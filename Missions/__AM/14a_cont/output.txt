// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Init ;
  11: CALL 76 0 0
// PrepareNature ( 4 , 3 , 3 , 5 , 1 , 0 , 0 , natureArea , 0 ) ;
  15: LD_INT 4
  17: PPUSH
  18: LD_INT 3
  20: PPUSH
  21: LD_INT 3
  23: PPUSH
  24: LD_INT 5
  26: PPUSH
  27: LD_INT 1
  29: PPUSH
  30: LD_INT 0
  32: PPUSH
  33: LD_INT 0
  35: PPUSH
  36: LD_INT 6
  38: PPUSH
  39: LD_INT 0
  41: PPUSH
  42: CALL 992 0 9
// PrepareAmerican ;
  46: CALL 5180 0 0
// PrepareAlliance ;
  50: CALL 189 0 0
// Action ;
  54: CALL 2141 0 0
// SaveForQuickRestart ;
  58: CALL_OW 22
// if debug then
  62: LD_EXP 1
  66: IFFALSE 75
// FogOff ( 7 ) ;
  68: LD_INT 7
  70: PPUSH
  71: CALL_OW 344
// end ;
  75: END
// export debug , activeBombTest , contaminateTime , bombExploded , enteredContaminatedArea , artifactPickedUp , planCaptured , seenBase , stevensTimer , canEnd , missionTime ; function Init ; begin
  76: LD_INT 0
  78: PPUSH
// debug := false ;
  79: LD_ADDR_EXP 1
  83: PUSH
  84: LD_INT 0
  86: ST_TO_ADDR
// activeBombTest := false ;
  87: LD_ADDR_EXP 2
  91: PUSH
  92: LD_INT 0
  94: ST_TO_ADDR
// bombExploded := false ;
  95: LD_ADDR_EXP 4
  99: PUSH
 100: LD_INT 0
 102: ST_TO_ADDR
// contaminateTime := 0 0$00 ;
 103: LD_ADDR_EXP 3
 107: PUSH
 108: LD_INT 0
 110: ST_TO_ADDR
// enteredContaminatedArea := false ;
 111: LD_ADDR_EXP 5
 115: PUSH
 116: LD_INT 0
 118: ST_TO_ADDR
// artifactPickedUp := false ;
 119: LD_ADDR_EXP 6
 123: PUSH
 124: LD_INT 0
 126: ST_TO_ADDR
// planCaptured := false ;
 127: LD_ADDR_EXP 7
 131: PUSH
 132: LD_INT 0
 134: ST_TO_ADDR
// seenBase := false ;
 135: LD_ADDR_EXP 8
 139: PUSH
 140: LD_INT 0
 142: ST_TO_ADDR
// stevensTimer := [ 20 20$00 , 16 16$00 , 11 11$00 ] [ Difficulty ] ;
 143: LD_ADDR_EXP 9
 147: PUSH
 148: LD_INT 42000
 150: PUSH
 151: LD_INT 33600
 153: PUSH
 154: LD_INT 23100
 156: PUSH
 157: EMPTY
 158: LIST
 159: LIST
 160: LIST
 161: PUSH
 162: LD_OWVAR 67
 166: ARRAY
 167: ST_TO_ADDR
// canEnd := false ;
 168: LD_ADDR_EXP 10
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// missionTime := 0 0$00 ;
 176: LD_ADDR_EXP 11
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// end ; end_of_file
 184: LD_VAR 0 1
 188: RET
// export JMM , Burlak , Joan , RuSci ; export function PrepareAlliance ; var tmp , i , JMMVeh , BurlakVeh , VarJMMVeh , VarBurlakVeh ; begin
 189: LD_INT 0
 191: PPUSH
 192: PPUSH
 193: PPUSH
 194: PPUSH
 195: PPUSH
 196: PPUSH
 197: PPUSH
// uc_side := 7 ;
 198: LD_ADDR_OWVAR 20
 202: PUSH
 203: LD_INT 7
 205: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
 206: LD_ADDR_EXP 12
 210: PUSH
 211: LD_STRING JMM
 213: PPUSH
 214: LD_EXP 1
 218: NOT
 219: PPUSH
 220: LD_STRING 14a_
 222: PPUSH
 223: CALL 871 0 3
 227: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
 228: LD_ADDR_EXP 13
 232: PUSH
 233: LD_STRING Burlak
 235: PPUSH
 236: LD_EXP 1
 240: NOT
 241: PPUSH
 242: LD_STRING 14a_
 244: PPUSH
 245: CALL 871 0 3
 249: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
 250: LD_ADDR_EXP 14
 254: PUSH
 255: LD_STRING Joan
 257: PPUSH
 258: LD_EXP 1
 262: NOT
 263: PPUSH
 264: LD_STRING 13a_
 266: PPUSH
 267: CALL 871 0 3
 271: ST_TO_ADDR
// if not Joan then
 272: LD_EXP 14
 276: NOT
 277: IFFALSE 410
// begin tmp := CreateCharacterSet ( 13a_others ) ;
 279: LD_ADDR_VAR 0 2
 283: PUSH
 284: LD_STRING 13a_others
 286: PPUSH
 287: CALL_OW 31
 291: ST_TO_ADDR
// if tmp then
 292: LD_VAR 0 2
 296: IFFALSE 372
// begin for i in tmp do
 298: LD_ADDR_VAR 0 3
 302: PUSH
 303: LD_VAR 0 2
 307: PUSH
 308: FOR_IN
 309: IFFALSE 370
// if GetClass ( i ) = 4 and GetSex ( i ) = sex_male and GetNation ( i ) = nation_russian then
 311: LD_VAR 0 3
 315: PPUSH
 316: CALL_OW 257
 320: PUSH
 321: LD_INT 4
 323: EQUAL
 324: PUSH
 325: LD_VAR 0 3
 329: PPUSH
 330: CALL_OW 258
 334: PUSH
 335: LD_INT 1
 337: EQUAL
 338: AND
 339: PUSH
 340: LD_VAR 0 3
 344: PPUSH
 345: CALL_OW 248
 349: PUSH
 350: LD_INT 3
 352: EQUAL
 353: AND
 354: IFFALSE 368
// begin RuSci := i ;
 356: LD_ADDR_EXP 15
 360: PUSH
 361: LD_VAR 0 3
 365: ST_TO_ADDR
// break ;
 366: GO 370
// end ;
 368: GO 308
 370: POP
 371: POP
// end ; if not RuSci then
 372: LD_EXP 15
 376: NOT
 377: IFFALSE 410
// begin uc_nation := 3 ;
 379: LD_ADDR_OWVAR 21
 383: PUSH
 384: LD_INT 3
 386: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 10 ) ;
 387: LD_INT 1
 389: PPUSH
 390: LD_INT 4
 392: PPUSH
 393: LD_INT 10
 395: PPUSH
 396: CALL_OW 380
// RuSci := CreateHuman ;
 400: LD_ADDR_EXP 15
 404: PUSH
 405: CALL_OW 44
 409: ST_TO_ADDR
// end ; end ; VarJMMVeh := LoadVariable ( 14a_JMMVeh , [ us_morphling , engine_siberite , control_manual , us_rocket_launcher , 0 , 1 ] ) ;
 410: LD_ADDR_VAR 0 6
 414: PUSH
 415: LD_STRING 14a_JMMVeh
 417: PPUSH
 418: LD_INT 5
 420: PUSH
 421: LD_INT 3
 423: PUSH
 424: LD_INT 1
 426: PUSH
 427: LD_INT 7
 429: PUSH
 430: LD_INT 0
 432: PUSH
 433: LD_INT 1
 435: PUSH
 436: EMPTY
 437: LIST
 438: LIST
 439: LIST
 440: LIST
 441: LIST
 442: LIST
 443: PPUSH
 444: CALL_OW 30
 448: ST_TO_ADDR
// VarBurlakVeh := LoadVariable ( 14a_BurlakVeh , [ ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 0 , 3 ] ) ;
 449: LD_ADDR_VAR 0 7
 453: PUSH
 454: LD_STRING 14a_BurlakVeh
 456: PPUSH
 457: LD_INT 22
 459: PUSH
 460: LD_INT 3
 462: PUSH
 463: LD_INT 1
 465: PUSH
 466: LD_INT 51
 468: PUSH
 469: LD_INT 0
 471: PUSH
 472: LD_INT 3
 474: PUSH
 475: EMPTY
 476: LIST
 477: LIST
 478: LIST
 479: LIST
 480: LIST
 481: LIST
 482: PPUSH
 483: CALL_OW 30
 487: ST_TO_ADDR
// uc_direction := 4 ;
 488: LD_ADDR_OWVAR 24
 492: PUSH
 493: LD_INT 4
 495: ST_TO_ADDR
// uc_nation := VarJMMVeh [ 6 ] ;
 496: LD_ADDR_OWVAR 21
 500: PUSH
 501: LD_VAR 0 6
 505: PUSH
 506: LD_INT 6
 508: ARRAY
 509: ST_TO_ADDR
// PrepareVehicle ( VarJMMVeh [ 1 ] , VarJMMVeh [ 2 ] , VarJMMVeh [ 3 ] , VarJMMVeh [ 4 ] , rand ( 60 , 80 ) ) ;
 510: LD_VAR 0 6
 514: PUSH
 515: LD_INT 1
 517: ARRAY
 518: PPUSH
 519: LD_VAR 0 6
 523: PUSH
 524: LD_INT 2
 526: ARRAY
 527: PPUSH
 528: LD_VAR 0 6
 532: PUSH
 533: LD_INT 3
 535: ARRAY
 536: PPUSH
 537: LD_VAR 0 6
 541: PUSH
 542: LD_INT 4
 544: ARRAY
 545: PPUSH
 546: LD_INT 60
 548: PPUSH
 549: LD_INT 80
 551: PPUSH
 552: CALL_OW 12
 556: PPUSH
 557: CALL 934 0 5
// JMMVeh := CreateVehicle ;
 561: LD_ADDR_VAR 0 4
 565: PUSH
 566: CALL_OW 45
 570: ST_TO_ADDR
// PlaceUnitInArea ( JMMVeh , startArea , false ) ;
 571: LD_VAR 0 4
 575: PPUSH
 576: LD_INT 1
 578: PPUSH
 579: LD_INT 0
 581: PPUSH
 582: CALL 1596 0 3
// if VarJMMVeh [ 5 ] <> 0 then
 586: LD_VAR 0 6
 590: PUSH
 591: LD_INT 5
 593: ARRAY
 594: PUSH
 595: LD_INT 0
 597: NONEQUAL
 598: IFFALSE 618
// SetMark ( JMMVeh , VarJMMVeh [ 5 ] ) ;
 600: LD_VAR 0 4
 604: PPUSH
 605: LD_VAR 0 6
 609: PUSH
 610: LD_INT 5
 612: ARRAY
 613: PPUSH
 614: CALL_OW 242
// PlaceHumanInUnit ( JMM , JMMVeh ) ;
 618: LD_EXP 12
 622: PPUSH
 623: LD_VAR 0 4
 627: PPUSH
 628: CALL_OW 52
// uc_nation := VarBurlakVeh [ 6 ] ;
 632: LD_ADDR_OWVAR 21
 636: PUSH
 637: LD_VAR 0 7
 641: PUSH
 642: LD_INT 6
 644: ARRAY
 645: ST_TO_ADDR
// PrepareVehicle ( VarBurlakVeh [ 1 ] , VarBurlakVeh [ 2 ] , VarBurlakVeh [ 3 ] , VarBurlakVeh [ 4 ] , rand ( 60 , 80 ) ) ;
 646: LD_VAR 0 7
 650: PUSH
 651: LD_INT 1
 653: ARRAY
 654: PPUSH
 655: LD_VAR 0 7
 659: PUSH
 660: LD_INT 2
 662: ARRAY
 663: PPUSH
 664: LD_VAR 0 7
 668: PUSH
 669: LD_INT 3
 671: ARRAY
 672: PPUSH
 673: LD_VAR 0 7
 677: PUSH
 678: LD_INT 4
 680: ARRAY
 681: PPUSH
 682: LD_INT 60
 684: PPUSH
 685: LD_INT 80
 687: PPUSH
 688: CALL_OW 12
 692: PPUSH
 693: CALL 934 0 5
// BurlakVeh := CreateVehicle ;
 697: LD_ADDR_VAR 0 5
 701: PUSH
 702: CALL_OW 45
 706: ST_TO_ADDR
// if not PlaceUnitInArea ( BurlakVeh , startArea , false ) then
 707: LD_VAR 0 5
 711: PPUSH
 712: LD_INT 1
 714: PPUSH
 715: LD_INT 0
 717: PPUSH
 718: CALL 1596 0 3
 722: NOT
 723: IFFALSE 743
// PlaceUnitXY ( BurlakVeh , 233 , 85 , false ) ;
 725: LD_VAR 0 5
 729: PPUSH
 730: LD_INT 233
 732: PPUSH
 733: LD_INT 85
 735: PPUSH
 736: LD_INT 0
 738: PPUSH
 739: CALL_OW 48
// if VarBurlakVeh [ 5 ] <> 0 then
 743: LD_VAR 0 7
 747: PUSH
 748: LD_INT 5
 750: ARRAY
 751: PUSH
 752: LD_INT 0
 754: NONEQUAL
 755: IFFALSE 775
// SetMark ( BurlakVeh , VarBurlakVeh [ 5 ] ) ;
 757: LD_VAR 0 5
 761: PPUSH
 762: LD_VAR 0 7
 766: PUSH
 767: LD_INT 5
 769: ARRAY
 770: PPUSH
 771: CALL_OW 242
// PlaceHumanInUnit ( Burlak , BurlakVeh ) ;
 775: LD_EXP 13
 779: PPUSH
 780: LD_VAR 0 5
 784: PPUSH
 785: CALL_OW 52
// tmp := [ [ 178 , 91 ] , [ 137 , 83 ] , [ 157 , 75 ] ] [ Difficulty ] ;
 789: LD_ADDR_VAR 0 2
 793: PUSH
 794: LD_INT 178
 796: PUSH
 797: LD_INT 91
 799: PUSH
 800: EMPTY
 801: LIST
 802: LIST
 803: PUSH
 804: LD_INT 137
 806: PUSH
 807: LD_INT 83
 809: PUSH
 810: EMPTY
 811: LIST
 812: LIST
 813: PUSH
 814: LD_INT 157
 816: PUSH
 817: LD_INT 75
 819: PUSH
 820: EMPTY
 821: LIST
 822: LIST
 823: PUSH
 824: EMPTY
 825: LIST
 826: LIST
 827: LIST
 828: PUSH
 829: LD_OWVAR 67
 833: ARRAY
 834: ST_TO_ADDR
// CreateResourcesXY ( mat_artifact , 4 , tmp [ 1 ] , tmp [ 2 ] , false ) ;
 835: LD_INT 4
 837: PPUSH
 838: LD_INT 4
 840: PPUSH
 841: LD_VAR 0 2
 845: PUSH
 846: LD_INT 1
 848: ARRAY
 849: PPUSH
 850: LD_VAR 0 2
 854: PUSH
 855: LD_INT 2
 857: ARRAY
 858: PPUSH
 859: LD_INT 0
 861: PPUSH
 862: CALL_OW 58
// end ; end_of_file
 866: LD_VAR 0 1
 870: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 871: LD_INT 0
 873: PPUSH
 874: PPUSH
// if exist_mode then
 875: LD_VAR 0 2
 879: IFFALSE 904
// unit := CreateCharacter ( prefix & ident ) else
 881: LD_ADDR_VAR 0 5
 885: PUSH
 886: LD_VAR 0 3
 890: PUSH
 891: LD_VAR 0 1
 895: STR
 896: PPUSH
 897: CALL_OW 34
 901: ST_TO_ADDR
 902: GO 919
// unit := NewCharacter ( ident ) ;
 904: LD_ADDR_VAR 0 5
 908: PUSH
 909: LD_VAR 0 1
 913: PPUSH
 914: CALL_OW 25
 918: ST_TO_ADDR
// result := unit ;
 919: LD_ADDR_VAR 0 4
 923: PUSH
 924: LD_VAR 0 5
 928: ST_TO_ADDR
// end ;
 929: LD_VAR 0 4
 933: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
 934: LD_INT 0
 936: PPUSH
// vc_chassis := chassis ;
 937: LD_ADDR_OWVAR 37
 941: PUSH
 942: LD_VAR 0 1
 946: ST_TO_ADDR
// vc_engine := engine ;
 947: LD_ADDR_OWVAR 39
 951: PUSH
 952: LD_VAR 0 2
 956: ST_TO_ADDR
// vc_control := control ;
 957: LD_ADDR_OWVAR 38
 961: PUSH
 962: LD_VAR 0 3
 966: ST_TO_ADDR
// vc_weapon := weapon ;
 967: LD_ADDR_OWVAR 40
 971: PUSH
 972: LD_VAR 0 4
 976: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 977: LD_ADDR_OWVAR 41
 981: PUSH
 982: LD_VAR 0 5
 986: ST_TO_ADDR
// end ;
 987: LD_VAR 0 6
 991: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
 992: LD_INT 0
 994: PPUSH
 995: PPUSH
 996: PPUSH
// uc_side = 0 ;
 997: LD_ADDR_OWVAR 20
1001: PUSH
1002: LD_INT 0
1004: ST_TO_ADDR
// uc_nation = 0 ;
1005: LD_ADDR_OWVAR 21
1009: PUSH
1010: LD_INT 0
1012: ST_TO_ADDR
// InitHc ;
1013: CALL_OW 19
// InitVc ;
1017: CALL_OW 20
// if mastodonts then
1021: LD_VAR 0 6
1025: IFFALSE 1092
// for i = 1 to mastodonts do
1027: LD_ADDR_VAR 0 11
1031: PUSH
1032: DOUBLE
1033: LD_INT 1
1035: DEC
1036: ST_TO_ADDR
1037: LD_VAR 0 6
1041: PUSH
1042: FOR_TO
1043: IFFALSE 1090
// begin vc_chassis := 31 ;
1045: LD_ADDR_OWVAR 37
1049: PUSH
1050: LD_INT 31
1052: ST_TO_ADDR
// vc_control := control_rider ;
1053: LD_ADDR_OWVAR 38
1057: PUSH
1058: LD_INT 4
1060: ST_TO_ADDR
// animal := CreateVehicle ;
1061: LD_ADDR_VAR 0 12
1065: PUSH
1066: CALL_OW 45
1070: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1071: LD_VAR 0 12
1075: PPUSH
1076: LD_VAR 0 8
1080: PPUSH
1081: LD_INT 0
1083: PPUSH
1084: CALL 1596 0 3
// end ;
1088: GO 1042
1090: POP
1091: POP
// if horses then
1092: LD_VAR 0 5
1096: IFFALSE 1163
// for i = 1 to horses do
1098: LD_ADDR_VAR 0 11
1102: PUSH
1103: DOUBLE
1104: LD_INT 1
1106: DEC
1107: ST_TO_ADDR
1108: LD_VAR 0 5
1112: PUSH
1113: FOR_TO
1114: IFFALSE 1161
// begin hc_class := 21 ;
1116: LD_ADDR_OWVAR 28
1120: PUSH
1121: LD_INT 21
1123: ST_TO_ADDR
// hc_gallery :=  ;
1124: LD_ADDR_OWVAR 33
1128: PUSH
1129: LD_STRING 
1131: ST_TO_ADDR
// animal := CreateHuman ;
1132: LD_ADDR_VAR 0 12
1136: PUSH
1137: CALL_OW 44
1141: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1142: LD_VAR 0 12
1146: PPUSH
1147: LD_VAR 0 8
1151: PPUSH
1152: LD_INT 0
1154: PPUSH
1155: CALL 1596 0 3
// end ;
1159: GO 1113
1161: POP
1162: POP
// if birds then
1163: LD_VAR 0 1
1167: IFFALSE 1234
// for i = 1 to birds do
1169: LD_ADDR_VAR 0 11
1173: PUSH
1174: DOUBLE
1175: LD_INT 1
1177: DEC
1178: ST_TO_ADDR
1179: LD_VAR 0 1
1183: PUSH
1184: FOR_TO
1185: IFFALSE 1232
// begin hc_class = 18 ;
1187: LD_ADDR_OWVAR 28
1191: PUSH
1192: LD_INT 18
1194: ST_TO_ADDR
// hc_gallery =  ;
1195: LD_ADDR_OWVAR 33
1199: PUSH
1200: LD_STRING 
1202: ST_TO_ADDR
// animal := CreateHuman ;
1203: LD_ADDR_VAR 0 12
1207: PUSH
1208: CALL_OW 44
1212: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1213: LD_VAR 0 12
1217: PPUSH
1218: LD_VAR 0 8
1222: PPUSH
1223: LD_INT 0
1225: PPUSH
1226: CALL 1596 0 3
// end ;
1230: GO 1184
1232: POP
1233: POP
// if tigers then
1234: LD_VAR 0 2
1238: IFFALSE 1322
// for i = 1 to tigers do
1240: LD_ADDR_VAR 0 11
1244: PUSH
1245: DOUBLE
1246: LD_INT 1
1248: DEC
1249: ST_TO_ADDR
1250: LD_VAR 0 2
1254: PUSH
1255: FOR_TO
1256: IFFALSE 1320
// begin hc_class = class_tiger ;
1258: LD_ADDR_OWVAR 28
1262: PUSH
1263: LD_INT 14
1265: ST_TO_ADDR
// hc_gallery =  ;
1266: LD_ADDR_OWVAR 33
1270: PUSH
1271: LD_STRING 
1273: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
1274: LD_ADDR_OWVAR 35
1278: PUSH
1279: LD_INT 7
1281: NEG
1282: PPUSH
1283: LD_INT 7
1285: PPUSH
1286: CALL_OW 12
1290: ST_TO_ADDR
// animal := CreateHuman ;
1291: LD_ADDR_VAR 0 12
1295: PUSH
1296: CALL_OW 44
1300: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1301: LD_VAR 0 12
1305: PPUSH
1306: LD_VAR 0 8
1310: PPUSH
1311: LD_INT 0
1313: PPUSH
1314: CALL 1596 0 3
// end ;
1318: GO 1255
1320: POP
1321: POP
// if apemans then
1322: LD_VAR 0 3
1326: IFFALSE 1449
// for i = 1 to apemans do
1328: LD_ADDR_VAR 0 11
1332: PUSH
1333: DOUBLE
1334: LD_INT 1
1336: DEC
1337: ST_TO_ADDR
1338: LD_VAR 0 3
1342: PUSH
1343: FOR_TO
1344: IFFALSE 1447
// begin hc_class = class_apeman ;
1346: LD_ADDR_OWVAR 28
1350: PUSH
1351: LD_INT 12
1353: ST_TO_ADDR
// hc_gallery =  ;
1354: LD_ADDR_OWVAR 33
1358: PUSH
1359: LD_STRING 
1361: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
1362: LD_ADDR_OWVAR 35
1366: PUSH
1367: LD_INT 5
1369: NEG
1370: PPUSH
1371: LD_INT 5
1373: PPUSH
1374: CALL_OW 12
1378: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
1379: LD_ADDR_OWVAR 31
1383: PUSH
1384: LD_INT 1
1386: PPUSH
1387: LD_INT 3
1389: PPUSH
1390: CALL_OW 12
1394: PUSH
1395: LD_INT 1
1397: PPUSH
1398: LD_INT 3
1400: PPUSH
1401: CALL_OW 12
1405: PUSH
1406: LD_INT 0
1408: PUSH
1409: LD_INT 0
1411: PUSH
1412: EMPTY
1413: LIST
1414: LIST
1415: LIST
1416: LIST
1417: ST_TO_ADDR
// animal := CreateHuman ;
1418: LD_ADDR_VAR 0 12
1422: PUSH
1423: CALL_OW 44
1427: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1428: LD_VAR 0 12
1432: PPUSH
1433: LD_VAR 0 8
1437: PPUSH
1438: LD_INT 0
1440: PPUSH
1441: CALL 1596 0 3
// end ;
1445: GO 1343
1447: POP
1448: POP
// if enchidnas then
1449: LD_VAR 0 4
1453: IFFALSE 1520
// for i = 1 to enchidnas do
1455: LD_ADDR_VAR 0 11
1459: PUSH
1460: DOUBLE
1461: LD_INT 1
1463: DEC
1464: ST_TO_ADDR
1465: LD_VAR 0 4
1469: PUSH
1470: FOR_TO
1471: IFFALSE 1518
// begin hc_class = 13 ;
1473: LD_ADDR_OWVAR 28
1477: PUSH
1478: LD_INT 13
1480: ST_TO_ADDR
// hc_gallery =  ;
1481: LD_ADDR_OWVAR 33
1485: PUSH
1486: LD_STRING 
1488: ST_TO_ADDR
// animal := CreateHuman ;
1489: LD_ADDR_VAR 0 12
1493: PUSH
1494: CALL_OW 44
1498: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1499: LD_VAR 0 12
1503: PPUSH
1504: LD_VAR 0 8
1508: PPUSH
1509: LD_INT 0
1511: PPUSH
1512: CALL 1596 0 3
// end ;
1516: GO 1470
1518: POP
1519: POP
// if fishes then
1520: LD_VAR 0 7
1524: IFFALSE 1591
// for i = 1 to fishes do
1526: LD_ADDR_VAR 0 11
1530: PUSH
1531: DOUBLE
1532: LD_INT 1
1534: DEC
1535: ST_TO_ADDR
1536: LD_VAR 0 7
1540: PUSH
1541: FOR_TO
1542: IFFALSE 1589
// begin hc_class = 20 ;
1544: LD_ADDR_OWVAR 28
1548: PUSH
1549: LD_INT 20
1551: ST_TO_ADDR
// hc_gallery =  ;
1552: LD_ADDR_OWVAR 33
1556: PUSH
1557: LD_STRING 
1559: ST_TO_ADDR
// animal := CreateHuman ;
1560: LD_ADDR_VAR 0 12
1564: PUSH
1565: CALL_OW 44
1569: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
1570: LD_VAR 0 12
1574: PPUSH
1575: LD_VAR 0 9
1579: PPUSH
1580: LD_INT 0
1582: PPUSH
1583: CALL 1596 0 3
// end ;
1587: GO 1541
1589: POP
1590: POP
// end ;
1591: LD_VAR 0 10
1595: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
1596: LD_INT 0
1598: PPUSH
1599: PPUSH
1600: PPUSH
1601: PPUSH
// if not unit or not area then
1602: LD_VAR 0 1
1606: NOT
1607: PUSH
1608: LD_VAR 0 2
1612: NOT
1613: OR
1614: IFFALSE 1618
// exit ;
1616: GO 1782
// tmp := AreaToList ( area , i ) ;
1618: LD_ADDR_VAR 0 6
1622: PUSH
1623: LD_VAR 0 2
1627: PPUSH
1628: LD_VAR 0 5
1632: PPUSH
1633: CALL_OW 517
1637: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
1638: LD_ADDR_VAR 0 5
1642: PUSH
1643: DOUBLE
1644: LD_INT 1
1646: DEC
1647: ST_TO_ADDR
1648: LD_VAR 0 6
1652: PUSH
1653: LD_INT 1
1655: ARRAY
1656: PUSH
1657: FOR_TO
1658: IFFALSE 1780
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
1660: LD_ADDR_VAR 0 7
1664: PUSH
1665: LD_VAR 0 6
1669: PUSH
1670: LD_INT 1
1672: ARRAY
1673: PUSH
1674: LD_VAR 0 5
1678: ARRAY
1679: PUSH
1680: LD_VAR 0 6
1684: PUSH
1685: LD_INT 2
1687: ARRAY
1688: PUSH
1689: LD_VAR 0 5
1693: ARRAY
1694: PUSH
1695: EMPTY
1696: LIST
1697: LIST
1698: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
1699: LD_VAR 0 7
1703: PUSH
1704: LD_INT 1
1706: ARRAY
1707: PPUSH
1708: LD_VAR 0 7
1712: PUSH
1713: LD_INT 2
1715: ARRAY
1716: PPUSH
1717: CALL_OW 428
1721: PUSH
1722: LD_INT 0
1724: EQUAL
1725: IFFALSE 1778
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
1727: LD_VAR 0 1
1731: PPUSH
1732: LD_VAR 0 7
1736: PUSH
1737: LD_INT 1
1739: ARRAY
1740: PPUSH
1741: LD_VAR 0 7
1745: PUSH
1746: LD_INT 2
1748: ARRAY
1749: PPUSH
1750: LD_VAR 0 3
1754: PPUSH
1755: CALL_OW 48
// result := IsPlaced ( unit ) ;
1759: LD_ADDR_VAR 0 4
1763: PUSH
1764: LD_VAR 0 1
1768: PPUSH
1769: CALL_OW 305
1773: ST_TO_ADDR
// exit ;
1774: POP
1775: POP
1776: GO 1782
// end ; end ;
1778: GO 1657
1780: POP
1781: POP
// end ;
1782: LD_VAR 0 4
1786: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
1787: LD_INT 0
1789: PPUSH
1790: PPUSH
1791: PPUSH
1792: PPUSH
1793: PPUSH
1794: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
1795: LD_VAR 0 1
1799: NOT
1800: PUSH
1801: LD_VAR 0 1
1805: PPUSH
1806: CALL_OW 263
1810: PUSH
1811: LD_INT 2
1813: EQUAL
1814: NOT
1815: OR
1816: IFFALSE 1820
// exit ;
1818: GO 2136
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
1820: LD_ADDR_VAR 0 6
1824: PUSH
1825: LD_INT 22
1827: PUSH
1828: LD_VAR 0 1
1832: PPUSH
1833: CALL_OW 255
1837: PUSH
1838: EMPTY
1839: LIST
1840: LIST
1841: PUSH
1842: LD_INT 2
1844: PUSH
1845: LD_INT 30
1847: PUSH
1848: LD_INT 36
1850: PUSH
1851: EMPTY
1852: LIST
1853: LIST
1854: PUSH
1855: LD_INT 34
1857: PUSH
1858: LD_INT 31
1860: PUSH
1861: EMPTY
1862: LIST
1863: LIST
1864: PUSH
1865: EMPTY
1866: LIST
1867: LIST
1868: LIST
1869: PUSH
1870: EMPTY
1871: LIST
1872: LIST
1873: PPUSH
1874: CALL_OW 69
1878: ST_TO_ADDR
// if not tmp then
1879: LD_VAR 0 6
1883: NOT
1884: IFFALSE 1888
// exit ;
1886: GO 2136
// result := [ ] ;
1888: LD_ADDR_VAR 0 2
1892: PUSH
1893: EMPTY
1894: ST_TO_ADDR
// for i in tmp do
1895: LD_ADDR_VAR 0 3
1899: PUSH
1900: LD_VAR 0 6
1904: PUSH
1905: FOR_IN
1906: IFFALSE 1977
// begin t := UnitsInside ( i ) ;
1908: LD_ADDR_VAR 0 4
1912: PUSH
1913: LD_VAR 0 3
1917: PPUSH
1918: CALL_OW 313
1922: ST_TO_ADDR
// if t then
1923: LD_VAR 0 4
1927: IFFALSE 1975
// for j in t do
1929: LD_ADDR_VAR 0 7
1933: PUSH
1934: LD_VAR 0 4
1938: PUSH
1939: FOR_IN
1940: IFFALSE 1973
// result := Insert ( result , result + 1 , j ) ;
1942: LD_ADDR_VAR 0 2
1946: PUSH
1947: LD_VAR 0 2
1951: PPUSH
1952: LD_VAR 0 2
1956: PUSH
1957: LD_INT 1
1959: PLUS
1960: PPUSH
1961: LD_VAR 0 7
1965: PPUSH
1966: CALL_OW 2
1970: ST_TO_ADDR
1971: GO 1939
1973: POP
1974: POP
// end ;
1975: GO 1905
1977: POP
1978: POP
// if not result then
1979: LD_VAR 0 2
1983: NOT
1984: IFFALSE 1988
// exit ;
1986: GO 2136
// mech := result [ 1 ] ;
1988: LD_ADDR_VAR 0 5
1992: PUSH
1993: LD_VAR 0 2
1997: PUSH
1998: LD_INT 1
2000: ARRAY
2001: ST_TO_ADDR
// if result > 1 then
2002: LD_VAR 0 2
2006: PUSH
2007: LD_INT 1
2009: GREATER
2010: IFFALSE 2122
// for i = 2 to result do
2012: LD_ADDR_VAR 0 3
2016: PUSH
2017: DOUBLE
2018: LD_INT 2
2020: DEC
2021: ST_TO_ADDR
2022: LD_VAR 0 2
2026: PUSH
2027: FOR_TO
2028: IFFALSE 2120
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
2030: LD_ADDR_VAR 0 4
2034: PUSH
2035: LD_VAR 0 2
2039: PUSH
2040: LD_VAR 0 3
2044: ARRAY
2045: PPUSH
2046: LD_INT 3
2048: PPUSH
2049: CALL_OW 259
2053: PUSH
2054: LD_VAR 0 2
2058: PUSH
2059: LD_VAR 0 3
2063: ARRAY
2064: PPUSH
2065: CALL_OW 432
2069: MINUS
2070: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
2071: LD_VAR 0 4
2075: PUSH
2076: LD_VAR 0 5
2080: PPUSH
2081: LD_INT 3
2083: PPUSH
2084: CALL_OW 259
2088: PUSH
2089: LD_VAR 0 5
2093: PPUSH
2094: CALL_OW 432
2098: MINUS
2099: GREATEREQUAL
2100: IFFALSE 2118
// mech := result [ i ] ;
2102: LD_ADDR_VAR 0 5
2106: PUSH
2107: LD_VAR 0 2
2111: PUSH
2112: LD_VAR 0 3
2116: ARRAY
2117: ST_TO_ADDR
// end ;
2118: GO 2027
2120: POP
2121: POP
// ComLinkTo ( vehicle , mech ) ;
2122: LD_VAR 0 1
2126: PPUSH
2127: LD_VAR 0 5
2131: PPUSH
2132: CALL_OW 135
// end ; end_of_file
2136: LD_VAR 0 2
2140: RET
// export function Action ; begin
2141: LD_INT 0
2143: PPUSH
// InGameOn ;
2144: CALL_OW 8
// CenterNowOnXY ( 221 , 80 ) ;
2148: LD_INT 221
2150: PPUSH
2151: LD_INT 80
2153: PPUSH
2154: CALL_OW 86
// ComMoveXY ( [ JMM , Burlak ] , 217 , 79 ) ;
2158: LD_EXP 12
2162: PUSH
2163: LD_EXP 13
2167: PUSH
2168: EMPTY
2169: LIST
2170: LIST
2171: PPUSH
2172: LD_INT 217
2174: PPUSH
2175: LD_INT 79
2177: PPUSH
2178: CALL_OW 111
// wait ( 0 0$7 ) ;
2182: LD_INT 245
2184: PPUSH
2185: CALL_OW 67
// ComExitVehicle ( [ JMM , Burlak ] ) ;
2189: LD_EXP 12
2193: PUSH
2194: LD_EXP 13
2198: PUSH
2199: EMPTY
2200: LIST
2201: LIST
2202: PPUSH
2203: CALL_OW 121
// Say ( Burlak , D2-Bur-1 ) ;
2207: LD_EXP 13
2211: PPUSH
2212: LD_STRING D2-Bur-1
2214: PPUSH
2215: CALL_OW 88
// Say ( JMM , D2-JMM-1 ) ;
2219: LD_EXP 12
2223: PPUSH
2224: LD_STRING D2-JMM-1
2226: PPUSH
2227: CALL_OW 88
// wait ( 0 0$0.5 ) ;
2231: LD_INT 18
2233: PPUSH
2234: CALL_OW 67
// ComTurnUnit ( Burlak , JMM ) ;
2238: LD_EXP 13
2242: PPUSH
2243: LD_EXP 12
2247: PPUSH
2248: CALL_OW 119
// Say ( Burlak , D2-Bur-2 ) ;
2252: LD_EXP 13
2256: PPUSH
2257: LD_STRING D2-Bur-2
2259: PPUSH
2260: CALL_OW 88
// ComEnterUnit ( Burlak , NearestUnitToUnit ( FilterAllUnits ( [ f_type , unit_vehicle ] ) , Burlak ) ) ;
2264: LD_EXP 13
2268: PPUSH
2269: LD_INT 21
2271: PUSH
2272: LD_INT 2
2274: PUSH
2275: EMPTY
2276: LIST
2277: LIST
2278: PPUSH
2279: CALL_OW 69
2283: PPUSH
2284: LD_EXP 13
2288: PPUSH
2289: CALL_OW 74
2293: PPUSH
2294: CALL_OW 120
// ComEnterUnit ( JMM , NearestUnitToUnit ( FilterAllUnits ( [ f_type , unit_vehicle ] ) , JMM ) ) ;
2298: LD_EXP 12
2302: PPUSH
2303: LD_INT 21
2305: PUSH
2306: LD_INT 2
2308: PUSH
2309: EMPTY
2310: LIST
2311: LIST
2312: PPUSH
2313: CALL_OW 69
2317: PPUSH
2318: LD_EXP 12
2322: PPUSH
2323: CALL_OW 74
2327: PPUSH
2328: CALL_OW 120
// wait ( 0 0$1 ) ;
2332: LD_INT 35
2334: PPUSH
2335: CALL_OW 67
// InGameOff ;
2339: CALL_OW 9
// ChangeMissionObjectives ( MArtPickup ) ;
2343: LD_STRING MArtPickup
2345: PPUSH
2346: CALL_OW 337
// end ;
2350: LD_VAR 0 1
2354: RET
// every 0 0$1 trigger UnitFilter ( guards , [ f_see , 7 ] ) do
2355: LD_EXP 20
2359: PPUSH
2360: LD_INT 101
2362: PUSH
2363: LD_INT 7
2365: PUSH
2366: EMPTY
2367: LIST
2368: LIST
2369: PPUSH
2370: CALL_OW 72
2374: IFFALSE 2403
2376: GO 2378
2378: DISABLE
// begin Say ( Burlak , D3-Bur-1 ) ;
2379: LD_EXP 13
2383: PPUSH
2384: LD_STRING D3-Bur-1
2386: PPUSH
2387: CALL_OW 88
// Say ( JMM , D3-JMM-1 ) ;
2391: LD_EXP 12
2395: PPUSH
2396: LD_STRING D3-JMM-1
2398: PPUSH
2399: CALL_OW 88
// end ;
2403: END
// every 0 0$2 trigger FilterUnitsInArea ( usTestBase , [ f_side , 7 ] ) do
2404: LD_INT 5
2406: PPUSH
2407: LD_INT 22
2409: PUSH
2410: LD_INT 7
2412: PUSH
2413: EMPTY
2414: LIST
2415: LIST
2416: PPUSH
2417: CALL_OW 70
2421: IFFALSE 2752
2423: GO 2425
2425: DISABLE
// begin wait ( 0 0$3 ) ;
2426: LD_INT 105
2428: PPUSH
2429: CALL_OW 67
// DialogueOn ;
2433: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
2437: LD_EXP 12
2441: PPUSH
2442: CALL_OW 87
// Say ( JMM , D3a-JMM-1 ) ;
2446: LD_EXP 12
2450: PPUSH
2451: LD_STRING D3a-JMM-1
2453: PPUSH
2454: CALL_OW 88
// Say ( Burlak , D3a-Bur-1 ) ;
2458: LD_EXP 13
2462: PPUSH
2463: LD_STRING D3a-Bur-1
2465: PPUSH
2466: CALL_OW 88
// Say ( JMM , D3a-JMM-2 ) ;
2470: LD_EXP 12
2474: PPUSH
2475: LD_STRING D3a-JMM-2
2477: PPUSH
2478: CALL_OW 88
// if Joan then
2482: LD_EXP 14
2486: IFFALSE 2502
// SayRadio ( Joan , D3a-Joan-2 ) else
2488: LD_EXP 14
2492: PPUSH
2493: LD_STRING D3a-Joan-2
2495: PPUSH
2496: CALL_OW 94
2500: GO 2514
// SayRadio ( RuSci , D3a-RSci1-2 ) ;
2502: LD_EXP 15
2506: PPUSH
2507: LD_STRING D3a-RSci1-2
2509: PPUSH
2510: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-2 ) ;
2514: LD_EXP 16
2518: PPUSH
2519: LD_STRING D3a-Huck-2
2521: PPUSH
2522: CALL_OW 94
// SayRadio ( Powell , D3a-Pow-2 ) ;
2526: LD_EXP 17
2530: PPUSH
2531: LD_STRING D3a-Pow-2
2533: PPUSH
2534: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-3 ) ;
2538: LD_EXP 16
2542: PPUSH
2543: LD_STRING D3a-Huck-3
2545: PPUSH
2546: CALL_OW 94
// SayRadio ( Powell , D3a-Pow-3 ) ;
2550: LD_EXP 17
2554: PPUSH
2555: LD_STRING D3a-Pow-3
2557: PPUSH
2558: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-4 ) ;
2562: LD_EXP 16
2566: PPUSH
2567: LD_STRING D3a-Huck-4
2569: PPUSH
2570: CALL_OW 94
// Say ( JMM , D3a-JMM-4 ) ;
2574: LD_EXP 12
2578: PPUSH
2579: LD_STRING D3a-JMM-4
2581: PPUSH
2582: CALL_OW 88
// Say ( Burlak , D3a-Bur-4 ) ;
2586: LD_EXP 13
2590: PPUSH
2591: LD_STRING D3a-Bur-4
2593: PPUSH
2594: CALL_OW 88
// if Joan then
2598: LD_EXP 14
2602: IFFALSE 2618
// SayRadio ( Joan , D3a-Joan-4 ) else
2604: LD_EXP 14
2608: PPUSH
2609: LD_STRING D3a-Joan-4
2611: PPUSH
2612: CALL_OW 94
2616: GO 2630
// SayRadio ( RuSci , D3a-RSci1-4 ) ;
2618: LD_EXP 15
2622: PPUSH
2623: LD_STRING D3a-RSci1-4
2625: PPUSH
2626: CALL_OW 94
// PlaceSeeing ( 133 , 43 , 7 , - 10 ) ;
2630: LD_INT 133
2632: PPUSH
2633: LD_INT 43
2635: PPUSH
2636: LD_INT 7
2638: PPUSH
2639: LD_INT 10
2641: NEG
2642: PPUSH
2643: CALL_OW 330
// RemoveSeeing ( 133 , 43 , 7 ) ;
2647: LD_INT 133
2649: PPUSH
2650: LD_INT 43
2652: PPUSH
2653: LD_INT 7
2655: PPUSH
2656: CALL_OW 331
// CenterNowOnXY ( 133 , 43 ) ;
2660: LD_INT 133
2662: PPUSH
2663: LD_INT 43
2665: PPUSH
2666: CALL_OW 86
// dwait ( 0 0$0.3 ) ;
2670: LD_INT 10
2672: PPUSH
2673: CALL_OW 68
// Say ( JMM , D3a-JMM-5 ) ;
2677: LD_EXP 12
2681: PPUSH
2682: LD_STRING D3a-JMM-5
2684: PPUSH
2685: CALL_OW 88
// Say ( Burlak , D3a-Bur-5 ) ;
2689: LD_EXP 13
2693: PPUSH
2694: LD_STRING D3a-Bur-5
2696: PPUSH
2697: CALL_OW 88
// DialogueOff ;
2701: CALL_OW 7
// seenBase := true ;
2705: LD_ADDR_EXP 8
2709: PUSH
2710: LD_INT 1
2712: ST_TO_ADDR
// wait ( [ 0 0$15 , 0 0$12 , 0 0$9 ] [ Difficulty ] ) ;
2713: LD_INT 525
2715: PUSH
2716: LD_INT 420
2718: PUSH
2719: LD_INT 315
2721: PUSH
2722: EMPTY
2723: LIST
2724: LIST
2725: LIST
2726: PUSH
2727: LD_OWVAR 67
2731: ARRAY
2732: PPUSH
2733: CALL_OW 67
// ComAttackPlace ( sibBomb , 142 , 52 ) ;
2737: LD_EXP 19
2741: PPUSH
2742: LD_INT 142
2744: PPUSH
2745: LD_INT 52
2747: PPUSH
2748: CALL_OW 116
// end ;
2752: END
// every 5 5$00 trigger not seenBase and not bombExploded do
2753: LD_EXP 8
2757: NOT
2758: PUSH
2759: LD_EXP 4
2763: NOT
2764: AND
2765: IFFALSE 2785
2767: GO 2769
2769: DISABLE
// ComAttackPlace ( sibBomb , 142 , 52 ) ;
2770: LD_EXP 19
2774: PPUSH
2775: LD_INT 142
2777: PPUSH
2778: LD_INT 52
2780: PPUSH
2781: CALL_OW 116
2785: END
// export function OnBombExploded ( bomb , x , y ) ; var art ; begin
2786: LD_INT 0
2788: PPUSH
2789: PPUSH
// contaminateTime := tick ;
2790: LD_ADDR_EXP 3
2794: PUSH
2795: LD_OWVAR 1
2799: ST_TO_ADDR
// wait ( 0 0$5 ) ;
2800: LD_INT 175
2802: PPUSH
2803: CALL_OW 67
// art := FindArtifact ( 4 ) ;
2807: LD_ADDR_VAR 0 5
2811: PUSH
2812: LD_INT 4
2814: PPUSH
2815: CALL_OW 469
2819: ST_TO_ADDR
// if art then
2820: LD_VAR 0 5
2824: IFFALSE 2863
// if art [ 1 ] = 157 and art [ 2 ] = 75 then
2826: LD_VAR 0 5
2830: PUSH
2831: LD_INT 1
2833: ARRAY
2834: PUSH
2835: LD_INT 157
2837: EQUAL
2838: PUSH
2839: LD_VAR 0 5
2843: PUSH
2844: LD_INT 2
2846: ARRAY
2847: PUSH
2848: LD_INT 75
2850: EQUAL
2851: AND
2852: IFFALSE 2863
// begin YouLost ( Artefact ) ;
2854: LD_STRING Artefact
2856: PPUSH
2857: CALL_OW 104
// exit ;
2861: GO 3015
// end ; if IsOK ( JMM ) and IsOk ( Burlak ) then
2863: LD_EXP 12
2867: PPUSH
2868: CALL_OW 302
2872: PUSH
2873: LD_EXP 13
2877: PPUSH
2878: CALL_OW 302
2882: AND
2883: IFFALSE 2960
// begin DialogueOn ;
2885: CALL_OW 6
// Say ( JMM , D6a-JMM-1 ) ;
2889: LD_EXP 12
2893: PPUSH
2894: LD_STRING D6a-JMM-1
2896: PPUSH
2897: CALL_OW 88
// Say ( Burlak , D6a-Bur-1 ) ;
2901: LD_EXP 13
2905: PPUSH
2906: LD_STRING D6a-Bur-1
2908: PPUSH
2909: CALL_OW 88
// Say ( JMM , D6c-JMM-1 ) ;
2913: LD_EXP 12
2917: PPUSH
2918: LD_STRING D6c-JMM-1
2920: PPUSH
2921: CALL_OW 88
// Say ( Burlak , D6c-Bur-1 ) ;
2925: LD_EXP 13
2929: PPUSH
2930: LD_STRING D6c-Bur-1
2932: PPUSH
2933: CALL_OW 88
// Say ( JMM , D6c-JMM-2 ) ;
2937: LD_EXP 12
2941: PPUSH
2942: LD_STRING D6c-JMM-2
2944: PPUSH
2945: CALL_OW 88
// ChangeMissionObjectives ( MBase ) ;
2949: LD_STRING MBase
2951: PPUSH
2952: CALL_OW 337
// DialogueOff ;
2956: CALL_OW 7
// end ; bombExploded := true ;
2960: LD_ADDR_EXP 4
2964: PUSH
2965: LD_INT 1
2967: ST_TO_ADDR
// wait ( [ 3 3$00 , 2 2$30 , 2 2$00 ] [ Difficulty ] ) ;
2968: LD_INT 6300
2970: PUSH
2971: LD_INT 5250
2973: PUSH
2974: LD_INT 4200
2976: PUSH
2977: EMPTY
2978: LIST
2979: LIST
2980: LIST
2981: PUSH
2982: LD_OWVAR 67
2986: ARRAY
2987: PPUSH
2988: CALL_OW 67
// if IsOk ( JMM ) then
2992: LD_EXP 12
2996: PPUSH
2997: CALL_OW 302
3001: IFFALSE 3015
// Say ( JMM , D8-JMM-1 ) ;
3003: LD_EXP 12
3007: PPUSH
3008: LD_STRING D8-JMM-1
3010: PPUSH
3011: CALL_OW 88
// end ;
3015: LD_VAR 0 4
3019: RET
// every 0 0$1 trigger stevensTimer and not planCaptured and bombExploded do
3020: LD_EXP 9
3024: PUSH
3025: LD_EXP 7
3029: NOT
3030: AND
3031: PUSH
3032: LD_EXP 4
3036: AND
3037: IFFALSE 3092
3039: GO 3041
3041: DISABLE
// begin enable ;
3042: ENABLE
// if FilterUnitsInArea ( usBase , [ f_side , 7 ] ) then
3043: LD_INT 9
3045: PPUSH
3046: LD_INT 22
3048: PUSH
3049: LD_INT 7
3051: PUSH
3052: EMPTY
3053: LIST
3054: LIST
3055: PPUSH
3056: CALL_OW 70
3060: IFFALSE 3078
// stevensTimer := stevensTimer - 0 0$30 else
3062: LD_ADDR_EXP 9
3066: PUSH
3067: LD_EXP 9
3071: PUSH
3072: LD_INT 1050
3074: MINUS
3075: ST_TO_ADDR
3076: GO 3092
// stevensTimer := stevensTimer - 0 0$1 ;
3078: LD_ADDR_EXP 9
3082: PUSH
3083: LD_EXP 9
3087: PUSH
3088: LD_INT 35
3090: MINUS
3091: ST_TO_ADDR
// end ;
3092: END
// every 0 0$1 trigger stevensTimer <= 0 0$00 and not planCaptured do var i , tmp ;
3093: LD_EXP 9
3097: PUSH
3098: LD_INT 0
3100: LESSEQUAL
3101: PUSH
3102: LD_EXP 7
3106: NOT
3107: AND
3108: IFFALSE 3272
3110: GO 3112
3112: DISABLE
3113: LD_INT 0
3115: PPUSH
3116: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
3117: LD_ADDR_VAR 0 2
3121: PUSH
3122: LD_INT 22
3124: PUSH
3125: LD_INT 1
3127: PUSH
3128: EMPTY
3129: LIST
3130: LIST
3131: PUSH
3132: LD_INT 25
3134: PUSH
3135: LD_INT 4
3137: PUSH
3138: EMPTY
3139: LIST
3140: LIST
3141: PUSH
3142: EMPTY
3143: LIST
3144: LIST
3145: PPUSH
3146: CALL_OW 69
3150: ST_TO_ADDR
// for i in tmp do
3151: LD_ADDR_VAR 0 1
3155: PUSH
3156: LD_VAR 0 2
3160: PUSH
3161: FOR_IN
3162: IFFALSE 3215
// begin if IsInUnit ( i ) then
3164: LD_VAR 0 1
3168: PPUSH
3169: CALL_OW 310
3173: IFFALSE 3186
// ComExitBuilding ( i ) else
3175: LD_VAR 0 1
3179: PPUSH
3180: CALL_OW 122
3184: GO 3213
// if not HasTask ( i ) then
3186: LD_VAR 0 1
3190: PPUSH
3191: CALL_OW 314
3195: NOT
3196: IFFALSE 3213
// ComMoveXY ( i , 29 , 56 ) ;
3198: LD_VAR 0 1
3202: PPUSH
3203: LD_INT 29
3205: PPUSH
3206: LD_INT 56
3208: PPUSH
3209: CALL_OW 111
// end ;
3213: GO 3161
3215: POP
3216: POP
// repeat wait ( 0 0$1 ) ;
3217: LD_INT 35
3219: PPUSH
3220: CALL_OW 67
// until FilterUnitsInArea ( stevensEscapeArea , [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
3224: LD_INT 8
3226: PPUSH
3227: LD_INT 22
3229: PUSH
3230: LD_INT 1
3232: PUSH
3233: EMPTY
3234: LIST
3235: LIST
3236: PUSH
3237: LD_INT 25
3239: PUSH
3240: LD_INT 4
3242: PUSH
3243: EMPTY
3244: LIST
3245: LIST
3246: PUSH
3247: EMPTY
3248: LIST
3249: LIST
3250: PPUSH
3251: CALL_OW 70
3255: IFFALSE 3217
// if planCaptured then
3257: LD_EXP 7
3261: IFFALSE 3265
// exit ;
3263: GO 3272
// YouLost ( Time ) ;
3265: LD_STRING Time
3267: PPUSH
3268: CALL_OW 104
// end ;
3272: PPOPN 2
3274: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_distxy , 142 , 52 , 27 ] ] ) and contaminateTime + 6000 > tick and bombExploded do
3275: LD_INT 22
3277: PUSH
3278: LD_INT 7
3280: PUSH
3281: EMPTY
3282: LIST
3283: LIST
3284: PUSH
3285: LD_INT 92
3287: PUSH
3288: LD_INT 142
3290: PUSH
3291: LD_INT 52
3293: PUSH
3294: LD_INT 27
3296: PUSH
3297: EMPTY
3298: LIST
3299: LIST
3300: LIST
3301: LIST
3302: PUSH
3303: EMPTY
3304: LIST
3305: LIST
3306: PPUSH
3307: CALL_OW 69
3311: PUSH
3312: LD_EXP 3
3316: PUSH
3317: LD_INT 6000
3319: PLUS
3320: PUSH
3321: LD_OWVAR 1
3325: GREATER
3326: AND
3327: PUSH
3328: LD_EXP 4
3332: AND
3333: IFFALSE 3388
3335: GO 3337
3337: DISABLE
// begin CenterOnUnits ( [ JMM , Burlak ] ) ;
3338: LD_EXP 12
3342: PUSH
3343: LD_EXP 13
3347: PUSH
3348: EMPTY
3349: LIST
3350: LIST
3351: PPUSH
3352: CALL_OW 85
// DialogueOn ;
3356: CALL_OW 6
// Say ( JMM , D6b-JMM-1 ) ;
3360: LD_EXP 12
3364: PPUSH
3365: LD_STRING D6b-JMM-1
3367: PPUSH
3368: CALL_OW 88
// Say ( Burlak , D6b-Bur-1 ) ;
3372: LD_EXP 13
3376: PPUSH
3377: LD_STRING D6b-Bur-1
3379: PPUSH
3380: CALL_OW 88
// DialogueOff ;
3384: CALL_OW 7
// end ;
3388: END
// every 0 0$1 trigger ( GetDistUnitXY ( Burlak , 142 , 52 ) < 25 or GetDistUnitXY ( IsInUnit ( Burlak ) , 142 , 52 ) < 25 ) and GetLives ( Burlak ) < 1000 and contaminateTime + 6000 > tick and bombExploded do
3389: LD_EXP 13
3393: PPUSH
3394: LD_INT 142
3396: PPUSH
3397: LD_INT 52
3399: PPUSH
3400: CALL_OW 297
3404: PUSH
3405: LD_INT 25
3407: LESS
3408: PUSH
3409: LD_EXP 13
3413: PPUSH
3414: CALL_OW 310
3418: PPUSH
3419: LD_INT 142
3421: PPUSH
3422: LD_INT 52
3424: PPUSH
3425: CALL_OW 297
3429: PUSH
3430: LD_INT 25
3432: LESS
3433: OR
3434: PUSH
3435: LD_EXP 13
3439: PPUSH
3440: CALL_OW 256
3444: PUSH
3445: LD_INT 1000
3447: LESS
3448: AND
3449: PUSH
3450: LD_EXP 3
3454: PUSH
3455: LD_INT 6000
3457: PLUS
3458: PUSH
3459: LD_OWVAR 1
3463: GREATER
3464: AND
3465: PUSH
3466: LD_EXP 4
3470: AND
3471: IFFALSE 3504
3473: GO 3475
3475: DISABLE
// begin DialogueOn ;
3476: CALL_OW 6
// Say ( Burlak , D7-Bur-1 ) ;
3480: LD_EXP 13
3484: PPUSH
3485: LD_STRING D7-Bur-1
3487: PPUSH
3488: CALL_OW 88
// enteredContaminatedArea := true ;
3492: LD_ADDR_EXP 5
3496: PUSH
3497: LD_INT 1
3499: ST_TO_ADDR
// DialogueOff ;
3500: CALL_OW 7
// end ;
3504: END
// every 0 0$1 trigger ( GetDistUnitXY ( JMM , 142 , 52 ) < 25 or GetDistUnitXY ( IsInUnit ( JMM ) , 142 , 52 ) < 25 ) and GetLives ( JMM ) < 1000 and contaminateTime + 6000 > tick and bombExploded do
3505: LD_EXP 12
3509: PPUSH
3510: LD_INT 142
3512: PPUSH
3513: LD_INT 52
3515: PPUSH
3516: CALL_OW 297
3520: PUSH
3521: LD_INT 25
3523: LESS
3524: PUSH
3525: LD_EXP 12
3529: PPUSH
3530: CALL_OW 310
3534: PPUSH
3535: LD_INT 142
3537: PPUSH
3538: LD_INT 52
3540: PPUSH
3541: CALL_OW 297
3545: PUSH
3546: LD_INT 25
3548: LESS
3549: OR
3550: PUSH
3551: LD_EXP 12
3555: PPUSH
3556: CALL_OW 256
3560: PUSH
3561: LD_INT 1000
3563: LESS
3564: AND
3565: PUSH
3566: LD_EXP 3
3570: PUSH
3571: LD_INT 6000
3573: PLUS
3574: PUSH
3575: LD_OWVAR 1
3579: GREATER
3580: AND
3581: PUSH
3582: LD_EXP 4
3586: AND
3587: IFFALSE 3620
3589: GO 3591
3591: DISABLE
// begin DialogueOn ;
3592: CALL_OW 6
// Say ( JMM , D7-JMM-1 ) ;
3596: LD_EXP 12
3600: PPUSH
3601: LD_STRING D7-JMM-1
3603: PPUSH
3604: CALL_OW 88
// enteredContaminatedArea := true ;
3608: LD_ADDR_EXP 5
3612: PUSH
3613: LD_INT 1
3615: ST_TO_ADDR
// DialogueOff ;
3616: CALL_OW 7
// end ;
3620: END
// every 0 0$1 trigger artifactPickedUp and IsOk ( JMM ) and IsOk ( Burlak ) do
3621: LD_EXP 6
3625: PUSH
3626: LD_EXP 12
3630: PPUSH
3631: CALL_OW 302
3635: AND
3636: PUSH
3637: LD_EXP 13
3641: PPUSH
3642: CALL_OW 302
3646: AND
3647: IFFALSE 3716
3649: GO 3651
3651: DISABLE
// begin DialogueOn ;
3652: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Burlak ] ) ;
3656: LD_EXP 12
3660: PUSH
3661: LD_EXP 13
3665: PUSH
3666: EMPTY
3667: LIST
3668: LIST
3669: PPUSH
3670: CALL_OW 87
// Say ( JMM , D4-JMM-1 ) ;
3674: LD_EXP 12
3678: PPUSH
3679: LD_STRING D4-JMM-1
3681: PPUSH
3682: CALL_OW 88
// if not bombExploded then
3686: LD_EXP 4
3690: NOT
3691: IFFALSE 3705
// Say ( Burlak , D4-Bur-1 ) ;
3693: LD_EXP 13
3697: PPUSH
3698: LD_STRING D4-Bur-1
3700: PPUSH
3701: CALL_OW 88
// DialogueOff ;
3705: CALL_OW 7
// ChangeMissionObjectives ( MReturn ) ;
3709: LD_STRING MReturn
3711: PPUSH
3712: CALL_OW 337
// end ;
3716: END
// every 0 0$2 trigger not planCaptured and FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , us_dep_north , 6 ] ] ) do
3717: LD_EXP 7
3721: NOT
3722: PUSH
3723: LD_INT 22
3725: PUSH
3726: LD_INT 7
3728: PUSH
3729: EMPTY
3730: LIST
3731: LIST
3732: PUSH
3733: LD_INT 91
3735: PUSH
3736: LD_INT 9
3738: PUSH
3739: LD_INT 6
3741: PUSH
3742: EMPTY
3743: LIST
3744: LIST
3745: LIST
3746: PUSH
3747: EMPTY
3748: LIST
3749: LIST
3750: PPUSH
3751: CALL_OW 69
3755: AND
3756: IFFALSE 3833
3758: GO 3760
3760: DISABLE
// begin DialogueOn ;
3761: CALL_OW 6
// PlaceSeeing ( 55 , 11 , 7 , - 6 ) ;
3765: LD_INT 55
3767: PPUSH
3768: LD_INT 11
3770: PPUSH
3771: LD_INT 7
3773: PPUSH
3774: LD_INT 6
3776: NEG
3777: PPUSH
3778: CALL_OW 330
// RemoveSeeing ( 55 , 11 , 7 ) ;
3782: LD_INT 55
3784: PPUSH
3785: LD_INT 11
3787: PPUSH
3788: LD_INT 7
3790: PPUSH
3791: CALL_OW 331
// Say ( Burlak , D9-Bur-1 ) ;
3795: LD_EXP 13
3799: PPUSH
3800: LD_STRING D9-Bur-1
3802: PPUSH
3803: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
3807: LD_EXP 12
3811: PPUSH
3812: LD_STRING D9-JMM-1
3814: PPUSH
3815: CALL_OW 88
// DialogueOff ;
3819: CALL_OW 7
// SetSide ( us_dep_north , 7 ) ;
3823: LD_INT 9
3825: PPUSH
3826: LD_INT 7
3828: PPUSH
3829: CALL_OW 235
// end ;
3833: END
// every 0 0$1 trigger FilterUnitsInArea ( usBase , [ f_side , 7 ] ) do
3834: LD_INT 9
3836: PPUSH
3837: LD_INT 22
3839: PUSH
3840: LD_INT 7
3842: PUSH
3843: EMPTY
3844: LIST
3845: LIST
3846: PPUSH
3847: CALL_OW 70
3851: IFFALSE 3887
3853: GO 3855
3855: DISABLE
// begin wait ( 0 0$07 ) ;
3856: LD_INT 245
3858: PPUSH
3859: CALL_OW 67
// Say ( JMM , D10b-JMM-1 ) ;
3863: LD_EXP 12
3867: PPUSH
3868: LD_STRING D10b-JMM-1
3870: PPUSH
3871: CALL_OW 88
// Say ( Burlak , D10b-Bur-1 ) ;
3875: LD_EXP 13
3879: PPUSH
3880: LD_STRING D10b-Bur-1
3882: PPUSH
3883: CALL_OW 88
// end ;
3887: END
// every 0 0$1 trigger stevensTimer and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) and ( GetSide ( us_depot ) = 7 or FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) = 0 ) do var i ;
3888: LD_EXP 9
3892: PUSH
3893: LD_INT 22
3895: PUSH
3896: LD_INT 1
3898: PUSH
3899: EMPTY
3900: LIST
3901: LIST
3902: PUSH
3903: LD_INT 25
3905: PUSH
3906: LD_INT 4
3908: PUSH
3909: EMPTY
3910: LIST
3911: LIST
3912: PUSH
3913: LD_INT 26
3915: PUSH
3916: LD_INT 1
3918: PUSH
3919: EMPTY
3920: LIST
3921: LIST
3922: PUSH
3923: EMPTY
3924: LIST
3925: LIST
3926: LIST
3927: PPUSH
3928: CALL_OW 69
3932: AND
3933: PUSH
3934: LD_INT 5
3936: PPUSH
3937: CALL_OW 255
3941: PUSH
3942: LD_INT 7
3944: EQUAL
3945: PUSH
3946: LD_INT 22
3948: PUSH
3949: LD_INT 1
3951: PUSH
3952: EMPTY
3953: LIST
3954: LIST
3955: PUSH
3956: LD_INT 25
3958: PUSH
3959: LD_INT 1
3961: PUSH
3962: EMPTY
3963: LIST
3964: LIST
3965: PUSH
3966: EMPTY
3967: LIST
3968: LIST
3969: PPUSH
3970: CALL_OW 69
3974: PUSH
3975: LD_INT 0
3977: EQUAL
3978: OR
3979: AND
3980: IFFALSE 4562
3982: GO 3984
3984: DISABLE
3985: LD_INT 0
3987: PPUSH
// begin case Query ( QKill ) of 1 :
3988: LD_STRING QKill
3990: PPUSH
3991: CALL_OW 97
3995: PUSH
3996: LD_INT 1
3998: DOUBLE
3999: EQUAL
4000: IFTRUE 4004
4002: GO 4550
4004: POP
// begin DialogueOn ;
4005: CALL_OW 6
// Say ( JMM , D10a-JMM-1 ) ;
4009: LD_EXP 12
4013: PPUSH
4014: LD_STRING D10a-JMM-1
4016: PPUSH
4017: CALL_OW 88
// Say ( Burlak , D10a-Bur-1 ) ;
4021: LD_EXP 13
4025: PPUSH
4026: LD_STRING D10a-Bur-1
4028: PPUSH
4029: CALL_OW 88
// Say ( JMM , D10a-JMM-2 ) ;
4033: LD_EXP 12
4037: PPUSH
4038: LD_STRING D10a-JMM-2
4040: PPUSH
4041: CALL_OW 88
// if IsOk ( Stevens ) then
4045: LD_EXP 16
4049: PPUSH
4050: CALL_OW 302
4054: IFFALSE 4070
// Say ( Stevens , D10a-Huck-2 ) else
4056: LD_EXP 16
4060: PPUSH
4061: LD_STRING D10a-Huck-2
4063: PPUSH
4064: CALL_OW 88
4068: GO 4121
// Say ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) [ 1 ] , D10a-ASci1-3 ) ;
4070: LD_INT 22
4072: PUSH
4073: LD_INT 1
4075: PUSH
4076: EMPTY
4077: LIST
4078: LIST
4079: PUSH
4080: LD_INT 25
4082: PUSH
4083: LD_INT 4
4085: PUSH
4086: EMPTY
4087: LIST
4088: LIST
4089: PUSH
4090: LD_INT 26
4092: PUSH
4093: LD_INT 1
4095: PUSH
4096: EMPTY
4097: LIST
4098: LIST
4099: PUSH
4100: EMPTY
4101: LIST
4102: LIST
4103: LIST
4104: PPUSH
4105: CALL_OW 69
4109: PUSH
4110: LD_INT 1
4112: ARRAY
4113: PPUSH
4114: LD_STRING D10a-ASci1-3
4116: PPUSH
4117: CALL_OW 88
// Say ( JMM , D10a-JMM-4 ) ;
4121: LD_EXP 12
4125: PPUSH
4126: LD_STRING D10a-JMM-4
4128: PPUSH
4129: CALL_OW 88
// if IsOk ( Stevens ) then
4133: LD_EXP 16
4137: PPUSH
4138: CALL_OW 302
4142: IFFALSE 4156
// Say ( Stevens , D10a-Huck-3 ) ;
4144: LD_EXP 16
4148: PPUSH
4149: LD_STRING D10a-Huck-3
4151: PPUSH
4152: CALL_OW 88
// DialogueOff ;
4156: CALL_OW 7
// SetAttitude ( 1 , 7 , att_friend , true ) ;
4160: LD_INT 1
4162: PPUSH
4163: LD_INT 7
4165: PPUSH
4166: LD_INT 1
4168: PPUSH
4169: LD_INT 1
4171: PPUSH
4172: CALL_OW 80
// planCaptured := true ;
4176: LD_ADDR_EXP 7
4180: PUSH
4181: LD_INT 1
4183: ST_TO_ADDR
// ChangeMissionObjectives ( MEnd ) ;
4184: LD_STRING MEnd
4186: PPUSH
4187: CALL_OW 337
// canEnd := true ;
4191: LD_ADDR_EXP 10
4195: PUSH
4196: LD_INT 1
4198: ST_TO_ADDR
// missionTime := tick ;
4199: LD_ADDR_EXP 11
4203: PUSH
4204: LD_OWVAR 1
4208: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4209: LD_INT 35
4211: PPUSH
4212: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] ] ) then
4216: LD_INT 22
4218: PUSH
4219: LD_INT 1
4221: PUSH
4222: EMPTY
4223: LIST
4224: LIST
4225: PUSH
4226: LD_INT 3
4228: PUSH
4229: LD_INT 50
4231: PUSH
4232: EMPTY
4233: LIST
4234: PUSH
4235: EMPTY
4236: LIST
4237: LIST
4238: PUSH
4239: EMPTY
4240: LIST
4241: LIST
4242: PPUSH
4243: CALL_OW 69
4247: IFFALSE 4363
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) do
4249: LD_ADDR_VAR 0 1
4253: PUSH
4254: LD_INT 22
4256: PUSH
4257: LD_INT 1
4259: PUSH
4260: EMPTY
4261: LIST
4262: LIST
4263: PUSH
4264: LD_INT 25
4266: PUSH
4267: LD_INT 4
4269: PUSH
4270: EMPTY
4271: LIST
4272: LIST
4273: PUSH
4274: EMPTY
4275: LIST
4276: LIST
4277: PPUSH
4278: CALL_OW 69
4282: PUSH
4283: FOR_IN
4284: IFFALSE 4361
// begin if IsInUnit ( i ) then
4286: LD_VAR 0 1
4290: PPUSH
4291: CALL_OW 310
4295: IFFALSE 4308
// ComExitBuilding ( i ) else
4297: LD_VAR 0 1
4301: PPUSH
4302: CALL_OW 122
4306: GO 4359
// ComHeal ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] ] ) , i ) ) ;
4308: LD_VAR 0 1
4312: PPUSH
4313: LD_INT 22
4315: PUSH
4316: LD_INT 1
4318: PUSH
4319: EMPTY
4320: LIST
4321: LIST
4322: PUSH
4323: LD_INT 3
4325: PUSH
4326: LD_INT 50
4328: PUSH
4329: EMPTY
4330: LIST
4331: PUSH
4332: EMPTY
4333: LIST
4334: LIST
4335: PUSH
4336: EMPTY
4337: LIST
4338: LIST
4339: PPUSH
4340: CALL_OW 69
4344: PPUSH
4345: LD_VAR 0 1
4349: PPUSH
4350: CALL_OW 74
4354: PPUSH
4355: CALL_OW 128
// end ;
4359: GO 4283
4361: POP
4362: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] ] ) ;
4363: LD_INT 22
4365: PUSH
4366: LD_INT 1
4368: PUSH
4369: EMPTY
4370: LIST
4371: LIST
4372: PUSH
4373: LD_INT 3
4375: PUSH
4376: LD_INT 50
4378: PUSH
4379: EMPTY
4380: LIST
4381: PUSH
4382: EMPTY
4383: LIST
4384: LIST
4385: PUSH
4386: EMPTY
4387: LIST
4388: LIST
4389: PPUSH
4390: CALL_OW 69
4394: NOT
4395: IFFALSE 4209
// repeat wait ( 3 ) ;
4397: LD_INT 3
4399: PPUSH
4400: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) do
4404: LD_ADDR_VAR 0 1
4408: PUSH
4409: LD_INT 22
4411: PUSH
4412: LD_INT 1
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: PUSH
4419: LD_INT 21
4421: PUSH
4422: LD_INT 1
4424: PUSH
4425: EMPTY
4426: LIST
4427: LIST
4428: PUSH
4429: EMPTY
4430: LIST
4431: LIST
4432: PPUSH
4433: CALL_OW 69
4437: PUSH
4438: FOR_IN
4439: IFFALSE 4515
// begin if IsInArea ( i , stevensEscapeArea ) then
4441: LD_VAR 0 1
4445: PPUSH
4446: LD_INT 8
4448: PPUSH
4449: CALL_OW 308
4453: IFFALSE 4466
// begin RemoveUnit ( i ) ;
4455: LD_VAR 0 1
4459: PPUSH
4460: CALL_OW 64
// continue ;
4464: GO 4438
// end ; if IsInUnit ( i ) then
4466: LD_VAR 0 1
4470: PPUSH
4471: CALL_OW 310
4475: IFFALSE 4486
// ComExitBuilding ( i ) ;
4477: LD_VAR 0 1
4481: PPUSH
4482: CALL_OW 122
// if not HasTask ( i ) then
4486: LD_VAR 0 1
4490: PPUSH
4491: CALL_OW 314
4495: NOT
4496: IFFALSE 4513
// ComMoveXY ( i , 28 , 55 ) ;
4498: LD_VAR 0 1
4502: PPUSH
4503: LD_INT 28
4505: PPUSH
4506: LD_INT 55
4508: PPUSH
4509: CALL_OW 111
// end ;
4513: GO 4438
4515: POP
4516: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ;
4517: LD_INT 22
4519: PUSH
4520: LD_INT 1
4522: PUSH
4523: EMPTY
4524: LIST
4525: LIST
4526: PUSH
4527: LD_INT 21
4529: PUSH
4530: LD_INT 1
4532: PUSH
4533: EMPTY
4534: LIST
4535: LIST
4536: PUSH
4537: EMPTY
4538: LIST
4539: LIST
4540: PPUSH
4541: CALL_OW 69
4545: NOT
4546: IFFALSE 4397
// end ; 2 :
4548: GO 4562
4550: LD_INT 2
4552: DOUBLE
4553: EQUAL
4554: IFTRUE 4558
4556: GO 4561
4558: POP
// ; end ;
4559: GO 4562
4561: POP
// end ;
4562: PPOPN 1
4564: END
// every 0 0$1 trigger canEnd do var un , i , tmp ;
4565: LD_EXP 10
4569: IFFALSE 4926
4571: GO 4573
4573: DISABLE
4574: LD_INT 0
4576: PPUSH
4577: PPUSH
4578: PPUSH
// begin SetAreaMapShow ( endMissionArea , 1 ) ;
4579: LD_INT 10
4581: PPUSH
4582: LD_INT 1
4584: PPUSH
4585: CALL_OW 424
// if Difficulty < 2 then
4589: LD_OWVAR 67
4593: PUSH
4594: LD_INT 2
4596: LESS
4597: IFFALSE 4601
// exit ;
4599: GO 4926
// uc_side := 4 ;
4601: LD_ADDR_OWVAR 20
4605: PUSH
4606: LD_INT 4
4608: ST_TO_ADDR
// uc_nation := 1 ;
4609: LD_ADDR_OWVAR 21
4613: PUSH
4614: LD_INT 1
4616: ST_TO_ADDR
// InitHc ;
4617: CALL_OW 19
// tmp := [ ] ;
4621: LD_ADDR_VAR 0 3
4625: PUSH
4626: EMPTY
4627: ST_TO_ADDR
// PrepareHuman ( false , class_sniper , 10 ) ;
4628: LD_INT 0
4630: PPUSH
4631: LD_INT 5
4633: PPUSH
4634: LD_INT 10
4636: PPUSH
4637: CALL_OW 380
// un := CreateHuman ;
4641: LD_ADDR_VAR 0 1
4645: PUSH
4646: CALL_OW 44
4650: ST_TO_ADDR
// tmp := [ un ] ;
4651: LD_ADDR_VAR 0 3
4655: PUSH
4656: LD_VAR 0 1
4660: PUSH
4661: EMPTY
4662: LIST
4663: ST_TO_ADDR
// PlaceUnitXY ( un , 226 , 86 , false ) ;
4664: LD_VAR 0 1
4668: PPUSH
4669: LD_INT 226
4671: PPUSH
4672: LD_INT 86
4674: PPUSH
4675: LD_INT 0
4677: PPUSH
4678: CALL_OW 48
// ComHold ( un ) ;
4682: LD_VAR 0 1
4686: PPUSH
4687: CALL_OW 140
// for i = 1 to 3 do
4691: LD_ADDR_VAR 0 2
4695: PUSH
4696: DOUBLE
4697: LD_INT 1
4699: DEC
4700: ST_TO_ADDR
4701: LD_INT 3
4703: PUSH
4704: FOR_TO
4705: IFFALSE 4804
// begin PrepareHuman ( false , class_soldier , 8 ) ;
4707: LD_INT 0
4709: PPUSH
4710: LD_INT 1
4712: PPUSH
4713: LD_INT 8
4715: PPUSH
4716: CALL_OW 380
// un := CreateHuman ;
4720: LD_ADDR_VAR 0 1
4724: PUSH
4725: CALL_OW 44
4729: ST_TO_ADDR
// SetDir ( un , 5 ) ;
4730: LD_VAR 0 1
4734: PPUSH
4735: LD_INT 5
4737: PPUSH
4738: CALL_OW 233
// PlaceUnitXY ( un , [ 215 , 217 , 219 ] [ i ] , 76 , false ) ;
4742: LD_VAR 0 1
4746: PPUSH
4747: LD_INT 215
4749: PUSH
4750: LD_INT 217
4752: PUSH
4753: LD_INT 219
4755: PUSH
4756: EMPTY
4757: LIST
4758: LIST
4759: LIST
4760: PUSH
4761: LD_VAR 0 2
4765: ARRAY
4766: PPUSH
4767: LD_INT 76
4769: PPUSH
4770: LD_INT 0
4772: PPUSH
4773: CALL_OW 48
// ComCrawl ( un ) ;
4777: LD_VAR 0 1
4781: PPUSH
4782: CALL_OW 137
// tmp := tmp ^ un ;
4786: LD_ADDR_VAR 0 3
4790: PUSH
4791: LD_VAR 0 3
4795: PUSH
4796: LD_VAR 0 1
4800: ADD
4801: ST_TO_ADDR
// end ;
4802: GO 4704
4804: POP
4805: POP
// repeat wait ( 0 0$1 ) ;
4806: LD_INT 35
4808: PPUSH
4809: CALL_OW 67
// until not UnitFilter ( un , [ f_lives , 1000 ] ) ;
4813: LD_VAR 0 1
4817: PPUSH
4818: LD_INT 24
4820: PUSH
4821: LD_INT 1000
4823: PUSH
4824: EMPTY
4825: LIST
4826: LIST
4827: PPUSH
4828: CALL_OW 72
4832: NOT
4833: IFFALSE 4806
// for i in tmp do
4835: LD_ADDR_VAR 0 2
4839: PUSH
4840: LD_VAR 0 3
4844: PUSH
4845: FOR_IN
4846: IFFALSE 4924
// begin wait ( 0 0$1 ) ;
4848: LD_INT 35
4850: PPUSH
4851: CALL_OW 67
// if Crawls ( i ) then
4855: LD_VAR 0 2
4859: PPUSH
4860: CALL_OW 318
4864: IFFALSE 4877
// ComWalk ( i ) else
4866: LD_VAR 0 2
4870: PPUSH
4871: CALL_OW 138
4875: GO 4922
// if GetClass ( i ) = class_sniper then
4877: LD_VAR 0 2
4881: PPUSH
4882: CALL_OW 257
4886: PUSH
4887: LD_INT 5
4889: EQUAL
4890: IFFALSE 4908
// ComAttackSoporific ( i , JMM ) else
4892: LD_VAR 0 2
4896: PPUSH
4897: LD_EXP 12
4901: PPUSH
4902: CALL_OW 166
4906: GO 4922
// ComAttackUnit ( i , JMM ) ;
4908: LD_VAR 0 2
4912: PPUSH
4913: LD_EXP 12
4917: PPUSH
4918: CALL_OW 115
// end ;
4922: GO 4845
4924: POP
4925: POP
// end ;
4926: PPOPN 3
4928: END
// every 0 0$1 trigger not planCaptured and IsDead ( us_lab ) do
4929: LD_EXP 7
4933: NOT
4934: PUSH
4935: LD_INT 1
4937: PPUSH
4938: CALL_OW 301
4942: AND
4943: IFFALSE 4955
4945: GO 4947
4947: DISABLE
// YouLost ( Lab ) ;
4948: LD_STRING Lab
4950: PPUSH
4951: CALL_OW 104
4955: END
// every 0 0$1 trigger FilterUnitsInArea ( endMissionArea , [ f_side , 7 ] ) >= 2 and FilterUnitsInArea ( endMissionArea , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) and canEnd and planCaptured and artifactPickedUp do
4956: LD_INT 10
4958: PPUSH
4959: LD_INT 22
4961: PUSH
4962: LD_INT 7
4964: PUSH
4965: EMPTY
4966: LIST
4967: LIST
4968: PPUSH
4969: CALL_OW 70
4973: PUSH
4974: LD_INT 2
4976: GREATEREQUAL
4977: PUSH
4978: LD_INT 10
4980: PPUSH
4981: LD_INT 2
4983: PUSH
4984: LD_INT 34
4986: PUSH
4987: LD_INT 12
4989: PUSH
4990: EMPTY
4991: LIST
4992: LIST
4993: PUSH
4994: LD_INT 34
4996: PUSH
4997: LD_INT 51
4999: PUSH
5000: EMPTY
5001: LIST
5002: LIST
5003: PUSH
5004: EMPTY
5005: LIST
5006: LIST
5007: LIST
5008: PPUSH
5009: CALL_OW 70
5013: AND
5014: PUSH
5015: LD_EXP 10
5019: AND
5020: PUSH
5021: LD_EXP 7
5025: AND
5026: PUSH
5027: LD_EXP 6
5031: AND
5032: IFFALSE 5179
5034: GO 5036
5036: DISABLE
// begin AddMedal ( Explosion , 1 ) ;
5037: LD_STRING Explosion
5039: PPUSH
5040: LD_INT 1
5042: PPUSH
5043: CALL_OW 101
// if enteredContaminatedArea then
5047: LD_EXP 5
5051: IFFALSE 5065
// AddMedal ( BioHazard , 1 ) else
5053: LD_STRING BioHazard
5055: PPUSH
5056: LD_INT 1
5058: PPUSH
5059: CALL_OW 101
5063: GO 5076
// AddMedal ( BioHazard , - 1 ) ;
5065: LD_STRING BioHazard
5067: PPUSH
5068: LD_INT 1
5070: NEG
5071: PPUSH
5072: CALL_OW 101
// if missionTime <= [ 20 20$00 , 15 15$00 , 12 12$00 ] [ Difficulty ] then
5076: LD_EXP 11
5080: PUSH
5081: LD_INT 42000
5083: PUSH
5084: LD_INT 31500
5086: PUSH
5087: LD_INT 25200
5089: PUSH
5090: EMPTY
5091: LIST
5092: LIST
5093: LIST
5094: PUSH
5095: LD_OWVAR 67
5099: ARRAY
5100: LESSEQUAL
5101: IFFALSE 5115
// AddMedal ( Speed , 1 ) else
5103: LD_STRING Speed
5105: PPUSH
5106: LD_INT 1
5108: PPUSH
5109: CALL_OW 101
5113: GO 5126
// AddMedal ( Speed , - 1 ) ;
5115: LD_STRING Speed
5117: PPUSH
5118: LD_INT 1
5120: NEG
5121: PPUSH
5122: CALL_OW 101
// GiveMedals ( Main ) ;
5126: LD_STRING Main
5128: PPUSH
5129: CALL_OW 102
// RewardPeople ( [ JMM , Burlak ] ) ;
5133: LD_EXP 12
5137: PUSH
5138: LD_EXP 13
5142: PUSH
5143: EMPTY
5144: LIST
5145: LIST
5146: PPUSH
5147: CALL_OW 43
// SaveCharacters ( JMM , 14a_JMM ) ;
5151: LD_EXP 12
5155: PPUSH
5156: LD_STRING 14a_JMM
5158: PPUSH
5159: CALL_OW 38
// SaveCharacters ( Burlak , 14a_Burlak ) ;
5163: LD_EXP 13
5167: PPUSH
5168: LD_STRING 14a_Burlak
5170: PPUSH
5171: CALL_OW 38
// YouWin ;
5175: CALL_OW 103
// end ; end_of_file
5179: END
// export Stevens , Powell , baseGuards , sibBomb , guards , vehGuard ; export function PrepareAmerican ; var i , un , tmp ; begin
5180: LD_INT 0
5182: PPUSH
5183: PPUSH
5184: PPUSH
5185: PPUSH
// uc_side := 1 ;
5186: LD_ADDR_OWVAR 20
5190: PUSH
5191: LD_INT 1
5193: ST_TO_ADDR
// uc_nation := 1 ;
5194: LD_ADDR_OWVAR 21
5198: PUSH
5199: LD_INT 1
5201: ST_TO_ADDR
// SetResourceType ( GetBase ( us_depot2 ) , mat_cans , 500 ) ;
5202: LD_INT 34
5204: PPUSH
5205: CALL_OW 274
5209: PPUSH
5210: LD_INT 1
5212: PPUSH
5213: LD_INT 500
5215: PPUSH
5216: CALL_OW 277
// SetResourceType ( GetBase ( us_depot2 ) , mat_siberit , 20 ) ;
5220: LD_INT 34
5222: PPUSH
5223: CALL_OW 274
5227: PPUSH
5228: LD_INT 3
5230: PPUSH
5231: LD_INT 20
5233: PPUSH
5234: CALL_OW 277
// Stevens := NewCharacter ( Stevens ) ;
5238: LD_ADDR_EXP 16
5242: PUSH
5243: LD_STRING Stevens
5245: PPUSH
5246: CALL_OW 25
5250: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
5251: LD_ADDR_EXP 17
5255: PUSH
5256: LD_STRING Powell
5258: PPUSH
5259: CALL_OW 25
5263: ST_TO_ADDR
// PlaceHumanInUnit ( Stevens , us_lab ) ;
5264: LD_EXP 16
5268: PPUSH
5269: LD_INT 1
5271: PPUSH
5272: CALL_OW 52
// vehGuard := [ ] ;
5276: LD_ADDR_EXP 21
5280: PUSH
5281: EMPTY
5282: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_siberite , control_computer , us_siberium_rocket , 100 ) ;
5283: LD_INT 4
5285: PPUSH
5286: LD_INT 3
5288: PPUSH
5289: LD_INT 3
5291: PPUSH
5292: LD_INT 8
5294: PPUSH
5295: LD_INT 100
5297: PPUSH
5298: CALL 934 0 5
// sibBomb := CreateVehicle ;
5302: LD_ADDR_EXP 19
5306: PUSH
5307: CALL_OW 45
5311: ST_TO_ADDR
// SetDir ( sibBomb , 1 ) ;
5312: LD_EXP 19
5316: PPUSH
5317: LD_INT 1
5319: PPUSH
5320: CALL_OW 233
// PlaceUnitXY ( sibBomb , 93 , 74 , false ) ;
5324: LD_EXP 19
5328: PPUSH
5329: LD_INT 93
5331: PPUSH
5332: LD_INT 74
5334: PPUSH
5335: LD_INT 0
5337: PPUSH
5338: CALL_OW 48
// guards := [ ] ;
5342: LD_ADDR_EXP 20
5346: PUSH
5347: EMPTY
5348: ST_TO_ADDR
// for i = 1 to 3 do
5349: LD_ADDR_VAR 0 2
5353: PUSH
5354: DOUBLE
5355: LD_INT 1
5357: DEC
5358: ST_TO_ADDR
5359: LD_INT 3
5361: PUSH
5362: FOR_TO
5363: IFFALSE 5455
// begin PrepareHuman ( false , class_soldier , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
5365: LD_INT 0
5367: PPUSH
5368: LD_INT 1
5370: PPUSH
5371: LD_INT 8
5373: PUSH
5374: LD_INT 9
5376: PUSH
5377: LD_INT 10
5379: PUSH
5380: EMPTY
5381: LIST
5382: LIST
5383: LIST
5384: PUSH
5385: LD_OWVAR 67
5389: ARRAY
5390: PPUSH
5391: CALL_OW 380
// un := CreateHuman ;
5395: LD_ADDR_VAR 0 3
5399: PUSH
5400: CALL_OW 44
5404: ST_TO_ADDR
// PlaceUnitArea ( un , [ patrol1 , patrol2 , patrol3 ] [ i ] , false ) ;
5405: LD_VAR 0 3
5409: PPUSH
5410: LD_INT 2
5412: PUSH
5413: LD_INT 3
5415: PUSH
5416: LD_INT 4
5418: PUSH
5419: EMPTY
5420: LIST
5421: LIST
5422: LIST
5423: PUSH
5424: LD_VAR 0 2
5428: ARRAY
5429: PPUSH
5430: LD_INT 0
5432: PPUSH
5433: CALL_OW 49
// guards := guards ^ un ;
5437: LD_ADDR_EXP 20
5441: PUSH
5442: LD_EXP 20
5446: PUSH
5447: LD_VAR 0 3
5451: ADD
5452: ST_TO_ADDR
// end ;
5453: GO 5362
5455: POP
5456: POP
// baseGuards := [ ] ;
5457: LD_ADDR_EXP 18
5461: PUSH
5462: EMPTY
5463: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
5464: LD_ADDR_VAR 0 2
5468: PUSH
5469: DOUBLE
5470: LD_INT 1
5472: DEC
5473: ST_TO_ADDR
5474: LD_INT 5
5476: PUSH
5477: LD_INT 6
5479: PUSH
5480: LD_INT 7
5482: PUSH
5483: EMPTY
5484: LIST
5485: LIST
5486: LIST
5487: PUSH
5488: LD_OWVAR 67
5492: ARRAY
5493: PUSH
5494: FOR_TO
5495: IFFALSE 5641
// begin PrepareSoldier ( false , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
5497: LD_INT 0
5499: PPUSH
5500: LD_INT 8
5502: PUSH
5503: LD_INT 9
5505: PUSH
5506: LD_INT 10
5508: PUSH
5509: EMPTY
5510: LIST
5511: LIST
5512: LIST
5513: PUSH
5514: LD_OWVAR 67
5518: ARRAY
5519: PPUSH
5520: CALL_OW 381
// un := CreateHuman ;
5524: LD_ADDR_VAR 0 3
5528: PUSH
5529: CALL_OW 44
5533: ST_TO_ADDR
// baseGuards := baseGuards ^ un ;
5534: LD_ADDR_EXP 18
5538: PUSH
5539: LD_EXP 18
5543: PUSH
5544: LD_VAR 0 3
5548: ADD
5549: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
5550: LD_ADDR_VAR 0 4
5554: PUSH
5555: LD_INT 22
5557: PUSH
5558: LD_INT 1
5560: PUSH
5561: EMPTY
5562: LIST
5563: LIST
5564: PUSH
5565: LD_INT 58
5567: PUSH
5568: EMPTY
5569: LIST
5570: PUSH
5571: LD_INT 30
5573: PUSH
5574: LD_INT 32
5576: PUSH
5577: EMPTY
5578: LIST
5579: LIST
5580: PUSH
5581: EMPTY
5582: LIST
5583: LIST
5584: LIST
5585: PPUSH
5586: CALL_OW 69
5590: ST_TO_ADDR
// if tmp then
5591: LD_VAR 0 4
5595: IFFALSE 5627
// PlaceHumanInUnit ( un , tmp [ rand ( 1 , tmp ) ] ) else
5597: LD_VAR 0 3
5601: PPUSH
5602: LD_VAR 0 4
5606: PUSH
5607: LD_INT 1
5609: PPUSH
5610: LD_VAR 0 4
5614: PPUSH
5615: CALL_OW 12
5619: ARRAY
5620: PPUSH
5621: CALL_OW 52
5625: GO 5639
// PlaceHumanInUnit ( un , us_bar ) ;
5627: LD_VAR 0 3
5631: PPUSH
5632: LD_INT 51
5634: PPUSH
5635: CALL_OW 52
// end ;
5639: GO 5494
5641: POP
5642: POP
// if Difficulty > 1 then
5643: LD_OWVAR 67
5647: PUSH
5648: LD_INT 1
5650: GREATER
5651: IFFALSE 5695
// begin PrepareHuman ( false , class_sniper , [ 9 , 10 ] [ Difficulty - 1 ] ) ;
5653: LD_INT 0
5655: PPUSH
5656: LD_INT 5
5658: PPUSH
5659: LD_INT 9
5661: PUSH
5662: LD_INT 10
5664: PUSH
5665: EMPTY
5666: LIST
5667: LIST
5668: PUSH
5669: LD_OWVAR 67
5673: PUSH
5674: LD_INT 1
5676: MINUS
5677: ARRAY
5678: PPUSH
5679: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_bun1 ) ;
5683: CALL_OW 44
5687: PPUSH
5688: LD_INT 80
5690: PPUSH
5691: CALL_OW 52
// end ; for i = 1 to 3 do
5695: LD_ADDR_VAR 0 2
5699: PUSH
5700: DOUBLE
5701: LD_INT 1
5703: DEC
5704: ST_TO_ADDR
5705: LD_INT 3
5707: PUSH
5708: FOR_TO
5709: IFFALSE 5735
// begin PrepareMechanic ( false , 9 ) ;
5711: LD_INT 0
5713: PPUSH
5714: LD_INT 9
5716: PPUSH
5717: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , us_fac ) ;
5721: CALL_OW 44
5725: PPUSH
5726: LD_INT 43
5728: PPUSH
5729: CALL_OW 52
// end ;
5733: GO 5708
5735: POP
5736: POP
// PlaceHumanInUnit ( CreateHuman , us_ct ) ;
5737: CALL_OW 44
5741: PPUSH
5742: LD_INT 49
5744: PPUSH
5745: CALL_OW 52
// for i = 1 to 1 + Difficulty do
5749: LD_ADDR_VAR 0 2
5753: PUSH
5754: DOUBLE
5755: LD_INT 1
5757: DEC
5758: ST_TO_ADDR
5759: LD_INT 1
5761: PUSH
5762: LD_OWVAR 67
5766: PLUS
5767: PUSH
5768: FOR_TO
5769: IFFALSE 5812
// begin PrepareEngineer ( false , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
5771: LD_INT 0
5773: PPUSH
5774: LD_INT 8
5776: PUSH
5777: LD_INT 9
5779: PUSH
5780: LD_INT 10
5782: PUSH
5783: EMPTY
5784: LIST
5785: LIST
5786: LIST
5787: PUSH
5788: LD_OWVAR 67
5792: ARRAY
5793: PPUSH
5794: CALL_OW 382
// PlaceHumanInUnit ( CreateHuman , us_depot ) ;
5798: CALL_OW 44
5802: PPUSH
5803: LD_INT 5
5805: PPUSH
5806: CALL_OW 52
// end ;
5810: GO 5768
5812: POP
5813: POP
// for i = 1 to 3 do
5814: LD_ADDR_VAR 0 2
5818: PUSH
5819: DOUBLE
5820: LD_INT 1
5822: DEC
5823: ST_TO_ADDR
5824: LD_INT 3
5826: PUSH
5827: FOR_TO
5828: IFFALSE 5854
// begin PrepareScientist ( false , 10 ) ;
5830: LD_INT 0
5832: PPUSH
5833: LD_INT 10
5835: PPUSH
5836: CALL_OW 384
// PlaceHumanInUnit ( CreateHuman , us_lab ) ;
5840: CALL_OW 44
5844: PPUSH
5845: LD_INT 1
5847: PPUSH
5848: CALL_OW 52
// end ;
5852: GO 5827
5854: POP
5855: POP
// end ;
5856: LD_VAR 0 1
5860: RET
// every 0 0$2 trigger guards and not activeBombTest do var i , j , points ;
5861: LD_EXP 20
5865: PUSH
5866: LD_EXP 2
5870: NOT
5871: AND
5872: IFFALSE 6058
5874: GO 5876
5876: DISABLE
5877: LD_INT 0
5879: PPUSH
5880: PPUSH
5881: PPUSH
// begin enable ;
5882: ENABLE
// points := [ [ 204 , 30 ] , [ 165 , 24 ] , [ 195 , 6 ] , [ 223 , 54 ] , [ 214 , 84 ] , [ 206 , 71 ] ] ;
5883: LD_ADDR_VAR 0 3
5887: PUSH
5888: LD_INT 204
5890: PUSH
5891: LD_INT 30
5893: PUSH
5894: EMPTY
5895: LIST
5896: LIST
5897: PUSH
5898: LD_INT 165
5900: PUSH
5901: LD_INT 24
5903: PUSH
5904: EMPTY
5905: LIST
5906: LIST
5907: PUSH
5908: LD_INT 195
5910: PUSH
5911: LD_INT 6
5913: PUSH
5914: EMPTY
5915: LIST
5916: LIST
5917: PUSH
5918: LD_INT 223
5920: PUSH
5921: LD_INT 54
5923: PUSH
5924: EMPTY
5925: LIST
5926: LIST
5927: PUSH
5928: LD_INT 214
5930: PUSH
5931: LD_INT 84
5933: PUSH
5934: EMPTY
5935: LIST
5936: LIST
5937: PUSH
5938: LD_INT 206
5940: PUSH
5941: LD_INT 71
5943: PUSH
5944: EMPTY
5945: LIST
5946: LIST
5947: PUSH
5948: EMPTY
5949: LIST
5950: LIST
5951: LIST
5952: LIST
5953: LIST
5954: LIST
5955: ST_TO_ADDR
// for i in guards do
5956: LD_ADDR_VAR 0 1
5960: PUSH
5961: LD_EXP 20
5965: PUSH
5966: FOR_IN
5967: IFFALSE 6056
// begin if HasTask ( i ) then
5969: LD_VAR 0 1
5973: PPUSH
5974: CALL_OW 314
5978: IFFALSE 5984
// continue else
5980: GO 5966
5982: GO 6054
// begin j := rand ( 1 , 6 ) ;
5984: LD_ADDR_VAR 0 2
5988: PUSH
5989: LD_INT 1
5991: PPUSH
5992: LD_INT 6
5994: PPUSH
5995: CALL_OW 12
5999: ST_TO_ADDR
// if not See ( 7 , i ) then
6000: LD_INT 7
6002: PPUSH
6003: LD_VAR 0 1
6007: PPUSH
6008: CALL_OW 292
6012: NOT
6013: IFFALSE 6054
// ComAgressiveMove ( i , points [ j ] [ 1 ] , points [ j ] [ 2 ] ) ;
6015: LD_VAR 0 1
6019: PPUSH
6020: LD_VAR 0 3
6024: PUSH
6025: LD_VAR 0 2
6029: ARRAY
6030: PUSH
6031: LD_INT 1
6033: ARRAY
6034: PPUSH
6035: LD_VAR 0 3
6039: PUSH
6040: LD_VAR 0 2
6044: ARRAY
6045: PUSH
6046: LD_INT 2
6048: ARRAY
6049: PPUSH
6050: CALL_OW 114
// end ; end ;
6054: GO 5966
6056: POP
6057: POP
// end ;
6058: PPOPN 3
6060: END
// every 0 0$1 trigger vehGuard and not planCaptured do var i ;
6061: LD_EXP 21
6065: PUSH
6066: LD_EXP 7
6070: NOT
6071: AND
6072: IFFALSE 6143
6074: GO 6076
6076: DISABLE
6077: LD_INT 0
6079: PPUSH
// begin enable ;
6080: ENABLE
// for i in vehGuard do
6081: LD_ADDR_VAR 0 1
6085: PUSH
6086: LD_EXP 21
6090: PUSH
6091: FOR_IN
6092: IFFALSE 6141
// if IsOk ( vehGuard ) then
6094: LD_EXP 21
6098: PPUSH
6099: CALL_OW 302
6103: IFFALSE 6139
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , i ) ) ;
6105: LD_VAR 0 1
6109: PPUSH
6110: LD_INT 22
6112: PUSH
6113: LD_INT 7
6115: PUSH
6116: EMPTY
6117: LIST
6118: LIST
6119: PPUSH
6120: CALL_OW 69
6124: PPUSH
6125: LD_VAR 0 1
6129: PPUSH
6130: CALL_OW 74
6134: PPUSH
6135: CALL_OW 115
6139: GO 6091
6141: POP
6142: POP
// end ;
6143: PPOPN 1
6145: END
// every 9 9$00 trigger bombExploded and IsOk ( us_fac ) and not planCaptured do
6146: LD_EXP 4
6150: PUSH
6151: LD_INT 43
6153: PPUSH
6154: CALL_OW 302
6158: AND
6159: PUSH
6160: LD_EXP 7
6164: NOT
6165: AND
6166: IFFALSE 6214
6168: GO 6170
6170: DISABLE
// begin enable ;
6171: ENABLE
// ComConstruct ( us_fac , us_morphling , engine_siberite , control_remote , [ us_rocket_launcher , us_rocket_launcher , us_laser ] [ rand ( 1 , 3 ) ] ) ;
6172: LD_INT 43
6174: PPUSH
6175: LD_INT 5
6177: PPUSH
6178: LD_INT 3
6180: PPUSH
6181: LD_INT 2
6183: PPUSH
6184: LD_INT 7
6186: PUSH
6187: LD_INT 7
6189: PUSH
6190: LD_INT 9
6192: PUSH
6193: EMPTY
6194: LIST
6195: LIST
6196: LIST
6197: PUSH
6198: LD_INT 1
6200: PPUSH
6201: LD_INT 3
6203: PPUSH
6204: CALL_OW 12
6208: ARRAY
6209: PPUSH
6210: CALL_OW 125
// end ;
6214: END
// every 1 1$45 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_sniper ] , [ f_ok ] ] ) and not planCaptured do var tmp , b ;
6215: LD_INT 22
6217: PUSH
6218: LD_INT 1
6220: PUSH
6221: EMPTY
6222: LIST
6223: LIST
6224: PUSH
6225: LD_INT 25
6227: PUSH
6228: LD_INT 5
6230: PUSH
6231: EMPTY
6232: LIST
6233: LIST
6234: PUSH
6235: LD_INT 50
6237: PUSH
6238: EMPTY
6239: LIST
6240: PUSH
6241: EMPTY
6242: LIST
6243: LIST
6244: LIST
6245: PPUSH
6246: CALL_OW 69
6250: PUSH
6251: LD_EXP 7
6255: NOT
6256: AND
6257: IFFALSE 6486
6259: GO 6261
6261: DISABLE
6262: LD_INT 0
6264: PPUSH
6265: PPUSH
// begin enable ;
6266: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_sniper ] , [ f_ok ] ] ) ;
6267: LD_ADDR_VAR 0 1
6271: PUSH
6272: LD_INT 22
6274: PUSH
6275: LD_INT 1
6277: PUSH
6278: EMPTY
6279: LIST
6280: LIST
6281: PUSH
6282: LD_INT 25
6284: PUSH
6285: LD_INT 5
6287: PUSH
6288: EMPTY
6289: LIST
6290: LIST
6291: PUSH
6292: LD_INT 50
6294: PUSH
6295: EMPTY
6296: LIST
6297: PUSH
6298: EMPTY
6299: LIST
6300: LIST
6301: LIST
6302: PPUSH
6303: CALL_OW 69
6307: ST_TO_ADDR
// if not tmp then
6308: LD_VAR 0 1
6312: NOT
6313: IFFALSE 6317
// exit ;
6315: GO 6486
// b := IsInUnit ( tmp [ 1 ] ) ;
6317: LD_ADDR_VAR 0 2
6321: PUSH
6322: LD_VAR 0 1
6326: PUSH
6327: LD_INT 1
6329: ARRAY
6330: PPUSH
6331: CALL_OW 310
6335: ST_TO_ADDR
// if not b or HasTask ( tmp [ 1 ] ) then
6336: LD_VAR 0 2
6340: NOT
6341: PUSH
6342: LD_VAR 0 1
6346: PUSH
6347: LD_INT 1
6349: ARRAY
6350: PPUSH
6351: CALL_OW 314
6355: OR
6356: IFFALSE 6360
// exit ;
6358: GO 6486
// if b = us_bun1 then
6360: LD_VAR 0 2
6364: PUSH
6365: LD_INT 80
6367: EQUAL
6368: IFFALSE 6429
// begin ComExitBuilding ( tmp [ 1 ] ) ;
6370: LD_VAR 0 1
6374: PUSH
6375: LD_INT 1
6377: ARRAY
6378: PPUSH
6379: CALL_OW 122
// AddComAgressiveMove ( tmp [ 1 ] , 27 , 44 ) ;
6383: LD_VAR 0 1
6387: PUSH
6388: LD_INT 1
6390: ARRAY
6391: PPUSH
6392: LD_INT 27
6394: PPUSH
6395: LD_INT 44
6397: PPUSH
6398: CALL_OW 174
// if IsOk ( us_bun2 ) then
6402: LD_INT 55
6404: PPUSH
6405: CALL_OW 302
6409: IFFALSE 6427
// AddComEnterUnit ( tmp [ 1 ] , us_bun2 ) ;
6411: LD_VAR 0 1
6415: PUSH
6416: LD_INT 1
6418: ARRAY
6419: PPUSH
6420: LD_INT 55
6422: PPUSH
6423: CALL_OW 180
// end else
6427: GO 6486
// begin ComExitBuilding ( tmp [ 1 ] ) ;
6429: LD_VAR 0 1
6433: PUSH
6434: LD_INT 1
6436: ARRAY
6437: PPUSH
6438: CALL_OW 122
// AddComAgressiveMove ( tmp [ 1 ] , 92 , 51 ) ;
6442: LD_VAR 0 1
6446: PUSH
6447: LD_INT 1
6449: ARRAY
6450: PPUSH
6451: LD_INT 92
6453: PPUSH
6454: LD_INT 51
6456: PPUSH
6457: CALL_OW 174
// if IsOk ( us_bun1 ) then
6461: LD_INT 80
6463: PPUSH
6464: CALL_OW 302
6468: IFFALSE 6486
// AddComEnterUnit ( tmp [ 1 ] , us_bun1 ) ;
6470: LD_VAR 0 1
6474: PUSH
6475: LD_INT 1
6477: ARRAY
6478: PPUSH
6479: LD_INT 80
6481: PPUSH
6482: CALL_OW 180
// end ; end ;
6486: PPOPN 2
6488: END
// every 0 0$1 trigger not planCaptured and FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var i , tmp , tmp2 , b ;
6489: LD_EXP 7
6493: NOT
6494: PUSH
6495: LD_INT 9
6497: PPUSH
6498: LD_INT 22
6500: PUSH
6501: LD_INT 1
6503: PUSH
6504: EMPTY
6505: LIST
6506: LIST
6507: PUSH
6508: LD_INT 21
6510: PUSH
6511: LD_INT 3
6513: PUSH
6514: EMPTY
6515: LIST
6516: LIST
6517: PUSH
6518: LD_INT 3
6520: PUSH
6521: LD_INT 24
6523: PUSH
6524: LD_INT 1000
6526: PUSH
6527: EMPTY
6528: LIST
6529: LIST
6530: PUSH
6531: EMPTY
6532: LIST
6533: LIST
6534: PUSH
6535: EMPTY
6536: LIST
6537: LIST
6538: LIST
6539: PPUSH
6540: CALL_OW 70
6544: AND
6545: IFFALSE 6956
6547: GO 6549
6549: DISABLE
6550: LD_INT 0
6552: PPUSH
6553: PPUSH
6554: PPUSH
6555: PPUSH
// begin enable ;
6556: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_lives , 1000 ] ] ) ;
6557: LD_ADDR_VAR 0 2
6561: PUSH
6562: LD_INT 22
6564: PUSH
6565: LD_INT 1
6567: PUSH
6568: EMPTY
6569: LIST
6570: LIST
6571: PUSH
6572: LD_INT 25
6574: PUSH
6575: LD_INT 2
6577: PUSH
6578: EMPTY
6579: LIST
6580: LIST
6581: PUSH
6582: LD_INT 24
6584: PUSH
6585: LD_INT 1000
6587: PUSH
6588: EMPTY
6589: LIST
6590: LIST
6591: PUSH
6592: EMPTY
6593: LIST
6594: LIST
6595: LIST
6596: PPUSH
6597: CALL_OW 69
6601: ST_TO_ADDR
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_not , [ f_lives , 750 ] ] ] ) ;
6602: LD_ADDR_VAR 0 3
6606: PUSH
6607: LD_INT 22
6609: PUSH
6610: LD_INT 1
6612: PUSH
6613: EMPTY
6614: LIST
6615: LIST
6616: PUSH
6617: LD_INT 25
6619: PUSH
6620: LD_INT 2
6622: PUSH
6623: EMPTY
6624: LIST
6625: LIST
6626: PUSH
6627: LD_INT 3
6629: PUSH
6630: LD_INT 24
6632: PUSH
6633: LD_INT 750
6635: PUSH
6636: EMPTY
6637: LIST
6638: LIST
6639: PUSH
6640: EMPTY
6641: LIST
6642: LIST
6643: PUSH
6644: EMPTY
6645: LIST
6646: LIST
6647: LIST
6648: PPUSH
6649: CALL_OW 69
6653: ST_TO_ADDR
// b := FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) diff us_lab ;
6654: LD_ADDR_VAR 0 4
6658: PUSH
6659: LD_INT 9
6661: PPUSH
6662: LD_INT 22
6664: PUSH
6665: LD_INT 1
6667: PUSH
6668: EMPTY
6669: LIST
6670: LIST
6671: PUSH
6672: LD_INT 21
6674: PUSH
6675: LD_INT 3
6677: PUSH
6678: EMPTY
6679: LIST
6680: LIST
6681: PUSH
6682: LD_INT 3
6684: PUSH
6685: LD_INT 24
6687: PUSH
6688: LD_INT 1000
6690: PUSH
6691: EMPTY
6692: LIST
6693: LIST
6694: PUSH
6695: EMPTY
6696: LIST
6697: LIST
6698: PUSH
6699: EMPTY
6700: LIST
6701: LIST
6702: LIST
6703: PPUSH
6704: CALL_OW 70
6708: PUSH
6709: LD_INT 1
6711: DIFF
6712: ST_TO_ADDR
// if not tmp and not tmp2 then
6713: LD_VAR 0 2
6717: NOT
6718: PUSH
6719: LD_VAR 0 3
6723: NOT
6724: AND
6725: IFFALSE 6729
// exit ;
6727: GO 6956
// if tmp and b then
6729: LD_VAR 0 2
6733: PUSH
6734: LD_VAR 0 4
6738: AND
6739: IFFALSE 6869
// for i in tmp do
6741: LD_ADDR_VAR 0 1
6745: PUSH
6746: LD_VAR 0 2
6750: PUSH
6751: FOR_IN
6752: IFFALSE 6867
// begin if GetTag ( i ) = 1 and GetLives ( i ) < 1000 then
6754: LD_VAR 0 1
6758: PPUSH
6759: CALL_OW 110
6763: PUSH
6764: LD_INT 1
6766: EQUAL
6767: PUSH
6768: LD_VAR 0 1
6772: PPUSH
6773: CALL_OW 256
6777: PUSH
6778: LD_INT 1000
6780: LESS
6781: AND
6782: IFFALSE 6788
// continue else
6784: GO 6751
6786: GO 6815
// if GetTag ( i ) = 1 then
6788: LD_VAR 0 1
6792: PPUSH
6793: CALL_OW 110
6797: PUSH
6798: LD_INT 1
6800: EQUAL
6801: IFFALSE 6815
// SetTag ( i , 0 ) ;
6803: LD_VAR 0 1
6807: PPUSH
6808: LD_INT 0
6810: PPUSH
6811: CALL_OW 109
// if IsInUnit ( i ) then
6815: LD_VAR 0 1
6819: PPUSH
6820: CALL_OW 310
6824: IFFALSE 6835
// ComExitBuilding ( i ) ;
6826: LD_VAR 0 1
6830: PPUSH
6831: CALL_OW 122
// if not HasTask ( i ) then
6835: LD_VAR 0 1
6839: PPUSH
6840: CALL_OW 314
6844: NOT
6845: IFFALSE 6865
// AddComRepairBuilding ( i , b [ 1 ] ) ;
6847: LD_VAR 0 1
6851: PPUSH
6852: LD_VAR 0 4
6856: PUSH
6857: LD_INT 1
6859: ARRAY
6860: PPUSH
6861: CALL_OW 190
// end ;
6865: GO 6751
6867: POP
6868: POP
// if tmp2 then
6869: LD_VAR 0 3
6873: IFFALSE 6956
// for i in tmp2 do
6875: LD_ADDR_VAR 0 1
6879: PUSH
6880: LD_VAR 0 3
6884: PUSH
6885: FOR_IN
6886: IFFALSE 6954
// begin if not GetTag ( i ) = 1 then
6888: LD_VAR 0 1
6892: PPUSH
6893: CALL_OW 110
6897: PUSH
6898: LD_INT 1
6900: EQUAL
6901: NOT
6902: IFFALSE 6916
// SetTag ( i , 1 ) ;
6904: LD_VAR 0 1
6908: PPUSH
6909: LD_INT 1
6911: PPUSH
6912: CALL_OW 109
// if GetDistUnitXY ( i , 88 , 75 ) > 6 then
6916: LD_VAR 0 1
6920: PPUSH
6921: LD_INT 88
6923: PPUSH
6924: LD_INT 75
6926: PPUSH
6927: CALL_OW 297
6931: PUSH
6932: LD_INT 6
6934: GREATER
6935: IFFALSE 6952
// ComMoveXY ( i , 88 , 75 ) ;
6937: LD_VAR 0 1
6941: PPUSH
6942: LD_INT 88
6944: PPUSH
6945: LD_INT 75
6947: PPUSH
6948: CALL_OW 111
// end ;
6952: GO 6885
6954: POP
6955: POP
// end ;
6956: PPOPN 4
6958: END
// every 0 0$1 trigger not planCaptured and stevensTimer and FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var i , sci , tmp ;
6959: LD_EXP 7
6963: NOT
6964: PUSH
6965: LD_EXP 9
6969: AND
6970: PUSH
6971: LD_INT 9
6973: PPUSH
6974: LD_INT 22
6976: PUSH
6977: LD_INT 1
6979: PUSH
6980: EMPTY
6981: LIST
6982: LIST
6983: PUSH
6984: LD_INT 21
6986: PUSH
6987: LD_INT 1
6989: PUSH
6990: EMPTY
6991: LIST
6992: LIST
6993: PUSH
6994: LD_INT 3
6996: PUSH
6997: LD_INT 24
6999: PUSH
7000: LD_INT 1000
7002: PUSH
7003: EMPTY
7004: LIST
7005: LIST
7006: PUSH
7007: EMPTY
7008: LIST
7009: LIST
7010: PUSH
7011: EMPTY
7012: LIST
7013: LIST
7014: LIST
7015: PPUSH
7016: CALL_OW 70
7020: AND
7021: IFFALSE 7194
7023: GO 7025
7025: DISABLE
7026: LD_INT 0
7028: PPUSH
7029: PPUSH
7030: PPUSH
// begin enable ;
7031: ENABLE
// sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
7032: LD_ADDR_VAR 0 2
7036: PUSH
7037: LD_INT 22
7039: PUSH
7040: LD_INT 1
7042: PUSH
7043: EMPTY
7044: LIST
7045: LIST
7046: PUSH
7047: LD_INT 25
7049: PUSH
7050: LD_INT 4
7052: PUSH
7053: EMPTY
7054: LIST
7055: LIST
7056: PUSH
7057: EMPTY
7058: LIST
7059: LIST
7060: PPUSH
7061: CALL_OW 69
7065: ST_TO_ADDR
// tmp := FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
7066: LD_ADDR_VAR 0 3
7070: PUSH
7071: LD_INT 9
7073: PPUSH
7074: LD_INT 22
7076: PUSH
7077: LD_INT 1
7079: PUSH
7080: EMPTY
7081: LIST
7082: LIST
7083: PUSH
7084: LD_INT 21
7086: PUSH
7087: LD_INT 1
7089: PUSH
7090: EMPTY
7091: LIST
7092: LIST
7093: PUSH
7094: LD_INT 3
7096: PUSH
7097: LD_INT 24
7099: PUSH
7100: LD_INT 1000
7102: PUSH
7103: EMPTY
7104: LIST
7105: LIST
7106: PUSH
7107: EMPTY
7108: LIST
7109: LIST
7110: PUSH
7111: EMPTY
7112: LIST
7113: LIST
7114: LIST
7115: PPUSH
7116: CALL_OW 70
7120: ST_TO_ADDR
// if not sci or not tmp then
7121: LD_VAR 0 2
7125: NOT
7126: PUSH
7127: LD_VAR 0 3
7131: NOT
7132: OR
7133: IFFALSE 7137
// exit ;
7135: GO 7194
// for i in sci do
7137: LD_ADDR_VAR 0 1
7141: PUSH
7142: LD_VAR 0 2
7146: PUSH
7147: FOR_IN
7148: IFFALSE 7192
// if IsInUnit ( i ) then
7150: LD_VAR 0 1
7154: PPUSH
7155: CALL_OW 310
7159: IFFALSE 7172
// ComExitBuilding ( i ) else
7161: LD_VAR 0 1
7165: PPUSH
7166: CALL_OW 122
7170: GO 7190
// ComHeal ( i , tmp [ 1 ] ) ;
7172: LD_VAR 0 1
7176: PPUSH
7177: LD_VAR 0 3
7181: PUSH
7182: LD_INT 1
7184: ARRAY
7185: PPUSH
7186: CALL_OW 128
7190: GO 7147
7192: POP
7193: POP
// end ;
7194: PPOPN 3
7196: END
// every 0 0$1 trigger not planCaptured and stevensTimer and IsOk ( us_lab ) and not FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_outside ] ] ) do var i ;
7197: LD_EXP 7
7201: NOT
7202: PUSH
7203: LD_EXP 9
7207: AND
7208: PUSH
7209: LD_INT 1
7211: PPUSH
7212: CALL_OW 302
7216: AND
7217: PUSH
7218: LD_INT 9
7220: PPUSH
7221: LD_INT 22
7223: PUSH
7224: LD_INT 1
7226: PUSH
7227: EMPTY
7228: LIST
7229: LIST
7230: PUSH
7231: LD_INT 21
7233: PUSH
7234: LD_INT 1
7236: PUSH
7237: EMPTY
7238: LIST
7239: LIST
7240: PUSH
7241: LD_INT 3
7243: PUSH
7244: LD_INT 24
7246: PUSH
7247: LD_INT 1000
7249: PUSH
7250: EMPTY
7251: LIST
7252: LIST
7253: PUSH
7254: EMPTY
7255: LIST
7256: LIST
7257: PUSH
7258: EMPTY
7259: LIST
7260: LIST
7261: LIST
7262: PPUSH
7263: CALL_OW 70
7267: NOT
7268: AND
7269: PUSH
7270: LD_INT 22
7272: PUSH
7273: LD_INT 1
7275: PUSH
7276: EMPTY
7277: LIST
7278: LIST
7279: PUSH
7280: LD_INT 25
7282: PUSH
7283: LD_INT 4
7285: PUSH
7286: EMPTY
7287: LIST
7288: LIST
7289: PUSH
7290: LD_INT 56
7292: PUSH
7293: EMPTY
7294: LIST
7295: PUSH
7296: EMPTY
7297: LIST
7298: LIST
7299: LIST
7300: PPUSH
7301: CALL_OW 69
7305: AND
7306: IFFALSE 7399
7308: GO 7310
7310: DISABLE
7311: LD_INT 0
7313: PPUSH
// begin enable ;
7314: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_outside ] ] ) do
7315: LD_ADDR_VAR 0 1
7319: PUSH
7320: LD_INT 22
7322: PUSH
7323: LD_INT 1
7325: PUSH
7326: EMPTY
7327: LIST
7328: LIST
7329: PUSH
7330: LD_INT 25
7332: PUSH
7333: LD_INT 4
7335: PUSH
7336: EMPTY
7337: LIST
7338: LIST
7339: PUSH
7340: LD_INT 56
7342: PUSH
7343: EMPTY
7344: LIST
7345: PUSH
7346: EMPTY
7347: LIST
7348: LIST
7349: LIST
7350: PPUSH
7351: CALL_OW 69
7355: PUSH
7356: FOR_IN
7357: IFFALSE 7397
// if not GetTag ( i ) and not HasTask ( i ) then
7359: LD_VAR 0 1
7363: PPUSH
7364: CALL_OW 110
7368: NOT
7369: PUSH
7370: LD_VAR 0 1
7374: PPUSH
7375: CALL_OW 314
7379: NOT
7380: AND
7381: IFFALSE 7395
// ComEnterUnit ( i , us_lab ) ;
7383: LD_VAR 0 1
7387: PPUSH
7388: LD_INT 1
7390: PPUSH
7391: CALL_OW 120
7395: GO 7356
7397: POP
7398: POP
// end ;
7399: PPOPN 1
7401: END
// every 0 0$1 trigger not planCaptured and not FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_outside ] ] ) do var i ;
7402: LD_EXP 7
7406: NOT
7407: PUSH
7408: LD_INT 9
7410: PPUSH
7411: LD_INT 22
7413: PUSH
7414: LD_INT 1
7416: PUSH
7417: EMPTY
7418: LIST
7419: LIST
7420: PUSH
7421: LD_INT 21
7423: PUSH
7424: LD_INT 3
7426: PUSH
7427: EMPTY
7428: LIST
7429: LIST
7430: PUSH
7431: LD_INT 3
7433: PUSH
7434: LD_INT 24
7436: PUSH
7437: LD_INT 1000
7439: PUSH
7440: EMPTY
7441: LIST
7442: LIST
7443: PUSH
7444: EMPTY
7445: LIST
7446: LIST
7447: PUSH
7448: EMPTY
7449: LIST
7450: LIST
7451: LIST
7452: PPUSH
7453: CALL_OW 70
7457: NOT
7458: AND
7459: PUSH
7460: LD_INT 22
7462: PUSH
7463: LD_INT 1
7465: PUSH
7466: EMPTY
7467: LIST
7468: LIST
7469: PUSH
7470: LD_INT 25
7472: PUSH
7473: LD_INT 2
7475: PUSH
7476: EMPTY
7477: LIST
7478: LIST
7479: PUSH
7480: LD_INT 56
7482: PUSH
7483: EMPTY
7484: LIST
7485: PUSH
7486: EMPTY
7487: LIST
7488: LIST
7489: LIST
7490: PPUSH
7491: CALL_OW 69
7495: AND
7496: IFFALSE 7589
7498: GO 7500
7500: DISABLE
7501: LD_INT 0
7503: PPUSH
// begin enable ;
7504: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_outside ] ] ) do
7505: LD_ADDR_VAR 0 1
7509: PUSH
7510: LD_INT 22
7512: PUSH
7513: LD_INT 1
7515: PUSH
7516: EMPTY
7517: LIST
7518: LIST
7519: PUSH
7520: LD_INT 25
7522: PUSH
7523: LD_INT 2
7525: PUSH
7526: EMPTY
7527: LIST
7528: LIST
7529: PUSH
7530: LD_INT 56
7532: PUSH
7533: EMPTY
7534: LIST
7535: PUSH
7536: EMPTY
7537: LIST
7538: LIST
7539: LIST
7540: PPUSH
7541: CALL_OW 69
7545: PUSH
7546: FOR_IN
7547: IFFALSE 7587
// if not HasTask ( i ) and not GetTag ( i ) then
7549: LD_VAR 0 1
7553: PPUSH
7554: CALL_OW 314
7558: NOT
7559: PUSH
7560: LD_VAR 0 1
7564: PPUSH
7565: CALL_OW 110
7569: NOT
7570: AND
7571: IFFALSE 7585
// ComEnterUnit ( i , us_depot ) ;
7573: LD_VAR 0 1
7577: PPUSH
7578: LD_INT 5
7580: PPUSH
7581: CALL_OW 120
7585: GO 7546
7587: POP
7588: POP
// end ;
7589: PPOPN 1
7591: END
// every 0 0$1 trigger ( stevensTimer <= 0 0$00 or IsDead ( Stevens ) ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) do
7592: LD_EXP 9
7596: PUSH
7597: LD_INT 0
7599: LESSEQUAL
7600: PUSH
7601: LD_EXP 16
7605: PPUSH
7606: CALL_OW 301
7610: OR
7611: PUSH
7612: LD_INT 22
7614: PUSH
7615: LD_INT 1
7617: PUSH
7618: EMPTY
7619: LIST
7620: LIST
7621: PUSH
7622: LD_INT 25
7624: PUSH
7625: LD_INT 2
7627: PUSH
7628: EMPTY
7629: LIST
7630: LIST
7631: PUSH
7632: EMPTY
7633: LIST
7634: LIST
7635: PPUSH
7636: CALL_OW 69
7640: AND
7641: IFFALSE 7682
7643: GO 7645
7645: DISABLE
// ComDismantle ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) , us_lab ) ;
7646: LD_INT 22
7648: PUSH
7649: LD_INT 1
7651: PUSH
7652: EMPTY
7653: LIST
7654: LIST
7655: PUSH
7656: LD_INT 25
7658: PUSH
7659: LD_INT 2
7661: PUSH
7662: EMPTY
7663: LIST
7664: LIST
7665: PUSH
7666: EMPTY
7667: LIST
7668: LIST
7669: PPUSH
7670: CALL_OW 69
7674: PPUSH
7675: LD_INT 1
7677: PPUSH
7678: CALL_OW 167
7682: END
// every 0 0$4 trigger not planCaptured and FilterUnitsInArea ( usBaseCriticalArea , [ f_side , 7 ] ) do var i ;
7683: LD_EXP 7
7687: NOT
7688: PUSH
7689: LD_INT 7
7691: PPUSH
7692: LD_INT 22
7694: PUSH
7695: LD_INT 7
7697: PUSH
7698: EMPTY
7699: LIST
7700: LIST
7701: PPUSH
7702: CALL_OW 70
7706: AND
7707: IFFALSE 7798
7709: GO 7711
7711: DISABLE
7712: LD_INT 0
7714: PPUSH
// begin wait ( 0 0$2 ) ;
7715: LD_INT 70
7717: PPUSH
7718: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) do
7722: LD_ADDR_VAR 0 1
7726: PUSH
7727: LD_INT 22
7729: PUSH
7730: LD_INT 1
7732: PUSH
7733: EMPTY
7734: LIST
7735: LIST
7736: PUSH
7737: LD_INT 25
7739: PUSH
7740: LD_INT 1
7742: PUSH
7743: EMPTY
7744: LIST
7745: LIST
7746: PUSH
7747: EMPTY
7748: LIST
7749: LIST
7750: PPUSH
7751: CALL_OW 69
7755: PUSH
7756: FOR_IN
7757: IFFALSE 7796
// begin if IsInUnit ( i ) then
7759: LD_VAR 0 1
7763: PPUSH
7764: CALL_OW 310
7768: IFFALSE 7779
// ComExitBuilding ( i ) ;
7770: LD_VAR 0 1
7774: PPUSH
7775: CALL_OW 122
// AddComAgressiveMove ( i , 92 , 78 ) ;
7779: LD_VAR 0 1
7783: PPUSH
7784: LD_INT 92
7786: PPUSH
7787: LD_INT 78
7789: PPUSH
7790: CALL_OW 174
// end ;
7794: GO 7756
7796: POP
7797: POP
// end ; end_of_file
7798: PPOPN 1
7800: END
// on SiberiteRocketExploded ( sibRocket , x , y ) do OnBombExploded ( sibRocket , x , y ) ;
7801: LD_VAR 0 1
7805: PPUSH
7806: LD_VAR 0 2
7810: PPUSH
7811: LD_VAR 0 3
7815: PPUSH
7816: CALL 2786 0 3
7820: PPOPN 3
7822: END
// on UnitGoesToRed ( un ) do begin if GetClass ( JMM ) = 4 or GetClass ( Burlak ) = 4 then
7823: LD_EXP 12
7827: PPUSH
7828: CALL_OW 257
7832: PUSH
7833: LD_INT 4
7835: EQUAL
7836: PUSH
7837: LD_EXP 13
7841: PPUSH
7842: CALL_OW 257
7846: PUSH
7847: LD_INT 4
7849: EQUAL
7850: OR
7851: IFFALSE 7855
// exit ;
7853: GO 7893
// if un = JMM then
7855: LD_VAR 0 1
7859: PUSH
7860: LD_EXP 12
7864: EQUAL
7865: IFFALSE 7874
// YouLost ( JMM ) ;
7867: LD_STRING JMM
7869: PPUSH
7870: CALL_OW 104
// if un = Burlak then
7874: LD_VAR 0 1
7878: PUSH
7879: LD_EXP 13
7883: EQUAL
7884: IFFALSE 7893
// YouLost ( Burlak ) ;
7886: LD_STRING Burlak
7888: PPUSH
7889: CALL_OW 104
// end ;
7893: PPOPN 1
7895: END
// on UnitDestroyed ( un ) do begin if un = JMM then
7896: LD_VAR 0 1
7900: PUSH
7901: LD_EXP 12
7905: EQUAL
7906: IFFALSE 7915
// YouLost ( JMM ) ;
7908: LD_STRING JMM
7910: PPUSH
7911: CALL_OW 104
// if un = Burlak then
7915: LD_VAR 0 1
7919: PUSH
7920: LD_EXP 13
7924: EQUAL
7925: IFFALSE 7934
// YouLost ( Burlak ) ;
7927: LD_STRING Burlak
7929: PPUSH
7930: CALL_OW 104
// end ;
7934: PPOPN 1
7936: END
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 7 then
7937: LD_VAR 0 1
7941: PPUSH
7942: CALL_OW 255
7946: PUSH
7947: LD_INT 7
7949: EQUAL
7950: IFFALSE 7960
// artifactPickedUp := true ;
7952: LD_ADDR_EXP 6
7956: PUSH
7957: LD_INT 1
7959: ST_TO_ADDR
// end ;
7960: PPOPN 2
7962: END
// on ArtifactUnloaded ( cargo , artifact ) do artifactPickedUp := false ;
7963: LD_ADDR_EXP 6
7967: PUSH
7968: LD_INT 0
7970: ST_TO_ADDR
7971: PPOPN 2
7973: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( vehicle ) <> 1 then
7974: LD_VAR 0 1
7978: PPUSH
7979: CALL_OW 255
7983: PUSH
7984: LD_INT 1
7986: NONEQUAL
7987: IFFALSE 7991
// exit ;
7989: GO 8038
// wait ( 0 0$5 ) ;
7991: LD_INT 175
7993: PPUSH
7994: CALL_OW 67
// if GetControl ( vehicle ) = control_remote then
7998: LD_VAR 0 1
8002: PPUSH
8003: CALL_OW 263
8007: PUSH
8008: LD_INT 2
8010: EQUAL
8011: IFFALSE 8022
// Connect ( vehicle ) ;
8013: LD_VAR 0 1
8017: PPUSH
8018: CALL 1787 0 1
// vehGuard := vehGuard ^ vehicle ;
8022: LD_ADDR_EXP 21
8026: PUSH
8027: LD_EXP 21
8031: PUSH
8032: LD_VAR 0 1
8036: ADD
8037: ST_TO_ADDR
// end ;
8038: PPOPN 2
8040: END
// on BuildingCaptured ( captured , old_side , unit ) do begin if captured = us_lab and not planCaptured then
8041: LD_VAR 0 1
8045: PUSH
8046: LD_INT 1
8048: EQUAL
8049: PUSH
8050: LD_EXP 7
8054: NOT
8055: AND
8056: IFFALSE 8091
// begin planCaptured := true ;
8058: LD_ADDR_EXP 7
8062: PUSH
8063: LD_INT 1
8065: ST_TO_ADDR
// ChangeMissionObjectives ( MEnd ) ;
8066: LD_STRING MEnd
8068: PPUSH
8069: CALL_OW 337
// canEnd := true ;
8073: LD_ADDR_EXP 10
8077: PUSH
8078: LD_INT 1
8080: ST_TO_ADDR
// missionTime := tick ;
8081: LD_ADDR_EXP 11
8085: PUSH
8086: LD_OWVAR 1
8090: ST_TO_ADDR
// end ; end ;
8091: PPOPN 3
8093: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
8094: LD_VAR 0 1
8098: PPUSH
8099: CALL 8248 0 1
// end ; end_of_file
8103: PPOPN 1
8105: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
8106: GO 8108
8108: DISABLE
// begin ru_radar := 98 ;
8109: LD_ADDR_EXP 22
8113: PUSH
8114: LD_INT 98
8116: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
8117: LD_ADDR_EXP 23
8121: PUSH
8122: LD_INT 89
8124: ST_TO_ADDR
// us_hack := 99 ;
8125: LD_ADDR_EXP 24
8129: PUSH
8130: LD_INT 99
8132: ST_TO_ADDR
// us_artillery := 97 ;
8133: LD_ADDR_EXP 25
8137: PUSH
8138: LD_INT 97
8140: ST_TO_ADDR
// ar_bio_bomb := 91 ;
8141: LD_ADDR_EXP 26
8145: PUSH
8146: LD_INT 91
8148: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
8149: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
8150: LD_INT 0
8152: PPUSH
8153: PPUSH
8154: PPUSH
8155: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
8156: LD_VAR 0 1
8160: PPUSH
8161: CALL_OW 264
8165: PUSH
8166: LD_EXP 26
8170: EQUAL
8171: IFFALSE 8243
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
8173: LD_INT 68
8175: PPUSH
8176: LD_VAR 0 1
8180: PPUSH
8181: CALL_OW 255
8185: PPUSH
8186: CALL_OW 321
8190: PUSH
8191: LD_INT 2
8193: EQUAL
8194: IFFALSE 8206
// eff := 70 else
8196: LD_ADDR_VAR 0 6
8200: PUSH
8201: LD_INT 70
8203: ST_TO_ADDR
8204: GO 8214
// eff := 30 ;
8206: LD_ADDR_VAR 0 6
8210: PUSH
8211: LD_INT 30
8213: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
8214: LD_VAR 0 1
8218: PPUSH
8219: CALL_OW 250
8223: PPUSH
8224: LD_VAR 0 1
8228: PPUSH
8229: CALL_OW 251
8233: PPUSH
8234: LD_VAR 0 6
8238: PPUSH
8239: CALL_OW 495
// end ; end ;
8243: LD_VAR 0 4
8247: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
8248: LD_INT 0
8250: PPUSH
8251: PPUSH
8252: PPUSH
8253: PPUSH
8254: PPUSH
8255: PPUSH
// if cmd = 124 then
8256: LD_VAR 0 1
8260: PUSH
8261: LD_INT 124
8263: EQUAL
8264: IFFALSE 8470
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
8266: LD_ADDR_VAR 0 5
8270: PUSH
8271: LD_INT 2
8273: PUSH
8274: LD_INT 34
8276: PUSH
8277: LD_INT 53
8279: PUSH
8280: EMPTY
8281: LIST
8282: LIST
8283: PUSH
8284: LD_INT 34
8286: PUSH
8287: LD_INT 14
8289: PUSH
8290: EMPTY
8291: LIST
8292: LIST
8293: PUSH
8294: EMPTY
8295: LIST
8296: LIST
8297: LIST
8298: PPUSH
8299: CALL_OW 69
8303: ST_TO_ADDR
// if not tmp then
8304: LD_VAR 0 5
8308: NOT
8309: IFFALSE 8313
// exit ;
8311: GO 8470
// for i in tmp do
8313: LD_ADDR_VAR 0 3
8317: PUSH
8318: LD_VAR 0 5
8322: PUSH
8323: FOR_IN
8324: IFFALSE 8468
// begin taskList := GetTaskList ( i ) ;
8326: LD_ADDR_VAR 0 6
8330: PUSH
8331: LD_VAR 0 3
8335: PPUSH
8336: CALL_OW 437
8340: ST_TO_ADDR
// if not taskList then
8341: LD_VAR 0 6
8345: NOT
8346: IFFALSE 8350
// continue ;
8348: GO 8323
// for j = 1 to taskList do
8350: LD_ADDR_VAR 0 4
8354: PUSH
8355: DOUBLE
8356: LD_INT 1
8358: DEC
8359: ST_TO_ADDR
8360: LD_VAR 0 6
8364: PUSH
8365: FOR_TO
8366: IFFALSE 8464
// if taskList [ j ] [ 1 ] = | then
8368: LD_VAR 0 6
8372: PUSH
8373: LD_VAR 0 4
8377: ARRAY
8378: PUSH
8379: LD_INT 1
8381: ARRAY
8382: PUSH
8383: LD_STRING |
8385: EQUAL
8386: IFFALSE 8462
// begin _taskList := Delete ( taskList , 1 ) ;
8388: LD_ADDR_VAR 0 7
8392: PUSH
8393: LD_VAR 0 6
8397: PPUSH
8398: LD_INT 1
8400: PPUSH
8401: CALL_OW 3
8405: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
8406: LD_VAR 0 3
8410: PPUSH
8411: LD_VAR 0 7
8415: PPUSH
8416: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
8420: LD_VAR 0 3
8424: PPUSH
8425: LD_VAR 0 6
8429: PUSH
8430: LD_VAR 0 4
8434: ARRAY
8435: PUSH
8436: LD_INT 2
8438: ARRAY
8439: PPUSH
8440: LD_VAR 0 6
8444: PUSH
8445: LD_VAR 0 4
8449: ARRAY
8450: PUSH
8451: LD_INT 3
8453: ARRAY
8454: PPUSH
8455: LD_INT 8
8457: PPUSH
8458: CALL 8475 0 4
// end ;
8462: GO 8365
8464: POP
8465: POP
// end ;
8466: GO 8323
8468: POP
8469: POP
// end ; end ;
8470: LD_VAR 0 2
8474: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
8475: LD_INT 0
8477: PPUSH
8478: PPUSH
8479: PPUSH
8480: PPUSH
8481: PPUSH
8482: PPUSH
8483: PPUSH
8484: PPUSH
8485: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
8486: LD_VAR 0 1
8490: NOT
8491: PUSH
8492: LD_VAR 0 2
8496: PPUSH
8497: LD_VAR 0 3
8501: PPUSH
8502: CALL_OW 488
8506: NOT
8507: OR
8508: PUSH
8509: LD_VAR 0 4
8513: NOT
8514: OR
8515: IFFALSE 8519
// exit ;
8517: GO 8859
// list := [ ] ;
8519: LD_ADDR_VAR 0 13
8523: PUSH
8524: EMPTY
8525: ST_TO_ADDR
// if x - r < 0 then
8526: LD_VAR 0 2
8530: PUSH
8531: LD_VAR 0 4
8535: MINUS
8536: PUSH
8537: LD_INT 0
8539: LESS
8540: IFFALSE 8552
// min_x := 0 else
8542: LD_ADDR_VAR 0 7
8546: PUSH
8547: LD_INT 0
8549: ST_TO_ADDR
8550: GO 8568
// min_x := x - r ;
8552: LD_ADDR_VAR 0 7
8556: PUSH
8557: LD_VAR 0 2
8561: PUSH
8562: LD_VAR 0 4
8566: MINUS
8567: ST_TO_ADDR
// if y - r < 0 then
8568: LD_VAR 0 3
8572: PUSH
8573: LD_VAR 0 4
8577: MINUS
8578: PUSH
8579: LD_INT 0
8581: LESS
8582: IFFALSE 8594
// min_y := 0 else
8584: LD_ADDR_VAR 0 8
8588: PUSH
8589: LD_INT 0
8591: ST_TO_ADDR
8592: GO 8610
// min_y := y - r ;
8594: LD_ADDR_VAR 0 8
8598: PUSH
8599: LD_VAR 0 3
8603: PUSH
8604: LD_VAR 0 4
8608: MINUS
8609: ST_TO_ADDR
// max_x := x + r ;
8610: LD_ADDR_VAR 0 9
8614: PUSH
8615: LD_VAR 0 2
8619: PUSH
8620: LD_VAR 0 4
8624: PLUS
8625: ST_TO_ADDR
// max_y := y + r ;
8626: LD_ADDR_VAR 0 10
8630: PUSH
8631: LD_VAR 0 3
8635: PUSH
8636: LD_VAR 0 4
8640: PLUS
8641: ST_TO_ADDR
// for _x = min_x to max_x do
8642: LD_ADDR_VAR 0 11
8646: PUSH
8647: DOUBLE
8648: LD_VAR 0 7
8652: DEC
8653: ST_TO_ADDR
8654: LD_VAR 0 9
8658: PUSH
8659: FOR_TO
8660: IFFALSE 8777
// for _y = min_y to max_y do
8662: LD_ADDR_VAR 0 12
8666: PUSH
8667: DOUBLE
8668: LD_VAR 0 8
8672: DEC
8673: ST_TO_ADDR
8674: LD_VAR 0 10
8678: PUSH
8679: FOR_TO
8680: IFFALSE 8773
// begin if not ValidHex ( _x , _y ) then
8682: LD_VAR 0 11
8686: PPUSH
8687: LD_VAR 0 12
8691: PPUSH
8692: CALL_OW 488
8696: NOT
8697: IFFALSE 8701
// continue ;
8699: GO 8679
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
8701: LD_VAR 0 11
8705: PPUSH
8706: LD_VAR 0 12
8710: PPUSH
8711: CALL_OW 351
8715: PUSH
8716: LD_VAR 0 11
8720: PPUSH
8721: LD_VAR 0 12
8725: PPUSH
8726: CALL_OW 554
8730: AND
8731: IFFALSE 8771
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
8733: LD_ADDR_VAR 0 13
8737: PUSH
8738: LD_VAR 0 13
8742: PPUSH
8743: LD_VAR 0 13
8747: PUSH
8748: LD_INT 1
8750: PLUS
8751: PPUSH
8752: LD_VAR 0 11
8756: PUSH
8757: LD_VAR 0 12
8761: PUSH
8762: EMPTY
8763: LIST
8764: LIST
8765: PPUSH
8766: CALL_OW 2
8770: ST_TO_ADDR
// end ;
8771: GO 8679
8773: POP
8774: POP
8775: GO 8659
8777: POP
8778: POP
// if not list then
8779: LD_VAR 0 13
8783: NOT
8784: IFFALSE 8788
// exit ;
8786: GO 8859
// for i in list do
8788: LD_ADDR_VAR 0 6
8792: PUSH
8793: LD_VAR 0 13
8797: PUSH
8798: FOR_IN
8799: IFFALSE 8857
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
8801: LD_VAR 0 1
8805: PPUSH
8806: LD_STRING M
8808: PUSH
8809: LD_VAR 0 6
8813: PUSH
8814: LD_INT 1
8816: ARRAY
8817: PUSH
8818: LD_VAR 0 6
8822: PUSH
8823: LD_INT 2
8825: ARRAY
8826: PUSH
8827: LD_INT 0
8829: PUSH
8830: LD_INT 0
8832: PUSH
8833: LD_INT 0
8835: PUSH
8836: LD_INT 0
8838: PUSH
8839: EMPTY
8840: LIST
8841: LIST
8842: LIST
8843: LIST
8844: LIST
8845: LIST
8846: LIST
8847: PUSH
8848: EMPTY
8849: LIST
8850: PPUSH
8851: CALL_OW 447
8855: GO 8798
8857: POP
8858: POP
// end ;
8859: LD_VAR 0 5
8863: RET
