// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Init ;
  11: CALL 76 0 0
// PrepareNature ( 4 , 3 , 3 , 5 , 1 , 0 , 0 , natureArea , 0 ) ;
  15: LD_INT 4
  17: PPUSH
  18: LD_INT 3
  20: PPUSH
  21: LD_INT 3
  23: PPUSH
  24: LD_INT 5
  26: PPUSH
  27: LD_INT 1
  29: PPUSH
  30: LD_INT 0
  32: PPUSH
  33: LD_INT 0
  35: PPUSH
  36: LD_INT 6
  38: PPUSH
  39: LD_INT 0
  41: PPUSH
  42: CALL 1029 0 9
// PrepareAmerican ;
  46: CALL 5351 0 0
// PrepareAlliance ;
  50: CALL 226 0 0
// Action ;
  54: CALL 2194 0 0
// SaveForQuickRestart ;
  58: CALL_OW 22
// if debug then
  62: LD_EXP 1
  66: IFFALSE 75
// FogOff ( 7 ) ;
  68: LD_INT 7
  70: PPUSH
  71: CALL_OW 344
// end ;
  75: END
// export debug , activeBombTest , contaminateTime , bombExploded , enteredContaminatedArea , artifactPickedUp , planCaptured , seenBase , stevensTimer , canEnd , missionTime , killCounter , bunkerCounter ; function Init ; begin
  76: LD_INT 0
  78: PPUSH
// debug := false ;
  79: LD_ADDR_EXP 1
  83: PUSH
  84: LD_INT 0
  86: ST_TO_ADDR
// activeBombTest := false ;
  87: LD_ADDR_EXP 2
  91: PUSH
  92: LD_INT 0
  94: ST_TO_ADDR
// bombExploded := false ;
  95: LD_ADDR_EXP 4
  99: PUSH
 100: LD_INT 0
 102: ST_TO_ADDR
// contaminateTime := 0 0$00 ;
 103: LD_ADDR_EXP 3
 107: PUSH
 108: LD_INT 0
 110: ST_TO_ADDR
// enteredContaminatedArea := false ;
 111: LD_ADDR_EXP 5
 115: PUSH
 116: LD_INT 0
 118: ST_TO_ADDR
// artifactPickedUp := false ;
 119: LD_ADDR_EXP 6
 123: PUSH
 124: LD_INT 0
 126: ST_TO_ADDR
// planCaptured := false ;
 127: LD_ADDR_EXP 7
 131: PUSH
 132: LD_INT 0
 134: ST_TO_ADDR
// seenBase := false ;
 135: LD_ADDR_EXP 8
 139: PUSH
 140: LD_INT 0
 142: ST_TO_ADDR
// stevensTimer := [ 20 20$00 , 16 16$00 , 14 14$00 ] [ Difficulty ] ;
 143: LD_ADDR_EXP 9
 147: PUSH
 148: LD_INT 42000
 150: PUSH
 151: LD_INT 33600
 153: PUSH
 154: LD_INT 29400
 156: PUSH
 157: EMPTY
 158: LIST
 159: LIST
 160: LIST
 161: PUSH
 162: LD_OWVAR 67
 166: ARRAY
 167: ST_TO_ADDR
// canEnd := false ;
 168: LD_ADDR_EXP 10
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// missionTime := 0 0$00 ;
 176: LD_ADDR_EXP 11
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// killCounter := 0 ;
 184: LD_ADDR_EXP 12
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// bunkerCounter := 0 ;
 192: LD_ADDR_EXP 13
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// end ;
 200: LD_VAR 0 1
 204: RET
// every 0 0$1 trigger bunkerCounter >= 3 do
 205: LD_EXP 13
 209: PUSH
 210: LD_INT 3
 212: GREATEREQUAL
 213: IFFALSE 225
 215: GO 217
 217: DISABLE
// SetAchievement ( ACH_ONEMANARMY ) ; end_of_file
 218: LD_STRING ACH_ONEMANARMY
 220: PPUSH
 221: CALL_OW 543
 225: END
// export JMM , Burlak , Joan , RuSci ; export function PrepareAlliance ; var tmp , i , JMMVeh , BurlakVeh , VarJMMVeh , VarBurlakVeh ; begin
 226: LD_INT 0
 228: PPUSH
 229: PPUSH
 230: PPUSH
 231: PPUSH
 232: PPUSH
 233: PPUSH
 234: PPUSH
// uc_side := 7 ;
 235: LD_ADDR_OWVAR 20
 239: PUSH
 240: LD_INT 7
 242: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
 243: LD_ADDR_EXP 14
 247: PUSH
 248: LD_STRING JMM
 250: PPUSH
 251: LD_EXP 1
 255: NOT
 256: PPUSH
 257: LD_STRING 14a_
 259: PPUSH
 260: CALL 908 0 3
 264: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
 265: LD_ADDR_EXP 15
 269: PUSH
 270: LD_STRING Burlak
 272: PPUSH
 273: LD_EXP 1
 277: NOT
 278: PPUSH
 279: LD_STRING 14a_
 281: PPUSH
 282: CALL 908 0 3
 286: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
 287: LD_ADDR_EXP 16
 291: PUSH
 292: LD_STRING Joan
 294: PPUSH
 295: LD_EXP 1
 299: NOT
 300: PPUSH
 301: LD_STRING 13a_
 303: PPUSH
 304: CALL 908 0 3
 308: ST_TO_ADDR
// if not Joan then
 309: LD_EXP 16
 313: NOT
 314: IFFALSE 447
// begin tmp := CreateCharacterSet ( 13a_others ) ;
 316: LD_ADDR_VAR 0 2
 320: PUSH
 321: LD_STRING 13a_others
 323: PPUSH
 324: CALL_OW 31
 328: ST_TO_ADDR
// if tmp then
 329: LD_VAR 0 2
 333: IFFALSE 409
// begin for i in tmp do
 335: LD_ADDR_VAR 0 3
 339: PUSH
 340: LD_VAR 0 2
 344: PUSH
 345: FOR_IN
 346: IFFALSE 407
// if GetClass ( i ) = 4 and GetSex ( i ) = sex_male and GetNation ( i ) = nation_russian then
 348: LD_VAR 0 3
 352: PPUSH
 353: CALL_OW 257
 357: PUSH
 358: LD_INT 4
 360: EQUAL
 361: PUSH
 362: LD_VAR 0 3
 366: PPUSH
 367: CALL_OW 258
 371: PUSH
 372: LD_INT 1
 374: EQUAL
 375: AND
 376: PUSH
 377: LD_VAR 0 3
 381: PPUSH
 382: CALL_OW 248
 386: PUSH
 387: LD_INT 3
 389: EQUAL
 390: AND
 391: IFFALSE 405
// begin RuSci := i ;
 393: LD_ADDR_EXP 17
 397: PUSH
 398: LD_VAR 0 3
 402: ST_TO_ADDR
// break ;
 403: GO 407
// end ;
 405: GO 345
 407: POP
 408: POP
// end ; if not RuSci then
 409: LD_EXP 17
 413: NOT
 414: IFFALSE 447
// begin uc_nation := 3 ;
 416: LD_ADDR_OWVAR 21
 420: PUSH
 421: LD_INT 3
 423: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 10 ) ;
 424: LD_INT 1
 426: PPUSH
 427: LD_INT 4
 429: PPUSH
 430: LD_INT 10
 432: PPUSH
 433: CALL_OW 380
// RuSci := CreateHuman ;
 437: LD_ADDR_EXP 17
 441: PUSH
 442: CALL_OW 44
 446: ST_TO_ADDR
// end ; end ; VarJMMVeh := LoadVariable ( 14a_JMMVeh , [ us_morphling , engine_siberite , control_manual , us_rocket_launcher , 0 , 1 ] ) ;
 447: LD_ADDR_VAR 0 6
 451: PUSH
 452: LD_STRING 14a_JMMVeh
 454: PPUSH
 455: LD_INT 5
 457: PUSH
 458: LD_INT 3
 460: PUSH
 461: LD_INT 1
 463: PUSH
 464: LD_INT 7
 466: PUSH
 467: LD_INT 0
 469: PUSH
 470: LD_INT 1
 472: PUSH
 473: EMPTY
 474: LIST
 475: LIST
 476: LIST
 477: LIST
 478: LIST
 479: LIST
 480: PPUSH
 481: CALL_OW 30
 485: ST_TO_ADDR
// VarBurlakVeh := LoadVariable ( 14a_BurlakVeh , [ ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 0 , 3 ] ) ;
 486: LD_ADDR_VAR 0 7
 490: PUSH
 491: LD_STRING 14a_BurlakVeh
 493: PPUSH
 494: LD_INT 22
 496: PUSH
 497: LD_INT 3
 499: PUSH
 500: LD_INT 1
 502: PUSH
 503: LD_INT 51
 505: PUSH
 506: LD_INT 0
 508: PUSH
 509: LD_INT 3
 511: PUSH
 512: EMPTY
 513: LIST
 514: LIST
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: PPUSH
 520: CALL_OW 30
 524: ST_TO_ADDR
// uc_direction := 4 ;
 525: LD_ADDR_OWVAR 24
 529: PUSH
 530: LD_INT 4
 532: ST_TO_ADDR
// uc_nation := VarJMMVeh [ 6 ] ;
 533: LD_ADDR_OWVAR 21
 537: PUSH
 538: LD_VAR 0 6
 542: PUSH
 543: LD_INT 6
 545: ARRAY
 546: ST_TO_ADDR
// PrepareVehicle ( VarJMMVeh [ 1 ] , VarJMMVeh [ 2 ] , VarJMMVeh [ 3 ] , VarJMMVeh [ 4 ] , rand ( 60 , 80 ) ) ;
 547: LD_VAR 0 6
 551: PUSH
 552: LD_INT 1
 554: ARRAY
 555: PPUSH
 556: LD_VAR 0 6
 560: PUSH
 561: LD_INT 2
 563: ARRAY
 564: PPUSH
 565: LD_VAR 0 6
 569: PUSH
 570: LD_INT 3
 572: ARRAY
 573: PPUSH
 574: LD_VAR 0 6
 578: PUSH
 579: LD_INT 4
 581: ARRAY
 582: PPUSH
 583: LD_INT 60
 585: PPUSH
 586: LD_INT 80
 588: PPUSH
 589: CALL_OW 12
 593: PPUSH
 594: CALL 971 0 5
// JMMVeh := CreateVehicle ;
 598: LD_ADDR_VAR 0 4
 602: PUSH
 603: CALL_OW 45
 607: ST_TO_ADDR
// PlaceUnitInArea ( JMMVeh , startArea , false ) ;
 608: LD_VAR 0 4
 612: PPUSH
 613: LD_INT 1
 615: PPUSH
 616: LD_INT 0
 618: PPUSH
 619: CALL 1649 0 3
// if VarJMMVeh [ 5 ] <> 0 then
 623: LD_VAR 0 6
 627: PUSH
 628: LD_INT 5
 630: ARRAY
 631: PUSH
 632: LD_INT 0
 634: NONEQUAL
 635: IFFALSE 655
// SetMark ( JMMVeh , VarJMMVeh [ 5 ] ) ;
 637: LD_VAR 0 4
 641: PPUSH
 642: LD_VAR 0 6
 646: PUSH
 647: LD_INT 5
 649: ARRAY
 650: PPUSH
 651: CALL_OW 242
// PlaceHumanInUnit ( JMM , JMMVeh ) ;
 655: LD_EXP 14
 659: PPUSH
 660: LD_VAR 0 4
 664: PPUSH
 665: CALL_OW 52
// uc_nation := VarBurlakVeh [ 6 ] ;
 669: LD_ADDR_OWVAR 21
 673: PUSH
 674: LD_VAR 0 7
 678: PUSH
 679: LD_INT 6
 681: ARRAY
 682: ST_TO_ADDR
// PrepareVehicle ( VarBurlakVeh [ 1 ] , VarBurlakVeh [ 2 ] , VarBurlakVeh [ 3 ] , VarBurlakVeh [ 4 ] , rand ( 60 , 80 ) ) ;
 683: LD_VAR 0 7
 687: PUSH
 688: LD_INT 1
 690: ARRAY
 691: PPUSH
 692: LD_VAR 0 7
 696: PUSH
 697: LD_INT 2
 699: ARRAY
 700: PPUSH
 701: LD_VAR 0 7
 705: PUSH
 706: LD_INT 3
 708: ARRAY
 709: PPUSH
 710: LD_VAR 0 7
 714: PUSH
 715: LD_INT 4
 717: ARRAY
 718: PPUSH
 719: LD_INT 60
 721: PPUSH
 722: LD_INT 80
 724: PPUSH
 725: CALL_OW 12
 729: PPUSH
 730: CALL 971 0 5
// BurlakVeh := CreateVehicle ;
 734: LD_ADDR_VAR 0 5
 738: PUSH
 739: CALL_OW 45
 743: ST_TO_ADDR
// if not PlaceUnitInArea ( BurlakVeh , startArea , false ) then
 744: LD_VAR 0 5
 748: PPUSH
 749: LD_INT 1
 751: PPUSH
 752: LD_INT 0
 754: PPUSH
 755: CALL 1649 0 3
 759: NOT
 760: IFFALSE 780
// PlaceUnitXY ( BurlakVeh , 233 , 85 , false ) ;
 762: LD_VAR 0 5
 766: PPUSH
 767: LD_INT 233
 769: PPUSH
 770: LD_INT 85
 772: PPUSH
 773: LD_INT 0
 775: PPUSH
 776: CALL_OW 48
// if VarBurlakVeh [ 5 ] <> 0 then
 780: LD_VAR 0 7
 784: PUSH
 785: LD_INT 5
 787: ARRAY
 788: PUSH
 789: LD_INT 0
 791: NONEQUAL
 792: IFFALSE 812
// SetMark ( BurlakVeh , VarBurlakVeh [ 5 ] ) ;
 794: LD_VAR 0 5
 798: PPUSH
 799: LD_VAR 0 7
 803: PUSH
 804: LD_INT 5
 806: ARRAY
 807: PPUSH
 808: CALL_OW 242
// PlaceHumanInUnit ( Burlak , BurlakVeh ) ;
 812: LD_EXP 15
 816: PPUSH
 817: LD_VAR 0 5
 821: PPUSH
 822: CALL_OW 52
// tmp := [ [ 178 , 91 ] , [ 137 , 83 ] , [ 157 , 75 ] ] [ Difficulty ] ;
 826: LD_ADDR_VAR 0 2
 830: PUSH
 831: LD_INT 178
 833: PUSH
 834: LD_INT 91
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: PUSH
 841: LD_INT 137
 843: PUSH
 844: LD_INT 83
 846: PUSH
 847: EMPTY
 848: LIST
 849: LIST
 850: PUSH
 851: LD_INT 157
 853: PUSH
 854: LD_INT 75
 856: PUSH
 857: EMPTY
 858: LIST
 859: LIST
 860: PUSH
 861: EMPTY
 862: LIST
 863: LIST
 864: LIST
 865: PUSH
 866: LD_OWVAR 67
 870: ARRAY
 871: ST_TO_ADDR
// CreateResourcesXY ( mat_artifact , 4 , tmp [ 1 ] , tmp [ 2 ] , false ) ;
 872: LD_INT 4
 874: PPUSH
 875: LD_INT 4
 877: PPUSH
 878: LD_VAR 0 2
 882: PUSH
 883: LD_INT 1
 885: ARRAY
 886: PPUSH
 887: LD_VAR 0 2
 891: PUSH
 892: LD_INT 2
 894: ARRAY
 895: PPUSH
 896: LD_INT 0
 898: PPUSH
 899: CALL_OW 58
// end ; end_of_file
 903: LD_VAR 0 1
 907: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 908: LD_INT 0
 910: PPUSH
 911: PPUSH
// if exist_mode then
 912: LD_VAR 0 2
 916: IFFALSE 941
// unit := CreateCharacter ( prefix & ident ) else
 918: LD_ADDR_VAR 0 5
 922: PUSH
 923: LD_VAR 0 3
 927: PUSH
 928: LD_VAR 0 1
 932: STR
 933: PPUSH
 934: CALL_OW 34
 938: ST_TO_ADDR
 939: GO 956
// unit := NewCharacter ( ident ) ;
 941: LD_ADDR_VAR 0 5
 945: PUSH
 946: LD_VAR 0 1
 950: PPUSH
 951: CALL_OW 25
 955: ST_TO_ADDR
// result := unit ;
 956: LD_ADDR_VAR 0 4
 960: PUSH
 961: LD_VAR 0 5
 965: ST_TO_ADDR
// end ;
 966: LD_VAR 0 4
 970: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
 971: LD_INT 0
 973: PPUSH
// vc_chassis := chassis ;
 974: LD_ADDR_OWVAR 37
 978: PUSH
 979: LD_VAR 0 1
 983: ST_TO_ADDR
// vc_engine := engine ;
 984: LD_ADDR_OWVAR 39
 988: PUSH
 989: LD_VAR 0 2
 993: ST_TO_ADDR
// vc_control := control ;
 994: LD_ADDR_OWVAR 38
 998: PUSH
 999: LD_VAR 0 3
1003: ST_TO_ADDR
// vc_weapon := weapon ;
1004: LD_ADDR_OWVAR 40
1008: PUSH
1009: LD_VAR 0 4
1013: ST_TO_ADDR
// vc_fuel_battery := fuel ;
1014: LD_ADDR_OWVAR 41
1018: PUSH
1019: LD_VAR 0 5
1023: ST_TO_ADDR
// end ;
1024: LD_VAR 0 6
1028: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
1029: LD_INT 0
1031: PPUSH
1032: PPUSH
1033: PPUSH
// uc_side = 0 ;
1034: LD_ADDR_OWVAR 20
1038: PUSH
1039: LD_INT 0
1041: ST_TO_ADDR
// uc_nation = 0 ;
1042: LD_ADDR_OWVAR 21
1046: PUSH
1047: LD_INT 0
1049: ST_TO_ADDR
// InitHc ;
1050: CALL_OW 19
// InitVc ;
1054: CALL_OW 20
// hc_importance := 0 ;
1058: LD_ADDR_OWVAR 32
1062: PUSH
1063: LD_INT 0
1065: ST_TO_ADDR
// hc_name :=  ;
1066: LD_ADDR_OWVAR 26
1070: PUSH
1071: LD_STRING 
1073: ST_TO_ADDR
// if mastodonts then
1074: LD_VAR 0 6
1078: IFFALSE 1145
// for i = 1 to mastodonts do
1080: LD_ADDR_VAR 0 11
1084: PUSH
1085: DOUBLE
1086: LD_INT 1
1088: DEC
1089: ST_TO_ADDR
1090: LD_VAR 0 6
1094: PUSH
1095: FOR_TO
1096: IFFALSE 1143
// begin vc_chassis := 31 ;
1098: LD_ADDR_OWVAR 37
1102: PUSH
1103: LD_INT 31
1105: ST_TO_ADDR
// vc_control := control_rider ;
1106: LD_ADDR_OWVAR 38
1110: PUSH
1111: LD_INT 4
1113: ST_TO_ADDR
// animal := CreateVehicle ;
1114: LD_ADDR_VAR 0 12
1118: PUSH
1119: CALL_OW 45
1123: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1124: LD_VAR 0 12
1128: PPUSH
1129: LD_VAR 0 8
1133: PPUSH
1134: LD_INT 0
1136: PPUSH
1137: CALL 1649 0 3
// end ;
1141: GO 1095
1143: POP
1144: POP
// if horses then
1145: LD_VAR 0 5
1149: IFFALSE 1216
// for i = 1 to horses do
1151: LD_ADDR_VAR 0 11
1155: PUSH
1156: DOUBLE
1157: LD_INT 1
1159: DEC
1160: ST_TO_ADDR
1161: LD_VAR 0 5
1165: PUSH
1166: FOR_TO
1167: IFFALSE 1214
// begin hc_class := 21 ;
1169: LD_ADDR_OWVAR 28
1173: PUSH
1174: LD_INT 21
1176: ST_TO_ADDR
// hc_gallery :=  ;
1177: LD_ADDR_OWVAR 33
1181: PUSH
1182: LD_STRING 
1184: ST_TO_ADDR
// animal := CreateHuman ;
1185: LD_ADDR_VAR 0 12
1189: PUSH
1190: CALL_OW 44
1194: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1195: LD_VAR 0 12
1199: PPUSH
1200: LD_VAR 0 8
1204: PPUSH
1205: LD_INT 0
1207: PPUSH
1208: CALL 1649 0 3
// end ;
1212: GO 1166
1214: POP
1215: POP
// if birds then
1216: LD_VAR 0 1
1220: IFFALSE 1287
// for i = 1 to birds do
1222: LD_ADDR_VAR 0 11
1226: PUSH
1227: DOUBLE
1228: LD_INT 1
1230: DEC
1231: ST_TO_ADDR
1232: LD_VAR 0 1
1236: PUSH
1237: FOR_TO
1238: IFFALSE 1285
// begin hc_class = 18 ;
1240: LD_ADDR_OWVAR 28
1244: PUSH
1245: LD_INT 18
1247: ST_TO_ADDR
// hc_gallery =  ;
1248: LD_ADDR_OWVAR 33
1252: PUSH
1253: LD_STRING 
1255: ST_TO_ADDR
// animal := CreateHuman ;
1256: LD_ADDR_VAR 0 12
1260: PUSH
1261: CALL_OW 44
1265: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1266: LD_VAR 0 12
1270: PPUSH
1271: LD_VAR 0 8
1275: PPUSH
1276: LD_INT 0
1278: PPUSH
1279: CALL 1649 0 3
// end ;
1283: GO 1237
1285: POP
1286: POP
// if tigers then
1287: LD_VAR 0 2
1291: IFFALSE 1375
// for i = 1 to tigers do
1293: LD_ADDR_VAR 0 11
1297: PUSH
1298: DOUBLE
1299: LD_INT 1
1301: DEC
1302: ST_TO_ADDR
1303: LD_VAR 0 2
1307: PUSH
1308: FOR_TO
1309: IFFALSE 1373
// begin hc_class = class_tiger ;
1311: LD_ADDR_OWVAR 28
1315: PUSH
1316: LD_INT 14
1318: ST_TO_ADDR
// hc_gallery =  ;
1319: LD_ADDR_OWVAR 33
1323: PUSH
1324: LD_STRING 
1326: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
1327: LD_ADDR_OWVAR 35
1331: PUSH
1332: LD_INT 7
1334: NEG
1335: PPUSH
1336: LD_INT 7
1338: PPUSH
1339: CALL_OW 12
1343: ST_TO_ADDR
// animal := CreateHuman ;
1344: LD_ADDR_VAR 0 12
1348: PUSH
1349: CALL_OW 44
1353: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1354: LD_VAR 0 12
1358: PPUSH
1359: LD_VAR 0 8
1363: PPUSH
1364: LD_INT 0
1366: PPUSH
1367: CALL 1649 0 3
// end ;
1371: GO 1308
1373: POP
1374: POP
// if apemans then
1375: LD_VAR 0 3
1379: IFFALSE 1502
// for i = 1 to apemans do
1381: LD_ADDR_VAR 0 11
1385: PUSH
1386: DOUBLE
1387: LD_INT 1
1389: DEC
1390: ST_TO_ADDR
1391: LD_VAR 0 3
1395: PUSH
1396: FOR_TO
1397: IFFALSE 1500
// begin hc_class = class_apeman ;
1399: LD_ADDR_OWVAR 28
1403: PUSH
1404: LD_INT 12
1406: ST_TO_ADDR
// hc_gallery =  ;
1407: LD_ADDR_OWVAR 33
1411: PUSH
1412: LD_STRING 
1414: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
1415: LD_ADDR_OWVAR 35
1419: PUSH
1420: LD_INT 5
1422: NEG
1423: PPUSH
1424: LD_INT 5
1426: PPUSH
1427: CALL_OW 12
1431: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
1432: LD_ADDR_OWVAR 31
1436: PUSH
1437: LD_INT 1
1439: PPUSH
1440: LD_INT 3
1442: PPUSH
1443: CALL_OW 12
1447: PUSH
1448: LD_INT 1
1450: PPUSH
1451: LD_INT 3
1453: PPUSH
1454: CALL_OW 12
1458: PUSH
1459: LD_INT 0
1461: PUSH
1462: LD_INT 0
1464: PUSH
1465: EMPTY
1466: LIST
1467: LIST
1468: LIST
1469: LIST
1470: ST_TO_ADDR
// animal := CreateHuman ;
1471: LD_ADDR_VAR 0 12
1475: PUSH
1476: CALL_OW 44
1480: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1481: LD_VAR 0 12
1485: PPUSH
1486: LD_VAR 0 8
1490: PPUSH
1491: LD_INT 0
1493: PPUSH
1494: CALL 1649 0 3
// end ;
1498: GO 1396
1500: POP
1501: POP
// if enchidnas then
1502: LD_VAR 0 4
1506: IFFALSE 1573
// for i = 1 to enchidnas do
1508: LD_ADDR_VAR 0 11
1512: PUSH
1513: DOUBLE
1514: LD_INT 1
1516: DEC
1517: ST_TO_ADDR
1518: LD_VAR 0 4
1522: PUSH
1523: FOR_TO
1524: IFFALSE 1571
// begin hc_class = 13 ;
1526: LD_ADDR_OWVAR 28
1530: PUSH
1531: LD_INT 13
1533: ST_TO_ADDR
// hc_gallery =  ;
1534: LD_ADDR_OWVAR 33
1538: PUSH
1539: LD_STRING 
1541: ST_TO_ADDR
// animal := CreateHuman ;
1542: LD_ADDR_VAR 0 12
1546: PUSH
1547: CALL_OW 44
1551: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1552: LD_VAR 0 12
1556: PPUSH
1557: LD_VAR 0 8
1561: PPUSH
1562: LD_INT 0
1564: PPUSH
1565: CALL 1649 0 3
// end ;
1569: GO 1523
1571: POP
1572: POP
// if fishes then
1573: LD_VAR 0 7
1577: IFFALSE 1644
// for i = 1 to fishes do
1579: LD_ADDR_VAR 0 11
1583: PUSH
1584: DOUBLE
1585: LD_INT 1
1587: DEC
1588: ST_TO_ADDR
1589: LD_VAR 0 7
1593: PUSH
1594: FOR_TO
1595: IFFALSE 1642
// begin hc_class = 20 ;
1597: LD_ADDR_OWVAR 28
1601: PUSH
1602: LD_INT 20
1604: ST_TO_ADDR
// hc_gallery =  ;
1605: LD_ADDR_OWVAR 33
1609: PUSH
1610: LD_STRING 
1612: ST_TO_ADDR
// animal := CreateHuman ;
1613: LD_ADDR_VAR 0 12
1617: PUSH
1618: CALL_OW 44
1622: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
1623: LD_VAR 0 12
1627: PPUSH
1628: LD_VAR 0 9
1632: PPUSH
1633: LD_INT 0
1635: PPUSH
1636: CALL 1649 0 3
// end ;
1640: GO 1594
1642: POP
1643: POP
// end ;
1644: LD_VAR 0 10
1648: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
1649: LD_INT 0
1651: PPUSH
1652: PPUSH
1653: PPUSH
1654: PPUSH
// if not unit or not area then
1655: LD_VAR 0 1
1659: NOT
1660: PUSH
1661: LD_VAR 0 2
1665: NOT
1666: OR
1667: IFFALSE 1671
// exit ;
1669: GO 1835
// tmp := AreaToList ( area , i ) ;
1671: LD_ADDR_VAR 0 6
1675: PUSH
1676: LD_VAR 0 2
1680: PPUSH
1681: LD_VAR 0 5
1685: PPUSH
1686: CALL_OW 517
1690: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
1691: LD_ADDR_VAR 0 5
1695: PUSH
1696: DOUBLE
1697: LD_INT 1
1699: DEC
1700: ST_TO_ADDR
1701: LD_VAR 0 6
1705: PUSH
1706: LD_INT 1
1708: ARRAY
1709: PUSH
1710: FOR_TO
1711: IFFALSE 1833
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
1713: LD_ADDR_VAR 0 7
1717: PUSH
1718: LD_VAR 0 6
1722: PUSH
1723: LD_INT 1
1725: ARRAY
1726: PUSH
1727: LD_VAR 0 5
1731: ARRAY
1732: PUSH
1733: LD_VAR 0 6
1737: PUSH
1738: LD_INT 2
1740: ARRAY
1741: PUSH
1742: LD_VAR 0 5
1746: ARRAY
1747: PUSH
1748: EMPTY
1749: LIST
1750: LIST
1751: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
1752: LD_VAR 0 7
1756: PUSH
1757: LD_INT 1
1759: ARRAY
1760: PPUSH
1761: LD_VAR 0 7
1765: PUSH
1766: LD_INT 2
1768: ARRAY
1769: PPUSH
1770: CALL_OW 428
1774: PUSH
1775: LD_INT 0
1777: EQUAL
1778: IFFALSE 1831
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
1780: LD_VAR 0 1
1784: PPUSH
1785: LD_VAR 0 7
1789: PUSH
1790: LD_INT 1
1792: ARRAY
1793: PPUSH
1794: LD_VAR 0 7
1798: PUSH
1799: LD_INT 2
1801: ARRAY
1802: PPUSH
1803: LD_VAR 0 3
1807: PPUSH
1808: CALL_OW 48
// result := IsPlaced ( unit ) ;
1812: LD_ADDR_VAR 0 4
1816: PUSH
1817: LD_VAR 0 1
1821: PPUSH
1822: CALL_OW 305
1826: ST_TO_ADDR
// exit ;
1827: POP
1828: POP
1829: GO 1835
// end ; end ;
1831: GO 1710
1833: POP
1834: POP
// end ;
1835: LD_VAR 0 4
1839: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
1840: LD_INT 0
1842: PPUSH
1843: PPUSH
1844: PPUSH
1845: PPUSH
1846: PPUSH
1847: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
1848: LD_VAR 0 1
1852: NOT
1853: PUSH
1854: LD_VAR 0 1
1858: PPUSH
1859: CALL_OW 263
1863: PUSH
1864: LD_INT 2
1866: EQUAL
1867: NOT
1868: OR
1869: IFFALSE 1873
// exit ;
1871: GO 2189
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
1873: LD_ADDR_VAR 0 6
1877: PUSH
1878: LD_INT 22
1880: PUSH
1881: LD_VAR 0 1
1885: PPUSH
1886: CALL_OW 255
1890: PUSH
1891: EMPTY
1892: LIST
1893: LIST
1894: PUSH
1895: LD_INT 2
1897: PUSH
1898: LD_INT 30
1900: PUSH
1901: LD_INT 36
1903: PUSH
1904: EMPTY
1905: LIST
1906: LIST
1907: PUSH
1908: LD_INT 34
1910: PUSH
1911: LD_INT 31
1913: PUSH
1914: EMPTY
1915: LIST
1916: LIST
1917: PUSH
1918: EMPTY
1919: LIST
1920: LIST
1921: LIST
1922: PUSH
1923: EMPTY
1924: LIST
1925: LIST
1926: PPUSH
1927: CALL_OW 69
1931: ST_TO_ADDR
// if not tmp then
1932: LD_VAR 0 6
1936: NOT
1937: IFFALSE 1941
// exit ;
1939: GO 2189
// result := [ ] ;
1941: LD_ADDR_VAR 0 2
1945: PUSH
1946: EMPTY
1947: ST_TO_ADDR
// for i in tmp do
1948: LD_ADDR_VAR 0 3
1952: PUSH
1953: LD_VAR 0 6
1957: PUSH
1958: FOR_IN
1959: IFFALSE 2030
// begin t := UnitsInside ( i ) ;
1961: LD_ADDR_VAR 0 4
1965: PUSH
1966: LD_VAR 0 3
1970: PPUSH
1971: CALL_OW 313
1975: ST_TO_ADDR
// if t then
1976: LD_VAR 0 4
1980: IFFALSE 2028
// for j in t do
1982: LD_ADDR_VAR 0 7
1986: PUSH
1987: LD_VAR 0 4
1991: PUSH
1992: FOR_IN
1993: IFFALSE 2026
// result := Insert ( result , result + 1 , j ) ;
1995: LD_ADDR_VAR 0 2
1999: PUSH
2000: LD_VAR 0 2
2004: PPUSH
2005: LD_VAR 0 2
2009: PUSH
2010: LD_INT 1
2012: PLUS
2013: PPUSH
2014: LD_VAR 0 7
2018: PPUSH
2019: CALL_OW 2
2023: ST_TO_ADDR
2024: GO 1992
2026: POP
2027: POP
// end ;
2028: GO 1958
2030: POP
2031: POP
// if not result then
2032: LD_VAR 0 2
2036: NOT
2037: IFFALSE 2041
// exit ;
2039: GO 2189
// mech := result [ 1 ] ;
2041: LD_ADDR_VAR 0 5
2045: PUSH
2046: LD_VAR 0 2
2050: PUSH
2051: LD_INT 1
2053: ARRAY
2054: ST_TO_ADDR
// if result > 1 then
2055: LD_VAR 0 2
2059: PUSH
2060: LD_INT 1
2062: GREATER
2063: IFFALSE 2175
// for i = 2 to result do
2065: LD_ADDR_VAR 0 3
2069: PUSH
2070: DOUBLE
2071: LD_INT 2
2073: DEC
2074: ST_TO_ADDR
2075: LD_VAR 0 2
2079: PUSH
2080: FOR_TO
2081: IFFALSE 2173
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
2083: LD_ADDR_VAR 0 4
2087: PUSH
2088: LD_VAR 0 2
2092: PUSH
2093: LD_VAR 0 3
2097: ARRAY
2098: PPUSH
2099: LD_INT 3
2101: PPUSH
2102: CALL_OW 259
2106: PUSH
2107: LD_VAR 0 2
2111: PUSH
2112: LD_VAR 0 3
2116: ARRAY
2117: PPUSH
2118: CALL_OW 432
2122: MINUS
2123: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
2124: LD_VAR 0 4
2128: PUSH
2129: LD_VAR 0 5
2133: PPUSH
2134: LD_INT 3
2136: PPUSH
2137: CALL_OW 259
2141: PUSH
2142: LD_VAR 0 5
2146: PPUSH
2147: CALL_OW 432
2151: MINUS
2152: GREATEREQUAL
2153: IFFALSE 2171
// mech := result [ i ] ;
2155: LD_ADDR_VAR 0 5
2159: PUSH
2160: LD_VAR 0 2
2164: PUSH
2165: LD_VAR 0 3
2169: ARRAY
2170: ST_TO_ADDR
// end ;
2171: GO 2080
2173: POP
2174: POP
// ComLinkTo ( vehicle , mech ) ;
2175: LD_VAR 0 1
2179: PPUSH
2180: LD_VAR 0 5
2184: PPUSH
2185: CALL_OW 135
// end ; end_of_file
2189: LD_VAR 0 2
2193: RET
// export function Action ; begin
2194: LD_INT 0
2196: PPUSH
// InGameOn ;
2197: CALL_OW 8
// CenterNowOnXY ( 221 , 80 ) ;
2201: LD_INT 221
2203: PPUSH
2204: LD_INT 80
2206: PPUSH
2207: CALL_OW 86
// ComMoveXY ( [ JMM , Burlak ] , 217 , 79 ) ;
2211: LD_EXP 14
2215: PUSH
2216: LD_EXP 15
2220: PUSH
2221: EMPTY
2222: LIST
2223: LIST
2224: PPUSH
2225: LD_INT 217
2227: PPUSH
2228: LD_INT 79
2230: PPUSH
2231: CALL_OW 111
// wait ( 0 0$7 ) ;
2235: LD_INT 245
2237: PPUSH
2238: CALL_OW 67
// ComExitVehicle ( [ JMM , Burlak ] ) ;
2242: LD_EXP 14
2246: PUSH
2247: LD_EXP 15
2251: PUSH
2252: EMPTY
2253: LIST
2254: LIST
2255: PPUSH
2256: CALL_OW 121
// Say ( Burlak , D2-Bur-1 ) ;
2260: LD_EXP 15
2264: PPUSH
2265: LD_STRING D2-Bur-1
2267: PPUSH
2268: CALL_OW 88
// Say ( JMM , D2-JMM-1 ) ;
2272: LD_EXP 14
2276: PPUSH
2277: LD_STRING D2-JMM-1
2279: PPUSH
2280: CALL_OW 88
// wait ( 0 0$0.5 ) ;
2284: LD_INT 18
2286: PPUSH
2287: CALL_OW 67
// ComTurnUnit ( Burlak , JMM ) ;
2291: LD_EXP 15
2295: PPUSH
2296: LD_EXP 14
2300: PPUSH
2301: CALL_OW 119
// Say ( Burlak , D2-Bur-2 ) ;
2305: LD_EXP 15
2309: PPUSH
2310: LD_STRING D2-Bur-2
2312: PPUSH
2313: CALL_OW 88
// ComEnterUnit ( Burlak , NearestUnitToUnit ( FilterAllUnits ( [ f_type , unit_vehicle ] ) , Burlak ) ) ;
2317: LD_EXP 15
2321: PPUSH
2322: LD_INT 21
2324: PUSH
2325: LD_INT 2
2327: PUSH
2328: EMPTY
2329: LIST
2330: LIST
2331: PPUSH
2332: CALL_OW 69
2336: PPUSH
2337: LD_EXP 15
2341: PPUSH
2342: CALL_OW 74
2346: PPUSH
2347: CALL_OW 120
// ComEnterUnit ( JMM , NearestUnitToUnit ( FilterAllUnits ( [ f_type , unit_vehicle ] ) , JMM ) ) ;
2351: LD_EXP 14
2355: PPUSH
2356: LD_INT 21
2358: PUSH
2359: LD_INT 2
2361: PUSH
2362: EMPTY
2363: LIST
2364: LIST
2365: PPUSH
2366: CALL_OW 69
2370: PPUSH
2371: LD_EXP 14
2375: PPUSH
2376: CALL_OW 74
2380: PPUSH
2381: CALL_OW 120
// wait ( 0 0$1 ) ;
2385: LD_INT 35
2387: PPUSH
2388: CALL_OW 67
// InGameOff ;
2392: CALL_OW 9
// ChangeMissionObjectives ( MArtPickup ) ;
2396: LD_STRING MArtPickup
2398: PPUSH
2399: CALL_OW 337
// end ;
2403: LD_VAR 0 1
2407: RET
// every 0 0$1 trigger UnitFilter ( guards , [ f_see , 7 ] ) do
2408: LD_EXP 22
2412: PPUSH
2413: LD_INT 101
2415: PUSH
2416: LD_INT 7
2418: PUSH
2419: EMPTY
2420: LIST
2421: LIST
2422: PPUSH
2423: CALL_OW 72
2427: IFFALSE 2456
2429: GO 2431
2431: DISABLE
// begin Say ( Burlak , D3-Bur-1 ) ;
2432: LD_EXP 15
2436: PPUSH
2437: LD_STRING D3-Bur-1
2439: PPUSH
2440: CALL_OW 88
// Say ( JMM , D3-JMM-1 ) ;
2444: LD_EXP 14
2448: PPUSH
2449: LD_STRING D3-JMM-1
2451: PPUSH
2452: CALL_OW 88
// end ;
2456: END
// every 0 0$2 trigger FilterUnitsInArea ( usTestBase , [ f_side , 7 ] ) do
2457: LD_INT 5
2459: PPUSH
2460: LD_INT 22
2462: PUSH
2463: LD_INT 7
2465: PUSH
2466: EMPTY
2467: LIST
2468: LIST
2469: PPUSH
2470: CALL_OW 70
2474: IFFALSE 2805
2476: GO 2478
2478: DISABLE
// begin wait ( 0 0$3 ) ;
2479: LD_INT 105
2481: PPUSH
2482: CALL_OW 67
// DialogueOn ;
2486: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
2490: LD_EXP 14
2494: PPUSH
2495: CALL_OW 87
// Say ( JMM , D3a-JMM-1 ) ;
2499: LD_EXP 14
2503: PPUSH
2504: LD_STRING D3a-JMM-1
2506: PPUSH
2507: CALL_OW 88
// Say ( Burlak , D3a-Bur-1 ) ;
2511: LD_EXP 15
2515: PPUSH
2516: LD_STRING D3a-Bur-1
2518: PPUSH
2519: CALL_OW 88
// Say ( JMM , D3a-JMM-2 ) ;
2523: LD_EXP 14
2527: PPUSH
2528: LD_STRING D3a-JMM-2
2530: PPUSH
2531: CALL_OW 88
// if Joan then
2535: LD_EXP 16
2539: IFFALSE 2555
// SayRadio ( Joan , D3a-Joan-2 ) else
2541: LD_EXP 16
2545: PPUSH
2546: LD_STRING D3a-Joan-2
2548: PPUSH
2549: CALL_OW 94
2553: GO 2567
// SayRadio ( RuSci , D3a-RSci1-2 ) ;
2555: LD_EXP 17
2559: PPUSH
2560: LD_STRING D3a-RSci1-2
2562: PPUSH
2563: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-2 ) ;
2567: LD_EXP 18
2571: PPUSH
2572: LD_STRING D3a-Huck-2
2574: PPUSH
2575: CALL_OW 94
// SayRadio ( Powell , D3a-Pow-2 ) ;
2579: LD_EXP 19
2583: PPUSH
2584: LD_STRING D3a-Pow-2
2586: PPUSH
2587: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-3 ) ;
2591: LD_EXP 18
2595: PPUSH
2596: LD_STRING D3a-Huck-3
2598: PPUSH
2599: CALL_OW 94
// SayRadio ( Powell , D3a-Pow-3 ) ;
2603: LD_EXP 19
2607: PPUSH
2608: LD_STRING D3a-Pow-3
2610: PPUSH
2611: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-4 ) ;
2615: LD_EXP 18
2619: PPUSH
2620: LD_STRING D3a-Huck-4
2622: PPUSH
2623: CALL_OW 94
// Say ( JMM , D3a-JMM-4 ) ;
2627: LD_EXP 14
2631: PPUSH
2632: LD_STRING D3a-JMM-4
2634: PPUSH
2635: CALL_OW 88
// Say ( Burlak , D3a-Bur-4 ) ;
2639: LD_EXP 15
2643: PPUSH
2644: LD_STRING D3a-Bur-4
2646: PPUSH
2647: CALL_OW 88
// if Joan then
2651: LD_EXP 16
2655: IFFALSE 2671
// SayRadio ( Joan , D3a-Joan-4 ) else
2657: LD_EXP 16
2661: PPUSH
2662: LD_STRING D3a-Joan-4
2664: PPUSH
2665: CALL_OW 94
2669: GO 2683
// SayRadio ( RuSci , D3a-RSci1-4 ) ;
2671: LD_EXP 17
2675: PPUSH
2676: LD_STRING D3a-RSci1-4
2678: PPUSH
2679: CALL_OW 94
// PlaceSeeing ( 133 , 43 , 7 , - 10 ) ;
2683: LD_INT 133
2685: PPUSH
2686: LD_INT 43
2688: PPUSH
2689: LD_INT 7
2691: PPUSH
2692: LD_INT 10
2694: NEG
2695: PPUSH
2696: CALL_OW 330
// RemoveSeeing ( 133 , 43 , 7 ) ;
2700: LD_INT 133
2702: PPUSH
2703: LD_INT 43
2705: PPUSH
2706: LD_INT 7
2708: PPUSH
2709: CALL_OW 331
// CenterNowOnXY ( 133 , 43 ) ;
2713: LD_INT 133
2715: PPUSH
2716: LD_INT 43
2718: PPUSH
2719: CALL_OW 86
// dwait ( 0 0$0.3 ) ;
2723: LD_INT 10
2725: PPUSH
2726: CALL_OW 68
// Say ( JMM , D3a-JMM-5 ) ;
2730: LD_EXP 14
2734: PPUSH
2735: LD_STRING D3a-JMM-5
2737: PPUSH
2738: CALL_OW 88
// Say ( Burlak , D3a-Bur-5 ) ;
2742: LD_EXP 15
2746: PPUSH
2747: LD_STRING D3a-Bur-5
2749: PPUSH
2750: CALL_OW 88
// DialogueOff ;
2754: CALL_OW 7
// seenBase := true ;
2758: LD_ADDR_EXP 8
2762: PUSH
2763: LD_INT 1
2765: ST_TO_ADDR
// wait ( [ 0 0$15 , 0 0$12 , 0 0$9 ] [ Difficulty ] ) ;
2766: LD_INT 525
2768: PUSH
2769: LD_INT 420
2771: PUSH
2772: LD_INT 315
2774: PUSH
2775: EMPTY
2776: LIST
2777: LIST
2778: LIST
2779: PUSH
2780: LD_OWVAR 67
2784: ARRAY
2785: PPUSH
2786: CALL_OW 67
// ComAttackPlace ( sibBomb , 142 , 52 ) ;
2790: LD_EXP 21
2794: PPUSH
2795: LD_INT 142
2797: PPUSH
2798: LD_INT 52
2800: PPUSH
2801: CALL_OW 116
// end ;
2805: END
// every 5 5$00 trigger not seenBase and not bombExploded do
2806: LD_EXP 8
2810: NOT
2811: PUSH
2812: LD_EXP 4
2816: NOT
2817: AND
2818: IFFALSE 2838
2820: GO 2822
2822: DISABLE
// ComAttackPlace ( sibBomb , 142 , 52 ) ;
2823: LD_EXP 21
2827: PPUSH
2828: LD_INT 142
2830: PPUSH
2831: LD_INT 52
2833: PPUSH
2834: CALL_OW 116
2838: END
// export function OnBombExploded ( bomb , x , y ) ; var art ; begin
2839: LD_INT 0
2841: PPUSH
2842: PPUSH
// contaminateTime := tick ;
2843: LD_ADDR_EXP 3
2847: PUSH
2848: LD_OWVAR 1
2852: ST_TO_ADDR
// wait ( 0 0$5 ) ;
2853: LD_INT 175
2855: PPUSH
2856: CALL_OW 67
// art := FindArtifact ( 4 ) ;
2860: LD_ADDR_VAR 0 5
2864: PUSH
2865: LD_INT 4
2867: PPUSH
2868: CALL_OW 469
2872: ST_TO_ADDR
// if art then
2873: LD_VAR 0 5
2877: IFFALSE 2916
// if art [ 1 ] = 157 and art [ 2 ] = 75 then
2879: LD_VAR 0 5
2883: PUSH
2884: LD_INT 1
2886: ARRAY
2887: PUSH
2888: LD_INT 157
2890: EQUAL
2891: PUSH
2892: LD_VAR 0 5
2896: PUSH
2897: LD_INT 2
2899: ARRAY
2900: PUSH
2901: LD_INT 75
2903: EQUAL
2904: AND
2905: IFFALSE 2916
// begin YouLost ( Artefact ) ;
2907: LD_STRING Artefact
2909: PPUSH
2910: CALL_OW 104
// exit ;
2914: GO 3068
// end ; if IsOK ( JMM ) and IsOk ( Burlak ) then
2916: LD_EXP 14
2920: PPUSH
2921: CALL_OW 302
2925: PUSH
2926: LD_EXP 15
2930: PPUSH
2931: CALL_OW 302
2935: AND
2936: IFFALSE 3013
// begin DialogueOn ;
2938: CALL_OW 6
// Say ( JMM , D6a-JMM-1 ) ;
2942: LD_EXP 14
2946: PPUSH
2947: LD_STRING D6a-JMM-1
2949: PPUSH
2950: CALL_OW 88
// Say ( Burlak , D6a-Bur-1 ) ;
2954: LD_EXP 15
2958: PPUSH
2959: LD_STRING D6a-Bur-1
2961: PPUSH
2962: CALL_OW 88
// Say ( JMM , D6c-JMM-1 ) ;
2966: LD_EXP 14
2970: PPUSH
2971: LD_STRING D6c-JMM-1
2973: PPUSH
2974: CALL_OW 88
// Say ( Burlak , D6c-Bur-1 ) ;
2978: LD_EXP 15
2982: PPUSH
2983: LD_STRING D6c-Bur-1
2985: PPUSH
2986: CALL_OW 88
// Say ( JMM , D6c-JMM-2 ) ;
2990: LD_EXP 14
2994: PPUSH
2995: LD_STRING D6c-JMM-2
2997: PPUSH
2998: CALL_OW 88
// ChangeMissionObjectives ( MBase ) ;
3002: LD_STRING MBase
3004: PPUSH
3005: CALL_OW 337
// DialogueOff ;
3009: CALL_OW 7
// end ; bombExploded := true ;
3013: LD_ADDR_EXP 4
3017: PUSH
3018: LD_INT 1
3020: ST_TO_ADDR
// wait ( [ 3 3$00 , 2 2$30 , 2 2$00 ] [ Difficulty ] ) ;
3021: LD_INT 6300
3023: PUSH
3024: LD_INT 5250
3026: PUSH
3027: LD_INT 4200
3029: PUSH
3030: EMPTY
3031: LIST
3032: LIST
3033: LIST
3034: PUSH
3035: LD_OWVAR 67
3039: ARRAY
3040: PPUSH
3041: CALL_OW 67
// if IsOk ( JMM ) then
3045: LD_EXP 14
3049: PPUSH
3050: CALL_OW 302
3054: IFFALSE 3068
// Say ( JMM , D8-JMM-1 ) ;
3056: LD_EXP 14
3060: PPUSH
3061: LD_STRING D8-JMM-1
3063: PPUSH
3064: CALL_OW 88
// end ;
3068: LD_VAR 0 4
3072: RET
// every 0 0$1 trigger stevensTimer and not planCaptured and bombExploded do
3073: LD_EXP 9
3077: PUSH
3078: LD_EXP 7
3082: NOT
3083: AND
3084: PUSH
3085: LD_EXP 4
3089: AND
3090: IFFALSE 3145
3092: GO 3094
3094: DISABLE
// begin enable ;
3095: ENABLE
// if FilterUnitsInArea ( usBase , [ f_side , 7 ] ) then
3096: LD_INT 9
3098: PPUSH
3099: LD_INT 22
3101: PUSH
3102: LD_INT 7
3104: PUSH
3105: EMPTY
3106: LIST
3107: LIST
3108: PPUSH
3109: CALL_OW 70
3113: IFFALSE 3131
// stevensTimer := stevensTimer - 0 0$30 else
3115: LD_ADDR_EXP 9
3119: PUSH
3120: LD_EXP 9
3124: PUSH
3125: LD_INT 1050
3127: MINUS
3128: ST_TO_ADDR
3129: GO 3145
// stevensTimer := stevensTimer - 0 0$1 ;
3131: LD_ADDR_EXP 9
3135: PUSH
3136: LD_EXP 9
3140: PUSH
3141: LD_INT 35
3143: MINUS
3144: ST_TO_ADDR
// end ;
3145: END
// every 0 0$1 trigger stevensTimer <= 0 0$00 and not planCaptured do var i , tmp ;
3146: LD_EXP 9
3150: PUSH
3151: LD_INT 0
3153: LESSEQUAL
3154: PUSH
3155: LD_EXP 7
3159: NOT
3160: AND
3161: IFFALSE 3325
3163: GO 3165
3165: DISABLE
3166: LD_INT 0
3168: PPUSH
3169: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
3170: LD_ADDR_VAR 0 2
3174: PUSH
3175: LD_INT 22
3177: PUSH
3178: LD_INT 1
3180: PUSH
3181: EMPTY
3182: LIST
3183: LIST
3184: PUSH
3185: LD_INT 25
3187: PUSH
3188: LD_INT 4
3190: PUSH
3191: EMPTY
3192: LIST
3193: LIST
3194: PUSH
3195: EMPTY
3196: LIST
3197: LIST
3198: PPUSH
3199: CALL_OW 69
3203: ST_TO_ADDR
// for i in tmp do
3204: LD_ADDR_VAR 0 1
3208: PUSH
3209: LD_VAR 0 2
3213: PUSH
3214: FOR_IN
3215: IFFALSE 3268
// begin if IsInUnit ( i ) then
3217: LD_VAR 0 1
3221: PPUSH
3222: CALL_OW 310
3226: IFFALSE 3239
// ComExitBuilding ( i ) else
3228: LD_VAR 0 1
3232: PPUSH
3233: CALL_OW 122
3237: GO 3266
// if not HasTask ( i ) then
3239: LD_VAR 0 1
3243: PPUSH
3244: CALL_OW 314
3248: NOT
3249: IFFALSE 3266
// ComMoveXY ( i , 29 , 56 ) ;
3251: LD_VAR 0 1
3255: PPUSH
3256: LD_INT 29
3258: PPUSH
3259: LD_INT 56
3261: PPUSH
3262: CALL_OW 111
// end ;
3266: GO 3214
3268: POP
3269: POP
// repeat wait ( 0 0$1 ) ;
3270: LD_INT 35
3272: PPUSH
3273: CALL_OW 67
// until FilterUnitsInArea ( stevensEscapeArea , [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
3277: LD_INT 8
3279: PPUSH
3280: LD_INT 22
3282: PUSH
3283: LD_INT 1
3285: PUSH
3286: EMPTY
3287: LIST
3288: LIST
3289: PUSH
3290: LD_INT 25
3292: PUSH
3293: LD_INT 4
3295: PUSH
3296: EMPTY
3297: LIST
3298: LIST
3299: PUSH
3300: EMPTY
3301: LIST
3302: LIST
3303: PPUSH
3304: CALL_OW 70
3308: IFFALSE 3270
// if planCaptured then
3310: LD_EXP 7
3314: IFFALSE 3318
// exit ;
3316: GO 3325
// YouLost ( Time ) ;
3318: LD_STRING Time
3320: PPUSH
3321: CALL_OW 104
// end ;
3325: PPOPN 2
3327: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_distxy , 142 , 52 , 27 ] ] ) and contaminateTime + 6000 > tick and bombExploded do
3328: LD_INT 22
3330: PUSH
3331: LD_INT 7
3333: PUSH
3334: EMPTY
3335: LIST
3336: LIST
3337: PUSH
3338: LD_INT 92
3340: PUSH
3341: LD_INT 142
3343: PUSH
3344: LD_INT 52
3346: PUSH
3347: LD_INT 27
3349: PUSH
3350: EMPTY
3351: LIST
3352: LIST
3353: LIST
3354: LIST
3355: PUSH
3356: EMPTY
3357: LIST
3358: LIST
3359: PPUSH
3360: CALL_OW 69
3364: PUSH
3365: LD_EXP 3
3369: PUSH
3370: LD_INT 6000
3372: PLUS
3373: PUSH
3374: LD_OWVAR 1
3378: GREATER
3379: AND
3380: PUSH
3381: LD_EXP 4
3385: AND
3386: IFFALSE 3441
3388: GO 3390
3390: DISABLE
// begin CenterOnUnits ( [ JMM , Burlak ] ) ;
3391: LD_EXP 14
3395: PUSH
3396: LD_EXP 15
3400: PUSH
3401: EMPTY
3402: LIST
3403: LIST
3404: PPUSH
3405: CALL_OW 85
// DialogueOn ;
3409: CALL_OW 6
// Say ( JMM , D6b-JMM-1 ) ;
3413: LD_EXP 14
3417: PPUSH
3418: LD_STRING D6b-JMM-1
3420: PPUSH
3421: CALL_OW 88
// Say ( Burlak , D6b-Bur-1 ) ;
3425: LD_EXP 15
3429: PPUSH
3430: LD_STRING D6b-Bur-1
3432: PPUSH
3433: CALL_OW 88
// DialogueOff ;
3437: CALL_OW 7
// end ;
3441: END
// every 0 0$1 trigger ( GetDistUnitXY ( Burlak , 142 , 52 ) < 25 or GetDistUnitXY ( IsInUnit ( Burlak ) , 142 , 52 ) < 25 ) and GetLives ( Burlak ) < 1000 and contaminateTime + 6000 > tick and bombExploded do
3442: LD_EXP 15
3446: PPUSH
3447: LD_INT 142
3449: PPUSH
3450: LD_INT 52
3452: PPUSH
3453: CALL_OW 297
3457: PUSH
3458: LD_INT 25
3460: LESS
3461: PUSH
3462: LD_EXP 15
3466: PPUSH
3467: CALL_OW 310
3471: PPUSH
3472: LD_INT 142
3474: PPUSH
3475: LD_INT 52
3477: PPUSH
3478: CALL_OW 297
3482: PUSH
3483: LD_INT 25
3485: LESS
3486: OR
3487: PUSH
3488: LD_EXP 15
3492: PPUSH
3493: CALL_OW 256
3497: PUSH
3498: LD_INT 1000
3500: LESS
3501: AND
3502: PUSH
3503: LD_EXP 3
3507: PUSH
3508: LD_INT 6000
3510: PLUS
3511: PUSH
3512: LD_OWVAR 1
3516: GREATER
3517: AND
3518: PUSH
3519: LD_EXP 4
3523: AND
3524: IFFALSE 3557
3526: GO 3528
3528: DISABLE
// begin DialogueOn ;
3529: CALL_OW 6
// Say ( Burlak , D7-Bur-1 ) ;
3533: LD_EXP 15
3537: PPUSH
3538: LD_STRING D7-Bur-1
3540: PPUSH
3541: CALL_OW 88
// enteredContaminatedArea := true ;
3545: LD_ADDR_EXP 5
3549: PUSH
3550: LD_INT 1
3552: ST_TO_ADDR
// DialogueOff ;
3553: CALL_OW 7
// end ;
3557: END
// every 0 0$1 trigger ( GetDistUnitXY ( JMM , 142 , 52 ) < 25 or GetDistUnitXY ( IsInUnit ( JMM ) , 142 , 52 ) < 25 ) and GetLives ( JMM ) < 1000 and contaminateTime + 6000 > tick and bombExploded do
3558: LD_EXP 14
3562: PPUSH
3563: LD_INT 142
3565: PPUSH
3566: LD_INT 52
3568: PPUSH
3569: CALL_OW 297
3573: PUSH
3574: LD_INT 25
3576: LESS
3577: PUSH
3578: LD_EXP 14
3582: PPUSH
3583: CALL_OW 310
3587: PPUSH
3588: LD_INT 142
3590: PPUSH
3591: LD_INT 52
3593: PPUSH
3594: CALL_OW 297
3598: PUSH
3599: LD_INT 25
3601: LESS
3602: OR
3603: PUSH
3604: LD_EXP 14
3608: PPUSH
3609: CALL_OW 256
3613: PUSH
3614: LD_INT 1000
3616: LESS
3617: AND
3618: PUSH
3619: LD_EXP 3
3623: PUSH
3624: LD_INT 6000
3626: PLUS
3627: PUSH
3628: LD_OWVAR 1
3632: GREATER
3633: AND
3634: PUSH
3635: LD_EXP 4
3639: AND
3640: IFFALSE 3673
3642: GO 3644
3644: DISABLE
// begin DialogueOn ;
3645: CALL_OW 6
// Say ( JMM , D7-JMM-1 ) ;
3649: LD_EXP 14
3653: PPUSH
3654: LD_STRING D7-JMM-1
3656: PPUSH
3657: CALL_OW 88
// enteredContaminatedArea := true ;
3661: LD_ADDR_EXP 5
3665: PUSH
3666: LD_INT 1
3668: ST_TO_ADDR
// DialogueOff ;
3669: CALL_OW 7
// end ;
3673: END
// every 0 0$1 trigger artifactPickedUp and IsOk ( JMM ) and IsOk ( Burlak ) do
3674: LD_EXP 6
3678: PUSH
3679: LD_EXP 14
3683: PPUSH
3684: CALL_OW 302
3688: AND
3689: PUSH
3690: LD_EXP 15
3694: PPUSH
3695: CALL_OW 302
3699: AND
3700: IFFALSE 3769
3702: GO 3704
3704: DISABLE
// begin DialogueOn ;
3705: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Burlak ] ) ;
3709: LD_EXP 14
3713: PUSH
3714: LD_EXP 15
3718: PUSH
3719: EMPTY
3720: LIST
3721: LIST
3722: PPUSH
3723: CALL_OW 87
// Say ( JMM , D4-JMM-1 ) ;
3727: LD_EXP 14
3731: PPUSH
3732: LD_STRING D4-JMM-1
3734: PPUSH
3735: CALL_OW 88
// if not bombExploded then
3739: LD_EXP 4
3743: NOT
3744: IFFALSE 3758
// Say ( Burlak , D4-Bur-1 ) ;
3746: LD_EXP 15
3750: PPUSH
3751: LD_STRING D4-Bur-1
3753: PPUSH
3754: CALL_OW 88
// DialogueOff ;
3758: CALL_OW 7
// ChangeMissionObjectives ( MReturn ) ;
3762: LD_STRING MReturn
3764: PPUSH
3765: CALL_OW 337
// end ;
3769: END
// every 0 0$2 trigger not planCaptured and FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , us_dep_north , 6 ] ] ) do
3770: LD_EXP 7
3774: NOT
3775: PUSH
3776: LD_INT 22
3778: PUSH
3779: LD_INT 7
3781: PUSH
3782: EMPTY
3783: LIST
3784: LIST
3785: PUSH
3786: LD_INT 91
3788: PUSH
3789: LD_INT 9
3791: PUSH
3792: LD_INT 6
3794: PUSH
3795: EMPTY
3796: LIST
3797: LIST
3798: LIST
3799: PUSH
3800: EMPTY
3801: LIST
3802: LIST
3803: PPUSH
3804: CALL_OW 69
3808: AND
3809: IFFALSE 3886
3811: GO 3813
3813: DISABLE
// begin DialogueOn ;
3814: CALL_OW 6
// PlaceSeeing ( 55 , 11 , 7 , - 6 ) ;
3818: LD_INT 55
3820: PPUSH
3821: LD_INT 11
3823: PPUSH
3824: LD_INT 7
3826: PPUSH
3827: LD_INT 6
3829: NEG
3830: PPUSH
3831: CALL_OW 330
// RemoveSeeing ( 55 , 11 , 7 ) ;
3835: LD_INT 55
3837: PPUSH
3838: LD_INT 11
3840: PPUSH
3841: LD_INT 7
3843: PPUSH
3844: CALL_OW 331
// Say ( Burlak , D9-Bur-1 ) ;
3848: LD_EXP 15
3852: PPUSH
3853: LD_STRING D9-Bur-1
3855: PPUSH
3856: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
3860: LD_EXP 14
3864: PPUSH
3865: LD_STRING D9-JMM-1
3867: PPUSH
3868: CALL_OW 88
// DialogueOff ;
3872: CALL_OW 7
// SetSide ( us_dep_north , 7 ) ;
3876: LD_INT 9
3878: PPUSH
3879: LD_INT 7
3881: PPUSH
3882: CALL_OW 235
// end ;
3886: END
// every 0 0$1 trigger FilterUnitsInArea ( usBase , [ f_side , 7 ] ) do
3887: LD_INT 9
3889: PPUSH
3890: LD_INT 22
3892: PUSH
3893: LD_INT 7
3895: PUSH
3896: EMPTY
3897: LIST
3898: LIST
3899: PPUSH
3900: CALL_OW 70
3904: IFFALSE 3940
3906: GO 3908
3908: DISABLE
// begin wait ( 0 0$07 ) ;
3909: LD_INT 245
3911: PPUSH
3912: CALL_OW 67
// Say ( JMM , D10b-JMM-1 ) ;
3916: LD_EXP 14
3920: PPUSH
3921: LD_STRING D10b-JMM-1
3923: PPUSH
3924: CALL_OW 88
// Say ( Burlak , D10b-Bur-1 ) ;
3928: LD_EXP 15
3932: PPUSH
3933: LD_STRING D10b-Bur-1
3935: PPUSH
3936: CALL_OW 88
// end ;
3940: END
// every 0 0$1 trigger stevensTimer and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) and ( GetSide ( us_depot ) = 7 or FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) = 0 ) do var i ;
3941: LD_EXP 9
3945: PUSH
3946: LD_INT 22
3948: PUSH
3949: LD_INT 1
3951: PUSH
3952: EMPTY
3953: LIST
3954: LIST
3955: PUSH
3956: LD_INT 25
3958: PUSH
3959: LD_INT 4
3961: PUSH
3962: EMPTY
3963: LIST
3964: LIST
3965: PUSH
3966: LD_INT 26
3968: PUSH
3969: LD_INT 1
3971: PUSH
3972: EMPTY
3973: LIST
3974: LIST
3975: PUSH
3976: EMPTY
3977: LIST
3978: LIST
3979: LIST
3980: PPUSH
3981: CALL_OW 69
3985: AND
3986: PUSH
3987: LD_INT 5
3989: PPUSH
3990: CALL_OW 255
3994: PUSH
3995: LD_INT 7
3997: EQUAL
3998: PUSH
3999: LD_INT 22
4001: PUSH
4002: LD_INT 1
4004: PUSH
4005: EMPTY
4006: LIST
4007: LIST
4008: PUSH
4009: LD_INT 25
4011: PUSH
4012: LD_INT 1
4014: PUSH
4015: EMPTY
4016: LIST
4017: LIST
4018: PUSH
4019: EMPTY
4020: LIST
4021: LIST
4022: PPUSH
4023: CALL_OW 69
4027: PUSH
4028: LD_INT 0
4030: EQUAL
4031: OR
4032: AND
4033: IFFALSE 4622
4035: GO 4037
4037: DISABLE
4038: LD_INT 0
4040: PPUSH
// begin case Query ( QKill ) of 1 :
4041: LD_STRING QKill
4043: PPUSH
4044: CALL_OW 97
4048: PUSH
4049: LD_INT 1
4051: DOUBLE
4052: EQUAL
4053: IFTRUE 4057
4055: GO 4610
4057: POP
// begin DialogueOn ;
4058: CALL_OW 6
// Say ( JMM , D10a-JMM-1 ) ;
4062: LD_EXP 14
4066: PPUSH
4067: LD_STRING D10a-JMM-1
4069: PPUSH
4070: CALL_OW 88
// Say ( Burlak , D10a-Bur-1 ) ;
4074: LD_EXP 15
4078: PPUSH
4079: LD_STRING D10a-Bur-1
4081: PPUSH
4082: CALL_OW 88
// Say ( JMM , D10a-JMM-2 ) ;
4086: LD_EXP 14
4090: PPUSH
4091: LD_STRING D10a-JMM-2
4093: PPUSH
4094: CALL_OW 88
// if IsOk ( Stevens ) then
4098: LD_EXP 18
4102: PPUSH
4103: CALL_OW 302
4107: IFFALSE 4123
// Say ( Stevens , D10a-Huck-2 ) else
4109: LD_EXP 18
4113: PPUSH
4114: LD_STRING D10a-Huck-2
4116: PPUSH
4117: CALL_OW 88
4121: GO 4174
// Say ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) [ 1 ] , D10a-ASci1-3 ) ;
4123: LD_INT 22
4125: PUSH
4126: LD_INT 1
4128: PUSH
4129: EMPTY
4130: LIST
4131: LIST
4132: PUSH
4133: LD_INT 25
4135: PUSH
4136: LD_INT 4
4138: PUSH
4139: EMPTY
4140: LIST
4141: LIST
4142: PUSH
4143: LD_INT 26
4145: PUSH
4146: LD_INT 1
4148: PUSH
4149: EMPTY
4150: LIST
4151: LIST
4152: PUSH
4153: EMPTY
4154: LIST
4155: LIST
4156: LIST
4157: PPUSH
4158: CALL_OW 69
4162: PUSH
4163: LD_INT 1
4165: ARRAY
4166: PPUSH
4167: LD_STRING D10a-ASci1-3
4169: PPUSH
4170: CALL_OW 88
// Say ( JMM , D10a-JMM-4 ) ;
4174: LD_EXP 14
4178: PPUSH
4179: LD_STRING D10a-JMM-4
4181: PPUSH
4182: CALL_OW 88
// if IsOk ( Stevens ) then
4186: LD_EXP 18
4190: PPUSH
4191: CALL_OW 302
4195: IFFALSE 4209
// Say ( Stevens , D10a-Huck-3 ) ;
4197: LD_EXP 18
4201: PPUSH
4202: LD_STRING D10a-Huck-3
4204: PPUSH
4205: CALL_OW 88
// DialogueOff ;
4209: CALL_OW 7
// SetAttitude ( 1 , 7 , att_friend , true ) ;
4213: LD_INT 1
4215: PPUSH
4216: LD_INT 7
4218: PPUSH
4219: LD_INT 1
4221: PPUSH
4222: LD_INT 1
4224: PPUSH
4225: CALL_OW 80
// planCaptured := true ;
4229: LD_ADDR_EXP 7
4233: PUSH
4234: LD_INT 1
4236: ST_TO_ADDR
// ChangeMissionObjectives ( MEnd ) ;
4237: LD_STRING MEnd
4239: PPUSH
4240: CALL_OW 337
// SetAchievement ( ACH_DIPLOMACY ) ;
4244: LD_STRING ACH_DIPLOMACY
4246: PPUSH
4247: CALL_OW 543
// canEnd := true ;
4251: LD_ADDR_EXP 10
4255: PUSH
4256: LD_INT 1
4258: ST_TO_ADDR
// missionTime := tick ;
4259: LD_ADDR_EXP 11
4263: PUSH
4264: LD_OWVAR 1
4268: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4269: LD_INT 35
4271: PPUSH
4272: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] ] ) then
4276: LD_INT 22
4278: PUSH
4279: LD_INT 1
4281: PUSH
4282: EMPTY
4283: LIST
4284: LIST
4285: PUSH
4286: LD_INT 3
4288: PUSH
4289: LD_INT 50
4291: PUSH
4292: EMPTY
4293: LIST
4294: PUSH
4295: EMPTY
4296: LIST
4297: LIST
4298: PUSH
4299: EMPTY
4300: LIST
4301: LIST
4302: PPUSH
4303: CALL_OW 69
4307: IFFALSE 4423
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) do
4309: LD_ADDR_VAR 0 1
4313: PUSH
4314: LD_INT 22
4316: PUSH
4317: LD_INT 1
4319: PUSH
4320: EMPTY
4321: LIST
4322: LIST
4323: PUSH
4324: LD_INT 25
4326: PUSH
4327: LD_INT 4
4329: PUSH
4330: EMPTY
4331: LIST
4332: LIST
4333: PUSH
4334: EMPTY
4335: LIST
4336: LIST
4337: PPUSH
4338: CALL_OW 69
4342: PUSH
4343: FOR_IN
4344: IFFALSE 4421
// begin if IsInUnit ( i ) then
4346: LD_VAR 0 1
4350: PPUSH
4351: CALL_OW 310
4355: IFFALSE 4368
// ComExitBuilding ( i ) else
4357: LD_VAR 0 1
4361: PPUSH
4362: CALL_OW 122
4366: GO 4419
// ComHeal ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] ] ) , i ) ) ;
4368: LD_VAR 0 1
4372: PPUSH
4373: LD_INT 22
4375: PUSH
4376: LD_INT 1
4378: PUSH
4379: EMPTY
4380: LIST
4381: LIST
4382: PUSH
4383: LD_INT 3
4385: PUSH
4386: LD_INT 50
4388: PUSH
4389: EMPTY
4390: LIST
4391: PUSH
4392: EMPTY
4393: LIST
4394: LIST
4395: PUSH
4396: EMPTY
4397: LIST
4398: LIST
4399: PPUSH
4400: CALL_OW 69
4404: PPUSH
4405: LD_VAR 0 1
4409: PPUSH
4410: CALL_OW 74
4414: PPUSH
4415: CALL_OW 128
// end ;
4419: GO 4343
4421: POP
4422: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] ] ) ;
4423: LD_INT 22
4425: PUSH
4426: LD_INT 1
4428: PUSH
4429: EMPTY
4430: LIST
4431: LIST
4432: PUSH
4433: LD_INT 3
4435: PUSH
4436: LD_INT 50
4438: PUSH
4439: EMPTY
4440: LIST
4441: PUSH
4442: EMPTY
4443: LIST
4444: LIST
4445: PUSH
4446: EMPTY
4447: LIST
4448: LIST
4449: PPUSH
4450: CALL_OW 69
4454: NOT
4455: IFFALSE 4269
// repeat wait ( 3 ) ;
4457: LD_INT 3
4459: PPUSH
4460: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) do
4464: LD_ADDR_VAR 0 1
4468: PUSH
4469: LD_INT 22
4471: PUSH
4472: LD_INT 1
4474: PUSH
4475: EMPTY
4476: LIST
4477: LIST
4478: PUSH
4479: LD_INT 21
4481: PUSH
4482: LD_INT 1
4484: PUSH
4485: EMPTY
4486: LIST
4487: LIST
4488: PUSH
4489: EMPTY
4490: LIST
4491: LIST
4492: PPUSH
4493: CALL_OW 69
4497: PUSH
4498: FOR_IN
4499: IFFALSE 4575
// begin if IsInArea ( i , stevensEscapeArea ) then
4501: LD_VAR 0 1
4505: PPUSH
4506: LD_INT 8
4508: PPUSH
4509: CALL_OW 308
4513: IFFALSE 4526
// begin RemoveUnit ( i ) ;
4515: LD_VAR 0 1
4519: PPUSH
4520: CALL_OW 64
// continue ;
4524: GO 4498
// end ; if IsInUnit ( i ) then
4526: LD_VAR 0 1
4530: PPUSH
4531: CALL_OW 310
4535: IFFALSE 4546
// ComExitBuilding ( i ) ;
4537: LD_VAR 0 1
4541: PPUSH
4542: CALL_OW 122
// if not HasTask ( i ) then
4546: LD_VAR 0 1
4550: PPUSH
4551: CALL_OW 314
4555: NOT
4556: IFFALSE 4573
// ComMoveXY ( i , 28 , 55 ) ;
4558: LD_VAR 0 1
4562: PPUSH
4563: LD_INT 28
4565: PPUSH
4566: LD_INT 55
4568: PPUSH
4569: CALL_OW 111
// end ;
4573: GO 4498
4575: POP
4576: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ;
4577: LD_INT 22
4579: PUSH
4580: LD_INT 1
4582: PUSH
4583: EMPTY
4584: LIST
4585: LIST
4586: PUSH
4587: LD_INT 21
4589: PUSH
4590: LD_INT 1
4592: PUSH
4593: EMPTY
4594: LIST
4595: LIST
4596: PUSH
4597: EMPTY
4598: LIST
4599: LIST
4600: PPUSH
4601: CALL_OW 69
4605: NOT
4606: IFFALSE 4457
// end ; 2 :
4608: GO 4622
4610: LD_INT 2
4612: DOUBLE
4613: EQUAL
4614: IFTRUE 4618
4616: GO 4621
4618: POP
// ; end ;
4619: GO 4622
4621: POP
// end ;
4622: PPOPN 1
4624: END
// every 0 0$1 trigger canEnd do var un , i , tmp ;
4625: LD_EXP 10
4629: IFFALSE 4986
4631: GO 4633
4633: DISABLE
4634: LD_INT 0
4636: PPUSH
4637: PPUSH
4638: PPUSH
// begin SetAreaMapShow ( endMissionArea , 1 ) ;
4639: LD_INT 10
4641: PPUSH
4642: LD_INT 1
4644: PPUSH
4645: CALL_OW 424
// if Difficulty < 2 then
4649: LD_OWVAR 67
4653: PUSH
4654: LD_INT 2
4656: LESS
4657: IFFALSE 4661
// exit ;
4659: GO 4986
// uc_side := 4 ;
4661: LD_ADDR_OWVAR 20
4665: PUSH
4666: LD_INT 4
4668: ST_TO_ADDR
// uc_nation := 1 ;
4669: LD_ADDR_OWVAR 21
4673: PUSH
4674: LD_INT 1
4676: ST_TO_ADDR
// InitHc ;
4677: CALL_OW 19
// tmp := [ ] ;
4681: LD_ADDR_VAR 0 3
4685: PUSH
4686: EMPTY
4687: ST_TO_ADDR
// PrepareHuman ( false , class_sniper , 10 ) ;
4688: LD_INT 0
4690: PPUSH
4691: LD_INT 5
4693: PPUSH
4694: LD_INT 10
4696: PPUSH
4697: CALL_OW 380
// un := CreateHuman ;
4701: LD_ADDR_VAR 0 1
4705: PUSH
4706: CALL_OW 44
4710: ST_TO_ADDR
// tmp := [ un ] ;
4711: LD_ADDR_VAR 0 3
4715: PUSH
4716: LD_VAR 0 1
4720: PUSH
4721: EMPTY
4722: LIST
4723: ST_TO_ADDR
// PlaceUnitXY ( un , 226 , 86 , false ) ;
4724: LD_VAR 0 1
4728: PPUSH
4729: LD_INT 226
4731: PPUSH
4732: LD_INT 86
4734: PPUSH
4735: LD_INT 0
4737: PPUSH
4738: CALL_OW 48
// ComHold ( un ) ;
4742: LD_VAR 0 1
4746: PPUSH
4747: CALL_OW 140
// for i = 1 to 3 do
4751: LD_ADDR_VAR 0 2
4755: PUSH
4756: DOUBLE
4757: LD_INT 1
4759: DEC
4760: ST_TO_ADDR
4761: LD_INT 3
4763: PUSH
4764: FOR_TO
4765: IFFALSE 4864
// begin PrepareHuman ( false , class_soldier , 8 ) ;
4767: LD_INT 0
4769: PPUSH
4770: LD_INT 1
4772: PPUSH
4773: LD_INT 8
4775: PPUSH
4776: CALL_OW 380
// un := CreateHuman ;
4780: LD_ADDR_VAR 0 1
4784: PUSH
4785: CALL_OW 44
4789: ST_TO_ADDR
// SetDir ( un , 5 ) ;
4790: LD_VAR 0 1
4794: PPUSH
4795: LD_INT 5
4797: PPUSH
4798: CALL_OW 233
// PlaceUnitXY ( un , [ 215 , 217 , 219 ] [ i ] , 76 , false ) ;
4802: LD_VAR 0 1
4806: PPUSH
4807: LD_INT 215
4809: PUSH
4810: LD_INT 217
4812: PUSH
4813: LD_INT 219
4815: PUSH
4816: EMPTY
4817: LIST
4818: LIST
4819: LIST
4820: PUSH
4821: LD_VAR 0 2
4825: ARRAY
4826: PPUSH
4827: LD_INT 76
4829: PPUSH
4830: LD_INT 0
4832: PPUSH
4833: CALL_OW 48
// ComCrawl ( un ) ;
4837: LD_VAR 0 1
4841: PPUSH
4842: CALL_OW 137
// tmp := tmp ^ un ;
4846: LD_ADDR_VAR 0 3
4850: PUSH
4851: LD_VAR 0 3
4855: PUSH
4856: LD_VAR 0 1
4860: ADD
4861: ST_TO_ADDR
// end ;
4862: GO 4764
4864: POP
4865: POP
// repeat wait ( 0 0$1 ) ;
4866: LD_INT 35
4868: PPUSH
4869: CALL_OW 67
// until not UnitFilter ( un , [ f_lives , 1000 ] ) ;
4873: LD_VAR 0 1
4877: PPUSH
4878: LD_INT 24
4880: PUSH
4881: LD_INT 1000
4883: PUSH
4884: EMPTY
4885: LIST
4886: LIST
4887: PPUSH
4888: CALL_OW 72
4892: NOT
4893: IFFALSE 4866
// for i in tmp do
4895: LD_ADDR_VAR 0 2
4899: PUSH
4900: LD_VAR 0 3
4904: PUSH
4905: FOR_IN
4906: IFFALSE 4984
// begin wait ( 0 0$1 ) ;
4908: LD_INT 35
4910: PPUSH
4911: CALL_OW 67
// if Crawls ( i ) then
4915: LD_VAR 0 2
4919: PPUSH
4920: CALL_OW 318
4924: IFFALSE 4937
// ComWalk ( i ) else
4926: LD_VAR 0 2
4930: PPUSH
4931: CALL_OW 138
4935: GO 4982
// if GetClass ( i ) = class_sniper then
4937: LD_VAR 0 2
4941: PPUSH
4942: CALL_OW 257
4946: PUSH
4947: LD_INT 5
4949: EQUAL
4950: IFFALSE 4968
// ComAttackSoporific ( i , JMM ) else
4952: LD_VAR 0 2
4956: PPUSH
4957: LD_EXP 14
4961: PPUSH
4962: CALL_OW 166
4966: GO 4982
// ComAttackUnit ( i , JMM ) ;
4968: LD_VAR 0 2
4972: PPUSH
4973: LD_EXP 14
4977: PPUSH
4978: CALL_OW 115
// end ;
4982: GO 4905
4984: POP
4985: POP
// end ;
4986: PPOPN 3
4988: END
// every 0 0$1 trigger not planCaptured and IsDead ( us_lab ) do
4989: LD_EXP 7
4993: NOT
4994: PUSH
4995: LD_INT 1
4997: PPUSH
4998: CALL_OW 301
5002: AND
5003: IFFALSE 5015
5005: GO 5007
5007: DISABLE
// YouLost ( Lab ) ;
5008: LD_STRING Lab
5010: PPUSH
5011: CALL_OW 104
5015: END
// every 0 0$1 trigger FilterUnitsInArea ( endMissionArea , [ f_side , 7 ] ) >= 2 and FilterUnitsInArea ( endMissionArea , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) and canEnd and planCaptured and artifactPickedUp do var m1 , m2 ;
5016: LD_INT 10
5018: PPUSH
5019: LD_INT 22
5021: PUSH
5022: LD_INT 7
5024: PUSH
5025: EMPTY
5026: LIST
5027: LIST
5028: PPUSH
5029: CALL_OW 70
5033: PUSH
5034: LD_INT 2
5036: GREATEREQUAL
5037: PUSH
5038: LD_INT 10
5040: PPUSH
5041: LD_INT 2
5043: PUSH
5044: LD_INT 34
5046: PUSH
5047: LD_INT 12
5049: PUSH
5050: EMPTY
5051: LIST
5052: LIST
5053: PUSH
5054: LD_INT 34
5056: PUSH
5057: LD_INT 51
5059: PUSH
5060: EMPTY
5061: LIST
5062: LIST
5063: PUSH
5064: EMPTY
5065: LIST
5066: LIST
5067: LIST
5068: PPUSH
5069: CALL_OW 70
5073: AND
5074: PUSH
5075: LD_EXP 10
5079: AND
5080: PUSH
5081: LD_EXP 7
5085: AND
5086: PUSH
5087: LD_EXP 6
5091: AND
5092: IFFALSE 5348
5094: GO 5096
5096: DISABLE
5097: LD_INT 0
5099: PPUSH
5100: PPUSH
// begin m1 := false ;
5101: LD_ADDR_VAR 0 1
5105: PUSH
5106: LD_INT 0
5108: ST_TO_ADDR
// m2 := false ;
5109: LD_ADDR_VAR 0 2
5113: PUSH
5114: LD_INT 0
5116: ST_TO_ADDR
// if killCounter = 0 then
5117: LD_EXP 12
5121: PUSH
5122: LD_INT 0
5124: EQUAL
5125: IFFALSE 5134
// SetAchievement ( ACH_PACIFIST ) ;
5127: LD_STRING ACH_PACIFIST
5129: PPUSH
5130: CALL_OW 543
// if tick < 7 7$00 then
5134: LD_OWVAR 1
5138: PUSH
5139: LD_INT 14700
5141: LESS
5142: IFFALSE 5158
// begin wait ( 3 ) ;
5144: LD_INT 3
5146: PPUSH
5147: CALL_OW 67
// SetAchievement ( ACH_ASPEED_18 ) ;
5151: LD_STRING ACH_ASPEED_18
5153: PPUSH
5154: CALL_OW 543
// end ; AddMedal ( Explosion , 1 ) ;
5158: LD_STRING Explosion
5160: PPUSH
5161: LD_INT 1
5163: PPUSH
5164: CALL_OW 101
// if enteredContaminatedArea then
5168: LD_EXP 5
5172: IFFALSE 5194
// begin m1 := true ;
5174: LD_ADDR_VAR 0 1
5178: PUSH
5179: LD_INT 1
5181: ST_TO_ADDR
// AddMedal ( BioHazard , 1 ) ;
5182: LD_STRING BioHazard
5184: PPUSH
5185: LD_INT 1
5187: PPUSH
5188: CALL_OW 101
// end else
5192: GO 5205
// AddMedal ( BioHazard , - 1 ) ;
5194: LD_STRING BioHazard
5196: PPUSH
5197: LD_INT 1
5199: NEG
5200: PPUSH
5201: CALL_OW 101
// if missionTime <= [ 20 20$00 , 15 15$00 , 12 12$00 ] [ Difficulty ] then
5205: LD_EXP 11
5209: PUSH
5210: LD_INT 42000
5212: PUSH
5213: LD_INT 31500
5215: PUSH
5216: LD_INT 25200
5218: PUSH
5219: EMPTY
5220: LIST
5221: LIST
5222: LIST
5223: PUSH
5224: LD_OWVAR 67
5228: ARRAY
5229: LESSEQUAL
5230: IFFALSE 5252
// begin m2 := true ;
5232: LD_ADDR_VAR 0 2
5236: PUSH
5237: LD_INT 1
5239: ST_TO_ADDR
// AddMedal ( Speed , 1 ) ;
5240: LD_STRING Speed
5242: PPUSH
5243: LD_INT 1
5245: PPUSH
5246: CALL_OW 101
// end else
5250: GO 5263
// AddMedal ( Speed , - 1 ) ;
5252: LD_STRING Speed
5254: PPUSH
5255: LD_INT 1
5257: NEG
5258: PPUSH
5259: CALL_OW 101
// if Difficulty = 3 and m1 and m2 then
5263: LD_OWVAR 67
5267: PUSH
5268: LD_INT 3
5270: EQUAL
5271: PUSH
5272: LD_VAR 0 1
5276: AND
5277: PUSH
5278: LD_VAR 0 2
5282: AND
5283: IFFALSE 5295
// SetAchievementEX ( ACH_AMER , 18 ) ;
5285: LD_STRING ACH_AMER
5287: PPUSH
5288: LD_INT 18
5290: PPUSH
5291: CALL_OW 564
// GiveMedals ( Main ) ;
5295: LD_STRING Main
5297: PPUSH
5298: CALL_OW 102
// RewardPeople ( [ JMM , Burlak ] ) ;
5302: LD_EXP 14
5306: PUSH
5307: LD_EXP 15
5311: PUSH
5312: EMPTY
5313: LIST
5314: LIST
5315: PPUSH
5316: CALL_OW 43
// SaveCharacters ( JMM , 14a_JMM ) ;
5320: LD_EXP 14
5324: PPUSH
5325: LD_STRING 14a_JMM
5327: PPUSH
5328: CALL_OW 38
// SaveCharacters ( Burlak , 14a_Burlak ) ;
5332: LD_EXP 15
5336: PPUSH
5337: LD_STRING 14a_Burlak
5339: PPUSH
5340: CALL_OW 38
// YouWin ;
5344: CALL_OW 103
// end ; end_of_file
5348: PPOPN 2
5350: END
// export Stevens , Powell , baseGuards , sibBomb , guards , vehGuard ; export function PrepareAmerican ; var i , un , tmp ; begin
5351: LD_INT 0
5353: PPUSH
5354: PPUSH
5355: PPUSH
5356: PPUSH
// uc_side := 1 ;
5357: LD_ADDR_OWVAR 20
5361: PUSH
5362: LD_INT 1
5364: ST_TO_ADDR
// uc_nation := 1 ;
5365: LD_ADDR_OWVAR 21
5369: PUSH
5370: LD_INT 1
5372: ST_TO_ADDR
// InitHc ;
5373: CALL_OW 19
// SetResourceType ( GetBase ( us_depot2 ) , mat_cans , 500 ) ;
5377: LD_INT 34
5379: PPUSH
5380: CALL_OW 274
5384: PPUSH
5385: LD_INT 1
5387: PPUSH
5388: LD_INT 500
5390: PPUSH
5391: CALL_OW 277
// SetResourceType ( GetBase ( us_depot2 ) , mat_siberit , 20 ) ;
5395: LD_INT 34
5397: PPUSH
5398: CALL_OW 274
5402: PPUSH
5403: LD_INT 3
5405: PPUSH
5406: LD_INT 20
5408: PPUSH
5409: CALL_OW 277
// Stevens := NewCharacter ( Stevens ) ;
5413: LD_ADDR_EXP 18
5417: PUSH
5418: LD_STRING Stevens
5420: PPUSH
5421: CALL_OW 25
5425: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
5426: LD_ADDR_EXP 19
5430: PUSH
5431: LD_STRING Powell
5433: PPUSH
5434: CALL_OW 25
5438: ST_TO_ADDR
// PlaceHumanInUnit ( Stevens , us_lab ) ;
5439: LD_EXP 18
5443: PPUSH
5444: LD_INT 1
5446: PPUSH
5447: CALL_OW 52
// vehGuard := [ ] ;
5451: LD_ADDR_EXP 23
5455: PUSH
5456: EMPTY
5457: ST_TO_ADDR
// hc_importance := 0 ;
5458: LD_ADDR_OWVAR 32
5462: PUSH
5463: LD_INT 0
5465: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_siberite , control_computer , us_siberium_rocket , 100 ) ;
5466: LD_INT 4
5468: PPUSH
5469: LD_INT 3
5471: PPUSH
5472: LD_INT 3
5474: PPUSH
5475: LD_INT 8
5477: PPUSH
5478: LD_INT 100
5480: PPUSH
5481: CALL 971 0 5
// sibBomb := CreateVehicle ;
5485: LD_ADDR_EXP 21
5489: PUSH
5490: CALL_OW 45
5494: ST_TO_ADDR
// SetDir ( sibBomb , 1 ) ;
5495: LD_EXP 21
5499: PPUSH
5500: LD_INT 1
5502: PPUSH
5503: CALL_OW 233
// PlaceUnitXY ( sibBomb , 93 , 74 , false ) ;
5507: LD_EXP 21
5511: PPUSH
5512: LD_INT 93
5514: PPUSH
5515: LD_INT 74
5517: PPUSH
5518: LD_INT 0
5520: PPUSH
5521: CALL_OW 48
// guards := [ ] ;
5525: LD_ADDR_EXP 22
5529: PUSH
5530: EMPTY
5531: ST_TO_ADDR
// for i = 1 to 3 do
5532: LD_ADDR_VAR 0 2
5536: PUSH
5537: DOUBLE
5538: LD_INT 1
5540: DEC
5541: ST_TO_ADDR
5542: LD_INT 3
5544: PUSH
5545: FOR_TO
5546: IFFALSE 5638
// begin PrepareHuman ( false , class_soldier , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
5548: LD_INT 0
5550: PPUSH
5551: LD_INT 1
5553: PPUSH
5554: LD_INT 8
5556: PUSH
5557: LD_INT 9
5559: PUSH
5560: LD_INT 10
5562: PUSH
5563: EMPTY
5564: LIST
5565: LIST
5566: LIST
5567: PUSH
5568: LD_OWVAR 67
5572: ARRAY
5573: PPUSH
5574: CALL_OW 380
// un := CreateHuman ;
5578: LD_ADDR_VAR 0 3
5582: PUSH
5583: CALL_OW 44
5587: ST_TO_ADDR
// PlaceUnitArea ( un , [ patrol1 , patrol2 , patrol3 ] [ i ] , false ) ;
5588: LD_VAR 0 3
5592: PPUSH
5593: LD_INT 2
5595: PUSH
5596: LD_INT 3
5598: PUSH
5599: LD_INT 4
5601: PUSH
5602: EMPTY
5603: LIST
5604: LIST
5605: LIST
5606: PUSH
5607: LD_VAR 0 2
5611: ARRAY
5612: PPUSH
5613: LD_INT 0
5615: PPUSH
5616: CALL_OW 49
// guards := guards ^ un ;
5620: LD_ADDR_EXP 22
5624: PUSH
5625: LD_EXP 22
5629: PUSH
5630: LD_VAR 0 3
5634: ADD
5635: ST_TO_ADDR
// end ;
5636: GO 5545
5638: POP
5639: POP
// baseGuards := [ ] ;
5640: LD_ADDR_EXP 20
5644: PUSH
5645: EMPTY
5646: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
5647: LD_ADDR_VAR 0 2
5651: PUSH
5652: DOUBLE
5653: LD_INT 1
5655: DEC
5656: ST_TO_ADDR
5657: LD_INT 5
5659: PUSH
5660: LD_INT 6
5662: PUSH
5663: LD_INT 7
5665: PUSH
5666: EMPTY
5667: LIST
5668: LIST
5669: LIST
5670: PUSH
5671: LD_OWVAR 67
5675: ARRAY
5676: PUSH
5677: FOR_TO
5678: IFFALSE 5824
// begin PrepareSoldier ( false , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
5680: LD_INT 0
5682: PPUSH
5683: LD_INT 8
5685: PUSH
5686: LD_INT 9
5688: PUSH
5689: LD_INT 10
5691: PUSH
5692: EMPTY
5693: LIST
5694: LIST
5695: LIST
5696: PUSH
5697: LD_OWVAR 67
5701: ARRAY
5702: PPUSH
5703: CALL_OW 381
// un := CreateHuman ;
5707: LD_ADDR_VAR 0 3
5711: PUSH
5712: CALL_OW 44
5716: ST_TO_ADDR
// baseGuards := baseGuards ^ un ;
5717: LD_ADDR_EXP 20
5721: PUSH
5722: LD_EXP 20
5726: PUSH
5727: LD_VAR 0 3
5731: ADD
5732: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
5733: LD_ADDR_VAR 0 4
5737: PUSH
5738: LD_INT 22
5740: PUSH
5741: LD_INT 1
5743: PUSH
5744: EMPTY
5745: LIST
5746: LIST
5747: PUSH
5748: LD_INT 58
5750: PUSH
5751: EMPTY
5752: LIST
5753: PUSH
5754: LD_INT 30
5756: PUSH
5757: LD_INT 32
5759: PUSH
5760: EMPTY
5761: LIST
5762: LIST
5763: PUSH
5764: EMPTY
5765: LIST
5766: LIST
5767: LIST
5768: PPUSH
5769: CALL_OW 69
5773: ST_TO_ADDR
// if tmp then
5774: LD_VAR 0 4
5778: IFFALSE 5810
// PlaceHumanInUnit ( un , tmp [ rand ( 1 , tmp ) ] ) else
5780: LD_VAR 0 3
5784: PPUSH
5785: LD_VAR 0 4
5789: PUSH
5790: LD_INT 1
5792: PPUSH
5793: LD_VAR 0 4
5797: PPUSH
5798: CALL_OW 12
5802: ARRAY
5803: PPUSH
5804: CALL_OW 52
5808: GO 5822
// PlaceHumanInUnit ( un , us_bar ) ;
5810: LD_VAR 0 3
5814: PPUSH
5815: LD_INT 51
5817: PPUSH
5818: CALL_OW 52
// end ;
5822: GO 5677
5824: POP
5825: POP
// if Difficulty > 1 then
5826: LD_OWVAR 67
5830: PUSH
5831: LD_INT 1
5833: GREATER
5834: IFFALSE 5878
// begin PrepareHuman ( false , class_sniper , [ 9 , 10 ] [ Difficulty - 1 ] ) ;
5836: LD_INT 0
5838: PPUSH
5839: LD_INT 5
5841: PPUSH
5842: LD_INT 9
5844: PUSH
5845: LD_INT 10
5847: PUSH
5848: EMPTY
5849: LIST
5850: LIST
5851: PUSH
5852: LD_OWVAR 67
5856: PUSH
5857: LD_INT 1
5859: MINUS
5860: ARRAY
5861: PPUSH
5862: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_bun1 ) ;
5866: CALL_OW 44
5870: PPUSH
5871: LD_INT 80
5873: PPUSH
5874: CALL_OW 52
// end ; for i = 1 to 3 do
5878: LD_ADDR_VAR 0 2
5882: PUSH
5883: DOUBLE
5884: LD_INT 1
5886: DEC
5887: ST_TO_ADDR
5888: LD_INT 3
5890: PUSH
5891: FOR_TO
5892: IFFALSE 5918
// begin PrepareMechanic ( false , 9 ) ;
5894: LD_INT 0
5896: PPUSH
5897: LD_INT 9
5899: PPUSH
5900: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , us_fac ) ;
5904: CALL_OW 44
5908: PPUSH
5909: LD_INT 43
5911: PPUSH
5912: CALL_OW 52
// end ;
5916: GO 5891
5918: POP
5919: POP
// PlaceHumanInUnit ( CreateHuman , us_ct ) ;
5920: CALL_OW 44
5924: PPUSH
5925: LD_INT 49
5927: PPUSH
5928: CALL_OW 52
// for i = 1 to 1 + Difficulty do
5932: LD_ADDR_VAR 0 2
5936: PUSH
5937: DOUBLE
5938: LD_INT 1
5940: DEC
5941: ST_TO_ADDR
5942: LD_INT 1
5944: PUSH
5945: LD_OWVAR 67
5949: PLUS
5950: PUSH
5951: FOR_TO
5952: IFFALSE 5995
// begin PrepareEngineer ( false , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
5954: LD_INT 0
5956: PPUSH
5957: LD_INT 8
5959: PUSH
5960: LD_INT 9
5962: PUSH
5963: LD_INT 10
5965: PUSH
5966: EMPTY
5967: LIST
5968: LIST
5969: LIST
5970: PUSH
5971: LD_OWVAR 67
5975: ARRAY
5976: PPUSH
5977: CALL_OW 382
// PlaceHumanInUnit ( CreateHuman , us_depot ) ;
5981: CALL_OW 44
5985: PPUSH
5986: LD_INT 5
5988: PPUSH
5989: CALL_OW 52
// end ;
5993: GO 5951
5995: POP
5996: POP
// for i = 1 to 3 do
5997: LD_ADDR_VAR 0 2
6001: PUSH
6002: DOUBLE
6003: LD_INT 1
6005: DEC
6006: ST_TO_ADDR
6007: LD_INT 3
6009: PUSH
6010: FOR_TO
6011: IFFALSE 6037
// begin PrepareScientist ( false , 10 ) ;
6013: LD_INT 0
6015: PPUSH
6016: LD_INT 10
6018: PPUSH
6019: CALL_OW 384
// PlaceHumanInUnit ( CreateHuman , us_lab ) ;
6023: CALL_OW 44
6027: PPUSH
6028: LD_INT 1
6030: PPUSH
6031: CALL_OW 52
// end ;
6035: GO 6010
6037: POP
6038: POP
// end ;
6039: LD_VAR 0 1
6043: RET
// every 0 0$2 trigger guards and not activeBombTest do var i , j , points ;
6044: LD_EXP 22
6048: PUSH
6049: LD_EXP 2
6053: NOT
6054: AND
6055: IFFALSE 6241
6057: GO 6059
6059: DISABLE
6060: LD_INT 0
6062: PPUSH
6063: PPUSH
6064: PPUSH
// begin enable ;
6065: ENABLE
// points := [ [ 204 , 30 ] , [ 165 , 24 ] , [ 195 , 6 ] , [ 223 , 54 ] , [ 214 , 84 ] , [ 206 , 71 ] ] ;
6066: LD_ADDR_VAR 0 3
6070: PUSH
6071: LD_INT 204
6073: PUSH
6074: LD_INT 30
6076: PUSH
6077: EMPTY
6078: LIST
6079: LIST
6080: PUSH
6081: LD_INT 165
6083: PUSH
6084: LD_INT 24
6086: PUSH
6087: EMPTY
6088: LIST
6089: LIST
6090: PUSH
6091: LD_INT 195
6093: PUSH
6094: LD_INT 6
6096: PUSH
6097: EMPTY
6098: LIST
6099: LIST
6100: PUSH
6101: LD_INT 223
6103: PUSH
6104: LD_INT 54
6106: PUSH
6107: EMPTY
6108: LIST
6109: LIST
6110: PUSH
6111: LD_INT 214
6113: PUSH
6114: LD_INT 84
6116: PUSH
6117: EMPTY
6118: LIST
6119: LIST
6120: PUSH
6121: LD_INT 206
6123: PUSH
6124: LD_INT 71
6126: PUSH
6127: EMPTY
6128: LIST
6129: LIST
6130: PUSH
6131: EMPTY
6132: LIST
6133: LIST
6134: LIST
6135: LIST
6136: LIST
6137: LIST
6138: ST_TO_ADDR
// for i in guards do
6139: LD_ADDR_VAR 0 1
6143: PUSH
6144: LD_EXP 22
6148: PUSH
6149: FOR_IN
6150: IFFALSE 6239
// begin if HasTask ( i ) then
6152: LD_VAR 0 1
6156: PPUSH
6157: CALL_OW 314
6161: IFFALSE 6167
// continue else
6163: GO 6149
6165: GO 6237
// begin j := rand ( 1 , 6 ) ;
6167: LD_ADDR_VAR 0 2
6171: PUSH
6172: LD_INT 1
6174: PPUSH
6175: LD_INT 6
6177: PPUSH
6178: CALL_OW 12
6182: ST_TO_ADDR
// if not See ( 7 , i ) then
6183: LD_INT 7
6185: PPUSH
6186: LD_VAR 0 1
6190: PPUSH
6191: CALL_OW 292
6195: NOT
6196: IFFALSE 6237
// ComAgressiveMove ( i , points [ j ] [ 1 ] , points [ j ] [ 2 ] ) ;
6198: LD_VAR 0 1
6202: PPUSH
6203: LD_VAR 0 3
6207: PUSH
6208: LD_VAR 0 2
6212: ARRAY
6213: PUSH
6214: LD_INT 1
6216: ARRAY
6217: PPUSH
6218: LD_VAR 0 3
6222: PUSH
6223: LD_VAR 0 2
6227: ARRAY
6228: PUSH
6229: LD_INT 2
6231: ARRAY
6232: PPUSH
6233: CALL_OW 114
// end ; end ;
6237: GO 6149
6239: POP
6240: POP
// end ;
6241: PPOPN 3
6243: END
// every 0 0$1 trigger vehGuard and not planCaptured do var i ;
6244: LD_EXP 23
6248: PUSH
6249: LD_EXP 7
6253: NOT
6254: AND
6255: IFFALSE 6326
6257: GO 6259
6259: DISABLE
6260: LD_INT 0
6262: PPUSH
// begin enable ;
6263: ENABLE
// for i in vehGuard do
6264: LD_ADDR_VAR 0 1
6268: PUSH
6269: LD_EXP 23
6273: PUSH
6274: FOR_IN
6275: IFFALSE 6324
// if IsOk ( vehGuard ) then
6277: LD_EXP 23
6281: PPUSH
6282: CALL_OW 302
6286: IFFALSE 6322
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , i ) ) ;
6288: LD_VAR 0 1
6292: PPUSH
6293: LD_INT 22
6295: PUSH
6296: LD_INT 7
6298: PUSH
6299: EMPTY
6300: LIST
6301: LIST
6302: PPUSH
6303: CALL_OW 69
6307: PPUSH
6308: LD_VAR 0 1
6312: PPUSH
6313: CALL_OW 74
6317: PPUSH
6318: CALL_OW 115
6322: GO 6274
6324: POP
6325: POP
// end ;
6326: PPOPN 1
6328: END
// every 9 9$00 trigger bombExploded and IsOk ( us_fac ) and not planCaptured do
6329: LD_EXP 4
6333: PUSH
6334: LD_INT 43
6336: PPUSH
6337: CALL_OW 302
6341: AND
6342: PUSH
6343: LD_EXP 7
6347: NOT
6348: AND
6349: IFFALSE 6397
6351: GO 6353
6353: DISABLE
// begin enable ;
6354: ENABLE
// ComConstruct ( us_fac , us_morphling , engine_siberite , control_remote , [ us_rocket_launcher , us_rocket_launcher , us_laser ] [ rand ( 1 , 3 ) ] ) ;
6355: LD_INT 43
6357: PPUSH
6358: LD_INT 5
6360: PPUSH
6361: LD_INT 3
6363: PPUSH
6364: LD_INT 2
6366: PPUSH
6367: LD_INT 7
6369: PUSH
6370: LD_INT 7
6372: PUSH
6373: LD_INT 9
6375: PUSH
6376: EMPTY
6377: LIST
6378: LIST
6379: LIST
6380: PUSH
6381: LD_INT 1
6383: PPUSH
6384: LD_INT 3
6386: PPUSH
6387: CALL_OW 12
6391: ARRAY
6392: PPUSH
6393: CALL_OW 125
// end ;
6397: END
// every 1 1$45 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_sniper ] , [ f_ok ] ] ) and not planCaptured do var tmp , b ;
6398: LD_INT 22
6400: PUSH
6401: LD_INT 1
6403: PUSH
6404: EMPTY
6405: LIST
6406: LIST
6407: PUSH
6408: LD_INT 25
6410: PUSH
6411: LD_INT 5
6413: PUSH
6414: EMPTY
6415: LIST
6416: LIST
6417: PUSH
6418: LD_INT 50
6420: PUSH
6421: EMPTY
6422: LIST
6423: PUSH
6424: EMPTY
6425: LIST
6426: LIST
6427: LIST
6428: PPUSH
6429: CALL_OW 69
6433: PUSH
6434: LD_EXP 7
6438: NOT
6439: AND
6440: IFFALSE 6669
6442: GO 6444
6444: DISABLE
6445: LD_INT 0
6447: PPUSH
6448: PPUSH
// begin enable ;
6449: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_sniper ] , [ f_ok ] ] ) ;
6450: LD_ADDR_VAR 0 1
6454: PUSH
6455: LD_INT 22
6457: PUSH
6458: LD_INT 1
6460: PUSH
6461: EMPTY
6462: LIST
6463: LIST
6464: PUSH
6465: LD_INT 25
6467: PUSH
6468: LD_INT 5
6470: PUSH
6471: EMPTY
6472: LIST
6473: LIST
6474: PUSH
6475: LD_INT 50
6477: PUSH
6478: EMPTY
6479: LIST
6480: PUSH
6481: EMPTY
6482: LIST
6483: LIST
6484: LIST
6485: PPUSH
6486: CALL_OW 69
6490: ST_TO_ADDR
// if not tmp then
6491: LD_VAR 0 1
6495: NOT
6496: IFFALSE 6500
// exit ;
6498: GO 6669
// b := IsInUnit ( tmp [ 1 ] ) ;
6500: LD_ADDR_VAR 0 2
6504: PUSH
6505: LD_VAR 0 1
6509: PUSH
6510: LD_INT 1
6512: ARRAY
6513: PPUSH
6514: CALL_OW 310
6518: ST_TO_ADDR
// if not b or HasTask ( tmp [ 1 ] ) then
6519: LD_VAR 0 2
6523: NOT
6524: PUSH
6525: LD_VAR 0 1
6529: PUSH
6530: LD_INT 1
6532: ARRAY
6533: PPUSH
6534: CALL_OW 314
6538: OR
6539: IFFALSE 6543
// exit ;
6541: GO 6669
// if b = us_bun1 then
6543: LD_VAR 0 2
6547: PUSH
6548: LD_INT 80
6550: EQUAL
6551: IFFALSE 6612
// begin ComExitBuilding ( tmp [ 1 ] ) ;
6553: LD_VAR 0 1
6557: PUSH
6558: LD_INT 1
6560: ARRAY
6561: PPUSH
6562: CALL_OW 122
// AddComAgressiveMove ( tmp [ 1 ] , 27 , 44 ) ;
6566: LD_VAR 0 1
6570: PUSH
6571: LD_INT 1
6573: ARRAY
6574: PPUSH
6575: LD_INT 27
6577: PPUSH
6578: LD_INT 44
6580: PPUSH
6581: CALL_OW 174
// if IsOk ( us_bun2 ) then
6585: LD_INT 55
6587: PPUSH
6588: CALL_OW 302
6592: IFFALSE 6610
// AddComEnterUnit ( tmp [ 1 ] , us_bun2 ) ;
6594: LD_VAR 0 1
6598: PUSH
6599: LD_INT 1
6601: ARRAY
6602: PPUSH
6603: LD_INT 55
6605: PPUSH
6606: CALL_OW 180
// end else
6610: GO 6669
// begin ComExitBuilding ( tmp [ 1 ] ) ;
6612: LD_VAR 0 1
6616: PUSH
6617: LD_INT 1
6619: ARRAY
6620: PPUSH
6621: CALL_OW 122
// AddComAgressiveMove ( tmp [ 1 ] , 92 , 51 ) ;
6625: LD_VAR 0 1
6629: PUSH
6630: LD_INT 1
6632: ARRAY
6633: PPUSH
6634: LD_INT 92
6636: PPUSH
6637: LD_INT 51
6639: PPUSH
6640: CALL_OW 174
// if IsOk ( us_bun1 ) then
6644: LD_INT 80
6646: PPUSH
6647: CALL_OW 302
6651: IFFALSE 6669
// AddComEnterUnit ( tmp [ 1 ] , us_bun1 ) ;
6653: LD_VAR 0 1
6657: PUSH
6658: LD_INT 1
6660: ARRAY
6661: PPUSH
6662: LD_INT 80
6664: PPUSH
6665: CALL_OW 180
// end ; end ;
6669: PPOPN 2
6671: END
// every 0 0$1 trigger not planCaptured and FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var i , tmp , tmp2 , b ;
6672: LD_EXP 7
6676: NOT
6677: PUSH
6678: LD_INT 9
6680: PPUSH
6681: LD_INT 22
6683: PUSH
6684: LD_INT 1
6686: PUSH
6687: EMPTY
6688: LIST
6689: LIST
6690: PUSH
6691: LD_INT 21
6693: PUSH
6694: LD_INT 3
6696: PUSH
6697: EMPTY
6698: LIST
6699: LIST
6700: PUSH
6701: LD_INT 3
6703: PUSH
6704: LD_INT 24
6706: PUSH
6707: LD_INT 1000
6709: PUSH
6710: EMPTY
6711: LIST
6712: LIST
6713: PUSH
6714: EMPTY
6715: LIST
6716: LIST
6717: PUSH
6718: EMPTY
6719: LIST
6720: LIST
6721: LIST
6722: PPUSH
6723: CALL_OW 70
6727: AND
6728: IFFALSE 7139
6730: GO 6732
6732: DISABLE
6733: LD_INT 0
6735: PPUSH
6736: PPUSH
6737: PPUSH
6738: PPUSH
// begin enable ;
6739: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_lives , 1000 ] ] ) ;
6740: LD_ADDR_VAR 0 2
6744: PUSH
6745: LD_INT 22
6747: PUSH
6748: LD_INT 1
6750: PUSH
6751: EMPTY
6752: LIST
6753: LIST
6754: PUSH
6755: LD_INT 25
6757: PUSH
6758: LD_INT 2
6760: PUSH
6761: EMPTY
6762: LIST
6763: LIST
6764: PUSH
6765: LD_INT 24
6767: PUSH
6768: LD_INT 1000
6770: PUSH
6771: EMPTY
6772: LIST
6773: LIST
6774: PUSH
6775: EMPTY
6776: LIST
6777: LIST
6778: LIST
6779: PPUSH
6780: CALL_OW 69
6784: ST_TO_ADDR
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_not , [ f_lives , 750 ] ] ] ) ;
6785: LD_ADDR_VAR 0 3
6789: PUSH
6790: LD_INT 22
6792: PUSH
6793: LD_INT 1
6795: PUSH
6796: EMPTY
6797: LIST
6798: LIST
6799: PUSH
6800: LD_INT 25
6802: PUSH
6803: LD_INT 2
6805: PUSH
6806: EMPTY
6807: LIST
6808: LIST
6809: PUSH
6810: LD_INT 3
6812: PUSH
6813: LD_INT 24
6815: PUSH
6816: LD_INT 750
6818: PUSH
6819: EMPTY
6820: LIST
6821: LIST
6822: PUSH
6823: EMPTY
6824: LIST
6825: LIST
6826: PUSH
6827: EMPTY
6828: LIST
6829: LIST
6830: LIST
6831: PPUSH
6832: CALL_OW 69
6836: ST_TO_ADDR
// b := FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) diff us_lab ;
6837: LD_ADDR_VAR 0 4
6841: PUSH
6842: LD_INT 9
6844: PPUSH
6845: LD_INT 22
6847: PUSH
6848: LD_INT 1
6850: PUSH
6851: EMPTY
6852: LIST
6853: LIST
6854: PUSH
6855: LD_INT 21
6857: PUSH
6858: LD_INT 3
6860: PUSH
6861: EMPTY
6862: LIST
6863: LIST
6864: PUSH
6865: LD_INT 3
6867: PUSH
6868: LD_INT 24
6870: PUSH
6871: LD_INT 1000
6873: PUSH
6874: EMPTY
6875: LIST
6876: LIST
6877: PUSH
6878: EMPTY
6879: LIST
6880: LIST
6881: PUSH
6882: EMPTY
6883: LIST
6884: LIST
6885: LIST
6886: PPUSH
6887: CALL_OW 70
6891: PUSH
6892: LD_INT 1
6894: DIFF
6895: ST_TO_ADDR
// if not tmp and not tmp2 then
6896: LD_VAR 0 2
6900: NOT
6901: PUSH
6902: LD_VAR 0 3
6906: NOT
6907: AND
6908: IFFALSE 6912
// exit ;
6910: GO 7139
// if tmp and b then
6912: LD_VAR 0 2
6916: PUSH
6917: LD_VAR 0 4
6921: AND
6922: IFFALSE 7052
// for i in tmp do
6924: LD_ADDR_VAR 0 1
6928: PUSH
6929: LD_VAR 0 2
6933: PUSH
6934: FOR_IN
6935: IFFALSE 7050
// begin if GetTag ( i ) = 1 and GetLives ( i ) < 1000 then
6937: LD_VAR 0 1
6941: PPUSH
6942: CALL_OW 110
6946: PUSH
6947: LD_INT 1
6949: EQUAL
6950: PUSH
6951: LD_VAR 0 1
6955: PPUSH
6956: CALL_OW 256
6960: PUSH
6961: LD_INT 1000
6963: LESS
6964: AND
6965: IFFALSE 6971
// continue else
6967: GO 6934
6969: GO 6998
// if GetTag ( i ) = 1 then
6971: LD_VAR 0 1
6975: PPUSH
6976: CALL_OW 110
6980: PUSH
6981: LD_INT 1
6983: EQUAL
6984: IFFALSE 6998
// SetTag ( i , 0 ) ;
6986: LD_VAR 0 1
6990: PPUSH
6991: LD_INT 0
6993: PPUSH
6994: CALL_OW 109
// if IsInUnit ( i ) then
6998: LD_VAR 0 1
7002: PPUSH
7003: CALL_OW 310
7007: IFFALSE 7018
// ComExitBuilding ( i ) ;
7009: LD_VAR 0 1
7013: PPUSH
7014: CALL_OW 122
// if not HasTask ( i ) then
7018: LD_VAR 0 1
7022: PPUSH
7023: CALL_OW 314
7027: NOT
7028: IFFALSE 7048
// AddComRepairBuilding ( i , b [ 1 ] ) ;
7030: LD_VAR 0 1
7034: PPUSH
7035: LD_VAR 0 4
7039: PUSH
7040: LD_INT 1
7042: ARRAY
7043: PPUSH
7044: CALL_OW 190
// end ;
7048: GO 6934
7050: POP
7051: POP
// if tmp2 then
7052: LD_VAR 0 3
7056: IFFALSE 7139
// for i in tmp2 do
7058: LD_ADDR_VAR 0 1
7062: PUSH
7063: LD_VAR 0 3
7067: PUSH
7068: FOR_IN
7069: IFFALSE 7137
// begin if not GetTag ( i ) = 1 then
7071: LD_VAR 0 1
7075: PPUSH
7076: CALL_OW 110
7080: PUSH
7081: LD_INT 1
7083: EQUAL
7084: NOT
7085: IFFALSE 7099
// SetTag ( i , 1 ) ;
7087: LD_VAR 0 1
7091: PPUSH
7092: LD_INT 1
7094: PPUSH
7095: CALL_OW 109
// if GetDistUnitXY ( i , 88 , 75 ) > 6 then
7099: LD_VAR 0 1
7103: PPUSH
7104: LD_INT 88
7106: PPUSH
7107: LD_INT 75
7109: PPUSH
7110: CALL_OW 297
7114: PUSH
7115: LD_INT 6
7117: GREATER
7118: IFFALSE 7135
// ComMoveXY ( i , 88 , 75 ) ;
7120: LD_VAR 0 1
7124: PPUSH
7125: LD_INT 88
7127: PPUSH
7128: LD_INT 75
7130: PPUSH
7131: CALL_OW 111
// end ;
7135: GO 7068
7137: POP
7138: POP
// end ;
7139: PPOPN 4
7141: END
// every 0 0$1 trigger not planCaptured and stevensTimer and FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var i , sci , tmp ;
7142: LD_EXP 7
7146: NOT
7147: PUSH
7148: LD_EXP 9
7152: AND
7153: PUSH
7154: LD_INT 9
7156: PPUSH
7157: LD_INT 22
7159: PUSH
7160: LD_INT 1
7162: PUSH
7163: EMPTY
7164: LIST
7165: LIST
7166: PUSH
7167: LD_INT 21
7169: PUSH
7170: LD_INT 1
7172: PUSH
7173: EMPTY
7174: LIST
7175: LIST
7176: PUSH
7177: LD_INT 3
7179: PUSH
7180: LD_INT 24
7182: PUSH
7183: LD_INT 1000
7185: PUSH
7186: EMPTY
7187: LIST
7188: LIST
7189: PUSH
7190: EMPTY
7191: LIST
7192: LIST
7193: PUSH
7194: EMPTY
7195: LIST
7196: LIST
7197: LIST
7198: PPUSH
7199: CALL_OW 70
7203: AND
7204: IFFALSE 7377
7206: GO 7208
7208: DISABLE
7209: LD_INT 0
7211: PPUSH
7212: PPUSH
7213: PPUSH
// begin enable ;
7214: ENABLE
// sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
7215: LD_ADDR_VAR 0 2
7219: PUSH
7220: LD_INT 22
7222: PUSH
7223: LD_INT 1
7225: PUSH
7226: EMPTY
7227: LIST
7228: LIST
7229: PUSH
7230: LD_INT 25
7232: PUSH
7233: LD_INT 4
7235: PUSH
7236: EMPTY
7237: LIST
7238: LIST
7239: PUSH
7240: EMPTY
7241: LIST
7242: LIST
7243: PPUSH
7244: CALL_OW 69
7248: ST_TO_ADDR
// tmp := FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
7249: LD_ADDR_VAR 0 3
7253: PUSH
7254: LD_INT 9
7256: PPUSH
7257: LD_INT 22
7259: PUSH
7260: LD_INT 1
7262: PUSH
7263: EMPTY
7264: LIST
7265: LIST
7266: PUSH
7267: LD_INT 21
7269: PUSH
7270: LD_INT 1
7272: PUSH
7273: EMPTY
7274: LIST
7275: LIST
7276: PUSH
7277: LD_INT 3
7279: PUSH
7280: LD_INT 24
7282: PUSH
7283: LD_INT 1000
7285: PUSH
7286: EMPTY
7287: LIST
7288: LIST
7289: PUSH
7290: EMPTY
7291: LIST
7292: LIST
7293: PUSH
7294: EMPTY
7295: LIST
7296: LIST
7297: LIST
7298: PPUSH
7299: CALL_OW 70
7303: ST_TO_ADDR
// if not sci or not tmp then
7304: LD_VAR 0 2
7308: NOT
7309: PUSH
7310: LD_VAR 0 3
7314: NOT
7315: OR
7316: IFFALSE 7320
// exit ;
7318: GO 7377
// for i in sci do
7320: LD_ADDR_VAR 0 1
7324: PUSH
7325: LD_VAR 0 2
7329: PUSH
7330: FOR_IN
7331: IFFALSE 7375
// if IsInUnit ( i ) then
7333: LD_VAR 0 1
7337: PPUSH
7338: CALL_OW 310
7342: IFFALSE 7355
// ComExitBuilding ( i ) else
7344: LD_VAR 0 1
7348: PPUSH
7349: CALL_OW 122
7353: GO 7373
// ComHeal ( i , tmp [ 1 ] ) ;
7355: LD_VAR 0 1
7359: PPUSH
7360: LD_VAR 0 3
7364: PUSH
7365: LD_INT 1
7367: ARRAY
7368: PPUSH
7369: CALL_OW 128
7373: GO 7330
7375: POP
7376: POP
// end ;
7377: PPOPN 3
7379: END
// every 0 0$1 trigger not planCaptured and stevensTimer and IsOk ( us_lab ) and not FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_outside ] ] ) do var i ;
7380: LD_EXP 7
7384: NOT
7385: PUSH
7386: LD_EXP 9
7390: AND
7391: PUSH
7392: LD_INT 1
7394: PPUSH
7395: CALL_OW 302
7399: AND
7400: PUSH
7401: LD_INT 9
7403: PPUSH
7404: LD_INT 22
7406: PUSH
7407: LD_INT 1
7409: PUSH
7410: EMPTY
7411: LIST
7412: LIST
7413: PUSH
7414: LD_INT 21
7416: PUSH
7417: LD_INT 1
7419: PUSH
7420: EMPTY
7421: LIST
7422: LIST
7423: PUSH
7424: LD_INT 3
7426: PUSH
7427: LD_INT 24
7429: PUSH
7430: LD_INT 1000
7432: PUSH
7433: EMPTY
7434: LIST
7435: LIST
7436: PUSH
7437: EMPTY
7438: LIST
7439: LIST
7440: PUSH
7441: EMPTY
7442: LIST
7443: LIST
7444: LIST
7445: PPUSH
7446: CALL_OW 70
7450: NOT
7451: AND
7452: PUSH
7453: LD_INT 22
7455: PUSH
7456: LD_INT 1
7458: PUSH
7459: EMPTY
7460: LIST
7461: LIST
7462: PUSH
7463: LD_INT 25
7465: PUSH
7466: LD_INT 4
7468: PUSH
7469: EMPTY
7470: LIST
7471: LIST
7472: PUSH
7473: LD_INT 56
7475: PUSH
7476: EMPTY
7477: LIST
7478: PUSH
7479: EMPTY
7480: LIST
7481: LIST
7482: LIST
7483: PPUSH
7484: CALL_OW 69
7488: AND
7489: IFFALSE 7582
7491: GO 7493
7493: DISABLE
7494: LD_INT 0
7496: PPUSH
// begin enable ;
7497: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_outside ] ] ) do
7498: LD_ADDR_VAR 0 1
7502: PUSH
7503: LD_INT 22
7505: PUSH
7506: LD_INT 1
7508: PUSH
7509: EMPTY
7510: LIST
7511: LIST
7512: PUSH
7513: LD_INT 25
7515: PUSH
7516: LD_INT 4
7518: PUSH
7519: EMPTY
7520: LIST
7521: LIST
7522: PUSH
7523: LD_INT 56
7525: PUSH
7526: EMPTY
7527: LIST
7528: PUSH
7529: EMPTY
7530: LIST
7531: LIST
7532: LIST
7533: PPUSH
7534: CALL_OW 69
7538: PUSH
7539: FOR_IN
7540: IFFALSE 7580
// if not GetTag ( i ) and not HasTask ( i ) then
7542: LD_VAR 0 1
7546: PPUSH
7547: CALL_OW 110
7551: NOT
7552: PUSH
7553: LD_VAR 0 1
7557: PPUSH
7558: CALL_OW 314
7562: NOT
7563: AND
7564: IFFALSE 7578
// ComEnterUnit ( i , us_lab ) ;
7566: LD_VAR 0 1
7570: PPUSH
7571: LD_INT 1
7573: PPUSH
7574: CALL_OW 120
7578: GO 7539
7580: POP
7581: POP
// end ;
7582: PPOPN 1
7584: END
// every 0 0$1 trigger not planCaptured and not FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_outside ] ] ) do var i ;
7585: LD_EXP 7
7589: NOT
7590: PUSH
7591: LD_INT 9
7593: PPUSH
7594: LD_INT 22
7596: PUSH
7597: LD_INT 1
7599: PUSH
7600: EMPTY
7601: LIST
7602: LIST
7603: PUSH
7604: LD_INT 21
7606: PUSH
7607: LD_INT 3
7609: PUSH
7610: EMPTY
7611: LIST
7612: LIST
7613: PUSH
7614: LD_INT 3
7616: PUSH
7617: LD_INT 24
7619: PUSH
7620: LD_INT 1000
7622: PUSH
7623: EMPTY
7624: LIST
7625: LIST
7626: PUSH
7627: EMPTY
7628: LIST
7629: LIST
7630: PUSH
7631: EMPTY
7632: LIST
7633: LIST
7634: LIST
7635: PPUSH
7636: CALL_OW 70
7640: NOT
7641: AND
7642: PUSH
7643: LD_INT 22
7645: PUSH
7646: LD_INT 1
7648: PUSH
7649: EMPTY
7650: LIST
7651: LIST
7652: PUSH
7653: LD_INT 25
7655: PUSH
7656: LD_INT 2
7658: PUSH
7659: EMPTY
7660: LIST
7661: LIST
7662: PUSH
7663: LD_INT 56
7665: PUSH
7666: EMPTY
7667: LIST
7668: PUSH
7669: EMPTY
7670: LIST
7671: LIST
7672: LIST
7673: PPUSH
7674: CALL_OW 69
7678: AND
7679: IFFALSE 7772
7681: GO 7683
7683: DISABLE
7684: LD_INT 0
7686: PPUSH
// begin enable ;
7687: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_outside ] ] ) do
7688: LD_ADDR_VAR 0 1
7692: PUSH
7693: LD_INT 22
7695: PUSH
7696: LD_INT 1
7698: PUSH
7699: EMPTY
7700: LIST
7701: LIST
7702: PUSH
7703: LD_INT 25
7705: PUSH
7706: LD_INT 2
7708: PUSH
7709: EMPTY
7710: LIST
7711: LIST
7712: PUSH
7713: LD_INT 56
7715: PUSH
7716: EMPTY
7717: LIST
7718: PUSH
7719: EMPTY
7720: LIST
7721: LIST
7722: LIST
7723: PPUSH
7724: CALL_OW 69
7728: PUSH
7729: FOR_IN
7730: IFFALSE 7770
// if not HasTask ( i ) and not GetTag ( i ) then
7732: LD_VAR 0 1
7736: PPUSH
7737: CALL_OW 314
7741: NOT
7742: PUSH
7743: LD_VAR 0 1
7747: PPUSH
7748: CALL_OW 110
7752: NOT
7753: AND
7754: IFFALSE 7768
// ComEnterUnit ( i , us_depot ) ;
7756: LD_VAR 0 1
7760: PPUSH
7761: LD_INT 5
7763: PPUSH
7764: CALL_OW 120
7768: GO 7729
7770: POP
7771: POP
// end ;
7772: PPOPN 1
7774: END
// every 0 0$1 trigger ( stevensTimer <= 0 0$00 or IsDead ( Stevens ) ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) do
7775: LD_EXP 9
7779: PUSH
7780: LD_INT 0
7782: LESSEQUAL
7783: PUSH
7784: LD_EXP 18
7788: PPUSH
7789: CALL_OW 301
7793: OR
7794: PUSH
7795: LD_INT 22
7797: PUSH
7798: LD_INT 1
7800: PUSH
7801: EMPTY
7802: LIST
7803: LIST
7804: PUSH
7805: LD_INT 25
7807: PUSH
7808: LD_INT 2
7810: PUSH
7811: EMPTY
7812: LIST
7813: LIST
7814: PUSH
7815: EMPTY
7816: LIST
7817: LIST
7818: PPUSH
7819: CALL_OW 69
7823: AND
7824: IFFALSE 7865
7826: GO 7828
7828: DISABLE
// ComDismantle ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) , us_lab ) ;
7829: LD_INT 22
7831: PUSH
7832: LD_INT 1
7834: PUSH
7835: EMPTY
7836: LIST
7837: LIST
7838: PUSH
7839: LD_INT 25
7841: PUSH
7842: LD_INT 2
7844: PUSH
7845: EMPTY
7846: LIST
7847: LIST
7848: PUSH
7849: EMPTY
7850: LIST
7851: LIST
7852: PPUSH
7853: CALL_OW 69
7857: PPUSH
7858: LD_INT 1
7860: PPUSH
7861: CALL_OW 167
7865: END
// every 0 0$4 trigger not planCaptured and FilterUnitsInArea ( usBaseCriticalArea , [ f_side , 7 ] ) do var i ;
7866: LD_EXP 7
7870: NOT
7871: PUSH
7872: LD_INT 7
7874: PPUSH
7875: LD_INT 22
7877: PUSH
7878: LD_INT 7
7880: PUSH
7881: EMPTY
7882: LIST
7883: LIST
7884: PPUSH
7885: CALL_OW 70
7889: AND
7890: IFFALSE 7981
7892: GO 7894
7894: DISABLE
7895: LD_INT 0
7897: PPUSH
// begin wait ( 0 0$2 ) ;
7898: LD_INT 70
7900: PPUSH
7901: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) do
7905: LD_ADDR_VAR 0 1
7909: PUSH
7910: LD_INT 22
7912: PUSH
7913: LD_INT 1
7915: PUSH
7916: EMPTY
7917: LIST
7918: LIST
7919: PUSH
7920: LD_INT 25
7922: PUSH
7923: LD_INT 1
7925: PUSH
7926: EMPTY
7927: LIST
7928: LIST
7929: PUSH
7930: EMPTY
7931: LIST
7932: LIST
7933: PPUSH
7934: CALL_OW 69
7938: PUSH
7939: FOR_IN
7940: IFFALSE 7979
// begin if IsInUnit ( i ) then
7942: LD_VAR 0 1
7946: PPUSH
7947: CALL_OW 310
7951: IFFALSE 7962
// ComExitBuilding ( i ) ;
7953: LD_VAR 0 1
7957: PPUSH
7958: CALL_OW 122
// AddComAgressiveMove ( i , 92 , 78 ) ;
7962: LD_VAR 0 1
7966: PPUSH
7967: LD_INT 92
7969: PPUSH
7970: LD_INT 78
7972: PPUSH
7973: CALL_OW 174
// end ;
7977: GO 7939
7979: POP
7980: POP
// end ; end_of_file
7981: PPOPN 1
7983: END
// on SiberiteRocketExploded ( sibRocket , x , y ) do OnBombExploded ( sibRocket , x , y ) ;
7984: LD_VAR 0 1
7988: PPUSH
7989: LD_VAR 0 2
7993: PPUSH
7994: LD_VAR 0 3
7998: PPUSH
7999: CALL 2839 0 3
8003: PPOPN 3
8005: END
// on UnitGoesToRed ( un ) do begin if GetClass ( JMM ) = 4 or GetClass ( Burlak ) = 4 then
8006: LD_EXP 14
8010: PPUSH
8011: CALL_OW 257
8015: PUSH
8016: LD_INT 4
8018: EQUAL
8019: PUSH
8020: LD_EXP 15
8024: PPUSH
8025: CALL_OW 257
8029: PUSH
8030: LD_INT 4
8032: EQUAL
8033: OR
8034: IFFALSE 8038
// exit ;
8036: GO 8076
// if un = JMM then
8038: LD_VAR 0 1
8042: PUSH
8043: LD_EXP 14
8047: EQUAL
8048: IFFALSE 8057
// YouLost ( JMM ) ;
8050: LD_STRING JMM
8052: PPUSH
8053: CALL_OW 104
// if un = Burlak then
8057: LD_VAR 0 1
8061: PUSH
8062: LD_EXP 15
8066: EQUAL
8067: IFFALSE 8076
// YouLost ( Burlak ) ;
8069: LD_STRING Burlak
8071: PPUSH
8072: CALL_OW 104
// end ;
8076: PPOPN 1
8078: END
// on UnitDestroyed ( un ) do begin if un = JMM then
8079: LD_VAR 0 1
8083: PUSH
8084: LD_EXP 14
8088: EQUAL
8089: IFFALSE 8098
// YouLost ( JMM ) ;
8091: LD_STRING JMM
8093: PPUSH
8094: CALL_OW 104
// if un = Burlak then
8098: LD_VAR 0 1
8102: PUSH
8103: LD_EXP 15
8107: EQUAL
8108: IFFALSE 8117
// YouLost ( Burlak ) ;
8110: LD_STRING Burlak
8112: PPUSH
8113: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
8117: LD_VAR 0 1
8121: PUSH
8122: LD_INT 21
8124: PUSH
8125: LD_INT 1
8127: PUSH
8128: EMPTY
8129: LIST
8130: LIST
8131: PUSH
8132: LD_INT 23
8134: PUSH
8135: LD_INT 1
8137: PUSH
8138: EMPTY
8139: LIST
8140: LIST
8141: PUSH
8142: EMPTY
8143: LIST
8144: LIST
8145: PPUSH
8146: CALL_OW 69
8150: IN
8151: IFFALSE 8167
// killCounter := killCounter + 1 ;
8153: LD_ADDR_EXP 12
8157: PUSH
8158: LD_EXP 12
8162: PUSH
8163: LD_INT 1
8165: PLUS
8166: ST_TO_ADDR
// end ;
8167: PPOPN 1
8169: END
// on UnitDestroyed_Extra ( un , killer_side , killer_unit ) do begin if killer_side = 7 and un in FilterAllUnits ( [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
8170: LD_VAR 0 2
8174: PUSH
8175: LD_INT 7
8177: EQUAL
8178: PUSH
8179: LD_VAR 0 1
8183: PUSH
8184: LD_INT 2
8186: PUSH
8187: LD_INT 30
8189: PUSH
8190: LD_INT 31
8192: PUSH
8193: EMPTY
8194: LIST
8195: LIST
8196: PUSH
8197: LD_INT 30
8199: PUSH
8200: LD_INT 32
8202: PUSH
8203: EMPTY
8204: LIST
8205: LIST
8206: PUSH
8207: LD_INT 30
8209: PUSH
8210: LD_INT 33
8212: PUSH
8213: EMPTY
8214: LIST
8215: LIST
8216: PUSH
8217: EMPTY
8218: LIST
8219: LIST
8220: LIST
8221: LIST
8222: PPUSH
8223: CALL_OW 69
8227: IN
8228: AND
8229: IFFALSE 8245
// bunkerCounter := bunkerCounter + 1 ;
8231: LD_ADDR_EXP 13
8235: PUSH
8236: LD_EXP 13
8240: PUSH
8241: LD_INT 1
8243: PLUS
8244: ST_TO_ADDR
// end ;
8245: PPOPN 3
8247: END
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 7 then
8248: LD_VAR 0 1
8252: PPUSH
8253: CALL_OW 255
8257: PUSH
8258: LD_INT 7
8260: EQUAL
8261: IFFALSE 8271
// artifactPickedUp := true ;
8263: LD_ADDR_EXP 6
8267: PUSH
8268: LD_INT 1
8270: ST_TO_ADDR
// end ;
8271: PPOPN 2
8273: END
// on ArtifactUnloaded ( cargo , artifact ) do artifactPickedUp := false ;
8274: LD_ADDR_EXP 6
8278: PUSH
8279: LD_INT 0
8281: ST_TO_ADDR
8282: PPOPN 2
8284: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( vehicle ) <> 1 then
8285: LD_VAR 0 1
8289: PPUSH
8290: CALL_OW 255
8294: PUSH
8295: LD_INT 1
8297: NONEQUAL
8298: IFFALSE 8302
// exit ;
8300: GO 8349
// wait ( 0 0$5 ) ;
8302: LD_INT 175
8304: PPUSH
8305: CALL_OW 67
// if GetControl ( vehicle ) = control_remote then
8309: LD_VAR 0 1
8313: PPUSH
8314: CALL_OW 263
8318: PUSH
8319: LD_INT 2
8321: EQUAL
8322: IFFALSE 8333
// Connect ( vehicle ) ;
8324: LD_VAR 0 1
8328: PPUSH
8329: CALL 1840 0 1
// vehGuard := vehGuard ^ vehicle ;
8333: LD_ADDR_EXP 23
8337: PUSH
8338: LD_EXP 23
8342: PUSH
8343: LD_VAR 0 1
8347: ADD
8348: ST_TO_ADDR
// end ;
8349: PPOPN 2
8351: END
// on BuildingCaptured ( captured , old_side , unit ) do begin if captured = us_lab and not planCaptured then
8352: LD_VAR 0 1
8356: PUSH
8357: LD_INT 1
8359: EQUAL
8360: PUSH
8361: LD_EXP 7
8365: NOT
8366: AND
8367: IFFALSE 8402
// begin planCaptured := true ;
8369: LD_ADDR_EXP 7
8373: PUSH
8374: LD_INT 1
8376: ST_TO_ADDR
// ChangeMissionObjectives ( MEnd ) ;
8377: LD_STRING MEnd
8379: PPUSH
8380: CALL_OW 337
// canEnd := true ;
8384: LD_ADDR_EXP 10
8388: PUSH
8389: LD_INT 1
8391: ST_TO_ADDR
// missionTime := tick ;
8392: LD_ADDR_EXP 11
8396: PUSH
8397: LD_OWVAR 1
8401: ST_TO_ADDR
// end ; end ;
8402: PPOPN 3
8404: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
8405: LD_VAR 0 1
8409: PPUSH
8410: CALL 19406 0 1
// end ; end_of_file
8414: PPOPN 1
8416: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
8417: GO 8419
8419: DISABLE
// begin ru_radar := 98 ;
8420: LD_ADDR_EXP 24
8424: PUSH
8425: LD_INT 98
8427: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
8428: LD_ADDR_EXP 25
8432: PUSH
8433: LD_INT 89
8435: ST_TO_ADDR
// us_hack := 99 ;
8436: LD_ADDR_EXP 26
8440: PUSH
8441: LD_INT 99
8443: ST_TO_ADDR
// us_artillery := 97 ;
8444: LD_ADDR_EXP 27
8448: PUSH
8449: LD_INT 97
8451: ST_TO_ADDR
// ar_bio_bomb := 91 ;
8452: LD_ADDR_EXP 28
8456: PUSH
8457: LD_INT 91
8459: ST_TO_ADDR
// end ; end_of_file end_of_file
8460: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
8461: GO 8463
8463: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
8464: LD_STRING initStreamRollete();
8466: PPUSH
8467: CALL_OW 559
// InitStreamMode ;
8471: CALL 8480 0 0
// DefineStreamItems ( ) ;
8475: CALL 8920 0 0
// end ;
8479: END
// function InitStreamMode ; begin
8480: LD_INT 0
8482: PPUSH
// streamModeActive := false ;
8483: LD_ADDR_EXP 29
8487: PUSH
8488: LD_INT 0
8490: ST_TO_ADDR
// normalCounter := 36 ;
8491: LD_ADDR_EXP 30
8495: PUSH
8496: LD_INT 36
8498: ST_TO_ADDR
// hardcoreCounter := 16 ;
8499: LD_ADDR_EXP 31
8503: PUSH
8504: LD_INT 16
8506: ST_TO_ADDR
// sRocket := false ;
8507: LD_ADDR_EXP 34
8511: PUSH
8512: LD_INT 0
8514: ST_TO_ADDR
// sSpeed := false ;
8515: LD_ADDR_EXP 33
8519: PUSH
8520: LD_INT 0
8522: ST_TO_ADDR
// sEngine := false ;
8523: LD_ADDR_EXP 35
8527: PUSH
8528: LD_INT 0
8530: ST_TO_ADDR
// sSpec := false ;
8531: LD_ADDR_EXP 32
8535: PUSH
8536: LD_INT 0
8538: ST_TO_ADDR
// sLevel := false ;
8539: LD_ADDR_EXP 36
8543: PUSH
8544: LD_INT 0
8546: ST_TO_ADDR
// sArmoury := false ;
8547: LD_ADDR_EXP 37
8551: PUSH
8552: LD_INT 0
8554: ST_TO_ADDR
// sRadar := false ;
8555: LD_ADDR_EXP 38
8559: PUSH
8560: LD_INT 0
8562: ST_TO_ADDR
// sBunker := false ;
8563: LD_ADDR_EXP 39
8567: PUSH
8568: LD_INT 0
8570: ST_TO_ADDR
// sHack := false ;
8571: LD_ADDR_EXP 40
8575: PUSH
8576: LD_INT 0
8578: ST_TO_ADDR
// sFire := false ;
8579: LD_ADDR_EXP 41
8583: PUSH
8584: LD_INT 0
8586: ST_TO_ADDR
// sRefresh := false ;
8587: LD_ADDR_EXP 42
8591: PUSH
8592: LD_INT 0
8594: ST_TO_ADDR
// sExp := false ;
8595: LD_ADDR_EXP 43
8599: PUSH
8600: LD_INT 0
8602: ST_TO_ADDR
// sDepot := false ;
8603: LD_ADDR_EXP 44
8607: PUSH
8608: LD_INT 0
8610: ST_TO_ADDR
// sFlag := false ;
8611: LD_ADDR_EXP 45
8615: PUSH
8616: LD_INT 0
8618: ST_TO_ADDR
// sKamikadze := false ;
8619: LD_ADDR_EXP 53
8623: PUSH
8624: LD_INT 0
8626: ST_TO_ADDR
// sTroll := false ;
8627: LD_ADDR_EXP 54
8631: PUSH
8632: LD_INT 0
8634: ST_TO_ADDR
// sSlow := false ;
8635: LD_ADDR_EXP 55
8639: PUSH
8640: LD_INT 0
8642: ST_TO_ADDR
// sLack := false ;
8643: LD_ADDR_EXP 56
8647: PUSH
8648: LD_INT 0
8650: ST_TO_ADDR
// sTank := false ;
8651: LD_ADDR_EXP 58
8655: PUSH
8656: LD_INT 0
8658: ST_TO_ADDR
// sRemote := false ;
8659: LD_ADDR_EXP 59
8663: PUSH
8664: LD_INT 0
8666: ST_TO_ADDR
// sPowell := false ;
8667: LD_ADDR_EXP 60
8671: PUSH
8672: LD_INT 0
8674: ST_TO_ADDR
// sTeleport := false ;
8675: LD_ADDR_EXP 63
8679: PUSH
8680: LD_INT 0
8682: ST_TO_ADDR
// sOilTower := false ;
8683: LD_ADDR_EXP 65
8687: PUSH
8688: LD_INT 0
8690: ST_TO_ADDR
// sShovel := false ;
8691: LD_ADDR_EXP 66
8695: PUSH
8696: LD_INT 0
8698: ST_TO_ADDR
// sSheik := false ;
8699: LD_ADDR_EXP 67
8703: PUSH
8704: LD_INT 0
8706: ST_TO_ADDR
// sEarthquake := false ;
8707: LD_ADDR_EXP 69
8711: PUSH
8712: LD_INT 0
8714: ST_TO_ADDR
// sAI := false ;
8715: LD_ADDR_EXP 70
8719: PUSH
8720: LD_INT 0
8722: ST_TO_ADDR
// sCargo := false ;
8723: LD_ADDR_EXP 73
8727: PUSH
8728: LD_INT 0
8730: ST_TO_ADDR
// sDLaser := false ;
8731: LD_ADDR_EXP 74
8735: PUSH
8736: LD_INT 0
8738: ST_TO_ADDR
// sExchange := false ;
8739: LD_ADDR_EXP 75
8743: PUSH
8744: LD_INT 0
8746: ST_TO_ADDR
// sFac := false ;
8747: LD_ADDR_EXP 76
8751: PUSH
8752: LD_INT 0
8754: ST_TO_ADDR
// sPower := false ;
8755: LD_ADDR_EXP 77
8759: PUSH
8760: LD_INT 0
8762: ST_TO_ADDR
// sRandom := false ;
8763: LD_ADDR_EXP 78
8767: PUSH
8768: LD_INT 0
8770: ST_TO_ADDR
// sShield := false ;
8771: LD_ADDR_EXP 79
8775: PUSH
8776: LD_INT 0
8778: ST_TO_ADDR
// sTime := false ;
8779: LD_ADDR_EXP 80
8783: PUSH
8784: LD_INT 0
8786: ST_TO_ADDR
// sTools := false ;
8787: LD_ADDR_EXP 81
8791: PUSH
8792: LD_INT 0
8794: ST_TO_ADDR
// sSold := false ;
8795: LD_ADDR_EXP 46
8799: PUSH
8800: LD_INT 0
8802: ST_TO_ADDR
// sDiff := false ;
8803: LD_ADDR_EXP 47
8807: PUSH
8808: LD_INT 0
8810: ST_TO_ADDR
// sFog := false ;
8811: LD_ADDR_EXP 50
8815: PUSH
8816: LD_INT 0
8818: ST_TO_ADDR
// sReset := false ;
8819: LD_ADDR_EXP 51
8823: PUSH
8824: LD_INT 0
8826: ST_TO_ADDR
// sSun := false ;
8827: LD_ADDR_EXP 52
8831: PUSH
8832: LD_INT 0
8834: ST_TO_ADDR
// sTiger := false ;
8835: LD_ADDR_EXP 48
8839: PUSH
8840: LD_INT 0
8842: ST_TO_ADDR
// sBomb := false ;
8843: LD_ADDR_EXP 49
8847: PUSH
8848: LD_INT 0
8850: ST_TO_ADDR
// sWound := false ;
8851: LD_ADDR_EXP 57
8855: PUSH
8856: LD_INT 0
8858: ST_TO_ADDR
// sBetray := false ;
8859: LD_ADDR_EXP 61
8863: PUSH
8864: LD_INT 0
8866: ST_TO_ADDR
// sContamin := false ;
8867: LD_ADDR_EXP 62
8871: PUSH
8872: LD_INT 0
8874: ST_TO_ADDR
// sOil := false ;
8875: LD_ADDR_EXP 64
8879: PUSH
8880: LD_INT 0
8882: ST_TO_ADDR
// sStu := false ;
8883: LD_ADDR_EXP 68
8887: PUSH
8888: LD_INT 0
8890: ST_TO_ADDR
// sBazooka := false ;
8891: LD_ADDR_EXP 71
8895: PUSH
8896: LD_INT 0
8898: ST_TO_ADDR
// sMortar := false ;
8899: LD_ADDR_EXP 72
8903: PUSH
8904: LD_INT 0
8906: ST_TO_ADDR
// sRanger := false ;
8907: LD_ADDR_EXP 82
8911: PUSH
8912: LD_INT 0
8914: ST_TO_ADDR
// end ;
8915: LD_VAR 0 1
8919: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
8920: LD_INT 0
8922: PPUSH
8923: PPUSH
8924: PPUSH
8925: PPUSH
8926: PPUSH
// result := [ ] ;
8927: LD_ADDR_VAR 0 1
8931: PUSH
8932: EMPTY
8933: ST_TO_ADDR
// if campaign_id = 1 then
8934: LD_OWVAR 69
8938: PUSH
8939: LD_INT 1
8941: EQUAL
8942: IFFALSE 11880
// begin case mission_number of 1 :
8944: LD_OWVAR 70
8948: PUSH
8949: LD_INT 1
8951: DOUBLE
8952: EQUAL
8953: IFTRUE 8957
8955: GO 9021
8957: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
8958: LD_ADDR_VAR 0 1
8962: PUSH
8963: LD_INT 2
8965: PUSH
8966: LD_INT 4
8968: PUSH
8969: LD_INT 11
8971: PUSH
8972: LD_INT 12
8974: PUSH
8975: LD_INT 15
8977: PUSH
8978: LD_INT 16
8980: PUSH
8981: LD_INT 22
8983: PUSH
8984: LD_INT 23
8986: PUSH
8987: LD_INT 26
8989: PUSH
8990: EMPTY
8991: LIST
8992: LIST
8993: LIST
8994: LIST
8995: LIST
8996: LIST
8997: LIST
8998: LIST
8999: LIST
9000: PUSH
9001: LD_INT 101
9003: PUSH
9004: LD_INT 102
9006: PUSH
9007: LD_INT 106
9009: PUSH
9010: EMPTY
9011: LIST
9012: LIST
9013: LIST
9014: PUSH
9015: EMPTY
9016: LIST
9017: LIST
9018: ST_TO_ADDR
9019: GO 11878
9021: LD_INT 2
9023: DOUBLE
9024: EQUAL
9025: IFTRUE 9029
9027: GO 9101
9029: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
9030: LD_ADDR_VAR 0 1
9034: PUSH
9035: LD_INT 2
9037: PUSH
9038: LD_INT 4
9040: PUSH
9041: LD_INT 11
9043: PUSH
9044: LD_INT 12
9046: PUSH
9047: LD_INT 15
9049: PUSH
9050: LD_INT 16
9052: PUSH
9053: LD_INT 22
9055: PUSH
9056: LD_INT 23
9058: PUSH
9059: LD_INT 26
9061: PUSH
9062: EMPTY
9063: LIST
9064: LIST
9065: LIST
9066: LIST
9067: LIST
9068: LIST
9069: LIST
9070: LIST
9071: LIST
9072: PUSH
9073: LD_INT 101
9075: PUSH
9076: LD_INT 102
9078: PUSH
9079: LD_INT 105
9081: PUSH
9082: LD_INT 106
9084: PUSH
9085: LD_INT 108
9087: PUSH
9088: EMPTY
9089: LIST
9090: LIST
9091: LIST
9092: LIST
9093: LIST
9094: PUSH
9095: EMPTY
9096: LIST
9097: LIST
9098: ST_TO_ADDR
9099: GO 11878
9101: LD_INT 3
9103: DOUBLE
9104: EQUAL
9105: IFTRUE 9109
9107: GO 9185
9109: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
9110: LD_ADDR_VAR 0 1
9114: PUSH
9115: LD_INT 2
9117: PUSH
9118: LD_INT 4
9120: PUSH
9121: LD_INT 5
9123: PUSH
9124: LD_INT 11
9126: PUSH
9127: LD_INT 12
9129: PUSH
9130: LD_INT 15
9132: PUSH
9133: LD_INT 16
9135: PUSH
9136: LD_INT 22
9138: PUSH
9139: LD_INT 26
9141: PUSH
9142: LD_INT 36
9144: PUSH
9145: EMPTY
9146: LIST
9147: LIST
9148: LIST
9149: LIST
9150: LIST
9151: LIST
9152: LIST
9153: LIST
9154: LIST
9155: LIST
9156: PUSH
9157: LD_INT 101
9159: PUSH
9160: LD_INT 102
9162: PUSH
9163: LD_INT 105
9165: PUSH
9166: LD_INT 106
9168: PUSH
9169: LD_INT 108
9171: PUSH
9172: EMPTY
9173: LIST
9174: LIST
9175: LIST
9176: LIST
9177: LIST
9178: PUSH
9179: EMPTY
9180: LIST
9181: LIST
9182: ST_TO_ADDR
9183: GO 11878
9185: LD_INT 4
9187: DOUBLE
9188: EQUAL
9189: IFTRUE 9193
9191: GO 9277
9193: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
9194: LD_ADDR_VAR 0 1
9198: PUSH
9199: LD_INT 2
9201: PUSH
9202: LD_INT 4
9204: PUSH
9205: LD_INT 5
9207: PUSH
9208: LD_INT 8
9210: PUSH
9211: LD_INT 11
9213: PUSH
9214: LD_INT 12
9216: PUSH
9217: LD_INT 15
9219: PUSH
9220: LD_INT 16
9222: PUSH
9223: LD_INT 22
9225: PUSH
9226: LD_INT 23
9228: PUSH
9229: LD_INT 26
9231: PUSH
9232: LD_INT 36
9234: PUSH
9235: EMPTY
9236: LIST
9237: LIST
9238: LIST
9239: LIST
9240: LIST
9241: LIST
9242: LIST
9243: LIST
9244: LIST
9245: LIST
9246: LIST
9247: LIST
9248: PUSH
9249: LD_INT 101
9251: PUSH
9252: LD_INT 102
9254: PUSH
9255: LD_INT 105
9257: PUSH
9258: LD_INT 106
9260: PUSH
9261: LD_INT 108
9263: PUSH
9264: EMPTY
9265: LIST
9266: LIST
9267: LIST
9268: LIST
9269: LIST
9270: PUSH
9271: EMPTY
9272: LIST
9273: LIST
9274: ST_TO_ADDR
9275: GO 11878
9277: LD_INT 5
9279: DOUBLE
9280: EQUAL
9281: IFTRUE 9285
9283: GO 9385
9285: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
9286: LD_ADDR_VAR 0 1
9290: PUSH
9291: LD_INT 2
9293: PUSH
9294: LD_INT 4
9296: PUSH
9297: LD_INT 5
9299: PUSH
9300: LD_INT 6
9302: PUSH
9303: LD_INT 8
9305: PUSH
9306: LD_INT 11
9308: PUSH
9309: LD_INT 12
9311: PUSH
9312: LD_INT 15
9314: PUSH
9315: LD_INT 16
9317: PUSH
9318: LD_INT 22
9320: PUSH
9321: LD_INT 23
9323: PUSH
9324: LD_INT 25
9326: PUSH
9327: LD_INT 26
9329: PUSH
9330: LD_INT 36
9332: PUSH
9333: EMPTY
9334: LIST
9335: LIST
9336: LIST
9337: LIST
9338: LIST
9339: LIST
9340: LIST
9341: LIST
9342: LIST
9343: LIST
9344: LIST
9345: LIST
9346: LIST
9347: LIST
9348: PUSH
9349: LD_INT 101
9351: PUSH
9352: LD_INT 102
9354: PUSH
9355: LD_INT 105
9357: PUSH
9358: LD_INT 106
9360: PUSH
9361: LD_INT 108
9363: PUSH
9364: LD_INT 109
9366: PUSH
9367: LD_INT 112
9369: PUSH
9370: EMPTY
9371: LIST
9372: LIST
9373: LIST
9374: LIST
9375: LIST
9376: LIST
9377: LIST
9378: PUSH
9379: EMPTY
9380: LIST
9381: LIST
9382: ST_TO_ADDR
9383: GO 11878
9385: LD_INT 6
9387: DOUBLE
9388: EQUAL
9389: IFTRUE 9393
9391: GO 9513
9393: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
9394: LD_ADDR_VAR 0 1
9398: PUSH
9399: LD_INT 2
9401: PUSH
9402: LD_INT 4
9404: PUSH
9405: LD_INT 5
9407: PUSH
9408: LD_INT 6
9410: PUSH
9411: LD_INT 8
9413: PUSH
9414: LD_INT 11
9416: PUSH
9417: LD_INT 12
9419: PUSH
9420: LD_INT 15
9422: PUSH
9423: LD_INT 16
9425: PUSH
9426: LD_INT 20
9428: PUSH
9429: LD_INT 21
9431: PUSH
9432: LD_INT 22
9434: PUSH
9435: LD_INT 23
9437: PUSH
9438: LD_INT 25
9440: PUSH
9441: LD_INT 26
9443: PUSH
9444: LD_INT 30
9446: PUSH
9447: LD_INT 31
9449: PUSH
9450: LD_INT 32
9452: PUSH
9453: LD_INT 36
9455: PUSH
9456: EMPTY
9457: LIST
9458: LIST
9459: LIST
9460: LIST
9461: LIST
9462: LIST
9463: LIST
9464: LIST
9465: LIST
9466: LIST
9467: LIST
9468: LIST
9469: LIST
9470: LIST
9471: LIST
9472: LIST
9473: LIST
9474: LIST
9475: LIST
9476: PUSH
9477: LD_INT 101
9479: PUSH
9480: LD_INT 102
9482: PUSH
9483: LD_INT 105
9485: PUSH
9486: LD_INT 106
9488: PUSH
9489: LD_INT 108
9491: PUSH
9492: LD_INT 109
9494: PUSH
9495: LD_INT 112
9497: PUSH
9498: EMPTY
9499: LIST
9500: LIST
9501: LIST
9502: LIST
9503: LIST
9504: LIST
9505: LIST
9506: PUSH
9507: EMPTY
9508: LIST
9509: LIST
9510: ST_TO_ADDR
9511: GO 11878
9513: LD_INT 7
9515: DOUBLE
9516: EQUAL
9517: IFTRUE 9521
9519: GO 9621
9521: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
9522: LD_ADDR_VAR 0 1
9526: PUSH
9527: LD_INT 2
9529: PUSH
9530: LD_INT 4
9532: PUSH
9533: LD_INT 5
9535: PUSH
9536: LD_INT 7
9538: PUSH
9539: LD_INT 11
9541: PUSH
9542: LD_INT 12
9544: PUSH
9545: LD_INT 15
9547: PUSH
9548: LD_INT 16
9550: PUSH
9551: LD_INT 20
9553: PUSH
9554: LD_INT 21
9556: PUSH
9557: LD_INT 22
9559: PUSH
9560: LD_INT 23
9562: PUSH
9563: LD_INT 25
9565: PUSH
9566: LD_INT 26
9568: PUSH
9569: EMPTY
9570: LIST
9571: LIST
9572: LIST
9573: LIST
9574: LIST
9575: LIST
9576: LIST
9577: LIST
9578: LIST
9579: LIST
9580: LIST
9581: LIST
9582: LIST
9583: LIST
9584: PUSH
9585: LD_INT 101
9587: PUSH
9588: LD_INT 102
9590: PUSH
9591: LD_INT 103
9593: PUSH
9594: LD_INT 105
9596: PUSH
9597: LD_INT 106
9599: PUSH
9600: LD_INT 108
9602: PUSH
9603: LD_INT 112
9605: PUSH
9606: EMPTY
9607: LIST
9608: LIST
9609: LIST
9610: LIST
9611: LIST
9612: LIST
9613: LIST
9614: PUSH
9615: EMPTY
9616: LIST
9617: LIST
9618: ST_TO_ADDR
9619: GO 11878
9621: LD_INT 8
9623: DOUBLE
9624: EQUAL
9625: IFTRUE 9629
9627: GO 9757
9629: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
9630: LD_ADDR_VAR 0 1
9634: PUSH
9635: LD_INT 2
9637: PUSH
9638: LD_INT 4
9640: PUSH
9641: LD_INT 5
9643: PUSH
9644: LD_INT 6
9646: PUSH
9647: LD_INT 7
9649: PUSH
9650: LD_INT 8
9652: PUSH
9653: LD_INT 11
9655: PUSH
9656: LD_INT 12
9658: PUSH
9659: LD_INT 15
9661: PUSH
9662: LD_INT 16
9664: PUSH
9665: LD_INT 20
9667: PUSH
9668: LD_INT 21
9670: PUSH
9671: LD_INT 22
9673: PUSH
9674: LD_INT 23
9676: PUSH
9677: LD_INT 25
9679: PUSH
9680: LD_INT 26
9682: PUSH
9683: LD_INT 30
9685: PUSH
9686: LD_INT 31
9688: PUSH
9689: LD_INT 32
9691: PUSH
9692: LD_INT 36
9694: PUSH
9695: EMPTY
9696: LIST
9697: LIST
9698: LIST
9699: LIST
9700: LIST
9701: LIST
9702: LIST
9703: LIST
9704: LIST
9705: LIST
9706: LIST
9707: LIST
9708: LIST
9709: LIST
9710: LIST
9711: LIST
9712: LIST
9713: LIST
9714: LIST
9715: LIST
9716: PUSH
9717: LD_INT 101
9719: PUSH
9720: LD_INT 102
9722: PUSH
9723: LD_INT 103
9725: PUSH
9726: LD_INT 105
9728: PUSH
9729: LD_INT 106
9731: PUSH
9732: LD_INT 108
9734: PUSH
9735: LD_INT 109
9737: PUSH
9738: LD_INT 112
9740: PUSH
9741: EMPTY
9742: LIST
9743: LIST
9744: LIST
9745: LIST
9746: LIST
9747: LIST
9748: LIST
9749: LIST
9750: PUSH
9751: EMPTY
9752: LIST
9753: LIST
9754: ST_TO_ADDR
9755: GO 11878
9757: LD_INT 9
9759: DOUBLE
9760: EQUAL
9761: IFTRUE 9765
9763: GO 9901
9765: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
9766: LD_ADDR_VAR 0 1
9770: PUSH
9771: LD_INT 2
9773: PUSH
9774: LD_INT 4
9776: PUSH
9777: LD_INT 5
9779: PUSH
9780: LD_INT 6
9782: PUSH
9783: LD_INT 7
9785: PUSH
9786: LD_INT 8
9788: PUSH
9789: LD_INT 11
9791: PUSH
9792: LD_INT 12
9794: PUSH
9795: LD_INT 15
9797: PUSH
9798: LD_INT 16
9800: PUSH
9801: LD_INT 20
9803: PUSH
9804: LD_INT 21
9806: PUSH
9807: LD_INT 22
9809: PUSH
9810: LD_INT 23
9812: PUSH
9813: LD_INT 25
9815: PUSH
9816: LD_INT 26
9818: PUSH
9819: LD_INT 28
9821: PUSH
9822: LD_INT 30
9824: PUSH
9825: LD_INT 31
9827: PUSH
9828: LD_INT 32
9830: PUSH
9831: LD_INT 36
9833: PUSH
9834: EMPTY
9835: LIST
9836: LIST
9837: LIST
9838: LIST
9839: LIST
9840: LIST
9841: LIST
9842: LIST
9843: LIST
9844: LIST
9845: LIST
9846: LIST
9847: LIST
9848: LIST
9849: LIST
9850: LIST
9851: LIST
9852: LIST
9853: LIST
9854: LIST
9855: LIST
9856: PUSH
9857: LD_INT 101
9859: PUSH
9860: LD_INT 102
9862: PUSH
9863: LD_INT 103
9865: PUSH
9866: LD_INT 105
9868: PUSH
9869: LD_INT 106
9871: PUSH
9872: LD_INT 108
9874: PUSH
9875: LD_INT 109
9877: PUSH
9878: LD_INT 112
9880: PUSH
9881: LD_INT 114
9883: PUSH
9884: EMPTY
9885: LIST
9886: LIST
9887: LIST
9888: LIST
9889: LIST
9890: LIST
9891: LIST
9892: LIST
9893: LIST
9894: PUSH
9895: EMPTY
9896: LIST
9897: LIST
9898: ST_TO_ADDR
9899: GO 11878
9901: LD_INT 10
9903: DOUBLE
9904: EQUAL
9905: IFTRUE 9909
9907: GO 10093
9909: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
9910: LD_ADDR_VAR 0 1
9914: PUSH
9915: LD_INT 2
9917: PUSH
9918: LD_INT 4
9920: PUSH
9921: LD_INT 5
9923: PUSH
9924: LD_INT 6
9926: PUSH
9927: LD_INT 7
9929: PUSH
9930: LD_INT 8
9932: PUSH
9933: LD_INT 9
9935: PUSH
9936: LD_INT 10
9938: PUSH
9939: LD_INT 11
9941: PUSH
9942: LD_INT 12
9944: PUSH
9945: LD_INT 13
9947: PUSH
9948: LD_INT 14
9950: PUSH
9951: LD_INT 15
9953: PUSH
9954: LD_INT 16
9956: PUSH
9957: LD_INT 17
9959: PUSH
9960: LD_INT 18
9962: PUSH
9963: LD_INT 19
9965: PUSH
9966: LD_INT 20
9968: PUSH
9969: LD_INT 21
9971: PUSH
9972: LD_INT 22
9974: PUSH
9975: LD_INT 23
9977: PUSH
9978: LD_INT 24
9980: PUSH
9981: LD_INT 25
9983: PUSH
9984: LD_INT 26
9986: PUSH
9987: LD_INT 28
9989: PUSH
9990: LD_INT 30
9992: PUSH
9993: LD_INT 31
9995: PUSH
9996: LD_INT 32
9998: PUSH
9999: LD_INT 36
10001: PUSH
10002: EMPTY
10003: LIST
10004: LIST
10005: LIST
10006: LIST
10007: LIST
10008: LIST
10009: LIST
10010: LIST
10011: LIST
10012: LIST
10013: LIST
10014: LIST
10015: LIST
10016: LIST
10017: LIST
10018: LIST
10019: LIST
10020: LIST
10021: LIST
10022: LIST
10023: LIST
10024: LIST
10025: LIST
10026: LIST
10027: LIST
10028: LIST
10029: LIST
10030: LIST
10031: LIST
10032: PUSH
10033: LD_INT 101
10035: PUSH
10036: LD_INT 102
10038: PUSH
10039: LD_INT 103
10041: PUSH
10042: LD_INT 104
10044: PUSH
10045: LD_INT 105
10047: PUSH
10048: LD_INT 106
10050: PUSH
10051: LD_INT 107
10053: PUSH
10054: LD_INT 108
10056: PUSH
10057: LD_INT 109
10059: PUSH
10060: LD_INT 110
10062: PUSH
10063: LD_INT 111
10065: PUSH
10066: LD_INT 112
10068: PUSH
10069: LD_INT 114
10071: PUSH
10072: EMPTY
10073: LIST
10074: LIST
10075: LIST
10076: LIST
10077: LIST
10078: LIST
10079: LIST
10080: LIST
10081: LIST
10082: LIST
10083: LIST
10084: LIST
10085: LIST
10086: PUSH
10087: EMPTY
10088: LIST
10089: LIST
10090: ST_TO_ADDR
10091: GO 11878
10093: LD_INT 11
10095: DOUBLE
10096: EQUAL
10097: IFTRUE 10101
10099: GO 10293
10101: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
10102: LD_ADDR_VAR 0 1
10106: PUSH
10107: LD_INT 2
10109: PUSH
10110: LD_INT 3
10112: PUSH
10113: LD_INT 4
10115: PUSH
10116: LD_INT 5
10118: PUSH
10119: LD_INT 6
10121: PUSH
10122: LD_INT 7
10124: PUSH
10125: LD_INT 8
10127: PUSH
10128: LD_INT 9
10130: PUSH
10131: LD_INT 10
10133: PUSH
10134: LD_INT 11
10136: PUSH
10137: LD_INT 12
10139: PUSH
10140: LD_INT 13
10142: PUSH
10143: LD_INT 14
10145: PUSH
10146: LD_INT 15
10148: PUSH
10149: LD_INT 16
10151: PUSH
10152: LD_INT 17
10154: PUSH
10155: LD_INT 18
10157: PUSH
10158: LD_INT 19
10160: PUSH
10161: LD_INT 20
10163: PUSH
10164: LD_INT 21
10166: PUSH
10167: LD_INT 22
10169: PUSH
10170: LD_INT 23
10172: PUSH
10173: LD_INT 24
10175: PUSH
10176: LD_INT 25
10178: PUSH
10179: LD_INT 26
10181: PUSH
10182: LD_INT 28
10184: PUSH
10185: LD_INT 30
10187: PUSH
10188: LD_INT 31
10190: PUSH
10191: LD_INT 32
10193: PUSH
10194: LD_INT 34
10196: PUSH
10197: LD_INT 36
10199: PUSH
10200: EMPTY
10201: LIST
10202: LIST
10203: LIST
10204: LIST
10205: LIST
10206: LIST
10207: LIST
10208: LIST
10209: LIST
10210: LIST
10211: LIST
10212: LIST
10213: LIST
10214: LIST
10215: LIST
10216: LIST
10217: LIST
10218: LIST
10219: LIST
10220: LIST
10221: LIST
10222: LIST
10223: LIST
10224: LIST
10225: LIST
10226: LIST
10227: LIST
10228: LIST
10229: LIST
10230: LIST
10231: LIST
10232: PUSH
10233: LD_INT 101
10235: PUSH
10236: LD_INT 102
10238: PUSH
10239: LD_INT 103
10241: PUSH
10242: LD_INT 104
10244: PUSH
10245: LD_INT 105
10247: PUSH
10248: LD_INT 106
10250: PUSH
10251: LD_INT 107
10253: PUSH
10254: LD_INT 108
10256: PUSH
10257: LD_INT 109
10259: PUSH
10260: LD_INT 110
10262: PUSH
10263: LD_INT 111
10265: PUSH
10266: LD_INT 112
10268: PUSH
10269: LD_INT 114
10271: PUSH
10272: EMPTY
10273: LIST
10274: LIST
10275: LIST
10276: LIST
10277: LIST
10278: LIST
10279: LIST
10280: LIST
10281: LIST
10282: LIST
10283: LIST
10284: LIST
10285: LIST
10286: PUSH
10287: EMPTY
10288: LIST
10289: LIST
10290: ST_TO_ADDR
10291: GO 11878
10293: LD_INT 12
10295: DOUBLE
10296: EQUAL
10297: IFTRUE 10301
10299: GO 10509
10301: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
10302: LD_ADDR_VAR 0 1
10306: PUSH
10307: LD_INT 1
10309: PUSH
10310: LD_INT 2
10312: PUSH
10313: LD_INT 3
10315: PUSH
10316: LD_INT 4
10318: PUSH
10319: LD_INT 5
10321: PUSH
10322: LD_INT 6
10324: PUSH
10325: LD_INT 7
10327: PUSH
10328: LD_INT 8
10330: PUSH
10331: LD_INT 9
10333: PUSH
10334: LD_INT 10
10336: PUSH
10337: LD_INT 11
10339: PUSH
10340: LD_INT 12
10342: PUSH
10343: LD_INT 13
10345: PUSH
10346: LD_INT 14
10348: PUSH
10349: LD_INT 15
10351: PUSH
10352: LD_INT 16
10354: PUSH
10355: LD_INT 17
10357: PUSH
10358: LD_INT 18
10360: PUSH
10361: LD_INT 19
10363: PUSH
10364: LD_INT 20
10366: PUSH
10367: LD_INT 21
10369: PUSH
10370: LD_INT 22
10372: PUSH
10373: LD_INT 23
10375: PUSH
10376: LD_INT 24
10378: PUSH
10379: LD_INT 25
10381: PUSH
10382: LD_INT 26
10384: PUSH
10385: LD_INT 27
10387: PUSH
10388: LD_INT 28
10390: PUSH
10391: LD_INT 30
10393: PUSH
10394: LD_INT 31
10396: PUSH
10397: LD_INT 32
10399: PUSH
10400: LD_INT 33
10402: PUSH
10403: LD_INT 34
10405: PUSH
10406: LD_INT 36
10408: PUSH
10409: EMPTY
10410: LIST
10411: LIST
10412: LIST
10413: LIST
10414: LIST
10415: LIST
10416: LIST
10417: LIST
10418: LIST
10419: LIST
10420: LIST
10421: LIST
10422: LIST
10423: LIST
10424: LIST
10425: LIST
10426: LIST
10427: LIST
10428: LIST
10429: LIST
10430: LIST
10431: LIST
10432: LIST
10433: LIST
10434: LIST
10435: LIST
10436: LIST
10437: LIST
10438: LIST
10439: LIST
10440: LIST
10441: LIST
10442: LIST
10443: LIST
10444: PUSH
10445: LD_INT 101
10447: PUSH
10448: LD_INT 102
10450: PUSH
10451: LD_INT 103
10453: PUSH
10454: LD_INT 104
10456: PUSH
10457: LD_INT 105
10459: PUSH
10460: LD_INT 106
10462: PUSH
10463: LD_INT 107
10465: PUSH
10466: LD_INT 108
10468: PUSH
10469: LD_INT 109
10471: PUSH
10472: LD_INT 110
10474: PUSH
10475: LD_INT 111
10477: PUSH
10478: LD_INT 112
10480: PUSH
10481: LD_INT 113
10483: PUSH
10484: LD_INT 114
10486: PUSH
10487: EMPTY
10488: LIST
10489: LIST
10490: LIST
10491: LIST
10492: LIST
10493: LIST
10494: LIST
10495: LIST
10496: LIST
10497: LIST
10498: LIST
10499: LIST
10500: LIST
10501: LIST
10502: PUSH
10503: EMPTY
10504: LIST
10505: LIST
10506: ST_TO_ADDR
10507: GO 11878
10509: LD_INT 13
10511: DOUBLE
10512: EQUAL
10513: IFTRUE 10517
10515: GO 10713
10517: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
10518: LD_ADDR_VAR 0 1
10522: PUSH
10523: LD_INT 1
10525: PUSH
10526: LD_INT 2
10528: PUSH
10529: LD_INT 3
10531: PUSH
10532: LD_INT 4
10534: PUSH
10535: LD_INT 5
10537: PUSH
10538: LD_INT 8
10540: PUSH
10541: LD_INT 9
10543: PUSH
10544: LD_INT 10
10546: PUSH
10547: LD_INT 11
10549: PUSH
10550: LD_INT 12
10552: PUSH
10553: LD_INT 14
10555: PUSH
10556: LD_INT 15
10558: PUSH
10559: LD_INT 16
10561: PUSH
10562: LD_INT 17
10564: PUSH
10565: LD_INT 18
10567: PUSH
10568: LD_INT 19
10570: PUSH
10571: LD_INT 20
10573: PUSH
10574: LD_INT 21
10576: PUSH
10577: LD_INT 22
10579: PUSH
10580: LD_INT 23
10582: PUSH
10583: LD_INT 24
10585: PUSH
10586: LD_INT 25
10588: PUSH
10589: LD_INT 26
10591: PUSH
10592: LD_INT 27
10594: PUSH
10595: LD_INT 28
10597: PUSH
10598: LD_INT 30
10600: PUSH
10601: LD_INT 31
10603: PUSH
10604: LD_INT 32
10606: PUSH
10607: LD_INT 33
10609: PUSH
10610: LD_INT 34
10612: PUSH
10613: LD_INT 36
10615: PUSH
10616: EMPTY
10617: LIST
10618: LIST
10619: LIST
10620: LIST
10621: LIST
10622: LIST
10623: LIST
10624: LIST
10625: LIST
10626: LIST
10627: LIST
10628: LIST
10629: LIST
10630: LIST
10631: LIST
10632: LIST
10633: LIST
10634: LIST
10635: LIST
10636: LIST
10637: LIST
10638: LIST
10639: LIST
10640: LIST
10641: LIST
10642: LIST
10643: LIST
10644: LIST
10645: LIST
10646: LIST
10647: LIST
10648: PUSH
10649: LD_INT 101
10651: PUSH
10652: LD_INT 102
10654: PUSH
10655: LD_INT 103
10657: PUSH
10658: LD_INT 104
10660: PUSH
10661: LD_INT 105
10663: PUSH
10664: LD_INT 106
10666: PUSH
10667: LD_INT 107
10669: PUSH
10670: LD_INT 108
10672: PUSH
10673: LD_INT 109
10675: PUSH
10676: LD_INT 110
10678: PUSH
10679: LD_INT 111
10681: PUSH
10682: LD_INT 112
10684: PUSH
10685: LD_INT 113
10687: PUSH
10688: LD_INT 114
10690: PUSH
10691: EMPTY
10692: LIST
10693: LIST
10694: LIST
10695: LIST
10696: LIST
10697: LIST
10698: LIST
10699: LIST
10700: LIST
10701: LIST
10702: LIST
10703: LIST
10704: LIST
10705: LIST
10706: PUSH
10707: EMPTY
10708: LIST
10709: LIST
10710: ST_TO_ADDR
10711: GO 11878
10713: LD_INT 14
10715: DOUBLE
10716: EQUAL
10717: IFTRUE 10721
10719: GO 10933
10721: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
10722: LD_ADDR_VAR 0 1
10726: PUSH
10727: LD_INT 1
10729: PUSH
10730: LD_INT 2
10732: PUSH
10733: LD_INT 3
10735: PUSH
10736: LD_INT 4
10738: PUSH
10739: LD_INT 5
10741: PUSH
10742: LD_INT 6
10744: PUSH
10745: LD_INT 7
10747: PUSH
10748: LD_INT 8
10750: PUSH
10751: LD_INT 9
10753: PUSH
10754: LD_INT 10
10756: PUSH
10757: LD_INT 11
10759: PUSH
10760: LD_INT 12
10762: PUSH
10763: LD_INT 13
10765: PUSH
10766: LD_INT 14
10768: PUSH
10769: LD_INT 15
10771: PUSH
10772: LD_INT 16
10774: PUSH
10775: LD_INT 17
10777: PUSH
10778: LD_INT 18
10780: PUSH
10781: LD_INT 19
10783: PUSH
10784: LD_INT 20
10786: PUSH
10787: LD_INT 21
10789: PUSH
10790: LD_INT 22
10792: PUSH
10793: LD_INT 23
10795: PUSH
10796: LD_INT 24
10798: PUSH
10799: LD_INT 25
10801: PUSH
10802: LD_INT 26
10804: PUSH
10805: LD_INT 27
10807: PUSH
10808: LD_INT 28
10810: PUSH
10811: LD_INT 29
10813: PUSH
10814: LD_INT 30
10816: PUSH
10817: LD_INT 31
10819: PUSH
10820: LD_INT 32
10822: PUSH
10823: LD_INT 33
10825: PUSH
10826: LD_INT 34
10828: PUSH
10829: LD_INT 36
10831: PUSH
10832: EMPTY
10833: LIST
10834: LIST
10835: LIST
10836: LIST
10837: LIST
10838: LIST
10839: LIST
10840: LIST
10841: LIST
10842: LIST
10843: LIST
10844: LIST
10845: LIST
10846: LIST
10847: LIST
10848: LIST
10849: LIST
10850: LIST
10851: LIST
10852: LIST
10853: LIST
10854: LIST
10855: LIST
10856: LIST
10857: LIST
10858: LIST
10859: LIST
10860: LIST
10861: LIST
10862: LIST
10863: LIST
10864: LIST
10865: LIST
10866: LIST
10867: LIST
10868: PUSH
10869: LD_INT 101
10871: PUSH
10872: LD_INT 102
10874: PUSH
10875: LD_INT 103
10877: PUSH
10878: LD_INT 104
10880: PUSH
10881: LD_INT 105
10883: PUSH
10884: LD_INT 106
10886: PUSH
10887: LD_INT 107
10889: PUSH
10890: LD_INT 108
10892: PUSH
10893: LD_INT 109
10895: PUSH
10896: LD_INT 110
10898: PUSH
10899: LD_INT 111
10901: PUSH
10902: LD_INT 112
10904: PUSH
10905: LD_INT 113
10907: PUSH
10908: LD_INT 114
10910: PUSH
10911: EMPTY
10912: LIST
10913: LIST
10914: LIST
10915: LIST
10916: LIST
10917: LIST
10918: LIST
10919: LIST
10920: LIST
10921: LIST
10922: LIST
10923: LIST
10924: LIST
10925: LIST
10926: PUSH
10927: EMPTY
10928: LIST
10929: LIST
10930: ST_TO_ADDR
10931: GO 11878
10933: LD_INT 15
10935: DOUBLE
10936: EQUAL
10937: IFTRUE 10941
10939: GO 11153
10941: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
10942: LD_ADDR_VAR 0 1
10946: PUSH
10947: LD_INT 1
10949: PUSH
10950: LD_INT 2
10952: PUSH
10953: LD_INT 3
10955: PUSH
10956: LD_INT 4
10958: PUSH
10959: LD_INT 5
10961: PUSH
10962: LD_INT 6
10964: PUSH
10965: LD_INT 7
10967: PUSH
10968: LD_INT 8
10970: PUSH
10971: LD_INT 9
10973: PUSH
10974: LD_INT 10
10976: PUSH
10977: LD_INT 11
10979: PUSH
10980: LD_INT 12
10982: PUSH
10983: LD_INT 13
10985: PUSH
10986: LD_INT 14
10988: PUSH
10989: LD_INT 15
10991: PUSH
10992: LD_INT 16
10994: PUSH
10995: LD_INT 17
10997: PUSH
10998: LD_INT 18
11000: PUSH
11001: LD_INT 19
11003: PUSH
11004: LD_INT 20
11006: PUSH
11007: LD_INT 21
11009: PUSH
11010: LD_INT 22
11012: PUSH
11013: LD_INT 23
11015: PUSH
11016: LD_INT 24
11018: PUSH
11019: LD_INT 25
11021: PUSH
11022: LD_INT 26
11024: PUSH
11025: LD_INT 27
11027: PUSH
11028: LD_INT 28
11030: PUSH
11031: LD_INT 29
11033: PUSH
11034: LD_INT 30
11036: PUSH
11037: LD_INT 31
11039: PUSH
11040: LD_INT 32
11042: PUSH
11043: LD_INT 33
11045: PUSH
11046: LD_INT 34
11048: PUSH
11049: LD_INT 36
11051: PUSH
11052: EMPTY
11053: LIST
11054: LIST
11055: LIST
11056: LIST
11057: LIST
11058: LIST
11059: LIST
11060: LIST
11061: LIST
11062: LIST
11063: LIST
11064: LIST
11065: LIST
11066: LIST
11067: LIST
11068: LIST
11069: LIST
11070: LIST
11071: LIST
11072: LIST
11073: LIST
11074: LIST
11075: LIST
11076: LIST
11077: LIST
11078: LIST
11079: LIST
11080: LIST
11081: LIST
11082: LIST
11083: LIST
11084: LIST
11085: LIST
11086: LIST
11087: LIST
11088: PUSH
11089: LD_INT 101
11091: PUSH
11092: LD_INT 102
11094: PUSH
11095: LD_INT 103
11097: PUSH
11098: LD_INT 104
11100: PUSH
11101: LD_INT 105
11103: PUSH
11104: LD_INT 106
11106: PUSH
11107: LD_INT 107
11109: PUSH
11110: LD_INT 108
11112: PUSH
11113: LD_INT 109
11115: PUSH
11116: LD_INT 110
11118: PUSH
11119: LD_INT 111
11121: PUSH
11122: LD_INT 112
11124: PUSH
11125: LD_INT 113
11127: PUSH
11128: LD_INT 114
11130: PUSH
11131: EMPTY
11132: LIST
11133: LIST
11134: LIST
11135: LIST
11136: LIST
11137: LIST
11138: LIST
11139: LIST
11140: LIST
11141: LIST
11142: LIST
11143: LIST
11144: LIST
11145: LIST
11146: PUSH
11147: EMPTY
11148: LIST
11149: LIST
11150: ST_TO_ADDR
11151: GO 11878
11153: LD_INT 16
11155: DOUBLE
11156: EQUAL
11157: IFTRUE 11161
11159: GO 11285
11161: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
11162: LD_ADDR_VAR 0 1
11166: PUSH
11167: LD_INT 2
11169: PUSH
11170: LD_INT 4
11172: PUSH
11173: LD_INT 5
11175: PUSH
11176: LD_INT 7
11178: PUSH
11179: LD_INT 11
11181: PUSH
11182: LD_INT 12
11184: PUSH
11185: LD_INT 15
11187: PUSH
11188: LD_INT 16
11190: PUSH
11191: LD_INT 20
11193: PUSH
11194: LD_INT 21
11196: PUSH
11197: LD_INT 22
11199: PUSH
11200: LD_INT 23
11202: PUSH
11203: LD_INT 25
11205: PUSH
11206: LD_INT 26
11208: PUSH
11209: LD_INT 30
11211: PUSH
11212: LD_INT 31
11214: PUSH
11215: LD_INT 32
11217: PUSH
11218: LD_INT 33
11220: PUSH
11221: LD_INT 34
11223: PUSH
11224: EMPTY
11225: LIST
11226: LIST
11227: LIST
11228: LIST
11229: LIST
11230: LIST
11231: LIST
11232: LIST
11233: LIST
11234: LIST
11235: LIST
11236: LIST
11237: LIST
11238: LIST
11239: LIST
11240: LIST
11241: LIST
11242: LIST
11243: LIST
11244: PUSH
11245: LD_INT 101
11247: PUSH
11248: LD_INT 102
11250: PUSH
11251: LD_INT 103
11253: PUSH
11254: LD_INT 106
11256: PUSH
11257: LD_INT 108
11259: PUSH
11260: LD_INT 112
11262: PUSH
11263: LD_INT 113
11265: PUSH
11266: LD_INT 114
11268: PUSH
11269: EMPTY
11270: LIST
11271: LIST
11272: LIST
11273: LIST
11274: LIST
11275: LIST
11276: LIST
11277: LIST
11278: PUSH
11279: EMPTY
11280: LIST
11281: LIST
11282: ST_TO_ADDR
11283: GO 11878
11285: LD_INT 17
11287: DOUBLE
11288: EQUAL
11289: IFTRUE 11293
11291: GO 11505
11293: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
11294: LD_ADDR_VAR 0 1
11298: PUSH
11299: LD_INT 1
11301: PUSH
11302: LD_INT 2
11304: PUSH
11305: LD_INT 3
11307: PUSH
11308: LD_INT 4
11310: PUSH
11311: LD_INT 5
11313: PUSH
11314: LD_INT 6
11316: PUSH
11317: LD_INT 7
11319: PUSH
11320: LD_INT 8
11322: PUSH
11323: LD_INT 9
11325: PUSH
11326: LD_INT 10
11328: PUSH
11329: LD_INT 11
11331: PUSH
11332: LD_INT 12
11334: PUSH
11335: LD_INT 13
11337: PUSH
11338: LD_INT 14
11340: PUSH
11341: LD_INT 15
11343: PUSH
11344: LD_INT 16
11346: PUSH
11347: LD_INT 17
11349: PUSH
11350: LD_INT 18
11352: PUSH
11353: LD_INT 19
11355: PUSH
11356: LD_INT 20
11358: PUSH
11359: LD_INT 21
11361: PUSH
11362: LD_INT 22
11364: PUSH
11365: LD_INT 23
11367: PUSH
11368: LD_INT 24
11370: PUSH
11371: LD_INT 25
11373: PUSH
11374: LD_INT 26
11376: PUSH
11377: LD_INT 27
11379: PUSH
11380: LD_INT 28
11382: PUSH
11383: LD_INT 29
11385: PUSH
11386: LD_INT 30
11388: PUSH
11389: LD_INT 31
11391: PUSH
11392: LD_INT 32
11394: PUSH
11395: LD_INT 33
11397: PUSH
11398: LD_INT 34
11400: PUSH
11401: LD_INT 36
11403: PUSH
11404: EMPTY
11405: LIST
11406: LIST
11407: LIST
11408: LIST
11409: LIST
11410: LIST
11411: LIST
11412: LIST
11413: LIST
11414: LIST
11415: LIST
11416: LIST
11417: LIST
11418: LIST
11419: LIST
11420: LIST
11421: LIST
11422: LIST
11423: LIST
11424: LIST
11425: LIST
11426: LIST
11427: LIST
11428: LIST
11429: LIST
11430: LIST
11431: LIST
11432: LIST
11433: LIST
11434: LIST
11435: LIST
11436: LIST
11437: LIST
11438: LIST
11439: LIST
11440: PUSH
11441: LD_INT 101
11443: PUSH
11444: LD_INT 102
11446: PUSH
11447: LD_INT 103
11449: PUSH
11450: LD_INT 104
11452: PUSH
11453: LD_INT 105
11455: PUSH
11456: LD_INT 106
11458: PUSH
11459: LD_INT 107
11461: PUSH
11462: LD_INT 108
11464: PUSH
11465: LD_INT 109
11467: PUSH
11468: LD_INT 110
11470: PUSH
11471: LD_INT 111
11473: PUSH
11474: LD_INT 112
11476: PUSH
11477: LD_INT 113
11479: PUSH
11480: LD_INT 114
11482: PUSH
11483: EMPTY
11484: LIST
11485: LIST
11486: LIST
11487: LIST
11488: LIST
11489: LIST
11490: LIST
11491: LIST
11492: LIST
11493: LIST
11494: LIST
11495: LIST
11496: LIST
11497: LIST
11498: PUSH
11499: EMPTY
11500: LIST
11501: LIST
11502: ST_TO_ADDR
11503: GO 11878
11505: LD_INT 18
11507: DOUBLE
11508: EQUAL
11509: IFTRUE 11513
11511: GO 11649
11513: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
11514: LD_ADDR_VAR 0 1
11518: PUSH
11519: LD_INT 2
11521: PUSH
11522: LD_INT 4
11524: PUSH
11525: LD_INT 5
11527: PUSH
11528: LD_INT 7
11530: PUSH
11531: LD_INT 11
11533: PUSH
11534: LD_INT 12
11536: PUSH
11537: LD_INT 15
11539: PUSH
11540: LD_INT 16
11542: PUSH
11543: LD_INT 20
11545: PUSH
11546: LD_INT 21
11548: PUSH
11549: LD_INT 22
11551: PUSH
11552: LD_INT 23
11554: PUSH
11555: LD_INT 25
11557: PUSH
11558: LD_INT 26
11560: PUSH
11561: LD_INT 30
11563: PUSH
11564: LD_INT 31
11566: PUSH
11567: LD_INT 32
11569: PUSH
11570: LD_INT 33
11572: PUSH
11573: LD_INT 34
11575: PUSH
11576: LD_INT 35
11578: PUSH
11579: LD_INT 36
11581: PUSH
11582: EMPTY
11583: LIST
11584: LIST
11585: LIST
11586: LIST
11587: LIST
11588: LIST
11589: LIST
11590: LIST
11591: LIST
11592: LIST
11593: LIST
11594: LIST
11595: LIST
11596: LIST
11597: LIST
11598: LIST
11599: LIST
11600: LIST
11601: LIST
11602: LIST
11603: LIST
11604: PUSH
11605: LD_INT 101
11607: PUSH
11608: LD_INT 102
11610: PUSH
11611: LD_INT 103
11613: PUSH
11614: LD_INT 106
11616: PUSH
11617: LD_INT 108
11619: PUSH
11620: LD_INT 112
11622: PUSH
11623: LD_INT 113
11625: PUSH
11626: LD_INT 114
11628: PUSH
11629: LD_INT 115
11631: PUSH
11632: EMPTY
11633: LIST
11634: LIST
11635: LIST
11636: LIST
11637: LIST
11638: LIST
11639: LIST
11640: LIST
11641: LIST
11642: PUSH
11643: EMPTY
11644: LIST
11645: LIST
11646: ST_TO_ADDR
11647: GO 11878
11649: LD_INT 19
11651: DOUBLE
11652: EQUAL
11653: IFTRUE 11657
11655: GO 11877
11657: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
11658: LD_ADDR_VAR 0 1
11662: PUSH
11663: LD_INT 1
11665: PUSH
11666: LD_INT 2
11668: PUSH
11669: LD_INT 3
11671: PUSH
11672: LD_INT 4
11674: PUSH
11675: LD_INT 5
11677: PUSH
11678: LD_INT 6
11680: PUSH
11681: LD_INT 7
11683: PUSH
11684: LD_INT 8
11686: PUSH
11687: LD_INT 9
11689: PUSH
11690: LD_INT 10
11692: PUSH
11693: LD_INT 11
11695: PUSH
11696: LD_INT 12
11698: PUSH
11699: LD_INT 13
11701: PUSH
11702: LD_INT 14
11704: PUSH
11705: LD_INT 15
11707: PUSH
11708: LD_INT 16
11710: PUSH
11711: LD_INT 17
11713: PUSH
11714: LD_INT 18
11716: PUSH
11717: LD_INT 19
11719: PUSH
11720: LD_INT 20
11722: PUSH
11723: LD_INT 21
11725: PUSH
11726: LD_INT 22
11728: PUSH
11729: LD_INT 23
11731: PUSH
11732: LD_INT 24
11734: PUSH
11735: LD_INT 25
11737: PUSH
11738: LD_INT 26
11740: PUSH
11741: LD_INT 27
11743: PUSH
11744: LD_INT 28
11746: PUSH
11747: LD_INT 29
11749: PUSH
11750: LD_INT 30
11752: PUSH
11753: LD_INT 31
11755: PUSH
11756: LD_INT 32
11758: PUSH
11759: LD_INT 33
11761: PUSH
11762: LD_INT 34
11764: PUSH
11765: LD_INT 35
11767: PUSH
11768: LD_INT 36
11770: PUSH
11771: EMPTY
11772: LIST
11773: LIST
11774: LIST
11775: LIST
11776: LIST
11777: LIST
11778: LIST
11779: LIST
11780: LIST
11781: LIST
11782: LIST
11783: LIST
11784: LIST
11785: LIST
11786: LIST
11787: LIST
11788: LIST
11789: LIST
11790: LIST
11791: LIST
11792: LIST
11793: LIST
11794: LIST
11795: LIST
11796: LIST
11797: LIST
11798: LIST
11799: LIST
11800: LIST
11801: LIST
11802: LIST
11803: LIST
11804: LIST
11805: LIST
11806: LIST
11807: LIST
11808: PUSH
11809: LD_INT 101
11811: PUSH
11812: LD_INT 102
11814: PUSH
11815: LD_INT 103
11817: PUSH
11818: LD_INT 104
11820: PUSH
11821: LD_INT 105
11823: PUSH
11824: LD_INT 106
11826: PUSH
11827: LD_INT 107
11829: PUSH
11830: LD_INT 108
11832: PUSH
11833: LD_INT 109
11835: PUSH
11836: LD_INT 110
11838: PUSH
11839: LD_INT 111
11841: PUSH
11842: LD_INT 112
11844: PUSH
11845: LD_INT 113
11847: PUSH
11848: LD_INT 114
11850: PUSH
11851: LD_INT 115
11853: PUSH
11854: EMPTY
11855: LIST
11856: LIST
11857: LIST
11858: LIST
11859: LIST
11860: LIST
11861: LIST
11862: LIST
11863: LIST
11864: LIST
11865: LIST
11866: LIST
11867: LIST
11868: LIST
11869: LIST
11870: PUSH
11871: EMPTY
11872: LIST
11873: LIST
11874: ST_TO_ADDR
11875: GO 11878
11877: POP
// end else
11878: GO 11915
// if campaign_id = 5 then
11880: LD_OWVAR 69
11884: PUSH
11885: LD_INT 5
11887: EQUAL
11888: IFFALSE 11915
// begin result := [ [ 1 , 2 ] , [ 100 ] ] ;
11890: LD_ADDR_VAR 0 1
11894: PUSH
11895: LD_INT 1
11897: PUSH
11898: LD_INT 2
11900: PUSH
11901: EMPTY
11902: LIST
11903: LIST
11904: PUSH
11905: LD_INT 100
11907: PUSH
11908: EMPTY
11909: LIST
11910: PUSH
11911: EMPTY
11912: LIST
11913: LIST
11914: ST_TO_ADDR
// end ; if result then
11915: LD_VAR 0 1
11919: IFFALSE 12208
// begin normal :=  ;
11921: LD_ADDR_VAR 0 3
11925: PUSH
11926: LD_STRING 
11928: ST_TO_ADDR
// hardcore :=  ;
11929: LD_ADDR_VAR 0 4
11933: PUSH
11934: LD_STRING 
11936: ST_TO_ADDR
// for i = 1 to normalCounter do
11937: LD_ADDR_VAR 0 5
11941: PUSH
11942: DOUBLE
11943: LD_INT 1
11945: DEC
11946: ST_TO_ADDR
11947: LD_EXP 30
11951: PUSH
11952: FOR_TO
11953: IFFALSE 12054
// begin tmp := 0 ;
11955: LD_ADDR_VAR 0 2
11959: PUSH
11960: LD_STRING 0
11962: ST_TO_ADDR
// if result [ 1 ] then
11963: LD_VAR 0 1
11967: PUSH
11968: LD_INT 1
11970: ARRAY
11971: IFFALSE 12036
// if result [ 1 ] [ 1 ] = i then
11973: LD_VAR 0 1
11977: PUSH
11978: LD_INT 1
11980: ARRAY
11981: PUSH
11982: LD_INT 1
11984: ARRAY
11985: PUSH
11986: LD_VAR 0 5
11990: EQUAL
11991: IFFALSE 12036
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
11993: LD_ADDR_VAR 0 1
11997: PUSH
11998: LD_VAR 0 1
12002: PPUSH
12003: LD_INT 1
12005: PPUSH
12006: LD_VAR 0 1
12010: PUSH
12011: LD_INT 1
12013: ARRAY
12014: PPUSH
12015: LD_INT 1
12017: PPUSH
12018: CALL_OW 3
12022: PPUSH
12023: CALL_OW 1
12027: ST_TO_ADDR
// tmp := 1 ;
12028: LD_ADDR_VAR 0 2
12032: PUSH
12033: LD_STRING 1
12035: ST_TO_ADDR
// end ; normal := normal & tmp ;
12036: LD_ADDR_VAR 0 3
12040: PUSH
12041: LD_VAR 0 3
12045: PUSH
12046: LD_VAR 0 2
12050: STR
12051: ST_TO_ADDR
// end ;
12052: GO 11952
12054: POP
12055: POP
// for i = 1 to hardcoreCounter do
12056: LD_ADDR_VAR 0 5
12060: PUSH
12061: DOUBLE
12062: LD_INT 1
12064: DEC
12065: ST_TO_ADDR
12066: LD_EXP 31
12070: PUSH
12071: FOR_TO
12072: IFFALSE 12177
// begin tmp := 0 ;
12074: LD_ADDR_VAR 0 2
12078: PUSH
12079: LD_STRING 0
12081: ST_TO_ADDR
// if result [ 2 ] then
12082: LD_VAR 0 1
12086: PUSH
12087: LD_INT 2
12089: ARRAY
12090: IFFALSE 12159
// if result [ 2 ] [ 1 ] = 100 + i then
12092: LD_VAR 0 1
12096: PUSH
12097: LD_INT 2
12099: ARRAY
12100: PUSH
12101: LD_INT 1
12103: ARRAY
12104: PUSH
12105: LD_INT 100
12107: PUSH
12108: LD_VAR 0 5
12112: PLUS
12113: EQUAL
12114: IFFALSE 12159
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
12116: LD_ADDR_VAR 0 1
12120: PUSH
12121: LD_VAR 0 1
12125: PPUSH
12126: LD_INT 2
12128: PPUSH
12129: LD_VAR 0 1
12133: PUSH
12134: LD_INT 2
12136: ARRAY
12137: PPUSH
12138: LD_INT 1
12140: PPUSH
12141: CALL_OW 3
12145: PPUSH
12146: CALL_OW 1
12150: ST_TO_ADDR
// tmp := 1 ;
12151: LD_ADDR_VAR 0 2
12155: PUSH
12156: LD_STRING 1
12158: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
12159: LD_ADDR_VAR 0 4
12163: PUSH
12164: LD_VAR 0 4
12168: PUSH
12169: LD_VAR 0 2
12173: STR
12174: ST_TO_ADDR
// end ;
12175: GO 12071
12177: POP
12178: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
12179: LD_STRING getStreamItemsFromMission("
12181: PUSH
12182: LD_VAR 0 3
12186: STR
12187: PUSH
12188: LD_STRING ","
12190: STR
12191: PUSH
12192: LD_VAR 0 4
12196: STR
12197: PUSH
12198: LD_STRING ")
12200: STR
12201: PPUSH
12202: CALL_OW 559
// end else
12206: GO 12215
// ToLua ( getStreamItemsFromMission("","") ) ;
12208: LD_STRING getStreamItemsFromMission("","")
12210: PPUSH
12211: CALL_OW 559
// end ;
12215: LD_VAR 0 1
12219: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
12220: LD_VAR 0 2
12224: PUSH
12225: LD_INT 100
12227: EQUAL
12228: IFFALSE 13177
// begin if not StreamModeActive then
12230: LD_EXP 29
12234: NOT
12235: IFFALSE 12245
// StreamModeActive := true ;
12237: LD_ADDR_EXP 29
12241: PUSH
12242: LD_INT 1
12244: ST_TO_ADDR
// if p3 = 0 then
12245: LD_VAR 0 3
12249: PUSH
12250: LD_INT 0
12252: EQUAL
12253: IFFALSE 12259
// InitStreamMode ;
12255: CALL 8480 0 0
// if p3 = 1 then
12259: LD_VAR 0 3
12263: PUSH
12264: LD_INT 1
12266: EQUAL
12267: IFFALSE 12277
// sRocket := true ;
12269: LD_ADDR_EXP 34
12273: PUSH
12274: LD_INT 1
12276: ST_TO_ADDR
// if p3 = 2 then
12277: LD_VAR 0 3
12281: PUSH
12282: LD_INT 2
12284: EQUAL
12285: IFFALSE 12295
// sSpeed := true ;
12287: LD_ADDR_EXP 33
12291: PUSH
12292: LD_INT 1
12294: ST_TO_ADDR
// if p3 = 3 then
12295: LD_VAR 0 3
12299: PUSH
12300: LD_INT 3
12302: EQUAL
12303: IFFALSE 12313
// sEngine := true ;
12305: LD_ADDR_EXP 35
12309: PUSH
12310: LD_INT 1
12312: ST_TO_ADDR
// if p3 = 4 then
12313: LD_VAR 0 3
12317: PUSH
12318: LD_INT 4
12320: EQUAL
12321: IFFALSE 12331
// sSpec := true ;
12323: LD_ADDR_EXP 32
12327: PUSH
12328: LD_INT 1
12330: ST_TO_ADDR
// if p3 = 5 then
12331: LD_VAR 0 3
12335: PUSH
12336: LD_INT 5
12338: EQUAL
12339: IFFALSE 12349
// sLevel := true ;
12341: LD_ADDR_EXP 36
12345: PUSH
12346: LD_INT 1
12348: ST_TO_ADDR
// if p3 = 6 then
12349: LD_VAR 0 3
12353: PUSH
12354: LD_INT 6
12356: EQUAL
12357: IFFALSE 12367
// sArmoury := true ;
12359: LD_ADDR_EXP 37
12363: PUSH
12364: LD_INT 1
12366: ST_TO_ADDR
// if p3 = 7 then
12367: LD_VAR 0 3
12371: PUSH
12372: LD_INT 7
12374: EQUAL
12375: IFFALSE 12385
// sRadar := true ;
12377: LD_ADDR_EXP 38
12381: PUSH
12382: LD_INT 1
12384: ST_TO_ADDR
// if p3 = 8 then
12385: LD_VAR 0 3
12389: PUSH
12390: LD_INT 8
12392: EQUAL
12393: IFFALSE 12403
// sBunker := true ;
12395: LD_ADDR_EXP 39
12399: PUSH
12400: LD_INT 1
12402: ST_TO_ADDR
// if p3 = 9 then
12403: LD_VAR 0 3
12407: PUSH
12408: LD_INT 9
12410: EQUAL
12411: IFFALSE 12421
// sHack := true ;
12413: LD_ADDR_EXP 40
12417: PUSH
12418: LD_INT 1
12420: ST_TO_ADDR
// if p3 = 10 then
12421: LD_VAR 0 3
12425: PUSH
12426: LD_INT 10
12428: EQUAL
12429: IFFALSE 12439
// sFire := true ;
12431: LD_ADDR_EXP 41
12435: PUSH
12436: LD_INT 1
12438: ST_TO_ADDR
// if p3 = 11 then
12439: LD_VAR 0 3
12443: PUSH
12444: LD_INT 11
12446: EQUAL
12447: IFFALSE 12457
// sRefresh := true ;
12449: LD_ADDR_EXP 42
12453: PUSH
12454: LD_INT 1
12456: ST_TO_ADDR
// if p3 = 12 then
12457: LD_VAR 0 3
12461: PUSH
12462: LD_INT 12
12464: EQUAL
12465: IFFALSE 12475
// sExp := true ;
12467: LD_ADDR_EXP 43
12471: PUSH
12472: LD_INT 1
12474: ST_TO_ADDR
// if p3 = 13 then
12475: LD_VAR 0 3
12479: PUSH
12480: LD_INT 13
12482: EQUAL
12483: IFFALSE 12493
// sDepot := true ;
12485: LD_ADDR_EXP 44
12489: PUSH
12490: LD_INT 1
12492: ST_TO_ADDR
// if p3 = 14 then
12493: LD_VAR 0 3
12497: PUSH
12498: LD_INT 14
12500: EQUAL
12501: IFFALSE 12511
// sFlag := true ;
12503: LD_ADDR_EXP 45
12507: PUSH
12508: LD_INT 1
12510: ST_TO_ADDR
// if p3 = 15 then
12511: LD_VAR 0 3
12515: PUSH
12516: LD_INT 15
12518: EQUAL
12519: IFFALSE 12529
// sKamikadze := true ;
12521: LD_ADDR_EXP 53
12525: PUSH
12526: LD_INT 1
12528: ST_TO_ADDR
// if p3 = 16 then
12529: LD_VAR 0 3
12533: PUSH
12534: LD_INT 16
12536: EQUAL
12537: IFFALSE 12547
// sTroll := true ;
12539: LD_ADDR_EXP 54
12543: PUSH
12544: LD_INT 1
12546: ST_TO_ADDR
// if p3 = 17 then
12547: LD_VAR 0 3
12551: PUSH
12552: LD_INT 17
12554: EQUAL
12555: IFFALSE 12565
// sSlow := true ;
12557: LD_ADDR_EXP 55
12561: PUSH
12562: LD_INT 1
12564: ST_TO_ADDR
// if p3 = 18 then
12565: LD_VAR 0 3
12569: PUSH
12570: LD_INT 18
12572: EQUAL
12573: IFFALSE 12583
// sLack := true ;
12575: LD_ADDR_EXP 56
12579: PUSH
12580: LD_INT 1
12582: ST_TO_ADDR
// if p3 = 19 then
12583: LD_VAR 0 3
12587: PUSH
12588: LD_INT 19
12590: EQUAL
12591: IFFALSE 12601
// sTank := true ;
12593: LD_ADDR_EXP 58
12597: PUSH
12598: LD_INT 1
12600: ST_TO_ADDR
// if p3 = 20 then
12601: LD_VAR 0 3
12605: PUSH
12606: LD_INT 20
12608: EQUAL
12609: IFFALSE 12619
// sRemote := true ;
12611: LD_ADDR_EXP 59
12615: PUSH
12616: LD_INT 1
12618: ST_TO_ADDR
// if p3 = 21 then
12619: LD_VAR 0 3
12623: PUSH
12624: LD_INT 21
12626: EQUAL
12627: IFFALSE 12637
// sPowell := true ;
12629: LD_ADDR_EXP 60
12633: PUSH
12634: LD_INT 1
12636: ST_TO_ADDR
// if p3 = 22 then
12637: LD_VAR 0 3
12641: PUSH
12642: LD_INT 22
12644: EQUAL
12645: IFFALSE 12655
// sTeleport := true ;
12647: LD_ADDR_EXP 63
12651: PUSH
12652: LD_INT 1
12654: ST_TO_ADDR
// if p3 = 23 then
12655: LD_VAR 0 3
12659: PUSH
12660: LD_INT 23
12662: EQUAL
12663: IFFALSE 12673
// sOilTower := true ;
12665: LD_ADDR_EXP 65
12669: PUSH
12670: LD_INT 1
12672: ST_TO_ADDR
// if p3 = 24 then
12673: LD_VAR 0 3
12677: PUSH
12678: LD_INT 24
12680: EQUAL
12681: IFFALSE 12691
// sShovel := true ;
12683: LD_ADDR_EXP 66
12687: PUSH
12688: LD_INT 1
12690: ST_TO_ADDR
// if p3 = 25 then
12691: LD_VAR 0 3
12695: PUSH
12696: LD_INT 25
12698: EQUAL
12699: IFFALSE 12709
// sSheik := true ;
12701: LD_ADDR_EXP 67
12705: PUSH
12706: LD_INT 1
12708: ST_TO_ADDR
// if p3 = 26 then
12709: LD_VAR 0 3
12713: PUSH
12714: LD_INT 26
12716: EQUAL
12717: IFFALSE 12727
// sEarthquake := true ;
12719: LD_ADDR_EXP 69
12723: PUSH
12724: LD_INT 1
12726: ST_TO_ADDR
// if p3 = 27 then
12727: LD_VAR 0 3
12731: PUSH
12732: LD_INT 27
12734: EQUAL
12735: IFFALSE 12745
// sAI := true ;
12737: LD_ADDR_EXP 70
12741: PUSH
12742: LD_INT 1
12744: ST_TO_ADDR
// if p3 = 28 then
12745: LD_VAR 0 3
12749: PUSH
12750: LD_INT 28
12752: EQUAL
12753: IFFALSE 12763
// sCargo := true ;
12755: LD_ADDR_EXP 73
12759: PUSH
12760: LD_INT 1
12762: ST_TO_ADDR
// if p3 = 29 then
12763: LD_VAR 0 3
12767: PUSH
12768: LD_INT 29
12770: EQUAL
12771: IFFALSE 12781
// sDLaser := true ;
12773: LD_ADDR_EXP 74
12777: PUSH
12778: LD_INT 1
12780: ST_TO_ADDR
// if p3 = 30 then
12781: LD_VAR 0 3
12785: PUSH
12786: LD_INT 30
12788: EQUAL
12789: IFFALSE 12799
// sExchange := true ;
12791: LD_ADDR_EXP 75
12795: PUSH
12796: LD_INT 1
12798: ST_TO_ADDR
// if p3 = 31 then
12799: LD_VAR 0 3
12803: PUSH
12804: LD_INT 31
12806: EQUAL
12807: IFFALSE 12817
// sFac := true ;
12809: LD_ADDR_EXP 76
12813: PUSH
12814: LD_INT 1
12816: ST_TO_ADDR
// if p3 = 32 then
12817: LD_VAR 0 3
12821: PUSH
12822: LD_INT 32
12824: EQUAL
12825: IFFALSE 12835
// sPower := true ;
12827: LD_ADDR_EXP 77
12831: PUSH
12832: LD_INT 1
12834: ST_TO_ADDR
// if p3 = 33 then
12835: LD_VAR 0 3
12839: PUSH
12840: LD_INT 33
12842: EQUAL
12843: IFFALSE 12853
// sRandom := true ;
12845: LD_ADDR_EXP 78
12849: PUSH
12850: LD_INT 1
12852: ST_TO_ADDR
// if p3 = 34 then
12853: LD_VAR 0 3
12857: PUSH
12858: LD_INT 34
12860: EQUAL
12861: IFFALSE 12871
// sShield := true ;
12863: LD_ADDR_EXP 79
12867: PUSH
12868: LD_INT 1
12870: ST_TO_ADDR
// if p3 = 35 then
12871: LD_VAR 0 3
12875: PUSH
12876: LD_INT 35
12878: EQUAL
12879: IFFALSE 12889
// sTime := true ;
12881: LD_ADDR_EXP 80
12885: PUSH
12886: LD_INT 1
12888: ST_TO_ADDR
// if p3 = 36 then
12889: LD_VAR 0 3
12893: PUSH
12894: LD_INT 36
12896: EQUAL
12897: IFFALSE 12907
// sTools := true ;
12899: LD_ADDR_EXP 81
12903: PUSH
12904: LD_INT 1
12906: ST_TO_ADDR
// if p3 = 101 then
12907: LD_VAR 0 3
12911: PUSH
12912: LD_INT 101
12914: EQUAL
12915: IFFALSE 12925
// sSold := true ;
12917: LD_ADDR_EXP 46
12921: PUSH
12922: LD_INT 1
12924: ST_TO_ADDR
// if p3 = 102 then
12925: LD_VAR 0 3
12929: PUSH
12930: LD_INT 102
12932: EQUAL
12933: IFFALSE 12943
// sDiff := true ;
12935: LD_ADDR_EXP 47
12939: PUSH
12940: LD_INT 1
12942: ST_TO_ADDR
// if p3 = 103 then
12943: LD_VAR 0 3
12947: PUSH
12948: LD_INT 103
12950: EQUAL
12951: IFFALSE 12961
// sFog := true ;
12953: LD_ADDR_EXP 50
12957: PUSH
12958: LD_INT 1
12960: ST_TO_ADDR
// if p3 = 104 then
12961: LD_VAR 0 3
12965: PUSH
12966: LD_INT 104
12968: EQUAL
12969: IFFALSE 12979
// sReset := true ;
12971: LD_ADDR_EXP 51
12975: PUSH
12976: LD_INT 1
12978: ST_TO_ADDR
// if p3 = 105 then
12979: LD_VAR 0 3
12983: PUSH
12984: LD_INT 105
12986: EQUAL
12987: IFFALSE 12997
// sSun := true ;
12989: LD_ADDR_EXP 52
12993: PUSH
12994: LD_INT 1
12996: ST_TO_ADDR
// if p3 = 106 then
12997: LD_VAR 0 3
13001: PUSH
13002: LD_INT 106
13004: EQUAL
13005: IFFALSE 13015
// sTiger := true ;
13007: LD_ADDR_EXP 48
13011: PUSH
13012: LD_INT 1
13014: ST_TO_ADDR
// if p3 = 107 then
13015: LD_VAR 0 3
13019: PUSH
13020: LD_INT 107
13022: EQUAL
13023: IFFALSE 13033
// sBomb := true ;
13025: LD_ADDR_EXP 49
13029: PUSH
13030: LD_INT 1
13032: ST_TO_ADDR
// if p3 = 108 then
13033: LD_VAR 0 3
13037: PUSH
13038: LD_INT 108
13040: EQUAL
13041: IFFALSE 13051
// sWound := true ;
13043: LD_ADDR_EXP 57
13047: PUSH
13048: LD_INT 1
13050: ST_TO_ADDR
// if p3 = 109 then
13051: LD_VAR 0 3
13055: PUSH
13056: LD_INT 109
13058: EQUAL
13059: IFFALSE 13069
// sBetray := true ;
13061: LD_ADDR_EXP 61
13065: PUSH
13066: LD_INT 1
13068: ST_TO_ADDR
// if p3 = 110 then
13069: LD_VAR 0 3
13073: PUSH
13074: LD_INT 110
13076: EQUAL
13077: IFFALSE 13087
// sContamin := true ;
13079: LD_ADDR_EXP 62
13083: PUSH
13084: LD_INT 1
13086: ST_TO_ADDR
// if p3 = 111 then
13087: LD_VAR 0 3
13091: PUSH
13092: LD_INT 111
13094: EQUAL
13095: IFFALSE 13105
// sOil := true ;
13097: LD_ADDR_EXP 64
13101: PUSH
13102: LD_INT 1
13104: ST_TO_ADDR
// if p3 = 112 then
13105: LD_VAR 0 3
13109: PUSH
13110: LD_INT 112
13112: EQUAL
13113: IFFALSE 13123
// sStu := true ;
13115: LD_ADDR_EXP 68
13119: PUSH
13120: LD_INT 1
13122: ST_TO_ADDR
// if p3 = 113 then
13123: LD_VAR 0 3
13127: PUSH
13128: LD_INT 113
13130: EQUAL
13131: IFFALSE 13141
// sBazooka := true ;
13133: LD_ADDR_EXP 71
13137: PUSH
13138: LD_INT 1
13140: ST_TO_ADDR
// if p3 = 114 then
13141: LD_VAR 0 3
13145: PUSH
13146: LD_INT 114
13148: EQUAL
13149: IFFALSE 13159
// sMortar := true ;
13151: LD_ADDR_EXP 72
13155: PUSH
13156: LD_INT 1
13158: ST_TO_ADDR
// if p3 = 115 then
13159: LD_VAR 0 3
13163: PUSH
13164: LD_INT 115
13166: EQUAL
13167: IFFALSE 13177
// sRanger := true ;
13169: LD_ADDR_EXP 82
13173: PUSH
13174: LD_INT 1
13176: ST_TO_ADDR
// end ; end ;
13177: PPOPN 6
13179: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
13180: LD_EXP 29
13184: PUSH
13185: LD_EXP 34
13189: AND
13190: IFFALSE 13314
13192: GO 13194
13194: DISABLE
13195: LD_INT 0
13197: PPUSH
13198: PPUSH
// begin enable ;
13199: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
13200: LD_ADDR_VAR 0 2
13204: PUSH
13205: LD_INT 22
13207: PUSH
13208: LD_OWVAR 2
13212: PUSH
13213: EMPTY
13214: LIST
13215: LIST
13216: PUSH
13217: LD_INT 2
13219: PUSH
13220: LD_INT 34
13222: PUSH
13223: LD_INT 7
13225: PUSH
13226: EMPTY
13227: LIST
13228: LIST
13229: PUSH
13230: LD_INT 34
13232: PUSH
13233: LD_INT 45
13235: PUSH
13236: EMPTY
13237: LIST
13238: LIST
13239: PUSH
13240: LD_INT 34
13242: PUSH
13243: LD_INT 28
13245: PUSH
13246: EMPTY
13247: LIST
13248: LIST
13249: PUSH
13250: LD_INT 34
13252: PUSH
13253: LD_INT 47
13255: PUSH
13256: EMPTY
13257: LIST
13258: LIST
13259: PUSH
13260: EMPTY
13261: LIST
13262: LIST
13263: LIST
13264: LIST
13265: LIST
13266: PUSH
13267: EMPTY
13268: LIST
13269: LIST
13270: PPUSH
13271: CALL_OW 69
13275: ST_TO_ADDR
// if not tmp then
13276: LD_VAR 0 2
13280: NOT
13281: IFFALSE 13285
// exit ;
13283: GO 13314
// for i in tmp do
13285: LD_ADDR_VAR 0 1
13289: PUSH
13290: LD_VAR 0 2
13294: PUSH
13295: FOR_IN
13296: IFFALSE 13312
// begin SetLives ( i , 0 ) ;
13298: LD_VAR 0 1
13302: PPUSH
13303: LD_INT 0
13305: PPUSH
13306: CALL_OW 234
// end ;
13310: GO 13295
13312: POP
13313: POP
// end ;
13314: PPOPN 2
13316: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
13317: LD_EXP 29
13321: PUSH
13322: LD_EXP 35
13326: AND
13327: IFFALSE 13411
13329: GO 13331
13331: DISABLE
13332: LD_INT 0
13334: PPUSH
13335: PPUSH
// begin enable ;
13336: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
13337: LD_ADDR_VAR 0 2
13341: PUSH
13342: LD_INT 22
13344: PUSH
13345: LD_OWVAR 2
13349: PUSH
13350: EMPTY
13351: LIST
13352: LIST
13353: PUSH
13354: LD_INT 32
13356: PUSH
13357: LD_INT 3
13359: PUSH
13360: EMPTY
13361: LIST
13362: LIST
13363: PUSH
13364: EMPTY
13365: LIST
13366: LIST
13367: PPUSH
13368: CALL_OW 69
13372: ST_TO_ADDR
// if not tmp then
13373: LD_VAR 0 2
13377: NOT
13378: IFFALSE 13382
// exit ;
13380: GO 13411
// for i in tmp do
13382: LD_ADDR_VAR 0 1
13386: PUSH
13387: LD_VAR 0 2
13391: PUSH
13392: FOR_IN
13393: IFFALSE 13409
// begin SetLives ( i , 0 ) ;
13395: LD_VAR 0 1
13399: PPUSH
13400: LD_INT 0
13402: PPUSH
13403: CALL_OW 234
// end ;
13407: GO 13392
13409: POP
13410: POP
// end ;
13411: PPOPN 2
13413: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
13414: LD_EXP 29
13418: PUSH
13419: LD_EXP 32
13423: AND
13424: IFFALSE 13517
13426: GO 13428
13428: DISABLE
13429: LD_INT 0
13431: PPUSH
// begin enable ;
13432: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
13433: LD_ADDR_VAR 0 1
13437: PUSH
13438: LD_INT 22
13440: PUSH
13441: LD_OWVAR 2
13445: PUSH
13446: EMPTY
13447: LIST
13448: LIST
13449: PUSH
13450: LD_INT 2
13452: PUSH
13453: LD_INT 25
13455: PUSH
13456: LD_INT 5
13458: PUSH
13459: EMPTY
13460: LIST
13461: LIST
13462: PUSH
13463: LD_INT 25
13465: PUSH
13466: LD_INT 9
13468: PUSH
13469: EMPTY
13470: LIST
13471: LIST
13472: PUSH
13473: LD_INT 25
13475: PUSH
13476: LD_INT 8
13478: PUSH
13479: EMPTY
13480: LIST
13481: LIST
13482: PUSH
13483: EMPTY
13484: LIST
13485: LIST
13486: LIST
13487: LIST
13488: PUSH
13489: EMPTY
13490: LIST
13491: LIST
13492: PPUSH
13493: CALL_OW 69
13497: PUSH
13498: FOR_IN
13499: IFFALSE 13515
// begin SetClass ( i , 1 ) ;
13501: LD_VAR 0 1
13505: PPUSH
13506: LD_INT 1
13508: PPUSH
13509: CALL_OW 336
// end ;
13513: GO 13498
13515: POP
13516: POP
// end ;
13517: PPOPN 1
13519: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
13520: LD_EXP 29
13524: PUSH
13525: LD_EXP 33
13529: AND
13530: PUSH
13531: LD_OWVAR 65
13535: PUSH
13536: LD_INT 7
13538: LESS
13539: AND
13540: IFFALSE 13554
13542: GO 13544
13544: DISABLE
// begin enable ;
13545: ENABLE
// game_speed := 7 ;
13546: LD_ADDR_OWVAR 65
13550: PUSH
13551: LD_INT 7
13553: ST_TO_ADDR
// end ;
13554: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
13555: LD_EXP 29
13559: PUSH
13560: LD_EXP 36
13564: AND
13565: IFFALSE 13767
13567: GO 13569
13569: DISABLE
13570: LD_INT 0
13572: PPUSH
13573: PPUSH
13574: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
13575: LD_ADDR_VAR 0 3
13579: PUSH
13580: LD_INT 81
13582: PUSH
13583: LD_OWVAR 2
13587: PUSH
13588: EMPTY
13589: LIST
13590: LIST
13591: PUSH
13592: LD_INT 21
13594: PUSH
13595: LD_INT 1
13597: PUSH
13598: EMPTY
13599: LIST
13600: LIST
13601: PUSH
13602: EMPTY
13603: LIST
13604: LIST
13605: PPUSH
13606: CALL_OW 69
13610: ST_TO_ADDR
// if not tmp then
13611: LD_VAR 0 3
13615: NOT
13616: IFFALSE 13620
// exit ;
13618: GO 13767
// if tmp > 5 then
13620: LD_VAR 0 3
13624: PUSH
13625: LD_INT 5
13627: GREATER
13628: IFFALSE 13640
// k := 5 else
13630: LD_ADDR_VAR 0 2
13634: PUSH
13635: LD_INT 5
13637: ST_TO_ADDR
13638: GO 13650
// k := tmp ;
13640: LD_ADDR_VAR 0 2
13644: PUSH
13645: LD_VAR 0 3
13649: ST_TO_ADDR
// for i := 1 to k do
13650: LD_ADDR_VAR 0 1
13654: PUSH
13655: DOUBLE
13656: LD_INT 1
13658: DEC
13659: ST_TO_ADDR
13660: LD_VAR 0 2
13664: PUSH
13665: FOR_TO
13666: IFFALSE 13765
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
13668: LD_VAR 0 3
13672: PUSH
13673: LD_VAR 0 1
13677: ARRAY
13678: PPUSH
13679: LD_VAR 0 1
13683: PUSH
13684: LD_INT 4
13686: MOD
13687: PUSH
13688: LD_INT 1
13690: PLUS
13691: PPUSH
13692: CALL_OW 259
13696: PUSH
13697: LD_INT 10
13699: LESS
13700: IFFALSE 13763
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
13702: LD_VAR 0 3
13706: PUSH
13707: LD_VAR 0 1
13711: ARRAY
13712: PPUSH
13713: LD_VAR 0 1
13717: PUSH
13718: LD_INT 4
13720: MOD
13721: PUSH
13722: LD_INT 1
13724: PLUS
13725: PPUSH
13726: LD_VAR 0 3
13730: PUSH
13731: LD_VAR 0 1
13735: ARRAY
13736: PPUSH
13737: LD_VAR 0 1
13741: PUSH
13742: LD_INT 4
13744: MOD
13745: PUSH
13746: LD_INT 1
13748: PLUS
13749: PPUSH
13750: CALL_OW 259
13754: PUSH
13755: LD_INT 1
13757: PLUS
13758: PPUSH
13759: CALL_OW 237
13763: GO 13665
13765: POP
13766: POP
// end ;
13767: PPOPN 3
13769: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
13770: LD_EXP 29
13774: PUSH
13775: LD_EXP 37
13779: AND
13780: IFFALSE 13800
13782: GO 13784
13784: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
13785: LD_INT 4
13787: PPUSH
13788: LD_OWVAR 2
13792: PPUSH
13793: LD_INT 0
13795: PPUSH
13796: CALL_OW 324
13800: END
// every 0 0$1 trigger StreamModeActive and sShovel do
13801: LD_EXP 29
13805: PUSH
13806: LD_EXP 66
13810: AND
13811: IFFALSE 13831
13813: GO 13815
13815: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
13816: LD_INT 19
13818: PPUSH
13819: LD_OWVAR 2
13823: PPUSH
13824: LD_INT 0
13826: PPUSH
13827: CALL_OW 324
13831: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
13832: LD_EXP 29
13836: PUSH
13837: LD_EXP 38
13841: AND
13842: IFFALSE 13944
13844: GO 13846
13846: DISABLE
13847: LD_INT 0
13849: PPUSH
13850: PPUSH
// begin enable ;
13851: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
13852: LD_ADDR_VAR 0 2
13856: PUSH
13857: LD_INT 22
13859: PUSH
13860: LD_OWVAR 2
13864: PUSH
13865: EMPTY
13866: LIST
13867: LIST
13868: PUSH
13869: LD_INT 2
13871: PUSH
13872: LD_INT 34
13874: PUSH
13875: LD_INT 11
13877: PUSH
13878: EMPTY
13879: LIST
13880: LIST
13881: PUSH
13882: LD_INT 34
13884: PUSH
13885: LD_INT 30
13887: PUSH
13888: EMPTY
13889: LIST
13890: LIST
13891: PUSH
13892: EMPTY
13893: LIST
13894: LIST
13895: LIST
13896: PUSH
13897: EMPTY
13898: LIST
13899: LIST
13900: PPUSH
13901: CALL_OW 69
13905: ST_TO_ADDR
// if not tmp then
13906: LD_VAR 0 2
13910: NOT
13911: IFFALSE 13915
// exit ;
13913: GO 13944
// for i in tmp do
13915: LD_ADDR_VAR 0 1
13919: PUSH
13920: LD_VAR 0 2
13924: PUSH
13925: FOR_IN
13926: IFFALSE 13942
// begin SetLives ( i , 0 ) ;
13928: LD_VAR 0 1
13932: PPUSH
13933: LD_INT 0
13935: PPUSH
13936: CALL_OW 234
// end ;
13940: GO 13925
13942: POP
13943: POP
// end ;
13944: PPOPN 2
13946: END
// every 0 0$1 trigger StreamModeActive and sBunker do
13947: LD_EXP 29
13951: PUSH
13952: LD_EXP 39
13956: AND
13957: IFFALSE 13977
13959: GO 13961
13961: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
13962: LD_INT 32
13964: PPUSH
13965: LD_OWVAR 2
13969: PPUSH
13970: LD_INT 0
13972: PPUSH
13973: CALL_OW 324
13977: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
13978: LD_EXP 29
13982: PUSH
13983: LD_EXP 40
13987: AND
13988: IFFALSE 14169
13990: GO 13992
13992: DISABLE
13993: LD_INT 0
13995: PPUSH
13996: PPUSH
13997: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
13998: LD_ADDR_VAR 0 2
14002: PUSH
14003: LD_INT 22
14005: PUSH
14006: LD_OWVAR 2
14010: PUSH
14011: EMPTY
14012: LIST
14013: LIST
14014: PUSH
14015: LD_INT 33
14017: PUSH
14018: LD_INT 3
14020: PUSH
14021: EMPTY
14022: LIST
14023: LIST
14024: PUSH
14025: EMPTY
14026: LIST
14027: LIST
14028: PPUSH
14029: CALL_OW 69
14033: ST_TO_ADDR
// if not tmp then
14034: LD_VAR 0 2
14038: NOT
14039: IFFALSE 14043
// exit ;
14041: GO 14169
// side := 0 ;
14043: LD_ADDR_VAR 0 3
14047: PUSH
14048: LD_INT 0
14050: ST_TO_ADDR
// for i := 1 to 8 do
14051: LD_ADDR_VAR 0 1
14055: PUSH
14056: DOUBLE
14057: LD_INT 1
14059: DEC
14060: ST_TO_ADDR
14061: LD_INT 8
14063: PUSH
14064: FOR_TO
14065: IFFALSE 14113
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
14067: LD_OWVAR 2
14071: PUSH
14072: LD_VAR 0 1
14076: NONEQUAL
14077: PUSH
14078: LD_OWVAR 2
14082: PPUSH
14083: LD_VAR 0 1
14087: PPUSH
14088: CALL_OW 81
14092: PUSH
14093: LD_INT 2
14095: EQUAL
14096: AND
14097: IFFALSE 14111
// begin side := i ;
14099: LD_ADDR_VAR 0 3
14103: PUSH
14104: LD_VAR 0 1
14108: ST_TO_ADDR
// break ;
14109: GO 14113
// end ;
14111: GO 14064
14113: POP
14114: POP
// if not side then
14115: LD_VAR 0 3
14119: NOT
14120: IFFALSE 14124
// exit ;
14122: GO 14169
// for i := 1 to tmp do
14124: LD_ADDR_VAR 0 1
14128: PUSH
14129: DOUBLE
14130: LD_INT 1
14132: DEC
14133: ST_TO_ADDR
14134: LD_VAR 0 2
14138: PUSH
14139: FOR_TO
14140: IFFALSE 14167
// if Prob ( 60 ) then
14142: LD_INT 60
14144: PPUSH
14145: CALL_OW 13
14149: IFFALSE 14165
// SetSide ( i , side ) ;
14151: LD_VAR 0 1
14155: PPUSH
14156: LD_VAR 0 3
14160: PPUSH
14161: CALL_OW 235
14165: GO 14139
14167: POP
14168: POP
// end ;
14169: PPOPN 3
14171: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
14172: LD_EXP 29
14176: PUSH
14177: LD_EXP 42
14181: AND
14182: IFFALSE 14301
14184: GO 14186
14186: DISABLE
14187: LD_INT 0
14189: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
14190: LD_ADDR_VAR 0 1
14194: PUSH
14195: LD_INT 22
14197: PUSH
14198: LD_OWVAR 2
14202: PUSH
14203: EMPTY
14204: LIST
14205: LIST
14206: PUSH
14207: LD_INT 21
14209: PUSH
14210: LD_INT 1
14212: PUSH
14213: EMPTY
14214: LIST
14215: LIST
14216: PUSH
14217: LD_INT 3
14219: PUSH
14220: LD_INT 23
14222: PUSH
14223: LD_INT 0
14225: PUSH
14226: EMPTY
14227: LIST
14228: LIST
14229: PUSH
14230: EMPTY
14231: LIST
14232: LIST
14233: PUSH
14234: EMPTY
14235: LIST
14236: LIST
14237: LIST
14238: PPUSH
14239: CALL_OW 69
14243: PUSH
14244: FOR_IN
14245: IFFALSE 14299
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
14247: LD_VAR 0 1
14251: PPUSH
14252: CALL_OW 257
14256: PUSH
14257: LD_INT 1
14259: PUSH
14260: LD_INT 2
14262: PUSH
14263: LD_INT 3
14265: PUSH
14266: LD_INT 4
14268: PUSH
14269: EMPTY
14270: LIST
14271: LIST
14272: LIST
14273: LIST
14274: IN
14275: IFFALSE 14297
// SetClass ( un , rand ( 1 , 4 ) ) ;
14277: LD_VAR 0 1
14281: PPUSH
14282: LD_INT 1
14284: PPUSH
14285: LD_INT 4
14287: PPUSH
14288: CALL_OW 12
14292: PPUSH
14293: CALL_OW 336
14297: GO 14244
14299: POP
14300: POP
// end ;
14301: PPOPN 1
14303: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
14304: LD_EXP 29
14308: PUSH
14309: LD_EXP 41
14313: AND
14314: IFFALSE 14393
14316: GO 14318
14318: DISABLE
14319: LD_INT 0
14321: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
14322: LD_ADDR_VAR 0 1
14326: PUSH
14327: LD_INT 22
14329: PUSH
14330: LD_OWVAR 2
14334: PUSH
14335: EMPTY
14336: LIST
14337: LIST
14338: PUSH
14339: LD_INT 21
14341: PUSH
14342: LD_INT 3
14344: PUSH
14345: EMPTY
14346: LIST
14347: LIST
14348: PUSH
14349: EMPTY
14350: LIST
14351: LIST
14352: PPUSH
14353: CALL_OW 69
14357: ST_TO_ADDR
// if not tmp then
14358: LD_VAR 0 1
14362: NOT
14363: IFFALSE 14367
// exit ;
14365: GO 14393
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
14367: LD_VAR 0 1
14371: PUSH
14372: LD_INT 1
14374: PPUSH
14375: LD_VAR 0 1
14379: PPUSH
14380: CALL_OW 12
14384: ARRAY
14385: PPUSH
14386: LD_INT 100
14388: PPUSH
14389: CALL_OW 234
// end ;
14393: PPOPN 1
14395: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
14396: LD_EXP 29
14400: PUSH
14401: LD_EXP 43
14405: AND
14406: IFFALSE 14504
14408: GO 14410
14410: DISABLE
14411: LD_INT 0
14413: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
14414: LD_ADDR_VAR 0 1
14418: PUSH
14419: LD_INT 22
14421: PUSH
14422: LD_OWVAR 2
14426: PUSH
14427: EMPTY
14428: LIST
14429: LIST
14430: PUSH
14431: LD_INT 21
14433: PUSH
14434: LD_INT 1
14436: PUSH
14437: EMPTY
14438: LIST
14439: LIST
14440: PUSH
14441: EMPTY
14442: LIST
14443: LIST
14444: PPUSH
14445: CALL_OW 69
14449: ST_TO_ADDR
// if not tmp then
14450: LD_VAR 0 1
14454: NOT
14455: IFFALSE 14459
// exit ;
14457: GO 14504
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
14459: LD_VAR 0 1
14463: PUSH
14464: LD_INT 1
14466: PPUSH
14467: LD_VAR 0 1
14471: PPUSH
14472: CALL_OW 12
14476: ARRAY
14477: PPUSH
14478: LD_INT 1
14480: PPUSH
14481: LD_INT 4
14483: PPUSH
14484: CALL_OW 12
14488: PPUSH
14489: LD_INT 3000
14491: PPUSH
14492: LD_INT 9000
14494: PPUSH
14495: CALL_OW 12
14499: PPUSH
14500: CALL_OW 492
// end ;
14504: PPOPN 1
14506: END
// every 0 0$1 trigger StreamModeActive and sDepot do
14507: LD_EXP 29
14511: PUSH
14512: LD_EXP 44
14516: AND
14517: IFFALSE 14537
14519: GO 14521
14521: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
14522: LD_INT 1
14524: PPUSH
14525: LD_OWVAR 2
14529: PPUSH
14530: LD_INT 0
14532: PPUSH
14533: CALL_OW 324
14537: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
14538: LD_EXP 29
14542: PUSH
14543: LD_EXP 45
14547: AND
14548: IFFALSE 14631
14550: GO 14552
14552: DISABLE
14553: LD_INT 0
14555: PPUSH
14556: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
14557: LD_ADDR_VAR 0 2
14561: PUSH
14562: LD_INT 22
14564: PUSH
14565: LD_OWVAR 2
14569: PUSH
14570: EMPTY
14571: LIST
14572: LIST
14573: PUSH
14574: LD_INT 21
14576: PUSH
14577: LD_INT 3
14579: PUSH
14580: EMPTY
14581: LIST
14582: LIST
14583: PUSH
14584: EMPTY
14585: LIST
14586: LIST
14587: PPUSH
14588: CALL_OW 69
14592: ST_TO_ADDR
// if not tmp then
14593: LD_VAR 0 2
14597: NOT
14598: IFFALSE 14602
// exit ;
14600: GO 14631
// for i in tmp do
14602: LD_ADDR_VAR 0 1
14606: PUSH
14607: LD_VAR 0 2
14611: PUSH
14612: FOR_IN
14613: IFFALSE 14629
// SetBLevel ( i , 10 ) ;
14615: LD_VAR 0 1
14619: PPUSH
14620: LD_INT 10
14622: PPUSH
14623: CALL_OW 241
14627: GO 14612
14629: POP
14630: POP
// end ;
14631: PPOPN 2
14633: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
14634: LD_EXP 29
14638: PUSH
14639: LD_EXP 46
14643: AND
14644: IFFALSE 14755
14646: GO 14648
14648: DISABLE
14649: LD_INT 0
14651: PPUSH
14652: PPUSH
14653: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
14654: LD_ADDR_VAR 0 3
14658: PUSH
14659: LD_INT 22
14661: PUSH
14662: LD_OWVAR 2
14666: PUSH
14667: EMPTY
14668: LIST
14669: LIST
14670: PUSH
14671: LD_INT 25
14673: PUSH
14674: LD_INT 1
14676: PUSH
14677: EMPTY
14678: LIST
14679: LIST
14680: PUSH
14681: EMPTY
14682: LIST
14683: LIST
14684: PPUSH
14685: CALL_OW 69
14689: ST_TO_ADDR
// if not tmp then
14690: LD_VAR 0 3
14694: NOT
14695: IFFALSE 14699
// exit ;
14697: GO 14755
// un := tmp [ rand ( 1 , tmp ) ] ;
14699: LD_ADDR_VAR 0 2
14703: PUSH
14704: LD_VAR 0 3
14708: PUSH
14709: LD_INT 1
14711: PPUSH
14712: LD_VAR 0 3
14716: PPUSH
14717: CALL_OW 12
14721: ARRAY
14722: ST_TO_ADDR
// if Crawls ( un ) then
14723: LD_VAR 0 2
14727: PPUSH
14728: CALL_OW 318
14732: IFFALSE 14743
// ComWalk ( un ) ;
14734: LD_VAR 0 2
14738: PPUSH
14739: CALL_OW 138
// SetClass ( un , class_sniper ) ;
14743: LD_VAR 0 2
14747: PPUSH
14748: LD_INT 5
14750: PPUSH
14751: CALL_OW 336
// end ;
14755: PPOPN 3
14757: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
14758: LD_EXP 29
14762: PUSH
14763: LD_EXP 47
14767: AND
14768: PUSH
14769: LD_OWVAR 67
14773: PUSH
14774: LD_INT 3
14776: LESS
14777: AND
14778: IFFALSE 14797
14780: GO 14782
14782: DISABLE
// Difficulty := Difficulty + 1 ;
14783: LD_ADDR_OWVAR 67
14787: PUSH
14788: LD_OWVAR 67
14792: PUSH
14793: LD_INT 1
14795: PLUS
14796: ST_TO_ADDR
14797: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
14798: LD_EXP 29
14802: PUSH
14803: LD_EXP 48
14807: AND
14808: IFFALSE 14911
14810: GO 14812
14812: DISABLE
14813: LD_INT 0
14815: PPUSH
// begin for i := 1 to 5 do
14816: LD_ADDR_VAR 0 1
14820: PUSH
14821: DOUBLE
14822: LD_INT 1
14824: DEC
14825: ST_TO_ADDR
14826: LD_INT 5
14828: PUSH
14829: FOR_TO
14830: IFFALSE 14909
// begin uc_nation := nation_nature ;
14832: LD_ADDR_OWVAR 21
14836: PUSH
14837: LD_INT 0
14839: ST_TO_ADDR
// uc_side := 0 ;
14840: LD_ADDR_OWVAR 20
14844: PUSH
14845: LD_INT 0
14847: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
14848: LD_ADDR_OWVAR 29
14852: PUSH
14853: LD_INT 12
14855: PUSH
14856: LD_INT 12
14858: PUSH
14859: EMPTY
14860: LIST
14861: LIST
14862: ST_TO_ADDR
// hc_agressivity := 20 ;
14863: LD_ADDR_OWVAR 35
14867: PUSH
14868: LD_INT 20
14870: ST_TO_ADDR
// hc_class := class_tiger ;
14871: LD_ADDR_OWVAR 28
14875: PUSH
14876: LD_INT 14
14878: ST_TO_ADDR
// hc_gallery :=  ;
14879: LD_ADDR_OWVAR 33
14883: PUSH
14884: LD_STRING 
14886: ST_TO_ADDR
// hc_name :=  ;
14887: LD_ADDR_OWVAR 26
14891: PUSH
14892: LD_STRING 
14894: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
14895: CALL_OW 44
14899: PPUSH
14900: LD_INT 0
14902: PPUSH
14903: CALL_OW 51
// end ;
14907: GO 14829
14909: POP
14910: POP
// end ;
14911: PPOPN 1
14913: END
// every 0 0$1 trigger StreamModeActive and sBomb do
14914: LD_EXP 29
14918: PUSH
14919: LD_EXP 49
14923: AND
14924: IFFALSE 14933
14926: GO 14928
14928: DISABLE
// StreamSibBomb ;
14929: CALL 14934 0 0
14933: END
// export function StreamSibBomb ; var i , x , y ; begin
14934: LD_INT 0
14936: PPUSH
14937: PPUSH
14938: PPUSH
14939: PPUSH
// result := false ;
14940: LD_ADDR_VAR 0 1
14944: PUSH
14945: LD_INT 0
14947: ST_TO_ADDR
// for i := 1 to 16 do
14948: LD_ADDR_VAR 0 2
14952: PUSH
14953: DOUBLE
14954: LD_INT 1
14956: DEC
14957: ST_TO_ADDR
14958: LD_INT 16
14960: PUSH
14961: FOR_TO
14962: IFFALSE 15161
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
14964: LD_ADDR_VAR 0 3
14968: PUSH
14969: LD_INT 10
14971: PUSH
14972: LD_INT 20
14974: PUSH
14975: LD_INT 30
14977: PUSH
14978: LD_INT 40
14980: PUSH
14981: LD_INT 50
14983: PUSH
14984: LD_INT 60
14986: PUSH
14987: LD_INT 70
14989: PUSH
14990: LD_INT 80
14992: PUSH
14993: LD_INT 90
14995: PUSH
14996: LD_INT 100
14998: PUSH
14999: LD_INT 110
15001: PUSH
15002: LD_INT 120
15004: PUSH
15005: LD_INT 130
15007: PUSH
15008: LD_INT 140
15010: PUSH
15011: LD_INT 150
15013: PUSH
15014: EMPTY
15015: LIST
15016: LIST
15017: LIST
15018: LIST
15019: LIST
15020: LIST
15021: LIST
15022: LIST
15023: LIST
15024: LIST
15025: LIST
15026: LIST
15027: LIST
15028: LIST
15029: LIST
15030: PUSH
15031: LD_INT 1
15033: PPUSH
15034: LD_INT 15
15036: PPUSH
15037: CALL_OW 12
15041: ARRAY
15042: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
15043: LD_ADDR_VAR 0 4
15047: PUSH
15048: LD_INT 10
15050: PUSH
15051: LD_INT 20
15053: PUSH
15054: LD_INT 30
15056: PUSH
15057: LD_INT 40
15059: PUSH
15060: LD_INT 50
15062: PUSH
15063: LD_INT 60
15065: PUSH
15066: LD_INT 70
15068: PUSH
15069: LD_INT 80
15071: PUSH
15072: LD_INT 90
15074: PUSH
15075: LD_INT 100
15077: PUSH
15078: LD_INT 110
15080: PUSH
15081: LD_INT 120
15083: PUSH
15084: LD_INT 130
15086: PUSH
15087: LD_INT 140
15089: PUSH
15090: LD_INT 150
15092: PUSH
15093: EMPTY
15094: LIST
15095: LIST
15096: LIST
15097: LIST
15098: LIST
15099: LIST
15100: LIST
15101: LIST
15102: LIST
15103: LIST
15104: LIST
15105: LIST
15106: LIST
15107: LIST
15108: LIST
15109: PUSH
15110: LD_INT 1
15112: PPUSH
15113: LD_INT 15
15115: PPUSH
15116: CALL_OW 12
15120: ARRAY
15121: ST_TO_ADDR
// if ValidHex ( x , y ) then
15122: LD_VAR 0 3
15126: PPUSH
15127: LD_VAR 0 4
15131: PPUSH
15132: CALL_OW 488
15136: IFFALSE 15159
// begin result := [ x , y ] ;
15138: LD_ADDR_VAR 0 1
15142: PUSH
15143: LD_VAR 0 3
15147: PUSH
15148: LD_VAR 0 4
15152: PUSH
15153: EMPTY
15154: LIST
15155: LIST
15156: ST_TO_ADDR
// break ;
15157: GO 15161
// end ; end ;
15159: GO 14961
15161: POP
15162: POP
// if result then
15163: LD_VAR 0 1
15167: IFFALSE 15227
// begin ToLua ( playSibBomb() ) ;
15169: LD_STRING playSibBomb()
15171: PPUSH
15172: CALL_OW 559
// wait ( 0 0$14 ) ;
15176: LD_INT 490
15178: PPUSH
15179: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
15183: LD_VAR 0 1
15187: PUSH
15188: LD_INT 1
15190: ARRAY
15191: PPUSH
15192: LD_VAR 0 1
15196: PUSH
15197: LD_INT 2
15199: ARRAY
15200: PPUSH
15201: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
15205: LD_VAR 0 1
15209: PUSH
15210: LD_INT 1
15212: ARRAY
15213: PPUSH
15214: LD_VAR 0 1
15218: PUSH
15219: LD_INT 2
15221: ARRAY
15222: PPUSH
15223: CALL_OW 429
// end ; end ;
15227: LD_VAR 0 1
15231: RET
// every 0 0$1 trigger StreamModeActive and sReset do
15232: LD_EXP 29
15236: PUSH
15237: LD_EXP 51
15241: AND
15242: IFFALSE 15254
15244: GO 15246
15246: DISABLE
// YouLost (  ) ;
15247: LD_STRING 
15249: PPUSH
15250: CALL_OW 104
15254: END
// every 0 0$1 trigger StreamModeActive and sFog do
15255: LD_EXP 29
15259: PUSH
15260: LD_EXP 50
15264: AND
15265: IFFALSE 15279
15267: GO 15269
15269: DISABLE
// FogOff ( your_side ) ;
15270: LD_OWVAR 2
15274: PPUSH
15275: CALL_OW 344
15279: END
// every 0 0$1 trigger StreamModeActive and sSun do
15280: LD_EXP 29
15284: PUSH
15285: LD_EXP 52
15289: AND
15290: IFFALSE 15318
15292: GO 15294
15294: DISABLE
// begin solar_recharge_percent := 0 ;
15295: LD_ADDR_OWVAR 79
15299: PUSH
15300: LD_INT 0
15302: ST_TO_ADDR
// wait ( 5 5$00 ) ;
15303: LD_INT 10500
15305: PPUSH
15306: CALL_OW 67
// solar_recharge_percent := 100 ;
15310: LD_ADDR_OWVAR 79
15314: PUSH
15315: LD_INT 100
15317: ST_TO_ADDR
// end ;
15318: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
15319: LD_EXP 29
15323: PUSH
15324: LD_EXP 53
15328: AND
15329: IFFALSE 15568
15331: GO 15333
15333: DISABLE
15334: LD_INT 0
15336: PPUSH
15337: PPUSH
15338: PPUSH
// begin tmp := [ ] ;
15339: LD_ADDR_VAR 0 3
15343: PUSH
15344: EMPTY
15345: ST_TO_ADDR
// for i := 1 to 6 do
15346: LD_ADDR_VAR 0 1
15350: PUSH
15351: DOUBLE
15352: LD_INT 1
15354: DEC
15355: ST_TO_ADDR
15356: LD_INT 6
15358: PUSH
15359: FOR_TO
15360: IFFALSE 15465
// begin uc_nation := nation_nature ;
15362: LD_ADDR_OWVAR 21
15366: PUSH
15367: LD_INT 0
15369: ST_TO_ADDR
// uc_side := 0 ;
15370: LD_ADDR_OWVAR 20
15374: PUSH
15375: LD_INT 0
15377: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
15378: LD_ADDR_OWVAR 29
15382: PUSH
15383: LD_INT 12
15385: PUSH
15386: LD_INT 12
15388: PUSH
15389: EMPTY
15390: LIST
15391: LIST
15392: ST_TO_ADDR
// hc_agressivity := 20 ;
15393: LD_ADDR_OWVAR 35
15397: PUSH
15398: LD_INT 20
15400: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
15401: LD_ADDR_OWVAR 28
15405: PUSH
15406: LD_INT 17
15408: ST_TO_ADDR
// hc_gallery :=  ;
15409: LD_ADDR_OWVAR 33
15413: PUSH
15414: LD_STRING 
15416: ST_TO_ADDR
// hc_name :=  ;
15417: LD_ADDR_OWVAR 26
15421: PUSH
15422: LD_STRING 
15424: ST_TO_ADDR
// un := CreateHuman ;
15425: LD_ADDR_VAR 0 2
15429: PUSH
15430: CALL_OW 44
15434: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
15435: LD_VAR 0 2
15439: PPUSH
15440: LD_INT 1
15442: PPUSH
15443: CALL_OW 51
// tmp := tmp ^ un ;
15447: LD_ADDR_VAR 0 3
15451: PUSH
15452: LD_VAR 0 3
15456: PUSH
15457: LD_VAR 0 2
15461: ADD
15462: ST_TO_ADDR
// end ;
15463: GO 15359
15465: POP
15466: POP
// repeat wait ( 0 0$1 ) ;
15467: LD_INT 35
15469: PPUSH
15470: CALL_OW 67
// for un in tmp do
15474: LD_ADDR_VAR 0 2
15478: PUSH
15479: LD_VAR 0 3
15483: PUSH
15484: FOR_IN
15485: IFFALSE 15559
// begin if IsDead ( un ) then
15487: LD_VAR 0 2
15491: PPUSH
15492: CALL_OW 301
15496: IFFALSE 15516
// begin tmp := tmp diff un ;
15498: LD_ADDR_VAR 0 3
15502: PUSH
15503: LD_VAR 0 3
15507: PUSH
15508: LD_VAR 0 2
15512: DIFF
15513: ST_TO_ADDR
// continue ;
15514: GO 15484
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
15516: LD_VAR 0 2
15520: PPUSH
15521: LD_INT 3
15523: PUSH
15524: LD_INT 22
15526: PUSH
15527: LD_INT 0
15529: PUSH
15530: EMPTY
15531: LIST
15532: LIST
15533: PUSH
15534: EMPTY
15535: LIST
15536: LIST
15537: PPUSH
15538: CALL_OW 69
15542: PPUSH
15543: LD_VAR 0 2
15547: PPUSH
15548: CALL_OW 74
15552: PPUSH
15553: CALL_OW 115
// end ;
15557: GO 15484
15559: POP
15560: POP
// until not tmp ;
15561: LD_VAR 0 3
15565: NOT
15566: IFFALSE 15467
// end ;
15568: PPOPN 3
15570: END
// every 0 0$1 trigger StreamModeActive and sTroll do
15571: LD_EXP 29
15575: PUSH
15576: LD_EXP 54
15580: AND
15581: IFFALSE 15635
15583: GO 15585
15585: DISABLE
// begin ToLua ( displayTroll(); ) ;
15586: LD_STRING displayTroll();
15588: PPUSH
15589: CALL_OW 559
// wait ( 3 3$00 ) ;
15593: LD_INT 6300
15595: PPUSH
15596: CALL_OW 67
// ToLua ( hideTroll(); ) ;
15600: LD_STRING hideTroll();
15602: PPUSH
15603: CALL_OW 559
// wait ( 1 1$00 ) ;
15607: LD_INT 2100
15609: PPUSH
15610: CALL_OW 67
// ToLua ( displayTroll(); ) ;
15614: LD_STRING displayTroll();
15616: PPUSH
15617: CALL_OW 559
// wait ( 1 1$00 ) ;
15621: LD_INT 2100
15623: PPUSH
15624: CALL_OW 67
// ToLua ( hideTroll(); ) ;
15628: LD_STRING hideTroll();
15630: PPUSH
15631: CALL_OW 559
// end ;
15635: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
15636: LD_EXP 29
15640: PUSH
15641: LD_EXP 55
15645: AND
15646: IFFALSE 15709
15648: GO 15650
15650: DISABLE
15651: LD_INT 0
15653: PPUSH
// begin p := 0 ;
15654: LD_ADDR_VAR 0 1
15658: PUSH
15659: LD_INT 0
15661: ST_TO_ADDR
// repeat game_speed := 1 ;
15662: LD_ADDR_OWVAR 65
15666: PUSH
15667: LD_INT 1
15669: ST_TO_ADDR
// wait ( 0 0$1 ) ;
15670: LD_INT 35
15672: PPUSH
15673: CALL_OW 67
// p := p + 1 ;
15677: LD_ADDR_VAR 0 1
15681: PUSH
15682: LD_VAR 0 1
15686: PUSH
15687: LD_INT 1
15689: PLUS
15690: ST_TO_ADDR
// until p >= 60 ;
15691: LD_VAR 0 1
15695: PUSH
15696: LD_INT 60
15698: GREATEREQUAL
15699: IFFALSE 15662
// game_speed := 4 ;
15701: LD_ADDR_OWVAR 65
15705: PUSH
15706: LD_INT 4
15708: ST_TO_ADDR
// end ;
15709: PPOPN 1
15711: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
15712: LD_EXP 29
15716: PUSH
15717: LD_EXP 56
15721: AND
15722: IFFALSE 15868
15724: GO 15726
15726: DISABLE
15727: LD_INT 0
15729: PPUSH
15730: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
15731: LD_ADDR_VAR 0 1
15735: PUSH
15736: LD_INT 22
15738: PUSH
15739: LD_OWVAR 2
15743: PUSH
15744: EMPTY
15745: LIST
15746: LIST
15747: PUSH
15748: LD_INT 2
15750: PUSH
15751: LD_INT 30
15753: PUSH
15754: LD_INT 0
15756: PUSH
15757: EMPTY
15758: LIST
15759: LIST
15760: PUSH
15761: LD_INT 30
15763: PUSH
15764: LD_INT 1
15766: PUSH
15767: EMPTY
15768: LIST
15769: LIST
15770: PUSH
15771: EMPTY
15772: LIST
15773: LIST
15774: LIST
15775: PUSH
15776: EMPTY
15777: LIST
15778: LIST
15779: PPUSH
15780: CALL_OW 69
15784: ST_TO_ADDR
// if not depot then
15785: LD_VAR 0 1
15789: NOT
15790: IFFALSE 15794
// exit ;
15792: GO 15868
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
15794: LD_ADDR_VAR 0 2
15798: PUSH
15799: LD_VAR 0 1
15803: PUSH
15804: LD_INT 1
15806: PPUSH
15807: LD_VAR 0 1
15811: PPUSH
15812: CALL_OW 12
15816: ARRAY
15817: PPUSH
15818: CALL_OW 274
15822: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
15823: LD_VAR 0 2
15827: PPUSH
15828: LD_INT 1
15830: PPUSH
15831: LD_INT 0
15833: PPUSH
15834: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
15838: LD_VAR 0 2
15842: PPUSH
15843: LD_INT 2
15845: PPUSH
15846: LD_INT 0
15848: PPUSH
15849: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
15853: LD_VAR 0 2
15857: PPUSH
15858: LD_INT 3
15860: PPUSH
15861: LD_INT 0
15863: PPUSH
15864: CALL_OW 277
// end ;
15868: PPOPN 2
15870: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
15871: LD_EXP 29
15875: PUSH
15876: LD_EXP 57
15880: AND
15881: IFFALSE 15978
15883: GO 15885
15885: DISABLE
15886: LD_INT 0
15888: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
15889: LD_ADDR_VAR 0 1
15893: PUSH
15894: LD_INT 22
15896: PUSH
15897: LD_OWVAR 2
15901: PUSH
15902: EMPTY
15903: LIST
15904: LIST
15905: PUSH
15906: LD_INT 21
15908: PUSH
15909: LD_INT 1
15911: PUSH
15912: EMPTY
15913: LIST
15914: LIST
15915: PUSH
15916: LD_INT 3
15918: PUSH
15919: LD_INT 23
15921: PUSH
15922: LD_INT 0
15924: PUSH
15925: EMPTY
15926: LIST
15927: LIST
15928: PUSH
15929: EMPTY
15930: LIST
15931: LIST
15932: PUSH
15933: EMPTY
15934: LIST
15935: LIST
15936: LIST
15937: PPUSH
15938: CALL_OW 69
15942: ST_TO_ADDR
// if not tmp then
15943: LD_VAR 0 1
15947: NOT
15948: IFFALSE 15952
// exit ;
15950: GO 15978
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
15952: LD_VAR 0 1
15956: PUSH
15957: LD_INT 1
15959: PPUSH
15960: LD_VAR 0 1
15964: PPUSH
15965: CALL_OW 12
15969: ARRAY
15970: PPUSH
15971: LD_INT 200
15973: PPUSH
15974: CALL_OW 234
// end ;
15978: PPOPN 1
15980: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
15981: LD_EXP 29
15985: PUSH
15986: LD_EXP 58
15990: AND
15991: IFFALSE 16070
15993: GO 15995
15995: DISABLE
15996: LD_INT 0
15998: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
15999: LD_ADDR_VAR 0 1
16003: PUSH
16004: LD_INT 22
16006: PUSH
16007: LD_OWVAR 2
16011: PUSH
16012: EMPTY
16013: LIST
16014: LIST
16015: PUSH
16016: LD_INT 21
16018: PUSH
16019: LD_INT 2
16021: PUSH
16022: EMPTY
16023: LIST
16024: LIST
16025: PUSH
16026: EMPTY
16027: LIST
16028: LIST
16029: PPUSH
16030: CALL_OW 69
16034: ST_TO_ADDR
// if not tmp then
16035: LD_VAR 0 1
16039: NOT
16040: IFFALSE 16044
// exit ;
16042: GO 16070
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
16044: LD_VAR 0 1
16048: PUSH
16049: LD_INT 1
16051: PPUSH
16052: LD_VAR 0 1
16056: PPUSH
16057: CALL_OW 12
16061: ARRAY
16062: PPUSH
16063: LD_INT 60
16065: PPUSH
16066: CALL_OW 234
// end ;
16070: PPOPN 1
16072: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
16073: LD_EXP 29
16077: PUSH
16078: LD_EXP 59
16082: AND
16083: IFFALSE 16182
16085: GO 16087
16087: DISABLE
16088: LD_INT 0
16090: PPUSH
16091: PPUSH
// begin enable ;
16092: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
16093: LD_ADDR_VAR 0 1
16097: PUSH
16098: LD_INT 22
16100: PUSH
16101: LD_OWVAR 2
16105: PUSH
16106: EMPTY
16107: LIST
16108: LIST
16109: PUSH
16110: LD_INT 61
16112: PUSH
16113: EMPTY
16114: LIST
16115: PUSH
16116: LD_INT 33
16118: PUSH
16119: LD_INT 2
16121: PUSH
16122: EMPTY
16123: LIST
16124: LIST
16125: PUSH
16126: EMPTY
16127: LIST
16128: LIST
16129: LIST
16130: PPUSH
16131: CALL_OW 69
16135: ST_TO_ADDR
// if not tmp then
16136: LD_VAR 0 1
16140: NOT
16141: IFFALSE 16145
// exit ;
16143: GO 16182
// for i in tmp do
16145: LD_ADDR_VAR 0 2
16149: PUSH
16150: LD_VAR 0 1
16154: PUSH
16155: FOR_IN
16156: IFFALSE 16180
// if IsControledBy ( i ) then
16158: LD_VAR 0 2
16162: PPUSH
16163: CALL_OW 312
16167: IFFALSE 16178
// ComUnlink ( i ) ;
16169: LD_VAR 0 2
16173: PPUSH
16174: CALL_OW 136
16178: GO 16155
16180: POP
16181: POP
// end ;
16182: PPOPN 2
16184: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
16185: LD_EXP 29
16189: PUSH
16190: LD_EXP 60
16194: AND
16195: IFFALSE 16335
16197: GO 16199
16199: DISABLE
16200: LD_INT 0
16202: PPUSH
16203: PPUSH
// begin ToLua ( displayPowell(); ) ;
16204: LD_STRING displayPowell();
16206: PPUSH
16207: CALL_OW 559
// uc_side := 0 ;
16211: LD_ADDR_OWVAR 20
16215: PUSH
16216: LD_INT 0
16218: ST_TO_ADDR
// uc_nation := 2 ;
16219: LD_ADDR_OWVAR 21
16223: PUSH
16224: LD_INT 2
16226: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
16227: LD_ADDR_OWVAR 37
16231: PUSH
16232: LD_INT 14
16234: ST_TO_ADDR
// vc_engine := engine_siberite ;
16235: LD_ADDR_OWVAR 39
16239: PUSH
16240: LD_INT 3
16242: ST_TO_ADDR
// vc_control := control_apeman ;
16243: LD_ADDR_OWVAR 38
16247: PUSH
16248: LD_INT 5
16250: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
16251: LD_ADDR_OWVAR 40
16255: PUSH
16256: LD_INT 29
16258: ST_TO_ADDR
// un := CreateVehicle ;
16259: LD_ADDR_VAR 0 2
16263: PUSH
16264: CALL_OW 45
16268: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
16269: LD_VAR 0 2
16273: PPUSH
16274: LD_INT 1
16276: PPUSH
16277: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
16281: LD_INT 35
16283: PPUSH
16284: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
16288: LD_VAR 0 2
16292: PPUSH
16293: LD_INT 22
16295: PUSH
16296: LD_OWVAR 2
16300: PUSH
16301: EMPTY
16302: LIST
16303: LIST
16304: PPUSH
16305: CALL_OW 69
16309: PPUSH
16310: LD_VAR 0 2
16314: PPUSH
16315: CALL_OW 74
16319: PPUSH
16320: CALL_OW 115
// until IsDead ( un ) ;
16324: LD_VAR 0 2
16328: PPUSH
16329: CALL_OW 301
16333: IFFALSE 16281
// end ;
16335: PPOPN 2
16337: END
// every 0 0$1 trigger StreamModeActive and sStu do
16338: LD_EXP 29
16342: PUSH
16343: LD_EXP 68
16347: AND
16348: IFFALSE 16364
16350: GO 16352
16352: DISABLE
// begin ToLua ( displayStucuk(); ) ;
16353: LD_STRING displayStucuk();
16355: PPUSH
16356: CALL_OW 559
// ResetFog ;
16360: CALL_OW 335
// end ;
16364: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
16365: LD_EXP 29
16369: PUSH
16370: LD_EXP 61
16374: AND
16375: IFFALSE 16516
16377: GO 16379
16379: DISABLE
16380: LD_INT 0
16382: PPUSH
16383: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
16384: LD_ADDR_VAR 0 2
16388: PUSH
16389: LD_INT 22
16391: PUSH
16392: LD_OWVAR 2
16396: PUSH
16397: EMPTY
16398: LIST
16399: LIST
16400: PUSH
16401: LD_INT 21
16403: PUSH
16404: LD_INT 1
16406: PUSH
16407: EMPTY
16408: LIST
16409: LIST
16410: PUSH
16411: EMPTY
16412: LIST
16413: LIST
16414: PPUSH
16415: CALL_OW 69
16419: ST_TO_ADDR
// if not tmp then
16420: LD_VAR 0 2
16424: NOT
16425: IFFALSE 16429
// exit ;
16427: GO 16516
// un := tmp [ rand ( 1 , tmp ) ] ;
16429: LD_ADDR_VAR 0 1
16433: PUSH
16434: LD_VAR 0 2
16438: PUSH
16439: LD_INT 1
16441: PPUSH
16442: LD_VAR 0 2
16446: PPUSH
16447: CALL_OW 12
16451: ARRAY
16452: ST_TO_ADDR
// SetSide ( un , 0 ) ;
16453: LD_VAR 0 1
16457: PPUSH
16458: LD_INT 0
16460: PPUSH
16461: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
16465: LD_VAR 0 1
16469: PPUSH
16470: LD_OWVAR 3
16474: PUSH
16475: LD_VAR 0 1
16479: DIFF
16480: PPUSH
16481: LD_VAR 0 1
16485: PPUSH
16486: CALL_OW 74
16490: PPUSH
16491: CALL_OW 115
// wait ( 0 0$20 ) ;
16495: LD_INT 700
16497: PPUSH
16498: CALL_OW 67
// SetSide ( un , your_side ) ;
16502: LD_VAR 0 1
16506: PPUSH
16507: LD_OWVAR 2
16511: PPUSH
16512: CALL_OW 235
// end ;
16516: PPOPN 2
16518: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
16519: LD_EXP 29
16523: PUSH
16524: LD_EXP 62
16528: AND
16529: IFFALSE 16635
16531: GO 16533
16533: DISABLE
16534: LD_INT 0
16536: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
16537: LD_ADDR_VAR 0 1
16541: PUSH
16542: LD_INT 22
16544: PUSH
16545: LD_OWVAR 2
16549: PUSH
16550: EMPTY
16551: LIST
16552: LIST
16553: PUSH
16554: LD_INT 2
16556: PUSH
16557: LD_INT 30
16559: PUSH
16560: LD_INT 0
16562: PUSH
16563: EMPTY
16564: LIST
16565: LIST
16566: PUSH
16567: LD_INT 30
16569: PUSH
16570: LD_INT 1
16572: PUSH
16573: EMPTY
16574: LIST
16575: LIST
16576: PUSH
16577: EMPTY
16578: LIST
16579: LIST
16580: LIST
16581: PUSH
16582: EMPTY
16583: LIST
16584: LIST
16585: PPUSH
16586: CALL_OW 69
16590: ST_TO_ADDR
// if not depot then
16591: LD_VAR 0 1
16595: NOT
16596: IFFALSE 16600
// exit ;
16598: GO 16635
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
16600: LD_VAR 0 1
16604: PUSH
16605: LD_INT 1
16607: ARRAY
16608: PPUSH
16609: CALL_OW 250
16613: PPUSH
16614: LD_VAR 0 1
16618: PUSH
16619: LD_INT 1
16621: ARRAY
16622: PPUSH
16623: CALL_OW 251
16627: PPUSH
16628: LD_INT 70
16630: PPUSH
16631: CALL_OW 495
// end ;
16635: PPOPN 1
16637: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
16638: LD_EXP 29
16642: PUSH
16643: LD_EXP 63
16647: AND
16648: IFFALSE 16859
16650: GO 16652
16652: DISABLE
16653: LD_INT 0
16655: PPUSH
16656: PPUSH
16657: PPUSH
16658: PPUSH
16659: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
16660: LD_ADDR_VAR 0 5
16664: PUSH
16665: LD_INT 22
16667: PUSH
16668: LD_OWVAR 2
16672: PUSH
16673: EMPTY
16674: LIST
16675: LIST
16676: PUSH
16677: LD_INT 21
16679: PUSH
16680: LD_INT 1
16682: PUSH
16683: EMPTY
16684: LIST
16685: LIST
16686: PUSH
16687: EMPTY
16688: LIST
16689: LIST
16690: PPUSH
16691: CALL_OW 69
16695: ST_TO_ADDR
// if not tmp then
16696: LD_VAR 0 5
16700: NOT
16701: IFFALSE 16705
// exit ;
16703: GO 16859
// for i in tmp do
16705: LD_ADDR_VAR 0 1
16709: PUSH
16710: LD_VAR 0 5
16714: PUSH
16715: FOR_IN
16716: IFFALSE 16857
// begin d := rand ( 0 , 5 ) ;
16718: LD_ADDR_VAR 0 4
16722: PUSH
16723: LD_INT 0
16725: PPUSH
16726: LD_INT 5
16728: PPUSH
16729: CALL_OW 12
16733: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
16734: LD_ADDR_VAR 0 2
16738: PUSH
16739: LD_VAR 0 1
16743: PPUSH
16744: CALL_OW 250
16748: PPUSH
16749: LD_VAR 0 4
16753: PPUSH
16754: LD_INT 3
16756: PPUSH
16757: LD_INT 12
16759: PPUSH
16760: CALL_OW 12
16764: PPUSH
16765: CALL_OW 272
16769: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
16770: LD_ADDR_VAR 0 3
16774: PUSH
16775: LD_VAR 0 1
16779: PPUSH
16780: CALL_OW 251
16784: PPUSH
16785: LD_VAR 0 4
16789: PPUSH
16790: LD_INT 3
16792: PPUSH
16793: LD_INT 12
16795: PPUSH
16796: CALL_OW 12
16800: PPUSH
16801: CALL_OW 273
16805: ST_TO_ADDR
// if ValidHex ( x , y ) then
16806: LD_VAR 0 2
16810: PPUSH
16811: LD_VAR 0 3
16815: PPUSH
16816: CALL_OW 488
16820: IFFALSE 16855
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
16822: LD_VAR 0 1
16826: PPUSH
16827: LD_VAR 0 2
16831: PPUSH
16832: LD_VAR 0 3
16836: PPUSH
16837: LD_INT 3
16839: PPUSH
16840: LD_INT 6
16842: PPUSH
16843: CALL_OW 12
16847: PPUSH
16848: LD_INT 1
16850: PPUSH
16851: CALL_OW 483
// end ;
16855: GO 16715
16857: POP
16858: POP
// end ;
16859: PPOPN 5
16861: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
16862: LD_EXP 29
16866: PUSH
16867: LD_EXP 64
16871: AND
16872: IFFALSE 16966
16874: GO 16876
16876: DISABLE
16877: LD_INT 0
16879: PPUSH
16880: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
16881: LD_ADDR_VAR 0 2
16885: PUSH
16886: LD_INT 22
16888: PUSH
16889: LD_OWVAR 2
16893: PUSH
16894: EMPTY
16895: LIST
16896: LIST
16897: PUSH
16898: LD_INT 32
16900: PUSH
16901: LD_INT 1
16903: PUSH
16904: EMPTY
16905: LIST
16906: LIST
16907: PUSH
16908: LD_INT 21
16910: PUSH
16911: LD_INT 2
16913: PUSH
16914: EMPTY
16915: LIST
16916: LIST
16917: PUSH
16918: EMPTY
16919: LIST
16920: LIST
16921: LIST
16922: PPUSH
16923: CALL_OW 69
16927: ST_TO_ADDR
// if not tmp then
16928: LD_VAR 0 2
16932: NOT
16933: IFFALSE 16937
// exit ;
16935: GO 16966
// for i in tmp do
16937: LD_ADDR_VAR 0 1
16941: PUSH
16942: LD_VAR 0 2
16946: PUSH
16947: FOR_IN
16948: IFFALSE 16964
// SetFuel ( i , 0 ) ;
16950: LD_VAR 0 1
16954: PPUSH
16955: LD_INT 0
16957: PPUSH
16958: CALL_OW 240
16962: GO 16947
16964: POP
16965: POP
// end ;
16966: PPOPN 2
16968: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
16969: LD_EXP 29
16973: PUSH
16974: LD_EXP 65
16978: AND
16979: IFFALSE 17045
16981: GO 16983
16983: DISABLE
16984: LD_INT 0
16986: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
16987: LD_ADDR_VAR 0 1
16991: PUSH
16992: LD_INT 22
16994: PUSH
16995: LD_OWVAR 2
16999: PUSH
17000: EMPTY
17001: LIST
17002: LIST
17003: PUSH
17004: LD_INT 30
17006: PUSH
17007: LD_INT 29
17009: PUSH
17010: EMPTY
17011: LIST
17012: LIST
17013: PUSH
17014: EMPTY
17015: LIST
17016: LIST
17017: PPUSH
17018: CALL_OW 69
17022: ST_TO_ADDR
// if not tmp then
17023: LD_VAR 0 1
17027: NOT
17028: IFFALSE 17032
// exit ;
17030: GO 17045
// DestroyUnit ( tmp [ 1 ] ) ;
17032: LD_VAR 0 1
17036: PUSH
17037: LD_INT 1
17039: ARRAY
17040: PPUSH
17041: CALL_OW 65
// end ;
17045: PPOPN 1
17047: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
17048: LD_EXP 29
17052: PUSH
17053: LD_EXP 67
17057: AND
17058: IFFALSE 17187
17060: GO 17062
17062: DISABLE
17063: LD_INT 0
17065: PPUSH
// begin uc_side := 0 ;
17066: LD_ADDR_OWVAR 20
17070: PUSH
17071: LD_INT 0
17073: ST_TO_ADDR
// uc_nation := nation_arabian ;
17074: LD_ADDR_OWVAR 21
17078: PUSH
17079: LD_INT 2
17081: ST_TO_ADDR
// hc_gallery :=  ;
17082: LD_ADDR_OWVAR 33
17086: PUSH
17087: LD_STRING 
17089: ST_TO_ADDR
// hc_name :=  ;
17090: LD_ADDR_OWVAR 26
17094: PUSH
17095: LD_STRING 
17097: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
17098: LD_INT 1
17100: PPUSH
17101: LD_INT 11
17103: PPUSH
17104: LD_INT 10
17106: PPUSH
17107: CALL_OW 380
// un := CreateHuman ;
17111: LD_ADDR_VAR 0 1
17115: PUSH
17116: CALL_OW 44
17120: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
17121: LD_VAR 0 1
17125: PPUSH
17126: LD_INT 1
17128: PPUSH
17129: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
17133: LD_INT 35
17135: PPUSH
17136: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
17140: LD_VAR 0 1
17144: PPUSH
17145: LD_INT 22
17147: PUSH
17148: LD_OWVAR 2
17152: PUSH
17153: EMPTY
17154: LIST
17155: LIST
17156: PPUSH
17157: CALL_OW 69
17161: PPUSH
17162: LD_VAR 0 1
17166: PPUSH
17167: CALL_OW 74
17171: PPUSH
17172: CALL_OW 115
// until IsDead ( un ) ;
17176: LD_VAR 0 1
17180: PPUSH
17181: CALL_OW 301
17185: IFFALSE 17133
// end ;
17187: PPOPN 1
17189: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
17190: LD_EXP 29
17194: PUSH
17195: LD_EXP 69
17199: AND
17200: IFFALSE 17212
17202: GO 17204
17204: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
17205: LD_STRING earthquake(getX(game), 0, 32)
17207: PPUSH
17208: CALL_OW 559
17212: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
17213: LD_EXP 29
17217: PUSH
17218: LD_EXP 70
17222: AND
17223: IFFALSE 17314
17225: GO 17227
17227: DISABLE
17228: LD_INT 0
17230: PPUSH
// begin enable ;
17231: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
17232: LD_ADDR_VAR 0 1
17236: PUSH
17237: LD_INT 22
17239: PUSH
17240: LD_OWVAR 2
17244: PUSH
17245: EMPTY
17246: LIST
17247: LIST
17248: PUSH
17249: LD_INT 21
17251: PUSH
17252: LD_INT 2
17254: PUSH
17255: EMPTY
17256: LIST
17257: LIST
17258: PUSH
17259: LD_INT 33
17261: PUSH
17262: LD_INT 3
17264: PUSH
17265: EMPTY
17266: LIST
17267: LIST
17268: PUSH
17269: EMPTY
17270: LIST
17271: LIST
17272: LIST
17273: PPUSH
17274: CALL_OW 69
17278: ST_TO_ADDR
// if not tmp then
17279: LD_VAR 0 1
17283: NOT
17284: IFFALSE 17288
// exit ;
17286: GO 17314
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
17288: LD_VAR 0 1
17292: PUSH
17293: LD_INT 1
17295: PPUSH
17296: LD_VAR 0 1
17300: PPUSH
17301: CALL_OW 12
17305: ARRAY
17306: PPUSH
17307: LD_INT 1
17309: PPUSH
17310: CALL_OW 234
// end ;
17314: PPOPN 1
17316: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
17317: LD_EXP 29
17321: PUSH
17322: LD_EXP 71
17326: AND
17327: IFFALSE 17468
17329: GO 17331
17331: DISABLE
17332: LD_INT 0
17334: PPUSH
17335: PPUSH
17336: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
17337: LD_ADDR_VAR 0 3
17341: PUSH
17342: LD_INT 22
17344: PUSH
17345: LD_OWVAR 2
17349: PUSH
17350: EMPTY
17351: LIST
17352: LIST
17353: PUSH
17354: LD_INT 25
17356: PUSH
17357: LD_INT 1
17359: PUSH
17360: EMPTY
17361: LIST
17362: LIST
17363: PUSH
17364: EMPTY
17365: LIST
17366: LIST
17367: PPUSH
17368: CALL_OW 69
17372: ST_TO_ADDR
// if not tmp then
17373: LD_VAR 0 3
17377: NOT
17378: IFFALSE 17382
// exit ;
17380: GO 17468
// un := tmp [ rand ( 1 , tmp ) ] ;
17382: LD_ADDR_VAR 0 2
17386: PUSH
17387: LD_VAR 0 3
17391: PUSH
17392: LD_INT 1
17394: PPUSH
17395: LD_VAR 0 3
17399: PPUSH
17400: CALL_OW 12
17404: ARRAY
17405: ST_TO_ADDR
// if Crawls ( un ) then
17406: LD_VAR 0 2
17410: PPUSH
17411: CALL_OW 318
17415: IFFALSE 17426
// ComWalk ( un ) ;
17417: LD_VAR 0 2
17421: PPUSH
17422: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
17426: LD_VAR 0 2
17430: PPUSH
17431: LD_INT 9
17433: PPUSH
17434: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
17438: LD_INT 28
17440: PPUSH
17441: LD_OWVAR 2
17445: PPUSH
17446: LD_INT 2
17448: PPUSH
17449: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
17453: LD_INT 29
17455: PPUSH
17456: LD_OWVAR 2
17460: PPUSH
17461: LD_INT 2
17463: PPUSH
17464: CALL_OW 322
// end ;
17468: PPOPN 3
17470: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
17471: LD_EXP 29
17475: PUSH
17476: LD_EXP 72
17480: AND
17481: IFFALSE 17592
17483: GO 17485
17485: DISABLE
17486: LD_INT 0
17488: PPUSH
17489: PPUSH
17490: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
17491: LD_ADDR_VAR 0 3
17495: PUSH
17496: LD_INT 22
17498: PUSH
17499: LD_OWVAR 2
17503: PUSH
17504: EMPTY
17505: LIST
17506: LIST
17507: PUSH
17508: LD_INT 25
17510: PUSH
17511: LD_INT 1
17513: PUSH
17514: EMPTY
17515: LIST
17516: LIST
17517: PUSH
17518: EMPTY
17519: LIST
17520: LIST
17521: PPUSH
17522: CALL_OW 69
17526: ST_TO_ADDR
// if not tmp then
17527: LD_VAR 0 3
17531: NOT
17532: IFFALSE 17536
// exit ;
17534: GO 17592
// un := tmp [ rand ( 1 , tmp ) ] ;
17536: LD_ADDR_VAR 0 2
17540: PUSH
17541: LD_VAR 0 3
17545: PUSH
17546: LD_INT 1
17548: PPUSH
17549: LD_VAR 0 3
17553: PPUSH
17554: CALL_OW 12
17558: ARRAY
17559: ST_TO_ADDR
// if Crawls ( un ) then
17560: LD_VAR 0 2
17564: PPUSH
17565: CALL_OW 318
17569: IFFALSE 17580
// ComWalk ( un ) ;
17571: LD_VAR 0 2
17575: PPUSH
17576: CALL_OW 138
// SetClass ( un , class_mortar ) ;
17580: LD_VAR 0 2
17584: PPUSH
17585: LD_INT 8
17587: PPUSH
17588: CALL_OW 336
// end ;
17592: PPOPN 3
17594: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
17595: LD_EXP 29
17599: PUSH
17600: LD_EXP 73
17604: AND
17605: IFFALSE 17749
17607: GO 17609
17609: DISABLE
17610: LD_INT 0
17612: PPUSH
17613: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
17614: LD_ADDR_VAR 0 2
17618: PUSH
17619: LD_INT 22
17621: PUSH
17622: LD_OWVAR 2
17626: PUSH
17627: EMPTY
17628: LIST
17629: LIST
17630: PUSH
17631: LD_INT 21
17633: PUSH
17634: LD_INT 2
17636: PUSH
17637: EMPTY
17638: LIST
17639: LIST
17640: PUSH
17641: LD_INT 2
17643: PUSH
17644: LD_INT 34
17646: PUSH
17647: LD_INT 12
17649: PUSH
17650: EMPTY
17651: LIST
17652: LIST
17653: PUSH
17654: LD_INT 34
17656: PUSH
17657: LD_INT 51
17659: PUSH
17660: EMPTY
17661: LIST
17662: LIST
17663: PUSH
17664: LD_INT 34
17666: PUSH
17667: LD_INT 32
17669: PUSH
17670: EMPTY
17671: LIST
17672: LIST
17673: PUSH
17674: EMPTY
17675: LIST
17676: LIST
17677: LIST
17678: LIST
17679: PUSH
17680: EMPTY
17681: LIST
17682: LIST
17683: LIST
17684: PPUSH
17685: CALL_OW 69
17689: ST_TO_ADDR
// if not tmp then
17690: LD_VAR 0 2
17694: NOT
17695: IFFALSE 17699
// exit ;
17697: GO 17749
// for i in tmp do
17699: LD_ADDR_VAR 0 1
17703: PUSH
17704: LD_VAR 0 2
17708: PUSH
17709: FOR_IN
17710: IFFALSE 17747
// if GetCargo ( i , mat_artifact ) = 0 then
17712: LD_VAR 0 1
17716: PPUSH
17717: LD_INT 4
17719: PPUSH
17720: CALL_OW 289
17724: PUSH
17725: LD_INT 0
17727: EQUAL
17728: IFFALSE 17745
// SetCargo ( i , mat_siberit , 100 ) ;
17730: LD_VAR 0 1
17734: PPUSH
17735: LD_INT 3
17737: PPUSH
17738: LD_INT 100
17740: PPUSH
17741: CALL_OW 290
17745: GO 17709
17747: POP
17748: POP
// end ;
17749: PPOPN 2
17751: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
17752: LD_EXP 29
17756: PUSH
17757: LD_EXP 74
17761: AND
17762: IFFALSE 17915
17764: GO 17766
17766: DISABLE
17767: LD_INT 0
17769: PPUSH
17770: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
17771: LD_ADDR_VAR 0 2
17775: PUSH
17776: LD_INT 22
17778: PUSH
17779: LD_OWVAR 2
17783: PUSH
17784: EMPTY
17785: LIST
17786: LIST
17787: PPUSH
17788: CALL_OW 69
17792: ST_TO_ADDR
// if not tmp then
17793: LD_VAR 0 2
17797: NOT
17798: IFFALSE 17802
// exit ;
17800: GO 17915
// for i := 1 to 2 do
17802: LD_ADDR_VAR 0 1
17806: PUSH
17807: DOUBLE
17808: LD_INT 1
17810: DEC
17811: ST_TO_ADDR
17812: LD_INT 2
17814: PUSH
17815: FOR_TO
17816: IFFALSE 17913
// begin uc_side := your_side ;
17818: LD_ADDR_OWVAR 20
17822: PUSH
17823: LD_OWVAR 2
17827: ST_TO_ADDR
// uc_nation := nation_american ;
17828: LD_ADDR_OWVAR 21
17832: PUSH
17833: LD_INT 1
17835: ST_TO_ADDR
// vc_chassis := us_morphling ;
17836: LD_ADDR_OWVAR 37
17840: PUSH
17841: LD_INT 5
17843: ST_TO_ADDR
// vc_engine := engine_siberite ;
17844: LD_ADDR_OWVAR 39
17848: PUSH
17849: LD_INT 3
17851: ST_TO_ADDR
// vc_control := control_computer ;
17852: LD_ADDR_OWVAR 38
17856: PUSH
17857: LD_INT 3
17859: ST_TO_ADDR
// vc_weapon := us_double_laser ;
17860: LD_ADDR_OWVAR 40
17864: PUSH
17865: LD_INT 10
17867: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
17868: CALL_OW 45
17872: PPUSH
17873: LD_VAR 0 2
17877: PUSH
17878: LD_INT 1
17880: ARRAY
17881: PPUSH
17882: CALL_OW 250
17886: PPUSH
17887: LD_VAR 0 2
17891: PUSH
17892: LD_INT 1
17894: ARRAY
17895: PPUSH
17896: CALL_OW 251
17900: PPUSH
17901: LD_INT 12
17903: PPUSH
17904: LD_INT 1
17906: PPUSH
17907: CALL_OW 50
// end ;
17911: GO 17815
17913: POP
17914: POP
// end ;
17915: PPOPN 2
17917: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
17918: LD_EXP 29
17922: PUSH
17923: LD_EXP 75
17927: AND
17928: IFFALSE 18150
17930: GO 17932
17932: DISABLE
17933: LD_INT 0
17935: PPUSH
17936: PPUSH
17937: PPUSH
17938: PPUSH
17939: PPUSH
17940: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
17941: LD_ADDR_VAR 0 6
17945: PUSH
17946: LD_INT 22
17948: PUSH
17949: LD_OWVAR 2
17953: PUSH
17954: EMPTY
17955: LIST
17956: LIST
17957: PUSH
17958: LD_INT 21
17960: PUSH
17961: LD_INT 1
17963: PUSH
17964: EMPTY
17965: LIST
17966: LIST
17967: PUSH
17968: LD_INT 3
17970: PUSH
17971: LD_INT 23
17973: PUSH
17974: LD_INT 0
17976: PUSH
17977: EMPTY
17978: LIST
17979: LIST
17980: PUSH
17981: EMPTY
17982: LIST
17983: LIST
17984: PUSH
17985: EMPTY
17986: LIST
17987: LIST
17988: LIST
17989: PPUSH
17990: CALL_OW 69
17994: ST_TO_ADDR
// if not tmp then
17995: LD_VAR 0 6
17999: NOT
18000: IFFALSE 18004
// exit ;
18002: GO 18150
// s1 := rand ( 1 , 4 ) ;
18004: LD_ADDR_VAR 0 2
18008: PUSH
18009: LD_INT 1
18011: PPUSH
18012: LD_INT 4
18014: PPUSH
18015: CALL_OW 12
18019: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
18020: LD_ADDR_VAR 0 4
18024: PUSH
18025: LD_VAR 0 6
18029: PUSH
18030: LD_INT 1
18032: ARRAY
18033: PPUSH
18034: LD_VAR 0 2
18038: PPUSH
18039: CALL_OW 259
18043: ST_TO_ADDR
// if s1 = 1 then
18044: LD_VAR 0 2
18048: PUSH
18049: LD_INT 1
18051: EQUAL
18052: IFFALSE 18072
// s2 := rand ( 2 , 4 ) else
18054: LD_ADDR_VAR 0 3
18058: PUSH
18059: LD_INT 2
18061: PPUSH
18062: LD_INT 4
18064: PPUSH
18065: CALL_OW 12
18069: ST_TO_ADDR
18070: GO 18080
// s2 := 1 ;
18072: LD_ADDR_VAR 0 3
18076: PUSH
18077: LD_INT 1
18079: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
18080: LD_ADDR_VAR 0 5
18084: PUSH
18085: LD_VAR 0 6
18089: PUSH
18090: LD_INT 1
18092: ARRAY
18093: PPUSH
18094: LD_VAR 0 3
18098: PPUSH
18099: CALL_OW 259
18103: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
18104: LD_VAR 0 6
18108: PUSH
18109: LD_INT 1
18111: ARRAY
18112: PPUSH
18113: LD_VAR 0 2
18117: PPUSH
18118: LD_VAR 0 5
18122: PPUSH
18123: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
18127: LD_VAR 0 6
18131: PUSH
18132: LD_INT 1
18134: ARRAY
18135: PPUSH
18136: LD_VAR 0 3
18140: PPUSH
18141: LD_VAR 0 4
18145: PPUSH
18146: CALL_OW 237
// end ;
18150: PPOPN 6
18152: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
18153: LD_EXP 29
18157: PUSH
18158: LD_EXP 76
18162: AND
18163: IFFALSE 18242
18165: GO 18167
18167: DISABLE
18168: LD_INT 0
18170: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
18171: LD_ADDR_VAR 0 1
18175: PUSH
18176: LD_INT 22
18178: PUSH
18179: LD_OWVAR 2
18183: PUSH
18184: EMPTY
18185: LIST
18186: LIST
18187: PUSH
18188: LD_INT 30
18190: PUSH
18191: LD_INT 3
18193: PUSH
18194: EMPTY
18195: LIST
18196: LIST
18197: PUSH
18198: EMPTY
18199: LIST
18200: LIST
18201: PPUSH
18202: CALL_OW 69
18206: ST_TO_ADDR
// if not tmp then
18207: LD_VAR 0 1
18211: NOT
18212: IFFALSE 18216
// exit ;
18214: GO 18242
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
18216: LD_VAR 0 1
18220: PUSH
18221: LD_INT 1
18223: PPUSH
18224: LD_VAR 0 1
18228: PPUSH
18229: CALL_OW 12
18233: ARRAY
18234: PPUSH
18235: LD_INT 1
18237: PPUSH
18238: CALL_OW 234
// end ;
18242: PPOPN 1
18244: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
18245: LD_EXP 29
18249: PUSH
18250: LD_EXP 77
18254: AND
18255: IFFALSE 18367
18257: GO 18259
18259: DISABLE
18260: LD_INT 0
18262: PPUSH
18263: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
18264: LD_ADDR_VAR 0 2
18268: PUSH
18269: LD_INT 22
18271: PUSH
18272: LD_OWVAR 2
18276: PUSH
18277: EMPTY
18278: LIST
18279: LIST
18280: PUSH
18281: LD_INT 2
18283: PUSH
18284: LD_INT 30
18286: PUSH
18287: LD_INT 27
18289: PUSH
18290: EMPTY
18291: LIST
18292: LIST
18293: PUSH
18294: LD_INT 30
18296: PUSH
18297: LD_INT 26
18299: PUSH
18300: EMPTY
18301: LIST
18302: LIST
18303: PUSH
18304: LD_INT 30
18306: PUSH
18307: LD_INT 28
18309: PUSH
18310: EMPTY
18311: LIST
18312: LIST
18313: PUSH
18314: EMPTY
18315: LIST
18316: LIST
18317: LIST
18318: LIST
18319: PUSH
18320: EMPTY
18321: LIST
18322: LIST
18323: PPUSH
18324: CALL_OW 69
18328: ST_TO_ADDR
// if not tmp then
18329: LD_VAR 0 2
18333: NOT
18334: IFFALSE 18338
// exit ;
18336: GO 18367
// for i in tmp do
18338: LD_ADDR_VAR 0 1
18342: PUSH
18343: LD_VAR 0 2
18347: PUSH
18348: FOR_IN
18349: IFFALSE 18365
// SetLives ( i , 1 ) ;
18351: LD_VAR 0 1
18355: PPUSH
18356: LD_INT 1
18358: PPUSH
18359: CALL_OW 234
18363: GO 18348
18365: POP
18366: POP
// end ;
18367: PPOPN 2
18369: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
18370: LD_EXP 29
18374: PUSH
18375: LD_EXP 78
18379: AND
18380: IFFALSE 18654
18382: GO 18384
18384: DISABLE
18385: LD_INT 0
18387: PPUSH
18388: PPUSH
18389: PPUSH
// begin i := rand ( 1 , 7 ) ;
18390: LD_ADDR_VAR 0 1
18394: PUSH
18395: LD_INT 1
18397: PPUSH
18398: LD_INT 7
18400: PPUSH
18401: CALL_OW 12
18405: ST_TO_ADDR
// case i of 1 :
18406: LD_VAR 0 1
18410: PUSH
18411: LD_INT 1
18413: DOUBLE
18414: EQUAL
18415: IFTRUE 18419
18417: GO 18429
18419: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
18420: LD_STRING earthquake(getX(game), 0, 32)
18422: PPUSH
18423: CALL_OW 559
18427: GO 18654
18429: LD_INT 2
18431: DOUBLE
18432: EQUAL
18433: IFTRUE 18437
18435: GO 18451
18437: POP
// begin ToLua ( displayStucuk(); ) ;
18438: LD_STRING displayStucuk();
18440: PPUSH
18441: CALL_OW 559
// ResetFog ;
18445: CALL_OW 335
// end ; 3 :
18449: GO 18654
18451: LD_INT 3
18453: DOUBLE
18454: EQUAL
18455: IFTRUE 18459
18457: GO 18563
18459: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
18460: LD_ADDR_VAR 0 2
18464: PUSH
18465: LD_INT 22
18467: PUSH
18468: LD_OWVAR 2
18472: PUSH
18473: EMPTY
18474: LIST
18475: LIST
18476: PUSH
18477: LD_INT 25
18479: PUSH
18480: LD_INT 1
18482: PUSH
18483: EMPTY
18484: LIST
18485: LIST
18486: PUSH
18487: EMPTY
18488: LIST
18489: LIST
18490: PPUSH
18491: CALL_OW 69
18495: ST_TO_ADDR
// if not tmp then
18496: LD_VAR 0 2
18500: NOT
18501: IFFALSE 18505
// exit ;
18503: GO 18654
// un := tmp [ rand ( 1 , tmp ) ] ;
18505: LD_ADDR_VAR 0 3
18509: PUSH
18510: LD_VAR 0 2
18514: PUSH
18515: LD_INT 1
18517: PPUSH
18518: LD_VAR 0 2
18522: PPUSH
18523: CALL_OW 12
18527: ARRAY
18528: ST_TO_ADDR
// if Crawls ( un ) then
18529: LD_VAR 0 3
18533: PPUSH
18534: CALL_OW 318
18538: IFFALSE 18549
// ComWalk ( un ) ;
18540: LD_VAR 0 3
18544: PPUSH
18545: CALL_OW 138
// SetClass ( un , class_mortar ) ;
18549: LD_VAR 0 3
18553: PPUSH
18554: LD_INT 8
18556: PPUSH
18557: CALL_OW 336
// end ; 4 :
18561: GO 18654
18563: LD_INT 4
18565: DOUBLE
18566: EQUAL
18567: IFTRUE 18571
18569: GO 18632
18571: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
18572: LD_ADDR_VAR 0 2
18576: PUSH
18577: LD_INT 22
18579: PUSH
18580: LD_OWVAR 2
18584: PUSH
18585: EMPTY
18586: LIST
18587: LIST
18588: PUSH
18589: LD_INT 30
18591: PUSH
18592: LD_INT 29
18594: PUSH
18595: EMPTY
18596: LIST
18597: LIST
18598: PUSH
18599: EMPTY
18600: LIST
18601: LIST
18602: PPUSH
18603: CALL_OW 69
18607: ST_TO_ADDR
// if not tmp then
18608: LD_VAR 0 2
18612: NOT
18613: IFFALSE 18617
// exit ;
18615: GO 18654
// DestroyUnit ( tmp [ 1 ] ) ;
18617: LD_VAR 0 2
18621: PUSH
18622: LD_INT 1
18624: ARRAY
18625: PPUSH
18626: CALL_OW 65
// end ; 5 .. 7 :
18630: GO 18654
18632: LD_INT 5
18634: DOUBLE
18635: GREATEREQUAL
18636: IFFALSE 18644
18638: LD_INT 7
18640: DOUBLE
18641: LESSEQUAL
18642: IFTRUE 18646
18644: GO 18653
18646: POP
// StreamSibBomb ; end ;
18647: CALL 14934 0 0
18651: GO 18654
18653: POP
// end ;
18654: PPOPN 3
18656: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
18657: LD_EXP 29
18661: PUSH
18662: LD_EXP 79
18666: AND
18667: IFFALSE 18823
18669: GO 18671
18671: DISABLE
18672: LD_INT 0
18674: PPUSH
18675: PPUSH
18676: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
18677: LD_ADDR_VAR 0 2
18681: PUSH
18682: LD_INT 81
18684: PUSH
18685: LD_OWVAR 2
18689: PUSH
18690: EMPTY
18691: LIST
18692: LIST
18693: PUSH
18694: LD_INT 2
18696: PUSH
18697: LD_INT 21
18699: PUSH
18700: LD_INT 1
18702: PUSH
18703: EMPTY
18704: LIST
18705: LIST
18706: PUSH
18707: LD_INT 21
18709: PUSH
18710: LD_INT 2
18712: PUSH
18713: EMPTY
18714: LIST
18715: LIST
18716: PUSH
18717: EMPTY
18718: LIST
18719: LIST
18720: LIST
18721: PUSH
18722: EMPTY
18723: LIST
18724: LIST
18725: PPUSH
18726: CALL_OW 69
18730: ST_TO_ADDR
// if not tmp then
18731: LD_VAR 0 2
18735: NOT
18736: IFFALSE 18740
// exit ;
18738: GO 18823
// p := 0 ;
18740: LD_ADDR_VAR 0 3
18744: PUSH
18745: LD_INT 0
18747: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18748: LD_INT 35
18750: PPUSH
18751: CALL_OW 67
// p := p + 1 ;
18755: LD_ADDR_VAR 0 3
18759: PUSH
18760: LD_VAR 0 3
18764: PUSH
18765: LD_INT 1
18767: PLUS
18768: ST_TO_ADDR
// for i in tmp do
18769: LD_ADDR_VAR 0 1
18773: PUSH
18774: LD_VAR 0 2
18778: PUSH
18779: FOR_IN
18780: IFFALSE 18811
// if GetLives ( i ) < 1000 then
18782: LD_VAR 0 1
18786: PPUSH
18787: CALL_OW 256
18791: PUSH
18792: LD_INT 1000
18794: LESS
18795: IFFALSE 18809
// SetLives ( i , 1000 ) ;
18797: LD_VAR 0 1
18801: PPUSH
18802: LD_INT 1000
18804: PPUSH
18805: CALL_OW 234
18809: GO 18779
18811: POP
18812: POP
// until p > 20 ;
18813: LD_VAR 0 3
18817: PUSH
18818: LD_INT 20
18820: GREATER
18821: IFFALSE 18748
// end ;
18823: PPOPN 3
18825: END
// every 0 0$1 trigger StreamModeActive and sTime do
18826: LD_EXP 29
18830: PUSH
18831: LD_EXP 80
18835: AND
18836: IFFALSE 18871
18838: GO 18840
18840: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
18841: LD_INT 28
18843: PPUSH
18844: LD_OWVAR 2
18848: PPUSH
18849: LD_INT 2
18851: PPUSH
18852: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
18856: LD_INT 30
18858: PPUSH
18859: LD_OWVAR 2
18863: PPUSH
18864: LD_INT 2
18866: PPUSH
18867: CALL_OW 322
// end ;
18871: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
18872: LD_EXP 29
18876: PUSH
18877: LD_EXP 81
18881: AND
18882: IFFALSE 19003
18884: GO 18886
18886: DISABLE
18887: LD_INT 0
18889: PPUSH
18890: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
18891: LD_ADDR_VAR 0 2
18895: PUSH
18896: LD_INT 22
18898: PUSH
18899: LD_OWVAR 2
18903: PUSH
18904: EMPTY
18905: LIST
18906: LIST
18907: PUSH
18908: LD_INT 21
18910: PUSH
18911: LD_INT 1
18913: PUSH
18914: EMPTY
18915: LIST
18916: LIST
18917: PUSH
18918: LD_INT 3
18920: PUSH
18921: LD_INT 23
18923: PUSH
18924: LD_INT 0
18926: PUSH
18927: EMPTY
18928: LIST
18929: LIST
18930: PUSH
18931: EMPTY
18932: LIST
18933: LIST
18934: PUSH
18935: EMPTY
18936: LIST
18937: LIST
18938: LIST
18939: PPUSH
18940: CALL_OW 69
18944: ST_TO_ADDR
// if not tmp then
18945: LD_VAR 0 2
18949: NOT
18950: IFFALSE 18954
// exit ;
18952: GO 19003
// for i in tmp do
18954: LD_ADDR_VAR 0 1
18958: PUSH
18959: LD_VAR 0 2
18963: PUSH
18964: FOR_IN
18965: IFFALSE 19001
// begin if Crawls ( i ) then
18967: LD_VAR 0 1
18971: PPUSH
18972: CALL_OW 318
18976: IFFALSE 18987
// ComWalk ( i ) ;
18978: LD_VAR 0 1
18982: PPUSH
18983: CALL_OW 138
// SetClass ( i , 2 ) ;
18987: LD_VAR 0 1
18991: PPUSH
18992: LD_INT 2
18994: PPUSH
18995: CALL_OW 336
// end ;
18999: GO 18964
19001: POP
19002: POP
// end ;
19003: PPOPN 2
19005: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
19006: LD_EXP 29
19010: PUSH
19011: LD_EXP 82
19015: AND
19016: IFFALSE 19297
19018: GO 19020
19020: DISABLE
19021: LD_INT 0
19023: PPUSH
19024: PPUSH
19025: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
19026: LD_OWVAR 2
19030: PPUSH
19031: LD_INT 9
19033: PPUSH
19034: LD_INT 1
19036: PPUSH
19037: LD_INT 1
19039: PPUSH
19040: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
19044: LD_INT 9
19046: PPUSH
19047: LD_OWVAR 2
19051: PPUSH
19052: CALL_OW 343
// uc_side := 9 ;
19056: LD_ADDR_OWVAR 20
19060: PUSH
19061: LD_INT 9
19063: ST_TO_ADDR
// uc_nation := 2 ;
19064: LD_ADDR_OWVAR 21
19068: PUSH
19069: LD_INT 2
19071: ST_TO_ADDR
// hc_name := Dark Warrior ;
19072: LD_ADDR_OWVAR 26
19076: PUSH
19077: LD_STRING Dark Warrior
19079: ST_TO_ADDR
// hc_gallery :=  ;
19080: LD_ADDR_OWVAR 33
19084: PUSH
19085: LD_STRING 
19087: ST_TO_ADDR
// hc_noskilllimit := true ;
19088: LD_ADDR_OWVAR 76
19092: PUSH
19093: LD_INT 1
19095: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
19096: LD_ADDR_OWVAR 31
19100: PUSH
19101: LD_INT 30
19103: PUSH
19104: LD_INT 30
19106: PUSH
19107: LD_INT 30
19109: PUSH
19110: LD_INT 30
19112: PUSH
19113: EMPTY
19114: LIST
19115: LIST
19116: LIST
19117: LIST
19118: ST_TO_ADDR
// un := CreateHuman ;
19119: LD_ADDR_VAR 0 3
19123: PUSH
19124: CALL_OW 44
19128: ST_TO_ADDR
// hc_noskilllimit := false ;
19129: LD_ADDR_OWVAR 76
19133: PUSH
19134: LD_INT 0
19136: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
19137: LD_VAR 0 3
19141: PPUSH
19142: LD_INT 1
19144: PPUSH
19145: CALL_OW 51
// p := 0 ;
19149: LD_ADDR_VAR 0 2
19153: PUSH
19154: LD_INT 0
19156: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
19157: LD_INT 35
19159: PPUSH
19160: CALL_OW 67
// p := p + 1 ;
19164: LD_ADDR_VAR 0 2
19168: PUSH
19169: LD_VAR 0 2
19173: PUSH
19174: LD_INT 1
19176: PLUS
19177: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
19178: LD_VAR 0 3
19182: PPUSH
19183: CALL_OW 256
19187: PUSH
19188: LD_INT 1000
19190: LESS
19191: IFFALSE 19205
// SetLives ( un , 1000 ) ;
19193: LD_VAR 0 3
19197: PPUSH
19198: LD_INT 1000
19200: PPUSH
19201: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
19205: LD_VAR 0 3
19209: PPUSH
19210: LD_INT 81
19212: PUSH
19213: LD_OWVAR 2
19217: PUSH
19218: EMPTY
19219: LIST
19220: LIST
19221: PUSH
19222: LD_INT 91
19224: PUSH
19225: LD_VAR 0 3
19229: PUSH
19230: LD_INT 30
19232: PUSH
19233: EMPTY
19234: LIST
19235: LIST
19236: LIST
19237: PUSH
19238: EMPTY
19239: LIST
19240: LIST
19241: PPUSH
19242: CALL_OW 69
19246: PPUSH
19247: LD_VAR 0 3
19251: PPUSH
19252: CALL_OW 74
19256: PPUSH
19257: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
19261: LD_VAR 0 2
19265: PUSH
19266: LD_INT 60
19268: GREATER
19269: PUSH
19270: LD_VAR 0 3
19274: PPUSH
19275: CALL_OW 301
19279: OR
19280: IFFALSE 19157
// if un then
19282: LD_VAR 0 3
19286: IFFALSE 19297
// RemoveUnit ( un ) ;
19288: LD_VAR 0 3
19292: PPUSH
19293: CALL_OW 64
// end ; end_of_file
19297: PPOPN 3
19299: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
19300: LD_INT 0
19302: PPUSH
19303: PPUSH
19304: PPUSH
19305: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
19306: LD_VAR 0 1
19310: PPUSH
19311: CALL_OW 264
19315: PUSH
19316: LD_EXP 28
19320: EQUAL
19321: IFFALSE 19393
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
19323: LD_INT 68
19325: PPUSH
19326: LD_VAR 0 1
19330: PPUSH
19331: CALL_OW 255
19335: PPUSH
19336: CALL_OW 321
19340: PUSH
19341: LD_INT 2
19343: EQUAL
19344: IFFALSE 19356
// eff := 70 else
19346: LD_ADDR_VAR 0 4
19350: PUSH
19351: LD_INT 70
19353: ST_TO_ADDR
19354: GO 19364
// eff := 30 ;
19356: LD_ADDR_VAR 0 4
19360: PUSH
19361: LD_INT 30
19363: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
19364: LD_VAR 0 1
19368: PPUSH
19369: CALL_OW 250
19373: PPUSH
19374: LD_VAR 0 1
19378: PPUSH
19379: CALL_OW 251
19383: PPUSH
19384: LD_VAR 0 4
19388: PPUSH
19389: CALL_OW 495
// end ; end ;
19393: LD_VAR 0 2
19397: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
19398: LD_INT 0
19400: PPUSH
// end ;
19401: LD_VAR 0 4
19405: RET
// export function SOS_Command ( cmd ) ; begin
19406: LD_INT 0
19408: PPUSH
// end ;
19409: LD_VAR 0 2
19413: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
19414: LD_VAR 0 1
19418: PUSH
19419: LD_INT 255
19421: EQUAL
19422: PUSH
19423: LD_VAR 0 2
19427: PPUSH
19428: CALL_OW 264
19432: PUSH
19433: LD_INT 14
19435: PUSH
19436: LD_INT 53
19438: PUSH
19439: EMPTY
19440: LIST
19441: LIST
19442: IN
19443: AND
19444: PUSH
19445: LD_VAR 0 4
19449: PPUSH
19450: LD_VAR 0 5
19454: PPUSH
19455: CALL_OW 488
19459: AND
19460: IFFALSE 19484
// CutTreeXYR ( unit , x , y , 12 ) ;
19462: LD_VAR 0 2
19466: PPUSH
19467: LD_VAR 0 4
19471: PPUSH
19472: LD_VAR 0 5
19476: PPUSH
19477: LD_INT 12
19479: PPUSH
19480: CALL 19487 0 4
// end ;
19484: PPOPN 5
19486: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
19487: LD_INT 0
19489: PPUSH
19490: PPUSH
19491: PPUSH
19492: PPUSH
19493: PPUSH
19494: PPUSH
19495: PPUSH
19496: PPUSH
19497: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
19498: LD_VAR 0 1
19502: NOT
19503: PUSH
19504: LD_VAR 0 2
19508: PPUSH
19509: LD_VAR 0 3
19513: PPUSH
19514: CALL_OW 488
19518: NOT
19519: OR
19520: PUSH
19521: LD_VAR 0 4
19525: NOT
19526: OR
19527: IFFALSE 19531
// exit ;
19529: GO 19871
// list := [ ] ;
19531: LD_ADDR_VAR 0 13
19535: PUSH
19536: EMPTY
19537: ST_TO_ADDR
// if x - r < 0 then
19538: LD_VAR 0 2
19542: PUSH
19543: LD_VAR 0 4
19547: MINUS
19548: PUSH
19549: LD_INT 0
19551: LESS
19552: IFFALSE 19564
// min_x := 0 else
19554: LD_ADDR_VAR 0 7
19558: PUSH
19559: LD_INT 0
19561: ST_TO_ADDR
19562: GO 19580
// min_x := x - r ;
19564: LD_ADDR_VAR 0 7
19568: PUSH
19569: LD_VAR 0 2
19573: PUSH
19574: LD_VAR 0 4
19578: MINUS
19579: ST_TO_ADDR
// if y - r < 0 then
19580: LD_VAR 0 3
19584: PUSH
19585: LD_VAR 0 4
19589: MINUS
19590: PUSH
19591: LD_INT 0
19593: LESS
19594: IFFALSE 19606
// min_y := 0 else
19596: LD_ADDR_VAR 0 8
19600: PUSH
19601: LD_INT 0
19603: ST_TO_ADDR
19604: GO 19622
// min_y := y - r ;
19606: LD_ADDR_VAR 0 8
19610: PUSH
19611: LD_VAR 0 3
19615: PUSH
19616: LD_VAR 0 4
19620: MINUS
19621: ST_TO_ADDR
// max_x := x + r ;
19622: LD_ADDR_VAR 0 9
19626: PUSH
19627: LD_VAR 0 2
19631: PUSH
19632: LD_VAR 0 4
19636: PLUS
19637: ST_TO_ADDR
// max_y := y + r ;
19638: LD_ADDR_VAR 0 10
19642: PUSH
19643: LD_VAR 0 3
19647: PUSH
19648: LD_VAR 0 4
19652: PLUS
19653: ST_TO_ADDR
// for _x = min_x to max_x do
19654: LD_ADDR_VAR 0 11
19658: PUSH
19659: DOUBLE
19660: LD_VAR 0 7
19664: DEC
19665: ST_TO_ADDR
19666: LD_VAR 0 9
19670: PUSH
19671: FOR_TO
19672: IFFALSE 19789
// for _y = min_y to max_y do
19674: LD_ADDR_VAR 0 12
19678: PUSH
19679: DOUBLE
19680: LD_VAR 0 8
19684: DEC
19685: ST_TO_ADDR
19686: LD_VAR 0 10
19690: PUSH
19691: FOR_TO
19692: IFFALSE 19785
// begin if not ValidHex ( _x , _y ) then
19694: LD_VAR 0 11
19698: PPUSH
19699: LD_VAR 0 12
19703: PPUSH
19704: CALL_OW 488
19708: NOT
19709: IFFALSE 19713
// continue ;
19711: GO 19691
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
19713: LD_VAR 0 11
19717: PPUSH
19718: LD_VAR 0 12
19722: PPUSH
19723: CALL_OW 351
19727: PUSH
19728: LD_VAR 0 11
19732: PPUSH
19733: LD_VAR 0 12
19737: PPUSH
19738: CALL_OW 554
19742: AND
19743: IFFALSE 19783
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
19745: LD_ADDR_VAR 0 13
19749: PUSH
19750: LD_VAR 0 13
19754: PPUSH
19755: LD_VAR 0 13
19759: PUSH
19760: LD_INT 1
19762: PLUS
19763: PPUSH
19764: LD_VAR 0 11
19768: PUSH
19769: LD_VAR 0 12
19773: PUSH
19774: EMPTY
19775: LIST
19776: LIST
19777: PPUSH
19778: CALL_OW 2
19782: ST_TO_ADDR
// end ;
19783: GO 19691
19785: POP
19786: POP
19787: GO 19671
19789: POP
19790: POP
// if not list then
19791: LD_VAR 0 13
19795: NOT
19796: IFFALSE 19800
// exit ;
19798: GO 19871
// for i in list do
19800: LD_ADDR_VAR 0 6
19804: PUSH
19805: LD_VAR 0 13
19809: PUSH
19810: FOR_IN
19811: IFFALSE 19869
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
19813: LD_VAR 0 1
19817: PPUSH
19818: LD_STRING M
19820: PUSH
19821: LD_VAR 0 6
19825: PUSH
19826: LD_INT 1
19828: ARRAY
19829: PUSH
19830: LD_VAR 0 6
19834: PUSH
19835: LD_INT 2
19837: ARRAY
19838: PUSH
19839: LD_INT 0
19841: PUSH
19842: LD_INT 0
19844: PUSH
19845: LD_INT 0
19847: PUSH
19848: LD_INT 0
19850: PUSH
19851: EMPTY
19852: LIST
19853: LIST
19854: LIST
19855: LIST
19856: LIST
19857: LIST
19858: LIST
19859: PUSH
19860: EMPTY
19861: LIST
19862: PPUSH
19863: CALL_OW 447
19867: GO 19810
19869: POP
19870: POP
// end ;
19871: LD_VAR 0 5
19875: RET
