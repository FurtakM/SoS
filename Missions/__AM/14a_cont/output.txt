// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Init ;
  11: CALL 76 0 0
// PrepareNature ( 4 , 3 , 3 , 5 , 1 , 0 , 0 , natureArea , 0 ) ;
  15: LD_INT 4
  17: PPUSH
  18: LD_INT 3
  20: PPUSH
  21: LD_INT 3
  23: PPUSH
  24: LD_INT 5
  26: PPUSH
  27: LD_INT 1
  29: PPUSH
  30: LD_INT 0
  32: PPUSH
  33: LD_INT 0
  35: PPUSH
  36: LD_INT 6
  38: PPUSH
  39: LD_INT 0
  41: PPUSH
  42: CALL 1029 0 9
// PrepareAmerican ;
  46: CALL 5335 0 0
// PrepareAlliance ;
  50: CALL 226 0 0
// Action ;
  54: CALL 2178 0 0
// SaveForQuickRestart ;
  58: CALL_OW 22
// if debug then
  62: LD_EXP 1
  66: IFFALSE 75
// FogOff ( 7 ) ;
  68: LD_INT 7
  70: PPUSH
  71: CALL_OW 344
// end ;
  75: END
// export debug , activeBombTest , contaminateTime , bombExploded , enteredContaminatedArea , artifactPickedUp , planCaptured , seenBase , stevensTimer , canEnd , missionTime , killCounter , bunkerCounter ; function Init ; begin
  76: LD_INT 0
  78: PPUSH
// debug := false ;
  79: LD_ADDR_EXP 1
  83: PUSH
  84: LD_INT 0
  86: ST_TO_ADDR
// activeBombTest := false ;
  87: LD_ADDR_EXP 2
  91: PUSH
  92: LD_INT 0
  94: ST_TO_ADDR
// bombExploded := false ;
  95: LD_ADDR_EXP 4
  99: PUSH
 100: LD_INT 0
 102: ST_TO_ADDR
// contaminateTime := 0 0$00 ;
 103: LD_ADDR_EXP 3
 107: PUSH
 108: LD_INT 0
 110: ST_TO_ADDR
// enteredContaminatedArea := false ;
 111: LD_ADDR_EXP 5
 115: PUSH
 116: LD_INT 0
 118: ST_TO_ADDR
// artifactPickedUp := false ;
 119: LD_ADDR_EXP 6
 123: PUSH
 124: LD_INT 0
 126: ST_TO_ADDR
// planCaptured := false ;
 127: LD_ADDR_EXP 7
 131: PUSH
 132: LD_INT 0
 134: ST_TO_ADDR
// seenBase := false ;
 135: LD_ADDR_EXP 8
 139: PUSH
 140: LD_INT 0
 142: ST_TO_ADDR
// stevensTimer := [ 20 20$00 , 16 16$00 , 14 14$00 ] [ Difficulty ] ;
 143: LD_ADDR_EXP 9
 147: PUSH
 148: LD_INT 42000
 150: PUSH
 151: LD_INT 33600
 153: PUSH
 154: LD_INT 29400
 156: PUSH
 157: EMPTY
 158: LIST
 159: LIST
 160: LIST
 161: PUSH
 162: LD_OWVAR 67
 166: ARRAY
 167: ST_TO_ADDR
// canEnd := false ;
 168: LD_ADDR_EXP 10
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// missionTime := 0 0$00 ;
 176: LD_ADDR_EXP 11
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// killCounter := 0 ;
 184: LD_ADDR_EXP 12
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// bunkerCounter := 0 ;
 192: LD_ADDR_EXP 13
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// end ;
 200: LD_VAR 0 1
 204: RET
// every 0 0$1 trigger bunkerCounter >= 3 do
 205: LD_EXP 13
 209: PUSH
 210: LD_INT 3
 212: GREATEREQUAL
 213: IFFALSE 225
 215: GO 217
 217: DISABLE
// SetAchievement ( ACH_ONEMANARMY ) ; end_of_file
 218: LD_STRING ACH_ONEMANARMY
 220: PPUSH
 221: CALL_OW 543
 225: END
// export JMM , Burlak , Joan , RuSci ; export function PrepareAlliance ; var tmp , i , JMMVeh , BurlakVeh , VarJMMVeh , VarBurlakVeh ; begin
 226: LD_INT 0
 228: PPUSH
 229: PPUSH
 230: PPUSH
 231: PPUSH
 232: PPUSH
 233: PPUSH
 234: PPUSH
// uc_side := 7 ;
 235: LD_ADDR_OWVAR 20
 239: PUSH
 240: LD_INT 7
 242: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
 243: LD_ADDR_EXP 14
 247: PUSH
 248: LD_STRING JMM
 250: PPUSH
 251: LD_EXP 1
 255: NOT
 256: PPUSH
 257: LD_STRING 14a_
 259: PPUSH
 260: CALL 908 0 3
 264: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
 265: LD_ADDR_EXP 15
 269: PUSH
 270: LD_STRING Burlak
 272: PPUSH
 273: LD_EXP 1
 277: NOT
 278: PPUSH
 279: LD_STRING 14a_
 281: PPUSH
 282: CALL 908 0 3
 286: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
 287: LD_ADDR_EXP 16
 291: PUSH
 292: LD_STRING Joan
 294: PPUSH
 295: LD_EXP 1
 299: NOT
 300: PPUSH
 301: LD_STRING 13a_
 303: PPUSH
 304: CALL 908 0 3
 308: ST_TO_ADDR
// if not Joan then
 309: LD_EXP 16
 313: NOT
 314: IFFALSE 447
// begin tmp := CreateCharacterSet ( 13a_others ) ;
 316: LD_ADDR_VAR 0 2
 320: PUSH
 321: LD_STRING 13a_others
 323: PPUSH
 324: CALL_OW 31
 328: ST_TO_ADDR
// if tmp then
 329: LD_VAR 0 2
 333: IFFALSE 409
// begin for i in tmp do
 335: LD_ADDR_VAR 0 3
 339: PUSH
 340: LD_VAR 0 2
 344: PUSH
 345: FOR_IN
 346: IFFALSE 407
// if GetClass ( i ) = 4 and GetSex ( i ) = sex_male and GetNation ( i ) = nation_russian then
 348: LD_VAR 0 3
 352: PPUSH
 353: CALL_OW 257
 357: PUSH
 358: LD_INT 4
 360: EQUAL
 361: PUSH
 362: LD_VAR 0 3
 366: PPUSH
 367: CALL_OW 258
 371: PUSH
 372: LD_INT 1
 374: EQUAL
 375: AND
 376: PUSH
 377: LD_VAR 0 3
 381: PPUSH
 382: CALL_OW 248
 386: PUSH
 387: LD_INT 3
 389: EQUAL
 390: AND
 391: IFFALSE 405
// begin RuSci := i ;
 393: LD_ADDR_EXP 17
 397: PUSH
 398: LD_VAR 0 3
 402: ST_TO_ADDR
// break ;
 403: GO 407
// end ;
 405: GO 345
 407: POP
 408: POP
// end ; if not RuSci then
 409: LD_EXP 17
 413: NOT
 414: IFFALSE 447
// begin uc_nation := 3 ;
 416: LD_ADDR_OWVAR 21
 420: PUSH
 421: LD_INT 3
 423: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 10 ) ;
 424: LD_INT 1
 426: PPUSH
 427: LD_INT 4
 429: PPUSH
 430: LD_INT 10
 432: PPUSH
 433: CALL_OW 380
// RuSci := CreateHuman ;
 437: LD_ADDR_EXP 17
 441: PUSH
 442: CALL_OW 44
 446: ST_TO_ADDR
// end ; end ; VarJMMVeh := LoadVariable ( 14a_JMMVeh , [ us_morphling , engine_siberite , control_manual , us_rocket_launcher , 0 , 1 ] ) ;
 447: LD_ADDR_VAR 0 6
 451: PUSH
 452: LD_STRING 14a_JMMVeh
 454: PPUSH
 455: LD_INT 5
 457: PUSH
 458: LD_INT 3
 460: PUSH
 461: LD_INT 1
 463: PUSH
 464: LD_INT 7
 466: PUSH
 467: LD_INT 0
 469: PUSH
 470: LD_INT 1
 472: PUSH
 473: EMPTY
 474: LIST
 475: LIST
 476: LIST
 477: LIST
 478: LIST
 479: LIST
 480: PPUSH
 481: CALL_OW 30
 485: ST_TO_ADDR
// VarBurlakVeh := LoadVariable ( 14a_BurlakVeh , [ ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 0 , 3 ] ) ;
 486: LD_ADDR_VAR 0 7
 490: PUSH
 491: LD_STRING 14a_BurlakVeh
 493: PPUSH
 494: LD_INT 22
 496: PUSH
 497: LD_INT 3
 499: PUSH
 500: LD_INT 1
 502: PUSH
 503: LD_INT 51
 505: PUSH
 506: LD_INT 0
 508: PUSH
 509: LD_INT 3
 511: PUSH
 512: EMPTY
 513: LIST
 514: LIST
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: PPUSH
 520: CALL_OW 30
 524: ST_TO_ADDR
// uc_direction := 4 ;
 525: LD_ADDR_OWVAR 24
 529: PUSH
 530: LD_INT 4
 532: ST_TO_ADDR
// uc_nation := VarJMMVeh [ 6 ] ;
 533: LD_ADDR_OWVAR 21
 537: PUSH
 538: LD_VAR 0 6
 542: PUSH
 543: LD_INT 6
 545: ARRAY
 546: ST_TO_ADDR
// PrepareVehicle ( VarJMMVeh [ 1 ] , VarJMMVeh [ 2 ] , VarJMMVeh [ 3 ] , VarJMMVeh [ 4 ] , rand ( 60 , 80 ) ) ;
 547: LD_VAR 0 6
 551: PUSH
 552: LD_INT 1
 554: ARRAY
 555: PPUSH
 556: LD_VAR 0 6
 560: PUSH
 561: LD_INT 2
 563: ARRAY
 564: PPUSH
 565: LD_VAR 0 6
 569: PUSH
 570: LD_INT 3
 572: ARRAY
 573: PPUSH
 574: LD_VAR 0 6
 578: PUSH
 579: LD_INT 4
 581: ARRAY
 582: PPUSH
 583: LD_INT 60
 585: PPUSH
 586: LD_INT 80
 588: PPUSH
 589: CALL_OW 12
 593: PPUSH
 594: CALL 971 0 5
// JMMVeh := CreateVehicle ;
 598: LD_ADDR_VAR 0 4
 602: PUSH
 603: CALL_OW 45
 607: ST_TO_ADDR
// PlaceUnitInArea ( JMMVeh , startArea , false ) ;
 608: LD_VAR 0 4
 612: PPUSH
 613: LD_INT 1
 615: PPUSH
 616: LD_INT 0
 618: PPUSH
 619: CALL 1633 0 3
// if VarJMMVeh [ 5 ] <> 0 then
 623: LD_VAR 0 6
 627: PUSH
 628: LD_INT 5
 630: ARRAY
 631: PUSH
 632: LD_INT 0
 634: NONEQUAL
 635: IFFALSE 655
// SetMark ( JMMVeh , VarJMMVeh [ 5 ] ) ;
 637: LD_VAR 0 4
 641: PPUSH
 642: LD_VAR 0 6
 646: PUSH
 647: LD_INT 5
 649: ARRAY
 650: PPUSH
 651: CALL_OW 242
// PlaceHumanInUnit ( JMM , JMMVeh ) ;
 655: LD_EXP 14
 659: PPUSH
 660: LD_VAR 0 4
 664: PPUSH
 665: CALL_OW 52
// uc_nation := VarBurlakVeh [ 6 ] ;
 669: LD_ADDR_OWVAR 21
 673: PUSH
 674: LD_VAR 0 7
 678: PUSH
 679: LD_INT 6
 681: ARRAY
 682: ST_TO_ADDR
// PrepareVehicle ( VarBurlakVeh [ 1 ] , VarBurlakVeh [ 2 ] , VarBurlakVeh [ 3 ] , VarBurlakVeh [ 4 ] , rand ( 60 , 80 ) ) ;
 683: LD_VAR 0 7
 687: PUSH
 688: LD_INT 1
 690: ARRAY
 691: PPUSH
 692: LD_VAR 0 7
 696: PUSH
 697: LD_INT 2
 699: ARRAY
 700: PPUSH
 701: LD_VAR 0 7
 705: PUSH
 706: LD_INT 3
 708: ARRAY
 709: PPUSH
 710: LD_VAR 0 7
 714: PUSH
 715: LD_INT 4
 717: ARRAY
 718: PPUSH
 719: LD_INT 60
 721: PPUSH
 722: LD_INT 80
 724: PPUSH
 725: CALL_OW 12
 729: PPUSH
 730: CALL 971 0 5
// BurlakVeh := CreateVehicle ;
 734: LD_ADDR_VAR 0 5
 738: PUSH
 739: CALL_OW 45
 743: ST_TO_ADDR
// if not PlaceUnitInArea ( BurlakVeh , startArea , false ) then
 744: LD_VAR 0 5
 748: PPUSH
 749: LD_INT 1
 751: PPUSH
 752: LD_INT 0
 754: PPUSH
 755: CALL 1633 0 3
 759: NOT
 760: IFFALSE 780
// PlaceUnitXY ( BurlakVeh , 233 , 85 , false ) ;
 762: LD_VAR 0 5
 766: PPUSH
 767: LD_INT 233
 769: PPUSH
 770: LD_INT 85
 772: PPUSH
 773: LD_INT 0
 775: PPUSH
 776: CALL_OW 48
// if VarBurlakVeh [ 5 ] <> 0 then
 780: LD_VAR 0 7
 784: PUSH
 785: LD_INT 5
 787: ARRAY
 788: PUSH
 789: LD_INT 0
 791: NONEQUAL
 792: IFFALSE 812
// SetMark ( BurlakVeh , VarBurlakVeh [ 5 ] ) ;
 794: LD_VAR 0 5
 798: PPUSH
 799: LD_VAR 0 7
 803: PUSH
 804: LD_INT 5
 806: ARRAY
 807: PPUSH
 808: CALL_OW 242
// PlaceHumanInUnit ( Burlak , BurlakVeh ) ;
 812: LD_EXP 15
 816: PPUSH
 817: LD_VAR 0 5
 821: PPUSH
 822: CALL_OW 52
// tmp := [ [ 178 , 91 ] , [ 137 , 83 ] , [ 157 , 75 ] ] [ Difficulty ] ;
 826: LD_ADDR_VAR 0 2
 830: PUSH
 831: LD_INT 178
 833: PUSH
 834: LD_INT 91
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: PUSH
 841: LD_INT 137
 843: PUSH
 844: LD_INT 83
 846: PUSH
 847: EMPTY
 848: LIST
 849: LIST
 850: PUSH
 851: LD_INT 157
 853: PUSH
 854: LD_INT 75
 856: PUSH
 857: EMPTY
 858: LIST
 859: LIST
 860: PUSH
 861: EMPTY
 862: LIST
 863: LIST
 864: LIST
 865: PUSH
 866: LD_OWVAR 67
 870: ARRAY
 871: ST_TO_ADDR
// CreateResourcesXY ( mat_artifact , 4 , tmp [ 1 ] , tmp [ 2 ] , false ) ;
 872: LD_INT 4
 874: PPUSH
 875: LD_INT 4
 877: PPUSH
 878: LD_VAR 0 2
 882: PUSH
 883: LD_INT 1
 885: ARRAY
 886: PPUSH
 887: LD_VAR 0 2
 891: PUSH
 892: LD_INT 2
 894: ARRAY
 895: PPUSH
 896: LD_INT 0
 898: PPUSH
 899: CALL_OW 58
// end ; end_of_file
 903: LD_VAR 0 1
 907: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 908: LD_INT 0
 910: PPUSH
 911: PPUSH
// if exist_mode then
 912: LD_VAR 0 2
 916: IFFALSE 941
// unit := CreateCharacter ( prefix & ident ) else
 918: LD_ADDR_VAR 0 5
 922: PUSH
 923: LD_VAR 0 3
 927: PUSH
 928: LD_VAR 0 1
 932: STR
 933: PPUSH
 934: CALL_OW 34
 938: ST_TO_ADDR
 939: GO 956
// unit := NewCharacter ( ident ) ;
 941: LD_ADDR_VAR 0 5
 945: PUSH
 946: LD_VAR 0 1
 950: PPUSH
 951: CALL_OW 25
 955: ST_TO_ADDR
// result := unit ;
 956: LD_ADDR_VAR 0 4
 960: PUSH
 961: LD_VAR 0 5
 965: ST_TO_ADDR
// end ;
 966: LD_VAR 0 4
 970: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
 971: LD_INT 0
 973: PPUSH
// vc_chassis := chassis ;
 974: LD_ADDR_OWVAR 37
 978: PUSH
 979: LD_VAR 0 1
 983: ST_TO_ADDR
// vc_engine := engine ;
 984: LD_ADDR_OWVAR 39
 988: PUSH
 989: LD_VAR 0 2
 993: ST_TO_ADDR
// vc_control := control ;
 994: LD_ADDR_OWVAR 38
 998: PUSH
 999: LD_VAR 0 3
1003: ST_TO_ADDR
// vc_weapon := weapon ;
1004: LD_ADDR_OWVAR 40
1008: PUSH
1009: LD_VAR 0 4
1013: ST_TO_ADDR
// vc_fuel_battery := fuel ;
1014: LD_ADDR_OWVAR 41
1018: PUSH
1019: LD_VAR 0 5
1023: ST_TO_ADDR
// end ;
1024: LD_VAR 0 6
1028: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
1029: LD_INT 0
1031: PPUSH
1032: PPUSH
1033: PPUSH
// uc_side = 0 ;
1034: LD_ADDR_OWVAR 20
1038: PUSH
1039: LD_INT 0
1041: ST_TO_ADDR
// uc_nation = 0 ;
1042: LD_ADDR_OWVAR 21
1046: PUSH
1047: LD_INT 0
1049: ST_TO_ADDR
// InitHc ;
1050: CALL_OW 19
// InitVc ;
1054: CALL_OW 20
// if mastodonts then
1058: LD_VAR 0 6
1062: IFFALSE 1129
// for i = 1 to mastodonts do
1064: LD_ADDR_VAR 0 11
1068: PUSH
1069: DOUBLE
1070: LD_INT 1
1072: DEC
1073: ST_TO_ADDR
1074: LD_VAR 0 6
1078: PUSH
1079: FOR_TO
1080: IFFALSE 1127
// begin vc_chassis := 31 ;
1082: LD_ADDR_OWVAR 37
1086: PUSH
1087: LD_INT 31
1089: ST_TO_ADDR
// vc_control := control_rider ;
1090: LD_ADDR_OWVAR 38
1094: PUSH
1095: LD_INT 4
1097: ST_TO_ADDR
// animal := CreateVehicle ;
1098: LD_ADDR_VAR 0 12
1102: PUSH
1103: CALL_OW 45
1107: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1108: LD_VAR 0 12
1112: PPUSH
1113: LD_VAR 0 8
1117: PPUSH
1118: LD_INT 0
1120: PPUSH
1121: CALL 1633 0 3
// end ;
1125: GO 1079
1127: POP
1128: POP
// if horses then
1129: LD_VAR 0 5
1133: IFFALSE 1200
// for i = 1 to horses do
1135: LD_ADDR_VAR 0 11
1139: PUSH
1140: DOUBLE
1141: LD_INT 1
1143: DEC
1144: ST_TO_ADDR
1145: LD_VAR 0 5
1149: PUSH
1150: FOR_TO
1151: IFFALSE 1198
// begin hc_class := 21 ;
1153: LD_ADDR_OWVAR 28
1157: PUSH
1158: LD_INT 21
1160: ST_TO_ADDR
// hc_gallery :=  ;
1161: LD_ADDR_OWVAR 33
1165: PUSH
1166: LD_STRING 
1168: ST_TO_ADDR
// animal := CreateHuman ;
1169: LD_ADDR_VAR 0 12
1173: PUSH
1174: CALL_OW 44
1178: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1179: LD_VAR 0 12
1183: PPUSH
1184: LD_VAR 0 8
1188: PPUSH
1189: LD_INT 0
1191: PPUSH
1192: CALL 1633 0 3
// end ;
1196: GO 1150
1198: POP
1199: POP
// if birds then
1200: LD_VAR 0 1
1204: IFFALSE 1271
// for i = 1 to birds do
1206: LD_ADDR_VAR 0 11
1210: PUSH
1211: DOUBLE
1212: LD_INT 1
1214: DEC
1215: ST_TO_ADDR
1216: LD_VAR 0 1
1220: PUSH
1221: FOR_TO
1222: IFFALSE 1269
// begin hc_class = 18 ;
1224: LD_ADDR_OWVAR 28
1228: PUSH
1229: LD_INT 18
1231: ST_TO_ADDR
// hc_gallery =  ;
1232: LD_ADDR_OWVAR 33
1236: PUSH
1237: LD_STRING 
1239: ST_TO_ADDR
// animal := CreateHuman ;
1240: LD_ADDR_VAR 0 12
1244: PUSH
1245: CALL_OW 44
1249: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1250: LD_VAR 0 12
1254: PPUSH
1255: LD_VAR 0 8
1259: PPUSH
1260: LD_INT 0
1262: PPUSH
1263: CALL 1633 0 3
// end ;
1267: GO 1221
1269: POP
1270: POP
// if tigers then
1271: LD_VAR 0 2
1275: IFFALSE 1359
// for i = 1 to tigers do
1277: LD_ADDR_VAR 0 11
1281: PUSH
1282: DOUBLE
1283: LD_INT 1
1285: DEC
1286: ST_TO_ADDR
1287: LD_VAR 0 2
1291: PUSH
1292: FOR_TO
1293: IFFALSE 1357
// begin hc_class = class_tiger ;
1295: LD_ADDR_OWVAR 28
1299: PUSH
1300: LD_INT 14
1302: ST_TO_ADDR
// hc_gallery =  ;
1303: LD_ADDR_OWVAR 33
1307: PUSH
1308: LD_STRING 
1310: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
1311: LD_ADDR_OWVAR 35
1315: PUSH
1316: LD_INT 7
1318: NEG
1319: PPUSH
1320: LD_INT 7
1322: PPUSH
1323: CALL_OW 12
1327: ST_TO_ADDR
// animal := CreateHuman ;
1328: LD_ADDR_VAR 0 12
1332: PUSH
1333: CALL_OW 44
1337: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1338: LD_VAR 0 12
1342: PPUSH
1343: LD_VAR 0 8
1347: PPUSH
1348: LD_INT 0
1350: PPUSH
1351: CALL 1633 0 3
// end ;
1355: GO 1292
1357: POP
1358: POP
// if apemans then
1359: LD_VAR 0 3
1363: IFFALSE 1486
// for i = 1 to apemans do
1365: LD_ADDR_VAR 0 11
1369: PUSH
1370: DOUBLE
1371: LD_INT 1
1373: DEC
1374: ST_TO_ADDR
1375: LD_VAR 0 3
1379: PUSH
1380: FOR_TO
1381: IFFALSE 1484
// begin hc_class = class_apeman ;
1383: LD_ADDR_OWVAR 28
1387: PUSH
1388: LD_INT 12
1390: ST_TO_ADDR
// hc_gallery =  ;
1391: LD_ADDR_OWVAR 33
1395: PUSH
1396: LD_STRING 
1398: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
1399: LD_ADDR_OWVAR 35
1403: PUSH
1404: LD_INT 5
1406: NEG
1407: PPUSH
1408: LD_INT 5
1410: PPUSH
1411: CALL_OW 12
1415: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
1416: LD_ADDR_OWVAR 31
1420: PUSH
1421: LD_INT 1
1423: PPUSH
1424: LD_INT 3
1426: PPUSH
1427: CALL_OW 12
1431: PUSH
1432: LD_INT 1
1434: PPUSH
1435: LD_INT 3
1437: PPUSH
1438: CALL_OW 12
1442: PUSH
1443: LD_INT 0
1445: PUSH
1446: LD_INT 0
1448: PUSH
1449: EMPTY
1450: LIST
1451: LIST
1452: LIST
1453: LIST
1454: ST_TO_ADDR
// animal := CreateHuman ;
1455: LD_ADDR_VAR 0 12
1459: PUSH
1460: CALL_OW 44
1464: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1465: LD_VAR 0 12
1469: PPUSH
1470: LD_VAR 0 8
1474: PPUSH
1475: LD_INT 0
1477: PPUSH
1478: CALL 1633 0 3
// end ;
1482: GO 1380
1484: POP
1485: POP
// if enchidnas then
1486: LD_VAR 0 4
1490: IFFALSE 1557
// for i = 1 to enchidnas do
1492: LD_ADDR_VAR 0 11
1496: PUSH
1497: DOUBLE
1498: LD_INT 1
1500: DEC
1501: ST_TO_ADDR
1502: LD_VAR 0 4
1506: PUSH
1507: FOR_TO
1508: IFFALSE 1555
// begin hc_class = 13 ;
1510: LD_ADDR_OWVAR 28
1514: PUSH
1515: LD_INT 13
1517: ST_TO_ADDR
// hc_gallery =  ;
1518: LD_ADDR_OWVAR 33
1522: PUSH
1523: LD_STRING 
1525: ST_TO_ADDR
// animal := CreateHuman ;
1526: LD_ADDR_VAR 0 12
1530: PUSH
1531: CALL_OW 44
1535: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1536: LD_VAR 0 12
1540: PPUSH
1541: LD_VAR 0 8
1545: PPUSH
1546: LD_INT 0
1548: PPUSH
1549: CALL 1633 0 3
// end ;
1553: GO 1507
1555: POP
1556: POP
// if fishes then
1557: LD_VAR 0 7
1561: IFFALSE 1628
// for i = 1 to fishes do
1563: LD_ADDR_VAR 0 11
1567: PUSH
1568: DOUBLE
1569: LD_INT 1
1571: DEC
1572: ST_TO_ADDR
1573: LD_VAR 0 7
1577: PUSH
1578: FOR_TO
1579: IFFALSE 1626
// begin hc_class = 20 ;
1581: LD_ADDR_OWVAR 28
1585: PUSH
1586: LD_INT 20
1588: ST_TO_ADDR
// hc_gallery =  ;
1589: LD_ADDR_OWVAR 33
1593: PUSH
1594: LD_STRING 
1596: ST_TO_ADDR
// animal := CreateHuman ;
1597: LD_ADDR_VAR 0 12
1601: PUSH
1602: CALL_OW 44
1606: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
1607: LD_VAR 0 12
1611: PPUSH
1612: LD_VAR 0 9
1616: PPUSH
1617: LD_INT 0
1619: PPUSH
1620: CALL 1633 0 3
// end ;
1624: GO 1578
1626: POP
1627: POP
// end ;
1628: LD_VAR 0 10
1632: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
1633: LD_INT 0
1635: PPUSH
1636: PPUSH
1637: PPUSH
1638: PPUSH
// if not unit or not area then
1639: LD_VAR 0 1
1643: NOT
1644: PUSH
1645: LD_VAR 0 2
1649: NOT
1650: OR
1651: IFFALSE 1655
// exit ;
1653: GO 1819
// tmp := AreaToList ( area , i ) ;
1655: LD_ADDR_VAR 0 6
1659: PUSH
1660: LD_VAR 0 2
1664: PPUSH
1665: LD_VAR 0 5
1669: PPUSH
1670: CALL_OW 517
1674: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
1675: LD_ADDR_VAR 0 5
1679: PUSH
1680: DOUBLE
1681: LD_INT 1
1683: DEC
1684: ST_TO_ADDR
1685: LD_VAR 0 6
1689: PUSH
1690: LD_INT 1
1692: ARRAY
1693: PUSH
1694: FOR_TO
1695: IFFALSE 1817
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
1697: LD_ADDR_VAR 0 7
1701: PUSH
1702: LD_VAR 0 6
1706: PUSH
1707: LD_INT 1
1709: ARRAY
1710: PUSH
1711: LD_VAR 0 5
1715: ARRAY
1716: PUSH
1717: LD_VAR 0 6
1721: PUSH
1722: LD_INT 2
1724: ARRAY
1725: PUSH
1726: LD_VAR 0 5
1730: ARRAY
1731: PUSH
1732: EMPTY
1733: LIST
1734: LIST
1735: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
1736: LD_VAR 0 7
1740: PUSH
1741: LD_INT 1
1743: ARRAY
1744: PPUSH
1745: LD_VAR 0 7
1749: PUSH
1750: LD_INT 2
1752: ARRAY
1753: PPUSH
1754: CALL_OW 428
1758: PUSH
1759: LD_INT 0
1761: EQUAL
1762: IFFALSE 1815
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
1764: LD_VAR 0 1
1768: PPUSH
1769: LD_VAR 0 7
1773: PUSH
1774: LD_INT 1
1776: ARRAY
1777: PPUSH
1778: LD_VAR 0 7
1782: PUSH
1783: LD_INT 2
1785: ARRAY
1786: PPUSH
1787: LD_VAR 0 3
1791: PPUSH
1792: CALL_OW 48
// result := IsPlaced ( unit ) ;
1796: LD_ADDR_VAR 0 4
1800: PUSH
1801: LD_VAR 0 1
1805: PPUSH
1806: CALL_OW 305
1810: ST_TO_ADDR
// exit ;
1811: POP
1812: POP
1813: GO 1819
// end ; end ;
1815: GO 1694
1817: POP
1818: POP
// end ;
1819: LD_VAR 0 4
1823: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
1824: LD_INT 0
1826: PPUSH
1827: PPUSH
1828: PPUSH
1829: PPUSH
1830: PPUSH
1831: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
1832: LD_VAR 0 1
1836: NOT
1837: PUSH
1838: LD_VAR 0 1
1842: PPUSH
1843: CALL_OW 263
1847: PUSH
1848: LD_INT 2
1850: EQUAL
1851: NOT
1852: OR
1853: IFFALSE 1857
// exit ;
1855: GO 2173
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
1857: LD_ADDR_VAR 0 6
1861: PUSH
1862: LD_INT 22
1864: PUSH
1865: LD_VAR 0 1
1869: PPUSH
1870: CALL_OW 255
1874: PUSH
1875: EMPTY
1876: LIST
1877: LIST
1878: PUSH
1879: LD_INT 2
1881: PUSH
1882: LD_INT 30
1884: PUSH
1885: LD_INT 36
1887: PUSH
1888: EMPTY
1889: LIST
1890: LIST
1891: PUSH
1892: LD_INT 34
1894: PUSH
1895: LD_INT 31
1897: PUSH
1898: EMPTY
1899: LIST
1900: LIST
1901: PUSH
1902: EMPTY
1903: LIST
1904: LIST
1905: LIST
1906: PUSH
1907: EMPTY
1908: LIST
1909: LIST
1910: PPUSH
1911: CALL_OW 69
1915: ST_TO_ADDR
// if not tmp then
1916: LD_VAR 0 6
1920: NOT
1921: IFFALSE 1925
// exit ;
1923: GO 2173
// result := [ ] ;
1925: LD_ADDR_VAR 0 2
1929: PUSH
1930: EMPTY
1931: ST_TO_ADDR
// for i in tmp do
1932: LD_ADDR_VAR 0 3
1936: PUSH
1937: LD_VAR 0 6
1941: PUSH
1942: FOR_IN
1943: IFFALSE 2014
// begin t := UnitsInside ( i ) ;
1945: LD_ADDR_VAR 0 4
1949: PUSH
1950: LD_VAR 0 3
1954: PPUSH
1955: CALL_OW 313
1959: ST_TO_ADDR
// if t then
1960: LD_VAR 0 4
1964: IFFALSE 2012
// for j in t do
1966: LD_ADDR_VAR 0 7
1970: PUSH
1971: LD_VAR 0 4
1975: PUSH
1976: FOR_IN
1977: IFFALSE 2010
// result := Insert ( result , result + 1 , j ) ;
1979: LD_ADDR_VAR 0 2
1983: PUSH
1984: LD_VAR 0 2
1988: PPUSH
1989: LD_VAR 0 2
1993: PUSH
1994: LD_INT 1
1996: PLUS
1997: PPUSH
1998: LD_VAR 0 7
2002: PPUSH
2003: CALL_OW 2
2007: ST_TO_ADDR
2008: GO 1976
2010: POP
2011: POP
// end ;
2012: GO 1942
2014: POP
2015: POP
// if not result then
2016: LD_VAR 0 2
2020: NOT
2021: IFFALSE 2025
// exit ;
2023: GO 2173
// mech := result [ 1 ] ;
2025: LD_ADDR_VAR 0 5
2029: PUSH
2030: LD_VAR 0 2
2034: PUSH
2035: LD_INT 1
2037: ARRAY
2038: ST_TO_ADDR
// if result > 1 then
2039: LD_VAR 0 2
2043: PUSH
2044: LD_INT 1
2046: GREATER
2047: IFFALSE 2159
// for i = 2 to result do
2049: LD_ADDR_VAR 0 3
2053: PUSH
2054: DOUBLE
2055: LD_INT 2
2057: DEC
2058: ST_TO_ADDR
2059: LD_VAR 0 2
2063: PUSH
2064: FOR_TO
2065: IFFALSE 2157
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
2067: LD_ADDR_VAR 0 4
2071: PUSH
2072: LD_VAR 0 2
2076: PUSH
2077: LD_VAR 0 3
2081: ARRAY
2082: PPUSH
2083: LD_INT 3
2085: PPUSH
2086: CALL_OW 259
2090: PUSH
2091: LD_VAR 0 2
2095: PUSH
2096: LD_VAR 0 3
2100: ARRAY
2101: PPUSH
2102: CALL_OW 432
2106: MINUS
2107: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
2108: LD_VAR 0 4
2112: PUSH
2113: LD_VAR 0 5
2117: PPUSH
2118: LD_INT 3
2120: PPUSH
2121: CALL_OW 259
2125: PUSH
2126: LD_VAR 0 5
2130: PPUSH
2131: CALL_OW 432
2135: MINUS
2136: GREATEREQUAL
2137: IFFALSE 2155
// mech := result [ i ] ;
2139: LD_ADDR_VAR 0 5
2143: PUSH
2144: LD_VAR 0 2
2148: PUSH
2149: LD_VAR 0 3
2153: ARRAY
2154: ST_TO_ADDR
// end ;
2155: GO 2064
2157: POP
2158: POP
// ComLinkTo ( vehicle , mech ) ;
2159: LD_VAR 0 1
2163: PPUSH
2164: LD_VAR 0 5
2168: PPUSH
2169: CALL_OW 135
// end ; end_of_file
2173: LD_VAR 0 2
2177: RET
// export function Action ; begin
2178: LD_INT 0
2180: PPUSH
// InGameOn ;
2181: CALL_OW 8
// CenterNowOnXY ( 221 , 80 ) ;
2185: LD_INT 221
2187: PPUSH
2188: LD_INT 80
2190: PPUSH
2191: CALL_OW 86
// ComMoveXY ( [ JMM , Burlak ] , 217 , 79 ) ;
2195: LD_EXP 14
2199: PUSH
2200: LD_EXP 15
2204: PUSH
2205: EMPTY
2206: LIST
2207: LIST
2208: PPUSH
2209: LD_INT 217
2211: PPUSH
2212: LD_INT 79
2214: PPUSH
2215: CALL_OW 111
// wait ( 0 0$7 ) ;
2219: LD_INT 245
2221: PPUSH
2222: CALL_OW 67
// ComExitVehicle ( [ JMM , Burlak ] ) ;
2226: LD_EXP 14
2230: PUSH
2231: LD_EXP 15
2235: PUSH
2236: EMPTY
2237: LIST
2238: LIST
2239: PPUSH
2240: CALL_OW 121
// Say ( Burlak , D2-Bur-1 ) ;
2244: LD_EXP 15
2248: PPUSH
2249: LD_STRING D2-Bur-1
2251: PPUSH
2252: CALL_OW 88
// Say ( JMM , D2-JMM-1 ) ;
2256: LD_EXP 14
2260: PPUSH
2261: LD_STRING D2-JMM-1
2263: PPUSH
2264: CALL_OW 88
// wait ( 0 0$0.5 ) ;
2268: LD_INT 18
2270: PPUSH
2271: CALL_OW 67
// ComTurnUnit ( Burlak , JMM ) ;
2275: LD_EXP 15
2279: PPUSH
2280: LD_EXP 14
2284: PPUSH
2285: CALL_OW 119
// Say ( Burlak , D2-Bur-2 ) ;
2289: LD_EXP 15
2293: PPUSH
2294: LD_STRING D2-Bur-2
2296: PPUSH
2297: CALL_OW 88
// ComEnterUnit ( Burlak , NearestUnitToUnit ( FilterAllUnits ( [ f_type , unit_vehicle ] ) , Burlak ) ) ;
2301: LD_EXP 15
2305: PPUSH
2306: LD_INT 21
2308: PUSH
2309: LD_INT 2
2311: PUSH
2312: EMPTY
2313: LIST
2314: LIST
2315: PPUSH
2316: CALL_OW 69
2320: PPUSH
2321: LD_EXP 15
2325: PPUSH
2326: CALL_OW 74
2330: PPUSH
2331: CALL_OW 120
// ComEnterUnit ( JMM , NearestUnitToUnit ( FilterAllUnits ( [ f_type , unit_vehicle ] ) , JMM ) ) ;
2335: LD_EXP 14
2339: PPUSH
2340: LD_INT 21
2342: PUSH
2343: LD_INT 2
2345: PUSH
2346: EMPTY
2347: LIST
2348: LIST
2349: PPUSH
2350: CALL_OW 69
2354: PPUSH
2355: LD_EXP 14
2359: PPUSH
2360: CALL_OW 74
2364: PPUSH
2365: CALL_OW 120
// wait ( 0 0$1 ) ;
2369: LD_INT 35
2371: PPUSH
2372: CALL_OW 67
// InGameOff ;
2376: CALL_OW 9
// ChangeMissionObjectives ( MArtPickup ) ;
2380: LD_STRING MArtPickup
2382: PPUSH
2383: CALL_OW 337
// end ;
2387: LD_VAR 0 1
2391: RET
// every 0 0$1 trigger UnitFilter ( guards , [ f_see , 7 ] ) do
2392: LD_EXP 22
2396: PPUSH
2397: LD_INT 101
2399: PUSH
2400: LD_INT 7
2402: PUSH
2403: EMPTY
2404: LIST
2405: LIST
2406: PPUSH
2407: CALL_OW 72
2411: IFFALSE 2440
2413: GO 2415
2415: DISABLE
// begin Say ( Burlak , D3-Bur-1 ) ;
2416: LD_EXP 15
2420: PPUSH
2421: LD_STRING D3-Bur-1
2423: PPUSH
2424: CALL_OW 88
// Say ( JMM , D3-JMM-1 ) ;
2428: LD_EXP 14
2432: PPUSH
2433: LD_STRING D3-JMM-1
2435: PPUSH
2436: CALL_OW 88
// end ;
2440: END
// every 0 0$2 trigger FilterUnitsInArea ( usTestBase , [ f_side , 7 ] ) do
2441: LD_INT 5
2443: PPUSH
2444: LD_INT 22
2446: PUSH
2447: LD_INT 7
2449: PUSH
2450: EMPTY
2451: LIST
2452: LIST
2453: PPUSH
2454: CALL_OW 70
2458: IFFALSE 2789
2460: GO 2462
2462: DISABLE
// begin wait ( 0 0$3 ) ;
2463: LD_INT 105
2465: PPUSH
2466: CALL_OW 67
// DialogueOn ;
2470: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
2474: LD_EXP 14
2478: PPUSH
2479: CALL_OW 87
// Say ( JMM , D3a-JMM-1 ) ;
2483: LD_EXP 14
2487: PPUSH
2488: LD_STRING D3a-JMM-1
2490: PPUSH
2491: CALL_OW 88
// Say ( Burlak , D3a-Bur-1 ) ;
2495: LD_EXP 15
2499: PPUSH
2500: LD_STRING D3a-Bur-1
2502: PPUSH
2503: CALL_OW 88
// Say ( JMM , D3a-JMM-2 ) ;
2507: LD_EXP 14
2511: PPUSH
2512: LD_STRING D3a-JMM-2
2514: PPUSH
2515: CALL_OW 88
// if Joan then
2519: LD_EXP 16
2523: IFFALSE 2539
// SayRadio ( Joan , D3a-Joan-2 ) else
2525: LD_EXP 16
2529: PPUSH
2530: LD_STRING D3a-Joan-2
2532: PPUSH
2533: CALL_OW 94
2537: GO 2551
// SayRadio ( RuSci , D3a-RSci1-2 ) ;
2539: LD_EXP 17
2543: PPUSH
2544: LD_STRING D3a-RSci1-2
2546: PPUSH
2547: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-2 ) ;
2551: LD_EXP 18
2555: PPUSH
2556: LD_STRING D3a-Huck-2
2558: PPUSH
2559: CALL_OW 94
// SayRadio ( Powell , D3a-Pow-2 ) ;
2563: LD_EXP 19
2567: PPUSH
2568: LD_STRING D3a-Pow-2
2570: PPUSH
2571: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-3 ) ;
2575: LD_EXP 18
2579: PPUSH
2580: LD_STRING D3a-Huck-3
2582: PPUSH
2583: CALL_OW 94
// SayRadio ( Powell , D3a-Pow-3 ) ;
2587: LD_EXP 19
2591: PPUSH
2592: LD_STRING D3a-Pow-3
2594: PPUSH
2595: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-4 ) ;
2599: LD_EXP 18
2603: PPUSH
2604: LD_STRING D3a-Huck-4
2606: PPUSH
2607: CALL_OW 94
// Say ( JMM , D3a-JMM-4 ) ;
2611: LD_EXP 14
2615: PPUSH
2616: LD_STRING D3a-JMM-4
2618: PPUSH
2619: CALL_OW 88
// Say ( Burlak , D3a-Bur-4 ) ;
2623: LD_EXP 15
2627: PPUSH
2628: LD_STRING D3a-Bur-4
2630: PPUSH
2631: CALL_OW 88
// if Joan then
2635: LD_EXP 16
2639: IFFALSE 2655
// SayRadio ( Joan , D3a-Joan-4 ) else
2641: LD_EXP 16
2645: PPUSH
2646: LD_STRING D3a-Joan-4
2648: PPUSH
2649: CALL_OW 94
2653: GO 2667
// SayRadio ( RuSci , D3a-RSci1-4 ) ;
2655: LD_EXP 17
2659: PPUSH
2660: LD_STRING D3a-RSci1-4
2662: PPUSH
2663: CALL_OW 94
// PlaceSeeing ( 133 , 43 , 7 , - 10 ) ;
2667: LD_INT 133
2669: PPUSH
2670: LD_INT 43
2672: PPUSH
2673: LD_INT 7
2675: PPUSH
2676: LD_INT 10
2678: NEG
2679: PPUSH
2680: CALL_OW 330
// RemoveSeeing ( 133 , 43 , 7 ) ;
2684: LD_INT 133
2686: PPUSH
2687: LD_INT 43
2689: PPUSH
2690: LD_INT 7
2692: PPUSH
2693: CALL_OW 331
// CenterNowOnXY ( 133 , 43 ) ;
2697: LD_INT 133
2699: PPUSH
2700: LD_INT 43
2702: PPUSH
2703: CALL_OW 86
// dwait ( 0 0$0.3 ) ;
2707: LD_INT 10
2709: PPUSH
2710: CALL_OW 68
// Say ( JMM , D3a-JMM-5 ) ;
2714: LD_EXP 14
2718: PPUSH
2719: LD_STRING D3a-JMM-5
2721: PPUSH
2722: CALL_OW 88
// Say ( Burlak , D3a-Bur-5 ) ;
2726: LD_EXP 15
2730: PPUSH
2731: LD_STRING D3a-Bur-5
2733: PPUSH
2734: CALL_OW 88
// DialogueOff ;
2738: CALL_OW 7
// seenBase := true ;
2742: LD_ADDR_EXP 8
2746: PUSH
2747: LD_INT 1
2749: ST_TO_ADDR
// wait ( [ 0 0$15 , 0 0$12 , 0 0$9 ] [ Difficulty ] ) ;
2750: LD_INT 525
2752: PUSH
2753: LD_INT 420
2755: PUSH
2756: LD_INT 315
2758: PUSH
2759: EMPTY
2760: LIST
2761: LIST
2762: LIST
2763: PUSH
2764: LD_OWVAR 67
2768: ARRAY
2769: PPUSH
2770: CALL_OW 67
// ComAttackPlace ( sibBomb , 142 , 52 ) ;
2774: LD_EXP 21
2778: PPUSH
2779: LD_INT 142
2781: PPUSH
2782: LD_INT 52
2784: PPUSH
2785: CALL_OW 116
// end ;
2789: END
// every 5 5$00 trigger not seenBase and not bombExploded do
2790: LD_EXP 8
2794: NOT
2795: PUSH
2796: LD_EXP 4
2800: NOT
2801: AND
2802: IFFALSE 2822
2804: GO 2806
2806: DISABLE
// ComAttackPlace ( sibBomb , 142 , 52 ) ;
2807: LD_EXP 21
2811: PPUSH
2812: LD_INT 142
2814: PPUSH
2815: LD_INT 52
2817: PPUSH
2818: CALL_OW 116
2822: END
// export function OnBombExploded ( bomb , x , y ) ; var art ; begin
2823: LD_INT 0
2825: PPUSH
2826: PPUSH
// contaminateTime := tick ;
2827: LD_ADDR_EXP 3
2831: PUSH
2832: LD_OWVAR 1
2836: ST_TO_ADDR
// wait ( 0 0$5 ) ;
2837: LD_INT 175
2839: PPUSH
2840: CALL_OW 67
// art := FindArtifact ( 4 ) ;
2844: LD_ADDR_VAR 0 5
2848: PUSH
2849: LD_INT 4
2851: PPUSH
2852: CALL_OW 469
2856: ST_TO_ADDR
// if art then
2857: LD_VAR 0 5
2861: IFFALSE 2900
// if art [ 1 ] = 157 and art [ 2 ] = 75 then
2863: LD_VAR 0 5
2867: PUSH
2868: LD_INT 1
2870: ARRAY
2871: PUSH
2872: LD_INT 157
2874: EQUAL
2875: PUSH
2876: LD_VAR 0 5
2880: PUSH
2881: LD_INT 2
2883: ARRAY
2884: PUSH
2885: LD_INT 75
2887: EQUAL
2888: AND
2889: IFFALSE 2900
// begin YouLost ( Artefact ) ;
2891: LD_STRING Artefact
2893: PPUSH
2894: CALL_OW 104
// exit ;
2898: GO 3052
// end ; if IsOK ( JMM ) and IsOk ( Burlak ) then
2900: LD_EXP 14
2904: PPUSH
2905: CALL_OW 302
2909: PUSH
2910: LD_EXP 15
2914: PPUSH
2915: CALL_OW 302
2919: AND
2920: IFFALSE 2997
// begin DialogueOn ;
2922: CALL_OW 6
// Say ( JMM , D6a-JMM-1 ) ;
2926: LD_EXP 14
2930: PPUSH
2931: LD_STRING D6a-JMM-1
2933: PPUSH
2934: CALL_OW 88
// Say ( Burlak , D6a-Bur-1 ) ;
2938: LD_EXP 15
2942: PPUSH
2943: LD_STRING D6a-Bur-1
2945: PPUSH
2946: CALL_OW 88
// Say ( JMM , D6c-JMM-1 ) ;
2950: LD_EXP 14
2954: PPUSH
2955: LD_STRING D6c-JMM-1
2957: PPUSH
2958: CALL_OW 88
// Say ( Burlak , D6c-Bur-1 ) ;
2962: LD_EXP 15
2966: PPUSH
2967: LD_STRING D6c-Bur-1
2969: PPUSH
2970: CALL_OW 88
// Say ( JMM , D6c-JMM-2 ) ;
2974: LD_EXP 14
2978: PPUSH
2979: LD_STRING D6c-JMM-2
2981: PPUSH
2982: CALL_OW 88
// ChangeMissionObjectives ( MBase ) ;
2986: LD_STRING MBase
2988: PPUSH
2989: CALL_OW 337
// DialogueOff ;
2993: CALL_OW 7
// end ; bombExploded := true ;
2997: LD_ADDR_EXP 4
3001: PUSH
3002: LD_INT 1
3004: ST_TO_ADDR
// wait ( [ 3 3$00 , 2 2$30 , 2 2$00 ] [ Difficulty ] ) ;
3005: LD_INT 6300
3007: PUSH
3008: LD_INT 5250
3010: PUSH
3011: LD_INT 4200
3013: PUSH
3014: EMPTY
3015: LIST
3016: LIST
3017: LIST
3018: PUSH
3019: LD_OWVAR 67
3023: ARRAY
3024: PPUSH
3025: CALL_OW 67
// if IsOk ( JMM ) then
3029: LD_EXP 14
3033: PPUSH
3034: CALL_OW 302
3038: IFFALSE 3052
// Say ( JMM , D8-JMM-1 ) ;
3040: LD_EXP 14
3044: PPUSH
3045: LD_STRING D8-JMM-1
3047: PPUSH
3048: CALL_OW 88
// end ;
3052: LD_VAR 0 4
3056: RET
// every 0 0$1 trigger stevensTimer and not planCaptured and bombExploded do
3057: LD_EXP 9
3061: PUSH
3062: LD_EXP 7
3066: NOT
3067: AND
3068: PUSH
3069: LD_EXP 4
3073: AND
3074: IFFALSE 3129
3076: GO 3078
3078: DISABLE
// begin enable ;
3079: ENABLE
// if FilterUnitsInArea ( usBase , [ f_side , 7 ] ) then
3080: LD_INT 9
3082: PPUSH
3083: LD_INT 22
3085: PUSH
3086: LD_INT 7
3088: PUSH
3089: EMPTY
3090: LIST
3091: LIST
3092: PPUSH
3093: CALL_OW 70
3097: IFFALSE 3115
// stevensTimer := stevensTimer - 0 0$30 else
3099: LD_ADDR_EXP 9
3103: PUSH
3104: LD_EXP 9
3108: PUSH
3109: LD_INT 1050
3111: MINUS
3112: ST_TO_ADDR
3113: GO 3129
// stevensTimer := stevensTimer - 0 0$1 ;
3115: LD_ADDR_EXP 9
3119: PUSH
3120: LD_EXP 9
3124: PUSH
3125: LD_INT 35
3127: MINUS
3128: ST_TO_ADDR
// end ;
3129: END
// every 0 0$1 trigger stevensTimer <= 0 0$00 and not planCaptured do var i , tmp ;
3130: LD_EXP 9
3134: PUSH
3135: LD_INT 0
3137: LESSEQUAL
3138: PUSH
3139: LD_EXP 7
3143: NOT
3144: AND
3145: IFFALSE 3309
3147: GO 3149
3149: DISABLE
3150: LD_INT 0
3152: PPUSH
3153: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
3154: LD_ADDR_VAR 0 2
3158: PUSH
3159: LD_INT 22
3161: PUSH
3162: LD_INT 1
3164: PUSH
3165: EMPTY
3166: LIST
3167: LIST
3168: PUSH
3169: LD_INT 25
3171: PUSH
3172: LD_INT 4
3174: PUSH
3175: EMPTY
3176: LIST
3177: LIST
3178: PUSH
3179: EMPTY
3180: LIST
3181: LIST
3182: PPUSH
3183: CALL_OW 69
3187: ST_TO_ADDR
// for i in tmp do
3188: LD_ADDR_VAR 0 1
3192: PUSH
3193: LD_VAR 0 2
3197: PUSH
3198: FOR_IN
3199: IFFALSE 3252
// begin if IsInUnit ( i ) then
3201: LD_VAR 0 1
3205: PPUSH
3206: CALL_OW 310
3210: IFFALSE 3223
// ComExitBuilding ( i ) else
3212: LD_VAR 0 1
3216: PPUSH
3217: CALL_OW 122
3221: GO 3250
// if not HasTask ( i ) then
3223: LD_VAR 0 1
3227: PPUSH
3228: CALL_OW 314
3232: NOT
3233: IFFALSE 3250
// ComMoveXY ( i , 29 , 56 ) ;
3235: LD_VAR 0 1
3239: PPUSH
3240: LD_INT 29
3242: PPUSH
3243: LD_INT 56
3245: PPUSH
3246: CALL_OW 111
// end ;
3250: GO 3198
3252: POP
3253: POP
// repeat wait ( 0 0$1 ) ;
3254: LD_INT 35
3256: PPUSH
3257: CALL_OW 67
// until FilterUnitsInArea ( stevensEscapeArea , [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
3261: LD_INT 8
3263: PPUSH
3264: LD_INT 22
3266: PUSH
3267: LD_INT 1
3269: PUSH
3270: EMPTY
3271: LIST
3272: LIST
3273: PUSH
3274: LD_INT 25
3276: PUSH
3277: LD_INT 4
3279: PUSH
3280: EMPTY
3281: LIST
3282: LIST
3283: PUSH
3284: EMPTY
3285: LIST
3286: LIST
3287: PPUSH
3288: CALL_OW 70
3292: IFFALSE 3254
// if planCaptured then
3294: LD_EXP 7
3298: IFFALSE 3302
// exit ;
3300: GO 3309
// YouLost ( Time ) ;
3302: LD_STRING Time
3304: PPUSH
3305: CALL_OW 104
// end ;
3309: PPOPN 2
3311: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_distxy , 142 , 52 , 27 ] ] ) and contaminateTime + 6000 > tick and bombExploded do
3312: LD_INT 22
3314: PUSH
3315: LD_INT 7
3317: PUSH
3318: EMPTY
3319: LIST
3320: LIST
3321: PUSH
3322: LD_INT 92
3324: PUSH
3325: LD_INT 142
3327: PUSH
3328: LD_INT 52
3330: PUSH
3331: LD_INT 27
3333: PUSH
3334: EMPTY
3335: LIST
3336: LIST
3337: LIST
3338: LIST
3339: PUSH
3340: EMPTY
3341: LIST
3342: LIST
3343: PPUSH
3344: CALL_OW 69
3348: PUSH
3349: LD_EXP 3
3353: PUSH
3354: LD_INT 6000
3356: PLUS
3357: PUSH
3358: LD_OWVAR 1
3362: GREATER
3363: AND
3364: PUSH
3365: LD_EXP 4
3369: AND
3370: IFFALSE 3425
3372: GO 3374
3374: DISABLE
// begin CenterOnUnits ( [ JMM , Burlak ] ) ;
3375: LD_EXP 14
3379: PUSH
3380: LD_EXP 15
3384: PUSH
3385: EMPTY
3386: LIST
3387: LIST
3388: PPUSH
3389: CALL_OW 85
// DialogueOn ;
3393: CALL_OW 6
// Say ( JMM , D6b-JMM-1 ) ;
3397: LD_EXP 14
3401: PPUSH
3402: LD_STRING D6b-JMM-1
3404: PPUSH
3405: CALL_OW 88
// Say ( Burlak , D6b-Bur-1 ) ;
3409: LD_EXP 15
3413: PPUSH
3414: LD_STRING D6b-Bur-1
3416: PPUSH
3417: CALL_OW 88
// DialogueOff ;
3421: CALL_OW 7
// end ;
3425: END
// every 0 0$1 trigger ( GetDistUnitXY ( Burlak , 142 , 52 ) < 25 or GetDistUnitXY ( IsInUnit ( Burlak ) , 142 , 52 ) < 25 ) and GetLives ( Burlak ) < 1000 and contaminateTime + 6000 > tick and bombExploded do
3426: LD_EXP 15
3430: PPUSH
3431: LD_INT 142
3433: PPUSH
3434: LD_INT 52
3436: PPUSH
3437: CALL_OW 297
3441: PUSH
3442: LD_INT 25
3444: LESS
3445: PUSH
3446: LD_EXP 15
3450: PPUSH
3451: CALL_OW 310
3455: PPUSH
3456: LD_INT 142
3458: PPUSH
3459: LD_INT 52
3461: PPUSH
3462: CALL_OW 297
3466: PUSH
3467: LD_INT 25
3469: LESS
3470: OR
3471: PUSH
3472: LD_EXP 15
3476: PPUSH
3477: CALL_OW 256
3481: PUSH
3482: LD_INT 1000
3484: LESS
3485: AND
3486: PUSH
3487: LD_EXP 3
3491: PUSH
3492: LD_INT 6000
3494: PLUS
3495: PUSH
3496: LD_OWVAR 1
3500: GREATER
3501: AND
3502: PUSH
3503: LD_EXP 4
3507: AND
3508: IFFALSE 3541
3510: GO 3512
3512: DISABLE
// begin DialogueOn ;
3513: CALL_OW 6
// Say ( Burlak , D7-Bur-1 ) ;
3517: LD_EXP 15
3521: PPUSH
3522: LD_STRING D7-Bur-1
3524: PPUSH
3525: CALL_OW 88
// enteredContaminatedArea := true ;
3529: LD_ADDR_EXP 5
3533: PUSH
3534: LD_INT 1
3536: ST_TO_ADDR
// DialogueOff ;
3537: CALL_OW 7
// end ;
3541: END
// every 0 0$1 trigger ( GetDistUnitXY ( JMM , 142 , 52 ) < 25 or GetDistUnitXY ( IsInUnit ( JMM ) , 142 , 52 ) < 25 ) and GetLives ( JMM ) < 1000 and contaminateTime + 6000 > tick and bombExploded do
3542: LD_EXP 14
3546: PPUSH
3547: LD_INT 142
3549: PPUSH
3550: LD_INT 52
3552: PPUSH
3553: CALL_OW 297
3557: PUSH
3558: LD_INT 25
3560: LESS
3561: PUSH
3562: LD_EXP 14
3566: PPUSH
3567: CALL_OW 310
3571: PPUSH
3572: LD_INT 142
3574: PPUSH
3575: LD_INT 52
3577: PPUSH
3578: CALL_OW 297
3582: PUSH
3583: LD_INT 25
3585: LESS
3586: OR
3587: PUSH
3588: LD_EXP 14
3592: PPUSH
3593: CALL_OW 256
3597: PUSH
3598: LD_INT 1000
3600: LESS
3601: AND
3602: PUSH
3603: LD_EXP 3
3607: PUSH
3608: LD_INT 6000
3610: PLUS
3611: PUSH
3612: LD_OWVAR 1
3616: GREATER
3617: AND
3618: PUSH
3619: LD_EXP 4
3623: AND
3624: IFFALSE 3657
3626: GO 3628
3628: DISABLE
// begin DialogueOn ;
3629: CALL_OW 6
// Say ( JMM , D7-JMM-1 ) ;
3633: LD_EXP 14
3637: PPUSH
3638: LD_STRING D7-JMM-1
3640: PPUSH
3641: CALL_OW 88
// enteredContaminatedArea := true ;
3645: LD_ADDR_EXP 5
3649: PUSH
3650: LD_INT 1
3652: ST_TO_ADDR
// DialogueOff ;
3653: CALL_OW 7
// end ;
3657: END
// every 0 0$1 trigger artifactPickedUp and IsOk ( JMM ) and IsOk ( Burlak ) do
3658: LD_EXP 6
3662: PUSH
3663: LD_EXP 14
3667: PPUSH
3668: CALL_OW 302
3672: AND
3673: PUSH
3674: LD_EXP 15
3678: PPUSH
3679: CALL_OW 302
3683: AND
3684: IFFALSE 3753
3686: GO 3688
3688: DISABLE
// begin DialogueOn ;
3689: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Burlak ] ) ;
3693: LD_EXP 14
3697: PUSH
3698: LD_EXP 15
3702: PUSH
3703: EMPTY
3704: LIST
3705: LIST
3706: PPUSH
3707: CALL_OW 87
// Say ( JMM , D4-JMM-1 ) ;
3711: LD_EXP 14
3715: PPUSH
3716: LD_STRING D4-JMM-1
3718: PPUSH
3719: CALL_OW 88
// if not bombExploded then
3723: LD_EXP 4
3727: NOT
3728: IFFALSE 3742
// Say ( Burlak , D4-Bur-1 ) ;
3730: LD_EXP 15
3734: PPUSH
3735: LD_STRING D4-Bur-1
3737: PPUSH
3738: CALL_OW 88
// DialogueOff ;
3742: CALL_OW 7
// ChangeMissionObjectives ( MReturn ) ;
3746: LD_STRING MReturn
3748: PPUSH
3749: CALL_OW 337
// end ;
3753: END
// every 0 0$2 trigger not planCaptured and FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , us_dep_north , 6 ] ] ) do
3754: LD_EXP 7
3758: NOT
3759: PUSH
3760: LD_INT 22
3762: PUSH
3763: LD_INT 7
3765: PUSH
3766: EMPTY
3767: LIST
3768: LIST
3769: PUSH
3770: LD_INT 91
3772: PUSH
3773: LD_INT 9
3775: PUSH
3776: LD_INT 6
3778: PUSH
3779: EMPTY
3780: LIST
3781: LIST
3782: LIST
3783: PUSH
3784: EMPTY
3785: LIST
3786: LIST
3787: PPUSH
3788: CALL_OW 69
3792: AND
3793: IFFALSE 3870
3795: GO 3797
3797: DISABLE
// begin DialogueOn ;
3798: CALL_OW 6
// PlaceSeeing ( 55 , 11 , 7 , - 6 ) ;
3802: LD_INT 55
3804: PPUSH
3805: LD_INT 11
3807: PPUSH
3808: LD_INT 7
3810: PPUSH
3811: LD_INT 6
3813: NEG
3814: PPUSH
3815: CALL_OW 330
// RemoveSeeing ( 55 , 11 , 7 ) ;
3819: LD_INT 55
3821: PPUSH
3822: LD_INT 11
3824: PPUSH
3825: LD_INT 7
3827: PPUSH
3828: CALL_OW 331
// Say ( Burlak , D9-Bur-1 ) ;
3832: LD_EXP 15
3836: PPUSH
3837: LD_STRING D9-Bur-1
3839: PPUSH
3840: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
3844: LD_EXP 14
3848: PPUSH
3849: LD_STRING D9-JMM-1
3851: PPUSH
3852: CALL_OW 88
// DialogueOff ;
3856: CALL_OW 7
// SetSide ( us_dep_north , 7 ) ;
3860: LD_INT 9
3862: PPUSH
3863: LD_INT 7
3865: PPUSH
3866: CALL_OW 235
// end ;
3870: END
// every 0 0$1 trigger FilterUnitsInArea ( usBase , [ f_side , 7 ] ) do
3871: LD_INT 9
3873: PPUSH
3874: LD_INT 22
3876: PUSH
3877: LD_INT 7
3879: PUSH
3880: EMPTY
3881: LIST
3882: LIST
3883: PPUSH
3884: CALL_OW 70
3888: IFFALSE 3924
3890: GO 3892
3892: DISABLE
// begin wait ( 0 0$07 ) ;
3893: LD_INT 245
3895: PPUSH
3896: CALL_OW 67
// Say ( JMM , D10b-JMM-1 ) ;
3900: LD_EXP 14
3904: PPUSH
3905: LD_STRING D10b-JMM-1
3907: PPUSH
3908: CALL_OW 88
// Say ( Burlak , D10b-Bur-1 ) ;
3912: LD_EXP 15
3916: PPUSH
3917: LD_STRING D10b-Bur-1
3919: PPUSH
3920: CALL_OW 88
// end ;
3924: END
// every 0 0$1 trigger stevensTimer and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) and ( GetSide ( us_depot ) = 7 or FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) = 0 ) do var i ;
3925: LD_EXP 9
3929: PUSH
3930: LD_INT 22
3932: PUSH
3933: LD_INT 1
3935: PUSH
3936: EMPTY
3937: LIST
3938: LIST
3939: PUSH
3940: LD_INT 25
3942: PUSH
3943: LD_INT 4
3945: PUSH
3946: EMPTY
3947: LIST
3948: LIST
3949: PUSH
3950: LD_INT 26
3952: PUSH
3953: LD_INT 1
3955: PUSH
3956: EMPTY
3957: LIST
3958: LIST
3959: PUSH
3960: EMPTY
3961: LIST
3962: LIST
3963: LIST
3964: PPUSH
3965: CALL_OW 69
3969: AND
3970: PUSH
3971: LD_INT 5
3973: PPUSH
3974: CALL_OW 255
3978: PUSH
3979: LD_INT 7
3981: EQUAL
3982: PUSH
3983: LD_INT 22
3985: PUSH
3986: LD_INT 1
3988: PUSH
3989: EMPTY
3990: LIST
3991: LIST
3992: PUSH
3993: LD_INT 25
3995: PUSH
3996: LD_INT 1
3998: PUSH
3999: EMPTY
4000: LIST
4001: LIST
4002: PUSH
4003: EMPTY
4004: LIST
4005: LIST
4006: PPUSH
4007: CALL_OW 69
4011: PUSH
4012: LD_INT 0
4014: EQUAL
4015: OR
4016: AND
4017: IFFALSE 4606
4019: GO 4021
4021: DISABLE
4022: LD_INT 0
4024: PPUSH
// begin case Query ( QKill ) of 1 :
4025: LD_STRING QKill
4027: PPUSH
4028: CALL_OW 97
4032: PUSH
4033: LD_INT 1
4035: DOUBLE
4036: EQUAL
4037: IFTRUE 4041
4039: GO 4594
4041: POP
// begin DialogueOn ;
4042: CALL_OW 6
// Say ( JMM , D10a-JMM-1 ) ;
4046: LD_EXP 14
4050: PPUSH
4051: LD_STRING D10a-JMM-1
4053: PPUSH
4054: CALL_OW 88
// Say ( Burlak , D10a-Bur-1 ) ;
4058: LD_EXP 15
4062: PPUSH
4063: LD_STRING D10a-Bur-1
4065: PPUSH
4066: CALL_OW 88
// Say ( JMM , D10a-JMM-2 ) ;
4070: LD_EXP 14
4074: PPUSH
4075: LD_STRING D10a-JMM-2
4077: PPUSH
4078: CALL_OW 88
// if IsOk ( Stevens ) then
4082: LD_EXP 18
4086: PPUSH
4087: CALL_OW 302
4091: IFFALSE 4107
// Say ( Stevens , D10a-Huck-2 ) else
4093: LD_EXP 18
4097: PPUSH
4098: LD_STRING D10a-Huck-2
4100: PPUSH
4101: CALL_OW 88
4105: GO 4158
// Say ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) [ 1 ] , D10a-ASci1-3 ) ;
4107: LD_INT 22
4109: PUSH
4110: LD_INT 1
4112: PUSH
4113: EMPTY
4114: LIST
4115: LIST
4116: PUSH
4117: LD_INT 25
4119: PUSH
4120: LD_INT 4
4122: PUSH
4123: EMPTY
4124: LIST
4125: LIST
4126: PUSH
4127: LD_INT 26
4129: PUSH
4130: LD_INT 1
4132: PUSH
4133: EMPTY
4134: LIST
4135: LIST
4136: PUSH
4137: EMPTY
4138: LIST
4139: LIST
4140: LIST
4141: PPUSH
4142: CALL_OW 69
4146: PUSH
4147: LD_INT 1
4149: ARRAY
4150: PPUSH
4151: LD_STRING D10a-ASci1-3
4153: PPUSH
4154: CALL_OW 88
// Say ( JMM , D10a-JMM-4 ) ;
4158: LD_EXP 14
4162: PPUSH
4163: LD_STRING D10a-JMM-4
4165: PPUSH
4166: CALL_OW 88
// if IsOk ( Stevens ) then
4170: LD_EXP 18
4174: PPUSH
4175: CALL_OW 302
4179: IFFALSE 4193
// Say ( Stevens , D10a-Huck-3 ) ;
4181: LD_EXP 18
4185: PPUSH
4186: LD_STRING D10a-Huck-3
4188: PPUSH
4189: CALL_OW 88
// DialogueOff ;
4193: CALL_OW 7
// SetAttitude ( 1 , 7 , att_friend , true ) ;
4197: LD_INT 1
4199: PPUSH
4200: LD_INT 7
4202: PPUSH
4203: LD_INT 1
4205: PPUSH
4206: LD_INT 1
4208: PPUSH
4209: CALL_OW 80
// planCaptured := true ;
4213: LD_ADDR_EXP 7
4217: PUSH
4218: LD_INT 1
4220: ST_TO_ADDR
// ChangeMissionObjectives ( MEnd ) ;
4221: LD_STRING MEnd
4223: PPUSH
4224: CALL_OW 337
// SetAchievement ( ACH_DIPLOMACY ) ;
4228: LD_STRING ACH_DIPLOMACY
4230: PPUSH
4231: CALL_OW 543
// canEnd := true ;
4235: LD_ADDR_EXP 10
4239: PUSH
4240: LD_INT 1
4242: ST_TO_ADDR
// missionTime := tick ;
4243: LD_ADDR_EXP 11
4247: PUSH
4248: LD_OWVAR 1
4252: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4253: LD_INT 35
4255: PPUSH
4256: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] ] ) then
4260: LD_INT 22
4262: PUSH
4263: LD_INT 1
4265: PUSH
4266: EMPTY
4267: LIST
4268: LIST
4269: PUSH
4270: LD_INT 3
4272: PUSH
4273: LD_INT 50
4275: PUSH
4276: EMPTY
4277: LIST
4278: PUSH
4279: EMPTY
4280: LIST
4281: LIST
4282: PUSH
4283: EMPTY
4284: LIST
4285: LIST
4286: PPUSH
4287: CALL_OW 69
4291: IFFALSE 4407
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) do
4293: LD_ADDR_VAR 0 1
4297: PUSH
4298: LD_INT 22
4300: PUSH
4301: LD_INT 1
4303: PUSH
4304: EMPTY
4305: LIST
4306: LIST
4307: PUSH
4308: LD_INT 25
4310: PUSH
4311: LD_INT 4
4313: PUSH
4314: EMPTY
4315: LIST
4316: LIST
4317: PUSH
4318: EMPTY
4319: LIST
4320: LIST
4321: PPUSH
4322: CALL_OW 69
4326: PUSH
4327: FOR_IN
4328: IFFALSE 4405
// begin if IsInUnit ( i ) then
4330: LD_VAR 0 1
4334: PPUSH
4335: CALL_OW 310
4339: IFFALSE 4352
// ComExitBuilding ( i ) else
4341: LD_VAR 0 1
4345: PPUSH
4346: CALL_OW 122
4350: GO 4403
// ComHeal ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] ] ) , i ) ) ;
4352: LD_VAR 0 1
4356: PPUSH
4357: LD_INT 22
4359: PUSH
4360: LD_INT 1
4362: PUSH
4363: EMPTY
4364: LIST
4365: LIST
4366: PUSH
4367: LD_INT 3
4369: PUSH
4370: LD_INT 50
4372: PUSH
4373: EMPTY
4374: LIST
4375: PUSH
4376: EMPTY
4377: LIST
4378: LIST
4379: PUSH
4380: EMPTY
4381: LIST
4382: LIST
4383: PPUSH
4384: CALL_OW 69
4388: PPUSH
4389: LD_VAR 0 1
4393: PPUSH
4394: CALL_OW 74
4398: PPUSH
4399: CALL_OW 128
// end ;
4403: GO 4327
4405: POP
4406: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] ] ) ;
4407: LD_INT 22
4409: PUSH
4410: LD_INT 1
4412: PUSH
4413: EMPTY
4414: LIST
4415: LIST
4416: PUSH
4417: LD_INT 3
4419: PUSH
4420: LD_INT 50
4422: PUSH
4423: EMPTY
4424: LIST
4425: PUSH
4426: EMPTY
4427: LIST
4428: LIST
4429: PUSH
4430: EMPTY
4431: LIST
4432: LIST
4433: PPUSH
4434: CALL_OW 69
4438: NOT
4439: IFFALSE 4253
// repeat wait ( 3 ) ;
4441: LD_INT 3
4443: PPUSH
4444: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) do
4448: LD_ADDR_VAR 0 1
4452: PUSH
4453: LD_INT 22
4455: PUSH
4456: LD_INT 1
4458: PUSH
4459: EMPTY
4460: LIST
4461: LIST
4462: PUSH
4463: LD_INT 21
4465: PUSH
4466: LD_INT 1
4468: PUSH
4469: EMPTY
4470: LIST
4471: LIST
4472: PUSH
4473: EMPTY
4474: LIST
4475: LIST
4476: PPUSH
4477: CALL_OW 69
4481: PUSH
4482: FOR_IN
4483: IFFALSE 4559
// begin if IsInArea ( i , stevensEscapeArea ) then
4485: LD_VAR 0 1
4489: PPUSH
4490: LD_INT 8
4492: PPUSH
4493: CALL_OW 308
4497: IFFALSE 4510
// begin RemoveUnit ( i ) ;
4499: LD_VAR 0 1
4503: PPUSH
4504: CALL_OW 64
// continue ;
4508: GO 4482
// end ; if IsInUnit ( i ) then
4510: LD_VAR 0 1
4514: PPUSH
4515: CALL_OW 310
4519: IFFALSE 4530
// ComExitBuilding ( i ) ;
4521: LD_VAR 0 1
4525: PPUSH
4526: CALL_OW 122
// if not HasTask ( i ) then
4530: LD_VAR 0 1
4534: PPUSH
4535: CALL_OW 314
4539: NOT
4540: IFFALSE 4557
// ComMoveXY ( i , 28 , 55 ) ;
4542: LD_VAR 0 1
4546: PPUSH
4547: LD_INT 28
4549: PPUSH
4550: LD_INT 55
4552: PPUSH
4553: CALL_OW 111
// end ;
4557: GO 4482
4559: POP
4560: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ;
4561: LD_INT 22
4563: PUSH
4564: LD_INT 1
4566: PUSH
4567: EMPTY
4568: LIST
4569: LIST
4570: PUSH
4571: LD_INT 21
4573: PUSH
4574: LD_INT 1
4576: PUSH
4577: EMPTY
4578: LIST
4579: LIST
4580: PUSH
4581: EMPTY
4582: LIST
4583: LIST
4584: PPUSH
4585: CALL_OW 69
4589: NOT
4590: IFFALSE 4441
// end ; 2 :
4592: GO 4606
4594: LD_INT 2
4596: DOUBLE
4597: EQUAL
4598: IFTRUE 4602
4600: GO 4605
4602: POP
// ; end ;
4603: GO 4606
4605: POP
// end ;
4606: PPOPN 1
4608: END
// every 0 0$1 trigger canEnd do var un , i , tmp ;
4609: LD_EXP 10
4613: IFFALSE 4970
4615: GO 4617
4617: DISABLE
4618: LD_INT 0
4620: PPUSH
4621: PPUSH
4622: PPUSH
// begin SetAreaMapShow ( endMissionArea , 1 ) ;
4623: LD_INT 10
4625: PPUSH
4626: LD_INT 1
4628: PPUSH
4629: CALL_OW 424
// if Difficulty < 2 then
4633: LD_OWVAR 67
4637: PUSH
4638: LD_INT 2
4640: LESS
4641: IFFALSE 4645
// exit ;
4643: GO 4970
// uc_side := 4 ;
4645: LD_ADDR_OWVAR 20
4649: PUSH
4650: LD_INT 4
4652: ST_TO_ADDR
// uc_nation := 1 ;
4653: LD_ADDR_OWVAR 21
4657: PUSH
4658: LD_INT 1
4660: ST_TO_ADDR
// InitHc ;
4661: CALL_OW 19
// tmp := [ ] ;
4665: LD_ADDR_VAR 0 3
4669: PUSH
4670: EMPTY
4671: ST_TO_ADDR
// PrepareHuman ( false , class_sniper , 10 ) ;
4672: LD_INT 0
4674: PPUSH
4675: LD_INT 5
4677: PPUSH
4678: LD_INT 10
4680: PPUSH
4681: CALL_OW 380
// un := CreateHuman ;
4685: LD_ADDR_VAR 0 1
4689: PUSH
4690: CALL_OW 44
4694: ST_TO_ADDR
// tmp := [ un ] ;
4695: LD_ADDR_VAR 0 3
4699: PUSH
4700: LD_VAR 0 1
4704: PUSH
4705: EMPTY
4706: LIST
4707: ST_TO_ADDR
// PlaceUnitXY ( un , 226 , 86 , false ) ;
4708: LD_VAR 0 1
4712: PPUSH
4713: LD_INT 226
4715: PPUSH
4716: LD_INT 86
4718: PPUSH
4719: LD_INT 0
4721: PPUSH
4722: CALL_OW 48
// ComHold ( un ) ;
4726: LD_VAR 0 1
4730: PPUSH
4731: CALL_OW 140
// for i = 1 to 3 do
4735: LD_ADDR_VAR 0 2
4739: PUSH
4740: DOUBLE
4741: LD_INT 1
4743: DEC
4744: ST_TO_ADDR
4745: LD_INT 3
4747: PUSH
4748: FOR_TO
4749: IFFALSE 4848
// begin PrepareHuman ( false , class_soldier , 8 ) ;
4751: LD_INT 0
4753: PPUSH
4754: LD_INT 1
4756: PPUSH
4757: LD_INT 8
4759: PPUSH
4760: CALL_OW 380
// un := CreateHuman ;
4764: LD_ADDR_VAR 0 1
4768: PUSH
4769: CALL_OW 44
4773: ST_TO_ADDR
// SetDir ( un , 5 ) ;
4774: LD_VAR 0 1
4778: PPUSH
4779: LD_INT 5
4781: PPUSH
4782: CALL_OW 233
// PlaceUnitXY ( un , [ 215 , 217 , 219 ] [ i ] , 76 , false ) ;
4786: LD_VAR 0 1
4790: PPUSH
4791: LD_INT 215
4793: PUSH
4794: LD_INT 217
4796: PUSH
4797: LD_INT 219
4799: PUSH
4800: EMPTY
4801: LIST
4802: LIST
4803: LIST
4804: PUSH
4805: LD_VAR 0 2
4809: ARRAY
4810: PPUSH
4811: LD_INT 76
4813: PPUSH
4814: LD_INT 0
4816: PPUSH
4817: CALL_OW 48
// ComCrawl ( un ) ;
4821: LD_VAR 0 1
4825: PPUSH
4826: CALL_OW 137
// tmp := tmp ^ un ;
4830: LD_ADDR_VAR 0 3
4834: PUSH
4835: LD_VAR 0 3
4839: PUSH
4840: LD_VAR 0 1
4844: ADD
4845: ST_TO_ADDR
// end ;
4846: GO 4748
4848: POP
4849: POP
// repeat wait ( 0 0$1 ) ;
4850: LD_INT 35
4852: PPUSH
4853: CALL_OW 67
// until not UnitFilter ( un , [ f_lives , 1000 ] ) ;
4857: LD_VAR 0 1
4861: PPUSH
4862: LD_INT 24
4864: PUSH
4865: LD_INT 1000
4867: PUSH
4868: EMPTY
4869: LIST
4870: LIST
4871: PPUSH
4872: CALL_OW 72
4876: NOT
4877: IFFALSE 4850
// for i in tmp do
4879: LD_ADDR_VAR 0 2
4883: PUSH
4884: LD_VAR 0 3
4888: PUSH
4889: FOR_IN
4890: IFFALSE 4968
// begin wait ( 0 0$1 ) ;
4892: LD_INT 35
4894: PPUSH
4895: CALL_OW 67
// if Crawls ( i ) then
4899: LD_VAR 0 2
4903: PPUSH
4904: CALL_OW 318
4908: IFFALSE 4921
// ComWalk ( i ) else
4910: LD_VAR 0 2
4914: PPUSH
4915: CALL_OW 138
4919: GO 4966
// if GetClass ( i ) = class_sniper then
4921: LD_VAR 0 2
4925: PPUSH
4926: CALL_OW 257
4930: PUSH
4931: LD_INT 5
4933: EQUAL
4934: IFFALSE 4952
// ComAttackSoporific ( i , JMM ) else
4936: LD_VAR 0 2
4940: PPUSH
4941: LD_EXP 14
4945: PPUSH
4946: CALL_OW 166
4950: GO 4966
// ComAttackUnit ( i , JMM ) ;
4952: LD_VAR 0 2
4956: PPUSH
4957: LD_EXP 14
4961: PPUSH
4962: CALL_OW 115
// end ;
4966: GO 4889
4968: POP
4969: POP
// end ;
4970: PPOPN 3
4972: END
// every 0 0$1 trigger not planCaptured and IsDead ( us_lab ) do
4973: LD_EXP 7
4977: NOT
4978: PUSH
4979: LD_INT 1
4981: PPUSH
4982: CALL_OW 301
4986: AND
4987: IFFALSE 4999
4989: GO 4991
4991: DISABLE
// YouLost ( Lab ) ;
4992: LD_STRING Lab
4994: PPUSH
4995: CALL_OW 104
4999: END
// every 0 0$1 trigger FilterUnitsInArea ( endMissionArea , [ f_side , 7 ] ) >= 2 and FilterUnitsInArea ( endMissionArea , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) and canEnd and planCaptured and artifactPickedUp do var m1 , m2 ;
5000: LD_INT 10
5002: PPUSH
5003: LD_INT 22
5005: PUSH
5006: LD_INT 7
5008: PUSH
5009: EMPTY
5010: LIST
5011: LIST
5012: PPUSH
5013: CALL_OW 70
5017: PUSH
5018: LD_INT 2
5020: GREATEREQUAL
5021: PUSH
5022: LD_INT 10
5024: PPUSH
5025: LD_INT 2
5027: PUSH
5028: LD_INT 34
5030: PUSH
5031: LD_INT 12
5033: PUSH
5034: EMPTY
5035: LIST
5036: LIST
5037: PUSH
5038: LD_INT 34
5040: PUSH
5041: LD_INT 51
5043: PUSH
5044: EMPTY
5045: LIST
5046: LIST
5047: PUSH
5048: EMPTY
5049: LIST
5050: LIST
5051: LIST
5052: PPUSH
5053: CALL_OW 70
5057: AND
5058: PUSH
5059: LD_EXP 10
5063: AND
5064: PUSH
5065: LD_EXP 7
5069: AND
5070: PUSH
5071: LD_EXP 6
5075: AND
5076: IFFALSE 5332
5078: GO 5080
5080: DISABLE
5081: LD_INT 0
5083: PPUSH
5084: PPUSH
// begin m1 := false ;
5085: LD_ADDR_VAR 0 1
5089: PUSH
5090: LD_INT 0
5092: ST_TO_ADDR
// m2 := false ;
5093: LD_ADDR_VAR 0 2
5097: PUSH
5098: LD_INT 0
5100: ST_TO_ADDR
// if killCounter = 0 then
5101: LD_EXP 12
5105: PUSH
5106: LD_INT 0
5108: EQUAL
5109: IFFALSE 5118
// SetAchievement ( ACH_PACIFIST ) ;
5111: LD_STRING ACH_PACIFIST
5113: PPUSH
5114: CALL_OW 543
// if tick < 7 7$00 then
5118: LD_OWVAR 1
5122: PUSH
5123: LD_INT 14700
5125: LESS
5126: IFFALSE 5142
// begin wait ( 3 ) ;
5128: LD_INT 3
5130: PPUSH
5131: CALL_OW 67
// SetAchievement ( ACH_ASPEED_18 ) ;
5135: LD_STRING ACH_ASPEED_18
5137: PPUSH
5138: CALL_OW 543
// end ; AddMedal ( Explosion , 1 ) ;
5142: LD_STRING Explosion
5144: PPUSH
5145: LD_INT 1
5147: PPUSH
5148: CALL_OW 101
// if enteredContaminatedArea then
5152: LD_EXP 5
5156: IFFALSE 5178
// begin m1 := true ;
5158: LD_ADDR_VAR 0 1
5162: PUSH
5163: LD_INT 1
5165: ST_TO_ADDR
// AddMedal ( BioHazard , 1 ) ;
5166: LD_STRING BioHazard
5168: PPUSH
5169: LD_INT 1
5171: PPUSH
5172: CALL_OW 101
// end else
5176: GO 5189
// AddMedal ( BioHazard , - 1 ) ;
5178: LD_STRING BioHazard
5180: PPUSH
5181: LD_INT 1
5183: NEG
5184: PPUSH
5185: CALL_OW 101
// if missionTime <= [ 20 20$00 , 15 15$00 , 12 12$00 ] [ Difficulty ] then
5189: LD_EXP 11
5193: PUSH
5194: LD_INT 42000
5196: PUSH
5197: LD_INT 31500
5199: PUSH
5200: LD_INT 25200
5202: PUSH
5203: EMPTY
5204: LIST
5205: LIST
5206: LIST
5207: PUSH
5208: LD_OWVAR 67
5212: ARRAY
5213: LESSEQUAL
5214: IFFALSE 5236
// begin m2 := true ;
5216: LD_ADDR_VAR 0 2
5220: PUSH
5221: LD_INT 1
5223: ST_TO_ADDR
// AddMedal ( Speed , 1 ) ;
5224: LD_STRING Speed
5226: PPUSH
5227: LD_INT 1
5229: PPUSH
5230: CALL_OW 101
// end else
5234: GO 5247
// AddMedal ( Speed , - 1 ) ;
5236: LD_STRING Speed
5238: PPUSH
5239: LD_INT 1
5241: NEG
5242: PPUSH
5243: CALL_OW 101
// if Difficulty = 3 and m1 and m2 then
5247: LD_OWVAR 67
5251: PUSH
5252: LD_INT 3
5254: EQUAL
5255: PUSH
5256: LD_VAR 0 1
5260: AND
5261: PUSH
5262: LD_VAR 0 2
5266: AND
5267: IFFALSE 5279
// SetAchievementEX ( ACH_AMER , 18 ) ;
5269: LD_STRING ACH_AMER
5271: PPUSH
5272: LD_INT 18
5274: PPUSH
5275: CALL_OW 564
// GiveMedals ( Main ) ;
5279: LD_STRING Main
5281: PPUSH
5282: CALL_OW 102
// RewardPeople ( [ JMM , Burlak ] ) ;
5286: LD_EXP 14
5290: PUSH
5291: LD_EXP 15
5295: PUSH
5296: EMPTY
5297: LIST
5298: LIST
5299: PPUSH
5300: CALL_OW 43
// SaveCharacters ( JMM , 14a_JMM ) ;
5304: LD_EXP 14
5308: PPUSH
5309: LD_STRING 14a_JMM
5311: PPUSH
5312: CALL_OW 38
// SaveCharacters ( Burlak , 14a_Burlak ) ;
5316: LD_EXP 15
5320: PPUSH
5321: LD_STRING 14a_Burlak
5323: PPUSH
5324: CALL_OW 38
// YouWin ;
5328: CALL_OW 103
// end ; end_of_file
5332: PPOPN 2
5334: END
// export Stevens , Powell , baseGuards , sibBomb , guards , vehGuard ; export function PrepareAmerican ; var i , un , tmp ; begin
5335: LD_INT 0
5337: PPUSH
5338: PPUSH
5339: PPUSH
5340: PPUSH
// uc_side := 1 ;
5341: LD_ADDR_OWVAR 20
5345: PUSH
5346: LD_INT 1
5348: ST_TO_ADDR
// uc_nation := 1 ;
5349: LD_ADDR_OWVAR 21
5353: PUSH
5354: LD_INT 1
5356: ST_TO_ADDR
// InitHc ;
5357: CALL_OW 19
// SetResourceType ( GetBase ( us_depot2 ) , mat_cans , 500 ) ;
5361: LD_INT 34
5363: PPUSH
5364: CALL_OW 274
5368: PPUSH
5369: LD_INT 1
5371: PPUSH
5372: LD_INT 500
5374: PPUSH
5375: CALL_OW 277
// SetResourceType ( GetBase ( us_depot2 ) , mat_siberit , 20 ) ;
5379: LD_INT 34
5381: PPUSH
5382: CALL_OW 274
5386: PPUSH
5387: LD_INT 3
5389: PPUSH
5390: LD_INT 20
5392: PPUSH
5393: CALL_OW 277
// Stevens := NewCharacter ( Stevens ) ;
5397: LD_ADDR_EXP 18
5401: PUSH
5402: LD_STRING Stevens
5404: PPUSH
5405: CALL_OW 25
5409: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
5410: LD_ADDR_EXP 19
5414: PUSH
5415: LD_STRING Powell
5417: PPUSH
5418: CALL_OW 25
5422: ST_TO_ADDR
// PlaceHumanInUnit ( Stevens , us_lab ) ;
5423: LD_EXP 18
5427: PPUSH
5428: LD_INT 1
5430: PPUSH
5431: CALL_OW 52
// vehGuard := [ ] ;
5435: LD_ADDR_EXP 23
5439: PUSH
5440: EMPTY
5441: ST_TO_ADDR
// hc_importance := 0 ;
5442: LD_ADDR_OWVAR 32
5446: PUSH
5447: LD_INT 0
5449: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_siberite , control_computer , us_siberium_rocket , 100 ) ;
5450: LD_INT 4
5452: PPUSH
5453: LD_INT 3
5455: PPUSH
5456: LD_INT 3
5458: PPUSH
5459: LD_INT 8
5461: PPUSH
5462: LD_INT 100
5464: PPUSH
5465: CALL 971 0 5
// sibBomb := CreateVehicle ;
5469: LD_ADDR_EXP 21
5473: PUSH
5474: CALL_OW 45
5478: ST_TO_ADDR
// SetDir ( sibBomb , 1 ) ;
5479: LD_EXP 21
5483: PPUSH
5484: LD_INT 1
5486: PPUSH
5487: CALL_OW 233
// PlaceUnitXY ( sibBomb , 93 , 74 , false ) ;
5491: LD_EXP 21
5495: PPUSH
5496: LD_INT 93
5498: PPUSH
5499: LD_INT 74
5501: PPUSH
5502: LD_INT 0
5504: PPUSH
5505: CALL_OW 48
// guards := [ ] ;
5509: LD_ADDR_EXP 22
5513: PUSH
5514: EMPTY
5515: ST_TO_ADDR
// for i = 1 to 3 do
5516: LD_ADDR_VAR 0 2
5520: PUSH
5521: DOUBLE
5522: LD_INT 1
5524: DEC
5525: ST_TO_ADDR
5526: LD_INT 3
5528: PUSH
5529: FOR_TO
5530: IFFALSE 5622
// begin PrepareHuman ( false , class_soldier , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
5532: LD_INT 0
5534: PPUSH
5535: LD_INT 1
5537: PPUSH
5538: LD_INT 8
5540: PUSH
5541: LD_INT 9
5543: PUSH
5544: LD_INT 10
5546: PUSH
5547: EMPTY
5548: LIST
5549: LIST
5550: LIST
5551: PUSH
5552: LD_OWVAR 67
5556: ARRAY
5557: PPUSH
5558: CALL_OW 380
// un := CreateHuman ;
5562: LD_ADDR_VAR 0 3
5566: PUSH
5567: CALL_OW 44
5571: ST_TO_ADDR
// PlaceUnitArea ( un , [ patrol1 , patrol2 , patrol3 ] [ i ] , false ) ;
5572: LD_VAR 0 3
5576: PPUSH
5577: LD_INT 2
5579: PUSH
5580: LD_INT 3
5582: PUSH
5583: LD_INT 4
5585: PUSH
5586: EMPTY
5587: LIST
5588: LIST
5589: LIST
5590: PUSH
5591: LD_VAR 0 2
5595: ARRAY
5596: PPUSH
5597: LD_INT 0
5599: PPUSH
5600: CALL_OW 49
// guards := guards ^ un ;
5604: LD_ADDR_EXP 22
5608: PUSH
5609: LD_EXP 22
5613: PUSH
5614: LD_VAR 0 3
5618: ADD
5619: ST_TO_ADDR
// end ;
5620: GO 5529
5622: POP
5623: POP
// baseGuards := [ ] ;
5624: LD_ADDR_EXP 20
5628: PUSH
5629: EMPTY
5630: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
5631: LD_ADDR_VAR 0 2
5635: PUSH
5636: DOUBLE
5637: LD_INT 1
5639: DEC
5640: ST_TO_ADDR
5641: LD_INT 5
5643: PUSH
5644: LD_INT 6
5646: PUSH
5647: LD_INT 7
5649: PUSH
5650: EMPTY
5651: LIST
5652: LIST
5653: LIST
5654: PUSH
5655: LD_OWVAR 67
5659: ARRAY
5660: PUSH
5661: FOR_TO
5662: IFFALSE 5808
// begin PrepareSoldier ( false , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
5664: LD_INT 0
5666: PPUSH
5667: LD_INT 8
5669: PUSH
5670: LD_INT 9
5672: PUSH
5673: LD_INT 10
5675: PUSH
5676: EMPTY
5677: LIST
5678: LIST
5679: LIST
5680: PUSH
5681: LD_OWVAR 67
5685: ARRAY
5686: PPUSH
5687: CALL_OW 381
// un := CreateHuman ;
5691: LD_ADDR_VAR 0 3
5695: PUSH
5696: CALL_OW 44
5700: ST_TO_ADDR
// baseGuards := baseGuards ^ un ;
5701: LD_ADDR_EXP 20
5705: PUSH
5706: LD_EXP 20
5710: PUSH
5711: LD_VAR 0 3
5715: ADD
5716: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
5717: LD_ADDR_VAR 0 4
5721: PUSH
5722: LD_INT 22
5724: PUSH
5725: LD_INT 1
5727: PUSH
5728: EMPTY
5729: LIST
5730: LIST
5731: PUSH
5732: LD_INT 58
5734: PUSH
5735: EMPTY
5736: LIST
5737: PUSH
5738: LD_INT 30
5740: PUSH
5741: LD_INT 32
5743: PUSH
5744: EMPTY
5745: LIST
5746: LIST
5747: PUSH
5748: EMPTY
5749: LIST
5750: LIST
5751: LIST
5752: PPUSH
5753: CALL_OW 69
5757: ST_TO_ADDR
// if tmp then
5758: LD_VAR 0 4
5762: IFFALSE 5794
// PlaceHumanInUnit ( un , tmp [ rand ( 1 , tmp ) ] ) else
5764: LD_VAR 0 3
5768: PPUSH
5769: LD_VAR 0 4
5773: PUSH
5774: LD_INT 1
5776: PPUSH
5777: LD_VAR 0 4
5781: PPUSH
5782: CALL_OW 12
5786: ARRAY
5787: PPUSH
5788: CALL_OW 52
5792: GO 5806
// PlaceHumanInUnit ( un , us_bar ) ;
5794: LD_VAR 0 3
5798: PPUSH
5799: LD_INT 51
5801: PPUSH
5802: CALL_OW 52
// end ;
5806: GO 5661
5808: POP
5809: POP
// if Difficulty > 1 then
5810: LD_OWVAR 67
5814: PUSH
5815: LD_INT 1
5817: GREATER
5818: IFFALSE 5862
// begin PrepareHuman ( false , class_sniper , [ 9 , 10 ] [ Difficulty - 1 ] ) ;
5820: LD_INT 0
5822: PPUSH
5823: LD_INT 5
5825: PPUSH
5826: LD_INT 9
5828: PUSH
5829: LD_INT 10
5831: PUSH
5832: EMPTY
5833: LIST
5834: LIST
5835: PUSH
5836: LD_OWVAR 67
5840: PUSH
5841: LD_INT 1
5843: MINUS
5844: ARRAY
5845: PPUSH
5846: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_bun1 ) ;
5850: CALL_OW 44
5854: PPUSH
5855: LD_INT 80
5857: PPUSH
5858: CALL_OW 52
// end ; for i = 1 to 3 do
5862: LD_ADDR_VAR 0 2
5866: PUSH
5867: DOUBLE
5868: LD_INT 1
5870: DEC
5871: ST_TO_ADDR
5872: LD_INT 3
5874: PUSH
5875: FOR_TO
5876: IFFALSE 5902
// begin PrepareMechanic ( false , 9 ) ;
5878: LD_INT 0
5880: PPUSH
5881: LD_INT 9
5883: PPUSH
5884: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , us_fac ) ;
5888: CALL_OW 44
5892: PPUSH
5893: LD_INT 43
5895: PPUSH
5896: CALL_OW 52
// end ;
5900: GO 5875
5902: POP
5903: POP
// PlaceHumanInUnit ( CreateHuman , us_ct ) ;
5904: CALL_OW 44
5908: PPUSH
5909: LD_INT 49
5911: PPUSH
5912: CALL_OW 52
// for i = 1 to 1 + Difficulty do
5916: LD_ADDR_VAR 0 2
5920: PUSH
5921: DOUBLE
5922: LD_INT 1
5924: DEC
5925: ST_TO_ADDR
5926: LD_INT 1
5928: PUSH
5929: LD_OWVAR 67
5933: PLUS
5934: PUSH
5935: FOR_TO
5936: IFFALSE 5979
// begin PrepareEngineer ( false , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
5938: LD_INT 0
5940: PPUSH
5941: LD_INT 8
5943: PUSH
5944: LD_INT 9
5946: PUSH
5947: LD_INT 10
5949: PUSH
5950: EMPTY
5951: LIST
5952: LIST
5953: LIST
5954: PUSH
5955: LD_OWVAR 67
5959: ARRAY
5960: PPUSH
5961: CALL_OW 382
// PlaceHumanInUnit ( CreateHuman , us_depot ) ;
5965: CALL_OW 44
5969: PPUSH
5970: LD_INT 5
5972: PPUSH
5973: CALL_OW 52
// end ;
5977: GO 5935
5979: POP
5980: POP
// for i = 1 to 3 do
5981: LD_ADDR_VAR 0 2
5985: PUSH
5986: DOUBLE
5987: LD_INT 1
5989: DEC
5990: ST_TO_ADDR
5991: LD_INT 3
5993: PUSH
5994: FOR_TO
5995: IFFALSE 6021
// begin PrepareScientist ( false , 10 ) ;
5997: LD_INT 0
5999: PPUSH
6000: LD_INT 10
6002: PPUSH
6003: CALL_OW 384
// PlaceHumanInUnit ( CreateHuman , us_lab ) ;
6007: CALL_OW 44
6011: PPUSH
6012: LD_INT 1
6014: PPUSH
6015: CALL_OW 52
// end ;
6019: GO 5994
6021: POP
6022: POP
// end ;
6023: LD_VAR 0 1
6027: RET
// every 0 0$2 trigger guards and not activeBombTest do var i , j , points ;
6028: LD_EXP 22
6032: PUSH
6033: LD_EXP 2
6037: NOT
6038: AND
6039: IFFALSE 6225
6041: GO 6043
6043: DISABLE
6044: LD_INT 0
6046: PPUSH
6047: PPUSH
6048: PPUSH
// begin enable ;
6049: ENABLE
// points := [ [ 204 , 30 ] , [ 165 , 24 ] , [ 195 , 6 ] , [ 223 , 54 ] , [ 214 , 84 ] , [ 206 , 71 ] ] ;
6050: LD_ADDR_VAR 0 3
6054: PUSH
6055: LD_INT 204
6057: PUSH
6058: LD_INT 30
6060: PUSH
6061: EMPTY
6062: LIST
6063: LIST
6064: PUSH
6065: LD_INT 165
6067: PUSH
6068: LD_INT 24
6070: PUSH
6071: EMPTY
6072: LIST
6073: LIST
6074: PUSH
6075: LD_INT 195
6077: PUSH
6078: LD_INT 6
6080: PUSH
6081: EMPTY
6082: LIST
6083: LIST
6084: PUSH
6085: LD_INT 223
6087: PUSH
6088: LD_INT 54
6090: PUSH
6091: EMPTY
6092: LIST
6093: LIST
6094: PUSH
6095: LD_INT 214
6097: PUSH
6098: LD_INT 84
6100: PUSH
6101: EMPTY
6102: LIST
6103: LIST
6104: PUSH
6105: LD_INT 206
6107: PUSH
6108: LD_INT 71
6110: PUSH
6111: EMPTY
6112: LIST
6113: LIST
6114: PUSH
6115: EMPTY
6116: LIST
6117: LIST
6118: LIST
6119: LIST
6120: LIST
6121: LIST
6122: ST_TO_ADDR
// for i in guards do
6123: LD_ADDR_VAR 0 1
6127: PUSH
6128: LD_EXP 22
6132: PUSH
6133: FOR_IN
6134: IFFALSE 6223
// begin if HasTask ( i ) then
6136: LD_VAR 0 1
6140: PPUSH
6141: CALL_OW 314
6145: IFFALSE 6151
// continue else
6147: GO 6133
6149: GO 6221
// begin j := rand ( 1 , 6 ) ;
6151: LD_ADDR_VAR 0 2
6155: PUSH
6156: LD_INT 1
6158: PPUSH
6159: LD_INT 6
6161: PPUSH
6162: CALL_OW 12
6166: ST_TO_ADDR
// if not See ( 7 , i ) then
6167: LD_INT 7
6169: PPUSH
6170: LD_VAR 0 1
6174: PPUSH
6175: CALL_OW 292
6179: NOT
6180: IFFALSE 6221
// ComAgressiveMove ( i , points [ j ] [ 1 ] , points [ j ] [ 2 ] ) ;
6182: LD_VAR 0 1
6186: PPUSH
6187: LD_VAR 0 3
6191: PUSH
6192: LD_VAR 0 2
6196: ARRAY
6197: PUSH
6198: LD_INT 1
6200: ARRAY
6201: PPUSH
6202: LD_VAR 0 3
6206: PUSH
6207: LD_VAR 0 2
6211: ARRAY
6212: PUSH
6213: LD_INT 2
6215: ARRAY
6216: PPUSH
6217: CALL_OW 114
// end ; end ;
6221: GO 6133
6223: POP
6224: POP
// end ;
6225: PPOPN 3
6227: END
// every 0 0$1 trigger vehGuard and not planCaptured do var i ;
6228: LD_EXP 23
6232: PUSH
6233: LD_EXP 7
6237: NOT
6238: AND
6239: IFFALSE 6310
6241: GO 6243
6243: DISABLE
6244: LD_INT 0
6246: PPUSH
// begin enable ;
6247: ENABLE
// for i in vehGuard do
6248: LD_ADDR_VAR 0 1
6252: PUSH
6253: LD_EXP 23
6257: PUSH
6258: FOR_IN
6259: IFFALSE 6308
// if IsOk ( vehGuard ) then
6261: LD_EXP 23
6265: PPUSH
6266: CALL_OW 302
6270: IFFALSE 6306
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , i ) ) ;
6272: LD_VAR 0 1
6276: PPUSH
6277: LD_INT 22
6279: PUSH
6280: LD_INT 7
6282: PUSH
6283: EMPTY
6284: LIST
6285: LIST
6286: PPUSH
6287: CALL_OW 69
6291: PPUSH
6292: LD_VAR 0 1
6296: PPUSH
6297: CALL_OW 74
6301: PPUSH
6302: CALL_OW 115
6306: GO 6258
6308: POP
6309: POP
// end ;
6310: PPOPN 1
6312: END
// every 9 9$00 trigger bombExploded and IsOk ( us_fac ) and not planCaptured do
6313: LD_EXP 4
6317: PUSH
6318: LD_INT 43
6320: PPUSH
6321: CALL_OW 302
6325: AND
6326: PUSH
6327: LD_EXP 7
6331: NOT
6332: AND
6333: IFFALSE 6381
6335: GO 6337
6337: DISABLE
// begin enable ;
6338: ENABLE
// ComConstruct ( us_fac , us_morphling , engine_siberite , control_remote , [ us_rocket_launcher , us_rocket_launcher , us_laser ] [ rand ( 1 , 3 ) ] ) ;
6339: LD_INT 43
6341: PPUSH
6342: LD_INT 5
6344: PPUSH
6345: LD_INT 3
6347: PPUSH
6348: LD_INT 2
6350: PPUSH
6351: LD_INT 7
6353: PUSH
6354: LD_INT 7
6356: PUSH
6357: LD_INT 9
6359: PUSH
6360: EMPTY
6361: LIST
6362: LIST
6363: LIST
6364: PUSH
6365: LD_INT 1
6367: PPUSH
6368: LD_INT 3
6370: PPUSH
6371: CALL_OW 12
6375: ARRAY
6376: PPUSH
6377: CALL_OW 125
// end ;
6381: END
// every 1 1$45 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_sniper ] , [ f_ok ] ] ) and not planCaptured do var tmp , b ;
6382: LD_INT 22
6384: PUSH
6385: LD_INT 1
6387: PUSH
6388: EMPTY
6389: LIST
6390: LIST
6391: PUSH
6392: LD_INT 25
6394: PUSH
6395: LD_INT 5
6397: PUSH
6398: EMPTY
6399: LIST
6400: LIST
6401: PUSH
6402: LD_INT 50
6404: PUSH
6405: EMPTY
6406: LIST
6407: PUSH
6408: EMPTY
6409: LIST
6410: LIST
6411: LIST
6412: PPUSH
6413: CALL_OW 69
6417: PUSH
6418: LD_EXP 7
6422: NOT
6423: AND
6424: IFFALSE 6653
6426: GO 6428
6428: DISABLE
6429: LD_INT 0
6431: PPUSH
6432: PPUSH
// begin enable ;
6433: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_sniper ] , [ f_ok ] ] ) ;
6434: LD_ADDR_VAR 0 1
6438: PUSH
6439: LD_INT 22
6441: PUSH
6442: LD_INT 1
6444: PUSH
6445: EMPTY
6446: LIST
6447: LIST
6448: PUSH
6449: LD_INT 25
6451: PUSH
6452: LD_INT 5
6454: PUSH
6455: EMPTY
6456: LIST
6457: LIST
6458: PUSH
6459: LD_INT 50
6461: PUSH
6462: EMPTY
6463: LIST
6464: PUSH
6465: EMPTY
6466: LIST
6467: LIST
6468: LIST
6469: PPUSH
6470: CALL_OW 69
6474: ST_TO_ADDR
// if not tmp then
6475: LD_VAR 0 1
6479: NOT
6480: IFFALSE 6484
// exit ;
6482: GO 6653
// b := IsInUnit ( tmp [ 1 ] ) ;
6484: LD_ADDR_VAR 0 2
6488: PUSH
6489: LD_VAR 0 1
6493: PUSH
6494: LD_INT 1
6496: ARRAY
6497: PPUSH
6498: CALL_OW 310
6502: ST_TO_ADDR
// if not b or HasTask ( tmp [ 1 ] ) then
6503: LD_VAR 0 2
6507: NOT
6508: PUSH
6509: LD_VAR 0 1
6513: PUSH
6514: LD_INT 1
6516: ARRAY
6517: PPUSH
6518: CALL_OW 314
6522: OR
6523: IFFALSE 6527
// exit ;
6525: GO 6653
// if b = us_bun1 then
6527: LD_VAR 0 2
6531: PUSH
6532: LD_INT 80
6534: EQUAL
6535: IFFALSE 6596
// begin ComExitBuilding ( tmp [ 1 ] ) ;
6537: LD_VAR 0 1
6541: PUSH
6542: LD_INT 1
6544: ARRAY
6545: PPUSH
6546: CALL_OW 122
// AddComAgressiveMove ( tmp [ 1 ] , 27 , 44 ) ;
6550: LD_VAR 0 1
6554: PUSH
6555: LD_INT 1
6557: ARRAY
6558: PPUSH
6559: LD_INT 27
6561: PPUSH
6562: LD_INT 44
6564: PPUSH
6565: CALL_OW 174
// if IsOk ( us_bun2 ) then
6569: LD_INT 55
6571: PPUSH
6572: CALL_OW 302
6576: IFFALSE 6594
// AddComEnterUnit ( tmp [ 1 ] , us_bun2 ) ;
6578: LD_VAR 0 1
6582: PUSH
6583: LD_INT 1
6585: ARRAY
6586: PPUSH
6587: LD_INT 55
6589: PPUSH
6590: CALL_OW 180
// end else
6594: GO 6653
// begin ComExitBuilding ( tmp [ 1 ] ) ;
6596: LD_VAR 0 1
6600: PUSH
6601: LD_INT 1
6603: ARRAY
6604: PPUSH
6605: CALL_OW 122
// AddComAgressiveMove ( tmp [ 1 ] , 92 , 51 ) ;
6609: LD_VAR 0 1
6613: PUSH
6614: LD_INT 1
6616: ARRAY
6617: PPUSH
6618: LD_INT 92
6620: PPUSH
6621: LD_INT 51
6623: PPUSH
6624: CALL_OW 174
// if IsOk ( us_bun1 ) then
6628: LD_INT 80
6630: PPUSH
6631: CALL_OW 302
6635: IFFALSE 6653
// AddComEnterUnit ( tmp [ 1 ] , us_bun1 ) ;
6637: LD_VAR 0 1
6641: PUSH
6642: LD_INT 1
6644: ARRAY
6645: PPUSH
6646: LD_INT 80
6648: PPUSH
6649: CALL_OW 180
// end ; end ;
6653: PPOPN 2
6655: END
// every 0 0$1 trigger not planCaptured and FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var i , tmp , tmp2 , b ;
6656: LD_EXP 7
6660: NOT
6661: PUSH
6662: LD_INT 9
6664: PPUSH
6665: LD_INT 22
6667: PUSH
6668: LD_INT 1
6670: PUSH
6671: EMPTY
6672: LIST
6673: LIST
6674: PUSH
6675: LD_INT 21
6677: PUSH
6678: LD_INT 3
6680: PUSH
6681: EMPTY
6682: LIST
6683: LIST
6684: PUSH
6685: LD_INT 3
6687: PUSH
6688: LD_INT 24
6690: PUSH
6691: LD_INT 1000
6693: PUSH
6694: EMPTY
6695: LIST
6696: LIST
6697: PUSH
6698: EMPTY
6699: LIST
6700: LIST
6701: PUSH
6702: EMPTY
6703: LIST
6704: LIST
6705: LIST
6706: PPUSH
6707: CALL_OW 70
6711: AND
6712: IFFALSE 7123
6714: GO 6716
6716: DISABLE
6717: LD_INT 0
6719: PPUSH
6720: PPUSH
6721: PPUSH
6722: PPUSH
// begin enable ;
6723: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_lives , 1000 ] ] ) ;
6724: LD_ADDR_VAR 0 2
6728: PUSH
6729: LD_INT 22
6731: PUSH
6732: LD_INT 1
6734: PUSH
6735: EMPTY
6736: LIST
6737: LIST
6738: PUSH
6739: LD_INT 25
6741: PUSH
6742: LD_INT 2
6744: PUSH
6745: EMPTY
6746: LIST
6747: LIST
6748: PUSH
6749: LD_INT 24
6751: PUSH
6752: LD_INT 1000
6754: PUSH
6755: EMPTY
6756: LIST
6757: LIST
6758: PUSH
6759: EMPTY
6760: LIST
6761: LIST
6762: LIST
6763: PPUSH
6764: CALL_OW 69
6768: ST_TO_ADDR
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_not , [ f_lives , 750 ] ] ] ) ;
6769: LD_ADDR_VAR 0 3
6773: PUSH
6774: LD_INT 22
6776: PUSH
6777: LD_INT 1
6779: PUSH
6780: EMPTY
6781: LIST
6782: LIST
6783: PUSH
6784: LD_INT 25
6786: PUSH
6787: LD_INT 2
6789: PUSH
6790: EMPTY
6791: LIST
6792: LIST
6793: PUSH
6794: LD_INT 3
6796: PUSH
6797: LD_INT 24
6799: PUSH
6800: LD_INT 750
6802: PUSH
6803: EMPTY
6804: LIST
6805: LIST
6806: PUSH
6807: EMPTY
6808: LIST
6809: LIST
6810: PUSH
6811: EMPTY
6812: LIST
6813: LIST
6814: LIST
6815: PPUSH
6816: CALL_OW 69
6820: ST_TO_ADDR
// b := FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) diff us_lab ;
6821: LD_ADDR_VAR 0 4
6825: PUSH
6826: LD_INT 9
6828: PPUSH
6829: LD_INT 22
6831: PUSH
6832: LD_INT 1
6834: PUSH
6835: EMPTY
6836: LIST
6837: LIST
6838: PUSH
6839: LD_INT 21
6841: PUSH
6842: LD_INT 3
6844: PUSH
6845: EMPTY
6846: LIST
6847: LIST
6848: PUSH
6849: LD_INT 3
6851: PUSH
6852: LD_INT 24
6854: PUSH
6855: LD_INT 1000
6857: PUSH
6858: EMPTY
6859: LIST
6860: LIST
6861: PUSH
6862: EMPTY
6863: LIST
6864: LIST
6865: PUSH
6866: EMPTY
6867: LIST
6868: LIST
6869: LIST
6870: PPUSH
6871: CALL_OW 70
6875: PUSH
6876: LD_INT 1
6878: DIFF
6879: ST_TO_ADDR
// if not tmp and not tmp2 then
6880: LD_VAR 0 2
6884: NOT
6885: PUSH
6886: LD_VAR 0 3
6890: NOT
6891: AND
6892: IFFALSE 6896
// exit ;
6894: GO 7123
// if tmp and b then
6896: LD_VAR 0 2
6900: PUSH
6901: LD_VAR 0 4
6905: AND
6906: IFFALSE 7036
// for i in tmp do
6908: LD_ADDR_VAR 0 1
6912: PUSH
6913: LD_VAR 0 2
6917: PUSH
6918: FOR_IN
6919: IFFALSE 7034
// begin if GetTag ( i ) = 1 and GetLives ( i ) < 1000 then
6921: LD_VAR 0 1
6925: PPUSH
6926: CALL_OW 110
6930: PUSH
6931: LD_INT 1
6933: EQUAL
6934: PUSH
6935: LD_VAR 0 1
6939: PPUSH
6940: CALL_OW 256
6944: PUSH
6945: LD_INT 1000
6947: LESS
6948: AND
6949: IFFALSE 6955
// continue else
6951: GO 6918
6953: GO 6982
// if GetTag ( i ) = 1 then
6955: LD_VAR 0 1
6959: PPUSH
6960: CALL_OW 110
6964: PUSH
6965: LD_INT 1
6967: EQUAL
6968: IFFALSE 6982
// SetTag ( i , 0 ) ;
6970: LD_VAR 0 1
6974: PPUSH
6975: LD_INT 0
6977: PPUSH
6978: CALL_OW 109
// if IsInUnit ( i ) then
6982: LD_VAR 0 1
6986: PPUSH
6987: CALL_OW 310
6991: IFFALSE 7002
// ComExitBuilding ( i ) ;
6993: LD_VAR 0 1
6997: PPUSH
6998: CALL_OW 122
// if not HasTask ( i ) then
7002: LD_VAR 0 1
7006: PPUSH
7007: CALL_OW 314
7011: NOT
7012: IFFALSE 7032
// AddComRepairBuilding ( i , b [ 1 ] ) ;
7014: LD_VAR 0 1
7018: PPUSH
7019: LD_VAR 0 4
7023: PUSH
7024: LD_INT 1
7026: ARRAY
7027: PPUSH
7028: CALL_OW 190
// end ;
7032: GO 6918
7034: POP
7035: POP
// if tmp2 then
7036: LD_VAR 0 3
7040: IFFALSE 7123
// for i in tmp2 do
7042: LD_ADDR_VAR 0 1
7046: PUSH
7047: LD_VAR 0 3
7051: PUSH
7052: FOR_IN
7053: IFFALSE 7121
// begin if not GetTag ( i ) = 1 then
7055: LD_VAR 0 1
7059: PPUSH
7060: CALL_OW 110
7064: PUSH
7065: LD_INT 1
7067: EQUAL
7068: NOT
7069: IFFALSE 7083
// SetTag ( i , 1 ) ;
7071: LD_VAR 0 1
7075: PPUSH
7076: LD_INT 1
7078: PPUSH
7079: CALL_OW 109
// if GetDistUnitXY ( i , 88 , 75 ) > 6 then
7083: LD_VAR 0 1
7087: PPUSH
7088: LD_INT 88
7090: PPUSH
7091: LD_INT 75
7093: PPUSH
7094: CALL_OW 297
7098: PUSH
7099: LD_INT 6
7101: GREATER
7102: IFFALSE 7119
// ComMoveXY ( i , 88 , 75 ) ;
7104: LD_VAR 0 1
7108: PPUSH
7109: LD_INT 88
7111: PPUSH
7112: LD_INT 75
7114: PPUSH
7115: CALL_OW 111
// end ;
7119: GO 7052
7121: POP
7122: POP
// end ;
7123: PPOPN 4
7125: END
// every 0 0$1 trigger not planCaptured and stevensTimer and FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var i , sci , tmp ;
7126: LD_EXP 7
7130: NOT
7131: PUSH
7132: LD_EXP 9
7136: AND
7137: PUSH
7138: LD_INT 9
7140: PPUSH
7141: LD_INT 22
7143: PUSH
7144: LD_INT 1
7146: PUSH
7147: EMPTY
7148: LIST
7149: LIST
7150: PUSH
7151: LD_INT 21
7153: PUSH
7154: LD_INT 1
7156: PUSH
7157: EMPTY
7158: LIST
7159: LIST
7160: PUSH
7161: LD_INT 3
7163: PUSH
7164: LD_INT 24
7166: PUSH
7167: LD_INT 1000
7169: PUSH
7170: EMPTY
7171: LIST
7172: LIST
7173: PUSH
7174: EMPTY
7175: LIST
7176: LIST
7177: PUSH
7178: EMPTY
7179: LIST
7180: LIST
7181: LIST
7182: PPUSH
7183: CALL_OW 70
7187: AND
7188: IFFALSE 7361
7190: GO 7192
7192: DISABLE
7193: LD_INT 0
7195: PPUSH
7196: PPUSH
7197: PPUSH
// begin enable ;
7198: ENABLE
// sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
7199: LD_ADDR_VAR 0 2
7203: PUSH
7204: LD_INT 22
7206: PUSH
7207: LD_INT 1
7209: PUSH
7210: EMPTY
7211: LIST
7212: LIST
7213: PUSH
7214: LD_INT 25
7216: PUSH
7217: LD_INT 4
7219: PUSH
7220: EMPTY
7221: LIST
7222: LIST
7223: PUSH
7224: EMPTY
7225: LIST
7226: LIST
7227: PPUSH
7228: CALL_OW 69
7232: ST_TO_ADDR
// tmp := FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
7233: LD_ADDR_VAR 0 3
7237: PUSH
7238: LD_INT 9
7240: PPUSH
7241: LD_INT 22
7243: PUSH
7244: LD_INT 1
7246: PUSH
7247: EMPTY
7248: LIST
7249: LIST
7250: PUSH
7251: LD_INT 21
7253: PUSH
7254: LD_INT 1
7256: PUSH
7257: EMPTY
7258: LIST
7259: LIST
7260: PUSH
7261: LD_INT 3
7263: PUSH
7264: LD_INT 24
7266: PUSH
7267: LD_INT 1000
7269: PUSH
7270: EMPTY
7271: LIST
7272: LIST
7273: PUSH
7274: EMPTY
7275: LIST
7276: LIST
7277: PUSH
7278: EMPTY
7279: LIST
7280: LIST
7281: LIST
7282: PPUSH
7283: CALL_OW 70
7287: ST_TO_ADDR
// if not sci or not tmp then
7288: LD_VAR 0 2
7292: NOT
7293: PUSH
7294: LD_VAR 0 3
7298: NOT
7299: OR
7300: IFFALSE 7304
// exit ;
7302: GO 7361
// for i in sci do
7304: LD_ADDR_VAR 0 1
7308: PUSH
7309: LD_VAR 0 2
7313: PUSH
7314: FOR_IN
7315: IFFALSE 7359
// if IsInUnit ( i ) then
7317: LD_VAR 0 1
7321: PPUSH
7322: CALL_OW 310
7326: IFFALSE 7339
// ComExitBuilding ( i ) else
7328: LD_VAR 0 1
7332: PPUSH
7333: CALL_OW 122
7337: GO 7357
// ComHeal ( i , tmp [ 1 ] ) ;
7339: LD_VAR 0 1
7343: PPUSH
7344: LD_VAR 0 3
7348: PUSH
7349: LD_INT 1
7351: ARRAY
7352: PPUSH
7353: CALL_OW 128
7357: GO 7314
7359: POP
7360: POP
// end ;
7361: PPOPN 3
7363: END
// every 0 0$1 trigger not planCaptured and stevensTimer and IsOk ( us_lab ) and not FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_outside ] ] ) do var i ;
7364: LD_EXP 7
7368: NOT
7369: PUSH
7370: LD_EXP 9
7374: AND
7375: PUSH
7376: LD_INT 1
7378: PPUSH
7379: CALL_OW 302
7383: AND
7384: PUSH
7385: LD_INT 9
7387: PPUSH
7388: LD_INT 22
7390: PUSH
7391: LD_INT 1
7393: PUSH
7394: EMPTY
7395: LIST
7396: LIST
7397: PUSH
7398: LD_INT 21
7400: PUSH
7401: LD_INT 1
7403: PUSH
7404: EMPTY
7405: LIST
7406: LIST
7407: PUSH
7408: LD_INT 3
7410: PUSH
7411: LD_INT 24
7413: PUSH
7414: LD_INT 1000
7416: PUSH
7417: EMPTY
7418: LIST
7419: LIST
7420: PUSH
7421: EMPTY
7422: LIST
7423: LIST
7424: PUSH
7425: EMPTY
7426: LIST
7427: LIST
7428: LIST
7429: PPUSH
7430: CALL_OW 70
7434: NOT
7435: AND
7436: PUSH
7437: LD_INT 22
7439: PUSH
7440: LD_INT 1
7442: PUSH
7443: EMPTY
7444: LIST
7445: LIST
7446: PUSH
7447: LD_INT 25
7449: PUSH
7450: LD_INT 4
7452: PUSH
7453: EMPTY
7454: LIST
7455: LIST
7456: PUSH
7457: LD_INT 56
7459: PUSH
7460: EMPTY
7461: LIST
7462: PUSH
7463: EMPTY
7464: LIST
7465: LIST
7466: LIST
7467: PPUSH
7468: CALL_OW 69
7472: AND
7473: IFFALSE 7566
7475: GO 7477
7477: DISABLE
7478: LD_INT 0
7480: PPUSH
// begin enable ;
7481: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_outside ] ] ) do
7482: LD_ADDR_VAR 0 1
7486: PUSH
7487: LD_INT 22
7489: PUSH
7490: LD_INT 1
7492: PUSH
7493: EMPTY
7494: LIST
7495: LIST
7496: PUSH
7497: LD_INT 25
7499: PUSH
7500: LD_INT 4
7502: PUSH
7503: EMPTY
7504: LIST
7505: LIST
7506: PUSH
7507: LD_INT 56
7509: PUSH
7510: EMPTY
7511: LIST
7512: PUSH
7513: EMPTY
7514: LIST
7515: LIST
7516: LIST
7517: PPUSH
7518: CALL_OW 69
7522: PUSH
7523: FOR_IN
7524: IFFALSE 7564
// if not GetTag ( i ) and not HasTask ( i ) then
7526: LD_VAR 0 1
7530: PPUSH
7531: CALL_OW 110
7535: NOT
7536: PUSH
7537: LD_VAR 0 1
7541: PPUSH
7542: CALL_OW 314
7546: NOT
7547: AND
7548: IFFALSE 7562
// ComEnterUnit ( i , us_lab ) ;
7550: LD_VAR 0 1
7554: PPUSH
7555: LD_INT 1
7557: PPUSH
7558: CALL_OW 120
7562: GO 7523
7564: POP
7565: POP
// end ;
7566: PPOPN 1
7568: END
// every 0 0$1 trigger not planCaptured and not FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_outside ] ] ) do var i ;
7569: LD_EXP 7
7573: NOT
7574: PUSH
7575: LD_INT 9
7577: PPUSH
7578: LD_INT 22
7580: PUSH
7581: LD_INT 1
7583: PUSH
7584: EMPTY
7585: LIST
7586: LIST
7587: PUSH
7588: LD_INT 21
7590: PUSH
7591: LD_INT 3
7593: PUSH
7594: EMPTY
7595: LIST
7596: LIST
7597: PUSH
7598: LD_INT 3
7600: PUSH
7601: LD_INT 24
7603: PUSH
7604: LD_INT 1000
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: PUSH
7611: EMPTY
7612: LIST
7613: LIST
7614: PUSH
7615: EMPTY
7616: LIST
7617: LIST
7618: LIST
7619: PPUSH
7620: CALL_OW 70
7624: NOT
7625: AND
7626: PUSH
7627: LD_INT 22
7629: PUSH
7630: LD_INT 1
7632: PUSH
7633: EMPTY
7634: LIST
7635: LIST
7636: PUSH
7637: LD_INT 25
7639: PUSH
7640: LD_INT 2
7642: PUSH
7643: EMPTY
7644: LIST
7645: LIST
7646: PUSH
7647: LD_INT 56
7649: PUSH
7650: EMPTY
7651: LIST
7652: PUSH
7653: EMPTY
7654: LIST
7655: LIST
7656: LIST
7657: PPUSH
7658: CALL_OW 69
7662: AND
7663: IFFALSE 7756
7665: GO 7667
7667: DISABLE
7668: LD_INT 0
7670: PPUSH
// begin enable ;
7671: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_outside ] ] ) do
7672: LD_ADDR_VAR 0 1
7676: PUSH
7677: LD_INT 22
7679: PUSH
7680: LD_INT 1
7682: PUSH
7683: EMPTY
7684: LIST
7685: LIST
7686: PUSH
7687: LD_INT 25
7689: PUSH
7690: LD_INT 2
7692: PUSH
7693: EMPTY
7694: LIST
7695: LIST
7696: PUSH
7697: LD_INT 56
7699: PUSH
7700: EMPTY
7701: LIST
7702: PUSH
7703: EMPTY
7704: LIST
7705: LIST
7706: LIST
7707: PPUSH
7708: CALL_OW 69
7712: PUSH
7713: FOR_IN
7714: IFFALSE 7754
// if not HasTask ( i ) and not GetTag ( i ) then
7716: LD_VAR 0 1
7720: PPUSH
7721: CALL_OW 314
7725: NOT
7726: PUSH
7727: LD_VAR 0 1
7731: PPUSH
7732: CALL_OW 110
7736: NOT
7737: AND
7738: IFFALSE 7752
// ComEnterUnit ( i , us_depot ) ;
7740: LD_VAR 0 1
7744: PPUSH
7745: LD_INT 5
7747: PPUSH
7748: CALL_OW 120
7752: GO 7713
7754: POP
7755: POP
// end ;
7756: PPOPN 1
7758: END
// every 0 0$1 trigger ( stevensTimer <= 0 0$00 or IsDead ( Stevens ) ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) do
7759: LD_EXP 9
7763: PUSH
7764: LD_INT 0
7766: LESSEQUAL
7767: PUSH
7768: LD_EXP 18
7772: PPUSH
7773: CALL_OW 301
7777: OR
7778: PUSH
7779: LD_INT 22
7781: PUSH
7782: LD_INT 1
7784: PUSH
7785: EMPTY
7786: LIST
7787: LIST
7788: PUSH
7789: LD_INT 25
7791: PUSH
7792: LD_INT 2
7794: PUSH
7795: EMPTY
7796: LIST
7797: LIST
7798: PUSH
7799: EMPTY
7800: LIST
7801: LIST
7802: PPUSH
7803: CALL_OW 69
7807: AND
7808: IFFALSE 7849
7810: GO 7812
7812: DISABLE
// ComDismantle ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) , us_lab ) ;
7813: LD_INT 22
7815: PUSH
7816: LD_INT 1
7818: PUSH
7819: EMPTY
7820: LIST
7821: LIST
7822: PUSH
7823: LD_INT 25
7825: PUSH
7826: LD_INT 2
7828: PUSH
7829: EMPTY
7830: LIST
7831: LIST
7832: PUSH
7833: EMPTY
7834: LIST
7835: LIST
7836: PPUSH
7837: CALL_OW 69
7841: PPUSH
7842: LD_INT 1
7844: PPUSH
7845: CALL_OW 167
7849: END
// every 0 0$4 trigger not planCaptured and FilterUnitsInArea ( usBaseCriticalArea , [ f_side , 7 ] ) do var i ;
7850: LD_EXP 7
7854: NOT
7855: PUSH
7856: LD_INT 7
7858: PPUSH
7859: LD_INT 22
7861: PUSH
7862: LD_INT 7
7864: PUSH
7865: EMPTY
7866: LIST
7867: LIST
7868: PPUSH
7869: CALL_OW 70
7873: AND
7874: IFFALSE 7965
7876: GO 7878
7878: DISABLE
7879: LD_INT 0
7881: PPUSH
// begin wait ( 0 0$2 ) ;
7882: LD_INT 70
7884: PPUSH
7885: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) do
7889: LD_ADDR_VAR 0 1
7893: PUSH
7894: LD_INT 22
7896: PUSH
7897: LD_INT 1
7899: PUSH
7900: EMPTY
7901: LIST
7902: LIST
7903: PUSH
7904: LD_INT 25
7906: PUSH
7907: LD_INT 1
7909: PUSH
7910: EMPTY
7911: LIST
7912: LIST
7913: PUSH
7914: EMPTY
7915: LIST
7916: LIST
7917: PPUSH
7918: CALL_OW 69
7922: PUSH
7923: FOR_IN
7924: IFFALSE 7963
// begin if IsInUnit ( i ) then
7926: LD_VAR 0 1
7930: PPUSH
7931: CALL_OW 310
7935: IFFALSE 7946
// ComExitBuilding ( i ) ;
7937: LD_VAR 0 1
7941: PPUSH
7942: CALL_OW 122
// AddComAgressiveMove ( i , 92 , 78 ) ;
7946: LD_VAR 0 1
7950: PPUSH
7951: LD_INT 92
7953: PPUSH
7954: LD_INT 78
7956: PPUSH
7957: CALL_OW 174
// end ;
7961: GO 7923
7963: POP
7964: POP
// end ; end_of_file
7965: PPOPN 1
7967: END
// on SiberiteRocketExploded ( sibRocket , x , y ) do OnBombExploded ( sibRocket , x , y ) ;
7968: LD_VAR 0 1
7972: PPUSH
7973: LD_VAR 0 2
7977: PPUSH
7978: LD_VAR 0 3
7982: PPUSH
7983: CALL 2823 0 3
7987: PPOPN 3
7989: END
// on UnitGoesToRed ( un ) do begin if GetClass ( JMM ) = 4 or GetClass ( Burlak ) = 4 then
7990: LD_EXP 14
7994: PPUSH
7995: CALL_OW 257
7999: PUSH
8000: LD_INT 4
8002: EQUAL
8003: PUSH
8004: LD_EXP 15
8008: PPUSH
8009: CALL_OW 257
8013: PUSH
8014: LD_INT 4
8016: EQUAL
8017: OR
8018: IFFALSE 8022
// exit ;
8020: GO 8060
// if un = JMM then
8022: LD_VAR 0 1
8026: PUSH
8027: LD_EXP 14
8031: EQUAL
8032: IFFALSE 8041
// YouLost ( JMM ) ;
8034: LD_STRING JMM
8036: PPUSH
8037: CALL_OW 104
// if un = Burlak then
8041: LD_VAR 0 1
8045: PUSH
8046: LD_EXP 15
8050: EQUAL
8051: IFFALSE 8060
// YouLost ( Burlak ) ;
8053: LD_STRING Burlak
8055: PPUSH
8056: CALL_OW 104
// end ;
8060: PPOPN 1
8062: END
// on UnitDestroyed ( un ) do begin if un = JMM then
8063: LD_VAR 0 1
8067: PUSH
8068: LD_EXP 14
8072: EQUAL
8073: IFFALSE 8082
// YouLost ( JMM ) ;
8075: LD_STRING JMM
8077: PPUSH
8078: CALL_OW 104
// if un = Burlak then
8082: LD_VAR 0 1
8086: PUSH
8087: LD_EXP 15
8091: EQUAL
8092: IFFALSE 8101
// YouLost ( Burlak ) ;
8094: LD_STRING Burlak
8096: PPUSH
8097: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
8101: LD_VAR 0 1
8105: PUSH
8106: LD_INT 21
8108: PUSH
8109: LD_INT 1
8111: PUSH
8112: EMPTY
8113: LIST
8114: LIST
8115: PUSH
8116: LD_INT 23
8118: PUSH
8119: LD_INT 1
8121: PUSH
8122: EMPTY
8123: LIST
8124: LIST
8125: PUSH
8126: EMPTY
8127: LIST
8128: LIST
8129: PPUSH
8130: CALL_OW 69
8134: IN
8135: IFFALSE 8151
// killCounter := killCounter + 1 ;
8137: LD_ADDR_EXP 12
8141: PUSH
8142: LD_EXP 12
8146: PUSH
8147: LD_INT 1
8149: PLUS
8150: ST_TO_ADDR
// end ;
8151: PPOPN 1
8153: END
// on UnitDestroyed_Extra ( un , killer_side , killer_unit ) do begin if killer_side = 7 and un in FilterAllUnits ( [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
8154: LD_VAR 0 2
8158: PUSH
8159: LD_INT 7
8161: EQUAL
8162: PUSH
8163: LD_VAR 0 1
8167: PUSH
8168: LD_INT 2
8170: PUSH
8171: LD_INT 30
8173: PUSH
8174: LD_INT 31
8176: PUSH
8177: EMPTY
8178: LIST
8179: LIST
8180: PUSH
8181: LD_INT 30
8183: PUSH
8184: LD_INT 32
8186: PUSH
8187: EMPTY
8188: LIST
8189: LIST
8190: PUSH
8191: LD_INT 30
8193: PUSH
8194: LD_INT 33
8196: PUSH
8197: EMPTY
8198: LIST
8199: LIST
8200: PUSH
8201: EMPTY
8202: LIST
8203: LIST
8204: LIST
8205: LIST
8206: PPUSH
8207: CALL_OW 69
8211: IN
8212: AND
8213: IFFALSE 8229
// bunkerCounter := bunkerCounter + 1 ;
8215: LD_ADDR_EXP 13
8219: PUSH
8220: LD_EXP 13
8224: PUSH
8225: LD_INT 1
8227: PLUS
8228: ST_TO_ADDR
// end ;
8229: PPOPN 3
8231: END
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 7 then
8232: LD_VAR 0 1
8236: PPUSH
8237: CALL_OW 255
8241: PUSH
8242: LD_INT 7
8244: EQUAL
8245: IFFALSE 8255
// artifactPickedUp := true ;
8247: LD_ADDR_EXP 6
8251: PUSH
8252: LD_INT 1
8254: ST_TO_ADDR
// end ;
8255: PPOPN 2
8257: END
// on ArtifactUnloaded ( cargo , artifact ) do artifactPickedUp := false ;
8258: LD_ADDR_EXP 6
8262: PUSH
8263: LD_INT 0
8265: ST_TO_ADDR
8266: PPOPN 2
8268: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( vehicle ) <> 1 then
8269: LD_VAR 0 1
8273: PPUSH
8274: CALL_OW 255
8278: PUSH
8279: LD_INT 1
8281: NONEQUAL
8282: IFFALSE 8286
// exit ;
8284: GO 8333
// wait ( 0 0$5 ) ;
8286: LD_INT 175
8288: PPUSH
8289: CALL_OW 67
// if GetControl ( vehicle ) = control_remote then
8293: LD_VAR 0 1
8297: PPUSH
8298: CALL_OW 263
8302: PUSH
8303: LD_INT 2
8305: EQUAL
8306: IFFALSE 8317
// Connect ( vehicle ) ;
8308: LD_VAR 0 1
8312: PPUSH
8313: CALL 1824 0 1
// vehGuard := vehGuard ^ vehicle ;
8317: LD_ADDR_EXP 23
8321: PUSH
8322: LD_EXP 23
8326: PUSH
8327: LD_VAR 0 1
8331: ADD
8332: ST_TO_ADDR
// end ;
8333: PPOPN 2
8335: END
// on BuildingCaptured ( captured , old_side , unit ) do begin if captured = us_lab and not planCaptured then
8336: LD_VAR 0 1
8340: PUSH
8341: LD_INT 1
8343: EQUAL
8344: PUSH
8345: LD_EXP 7
8349: NOT
8350: AND
8351: IFFALSE 8386
// begin planCaptured := true ;
8353: LD_ADDR_EXP 7
8357: PUSH
8358: LD_INT 1
8360: ST_TO_ADDR
// ChangeMissionObjectives ( MEnd ) ;
8361: LD_STRING MEnd
8363: PPUSH
8364: CALL_OW 337
// canEnd := true ;
8368: LD_ADDR_EXP 10
8372: PUSH
8373: LD_INT 1
8375: ST_TO_ADDR
// missionTime := tick ;
8376: LD_ADDR_EXP 11
8380: PUSH
8381: LD_OWVAR 1
8385: ST_TO_ADDR
// end ; end ;
8386: PPOPN 3
8388: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
8389: LD_VAR 0 1
8393: PPUSH
8394: CALL 19267 0 1
// end ; end_of_file
8398: PPOPN 1
8400: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
8401: GO 8403
8403: DISABLE
// begin ru_radar := 98 ;
8404: LD_ADDR_EXP 24
8408: PUSH
8409: LD_INT 98
8411: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
8412: LD_ADDR_EXP 25
8416: PUSH
8417: LD_INT 89
8419: ST_TO_ADDR
// us_hack := 99 ;
8420: LD_ADDR_EXP 26
8424: PUSH
8425: LD_INT 99
8427: ST_TO_ADDR
// us_artillery := 97 ;
8428: LD_ADDR_EXP 27
8432: PUSH
8433: LD_INT 97
8435: ST_TO_ADDR
// ar_bio_bomb := 91 ;
8436: LD_ADDR_EXP 28
8440: PUSH
8441: LD_INT 91
8443: ST_TO_ADDR
// end ; end_of_file end_of_file
8444: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
8445: GO 8447
8447: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
8448: LD_STRING initStreamRollete();
8450: PPUSH
8451: CALL_OW 559
// InitStreamMode ;
8455: CALL 8464 0 0
// DefineStreamItems ( ) ;
8459: CALL 8904 0 0
// end ;
8463: END
// function InitStreamMode ; begin
8464: LD_INT 0
8466: PPUSH
// streamModeActive := false ;
8467: LD_ADDR_EXP 29
8471: PUSH
8472: LD_INT 0
8474: ST_TO_ADDR
// normalCounter := 26 ;
8475: LD_ADDR_EXP 30
8479: PUSH
8480: LD_INT 26
8482: ST_TO_ADDR
// hardcoreCounter := 12 ;
8483: LD_ADDR_EXP 31
8487: PUSH
8488: LD_INT 12
8490: ST_TO_ADDR
// sRocket := false ;
8491: LD_ADDR_EXP 34
8495: PUSH
8496: LD_INT 0
8498: ST_TO_ADDR
// sSpeed := false ;
8499: LD_ADDR_EXP 33
8503: PUSH
8504: LD_INT 0
8506: ST_TO_ADDR
// sEngine := false ;
8507: LD_ADDR_EXP 35
8511: PUSH
8512: LD_INT 0
8514: ST_TO_ADDR
// sSpec := false ;
8515: LD_ADDR_EXP 32
8519: PUSH
8520: LD_INT 0
8522: ST_TO_ADDR
// sLevel := false ;
8523: LD_ADDR_EXP 36
8527: PUSH
8528: LD_INT 0
8530: ST_TO_ADDR
// sArmoury := false ;
8531: LD_ADDR_EXP 37
8535: PUSH
8536: LD_INT 0
8538: ST_TO_ADDR
// sRadar := false ;
8539: LD_ADDR_EXP 38
8543: PUSH
8544: LD_INT 0
8546: ST_TO_ADDR
// sBunker := false ;
8547: LD_ADDR_EXP 39
8551: PUSH
8552: LD_INT 0
8554: ST_TO_ADDR
// sHack := false ;
8555: LD_ADDR_EXP 40
8559: PUSH
8560: LD_INT 0
8562: ST_TO_ADDR
// sFire := false ;
8563: LD_ADDR_EXP 41
8567: PUSH
8568: LD_INT 0
8570: ST_TO_ADDR
// sRefresh := false ;
8571: LD_ADDR_EXP 42
8575: PUSH
8576: LD_INT 0
8578: ST_TO_ADDR
// sExp := false ;
8579: LD_ADDR_EXP 43
8583: PUSH
8584: LD_INT 0
8586: ST_TO_ADDR
// sDepot := false ;
8587: LD_ADDR_EXP 44
8591: PUSH
8592: LD_INT 0
8594: ST_TO_ADDR
// sFlag := false ;
8595: LD_ADDR_EXP 45
8599: PUSH
8600: LD_INT 0
8602: ST_TO_ADDR
// sKamikadze := false ;
8603: LD_ADDR_EXP 53
8607: PUSH
8608: LD_INT 0
8610: ST_TO_ADDR
// sTroll := false ;
8611: LD_ADDR_EXP 54
8615: PUSH
8616: LD_INT 0
8618: ST_TO_ADDR
// sSlow := false ;
8619: LD_ADDR_EXP 55
8623: PUSH
8624: LD_INT 0
8626: ST_TO_ADDR
// sLack := false ;
8627: LD_ADDR_EXP 56
8631: PUSH
8632: LD_INT 0
8634: ST_TO_ADDR
// sTank := false ;
8635: LD_ADDR_EXP 58
8639: PUSH
8640: LD_INT 0
8642: ST_TO_ADDR
// sRemote := false ;
8643: LD_ADDR_EXP 59
8647: PUSH
8648: LD_INT 0
8650: ST_TO_ADDR
// sPowell := false ;
8651: LD_ADDR_EXP 60
8655: PUSH
8656: LD_INT 0
8658: ST_TO_ADDR
// sTeleport := false ;
8659: LD_ADDR_EXP 63
8663: PUSH
8664: LD_INT 0
8666: ST_TO_ADDR
// sOilTower := false ;
8667: LD_ADDR_EXP 65
8671: PUSH
8672: LD_INT 0
8674: ST_TO_ADDR
// sShovel := false ;
8675: LD_ADDR_EXP 66
8679: PUSH
8680: LD_INT 0
8682: ST_TO_ADDR
// sSheik := false ;
8683: LD_ADDR_EXP 67
8687: PUSH
8688: LD_INT 0
8690: ST_TO_ADDR
// sEarthquake := false ;
8691: LD_ADDR_EXP 69
8695: PUSH
8696: LD_INT 0
8698: ST_TO_ADDR
// sAI := false ;
8699: LD_ADDR_EXP 70
8703: PUSH
8704: LD_INT 0
8706: ST_TO_ADDR
// sCargo := false ;
8707: LD_ADDR_EXP 73
8711: PUSH
8712: LD_INT 0
8714: ST_TO_ADDR
// sDLaser := false ;
8715: LD_ADDR_EXP 74
8719: PUSH
8720: LD_INT 0
8722: ST_TO_ADDR
// sExchange := false ;
8723: LD_ADDR_EXP 75
8727: PUSH
8728: LD_INT 0
8730: ST_TO_ADDR
// sFac := false ;
8731: LD_ADDR_EXP 76
8735: PUSH
8736: LD_INT 0
8738: ST_TO_ADDR
// sPower := false ;
8739: LD_ADDR_EXP 77
8743: PUSH
8744: LD_INT 0
8746: ST_TO_ADDR
// sRandom := false ;
8747: LD_ADDR_EXP 78
8751: PUSH
8752: LD_INT 0
8754: ST_TO_ADDR
// sShield := false ;
8755: LD_ADDR_EXP 79
8759: PUSH
8760: LD_INT 0
8762: ST_TO_ADDR
// sTime := false ;
8763: LD_ADDR_EXP 80
8767: PUSH
8768: LD_INT 0
8770: ST_TO_ADDR
// sTools := false ;
8771: LD_ADDR_EXP 81
8775: PUSH
8776: LD_INT 0
8778: ST_TO_ADDR
// sSold := false ;
8779: LD_ADDR_EXP 46
8783: PUSH
8784: LD_INT 0
8786: ST_TO_ADDR
// sDiff := false ;
8787: LD_ADDR_EXP 47
8791: PUSH
8792: LD_INT 0
8794: ST_TO_ADDR
// sFog := false ;
8795: LD_ADDR_EXP 50
8799: PUSH
8800: LD_INT 0
8802: ST_TO_ADDR
// sReset := false ;
8803: LD_ADDR_EXP 51
8807: PUSH
8808: LD_INT 0
8810: ST_TO_ADDR
// sSun := false ;
8811: LD_ADDR_EXP 52
8815: PUSH
8816: LD_INT 0
8818: ST_TO_ADDR
// sTiger := false ;
8819: LD_ADDR_EXP 48
8823: PUSH
8824: LD_INT 0
8826: ST_TO_ADDR
// sBomb := false ;
8827: LD_ADDR_EXP 49
8831: PUSH
8832: LD_INT 0
8834: ST_TO_ADDR
// sWound := false ;
8835: LD_ADDR_EXP 57
8839: PUSH
8840: LD_INT 0
8842: ST_TO_ADDR
// sBetray := false ;
8843: LD_ADDR_EXP 61
8847: PUSH
8848: LD_INT 0
8850: ST_TO_ADDR
// sContamin := false ;
8851: LD_ADDR_EXP 62
8855: PUSH
8856: LD_INT 0
8858: ST_TO_ADDR
// sOil := false ;
8859: LD_ADDR_EXP 64
8863: PUSH
8864: LD_INT 0
8866: ST_TO_ADDR
// sStu := false ;
8867: LD_ADDR_EXP 68
8871: PUSH
8872: LD_INT 0
8874: ST_TO_ADDR
// sBazooka := false ;
8875: LD_ADDR_EXP 71
8879: PUSH
8880: LD_INT 0
8882: ST_TO_ADDR
// sMortar := false ;
8883: LD_ADDR_EXP 72
8887: PUSH
8888: LD_INT 0
8890: ST_TO_ADDR
// sRanger := false ;
8891: LD_ADDR_EXP 82
8895: PUSH
8896: LD_INT 0
8898: ST_TO_ADDR
// end ;
8899: LD_VAR 0 1
8903: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
8904: LD_INT 0
8906: PPUSH
8907: PPUSH
8908: PPUSH
8909: PPUSH
8910: PPUSH
// result := [ ] ;
8911: LD_ADDR_VAR 0 1
8915: PUSH
8916: EMPTY
8917: ST_TO_ADDR
// if campaign_id = 1 then
8918: LD_OWVAR 69
8922: PUSH
8923: LD_INT 1
8925: EQUAL
8926: IFFALSE 11874
// begin case mission_number of 1 :
8928: LD_OWVAR 70
8932: PUSH
8933: LD_INT 1
8935: DOUBLE
8936: EQUAL
8937: IFTRUE 8941
8939: GO 9005
8941: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
8942: LD_ADDR_VAR 0 1
8946: PUSH
8947: LD_INT 2
8949: PUSH
8950: LD_INT 4
8952: PUSH
8953: LD_INT 11
8955: PUSH
8956: LD_INT 12
8958: PUSH
8959: LD_INT 15
8961: PUSH
8962: LD_INT 16
8964: PUSH
8965: LD_INT 22
8967: PUSH
8968: LD_INT 23
8970: PUSH
8971: LD_INT 26
8973: PUSH
8974: EMPTY
8975: LIST
8976: LIST
8977: LIST
8978: LIST
8979: LIST
8980: LIST
8981: LIST
8982: LIST
8983: LIST
8984: PUSH
8985: LD_INT 101
8987: PUSH
8988: LD_INT 102
8990: PUSH
8991: LD_INT 106
8993: PUSH
8994: EMPTY
8995: LIST
8996: LIST
8997: LIST
8998: PUSH
8999: EMPTY
9000: LIST
9001: LIST
9002: ST_TO_ADDR
9003: GO 11874
9005: LD_INT 2
9007: DOUBLE
9008: EQUAL
9009: IFTRUE 9013
9011: GO 9085
9013: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
9014: LD_ADDR_VAR 0 1
9018: PUSH
9019: LD_INT 2
9021: PUSH
9022: LD_INT 4
9024: PUSH
9025: LD_INT 11
9027: PUSH
9028: LD_INT 12
9030: PUSH
9031: LD_INT 15
9033: PUSH
9034: LD_INT 16
9036: PUSH
9037: LD_INT 22
9039: PUSH
9040: LD_INT 23
9042: PUSH
9043: LD_INT 26
9045: PUSH
9046: EMPTY
9047: LIST
9048: LIST
9049: LIST
9050: LIST
9051: LIST
9052: LIST
9053: LIST
9054: LIST
9055: LIST
9056: PUSH
9057: LD_INT 101
9059: PUSH
9060: LD_INT 102
9062: PUSH
9063: LD_INT 105
9065: PUSH
9066: LD_INT 106
9068: PUSH
9069: LD_INT 108
9071: PUSH
9072: EMPTY
9073: LIST
9074: LIST
9075: LIST
9076: LIST
9077: LIST
9078: PUSH
9079: EMPTY
9080: LIST
9081: LIST
9082: ST_TO_ADDR
9083: GO 11874
9085: LD_INT 3
9087: DOUBLE
9088: EQUAL
9089: IFTRUE 9093
9091: GO 9169
9093: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
9094: LD_ADDR_VAR 0 1
9098: PUSH
9099: LD_INT 2
9101: PUSH
9102: LD_INT 4
9104: PUSH
9105: LD_INT 5
9107: PUSH
9108: LD_INT 11
9110: PUSH
9111: LD_INT 12
9113: PUSH
9114: LD_INT 15
9116: PUSH
9117: LD_INT 16
9119: PUSH
9120: LD_INT 22
9122: PUSH
9123: LD_INT 26
9125: PUSH
9126: LD_INT 36
9128: PUSH
9129: EMPTY
9130: LIST
9131: LIST
9132: LIST
9133: LIST
9134: LIST
9135: LIST
9136: LIST
9137: LIST
9138: LIST
9139: LIST
9140: PUSH
9141: LD_INT 101
9143: PUSH
9144: LD_INT 102
9146: PUSH
9147: LD_INT 105
9149: PUSH
9150: LD_INT 106
9152: PUSH
9153: LD_INT 108
9155: PUSH
9156: EMPTY
9157: LIST
9158: LIST
9159: LIST
9160: LIST
9161: LIST
9162: PUSH
9163: EMPTY
9164: LIST
9165: LIST
9166: ST_TO_ADDR
9167: GO 11874
9169: LD_INT 4
9171: DOUBLE
9172: EQUAL
9173: IFTRUE 9177
9175: GO 9261
9177: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
9178: LD_ADDR_VAR 0 1
9182: PUSH
9183: LD_INT 2
9185: PUSH
9186: LD_INT 4
9188: PUSH
9189: LD_INT 5
9191: PUSH
9192: LD_INT 8
9194: PUSH
9195: LD_INT 11
9197: PUSH
9198: LD_INT 12
9200: PUSH
9201: LD_INT 15
9203: PUSH
9204: LD_INT 16
9206: PUSH
9207: LD_INT 22
9209: PUSH
9210: LD_INT 23
9212: PUSH
9213: LD_INT 26
9215: PUSH
9216: LD_INT 36
9218: PUSH
9219: EMPTY
9220: LIST
9221: LIST
9222: LIST
9223: LIST
9224: LIST
9225: LIST
9226: LIST
9227: LIST
9228: LIST
9229: LIST
9230: LIST
9231: LIST
9232: PUSH
9233: LD_INT 101
9235: PUSH
9236: LD_INT 102
9238: PUSH
9239: LD_INT 105
9241: PUSH
9242: LD_INT 106
9244: PUSH
9245: LD_INT 108
9247: PUSH
9248: EMPTY
9249: LIST
9250: LIST
9251: LIST
9252: LIST
9253: LIST
9254: PUSH
9255: EMPTY
9256: LIST
9257: LIST
9258: ST_TO_ADDR
9259: GO 11874
9261: LD_INT 5
9263: DOUBLE
9264: EQUAL
9265: IFTRUE 9269
9267: GO 9369
9269: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
9270: LD_ADDR_VAR 0 1
9274: PUSH
9275: LD_INT 2
9277: PUSH
9278: LD_INT 4
9280: PUSH
9281: LD_INT 5
9283: PUSH
9284: LD_INT 6
9286: PUSH
9287: LD_INT 8
9289: PUSH
9290: LD_INT 11
9292: PUSH
9293: LD_INT 12
9295: PUSH
9296: LD_INT 15
9298: PUSH
9299: LD_INT 16
9301: PUSH
9302: LD_INT 22
9304: PUSH
9305: LD_INT 23
9307: PUSH
9308: LD_INT 25
9310: PUSH
9311: LD_INT 26
9313: PUSH
9314: LD_INT 36
9316: PUSH
9317: EMPTY
9318: LIST
9319: LIST
9320: LIST
9321: LIST
9322: LIST
9323: LIST
9324: LIST
9325: LIST
9326: LIST
9327: LIST
9328: LIST
9329: LIST
9330: LIST
9331: LIST
9332: PUSH
9333: LD_INT 101
9335: PUSH
9336: LD_INT 102
9338: PUSH
9339: LD_INT 105
9341: PUSH
9342: LD_INT 106
9344: PUSH
9345: LD_INT 108
9347: PUSH
9348: LD_INT 109
9350: PUSH
9351: LD_INT 112
9353: PUSH
9354: EMPTY
9355: LIST
9356: LIST
9357: LIST
9358: LIST
9359: LIST
9360: LIST
9361: LIST
9362: PUSH
9363: EMPTY
9364: LIST
9365: LIST
9366: ST_TO_ADDR
9367: GO 11874
9369: LD_INT 6
9371: DOUBLE
9372: EQUAL
9373: IFTRUE 9377
9375: GO 9497
9377: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
9378: LD_ADDR_VAR 0 1
9382: PUSH
9383: LD_INT 2
9385: PUSH
9386: LD_INT 4
9388: PUSH
9389: LD_INT 5
9391: PUSH
9392: LD_INT 6
9394: PUSH
9395: LD_INT 8
9397: PUSH
9398: LD_INT 11
9400: PUSH
9401: LD_INT 12
9403: PUSH
9404: LD_INT 15
9406: PUSH
9407: LD_INT 16
9409: PUSH
9410: LD_INT 20
9412: PUSH
9413: LD_INT 21
9415: PUSH
9416: LD_INT 22
9418: PUSH
9419: LD_INT 23
9421: PUSH
9422: LD_INT 25
9424: PUSH
9425: LD_INT 26
9427: PUSH
9428: LD_INT 30
9430: PUSH
9431: LD_INT 31
9433: PUSH
9434: LD_INT 32
9436: PUSH
9437: LD_INT 36
9439: PUSH
9440: EMPTY
9441: LIST
9442: LIST
9443: LIST
9444: LIST
9445: LIST
9446: LIST
9447: LIST
9448: LIST
9449: LIST
9450: LIST
9451: LIST
9452: LIST
9453: LIST
9454: LIST
9455: LIST
9456: LIST
9457: LIST
9458: LIST
9459: LIST
9460: PUSH
9461: LD_INT 101
9463: PUSH
9464: LD_INT 102
9466: PUSH
9467: LD_INT 105
9469: PUSH
9470: LD_INT 106
9472: PUSH
9473: LD_INT 108
9475: PUSH
9476: LD_INT 109
9478: PUSH
9479: LD_INT 112
9481: PUSH
9482: EMPTY
9483: LIST
9484: LIST
9485: LIST
9486: LIST
9487: LIST
9488: LIST
9489: LIST
9490: PUSH
9491: EMPTY
9492: LIST
9493: LIST
9494: ST_TO_ADDR
9495: GO 11874
9497: LD_INT 7
9499: DOUBLE
9500: EQUAL
9501: IFTRUE 9505
9503: GO 9605
9505: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
9506: LD_ADDR_VAR 0 1
9510: PUSH
9511: LD_INT 2
9513: PUSH
9514: LD_INT 4
9516: PUSH
9517: LD_INT 5
9519: PUSH
9520: LD_INT 7
9522: PUSH
9523: LD_INT 11
9525: PUSH
9526: LD_INT 12
9528: PUSH
9529: LD_INT 15
9531: PUSH
9532: LD_INT 16
9534: PUSH
9535: LD_INT 20
9537: PUSH
9538: LD_INT 21
9540: PUSH
9541: LD_INT 22
9543: PUSH
9544: LD_INT 23
9546: PUSH
9547: LD_INT 25
9549: PUSH
9550: LD_INT 26
9552: PUSH
9553: EMPTY
9554: LIST
9555: LIST
9556: LIST
9557: LIST
9558: LIST
9559: LIST
9560: LIST
9561: LIST
9562: LIST
9563: LIST
9564: LIST
9565: LIST
9566: LIST
9567: LIST
9568: PUSH
9569: LD_INT 101
9571: PUSH
9572: LD_INT 102
9574: PUSH
9575: LD_INT 103
9577: PUSH
9578: LD_INT 105
9580: PUSH
9581: LD_INT 106
9583: PUSH
9584: LD_INT 108
9586: PUSH
9587: LD_INT 112
9589: PUSH
9590: EMPTY
9591: LIST
9592: LIST
9593: LIST
9594: LIST
9595: LIST
9596: LIST
9597: LIST
9598: PUSH
9599: EMPTY
9600: LIST
9601: LIST
9602: ST_TO_ADDR
9603: GO 11874
9605: LD_INT 8
9607: DOUBLE
9608: EQUAL
9609: IFTRUE 9613
9611: GO 9741
9613: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
9614: LD_ADDR_VAR 0 1
9618: PUSH
9619: LD_INT 2
9621: PUSH
9622: LD_INT 4
9624: PUSH
9625: LD_INT 5
9627: PUSH
9628: LD_INT 6
9630: PUSH
9631: LD_INT 7
9633: PUSH
9634: LD_INT 8
9636: PUSH
9637: LD_INT 11
9639: PUSH
9640: LD_INT 12
9642: PUSH
9643: LD_INT 15
9645: PUSH
9646: LD_INT 16
9648: PUSH
9649: LD_INT 20
9651: PUSH
9652: LD_INT 21
9654: PUSH
9655: LD_INT 22
9657: PUSH
9658: LD_INT 23
9660: PUSH
9661: LD_INT 25
9663: PUSH
9664: LD_INT 26
9666: PUSH
9667: LD_INT 30
9669: PUSH
9670: LD_INT 31
9672: PUSH
9673: LD_INT 32
9675: PUSH
9676: LD_INT 36
9678: PUSH
9679: EMPTY
9680: LIST
9681: LIST
9682: LIST
9683: LIST
9684: LIST
9685: LIST
9686: LIST
9687: LIST
9688: LIST
9689: LIST
9690: LIST
9691: LIST
9692: LIST
9693: LIST
9694: LIST
9695: LIST
9696: LIST
9697: LIST
9698: LIST
9699: LIST
9700: PUSH
9701: LD_INT 101
9703: PUSH
9704: LD_INT 102
9706: PUSH
9707: LD_INT 103
9709: PUSH
9710: LD_INT 105
9712: PUSH
9713: LD_INT 106
9715: PUSH
9716: LD_INT 108
9718: PUSH
9719: LD_INT 109
9721: PUSH
9722: LD_INT 112
9724: PUSH
9725: EMPTY
9726: LIST
9727: LIST
9728: LIST
9729: LIST
9730: LIST
9731: LIST
9732: LIST
9733: LIST
9734: PUSH
9735: EMPTY
9736: LIST
9737: LIST
9738: ST_TO_ADDR
9739: GO 11874
9741: LD_INT 9
9743: DOUBLE
9744: EQUAL
9745: IFTRUE 9749
9747: GO 9885
9749: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
9750: LD_ADDR_VAR 0 1
9754: PUSH
9755: LD_INT 2
9757: PUSH
9758: LD_INT 4
9760: PUSH
9761: LD_INT 5
9763: PUSH
9764: LD_INT 6
9766: PUSH
9767: LD_INT 7
9769: PUSH
9770: LD_INT 8
9772: PUSH
9773: LD_INT 11
9775: PUSH
9776: LD_INT 12
9778: PUSH
9779: LD_INT 15
9781: PUSH
9782: LD_INT 16
9784: PUSH
9785: LD_INT 20
9787: PUSH
9788: LD_INT 21
9790: PUSH
9791: LD_INT 22
9793: PUSH
9794: LD_INT 23
9796: PUSH
9797: LD_INT 25
9799: PUSH
9800: LD_INT 26
9802: PUSH
9803: LD_INT 28
9805: PUSH
9806: LD_INT 30
9808: PUSH
9809: LD_INT 31
9811: PUSH
9812: LD_INT 32
9814: PUSH
9815: LD_INT 36
9817: PUSH
9818: EMPTY
9819: LIST
9820: LIST
9821: LIST
9822: LIST
9823: LIST
9824: LIST
9825: LIST
9826: LIST
9827: LIST
9828: LIST
9829: LIST
9830: LIST
9831: LIST
9832: LIST
9833: LIST
9834: LIST
9835: LIST
9836: LIST
9837: LIST
9838: LIST
9839: LIST
9840: PUSH
9841: LD_INT 101
9843: PUSH
9844: LD_INT 102
9846: PUSH
9847: LD_INT 103
9849: PUSH
9850: LD_INT 105
9852: PUSH
9853: LD_INT 106
9855: PUSH
9856: LD_INT 108
9858: PUSH
9859: LD_INT 109
9861: PUSH
9862: LD_INT 112
9864: PUSH
9865: LD_INT 114
9867: PUSH
9868: EMPTY
9869: LIST
9870: LIST
9871: LIST
9872: LIST
9873: LIST
9874: LIST
9875: LIST
9876: LIST
9877: LIST
9878: PUSH
9879: EMPTY
9880: LIST
9881: LIST
9882: ST_TO_ADDR
9883: GO 11874
9885: LD_INT 10
9887: DOUBLE
9888: EQUAL
9889: IFTRUE 9893
9891: GO 10077
9893: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
9894: LD_ADDR_VAR 0 1
9898: PUSH
9899: LD_INT 2
9901: PUSH
9902: LD_INT 4
9904: PUSH
9905: LD_INT 5
9907: PUSH
9908: LD_INT 6
9910: PUSH
9911: LD_INT 7
9913: PUSH
9914: LD_INT 8
9916: PUSH
9917: LD_INT 9
9919: PUSH
9920: LD_INT 10
9922: PUSH
9923: LD_INT 11
9925: PUSH
9926: LD_INT 12
9928: PUSH
9929: LD_INT 13
9931: PUSH
9932: LD_INT 14
9934: PUSH
9935: LD_INT 15
9937: PUSH
9938: LD_INT 16
9940: PUSH
9941: LD_INT 17
9943: PUSH
9944: LD_INT 18
9946: PUSH
9947: LD_INT 19
9949: PUSH
9950: LD_INT 20
9952: PUSH
9953: LD_INT 21
9955: PUSH
9956: LD_INT 22
9958: PUSH
9959: LD_INT 23
9961: PUSH
9962: LD_INT 24
9964: PUSH
9965: LD_INT 25
9967: PUSH
9968: LD_INT 26
9970: PUSH
9971: LD_INT 28
9973: PUSH
9974: LD_INT 30
9976: PUSH
9977: LD_INT 31
9979: PUSH
9980: LD_INT 32
9982: PUSH
9983: LD_INT 36
9985: PUSH
9986: EMPTY
9987: LIST
9988: LIST
9989: LIST
9990: LIST
9991: LIST
9992: LIST
9993: LIST
9994: LIST
9995: LIST
9996: LIST
9997: LIST
9998: LIST
9999: LIST
10000: LIST
10001: LIST
10002: LIST
10003: LIST
10004: LIST
10005: LIST
10006: LIST
10007: LIST
10008: LIST
10009: LIST
10010: LIST
10011: LIST
10012: LIST
10013: LIST
10014: LIST
10015: LIST
10016: PUSH
10017: LD_INT 101
10019: PUSH
10020: LD_INT 102
10022: PUSH
10023: LD_INT 103
10025: PUSH
10026: LD_INT 104
10028: PUSH
10029: LD_INT 105
10031: PUSH
10032: LD_INT 106
10034: PUSH
10035: LD_INT 107
10037: PUSH
10038: LD_INT 108
10040: PUSH
10041: LD_INT 109
10043: PUSH
10044: LD_INT 110
10046: PUSH
10047: LD_INT 111
10049: PUSH
10050: LD_INT 112
10052: PUSH
10053: LD_INT 114
10055: PUSH
10056: EMPTY
10057: LIST
10058: LIST
10059: LIST
10060: LIST
10061: LIST
10062: LIST
10063: LIST
10064: LIST
10065: LIST
10066: LIST
10067: LIST
10068: LIST
10069: LIST
10070: PUSH
10071: EMPTY
10072: LIST
10073: LIST
10074: ST_TO_ADDR
10075: GO 11874
10077: LD_INT 11
10079: DOUBLE
10080: EQUAL
10081: IFTRUE 10085
10083: GO 10277
10085: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
10086: LD_ADDR_VAR 0 1
10090: PUSH
10091: LD_INT 2
10093: PUSH
10094: LD_INT 3
10096: PUSH
10097: LD_INT 4
10099: PUSH
10100: LD_INT 5
10102: PUSH
10103: LD_INT 6
10105: PUSH
10106: LD_INT 7
10108: PUSH
10109: LD_INT 8
10111: PUSH
10112: LD_INT 9
10114: PUSH
10115: LD_INT 10
10117: PUSH
10118: LD_INT 11
10120: PUSH
10121: LD_INT 12
10123: PUSH
10124: LD_INT 13
10126: PUSH
10127: LD_INT 14
10129: PUSH
10130: LD_INT 15
10132: PUSH
10133: LD_INT 16
10135: PUSH
10136: LD_INT 17
10138: PUSH
10139: LD_INT 18
10141: PUSH
10142: LD_INT 19
10144: PUSH
10145: LD_INT 20
10147: PUSH
10148: LD_INT 21
10150: PUSH
10151: LD_INT 22
10153: PUSH
10154: LD_INT 23
10156: PUSH
10157: LD_INT 24
10159: PUSH
10160: LD_INT 25
10162: PUSH
10163: LD_INT 26
10165: PUSH
10166: LD_INT 28
10168: PUSH
10169: LD_INT 30
10171: PUSH
10172: LD_INT 31
10174: PUSH
10175: LD_INT 32
10177: PUSH
10178: LD_INT 34
10180: PUSH
10181: LD_INT 36
10183: PUSH
10184: EMPTY
10185: LIST
10186: LIST
10187: LIST
10188: LIST
10189: LIST
10190: LIST
10191: LIST
10192: LIST
10193: LIST
10194: LIST
10195: LIST
10196: LIST
10197: LIST
10198: LIST
10199: LIST
10200: LIST
10201: LIST
10202: LIST
10203: LIST
10204: LIST
10205: LIST
10206: LIST
10207: LIST
10208: LIST
10209: LIST
10210: LIST
10211: LIST
10212: LIST
10213: LIST
10214: LIST
10215: LIST
10216: PUSH
10217: LD_INT 101
10219: PUSH
10220: LD_INT 102
10222: PUSH
10223: LD_INT 103
10225: PUSH
10226: LD_INT 104
10228: PUSH
10229: LD_INT 105
10231: PUSH
10232: LD_INT 106
10234: PUSH
10235: LD_INT 107
10237: PUSH
10238: LD_INT 108
10240: PUSH
10241: LD_INT 109
10243: PUSH
10244: LD_INT 110
10246: PUSH
10247: LD_INT 111
10249: PUSH
10250: LD_INT 112
10252: PUSH
10253: LD_INT 114
10255: PUSH
10256: EMPTY
10257: LIST
10258: LIST
10259: LIST
10260: LIST
10261: LIST
10262: LIST
10263: LIST
10264: LIST
10265: LIST
10266: LIST
10267: LIST
10268: LIST
10269: LIST
10270: PUSH
10271: EMPTY
10272: LIST
10273: LIST
10274: ST_TO_ADDR
10275: GO 11874
10277: LD_INT 12
10279: DOUBLE
10280: EQUAL
10281: IFTRUE 10285
10283: GO 10493
10285: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
10286: LD_ADDR_VAR 0 1
10290: PUSH
10291: LD_INT 1
10293: PUSH
10294: LD_INT 2
10296: PUSH
10297: LD_INT 3
10299: PUSH
10300: LD_INT 4
10302: PUSH
10303: LD_INT 5
10305: PUSH
10306: LD_INT 6
10308: PUSH
10309: LD_INT 7
10311: PUSH
10312: LD_INT 8
10314: PUSH
10315: LD_INT 9
10317: PUSH
10318: LD_INT 10
10320: PUSH
10321: LD_INT 11
10323: PUSH
10324: LD_INT 12
10326: PUSH
10327: LD_INT 13
10329: PUSH
10330: LD_INT 14
10332: PUSH
10333: LD_INT 15
10335: PUSH
10336: LD_INT 16
10338: PUSH
10339: LD_INT 17
10341: PUSH
10342: LD_INT 18
10344: PUSH
10345: LD_INT 19
10347: PUSH
10348: LD_INT 20
10350: PUSH
10351: LD_INT 21
10353: PUSH
10354: LD_INT 22
10356: PUSH
10357: LD_INT 23
10359: PUSH
10360: LD_INT 24
10362: PUSH
10363: LD_INT 25
10365: PUSH
10366: LD_INT 26
10368: PUSH
10369: LD_INT 27
10371: PUSH
10372: LD_INT 28
10374: PUSH
10375: LD_INT 30
10377: PUSH
10378: LD_INT 31
10380: PUSH
10381: LD_INT 32
10383: PUSH
10384: LD_INT 33
10386: PUSH
10387: LD_INT 34
10389: PUSH
10390: LD_INT 36
10392: PUSH
10393: EMPTY
10394: LIST
10395: LIST
10396: LIST
10397: LIST
10398: LIST
10399: LIST
10400: LIST
10401: LIST
10402: LIST
10403: LIST
10404: LIST
10405: LIST
10406: LIST
10407: LIST
10408: LIST
10409: LIST
10410: LIST
10411: LIST
10412: LIST
10413: LIST
10414: LIST
10415: LIST
10416: LIST
10417: LIST
10418: LIST
10419: LIST
10420: LIST
10421: LIST
10422: LIST
10423: LIST
10424: LIST
10425: LIST
10426: LIST
10427: LIST
10428: PUSH
10429: LD_INT 101
10431: PUSH
10432: LD_INT 102
10434: PUSH
10435: LD_INT 103
10437: PUSH
10438: LD_INT 104
10440: PUSH
10441: LD_INT 105
10443: PUSH
10444: LD_INT 106
10446: PUSH
10447: LD_INT 107
10449: PUSH
10450: LD_INT 108
10452: PUSH
10453: LD_INT 109
10455: PUSH
10456: LD_INT 110
10458: PUSH
10459: LD_INT 111
10461: PUSH
10462: LD_INT 112
10464: PUSH
10465: LD_INT 113
10467: PUSH
10468: LD_INT 114
10470: PUSH
10471: EMPTY
10472: LIST
10473: LIST
10474: LIST
10475: LIST
10476: LIST
10477: LIST
10478: LIST
10479: LIST
10480: LIST
10481: LIST
10482: LIST
10483: LIST
10484: LIST
10485: LIST
10486: PUSH
10487: EMPTY
10488: LIST
10489: LIST
10490: ST_TO_ADDR
10491: GO 11874
10493: LD_INT 13
10495: DOUBLE
10496: EQUAL
10497: IFTRUE 10501
10499: GO 10709
10501: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
10502: LD_ADDR_VAR 0 1
10506: PUSH
10507: LD_INT 1
10509: PUSH
10510: LD_INT 2
10512: PUSH
10513: LD_INT 3
10515: PUSH
10516: LD_INT 4
10518: PUSH
10519: LD_INT 5
10521: PUSH
10522: LD_INT 6
10524: PUSH
10525: LD_INT 7
10527: PUSH
10528: LD_INT 8
10530: PUSH
10531: LD_INT 9
10533: PUSH
10534: LD_INT 10
10536: PUSH
10537: LD_INT 11
10539: PUSH
10540: LD_INT 12
10542: PUSH
10543: LD_INT 13
10545: PUSH
10546: LD_INT 14
10548: PUSH
10549: LD_INT 15
10551: PUSH
10552: LD_INT 16
10554: PUSH
10555: LD_INT 17
10557: PUSH
10558: LD_INT 18
10560: PUSH
10561: LD_INT 19
10563: PUSH
10564: LD_INT 20
10566: PUSH
10567: LD_INT 21
10569: PUSH
10570: LD_INT 22
10572: PUSH
10573: LD_INT 23
10575: PUSH
10576: LD_INT 24
10578: PUSH
10579: LD_INT 25
10581: PUSH
10582: LD_INT 26
10584: PUSH
10585: LD_INT 27
10587: PUSH
10588: LD_INT 28
10590: PUSH
10591: LD_INT 30
10593: PUSH
10594: LD_INT 31
10596: PUSH
10597: LD_INT 32
10599: PUSH
10600: LD_INT 33
10602: PUSH
10603: LD_INT 34
10605: PUSH
10606: LD_INT 36
10608: PUSH
10609: EMPTY
10610: LIST
10611: LIST
10612: LIST
10613: LIST
10614: LIST
10615: LIST
10616: LIST
10617: LIST
10618: LIST
10619: LIST
10620: LIST
10621: LIST
10622: LIST
10623: LIST
10624: LIST
10625: LIST
10626: LIST
10627: LIST
10628: LIST
10629: LIST
10630: LIST
10631: LIST
10632: LIST
10633: LIST
10634: LIST
10635: LIST
10636: LIST
10637: LIST
10638: LIST
10639: LIST
10640: LIST
10641: LIST
10642: LIST
10643: LIST
10644: PUSH
10645: LD_INT 101
10647: PUSH
10648: LD_INT 102
10650: PUSH
10651: LD_INT 103
10653: PUSH
10654: LD_INT 104
10656: PUSH
10657: LD_INT 105
10659: PUSH
10660: LD_INT 106
10662: PUSH
10663: LD_INT 107
10665: PUSH
10666: LD_INT 108
10668: PUSH
10669: LD_INT 109
10671: PUSH
10672: LD_INT 110
10674: PUSH
10675: LD_INT 111
10677: PUSH
10678: LD_INT 112
10680: PUSH
10681: LD_INT 113
10683: PUSH
10684: LD_INT 114
10686: PUSH
10687: EMPTY
10688: LIST
10689: LIST
10690: LIST
10691: LIST
10692: LIST
10693: LIST
10694: LIST
10695: LIST
10696: LIST
10697: LIST
10698: LIST
10699: LIST
10700: LIST
10701: LIST
10702: PUSH
10703: EMPTY
10704: LIST
10705: LIST
10706: ST_TO_ADDR
10707: GO 11874
10709: LD_INT 14
10711: DOUBLE
10712: EQUAL
10713: IFTRUE 10717
10715: GO 10929
10717: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
10718: LD_ADDR_VAR 0 1
10722: PUSH
10723: LD_INT 1
10725: PUSH
10726: LD_INT 2
10728: PUSH
10729: LD_INT 3
10731: PUSH
10732: LD_INT 4
10734: PUSH
10735: LD_INT 5
10737: PUSH
10738: LD_INT 6
10740: PUSH
10741: LD_INT 7
10743: PUSH
10744: LD_INT 8
10746: PUSH
10747: LD_INT 9
10749: PUSH
10750: LD_INT 10
10752: PUSH
10753: LD_INT 11
10755: PUSH
10756: LD_INT 12
10758: PUSH
10759: LD_INT 13
10761: PUSH
10762: LD_INT 14
10764: PUSH
10765: LD_INT 15
10767: PUSH
10768: LD_INT 16
10770: PUSH
10771: LD_INT 17
10773: PUSH
10774: LD_INT 18
10776: PUSH
10777: LD_INT 19
10779: PUSH
10780: LD_INT 20
10782: PUSH
10783: LD_INT 21
10785: PUSH
10786: LD_INT 22
10788: PUSH
10789: LD_INT 23
10791: PUSH
10792: LD_INT 24
10794: PUSH
10795: LD_INT 25
10797: PUSH
10798: LD_INT 26
10800: PUSH
10801: LD_INT 27
10803: PUSH
10804: LD_INT 28
10806: PUSH
10807: LD_INT 29
10809: PUSH
10810: LD_INT 30
10812: PUSH
10813: LD_INT 31
10815: PUSH
10816: LD_INT 32
10818: PUSH
10819: LD_INT 33
10821: PUSH
10822: LD_INT 34
10824: PUSH
10825: LD_INT 36
10827: PUSH
10828: EMPTY
10829: LIST
10830: LIST
10831: LIST
10832: LIST
10833: LIST
10834: LIST
10835: LIST
10836: LIST
10837: LIST
10838: LIST
10839: LIST
10840: LIST
10841: LIST
10842: LIST
10843: LIST
10844: LIST
10845: LIST
10846: LIST
10847: LIST
10848: LIST
10849: LIST
10850: LIST
10851: LIST
10852: LIST
10853: LIST
10854: LIST
10855: LIST
10856: LIST
10857: LIST
10858: LIST
10859: LIST
10860: LIST
10861: LIST
10862: LIST
10863: LIST
10864: PUSH
10865: LD_INT 101
10867: PUSH
10868: LD_INT 102
10870: PUSH
10871: LD_INT 103
10873: PUSH
10874: LD_INT 104
10876: PUSH
10877: LD_INT 105
10879: PUSH
10880: LD_INT 106
10882: PUSH
10883: LD_INT 107
10885: PUSH
10886: LD_INT 108
10888: PUSH
10889: LD_INT 109
10891: PUSH
10892: LD_INT 110
10894: PUSH
10895: LD_INT 111
10897: PUSH
10898: LD_INT 112
10900: PUSH
10901: LD_INT 113
10903: PUSH
10904: LD_INT 114
10906: PUSH
10907: EMPTY
10908: LIST
10909: LIST
10910: LIST
10911: LIST
10912: LIST
10913: LIST
10914: LIST
10915: LIST
10916: LIST
10917: LIST
10918: LIST
10919: LIST
10920: LIST
10921: LIST
10922: PUSH
10923: EMPTY
10924: LIST
10925: LIST
10926: ST_TO_ADDR
10927: GO 11874
10929: LD_INT 15
10931: DOUBLE
10932: EQUAL
10933: IFTRUE 10937
10935: GO 11149
10937: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
10938: LD_ADDR_VAR 0 1
10942: PUSH
10943: LD_INT 1
10945: PUSH
10946: LD_INT 2
10948: PUSH
10949: LD_INT 3
10951: PUSH
10952: LD_INT 4
10954: PUSH
10955: LD_INT 5
10957: PUSH
10958: LD_INT 6
10960: PUSH
10961: LD_INT 7
10963: PUSH
10964: LD_INT 8
10966: PUSH
10967: LD_INT 9
10969: PUSH
10970: LD_INT 10
10972: PUSH
10973: LD_INT 11
10975: PUSH
10976: LD_INT 12
10978: PUSH
10979: LD_INT 13
10981: PUSH
10982: LD_INT 14
10984: PUSH
10985: LD_INT 15
10987: PUSH
10988: LD_INT 16
10990: PUSH
10991: LD_INT 17
10993: PUSH
10994: LD_INT 18
10996: PUSH
10997: LD_INT 19
10999: PUSH
11000: LD_INT 20
11002: PUSH
11003: LD_INT 21
11005: PUSH
11006: LD_INT 22
11008: PUSH
11009: LD_INT 23
11011: PUSH
11012: LD_INT 24
11014: PUSH
11015: LD_INT 25
11017: PUSH
11018: LD_INT 26
11020: PUSH
11021: LD_INT 27
11023: PUSH
11024: LD_INT 28
11026: PUSH
11027: LD_INT 29
11029: PUSH
11030: LD_INT 30
11032: PUSH
11033: LD_INT 31
11035: PUSH
11036: LD_INT 32
11038: PUSH
11039: LD_INT 33
11041: PUSH
11042: LD_INT 34
11044: PUSH
11045: LD_INT 36
11047: PUSH
11048: EMPTY
11049: LIST
11050: LIST
11051: LIST
11052: LIST
11053: LIST
11054: LIST
11055: LIST
11056: LIST
11057: LIST
11058: LIST
11059: LIST
11060: LIST
11061: LIST
11062: LIST
11063: LIST
11064: LIST
11065: LIST
11066: LIST
11067: LIST
11068: LIST
11069: LIST
11070: LIST
11071: LIST
11072: LIST
11073: LIST
11074: LIST
11075: LIST
11076: LIST
11077: LIST
11078: LIST
11079: LIST
11080: LIST
11081: LIST
11082: LIST
11083: LIST
11084: PUSH
11085: LD_INT 101
11087: PUSH
11088: LD_INT 102
11090: PUSH
11091: LD_INT 103
11093: PUSH
11094: LD_INT 104
11096: PUSH
11097: LD_INT 105
11099: PUSH
11100: LD_INT 106
11102: PUSH
11103: LD_INT 107
11105: PUSH
11106: LD_INT 108
11108: PUSH
11109: LD_INT 109
11111: PUSH
11112: LD_INT 110
11114: PUSH
11115: LD_INT 111
11117: PUSH
11118: LD_INT 112
11120: PUSH
11121: LD_INT 113
11123: PUSH
11124: LD_INT 114
11126: PUSH
11127: EMPTY
11128: LIST
11129: LIST
11130: LIST
11131: LIST
11132: LIST
11133: LIST
11134: LIST
11135: LIST
11136: LIST
11137: LIST
11138: LIST
11139: LIST
11140: LIST
11141: LIST
11142: PUSH
11143: EMPTY
11144: LIST
11145: LIST
11146: ST_TO_ADDR
11147: GO 11874
11149: LD_INT 16
11151: DOUBLE
11152: EQUAL
11153: IFTRUE 11157
11155: GO 11281
11157: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
11158: LD_ADDR_VAR 0 1
11162: PUSH
11163: LD_INT 2
11165: PUSH
11166: LD_INT 4
11168: PUSH
11169: LD_INT 5
11171: PUSH
11172: LD_INT 7
11174: PUSH
11175: LD_INT 11
11177: PUSH
11178: LD_INT 12
11180: PUSH
11181: LD_INT 15
11183: PUSH
11184: LD_INT 16
11186: PUSH
11187: LD_INT 20
11189: PUSH
11190: LD_INT 21
11192: PUSH
11193: LD_INT 22
11195: PUSH
11196: LD_INT 23
11198: PUSH
11199: LD_INT 25
11201: PUSH
11202: LD_INT 26
11204: PUSH
11205: LD_INT 30
11207: PUSH
11208: LD_INT 31
11210: PUSH
11211: LD_INT 32
11213: PUSH
11214: LD_INT 33
11216: PUSH
11217: LD_INT 34
11219: PUSH
11220: EMPTY
11221: LIST
11222: LIST
11223: LIST
11224: LIST
11225: LIST
11226: LIST
11227: LIST
11228: LIST
11229: LIST
11230: LIST
11231: LIST
11232: LIST
11233: LIST
11234: LIST
11235: LIST
11236: LIST
11237: LIST
11238: LIST
11239: LIST
11240: PUSH
11241: LD_INT 101
11243: PUSH
11244: LD_INT 102
11246: PUSH
11247: LD_INT 103
11249: PUSH
11250: LD_INT 106
11252: PUSH
11253: LD_INT 108
11255: PUSH
11256: LD_INT 112
11258: PUSH
11259: LD_INT 113
11261: PUSH
11262: LD_INT 114
11264: PUSH
11265: EMPTY
11266: LIST
11267: LIST
11268: LIST
11269: LIST
11270: LIST
11271: LIST
11272: LIST
11273: LIST
11274: PUSH
11275: EMPTY
11276: LIST
11277: LIST
11278: ST_TO_ADDR
11279: GO 11874
11281: LD_INT 17
11283: DOUBLE
11284: EQUAL
11285: IFTRUE 11289
11287: GO 11501
11289: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
11290: LD_ADDR_VAR 0 1
11294: PUSH
11295: LD_INT 1
11297: PUSH
11298: LD_INT 2
11300: PUSH
11301: LD_INT 3
11303: PUSH
11304: LD_INT 4
11306: PUSH
11307: LD_INT 5
11309: PUSH
11310: LD_INT 6
11312: PUSH
11313: LD_INT 7
11315: PUSH
11316: LD_INT 8
11318: PUSH
11319: LD_INT 9
11321: PUSH
11322: LD_INT 10
11324: PUSH
11325: LD_INT 11
11327: PUSH
11328: LD_INT 12
11330: PUSH
11331: LD_INT 13
11333: PUSH
11334: LD_INT 14
11336: PUSH
11337: LD_INT 15
11339: PUSH
11340: LD_INT 16
11342: PUSH
11343: LD_INT 17
11345: PUSH
11346: LD_INT 18
11348: PUSH
11349: LD_INT 19
11351: PUSH
11352: LD_INT 20
11354: PUSH
11355: LD_INT 21
11357: PUSH
11358: LD_INT 22
11360: PUSH
11361: LD_INT 23
11363: PUSH
11364: LD_INT 24
11366: PUSH
11367: LD_INT 25
11369: PUSH
11370: LD_INT 26
11372: PUSH
11373: LD_INT 27
11375: PUSH
11376: LD_INT 28
11378: PUSH
11379: LD_INT 29
11381: PUSH
11382: LD_INT 30
11384: PUSH
11385: LD_INT 31
11387: PUSH
11388: LD_INT 32
11390: PUSH
11391: LD_INT 33
11393: PUSH
11394: LD_INT 34
11396: PUSH
11397: LD_INT 36
11399: PUSH
11400: EMPTY
11401: LIST
11402: LIST
11403: LIST
11404: LIST
11405: LIST
11406: LIST
11407: LIST
11408: LIST
11409: LIST
11410: LIST
11411: LIST
11412: LIST
11413: LIST
11414: LIST
11415: LIST
11416: LIST
11417: LIST
11418: LIST
11419: LIST
11420: LIST
11421: LIST
11422: LIST
11423: LIST
11424: LIST
11425: LIST
11426: LIST
11427: LIST
11428: LIST
11429: LIST
11430: LIST
11431: LIST
11432: LIST
11433: LIST
11434: LIST
11435: LIST
11436: PUSH
11437: LD_INT 101
11439: PUSH
11440: LD_INT 102
11442: PUSH
11443: LD_INT 103
11445: PUSH
11446: LD_INT 104
11448: PUSH
11449: LD_INT 105
11451: PUSH
11452: LD_INT 106
11454: PUSH
11455: LD_INT 107
11457: PUSH
11458: LD_INT 108
11460: PUSH
11461: LD_INT 109
11463: PUSH
11464: LD_INT 110
11466: PUSH
11467: LD_INT 111
11469: PUSH
11470: LD_INT 112
11472: PUSH
11473: LD_INT 113
11475: PUSH
11476: LD_INT 114
11478: PUSH
11479: EMPTY
11480: LIST
11481: LIST
11482: LIST
11483: LIST
11484: LIST
11485: LIST
11486: LIST
11487: LIST
11488: LIST
11489: LIST
11490: LIST
11491: LIST
11492: LIST
11493: LIST
11494: PUSH
11495: EMPTY
11496: LIST
11497: LIST
11498: ST_TO_ADDR
11499: GO 11874
11501: LD_INT 18
11503: DOUBLE
11504: EQUAL
11505: IFTRUE 11509
11507: GO 11645
11509: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
11510: LD_ADDR_VAR 0 1
11514: PUSH
11515: LD_INT 2
11517: PUSH
11518: LD_INT 4
11520: PUSH
11521: LD_INT 5
11523: PUSH
11524: LD_INT 7
11526: PUSH
11527: LD_INT 11
11529: PUSH
11530: LD_INT 12
11532: PUSH
11533: LD_INT 15
11535: PUSH
11536: LD_INT 16
11538: PUSH
11539: LD_INT 20
11541: PUSH
11542: LD_INT 21
11544: PUSH
11545: LD_INT 22
11547: PUSH
11548: LD_INT 23
11550: PUSH
11551: LD_INT 25
11553: PUSH
11554: LD_INT 26
11556: PUSH
11557: LD_INT 30
11559: PUSH
11560: LD_INT 31
11562: PUSH
11563: LD_INT 32
11565: PUSH
11566: LD_INT 33
11568: PUSH
11569: LD_INT 34
11571: PUSH
11572: LD_INT 35
11574: PUSH
11575: LD_INT 36
11577: PUSH
11578: EMPTY
11579: LIST
11580: LIST
11581: LIST
11582: LIST
11583: LIST
11584: LIST
11585: LIST
11586: LIST
11587: LIST
11588: LIST
11589: LIST
11590: LIST
11591: LIST
11592: LIST
11593: LIST
11594: LIST
11595: LIST
11596: LIST
11597: LIST
11598: LIST
11599: LIST
11600: PUSH
11601: LD_INT 101
11603: PUSH
11604: LD_INT 102
11606: PUSH
11607: LD_INT 103
11609: PUSH
11610: LD_INT 106
11612: PUSH
11613: LD_INT 108
11615: PUSH
11616: LD_INT 112
11618: PUSH
11619: LD_INT 113
11621: PUSH
11622: LD_INT 114
11624: PUSH
11625: LD_INT 115
11627: PUSH
11628: EMPTY
11629: LIST
11630: LIST
11631: LIST
11632: LIST
11633: LIST
11634: LIST
11635: LIST
11636: LIST
11637: LIST
11638: PUSH
11639: EMPTY
11640: LIST
11641: LIST
11642: ST_TO_ADDR
11643: GO 11874
11645: LD_INT 19
11647: DOUBLE
11648: EQUAL
11649: IFTRUE 11653
11651: GO 11873
11653: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
11654: LD_ADDR_VAR 0 1
11658: PUSH
11659: LD_INT 1
11661: PUSH
11662: LD_INT 2
11664: PUSH
11665: LD_INT 3
11667: PUSH
11668: LD_INT 4
11670: PUSH
11671: LD_INT 5
11673: PUSH
11674: LD_INT 6
11676: PUSH
11677: LD_INT 7
11679: PUSH
11680: LD_INT 8
11682: PUSH
11683: LD_INT 9
11685: PUSH
11686: LD_INT 10
11688: PUSH
11689: LD_INT 11
11691: PUSH
11692: LD_INT 12
11694: PUSH
11695: LD_INT 13
11697: PUSH
11698: LD_INT 14
11700: PUSH
11701: LD_INT 15
11703: PUSH
11704: LD_INT 16
11706: PUSH
11707: LD_INT 17
11709: PUSH
11710: LD_INT 18
11712: PUSH
11713: LD_INT 19
11715: PUSH
11716: LD_INT 20
11718: PUSH
11719: LD_INT 21
11721: PUSH
11722: LD_INT 22
11724: PUSH
11725: LD_INT 23
11727: PUSH
11728: LD_INT 24
11730: PUSH
11731: LD_INT 25
11733: PUSH
11734: LD_INT 26
11736: PUSH
11737: LD_INT 27
11739: PUSH
11740: LD_INT 28
11742: PUSH
11743: LD_INT 29
11745: PUSH
11746: LD_INT 30
11748: PUSH
11749: LD_INT 31
11751: PUSH
11752: LD_INT 32
11754: PUSH
11755: LD_INT 33
11757: PUSH
11758: LD_INT 34
11760: PUSH
11761: LD_INT 35
11763: PUSH
11764: LD_INT 36
11766: PUSH
11767: EMPTY
11768: LIST
11769: LIST
11770: LIST
11771: LIST
11772: LIST
11773: LIST
11774: LIST
11775: LIST
11776: LIST
11777: LIST
11778: LIST
11779: LIST
11780: LIST
11781: LIST
11782: LIST
11783: LIST
11784: LIST
11785: LIST
11786: LIST
11787: LIST
11788: LIST
11789: LIST
11790: LIST
11791: LIST
11792: LIST
11793: LIST
11794: LIST
11795: LIST
11796: LIST
11797: LIST
11798: LIST
11799: LIST
11800: LIST
11801: LIST
11802: LIST
11803: LIST
11804: PUSH
11805: LD_INT 101
11807: PUSH
11808: LD_INT 102
11810: PUSH
11811: LD_INT 103
11813: PUSH
11814: LD_INT 104
11816: PUSH
11817: LD_INT 105
11819: PUSH
11820: LD_INT 106
11822: PUSH
11823: LD_INT 107
11825: PUSH
11826: LD_INT 108
11828: PUSH
11829: LD_INT 109
11831: PUSH
11832: LD_INT 110
11834: PUSH
11835: LD_INT 111
11837: PUSH
11838: LD_INT 112
11840: PUSH
11841: LD_INT 113
11843: PUSH
11844: LD_INT 114
11846: PUSH
11847: LD_INT 115
11849: PUSH
11850: EMPTY
11851: LIST
11852: LIST
11853: LIST
11854: LIST
11855: LIST
11856: LIST
11857: LIST
11858: LIST
11859: LIST
11860: LIST
11861: LIST
11862: LIST
11863: LIST
11864: LIST
11865: LIST
11866: PUSH
11867: EMPTY
11868: LIST
11869: LIST
11870: ST_TO_ADDR
11871: GO 11874
11873: POP
// end ; if result then
11874: LD_VAR 0 1
11878: IFFALSE 12167
// begin normal :=  ;
11880: LD_ADDR_VAR 0 3
11884: PUSH
11885: LD_STRING 
11887: ST_TO_ADDR
// hardcore :=  ;
11888: LD_ADDR_VAR 0 4
11892: PUSH
11893: LD_STRING 
11895: ST_TO_ADDR
// for i = 1 to normalCounter do
11896: LD_ADDR_VAR 0 5
11900: PUSH
11901: DOUBLE
11902: LD_INT 1
11904: DEC
11905: ST_TO_ADDR
11906: LD_EXP 30
11910: PUSH
11911: FOR_TO
11912: IFFALSE 12013
// begin tmp := 0 ;
11914: LD_ADDR_VAR 0 2
11918: PUSH
11919: LD_STRING 0
11921: ST_TO_ADDR
// if result [ 1 ] then
11922: LD_VAR 0 1
11926: PUSH
11927: LD_INT 1
11929: ARRAY
11930: IFFALSE 11995
// if result [ 1 ] [ 1 ] = i then
11932: LD_VAR 0 1
11936: PUSH
11937: LD_INT 1
11939: ARRAY
11940: PUSH
11941: LD_INT 1
11943: ARRAY
11944: PUSH
11945: LD_VAR 0 5
11949: EQUAL
11950: IFFALSE 11995
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
11952: LD_ADDR_VAR 0 1
11956: PUSH
11957: LD_VAR 0 1
11961: PPUSH
11962: LD_INT 1
11964: PPUSH
11965: LD_VAR 0 1
11969: PUSH
11970: LD_INT 1
11972: ARRAY
11973: PPUSH
11974: LD_INT 1
11976: PPUSH
11977: CALL_OW 3
11981: PPUSH
11982: CALL_OW 1
11986: ST_TO_ADDR
// tmp := 1 ;
11987: LD_ADDR_VAR 0 2
11991: PUSH
11992: LD_STRING 1
11994: ST_TO_ADDR
// end ; normal := normal & tmp ;
11995: LD_ADDR_VAR 0 3
11999: PUSH
12000: LD_VAR 0 3
12004: PUSH
12005: LD_VAR 0 2
12009: STR
12010: ST_TO_ADDR
// end ;
12011: GO 11911
12013: POP
12014: POP
// for i = 1 to hardcoreCounter do
12015: LD_ADDR_VAR 0 5
12019: PUSH
12020: DOUBLE
12021: LD_INT 1
12023: DEC
12024: ST_TO_ADDR
12025: LD_EXP 31
12029: PUSH
12030: FOR_TO
12031: IFFALSE 12136
// begin tmp := 0 ;
12033: LD_ADDR_VAR 0 2
12037: PUSH
12038: LD_STRING 0
12040: ST_TO_ADDR
// if result [ 2 ] then
12041: LD_VAR 0 1
12045: PUSH
12046: LD_INT 2
12048: ARRAY
12049: IFFALSE 12118
// if result [ 2 ] [ 1 ] = 100 + i then
12051: LD_VAR 0 1
12055: PUSH
12056: LD_INT 2
12058: ARRAY
12059: PUSH
12060: LD_INT 1
12062: ARRAY
12063: PUSH
12064: LD_INT 100
12066: PUSH
12067: LD_VAR 0 5
12071: PLUS
12072: EQUAL
12073: IFFALSE 12118
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
12075: LD_ADDR_VAR 0 1
12079: PUSH
12080: LD_VAR 0 1
12084: PPUSH
12085: LD_INT 2
12087: PPUSH
12088: LD_VAR 0 1
12092: PUSH
12093: LD_INT 2
12095: ARRAY
12096: PPUSH
12097: LD_INT 1
12099: PPUSH
12100: CALL_OW 3
12104: PPUSH
12105: CALL_OW 1
12109: ST_TO_ADDR
// tmp := 1 ;
12110: LD_ADDR_VAR 0 2
12114: PUSH
12115: LD_STRING 1
12117: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
12118: LD_ADDR_VAR 0 4
12122: PUSH
12123: LD_VAR 0 4
12127: PUSH
12128: LD_VAR 0 2
12132: STR
12133: ST_TO_ADDR
// end ;
12134: GO 12030
12136: POP
12137: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
12138: LD_STRING getStreamItemsFromMission("
12140: PUSH
12141: LD_VAR 0 3
12145: STR
12146: PUSH
12147: LD_STRING ","
12149: STR
12150: PUSH
12151: LD_VAR 0 4
12155: STR
12156: PUSH
12157: LD_STRING ")
12159: STR
12160: PPUSH
12161: CALL_OW 559
// end else
12165: GO 12174
// ToLua ( getStreamItemsFromMission("","") ) ;
12167: LD_STRING getStreamItemsFromMission("","")
12169: PPUSH
12170: CALL_OW 559
// end ;
12174: LD_VAR 0 1
12178: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
12179: LD_VAR 0 2
12183: PUSH
12184: LD_INT 100
12186: EQUAL
12187: IFFALSE 13136
// begin if not StreamModeActive then
12189: LD_EXP 29
12193: NOT
12194: IFFALSE 12204
// StreamModeActive := true ;
12196: LD_ADDR_EXP 29
12200: PUSH
12201: LD_INT 1
12203: ST_TO_ADDR
// if p3 = 0 then
12204: LD_VAR 0 3
12208: PUSH
12209: LD_INT 0
12211: EQUAL
12212: IFFALSE 12218
// InitStreamMode ;
12214: CALL 8464 0 0
// if p3 = 1 then
12218: LD_VAR 0 3
12222: PUSH
12223: LD_INT 1
12225: EQUAL
12226: IFFALSE 12236
// sRocket := true ;
12228: LD_ADDR_EXP 34
12232: PUSH
12233: LD_INT 1
12235: ST_TO_ADDR
// if p3 = 2 then
12236: LD_VAR 0 3
12240: PUSH
12241: LD_INT 2
12243: EQUAL
12244: IFFALSE 12254
// sSpeed := true ;
12246: LD_ADDR_EXP 33
12250: PUSH
12251: LD_INT 1
12253: ST_TO_ADDR
// if p3 = 3 then
12254: LD_VAR 0 3
12258: PUSH
12259: LD_INT 3
12261: EQUAL
12262: IFFALSE 12272
// sEngine := true ;
12264: LD_ADDR_EXP 35
12268: PUSH
12269: LD_INT 1
12271: ST_TO_ADDR
// if p3 = 4 then
12272: LD_VAR 0 3
12276: PUSH
12277: LD_INT 4
12279: EQUAL
12280: IFFALSE 12290
// sSpec := true ;
12282: LD_ADDR_EXP 32
12286: PUSH
12287: LD_INT 1
12289: ST_TO_ADDR
// if p3 = 5 then
12290: LD_VAR 0 3
12294: PUSH
12295: LD_INT 5
12297: EQUAL
12298: IFFALSE 12308
// sLevel := true ;
12300: LD_ADDR_EXP 36
12304: PUSH
12305: LD_INT 1
12307: ST_TO_ADDR
// if p3 = 6 then
12308: LD_VAR 0 3
12312: PUSH
12313: LD_INT 6
12315: EQUAL
12316: IFFALSE 12326
// sArmoury := true ;
12318: LD_ADDR_EXP 37
12322: PUSH
12323: LD_INT 1
12325: ST_TO_ADDR
// if p3 = 7 then
12326: LD_VAR 0 3
12330: PUSH
12331: LD_INT 7
12333: EQUAL
12334: IFFALSE 12344
// sRadar := true ;
12336: LD_ADDR_EXP 38
12340: PUSH
12341: LD_INT 1
12343: ST_TO_ADDR
// if p3 = 8 then
12344: LD_VAR 0 3
12348: PUSH
12349: LD_INT 8
12351: EQUAL
12352: IFFALSE 12362
// sBunker := true ;
12354: LD_ADDR_EXP 39
12358: PUSH
12359: LD_INT 1
12361: ST_TO_ADDR
// if p3 = 9 then
12362: LD_VAR 0 3
12366: PUSH
12367: LD_INT 9
12369: EQUAL
12370: IFFALSE 12380
// sHack := true ;
12372: LD_ADDR_EXP 40
12376: PUSH
12377: LD_INT 1
12379: ST_TO_ADDR
// if p3 = 10 then
12380: LD_VAR 0 3
12384: PUSH
12385: LD_INT 10
12387: EQUAL
12388: IFFALSE 12398
// sFire := true ;
12390: LD_ADDR_EXP 41
12394: PUSH
12395: LD_INT 1
12397: ST_TO_ADDR
// if p3 = 11 then
12398: LD_VAR 0 3
12402: PUSH
12403: LD_INT 11
12405: EQUAL
12406: IFFALSE 12416
// sRefresh := true ;
12408: LD_ADDR_EXP 42
12412: PUSH
12413: LD_INT 1
12415: ST_TO_ADDR
// if p3 = 12 then
12416: LD_VAR 0 3
12420: PUSH
12421: LD_INT 12
12423: EQUAL
12424: IFFALSE 12434
// sExp := true ;
12426: LD_ADDR_EXP 43
12430: PUSH
12431: LD_INT 1
12433: ST_TO_ADDR
// if p3 = 13 then
12434: LD_VAR 0 3
12438: PUSH
12439: LD_INT 13
12441: EQUAL
12442: IFFALSE 12452
// sDepot := true ;
12444: LD_ADDR_EXP 44
12448: PUSH
12449: LD_INT 1
12451: ST_TO_ADDR
// if p3 = 14 then
12452: LD_VAR 0 3
12456: PUSH
12457: LD_INT 14
12459: EQUAL
12460: IFFALSE 12470
// sFlag := true ;
12462: LD_ADDR_EXP 45
12466: PUSH
12467: LD_INT 1
12469: ST_TO_ADDR
// if p3 = 15 then
12470: LD_VAR 0 3
12474: PUSH
12475: LD_INT 15
12477: EQUAL
12478: IFFALSE 12488
// sKamikadze := true ;
12480: LD_ADDR_EXP 53
12484: PUSH
12485: LD_INT 1
12487: ST_TO_ADDR
// if p3 = 16 then
12488: LD_VAR 0 3
12492: PUSH
12493: LD_INT 16
12495: EQUAL
12496: IFFALSE 12506
// sTroll := true ;
12498: LD_ADDR_EXP 54
12502: PUSH
12503: LD_INT 1
12505: ST_TO_ADDR
// if p3 = 17 then
12506: LD_VAR 0 3
12510: PUSH
12511: LD_INT 17
12513: EQUAL
12514: IFFALSE 12524
// sSlow := true ;
12516: LD_ADDR_EXP 55
12520: PUSH
12521: LD_INT 1
12523: ST_TO_ADDR
// if p3 = 18 then
12524: LD_VAR 0 3
12528: PUSH
12529: LD_INT 18
12531: EQUAL
12532: IFFALSE 12542
// sLack := true ;
12534: LD_ADDR_EXP 56
12538: PUSH
12539: LD_INT 1
12541: ST_TO_ADDR
// if p3 = 19 then
12542: LD_VAR 0 3
12546: PUSH
12547: LD_INT 19
12549: EQUAL
12550: IFFALSE 12560
// sTank := true ;
12552: LD_ADDR_EXP 58
12556: PUSH
12557: LD_INT 1
12559: ST_TO_ADDR
// if p3 = 20 then
12560: LD_VAR 0 3
12564: PUSH
12565: LD_INT 20
12567: EQUAL
12568: IFFALSE 12578
// sRemote := true ;
12570: LD_ADDR_EXP 59
12574: PUSH
12575: LD_INT 1
12577: ST_TO_ADDR
// if p3 = 21 then
12578: LD_VAR 0 3
12582: PUSH
12583: LD_INT 21
12585: EQUAL
12586: IFFALSE 12596
// sPowell := true ;
12588: LD_ADDR_EXP 60
12592: PUSH
12593: LD_INT 1
12595: ST_TO_ADDR
// if p3 = 22 then
12596: LD_VAR 0 3
12600: PUSH
12601: LD_INT 22
12603: EQUAL
12604: IFFALSE 12614
// sTeleport := true ;
12606: LD_ADDR_EXP 63
12610: PUSH
12611: LD_INT 1
12613: ST_TO_ADDR
// if p3 = 23 then
12614: LD_VAR 0 3
12618: PUSH
12619: LD_INT 23
12621: EQUAL
12622: IFFALSE 12632
// sOilTower := true ;
12624: LD_ADDR_EXP 65
12628: PUSH
12629: LD_INT 1
12631: ST_TO_ADDR
// if p3 = 24 then
12632: LD_VAR 0 3
12636: PUSH
12637: LD_INT 24
12639: EQUAL
12640: IFFALSE 12650
// sShovel := true ;
12642: LD_ADDR_EXP 66
12646: PUSH
12647: LD_INT 1
12649: ST_TO_ADDR
// if p3 = 25 then
12650: LD_VAR 0 3
12654: PUSH
12655: LD_INT 25
12657: EQUAL
12658: IFFALSE 12668
// sSheik := true ;
12660: LD_ADDR_EXP 67
12664: PUSH
12665: LD_INT 1
12667: ST_TO_ADDR
// if p3 = 26 then
12668: LD_VAR 0 3
12672: PUSH
12673: LD_INT 26
12675: EQUAL
12676: IFFALSE 12686
// sEarthquake := true ;
12678: LD_ADDR_EXP 69
12682: PUSH
12683: LD_INT 1
12685: ST_TO_ADDR
// if p3 = 27 then
12686: LD_VAR 0 3
12690: PUSH
12691: LD_INT 27
12693: EQUAL
12694: IFFALSE 12704
// sAI := true ;
12696: LD_ADDR_EXP 70
12700: PUSH
12701: LD_INT 1
12703: ST_TO_ADDR
// if p3 = 28 then
12704: LD_VAR 0 3
12708: PUSH
12709: LD_INT 28
12711: EQUAL
12712: IFFALSE 12722
// sCargo := true ;
12714: LD_ADDR_EXP 73
12718: PUSH
12719: LD_INT 1
12721: ST_TO_ADDR
// if p3 = 29 then
12722: LD_VAR 0 3
12726: PUSH
12727: LD_INT 29
12729: EQUAL
12730: IFFALSE 12740
// sDLaser := true ;
12732: LD_ADDR_EXP 74
12736: PUSH
12737: LD_INT 1
12739: ST_TO_ADDR
// if p3 = 30 then
12740: LD_VAR 0 3
12744: PUSH
12745: LD_INT 30
12747: EQUAL
12748: IFFALSE 12758
// sExchange := true ;
12750: LD_ADDR_EXP 75
12754: PUSH
12755: LD_INT 1
12757: ST_TO_ADDR
// if p3 = 31 then
12758: LD_VAR 0 3
12762: PUSH
12763: LD_INT 31
12765: EQUAL
12766: IFFALSE 12776
// sFac := true ;
12768: LD_ADDR_EXP 76
12772: PUSH
12773: LD_INT 1
12775: ST_TO_ADDR
// if p3 = 32 then
12776: LD_VAR 0 3
12780: PUSH
12781: LD_INT 32
12783: EQUAL
12784: IFFALSE 12794
// sPower := true ;
12786: LD_ADDR_EXP 77
12790: PUSH
12791: LD_INT 1
12793: ST_TO_ADDR
// if p3 = 33 then
12794: LD_VAR 0 3
12798: PUSH
12799: LD_INT 33
12801: EQUAL
12802: IFFALSE 12812
// sRandom := true ;
12804: LD_ADDR_EXP 78
12808: PUSH
12809: LD_INT 1
12811: ST_TO_ADDR
// if p3 = 34 then
12812: LD_VAR 0 3
12816: PUSH
12817: LD_INT 34
12819: EQUAL
12820: IFFALSE 12830
// sShield := true ;
12822: LD_ADDR_EXP 79
12826: PUSH
12827: LD_INT 1
12829: ST_TO_ADDR
// if p3 = 35 then
12830: LD_VAR 0 3
12834: PUSH
12835: LD_INT 35
12837: EQUAL
12838: IFFALSE 12848
// sTime := true ;
12840: LD_ADDR_EXP 80
12844: PUSH
12845: LD_INT 1
12847: ST_TO_ADDR
// if p3 = 36 then
12848: LD_VAR 0 3
12852: PUSH
12853: LD_INT 36
12855: EQUAL
12856: IFFALSE 12866
// sTools := true ;
12858: LD_ADDR_EXP 81
12862: PUSH
12863: LD_INT 1
12865: ST_TO_ADDR
// if p3 = 101 then
12866: LD_VAR 0 3
12870: PUSH
12871: LD_INT 101
12873: EQUAL
12874: IFFALSE 12884
// sSold := true ;
12876: LD_ADDR_EXP 46
12880: PUSH
12881: LD_INT 1
12883: ST_TO_ADDR
// if p3 = 102 then
12884: LD_VAR 0 3
12888: PUSH
12889: LD_INT 102
12891: EQUAL
12892: IFFALSE 12902
// sDiff := true ;
12894: LD_ADDR_EXP 47
12898: PUSH
12899: LD_INT 1
12901: ST_TO_ADDR
// if p3 = 103 then
12902: LD_VAR 0 3
12906: PUSH
12907: LD_INT 103
12909: EQUAL
12910: IFFALSE 12920
// sFog := true ;
12912: LD_ADDR_EXP 50
12916: PUSH
12917: LD_INT 1
12919: ST_TO_ADDR
// if p3 = 104 then
12920: LD_VAR 0 3
12924: PUSH
12925: LD_INT 104
12927: EQUAL
12928: IFFALSE 12938
// sReset := true ;
12930: LD_ADDR_EXP 51
12934: PUSH
12935: LD_INT 1
12937: ST_TO_ADDR
// if p3 = 105 then
12938: LD_VAR 0 3
12942: PUSH
12943: LD_INT 105
12945: EQUAL
12946: IFFALSE 12956
// sSun := true ;
12948: LD_ADDR_EXP 52
12952: PUSH
12953: LD_INT 1
12955: ST_TO_ADDR
// if p3 = 106 then
12956: LD_VAR 0 3
12960: PUSH
12961: LD_INT 106
12963: EQUAL
12964: IFFALSE 12974
// sTiger := true ;
12966: LD_ADDR_EXP 48
12970: PUSH
12971: LD_INT 1
12973: ST_TO_ADDR
// if p3 = 107 then
12974: LD_VAR 0 3
12978: PUSH
12979: LD_INT 107
12981: EQUAL
12982: IFFALSE 12992
// sBomb := true ;
12984: LD_ADDR_EXP 49
12988: PUSH
12989: LD_INT 1
12991: ST_TO_ADDR
// if p3 = 108 then
12992: LD_VAR 0 3
12996: PUSH
12997: LD_INT 108
12999: EQUAL
13000: IFFALSE 13010
// sWound := true ;
13002: LD_ADDR_EXP 57
13006: PUSH
13007: LD_INT 1
13009: ST_TO_ADDR
// if p3 = 109 then
13010: LD_VAR 0 3
13014: PUSH
13015: LD_INT 109
13017: EQUAL
13018: IFFALSE 13028
// sBetray := true ;
13020: LD_ADDR_EXP 61
13024: PUSH
13025: LD_INT 1
13027: ST_TO_ADDR
// if p3 = 110 then
13028: LD_VAR 0 3
13032: PUSH
13033: LD_INT 110
13035: EQUAL
13036: IFFALSE 13046
// sContamin := true ;
13038: LD_ADDR_EXP 62
13042: PUSH
13043: LD_INT 1
13045: ST_TO_ADDR
// if p3 = 111 then
13046: LD_VAR 0 3
13050: PUSH
13051: LD_INT 111
13053: EQUAL
13054: IFFALSE 13064
// sOil := true ;
13056: LD_ADDR_EXP 64
13060: PUSH
13061: LD_INT 1
13063: ST_TO_ADDR
// if p3 = 112 then
13064: LD_VAR 0 3
13068: PUSH
13069: LD_INT 112
13071: EQUAL
13072: IFFALSE 13082
// sStu := true ;
13074: LD_ADDR_EXP 68
13078: PUSH
13079: LD_INT 1
13081: ST_TO_ADDR
// if p3 = 113 then
13082: LD_VAR 0 3
13086: PUSH
13087: LD_INT 113
13089: EQUAL
13090: IFFALSE 13100
// sBazooka := true ;
13092: LD_ADDR_EXP 71
13096: PUSH
13097: LD_INT 1
13099: ST_TO_ADDR
// if p3 = 114 then
13100: LD_VAR 0 3
13104: PUSH
13105: LD_INT 114
13107: EQUAL
13108: IFFALSE 13118
// sMortar := true ;
13110: LD_ADDR_EXP 72
13114: PUSH
13115: LD_INT 1
13117: ST_TO_ADDR
// if p3 = 115 then
13118: LD_VAR 0 3
13122: PUSH
13123: LD_INT 115
13125: EQUAL
13126: IFFALSE 13136
// sRanger := true ;
13128: LD_ADDR_EXP 82
13132: PUSH
13133: LD_INT 1
13135: ST_TO_ADDR
// end ; end ;
13136: PPOPN 6
13138: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
13139: LD_EXP 29
13143: PUSH
13144: LD_EXP 34
13148: AND
13149: IFFALSE 13273
13151: GO 13153
13153: DISABLE
13154: LD_INT 0
13156: PPUSH
13157: PPUSH
// begin enable ;
13158: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
13159: LD_ADDR_VAR 0 2
13163: PUSH
13164: LD_INT 22
13166: PUSH
13167: LD_OWVAR 2
13171: PUSH
13172: EMPTY
13173: LIST
13174: LIST
13175: PUSH
13176: LD_INT 2
13178: PUSH
13179: LD_INT 34
13181: PUSH
13182: LD_INT 7
13184: PUSH
13185: EMPTY
13186: LIST
13187: LIST
13188: PUSH
13189: LD_INT 34
13191: PUSH
13192: LD_INT 45
13194: PUSH
13195: EMPTY
13196: LIST
13197: LIST
13198: PUSH
13199: LD_INT 34
13201: PUSH
13202: LD_INT 28
13204: PUSH
13205: EMPTY
13206: LIST
13207: LIST
13208: PUSH
13209: LD_INT 34
13211: PUSH
13212: LD_INT 47
13214: PUSH
13215: EMPTY
13216: LIST
13217: LIST
13218: PUSH
13219: EMPTY
13220: LIST
13221: LIST
13222: LIST
13223: LIST
13224: LIST
13225: PUSH
13226: EMPTY
13227: LIST
13228: LIST
13229: PPUSH
13230: CALL_OW 69
13234: ST_TO_ADDR
// if not tmp then
13235: LD_VAR 0 2
13239: NOT
13240: IFFALSE 13244
// exit ;
13242: GO 13273
// for i in tmp do
13244: LD_ADDR_VAR 0 1
13248: PUSH
13249: LD_VAR 0 2
13253: PUSH
13254: FOR_IN
13255: IFFALSE 13271
// begin SetLives ( i , 0 ) ;
13257: LD_VAR 0 1
13261: PPUSH
13262: LD_INT 0
13264: PPUSH
13265: CALL_OW 234
// end ;
13269: GO 13254
13271: POP
13272: POP
// end ;
13273: PPOPN 2
13275: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
13276: LD_EXP 29
13280: PUSH
13281: LD_EXP 35
13285: AND
13286: IFFALSE 13370
13288: GO 13290
13290: DISABLE
13291: LD_INT 0
13293: PPUSH
13294: PPUSH
// begin enable ;
13295: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
13296: LD_ADDR_VAR 0 2
13300: PUSH
13301: LD_INT 22
13303: PUSH
13304: LD_OWVAR 2
13308: PUSH
13309: EMPTY
13310: LIST
13311: LIST
13312: PUSH
13313: LD_INT 32
13315: PUSH
13316: LD_INT 3
13318: PUSH
13319: EMPTY
13320: LIST
13321: LIST
13322: PUSH
13323: EMPTY
13324: LIST
13325: LIST
13326: PPUSH
13327: CALL_OW 69
13331: ST_TO_ADDR
// if not tmp then
13332: LD_VAR 0 2
13336: NOT
13337: IFFALSE 13341
// exit ;
13339: GO 13370
// for i in tmp do
13341: LD_ADDR_VAR 0 1
13345: PUSH
13346: LD_VAR 0 2
13350: PUSH
13351: FOR_IN
13352: IFFALSE 13368
// begin SetLives ( i , 0 ) ;
13354: LD_VAR 0 1
13358: PPUSH
13359: LD_INT 0
13361: PPUSH
13362: CALL_OW 234
// end ;
13366: GO 13351
13368: POP
13369: POP
// end ;
13370: PPOPN 2
13372: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
13373: LD_EXP 29
13377: PUSH
13378: LD_EXP 32
13382: AND
13383: IFFALSE 13476
13385: GO 13387
13387: DISABLE
13388: LD_INT 0
13390: PPUSH
// begin enable ;
13391: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
13392: LD_ADDR_VAR 0 1
13396: PUSH
13397: LD_INT 22
13399: PUSH
13400: LD_OWVAR 2
13404: PUSH
13405: EMPTY
13406: LIST
13407: LIST
13408: PUSH
13409: LD_INT 2
13411: PUSH
13412: LD_INT 25
13414: PUSH
13415: LD_INT 5
13417: PUSH
13418: EMPTY
13419: LIST
13420: LIST
13421: PUSH
13422: LD_INT 25
13424: PUSH
13425: LD_INT 9
13427: PUSH
13428: EMPTY
13429: LIST
13430: LIST
13431: PUSH
13432: LD_INT 25
13434: PUSH
13435: LD_INT 8
13437: PUSH
13438: EMPTY
13439: LIST
13440: LIST
13441: PUSH
13442: EMPTY
13443: LIST
13444: LIST
13445: LIST
13446: LIST
13447: PUSH
13448: EMPTY
13449: LIST
13450: LIST
13451: PPUSH
13452: CALL_OW 69
13456: PUSH
13457: FOR_IN
13458: IFFALSE 13474
// begin SetClass ( i , 1 ) ;
13460: LD_VAR 0 1
13464: PPUSH
13465: LD_INT 1
13467: PPUSH
13468: CALL_OW 336
// end ;
13472: GO 13457
13474: POP
13475: POP
// end ;
13476: PPOPN 1
13478: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
13479: LD_EXP 29
13483: PUSH
13484: LD_EXP 33
13488: AND
13489: PUSH
13490: LD_OWVAR 65
13494: PUSH
13495: LD_INT 7
13497: LESS
13498: AND
13499: IFFALSE 13513
13501: GO 13503
13503: DISABLE
// begin enable ;
13504: ENABLE
// game_speed := 7 ;
13505: LD_ADDR_OWVAR 65
13509: PUSH
13510: LD_INT 7
13512: ST_TO_ADDR
// end ;
13513: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
13514: LD_EXP 29
13518: PUSH
13519: LD_EXP 36
13523: AND
13524: IFFALSE 13726
13526: GO 13528
13528: DISABLE
13529: LD_INT 0
13531: PPUSH
13532: PPUSH
13533: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
13534: LD_ADDR_VAR 0 3
13538: PUSH
13539: LD_INT 81
13541: PUSH
13542: LD_OWVAR 2
13546: PUSH
13547: EMPTY
13548: LIST
13549: LIST
13550: PUSH
13551: LD_INT 21
13553: PUSH
13554: LD_INT 1
13556: PUSH
13557: EMPTY
13558: LIST
13559: LIST
13560: PUSH
13561: EMPTY
13562: LIST
13563: LIST
13564: PPUSH
13565: CALL_OW 69
13569: ST_TO_ADDR
// if not tmp then
13570: LD_VAR 0 3
13574: NOT
13575: IFFALSE 13579
// exit ;
13577: GO 13726
// if tmp > 5 then
13579: LD_VAR 0 3
13583: PUSH
13584: LD_INT 5
13586: GREATER
13587: IFFALSE 13599
// k := 5 else
13589: LD_ADDR_VAR 0 2
13593: PUSH
13594: LD_INT 5
13596: ST_TO_ADDR
13597: GO 13609
// k := tmp ;
13599: LD_ADDR_VAR 0 2
13603: PUSH
13604: LD_VAR 0 3
13608: ST_TO_ADDR
// for i := 1 to k do
13609: LD_ADDR_VAR 0 1
13613: PUSH
13614: DOUBLE
13615: LD_INT 1
13617: DEC
13618: ST_TO_ADDR
13619: LD_VAR 0 2
13623: PUSH
13624: FOR_TO
13625: IFFALSE 13724
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
13627: LD_VAR 0 3
13631: PUSH
13632: LD_VAR 0 1
13636: ARRAY
13637: PPUSH
13638: LD_VAR 0 1
13642: PUSH
13643: LD_INT 4
13645: MOD
13646: PUSH
13647: LD_INT 1
13649: PLUS
13650: PPUSH
13651: CALL_OW 259
13655: PUSH
13656: LD_INT 10
13658: LESS
13659: IFFALSE 13722
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
13661: LD_VAR 0 3
13665: PUSH
13666: LD_VAR 0 1
13670: ARRAY
13671: PPUSH
13672: LD_VAR 0 1
13676: PUSH
13677: LD_INT 4
13679: MOD
13680: PUSH
13681: LD_INT 1
13683: PLUS
13684: PPUSH
13685: LD_VAR 0 3
13689: PUSH
13690: LD_VAR 0 1
13694: ARRAY
13695: PPUSH
13696: LD_VAR 0 1
13700: PUSH
13701: LD_INT 4
13703: MOD
13704: PUSH
13705: LD_INT 1
13707: PLUS
13708: PPUSH
13709: CALL_OW 259
13713: PUSH
13714: LD_INT 1
13716: PLUS
13717: PPUSH
13718: CALL_OW 237
13722: GO 13624
13724: POP
13725: POP
// end ;
13726: PPOPN 3
13728: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
13729: LD_EXP 29
13733: PUSH
13734: LD_EXP 37
13738: AND
13739: IFFALSE 13759
13741: GO 13743
13743: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
13744: LD_INT 4
13746: PPUSH
13747: LD_OWVAR 2
13751: PPUSH
13752: LD_INT 0
13754: PPUSH
13755: CALL_OW 324
13759: END
// every 0 0$1 trigger StreamModeActive and sShovel do
13760: LD_EXP 29
13764: PUSH
13765: LD_EXP 66
13769: AND
13770: IFFALSE 13790
13772: GO 13774
13774: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
13775: LD_INT 19
13777: PPUSH
13778: LD_OWVAR 2
13782: PPUSH
13783: LD_INT 0
13785: PPUSH
13786: CALL_OW 324
13790: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
13791: LD_EXP 29
13795: PUSH
13796: LD_EXP 38
13800: AND
13801: IFFALSE 13903
13803: GO 13805
13805: DISABLE
13806: LD_INT 0
13808: PPUSH
13809: PPUSH
// begin enable ;
13810: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
13811: LD_ADDR_VAR 0 2
13815: PUSH
13816: LD_INT 22
13818: PUSH
13819: LD_OWVAR 2
13823: PUSH
13824: EMPTY
13825: LIST
13826: LIST
13827: PUSH
13828: LD_INT 2
13830: PUSH
13831: LD_INT 34
13833: PUSH
13834: LD_INT 11
13836: PUSH
13837: EMPTY
13838: LIST
13839: LIST
13840: PUSH
13841: LD_INT 34
13843: PUSH
13844: LD_INT 30
13846: PUSH
13847: EMPTY
13848: LIST
13849: LIST
13850: PUSH
13851: EMPTY
13852: LIST
13853: LIST
13854: LIST
13855: PUSH
13856: EMPTY
13857: LIST
13858: LIST
13859: PPUSH
13860: CALL_OW 69
13864: ST_TO_ADDR
// if not tmp then
13865: LD_VAR 0 2
13869: NOT
13870: IFFALSE 13874
// exit ;
13872: GO 13903
// for i in tmp do
13874: LD_ADDR_VAR 0 1
13878: PUSH
13879: LD_VAR 0 2
13883: PUSH
13884: FOR_IN
13885: IFFALSE 13901
// begin SetLives ( i , 0 ) ;
13887: LD_VAR 0 1
13891: PPUSH
13892: LD_INT 0
13894: PPUSH
13895: CALL_OW 234
// end ;
13899: GO 13884
13901: POP
13902: POP
// end ;
13903: PPOPN 2
13905: END
// every 0 0$1 trigger StreamModeActive and sBunker do
13906: LD_EXP 29
13910: PUSH
13911: LD_EXP 39
13915: AND
13916: IFFALSE 13936
13918: GO 13920
13920: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
13921: LD_INT 32
13923: PPUSH
13924: LD_OWVAR 2
13928: PPUSH
13929: LD_INT 0
13931: PPUSH
13932: CALL_OW 324
13936: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
13937: LD_EXP 29
13941: PUSH
13942: LD_EXP 40
13946: AND
13947: IFFALSE 14128
13949: GO 13951
13951: DISABLE
13952: LD_INT 0
13954: PPUSH
13955: PPUSH
13956: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
13957: LD_ADDR_VAR 0 2
13961: PUSH
13962: LD_INT 22
13964: PUSH
13965: LD_OWVAR 2
13969: PUSH
13970: EMPTY
13971: LIST
13972: LIST
13973: PUSH
13974: LD_INT 33
13976: PUSH
13977: LD_INT 3
13979: PUSH
13980: EMPTY
13981: LIST
13982: LIST
13983: PUSH
13984: EMPTY
13985: LIST
13986: LIST
13987: PPUSH
13988: CALL_OW 69
13992: ST_TO_ADDR
// if not tmp then
13993: LD_VAR 0 2
13997: NOT
13998: IFFALSE 14002
// exit ;
14000: GO 14128
// side := 0 ;
14002: LD_ADDR_VAR 0 3
14006: PUSH
14007: LD_INT 0
14009: ST_TO_ADDR
// for i := 1 to 8 do
14010: LD_ADDR_VAR 0 1
14014: PUSH
14015: DOUBLE
14016: LD_INT 1
14018: DEC
14019: ST_TO_ADDR
14020: LD_INT 8
14022: PUSH
14023: FOR_TO
14024: IFFALSE 14072
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
14026: LD_OWVAR 2
14030: PUSH
14031: LD_VAR 0 1
14035: NONEQUAL
14036: PUSH
14037: LD_OWVAR 2
14041: PPUSH
14042: LD_VAR 0 1
14046: PPUSH
14047: CALL_OW 81
14051: PUSH
14052: LD_INT 2
14054: EQUAL
14055: AND
14056: IFFALSE 14070
// begin side := i ;
14058: LD_ADDR_VAR 0 3
14062: PUSH
14063: LD_VAR 0 1
14067: ST_TO_ADDR
// break ;
14068: GO 14072
// end ;
14070: GO 14023
14072: POP
14073: POP
// if not side then
14074: LD_VAR 0 3
14078: NOT
14079: IFFALSE 14083
// exit ;
14081: GO 14128
// for i := 1 to tmp do
14083: LD_ADDR_VAR 0 1
14087: PUSH
14088: DOUBLE
14089: LD_INT 1
14091: DEC
14092: ST_TO_ADDR
14093: LD_VAR 0 2
14097: PUSH
14098: FOR_TO
14099: IFFALSE 14126
// if Prob ( 30 ) then
14101: LD_INT 30
14103: PPUSH
14104: CALL_OW 13
14108: IFFALSE 14124
// SetSide ( i , side ) ;
14110: LD_VAR 0 1
14114: PPUSH
14115: LD_VAR 0 3
14119: PPUSH
14120: CALL_OW 235
14124: GO 14098
14126: POP
14127: POP
// end ;
14128: PPOPN 3
14130: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
14131: LD_EXP 29
14135: PUSH
14136: LD_EXP 42
14140: AND
14141: IFFALSE 14260
14143: GO 14145
14145: DISABLE
14146: LD_INT 0
14148: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
14149: LD_ADDR_VAR 0 1
14153: PUSH
14154: LD_INT 22
14156: PUSH
14157: LD_OWVAR 2
14161: PUSH
14162: EMPTY
14163: LIST
14164: LIST
14165: PUSH
14166: LD_INT 21
14168: PUSH
14169: LD_INT 1
14171: PUSH
14172: EMPTY
14173: LIST
14174: LIST
14175: PUSH
14176: LD_INT 3
14178: PUSH
14179: LD_INT 23
14181: PUSH
14182: LD_INT 0
14184: PUSH
14185: EMPTY
14186: LIST
14187: LIST
14188: PUSH
14189: EMPTY
14190: LIST
14191: LIST
14192: PUSH
14193: EMPTY
14194: LIST
14195: LIST
14196: LIST
14197: PPUSH
14198: CALL_OW 69
14202: PUSH
14203: FOR_IN
14204: IFFALSE 14258
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
14206: LD_VAR 0 1
14210: PPUSH
14211: CALL_OW 257
14215: PUSH
14216: LD_INT 1
14218: PUSH
14219: LD_INT 2
14221: PUSH
14222: LD_INT 3
14224: PUSH
14225: LD_INT 4
14227: PUSH
14228: EMPTY
14229: LIST
14230: LIST
14231: LIST
14232: LIST
14233: IN
14234: IFFALSE 14256
// SetClass ( un , rand ( 1 , 4 ) ) ;
14236: LD_VAR 0 1
14240: PPUSH
14241: LD_INT 1
14243: PPUSH
14244: LD_INT 4
14246: PPUSH
14247: CALL_OW 12
14251: PPUSH
14252: CALL_OW 336
14256: GO 14203
14258: POP
14259: POP
// end ;
14260: PPOPN 1
14262: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
14263: LD_EXP 29
14267: PUSH
14268: LD_EXP 41
14272: AND
14273: IFFALSE 14352
14275: GO 14277
14277: DISABLE
14278: LD_INT 0
14280: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
14281: LD_ADDR_VAR 0 1
14285: PUSH
14286: LD_INT 22
14288: PUSH
14289: LD_OWVAR 2
14293: PUSH
14294: EMPTY
14295: LIST
14296: LIST
14297: PUSH
14298: LD_INT 21
14300: PUSH
14301: LD_INT 3
14303: PUSH
14304: EMPTY
14305: LIST
14306: LIST
14307: PUSH
14308: EMPTY
14309: LIST
14310: LIST
14311: PPUSH
14312: CALL_OW 69
14316: ST_TO_ADDR
// if not tmp then
14317: LD_VAR 0 1
14321: NOT
14322: IFFALSE 14326
// exit ;
14324: GO 14352
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
14326: LD_VAR 0 1
14330: PUSH
14331: LD_INT 1
14333: PPUSH
14334: LD_VAR 0 1
14338: PPUSH
14339: CALL_OW 12
14343: ARRAY
14344: PPUSH
14345: LD_INT 100
14347: PPUSH
14348: CALL_OW 234
// end ;
14352: PPOPN 1
14354: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
14355: LD_EXP 29
14359: PUSH
14360: LD_EXP 43
14364: AND
14365: IFFALSE 14463
14367: GO 14369
14369: DISABLE
14370: LD_INT 0
14372: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
14373: LD_ADDR_VAR 0 1
14377: PUSH
14378: LD_INT 22
14380: PUSH
14381: LD_OWVAR 2
14385: PUSH
14386: EMPTY
14387: LIST
14388: LIST
14389: PUSH
14390: LD_INT 21
14392: PUSH
14393: LD_INT 1
14395: PUSH
14396: EMPTY
14397: LIST
14398: LIST
14399: PUSH
14400: EMPTY
14401: LIST
14402: LIST
14403: PPUSH
14404: CALL_OW 69
14408: ST_TO_ADDR
// if not tmp then
14409: LD_VAR 0 1
14413: NOT
14414: IFFALSE 14418
// exit ;
14416: GO 14463
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
14418: LD_VAR 0 1
14422: PUSH
14423: LD_INT 1
14425: PPUSH
14426: LD_VAR 0 1
14430: PPUSH
14431: CALL_OW 12
14435: ARRAY
14436: PPUSH
14437: LD_INT 1
14439: PPUSH
14440: LD_INT 4
14442: PPUSH
14443: CALL_OW 12
14447: PPUSH
14448: LD_INT 3000
14450: PPUSH
14451: LD_INT 9000
14453: PPUSH
14454: CALL_OW 12
14458: PPUSH
14459: CALL_OW 492
// end ;
14463: PPOPN 1
14465: END
// every 0 0$1 trigger StreamModeActive and sDepot do
14466: LD_EXP 29
14470: PUSH
14471: LD_EXP 44
14475: AND
14476: IFFALSE 14496
14478: GO 14480
14480: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
14481: LD_INT 1
14483: PPUSH
14484: LD_OWVAR 2
14488: PPUSH
14489: LD_INT 0
14491: PPUSH
14492: CALL_OW 324
14496: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
14497: LD_EXP 29
14501: PUSH
14502: LD_EXP 45
14506: AND
14507: IFFALSE 14590
14509: GO 14511
14511: DISABLE
14512: LD_INT 0
14514: PPUSH
14515: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
14516: LD_ADDR_VAR 0 2
14520: PUSH
14521: LD_INT 22
14523: PUSH
14524: LD_OWVAR 2
14528: PUSH
14529: EMPTY
14530: LIST
14531: LIST
14532: PUSH
14533: LD_INT 21
14535: PUSH
14536: LD_INT 3
14538: PUSH
14539: EMPTY
14540: LIST
14541: LIST
14542: PUSH
14543: EMPTY
14544: LIST
14545: LIST
14546: PPUSH
14547: CALL_OW 69
14551: ST_TO_ADDR
// if not tmp then
14552: LD_VAR 0 2
14556: NOT
14557: IFFALSE 14561
// exit ;
14559: GO 14590
// for i in tmp do
14561: LD_ADDR_VAR 0 1
14565: PUSH
14566: LD_VAR 0 2
14570: PUSH
14571: FOR_IN
14572: IFFALSE 14588
// SetBLevel ( i , 10 ) ;
14574: LD_VAR 0 1
14578: PPUSH
14579: LD_INT 10
14581: PPUSH
14582: CALL_OW 241
14586: GO 14571
14588: POP
14589: POP
// end ;
14590: PPOPN 2
14592: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
14593: LD_EXP 29
14597: PUSH
14598: LD_EXP 46
14602: AND
14603: IFFALSE 14714
14605: GO 14607
14607: DISABLE
14608: LD_INT 0
14610: PPUSH
14611: PPUSH
14612: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
14613: LD_ADDR_VAR 0 3
14617: PUSH
14618: LD_INT 22
14620: PUSH
14621: LD_OWVAR 2
14625: PUSH
14626: EMPTY
14627: LIST
14628: LIST
14629: PUSH
14630: LD_INT 25
14632: PUSH
14633: LD_INT 1
14635: PUSH
14636: EMPTY
14637: LIST
14638: LIST
14639: PUSH
14640: EMPTY
14641: LIST
14642: LIST
14643: PPUSH
14644: CALL_OW 69
14648: ST_TO_ADDR
// if not tmp then
14649: LD_VAR 0 3
14653: NOT
14654: IFFALSE 14658
// exit ;
14656: GO 14714
// un := tmp [ rand ( 1 , tmp ) ] ;
14658: LD_ADDR_VAR 0 2
14662: PUSH
14663: LD_VAR 0 3
14667: PUSH
14668: LD_INT 1
14670: PPUSH
14671: LD_VAR 0 3
14675: PPUSH
14676: CALL_OW 12
14680: ARRAY
14681: ST_TO_ADDR
// if Crawls ( un ) then
14682: LD_VAR 0 2
14686: PPUSH
14687: CALL_OW 318
14691: IFFALSE 14702
// ComWalk ( un ) ;
14693: LD_VAR 0 2
14697: PPUSH
14698: CALL_OW 138
// SetClass ( un , class_sniper ) ;
14702: LD_VAR 0 2
14706: PPUSH
14707: LD_INT 5
14709: PPUSH
14710: CALL_OW 336
// end ;
14714: PPOPN 3
14716: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
14717: LD_EXP 29
14721: PUSH
14722: LD_EXP 47
14726: AND
14727: PUSH
14728: LD_OWVAR 67
14732: PUSH
14733: LD_INT 3
14735: LESS
14736: AND
14737: IFFALSE 14756
14739: GO 14741
14741: DISABLE
// Difficulty := Difficulty + 1 ;
14742: LD_ADDR_OWVAR 67
14746: PUSH
14747: LD_OWVAR 67
14751: PUSH
14752: LD_INT 1
14754: PLUS
14755: ST_TO_ADDR
14756: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
14757: LD_EXP 29
14761: PUSH
14762: LD_EXP 48
14766: AND
14767: IFFALSE 14870
14769: GO 14771
14771: DISABLE
14772: LD_INT 0
14774: PPUSH
// begin for i := 1 to 5 do
14775: LD_ADDR_VAR 0 1
14779: PUSH
14780: DOUBLE
14781: LD_INT 1
14783: DEC
14784: ST_TO_ADDR
14785: LD_INT 5
14787: PUSH
14788: FOR_TO
14789: IFFALSE 14868
// begin uc_nation := nation_nature ;
14791: LD_ADDR_OWVAR 21
14795: PUSH
14796: LD_INT 0
14798: ST_TO_ADDR
// uc_side := 0 ;
14799: LD_ADDR_OWVAR 20
14803: PUSH
14804: LD_INT 0
14806: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
14807: LD_ADDR_OWVAR 29
14811: PUSH
14812: LD_INT 12
14814: PUSH
14815: LD_INT 12
14817: PUSH
14818: EMPTY
14819: LIST
14820: LIST
14821: ST_TO_ADDR
// hc_agressivity := 20 ;
14822: LD_ADDR_OWVAR 35
14826: PUSH
14827: LD_INT 20
14829: ST_TO_ADDR
// hc_class := class_tiger ;
14830: LD_ADDR_OWVAR 28
14834: PUSH
14835: LD_INT 14
14837: ST_TO_ADDR
// hc_gallery :=  ;
14838: LD_ADDR_OWVAR 33
14842: PUSH
14843: LD_STRING 
14845: ST_TO_ADDR
// hc_name :=  ;
14846: LD_ADDR_OWVAR 26
14850: PUSH
14851: LD_STRING 
14853: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
14854: CALL_OW 44
14858: PPUSH
14859: LD_INT 0
14861: PPUSH
14862: CALL_OW 51
// end ;
14866: GO 14788
14868: POP
14869: POP
// end ;
14870: PPOPN 1
14872: END
// every 0 0$1 trigger StreamModeActive and sBomb do
14873: LD_EXP 29
14877: PUSH
14878: LD_EXP 49
14882: AND
14883: IFFALSE 14892
14885: GO 14887
14887: DISABLE
// StreamSibBomb ;
14888: CALL 14893 0 0
14892: END
// export function StreamSibBomb ; var i , x , y ; begin
14893: LD_INT 0
14895: PPUSH
14896: PPUSH
14897: PPUSH
14898: PPUSH
// result := false ;
14899: LD_ADDR_VAR 0 1
14903: PUSH
14904: LD_INT 0
14906: ST_TO_ADDR
// for i := 1 to 16 do
14907: LD_ADDR_VAR 0 2
14911: PUSH
14912: DOUBLE
14913: LD_INT 1
14915: DEC
14916: ST_TO_ADDR
14917: LD_INT 16
14919: PUSH
14920: FOR_TO
14921: IFFALSE 15120
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
14923: LD_ADDR_VAR 0 3
14927: PUSH
14928: LD_INT 10
14930: PUSH
14931: LD_INT 20
14933: PUSH
14934: LD_INT 30
14936: PUSH
14937: LD_INT 40
14939: PUSH
14940: LD_INT 50
14942: PUSH
14943: LD_INT 60
14945: PUSH
14946: LD_INT 70
14948: PUSH
14949: LD_INT 80
14951: PUSH
14952: LD_INT 90
14954: PUSH
14955: LD_INT 100
14957: PUSH
14958: LD_INT 110
14960: PUSH
14961: LD_INT 120
14963: PUSH
14964: LD_INT 130
14966: PUSH
14967: LD_INT 140
14969: PUSH
14970: LD_INT 150
14972: PUSH
14973: EMPTY
14974: LIST
14975: LIST
14976: LIST
14977: LIST
14978: LIST
14979: LIST
14980: LIST
14981: LIST
14982: LIST
14983: LIST
14984: LIST
14985: LIST
14986: LIST
14987: LIST
14988: LIST
14989: PUSH
14990: LD_INT 1
14992: PPUSH
14993: LD_INT 15
14995: PPUSH
14996: CALL_OW 12
15000: ARRAY
15001: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
15002: LD_ADDR_VAR 0 4
15006: PUSH
15007: LD_INT 10
15009: PUSH
15010: LD_INT 20
15012: PUSH
15013: LD_INT 30
15015: PUSH
15016: LD_INT 40
15018: PUSH
15019: LD_INT 50
15021: PUSH
15022: LD_INT 60
15024: PUSH
15025: LD_INT 70
15027: PUSH
15028: LD_INT 80
15030: PUSH
15031: LD_INT 90
15033: PUSH
15034: LD_INT 100
15036: PUSH
15037: LD_INT 110
15039: PUSH
15040: LD_INT 120
15042: PUSH
15043: LD_INT 130
15045: PUSH
15046: LD_INT 140
15048: PUSH
15049: LD_INT 150
15051: PUSH
15052: EMPTY
15053: LIST
15054: LIST
15055: LIST
15056: LIST
15057: LIST
15058: LIST
15059: LIST
15060: LIST
15061: LIST
15062: LIST
15063: LIST
15064: LIST
15065: LIST
15066: LIST
15067: LIST
15068: PUSH
15069: LD_INT 1
15071: PPUSH
15072: LD_INT 15
15074: PPUSH
15075: CALL_OW 12
15079: ARRAY
15080: ST_TO_ADDR
// if ValidHex ( x , y ) then
15081: LD_VAR 0 3
15085: PPUSH
15086: LD_VAR 0 4
15090: PPUSH
15091: CALL_OW 488
15095: IFFALSE 15118
// begin result := [ x , y ] ;
15097: LD_ADDR_VAR 0 1
15101: PUSH
15102: LD_VAR 0 3
15106: PUSH
15107: LD_VAR 0 4
15111: PUSH
15112: EMPTY
15113: LIST
15114: LIST
15115: ST_TO_ADDR
// break ;
15116: GO 15120
// end ; end ;
15118: GO 14920
15120: POP
15121: POP
// if result then
15122: LD_VAR 0 1
15126: IFFALSE 15186
// begin ToLua ( playSibBomb() ) ;
15128: LD_STRING playSibBomb()
15130: PPUSH
15131: CALL_OW 559
// wait ( 0 0$14 ) ;
15135: LD_INT 490
15137: PPUSH
15138: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
15142: LD_VAR 0 1
15146: PUSH
15147: LD_INT 1
15149: ARRAY
15150: PPUSH
15151: LD_VAR 0 1
15155: PUSH
15156: LD_INT 2
15158: ARRAY
15159: PPUSH
15160: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
15164: LD_VAR 0 1
15168: PUSH
15169: LD_INT 1
15171: ARRAY
15172: PPUSH
15173: LD_VAR 0 1
15177: PUSH
15178: LD_INT 2
15180: ARRAY
15181: PPUSH
15182: CALL_OW 429
// end ; end ;
15186: LD_VAR 0 1
15190: RET
// every 0 0$1 trigger StreamModeActive and sReset do
15191: LD_EXP 29
15195: PUSH
15196: LD_EXP 51
15200: AND
15201: IFFALSE 15213
15203: GO 15205
15205: DISABLE
// YouLost (  ) ;
15206: LD_STRING 
15208: PPUSH
15209: CALL_OW 104
15213: END
// every 0 0$1 trigger StreamModeActive and sFog do
15214: LD_EXP 29
15218: PUSH
15219: LD_EXP 50
15223: AND
15224: IFFALSE 15238
15226: GO 15228
15228: DISABLE
// FogOff ( your_side ) ;
15229: LD_OWVAR 2
15233: PPUSH
15234: CALL_OW 344
15238: END
// every 0 0$1 trigger StreamModeActive and sSun do
15239: LD_EXP 29
15243: PUSH
15244: LD_EXP 52
15248: AND
15249: IFFALSE 15277
15251: GO 15253
15253: DISABLE
// begin solar_recharge_percent := 0 ;
15254: LD_ADDR_OWVAR 79
15258: PUSH
15259: LD_INT 0
15261: ST_TO_ADDR
// wait ( 5 5$00 ) ;
15262: LD_INT 10500
15264: PPUSH
15265: CALL_OW 67
// solar_recharge_percent := 100 ;
15269: LD_ADDR_OWVAR 79
15273: PUSH
15274: LD_INT 100
15276: ST_TO_ADDR
// end ;
15277: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
15278: LD_EXP 29
15282: PUSH
15283: LD_EXP 53
15287: AND
15288: IFFALSE 15527
15290: GO 15292
15292: DISABLE
15293: LD_INT 0
15295: PPUSH
15296: PPUSH
15297: PPUSH
// begin tmp := [ ] ;
15298: LD_ADDR_VAR 0 3
15302: PUSH
15303: EMPTY
15304: ST_TO_ADDR
// for i := 1 to 6 do
15305: LD_ADDR_VAR 0 1
15309: PUSH
15310: DOUBLE
15311: LD_INT 1
15313: DEC
15314: ST_TO_ADDR
15315: LD_INT 6
15317: PUSH
15318: FOR_TO
15319: IFFALSE 15424
// begin uc_nation := nation_nature ;
15321: LD_ADDR_OWVAR 21
15325: PUSH
15326: LD_INT 0
15328: ST_TO_ADDR
// uc_side := 0 ;
15329: LD_ADDR_OWVAR 20
15333: PUSH
15334: LD_INT 0
15336: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
15337: LD_ADDR_OWVAR 29
15341: PUSH
15342: LD_INT 12
15344: PUSH
15345: LD_INT 12
15347: PUSH
15348: EMPTY
15349: LIST
15350: LIST
15351: ST_TO_ADDR
// hc_agressivity := 20 ;
15352: LD_ADDR_OWVAR 35
15356: PUSH
15357: LD_INT 20
15359: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
15360: LD_ADDR_OWVAR 28
15364: PUSH
15365: LD_INT 17
15367: ST_TO_ADDR
// hc_gallery :=  ;
15368: LD_ADDR_OWVAR 33
15372: PUSH
15373: LD_STRING 
15375: ST_TO_ADDR
// hc_name :=  ;
15376: LD_ADDR_OWVAR 26
15380: PUSH
15381: LD_STRING 
15383: ST_TO_ADDR
// un := CreateHuman ;
15384: LD_ADDR_VAR 0 2
15388: PUSH
15389: CALL_OW 44
15393: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
15394: LD_VAR 0 2
15398: PPUSH
15399: LD_INT 1
15401: PPUSH
15402: CALL_OW 51
// tmp := tmp ^ un ;
15406: LD_ADDR_VAR 0 3
15410: PUSH
15411: LD_VAR 0 3
15415: PUSH
15416: LD_VAR 0 2
15420: ADD
15421: ST_TO_ADDR
// end ;
15422: GO 15318
15424: POP
15425: POP
// repeat wait ( 0 0$1 ) ;
15426: LD_INT 35
15428: PPUSH
15429: CALL_OW 67
// for un in tmp do
15433: LD_ADDR_VAR 0 2
15437: PUSH
15438: LD_VAR 0 3
15442: PUSH
15443: FOR_IN
15444: IFFALSE 15518
// begin if IsDead ( un ) then
15446: LD_VAR 0 2
15450: PPUSH
15451: CALL_OW 301
15455: IFFALSE 15475
// begin tmp := tmp diff un ;
15457: LD_ADDR_VAR 0 3
15461: PUSH
15462: LD_VAR 0 3
15466: PUSH
15467: LD_VAR 0 2
15471: DIFF
15472: ST_TO_ADDR
// continue ;
15473: GO 15443
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
15475: LD_VAR 0 2
15479: PPUSH
15480: LD_INT 3
15482: PUSH
15483: LD_INT 22
15485: PUSH
15486: LD_INT 0
15488: PUSH
15489: EMPTY
15490: LIST
15491: LIST
15492: PUSH
15493: EMPTY
15494: LIST
15495: LIST
15496: PPUSH
15497: CALL_OW 69
15501: PPUSH
15502: LD_VAR 0 2
15506: PPUSH
15507: CALL_OW 74
15511: PPUSH
15512: CALL_OW 115
// end ;
15516: GO 15443
15518: POP
15519: POP
// until not tmp ;
15520: LD_VAR 0 3
15524: NOT
15525: IFFALSE 15426
// end ;
15527: PPOPN 3
15529: END
// every 0 0$1 trigger StreamModeActive and sTroll do
15530: LD_EXP 29
15534: PUSH
15535: LD_EXP 54
15539: AND
15540: IFFALSE 15594
15542: GO 15544
15544: DISABLE
// begin ToLua ( displayTroll(); ) ;
15545: LD_STRING displayTroll();
15547: PPUSH
15548: CALL_OW 559
// wait ( 3 3$00 ) ;
15552: LD_INT 6300
15554: PPUSH
15555: CALL_OW 67
// ToLua ( hideTroll(); ) ;
15559: LD_STRING hideTroll();
15561: PPUSH
15562: CALL_OW 559
// wait ( 1 1$00 ) ;
15566: LD_INT 2100
15568: PPUSH
15569: CALL_OW 67
// ToLua ( displayTroll(); ) ;
15573: LD_STRING displayTroll();
15575: PPUSH
15576: CALL_OW 559
// wait ( 1 1$00 ) ;
15580: LD_INT 2100
15582: PPUSH
15583: CALL_OW 67
// ToLua ( hideTroll(); ) ;
15587: LD_STRING hideTroll();
15589: PPUSH
15590: CALL_OW 559
// end ;
15594: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
15595: LD_EXP 29
15599: PUSH
15600: LD_EXP 55
15604: AND
15605: IFFALSE 15668
15607: GO 15609
15609: DISABLE
15610: LD_INT 0
15612: PPUSH
// begin p := 0 ;
15613: LD_ADDR_VAR 0 1
15617: PUSH
15618: LD_INT 0
15620: ST_TO_ADDR
// repeat game_speed := 1 ;
15621: LD_ADDR_OWVAR 65
15625: PUSH
15626: LD_INT 1
15628: ST_TO_ADDR
// wait ( 0 0$1 ) ;
15629: LD_INT 35
15631: PPUSH
15632: CALL_OW 67
// p := p + 1 ;
15636: LD_ADDR_VAR 0 1
15640: PUSH
15641: LD_VAR 0 1
15645: PUSH
15646: LD_INT 1
15648: PLUS
15649: ST_TO_ADDR
// until p >= 60 ;
15650: LD_VAR 0 1
15654: PUSH
15655: LD_INT 60
15657: GREATEREQUAL
15658: IFFALSE 15621
// game_speed := 4 ;
15660: LD_ADDR_OWVAR 65
15664: PUSH
15665: LD_INT 4
15667: ST_TO_ADDR
// end ;
15668: PPOPN 1
15670: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
15671: LD_EXP 29
15675: PUSH
15676: LD_EXP 56
15680: AND
15681: IFFALSE 15827
15683: GO 15685
15685: DISABLE
15686: LD_INT 0
15688: PPUSH
15689: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
15690: LD_ADDR_VAR 0 1
15694: PUSH
15695: LD_INT 22
15697: PUSH
15698: LD_OWVAR 2
15702: PUSH
15703: EMPTY
15704: LIST
15705: LIST
15706: PUSH
15707: LD_INT 2
15709: PUSH
15710: LD_INT 30
15712: PUSH
15713: LD_INT 0
15715: PUSH
15716: EMPTY
15717: LIST
15718: LIST
15719: PUSH
15720: LD_INT 30
15722: PUSH
15723: LD_INT 1
15725: PUSH
15726: EMPTY
15727: LIST
15728: LIST
15729: PUSH
15730: EMPTY
15731: LIST
15732: LIST
15733: LIST
15734: PUSH
15735: EMPTY
15736: LIST
15737: LIST
15738: PPUSH
15739: CALL_OW 69
15743: ST_TO_ADDR
// if not depot then
15744: LD_VAR 0 1
15748: NOT
15749: IFFALSE 15753
// exit ;
15751: GO 15827
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
15753: LD_ADDR_VAR 0 2
15757: PUSH
15758: LD_VAR 0 1
15762: PUSH
15763: LD_INT 1
15765: PPUSH
15766: LD_VAR 0 1
15770: PPUSH
15771: CALL_OW 12
15775: ARRAY
15776: PPUSH
15777: CALL_OW 274
15781: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
15782: LD_VAR 0 2
15786: PPUSH
15787: LD_INT 1
15789: PPUSH
15790: LD_INT 0
15792: PPUSH
15793: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
15797: LD_VAR 0 2
15801: PPUSH
15802: LD_INT 2
15804: PPUSH
15805: LD_INT 0
15807: PPUSH
15808: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
15812: LD_VAR 0 2
15816: PPUSH
15817: LD_INT 3
15819: PPUSH
15820: LD_INT 0
15822: PPUSH
15823: CALL_OW 277
// end ;
15827: PPOPN 2
15829: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
15830: LD_EXP 29
15834: PUSH
15835: LD_EXP 57
15839: AND
15840: IFFALSE 15937
15842: GO 15844
15844: DISABLE
15845: LD_INT 0
15847: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
15848: LD_ADDR_VAR 0 1
15852: PUSH
15853: LD_INT 22
15855: PUSH
15856: LD_OWVAR 2
15860: PUSH
15861: EMPTY
15862: LIST
15863: LIST
15864: PUSH
15865: LD_INT 21
15867: PUSH
15868: LD_INT 1
15870: PUSH
15871: EMPTY
15872: LIST
15873: LIST
15874: PUSH
15875: LD_INT 3
15877: PUSH
15878: LD_INT 23
15880: PUSH
15881: LD_INT 0
15883: PUSH
15884: EMPTY
15885: LIST
15886: LIST
15887: PUSH
15888: EMPTY
15889: LIST
15890: LIST
15891: PUSH
15892: EMPTY
15893: LIST
15894: LIST
15895: LIST
15896: PPUSH
15897: CALL_OW 69
15901: ST_TO_ADDR
// if not tmp then
15902: LD_VAR 0 1
15906: NOT
15907: IFFALSE 15911
// exit ;
15909: GO 15937
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
15911: LD_VAR 0 1
15915: PUSH
15916: LD_INT 1
15918: PPUSH
15919: LD_VAR 0 1
15923: PPUSH
15924: CALL_OW 12
15928: ARRAY
15929: PPUSH
15930: LD_INT 200
15932: PPUSH
15933: CALL_OW 234
// end ;
15937: PPOPN 1
15939: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
15940: LD_EXP 29
15944: PUSH
15945: LD_EXP 58
15949: AND
15950: IFFALSE 16029
15952: GO 15954
15954: DISABLE
15955: LD_INT 0
15957: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
15958: LD_ADDR_VAR 0 1
15962: PUSH
15963: LD_INT 22
15965: PUSH
15966: LD_OWVAR 2
15970: PUSH
15971: EMPTY
15972: LIST
15973: LIST
15974: PUSH
15975: LD_INT 21
15977: PUSH
15978: LD_INT 2
15980: PUSH
15981: EMPTY
15982: LIST
15983: LIST
15984: PUSH
15985: EMPTY
15986: LIST
15987: LIST
15988: PPUSH
15989: CALL_OW 69
15993: ST_TO_ADDR
// if not tmp then
15994: LD_VAR 0 1
15998: NOT
15999: IFFALSE 16003
// exit ;
16001: GO 16029
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
16003: LD_VAR 0 1
16007: PUSH
16008: LD_INT 1
16010: PPUSH
16011: LD_VAR 0 1
16015: PPUSH
16016: CALL_OW 12
16020: ARRAY
16021: PPUSH
16022: LD_INT 60
16024: PPUSH
16025: CALL_OW 234
// end ;
16029: PPOPN 1
16031: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
16032: LD_EXP 29
16036: PUSH
16037: LD_EXP 59
16041: AND
16042: IFFALSE 16141
16044: GO 16046
16046: DISABLE
16047: LD_INT 0
16049: PPUSH
16050: PPUSH
// begin enable ;
16051: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
16052: LD_ADDR_VAR 0 1
16056: PUSH
16057: LD_INT 22
16059: PUSH
16060: LD_OWVAR 2
16064: PUSH
16065: EMPTY
16066: LIST
16067: LIST
16068: PUSH
16069: LD_INT 61
16071: PUSH
16072: EMPTY
16073: LIST
16074: PUSH
16075: LD_INT 33
16077: PUSH
16078: LD_INT 2
16080: PUSH
16081: EMPTY
16082: LIST
16083: LIST
16084: PUSH
16085: EMPTY
16086: LIST
16087: LIST
16088: LIST
16089: PPUSH
16090: CALL_OW 69
16094: ST_TO_ADDR
// if not tmp then
16095: LD_VAR 0 1
16099: NOT
16100: IFFALSE 16104
// exit ;
16102: GO 16141
// for i in tmp do
16104: LD_ADDR_VAR 0 2
16108: PUSH
16109: LD_VAR 0 1
16113: PUSH
16114: FOR_IN
16115: IFFALSE 16139
// if IsControledBy ( i ) then
16117: LD_VAR 0 2
16121: PPUSH
16122: CALL_OW 312
16126: IFFALSE 16137
// ComUnlink ( i ) ;
16128: LD_VAR 0 2
16132: PPUSH
16133: CALL_OW 136
16137: GO 16114
16139: POP
16140: POP
// end ;
16141: PPOPN 2
16143: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
16144: LD_EXP 29
16148: PUSH
16149: LD_EXP 60
16153: AND
16154: IFFALSE 16288
16156: GO 16158
16158: DISABLE
16159: LD_INT 0
16161: PPUSH
16162: PPUSH
// begin ToLua ( displayPowell(); ) ;
16163: LD_STRING displayPowell();
16165: PPUSH
16166: CALL_OW 559
// uc_side := 0 ;
16170: LD_ADDR_OWVAR 20
16174: PUSH
16175: LD_INT 0
16177: ST_TO_ADDR
// uc_nation := 2 ;
16178: LD_ADDR_OWVAR 21
16182: PUSH
16183: LD_INT 2
16185: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
16186: LD_ADDR_OWVAR 37
16190: PUSH
16191: LD_INT 14
16193: ST_TO_ADDR
// vc_engine := engine_siberite ;
16194: LD_ADDR_OWVAR 39
16198: PUSH
16199: LD_INT 3
16201: ST_TO_ADDR
// vc_control := control_apeman ;
16202: LD_ADDR_OWVAR 38
16206: PUSH
16207: LD_INT 5
16209: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
16210: LD_ADDR_OWVAR 40
16214: PUSH
16215: LD_INT 29
16217: ST_TO_ADDR
// un := CreateVehicle ;
16218: LD_ADDR_VAR 0 2
16222: PUSH
16223: CALL_OW 45
16227: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
16228: LD_VAR 0 2
16232: PPUSH
16233: LD_INT 1
16235: PPUSH
16236: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
16240: LD_INT 35
16242: PPUSH
16243: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
16247: LD_VAR 0 2
16251: PPUSH
16252: LD_OWVAR 3
16256: PUSH
16257: LD_VAR 0 2
16261: DIFF
16262: PPUSH
16263: LD_VAR 0 2
16267: PPUSH
16268: CALL_OW 74
16272: PPUSH
16273: CALL_OW 115
// until IsOk ( un ) ;
16277: LD_VAR 0 2
16281: PPUSH
16282: CALL_OW 302
16286: IFFALSE 16240
// end ;
16288: PPOPN 2
16290: END
// every 0 0$1 trigger StreamModeActive and sStu do
16291: LD_EXP 29
16295: PUSH
16296: LD_EXP 68
16300: AND
16301: IFFALSE 16313
16303: GO 16305
16305: DISABLE
// begin ToLua ( displayStucuk(); ) ;
16306: LD_STRING displayStucuk();
16308: PPUSH
16309: CALL_OW 559
// end ;
16313: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
16314: LD_EXP 29
16318: PUSH
16319: LD_EXP 61
16323: AND
16324: IFFALSE 16465
16326: GO 16328
16328: DISABLE
16329: LD_INT 0
16331: PPUSH
16332: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
16333: LD_ADDR_VAR 0 2
16337: PUSH
16338: LD_INT 22
16340: PUSH
16341: LD_OWVAR 2
16345: PUSH
16346: EMPTY
16347: LIST
16348: LIST
16349: PUSH
16350: LD_INT 21
16352: PUSH
16353: LD_INT 1
16355: PUSH
16356: EMPTY
16357: LIST
16358: LIST
16359: PUSH
16360: EMPTY
16361: LIST
16362: LIST
16363: PPUSH
16364: CALL_OW 69
16368: ST_TO_ADDR
// if not tmp then
16369: LD_VAR 0 2
16373: NOT
16374: IFFALSE 16378
// exit ;
16376: GO 16465
// un := tmp [ rand ( 1 , tmp ) ] ;
16378: LD_ADDR_VAR 0 1
16382: PUSH
16383: LD_VAR 0 2
16387: PUSH
16388: LD_INT 1
16390: PPUSH
16391: LD_VAR 0 2
16395: PPUSH
16396: CALL_OW 12
16400: ARRAY
16401: ST_TO_ADDR
// SetSide ( un , 0 ) ;
16402: LD_VAR 0 1
16406: PPUSH
16407: LD_INT 0
16409: PPUSH
16410: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
16414: LD_VAR 0 1
16418: PPUSH
16419: LD_OWVAR 3
16423: PUSH
16424: LD_VAR 0 1
16428: DIFF
16429: PPUSH
16430: LD_VAR 0 1
16434: PPUSH
16435: CALL_OW 74
16439: PPUSH
16440: CALL_OW 115
// wait ( 0 0$20 ) ;
16444: LD_INT 700
16446: PPUSH
16447: CALL_OW 67
// SetSide ( un , your_side ) ;
16451: LD_VAR 0 1
16455: PPUSH
16456: LD_OWVAR 2
16460: PPUSH
16461: CALL_OW 235
// end ;
16465: PPOPN 2
16467: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
16468: LD_EXP 29
16472: PUSH
16473: LD_EXP 62
16477: AND
16478: IFFALSE 16584
16480: GO 16482
16482: DISABLE
16483: LD_INT 0
16485: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
16486: LD_ADDR_VAR 0 1
16490: PUSH
16491: LD_INT 22
16493: PUSH
16494: LD_OWVAR 2
16498: PUSH
16499: EMPTY
16500: LIST
16501: LIST
16502: PUSH
16503: LD_INT 2
16505: PUSH
16506: LD_INT 30
16508: PUSH
16509: LD_INT 0
16511: PUSH
16512: EMPTY
16513: LIST
16514: LIST
16515: PUSH
16516: LD_INT 30
16518: PUSH
16519: LD_INT 1
16521: PUSH
16522: EMPTY
16523: LIST
16524: LIST
16525: PUSH
16526: EMPTY
16527: LIST
16528: LIST
16529: LIST
16530: PUSH
16531: EMPTY
16532: LIST
16533: LIST
16534: PPUSH
16535: CALL_OW 69
16539: ST_TO_ADDR
// if not depot then
16540: LD_VAR 0 1
16544: NOT
16545: IFFALSE 16549
// exit ;
16547: GO 16584
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
16549: LD_VAR 0 1
16553: PUSH
16554: LD_INT 1
16556: ARRAY
16557: PPUSH
16558: CALL_OW 250
16562: PPUSH
16563: LD_VAR 0 1
16567: PUSH
16568: LD_INT 1
16570: ARRAY
16571: PPUSH
16572: CALL_OW 251
16576: PPUSH
16577: LD_INT 70
16579: PPUSH
16580: CALL_OW 495
// end ;
16584: PPOPN 1
16586: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
16587: LD_EXP 29
16591: PUSH
16592: LD_EXP 63
16596: AND
16597: IFFALSE 16808
16599: GO 16601
16601: DISABLE
16602: LD_INT 0
16604: PPUSH
16605: PPUSH
16606: PPUSH
16607: PPUSH
16608: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
16609: LD_ADDR_VAR 0 5
16613: PUSH
16614: LD_INT 22
16616: PUSH
16617: LD_OWVAR 2
16621: PUSH
16622: EMPTY
16623: LIST
16624: LIST
16625: PUSH
16626: LD_INT 21
16628: PUSH
16629: LD_INT 1
16631: PUSH
16632: EMPTY
16633: LIST
16634: LIST
16635: PUSH
16636: EMPTY
16637: LIST
16638: LIST
16639: PPUSH
16640: CALL_OW 69
16644: ST_TO_ADDR
// if not tmp then
16645: LD_VAR 0 5
16649: NOT
16650: IFFALSE 16654
// exit ;
16652: GO 16808
// for i in tmp do
16654: LD_ADDR_VAR 0 1
16658: PUSH
16659: LD_VAR 0 5
16663: PUSH
16664: FOR_IN
16665: IFFALSE 16806
// begin d := rand ( 0 , 5 ) ;
16667: LD_ADDR_VAR 0 4
16671: PUSH
16672: LD_INT 0
16674: PPUSH
16675: LD_INT 5
16677: PPUSH
16678: CALL_OW 12
16682: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
16683: LD_ADDR_VAR 0 2
16687: PUSH
16688: LD_VAR 0 1
16692: PPUSH
16693: CALL_OW 250
16697: PPUSH
16698: LD_VAR 0 4
16702: PPUSH
16703: LD_INT 3
16705: PPUSH
16706: LD_INT 12
16708: PPUSH
16709: CALL_OW 12
16713: PPUSH
16714: CALL_OW 272
16718: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
16719: LD_ADDR_VAR 0 3
16723: PUSH
16724: LD_VAR 0 1
16728: PPUSH
16729: CALL_OW 251
16733: PPUSH
16734: LD_VAR 0 4
16738: PPUSH
16739: LD_INT 3
16741: PPUSH
16742: LD_INT 12
16744: PPUSH
16745: CALL_OW 12
16749: PPUSH
16750: CALL_OW 273
16754: ST_TO_ADDR
// if ValidHex ( x , y ) then
16755: LD_VAR 0 2
16759: PPUSH
16760: LD_VAR 0 3
16764: PPUSH
16765: CALL_OW 488
16769: IFFALSE 16804
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
16771: LD_VAR 0 1
16775: PPUSH
16776: LD_VAR 0 2
16780: PPUSH
16781: LD_VAR 0 3
16785: PPUSH
16786: LD_INT 3
16788: PPUSH
16789: LD_INT 6
16791: PPUSH
16792: CALL_OW 12
16796: PPUSH
16797: LD_INT 1
16799: PPUSH
16800: CALL_OW 483
// end ;
16804: GO 16664
16806: POP
16807: POP
// end ;
16808: PPOPN 5
16810: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
16811: LD_EXP 29
16815: PUSH
16816: LD_EXP 64
16820: AND
16821: IFFALSE 16915
16823: GO 16825
16825: DISABLE
16826: LD_INT 0
16828: PPUSH
16829: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
16830: LD_ADDR_VAR 0 2
16834: PUSH
16835: LD_INT 22
16837: PUSH
16838: LD_OWVAR 2
16842: PUSH
16843: EMPTY
16844: LIST
16845: LIST
16846: PUSH
16847: LD_INT 32
16849: PUSH
16850: LD_INT 1
16852: PUSH
16853: EMPTY
16854: LIST
16855: LIST
16856: PUSH
16857: LD_INT 21
16859: PUSH
16860: LD_INT 2
16862: PUSH
16863: EMPTY
16864: LIST
16865: LIST
16866: PUSH
16867: EMPTY
16868: LIST
16869: LIST
16870: LIST
16871: PPUSH
16872: CALL_OW 69
16876: ST_TO_ADDR
// if not tmp then
16877: LD_VAR 0 2
16881: NOT
16882: IFFALSE 16886
// exit ;
16884: GO 16915
// for i in tmp do
16886: LD_ADDR_VAR 0 1
16890: PUSH
16891: LD_VAR 0 2
16895: PUSH
16896: FOR_IN
16897: IFFALSE 16913
// SetFuel ( i , 0 ) ;
16899: LD_VAR 0 1
16903: PPUSH
16904: LD_INT 0
16906: PPUSH
16907: CALL_OW 240
16911: GO 16896
16913: POP
16914: POP
// end ;
16915: PPOPN 2
16917: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
16918: LD_EXP 29
16922: PUSH
16923: LD_EXP 65
16927: AND
16928: IFFALSE 16994
16930: GO 16932
16932: DISABLE
16933: LD_INT 0
16935: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
16936: LD_ADDR_VAR 0 1
16940: PUSH
16941: LD_INT 22
16943: PUSH
16944: LD_OWVAR 2
16948: PUSH
16949: EMPTY
16950: LIST
16951: LIST
16952: PUSH
16953: LD_INT 30
16955: PUSH
16956: LD_INT 29
16958: PUSH
16959: EMPTY
16960: LIST
16961: LIST
16962: PUSH
16963: EMPTY
16964: LIST
16965: LIST
16966: PPUSH
16967: CALL_OW 69
16971: ST_TO_ADDR
// if not tmp then
16972: LD_VAR 0 1
16976: NOT
16977: IFFALSE 16981
// exit ;
16979: GO 16994
// DestroyUnit ( tmp [ 1 ] ) ;
16981: LD_VAR 0 1
16985: PUSH
16986: LD_INT 1
16988: ARRAY
16989: PPUSH
16990: CALL_OW 65
// end ;
16994: PPOPN 1
16996: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
16997: LD_EXP 29
17001: PUSH
17002: LD_EXP 67
17006: AND
17007: IFFALSE 17136
17009: GO 17011
17011: DISABLE
17012: LD_INT 0
17014: PPUSH
// begin uc_side := 0 ;
17015: LD_ADDR_OWVAR 20
17019: PUSH
17020: LD_INT 0
17022: ST_TO_ADDR
// uc_nation := nation_arabian ;
17023: LD_ADDR_OWVAR 21
17027: PUSH
17028: LD_INT 2
17030: ST_TO_ADDR
// hc_gallery :=  ;
17031: LD_ADDR_OWVAR 33
17035: PUSH
17036: LD_STRING 
17038: ST_TO_ADDR
// hc_name :=  ;
17039: LD_ADDR_OWVAR 26
17043: PUSH
17044: LD_STRING 
17046: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
17047: LD_INT 1
17049: PPUSH
17050: LD_INT 11
17052: PPUSH
17053: LD_INT 10
17055: PPUSH
17056: CALL_OW 380
// un := CreateHuman ;
17060: LD_ADDR_VAR 0 1
17064: PUSH
17065: CALL_OW 44
17069: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
17070: LD_VAR 0 1
17074: PPUSH
17075: LD_INT 1
17077: PPUSH
17078: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
17082: LD_INT 35
17084: PPUSH
17085: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
17089: LD_VAR 0 1
17093: PPUSH
17094: LD_INT 22
17096: PUSH
17097: LD_OWVAR 2
17101: PUSH
17102: EMPTY
17103: LIST
17104: LIST
17105: PPUSH
17106: CALL_OW 69
17110: PPUSH
17111: LD_VAR 0 1
17115: PPUSH
17116: CALL_OW 74
17120: PPUSH
17121: CALL_OW 115
// until IsDead ( un ) ;
17125: LD_VAR 0 1
17129: PPUSH
17130: CALL_OW 301
17134: IFFALSE 17082
// end ;
17136: PPOPN 1
17138: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
17139: LD_EXP 29
17143: PUSH
17144: LD_EXP 69
17148: AND
17149: IFFALSE 17161
17151: GO 17153
17153: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
17154: LD_STRING earthquake(getX(game), 0, 32)
17156: PPUSH
17157: CALL_OW 559
17161: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
17162: LD_EXP 29
17166: PUSH
17167: LD_EXP 70
17171: AND
17172: IFFALSE 17263
17174: GO 17176
17176: DISABLE
17177: LD_INT 0
17179: PPUSH
// begin enable ;
17180: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
17181: LD_ADDR_VAR 0 1
17185: PUSH
17186: LD_INT 22
17188: PUSH
17189: LD_OWVAR 2
17193: PUSH
17194: EMPTY
17195: LIST
17196: LIST
17197: PUSH
17198: LD_INT 21
17200: PUSH
17201: LD_INT 2
17203: PUSH
17204: EMPTY
17205: LIST
17206: LIST
17207: PUSH
17208: LD_INT 33
17210: PUSH
17211: LD_INT 3
17213: PUSH
17214: EMPTY
17215: LIST
17216: LIST
17217: PUSH
17218: EMPTY
17219: LIST
17220: LIST
17221: LIST
17222: PPUSH
17223: CALL_OW 69
17227: ST_TO_ADDR
// if not tmp then
17228: LD_VAR 0 1
17232: NOT
17233: IFFALSE 17237
// exit ;
17235: GO 17263
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
17237: LD_VAR 0 1
17241: PUSH
17242: LD_INT 1
17244: PPUSH
17245: LD_VAR 0 1
17249: PPUSH
17250: CALL_OW 12
17254: ARRAY
17255: PPUSH
17256: LD_INT 1
17258: PPUSH
17259: CALL_OW 234
// end ;
17263: PPOPN 1
17265: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
17266: LD_EXP 29
17270: PUSH
17271: LD_EXP 71
17275: AND
17276: IFFALSE 17417
17278: GO 17280
17280: DISABLE
17281: LD_INT 0
17283: PPUSH
17284: PPUSH
17285: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
17286: LD_ADDR_VAR 0 3
17290: PUSH
17291: LD_INT 22
17293: PUSH
17294: LD_OWVAR 2
17298: PUSH
17299: EMPTY
17300: LIST
17301: LIST
17302: PUSH
17303: LD_INT 25
17305: PUSH
17306: LD_INT 1
17308: PUSH
17309: EMPTY
17310: LIST
17311: LIST
17312: PUSH
17313: EMPTY
17314: LIST
17315: LIST
17316: PPUSH
17317: CALL_OW 69
17321: ST_TO_ADDR
// if not tmp then
17322: LD_VAR 0 3
17326: NOT
17327: IFFALSE 17331
// exit ;
17329: GO 17417
// un := tmp [ rand ( 1 , tmp ) ] ;
17331: LD_ADDR_VAR 0 2
17335: PUSH
17336: LD_VAR 0 3
17340: PUSH
17341: LD_INT 1
17343: PPUSH
17344: LD_VAR 0 3
17348: PPUSH
17349: CALL_OW 12
17353: ARRAY
17354: ST_TO_ADDR
// if Crawls ( un ) then
17355: LD_VAR 0 2
17359: PPUSH
17360: CALL_OW 318
17364: IFFALSE 17375
// ComWalk ( un ) ;
17366: LD_VAR 0 2
17370: PPUSH
17371: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
17375: LD_VAR 0 2
17379: PPUSH
17380: LD_INT 9
17382: PPUSH
17383: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
17387: LD_INT 28
17389: PPUSH
17390: LD_OWVAR 2
17394: PPUSH
17395: LD_INT 2
17397: PPUSH
17398: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
17402: LD_INT 29
17404: PPUSH
17405: LD_OWVAR 2
17409: PPUSH
17410: LD_INT 2
17412: PPUSH
17413: CALL_OW 322
// end ;
17417: PPOPN 3
17419: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
17420: LD_EXP 29
17424: PUSH
17425: LD_EXP 72
17429: AND
17430: IFFALSE 17541
17432: GO 17434
17434: DISABLE
17435: LD_INT 0
17437: PPUSH
17438: PPUSH
17439: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
17440: LD_ADDR_VAR 0 3
17444: PUSH
17445: LD_INT 22
17447: PUSH
17448: LD_OWVAR 2
17452: PUSH
17453: EMPTY
17454: LIST
17455: LIST
17456: PUSH
17457: LD_INT 25
17459: PUSH
17460: LD_INT 1
17462: PUSH
17463: EMPTY
17464: LIST
17465: LIST
17466: PUSH
17467: EMPTY
17468: LIST
17469: LIST
17470: PPUSH
17471: CALL_OW 69
17475: ST_TO_ADDR
// if not tmp then
17476: LD_VAR 0 3
17480: NOT
17481: IFFALSE 17485
// exit ;
17483: GO 17541
// un := tmp [ rand ( 1 , tmp ) ] ;
17485: LD_ADDR_VAR 0 2
17489: PUSH
17490: LD_VAR 0 3
17494: PUSH
17495: LD_INT 1
17497: PPUSH
17498: LD_VAR 0 3
17502: PPUSH
17503: CALL_OW 12
17507: ARRAY
17508: ST_TO_ADDR
// if Crawls ( un ) then
17509: LD_VAR 0 2
17513: PPUSH
17514: CALL_OW 318
17518: IFFALSE 17529
// ComWalk ( un ) ;
17520: LD_VAR 0 2
17524: PPUSH
17525: CALL_OW 138
// SetClass ( un , class_mortar ) ;
17529: LD_VAR 0 2
17533: PPUSH
17534: LD_INT 8
17536: PPUSH
17537: CALL_OW 336
// end ;
17541: PPOPN 3
17543: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
17544: LD_EXP 29
17548: PUSH
17549: LD_EXP 73
17553: AND
17554: IFFALSE 17698
17556: GO 17558
17558: DISABLE
17559: LD_INT 0
17561: PPUSH
17562: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
17563: LD_ADDR_VAR 0 2
17567: PUSH
17568: LD_INT 22
17570: PUSH
17571: LD_OWVAR 2
17575: PUSH
17576: EMPTY
17577: LIST
17578: LIST
17579: PUSH
17580: LD_INT 21
17582: PUSH
17583: LD_INT 2
17585: PUSH
17586: EMPTY
17587: LIST
17588: LIST
17589: PUSH
17590: LD_INT 2
17592: PUSH
17593: LD_INT 34
17595: PUSH
17596: LD_INT 12
17598: PUSH
17599: EMPTY
17600: LIST
17601: LIST
17602: PUSH
17603: LD_INT 34
17605: PUSH
17606: LD_INT 51
17608: PUSH
17609: EMPTY
17610: LIST
17611: LIST
17612: PUSH
17613: LD_INT 34
17615: PUSH
17616: LD_INT 32
17618: PUSH
17619: EMPTY
17620: LIST
17621: LIST
17622: PUSH
17623: EMPTY
17624: LIST
17625: LIST
17626: LIST
17627: LIST
17628: PUSH
17629: EMPTY
17630: LIST
17631: LIST
17632: LIST
17633: PPUSH
17634: CALL_OW 69
17638: ST_TO_ADDR
// if not tmp then
17639: LD_VAR 0 2
17643: NOT
17644: IFFALSE 17648
// exit ;
17646: GO 17698
// for i in tmp do
17648: LD_ADDR_VAR 0 1
17652: PUSH
17653: LD_VAR 0 2
17657: PUSH
17658: FOR_IN
17659: IFFALSE 17696
// if GetCargo ( i , mat_artifact ) = 0 then
17661: LD_VAR 0 1
17665: PPUSH
17666: LD_INT 4
17668: PPUSH
17669: CALL_OW 289
17673: PUSH
17674: LD_INT 0
17676: EQUAL
17677: IFFALSE 17694
// SetCargo ( i , mat_siberit , 100 ) ;
17679: LD_VAR 0 1
17683: PPUSH
17684: LD_INT 3
17686: PPUSH
17687: LD_INT 100
17689: PPUSH
17690: CALL_OW 290
17694: GO 17658
17696: POP
17697: POP
// end ;
17698: PPOPN 2
17700: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
17701: LD_EXP 29
17705: PUSH
17706: LD_EXP 74
17710: AND
17711: IFFALSE 17864
17713: GO 17715
17715: DISABLE
17716: LD_INT 0
17718: PPUSH
17719: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
17720: LD_ADDR_VAR 0 2
17724: PUSH
17725: LD_INT 22
17727: PUSH
17728: LD_OWVAR 2
17732: PUSH
17733: EMPTY
17734: LIST
17735: LIST
17736: PPUSH
17737: CALL_OW 69
17741: ST_TO_ADDR
// if not tmp then
17742: LD_VAR 0 2
17746: NOT
17747: IFFALSE 17751
// exit ;
17749: GO 17864
// for i := 1 to 2 do
17751: LD_ADDR_VAR 0 1
17755: PUSH
17756: DOUBLE
17757: LD_INT 1
17759: DEC
17760: ST_TO_ADDR
17761: LD_INT 2
17763: PUSH
17764: FOR_TO
17765: IFFALSE 17862
// begin uc_side := your_side ;
17767: LD_ADDR_OWVAR 20
17771: PUSH
17772: LD_OWVAR 2
17776: ST_TO_ADDR
// uc_nation := nation_american ;
17777: LD_ADDR_OWVAR 21
17781: PUSH
17782: LD_INT 1
17784: ST_TO_ADDR
// vc_chassis := us_morphling ;
17785: LD_ADDR_OWVAR 37
17789: PUSH
17790: LD_INT 5
17792: ST_TO_ADDR
// vc_engine := engine_siberite ;
17793: LD_ADDR_OWVAR 39
17797: PUSH
17798: LD_INT 3
17800: ST_TO_ADDR
// vc_control := control_computer ;
17801: LD_ADDR_OWVAR 38
17805: PUSH
17806: LD_INT 3
17808: ST_TO_ADDR
// vc_weapon := us_double_laser ;
17809: LD_ADDR_OWVAR 40
17813: PUSH
17814: LD_INT 10
17816: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
17817: CALL_OW 45
17821: PPUSH
17822: LD_VAR 0 2
17826: PUSH
17827: LD_INT 1
17829: ARRAY
17830: PPUSH
17831: CALL_OW 250
17835: PPUSH
17836: LD_VAR 0 2
17840: PUSH
17841: LD_INT 1
17843: ARRAY
17844: PPUSH
17845: CALL_OW 251
17849: PPUSH
17850: LD_INT 12
17852: PPUSH
17853: LD_INT 1
17855: PPUSH
17856: CALL_OW 50
// end ;
17860: GO 17764
17862: POP
17863: POP
// end ;
17864: PPOPN 2
17866: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
17867: LD_EXP 29
17871: PUSH
17872: LD_EXP 75
17876: AND
17877: IFFALSE 18099
17879: GO 17881
17881: DISABLE
17882: LD_INT 0
17884: PPUSH
17885: PPUSH
17886: PPUSH
17887: PPUSH
17888: PPUSH
17889: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
17890: LD_ADDR_VAR 0 6
17894: PUSH
17895: LD_INT 22
17897: PUSH
17898: LD_OWVAR 2
17902: PUSH
17903: EMPTY
17904: LIST
17905: LIST
17906: PUSH
17907: LD_INT 21
17909: PUSH
17910: LD_INT 1
17912: PUSH
17913: EMPTY
17914: LIST
17915: LIST
17916: PUSH
17917: LD_INT 3
17919: PUSH
17920: LD_INT 23
17922: PUSH
17923: LD_INT 0
17925: PUSH
17926: EMPTY
17927: LIST
17928: LIST
17929: PUSH
17930: EMPTY
17931: LIST
17932: LIST
17933: PUSH
17934: EMPTY
17935: LIST
17936: LIST
17937: LIST
17938: PPUSH
17939: CALL_OW 69
17943: ST_TO_ADDR
// if not tmp then
17944: LD_VAR 0 6
17948: NOT
17949: IFFALSE 17953
// exit ;
17951: GO 18099
// s1 := rand ( 1 , 4 ) ;
17953: LD_ADDR_VAR 0 2
17957: PUSH
17958: LD_INT 1
17960: PPUSH
17961: LD_INT 4
17963: PPUSH
17964: CALL_OW 12
17968: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
17969: LD_ADDR_VAR 0 4
17973: PUSH
17974: LD_VAR 0 6
17978: PUSH
17979: LD_INT 1
17981: ARRAY
17982: PPUSH
17983: LD_VAR 0 2
17987: PPUSH
17988: CALL_OW 259
17992: ST_TO_ADDR
// if s1 = 1 then
17993: LD_VAR 0 2
17997: PUSH
17998: LD_INT 1
18000: EQUAL
18001: IFFALSE 18021
// s2 := rand ( 2 , 4 ) else
18003: LD_ADDR_VAR 0 3
18007: PUSH
18008: LD_INT 2
18010: PPUSH
18011: LD_INT 4
18013: PPUSH
18014: CALL_OW 12
18018: ST_TO_ADDR
18019: GO 18029
// s2 := 1 ;
18021: LD_ADDR_VAR 0 3
18025: PUSH
18026: LD_INT 1
18028: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
18029: LD_ADDR_VAR 0 5
18033: PUSH
18034: LD_VAR 0 6
18038: PUSH
18039: LD_INT 1
18041: ARRAY
18042: PPUSH
18043: LD_VAR 0 3
18047: PPUSH
18048: CALL_OW 259
18052: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
18053: LD_VAR 0 6
18057: PUSH
18058: LD_INT 1
18060: ARRAY
18061: PPUSH
18062: LD_VAR 0 2
18066: PPUSH
18067: LD_VAR 0 5
18071: PPUSH
18072: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
18076: LD_VAR 0 6
18080: PUSH
18081: LD_INT 1
18083: ARRAY
18084: PPUSH
18085: LD_VAR 0 3
18089: PPUSH
18090: LD_VAR 0 4
18094: PPUSH
18095: CALL_OW 237
// end ;
18099: PPOPN 6
18101: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
18102: LD_EXP 29
18106: PUSH
18107: LD_EXP 76
18111: AND
18112: IFFALSE 18191
18114: GO 18116
18116: DISABLE
18117: LD_INT 0
18119: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
18120: LD_ADDR_VAR 0 1
18124: PUSH
18125: LD_INT 22
18127: PUSH
18128: LD_OWVAR 2
18132: PUSH
18133: EMPTY
18134: LIST
18135: LIST
18136: PUSH
18137: LD_INT 30
18139: PUSH
18140: LD_INT 3
18142: PUSH
18143: EMPTY
18144: LIST
18145: LIST
18146: PUSH
18147: EMPTY
18148: LIST
18149: LIST
18150: PPUSH
18151: CALL_OW 69
18155: ST_TO_ADDR
// if not tmp then
18156: LD_VAR 0 1
18160: NOT
18161: IFFALSE 18165
// exit ;
18163: GO 18191
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
18165: LD_VAR 0 1
18169: PUSH
18170: LD_INT 1
18172: PPUSH
18173: LD_VAR 0 1
18177: PPUSH
18178: CALL_OW 12
18182: ARRAY
18183: PPUSH
18184: LD_INT 1
18186: PPUSH
18187: CALL_OW 234
// end ;
18191: PPOPN 1
18193: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
18194: LD_EXP 29
18198: PUSH
18199: LD_EXP 77
18203: AND
18204: IFFALSE 18316
18206: GO 18208
18208: DISABLE
18209: LD_INT 0
18211: PPUSH
18212: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
18213: LD_ADDR_VAR 0 2
18217: PUSH
18218: LD_INT 22
18220: PUSH
18221: LD_OWVAR 2
18225: PUSH
18226: EMPTY
18227: LIST
18228: LIST
18229: PUSH
18230: LD_INT 2
18232: PUSH
18233: LD_INT 30
18235: PUSH
18236: LD_INT 27
18238: PUSH
18239: EMPTY
18240: LIST
18241: LIST
18242: PUSH
18243: LD_INT 30
18245: PUSH
18246: LD_INT 26
18248: PUSH
18249: EMPTY
18250: LIST
18251: LIST
18252: PUSH
18253: LD_INT 30
18255: PUSH
18256: LD_INT 28
18258: PUSH
18259: EMPTY
18260: LIST
18261: LIST
18262: PUSH
18263: EMPTY
18264: LIST
18265: LIST
18266: LIST
18267: LIST
18268: PUSH
18269: EMPTY
18270: LIST
18271: LIST
18272: PPUSH
18273: CALL_OW 69
18277: ST_TO_ADDR
// if not tmp then
18278: LD_VAR 0 2
18282: NOT
18283: IFFALSE 18287
// exit ;
18285: GO 18316
// for i in tmp do
18287: LD_ADDR_VAR 0 1
18291: PUSH
18292: LD_VAR 0 2
18296: PUSH
18297: FOR_IN
18298: IFFALSE 18314
// SetLives ( i , 1 ) ;
18300: LD_VAR 0 1
18304: PPUSH
18305: LD_INT 1
18307: PPUSH
18308: CALL_OW 234
18312: GO 18297
18314: POP
18315: POP
// end ;
18316: PPOPN 2
18318: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
18319: LD_EXP 29
18323: PUSH
18324: LD_EXP 78
18328: AND
18329: IFFALSE 18599
18331: GO 18333
18333: DISABLE
18334: LD_INT 0
18336: PPUSH
18337: PPUSH
18338: PPUSH
// begin i := rand ( 1 , 7 ) ;
18339: LD_ADDR_VAR 0 1
18343: PUSH
18344: LD_INT 1
18346: PPUSH
18347: LD_INT 7
18349: PPUSH
18350: CALL_OW 12
18354: ST_TO_ADDR
// case i of 1 :
18355: LD_VAR 0 1
18359: PUSH
18360: LD_INT 1
18362: DOUBLE
18363: EQUAL
18364: IFTRUE 18368
18366: GO 18378
18368: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
18369: LD_STRING earthquake(getX(game), 0, 32)
18371: PPUSH
18372: CALL_OW 559
18376: GO 18599
18378: LD_INT 2
18380: DOUBLE
18381: EQUAL
18382: IFTRUE 18386
18384: GO 18396
18386: POP
// ToLua ( displayStucuk(); ) ; 3 :
18387: LD_STRING displayStucuk();
18389: PPUSH
18390: CALL_OW 559
18394: GO 18599
18396: LD_INT 3
18398: DOUBLE
18399: EQUAL
18400: IFTRUE 18404
18402: GO 18508
18404: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
18405: LD_ADDR_VAR 0 2
18409: PUSH
18410: LD_INT 22
18412: PUSH
18413: LD_OWVAR 2
18417: PUSH
18418: EMPTY
18419: LIST
18420: LIST
18421: PUSH
18422: LD_INT 25
18424: PUSH
18425: LD_INT 1
18427: PUSH
18428: EMPTY
18429: LIST
18430: LIST
18431: PUSH
18432: EMPTY
18433: LIST
18434: LIST
18435: PPUSH
18436: CALL_OW 69
18440: ST_TO_ADDR
// if not tmp then
18441: LD_VAR 0 2
18445: NOT
18446: IFFALSE 18450
// exit ;
18448: GO 18599
// un := tmp [ rand ( 1 , tmp ) ] ;
18450: LD_ADDR_VAR 0 3
18454: PUSH
18455: LD_VAR 0 2
18459: PUSH
18460: LD_INT 1
18462: PPUSH
18463: LD_VAR 0 2
18467: PPUSH
18468: CALL_OW 12
18472: ARRAY
18473: ST_TO_ADDR
// if Crawls ( un ) then
18474: LD_VAR 0 3
18478: PPUSH
18479: CALL_OW 318
18483: IFFALSE 18494
// ComWalk ( un ) ;
18485: LD_VAR 0 3
18489: PPUSH
18490: CALL_OW 138
// SetClass ( un , class_mortar ) ;
18494: LD_VAR 0 3
18498: PPUSH
18499: LD_INT 8
18501: PPUSH
18502: CALL_OW 336
// end ; 4 :
18506: GO 18599
18508: LD_INT 4
18510: DOUBLE
18511: EQUAL
18512: IFTRUE 18516
18514: GO 18577
18516: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
18517: LD_ADDR_VAR 0 2
18521: PUSH
18522: LD_INT 22
18524: PUSH
18525: LD_OWVAR 2
18529: PUSH
18530: EMPTY
18531: LIST
18532: LIST
18533: PUSH
18534: LD_INT 30
18536: PUSH
18537: LD_INT 29
18539: PUSH
18540: EMPTY
18541: LIST
18542: LIST
18543: PUSH
18544: EMPTY
18545: LIST
18546: LIST
18547: PPUSH
18548: CALL_OW 69
18552: ST_TO_ADDR
// if not tmp then
18553: LD_VAR 0 2
18557: NOT
18558: IFFALSE 18562
// exit ;
18560: GO 18599
// DestroyUnit ( tmp [ 1 ] ) ;
18562: LD_VAR 0 2
18566: PUSH
18567: LD_INT 1
18569: ARRAY
18570: PPUSH
18571: CALL_OW 65
// end ; 5 .. 7 :
18575: GO 18599
18577: LD_INT 5
18579: DOUBLE
18580: GREATEREQUAL
18581: IFFALSE 18589
18583: LD_INT 7
18585: DOUBLE
18586: LESSEQUAL
18587: IFTRUE 18591
18589: GO 18598
18591: POP
// StreamSibBomb ; end ;
18592: CALL 14893 0 0
18596: GO 18599
18598: POP
// end ;
18599: PPOPN 3
18601: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
18602: LD_EXP 29
18606: PUSH
18607: LD_EXP 79
18611: AND
18612: IFFALSE 18768
18614: GO 18616
18616: DISABLE
18617: LD_INT 0
18619: PPUSH
18620: PPUSH
18621: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
18622: LD_ADDR_VAR 0 2
18626: PUSH
18627: LD_INT 81
18629: PUSH
18630: LD_OWVAR 2
18634: PUSH
18635: EMPTY
18636: LIST
18637: LIST
18638: PUSH
18639: LD_INT 2
18641: PUSH
18642: LD_INT 21
18644: PUSH
18645: LD_INT 1
18647: PUSH
18648: EMPTY
18649: LIST
18650: LIST
18651: PUSH
18652: LD_INT 21
18654: PUSH
18655: LD_INT 2
18657: PUSH
18658: EMPTY
18659: LIST
18660: LIST
18661: PUSH
18662: EMPTY
18663: LIST
18664: LIST
18665: LIST
18666: PUSH
18667: EMPTY
18668: LIST
18669: LIST
18670: PPUSH
18671: CALL_OW 69
18675: ST_TO_ADDR
// if not tmp then
18676: LD_VAR 0 2
18680: NOT
18681: IFFALSE 18685
// exit ;
18683: GO 18768
// p := 0 ;
18685: LD_ADDR_VAR 0 3
18689: PUSH
18690: LD_INT 0
18692: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18693: LD_INT 35
18695: PPUSH
18696: CALL_OW 67
// p := p + 1 ;
18700: LD_ADDR_VAR 0 3
18704: PUSH
18705: LD_VAR 0 3
18709: PUSH
18710: LD_INT 1
18712: PLUS
18713: ST_TO_ADDR
// for i in tmp do
18714: LD_ADDR_VAR 0 1
18718: PUSH
18719: LD_VAR 0 2
18723: PUSH
18724: FOR_IN
18725: IFFALSE 18756
// if GetLives ( i ) < 1000 then
18727: LD_VAR 0 1
18731: PPUSH
18732: CALL_OW 256
18736: PUSH
18737: LD_INT 1000
18739: LESS
18740: IFFALSE 18754
// SetLives ( i , 1000 ) ;
18742: LD_VAR 0 1
18746: PPUSH
18747: LD_INT 1000
18749: PPUSH
18750: CALL_OW 234
18754: GO 18724
18756: POP
18757: POP
// until p > 20 ;
18758: LD_VAR 0 3
18762: PUSH
18763: LD_INT 20
18765: GREATER
18766: IFFALSE 18693
// end ;
18768: PPOPN 3
18770: END
// every 0 0$1 trigger StreamModeActive and sTime do
18771: LD_EXP 29
18775: PUSH
18776: LD_EXP 80
18780: AND
18781: IFFALSE 18816
18783: GO 18785
18785: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
18786: LD_INT 28
18788: PPUSH
18789: LD_OWVAR 2
18793: PPUSH
18794: LD_INT 2
18796: PPUSH
18797: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
18801: LD_INT 30
18803: PPUSH
18804: LD_OWVAR 2
18808: PPUSH
18809: LD_INT 2
18811: PPUSH
18812: CALL_OW 322
// end ;
18816: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
18817: LD_EXP 29
18821: PUSH
18822: LD_EXP 81
18826: AND
18827: IFFALSE 18948
18829: GO 18831
18831: DISABLE
18832: LD_INT 0
18834: PPUSH
18835: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
18836: LD_ADDR_VAR 0 2
18840: PUSH
18841: LD_INT 22
18843: PUSH
18844: LD_OWVAR 2
18848: PUSH
18849: EMPTY
18850: LIST
18851: LIST
18852: PUSH
18853: LD_INT 21
18855: PUSH
18856: LD_INT 1
18858: PUSH
18859: EMPTY
18860: LIST
18861: LIST
18862: PUSH
18863: LD_INT 3
18865: PUSH
18866: LD_INT 23
18868: PUSH
18869: LD_INT 0
18871: PUSH
18872: EMPTY
18873: LIST
18874: LIST
18875: PUSH
18876: EMPTY
18877: LIST
18878: LIST
18879: PUSH
18880: EMPTY
18881: LIST
18882: LIST
18883: LIST
18884: PPUSH
18885: CALL_OW 69
18889: ST_TO_ADDR
// if not tmp then
18890: LD_VAR 0 2
18894: NOT
18895: IFFALSE 18899
// exit ;
18897: GO 18948
// for i in tmp do
18899: LD_ADDR_VAR 0 1
18903: PUSH
18904: LD_VAR 0 2
18908: PUSH
18909: FOR_IN
18910: IFFALSE 18946
// begin if Crawls ( i ) then
18912: LD_VAR 0 1
18916: PPUSH
18917: CALL_OW 318
18921: IFFALSE 18932
// ComWalk ( i ) ;
18923: LD_VAR 0 1
18927: PPUSH
18928: CALL_OW 138
// SetClass ( i , 2 ) ;
18932: LD_VAR 0 1
18936: PPUSH
18937: LD_INT 2
18939: PPUSH
18940: CALL_OW 336
// end ;
18944: GO 18909
18946: POP
18947: POP
// end ;
18948: PPOPN 2
18950: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
18951: LD_EXP 29
18955: PUSH
18956: LD_EXP 82
18960: AND
18961: IFFALSE 19166
18963: GO 18965
18965: DISABLE
18966: LD_INT 0
18968: PPUSH
18969: PPUSH
18970: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
18971: LD_OWVAR 2
18975: PPUSH
18976: LD_INT 9
18978: PPUSH
18979: LD_INT 1
18981: PPUSH
18982: LD_INT 1
18984: PPUSH
18985: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
18989: LD_INT 9
18991: PPUSH
18992: LD_OWVAR 2
18996: PPUSH
18997: CALL_OW 343
// hc_name := Dark Warrior ;
19001: LD_ADDR_OWVAR 26
19005: PUSH
19006: LD_STRING Dark Warrior
19008: ST_TO_ADDR
// hc_gallery :=  ;
19009: LD_ADDR_OWVAR 33
19013: PUSH
19014: LD_STRING 
19016: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 10 ) ;
19017: LD_INT 1
19019: PPUSH
19020: LD_INT 1
19022: PPUSH
19023: LD_INT 10
19025: PPUSH
19026: CALL_OW 380
// un := CreateHuman ;
19030: LD_ADDR_VAR 0 3
19034: PUSH
19035: CALL_OW 44
19039: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
19040: LD_VAR 0 3
19044: PPUSH
19045: LD_INT 1
19047: PPUSH
19048: CALL_OW 51
// p := 0 ;
19052: LD_ADDR_VAR 0 2
19056: PUSH
19057: LD_INT 0
19059: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
19060: LD_INT 35
19062: PPUSH
19063: CALL_OW 67
// if GetLives ( un ) < 1000 then
19067: LD_VAR 0 3
19071: PPUSH
19072: CALL_OW 256
19076: PUSH
19077: LD_INT 1000
19079: LESS
19080: IFFALSE 19094
// SetLives ( un , 1000 ) ;
19082: LD_VAR 0 3
19086: PPUSH
19087: LD_INT 1000
19089: PPUSH
19090: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , your_side ] ) , un ) ) ;
19094: LD_VAR 0 3
19098: PPUSH
19099: LD_INT 81
19101: PUSH
19102: LD_OWVAR 2
19106: PUSH
19107: EMPTY
19108: LIST
19109: LIST
19110: PPUSH
19111: CALL_OW 69
19115: PPUSH
19116: LD_VAR 0 3
19120: PPUSH
19121: CALL_OW 74
19125: PPUSH
19126: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
19130: LD_VAR 0 2
19134: PUSH
19135: LD_INT 60
19137: GREATER
19138: PUSH
19139: LD_VAR 0 3
19143: PPUSH
19144: CALL_OW 301
19148: OR
19149: IFFALSE 19060
// if un then
19151: LD_VAR 0 3
19155: IFFALSE 19166
// RemoveUnit ( un ) ;
19157: LD_VAR 0 3
19161: PPUSH
19162: CALL_OW 64
// end ; end_of_file
19166: PPOPN 3
19168: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
19169: LD_INT 0
19171: PPUSH
19172: PPUSH
19173: PPUSH
19174: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
19175: LD_VAR 0 1
19179: PPUSH
19180: CALL_OW 264
19184: PUSH
19185: LD_EXP 28
19189: EQUAL
19190: IFFALSE 19262
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
19192: LD_INT 68
19194: PPUSH
19195: LD_VAR 0 1
19199: PPUSH
19200: CALL_OW 255
19204: PPUSH
19205: CALL_OW 321
19209: PUSH
19210: LD_INT 2
19212: EQUAL
19213: IFFALSE 19225
// eff := 70 else
19215: LD_ADDR_VAR 0 6
19219: PUSH
19220: LD_INT 70
19222: ST_TO_ADDR
19223: GO 19233
// eff := 30 ;
19225: LD_ADDR_VAR 0 6
19229: PUSH
19230: LD_INT 30
19232: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
19233: LD_VAR 0 1
19237: PPUSH
19238: CALL_OW 250
19242: PPUSH
19243: LD_VAR 0 1
19247: PPUSH
19248: CALL_OW 251
19252: PPUSH
19253: LD_VAR 0 6
19257: PPUSH
19258: CALL_OW 495
// end ; end ;
19262: LD_VAR 0 4
19266: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
19267: LD_INT 0
19269: PPUSH
19270: PPUSH
19271: PPUSH
19272: PPUSH
19273: PPUSH
19274: PPUSH
// if cmd = 124 then
19275: LD_VAR 0 1
19279: PUSH
19280: LD_INT 124
19282: EQUAL
19283: IFFALSE 19489
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
19285: LD_ADDR_VAR 0 5
19289: PUSH
19290: LD_INT 2
19292: PUSH
19293: LD_INT 34
19295: PUSH
19296: LD_INT 53
19298: PUSH
19299: EMPTY
19300: LIST
19301: LIST
19302: PUSH
19303: LD_INT 34
19305: PUSH
19306: LD_INT 14
19308: PUSH
19309: EMPTY
19310: LIST
19311: LIST
19312: PUSH
19313: EMPTY
19314: LIST
19315: LIST
19316: LIST
19317: PPUSH
19318: CALL_OW 69
19322: ST_TO_ADDR
// if not tmp then
19323: LD_VAR 0 5
19327: NOT
19328: IFFALSE 19332
// exit ;
19330: GO 19489
// for i in tmp do
19332: LD_ADDR_VAR 0 3
19336: PUSH
19337: LD_VAR 0 5
19341: PUSH
19342: FOR_IN
19343: IFFALSE 19487
// begin taskList := GetTaskList ( i ) ;
19345: LD_ADDR_VAR 0 6
19349: PUSH
19350: LD_VAR 0 3
19354: PPUSH
19355: CALL_OW 437
19359: ST_TO_ADDR
// if not taskList then
19360: LD_VAR 0 6
19364: NOT
19365: IFFALSE 19369
// continue ;
19367: GO 19342
// for j = 1 to taskList do
19369: LD_ADDR_VAR 0 4
19373: PUSH
19374: DOUBLE
19375: LD_INT 1
19377: DEC
19378: ST_TO_ADDR
19379: LD_VAR 0 6
19383: PUSH
19384: FOR_TO
19385: IFFALSE 19483
// if taskList [ j ] [ 1 ] = | then
19387: LD_VAR 0 6
19391: PUSH
19392: LD_VAR 0 4
19396: ARRAY
19397: PUSH
19398: LD_INT 1
19400: ARRAY
19401: PUSH
19402: LD_STRING |
19404: EQUAL
19405: IFFALSE 19481
// begin _taskList := Delete ( taskList , 1 ) ;
19407: LD_ADDR_VAR 0 7
19411: PUSH
19412: LD_VAR 0 6
19416: PPUSH
19417: LD_INT 1
19419: PPUSH
19420: CALL_OW 3
19424: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
19425: LD_VAR 0 3
19429: PPUSH
19430: LD_VAR 0 7
19434: PPUSH
19435: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
19439: LD_VAR 0 3
19443: PPUSH
19444: LD_VAR 0 6
19448: PUSH
19449: LD_VAR 0 4
19453: ARRAY
19454: PUSH
19455: LD_INT 2
19457: ARRAY
19458: PPUSH
19459: LD_VAR 0 6
19463: PUSH
19464: LD_VAR 0 4
19468: ARRAY
19469: PUSH
19470: LD_INT 3
19472: ARRAY
19473: PPUSH
19474: LD_INT 8
19476: PPUSH
19477: CALL 19494 0 4
// end ;
19481: GO 19384
19483: POP
19484: POP
// end ;
19485: GO 19342
19487: POP
19488: POP
// end ; end ;
19489: LD_VAR 0 2
19493: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
19494: LD_INT 0
19496: PPUSH
19497: PPUSH
19498: PPUSH
19499: PPUSH
19500: PPUSH
19501: PPUSH
19502: PPUSH
19503: PPUSH
19504: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
19505: LD_VAR 0 1
19509: NOT
19510: PUSH
19511: LD_VAR 0 2
19515: PPUSH
19516: LD_VAR 0 3
19520: PPUSH
19521: CALL_OW 488
19525: NOT
19526: OR
19527: PUSH
19528: LD_VAR 0 4
19532: NOT
19533: OR
19534: IFFALSE 19538
// exit ;
19536: GO 19878
// list := [ ] ;
19538: LD_ADDR_VAR 0 13
19542: PUSH
19543: EMPTY
19544: ST_TO_ADDR
// if x - r < 0 then
19545: LD_VAR 0 2
19549: PUSH
19550: LD_VAR 0 4
19554: MINUS
19555: PUSH
19556: LD_INT 0
19558: LESS
19559: IFFALSE 19571
// min_x := 0 else
19561: LD_ADDR_VAR 0 7
19565: PUSH
19566: LD_INT 0
19568: ST_TO_ADDR
19569: GO 19587
// min_x := x - r ;
19571: LD_ADDR_VAR 0 7
19575: PUSH
19576: LD_VAR 0 2
19580: PUSH
19581: LD_VAR 0 4
19585: MINUS
19586: ST_TO_ADDR
// if y - r < 0 then
19587: LD_VAR 0 3
19591: PUSH
19592: LD_VAR 0 4
19596: MINUS
19597: PUSH
19598: LD_INT 0
19600: LESS
19601: IFFALSE 19613
// min_y := 0 else
19603: LD_ADDR_VAR 0 8
19607: PUSH
19608: LD_INT 0
19610: ST_TO_ADDR
19611: GO 19629
// min_y := y - r ;
19613: LD_ADDR_VAR 0 8
19617: PUSH
19618: LD_VAR 0 3
19622: PUSH
19623: LD_VAR 0 4
19627: MINUS
19628: ST_TO_ADDR
// max_x := x + r ;
19629: LD_ADDR_VAR 0 9
19633: PUSH
19634: LD_VAR 0 2
19638: PUSH
19639: LD_VAR 0 4
19643: PLUS
19644: ST_TO_ADDR
// max_y := y + r ;
19645: LD_ADDR_VAR 0 10
19649: PUSH
19650: LD_VAR 0 3
19654: PUSH
19655: LD_VAR 0 4
19659: PLUS
19660: ST_TO_ADDR
// for _x = min_x to max_x do
19661: LD_ADDR_VAR 0 11
19665: PUSH
19666: DOUBLE
19667: LD_VAR 0 7
19671: DEC
19672: ST_TO_ADDR
19673: LD_VAR 0 9
19677: PUSH
19678: FOR_TO
19679: IFFALSE 19796
// for _y = min_y to max_y do
19681: LD_ADDR_VAR 0 12
19685: PUSH
19686: DOUBLE
19687: LD_VAR 0 8
19691: DEC
19692: ST_TO_ADDR
19693: LD_VAR 0 10
19697: PUSH
19698: FOR_TO
19699: IFFALSE 19792
// begin if not ValidHex ( _x , _y ) then
19701: LD_VAR 0 11
19705: PPUSH
19706: LD_VAR 0 12
19710: PPUSH
19711: CALL_OW 488
19715: NOT
19716: IFFALSE 19720
// continue ;
19718: GO 19698
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
19720: LD_VAR 0 11
19724: PPUSH
19725: LD_VAR 0 12
19729: PPUSH
19730: CALL_OW 351
19734: PUSH
19735: LD_VAR 0 11
19739: PPUSH
19740: LD_VAR 0 12
19744: PPUSH
19745: CALL_OW 554
19749: AND
19750: IFFALSE 19790
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
19752: LD_ADDR_VAR 0 13
19756: PUSH
19757: LD_VAR 0 13
19761: PPUSH
19762: LD_VAR 0 13
19766: PUSH
19767: LD_INT 1
19769: PLUS
19770: PPUSH
19771: LD_VAR 0 11
19775: PUSH
19776: LD_VAR 0 12
19780: PUSH
19781: EMPTY
19782: LIST
19783: LIST
19784: PPUSH
19785: CALL_OW 2
19789: ST_TO_ADDR
// end ;
19790: GO 19698
19792: POP
19793: POP
19794: GO 19678
19796: POP
19797: POP
// if not list then
19798: LD_VAR 0 13
19802: NOT
19803: IFFALSE 19807
// exit ;
19805: GO 19878
// for i in list do
19807: LD_ADDR_VAR 0 6
19811: PUSH
19812: LD_VAR 0 13
19816: PUSH
19817: FOR_IN
19818: IFFALSE 19876
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
19820: LD_VAR 0 1
19824: PPUSH
19825: LD_STRING M
19827: PUSH
19828: LD_VAR 0 6
19832: PUSH
19833: LD_INT 1
19835: ARRAY
19836: PUSH
19837: LD_VAR 0 6
19841: PUSH
19842: LD_INT 2
19844: ARRAY
19845: PUSH
19846: LD_INT 0
19848: PUSH
19849: LD_INT 0
19851: PUSH
19852: LD_INT 0
19854: PUSH
19855: LD_INT 0
19857: PUSH
19858: EMPTY
19859: LIST
19860: LIST
19861: LIST
19862: LIST
19863: LIST
19864: LIST
19865: LIST
19866: PUSH
19867: EMPTY
19868: LIST
19869: PPUSH
19870: CALL_OW 447
19874: GO 19817
19876: POP
19877: POP
// end ;
19878: LD_VAR 0 5
19882: RET
