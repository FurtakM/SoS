// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Init ;
  11: CALL 76 0 0
// PrepareNature ( 4 , 3 , 3 , 5 , 1 , 0 , 0 , natureArea , 0 ) ;
  15: LD_INT 4
  17: PPUSH
  18: LD_INT 3
  20: PPUSH
  21: LD_INT 3
  23: PPUSH
  24: LD_INT 5
  26: PPUSH
  27: LD_INT 1
  29: PPUSH
  30: LD_INT 0
  32: PPUSH
  33: LD_INT 0
  35: PPUSH
  36: LD_INT 6
  38: PPUSH
  39: LD_INT 0
  41: PPUSH
  42: CALL 1029 0 9
// PrepareAmerican ;
  46: CALL 5358 0 0
// PrepareAlliance ;
  50: CALL 226 0 0
// Action ;
  54: CALL 2194 0 0
// SaveForQuickRestart ;
  58: CALL_OW 22
// if debug then
  62: LD_EXP 1
  66: IFFALSE 75
// FogOff ( 7 ) ;
  68: LD_INT 7
  70: PPUSH
  71: CALL_OW 344
// end ;
  75: END
// export debug , activeBombTest , contaminateTime , bombExploded , enteredContaminatedArea , artifactPickedUp , planCaptured , seenBase , stevensTimer , canEnd , missionTime , killCounter , bunkerCounter ; function Init ; begin
  76: LD_INT 0
  78: PPUSH
// debug := false ;
  79: LD_ADDR_EXP 1
  83: PUSH
  84: LD_INT 0
  86: ST_TO_ADDR
// activeBombTest := false ;
  87: LD_ADDR_EXP 2
  91: PUSH
  92: LD_INT 0
  94: ST_TO_ADDR
// bombExploded := false ;
  95: LD_ADDR_EXP 4
  99: PUSH
 100: LD_INT 0
 102: ST_TO_ADDR
// contaminateTime := 0 0$00 ;
 103: LD_ADDR_EXP 3
 107: PUSH
 108: LD_INT 0
 110: ST_TO_ADDR
// enteredContaminatedArea := false ;
 111: LD_ADDR_EXP 5
 115: PUSH
 116: LD_INT 0
 118: ST_TO_ADDR
// artifactPickedUp := false ;
 119: LD_ADDR_EXP 6
 123: PUSH
 124: LD_INT 0
 126: ST_TO_ADDR
// planCaptured := false ;
 127: LD_ADDR_EXP 7
 131: PUSH
 132: LD_INT 0
 134: ST_TO_ADDR
// seenBase := false ;
 135: LD_ADDR_EXP 8
 139: PUSH
 140: LD_INT 0
 142: ST_TO_ADDR
// stevensTimer := [ 20 20$00 , 16 16$00 , 14 14$00 ] [ Difficulty ] ;
 143: LD_ADDR_EXP 9
 147: PUSH
 148: LD_INT 42000
 150: PUSH
 151: LD_INT 33600
 153: PUSH
 154: LD_INT 29400
 156: PUSH
 157: EMPTY
 158: LIST
 159: LIST
 160: LIST
 161: PUSH
 162: LD_OWVAR 67
 166: ARRAY
 167: ST_TO_ADDR
// canEnd := false ;
 168: LD_ADDR_EXP 10
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// missionTime := 0 0$00 ;
 176: LD_ADDR_EXP 11
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// killCounter := 0 ;
 184: LD_ADDR_EXP 12
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// bunkerCounter := 0 ;
 192: LD_ADDR_EXP 13
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// end ;
 200: LD_VAR 0 1
 204: RET
// every 0 0$1 trigger bunkerCounter >= 3 do
 205: LD_EXP 13
 209: PUSH
 210: LD_INT 3
 212: GREATEREQUAL
 213: IFFALSE 225
 215: GO 217
 217: DISABLE
// SetAchievement ( ACH_ONEMANARMY ) ; end_of_file
 218: LD_STRING ACH_ONEMANARMY
 220: PPUSH
 221: CALL_OW 543
 225: END
// export JMM , Burlak , Joan , RuSci ; export function PrepareAlliance ; var tmp , i , JMMVeh , BurlakVeh , VarJMMVeh , VarBurlakVeh ; begin
 226: LD_INT 0
 228: PPUSH
 229: PPUSH
 230: PPUSH
 231: PPUSH
 232: PPUSH
 233: PPUSH
 234: PPUSH
// uc_side := 7 ;
 235: LD_ADDR_OWVAR 20
 239: PUSH
 240: LD_INT 7
 242: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
 243: LD_ADDR_EXP 14
 247: PUSH
 248: LD_STRING JMM
 250: PPUSH
 251: LD_EXP 1
 255: NOT
 256: PPUSH
 257: LD_STRING 14a_
 259: PPUSH
 260: CALL 908 0 3
 264: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
 265: LD_ADDR_EXP 15
 269: PUSH
 270: LD_STRING Burlak
 272: PPUSH
 273: LD_EXP 1
 277: NOT
 278: PPUSH
 279: LD_STRING 14a_
 281: PPUSH
 282: CALL 908 0 3
 286: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
 287: LD_ADDR_EXP 16
 291: PUSH
 292: LD_STRING Joan
 294: PPUSH
 295: LD_EXP 1
 299: NOT
 300: PPUSH
 301: LD_STRING 13a_
 303: PPUSH
 304: CALL 908 0 3
 308: ST_TO_ADDR
// if not Joan then
 309: LD_EXP 16
 313: NOT
 314: IFFALSE 447
// begin tmp := CreateCharacterSet ( 13a_others ) ;
 316: LD_ADDR_VAR 0 2
 320: PUSH
 321: LD_STRING 13a_others
 323: PPUSH
 324: CALL_OW 31
 328: ST_TO_ADDR
// if tmp then
 329: LD_VAR 0 2
 333: IFFALSE 409
// begin for i in tmp do
 335: LD_ADDR_VAR 0 3
 339: PUSH
 340: LD_VAR 0 2
 344: PUSH
 345: FOR_IN
 346: IFFALSE 407
// if GetClass ( i ) = 4 and GetSex ( i ) = sex_male and GetNation ( i ) = nation_russian then
 348: LD_VAR 0 3
 352: PPUSH
 353: CALL_OW 257
 357: PUSH
 358: LD_INT 4
 360: EQUAL
 361: PUSH
 362: LD_VAR 0 3
 366: PPUSH
 367: CALL_OW 258
 371: PUSH
 372: LD_INT 1
 374: EQUAL
 375: AND
 376: PUSH
 377: LD_VAR 0 3
 381: PPUSH
 382: CALL_OW 248
 386: PUSH
 387: LD_INT 3
 389: EQUAL
 390: AND
 391: IFFALSE 405
// begin RuSci := i ;
 393: LD_ADDR_EXP 17
 397: PUSH
 398: LD_VAR 0 3
 402: ST_TO_ADDR
// break ;
 403: GO 407
// end ;
 405: GO 345
 407: POP
 408: POP
// end ; if not RuSci then
 409: LD_EXP 17
 413: NOT
 414: IFFALSE 447
// begin uc_nation := 3 ;
 416: LD_ADDR_OWVAR 21
 420: PUSH
 421: LD_INT 3
 423: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 10 ) ;
 424: LD_INT 1
 426: PPUSH
 427: LD_INT 4
 429: PPUSH
 430: LD_INT 10
 432: PPUSH
 433: CALL_OW 380
// RuSci := CreateHuman ;
 437: LD_ADDR_EXP 17
 441: PUSH
 442: CALL_OW 44
 446: ST_TO_ADDR
// end ; end ; VarJMMVeh := LoadVariable ( 14a_JMMVeh , [ us_morphling , engine_siberite , control_manual , us_rocket_launcher , 0 , 1 ] ) ;
 447: LD_ADDR_VAR 0 6
 451: PUSH
 452: LD_STRING 14a_JMMVeh
 454: PPUSH
 455: LD_INT 5
 457: PUSH
 458: LD_INT 3
 460: PUSH
 461: LD_INT 1
 463: PUSH
 464: LD_INT 7
 466: PUSH
 467: LD_INT 0
 469: PUSH
 470: LD_INT 1
 472: PUSH
 473: EMPTY
 474: LIST
 475: LIST
 476: LIST
 477: LIST
 478: LIST
 479: LIST
 480: PPUSH
 481: CALL_OW 30
 485: ST_TO_ADDR
// VarBurlakVeh := LoadVariable ( 14a_BurlakVeh , [ ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 0 , 3 ] ) ;
 486: LD_ADDR_VAR 0 7
 490: PUSH
 491: LD_STRING 14a_BurlakVeh
 493: PPUSH
 494: LD_INT 22
 496: PUSH
 497: LD_INT 3
 499: PUSH
 500: LD_INT 1
 502: PUSH
 503: LD_INT 51
 505: PUSH
 506: LD_INT 0
 508: PUSH
 509: LD_INT 3
 511: PUSH
 512: EMPTY
 513: LIST
 514: LIST
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: PPUSH
 520: CALL_OW 30
 524: ST_TO_ADDR
// uc_direction := 4 ;
 525: LD_ADDR_OWVAR 24
 529: PUSH
 530: LD_INT 4
 532: ST_TO_ADDR
// uc_nation := VarJMMVeh [ 6 ] ;
 533: LD_ADDR_OWVAR 21
 537: PUSH
 538: LD_VAR 0 6
 542: PUSH
 543: LD_INT 6
 545: ARRAY
 546: ST_TO_ADDR
// PrepareVehicle ( VarJMMVeh [ 1 ] , VarJMMVeh [ 2 ] , VarJMMVeh [ 3 ] , VarJMMVeh [ 4 ] , rand ( 60 , 80 ) ) ;
 547: LD_VAR 0 6
 551: PUSH
 552: LD_INT 1
 554: ARRAY
 555: PPUSH
 556: LD_VAR 0 6
 560: PUSH
 561: LD_INT 2
 563: ARRAY
 564: PPUSH
 565: LD_VAR 0 6
 569: PUSH
 570: LD_INT 3
 572: ARRAY
 573: PPUSH
 574: LD_VAR 0 6
 578: PUSH
 579: LD_INT 4
 581: ARRAY
 582: PPUSH
 583: LD_INT 60
 585: PPUSH
 586: LD_INT 80
 588: PPUSH
 589: CALL_OW 12
 593: PPUSH
 594: CALL 971 0 5
// JMMVeh := CreateVehicle ;
 598: LD_ADDR_VAR 0 4
 602: PUSH
 603: CALL_OW 45
 607: ST_TO_ADDR
// PlaceUnitInArea ( JMMVeh , startArea , false ) ;
 608: LD_VAR 0 4
 612: PPUSH
 613: LD_INT 1
 615: PPUSH
 616: LD_INT 0
 618: PPUSH
 619: CALL 1649 0 3
// if VarJMMVeh [ 5 ] <> 0 then
 623: LD_VAR 0 6
 627: PUSH
 628: LD_INT 5
 630: ARRAY
 631: PUSH
 632: LD_INT 0
 634: NONEQUAL
 635: IFFALSE 655
// SetMark ( JMMVeh , VarJMMVeh [ 5 ] ) ;
 637: LD_VAR 0 4
 641: PPUSH
 642: LD_VAR 0 6
 646: PUSH
 647: LD_INT 5
 649: ARRAY
 650: PPUSH
 651: CALL_OW 242
// PlaceHumanInUnit ( JMM , JMMVeh ) ;
 655: LD_EXP 14
 659: PPUSH
 660: LD_VAR 0 4
 664: PPUSH
 665: CALL_OW 52
// uc_nation := VarBurlakVeh [ 6 ] ;
 669: LD_ADDR_OWVAR 21
 673: PUSH
 674: LD_VAR 0 7
 678: PUSH
 679: LD_INT 6
 681: ARRAY
 682: ST_TO_ADDR
// PrepareVehicle ( VarBurlakVeh [ 1 ] , VarBurlakVeh [ 2 ] , VarBurlakVeh [ 3 ] , VarBurlakVeh [ 4 ] , rand ( 60 , 80 ) ) ;
 683: LD_VAR 0 7
 687: PUSH
 688: LD_INT 1
 690: ARRAY
 691: PPUSH
 692: LD_VAR 0 7
 696: PUSH
 697: LD_INT 2
 699: ARRAY
 700: PPUSH
 701: LD_VAR 0 7
 705: PUSH
 706: LD_INT 3
 708: ARRAY
 709: PPUSH
 710: LD_VAR 0 7
 714: PUSH
 715: LD_INT 4
 717: ARRAY
 718: PPUSH
 719: LD_INT 60
 721: PPUSH
 722: LD_INT 80
 724: PPUSH
 725: CALL_OW 12
 729: PPUSH
 730: CALL 971 0 5
// BurlakVeh := CreateVehicle ;
 734: LD_ADDR_VAR 0 5
 738: PUSH
 739: CALL_OW 45
 743: ST_TO_ADDR
// if not PlaceUnitInArea ( BurlakVeh , startArea , false ) then
 744: LD_VAR 0 5
 748: PPUSH
 749: LD_INT 1
 751: PPUSH
 752: LD_INT 0
 754: PPUSH
 755: CALL 1649 0 3
 759: NOT
 760: IFFALSE 780
// PlaceUnitXY ( BurlakVeh , 233 , 85 , false ) ;
 762: LD_VAR 0 5
 766: PPUSH
 767: LD_INT 233
 769: PPUSH
 770: LD_INT 85
 772: PPUSH
 773: LD_INT 0
 775: PPUSH
 776: CALL_OW 48
// if VarBurlakVeh [ 5 ] <> 0 then
 780: LD_VAR 0 7
 784: PUSH
 785: LD_INT 5
 787: ARRAY
 788: PUSH
 789: LD_INT 0
 791: NONEQUAL
 792: IFFALSE 812
// SetMark ( BurlakVeh , VarBurlakVeh [ 5 ] ) ;
 794: LD_VAR 0 5
 798: PPUSH
 799: LD_VAR 0 7
 803: PUSH
 804: LD_INT 5
 806: ARRAY
 807: PPUSH
 808: CALL_OW 242
// PlaceHumanInUnit ( Burlak , BurlakVeh ) ;
 812: LD_EXP 15
 816: PPUSH
 817: LD_VAR 0 5
 821: PPUSH
 822: CALL_OW 52
// tmp := [ [ 178 , 91 ] , [ 137 , 83 ] , [ 157 , 75 ] ] [ Difficulty ] ;
 826: LD_ADDR_VAR 0 2
 830: PUSH
 831: LD_INT 178
 833: PUSH
 834: LD_INT 91
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: PUSH
 841: LD_INT 137
 843: PUSH
 844: LD_INT 83
 846: PUSH
 847: EMPTY
 848: LIST
 849: LIST
 850: PUSH
 851: LD_INT 157
 853: PUSH
 854: LD_INT 75
 856: PUSH
 857: EMPTY
 858: LIST
 859: LIST
 860: PUSH
 861: EMPTY
 862: LIST
 863: LIST
 864: LIST
 865: PUSH
 866: LD_OWVAR 67
 870: ARRAY
 871: ST_TO_ADDR
// CreateResourcesXY ( mat_artifact , 4 , tmp [ 1 ] , tmp [ 2 ] , false ) ;
 872: LD_INT 4
 874: PPUSH
 875: LD_INT 4
 877: PPUSH
 878: LD_VAR 0 2
 882: PUSH
 883: LD_INT 1
 885: ARRAY
 886: PPUSH
 887: LD_VAR 0 2
 891: PUSH
 892: LD_INT 2
 894: ARRAY
 895: PPUSH
 896: LD_INT 0
 898: PPUSH
 899: CALL_OW 58
// end ; end_of_file
 903: LD_VAR 0 1
 907: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 908: LD_INT 0
 910: PPUSH
 911: PPUSH
// if exist_mode then
 912: LD_VAR 0 2
 916: IFFALSE 941
// unit := CreateCharacter ( prefix & ident ) else
 918: LD_ADDR_VAR 0 5
 922: PUSH
 923: LD_VAR 0 3
 927: PUSH
 928: LD_VAR 0 1
 932: STR
 933: PPUSH
 934: CALL_OW 34
 938: ST_TO_ADDR
 939: GO 956
// unit := NewCharacter ( ident ) ;
 941: LD_ADDR_VAR 0 5
 945: PUSH
 946: LD_VAR 0 1
 950: PPUSH
 951: CALL_OW 25
 955: ST_TO_ADDR
// result := unit ;
 956: LD_ADDR_VAR 0 4
 960: PUSH
 961: LD_VAR 0 5
 965: ST_TO_ADDR
// end ;
 966: LD_VAR 0 4
 970: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
 971: LD_INT 0
 973: PPUSH
// vc_chassis := chassis ;
 974: LD_ADDR_OWVAR 37
 978: PUSH
 979: LD_VAR 0 1
 983: ST_TO_ADDR
// vc_engine := engine ;
 984: LD_ADDR_OWVAR 39
 988: PUSH
 989: LD_VAR 0 2
 993: ST_TO_ADDR
// vc_control := control ;
 994: LD_ADDR_OWVAR 38
 998: PUSH
 999: LD_VAR 0 3
1003: ST_TO_ADDR
// vc_weapon := weapon ;
1004: LD_ADDR_OWVAR 40
1008: PUSH
1009: LD_VAR 0 4
1013: ST_TO_ADDR
// vc_fuel_battery := fuel ;
1014: LD_ADDR_OWVAR 41
1018: PUSH
1019: LD_VAR 0 5
1023: ST_TO_ADDR
// end ;
1024: LD_VAR 0 6
1028: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
1029: LD_INT 0
1031: PPUSH
1032: PPUSH
1033: PPUSH
// uc_side = 0 ;
1034: LD_ADDR_OWVAR 20
1038: PUSH
1039: LD_INT 0
1041: ST_TO_ADDR
// uc_nation = 0 ;
1042: LD_ADDR_OWVAR 21
1046: PUSH
1047: LD_INT 0
1049: ST_TO_ADDR
// InitHc ;
1050: CALL_OW 19
// InitVc ;
1054: CALL_OW 20
// hc_importance := 0 ;
1058: LD_ADDR_OWVAR 32
1062: PUSH
1063: LD_INT 0
1065: ST_TO_ADDR
// hc_name :=  ;
1066: LD_ADDR_OWVAR 26
1070: PUSH
1071: LD_STRING 
1073: ST_TO_ADDR
// if mastodonts then
1074: LD_VAR 0 6
1078: IFFALSE 1145
// for i = 1 to mastodonts do
1080: LD_ADDR_VAR 0 11
1084: PUSH
1085: DOUBLE
1086: LD_INT 1
1088: DEC
1089: ST_TO_ADDR
1090: LD_VAR 0 6
1094: PUSH
1095: FOR_TO
1096: IFFALSE 1143
// begin vc_chassis := 31 ;
1098: LD_ADDR_OWVAR 37
1102: PUSH
1103: LD_INT 31
1105: ST_TO_ADDR
// vc_control := control_rider ;
1106: LD_ADDR_OWVAR 38
1110: PUSH
1111: LD_INT 4
1113: ST_TO_ADDR
// animal := CreateVehicle ;
1114: LD_ADDR_VAR 0 12
1118: PUSH
1119: CALL_OW 45
1123: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1124: LD_VAR 0 12
1128: PPUSH
1129: LD_VAR 0 8
1133: PPUSH
1134: LD_INT 0
1136: PPUSH
1137: CALL 1649 0 3
// end ;
1141: GO 1095
1143: POP
1144: POP
// if horses then
1145: LD_VAR 0 5
1149: IFFALSE 1216
// for i = 1 to horses do
1151: LD_ADDR_VAR 0 11
1155: PUSH
1156: DOUBLE
1157: LD_INT 1
1159: DEC
1160: ST_TO_ADDR
1161: LD_VAR 0 5
1165: PUSH
1166: FOR_TO
1167: IFFALSE 1214
// begin hc_class := 21 ;
1169: LD_ADDR_OWVAR 28
1173: PUSH
1174: LD_INT 21
1176: ST_TO_ADDR
// hc_gallery :=  ;
1177: LD_ADDR_OWVAR 33
1181: PUSH
1182: LD_STRING 
1184: ST_TO_ADDR
// animal := CreateHuman ;
1185: LD_ADDR_VAR 0 12
1189: PUSH
1190: CALL_OW 44
1194: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1195: LD_VAR 0 12
1199: PPUSH
1200: LD_VAR 0 8
1204: PPUSH
1205: LD_INT 0
1207: PPUSH
1208: CALL 1649 0 3
// end ;
1212: GO 1166
1214: POP
1215: POP
// if birds then
1216: LD_VAR 0 1
1220: IFFALSE 1287
// for i = 1 to birds do
1222: LD_ADDR_VAR 0 11
1226: PUSH
1227: DOUBLE
1228: LD_INT 1
1230: DEC
1231: ST_TO_ADDR
1232: LD_VAR 0 1
1236: PUSH
1237: FOR_TO
1238: IFFALSE 1285
// begin hc_class = 18 ;
1240: LD_ADDR_OWVAR 28
1244: PUSH
1245: LD_INT 18
1247: ST_TO_ADDR
// hc_gallery =  ;
1248: LD_ADDR_OWVAR 33
1252: PUSH
1253: LD_STRING 
1255: ST_TO_ADDR
// animal := CreateHuman ;
1256: LD_ADDR_VAR 0 12
1260: PUSH
1261: CALL_OW 44
1265: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1266: LD_VAR 0 12
1270: PPUSH
1271: LD_VAR 0 8
1275: PPUSH
1276: LD_INT 0
1278: PPUSH
1279: CALL 1649 0 3
// end ;
1283: GO 1237
1285: POP
1286: POP
// if tigers then
1287: LD_VAR 0 2
1291: IFFALSE 1375
// for i = 1 to tigers do
1293: LD_ADDR_VAR 0 11
1297: PUSH
1298: DOUBLE
1299: LD_INT 1
1301: DEC
1302: ST_TO_ADDR
1303: LD_VAR 0 2
1307: PUSH
1308: FOR_TO
1309: IFFALSE 1373
// begin hc_class = class_tiger ;
1311: LD_ADDR_OWVAR 28
1315: PUSH
1316: LD_INT 14
1318: ST_TO_ADDR
// hc_gallery =  ;
1319: LD_ADDR_OWVAR 33
1323: PUSH
1324: LD_STRING 
1326: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
1327: LD_ADDR_OWVAR 35
1331: PUSH
1332: LD_INT 7
1334: NEG
1335: PPUSH
1336: LD_INT 7
1338: PPUSH
1339: CALL_OW 12
1343: ST_TO_ADDR
// animal := CreateHuman ;
1344: LD_ADDR_VAR 0 12
1348: PUSH
1349: CALL_OW 44
1353: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1354: LD_VAR 0 12
1358: PPUSH
1359: LD_VAR 0 8
1363: PPUSH
1364: LD_INT 0
1366: PPUSH
1367: CALL 1649 0 3
// end ;
1371: GO 1308
1373: POP
1374: POP
// if apemans then
1375: LD_VAR 0 3
1379: IFFALSE 1502
// for i = 1 to apemans do
1381: LD_ADDR_VAR 0 11
1385: PUSH
1386: DOUBLE
1387: LD_INT 1
1389: DEC
1390: ST_TO_ADDR
1391: LD_VAR 0 3
1395: PUSH
1396: FOR_TO
1397: IFFALSE 1500
// begin hc_class = class_apeman ;
1399: LD_ADDR_OWVAR 28
1403: PUSH
1404: LD_INT 12
1406: ST_TO_ADDR
// hc_gallery =  ;
1407: LD_ADDR_OWVAR 33
1411: PUSH
1412: LD_STRING 
1414: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
1415: LD_ADDR_OWVAR 35
1419: PUSH
1420: LD_INT 5
1422: NEG
1423: PPUSH
1424: LD_INT 5
1426: PPUSH
1427: CALL_OW 12
1431: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
1432: LD_ADDR_OWVAR 31
1436: PUSH
1437: LD_INT 1
1439: PPUSH
1440: LD_INT 3
1442: PPUSH
1443: CALL_OW 12
1447: PUSH
1448: LD_INT 1
1450: PPUSH
1451: LD_INT 3
1453: PPUSH
1454: CALL_OW 12
1458: PUSH
1459: LD_INT 0
1461: PUSH
1462: LD_INT 0
1464: PUSH
1465: EMPTY
1466: LIST
1467: LIST
1468: LIST
1469: LIST
1470: ST_TO_ADDR
// animal := CreateHuman ;
1471: LD_ADDR_VAR 0 12
1475: PUSH
1476: CALL_OW 44
1480: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1481: LD_VAR 0 12
1485: PPUSH
1486: LD_VAR 0 8
1490: PPUSH
1491: LD_INT 0
1493: PPUSH
1494: CALL 1649 0 3
// end ;
1498: GO 1396
1500: POP
1501: POP
// if enchidnas then
1502: LD_VAR 0 4
1506: IFFALSE 1573
// for i = 1 to enchidnas do
1508: LD_ADDR_VAR 0 11
1512: PUSH
1513: DOUBLE
1514: LD_INT 1
1516: DEC
1517: ST_TO_ADDR
1518: LD_VAR 0 4
1522: PUSH
1523: FOR_TO
1524: IFFALSE 1571
// begin hc_class = 13 ;
1526: LD_ADDR_OWVAR 28
1530: PUSH
1531: LD_INT 13
1533: ST_TO_ADDR
// hc_gallery =  ;
1534: LD_ADDR_OWVAR 33
1538: PUSH
1539: LD_STRING 
1541: ST_TO_ADDR
// animal := CreateHuman ;
1542: LD_ADDR_VAR 0 12
1546: PUSH
1547: CALL_OW 44
1551: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1552: LD_VAR 0 12
1556: PPUSH
1557: LD_VAR 0 8
1561: PPUSH
1562: LD_INT 0
1564: PPUSH
1565: CALL 1649 0 3
// end ;
1569: GO 1523
1571: POP
1572: POP
// if fishes then
1573: LD_VAR 0 7
1577: IFFALSE 1644
// for i = 1 to fishes do
1579: LD_ADDR_VAR 0 11
1583: PUSH
1584: DOUBLE
1585: LD_INT 1
1587: DEC
1588: ST_TO_ADDR
1589: LD_VAR 0 7
1593: PUSH
1594: FOR_TO
1595: IFFALSE 1642
// begin hc_class = 20 ;
1597: LD_ADDR_OWVAR 28
1601: PUSH
1602: LD_INT 20
1604: ST_TO_ADDR
// hc_gallery =  ;
1605: LD_ADDR_OWVAR 33
1609: PUSH
1610: LD_STRING 
1612: ST_TO_ADDR
// animal := CreateHuman ;
1613: LD_ADDR_VAR 0 12
1617: PUSH
1618: CALL_OW 44
1622: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
1623: LD_VAR 0 12
1627: PPUSH
1628: LD_VAR 0 9
1632: PPUSH
1633: LD_INT 0
1635: PPUSH
1636: CALL 1649 0 3
// end ;
1640: GO 1594
1642: POP
1643: POP
// end ;
1644: LD_VAR 0 10
1648: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
1649: LD_INT 0
1651: PPUSH
1652: PPUSH
1653: PPUSH
1654: PPUSH
// if not unit or not area then
1655: LD_VAR 0 1
1659: NOT
1660: PUSH
1661: LD_VAR 0 2
1665: NOT
1666: OR
1667: IFFALSE 1671
// exit ;
1669: GO 1835
// tmp := AreaToList ( area , i ) ;
1671: LD_ADDR_VAR 0 6
1675: PUSH
1676: LD_VAR 0 2
1680: PPUSH
1681: LD_VAR 0 5
1685: PPUSH
1686: CALL_OW 517
1690: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
1691: LD_ADDR_VAR 0 5
1695: PUSH
1696: DOUBLE
1697: LD_INT 1
1699: DEC
1700: ST_TO_ADDR
1701: LD_VAR 0 6
1705: PUSH
1706: LD_INT 1
1708: ARRAY
1709: PUSH
1710: FOR_TO
1711: IFFALSE 1833
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
1713: LD_ADDR_VAR 0 7
1717: PUSH
1718: LD_VAR 0 6
1722: PUSH
1723: LD_INT 1
1725: ARRAY
1726: PUSH
1727: LD_VAR 0 5
1731: ARRAY
1732: PUSH
1733: LD_VAR 0 6
1737: PUSH
1738: LD_INT 2
1740: ARRAY
1741: PUSH
1742: LD_VAR 0 5
1746: ARRAY
1747: PUSH
1748: EMPTY
1749: LIST
1750: LIST
1751: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
1752: LD_VAR 0 7
1756: PUSH
1757: LD_INT 1
1759: ARRAY
1760: PPUSH
1761: LD_VAR 0 7
1765: PUSH
1766: LD_INT 2
1768: ARRAY
1769: PPUSH
1770: CALL_OW 428
1774: PUSH
1775: LD_INT 0
1777: EQUAL
1778: IFFALSE 1831
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
1780: LD_VAR 0 1
1784: PPUSH
1785: LD_VAR 0 7
1789: PUSH
1790: LD_INT 1
1792: ARRAY
1793: PPUSH
1794: LD_VAR 0 7
1798: PUSH
1799: LD_INT 2
1801: ARRAY
1802: PPUSH
1803: LD_VAR 0 3
1807: PPUSH
1808: CALL_OW 48
// result := IsPlaced ( unit ) ;
1812: LD_ADDR_VAR 0 4
1816: PUSH
1817: LD_VAR 0 1
1821: PPUSH
1822: CALL_OW 305
1826: ST_TO_ADDR
// exit ;
1827: POP
1828: POP
1829: GO 1835
// end ; end ;
1831: GO 1710
1833: POP
1834: POP
// end ;
1835: LD_VAR 0 4
1839: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
1840: LD_INT 0
1842: PPUSH
1843: PPUSH
1844: PPUSH
1845: PPUSH
1846: PPUSH
1847: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
1848: LD_VAR 0 1
1852: NOT
1853: PUSH
1854: LD_VAR 0 1
1858: PPUSH
1859: CALL_OW 263
1863: PUSH
1864: LD_INT 2
1866: EQUAL
1867: NOT
1868: OR
1869: IFFALSE 1873
// exit ;
1871: GO 2189
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
1873: LD_ADDR_VAR 0 6
1877: PUSH
1878: LD_INT 22
1880: PUSH
1881: LD_VAR 0 1
1885: PPUSH
1886: CALL_OW 255
1890: PUSH
1891: EMPTY
1892: LIST
1893: LIST
1894: PUSH
1895: LD_INT 2
1897: PUSH
1898: LD_INT 30
1900: PUSH
1901: LD_INT 36
1903: PUSH
1904: EMPTY
1905: LIST
1906: LIST
1907: PUSH
1908: LD_INT 34
1910: PUSH
1911: LD_INT 31
1913: PUSH
1914: EMPTY
1915: LIST
1916: LIST
1917: PUSH
1918: EMPTY
1919: LIST
1920: LIST
1921: LIST
1922: PUSH
1923: EMPTY
1924: LIST
1925: LIST
1926: PPUSH
1927: CALL_OW 69
1931: ST_TO_ADDR
// if not tmp then
1932: LD_VAR 0 6
1936: NOT
1937: IFFALSE 1941
// exit ;
1939: GO 2189
// result := [ ] ;
1941: LD_ADDR_VAR 0 2
1945: PUSH
1946: EMPTY
1947: ST_TO_ADDR
// for i in tmp do
1948: LD_ADDR_VAR 0 3
1952: PUSH
1953: LD_VAR 0 6
1957: PUSH
1958: FOR_IN
1959: IFFALSE 2030
// begin t := UnitsInside ( i ) ;
1961: LD_ADDR_VAR 0 4
1965: PUSH
1966: LD_VAR 0 3
1970: PPUSH
1971: CALL_OW 313
1975: ST_TO_ADDR
// if t then
1976: LD_VAR 0 4
1980: IFFALSE 2028
// for j in t do
1982: LD_ADDR_VAR 0 7
1986: PUSH
1987: LD_VAR 0 4
1991: PUSH
1992: FOR_IN
1993: IFFALSE 2026
// result := Insert ( result , result + 1 , j ) ;
1995: LD_ADDR_VAR 0 2
1999: PUSH
2000: LD_VAR 0 2
2004: PPUSH
2005: LD_VAR 0 2
2009: PUSH
2010: LD_INT 1
2012: PLUS
2013: PPUSH
2014: LD_VAR 0 7
2018: PPUSH
2019: CALL_OW 2
2023: ST_TO_ADDR
2024: GO 1992
2026: POP
2027: POP
// end ;
2028: GO 1958
2030: POP
2031: POP
// if not result then
2032: LD_VAR 0 2
2036: NOT
2037: IFFALSE 2041
// exit ;
2039: GO 2189
// mech := result [ 1 ] ;
2041: LD_ADDR_VAR 0 5
2045: PUSH
2046: LD_VAR 0 2
2050: PUSH
2051: LD_INT 1
2053: ARRAY
2054: ST_TO_ADDR
// if result > 1 then
2055: LD_VAR 0 2
2059: PUSH
2060: LD_INT 1
2062: GREATER
2063: IFFALSE 2175
// for i = 2 to result do
2065: LD_ADDR_VAR 0 3
2069: PUSH
2070: DOUBLE
2071: LD_INT 2
2073: DEC
2074: ST_TO_ADDR
2075: LD_VAR 0 2
2079: PUSH
2080: FOR_TO
2081: IFFALSE 2173
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
2083: LD_ADDR_VAR 0 4
2087: PUSH
2088: LD_VAR 0 2
2092: PUSH
2093: LD_VAR 0 3
2097: ARRAY
2098: PPUSH
2099: LD_INT 3
2101: PPUSH
2102: CALL_OW 259
2106: PUSH
2107: LD_VAR 0 2
2111: PUSH
2112: LD_VAR 0 3
2116: ARRAY
2117: PPUSH
2118: CALL_OW 432
2122: MINUS
2123: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
2124: LD_VAR 0 4
2128: PUSH
2129: LD_VAR 0 5
2133: PPUSH
2134: LD_INT 3
2136: PPUSH
2137: CALL_OW 259
2141: PUSH
2142: LD_VAR 0 5
2146: PPUSH
2147: CALL_OW 432
2151: MINUS
2152: GREATEREQUAL
2153: IFFALSE 2171
// mech := result [ i ] ;
2155: LD_ADDR_VAR 0 5
2159: PUSH
2160: LD_VAR 0 2
2164: PUSH
2165: LD_VAR 0 3
2169: ARRAY
2170: ST_TO_ADDR
// end ;
2171: GO 2080
2173: POP
2174: POP
// ComLinkTo ( vehicle , mech ) ;
2175: LD_VAR 0 1
2179: PPUSH
2180: LD_VAR 0 5
2184: PPUSH
2185: CALL_OW 135
// end ; end_of_file
2189: LD_VAR 0 2
2193: RET
// export function Action ; begin
2194: LD_INT 0
2196: PPUSH
// InGameOn ;
2197: CALL_OW 8
// CenterNowOnXY ( 221 , 80 ) ;
2201: LD_INT 221
2203: PPUSH
2204: LD_INT 80
2206: PPUSH
2207: CALL_OW 86
// ComMoveXY ( [ JMM , Burlak ] , 217 , 79 ) ;
2211: LD_EXP 14
2215: PUSH
2216: LD_EXP 15
2220: PUSH
2221: EMPTY
2222: LIST
2223: LIST
2224: PPUSH
2225: LD_INT 217
2227: PPUSH
2228: LD_INT 79
2230: PPUSH
2231: CALL_OW 111
// wait ( 0 0$7 ) ;
2235: LD_INT 245
2237: PPUSH
2238: CALL_OW 67
// ComExitVehicle ( [ JMM , Burlak ] ) ;
2242: LD_EXP 14
2246: PUSH
2247: LD_EXP 15
2251: PUSH
2252: EMPTY
2253: LIST
2254: LIST
2255: PPUSH
2256: CALL_OW 121
// Say ( Burlak , D2-Bur-1 ) ;
2260: LD_EXP 15
2264: PPUSH
2265: LD_STRING D2-Bur-1
2267: PPUSH
2268: CALL_OW 88
// Say ( JMM , D2-JMM-1 ) ;
2272: LD_EXP 14
2276: PPUSH
2277: LD_STRING D2-JMM-1
2279: PPUSH
2280: CALL_OW 88
// wait ( 0 0$0.5 ) ;
2284: LD_INT 18
2286: PPUSH
2287: CALL_OW 67
// ComTurnUnit ( Burlak , JMM ) ;
2291: LD_EXP 15
2295: PPUSH
2296: LD_EXP 14
2300: PPUSH
2301: CALL_OW 119
// Say ( Burlak , D2-Bur-2 ) ;
2305: LD_EXP 15
2309: PPUSH
2310: LD_STRING D2-Bur-2
2312: PPUSH
2313: CALL_OW 88
// ComEnterUnit ( Burlak , NearestUnitToUnit ( FilterAllUnits ( [ f_type , unit_vehicle ] ) , Burlak ) ) ;
2317: LD_EXP 15
2321: PPUSH
2322: LD_INT 21
2324: PUSH
2325: LD_INT 2
2327: PUSH
2328: EMPTY
2329: LIST
2330: LIST
2331: PPUSH
2332: CALL_OW 69
2336: PPUSH
2337: LD_EXP 15
2341: PPUSH
2342: CALL_OW 74
2346: PPUSH
2347: CALL_OW 120
// ComEnterUnit ( JMM , NearestUnitToUnit ( FilterAllUnits ( [ f_type , unit_vehicle ] ) , JMM ) ) ;
2351: LD_EXP 14
2355: PPUSH
2356: LD_INT 21
2358: PUSH
2359: LD_INT 2
2361: PUSH
2362: EMPTY
2363: LIST
2364: LIST
2365: PPUSH
2366: CALL_OW 69
2370: PPUSH
2371: LD_EXP 14
2375: PPUSH
2376: CALL_OW 74
2380: PPUSH
2381: CALL_OW 120
// wait ( 0 0$1 ) ;
2385: LD_INT 35
2387: PPUSH
2388: CALL_OW 67
// InGameOff ;
2392: CALL_OW 9
// ChangeMissionObjectives ( MArtPickup ) ;
2396: LD_STRING MArtPickup
2398: PPUSH
2399: CALL_OW 337
// end ;
2403: LD_VAR 0 1
2407: RET
// every 0 0$1 trigger UnitFilter ( guards , [ f_see , 7 ] ) and not seenBase do
2408: LD_EXP 22
2412: PPUSH
2413: LD_INT 101
2415: PUSH
2416: LD_INT 7
2418: PUSH
2419: EMPTY
2420: LIST
2421: LIST
2422: PPUSH
2423: CALL_OW 72
2427: PUSH
2428: LD_EXP 8
2432: NOT
2433: AND
2434: IFFALSE 2463
2436: GO 2438
2438: DISABLE
// begin Say ( Burlak , D3-Bur-1 ) ;
2439: LD_EXP 15
2443: PPUSH
2444: LD_STRING D3-Bur-1
2446: PPUSH
2447: CALL_OW 88
// Say ( JMM , D3-JMM-1 ) ;
2451: LD_EXP 14
2455: PPUSH
2456: LD_STRING D3-JMM-1
2458: PPUSH
2459: CALL_OW 88
// end ;
2463: END
// every 0 0$2 trigger FilterUnitsInArea ( usTestBase , [ f_side , 7 ] ) do
2464: LD_INT 5
2466: PPUSH
2467: LD_INT 22
2469: PUSH
2470: LD_INT 7
2472: PUSH
2473: EMPTY
2474: LIST
2475: LIST
2476: PPUSH
2477: CALL_OW 70
2481: IFFALSE 2812
2483: GO 2485
2485: DISABLE
// begin wait ( 0 0$3 ) ;
2486: LD_INT 105
2488: PPUSH
2489: CALL_OW 67
// PlaceSeeing ( 139 , 43 , 7 , - 20 ) ;
2493: LD_INT 139
2495: PPUSH
2496: LD_INT 43
2498: PPUSH
2499: LD_INT 7
2501: PPUSH
2502: LD_INT 20
2504: NEG
2505: PPUSH
2506: CALL_OW 330
// RemoveSeeing ( 139 , 43 , 7 ) ;
2510: LD_INT 139
2512: PPUSH
2513: LD_INT 43
2515: PPUSH
2516: LD_INT 7
2518: PPUSH
2519: CALL_OW 331
// DialogueOn ;
2523: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
2527: LD_EXP 14
2531: PPUSH
2532: CALL_OW 87
// Say ( JMM , D3a-JMM-1 ) ;
2536: LD_EXP 14
2540: PPUSH
2541: LD_STRING D3a-JMM-1
2543: PPUSH
2544: CALL_OW 88
// Say ( Burlak , D3a-Bur-1 ) ;
2548: LD_EXP 15
2552: PPUSH
2553: LD_STRING D3a-Bur-1
2555: PPUSH
2556: CALL_OW 88
// Say ( JMM , D3a-JMM-2 ) ;
2560: LD_EXP 14
2564: PPUSH
2565: LD_STRING D3a-JMM-2
2567: PPUSH
2568: CALL_OW 88
// if Joan then
2572: LD_EXP 16
2576: IFFALSE 2592
// SayRadio ( Joan , D3a-Joan-2 ) else
2578: LD_EXP 16
2582: PPUSH
2583: LD_STRING D3a-Joan-2
2585: PPUSH
2586: CALL_OW 94
2590: GO 2604
// SayRadio ( RuSci , D3a-RSci1-2 ) ;
2592: LD_EXP 17
2596: PPUSH
2597: LD_STRING D3a-RSci1-2
2599: PPUSH
2600: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-2 ) ;
2604: LD_EXP 18
2608: PPUSH
2609: LD_STRING D3a-Huck-2
2611: PPUSH
2612: CALL_OW 94
// SayRadio ( Powell , D3a-Pow-2 ) ;
2616: LD_EXP 19
2620: PPUSH
2621: LD_STRING D3a-Pow-2
2623: PPUSH
2624: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-3 ) ;
2628: LD_EXP 18
2632: PPUSH
2633: LD_STRING D3a-Huck-3
2635: PPUSH
2636: CALL_OW 94
// SayRadio ( Powell , D3a-Pow-3 ) ;
2640: LD_EXP 19
2644: PPUSH
2645: LD_STRING D3a-Pow-3
2647: PPUSH
2648: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-4 ) ;
2652: LD_EXP 18
2656: PPUSH
2657: LD_STRING D3a-Huck-4
2659: PPUSH
2660: CALL_OW 94
// Say ( JMM , D3a-JMM-4 ) ;
2664: LD_EXP 14
2668: PPUSH
2669: LD_STRING D3a-JMM-4
2671: PPUSH
2672: CALL_OW 88
// Say ( Burlak , D3a-Bur-4 ) ;
2676: LD_EXP 15
2680: PPUSH
2681: LD_STRING D3a-Bur-4
2683: PPUSH
2684: CALL_OW 88
// if Joan then
2688: LD_EXP 16
2692: IFFALSE 2708
// SayRadio ( Joan , D3a-Joan-4 ) else
2694: LD_EXP 16
2698: PPUSH
2699: LD_STRING D3a-Joan-4
2701: PPUSH
2702: CALL_OW 94
2706: GO 2720
// SayRadio ( RuSci , D3a-RSci1-4 ) ;
2708: LD_EXP 17
2712: PPUSH
2713: LD_STRING D3a-RSci1-4
2715: PPUSH
2716: CALL_OW 94
// CenterNowOnXY ( 133 , 43 ) ;
2720: LD_INT 133
2722: PPUSH
2723: LD_INT 43
2725: PPUSH
2726: CALL_OW 86
// dwait ( 0 0$0.3 ) ;
2730: LD_INT 10
2732: PPUSH
2733: CALL_OW 68
// Say ( JMM , D3a-JMM-5 ) ;
2737: LD_EXP 14
2741: PPUSH
2742: LD_STRING D3a-JMM-5
2744: PPUSH
2745: CALL_OW 88
// Say ( Burlak , D3a-Bur-5 ) ;
2749: LD_EXP 15
2753: PPUSH
2754: LD_STRING D3a-Bur-5
2756: PPUSH
2757: CALL_OW 88
// DialogueOff ;
2761: CALL_OW 7
// seenBase := true ;
2765: LD_ADDR_EXP 8
2769: PUSH
2770: LD_INT 1
2772: ST_TO_ADDR
// wait ( [ 0 0$15 , 0 0$12 , 0 0$9 ] [ Difficulty ] ) ;
2773: LD_INT 525
2775: PUSH
2776: LD_INT 420
2778: PUSH
2779: LD_INT 315
2781: PUSH
2782: EMPTY
2783: LIST
2784: LIST
2785: LIST
2786: PUSH
2787: LD_OWVAR 67
2791: ARRAY
2792: PPUSH
2793: CALL_OW 67
// ComAttackPlace ( sibBomb , 142 , 52 ) ;
2797: LD_EXP 21
2801: PPUSH
2802: LD_INT 142
2804: PPUSH
2805: LD_INT 52
2807: PPUSH
2808: CALL_OW 116
// end ;
2812: END
// every 5 5$00 trigger not seenBase and not bombExploded do
2813: LD_EXP 8
2817: NOT
2818: PUSH
2819: LD_EXP 4
2823: NOT
2824: AND
2825: IFFALSE 2845
2827: GO 2829
2829: DISABLE
// ComAttackPlace ( sibBomb , 142 , 52 ) ;
2830: LD_EXP 21
2834: PPUSH
2835: LD_INT 142
2837: PPUSH
2838: LD_INT 52
2840: PPUSH
2841: CALL_OW 116
2845: END
// export function OnBombExploded ( bomb , x , y ) ; var art ; begin
2846: LD_INT 0
2848: PPUSH
2849: PPUSH
// contaminateTime := tick ;
2850: LD_ADDR_EXP 3
2854: PUSH
2855: LD_OWVAR 1
2859: ST_TO_ADDR
// wait ( 0 0$5 ) ;
2860: LD_INT 175
2862: PPUSH
2863: CALL_OW 67
// art := FindArtifact ( 4 ) ;
2867: LD_ADDR_VAR 0 5
2871: PUSH
2872: LD_INT 4
2874: PPUSH
2875: CALL_OW 469
2879: ST_TO_ADDR
// if art then
2880: LD_VAR 0 5
2884: IFFALSE 2923
// if art [ 1 ] = 157 and art [ 2 ] = 75 then
2886: LD_VAR 0 5
2890: PUSH
2891: LD_INT 1
2893: ARRAY
2894: PUSH
2895: LD_INT 157
2897: EQUAL
2898: PUSH
2899: LD_VAR 0 5
2903: PUSH
2904: LD_INT 2
2906: ARRAY
2907: PUSH
2908: LD_INT 75
2910: EQUAL
2911: AND
2912: IFFALSE 2923
// begin YouLost ( Artefact ) ;
2914: LD_STRING Artefact
2916: PPUSH
2917: CALL_OW 104
// exit ;
2921: GO 3075
// end ; if IsOK ( JMM ) and IsOk ( Burlak ) then
2923: LD_EXP 14
2927: PPUSH
2928: CALL_OW 302
2932: PUSH
2933: LD_EXP 15
2937: PPUSH
2938: CALL_OW 302
2942: AND
2943: IFFALSE 3020
// begin DialogueOn ;
2945: CALL_OW 6
// Say ( JMM , D6a-JMM-1 ) ;
2949: LD_EXP 14
2953: PPUSH
2954: LD_STRING D6a-JMM-1
2956: PPUSH
2957: CALL_OW 88
// Say ( Burlak , D6a-Bur-1 ) ;
2961: LD_EXP 15
2965: PPUSH
2966: LD_STRING D6a-Bur-1
2968: PPUSH
2969: CALL_OW 88
// Say ( JMM , D6c-JMM-1 ) ;
2973: LD_EXP 14
2977: PPUSH
2978: LD_STRING D6c-JMM-1
2980: PPUSH
2981: CALL_OW 88
// Say ( Burlak , D6c-Bur-1 ) ;
2985: LD_EXP 15
2989: PPUSH
2990: LD_STRING D6c-Bur-1
2992: PPUSH
2993: CALL_OW 88
// Say ( JMM , D6c-JMM-2 ) ;
2997: LD_EXP 14
3001: PPUSH
3002: LD_STRING D6c-JMM-2
3004: PPUSH
3005: CALL_OW 88
// ChangeMissionObjectives ( MBase ) ;
3009: LD_STRING MBase
3011: PPUSH
3012: CALL_OW 337
// DialogueOff ;
3016: CALL_OW 7
// end ; bombExploded := true ;
3020: LD_ADDR_EXP 4
3024: PUSH
3025: LD_INT 1
3027: ST_TO_ADDR
// wait ( [ 3 3$00 , 2 2$30 , 2 2$00 ] [ Difficulty ] ) ;
3028: LD_INT 6300
3030: PUSH
3031: LD_INT 5250
3033: PUSH
3034: LD_INT 4200
3036: PUSH
3037: EMPTY
3038: LIST
3039: LIST
3040: LIST
3041: PUSH
3042: LD_OWVAR 67
3046: ARRAY
3047: PPUSH
3048: CALL_OW 67
// if IsOk ( JMM ) then
3052: LD_EXP 14
3056: PPUSH
3057: CALL_OW 302
3061: IFFALSE 3075
// Say ( JMM , D8-JMM-1 ) ;
3063: LD_EXP 14
3067: PPUSH
3068: LD_STRING D8-JMM-1
3070: PPUSH
3071: CALL_OW 88
// end ;
3075: LD_VAR 0 4
3079: RET
// every 0 0$1 trigger stevensTimer and not planCaptured and bombExploded do
3080: LD_EXP 9
3084: PUSH
3085: LD_EXP 7
3089: NOT
3090: AND
3091: PUSH
3092: LD_EXP 4
3096: AND
3097: IFFALSE 3152
3099: GO 3101
3101: DISABLE
// begin enable ;
3102: ENABLE
// if FilterUnitsInArea ( usBase , [ f_side , 7 ] ) then
3103: LD_INT 9
3105: PPUSH
3106: LD_INT 22
3108: PUSH
3109: LD_INT 7
3111: PUSH
3112: EMPTY
3113: LIST
3114: LIST
3115: PPUSH
3116: CALL_OW 70
3120: IFFALSE 3138
// stevensTimer := stevensTimer - 0 0$30 else
3122: LD_ADDR_EXP 9
3126: PUSH
3127: LD_EXP 9
3131: PUSH
3132: LD_INT 1050
3134: MINUS
3135: ST_TO_ADDR
3136: GO 3152
// stevensTimer := stevensTimer - 0 0$1 ;
3138: LD_ADDR_EXP 9
3142: PUSH
3143: LD_EXP 9
3147: PUSH
3148: LD_INT 35
3150: MINUS
3151: ST_TO_ADDR
// end ;
3152: END
// every 0 0$1 trigger stevensTimer <= 0 0$00 and not planCaptured do var i , tmp ;
3153: LD_EXP 9
3157: PUSH
3158: LD_INT 0
3160: LESSEQUAL
3161: PUSH
3162: LD_EXP 7
3166: NOT
3167: AND
3168: IFFALSE 3332
3170: GO 3172
3172: DISABLE
3173: LD_INT 0
3175: PPUSH
3176: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
3177: LD_ADDR_VAR 0 2
3181: PUSH
3182: LD_INT 22
3184: PUSH
3185: LD_INT 1
3187: PUSH
3188: EMPTY
3189: LIST
3190: LIST
3191: PUSH
3192: LD_INT 25
3194: PUSH
3195: LD_INT 4
3197: PUSH
3198: EMPTY
3199: LIST
3200: LIST
3201: PUSH
3202: EMPTY
3203: LIST
3204: LIST
3205: PPUSH
3206: CALL_OW 69
3210: ST_TO_ADDR
// for i in tmp do
3211: LD_ADDR_VAR 0 1
3215: PUSH
3216: LD_VAR 0 2
3220: PUSH
3221: FOR_IN
3222: IFFALSE 3275
// begin if IsInUnit ( i ) then
3224: LD_VAR 0 1
3228: PPUSH
3229: CALL_OW 310
3233: IFFALSE 3246
// ComExitBuilding ( i ) else
3235: LD_VAR 0 1
3239: PPUSH
3240: CALL_OW 122
3244: GO 3273
// if not HasTask ( i ) then
3246: LD_VAR 0 1
3250: PPUSH
3251: CALL_OW 314
3255: NOT
3256: IFFALSE 3273
// ComMoveXY ( i , 29 , 56 ) ;
3258: LD_VAR 0 1
3262: PPUSH
3263: LD_INT 29
3265: PPUSH
3266: LD_INT 56
3268: PPUSH
3269: CALL_OW 111
// end ;
3273: GO 3221
3275: POP
3276: POP
// repeat wait ( 0 0$1 ) ;
3277: LD_INT 35
3279: PPUSH
3280: CALL_OW 67
// until FilterUnitsInArea ( stevensEscapeArea , [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
3284: LD_INT 8
3286: PPUSH
3287: LD_INT 22
3289: PUSH
3290: LD_INT 1
3292: PUSH
3293: EMPTY
3294: LIST
3295: LIST
3296: PUSH
3297: LD_INT 25
3299: PUSH
3300: LD_INT 4
3302: PUSH
3303: EMPTY
3304: LIST
3305: LIST
3306: PUSH
3307: EMPTY
3308: LIST
3309: LIST
3310: PPUSH
3311: CALL_OW 70
3315: IFFALSE 3277
// if planCaptured then
3317: LD_EXP 7
3321: IFFALSE 3325
// exit ;
3323: GO 3332
// YouLost ( Time ) ;
3325: LD_STRING Time
3327: PPUSH
3328: CALL_OW 104
// end ;
3332: PPOPN 2
3334: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_distxy , 142 , 52 , 27 ] ] ) and contaminateTime + 6000 > tick and bombExploded do
3335: LD_INT 22
3337: PUSH
3338: LD_INT 7
3340: PUSH
3341: EMPTY
3342: LIST
3343: LIST
3344: PUSH
3345: LD_INT 92
3347: PUSH
3348: LD_INT 142
3350: PUSH
3351: LD_INT 52
3353: PUSH
3354: LD_INT 27
3356: PUSH
3357: EMPTY
3358: LIST
3359: LIST
3360: LIST
3361: LIST
3362: PUSH
3363: EMPTY
3364: LIST
3365: LIST
3366: PPUSH
3367: CALL_OW 69
3371: PUSH
3372: LD_EXP 3
3376: PUSH
3377: LD_INT 6000
3379: PLUS
3380: PUSH
3381: LD_OWVAR 1
3385: GREATER
3386: AND
3387: PUSH
3388: LD_EXP 4
3392: AND
3393: IFFALSE 3448
3395: GO 3397
3397: DISABLE
// begin CenterOnUnits ( [ JMM , Burlak ] ) ;
3398: LD_EXP 14
3402: PUSH
3403: LD_EXP 15
3407: PUSH
3408: EMPTY
3409: LIST
3410: LIST
3411: PPUSH
3412: CALL_OW 85
// DialogueOn ;
3416: CALL_OW 6
// Say ( JMM , D6b-JMM-1 ) ;
3420: LD_EXP 14
3424: PPUSH
3425: LD_STRING D6b-JMM-1
3427: PPUSH
3428: CALL_OW 88
// Say ( Burlak , D6b-Bur-1 ) ;
3432: LD_EXP 15
3436: PPUSH
3437: LD_STRING D6b-Bur-1
3439: PPUSH
3440: CALL_OW 88
// DialogueOff ;
3444: CALL_OW 7
// end ;
3448: END
// every 0 0$1 trigger ( GetDistUnitXY ( Burlak , 142 , 52 ) < 25 or GetDistUnitXY ( IsInUnit ( Burlak ) , 142 , 52 ) < 25 ) and GetLives ( Burlak ) < 1000 and contaminateTime + 6000 > tick and bombExploded do
3449: LD_EXP 15
3453: PPUSH
3454: LD_INT 142
3456: PPUSH
3457: LD_INT 52
3459: PPUSH
3460: CALL_OW 297
3464: PUSH
3465: LD_INT 25
3467: LESS
3468: PUSH
3469: LD_EXP 15
3473: PPUSH
3474: CALL_OW 310
3478: PPUSH
3479: LD_INT 142
3481: PPUSH
3482: LD_INT 52
3484: PPUSH
3485: CALL_OW 297
3489: PUSH
3490: LD_INT 25
3492: LESS
3493: OR
3494: PUSH
3495: LD_EXP 15
3499: PPUSH
3500: CALL_OW 256
3504: PUSH
3505: LD_INT 1000
3507: LESS
3508: AND
3509: PUSH
3510: LD_EXP 3
3514: PUSH
3515: LD_INT 6000
3517: PLUS
3518: PUSH
3519: LD_OWVAR 1
3523: GREATER
3524: AND
3525: PUSH
3526: LD_EXP 4
3530: AND
3531: IFFALSE 3564
3533: GO 3535
3535: DISABLE
// begin DialogueOn ;
3536: CALL_OW 6
// Say ( Burlak , D7-Bur-1 ) ;
3540: LD_EXP 15
3544: PPUSH
3545: LD_STRING D7-Bur-1
3547: PPUSH
3548: CALL_OW 88
// enteredContaminatedArea := true ;
3552: LD_ADDR_EXP 5
3556: PUSH
3557: LD_INT 1
3559: ST_TO_ADDR
// DialogueOff ;
3560: CALL_OW 7
// end ;
3564: END
// every 0 0$1 trigger ( GetDistUnitXY ( JMM , 142 , 52 ) < 25 or GetDistUnitXY ( IsInUnit ( JMM ) , 142 , 52 ) < 25 ) and GetLives ( JMM ) < 1000 and contaminateTime + 6000 > tick and bombExploded do
3565: LD_EXP 14
3569: PPUSH
3570: LD_INT 142
3572: PPUSH
3573: LD_INT 52
3575: PPUSH
3576: CALL_OW 297
3580: PUSH
3581: LD_INT 25
3583: LESS
3584: PUSH
3585: LD_EXP 14
3589: PPUSH
3590: CALL_OW 310
3594: PPUSH
3595: LD_INT 142
3597: PPUSH
3598: LD_INT 52
3600: PPUSH
3601: CALL_OW 297
3605: PUSH
3606: LD_INT 25
3608: LESS
3609: OR
3610: PUSH
3611: LD_EXP 14
3615: PPUSH
3616: CALL_OW 256
3620: PUSH
3621: LD_INT 1000
3623: LESS
3624: AND
3625: PUSH
3626: LD_EXP 3
3630: PUSH
3631: LD_INT 6000
3633: PLUS
3634: PUSH
3635: LD_OWVAR 1
3639: GREATER
3640: AND
3641: PUSH
3642: LD_EXP 4
3646: AND
3647: IFFALSE 3680
3649: GO 3651
3651: DISABLE
// begin DialogueOn ;
3652: CALL_OW 6
// Say ( JMM , D7-JMM-1 ) ;
3656: LD_EXP 14
3660: PPUSH
3661: LD_STRING D7-JMM-1
3663: PPUSH
3664: CALL_OW 88
// enteredContaminatedArea := true ;
3668: LD_ADDR_EXP 5
3672: PUSH
3673: LD_INT 1
3675: ST_TO_ADDR
// DialogueOff ;
3676: CALL_OW 7
// end ;
3680: END
// every 0 0$1 trigger artifactPickedUp and IsOk ( JMM ) and IsOk ( Burlak ) do
3681: LD_EXP 6
3685: PUSH
3686: LD_EXP 14
3690: PPUSH
3691: CALL_OW 302
3695: AND
3696: PUSH
3697: LD_EXP 15
3701: PPUSH
3702: CALL_OW 302
3706: AND
3707: IFFALSE 3776
3709: GO 3711
3711: DISABLE
// begin DialogueOn ;
3712: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Burlak ] ) ;
3716: LD_EXP 14
3720: PUSH
3721: LD_EXP 15
3725: PUSH
3726: EMPTY
3727: LIST
3728: LIST
3729: PPUSH
3730: CALL_OW 87
// Say ( JMM , D4-JMM-1 ) ;
3734: LD_EXP 14
3738: PPUSH
3739: LD_STRING D4-JMM-1
3741: PPUSH
3742: CALL_OW 88
// if not bombExploded then
3746: LD_EXP 4
3750: NOT
3751: IFFALSE 3765
// Say ( Burlak , D4-Bur-1 ) ;
3753: LD_EXP 15
3757: PPUSH
3758: LD_STRING D4-Bur-1
3760: PPUSH
3761: CALL_OW 88
// DialogueOff ;
3765: CALL_OW 7
// ChangeMissionObjectives ( MReturn ) ;
3769: LD_STRING MReturn
3771: PPUSH
3772: CALL_OW 337
// end ;
3776: END
// every 0 0$2 trigger not planCaptured and FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , us_dep_north , 6 ] ] ) do
3777: LD_EXP 7
3781: NOT
3782: PUSH
3783: LD_INT 22
3785: PUSH
3786: LD_INT 7
3788: PUSH
3789: EMPTY
3790: LIST
3791: LIST
3792: PUSH
3793: LD_INT 91
3795: PUSH
3796: LD_INT 9
3798: PUSH
3799: LD_INT 6
3801: PUSH
3802: EMPTY
3803: LIST
3804: LIST
3805: LIST
3806: PUSH
3807: EMPTY
3808: LIST
3809: LIST
3810: PPUSH
3811: CALL_OW 69
3815: AND
3816: IFFALSE 3893
3818: GO 3820
3820: DISABLE
// begin DialogueOn ;
3821: CALL_OW 6
// PlaceSeeing ( 55 , 11 , 7 , - 6 ) ;
3825: LD_INT 55
3827: PPUSH
3828: LD_INT 11
3830: PPUSH
3831: LD_INT 7
3833: PPUSH
3834: LD_INT 6
3836: NEG
3837: PPUSH
3838: CALL_OW 330
// RemoveSeeing ( 55 , 11 , 7 ) ;
3842: LD_INT 55
3844: PPUSH
3845: LD_INT 11
3847: PPUSH
3848: LD_INT 7
3850: PPUSH
3851: CALL_OW 331
// Say ( Burlak , D9-Bur-1 ) ;
3855: LD_EXP 15
3859: PPUSH
3860: LD_STRING D9-Bur-1
3862: PPUSH
3863: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
3867: LD_EXP 14
3871: PPUSH
3872: LD_STRING D9-JMM-1
3874: PPUSH
3875: CALL_OW 88
// DialogueOff ;
3879: CALL_OW 7
// SetSide ( us_dep_north , 7 ) ;
3883: LD_INT 9
3885: PPUSH
3886: LD_INT 7
3888: PPUSH
3889: CALL_OW 235
// end ;
3893: END
// every 0 0$1 trigger FilterUnitsInArea ( usBase , [ f_side , 7 ] ) do
3894: LD_INT 9
3896: PPUSH
3897: LD_INT 22
3899: PUSH
3900: LD_INT 7
3902: PUSH
3903: EMPTY
3904: LIST
3905: LIST
3906: PPUSH
3907: CALL_OW 70
3911: IFFALSE 3947
3913: GO 3915
3915: DISABLE
// begin wait ( 0 0$07 ) ;
3916: LD_INT 245
3918: PPUSH
3919: CALL_OW 67
// Say ( JMM , D10b-JMM-1 ) ;
3923: LD_EXP 14
3927: PPUSH
3928: LD_STRING D10b-JMM-1
3930: PPUSH
3931: CALL_OW 88
// Say ( Burlak , D10b-Bur-1 ) ;
3935: LD_EXP 15
3939: PPUSH
3940: LD_STRING D10b-Bur-1
3942: PPUSH
3943: CALL_OW 88
// end ;
3947: END
// every 0 0$1 trigger stevensTimer and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) and ( GetSide ( us_depot ) = 7 or FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) = 0 ) do var i ;
3948: LD_EXP 9
3952: PUSH
3953: LD_INT 22
3955: PUSH
3956: LD_INT 1
3958: PUSH
3959: EMPTY
3960: LIST
3961: LIST
3962: PUSH
3963: LD_INT 25
3965: PUSH
3966: LD_INT 4
3968: PUSH
3969: EMPTY
3970: LIST
3971: LIST
3972: PUSH
3973: LD_INT 26
3975: PUSH
3976: LD_INT 1
3978: PUSH
3979: EMPTY
3980: LIST
3981: LIST
3982: PUSH
3983: EMPTY
3984: LIST
3985: LIST
3986: LIST
3987: PPUSH
3988: CALL_OW 69
3992: AND
3993: PUSH
3994: LD_INT 5
3996: PPUSH
3997: CALL_OW 255
4001: PUSH
4002: LD_INT 7
4004: EQUAL
4005: PUSH
4006: LD_INT 22
4008: PUSH
4009: LD_INT 1
4011: PUSH
4012: EMPTY
4013: LIST
4014: LIST
4015: PUSH
4016: LD_INT 25
4018: PUSH
4019: LD_INT 1
4021: PUSH
4022: EMPTY
4023: LIST
4024: LIST
4025: PUSH
4026: EMPTY
4027: LIST
4028: LIST
4029: PPUSH
4030: CALL_OW 69
4034: PUSH
4035: LD_INT 0
4037: EQUAL
4038: OR
4039: AND
4040: IFFALSE 4629
4042: GO 4044
4044: DISABLE
4045: LD_INT 0
4047: PPUSH
// begin case Query ( QKill ) of 1 :
4048: LD_STRING QKill
4050: PPUSH
4051: CALL_OW 97
4055: PUSH
4056: LD_INT 1
4058: DOUBLE
4059: EQUAL
4060: IFTRUE 4064
4062: GO 4617
4064: POP
// begin DialogueOn ;
4065: CALL_OW 6
// Say ( JMM , D10a-JMM-1 ) ;
4069: LD_EXP 14
4073: PPUSH
4074: LD_STRING D10a-JMM-1
4076: PPUSH
4077: CALL_OW 88
// Say ( Burlak , D10a-Bur-1 ) ;
4081: LD_EXP 15
4085: PPUSH
4086: LD_STRING D10a-Bur-1
4088: PPUSH
4089: CALL_OW 88
// Say ( JMM , D10a-JMM-2 ) ;
4093: LD_EXP 14
4097: PPUSH
4098: LD_STRING D10a-JMM-2
4100: PPUSH
4101: CALL_OW 88
// if IsOk ( Stevens ) then
4105: LD_EXP 18
4109: PPUSH
4110: CALL_OW 302
4114: IFFALSE 4130
// Say ( Stevens , D10a-Huck-2 ) else
4116: LD_EXP 18
4120: PPUSH
4121: LD_STRING D10a-Huck-2
4123: PPUSH
4124: CALL_OW 88
4128: GO 4181
// Say ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) [ 1 ] , D10a-ASci1-3 ) ;
4130: LD_INT 22
4132: PUSH
4133: LD_INT 1
4135: PUSH
4136: EMPTY
4137: LIST
4138: LIST
4139: PUSH
4140: LD_INT 25
4142: PUSH
4143: LD_INT 4
4145: PUSH
4146: EMPTY
4147: LIST
4148: LIST
4149: PUSH
4150: LD_INT 26
4152: PUSH
4153: LD_INT 1
4155: PUSH
4156: EMPTY
4157: LIST
4158: LIST
4159: PUSH
4160: EMPTY
4161: LIST
4162: LIST
4163: LIST
4164: PPUSH
4165: CALL_OW 69
4169: PUSH
4170: LD_INT 1
4172: ARRAY
4173: PPUSH
4174: LD_STRING D10a-ASci1-3
4176: PPUSH
4177: CALL_OW 88
// Say ( JMM , D10a-JMM-4 ) ;
4181: LD_EXP 14
4185: PPUSH
4186: LD_STRING D10a-JMM-4
4188: PPUSH
4189: CALL_OW 88
// if IsOk ( Stevens ) then
4193: LD_EXP 18
4197: PPUSH
4198: CALL_OW 302
4202: IFFALSE 4216
// Say ( Stevens , D10a-Huck-3 ) ;
4204: LD_EXP 18
4208: PPUSH
4209: LD_STRING D10a-Huck-3
4211: PPUSH
4212: CALL_OW 88
// DialogueOff ;
4216: CALL_OW 7
// SetAttitude ( 1 , 7 , att_friend , true ) ;
4220: LD_INT 1
4222: PPUSH
4223: LD_INT 7
4225: PPUSH
4226: LD_INT 1
4228: PPUSH
4229: LD_INT 1
4231: PPUSH
4232: CALL_OW 80
// planCaptured := true ;
4236: LD_ADDR_EXP 7
4240: PUSH
4241: LD_INT 1
4243: ST_TO_ADDR
// ChangeMissionObjectives ( MEnd ) ;
4244: LD_STRING MEnd
4246: PPUSH
4247: CALL_OW 337
// SetAchievement ( ACH_DIPLOMACY ) ;
4251: LD_STRING ACH_DIPLOMACY
4253: PPUSH
4254: CALL_OW 543
// canEnd := true ;
4258: LD_ADDR_EXP 10
4262: PUSH
4263: LD_INT 1
4265: ST_TO_ADDR
// missionTime := tick ;
4266: LD_ADDR_EXP 11
4270: PUSH
4271: LD_OWVAR 1
4275: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4276: LD_INT 35
4278: PPUSH
4279: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] ] ) then
4283: LD_INT 22
4285: PUSH
4286: LD_INT 1
4288: PUSH
4289: EMPTY
4290: LIST
4291: LIST
4292: PUSH
4293: LD_INT 3
4295: PUSH
4296: LD_INT 50
4298: PUSH
4299: EMPTY
4300: LIST
4301: PUSH
4302: EMPTY
4303: LIST
4304: LIST
4305: PUSH
4306: EMPTY
4307: LIST
4308: LIST
4309: PPUSH
4310: CALL_OW 69
4314: IFFALSE 4430
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) do
4316: LD_ADDR_VAR 0 1
4320: PUSH
4321: LD_INT 22
4323: PUSH
4324: LD_INT 1
4326: PUSH
4327: EMPTY
4328: LIST
4329: LIST
4330: PUSH
4331: LD_INT 25
4333: PUSH
4334: LD_INT 4
4336: PUSH
4337: EMPTY
4338: LIST
4339: LIST
4340: PUSH
4341: EMPTY
4342: LIST
4343: LIST
4344: PPUSH
4345: CALL_OW 69
4349: PUSH
4350: FOR_IN
4351: IFFALSE 4428
// begin if IsInUnit ( i ) then
4353: LD_VAR 0 1
4357: PPUSH
4358: CALL_OW 310
4362: IFFALSE 4375
// ComExitBuilding ( i ) else
4364: LD_VAR 0 1
4368: PPUSH
4369: CALL_OW 122
4373: GO 4426
// ComHeal ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] ] ) , i ) ) ;
4375: LD_VAR 0 1
4379: PPUSH
4380: LD_INT 22
4382: PUSH
4383: LD_INT 1
4385: PUSH
4386: EMPTY
4387: LIST
4388: LIST
4389: PUSH
4390: LD_INT 3
4392: PUSH
4393: LD_INT 50
4395: PUSH
4396: EMPTY
4397: LIST
4398: PUSH
4399: EMPTY
4400: LIST
4401: LIST
4402: PUSH
4403: EMPTY
4404: LIST
4405: LIST
4406: PPUSH
4407: CALL_OW 69
4411: PPUSH
4412: LD_VAR 0 1
4416: PPUSH
4417: CALL_OW 74
4421: PPUSH
4422: CALL_OW 128
// end ;
4426: GO 4350
4428: POP
4429: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] ] ) ;
4430: LD_INT 22
4432: PUSH
4433: LD_INT 1
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: PUSH
4440: LD_INT 3
4442: PUSH
4443: LD_INT 50
4445: PUSH
4446: EMPTY
4447: LIST
4448: PUSH
4449: EMPTY
4450: LIST
4451: LIST
4452: PUSH
4453: EMPTY
4454: LIST
4455: LIST
4456: PPUSH
4457: CALL_OW 69
4461: NOT
4462: IFFALSE 4276
// repeat wait ( 3 ) ;
4464: LD_INT 3
4466: PPUSH
4467: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) do
4471: LD_ADDR_VAR 0 1
4475: PUSH
4476: LD_INT 22
4478: PUSH
4479: LD_INT 1
4481: PUSH
4482: EMPTY
4483: LIST
4484: LIST
4485: PUSH
4486: LD_INT 21
4488: PUSH
4489: LD_INT 1
4491: PUSH
4492: EMPTY
4493: LIST
4494: LIST
4495: PUSH
4496: EMPTY
4497: LIST
4498: LIST
4499: PPUSH
4500: CALL_OW 69
4504: PUSH
4505: FOR_IN
4506: IFFALSE 4582
// begin if IsInArea ( i , stevensEscapeArea ) then
4508: LD_VAR 0 1
4512: PPUSH
4513: LD_INT 8
4515: PPUSH
4516: CALL_OW 308
4520: IFFALSE 4533
// begin RemoveUnit ( i ) ;
4522: LD_VAR 0 1
4526: PPUSH
4527: CALL_OW 64
// continue ;
4531: GO 4505
// end ; if IsInUnit ( i ) then
4533: LD_VAR 0 1
4537: PPUSH
4538: CALL_OW 310
4542: IFFALSE 4553
// ComExitBuilding ( i ) ;
4544: LD_VAR 0 1
4548: PPUSH
4549: CALL_OW 122
// if not HasTask ( i ) then
4553: LD_VAR 0 1
4557: PPUSH
4558: CALL_OW 314
4562: NOT
4563: IFFALSE 4580
// ComMoveXY ( i , 28 , 55 ) ;
4565: LD_VAR 0 1
4569: PPUSH
4570: LD_INT 28
4572: PPUSH
4573: LD_INT 55
4575: PPUSH
4576: CALL_OW 111
// end ;
4580: GO 4505
4582: POP
4583: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ;
4584: LD_INT 22
4586: PUSH
4587: LD_INT 1
4589: PUSH
4590: EMPTY
4591: LIST
4592: LIST
4593: PUSH
4594: LD_INT 21
4596: PUSH
4597: LD_INT 1
4599: PUSH
4600: EMPTY
4601: LIST
4602: LIST
4603: PUSH
4604: EMPTY
4605: LIST
4606: LIST
4607: PPUSH
4608: CALL_OW 69
4612: NOT
4613: IFFALSE 4464
// end ; 2 :
4615: GO 4629
4617: LD_INT 2
4619: DOUBLE
4620: EQUAL
4621: IFTRUE 4625
4623: GO 4628
4625: POP
// ; end ;
4626: GO 4629
4628: POP
// end ;
4629: PPOPN 1
4631: END
// every 0 0$1 trigger canEnd do var un , i , tmp ;
4632: LD_EXP 10
4636: IFFALSE 4993
4638: GO 4640
4640: DISABLE
4641: LD_INT 0
4643: PPUSH
4644: PPUSH
4645: PPUSH
// begin SetAreaMapShow ( endMissionArea , 1 ) ;
4646: LD_INT 10
4648: PPUSH
4649: LD_INT 1
4651: PPUSH
4652: CALL_OW 424
// if Difficulty < 2 then
4656: LD_OWVAR 67
4660: PUSH
4661: LD_INT 2
4663: LESS
4664: IFFALSE 4668
// exit ;
4666: GO 4993
// uc_side := 4 ;
4668: LD_ADDR_OWVAR 20
4672: PUSH
4673: LD_INT 4
4675: ST_TO_ADDR
// uc_nation := 1 ;
4676: LD_ADDR_OWVAR 21
4680: PUSH
4681: LD_INT 1
4683: ST_TO_ADDR
// InitHc ;
4684: CALL_OW 19
// tmp := [ ] ;
4688: LD_ADDR_VAR 0 3
4692: PUSH
4693: EMPTY
4694: ST_TO_ADDR
// PrepareHuman ( false , class_sniper , 10 ) ;
4695: LD_INT 0
4697: PPUSH
4698: LD_INT 5
4700: PPUSH
4701: LD_INT 10
4703: PPUSH
4704: CALL_OW 380
// un := CreateHuman ;
4708: LD_ADDR_VAR 0 1
4712: PUSH
4713: CALL_OW 44
4717: ST_TO_ADDR
// tmp := [ un ] ;
4718: LD_ADDR_VAR 0 3
4722: PUSH
4723: LD_VAR 0 1
4727: PUSH
4728: EMPTY
4729: LIST
4730: ST_TO_ADDR
// PlaceUnitXY ( un , 226 , 86 , false ) ;
4731: LD_VAR 0 1
4735: PPUSH
4736: LD_INT 226
4738: PPUSH
4739: LD_INT 86
4741: PPUSH
4742: LD_INT 0
4744: PPUSH
4745: CALL_OW 48
// ComHold ( un ) ;
4749: LD_VAR 0 1
4753: PPUSH
4754: CALL_OW 140
// for i = 1 to 3 do
4758: LD_ADDR_VAR 0 2
4762: PUSH
4763: DOUBLE
4764: LD_INT 1
4766: DEC
4767: ST_TO_ADDR
4768: LD_INT 3
4770: PUSH
4771: FOR_TO
4772: IFFALSE 4871
// begin PrepareHuman ( false , class_soldier , 8 ) ;
4774: LD_INT 0
4776: PPUSH
4777: LD_INT 1
4779: PPUSH
4780: LD_INT 8
4782: PPUSH
4783: CALL_OW 380
// un := CreateHuman ;
4787: LD_ADDR_VAR 0 1
4791: PUSH
4792: CALL_OW 44
4796: ST_TO_ADDR
// SetDir ( un , 5 ) ;
4797: LD_VAR 0 1
4801: PPUSH
4802: LD_INT 5
4804: PPUSH
4805: CALL_OW 233
// PlaceUnitXY ( un , [ 215 , 217 , 219 ] [ i ] , 76 , false ) ;
4809: LD_VAR 0 1
4813: PPUSH
4814: LD_INT 215
4816: PUSH
4817: LD_INT 217
4819: PUSH
4820: LD_INT 219
4822: PUSH
4823: EMPTY
4824: LIST
4825: LIST
4826: LIST
4827: PUSH
4828: LD_VAR 0 2
4832: ARRAY
4833: PPUSH
4834: LD_INT 76
4836: PPUSH
4837: LD_INT 0
4839: PPUSH
4840: CALL_OW 48
// ComCrawl ( un ) ;
4844: LD_VAR 0 1
4848: PPUSH
4849: CALL_OW 137
// tmp := tmp ^ un ;
4853: LD_ADDR_VAR 0 3
4857: PUSH
4858: LD_VAR 0 3
4862: PUSH
4863: LD_VAR 0 1
4867: ADD
4868: ST_TO_ADDR
// end ;
4869: GO 4771
4871: POP
4872: POP
// repeat wait ( 0 0$1 ) ;
4873: LD_INT 35
4875: PPUSH
4876: CALL_OW 67
// until not UnitFilter ( tmp , [ f_lives , 1000 ] ) ;
4880: LD_VAR 0 3
4884: PPUSH
4885: LD_INT 24
4887: PUSH
4888: LD_INT 1000
4890: PUSH
4891: EMPTY
4892: LIST
4893: LIST
4894: PPUSH
4895: CALL_OW 72
4899: NOT
4900: IFFALSE 4873
// for i in tmp do
4902: LD_ADDR_VAR 0 2
4906: PUSH
4907: LD_VAR 0 3
4911: PUSH
4912: FOR_IN
4913: IFFALSE 4991
// begin wait ( 0 0$1 ) ;
4915: LD_INT 35
4917: PPUSH
4918: CALL_OW 67
// if Crawls ( i ) then
4922: LD_VAR 0 2
4926: PPUSH
4927: CALL_OW 318
4931: IFFALSE 4944
// ComWalk ( i ) else
4933: LD_VAR 0 2
4937: PPUSH
4938: CALL_OW 138
4942: GO 4989
// if GetClass ( i ) = class_sniper then
4944: LD_VAR 0 2
4948: PPUSH
4949: CALL_OW 257
4953: PUSH
4954: LD_INT 5
4956: EQUAL
4957: IFFALSE 4975
// ComAttackSoporific ( i , JMM ) else
4959: LD_VAR 0 2
4963: PPUSH
4964: LD_EXP 14
4968: PPUSH
4969: CALL_OW 166
4973: GO 4989
// ComAttackUnit ( i , JMM ) ;
4975: LD_VAR 0 2
4979: PPUSH
4980: LD_EXP 14
4984: PPUSH
4985: CALL_OW 115
// end ;
4989: GO 4912
4991: POP
4992: POP
// end ;
4993: PPOPN 3
4995: END
// every 0 0$1 trigger not planCaptured and IsDead ( us_lab ) do
4996: LD_EXP 7
5000: NOT
5001: PUSH
5002: LD_INT 1
5004: PPUSH
5005: CALL_OW 301
5009: AND
5010: IFFALSE 5022
5012: GO 5014
5014: DISABLE
// YouLost ( Lab ) ;
5015: LD_STRING Lab
5017: PPUSH
5018: CALL_OW 104
5022: END
// every 0 0$1 trigger FilterUnitsInArea ( endMissionArea , [ f_side , 7 ] ) >= 2 and FilterUnitsInArea ( endMissionArea , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) and canEnd and planCaptured and artifactPickedUp do var m1 , m2 ;
5023: LD_INT 10
5025: PPUSH
5026: LD_INT 22
5028: PUSH
5029: LD_INT 7
5031: PUSH
5032: EMPTY
5033: LIST
5034: LIST
5035: PPUSH
5036: CALL_OW 70
5040: PUSH
5041: LD_INT 2
5043: GREATEREQUAL
5044: PUSH
5045: LD_INT 10
5047: PPUSH
5048: LD_INT 2
5050: PUSH
5051: LD_INT 34
5053: PUSH
5054: LD_INT 12
5056: PUSH
5057: EMPTY
5058: LIST
5059: LIST
5060: PUSH
5061: LD_INT 34
5063: PUSH
5064: LD_INT 51
5066: PUSH
5067: EMPTY
5068: LIST
5069: LIST
5070: PUSH
5071: EMPTY
5072: LIST
5073: LIST
5074: LIST
5075: PPUSH
5076: CALL_OW 70
5080: AND
5081: PUSH
5082: LD_EXP 10
5086: AND
5087: PUSH
5088: LD_EXP 7
5092: AND
5093: PUSH
5094: LD_EXP 6
5098: AND
5099: IFFALSE 5355
5101: GO 5103
5103: DISABLE
5104: LD_INT 0
5106: PPUSH
5107: PPUSH
// begin m1 := false ;
5108: LD_ADDR_VAR 0 1
5112: PUSH
5113: LD_INT 0
5115: ST_TO_ADDR
// m2 := false ;
5116: LD_ADDR_VAR 0 2
5120: PUSH
5121: LD_INT 0
5123: ST_TO_ADDR
// if killCounter = 0 then
5124: LD_EXP 12
5128: PUSH
5129: LD_INT 0
5131: EQUAL
5132: IFFALSE 5141
// SetAchievement ( ACH_PACIFIST ) ;
5134: LD_STRING ACH_PACIFIST
5136: PPUSH
5137: CALL_OW 543
// if tick < 7 7$00 then
5141: LD_OWVAR 1
5145: PUSH
5146: LD_INT 14700
5148: LESS
5149: IFFALSE 5165
// begin wait ( 3 ) ;
5151: LD_INT 3
5153: PPUSH
5154: CALL_OW 67
// SetAchievement ( ACH_ASPEED_18 ) ;
5158: LD_STRING ACH_ASPEED_18
5160: PPUSH
5161: CALL_OW 543
// end ; AddMedal ( Explosion , 1 ) ;
5165: LD_STRING Explosion
5167: PPUSH
5168: LD_INT 1
5170: PPUSH
5171: CALL_OW 101
// if enteredContaminatedArea then
5175: LD_EXP 5
5179: IFFALSE 5201
// begin m1 := true ;
5181: LD_ADDR_VAR 0 1
5185: PUSH
5186: LD_INT 1
5188: ST_TO_ADDR
// AddMedal ( BioHazard , 1 ) ;
5189: LD_STRING BioHazard
5191: PPUSH
5192: LD_INT 1
5194: PPUSH
5195: CALL_OW 101
// end else
5199: GO 5212
// AddMedal ( BioHazard , - 1 ) ;
5201: LD_STRING BioHazard
5203: PPUSH
5204: LD_INT 1
5206: NEG
5207: PPUSH
5208: CALL_OW 101
// if missionTime <= [ 20 20$00 , 15 15$00 , 12 12$00 ] [ Difficulty ] then
5212: LD_EXP 11
5216: PUSH
5217: LD_INT 42000
5219: PUSH
5220: LD_INT 31500
5222: PUSH
5223: LD_INT 25200
5225: PUSH
5226: EMPTY
5227: LIST
5228: LIST
5229: LIST
5230: PUSH
5231: LD_OWVAR 67
5235: ARRAY
5236: LESSEQUAL
5237: IFFALSE 5259
// begin m2 := true ;
5239: LD_ADDR_VAR 0 2
5243: PUSH
5244: LD_INT 1
5246: ST_TO_ADDR
// AddMedal ( Speed , 1 ) ;
5247: LD_STRING Speed
5249: PPUSH
5250: LD_INT 1
5252: PPUSH
5253: CALL_OW 101
// end else
5257: GO 5270
// AddMedal ( Speed , - 1 ) ;
5259: LD_STRING Speed
5261: PPUSH
5262: LD_INT 1
5264: NEG
5265: PPUSH
5266: CALL_OW 101
// if Difficulty = 3 and m1 and m2 then
5270: LD_OWVAR 67
5274: PUSH
5275: LD_INT 3
5277: EQUAL
5278: PUSH
5279: LD_VAR 0 1
5283: AND
5284: PUSH
5285: LD_VAR 0 2
5289: AND
5290: IFFALSE 5302
// SetAchievementEX ( ACH_AMER , 18 ) ;
5292: LD_STRING ACH_AMER
5294: PPUSH
5295: LD_INT 18
5297: PPUSH
5298: CALL_OW 564
// GiveMedals ( Main ) ;
5302: LD_STRING Main
5304: PPUSH
5305: CALL_OW 102
// RewardPeople ( [ JMM , Burlak ] ) ;
5309: LD_EXP 14
5313: PUSH
5314: LD_EXP 15
5318: PUSH
5319: EMPTY
5320: LIST
5321: LIST
5322: PPUSH
5323: CALL_OW 43
// SaveCharacters ( JMM , 14a_JMM ) ;
5327: LD_EXP 14
5331: PPUSH
5332: LD_STRING 14a_JMM
5334: PPUSH
5335: CALL_OW 38
// SaveCharacters ( Burlak , 14a_Burlak ) ;
5339: LD_EXP 15
5343: PPUSH
5344: LD_STRING 14a_Burlak
5346: PPUSH
5347: CALL_OW 38
// YouWin ;
5351: CALL_OW 103
// end ; end_of_file
5355: PPOPN 2
5357: END
// export Stevens , Powell , baseGuards , sibBomb , guards , vehGuard ; export function PrepareAmerican ; var i , un , tmp ; begin
5358: LD_INT 0
5360: PPUSH
5361: PPUSH
5362: PPUSH
5363: PPUSH
// uc_side := 1 ;
5364: LD_ADDR_OWVAR 20
5368: PUSH
5369: LD_INT 1
5371: ST_TO_ADDR
// uc_nation := 1 ;
5372: LD_ADDR_OWVAR 21
5376: PUSH
5377: LD_INT 1
5379: ST_TO_ADDR
// InitHc ;
5380: CALL_OW 19
// SetResourceType ( GetBase ( us_depot2 ) , mat_cans , 500 ) ;
5384: LD_INT 34
5386: PPUSH
5387: CALL_OW 274
5391: PPUSH
5392: LD_INT 1
5394: PPUSH
5395: LD_INT 500
5397: PPUSH
5398: CALL_OW 277
// SetResourceType ( GetBase ( us_depot2 ) , mat_siberit , 20 ) ;
5402: LD_INT 34
5404: PPUSH
5405: CALL_OW 274
5409: PPUSH
5410: LD_INT 3
5412: PPUSH
5413: LD_INT 20
5415: PPUSH
5416: CALL_OW 277
// Stevens := NewCharacter ( Stevens ) ;
5420: LD_ADDR_EXP 18
5424: PUSH
5425: LD_STRING Stevens
5427: PPUSH
5428: CALL_OW 25
5432: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
5433: LD_ADDR_EXP 19
5437: PUSH
5438: LD_STRING Powell
5440: PPUSH
5441: CALL_OW 25
5445: ST_TO_ADDR
// PlaceHumanInUnit ( Stevens , us_lab ) ;
5446: LD_EXP 18
5450: PPUSH
5451: LD_INT 1
5453: PPUSH
5454: CALL_OW 52
// vehGuard := [ ] ;
5458: LD_ADDR_EXP 23
5462: PUSH
5463: EMPTY
5464: ST_TO_ADDR
// hc_importance := 0 ;
5465: LD_ADDR_OWVAR 32
5469: PUSH
5470: LD_INT 0
5472: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_siberite , control_computer , us_siberium_rocket , 100 ) ;
5473: LD_INT 4
5475: PPUSH
5476: LD_INT 3
5478: PPUSH
5479: LD_INT 3
5481: PPUSH
5482: LD_INT 8
5484: PPUSH
5485: LD_INT 100
5487: PPUSH
5488: CALL 971 0 5
// sibBomb := CreateVehicle ;
5492: LD_ADDR_EXP 21
5496: PUSH
5497: CALL_OW 45
5501: ST_TO_ADDR
// SetDir ( sibBomb , 1 ) ;
5502: LD_EXP 21
5506: PPUSH
5507: LD_INT 1
5509: PPUSH
5510: CALL_OW 233
// PlaceUnitXY ( sibBomb , 93 , 74 , false ) ;
5514: LD_EXP 21
5518: PPUSH
5519: LD_INT 93
5521: PPUSH
5522: LD_INT 74
5524: PPUSH
5525: LD_INT 0
5527: PPUSH
5528: CALL_OW 48
// guards := [ ] ;
5532: LD_ADDR_EXP 22
5536: PUSH
5537: EMPTY
5538: ST_TO_ADDR
// for i = 1 to 3 do
5539: LD_ADDR_VAR 0 2
5543: PUSH
5544: DOUBLE
5545: LD_INT 1
5547: DEC
5548: ST_TO_ADDR
5549: LD_INT 3
5551: PUSH
5552: FOR_TO
5553: IFFALSE 5645
// begin PrepareHuman ( false , class_soldier , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
5555: LD_INT 0
5557: PPUSH
5558: LD_INT 1
5560: PPUSH
5561: LD_INT 8
5563: PUSH
5564: LD_INT 9
5566: PUSH
5567: LD_INT 10
5569: PUSH
5570: EMPTY
5571: LIST
5572: LIST
5573: LIST
5574: PUSH
5575: LD_OWVAR 67
5579: ARRAY
5580: PPUSH
5581: CALL_OW 380
// un := CreateHuman ;
5585: LD_ADDR_VAR 0 3
5589: PUSH
5590: CALL_OW 44
5594: ST_TO_ADDR
// PlaceUnitArea ( un , [ patrol1 , patrol2 , patrol3 ] [ i ] , false ) ;
5595: LD_VAR 0 3
5599: PPUSH
5600: LD_INT 2
5602: PUSH
5603: LD_INT 3
5605: PUSH
5606: LD_INT 4
5608: PUSH
5609: EMPTY
5610: LIST
5611: LIST
5612: LIST
5613: PUSH
5614: LD_VAR 0 2
5618: ARRAY
5619: PPUSH
5620: LD_INT 0
5622: PPUSH
5623: CALL_OW 49
// guards := guards ^ un ;
5627: LD_ADDR_EXP 22
5631: PUSH
5632: LD_EXP 22
5636: PUSH
5637: LD_VAR 0 3
5641: ADD
5642: ST_TO_ADDR
// end ;
5643: GO 5552
5645: POP
5646: POP
// baseGuards := [ ] ;
5647: LD_ADDR_EXP 20
5651: PUSH
5652: EMPTY
5653: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
5654: LD_ADDR_VAR 0 2
5658: PUSH
5659: DOUBLE
5660: LD_INT 1
5662: DEC
5663: ST_TO_ADDR
5664: LD_INT 5
5666: PUSH
5667: LD_INT 6
5669: PUSH
5670: LD_INT 7
5672: PUSH
5673: EMPTY
5674: LIST
5675: LIST
5676: LIST
5677: PUSH
5678: LD_OWVAR 67
5682: ARRAY
5683: PUSH
5684: FOR_TO
5685: IFFALSE 5831
// begin PrepareSoldier ( false , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
5687: LD_INT 0
5689: PPUSH
5690: LD_INT 8
5692: PUSH
5693: LD_INT 9
5695: PUSH
5696: LD_INT 10
5698: PUSH
5699: EMPTY
5700: LIST
5701: LIST
5702: LIST
5703: PUSH
5704: LD_OWVAR 67
5708: ARRAY
5709: PPUSH
5710: CALL_OW 381
// un := CreateHuman ;
5714: LD_ADDR_VAR 0 3
5718: PUSH
5719: CALL_OW 44
5723: ST_TO_ADDR
// baseGuards := baseGuards ^ un ;
5724: LD_ADDR_EXP 20
5728: PUSH
5729: LD_EXP 20
5733: PUSH
5734: LD_VAR 0 3
5738: ADD
5739: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
5740: LD_ADDR_VAR 0 4
5744: PUSH
5745: LD_INT 22
5747: PUSH
5748: LD_INT 1
5750: PUSH
5751: EMPTY
5752: LIST
5753: LIST
5754: PUSH
5755: LD_INT 58
5757: PUSH
5758: EMPTY
5759: LIST
5760: PUSH
5761: LD_INT 30
5763: PUSH
5764: LD_INT 32
5766: PUSH
5767: EMPTY
5768: LIST
5769: LIST
5770: PUSH
5771: EMPTY
5772: LIST
5773: LIST
5774: LIST
5775: PPUSH
5776: CALL_OW 69
5780: ST_TO_ADDR
// if tmp then
5781: LD_VAR 0 4
5785: IFFALSE 5817
// PlaceHumanInUnit ( un , tmp [ rand ( 1 , tmp ) ] ) else
5787: LD_VAR 0 3
5791: PPUSH
5792: LD_VAR 0 4
5796: PUSH
5797: LD_INT 1
5799: PPUSH
5800: LD_VAR 0 4
5804: PPUSH
5805: CALL_OW 12
5809: ARRAY
5810: PPUSH
5811: CALL_OW 52
5815: GO 5829
// PlaceHumanInUnit ( un , us_bar ) ;
5817: LD_VAR 0 3
5821: PPUSH
5822: LD_INT 51
5824: PPUSH
5825: CALL_OW 52
// end ;
5829: GO 5684
5831: POP
5832: POP
// if Difficulty > 1 then
5833: LD_OWVAR 67
5837: PUSH
5838: LD_INT 1
5840: GREATER
5841: IFFALSE 5885
// begin PrepareHuman ( false , class_sniper , [ 9 , 10 ] [ Difficulty - 1 ] ) ;
5843: LD_INT 0
5845: PPUSH
5846: LD_INT 5
5848: PPUSH
5849: LD_INT 9
5851: PUSH
5852: LD_INT 10
5854: PUSH
5855: EMPTY
5856: LIST
5857: LIST
5858: PUSH
5859: LD_OWVAR 67
5863: PUSH
5864: LD_INT 1
5866: MINUS
5867: ARRAY
5868: PPUSH
5869: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_bun1 ) ;
5873: CALL_OW 44
5877: PPUSH
5878: LD_INT 80
5880: PPUSH
5881: CALL_OW 52
// end ; for i = 1 to 3 do
5885: LD_ADDR_VAR 0 2
5889: PUSH
5890: DOUBLE
5891: LD_INT 1
5893: DEC
5894: ST_TO_ADDR
5895: LD_INT 3
5897: PUSH
5898: FOR_TO
5899: IFFALSE 5925
// begin PrepareMechanic ( false , 9 ) ;
5901: LD_INT 0
5903: PPUSH
5904: LD_INT 9
5906: PPUSH
5907: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , us_fac ) ;
5911: CALL_OW 44
5915: PPUSH
5916: LD_INT 43
5918: PPUSH
5919: CALL_OW 52
// end ;
5923: GO 5898
5925: POP
5926: POP
// PlaceHumanInUnit ( CreateHuman , us_ct ) ;
5927: CALL_OW 44
5931: PPUSH
5932: LD_INT 49
5934: PPUSH
5935: CALL_OW 52
// for i = 1 to 1 + Difficulty do
5939: LD_ADDR_VAR 0 2
5943: PUSH
5944: DOUBLE
5945: LD_INT 1
5947: DEC
5948: ST_TO_ADDR
5949: LD_INT 1
5951: PUSH
5952: LD_OWVAR 67
5956: PLUS
5957: PUSH
5958: FOR_TO
5959: IFFALSE 6002
// begin PrepareEngineer ( false , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
5961: LD_INT 0
5963: PPUSH
5964: LD_INT 8
5966: PUSH
5967: LD_INT 9
5969: PUSH
5970: LD_INT 10
5972: PUSH
5973: EMPTY
5974: LIST
5975: LIST
5976: LIST
5977: PUSH
5978: LD_OWVAR 67
5982: ARRAY
5983: PPUSH
5984: CALL_OW 382
// PlaceHumanInUnit ( CreateHuman , us_depot ) ;
5988: CALL_OW 44
5992: PPUSH
5993: LD_INT 5
5995: PPUSH
5996: CALL_OW 52
// end ;
6000: GO 5958
6002: POP
6003: POP
// for i = 1 to 3 do
6004: LD_ADDR_VAR 0 2
6008: PUSH
6009: DOUBLE
6010: LD_INT 1
6012: DEC
6013: ST_TO_ADDR
6014: LD_INT 3
6016: PUSH
6017: FOR_TO
6018: IFFALSE 6044
// begin PrepareScientist ( false , 10 ) ;
6020: LD_INT 0
6022: PPUSH
6023: LD_INT 10
6025: PPUSH
6026: CALL_OW 384
// PlaceHumanInUnit ( CreateHuman , us_lab ) ;
6030: CALL_OW 44
6034: PPUSH
6035: LD_INT 1
6037: PPUSH
6038: CALL_OW 52
// end ;
6042: GO 6017
6044: POP
6045: POP
// end ;
6046: LD_VAR 0 1
6050: RET
// every 0 0$2 trigger guards and not activeBombTest do var i , j , points ;
6051: LD_EXP 22
6055: PUSH
6056: LD_EXP 2
6060: NOT
6061: AND
6062: IFFALSE 6248
6064: GO 6066
6066: DISABLE
6067: LD_INT 0
6069: PPUSH
6070: PPUSH
6071: PPUSH
// begin enable ;
6072: ENABLE
// points := [ [ 204 , 30 ] , [ 165 , 24 ] , [ 195 , 6 ] , [ 223 , 54 ] , [ 214 , 84 ] , [ 206 , 71 ] ] ;
6073: LD_ADDR_VAR 0 3
6077: PUSH
6078: LD_INT 204
6080: PUSH
6081: LD_INT 30
6083: PUSH
6084: EMPTY
6085: LIST
6086: LIST
6087: PUSH
6088: LD_INT 165
6090: PUSH
6091: LD_INT 24
6093: PUSH
6094: EMPTY
6095: LIST
6096: LIST
6097: PUSH
6098: LD_INT 195
6100: PUSH
6101: LD_INT 6
6103: PUSH
6104: EMPTY
6105: LIST
6106: LIST
6107: PUSH
6108: LD_INT 223
6110: PUSH
6111: LD_INT 54
6113: PUSH
6114: EMPTY
6115: LIST
6116: LIST
6117: PUSH
6118: LD_INT 214
6120: PUSH
6121: LD_INT 84
6123: PUSH
6124: EMPTY
6125: LIST
6126: LIST
6127: PUSH
6128: LD_INT 206
6130: PUSH
6131: LD_INT 71
6133: PUSH
6134: EMPTY
6135: LIST
6136: LIST
6137: PUSH
6138: EMPTY
6139: LIST
6140: LIST
6141: LIST
6142: LIST
6143: LIST
6144: LIST
6145: ST_TO_ADDR
// for i in guards do
6146: LD_ADDR_VAR 0 1
6150: PUSH
6151: LD_EXP 22
6155: PUSH
6156: FOR_IN
6157: IFFALSE 6246
// begin if HasTask ( i ) then
6159: LD_VAR 0 1
6163: PPUSH
6164: CALL_OW 314
6168: IFFALSE 6174
// continue else
6170: GO 6156
6172: GO 6244
// begin j := rand ( 1 , 6 ) ;
6174: LD_ADDR_VAR 0 2
6178: PUSH
6179: LD_INT 1
6181: PPUSH
6182: LD_INT 6
6184: PPUSH
6185: CALL_OW 12
6189: ST_TO_ADDR
// if not See ( 7 , i ) then
6190: LD_INT 7
6192: PPUSH
6193: LD_VAR 0 1
6197: PPUSH
6198: CALL_OW 292
6202: NOT
6203: IFFALSE 6244
// ComAgressiveMove ( i , points [ j ] [ 1 ] , points [ j ] [ 2 ] ) ;
6205: LD_VAR 0 1
6209: PPUSH
6210: LD_VAR 0 3
6214: PUSH
6215: LD_VAR 0 2
6219: ARRAY
6220: PUSH
6221: LD_INT 1
6223: ARRAY
6224: PPUSH
6225: LD_VAR 0 3
6229: PUSH
6230: LD_VAR 0 2
6234: ARRAY
6235: PUSH
6236: LD_INT 2
6238: ARRAY
6239: PPUSH
6240: CALL_OW 114
// end ; end ;
6244: GO 6156
6246: POP
6247: POP
// end ;
6248: PPOPN 3
6250: END
// every 0 0$1 trigger vehGuard and not planCaptured do var i ;
6251: LD_EXP 23
6255: PUSH
6256: LD_EXP 7
6260: NOT
6261: AND
6262: IFFALSE 6333
6264: GO 6266
6266: DISABLE
6267: LD_INT 0
6269: PPUSH
// begin enable ;
6270: ENABLE
// for i in vehGuard do
6271: LD_ADDR_VAR 0 1
6275: PUSH
6276: LD_EXP 23
6280: PUSH
6281: FOR_IN
6282: IFFALSE 6331
// if IsOk ( vehGuard ) then
6284: LD_EXP 23
6288: PPUSH
6289: CALL_OW 302
6293: IFFALSE 6329
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , i ) ) ;
6295: LD_VAR 0 1
6299: PPUSH
6300: LD_INT 22
6302: PUSH
6303: LD_INT 7
6305: PUSH
6306: EMPTY
6307: LIST
6308: LIST
6309: PPUSH
6310: CALL_OW 69
6314: PPUSH
6315: LD_VAR 0 1
6319: PPUSH
6320: CALL_OW 74
6324: PPUSH
6325: CALL_OW 115
6329: GO 6281
6331: POP
6332: POP
// end ;
6333: PPOPN 1
6335: END
// every 9 9$00 trigger bombExploded and IsOk ( us_fac ) and not planCaptured do
6336: LD_EXP 4
6340: PUSH
6341: LD_INT 43
6343: PPUSH
6344: CALL_OW 302
6348: AND
6349: PUSH
6350: LD_EXP 7
6354: NOT
6355: AND
6356: IFFALSE 6404
6358: GO 6360
6360: DISABLE
// begin enable ;
6361: ENABLE
// ComConstruct ( us_fac , us_morphling , engine_siberite , control_remote , [ us_rocket_launcher , us_rocket_launcher , us_laser ] [ rand ( 1 , 3 ) ] ) ;
6362: LD_INT 43
6364: PPUSH
6365: LD_INT 5
6367: PPUSH
6368: LD_INT 3
6370: PPUSH
6371: LD_INT 2
6373: PPUSH
6374: LD_INT 7
6376: PUSH
6377: LD_INT 7
6379: PUSH
6380: LD_INT 9
6382: PUSH
6383: EMPTY
6384: LIST
6385: LIST
6386: LIST
6387: PUSH
6388: LD_INT 1
6390: PPUSH
6391: LD_INT 3
6393: PPUSH
6394: CALL_OW 12
6398: ARRAY
6399: PPUSH
6400: CALL_OW 125
// end ;
6404: END
// every 1 1$45 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_sniper ] , [ f_ok ] ] ) and not planCaptured do var tmp , b ;
6405: LD_INT 22
6407: PUSH
6408: LD_INT 1
6410: PUSH
6411: EMPTY
6412: LIST
6413: LIST
6414: PUSH
6415: LD_INT 25
6417: PUSH
6418: LD_INT 5
6420: PUSH
6421: EMPTY
6422: LIST
6423: LIST
6424: PUSH
6425: LD_INT 50
6427: PUSH
6428: EMPTY
6429: LIST
6430: PUSH
6431: EMPTY
6432: LIST
6433: LIST
6434: LIST
6435: PPUSH
6436: CALL_OW 69
6440: PUSH
6441: LD_EXP 7
6445: NOT
6446: AND
6447: IFFALSE 6676
6449: GO 6451
6451: DISABLE
6452: LD_INT 0
6454: PPUSH
6455: PPUSH
// begin enable ;
6456: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_sniper ] , [ f_ok ] ] ) ;
6457: LD_ADDR_VAR 0 1
6461: PUSH
6462: LD_INT 22
6464: PUSH
6465: LD_INT 1
6467: PUSH
6468: EMPTY
6469: LIST
6470: LIST
6471: PUSH
6472: LD_INT 25
6474: PUSH
6475: LD_INT 5
6477: PUSH
6478: EMPTY
6479: LIST
6480: LIST
6481: PUSH
6482: LD_INT 50
6484: PUSH
6485: EMPTY
6486: LIST
6487: PUSH
6488: EMPTY
6489: LIST
6490: LIST
6491: LIST
6492: PPUSH
6493: CALL_OW 69
6497: ST_TO_ADDR
// if not tmp then
6498: LD_VAR 0 1
6502: NOT
6503: IFFALSE 6507
// exit ;
6505: GO 6676
// b := IsInUnit ( tmp [ 1 ] ) ;
6507: LD_ADDR_VAR 0 2
6511: PUSH
6512: LD_VAR 0 1
6516: PUSH
6517: LD_INT 1
6519: ARRAY
6520: PPUSH
6521: CALL_OW 310
6525: ST_TO_ADDR
// if not b or HasTask ( tmp [ 1 ] ) then
6526: LD_VAR 0 2
6530: NOT
6531: PUSH
6532: LD_VAR 0 1
6536: PUSH
6537: LD_INT 1
6539: ARRAY
6540: PPUSH
6541: CALL_OW 314
6545: OR
6546: IFFALSE 6550
// exit ;
6548: GO 6676
// if b = us_bun1 then
6550: LD_VAR 0 2
6554: PUSH
6555: LD_INT 80
6557: EQUAL
6558: IFFALSE 6619
// begin ComExitBuilding ( tmp [ 1 ] ) ;
6560: LD_VAR 0 1
6564: PUSH
6565: LD_INT 1
6567: ARRAY
6568: PPUSH
6569: CALL_OW 122
// AddComAgressiveMove ( tmp [ 1 ] , 27 , 44 ) ;
6573: LD_VAR 0 1
6577: PUSH
6578: LD_INT 1
6580: ARRAY
6581: PPUSH
6582: LD_INT 27
6584: PPUSH
6585: LD_INT 44
6587: PPUSH
6588: CALL_OW 174
// if IsOk ( us_bun2 ) then
6592: LD_INT 55
6594: PPUSH
6595: CALL_OW 302
6599: IFFALSE 6617
// AddComEnterUnit ( tmp [ 1 ] , us_bun2 ) ;
6601: LD_VAR 0 1
6605: PUSH
6606: LD_INT 1
6608: ARRAY
6609: PPUSH
6610: LD_INT 55
6612: PPUSH
6613: CALL_OW 180
// end else
6617: GO 6676
// begin ComExitBuilding ( tmp [ 1 ] ) ;
6619: LD_VAR 0 1
6623: PUSH
6624: LD_INT 1
6626: ARRAY
6627: PPUSH
6628: CALL_OW 122
// AddComAgressiveMove ( tmp [ 1 ] , 92 , 51 ) ;
6632: LD_VAR 0 1
6636: PUSH
6637: LD_INT 1
6639: ARRAY
6640: PPUSH
6641: LD_INT 92
6643: PPUSH
6644: LD_INT 51
6646: PPUSH
6647: CALL_OW 174
// if IsOk ( us_bun1 ) then
6651: LD_INT 80
6653: PPUSH
6654: CALL_OW 302
6658: IFFALSE 6676
// AddComEnterUnit ( tmp [ 1 ] , us_bun1 ) ;
6660: LD_VAR 0 1
6664: PUSH
6665: LD_INT 1
6667: ARRAY
6668: PPUSH
6669: LD_INT 80
6671: PPUSH
6672: CALL_OW 180
// end ; end ;
6676: PPOPN 2
6678: END
// every 0 0$1 trigger not planCaptured and FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var i , tmp , tmp2 , b ;
6679: LD_EXP 7
6683: NOT
6684: PUSH
6685: LD_INT 9
6687: PPUSH
6688: LD_INT 22
6690: PUSH
6691: LD_INT 1
6693: PUSH
6694: EMPTY
6695: LIST
6696: LIST
6697: PUSH
6698: LD_INT 21
6700: PUSH
6701: LD_INT 3
6703: PUSH
6704: EMPTY
6705: LIST
6706: LIST
6707: PUSH
6708: LD_INT 3
6710: PUSH
6711: LD_INT 24
6713: PUSH
6714: LD_INT 1000
6716: PUSH
6717: EMPTY
6718: LIST
6719: LIST
6720: PUSH
6721: EMPTY
6722: LIST
6723: LIST
6724: PUSH
6725: EMPTY
6726: LIST
6727: LIST
6728: LIST
6729: PPUSH
6730: CALL_OW 70
6734: AND
6735: IFFALSE 7146
6737: GO 6739
6739: DISABLE
6740: LD_INT 0
6742: PPUSH
6743: PPUSH
6744: PPUSH
6745: PPUSH
// begin enable ;
6746: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_lives , 1000 ] ] ) ;
6747: LD_ADDR_VAR 0 2
6751: PUSH
6752: LD_INT 22
6754: PUSH
6755: LD_INT 1
6757: PUSH
6758: EMPTY
6759: LIST
6760: LIST
6761: PUSH
6762: LD_INT 25
6764: PUSH
6765: LD_INT 2
6767: PUSH
6768: EMPTY
6769: LIST
6770: LIST
6771: PUSH
6772: LD_INT 24
6774: PUSH
6775: LD_INT 1000
6777: PUSH
6778: EMPTY
6779: LIST
6780: LIST
6781: PUSH
6782: EMPTY
6783: LIST
6784: LIST
6785: LIST
6786: PPUSH
6787: CALL_OW 69
6791: ST_TO_ADDR
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_not , [ f_lives , 750 ] ] ] ) ;
6792: LD_ADDR_VAR 0 3
6796: PUSH
6797: LD_INT 22
6799: PUSH
6800: LD_INT 1
6802: PUSH
6803: EMPTY
6804: LIST
6805: LIST
6806: PUSH
6807: LD_INT 25
6809: PUSH
6810: LD_INT 2
6812: PUSH
6813: EMPTY
6814: LIST
6815: LIST
6816: PUSH
6817: LD_INT 3
6819: PUSH
6820: LD_INT 24
6822: PUSH
6823: LD_INT 750
6825: PUSH
6826: EMPTY
6827: LIST
6828: LIST
6829: PUSH
6830: EMPTY
6831: LIST
6832: LIST
6833: PUSH
6834: EMPTY
6835: LIST
6836: LIST
6837: LIST
6838: PPUSH
6839: CALL_OW 69
6843: ST_TO_ADDR
// b := FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) diff us_lab ;
6844: LD_ADDR_VAR 0 4
6848: PUSH
6849: LD_INT 9
6851: PPUSH
6852: LD_INT 22
6854: PUSH
6855: LD_INT 1
6857: PUSH
6858: EMPTY
6859: LIST
6860: LIST
6861: PUSH
6862: LD_INT 21
6864: PUSH
6865: LD_INT 3
6867: PUSH
6868: EMPTY
6869: LIST
6870: LIST
6871: PUSH
6872: LD_INT 3
6874: PUSH
6875: LD_INT 24
6877: PUSH
6878: LD_INT 1000
6880: PUSH
6881: EMPTY
6882: LIST
6883: LIST
6884: PUSH
6885: EMPTY
6886: LIST
6887: LIST
6888: PUSH
6889: EMPTY
6890: LIST
6891: LIST
6892: LIST
6893: PPUSH
6894: CALL_OW 70
6898: PUSH
6899: LD_INT 1
6901: DIFF
6902: ST_TO_ADDR
// if not tmp and not tmp2 then
6903: LD_VAR 0 2
6907: NOT
6908: PUSH
6909: LD_VAR 0 3
6913: NOT
6914: AND
6915: IFFALSE 6919
// exit ;
6917: GO 7146
// if tmp and b then
6919: LD_VAR 0 2
6923: PUSH
6924: LD_VAR 0 4
6928: AND
6929: IFFALSE 7059
// for i in tmp do
6931: LD_ADDR_VAR 0 1
6935: PUSH
6936: LD_VAR 0 2
6940: PUSH
6941: FOR_IN
6942: IFFALSE 7057
// begin if GetTag ( i ) = 1 and GetLives ( i ) < 1000 then
6944: LD_VAR 0 1
6948: PPUSH
6949: CALL_OW 110
6953: PUSH
6954: LD_INT 1
6956: EQUAL
6957: PUSH
6958: LD_VAR 0 1
6962: PPUSH
6963: CALL_OW 256
6967: PUSH
6968: LD_INT 1000
6970: LESS
6971: AND
6972: IFFALSE 6978
// continue else
6974: GO 6941
6976: GO 7005
// if GetTag ( i ) = 1 then
6978: LD_VAR 0 1
6982: PPUSH
6983: CALL_OW 110
6987: PUSH
6988: LD_INT 1
6990: EQUAL
6991: IFFALSE 7005
// SetTag ( i , 0 ) ;
6993: LD_VAR 0 1
6997: PPUSH
6998: LD_INT 0
7000: PPUSH
7001: CALL_OW 109
// if IsInUnit ( i ) then
7005: LD_VAR 0 1
7009: PPUSH
7010: CALL_OW 310
7014: IFFALSE 7025
// ComExitBuilding ( i ) ;
7016: LD_VAR 0 1
7020: PPUSH
7021: CALL_OW 122
// if not HasTask ( i ) then
7025: LD_VAR 0 1
7029: PPUSH
7030: CALL_OW 314
7034: NOT
7035: IFFALSE 7055
// AddComRepairBuilding ( i , b [ 1 ] ) ;
7037: LD_VAR 0 1
7041: PPUSH
7042: LD_VAR 0 4
7046: PUSH
7047: LD_INT 1
7049: ARRAY
7050: PPUSH
7051: CALL_OW 190
// end ;
7055: GO 6941
7057: POP
7058: POP
// if tmp2 then
7059: LD_VAR 0 3
7063: IFFALSE 7146
// for i in tmp2 do
7065: LD_ADDR_VAR 0 1
7069: PUSH
7070: LD_VAR 0 3
7074: PUSH
7075: FOR_IN
7076: IFFALSE 7144
// begin if not GetTag ( i ) = 1 then
7078: LD_VAR 0 1
7082: PPUSH
7083: CALL_OW 110
7087: PUSH
7088: LD_INT 1
7090: EQUAL
7091: NOT
7092: IFFALSE 7106
// SetTag ( i , 1 ) ;
7094: LD_VAR 0 1
7098: PPUSH
7099: LD_INT 1
7101: PPUSH
7102: CALL_OW 109
// if GetDistUnitXY ( i , 88 , 75 ) > 6 then
7106: LD_VAR 0 1
7110: PPUSH
7111: LD_INT 88
7113: PPUSH
7114: LD_INT 75
7116: PPUSH
7117: CALL_OW 297
7121: PUSH
7122: LD_INT 6
7124: GREATER
7125: IFFALSE 7142
// ComMoveXY ( i , 88 , 75 ) ;
7127: LD_VAR 0 1
7131: PPUSH
7132: LD_INT 88
7134: PPUSH
7135: LD_INT 75
7137: PPUSH
7138: CALL_OW 111
// end ;
7142: GO 7075
7144: POP
7145: POP
// end ;
7146: PPOPN 4
7148: END
// every 0 0$1 trigger not planCaptured and stevensTimer and FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var i , sci , tmp ;
7149: LD_EXP 7
7153: NOT
7154: PUSH
7155: LD_EXP 9
7159: AND
7160: PUSH
7161: LD_INT 9
7163: PPUSH
7164: LD_INT 22
7166: PUSH
7167: LD_INT 1
7169: PUSH
7170: EMPTY
7171: LIST
7172: LIST
7173: PUSH
7174: LD_INT 21
7176: PUSH
7177: LD_INT 1
7179: PUSH
7180: EMPTY
7181: LIST
7182: LIST
7183: PUSH
7184: LD_INT 3
7186: PUSH
7187: LD_INT 24
7189: PUSH
7190: LD_INT 1000
7192: PUSH
7193: EMPTY
7194: LIST
7195: LIST
7196: PUSH
7197: EMPTY
7198: LIST
7199: LIST
7200: PUSH
7201: EMPTY
7202: LIST
7203: LIST
7204: LIST
7205: PPUSH
7206: CALL_OW 70
7210: AND
7211: IFFALSE 7384
7213: GO 7215
7215: DISABLE
7216: LD_INT 0
7218: PPUSH
7219: PPUSH
7220: PPUSH
// begin enable ;
7221: ENABLE
// sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
7222: LD_ADDR_VAR 0 2
7226: PUSH
7227: LD_INT 22
7229: PUSH
7230: LD_INT 1
7232: PUSH
7233: EMPTY
7234: LIST
7235: LIST
7236: PUSH
7237: LD_INT 25
7239: PUSH
7240: LD_INT 4
7242: PUSH
7243: EMPTY
7244: LIST
7245: LIST
7246: PUSH
7247: EMPTY
7248: LIST
7249: LIST
7250: PPUSH
7251: CALL_OW 69
7255: ST_TO_ADDR
// tmp := FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
7256: LD_ADDR_VAR 0 3
7260: PUSH
7261: LD_INT 9
7263: PPUSH
7264: LD_INT 22
7266: PUSH
7267: LD_INT 1
7269: PUSH
7270: EMPTY
7271: LIST
7272: LIST
7273: PUSH
7274: LD_INT 21
7276: PUSH
7277: LD_INT 1
7279: PUSH
7280: EMPTY
7281: LIST
7282: LIST
7283: PUSH
7284: LD_INT 3
7286: PUSH
7287: LD_INT 24
7289: PUSH
7290: LD_INT 1000
7292: PUSH
7293: EMPTY
7294: LIST
7295: LIST
7296: PUSH
7297: EMPTY
7298: LIST
7299: LIST
7300: PUSH
7301: EMPTY
7302: LIST
7303: LIST
7304: LIST
7305: PPUSH
7306: CALL_OW 70
7310: ST_TO_ADDR
// if not sci or not tmp then
7311: LD_VAR 0 2
7315: NOT
7316: PUSH
7317: LD_VAR 0 3
7321: NOT
7322: OR
7323: IFFALSE 7327
// exit ;
7325: GO 7384
// for i in sci do
7327: LD_ADDR_VAR 0 1
7331: PUSH
7332: LD_VAR 0 2
7336: PUSH
7337: FOR_IN
7338: IFFALSE 7382
// if IsInUnit ( i ) then
7340: LD_VAR 0 1
7344: PPUSH
7345: CALL_OW 310
7349: IFFALSE 7362
// ComExitBuilding ( i ) else
7351: LD_VAR 0 1
7355: PPUSH
7356: CALL_OW 122
7360: GO 7380
// ComHeal ( i , tmp [ 1 ] ) ;
7362: LD_VAR 0 1
7366: PPUSH
7367: LD_VAR 0 3
7371: PUSH
7372: LD_INT 1
7374: ARRAY
7375: PPUSH
7376: CALL_OW 128
7380: GO 7337
7382: POP
7383: POP
// end ;
7384: PPOPN 3
7386: END
// every 0 0$1 trigger not planCaptured and stevensTimer and IsOk ( us_lab ) and not FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_outside ] ] ) do var i ;
7387: LD_EXP 7
7391: NOT
7392: PUSH
7393: LD_EXP 9
7397: AND
7398: PUSH
7399: LD_INT 1
7401: PPUSH
7402: CALL_OW 302
7406: AND
7407: PUSH
7408: LD_INT 9
7410: PPUSH
7411: LD_INT 22
7413: PUSH
7414: LD_INT 1
7416: PUSH
7417: EMPTY
7418: LIST
7419: LIST
7420: PUSH
7421: LD_INT 21
7423: PUSH
7424: LD_INT 1
7426: PUSH
7427: EMPTY
7428: LIST
7429: LIST
7430: PUSH
7431: LD_INT 3
7433: PUSH
7434: LD_INT 24
7436: PUSH
7437: LD_INT 1000
7439: PUSH
7440: EMPTY
7441: LIST
7442: LIST
7443: PUSH
7444: EMPTY
7445: LIST
7446: LIST
7447: PUSH
7448: EMPTY
7449: LIST
7450: LIST
7451: LIST
7452: PPUSH
7453: CALL_OW 70
7457: NOT
7458: AND
7459: PUSH
7460: LD_INT 22
7462: PUSH
7463: LD_INT 1
7465: PUSH
7466: EMPTY
7467: LIST
7468: LIST
7469: PUSH
7470: LD_INT 25
7472: PUSH
7473: LD_INT 4
7475: PUSH
7476: EMPTY
7477: LIST
7478: LIST
7479: PUSH
7480: LD_INT 56
7482: PUSH
7483: EMPTY
7484: LIST
7485: PUSH
7486: EMPTY
7487: LIST
7488: LIST
7489: LIST
7490: PPUSH
7491: CALL_OW 69
7495: AND
7496: IFFALSE 7589
7498: GO 7500
7500: DISABLE
7501: LD_INT 0
7503: PPUSH
// begin enable ;
7504: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_outside ] ] ) do
7505: LD_ADDR_VAR 0 1
7509: PUSH
7510: LD_INT 22
7512: PUSH
7513: LD_INT 1
7515: PUSH
7516: EMPTY
7517: LIST
7518: LIST
7519: PUSH
7520: LD_INT 25
7522: PUSH
7523: LD_INT 4
7525: PUSH
7526: EMPTY
7527: LIST
7528: LIST
7529: PUSH
7530: LD_INT 56
7532: PUSH
7533: EMPTY
7534: LIST
7535: PUSH
7536: EMPTY
7537: LIST
7538: LIST
7539: LIST
7540: PPUSH
7541: CALL_OW 69
7545: PUSH
7546: FOR_IN
7547: IFFALSE 7587
// if not GetTag ( i ) and not HasTask ( i ) then
7549: LD_VAR 0 1
7553: PPUSH
7554: CALL_OW 110
7558: NOT
7559: PUSH
7560: LD_VAR 0 1
7564: PPUSH
7565: CALL_OW 314
7569: NOT
7570: AND
7571: IFFALSE 7585
// ComEnterUnit ( i , us_lab ) ;
7573: LD_VAR 0 1
7577: PPUSH
7578: LD_INT 1
7580: PPUSH
7581: CALL_OW 120
7585: GO 7546
7587: POP
7588: POP
// end ;
7589: PPOPN 1
7591: END
// every 0 0$1 trigger not planCaptured and not FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_outside ] ] ) do var i ;
7592: LD_EXP 7
7596: NOT
7597: PUSH
7598: LD_INT 9
7600: PPUSH
7601: LD_INT 22
7603: PUSH
7604: LD_INT 1
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: PUSH
7611: LD_INT 21
7613: PUSH
7614: LD_INT 3
7616: PUSH
7617: EMPTY
7618: LIST
7619: LIST
7620: PUSH
7621: LD_INT 3
7623: PUSH
7624: LD_INT 24
7626: PUSH
7627: LD_INT 1000
7629: PUSH
7630: EMPTY
7631: LIST
7632: LIST
7633: PUSH
7634: EMPTY
7635: LIST
7636: LIST
7637: PUSH
7638: EMPTY
7639: LIST
7640: LIST
7641: LIST
7642: PPUSH
7643: CALL_OW 70
7647: NOT
7648: AND
7649: PUSH
7650: LD_INT 22
7652: PUSH
7653: LD_INT 1
7655: PUSH
7656: EMPTY
7657: LIST
7658: LIST
7659: PUSH
7660: LD_INT 25
7662: PUSH
7663: LD_INT 2
7665: PUSH
7666: EMPTY
7667: LIST
7668: LIST
7669: PUSH
7670: LD_INT 56
7672: PUSH
7673: EMPTY
7674: LIST
7675: PUSH
7676: EMPTY
7677: LIST
7678: LIST
7679: LIST
7680: PPUSH
7681: CALL_OW 69
7685: AND
7686: IFFALSE 7779
7688: GO 7690
7690: DISABLE
7691: LD_INT 0
7693: PPUSH
// begin enable ;
7694: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_outside ] ] ) do
7695: LD_ADDR_VAR 0 1
7699: PUSH
7700: LD_INT 22
7702: PUSH
7703: LD_INT 1
7705: PUSH
7706: EMPTY
7707: LIST
7708: LIST
7709: PUSH
7710: LD_INT 25
7712: PUSH
7713: LD_INT 2
7715: PUSH
7716: EMPTY
7717: LIST
7718: LIST
7719: PUSH
7720: LD_INT 56
7722: PUSH
7723: EMPTY
7724: LIST
7725: PUSH
7726: EMPTY
7727: LIST
7728: LIST
7729: LIST
7730: PPUSH
7731: CALL_OW 69
7735: PUSH
7736: FOR_IN
7737: IFFALSE 7777
// if not HasTask ( i ) and not GetTag ( i ) then
7739: LD_VAR 0 1
7743: PPUSH
7744: CALL_OW 314
7748: NOT
7749: PUSH
7750: LD_VAR 0 1
7754: PPUSH
7755: CALL_OW 110
7759: NOT
7760: AND
7761: IFFALSE 7775
// ComEnterUnit ( i , us_depot ) ;
7763: LD_VAR 0 1
7767: PPUSH
7768: LD_INT 5
7770: PPUSH
7771: CALL_OW 120
7775: GO 7736
7777: POP
7778: POP
// end ;
7779: PPOPN 1
7781: END
// every 0 0$1 trigger ( stevensTimer <= 0 0$00 or IsDead ( Stevens ) ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) do
7782: LD_EXP 9
7786: PUSH
7787: LD_INT 0
7789: LESSEQUAL
7790: PUSH
7791: LD_EXP 18
7795: PPUSH
7796: CALL_OW 301
7800: OR
7801: PUSH
7802: LD_INT 22
7804: PUSH
7805: LD_INT 1
7807: PUSH
7808: EMPTY
7809: LIST
7810: LIST
7811: PUSH
7812: LD_INT 25
7814: PUSH
7815: LD_INT 2
7817: PUSH
7818: EMPTY
7819: LIST
7820: LIST
7821: PUSH
7822: EMPTY
7823: LIST
7824: LIST
7825: PPUSH
7826: CALL_OW 69
7830: AND
7831: IFFALSE 7872
7833: GO 7835
7835: DISABLE
// ComDismantle ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) , us_lab ) ;
7836: LD_INT 22
7838: PUSH
7839: LD_INT 1
7841: PUSH
7842: EMPTY
7843: LIST
7844: LIST
7845: PUSH
7846: LD_INT 25
7848: PUSH
7849: LD_INT 2
7851: PUSH
7852: EMPTY
7853: LIST
7854: LIST
7855: PUSH
7856: EMPTY
7857: LIST
7858: LIST
7859: PPUSH
7860: CALL_OW 69
7864: PPUSH
7865: LD_INT 1
7867: PPUSH
7868: CALL_OW 167
7872: END
// every 0 0$4 trigger not planCaptured and FilterUnitsInArea ( usBaseCriticalArea , [ f_side , 7 ] ) do var i ;
7873: LD_EXP 7
7877: NOT
7878: PUSH
7879: LD_INT 7
7881: PPUSH
7882: LD_INT 22
7884: PUSH
7885: LD_INT 7
7887: PUSH
7888: EMPTY
7889: LIST
7890: LIST
7891: PPUSH
7892: CALL_OW 70
7896: AND
7897: IFFALSE 7988
7899: GO 7901
7901: DISABLE
7902: LD_INT 0
7904: PPUSH
// begin wait ( 0 0$2 ) ;
7905: LD_INT 70
7907: PPUSH
7908: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) do
7912: LD_ADDR_VAR 0 1
7916: PUSH
7917: LD_INT 22
7919: PUSH
7920: LD_INT 1
7922: PUSH
7923: EMPTY
7924: LIST
7925: LIST
7926: PUSH
7927: LD_INT 25
7929: PUSH
7930: LD_INT 1
7932: PUSH
7933: EMPTY
7934: LIST
7935: LIST
7936: PUSH
7937: EMPTY
7938: LIST
7939: LIST
7940: PPUSH
7941: CALL_OW 69
7945: PUSH
7946: FOR_IN
7947: IFFALSE 7986
// begin if IsInUnit ( i ) then
7949: LD_VAR 0 1
7953: PPUSH
7954: CALL_OW 310
7958: IFFALSE 7969
// ComExitBuilding ( i ) ;
7960: LD_VAR 0 1
7964: PPUSH
7965: CALL_OW 122
// AddComAgressiveMove ( i , 92 , 78 ) ;
7969: LD_VAR 0 1
7973: PPUSH
7974: LD_INT 92
7976: PPUSH
7977: LD_INT 78
7979: PPUSH
7980: CALL_OW 174
// end ;
7984: GO 7946
7986: POP
7987: POP
// end ; end_of_file
7988: PPOPN 1
7990: END
// on SiberiteRocketExploded ( sibRocket , x , y ) do OnBombExploded ( sibRocket , x , y ) ;
7991: LD_VAR 0 1
7995: PPUSH
7996: LD_VAR 0 2
8000: PPUSH
8001: LD_VAR 0 3
8005: PPUSH
8006: CALL 2846 0 3
8010: PPOPN 3
8012: END
// on UnitGoesToRed ( un ) do begin if GetClass ( JMM ) = 4 or GetClass ( Burlak ) = 4 or FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_building ] ] ) then
8013: LD_EXP 14
8017: PPUSH
8018: CALL_OW 257
8022: PUSH
8023: LD_INT 4
8025: EQUAL
8026: PUSH
8027: LD_EXP 15
8031: PPUSH
8032: CALL_OW 257
8036: PUSH
8037: LD_INT 4
8039: EQUAL
8040: OR
8041: PUSH
8042: LD_INT 22
8044: PUSH
8045: LD_INT 7
8047: PUSH
8048: EMPTY
8049: LIST
8050: LIST
8051: PUSH
8052: LD_INT 21
8054: PUSH
8055: LD_INT 3
8057: PUSH
8058: EMPTY
8059: LIST
8060: LIST
8061: PUSH
8062: EMPTY
8063: LIST
8064: LIST
8065: PPUSH
8066: CALL_OW 69
8070: OR
8071: IFFALSE 8075
// exit ;
8073: GO 8113
// if un = JMM then
8075: LD_VAR 0 1
8079: PUSH
8080: LD_EXP 14
8084: EQUAL
8085: IFFALSE 8094
// YouLost ( JMM ) ;
8087: LD_STRING JMM
8089: PPUSH
8090: CALL_OW 104
// if un = Burlak then
8094: LD_VAR 0 1
8098: PUSH
8099: LD_EXP 15
8103: EQUAL
8104: IFFALSE 8113
// YouLost ( Burlak ) ;
8106: LD_STRING Burlak
8108: PPUSH
8109: CALL_OW 104
// end ;
8113: PPOPN 1
8115: END
// on UnitDestroyed ( un ) do begin if un = JMM then
8116: LD_VAR 0 1
8120: PUSH
8121: LD_EXP 14
8125: EQUAL
8126: IFFALSE 8135
// YouLost ( JMM ) ;
8128: LD_STRING JMM
8130: PPUSH
8131: CALL_OW 104
// if un = Burlak then
8135: LD_VAR 0 1
8139: PUSH
8140: LD_EXP 15
8144: EQUAL
8145: IFFALSE 8154
// YouLost ( Burlak ) ;
8147: LD_STRING Burlak
8149: PPUSH
8150: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
8154: LD_VAR 0 1
8158: PUSH
8159: LD_INT 21
8161: PUSH
8162: LD_INT 1
8164: PUSH
8165: EMPTY
8166: LIST
8167: LIST
8168: PUSH
8169: LD_INT 23
8171: PUSH
8172: LD_INT 1
8174: PUSH
8175: EMPTY
8176: LIST
8177: LIST
8178: PUSH
8179: EMPTY
8180: LIST
8181: LIST
8182: PPUSH
8183: CALL_OW 69
8187: IN
8188: IFFALSE 8204
// killCounter := killCounter + 1 ;
8190: LD_ADDR_EXP 12
8194: PUSH
8195: LD_EXP 12
8199: PUSH
8200: LD_INT 1
8202: PLUS
8203: ST_TO_ADDR
// end ;
8204: PPOPN 1
8206: END
// on UnitDestroyed_Extra ( un , killer_side , killer_unit ) do begin if killer_side = 7 and un in FilterAllUnits ( [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
8207: LD_VAR 0 2
8211: PUSH
8212: LD_INT 7
8214: EQUAL
8215: PUSH
8216: LD_VAR 0 1
8220: PUSH
8221: LD_INT 2
8223: PUSH
8224: LD_INT 30
8226: PUSH
8227: LD_INT 31
8229: PUSH
8230: EMPTY
8231: LIST
8232: LIST
8233: PUSH
8234: LD_INT 30
8236: PUSH
8237: LD_INT 32
8239: PUSH
8240: EMPTY
8241: LIST
8242: LIST
8243: PUSH
8244: LD_INT 30
8246: PUSH
8247: LD_INT 33
8249: PUSH
8250: EMPTY
8251: LIST
8252: LIST
8253: PUSH
8254: EMPTY
8255: LIST
8256: LIST
8257: LIST
8258: LIST
8259: PPUSH
8260: CALL_OW 69
8264: IN
8265: AND
8266: IFFALSE 8282
// bunkerCounter := bunkerCounter + 1 ;
8268: LD_ADDR_EXP 13
8272: PUSH
8273: LD_EXP 13
8277: PUSH
8278: LD_INT 1
8280: PLUS
8281: ST_TO_ADDR
// end ;
8282: PPOPN 3
8284: END
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 7 then
8285: LD_VAR 0 1
8289: PPUSH
8290: CALL_OW 255
8294: PUSH
8295: LD_INT 7
8297: EQUAL
8298: IFFALSE 8308
// artifactPickedUp := true ;
8300: LD_ADDR_EXP 6
8304: PUSH
8305: LD_INT 1
8307: ST_TO_ADDR
// end ;
8308: PPOPN 2
8310: END
// on ArtifactUnloaded ( cargo , artifact ) do artifactPickedUp := false ;
8311: LD_ADDR_EXP 6
8315: PUSH
8316: LD_INT 0
8318: ST_TO_ADDR
8319: PPOPN 2
8321: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( vehicle ) <> 1 then
8322: LD_VAR 0 1
8326: PPUSH
8327: CALL_OW 255
8331: PUSH
8332: LD_INT 1
8334: NONEQUAL
8335: IFFALSE 8339
// exit ;
8337: GO 8386
// wait ( 0 0$5 ) ;
8339: LD_INT 175
8341: PPUSH
8342: CALL_OW 67
// if GetControl ( vehicle ) = control_remote then
8346: LD_VAR 0 1
8350: PPUSH
8351: CALL_OW 263
8355: PUSH
8356: LD_INT 2
8358: EQUAL
8359: IFFALSE 8370
// Connect ( vehicle ) ;
8361: LD_VAR 0 1
8365: PPUSH
8366: CALL 1840 0 1
// vehGuard := vehGuard ^ vehicle ;
8370: LD_ADDR_EXP 23
8374: PUSH
8375: LD_EXP 23
8379: PUSH
8380: LD_VAR 0 1
8384: ADD
8385: ST_TO_ADDR
// end ;
8386: PPOPN 2
8388: END
// on BuildingCaptured ( captured , old_side , unit ) do begin if captured = us_lab and not planCaptured then
8389: LD_VAR 0 1
8393: PUSH
8394: LD_INT 1
8396: EQUAL
8397: PUSH
8398: LD_EXP 7
8402: NOT
8403: AND
8404: IFFALSE 8439
// begin planCaptured := true ;
8406: LD_ADDR_EXP 7
8410: PUSH
8411: LD_INT 1
8413: ST_TO_ADDR
// ChangeMissionObjectives ( MEnd ) ;
8414: LD_STRING MEnd
8416: PPUSH
8417: CALL_OW 337
// canEnd := true ;
8421: LD_ADDR_EXP 10
8425: PUSH
8426: LD_INT 1
8428: ST_TO_ADDR
// missionTime := tick ;
8429: LD_ADDR_EXP 11
8433: PUSH
8434: LD_OWVAR 1
8438: ST_TO_ADDR
// end ; end ;
8439: PPOPN 3
8441: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
8442: LD_VAR 0 1
8446: PPUSH
8447: CALL 19689 0 1
// end ; end_of_file
8451: PPOPN 1
8453: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
8454: GO 8456
8456: DISABLE
// begin ru_radar := 98 ;
8457: LD_ADDR_EXP 24
8461: PUSH
8462: LD_INT 98
8464: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
8465: LD_ADDR_EXP 25
8469: PUSH
8470: LD_INT 89
8472: ST_TO_ADDR
// us_hack := 99 ;
8473: LD_ADDR_EXP 26
8477: PUSH
8478: LD_INT 99
8480: ST_TO_ADDR
// us_artillery := 97 ;
8481: LD_ADDR_EXP 27
8485: PUSH
8486: LD_INT 97
8488: ST_TO_ADDR
// ar_bio_bomb := 91 ;
8489: LD_ADDR_EXP 28
8493: PUSH
8494: LD_INT 91
8496: ST_TO_ADDR
// tech_Artillery := 80 ;
8497: LD_ADDR_EXP 29
8501: PUSH
8502: LD_INT 80
8504: ST_TO_ADDR
// tech_RadMat := 81 ;
8505: LD_ADDR_EXP 30
8509: PUSH
8510: LD_INT 81
8512: ST_TO_ADDR
// tech_BasicTools := 82 ;
8513: LD_ADDR_EXP 31
8517: PUSH
8518: LD_INT 82
8520: ST_TO_ADDR
// tech_Cargo := 83 ;
8521: LD_ADDR_EXP 32
8525: PUSH
8526: LD_INT 83
8528: ST_TO_ADDR
// tech_Track := 84 ;
8529: LD_ADDR_EXP 33
8533: PUSH
8534: LD_INT 84
8536: ST_TO_ADDR
// tech_Crane := 85 ;
8537: LD_ADDR_EXP 34
8541: PUSH
8542: LD_INT 85
8544: ST_TO_ADDR
// tech_Bulldozer := 86 ;
8545: LD_ADDR_EXP 35
8549: PUSH
8550: LD_INT 86
8552: ST_TO_ADDR
// tech_Hovercraft := 87 ;
8553: LD_ADDR_EXP 36
8557: PUSH
8558: LD_INT 87
8560: ST_TO_ADDR
// end ; end_of_file end_of_file
8561: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
8562: GO 8564
8564: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
8565: LD_STRING initStreamRollete();
8567: PPUSH
8568: CALL_OW 559
// InitStreamMode ;
8572: CALL 8581 0 0
// DefineStreamItems ( ) ;
8576: CALL 9021 0 0
// end ;
8580: END
// function InitStreamMode ; begin
8581: LD_INT 0
8583: PPUSH
// streamModeActive := false ;
8584: LD_ADDR_EXP 37
8588: PUSH
8589: LD_INT 0
8591: ST_TO_ADDR
// normalCounter := 36 ;
8592: LD_ADDR_EXP 38
8596: PUSH
8597: LD_INT 36
8599: ST_TO_ADDR
// hardcoreCounter := 16 ;
8600: LD_ADDR_EXP 39
8604: PUSH
8605: LD_INT 16
8607: ST_TO_ADDR
// sRocket := false ;
8608: LD_ADDR_EXP 42
8612: PUSH
8613: LD_INT 0
8615: ST_TO_ADDR
// sSpeed := false ;
8616: LD_ADDR_EXP 41
8620: PUSH
8621: LD_INT 0
8623: ST_TO_ADDR
// sEngine := false ;
8624: LD_ADDR_EXP 43
8628: PUSH
8629: LD_INT 0
8631: ST_TO_ADDR
// sSpec := false ;
8632: LD_ADDR_EXP 40
8636: PUSH
8637: LD_INT 0
8639: ST_TO_ADDR
// sLevel := false ;
8640: LD_ADDR_EXP 44
8644: PUSH
8645: LD_INT 0
8647: ST_TO_ADDR
// sArmoury := false ;
8648: LD_ADDR_EXP 45
8652: PUSH
8653: LD_INT 0
8655: ST_TO_ADDR
// sRadar := false ;
8656: LD_ADDR_EXP 46
8660: PUSH
8661: LD_INT 0
8663: ST_TO_ADDR
// sBunker := false ;
8664: LD_ADDR_EXP 47
8668: PUSH
8669: LD_INT 0
8671: ST_TO_ADDR
// sHack := false ;
8672: LD_ADDR_EXP 48
8676: PUSH
8677: LD_INT 0
8679: ST_TO_ADDR
// sFire := false ;
8680: LD_ADDR_EXP 49
8684: PUSH
8685: LD_INT 0
8687: ST_TO_ADDR
// sRefresh := false ;
8688: LD_ADDR_EXP 50
8692: PUSH
8693: LD_INT 0
8695: ST_TO_ADDR
// sExp := false ;
8696: LD_ADDR_EXP 51
8700: PUSH
8701: LD_INT 0
8703: ST_TO_ADDR
// sDepot := false ;
8704: LD_ADDR_EXP 52
8708: PUSH
8709: LD_INT 0
8711: ST_TO_ADDR
// sFlag := false ;
8712: LD_ADDR_EXP 53
8716: PUSH
8717: LD_INT 0
8719: ST_TO_ADDR
// sKamikadze := false ;
8720: LD_ADDR_EXP 61
8724: PUSH
8725: LD_INT 0
8727: ST_TO_ADDR
// sTroll := false ;
8728: LD_ADDR_EXP 62
8732: PUSH
8733: LD_INT 0
8735: ST_TO_ADDR
// sSlow := false ;
8736: LD_ADDR_EXP 63
8740: PUSH
8741: LD_INT 0
8743: ST_TO_ADDR
// sLack := false ;
8744: LD_ADDR_EXP 64
8748: PUSH
8749: LD_INT 0
8751: ST_TO_ADDR
// sTank := false ;
8752: LD_ADDR_EXP 66
8756: PUSH
8757: LD_INT 0
8759: ST_TO_ADDR
// sRemote := false ;
8760: LD_ADDR_EXP 67
8764: PUSH
8765: LD_INT 0
8767: ST_TO_ADDR
// sPowell := false ;
8768: LD_ADDR_EXP 68
8772: PUSH
8773: LD_INT 0
8775: ST_TO_ADDR
// sTeleport := false ;
8776: LD_ADDR_EXP 71
8780: PUSH
8781: LD_INT 0
8783: ST_TO_ADDR
// sOilTower := false ;
8784: LD_ADDR_EXP 73
8788: PUSH
8789: LD_INT 0
8791: ST_TO_ADDR
// sShovel := false ;
8792: LD_ADDR_EXP 74
8796: PUSH
8797: LD_INT 0
8799: ST_TO_ADDR
// sSheik := false ;
8800: LD_ADDR_EXP 75
8804: PUSH
8805: LD_INT 0
8807: ST_TO_ADDR
// sEarthquake := false ;
8808: LD_ADDR_EXP 77
8812: PUSH
8813: LD_INT 0
8815: ST_TO_ADDR
// sAI := false ;
8816: LD_ADDR_EXP 78
8820: PUSH
8821: LD_INT 0
8823: ST_TO_ADDR
// sCargo := false ;
8824: LD_ADDR_EXP 81
8828: PUSH
8829: LD_INT 0
8831: ST_TO_ADDR
// sDLaser := false ;
8832: LD_ADDR_EXP 82
8836: PUSH
8837: LD_INT 0
8839: ST_TO_ADDR
// sExchange := false ;
8840: LD_ADDR_EXP 83
8844: PUSH
8845: LD_INT 0
8847: ST_TO_ADDR
// sFac := false ;
8848: LD_ADDR_EXP 84
8852: PUSH
8853: LD_INT 0
8855: ST_TO_ADDR
// sPower := false ;
8856: LD_ADDR_EXP 85
8860: PUSH
8861: LD_INT 0
8863: ST_TO_ADDR
// sRandom := false ;
8864: LD_ADDR_EXP 86
8868: PUSH
8869: LD_INT 0
8871: ST_TO_ADDR
// sShield := false ;
8872: LD_ADDR_EXP 87
8876: PUSH
8877: LD_INT 0
8879: ST_TO_ADDR
// sTime := false ;
8880: LD_ADDR_EXP 88
8884: PUSH
8885: LD_INT 0
8887: ST_TO_ADDR
// sTools := false ;
8888: LD_ADDR_EXP 89
8892: PUSH
8893: LD_INT 0
8895: ST_TO_ADDR
// sSold := false ;
8896: LD_ADDR_EXP 54
8900: PUSH
8901: LD_INT 0
8903: ST_TO_ADDR
// sDiff := false ;
8904: LD_ADDR_EXP 55
8908: PUSH
8909: LD_INT 0
8911: ST_TO_ADDR
// sFog := false ;
8912: LD_ADDR_EXP 58
8916: PUSH
8917: LD_INT 0
8919: ST_TO_ADDR
// sReset := false ;
8920: LD_ADDR_EXP 59
8924: PUSH
8925: LD_INT 0
8927: ST_TO_ADDR
// sSun := false ;
8928: LD_ADDR_EXP 60
8932: PUSH
8933: LD_INT 0
8935: ST_TO_ADDR
// sTiger := false ;
8936: LD_ADDR_EXP 56
8940: PUSH
8941: LD_INT 0
8943: ST_TO_ADDR
// sBomb := false ;
8944: LD_ADDR_EXP 57
8948: PUSH
8949: LD_INT 0
8951: ST_TO_ADDR
// sWound := false ;
8952: LD_ADDR_EXP 65
8956: PUSH
8957: LD_INT 0
8959: ST_TO_ADDR
// sBetray := false ;
8960: LD_ADDR_EXP 69
8964: PUSH
8965: LD_INT 0
8967: ST_TO_ADDR
// sContamin := false ;
8968: LD_ADDR_EXP 70
8972: PUSH
8973: LD_INT 0
8975: ST_TO_ADDR
// sOil := false ;
8976: LD_ADDR_EXP 72
8980: PUSH
8981: LD_INT 0
8983: ST_TO_ADDR
// sStu := false ;
8984: LD_ADDR_EXP 76
8988: PUSH
8989: LD_INT 0
8991: ST_TO_ADDR
// sBazooka := false ;
8992: LD_ADDR_EXP 79
8996: PUSH
8997: LD_INT 0
8999: ST_TO_ADDR
// sMortar := false ;
9000: LD_ADDR_EXP 80
9004: PUSH
9005: LD_INT 0
9007: ST_TO_ADDR
// sRanger := false ;
9008: LD_ADDR_EXP 90
9012: PUSH
9013: LD_INT 0
9015: ST_TO_ADDR
// end ;
9016: LD_VAR 0 1
9020: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
9021: LD_INT 0
9023: PPUSH
9024: PPUSH
9025: PPUSH
9026: PPUSH
9027: PPUSH
// result := [ ] ;
9028: LD_ADDR_VAR 0 1
9032: PUSH
9033: EMPTY
9034: ST_TO_ADDR
// if campaign_id = 1 then
9035: LD_OWVAR 69
9039: PUSH
9040: LD_INT 1
9042: EQUAL
9043: IFFALSE 11981
// begin case mission_number of 1 :
9045: LD_OWVAR 70
9049: PUSH
9050: LD_INT 1
9052: DOUBLE
9053: EQUAL
9054: IFTRUE 9058
9056: GO 9122
9058: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
9059: LD_ADDR_VAR 0 1
9063: PUSH
9064: LD_INT 2
9066: PUSH
9067: LD_INT 4
9069: PUSH
9070: LD_INT 11
9072: PUSH
9073: LD_INT 12
9075: PUSH
9076: LD_INT 15
9078: PUSH
9079: LD_INT 16
9081: PUSH
9082: LD_INT 22
9084: PUSH
9085: LD_INT 23
9087: PUSH
9088: LD_INT 26
9090: PUSH
9091: EMPTY
9092: LIST
9093: LIST
9094: LIST
9095: LIST
9096: LIST
9097: LIST
9098: LIST
9099: LIST
9100: LIST
9101: PUSH
9102: LD_INT 101
9104: PUSH
9105: LD_INT 102
9107: PUSH
9108: LD_INT 106
9110: PUSH
9111: EMPTY
9112: LIST
9113: LIST
9114: LIST
9115: PUSH
9116: EMPTY
9117: LIST
9118: LIST
9119: ST_TO_ADDR
9120: GO 11979
9122: LD_INT 2
9124: DOUBLE
9125: EQUAL
9126: IFTRUE 9130
9128: GO 9202
9130: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
9131: LD_ADDR_VAR 0 1
9135: PUSH
9136: LD_INT 2
9138: PUSH
9139: LD_INT 4
9141: PUSH
9142: LD_INT 11
9144: PUSH
9145: LD_INT 12
9147: PUSH
9148: LD_INT 15
9150: PUSH
9151: LD_INT 16
9153: PUSH
9154: LD_INT 22
9156: PUSH
9157: LD_INT 23
9159: PUSH
9160: LD_INT 26
9162: PUSH
9163: EMPTY
9164: LIST
9165: LIST
9166: LIST
9167: LIST
9168: LIST
9169: LIST
9170: LIST
9171: LIST
9172: LIST
9173: PUSH
9174: LD_INT 101
9176: PUSH
9177: LD_INT 102
9179: PUSH
9180: LD_INT 105
9182: PUSH
9183: LD_INT 106
9185: PUSH
9186: LD_INT 108
9188: PUSH
9189: EMPTY
9190: LIST
9191: LIST
9192: LIST
9193: LIST
9194: LIST
9195: PUSH
9196: EMPTY
9197: LIST
9198: LIST
9199: ST_TO_ADDR
9200: GO 11979
9202: LD_INT 3
9204: DOUBLE
9205: EQUAL
9206: IFTRUE 9210
9208: GO 9286
9210: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
9211: LD_ADDR_VAR 0 1
9215: PUSH
9216: LD_INT 2
9218: PUSH
9219: LD_INT 4
9221: PUSH
9222: LD_INT 5
9224: PUSH
9225: LD_INT 11
9227: PUSH
9228: LD_INT 12
9230: PUSH
9231: LD_INT 15
9233: PUSH
9234: LD_INT 16
9236: PUSH
9237: LD_INT 22
9239: PUSH
9240: LD_INT 26
9242: PUSH
9243: LD_INT 36
9245: PUSH
9246: EMPTY
9247: LIST
9248: LIST
9249: LIST
9250: LIST
9251: LIST
9252: LIST
9253: LIST
9254: LIST
9255: LIST
9256: LIST
9257: PUSH
9258: LD_INT 101
9260: PUSH
9261: LD_INT 102
9263: PUSH
9264: LD_INT 105
9266: PUSH
9267: LD_INT 106
9269: PUSH
9270: LD_INT 108
9272: PUSH
9273: EMPTY
9274: LIST
9275: LIST
9276: LIST
9277: LIST
9278: LIST
9279: PUSH
9280: EMPTY
9281: LIST
9282: LIST
9283: ST_TO_ADDR
9284: GO 11979
9286: LD_INT 4
9288: DOUBLE
9289: EQUAL
9290: IFTRUE 9294
9292: GO 9378
9294: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
9295: LD_ADDR_VAR 0 1
9299: PUSH
9300: LD_INT 2
9302: PUSH
9303: LD_INT 4
9305: PUSH
9306: LD_INT 5
9308: PUSH
9309: LD_INT 8
9311: PUSH
9312: LD_INT 11
9314: PUSH
9315: LD_INT 12
9317: PUSH
9318: LD_INT 15
9320: PUSH
9321: LD_INT 16
9323: PUSH
9324: LD_INT 22
9326: PUSH
9327: LD_INT 23
9329: PUSH
9330: LD_INT 26
9332: PUSH
9333: LD_INT 36
9335: PUSH
9336: EMPTY
9337: LIST
9338: LIST
9339: LIST
9340: LIST
9341: LIST
9342: LIST
9343: LIST
9344: LIST
9345: LIST
9346: LIST
9347: LIST
9348: LIST
9349: PUSH
9350: LD_INT 101
9352: PUSH
9353: LD_INT 102
9355: PUSH
9356: LD_INT 105
9358: PUSH
9359: LD_INT 106
9361: PUSH
9362: LD_INT 108
9364: PUSH
9365: EMPTY
9366: LIST
9367: LIST
9368: LIST
9369: LIST
9370: LIST
9371: PUSH
9372: EMPTY
9373: LIST
9374: LIST
9375: ST_TO_ADDR
9376: GO 11979
9378: LD_INT 5
9380: DOUBLE
9381: EQUAL
9382: IFTRUE 9386
9384: GO 9486
9386: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
9387: LD_ADDR_VAR 0 1
9391: PUSH
9392: LD_INT 2
9394: PUSH
9395: LD_INT 4
9397: PUSH
9398: LD_INT 5
9400: PUSH
9401: LD_INT 6
9403: PUSH
9404: LD_INT 8
9406: PUSH
9407: LD_INT 11
9409: PUSH
9410: LD_INT 12
9412: PUSH
9413: LD_INT 15
9415: PUSH
9416: LD_INT 16
9418: PUSH
9419: LD_INT 22
9421: PUSH
9422: LD_INT 23
9424: PUSH
9425: LD_INT 25
9427: PUSH
9428: LD_INT 26
9430: PUSH
9431: LD_INT 36
9433: PUSH
9434: EMPTY
9435: LIST
9436: LIST
9437: LIST
9438: LIST
9439: LIST
9440: LIST
9441: LIST
9442: LIST
9443: LIST
9444: LIST
9445: LIST
9446: LIST
9447: LIST
9448: LIST
9449: PUSH
9450: LD_INT 101
9452: PUSH
9453: LD_INT 102
9455: PUSH
9456: LD_INT 105
9458: PUSH
9459: LD_INT 106
9461: PUSH
9462: LD_INT 108
9464: PUSH
9465: LD_INT 109
9467: PUSH
9468: LD_INT 112
9470: PUSH
9471: EMPTY
9472: LIST
9473: LIST
9474: LIST
9475: LIST
9476: LIST
9477: LIST
9478: LIST
9479: PUSH
9480: EMPTY
9481: LIST
9482: LIST
9483: ST_TO_ADDR
9484: GO 11979
9486: LD_INT 6
9488: DOUBLE
9489: EQUAL
9490: IFTRUE 9494
9492: GO 9614
9494: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
9495: LD_ADDR_VAR 0 1
9499: PUSH
9500: LD_INT 2
9502: PUSH
9503: LD_INT 4
9505: PUSH
9506: LD_INT 5
9508: PUSH
9509: LD_INT 6
9511: PUSH
9512: LD_INT 8
9514: PUSH
9515: LD_INT 11
9517: PUSH
9518: LD_INT 12
9520: PUSH
9521: LD_INT 15
9523: PUSH
9524: LD_INT 16
9526: PUSH
9527: LD_INT 20
9529: PUSH
9530: LD_INT 21
9532: PUSH
9533: LD_INT 22
9535: PUSH
9536: LD_INT 23
9538: PUSH
9539: LD_INT 25
9541: PUSH
9542: LD_INT 26
9544: PUSH
9545: LD_INT 30
9547: PUSH
9548: LD_INT 31
9550: PUSH
9551: LD_INT 32
9553: PUSH
9554: LD_INT 36
9556: PUSH
9557: EMPTY
9558: LIST
9559: LIST
9560: LIST
9561: LIST
9562: LIST
9563: LIST
9564: LIST
9565: LIST
9566: LIST
9567: LIST
9568: LIST
9569: LIST
9570: LIST
9571: LIST
9572: LIST
9573: LIST
9574: LIST
9575: LIST
9576: LIST
9577: PUSH
9578: LD_INT 101
9580: PUSH
9581: LD_INT 102
9583: PUSH
9584: LD_INT 105
9586: PUSH
9587: LD_INT 106
9589: PUSH
9590: LD_INT 108
9592: PUSH
9593: LD_INT 109
9595: PUSH
9596: LD_INT 112
9598: PUSH
9599: EMPTY
9600: LIST
9601: LIST
9602: LIST
9603: LIST
9604: LIST
9605: LIST
9606: LIST
9607: PUSH
9608: EMPTY
9609: LIST
9610: LIST
9611: ST_TO_ADDR
9612: GO 11979
9614: LD_INT 7
9616: DOUBLE
9617: EQUAL
9618: IFTRUE 9622
9620: GO 9722
9622: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
9623: LD_ADDR_VAR 0 1
9627: PUSH
9628: LD_INT 2
9630: PUSH
9631: LD_INT 4
9633: PUSH
9634: LD_INT 5
9636: PUSH
9637: LD_INT 7
9639: PUSH
9640: LD_INT 11
9642: PUSH
9643: LD_INT 12
9645: PUSH
9646: LD_INT 15
9648: PUSH
9649: LD_INT 16
9651: PUSH
9652: LD_INT 20
9654: PUSH
9655: LD_INT 21
9657: PUSH
9658: LD_INT 22
9660: PUSH
9661: LD_INT 23
9663: PUSH
9664: LD_INT 25
9666: PUSH
9667: LD_INT 26
9669: PUSH
9670: EMPTY
9671: LIST
9672: LIST
9673: LIST
9674: LIST
9675: LIST
9676: LIST
9677: LIST
9678: LIST
9679: LIST
9680: LIST
9681: LIST
9682: LIST
9683: LIST
9684: LIST
9685: PUSH
9686: LD_INT 101
9688: PUSH
9689: LD_INT 102
9691: PUSH
9692: LD_INT 103
9694: PUSH
9695: LD_INT 105
9697: PUSH
9698: LD_INT 106
9700: PUSH
9701: LD_INT 108
9703: PUSH
9704: LD_INT 112
9706: PUSH
9707: EMPTY
9708: LIST
9709: LIST
9710: LIST
9711: LIST
9712: LIST
9713: LIST
9714: LIST
9715: PUSH
9716: EMPTY
9717: LIST
9718: LIST
9719: ST_TO_ADDR
9720: GO 11979
9722: LD_INT 8
9724: DOUBLE
9725: EQUAL
9726: IFTRUE 9730
9728: GO 9858
9730: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
9731: LD_ADDR_VAR 0 1
9735: PUSH
9736: LD_INT 2
9738: PUSH
9739: LD_INT 4
9741: PUSH
9742: LD_INT 5
9744: PUSH
9745: LD_INT 6
9747: PUSH
9748: LD_INT 7
9750: PUSH
9751: LD_INT 8
9753: PUSH
9754: LD_INT 11
9756: PUSH
9757: LD_INT 12
9759: PUSH
9760: LD_INT 15
9762: PUSH
9763: LD_INT 16
9765: PUSH
9766: LD_INT 20
9768: PUSH
9769: LD_INT 21
9771: PUSH
9772: LD_INT 22
9774: PUSH
9775: LD_INT 23
9777: PUSH
9778: LD_INT 25
9780: PUSH
9781: LD_INT 26
9783: PUSH
9784: LD_INT 30
9786: PUSH
9787: LD_INT 31
9789: PUSH
9790: LD_INT 32
9792: PUSH
9793: LD_INT 36
9795: PUSH
9796: EMPTY
9797: LIST
9798: LIST
9799: LIST
9800: LIST
9801: LIST
9802: LIST
9803: LIST
9804: LIST
9805: LIST
9806: LIST
9807: LIST
9808: LIST
9809: LIST
9810: LIST
9811: LIST
9812: LIST
9813: LIST
9814: LIST
9815: LIST
9816: LIST
9817: PUSH
9818: LD_INT 101
9820: PUSH
9821: LD_INT 102
9823: PUSH
9824: LD_INT 103
9826: PUSH
9827: LD_INT 105
9829: PUSH
9830: LD_INT 106
9832: PUSH
9833: LD_INT 108
9835: PUSH
9836: LD_INT 109
9838: PUSH
9839: LD_INT 112
9841: PUSH
9842: EMPTY
9843: LIST
9844: LIST
9845: LIST
9846: LIST
9847: LIST
9848: LIST
9849: LIST
9850: LIST
9851: PUSH
9852: EMPTY
9853: LIST
9854: LIST
9855: ST_TO_ADDR
9856: GO 11979
9858: LD_INT 9
9860: DOUBLE
9861: EQUAL
9862: IFTRUE 9866
9864: GO 10002
9866: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
9867: LD_ADDR_VAR 0 1
9871: PUSH
9872: LD_INT 2
9874: PUSH
9875: LD_INT 4
9877: PUSH
9878: LD_INT 5
9880: PUSH
9881: LD_INT 6
9883: PUSH
9884: LD_INT 7
9886: PUSH
9887: LD_INT 8
9889: PUSH
9890: LD_INT 11
9892: PUSH
9893: LD_INT 12
9895: PUSH
9896: LD_INT 15
9898: PUSH
9899: LD_INT 16
9901: PUSH
9902: LD_INT 20
9904: PUSH
9905: LD_INT 21
9907: PUSH
9908: LD_INT 22
9910: PUSH
9911: LD_INT 23
9913: PUSH
9914: LD_INT 25
9916: PUSH
9917: LD_INT 26
9919: PUSH
9920: LD_INT 28
9922: PUSH
9923: LD_INT 30
9925: PUSH
9926: LD_INT 31
9928: PUSH
9929: LD_INT 32
9931: PUSH
9932: LD_INT 36
9934: PUSH
9935: EMPTY
9936: LIST
9937: LIST
9938: LIST
9939: LIST
9940: LIST
9941: LIST
9942: LIST
9943: LIST
9944: LIST
9945: LIST
9946: LIST
9947: LIST
9948: LIST
9949: LIST
9950: LIST
9951: LIST
9952: LIST
9953: LIST
9954: LIST
9955: LIST
9956: LIST
9957: PUSH
9958: LD_INT 101
9960: PUSH
9961: LD_INT 102
9963: PUSH
9964: LD_INT 103
9966: PUSH
9967: LD_INT 105
9969: PUSH
9970: LD_INT 106
9972: PUSH
9973: LD_INT 108
9975: PUSH
9976: LD_INT 109
9978: PUSH
9979: LD_INT 112
9981: PUSH
9982: LD_INT 114
9984: PUSH
9985: EMPTY
9986: LIST
9987: LIST
9988: LIST
9989: LIST
9990: LIST
9991: LIST
9992: LIST
9993: LIST
9994: LIST
9995: PUSH
9996: EMPTY
9997: LIST
9998: LIST
9999: ST_TO_ADDR
10000: GO 11979
10002: LD_INT 10
10004: DOUBLE
10005: EQUAL
10006: IFTRUE 10010
10008: GO 10194
10010: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
10011: LD_ADDR_VAR 0 1
10015: PUSH
10016: LD_INT 2
10018: PUSH
10019: LD_INT 4
10021: PUSH
10022: LD_INT 5
10024: PUSH
10025: LD_INT 6
10027: PUSH
10028: LD_INT 7
10030: PUSH
10031: LD_INT 8
10033: PUSH
10034: LD_INT 9
10036: PUSH
10037: LD_INT 10
10039: PUSH
10040: LD_INT 11
10042: PUSH
10043: LD_INT 12
10045: PUSH
10046: LD_INT 13
10048: PUSH
10049: LD_INT 14
10051: PUSH
10052: LD_INT 15
10054: PUSH
10055: LD_INT 16
10057: PUSH
10058: LD_INT 17
10060: PUSH
10061: LD_INT 18
10063: PUSH
10064: LD_INT 19
10066: PUSH
10067: LD_INT 20
10069: PUSH
10070: LD_INT 21
10072: PUSH
10073: LD_INT 22
10075: PUSH
10076: LD_INT 23
10078: PUSH
10079: LD_INT 24
10081: PUSH
10082: LD_INT 25
10084: PUSH
10085: LD_INT 26
10087: PUSH
10088: LD_INT 28
10090: PUSH
10091: LD_INT 30
10093: PUSH
10094: LD_INT 31
10096: PUSH
10097: LD_INT 32
10099: PUSH
10100: LD_INT 36
10102: PUSH
10103: EMPTY
10104: LIST
10105: LIST
10106: LIST
10107: LIST
10108: LIST
10109: LIST
10110: LIST
10111: LIST
10112: LIST
10113: LIST
10114: LIST
10115: LIST
10116: LIST
10117: LIST
10118: LIST
10119: LIST
10120: LIST
10121: LIST
10122: LIST
10123: LIST
10124: LIST
10125: LIST
10126: LIST
10127: LIST
10128: LIST
10129: LIST
10130: LIST
10131: LIST
10132: LIST
10133: PUSH
10134: LD_INT 101
10136: PUSH
10137: LD_INT 102
10139: PUSH
10140: LD_INT 103
10142: PUSH
10143: LD_INT 104
10145: PUSH
10146: LD_INT 105
10148: PUSH
10149: LD_INT 106
10151: PUSH
10152: LD_INT 107
10154: PUSH
10155: LD_INT 108
10157: PUSH
10158: LD_INT 109
10160: PUSH
10161: LD_INT 110
10163: PUSH
10164: LD_INT 111
10166: PUSH
10167: LD_INT 112
10169: PUSH
10170: LD_INT 114
10172: PUSH
10173: EMPTY
10174: LIST
10175: LIST
10176: LIST
10177: LIST
10178: LIST
10179: LIST
10180: LIST
10181: LIST
10182: LIST
10183: LIST
10184: LIST
10185: LIST
10186: LIST
10187: PUSH
10188: EMPTY
10189: LIST
10190: LIST
10191: ST_TO_ADDR
10192: GO 11979
10194: LD_INT 11
10196: DOUBLE
10197: EQUAL
10198: IFTRUE 10202
10200: GO 10394
10202: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
10203: LD_ADDR_VAR 0 1
10207: PUSH
10208: LD_INT 2
10210: PUSH
10211: LD_INT 3
10213: PUSH
10214: LD_INT 4
10216: PUSH
10217: LD_INT 5
10219: PUSH
10220: LD_INT 6
10222: PUSH
10223: LD_INT 7
10225: PUSH
10226: LD_INT 8
10228: PUSH
10229: LD_INT 9
10231: PUSH
10232: LD_INT 10
10234: PUSH
10235: LD_INT 11
10237: PUSH
10238: LD_INT 12
10240: PUSH
10241: LD_INT 13
10243: PUSH
10244: LD_INT 14
10246: PUSH
10247: LD_INT 15
10249: PUSH
10250: LD_INT 16
10252: PUSH
10253: LD_INT 17
10255: PUSH
10256: LD_INT 18
10258: PUSH
10259: LD_INT 19
10261: PUSH
10262: LD_INT 20
10264: PUSH
10265: LD_INT 21
10267: PUSH
10268: LD_INT 22
10270: PUSH
10271: LD_INT 23
10273: PUSH
10274: LD_INT 24
10276: PUSH
10277: LD_INT 25
10279: PUSH
10280: LD_INT 26
10282: PUSH
10283: LD_INT 28
10285: PUSH
10286: LD_INT 30
10288: PUSH
10289: LD_INT 31
10291: PUSH
10292: LD_INT 32
10294: PUSH
10295: LD_INT 34
10297: PUSH
10298: LD_INT 36
10300: PUSH
10301: EMPTY
10302: LIST
10303: LIST
10304: LIST
10305: LIST
10306: LIST
10307: LIST
10308: LIST
10309: LIST
10310: LIST
10311: LIST
10312: LIST
10313: LIST
10314: LIST
10315: LIST
10316: LIST
10317: LIST
10318: LIST
10319: LIST
10320: LIST
10321: LIST
10322: LIST
10323: LIST
10324: LIST
10325: LIST
10326: LIST
10327: LIST
10328: LIST
10329: LIST
10330: LIST
10331: LIST
10332: LIST
10333: PUSH
10334: LD_INT 101
10336: PUSH
10337: LD_INT 102
10339: PUSH
10340: LD_INT 103
10342: PUSH
10343: LD_INT 104
10345: PUSH
10346: LD_INT 105
10348: PUSH
10349: LD_INT 106
10351: PUSH
10352: LD_INT 107
10354: PUSH
10355: LD_INT 108
10357: PUSH
10358: LD_INT 109
10360: PUSH
10361: LD_INT 110
10363: PUSH
10364: LD_INT 111
10366: PUSH
10367: LD_INT 112
10369: PUSH
10370: LD_INT 114
10372: PUSH
10373: EMPTY
10374: LIST
10375: LIST
10376: LIST
10377: LIST
10378: LIST
10379: LIST
10380: LIST
10381: LIST
10382: LIST
10383: LIST
10384: LIST
10385: LIST
10386: LIST
10387: PUSH
10388: EMPTY
10389: LIST
10390: LIST
10391: ST_TO_ADDR
10392: GO 11979
10394: LD_INT 12
10396: DOUBLE
10397: EQUAL
10398: IFTRUE 10402
10400: GO 10610
10402: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
10403: LD_ADDR_VAR 0 1
10407: PUSH
10408: LD_INT 1
10410: PUSH
10411: LD_INT 2
10413: PUSH
10414: LD_INT 3
10416: PUSH
10417: LD_INT 4
10419: PUSH
10420: LD_INT 5
10422: PUSH
10423: LD_INT 6
10425: PUSH
10426: LD_INT 7
10428: PUSH
10429: LD_INT 8
10431: PUSH
10432: LD_INT 9
10434: PUSH
10435: LD_INT 10
10437: PUSH
10438: LD_INT 11
10440: PUSH
10441: LD_INT 12
10443: PUSH
10444: LD_INT 13
10446: PUSH
10447: LD_INT 14
10449: PUSH
10450: LD_INT 15
10452: PUSH
10453: LD_INT 16
10455: PUSH
10456: LD_INT 17
10458: PUSH
10459: LD_INT 18
10461: PUSH
10462: LD_INT 19
10464: PUSH
10465: LD_INT 20
10467: PUSH
10468: LD_INT 21
10470: PUSH
10471: LD_INT 22
10473: PUSH
10474: LD_INT 23
10476: PUSH
10477: LD_INT 24
10479: PUSH
10480: LD_INT 25
10482: PUSH
10483: LD_INT 26
10485: PUSH
10486: LD_INT 27
10488: PUSH
10489: LD_INT 28
10491: PUSH
10492: LD_INT 30
10494: PUSH
10495: LD_INT 31
10497: PUSH
10498: LD_INT 32
10500: PUSH
10501: LD_INT 33
10503: PUSH
10504: LD_INT 34
10506: PUSH
10507: LD_INT 36
10509: PUSH
10510: EMPTY
10511: LIST
10512: LIST
10513: LIST
10514: LIST
10515: LIST
10516: LIST
10517: LIST
10518: LIST
10519: LIST
10520: LIST
10521: LIST
10522: LIST
10523: LIST
10524: LIST
10525: LIST
10526: LIST
10527: LIST
10528: LIST
10529: LIST
10530: LIST
10531: LIST
10532: LIST
10533: LIST
10534: LIST
10535: LIST
10536: LIST
10537: LIST
10538: LIST
10539: LIST
10540: LIST
10541: LIST
10542: LIST
10543: LIST
10544: LIST
10545: PUSH
10546: LD_INT 101
10548: PUSH
10549: LD_INT 102
10551: PUSH
10552: LD_INT 103
10554: PUSH
10555: LD_INT 104
10557: PUSH
10558: LD_INT 105
10560: PUSH
10561: LD_INT 106
10563: PUSH
10564: LD_INT 107
10566: PUSH
10567: LD_INT 108
10569: PUSH
10570: LD_INT 109
10572: PUSH
10573: LD_INT 110
10575: PUSH
10576: LD_INT 111
10578: PUSH
10579: LD_INT 112
10581: PUSH
10582: LD_INT 113
10584: PUSH
10585: LD_INT 114
10587: PUSH
10588: EMPTY
10589: LIST
10590: LIST
10591: LIST
10592: LIST
10593: LIST
10594: LIST
10595: LIST
10596: LIST
10597: LIST
10598: LIST
10599: LIST
10600: LIST
10601: LIST
10602: LIST
10603: PUSH
10604: EMPTY
10605: LIST
10606: LIST
10607: ST_TO_ADDR
10608: GO 11979
10610: LD_INT 13
10612: DOUBLE
10613: EQUAL
10614: IFTRUE 10618
10616: GO 10814
10618: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
10619: LD_ADDR_VAR 0 1
10623: PUSH
10624: LD_INT 1
10626: PUSH
10627: LD_INT 2
10629: PUSH
10630: LD_INT 3
10632: PUSH
10633: LD_INT 4
10635: PUSH
10636: LD_INT 5
10638: PUSH
10639: LD_INT 8
10641: PUSH
10642: LD_INT 9
10644: PUSH
10645: LD_INT 10
10647: PUSH
10648: LD_INT 11
10650: PUSH
10651: LD_INT 12
10653: PUSH
10654: LD_INT 14
10656: PUSH
10657: LD_INT 15
10659: PUSH
10660: LD_INT 16
10662: PUSH
10663: LD_INT 17
10665: PUSH
10666: LD_INT 18
10668: PUSH
10669: LD_INT 19
10671: PUSH
10672: LD_INT 20
10674: PUSH
10675: LD_INT 21
10677: PUSH
10678: LD_INT 22
10680: PUSH
10681: LD_INT 23
10683: PUSH
10684: LD_INT 24
10686: PUSH
10687: LD_INT 25
10689: PUSH
10690: LD_INT 26
10692: PUSH
10693: LD_INT 27
10695: PUSH
10696: LD_INT 28
10698: PUSH
10699: LD_INT 30
10701: PUSH
10702: LD_INT 31
10704: PUSH
10705: LD_INT 32
10707: PUSH
10708: LD_INT 33
10710: PUSH
10711: LD_INT 34
10713: PUSH
10714: LD_INT 36
10716: PUSH
10717: EMPTY
10718: LIST
10719: LIST
10720: LIST
10721: LIST
10722: LIST
10723: LIST
10724: LIST
10725: LIST
10726: LIST
10727: LIST
10728: LIST
10729: LIST
10730: LIST
10731: LIST
10732: LIST
10733: LIST
10734: LIST
10735: LIST
10736: LIST
10737: LIST
10738: LIST
10739: LIST
10740: LIST
10741: LIST
10742: LIST
10743: LIST
10744: LIST
10745: LIST
10746: LIST
10747: LIST
10748: LIST
10749: PUSH
10750: LD_INT 101
10752: PUSH
10753: LD_INT 102
10755: PUSH
10756: LD_INT 103
10758: PUSH
10759: LD_INT 104
10761: PUSH
10762: LD_INT 105
10764: PUSH
10765: LD_INT 106
10767: PUSH
10768: LD_INT 107
10770: PUSH
10771: LD_INT 108
10773: PUSH
10774: LD_INT 109
10776: PUSH
10777: LD_INT 110
10779: PUSH
10780: LD_INT 111
10782: PUSH
10783: LD_INT 112
10785: PUSH
10786: LD_INT 113
10788: PUSH
10789: LD_INT 114
10791: PUSH
10792: EMPTY
10793: LIST
10794: LIST
10795: LIST
10796: LIST
10797: LIST
10798: LIST
10799: LIST
10800: LIST
10801: LIST
10802: LIST
10803: LIST
10804: LIST
10805: LIST
10806: LIST
10807: PUSH
10808: EMPTY
10809: LIST
10810: LIST
10811: ST_TO_ADDR
10812: GO 11979
10814: LD_INT 14
10816: DOUBLE
10817: EQUAL
10818: IFTRUE 10822
10820: GO 11034
10822: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
10823: LD_ADDR_VAR 0 1
10827: PUSH
10828: LD_INT 1
10830: PUSH
10831: LD_INT 2
10833: PUSH
10834: LD_INT 3
10836: PUSH
10837: LD_INT 4
10839: PUSH
10840: LD_INT 5
10842: PUSH
10843: LD_INT 6
10845: PUSH
10846: LD_INT 7
10848: PUSH
10849: LD_INT 8
10851: PUSH
10852: LD_INT 9
10854: PUSH
10855: LD_INT 10
10857: PUSH
10858: LD_INT 11
10860: PUSH
10861: LD_INT 12
10863: PUSH
10864: LD_INT 13
10866: PUSH
10867: LD_INT 14
10869: PUSH
10870: LD_INT 15
10872: PUSH
10873: LD_INT 16
10875: PUSH
10876: LD_INT 17
10878: PUSH
10879: LD_INT 18
10881: PUSH
10882: LD_INT 19
10884: PUSH
10885: LD_INT 20
10887: PUSH
10888: LD_INT 21
10890: PUSH
10891: LD_INT 22
10893: PUSH
10894: LD_INT 23
10896: PUSH
10897: LD_INT 24
10899: PUSH
10900: LD_INT 25
10902: PUSH
10903: LD_INT 26
10905: PUSH
10906: LD_INT 27
10908: PUSH
10909: LD_INT 28
10911: PUSH
10912: LD_INT 29
10914: PUSH
10915: LD_INT 30
10917: PUSH
10918: LD_INT 31
10920: PUSH
10921: LD_INT 32
10923: PUSH
10924: LD_INT 33
10926: PUSH
10927: LD_INT 34
10929: PUSH
10930: LD_INT 36
10932: PUSH
10933: EMPTY
10934: LIST
10935: LIST
10936: LIST
10937: LIST
10938: LIST
10939: LIST
10940: LIST
10941: LIST
10942: LIST
10943: LIST
10944: LIST
10945: LIST
10946: LIST
10947: LIST
10948: LIST
10949: LIST
10950: LIST
10951: LIST
10952: LIST
10953: LIST
10954: LIST
10955: LIST
10956: LIST
10957: LIST
10958: LIST
10959: LIST
10960: LIST
10961: LIST
10962: LIST
10963: LIST
10964: LIST
10965: LIST
10966: LIST
10967: LIST
10968: LIST
10969: PUSH
10970: LD_INT 101
10972: PUSH
10973: LD_INT 102
10975: PUSH
10976: LD_INT 103
10978: PUSH
10979: LD_INT 104
10981: PUSH
10982: LD_INT 105
10984: PUSH
10985: LD_INT 106
10987: PUSH
10988: LD_INT 107
10990: PUSH
10991: LD_INT 108
10993: PUSH
10994: LD_INT 109
10996: PUSH
10997: LD_INT 110
10999: PUSH
11000: LD_INT 111
11002: PUSH
11003: LD_INT 112
11005: PUSH
11006: LD_INT 113
11008: PUSH
11009: LD_INT 114
11011: PUSH
11012: EMPTY
11013: LIST
11014: LIST
11015: LIST
11016: LIST
11017: LIST
11018: LIST
11019: LIST
11020: LIST
11021: LIST
11022: LIST
11023: LIST
11024: LIST
11025: LIST
11026: LIST
11027: PUSH
11028: EMPTY
11029: LIST
11030: LIST
11031: ST_TO_ADDR
11032: GO 11979
11034: LD_INT 15
11036: DOUBLE
11037: EQUAL
11038: IFTRUE 11042
11040: GO 11254
11042: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
11043: LD_ADDR_VAR 0 1
11047: PUSH
11048: LD_INT 1
11050: PUSH
11051: LD_INT 2
11053: PUSH
11054: LD_INT 3
11056: PUSH
11057: LD_INT 4
11059: PUSH
11060: LD_INT 5
11062: PUSH
11063: LD_INT 6
11065: PUSH
11066: LD_INT 7
11068: PUSH
11069: LD_INT 8
11071: PUSH
11072: LD_INT 9
11074: PUSH
11075: LD_INT 10
11077: PUSH
11078: LD_INT 11
11080: PUSH
11081: LD_INT 12
11083: PUSH
11084: LD_INT 13
11086: PUSH
11087: LD_INT 14
11089: PUSH
11090: LD_INT 15
11092: PUSH
11093: LD_INT 16
11095: PUSH
11096: LD_INT 17
11098: PUSH
11099: LD_INT 18
11101: PUSH
11102: LD_INT 19
11104: PUSH
11105: LD_INT 20
11107: PUSH
11108: LD_INT 21
11110: PUSH
11111: LD_INT 22
11113: PUSH
11114: LD_INT 23
11116: PUSH
11117: LD_INT 24
11119: PUSH
11120: LD_INT 25
11122: PUSH
11123: LD_INT 26
11125: PUSH
11126: LD_INT 27
11128: PUSH
11129: LD_INT 28
11131: PUSH
11132: LD_INT 29
11134: PUSH
11135: LD_INT 30
11137: PUSH
11138: LD_INT 31
11140: PUSH
11141: LD_INT 32
11143: PUSH
11144: LD_INT 33
11146: PUSH
11147: LD_INT 34
11149: PUSH
11150: LD_INT 36
11152: PUSH
11153: EMPTY
11154: LIST
11155: LIST
11156: LIST
11157: LIST
11158: LIST
11159: LIST
11160: LIST
11161: LIST
11162: LIST
11163: LIST
11164: LIST
11165: LIST
11166: LIST
11167: LIST
11168: LIST
11169: LIST
11170: LIST
11171: LIST
11172: LIST
11173: LIST
11174: LIST
11175: LIST
11176: LIST
11177: LIST
11178: LIST
11179: LIST
11180: LIST
11181: LIST
11182: LIST
11183: LIST
11184: LIST
11185: LIST
11186: LIST
11187: LIST
11188: LIST
11189: PUSH
11190: LD_INT 101
11192: PUSH
11193: LD_INT 102
11195: PUSH
11196: LD_INT 103
11198: PUSH
11199: LD_INT 104
11201: PUSH
11202: LD_INT 105
11204: PUSH
11205: LD_INT 106
11207: PUSH
11208: LD_INT 107
11210: PUSH
11211: LD_INT 108
11213: PUSH
11214: LD_INT 109
11216: PUSH
11217: LD_INT 110
11219: PUSH
11220: LD_INT 111
11222: PUSH
11223: LD_INT 112
11225: PUSH
11226: LD_INT 113
11228: PUSH
11229: LD_INT 114
11231: PUSH
11232: EMPTY
11233: LIST
11234: LIST
11235: LIST
11236: LIST
11237: LIST
11238: LIST
11239: LIST
11240: LIST
11241: LIST
11242: LIST
11243: LIST
11244: LIST
11245: LIST
11246: LIST
11247: PUSH
11248: EMPTY
11249: LIST
11250: LIST
11251: ST_TO_ADDR
11252: GO 11979
11254: LD_INT 16
11256: DOUBLE
11257: EQUAL
11258: IFTRUE 11262
11260: GO 11386
11262: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
11263: LD_ADDR_VAR 0 1
11267: PUSH
11268: LD_INT 2
11270: PUSH
11271: LD_INT 4
11273: PUSH
11274: LD_INT 5
11276: PUSH
11277: LD_INT 7
11279: PUSH
11280: LD_INT 11
11282: PUSH
11283: LD_INT 12
11285: PUSH
11286: LD_INT 15
11288: PUSH
11289: LD_INT 16
11291: PUSH
11292: LD_INT 20
11294: PUSH
11295: LD_INT 21
11297: PUSH
11298: LD_INT 22
11300: PUSH
11301: LD_INT 23
11303: PUSH
11304: LD_INT 25
11306: PUSH
11307: LD_INT 26
11309: PUSH
11310: LD_INT 30
11312: PUSH
11313: LD_INT 31
11315: PUSH
11316: LD_INT 32
11318: PUSH
11319: LD_INT 33
11321: PUSH
11322: LD_INT 34
11324: PUSH
11325: EMPTY
11326: LIST
11327: LIST
11328: LIST
11329: LIST
11330: LIST
11331: LIST
11332: LIST
11333: LIST
11334: LIST
11335: LIST
11336: LIST
11337: LIST
11338: LIST
11339: LIST
11340: LIST
11341: LIST
11342: LIST
11343: LIST
11344: LIST
11345: PUSH
11346: LD_INT 101
11348: PUSH
11349: LD_INT 102
11351: PUSH
11352: LD_INT 103
11354: PUSH
11355: LD_INT 106
11357: PUSH
11358: LD_INT 108
11360: PUSH
11361: LD_INT 112
11363: PUSH
11364: LD_INT 113
11366: PUSH
11367: LD_INT 114
11369: PUSH
11370: EMPTY
11371: LIST
11372: LIST
11373: LIST
11374: LIST
11375: LIST
11376: LIST
11377: LIST
11378: LIST
11379: PUSH
11380: EMPTY
11381: LIST
11382: LIST
11383: ST_TO_ADDR
11384: GO 11979
11386: LD_INT 17
11388: DOUBLE
11389: EQUAL
11390: IFTRUE 11394
11392: GO 11606
11394: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
11395: LD_ADDR_VAR 0 1
11399: PUSH
11400: LD_INT 1
11402: PUSH
11403: LD_INT 2
11405: PUSH
11406: LD_INT 3
11408: PUSH
11409: LD_INT 4
11411: PUSH
11412: LD_INT 5
11414: PUSH
11415: LD_INT 6
11417: PUSH
11418: LD_INT 7
11420: PUSH
11421: LD_INT 8
11423: PUSH
11424: LD_INT 9
11426: PUSH
11427: LD_INT 10
11429: PUSH
11430: LD_INT 11
11432: PUSH
11433: LD_INT 12
11435: PUSH
11436: LD_INT 13
11438: PUSH
11439: LD_INT 14
11441: PUSH
11442: LD_INT 15
11444: PUSH
11445: LD_INT 16
11447: PUSH
11448: LD_INT 17
11450: PUSH
11451: LD_INT 18
11453: PUSH
11454: LD_INT 19
11456: PUSH
11457: LD_INT 20
11459: PUSH
11460: LD_INT 21
11462: PUSH
11463: LD_INT 22
11465: PUSH
11466: LD_INT 23
11468: PUSH
11469: LD_INT 24
11471: PUSH
11472: LD_INT 25
11474: PUSH
11475: LD_INT 26
11477: PUSH
11478: LD_INT 27
11480: PUSH
11481: LD_INT 28
11483: PUSH
11484: LD_INT 29
11486: PUSH
11487: LD_INT 30
11489: PUSH
11490: LD_INT 31
11492: PUSH
11493: LD_INT 32
11495: PUSH
11496: LD_INT 33
11498: PUSH
11499: LD_INT 34
11501: PUSH
11502: LD_INT 36
11504: PUSH
11505: EMPTY
11506: LIST
11507: LIST
11508: LIST
11509: LIST
11510: LIST
11511: LIST
11512: LIST
11513: LIST
11514: LIST
11515: LIST
11516: LIST
11517: LIST
11518: LIST
11519: LIST
11520: LIST
11521: LIST
11522: LIST
11523: LIST
11524: LIST
11525: LIST
11526: LIST
11527: LIST
11528: LIST
11529: LIST
11530: LIST
11531: LIST
11532: LIST
11533: LIST
11534: LIST
11535: LIST
11536: LIST
11537: LIST
11538: LIST
11539: LIST
11540: LIST
11541: PUSH
11542: LD_INT 101
11544: PUSH
11545: LD_INT 102
11547: PUSH
11548: LD_INT 103
11550: PUSH
11551: LD_INT 104
11553: PUSH
11554: LD_INT 105
11556: PUSH
11557: LD_INT 106
11559: PUSH
11560: LD_INT 107
11562: PUSH
11563: LD_INT 108
11565: PUSH
11566: LD_INT 109
11568: PUSH
11569: LD_INT 110
11571: PUSH
11572: LD_INT 111
11574: PUSH
11575: LD_INT 112
11577: PUSH
11578: LD_INT 113
11580: PUSH
11581: LD_INT 114
11583: PUSH
11584: EMPTY
11585: LIST
11586: LIST
11587: LIST
11588: LIST
11589: LIST
11590: LIST
11591: LIST
11592: LIST
11593: LIST
11594: LIST
11595: LIST
11596: LIST
11597: LIST
11598: LIST
11599: PUSH
11600: EMPTY
11601: LIST
11602: LIST
11603: ST_TO_ADDR
11604: GO 11979
11606: LD_INT 18
11608: DOUBLE
11609: EQUAL
11610: IFTRUE 11614
11612: GO 11750
11614: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
11615: LD_ADDR_VAR 0 1
11619: PUSH
11620: LD_INT 2
11622: PUSH
11623: LD_INT 4
11625: PUSH
11626: LD_INT 5
11628: PUSH
11629: LD_INT 7
11631: PUSH
11632: LD_INT 11
11634: PUSH
11635: LD_INT 12
11637: PUSH
11638: LD_INT 15
11640: PUSH
11641: LD_INT 16
11643: PUSH
11644: LD_INT 20
11646: PUSH
11647: LD_INT 21
11649: PUSH
11650: LD_INT 22
11652: PUSH
11653: LD_INT 23
11655: PUSH
11656: LD_INT 25
11658: PUSH
11659: LD_INT 26
11661: PUSH
11662: LD_INT 30
11664: PUSH
11665: LD_INT 31
11667: PUSH
11668: LD_INT 32
11670: PUSH
11671: LD_INT 33
11673: PUSH
11674: LD_INT 34
11676: PUSH
11677: LD_INT 35
11679: PUSH
11680: LD_INT 36
11682: PUSH
11683: EMPTY
11684: LIST
11685: LIST
11686: LIST
11687: LIST
11688: LIST
11689: LIST
11690: LIST
11691: LIST
11692: LIST
11693: LIST
11694: LIST
11695: LIST
11696: LIST
11697: LIST
11698: LIST
11699: LIST
11700: LIST
11701: LIST
11702: LIST
11703: LIST
11704: LIST
11705: PUSH
11706: LD_INT 101
11708: PUSH
11709: LD_INT 102
11711: PUSH
11712: LD_INT 103
11714: PUSH
11715: LD_INT 106
11717: PUSH
11718: LD_INT 108
11720: PUSH
11721: LD_INT 112
11723: PUSH
11724: LD_INT 113
11726: PUSH
11727: LD_INT 114
11729: PUSH
11730: LD_INT 115
11732: PUSH
11733: EMPTY
11734: LIST
11735: LIST
11736: LIST
11737: LIST
11738: LIST
11739: LIST
11740: LIST
11741: LIST
11742: LIST
11743: PUSH
11744: EMPTY
11745: LIST
11746: LIST
11747: ST_TO_ADDR
11748: GO 11979
11750: LD_INT 19
11752: DOUBLE
11753: EQUAL
11754: IFTRUE 11758
11756: GO 11978
11758: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
11759: LD_ADDR_VAR 0 1
11763: PUSH
11764: LD_INT 1
11766: PUSH
11767: LD_INT 2
11769: PUSH
11770: LD_INT 3
11772: PUSH
11773: LD_INT 4
11775: PUSH
11776: LD_INT 5
11778: PUSH
11779: LD_INT 6
11781: PUSH
11782: LD_INT 7
11784: PUSH
11785: LD_INT 8
11787: PUSH
11788: LD_INT 9
11790: PUSH
11791: LD_INT 10
11793: PUSH
11794: LD_INT 11
11796: PUSH
11797: LD_INT 12
11799: PUSH
11800: LD_INT 13
11802: PUSH
11803: LD_INT 14
11805: PUSH
11806: LD_INT 15
11808: PUSH
11809: LD_INT 16
11811: PUSH
11812: LD_INT 17
11814: PUSH
11815: LD_INT 18
11817: PUSH
11818: LD_INT 19
11820: PUSH
11821: LD_INT 20
11823: PUSH
11824: LD_INT 21
11826: PUSH
11827: LD_INT 22
11829: PUSH
11830: LD_INT 23
11832: PUSH
11833: LD_INT 24
11835: PUSH
11836: LD_INT 25
11838: PUSH
11839: LD_INT 26
11841: PUSH
11842: LD_INT 27
11844: PUSH
11845: LD_INT 28
11847: PUSH
11848: LD_INT 29
11850: PUSH
11851: LD_INT 30
11853: PUSH
11854: LD_INT 31
11856: PUSH
11857: LD_INT 32
11859: PUSH
11860: LD_INT 33
11862: PUSH
11863: LD_INT 34
11865: PUSH
11866: LD_INT 35
11868: PUSH
11869: LD_INT 36
11871: PUSH
11872: EMPTY
11873: LIST
11874: LIST
11875: LIST
11876: LIST
11877: LIST
11878: LIST
11879: LIST
11880: LIST
11881: LIST
11882: LIST
11883: LIST
11884: LIST
11885: LIST
11886: LIST
11887: LIST
11888: LIST
11889: LIST
11890: LIST
11891: LIST
11892: LIST
11893: LIST
11894: LIST
11895: LIST
11896: LIST
11897: LIST
11898: LIST
11899: LIST
11900: LIST
11901: LIST
11902: LIST
11903: LIST
11904: LIST
11905: LIST
11906: LIST
11907: LIST
11908: LIST
11909: PUSH
11910: LD_INT 101
11912: PUSH
11913: LD_INT 102
11915: PUSH
11916: LD_INT 103
11918: PUSH
11919: LD_INT 104
11921: PUSH
11922: LD_INT 105
11924: PUSH
11925: LD_INT 106
11927: PUSH
11928: LD_INT 107
11930: PUSH
11931: LD_INT 108
11933: PUSH
11934: LD_INT 109
11936: PUSH
11937: LD_INT 110
11939: PUSH
11940: LD_INT 111
11942: PUSH
11943: LD_INT 112
11945: PUSH
11946: LD_INT 113
11948: PUSH
11949: LD_INT 114
11951: PUSH
11952: LD_INT 115
11954: PUSH
11955: EMPTY
11956: LIST
11957: LIST
11958: LIST
11959: LIST
11960: LIST
11961: LIST
11962: LIST
11963: LIST
11964: LIST
11965: LIST
11966: LIST
11967: LIST
11968: LIST
11969: LIST
11970: LIST
11971: PUSH
11972: EMPTY
11973: LIST
11974: LIST
11975: ST_TO_ADDR
11976: GO 11979
11978: POP
// end else
11979: GO 12198
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
11981: LD_ADDR_VAR 0 1
11985: PUSH
11986: LD_INT 1
11988: PUSH
11989: LD_INT 2
11991: PUSH
11992: LD_INT 3
11994: PUSH
11995: LD_INT 4
11997: PUSH
11998: LD_INT 5
12000: PUSH
12001: LD_INT 6
12003: PUSH
12004: LD_INT 7
12006: PUSH
12007: LD_INT 8
12009: PUSH
12010: LD_INT 9
12012: PUSH
12013: LD_INT 10
12015: PUSH
12016: LD_INT 11
12018: PUSH
12019: LD_INT 12
12021: PUSH
12022: LD_INT 13
12024: PUSH
12025: LD_INT 14
12027: PUSH
12028: LD_INT 15
12030: PUSH
12031: LD_INT 16
12033: PUSH
12034: LD_INT 17
12036: PUSH
12037: LD_INT 18
12039: PUSH
12040: LD_INT 19
12042: PUSH
12043: LD_INT 20
12045: PUSH
12046: LD_INT 21
12048: PUSH
12049: LD_INT 22
12051: PUSH
12052: LD_INT 23
12054: PUSH
12055: LD_INT 24
12057: PUSH
12058: LD_INT 25
12060: PUSH
12061: LD_INT 26
12063: PUSH
12064: LD_INT 27
12066: PUSH
12067: LD_INT 28
12069: PUSH
12070: LD_INT 29
12072: PUSH
12073: LD_INT 30
12075: PUSH
12076: LD_INT 31
12078: PUSH
12079: LD_INT 32
12081: PUSH
12082: LD_INT 33
12084: PUSH
12085: LD_INT 34
12087: PUSH
12088: LD_INT 35
12090: PUSH
12091: LD_INT 36
12093: PUSH
12094: EMPTY
12095: LIST
12096: LIST
12097: LIST
12098: LIST
12099: LIST
12100: LIST
12101: LIST
12102: LIST
12103: LIST
12104: LIST
12105: LIST
12106: LIST
12107: LIST
12108: LIST
12109: LIST
12110: LIST
12111: LIST
12112: LIST
12113: LIST
12114: LIST
12115: LIST
12116: LIST
12117: LIST
12118: LIST
12119: LIST
12120: LIST
12121: LIST
12122: LIST
12123: LIST
12124: LIST
12125: LIST
12126: LIST
12127: LIST
12128: LIST
12129: LIST
12130: LIST
12131: PUSH
12132: LD_INT 101
12134: PUSH
12135: LD_INT 102
12137: PUSH
12138: LD_INT 103
12140: PUSH
12141: LD_INT 104
12143: PUSH
12144: LD_INT 105
12146: PUSH
12147: LD_INT 106
12149: PUSH
12150: LD_INT 107
12152: PUSH
12153: LD_INT 108
12155: PUSH
12156: LD_INT 109
12158: PUSH
12159: LD_INT 110
12161: PUSH
12162: LD_INT 111
12164: PUSH
12165: LD_INT 112
12167: PUSH
12168: LD_INT 113
12170: PUSH
12171: LD_INT 114
12173: PUSH
12174: LD_INT 115
12176: PUSH
12177: EMPTY
12178: LIST
12179: LIST
12180: LIST
12181: LIST
12182: LIST
12183: LIST
12184: LIST
12185: LIST
12186: LIST
12187: LIST
12188: LIST
12189: LIST
12190: LIST
12191: LIST
12192: LIST
12193: PUSH
12194: EMPTY
12195: LIST
12196: LIST
12197: ST_TO_ADDR
// if result then
12198: LD_VAR 0 1
12202: IFFALSE 12491
// begin normal :=  ;
12204: LD_ADDR_VAR 0 3
12208: PUSH
12209: LD_STRING 
12211: ST_TO_ADDR
// hardcore :=  ;
12212: LD_ADDR_VAR 0 4
12216: PUSH
12217: LD_STRING 
12219: ST_TO_ADDR
// for i = 1 to normalCounter do
12220: LD_ADDR_VAR 0 5
12224: PUSH
12225: DOUBLE
12226: LD_INT 1
12228: DEC
12229: ST_TO_ADDR
12230: LD_EXP 38
12234: PUSH
12235: FOR_TO
12236: IFFALSE 12337
// begin tmp := 0 ;
12238: LD_ADDR_VAR 0 2
12242: PUSH
12243: LD_STRING 0
12245: ST_TO_ADDR
// if result [ 1 ] then
12246: LD_VAR 0 1
12250: PUSH
12251: LD_INT 1
12253: ARRAY
12254: IFFALSE 12319
// if result [ 1 ] [ 1 ] = i then
12256: LD_VAR 0 1
12260: PUSH
12261: LD_INT 1
12263: ARRAY
12264: PUSH
12265: LD_INT 1
12267: ARRAY
12268: PUSH
12269: LD_VAR 0 5
12273: EQUAL
12274: IFFALSE 12319
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
12276: LD_ADDR_VAR 0 1
12280: PUSH
12281: LD_VAR 0 1
12285: PPUSH
12286: LD_INT 1
12288: PPUSH
12289: LD_VAR 0 1
12293: PUSH
12294: LD_INT 1
12296: ARRAY
12297: PPUSH
12298: LD_INT 1
12300: PPUSH
12301: CALL_OW 3
12305: PPUSH
12306: CALL_OW 1
12310: ST_TO_ADDR
// tmp := 1 ;
12311: LD_ADDR_VAR 0 2
12315: PUSH
12316: LD_STRING 1
12318: ST_TO_ADDR
// end ; normal := normal & tmp ;
12319: LD_ADDR_VAR 0 3
12323: PUSH
12324: LD_VAR 0 3
12328: PUSH
12329: LD_VAR 0 2
12333: STR
12334: ST_TO_ADDR
// end ;
12335: GO 12235
12337: POP
12338: POP
// for i = 1 to hardcoreCounter do
12339: LD_ADDR_VAR 0 5
12343: PUSH
12344: DOUBLE
12345: LD_INT 1
12347: DEC
12348: ST_TO_ADDR
12349: LD_EXP 39
12353: PUSH
12354: FOR_TO
12355: IFFALSE 12460
// begin tmp := 0 ;
12357: LD_ADDR_VAR 0 2
12361: PUSH
12362: LD_STRING 0
12364: ST_TO_ADDR
// if result [ 2 ] then
12365: LD_VAR 0 1
12369: PUSH
12370: LD_INT 2
12372: ARRAY
12373: IFFALSE 12442
// if result [ 2 ] [ 1 ] = 100 + i then
12375: LD_VAR 0 1
12379: PUSH
12380: LD_INT 2
12382: ARRAY
12383: PUSH
12384: LD_INT 1
12386: ARRAY
12387: PUSH
12388: LD_INT 100
12390: PUSH
12391: LD_VAR 0 5
12395: PLUS
12396: EQUAL
12397: IFFALSE 12442
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
12399: LD_ADDR_VAR 0 1
12403: PUSH
12404: LD_VAR 0 1
12408: PPUSH
12409: LD_INT 2
12411: PPUSH
12412: LD_VAR 0 1
12416: PUSH
12417: LD_INT 2
12419: ARRAY
12420: PPUSH
12421: LD_INT 1
12423: PPUSH
12424: CALL_OW 3
12428: PPUSH
12429: CALL_OW 1
12433: ST_TO_ADDR
// tmp := 1 ;
12434: LD_ADDR_VAR 0 2
12438: PUSH
12439: LD_STRING 1
12441: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
12442: LD_ADDR_VAR 0 4
12446: PUSH
12447: LD_VAR 0 4
12451: PUSH
12452: LD_VAR 0 2
12456: STR
12457: ST_TO_ADDR
// end ;
12458: GO 12354
12460: POP
12461: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
12462: LD_STRING getStreamItemsFromMission("
12464: PUSH
12465: LD_VAR 0 3
12469: STR
12470: PUSH
12471: LD_STRING ","
12473: STR
12474: PUSH
12475: LD_VAR 0 4
12479: STR
12480: PUSH
12481: LD_STRING ")
12483: STR
12484: PPUSH
12485: CALL_OW 559
// end else
12489: GO 12498
// ToLua ( getStreamItemsFromMission("","") ) ;
12491: LD_STRING getStreamItemsFromMission("","")
12493: PPUSH
12494: CALL_OW 559
// end ;
12498: LD_VAR 0 1
12502: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
12503: LD_VAR 0 2
12507: PUSH
12508: LD_INT 100
12510: EQUAL
12511: IFFALSE 13460
// begin if not StreamModeActive then
12513: LD_EXP 37
12517: NOT
12518: IFFALSE 12528
// StreamModeActive := true ;
12520: LD_ADDR_EXP 37
12524: PUSH
12525: LD_INT 1
12527: ST_TO_ADDR
// if p3 = 0 then
12528: LD_VAR 0 3
12532: PUSH
12533: LD_INT 0
12535: EQUAL
12536: IFFALSE 12542
// InitStreamMode ;
12538: CALL 8581 0 0
// if p3 = 1 then
12542: LD_VAR 0 3
12546: PUSH
12547: LD_INT 1
12549: EQUAL
12550: IFFALSE 12560
// sRocket := true ;
12552: LD_ADDR_EXP 42
12556: PUSH
12557: LD_INT 1
12559: ST_TO_ADDR
// if p3 = 2 then
12560: LD_VAR 0 3
12564: PUSH
12565: LD_INT 2
12567: EQUAL
12568: IFFALSE 12578
// sSpeed := true ;
12570: LD_ADDR_EXP 41
12574: PUSH
12575: LD_INT 1
12577: ST_TO_ADDR
// if p3 = 3 then
12578: LD_VAR 0 3
12582: PUSH
12583: LD_INT 3
12585: EQUAL
12586: IFFALSE 12596
// sEngine := true ;
12588: LD_ADDR_EXP 43
12592: PUSH
12593: LD_INT 1
12595: ST_TO_ADDR
// if p3 = 4 then
12596: LD_VAR 0 3
12600: PUSH
12601: LD_INT 4
12603: EQUAL
12604: IFFALSE 12614
// sSpec := true ;
12606: LD_ADDR_EXP 40
12610: PUSH
12611: LD_INT 1
12613: ST_TO_ADDR
// if p3 = 5 then
12614: LD_VAR 0 3
12618: PUSH
12619: LD_INT 5
12621: EQUAL
12622: IFFALSE 12632
// sLevel := true ;
12624: LD_ADDR_EXP 44
12628: PUSH
12629: LD_INT 1
12631: ST_TO_ADDR
// if p3 = 6 then
12632: LD_VAR 0 3
12636: PUSH
12637: LD_INT 6
12639: EQUAL
12640: IFFALSE 12650
// sArmoury := true ;
12642: LD_ADDR_EXP 45
12646: PUSH
12647: LD_INT 1
12649: ST_TO_ADDR
// if p3 = 7 then
12650: LD_VAR 0 3
12654: PUSH
12655: LD_INT 7
12657: EQUAL
12658: IFFALSE 12668
// sRadar := true ;
12660: LD_ADDR_EXP 46
12664: PUSH
12665: LD_INT 1
12667: ST_TO_ADDR
// if p3 = 8 then
12668: LD_VAR 0 3
12672: PUSH
12673: LD_INT 8
12675: EQUAL
12676: IFFALSE 12686
// sBunker := true ;
12678: LD_ADDR_EXP 47
12682: PUSH
12683: LD_INT 1
12685: ST_TO_ADDR
// if p3 = 9 then
12686: LD_VAR 0 3
12690: PUSH
12691: LD_INT 9
12693: EQUAL
12694: IFFALSE 12704
// sHack := true ;
12696: LD_ADDR_EXP 48
12700: PUSH
12701: LD_INT 1
12703: ST_TO_ADDR
// if p3 = 10 then
12704: LD_VAR 0 3
12708: PUSH
12709: LD_INT 10
12711: EQUAL
12712: IFFALSE 12722
// sFire := true ;
12714: LD_ADDR_EXP 49
12718: PUSH
12719: LD_INT 1
12721: ST_TO_ADDR
// if p3 = 11 then
12722: LD_VAR 0 3
12726: PUSH
12727: LD_INT 11
12729: EQUAL
12730: IFFALSE 12740
// sRefresh := true ;
12732: LD_ADDR_EXP 50
12736: PUSH
12737: LD_INT 1
12739: ST_TO_ADDR
// if p3 = 12 then
12740: LD_VAR 0 3
12744: PUSH
12745: LD_INT 12
12747: EQUAL
12748: IFFALSE 12758
// sExp := true ;
12750: LD_ADDR_EXP 51
12754: PUSH
12755: LD_INT 1
12757: ST_TO_ADDR
// if p3 = 13 then
12758: LD_VAR 0 3
12762: PUSH
12763: LD_INT 13
12765: EQUAL
12766: IFFALSE 12776
// sDepot := true ;
12768: LD_ADDR_EXP 52
12772: PUSH
12773: LD_INT 1
12775: ST_TO_ADDR
// if p3 = 14 then
12776: LD_VAR 0 3
12780: PUSH
12781: LD_INT 14
12783: EQUAL
12784: IFFALSE 12794
// sFlag := true ;
12786: LD_ADDR_EXP 53
12790: PUSH
12791: LD_INT 1
12793: ST_TO_ADDR
// if p3 = 15 then
12794: LD_VAR 0 3
12798: PUSH
12799: LD_INT 15
12801: EQUAL
12802: IFFALSE 12812
// sKamikadze := true ;
12804: LD_ADDR_EXP 61
12808: PUSH
12809: LD_INT 1
12811: ST_TO_ADDR
// if p3 = 16 then
12812: LD_VAR 0 3
12816: PUSH
12817: LD_INT 16
12819: EQUAL
12820: IFFALSE 12830
// sTroll := true ;
12822: LD_ADDR_EXP 62
12826: PUSH
12827: LD_INT 1
12829: ST_TO_ADDR
// if p3 = 17 then
12830: LD_VAR 0 3
12834: PUSH
12835: LD_INT 17
12837: EQUAL
12838: IFFALSE 12848
// sSlow := true ;
12840: LD_ADDR_EXP 63
12844: PUSH
12845: LD_INT 1
12847: ST_TO_ADDR
// if p3 = 18 then
12848: LD_VAR 0 3
12852: PUSH
12853: LD_INT 18
12855: EQUAL
12856: IFFALSE 12866
// sLack := true ;
12858: LD_ADDR_EXP 64
12862: PUSH
12863: LD_INT 1
12865: ST_TO_ADDR
// if p3 = 19 then
12866: LD_VAR 0 3
12870: PUSH
12871: LD_INT 19
12873: EQUAL
12874: IFFALSE 12884
// sTank := true ;
12876: LD_ADDR_EXP 66
12880: PUSH
12881: LD_INT 1
12883: ST_TO_ADDR
// if p3 = 20 then
12884: LD_VAR 0 3
12888: PUSH
12889: LD_INT 20
12891: EQUAL
12892: IFFALSE 12902
// sRemote := true ;
12894: LD_ADDR_EXP 67
12898: PUSH
12899: LD_INT 1
12901: ST_TO_ADDR
// if p3 = 21 then
12902: LD_VAR 0 3
12906: PUSH
12907: LD_INT 21
12909: EQUAL
12910: IFFALSE 12920
// sPowell := true ;
12912: LD_ADDR_EXP 68
12916: PUSH
12917: LD_INT 1
12919: ST_TO_ADDR
// if p3 = 22 then
12920: LD_VAR 0 3
12924: PUSH
12925: LD_INT 22
12927: EQUAL
12928: IFFALSE 12938
// sTeleport := true ;
12930: LD_ADDR_EXP 71
12934: PUSH
12935: LD_INT 1
12937: ST_TO_ADDR
// if p3 = 23 then
12938: LD_VAR 0 3
12942: PUSH
12943: LD_INT 23
12945: EQUAL
12946: IFFALSE 12956
// sOilTower := true ;
12948: LD_ADDR_EXP 73
12952: PUSH
12953: LD_INT 1
12955: ST_TO_ADDR
// if p3 = 24 then
12956: LD_VAR 0 3
12960: PUSH
12961: LD_INT 24
12963: EQUAL
12964: IFFALSE 12974
// sShovel := true ;
12966: LD_ADDR_EXP 74
12970: PUSH
12971: LD_INT 1
12973: ST_TO_ADDR
// if p3 = 25 then
12974: LD_VAR 0 3
12978: PUSH
12979: LD_INT 25
12981: EQUAL
12982: IFFALSE 12992
// sSheik := true ;
12984: LD_ADDR_EXP 75
12988: PUSH
12989: LD_INT 1
12991: ST_TO_ADDR
// if p3 = 26 then
12992: LD_VAR 0 3
12996: PUSH
12997: LD_INT 26
12999: EQUAL
13000: IFFALSE 13010
// sEarthquake := true ;
13002: LD_ADDR_EXP 77
13006: PUSH
13007: LD_INT 1
13009: ST_TO_ADDR
// if p3 = 27 then
13010: LD_VAR 0 3
13014: PUSH
13015: LD_INT 27
13017: EQUAL
13018: IFFALSE 13028
// sAI := true ;
13020: LD_ADDR_EXP 78
13024: PUSH
13025: LD_INT 1
13027: ST_TO_ADDR
// if p3 = 28 then
13028: LD_VAR 0 3
13032: PUSH
13033: LD_INT 28
13035: EQUAL
13036: IFFALSE 13046
// sCargo := true ;
13038: LD_ADDR_EXP 81
13042: PUSH
13043: LD_INT 1
13045: ST_TO_ADDR
// if p3 = 29 then
13046: LD_VAR 0 3
13050: PUSH
13051: LD_INT 29
13053: EQUAL
13054: IFFALSE 13064
// sDLaser := true ;
13056: LD_ADDR_EXP 82
13060: PUSH
13061: LD_INT 1
13063: ST_TO_ADDR
// if p3 = 30 then
13064: LD_VAR 0 3
13068: PUSH
13069: LD_INT 30
13071: EQUAL
13072: IFFALSE 13082
// sExchange := true ;
13074: LD_ADDR_EXP 83
13078: PUSH
13079: LD_INT 1
13081: ST_TO_ADDR
// if p3 = 31 then
13082: LD_VAR 0 3
13086: PUSH
13087: LD_INT 31
13089: EQUAL
13090: IFFALSE 13100
// sFac := true ;
13092: LD_ADDR_EXP 84
13096: PUSH
13097: LD_INT 1
13099: ST_TO_ADDR
// if p3 = 32 then
13100: LD_VAR 0 3
13104: PUSH
13105: LD_INT 32
13107: EQUAL
13108: IFFALSE 13118
// sPower := true ;
13110: LD_ADDR_EXP 85
13114: PUSH
13115: LD_INT 1
13117: ST_TO_ADDR
// if p3 = 33 then
13118: LD_VAR 0 3
13122: PUSH
13123: LD_INT 33
13125: EQUAL
13126: IFFALSE 13136
// sRandom := true ;
13128: LD_ADDR_EXP 86
13132: PUSH
13133: LD_INT 1
13135: ST_TO_ADDR
// if p3 = 34 then
13136: LD_VAR 0 3
13140: PUSH
13141: LD_INT 34
13143: EQUAL
13144: IFFALSE 13154
// sShield := true ;
13146: LD_ADDR_EXP 87
13150: PUSH
13151: LD_INT 1
13153: ST_TO_ADDR
// if p3 = 35 then
13154: LD_VAR 0 3
13158: PUSH
13159: LD_INT 35
13161: EQUAL
13162: IFFALSE 13172
// sTime := true ;
13164: LD_ADDR_EXP 88
13168: PUSH
13169: LD_INT 1
13171: ST_TO_ADDR
// if p3 = 36 then
13172: LD_VAR 0 3
13176: PUSH
13177: LD_INT 36
13179: EQUAL
13180: IFFALSE 13190
// sTools := true ;
13182: LD_ADDR_EXP 89
13186: PUSH
13187: LD_INT 1
13189: ST_TO_ADDR
// if p3 = 101 then
13190: LD_VAR 0 3
13194: PUSH
13195: LD_INT 101
13197: EQUAL
13198: IFFALSE 13208
// sSold := true ;
13200: LD_ADDR_EXP 54
13204: PUSH
13205: LD_INT 1
13207: ST_TO_ADDR
// if p3 = 102 then
13208: LD_VAR 0 3
13212: PUSH
13213: LD_INT 102
13215: EQUAL
13216: IFFALSE 13226
// sDiff := true ;
13218: LD_ADDR_EXP 55
13222: PUSH
13223: LD_INT 1
13225: ST_TO_ADDR
// if p3 = 103 then
13226: LD_VAR 0 3
13230: PUSH
13231: LD_INT 103
13233: EQUAL
13234: IFFALSE 13244
// sFog := true ;
13236: LD_ADDR_EXP 58
13240: PUSH
13241: LD_INT 1
13243: ST_TO_ADDR
// if p3 = 104 then
13244: LD_VAR 0 3
13248: PUSH
13249: LD_INT 104
13251: EQUAL
13252: IFFALSE 13262
// sReset := true ;
13254: LD_ADDR_EXP 59
13258: PUSH
13259: LD_INT 1
13261: ST_TO_ADDR
// if p3 = 105 then
13262: LD_VAR 0 3
13266: PUSH
13267: LD_INT 105
13269: EQUAL
13270: IFFALSE 13280
// sSun := true ;
13272: LD_ADDR_EXP 60
13276: PUSH
13277: LD_INT 1
13279: ST_TO_ADDR
// if p3 = 106 then
13280: LD_VAR 0 3
13284: PUSH
13285: LD_INT 106
13287: EQUAL
13288: IFFALSE 13298
// sTiger := true ;
13290: LD_ADDR_EXP 56
13294: PUSH
13295: LD_INT 1
13297: ST_TO_ADDR
// if p3 = 107 then
13298: LD_VAR 0 3
13302: PUSH
13303: LD_INT 107
13305: EQUAL
13306: IFFALSE 13316
// sBomb := true ;
13308: LD_ADDR_EXP 57
13312: PUSH
13313: LD_INT 1
13315: ST_TO_ADDR
// if p3 = 108 then
13316: LD_VAR 0 3
13320: PUSH
13321: LD_INT 108
13323: EQUAL
13324: IFFALSE 13334
// sWound := true ;
13326: LD_ADDR_EXP 65
13330: PUSH
13331: LD_INT 1
13333: ST_TO_ADDR
// if p3 = 109 then
13334: LD_VAR 0 3
13338: PUSH
13339: LD_INT 109
13341: EQUAL
13342: IFFALSE 13352
// sBetray := true ;
13344: LD_ADDR_EXP 69
13348: PUSH
13349: LD_INT 1
13351: ST_TO_ADDR
// if p3 = 110 then
13352: LD_VAR 0 3
13356: PUSH
13357: LD_INT 110
13359: EQUAL
13360: IFFALSE 13370
// sContamin := true ;
13362: LD_ADDR_EXP 70
13366: PUSH
13367: LD_INT 1
13369: ST_TO_ADDR
// if p3 = 111 then
13370: LD_VAR 0 3
13374: PUSH
13375: LD_INT 111
13377: EQUAL
13378: IFFALSE 13388
// sOil := true ;
13380: LD_ADDR_EXP 72
13384: PUSH
13385: LD_INT 1
13387: ST_TO_ADDR
// if p3 = 112 then
13388: LD_VAR 0 3
13392: PUSH
13393: LD_INT 112
13395: EQUAL
13396: IFFALSE 13406
// sStu := true ;
13398: LD_ADDR_EXP 76
13402: PUSH
13403: LD_INT 1
13405: ST_TO_ADDR
// if p3 = 113 then
13406: LD_VAR 0 3
13410: PUSH
13411: LD_INT 113
13413: EQUAL
13414: IFFALSE 13424
// sBazooka := true ;
13416: LD_ADDR_EXP 79
13420: PUSH
13421: LD_INT 1
13423: ST_TO_ADDR
// if p3 = 114 then
13424: LD_VAR 0 3
13428: PUSH
13429: LD_INT 114
13431: EQUAL
13432: IFFALSE 13442
// sMortar := true ;
13434: LD_ADDR_EXP 80
13438: PUSH
13439: LD_INT 1
13441: ST_TO_ADDR
// if p3 = 115 then
13442: LD_VAR 0 3
13446: PUSH
13447: LD_INT 115
13449: EQUAL
13450: IFFALSE 13460
// sRanger := true ;
13452: LD_ADDR_EXP 90
13456: PUSH
13457: LD_INT 1
13459: ST_TO_ADDR
// end ; end ;
13460: PPOPN 6
13462: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
13463: LD_EXP 37
13467: PUSH
13468: LD_EXP 42
13472: AND
13473: IFFALSE 13597
13475: GO 13477
13477: DISABLE
13478: LD_INT 0
13480: PPUSH
13481: PPUSH
// begin enable ;
13482: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
13483: LD_ADDR_VAR 0 2
13487: PUSH
13488: LD_INT 22
13490: PUSH
13491: LD_OWVAR 2
13495: PUSH
13496: EMPTY
13497: LIST
13498: LIST
13499: PUSH
13500: LD_INT 2
13502: PUSH
13503: LD_INT 34
13505: PUSH
13506: LD_INT 7
13508: PUSH
13509: EMPTY
13510: LIST
13511: LIST
13512: PUSH
13513: LD_INT 34
13515: PUSH
13516: LD_INT 45
13518: PUSH
13519: EMPTY
13520: LIST
13521: LIST
13522: PUSH
13523: LD_INT 34
13525: PUSH
13526: LD_INT 28
13528: PUSH
13529: EMPTY
13530: LIST
13531: LIST
13532: PUSH
13533: LD_INT 34
13535: PUSH
13536: LD_INT 47
13538: PUSH
13539: EMPTY
13540: LIST
13541: LIST
13542: PUSH
13543: EMPTY
13544: LIST
13545: LIST
13546: LIST
13547: LIST
13548: LIST
13549: PUSH
13550: EMPTY
13551: LIST
13552: LIST
13553: PPUSH
13554: CALL_OW 69
13558: ST_TO_ADDR
// if not tmp then
13559: LD_VAR 0 2
13563: NOT
13564: IFFALSE 13568
// exit ;
13566: GO 13597
// for i in tmp do
13568: LD_ADDR_VAR 0 1
13572: PUSH
13573: LD_VAR 0 2
13577: PUSH
13578: FOR_IN
13579: IFFALSE 13595
// begin SetLives ( i , 0 ) ;
13581: LD_VAR 0 1
13585: PPUSH
13586: LD_INT 0
13588: PPUSH
13589: CALL_OW 234
// end ;
13593: GO 13578
13595: POP
13596: POP
// end ;
13597: PPOPN 2
13599: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
13600: LD_EXP 37
13604: PUSH
13605: LD_EXP 43
13609: AND
13610: IFFALSE 13694
13612: GO 13614
13614: DISABLE
13615: LD_INT 0
13617: PPUSH
13618: PPUSH
// begin enable ;
13619: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
13620: LD_ADDR_VAR 0 2
13624: PUSH
13625: LD_INT 22
13627: PUSH
13628: LD_OWVAR 2
13632: PUSH
13633: EMPTY
13634: LIST
13635: LIST
13636: PUSH
13637: LD_INT 32
13639: PUSH
13640: LD_INT 3
13642: PUSH
13643: EMPTY
13644: LIST
13645: LIST
13646: PUSH
13647: EMPTY
13648: LIST
13649: LIST
13650: PPUSH
13651: CALL_OW 69
13655: ST_TO_ADDR
// if not tmp then
13656: LD_VAR 0 2
13660: NOT
13661: IFFALSE 13665
// exit ;
13663: GO 13694
// for i in tmp do
13665: LD_ADDR_VAR 0 1
13669: PUSH
13670: LD_VAR 0 2
13674: PUSH
13675: FOR_IN
13676: IFFALSE 13692
// begin SetLives ( i , 0 ) ;
13678: LD_VAR 0 1
13682: PPUSH
13683: LD_INT 0
13685: PPUSH
13686: CALL_OW 234
// end ;
13690: GO 13675
13692: POP
13693: POP
// end ;
13694: PPOPN 2
13696: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
13697: LD_EXP 37
13701: PUSH
13702: LD_EXP 40
13706: AND
13707: IFFALSE 13800
13709: GO 13711
13711: DISABLE
13712: LD_INT 0
13714: PPUSH
// begin enable ;
13715: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
13716: LD_ADDR_VAR 0 1
13720: PUSH
13721: LD_INT 22
13723: PUSH
13724: LD_OWVAR 2
13728: PUSH
13729: EMPTY
13730: LIST
13731: LIST
13732: PUSH
13733: LD_INT 2
13735: PUSH
13736: LD_INT 25
13738: PUSH
13739: LD_INT 5
13741: PUSH
13742: EMPTY
13743: LIST
13744: LIST
13745: PUSH
13746: LD_INT 25
13748: PUSH
13749: LD_INT 9
13751: PUSH
13752: EMPTY
13753: LIST
13754: LIST
13755: PUSH
13756: LD_INT 25
13758: PUSH
13759: LD_INT 8
13761: PUSH
13762: EMPTY
13763: LIST
13764: LIST
13765: PUSH
13766: EMPTY
13767: LIST
13768: LIST
13769: LIST
13770: LIST
13771: PUSH
13772: EMPTY
13773: LIST
13774: LIST
13775: PPUSH
13776: CALL_OW 69
13780: PUSH
13781: FOR_IN
13782: IFFALSE 13798
// begin SetClass ( i , 1 ) ;
13784: LD_VAR 0 1
13788: PPUSH
13789: LD_INT 1
13791: PPUSH
13792: CALL_OW 336
// end ;
13796: GO 13781
13798: POP
13799: POP
// end ;
13800: PPOPN 1
13802: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
13803: LD_EXP 37
13807: PUSH
13808: LD_EXP 41
13812: AND
13813: PUSH
13814: LD_OWVAR 65
13818: PUSH
13819: LD_INT 7
13821: LESS
13822: AND
13823: IFFALSE 13837
13825: GO 13827
13827: DISABLE
// begin enable ;
13828: ENABLE
// game_speed := 7 ;
13829: LD_ADDR_OWVAR 65
13833: PUSH
13834: LD_INT 7
13836: ST_TO_ADDR
// end ;
13837: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
13838: LD_EXP 37
13842: PUSH
13843: LD_EXP 44
13847: AND
13848: IFFALSE 14050
13850: GO 13852
13852: DISABLE
13853: LD_INT 0
13855: PPUSH
13856: PPUSH
13857: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
13858: LD_ADDR_VAR 0 3
13862: PUSH
13863: LD_INT 81
13865: PUSH
13866: LD_OWVAR 2
13870: PUSH
13871: EMPTY
13872: LIST
13873: LIST
13874: PUSH
13875: LD_INT 21
13877: PUSH
13878: LD_INT 1
13880: PUSH
13881: EMPTY
13882: LIST
13883: LIST
13884: PUSH
13885: EMPTY
13886: LIST
13887: LIST
13888: PPUSH
13889: CALL_OW 69
13893: ST_TO_ADDR
// if not tmp then
13894: LD_VAR 0 3
13898: NOT
13899: IFFALSE 13903
// exit ;
13901: GO 14050
// if tmp > 5 then
13903: LD_VAR 0 3
13907: PUSH
13908: LD_INT 5
13910: GREATER
13911: IFFALSE 13923
// k := 5 else
13913: LD_ADDR_VAR 0 2
13917: PUSH
13918: LD_INT 5
13920: ST_TO_ADDR
13921: GO 13933
// k := tmp ;
13923: LD_ADDR_VAR 0 2
13927: PUSH
13928: LD_VAR 0 3
13932: ST_TO_ADDR
// for i := 1 to k do
13933: LD_ADDR_VAR 0 1
13937: PUSH
13938: DOUBLE
13939: LD_INT 1
13941: DEC
13942: ST_TO_ADDR
13943: LD_VAR 0 2
13947: PUSH
13948: FOR_TO
13949: IFFALSE 14048
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
13951: LD_VAR 0 3
13955: PUSH
13956: LD_VAR 0 1
13960: ARRAY
13961: PPUSH
13962: LD_VAR 0 1
13966: PUSH
13967: LD_INT 4
13969: MOD
13970: PUSH
13971: LD_INT 1
13973: PLUS
13974: PPUSH
13975: CALL_OW 259
13979: PUSH
13980: LD_INT 10
13982: LESS
13983: IFFALSE 14046
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
13985: LD_VAR 0 3
13989: PUSH
13990: LD_VAR 0 1
13994: ARRAY
13995: PPUSH
13996: LD_VAR 0 1
14000: PUSH
14001: LD_INT 4
14003: MOD
14004: PUSH
14005: LD_INT 1
14007: PLUS
14008: PPUSH
14009: LD_VAR 0 3
14013: PUSH
14014: LD_VAR 0 1
14018: ARRAY
14019: PPUSH
14020: LD_VAR 0 1
14024: PUSH
14025: LD_INT 4
14027: MOD
14028: PUSH
14029: LD_INT 1
14031: PLUS
14032: PPUSH
14033: CALL_OW 259
14037: PUSH
14038: LD_INT 1
14040: PLUS
14041: PPUSH
14042: CALL_OW 237
14046: GO 13948
14048: POP
14049: POP
// end ;
14050: PPOPN 3
14052: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
14053: LD_EXP 37
14057: PUSH
14058: LD_EXP 45
14062: AND
14063: IFFALSE 14083
14065: GO 14067
14067: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
14068: LD_INT 4
14070: PPUSH
14071: LD_OWVAR 2
14075: PPUSH
14076: LD_INT 0
14078: PPUSH
14079: CALL_OW 324
14083: END
// every 0 0$1 trigger StreamModeActive and sShovel do
14084: LD_EXP 37
14088: PUSH
14089: LD_EXP 74
14093: AND
14094: IFFALSE 14114
14096: GO 14098
14098: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
14099: LD_INT 19
14101: PPUSH
14102: LD_OWVAR 2
14106: PPUSH
14107: LD_INT 0
14109: PPUSH
14110: CALL_OW 324
14114: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
14115: LD_EXP 37
14119: PUSH
14120: LD_EXP 46
14124: AND
14125: IFFALSE 14227
14127: GO 14129
14129: DISABLE
14130: LD_INT 0
14132: PPUSH
14133: PPUSH
// begin enable ;
14134: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
14135: LD_ADDR_VAR 0 2
14139: PUSH
14140: LD_INT 22
14142: PUSH
14143: LD_OWVAR 2
14147: PUSH
14148: EMPTY
14149: LIST
14150: LIST
14151: PUSH
14152: LD_INT 2
14154: PUSH
14155: LD_INT 34
14157: PUSH
14158: LD_INT 11
14160: PUSH
14161: EMPTY
14162: LIST
14163: LIST
14164: PUSH
14165: LD_INT 34
14167: PUSH
14168: LD_INT 30
14170: PUSH
14171: EMPTY
14172: LIST
14173: LIST
14174: PUSH
14175: EMPTY
14176: LIST
14177: LIST
14178: LIST
14179: PUSH
14180: EMPTY
14181: LIST
14182: LIST
14183: PPUSH
14184: CALL_OW 69
14188: ST_TO_ADDR
// if not tmp then
14189: LD_VAR 0 2
14193: NOT
14194: IFFALSE 14198
// exit ;
14196: GO 14227
// for i in tmp do
14198: LD_ADDR_VAR 0 1
14202: PUSH
14203: LD_VAR 0 2
14207: PUSH
14208: FOR_IN
14209: IFFALSE 14225
// begin SetLives ( i , 0 ) ;
14211: LD_VAR 0 1
14215: PPUSH
14216: LD_INT 0
14218: PPUSH
14219: CALL_OW 234
// end ;
14223: GO 14208
14225: POP
14226: POP
// end ;
14227: PPOPN 2
14229: END
// every 0 0$1 trigger StreamModeActive and sBunker do
14230: LD_EXP 37
14234: PUSH
14235: LD_EXP 47
14239: AND
14240: IFFALSE 14260
14242: GO 14244
14244: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
14245: LD_INT 32
14247: PPUSH
14248: LD_OWVAR 2
14252: PPUSH
14253: LD_INT 0
14255: PPUSH
14256: CALL_OW 324
14260: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
14261: LD_EXP 37
14265: PUSH
14266: LD_EXP 48
14270: AND
14271: IFFALSE 14452
14273: GO 14275
14275: DISABLE
14276: LD_INT 0
14278: PPUSH
14279: PPUSH
14280: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
14281: LD_ADDR_VAR 0 2
14285: PUSH
14286: LD_INT 22
14288: PUSH
14289: LD_OWVAR 2
14293: PUSH
14294: EMPTY
14295: LIST
14296: LIST
14297: PUSH
14298: LD_INT 33
14300: PUSH
14301: LD_INT 3
14303: PUSH
14304: EMPTY
14305: LIST
14306: LIST
14307: PUSH
14308: EMPTY
14309: LIST
14310: LIST
14311: PPUSH
14312: CALL_OW 69
14316: ST_TO_ADDR
// if not tmp then
14317: LD_VAR 0 2
14321: NOT
14322: IFFALSE 14326
// exit ;
14324: GO 14452
// side := 0 ;
14326: LD_ADDR_VAR 0 3
14330: PUSH
14331: LD_INT 0
14333: ST_TO_ADDR
// for i := 1 to 8 do
14334: LD_ADDR_VAR 0 1
14338: PUSH
14339: DOUBLE
14340: LD_INT 1
14342: DEC
14343: ST_TO_ADDR
14344: LD_INT 8
14346: PUSH
14347: FOR_TO
14348: IFFALSE 14396
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
14350: LD_OWVAR 2
14354: PUSH
14355: LD_VAR 0 1
14359: NONEQUAL
14360: PUSH
14361: LD_OWVAR 2
14365: PPUSH
14366: LD_VAR 0 1
14370: PPUSH
14371: CALL_OW 81
14375: PUSH
14376: LD_INT 2
14378: EQUAL
14379: AND
14380: IFFALSE 14394
// begin side := i ;
14382: LD_ADDR_VAR 0 3
14386: PUSH
14387: LD_VAR 0 1
14391: ST_TO_ADDR
// break ;
14392: GO 14396
// end ;
14394: GO 14347
14396: POP
14397: POP
// if not side then
14398: LD_VAR 0 3
14402: NOT
14403: IFFALSE 14407
// exit ;
14405: GO 14452
// for i := 1 to tmp do
14407: LD_ADDR_VAR 0 1
14411: PUSH
14412: DOUBLE
14413: LD_INT 1
14415: DEC
14416: ST_TO_ADDR
14417: LD_VAR 0 2
14421: PUSH
14422: FOR_TO
14423: IFFALSE 14450
// if Prob ( 60 ) then
14425: LD_INT 60
14427: PPUSH
14428: CALL_OW 13
14432: IFFALSE 14448
// SetSide ( i , side ) ;
14434: LD_VAR 0 1
14438: PPUSH
14439: LD_VAR 0 3
14443: PPUSH
14444: CALL_OW 235
14448: GO 14422
14450: POP
14451: POP
// end ;
14452: PPOPN 3
14454: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
14455: LD_EXP 37
14459: PUSH
14460: LD_EXP 50
14464: AND
14465: IFFALSE 14584
14467: GO 14469
14469: DISABLE
14470: LD_INT 0
14472: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
14473: LD_ADDR_VAR 0 1
14477: PUSH
14478: LD_INT 22
14480: PUSH
14481: LD_OWVAR 2
14485: PUSH
14486: EMPTY
14487: LIST
14488: LIST
14489: PUSH
14490: LD_INT 21
14492: PUSH
14493: LD_INT 1
14495: PUSH
14496: EMPTY
14497: LIST
14498: LIST
14499: PUSH
14500: LD_INT 3
14502: PUSH
14503: LD_INT 23
14505: PUSH
14506: LD_INT 0
14508: PUSH
14509: EMPTY
14510: LIST
14511: LIST
14512: PUSH
14513: EMPTY
14514: LIST
14515: LIST
14516: PUSH
14517: EMPTY
14518: LIST
14519: LIST
14520: LIST
14521: PPUSH
14522: CALL_OW 69
14526: PUSH
14527: FOR_IN
14528: IFFALSE 14582
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
14530: LD_VAR 0 1
14534: PPUSH
14535: CALL_OW 257
14539: PUSH
14540: LD_INT 1
14542: PUSH
14543: LD_INT 2
14545: PUSH
14546: LD_INT 3
14548: PUSH
14549: LD_INT 4
14551: PUSH
14552: EMPTY
14553: LIST
14554: LIST
14555: LIST
14556: LIST
14557: IN
14558: IFFALSE 14580
// SetClass ( un , rand ( 1 , 4 ) ) ;
14560: LD_VAR 0 1
14564: PPUSH
14565: LD_INT 1
14567: PPUSH
14568: LD_INT 4
14570: PPUSH
14571: CALL_OW 12
14575: PPUSH
14576: CALL_OW 336
14580: GO 14527
14582: POP
14583: POP
// end ;
14584: PPOPN 1
14586: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
14587: LD_EXP 37
14591: PUSH
14592: LD_EXP 49
14596: AND
14597: IFFALSE 14676
14599: GO 14601
14601: DISABLE
14602: LD_INT 0
14604: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
14605: LD_ADDR_VAR 0 1
14609: PUSH
14610: LD_INT 22
14612: PUSH
14613: LD_OWVAR 2
14617: PUSH
14618: EMPTY
14619: LIST
14620: LIST
14621: PUSH
14622: LD_INT 21
14624: PUSH
14625: LD_INT 3
14627: PUSH
14628: EMPTY
14629: LIST
14630: LIST
14631: PUSH
14632: EMPTY
14633: LIST
14634: LIST
14635: PPUSH
14636: CALL_OW 69
14640: ST_TO_ADDR
// if not tmp then
14641: LD_VAR 0 1
14645: NOT
14646: IFFALSE 14650
// exit ;
14648: GO 14676
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
14650: LD_VAR 0 1
14654: PUSH
14655: LD_INT 1
14657: PPUSH
14658: LD_VAR 0 1
14662: PPUSH
14663: CALL_OW 12
14667: ARRAY
14668: PPUSH
14669: LD_INT 100
14671: PPUSH
14672: CALL_OW 234
// end ;
14676: PPOPN 1
14678: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
14679: LD_EXP 37
14683: PUSH
14684: LD_EXP 51
14688: AND
14689: IFFALSE 14787
14691: GO 14693
14693: DISABLE
14694: LD_INT 0
14696: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
14697: LD_ADDR_VAR 0 1
14701: PUSH
14702: LD_INT 22
14704: PUSH
14705: LD_OWVAR 2
14709: PUSH
14710: EMPTY
14711: LIST
14712: LIST
14713: PUSH
14714: LD_INT 21
14716: PUSH
14717: LD_INT 1
14719: PUSH
14720: EMPTY
14721: LIST
14722: LIST
14723: PUSH
14724: EMPTY
14725: LIST
14726: LIST
14727: PPUSH
14728: CALL_OW 69
14732: ST_TO_ADDR
// if not tmp then
14733: LD_VAR 0 1
14737: NOT
14738: IFFALSE 14742
// exit ;
14740: GO 14787
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
14742: LD_VAR 0 1
14746: PUSH
14747: LD_INT 1
14749: PPUSH
14750: LD_VAR 0 1
14754: PPUSH
14755: CALL_OW 12
14759: ARRAY
14760: PPUSH
14761: LD_INT 1
14763: PPUSH
14764: LD_INT 4
14766: PPUSH
14767: CALL_OW 12
14771: PPUSH
14772: LD_INT 3000
14774: PPUSH
14775: LD_INT 9000
14777: PPUSH
14778: CALL_OW 12
14782: PPUSH
14783: CALL_OW 492
// end ;
14787: PPOPN 1
14789: END
// every 0 0$1 trigger StreamModeActive and sDepot do
14790: LD_EXP 37
14794: PUSH
14795: LD_EXP 52
14799: AND
14800: IFFALSE 14820
14802: GO 14804
14804: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
14805: LD_INT 1
14807: PPUSH
14808: LD_OWVAR 2
14812: PPUSH
14813: LD_INT 0
14815: PPUSH
14816: CALL_OW 324
14820: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
14821: LD_EXP 37
14825: PUSH
14826: LD_EXP 53
14830: AND
14831: IFFALSE 14914
14833: GO 14835
14835: DISABLE
14836: LD_INT 0
14838: PPUSH
14839: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
14840: LD_ADDR_VAR 0 2
14844: PUSH
14845: LD_INT 22
14847: PUSH
14848: LD_OWVAR 2
14852: PUSH
14853: EMPTY
14854: LIST
14855: LIST
14856: PUSH
14857: LD_INT 21
14859: PUSH
14860: LD_INT 3
14862: PUSH
14863: EMPTY
14864: LIST
14865: LIST
14866: PUSH
14867: EMPTY
14868: LIST
14869: LIST
14870: PPUSH
14871: CALL_OW 69
14875: ST_TO_ADDR
// if not tmp then
14876: LD_VAR 0 2
14880: NOT
14881: IFFALSE 14885
// exit ;
14883: GO 14914
// for i in tmp do
14885: LD_ADDR_VAR 0 1
14889: PUSH
14890: LD_VAR 0 2
14894: PUSH
14895: FOR_IN
14896: IFFALSE 14912
// SetBLevel ( i , 10 ) ;
14898: LD_VAR 0 1
14902: PPUSH
14903: LD_INT 10
14905: PPUSH
14906: CALL_OW 241
14910: GO 14895
14912: POP
14913: POP
// end ;
14914: PPOPN 2
14916: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
14917: LD_EXP 37
14921: PUSH
14922: LD_EXP 54
14926: AND
14927: IFFALSE 15038
14929: GO 14931
14931: DISABLE
14932: LD_INT 0
14934: PPUSH
14935: PPUSH
14936: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
14937: LD_ADDR_VAR 0 3
14941: PUSH
14942: LD_INT 22
14944: PUSH
14945: LD_OWVAR 2
14949: PUSH
14950: EMPTY
14951: LIST
14952: LIST
14953: PUSH
14954: LD_INT 25
14956: PUSH
14957: LD_INT 1
14959: PUSH
14960: EMPTY
14961: LIST
14962: LIST
14963: PUSH
14964: EMPTY
14965: LIST
14966: LIST
14967: PPUSH
14968: CALL_OW 69
14972: ST_TO_ADDR
// if not tmp then
14973: LD_VAR 0 3
14977: NOT
14978: IFFALSE 14982
// exit ;
14980: GO 15038
// un := tmp [ rand ( 1 , tmp ) ] ;
14982: LD_ADDR_VAR 0 2
14986: PUSH
14987: LD_VAR 0 3
14991: PUSH
14992: LD_INT 1
14994: PPUSH
14995: LD_VAR 0 3
14999: PPUSH
15000: CALL_OW 12
15004: ARRAY
15005: ST_TO_ADDR
// if Crawls ( un ) then
15006: LD_VAR 0 2
15010: PPUSH
15011: CALL_OW 318
15015: IFFALSE 15026
// ComWalk ( un ) ;
15017: LD_VAR 0 2
15021: PPUSH
15022: CALL_OW 138
// SetClass ( un , class_sniper ) ;
15026: LD_VAR 0 2
15030: PPUSH
15031: LD_INT 5
15033: PPUSH
15034: CALL_OW 336
// end ;
15038: PPOPN 3
15040: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
15041: LD_EXP 37
15045: PUSH
15046: LD_EXP 55
15050: AND
15051: PUSH
15052: LD_OWVAR 67
15056: PUSH
15057: LD_INT 3
15059: LESS
15060: AND
15061: IFFALSE 15080
15063: GO 15065
15065: DISABLE
// Difficulty := Difficulty + 1 ;
15066: LD_ADDR_OWVAR 67
15070: PUSH
15071: LD_OWVAR 67
15075: PUSH
15076: LD_INT 1
15078: PLUS
15079: ST_TO_ADDR
15080: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
15081: LD_EXP 37
15085: PUSH
15086: LD_EXP 56
15090: AND
15091: IFFALSE 15194
15093: GO 15095
15095: DISABLE
15096: LD_INT 0
15098: PPUSH
// begin for i := 1 to 5 do
15099: LD_ADDR_VAR 0 1
15103: PUSH
15104: DOUBLE
15105: LD_INT 1
15107: DEC
15108: ST_TO_ADDR
15109: LD_INT 5
15111: PUSH
15112: FOR_TO
15113: IFFALSE 15192
// begin uc_nation := nation_nature ;
15115: LD_ADDR_OWVAR 21
15119: PUSH
15120: LD_INT 0
15122: ST_TO_ADDR
// uc_side := 0 ;
15123: LD_ADDR_OWVAR 20
15127: PUSH
15128: LD_INT 0
15130: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
15131: LD_ADDR_OWVAR 29
15135: PUSH
15136: LD_INT 12
15138: PUSH
15139: LD_INT 12
15141: PUSH
15142: EMPTY
15143: LIST
15144: LIST
15145: ST_TO_ADDR
// hc_agressivity := 20 ;
15146: LD_ADDR_OWVAR 35
15150: PUSH
15151: LD_INT 20
15153: ST_TO_ADDR
// hc_class := class_tiger ;
15154: LD_ADDR_OWVAR 28
15158: PUSH
15159: LD_INT 14
15161: ST_TO_ADDR
// hc_gallery :=  ;
15162: LD_ADDR_OWVAR 33
15166: PUSH
15167: LD_STRING 
15169: ST_TO_ADDR
// hc_name :=  ;
15170: LD_ADDR_OWVAR 26
15174: PUSH
15175: LD_STRING 
15177: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
15178: CALL_OW 44
15182: PPUSH
15183: LD_INT 0
15185: PPUSH
15186: CALL_OW 51
// end ;
15190: GO 15112
15192: POP
15193: POP
// end ;
15194: PPOPN 1
15196: END
// every 0 0$1 trigger StreamModeActive and sBomb do
15197: LD_EXP 37
15201: PUSH
15202: LD_EXP 57
15206: AND
15207: IFFALSE 15216
15209: GO 15211
15211: DISABLE
// StreamSibBomb ;
15212: CALL 15217 0 0
15216: END
// export function StreamSibBomb ; var i , x , y ; begin
15217: LD_INT 0
15219: PPUSH
15220: PPUSH
15221: PPUSH
15222: PPUSH
// result := false ;
15223: LD_ADDR_VAR 0 1
15227: PUSH
15228: LD_INT 0
15230: ST_TO_ADDR
// for i := 1 to 16 do
15231: LD_ADDR_VAR 0 2
15235: PUSH
15236: DOUBLE
15237: LD_INT 1
15239: DEC
15240: ST_TO_ADDR
15241: LD_INT 16
15243: PUSH
15244: FOR_TO
15245: IFFALSE 15444
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
15247: LD_ADDR_VAR 0 3
15251: PUSH
15252: LD_INT 10
15254: PUSH
15255: LD_INT 20
15257: PUSH
15258: LD_INT 30
15260: PUSH
15261: LD_INT 40
15263: PUSH
15264: LD_INT 50
15266: PUSH
15267: LD_INT 60
15269: PUSH
15270: LD_INT 70
15272: PUSH
15273: LD_INT 80
15275: PUSH
15276: LD_INT 90
15278: PUSH
15279: LD_INT 100
15281: PUSH
15282: LD_INT 110
15284: PUSH
15285: LD_INT 120
15287: PUSH
15288: LD_INT 130
15290: PUSH
15291: LD_INT 140
15293: PUSH
15294: LD_INT 150
15296: PUSH
15297: EMPTY
15298: LIST
15299: LIST
15300: LIST
15301: LIST
15302: LIST
15303: LIST
15304: LIST
15305: LIST
15306: LIST
15307: LIST
15308: LIST
15309: LIST
15310: LIST
15311: LIST
15312: LIST
15313: PUSH
15314: LD_INT 1
15316: PPUSH
15317: LD_INT 15
15319: PPUSH
15320: CALL_OW 12
15324: ARRAY
15325: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
15326: LD_ADDR_VAR 0 4
15330: PUSH
15331: LD_INT 10
15333: PUSH
15334: LD_INT 20
15336: PUSH
15337: LD_INT 30
15339: PUSH
15340: LD_INT 40
15342: PUSH
15343: LD_INT 50
15345: PUSH
15346: LD_INT 60
15348: PUSH
15349: LD_INT 70
15351: PUSH
15352: LD_INT 80
15354: PUSH
15355: LD_INT 90
15357: PUSH
15358: LD_INT 100
15360: PUSH
15361: LD_INT 110
15363: PUSH
15364: LD_INT 120
15366: PUSH
15367: LD_INT 130
15369: PUSH
15370: LD_INT 140
15372: PUSH
15373: LD_INT 150
15375: PUSH
15376: EMPTY
15377: LIST
15378: LIST
15379: LIST
15380: LIST
15381: LIST
15382: LIST
15383: LIST
15384: LIST
15385: LIST
15386: LIST
15387: LIST
15388: LIST
15389: LIST
15390: LIST
15391: LIST
15392: PUSH
15393: LD_INT 1
15395: PPUSH
15396: LD_INT 15
15398: PPUSH
15399: CALL_OW 12
15403: ARRAY
15404: ST_TO_ADDR
// if ValidHex ( x , y ) then
15405: LD_VAR 0 3
15409: PPUSH
15410: LD_VAR 0 4
15414: PPUSH
15415: CALL_OW 488
15419: IFFALSE 15442
// begin result := [ x , y ] ;
15421: LD_ADDR_VAR 0 1
15425: PUSH
15426: LD_VAR 0 3
15430: PUSH
15431: LD_VAR 0 4
15435: PUSH
15436: EMPTY
15437: LIST
15438: LIST
15439: ST_TO_ADDR
// break ;
15440: GO 15444
// end ; end ;
15442: GO 15244
15444: POP
15445: POP
// if result then
15446: LD_VAR 0 1
15450: IFFALSE 15510
// begin ToLua ( playSibBomb() ) ;
15452: LD_STRING playSibBomb()
15454: PPUSH
15455: CALL_OW 559
// wait ( 0 0$14 ) ;
15459: LD_INT 490
15461: PPUSH
15462: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
15466: LD_VAR 0 1
15470: PUSH
15471: LD_INT 1
15473: ARRAY
15474: PPUSH
15475: LD_VAR 0 1
15479: PUSH
15480: LD_INT 2
15482: ARRAY
15483: PPUSH
15484: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
15488: LD_VAR 0 1
15492: PUSH
15493: LD_INT 1
15495: ARRAY
15496: PPUSH
15497: LD_VAR 0 1
15501: PUSH
15502: LD_INT 2
15504: ARRAY
15505: PPUSH
15506: CALL_OW 429
// end ; end ;
15510: LD_VAR 0 1
15514: RET
// every 0 0$1 trigger StreamModeActive and sReset do
15515: LD_EXP 37
15519: PUSH
15520: LD_EXP 59
15524: AND
15525: IFFALSE 15537
15527: GO 15529
15529: DISABLE
// YouLost (  ) ;
15530: LD_STRING 
15532: PPUSH
15533: CALL_OW 104
15537: END
// every 0 0$1 trigger StreamModeActive and sFog do
15538: LD_EXP 37
15542: PUSH
15543: LD_EXP 58
15547: AND
15548: IFFALSE 15562
15550: GO 15552
15552: DISABLE
// FogOff ( your_side ) ;
15553: LD_OWVAR 2
15557: PPUSH
15558: CALL_OW 344
15562: END
// every 0 0$1 trigger StreamModeActive and sSun do
15563: LD_EXP 37
15567: PUSH
15568: LD_EXP 60
15572: AND
15573: IFFALSE 15601
15575: GO 15577
15577: DISABLE
// begin solar_recharge_percent := 0 ;
15578: LD_ADDR_OWVAR 79
15582: PUSH
15583: LD_INT 0
15585: ST_TO_ADDR
// wait ( 5 5$00 ) ;
15586: LD_INT 10500
15588: PPUSH
15589: CALL_OW 67
// solar_recharge_percent := 100 ;
15593: LD_ADDR_OWVAR 79
15597: PUSH
15598: LD_INT 100
15600: ST_TO_ADDR
// end ;
15601: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
15602: LD_EXP 37
15606: PUSH
15607: LD_EXP 61
15611: AND
15612: IFFALSE 15851
15614: GO 15616
15616: DISABLE
15617: LD_INT 0
15619: PPUSH
15620: PPUSH
15621: PPUSH
// begin tmp := [ ] ;
15622: LD_ADDR_VAR 0 3
15626: PUSH
15627: EMPTY
15628: ST_TO_ADDR
// for i := 1 to 6 do
15629: LD_ADDR_VAR 0 1
15633: PUSH
15634: DOUBLE
15635: LD_INT 1
15637: DEC
15638: ST_TO_ADDR
15639: LD_INT 6
15641: PUSH
15642: FOR_TO
15643: IFFALSE 15748
// begin uc_nation := nation_nature ;
15645: LD_ADDR_OWVAR 21
15649: PUSH
15650: LD_INT 0
15652: ST_TO_ADDR
// uc_side := 0 ;
15653: LD_ADDR_OWVAR 20
15657: PUSH
15658: LD_INT 0
15660: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
15661: LD_ADDR_OWVAR 29
15665: PUSH
15666: LD_INT 12
15668: PUSH
15669: LD_INT 12
15671: PUSH
15672: EMPTY
15673: LIST
15674: LIST
15675: ST_TO_ADDR
// hc_agressivity := 20 ;
15676: LD_ADDR_OWVAR 35
15680: PUSH
15681: LD_INT 20
15683: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
15684: LD_ADDR_OWVAR 28
15688: PUSH
15689: LD_INT 17
15691: ST_TO_ADDR
// hc_gallery :=  ;
15692: LD_ADDR_OWVAR 33
15696: PUSH
15697: LD_STRING 
15699: ST_TO_ADDR
// hc_name :=  ;
15700: LD_ADDR_OWVAR 26
15704: PUSH
15705: LD_STRING 
15707: ST_TO_ADDR
// un := CreateHuman ;
15708: LD_ADDR_VAR 0 2
15712: PUSH
15713: CALL_OW 44
15717: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
15718: LD_VAR 0 2
15722: PPUSH
15723: LD_INT 1
15725: PPUSH
15726: CALL_OW 51
// tmp := tmp ^ un ;
15730: LD_ADDR_VAR 0 3
15734: PUSH
15735: LD_VAR 0 3
15739: PUSH
15740: LD_VAR 0 2
15744: ADD
15745: ST_TO_ADDR
// end ;
15746: GO 15642
15748: POP
15749: POP
// repeat wait ( 0 0$1 ) ;
15750: LD_INT 35
15752: PPUSH
15753: CALL_OW 67
// for un in tmp do
15757: LD_ADDR_VAR 0 2
15761: PUSH
15762: LD_VAR 0 3
15766: PUSH
15767: FOR_IN
15768: IFFALSE 15842
// begin if IsDead ( un ) then
15770: LD_VAR 0 2
15774: PPUSH
15775: CALL_OW 301
15779: IFFALSE 15799
// begin tmp := tmp diff un ;
15781: LD_ADDR_VAR 0 3
15785: PUSH
15786: LD_VAR 0 3
15790: PUSH
15791: LD_VAR 0 2
15795: DIFF
15796: ST_TO_ADDR
// continue ;
15797: GO 15767
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
15799: LD_VAR 0 2
15803: PPUSH
15804: LD_INT 3
15806: PUSH
15807: LD_INT 22
15809: PUSH
15810: LD_INT 0
15812: PUSH
15813: EMPTY
15814: LIST
15815: LIST
15816: PUSH
15817: EMPTY
15818: LIST
15819: LIST
15820: PPUSH
15821: CALL_OW 69
15825: PPUSH
15826: LD_VAR 0 2
15830: PPUSH
15831: CALL_OW 74
15835: PPUSH
15836: CALL_OW 115
// end ;
15840: GO 15767
15842: POP
15843: POP
// until not tmp ;
15844: LD_VAR 0 3
15848: NOT
15849: IFFALSE 15750
// end ;
15851: PPOPN 3
15853: END
// every 0 0$1 trigger StreamModeActive and sTroll do
15854: LD_EXP 37
15858: PUSH
15859: LD_EXP 62
15863: AND
15864: IFFALSE 15918
15866: GO 15868
15868: DISABLE
// begin ToLua ( displayTroll(); ) ;
15869: LD_STRING displayTroll();
15871: PPUSH
15872: CALL_OW 559
// wait ( 3 3$00 ) ;
15876: LD_INT 6300
15878: PPUSH
15879: CALL_OW 67
// ToLua ( hideTroll(); ) ;
15883: LD_STRING hideTroll();
15885: PPUSH
15886: CALL_OW 559
// wait ( 1 1$00 ) ;
15890: LD_INT 2100
15892: PPUSH
15893: CALL_OW 67
// ToLua ( displayTroll(); ) ;
15897: LD_STRING displayTroll();
15899: PPUSH
15900: CALL_OW 559
// wait ( 1 1$00 ) ;
15904: LD_INT 2100
15906: PPUSH
15907: CALL_OW 67
// ToLua ( hideTroll(); ) ;
15911: LD_STRING hideTroll();
15913: PPUSH
15914: CALL_OW 559
// end ;
15918: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
15919: LD_EXP 37
15923: PUSH
15924: LD_EXP 63
15928: AND
15929: IFFALSE 15992
15931: GO 15933
15933: DISABLE
15934: LD_INT 0
15936: PPUSH
// begin p := 0 ;
15937: LD_ADDR_VAR 0 1
15941: PUSH
15942: LD_INT 0
15944: ST_TO_ADDR
// repeat game_speed := 1 ;
15945: LD_ADDR_OWVAR 65
15949: PUSH
15950: LD_INT 1
15952: ST_TO_ADDR
// wait ( 0 0$1 ) ;
15953: LD_INT 35
15955: PPUSH
15956: CALL_OW 67
// p := p + 1 ;
15960: LD_ADDR_VAR 0 1
15964: PUSH
15965: LD_VAR 0 1
15969: PUSH
15970: LD_INT 1
15972: PLUS
15973: ST_TO_ADDR
// until p >= 60 ;
15974: LD_VAR 0 1
15978: PUSH
15979: LD_INT 60
15981: GREATEREQUAL
15982: IFFALSE 15945
// game_speed := 4 ;
15984: LD_ADDR_OWVAR 65
15988: PUSH
15989: LD_INT 4
15991: ST_TO_ADDR
// end ;
15992: PPOPN 1
15994: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
15995: LD_EXP 37
15999: PUSH
16000: LD_EXP 64
16004: AND
16005: IFFALSE 16151
16007: GO 16009
16009: DISABLE
16010: LD_INT 0
16012: PPUSH
16013: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
16014: LD_ADDR_VAR 0 1
16018: PUSH
16019: LD_INT 22
16021: PUSH
16022: LD_OWVAR 2
16026: PUSH
16027: EMPTY
16028: LIST
16029: LIST
16030: PUSH
16031: LD_INT 2
16033: PUSH
16034: LD_INT 30
16036: PUSH
16037: LD_INT 0
16039: PUSH
16040: EMPTY
16041: LIST
16042: LIST
16043: PUSH
16044: LD_INT 30
16046: PUSH
16047: LD_INT 1
16049: PUSH
16050: EMPTY
16051: LIST
16052: LIST
16053: PUSH
16054: EMPTY
16055: LIST
16056: LIST
16057: LIST
16058: PUSH
16059: EMPTY
16060: LIST
16061: LIST
16062: PPUSH
16063: CALL_OW 69
16067: ST_TO_ADDR
// if not depot then
16068: LD_VAR 0 1
16072: NOT
16073: IFFALSE 16077
// exit ;
16075: GO 16151
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
16077: LD_ADDR_VAR 0 2
16081: PUSH
16082: LD_VAR 0 1
16086: PUSH
16087: LD_INT 1
16089: PPUSH
16090: LD_VAR 0 1
16094: PPUSH
16095: CALL_OW 12
16099: ARRAY
16100: PPUSH
16101: CALL_OW 274
16105: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
16106: LD_VAR 0 2
16110: PPUSH
16111: LD_INT 1
16113: PPUSH
16114: LD_INT 0
16116: PPUSH
16117: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
16121: LD_VAR 0 2
16125: PPUSH
16126: LD_INT 2
16128: PPUSH
16129: LD_INT 0
16131: PPUSH
16132: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
16136: LD_VAR 0 2
16140: PPUSH
16141: LD_INT 3
16143: PPUSH
16144: LD_INT 0
16146: PPUSH
16147: CALL_OW 277
// end ;
16151: PPOPN 2
16153: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
16154: LD_EXP 37
16158: PUSH
16159: LD_EXP 65
16163: AND
16164: IFFALSE 16261
16166: GO 16168
16168: DISABLE
16169: LD_INT 0
16171: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
16172: LD_ADDR_VAR 0 1
16176: PUSH
16177: LD_INT 22
16179: PUSH
16180: LD_OWVAR 2
16184: PUSH
16185: EMPTY
16186: LIST
16187: LIST
16188: PUSH
16189: LD_INT 21
16191: PUSH
16192: LD_INT 1
16194: PUSH
16195: EMPTY
16196: LIST
16197: LIST
16198: PUSH
16199: LD_INT 3
16201: PUSH
16202: LD_INT 23
16204: PUSH
16205: LD_INT 0
16207: PUSH
16208: EMPTY
16209: LIST
16210: LIST
16211: PUSH
16212: EMPTY
16213: LIST
16214: LIST
16215: PUSH
16216: EMPTY
16217: LIST
16218: LIST
16219: LIST
16220: PPUSH
16221: CALL_OW 69
16225: ST_TO_ADDR
// if not tmp then
16226: LD_VAR 0 1
16230: NOT
16231: IFFALSE 16235
// exit ;
16233: GO 16261
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
16235: LD_VAR 0 1
16239: PUSH
16240: LD_INT 1
16242: PPUSH
16243: LD_VAR 0 1
16247: PPUSH
16248: CALL_OW 12
16252: ARRAY
16253: PPUSH
16254: LD_INT 200
16256: PPUSH
16257: CALL_OW 234
// end ;
16261: PPOPN 1
16263: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
16264: LD_EXP 37
16268: PUSH
16269: LD_EXP 66
16273: AND
16274: IFFALSE 16353
16276: GO 16278
16278: DISABLE
16279: LD_INT 0
16281: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
16282: LD_ADDR_VAR 0 1
16286: PUSH
16287: LD_INT 22
16289: PUSH
16290: LD_OWVAR 2
16294: PUSH
16295: EMPTY
16296: LIST
16297: LIST
16298: PUSH
16299: LD_INT 21
16301: PUSH
16302: LD_INT 2
16304: PUSH
16305: EMPTY
16306: LIST
16307: LIST
16308: PUSH
16309: EMPTY
16310: LIST
16311: LIST
16312: PPUSH
16313: CALL_OW 69
16317: ST_TO_ADDR
// if not tmp then
16318: LD_VAR 0 1
16322: NOT
16323: IFFALSE 16327
// exit ;
16325: GO 16353
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
16327: LD_VAR 0 1
16331: PUSH
16332: LD_INT 1
16334: PPUSH
16335: LD_VAR 0 1
16339: PPUSH
16340: CALL_OW 12
16344: ARRAY
16345: PPUSH
16346: LD_INT 60
16348: PPUSH
16349: CALL_OW 234
// end ;
16353: PPOPN 1
16355: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
16356: LD_EXP 37
16360: PUSH
16361: LD_EXP 67
16365: AND
16366: IFFALSE 16465
16368: GO 16370
16370: DISABLE
16371: LD_INT 0
16373: PPUSH
16374: PPUSH
// begin enable ;
16375: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
16376: LD_ADDR_VAR 0 1
16380: PUSH
16381: LD_INT 22
16383: PUSH
16384: LD_OWVAR 2
16388: PUSH
16389: EMPTY
16390: LIST
16391: LIST
16392: PUSH
16393: LD_INT 61
16395: PUSH
16396: EMPTY
16397: LIST
16398: PUSH
16399: LD_INT 33
16401: PUSH
16402: LD_INT 2
16404: PUSH
16405: EMPTY
16406: LIST
16407: LIST
16408: PUSH
16409: EMPTY
16410: LIST
16411: LIST
16412: LIST
16413: PPUSH
16414: CALL_OW 69
16418: ST_TO_ADDR
// if not tmp then
16419: LD_VAR 0 1
16423: NOT
16424: IFFALSE 16428
// exit ;
16426: GO 16465
// for i in tmp do
16428: LD_ADDR_VAR 0 2
16432: PUSH
16433: LD_VAR 0 1
16437: PUSH
16438: FOR_IN
16439: IFFALSE 16463
// if IsControledBy ( i ) then
16441: LD_VAR 0 2
16445: PPUSH
16446: CALL_OW 312
16450: IFFALSE 16461
// ComUnlink ( i ) ;
16452: LD_VAR 0 2
16456: PPUSH
16457: CALL_OW 136
16461: GO 16438
16463: POP
16464: POP
// end ;
16465: PPOPN 2
16467: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
16468: LD_EXP 37
16472: PUSH
16473: LD_EXP 68
16477: AND
16478: IFFALSE 16618
16480: GO 16482
16482: DISABLE
16483: LD_INT 0
16485: PPUSH
16486: PPUSH
// begin ToLua ( displayPowell(); ) ;
16487: LD_STRING displayPowell();
16489: PPUSH
16490: CALL_OW 559
// uc_side := 0 ;
16494: LD_ADDR_OWVAR 20
16498: PUSH
16499: LD_INT 0
16501: ST_TO_ADDR
// uc_nation := 2 ;
16502: LD_ADDR_OWVAR 21
16506: PUSH
16507: LD_INT 2
16509: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
16510: LD_ADDR_OWVAR 37
16514: PUSH
16515: LD_INT 14
16517: ST_TO_ADDR
// vc_engine := engine_siberite ;
16518: LD_ADDR_OWVAR 39
16522: PUSH
16523: LD_INT 3
16525: ST_TO_ADDR
// vc_control := control_apeman ;
16526: LD_ADDR_OWVAR 38
16530: PUSH
16531: LD_INT 5
16533: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
16534: LD_ADDR_OWVAR 40
16538: PUSH
16539: LD_INT 29
16541: ST_TO_ADDR
// un := CreateVehicle ;
16542: LD_ADDR_VAR 0 2
16546: PUSH
16547: CALL_OW 45
16551: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
16552: LD_VAR 0 2
16556: PPUSH
16557: LD_INT 1
16559: PPUSH
16560: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
16564: LD_INT 35
16566: PPUSH
16567: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
16571: LD_VAR 0 2
16575: PPUSH
16576: LD_INT 22
16578: PUSH
16579: LD_OWVAR 2
16583: PUSH
16584: EMPTY
16585: LIST
16586: LIST
16587: PPUSH
16588: CALL_OW 69
16592: PPUSH
16593: LD_VAR 0 2
16597: PPUSH
16598: CALL_OW 74
16602: PPUSH
16603: CALL_OW 115
// until IsDead ( un ) ;
16607: LD_VAR 0 2
16611: PPUSH
16612: CALL_OW 301
16616: IFFALSE 16564
// end ;
16618: PPOPN 2
16620: END
// every 0 0$1 trigger StreamModeActive and sStu do
16621: LD_EXP 37
16625: PUSH
16626: LD_EXP 76
16630: AND
16631: IFFALSE 16647
16633: GO 16635
16635: DISABLE
// begin ToLua ( displayStucuk(); ) ;
16636: LD_STRING displayStucuk();
16638: PPUSH
16639: CALL_OW 559
// ResetFog ;
16643: CALL_OW 335
// end ;
16647: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
16648: LD_EXP 37
16652: PUSH
16653: LD_EXP 69
16657: AND
16658: IFFALSE 16799
16660: GO 16662
16662: DISABLE
16663: LD_INT 0
16665: PPUSH
16666: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
16667: LD_ADDR_VAR 0 2
16671: PUSH
16672: LD_INT 22
16674: PUSH
16675: LD_OWVAR 2
16679: PUSH
16680: EMPTY
16681: LIST
16682: LIST
16683: PUSH
16684: LD_INT 21
16686: PUSH
16687: LD_INT 1
16689: PUSH
16690: EMPTY
16691: LIST
16692: LIST
16693: PUSH
16694: EMPTY
16695: LIST
16696: LIST
16697: PPUSH
16698: CALL_OW 69
16702: ST_TO_ADDR
// if not tmp then
16703: LD_VAR 0 2
16707: NOT
16708: IFFALSE 16712
// exit ;
16710: GO 16799
// un := tmp [ rand ( 1 , tmp ) ] ;
16712: LD_ADDR_VAR 0 1
16716: PUSH
16717: LD_VAR 0 2
16721: PUSH
16722: LD_INT 1
16724: PPUSH
16725: LD_VAR 0 2
16729: PPUSH
16730: CALL_OW 12
16734: ARRAY
16735: ST_TO_ADDR
// SetSide ( un , 0 ) ;
16736: LD_VAR 0 1
16740: PPUSH
16741: LD_INT 0
16743: PPUSH
16744: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
16748: LD_VAR 0 1
16752: PPUSH
16753: LD_OWVAR 3
16757: PUSH
16758: LD_VAR 0 1
16762: DIFF
16763: PPUSH
16764: LD_VAR 0 1
16768: PPUSH
16769: CALL_OW 74
16773: PPUSH
16774: CALL_OW 115
// wait ( 0 0$20 ) ;
16778: LD_INT 700
16780: PPUSH
16781: CALL_OW 67
// SetSide ( un , your_side ) ;
16785: LD_VAR 0 1
16789: PPUSH
16790: LD_OWVAR 2
16794: PPUSH
16795: CALL_OW 235
// end ;
16799: PPOPN 2
16801: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
16802: LD_EXP 37
16806: PUSH
16807: LD_EXP 70
16811: AND
16812: IFFALSE 16918
16814: GO 16816
16816: DISABLE
16817: LD_INT 0
16819: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
16820: LD_ADDR_VAR 0 1
16824: PUSH
16825: LD_INT 22
16827: PUSH
16828: LD_OWVAR 2
16832: PUSH
16833: EMPTY
16834: LIST
16835: LIST
16836: PUSH
16837: LD_INT 2
16839: PUSH
16840: LD_INT 30
16842: PUSH
16843: LD_INT 0
16845: PUSH
16846: EMPTY
16847: LIST
16848: LIST
16849: PUSH
16850: LD_INT 30
16852: PUSH
16853: LD_INT 1
16855: PUSH
16856: EMPTY
16857: LIST
16858: LIST
16859: PUSH
16860: EMPTY
16861: LIST
16862: LIST
16863: LIST
16864: PUSH
16865: EMPTY
16866: LIST
16867: LIST
16868: PPUSH
16869: CALL_OW 69
16873: ST_TO_ADDR
// if not depot then
16874: LD_VAR 0 1
16878: NOT
16879: IFFALSE 16883
// exit ;
16881: GO 16918
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
16883: LD_VAR 0 1
16887: PUSH
16888: LD_INT 1
16890: ARRAY
16891: PPUSH
16892: CALL_OW 250
16896: PPUSH
16897: LD_VAR 0 1
16901: PUSH
16902: LD_INT 1
16904: ARRAY
16905: PPUSH
16906: CALL_OW 251
16910: PPUSH
16911: LD_INT 70
16913: PPUSH
16914: CALL_OW 495
// end ;
16918: PPOPN 1
16920: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
16921: LD_EXP 37
16925: PUSH
16926: LD_EXP 71
16930: AND
16931: IFFALSE 17142
16933: GO 16935
16935: DISABLE
16936: LD_INT 0
16938: PPUSH
16939: PPUSH
16940: PPUSH
16941: PPUSH
16942: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
16943: LD_ADDR_VAR 0 5
16947: PUSH
16948: LD_INT 22
16950: PUSH
16951: LD_OWVAR 2
16955: PUSH
16956: EMPTY
16957: LIST
16958: LIST
16959: PUSH
16960: LD_INT 21
16962: PUSH
16963: LD_INT 1
16965: PUSH
16966: EMPTY
16967: LIST
16968: LIST
16969: PUSH
16970: EMPTY
16971: LIST
16972: LIST
16973: PPUSH
16974: CALL_OW 69
16978: ST_TO_ADDR
// if not tmp then
16979: LD_VAR 0 5
16983: NOT
16984: IFFALSE 16988
// exit ;
16986: GO 17142
// for i in tmp do
16988: LD_ADDR_VAR 0 1
16992: PUSH
16993: LD_VAR 0 5
16997: PUSH
16998: FOR_IN
16999: IFFALSE 17140
// begin d := rand ( 0 , 5 ) ;
17001: LD_ADDR_VAR 0 4
17005: PUSH
17006: LD_INT 0
17008: PPUSH
17009: LD_INT 5
17011: PPUSH
17012: CALL_OW 12
17016: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
17017: LD_ADDR_VAR 0 2
17021: PUSH
17022: LD_VAR 0 1
17026: PPUSH
17027: CALL_OW 250
17031: PPUSH
17032: LD_VAR 0 4
17036: PPUSH
17037: LD_INT 3
17039: PPUSH
17040: LD_INT 12
17042: PPUSH
17043: CALL_OW 12
17047: PPUSH
17048: CALL_OW 272
17052: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
17053: LD_ADDR_VAR 0 3
17057: PUSH
17058: LD_VAR 0 1
17062: PPUSH
17063: CALL_OW 251
17067: PPUSH
17068: LD_VAR 0 4
17072: PPUSH
17073: LD_INT 3
17075: PPUSH
17076: LD_INT 12
17078: PPUSH
17079: CALL_OW 12
17083: PPUSH
17084: CALL_OW 273
17088: ST_TO_ADDR
// if ValidHex ( x , y ) then
17089: LD_VAR 0 2
17093: PPUSH
17094: LD_VAR 0 3
17098: PPUSH
17099: CALL_OW 488
17103: IFFALSE 17138
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
17105: LD_VAR 0 1
17109: PPUSH
17110: LD_VAR 0 2
17114: PPUSH
17115: LD_VAR 0 3
17119: PPUSH
17120: LD_INT 3
17122: PPUSH
17123: LD_INT 6
17125: PPUSH
17126: CALL_OW 12
17130: PPUSH
17131: LD_INT 1
17133: PPUSH
17134: CALL_OW 483
// end ;
17138: GO 16998
17140: POP
17141: POP
// end ;
17142: PPOPN 5
17144: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
17145: LD_EXP 37
17149: PUSH
17150: LD_EXP 72
17154: AND
17155: IFFALSE 17249
17157: GO 17159
17159: DISABLE
17160: LD_INT 0
17162: PPUSH
17163: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
17164: LD_ADDR_VAR 0 2
17168: PUSH
17169: LD_INT 22
17171: PUSH
17172: LD_OWVAR 2
17176: PUSH
17177: EMPTY
17178: LIST
17179: LIST
17180: PUSH
17181: LD_INT 32
17183: PUSH
17184: LD_INT 1
17186: PUSH
17187: EMPTY
17188: LIST
17189: LIST
17190: PUSH
17191: LD_INT 21
17193: PUSH
17194: LD_INT 2
17196: PUSH
17197: EMPTY
17198: LIST
17199: LIST
17200: PUSH
17201: EMPTY
17202: LIST
17203: LIST
17204: LIST
17205: PPUSH
17206: CALL_OW 69
17210: ST_TO_ADDR
// if not tmp then
17211: LD_VAR 0 2
17215: NOT
17216: IFFALSE 17220
// exit ;
17218: GO 17249
// for i in tmp do
17220: LD_ADDR_VAR 0 1
17224: PUSH
17225: LD_VAR 0 2
17229: PUSH
17230: FOR_IN
17231: IFFALSE 17247
// SetFuel ( i , 0 ) ;
17233: LD_VAR 0 1
17237: PPUSH
17238: LD_INT 0
17240: PPUSH
17241: CALL_OW 240
17245: GO 17230
17247: POP
17248: POP
// end ;
17249: PPOPN 2
17251: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
17252: LD_EXP 37
17256: PUSH
17257: LD_EXP 73
17261: AND
17262: IFFALSE 17328
17264: GO 17266
17266: DISABLE
17267: LD_INT 0
17269: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
17270: LD_ADDR_VAR 0 1
17274: PUSH
17275: LD_INT 22
17277: PUSH
17278: LD_OWVAR 2
17282: PUSH
17283: EMPTY
17284: LIST
17285: LIST
17286: PUSH
17287: LD_INT 30
17289: PUSH
17290: LD_INT 29
17292: PUSH
17293: EMPTY
17294: LIST
17295: LIST
17296: PUSH
17297: EMPTY
17298: LIST
17299: LIST
17300: PPUSH
17301: CALL_OW 69
17305: ST_TO_ADDR
// if not tmp then
17306: LD_VAR 0 1
17310: NOT
17311: IFFALSE 17315
// exit ;
17313: GO 17328
// DestroyUnit ( tmp [ 1 ] ) ;
17315: LD_VAR 0 1
17319: PUSH
17320: LD_INT 1
17322: ARRAY
17323: PPUSH
17324: CALL_OW 65
// end ;
17328: PPOPN 1
17330: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
17331: LD_EXP 37
17335: PUSH
17336: LD_EXP 75
17340: AND
17341: IFFALSE 17470
17343: GO 17345
17345: DISABLE
17346: LD_INT 0
17348: PPUSH
// begin uc_side := 0 ;
17349: LD_ADDR_OWVAR 20
17353: PUSH
17354: LD_INT 0
17356: ST_TO_ADDR
// uc_nation := nation_arabian ;
17357: LD_ADDR_OWVAR 21
17361: PUSH
17362: LD_INT 2
17364: ST_TO_ADDR
// hc_gallery :=  ;
17365: LD_ADDR_OWVAR 33
17369: PUSH
17370: LD_STRING 
17372: ST_TO_ADDR
// hc_name :=  ;
17373: LD_ADDR_OWVAR 26
17377: PUSH
17378: LD_STRING 
17380: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
17381: LD_INT 1
17383: PPUSH
17384: LD_INT 11
17386: PPUSH
17387: LD_INT 10
17389: PPUSH
17390: CALL_OW 380
// un := CreateHuman ;
17394: LD_ADDR_VAR 0 1
17398: PUSH
17399: CALL_OW 44
17403: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
17404: LD_VAR 0 1
17408: PPUSH
17409: LD_INT 1
17411: PPUSH
17412: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
17416: LD_INT 35
17418: PPUSH
17419: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
17423: LD_VAR 0 1
17427: PPUSH
17428: LD_INT 22
17430: PUSH
17431: LD_OWVAR 2
17435: PUSH
17436: EMPTY
17437: LIST
17438: LIST
17439: PPUSH
17440: CALL_OW 69
17444: PPUSH
17445: LD_VAR 0 1
17449: PPUSH
17450: CALL_OW 74
17454: PPUSH
17455: CALL_OW 115
// until IsDead ( un ) ;
17459: LD_VAR 0 1
17463: PPUSH
17464: CALL_OW 301
17468: IFFALSE 17416
// end ;
17470: PPOPN 1
17472: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
17473: LD_EXP 37
17477: PUSH
17478: LD_EXP 77
17482: AND
17483: IFFALSE 17495
17485: GO 17487
17487: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
17488: LD_STRING earthquake(getX(game), 0, 32)
17490: PPUSH
17491: CALL_OW 559
17495: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
17496: LD_EXP 37
17500: PUSH
17501: LD_EXP 78
17505: AND
17506: IFFALSE 17597
17508: GO 17510
17510: DISABLE
17511: LD_INT 0
17513: PPUSH
// begin enable ;
17514: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
17515: LD_ADDR_VAR 0 1
17519: PUSH
17520: LD_INT 22
17522: PUSH
17523: LD_OWVAR 2
17527: PUSH
17528: EMPTY
17529: LIST
17530: LIST
17531: PUSH
17532: LD_INT 21
17534: PUSH
17535: LD_INT 2
17537: PUSH
17538: EMPTY
17539: LIST
17540: LIST
17541: PUSH
17542: LD_INT 33
17544: PUSH
17545: LD_INT 3
17547: PUSH
17548: EMPTY
17549: LIST
17550: LIST
17551: PUSH
17552: EMPTY
17553: LIST
17554: LIST
17555: LIST
17556: PPUSH
17557: CALL_OW 69
17561: ST_TO_ADDR
// if not tmp then
17562: LD_VAR 0 1
17566: NOT
17567: IFFALSE 17571
// exit ;
17569: GO 17597
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
17571: LD_VAR 0 1
17575: PUSH
17576: LD_INT 1
17578: PPUSH
17579: LD_VAR 0 1
17583: PPUSH
17584: CALL_OW 12
17588: ARRAY
17589: PPUSH
17590: LD_INT 1
17592: PPUSH
17593: CALL_OW 234
// end ;
17597: PPOPN 1
17599: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
17600: LD_EXP 37
17604: PUSH
17605: LD_EXP 79
17609: AND
17610: IFFALSE 17751
17612: GO 17614
17614: DISABLE
17615: LD_INT 0
17617: PPUSH
17618: PPUSH
17619: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
17620: LD_ADDR_VAR 0 3
17624: PUSH
17625: LD_INT 22
17627: PUSH
17628: LD_OWVAR 2
17632: PUSH
17633: EMPTY
17634: LIST
17635: LIST
17636: PUSH
17637: LD_INT 25
17639: PUSH
17640: LD_INT 1
17642: PUSH
17643: EMPTY
17644: LIST
17645: LIST
17646: PUSH
17647: EMPTY
17648: LIST
17649: LIST
17650: PPUSH
17651: CALL_OW 69
17655: ST_TO_ADDR
// if not tmp then
17656: LD_VAR 0 3
17660: NOT
17661: IFFALSE 17665
// exit ;
17663: GO 17751
// un := tmp [ rand ( 1 , tmp ) ] ;
17665: LD_ADDR_VAR 0 2
17669: PUSH
17670: LD_VAR 0 3
17674: PUSH
17675: LD_INT 1
17677: PPUSH
17678: LD_VAR 0 3
17682: PPUSH
17683: CALL_OW 12
17687: ARRAY
17688: ST_TO_ADDR
// if Crawls ( un ) then
17689: LD_VAR 0 2
17693: PPUSH
17694: CALL_OW 318
17698: IFFALSE 17709
// ComWalk ( un ) ;
17700: LD_VAR 0 2
17704: PPUSH
17705: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
17709: LD_VAR 0 2
17713: PPUSH
17714: LD_INT 9
17716: PPUSH
17717: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
17721: LD_INT 28
17723: PPUSH
17724: LD_OWVAR 2
17728: PPUSH
17729: LD_INT 2
17731: PPUSH
17732: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
17736: LD_INT 29
17738: PPUSH
17739: LD_OWVAR 2
17743: PPUSH
17744: LD_INT 2
17746: PPUSH
17747: CALL_OW 322
// end ;
17751: PPOPN 3
17753: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
17754: LD_EXP 37
17758: PUSH
17759: LD_EXP 80
17763: AND
17764: IFFALSE 17875
17766: GO 17768
17768: DISABLE
17769: LD_INT 0
17771: PPUSH
17772: PPUSH
17773: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
17774: LD_ADDR_VAR 0 3
17778: PUSH
17779: LD_INT 22
17781: PUSH
17782: LD_OWVAR 2
17786: PUSH
17787: EMPTY
17788: LIST
17789: LIST
17790: PUSH
17791: LD_INT 25
17793: PUSH
17794: LD_INT 1
17796: PUSH
17797: EMPTY
17798: LIST
17799: LIST
17800: PUSH
17801: EMPTY
17802: LIST
17803: LIST
17804: PPUSH
17805: CALL_OW 69
17809: ST_TO_ADDR
// if not tmp then
17810: LD_VAR 0 3
17814: NOT
17815: IFFALSE 17819
// exit ;
17817: GO 17875
// un := tmp [ rand ( 1 , tmp ) ] ;
17819: LD_ADDR_VAR 0 2
17823: PUSH
17824: LD_VAR 0 3
17828: PUSH
17829: LD_INT 1
17831: PPUSH
17832: LD_VAR 0 3
17836: PPUSH
17837: CALL_OW 12
17841: ARRAY
17842: ST_TO_ADDR
// if Crawls ( un ) then
17843: LD_VAR 0 2
17847: PPUSH
17848: CALL_OW 318
17852: IFFALSE 17863
// ComWalk ( un ) ;
17854: LD_VAR 0 2
17858: PPUSH
17859: CALL_OW 138
// SetClass ( un , class_mortar ) ;
17863: LD_VAR 0 2
17867: PPUSH
17868: LD_INT 8
17870: PPUSH
17871: CALL_OW 336
// end ;
17875: PPOPN 3
17877: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
17878: LD_EXP 37
17882: PUSH
17883: LD_EXP 81
17887: AND
17888: IFFALSE 18032
17890: GO 17892
17892: DISABLE
17893: LD_INT 0
17895: PPUSH
17896: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
17897: LD_ADDR_VAR 0 2
17901: PUSH
17902: LD_INT 22
17904: PUSH
17905: LD_OWVAR 2
17909: PUSH
17910: EMPTY
17911: LIST
17912: LIST
17913: PUSH
17914: LD_INT 21
17916: PUSH
17917: LD_INT 2
17919: PUSH
17920: EMPTY
17921: LIST
17922: LIST
17923: PUSH
17924: LD_INT 2
17926: PUSH
17927: LD_INT 34
17929: PUSH
17930: LD_INT 12
17932: PUSH
17933: EMPTY
17934: LIST
17935: LIST
17936: PUSH
17937: LD_INT 34
17939: PUSH
17940: LD_INT 51
17942: PUSH
17943: EMPTY
17944: LIST
17945: LIST
17946: PUSH
17947: LD_INT 34
17949: PUSH
17950: LD_INT 32
17952: PUSH
17953: EMPTY
17954: LIST
17955: LIST
17956: PUSH
17957: EMPTY
17958: LIST
17959: LIST
17960: LIST
17961: LIST
17962: PUSH
17963: EMPTY
17964: LIST
17965: LIST
17966: LIST
17967: PPUSH
17968: CALL_OW 69
17972: ST_TO_ADDR
// if not tmp then
17973: LD_VAR 0 2
17977: NOT
17978: IFFALSE 17982
// exit ;
17980: GO 18032
// for i in tmp do
17982: LD_ADDR_VAR 0 1
17986: PUSH
17987: LD_VAR 0 2
17991: PUSH
17992: FOR_IN
17993: IFFALSE 18030
// if GetCargo ( i , mat_artifact ) = 0 then
17995: LD_VAR 0 1
17999: PPUSH
18000: LD_INT 4
18002: PPUSH
18003: CALL_OW 289
18007: PUSH
18008: LD_INT 0
18010: EQUAL
18011: IFFALSE 18028
// SetCargo ( i , mat_siberit , 100 ) ;
18013: LD_VAR 0 1
18017: PPUSH
18018: LD_INT 3
18020: PPUSH
18021: LD_INT 100
18023: PPUSH
18024: CALL_OW 290
18028: GO 17992
18030: POP
18031: POP
// end ;
18032: PPOPN 2
18034: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
18035: LD_EXP 37
18039: PUSH
18040: LD_EXP 82
18044: AND
18045: IFFALSE 18198
18047: GO 18049
18049: DISABLE
18050: LD_INT 0
18052: PPUSH
18053: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
18054: LD_ADDR_VAR 0 2
18058: PUSH
18059: LD_INT 22
18061: PUSH
18062: LD_OWVAR 2
18066: PUSH
18067: EMPTY
18068: LIST
18069: LIST
18070: PPUSH
18071: CALL_OW 69
18075: ST_TO_ADDR
// if not tmp then
18076: LD_VAR 0 2
18080: NOT
18081: IFFALSE 18085
// exit ;
18083: GO 18198
// for i := 1 to 2 do
18085: LD_ADDR_VAR 0 1
18089: PUSH
18090: DOUBLE
18091: LD_INT 1
18093: DEC
18094: ST_TO_ADDR
18095: LD_INT 2
18097: PUSH
18098: FOR_TO
18099: IFFALSE 18196
// begin uc_side := your_side ;
18101: LD_ADDR_OWVAR 20
18105: PUSH
18106: LD_OWVAR 2
18110: ST_TO_ADDR
// uc_nation := nation_american ;
18111: LD_ADDR_OWVAR 21
18115: PUSH
18116: LD_INT 1
18118: ST_TO_ADDR
// vc_chassis := us_morphling ;
18119: LD_ADDR_OWVAR 37
18123: PUSH
18124: LD_INT 5
18126: ST_TO_ADDR
// vc_engine := engine_siberite ;
18127: LD_ADDR_OWVAR 39
18131: PUSH
18132: LD_INT 3
18134: ST_TO_ADDR
// vc_control := control_computer ;
18135: LD_ADDR_OWVAR 38
18139: PUSH
18140: LD_INT 3
18142: ST_TO_ADDR
// vc_weapon := us_double_laser ;
18143: LD_ADDR_OWVAR 40
18147: PUSH
18148: LD_INT 10
18150: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
18151: CALL_OW 45
18155: PPUSH
18156: LD_VAR 0 2
18160: PUSH
18161: LD_INT 1
18163: ARRAY
18164: PPUSH
18165: CALL_OW 250
18169: PPUSH
18170: LD_VAR 0 2
18174: PUSH
18175: LD_INT 1
18177: ARRAY
18178: PPUSH
18179: CALL_OW 251
18183: PPUSH
18184: LD_INT 12
18186: PPUSH
18187: LD_INT 1
18189: PPUSH
18190: CALL_OW 50
// end ;
18194: GO 18098
18196: POP
18197: POP
// end ;
18198: PPOPN 2
18200: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
18201: LD_EXP 37
18205: PUSH
18206: LD_EXP 83
18210: AND
18211: IFFALSE 18433
18213: GO 18215
18215: DISABLE
18216: LD_INT 0
18218: PPUSH
18219: PPUSH
18220: PPUSH
18221: PPUSH
18222: PPUSH
18223: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
18224: LD_ADDR_VAR 0 6
18228: PUSH
18229: LD_INT 22
18231: PUSH
18232: LD_OWVAR 2
18236: PUSH
18237: EMPTY
18238: LIST
18239: LIST
18240: PUSH
18241: LD_INT 21
18243: PUSH
18244: LD_INT 1
18246: PUSH
18247: EMPTY
18248: LIST
18249: LIST
18250: PUSH
18251: LD_INT 3
18253: PUSH
18254: LD_INT 23
18256: PUSH
18257: LD_INT 0
18259: PUSH
18260: EMPTY
18261: LIST
18262: LIST
18263: PUSH
18264: EMPTY
18265: LIST
18266: LIST
18267: PUSH
18268: EMPTY
18269: LIST
18270: LIST
18271: LIST
18272: PPUSH
18273: CALL_OW 69
18277: ST_TO_ADDR
// if not tmp then
18278: LD_VAR 0 6
18282: NOT
18283: IFFALSE 18287
// exit ;
18285: GO 18433
// s1 := rand ( 1 , 4 ) ;
18287: LD_ADDR_VAR 0 2
18291: PUSH
18292: LD_INT 1
18294: PPUSH
18295: LD_INT 4
18297: PPUSH
18298: CALL_OW 12
18302: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
18303: LD_ADDR_VAR 0 4
18307: PUSH
18308: LD_VAR 0 6
18312: PUSH
18313: LD_INT 1
18315: ARRAY
18316: PPUSH
18317: LD_VAR 0 2
18321: PPUSH
18322: CALL_OW 259
18326: ST_TO_ADDR
// if s1 = 1 then
18327: LD_VAR 0 2
18331: PUSH
18332: LD_INT 1
18334: EQUAL
18335: IFFALSE 18355
// s2 := rand ( 2 , 4 ) else
18337: LD_ADDR_VAR 0 3
18341: PUSH
18342: LD_INT 2
18344: PPUSH
18345: LD_INT 4
18347: PPUSH
18348: CALL_OW 12
18352: ST_TO_ADDR
18353: GO 18363
// s2 := 1 ;
18355: LD_ADDR_VAR 0 3
18359: PUSH
18360: LD_INT 1
18362: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
18363: LD_ADDR_VAR 0 5
18367: PUSH
18368: LD_VAR 0 6
18372: PUSH
18373: LD_INT 1
18375: ARRAY
18376: PPUSH
18377: LD_VAR 0 3
18381: PPUSH
18382: CALL_OW 259
18386: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
18387: LD_VAR 0 6
18391: PUSH
18392: LD_INT 1
18394: ARRAY
18395: PPUSH
18396: LD_VAR 0 2
18400: PPUSH
18401: LD_VAR 0 5
18405: PPUSH
18406: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
18410: LD_VAR 0 6
18414: PUSH
18415: LD_INT 1
18417: ARRAY
18418: PPUSH
18419: LD_VAR 0 3
18423: PPUSH
18424: LD_VAR 0 4
18428: PPUSH
18429: CALL_OW 237
// end ;
18433: PPOPN 6
18435: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
18436: LD_EXP 37
18440: PUSH
18441: LD_EXP 84
18445: AND
18446: IFFALSE 18525
18448: GO 18450
18450: DISABLE
18451: LD_INT 0
18453: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
18454: LD_ADDR_VAR 0 1
18458: PUSH
18459: LD_INT 22
18461: PUSH
18462: LD_OWVAR 2
18466: PUSH
18467: EMPTY
18468: LIST
18469: LIST
18470: PUSH
18471: LD_INT 30
18473: PUSH
18474: LD_INT 3
18476: PUSH
18477: EMPTY
18478: LIST
18479: LIST
18480: PUSH
18481: EMPTY
18482: LIST
18483: LIST
18484: PPUSH
18485: CALL_OW 69
18489: ST_TO_ADDR
// if not tmp then
18490: LD_VAR 0 1
18494: NOT
18495: IFFALSE 18499
// exit ;
18497: GO 18525
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
18499: LD_VAR 0 1
18503: PUSH
18504: LD_INT 1
18506: PPUSH
18507: LD_VAR 0 1
18511: PPUSH
18512: CALL_OW 12
18516: ARRAY
18517: PPUSH
18518: LD_INT 1
18520: PPUSH
18521: CALL_OW 234
// end ;
18525: PPOPN 1
18527: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
18528: LD_EXP 37
18532: PUSH
18533: LD_EXP 85
18537: AND
18538: IFFALSE 18650
18540: GO 18542
18542: DISABLE
18543: LD_INT 0
18545: PPUSH
18546: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
18547: LD_ADDR_VAR 0 2
18551: PUSH
18552: LD_INT 22
18554: PUSH
18555: LD_OWVAR 2
18559: PUSH
18560: EMPTY
18561: LIST
18562: LIST
18563: PUSH
18564: LD_INT 2
18566: PUSH
18567: LD_INT 30
18569: PUSH
18570: LD_INT 27
18572: PUSH
18573: EMPTY
18574: LIST
18575: LIST
18576: PUSH
18577: LD_INT 30
18579: PUSH
18580: LD_INT 26
18582: PUSH
18583: EMPTY
18584: LIST
18585: LIST
18586: PUSH
18587: LD_INT 30
18589: PUSH
18590: LD_INT 28
18592: PUSH
18593: EMPTY
18594: LIST
18595: LIST
18596: PUSH
18597: EMPTY
18598: LIST
18599: LIST
18600: LIST
18601: LIST
18602: PUSH
18603: EMPTY
18604: LIST
18605: LIST
18606: PPUSH
18607: CALL_OW 69
18611: ST_TO_ADDR
// if not tmp then
18612: LD_VAR 0 2
18616: NOT
18617: IFFALSE 18621
// exit ;
18619: GO 18650
// for i in tmp do
18621: LD_ADDR_VAR 0 1
18625: PUSH
18626: LD_VAR 0 2
18630: PUSH
18631: FOR_IN
18632: IFFALSE 18648
// SetLives ( i , 1 ) ;
18634: LD_VAR 0 1
18638: PPUSH
18639: LD_INT 1
18641: PPUSH
18642: CALL_OW 234
18646: GO 18631
18648: POP
18649: POP
// end ;
18650: PPOPN 2
18652: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
18653: LD_EXP 37
18657: PUSH
18658: LD_EXP 86
18662: AND
18663: IFFALSE 18937
18665: GO 18667
18667: DISABLE
18668: LD_INT 0
18670: PPUSH
18671: PPUSH
18672: PPUSH
// begin i := rand ( 1 , 7 ) ;
18673: LD_ADDR_VAR 0 1
18677: PUSH
18678: LD_INT 1
18680: PPUSH
18681: LD_INT 7
18683: PPUSH
18684: CALL_OW 12
18688: ST_TO_ADDR
// case i of 1 :
18689: LD_VAR 0 1
18693: PUSH
18694: LD_INT 1
18696: DOUBLE
18697: EQUAL
18698: IFTRUE 18702
18700: GO 18712
18702: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
18703: LD_STRING earthquake(getX(game), 0, 32)
18705: PPUSH
18706: CALL_OW 559
18710: GO 18937
18712: LD_INT 2
18714: DOUBLE
18715: EQUAL
18716: IFTRUE 18720
18718: GO 18734
18720: POP
// begin ToLua ( displayStucuk(); ) ;
18721: LD_STRING displayStucuk();
18723: PPUSH
18724: CALL_OW 559
// ResetFog ;
18728: CALL_OW 335
// end ; 3 :
18732: GO 18937
18734: LD_INT 3
18736: DOUBLE
18737: EQUAL
18738: IFTRUE 18742
18740: GO 18846
18742: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
18743: LD_ADDR_VAR 0 2
18747: PUSH
18748: LD_INT 22
18750: PUSH
18751: LD_OWVAR 2
18755: PUSH
18756: EMPTY
18757: LIST
18758: LIST
18759: PUSH
18760: LD_INT 25
18762: PUSH
18763: LD_INT 1
18765: PUSH
18766: EMPTY
18767: LIST
18768: LIST
18769: PUSH
18770: EMPTY
18771: LIST
18772: LIST
18773: PPUSH
18774: CALL_OW 69
18778: ST_TO_ADDR
// if not tmp then
18779: LD_VAR 0 2
18783: NOT
18784: IFFALSE 18788
// exit ;
18786: GO 18937
// un := tmp [ rand ( 1 , tmp ) ] ;
18788: LD_ADDR_VAR 0 3
18792: PUSH
18793: LD_VAR 0 2
18797: PUSH
18798: LD_INT 1
18800: PPUSH
18801: LD_VAR 0 2
18805: PPUSH
18806: CALL_OW 12
18810: ARRAY
18811: ST_TO_ADDR
// if Crawls ( un ) then
18812: LD_VAR 0 3
18816: PPUSH
18817: CALL_OW 318
18821: IFFALSE 18832
// ComWalk ( un ) ;
18823: LD_VAR 0 3
18827: PPUSH
18828: CALL_OW 138
// SetClass ( un , class_mortar ) ;
18832: LD_VAR 0 3
18836: PPUSH
18837: LD_INT 8
18839: PPUSH
18840: CALL_OW 336
// end ; 4 :
18844: GO 18937
18846: LD_INT 4
18848: DOUBLE
18849: EQUAL
18850: IFTRUE 18854
18852: GO 18915
18854: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
18855: LD_ADDR_VAR 0 2
18859: PUSH
18860: LD_INT 22
18862: PUSH
18863: LD_OWVAR 2
18867: PUSH
18868: EMPTY
18869: LIST
18870: LIST
18871: PUSH
18872: LD_INT 30
18874: PUSH
18875: LD_INT 29
18877: PUSH
18878: EMPTY
18879: LIST
18880: LIST
18881: PUSH
18882: EMPTY
18883: LIST
18884: LIST
18885: PPUSH
18886: CALL_OW 69
18890: ST_TO_ADDR
// if not tmp then
18891: LD_VAR 0 2
18895: NOT
18896: IFFALSE 18900
// exit ;
18898: GO 18937
// DestroyUnit ( tmp [ 1 ] ) ;
18900: LD_VAR 0 2
18904: PUSH
18905: LD_INT 1
18907: ARRAY
18908: PPUSH
18909: CALL_OW 65
// end ; 5 .. 7 :
18913: GO 18937
18915: LD_INT 5
18917: DOUBLE
18918: GREATEREQUAL
18919: IFFALSE 18927
18921: LD_INT 7
18923: DOUBLE
18924: LESSEQUAL
18925: IFTRUE 18929
18927: GO 18936
18929: POP
// StreamSibBomb ; end ;
18930: CALL 15217 0 0
18934: GO 18937
18936: POP
// end ;
18937: PPOPN 3
18939: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
18940: LD_EXP 37
18944: PUSH
18945: LD_EXP 87
18949: AND
18950: IFFALSE 19106
18952: GO 18954
18954: DISABLE
18955: LD_INT 0
18957: PPUSH
18958: PPUSH
18959: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
18960: LD_ADDR_VAR 0 2
18964: PUSH
18965: LD_INT 81
18967: PUSH
18968: LD_OWVAR 2
18972: PUSH
18973: EMPTY
18974: LIST
18975: LIST
18976: PUSH
18977: LD_INT 2
18979: PUSH
18980: LD_INT 21
18982: PUSH
18983: LD_INT 1
18985: PUSH
18986: EMPTY
18987: LIST
18988: LIST
18989: PUSH
18990: LD_INT 21
18992: PUSH
18993: LD_INT 2
18995: PUSH
18996: EMPTY
18997: LIST
18998: LIST
18999: PUSH
19000: EMPTY
19001: LIST
19002: LIST
19003: LIST
19004: PUSH
19005: EMPTY
19006: LIST
19007: LIST
19008: PPUSH
19009: CALL_OW 69
19013: ST_TO_ADDR
// if not tmp then
19014: LD_VAR 0 2
19018: NOT
19019: IFFALSE 19023
// exit ;
19021: GO 19106
// p := 0 ;
19023: LD_ADDR_VAR 0 3
19027: PUSH
19028: LD_INT 0
19030: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
19031: LD_INT 35
19033: PPUSH
19034: CALL_OW 67
// p := p + 1 ;
19038: LD_ADDR_VAR 0 3
19042: PUSH
19043: LD_VAR 0 3
19047: PUSH
19048: LD_INT 1
19050: PLUS
19051: ST_TO_ADDR
// for i in tmp do
19052: LD_ADDR_VAR 0 1
19056: PUSH
19057: LD_VAR 0 2
19061: PUSH
19062: FOR_IN
19063: IFFALSE 19094
// if GetLives ( i ) < 1000 then
19065: LD_VAR 0 1
19069: PPUSH
19070: CALL_OW 256
19074: PUSH
19075: LD_INT 1000
19077: LESS
19078: IFFALSE 19092
// SetLives ( i , 1000 ) ;
19080: LD_VAR 0 1
19084: PPUSH
19085: LD_INT 1000
19087: PPUSH
19088: CALL_OW 234
19092: GO 19062
19094: POP
19095: POP
// until p > 20 ;
19096: LD_VAR 0 3
19100: PUSH
19101: LD_INT 20
19103: GREATER
19104: IFFALSE 19031
// end ;
19106: PPOPN 3
19108: END
// every 0 0$1 trigger StreamModeActive and sTime do
19109: LD_EXP 37
19113: PUSH
19114: LD_EXP 88
19118: AND
19119: IFFALSE 19154
19121: GO 19123
19123: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
19124: LD_INT 28
19126: PPUSH
19127: LD_OWVAR 2
19131: PPUSH
19132: LD_INT 2
19134: PPUSH
19135: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
19139: LD_INT 30
19141: PPUSH
19142: LD_OWVAR 2
19146: PPUSH
19147: LD_INT 2
19149: PPUSH
19150: CALL_OW 322
// end ;
19154: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
19155: LD_EXP 37
19159: PUSH
19160: LD_EXP 89
19164: AND
19165: IFFALSE 19286
19167: GO 19169
19169: DISABLE
19170: LD_INT 0
19172: PPUSH
19173: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
19174: LD_ADDR_VAR 0 2
19178: PUSH
19179: LD_INT 22
19181: PUSH
19182: LD_OWVAR 2
19186: PUSH
19187: EMPTY
19188: LIST
19189: LIST
19190: PUSH
19191: LD_INT 21
19193: PUSH
19194: LD_INT 1
19196: PUSH
19197: EMPTY
19198: LIST
19199: LIST
19200: PUSH
19201: LD_INT 3
19203: PUSH
19204: LD_INT 23
19206: PUSH
19207: LD_INT 0
19209: PUSH
19210: EMPTY
19211: LIST
19212: LIST
19213: PUSH
19214: EMPTY
19215: LIST
19216: LIST
19217: PUSH
19218: EMPTY
19219: LIST
19220: LIST
19221: LIST
19222: PPUSH
19223: CALL_OW 69
19227: ST_TO_ADDR
// if not tmp then
19228: LD_VAR 0 2
19232: NOT
19233: IFFALSE 19237
// exit ;
19235: GO 19286
// for i in tmp do
19237: LD_ADDR_VAR 0 1
19241: PUSH
19242: LD_VAR 0 2
19246: PUSH
19247: FOR_IN
19248: IFFALSE 19284
// begin if Crawls ( i ) then
19250: LD_VAR 0 1
19254: PPUSH
19255: CALL_OW 318
19259: IFFALSE 19270
// ComWalk ( i ) ;
19261: LD_VAR 0 1
19265: PPUSH
19266: CALL_OW 138
// SetClass ( i , 2 ) ;
19270: LD_VAR 0 1
19274: PPUSH
19275: LD_INT 2
19277: PPUSH
19278: CALL_OW 336
// end ;
19282: GO 19247
19284: POP
19285: POP
// end ;
19286: PPOPN 2
19288: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
19289: LD_EXP 37
19293: PUSH
19294: LD_EXP 90
19298: AND
19299: IFFALSE 19580
19301: GO 19303
19303: DISABLE
19304: LD_INT 0
19306: PPUSH
19307: PPUSH
19308: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
19309: LD_OWVAR 2
19313: PPUSH
19314: LD_INT 9
19316: PPUSH
19317: LD_INT 1
19319: PPUSH
19320: LD_INT 1
19322: PPUSH
19323: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
19327: LD_INT 9
19329: PPUSH
19330: LD_OWVAR 2
19334: PPUSH
19335: CALL_OW 343
// uc_side := 9 ;
19339: LD_ADDR_OWVAR 20
19343: PUSH
19344: LD_INT 9
19346: ST_TO_ADDR
// uc_nation := 2 ;
19347: LD_ADDR_OWVAR 21
19351: PUSH
19352: LD_INT 2
19354: ST_TO_ADDR
// hc_name := Dark Warrior ;
19355: LD_ADDR_OWVAR 26
19359: PUSH
19360: LD_STRING Dark Warrior
19362: ST_TO_ADDR
// hc_gallery :=  ;
19363: LD_ADDR_OWVAR 33
19367: PUSH
19368: LD_STRING 
19370: ST_TO_ADDR
// hc_noskilllimit := true ;
19371: LD_ADDR_OWVAR 76
19375: PUSH
19376: LD_INT 1
19378: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
19379: LD_ADDR_OWVAR 31
19383: PUSH
19384: LD_INT 30
19386: PUSH
19387: LD_INT 30
19389: PUSH
19390: LD_INT 30
19392: PUSH
19393: LD_INT 30
19395: PUSH
19396: EMPTY
19397: LIST
19398: LIST
19399: LIST
19400: LIST
19401: ST_TO_ADDR
// un := CreateHuman ;
19402: LD_ADDR_VAR 0 3
19406: PUSH
19407: CALL_OW 44
19411: ST_TO_ADDR
// hc_noskilllimit := false ;
19412: LD_ADDR_OWVAR 76
19416: PUSH
19417: LD_INT 0
19419: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
19420: LD_VAR 0 3
19424: PPUSH
19425: LD_INT 1
19427: PPUSH
19428: CALL_OW 51
// p := 0 ;
19432: LD_ADDR_VAR 0 2
19436: PUSH
19437: LD_INT 0
19439: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
19440: LD_INT 35
19442: PPUSH
19443: CALL_OW 67
// p := p + 1 ;
19447: LD_ADDR_VAR 0 2
19451: PUSH
19452: LD_VAR 0 2
19456: PUSH
19457: LD_INT 1
19459: PLUS
19460: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
19461: LD_VAR 0 3
19465: PPUSH
19466: CALL_OW 256
19470: PUSH
19471: LD_INT 1000
19473: LESS
19474: IFFALSE 19488
// SetLives ( un , 1000 ) ;
19476: LD_VAR 0 3
19480: PPUSH
19481: LD_INT 1000
19483: PPUSH
19484: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
19488: LD_VAR 0 3
19492: PPUSH
19493: LD_INT 81
19495: PUSH
19496: LD_OWVAR 2
19500: PUSH
19501: EMPTY
19502: LIST
19503: LIST
19504: PUSH
19505: LD_INT 91
19507: PUSH
19508: LD_VAR 0 3
19512: PUSH
19513: LD_INT 30
19515: PUSH
19516: EMPTY
19517: LIST
19518: LIST
19519: LIST
19520: PUSH
19521: EMPTY
19522: LIST
19523: LIST
19524: PPUSH
19525: CALL_OW 69
19529: PPUSH
19530: LD_VAR 0 3
19534: PPUSH
19535: CALL_OW 74
19539: PPUSH
19540: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
19544: LD_VAR 0 2
19548: PUSH
19549: LD_INT 60
19551: GREATER
19552: PUSH
19553: LD_VAR 0 3
19557: PPUSH
19558: CALL_OW 301
19562: OR
19563: IFFALSE 19440
// if un then
19565: LD_VAR 0 3
19569: IFFALSE 19580
// RemoveUnit ( un ) ;
19571: LD_VAR 0 3
19575: PPUSH
19576: CALL_OW 64
// end ; end_of_file
19580: PPOPN 3
19582: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
19583: LD_INT 0
19585: PPUSH
19586: PPUSH
19587: PPUSH
19588: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
19589: LD_VAR 0 1
19593: PPUSH
19594: CALL_OW 264
19598: PUSH
19599: LD_EXP 28
19603: EQUAL
19604: IFFALSE 19676
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
19606: LD_INT 68
19608: PPUSH
19609: LD_VAR 0 1
19613: PPUSH
19614: CALL_OW 255
19618: PPUSH
19619: CALL_OW 321
19623: PUSH
19624: LD_INT 2
19626: EQUAL
19627: IFFALSE 19639
// eff := 70 else
19629: LD_ADDR_VAR 0 4
19633: PUSH
19634: LD_INT 70
19636: ST_TO_ADDR
19637: GO 19647
// eff := 30 ;
19639: LD_ADDR_VAR 0 4
19643: PUSH
19644: LD_INT 30
19646: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
19647: LD_VAR 0 1
19651: PPUSH
19652: CALL_OW 250
19656: PPUSH
19657: LD_VAR 0 1
19661: PPUSH
19662: CALL_OW 251
19666: PPUSH
19667: LD_VAR 0 4
19671: PPUSH
19672: CALL_OW 495
// end ; end ;
19676: LD_VAR 0 2
19680: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
19681: LD_INT 0
19683: PPUSH
// end ;
19684: LD_VAR 0 4
19688: RET
// export function SOS_Command ( cmd ) ; begin
19689: LD_INT 0
19691: PPUSH
// end ;
19692: LD_VAR 0 2
19696: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
19697: LD_VAR 0 1
19701: PUSH
19702: LD_INT 255
19704: EQUAL
19705: PUSH
19706: LD_VAR 0 2
19710: PPUSH
19711: CALL_OW 264
19715: PUSH
19716: LD_INT 14
19718: PUSH
19719: LD_INT 53
19721: PUSH
19722: EMPTY
19723: LIST
19724: LIST
19725: IN
19726: AND
19727: PUSH
19728: LD_VAR 0 4
19732: PPUSH
19733: LD_VAR 0 5
19737: PPUSH
19738: CALL_OW 488
19742: AND
19743: IFFALSE 19767
// CutTreeXYR ( unit , x , y , 12 ) ;
19745: LD_VAR 0 2
19749: PPUSH
19750: LD_VAR 0 4
19754: PPUSH
19755: LD_VAR 0 5
19759: PPUSH
19760: LD_INT 12
19762: PPUSH
19763: CALL 19770 0 4
// end ;
19767: PPOPN 5
19769: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
19770: LD_INT 0
19772: PPUSH
19773: PPUSH
19774: PPUSH
19775: PPUSH
19776: PPUSH
19777: PPUSH
19778: PPUSH
19779: PPUSH
19780: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
19781: LD_VAR 0 1
19785: NOT
19786: PUSH
19787: LD_VAR 0 2
19791: PPUSH
19792: LD_VAR 0 3
19796: PPUSH
19797: CALL_OW 488
19801: NOT
19802: OR
19803: PUSH
19804: LD_VAR 0 4
19808: NOT
19809: OR
19810: IFFALSE 19814
// exit ;
19812: GO 20154
// list := [ ] ;
19814: LD_ADDR_VAR 0 13
19818: PUSH
19819: EMPTY
19820: ST_TO_ADDR
// if x - r < 0 then
19821: LD_VAR 0 2
19825: PUSH
19826: LD_VAR 0 4
19830: MINUS
19831: PUSH
19832: LD_INT 0
19834: LESS
19835: IFFALSE 19847
// min_x := 0 else
19837: LD_ADDR_VAR 0 7
19841: PUSH
19842: LD_INT 0
19844: ST_TO_ADDR
19845: GO 19863
// min_x := x - r ;
19847: LD_ADDR_VAR 0 7
19851: PUSH
19852: LD_VAR 0 2
19856: PUSH
19857: LD_VAR 0 4
19861: MINUS
19862: ST_TO_ADDR
// if y - r < 0 then
19863: LD_VAR 0 3
19867: PUSH
19868: LD_VAR 0 4
19872: MINUS
19873: PUSH
19874: LD_INT 0
19876: LESS
19877: IFFALSE 19889
// min_y := 0 else
19879: LD_ADDR_VAR 0 8
19883: PUSH
19884: LD_INT 0
19886: ST_TO_ADDR
19887: GO 19905
// min_y := y - r ;
19889: LD_ADDR_VAR 0 8
19893: PUSH
19894: LD_VAR 0 3
19898: PUSH
19899: LD_VAR 0 4
19903: MINUS
19904: ST_TO_ADDR
// max_x := x + r ;
19905: LD_ADDR_VAR 0 9
19909: PUSH
19910: LD_VAR 0 2
19914: PUSH
19915: LD_VAR 0 4
19919: PLUS
19920: ST_TO_ADDR
// max_y := y + r ;
19921: LD_ADDR_VAR 0 10
19925: PUSH
19926: LD_VAR 0 3
19930: PUSH
19931: LD_VAR 0 4
19935: PLUS
19936: ST_TO_ADDR
// for _x = min_x to max_x do
19937: LD_ADDR_VAR 0 11
19941: PUSH
19942: DOUBLE
19943: LD_VAR 0 7
19947: DEC
19948: ST_TO_ADDR
19949: LD_VAR 0 9
19953: PUSH
19954: FOR_TO
19955: IFFALSE 20072
// for _y = min_y to max_y do
19957: LD_ADDR_VAR 0 12
19961: PUSH
19962: DOUBLE
19963: LD_VAR 0 8
19967: DEC
19968: ST_TO_ADDR
19969: LD_VAR 0 10
19973: PUSH
19974: FOR_TO
19975: IFFALSE 20068
// begin if not ValidHex ( _x , _y ) then
19977: LD_VAR 0 11
19981: PPUSH
19982: LD_VAR 0 12
19986: PPUSH
19987: CALL_OW 488
19991: NOT
19992: IFFALSE 19996
// continue ;
19994: GO 19974
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
19996: LD_VAR 0 11
20000: PPUSH
20001: LD_VAR 0 12
20005: PPUSH
20006: CALL_OW 351
20010: PUSH
20011: LD_VAR 0 11
20015: PPUSH
20016: LD_VAR 0 12
20020: PPUSH
20021: CALL_OW 554
20025: AND
20026: IFFALSE 20066
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
20028: LD_ADDR_VAR 0 13
20032: PUSH
20033: LD_VAR 0 13
20037: PPUSH
20038: LD_VAR 0 13
20042: PUSH
20043: LD_INT 1
20045: PLUS
20046: PPUSH
20047: LD_VAR 0 11
20051: PUSH
20052: LD_VAR 0 12
20056: PUSH
20057: EMPTY
20058: LIST
20059: LIST
20060: PPUSH
20061: CALL_OW 2
20065: ST_TO_ADDR
// end ;
20066: GO 19974
20068: POP
20069: POP
20070: GO 19954
20072: POP
20073: POP
// if not list then
20074: LD_VAR 0 13
20078: NOT
20079: IFFALSE 20083
// exit ;
20081: GO 20154
// for i in list do
20083: LD_ADDR_VAR 0 6
20087: PUSH
20088: LD_VAR 0 13
20092: PUSH
20093: FOR_IN
20094: IFFALSE 20152
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
20096: LD_VAR 0 1
20100: PPUSH
20101: LD_STRING M
20103: PUSH
20104: LD_VAR 0 6
20108: PUSH
20109: LD_INT 1
20111: ARRAY
20112: PUSH
20113: LD_VAR 0 6
20117: PUSH
20118: LD_INT 2
20120: ARRAY
20121: PUSH
20122: LD_INT 0
20124: PUSH
20125: LD_INT 0
20127: PUSH
20128: LD_INT 0
20130: PUSH
20131: LD_INT 0
20133: PUSH
20134: EMPTY
20135: LIST
20136: LIST
20137: LIST
20138: LIST
20139: LIST
20140: LIST
20141: LIST
20142: PUSH
20143: EMPTY
20144: LIST
20145: PPUSH
20146: CALL_OW 447
20150: GO 20093
20152: POP
20153: POP
// end ;
20154: LD_VAR 0 5
20158: RET
