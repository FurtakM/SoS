// starting begin ResetFog ;
   0: CALL_OW 335
// FogOff ( 1 ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 344
// RandomizeAll ;
  11: CALL_OW 11
// Init ;
  15: CALL 32 0 0
// DebugMode ;
  19: CALL 98 0 0
// PrepareAmerican ;
  23: CALL 115 0 0
// Action ;
  27: CALL 2999 0 0
// end ;
  31: END
// export debug ; export donaldson_commander , brown_commander , save_group ; export mission_prefix , mission_prefix_prev ; function Init ; begin
  32: LD_INT 0
  34: PPUSH
// debug := false ;
  35: LD_ADDR_EXP 1
  39: PUSH
  40: LD_INT 0
  42: ST_TO_ADDR
// mission_prefix := 07_ ;
  43: LD_ADDR_EXP 5
  47: PUSH
  48: LD_STRING 07_
  50: ST_TO_ADDR
// mission_prefix_prev := [ 06_ , 05_ , 04_ ] ;
  51: LD_ADDR_EXP 6
  55: PUSH
  56: LD_STRING 06_
  58: PUSH
  59: LD_STRING 05_
  61: PUSH
  62: LD_STRING 04_
  64: PUSH
  65: EMPTY
  66: LIST
  67: LIST
  68: LIST
  69: ST_TO_ADDR
// donaldson_commander := false ;
  70: LD_ADDR_EXP 2
  74: PUSH
  75: LD_INT 0
  77: ST_TO_ADDR
// brown_commander := false ;
  78: LD_ADDR_EXP 3
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// save_group := [ ] ;
  86: LD_ADDR_EXP 4
  90: PUSH
  91: EMPTY
  92: ST_TO_ADDR
// end ;
  93: LD_VAR 0 1
  97: RET
// function DebugMode ; begin
  98: LD_INT 0
 100: PPUSH
// if not debug then
 101: LD_EXP 1
 105: NOT
 106: IFFALSE 110
// exit ;
 108: GO 110
// end ; end_of_file
 110: LD_VAR 0 1
 114: RET
// export JMM , Gladstone , Frank , Lisa , Cyrus , Bobby , Donaldson , Brown , Houten , Khatam , Harisson ; export gamma_commander ; export RandGuy ; export function PrepareAmerican ; var others , others_delta , others4 , veh , team , dep , bar , lab , fac , bun , filter , i , j ; begin
 115: LD_INT 0
 117: PPUSH
 118: PPUSH
 119: PPUSH
 120: PPUSH
 121: PPUSH
 122: PPUSH
 123: PPUSH
 124: PPUSH
 125: PPUSH
 126: PPUSH
 127: PPUSH
 128: PPUSH
 129: PPUSH
 130: PPUSH
// PrepareBase ;
 131: CALL 2582 0 0
// uc_side := 1 ;
 135: LD_ADDR_OWVAR 20
 139: PUSH
 140: LD_INT 1
 142: ST_TO_ADDR
// uc_nation := 1 ;
 143: LD_ADDR_OWVAR 21
 147: PUSH
 148: LD_INT 1
 150: ST_TO_ADDR
// team := [ ] ;
 151: LD_ADDR_VAR 0 6
 155: PUSH
 156: EMPTY
 157: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 06c_ ) ;
 158: LD_ADDR_EXP 7
 162: PUSH
 163: LD_STRING JMM
 165: PPUSH
 166: LD_EXP 1
 170: NOT
 171: PPUSH
 172: LD_STRING 06c_
 174: PPUSH
 175: CALL 4482 0 3
 179: ST_TO_ADDR
// if GetClass ( JMM ) = 2 then
 180: LD_EXP 7
 184: PPUSH
 185: CALL_OW 257
 189: PUSH
 190: LD_INT 2
 192: EQUAL
 193: IFFALSE 207
// SetClass ( JMM , 1 ) ;
 195: LD_EXP 7
 199: PPUSH
 200: LD_INT 1
 202: PPUSH
 203: CALL_OW 336
// gamma_commander := LoadVariable ( GammaCommander , 3 ) ;
 207: LD_ADDR_EXP 18
 211: PUSH
 212: LD_STRING GammaCommander
 214: PPUSH
 215: LD_INT 3
 217: PPUSH
 218: CALL_OW 30
 222: ST_TO_ADDR
// if gamma_commander = 1 then
 223: LD_EXP 18
 227: PUSH
 228: LD_INT 1
 230: EQUAL
 231: IFFALSE 257
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 04_ ) ;
 233: LD_ADDR_EXP 13
 237: PUSH
 238: LD_STRING Donaldson
 240: PPUSH
 241: LD_EXP 1
 245: NOT
 246: PPUSH
 247: LD_STRING 04_
 249: PPUSH
 250: CALL 4482 0 3
 254: ST_TO_ADDR
// end else
 255: GO 328
// begin if LoadVariable ( DonaldsonIn06 , 0 ) then
 257: LD_STRING DonaldsonIn06
 259: PPUSH
 260: LD_INT 0
 262: PPUSH
 263: CALL_OW 30
 267: IFFALSE 293
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 06c_ ) else
 269: LD_ADDR_EXP 13
 273: PUSH
 274: LD_STRING Donaldson
 276: PPUSH
 277: LD_EXP 1
 281: NOT
 282: PPUSH
 283: LD_STRING 06c_
 285: PPUSH
 286: CALL 4482 0 3
 290: ST_TO_ADDR
 291: GO 328
// if not LoadVariable ( DonaldsonStayInDelta , 0 ) then
 293: LD_STRING DonaldsonStayInDelta
 295: PPUSH
 296: LD_INT 0
 298: PPUSH
 299: CALL_OW 30
 303: NOT
 304: IFFALSE 328
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 04_ ) ;
 306: LD_ADDR_EXP 13
 310: PUSH
 311: LD_STRING Donaldson
 313: PPUSH
 314: LD_EXP 1
 318: NOT
 319: PPUSH
 320: LD_STRING 04_
 322: PPUSH
 323: CALL 4482 0 3
 327: ST_TO_ADDR
// end ; if Donaldson then
 328: LD_EXP 13
 332: IFFALSE 350
// team := team ^ Donaldson ;
 334: LD_ADDR_VAR 0 6
 338: PUSH
 339: LD_VAR 0 6
 343: PUSH
 344: LD_EXP 13
 348: ADD
 349: ST_TO_ADDR
// if gamma_commander = 2 then
 350: LD_EXP 18
 354: PUSH
 355: LD_INT 2
 357: EQUAL
 358: IFFALSE 384
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 04_ ) ;
 360: LD_ADDR_EXP 14
 364: PUSH
 365: LD_STRING Brown
 367: PPUSH
 368: LD_EXP 1
 372: NOT
 373: PPUSH
 374: LD_STRING 04_
 376: PPUSH
 377: CALL 4482 0 3
 381: ST_TO_ADDR
// end else
 382: GO 455
// begin if LoadVariable ( BrownIn06 , 0 ) then
 384: LD_STRING BrownIn06
 386: PPUSH
 387: LD_INT 0
 389: PPUSH
 390: CALL_OW 30
 394: IFFALSE 420
// Brown := PrepareUnit ( Brown , ( not debug ) , 06c_ ) else
 396: LD_ADDR_EXP 14
 400: PUSH
 401: LD_STRING Brown
 403: PPUSH
 404: LD_EXP 1
 408: NOT
 409: PPUSH
 410: LD_STRING 06c_
 412: PPUSH
 413: CALL 4482 0 3
 417: ST_TO_ADDR
 418: GO 455
// if not LoadVariable ( BrownStayInDelta , 0 ) then
 420: LD_STRING BrownStayInDelta
 422: PPUSH
 423: LD_INT 0
 425: PPUSH
 426: CALL_OW 30
 430: NOT
 431: IFFALSE 455
// Brown := PrepareUnit ( Brown , ( not debug ) , 04_ ) ;
 433: LD_ADDR_EXP 14
 437: PUSH
 438: LD_STRING Brown
 440: PPUSH
 441: LD_EXP 1
 445: NOT
 446: PPUSH
 447: LD_STRING 04_
 449: PPUSH
 450: CALL 4482 0 3
 454: ST_TO_ADDR
// end ; if Brown then
 455: LD_EXP 14
 459: IFFALSE 477
// team := team ^ Brown ;
 461: LD_ADDR_VAR 0 6
 465: PUSH
 466: LD_VAR 0 6
 470: PUSH
 471: LD_EXP 14
 475: ADD
 476: ST_TO_ADDR
// if gamma_commander = 3 then
 477: LD_EXP 18
 481: PUSH
 482: LD_INT 3
 484: EQUAL
 485: IFFALSE 522
// begin Houten := PrepareUnit ( VanHouten , false ,  ) ;
 487: LD_ADDR_EXP 15
 491: PUSH
 492: LD_STRING VanHouten
 494: PPUSH
 495: LD_INT 0
 497: PPUSH
 498: LD_STRING 
 500: PPUSH
 501: CALL 4482 0 3
 505: ST_TO_ADDR
// team := team ^ Houten ;
 506: LD_ADDR_VAR 0 6
 510: PUSH
 511: LD_VAR 0 6
 515: PUSH
 516: LD_EXP 15
 520: ADD
 521: ST_TO_ADDR
// end ; if LoadVariable ( GladstoneIn06 , 0 ) then
 522: LD_STRING GladstoneIn06
 524: PPUSH
 525: LD_INT 0
 527: PPUSH
 528: CALL_OW 30
 532: IFFALSE 558
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 06c_ ) else
 534: LD_ADDR_EXP 8
 538: PUSH
 539: LD_STRING Gladstone
 541: PPUSH
 542: LD_EXP 1
 546: NOT
 547: PPUSH
 548: LD_STRING 06c_
 550: PPUSH
 551: CALL 4482 0 3
 555: ST_TO_ADDR
 556: GO 592
// if LoadVariable ( GladstoneStayInDelta , 0 ) then
 558: LD_STRING GladstoneStayInDelta
 560: PPUSH
 561: LD_INT 0
 563: PPUSH
 564: CALL_OW 30
 568: IFFALSE 592
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 06_ ) ;
 570: LD_ADDR_EXP 8
 574: PUSH
 575: LD_STRING Gladstone
 577: PPUSH
 578: LD_EXP 1
 582: NOT
 583: PPUSH
 584: LD_STRING 06_
 586: PPUSH
 587: CALL 4482 0 3
 591: ST_TO_ADDR
// if Gladstone then
 592: LD_EXP 8
 596: IFFALSE 614
// team := team ^ Gladstone ;
 598: LD_ADDR_VAR 0 6
 602: PUSH
 603: LD_VAR 0 6
 607: PUSH
 608: LD_EXP 8
 612: ADD
 613: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) , 03_ ) ;
 614: LD_ADDR_EXP 16
 618: PUSH
 619: LD_STRING Khatam
 621: PPUSH
 622: LD_EXP 1
 626: NOT
 627: PPUSH
 628: LD_STRING 03_
 630: PPUSH
 631: CALL 4482 0 3
 635: ST_TO_ADDR
// if Khatam then
 636: LD_EXP 16
 640: IFFALSE 658
// team := team ^ Khatam ;
 642: LD_ADDR_VAR 0 6
 646: PUSH
 647: LD_VAR 0 6
 651: PUSH
 652: LD_EXP 16
 656: ADD
 657: ST_TO_ADDR
// if LoadVariable ( LisaIn06 , 0 ) then
 658: LD_STRING LisaIn06
 660: PPUSH
 661: LD_INT 0
 663: PPUSH
 664: CALL_OW 30
 668: IFFALSE 694
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 06c_ ) else
 670: LD_ADDR_EXP 10
 674: PUSH
 675: LD_STRING Lisa
 677: PPUSH
 678: LD_EXP 1
 682: NOT
 683: PPUSH
 684: LD_STRING 06c_
 686: PPUSH
 687: CALL 4482 0 3
 691: ST_TO_ADDR
 692: GO 729
// if not LoadVariable ( LisaStayInDelta , 0 ) then
 694: LD_STRING LisaStayInDelta
 696: PPUSH
 697: LD_INT 0
 699: PPUSH
 700: CALL_OW 30
 704: NOT
 705: IFFALSE 729
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 04_ ) ;
 707: LD_ADDR_EXP 10
 711: PUSH
 712: LD_STRING Lisa
 714: PPUSH
 715: LD_EXP 1
 719: NOT
 720: PPUSH
 721: LD_STRING 04_
 723: PPUSH
 724: CALL 4482 0 3
 728: ST_TO_ADDR
// if Lisa then
 729: LD_EXP 10
 733: IFFALSE 751
// team := team ^ Lisa ;
 735: LD_ADDR_VAR 0 6
 739: PUSH
 740: LD_VAR 0 6
 744: PUSH
 745: LD_EXP 10
 749: ADD
 750: ST_TO_ADDR
// if not Lisa then
 751: LD_EXP 10
 755: NOT
 756: IFFALSE 1009
// begin if LoadVariable ( CyrusIn06 , 0 ) then
 758: LD_STRING CyrusIn06
 760: PPUSH
 761: LD_INT 0
 763: PPUSH
 764: CALL_OW 30
 768: IFFALSE 794
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 06c_ ) else
 770: LD_ADDR_EXP 11
 774: PUSH
 775: LD_STRING Cyrus
 777: PPUSH
 778: LD_EXP 1
 782: NOT
 783: PPUSH
 784: LD_STRING 06c_
 786: PPUSH
 787: CALL 4482 0 3
 791: ST_TO_ADDR
 792: GO 858
// if not LoadVariable ( CyrusStayInDelta , 0 ) then
 794: LD_STRING CyrusStayInDelta
 796: PPUSH
 797: LD_INT 0
 799: PPUSH
 800: CALL_OW 30
 804: NOT
 805: IFFALSE 858
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 04_ ) ;
 807: LD_ADDR_EXP 11
 811: PUSH
 812: LD_STRING Cyrus
 814: PPUSH
 815: LD_EXP 1
 819: NOT
 820: PPUSH
 821: LD_STRING 04_
 823: PPUSH
 824: CALL 4482 0 3
 828: ST_TO_ADDR
// if not Cyrus then
 829: LD_EXP 11
 833: NOT
 834: IFFALSE 858
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 03_ ) ;
 836: LD_ADDR_EXP 11
 840: PUSH
 841: LD_STRING Cyrus
 843: PPUSH
 844: LD_EXP 1
 848: NOT
 849: PPUSH
 850: LD_STRING 03_
 852: PPUSH
 853: CALL 4482 0 3
 857: ST_TO_ADDR
// end ; if Cyrus then
 858: LD_EXP 11
 862: IFFALSE 880
// team := team ^ Cyrus ;
 864: LD_ADDR_VAR 0 6
 868: PUSH
 869: LD_VAR 0 6
 873: PUSH
 874: LD_EXP 11
 878: ADD
 879: ST_TO_ADDR
// if not Cyrus then
 880: LD_EXP 11
 884: NOT
 885: IFFALSE 1009
// begin if LoadVariable ( BobbyIn06 , 0 ) then
 887: LD_STRING BobbyIn06
 889: PPUSH
 890: LD_INT 0
 892: PPUSH
 893: CALL_OW 30
 897: IFFALSE 923
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 06c_ ) else
 899: LD_ADDR_EXP 12
 903: PUSH
 904: LD_STRING Bobby
 906: PPUSH
 907: LD_EXP 1
 911: NOT
 912: PPUSH
 913: LD_STRING 06c_
 915: PPUSH
 916: CALL 4482 0 3
 920: ST_TO_ADDR
 921: GO 987
// if not LoadVariable ( BobbyStayInDelta , 0 ) then
 923: LD_STRING BobbyStayInDelta
 925: PPUSH
 926: LD_INT 0
 928: PPUSH
 929: CALL_OW 30
 933: NOT
 934: IFFALSE 987
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 04_ ) ;
 936: LD_ADDR_EXP 12
 940: PUSH
 941: LD_STRING Bobby
 943: PPUSH
 944: LD_EXP 1
 948: NOT
 949: PPUSH
 950: LD_STRING 04_
 952: PPUSH
 953: CALL 4482 0 3
 957: ST_TO_ADDR
// if not Bobby then
 958: LD_EXP 12
 962: NOT
 963: IFFALSE 987
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 03_ ) ;
 965: LD_ADDR_EXP 12
 969: PUSH
 970: LD_STRING Bobby
 972: PPUSH
 973: LD_EXP 1
 977: NOT
 978: PPUSH
 979: LD_STRING 03_
 981: PPUSH
 982: CALL 4482 0 3
 986: ST_TO_ADDR
// end ; if Bobby then
 987: LD_EXP 12
 991: IFFALSE 1009
// team := team ^ Bobby ;
 993: LD_ADDR_VAR 0 6
 997: PUSH
 998: LD_VAR 0 6
1002: PUSH
1003: LD_EXP 12
1007: ADD
1008: ST_TO_ADDR
// end ; end ; others4 := CreateCharacterSet ( othersGamma ) ;
1009: LD_ADDR_VAR 0 4
1013: PUSH
1014: LD_STRING othersGamma
1016: PPUSH
1017: CALL_OW 31
1021: ST_TO_ADDR
// others := CreateCharacterSet ( 06_other_survivors ) ;
1022: LD_ADDR_VAR 0 2
1026: PUSH
1027: LD_STRING 06_other_survivors
1029: PPUSH
1030: CALL_OW 31
1034: ST_TO_ADDR
// others := others union others4 ;
1035: LD_ADDR_VAR 0 2
1039: PUSH
1040: LD_VAR 0 2
1044: PUSH
1045: LD_VAR 0 4
1049: UNION
1050: ST_TO_ADDR
// team := team ^ others ;
1051: LD_ADDR_VAR 0 6
1055: PUSH
1056: LD_VAR 0 6
1060: PUSH
1061: LD_VAR 0 2
1065: ADD
1066: ST_TO_ADDR
// InitHc ;
1067: CALL_OW 19
// if team <= 12 then
1071: LD_VAR 0 6
1075: PUSH
1076: LD_INT 12
1078: LESSEQUAL
1079: IFFALSE 1128
// repeat PrepareHuman ( false , rand ( 1 , 4 ) , 5 ) ;
1081: LD_INT 0
1083: PPUSH
1084: LD_INT 1
1086: PPUSH
1087: LD_INT 4
1089: PPUSH
1090: CALL_OW 12
1094: PPUSH
1095: LD_INT 5
1097: PPUSH
1098: CALL_OW 380
// team := team ^ CreateHuman ;
1102: LD_ADDR_VAR 0 6
1106: PUSH
1107: LD_VAR 0 6
1111: PUSH
1112: CALL_OW 44
1116: ADD
1117: ST_TO_ADDR
// until team > 12 ;
1118: LD_VAR 0 6
1122: PUSH
1123: LD_INT 12
1125: GREATER
1126: IFFALSE 1081
// for i in others do
1128: LD_ADDR_VAR 0 13
1132: PUSH
1133: LD_VAR 0 2
1137: PUSH
1138: FOR_IN
1139: IFFALSE 1207
// begin if GetClass ( i ) = 2 then
1141: LD_VAR 0 13
1145: PPUSH
1146: CALL_OW 257
1150: PUSH
1151: LD_INT 2
1153: EQUAL
1154: IFFALSE 1168
// SetClass ( i , 1 ) ;
1156: LD_VAR 0 13
1160: PPUSH
1161: LD_INT 1
1163: PPUSH
1164: CALL_OW 336
// for j = 1 to 4 do
1168: LD_ADDR_VAR 0 14
1172: PUSH
1173: DOUBLE
1174: LD_INT 1
1176: DEC
1177: ST_TO_ADDR
1178: LD_INT 4
1180: PUSH
1181: FOR_TO
1182: IFFALSE 1203
// AddExperience ( i , j , 3000 ) ;
1184: LD_VAR 0 13
1188: PPUSH
1189: LD_VAR 0 14
1193: PPUSH
1194: LD_INT 3000
1196: PPUSH
1197: CALL_OW 492
1201: GO 1181
1203: POP
1204: POP
// end ;
1205: GO 1138
1207: POP
1208: POP
// if UnitFilter ( team , [ f_class , 2 ] ) then
1209: LD_VAR 0 6
1213: PPUSH
1214: LD_INT 25
1216: PUSH
1217: LD_INT 2
1219: PUSH
1220: EMPTY
1221: LIST
1222: LIST
1223: PPUSH
1224: CALL_OW 72
1228: IFFALSE 1274
// for i in UnitFilter ( team , [ f_class , 2 ] ) do
1230: LD_ADDR_VAR 0 13
1234: PUSH
1235: LD_VAR 0 6
1239: PPUSH
1240: LD_INT 25
1242: PUSH
1243: LD_INT 2
1245: PUSH
1246: EMPTY
1247: LIST
1248: LIST
1249: PPUSH
1250: CALL_OW 72
1254: PUSH
1255: FOR_IN
1256: IFFALSE 1272
// SetClass ( i , 1 ) ;
1258: LD_VAR 0 13
1262: PPUSH
1263: LD_INT 1
1265: PPUSH
1266: CALL_OW 336
1270: GO 1255
1272: POP
1273: POP
// dep := FilterAllUnits ( [ f_btype , b_depot ] ) ;
1274: LD_ADDR_VAR 0 7
1278: PUSH
1279: LD_INT 30
1281: PUSH
1282: LD_INT 0
1284: PUSH
1285: EMPTY
1286: LIST
1287: LIST
1288: PPUSH
1289: CALL_OW 69
1293: ST_TO_ADDR
// bar := FilterAllUnits ( [ f_btype , b_armoury ] ) ;
1294: LD_ADDR_VAR 0 8
1298: PUSH
1299: LD_INT 30
1301: PUSH
1302: LD_INT 4
1304: PUSH
1305: EMPTY
1306: LIST
1307: LIST
1308: PPUSH
1309: CALL_OW 69
1313: ST_TO_ADDR
// lab := FilterAllUnits ( [ f_or , [ f_btype , b_lab_half ] , [ f_btype , b_lab ] ] ) ;
1314: LD_ADDR_VAR 0 9
1318: PUSH
1319: LD_INT 2
1321: PUSH
1322: LD_INT 30
1324: PUSH
1325: LD_INT 7
1327: PUSH
1328: EMPTY
1329: LIST
1330: LIST
1331: PUSH
1332: LD_INT 30
1334: PUSH
1335: LD_INT 6
1337: PUSH
1338: EMPTY
1339: LIST
1340: LIST
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: LIST
1346: PPUSH
1347: CALL_OW 69
1351: ST_TO_ADDR
// fac := FilterAllUnits ( [ f_btype , b_factory ] ) ;
1352: LD_ADDR_VAR 0 10
1356: PUSH
1357: LD_INT 30
1359: PUSH
1360: LD_INT 3
1362: PUSH
1363: EMPTY
1364: LIST
1365: LIST
1366: PPUSH
1367: CALL_OW 69
1371: ST_TO_ADDR
// bun := FilterAllUnits ( [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ;
1372: LD_ADDR_VAR 0 11
1376: PUSH
1377: LD_INT 2
1379: PUSH
1380: LD_INT 30
1382: PUSH
1383: LD_INT 32
1385: PUSH
1386: EMPTY
1387: LIST
1388: LIST
1389: PUSH
1390: LD_INT 30
1392: PUSH
1393: LD_INT 31
1395: PUSH
1396: EMPTY
1397: LIST
1398: LIST
1399: PUSH
1400: EMPTY
1401: LIST
1402: LIST
1403: LIST
1404: PPUSH
1405: CALL_OW 69
1409: ST_TO_ADDR
// SetBName ( dep , Gamma ) ;
1410: LD_VAR 0 7
1414: PPUSH
1415: LD_STRING Gamma
1417: PPUSH
1418: CALL_OW 500
// SetResourceType ( GetBase ( dep ) , mat_oil , 10000 ) ;
1422: LD_VAR 0 7
1426: PPUSH
1427: CALL_OW 274
1431: PPUSH
1432: LD_INT 2
1434: PPUSH
1435: LD_INT 10000
1437: PPUSH
1438: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_cans , 10000 ) ;
1442: LD_VAR 0 7
1446: PPUSH
1447: CALL_OW 274
1451: PPUSH
1452: LD_INT 1
1454: PPUSH
1455: LD_INT 10000
1457: PPUSH
1458: CALL_OW 277
// if dep then
1462: LD_VAR 0 7
1466: IFFALSE 1568
// begin PlaceHumanInUnit ( JMM , dep [ 1 ] ) ;
1468: LD_EXP 7
1472: PPUSH
1473: LD_VAR 0 7
1477: PUSH
1478: LD_INT 1
1480: ARRAY
1481: PPUSH
1482: CALL_OW 52
// if Brown then
1486: LD_EXP 14
1490: IFFALSE 1526
// begin PlaceHumanInUnit ( Brown , dep [ 1 ] ) ;
1492: LD_EXP 14
1496: PPUSH
1497: LD_VAR 0 7
1501: PUSH
1502: LD_INT 1
1504: ARRAY
1505: PPUSH
1506: CALL_OW 52
// team := team diff Brown ;
1510: LD_ADDR_VAR 0 6
1514: PUSH
1515: LD_VAR 0 6
1519: PUSH
1520: LD_EXP 14
1524: DIFF
1525: ST_TO_ADDR
// end ; if Donaldson then
1526: LD_EXP 13
1530: IFFALSE 1566
// begin PlaceHumanInUnit ( Donaldson , dep [ 1 ] ) ;
1532: LD_EXP 13
1536: PPUSH
1537: LD_VAR 0 7
1541: PUSH
1542: LD_INT 1
1544: ARRAY
1545: PPUSH
1546: CALL_OW 52
// team := team diff Donaldson ;
1550: LD_ADDR_VAR 0 6
1554: PUSH
1555: LD_VAR 0 6
1559: PUSH
1560: LD_EXP 13
1564: DIFF
1565: ST_TO_ADDR
// end ; end else
1566: GO 1675
// begin PlaceUnitXYR ( JMM , 52 , 16 , 10 , false ) ;
1568: LD_EXP 7
1572: PPUSH
1573: LD_INT 52
1575: PPUSH
1576: LD_INT 16
1578: PPUSH
1579: LD_INT 10
1581: PPUSH
1582: LD_INT 0
1584: PPUSH
1585: CALL_OW 50
// if Brown then
1589: LD_EXP 14
1593: IFFALSE 1632
// begin PlaceUnitXYR ( Brown , 52 , 16 , 10 , false ) ;
1595: LD_EXP 14
1599: PPUSH
1600: LD_INT 52
1602: PPUSH
1603: LD_INT 16
1605: PPUSH
1606: LD_INT 10
1608: PPUSH
1609: LD_INT 0
1611: PPUSH
1612: CALL_OW 50
// team := team diff Brown ;
1616: LD_ADDR_VAR 0 6
1620: PUSH
1621: LD_VAR 0 6
1625: PUSH
1626: LD_EXP 14
1630: DIFF
1631: ST_TO_ADDR
// end ; if Donaldson then
1632: LD_EXP 13
1636: IFFALSE 1675
// begin PlaceUnitXYR ( Donaldson , 52 , 16 , 10 , false ) ;
1638: LD_EXP 13
1642: PPUSH
1643: LD_INT 52
1645: PPUSH
1646: LD_INT 16
1648: PPUSH
1649: LD_INT 10
1651: PPUSH
1652: LD_INT 0
1654: PPUSH
1655: CALL_OW 50
// team := team diff Donaldson ;
1659: LD_ADDR_VAR 0 6
1663: PUSH
1664: LD_VAR 0 6
1668: PUSH
1669: LD_EXP 13
1673: DIFF
1674: ST_TO_ADDR
// end ; end ; if bun and UnitFilter ( team , [ f_class , 1 ] ) then
1675: LD_VAR 0 11
1679: PUSH
1680: LD_VAR 0 6
1684: PPUSH
1685: LD_INT 25
1687: PUSH
1688: LD_INT 1
1690: PUSH
1691: EMPTY
1692: LIST
1693: LIST
1694: PPUSH
1695: CALL_OW 72
1699: AND
1700: IFFALSE 1809
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
1702: LD_ADDR_VAR 0 12
1706: PUSH
1707: LD_VAR 0 6
1711: PPUSH
1712: LD_INT 25
1714: PUSH
1715: LD_INT 1
1717: PUSH
1718: EMPTY
1719: LIST
1720: LIST
1721: PPUSH
1722: CALL_OW 72
1726: ST_TO_ADDR
// for i in bun do
1727: LD_ADDR_VAR 0 13
1731: PUSH
1732: LD_VAR 0 11
1736: PUSH
1737: FOR_IN
1738: IFFALSE 1807
// begin if not filter then
1740: LD_VAR 0 12
1744: NOT
1745: IFFALSE 1749
// break ;
1747: GO 1807
// PlaceHumanInUnit ( filter [ 1 ] , i ) ;
1749: LD_VAR 0 12
1753: PUSH
1754: LD_INT 1
1756: ARRAY
1757: PPUSH
1758: LD_VAR 0 13
1762: PPUSH
1763: CALL_OW 52
// team := team diff filter [ 1 ] ;
1767: LD_ADDR_VAR 0 6
1771: PUSH
1772: LD_VAR 0 6
1776: PUSH
1777: LD_VAR 0 12
1781: PUSH
1782: LD_INT 1
1784: ARRAY
1785: DIFF
1786: ST_TO_ADDR
// filter := Delete ( filter , 1 ) ;
1787: LD_ADDR_VAR 0 12
1791: PUSH
1792: LD_VAR 0 12
1796: PPUSH
1797: LD_INT 1
1799: PPUSH
1800: CALL_OW 3
1804: ST_TO_ADDR
// end ;
1805: GO 1737
1807: POP
1808: POP
// end ; if bar and UnitFilter ( team , [ f_class , 1 ] ) then
1809: LD_VAR 0 8
1813: PUSH
1814: LD_VAR 0 6
1818: PPUSH
1819: LD_INT 25
1821: PUSH
1822: LD_INT 1
1824: PUSH
1825: EMPTY
1826: LIST
1827: LIST
1828: PPUSH
1829: CALL_OW 72
1833: AND
1834: IFFALSE 1956
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
1836: LD_ADDR_VAR 0 12
1840: PUSH
1841: LD_VAR 0 6
1845: PPUSH
1846: LD_INT 25
1848: PUSH
1849: LD_INT 1
1851: PUSH
1852: EMPTY
1853: LIST
1854: LIST
1855: PPUSH
1856: CALL_OW 72
1860: ST_TO_ADDR
// for i = 1 to filter do
1861: LD_ADDR_VAR 0 13
1865: PUSH
1866: DOUBLE
1867: LD_INT 1
1869: DEC
1870: ST_TO_ADDR
1871: LD_VAR 0 12
1875: PUSH
1876: FOR_TO
1877: IFFALSE 1938
// begin if ( i <= 6 ) then
1879: LD_VAR 0 13
1883: PUSH
1884: LD_INT 6
1886: LESSEQUAL
1887: IFFALSE 1915
// PlaceHumanInUnit ( filter [ i ] , bar [ 1 ] ) else
1889: LD_VAR 0 12
1893: PUSH
1894: LD_VAR 0 13
1898: ARRAY
1899: PPUSH
1900: LD_VAR 0 8
1904: PUSH
1905: LD_INT 1
1907: ARRAY
1908: PPUSH
1909: CALL_OW 52
1913: GO 1936
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1915: LD_VAR 0 12
1919: PUSH
1920: LD_VAR 0 13
1924: ARRAY
1925: PPUSH
1926: LD_INT 1
1928: PPUSH
1929: LD_INT 0
1931: PPUSH
1932: CALL_OW 49
// end ;
1936: GO 1876
1938: POP
1939: POP
// team := team diff filter ;
1940: LD_ADDR_VAR 0 6
1944: PUSH
1945: LD_VAR 0 6
1949: PUSH
1950: LD_VAR 0 12
1954: DIFF
1955: ST_TO_ADDR
// end ; if lab and UnitFilter ( team , [ f_class , 4 ] ) then
1956: LD_VAR 0 9
1960: PUSH
1961: LD_VAR 0 6
1965: PPUSH
1966: LD_INT 25
1968: PUSH
1969: LD_INT 4
1971: PUSH
1972: EMPTY
1973: LIST
1974: LIST
1975: PPUSH
1976: CALL_OW 72
1980: AND
1981: IFFALSE 2103
// begin filter := UnitFilter ( team , [ f_class , 4 ] ) ;
1983: LD_ADDR_VAR 0 12
1987: PUSH
1988: LD_VAR 0 6
1992: PPUSH
1993: LD_INT 25
1995: PUSH
1996: LD_INT 4
1998: PUSH
1999: EMPTY
2000: LIST
2001: LIST
2002: PPUSH
2003: CALL_OW 72
2007: ST_TO_ADDR
// for i = 1 to filter do
2008: LD_ADDR_VAR 0 13
2012: PUSH
2013: DOUBLE
2014: LD_INT 1
2016: DEC
2017: ST_TO_ADDR
2018: LD_VAR 0 12
2022: PUSH
2023: FOR_TO
2024: IFFALSE 2085
// begin if ( i <= 6 ) then
2026: LD_VAR 0 13
2030: PUSH
2031: LD_INT 6
2033: LESSEQUAL
2034: IFFALSE 2062
// PlaceHumanInUnit ( filter [ i ] , lab [ 1 ] ) else
2036: LD_VAR 0 12
2040: PUSH
2041: LD_VAR 0 13
2045: ARRAY
2046: PPUSH
2047: LD_VAR 0 9
2051: PUSH
2052: LD_INT 1
2054: ARRAY
2055: PPUSH
2056: CALL_OW 52
2060: GO 2083
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
2062: LD_VAR 0 12
2066: PUSH
2067: LD_VAR 0 13
2071: ARRAY
2072: PPUSH
2073: LD_INT 1
2075: PPUSH
2076: LD_INT 0
2078: PPUSH
2079: CALL_OW 49
// end ;
2083: GO 2023
2085: POP
2086: POP
// team := team diff filter ;
2087: LD_ADDR_VAR 0 6
2091: PUSH
2092: LD_VAR 0 6
2096: PUSH
2097: LD_VAR 0 12
2101: DIFF
2102: ST_TO_ADDR
// end ; if fac and UnitFilter ( team , [ f_class , 3 ] ) then
2103: LD_VAR 0 10
2107: PUSH
2108: LD_VAR 0 6
2112: PPUSH
2113: LD_INT 25
2115: PUSH
2116: LD_INT 3
2118: PUSH
2119: EMPTY
2120: LIST
2121: LIST
2122: PPUSH
2123: CALL_OW 72
2127: AND
2128: IFFALSE 2250
// begin filter := UnitFilter ( team , [ f_class , 3 ] ) ;
2130: LD_ADDR_VAR 0 12
2134: PUSH
2135: LD_VAR 0 6
2139: PPUSH
2140: LD_INT 25
2142: PUSH
2143: LD_INT 3
2145: PUSH
2146: EMPTY
2147: LIST
2148: LIST
2149: PPUSH
2150: CALL_OW 72
2154: ST_TO_ADDR
// for i = 1 to filter do
2155: LD_ADDR_VAR 0 13
2159: PUSH
2160: DOUBLE
2161: LD_INT 1
2163: DEC
2164: ST_TO_ADDR
2165: LD_VAR 0 12
2169: PUSH
2170: FOR_TO
2171: IFFALSE 2232
// begin if ( i <= 6 ) then
2173: LD_VAR 0 13
2177: PUSH
2178: LD_INT 6
2180: LESSEQUAL
2181: IFFALSE 2209
// PlaceHumanInUnit ( filter [ i ] , fac [ 1 ] ) else
2183: LD_VAR 0 12
2187: PUSH
2188: LD_VAR 0 13
2192: ARRAY
2193: PPUSH
2194: LD_VAR 0 10
2198: PUSH
2199: LD_INT 1
2201: ARRAY
2202: PPUSH
2203: CALL_OW 52
2207: GO 2230
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
2209: LD_VAR 0 12
2213: PUSH
2214: LD_VAR 0 13
2218: ARRAY
2219: PPUSH
2220: LD_INT 1
2222: PPUSH
2223: LD_INT 0
2225: PPUSH
2226: CALL_OW 49
// end ;
2230: GO 2170
2232: POP
2233: POP
// team := team diff filter ;
2234: LD_ADDR_VAR 0 6
2238: PUSH
2239: LD_VAR 0 6
2243: PUSH
2244: LD_VAR 0 12
2248: DIFF
2249: ST_TO_ADDR
// end ; if team then
2250: LD_VAR 0 6
2254: IFFALSE 2297
// for i in team do
2256: LD_ADDR_VAR 0 13
2260: PUSH
2261: LD_VAR 0 6
2265: PUSH
2266: FOR_IN
2267: IFFALSE 2295
// begin PlaceUnitArea ( i , gammaBaseArea , false ) ;
2269: LD_VAR 0 13
2273: PPUSH
2274: LD_INT 1
2276: PPUSH
2277: LD_INT 0
2279: PPUSH
2280: CALL_OW 49
// ComHold ( i ) ;
2284: LD_VAR 0 13
2288: PPUSH
2289: CALL_OW 140
// end ;
2293: GO 2266
2295: POP
2296: POP
// if fac then
2297: LD_VAR 0 10
2301: IFFALSE 2337
// if UnitsInside ( fac [ 1 ] ) then
2303: LD_VAR 0 10
2307: PUSH
2308: LD_INT 1
2310: ARRAY
2311: PPUSH
2312: CALL_OW 313
2316: IFFALSE 2337
// SetSpecResearch ( fac [ 1 ] , 10 , false ) ;
2318: LD_VAR 0 10
2322: PUSH
2323: LD_INT 1
2325: ARRAY
2326: PPUSH
2327: LD_INT 10
2329: PPUSH
2330: LD_INT 0
2332: PPUSH
2333: CALL_OW 486
// if lab then
2337: LD_VAR 0 9
2341: IFFALSE 2377
// if UnitsInside ( lab [ 1 ] ) then
2343: LD_VAR 0 9
2347: PUSH
2348: LD_INT 1
2350: ARRAY
2351: PPUSH
2352: CALL_OW 313
2356: IFFALSE 2377
// SetSpecResearch ( lab [ 1 ] , 10 , false ) ;
2358: LD_VAR 0 9
2362: PUSH
2363: LD_INT 1
2365: ARRAY
2366: PPUSH
2367: LD_INT 10
2369: PPUSH
2370: LD_INT 0
2372: PPUSH
2373: CALL_OW 486
// uc_side := 4 ;
2377: LD_ADDR_OWVAR 20
2381: PUSH
2382: LD_INT 4
2384: ST_TO_ADDR
// Harisson := PrepareUnit ( Harisson , false ,  ) ;
2385: LD_ADDR_EXP 17
2389: PUSH
2390: LD_STRING Harisson
2392: PPUSH
2393: LD_INT 0
2395: PPUSH
2396: LD_STRING 
2398: PPUSH
2399: CALL 4482 0 3
2403: ST_TO_ADDR
// veh := PrepareTank ( 4 , 1 , us_medium_wheeled , engine_combustion , control_manual , us_double_gun , 100 ) ;
2404: LD_ADDR_VAR 0 5
2408: PUSH
2409: LD_INT 4
2411: PPUSH
2412: LD_INT 1
2414: PPUSH
2415: LD_INT 2
2417: PPUSH
2418: LD_INT 1
2420: PPUSH
2421: LD_INT 1
2423: PPUSH
2424: LD_INT 5
2426: PPUSH
2427: LD_INT 100
2429: PPUSH
2430: CALL 4545 0 7
2434: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
2435: LD_VAR 0 5
2439: PPUSH
2440: LD_INT 2
2442: PPUSH
2443: CALL_OW 233
// PlaceUnitXY ( veh , 22 , 9 , false ) ;
2447: LD_VAR 0 5
2451: PPUSH
2452: LD_INT 22
2454: PPUSH
2455: LD_INT 9
2457: PPUSH
2458: LD_INT 0
2460: PPUSH
2461: CALL_OW 48
// PlaceHumanInUnit ( Harisson , veh ) ;
2465: LD_EXP 17
2469: PPUSH
2470: LD_VAR 0 5
2474: PPUSH
2475: CALL_OW 52
// PrepareHuman ( false , 1 , 0 ) ;
2479: LD_INT 0
2481: PPUSH
2482: LD_INT 1
2484: PPUSH
2485: LD_INT 0
2487: PPUSH
2488: CALL_OW 380
// RandGuy := CreateHuman ;
2492: LD_ADDR_EXP 19
2496: PUSH
2497: CALL_OW 44
2501: ST_TO_ADDR
// veh := PrepareTank ( 4 , 1 , us_medium_wheeled , engine_combustion , control_manual , us_gatling_gun , 100 ) ;
2502: LD_ADDR_VAR 0 5
2506: PUSH
2507: LD_INT 4
2509: PPUSH
2510: LD_INT 1
2512: PPUSH
2513: LD_INT 2
2515: PPUSH
2516: LD_INT 1
2518: PPUSH
2519: LD_INT 1
2521: PPUSH
2522: LD_INT 4
2524: PPUSH
2525: LD_INT 100
2527: PPUSH
2528: CALL 4545 0 7
2532: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
2533: LD_VAR 0 5
2537: PPUSH
2538: LD_INT 2
2540: PPUSH
2541: CALL_OW 233
// PlaceUnitXY ( veh , 17 , 4 , false ) ;
2545: LD_VAR 0 5
2549: PPUSH
2550: LD_INT 17
2552: PPUSH
2553: LD_INT 4
2555: PPUSH
2556: LD_INT 0
2558: PPUSH
2559: CALL_OW 48
// PlaceHumanInUnit ( RandGuy , veh ) ;
2563: LD_EXP 19
2567: PPUSH
2568: LD_VAR 0 5
2572: PPUSH
2573: CALL_OW 52
// end ;
2577: LD_VAR 0 1
2581: RET
// function PrepareBase ; var blist , i , b , base ; begin
2582: LD_INT 0
2584: PPUSH
2585: PPUSH
2586: PPUSH
2587: PPUSH
2588: PPUSH
// SetResourceVisibility ( 71 , 5 , 1 ) ;
2589: LD_INT 71
2591: PPUSH
2592: LD_INT 5
2594: PPUSH
2595: LD_INT 1
2597: PPUSH
2598: CALL_OW 441
// blist := LoadVariable ( GammaBase , [ ] ) ;
2602: LD_ADDR_VAR 0 2
2606: PUSH
2607: LD_STRING GammaBase
2609: PPUSH
2610: EMPTY
2611: PPUSH
2612: CALL_OW 30
2616: ST_TO_ADDR
// if not blist then
2617: LD_VAR 0 2
2621: NOT
2622: IFFALSE 2662
// blist := [ [ b_depot , 52 , 12 , 3 , 3 , 0 , 0 ] ] ;
2624: LD_ADDR_VAR 0 2
2628: PUSH
2629: LD_INT 0
2631: PUSH
2632: LD_INT 52
2634: PUSH
2635: LD_INT 12
2637: PUSH
2638: LD_INT 3
2640: PUSH
2641: LD_INT 3
2643: PUSH
2644: LD_INT 0
2646: PUSH
2647: LD_INT 0
2649: PUSH
2650: EMPTY
2651: LIST
2652: LIST
2653: LIST
2654: LIST
2655: LIST
2656: LIST
2657: LIST
2658: PUSH
2659: EMPTY
2660: LIST
2661: ST_TO_ADDR
// uc_side := 1 ;
2662: LD_ADDR_OWVAR 20
2666: PUSH
2667: LD_INT 1
2669: ST_TO_ADDR
// uc_nation := 1 ;
2670: LD_ADDR_OWVAR 21
2674: PUSH
2675: LD_INT 1
2677: ST_TO_ADDR
// bc_kind1 := - 1 ;
2678: LD_ADDR_OWVAR 44
2682: PUSH
2683: LD_INT 1
2685: NEG
2686: ST_TO_ADDR
// bc_kind2 := - 1 ;
2687: LD_ADDR_OWVAR 45
2691: PUSH
2692: LD_INT 1
2694: NEG
2695: ST_TO_ADDR
// for i in blist do
2696: LD_ADDR_VAR 0 3
2700: PUSH
2701: LD_VAR 0 2
2705: PUSH
2706: FOR_IN
2707: IFFALSE 2858
// begin bc_type := i [ 1 ] ;
2709: LD_ADDR_OWVAR 42
2713: PUSH
2714: LD_VAR 0 3
2718: PUSH
2719: LD_INT 1
2721: ARRAY
2722: ST_TO_ADDR
// bc_level := i [ 5 ] ;
2723: LD_ADDR_OWVAR 43
2727: PUSH
2728: LD_VAR 0 3
2732: PUSH
2733: LD_INT 5
2735: ARRAY
2736: ST_TO_ADDR
// if i [ 1 ] in [ b_lab_half , b_lab_full ] then
2737: LD_VAR 0 3
2741: PUSH
2742: LD_INT 1
2744: ARRAY
2745: PUSH
2746: LD_INT 7
2748: PUSH
2749: LD_INT 8
2751: PUSH
2752: EMPTY
2753: LIST
2754: LIST
2755: IN
2756: IFFALSE 2786
// begin bc_kind1 := i [ 7 ] ;
2758: LD_ADDR_OWVAR 44
2762: PUSH
2763: LD_VAR 0 3
2767: PUSH
2768: LD_INT 7
2770: ARRAY
2771: ST_TO_ADDR
// bc_kind2 := i [ 8 ] ;
2772: LD_ADDR_OWVAR 45
2776: PUSH
2777: LD_VAR 0 3
2781: PUSH
2782: LD_INT 8
2784: ARRAY
2785: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
2786: LD_ADDR_VAR 0 4
2790: PUSH
2791: LD_VAR 0 3
2795: PUSH
2796: LD_INT 2
2798: ARRAY
2799: PPUSH
2800: LD_VAR 0 3
2804: PUSH
2805: LD_INT 3
2807: ARRAY
2808: PPUSH
2809: LD_VAR 0 3
2813: PUSH
2814: LD_INT 4
2816: ARRAY
2817: PPUSH
2818: CALL_OW 47
2822: ST_TO_ADDR
// if GetBType ( b ) = b_bunker then
2823: LD_VAR 0 4
2827: PPUSH
2828: CALL_OW 266
2832: PUSH
2833: LD_INT 32
2835: EQUAL
2836: IFFALSE 2856
// begin PlaceWeaponTurret ( b , i [ 7 ] ) ;
2838: LD_VAR 0 4
2842: PPUSH
2843: LD_VAR 0 3
2847: PUSH
2848: LD_INT 7
2850: ARRAY
2851: PPUSH
2852: CALL_OW 431
// end ; end ;
2856: GO 2706
2858: POP
2859: POP
// if not FilterAllUnits ( [ f_btype , b_depot ] ) then
2860: LD_INT 30
2862: PUSH
2863: LD_INT 0
2865: PUSH
2866: EMPTY
2867: LIST
2868: LIST
2869: PPUSH
2870: CALL_OW 69
2874: NOT
2875: IFFALSE 2912
// begin bc_type := b_depot ;
2877: LD_ADDR_OWVAR 42
2881: PUSH
2882: LD_INT 0
2884: ST_TO_ADDR
// bc_level := 6 ;
2885: LD_ADDR_OWVAR 43
2889: PUSH
2890: LD_INT 6
2892: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 52 , 12 , 3 ) ;
2893: LD_ADDR_VAR 0 4
2897: PUSH
2898: LD_INT 52
2900: PPUSH
2901: LD_INT 12
2903: PPUSH
2904: LD_INT 3
2906: PPUSH
2907: CALL_OW 47
2911: ST_TO_ADDR
// end ; base := GetBase ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) [ 1 ] ) ;
2912: LD_ADDR_VAR 0 5
2916: PUSH
2917: LD_INT 22
2919: PUSH
2920: LD_INT 1
2922: PUSH
2923: EMPTY
2924: LIST
2925: LIST
2926: PUSH
2927: LD_INT 2
2929: PUSH
2930: LD_INT 30
2932: PUSH
2933: LD_INT 0
2935: PUSH
2936: EMPTY
2937: LIST
2938: LIST
2939: PUSH
2940: LD_INT 30
2942: PUSH
2943: LD_INT 1
2945: PUSH
2946: EMPTY
2947: LIST
2948: LIST
2949: PUSH
2950: EMPTY
2951: LIST
2952: LIST
2953: LIST
2954: PUSH
2955: EMPTY
2956: LIST
2957: LIST
2958: PPUSH
2959: CALL_OW 69
2963: PUSH
2964: LD_INT 1
2966: ARRAY
2967: PPUSH
2968: CALL_OW 274
2972: ST_TO_ADDR
// if base then
2973: LD_VAR 0 5
2977: IFFALSE 2994
// SetResourceType ( base , mat_oil , 1000 ) ;
2979: LD_VAR 0 5
2983: PPUSH
2984: LD_INT 2
2986: PPUSH
2987: LD_INT 1000
2989: PPUSH
2990: CALL_OW 277
// end ; end_of_file
2994: LD_VAR 0 1
2998: RET
// export function Action ; var points , i , sol , time , team , filter ; begin
2999: LD_INT 0
3001: PPUSH
3002: PPUSH
3003: PPUSH
3004: PPUSH
3005: PPUSH
3006: PPUSH
3007: PPUSH
// InGameOn ;
3008: CALL_OW 8
// CenterNowOnXY ( 33 , 11 ) ;
3012: LD_INT 33
3014: PPUSH
3015: LD_INT 11
3017: PPUSH
3018: CALL_OW 86
// points := [ [ 29 , 21 ] , [ 41 , 28 ] , [ 52 , 26 ] , [ 49 , 16 ] ] ;
3022: LD_ADDR_VAR 0 2
3026: PUSH
3027: LD_INT 29
3029: PUSH
3030: LD_INT 21
3032: PUSH
3033: EMPTY
3034: LIST
3035: LIST
3036: PUSH
3037: LD_INT 41
3039: PUSH
3040: LD_INT 28
3042: PUSH
3043: EMPTY
3044: LIST
3045: LIST
3046: PUSH
3047: LD_INT 52
3049: PUSH
3050: LD_INT 26
3052: PUSH
3053: EMPTY
3054: LIST
3055: LIST
3056: PUSH
3057: LD_INT 49
3059: PUSH
3060: LD_INT 16
3062: PUSH
3063: EMPTY
3064: LIST
3065: LIST
3066: PUSH
3067: EMPTY
3068: LIST
3069: LIST
3070: LIST
3071: LIST
3072: ST_TO_ADDR
// sol := ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , 1 ] ] ) diff [ JMM , Brown , Cyrus , Bobby , Gladstone , Houten , Khatam ] ) [ 1 ] ;
3073: LD_ADDR_VAR 0 4
3077: PUSH
3078: LD_INT 22
3080: PUSH
3081: LD_INT 1
3083: PUSH
3084: EMPTY
3085: LIST
3086: LIST
3087: PUSH
3088: LD_INT 26
3090: PUSH
3091: LD_INT 1
3093: PUSH
3094: EMPTY
3095: LIST
3096: LIST
3097: PUSH
3098: EMPTY
3099: LIST
3100: LIST
3101: PPUSH
3102: CALL_OW 69
3106: PUSH
3107: LD_EXP 7
3111: PUSH
3112: LD_EXP 14
3116: PUSH
3117: LD_EXP 11
3121: PUSH
3122: LD_EXP 12
3126: PUSH
3127: LD_EXP 8
3131: PUSH
3132: LD_EXP 15
3136: PUSH
3137: LD_EXP 16
3141: PUSH
3142: EMPTY
3143: LIST
3144: LIST
3145: LIST
3146: LIST
3147: LIST
3148: LIST
3149: LIST
3150: DIFF
3151: PUSH
3152: LD_INT 1
3154: ARRAY
3155: ST_TO_ADDR
// if sol then
3156: LD_VAR 0 4
3160: IFFALSE 3191
// begin ComMoveXY ( sol , 50 , 18 ) ;
3162: LD_VAR 0 4
3166: PPUSH
3167: LD_INT 50
3169: PPUSH
3170: LD_INT 18
3172: PPUSH
3173: CALL_OW 111
// AddComTurnUnit ( sol , Harisson ) ;
3177: LD_VAR 0 4
3181: PPUSH
3182: LD_EXP 17
3186: PPUSH
3187: CALL_OW 179
// end ; for i in points do
3191: LD_ADDR_VAR 0 3
3195: PUSH
3196: LD_VAR 0 2
3200: PUSH
3201: FOR_IN
3202: IFFALSE 3242
// AddComMoveXY ( [ Harisson , RandGuy ] , i [ 1 ] , i [ 2 ] ) ;
3204: LD_EXP 17
3208: PUSH
3209: LD_EXP 19
3213: PUSH
3214: EMPTY
3215: LIST
3216: LIST
3217: PPUSH
3218: LD_VAR 0 3
3222: PUSH
3223: LD_INT 1
3225: ARRAY
3226: PPUSH
3227: LD_VAR 0 3
3231: PUSH
3232: LD_INT 2
3234: ARRAY
3235: PPUSH
3236: CALL_OW 171
3240: GO 3201
3242: POP
3243: POP
// AddComExitVehicle ( [ Harisson , RandGuy ] ) ;
3244: LD_EXP 17
3248: PUSH
3249: LD_EXP 19
3253: PUSH
3254: EMPTY
3255: LIST
3256: LIST
3257: PPUSH
3258: CALL_OW 181
// AddComTurnUnit ( [ Harisson , RandGuy ] , sol ) ;
3262: LD_EXP 17
3266: PUSH
3267: LD_EXP 19
3271: PUSH
3272: EMPTY
3273: LIST
3274: LIST
3275: PPUSH
3276: LD_VAR 0 4
3280: PPUSH
3281: CALL_OW 179
// time := 0 0$20 ;
3285: LD_ADDR_VAR 0 5
3289: PUSH
3290: LD_INT 700
3292: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
3293: LD_INT 10
3295: PPUSH
3296: CALL_OW 67
// time := time - 0 0$0.3 ;
3300: LD_ADDR_VAR 0 5
3304: PUSH
3305: LD_VAR 0 5
3309: PUSH
3310: LD_INT 10
3312: MINUS
3313: ST_TO_ADDR
// until not IsInUnit ( Harisson ) or time <= 0 0$00 ;
3314: LD_EXP 17
3318: PPUSH
3319: CALL_OW 310
3323: NOT
3324: PUSH
3325: LD_VAR 0 5
3329: PUSH
3330: LD_INT 0
3332: LESSEQUAL
3333: OR
3334: IFFALSE 3293
// Say ( sol , D1-Sol1-1 ) ;
3336: LD_VAR 0 4
3340: PPUSH
3341: LD_STRING D1-Sol1-1
3343: PPUSH
3344: CALL_OW 88
// Say ( Harisson , D1-Har-1 ) ;
3348: LD_EXP 17
3352: PPUSH
3353: LD_STRING D1-Har-1
3355: PPUSH
3356: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
3360: LD_INT 10
3362: PPUSH
3363: CALL_OW 67
// ComMoveXY ( sol , 35 , 21 ) ;
3367: LD_VAR 0 4
3371: PPUSH
3372: LD_INT 35
3374: PPUSH
3375: LD_INT 21
3377: PPUSH
3378: CALL_OW 111
// ComExitBuilding ( JMM ) ;
3382: LD_EXP 7
3386: PPUSH
3387: CALL_OW 122
// AddComMoveUnit ( JMM , Harisson ) ;
3391: LD_EXP 7
3395: PPUSH
3396: LD_EXP 17
3400: PPUSH
3401: CALL_OW 172
// ComTurnUnit ( [ Harisson , RandGuy ] , JMM ) ;
3405: LD_EXP 17
3409: PUSH
3410: LD_EXP 19
3414: PUSH
3415: EMPTY
3416: LIST
3417: LIST
3418: PPUSH
3419: LD_EXP 7
3423: PPUSH
3424: CALL_OW 119
// time := 0 0$3 ;
3428: LD_ADDR_VAR 0 5
3432: PUSH
3433: LD_INT 105
3435: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3436: LD_INT 35
3438: PPUSH
3439: CALL_OW 67
// time := time - 0 0$1 ;
3443: LD_ADDR_VAR 0 5
3447: PUSH
3448: LD_VAR 0 5
3452: PUSH
3453: LD_INT 35
3455: MINUS
3456: ST_TO_ADDR
// until GetDistUnits ( JMM , Harisson ) < 4 or time = 0 0$00 ;
3457: LD_EXP 7
3461: PPUSH
3462: LD_EXP 17
3466: PPUSH
3467: CALL_OW 296
3471: PUSH
3472: LD_INT 4
3474: LESS
3475: PUSH
3476: LD_VAR 0 5
3480: PUSH
3481: LD_INT 0
3483: EQUAL
3484: OR
3485: IFFALSE 3436
// ComTurnUnit ( JMM , Harisson ) ;
3487: LD_EXP 7
3491: PPUSH
3492: LD_EXP 17
3496: PPUSH
3497: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
3501: LD_EXP 7
3505: PPUSH
3506: LD_STRING D1-JMM-1
3508: PPUSH
3509: CALL_OW 88
// Say ( Harisson , D1-Har-2 ) ;
3513: LD_EXP 17
3517: PPUSH
3518: LD_STRING D1-Har-2
3520: PPUSH
3521: CALL_OW 88
// Say ( JMM , D1-JMM-2 ) ;
3525: LD_EXP 7
3529: PPUSH
3530: LD_STRING D1-JMM-2
3532: PPUSH
3533: CALL_OW 88
// Say ( Harisson , D1-Har-3 ) ;
3537: LD_EXP 17
3541: PPUSH
3542: LD_STRING D1-Har-3
3544: PPUSH
3545: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
3549: LD_EXP 7
3553: PPUSH
3554: LD_STRING D1-JMM-3
3556: PPUSH
3557: CALL_OW 88
// Say ( Harisson , D1-Har-4 ) ;
3561: LD_EXP 17
3565: PPUSH
3566: LD_STRING D1-Har-4
3568: PPUSH
3569: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
3573: LD_EXP 7
3577: PPUSH
3578: LD_STRING D1-JMM-4
3580: PPUSH
3581: CALL_OW 88
// Say ( Harisson , D1-Har-5 ) ;
3585: LD_EXP 17
3589: PPUSH
3590: LD_STRING D1-Har-5
3592: PPUSH
3593: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
3597: LD_EXP 7
3601: PPUSH
3602: LD_STRING D1-JMM-5
3604: PPUSH
3605: CALL_OW 88
// Say ( Harisson , D1-Har-6 ) ;
3609: LD_EXP 17
3613: PPUSH
3614: LD_STRING D1-Har-6
3616: PPUSH
3617: CALL_OW 88
// Say ( JMM , D1-JMM-6 ) ;
3621: LD_EXP 7
3625: PPUSH
3626: LD_STRING D1-JMM-6
3628: PPUSH
3629: CALL_OW 88
// EndMission ;
3633: CALL 3642 0 0
// end ;
3637: LD_VAR 0 1
3641: RET
// export function EndMission ; var commander , i , all ; begin
3642: LD_INT 0
3644: PPUSH
3645: PPUSH
3646: PPUSH
3647: PPUSH
// case gamma_commander of 1 :
3648: LD_EXP 18
3652: PUSH
3653: LD_INT 1
3655: DOUBLE
3656: EQUAL
3657: IFTRUE 3661
3659: GO 3674
3661: POP
// commander := Donaldson ; 2 :
3662: LD_ADDR_VAR 0 2
3666: PUSH
3667: LD_EXP 13
3671: ST_TO_ADDR
3672: GO 3717
3674: LD_INT 2
3676: DOUBLE
3677: EQUAL
3678: IFTRUE 3682
3680: GO 3695
3682: POP
// commander := Brown ; 3 :
3683: LD_ADDR_VAR 0 2
3687: PUSH
3688: LD_EXP 14
3692: ST_TO_ADDR
3693: GO 3717
3695: LD_INT 3
3697: DOUBLE
3698: EQUAL
3699: IFTRUE 3703
3701: GO 3716
3703: POP
// commander := Houten ; end ;
3704: LD_ADDR_VAR 0 2
3708: PUSH
3709: LD_EXP 15
3713: ST_TO_ADDR
3714: GO 3717
3716: POP
// all := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) diff [ JMM , commander ] ;
3717: LD_ADDR_VAR 0 4
3721: PUSH
3722: LD_INT 22
3724: PUSH
3725: LD_INT 1
3727: PUSH
3728: EMPTY
3729: LIST
3730: LIST
3731: PUSH
3732: LD_INT 21
3734: PUSH
3735: LD_INT 1
3737: PUSH
3738: EMPTY
3739: LIST
3740: LIST
3741: PUSH
3742: EMPTY
3743: LIST
3744: LIST
3745: PPUSH
3746: CALL_OW 69
3750: PUSH
3751: LD_EXP 7
3755: PUSH
3756: LD_VAR 0 2
3760: PUSH
3761: EMPTY
3762: LIST
3763: LIST
3764: DIFF
3765: ST_TO_ADDR
// if UnitFilter ( all , [ f_class , 2 ] ) then
3766: LD_VAR 0 4
3770: PPUSH
3771: LD_INT 25
3773: PUSH
3774: LD_INT 2
3776: PUSH
3777: EMPTY
3778: LIST
3779: LIST
3780: PPUSH
3781: CALL_OW 72
3785: IFFALSE 3831
// for i in UnitFilter ( all , [ f_class , 2 ] ) do
3787: LD_ADDR_VAR 0 3
3791: PUSH
3792: LD_VAR 0 4
3796: PPUSH
3797: LD_INT 25
3799: PUSH
3800: LD_INT 2
3802: PUSH
3803: EMPTY
3804: LIST
3805: LIST
3806: PPUSH
3807: CALL_OW 72
3811: PUSH
3812: FOR_IN
3813: IFFALSE 3829
// SetClass ( i , 2 ) ;
3815: LD_VAR 0 3
3819: PPUSH
3820: LD_INT 2
3822: PPUSH
3823: CALL_OW 336
3827: GO 3812
3829: POP
3830: POP
// save_group := CharacterSelection ( 1 , 10 , 10 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ all ^ [ sel_dont_change_class , sel_not_changeable ] ^ [ commander , Harisson ] , [ [ class_soldier , 3 ] , [ class_mechanic , 3 , 6 ] , [ class_scientistic , 1 ] ] ) ;
3831: LD_ADDR_EXP 4
3835: PUSH
3836: LD_STRING 1
3838: PPUSH
3839: LD_INT 10
3841: PPUSH
3842: LD_INT 10
3844: PPUSH
3845: LD_INT -5
3847: PUSH
3848: LD_EXP 7
3852: PUSH
3853: LD_INT -2
3855: PUSH
3856: LD_INT -3
3858: PUSH
3859: LD_INT -5
3861: PUSH
3862: EMPTY
3863: LIST
3864: LIST
3865: LIST
3866: LIST
3867: LIST
3868: PUSH
3869: LD_VAR 0 4
3873: ADD
3874: PUSH
3875: LD_INT -6
3877: PUSH
3878: LD_INT -4
3880: PUSH
3881: EMPTY
3882: LIST
3883: LIST
3884: ADD
3885: PUSH
3886: LD_VAR 0 2
3890: PUSH
3891: LD_EXP 17
3895: PUSH
3896: EMPTY
3897: LIST
3898: LIST
3899: ADD
3900: PPUSH
3901: LD_INT 1
3903: PUSH
3904: LD_INT 3
3906: PUSH
3907: EMPTY
3908: LIST
3909: LIST
3910: PUSH
3911: LD_INT 3
3913: PUSH
3914: LD_INT 3
3916: PUSH
3917: LD_INT 6
3919: PUSH
3920: EMPTY
3921: LIST
3922: LIST
3923: LIST
3924: PUSH
3925: LD_INT 4
3927: PUSH
3928: LD_INT 1
3930: PUSH
3931: EMPTY
3932: LIST
3933: LIST
3934: PUSH
3935: EMPTY
3936: LIST
3937: LIST
3938: LIST
3939: PPUSH
3940: CALL_OW 42
3944: ST_TO_ADDR
// SaveCharacters ( all diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , Houten , Harisson , Khatam ] ^ save_group , 07_othersGamma ) ;
3945: LD_VAR 0 4
3949: PUSH
3950: LD_EXP 7
3954: PUSH
3955: LD_EXP 8
3959: PUSH
3960: LD_EXP 10
3964: PUSH
3965: LD_EXP 11
3969: PUSH
3970: LD_EXP 12
3974: PUSH
3975: LD_EXP 9
3979: PUSH
3980: LD_EXP 13
3984: PUSH
3985: LD_EXP 14
3989: PUSH
3990: LD_EXP 15
3994: PUSH
3995: LD_EXP 17
3999: PUSH
4000: LD_EXP 16
4004: PUSH
4005: EMPTY
4006: LIST
4007: LIST
4008: LIST
4009: LIST
4010: LIST
4011: LIST
4012: LIST
4013: LIST
4014: LIST
4015: LIST
4016: LIST
4017: PUSH
4018: LD_EXP 4
4022: ADD
4023: DIFF
4024: PPUSH
4025: LD_STRING 07_othersGamma
4027: PPUSH
4028: CALL_OW 38
// SaveCharacters ( save_group diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , Houten , Harisson , Khatam , 0 ] , 07_others ) ;
4032: LD_EXP 4
4036: PUSH
4037: LD_EXP 7
4041: PUSH
4042: LD_EXP 8
4046: PUSH
4047: LD_EXP 10
4051: PUSH
4052: LD_EXP 11
4056: PUSH
4057: LD_EXP 12
4061: PUSH
4062: LD_EXP 9
4066: PUSH
4067: LD_EXP 13
4071: PUSH
4072: LD_EXP 14
4076: PUSH
4077: LD_EXP 15
4081: PUSH
4082: LD_EXP 17
4086: PUSH
4087: LD_EXP 16
4091: PUSH
4092: LD_INT 0
4094: PUSH
4095: EMPTY
4096: LIST
4097: LIST
4098: LIST
4099: LIST
4100: LIST
4101: LIST
4102: LIST
4103: LIST
4104: LIST
4105: LIST
4106: LIST
4107: LIST
4108: DIFF
4109: PPUSH
4110: LD_STRING 07_others
4112: PPUSH
4113: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
4117: LD_EXP 7
4121: PPUSH
4122: LD_EXP 5
4126: PUSH
4127: LD_STRING JMM
4129: STR
4130: PPUSH
4131: CALL_OW 38
// if Lisa then
4135: LD_EXP 10
4139: IFFALSE 4181
// begin SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
4141: LD_EXP 10
4145: PPUSH
4146: LD_EXP 5
4150: PUSH
4151: LD_STRING Lisa
4153: STR
4154: PPUSH
4155: CALL_OW 38
// if Lisa in save_group then
4159: LD_EXP 10
4163: PUSH
4164: LD_EXP 4
4168: IN
4169: IFFALSE 4181
// SaveVariable ( true , LisaIn07 ) ;
4171: LD_INT 1
4173: PPUSH
4174: LD_STRING LisaIn07
4176: PPUSH
4177: CALL_OW 39
// end ; if Bobby then
4181: LD_EXP 12
4185: IFFALSE 4227
// begin SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
4187: LD_EXP 12
4191: PPUSH
4192: LD_EXP 5
4196: PUSH
4197: LD_STRING Bobby
4199: STR
4200: PPUSH
4201: CALL_OW 38
// if Bobby in save_group then
4205: LD_EXP 12
4209: PUSH
4210: LD_EXP 4
4214: IN
4215: IFFALSE 4227
// SaveVariable ( true , BobbyIn07 ) ;
4217: LD_INT 1
4219: PPUSH
4220: LD_STRING BobbyIn07
4222: PPUSH
4223: CALL_OW 39
// end ; if Cyrus then
4227: LD_EXP 11
4231: IFFALSE 4273
// begin SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
4233: LD_EXP 11
4237: PPUSH
4238: LD_EXP 5
4242: PUSH
4243: LD_STRING Cyrus
4245: STR
4246: PPUSH
4247: CALL_OW 38
// if Cyrus in save_group then
4251: LD_EXP 11
4255: PUSH
4256: LD_EXP 4
4260: IN
4261: IFFALSE 4273
// SaveVariable ( true , CyrusIn07 ) ;
4263: LD_INT 1
4265: PPUSH
4266: LD_STRING CyrusIn07
4268: PPUSH
4269: CALL_OW 39
// end ; if Brown then
4273: LD_EXP 14
4277: IFFALSE 4319
// begin SaveCharacters ( Brown , mission_prefix & Brown ) ;
4279: LD_EXP 14
4283: PPUSH
4284: LD_EXP 5
4288: PUSH
4289: LD_STRING Brown
4291: STR
4292: PPUSH
4293: CALL_OW 38
// if Brown in save_group then
4297: LD_EXP 14
4301: PUSH
4302: LD_EXP 4
4306: IN
4307: IFFALSE 4319
// SaveVariable ( true , BrownIn07 ) ;
4309: LD_INT 1
4311: PPUSH
4312: LD_STRING BrownIn07
4314: PPUSH
4315: CALL_OW 39
// end ; if Donaldson then
4319: LD_EXP 13
4323: IFFALSE 4365
// begin SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
4325: LD_EXP 13
4329: PPUSH
4330: LD_EXP 5
4334: PUSH
4335: LD_STRING Donaldson
4337: STR
4338: PPUSH
4339: CALL_OW 38
// if Donaldson in save_group then
4343: LD_EXP 13
4347: PUSH
4348: LD_EXP 4
4352: IN
4353: IFFALSE 4365
// SaveVariable ( true , DonaldsonIn07 ) ;
4355: LD_INT 1
4357: PPUSH
4358: LD_STRING DonaldsonIn07
4360: PPUSH
4361: CALL_OW 39
// end ; if Gladstone then
4365: LD_EXP 8
4369: IFFALSE 4411
// begin SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
4371: LD_EXP 8
4375: PPUSH
4376: LD_EXP 5
4380: PUSH
4381: LD_STRING Gladstone
4383: STR
4384: PPUSH
4385: CALL_OW 38
// if Gladstone in save_group then
4389: LD_EXP 8
4393: PUSH
4394: LD_EXP 4
4398: IN
4399: IFFALSE 4411
// SaveVariable ( true , GladstoneIn07 ) ;
4401: LD_INT 1
4403: PPUSH
4404: LD_STRING GladstoneIn07
4406: PPUSH
4407: CALL_OW 39
// end ; if Khatam then
4411: LD_EXP 16
4415: IFFALSE 4457
// begin SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
4417: LD_EXP 16
4421: PPUSH
4422: LD_EXP 5
4426: PUSH
4427: LD_STRING Khatam
4429: STR
4430: PPUSH
4431: CALL_OW 38
// if Khatam in save_group then
4435: LD_EXP 16
4439: PUSH
4440: LD_EXP 4
4444: IN
4445: IFFALSE 4457
// SaveVariable ( true , KhatamIn07 ) ;
4447: LD_INT 1
4449: PPUSH
4450: LD_STRING KhatamIn07
4452: PPUSH
4453: CALL_OW 39
// end ; if debug then
4457: LD_EXP 1
4461: IFFALSE 4467
// InGameOff ;
4463: CALL_OW 9
// ChangeMap ( 1 , %_cont ) ;
4467: LD_INT 1
4469: PPUSH
4470: LD_STRING %_cont
4472: PPUSH
4473: CALL_OW 340
// end ; end_of_file
4477: LD_VAR 0 1
4481: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
4482: LD_INT 0
4484: PPUSH
4485: PPUSH
// if exist_mode then
4486: LD_VAR 0 2
4490: IFFALSE 4515
// unit := CreateCharacter ( prefix & ident ) else
4492: LD_ADDR_VAR 0 5
4496: PUSH
4497: LD_VAR 0 3
4501: PUSH
4502: LD_VAR 0 1
4506: STR
4507: PPUSH
4508: CALL_OW 34
4512: ST_TO_ADDR
4513: GO 4530
// unit := NewCharacter ( ident ) ;
4515: LD_ADDR_VAR 0 5
4519: PUSH
4520: LD_VAR 0 1
4524: PPUSH
4525: CALL_OW 25
4529: ST_TO_ADDR
// result := unit ;
4530: LD_ADDR_VAR 0 4
4534: PUSH
4535: LD_VAR 0 5
4539: ST_TO_ADDR
// end ;
4540: LD_VAR 0 4
4544: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
4545: LD_INT 0
4547: PPUSH
// uc_side := side ;
4548: LD_ADDR_OWVAR 20
4552: PUSH
4553: LD_VAR 0 1
4557: ST_TO_ADDR
// uc_nation := nation ;
4558: LD_ADDR_OWVAR 21
4562: PUSH
4563: LD_VAR 0 2
4567: ST_TO_ADDR
// vc_chassis := chassis ;
4568: LD_ADDR_OWVAR 37
4572: PUSH
4573: LD_VAR 0 3
4577: ST_TO_ADDR
// vc_engine := engine ;
4578: LD_ADDR_OWVAR 39
4582: PUSH
4583: LD_VAR 0 4
4587: ST_TO_ADDR
// vc_control := control ;
4588: LD_ADDR_OWVAR 38
4592: PUSH
4593: LD_VAR 0 5
4597: ST_TO_ADDR
// vc_weapon := weapon ;
4598: LD_ADDR_OWVAR 40
4602: PUSH
4603: LD_VAR 0 6
4607: ST_TO_ADDR
// vc_fuel_battery := fuel ;
4608: LD_ADDR_OWVAR 41
4612: PUSH
4613: LD_VAR 0 7
4617: ST_TO_ADDR
// result := CreateVehicle ;
4618: LD_ADDR_VAR 0 8
4622: PUSH
4623: CALL_OW 45
4627: ST_TO_ADDR
// end ;
4628: LD_VAR 0 8
4632: RET
// export function SayX ( units , ident ) ; var i ; begin
4633: LD_INT 0
4635: PPUSH
4636: PPUSH
// result := false ;
4637: LD_ADDR_VAR 0 3
4641: PUSH
4642: LD_INT 0
4644: ST_TO_ADDR
// if not units then
4645: LD_VAR 0 1
4649: NOT
4650: IFFALSE 4654
// exit ;
4652: GO 4708
// for i in units do
4654: LD_ADDR_VAR 0 4
4658: PUSH
4659: LD_VAR 0 1
4663: PUSH
4664: FOR_IN
4665: IFFALSE 4706
// if IsOk ( i ) then
4667: LD_VAR 0 4
4671: PPUSH
4672: CALL_OW 302
4676: IFFALSE 4704
// begin Say ( i , ident ) ;
4678: LD_VAR 0 4
4682: PPUSH
4683: LD_VAR 0 2
4687: PPUSH
4688: CALL_OW 88
// result := i ;
4692: LD_ADDR_VAR 0 3
4696: PUSH
4697: LD_VAR 0 4
4701: ST_TO_ADDR
// break ;
4702: GO 4706
// end ;
4704: GO 4664
4706: POP
4707: POP
// end ;
4708: LD_VAR 0 3
4712: RET
