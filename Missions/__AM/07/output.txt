// starting begin ResetFog ;
   0: CALL_OW 335
// FogOff ( 1 ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 344
// RandomizeAll ;
  11: CALL_OW 11
// Init ;
  15: CALL 28 0 0
// PrepareAmerican ;
  19: CALL 94 0 0
// Action ;
  23: CALL 3010 0 0
// end ;
  27: END
// export debug ; export donaldson_commander , brown_commander , save_group ; export mission_prefix , mission_prefix_prev ; function Init ; begin
  28: LD_INT 0
  30: PPUSH
// debug := false ;
  31: LD_ADDR_EXP 1
  35: PUSH
  36: LD_INT 0
  38: ST_TO_ADDR
// mission_prefix := 07_ ;
  39: LD_ADDR_EXP 5
  43: PUSH
  44: LD_STRING 07_
  46: ST_TO_ADDR
// mission_prefix_prev := [ 06_ , 05_ , 04_ ] ;
  47: LD_ADDR_EXP 6
  51: PUSH
  52: LD_STRING 06_
  54: PUSH
  55: LD_STRING 05_
  57: PUSH
  58: LD_STRING 04_
  60: PUSH
  61: EMPTY
  62: LIST
  63: LIST
  64: LIST
  65: ST_TO_ADDR
// donaldson_commander := false ;
  66: LD_ADDR_EXP 2
  70: PUSH
  71: LD_INT 0
  73: ST_TO_ADDR
// brown_commander := false ;
  74: LD_ADDR_EXP 3
  78: PUSH
  79: LD_INT 0
  81: ST_TO_ADDR
// save_group := [ ] ;
  82: LD_ADDR_EXP 4
  86: PUSH
  87: EMPTY
  88: ST_TO_ADDR
// end ; end_of_file
  89: LD_VAR 0 1
  93: RET
// export JMM , Gladstone , Frank , Lisa , Cyrus , Bobby , Donaldson , Brown , Houten , Khatam , Harisson ; export gamma_commander ; export RandGuy ; export function PrepareAmerican ; var others , others_delta , others4 , veh , team , dep , bar , lab , fac , bun , filter , i , j ; begin
  94: LD_INT 0
  96: PPUSH
  97: PPUSH
  98: PPUSH
  99: PPUSH
 100: PPUSH
 101: PPUSH
 102: PPUSH
 103: PPUSH
 104: PPUSH
 105: PPUSH
 106: PPUSH
 107: PPUSH
 108: PPUSH
 109: PPUSH
// PrepareBase ;
 110: CALL 2569 0 0
// uc_side := 1 ;
 114: LD_ADDR_OWVAR 20
 118: PUSH
 119: LD_INT 1
 121: ST_TO_ADDR
// uc_nation := 1 ;
 122: LD_ADDR_OWVAR 21
 126: PUSH
 127: LD_INT 1
 129: ST_TO_ADDR
// team := [ ] ;
 130: LD_ADDR_VAR 0 6
 134: PUSH
 135: EMPTY
 136: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 06c_ ) ;
 137: LD_ADDR_EXP 7
 141: PUSH
 142: LD_STRING JMM
 144: PPUSH
 145: LD_EXP 1
 149: NOT
 150: PPUSH
 151: LD_STRING 06c_
 153: PPUSH
 154: CALL 4508 0 3
 158: ST_TO_ADDR
// if GetClass ( JMM ) = 2 then
 159: LD_EXP 7
 163: PPUSH
 164: CALL_OW 257
 168: PUSH
 169: LD_INT 2
 171: EQUAL
 172: IFFALSE 186
// SetClass ( JMM , 1 ) ;
 174: LD_EXP 7
 178: PPUSH
 179: LD_INT 1
 181: PPUSH
 182: CALL_OW 336
// gamma_commander := LoadVariable ( GammaCommander , 3 ) ;
 186: LD_ADDR_EXP 18
 190: PUSH
 191: LD_STRING GammaCommander
 193: PPUSH
 194: LD_INT 3
 196: PPUSH
 197: CALL_OW 30
 201: ST_TO_ADDR
// if gamma_commander = 1 then
 202: LD_EXP 18
 206: PUSH
 207: LD_INT 1
 209: EQUAL
 210: IFFALSE 236
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 04_ ) ;
 212: LD_ADDR_EXP 13
 216: PUSH
 217: LD_STRING Donaldson
 219: PPUSH
 220: LD_EXP 1
 224: NOT
 225: PPUSH
 226: LD_STRING 04_
 228: PPUSH
 229: CALL 4508 0 3
 233: ST_TO_ADDR
// end else
 234: GO 307
// begin if LoadVariable ( DonaldsonIn06 , 0 ) then
 236: LD_STRING DonaldsonIn06
 238: PPUSH
 239: LD_INT 0
 241: PPUSH
 242: CALL_OW 30
 246: IFFALSE 272
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 06c_ ) else
 248: LD_ADDR_EXP 13
 252: PUSH
 253: LD_STRING Donaldson
 255: PPUSH
 256: LD_EXP 1
 260: NOT
 261: PPUSH
 262: LD_STRING 06c_
 264: PPUSH
 265: CALL 4508 0 3
 269: ST_TO_ADDR
 270: GO 307
// if not LoadVariable ( DonaldsonStayInDelta , 0 ) then
 272: LD_STRING DonaldsonStayInDelta
 274: PPUSH
 275: LD_INT 0
 277: PPUSH
 278: CALL_OW 30
 282: NOT
 283: IFFALSE 307
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 04_ ) ;
 285: LD_ADDR_EXP 13
 289: PUSH
 290: LD_STRING Donaldson
 292: PPUSH
 293: LD_EXP 1
 297: NOT
 298: PPUSH
 299: LD_STRING 04_
 301: PPUSH
 302: CALL 4508 0 3
 306: ST_TO_ADDR
// end ; if Donaldson then
 307: LD_EXP 13
 311: IFFALSE 329
// team := team ^ Donaldson ;
 313: LD_ADDR_VAR 0 6
 317: PUSH
 318: LD_VAR 0 6
 322: PUSH
 323: LD_EXP 13
 327: ADD
 328: ST_TO_ADDR
// if gamma_commander = 2 then
 329: LD_EXP 18
 333: PUSH
 334: LD_INT 2
 336: EQUAL
 337: IFFALSE 363
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 04_ ) ;
 339: LD_ADDR_EXP 14
 343: PUSH
 344: LD_STRING Brown
 346: PPUSH
 347: LD_EXP 1
 351: NOT
 352: PPUSH
 353: LD_STRING 04_
 355: PPUSH
 356: CALL 4508 0 3
 360: ST_TO_ADDR
// end else
 361: GO 434
// begin if LoadVariable ( BrownIn06 , 0 ) then
 363: LD_STRING BrownIn06
 365: PPUSH
 366: LD_INT 0
 368: PPUSH
 369: CALL_OW 30
 373: IFFALSE 399
// Brown := PrepareUnit ( Brown , ( not debug ) , 06c_ ) else
 375: LD_ADDR_EXP 14
 379: PUSH
 380: LD_STRING Brown
 382: PPUSH
 383: LD_EXP 1
 387: NOT
 388: PPUSH
 389: LD_STRING 06c_
 391: PPUSH
 392: CALL 4508 0 3
 396: ST_TO_ADDR
 397: GO 434
// if not LoadVariable ( BrownStayInDelta , 0 ) then
 399: LD_STRING BrownStayInDelta
 401: PPUSH
 402: LD_INT 0
 404: PPUSH
 405: CALL_OW 30
 409: NOT
 410: IFFALSE 434
// Brown := PrepareUnit ( Brown , ( not debug ) , 04_ ) ;
 412: LD_ADDR_EXP 14
 416: PUSH
 417: LD_STRING Brown
 419: PPUSH
 420: LD_EXP 1
 424: NOT
 425: PPUSH
 426: LD_STRING 04_
 428: PPUSH
 429: CALL 4508 0 3
 433: ST_TO_ADDR
// end ; if Brown then
 434: LD_EXP 14
 438: IFFALSE 456
// team := team ^ Brown ;
 440: LD_ADDR_VAR 0 6
 444: PUSH
 445: LD_VAR 0 6
 449: PUSH
 450: LD_EXP 14
 454: ADD
 455: ST_TO_ADDR
// if gamma_commander = 3 then
 456: LD_EXP 18
 460: PUSH
 461: LD_INT 3
 463: EQUAL
 464: IFFALSE 501
// begin Houten := PrepareUnit ( VanHouten , false ,  ) ;
 466: LD_ADDR_EXP 15
 470: PUSH
 471: LD_STRING VanHouten
 473: PPUSH
 474: LD_INT 0
 476: PPUSH
 477: LD_STRING 
 479: PPUSH
 480: CALL 4508 0 3
 484: ST_TO_ADDR
// team := team ^ Houten ;
 485: LD_ADDR_VAR 0 6
 489: PUSH
 490: LD_VAR 0 6
 494: PUSH
 495: LD_EXP 15
 499: ADD
 500: ST_TO_ADDR
// end ; if LoadVariable ( GladstoneIn06 , 0 ) then
 501: LD_STRING GladstoneIn06
 503: PPUSH
 504: LD_INT 0
 506: PPUSH
 507: CALL_OW 30
 511: IFFALSE 537
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 06c_ ) else
 513: LD_ADDR_EXP 8
 517: PUSH
 518: LD_STRING Gladstone
 520: PPUSH
 521: LD_EXP 1
 525: NOT
 526: PPUSH
 527: LD_STRING 06c_
 529: PPUSH
 530: CALL 4508 0 3
 534: ST_TO_ADDR
 535: GO 571
// if LoadVariable ( GladstoneStayInDelta , 0 ) then
 537: LD_STRING GladstoneStayInDelta
 539: PPUSH
 540: LD_INT 0
 542: PPUSH
 543: CALL_OW 30
 547: IFFALSE 571
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 06_ ) ;
 549: LD_ADDR_EXP 8
 553: PUSH
 554: LD_STRING Gladstone
 556: PPUSH
 557: LD_EXP 1
 561: NOT
 562: PPUSH
 563: LD_STRING 06_
 565: PPUSH
 566: CALL 4508 0 3
 570: ST_TO_ADDR
// if Gladstone then
 571: LD_EXP 8
 575: IFFALSE 593
// team := team ^ Gladstone ;
 577: LD_ADDR_VAR 0 6
 581: PUSH
 582: LD_VAR 0 6
 586: PUSH
 587: LD_EXP 8
 591: ADD
 592: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) , 03_ ) ;
 593: LD_ADDR_EXP 16
 597: PUSH
 598: LD_STRING Khatam
 600: PPUSH
 601: LD_EXP 1
 605: NOT
 606: PPUSH
 607: LD_STRING 03_
 609: PPUSH
 610: CALL 4508 0 3
 614: ST_TO_ADDR
// if Khatam then
 615: LD_EXP 16
 619: IFFALSE 637
// team := team ^ Khatam ;
 621: LD_ADDR_VAR 0 6
 625: PUSH
 626: LD_VAR 0 6
 630: PUSH
 631: LD_EXP 16
 635: ADD
 636: ST_TO_ADDR
// if LoadVariable ( LisaIn06 , 0 ) then
 637: LD_STRING LisaIn06
 639: PPUSH
 640: LD_INT 0
 642: PPUSH
 643: CALL_OW 30
 647: IFFALSE 673
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 06c_ ) else
 649: LD_ADDR_EXP 10
 653: PUSH
 654: LD_STRING Lisa
 656: PPUSH
 657: LD_EXP 1
 661: NOT
 662: PPUSH
 663: LD_STRING 06c_
 665: PPUSH
 666: CALL 4508 0 3
 670: ST_TO_ADDR
 671: GO 708
// if not LoadVariable ( LisaStayInDelta , 0 ) then
 673: LD_STRING LisaStayInDelta
 675: PPUSH
 676: LD_INT 0
 678: PPUSH
 679: CALL_OW 30
 683: NOT
 684: IFFALSE 708
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 04_ ) ;
 686: LD_ADDR_EXP 10
 690: PUSH
 691: LD_STRING Lisa
 693: PPUSH
 694: LD_EXP 1
 698: NOT
 699: PPUSH
 700: LD_STRING 04_
 702: PPUSH
 703: CALL 4508 0 3
 707: ST_TO_ADDR
// if Lisa then
 708: LD_EXP 10
 712: IFFALSE 730
// team := team ^ Lisa ;
 714: LD_ADDR_VAR 0 6
 718: PUSH
 719: LD_VAR 0 6
 723: PUSH
 724: LD_EXP 10
 728: ADD
 729: ST_TO_ADDR
// if not Lisa then
 730: LD_EXP 10
 734: NOT
 735: IFFALSE 988
// begin if LoadVariable ( CyrusIn06 , 0 ) then
 737: LD_STRING CyrusIn06
 739: PPUSH
 740: LD_INT 0
 742: PPUSH
 743: CALL_OW 30
 747: IFFALSE 773
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 06c_ ) else
 749: LD_ADDR_EXP 11
 753: PUSH
 754: LD_STRING Cyrus
 756: PPUSH
 757: LD_EXP 1
 761: NOT
 762: PPUSH
 763: LD_STRING 06c_
 765: PPUSH
 766: CALL 4508 0 3
 770: ST_TO_ADDR
 771: GO 837
// if not LoadVariable ( CyrusStayInDelta , 0 ) then
 773: LD_STRING CyrusStayInDelta
 775: PPUSH
 776: LD_INT 0
 778: PPUSH
 779: CALL_OW 30
 783: NOT
 784: IFFALSE 837
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 04_ ) ;
 786: LD_ADDR_EXP 11
 790: PUSH
 791: LD_STRING Cyrus
 793: PPUSH
 794: LD_EXP 1
 798: NOT
 799: PPUSH
 800: LD_STRING 04_
 802: PPUSH
 803: CALL 4508 0 3
 807: ST_TO_ADDR
// if not Cyrus then
 808: LD_EXP 11
 812: NOT
 813: IFFALSE 837
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 03_ ) ;
 815: LD_ADDR_EXP 11
 819: PUSH
 820: LD_STRING Cyrus
 822: PPUSH
 823: LD_EXP 1
 827: NOT
 828: PPUSH
 829: LD_STRING 03_
 831: PPUSH
 832: CALL 4508 0 3
 836: ST_TO_ADDR
// end ; if Cyrus then
 837: LD_EXP 11
 841: IFFALSE 859
// team := team ^ Cyrus ;
 843: LD_ADDR_VAR 0 6
 847: PUSH
 848: LD_VAR 0 6
 852: PUSH
 853: LD_EXP 11
 857: ADD
 858: ST_TO_ADDR
// if not Cyrus then
 859: LD_EXP 11
 863: NOT
 864: IFFALSE 988
// begin if LoadVariable ( BobbyIn06 , 0 ) then
 866: LD_STRING BobbyIn06
 868: PPUSH
 869: LD_INT 0
 871: PPUSH
 872: CALL_OW 30
 876: IFFALSE 902
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 06c_ ) else
 878: LD_ADDR_EXP 12
 882: PUSH
 883: LD_STRING Bobby
 885: PPUSH
 886: LD_EXP 1
 890: NOT
 891: PPUSH
 892: LD_STRING 06c_
 894: PPUSH
 895: CALL 4508 0 3
 899: ST_TO_ADDR
 900: GO 966
// if not LoadVariable ( BobbyStayInDelta , 0 ) then
 902: LD_STRING BobbyStayInDelta
 904: PPUSH
 905: LD_INT 0
 907: PPUSH
 908: CALL_OW 30
 912: NOT
 913: IFFALSE 966
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 04_ ) ;
 915: LD_ADDR_EXP 12
 919: PUSH
 920: LD_STRING Bobby
 922: PPUSH
 923: LD_EXP 1
 927: NOT
 928: PPUSH
 929: LD_STRING 04_
 931: PPUSH
 932: CALL 4508 0 3
 936: ST_TO_ADDR
// if not Bobby then
 937: LD_EXP 12
 941: NOT
 942: IFFALSE 966
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 03_ ) ;
 944: LD_ADDR_EXP 12
 948: PUSH
 949: LD_STRING Bobby
 951: PPUSH
 952: LD_EXP 1
 956: NOT
 957: PPUSH
 958: LD_STRING 03_
 960: PPUSH
 961: CALL 4508 0 3
 965: ST_TO_ADDR
// end ; if Bobby then
 966: LD_EXP 12
 970: IFFALSE 988
// team := team ^ Bobby ;
 972: LD_ADDR_VAR 0 6
 976: PUSH
 977: LD_VAR 0 6
 981: PUSH
 982: LD_EXP 12
 986: ADD
 987: ST_TO_ADDR
// end ; end ; others4 := CreateCharacterSet ( othersGamma ) ;
 988: LD_ADDR_VAR 0 4
 992: PUSH
 993: LD_STRING othersGamma
 995: PPUSH
 996: CALL_OW 31
1000: ST_TO_ADDR
// others := CreateCharacterSet ( 06_other_survivors ) ;
1001: LD_ADDR_VAR 0 2
1005: PUSH
1006: LD_STRING 06_other_survivors
1008: PPUSH
1009: CALL_OW 31
1013: ST_TO_ADDR
// others := others union others4 ;
1014: LD_ADDR_VAR 0 2
1018: PUSH
1019: LD_VAR 0 2
1023: PUSH
1024: LD_VAR 0 4
1028: UNION
1029: ST_TO_ADDR
// team := team ^ others ;
1030: LD_ADDR_VAR 0 6
1034: PUSH
1035: LD_VAR 0 6
1039: PUSH
1040: LD_VAR 0 2
1044: ADD
1045: ST_TO_ADDR
// InitHc ;
1046: CALL_OW 19
// if team <= 12 then
1050: LD_VAR 0 6
1054: PUSH
1055: LD_INT 12
1057: LESSEQUAL
1058: IFFALSE 1107
// repeat PrepareHuman ( false , rand ( 1 , 4 ) , 5 ) ;
1060: LD_INT 0
1062: PPUSH
1063: LD_INT 1
1065: PPUSH
1066: LD_INT 4
1068: PPUSH
1069: CALL_OW 12
1073: PPUSH
1074: LD_INT 5
1076: PPUSH
1077: CALL_OW 380
// team := team ^ CreateHuman ;
1081: LD_ADDR_VAR 0 6
1085: PUSH
1086: LD_VAR 0 6
1090: PUSH
1091: CALL_OW 44
1095: ADD
1096: ST_TO_ADDR
// until team > 12 ;
1097: LD_VAR 0 6
1101: PUSH
1102: LD_INT 12
1104: GREATER
1105: IFFALSE 1060
// for i in others do
1107: LD_ADDR_VAR 0 13
1111: PUSH
1112: LD_VAR 0 2
1116: PUSH
1117: FOR_IN
1118: IFFALSE 1186
// begin if GetClass ( i ) = 2 then
1120: LD_VAR 0 13
1124: PPUSH
1125: CALL_OW 257
1129: PUSH
1130: LD_INT 2
1132: EQUAL
1133: IFFALSE 1147
// SetClass ( i , 1 ) ;
1135: LD_VAR 0 13
1139: PPUSH
1140: LD_INT 1
1142: PPUSH
1143: CALL_OW 336
// for j = 1 to 4 do
1147: LD_ADDR_VAR 0 14
1151: PUSH
1152: DOUBLE
1153: LD_INT 1
1155: DEC
1156: ST_TO_ADDR
1157: LD_INT 4
1159: PUSH
1160: FOR_TO
1161: IFFALSE 1182
// AddExperience ( i , j , 3000 ) ;
1163: LD_VAR 0 13
1167: PPUSH
1168: LD_VAR 0 14
1172: PPUSH
1173: LD_INT 3000
1175: PPUSH
1176: CALL_OW 492
1180: GO 1160
1182: POP
1183: POP
// end ;
1184: GO 1117
1186: POP
1187: POP
// if UnitFilter ( team , [ f_class , 2 ] ) then
1188: LD_VAR 0 6
1192: PPUSH
1193: LD_INT 25
1195: PUSH
1196: LD_INT 2
1198: PUSH
1199: EMPTY
1200: LIST
1201: LIST
1202: PPUSH
1203: CALL_OW 72
1207: IFFALSE 1253
// for i in UnitFilter ( team , [ f_class , 2 ] ) do
1209: LD_ADDR_VAR 0 13
1213: PUSH
1214: LD_VAR 0 6
1218: PPUSH
1219: LD_INT 25
1221: PUSH
1222: LD_INT 2
1224: PUSH
1225: EMPTY
1226: LIST
1227: LIST
1228: PPUSH
1229: CALL_OW 72
1233: PUSH
1234: FOR_IN
1235: IFFALSE 1251
// SetClass ( i , 1 ) ;
1237: LD_VAR 0 13
1241: PPUSH
1242: LD_INT 1
1244: PPUSH
1245: CALL_OW 336
1249: GO 1234
1251: POP
1252: POP
// dep := FilterAllUnits ( [ f_btype , b_depot ] ) ;
1253: LD_ADDR_VAR 0 7
1257: PUSH
1258: LD_INT 30
1260: PUSH
1261: LD_INT 0
1263: PUSH
1264: EMPTY
1265: LIST
1266: LIST
1267: PPUSH
1268: CALL_OW 69
1272: ST_TO_ADDR
// bar := FilterAllUnits ( [ f_btype , b_armoury ] ) ;
1273: LD_ADDR_VAR 0 8
1277: PUSH
1278: LD_INT 30
1280: PUSH
1281: LD_INT 4
1283: PUSH
1284: EMPTY
1285: LIST
1286: LIST
1287: PPUSH
1288: CALL_OW 69
1292: ST_TO_ADDR
// lab := FilterAllUnits ( [ f_or , [ f_btype , b_lab_half ] , [ f_btype , b_lab ] ] ) ;
1293: LD_ADDR_VAR 0 9
1297: PUSH
1298: LD_INT 2
1300: PUSH
1301: LD_INT 30
1303: PUSH
1304: LD_INT 7
1306: PUSH
1307: EMPTY
1308: LIST
1309: LIST
1310: PUSH
1311: LD_INT 30
1313: PUSH
1314: LD_INT 6
1316: PUSH
1317: EMPTY
1318: LIST
1319: LIST
1320: PUSH
1321: EMPTY
1322: LIST
1323: LIST
1324: LIST
1325: PPUSH
1326: CALL_OW 69
1330: ST_TO_ADDR
// fac := FilterAllUnits ( [ f_btype , b_factory ] ) ;
1331: LD_ADDR_VAR 0 10
1335: PUSH
1336: LD_INT 30
1338: PUSH
1339: LD_INT 3
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: PPUSH
1346: CALL_OW 69
1350: ST_TO_ADDR
// bun := FilterAllUnits ( [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ;
1351: LD_ADDR_VAR 0 11
1355: PUSH
1356: LD_INT 2
1358: PUSH
1359: LD_INT 30
1361: PUSH
1362: LD_INT 32
1364: PUSH
1365: EMPTY
1366: LIST
1367: LIST
1368: PUSH
1369: LD_INT 30
1371: PUSH
1372: LD_INT 31
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: PUSH
1379: EMPTY
1380: LIST
1381: LIST
1382: LIST
1383: PPUSH
1384: CALL_OW 69
1388: ST_TO_ADDR
// SetBName ( dep , Gamma ) ;
1389: LD_VAR 0 7
1393: PPUSH
1394: LD_STRING Gamma
1396: PPUSH
1397: CALL_OW 500
// SetResourceType ( GetBase ( dep ) , mat_oil , 10000 ) ;
1401: LD_VAR 0 7
1405: PPUSH
1406: CALL_OW 274
1410: PPUSH
1411: LD_INT 2
1413: PPUSH
1414: LD_INT 10000
1416: PPUSH
1417: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_cans , 10000 ) ;
1421: LD_VAR 0 7
1425: PPUSH
1426: CALL_OW 274
1430: PPUSH
1431: LD_INT 1
1433: PPUSH
1434: LD_INT 10000
1436: PPUSH
1437: CALL_OW 277
// if dep then
1441: LD_VAR 0 7
1445: IFFALSE 1547
// begin PlaceHumanInUnit ( JMM , dep [ 1 ] ) ;
1447: LD_EXP 7
1451: PPUSH
1452: LD_VAR 0 7
1456: PUSH
1457: LD_INT 1
1459: ARRAY
1460: PPUSH
1461: CALL_OW 52
// if Brown then
1465: LD_EXP 14
1469: IFFALSE 1505
// begin PlaceHumanInUnit ( Brown , dep [ 1 ] ) ;
1471: LD_EXP 14
1475: PPUSH
1476: LD_VAR 0 7
1480: PUSH
1481: LD_INT 1
1483: ARRAY
1484: PPUSH
1485: CALL_OW 52
// team := team diff Brown ;
1489: LD_ADDR_VAR 0 6
1493: PUSH
1494: LD_VAR 0 6
1498: PUSH
1499: LD_EXP 14
1503: DIFF
1504: ST_TO_ADDR
// end ; if Donaldson then
1505: LD_EXP 13
1509: IFFALSE 1545
// begin PlaceHumanInUnit ( Donaldson , dep [ 1 ] ) ;
1511: LD_EXP 13
1515: PPUSH
1516: LD_VAR 0 7
1520: PUSH
1521: LD_INT 1
1523: ARRAY
1524: PPUSH
1525: CALL_OW 52
// team := team diff Donaldson ;
1529: LD_ADDR_VAR 0 6
1533: PUSH
1534: LD_VAR 0 6
1538: PUSH
1539: LD_EXP 13
1543: DIFF
1544: ST_TO_ADDR
// end ; end else
1545: GO 1654
// begin PlaceUnitXYR ( JMM , 52 , 16 , 10 , false ) ;
1547: LD_EXP 7
1551: PPUSH
1552: LD_INT 52
1554: PPUSH
1555: LD_INT 16
1557: PPUSH
1558: LD_INT 10
1560: PPUSH
1561: LD_INT 0
1563: PPUSH
1564: CALL_OW 50
// if Brown then
1568: LD_EXP 14
1572: IFFALSE 1611
// begin PlaceUnitXYR ( Brown , 52 , 16 , 10 , false ) ;
1574: LD_EXP 14
1578: PPUSH
1579: LD_INT 52
1581: PPUSH
1582: LD_INT 16
1584: PPUSH
1585: LD_INT 10
1587: PPUSH
1588: LD_INT 0
1590: PPUSH
1591: CALL_OW 50
// team := team diff Brown ;
1595: LD_ADDR_VAR 0 6
1599: PUSH
1600: LD_VAR 0 6
1604: PUSH
1605: LD_EXP 14
1609: DIFF
1610: ST_TO_ADDR
// end ; if Donaldson then
1611: LD_EXP 13
1615: IFFALSE 1654
// begin PlaceUnitXYR ( Donaldson , 52 , 16 , 10 , false ) ;
1617: LD_EXP 13
1621: PPUSH
1622: LD_INT 52
1624: PPUSH
1625: LD_INT 16
1627: PPUSH
1628: LD_INT 10
1630: PPUSH
1631: LD_INT 0
1633: PPUSH
1634: CALL_OW 50
// team := team diff Donaldson ;
1638: LD_ADDR_VAR 0 6
1642: PUSH
1643: LD_VAR 0 6
1647: PUSH
1648: LD_EXP 13
1652: DIFF
1653: ST_TO_ADDR
// end ; end ; if bun and UnitFilter ( team , [ f_class , 1 ] ) then
1654: LD_VAR 0 11
1658: IFFALSE 1681
1660: PUSH
1661: LD_VAR 0 6
1665: PPUSH
1666: LD_INT 25
1668: PUSH
1669: LD_INT 1
1671: PUSH
1672: EMPTY
1673: LIST
1674: LIST
1675: PPUSH
1676: CALL_OW 72
1680: AND
1681: IFFALSE 1790
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
1683: LD_ADDR_VAR 0 12
1687: PUSH
1688: LD_VAR 0 6
1692: PPUSH
1693: LD_INT 25
1695: PUSH
1696: LD_INT 1
1698: PUSH
1699: EMPTY
1700: LIST
1701: LIST
1702: PPUSH
1703: CALL_OW 72
1707: ST_TO_ADDR
// for i in bun do
1708: LD_ADDR_VAR 0 13
1712: PUSH
1713: LD_VAR 0 11
1717: PUSH
1718: FOR_IN
1719: IFFALSE 1788
// begin if not filter then
1721: LD_VAR 0 12
1725: NOT
1726: IFFALSE 1730
// break ;
1728: GO 1788
// PlaceHumanInUnit ( filter [ 1 ] , i ) ;
1730: LD_VAR 0 12
1734: PUSH
1735: LD_INT 1
1737: ARRAY
1738: PPUSH
1739: LD_VAR 0 13
1743: PPUSH
1744: CALL_OW 52
// team := team diff filter [ 1 ] ;
1748: LD_ADDR_VAR 0 6
1752: PUSH
1753: LD_VAR 0 6
1757: PUSH
1758: LD_VAR 0 12
1762: PUSH
1763: LD_INT 1
1765: ARRAY
1766: DIFF
1767: ST_TO_ADDR
// filter := Delete ( filter , 1 ) ;
1768: LD_ADDR_VAR 0 12
1772: PUSH
1773: LD_VAR 0 12
1777: PPUSH
1778: LD_INT 1
1780: PPUSH
1781: CALL_OW 3
1785: ST_TO_ADDR
// end ;
1786: GO 1718
1788: POP
1789: POP
// end ; if bar and UnitFilter ( team , [ f_class , 1 ] ) then
1790: LD_VAR 0 8
1794: IFFALSE 1817
1796: PUSH
1797: LD_VAR 0 6
1801: PPUSH
1802: LD_INT 25
1804: PUSH
1805: LD_INT 1
1807: PUSH
1808: EMPTY
1809: LIST
1810: LIST
1811: PPUSH
1812: CALL_OW 72
1816: AND
1817: IFFALSE 1939
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
1819: LD_ADDR_VAR 0 12
1823: PUSH
1824: LD_VAR 0 6
1828: PPUSH
1829: LD_INT 25
1831: PUSH
1832: LD_INT 1
1834: PUSH
1835: EMPTY
1836: LIST
1837: LIST
1838: PPUSH
1839: CALL_OW 72
1843: ST_TO_ADDR
// for i = 1 to filter do
1844: LD_ADDR_VAR 0 13
1848: PUSH
1849: DOUBLE
1850: LD_INT 1
1852: DEC
1853: ST_TO_ADDR
1854: LD_VAR 0 12
1858: PUSH
1859: FOR_TO
1860: IFFALSE 1921
// begin if ( i <= 6 ) then
1862: LD_VAR 0 13
1866: PUSH
1867: LD_INT 6
1869: LESSEQUAL
1870: IFFALSE 1898
// PlaceHumanInUnit ( filter [ i ] , bar [ 1 ] ) else
1872: LD_VAR 0 12
1876: PUSH
1877: LD_VAR 0 13
1881: ARRAY
1882: PPUSH
1883: LD_VAR 0 8
1887: PUSH
1888: LD_INT 1
1890: ARRAY
1891: PPUSH
1892: CALL_OW 52
1896: GO 1919
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1898: LD_VAR 0 12
1902: PUSH
1903: LD_VAR 0 13
1907: ARRAY
1908: PPUSH
1909: LD_INT 1
1911: PPUSH
1912: LD_INT 0
1914: PPUSH
1915: CALL_OW 49
// end ;
1919: GO 1859
1921: POP
1922: POP
// team := team diff filter ;
1923: LD_ADDR_VAR 0 6
1927: PUSH
1928: LD_VAR 0 6
1932: PUSH
1933: LD_VAR 0 12
1937: DIFF
1938: ST_TO_ADDR
// end ; if lab and UnitFilter ( team , [ f_class , 4 ] ) then
1939: LD_VAR 0 9
1943: IFFALSE 1966
1945: PUSH
1946: LD_VAR 0 6
1950: PPUSH
1951: LD_INT 25
1953: PUSH
1954: LD_INT 4
1956: PUSH
1957: EMPTY
1958: LIST
1959: LIST
1960: PPUSH
1961: CALL_OW 72
1965: AND
1966: IFFALSE 2088
// begin filter := UnitFilter ( team , [ f_class , 4 ] ) ;
1968: LD_ADDR_VAR 0 12
1972: PUSH
1973: LD_VAR 0 6
1977: PPUSH
1978: LD_INT 25
1980: PUSH
1981: LD_INT 4
1983: PUSH
1984: EMPTY
1985: LIST
1986: LIST
1987: PPUSH
1988: CALL_OW 72
1992: ST_TO_ADDR
// for i = 1 to filter do
1993: LD_ADDR_VAR 0 13
1997: PUSH
1998: DOUBLE
1999: LD_INT 1
2001: DEC
2002: ST_TO_ADDR
2003: LD_VAR 0 12
2007: PUSH
2008: FOR_TO
2009: IFFALSE 2070
// begin if ( i <= 6 ) then
2011: LD_VAR 0 13
2015: PUSH
2016: LD_INT 6
2018: LESSEQUAL
2019: IFFALSE 2047
// PlaceHumanInUnit ( filter [ i ] , lab [ 1 ] ) else
2021: LD_VAR 0 12
2025: PUSH
2026: LD_VAR 0 13
2030: ARRAY
2031: PPUSH
2032: LD_VAR 0 9
2036: PUSH
2037: LD_INT 1
2039: ARRAY
2040: PPUSH
2041: CALL_OW 52
2045: GO 2068
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
2047: LD_VAR 0 12
2051: PUSH
2052: LD_VAR 0 13
2056: ARRAY
2057: PPUSH
2058: LD_INT 1
2060: PPUSH
2061: LD_INT 0
2063: PPUSH
2064: CALL_OW 49
// end ;
2068: GO 2008
2070: POP
2071: POP
// team := team diff filter ;
2072: LD_ADDR_VAR 0 6
2076: PUSH
2077: LD_VAR 0 6
2081: PUSH
2082: LD_VAR 0 12
2086: DIFF
2087: ST_TO_ADDR
// end ; if fac and UnitFilter ( team , [ f_class , 3 ] ) then
2088: LD_VAR 0 10
2092: IFFALSE 2115
2094: PUSH
2095: LD_VAR 0 6
2099: PPUSH
2100: LD_INT 25
2102: PUSH
2103: LD_INT 3
2105: PUSH
2106: EMPTY
2107: LIST
2108: LIST
2109: PPUSH
2110: CALL_OW 72
2114: AND
2115: IFFALSE 2237
// begin filter := UnitFilter ( team , [ f_class , 3 ] ) ;
2117: LD_ADDR_VAR 0 12
2121: PUSH
2122: LD_VAR 0 6
2126: PPUSH
2127: LD_INT 25
2129: PUSH
2130: LD_INT 3
2132: PUSH
2133: EMPTY
2134: LIST
2135: LIST
2136: PPUSH
2137: CALL_OW 72
2141: ST_TO_ADDR
// for i = 1 to filter do
2142: LD_ADDR_VAR 0 13
2146: PUSH
2147: DOUBLE
2148: LD_INT 1
2150: DEC
2151: ST_TO_ADDR
2152: LD_VAR 0 12
2156: PUSH
2157: FOR_TO
2158: IFFALSE 2219
// begin if ( i <= 6 ) then
2160: LD_VAR 0 13
2164: PUSH
2165: LD_INT 6
2167: LESSEQUAL
2168: IFFALSE 2196
// PlaceHumanInUnit ( filter [ i ] , fac [ 1 ] ) else
2170: LD_VAR 0 12
2174: PUSH
2175: LD_VAR 0 13
2179: ARRAY
2180: PPUSH
2181: LD_VAR 0 10
2185: PUSH
2186: LD_INT 1
2188: ARRAY
2189: PPUSH
2190: CALL_OW 52
2194: GO 2217
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
2196: LD_VAR 0 12
2200: PUSH
2201: LD_VAR 0 13
2205: ARRAY
2206: PPUSH
2207: LD_INT 1
2209: PPUSH
2210: LD_INT 0
2212: PPUSH
2213: CALL_OW 49
// end ;
2217: GO 2157
2219: POP
2220: POP
// team := team diff filter ;
2221: LD_ADDR_VAR 0 6
2225: PUSH
2226: LD_VAR 0 6
2230: PUSH
2231: LD_VAR 0 12
2235: DIFF
2236: ST_TO_ADDR
// end ; if team then
2237: LD_VAR 0 6
2241: IFFALSE 2284
// for i in team do
2243: LD_ADDR_VAR 0 13
2247: PUSH
2248: LD_VAR 0 6
2252: PUSH
2253: FOR_IN
2254: IFFALSE 2282
// begin PlaceUnitArea ( i , gammaBaseArea , false ) ;
2256: LD_VAR 0 13
2260: PPUSH
2261: LD_INT 1
2263: PPUSH
2264: LD_INT 0
2266: PPUSH
2267: CALL_OW 49
// ComHold ( i ) ;
2271: LD_VAR 0 13
2275: PPUSH
2276: CALL_OW 140
// end ;
2280: GO 2253
2282: POP
2283: POP
// if fac then
2284: LD_VAR 0 10
2288: IFFALSE 2324
// if UnitsInside ( fac [ 1 ] ) then
2290: LD_VAR 0 10
2294: PUSH
2295: LD_INT 1
2297: ARRAY
2298: PPUSH
2299: CALL_OW 313
2303: IFFALSE 2324
// SetSpecResearch ( fac [ 1 ] , 10 , false ) ;
2305: LD_VAR 0 10
2309: PUSH
2310: LD_INT 1
2312: ARRAY
2313: PPUSH
2314: LD_INT 10
2316: PPUSH
2317: LD_INT 0
2319: PPUSH
2320: CALL_OW 486
// if lab then
2324: LD_VAR 0 9
2328: IFFALSE 2364
// if UnitsInside ( lab [ 1 ] ) then
2330: LD_VAR 0 9
2334: PUSH
2335: LD_INT 1
2337: ARRAY
2338: PPUSH
2339: CALL_OW 313
2343: IFFALSE 2364
// SetSpecResearch ( lab [ 1 ] , 10 , false ) ;
2345: LD_VAR 0 9
2349: PUSH
2350: LD_INT 1
2352: ARRAY
2353: PPUSH
2354: LD_INT 10
2356: PPUSH
2357: LD_INT 0
2359: PPUSH
2360: CALL_OW 486
// uc_side := 4 ;
2364: LD_ADDR_OWVAR 20
2368: PUSH
2369: LD_INT 4
2371: ST_TO_ADDR
// Harisson := PrepareUnit ( Harisson , false ,  ) ;
2372: LD_ADDR_EXP 17
2376: PUSH
2377: LD_STRING Harisson
2379: PPUSH
2380: LD_INT 0
2382: PPUSH
2383: LD_STRING 
2385: PPUSH
2386: CALL 4508 0 3
2390: ST_TO_ADDR
// veh := PrepareTank ( 4 , 1 , us_medium_wheeled , engine_combustion , control_manual , us_double_gun , 100 ) ;
2391: LD_ADDR_VAR 0 5
2395: PUSH
2396: LD_INT 4
2398: PPUSH
2399: LD_INT 1
2401: PPUSH
2402: LD_INT 2
2404: PPUSH
2405: LD_INT 1
2407: PPUSH
2408: LD_INT 1
2410: PPUSH
2411: LD_INT 5
2413: PPUSH
2414: LD_INT 100
2416: PPUSH
2417: CALL 4571 0 7
2421: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
2422: LD_VAR 0 5
2426: PPUSH
2427: LD_INT 2
2429: PPUSH
2430: CALL_OW 233
// PlaceUnitXY ( veh , 22 , 9 , false ) ;
2434: LD_VAR 0 5
2438: PPUSH
2439: LD_INT 22
2441: PPUSH
2442: LD_INT 9
2444: PPUSH
2445: LD_INT 0
2447: PPUSH
2448: CALL_OW 48
// PlaceHumanInUnit ( Harisson , veh ) ;
2452: LD_EXP 17
2456: PPUSH
2457: LD_VAR 0 5
2461: PPUSH
2462: CALL_OW 52
// PrepareHuman ( false , 1 , 0 ) ;
2466: LD_INT 0
2468: PPUSH
2469: LD_INT 1
2471: PPUSH
2472: LD_INT 0
2474: PPUSH
2475: CALL_OW 380
// RandGuy := CreateHuman ;
2479: LD_ADDR_EXP 19
2483: PUSH
2484: CALL_OW 44
2488: ST_TO_ADDR
// veh := PrepareTank ( 4 , 1 , us_medium_wheeled , engine_combustion , control_manual , us_gatling_gun , 100 ) ;
2489: LD_ADDR_VAR 0 5
2493: PUSH
2494: LD_INT 4
2496: PPUSH
2497: LD_INT 1
2499: PPUSH
2500: LD_INT 2
2502: PPUSH
2503: LD_INT 1
2505: PPUSH
2506: LD_INT 1
2508: PPUSH
2509: LD_INT 4
2511: PPUSH
2512: LD_INT 100
2514: PPUSH
2515: CALL 4571 0 7
2519: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
2520: LD_VAR 0 5
2524: PPUSH
2525: LD_INT 2
2527: PPUSH
2528: CALL_OW 233
// PlaceUnitXY ( veh , 17 , 4 , false ) ;
2532: LD_VAR 0 5
2536: PPUSH
2537: LD_INT 17
2539: PPUSH
2540: LD_INT 4
2542: PPUSH
2543: LD_INT 0
2545: PPUSH
2546: CALL_OW 48
// PlaceHumanInUnit ( RandGuy , veh ) ;
2550: LD_EXP 19
2554: PPUSH
2555: LD_VAR 0 5
2559: PPUSH
2560: CALL_OW 52
// end ;
2564: LD_VAR 0 1
2568: RET
// function PrepareBase ; var blist , i , b , base ; begin
2569: LD_INT 0
2571: PPUSH
2572: PPUSH
2573: PPUSH
2574: PPUSH
2575: PPUSH
// SetResourceVisibility ( 71 , 5 , 1 ) ;
2576: LD_INT 71
2578: PPUSH
2579: LD_INT 5
2581: PPUSH
2582: LD_INT 1
2584: PPUSH
2585: CALL_OW 441
// blist := LoadVariable ( GammaBase , [ ] ) ;
2589: LD_ADDR_VAR 0 2
2593: PUSH
2594: LD_STRING GammaBase
2596: PPUSH
2597: EMPTY
2598: PPUSH
2599: CALL_OW 30
2603: ST_TO_ADDR
// if not blist then
2604: LD_VAR 0 2
2608: NOT
2609: IFFALSE 2649
// blist := [ [ b_depot , 52 , 12 , 3 , 3 , 0 , 0 ] ] ;
2611: LD_ADDR_VAR 0 2
2615: PUSH
2616: LD_INT 0
2618: PUSH
2619: LD_INT 52
2621: PUSH
2622: LD_INT 12
2624: PUSH
2625: LD_INT 3
2627: PUSH
2628: LD_INT 3
2630: PUSH
2631: LD_INT 0
2633: PUSH
2634: LD_INT 0
2636: PUSH
2637: EMPTY
2638: LIST
2639: LIST
2640: LIST
2641: LIST
2642: LIST
2643: LIST
2644: LIST
2645: PUSH
2646: EMPTY
2647: LIST
2648: ST_TO_ADDR
// uc_side := 1 ;
2649: LD_ADDR_OWVAR 20
2653: PUSH
2654: LD_INT 1
2656: ST_TO_ADDR
// uc_nation := 1 ;
2657: LD_ADDR_OWVAR 21
2661: PUSH
2662: LD_INT 1
2664: ST_TO_ADDR
// for i in blist do
2665: LD_ADDR_VAR 0 3
2669: PUSH
2670: LD_VAR 0 2
2674: PUSH
2675: FOR_IN
2676: IFFALSE 2869
// begin InitBc ;
2678: CALL_OW 21
// bc_type := i [ 1 ] ;
2682: LD_ADDR_OWVAR 42
2686: PUSH
2687: LD_VAR 0 3
2691: PUSH
2692: LD_INT 1
2694: ARRAY
2695: ST_TO_ADDR
// bc_level := i [ 5 ] ;
2696: LD_ADDR_OWVAR 43
2700: PUSH
2701: LD_VAR 0 3
2705: PUSH
2706: LD_INT 5
2708: ARRAY
2709: ST_TO_ADDR
// bc_kind1 := b_lab_basic ;
2710: LD_ADDR_OWVAR 44
2714: PUSH
2715: LD_INT 9
2717: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
2718: LD_ADDR_OWVAR 45
2722: PUSH
2723: LD_INT 9
2725: ST_TO_ADDR
// if i [ 1 ] in [ b_lab_half , b_lab_full ] then
2726: LD_VAR 0 3
2730: PUSH
2731: LD_INT 1
2733: ARRAY
2734: PUSH
2735: LD_INT 7
2737: PUSH
2738: LD_INT 8
2740: PUSH
2741: EMPTY
2742: LIST
2743: LIST
2744: IN
2745: IFFALSE 2797
// begin bc_kind1 := i [ 7 ] ;
2747: LD_ADDR_OWVAR 44
2751: PUSH
2752: LD_VAR 0 3
2756: PUSH
2757: LD_INT 7
2759: ARRAY
2760: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
2761: LD_ADDR_OWVAR 45
2765: PUSH
2766: LD_INT 9
2768: ST_TO_ADDR
// if i [ 1 ] = b_lab_full then
2769: LD_VAR 0 3
2773: PUSH
2774: LD_INT 1
2776: ARRAY
2777: PUSH
2778: LD_INT 8
2780: EQUAL
2781: IFFALSE 2797
// bc_kind2 := i [ 8 ] ;
2783: LD_ADDR_OWVAR 45
2787: PUSH
2788: LD_VAR 0 3
2792: PUSH
2793: LD_INT 8
2795: ARRAY
2796: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
2797: LD_ADDR_VAR 0 4
2801: PUSH
2802: LD_VAR 0 3
2806: PUSH
2807: LD_INT 2
2809: ARRAY
2810: PPUSH
2811: LD_VAR 0 3
2815: PUSH
2816: LD_INT 3
2818: ARRAY
2819: PPUSH
2820: LD_VAR 0 3
2824: PUSH
2825: LD_INT 4
2827: ARRAY
2828: PPUSH
2829: CALL_OW 47
2833: ST_TO_ADDR
// if GetBType ( b ) = b_bunker then
2834: LD_VAR 0 4
2838: PPUSH
2839: CALL_OW 266
2843: PUSH
2844: LD_INT 32
2846: EQUAL
2847: IFFALSE 2867
// begin PlaceWeaponTurret ( b , i [ 7 ] ) ;
2849: LD_VAR 0 4
2853: PPUSH
2854: LD_VAR 0 3
2858: PUSH
2859: LD_INT 7
2861: ARRAY
2862: PPUSH
2863: CALL_OW 431
// end ; end ;
2867: GO 2675
2869: POP
2870: POP
// if not FilterAllUnits ( [ f_btype , b_depot ] ) then
2871: LD_INT 30
2873: PUSH
2874: LD_INT 0
2876: PUSH
2877: EMPTY
2878: LIST
2879: LIST
2880: PPUSH
2881: CALL_OW 69
2885: NOT
2886: IFFALSE 2923
// begin bc_type := b_depot ;
2888: LD_ADDR_OWVAR 42
2892: PUSH
2893: LD_INT 0
2895: ST_TO_ADDR
// bc_level := 6 ;
2896: LD_ADDR_OWVAR 43
2900: PUSH
2901: LD_INT 6
2903: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 52 , 12 , 3 ) ;
2904: LD_ADDR_VAR 0 4
2908: PUSH
2909: LD_INT 52
2911: PPUSH
2912: LD_INT 12
2914: PPUSH
2915: LD_INT 3
2917: PPUSH
2918: CALL_OW 47
2922: ST_TO_ADDR
// end ; base := GetBase ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) [ 1 ] ) ;
2923: LD_ADDR_VAR 0 5
2927: PUSH
2928: LD_INT 22
2930: PUSH
2931: LD_INT 1
2933: PUSH
2934: EMPTY
2935: LIST
2936: LIST
2937: PUSH
2938: LD_INT 2
2940: PUSH
2941: LD_INT 30
2943: PUSH
2944: LD_INT 0
2946: PUSH
2947: EMPTY
2948: LIST
2949: LIST
2950: PUSH
2951: LD_INT 30
2953: PUSH
2954: LD_INT 1
2956: PUSH
2957: EMPTY
2958: LIST
2959: LIST
2960: PUSH
2961: EMPTY
2962: LIST
2963: LIST
2964: LIST
2965: PUSH
2966: EMPTY
2967: LIST
2968: LIST
2969: PPUSH
2970: CALL_OW 69
2974: PUSH
2975: LD_INT 1
2977: ARRAY
2978: PPUSH
2979: CALL_OW 274
2983: ST_TO_ADDR
// if base then
2984: LD_VAR 0 5
2988: IFFALSE 3005
// SetResourceType ( base , mat_oil , 1000 ) ;
2990: LD_VAR 0 5
2994: PPUSH
2995: LD_INT 2
2997: PPUSH
2998: LD_INT 1000
3000: PPUSH
3001: CALL_OW 277
// end ; end_of_file
3005: LD_VAR 0 1
3009: RET
// export function Action ; var points , i , sol , time , team , filter ; begin
3010: LD_INT 0
3012: PPUSH
3013: PPUSH
3014: PPUSH
3015: PPUSH
3016: PPUSH
3017: PPUSH
3018: PPUSH
// InGameOn ;
3019: CALL_OW 8
// CenterNowOnXY ( 33 , 11 ) ;
3023: LD_INT 33
3025: PPUSH
3026: LD_INT 11
3028: PPUSH
3029: CALL_OW 86
// points := [ [ 29 , 21 ] , [ 41 , 28 ] , [ 52 , 26 ] , [ 49 , 16 ] ] ;
3033: LD_ADDR_VAR 0 2
3037: PUSH
3038: LD_INT 29
3040: PUSH
3041: LD_INT 21
3043: PUSH
3044: EMPTY
3045: LIST
3046: LIST
3047: PUSH
3048: LD_INT 41
3050: PUSH
3051: LD_INT 28
3053: PUSH
3054: EMPTY
3055: LIST
3056: LIST
3057: PUSH
3058: LD_INT 52
3060: PUSH
3061: LD_INT 26
3063: PUSH
3064: EMPTY
3065: LIST
3066: LIST
3067: PUSH
3068: LD_INT 49
3070: PUSH
3071: LD_INT 16
3073: PUSH
3074: EMPTY
3075: LIST
3076: LIST
3077: PUSH
3078: EMPTY
3079: LIST
3080: LIST
3081: LIST
3082: LIST
3083: ST_TO_ADDR
// sol := ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , 1 ] ] ) diff [ JMM , Brown , Cyrus , Bobby , Gladstone , Houten , Khatam ] ) [ 1 ] ;
3084: LD_ADDR_VAR 0 4
3088: PUSH
3089: LD_INT 22
3091: PUSH
3092: LD_INT 1
3094: PUSH
3095: EMPTY
3096: LIST
3097: LIST
3098: PUSH
3099: LD_INT 26
3101: PUSH
3102: LD_INT 1
3104: PUSH
3105: EMPTY
3106: LIST
3107: LIST
3108: PUSH
3109: EMPTY
3110: LIST
3111: LIST
3112: PPUSH
3113: CALL_OW 69
3117: PUSH
3118: LD_EXP 7
3122: PUSH
3123: LD_EXP 14
3127: PUSH
3128: LD_EXP 11
3132: PUSH
3133: LD_EXP 12
3137: PUSH
3138: LD_EXP 8
3142: PUSH
3143: LD_EXP 15
3147: PUSH
3148: LD_EXP 16
3152: PUSH
3153: EMPTY
3154: LIST
3155: LIST
3156: LIST
3157: LIST
3158: LIST
3159: LIST
3160: LIST
3161: DIFF
3162: PUSH
3163: LD_INT 1
3165: ARRAY
3166: ST_TO_ADDR
// if sol then
3167: LD_VAR 0 4
3171: IFFALSE 3202
// begin ComMoveXY ( sol , 50 , 18 ) ;
3173: LD_VAR 0 4
3177: PPUSH
3178: LD_INT 50
3180: PPUSH
3181: LD_INT 18
3183: PPUSH
3184: CALL_OW 111
// AddComTurnUnit ( sol , Harisson ) ;
3188: LD_VAR 0 4
3192: PPUSH
3193: LD_EXP 17
3197: PPUSH
3198: CALL_OW 179
// end ; for i in points do
3202: LD_ADDR_VAR 0 3
3206: PUSH
3207: LD_VAR 0 2
3211: PUSH
3212: FOR_IN
3213: IFFALSE 3253
// AddComMoveXY ( [ Harisson , RandGuy ] , i [ 1 ] , i [ 2 ] ) ;
3215: LD_EXP 17
3219: PUSH
3220: LD_EXP 19
3224: PUSH
3225: EMPTY
3226: LIST
3227: LIST
3228: PPUSH
3229: LD_VAR 0 3
3233: PUSH
3234: LD_INT 1
3236: ARRAY
3237: PPUSH
3238: LD_VAR 0 3
3242: PUSH
3243: LD_INT 2
3245: ARRAY
3246: PPUSH
3247: CALL_OW 171
3251: GO 3212
3253: POP
3254: POP
// AddComExitVehicle ( [ Harisson , RandGuy ] ) ;
3255: LD_EXP 17
3259: PUSH
3260: LD_EXP 19
3264: PUSH
3265: EMPTY
3266: LIST
3267: LIST
3268: PPUSH
3269: CALL_OW 181
// AddComTurnUnit ( [ Harisson , RandGuy ] , sol ) ;
3273: LD_EXP 17
3277: PUSH
3278: LD_EXP 19
3282: PUSH
3283: EMPTY
3284: LIST
3285: LIST
3286: PPUSH
3287: LD_VAR 0 4
3291: PPUSH
3292: CALL_OW 179
// time := 0 0$20 ;
3296: LD_ADDR_VAR 0 5
3300: PUSH
3301: LD_INT 700
3303: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
3304: LD_INT 10
3306: PPUSH
3307: CALL_OW 67
// time := time - 0 0$0.3 ;
3311: LD_ADDR_VAR 0 5
3315: PUSH
3316: LD_VAR 0 5
3320: PUSH
3321: LD_INT 10
3323: MINUS
3324: ST_TO_ADDR
// until not IsInUnit ( Harisson ) or time <= 0 0$00 ;
3325: LD_EXP 17
3329: PPUSH
3330: CALL_OW 310
3334: NOT
3335: IFTRUE 3347
3337: PUSH
3338: LD_VAR 0 5
3342: PUSH
3343: LD_INT 0
3345: LESSEQUAL
3346: OR
3347: IFFALSE 3304
// Say ( sol , D1-Sol1-1 ) ;
3349: LD_VAR 0 4
3353: PPUSH
3354: LD_STRING D1-Sol1-1
3356: PPUSH
3357: CALL_OW 88
// Say ( Harisson , D1-Har-1 ) ;
3361: LD_EXP 17
3365: PPUSH
3366: LD_STRING D1-Har-1
3368: PPUSH
3369: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
3373: LD_INT 10
3375: PPUSH
3376: CALL_OW 67
// ComMoveXY ( sol , 35 , 21 ) ;
3380: LD_VAR 0 4
3384: PPUSH
3385: LD_INT 35
3387: PPUSH
3388: LD_INT 21
3390: PPUSH
3391: CALL_OW 111
// ComExitBuilding ( JMM ) ;
3395: LD_EXP 7
3399: PPUSH
3400: CALL_OW 122
// AddComMoveUnit ( JMM , Harisson ) ;
3404: LD_EXP 7
3408: PPUSH
3409: LD_EXP 17
3413: PPUSH
3414: CALL_OW 172
// ComTurnUnit ( [ Harisson , RandGuy ] , JMM ) ;
3418: LD_EXP 17
3422: PUSH
3423: LD_EXP 19
3427: PUSH
3428: EMPTY
3429: LIST
3430: LIST
3431: PPUSH
3432: LD_EXP 7
3436: PPUSH
3437: CALL_OW 119
// time := 0 0$3 ;
3441: LD_ADDR_VAR 0 5
3445: PUSH
3446: LD_INT 105
3448: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3449: LD_INT 35
3451: PPUSH
3452: CALL_OW 67
// time := time - 0 0$1 ;
3456: LD_ADDR_VAR 0 5
3460: PUSH
3461: LD_VAR 0 5
3465: PUSH
3466: LD_INT 35
3468: MINUS
3469: ST_TO_ADDR
// until GetDistUnits ( JMM , Harisson ) < 4 or time = 0 0$00 ;
3470: LD_EXP 7
3474: PPUSH
3475: LD_EXP 17
3479: PPUSH
3480: CALL_OW 296
3484: PUSH
3485: LD_INT 4
3487: LESS
3488: IFTRUE 3500
3490: PUSH
3491: LD_VAR 0 5
3495: PUSH
3496: LD_INT 0
3498: EQUAL
3499: OR
3500: IFFALSE 3449
// ComTurnUnit ( JMM , Harisson ) ;
3502: LD_EXP 7
3506: PPUSH
3507: LD_EXP 17
3511: PPUSH
3512: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
3516: LD_EXP 7
3520: PPUSH
3521: LD_STRING D1-JMM-1
3523: PPUSH
3524: CALL_OW 88
// Say ( Harisson , D1-Har-2 ) ;
3528: LD_EXP 17
3532: PPUSH
3533: LD_STRING D1-Har-2
3535: PPUSH
3536: CALL_OW 88
// Say ( JMM , D1-JMM-2 ) ;
3540: LD_EXP 7
3544: PPUSH
3545: LD_STRING D1-JMM-2
3547: PPUSH
3548: CALL_OW 88
// Say ( Harisson , D1-Har-3 ) ;
3552: LD_EXP 17
3556: PPUSH
3557: LD_STRING D1-Har-3
3559: PPUSH
3560: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
3564: LD_EXP 7
3568: PPUSH
3569: LD_STRING D1-JMM-3
3571: PPUSH
3572: CALL_OW 88
// Say ( Harisson , D1-Har-4 ) ;
3576: LD_EXP 17
3580: PPUSH
3581: LD_STRING D1-Har-4
3583: PPUSH
3584: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
3588: LD_EXP 7
3592: PPUSH
3593: LD_STRING D1-JMM-4
3595: PPUSH
3596: CALL_OW 88
// Say ( Harisson , D1-Har-5 ) ;
3600: LD_EXP 17
3604: PPUSH
3605: LD_STRING D1-Har-5
3607: PPUSH
3608: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
3612: LD_EXP 7
3616: PPUSH
3617: LD_STRING D1-JMM-5
3619: PPUSH
3620: CALL_OW 88
// Say ( Harisson , D1-Har-6 ) ;
3624: LD_EXP 17
3628: PPUSH
3629: LD_STRING D1-Har-6
3631: PPUSH
3632: CALL_OW 88
// Say ( JMM , D1-JMM-6 ) ;
3636: LD_EXP 7
3640: PPUSH
3641: LD_STRING D1-JMM-6
3643: PPUSH
3644: CALL_OW 88
// EndMission ;
3648: CALL 3657 0 0
// end ;
3652: LD_VAR 0 1
3656: RET
// export function EndMission ; var commander , i , all ; begin
3657: LD_INT 0
3659: PPUSH
3660: PPUSH
3661: PPUSH
3662: PPUSH
// case gamma_commander of 1 :
3663: LD_EXP 18
3667: PUSH
3668: LD_INT 1
3670: DOUBLE
3671: EQUAL
3672: IFTRUE 3676
3674: GO 3689
3676: POP
// commander := Donaldson ; 2 :
3677: LD_ADDR_VAR 0 2
3681: PUSH
3682: LD_EXP 13
3686: ST_TO_ADDR
3687: GO 3732
3689: LD_INT 2
3691: DOUBLE
3692: EQUAL
3693: IFTRUE 3697
3695: GO 3710
3697: POP
// commander := Brown ; 3 :
3698: LD_ADDR_VAR 0 2
3702: PUSH
3703: LD_EXP 14
3707: ST_TO_ADDR
3708: GO 3732
3710: LD_INT 3
3712: DOUBLE
3713: EQUAL
3714: IFTRUE 3718
3716: GO 3731
3718: POP
// commander := Houten ; end ;
3719: LD_ADDR_VAR 0 2
3723: PUSH
3724: LD_EXP 15
3728: ST_TO_ADDR
3729: GO 3732
3731: POP
// all := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) diff [ JMM , commander ] ;
3732: LD_ADDR_VAR 0 4
3736: PUSH
3737: LD_INT 22
3739: PUSH
3740: LD_INT 1
3742: PUSH
3743: EMPTY
3744: LIST
3745: LIST
3746: PUSH
3747: LD_INT 21
3749: PUSH
3750: LD_INT 1
3752: PUSH
3753: EMPTY
3754: LIST
3755: LIST
3756: PUSH
3757: EMPTY
3758: LIST
3759: LIST
3760: PPUSH
3761: CALL_OW 69
3765: PUSH
3766: LD_EXP 7
3770: PUSH
3771: LD_VAR 0 2
3775: PUSH
3776: EMPTY
3777: LIST
3778: LIST
3779: DIFF
3780: ST_TO_ADDR
// if UnitFilter ( all , [ f_class , 2 ] ) then
3781: LD_VAR 0 4
3785: PPUSH
3786: LD_INT 25
3788: PUSH
3789: LD_INT 2
3791: PUSH
3792: EMPTY
3793: LIST
3794: LIST
3795: PPUSH
3796: CALL_OW 72
3800: IFFALSE 3846
// for i in UnitFilter ( all , [ f_class , 2 ] ) do
3802: LD_ADDR_VAR 0 3
3806: PUSH
3807: LD_VAR 0 4
3811: PPUSH
3812: LD_INT 25
3814: PUSH
3815: LD_INT 2
3817: PUSH
3818: EMPTY
3819: LIST
3820: LIST
3821: PPUSH
3822: CALL_OW 72
3826: PUSH
3827: FOR_IN
3828: IFFALSE 3844
// SetClass ( i , 2 ) ;
3830: LD_VAR 0 3
3834: PPUSH
3835: LD_INT 2
3837: PPUSH
3838: CALL_OW 336
3842: GO 3827
3844: POP
3845: POP
// save_group := CharacterSelection ( 1 , 11 , 11 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ all ^ [ sel_dont_change_class , sel_not_changeable ] ^ [ commander , Harisson ] , [ [ class_soldier , 3 ] , [ class_mechanic , 3 , 6 ] , [ class_scientistic , 1 , 2 ] ] ) ;
3846: LD_ADDR_EXP 4
3850: PUSH
3851: LD_STRING 1
3853: PPUSH
3854: LD_INT 11
3856: PPUSH
3857: LD_INT 11
3859: PPUSH
3860: LD_INT -5
3862: PUSH
3863: LD_EXP 7
3867: PUSH
3868: LD_INT -2
3870: PUSH
3871: LD_INT -3
3873: PUSH
3874: LD_INT -5
3876: PUSH
3877: EMPTY
3878: LIST
3879: LIST
3880: LIST
3881: LIST
3882: LIST
3883: PUSH
3884: LD_VAR 0 4
3888: ADD
3889: PUSH
3890: LD_INT -6
3892: PUSH
3893: LD_INT -4
3895: PUSH
3896: EMPTY
3897: LIST
3898: LIST
3899: ADD
3900: PUSH
3901: LD_VAR 0 2
3905: PUSH
3906: LD_EXP 17
3910: PUSH
3911: EMPTY
3912: LIST
3913: LIST
3914: ADD
3915: PPUSH
3916: LD_INT 1
3918: PUSH
3919: LD_INT 3
3921: PUSH
3922: EMPTY
3923: LIST
3924: LIST
3925: PUSH
3926: LD_INT 3
3928: PUSH
3929: LD_INT 3
3931: PUSH
3932: LD_INT 6
3934: PUSH
3935: EMPTY
3936: LIST
3937: LIST
3938: LIST
3939: PUSH
3940: LD_INT 4
3942: PUSH
3943: LD_INT 1
3945: PUSH
3946: LD_INT 2
3948: PUSH
3949: EMPTY
3950: LIST
3951: LIST
3952: LIST
3953: PUSH
3954: EMPTY
3955: LIST
3956: LIST
3957: LIST
3958: PPUSH
3959: CALL_OW 42
3963: ST_TO_ADDR
// SaveCharacters ( all diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , Houten , Harisson , Khatam ] ^ save_group , 07_othersGamma ) ;
3964: LD_VAR 0 4
3968: PUSH
3969: LD_EXP 7
3973: PUSH
3974: LD_EXP 8
3978: PUSH
3979: LD_EXP 10
3983: PUSH
3984: LD_EXP 11
3988: PUSH
3989: LD_EXP 12
3993: PUSH
3994: LD_EXP 9
3998: PUSH
3999: LD_EXP 13
4003: PUSH
4004: LD_EXP 14
4008: PUSH
4009: LD_EXP 15
4013: PUSH
4014: LD_EXP 17
4018: PUSH
4019: LD_EXP 16
4023: PUSH
4024: EMPTY
4025: LIST
4026: LIST
4027: LIST
4028: LIST
4029: LIST
4030: LIST
4031: LIST
4032: LIST
4033: LIST
4034: LIST
4035: LIST
4036: PUSH
4037: LD_EXP 4
4041: ADD
4042: DIFF
4043: PPUSH
4044: LD_STRING 07_othersGamma
4046: PPUSH
4047: CALL_OW 38
// SaveCharacters ( save_group diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , Houten , Harisson , Khatam , 0 ] , 07_others ) ;
4051: LD_EXP 4
4055: PUSH
4056: LD_EXP 7
4060: PUSH
4061: LD_EXP 8
4065: PUSH
4066: LD_EXP 10
4070: PUSH
4071: LD_EXP 11
4075: PUSH
4076: LD_EXP 12
4080: PUSH
4081: LD_EXP 9
4085: PUSH
4086: LD_EXP 13
4090: PUSH
4091: LD_EXP 14
4095: PUSH
4096: LD_EXP 15
4100: PUSH
4101: LD_EXP 17
4105: PUSH
4106: LD_EXP 16
4110: PUSH
4111: LD_INT 0
4113: PUSH
4114: EMPTY
4115: LIST
4116: LIST
4117: LIST
4118: LIST
4119: LIST
4120: LIST
4121: LIST
4122: LIST
4123: LIST
4124: LIST
4125: LIST
4126: LIST
4127: DIFF
4128: PPUSH
4129: LD_STRING 07_others
4131: PPUSH
4132: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
4136: LD_EXP 7
4140: PPUSH
4141: LD_EXP 5
4145: PUSH
4146: LD_STRING JMM
4148: STR
4149: PPUSH
4150: CALL_OW 38
// if Lisa then
4154: LD_EXP 10
4158: IFFALSE 4200
// begin SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
4160: LD_EXP 10
4164: PPUSH
4165: LD_EXP 5
4169: PUSH
4170: LD_STRING Lisa
4172: STR
4173: PPUSH
4174: CALL_OW 38
// if Lisa in save_group then
4178: LD_EXP 10
4182: PUSH
4183: LD_EXP 4
4187: IN
4188: IFFALSE 4200
// SaveVariable ( true , LisaIn07 ) ;
4190: LD_INT 1
4192: PPUSH
4193: LD_STRING LisaIn07
4195: PPUSH
4196: CALL_OW 39
// end ; if Bobby then
4200: LD_EXP 12
4204: IFFALSE 4246
// begin SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
4206: LD_EXP 12
4210: PPUSH
4211: LD_EXP 5
4215: PUSH
4216: LD_STRING Bobby
4218: STR
4219: PPUSH
4220: CALL_OW 38
// if Bobby in save_group then
4224: LD_EXP 12
4228: PUSH
4229: LD_EXP 4
4233: IN
4234: IFFALSE 4246
// SaveVariable ( true , BobbyIn07 ) ;
4236: LD_INT 1
4238: PPUSH
4239: LD_STRING BobbyIn07
4241: PPUSH
4242: CALL_OW 39
// end ; if Cyrus then
4246: LD_EXP 11
4250: IFFALSE 4292
// begin SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
4252: LD_EXP 11
4256: PPUSH
4257: LD_EXP 5
4261: PUSH
4262: LD_STRING Cyrus
4264: STR
4265: PPUSH
4266: CALL_OW 38
// if Cyrus in save_group then
4270: LD_EXP 11
4274: PUSH
4275: LD_EXP 4
4279: IN
4280: IFFALSE 4292
// SaveVariable ( true , CyrusIn07 ) ;
4282: LD_INT 1
4284: PPUSH
4285: LD_STRING CyrusIn07
4287: PPUSH
4288: CALL_OW 39
// end ; if Brown then
4292: LD_EXP 14
4296: IFFALSE 4338
// begin SaveCharacters ( Brown , mission_prefix & Brown ) ;
4298: LD_EXP 14
4302: PPUSH
4303: LD_EXP 5
4307: PUSH
4308: LD_STRING Brown
4310: STR
4311: PPUSH
4312: CALL_OW 38
// if Brown in save_group then
4316: LD_EXP 14
4320: PUSH
4321: LD_EXP 4
4325: IN
4326: IFFALSE 4338
// SaveVariable ( true , BrownIn07 ) ;
4328: LD_INT 1
4330: PPUSH
4331: LD_STRING BrownIn07
4333: PPUSH
4334: CALL_OW 39
// end ; if Donaldson then
4338: LD_EXP 13
4342: IFFALSE 4384
// begin SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
4344: LD_EXP 13
4348: PPUSH
4349: LD_EXP 5
4353: PUSH
4354: LD_STRING Donaldson
4356: STR
4357: PPUSH
4358: CALL_OW 38
// if Donaldson in save_group then
4362: LD_EXP 13
4366: PUSH
4367: LD_EXP 4
4371: IN
4372: IFFALSE 4384
// SaveVariable ( true , DonaldsonIn07 ) ;
4374: LD_INT 1
4376: PPUSH
4377: LD_STRING DonaldsonIn07
4379: PPUSH
4380: CALL_OW 39
// end ; if Gladstone then
4384: LD_EXP 8
4388: IFFALSE 4430
// begin SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
4390: LD_EXP 8
4394: PPUSH
4395: LD_EXP 5
4399: PUSH
4400: LD_STRING Gladstone
4402: STR
4403: PPUSH
4404: CALL_OW 38
// if Gladstone in save_group then
4408: LD_EXP 8
4412: PUSH
4413: LD_EXP 4
4417: IN
4418: IFFALSE 4430
// SaveVariable ( true , GladstoneIn07 ) ;
4420: LD_INT 1
4422: PPUSH
4423: LD_STRING GladstoneIn07
4425: PPUSH
4426: CALL_OW 39
// end ; if Khatam then
4430: LD_EXP 16
4434: IFFALSE 4476
// begin SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
4436: LD_EXP 16
4440: PPUSH
4441: LD_EXP 5
4445: PUSH
4446: LD_STRING Khatam
4448: STR
4449: PPUSH
4450: CALL_OW 38
// if Khatam in save_group then
4454: LD_EXP 16
4458: PUSH
4459: LD_EXP 4
4463: IN
4464: IFFALSE 4476
// SaveVariable ( true , KhatamIn07 ) ;
4466: LD_INT 1
4468: PPUSH
4469: LD_STRING KhatamIn07
4471: PPUSH
4472: CALL_OW 39
// end ; if debug then
4476: LD_EXP 1
4480: IFFALSE 4486
// InGameOff ;
4482: CALL_OW 9
// ToLua ( enableBioCharacter(BIO_HARR) ) ;
4486: LD_STRING enableBioCharacter(BIO_HARR)
4488: PPUSH
4489: CALL_OW 559
// ChangeMap ( 1 , %_cont ) ;
4493: LD_INT 1
4495: PPUSH
4496: LD_STRING %_cont
4498: PPUSH
4499: CALL_OW 340
// end ; end_of_file
4503: LD_VAR 0 1
4507: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
4508: LD_INT 0
4510: PPUSH
4511: PPUSH
// if exist_mode then
4512: LD_VAR 0 2
4516: IFFALSE 4541
// unit := CreateCharacter ( prefix & ident ) else
4518: LD_ADDR_VAR 0 5
4522: PUSH
4523: LD_VAR 0 3
4527: PUSH
4528: LD_VAR 0 1
4532: STR
4533: PPUSH
4534: CALL_OW 34
4538: ST_TO_ADDR
4539: GO 4556
// unit := NewCharacter ( ident ) ;
4541: LD_ADDR_VAR 0 5
4545: PUSH
4546: LD_VAR 0 1
4550: PPUSH
4551: CALL_OW 25
4555: ST_TO_ADDR
// result := unit ;
4556: LD_ADDR_VAR 0 4
4560: PUSH
4561: LD_VAR 0 5
4565: ST_TO_ADDR
// end ;
4566: LD_VAR 0 4
4570: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
4571: LD_INT 0
4573: PPUSH
// uc_side := side ;
4574: LD_ADDR_OWVAR 20
4578: PUSH
4579: LD_VAR 0 1
4583: ST_TO_ADDR
// uc_nation := nation ;
4584: LD_ADDR_OWVAR 21
4588: PUSH
4589: LD_VAR 0 2
4593: ST_TO_ADDR
// vc_chassis := chassis ;
4594: LD_ADDR_OWVAR 37
4598: PUSH
4599: LD_VAR 0 3
4603: ST_TO_ADDR
// vc_engine := engine ;
4604: LD_ADDR_OWVAR 39
4608: PUSH
4609: LD_VAR 0 4
4613: ST_TO_ADDR
// vc_control := control ;
4614: LD_ADDR_OWVAR 38
4618: PUSH
4619: LD_VAR 0 5
4623: ST_TO_ADDR
// vc_weapon := weapon ;
4624: LD_ADDR_OWVAR 40
4628: PUSH
4629: LD_VAR 0 6
4633: ST_TO_ADDR
// vc_fuel_battery := fuel ;
4634: LD_ADDR_OWVAR 41
4638: PUSH
4639: LD_VAR 0 7
4643: ST_TO_ADDR
// result := CreateVehicle ;
4644: LD_ADDR_VAR 0 8
4648: PUSH
4649: CALL_OW 45
4653: ST_TO_ADDR
// end ;
4654: LD_VAR 0 8
4658: RET
// export function SayX ( units , ident ) ; var i ; begin
4659: LD_INT 0
4661: PPUSH
4662: PPUSH
// result := false ;
4663: LD_ADDR_VAR 0 3
4667: PUSH
4668: LD_INT 0
4670: ST_TO_ADDR
// if not units then
4671: LD_VAR 0 1
4675: NOT
4676: IFFALSE 4680
// exit ;
4678: GO 4734
// for i in units do
4680: LD_ADDR_VAR 0 4
4684: PUSH
4685: LD_VAR 0 1
4689: PUSH
4690: FOR_IN
4691: IFFALSE 4732
// if IsOk ( i ) then
4693: LD_VAR 0 4
4697: PPUSH
4698: CALL_OW 302
4702: IFFALSE 4730
// begin Say ( i , ident ) ;
4704: LD_VAR 0 4
4708: PPUSH
4709: LD_VAR 0 2
4713: PPUSH
4714: CALL_OW 88
// result := i ;
4718: LD_ADDR_VAR 0 3
4722: PUSH
4723: LD_VAR 0 4
4727: ST_TO_ADDR
// break ;
4728: GO 4732
// end ;
4730: GO 4690
4732: POP
4733: POP
// end ;
4734: LD_VAR 0 3
4738: RET
