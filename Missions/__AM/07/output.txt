// starting begin ResetFog ;
   0: CALL_OW 335
// FogOff ( 1 ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 344
// RandomizeAll ;
  11: CALL_OW 11
// Init ;
  15: CALL 28 0 0
// PrepareAmerican ;
  19: CALL 94 0 0
// Action ;
  23: CALL 3004 0 0
// end ;
  27: END
// export debug ; export donaldson_commander , brown_commander , save_group ; export mission_prefix , mission_prefix_prev ; function Init ; begin
  28: LD_INT 0
  30: PPUSH
// debug := false ;
  31: LD_ADDR_EXP 1
  35: PUSH
  36: LD_INT 0
  38: ST_TO_ADDR
// mission_prefix := 07_ ;
  39: LD_ADDR_EXP 5
  43: PUSH
  44: LD_STRING 07_
  46: ST_TO_ADDR
// mission_prefix_prev := [ 06_ , 05_ , 04_ ] ;
  47: LD_ADDR_EXP 6
  51: PUSH
  52: LD_STRING 06_
  54: PUSH
  55: LD_STRING 05_
  57: PUSH
  58: LD_STRING 04_
  60: PUSH
  61: EMPTY
  62: LIST
  63: LIST
  64: LIST
  65: ST_TO_ADDR
// donaldson_commander := false ;
  66: LD_ADDR_EXP 2
  70: PUSH
  71: LD_INT 0
  73: ST_TO_ADDR
// brown_commander := false ;
  74: LD_ADDR_EXP 3
  78: PUSH
  79: LD_INT 0
  81: ST_TO_ADDR
// save_group := [ ] ;
  82: LD_ADDR_EXP 4
  86: PUSH
  87: EMPTY
  88: ST_TO_ADDR
// end ; end_of_file
  89: LD_VAR 0 1
  93: RET
// export JMM , Gladstone , Frank , Lisa , Cyrus , Bobby , Donaldson , Brown , Houten , Khatam , Harisson ; export gamma_commander ; export RandGuy ; export function PrepareAmerican ; var others , others_delta , others4 , veh , team , dep , bar , lab , fac , bun , filter , i , j ; begin
  94: LD_INT 0
  96: PPUSH
  97: PPUSH
  98: PPUSH
  99: PPUSH
 100: PPUSH
 101: PPUSH
 102: PPUSH
 103: PPUSH
 104: PPUSH
 105: PPUSH
 106: PPUSH
 107: PPUSH
 108: PPUSH
 109: PPUSH
// PrepareBase ;
 110: CALL 2569 0 0
// uc_side := 1 ;
 114: LD_ADDR_OWVAR 20
 118: PUSH
 119: LD_INT 1
 121: ST_TO_ADDR
// uc_nation := 1 ;
 122: LD_ADDR_OWVAR 21
 126: PUSH
 127: LD_INT 1
 129: ST_TO_ADDR
// team := [ ] ;
 130: LD_ADDR_VAR 0 6
 134: PUSH
 135: EMPTY
 136: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 06c_ ) ;
 137: LD_ADDR_EXP 7
 141: PUSH
 142: LD_STRING JMM
 144: PPUSH
 145: LD_EXP 1
 149: NOT
 150: PPUSH
 151: LD_STRING 06c_
 153: PPUSH
 154: CALL 4502 0 3
 158: ST_TO_ADDR
// if GetClass ( JMM ) = 2 then
 159: LD_EXP 7
 163: PPUSH
 164: CALL_OW 257
 168: PUSH
 169: LD_INT 2
 171: EQUAL
 172: IFFALSE 186
// SetClass ( JMM , 1 ) ;
 174: LD_EXP 7
 178: PPUSH
 179: LD_INT 1
 181: PPUSH
 182: CALL_OW 336
// gamma_commander := LoadVariable ( GammaCommander , 3 ) ;
 186: LD_ADDR_EXP 18
 190: PUSH
 191: LD_STRING GammaCommander
 193: PPUSH
 194: LD_INT 3
 196: PPUSH
 197: CALL_OW 30
 201: ST_TO_ADDR
// if gamma_commander = 1 then
 202: LD_EXP 18
 206: PUSH
 207: LD_INT 1
 209: EQUAL
 210: IFFALSE 236
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 04_ ) ;
 212: LD_ADDR_EXP 13
 216: PUSH
 217: LD_STRING Donaldson
 219: PPUSH
 220: LD_EXP 1
 224: NOT
 225: PPUSH
 226: LD_STRING 04_
 228: PPUSH
 229: CALL 4502 0 3
 233: ST_TO_ADDR
// end else
 234: GO 307
// begin if LoadVariable ( DonaldsonIn06 , 0 ) then
 236: LD_STRING DonaldsonIn06
 238: PPUSH
 239: LD_INT 0
 241: PPUSH
 242: CALL_OW 30
 246: IFFALSE 272
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 06c_ ) else
 248: LD_ADDR_EXP 13
 252: PUSH
 253: LD_STRING Donaldson
 255: PPUSH
 256: LD_EXP 1
 260: NOT
 261: PPUSH
 262: LD_STRING 06c_
 264: PPUSH
 265: CALL 4502 0 3
 269: ST_TO_ADDR
 270: GO 307
// if not LoadVariable ( DonaldsonStayInDelta , 0 ) then
 272: LD_STRING DonaldsonStayInDelta
 274: PPUSH
 275: LD_INT 0
 277: PPUSH
 278: CALL_OW 30
 282: NOT
 283: IFFALSE 307
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 04_ ) ;
 285: LD_ADDR_EXP 13
 289: PUSH
 290: LD_STRING Donaldson
 292: PPUSH
 293: LD_EXP 1
 297: NOT
 298: PPUSH
 299: LD_STRING 04_
 301: PPUSH
 302: CALL 4502 0 3
 306: ST_TO_ADDR
// end ; if Donaldson then
 307: LD_EXP 13
 311: IFFALSE 329
// team := team ^ Donaldson ;
 313: LD_ADDR_VAR 0 6
 317: PUSH
 318: LD_VAR 0 6
 322: PUSH
 323: LD_EXP 13
 327: ADD
 328: ST_TO_ADDR
// if gamma_commander = 2 then
 329: LD_EXP 18
 333: PUSH
 334: LD_INT 2
 336: EQUAL
 337: IFFALSE 363
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 04_ ) ;
 339: LD_ADDR_EXP 14
 343: PUSH
 344: LD_STRING Brown
 346: PPUSH
 347: LD_EXP 1
 351: NOT
 352: PPUSH
 353: LD_STRING 04_
 355: PPUSH
 356: CALL 4502 0 3
 360: ST_TO_ADDR
// end else
 361: GO 434
// begin if LoadVariable ( BrownIn06 , 0 ) then
 363: LD_STRING BrownIn06
 365: PPUSH
 366: LD_INT 0
 368: PPUSH
 369: CALL_OW 30
 373: IFFALSE 399
// Brown := PrepareUnit ( Brown , ( not debug ) , 06c_ ) else
 375: LD_ADDR_EXP 14
 379: PUSH
 380: LD_STRING Brown
 382: PPUSH
 383: LD_EXP 1
 387: NOT
 388: PPUSH
 389: LD_STRING 06c_
 391: PPUSH
 392: CALL 4502 0 3
 396: ST_TO_ADDR
 397: GO 434
// if not LoadVariable ( BrownStayInDelta , 0 ) then
 399: LD_STRING BrownStayInDelta
 401: PPUSH
 402: LD_INT 0
 404: PPUSH
 405: CALL_OW 30
 409: NOT
 410: IFFALSE 434
// Brown := PrepareUnit ( Brown , ( not debug ) , 04_ ) ;
 412: LD_ADDR_EXP 14
 416: PUSH
 417: LD_STRING Brown
 419: PPUSH
 420: LD_EXP 1
 424: NOT
 425: PPUSH
 426: LD_STRING 04_
 428: PPUSH
 429: CALL 4502 0 3
 433: ST_TO_ADDR
// end ; if Brown then
 434: LD_EXP 14
 438: IFFALSE 456
// team := team ^ Brown ;
 440: LD_ADDR_VAR 0 6
 444: PUSH
 445: LD_VAR 0 6
 449: PUSH
 450: LD_EXP 14
 454: ADD
 455: ST_TO_ADDR
// if gamma_commander = 3 then
 456: LD_EXP 18
 460: PUSH
 461: LD_INT 3
 463: EQUAL
 464: IFFALSE 501
// begin Houten := PrepareUnit ( VanHouten , false ,  ) ;
 466: LD_ADDR_EXP 15
 470: PUSH
 471: LD_STRING VanHouten
 473: PPUSH
 474: LD_INT 0
 476: PPUSH
 477: LD_STRING 
 479: PPUSH
 480: CALL 4502 0 3
 484: ST_TO_ADDR
// team := team ^ Houten ;
 485: LD_ADDR_VAR 0 6
 489: PUSH
 490: LD_VAR 0 6
 494: PUSH
 495: LD_EXP 15
 499: ADD
 500: ST_TO_ADDR
// end ; if LoadVariable ( GladstoneIn06 , 0 ) then
 501: LD_STRING GladstoneIn06
 503: PPUSH
 504: LD_INT 0
 506: PPUSH
 507: CALL_OW 30
 511: IFFALSE 537
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 06c_ ) else
 513: LD_ADDR_EXP 8
 517: PUSH
 518: LD_STRING Gladstone
 520: PPUSH
 521: LD_EXP 1
 525: NOT
 526: PPUSH
 527: LD_STRING 06c_
 529: PPUSH
 530: CALL 4502 0 3
 534: ST_TO_ADDR
 535: GO 571
// if LoadVariable ( GladstoneStayInDelta , 0 ) then
 537: LD_STRING GladstoneStayInDelta
 539: PPUSH
 540: LD_INT 0
 542: PPUSH
 543: CALL_OW 30
 547: IFFALSE 571
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 06_ ) ;
 549: LD_ADDR_EXP 8
 553: PUSH
 554: LD_STRING Gladstone
 556: PPUSH
 557: LD_EXP 1
 561: NOT
 562: PPUSH
 563: LD_STRING 06_
 565: PPUSH
 566: CALL 4502 0 3
 570: ST_TO_ADDR
// if Gladstone then
 571: LD_EXP 8
 575: IFFALSE 593
// team := team ^ Gladstone ;
 577: LD_ADDR_VAR 0 6
 581: PUSH
 582: LD_VAR 0 6
 586: PUSH
 587: LD_EXP 8
 591: ADD
 592: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) , 03_ ) ;
 593: LD_ADDR_EXP 16
 597: PUSH
 598: LD_STRING Khatam
 600: PPUSH
 601: LD_EXP 1
 605: NOT
 606: PPUSH
 607: LD_STRING 03_
 609: PPUSH
 610: CALL 4502 0 3
 614: ST_TO_ADDR
// if Khatam then
 615: LD_EXP 16
 619: IFFALSE 637
// team := team ^ Khatam ;
 621: LD_ADDR_VAR 0 6
 625: PUSH
 626: LD_VAR 0 6
 630: PUSH
 631: LD_EXP 16
 635: ADD
 636: ST_TO_ADDR
// if LoadVariable ( LisaIn06 , 0 ) then
 637: LD_STRING LisaIn06
 639: PPUSH
 640: LD_INT 0
 642: PPUSH
 643: CALL_OW 30
 647: IFFALSE 673
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 06c_ ) else
 649: LD_ADDR_EXP 10
 653: PUSH
 654: LD_STRING Lisa
 656: PPUSH
 657: LD_EXP 1
 661: NOT
 662: PPUSH
 663: LD_STRING 06c_
 665: PPUSH
 666: CALL 4502 0 3
 670: ST_TO_ADDR
 671: GO 708
// if not LoadVariable ( LisaStayInDelta , 0 ) then
 673: LD_STRING LisaStayInDelta
 675: PPUSH
 676: LD_INT 0
 678: PPUSH
 679: CALL_OW 30
 683: NOT
 684: IFFALSE 708
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 04_ ) ;
 686: LD_ADDR_EXP 10
 690: PUSH
 691: LD_STRING Lisa
 693: PPUSH
 694: LD_EXP 1
 698: NOT
 699: PPUSH
 700: LD_STRING 04_
 702: PPUSH
 703: CALL 4502 0 3
 707: ST_TO_ADDR
// if Lisa then
 708: LD_EXP 10
 712: IFFALSE 730
// team := team ^ Lisa ;
 714: LD_ADDR_VAR 0 6
 718: PUSH
 719: LD_VAR 0 6
 723: PUSH
 724: LD_EXP 10
 728: ADD
 729: ST_TO_ADDR
// if not Lisa then
 730: LD_EXP 10
 734: NOT
 735: IFFALSE 988
// begin if LoadVariable ( CyrusIn06 , 0 ) then
 737: LD_STRING CyrusIn06
 739: PPUSH
 740: LD_INT 0
 742: PPUSH
 743: CALL_OW 30
 747: IFFALSE 773
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 06c_ ) else
 749: LD_ADDR_EXP 11
 753: PUSH
 754: LD_STRING Cyrus
 756: PPUSH
 757: LD_EXP 1
 761: NOT
 762: PPUSH
 763: LD_STRING 06c_
 765: PPUSH
 766: CALL 4502 0 3
 770: ST_TO_ADDR
 771: GO 837
// if not LoadVariable ( CyrusStayInDelta , 0 ) then
 773: LD_STRING CyrusStayInDelta
 775: PPUSH
 776: LD_INT 0
 778: PPUSH
 779: CALL_OW 30
 783: NOT
 784: IFFALSE 837
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 04_ ) ;
 786: LD_ADDR_EXP 11
 790: PUSH
 791: LD_STRING Cyrus
 793: PPUSH
 794: LD_EXP 1
 798: NOT
 799: PPUSH
 800: LD_STRING 04_
 802: PPUSH
 803: CALL 4502 0 3
 807: ST_TO_ADDR
// if not Cyrus then
 808: LD_EXP 11
 812: NOT
 813: IFFALSE 837
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 03_ ) ;
 815: LD_ADDR_EXP 11
 819: PUSH
 820: LD_STRING Cyrus
 822: PPUSH
 823: LD_EXP 1
 827: NOT
 828: PPUSH
 829: LD_STRING 03_
 831: PPUSH
 832: CALL 4502 0 3
 836: ST_TO_ADDR
// end ; if Cyrus then
 837: LD_EXP 11
 841: IFFALSE 859
// team := team ^ Cyrus ;
 843: LD_ADDR_VAR 0 6
 847: PUSH
 848: LD_VAR 0 6
 852: PUSH
 853: LD_EXP 11
 857: ADD
 858: ST_TO_ADDR
// if not Cyrus then
 859: LD_EXP 11
 863: NOT
 864: IFFALSE 988
// begin if LoadVariable ( BobbyIn06 , 0 ) then
 866: LD_STRING BobbyIn06
 868: PPUSH
 869: LD_INT 0
 871: PPUSH
 872: CALL_OW 30
 876: IFFALSE 902
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 06c_ ) else
 878: LD_ADDR_EXP 12
 882: PUSH
 883: LD_STRING Bobby
 885: PPUSH
 886: LD_EXP 1
 890: NOT
 891: PPUSH
 892: LD_STRING 06c_
 894: PPUSH
 895: CALL 4502 0 3
 899: ST_TO_ADDR
 900: GO 966
// if not LoadVariable ( BobbyStayInDelta , 0 ) then
 902: LD_STRING BobbyStayInDelta
 904: PPUSH
 905: LD_INT 0
 907: PPUSH
 908: CALL_OW 30
 912: NOT
 913: IFFALSE 966
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 04_ ) ;
 915: LD_ADDR_EXP 12
 919: PUSH
 920: LD_STRING Bobby
 922: PPUSH
 923: LD_EXP 1
 927: NOT
 928: PPUSH
 929: LD_STRING 04_
 931: PPUSH
 932: CALL 4502 0 3
 936: ST_TO_ADDR
// if not Bobby then
 937: LD_EXP 12
 941: NOT
 942: IFFALSE 966
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 03_ ) ;
 944: LD_ADDR_EXP 12
 948: PUSH
 949: LD_STRING Bobby
 951: PPUSH
 952: LD_EXP 1
 956: NOT
 957: PPUSH
 958: LD_STRING 03_
 960: PPUSH
 961: CALL 4502 0 3
 965: ST_TO_ADDR
// end ; if Bobby then
 966: LD_EXP 12
 970: IFFALSE 988
// team := team ^ Bobby ;
 972: LD_ADDR_VAR 0 6
 976: PUSH
 977: LD_VAR 0 6
 981: PUSH
 982: LD_EXP 12
 986: ADD
 987: ST_TO_ADDR
// end ; end ; others4 := CreateCharacterSet ( othersGamma ) ;
 988: LD_ADDR_VAR 0 4
 992: PUSH
 993: LD_STRING othersGamma
 995: PPUSH
 996: CALL_OW 31
1000: ST_TO_ADDR
// others := CreateCharacterSet ( 06_other_survivors ) ;
1001: LD_ADDR_VAR 0 2
1005: PUSH
1006: LD_STRING 06_other_survivors
1008: PPUSH
1009: CALL_OW 31
1013: ST_TO_ADDR
// others := others union others4 ;
1014: LD_ADDR_VAR 0 2
1018: PUSH
1019: LD_VAR 0 2
1023: PUSH
1024: LD_VAR 0 4
1028: UNION
1029: ST_TO_ADDR
// team := team ^ others ;
1030: LD_ADDR_VAR 0 6
1034: PUSH
1035: LD_VAR 0 6
1039: PUSH
1040: LD_VAR 0 2
1044: ADD
1045: ST_TO_ADDR
// InitHc ;
1046: CALL_OW 19
// if team <= 12 then
1050: LD_VAR 0 6
1054: PUSH
1055: LD_INT 12
1057: LESSEQUAL
1058: IFFALSE 1107
// repeat PrepareHuman ( false , rand ( 1 , 4 ) , 5 ) ;
1060: LD_INT 0
1062: PPUSH
1063: LD_INT 1
1065: PPUSH
1066: LD_INT 4
1068: PPUSH
1069: CALL_OW 12
1073: PPUSH
1074: LD_INT 5
1076: PPUSH
1077: CALL_OW 380
// team := team ^ CreateHuman ;
1081: LD_ADDR_VAR 0 6
1085: PUSH
1086: LD_VAR 0 6
1090: PUSH
1091: CALL_OW 44
1095: ADD
1096: ST_TO_ADDR
// until team > 12 ;
1097: LD_VAR 0 6
1101: PUSH
1102: LD_INT 12
1104: GREATER
1105: IFFALSE 1060
// for i in others do
1107: LD_ADDR_VAR 0 13
1111: PUSH
1112: LD_VAR 0 2
1116: PUSH
1117: FOR_IN
1118: IFFALSE 1186
// begin if GetClass ( i ) = 2 then
1120: LD_VAR 0 13
1124: PPUSH
1125: CALL_OW 257
1129: PUSH
1130: LD_INT 2
1132: EQUAL
1133: IFFALSE 1147
// SetClass ( i , 1 ) ;
1135: LD_VAR 0 13
1139: PPUSH
1140: LD_INT 1
1142: PPUSH
1143: CALL_OW 336
// for j = 1 to 4 do
1147: LD_ADDR_VAR 0 14
1151: PUSH
1152: DOUBLE
1153: LD_INT 1
1155: DEC
1156: ST_TO_ADDR
1157: LD_INT 4
1159: PUSH
1160: FOR_TO
1161: IFFALSE 1182
// AddExperience ( i , j , 3000 ) ;
1163: LD_VAR 0 13
1167: PPUSH
1168: LD_VAR 0 14
1172: PPUSH
1173: LD_INT 3000
1175: PPUSH
1176: CALL_OW 492
1180: GO 1160
1182: POP
1183: POP
// end ;
1184: GO 1117
1186: POP
1187: POP
// if UnitFilter ( team , [ f_class , 2 ] ) then
1188: LD_VAR 0 6
1192: PPUSH
1193: LD_INT 25
1195: PUSH
1196: LD_INT 2
1198: PUSH
1199: EMPTY
1200: LIST
1201: LIST
1202: PPUSH
1203: CALL_OW 72
1207: IFFALSE 1253
// for i in UnitFilter ( team , [ f_class , 2 ] ) do
1209: LD_ADDR_VAR 0 13
1213: PUSH
1214: LD_VAR 0 6
1218: PPUSH
1219: LD_INT 25
1221: PUSH
1222: LD_INT 2
1224: PUSH
1225: EMPTY
1226: LIST
1227: LIST
1228: PPUSH
1229: CALL_OW 72
1233: PUSH
1234: FOR_IN
1235: IFFALSE 1251
// SetClass ( i , 1 ) ;
1237: LD_VAR 0 13
1241: PPUSH
1242: LD_INT 1
1244: PPUSH
1245: CALL_OW 336
1249: GO 1234
1251: POP
1252: POP
// dep := FilterAllUnits ( [ f_btype , b_depot ] ) ;
1253: LD_ADDR_VAR 0 7
1257: PUSH
1258: LD_INT 30
1260: PUSH
1261: LD_INT 0
1263: PUSH
1264: EMPTY
1265: LIST
1266: LIST
1267: PPUSH
1268: CALL_OW 69
1272: ST_TO_ADDR
// bar := FilterAllUnits ( [ f_btype , b_armoury ] ) ;
1273: LD_ADDR_VAR 0 8
1277: PUSH
1278: LD_INT 30
1280: PUSH
1281: LD_INT 4
1283: PUSH
1284: EMPTY
1285: LIST
1286: LIST
1287: PPUSH
1288: CALL_OW 69
1292: ST_TO_ADDR
// lab := FilterAllUnits ( [ f_or , [ f_btype , b_lab_half ] , [ f_btype , b_lab ] ] ) ;
1293: LD_ADDR_VAR 0 9
1297: PUSH
1298: LD_INT 2
1300: PUSH
1301: LD_INT 30
1303: PUSH
1304: LD_INT 7
1306: PUSH
1307: EMPTY
1308: LIST
1309: LIST
1310: PUSH
1311: LD_INT 30
1313: PUSH
1314: LD_INT 6
1316: PUSH
1317: EMPTY
1318: LIST
1319: LIST
1320: PUSH
1321: EMPTY
1322: LIST
1323: LIST
1324: LIST
1325: PPUSH
1326: CALL_OW 69
1330: ST_TO_ADDR
// fac := FilterAllUnits ( [ f_btype , b_factory ] ) ;
1331: LD_ADDR_VAR 0 10
1335: PUSH
1336: LD_INT 30
1338: PUSH
1339: LD_INT 3
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: PPUSH
1346: CALL_OW 69
1350: ST_TO_ADDR
// bun := FilterAllUnits ( [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ;
1351: LD_ADDR_VAR 0 11
1355: PUSH
1356: LD_INT 2
1358: PUSH
1359: LD_INT 30
1361: PUSH
1362: LD_INT 32
1364: PUSH
1365: EMPTY
1366: LIST
1367: LIST
1368: PUSH
1369: LD_INT 30
1371: PUSH
1372: LD_INT 31
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: PUSH
1379: EMPTY
1380: LIST
1381: LIST
1382: LIST
1383: PPUSH
1384: CALL_OW 69
1388: ST_TO_ADDR
// SetBName ( dep , Gamma ) ;
1389: LD_VAR 0 7
1393: PPUSH
1394: LD_STRING Gamma
1396: PPUSH
1397: CALL_OW 500
// SetResourceType ( GetBase ( dep ) , mat_oil , 10000 ) ;
1401: LD_VAR 0 7
1405: PPUSH
1406: CALL_OW 274
1410: PPUSH
1411: LD_INT 2
1413: PPUSH
1414: LD_INT 10000
1416: PPUSH
1417: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_cans , 10000 ) ;
1421: LD_VAR 0 7
1425: PPUSH
1426: CALL_OW 274
1430: PPUSH
1431: LD_INT 1
1433: PPUSH
1434: LD_INT 10000
1436: PPUSH
1437: CALL_OW 277
// if dep then
1441: LD_VAR 0 7
1445: IFFALSE 1547
// begin PlaceHumanInUnit ( JMM , dep [ 1 ] ) ;
1447: LD_EXP 7
1451: PPUSH
1452: LD_VAR 0 7
1456: PUSH
1457: LD_INT 1
1459: ARRAY
1460: PPUSH
1461: CALL_OW 52
// if Brown then
1465: LD_EXP 14
1469: IFFALSE 1505
// begin PlaceHumanInUnit ( Brown , dep [ 1 ] ) ;
1471: LD_EXP 14
1475: PPUSH
1476: LD_VAR 0 7
1480: PUSH
1481: LD_INT 1
1483: ARRAY
1484: PPUSH
1485: CALL_OW 52
// team := team diff Brown ;
1489: LD_ADDR_VAR 0 6
1493: PUSH
1494: LD_VAR 0 6
1498: PUSH
1499: LD_EXP 14
1503: DIFF
1504: ST_TO_ADDR
// end ; if Donaldson then
1505: LD_EXP 13
1509: IFFALSE 1545
// begin PlaceHumanInUnit ( Donaldson , dep [ 1 ] ) ;
1511: LD_EXP 13
1515: PPUSH
1516: LD_VAR 0 7
1520: PUSH
1521: LD_INT 1
1523: ARRAY
1524: PPUSH
1525: CALL_OW 52
// team := team diff Donaldson ;
1529: LD_ADDR_VAR 0 6
1533: PUSH
1534: LD_VAR 0 6
1538: PUSH
1539: LD_EXP 13
1543: DIFF
1544: ST_TO_ADDR
// end ; end else
1545: GO 1654
// begin PlaceUnitXYR ( JMM , 52 , 16 , 10 , false ) ;
1547: LD_EXP 7
1551: PPUSH
1552: LD_INT 52
1554: PPUSH
1555: LD_INT 16
1557: PPUSH
1558: LD_INT 10
1560: PPUSH
1561: LD_INT 0
1563: PPUSH
1564: CALL_OW 50
// if Brown then
1568: LD_EXP 14
1572: IFFALSE 1611
// begin PlaceUnitXYR ( Brown , 52 , 16 , 10 , false ) ;
1574: LD_EXP 14
1578: PPUSH
1579: LD_INT 52
1581: PPUSH
1582: LD_INT 16
1584: PPUSH
1585: LD_INT 10
1587: PPUSH
1588: LD_INT 0
1590: PPUSH
1591: CALL_OW 50
// team := team diff Brown ;
1595: LD_ADDR_VAR 0 6
1599: PUSH
1600: LD_VAR 0 6
1604: PUSH
1605: LD_EXP 14
1609: DIFF
1610: ST_TO_ADDR
// end ; if Donaldson then
1611: LD_EXP 13
1615: IFFALSE 1654
// begin PlaceUnitXYR ( Donaldson , 52 , 16 , 10 , false ) ;
1617: LD_EXP 13
1621: PPUSH
1622: LD_INT 52
1624: PPUSH
1625: LD_INT 16
1627: PPUSH
1628: LD_INT 10
1630: PPUSH
1631: LD_INT 0
1633: PPUSH
1634: CALL_OW 50
// team := team diff Donaldson ;
1638: LD_ADDR_VAR 0 6
1642: PUSH
1643: LD_VAR 0 6
1647: PUSH
1648: LD_EXP 13
1652: DIFF
1653: ST_TO_ADDR
// end ; end ; if bun and UnitFilter ( team , [ f_class , 1 ] ) then
1654: LD_VAR 0 11
1658: IFFALSE 1681
1660: PUSH
1661: LD_VAR 0 6
1665: PPUSH
1666: LD_INT 25
1668: PUSH
1669: LD_INT 1
1671: PUSH
1672: EMPTY
1673: LIST
1674: LIST
1675: PPUSH
1676: CALL_OW 72
1680: AND
1681: IFFALSE 1790
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
1683: LD_ADDR_VAR 0 12
1687: PUSH
1688: LD_VAR 0 6
1692: PPUSH
1693: LD_INT 25
1695: PUSH
1696: LD_INT 1
1698: PUSH
1699: EMPTY
1700: LIST
1701: LIST
1702: PPUSH
1703: CALL_OW 72
1707: ST_TO_ADDR
// for i in bun do
1708: LD_ADDR_VAR 0 13
1712: PUSH
1713: LD_VAR 0 11
1717: PUSH
1718: FOR_IN
1719: IFFALSE 1788
// begin if not filter then
1721: LD_VAR 0 12
1725: NOT
1726: IFFALSE 1730
// break ;
1728: GO 1788
// PlaceHumanInUnit ( filter [ 1 ] , i ) ;
1730: LD_VAR 0 12
1734: PUSH
1735: LD_INT 1
1737: ARRAY
1738: PPUSH
1739: LD_VAR 0 13
1743: PPUSH
1744: CALL_OW 52
// team := team diff filter [ 1 ] ;
1748: LD_ADDR_VAR 0 6
1752: PUSH
1753: LD_VAR 0 6
1757: PUSH
1758: LD_VAR 0 12
1762: PUSH
1763: LD_INT 1
1765: ARRAY
1766: DIFF
1767: ST_TO_ADDR
// filter := Delete ( filter , 1 ) ;
1768: LD_ADDR_VAR 0 12
1772: PUSH
1773: LD_VAR 0 12
1777: PPUSH
1778: LD_INT 1
1780: PPUSH
1781: CALL_OW 3
1785: ST_TO_ADDR
// end ;
1786: GO 1718
1788: POP
1789: POP
// end ; if bar and UnitFilter ( team , [ f_class , 1 ] ) then
1790: LD_VAR 0 8
1794: IFFALSE 1817
1796: PUSH
1797: LD_VAR 0 6
1801: PPUSH
1802: LD_INT 25
1804: PUSH
1805: LD_INT 1
1807: PUSH
1808: EMPTY
1809: LIST
1810: LIST
1811: PPUSH
1812: CALL_OW 72
1816: AND
1817: IFFALSE 1939
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
1819: LD_ADDR_VAR 0 12
1823: PUSH
1824: LD_VAR 0 6
1828: PPUSH
1829: LD_INT 25
1831: PUSH
1832: LD_INT 1
1834: PUSH
1835: EMPTY
1836: LIST
1837: LIST
1838: PPUSH
1839: CALL_OW 72
1843: ST_TO_ADDR
// for i = 1 to filter do
1844: LD_ADDR_VAR 0 13
1848: PUSH
1849: DOUBLE
1850: LD_INT 1
1852: DEC
1853: ST_TO_ADDR
1854: LD_VAR 0 12
1858: PUSH
1859: FOR_TO
1860: IFFALSE 1921
// begin if ( i <= 6 ) then
1862: LD_VAR 0 13
1866: PUSH
1867: LD_INT 6
1869: LESSEQUAL
1870: IFFALSE 1898
// PlaceHumanInUnit ( filter [ i ] , bar [ 1 ] ) else
1872: LD_VAR 0 12
1876: PUSH
1877: LD_VAR 0 13
1881: ARRAY
1882: PPUSH
1883: LD_VAR 0 8
1887: PUSH
1888: LD_INT 1
1890: ARRAY
1891: PPUSH
1892: CALL_OW 52
1896: GO 1919
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1898: LD_VAR 0 12
1902: PUSH
1903: LD_VAR 0 13
1907: ARRAY
1908: PPUSH
1909: LD_INT 1
1911: PPUSH
1912: LD_INT 0
1914: PPUSH
1915: CALL_OW 49
// end ;
1919: GO 1859
1921: POP
1922: POP
// team := team diff filter ;
1923: LD_ADDR_VAR 0 6
1927: PUSH
1928: LD_VAR 0 6
1932: PUSH
1933: LD_VAR 0 12
1937: DIFF
1938: ST_TO_ADDR
// end ; if lab and UnitFilter ( team , [ f_class , 4 ] ) then
1939: LD_VAR 0 9
1943: IFFALSE 1966
1945: PUSH
1946: LD_VAR 0 6
1950: PPUSH
1951: LD_INT 25
1953: PUSH
1954: LD_INT 4
1956: PUSH
1957: EMPTY
1958: LIST
1959: LIST
1960: PPUSH
1961: CALL_OW 72
1965: AND
1966: IFFALSE 2088
// begin filter := UnitFilter ( team , [ f_class , 4 ] ) ;
1968: LD_ADDR_VAR 0 12
1972: PUSH
1973: LD_VAR 0 6
1977: PPUSH
1978: LD_INT 25
1980: PUSH
1981: LD_INT 4
1983: PUSH
1984: EMPTY
1985: LIST
1986: LIST
1987: PPUSH
1988: CALL_OW 72
1992: ST_TO_ADDR
// for i = 1 to filter do
1993: LD_ADDR_VAR 0 13
1997: PUSH
1998: DOUBLE
1999: LD_INT 1
2001: DEC
2002: ST_TO_ADDR
2003: LD_VAR 0 12
2007: PUSH
2008: FOR_TO
2009: IFFALSE 2070
// begin if ( i <= 6 ) then
2011: LD_VAR 0 13
2015: PUSH
2016: LD_INT 6
2018: LESSEQUAL
2019: IFFALSE 2047
// PlaceHumanInUnit ( filter [ i ] , lab [ 1 ] ) else
2021: LD_VAR 0 12
2025: PUSH
2026: LD_VAR 0 13
2030: ARRAY
2031: PPUSH
2032: LD_VAR 0 9
2036: PUSH
2037: LD_INT 1
2039: ARRAY
2040: PPUSH
2041: CALL_OW 52
2045: GO 2068
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
2047: LD_VAR 0 12
2051: PUSH
2052: LD_VAR 0 13
2056: ARRAY
2057: PPUSH
2058: LD_INT 1
2060: PPUSH
2061: LD_INT 0
2063: PPUSH
2064: CALL_OW 49
// end ;
2068: GO 2008
2070: POP
2071: POP
// team := team diff filter ;
2072: LD_ADDR_VAR 0 6
2076: PUSH
2077: LD_VAR 0 6
2081: PUSH
2082: LD_VAR 0 12
2086: DIFF
2087: ST_TO_ADDR
// end ; if fac and UnitFilter ( team , [ f_class , 3 ] ) then
2088: LD_VAR 0 10
2092: IFFALSE 2115
2094: PUSH
2095: LD_VAR 0 6
2099: PPUSH
2100: LD_INT 25
2102: PUSH
2103: LD_INT 3
2105: PUSH
2106: EMPTY
2107: LIST
2108: LIST
2109: PPUSH
2110: CALL_OW 72
2114: AND
2115: IFFALSE 2237
// begin filter := UnitFilter ( team , [ f_class , 3 ] ) ;
2117: LD_ADDR_VAR 0 12
2121: PUSH
2122: LD_VAR 0 6
2126: PPUSH
2127: LD_INT 25
2129: PUSH
2130: LD_INT 3
2132: PUSH
2133: EMPTY
2134: LIST
2135: LIST
2136: PPUSH
2137: CALL_OW 72
2141: ST_TO_ADDR
// for i = 1 to filter do
2142: LD_ADDR_VAR 0 13
2146: PUSH
2147: DOUBLE
2148: LD_INT 1
2150: DEC
2151: ST_TO_ADDR
2152: LD_VAR 0 12
2156: PUSH
2157: FOR_TO
2158: IFFALSE 2219
// begin if ( i <= 6 ) then
2160: LD_VAR 0 13
2164: PUSH
2165: LD_INT 6
2167: LESSEQUAL
2168: IFFALSE 2196
// PlaceHumanInUnit ( filter [ i ] , fac [ 1 ] ) else
2170: LD_VAR 0 12
2174: PUSH
2175: LD_VAR 0 13
2179: ARRAY
2180: PPUSH
2181: LD_VAR 0 10
2185: PUSH
2186: LD_INT 1
2188: ARRAY
2189: PPUSH
2190: CALL_OW 52
2194: GO 2217
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
2196: LD_VAR 0 12
2200: PUSH
2201: LD_VAR 0 13
2205: ARRAY
2206: PPUSH
2207: LD_INT 1
2209: PPUSH
2210: LD_INT 0
2212: PPUSH
2213: CALL_OW 49
// end ;
2217: GO 2157
2219: POP
2220: POP
// team := team diff filter ;
2221: LD_ADDR_VAR 0 6
2225: PUSH
2226: LD_VAR 0 6
2230: PUSH
2231: LD_VAR 0 12
2235: DIFF
2236: ST_TO_ADDR
// end ; if team then
2237: LD_VAR 0 6
2241: IFFALSE 2284
// for i in team do
2243: LD_ADDR_VAR 0 13
2247: PUSH
2248: LD_VAR 0 6
2252: PUSH
2253: FOR_IN
2254: IFFALSE 2282
// begin PlaceUnitArea ( i , gammaBaseArea , false ) ;
2256: LD_VAR 0 13
2260: PPUSH
2261: LD_INT 1
2263: PPUSH
2264: LD_INT 0
2266: PPUSH
2267: CALL_OW 49
// ComHold ( i ) ;
2271: LD_VAR 0 13
2275: PPUSH
2276: CALL_OW 140
// end ;
2280: GO 2253
2282: POP
2283: POP
// if fac then
2284: LD_VAR 0 10
2288: IFFALSE 2324
// if UnitsInside ( fac [ 1 ] ) then
2290: LD_VAR 0 10
2294: PUSH
2295: LD_INT 1
2297: ARRAY
2298: PPUSH
2299: CALL_OW 313
2303: IFFALSE 2324
// SetSpecResearch ( fac [ 1 ] , 10 , false ) ;
2305: LD_VAR 0 10
2309: PUSH
2310: LD_INT 1
2312: ARRAY
2313: PPUSH
2314: LD_INT 10
2316: PPUSH
2317: LD_INT 0
2319: PPUSH
2320: CALL_OW 486
// if lab then
2324: LD_VAR 0 9
2328: IFFALSE 2364
// if UnitsInside ( lab [ 1 ] ) then
2330: LD_VAR 0 9
2334: PUSH
2335: LD_INT 1
2337: ARRAY
2338: PPUSH
2339: CALL_OW 313
2343: IFFALSE 2364
// SetSpecResearch ( lab [ 1 ] , 10 , false ) ;
2345: LD_VAR 0 9
2349: PUSH
2350: LD_INT 1
2352: ARRAY
2353: PPUSH
2354: LD_INT 10
2356: PPUSH
2357: LD_INT 0
2359: PPUSH
2360: CALL_OW 486
// uc_side := 4 ;
2364: LD_ADDR_OWVAR 20
2368: PUSH
2369: LD_INT 4
2371: ST_TO_ADDR
// Harisson := PrepareUnit ( Harisson , false ,  ) ;
2372: LD_ADDR_EXP 17
2376: PUSH
2377: LD_STRING Harisson
2379: PPUSH
2380: LD_INT 0
2382: PPUSH
2383: LD_STRING 
2385: PPUSH
2386: CALL 4502 0 3
2390: ST_TO_ADDR
// veh := PrepareTank ( 4 , 1 , us_medium_wheeled , engine_combustion , control_manual , us_double_gun , 100 ) ;
2391: LD_ADDR_VAR 0 5
2395: PUSH
2396: LD_INT 4
2398: PPUSH
2399: LD_INT 1
2401: PPUSH
2402: LD_INT 2
2404: PPUSH
2405: LD_INT 1
2407: PPUSH
2408: LD_INT 1
2410: PPUSH
2411: LD_INT 5
2413: PPUSH
2414: LD_INT 100
2416: PPUSH
2417: CALL 4565 0 7
2421: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
2422: LD_VAR 0 5
2426: PPUSH
2427: LD_INT 2
2429: PPUSH
2430: CALL_OW 233
// PlaceUnitXY ( veh , 22 , 9 , false ) ;
2434: LD_VAR 0 5
2438: PPUSH
2439: LD_INT 22
2441: PPUSH
2442: LD_INT 9
2444: PPUSH
2445: LD_INT 0
2447: PPUSH
2448: CALL_OW 48
// PlaceHumanInUnit ( Harisson , veh ) ;
2452: LD_EXP 17
2456: PPUSH
2457: LD_VAR 0 5
2461: PPUSH
2462: CALL_OW 52
// PrepareHuman ( false , 1 , 0 ) ;
2466: LD_INT 0
2468: PPUSH
2469: LD_INT 1
2471: PPUSH
2472: LD_INT 0
2474: PPUSH
2475: CALL_OW 380
// RandGuy := CreateHuman ;
2479: LD_ADDR_EXP 19
2483: PUSH
2484: CALL_OW 44
2488: ST_TO_ADDR
// veh := PrepareTank ( 4 , 1 , us_medium_wheeled , engine_combustion , control_manual , us_gatling_gun , 100 ) ;
2489: LD_ADDR_VAR 0 5
2493: PUSH
2494: LD_INT 4
2496: PPUSH
2497: LD_INT 1
2499: PPUSH
2500: LD_INT 2
2502: PPUSH
2503: LD_INT 1
2505: PPUSH
2506: LD_INT 1
2508: PPUSH
2509: LD_INT 4
2511: PPUSH
2512: LD_INT 100
2514: PPUSH
2515: CALL 4565 0 7
2519: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
2520: LD_VAR 0 5
2524: PPUSH
2525: LD_INT 2
2527: PPUSH
2528: CALL_OW 233
// PlaceUnitXY ( veh , 17 , 4 , false ) ;
2532: LD_VAR 0 5
2536: PPUSH
2537: LD_INT 17
2539: PPUSH
2540: LD_INT 4
2542: PPUSH
2543: LD_INT 0
2545: PPUSH
2546: CALL_OW 48
// PlaceHumanInUnit ( RandGuy , veh ) ;
2550: LD_EXP 19
2554: PPUSH
2555: LD_VAR 0 5
2559: PPUSH
2560: CALL_OW 52
// end ;
2564: LD_VAR 0 1
2568: RET
// function PrepareBase ; var blist , i , b , base ; begin
2569: LD_INT 0
2571: PPUSH
2572: PPUSH
2573: PPUSH
2574: PPUSH
2575: PPUSH
// SetResourceVisibility ( 71 , 5 , 1 ) ;
2576: LD_INT 71
2578: PPUSH
2579: LD_INT 5
2581: PPUSH
2582: LD_INT 1
2584: PPUSH
2585: CALL_OW 441
// blist := LoadVariable ( GammaBase , [ ] ) ;
2589: LD_ADDR_VAR 0 2
2593: PUSH
2594: LD_STRING GammaBase
2596: PPUSH
2597: EMPTY
2598: PPUSH
2599: CALL_OW 30
2603: ST_TO_ADDR
// if not blist then
2604: LD_VAR 0 2
2608: NOT
2609: IFFALSE 2649
// blist := [ [ b_depot , 52 , 12 , 3 , 3 , 0 , 0 ] ] ;
2611: LD_ADDR_VAR 0 2
2615: PUSH
2616: LD_INT 0
2618: PUSH
2619: LD_INT 52
2621: PUSH
2622: LD_INT 12
2624: PUSH
2625: LD_INT 3
2627: PUSH
2628: LD_INT 3
2630: PUSH
2631: LD_INT 0
2633: PUSH
2634: LD_INT 0
2636: PUSH
2637: EMPTY
2638: LIST
2639: LIST
2640: LIST
2641: LIST
2642: LIST
2643: LIST
2644: LIST
2645: PUSH
2646: EMPTY
2647: LIST
2648: ST_TO_ADDR
// uc_side := 1 ;
2649: LD_ADDR_OWVAR 20
2653: PUSH
2654: LD_INT 1
2656: ST_TO_ADDR
// uc_nation := 1 ;
2657: LD_ADDR_OWVAR 21
2661: PUSH
2662: LD_INT 1
2664: ST_TO_ADDR
// for i in blist do
2665: LD_ADDR_VAR 0 3
2669: PUSH
2670: LD_VAR 0 2
2674: PUSH
2675: FOR_IN
2676: IFFALSE 2863
// begin InitBc ;
2678: CALL_OW 21
// bc_type := i [ 1 ] ;
2682: LD_ADDR_OWVAR 42
2686: PUSH
2687: LD_VAR 0 3
2691: PUSH
2692: LD_INT 1
2694: ARRAY
2695: ST_TO_ADDR
// bc_level := i [ 5 ] ;
2696: LD_ADDR_OWVAR 43
2700: PUSH
2701: LD_VAR 0 3
2705: PUSH
2706: LD_INT 5
2708: ARRAY
2709: ST_TO_ADDR
// bc_kind1 := b_lab_basic ;
2710: LD_ADDR_OWVAR 44
2714: PUSH
2715: LD_INT 9
2717: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
2718: LD_ADDR_OWVAR 45
2722: PUSH
2723: LD_INT 9
2725: ST_TO_ADDR
// if i [ 1 ] in [ b_lab_half , b_lab_full ] then
2726: LD_VAR 0 3
2730: PUSH
2731: LD_INT 1
2733: ARRAY
2734: PUSH
2735: LD_INT 7
2737: PUSH
2738: LD_INT 8
2740: PUSH
2741: EMPTY
2742: LIST
2743: LIST
2744: IN
2745: IFFALSE 2791
// begin bc_kind1 := i [ 7 ] ;
2747: LD_ADDR_OWVAR 44
2751: PUSH
2752: LD_VAR 0 3
2756: PUSH
2757: LD_INT 7
2759: ARRAY
2760: ST_TO_ADDR
// if LoadVariable ( 06_remoteVehs_1 , 0 ) then
2761: LD_STRING 06_remoteVehs_1
2763: PPUSH
2764: LD_INT 0
2766: PPUSH
2767: CALL_OW 30
2771: IFFALSE 2783
// bc_kind2 := b_lab_opto else
2773: LD_ADDR_OWVAR 45
2777: PUSH
2778: LD_INT 15
2780: ST_TO_ADDR
2781: GO 2791
// bc_kind2 := b_lab_basic ;
2783: LD_ADDR_OWVAR 45
2787: PUSH
2788: LD_INT 9
2790: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
2791: LD_ADDR_VAR 0 4
2795: PUSH
2796: LD_VAR 0 3
2800: PUSH
2801: LD_INT 2
2803: ARRAY
2804: PPUSH
2805: LD_VAR 0 3
2809: PUSH
2810: LD_INT 3
2812: ARRAY
2813: PPUSH
2814: LD_VAR 0 3
2818: PUSH
2819: LD_INT 4
2821: ARRAY
2822: PPUSH
2823: CALL_OW 47
2827: ST_TO_ADDR
// if GetBType ( b ) = b_bunker then
2828: LD_VAR 0 4
2832: PPUSH
2833: CALL_OW 266
2837: PUSH
2838: LD_INT 32
2840: EQUAL
2841: IFFALSE 2861
// begin PlaceWeaponTurret ( b , i [ 7 ] ) ;
2843: LD_VAR 0 4
2847: PPUSH
2848: LD_VAR 0 3
2852: PUSH
2853: LD_INT 7
2855: ARRAY
2856: PPUSH
2857: CALL_OW 431
// end ; end ;
2861: GO 2675
2863: POP
2864: POP
// if not FilterAllUnits ( [ f_btype , b_depot ] ) then
2865: LD_INT 30
2867: PUSH
2868: LD_INT 0
2870: PUSH
2871: EMPTY
2872: LIST
2873: LIST
2874: PPUSH
2875: CALL_OW 69
2879: NOT
2880: IFFALSE 2917
// begin bc_type := b_depot ;
2882: LD_ADDR_OWVAR 42
2886: PUSH
2887: LD_INT 0
2889: ST_TO_ADDR
// bc_level := 6 ;
2890: LD_ADDR_OWVAR 43
2894: PUSH
2895: LD_INT 6
2897: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 52 , 12 , 3 ) ;
2898: LD_ADDR_VAR 0 4
2902: PUSH
2903: LD_INT 52
2905: PPUSH
2906: LD_INT 12
2908: PPUSH
2909: LD_INT 3
2911: PPUSH
2912: CALL_OW 47
2916: ST_TO_ADDR
// end ; base := GetBase ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) [ 1 ] ) ;
2917: LD_ADDR_VAR 0 5
2921: PUSH
2922: LD_INT 22
2924: PUSH
2925: LD_INT 1
2927: PUSH
2928: EMPTY
2929: LIST
2930: LIST
2931: PUSH
2932: LD_INT 2
2934: PUSH
2935: LD_INT 30
2937: PUSH
2938: LD_INT 0
2940: PUSH
2941: EMPTY
2942: LIST
2943: LIST
2944: PUSH
2945: LD_INT 30
2947: PUSH
2948: LD_INT 1
2950: PUSH
2951: EMPTY
2952: LIST
2953: LIST
2954: PUSH
2955: EMPTY
2956: LIST
2957: LIST
2958: LIST
2959: PUSH
2960: EMPTY
2961: LIST
2962: LIST
2963: PPUSH
2964: CALL_OW 69
2968: PUSH
2969: LD_INT 1
2971: ARRAY
2972: PPUSH
2973: CALL_OW 274
2977: ST_TO_ADDR
// if base then
2978: LD_VAR 0 5
2982: IFFALSE 2999
// SetResourceType ( base , mat_oil , 1000 ) ;
2984: LD_VAR 0 5
2988: PPUSH
2989: LD_INT 2
2991: PPUSH
2992: LD_INT 1000
2994: PPUSH
2995: CALL_OW 277
// end ; end_of_file
2999: LD_VAR 0 1
3003: RET
// export function Action ; var points , i , sol , time , team , filter ; begin
3004: LD_INT 0
3006: PPUSH
3007: PPUSH
3008: PPUSH
3009: PPUSH
3010: PPUSH
3011: PPUSH
3012: PPUSH
// InGameOn ;
3013: CALL_OW 8
// CenterNowOnXY ( 33 , 11 ) ;
3017: LD_INT 33
3019: PPUSH
3020: LD_INT 11
3022: PPUSH
3023: CALL_OW 86
// points := [ [ 29 , 21 ] , [ 41 , 28 ] , [ 52 , 26 ] , [ 49 , 16 ] ] ;
3027: LD_ADDR_VAR 0 2
3031: PUSH
3032: LD_INT 29
3034: PUSH
3035: LD_INT 21
3037: PUSH
3038: EMPTY
3039: LIST
3040: LIST
3041: PUSH
3042: LD_INT 41
3044: PUSH
3045: LD_INT 28
3047: PUSH
3048: EMPTY
3049: LIST
3050: LIST
3051: PUSH
3052: LD_INT 52
3054: PUSH
3055: LD_INT 26
3057: PUSH
3058: EMPTY
3059: LIST
3060: LIST
3061: PUSH
3062: LD_INT 49
3064: PUSH
3065: LD_INT 16
3067: PUSH
3068: EMPTY
3069: LIST
3070: LIST
3071: PUSH
3072: EMPTY
3073: LIST
3074: LIST
3075: LIST
3076: LIST
3077: ST_TO_ADDR
// sol := ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , 1 ] ] ) diff [ JMM , Brown , Cyrus , Bobby , Gladstone , Houten , Khatam ] ) [ 1 ] ;
3078: LD_ADDR_VAR 0 4
3082: PUSH
3083: LD_INT 22
3085: PUSH
3086: LD_INT 1
3088: PUSH
3089: EMPTY
3090: LIST
3091: LIST
3092: PUSH
3093: LD_INT 26
3095: PUSH
3096: LD_INT 1
3098: PUSH
3099: EMPTY
3100: LIST
3101: LIST
3102: PUSH
3103: EMPTY
3104: LIST
3105: LIST
3106: PPUSH
3107: CALL_OW 69
3111: PUSH
3112: LD_EXP 7
3116: PUSH
3117: LD_EXP 14
3121: PUSH
3122: LD_EXP 11
3126: PUSH
3127: LD_EXP 12
3131: PUSH
3132: LD_EXP 8
3136: PUSH
3137: LD_EXP 15
3141: PUSH
3142: LD_EXP 16
3146: PUSH
3147: EMPTY
3148: LIST
3149: LIST
3150: LIST
3151: LIST
3152: LIST
3153: LIST
3154: LIST
3155: DIFF
3156: PUSH
3157: LD_INT 1
3159: ARRAY
3160: ST_TO_ADDR
// if sol then
3161: LD_VAR 0 4
3165: IFFALSE 3196
// begin ComMoveXY ( sol , 50 , 18 ) ;
3167: LD_VAR 0 4
3171: PPUSH
3172: LD_INT 50
3174: PPUSH
3175: LD_INT 18
3177: PPUSH
3178: CALL_OW 111
// AddComTurnUnit ( sol , Harisson ) ;
3182: LD_VAR 0 4
3186: PPUSH
3187: LD_EXP 17
3191: PPUSH
3192: CALL_OW 179
// end ; for i in points do
3196: LD_ADDR_VAR 0 3
3200: PUSH
3201: LD_VAR 0 2
3205: PUSH
3206: FOR_IN
3207: IFFALSE 3247
// AddComMoveXY ( [ Harisson , RandGuy ] , i [ 1 ] , i [ 2 ] ) ;
3209: LD_EXP 17
3213: PUSH
3214: LD_EXP 19
3218: PUSH
3219: EMPTY
3220: LIST
3221: LIST
3222: PPUSH
3223: LD_VAR 0 3
3227: PUSH
3228: LD_INT 1
3230: ARRAY
3231: PPUSH
3232: LD_VAR 0 3
3236: PUSH
3237: LD_INT 2
3239: ARRAY
3240: PPUSH
3241: CALL_OW 171
3245: GO 3206
3247: POP
3248: POP
// AddComExitVehicle ( [ Harisson , RandGuy ] ) ;
3249: LD_EXP 17
3253: PUSH
3254: LD_EXP 19
3258: PUSH
3259: EMPTY
3260: LIST
3261: LIST
3262: PPUSH
3263: CALL_OW 181
// AddComTurnUnit ( [ Harisson , RandGuy ] , sol ) ;
3267: LD_EXP 17
3271: PUSH
3272: LD_EXP 19
3276: PUSH
3277: EMPTY
3278: LIST
3279: LIST
3280: PPUSH
3281: LD_VAR 0 4
3285: PPUSH
3286: CALL_OW 179
// time := 0 0$20 ;
3290: LD_ADDR_VAR 0 5
3294: PUSH
3295: LD_INT 700
3297: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
3298: LD_INT 10
3300: PPUSH
3301: CALL_OW 67
// time := time - 0 0$0.3 ;
3305: LD_ADDR_VAR 0 5
3309: PUSH
3310: LD_VAR 0 5
3314: PUSH
3315: LD_INT 10
3317: MINUS
3318: ST_TO_ADDR
// until not IsInUnit ( Harisson ) or time <= 0 0$00 ;
3319: LD_EXP 17
3323: PPUSH
3324: CALL_OW 310
3328: NOT
3329: IFTRUE 3341
3331: PUSH
3332: LD_VAR 0 5
3336: PUSH
3337: LD_INT 0
3339: LESSEQUAL
3340: OR
3341: IFFALSE 3298
// Say ( sol , D1-Sol1-1 ) ;
3343: LD_VAR 0 4
3347: PPUSH
3348: LD_STRING D1-Sol1-1
3350: PPUSH
3351: CALL_OW 88
// Say ( Harisson , D1-Har-1 ) ;
3355: LD_EXP 17
3359: PPUSH
3360: LD_STRING D1-Har-1
3362: PPUSH
3363: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
3367: LD_INT 10
3369: PPUSH
3370: CALL_OW 67
// ComMoveXY ( sol , 35 , 21 ) ;
3374: LD_VAR 0 4
3378: PPUSH
3379: LD_INT 35
3381: PPUSH
3382: LD_INT 21
3384: PPUSH
3385: CALL_OW 111
// ComExitBuilding ( JMM ) ;
3389: LD_EXP 7
3393: PPUSH
3394: CALL_OW 122
// AddComMoveUnit ( JMM , Harisson ) ;
3398: LD_EXP 7
3402: PPUSH
3403: LD_EXP 17
3407: PPUSH
3408: CALL_OW 172
// ComTurnUnit ( [ Harisson , RandGuy ] , JMM ) ;
3412: LD_EXP 17
3416: PUSH
3417: LD_EXP 19
3421: PUSH
3422: EMPTY
3423: LIST
3424: LIST
3425: PPUSH
3426: LD_EXP 7
3430: PPUSH
3431: CALL_OW 119
// time := 0 0$3 ;
3435: LD_ADDR_VAR 0 5
3439: PUSH
3440: LD_INT 105
3442: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3443: LD_INT 35
3445: PPUSH
3446: CALL_OW 67
// time := time - 0 0$1 ;
3450: LD_ADDR_VAR 0 5
3454: PUSH
3455: LD_VAR 0 5
3459: PUSH
3460: LD_INT 35
3462: MINUS
3463: ST_TO_ADDR
// until GetDistUnits ( JMM , Harisson ) < 4 or time = 0 0$00 ;
3464: LD_EXP 7
3468: PPUSH
3469: LD_EXP 17
3473: PPUSH
3474: CALL_OW 296
3478: PUSH
3479: LD_INT 4
3481: LESS
3482: IFTRUE 3494
3484: PUSH
3485: LD_VAR 0 5
3489: PUSH
3490: LD_INT 0
3492: EQUAL
3493: OR
3494: IFFALSE 3443
// ComTurnUnit ( JMM , Harisson ) ;
3496: LD_EXP 7
3500: PPUSH
3501: LD_EXP 17
3505: PPUSH
3506: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
3510: LD_EXP 7
3514: PPUSH
3515: LD_STRING D1-JMM-1
3517: PPUSH
3518: CALL_OW 88
// Say ( Harisson , D1-Har-2 ) ;
3522: LD_EXP 17
3526: PPUSH
3527: LD_STRING D1-Har-2
3529: PPUSH
3530: CALL_OW 88
// Say ( JMM , D1-JMM-2 ) ;
3534: LD_EXP 7
3538: PPUSH
3539: LD_STRING D1-JMM-2
3541: PPUSH
3542: CALL_OW 88
// Say ( Harisson , D1-Har-3 ) ;
3546: LD_EXP 17
3550: PPUSH
3551: LD_STRING D1-Har-3
3553: PPUSH
3554: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
3558: LD_EXP 7
3562: PPUSH
3563: LD_STRING D1-JMM-3
3565: PPUSH
3566: CALL_OW 88
// Say ( Harisson , D1-Har-4 ) ;
3570: LD_EXP 17
3574: PPUSH
3575: LD_STRING D1-Har-4
3577: PPUSH
3578: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
3582: LD_EXP 7
3586: PPUSH
3587: LD_STRING D1-JMM-4
3589: PPUSH
3590: CALL_OW 88
// Say ( Harisson , D1-Har-5 ) ;
3594: LD_EXP 17
3598: PPUSH
3599: LD_STRING D1-Har-5
3601: PPUSH
3602: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
3606: LD_EXP 7
3610: PPUSH
3611: LD_STRING D1-JMM-5
3613: PPUSH
3614: CALL_OW 88
// Say ( Harisson , D1-Har-6 ) ;
3618: LD_EXP 17
3622: PPUSH
3623: LD_STRING D1-Har-6
3625: PPUSH
3626: CALL_OW 88
// Say ( JMM , D1-JMM-6 ) ;
3630: LD_EXP 7
3634: PPUSH
3635: LD_STRING D1-JMM-6
3637: PPUSH
3638: CALL_OW 88
// EndMission ;
3642: CALL 3651 0 0
// end ;
3646: LD_VAR 0 1
3650: RET
// export function EndMission ; var commander , i , all ; begin
3651: LD_INT 0
3653: PPUSH
3654: PPUSH
3655: PPUSH
3656: PPUSH
// case gamma_commander of 1 :
3657: LD_EXP 18
3661: PUSH
3662: LD_INT 1
3664: DOUBLE
3665: EQUAL
3666: IFTRUE 3670
3668: GO 3683
3670: POP
// commander := Donaldson ; 2 :
3671: LD_ADDR_VAR 0 2
3675: PUSH
3676: LD_EXP 13
3680: ST_TO_ADDR
3681: GO 3726
3683: LD_INT 2
3685: DOUBLE
3686: EQUAL
3687: IFTRUE 3691
3689: GO 3704
3691: POP
// commander := Brown ; 3 :
3692: LD_ADDR_VAR 0 2
3696: PUSH
3697: LD_EXP 14
3701: ST_TO_ADDR
3702: GO 3726
3704: LD_INT 3
3706: DOUBLE
3707: EQUAL
3708: IFTRUE 3712
3710: GO 3725
3712: POP
// commander := Houten ; end ;
3713: LD_ADDR_VAR 0 2
3717: PUSH
3718: LD_EXP 15
3722: ST_TO_ADDR
3723: GO 3726
3725: POP
// all := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) diff [ JMM , commander ] ;
3726: LD_ADDR_VAR 0 4
3730: PUSH
3731: LD_INT 22
3733: PUSH
3734: LD_INT 1
3736: PUSH
3737: EMPTY
3738: LIST
3739: LIST
3740: PUSH
3741: LD_INT 21
3743: PUSH
3744: LD_INT 1
3746: PUSH
3747: EMPTY
3748: LIST
3749: LIST
3750: PUSH
3751: EMPTY
3752: LIST
3753: LIST
3754: PPUSH
3755: CALL_OW 69
3759: PUSH
3760: LD_EXP 7
3764: PUSH
3765: LD_VAR 0 2
3769: PUSH
3770: EMPTY
3771: LIST
3772: LIST
3773: DIFF
3774: ST_TO_ADDR
// if UnitFilter ( all , [ f_class , 2 ] ) then
3775: LD_VAR 0 4
3779: PPUSH
3780: LD_INT 25
3782: PUSH
3783: LD_INT 2
3785: PUSH
3786: EMPTY
3787: LIST
3788: LIST
3789: PPUSH
3790: CALL_OW 72
3794: IFFALSE 3840
// for i in UnitFilter ( all , [ f_class , 2 ] ) do
3796: LD_ADDR_VAR 0 3
3800: PUSH
3801: LD_VAR 0 4
3805: PPUSH
3806: LD_INT 25
3808: PUSH
3809: LD_INT 2
3811: PUSH
3812: EMPTY
3813: LIST
3814: LIST
3815: PPUSH
3816: CALL_OW 72
3820: PUSH
3821: FOR_IN
3822: IFFALSE 3838
// SetClass ( i , 2 ) ;
3824: LD_VAR 0 3
3828: PPUSH
3829: LD_INT 2
3831: PPUSH
3832: CALL_OW 336
3836: GO 3821
3838: POP
3839: POP
// save_group := CharacterSelection ( 1 , 11 , 11 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ all ^ [ sel_dont_change_class , sel_not_changeable ] ^ [ commander , Harisson ] , [ [ class_soldier , 3 ] , [ class_mechanic , 3 , 6 ] , [ class_scientistic , 1 , 2 ] ] ) ;
3840: LD_ADDR_EXP 4
3844: PUSH
3845: LD_STRING 1
3847: PPUSH
3848: LD_INT 11
3850: PPUSH
3851: LD_INT 11
3853: PPUSH
3854: LD_INT -5
3856: PUSH
3857: LD_EXP 7
3861: PUSH
3862: LD_INT -2
3864: PUSH
3865: LD_INT -3
3867: PUSH
3868: LD_INT -5
3870: PUSH
3871: EMPTY
3872: LIST
3873: LIST
3874: LIST
3875: LIST
3876: LIST
3877: PUSH
3878: LD_VAR 0 4
3882: ADD
3883: PUSH
3884: LD_INT -6
3886: PUSH
3887: LD_INT -4
3889: PUSH
3890: EMPTY
3891: LIST
3892: LIST
3893: ADD
3894: PUSH
3895: LD_VAR 0 2
3899: PUSH
3900: LD_EXP 17
3904: PUSH
3905: EMPTY
3906: LIST
3907: LIST
3908: ADD
3909: PPUSH
3910: LD_INT 1
3912: PUSH
3913: LD_INT 3
3915: PUSH
3916: EMPTY
3917: LIST
3918: LIST
3919: PUSH
3920: LD_INT 3
3922: PUSH
3923: LD_INT 3
3925: PUSH
3926: LD_INT 6
3928: PUSH
3929: EMPTY
3930: LIST
3931: LIST
3932: LIST
3933: PUSH
3934: LD_INT 4
3936: PUSH
3937: LD_INT 1
3939: PUSH
3940: LD_INT 2
3942: PUSH
3943: EMPTY
3944: LIST
3945: LIST
3946: LIST
3947: PUSH
3948: EMPTY
3949: LIST
3950: LIST
3951: LIST
3952: PPUSH
3953: CALL_OW 42
3957: ST_TO_ADDR
// SaveCharacters ( all diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , Houten , Harisson , Khatam ] ^ save_group , 07_othersGamma ) ;
3958: LD_VAR 0 4
3962: PUSH
3963: LD_EXP 7
3967: PUSH
3968: LD_EXP 8
3972: PUSH
3973: LD_EXP 10
3977: PUSH
3978: LD_EXP 11
3982: PUSH
3983: LD_EXP 12
3987: PUSH
3988: LD_EXP 9
3992: PUSH
3993: LD_EXP 13
3997: PUSH
3998: LD_EXP 14
4002: PUSH
4003: LD_EXP 15
4007: PUSH
4008: LD_EXP 17
4012: PUSH
4013: LD_EXP 16
4017: PUSH
4018: EMPTY
4019: LIST
4020: LIST
4021: LIST
4022: LIST
4023: LIST
4024: LIST
4025: LIST
4026: LIST
4027: LIST
4028: LIST
4029: LIST
4030: PUSH
4031: LD_EXP 4
4035: ADD
4036: DIFF
4037: PPUSH
4038: LD_STRING 07_othersGamma
4040: PPUSH
4041: CALL_OW 38
// SaveCharacters ( save_group diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , Houten , Harisson , Khatam , 0 ] , 07_others ) ;
4045: LD_EXP 4
4049: PUSH
4050: LD_EXP 7
4054: PUSH
4055: LD_EXP 8
4059: PUSH
4060: LD_EXP 10
4064: PUSH
4065: LD_EXP 11
4069: PUSH
4070: LD_EXP 12
4074: PUSH
4075: LD_EXP 9
4079: PUSH
4080: LD_EXP 13
4084: PUSH
4085: LD_EXP 14
4089: PUSH
4090: LD_EXP 15
4094: PUSH
4095: LD_EXP 17
4099: PUSH
4100: LD_EXP 16
4104: PUSH
4105: LD_INT 0
4107: PUSH
4108: EMPTY
4109: LIST
4110: LIST
4111: LIST
4112: LIST
4113: LIST
4114: LIST
4115: LIST
4116: LIST
4117: LIST
4118: LIST
4119: LIST
4120: LIST
4121: DIFF
4122: PPUSH
4123: LD_STRING 07_others
4125: PPUSH
4126: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
4130: LD_EXP 7
4134: PPUSH
4135: LD_EXP 5
4139: PUSH
4140: LD_STRING JMM
4142: STR
4143: PPUSH
4144: CALL_OW 38
// if Lisa then
4148: LD_EXP 10
4152: IFFALSE 4194
// begin SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
4154: LD_EXP 10
4158: PPUSH
4159: LD_EXP 5
4163: PUSH
4164: LD_STRING Lisa
4166: STR
4167: PPUSH
4168: CALL_OW 38
// if Lisa in save_group then
4172: LD_EXP 10
4176: PUSH
4177: LD_EXP 4
4181: IN
4182: IFFALSE 4194
// SaveVariable ( true , LisaIn07 ) ;
4184: LD_INT 1
4186: PPUSH
4187: LD_STRING LisaIn07
4189: PPUSH
4190: CALL_OW 39
// end ; if Bobby then
4194: LD_EXP 12
4198: IFFALSE 4240
// begin SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
4200: LD_EXP 12
4204: PPUSH
4205: LD_EXP 5
4209: PUSH
4210: LD_STRING Bobby
4212: STR
4213: PPUSH
4214: CALL_OW 38
// if Bobby in save_group then
4218: LD_EXP 12
4222: PUSH
4223: LD_EXP 4
4227: IN
4228: IFFALSE 4240
// SaveVariable ( true , BobbyIn07 ) ;
4230: LD_INT 1
4232: PPUSH
4233: LD_STRING BobbyIn07
4235: PPUSH
4236: CALL_OW 39
// end ; if Cyrus then
4240: LD_EXP 11
4244: IFFALSE 4286
// begin SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
4246: LD_EXP 11
4250: PPUSH
4251: LD_EXP 5
4255: PUSH
4256: LD_STRING Cyrus
4258: STR
4259: PPUSH
4260: CALL_OW 38
// if Cyrus in save_group then
4264: LD_EXP 11
4268: PUSH
4269: LD_EXP 4
4273: IN
4274: IFFALSE 4286
// SaveVariable ( true , CyrusIn07 ) ;
4276: LD_INT 1
4278: PPUSH
4279: LD_STRING CyrusIn07
4281: PPUSH
4282: CALL_OW 39
// end ; if Brown then
4286: LD_EXP 14
4290: IFFALSE 4332
// begin SaveCharacters ( Brown , mission_prefix & Brown ) ;
4292: LD_EXP 14
4296: PPUSH
4297: LD_EXP 5
4301: PUSH
4302: LD_STRING Brown
4304: STR
4305: PPUSH
4306: CALL_OW 38
// if Brown in save_group then
4310: LD_EXP 14
4314: PUSH
4315: LD_EXP 4
4319: IN
4320: IFFALSE 4332
// SaveVariable ( true , BrownIn07 ) ;
4322: LD_INT 1
4324: PPUSH
4325: LD_STRING BrownIn07
4327: PPUSH
4328: CALL_OW 39
// end ; if Donaldson then
4332: LD_EXP 13
4336: IFFALSE 4378
// begin SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
4338: LD_EXP 13
4342: PPUSH
4343: LD_EXP 5
4347: PUSH
4348: LD_STRING Donaldson
4350: STR
4351: PPUSH
4352: CALL_OW 38
// if Donaldson in save_group then
4356: LD_EXP 13
4360: PUSH
4361: LD_EXP 4
4365: IN
4366: IFFALSE 4378
// SaveVariable ( true , DonaldsonIn07 ) ;
4368: LD_INT 1
4370: PPUSH
4371: LD_STRING DonaldsonIn07
4373: PPUSH
4374: CALL_OW 39
// end ; if Gladstone then
4378: LD_EXP 8
4382: IFFALSE 4424
// begin SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
4384: LD_EXP 8
4388: PPUSH
4389: LD_EXP 5
4393: PUSH
4394: LD_STRING Gladstone
4396: STR
4397: PPUSH
4398: CALL_OW 38
// if Gladstone in save_group then
4402: LD_EXP 8
4406: PUSH
4407: LD_EXP 4
4411: IN
4412: IFFALSE 4424
// SaveVariable ( true , GladstoneIn07 ) ;
4414: LD_INT 1
4416: PPUSH
4417: LD_STRING GladstoneIn07
4419: PPUSH
4420: CALL_OW 39
// end ; if Khatam then
4424: LD_EXP 16
4428: IFFALSE 4470
// begin SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
4430: LD_EXP 16
4434: PPUSH
4435: LD_EXP 5
4439: PUSH
4440: LD_STRING Khatam
4442: STR
4443: PPUSH
4444: CALL_OW 38
// if Khatam in save_group then
4448: LD_EXP 16
4452: PUSH
4453: LD_EXP 4
4457: IN
4458: IFFALSE 4470
// SaveVariable ( true , KhatamIn07 ) ;
4460: LD_INT 1
4462: PPUSH
4463: LD_STRING KhatamIn07
4465: PPUSH
4466: CALL_OW 39
// end ; if debug then
4470: LD_EXP 1
4474: IFFALSE 4480
// InGameOff ;
4476: CALL_OW 9
// ToLua ( enableBioCharacter(BIO_HARR) ) ;
4480: LD_STRING enableBioCharacter(BIO_HARR)
4482: PPUSH
4483: CALL_OW 559
// ChangeMap ( 1 , %_cont ) ;
4487: LD_INT 1
4489: PPUSH
4490: LD_STRING %_cont
4492: PPUSH
4493: CALL_OW 340
// end ; end_of_file
4497: LD_VAR 0 1
4501: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
4502: LD_INT 0
4504: PPUSH
4505: PPUSH
// if exist_mode then
4506: LD_VAR 0 2
4510: IFFALSE 4535
// unit := CreateCharacter ( prefix & ident ) else
4512: LD_ADDR_VAR 0 5
4516: PUSH
4517: LD_VAR 0 3
4521: PUSH
4522: LD_VAR 0 1
4526: STR
4527: PPUSH
4528: CALL_OW 34
4532: ST_TO_ADDR
4533: GO 4550
// unit := NewCharacter ( ident ) ;
4535: LD_ADDR_VAR 0 5
4539: PUSH
4540: LD_VAR 0 1
4544: PPUSH
4545: CALL_OW 25
4549: ST_TO_ADDR
// result := unit ;
4550: LD_ADDR_VAR 0 4
4554: PUSH
4555: LD_VAR 0 5
4559: ST_TO_ADDR
// end ;
4560: LD_VAR 0 4
4564: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
4565: LD_INT 0
4567: PPUSH
// uc_side := side ;
4568: LD_ADDR_OWVAR 20
4572: PUSH
4573: LD_VAR 0 1
4577: ST_TO_ADDR
// uc_nation := nation ;
4578: LD_ADDR_OWVAR 21
4582: PUSH
4583: LD_VAR 0 2
4587: ST_TO_ADDR
// vc_chassis := chassis ;
4588: LD_ADDR_OWVAR 37
4592: PUSH
4593: LD_VAR 0 3
4597: ST_TO_ADDR
// vc_engine := engine ;
4598: LD_ADDR_OWVAR 39
4602: PUSH
4603: LD_VAR 0 4
4607: ST_TO_ADDR
// vc_control := control ;
4608: LD_ADDR_OWVAR 38
4612: PUSH
4613: LD_VAR 0 5
4617: ST_TO_ADDR
// vc_weapon := weapon ;
4618: LD_ADDR_OWVAR 40
4622: PUSH
4623: LD_VAR 0 6
4627: ST_TO_ADDR
// vc_fuel_battery := fuel ;
4628: LD_ADDR_OWVAR 41
4632: PUSH
4633: LD_VAR 0 7
4637: ST_TO_ADDR
// result := CreateVehicle ;
4638: LD_ADDR_VAR 0 8
4642: PUSH
4643: CALL_OW 45
4647: ST_TO_ADDR
// end ;
4648: LD_VAR 0 8
4652: RET
// export function SayX ( units , ident ) ; var i ; begin
4653: LD_INT 0
4655: PPUSH
4656: PPUSH
// result := false ;
4657: LD_ADDR_VAR 0 3
4661: PUSH
4662: LD_INT 0
4664: ST_TO_ADDR
// if not units then
4665: LD_VAR 0 1
4669: NOT
4670: IFFALSE 4674
// exit ;
4672: GO 4728
// for i in units do
4674: LD_ADDR_VAR 0 4
4678: PUSH
4679: LD_VAR 0 1
4683: PUSH
4684: FOR_IN
4685: IFFALSE 4726
// if IsOk ( i ) then
4687: LD_VAR 0 4
4691: PPUSH
4692: CALL_OW 302
4696: IFFALSE 4724
// begin Say ( i , ident ) ;
4698: LD_VAR 0 4
4702: PPUSH
4703: LD_VAR 0 2
4707: PPUSH
4708: CALL_OW 88
// result := i ;
4712: LD_ADDR_VAR 0 3
4716: PUSH
4717: LD_VAR 0 4
4721: ST_TO_ADDR
// break ;
4722: GO 4726
// end ;
4724: GO 4684
4726: POP
4727: POP
// end ;
4728: LD_VAR 0 3
4732: RET
