// starting begin ResetFog ;
   0: CALL_OW 335
// FogOff ( 1 ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 344
// Randomize ;
  11: CALL_OW 10
// Init ;
  15: CALL 32 0 0
// DebugMode ;
  19: CALL 98 0 0
// PrepareAmerican ;
  23: CALL 115 0 0
// Action ;
  27: CALL 2592 0 0
// end ;
  31: END
// export debug ; export donaldson_commander , brown_commander , save_group ; export mission_prefix , mission_prefix_prev ; function Init ; begin
  32: LD_INT 0
  34: PPUSH
// debug := false ;
  35: LD_ADDR_EXP 1
  39: PUSH
  40: LD_INT 0
  42: ST_TO_ADDR
// mission_prefix := 07_ ;
  43: LD_ADDR_EXP 5
  47: PUSH
  48: LD_STRING 07_
  50: ST_TO_ADDR
// mission_prefix_prev := [ 06_ , 05_ , 04_ ] ;
  51: LD_ADDR_EXP 6
  55: PUSH
  56: LD_STRING 06_
  58: PUSH
  59: LD_STRING 05_
  61: PUSH
  62: LD_STRING 04_
  64: PUSH
  65: EMPTY
  66: LIST
  67: LIST
  68: LIST
  69: ST_TO_ADDR
// donaldson_commander := false ;
  70: LD_ADDR_EXP 2
  74: PUSH
  75: LD_INT 0
  77: ST_TO_ADDR
// brown_commander := false ;
  78: LD_ADDR_EXP 3
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// save_group := [ ] ;
  86: LD_ADDR_EXP 4
  90: PUSH
  91: EMPTY
  92: ST_TO_ADDR
// end ;
  93: LD_VAR 0 1
  97: RET
// function DebugMode ; begin
  98: LD_INT 0
 100: PPUSH
// if not debug then
 101: LD_EXP 1
 105: NOT
 106: IFFALSE 110
// exit ;
 108: GO 110
// end ; end_of_file
 110: LD_VAR 0 1
 114: RET
// export JMM , Gladstone , Frank , Lisa , Cyrus , Bobby , Donaldson , Brown , Houten , Khatam , Harisson ; export gamma_commander ; export function PrepareAmerican ; var others , others_delta , others4 , veh , team , dep , bar , lab , fac , bun , filter , i , j ; begin
 115: LD_INT 0
 117: PPUSH
 118: PPUSH
 119: PPUSH
 120: PPUSH
 121: PPUSH
 122: PPUSH
 123: PPUSH
 124: PPUSH
 125: PPUSH
 126: PPUSH
 127: PPUSH
 128: PPUSH
 129: PPUSH
 130: PPUSH
// PrepareBase ;
 131: CALL 2313 0 0
// uc_side := 1 ;
 135: LD_ADDR_OWVAR 20
 139: PUSH
 140: LD_INT 1
 142: ST_TO_ADDR
// uc_nation := 1 ;
 143: LD_ADDR_OWVAR 21
 147: PUSH
 148: LD_INT 1
 150: ST_TO_ADDR
// team := [ ] ;
 151: LD_ADDR_VAR 0 6
 155: PUSH
 156: EMPTY
 157: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 06c_ ) ;
 158: LD_ADDR_EXP 7
 162: PUSH
 163: LD_STRING JMM
 165: PPUSH
 166: LD_EXP 1
 170: NOT
 171: PPUSH
 172: LD_STRING 06c_
 174: PPUSH
 175: CALL 3899 0 3
 179: ST_TO_ADDR
// if GetClass ( JMM ) = 2 then
 180: LD_EXP 7
 184: PPUSH
 185: CALL_OW 257
 189: PUSH
 190: LD_INT 2
 192: EQUAL
 193: IFFALSE 207
// SetClass ( JMM , 1 ) ;
 195: LD_EXP 7
 199: PPUSH
 200: LD_INT 1
 202: PPUSH
 203: CALL_OW 336
// gamma_commander := LoadVariable ( GammaCommander , 3 ) ;
 207: LD_ADDR_EXP 18
 211: PUSH
 212: LD_STRING GammaCommander
 214: PPUSH
 215: LD_INT 3
 217: PPUSH
 218: CALL_OW 30
 222: ST_TO_ADDR
// if gamma_commander = 1 then
 223: LD_EXP 18
 227: PUSH
 228: LD_INT 1
 230: EQUAL
 231: IFFALSE 257
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 04_ ) ;
 233: LD_ADDR_EXP 13
 237: PUSH
 238: LD_STRING Donaldson
 240: PPUSH
 241: LD_EXP 1
 245: NOT
 246: PPUSH
 247: LD_STRING 04_
 249: PPUSH
 250: CALL 3899 0 3
 254: ST_TO_ADDR
// end else
 255: GO 328
// begin if LoadVariable ( DonaldsonIn06 , 0 ) then
 257: LD_STRING DonaldsonIn06
 259: PPUSH
 260: LD_INT 0
 262: PPUSH
 263: CALL_OW 30
 267: IFFALSE 293
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 06c_ ) else
 269: LD_ADDR_EXP 13
 273: PUSH
 274: LD_STRING Donaldson
 276: PPUSH
 277: LD_EXP 1
 281: NOT
 282: PPUSH
 283: LD_STRING 06c_
 285: PPUSH
 286: CALL 3899 0 3
 290: ST_TO_ADDR
 291: GO 328
// if not LoadVariable ( DonaldsonStayInDelta , 0 ) then
 293: LD_STRING DonaldsonStayInDelta
 295: PPUSH
 296: LD_INT 0
 298: PPUSH
 299: CALL_OW 30
 303: NOT
 304: IFFALSE 328
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 04_ ) ;
 306: LD_ADDR_EXP 13
 310: PUSH
 311: LD_STRING Donaldson
 313: PPUSH
 314: LD_EXP 1
 318: NOT
 319: PPUSH
 320: LD_STRING 04_
 322: PPUSH
 323: CALL 3899 0 3
 327: ST_TO_ADDR
// end ; if Donaldson then
 328: LD_EXP 13
 332: IFFALSE 350
// team := team ^ Donaldson ;
 334: LD_ADDR_VAR 0 6
 338: PUSH
 339: LD_VAR 0 6
 343: PUSH
 344: LD_EXP 13
 348: ADD
 349: ST_TO_ADDR
// if gamma_commander = 2 then
 350: LD_EXP 18
 354: PUSH
 355: LD_INT 2
 357: EQUAL
 358: IFFALSE 384
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 04_ ) ;
 360: LD_ADDR_EXP 14
 364: PUSH
 365: LD_STRING Brown
 367: PPUSH
 368: LD_EXP 1
 372: NOT
 373: PPUSH
 374: LD_STRING 04_
 376: PPUSH
 377: CALL 3899 0 3
 381: ST_TO_ADDR
// end else
 382: GO 455
// begin if LoadVariable ( BrownIn06 , 0 ) then
 384: LD_STRING BrownIn06
 386: PPUSH
 387: LD_INT 0
 389: PPUSH
 390: CALL_OW 30
 394: IFFALSE 420
// Brown := PrepareUnit ( Brown , ( not debug ) , 06c_ ) else
 396: LD_ADDR_EXP 14
 400: PUSH
 401: LD_STRING Brown
 403: PPUSH
 404: LD_EXP 1
 408: NOT
 409: PPUSH
 410: LD_STRING 06c_
 412: PPUSH
 413: CALL 3899 0 3
 417: ST_TO_ADDR
 418: GO 455
// if not LoadVariable ( BrownStayInDelta , 0 ) then
 420: LD_STRING BrownStayInDelta
 422: PPUSH
 423: LD_INT 0
 425: PPUSH
 426: CALL_OW 30
 430: NOT
 431: IFFALSE 455
// Brown := PrepareUnit ( Brown , ( not debug ) , 04_ ) ;
 433: LD_ADDR_EXP 14
 437: PUSH
 438: LD_STRING Brown
 440: PPUSH
 441: LD_EXP 1
 445: NOT
 446: PPUSH
 447: LD_STRING 04_
 449: PPUSH
 450: CALL 3899 0 3
 454: ST_TO_ADDR
// end ; if Brown then
 455: LD_EXP 14
 459: IFFALSE 477
// team := team ^ Brown ;
 461: LD_ADDR_VAR 0 6
 465: PUSH
 466: LD_VAR 0 6
 470: PUSH
 471: LD_EXP 14
 475: ADD
 476: ST_TO_ADDR
// if gamma_commander = 3 then
 477: LD_EXP 18
 481: PUSH
 482: LD_INT 3
 484: EQUAL
 485: IFFALSE 522
// begin Houten := PrepareUnit ( VanHouten , false ,  ) ;
 487: LD_ADDR_EXP 15
 491: PUSH
 492: LD_STRING VanHouten
 494: PPUSH
 495: LD_INT 0
 497: PPUSH
 498: LD_STRING 
 500: PPUSH
 501: CALL 3899 0 3
 505: ST_TO_ADDR
// team := team ^ Houten ;
 506: LD_ADDR_VAR 0 6
 510: PUSH
 511: LD_VAR 0 6
 515: PUSH
 516: LD_EXP 15
 520: ADD
 521: ST_TO_ADDR
// end ; if LoadVariable ( GladstoneIn06 , 0 ) then
 522: LD_STRING GladstoneIn06
 524: PPUSH
 525: LD_INT 0
 527: PPUSH
 528: CALL_OW 30
 532: IFFALSE 558
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 06c_ ) else
 534: LD_ADDR_EXP 8
 538: PUSH
 539: LD_STRING Gladstone
 541: PPUSH
 542: LD_EXP 1
 546: NOT
 547: PPUSH
 548: LD_STRING 06c_
 550: PPUSH
 551: CALL 3899 0 3
 555: ST_TO_ADDR
 556: GO 592
// if LoadVariable ( GladstoneStayInDelta , 0 ) then
 558: LD_STRING GladstoneStayInDelta
 560: PPUSH
 561: LD_INT 0
 563: PPUSH
 564: CALL_OW 30
 568: IFFALSE 592
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 06_ ) ;
 570: LD_ADDR_EXP 8
 574: PUSH
 575: LD_STRING Gladstone
 577: PPUSH
 578: LD_EXP 1
 582: NOT
 583: PPUSH
 584: LD_STRING 06_
 586: PPUSH
 587: CALL 3899 0 3
 591: ST_TO_ADDR
// if Gladstone then
 592: LD_EXP 8
 596: IFFALSE 614
// team := team ^ Gladstone ;
 598: LD_ADDR_VAR 0 6
 602: PUSH
 603: LD_VAR 0 6
 607: PUSH
 608: LD_EXP 8
 612: ADD
 613: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) , 03_ ) ;
 614: LD_ADDR_EXP 16
 618: PUSH
 619: LD_STRING Khatam
 621: PPUSH
 622: LD_EXP 1
 626: NOT
 627: PPUSH
 628: LD_STRING 03_
 630: PPUSH
 631: CALL 3899 0 3
 635: ST_TO_ADDR
// if Khatam then
 636: LD_EXP 16
 640: IFFALSE 658
// team := team ^ Khatam ;
 642: LD_ADDR_VAR 0 6
 646: PUSH
 647: LD_VAR 0 6
 651: PUSH
 652: LD_EXP 16
 656: ADD
 657: ST_TO_ADDR
// if LoadVariable ( LisaIn06 , 0 ) then
 658: LD_STRING LisaIn06
 660: PPUSH
 661: LD_INT 0
 663: PPUSH
 664: CALL_OW 30
 668: IFFALSE 694
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 06c_ ) else
 670: LD_ADDR_EXP 10
 674: PUSH
 675: LD_STRING Lisa
 677: PPUSH
 678: LD_EXP 1
 682: NOT
 683: PPUSH
 684: LD_STRING 06c_
 686: PPUSH
 687: CALL 3899 0 3
 691: ST_TO_ADDR
 692: GO 729
// if not LoadVariable ( LisaStayInDelta , 0 ) then
 694: LD_STRING LisaStayInDelta
 696: PPUSH
 697: LD_INT 0
 699: PPUSH
 700: CALL_OW 30
 704: NOT
 705: IFFALSE 729
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 04_ ) ;
 707: LD_ADDR_EXP 10
 711: PUSH
 712: LD_STRING Lisa
 714: PPUSH
 715: LD_EXP 1
 719: NOT
 720: PPUSH
 721: LD_STRING 04_
 723: PPUSH
 724: CALL 3899 0 3
 728: ST_TO_ADDR
// if Lisa then
 729: LD_EXP 10
 733: IFFALSE 751
// team := team ^ Lisa ;
 735: LD_ADDR_VAR 0 6
 739: PUSH
 740: LD_VAR 0 6
 744: PUSH
 745: LD_EXP 10
 749: ADD
 750: ST_TO_ADDR
// if not Lisa then
 751: LD_EXP 10
 755: NOT
 756: IFFALSE 1009
// begin if LoadVariable ( CyrusIn06 , 0 ) then
 758: LD_STRING CyrusIn06
 760: PPUSH
 761: LD_INT 0
 763: PPUSH
 764: CALL_OW 30
 768: IFFALSE 794
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 06c_ ) else
 770: LD_ADDR_EXP 11
 774: PUSH
 775: LD_STRING Cyrus
 777: PPUSH
 778: LD_EXP 1
 782: NOT
 783: PPUSH
 784: LD_STRING 06c_
 786: PPUSH
 787: CALL 3899 0 3
 791: ST_TO_ADDR
 792: GO 858
// if not LoadVariable ( CyrusStayInDelta , 0 ) then
 794: LD_STRING CyrusStayInDelta
 796: PPUSH
 797: LD_INT 0
 799: PPUSH
 800: CALL_OW 30
 804: NOT
 805: IFFALSE 858
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 04_ ) ;
 807: LD_ADDR_EXP 11
 811: PUSH
 812: LD_STRING Cyrus
 814: PPUSH
 815: LD_EXP 1
 819: NOT
 820: PPUSH
 821: LD_STRING 04_
 823: PPUSH
 824: CALL 3899 0 3
 828: ST_TO_ADDR
// if not Cyrus then
 829: LD_EXP 11
 833: NOT
 834: IFFALSE 858
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 03_ ) ;
 836: LD_ADDR_EXP 11
 840: PUSH
 841: LD_STRING Cyrus
 843: PPUSH
 844: LD_EXP 1
 848: NOT
 849: PPUSH
 850: LD_STRING 03_
 852: PPUSH
 853: CALL 3899 0 3
 857: ST_TO_ADDR
// end ; if Cyrus then
 858: LD_EXP 11
 862: IFFALSE 880
// team := team ^ Cyrus ;
 864: LD_ADDR_VAR 0 6
 868: PUSH
 869: LD_VAR 0 6
 873: PUSH
 874: LD_EXP 11
 878: ADD
 879: ST_TO_ADDR
// if not Cyrus then
 880: LD_EXP 11
 884: NOT
 885: IFFALSE 1009
// begin if LoadVariable ( BobbyIn06 , 0 ) then
 887: LD_STRING BobbyIn06
 889: PPUSH
 890: LD_INT 0
 892: PPUSH
 893: CALL_OW 30
 897: IFFALSE 923
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 06c_ ) else
 899: LD_ADDR_EXP 12
 903: PUSH
 904: LD_STRING Bobby
 906: PPUSH
 907: LD_EXP 1
 911: NOT
 912: PPUSH
 913: LD_STRING 06c_
 915: PPUSH
 916: CALL 3899 0 3
 920: ST_TO_ADDR
 921: GO 987
// if not LoadVariable ( BobbyStayInDelta , 0 ) then
 923: LD_STRING BobbyStayInDelta
 925: PPUSH
 926: LD_INT 0
 928: PPUSH
 929: CALL_OW 30
 933: NOT
 934: IFFALSE 987
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 04_ ) ;
 936: LD_ADDR_EXP 12
 940: PUSH
 941: LD_STRING Bobby
 943: PPUSH
 944: LD_EXP 1
 948: NOT
 949: PPUSH
 950: LD_STRING 04_
 952: PPUSH
 953: CALL 3899 0 3
 957: ST_TO_ADDR
// if not Bobby then
 958: LD_EXP 12
 962: NOT
 963: IFFALSE 987
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 03_ ) ;
 965: LD_ADDR_EXP 12
 969: PUSH
 970: LD_STRING Bobby
 972: PPUSH
 973: LD_EXP 1
 977: NOT
 978: PPUSH
 979: LD_STRING 03_
 981: PPUSH
 982: CALL 3899 0 3
 986: ST_TO_ADDR
// end ; if Bobby then
 987: LD_EXP 12
 991: IFFALSE 1009
// team := team ^ Bobby ;
 993: LD_ADDR_VAR 0 6
 997: PUSH
 998: LD_VAR 0 6
1002: PUSH
1003: LD_EXP 12
1007: ADD
1008: ST_TO_ADDR
// end ; end ; others4 := CreateCharacterSet ( othersGamma ) ;
1009: LD_ADDR_VAR 0 4
1013: PUSH
1014: LD_STRING othersGamma
1016: PPUSH
1017: CALL_OW 31
1021: ST_TO_ADDR
// others := CreateCharacterSet ( 06_other_survivors ) ;
1022: LD_ADDR_VAR 0 2
1026: PUSH
1027: LD_STRING 06_other_survivors
1029: PPUSH
1030: CALL_OW 31
1034: ST_TO_ADDR
// others := others union others4 ;
1035: LD_ADDR_VAR 0 2
1039: PUSH
1040: LD_VAR 0 2
1044: PUSH
1045: LD_VAR 0 4
1049: UNION
1050: ST_TO_ADDR
// team := team ^ others ;
1051: LD_ADDR_VAR 0 6
1055: PUSH
1056: LD_VAR 0 6
1060: PUSH
1061: LD_VAR 0 2
1065: ADD
1066: ST_TO_ADDR
// if team < 10 then
1067: LD_VAR 0 6
1071: PUSH
1072: LD_INT 10
1074: LESS
1075: IFFALSE 1131
// repeat wait ( 0 0$01 ) ;
1077: LD_INT 35
1079: PPUSH
1080: CALL_OW 67
// PrepareHuman ( false , rand ( 1 , 4 ) , 5 ) ;
1084: LD_INT 0
1086: PPUSH
1087: LD_INT 1
1089: PPUSH
1090: LD_INT 4
1092: PPUSH
1093: CALL_OW 12
1097: PPUSH
1098: LD_INT 5
1100: PPUSH
1101: CALL_OW 380
// team := team ^ CreateHuman ;
1105: LD_ADDR_VAR 0 6
1109: PUSH
1110: LD_VAR 0 6
1114: PUSH
1115: CALL_OW 44
1119: ADD
1120: ST_TO_ADDR
// until team < 10 ;
1121: LD_VAR 0 6
1125: PUSH
1126: LD_INT 10
1128: LESS
1129: IFFALSE 1077
// for i in others do
1131: LD_ADDR_VAR 0 13
1135: PUSH
1136: LD_VAR 0 2
1140: PUSH
1141: FOR_IN
1142: IFFALSE 1210
// begin if GetClass ( i ) = 2 then
1144: LD_VAR 0 13
1148: PPUSH
1149: CALL_OW 257
1153: PUSH
1154: LD_INT 2
1156: EQUAL
1157: IFFALSE 1171
// SetClass ( i , 1 ) ;
1159: LD_VAR 0 13
1163: PPUSH
1164: LD_INT 1
1166: PPUSH
1167: CALL_OW 336
// for j = 1 to 4 do
1171: LD_ADDR_VAR 0 14
1175: PUSH
1176: DOUBLE
1177: LD_INT 1
1179: DEC
1180: ST_TO_ADDR
1181: LD_INT 4
1183: PUSH
1184: FOR_TO
1185: IFFALSE 1206
// AddExperience ( i , j , 3000 ) ;
1187: LD_VAR 0 13
1191: PPUSH
1192: LD_VAR 0 14
1196: PPUSH
1197: LD_INT 3000
1199: PPUSH
1200: CALL_OW 492
1204: GO 1184
1206: POP
1207: POP
// end ;
1208: GO 1141
1210: POP
1211: POP
// dep := FilterAllUnits ( [ f_btype , b_depot ] ) ;
1212: LD_ADDR_VAR 0 7
1216: PUSH
1217: LD_INT 30
1219: PUSH
1220: LD_INT 0
1222: PUSH
1223: EMPTY
1224: LIST
1225: LIST
1226: PPUSH
1227: CALL_OW 69
1231: ST_TO_ADDR
// bar := FilterAllUnits ( [ f_btype , b_armoury ] ) ;
1232: LD_ADDR_VAR 0 8
1236: PUSH
1237: LD_INT 30
1239: PUSH
1240: LD_INT 4
1242: PUSH
1243: EMPTY
1244: LIST
1245: LIST
1246: PPUSH
1247: CALL_OW 69
1251: ST_TO_ADDR
// lab := FilterAllUnits ( [ f_or , [ f_btype , b_lab_half ] , [ f_btype , b_lab ] ] ) ;
1252: LD_ADDR_VAR 0 9
1256: PUSH
1257: LD_INT 2
1259: PUSH
1260: LD_INT 30
1262: PUSH
1263: LD_INT 7
1265: PUSH
1266: EMPTY
1267: LIST
1268: LIST
1269: PUSH
1270: LD_INT 30
1272: PUSH
1273: LD_INT 6
1275: PUSH
1276: EMPTY
1277: LIST
1278: LIST
1279: PUSH
1280: EMPTY
1281: LIST
1282: LIST
1283: LIST
1284: PPUSH
1285: CALL_OW 69
1289: ST_TO_ADDR
// fac := FilterAllUnits ( [ f_btype , b_factory ] ) ;
1290: LD_ADDR_VAR 0 10
1294: PUSH
1295: LD_INT 30
1297: PUSH
1298: LD_INT 3
1300: PUSH
1301: EMPTY
1302: LIST
1303: LIST
1304: PPUSH
1305: CALL_OW 69
1309: ST_TO_ADDR
// bun := FilterAllUnits ( [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ;
1310: LD_ADDR_VAR 0 11
1314: PUSH
1315: LD_INT 2
1317: PUSH
1318: LD_INT 30
1320: PUSH
1321: LD_INT 32
1323: PUSH
1324: EMPTY
1325: LIST
1326: LIST
1327: PUSH
1328: LD_INT 30
1330: PUSH
1331: LD_INT 31
1333: PUSH
1334: EMPTY
1335: LIST
1336: LIST
1337: PUSH
1338: EMPTY
1339: LIST
1340: LIST
1341: LIST
1342: PPUSH
1343: CALL_OW 69
1347: ST_TO_ADDR
// SetBName ( dep , Gamma ) ;
1348: LD_VAR 0 7
1352: PPUSH
1353: LD_STRING Gamma
1355: PPUSH
1356: CALL_OW 500
// SetResourceType ( GetBase ( dep ) , mat_oil , 10000 ) ;
1360: LD_VAR 0 7
1364: PPUSH
1365: CALL_OW 274
1369: PPUSH
1370: LD_INT 2
1372: PPUSH
1373: LD_INT 10000
1375: PPUSH
1376: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_cans , 10000 ) ;
1380: LD_VAR 0 7
1384: PPUSH
1385: CALL_OW 274
1389: PPUSH
1390: LD_INT 1
1392: PPUSH
1393: LD_INT 10000
1395: PPUSH
1396: CALL_OW 277
// if dep then
1400: LD_VAR 0 7
1404: IFFALSE 1504
// begin PlaceHumanInUnit ( JMM , dep [ 1 ] ) ;
1406: LD_EXP 7
1410: PPUSH
1411: LD_VAR 0 7
1415: PUSH
1416: LD_INT 1
1418: ARRAY
1419: PPUSH
1420: CALL_OW 52
// if Brown then
1424: LD_EXP 14
1428: IFFALSE 1464
// begin PlaceHumanInUnit ( Brown , dep [ 1 ] ) ;
1430: LD_EXP 14
1434: PPUSH
1435: LD_VAR 0 7
1439: PUSH
1440: LD_INT 1
1442: ARRAY
1443: PPUSH
1444: CALL_OW 52
// team := team diff Brown ;
1448: LD_ADDR_VAR 0 6
1452: PUSH
1453: LD_VAR 0 6
1457: PUSH
1458: LD_EXP 14
1462: DIFF
1463: ST_TO_ADDR
// end ; if Donaldson then
1464: LD_EXP 13
1468: IFFALSE 1504
// begin PlaceHumanInUnit ( Donaldson , dep [ 1 ] ) ;
1470: LD_EXP 13
1474: PPUSH
1475: LD_VAR 0 7
1479: PUSH
1480: LD_INT 1
1482: ARRAY
1483: PPUSH
1484: CALL_OW 52
// team := team diff Donaldson ;
1488: LD_ADDR_VAR 0 6
1492: PUSH
1493: LD_VAR 0 6
1497: PUSH
1498: LD_EXP 13
1502: DIFF
1503: ST_TO_ADDR
// end ; end ; if bun and UnitFilter ( team , [ f_class , 1 ] ) then
1504: LD_VAR 0 11
1508: PUSH
1509: LD_VAR 0 6
1513: PPUSH
1514: LD_INT 25
1516: PUSH
1517: LD_INT 1
1519: PUSH
1520: EMPTY
1521: LIST
1522: LIST
1523: PPUSH
1524: CALL_OW 72
1528: AND
1529: IFFALSE 1638
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
1531: LD_ADDR_VAR 0 12
1535: PUSH
1536: LD_VAR 0 6
1540: PPUSH
1541: LD_INT 25
1543: PUSH
1544: LD_INT 1
1546: PUSH
1547: EMPTY
1548: LIST
1549: LIST
1550: PPUSH
1551: CALL_OW 72
1555: ST_TO_ADDR
// for i in bun do
1556: LD_ADDR_VAR 0 13
1560: PUSH
1561: LD_VAR 0 11
1565: PUSH
1566: FOR_IN
1567: IFFALSE 1636
// begin if not filter then
1569: LD_VAR 0 12
1573: NOT
1574: IFFALSE 1578
// break ;
1576: GO 1636
// PlaceHumanInUnit ( filter [ 1 ] , i ) ;
1578: LD_VAR 0 12
1582: PUSH
1583: LD_INT 1
1585: ARRAY
1586: PPUSH
1587: LD_VAR 0 13
1591: PPUSH
1592: CALL_OW 52
// team := team diff filter [ 1 ] ;
1596: LD_ADDR_VAR 0 6
1600: PUSH
1601: LD_VAR 0 6
1605: PUSH
1606: LD_VAR 0 12
1610: PUSH
1611: LD_INT 1
1613: ARRAY
1614: DIFF
1615: ST_TO_ADDR
// filter := Delete ( filter , 1 ) ;
1616: LD_ADDR_VAR 0 12
1620: PUSH
1621: LD_VAR 0 12
1625: PPUSH
1626: LD_INT 1
1628: PPUSH
1629: CALL_OW 3
1633: ST_TO_ADDR
// end ;
1634: GO 1566
1636: POP
1637: POP
// end ; if bar and UnitFilter ( team , [ f_class , 1 ] ) then
1638: LD_VAR 0 8
1642: PUSH
1643: LD_VAR 0 6
1647: PPUSH
1648: LD_INT 25
1650: PUSH
1651: LD_INT 1
1653: PUSH
1654: EMPTY
1655: LIST
1656: LIST
1657: PPUSH
1658: CALL_OW 72
1662: AND
1663: IFFALSE 1785
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
1665: LD_ADDR_VAR 0 12
1669: PUSH
1670: LD_VAR 0 6
1674: PPUSH
1675: LD_INT 25
1677: PUSH
1678: LD_INT 1
1680: PUSH
1681: EMPTY
1682: LIST
1683: LIST
1684: PPUSH
1685: CALL_OW 72
1689: ST_TO_ADDR
// for i = 1 to filter do
1690: LD_ADDR_VAR 0 13
1694: PUSH
1695: DOUBLE
1696: LD_INT 1
1698: DEC
1699: ST_TO_ADDR
1700: LD_VAR 0 12
1704: PUSH
1705: FOR_TO
1706: IFFALSE 1767
// begin if ( i <= 6 ) then
1708: LD_VAR 0 13
1712: PUSH
1713: LD_INT 6
1715: LESSEQUAL
1716: IFFALSE 1744
// PlaceHumanInUnit ( filter [ i ] , bar [ 1 ] ) else
1718: LD_VAR 0 12
1722: PUSH
1723: LD_VAR 0 13
1727: ARRAY
1728: PPUSH
1729: LD_VAR 0 8
1733: PUSH
1734: LD_INT 1
1736: ARRAY
1737: PPUSH
1738: CALL_OW 52
1742: GO 1765
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1744: LD_VAR 0 12
1748: PUSH
1749: LD_VAR 0 13
1753: ARRAY
1754: PPUSH
1755: LD_INT 1
1757: PPUSH
1758: LD_INT 0
1760: PPUSH
1761: CALL_OW 49
// end ;
1765: GO 1705
1767: POP
1768: POP
// team := team diff filter ;
1769: LD_ADDR_VAR 0 6
1773: PUSH
1774: LD_VAR 0 6
1778: PUSH
1779: LD_VAR 0 12
1783: DIFF
1784: ST_TO_ADDR
// end ; if lab and UnitFilter ( team , [ f_class , 4 ] ) then
1785: LD_VAR 0 9
1789: PUSH
1790: LD_VAR 0 6
1794: PPUSH
1795: LD_INT 25
1797: PUSH
1798: LD_INT 4
1800: PUSH
1801: EMPTY
1802: LIST
1803: LIST
1804: PPUSH
1805: CALL_OW 72
1809: AND
1810: IFFALSE 1932
// begin filter := UnitFilter ( team , [ f_class , 4 ] ) ;
1812: LD_ADDR_VAR 0 12
1816: PUSH
1817: LD_VAR 0 6
1821: PPUSH
1822: LD_INT 25
1824: PUSH
1825: LD_INT 4
1827: PUSH
1828: EMPTY
1829: LIST
1830: LIST
1831: PPUSH
1832: CALL_OW 72
1836: ST_TO_ADDR
// for i = 1 to filter do
1837: LD_ADDR_VAR 0 13
1841: PUSH
1842: DOUBLE
1843: LD_INT 1
1845: DEC
1846: ST_TO_ADDR
1847: LD_VAR 0 12
1851: PUSH
1852: FOR_TO
1853: IFFALSE 1914
// begin if ( i <= 6 ) then
1855: LD_VAR 0 13
1859: PUSH
1860: LD_INT 6
1862: LESSEQUAL
1863: IFFALSE 1891
// PlaceHumanInUnit ( filter [ i ] , lab [ 1 ] ) else
1865: LD_VAR 0 12
1869: PUSH
1870: LD_VAR 0 13
1874: ARRAY
1875: PPUSH
1876: LD_VAR 0 9
1880: PUSH
1881: LD_INT 1
1883: ARRAY
1884: PPUSH
1885: CALL_OW 52
1889: GO 1912
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1891: LD_VAR 0 12
1895: PUSH
1896: LD_VAR 0 13
1900: ARRAY
1901: PPUSH
1902: LD_INT 1
1904: PPUSH
1905: LD_INT 0
1907: PPUSH
1908: CALL_OW 49
// end ;
1912: GO 1852
1914: POP
1915: POP
// team := team diff filter ;
1916: LD_ADDR_VAR 0 6
1920: PUSH
1921: LD_VAR 0 6
1925: PUSH
1926: LD_VAR 0 12
1930: DIFF
1931: ST_TO_ADDR
// end ; if fac and UnitFilter ( team , [ f_class , 3 ] ) then
1932: LD_VAR 0 10
1936: PUSH
1937: LD_VAR 0 6
1941: PPUSH
1942: LD_INT 25
1944: PUSH
1945: LD_INT 3
1947: PUSH
1948: EMPTY
1949: LIST
1950: LIST
1951: PPUSH
1952: CALL_OW 72
1956: AND
1957: IFFALSE 2079
// begin filter := UnitFilter ( team , [ f_class , 3 ] ) ;
1959: LD_ADDR_VAR 0 12
1963: PUSH
1964: LD_VAR 0 6
1968: PPUSH
1969: LD_INT 25
1971: PUSH
1972: LD_INT 3
1974: PUSH
1975: EMPTY
1976: LIST
1977: LIST
1978: PPUSH
1979: CALL_OW 72
1983: ST_TO_ADDR
// for i = 1 to filter do
1984: LD_ADDR_VAR 0 13
1988: PUSH
1989: DOUBLE
1990: LD_INT 1
1992: DEC
1993: ST_TO_ADDR
1994: LD_VAR 0 12
1998: PUSH
1999: FOR_TO
2000: IFFALSE 2061
// begin if ( i <= 6 ) then
2002: LD_VAR 0 13
2006: PUSH
2007: LD_INT 6
2009: LESSEQUAL
2010: IFFALSE 2038
// PlaceHumanInUnit ( filter [ i ] , fac [ 1 ] ) else
2012: LD_VAR 0 12
2016: PUSH
2017: LD_VAR 0 13
2021: ARRAY
2022: PPUSH
2023: LD_VAR 0 10
2027: PUSH
2028: LD_INT 1
2030: ARRAY
2031: PPUSH
2032: CALL_OW 52
2036: GO 2059
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
2038: LD_VAR 0 12
2042: PUSH
2043: LD_VAR 0 13
2047: ARRAY
2048: PPUSH
2049: LD_INT 1
2051: PPUSH
2052: LD_INT 0
2054: PPUSH
2055: CALL_OW 49
// end ;
2059: GO 1999
2061: POP
2062: POP
// team := team diff filter ;
2063: LD_ADDR_VAR 0 6
2067: PUSH
2068: LD_VAR 0 6
2072: PUSH
2073: LD_VAR 0 12
2077: DIFF
2078: ST_TO_ADDR
// end ; if team then
2079: LD_VAR 0 6
2083: IFFALSE 2126
// for i in team do
2085: LD_ADDR_VAR 0 13
2089: PUSH
2090: LD_VAR 0 6
2094: PUSH
2095: FOR_IN
2096: IFFALSE 2124
// begin PlaceUnitArea ( i , gammaBaseArea , false ) ;
2098: LD_VAR 0 13
2102: PPUSH
2103: LD_INT 1
2105: PPUSH
2106: LD_INT 0
2108: PPUSH
2109: CALL_OW 49
// ComHold ( i ) ;
2113: LD_VAR 0 13
2117: PPUSH
2118: CALL_OW 140
// end ;
2122: GO 2095
2124: POP
2125: POP
// if fac then
2126: LD_VAR 0 10
2130: IFFALSE 2166
// if UnitsInside ( fac [ 1 ] ) then
2132: LD_VAR 0 10
2136: PUSH
2137: LD_INT 1
2139: ARRAY
2140: PPUSH
2141: CALL_OW 313
2145: IFFALSE 2166
// SetSpecResearch ( fac [ 1 ] , 10 , false ) ;
2147: LD_VAR 0 10
2151: PUSH
2152: LD_INT 1
2154: ARRAY
2155: PPUSH
2156: LD_INT 10
2158: PPUSH
2159: LD_INT 0
2161: PPUSH
2162: CALL_OW 486
// if lab then
2166: LD_VAR 0 9
2170: IFFALSE 2206
// if UnitsInside ( lab [ 1 ] ) then
2172: LD_VAR 0 9
2176: PUSH
2177: LD_INT 1
2179: ARRAY
2180: PPUSH
2181: CALL_OW 313
2185: IFFALSE 2206
// SetSpecResearch ( lab [ 1 ] , 10 , false ) ;
2187: LD_VAR 0 9
2191: PUSH
2192: LD_INT 1
2194: ARRAY
2195: PPUSH
2196: LD_INT 10
2198: PPUSH
2199: LD_INT 0
2201: PPUSH
2202: CALL_OW 486
// uc_side := 4 ;
2206: LD_ADDR_OWVAR 20
2210: PUSH
2211: LD_INT 4
2213: ST_TO_ADDR
// Harisson := PrepareUnit ( Harisson , false ,  ) ;
2214: LD_ADDR_EXP 17
2218: PUSH
2219: LD_STRING Harisson
2221: PPUSH
2222: LD_INT 0
2224: PPUSH
2225: LD_STRING 
2227: PPUSH
2228: CALL 3899 0 3
2232: ST_TO_ADDR
// veh := PrepareTank ( 4 , 1 , us_light_wheeled , engine_combustion , control_manual , us_machine_gun , 100 ) ;
2233: LD_ADDR_VAR 0 5
2237: PUSH
2238: LD_INT 4
2240: PPUSH
2241: LD_INT 1
2243: PPUSH
2244: LD_INT 1
2246: PPUSH
2247: LD_INT 1
2249: PPUSH
2250: LD_INT 1
2252: PPUSH
2253: LD_INT 2
2255: PPUSH
2256: LD_INT 100
2258: PPUSH
2259: CALL 3962 0 7
2263: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
2264: LD_VAR 0 5
2268: PPUSH
2269: LD_INT 2
2271: PPUSH
2272: CALL_OW 233
// PlaceUnitXY ( veh , 21 , 8 , false ) ;
2276: LD_VAR 0 5
2280: PPUSH
2281: LD_INT 21
2283: PPUSH
2284: LD_INT 8
2286: PPUSH
2287: LD_INT 0
2289: PPUSH
2290: CALL_OW 48
// PlaceHumanInUnit ( Harisson , veh ) ;
2294: LD_EXP 17
2298: PPUSH
2299: LD_VAR 0 5
2303: PPUSH
2304: CALL_OW 52
// end ;
2308: LD_VAR 0 1
2312: RET
// function PrepareBase ; var blist , i , b ; begin
2313: LD_INT 0
2315: PPUSH
2316: PPUSH
2317: PPUSH
2318: PPUSH
// SetResourceVisibility ( 71 , 5 , 1 ) ;
2319: LD_INT 71
2321: PPUSH
2322: LD_INT 5
2324: PPUSH
2325: LD_INT 1
2327: PPUSH
2328: CALL_OW 441
// blist := LoadVariable ( GammaBase , [ ] ) ;
2332: LD_ADDR_VAR 0 2
2336: PUSH
2337: LD_STRING GammaBase
2339: PPUSH
2340: EMPTY
2341: PPUSH
2342: CALL_OW 30
2346: ST_TO_ADDR
// if not blist and debug then
2347: LD_VAR 0 2
2351: NOT
2352: PUSH
2353: LD_EXP 1
2357: AND
2358: IFFALSE 2398
// blist := [ [ b_depot , 51 , 10 , 3 , 3 , 0 , 0 ] ] ;
2360: LD_ADDR_VAR 0 2
2364: PUSH
2365: LD_INT 0
2367: PUSH
2368: LD_INT 51
2370: PUSH
2371: LD_INT 10
2373: PUSH
2374: LD_INT 3
2376: PUSH
2377: LD_INT 3
2379: PUSH
2380: LD_INT 0
2382: PUSH
2383: LD_INT 0
2385: PUSH
2386: EMPTY
2387: LIST
2388: LIST
2389: LIST
2390: LIST
2391: LIST
2392: LIST
2393: LIST
2394: PUSH
2395: EMPTY
2396: LIST
2397: ST_TO_ADDR
// if not blist then
2398: LD_VAR 0 2
2402: NOT
2403: IFFALSE 2407
// exit ;
2405: GO 2587
// uc_side := 1 ;
2407: LD_ADDR_OWVAR 20
2411: PUSH
2412: LD_INT 1
2414: ST_TO_ADDR
// uc_nation := 1 ;
2415: LD_ADDR_OWVAR 21
2419: PUSH
2420: LD_INT 1
2422: ST_TO_ADDR
// for i in blist do
2423: LD_ADDR_VAR 0 3
2427: PUSH
2428: LD_VAR 0 2
2432: PUSH
2433: FOR_IN
2434: IFFALSE 2585
// begin bc_type := i [ 1 ] ;
2436: LD_ADDR_OWVAR 42
2440: PUSH
2441: LD_VAR 0 3
2445: PUSH
2446: LD_INT 1
2448: ARRAY
2449: ST_TO_ADDR
// bc_level := i [ 5 ] ;
2450: LD_ADDR_OWVAR 43
2454: PUSH
2455: LD_VAR 0 3
2459: PUSH
2460: LD_INT 5
2462: ARRAY
2463: ST_TO_ADDR
// if i [ 1 ] in [ b_lab_half , b_lab_full ] then
2464: LD_VAR 0 3
2468: PUSH
2469: LD_INT 1
2471: ARRAY
2472: PUSH
2473: LD_INT 7
2475: PUSH
2476: LD_INT 8
2478: PUSH
2479: EMPTY
2480: LIST
2481: LIST
2482: IN
2483: IFFALSE 2513
// begin bc_kind1 := i [ 7 ] ;
2485: LD_ADDR_OWVAR 44
2489: PUSH
2490: LD_VAR 0 3
2494: PUSH
2495: LD_INT 7
2497: ARRAY
2498: ST_TO_ADDR
// bc_kind2 := i [ 8 ] ;
2499: LD_ADDR_OWVAR 45
2503: PUSH
2504: LD_VAR 0 3
2508: PUSH
2509: LD_INT 8
2511: ARRAY
2512: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
2513: LD_ADDR_VAR 0 4
2517: PUSH
2518: LD_VAR 0 3
2522: PUSH
2523: LD_INT 2
2525: ARRAY
2526: PPUSH
2527: LD_VAR 0 3
2531: PUSH
2532: LD_INT 3
2534: ARRAY
2535: PPUSH
2536: LD_VAR 0 3
2540: PUSH
2541: LD_INT 4
2543: ARRAY
2544: PPUSH
2545: CALL_OW 47
2549: ST_TO_ADDR
// if GetBType ( b ) = b_bunker then
2550: LD_VAR 0 4
2554: PPUSH
2555: CALL_OW 266
2559: PUSH
2560: LD_INT 32
2562: EQUAL
2563: IFFALSE 2583
// begin PlaceWeaponTurret ( b , i [ 7 ] ) ;
2565: LD_VAR 0 4
2569: PPUSH
2570: LD_VAR 0 3
2574: PUSH
2575: LD_INT 7
2577: ARRAY
2578: PPUSH
2579: CALL_OW 431
// end ; end ;
2583: GO 2433
2585: POP
2586: POP
// end ; end_of_file
2587: LD_VAR 0 1
2591: RET
// export function Action ; var points , i , sol , team , filter ; begin
2592: LD_INT 0
2594: PPUSH
2595: PPUSH
2596: PPUSH
2597: PPUSH
2598: PPUSH
2599: PPUSH
// InGameOn ;
2600: CALL_OW 8
// CenterNowOnXY ( 33 , 11 ) ;
2604: LD_INT 33
2606: PPUSH
2607: LD_INT 11
2609: PPUSH
2610: CALL_OW 86
// points := [ [ 29 , 21 ] , [ 41 , 28 ] , [ 52 , 26 ] , [ 49 , 16 ] ] ;
2614: LD_ADDR_VAR 0 2
2618: PUSH
2619: LD_INT 29
2621: PUSH
2622: LD_INT 21
2624: PUSH
2625: EMPTY
2626: LIST
2627: LIST
2628: PUSH
2629: LD_INT 41
2631: PUSH
2632: LD_INT 28
2634: PUSH
2635: EMPTY
2636: LIST
2637: LIST
2638: PUSH
2639: LD_INT 52
2641: PUSH
2642: LD_INT 26
2644: PUSH
2645: EMPTY
2646: LIST
2647: LIST
2648: PUSH
2649: LD_INT 49
2651: PUSH
2652: LD_INT 16
2654: PUSH
2655: EMPTY
2656: LIST
2657: LIST
2658: PUSH
2659: EMPTY
2660: LIST
2661: LIST
2662: LIST
2663: LIST
2664: ST_TO_ADDR
// sol := ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , 1 ] ] ) diff [ JMM , Brown , Cyrus , Bobby , Gladstone , Houten , Khatam ] ) [ 1 ] ;
2665: LD_ADDR_VAR 0 4
2669: PUSH
2670: LD_INT 22
2672: PUSH
2673: LD_INT 1
2675: PUSH
2676: EMPTY
2677: LIST
2678: LIST
2679: PUSH
2680: LD_INT 26
2682: PUSH
2683: LD_INT 1
2685: PUSH
2686: EMPTY
2687: LIST
2688: LIST
2689: PUSH
2690: EMPTY
2691: LIST
2692: LIST
2693: PPUSH
2694: CALL_OW 69
2698: PUSH
2699: LD_EXP 7
2703: PUSH
2704: LD_EXP 14
2708: PUSH
2709: LD_EXP 11
2713: PUSH
2714: LD_EXP 12
2718: PUSH
2719: LD_EXP 8
2723: PUSH
2724: LD_EXP 15
2728: PUSH
2729: LD_EXP 16
2733: PUSH
2734: EMPTY
2735: LIST
2736: LIST
2737: LIST
2738: LIST
2739: LIST
2740: LIST
2741: LIST
2742: DIFF
2743: PUSH
2744: LD_INT 1
2746: ARRAY
2747: ST_TO_ADDR
// if sol then
2748: LD_VAR 0 4
2752: IFFALSE 2783
// begin ComMoveXY ( sol , 50 , 18 ) ;
2754: LD_VAR 0 4
2758: PPUSH
2759: LD_INT 50
2761: PPUSH
2762: LD_INT 18
2764: PPUSH
2765: CALL_OW 111
// AddComTurnUnit ( sol , Harisson ) ;
2769: LD_VAR 0 4
2773: PPUSH
2774: LD_EXP 17
2778: PPUSH
2779: CALL_OW 179
// end ; for i in points do
2783: LD_ADDR_VAR 0 3
2787: PUSH
2788: LD_VAR 0 2
2792: PUSH
2793: FOR_IN
2794: IFFALSE 2825
// AddComMoveXY ( Harisson , i [ 1 ] , i [ 2 ] ) ;
2796: LD_EXP 17
2800: PPUSH
2801: LD_VAR 0 3
2805: PUSH
2806: LD_INT 1
2808: ARRAY
2809: PPUSH
2810: LD_VAR 0 3
2814: PUSH
2815: LD_INT 2
2817: ARRAY
2818: PPUSH
2819: CALL_OW 171
2823: GO 2793
2825: POP
2826: POP
// AddComExitVehicle ( Harisson ) ;
2827: LD_EXP 17
2831: PPUSH
2832: CALL_OW 181
// repeat wait ( 3 ) ;
2836: LD_INT 3
2838: PPUSH
2839: CALL_OW 67
// until not IsInUnit ( Harisson ) ;
2843: LD_EXP 17
2847: PPUSH
2848: CALL_OW 310
2852: NOT
2853: IFFALSE 2836
// Say ( sol , D1-Sol1-1 ) ;
2855: LD_VAR 0 4
2859: PPUSH
2860: LD_STRING D1-Sol1-1
2862: PPUSH
2863: CALL_OW 88
// ComTurnUnit ( Harisson , sol ) ;
2867: LD_EXP 17
2871: PPUSH
2872: LD_VAR 0 4
2876: PPUSH
2877: CALL_OW 119
// Say ( Harisson , D1-Har-1 ) ;
2881: LD_EXP 17
2885: PPUSH
2886: LD_STRING D1-Har-1
2888: PPUSH
2889: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
2893: LD_INT 10
2895: PPUSH
2896: CALL_OW 67
// ComMoveXY ( sol , 35 , 21 ) ;
2900: LD_VAR 0 4
2904: PPUSH
2905: LD_INT 35
2907: PPUSH
2908: LD_INT 21
2910: PPUSH
2911: CALL_OW 111
// ComExitBuilding ( JMM ) ;
2915: LD_EXP 7
2919: PPUSH
2920: CALL_OW 122
// AddComMoveUnit ( JMM , Harisson ) ;
2924: LD_EXP 7
2928: PPUSH
2929: LD_EXP 17
2933: PPUSH
2934: CALL_OW 172
// ComTurnUnit ( Harisson , JMM ) ;
2938: LD_EXP 17
2942: PPUSH
2943: LD_EXP 7
2947: PPUSH
2948: CALL_OW 119
// repeat wait ( 3 ) ;
2952: LD_INT 3
2954: PPUSH
2955: CALL_OW 67
// until GetDistUnits ( JMM , Harisson ) < 4 ;
2959: LD_EXP 7
2963: PPUSH
2964: LD_EXP 17
2968: PPUSH
2969: CALL_OW 296
2973: PUSH
2974: LD_INT 4
2976: LESS
2977: IFFALSE 2952
// ComTurnUnit ( JMM , Harisson ) ;
2979: LD_EXP 7
2983: PPUSH
2984: LD_EXP 17
2988: PPUSH
2989: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
2993: LD_EXP 7
2997: PPUSH
2998: LD_STRING D1-JMM-1
3000: PPUSH
3001: CALL_OW 88
// Say ( Harisson , D1-Har-2 ) ;
3005: LD_EXP 17
3009: PPUSH
3010: LD_STRING D1-Har-2
3012: PPUSH
3013: CALL_OW 88
// Say ( JMM , D1-JMM-2 ) ;
3017: LD_EXP 7
3021: PPUSH
3022: LD_STRING D1-JMM-2
3024: PPUSH
3025: CALL_OW 88
// Say ( Harisson , D1-Har-3 ) ;
3029: LD_EXP 17
3033: PPUSH
3034: LD_STRING D1-Har-3
3036: PPUSH
3037: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
3041: LD_EXP 7
3045: PPUSH
3046: LD_STRING D1-JMM-3
3048: PPUSH
3049: CALL_OW 88
// Say ( Harisson , D1-Har-4 ) ;
3053: LD_EXP 17
3057: PPUSH
3058: LD_STRING D1-Har-4
3060: PPUSH
3061: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
3065: LD_EXP 7
3069: PPUSH
3070: LD_STRING D1-JMM-4
3072: PPUSH
3073: CALL_OW 88
// Say ( Harisson , D1-Har-5 ) ;
3077: LD_EXP 17
3081: PPUSH
3082: LD_STRING D1-Har-5
3084: PPUSH
3085: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
3089: LD_EXP 7
3093: PPUSH
3094: LD_STRING D1-JMM-5
3096: PPUSH
3097: CALL_OW 88
// Say ( Harisson , D1-Har-6 ) ;
3101: LD_EXP 17
3105: PPUSH
3106: LD_STRING D1-Har-6
3108: PPUSH
3109: CALL_OW 88
// Say ( JMM , D1-JMM-6 ) ;
3113: LD_EXP 7
3117: PPUSH
3118: LD_STRING D1-JMM-6
3120: PPUSH
3121: CALL_OW 88
// EndMission ;
3125: CALL 3134 0 0
// end ;
3129: LD_VAR 0 1
3133: RET
// export function EndMission ; var commander , i , all ; begin
3134: LD_INT 0
3136: PPUSH
3137: PPUSH
3138: PPUSH
3139: PPUSH
// case gamma_commander of 1 :
3140: LD_EXP 18
3144: PUSH
3145: LD_INT 1
3147: DOUBLE
3148: EQUAL
3149: IFTRUE 3153
3151: GO 3166
3153: POP
// commander := Donaldson ; 2 :
3154: LD_ADDR_VAR 0 2
3158: PUSH
3159: LD_EXP 13
3163: ST_TO_ADDR
3164: GO 3209
3166: LD_INT 2
3168: DOUBLE
3169: EQUAL
3170: IFTRUE 3174
3172: GO 3187
3174: POP
// commander := Brown ; 3 :
3175: LD_ADDR_VAR 0 2
3179: PUSH
3180: LD_EXP 14
3184: ST_TO_ADDR
3185: GO 3209
3187: LD_INT 3
3189: DOUBLE
3190: EQUAL
3191: IFTRUE 3195
3193: GO 3208
3195: POP
// commander := Houten ; end ;
3196: LD_ADDR_VAR 0 2
3200: PUSH
3201: LD_EXP 15
3205: ST_TO_ADDR
3206: GO 3209
3208: POP
// all := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) diff [ JMM , commander ] ;
3209: LD_ADDR_VAR 0 4
3213: PUSH
3214: LD_INT 22
3216: PUSH
3217: LD_INT 1
3219: PUSH
3220: EMPTY
3221: LIST
3222: LIST
3223: PUSH
3224: LD_INT 21
3226: PUSH
3227: LD_INT 1
3229: PUSH
3230: EMPTY
3231: LIST
3232: LIST
3233: PUSH
3234: EMPTY
3235: LIST
3236: LIST
3237: PPUSH
3238: CALL_OW 69
3242: PUSH
3243: LD_EXP 7
3247: PUSH
3248: LD_VAR 0 2
3252: PUSH
3253: EMPTY
3254: LIST
3255: LIST
3256: DIFF
3257: ST_TO_ADDR
// save_group := CharacterSelection ( 1 , 10 , 10 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ all ^ [ sel_dont_change_class , sel_not_changeable , [ commander , Harisson ] ] , [ [ class_soldier , 3 ] , [ class_mechanic , 3 , 6 ] , [ class_scientistic , 1 ] ] ) ;
3258: LD_ADDR_EXP 4
3262: PUSH
3263: LD_STRING 1
3265: PPUSH
3266: LD_INT 10
3268: PPUSH
3269: LD_INT 10
3271: PPUSH
3272: LD_INT -5
3274: PUSH
3275: LD_EXP 7
3279: PUSH
3280: LD_INT -2
3282: PUSH
3283: LD_INT -3
3285: PUSH
3286: LD_INT -5
3288: PUSH
3289: EMPTY
3290: LIST
3291: LIST
3292: LIST
3293: LIST
3294: LIST
3295: PUSH
3296: LD_VAR 0 4
3300: ADD
3301: PUSH
3302: LD_INT -6
3304: PUSH
3305: LD_INT -4
3307: PUSH
3308: LD_VAR 0 2
3312: PUSH
3313: LD_EXP 17
3317: PUSH
3318: EMPTY
3319: LIST
3320: LIST
3321: PUSH
3322: EMPTY
3323: LIST
3324: LIST
3325: LIST
3326: ADD
3327: PPUSH
3328: LD_INT 1
3330: PUSH
3331: LD_INT 3
3333: PUSH
3334: EMPTY
3335: LIST
3336: LIST
3337: PUSH
3338: LD_INT 3
3340: PUSH
3341: LD_INT 3
3343: PUSH
3344: LD_INT 6
3346: PUSH
3347: EMPTY
3348: LIST
3349: LIST
3350: LIST
3351: PUSH
3352: LD_INT 4
3354: PUSH
3355: LD_INT 1
3357: PUSH
3358: EMPTY
3359: LIST
3360: LIST
3361: PUSH
3362: EMPTY
3363: LIST
3364: LIST
3365: LIST
3366: PPUSH
3367: CALL_OW 42
3371: ST_TO_ADDR
// SaveCharacters ( all diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , Houten , Harisson , Khatam ] ^ save_group , 07_othersGamma ) ;
3372: LD_VAR 0 4
3376: PUSH
3377: LD_EXP 7
3381: PUSH
3382: LD_EXP 8
3386: PUSH
3387: LD_EXP 10
3391: PUSH
3392: LD_EXP 11
3396: PUSH
3397: LD_EXP 12
3401: PUSH
3402: LD_EXP 9
3406: PUSH
3407: LD_EXP 13
3411: PUSH
3412: LD_EXP 14
3416: PUSH
3417: LD_EXP 15
3421: PUSH
3422: LD_EXP 17
3426: PUSH
3427: LD_EXP 16
3431: PUSH
3432: EMPTY
3433: LIST
3434: LIST
3435: LIST
3436: LIST
3437: LIST
3438: LIST
3439: LIST
3440: LIST
3441: LIST
3442: LIST
3443: LIST
3444: PUSH
3445: LD_EXP 4
3449: ADD
3450: DIFF
3451: PPUSH
3452: LD_STRING 07_othersGamma
3454: PPUSH
3455: CALL_OW 38
// SaveCharacters ( save_group diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , Houten , Harisson , Khatam , 0 ] , 07_others ) ;
3459: LD_EXP 4
3463: PUSH
3464: LD_EXP 7
3468: PUSH
3469: LD_EXP 8
3473: PUSH
3474: LD_EXP 10
3478: PUSH
3479: LD_EXP 11
3483: PUSH
3484: LD_EXP 12
3488: PUSH
3489: LD_EXP 9
3493: PUSH
3494: LD_EXP 13
3498: PUSH
3499: LD_EXP 14
3503: PUSH
3504: LD_EXP 15
3508: PUSH
3509: LD_EXP 17
3513: PUSH
3514: LD_EXP 16
3518: PUSH
3519: LD_INT 0
3521: PUSH
3522: EMPTY
3523: LIST
3524: LIST
3525: LIST
3526: LIST
3527: LIST
3528: LIST
3529: LIST
3530: LIST
3531: LIST
3532: LIST
3533: LIST
3534: LIST
3535: DIFF
3536: PPUSH
3537: LD_STRING 07_others
3539: PPUSH
3540: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
3544: LD_EXP 7
3548: PPUSH
3549: LD_EXP 5
3553: PUSH
3554: LD_STRING JMM
3556: STR
3557: PPUSH
3558: CALL_OW 38
// if Lisa then
3562: LD_EXP 10
3566: IFFALSE 3608
// begin SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
3568: LD_EXP 10
3572: PPUSH
3573: LD_EXP 5
3577: PUSH
3578: LD_STRING Lisa
3580: STR
3581: PPUSH
3582: CALL_OW 38
// if Lisa in save_group then
3586: LD_EXP 10
3590: PUSH
3591: LD_EXP 4
3595: IN
3596: IFFALSE 3608
// SaveVariable ( true , LisaIn07 ) ;
3598: LD_INT 1
3600: PPUSH
3601: LD_STRING LisaIn07
3603: PPUSH
3604: CALL_OW 39
// end ; if Bobby then
3608: LD_EXP 12
3612: IFFALSE 3654
// begin SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
3614: LD_EXP 12
3618: PPUSH
3619: LD_EXP 5
3623: PUSH
3624: LD_STRING Bobby
3626: STR
3627: PPUSH
3628: CALL_OW 38
// if Bobby in save_group then
3632: LD_EXP 12
3636: PUSH
3637: LD_EXP 4
3641: IN
3642: IFFALSE 3654
// SaveVariable ( true , BobbyIn07 ) ;
3644: LD_INT 1
3646: PPUSH
3647: LD_STRING BobbyIn07
3649: PPUSH
3650: CALL_OW 39
// end ; if Cyrus then
3654: LD_EXP 11
3658: IFFALSE 3700
// begin SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
3660: LD_EXP 11
3664: PPUSH
3665: LD_EXP 5
3669: PUSH
3670: LD_STRING Cyrus
3672: STR
3673: PPUSH
3674: CALL_OW 38
// if Cyrus in save_group then
3678: LD_EXP 11
3682: PUSH
3683: LD_EXP 4
3687: IN
3688: IFFALSE 3700
// SaveVariable ( true , CyrusIn07 ) ;
3690: LD_INT 1
3692: PPUSH
3693: LD_STRING CyrusIn07
3695: PPUSH
3696: CALL_OW 39
// end ; if Brown then
3700: LD_EXP 14
3704: IFFALSE 3746
// begin SaveCharacters ( Brown , mission_prefix & Brown ) ;
3706: LD_EXP 14
3710: PPUSH
3711: LD_EXP 5
3715: PUSH
3716: LD_STRING Brown
3718: STR
3719: PPUSH
3720: CALL_OW 38
// if Brown in save_group then
3724: LD_EXP 14
3728: PUSH
3729: LD_EXP 4
3733: IN
3734: IFFALSE 3746
// SaveVariable ( true , BrownIn07 ) ;
3736: LD_INT 1
3738: PPUSH
3739: LD_STRING BrownIn07
3741: PPUSH
3742: CALL_OW 39
// end ; if Donaldson then
3746: LD_EXP 13
3750: IFFALSE 3792
// begin SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
3752: LD_EXP 13
3756: PPUSH
3757: LD_EXP 5
3761: PUSH
3762: LD_STRING Donaldson
3764: STR
3765: PPUSH
3766: CALL_OW 38
// if Donaldson in save_group then
3770: LD_EXP 13
3774: PUSH
3775: LD_EXP 4
3779: IN
3780: IFFALSE 3792
// SaveVariable ( true , DonaldsonIn07 ) ;
3782: LD_INT 1
3784: PPUSH
3785: LD_STRING DonaldsonIn07
3787: PPUSH
3788: CALL_OW 39
// end ; if Gladstone then
3792: LD_EXP 8
3796: IFFALSE 3838
// begin SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
3798: LD_EXP 8
3802: PPUSH
3803: LD_EXP 5
3807: PUSH
3808: LD_STRING Gladstone
3810: STR
3811: PPUSH
3812: CALL_OW 38
// if Gladstone in save_group then
3816: LD_EXP 8
3820: PUSH
3821: LD_EXP 4
3825: IN
3826: IFFALSE 3838
// SaveVariable ( true , GladstoneIn07 ) ;
3828: LD_INT 1
3830: PPUSH
3831: LD_STRING GladstoneIn07
3833: PPUSH
3834: CALL_OW 39
// end ; if Khatam then
3838: LD_EXP 16
3842: IFFALSE 3884
// begin SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
3844: LD_EXP 16
3848: PPUSH
3849: LD_EXP 5
3853: PUSH
3854: LD_STRING Khatam
3856: STR
3857: PPUSH
3858: CALL_OW 38
// if Khatam in save_group then
3862: LD_EXP 16
3866: PUSH
3867: LD_EXP 4
3871: IN
3872: IFFALSE 3884
// SaveVariable ( true , KhatamIn07 ) ;
3874: LD_INT 1
3876: PPUSH
3877: LD_STRING KhatamIn07
3879: PPUSH
3880: CALL_OW 39
// end ; ChangeMap ( 1 , %_cont ) ;
3884: LD_INT 1
3886: PPUSH
3887: LD_STRING %_cont
3889: PPUSH
3890: CALL_OW 340
// end ; end_of_file
3894: LD_VAR 0 1
3898: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
3899: LD_INT 0
3901: PPUSH
3902: PPUSH
// if exist_mode then
3903: LD_VAR 0 2
3907: IFFALSE 3932
// unit := CreateCharacter ( prefix & ident ) else
3909: LD_ADDR_VAR 0 5
3913: PUSH
3914: LD_VAR 0 3
3918: PUSH
3919: LD_VAR 0 1
3923: STR
3924: PPUSH
3925: CALL_OW 34
3929: ST_TO_ADDR
3930: GO 3947
// unit := NewCharacter ( ident ) ;
3932: LD_ADDR_VAR 0 5
3936: PUSH
3937: LD_VAR 0 1
3941: PPUSH
3942: CALL_OW 25
3946: ST_TO_ADDR
// result := unit ;
3947: LD_ADDR_VAR 0 4
3951: PUSH
3952: LD_VAR 0 5
3956: ST_TO_ADDR
// end ;
3957: LD_VAR 0 4
3961: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
3962: LD_INT 0
3964: PPUSH
// uc_side := side ;
3965: LD_ADDR_OWVAR 20
3969: PUSH
3970: LD_VAR 0 1
3974: ST_TO_ADDR
// uc_nation := nation ;
3975: LD_ADDR_OWVAR 21
3979: PUSH
3980: LD_VAR 0 2
3984: ST_TO_ADDR
// vc_chassis := chassis ;
3985: LD_ADDR_OWVAR 37
3989: PUSH
3990: LD_VAR 0 3
3994: ST_TO_ADDR
// vc_engine := engine ;
3995: LD_ADDR_OWVAR 39
3999: PUSH
4000: LD_VAR 0 4
4004: ST_TO_ADDR
// vc_control := control ;
4005: LD_ADDR_OWVAR 38
4009: PUSH
4010: LD_VAR 0 5
4014: ST_TO_ADDR
// vc_weapon := weapon ;
4015: LD_ADDR_OWVAR 40
4019: PUSH
4020: LD_VAR 0 6
4024: ST_TO_ADDR
// vc_fuel_battery := fuel ;
4025: LD_ADDR_OWVAR 41
4029: PUSH
4030: LD_VAR 0 7
4034: ST_TO_ADDR
// result := CreateVehicle ;
4035: LD_ADDR_VAR 0 8
4039: PUSH
4040: CALL_OW 45
4044: ST_TO_ADDR
// end ;
4045: LD_VAR 0 8
4049: RET
// export function SayX ( units , ident ) ; var i ; begin
4050: LD_INT 0
4052: PPUSH
4053: PPUSH
// result := false ;
4054: LD_ADDR_VAR 0 3
4058: PUSH
4059: LD_INT 0
4061: ST_TO_ADDR
// if not units then
4062: LD_VAR 0 1
4066: NOT
4067: IFFALSE 4071
// exit ;
4069: GO 4125
// for i in units do
4071: LD_ADDR_VAR 0 4
4075: PUSH
4076: LD_VAR 0 1
4080: PUSH
4081: FOR_IN
4082: IFFALSE 4123
// if IsOk ( i ) then
4084: LD_VAR 0 4
4088: PPUSH
4089: CALL_OW 302
4093: IFFALSE 4121
// begin Say ( i , ident ) ;
4095: LD_VAR 0 4
4099: PPUSH
4100: LD_VAR 0 2
4104: PPUSH
4105: CALL_OW 88
// result := i ;
4109: LD_ADDR_VAR 0 3
4113: PUSH
4114: LD_VAR 0 4
4118: ST_TO_ADDR
// break ;
4119: GO 4123
// end ;
4121: GO 4081
4123: POP
4124: POP
// end ;
4125: LD_VAR 0 3
4129: RET
