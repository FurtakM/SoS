// export JMM , Bobby , Cyrus , Lisa , Frank ; export RandomBeforeMission ; export Brown , Dickens , Woodruff , Knight , Claptopn , Campell , Donaldson ; export Harisson ; export Stolypin ; export ruSoldMinLevel , ruSoldMaxLevel ; export russianTanks , russianDamageTanks ; export baseReadyToBuild ; export ruPDepot , ruPLab ; export firstRussianAttack ; export saveDonaldson ; export frankScoutBase ; export harrAnswer ; export timeToDestroyRuBase , timeToSupport , timerStatus , startTimer ; export factoryDialog , bunkerDialog , energyVDialog ; export buildOil , buildPower ; export supply ; export AIEnable ; export lostCounter ; export honor ; export escapeAvalaible ; export donaldsonCoopAttack ; export vehicleProduceCounter , ruMech ; export bonusAvalaible ; export debugMode ; export ruMobile ; export specAttack ; export mission_prefix , mission_prefix_prev ; starting begin Resetfog ;
   0: CALL_OW 335
// InGameOn ;
   4: CALL_OW 8
// RandomizeAll ;
   8: CALL_OW 11
// mission_prefix := 04_ ;
  12: LD_ADDR_EXP 48
  16: PUSH
  17: LD_STRING 04_
  19: ST_TO_ADDR
// mission_prefix_prev := 03_ ;
  20: LD_ADDR_EXP 49
  24: PUSH
  25: LD_STRING 03_
  27: ST_TO_ADDR
// ruSoldMinLevel = 0 ;
  28: LD_ADDR_EXP 16
  32: PUSH
  33: LD_INT 0
  35: ST_TO_ADDR
// ruSoldMaxLevel = 0 ;
  36: LD_ADDR_EXP 17
  40: PUSH
  41: LD_INT 0
  43: ST_TO_ADDR
// baseReadyToBuild = 0 ;
  44: LD_ADDR_EXP 20
  48: PUSH
  49: LD_INT 0
  51: ST_TO_ADDR
// debugMode = 0 ;
  52: LD_ADDR_EXP 45
  56: PUSH
  57: LD_INT 0
  59: ST_TO_ADDR
// vehicleProduceCounter := 0 ;
  60: LD_ADDR_EXP 42
  64: PUSH
  65: LD_INT 0
  67: ST_TO_ADDR
// bonusAvalaible = 0 ;
  68: LD_ADDR_EXP 44
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// firstRussianAttack = 0 ;
  76: LD_ADDR_EXP 23
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// saveDonaldson = 0 ;
  84: LD_ADDR_EXP 24
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// frankScoutBase = 0 ;
  92: LD_ADDR_EXP 25
  96: PUSH
  97: LD_INT 0
  99: ST_TO_ADDR
// harrAnswer = 0 ;
 100: LD_ADDR_EXP 26
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// timeToDestroyRuBase = 0 ;
 108: LD_ADDR_EXP 27
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// timeToSupport = 9 9$00 ;
 116: LD_ADDR_EXP 28
 120: PUSH
 121: LD_INT 18900
 123: ST_TO_ADDR
// timerStatus = 0 ;
 124: LD_ADDR_EXP 29
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// startTimer = 0 ;
 132: LD_ADDR_EXP 30
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// factoryDialog = 0 ;
 140: LD_ADDR_EXP 31
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// bunkerDialog = 0 ;
 148: LD_ADDR_EXP 32
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// energyVDialog = 0 ;
 156: LD_ADDR_EXP 33
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// buildOil = 0 ;
 164: LD_ADDR_EXP 34
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// buildPower = 0 ;
 172: LD_ADDR_EXP 35
 176: PUSH
 177: LD_INT 0
 179: ST_TO_ADDR
// supply = [ 14 , 12 , 11 ] [ Difficulty ] ;
 180: LD_ADDR_EXP 36
 184: PUSH
 185: LD_INT 14
 187: PUSH
 188: LD_INT 12
 190: PUSH
 191: LD_INT 11
 193: PUSH
 194: EMPTY
 195: LIST
 196: LIST
 197: LIST
 198: PUSH
 199: LD_OWVAR 67
 203: ARRAY
 204: ST_TO_ADDR
// AIEnable = 1 ;
 205: LD_ADDR_EXP 37
 209: PUSH
 210: LD_INT 1
 212: ST_TO_ADDR
// donaldsonCoopAttack = 0 ;
 213: LD_ADDR_EXP 41
 217: PUSH
 218: LD_INT 0
 220: ST_TO_ADDR
// lostCounter = 0 ;
 221: LD_ADDR_EXP 38
 225: PUSH
 226: LD_INT 0
 228: ST_TO_ADDR
// honor = 1 ;
 229: LD_ADDR_EXP 39
 233: PUSH
 234: LD_INT 1
 236: ST_TO_ADDR
// escapeAvalaible = 0 ;
 237: LD_ADDR_EXP 40
 241: PUSH
 242: LD_INT 0
 244: ST_TO_ADDR
// specAttack := false ;
 245: LD_ADDR_EXP 47
 249: PUSH
 250: LD_INT 0
 252: ST_TO_ADDR
// ruMobile := [ ] ;
 253: LD_ADDR_EXP 46
 257: PUSH
 258: EMPTY
 259: ST_TO_ADDR
// ruMech := [ 3 , 4 , 6 ] [ Difficulty ] ;
 260: LD_ADDR_EXP 43
 264: PUSH
 265: LD_INT 3
 267: PUSH
 268: LD_INT 4
 270: PUSH
 271: LD_INT 6
 273: PUSH
 274: EMPTY
 275: LIST
 276: LIST
 277: LIST
 278: PUSH
 279: LD_OWVAR 67
 283: ARRAY
 284: ST_TO_ADDR
// PrepareDifficulty ;
 285: CALL 4581 0 0
// PrepareRussianBase ;
 289: CALL 2810 0 0
// PrepareRussianCommander ;
 293: CALL 2761 0 0
// PrepareHeroes ;
 297: CALL 479 0 0
// SetBName ( ambdept0 , gamma ) ;
 301: LD_INT 4
 303: PPUSH
 304: LD_STRING gamma
 306: PPUSH
 307: CALL_OW 500
// SetBName ( rubware0 , fyodor ) ;
 311: LD_INT 21
 313: PPUSH
 314: LD_STRING fyodor
 316: PPUSH
 317: CALL_OW 500
// end ;
 321: END
// every 0 0$1 trigger debugMode = 1 do var i ;
 322: LD_EXP 45
 326: PUSH
 327: LD_INT 1
 329: EQUAL
 330: IFFALSE 435
 332: GO 334
 334: DISABLE
 335: LD_INT 0
 337: PPUSH
// begin enable ;
 338: ENABLE
// fogoff ( true ) ;
 339: LD_INT 1
 341: PPUSH
 342: CALL_OW 344
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) do
 346: LD_ADDR_VAR 0 1
 350: PUSH
 351: LD_INT 22
 353: PUSH
 354: LD_INT 1
 356: PUSH
 357: EMPTY
 358: LIST
 359: LIST
 360: PUSH
 361: LD_INT 21
 363: PUSH
 364: LD_INT 1
 366: PUSH
 367: EMPTY
 368: LIST
 369: LIST
 370: PUSH
 371: EMPTY
 372: LIST
 373: LIST
 374: PPUSH
 375: CALL_OW 69
 379: PUSH
 380: FOR_IN
 381: IFFALSE 397
// SetLives ( i , 1000 ) ;
 383: LD_VAR 0 1
 387: PPUSH
 388: LD_INT 1000
 390: PPUSH
 391: CALL_OW 234
 395: GO 380
 397: POP
 398: POP
// SetResourceType ( GetBase ( ambdept0 ) , 1 , 9999 ) ;
 399: LD_INT 4
 401: PPUSH
 402: CALL_OW 274
 406: PPUSH
 407: LD_INT 1
 409: PPUSH
 410: LD_INT 9999
 412: PPUSH
 413: CALL_OW 277
// SetResourceType ( GetBase ( ambdept0 ) , 2 , 9999 ) ;
 417: LD_INT 4
 419: PPUSH
 420: CALL_OW 274
 424: PPUSH
 425: LD_INT 2
 427: PPUSH
 428: LD_INT 9999
 430: PPUSH
 431: CALL_OW 277
// end ;
 435: PPOPN 1
 437: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , ru_gun ] ] ) do
 438: LD_INT 22
 440: PUSH
 441: LD_INT 1
 443: PUSH
 444: EMPTY
 445: LIST
 446: LIST
 447: PUSH
 448: LD_INT 34
 450: PUSH
 451: LD_INT 44
 453: PUSH
 454: EMPTY
 455: LIST
 456: LIST
 457: PUSH
 458: EMPTY
 459: LIST
 460: LIST
 461: PPUSH
 462: CALL_OW 69
 466: IFFALSE 478
 468: GO 470
 470: DISABLE
// SetAchievement ( ACH_GUN ) ; end_of_file
 471: LD_STRING ACH_GUN
 473: PPUSH
 474: CALL_OW 543
 478: END
// export function PrepareHeroes ; var i , tmp ; begin
 479: LD_INT 0
 481: PPUSH
 482: PPUSH
 483: PPUSH
// uc_side = 1 ;
 484: LD_ADDR_OWVAR 20
 488: PUSH
 489: LD_INT 1
 491: ST_TO_ADDR
// uc_nation = 1 ;
 492: LD_ADDR_OWVAR 21
 496: PUSH
 497: LD_INT 1
 499: ST_TO_ADDR
// JMM = PrepareUnit ( JMM , true ) ;
 500: LD_ADDR_EXP 1
 504: PUSH
 505: LD_STRING JMM
 507: PPUSH
 508: LD_INT 1
 510: PPUSH
 511: CALL 4183 0 2
 515: ST_TO_ADDR
// Lisa = PrepareUnit ( Lisa , true ) ;
 516: LD_ADDR_EXP 4
 520: PUSH
 521: LD_STRING Lisa
 523: PPUSH
 524: LD_INT 1
 526: PPUSH
 527: CALL 4183 0 2
 531: ST_TO_ADDR
// Brown = PrepareUnit ( Brown , false ) ;
 532: LD_ADDR_EXP 7
 536: PUSH
 537: LD_STRING Brown
 539: PPUSH
 540: LD_INT 0
 542: PPUSH
 543: CALL 4183 0 2
 547: ST_TO_ADDR
// Dickens = PrepareUnit ( Dickens , false ) ;
 548: LD_ADDR_EXP 8
 552: PUSH
 553: LD_STRING Dickens
 555: PPUSH
 556: LD_INT 0
 558: PPUSH
 559: CALL 4183 0 2
 563: ST_TO_ADDR
// Woodruff = PrepareUnit ( Woodruff , false ) ;
 564: LD_ADDR_EXP 9
 568: PUSH
 569: LD_STRING Woodruff
 571: PPUSH
 572: LD_INT 0
 574: PPUSH
 575: CALL 4183 0 2
 579: ST_TO_ADDR
// Campell = PrepareUnit ( Campell , false ) ;
 580: LD_ADDR_EXP 12
 584: PUSH
 585: LD_STRING Campell
 587: PPUSH
 588: LD_INT 0
 590: PPUSH
 591: CALL 4183 0 2
 595: ST_TO_ADDR
// Knight = PrepareUnit ( Knight , false ) ;
 596: LD_ADDR_EXP 10
 600: PUSH
 601: LD_STRING Knight
 603: PPUSH
 604: LD_INT 0
 606: PPUSH
 607: CALL 4183 0 2
 611: ST_TO_ADDR
// Claptopn = PrepareUnit ( Claptopn , false ) ;
 612: LD_ADDR_EXP 11
 616: PUSH
 617: LD_STRING Claptopn
 619: PPUSH
 620: LD_INT 0
 622: PPUSH
 623: CALL 4183 0 2
 627: ST_TO_ADDR
// Harisson = PrepareUnit ( Harisson , false ) ;
 628: LD_ADDR_EXP 14
 632: PUSH
 633: LD_STRING Harisson
 635: PPUSH
 636: LD_INT 0
 638: PPUSH
 639: CALL 4183 0 2
 643: ST_TO_ADDR
// if Lisa = false then
 644: LD_EXP 4
 648: PUSH
 649: LD_INT 0
 651: EQUAL
 652: IFFALSE 670
// Bobby = PrepareUnit ( Bobby , true ) ;
 654: LD_ADDR_EXP 2
 658: PUSH
 659: LD_STRING Bobby
 661: PPUSH
 662: LD_INT 1
 664: PPUSH
 665: CALL 4183 0 2
 669: ST_TO_ADDR
// if Lisa = false and Bobby = false then
 670: LD_EXP 4
 674: PUSH
 675: LD_INT 0
 677: EQUAL
 678: PUSH
 679: LD_EXP 2
 683: PUSH
 684: LD_INT 0
 686: EQUAL
 687: AND
 688: IFFALSE 706
// Cyrus = PrepareUnit ( Cyrus , true ) ;
 690: LD_ADDR_EXP 3
 694: PUSH
 695: LD_STRING Cyrus
 697: PPUSH
 698: LD_INT 1
 700: PPUSH
 701: CALL 4183 0 2
 705: ST_TO_ADDR
// if Lisa = false and Bobby = false and Cyrus = false then
 706: LD_EXP 4
 710: PUSH
 711: LD_INT 0
 713: EQUAL
 714: PUSH
 715: LD_EXP 2
 719: PUSH
 720: LD_INT 0
 722: EQUAL
 723: AND
 724: PUSH
 725: LD_EXP 3
 729: PUSH
 730: LD_INT 0
 732: EQUAL
 733: AND
 734: IFFALSE 833
// begin tmp = CreateCharacterSet ( 03_others ) ;
 736: LD_ADDR_VAR 0 3
 740: PUSH
 741: LD_STRING 03_others
 743: PPUSH
 744: CALL_OW 31
 748: ST_TO_ADDR
// if tmp then
 749: LD_VAR 0 3
 753: IFFALSE 810
// begin RandomBeforeMission = tmp [ 1 ] ;
 755: LD_ADDR_EXP 6
 759: PUSH
 760: LD_VAR 0 3
 764: PUSH
 765: LD_INT 1
 767: ARRAY
 768: ST_TO_ADDR
// DeleteCharacters ( 03_others ) ;
 769: LD_STRING 03_others
 771: PPUSH
 772: CALL_OW 40
// if tmp > 1 then
 776: LD_VAR 0 3
 780: PUSH
 781: LD_INT 1
 783: GREATER
 784: IFFALSE 808
// SaveCharacters ( tmp diff tmp [ 1 ] , 03_others ) ;
 786: LD_VAR 0 3
 790: PUSH
 791: LD_VAR 0 3
 795: PUSH
 796: LD_INT 1
 798: ARRAY
 799: DIFF
 800: PPUSH
 801: LD_STRING 03_others
 803: PPUSH
 804: CALL_OW 38
// end else
 808: GO 833
// begin PrepareHuman ( false , 1 , 3 ) ;
 810: LD_INT 0
 812: PPUSH
 813: LD_INT 1
 815: PPUSH
 816: LD_INT 3
 818: PPUSH
 819: CALL_OW 380
// RandomBeforeMission := CreateHuman ;
 823: LD_ADDR_EXP 6
 827: PUSH
 828: CALL_OW 44
 832: ST_TO_ADDR
// end ; end ; uc_side = 4 ;
 833: LD_ADDR_OWVAR 20
 837: PUSH
 838: LD_INT 4
 840: ST_TO_ADDR
// Donaldson = PrepareUnit ( Donaldson , false ) ;
 841: LD_ADDR_EXP 13
 845: PUSH
 846: LD_STRING Donaldson
 848: PPUSH
 849: LD_INT 0
 851: PPUSH
 852: CALL 4183 0 2
 856: ST_TO_ADDR
// if TestCharacters ( 03_Frank ) = true then
 857: LD_STRING 03_Frank
 859: PPUSH
 860: CALL_OW 28
 864: PUSH
 865: LD_INT 1
 867: EQUAL
 868: IFFALSE 912
// begin Frank = PrepareUnit ( 03_Frank , true ) ;
 870: LD_ADDR_EXP 5
 874: PUSH
 875: LD_STRING 03_Frank
 877: PPUSH
 878: LD_INT 1
 880: PPUSH
 881: CALL 4183 0 2
 885: ST_TO_ADDR
// if Frank = 0 then
 886: LD_EXP 5
 890: PUSH
 891: LD_INT 0
 893: EQUAL
 894: IFFALSE 912
// Frank = PrepareUnit ( Frank , false ) ;
 896: LD_ADDR_EXP 5
 900: PUSH
 901: LD_STRING Frank
 903: PPUSH
 904: LD_INT 0
 906: PPUSH
 907: CALL 4183 0 2
 911: ST_TO_ADDR
// end ; PlaceHumanInUnit ( JMM , amvj ) ;
 912: LD_EXP 1
 916: PPUSH
 917: LD_INT 32
 919: PPUSH
 920: CALL_OW 52
// PlaceUnitArea ( Brown , BrownSpawn , false ) ;
 924: LD_EXP 7
 928: PPUSH
 929: LD_INT 1
 931: PPUSH
 932: LD_INT 0
 934: PPUSH
 935: CALL_OW 49
// ComTurnUnit ( Brown , amvj ) ;
 939: LD_EXP 7
 943: PPUSH
 944: LD_INT 32
 946: PPUSH
 947: CALL_OW 119
// PlaceUnitArea ( Dickens , GammaPeople , false ) ;
 951: LD_EXP 8
 955: PPUSH
 956: LD_INT 2
 958: PPUSH
 959: LD_INT 0
 961: PPUSH
 962: CALL_OW 49
// PlaceUnitArea ( Woodruff , GammaPeople , false ) ;
 966: LD_EXP 9
 970: PPUSH
 971: LD_INT 2
 973: PPUSH
 974: LD_INT 0
 976: PPUSH
 977: CALL_OW 49
// PlaceUnitArea ( Campell , GammaPeople , false ) ;
 981: LD_EXP 12
 985: PPUSH
 986: LD_INT 2
 988: PPUSH
 989: LD_INT 0
 991: PPUSH
 992: CALL_OW 49
// PlaceUnitArea ( Knight , GammaPeople , false ) ;
 996: LD_EXP 10
1000: PPUSH
1001: LD_INT 2
1003: PPUSH
1004: LD_INT 0
1006: PPUSH
1007: CALL_OW 49
// PlaceUnitArea ( Claptopn , GammaPeople , false ) ;
1011: LD_EXP 11
1015: PPUSH
1016: LD_INT 2
1018: PPUSH
1019: LD_INT 0
1021: PPUSH
1022: CALL_OW 49
// PlaceUnitArea ( Lisa , GammaPeople , false ) ;
1026: LD_EXP 4
1030: PPUSH
1031: LD_INT 2
1033: PPUSH
1034: LD_INT 0
1036: PPUSH
1037: CALL_OW 49
// if Lisa = false then
1041: LD_EXP 4
1045: PUSH
1046: LD_INT 0
1048: EQUAL
1049: IFFALSE 1066
// PlaceUnitArea ( Bobby , GammaPeople , false ) ;
1051: LD_EXP 2
1055: PPUSH
1056: LD_INT 2
1058: PPUSH
1059: LD_INT 0
1061: PPUSH
1062: CALL_OW 49
// if Lisa = false and Bobby = false then
1066: LD_EXP 4
1070: PUSH
1071: LD_INT 0
1073: EQUAL
1074: PUSH
1075: LD_EXP 2
1079: PUSH
1080: LD_INT 0
1082: EQUAL
1083: AND
1084: IFFALSE 1101
// PlaceUnitArea ( Cyrus , GammaPeople , false ) ;
1086: LD_EXP 3
1090: PPUSH
1091: LD_INT 2
1093: PPUSH
1094: LD_INT 0
1096: PPUSH
1097: CALL_OW 49
// if Lisa = false and Bobby = false and Cyrus = false then
1101: LD_EXP 4
1105: PUSH
1106: LD_INT 0
1108: EQUAL
1109: PUSH
1110: LD_EXP 2
1114: PUSH
1115: LD_INT 0
1117: EQUAL
1118: AND
1119: PUSH
1120: LD_EXP 3
1124: PUSH
1125: LD_INT 0
1127: EQUAL
1128: AND
1129: IFFALSE 1146
// PlaceUnitArea ( RandomBeforeMission , GammaPeople , false ) ;
1131: LD_EXP 6
1135: PPUSH
1136: LD_INT 2
1138: PPUSH
1139: LD_INT 0
1141: PPUSH
1142: CALL_OW 49
// end ;
1146: LD_VAR 0 1
1150: RET
// export function PrepareDonaldsonArmy ; var i , un ; begin
1151: LD_INT 0
1153: PPUSH
1154: PPUSH
1155: PPUSH
// PlaceUnitArea ( Donaldson , DonaldsonArea , false ) ;
1156: LD_EXP 13
1160: PPUSH
1161: LD_INT 10
1163: PPUSH
1164: LD_INT 0
1166: PPUSH
1167: CALL_OW 49
// if Frank then
1171: LD_EXP 5
1175: IFFALSE 1192
// PlaceUnitArea ( Frank , DonaldsonArea , false ) ;
1177: LD_EXP 5
1181: PPUSH
1182: LD_INT 10
1184: PPUSH
1185: LD_INT 0
1187: PPUSH
1188: CALL_OW 49
// uc_nation = 1 ;
1192: LD_ADDR_OWVAR 21
1196: PUSH
1197: LD_INT 1
1199: ST_TO_ADDR
// uc_side = 4 ;
1200: LD_ADDR_OWVAR 20
1204: PUSH
1205: LD_INT 4
1207: ST_TO_ADDR
// hc_class := 3 ;
1208: LD_ADDR_OWVAR 28
1212: PUSH
1213: LD_INT 3
1215: ST_TO_ADDR
// hc_sex := sex_male ;
1216: LD_ADDR_OWVAR 27
1220: PUSH
1221: LD_INT 1
1223: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
1224: LD_ADDR_OWVAR 33
1228: PUSH
1229: LD_STRING SecondCharsGal
1231: ST_TO_ADDR
// hc_face_number := 53 ;
1232: LD_ADDR_OWVAR 34
1236: PUSH
1237: LD_INT 53
1239: ST_TO_ADDR
// hc_name := Freddie Warner ;
1240: LD_ADDR_OWVAR 26
1244: PUSH
1245: LD_STRING Freddie Warner
1247: ST_TO_ADDR
// hc_attr := [ 8 , 11 ] ;
1248: LD_ADDR_OWVAR 29
1252: PUSH
1253: LD_INT 8
1255: PUSH
1256: LD_INT 11
1258: PUSH
1259: EMPTY
1260: LIST
1261: LIST
1262: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 1 , 0 ] ;
1263: LD_ADDR_OWVAR 30
1267: PUSH
1268: LD_INT 0
1270: PUSH
1271: LD_INT 0
1273: PUSH
1274: LD_INT 1
1276: PUSH
1277: LD_INT 0
1279: PUSH
1280: EMPTY
1281: LIST
1282: LIST
1283: LIST
1284: LIST
1285: ST_TO_ADDR
// hc_skills := [ 1 , 0 , 3 , 0 ] ;
1286: LD_ADDR_OWVAR 31
1290: PUSH
1291: LD_INT 1
1293: PUSH
1294: LD_INT 0
1296: PUSH
1297: LD_INT 3
1299: PUSH
1300: LD_INT 0
1302: PUSH
1303: EMPTY
1304: LIST
1305: LIST
1306: LIST
1307: LIST
1308: ST_TO_ADDR
// un = CreateHuman ;
1309: LD_ADDR_VAR 0 3
1313: PUSH
1314: CALL_OW 44
1318: ST_TO_ADDR
// PlaceUnitArea ( un , DonaldsonArea , false ) ;
1319: LD_VAR 0 3
1323: PPUSH
1324: LD_INT 10
1326: PPUSH
1327: LD_INT 0
1329: PPUSH
1330: CALL_OW 49
// hc_class := 1 ;
1334: LD_ADDR_OWVAR 28
1338: PUSH
1339: LD_INT 1
1341: ST_TO_ADDR
// hc_sex := sex_male ;
1342: LD_ADDR_OWVAR 27
1346: PUSH
1347: LD_INT 1
1349: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
1350: LD_ADDR_OWVAR 33
1354: PUSH
1355: LD_STRING SecondCharsGal
1357: ST_TO_ADDR
// hc_face_number := 56 ;
1358: LD_ADDR_OWVAR 34
1362: PUSH
1363: LD_INT 56
1365: ST_TO_ADDR
// hc_name := Mel Brennan ;
1366: LD_ADDR_OWVAR 26
1370: PUSH
1371: LD_STRING Mel Brennan
1373: ST_TO_ADDR
// hc_attr := [ 12 , 11 ] ;
1374: LD_ADDR_OWVAR 29
1378: PUSH
1379: LD_INT 12
1381: PUSH
1382: LD_INT 11
1384: PUSH
1385: EMPTY
1386: LIST
1387: LIST
1388: ST_TO_ADDR
// hc_basic_skills := [ 1 , 1 , 0 , 0 ] ;
1389: LD_ADDR_OWVAR 30
1393: PUSH
1394: LD_INT 1
1396: PUSH
1397: LD_INT 1
1399: PUSH
1400: LD_INT 0
1402: PUSH
1403: LD_INT 0
1405: PUSH
1406: EMPTY
1407: LIST
1408: LIST
1409: LIST
1410: LIST
1411: ST_TO_ADDR
// hc_skills := [ 2 , 1 , 1 , 0 ] ;
1412: LD_ADDR_OWVAR 31
1416: PUSH
1417: LD_INT 2
1419: PUSH
1420: LD_INT 1
1422: PUSH
1423: LD_INT 1
1425: PUSH
1426: LD_INT 0
1428: PUSH
1429: EMPTY
1430: LIST
1431: LIST
1432: LIST
1433: LIST
1434: ST_TO_ADDR
// un = CreateHuman ;
1435: LD_ADDR_VAR 0 3
1439: PUSH
1440: CALL_OW 44
1444: ST_TO_ADDR
// PlaceUnitArea ( un , DonaldsonArea , false ) ;
1445: LD_VAR 0 3
1449: PPUSH
1450: LD_INT 10
1452: PPUSH
1453: LD_INT 0
1455: PPUSH
1456: CALL_OW 49
// hc_class := 1 ;
1460: LD_ADDR_OWVAR 28
1464: PUSH
1465: LD_INT 1
1467: ST_TO_ADDR
// hc_sex := sex_male ;
1468: LD_ADDR_OWVAR 27
1472: PUSH
1473: LD_INT 1
1475: ST_TO_ADDR
// hc_gallery := AmGalRemake ;
1476: LD_ADDR_OWVAR 33
1480: PUSH
1481: LD_STRING AmGalRemake
1483: ST_TO_ADDR
// hc_face_number := 5 ;
1484: LD_ADDR_OWVAR 34
1488: PUSH
1489: LD_INT 5
1491: ST_TO_ADDR
// hc_name := Bob Joplin ;
1492: LD_ADDR_OWVAR 26
1496: PUSH
1497: LD_STRING Bob Joplin
1499: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
1500: LD_ADDR_OWVAR 29
1504: PUSH
1505: LD_INT 10
1507: PUSH
1508: LD_INT 11
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: ST_TO_ADDR
// hc_basic_skills := [ 0 , 1 , 1 , 0 ] ;
1515: LD_ADDR_OWVAR 30
1519: PUSH
1520: LD_INT 0
1522: PUSH
1523: LD_INT 1
1525: PUSH
1526: LD_INT 1
1528: PUSH
1529: LD_INT 0
1531: PUSH
1532: EMPTY
1533: LIST
1534: LIST
1535: LIST
1536: LIST
1537: ST_TO_ADDR
// hc_skills := [ 3 , 1 , 1 , 1 ] ;
1538: LD_ADDR_OWVAR 31
1542: PUSH
1543: LD_INT 3
1545: PUSH
1546: LD_INT 1
1548: PUSH
1549: LD_INT 1
1551: PUSH
1552: LD_INT 1
1554: PUSH
1555: EMPTY
1556: LIST
1557: LIST
1558: LIST
1559: LIST
1560: ST_TO_ADDR
// un = CreateHuman ;
1561: LD_ADDR_VAR 0 3
1565: PUSH
1566: CALL_OW 44
1570: ST_TO_ADDR
// PlaceUnitArea ( un , DonaldsonArea , false ) ;
1571: LD_VAR 0 3
1575: PPUSH
1576: LD_INT 10
1578: PPUSH
1579: LD_INT 0
1581: PPUSH
1582: CALL_OW 49
// hc_class := 3 ;
1586: LD_ADDR_OWVAR 28
1590: PUSH
1591: LD_INT 3
1593: ST_TO_ADDR
// hc_sex := sex_female ;
1594: LD_ADDR_OWVAR 27
1598: PUSH
1599: LD_INT 2
1601: ST_TO_ADDR
// hc_gallery := AmGalRemake ;
1602: LD_ADDR_OWVAR 33
1606: PUSH
1607: LD_STRING AmGalRemake
1609: ST_TO_ADDR
// hc_face_number := 8 ;
1610: LD_ADDR_OWVAR 34
1614: PUSH
1615: LD_INT 8
1617: ST_TO_ADDR
// hc_name := Elizabeth Whitney ;
1618: LD_ADDR_OWVAR 26
1622: PUSH
1623: LD_STRING Elizabeth Whitney
1625: ST_TO_ADDR
// hc_attr := [ 9 , 11 ] ;
1626: LD_ADDR_OWVAR 29
1630: PUSH
1631: LD_INT 9
1633: PUSH
1634: LD_INT 11
1636: PUSH
1637: EMPTY
1638: LIST
1639: LIST
1640: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 2 , 0 ] ;
1641: LD_ADDR_OWVAR 30
1645: PUSH
1646: LD_INT 0
1648: PUSH
1649: LD_INT 0
1651: PUSH
1652: LD_INT 2
1654: PUSH
1655: LD_INT 0
1657: PUSH
1658: EMPTY
1659: LIST
1660: LIST
1661: LIST
1662: LIST
1663: ST_TO_ADDR
// hc_skills := [ 2 , 2 , 4 , 2 ] ;
1664: LD_ADDR_OWVAR 31
1668: PUSH
1669: LD_INT 2
1671: PUSH
1672: LD_INT 2
1674: PUSH
1675: LD_INT 4
1677: PUSH
1678: LD_INT 2
1680: PUSH
1681: EMPTY
1682: LIST
1683: LIST
1684: LIST
1685: LIST
1686: ST_TO_ADDR
// un = CreateHuman ;
1687: LD_ADDR_VAR 0 3
1691: PUSH
1692: CALL_OW 44
1696: ST_TO_ADDR
// PlaceUnitArea ( un , DonaldsonArea , false ) ;
1697: LD_VAR 0 3
1701: PPUSH
1702: LD_INT 10
1704: PPUSH
1705: LD_INT 0
1707: PPUSH
1708: CALL_OW 49
// InitHc ;
1712: CALL_OW 19
// end ;
1716: LD_VAR 0 1
1720: RET
// export function PrepareHarrisonSupport ( count ) ; var i , un , veh ; begin
1721: LD_INT 0
1723: PPUSH
1724: PPUSH
1725: PPUSH
1726: PPUSH
// uc_nation = 1 ;
1727: LD_ADDR_OWVAR 21
1731: PUSH
1732: LD_INT 1
1734: ST_TO_ADDR
// uc_side = 1 ;
1735: LD_ADDR_OWVAR 20
1739: PUSH
1740: LD_INT 1
1742: ST_TO_ADDR
// vc_chassis := us_medium_wheeled ;
1743: LD_ADDR_OWVAR 37
1747: PUSH
1748: LD_INT 2
1750: ST_TO_ADDR
// vc_engine := engine_combustion ;
1751: LD_ADDR_OWVAR 39
1755: PUSH
1756: LD_INT 1
1758: ST_TO_ADDR
// vc_control := control_manual ;
1759: LD_ADDR_OWVAR 38
1763: PUSH
1764: LD_INT 1
1766: ST_TO_ADDR
// vc_fuel_battery := 65 ;
1767: LD_ADDR_OWVAR 41
1771: PUSH
1772: LD_INT 65
1774: ST_TO_ADDR
// vc_weapon := [ us_double_gun , us_light_gun , us_gatling_gun ] [ Difficulty ] ;
1775: LD_ADDR_OWVAR 40
1779: PUSH
1780: LD_INT 5
1782: PUSH
1783: LD_INT 3
1785: PUSH
1786: LD_INT 4
1788: PUSH
1789: EMPTY
1790: LIST
1791: LIST
1792: LIST
1793: PUSH
1794: LD_OWVAR 67
1798: ARRAY
1799: ST_TO_ADDR
// veh := CreateVehicle ;
1800: LD_ADDR_VAR 0 5
1804: PUSH
1805: CALL_OW 45
1809: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1810: LD_VAR 0 5
1814: PPUSH
1815: LD_INT 2
1817: PPUSH
1818: CALL_OW 233
// if HexInfo ( 17 , 4 ) = 0 then
1822: LD_INT 17
1824: PPUSH
1825: LD_INT 4
1827: PPUSH
1828: CALL_OW 428
1832: PUSH
1833: LD_INT 0
1835: EQUAL
1836: IFFALSE 1858
// PlaceUnitXY ( veh , 17 , 4 , false ) else
1838: LD_VAR 0 5
1842: PPUSH
1843: LD_INT 17
1845: PPUSH
1846: LD_INT 4
1848: PPUSH
1849: LD_INT 0
1851: PPUSH
1852: CALL_OW 48
1856: GO 1876
// PlaceUnitXY ( veh , 23 , 10 , false ) ;
1858: LD_VAR 0 5
1862: PPUSH
1863: LD_INT 23
1865: PPUSH
1866: LD_INT 10
1868: PPUSH
1869: LD_INT 0
1871: PPUSH
1872: CALL_OW 48
// hc_class := 1 ;
1876: LD_ADDR_OWVAR 28
1880: PUSH
1881: LD_INT 1
1883: ST_TO_ADDR
// hc_sex := sex_male ;
1884: LD_ADDR_OWVAR 27
1888: PUSH
1889: LD_INT 1
1891: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
1892: LD_ADDR_OWVAR 33
1896: PUSH
1897: LD_STRING SecondCharsGal
1899: ST_TO_ADDR
// hc_face_number := 59 ;
1900: LD_ADDR_OWVAR 34
1904: PUSH
1905: LD_INT 59
1907: ST_TO_ADDR
// hc_name := Max Gray ;
1908: LD_ADDR_OWVAR 26
1912: PUSH
1913: LD_STRING Max Gray
1915: ST_TO_ADDR
// hc_attr := [ 9 , 11 ] ;
1916: LD_ADDR_OWVAR 29
1920: PUSH
1921: LD_INT 9
1923: PUSH
1924: LD_INT 11
1926: PUSH
1927: EMPTY
1928: LIST
1929: LIST
1930: ST_TO_ADDR
// hc_basic_skills := [ 1 , 0 , 0 , 0 ] ;
1931: LD_ADDR_OWVAR 30
1935: PUSH
1936: LD_INT 1
1938: PUSH
1939: LD_INT 0
1941: PUSH
1942: LD_INT 0
1944: PUSH
1945: LD_INT 0
1947: PUSH
1948: EMPTY
1949: LIST
1950: LIST
1951: LIST
1952: LIST
1953: ST_TO_ADDR
// hc_skills := [ 2 , 1 , 1 , 0 ] ;
1954: LD_ADDR_OWVAR 31
1958: PUSH
1959: LD_INT 2
1961: PUSH
1962: LD_INT 1
1964: PUSH
1965: LD_INT 1
1967: PUSH
1968: LD_INT 0
1970: PUSH
1971: EMPTY
1972: LIST
1973: LIST
1974: LIST
1975: LIST
1976: ST_TO_ADDR
// un = CreateHuman ;
1977: LD_ADDR_VAR 0 4
1981: PUSH
1982: CALL_OW 44
1986: ST_TO_ADDR
// PlaceUnitArea ( un , AmericansHelpArea2 , false ) ;
1987: LD_VAR 0 4
1991: PPUSH
1992: LD_INT 11
1994: PPUSH
1995: LD_INT 0
1997: PPUSH
1998: CALL_OW 49
// hc_class := 1 ;
2002: LD_ADDR_OWVAR 28
2006: PUSH
2007: LD_INT 1
2009: ST_TO_ADDR
// hc_sex := sex_male ;
2010: LD_ADDR_OWVAR 27
2014: PUSH
2015: LD_INT 1
2017: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
2018: LD_ADDR_OWVAR 33
2022: PUSH
2023: LD_STRING SecondCharsGal
2025: ST_TO_ADDR
// hc_face_number := 54 ;
2026: LD_ADDR_OWVAR 34
2030: PUSH
2031: LD_INT 54
2033: ST_TO_ADDR
// hc_name := Luigi Ghbellin ;
2034: LD_ADDR_OWVAR 26
2038: PUSH
2039: LD_STRING Luigi Ghbellin
2041: ST_TO_ADDR
// hc_attr := [ 11 , 11 ] ;
2042: LD_ADDR_OWVAR 29
2046: PUSH
2047: LD_INT 11
2049: PUSH
2050: LD_INT 11
2052: PUSH
2053: EMPTY
2054: LIST
2055: LIST
2056: ST_TO_ADDR
// hc_basic_skills := [ 1 , 0 , 0 , 0 ] ;
2057: LD_ADDR_OWVAR 30
2061: PUSH
2062: LD_INT 1
2064: PUSH
2065: LD_INT 0
2067: PUSH
2068: LD_INT 0
2070: PUSH
2071: LD_INT 0
2073: PUSH
2074: EMPTY
2075: LIST
2076: LIST
2077: LIST
2078: LIST
2079: ST_TO_ADDR
// hc_skills := [ 1 , 0 , 0 , 1 ] ;
2080: LD_ADDR_OWVAR 31
2084: PUSH
2085: LD_INT 1
2087: PUSH
2088: LD_INT 0
2090: PUSH
2091: LD_INT 0
2093: PUSH
2094: LD_INT 1
2096: PUSH
2097: EMPTY
2098: LIST
2099: LIST
2100: LIST
2101: LIST
2102: ST_TO_ADDR
// un = CreateHuman ;
2103: LD_ADDR_VAR 0 4
2107: PUSH
2108: CALL_OW 44
2112: ST_TO_ADDR
// PlaceUnitArea ( un , AmericansHelpArea2 , false ) ;
2113: LD_VAR 0 4
2117: PPUSH
2118: LD_INT 11
2120: PPUSH
2121: LD_INT 0
2123: PPUSH
2124: CALL_OW 49
// hc_class := 3 ;
2128: LD_ADDR_OWVAR 28
2132: PUSH
2133: LD_INT 3
2135: ST_TO_ADDR
// hc_sex := sex_male ;
2136: LD_ADDR_OWVAR 27
2140: PUSH
2141: LD_INT 1
2143: ST_TO_ADDR
// hc_gallery := AmGalRemake ;
2144: LD_ADDR_OWVAR 33
2148: PUSH
2149: LD_STRING AmGalRemake
2151: ST_TO_ADDR
// hc_face_number := 6 ;
2152: LD_ADDR_OWVAR 34
2156: PUSH
2157: LD_INT 6
2159: ST_TO_ADDR
// hc_name := Leon Carter ;
2160: LD_ADDR_OWVAR 26
2164: PUSH
2165: LD_STRING Leon Carter
2167: ST_TO_ADDR
// hc_attr := [ 10 , 9 ] ;
2168: LD_ADDR_OWVAR 29
2172: PUSH
2173: LD_INT 10
2175: PUSH
2176: LD_INT 9
2178: PUSH
2179: EMPTY
2180: LIST
2181: LIST
2182: ST_TO_ADDR
// hc_basic_skills := [ 0 , 1 , 1 , 0 ] ;
2183: LD_ADDR_OWVAR 30
2187: PUSH
2188: LD_INT 0
2190: PUSH
2191: LD_INT 1
2193: PUSH
2194: LD_INT 1
2196: PUSH
2197: LD_INT 0
2199: PUSH
2200: EMPTY
2201: LIST
2202: LIST
2203: LIST
2204: LIST
2205: ST_TO_ADDR
// hc_skills := [ 0 , 1 , 3 , 0 ] ;
2206: LD_ADDR_OWVAR 31
2210: PUSH
2211: LD_INT 0
2213: PUSH
2214: LD_INT 1
2216: PUSH
2217: LD_INT 3
2219: PUSH
2220: LD_INT 0
2222: PUSH
2223: EMPTY
2224: LIST
2225: LIST
2226: LIST
2227: LIST
2228: ST_TO_ADDR
// un = CreateHuman ;
2229: LD_ADDR_VAR 0 4
2233: PUSH
2234: CALL_OW 44
2238: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
2239: LD_VAR 0 4
2243: PPUSH
2244: LD_VAR 0 5
2248: PPUSH
2249: CALL_OW 52
// if count = 4 then
2253: LD_VAR 0 1
2257: PUSH
2258: LD_INT 4
2260: EQUAL
2261: IFFALSE 2389
// begin hc_class := 1 ;
2263: LD_ADDR_OWVAR 28
2267: PUSH
2268: LD_INT 1
2270: ST_TO_ADDR
// hc_sex := sex_male ;
2271: LD_ADDR_OWVAR 27
2275: PUSH
2276: LD_INT 1
2278: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
2279: LD_ADDR_OWVAR 33
2283: PUSH
2284: LD_STRING SecondCharsGal
2286: ST_TO_ADDR
// hc_face_number := 34 ;
2287: LD_ADDR_OWVAR 34
2291: PUSH
2292: LD_INT 34
2294: ST_TO_ADDR
// hc_name := Ian Hill ;
2295: LD_ADDR_OWVAR 26
2299: PUSH
2300: LD_STRING Ian Hill
2302: ST_TO_ADDR
// hc_attr := [ 10 , 12 ] ;
2303: LD_ADDR_OWVAR 29
2307: PUSH
2308: LD_INT 10
2310: PUSH
2311: LD_INT 12
2313: PUSH
2314: EMPTY
2315: LIST
2316: LIST
2317: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 1 , 0 ] ;
2318: LD_ADDR_OWVAR 30
2322: PUSH
2323: LD_INT 0
2325: PUSH
2326: LD_INT 0
2328: PUSH
2329: LD_INT 1
2331: PUSH
2332: LD_INT 0
2334: PUSH
2335: EMPTY
2336: LIST
2337: LIST
2338: LIST
2339: LIST
2340: ST_TO_ADDR
// hc_skills := [ 2 , 0 , 1 , 0 ] ;
2341: LD_ADDR_OWVAR 31
2345: PUSH
2346: LD_INT 2
2348: PUSH
2349: LD_INT 0
2351: PUSH
2352: LD_INT 1
2354: PUSH
2355: LD_INT 0
2357: PUSH
2358: EMPTY
2359: LIST
2360: LIST
2361: LIST
2362: LIST
2363: ST_TO_ADDR
// un = CreateHuman ;
2364: LD_ADDR_VAR 0 4
2368: PUSH
2369: CALL_OW 44
2373: ST_TO_ADDR
// PlaceUnitArea ( un , AmericansHelpArea2 , false ) ;
2374: LD_VAR 0 4
2378: PPUSH
2379: LD_INT 11
2381: PPUSH
2382: LD_INT 0
2384: PPUSH
2385: CALL_OW 49
// end ; if count = 5 then
2389: LD_VAR 0 1
2393: PUSH
2394: LD_INT 5
2396: EQUAL
2397: IFFALSE 2651
// begin hc_class := 1 ;
2399: LD_ADDR_OWVAR 28
2403: PUSH
2404: LD_INT 1
2406: ST_TO_ADDR
// hc_sex := sex_male ;
2407: LD_ADDR_OWVAR 27
2411: PUSH
2412: LD_INT 1
2414: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
2415: LD_ADDR_OWVAR 33
2419: PUSH
2420: LD_STRING SecondCharsGal
2422: ST_TO_ADDR
// hc_face_number := 34 ;
2423: LD_ADDR_OWVAR 34
2427: PUSH
2428: LD_INT 34
2430: ST_TO_ADDR
// hc_name := Ian Hill ;
2431: LD_ADDR_OWVAR 26
2435: PUSH
2436: LD_STRING Ian Hill
2438: ST_TO_ADDR
// hc_attr := [ 10 , 12 ] ;
2439: LD_ADDR_OWVAR 29
2443: PUSH
2444: LD_INT 10
2446: PUSH
2447: LD_INT 12
2449: PUSH
2450: EMPTY
2451: LIST
2452: LIST
2453: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 1 , 0 ] ;
2454: LD_ADDR_OWVAR 30
2458: PUSH
2459: LD_INT 0
2461: PUSH
2462: LD_INT 0
2464: PUSH
2465: LD_INT 1
2467: PUSH
2468: LD_INT 0
2470: PUSH
2471: EMPTY
2472: LIST
2473: LIST
2474: LIST
2475: LIST
2476: ST_TO_ADDR
// hc_skills := [ 2 , 0 , 1 , 0 ] ;
2477: LD_ADDR_OWVAR 31
2481: PUSH
2482: LD_INT 2
2484: PUSH
2485: LD_INT 0
2487: PUSH
2488: LD_INT 1
2490: PUSH
2491: LD_INT 0
2493: PUSH
2494: EMPTY
2495: LIST
2496: LIST
2497: LIST
2498: LIST
2499: ST_TO_ADDR
// un = CreateHuman ;
2500: LD_ADDR_VAR 0 4
2504: PUSH
2505: CALL_OW 44
2509: ST_TO_ADDR
// PlaceUnitArea ( un , AmericansHelpArea2 , false ) ;
2510: LD_VAR 0 4
2514: PPUSH
2515: LD_INT 11
2517: PPUSH
2518: LD_INT 0
2520: PPUSH
2521: CALL_OW 49
// hc_class := 1 ;
2525: LD_ADDR_OWVAR 28
2529: PUSH
2530: LD_INT 1
2532: ST_TO_ADDR
// hc_sex := sex_female ;
2533: LD_ADDR_OWVAR 27
2537: PUSH
2538: LD_INT 2
2540: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
2541: LD_ADDR_OWVAR 33
2545: PUSH
2546: LD_STRING SecondCharsGal
2548: ST_TO_ADDR
// hc_face_number := 41 ;
2549: LD_ADDR_OWVAR 34
2553: PUSH
2554: LD_INT 41
2556: ST_TO_ADDR
// hc_name := Kate Wadsworth ;
2557: LD_ADDR_OWVAR 26
2561: PUSH
2562: LD_STRING Kate Wadsworth
2564: ST_TO_ADDR
// hc_attr := [ 9 , 9 ] ;
2565: LD_ADDR_OWVAR 29
2569: PUSH
2570: LD_INT 9
2572: PUSH
2573: LD_INT 9
2575: PUSH
2576: EMPTY
2577: LIST
2578: LIST
2579: ST_TO_ADDR
// hc_basic_skills := [ 0 , 2 , 0 , 0 ] ;
2580: LD_ADDR_OWVAR 30
2584: PUSH
2585: LD_INT 0
2587: PUSH
2588: LD_INT 2
2590: PUSH
2591: LD_INT 0
2593: PUSH
2594: LD_INT 0
2596: PUSH
2597: EMPTY
2598: LIST
2599: LIST
2600: LIST
2601: LIST
2602: ST_TO_ADDR
// hc_skills := [ 2 , 3 , 1 , 0 ] ;
2603: LD_ADDR_OWVAR 31
2607: PUSH
2608: LD_INT 2
2610: PUSH
2611: LD_INT 3
2613: PUSH
2614: LD_INT 1
2616: PUSH
2617: LD_INT 0
2619: PUSH
2620: EMPTY
2621: LIST
2622: LIST
2623: LIST
2624: LIST
2625: ST_TO_ADDR
// un = CreateHuman ;
2626: LD_ADDR_VAR 0 4
2630: PUSH
2631: CALL_OW 44
2635: ST_TO_ADDR
// PlaceUnitArea ( un , AmericansHelpArea2 , false ) ;
2636: LD_VAR 0 4
2640: PPUSH
2641: LD_INT 11
2643: PPUSH
2644: LD_INT 0
2646: PPUSH
2647: CALL_OW 49
// end ; CenterNowOnUnits ( FilterUnitsInArea ( AmericansHelpArea2 , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_sex , 1 ] ] ) [ 1 ] ) ;
2651: LD_INT 11
2653: PPUSH
2654: LD_INT 22
2656: PUSH
2657: LD_INT 1
2659: PUSH
2660: EMPTY
2661: LIST
2662: LIST
2663: PUSH
2664: LD_INT 21
2666: PUSH
2667: LD_INT 1
2669: PUSH
2670: EMPTY
2671: LIST
2672: LIST
2673: PUSH
2674: LD_INT 26
2676: PUSH
2677: LD_INT 1
2679: PUSH
2680: EMPTY
2681: LIST
2682: LIST
2683: PUSH
2684: EMPTY
2685: LIST
2686: LIST
2687: LIST
2688: PPUSH
2689: CALL_OW 70
2693: PUSH
2694: LD_INT 1
2696: ARRAY
2697: PPUSH
2698: CALL_OW 87
// Say ( FilterUnitsInArea ( AmericansHelpArea2 , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_sex , 1 ] ] ) [ 1 ] , D6-Sol3-1 ) ;
2702: LD_INT 11
2704: PPUSH
2705: LD_INT 22
2707: PUSH
2708: LD_INT 1
2710: PUSH
2711: EMPTY
2712: LIST
2713: LIST
2714: PUSH
2715: LD_INT 21
2717: PUSH
2718: LD_INT 1
2720: PUSH
2721: EMPTY
2722: LIST
2723: LIST
2724: PUSH
2725: LD_INT 26
2727: PUSH
2728: LD_INT 1
2730: PUSH
2731: EMPTY
2732: LIST
2733: LIST
2734: PUSH
2735: EMPTY
2736: LIST
2737: LIST
2738: LIST
2739: PPUSH
2740: CALL_OW 70
2744: PUSH
2745: LD_INT 1
2747: ARRAY
2748: PPUSH
2749: LD_STRING D6-Sol3-1
2751: PPUSH
2752: CALL_OW 88
// end ; end_of_file
2756: LD_VAR 0 2
2760: RET
// export function PrepareRussianCommander ; begin
2761: LD_INT 0
2763: PPUSH
// uc_side = 3 ;
2764: LD_ADDR_OWVAR 20
2768: PUSH
2769: LD_INT 3
2771: ST_TO_ADDR
// uc_nation = 3 ;
2772: LD_ADDR_OWVAR 21
2776: PUSH
2777: LD_INT 3
2779: ST_TO_ADDR
// Stolypin = NewCharacter ( Stolypin ) ;
2780: LD_ADDR_EXP 15
2784: PUSH
2785: LD_STRING Stolypin
2787: PPUSH
2788: CALL_OW 25
2792: ST_TO_ADDR
// PlaceHumanInUnit ( Stolypin , rubware0 ) ;
2793: LD_EXP 15
2797: PPUSH
2798: LD_INT 21
2800: PPUSH
2801: CALL_OW 52
// end ;
2805: LD_VAR 0 1
2809: RET
// export function PrepareRussianBase ; var i , b , un ; begin
2810: LD_INT 0
2812: PPUSH
2813: PPUSH
2814: PPUSH
2815: PPUSH
// if Difficulty > 1 then
2816: LD_OWVAR 67
2820: PUSH
2821: LD_INT 1
2823: GREATER
2824: IFFALSE 2934
// begin uc_side := 3 ;
2826: LD_ADDR_OWVAR 20
2830: PUSH
2831: LD_INT 3
2833: ST_TO_ADDR
// uc_nation := 3 ;
2834: LD_ADDR_OWVAR 21
2838: PUSH
2839: LD_INT 3
2841: ST_TO_ADDR
// InitHc ;
2842: CALL_OW 19
// InitBc ;
2846: CALL_OW 21
// PrepareHuman ( false , 1 , 4 ) ;
2850: LD_INT 0
2852: PPUSH
2853: LD_INT 1
2855: PPUSH
2856: LD_INT 4
2858: PPUSH
2859: CALL_OW 380
// bc_type := b_breastwork ;
2863: LD_ADDR_OWVAR 42
2867: PUSH
2868: LD_INT 31
2870: ST_TO_ADDR
// bc_level := 4 ;
2871: LD_ADDR_OWVAR 43
2875: PUSH
2876: LD_INT 4
2878: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 100 , 58 , 2 ) ;
2879: LD_ADDR_VAR 0 3
2883: PUSH
2884: LD_INT 100
2886: PPUSH
2887: LD_INT 58
2889: PPUSH
2890: LD_INT 2
2892: PPUSH
2893: CALL_OW 47
2897: ST_TO_ADDR
// un := CreateHuman ;
2898: LD_ADDR_VAR 0 4
2902: PUSH
2903: CALL_OW 44
2907: ST_TO_ADDR
// SetDir ( un , 5 ) ;
2908: LD_VAR 0 4
2912: PPUSH
2913: LD_INT 5
2915: PPUSH
2916: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
2920: LD_VAR 0 4
2924: PPUSH
2925: LD_VAR 0 3
2929: PPUSH
2930: CALL_OW 52
// end ; RespawnInside ( 3 , 3 , rubarmr0 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) , 1 , [ 3 , 4 , 5 ] [ Difficulty ] ) ;
2934: LD_INT 3
2936: PPUSH
2937: LD_INT 3
2939: PPUSH
2940: LD_INT 22
2942: PPUSH
2943: LD_EXP 16
2947: PPUSH
2948: LD_EXP 17
2952: PPUSH
2953: CALL_OW 12
2957: PPUSH
2958: LD_INT 1
2960: PPUSH
2961: LD_INT 3
2963: PUSH
2964: LD_INT 4
2966: PUSH
2967: LD_INT 5
2969: PUSH
2970: EMPTY
2971: LIST
2972: LIST
2973: LIST
2974: PUSH
2975: LD_OWVAR 67
2979: ARRAY
2980: PPUSH
2981: CALL 4246 0 6
// RespawnInside ( 3 , 3 , rubware0 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) , 2 , 3 ) ;
2985: LD_INT 3
2987: PPUSH
2988: LD_INT 3
2990: PPUSH
2991: LD_INT 21
2993: PPUSH
2994: LD_EXP 16
2998: PPUSH
2999: LD_EXP 17
3003: PPUSH
3004: CALL_OW 12
3008: PPUSH
3009: LD_INT 2
3011: PPUSH
3012: LD_INT 3
3014: PPUSH
3015: CALL 4246 0 6
// RespawnInside ( 3 , 3 , rubbrid0 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) , 4 , 3 ) ;
3019: LD_INT 3
3021: PPUSH
3022: LD_INT 3
3024: PPUSH
3025: LD_INT 1
3027: PPUSH
3028: LD_EXP 16
3032: PPUSH
3033: LD_EXP 17
3037: PPUSH
3038: CALL_OW 12
3042: PPUSH
3043: LD_INT 4
3045: PPUSH
3046: LD_INT 3
3048: PPUSH
3049: CALL 4246 0 6
// RespawnInside ( 3 , 3 , rubfact0 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) , 3 , 5 ) ;
3053: LD_INT 3
3055: PPUSH
3056: LD_INT 3
3058: PPUSH
3059: LD_INT 24
3061: PPUSH
3062: LD_EXP 16
3066: PPUSH
3067: LD_EXP 17
3071: PPUSH
3072: CALL_OW 12
3076: PPUSH
3077: LD_INT 3
3079: PPUSH
3080: LD_INT 5
3082: PPUSH
3083: CALL 4246 0 6
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) do
3087: LD_ADDR_VAR 0 2
3091: PUSH
3092: LD_INT 22
3094: PUSH
3095: LD_INT 3
3097: PUSH
3098: EMPTY
3099: LIST
3100: LIST
3101: PUSH
3102: LD_INT 30
3104: PUSH
3105: LD_INT 32
3107: PUSH
3108: EMPTY
3109: LIST
3110: LIST
3111: PUSH
3112: EMPTY
3113: LIST
3114: LIST
3115: PPUSH
3116: CALL_OW 69
3120: PUSH
3121: FOR_IN
3122: IFFALSE 3162
// RespawnInside ( 3 , 3 , i , rand ( RuSoldMinLevel , RuSoldMaxLevel ) , 1 , 1 ) ;
3124: LD_INT 3
3126: PPUSH
3127: LD_INT 3
3129: PPUSH
3130: LD_VAR 0 2
3134: PPUSH
3135: LD_EXP 16
3139: PPUSH
3140: LD_EXP 17
3144: PPUSH
3145: CALL_OW 12
3149: PPUSH
3150: LD_INT 1
3152: PPUSH
3153: LD_INT 1
3155: PPUSH
3156: CALL 4246 0 6
3160: GO 3121
3162: POP
3163: POP
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , 31 ] ] ) do
3164: LD_ADDR_VAR 0 2
3168: PUSH
3169: LD_INT 22
3171: PUSH
3172: LD_INT 3
3174: PUSH
3175: EMPTY
3176: LIST
3177: LIST
3178: PUSH
3179: LD_INT 30
3181: PUSH
3182: LD_INT 31
3184: PUSH
3185: EMPTY
3186: LIST
3187: LIST
3188: PUSH
3189: EMPTY
3190: LIST
3191: LIST
3192: PPUSH
3193: CALL_OW 69
3197: PUSH
3198: FOR_IN
3199: IFFALSE 3227
// PrepareSolBun ( rand ( RuSoldMinLevel , RuSoldMaxLevel ) , i ) ;
3201: LD_EXP 16
3205: PPUSH
3206: LD_EXP 17
3210: PPUSH
3211: CALL_OW 12
3215: PPUSH
3216: LD_VAR 0 2
3220: PPUSH
3221: CALL 4356 0 2
3225: GO 3198
3227: POP
3228: POP
// end ;
3229: LD_VAR 0 1
3233: RET
// export function PrepareRussianConvoy ; var i , veh , un ; begin
3234: LD_INT 0
3236: PPUSH
3237: PPUSH
3238: PPUSH
3239: PPUSH
// uc_side = 6 ;
3240: LD_ADDR_OWVAR 20
3244: PUSH
3245: LD_INT 6
3247: ST_TO_ADDR
// uc_nation = 3 ;
3248: LD_ADDR_OWVAR 21
3252: PUSH
3253: LD_INT 3
3255: ST_TO_ADDR
// for i := 1 to [ 1 , 2 , rand ( 1 , 2 ) ] [ Difficulty ] do
3256: LD_ADDR_VAR 0 2
3260: PUSH
3261: DOUBLE
3262: LD_INT 1
3264: DEC
3265: ST_TO_ADDR
3266: LD_INT 1
3268: PUSH
3269: LD_INT 2
3271: PUSH
3272: LD_INT 1
3274: PPUSH
3275: LD_INT 2
3277: PPUSH
3278: CALL_OW 12
3282: PUSH
3283: EMPTY
3284: LIST
3285: LIST
3286: LIST
3287: PUSH
3288: LD_OWVAR 67
3292: ARRAY
3293: PUSH
3294: FOR_TO
3295: IFFALSE 3455
// begin vc_engine = 1 ;
3297: LD_ADDR_OWVAR 39
3301: PUSH
3302: LD_INT 1
3304: ST_TO_ADDR
// vc_control = 1 ;
3305: LD_ADDR_OWVAR 38
3309: PUSH
3310: LD_INT 1
3312: ST_TO_ADDR
// vc_weapon = [ 42 , 42 , 43 ] [ Difficulty ] ;
3313: LD_ADDR_OWVAR 40
3317: PUSH
3318: LD_INT 42
3320: PUSH
3321: LD_INT 42
3323: PUSH
3324: LD_INT 43
3326: PUSH
3327: EMPTY
3328: LIST
3329: LIST
3330: LIST
3331: PUSH
3332: LD_OWVAR 67
3336: ARRAY
3337: ST_TO_ADDR
// vc_chassis = [ 21 , 22 , 22 ] [ Difficulty ] ;
3338: LD_ADDR_OWVAR 37
3342: PUSH
3343: LD_INT 21
3345: PUSH
3346: LD_INT 22
3348: PUSH
3349: LD_INT 22
3351: PUSH
3352: EMPTY
3353: LIST
3354: LIST
3355: LIST
3356: PUSH
3357: LD_OWVAR 67
3361: ARRAY
3362: ST_TO_ADDR
// veh = CreateVehicle ;
3363: LD_ADDR_VAR 0 3
3367: PUSH
3368: CALL_OW 45
3372: ST_TO_ADDR
// PlaceUnitArea ( veh , RussianConvoy , false ) ;
3373: LD_VAR 0 3
3377: PPUSH
3378: LD_INT 3
3380: PPUSH
3381: LD_INT 0
3383: PPUSH
3384: CALL_OW 49
// hc_gallery =  ;
3388: LD_ADDR_OWVAR 33
3392: PUSH
3393: LD_STRING 
3395: ST_TO_ADDR
// hc_name =  ;
3396: LD_ADDR_OWVAR 26
3400: PUSH
3401: LD_STRING 
3403: ST_TO_ADDR
// PrepareHuman ( false , 3 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) ) ;
3404: LD_INT 0
3406: PPUSH
3407: LD_INT 3
3409: PPUSH
3410: LD_EXP 16
3414: PPUSH
3415: LD_EXP 17
3419: PPUSH
3420: CALL_OW 12
3424: PPUSH
3425: CALL_OW 380
// un = CreateHuman ;
3429: LD_ADDR_VAR 0 4
3433: PUSH
3434: CALL_OW 44
3438: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
3439: LD_VAR 0 4
3443: PPUSH
3444: LD_VAR 0 3
3448: PPUSH
3449: CALL_OW 52
// end ;
3453: GO 3294
3455: POP
3456: POP
// PrepareHuman ( false , 2 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) + 2 ) ;
3457: LD_INT 0
3459: PPUSH
3460: LD_INT 2
3462: PPUSH
3463: LD_EXP 16
3467: PPUSH
3468: LD_EXP 17
3472: PPUSH
3473: CALL_OW 12
3477: PUSH
3478: LD_INT 2
3480: PLUS
3481: PPUSH
3482: CALL_OW 380
// un = CreateHuman ;
3486: LD_ADDR_VAR 0 4
3490: PUSH
3491: CALL_OW 44
3495: ST_TO_ADDR
// PlaceUnitArea ( un , RussianConvoy , false ) ;
3496: LD_VAR 0 4
3500: PPUSH
3501: LD_INT 3
3503: PPUSH
3504: LD_INT 0
3506: PPUSH
3507: CALL_OW 49
// PrepareHuman ( false , 4 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) + 2 ) ;
3511: LD_INT 0
3513: PPUSH
3514: LD_INT 4
3516: PPUSH
3517: LD_EXP 16
3521: PPUSH
3522: LD_EXP 17
3526: PPUSH
3527: CALL_OW 12
3531: PUSH
3532: LD_INT 2
3534: PLUS
3535: PPUSH
3536: CALL_OW 380
// un = CreateHuman ;
3540: LD_ADDR_VAR 0 4
3544: PUSH
3545: CALL_OW 44
3549: ST_TO_ADDR
// PlaceUnitArea ( un , RussianConvoy , false ) ;
3550: LD_VAR 0 4
3554: PPUSH
3555: LD_INT 3
3557: PPUSH
3558: LD_INT 0
3560: PPUSH
3561: CALL_OW 49
// for i := 1 to [ 2 , 3 , 3 ] [ Difficulty ] + rand ( 1 , 3 ) do
3565: LD_ADDR_VAR 0 2
3569: PUSH
3570: DOUBLE
3571: LD_INT 1
3573: DEC
3574: ST_TO_ADDR
3575: LD_INT 2
3577: PUSH
3578: LD_INT 3
3580: PUSH
3581: LD_INT 3
3583: PUSH
3584: EMPTY
3585: LIST
3586: LIST
3587: LIST
3588: PUSH
3589: LD_OWVAR 67
3593: ARRAY
3594: PUSH
3595: LD_INT 1
3597: PPUSH
3598: LD_INT 3
3600: PPUSH
3601: CALL_OW 12
3605: PLUS
3606: PUSH
3607: FOR_TO
3608: IFFALSE 3678
// begin hc_gallery =  ;
3610: LD_ADDR_OWVAR 33
3614: PUSH
3615: LD_STRING 
3617: ST_TO_ADDR
// hc_name =  ;
3618: LD_ADDR_OWVAR 26
3622: PUSH
3623: LD_STRING 
3625: ST_TO_ADDR
// PrepareHuman ( false , 1 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) ) ;
3626: LD_INT 0
3628: PPUSH
3629: LD_INT 1
3631: PPUSH
3632: LD_EXP 16
3636: PPUSH
3637: LD_EXP 17
3641: PPUSH
3642: CALL_OW 12
3646: PPUSH
3647: CALL_OW 380
// un = CreateHuman ;
3651: LD_ADDR_VAR 0 4
3655: PUSH
3656: CALL_OW 44
3660: ST_TO_ADDR
// PlaceUnitArea ( un , RussianConvoy , false ) ;
3661: LD_VAR 0 4
3665: PPUSH
3666: LD_INT 3
3668: PPUSH
3669: LD_INT 0
3671: PPUSH
3672: CALL_OW 49
// end ;
3676: GO 3607
3678: POP
3679: POP
// vc_engine = 1 ;
3680: LD_ADDR_OWVAR 39
3684: PUSH
3685: LD_INT 1
3687: ST_TO_ADDR
// vc_control = 1 ;
3688: LD_ADDR_OWVAR 38
3692: PUSH
3693: LD_INT 1
3695: ST_TO_ADDR
// vc_weapon = 51 ;
3696: LD_ADDR_OWVAR 40
3700: PUSH
3701: LD_INT 51
3703: ST_TO_ADDR
// vc_chassis = 22 ;
3704: LD_ADDR_OWVAR 37
3708: PUSH
3709: LD_INT 22
3711: ST_TO_ADDR
// veh = CreateVehicle ;
3712: LD_ADDR_VAR 0 3
3716: PUSH
3717: CALL_OW 45
3721: ST_TO_ADDR
// PlaceUnitArea ( veh , RussianConvoy , false ) ;
3722: LD_VAR 0 3
3726: PPUSH
3727: LD_INT 3
3729: PPUSH
3730: LD_INT 0
3732: PPUSH
3733: CALL_OW 49
// SetCargo ( veh , 1 , 100 ) ;
3737: LD_VAR 0 3
3741: PPUSH
3742: LD_INT 1
3744: PPUSH
3745: LD_INT 100
3747: PPUSH
3748: CALL_OW 290
// hc_gallery =  ;
3752: LD_ADDR_OWVAR 33
3756: PUSH
3757: LD_STRING 
3759: ST_TO_ADDR
// hc_name =  ;
3760: LD_ADDR_OWVAR 26
3764: PUSH
3765: LD_STRING 
3767: ST_TO_ADDR
// PrepareHuman ( false , 3 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) ) ;
3768: LD_INT 0
3770: PPUSH
3771: LD_INT 3
3773: PPUSH
3774: LD_EXP 16
3778: PPUSH
3779: LD_EXP 17
3783: PPUSH
3784: CALL_OW 12
3788: PPUSH
3789: CALL_OW 380
// un = CreateHuman ;
3793: LD_ADDR_VAR 0 4
3797: PUSH
3798: CALL_OW 44
3802: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
3803: LD_VAR 0 4
3807: PPUSH
3808: LD_VAR 0 3
3812: PPUSH
3813: CALL_OW 52
// for i in FilterAllUnits ( [ [ f_side , 6 ] , [ f_and , [ f_not , [ f_class , 2 ] ] , [ f_not , [ f_class , 4 ] ] ] ] ) do
3817: LD_ADDR_VAR 0 2
3821: PUSH
3822: LD_INT 22
3824: PUSH
3825: LD_INT 6
3827: PUSH
3828: EMPTY
3829: LIST
3830: LIST
3831: PUSH
3832: LD_INT 1
3834: PUSH
3835: LD_INT 3
3837: PUSH
3838: LD_INT 25
3840: PUSH
3841: LD_INT 2
3843: PUSH
3844: EMPTY
3845: LIST
3846: LIST
3847: PUSH
3848: EMPTY
3849: LIST
3850: LIST
3851: PUSH
3852: LD_INT 3
3854: PUSH
3855: LD_INT 25
3857: PUSH
3858: LD_INT 4
3860: PUSH
3861: EMPTY
3862: LIST
3863: LIST
3864: PUSH
3865: EMPTY
3866: LIST
3867: LIST
3868: PUSH
3869: EMPTY
3870: LIST
3871: LIST
3872: LIST
3873: PUSH
3874: EMPTY
3875: LIST
3876: LIST
3877: PPUSH
3878: CALL_OW 69
3882: PUSH
3883: FOR_IN
3884: IFFALSE 3903
// ComAgressiveMove ( i , 45 , 46 ) ;
3886: LD_VAR 0 2
3890: PPUSH
3891: LD_INT 45
3893: PPUSH
3894: LD_INT 46
3896: PPUSH
3897: CALL_OW 114
3901: GO 3883
3903: POP
3904: POP
// for i in FilterAllUnits ( [ [ f_side , 6 ] , [ f_class , 2 ] ] ) do
3905: LD_ADDR_VAR 0 2
3909: PUSH
3910: LD_INT 22
3912: PUSH
3913: LD_INT 6
3915: PUSH
3916: EMPTY
3917: LIST
3918: LIST
3919: PUSH
3920: LD_INT 25
3922: PUSH
3923: LD_INT 2
3925: PUSH
3926: EMPTY
3927: LIST
3928: LIST
3929: PUSH
3930: EMPTY
3931: LIST
3932: LIST
3933: PPUSH
3934: CALL_OW 69
3938: PUSH
3939: FOR_IN
3940: IFFALSE 3971
// ruPDepot = ComBuild ( i , b_depot , 48 , 55 , 5 ) ;
3942: LD_ADDR_EXP 21
3946: PUSH
3947: LD_VAR 0 2
3951: PPUSH
3952: LD_INT 0
3954: PPUSH
3955: LD_INT 48
3957: PPUSH
3958: LD_INT 55
3960: PPUSH
3961: LD_INT 5
3963: PPUSH
3964: CALL_OW 145
3968: ST_TO_ADDR
3969: GO 3939
3971: POP
3972: POP
// for i in FilterAllUnits ( [ [ f_side , 6 ] , [ f_class , 4 ] ] ) do
3973: LD_ADDR_VAR 0 2
3977: PUSH
3978: LD_INT 22
3980: PUSH
3981: LD_INT 6
3983: PUSH
3984: EMPTY
3985: LIST
3986: LIST
3987: PUSH
3988: LD_INT 25
3990: PUSH
3991: LD_INT 4
3993: PUSH
3994: EMPTY
3995: LIST
3996: LIST
3997: PUSH
3998: EMPTY
3999: LIST
4000: LIST
4001: PPUSH
4002: CALL_OW 69
4006: PUSH
4007: FOR_IN
4008: IFFALSE 4027
// ComMoveXY ( i , 39 , 55 ) ;
4010: LD_VAR 0 2
4014: PPUSH
4015: LD_INT 39
4017: PPUSH
4018: LD_INT 55
4020: PPUSH
4021: CALL_OW 111
4025: GO 4007
4027: POP
4028: POP
// end ;
4029: LD_VAR 0 1
4033: RET
// export function PrepareFirstAttack ; var i , un ; begin
4034: LD_INT 0
4036: PPUSH
4037: PPUSH
4038: PPUSH
// uc_side = 5 ;
4039: LD_ADDR_OWVAR 20
4043: PUSH
4044: LD_INT 5
4046: ST_TO_ADDR
// uc_nation = 3 ;
4047: LD_ADDR_OWVAR 21
4051: PUSH
4052: LD_INT 3
4054: ST_TO_ADDR
// for i := 1 to 4 do
4055: LD_ADDR_VAR 0 2
4059: PUSH
4060: DOUBLE
4061: LD_INT 1
4063: DEC
4064: ST_TO_ADDR
4065: LD_INT 4
4067: PUSH
4068: FOR_TO
4069: IFFALSE 4168
// begin hc_gallery =  ;
4071: LD_ADDR_OWVAR 33
4075: PUSH
4076: LD_STRING 
4078: ST_TO_ADDR
// hc_name =  ;
4079: LD_ADDR_OWVAR 26
4083: PUSH
4084: LD_STRING 
4086: ST_TO_ADDR
// PrepareHuman ( false , 1 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) ) ;
4087: LD_INT 0
4089: PPUSH
4090: LD_INT 1
4092: PPUSH
4093: LD_EXP 16
4097: PPUSH
4098: LD_EXP 17
4102: PPUSH
4103: CALL_OW 12
4107: PPUSH
4108: CALL_OW 380
// un = CreateHuman ;
4112: LD_ADDR_VAR 0 3
4116: PUSH
4117: CALL_OW 44
4121: ST_TO_ADDR
// PlaceUnitArea ( un , RussianAttack , false ) ;
4122: LD_VAR 0 3
4126: PPUSH
4127: LD_INT 4
4129: PPUSH
4130: LD_INT 0
4132: PPUSH
4133: CALL_OW 49
// ComAgressiveMove ( un , GetX ( JMM ) , GetY ( JMM ) ) ;
4137: LD_VAR 0 3
4141: PPUSH
4142: LD_EXP 1
4146: PPUSH
4147: CALL_OW 250
4151: PPUSH
4152: LD_EXP 1
4156: PPUSH
4157: CALL_OW 251
4161: PPUSH
4162: CALL_OW 114
// end ;
4166: GO 4068
4168: POP
4169: POP
// firstRussianAttack = 1 ;
4170: LD_ADDR_EXP 23
4174: PUSH
4175: LD_INT 1
4177: ST_TO_ADDR
// end ; end_of_file
4178: LD_VAR 0 1
4182: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
4183: LD_INT 0
4185: PPUSH
4186: PPUSH
// if exist_mode then
4187: LD_VAR 0 2
4191: IFFALSE 4216
// begin unit := CreateCharacter ( mission_prefix_prev & ident ) ;
4193: LD_ADDR_VAR 0 4
4197: PUSH
4198: LD_EXP 49
4202: PUSH
4203: LD_VAR 0 1
4207: STR
4208: PPUSH
4209: CALL_OW 34
4213: ST_TO_ADDR
// end else
4214: GO 4231
// begin unit := NewCharacter ( ident ) ;
4216: LD_ADDR_VAR 0 4
4220: PUSH
4221: LD_VAR 0 1
4225: PPUSH
4226: CALL_OW 25
4230: ST_TO_ADDR
// end ; result := unit ;
4231: LD_ADDR_VAR 0 3
4235: PUSH
4236: LD_VAR 0 4
4240: ST_TO_ADDR
// end ;
4241: LD_VAR 0 3
4245: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
4246: LD_INT 0
4248: PPUSH
4249: PPUSH
4250: PPUSH
4251: PPUSH
// for i = 1 to count do
4252: LD_ADDR_VAR 0 8
4256: PUSH
4257: DOUBLE
4258: LD_INT 1
4260: DEC
4261: ST_TO_ADDR
4262: LD_VAR 0 6
4266: PUSH
4267: FOR_TO
4268: IFFALSE 4349
// begin uc_side = side ;
4270: LD_ADDR_OWVAR 20
4274: PUSH
4275: LD_VAR 0 1
4279: ST_TO_ADDR
// uc_nation = nation ;
4280: LD_ADDR_OWVAR 21
4284: PUSH
4285: LD_VAR 0 2
4289: ST_TO_ADDR
// hc_gallery =  ;
4290: LD_ADDR_OWVAR 33
4294: PUSH
4295: LD_STRING 
4297: ST_TO_ADDR
// hc_name =  ;
4298: LD_ADDR_OWVAR 26
4302: PUSH
4303: LD_STRING 
4305: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
4306: LD_INT 0
4308: PPUSH
4309: LD_VAR 0 5
4313: PPUSH
4314: LD_VAR 0 4
4318: PPUSH
4319: CALL_OW 380
// un = CreateHuman ;
4323: LD_ADDR_VAR 0 10
4327: PUSH
4328: CALL_OW 44
4332: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
4333: LD_VAR 0 10
4337: PPUSH
4338: LD_VAR 0 3
4342: PPUSH
4343: CALL_OW 52
// end ;
4347: GO 4267
4349: POP
4350: POP
// end ;
4351: LD_VAR 0 7
4355: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
4356: LD_INT 0
4358: PPUSH
4359: PPUSH
4360: PPUSH
// uc_side := GetSide ( b ) ;
4361: LD_ADDR_OWVAR 20
4365: PUSH
4366: LD_VAR 0 2
4370: PPUSH
4371: CALL_OW 255
4375: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
4376: LD_ADDR_OWVAR 21
4380: PUSH
4381: LD_VAR 0 2
4385: PPUSH
4386: CALL_OW 248
4390: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
4391: LD_INT 0
4393: PPUSH
4394: LD_INT 1
4396: PPUSH
4397: LD_VAR 0 1
4401: PPUSH
4402: CALL_OW 380
// un = CreateHuman ;
4406: LD_ADDR_VAR 0 4
4410: PUSH
4411: CALL_OW 44
4415: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
4416: LD_ADDR_VAR 0 5
4420: PUSH
4421: LD_VAR 0 2
4425: PPUSH
4426: CALL_OW 254
4430: PUSH
4431: LD_INT 3
4433: MINUS
4434: ST_TO_ADDR
// if dir < 0 then
4435: LD_VAR 0 5
4439: PUSH
4440: LD_INT 0
4442: LESS
4443: IFFALSE 4459
// dir := 6 + dir ;
4445: LD_ADDR_VAR 0 5
4449: PUSH
4450: LD_INT 6
4452: PUSH
4453: LD_VAR 0 5
4457: PLUS
4458: ST_TO_ADDR
// SetDir ( un , dir ) ;
4459: LD_VAR 0 4
4463: PPUSH
4464: LD_VAR 0 5
4468: PPUSH
4469: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
4473: LD_VAR 0 4
4477: PPUSH
4478: LD_VAR 0 2
4482: PPUSH
4483: CALL_OW 52
// end ;
4487: LD_VAR 0 3
4491: RET
// export function DialogRandom ( characters , dialogMID , dialogFID ) ; var i , speaker ; begin
4492: LD_INT 0
4494: PPUSH
4495: PPUSH
4496: PPUSH
// speaker := characters [ rand ( 1 , characters ) ] ;
4497: LD_ADDR_VAR 0 6
4501: PUSH
4502: LD_VAR 0 1
4506: PUSH
4507: LD_INT 1
4509: PPUSH
4510: LD_VAR 0 1
4514: PPUSH
4515: CALL_OW 12
4519: ARRAY
4520: ST_TO_ADDR
// if GetSex ( speaker ) = sex_male then
4521: LD_VAR 0 6
4525: PPUSH
4526: CALL_OW 258
4530: PUSH
4531: LD_INT 1
4533: EQUAL
4534: IFFALSE 4552
// Say ( speaker , dialogMID ) else
4536: LD_VAR 0 6
4540: PPUSH
4541: LD_VAR 0 2
4545: PPUSH
4546: CALL_OW 88
4550: GO 4566
// Say ( speaker , dialogFID ) ;
4552: LD_VAR 0 6
4556: PPUSH
4557: LD_VAR 0 3
4561: PPUSH
4562: CALL_OW 88
// result := speaker ;
4566: LD_ADDR_VAR 0 4
4570: PUSH
4571: LD_VAR 0 6
4575: ST_TO_ADDR
// end ;
4576: LD_VAR 0 4
4580: RET
// export function PrepareDifficulty ; var tmp ; begin
4581: LD_INT 0
4583: PPUSH
4584: PPUSH
// if Difficulty = 1 then
4585: LD_OWVAR 67
4589: PUSH
4590: LD_INT 1
4592: EQUAL
4593: IFFALSE 4611
// begin RuSoldMinLevel = 1 ;
4595: LD_ADDR_EXP 16
4599: PUSH
4600: LD_INT 1
4602: ST_TO_ADDR
// RuSoldMaxLevel = 2 ;
4603: LD_ADDR_EXP 17
4607: PUSH
4608: LD_INT 2
4610: ST_TO_ADDR
// end ; if Difficulty = 2 then
4611: LD_OWVAR 67
4615: PUSH
4616: LD_INT 2
4618: EQUAL
4619: IFFALSE 4720
// begin RuSoldMinLevel = 2 ;
4621: LD_ADDR_EXP 16
4625: PUSH
4626: LD_INT 2
4628: ST_TO_ADDR
// RuSoldMaxLevel = 4 ;
4629: LD_ADDR_EXP 17
4633: PUSH
4634: LD_INT 4
4636: ST_TO_ADDR
// RemoveUnit ( rubbrwr1 ) ;
4637: LD_INT 23
4639: PPUSH
4640: CALL_OW 64
// uc_nation = 3 ;
4644: LD_ADDR_OWVAR 21
4648: PUSH
4649: LD_INT 3
4651: ST_TO_ADDR
// uc_side = 3 ;
4652: LD_ADDR_OWVAR 20
4656: PUSH
4657: LD_INT 3
4659: ST_TO_ADDR
// bc_level = 5 ;
4660: LD_ADDR_OWVAR 43
4664: PUSH
4665: LD_INT 5
4667: ST_TO_ADDR
// bc_type = 32 ;
4668: LD_ADDR_OWVAR 42
4672: PUSH
4673: LD_INT 32
4675: ST_TO_ADDR
// tmp = CreateAndPlaceBuildingXYD ( 76 , 91 , 2 ) ;
4676: LD_ADDR_VAR 0 2
4680: PUSH
4681: LD_INT 76
4683: PPUSH
4684: LD_INT 91
4686: PPUSH
4687: LD_INT 2
4689: PPUSH
4690: CALL_OW 47
4694: ST_TO_ADDR
// PlaceWeaponTurret ( tmp , 43 ) ;
4695: LD_VAR 0 2
4699: PPUSH
4700: LD_INT 43
4702: PPUSH
4703: CALL_OW 431
// SetTech ( 51 , 3 , state_enabled ) ;
4707: LD_INT 51
4709: PPUSH
4710: LD_INT 3
4712: PPUSH
4713: LD_INT 1
4715: PPUSH
4716: CALL_OW 322
// end ; if Difficulty = 3 then
4720: LD_OWVAR 67
4724: PUSH
4725: LD_INT 3
4727: EQUAL
4728: IFFALSE 4890
// begin RuSoldMinLevel = 3 ;
4730: LD_ADDR_EXP 16
4734: PUSH
4735: LD_INT 3
4737: ST_TO_ADDR
// RuSoldMaxLevel = 5 ;
4738: LD_ADDR_EXP 17
4742: PUSH
4743: LD_INT 5
4745: ST_TO_ADDR
// RemoveUnit ( rubbrwr0 ) ;
4746: LD_INT 26
4748: PPUSH
4749: CALL_OW 64
// RemoveUnit ( rubbrwr1 ) ;
4753: LD_INT 23
4755: PPUSH
4756: CALL_OW 64
// uc_nation = 3 ;
4760: LD_ADDR_OWVAR 21
4764: PUSH
4765: LD_INT 3
4767: ST_TO_ADDR
// uc_side = 3 ;
4768: LD_ADDR_OWVAR 20
4772: PUSH
4773: LD_INT 3
4775: ST_TO_ADDR
// bc_level = 5 ;
4776: LD_ADDR_OWVAR 43
4780: PUSH
4781: LD_INT 5
4783: ST_TO_ADDR
// bc_type = 32 ;
4784: LD_ADDR_OWVAR 42
4788: PUSH
4789: LD_INT 32
4791: ST_TO_ADDR
// tmp = CreateAndPlaceBuildingXYD ( 76 , 91 , 2 ) ;
4792: LD_ADDR_VAR 0 2
4796: PUSH
4797: LD_INT 76
4799: PPUSH
4800: LD_INT 91
4802: PPUSH
4803: LD_INT 2
4805: PPUSH
4806: CALL_OW 47
4810: ST_TO_ADDR
// PlaceWeaponTurret ( tmp , 44 ) ;
4811: LD_VAR 0 2
4815: PPUSH
4816: LD_INT 44
4818: PPUSH
4819: CALL_OW 431
// tmp = CreateAndPlaceBuildingXYD ( 83 , 84 , 2 ) ;
4823: LD_ADDR_VAR 0 2
4827: PUSH
4828: LD_INT 83
4830: PPUSH
4831: LD_INT 84
4833: PPUSH
4834: LD_INT 2
4836: PPUSH
4837: CALL_OW 47
4841: ST_TO_ADDR
// PlaceWeaponTurret ( tmp , 43 ) ;
4842: LD_VAR 0 2
4846: PPUSH
4847: LD_INT 43
4849: PPUSH
4850: CALL_OW 431
// SetTech ( 51 , 3 , state_enabled ) ;
4854: LD_INT 51
4856: PPUSH
4857: LD_INT 3
4859: PPUSH
4860: LD_INT 1
4862: PPUSH
4863: CALL_OW 322
// SetTech ( 52 , 3 , state_enabled ) ;
4867: LD_INT 52
4869: PPUSH
4870: LD_INT 3
4872: PPUSH
4873: LD_INT 1
4875: PPUSH
4876: CALL_OW 322
// PlaceWeaponTurret ( rubbunk0 , ru_gun ) ;
4880: LD_INT 25
4882: PPUSH
4883: LD_INT 44
4885: PPUSH
4886: CALL_OW 431
// end ; end ;
4890: LD_VAR 0 1
4894: RET
// export function EnergyDialog ; begin
4895: LD_INT 0
4897: PPUSH
// if GetTech ( 46 , 1 ) = state_enabled and GetTech ( 35 , 1 ) = state_enabled then
4898: LD_INT 46
4900: PPUSH
4901: LD_INT 1
4903: PPUSH
4904: CALL_OW 321
4908: PUSH
4909: LD_INT 1
4911: EQUAL
4912: PUSH
4913: LD_INT 35
4915: PPUSH
4916: LD_INT 1
4918: PPUSH
4919: CALL_OW 321
4923: PUSH
4924: LD_INT 1
4926: EQUAL
4927: AND
4928: IFFALSE 4952
// begin Say ( JMM , D9c-JMM-1 ) ;
4930: LD_EXP 1
4934: PPUSH
4935: LD_STRING D9c-JMM-1
4937: PPUSH
4938: CALL_OW 88
// energyVDialog = 1 ;
4942: LD_ADDR_EXP 33
4946: PUSH
4947: LD_INT 1
4949: ST_TO_ADDR
// end else
4950: GO 5106
// begin if GetTech ( 35 , 1 ) = state_researched and energyVDialog = 0 then
4952: LD_INT 35
4954: PPUSH
4955: LD_INT 1
4957: PPUSH
4958: CALL_OW 321
4962: PUSH
4963: LD_INT 2
4965: EQUAL
4966: PUSH
4967: LD_EXP 33
4971: PUSH
4972: LD_INT 0
4974: EQUAL
4975: AND
4976: IFFALSE 4998
// begin Say ( JMM , D9c-JMM-1a ) ;
4978: LD_EXP 1
4982: PPUSH
4983: LD_STRING D9c-JMM-1a
4985: PPUSH
4986: CALL_OW 88
// energyVDialog = 1 ;
4990: LD_ADDR_EXP 33
4994: PUSH
4995: LD_INT 1
4997: ST_TO_ADDR
// end ; if GetTech ( 46 , 1 ) = state_researched and energyVDialog = 0 then
4998: LD_INT 46
5000: PPUSH
5001: LD_INT 1
5003: PPUSH
5004: CALL_OW 321
5008: PUSH
5009: LD_INT 2
5011: EQUAL
5012: PUSH
5013: LD_EXP 33
5017: PUSH
5018: LD_INT 0
5020: EQUAL
5021: AND
5022: IFFALSE 5044
// begin Say ( JMM , D9c-JMM-1b ) ;
5024: LD_EXP 1
5028: PPUSH
5029: LD_STRING D9c-JMM-1b
5031: PPUSH
5032: CALL_OW 88
// energyVDialog = 1 ;
5036: LD_ADDR_EXP 33
5040: PUSH
5041: LD_INT 1
5043: ST_TO_ADDR
// end ; if GetTech ( 46 , 1 ) = state_researched and GetTech ( 21 , 1 ) = state_researched and energyVDialog = 0 then
5044: LD_INT 46
5046: PPUSH
5047: LD_INT 1
5049: PPUSH
5050: CALL_OW 321
5054: PUSH
5055: LD_INT 2
5057: EQUAL
5058: PUSH
5059: LD_INT 21
5061: PPUSH
5062: LD_INT 1
5064: PPUSH
5065: CALL_OW 321
5069: PUSH
5070: LD_INT 2
5072: EQUAL
5073: AND
5074: PUSH
5075: LD_EXP 33
5079: PUSH
5080: LD_INT 0
5082: EQUAL
5083: AND
5084: IFFALSE 5106
// begin Say ( JMM , D9c-JMM-1c ) ;
5086: LD_EXP 1
5090: PPUSH
5091: LD_STRING D9c-JMM-1c
5093: PPUSH
5094: CALL_OW 88
// energyVDialog = 1 ;
5098: LD_ADDR_EXP 33
5102: PUSH
5103: LD_INT 1
5105: ST_TO_ADDR
// end ; end ; end ;
5106: LD_VAR 0 1
5110: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i , list , tmp , hex ; begin
5111: LD_INT 0
5113: PPUSH
5114: PPUSH
5115: PPUSH
5116: PPUSH
5117: PPUSH
// if not bulldozer or GetLives ( bulldozer ) < 250 or ( HasTask ( bulldozer ) and GetFuel ( bulldozer ) > 20 ) then
5118: LD_VAR 0 1
5122: NOT
5123: PUSH
5124: LD_VAR 0 1
5128: PPUSH
5129: CALL_OW 256
5133: PUSH
5134: LD_INT 250
5136: LESS
5137: OR
5138: PUSH
5139: LD_VAR 0 1
5143: PPUSH
5144: CALL_OW 314
5148: PUSH
5149: LD_VAR 0 1
5153: PPUSH
5154: CALL_OW 261
5158: PUSH
5159: LD_INT 20
5161: GREATER
5162: AND
5163: OR
5164: IFFALSE 5168
// exit ;
5166: GO 5533
// if GetFuel ( bulldozer ) < 20 and not GetTag ( bulldozer ) = 21 then
5168: LD_VAR 0 1
5172: PPUSH
5173: CALL_OW 261
5177: PUSH
5178: LD_INT 20
5180: LESS
5181: PUSH
5182: LD_VAR 0 1
5186: PPUSH
5187: CALL_OW 110
5191: PUSH
5192: LD_INT 21
5194: EQUAL
5195: NOT
5196: AND
5197: IFFALSE 5224
// begin ComStop ( bulldozer ) ;
5199: LD_VAR 0 1
5203: PPUSH
5204: CALL_OW 141
// SetTag ( bulldozer , 21 ) ;
5208: LD_VAR 0 1
5212: PPUSH
5213: LD_INT 21
5215: PPUSH
5216: CALL_OW 109
// exit ;
5220: GO 5533
// end else
5222: GO 5251
// if GetFuel ( bulldozer ) > 20 then
5224: LD_VAR 0 1
5228: PPUSH
5229: CALL_OW 261
5233: PUSH
5234: LD_INT 20
5236: GREATER
5237: IFFALSE 5251
// SetTag ( bulldozer , 0 ) ;
5239: LD_VAR 0 1
5243: PPUSH
5244: LD_INT 0
5246: PPUSH
5247: CALL_OW 109
// list := ListEnvironmentArea ( area ) ;
5251: LD_ADDR_VAR 0 5
5255: PUSH
5256: LD_VAR 0 2
5260: PPUSH
5261: CALL_OW 353
5265: ST_TO_ADDR
// tmp := [ ] ;
5266: LD_ADDR_VAR 0 6
5270: PUSH
5271: EMPTY
5272: ST_TO_ADDR
// for i = 1 to list do
5273: LD_ADDR_VAR 0 4
5277: PUSH
5278: DOUBLE
5279: LD_INT 1
5281: DEC
5282: ST_TO_ADDR
5283: LD_VAR 0 5
5287: PUSH
5288: FOR_TO
5289: IFFALSE 5387
// if IsEnvironmentDestroyable ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) then
5291: LD_VAR 0 5
5295: PUSH
5296: LD_VAR 0 4
5300: ARRAY
5301: PUSH
5302: LD_INT 1
5304: ARRAY
5305: PPUSH
5306: LD_VAR 0 5
5310: PUSH
5311: LD_VAR 0 4
5315: ARRAY
5316: PUSH
5317: LD_INT 2
5319: ARRAY
5320: PPUSH
5321: CALL_OW 554
5325: IFFALSE 5385
// begin tmp := Replace ( tmp , tmp + 1 , [ list [ i ] [ 1 ] , list [ i ] [ 2 ] ] ) ;
5327: LD_ADDR_VAR 0 6
5331: PUSH
5332: LD_VAR 0 6
5336: PPUSH
5337: LD_VAR 0 6
5341: PUSH
5342: LD_INT 1
5344: PLUS
5345: PPUSH
5346: LD_VAR 0 5
5350: PUSH
5351: LD_VAR 0 4
5355: ARRAY
5356: PUSH
5357: LD_INT 1
5359: ARRAY
5360: PUSH
5361: LD_VAR 0 5
5365: PUSH
5366: LD_VAR 0 4
5370: ARRAY
5371: PUSH
5372: LD_INT 2
5374: ARRAY
5375: PUSH
5376: EMPTY
5377: LIST
5378: LIST
5379: PPUSH
5380: CALL_OW 1
5384: ST_TO_ADDR
// end ;
5385: GO 5288
5387: POP
5388: POP
// ComStop ( bulldozer ) ;
5389: LD_VAR 0 1
5393: PPUSH
5394: CALL_OW 141
// hex := [ GetX ( bulldozer ) , GetY ( bulldozer ) ] ;
5398: LD_ADDR_VAR 0 7
5402: PUSH
5403: LD_VAR 0 1
5407: PPUSH
5408: CALL_OW 250
5412: PUSH
5413: LD_VAR 0 1
5417: PPUSH
5418: CALL_OW 251
5422: PUSH
5423: EMPTY
5424: LIST
5425: LIST
5426: ST_TO_ADDR
// for i = tmp downto 1 do
5427: LD_ADDR_VAR 0 4
5431: PUSH
5432: DOUBLE
5433: LD_VAR 0 6
5437: INC
5438: ST_TO_ADDR
5439: LD_INT 1
5441: PUSH
5442: FOR_DOWNTO
5443: IFFALSE 5531
// begin hex := GetClosestPoint ( hex [ 1 ] , hex [ 2 ] , tmp ) ;
5445: LD_ADDR_VAR 0 7
5449: PUSH
5450: LD_VAR 0 7
5454: PUSH
5455: LD_INT 1
5457: ARRAY
5458: PPUSH
5459: LD_VAR 0 7
5463: PUSH
5464: LD_INT 2
5466: ARRAY
5467: PPUSH
5468: LD_VAR 0 6
5472: PPUSH
5473: CALL 5634 0 3
5477: ST_TO_ADDR
// AddComCutTreeOnHex ( bulldozer , hex [ 1 ] , hex [ 2 ] ) ;
5478: LD_VAR 0 1
5482: PPUSH
5483: LD_VAR 0 7
5487: PUSH
5488: LD_INT 1
5490: ARRAY
5491: PPUSH
5492: LD_VAR 0 7
5496: PUSH
5497: LD_INT 2
5499: ARRAY
5500: PPUSH
5501: CALL 5538 0 3
// tmp := Delete ( tmp , hex [ 3 ] ) ;
5505: LD_ADDR_VAR 0 6
5509: PUSH
5510: LD_VAR 0 6
5514: PPUSH
5515: LD_VAR 0 7
5519: PUSH
5520: LD_INT 3
5522: ARRAY
5523: PPUSH
5524: CALL_OW 3
5528: ST_TO_ADDR
// end ;
5529: GO 5442
5531: POP
5532: POP
// end ;
5533: LD_VAR 0 3
5537: RET
// export function AddComCutTreeOnHex ( bulldozer , x , y ) ; begin
5538: LD_INT 0
5540: PPUSH
// if IsEnvironment ( x , y ) and IsEnvironmentDestroyable ( x , y ) and ValidHex ( x , y ) and HexInfo ( x , y ) = - 1 then
5541: LD_VAR 0 2
5545: PPUSH
5546: LD_VAR 0 3
5550: PPUSH
5551: CALL_OW 351
5555: PUSH
5556: LD_VAR 0 2
5560: PPUSH
5561: LD_VAR 0 3
5565: PPUSH
5566: CALL_OW 554
5570: AND
5571: PUSH
5572: LD_VAR 0 2
5576: PPUSH
5577: LD_VAR 0 3
5581: PPUSH
5582: CALL_OW 488
5586: AND
5587: PUSH
5588: LD_VAR 0 2
5592: PPUSH
5593: LD_VAR 0 3
5597: PPUSH
5598: CALL_OW 428
5602: PUSH
5603: LD_INT 1
5605: NEG
5606: EQUAL
5607: AND
5608: IFFALSE 5629
// AddComMoveXY ( bulldozer , x , y ) ;
5610: LD_VAR 0 1
5614: PPUSH
5615: LD_VAR 0 2
5619: PPUSH
5620: LD_VAR 0 3
5624: PPUSH
5625: CALL_OW 171
// end ;
5629: LD_VAR 0 4
5633: RET
// export function GetClosestPoint ( x , y , list ) ; var i , dist , d , _x , _y , _i ; begin
5634: LD_INT 0
5636: PPUSH
5637: PPUSH
5638: PPUSH
5639: PPUSH
5640: PPUSH
5641: PPUSH
5642: PPUSH
// dist := 99999 ;
5643: LD_ADDR_VAR 0 6
5647: PUSH
5648: LD_INT 99999
5650: ST_TO_ADDR
// for i = 1 to list do
5651: LD_ADDR_VAR 0 5
5655: PUSH
5656: DOUBLE
5657: LD_INT 1
5659: DEC
5660: ST_TO_ADDR
5661: LD_VAR 0 3
5665: PUSH
5666: FOR_TO
5667: IFFALSE 5805
// begin d := GetDistXY ( x , y , list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ;
5669: LD_ADDR_VAR 0 7
5673: PUSH
5674: LD_VAR 0 1
5678: PPUSH
5679: LD_VAR 0 2
5683: PPUSH
5684: LD_VAR 0 3
5688: PUSH
5689: LD_VAR 0 5
5693: ARRAY
5694: PUSH
5695: LD_INT 1
5697: ARRAY
5698: PPUSH
5699: LD_VAR 0 3
5703: PUSH
5704: LD_VAR 0 5
5708: ARRAY
5709: PUSH
5710: LD_INT 2
5712: ARRAY
5713: PPUSH
5714: CALL_OW 298
5718: ST_TO_ADDR
// if d = 0 then
5719: LD_VAR 0 7
5723: PUSH
5724: LD_INT 0
5726: EQUAL
5727: IFFALSE 5731
// continue ;
5729: GO 5666
// if d < dist then
5731: LD_VAR 0 7
5735: PUSH
5736: LD_VAR 0 6
5740: LESS
5741: IFFALSE 5803
// begin _x := list [ i ] [ 1 ] ;
5743: LD_ADDR_VAR 0 8
5747: PUSH
5748: LD_VAR 0 3
5752: PUSH
5753: LD_VAR 0 5
5757: ARRAY
5758: PUSH
5759: LD_INT 1
5761: ARRAY
5762: ST_TO_ADDR
// _y := list [ i ] [ 2 ] ;
5763: LD_ADDR_VAR 0 9
5767: PUSH
5768: LD_VAR 0 3
5772: PUSH
5773: LD_VAR 0 5
5777: ARRAY
5778: PUSH
5779: LD_INT 2
5781: ARRAY
5782: ST_TO_ADDR
// _i := i ;
5783: LD_ADDR_VAR 0 10
5787: PUSH
5788: LD_VAR 0 5
5792: ST_TO_ADDR
// dist := d ;
5793: LD_ADDR_VAR 0 6
5797: PUSH
5798: LD_VAR 0 7
5802: ST_TO_ADDR
// end ; end ;
5803: GO 5666
5805: POP
5806: POP
// result := [ _x , _y , _i , dist ] ;
5807: LD_ADDR_VAR 0 4
5811: PUSH
5812: LD_VAR 0 8
5816: PUSH
5817: LD_VAR 0 9
5821: PUSH
5822: LD_VAR 0 10
5826: PUSH
5827: LD_VAR 0 6
5831: PUSH
5832: EMPTY
5833: LIST
5834: LIST
5835: LIST
5836: LIST
5837: ST_TO_ADDR
// end ;
5838: LD_VAR 0 4
5842: RET
// export function ResAllTechs ( side , lab , nation ) ; var i , tech , cout ; begin
5843: LD_INT 0
5845: PPUSH
5846: PPUSH
5847: PPUSH
5848: PPUSH
// for i = 1 to 72 do
5849: LD_ADDR_VAR 0 5
5853: PUSH
5854: DOUBLE
5855: LD_INT 1
5857: DEC
5858: ST_TO_ADDR
5859: LD_INT 72
5861: PUSH
5862: FOR_TO
5863: IFFALSE 5921
// if GetTech ( i , side ) = state_enabled and TechNationAvailable ( i , nation ) = true then
5865: LD_VAR 0 5
5869: PPUSH
5870: LD_VAR 0 1
5874: PPUSH
5875: CALL_OW 321
5879: PUSH
5880: LD_INT 1
5882: EQUAL
5883: PUSH
5884: LD_VAR 0 5
5888: PPUSH
5889: LD_VAR 0 3
5893: PPUSH
5894: CALL_OW 482
5898: PUSH
5899: LD_INT 1
5901: EQUAL
5902: AND
5903: IFFALSE 5919
// AddComResearch ( lab , i ) ;
5905: LD_VAR 0 2
5909: PPUSH
5910: LD_VAR 0 5
5914: PPUSH
5915: CALL_OW 184
5919: GO 5862
5921: POP
5922: POP
// end ;
5923: LD_VAR 0 4
5927: RET
// export function RepairBuilding ( side , building , area ) ; var buildings_list , i , engineerOkInside , engineerOkOutside , j ; begin
5928: LD_INT 0
5930: PPUSH
5931: PPUSH
5932: PPUSH
5933: PPUSH
5934: PPUSH
5935: PPUSH
// engineerOkInside = UnitsInside ( building ) ;
5936: LD_ADDR_VAR 0 7
5940: PUSH
5941: LD_VAR 0 2
5945: PPUSH
5946: CALL_OW 313
5950: ST_TO_ADDR
// engineerOkOutside = FilterUnitsInArea ( area , [ [ f_side , side ] , [ f_class , 2 ] , [ f_lives , 750 ] , [ f_not , [ f_inside ] ] ] ) ;
5951: LD_ADDR_VAR 0 8
5955: PUSH
5956: LD_VAR 0 3
5960: PPUSH
5961: LD_INT 22
5963: PUSH
5964: LD_VAR 0 1
5968: PUSH
5969: EMPTY
5970: LIST
5971: LIST
5972: PUSH
5973: LD_INT 25
5975: PUSH
5976: LD_INT 2
5978: PUSH
5979: EMPTY
5980: LIST
5981: LIST
5982: PUSH
5983: LD_INT 24
5985: PUSH
5986: LD_INT 750
5988: PUSH
5989: EMPTY
5990: LIST
5991: LIST
5992: PUSH
5993: LD_INT 3
5995: PUSH
5996: LD_INT 54
5998: PUSH
5999: EMPTY
6000: LIST
6001: PUSH
6002: EMPTY
6003: LIST
6004: LIST
6005: PUSH
6006: EMPTY
6007: LIST
6008: LIST
6009: LIST
6010: LIST
6011: PPUSH
6012: CALL_OW 70
6016: ST_TO_ADDR
// buildings_list = FilterUnitsInArea ( area , [ [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
6017: LD_ADDR_VAR 0 5
6021: PUSH
6022: LD_VAR 0 3
6026: PPUSH
6027: LD_INT 22
6029: PUSH
6030: LD_VAR 0 1
6034: PUSH
6035: EMPTY
6036: LIST
6037: LIST
6038: PUSH
6039: LD_INT 21
6041: PUSH
6042: LD_INT 3
6044: PUSH
6045: EMPTY
6046: LIST
6047: LIST
6048: PUSH
6049: LD_INT 3
6051: PUSH
6052: LD_INT 24
6054: PUSH
6055: LD_INT 1000
6057: PUSH
6058: EMPTY
6059: LIST
6060: LIST
6061: PUSH
6062: EMPTY
6063: LIST
6064: LIST
6065: PUSH
6066: EMPTY
6067: LIST
6068: LIST
6069: LIST
6070: PUSH
6071: EMPTY
6072: LIST
6073: PPUSH
6074: CALL_OW 70
6078: ST_TO_ADDR
// if not buildings_list and not FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] , [ f_lives , 250 ] ] ) then
6079: LD_VAR 0 5
6083: NOT
6084: PUSH
6085: LD_INT 22
6087: PUSH
6088: LD_VAR 0 1
6092: PUSH
6093: EMPTY
6094: LIST
6095: LIST
6096: PUSH
6097: LD_INT 25
6099: PUSH
6100: LD_INT 2
6102: PUSH
6103: EMPTY
6104: LIST
6105: LIST
6106: PUSH
6107: LD_INT 24
6109: PUSH
6110: LD_INT 250
6112: PUSH
6113: EMPTY
6114: LIST
6115: LIST
6116: PUSH
6117: EMPTY
6118: LIST
6119: LIST
6120: LIST
6121: PPUSH
6122: CALL_OW 69
6126: NOT
6127: AND
6128: IFFALSE 6132
// exit ;
6130: GO 6244
// if buildings_list > 0 and engineerOkInside then
6132: LD_VAR 0 5
6136: PUSH
6137: LD_INT 0
6139: GREATER
6140: PUSH
6141: LD_VAR 0 7
6145: AND
6146: IFFALSE 6172
// ComExitBuilding ( UnitFilter ( engineerOkInside , [ f_class , 2 ] ) ) ;
6148: LD_VAR 0 7
6152: PPUSH
6153: LD_INT 25
6155: PUSH
6156: LD_INT 2
6158: PUSH
6159: EMPTY
6160: LIST
6161: LIST
6162: PPUSH
6163: CALL_OW 72
6167: PPUSH
6168: CALL_OW 122
// if buildings_list > 0 and engineerOkOutside > 0 then
6172: LD_VAR 0 5
6176: PUSH
6177: LD_INT 0
6179: GREATER
6180: PUSH
6181: LD_VAR 0 8
6185: PUSH
6186: LD_INT 0
6188: GREATER
6189: AND
6190: IFFALSE 6210
// ComRepairBuilding ( engineerOkOutside , buildings_list [ 1 ] ) ;
6192: LD_VAR 0 8
6196: PPUSH
6197: LD_VAR 0 5
6201: PUSH
6202: LD_INT 1
6204: ARRAY
6205: PPUSH
6206: CALL_OW 130
// if buildings_list = 0 and engineerOkOutside > 0 then
6210: LD_VAR 0 5
6214: PUSH
6215: LD_INT 0
6217: EQUAL
6218: PUSH
6219: LD_VAR 0 8
6223: PUSH
6224: LD_INT 0
6226: GREATER
6227: AND
6228: IFFALSE 6244
// ComEnterUnit ( engineerOkOutside , building ) ;
6230: LD_VAR 0 8
6234: PPUSH
6235: LD_VAR 0 2
6239: PPUSH
6240: CALL_OW 120
// end ;
6244: LD_VAR 0 4
6248: RET
// export function HealUnitInBase ( side , healArea , baseArea , build ) ; var sci_list , sci_listOutside , i , j , damageUnits , unitsToHeal , tmp , rnd ; begin
6249: LD_INT 0
6251: PPUSH
6252: PPUSH
6253: PPUSH
6254: PPUSH
6255: PPUSH
6256: PPUSH
6257: PPUSH
6258: PPUSH
6259: PPUSH
// sci_list = FilterAllUnits ( [ [ f_side , side ] , [ f_class , 4 ] , [ f_nation , 2 ] , [ f_lives , 251 ] ] ) ;
6260: LD_ADDR_VAR 0 6
6264: PUSH
6265: LD_INT 22
6267: PUSH
6268: LD_VAR 0 1
6272: PUSH
6273: EMPTY
6274: LIST
6275: LIST
6276: PUSH
6277: LD_INT 25
6279: PUSH
6280: LD_INT 4
6282: PUSH
6283: EMPTY
6284: LIST
6285: LIST
6286: PUSH
6287: LD_INT 23
6289: PUSH
6290: LD_INT 2
6292: PUSH
6293: EMPTY
6294: LIST
6295: LIST
6296: PUSH
6297: LD_INT 24
6299: PUSH
6300: LD_INT 251
6302: PUSH
6303: EMPTY
6304: LIST
6305: LIST
6306: PUSH
6307: EMPTY
6308: LIST
6309: LIST
6310: LIST
6311: LIST
6312: PPUSH
6313: CALL_OW 69
6317: ST_TO_ADDR
// sci_listOutside = FilterUnitsInArea ( baseArea , [ [ f_side , side ] , [ f_nation , 2 ] , [ f_class , 4 ] , [ f_ok ] ] ) ;
6318: LD_ADDR_VAR 0 7
6322: PUSH
6323: LD_VAR 0 3
6327: PPUSH
6328: LD_INT 22
6330: PUSH
6331: LD_VAR 0 1
6335: PUSH
6336: EMPTY
6337: LIST
6338: LIST
6339: PUSH
6340: LD_INT 23
6342: PUSH
6343: LD_INT 2
6345: PUSH
6346: EMPTY
6347: LIST
6348: LIST
6349: PUSH
6350: LD_INT 25
6352: PUSH
6353: LD_INT 4
6355: PUSH
6356: EMPTY
6357: LIST
6358: LIST
6359: PUSH
6360: LD_INT 50
6362: PUSH
6363: EMPTY
6364: LIST
6365: PUSH
6366: EMPTY
6367: LIST
6368: LIST
6369: LIST
6370: LIST
6371: PPUSH
6372: CALL_OW 70
6376: ST_TO_ADDR
// damageUnits = FilterUnitsInArea ( baseArea , [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_class , 3 ] ] , [ f_not , [ f_lives , 750 ] ] ] ) ;
6377: LD_ADDR_VAR 0 10
6381: PUSH
6382: LD_VAR 0 3
6386: PPUSH
6387: LD_INT 22
6389: PUSH
6390: LD_VAR 0 1
6394: PUSH
6395: EMPTY
6396: LIST
6397: LIST
6398: PUSH
6399: LD_INT 21
6401: PUSH
6402: LD_INT 1
6404: PUSH
6405: EMPTY
6406: LIST
6407: LIST
6408: PUSH
6409: LD_INT 3
6411: PUSH
6412: LD_INT 25
6414: PUSH
6415: LD_INT 3
6417: PUSH
6418: EMPTY
6419: LIST
6420: LIST
6421: PUSH
6422: EMPTY
6423: LIST
6424: LIST
6425: PUSH
6426: LD_INT 3
6428: PUSH
6429: LD_INT 24
6431: PUSH
6432: LD_INT 750
6434: PUSH
6435: EMPTY
6436: LIST
6437: LIST
6438: PUSH
6439: EMPTY
6440: LIST
6441: LIST
6442: PUSH
6443: EMPTY
6444: LIST
6445: LIST
6446: LIST
6447: LIST
6448: PPUSH
6449: CALL_OW 70
6453: ST_TO_ADDR
// unitsToHeal = FilterUnitsInArea ( healArea , [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_class , 3 ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
6454: LD_ADDR_VAR 0 11
6458: PUSH
6459: LD_VAR 0 2
6463: PPUSH
6464: LD_INT 22
6466: PUSH
6467: LD_VAR 0 1
6471: PUSH
6472: EMPTY
6473: LIST
6474: LIST
6475: PUSH
6476: LD_INT 21
6478: PUSH
6479: LD_INT 1
6481: PUSH
6482: EMPTY
6483: LIST
6484: LIST
6485: PUSH
6486: LD_INT 3
6488: PUSH
6489: LD_INT 25
6491: PUSH
6492: LD_INT 3
6494: PUSH
6495: EMPTY
6496: LIST
6497: LIST
6498: PUSH
6499: EMPTY
6500: LIST
6501: LIST
6502: PUSH
6503: LD_INT 3
6505: PUSH
6506: LD_INT 24
6508: PUSH
6509: LD_INT 1000
6511: PUSH
6512: EMPTY
6513: LIST
6514: LIST
6515: PUSH
6516: EMPTY
6517: LIST
6518: LIST
6519: PUSH
6520: EMPTY
6521: LIST
6522: LIST
6523: LIST
6524: LIST
6525: PPUSH
6526: CALL_OW 70
6530: ST_TO_ADDR
// if not damageUnits and not unitsToHeal and not sci_list then
6531: LD_VAR 0 10
6535: NOT
6536: PUSH
6537: LD_VAR 0 11
6541: NOT
6542: AND
6543: PUSH
6544: LD_VAR 0 6
6548: NOT
6549: AND
6550: IFFALSE 6554
// exit ;
6552: GO 6788
// if damageUnits > 0 and sci_list > 0 then
6554: LD_VAR 0 10
6558: PUSH
6559: LD_INT 0
6561: GREATER
6562: PUSH
6563: LD_VAR 0 6
6567: PUSH
6568: LD_INT 0
6570: GREATER
6571: AND
6572: IFFALSE 6588
// ComMoveToArea ( damageUnits , healArea ) ;
6574: LD_VAR 0 10
6578: PPUSH
6579: LD_VAR 0 2
6583: PPUSH
6584: CALL_OW 113
// if unitsToHeal > 0 and sci_list > 0 then
6588: LD_VAR 0 11
6592: PUSH
6593: LD_INT 0
6595: GREATER
6596: PUSH
6597: LD_VAR 0 6
6601: PUSH
6602: LD_INT 0
6604: GREATER
6605: AND
6606: IFFALSE 6617
// ComExitBuilding ( sci_list ) ;
6608: LD_VAR 0 6
6612: PPUSH
6613: CALL_OW 122
// if unitsToHeal > 0 and sci_listOutside > 0 then
6617: LD_VAR 0 11
6621: PUSH
6622: LD_INT 0
6624: GREATER
6625: PUSH
6626: LD_VAR 0 7
6630: PUSH
6631: LD_INT 0
6633: GREATER
6634: AND
6635: IFFALSE 6655
// ComHeal ( sci_listOutside , unitsToHeal [ 1 ] ) ;
6637: LD_VAR 0 7
6641: PPUSH
6642: LD_VAR 0 11
6646: PUSH
6647: LD_INT 1
6649: ARRAY
6650: PPUSH
6651: CALL_OW 128
// if damageUnits = 0 and unitsToHeal = 0 and sci_listOutside > 0 then
6655: LD_VAR 0 10
6659: PUSH
6660: LD_INT 0
6662: EQUAL
6663: PUSH
6664: LD_VAR 0 11
6668: PUSH
6669: LD_INT 0
6671: EQUAL
6672: AND
6673: PUSH
6674: LD_VAR 0 7
6678: PUSH
6679: LD_INT 0
6681: GREATER
6682: AND
6683: IFFALSE 6788
// begin tmp = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_btype , b_lab_full ] ] ) ;
6685: LD_ADDR_VAR 0 12
6689: PUSH
6690: LD_INT 22
6692: PUSH
6693: LD_VAR 0 1
6697: PUSH
6698: EMPTY
6699: LIST
6700: LIST
6701: PUSH
6702: LD_INT 21
6704: PUSH
6705: LD_INT 3
6707: PUSH
6708: EMPTY
6709: LIST
6710: LIST
6711: PUSH
6712: LD_INT 30
6714: PUSH
6715: LD_INT 8
6717: PUSH
6718: EMPTY
6719: LIST
6720: LIST
6721: PUSH
6722: EMPTY
6723: LIST
6724: LIST
6725: LIST
6726: PPUSH
6727: CALL_OW 69
6731: ST_TO_ADDR
// rnd = rand ( 1 , tmp ) ;
6732: LD_ADDR_VAR 0 13
6736: PUSH
6737: LD_INT 1
6739: PPUSH
6740: LD_VAR 0 12
6744: PPUSH
6745: CALL_OW 12
6749: ST_TO_ADDR
// ComEnterUnit ( UnitFilter ( sci_listOutside , [ f_not , [ f_hastask ] ] ) , tmp [ rnd ] ) ;
6750: LD_VAR 0 7
6754: PPUSH
6755: LD_INT 3
6757: PUSH
6758: LD_INT 60
6760: PUSH
6761: EMPTY
6762: LIST
6763: PUSH
6764: EMPTY
6765: LIST
6766: LIST
6767: PPUSH
6768: CALL_OW 72
6772: PPUSH
6773: LD_VAR 0 12
6777: PUSH
6778: LD_VAR 0 13
6782: ARRAY
6783: PPUSH
6784: CALL_OW 120
// end ; end ;
6788: LD_VAR 0 5
6792: RET
// export function BuildVehicle ( side , fabric , vehCount , weaponTab , engine , control , chassis ) ; var i ; begin
6793: LD_INT 0
6795: PPUSH
6796: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] ] ) <= vehCount then
6797: LD_INT 22
6799: PUSH
6800: LD_VAR 0 1
6804: PUSH
6805: EMPTY
6806: LIST
6807: LIST
6808: PUSH
6809: LD_INT 21
6811: PUSH
6812: LD_INT 2
6814: PUSH
6815: EMPTY
6816: LIST
6817: LIST
6818: PUSH
6819: EMPTY
6820: LIST
6821: LIST
6822: PPUSH
6823: CALL_OW 69
6827: PUSH
6828: LD_VAR 0 3
6832: LESSEQUAL
6833: IFFALSE 6900
// for i = 1 to vehCount do
6835: LD_ADDR_VAR 0 9
6839: PUSH
6840: DOUBLE
6841: LD_INT 1
6843: DEC
6844: ST_TO_ADDR
6845: LD_VAR 0 3
6849: PUSH
6850: FOR_TO
6851: IFFALSE 6898
// AddComConstruct ( fabric , chassis , engine , control , weaponTab [ Rand ( 1 , weaponTab ) ] ) ;
6853: LD_VAR 0 2
6857: PPUSH
6858: LD_VAR 0 7
6862: PPUSH
6863: LD_VAR 0 5
6867: PPUSH
6868: LD_VAR 0 6
6872: PPUSH
6873: LD_VAR 0 4
6877: PUSH
6878: LD_INT 1
6880: PPUSH
6881: LD_VAR 0 4
6885: PPUSH
6886: CALL_OW 12
6890: ARRAY
6891: PPUSH
6892: CALL_OW 185
6896: GO 6850
6898: POP
6899: POP
// end ;
6900: LD_VAR 0 8
6904: RET
// export function AttackVehicles ( side , meetArea , wayX , wayY ) ; var i , j , vehiclesOK , target1 , target2 , seeEnemy ; begin
6905: LD_INT 0
6907: PPUSH
6908: PPUSH
6909: PPUSH
6910: PPUSH
6911: PPUSH
6912: PPUSH
6913: PPUSH
// vehiclesOK = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_crane ] ] , [ f_lives , 650 ] ] ) ;
6914: LD_ADDR_VAR 0 8
6918: PUSH
6919: LD_INT 22
6921: PUSH
6922: LD_VAR 0 1
6926: PUSH
6927: EMPTY
6928: LIST
6929: LIST
6930: PUSH
6931: LD_INT 21
6933: PUSH
6934: LD_INT 2
6936: PUSH
6937: EMPTY
6938: LIST
6939: LIST
6940: PUSH
6941: LD_INT 3
6943: PUSH
6944: LD_INT 34
6946: PUSH
6947: LD_INT 51
6949: PUSH
6950: EMPTY
6951: LIST
6952: LIST
6953: PUSH
6954: LD_INT 34
6956: PUSH
6957: LD_INT 53
6959: PUSH
6960: EMPTY
6961: LIST
6962: LIST
6963: PUSH
6964: LD_INT 34
6966: PUSH
6967: LD_INT 52
6969: PUSH
6970: EMPTY
6971: LIST
6972: LIST
6973: PUSH
6974: EMPTY
6975: LIST
6976: LIST
6977: LIST
6978: LIST
6979: PUSH
6980: LD_INT 24
6982: PUSH
6983: LD_INT 650
6985: PUSH
6986: EMPTY
6987: LIST
6988: LIST
6989: PUSH
6990: EMPTY
6991: LIST
6992: LIST
6993: LIST
6994: LIST
6995: PPUSH
6996: CALL_OW 69
7000: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 1000 ] ] ) >= [ 3 , 4 , 5 ] [ Difficulty ] then
7001: LD_INT 22
7003: PUSH
7004: LD_VAR 0 1
7008: PUSH
7009: EMPTY
7010: LIST
7011: LIST
7012: PUSH
7013: LD_INT 21
7015: PUSH
7016: LD_INT 2
7018: PUSH
7019: EMPTY
7020: LIST
7021: LIST
7022: PUSH
7023: LD_INT 24
7025: PUSH
7026: LD_INT 1000
7028: PUSH
7029: EMPTY
7030: LIST
7031: LIST
7032: PUSH
7033: EMPTY
7034: LIST
7035: LIST
7036: LIST
7037: PPUSH
7038: CALL_OW 69
7042: PUSH
7043: LD_INT 3
7045: PUSH
7046: LD_INT 4
7048: PUSH
7049: LD_INT 5
7051: PUSH
7052: EMPTY
7053: LIST
7054: LIST
7055: LIST
7056: PUSH
7057: LD_OWVAR 67
7061: ARRAY
7062: GREATEREQUAL
7063: IFFALSE 7560
// repeat wait ( 0 0$1 ) ;
7065: LD_INT 35
7067: PPUSH
7068: CALL_OW 67
// vehiclesOK = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_crane ] ] , [ f_lives , 650 ] ] ) ;
7072: LD_ADDR_VAR 0 8
7076: PUSH
7077: LD_INT 22
7079: PUSH
7080: LD_VAR 0 1
7084: PUSH
7085: EMPTY
7086: LIST
7087: LIST
7088: PUSH
7089: LD_INT 21
7091: PUSH
7092: LD_INT 2
7094: PUSH
7095: EMPTY
7096: LIST
7097: LIST
7098: PUSH
7099: LD_INT 3
7101: PUSH
7102: LD_INT 34
7104: PUSH
7105: LD_INT 51
7107: PUSH
7108: EMPTY
7109: LIST
7110: LIST
7111: PUSH
7112: LD_INT 34
7114: PUSH
7115: LD_INT 53
7117: PUSH
7118: EMPTY
7119: LIST
7120: LIST
7121: PUSH
7122: LD_INT 34
7124: PUSH
7125: LD_INT 52
7127: PUSH
7128: EMPTY
7129: LIST
7130: LIST
7131: PUSH
7132: EMPTY
7133: LIST
7134: LIST
7135: LIST
7136: LIST
7137: PUSH
7138: LD_INT 24
7140: PUSH
7141: LD_INT 650
7143: PUSH
7144: EMPTY
7145: LIST
7146: LIST
7147: PUSH
7148: EMPTY
7149: LIST
7150: LIST
7151: LIST
7152: LIST
7153: PPUSH
7154: CALL_OW 69
7158: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , side ] , [ f_inarea , meetArea ] ] ) and seeEnemy = 0 then
7159: LD_INT 22
7161: PUSH
7162: LD_VAR 0 1
7166: PUSH
7167: EMPTY
7168: LIST
7169: LIST
7170: PUSH
7171: LD_INT 95
7173: PUSH
7174: LD_VAR 0 2
7178: PUSH
7179: EMPTY
7180: LIST
7181: LIST
7182: PUSH
7183: EMPTY
7184: LIST
7185: LIST
7186: PPUSH
7187: CALL_OW 69
7191: NOT
7192: PUSH
7193: LD_VAR 0 11
7197: PUSH
7198: LD_INT 0
7200: EQUAL
7201: AND
7202: IFFALSE 7257
// for i := 1 to wayX do
7204: LD_ADDR_VAR 0 6
7208: PUSH
7209: DOUBLE
7210: LD_INT 1
7212: DEC
7213: ST_TO_ADDR
7214: LD_VAR 0 3
7218: PUSH
7219: FOR_TO
7220: IFFALSE 7255
// AddComAgressiveMove ( vehiclesOK , wayX [ i ] , wayY [ i ] ) ;
7222: LD_VAR 0 8
7226: PPUSH
7227: LD_VAR 0 3
7231: PUSH
7232: LD_VAR 0 6
7236: ARRAY
7237: PPUSH
7238: LD_VAR 0 4
7242: PUSH
7243: LD_VAR 0 6
7247: ARRAY
7248: PPUSH
7249: CALL_OW 174
7253: GO 7219
7255: POP
7256: POP
// if FilterAllUnits ( [ [ f_side , side ] , [ f_inarea , meetArea ] ] ) then
7257: LD_INT 22
7259: PUSH
7260: LD_VAR 0 1
7264: PUSH
7265: EMPTY
7266: LIST
7267: LIST
7268: PUSH
7269: LD_INT 95
7271: PUSH
7272: LD_VAR 0 2
7276: PUSH
7277: EMPTY
7278: LIST
7279: LIST
7280: PUSH
7281: EMPTY
7282: LIST
7283: LIST
7284: PPUSH
7285: CALL_OW 69
7289: IFFALSE 7513
// begin seeEnemy = 1 ;
7291: LD_ADDR_VAR 0 11
7295: PUSH
7296: LD_INT 1
7298: ST_TO_ADDR
// for j in vehiclesOK do
7299: LD_ADDR_VAR 0 7
7303: PUSH
7304: LD_VAR 0 8
7308: PUSH
7309: FOR_IN
7310: IFFALSE 7511
// begin target1 := NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , side ] , [ f_see , 1 ] ] ) , j ) ;
7312: LD_ADDR_VAR 0 9
7316: PUSH
7317: LD_INT 81
7319: PUSH
7320: LD_VAR 0 1
7324: PUSH
7325: EMPTY
7326: LIST
7327: LIST
7328: PUSH
7329: LD_INT 101
7331: PUSH
7332: LD_INT 1
7334: PUSH
7335: EMPTY
7336: LIST
7337: LIST
7338: PUSH
7339: EMPTY
7340: LIST
7341: LIST
7342: PPUSH
7343: CALL_OW 69
7347: PPUSH
7348: LD_VAR 0 7
7352: PPUSH
7353: CALL_OW 74
7357: ST_TO_ADDR
// target2 := NearestUnitToUnit ( FilterAllUnits ( [ [ [ f_enemy , side ] , [ f_see , 1 ] , [ f_or , [ f_occupied ] , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ] ) , j ) ;
7358: LD_ADDR_VAR 0 10
7362: PUSH
7363: LD_INT 81
7365: PUSH
7366: LD_VAR 0 1
7370: PUSH
7371: EMPTY
7372: LIST
7373: LIST
7374: PUSH
7375: LD_INT 101
7377: PUSH
7378: LD_INT 1
7380: PUSH
7381: EMPTY
7382: LIST
7383: LIST
7384: PUSH
7385: LD_INT 2
7387: PUSH
7388: LD_INT 59
7390: PUSH
7391: EMPTY
7392: LIST
7393: PUSH
7394: LD_INT 21
7396: PUSH
7397: LD_INT 1
7399: PUSH
7400: EMPTY
7401: LIST
7402: LIST
7403: PUSH
7404: LD_INT 21
7406: PUSH
7407: LD_INT 2
7409: PUSH
7410: EMPTY
7411: LIST
7412: LIST
7413: PUSH
7414: EMPTY
7415: LIST
7416: LIST
7417: LIST
7418: LIST
7419: PUSH
7420: EMPTY
7421: LIST
7422: LIST
7423: LIST
7424: PUSH
7425: EMPTY
7426: LIST
7427: PPUSH
7428: CALL_OW 69
7432: PPUSH
7433: LD_VAR 0 7
7437: PPUSH
7438: CALL_OW 74
7442: ST_TO_ADDR
// if GetDistUnits ( j , target1 ) + 8 < GetDistUnits ( j , target2 ) then
7443: LD_VAR 0 7
7447: PPUSH
7448: LD_VAR 0 9
7452: PPUSH
7453: CALL_OW 296
7457: PUSH
7458: LD_INT 8
7460: PLUS
7461: PUSH
7462: LD_VAR 0 7
7466: PPUSH
7467: LD_VAR 0 10
7471: PPUSH
7472: CALL_OW 296
7476: LESS
7477: IFFALSE 7495
// ComAttackUnit ( j , target1 ) else
7479: LD_VAR 0 7
7483: PPUSH
7484: LD_VAR 0 9
7488: PPUSH
7489: CALL_OW 115
7493: GO 7509
// ComAttackUnit ( j , target2 ) ;
7495: LD_VAR 0 7
7499: PPUSH
7500: LD_VAR 0 10
7504: PPUSH
7505: CALL_OW 115
// end ;
7509: GO 7309
7511: POP
7512: POP
// end ; until FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 1000 ] ] ) = 0 ;
7513: LD_INT 22
7515: PUSH
7516: LD_VAR 0 1
7520: PUSH
7521: EMPTY
7522: LIST
7523: LIST
7524: PUSH
7525: LD_INT 21
7527: PUSH
7528: LD_INT 2
7530: PUSH
7531: EMPTY
7532: LIST
7533: LIST
7534: PUSH
7535: LD_INT 24
7537: PUSH
7538: LD_INT 1000
7540: PUSH
7541: EMPTY
7542: LIST
7543: LIST
7544: PUSH
7545: EMPTY
7546: LIST
7547: LIST
7548: LIST
7549: PPUSH
7550: CALL_OW 69
7554: PUSH
7555: LD_INT 0
7557: EQUAL
7558: IFFALSE 7065
// seeEnemy = 0 ;
7560: LD_ADDR_VAR 0 11
7564: PUSH
7565: LD_INT 0
7567: ST_TO_ADDR
// end ;
7568: LD_VAR 0 5
7572: RET
// export function RepairVehicles ( side , area , repX , repY ) ; var i , j , damageVehicles ; begin
7573: LD_INT 0
7575: PPUSH
7576: PPUSH
7577: PPUSH
7578: PPUSH
// damageVehicles = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_crane ] ] , [ f_not , [ f_lives , 650 ] ] ] ) ;
7579: LD_ADDR_VAR 0 8
7583: PUSH
7584: LD_INT 22
7586: PUSH
7587: LD_VAR 0 1
7591: PUSH
7592: EMPTY
7593: LIST
7594: LIST
7595: PUSH
7596: LD_INT 21
7598: PUSH
7599: LD_INT 2
7601: PUSH
7602: EMPTY
7603: LIST
7604: LIST
7605: PUSH
7606: LD_INT 3
7608: PUSH
7609: LD_INT 34
7611: PUSH
7612: LD_INT 51
7614: PUSH
7615: EMPTY
7616: LIST
7617: LIST
7618: PUSH
7619: LD_INT 34
7621: PUSH
7622: LD_INT 53
7624: PUSH
7625: EMPTY
7626: LIST
7627: LIST
7628: PUSH
7629: LD_INT 34
7631: PUSH
7632: LD_INT 52
7634: PUSH
7635: EMPTY
7636: LIST
7637: LIST
7638: PUSH
7639: EMPTY
7640: LIST
7641: LIST
7642: LIST
7643: LIST
7644: PUSH
7645: LD_INT 3
7647: PUSH
7648: LD_INT 24
7650: PUSH
7651: LD_INT 650
7653: PUSH
7654: EMPTY
7655: LIST
7656: LIST
7657: PUSH
7658: EMPTY
7659: LIST
7660: LIST
7661: PUSH
7662: EMPTY
7663: LIST
7664: LIST
7665: LIST
7666: LIST
7667: PPUSH
7668: CALL_OW 69
7672: ST_TO_ADDR
// if damageVehicles > 0 then
7673: LD_VAR 0 8
7677: PUSH
7678: LD_INT 0
7680: GREATER
7681: IFFALSE 7702
// ComMoveXY ( damageVehicles , repX , repY ) ;
7683: LD_VAR 0 8
7687: PPUSH
7688: LD_VAR 0 3
7692: PPUSH
7693: LD_VAR 0 4
7697: PPUSH
7698: CALL_OW 111
// if UnitFilter ( damageVehicles , [ [ f_inarea , area ] , [ f_not , [ f_empty ] ] ] ) > 0 then
7702: LD_VAR 0 8
7706: PPUSH
7707: LD_INT 95
7709: PUSH
7710: LD_VAR 0 2
7714: PUSH
7715: EMPTY
7716: LIST
7717: LIST
7718: PUSH
7719: LD_INT 3
7721: PUSH
7722: LD_INT 58
7724: PUSH
7725: EMPTY
7726: LIST
7727: PUSH
7728: EMPTY
7729: LIST
7730: LIST
7731: PUSH
7732: EMPTY
7733: LIST
7734: LIST
7735: PPUSH
7736: CALL_OW 72
7740: PUSH
7741: LD_INT 0
7743: GREATER
7744: IFFALSE 7811
// for i in UnitFilter ( damageVehicles , [ [ f_inarea , area ] , [ f_not , [ f_empty ] ] ] ) do
7746: LD_ADDR_VAR 0 6
7750: PUSH
7751: LD_VAR 0 8
7755: PPUSH
7756: LD_INT 95
7758: PUSH
7759: LD_VAR 0 2
7763: PUSH
7764: EMPTY
7765: LIST
7766: LIST
7767: PUSH
7768: LD_INT 3
7770: PUSH
7771: LD_INT 58
7773: PUSH
7774: EMPTY
7775: LIST
7776: PUSH
7777: EMPTY
7778: LIST
7779: LIST
7780: PUSH
7781: EMPTY
7782: LIST
7783: LIST
7784: PPUSH
7785: CALL_OW 72
7789: PUSH
7790: FOR_IN
7791: IFFALSE 7809
// ComExitVehicle ( UnitsInside ( i ) ) ;
7793: LD_VAR 0 6
7797: PPUSH
7798: CALL_OW 313
7802: PPUSH
7803: CALL_OW 121
7807: GO 7790
7809: POP
7810: POP
// end ;
7811: LD_VAR 0 5
7815: RET
// export function RespawnAttackInfantry ( side , nation , soldierCount , sniperCount , bazookCount , mortalCount , medicCount , skil , spawnArea , healArea , targetSide , strategy ) ; var i , j , un , damageUnit_list , medic_list , soldiersOK_list , enemyUnits , und , target1 , target2 ; begin
7816: LD_INT 0
7818: PPUSH
7819: PPUSH
7820: PPUSH
7821: PPUSH
7822: PPUSH
7823: PPUSH
7824: PPUSH
7825: PPUSH
7826: PPUSH
7827: PPUSH
7828: PPUSH
// for i = 1 to medicCount do
7829: LD_ADDR_VAR 0 14
7833: PUSH
7834: DOUBLE
7835: LD_INT 1
7837: DEC
7838: ST_TO_ADDR
7839: LD_VAR 0 7
7843: PUSH
7844: FOR_TO
7845: IFFALSE 7927
// begin uc_side = side ;
7847: LD_ADDR_OWVAR 20
7851: PUSH
7852: LD_VAR 0 1
7856: ST_TO_ADDR
// uc_nation = nation ;
7857: LD_ADDR_OWVAR 21
7861: PUSH
7862: LD_VAR 0 2
7866: ST_TO_ADDR
// hc_name =  ;
7867: LD_ADDR_OWVAR 26
7871: PUSH
7872: LD_STRING 
7874: ST_TO_ADDR
// hc_gallery =  ;
7875: LD_ADDR_OWVAR 33
7879: PUSH
7880: LD_STRING 
7882: ST_TO_ADDR
// PrepareHuman ( false , 4 , skil ) ;
7883: LD_INT 0
7885: PPUSH
7886: LD_INT 4
7888: PPUSH
7889: LD_VAR 0 8
7893: PPUSH
7894: CALL_OW 380
// un = CreateHuman ;
7898: LD_ADDR_VAR 0 16
7902: PUSH
7903: CALL_OW 44
7907: ST_TO_ADDR
// PlaceUnitArea ( un , spawnArea , false ) ;
7908: LD_VAR 0 16
7912: PPUSH
7913: LD_VAR 0 9
7917: PPUSH
7918: LD_INT 0
7920: PPUSH
7921: CALL_OW 49
// end ;
7925: GO 7844
7927: POP
7928: POP
// for i = 1 to soldierCount do
7929: LD_ADDR_VAR 0 14
7933: PUSH
7934: DOUBLE
7935: LD_INT 1
7937: DEC
7938: ST_TO_ADDR
7939: LD_VAR 0 3
7943: PUSH
7944: FOR_TO
7945: IFFALSE 8027
// begin uc_side = side ;
7947: LD_ADDR_OWVAR 20
7951: PUSH
7952: LD_VAR 0 1
7956: ST_TO_ADDR
// uc_nation = nation ;
7957: LD_ADDR_OWVAR 21
7961: PUSH
7962: LD_VAR 0 2
7966: ST_TO_ADDR
// hc_name =  ;
7967: LD_ADDR_OWVAR 26
7971: PUSH
7972: LD_STRING 
7974: ST_TO_ADDR
// hc_gallery =  ;
7975: LD_ADDR_OWVAR 33
7979: PUSH
7980: LD_STRING 
7982: ST_TO_ADDR
// PrepareHuman ( false , 1 , skil ) ;
7983: LD_INT 0
7985: PPUSH
7986: LD_INT 1
7988: PPUSH
7989: LD_VAR 0 8
7993: PPUSH
7994: CALL_OW 380
// un = CreateHuman ;
7998: LD_ADDR_VAR 0 16
8002: PUSH
8003: CALL_OW 44
8007: ST_TO_ADDR
// PlaceUnitArea ( un , spawnArea , false ) ;
8008: LD_VAR 0 16
8012: PPUSH
8013: LD_VAR 0 9
8017: PPUSH
8018: LD_INT 0
8020: PPUSH
8021: CALL_OW 49
// end ;
8025: GO 7944
8027: POP
8028: POP
// for i = 1 to sniperCount do
8029: LD_ADDR_VAR 0 14
8033: PUSH
8034: DOUBLE
8035: LD_INT 1
8037: DEC
8038: ST_TO_ADDR
8039: LD_VAR 0 4
8043: PUSH
8044: FOR_TO
8045: IFFALSE 8127
// begin uc_side = side ;
8047: LD_ADDR_OWVAR 20
8051: PUSH
8052: LD_VAR 0 1
8056: ST_TO_ADDR
// uc_nation = nation ;
8057: LD_ADDR_OWVAR 21
8061: PUSH
8062: LD_VAR 0 2
8066: ST_TO_ADDR
// hc_name =  ;
8067: LD_ADDR_OWVAR 26
8071: PUSH
8072: LD_STRING 
8074: ST_TO_ADDR
// hc_gallery =  ;
8075: LD_ADDR_OWVAR 33
8079: PUSH
8080: LD_STRING 
8082: ST_TO_ADDR
// PrepareHuman ( false , 5 , skil ) ;
8083: LD_INT 0
8085: PPUSH
8086: LD_INT 5
8088: PPUSH
8089: LD_VAR 0 8
8093: PPUSH
8094: CALL_OW 380
// un = CreateHuman ;
8098: LD_ADDR_VAR 0 16
8102: PUSH
8103: CALL_OW 44
8107: ST_TO_ADDR
// PlaceUnitArea ( un , spawnArea , false ) ;
8108: LD_VAR 0 16
8112: PPUSH
8113: LD_VAR 0 9
8117: PPUSH
8118: LD_INT 0
8120: PPUSH
8121: CALL_OW 49
// end ;
8125: GO 8044
8127: POP
8128: POP
// for i = 1 to bazookCount do
8129: LD_ADDR_VAR 0 14
8133: PUSH
8134: DOUBLE
8135: LD_INT 1
8137: DEC
8138: ST_TO_ADDR
8139: LD_VAR 0 5
8143: PUSH
8144: FOR_TO
8145: IFFALSE 8227
// begin uc_side = side ;
8147: LD_ADDR_OWVAR 20
8151: PUSH
8152: LD_VAR 0 1
8156: ST_TO_ADDR
// uc_nation = nation ;
8157: LD_ADDR_OWVAR 21
8161: PUSH
8162: LD_VAR 0 2
8166: ST_TO_ADDR
// hc_name =  ;
8167: LD_ADDR_OWVAR 26
8171: PUSH
8172: LD_STRING 
8174: ST_TO_ADDR
// hc_gallery =  ;
8175: LD_ADDR_OWVAR 33
8179: PUSH
8180: LD_STRING 
8182: ST_TO_ADDR
// PrepareHuman ( false , 9 , skil ) ;
8183: LD_INT 0
8185: PPUSH
8186: LD_INT 9
8188: PPUSH
8189: LD_VAR 0 8
8193: PPUSH
8194: CALL_OW 380
// un = CreateHuman ;
8198: LD_ADDR_VAR 0 16
8202: PUSH
8203: CALL_OW 44
8207: ST_TO_ADDR
// PlaceUnitArea ( un , spawnArea , false ) ;
8208: LD_VAR 0 16
8212: PPUSH
8213: LD_VAR 0 9
8217: PPUSH
8218: LD_INT 0
8220: PPUSH
8221: CALL_OW 49
// end ;
8225: GO 8144
8227: POP
8228: POP
// for i = 1 to mortalCount do
8229: LD_ADDR_VAR 0 14
8233: PUSH
8234: DOUBLE
8235: LD_INT 1
8237: DEC
8238: ST_TO_ADDR
8239: LD_VAR 0 6
8243: PUSH
8244: FOR_TO
8245: IFFALSE 8327
// begin uc_side = side ;
8247: LD_ADDR_OWVAR 20
8251: PUSH
8252: LD_VAR 0 1
8256: ST_TO_ADDR
// uc_nation = nation ;
8257: LD_ADDR_OWVAR 21
8261: PUSH
8262: LD_VAR 0 2
8266: ST_TO_ADDR
// hc_name =  ;
8267: LD_ADDR_OWVAR 26
8271: PUSH
8272: LD_STRING 
8274: ST_TO_ADDR
// hc_gallery =  ;
8275: LD_ADDR_OWVAR 33
8279: PUSH
8280: LD_STRING 
8282: ST_TO_ADDR
// PrepareHuman ( false , 8 , skil ) ;
8283: LD_INT 0
8285: PPUSH
8286: LD_INT 8
8288: PPUSH
8289: LD_VAR 0 8
8293: PPUSH
8294: CALL_OW 380
// un = CreateHuman ;
8298: LD_ADDR_VAR 0 16
8302: PUSH
8303: CALL_OW 44
8307: ST_TO_ADDR
// PlaceUnitArea ( un , spawnArea , false ) ;
8308: LD_VAR 0 16
8312: PPUSH
8313: LD_VAR 0 9
8317: PPUSH
8318: LD_INT 0
8320: PPUSH
8321: CALL_OW 49
// end ;
8325: GO 8244
8327: POP
8328: POP
// soldiersOK_list = FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
8329: LD_ADDR_VAR 0 19
8333: PUSH
8334: LD_INT 22
8336: PUSH
8337: LD_VAR 0 1
8341: PUSH
8342: EMPTY
8343: LIST
8344: LIST
8345: PUSH
8346: LD_INT 2
8348: PUSH
8349: LD_INT 25
8351: PUSH
8352: LD_INT 1
8354: PUSH
8355: EMPTY
8356: LIST
8357: LIST
8358: PUSH
8359: LD_INT 25
8361: PUSH
8362: LD_INT 5
8364: PUSH
8365: EMPTY
8366: LIST
8367: LIST
8368: PUSH
8369: LD_INT 25
8371: PUSH
8372: LD_INT 8
8374: PUSH
8375: EMPTY
8376: LIST
8377: LIST
8378: PUSH
8379: LD_INT 25
8381: PUSH
8382: LD_INT 9
8384: PUSH
8385: EMPTY
8386: LIST
8387: LIST
8388: PUSH
8389: EMPTY
8390: LIST
8391: LIST
8392: LIST
8393: LIST
8394: LIST
8395: PUSH
8396: EMPTY
8397: LIST
8398: LIST
8399: PPUSH
8400: CALL_OW 69
8404: ST_TO_ADDR
// medic_list = FilterAllUnits ( [ [ f_side , side ] , [ f_class , 4 ] ] ) ;
8405: LD_ADDR_VAR 0 18
8409: PUSH
8410: LD_INT 22
8412: PUSH
8413: LD_VAR 0 1
8417: PUSH
8418: EMPTY
8419: LIST
8420: LIST
8421: PUSH
8422: LD_INT 25
8424: PUSH
8425: LD_INT 4
8427: PUSH
8428: EMPTY
8429: LIST
8430: LIST
8431: PUSH
8432: EMPTY
8433: LIST
8434: LIST
8435: PPUSH
8436: CALL_OW 69
8440: ST_TO_ADDR
// ComMoveToArea ( medic_list , healArea ) ;
8441: LD_VAR 0 18
8445: PPUSH
8446: LD_VAR 0 10
8450: PPUSH
8451: CALL_OW 113
// if strategy = 1 then
8455: LD_VAR 0 12
8459: PUSH
8460: LD_INT 1
8462: EQUAL
8463: IFFALSE 8954
// begin for i in soldiersOK_list do
8465: LD_ADDR_VAR 0 14
8469: PUSH
8470: LD_VAR 0 19
8474: PUSH
8475: FOR_IN
8476: IFFALSE 8540
// begin AddComAgressiveMove ( i , 91 , 63 ) ;
8478: LD_VAR 0 14
8482: PPUSH
8483: LD_INT 91
8485: PPUSH
8486: LD_INT 63
8488: PPUSH
8489: CALL_OW 174
// AddComAgressiveMove ( i , 101 , 53 ) ;
8493: LD_VAR 0 14
8497: PPUSH
8498: LD_INT 101
8500: PPUSH
8501: LD_INT 53
8503: PPUSH
8504: CALL_OW 174
// AddComAgressiveMove ( i , 75 , 23 ) ;
8508: LD_VAR 0 14
8512: PPUSH
8513: LD_INT 75
8515: PPUSH
8516: LD_INT 23
8518: PPUSH
8519: CALL_OW 174
// AddComAgressiveMove ( i , 78 , 8 ) ;
8523: LD_VAR 0 14
8527: PPUSH
8528: LD_INT 78
8530: PPUSH
8531: LD_INT 8
8533: PPUSH
8534: CALL_OW 174
// end ;
8538: GO 8475
8540: POP
8541: POP
// wait ( 0 0$30 ) ;
8542: LD_INT 1050
8544: PPUSH
8545: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8549: LD_INT 35
8551: PPUSH
8552: CALL_OW 67
// damageUnit_list = FilterAllUnits ( [ [ f_side , side ] , [ f_and , [ f_not , [ f_lives , 550 ] ] , [ f_lives , 250 ] ] ] ) ;
8556: LD_ADDR_VAR 0 17
8560: PUSH
8561: LD_INT 22
8563: PUSH
8564: LD_VAR 0 1
8568: PUSH
8569: EMPTY
8570: LIST
8571: LIST
8572: PUSH
8573: LD_INT 1
8575: PUSH
8576: LD_INT 3
8578: PUSH
8579: LD_INT 24
8581: PUSH
8582: LD_INT 550
8584: PUSH
8585: EMPTY
8586: LIST
8587: LIST
8588: PUSH
8589: EMPTY
8590: LIST
8591: LIST
8592: PUSH
8593: LD_INT 24
8595: PUSH
8596: LD_INT 250
8598: PUSH
8599: EMPTY
8600: LIST
8601: LIST
8602: PUSH
8603: EMPTY
8604: LIST
8605: LIST
8606: LIST
8607: PUSH
8608: EMPTY
8609: LIST
8610: LIST
8611: PPUSH
8612: CALL_OW 69
8616: ST_TO_ADDR
// soldiersOK_list = FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] , [ f_lives , 1000 ] ] ) ;
8617: LD_ADDR_VAR 0 19
8621: PUSH
8622: LD_INT 22
8624: PUSH
8625: LD_VAR 0 1
8629: PUSH
8630: EMPTY
8631: LIST
8632: LIST
8633: PUSH
8634: LD_INT 2
8636: PUSH
8637: LD_INT 25
8639: PUSH
8640: LD_INT 1
8642: PUSH
8643: EMPTY
8644: LIST
8645: LIST
8646: PUSH
8647: LD_INT 25
8649: PUSH
8650: LD_INT 5
8652: PUSH
8653: EMPTY
8654: LIST
8655: LIST
8656: PUSH
8657: LD_INT 25
8659: PUSH
8660: LD_INT 8
8662: PUSH
8663: EMPTY
8664: LIST
8665: LIST
8666: PUSH
8667: LD_INT 25
8669: PUSH
8670: LD_INT 9
8672: PUSH
8673: EMPTY
8674: LIST
8675: LIST
8676: PUSH
8677: EMPTY
8678: LIST
8679: LIST
8680: LIST
8681: LIST
8682: LIST
8683: PUSH
8684: LD_INT 24
8686: PUSH
8687: LD_INT 1000
8689: PUSH
8690: EMPTY
8691: LIST
8692: LIST
8693: PUSH
8694: EMPTY
8695: LIST
8696: LIST
8697: LIST
8698: PPUSH
8699: CALL_OW 69
8703: ST_TO_ADDR
// if medicCount > 0 then
8704: LD_VAR 0 7
8708: PUSH
8709: LD_INT 0
8711: GREATER
8712: IFFALSE 8756
// begin if damageUnit_list > 0 then
8714: LD_VAR 0 17
8718: PUSH
8719: LD_INT 0
8721: GREATER
8722: IFFALSE 8756
// begin ComMoveToArea ( damageUnit_list , healArea ) ;
8724: LD_VAR 0 17
8728: PPUSH
8729: LD_VAR 0 10
8733: PPUSH
8734: CALL_OW 113
// AddComHeal ( medicCount , damageUnit_list [ 1 ] ) ;
8738: LD_VAR 0 7
8742: PPUSH
8743: LD_VAR 0 17
8747: PUSH
8748: LD_INT 1
8750: ARRAY
8751: PPUSH
8752: CALL_OW 188
// end ; end ; for i in soldiersOK_list do
8756: LD_ADDR_VAR 0 14
8760: PUSH
8761: LD_VAR 0 19
8765: PUSH
8766: FOR_IN
8767: IFFALSE 8943
// begin target1 := NearestUnitToUnit ( FilterAllUnits ( [ f_side , targetSide ] ) , i ) ;
8769: LD_ADDR_VAR 0 22
8773: PUSH
8774: LD_INT 22
8776: PUSH
8777: LD_VAR 0 11
8781: PUSH
8782: EMPTY
8783: LIST
8784: LIST
8785: PPUSH
8786: CALL_OW 69
8790: PPUSH
8791: LD_VAR 0 14
8795: PPUSH
8796: CALL_OW 74
8800: ST_TO_ADDR
// target2 := NearestUnitToUnit ( FilterAllUnits ( [ [ [ f_side , targetSide ] , [ f_or , [ f_occupied ] , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ] ) , i ) ;
8801: LD_ADDR_VAR 0 23
8805: PUSH
8806: LD_INT 22
8808: PUSH
8809: LD_VAR 0 11
8813: PUSH
8814: EMPTY
8815: LIST
8816: LIST
8817: PUSH
8818: LD_INT 2
8820: PUSH
8821: LD_INT 59
8823: PUSH
8824: EMPTY
8825: LIST
8826: PUSH
8827: LD_INT 21
8829: PUSH
8830: LD_INT 1
8832: PUSH
8833: EMPTY
8834: LIST
8835: LIST
8836: PUSH
8837: LD_INT 21
8839: PUSH
8840: LD_INT 2
8842: PUSH
8843: EMPTY
8844: LIST
8845: LIST
8846: PUSH
8847: EMPTY
8848: LIST
8849: LIST
8850: LIST
8851: LIST
8852: PUSH
8853: EMPTY
8854: LIST
8855: LIST
8856: PUSH
8857: EMPTY
8858: LIST
8859: PPUSH
8860: CALL_OW 69
8864: PPUSH
8865: LD_VAR 0 14
8869: PPUSH
8870: CALL_OW 74
8874: ST_TO_ADDR
// if GetDistUnits ( i , target1 ) + 8 < GetDistUnits ( i , target2 ) then
8875: LD_VAR 0 14
8879: PPUSH
8880: LD_VAR 0 22
8884: PPUSH
8885: CALL_OW 296
8889: PUSH
8890: LD_INT 8
8892: PLUS
8893: PUSH
8894: LD_VAR 0 14
8898: PPUSH
8899: LD_VAR 0 23
8903: PPUSH
8904: CALL_OW 296
8908: LESS
8909: IFFALSE 8927
// begin ComAttackUnit ( i , target1 ) ;
8911: LD_VAR 0 14
8915: PPUSH
8916: LD_VAR 0 22
8920: PPUSH
8921: CALL_OW 115
// end else
8925: GO 8941
// begin ComAttackUnit ( i , target2 ) ;
8927: LD_VAR 0 14
8931: PPUSH
8932: LD_VAR 0 23
8936: PPUSH
8937: CALL_OW 115
// end ; end ;
8941: GO 8766
8943: POP
8944: POP
// until soldiersOK_list = [ ] ;
8945: LD_VAR 0 19
8949: PUSH
8950: EMPTY
8951: EQUAL
8952: IFFALSE 8549
// end ; if strategy = 2 then
8954: LD_VAR 0 12
8958: PUSH
8959: LD_INT 2
8961: EQUAL
8962: IFFALSE 9416
// begin for i in soldiersOK_list do
8964: LD_ADDR_VAR 0 14
8968: PUSH
8969: LD_VAR 0 19
8973: PUSH
8974: FOR_IN
8975: IFFALSE 9009
// begin AddComAgressiveMove ( i , 91 , 63 ) ;
8977: LD_VAR 0 14
8981: PPUSH
8982: LD_INT 91
8984: PPUSH
8985: LD_INT 63
8987: PPUSH
8988: CALL_OW 174
// AddComAgressiveMove ( i , 75 , 33 ) ;
8992: LD_VAR 0 14
8996: PPUSH
8997: LD_INT 75
8999: PPUSH
9000: LD_INT 33
9002: PPUSH
9003: CALL_OW 174
// end ;
9007: GO 8974
9009: POP
9010: POP
// repeat wait ( 0 0$3 ) ;
9011: LD_INT 105
9013: PPUSH
9014: CALL_OW 67
// damageUnit_list = FilterAllUnits ( [ [ f_side , side ] , [ f_and , [ f_not , [ f_lives , 550 ] ] , [ f_lives , 250 ] ] ] ) ;
9018: LD_ADDR_VAR 0 17
9022: PUSH
9023: LD_INT 22
9025: PUSH
9026: LD_VAR 0 1
9030: PUSH
9031: EMPTY
9032: LIST
9033: LIST
9034: PUSH
9035: LD_INT 1
9037: PUSH
9038: LD_INT 3
9040: PUSH
9041: LD_INT 24
9043: PUSH
9044: LD_INT 550
9046: PUSH
9047: EMPTY
9048: LIST
9049: LIST
9050: PUSH
9051: EMPTY
9052: LIST
9053: LIST
9054: PUSH
9055: LD_INT 24
9057: PUSH
9058: LD_INT 250
9060: PUSH
9061: EMPTY
9062: LIST
9063: LIST
9064: PUSH
9065: EMPTY
9066: LIST
9067: LIST
9068: LIST
9069: PUSH
9070: EMPTY
9071: LIST
9072: LIST
9073: PPUSH
9074: CALL_OW 69
9078: ST_TO_ADDR
// soldiersOK_list = FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] , [ f_lives , 1000 ] ] ) ;
9079: LD_ADDR_VAR 0 19
9083: PUSH
9084: LD_INT 22
9086: PUSH
9087: LD_VAR 0 1
9091: PUSH
9092: EMPTY
9093: LIST
9094: LIST
9095: PUSH
9096: LD_INT 2
9098: PUSH
9099: LD_INT 25
9101: PUSH
9102: LD_INT 1
9104: PUSH
9105: EMPTY
9106: LIST
9107: LIST
9108: PUSH
9109: LD_INT 25
9111: PUSH
9112: LD_INT 5
9114: PUSH
9115: EMPTY
9116: LIST
9117: LIST
9118: PUSH
9119: LD_INT 25
9121: PUSH
9122: LD_INT 8
9124: PUSH
9125: EMPTY
9126: LIST
9127: LIST
9128: PUSH
9129: LD_INT 25
9131: PUSH
9132: LD_INT 9
9134: PUSH
9135: EMPTY
9136: LIST
9137: LIST
9138: PUSH
9139: EMPTY
9140: LIST
9141: LIST
9142: LIST
9143: LIST
9144: LIST
9145: PUSH
9146: LD_INT 24
9148: PUSH
9149: LD_INT 1000
9151: PUSH
9152: EMPTY
9153: LIST
9154: LIST
9155: PUSH
9156: EMPTY
9157: LIST
9158: LIST
9159: LIST
9160: PPUSH
9161: CALL_OW 69
9165: ST_TO_ADDR
// if medicCount > 0 then
9166: LD_VAR 0 7
9170: PUSH
9171: LD_INT 0
9173: GREATER
9174: IFFALSE 9218
// begin if damageUnit_list > 0 then
9176: LD_VAR 0 17
9180: PUSH
9181: LD_INT 0
9183: GREATER
9184: IFFALSE 9218
// begin ComMoveToArea ( damageUnit_list , healArea ) ;
9186: LD_VAR 0 17
9190: PPUSH
9191: LD_VAR 0 10
9195: PPUSH
9196: CALL_OW 113
// AddComHeal ( medicCount , damageUnit_list [ 1 ] ) ;
9200: LD_VAR 0 7
9204: PPUSH
9205: LD_VAR 0 17
9209: PUSH
9210: LD_INT 1
9212: ARRAY
9213: PPUSH
9214: CALL_OW 188
// end ; end ; for i in soldiersOK_list do
9218: LD_ADDR_VAR 0 14
9222: PUSH
9223: LD_VAR 0 19
9227: PUSH
9228: FOR_IN
9229: IFFALSE 9405
// begin target1 := NearestUnitToUnit ( FilterAllUnits ( [ f_side , targetSide ] ) , i ) ;
9231: LD_ADDR_VAR 0 22
9235: PUSH
9236: LD_INT 22
9238: PUSH
9239: LD_VAR 0 11
9243: PUSH
9244: EMPTY
9245: LIST
9246: LIST
9247: PPUSH
9248: CALL_OW 69
9252: PPUSH
9253: LD_VAR 0 14
9257: PPUSH
9258: CALL_OW 74
9262: ST_TO_ADDR
// target2 := NearestUnitToUnit ( FilterAllUnits ( [ [ [ f_side , targetSide ] , [ f_or , [ f_occupied ] , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ] ) , i ) ;
9263: LD_ADDR_VAR 0 23
9267: PUSH
9268: LD_INT 22
9270: PUSH
9271: LD_VAR 0 11
9275: PUSH
9276: EMPTY
9277: LIST
9278: LIST
9279: PUSH
9280: LD_INT 2
9282: PUSH
9283: LD_INT 59
9285: PUSH
9286: EMPTY
9287: LIST
9288: PUSH
9289: LD_INT 21
9291: PUSH
9292: LD_INT 1
9294: PUSH
9295: EMPTY
9296: LIST
9297: LIST
9298: PUSH
9299: LD_INT 21
9301: PUSH
9302: LD_INT 2
9304: PUSH
9305: EMPTY
9306: LIST
9307: LIST
9308: PUSH
9309: EMPTY
9310: LIST
9311: LIST
9312: LIST
9313: LIST
9314: PUSH
9315: EMPTY
9316: LIST
9317: LIST
9318: PUSH
9319: EMPTY
9320: LIST
9321: PPUSH
9322: CALL_OW 69
9326: PPUSH
9327: LD_VAR 0 14
9331: PPUSH
9332: CALL_OW 74
9336: ST_TO_ADDR
// if GetDistUnits ( i , target1 ) + 8 < GetDistUnits ( i , target2 ) then
9337: LD_VAR 0 14
9341: PPUSH
9342: LD_VAR 0 22
9346: PPUSH
9347: CALL_OW 296
9351: PUSH
9352: LD_INT 8
9354: PLUS
9355: PUSH
9356: LD_VAR 0 14
9360: PPUSH
9361: LD_VAR 0 23
9365: PPUSH
9366: CALL_OW 296
9370: LESS
9371: IFFALSE 9389
// begin ComAttackUnit ( i , target1 ) ;
9373: LD_VAR 0 14
9377: PPUSH
9378: LD_VAR 0 22
9382: PPUSH
9383: CALL_OW 115
// end else
9387: GO 9403
// begin ComAttackUnit ( i , target2 ) ;
9389: LD_VAR 0 14
9393: PPUSH
9394: LD_VAR 0 23
9398: PPUSH
9399: CALL_OW 115
// end ; end ;
9403: GO 9228
9405: POP
9406: POP
// until soldiersOK_list = [ ] ;
9407: LD_VAR 0 19
9411: PUSH
9412: EMPTY
9413: EQUAL
9414: IFFALSE 9011
// end ; if not soldiersOK_list and medic_list then
9416: LD_VAR 0 19
9420: NOT
9421: PUSH
9422: LD_VAR 0 18
9426: AND
9427: IFFALSE 9567
// begin repeat medic_list = FilterAllUnits ( [ [ f_side , side ] , [ f_class , 4 ] , [ f_ok ] ] ) ;
9429: LD_ADDR_VAR 0 18
9433: PUSH
9434: LD_INT 22
9436: PUSH
9437: LD_VAR 0 1
9441: PUSH
9442: EMPTY
9443: LIST
9444: LIST
9445: PUSH
9446: LD_INT 25
9448: PUSH
9449: LD_INT 4
9451: PUSH
9452: EMPTY
9453: LIST
9454: LIST
9455: PUSH
9456: LD_INT 50
9458: PUSH
9459: EMPTY
9460: LIST
9461: PUSH
9462: EMPTY
9463: LIST
9464: LIST
9465: LIST
9466: PPUSH
9467: CALL_OW 69
9471: ST_TO_ADDR
// wait ( 0 0$1 ) ;
9472: LD_INT 35
9474: PPUSH
9475: CALL_OW 67
// for i in medic_list do
9479: LD_ADDR_VAR 0 14
9483: PUSH
9484: LD_VAR 0 18
9488: PUSH
9489: FOR_IN
9490: IFFALSE 9558
// if not HasTask ( i ) and not IsInArea ( i , RussianAttack ) then
9492: LD_VAR 0 14
9496: PPUSH
9497: CALL_OW 314
9501: NOT
9502: PUSH
9503: LD_VAR 0 14
9507: PPUSH
9508: LD_INT 4
9510: PPUSH
9511: CALL_OW 308
9515: NOT
9516: AND
9517: IFFALSE 9533
// ComMoveToArea ( i , RussianAttack ) else
9519: LD_VAR 0 14
9523: PPUSH
9524: LD_INT 4
9526: PPUSH
9527: CALL_OW 113
9531: GO 9556
// if IsInArea ( i , RussianAttack ) then
9533: LD_VAR 0 14
9537: PPUSH
9538: LD_INT 4
9540: PPUSH
9541: CALL_OW 308
9545: IFFALSE 9556
// RemoveUnit ( i ) ;
9547: LD_VAR 0 14
9551: PPUSH
9552: CALL_OW 64
9556: GO 9489
9558: POP
9559: POP
// until not medic_list ;
9560: LD_VAR 0 18
9564: NOT
9565: IFFALSE 9429
// end ; end ;
9567: LD_VAR 0 13
9571: RET
// export function RespawnAttackVehicle ( area , side , vehCount , mehskill , nation , vehEngine , vehControl , RUWeapons , ARWeapons , AMWeapon , targetSide ) ; var i , j , un , veh , ruChassisTab , arChassisTab , amChassisTab , vehicleOK_list , target1 , target2 ; begin
9572: LD_INT 0
9574: PPUSH
9575: PPUSH
9576: PPUSH
9577: PPUSH
9578: PPUSH
9579: PPUSH
9580: PPUSH
9581: PPUSH
9582: PPUSH
9583: PPUSH
9584: PPUSH
// amChassisTab = [ ] ;
9585: LD_ADDR_VAR 0 19
9589: PUSH
9590: EMPTY
9591: ST_TO_ADDR
// arChassisTab = [ ] ;
9592: LD_ADDR_VAR 0 18
9596: PUSH
9597: EMPTY
9598: ST_TO_ADDR
// ruChassisTab = [ ] ;
9599: LD_ADDR_VAR 0 17
9603: PUSH
9604: EMPTY
9605: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
9606: LD_INT 35
9608: PPUSH
9609: CALL_OW 67
// if nation = 1 then
9613: LD_VAR 0 5
9617: PUSH
9618: LD_INT 1
9620: EQUAL
9621: IFFALSE 10112
// begin uc_side = side ;
9623: LD_ADDR_OWVAR 20
9627: PUSH
9628: LD_VAR 0 2
9632: ST_TO_ADDR
// uc_nation = nation ;
9633: LD_ADDR_OWVAR 21
9637: PUSH
9638: LD_VAR 0 5
9642: ST_TO_ADDR
// vc_engine = vehengine ;
9643: LD_ADDR_OWVAR 39
9647: PUSH
9648: LD_VAR 0 6
9652: ST_TO_ADDR
// vc_control = vehcontrol ;
9653: LD_ADDR_OWVAR 38
9657: PUSH
9658: LD_VAR 0 7
9662: ST_TO_ADDR
// vc_weapon = AMWeapon [ Rand ( 1 , AMWeapon ) ] ;
9663: LD_ADDR_OWVAR 40
9667: PUSH
9668: LD_VAR 0 10
9672: PUSH
9673: LD_INT 1
9675: PPUSH
9676: LD_VAR 0 10
9680: PPUSH
9681: CALL_OW 12
9685: ARRAY
9686: ST_TO_ADDR
// for j = 1 to AMWeapon do
9687: LD_ADDR_VAR 0 14
9691: PUSH
9692: DOUBLE
9693: LD_INT 1
9695: DEC
9696: ST_TO_ADDR
9697: LD_VAR 0 10
9701: PUSH
9702: FOR_TO
9703: IFFALSE 10004
// begin if AMWeapon [ j ] = 2 or AMWeapon [ j ] = 3 then
9705: LD_VAR 0 10
9709: PUSH
9710: LD_VAR 0 14
9714: ARRAY
9715: PUSH
9716: LD_INT 2
9718: EQUAL
9719: PUSH
9720: LD_VAR 0 10
9724: PUSH
9725: LD_VAR 0 14
9729: ARRAY
9730: PUSH
9731: LD_INT 3
9733: EQUAL
9734: OR
9735: IFFALSE 9788
// begin amChassisTab = [ 1 , 2 , 3 , 4 , 5 ] ;
9737: LD_ADDR_VAR 0 19
9741: PUSH
9742: LD_INT 1
9744: PUSH
9745: LD_INT 2
9747: PUSH
9748: LD_INT 3
9750: PUSH
9751: LD_INT 4
9753: PUSH
9754: LD_INT 5
9756: PUSH
9757: EMPTY
9758: LIST
9759: LIST
9760: LIST
9761: LIST
9762: LIST
9763: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
9764: LD_ADDR_OWVAR 37
9768: PUSH
9769: LD_VAR 0 19
9773: PUSH
9774: LD_INT 1
9776: PPUSH
9777: LD_VAR 0 19
9781: PPUSH
9782: CALL_OW 12
9786: ARRAY
9787: ST_TO_ADDR
// end ; if AMWeapon [ j ] = 4 or AMWeapon [ j ] = 5 or AMWeapon [ j ] = 9 or AMWeapon [ j ] = 11 or AMWeapon [ j ] = 7 then
9788: LD_VAR 0 10
9792: PUSH
9793: LD_VAR 0 14
9797: ARRAY
9798: PUSH
9799: LD_INT 4
9801: EQUAL
9802: PUSH
9803: LD_VAR 0 10
9807: PUSH
9808: LD_VAR 0 14
9812: ARRAY
9813: PUSH
9814: LD_INT 5
9816: EQUAL
9817: OR
9818: PUSH
9819: LD_VAR 0 10
9823: PUSH
9824: LD_VAR 0 14
9828: ARRAY
9829: PUSH
9830: LD_INT 9
9832: EQUAL
9833: OR
9834: PUSH
9835: LD_VAR 0 10
9839: PUSH
9840: LD_VAR 0 14
9844: ARRAY
9845: PUSH
9846: LD_INT 11
9848: EQUAL
9849: OR
9850: PUSH
9851: LD_VAR 0 10
9855: PUSH
9856: LD_VAR 0 14
9860: ARRAY
9861: PUSH
9862: LD_INT 7
9864: EQUAL
9865: OR
9866: IFFALSE 9915
// begin amChassisTab = [ 2 , 3 , 4 , 5 ] ;
9868: LD_ADDR_VAR 0 19
9872: PUSH
9873: LD_INT 2
9875: PUSH
9876: LD_INT 3
9878: PUSH
9879: LD_INT 4
9881: PUSH
9882: LD_INT 5
9884: PUSH
9885: EMPTY
9886: LIST
9887: LIST
9888: LIST
9889: LIST
9890: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
9891: LD_ADDR_OWVAR 37
9895: PUSH
9896: LD_VAR 0 19
9900: PUSH
9901: LD_INT 1
9903: PPUSH
9904: LD_VAR 0 19
9908: PPUSH
9909: CALL_OW 12
9913: ARRAY
9914: ST_TO_ADDR
// end ; if AMWeapon [ j ] = 8 or AMWeapon [ j ] = 6 or AMWeapon [ j ] = 10 then
9915: LD_VAR 0 10
9919: PUSH
9920: LD_VAR 0 14
9924: ARRAY
9925: PUSH
9926: LD_INT 8
9928: EQUAL
9929: PUSH
9930: LD_VAR 0 10
9934: PUSH
9935: LD_VAR 0 14
9939: ARRAY
9940: PUSH
9941: LD_INT 6
9943: EQUAL
9944: OR
9945: PUSH
9946: LD_VAR 0 10
9950: PUSH
9951: LD_VAR 0 14
9955: ARRAY
9956: PUSH
9957: LD_INT 10
9959: EQUAL
9960: OR
9961: IFFALSE 10002
// begin amChassisTab = [ 4 , 5 ] ;
9963: LD_ADDR_VAR 0 19
9967: PUSH
9968: LD_INT 4
9970: PUSH
9971: LD_INT 5
9973: PUSH
9974: EMPTY
9975: LIST
9976: LIST
9977: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
9978: LD_ADDR_OWVAR 37
9982: PUSH
9983: LD_VAR 0 19
9987: PUSH
9988: LD_INT 1
9990: PPUSH
9991: LD_VAR 0 19
9995: PPUSH
9996: CALL_OW 12
10000: ARRAY
10001: ST_TO_ADDR
// end ; end ;
10002: GO 9702
10004: POP
10005: POP
// veh = CreateVehicle ;
10006: LD_ADDR_VAR 0 16
10010: PUSH
10011: CALL_OW 45
10015: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
10016: LD_VAR 0 16
10020: PPUSH
10021: LD_VAR 0 1
10025: PPUSH
10026: LD_INT 0
10028: PPUSH
10029: CALL_OW 49
// if vehControl = 1 then
10033: LD_VAR 0 7
10037: PUSH
10038: LD_INT 1
10040: EQUAL
10041: IFFALSE 10098
// begin hc_gallery =  ;
10043: LD_ADDR_OWVAR 33
10047: PUSH
10048: LD_STRING 
10050: ST_TO_ADDR
// hc_name =  ;
10051: LD_ADDR_OWVAR 26
10055: PUSH
10056: LD_STRING 
10058: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
10059: LD_INT 0
10061: PPUSH
10062: LD_INT 3
10064: PPUSH
10065: LD_VAR 0 4
10069: PPUSH
10070: CALL_OW 380
// un = CreateHuman ;
10074: LD_ADDR_VAR 0 15
10078: PUSH
10079: CALL_OW 44
10083: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
10084: LD_VAR 0 15
10088: PPUSH
10089: LD_VAR 0 16
10093: PPUSH
10094: CALL_OW 52
// end ; i = i + 1 ;
10098: LD_ADDR_VAR 0 13
10102: PUSH
10103: LD_VAR 0 13
10107: PUSH
10108: LD_INT 1
10110: PLUS
10111: ST_TO_ADDR
// end ; if nation = 2 then
10112: LD_VAR 0 5
10116: PUSH
10117: LD_INT 2
10119: EQUAL
10120: IFFALSE 10544
// begin uc_side = side ;
10122: LD_ADDR_OWVAR 20
10126: PUSH
10127: LD_VAR 0 2
10131: ST_TO_ADDR
// uc_nation = nation ;
10132: LD_ADDR_OWVAR 21
10136: PUSH
10137: LD_VAR 0 5
10141: ST_TO_ADDR
// vc_engine = vehengine ;
10142: LD_ADDR_OWVAR 39
10146: PUSH
10147: LD_VAR 0 6
10151: ST_TO_ADDR
// vc_control = vehcontrol ;
10152: LD_ADDR_OWVAR 38
10156: PUSH
10157: LD_VAR 0 7
10161: ST_TO_ADDR
// vc_weapon = ARWeapons [ Rand ( 1 , ARWeapons ) ] ;
10162: LD_ADDR_OWVAR 40
10166: PUSH
10167: LD_VAR 0 9
10171: PUSH
10172: LD_INT 1
10174: PPUSH
10175: LD_VAR 0 9
10179: PPUSH
10180: CALL_OW 12
10184: ARRAY
10185: ST_TO_ADDR
// for j = 1 to ARWeapons do
10186: LD_ADDR_VAR 0 14
10190: PUSH
10191: DOUBLE
10192: LD_INT 1
10194: DEC
10195: ST_TO_ADDR
10196: LD_VAR 0 9
10200: PUSH
10201: FOR_TO
10202: IFFALSE 10436
// begin if ARWeapons [ j ] = 24 or ARWeapons [ j ] = 22 or ARWeapons [ j ] = 23 or ARWeapons [ j ] = 30 then
10204: LD_VAR 0 9
10208: PUSH
10209: LD_VAR 0 14
10213: ARRAY
10214: PUSH
10215: LD_INT 24
10217: EQUAL
10218: PUSH
10219: LD_VAR 0 9
10223: PUSH
10224: LD_VAR 0 14
10228: ARRAY
10229: PUSH
10230: LD_INT 22
10232: EQUAL
10233: OR
10234: PUSH
10235: LD_VAR 0 9
10239: PUSH
10240: LD_VAR 0 14
10244: ARRAY
10245: PUSH
10246: LD_INT 23
10248: EQUAL
10249: OR
10250: PUSH
10251: LD_VAR 0 9
10255: PUSH
10256: LD_VAR 0 14
10260: ARRAY
10261: PUSH
10262: LD_INT 30
10264: EQUAL
10265: OR
10266: IFFALSE 10315
// begin arChassisTab = [ 11 , 12 , 13 , 14 ] ;
10268: LD_ADDR_VAR 0 18
10272: PUSH
10273: LD_INT 11
10275: PUSH
10276: LD_INT 12
10278: PUSH
10279: LD_INT 13
10281: PUSH
10282: LD_INT 14
10284: PUSH
10285: EMPTY
10286: LIST
10287: LIST
10288: LIST
10289: LIST
10290: ST_TO_ADDR
// vc_chassis = arChassisTab [ Rand ( 1 , arChassisTab ) ] ;
10291: LD_ADDR_OWVAR 37
10295: PUSH
10296: LD_VAR 0 18
10300: PUSH
10301: LD_INT 1
10303: PPUSH
10304: LD_VAR 0 18
10308: PPUSH
10309: CALL_OW 12
10313: ARRAY
10314: ST_TO_ADDR
// end ; if ARWeapons [ j ] = 29 or ARWeapons [ j ] = 28 or ARWeapons [ j ] = 27 or ARWeapons [ j ] = 26 or ARWeapons [ j ] = 25 then
10315: LD_VAR 0 9
10319: PUSH
10320: LD_VAR 0 14
10324: ARRAY
10325: PUSH
10326: LD_INT 29
10328: EQUAL
10329: PUSH
10330: LD_VAR 0 9
10334: PUSH
10335: LD_VAR 0 14
10339: ARRAY
10340: PUSH
10341: LD_INT 28
10343: EQUAL
10344: OR
10345: PUSH
10346: LD_VAR 0 9
10350: PUSH
10351: LD_VAR 0 14
10355: ARRAY
10356: PUSH
10357: LD_INT 27
10359: EQUAL
10360: OR
10361: PUSH
10362: LD_VAR 0 9
10366: PUSH
10367: LD_VAR 0 14
10371: ARRAY
10372: PUSH
10373: LD_INT 26
10375: EQUAL
10376: OR
10377: PUSH
10378: LD_VAR 0 9
10382: PUSH
10383: LD_VAR 0 14
10387: ARRAY
10388: PUSH
10389: LD_INT 25
10391: EQUAL
10392: OR
10393: IFFALSE 10434
// begin arChassisTab = [ 13 , 14 ] ;
10395: LD_ADDR_VAR 0 18
10399: PUSH
10400: LD_INT 13
10402: PUSH
10403: LD_INT 14
10405: PUSH
10406: EMPTY
10407: LIST
10408: LIST
10409: ST_TO_ADDR
// vc_chassis = arChassisTab [ Rand ( 1 , arChassisTab ) ] ;
10410: LD_ADDR_OWVAR 37
10414: PUSH
10415: LD_VAR 0 18
10419: PUSH
10420: LD_INT 1
10422: PPUSH
10423: LD_VAR 0 18
10427: PPUSH
10428: CALL_OW 12
10432: ARRAY
10433: ST_TO_ADDR
// end ; end ;
10434: GO 10201
10436: POP
10437: POP
// veh = CreateVehicle ;
10438: LD_ADDR_VAR 0 16
10442: PUSH
10443: CALL_OW 45
10447: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
10448: LD_VAR 0 16
10452: PPUSH
10453: LD_VAR 0 1
10457: PPUSH
10458: LD_INT 0
10460: PPUSH
10461: CALL_OW 49
// if vehcontrol = 1 then
10465: LD_VAR 0 7
10469: PUSH
10470: LD_INT 1
10472: EQUAL
10473: IFFALSE 10530
// begin hc_gallery =  ;
10475: LD_ADDR_OWVAR 33
10479: PUSH
10480: LD_STRING 
10482: ST_TO_ADDR
// hc_name =  ;
10483: LD_ADDR_OWVAR 26
10487: PUSH
10488: LD_STRING 
10490: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
10491: LD_INT 0
10493: PPUSH
10494: LD_INT 3
10496: PPUSH
10497: LD_VAR 0 4
10501: PPUSH
10502: CALL_OW 380
// un = CreateHuman ;
10506: LD_ADDR_VAR 0 15
10510: PUSH
10511: CALL_OW 44
10515: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
10516: LD_VAR 0 15
10520: PPUSH
10521: LD_VAR 0 16
10525: PPUSH
10526: CALL_OW 52
// end ; i = i + 1 ;
10530: LD_ADDR_VAR 0 13
10534: PUSH
10535: LD_VAR 0 13
10539: PUSH
10540: LD_INT 1
10542: PLUS
10543: ST_TO_ADDR
// end ; if nation = 3 then
10544: LD_VAR 0 5
10548: PUSH
10549: LD_INT 3
10551: EQUAL
10552: IFFALSE 10944
// begin uc_side = side ;
10554: LD_ADDR_OWVAR 20
10558: PUSH
10559: LD_VAR 0 2
10563: ST_TO_ADDR
// uc_nation = nation ;
10564: LD_ADDR_OWVAR 21
10568: PUSH
10569: LD_VAR 0 5
10573: ST_TO_ADDR
// vc_engine = vehengine ;
10574: LD_ADDR_OWVAR 39
10578: PUSH
10579: LD_VAR 0 6
10583: ST_TO_ADDR
// vc_control = vehcontrol ;
10584: LD_ADDR_OWVAR 38
10588: PUSH
10589: LD_VAR 0 7
10593: ST_TO_ADDR
// vc_weapon = RUWeapons [ Rand ( 1 , RUWeapons ) ] ;
10594: LD_ADDR_OWVAR 40
10598: PUSH
10599: LD_VAR 0 8
10603: PUSH
10604: LD_INT 1
10606: PPUSH
10607: LD_VAR 0 8
10611: PPUSH
10612: CALL_OW 12
10616: ARRAY
10617: ST_TO_ADDR
// for j = 1 to RuWeapons do
10618: LD_ADDR_VAR 0 14
10622: PUSH
10623: DOUBLE
10624: LD_INT 1
10626: DEC
10627: ST_TO_ADDR
10628: LD_VAR 0 8
10632: PUSH
10633: FOR_TO
10634: IFFALSE 10836
// begin if RUWeapons [ j ] = 42 or RUWeapons [ j ] = 43 or RUWeapons [ j ] = 44 or RUWeapons [ j ] = 45 or RUWeapons [ j ] = 49 then
10636: LD_VAR 0 8
10640: PUSH
10641: LD_VAR 0 14
10645: ARRAY
10646: PUSH
10647: LD_INT 42
10649: EQUAL
10650: PUSH
10651: LD_VAR 0 8
10655: PUSH
10656: LD_VAR 0 14
10660: ARRAY
10661: PUSH
10662: LD_INT 43
10664: EQUAL
10665: OR
10666: PUSH
10667: LD_VAR 0 8
10671: PUSH
10672: LD_VAR 0 14
10676: ARRAY
10677: PUSH
10678: LD_INT 44
10680: EQUAL
10681: OR
10682: PUSH
10683: LD_VAR 0 8
10687: PUSH
10688: LD_VAR 0 14
10692: ARRAY
10693: PUSH
10694: LD_INT 45
10696: EQUAL
10697: OR
10698: PUSH
10699: LD_VAR 0 8
10703: PUSH
10704: LD_VAR 0 14
10708: ARRAY
10709: PUSH
10710: LD_INT 49
10712: EQUAL
10713: OR
10714: IFFALSE 10763
// begin ruChassisTab = [ 21 , 22 , 23 , 24 ] ;
10716: LD_ADDR_VAR 0 17
10720: PUSH
10721: LD_INT 21
10723: PUSH
10724: LD_INT 22
10726: PUSH
10727: LD_INT 23
10729: PUSH
10730: LD_INT 24
10732: PUSH
10733: EMPTY
10734: LIST
10735: LIST
10736: LIST
10737: LIST
10738: ST_TO_ADDR
// vc_chassis = ruChassisTab [ Rand ( 1 , ruChassisTab ) ] ;
10739: LD_ADDR_OWVAR 37
10743: PUSH
10744: LD_VAR 0 17
10748: PUSH
10749: LD_INT 1
10751: PPUSH
10752: LD_VAR 0 17
10756: PPUSH
10757: CALL_OW 12
10761: ARRAY
10762: ST_TO_ADDR
// end ; if RUWeapons [ j ] = 46 or RUWeapons [ j ] = 47 then
10763: LD_VAR 0 8
10767: PUSH
10768: LD_VAR 0 14
10772: ARRAY
10773: PUSH
10774: LD_INT 46
10776: EQUAL
10777: PUSH
10778: LD_VAR 0 8
10782: PUSH
10783: LD_VAR 0 14
10787: ARRAY
10788: PUSH
10789: LD_INT 47
10791: EQUAL
10792: OR
10793: IFFALSE 10834
// begin ruChassisTab = [ 23 , 24 ] ;
10795: LD_ADDR_VAR 0 17
10799: PUSH
10800: LD_INT 23
10802: PUSH
10803: LD_INT 24
10805: PUSH
10806: EMPTY
10807: LIST
10808: LIST
10809: ST_TO_ADDR
// vc_chassis = ruChassisTab [ Rand ( 1 , ruChassisTab ) ] ;
10810: LD_ADDR_OWVAR 37
10814: PUSH
10815: LD_VAR 0 17
10819: PUSH
10820: LD_INT 1
10822: PPUSH
10823: LD_VAR 0 17
10827: PPUSH
10828: CALL_OW 12
10832: ARRAY
10833: ST_TO_ADDR
// end ; end ;
10834: GO 10633
10836: POP
10837: POP
// veh = CreateVehicle ;
10838: LD_ADDR_VAR 0 16
10842: PUSH
10843: CALL_OW 45
10847: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
10848: LD_VAR 0 16
10852: PPUSH
10853: LD_VAR 0 1
10857: PPUSH
10858: LD_INT 0
10860: PPUSH
10861: CALL_OW 49
// if vehcontrol = 1 then
10865: LD_VAR 0 7
10869: PUSH
10870: LD_INT 1
10872: EQUAL
10873: IFFALSE 10930
// begin hc_gallery =  ;
10875: LD_ADDR_OWVAR 33
10879: PUSH
10880: LD_STRING 
10882: ST_TO_ADDR
// hc_name =  ;
10883: LD_ADDR_OWVAR 26
10887: PUSH
10888: LD_STRING 
10890: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
10891: LD_INT 0
10893: PPUSH
10894: LD_INT 3
10896: PPUSH
10897: LD_VAR 0 4
10901: PPUSH
10902: CALL_OW 380
// un = CreateHuman ;
10906: LD_ADDR_VAR 0 15
10910: PUSH
10911: CALL_OW 44
10915: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
10916: LD_VAR 0 15
10920: PPUSH
10921: LD_VAR 0 16
10925: PPUSH
10926: CALL_OW 52
// end ; i = i + 1 ;
10930: LD_ADDR_VAR 0 13
10934: PUSH
10935: LD_VAR 0 13
10939: PUSH
10940: LD_INT 1
10942: PLUS
10943: ST_TO_ADDR
// end ; until i = vehCount ;
10944: LD_VAR 0 13
10948: PUSH
10949: LD_VAR 0 3
10953: EQUAL
10954: IFFALSE 9606
// repeat wait ( 0 0$1 ) ;
10956: LD_INT 35
10958: PPUSH
10959: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 250 ] , [ f_not , [ f_empty ] ] ] ) > 0 then
10963: LD_INT 22
10965: PUSH
10966: LD_VAR 0 2
10970: PUSH
10971: EMPTY
10972: LIST
10973: LIST
10974: PUSH
10975: LD_INT 21
10977: PUSH
10978: LD_INT 2
10980: PUSH
10981: EMPTY
10982: LIST
10983: LIST
10984: PUSH
10985: LD_INT 24
10987: PUSH
10988: LD_INT 250
10990: PUSH
10991: EMPTY
10992: LIST
10993: LIST
10994: PUSH
10995: LD_INT 3
10997: PUSH
10998: LD_INT 58
11000: PUSH
11001: EMPTY
11002: LIST
11003: PUSH
11004: EMPTY
11005: LIST
11006: LIST
11007: PUSH
11008: EMPTY
11009: LIST
11010: LIST
11011: LIST
11012: LIST
11013: PPUSH
11014: CALL_OW 69
11018: PUSH
11019: LD_INT 0
11021: GREATER
11022: IFFALSE 11264
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 250 ] , [ f_not , [ f_empty ] ] ] ) do
11024: LD_ADDR_VAR 0 13
11028: PUSH
11029: LD_INT 22
11031: PUSH
11032: LD_VAR 0 2
11036: PUSH
11037: EMPTY
11038: LIST
11039: LIST
11040: PUSH
11041: LD_INT 21
11043: PUSH
11044: LD_INT 2
11046: PUSH
11047: EMPTY
11048: LIST
11049: LIST
11050: PUSH
11051: LD_INT 24
11053: PUSH
11054: LD_INT 250
11056: PUSH
11057: EMPTY
11058: LIST
11059: LIST
11060: PUSH
11061: LD_INT 3
11063: PUSH
11064: LD_INT 58
11066: PUSH
11067: EMPTY
11068: LIST
11069: PUSH
11070: EMPTY
11071: LIST
11072: LIST
11073: PUSH
11074: EMPTY
11075: LIST
11076: LIST
11077: LIST
11078: LIST
11079: PPUSH
11080: CALL_OW 69
11084: PUSH
11085: FOR_IN
11086: IFFALSE 11262
// begin target1 := NearestUnitToUnit ( FilterAllUnits ( [ f_side , targetSide ] ) , i ) ;
11088: LD_ADDR_VAR 0 21
11092: PUSH
11093: LD_INT 22
11095: PUSH
11096: LD_VAR 0 11
11100: PUSH
11101: EMPTY
11102: LIST
11103: LIST
11104: PPUSH
11105: CALL_OW 69
11109: PPUSH
11110: LD_VAR 0 13
11114: PPUSH
11115: CALL_OW 74
11119: ST_TO_ADDR
// target2 := NearestUnitToUnit ( FilterAllUnits ( [ [ [ f_side , targetSide ] , [ f_or , [ f_occupied ] , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ] ) , i ) ;
11120: LD_ADDR_VAR 0 22
11124: PUSH
11125: LD_INT 22
11127: PUSH
11128: LD_VAR 0 11
11132: PUSH
11133: EMPTY
11134: LIST
11135: LIST
11136: PUSH
11137: LD_INT 2
11139: PUSH
11140: LD_INT 59
11142: PUSH
11143: EMPTY
11144: LIST
11145: PUSH
11146: LD_INT 21
11148: PUSH
11149: LD_INT 1
11151: PUSH
11152: EMPTY
11153: LIST
11154: LIST
11155: PUSH
11156: LD_INT 21
11158: PUSH
11159: LD_INT 2
11161: PUSH
11162: EMPTY
11163: LIST
11164: LIST
11165: PUSH
11166: EMPTY
11167: LIST
11168: LIST
11169: LIST
11170: LIST
11171: PUSH
11172: EMPTY
11173: LIST
11174: LIST
11175: PUSH
11176: EMPTY
11177: LIST
11178: PPUSH
11179: CALL_OW 69
11183: PPUSH
11184: LD_VAR 0 13
11188: PPUSH
11189: CALL_OW 74
11193: ST_TO_ADDR
// if GetDistUnits ( i , target1 ) + 8 < GetDistUnits ( i , target2 ) then
11194: LD_VAR 0 13
11198: PPUSH
11199: LD_VAR 0 21
11203: PPUSH
11204: CALL_OW 296
11208: PUSH
11209: LD_INT 8
11211: PLUS
11212: PUSH
11213: LD_VAR 0 13
11217: PPUSH
11218: LD_VAR 0 22
11222: PPUSH
11223: CALL_OW 296
11227: LESS
11228: IFFALSE 11246
// begin ComAttackUnit ( i , target1 ) ;
11230: LD_VAR 0 13
11234: PPUSH
11235: LD_VAR 0 21
11239: PPUSH
11240: CALL_OW 115
// end else
11244: GO 11260
// begin ComAttackUnit ( i , target2 ) ;
11246: LD_VAR 0 13
11250: PPUSH
11251: LD_VAR 0 22
11255: PPUSH
11256: CALL_OW 115
// end ; end ;
11260: GO 11085
11262: POP
11263: POP
// end ; until FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 250 ] , [ f_not , [ f_empty ] ] ] ) = 0 ;
11264: LD_INT 22
11266: PUSH
11267: LD_VAR 0 2
11271: PUSH
11272: EMPTY
11273: LIST
11274: LIST
11275: PUSH
11276: LD_INT 21
11278: PUSH
11279: LD_INT 2
11281: PUSH
11282: EMPTY
11283: LIST
11284: LIST
11285: PUSH
11286: LD_INT 24
11288: PUSH
11289: LD_INT 250
11291: PUSH
11292: EMPTY
11293: LIST
11294: LIST
11295: PUSH
11296: LD_INT 3
11298: PUSH
11299: LD_INT 58
11301: PUSH
11302: EMPTY
11303: LIST
11304: PUSH
11305: EMPTY
11306: LIST
11307: LIST
11308: PUSH
11309: EMPTY
11310: LIST
11311: LIST
11312: LIST
11313: LIST
11314: PPUSH
11315: CALL_OW 69
11319: PUSH
11320: LD_INT 0
11322: EQUAL
11323: IFFALSE 10956
// end ; end_of_file
11325: LD_VAR 0 12
11329: RET
// every 1 do var i , gammaSquad , startX , startY ;
11330: GO 11332
11332: DISABLE
11333: LD_INT 0
11335: PPUSH
11336: PPUSH
11337: PPUSH
11338: PPUSH
// begin gammaSquad = [ Dickens , Woodruff , Knight , Claptopn , Campell ] ;
11339: LD_ADDR_VAR 0 2
11343: PUSH
11344: LD_EXP 8
11348: PUSH
11349: LD_EXP 9
11353: PUSH
11354: LD_EXP 10
11358: PUSH
11359: LD_EXP 11
11363: PUSH
11364: LD_EXP 12
11368: PUSH
11369: EMPTY
11370: LIST
11371: LIST
11372: LIST
11373: LIST
11374: LIST
11375: ST_TO_ADDR
// startX = [ 46 , 45 , 44 , 43 , 42 ] ;
11376: LD_ADDR_VAR 0 3
11380: PUSH
11381: LD_INT 46
11383: PUSH
11384: LD_INT 45
11386: PUSH
11387: LD_INT 44
11389: PUSH
11390: LD_INT 43
11392: PUSH
11393: LD_INT 42
11395: PUSH
11396: EMPTY
11397: LIST
11398: LIST
11399: LIST
11400: LIST
11401: LIST
11402: ST_TO_ADDR
// startY = [ 14 , 12 , 10 , 8 , 6 ] ;
11403: LD_ADDR_VAR 0 4
11407: PUSH
11408: LD_INT 14
11410: PUSH
11411: LD_INT 12
11413: PUSH
11414: LD_INT 10
11416: PUSH
11417: LD_INT 8
11419: PUSH
11420: LD_INT 6
11422: PUSH
11423: EMPTY
11424: LIST
11425: LIST
11426: LIST
11427: LIST
11428: LIST
11429: ST_TO_ADDR
// ComBuild ( Claptopn , b_breastwork , 59 , 19 , 5 ) ;
11430: LD_EXP 11
11434: PPUSH
11435: LD_INT 31
11437: PPUSH
11438: LD_INT 59
11440: PPUSH
11441: LD_INT 19
11443: PPUSH
11444: LD_INT 5
11446: PPUSH
11447: CALL_OW 145
// CenterNowOnUnits ( amvj ) ;
11451: LD_INT 32
11453: PPUSH
11454: CALL_OW 87
// ComMoveXY ( amvj , 51 , 26 ) ;
11458: LD_INT 32
11460: PPUSH
11461: LD_INT 51
11463: PPUSH
11464: LD_INT 26
11466: PPUSH
11467: CALL_OW 111
// AddComMoveXY ( amvj , 53 , 23 ) ;
11471: LD_INT 32
11473: PPUSH
11474: LD_INT 53
11476: PPUSH
11477: LD_INT 23
11479: PPUSH
11480: CALL_OW 171
// AddComMoveXY ( amvj , 52 , 19 ) ;
11484: LD_INT 32
11486: PPUSH
11487: LD_INT 52
11489: PPUSH
11490: LD_INT 19
11492: PPUSH
11493: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11497: LD_INT 35
11499: PPUSH
11500: CALL_OW 67
// CenterNowOnUnits ( amvj ) ;
11504: LD_INT 32
11506: PPUSH
11507: CALL_OW 87
// until GetX ( amvj ) = 52 and GetY ( amvj ) = 19 ;
11511: LD_INT 32
11513: PPUSH
11514: CALL_OW 250
11518: PUSH
11519: LD_INT 52
11521: EQUAL
11522: PUSH
11523: LD_INT 32
11525: PPUSH
11526: CALL_OW 251
11530: PUSH
11531: LD_INT 19
11533: EQUAL
11534: AND
11535: IFFALSE 11497
// ComExitVehicle ( JMM ) ;
11537: LD_EXP 1
11541: PPUSH
11542: CALL_OW 121
// ComTurnUnit ( Brown , JMM ) ;
11546: LD_EXP 7
11550: PPUSH
11551: LD_EXP 1
11555: PPUSH
11556: CALL_OW 119
// wait ( 0 0$01 ) ;
11560: LD_INT 35
11562: PPUSH
11563: CALL_OW 67
// ComMoveXY ( JMM , 46 , 10 ) ;
11567: LD_EXP 1
11571: PPUSH
11572: LD_INT 46
11574: PPUSH
11575: LD_INT 10
11577: PPUSH
11578: CALL_OW 111
// AddComTurnUnit ( JMM , Brown ) ;
11582: LD_EXP 1
11586: PPUSH
11587: LD_EXP 7
11591: PPUSH
11592: CALL_OW 179
// wait ( 0 0$4 ) ;
11596: LD_INT 140
11598: PPUSH
11599: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
11603: LD_EXP 1
11607: PPUSH
11608: LD_STRING D1-JMM-1
11610: PPUSH
11611: CALL_OW 88
// if not dialogue_skipped then
11615: LD_OWVAR 59
11619: NOT
11620: IFFALSE 12277
// begin for i := 1 to gammaSquad do
11622: LD_ADDR_VAR 0 1
11626: PUSH
11627: DOUBLE
11628: LD_INT 1
11630: DEC
11631: ST_TO_ADDR
11632: LD_VAR 0 2
11636: PUSH
11637: FOR_TO
11638: IFFALSE 11699
// begin ComMoveXY ( gammaSquad [ i ] , startX [ i ] , startY [ i ] ) ;
11640: LD_VAR 0 2
11644: PUSH
11645: LD_VAR 0 1
11649: ARRAY
11650: PPUSH
11651: LD_VAR 0 3
11655: PUSH
11656: LD_VAR 0 1
11660: ARRAY
11661: PPUSH
11662: LD_VAR 0 4
11666: PUSH
11667: LD_VAR 0 1
11671: ARRAY
11672: PPUSH
11673: CALL_OW 111
// AddComTurnUnit ( gammaSquad [ i ] , JMM ) ;
11677: LD_VAR 0 2
11681: PUSH
11682: LD_VAR 0 1
11686: ARRAY
11687: PPUSH
11688: LD_EXP 1
11692: PPUSH
11693: CALL_OW 179
// end ;
11697: GO 11637
11699: POP
11700: POP
// ComMoveXY ( Lisa , 41 , 4 ) ;
11701: LD_EXP 4
11705: PPUSH
11706: LD_INT 41
11708: PPUSH
11709: LD_INT 4
11711: PPUSH
11712: CALL_OW 111
// AddComTurnUnit ( Lisa , JMM ) ;
11716: LD_EXP 4
11720: PPUSH
11721: LD_EXP 1
11725: PPUSH
11726: CALL_OW 179
// if Lisa = false and Bobby then
11730: LD_EXP 4
11734: PUSH
11735: LD_INT 0
11737: EQUAL
11738: PUSH
11739: LD_EXP 2
11743: AND
11744: IFFALSE 11775
// begin ComMoveXY ( Bobby , 41 , 4 ) ;
11746: LD_EXP 2
11750: PPUSH
11751: LD_INT 41
11753: PPUSH
11754: LD_INT 4
11756: PPUSH
11757: CALL_OW 111
// AddComTurnUnit ( Bobby , JMM ) ;
11761: LD_EXP 2
11765: PPUSH
11766: LD_EXP 1
11770: PPUSH
11771: CALL_OW 179
// end ; if Lisa = false and Bobby = false and Cyrus then
11775: LD_EXP 4
11779: PUSH
11780: LD_INT 0
11782: EQUAL
11783: PUSH
11784: LD_EXP 2
11788: PUSH
11789: LD_INT 0
11791: EQUAL
11792: AND
11793: PUSH
11794: LD_EXP 3
11798: AND
11799: IFFALSE 11830
// begin ComMoveXY ( Cyrus , 41 , 4 ) ;
11801: LD_EXP 3
11805: PPUSH
11806: LD_INT 41
11808: PPUSH
11809: LD_INT 4
11811: PPUSH
11812: CALL_OW 111
// AddComTurnUnit ( Cyrus , JMM ) ;
11816: LD_EXP 3
11820: PPUSH
11821: LD_EXP 1
11825: PPUSH
11826: CALL_OW 179
// end ; if Lisa = false and Bobby = false and Cyrus = false then
11830: LD_EXP 4
11834: PUSH
11835: LD_INT 0
11837: EQUAL
11838: PUSH
11839: LD_EXP 2
11843: PUSH
11844: LD_INT 0
11846: EQUAL
11847: AND
11848: PUSH
11849: LD_EXP 3
11853: PUSH
11854: LD_INT 0
11856: EQUAL
11857: AND
11858: IFFALSE 11889
// begin ComMoveXY ( RandomBeforeMission , 41 , 4 ) ;
11860: LD_EXP 6
11864: PPUSH
11865: LD_INT 41
11867: PPUSH
11868: LD_INT 4
11870: PPUSH
11871: CALL_OW 111
// AddComTurnUnit ( RandomBeforeMission , JMM ) ;
11875: LD_EXP 6
11879: PPUSH
11880: LD_EXP 1
11884: PPUSH
11885: CALL_OW 179
// end ; Say ( Brown , D1-Brown-1 ) ;
11889: LD_EXP 7
11893: PPUSH
11894: LD_STRING D1-Brown-1
11896: PPUSH
11897: CALL_OW 88
// Say ( JMM , D1-JMM-2 ) ;
11901: LD_EXP 1
11905: PPUSH
11906: LD_STRING D1-JMM-2
11908: PPUSH
11909: CALL_OW 88
// Say ( Brown , D1-Brown-2 ) ;
11913: LD_EXP 7
11917: PPUSH
11918: LD_STRING D1-Brown-2
11920: PPUSH
11921: CALL_OW 88
// ComTurnUnit ( JMM , Woodruff ) ;
11925: LD_EXP 1
11929: PPUSH
11930: LD_EXP 9
11934: PPUSH
11935: CALL_OW 119
// Say ( Woodruff , D1-FSol1-2 ) ;
11939: LD_EXP 9
11943: PPUSH
11944: LD_STRING D1-FSol1-2
11946: PPUSH
11947: CALL_OW 88
// ComTurnUnit ( JMM , Dickens ) ;
11951: LD_EXP 1
11955: PPUSH
11956: LD_EXP 8
11960: PPUSH
11961: CALL_OW 119
// Say ( Dickens , D1-Sol2-2 ) ;
11965: LD_EXP 8
11969: PPUSH
11970: LD_STRING D1-Sol2-2
11972: PPUSH
11973: CALL_OW 88
// if Lisa then
11977: LD_EXP 4
11981: IFFALSE 12021
// begin ComTurnUnit ( JMM , Lisa ) ;
11983: LD_EXP 1
11987: PPUSH
11988: LD_EXP 4
11992: PPUSH
11993: CALL_OW 119
// Say ( Lisa , D1-Lisa-2 ) ;
11997: LD_EXP 4
12001: PPUSH
12002: LD_STRING D1-Lisa-2
12004: PPUSH
12005: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
12009: LD_EXP 1
12013: PPUSH
12014: LD_STRING D1-JMM-3
12016: PPUSH
12017: CALL_OW 88
// end ; if Bobby then
12021: LD_EXP 2
12025: IFFALSE 12065
// begin ComTurnUnit ( JMM , Bobby ) ;
12027: LD_EXP 1
12031: PPUSH
12032: LD_EXP 2
12036: PPUSH
12037: CALL_OW 119
// Say ( Bobby , D1-Bobby-2 ) ;
12041: LD_EXP 2
12045: PPUSH
12046: LD_STRING D1-Bobby-2
12048: PPUSH
12049: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
12053: LD_EXP 1
12057: PPUSH
12058: LD_STRING D1-JMM-3
12060: PPUSH
12061: CALL_OW 88
// end ; if Cyrus then
12065: LD_EXP 3
12069: IFFALSE 12109
// begin ComTurnUnit ( JMM , Cyrus ) ;
12071: LD_EXP 1
12075: PPUSH
12076: LD_EXP 3
12080: PPUSH
12081: CALL_OW 119
// Say ( Cyrus , D1-Cyrus-2 ) ;
12085: LD_EXP 3
12089: PPUSH
12090: LD_STRING D1-Cyrus-2
12092: PPUSH
12093: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
12097: LD_EXP 1
12101: PPUSH
12102: LD_STRING D1-JMM-3
12104: PPUSH
12105: CALL_OW 88
// end ; ComTurnUnit ( JMM , Brown ) ;
12109: LD_EXP 1
12113: PPUSH
12114: LD_EXP 7
12118: PPUSH
12119: CALL_OW 119
// Say ( JMM , D1-JMM-3a ) ;
12123: LD_EXP 1
12127: PPUSH
12128: LD_STRING D1-JMM-3a
12130: PPUSH
12131: CALL_OW 88
// ComMoveXY ( Brown , 38 , 5 ) ;
12135: LD_EXP 7
12139: PPUSH
12140: LD_INT 38
12142: PPUSH
12143: LD_INT 5
12145: PPUSH
12146: CALL_OW 111
// AddComTurnUnit ( Brown , JMM ) ;
12150: LD_EXP 7
12154: PPUSH
12155: LD_EXP 1
12159: PPUSH
12160: CALL_OW 179
// ComMoveXY ( JMM , 40 , 7 ) ;
12164: LD_EXP 1
12168: PPUSH
12169: LD_INT 40
12171: PPUSH
12172: LD_INT 7
12174: PPUSH
12175: CALL_OW 111
// AddComTurnUnit ( JMM , Brown ) ;
12179: LD_EXP 1
12183: PPUSH
12184: LD_EXP 7
12188: PPUSH
12189: CALL_OW 179
// Say ( Brown , D1-Brown-3 ) ;
12193: LD_EXP 7
12197: PPUSH
12198: LD_STRING D1-Brown-3
12200: PPUSH
12201: CALL_OW 88
// SayRadio ( Harisson , D1-Har-3 ) ;
12205: LD_EXP 14
12209: PPUSH
12210: LD_STRING D1-Har-3
12212: PPUSH
12213: CALL_OW 94
// Say ( JMM , D1-JMM-4 ) ;
12217: LD_EXP 1
12221: PPUSH
12222: LD_STRING D1-JMM-4
12224: PPUSH
12225: CALL_OW 88
// SayRadio ( Harisson , D1-Har-4 ) ;
12229: LD_EXP 14
12233: PPUSH
12234: LD_STRING D1-Har-4
12236: PPUSH
12237: CALL_OW 94
// Say ( JMM , D1-JMM-5 ) ;
12241: LD_EXP 1
12245: PPUSH
12246: LD_STRING D1-JMM-5
12248: PPUSH
12249: CALL_OW 88
// SayRadio ( Harisson , D1-Har-5 ) ;
12253: LD_EXP 14
12257: PPUSH
12258: LD_STRING D1-Har-5
12260: PPUSH
12261: CALL_OW 94
// Say ( JMM , D1-JMM-6 ) ;
12265: LD_EXP 1
12269: PPUSH
12270: LD_STRING D1-JMM-6
12272: PPUSH
12273: CALL_OW 88
// end ; InGameOff ;
12277: CALL_OW 9
// PrepareRussianConvoy ;
12281: CALL 3234 0 0
// ChangeMissionObjectives ( M1 ) ;
12285: LD_STRING M1
12287: PPUSH
12288: CALL_OW 337
// SaveForQuickRestart ;
12292: CALL_OW 22
// timerStatus = 1 ;
12296: LD_ADDR_EXP 29
12300: PUSH
12301: LD_INT 1
12303: ST_TO_ADDR
// startTimer = 1 ;
12304: LD_ADDR_EXP 30
12308: PUSH
12309: LD_INT 1
12311: ST_TO_ADDR
// bonusAvalaible = 1 ;
12312: LD_ADDR_EXP 44
12316: PUSH
12317: LD_INT 1
12319: ST_TO_ADDR
// wait ( 0 0$3 ) ;
12320: LD_INT 105
12322: PPUSH
12323: CALL_OW 67
// DialogueOn ;
12327: CALL_OW 6
// Say ( Campell , D9-Mech1-1 ) ;
12331: LD_EXP 12
12335: PPUSH
12336: LD_STRING D9-Mech1-1
12338: PPUSH
12339: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
12343: LD_EXP 1
12347: PPUSH
12348: LD_STRING D9-JMM-1
12350: PPUSH
12351: CALL_OW 88
// DialogueOff ;
12355: CALL_OW 7
// end ;
12359: PPOPN 4
12361: END
// every 0 0$1 trigger GetTech ( 47 , 1 ) = state_researched and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_btype , b_factory ] ] ) > 0 do
12362: LD_INT 47
12364: PPUSH
12365: LD_INT 1
12367: PPUSH
12368: CALL_OW 321
12372: PUSH
12373: LD_INT 2
12375: EQUAL
12376: PUSH
12377: LD_INT 22
12379: PUSH
12380: LD_INT 1
12382: PUSH
12383: EMPTY
12384: LIST
12385: LIST
12386: PUSH
12387: LD_INT 21
12389: PUSH
12390: LD_INT 3
12392: PUSH
12393: EMPTY
12394: LIST
12395: LIST
12396: PUSH
12397: LD_INT 30
12399: PUSH
12400: LD_INT 3
12402: PUSH
12403: EMPTY
12404: LIST
12405: LIST
12406: PUSH
12407: EMPTY
12408: LIST
12409: LIST
12410: LIST
12411: PPUSH
12412: CALL_OW 69
12416: PUSH
12417: LD_INT 0
12419: GREATER
12420: AND
12421: IFFALSE 12651
12423: GO 12425
12425: DISABLE
// begin if IsOk ( Campell ) then
12426: LD_EXP 12
12430: PPUSH
12431: CALL_OW 302
12435: IFFALSE 12451
// begin Say ( Campell , D10-Mech1-1 ) ;
12437: LD_EXP 12
12441: PPUSH
12442: LD_STRING D10-Mech1-1
12444: PPUSH
12445: CALL_OW 88
// end else
12449: GO 12651
// begin if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , 3 ] , [ f_sex , 1 ] ] ) diff [ JMM ] > 0 then
12451: LD_INT 22
12453: PUSH
12454: LD_INT 1
12456: PUSH
12457: EMPTY
12458: LIST
12459: LIST
12460: PUSH
12461: LD_INT 21
12463: PUSH
12464: LD_INT 1
12466: PUSH
12467: EMPTY
12468: LIST
12469: LIST
12470: PUSH
12471: LD_INT 25
12473: PUSH
12474: LD_INT 3
12476: PUSH
12477: EMPTY
12478: LIST
12479: LIST
12480: PUSH
12481: LD_INT 26
12483: PUSH
12484: LD_INT 1
12486: PUSH
12487: EMPTY
12488: LIST
12489: LIST
12490: PUSH
12491: EMPTY
12492: LIST
12493: LIST
12494: LIST
12495: LIST
12496: PPUSH
12497: CALL_OW 69
12501: PUSH
12502: LD_EXP 1
12506: PUSH
12507: EMPTY
12508: LIST
12509: PUSH
12510: LD_INT 0
12512: GREATER
12513: DIFF
12514: IFFALSE 12588
// begin DialogRandom ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , 3 ] , [ f_sex , 1 ] ] ) diff [ JMM ] , D10-Mech1-1 , D10-Mech1-1 ) ;
12516: LD_INT 22
12518: PUSH
12519: LD_INT 1
12521: PUSH
12522: EMPTY
12523: LIST
12524: LIST
12525: PUSH
12526: LD_INT 21
12528: PUSH
12529: LD_INT 1
12531: PUSH
12532: EMPTY
12533: LIST
12534: LIST
12535: PUSH
12536: LD_INT 25
12538: PUSH
12539: LD_INT 3
12541: PUSH
12542: EMPTY
12543: LIST
12544: LIST
12545: PUSH
12546: LD_INT 26
12548: PUSH
12549: LD_INT 1
12551: PUSH
12552: EMPTY
12553: LIST
12554: LIST
12555: PUSH
12556: EMPTY
12557: LIST
12558: LIST
12559: LIST
12560: LIST
12561: PPUSH
12562: CALL_OW 69
12566: PUSH
12567: LD_EXP 1
12571: PUSH
12572: EMPTY
12573: LIST
12574: DIFF
12575: PPUSH
12576: LD_STRING D10-Mech1-1
12578: PPUSH
12579: LD_STRING D10-Mech1-1
12581: PPUSH
12582: CALL 4492 0 3
// end else
12586: GO 12651
// begin DialogRandom ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_sex , 1 ] ] [ 1 ] ) diff [ JMM ] , D10-Mech1-1 , D10-Mech1-1 ) ;
12588: LD_INT 22
12590: PUSH
12591: LD_INT 1
12593: PUSH
12594: EMPTY
12595: LIST
12596: LIST
12597: PUSH
12598: LD_INT 21
12600: PUSH
12601: LD_INT 1
12603: PUSH
12604: EMPTY
12605: LIST
12606: LIST
12607: PUSH
12608: LD_INT 26
12610: PUSH
12611: LD_INT 1
12613: PUSH
12614: EMPTY
12615: LIST
12616: LIST
12617: PUSH
12618: EMPTY
12619: LIST
12620: LIST
12621: LIST
12622: PUSH
12623: LD_INT 1
12625: ARRAY
12626: PPUSH
12627: CALL_OW 69
12631: PUSH
12632: LD_EXP 1
12636: PUSH
12637: EMPTY
12638: LIST
12639: DIFF
12640: PPUSH
12641: LD_STRING D10-Mech1-1
12643: PPUSH
12644: LD_STRING D10-Mech1-1
12646: PPUSH
12647: CALL 4492 0 3
// end ; end ; end ;
12651: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) > 0 and bunkerDialog = 0 do
12652: LD_INT 22
12654: PUSH
12655: LD_INT 1
12657: PUSH
12658: EMPTY
12659: LIST
12660: LIST
12661: PUSH
12662: LD_INT 30
12664: PUSH
12665: LD_INT 32
12667: PUSH
12668: EMPTY
12669: LIST
12670: LIST
12671: PUSH
12672: EMPTY
12673: LIST
12674: LIST
12675: PPUSH
12676: CALL_OW 69
12680: PUSH
12681: LD_INT 0
12683: GREATER
12684: PUSH
12685: LD_EXP 32
12689: PUSH
12690: LD_INT 0
12692: EQUAL
12693: AND
12694: IFFALSE 12934
12696: GO 12698
12698: DISABLE
// begin if IsOK ( Claptopn ) then
12699: LD_EXP 11
12703: PPUSH
12704: CALL_OW 302
12708: IFFALSE 12724
// begin Say ( Claptopn , D9b-Eng1-1 ) ;
12710: LD_EXP 11
12714: PPUSH
12715: LD_STRING D9b-Eng1-1
12717: PPUSH
12718: CALL_OW 88
// end else
12722: GO 12920
// begin ; if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , 3 ] , [ f_sex , 1 ] ] ) diff [ JMM ] > 0 then
12724: LD_INT 22
12726: PUSH
12727: LD_INT 1
12729: PUSH
12730: EMPTY
12731: LIST
12732: LIST
12733: PUSH
12734: LD_INT 21
12736: PUSH
12737: LD_INT 1
12739: PUSH
12740: EMPTY
12741: LIST
12742: LIST
12743: PUSH
12744: LD_INT 25
12746: PUSH
12747: LD_INT 3
12749: PUSH
12750: EMPTY
12751: LIST
12752: LIST
12753: PUSH
12754: LD_INT 26
12756: PUSH
12757: LD_INT 1
12759: PUSH
12760: EMPTY
12761: LIST
12762: LIST
12763: PUSH
12764: EMPTY
12765: LIST
12766: LIST
12767: LIST
12768: LIST
12769: PPUSH
12770: CALL_OW 69
12774: PUSH
12775: LD_EXP 1
12779: PUSH
12780: EMPTY
12781: LIST
12782: PUSH
12783: LD_INT 0
12785: GREATER
12786: DIFF
12787: IFFALSE 12861
// begin DialogRandom ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , 2 ] , [ f_sex , 1 ] ] ) diff [ JMM ] , D9b-Eng1-1 , D9b-Eng1-11 ) ;
12789: LD_INT 22
12791: PUSH
12792: LD_INT 1
12794: PUSH
12795: EMPTY
12796: LIST
12797: LIST
12798: PUSH
12799: LD_INT 21
12801: PUSH
12802: LD_INT 1
12804: PUSH
12805: EMPTY
12806: LIST
12807: LIST
12808: PUSH
12809: LD_INT 25
12811: PUSH
12812: LD_INT 2
12814: PUSH
12815: EMPTY
12816: LIST
12817: LIST
12818: PUSH
12819: LD_INT 26
12821: PUSH
12822: LD_INT 1
12824: PUSH
12825: EMPTY
12826: LIST
12827: LIST
12828: PUSH
12829: EMPTY
12830: LIST
12831: LIST
12832: LIST
12833: LIST
12834: PPUSH
12835: CALL_OW 69
12839: PUSH
12840: LD_EXP 1
12844: PUSH
12845: EMPTY
12846: LIST
12847: DIFF
12848: PPUSH
12849: LD_STRING D9b-Eng1-1
12851: PPUSH
12852: LD_STRING D9b-Eng1-11
12854: PPUSH
12855: CALL 4492 0 3
// end else
12859: GO 12920
// begin DialogRandom ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_sex , 1 ] ] ) diff [ JMM ] , D9b-Eng1-1 , D9b-Eng1-1 ) ;
12861: LD_INT 22
12863: PUSH
12864: LD_INT 1
12866: PUSH
12867: EMPTY
12868: LIST
12869: LIST
12870: PUSH
12871: LD_INT 21
12873: PUSH
12874: LD_INT 1
12876: PUSH
12877: EMPTY
12878: LIST
12879: LIST
12880: PUSH
12881: LD_INT 26
12883: PUSH
12884: LD_INT 1
12886: PUSH
12887: EMPTY
12888: LIST
12889: LIST
12890: PUSH
12891: EMPTY
12892: LIST
12893: LIST
12894: LIST
12895: PPUSH
12896: CALL_OW 69
12900: PUSH
12901: LD_EXP 1
12905: PUSH
12906: EMPTY
12907: LIST
12908: DIFF
12909: PPUSH
12910: LD_STRING D9b-Eng1-1
12912: PPUSH
12913: LD_STRING D9b-Eng1-1
12915: PPUSH
12916: CALL 4492 0 3
// end ; end ; if energyVDialog = 0 then
12920: LD_EXP 33
12924: PUSH
12925: LD_INT 0
12927: EQUAL
12928: IFFALSE 12934
// EnergyDialog ;
12930: CALL 4895 0 0
// end ;
12934: END
// every 0 0$1 trigger buildOil = 1 and buildPower = 1 do
12935: LD_EXP 34
12939: PUSH
12940: LD_INT 1
12942: EQUAL
12943: PUSH
12944: LD_EXP 35
12948: PUSH
12949: LD_INT 1
12951: EQUAL
12952: AND
12953: IFFALSE 12965
12955: GO 12957
12957: DISABLE
// ChangeMissionObjectives ( M1a ) ;
12958: LD_STRING M1a
12960: PPUSH
12961: CALL_OW 337
12965: END
// every 3 3$0 do
12966: GO 12968
12968: DISABLE
// begin PrepareFirstAttack ;
12969: CALL 4034 0 0
// end ;
12973: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 5 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 250 ] ] ] ) > 0 and firstRussianAttack = 1 do var i ;
12974: LD_INT 22
12976: PUSH
12977: LD_INT 5
12979: PUSH
12980: EMPTY
12981: LIST
12982: LIST
12983: PUSH
12984: LD_INT 21
12986: PUSH
12987: LD_INT 1
12989: PUSH
12990: EMPTY
12991: LIST
12992: LIST
12993: PUSH
12994: LD_INT 3
12996: PUSH
12997: LD_INT 24
12999: PUSH
13000: LD_INT 250
13002: PUSH
13003: EMPTY
13004: LIST
13005: LIST
13006: PUSH
13007: EMPTY
13008: LIST
13009: LIST
13010: PUSH
13011: EMPTY
13012: LIST
13013: LIST
13014: LIST
13015: PPUSH
13016: CALL_OW 69
13020: PUSH
13021: LD_INT 0
13023: GREATER
13024: PUSH
13025: LD_EXP 23
13029: PUSH
13030: LD_INT 1
13032: EQUAL
13033: AND
13034: IFFALSE 13335
13036: GO 13038
13038: DISABLE
13039: LD_INT 0
13041: PPUSH
// begin firstRussianAttack = 2 ;
13042: LD_ADDR_EXP 23
13046: PUSH
13047: LD_INT 2
13049: ST_TO_ADDR
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 5 ] , [ f_type , unit_human ] ] ) , 125 , 98 ) ;
13050: LD_INT 22
13052: PUSH
13053: LD_INT 5
13055: PUSH
13056: EMPTY
13057: LIST
13058: LIST
13059: PUSH
13060: LD_INT 21
13062: PUSH
13063: LD_INT 1
13065: PUSH
13066: EMPTY
13067: LIST
13068: LIST
13069: PUSH
13070: EMPTY
13071: LIST
13072: LIST
13073: PPUSH
13074: CALL_OW 69
13078: PPUSH
13079: LD_INT 125
13081: PPUSH
13082: LD_INT 98
13084: PPUSH
13085: CALL_OW 111
// DialogRandom ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) diff [ JMM , Brown , Lisa ] , DAtt1-Sol1-1 , DAtt1-FSol1-1 ) ;
13089: LD_INT 22
13091: PUSH
13092: LD_INT 1
13094: PUSH
13095: EMPTY
13096: LIST
13097: LIST
13098: PUSH
13099: LD_INT 21
13101: PUSH
13102: LD_INT 1
13104: PUSH
13105: EMPTY
13106: LIST
13107: LIST
13108: PUSH
13109: EMPTY
13110: LIST
13111: LIST
13112: PPUSH
13113: CALL_OW 69
13117: PUSH
13118: LD_EXP 1
13122: PUSH
13123: LD_EXP 7
13127: PUSH
13128: LD_EXP 4
13132: PUSH
13133: EMPTY
13134: LIST
13135: LIST
13136: LIST
13137: DIFF
13138: PPUSH
13139: LD_STRING DAtt1-Sol1-1
13141: PPUSH
13142: LD_STRING DAtt1-FSol1-1
13144: PPUSH
13145: CALL 4492 0 3
// Say ( JMM , DAtt1-JMM-1 ) ;
13149: LD_EXP 1
13153: PPUSH
13154: LD_STRING DAtt1-JMM-1
13156: PPUSH
13157: CALL_OW 88
// if Lisa then
13161: LD_EXP 4
13165: IFFALSE 13181
// begin Say ( Lisa , DAtt1a-Lisa-1 ) ;
13167: LD_EXP 4
13171: PPUSH
13172: LD_STRING DAtt1a-Lisa-1
13174: PPUSH
13175: CALL_OW 88
// end else
13179: GO 13252
// begin DialogRandom ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_sex , 1 ] ] ) diff [ JMM , Brown , Lisa ] , DAtt1a-Sol1-1 , DAtt1-FSol1-1 ) ;
13181: LD_INT 22
13183: PUSH
13184: LD_INT 1
13186: PUSH
13187: EMPTY
13188: LIST
13189: LIST
13190: PUSH
13191: LD_INT 21
13193: PUSH
13194: LD_INT 1
13196: PUSH
13197: EMPTY
13198: LIST
13199: LIST
13200: PUSH
13201: LD_INT 26
13203: PUSH
13204: LD_INT 1
13206: PUSH
13207: EMPTY
13208: LIST
13209: LIST
13210: PUSH
13211: EMPTY
13212: LIST
13213: LIST
13214: LIST
13215: PPUSH
13216: CALL_OW 69
13220: PUSH
13221: LD_EXP 1
13225: PUSH
13226: LD_EXP 7
13230: PUSH
13231: LD_EXP 4
13235: PUSH
13236: EMPTY
13237: LIST
13238: LIST
13239: LIST
13240: DIFF
13241: PPUSH
13242: LD_STRING DAtt1a-Sol1-1
13244: PPUSH
13245: LD_STRING DAtt1-FSol1-1
13247: PPUSH
13248: CALL 4492 0 3
// end ; Say ( JMM , DAtt1a-JMM-1 ) ;
13252: LD_EXP 1
13256: PPUSH
13257: LD_STRING DAtt1a-JMM-1
13259: PPUSH
13260: CALL_OW 88
// DialogRandom ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_sex , 1 ] ] ) diff [ JMM , Brown , Lisa ] , DAtt1b-Sol1-1 , DAtt1a-Sol1-1 ) ;
13264: LD_INT 22
13266: PUSH
13267: LD_INT 1
13269: PUSH
13270: EMPTY
13271: LIST
13272: LIST
13273: PUSH
13274: LD_INT 21
13276: PUSH
13277: LD_INT 1
13279: PUSH
13280: EMPTY
13281: LIST
13282: LIST
13283: PUSH
13284: LD_INT 26
13286: PUSH
13287: LD_INT 1
13289: PUSH
13290: EMPTY
13291: LIST
13292: LIST
13293: PUSH
13294: EMPTY
13295: LIST
13296: LIST
13297: LIST
13298: PPUSH
13299: CALL_OW 69
13303: PUSH
13304: LD_EXP 1
13308: PUSH
13309: LD_EXP 7
13313: PUSH
13314: LD_EXP 4
13318: PUSH
13319: EMPTY
13320: LIST
13321: LIST
13322: LIST
13323: DIFF
13324: PPUSH
13325: LD_STRING DAtt1b-Sol1-1
13327: PPUSH
13328: LD_STRING DAtt1a-Sol1-1
13330: PPUSH
13331: CALL 4492 0 3
// end ;
13335: PPOPN 1
13337: END
// every 0 0$1 trigger firstRussianAttack = 2 do var i ;
13338: LD_EXP 23
13342: PUSH
13343: LD_INT 2
13345: EQUAL
13346: IFFALSE 13408
13348: GO 13350
13350: DISABLE
13351: LD_INT 0
13353: PPUSH
// begin enable ;
13354: ENABLE
// for i in FilterUnitsInArea ( RussianEscape , [ [ f_side , 5 ] , [ f_type , unit_human ] ] ) do
13355: LD_ADDR_VAR 0 1
13359: PUSH
13360: LD_INT 5
13362: PPUSH
13363: LD_INT 22
13365: PUSH
13366: LD_INT 5
13368: PUSH
13369: EMPTY
13370: LIST
13371: LIST
13372: PUSH
13373: LD_INT 21
13375: PUSH
13376: LD_INT 1
13378: PUSH
13379: EMPTY
13380: LIST
13381: LIST
13382: PUSH
13383: EMPTY
13384: LIST
13385: LIST
13386: PPUSH
13387: CALL_OW 70
13391: PUSH
13392: FOR_IN
13393: IFFALSE 13406
// RemoveUnit ( i ) ;
13395: LD_VAR 0 1
13399: PPUSH
13400: CALL_OW 64
13404: GO 13392
13406: POP
13407: POP
// end ;
13408: PPOPN 1
13410: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 5 ] ] ) = 0 and firstRussianAttack = 2 do
13411: LD_INT 22
13413: PUSH
13414: LD_INT 5
13416: PUSH
13417: EMPTY
13418: LIST
13419: LIST
13420: PUSH
13421: EMPTY
13422: LIST
13423: PPUSH
13424: CALL_OW 69
13428: PUSH
13429: LD_INT 0
13431: EQUAL
13432: PUSH
13433: LD_EXP 23
13437: PUSH
13438: LD_INT 2
13440: EQUAL
13441: AND
13442: IFFALSE 13455
13444: GO 13446
13446: DISABLE
// firstRussianAttack = 3 ;
13447: LD_ADDR_EXP 23
13451: PUSH
13452: LD_INT 3
13454: ST_TO_ADDR
13455: END
// every 0 0$01 trigger timeToSupport = 0 0$00 do
13456: LD_EXP 28
13460: PUSH
13461: LD_INT 0
13463: EQUAL
13464: IFFALSE 13545
13466: GO 13468
13468: DISABLE
// begin timerStatus = 4 ;
13469: LD_ADDR_EXP 29
13473: PUSH
13474: LD_INT 4
13476: ST_TO_ADDR
// DialogueOn ;
13477: CALL_OW 6
// SayRadio ( Donaldson , D2-Don-1 ) ;
13481: LD_EXP 13
13485: PPUSH
13486: LD_STRING D2-Don-1
13488: PPUSH
13489: CALL_OW 94
// Say ( JMM , D2-JMM-1 ) ;
13493: LD_EXP 1
13497: PPUSH
13498: LD_STRING D2-JMM-1
13500: PPUSH
13501: CALL_OW 88
// SayRadio ( Donaldson , D2-Don-2 ) ;
13505: LD_EXP 13
13509: PPUSH
13510: LD_STRING D2-Don-2
13512: PPUSH
13513: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
13517: LD_EXP 1
13521: PPUSH
13522: LD_STRING D2-JMM-2
13524: PPUSH
13525: CALL_OW 88
// SayRadio ( Donaldson , D2-Don-3 ) ;
13529: LD_EXP 13
13533: PPUSH
13534: LD_STRING D2-Don-3
13536: PPUSH
13537: CALL_OW 94
// DialogueOff ;
13541: CALL_OW 7
// end ;
13545: END
// every 12 12$0 do var tmp ;
13546: GO 13548
13548: DISABLE
13549: LD_INT 0
13551: PPUSH
// begin PrepareDonaldsonArmy ;
13552: CALL 1151 0 0
// CenterNowOnUnits ( Donaldson ) ;
13556: LD_EXP 13
13560: PPUSH
13561: CALL_OW 87
// if not FilterAllUnits ( [ f_side , 6 ] ) then
13565: LD_INT 22
13567: PUSH
13568: LD_INT 6
13570: PUSH
13571: EMPTY
13572: LIST
13573: LIST
13574: PPUSH
13575: CALL_OW 69
13579: NOT
13580: IFFALSE 13596
// begin wait ( 3 ) ;
13582: LD_INT 3
13584: PPUSH
13585: CALL_OW 67
// SetAchievement ( ACH_BASE ) ;
13589: LD_STRING ACH_BASE
13591: PPUSH
13592: CALL_OW 543
// end ; tmp = FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_sex , 1 ] , [ f_class , 1 ] ] ) diff [ Frank ] ;
13596: LD_ADDR_VAR 0 1
13600: PUSH
13601: LD_INT 22
13603: PUSH
13604: LD_INT 4
13606: PUSH
13607: EMPTY
13608: LIST
13609: LIST
13610: PUSH
13611: LD_INT 21
13613: PUSH
13614: LD_INT 1
13616: PUSH
13617: EMPTY
13618: LIST
13619: LIST
13620: PUSH
13621: LD_INT 26
13623: PUSH
13624: LD_INT 1
13626: PUSH
13627: EMPTY
13628: LIST
13629: LIST
13630: PUSH
13631: LD_INT 25
13633: PUSH
13634: LD_INT 1
13636: PUSH
13637: EMPTY
13638: LIST
13639: LIST
13640: PUSH
13641: EMPTY
13642: LIST
13643: LIST
13644: LIST
13645: LIST
13646: PPUSH
13647: CALL_OW 69
13651: PUSH
13652: LD_EXP 5
13656: PUSH
13657: EMPTY
13658: LIST
13659: DIFF
13660: ST_TO_ADDR
// DialogueOn ;
13661: CALL_OW 6
// DialogRandom ( tmp , D3-Sol1-1 , D3-Sol1-1 ) ;
13665: LD_VAR 0 1
13669: PPUSH
13670: LD_STRING D3-Sol1-1
13672: PPUSH
13673: LD_STRING D3-Sol1-1
13675: PPUSH
13676: CALL 4492 0 3
// DialogRandom ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_sex , 1 ] , [ f_class , 3 ] ] ) , D3-Sol2-1 , D3-Sol2-1 ) ;
13680: LD_INT 22
13682: PUSH
13683: LD_INT 4
13685: PUSH
13686: EMPTY
13687: LIST
13688: LIST
13689: PUSH
13690: LD_INT 21
13692: PUSH
13693: LD_INT 1
13695: PUSH
13696: EMPTY
13697: LIST
13698: LIST
13699: PUSH
13700: LD_INT 26
13702: PUSH
13703: LD_INT 1
13705: PUSH
13706: EMPTY
13707: LIST
13708: LIST
13709: PUSH
13710: LD_INT 25
13712: PUSH
13713: LD_INT 3
13715: PUSH
13716: EMPTY
13717: LIST
13718: LIST
13719: PUSH
13720: EMPTY
13721: LIST
13722: LIST
13723: LIST
13724: LIST
13725: PPUSH
13726: CALL_OW 69
13730: PPUSH
13731: LD_STRING D3-Sol2-1
13733: PPUSH
13734: LD_STRING D3-Sol2-1
13736: PPUSH
13737: CALL 4492 0 3
// if Frank then
13741: LD_EXP 5
13745: IFFALSE 13759
// Say ( Frank , D3-Frank-1 ) ;
13747: LD_EXP 5
13751: PPUSH
13752: LD_STRING D3-Frank-1
13754: PPUSH
13755: CALL_OW 88
// Say ( Donaldson , D3-Don-1 ) ;
13759: LD_EXP 13
13763: PPUSH
13764: LD_STRING D3-Don-1
13766: PPUSH
13767: CALL_OW 88
// SayRadio ( Donaldson , D3-Don-1a ) ;
13771: LD_EXP 13
13775: PPUSH
13776: LD_STRING D3-Don-1a
13778: PPUSH
13779: CALL_OW 94
// Say ( JMM , D3-JMM-1 ) ;
13783: LD_EXP 1
13787: PPUSH
13788: LD_STRING D3-JMM-1
13790: PPUSH
13791: CALL_OW 88
// SayRadio ( Donaldson , D3-Don-2 ) ;
13795: LD_EXP 13
13799: PPUSH
13800: LD_STRING D3-Don-2
13802: PPUSH
13803: CALL_OW 94
// if FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] ] ) > 0 then
13807: LD_INT 22
13809: PUSH
13810: LD_INT 6
13812: PUSH
13813: EMPTY
13814: LIST
13815: LIST
13816: PUSH
13817: LD_INT 21
13819: PUSH
13820: LD_INT 1
13822: PUSH
13823: EMPTY
13824: LIST
13825: LIST
13826: PUSH
13827: EMPTY
13828: LIST
13829: LIST
13830: PPUSH
13831: CALL_OW 69
13835: PUSH
13836: LD_INT 0
13838: GREATER
13839: IFFALSE 13977
// begin Say ( JMM , D3-JMM-2 ) ;
13841: LD_EXP 1
13845: PPUSH
13846: LD_STRING D3-JMM-2
13848: PPUSH
13849: CALL_OW 88
// SayRadio ( Donaldson , D3-Don-3 ) ;
13853: LD_EXP 13
13857: PPUSH
13858: LD_STRING D3-Don-3
13860: PPUSH
13861: CALL_OW 94
// Say ( JMM , D3-JMM-3 ) ;
13865: LD_EXP 1
13869: PPUSH
13870: LD_STRING D3-JMM-3
13872: PPUSH
13873: CALL_OW 88
// if IsOK ( Frank ) then
13877: LD_EXP 5
13881: PPUSH
13882: CALL_OW 302
13886: IFFALSE 13900
// Say ( Frank , D3-Frank-3 ) ;
13888: LD_EXP 5
13892: PPUSH
13893: LD_STRING D3-Frank-3
13895: PPUSH
13896: CALL_OW 88
// DialogueOff ;
13900: CALL_OW 7
// if IsOK ( Frank ) then
13904: LD_EXP 5
13908: PPUSH
13909: CALL_OW 302
13913: IFFALSE 13975
// begin SetSide ( Frank , 0 ) ;
13915: LD_EXP 5
13919: PPUSH
13920: LD_INT 0
13922: PPUSH
13923: CALL_OW 235
// ComMoveToArea ( Frank , FrankSpot ) ;
13927: LD_EXP 5
13931: PPUSH
13932: LD_INT 12
13934: PPUSH
13935: CALL_OW 113
// SaveCharacters ( Frank , 04t_Frank ) ;
13939: LD_EXP 5
13943: PPUSH
13944: LD_STRING 04t_Frank
13946: PPUSH
13947: CALL_OW 38
// Wait ( 0 0$3 ) ;
13951: LD_INT 105
13953: PPUSH
13954: CALL_OW 67
// frankScoutBase = 1 ;
13958: LD_ADDR_EXP 25
13962: PUSH
13963: LD_INT 1
13965: ST_TO_ADDR
// RemoveUnit ( Frank ) ;
13966: LD_EXP 5
13970: PPUSH
13971: CALL_OW 64
// end ; end else
13975: GO 14064
// begin Say ( JMM , D3-JMM-4 ) ;
13977: LD_EXP 1
13981: PPUSH
13982: LD_STRING D3-JMM-4
13984: PPUSH
13985: CALL_OW 88
// DialogueOff ;
13989: CALL_OW 7
// if IsOK ( Frank ) then
13993: LD_EXP 5
13997: PPUSH
13998: CALL_OW 302
14002: IFFALSE 14064
// begin SetSide ( Frank , 0 ) ;
14004: LD_EXP 5
14008: PPUSH
14009: LD_INT 0
14011: PPUSH
14012: CALL_OW 235
// ComMoveToArea ( Frank , FrankSpot ) ;
14016: LD_EXP 5
14020: PPUSH
14021: LD_INT 12
14023: PPUSH
14024: CALL_OW 113
// SaveCharacters ( Frank , 04t_Frank ) ;
14028: LD_EXP 5
14032: PPUSH
14033: LD_STRING 04t_Frank
14035: PPUSH
14036: CALL_OW 38
// Wait ( 0 0$3 ) ;
14040: LD_INT 105
14042: PPUSH
14043: CALL_OW 67
// frankScoutBase = 1 ;
14047: LD_ADDR_EXP 25
14051: PUSH
14052: LD_INT 1
14054: ST_TO_ADDR
// RemoveUnit ( Frank ) ;
14055: LD_EXP 5
14059: PPUSH
14060: CALL_OW 64
// end ; end ; end ;
14064: PPOPN 1
14066: END
// every 7 7$0 trigger GetSide ( Donaldson ) = 4 and IsOK ( Donaldson ) do
14067: LD_EXP 13
14071: PPUSH
14072: CALL_OW 255
14076: PUSH
14077: LD_INT 4
14079: EQUAL
14080: PUSH
14081: LD_EXP 13
14085: PPUSH
14086: CALL_OW 302
14090: AND
14091: IFFALSE 14116
14093: GO 14095
14095: DISABLE
// begin SayRadio ( Donaldson , D3b-Don-1 ) ;
14096: LD_EXP 13
14100: PPUSH
14101: LD_STRING D3b-Don-1
14103: PPUSH
14104: CALL_OW 94
// donaldsonCoopAttack = 1 ;
14108: LD_ADDR_EXP 41
14112: PUSH
14113: LD_INT 1
14115: ST_TO_ADDR
// end ;
14116: END
// every 0 0$1 trigger saveDonaldson = 0 do var i , j ;
14117: LD_EXP 24
14121: PUSH
14122: LD_INT 0
14124: EQUAL
14125: IFFALSE 14281
14127: GO 14129
14129: DISABLE
14130: LD_INT 0
14132: PPUSH
14133: PPUSH
// begin enable ;
14134: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) do
14135: LD_ADDR_VAR 0 1
14139: PUSH
14140: LD_INT 22
14142: PUSH
14143: LD_INT 4
14145: PUSH
14146: EMPTY
14147: LIST
14148: LIST
14149: PUSH
14150: LD_INT 21
14152: PUSH
14153: LD_INT 1
14155: PUSH
14156: EMPTY
14157: LIST
14158: LIST
14159: PUSH
14160: EMPTY
14161: LIST
14162: LIST
14163: PPUSH
14164: CALL_OW 69
14168: PUSH
14169: FOR_IN
14170: IFFALSE 14279
// begin for j in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) do
14172: LD_ADDR_VAR 0 2
14176: PUSH
14177: LD_INT 22
14179: PUSH
14180: LD_INT 1
14182: PUSH
14183: EMPTY
14184: LIST
14185: LIST
14186: PUSH
14187: LD_INT 21
14189: PUSH
14190: LD_INT 1
14192: PUSH
14193: EMPTY
14194: LIST
14195: LIST
14196: PUSH
14197: EMPTY
14198: LIST
14199: LIST
14200: PPUSH
14201: CALL_OW 69
14205: PUSH
14206: FOR_IN
14207: IFFALSE 14275
// begin if GetDistUnits ( i , j ) < 7 then
14209: LD_VAR 0 1
14213: PPUSH
14214: LD_VAR 0 2
14218: PPUSH
14219: CALL_OW 296
14223: PUSH
14224: LD_INT 7
14226: LESS
14227: IFFALSE 14273
// begin saveDonaldson = 1 ;
14229: LD_ADDR_EXP 24
14233: PUSH
14234: LD_INT 1
14236: ST_TO_ADDR
// SetSide ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) , 1 ) ;
14237: LD_INT 22
14239: PUSH
14240: LD_INT 4
14242: PUSH
14243: EMPTY
14244: LIST
14245: LIST
14246: PUSH
14247: LD_INT 21
14249: PUSH
14250: LD_INT 1
14252: PUSH
14253: EMPTY
14254: LIST
14255: LIST
14256: PUSH
14257: EMPTY
14258: LIST
14259: LIST
14260: PPUSH
14261: CALL_OW 69
14265: PPUSH
14266: LD_INT 1
14268: PPUSH
14269: CALL_OW 235
// end ; end ;
14273: GO 14206
14275: POP
14276: POP
// end ;
14277: GO 14169
14279: POP
14280: POP
// end ;
14281: PPOPN 2
14283: END
// every 0 0$1 trigger frankScoutBase do
14284: LD_EXP 25
14288: IFFALSE 14653
14290: GO 14292
14292: DISABLE
// begin wait ( 2 2$30 ) ;
14293: LD_INT 5250
14295: PPUSH
14296: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
14300: LD_INT 35
14302: PPUSH
14303: CALL_OW 67
// until not FilterAllUnits ( [ [ f_enemy , 4 ] , [ f_distxy , 84 , 28 , 22 ] ] ) ;
14307: LD_INT 81
14309: PUSH
14310: LD_INT 4
14312: PUSH
14313: EMPTY
14314: LIST
14315: LIST
14316: PUSH
14317: LD_INT 92
14319: PUSH
14320: LD_INT 84
14322: PUSH
14323: LD_INT 28
14325: PUSH
14326: LD_INT 22
14328: PUSH
14329: EMPTY
14330: LIST
14331: LIST
14332: LIST
14333: LIST
14334: PUSH
14335: EMPTY
14336: LIST
14337: LIST
14338: PPUSH
14339: CALL_OW 69
14343: NOT
14344: IFFALSE 14300
// uc_side = 4 ;
14346: LD_ADDR_OWVAR 20
14350: PUSH
14351: LD_INT 4
14353: ST_TO_ADDR
// uc_nation = 1 ;
14354: LD_ADDR_OWVAR 21
14358: PUSH
14359: LD_INT 1
14361: ST_TO_ADDR
// Frank = CreateCharacter ( 04t_Frank ) ;
14362: LD_ADDR_EXP 5
14366: PUSH
14367: LD_STRING 04t_Frank
14369: PPUSH
14370: CALL_OW 34
14374: ST_TO_ADDR
// if not Frank then
14375: LD_EXP 5
14379: NOT
14380: IFFALSE 14384
// exit ;
14382: GO 14653
// PlaceUnitArea ( Frank , FrankSpawn , false ) ;
14384: LD_EXP 5
14388: PPUSH
14389: LD_INT 13
14391: PPUSH
14392: LD_INT 0
14394: PPUSH
14395: CALL_OW 49
// repeat wait ( 0 0$1 ) ;
14399: LD_INT 35
14401: PPUSH
14402: CALL_OW 67
// if not IsInUnit ( JMM ) and GetDistUnits ( JMM , ambdept0 ) < 20 then
14406: LD_EXP 1
14410: PPUSH
14411: CALL_OW 310
14415: NOT
14416: PUSH
14417: LD_EXP 1
14421: PPUSH
14422: LD_INT 4
14424: PPUSH
14425: CALL_OW 296
14429: PUSH
14430: LD_INT 20
14432: LESS
14433: AND
14434: IFFALSE 14467
// ComMoveXY ( Frank , GetX ( JMM ) , GetY ( JMM ) ) else
14436: LD_EXP 5
14440: PPUSH
14441: LD_EXP 1
14445: PPUSH
14446: CALL_OW 250
14450: PPUSH
14451: LD_EXP 1
14455: PPUSH
14456: CALL_OW 251
14460: PPUSH
14461: CALL_OW 111
14465: GO 14482
// ComMoveXY ( Frank , 51 , 15 ) ;
14467: LD_EXP 5
14471: PPUSH
14472: LD_INT 51
14474: PPUSH
14475: LD_INT 15
14477: PPUSH
14478: CALL_OW 111
// until GetDistUnits ( Frank , JMM ) < 10 ;
14482: LD_EXP 5
14486: PPUSH
14487: LD_EXP 1
14491: PPUSH
14492: CALL_OW 296
14496: PUSH
14497: LD_INT 10
14499: LESS
14500: IFFALSE 14399
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
14502: LD_EXP 1
14506: PUSH
14507: LD_EXP 5
14511: PUSH
14512: EMPTY
14513: LIST
14514: LIST
14515: PPUSH
14516: CALL_OW 87
// DialogueOn ;
14520: CALL_OW 6
// Say ( Frank , D3a-Frank-1 ) ;
14524: LD_EXP 5
14528: PPUSH
14529: LD_STRING D3a-Frank-1
14531: PPUSH
14532: CALL_OW 88
// if Lisa then
14536: LD_EXP 4
14540: IFFALSE 14590
// begin Say ( Lisa , D3a-Lisa-1 ) ;
14542: LD_EXP 4
14546: PPUSH
14547: LD_STRING D3a-Lisa-1
14549: PPUSH
14550: CALL_OW 88
// Say ( Frank , D3a-Frank-2 ) ;
14554: LD_EXP 5
14558: PPUSH
14559: LD_STRING D3a-Frank-2
14561: PPUSH
14562: CALL_OW 88
// Say ( Lisa , D3a-Lisa-2 ) ;
14566: LD_EXP 4
14570: PPUSH
14571: LD_STRING D3a-Lisa-2
14573: PPUSH
14574: CALL_OW 88
// Say ( Frank , D3a-Frank-3 ) ;
14578: LD_EXP 5
14582: PPUSH
14583: LD_STRING D3a-Frank-3
14585: PPUSH
14586: CALL_OW 88
// end ; Say ( JMM , D3a-JMM-3 ) ;
14590: LD_EXP 1
14594: PPUSH
14595: LD_STRING D3a-JMM-3
14597: PPUSH
14598: CALL_OW 88
// DialogueOff ;
14602: CALL_OW 7
// SetSide ( Frank , 1 ) ;
14606: LD_EXP 5
14610: PPUSH
14611: LD_INT 1
14613: PPUSH
14614: CALL_OW 235
// InGameOn ;
14618: CALL_OW 8
// RevealFogArea ( 1 , RussianBase ) ;
14622: LD_INT 1
14624: PPUSH
14625: LD_INT 7
14627: PPUSH
14628: CALL_OW 332
// CenterOnXY ( 93 , 91 ) ;
14632: LD_INT 93
14634: PPUSH
14635: LD_INT 91
14637: PPUSH
14638: CALL_OW 84
// wait ( 0 0$5 ) ;
14642: LD_INT 175
14644: PPUSH
14645: CALL_OW 67
// InGameOff ;
14649: CALL_OW 9
// end ;
14653: END
// every 12 12$0 trigger Difficulty = 2 or Difficulty = 3 do
14654: LD_OWVAR 67
14658: PUSH
14659: LD_INT 2
14661: EQUAL
14662: PUSH
14663: LD_OWVAR 67
14667: PUSH
14668: LD_INT 3
14670: EQUAL
14671: OR
14672: IFFALSE 14696
14674: GO 14676
14676: DISABLE
// AddComConstruct ( rubfact0 , 24 , 1 , 1 , 53 ) ;
14677: LD_INT 24
14679: PPUSH
14680: LD_INT 24
14682: PPUSH
14683: LD_INT 1
14685: PPUSH
14686: LD_INT 1
14688: PPUSH
14689: LD_INT 53
14691: PPUSH
14692: CALL_OW 185
14696: END
// every 18 18$0 do
14697: GO 14699
14699: DISABLE
// begin SayRadio ( Harisson , D4-Har-1 ) ;
14700: LD_EXP 14
14704: PPUSH
14705: LD_STRING D4-Har-1
14707: PPUSH
14708: CALL_OW 94
// Say ( JMM , D4-JMM-1 ) ;
14712: LD_EXP 1
14716: PPUSH
14717: LD_STRING D4-JMM-1
14719: PPUSH
14720: CALL_OW 88
// SayRadio ( Harisson , D4-Har-2 ) ;
14724: LD_EXP 14
14728: PPUSH
14729: LD_STRING D4-Har-2
14731: PPUSH
14732: CALL_OW 94
// case query ( Q1 ) of 1 :
14736: LD_STRING Q1
14738: PPUSH
14739: CALL_OW 97
14743: PUSH
14744: LD_INT 1
14746: DOUBLE
14747: EQUAL
14748: IFTRUE 14752
14750: GO 14811
14752: POP
// begin Say ( JMM , D5-JMM-1 ) ;
14753: LD_EXP 1
14757: PPUSH
14758: LD_STRING D5-JMM-1
14760: PPUSH
14761: CALL_OW 88
// SayRadio ( Harisson , D5-Har-1 ) ;
14765: LD_EXP 14
14769: PPUSH
14770: LD_STRING D5-Har-1
14772: PPUSH
14773: CALL_OW 94
// timeToSupport = 10 10$0 ;
14777: LD_ADDR_EXP 28
14781: PUSH
14782: LD_INT 21000
14784: ST_TO_ADDR
// timerStatus = 2 ;
14785: LD_ADDR_EXP 29
14789: PUSH
14790: LD_INT 2
14792: ST_TO_ADDR
// startTimer = 1 ;
14793: LD_ADDR_EXP 30
14797: PUSH
14798: LD_INT 1
14800: ST_TO_ADDR
// harrAnswer = 1 ;
14801: LD_ADDR_EXP 26
14805: PUSH
14806: LD_INT 1
14808: ST_TO_ADDR
// end ; 2 :
14809: GO 14946
14811: LD_INT 2
14813: DOUBLE
14814: EQUAL
14815: IFTRUE 14819
14817: GO 14878
14819: POP
// begin Say ( JMM , D5-JMM-2 ) ;
14820: LD_EXP 1
14824: PPUSH
14825: LD_STRING D5-JMM-2
14827: PPUSH
14828: CALL_OW 88
// SayRadio ( Harisson , D5-Har-2 ) ;
14832: LD_EXP 14
14836: PPUSH
14837: LD_STRING D5-Har-2
14839: PPUSH
14840: CALL_OW 94
// timeToSupport = 5 5$0 ;
14844: LD_ADDR_EXP 28
14848: PUSH
14849: LD_INT 10500
14851: ST_TO_ADDR
// timerStatus = 2 ;
14852: LD_ADDR_EXP 29
14856: PUSH
14857: LD_INT 2
14859: ST_TO_ADDR
// startTimer = 1 ;
14860: LD_ADDR_EXP 30
14864: PUSH
14865: LD_INT 1
14867: ST_TO_ADDR
// harrAnswer = 2 ;
14868: LD_ADDR_EXP 26
14872: PUSH
14873: LD_INT 2
14875: ST_TO_ADDR
// end ; 3 :
14876: GO 14946
14878: LD_INT 3
14880: DOUBLE
14881: EQUAL
14882: IFTRUE 14886
14884: GO 14945
14886: POP
// begin Say ( JMM , D5-JMM-3 ) ;
14887: LD_EXP 1
14891: PPUSH
14892: LD_STRING D5-JMM-3
14894: PPUSH
14895: CALL_OW 88
// SayRadio ( Harisson , D5-Har-3 ) ;
14899: LD_EXP 14
14903: PPUSH
14904: LD_STRING D5-Har-3
14906: PPUSH
14907: CALL_OW 94
// timeToSupport = 5 5$0 ;
14911: LD_ADDR_EXP 28
14915: PUSH
14916: LD_INT 10500
14918: ST_TO_ADDR
// timerStatus = 2 ;
14919: LD_ADDR_EXP 29
14923: PUSH
14924: LD_INT 2
14926: ST_TO_ADDR
// startTimer = 1 ;
14927: LD_ADDR_EXP 30
14931: PUSH
14932: LD_INT 1
14934: ST_TO_ADDR
// harrAnswer = 3 ;
14935: LD_ADDR_EXP 26
14939: PUSH
14940: LD_INT 3
14942: ST_TO_ADDR
// end ; end ;
14943: GO 14946
14945: POP
// end ;
14946: END
// every 0 0$01 trigger timerStatus = 2 and timeToSupport = 0 0$00 do
14947: LD_EXP 29
14951: PUSH
14952: LD_INT 2
14954: EQUAL
14955: PUSH
14956: LD_EXP 28
14960: PUSH
14961: LD_INT 0
14963: EQUAL
14964: AND
14965: IFFALSE 15242
14967: GO 14969
14969: DISABLE
// begin timerStatus = 4 ;
14970: LD_ADDR_EXP 29
14974: PUSH
14975: LD_INT 4
14977: ST_TO_ADDR
// if harrAnswer = 1 then
14978: LD_EXP 26
14982: PUSH
14983: LD_INT 1
14985: EQUAL
14986: IFFALSE 15066
// begin PrepareHarrisonSupport ( 3 ) ;
14988: LD_INT 3
14990: PPUSH
14991: CALL 1721 0 1
// wait ( 1 1$0 ) ;
14995: LD_INT 2100
14997: PPUSH
14998: CALL_OW 67
// SayRadio ( Harisson , D7-Har-1 ) ;
15002: LD_EXP 14
15006: PPUSH
15007: LD_STRING D7-Har-1
15009: PPUSH
15010: CALL_OW 94
// ChangeMissionObjectives ( M2 ) ;
15014: LD_STRING M2
15016: PPUSH
15017: CALL_OW 337
// timeToDestroyRuBase = 15 15$0 + [ 5 5$0 , 4 4$0 , 3 3$0 ] [ Difficulty ] ;
15021: LD_ADDR_EXP 27
15025: PUSH
15026: LD_INT 31500
15028: PUSH
15029: LD_INT 10500
15031: PUSH
15032: LD_INT 8400
15034: PUSH
15035: LD_INT 6300
15037: PUSH
15038: EMPTY
15039: LIST
15040: LIST
15041: LIST
15042: PUSH
15043: LD_OWVAR 67
15047: ARRAY
15048: PLUS
15049: ST_TO_ADDR
// startTimer = 1 ;
15050: LD_ADDR_EXP 30
15054: PUSH
15055: LD_INT 1
15057: ST_TO_ADDR
// timerStatus = 3 ;
15058: LD_ADDR_EXP 29
15062: PUSH
15063: LD_INT 3
15065: ST_TO_ADDR
// end ; if harrAnswer = 2 then
15066: LD_EXP 26
15070: PUSH
15071: LD_INT 2
15073: EQUAL
15074: IFFALSE 15154
// begin PrepareHarrisonSupport ( 4 ) ;
15076: LD_INT 4
15078: PPUSH
15079: CALL 1721 0 1
// wait ( 1 1$0 ) ;
15083: LD_INT 2100
15085: PPUSH
15086: CALL_OW 67
// SayRadio ( Harisson , D7-Har-1 ) ;
15090: LD_EXP 14
15094: PPUSH
15095: LD_STRING D7-Har-1
15097: PPUSH
15098: CALL_OW 94
// ChangeMissionObjectives ( M2 ) ;
15102: LD_STRING M2
15104: PPUSH
15105: CALL_OW 337
// timeToDestroyRuBase = 13 13$0 + [ 5 5$0 , 4 4$0 , 3 3$0 ] [ Difficulty ] ;
15109: LD_ADDR_EXP 27
15113: PUSH
15114: LD_INT 27300
15116: PUSH
15117: LD_INT 10500
15119: PUSH
15120: LD_INT 8400
15122: PUSH
15123: LD_INT 6300
15125: PUSH
15126: EMPTY
15127: LIST
15128: LIST
15129: LIST
15130: PUSH
15131: LD_OWVAR 67
15135: ARRAY
15136: PLUS
15137: ST_TO_ADDR
// startTimer = 1 ;
15138: LD_ADDR_EXP 30
15142: PUSH
15143: LD_INT 1
15145: ST_TO_ADDR
// timerStatus = 3 ;
15146: LD_ADDR_EXP 29
15150: PUSH
15151: LD_INT 3
15153: ST_TO_ADDR
// end ; if harrAnswer = 3 then
15154: LD_EXP 26
15158: PUSH
15159: LD_INT 3
15161: EQUAL
15162: IFFALSE 15242
// begin PrepareHarrisonSupport ( 5 ) ;
15164: LD_INT 5
15166: PPUSH
15167: CALL 1721 0 1
// wait ( 1 1$0 ) ;
15171: LD_INT 2100
15173: PPUSH
15174: CALL_OW 67
// SayRadio ( Harisson , D7-Har-1 ) ;
15178: LD_EXP 14
15182: PPUSH
15183: LD_STRING D7-Har-1
15185: PPUSH
15186: CALL_OW 94
// ChangeMissionObjectives ( M2 ) ;
15190: LD_STRING M2
15192: PPUSH
15193: CALL_OW 337
// timeToDestroyRuBase = 11 11$0 + [ 5 5$0 , 3 3$0 , 2 2$0 ] [ Difficulty ] ;
15197: LD_ADDR_EXP 27
15201: PUSH
15202: LD_INT 23100
15204: PUSH
15205: LD_INT 10500
15207: PUSH
15208: LD_INT 6300
15210: PUSH
15211: LD_INT 4200
15213: PUSH
15214: EMPTY
15215: LIST
15216: LIST
15217: LIST
15218: PUSH
15219: LD_OWVAR 67
15223: ARRAY
15224: PLUS
15225: ST_TO_ADDR
// startTimer = 1 ;
15226: LD_ADDR_EXP 30
15230: PUSH
15231: LD_INT 1
15233: ST_TO_ADDR
// timerStatus = 3 ;
15234: LD_ADDR_EXP 29
15238: PUSH
15239: LD_INT 3
15241: ST_TO_ADDR
// end ; end ;
15242: END
// every 0 0$1 trigger timeToDestroyRuBase <= 4 4$00 and timerStatus = 3 do
15243: LD_EXP 27
15247: PUSH
15248: LD_INT 8400
15250: LESSEQUAL
15251: PUSH
15252: LD_EXP 29
15256: PUSH
15257: LD_INT 3
15259: EQUAL
15260: AND
15261: IFFALSE 15293
15263: GO 15265
15265: DISABLE
// begin DialogueOn ;
15266: CALL_OW 6
// SayRadio ( Harisson , D7a-Har-1 ) ;
15270: LD_EXP 14
15274: PPUSH
15275: LD_STRING D7a-Har-1
15277: PPUSH
15278: CALL_OW 94
// DialogueOff ;
15282: CALL_OW 7
// ChangeMissionObjectives ( M2a ) ;
15286: LD_STRING M2a
15288: PPUSH
15289: CALL_OW 337
// end ;
15293: END
// every 0 0$1 trigger timeToDestroyRuBase <= 0 0$00 and timerStatus = 3 and not escapeAvalaible do var tmp ;
15294: LD_EXP 27
15298: PUSH
15299: LD_INT 0
15301: LESSEQUAL
15302: PUSH
15303: LD_EXP 29
15307: PUSH
15308: LD_INT 3
15310: EQUAL
15311: AND
15312: PUSH
15313: LD_EXP 40
15317: NOT
15318: AND
15319: IFFALSE 15458
15321: GO 15323
15323: DISABLE
15324: LD_INT 0
15326: PPUSH
// begin tmp = FilterAllUnits ( [ f_side , 1 ] ) diff [ JMM ] ;
15327: LD_ADDR_VAR 0 1
15331: PUSH
15332: LD_INT 22
15334: PUSH
15335: LD_INT 1
15337: PUSH
15338: EMPTY
15339: LIST
15340: LIST
15341: PPUSH
15342: CALL_OW 69
15346: PUSH
15347: LD_EXP 1
15351: PUSH
15352: EMPTY
15353: LIST
15354: DIFF
15355: ST_TO_ADDR
// saveDonaldson = 2 ;
15356: LD_ADDR_EXP 24
15360: PUSH
15361: LD_INT 2
15363: ST_TO_ADDR
// DialogueOn ;
15364: CALL_OW 6
// if IsOK ( Donaldson ) then
15368: LD_EXP 13
15372: PPUSH
15373: CALL_OW 302
15377: IFFALSE 15393
// begin SayRadio ( Harisson , D8-Har-1 ) ;
15379: LD_EXP 14
15383: PPUSH
15384: LD_STRING D8-Har-1
15386: PPUSH
15387: CALL_OW 94
// end else
15391: GO 15405
// begin SayRadio ( Harisson , D8-Har-1a ) ;
15393: LD_EXP 14
15397: PPUSH
15398: LD_STRING D8-Har-1a
15400: PPUSH
15401: CALL_OW 94
// end ; DialogueOff ;
15405: CALL_OW 7
// SetSide ( tmp , 4 ) ;
15409: LD_VAR 0 1
15413: PPUSH
15414: LD_INT 4
15416: PPUSH
15417: CALL_OW 235
// ComAgressiveMove ( tmp , 88 , 89 ) ;
15421: LD_VAR 0 1
15425: PPUSH
15426: LD_INT 88
15428: PPUSH
15429: LD_INT 89
15431: PPUSH
15432: CALL_OW 114
// honor = 0 ;
15436: LD_ADDR_EXP 39
15440: PUSH
15441: LD_INT 0
15443: ST_TO_ADDR
// wait ( 0 0$10 ) ;
15444: LD_INT 350
15446: PPUSH
15447: CALL_OW 67
// YouLost ( LostCommand ) ;
15451: LD_STRING LostCommand
15453: PPUSH
15454: CALL_OW 104
// end ;
15458: PPOPN 1
15460: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] ] ) = 0 and baseReadyToBuild = 0 and bonusAvalaible = 1 do var i , tmp ;
15461: LD_INT 22
15463: PUSH
15464: LD_INT 6
15466: PUSH
15467: EMPTY
15468: LIST
15469: LIST
15470: PUSH
15471: LD_INT 21
15473: PUSH
15474: LD_INT 1
15476: PUSH
15477: EMPTY
15478: LIST
15479: LIST
15480: PUSH
15481: EMPTY
15482: LIST
15483: LIST
15484: PPUSH
15485: CALL_OW 69
15489: PUSH
15490: LD_INT 0
15492: EQUAL
15493: PUSH
15494: LD_EXP 20
15498: PUSH
15499: LD_INT 0
15501: EQUAL
15502: AND
15503: PUSH
15504: LD_EXP 44
15508: PUSH
15509: LD_INT 1
15511: EQUAL
15512: AND
15513: IFFALSE 15607
15515: GO 15517
15517: DISABLE
15518: LD_INT 0
15520: PPUSH
15521: PPUSH
// begin tmp = FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) ;
15522: LD_ADDR_VAR 0 2
15526: PUSH
15527: LD_INT 22
15529: PUSH
15530: LD_INT 1
15532: PUSH
15533: EMPTY
15534: LIST
15535: LIST
15536: PUSH
15537: LD_INT 21
15539: PUSH
15540: LD_INT 1
15542: PUSH
15543: EMPTY
15544: LIST
15545: LIST
15546: PUSH
15547: LD_INT 23
15549: PUSH
15550: LD_INT 1
15552: PUSH
15553: EMPTY
15554: LIST
15555: LIST
15556: PUSH
15557: EMPTY
15558: LIST
15559: LIST
15560: LIST
15561: PPUSH
15562: CALL_OW 69
15566: ST_TO_ADDR
// for i in tmp do
15567: LD_ADDR_VAR 0 1
15571: PUSH
15572: LD_VAR 0 2
15576: PUSH
15577: FOR_IN
15578: IFFALSE 15605
// begin AddExperience ( i , rand ( 1 , 4 ) , 500 ) ;
15580: LD_VAR 0 1
15584: PPUSH
15585: LD_INT 1
15587: PPUSH
15588: LD_INT 4
15590: PPUSH
15591: CALL_OW 12
15595: PPUSH
15596: LD_INT 500
15598: PPUSH
15599: CALL_OW 492
// end ;
15603: GO 15577
15605: POP
15606: POP
// end ; end_of_file
15607: PPOPN 2
15609: END
// export enemyWayX , enemyWayY ; every 3 3$0 do var rnd ;
15610: GO 15612
15612: DISABLE
15613: LD_INT 0
15615: PPUSH
// begin enemyWayX = [ ] ;
15616: LD_ADDR_EXP 50
15620: PUSH
15621: EMPTY
15622: ST_TO_ADDR
// enemyWayY = [ ] ;
15623: LD_ADDR_EXP 51
15627: PUSH
15628: EMPTY
15629: ST_TO_ADDR
// rnd = rand ( 1 , 3 ) ;
15630: LD_ADDR_VAR 0 1
15634: PUSH
15635: LD_INT 1
15637: PPUSH
15638: LD_INT 3
15640: PPUSH
15641: CALL_OW 12
15645: ST_TO_ADDR
// if rnd = 1 then
15646: LD_VAR 0 1
15650: PUSH
15651: LD_INT 1
15653: EQUAL
15654: IFFALSE 15694
// begin enemyWayX = [ 73 , 46 , 29 ] ;
15656: LD_ADDR_EXP 50
15660: PUSH
15661: LD_INT 73
15663: PUSH
15664: LD_INT 46
15666: PUSH
15667: LD_INT 29
15669: PUSH
15670: EMPTY
15671: LIST
15672: LIST
15673: LIST
15674: ST_TO_ADDR
// enemyWayY = [ 71 , 43 , 29 ] ;
15675: LD_ADDR_EXP 51
15679: PUSH
15680: LD_INT 71
15682: PUSH
15683: LD_INT 43
15685: PUSH
15686: LD_INT 29
15688: PUSH
15689: EMPTY
15690: LIST
15691: LIST
15692: LIST
15693: ST_TO_ADDR
// end ; if rnd = 2 then
15694: LD_VAR 0 1
15698: PUSH
15699: LD_INT 2
15701: EQUAL
15702: IFFALSE 15726
// begin enemyWayX = [ 64 ] ;
15704: LD_ADDR_EXP 50
15708: PUSH
15709: LD_INT 64
15711: PUSH
15712: EMPTY
15713: LIST
15714: ST_TO_ADDR
// enemyWayY = [ 43 ] ;
15715: LD_ADDR_EXP 51
15719: PUSH
15720: LD_INT 43
15722: PUSH
15723: EMPTY
15724: LIST
15725: ST_TO_ADDR
// end ; if rnd = 3 then
15726: LD_VAR 0 1
15730: PUSH
15731: LD_INT 3
15733: EQUAL
15734: IFFALSE 15758
// begin enemyWayX = [ 80 ] ;
15736: LD_ADDR_EXP 50
15740: PUSH
15741: LD_INT 80
15743: PUSH
15744: EMPTY
15745: LIST
15746: ST_TO_ADDR
// enemyWayY = [ 28 ] ;
15747: LD_ADDR_EXP 51
15751: PUSH
15752: LD_INT 28
15754: PUSH
15755: EMPTY
15756: LIST
15757: ST_TO_ADDR
// end ; enable ;
15758: ENABLE
// end ;
15759: PPOPN 1
15761: END
// every 0 0$1 trigger AIEnable = 1 do
15762: LD_EXP 37
15766: PUSH
15767: LD_INT 1
15769: EQUAL
15770: IFFALSE 15884
15772: GO 15774
15774: DISABLE
// begin enable ;
15775: ENABLE
// RepairBuilding ( 3 , rubware0 , RussianBase ) ;
15776: LD_INT 3
15778: PPUSH
15779: LD_INT 21
15781: PPUSH
15782: LD_INT 7
15784: PPUSH
15785: CALL 5928 0 3
// HealUnitInBase ( 3 , RussianHealArea , RussianBase , rubbrid0 ) ;
15789: LD_INT 3
15791: PPUSH
15792: LD_INT 8
15794: PPUSH
15795: LD_INT 7
15797: PPUSH
15798: LD_INT 1
15800: PPUSH
15801: CALL 6249 0 4
// RepairVehicles ( 3 , RussianAttackRepair , 108 , 95 ) ;
15805: LD_INT 3
15807: PPUSH
15808: LD_INT 17
15810: PPUSH
15811: LD_INT 108
15813: PPUSH
15814: LD_INT 95
15816: PPUSH
15817: CALL 7573 0 4
// AttackVehicles ( 3 , RussianTanksSpot , enemyWayX , enemyWayY ) ;
15821: LD_INT 3
15823: PPUSH
15824: LD_INT 23
15826: PPUSH
15827: LD_EXP 50
15831: PPUSH
15832: LD_EXP 51
15836: PPUSH
15837: CALL 6905 0 4
// if baseReadyToBuild = 2 then
15841: LD_EXP 20
15845: PUSH
15846: LD_INT 2
15848: EQUAL
15849: IFFALSE 15884
// begin RepairBuilding ( 6 , ruPDepot , SecondRussianBase ) ;
15851: LD_INT 6
15853: PPUSH
15854: LD_EXP 21
15858: PPUSH
15859: LD_INT 6
15861: PPUSH
15862: CALL 5928 0 3
// HealUnitInBase ( 6 , SecondRussianHealArea , SecondRussianBase , ruPLab ) ;
15866: LD_INT 6
15868: PPUSH
15869: LD_INT 9
15871: PPUSH
15872: LD_INT 6
15874: PPUSH
15875: LD_EXP 22
15879: PPUSH
15880: CALL 6249 0 4
// end ; end ;
15884: END
// every 1 trigger not IsInUnit ( Stolypin ) and IsOk ( rubware0 ) and GetSide ( rubware0 ) = 3 do
15885: LD_EXP 15
15889: PPUSH
15890: CALL_OW 310
15894: NOT
15895: PUSH
15896: LD_INT 21
15898: PPUSH
15899: CALL_OW 302
15903: AND
15904: PUSH
15905: LD_INT 21
15907: PPUSH
15908: CALL_OW 255
15912: PUSH
15913: LD_INT 3
15915: EQUAL
15916: AND
15917: IFFALSE 15935
15919: GO 15921
15921: DISABLE
// begin enable ;
15922: ENABLE
// ComEnterUnit ( Stolypin , rubware0 ) ;
15923: LD_EXP 15
15927: PPUSH
15928: LD_INT 21
15930: PPUSH
15931: CALL_OW 120
// end ;
15935: END
// every 5 5$1 + 10 10$0 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_driving ] ] ) = 0 and GetSide ( rubbrid0 ) = 3 and IsOk ( rubware0 ) and GetSide ( rubware0 ) = 3 and IsOk ( rubware0 ) do
15936: LD_INT 22
15938: PUSH
15939: LD_INT 3
15941: PUSH
15942: EMPTY
15943: LIST
15944: LIST
15945: PUSH
15946: LD_INT 21
15948: PUSH
15949: LD_INT 2
15951: PUSH
15952: EMPTY
15953: LIST
15954: LIST
15955: PUSH
15956: LD_INT 55
15958: PUSH
15959: EMPTY
15960: LIST
15961: PUSH
15962: EMPTY
15963: LIST
15964: LIST
15965: LIST
15966: PPUSH
15967: CALL_OW 69
15971: PUSH
15972: LD_INT 0
15974: EQUAL
15975: PUSH
15976: LD_INT 1
15978: PPUSH
15979: CALL_OW 255
15983: PUSH
15984: LD_INT 3
15986: EQUAL
15987: AND
15988: PUSH
15989: LD_INT 21
15991: PPUSH
15992: CALL_OW 302
15996: AND
15997: PUSH
15998: LD_INT 21
16000: PPUSH
16001: CALL_OW 255
16005: PUSH
16006: LD_INT 3
16008: EQUAL
16009: AND
16010: PUSH
16011: LD_INT 21
16013: PPUSH
16014: CALL_OW 302
16018: AND
16019: IFFALSE 16231
16021: GO 16023
16023: DISABLE
// begin enable ;
16024: ENABLE
// if Difficulty = 1 then
16025: LD_OWVAR 67
16029: PUSH
16030: LD_INT 1
16032: EQUAL
16033: IFFALSE 16077
// BuildVehicle ( 3 , rubfact0 , Difficulty + 2 , [ 42 , 44 , 43 ] , 1 , 1 , 21 ) ;
16035: LD_INT 3
16037: PPUSH
16038: LD_INT 24
16040: PPUSH
16041: LD_OWVAR 67
16045: PUSH
16046: LD_INT 2
16048: PLUS
16049: PPUSH
16050: LD_INT 42
16052: PUSH
16053: LD_INT 44
16055: PUSH
16056: LD_INT 43
16058: PUSH
16059: EMPTY
16060: LIST
16061: LIST
16062: LIST
16063: PPUSH
16064: LD_INT 1
16066: PPUSH
16067: LD_INT 1
16069: PPUSH
16070: LD_INT 21
16072: PPUSH
16073: CALL 6793 0 7
// if Difficulty = 2 then
16077: LD_OWVAR 67
16081: PUSH
16082: LD_INT 2
16084: EQUAL
16085: IFFALSE 16152
// BuildVehicle ( 3 , rubfact0 , Difficulty + 2 , [ 44 , 44 , 43 , 43 ] , 1 , 1 , [ 21 , 22 ] [ Rand ( 1 , 2 ) ] ) ;
16087: LD_INT 3
16089: PPUSH
16090: LD_INT 24
16092: PPUSH
16093: LD_OWVAR 67
16097: PUSH
16098: LD_INT 2
16100: PLUS
16101: PPUSH
16102: LD_INT 44
16104: PUSH
16105: LD_INT 44
16107: PUSH
16108: LD_INT 43
16110: PUSH
16111: LD_INT 43
16113: PUSH
16114: EMPTY
16115: LIST
16116: LIST
16117: LIST
16118: LIST
16119: PPUSH
16120: LD_INT 1
16122: PPUSH
16123: LD_INT 1
16125: PPUSH
16126: LD_INT 21
16128: PUSH
16129: LD_INT 22
16131: PUSH
16132: EMPTY
16133: LIST
16134: LIST
16135: PUSH
16136: LD_INT 1
16138: PPUSH
16139: LD_INT 2
16141: PPUSH
16142: CALL_OW 12
16146: ARRAY
16147: PPUSH
16148: CALL 6793 0 7
// if Difficulty = 3 then
16152: LD_OWVAR 67
16156: PUSH
16157: LD_INT 3
16159: EQUAL
16160: IFFALSE 16231
// BuildVehicle ( 3 , rubfact0 , Difficulty + rand ( 2 , 3 ) , [ 44 , 44 , 43 ] , 1 , 1 , [ ru_medium_tracked , ru_heavy_wheeled ] [ rand ( 1 , 2 ) ] ) ;
16162: LD_INT 3
16164: PPUSH
16165: LD_INT 24
16167: PPUSH
16168: LD_OWVAR 67
16172: PUSH
16173: LD_INT 2
16175: PPUSH
16176: LD_INT 3
16178: PPUSH
16179: CALL_OW 12
16183: PLUS
16184: PPUSH
16185: LD_INT 44
16187: PUSH
16188: LD_INT 44
16190: PUSH
16191: LD_INT 43
16193: PUSH
16194: EMPTY
16195: LIST
16196: LIST
16197: LIST
16198: PPUSH
16199: LD_INT 1
16201: PPUSH
16202: LD_INT 1
16204: PPUSH
16205: LD_INT 22
16207: PUSH
16208: LD_INT 23
16210: PUSH
16211: EMPTY
16212: LIST
16213: LIST
16214: PUSH
16215: LD_INT 1
16217: PPUSH
16218: LD_INT 2
16220: PPUSH
16221: CALL_OW 12
16225: ARRAY
16226: PPUSH
16227: CALL 6793 0 7
// end ;
16231: END
// every 0 0$1 do
16232: GO 16234
16234: DISABLE
// ResAllTechs ( 3 , rubbrid0 , 3 ) ;
16235: LD_INT 3
16237: PPUSH
16238: LD_INT 1
16240: PPUSH
16241: LD_INT 3
16243: PPUSH
16244: CALL 5843 0 3
16248: END
// every 0 0$1 trigger baseReadyToBuild = 1 do var i , cargo ;
16249: LD_EXP 20
16253: PUSH
16254: LD_INT 1
16256: EQUAL
16257: IFFALSE 16404
16259: GO 16261
16261: DISABLE
16262: LD_INT 0
16264: PPUSH
16265: PPUSH
// begin cargo = FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_weapon , 51 ] ] ) ;
16266: LD_ADDR_VAR 0 2
16270: PUSH
16271: LD_INT 22
16273: PUSH
16274: LD_INT 6
16276: PUSH
16277: EMPTY
16278: LIST
16279: LIST
16280: PUSH
16281: LD_INT 21
16283: PUSH
16284: LD_INT 2
16286: PUSH
16287: EMPTY
16288: LIST
16289: LIST
16290: PUSH
16291: LD_INT 34
16293: PUSH
16294: LD_INT 51
16296: PUSH
16297: EMPTY
16298: LIST
16299: LIST
16300: PUSH
16301: EMPTY
16302: LIST
16303: LIST
16304: LIST
16305: PPUSH
16306: CALL_OW 69
16310: ST_TO_ADDR
// ComMoveXY ( cargo [ 1 ] , GetX ( ruPDepot ) - 5 , GetY ( ruPDepot ) - 5 ) ;
16311: LD_VAR 0 2
16315: PUSH
16316: LD_INT 1
16318: ARRAY
16319: PPUSH
16320: LD_EXP 21
16324: PPUSH
16325: CALL_OW 250
16329: PUSH
16330: LD_INT 5
16332: MINUS
16333: PPUSH
16334: LD_EXP 21
16338: PPUSH
16339: CALL_OW 251
16343: PUSH
16344: LD_INT 5
16346: MINUS
16347: PPUSH
16348: CALL_OW 111
// wait ( 0 0$5 ) ;
16352: LD_INT 175
16354: PPUSH
16355: CALL_OW 67
// AddComCollect ( cargo [ 1 ] , 41 , 52 ) ;
16359: LD_VAR 0 2
16363: PUSH
16364: LD_INT 1
16366: ARRAY
16367: PPUSH
16368: LD_INT 41
16370: PPUSH
16371: LD_INT 52
16373: PPUSH
16374: CALL_OW 177
// wait ( 0 0$40 ) ;
16378: LD_INT 1400
16380: PPUSH
16381: CALL_OW 67
// ComMoveXY ( cargo [ 1 ] , 41 , 44 ) ;
16385: LD_VAR 0 2
16389: PUSH
16390: LD_INT 1
16392: ARRAY
16393: PPUSH
16394: LD_INT 41
16396: PPUSH
16397: LD_INT 44
16399: PPUSH
16400: CALL_OW 111
// end ;
16404: PPOPN 2
16406: END
// every 0 0$1 trigger GetResourceType ( GetBase ( ruPDepot ) , 1 ) >= 100 do var eng ;
16407: LD_EXP 21
16411: PPUSH
16412: CALL_OW 274
16416: PPUSH
16417: LD_INT 1
16419: PPUSH
16420: CALL_OW 275
16424: PUSH
16425: LD_INT 100
16427: GREATEREQUAL
16428: IFFALSE 16656
16430: GO 16432
16432: DISABLE
16433: LD_INT 0
16435: PPUSH
// begin eng = FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] , [ f_class , 2 ] ] ) ;
16436: LD_ADDR_VAR 0 1
16440: PUSH
16441: LD_INT 22
16443: PUSH
16444: LD_INT 6
16446: PUSH
16447: EMPTY
16448: LIST
16449: LIST
16450: PUSH
16451: LD_INT 21
16453: PUSH
16454: LD_INT 1
16456: PUSH
16457: EMPTY
16458: LIST
16459: LIST
16460: PUSH
16461: LD_INT 25
16463: PUSH
16464: LD_INT 2
16466: PUSH
16467: EMPTY
16468: LIST
16469: LIST
16470: PUSH
16471: EMPTY
16472: LIST
16473: LIST
16474: LIST
16475: PPUSH
16476: CALL_OW 69
16480: ST_TO_ADDR
// ComBuild ( eng [ 1 ] , 4 , 39 , 37 , 3 ) ;
16481: LD_VAR 0 1
16485: PUSH
16486: LD_INT 1
16488: ARRAY
16489: PPUSH
16490: LD_INT 4
16492: PPUSH
16493: LD_INT 39
16495: PPUSH
16496: LD_INT 37
16498: PPUSH
16499: LD_INT 3
16501: PPUSH
16502: CALL_OW 145
// AddComBuild ( eng [ 1 ] , 29 , 42 , 54 , 3 ) ;
16506: LD_VAR 0 1
16510: PUSH
16511: LD_INT 1
16513: ARRAY
16514: PPUSH
16515: LD_INT 29
16517: PPUSH
16518: LD_INT 42
16520: PPUSH
16521: LD_INT 54
16523: PPUSH
16524: LD_INT 3
16526: PPUSH
16527: CALL_OW 205
// AddComBuild ( eng [ 1 ] , 6 , 38 , 48 , 0 ) ;
16531: LD_VAR 0 1
16535: PUSH
16536: LD_INT 1
16538: ARRAY
16539: PPUSH
16540: LD_INT 6
16542: PPUSH
16543: LD_INT 38
16545: PPUSH
16546: LD_INT 48
16548: PPUSH
16549: LD_INT 0
16551: PPUSH
16552: CALL_OW 205
// AddComBuild ( eng [ 1 ] , 2 , 32 , 38 , 2 ) ;
16556: LD_VAR 0 1
16560: PUSH
16561: LD_INT 1
16563: ARRAY
16564: PPUSH
16565: LD_INT 2
16567: PPUSH
16568: LD_INT 32
16570: PPUSH
16571: LD_INT 38
16573: PPUSH
16574: LD_INT 2
16576: PPUSH
16577: CALL_OW 205
// AddComBuild ( eng [ 1 ] , 26 , 39 , 55 , 3 ) ;
16581: LD_VAR 0 1
16585: PUSH
16586: LD_INT 1
16588: ARRAY
16589: PPUSH
16590: LD_INT 26
16592: PPUSH
16593: LD_INT 39
16595: PPUSH
16596: LD_INT 55
16598: PPUSH
16599: LD_INT 3
16601: PPUSH
16602: CALL_OW 205
// AddComBuild ( eng [ 1 ] , 32 , 31 , 31 , 3 ) ;
16606: LD_VAR 0 1
16610: PUSH
16611: LD_INT 1
16613: ARRAY
16614: PPUSH
16615: LD_INT 32
16617: PPUSH
16618: LD_INT 31
16620: PPUSH
16621: LD_INT 31
16623: PPUSH
16624: LD_INT 3
16626: PPUSH
16627: CALL_OW 205
// AddComBuild ( eng [ 1 ] , b_breastwork , 50 , 51 , 4 ) ;
16631: LD_VAR 0 1
16635: PUSH
16636: LD_INT 1
16638: ARRAY
16639: PPUSH
16640: LD_INT 31
16642: PPUSH
16643: LD_INT 50
16645: PPUSH
16646: LD_INT 51
16648: PPUSH
16649: LD_INT 4
16651: PPUSH
16652: CALL_OW 205
// end ;
16656: PPOPN 1
16658: END
// every 0 0$1 trigger ruMobile do var i , mech , enemy ;
16659: LD_EXP 46
16663: IFFALSE 17220
16665: GO 16667
16667: DISABLE
16668: LD_INT 0
16670: PPUSH
16671: PPUSH
16672: PPUSH
// begin enable ;
16673: ENABLE
// if not ruMobile then
16674: LD_EXP 46
16678: NOT
16679: IFFALSE 16683
// exit ;
16681: GO 17220
// for i in ruMobile do
16683: LD_ADDR_VAR 0 1
16687: PUSH
16688: LD_EXP 46
16692: PUSH
16693: FOR_IN
16694: IFFALSE 17218
// begin if not IsOk ( i ) or GetSide ( i ) <> 3 then
16696: LD_VAR 0 1
16700: PPUSH
16701: CALL_OW 302
16705: NOT
16706: PUSH
16707: LD_VAR 0 1
16711: PPUSH
16712: CALL_OW 255
16716: PUSH
16717: LD_INT 3
16719: NONEQUAL
16720: OR
16721: IFFALSE 16741
// begin ruMobile := ruMobile diff i ;
16723: LD_ADDR_EXP 46
16727: PUSH
16728: LD_EXP 46
16732: PUSH
16733: LD_VAR 0 1
16737: DIFF
16738: ST_TO_ADDR
// continue ;
16739: GO 16693
// end ; if not GetTag ( i ) or GetTag ( i ) = 0 then
16741: LD_VAR 0 1
16745: PPUSH
16746: CALL_OW 110
16750: NOT
16751: PUSH
16752: LD_VAR 0 1
16756: PPUSH
16757: CALL_OW 110
16761: PUSH
16762: LD_INT 0
16764: EQUAL
16765: OR
16766: IFFALSE 16881
// begin if GetFuel ( i ) < 50 then
16768: LD_VAR 0 1
16772: PPUSH
16773: CALL_OW 261
16777: PUSH
16778: LD_INT 50
16780: LESS
16781: IFFALSE 16840
// begin ComMoveXY ( i , 106 , 88 ) ;
16783: LD_VAR 0 1
16787: PPUSH
16788: LD_INT 106
16790: PPUSH
16791: LD_INT 88
16793: PPUSH
16794: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
16798: LD_INT 35
16800: PPUSH
16801: CALL_OW 67
// until GetDistUnitXY ( i , 106 , 88 ) < 4 ;
16805: LD_VAR 0 1
16809: PPUSH
16810: LD_INT 106
16812: PPUSH
16813: LD_INT 88
16815: PPUSH
16816: CALL_OW 297
16820: PUSH
16821: LD_INT 4
16823: LESS
16824: IFFALSE 16798
// SetFuel ( i , 100 ) ;
16826: LD_VAR 0 1
16830: PPUSH
16831: LD_INT 100
16833: PPUSH
16834: CALL_OW 240
// end else
16838: GO 16881
// if not IsInArea ( i , ruParking ) then
16840: LD_VAR 0 1
16844: PPUSH
16845: LD_INT 25
16847: PPUSH
16848: CALL_OW 308
16852: NOT
16853: IFFALSE 16869
// ComMoveToArea ( i , ruParking ) else
16855: LD_VAR 0 1
16859: PPUSH
16860: LD_INT 25
16862: PPUSH
16863: CALL_OW 113
16867: GO 16881
// SetTag ( i , 1 ) ;
16869: LD_VAR 0 1
16873: PPUSH
16874: LD_INT 1
16876: PPUSH
16877: CALL_OW 109
// end ; if GetTag ( i ) = 1 then
16881: LD_VAR 0 1
16885: PPUSH
16886: CALL_OW 110
16890: PUSH
16891: LD_INT 1
16893: EQUAL
16894: IFFALSE 17024
// begin if GetLives ( i ) < 1000 then
16896: LD_VAR 0 1
16900: PPUSH
16901: CALL_OW 256
16905: PUSH
16906: LD_INT 1000
16908: LESS
16909: IFFALSE 17001
// begin if not IsDrivenBy ( i ) then
16911: LD_VAR 0 1
16915: PPUSH
16916: CALL_OW 311
16920: NOT
16921: IFFALSE 16925
// continue ;
16923: GO 16693
// mech := IsDrivenBy ( i ) ;
16925: LD_ADDR_VAR 0 2
16929: PUSH
16930: LD_VAR 0 1
16934: PPUSH
16935: CALL_OW 311
16939: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
16940: LD_VAR 0 2
16944: PPUSH
16945: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
16949: LD_VAR 0 2
16953: PPUSH
16954: LD_VAR 0 1
16958: PPUSH
16959: CALL_OW 189
// repeat wait ( 0 0$1 ) ;
16963: LD_INT 35
16965: PPUSH
16966: CALL_OW 67
// until GetLives ( i ) = 1000 ;
16970: LD_VAR 0 1
16974: PPUSH
16975: CALL_OW 256
16979: PUSH
16980: LD_INT 1000
16982: EQUAL
16983: IFFALSE 16963
// ComEnterUnit ( mech , i ) ;
16985: LD_VAR 0 2
16989: PPUSH
16990: LD_VAR 0 1
16994: PPUSH
16995: CALL_OW 120
// end else
16999: GO 17024
// if IsDrivenBy ( i ) then
17001: LD_VAR 0 1
17005: PPUSH
17006: CALL_OW 311
17010: IFFALSE 17024
// SetTag ( i , 2 ) ;
17012: LD_VAR 0 1
17016: PPUSH
17017: LD_INT 2
17019: PPUSH
17020: CALL_OW 109
// end ; if GetTag ( i ) = 2 then
17024: LD_VAR 0 1
17028: PPUSH
17029: CALL_OW 110
17033: PUSH
17034: LD_INT 2
17036: EQUAL
17037: IFFALSE 17216
// begin enemy := FilterUnitsInArea ( ruDefArea , [ f_enemy , 3 ] ) ;
17039: LD_ADDR_VAR 0 3
17043: PUSH
17044: LD_INT 24
17046: PPUSH
17047: LD_INT 81
17049: PUSH
17050: LD_INT 3
17052: PUSH
17053: EMPTY
17054: LIST
17055: LIST
17056: PPUSH
17057: CALL_OW 70
17061: ST_TO_ADDR
// if GetLives ( i ) < 650 then
17062: LD_VAR 0 1
17066: PPUSH
17067: CALL_OW 256
17071: PUSH
17072: LD_INT 650
17074: LESS
17075: IFFALSE 17100
// begin ComStop ( i ) ;
17077: LD_VAR 0 1
17081: PPUSH
17082: CALL_OW 141
// SetTag ( i , 0 ) ;
17086: LD_VAR 0 1
17090: PPUSH
17091: LD_INT 0
17093: PPUSH
17094: CALL_OW 109
// continue ;
17098: GO 16693
// end ; if enemy then
17100: LD_VAR 0 3
17104: IFFALSE 17144
// begin if not HasTask ( i ) then
17106: LD_VAR 0 1
17110: PPUSH
17111: CALL_OW 314
17115: NOT
17116: IFFALSE 17142
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
17118: LD_VAR 0 1
17122: PPUSH
17123: LD_VAR 0 3
17127: PPUSH
17128: LD_VAR 0 1
17132: PPUSH
17133: CALL_OW 74
17137: PPUSH
17138: CALL_OW 115
// end else
17142: GO 17216
// if ruMobile > 2 then
17144: LD_EXP 46
17148: PUSH
17149: LD_INT 2
17151: GREATER
17152: IFFALSE 17216
// begin enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
17154: LD_ADDR_VAR 0 3
17158: PUSH
17159: LD_INT 81
17161: PUSH
17162: LD_INT 3
17164: PUSH
17165: EMPTY
17166: LIST
17167: LIST
17168: PPUSH
17169: CALL_OW 69
17173: ST_TO_ADDR
// if enemy then
17174: LD_VAR 0 3
17178: IFFALSE 17216
// if not HasTask ( i ) then
17180: LD_VAR 0 1
17184: PPUSH
17185: CALL_OW 314
17189: NOT
17190: IFFALSE 17216
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
17192: LD_VAR 0 1
17196: PPUSH
17197: LD_VAR 0 3
17201: PPUSH
17202: LD_VAR 0 1
17206: PPUSH
17207: CALL_OW 74
17211: PPUSH
17212: CALL_OW 115
// end ; end ; end ;
17216: GO 16693
17218: POP
17219: POP
// end ; end_of_file
17220: PPOPN 3
17222: END
// on BuildingComplete ( building ) do var i , tmpSold , tmpEng , tmpMeh , tmpSci , tmpSoldInside , cargo ;
17223: LD_INT 0
17225: PPUSH
17226: PPUSH
17227: PPUSH
17228: PPUSH
17229: PPUSH
17230: PPUSH
17231: PPUSH
// begin tmpSold = FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] , [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
17232: LD_ADDR_VAR 0 3
17236: PUSH
17237: LD_INT 22
17239: PUSH
17240: LD_INT 6
17242: PUSH
17243: EMPTY
17244: LIST
17245: LIST
17246: PUSH
17247: LD_INT 21
17249: PUSH
17250: LD_INT 1
17252: PUSH
17253: EMPTY
17254: LIST
17255: LIST
17256: PUSH
17257: LD_INT 25
17259: PUSH
17260: LD_INT 1
17262: PUSH
17263: EMPTY
17264: LIST
17265: LIST
17266: PUSH
17267: LD_INT 3
17269: PUSH
17270: LD_INT 54
17272: PUSH
17273: EMPTY
17274: LIST
17275: PUSH
17276: EMPTY
17277: LIST
17278: LIST
17279: PUSH
17280: EMPTY
17281: LIST
17282: LIST
17283: LIST
17284: LIST
17285: PPUSH
17286: CALL_OW 69
17290: ST_TO_ADDR
// tmpSoldInside = FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] , [ f_class , 1 ] , [ f_inside ] ] ) ;
17291: LD_ADDR_VAR 0 7
17295: PUSH
17296: LD_INT 22
17298: PUSH
17299: LD_INT 6
17301: PUSH
17302: EMPTY
17303: LIST
17304: LIST
17305: PUSH
17306: LD_INT 21
17308: PUSH
17309: LD_INT 1
17311: PUSH
17312: EMPTY
17313: LIST
17314: LIST
17315: PUSH
17316: LD_INT 25
17318: PUSH
17319: LD_INT 1
17321: PUSH
17322: EMPTY
17323: LIST
17324: LIST
17325: PUSH
17326: LD_INT 54
17328: PUSH
17329: EMPTY
17330: LIST
17331: PUSH
17332: EMPTY
17333: LIST
17334: LIST
17335: LIST
17336: LIST
17337: PPUSH
17338: CALL_OW 69
17342: ST_TO_ADDR
// tmpEng = FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] , [ f_class , 2 ] ] ) ;
17343: LD_ADDR_VAR 0 4
17347: PUSH
17348: LD_INT 22
17350: PUSH
17351: LD_INT 6
17353: PUSH
17354: EMPTY
17355: LIST
17356: LIST
17357: PUSH
17358: LD_INT 21
17360: PUSH
17361: LD_INT 1
17363: PUSH
17364: EMPTY
17365: LIST
17366: LIST
17367: PUSH
17368: LD_INT 25
17370: PUSH
17371: LD_INT 2
17373: PUSH
17374: EMPTY
17375: LIST
17376: LIST
17377: PUSH
17378: EMPTY
17379: LIST
17380: LIST
17381: LIST
17382: PPUSH
17383: CALL_OW 69
17387: ST_TO_ADDR
// tmpSci = FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] , [ f_class , 4 ] ] ) ;
17388: LD_ADDR_VAR 0 6
17392: PUSH
17393: LD_INT 22
17395: PUSH
17396: LD_INT 6
17398: PUSH
17399: EMPTY
17400: LIST
17401: LIST
17402: PUSH
17403: LD_INT 21
17405: PUSH
17406: LD_INT 1
17408: PUSH
17409: EMPTY
17410: LIST
17411: LIST
17412: PUSH
17413: LD_INT 25
17415: PUSH
17416: LD_INT 4
17418: PUSH
17419: EMPTY
17420: LIST
17421: LIST
17422: PUSH
17423: EMPTY
17424: LIST
17425: LIST
17426: LIST
17427: PPUSH
17428: CALL_OW 69
17432: ST_TO_ADDR
// cargo = FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_weapon , 51 ] ] ) ;
17433: LD_ADDR_VAR 0 8
17437: PUSH
17438: LD_INT 22
17440: PUSH
17441: LD_INT 6
17443: PUSH
17444: EMPTY
17445: LIST
17446: LIST
17447: PUSH
17448: LD_INT 21
17450: PUSH
17451: LD_INT 2
17453: PUSH
17454: EMPTY
17455: LIST
17456: LIST
17457: PUSH
17458: LD_INT 34
17460: PUSH
17461: LD_INT 51
17463: PUSH
17464: EMPTY
17465: LIST
17466: LIST
17467: PUSH
17468: EMPTY
17469: LIST
17470: LIST
17471: LIST
17472: PPUSH
17473: CALL_OW 69
17477: ST_TO_ADDR
// if GetSide ( building ) = 6 and GetBType ( building ) = b_depot then
17478: LD_VAR 0 1
17482: PPUSH
17483: CALL_OW 255
17487: PUSH
17488: LD_INT 6
17490: EQUAL
17491: PUSH
17492: LD_VAR 0 1
17496: PPUSH
17497: CALL_OW 266
17501: PUSH
17502: LD_INT 0
17504: EQUAL
17505: AND
17506: IFFALSE 17526
// begin ruPDepot = building ;
17508: LD_ADDR_EXP 21
17512: PUSH
17513: LD_VAR 0 1
17517: ST_TO_ADDR
// baseReadyToBuild = 1 ;
17518: LD_ADDR_EXP 20
17522: PUSH
17523: LD_INT 1
17525: ST_TO_ADDR
// end ; if GetBType ( building ) = 4 and GetSide ( building ) = 6 then
17526: LD_VAR 0 1
17530: PPUSH
17531: CALL_OW 266
17535: PUSH
17536: LD_INT 4
17538: EQUAL
17539: PUSH
17540: LD_VAR 0 1
17544: PPUSH
17545: CALL_OW 255
17549: PUSH
17550: LD_INT 6
17552: EQUAL
17553: AND
17554: IFFALSE 17587
// for i in tmpSold do
17556: LD_ADDR_VAR 0 2
17560: PUSH
17561: LD_VAR 0 3
17565: PUSH
17566: FOR_IN
17567: IFFALSE 17585
// ComEnterUnit ( i , building ) ;
17569: LD_VAR 0 2
17573: PPUSH
17574: LD_VAR 0 1
17578: PPUSH
17579: CALL_OW 120
17583: GO 17566
17585: POP
17586: POP
// if GetBType ( building ) = 6 and GetSide ( building ) = 6 then
17587: LD_VAR 0 1
17591: PPUSH
17592: CALL_OW 266
17596: PUSH
17597: LD_INT 6
17599: EQUAL
17600: PUSH
17601: LD_VAR 0 1
17605: PPUSH
17606: CALL_OW 255
17610: PUSH
17611: LD_INT 6
17613: EQUAL
17614: AND
17615: IFFALSE 17673
// begin for i in tmpSci do
17617: LD_ADDR_VAR 0 2
17621: PUSH
17622: LD_VAR 0 6
17626: PUSH
17627: FOR_IN
17628: IFFALSE 17646
// ComEnterUnit ( i , building ) ;
17630: LD_VAR 0 2
17634: PPUSH
17635: LD_VAR 0 1
17639: PPUSH
17640: CALL_OW 120
17644: GO 17627
17646: POP
17647: POP
// ResAllTechs ( 6 , building , 3 ) ;
17648: LD_INT 6
17650: PPUSH
17651: LD_VAR 0 1
17655: PPUSH
17656: LD_INT 3
17658: PPUSH
17659: CALL 5843 0 3
// ruPLab = building ;
17663: LD_ADDR_EXP 22
17667: PUSH
17668: LD_VAR 0 1
17672: ST_TO_ADDR
// end ; if GetBType ( building ) = 2 and GetSide ( building ) = 6 then
17673: LD_VAR 0 1
17677: PPUSH
17678: CALL_OW 266
17682: PUSH
17683: LD_INT 2
17685: EQUAL
17686: PUSH
17687: LD_VAR 0 1
17691: PPUSH
17692: CALL_OW 255
17696: PUSH
17697: LD_INT 6
17699: EQUAL
17700: AND
17701: IFFALSE 17752
// begin tmpMeh = UnitsInside ( cargo [ 1 ] ) ;
17703: LD_ADDR_VAR 0 5
17707: PUSH
17708: LD_VAR 0 8
17712: PUSH
17713: LD_INT 1
17715: ARRAY
17716: PPUSH
17717: CALL_OW 313
17721: ST_TO_ADDR
// ComExitVehicle ( tmpMeh ) ;
17722: LD_VAR 0 5
17726: PPUSH
17727: CALL_OW 121
// wait ( 0 0$1 ) ;
17731: LD_INT 35
17733: PPUSH
17734: CALL_OW 67
// AddComEnterUnit ( tmpMeh , building ) ;
17738: LD_VAR 0 5
17742: PPUSH
17743: LD_VAR 0 1
17747: PPUSH
17748: CALL_OW 180
// end ; if GetBType ( building ) = 32 and GetSide ( building ) = 6 then
17752: LD_VAR 0 1
17756: PPUSH
17757: CALL_OW 266
17761: PUSH
17762: LD_INT 32
17764: EQUAL
17765: PUSH
17766: LD_VAR 0 1
17770: PPUSH
17771: CALL_OW 255
17775: PUSH
17776: LD_INT 6
17778: EQUAL
17779: AND
17780: IFFALSE 17832
// begin ComPlaceWeapon ( building , 42 ) ;
17782: LD_VAR 0 1
17786: PPUSH
17787: LD_INT 42
17789: PPUSH
17790: CALL_OW 148
// ComExitBuilding ( tmpSoldInside [ 1 ] ) ;
17794: LD_VAR 0 7
17798: PUSH
17799: LD_INT 1
17801: ARRAY
17802: PPUSH
17803: CALL_OW 122
// wait ( 0 0$1 ) ;
17807: LD_INT 35
17809: PPUSH
17810: CALL_OW 67
// AddComEnterUnit ( tmpSoldInside [ 1 ] , building ) ;
17814: LD_VAR 0 7
17818: PUSH
17819: LD_INT 1
17821: ARRAY
17822: PPUSH
17823: LD_VAR 0 1
17827: PPUSH
17828: CALL_OW 180
// end ; if GetBType ( building ) = b_breastwork and GetSide ( building ) = 6 then
17832: LD_VAR 0 1
17836: PPUSH
17837: CALL_OW 266
17841: PUSH
17842: LD_INT 31
17844: EQUAL
17845: PUSH
17846: LD_VAR 0 1
17850: PPUSH
17851: CALL_OW 255
17855: PUSH
17856: LD_INT 6
17858: EQUAL
17859: AND
17860: IFFALSE 17926
// begin ComExitBuilding ( tmpSoldInside [ 2 ] ) ;
17862: LD_VAR 0 7
17866: PUSH
17867: LD_INT 2
17869: ARRAY
17870: PPUSH
17871: CALL_OW 122
// wait ( 0 0$1 ) ;
17875: LD_INT 35
17877: PPUSH
17878: CALL_OW 67
// AddComEnterUnit ( tmpSoldInside [ 2 ] , building ) ;
17882: LD_VAR 0 7
17886: PUSH
17887: LD_INT 2
17889: ARRAY
17890: PPUSH
17891: LD_VAR 0 1
17895: PPUSH
17896: CALL_OW 180
// ComEnterUnit ( tmpEng [ 1 ] , ruPDepot ) ;
17900: LD_VAR 0 4
17904: PUSH
17905: LD_INT 1
17907: ARRAY
17908: PPUSH
17909: LD_EXP 21
17913: PPUSH
17914: CALL_OW 120
// baseReadyToBuild = 2 ;
17918: LD_ADDR_EXP 20
17922: PUSH
17923: LD_INT 2
17925: ST_TO_ADDR
// end ; if GetBType ( building ) = b_bunker and GetSide ( building ) = 1 and bunkerDialog = 0 then
17926: LD_VAR 0 1
17930: PPUSH
17931: CALL_OW 266
17935: PUSH
17936: LD_INT 32
17938: EQUAL
17939: PUSH
17940: LD_VAR 0 1
17944: PPUSH
17945: CALL_OW 255
17949: PUSH
17950: LD_INT 1
17952: EQUAL
17953: AND
17954: PUSH
17955: LD_EXP 32
17959: PUSH
17960: LD_INT 0
17962: EQUAL
17963: AND
17964: IFFALSE 18209
// begin bunkerDialog = 1 ;
17966: LD_ADDR_EXP 32
17970: PUSH
17971: LD_INT 1
17973: ST_TO_ADDR
// if IsOK ( Claptopn ) then
17974: LD_EXP 11
17978: PPUSH
17979: CALL_OW 302
17983: IFFALSE 17999
// begin Say ( Claptopn , D11-Eng1-1 ) ;
17985: LD_EXP 11
17989: PPUSH
17990: LD_STRING D11-Eng1-1
17992: PPUSH
17993: CALL_OW 88
// end else
17997: GO 18195
// begin ; if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , 3 ] , [ f_sex , 1 ] ] ) diff [ JMM ] > 0 then
17999: LD_INT 22
18001: PUSH
18002: LD_INT 1
18004: PUSH
18005: EMPTY
18006: LIST
18007: LIST
18008: PUSH
18009: LD_INT 21
18011: PUSH
18012: LD_INT 1
18014: PUSH
18015: EMPTY
18016: LIST
18017: LIST
18018: PUSH
18019: LD_INT 25
18021: PUSH
18022: LD_INT 3
18024: PUSH
18025: EMPTY
18026: LIST
18027: LIST
18028: PUSH
18029: LD_INT 26
18031: PUSH
18032: LD_INT 1
18034: PUSH
18035: EMPTY
18036: LIST
18037: LIST
18038: PUSH
18039: EMPTY
18040: LIST
18041: LIST
18042: LIST
18043: LIST
18044: PPUSH
18045: CALL_OW 69
18049: PUSH
18050: LD_EXP 1
18054: PUSH
18055: EMPTY
18056: LIST
18057: PUSH
18058: LD_INT 0
18060: GREATER
18061: DIFF
18062: IFFALSE 18136
// begin DialogRandom ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , 2 ] , [ f_sex , 1 ] ] ) diff [ JMM ] , D11-Eng1-1 , D11-Eng1-1 ) ;
18064: LD_INT 22
18066: PUSH
18067: LD_INT 1
18069: PUSH
18070: EMPTY
18071: LIST
18072: LIST
18073: PUSH
18074: LD_INT 21
18076: PUSH
18077: LD_INT 1
18079: PUSH
18080: EMPTY
18081: LIST
18082: LIST
18083: PUSH
18084: LD_INT 25
18086: PUSH
18087: LD_INT 2
18089: PUSH
18090: EMPTY
18091: LIST
18092: LIST
18093: PUSH
18094: LD_INT 26
18096: PUSH
18097: LD_INT 1
18099: PUSH
18100: EMPTY
18101: LIST
18102: LIST
18103: PUSH
18104: EMPTY
18105: LIST
18106: LIST
18107: LIST
18108: LIST
18109: PPUSH
18110: CALL_OW 69
18114: PUSH
18115: LD_EXP 1
18119: PUSH
18120: EMPTY
18121: LIST
18122: DIFF
18123: PPUSH
18124: LD_STRING D11-Eng1-1
18126: PPUSH
18127: LD_STRING D11-Eng1-1
18129: PPUSH
18130: CALL 4492 0 3
// end else
18134: GO 18195
// begin DialogRandom ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_sex , 1 ] ] ) diff [ JMM ] , D11-Eng1-1 , D11-Eng1-1 ) ;
18136: LD_INT 22
18138: PUSH
18139: LD_INT 1
18141: PUSH
18142: EMPTY
18143: LIST
18144: LIST
18145: PUSH
18146: LD_INT 21
18148: PUSH
18149: LD_INT 1
18151: PUSH
18152: EMPTY
18153: LIST
18154: LIST
18155: PUSH
18156: LD_INT 26
18158: PUSH
18159: LD_INT 1
18161: PUSH
18162: EMPTY
18163: LIST
18164: LIST
18165: PUSH
18166: EMPTY
18167: LIST
18168: LIST
18169: LIST
18170: PPUSH
18171: CALL_OW 69
18175: PUSH
18176: LD_EXP 1
18180: PUSH
18181: EMPTY
18182: LIST
18183: DIFF
18184: PPUSH
18185: LD_STRING D11-Eng1-1
18187: PPUSH
18188: LD_STRING D11-Eng1-1
18190: PPUSH
18191: CALL 4492 0 3
// end ; end ; if energyVDialog = 0 then
18195: LD_EXP 33
18199: PUSH
18200: LD_INT 0
18202: EQUAL
18203: IFFALSE 18209
// EnergyDialog ;
18205: CALL 4895 0 0
// end ; if GetBType ( building ) = b_oil_mine and GetSide ( building ) = 1 then
18209: LD_VAR 0 1
18213: PPUSH
18214: CALL_OW 266
18218: PUSH
18219: LD_INT 29
18221: EQUAL
18222: PUSH
18223: LD_VAR 0 1
18227: PPUSH
18228: CALL_OW 255
18232: PUSH
18233: LD_INT 1
18235: EQUAL
18236: AND
18237: IFFALSE 18247
// buildOil = 1 ;
18239: LD_ADDR_EXP 34
18243: PUSH
18244: LD_INT 1
18246: ST_TO_ADDR
// if GetBType ( building ) = b_oil_power and GetSide ( building ) = 1 then
18247: LD_VAR 0 1
18251: PPUSH
18252: CALL_OW 266
18256: PUSH
18257: LD_INT 26
18259: EQUAL
18260: PUSH
18261: LD_VAR 0 1
18265: PPUSH
18266: CALL_OW 255
18270: PUSH
18271: LD_INT 1
18273: EQUAL
18274: AND
18275: IFFALSE 18285
// buildPower = 1 ;
18277: LD_ADDR_EXP 35
18281: PUSH
18282: LD_INT 1
18284: ST_TO_ADDR
// end ;
18285: PPOPN 8
18287: END
// on UpgradeComplete ( building ) do begin if GetBType ( building ) = b_factory and GetSide ( building ) = 1 and factoryDialog = 0 then
18288: LD_VAR 0 1
18292: PPUSH
18293: CALL_OW 266
18297: PUSH
18298: LD_INT 3
18300: EQUAL
18301: PUSH
18302: LD_VAR 0 1
18306: PPUSH
18307: CALL_OW 255
18311: PUSH
18312: LD_INT 1
18314: EQUAL
18315: AND
18316: PUSH
18317: LD_EXP 31
18321: PUSH
18322: LD_INT 0
18324: EQUAL
18325: AND
18326: IFFALSE 18674
// begin factoryDialog = 1 ;
18328: LD_ADDR_EXP 31
18332: PUSH
18333: LD_INT 1
18335: ST_TO_ADDR
// CenterNowOnUnits ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_btype , b_factory ] , [ f_lives , 1000 ] ] ) [ 1 ] ) ;
18336: LD_INT 22
18338: PUSH
18339: LD_INT 1
18341: PUSH
18342: EMPTY
18343: LIST
18344: LIST
18345: PUSH
18346: LD_INT 21
18348: PUSH
18349: LD_INT 3
18351: PUSH
18352: EMPTY
18353: LIST
18354: LIST
18355: PUSH
18356: LD_INT 30
18358: PUSH
18359: LD_INT 3
18361: PUSH
18362: EMPTY
18363: LIST
18364: LIST
18365: PUSH
18366: LD_INT 24
18368: PUSH
18369: LD_INT 1000
18371: PUSH
18372: EMPTY
18373: LIST
18374: LIST
18375: PUSH
18376: EMPTY
18377: LIST
18378: LIST
18379: LIST
18380: LIST
18381: PPUSH
18382: CALL_OW 69
18386: PUSH
18387: LD_INT 1
18389: ARRAY
18390: PPUSH
18391: CALL_OW 87
// if GetTech ( 47 , 1 ) = state_enabled and GetTech ( 45 , 1 ) = state_enabled then
18395: LD_INT 47
18397: PPUSH
18398: LD_INT 1
18400: PPUSH
18401: CALL_OW 321
18405: PUSH
18406: LD_INT 1
18408: EQUAL
18409: PUSH
18410: LD_INT 45
18412: PPUSH
18413: LD_INT 1
18415: PPUSH
18416: CALL_OW 321
18420: PUSH
18421: LD_INT 1
18423: EQUAL
18424: AND
18425: IFFALSE 18674
// begin Say ( JMM , D9a-JMM-1 ) ;
18427: LD_EXP 1
18431: PPUSH
18432: LD_STRING D9a-JMM-1
18434: PPUSH
18435: CALL_OW 88
// if IsOK ( Campell ) then
18439: LD_EXP 12
18443: PPUSH
18444: CALL_OW 302
18448: IFFALSE 18464
// begin Say ( Campell , D9a-Mech1-1 ) ;
18450: LD_EXP 12
18454: PPUSH
18455: LD_STRING D9a-Mech1-1
18457: PPUSH
18458: CALL_OW 88
// end else
18462: GO 18660
// begin ; if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , 3 ] , [ f_sex , 1 ] ] ) diff [ JMM ] > 0 then
18464: LD_INT 22
18466: PUSH
18467: LD_INT 1
18469: PUSH
18470: EMPTY
18471: LIST
18472: LIST
18473: PUSH
18474: LD_INT 21
18476: PUSH
18477: LD_INT 1
18479: PUSH
18480: EMPTY
18481: LIST
18482: LIST
18483: PUSH
18484: LD_INT 25
18486: PUSH
18487: LD_INT 3
18489: PUSH
18490: EMPTY
18491: LIST
18492: LIST
18493: PUSH
18494: LD_INT 26
18496: PUSH
18497: LD_INT 1
18499: PUSH
18500: EMPTY
18501: LIST
18502: LIST
18503: PUSH
18504: EMPTY
18505: LIST
18506: LIST
18507: LIST
18508: LIST
18509: PPUSH
18510: CALL_OW 69
18514: PUSH
18515: LD_EXP 1
18519: PUSH
18520: EMPTY
18521: LIST
18522: PUSH
18523: LD_INT 0
18525: GREATER
18526: DIFF
18527: IFFALSE 18601
// begin DialogRandom ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , 3 ] , [ f_sex , 1 ] ] ) diff [ JMM ] , D9a-Mech1-1 , D9a-Mech1-1 ) ;
18529: LD_INT 22
18531: PUSH
18532: LD_INT 1
18534: PUSH
18535: EMPTY
18536: LIST
18537: LIST
18538: PUSH
18539: LD_INT 21
18541: PUSH
18542: LD_INT 1
18544: PUSH
18545: EMPTY
18546: LIST
18547: LIST
18548: PUSH
18549: LD_INT 25
18551: PUSH
18552: LD_INT 3
18554: PUSH
18555: EMPTY
18556: LIST
18557: LIST
18558: PUSH
18559: LD_INT 26
18561: PUSH
18562: LD_INT 1
18564: PUSH
18565: EMPTY
18566: LIST
18567: LIST
18568: PUSH
18569: EMPTY
18570: LIST
18571: LIST
18572: LIST
18573: LIST
18574: PPUSH
18575: CALL_OW 69
18579: PUSH
18580: LD_EXP 1
18584: PUSH
18585: EMPTY
18586: LIST
18587: DIFF
18588: PPUSH
18589: LD_STRING D9a-Mech1-1
18591: PPUSH
18592: LD_STRING D9a-Mech1-1
18594: PPUSH
18595: CALL 4492 0 3
// end else
18599: GO 18660
// begin DialogRandom ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_sex , 1 ] ] ) diff [ JMM ] , D9a-Mech1-1 , D9a-Mech1-1 ) ;
18601: LD_INT 22
18603: PUSH
18604: LD_INT 1
18606: PUSH
18607: EMPTY
18608: LIST
18609: LIST
18610: PUSH
18611: LD_INT 21
18613: PUSH
18614: LD_INT 1
18616: PUSH
18617: EMPTY
18618: LIST
18619: LIST
18620: PUSH
18621: LD_INT 26
18623: PUSH
18624: LD_INT 1
18626: PUSH
18627: EMPTY
18628: LIST
18629: LIST
18630: PUSH
18631: EMPTY
18632: LIST
18633: LIST
18634: LIST
18635: PPUSH
18636: CALL_OW 69
18640: PUSH
18641: LD_EXP 1
18645: PUSH
18646: EMPTY
18647: LIST
18648: DIFF
18649: PPUSH
18650: LD_STRING D9a-Mech1-1
18652: PPUSH
18653: LD_STRING D9a-Mech1-1
18655: PPUSH
18656: CALL 4492 0 3
// end ; end ; if energyVDialog = 0 then
18660: LD_EXP 33
18664: PUSH
18665: LD_INT 0
18667: EQUAL
18668: IFFALSE 18674
// EnergyDialog ;
18670: CALL 4895 0 0
// end ; end ; end ;
18674: PPOPN 1
18676: END
// on UnitDestroyed ( unit ) do var mech ;
18677: LD_INT 0
18679: PPUSH
// begin if unit = JMM then
18680: LD_VAR 0 1
18684: PUSH
18685: LD_EXP 1
18689: EQUAL
18690: IFFALSE 18699
// YouLost ( JMM ) ;
18692: LD_STRING JMM
18694: PPUSH
18695: CALL_OW 104
// if unit in ruMobile then
18699: LD_VAR 0 1
18703: PUSH
18704: LD_EXP 46
18708: IN
18709: IFFALSE 18727
// ruMobile = ruMobile diff ruMobile ;
18711: LD_ADDR_EXP 46
18715: PUSH
18716: LD_EXP 46
18720: PUSH
18721: LD_EXP 46
18725: DIFF
18726: ST_TO_ADDR
// if GetType ( unit ) = unit_human and GetSide ( unit ) = 1 then
18727: LD_VAR 0 1
18731: PPUSH
18732: CALL_OW 247
18736: PUSH
18737: LD_INT 1
18739: EQUAL
18740: PUSH
18741: LD_VAR 0 1
18745: PPUSH
18746: CALL_OW 255
18750: PUSH
18751: LD_INT 1
18753: EQUAL
18754: AND
18755: IFFALSE 18771
// lostCounter = lostCounter + 1 ;
18757: LD_ADDR_EXP 38
18761: PUSH
18762: LD_EXP 38
18766: PUSH
18767: LD_INT 1
18769: PLUS
18770: ST_TO_ADDR
// if ruMech and UnitsInside ( rubfact0 ) < 6 and GetClass ( unit ) = 3 and GetSide ( unit ) = 3 and IsOK ( rubfact0 ) and GetSide ( rubfact0 ) = 3 then
18771: LD_EXP 43
18775: PUSH
18776: LD_INT 24
18778: PPUSH
18779: CALL_OW 313
18783: PUSH
18784: LD_INT 6
18786: LESS
18787: AND
18788: PUSH
18789: LD_VAR 0 1
18793: PPUSH
18794: CALL_OW 257
18798: PUSH
18799: LD_INT 3
18801: EQUAL
18802: AND
18803: PUSH
18804: LD_VAR 0 1
18808: PPUSH
18809: CALL_OW 255
18813: PUSH
18814: LD_INT 3
18816: EQUAL
18817: AND
18818: PUSH
18819: LD_INT 24
18821: PPUSH
18822: CALL_OW 302
18826: AND
18827: PUSH
18828: LD_INT 24
18830: PPUSH
18831: CALL_OW 255
18835: PUSH
18836: LD_INT 3
18838: EQUAL
18839: AND
18840: IFFALSE 18969
// begin ruMech := ruMech - 1 ;
18842: LD_ADDR_EXP 43
18846: PUSH
18847: LD_EXP 43
18851: PUSH
18852: LD_INT 1
18854: MINUS
18855: ST_TO_ADDR
// if ruMech = 0 then
18856: LD_EXP 43
18860: PUSH
18861: LD_INT 0
18863: EQUAL
18864: IFFALSE 18868
// exit ;
18866: GO 18969
// wait ( 0 0$40 ) ;
18868: LD_INT 1400
18870: PPUSH
18871: CALL_OW 67
// uc_side = 3 ;
18875: LD_ADDR_OWVAR 20
18879: PUSH
18880: LD_INT 3
18882: ST_TO_ADDR
// uc_nation = 3 ;
18883: LD_ADDR_OWVAR 21
18887: PUSH
18888: LD_INT 3
18890: ST_TO_ADDR
// hc_gallery :=  ;
18891: LD_ADDR_OWVAR 33
18895: PUSH
18896: LD_STRING 
18898: ST_TO_ADDR
// hc_name :=  ;
18899: LD_ADDR_OWVAR 26
18903: PUSH
18904: LD_STRING 
18906: ST_TO_ADDR
// PrepareMechanic ( false , rand ( RuSoldMinLevel , RuSoldMaxLevel ) ) ;
18907: LD_INT 0
18909: PPUSH
18910: LD_EXP 16
18914: PPUSH
18915: LD_EXP 17
18919: PPUSH
18920: CALL_OW 12
18924: PPUSH
18925: CALL_OW 383
// mech := CreateHuman ;
18929: LD_ADDR_VAR 0 2
18933: PUSH
18934: CALL_OW 44
18938: ST_TO_ADDR
// PlaceUnitXY ( mech , 124 , 97 , false ) ;
18939: LD_VAR 0 2
18943: PPUSH
18944: LD_INT 124
18946: PPUSH
18947: LD_INT 97
18949: PPUSH
18950: LD_INT 0
18952: PPUSH
18953: CALL_OW 48
// ComEnterUnit ( mech , rubfact0 ) ;
18957: LD_VAR 0 2
18961: PPUSH
18962: LD_INT 24
18964: PPUSH
18965: CALL_OW 120
// end ; end ;
18969: PPOPN 2
18971: END
// on Contact ( side1 , side2 ) do var i , tmp ;
18972: LD_INT 0
18974: PPUSH
18975: PPUSH
// begin tmp = FilterAllUnits ( [ f_side , 1 ] ) ;
18976: LD_ADDR_VAR 0 4
18980: PUSH
18981: LD_INT 22
18983: PUSH
18984: LD_INT 1
18986: PUSH
18987: EMPTY
18988: LIST
18989: LIST
18990: PPUSH
18991: CALL_OW 69
18995: ST_TO_ADDR
// if side1 = 1 and side2 = 6 and donaldsonCoopAttack = 1 then
18996: LD_VAR 0 1
19000: PUSH
19001: LD_INT 1
19003: EQUAL
19004: PUSH
19005: LD_VAR 0 2
19009: PUSH
19010: LD_INT 6
19012: EQUAL
19013: AND
19014: PUSH
19015: LD_EXP 41
19019: PUSH
19020: LD_INT 1
19022: EQUAL
19023: AND
19024: IFFALSE 19079
// begin donaldsonCoopAttack = 0 ;
19026: LD_ADDR_EXP 41
19030: PUSH
19031: LD_INT 0
19033: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 4 ] ] ) do
19034: LD_ADDR_VAR 0 3
19038: PUSH
19039: LD_INT 22
19041: PUSH
19042: LD_INT 4
19044: PUSH
19045: EMPTY
19046: LIST
19047: LIST
19048: PUSH
19049: EMPTY
19050: LIST
19051: PPUSH
19052: CALL_OW 69
19056: PUSH
19057: FOR_IN
19058: IFFALSE 19077
// ComAgressiveMove ( i , 52 , 64 ) ;
19060: LD_VAR 0 3
19064: PPUSH
19065: LD_INT 52
19067: PPUSH
19068: LD_INT 64
19070: PPUSH
19071: CALL_OW 114
19075: GO 19057
19077: POP
19078: POP
// end ; end ;
19079: PPOPN 4
19081: END
// on VehicleConstructed ( vehicle , building ) do var driver ;
19082: LD_INT 0
19084: PPUSH
// begin if GetSide ( vehicle ) = 1 then
19085: LD_VAR 0 1
19089: PPUSH
19090: CALL_OW 255
19094: PUSH
19095: LD_INT 1
19097: EQUAL
19098: IFFALSE 19114
// vehicleProduceCounter := vehicleProduceCounter + 1 ;
19100: LD_ADDR_EXP 42
19104: PUSH
19105: LD_EXP 42
19109: PUSH
19110: LD_INT 1
19112: PLUS
19113: ST_TO_ADDR
// if GetSide ( vehicle ) = 3 and GetWeapon ( vehicle ) in [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun ] then
19114: LD_VAR 0 1
19118: PPUSH
19119: CALL_OW 255
19123: PUSH
19124: LD_INT 3
19126: EQUAL
19127: PUSH
19128: LD_VAR 0 1
19132: PPUSH
19133: CALL_OW 264
19137: PUSH
19138: LD_INT 42
19140: PUSH
19141: LD_INT 43
19143: PUSH
19144: LD_INT 44
19146: PUSH
19147: EMPTY
19148: LIST
19149: LIST
19150: LIST
19151: IN
19152: AND
19153: IFFALSE 19171
// ruMobile := ruMobile union vehicle ;
19155: LD_ADDR_EXP 46
19159: PUSH
19160: LD_EXP 46
19164: PUSH
19165: LD_VAR 0 1
19169: UNION
19170: ST_TO_ADDR
// if GetWeapon ( vehicle ) = 53 then
19171: LD_VAR 0 1
19175: PPUSH
19176: CALL_OW 264
19180: PUSH
19181: LD_INT 53
19183: EQUAL
19184: IFFALSE 19320
// begin uc_side = 3 ;
19186: LD_ADDR_OWVAR 20
19190: PUSH
19191: LD_INT 3
19193: ST_TO_ADDR
// uc_nation = 3 ;
19194: LD_ADDR_OWVAR 21
19198: PUSH
19199: LD_INT 3
19201: ST_TO_ADDR
// PrepareMechanic ( false , RuSoldMaxLevel ) ;
19202: LD_INT 0
19204: PPUSH
19205: LD_EXP 17
19209: PPUSH
19210: CALL_OW 383
// driver := CreateHuman ;
19214: LD_ADDR_VAR 0 3
19218: PUSH
19219: CALL_OW 44
19223: ST_TO_ADDR
// PlaceHumanInUnit ( driver , building ) ;
19224: LD_VAR 0 3
19228: PPUSH
19229: LD_VAR 0 2
19233: PPUSH
19234: CALL_OW 52
// CutTreeInArea ( vehicle , TreesArea ) ;
19238: LD_VAR 0 1
19242: PPUSH
19243: LD_INT 21
19245: PPUSH
19246: CALL 5111 0 2
// repeat wait ( 0 0$1 ) ;
19250: LD_INT 35
19252: PPUSH
19253: CALL_OW 67
// until not HasTask ( vehicle ) ;
19257: LD_VAR 0 1
19261: PPUSH
19262: CALL_OW 314
19266: NOT
19267: IFFALSE 19250
// driver := IsDrivenBy ( vehicle ) ;
19269: LD_ADDR_VAR 0 3
19273: PUSH
19274: LD_VAR 0 1
19278: PPUSH
19279: CALL_OW 311
19283: ST_TO_ADDR
// AddComMoveXY ( driver , 104 , 73 ) ;
19284: LD_VAR 0 3
19288: PPUSH
19289: LD_INT 104
19291: PPUSH
19292: LD_INT 73
19294: PPUSH
19295: CALL_OW 171
// AddComExitVehicle ( driver ) ;
19299: LD_VAR 0 3
19303: PPUSH
19304: CALL_OW 181
// AddComEnterUnit ( driver , rubfact0 ) ;
19308: LD_VAR 0 3
19312: PPUSH
19313: LD_INT 24
19315: PPUSH
19316: CALL_OW 180
// end ; end ;
19320: PPOPN 3
19322: END
// on UnitGoesToRed ( unit ) do var i , tmpMeh ;
19323: LD_INT 0
19325: PPUSH
19326: PPUSH
// begin if GetSide ( unit ) = 3 and GetType ( unit ) = unit_vehicle then
19327: LD_VAR 0 1
19331: PPUSH
19332: CALL_OW 255
19336: PUSH
19337: LD_INT 3
19339: EQUAL
19340: PUSH
19341: LD_VAR 0 1
19345: PPUSH
19346: CALL_OW 247
19350: PUSH
19351: LD_INT 2
19353: EQUAL
19354: AND
19355: IFFALSE 19449
// if GetWeapon ( unit ) = 42 or GetWeapon ( unit ) = 43 or GetWeapon ( unit ) = 44 then
19357: LD_VAR 0 1
19361: PPUSH
19362: CALL_OW 264
19366: PUSH
19367: LD_INT 42
19369: EQUAL
19370: PUSH
19371: LD_VAR 0 1
19375: PPUSH
19376: CALL_OW 264
19380: PUSH
19381: LD_INT 43
19383: EQUAL
19384: OR
19385: PUSH
19386: LD_VAR 0 1
19390: PPUSH
19391: CALL_OW 264
19395: PUSH
19396: LD_INT 44
19398: EQUAL
19399: OR
19400: IFFALSE 19449
// AddComConstruct ( rubfact0 , GetChassis ( unit ) , GetEngine ( unit ) , GetControl ( unit ) , GetWeapon ( unit ) ) ;
19402: LD_INT 24
19404: PPUSH
19405: LD_VAR 0 1
19409: PPUSH
19410: CALL_OW 265
19414: PPUSH
19415: LD_VAR 0 1
19419: PPUSH
19420: CALL_OW 262
19424: PPUSH
19425: LD_VAR 0 1
19429: PPUSH
19430: CALL_OW 263
19434: PPUSH
19435: LD_VAR 0 1
19439: PPUSH
19440: CALL_OW 264
19444: PPUSH
19445: CALL_OW 185
// end ;
19449: PPOPN 3
19451: END
// on LeaveVehicle ( vehicle , human ) do begin if GetSide ( vehicle ) = 3 and GetSide ( human ) = 3 and IsOK ( rubfact0 ) and not IsOk ( vehicle ) then
19452: LD_VAR 0 1
19456: PPUSH
19457: CALL_OW 255
19461: PUSH
19462: LD_INT 3
19464: EQUAL
19465: PUSH
19466: LD_VAR 0 2
19470: PPUSH
19471: CALL_OW 255
19475: PUSH
19476: LD_INT 3
19478: EQUAL
19479: AND
19480: PUSH
19481: LD_INT 24
19483: PPUSH
19484: CALL_OW 302
19488: AND
19489: PUSH
19490: LD_VAR 0 1
19494: PPUSH
19495: CALL_OW 302
19499: NOT
19500: AND
19501: IFFALSE 19515
// ComEnterUnit ( human , rubfact0 ) ;
19503: LD_VAR 0 2
19507: PPUSH
19508: LD_INT 24
19510: PPUSH
19511: CALL_OW 120
// end ;
19515: PPOPN 2
19517: END
// on EnterBuilding ( b , un ) do begin if b = rubfact0 and GetLives ( un ) < 1000 then
19518: LD_VAR 0 1
19522: PUSH
19523: LD_INT 24
19525: EQUAL
19526: PUSH
19527: LD_VAR 0 2
19531: PPUSH
19532: CALL_OW 256
19536: PUSH
19537: LD_INT 1000
19539: LESS
19540: AND
19541: IFFALSE 19555
// SetLives ( un , 1000 ) ;
19543: LD_VAR 0 2
19547: PPUSH
19548: LD_INT 1000
19550: PPUSH
19551: CALL_OW 234
// end ;
19555: PPOPN 2
19557: END
// on Command ( comandid ) do var i , j , tmp ;
19558: LD_INT 0
19560: PPUSH
19561: PPUSH
19562: PPUSH
// begin SOS_Command ( comandid ) ;
19563: LD_VAR 0 1
19567: PPUSH
19568: CALL 27410 0 1
// if not FilterAllUnits ( [ f_side , 4 ] ) then
19572: LD_INT 22
19574: PUSH
19575: LD_INT 4
19577: PUSH
19578: EMPTY
19579: LIST
19580: LIST
19581: PPUSH
19582: CALL_OW 69
19586: NOT
19587: IFFALSE 19591
// exit ;
19589: GO 19756
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
19591: LD_ADDR_VAR 0 2
19595: PUSH
19596: LD_INT 22
19598: PUSH
19599: LD_INT 1
19601: PUSH
19602: EMPTY
19603: LIST
19604: LIST
19605: PUSH
19606: LD_INT 2
19608: PUSH
19609: LD_INT 21
19611: PUSH
19612: LD_INT 1
19614: PUSH
19615: EMPTY
19616: LIST
19617: LIST
19618: PUSH
19619: LD_INT 21
19621: PUSH
19622: LD_INT 2
19624: PUSH
19625: EMPTY
19626: LIST
19627: LIST
19628: PUSH
19629: EMPTY
19630: LIST
19631: LIST
19632: LIST
19633: PUSH
19634: EMPTY
19635: LIST
19636: LIST
19637: PPUSH
19638: CALL_OW 69
19642: PUSH
19643: FOR_IN
19644: IFFALSE 19754
// begin if GetTaskList ( i ) > 0 then
19646: LD_VAR 0 2
19650: PPUSH
19651: CALL_OW 437
19655: PUSH
19656: LD_INT 0
19658: GREATER
19659: IFFALSE 19752
// begin for j = 1 to GetTaskList ( i ) do
19661: LD_ADDR_VAR 0 3
19665: PUSH
19666: DOUBLE
19667: LD_INT 1
19669: DEC
19670: ST_TO_ADDR
19671: LD_VAR 0 2
19675: PPUSH
19676: CALL_OW 437
19680: PUSH
19681: FOR_TO
19682: IFFALSE 19750
// begin tmp = GetTaskList ( i ) [ j ] [ 4 ] ;
19684: LD_ADDR_VAR 0 4
19688: PUSH
19689: LD_VAR 0 2
19693: PPUSH
19694: CALL_OW 437
19698: PUSH
19699: LD_VAR 0 3
19703: ARRAY
19704: PUSH
19705: LD_INT 4
19707: ARRAY
19708: ST_TO_ADDR
// if ( GetSide ( tmp ) = 4 or GetSide ( tmp ) = 0 ) then
19709: LD_VAR 0 4
19713: PPUSH
19714: CALL_OW 255
19718: PUSH
19719: LD_INT 4
19721: EQUAL
19722: PUSH
19723: LD_VAR 0 4
19727: PPUSH
19728: CALL_OW 255
19732: PUSH
19733: LD_INT 0
19735: EQUAL
19736: OR
19737: IFFALSE 19748
// ComStop ( i ) ;
19739: LD_VAR 0 2
19743: PPUSH
19744: CALL_OW 141
// end ;
19748: GO 19681
19750: POP
19751: POP
// end ; end ;
19752: GO 19643
19754: POP
19755: POP
// end ; end_of_file
19756: PPOPN 4
19758: END
// every 10 10$0 do
19759: GO 19761
19761: DISABLE
// begin RespawnAttackInfantry ( 5 , 3 , 2 + [ 2 , 3 , 4 ] [ Difficulty ] , 0 , 0 , 0 , 0 , rand ( ruSoldMinLevel , ruSoldMaxLevel ) , RussianAttack , RussianAttackHeal , 1 , 2 ) ;
19762: LD_INT 5
19764: PPUSH
19765: LD_INT 3
19767: PPUSH
19768: LD_INT 2
19770: PUSH
19771: LD_INT 2
19773: PUSH
19774: LD_INT 3
19776: PUSH
19777: LD_INT 4
19779: PUSH
19780: EMPTY
19781: LIST
19782: LIST
19783: LIST
19784: PUSH
19785: LD_OWVAR 67
19789: ARRAY
19790: PLUS
19791: PPUSH
19792: LD_INT 0
19794: PPUSH
19795: LD_INT 0
19797: PPUSH
19798: LD_INT 0
19800: PPUSH
19801: LD_INT 0
19803: PPUSH
19804: LD_EXP 16
19808: PPUSH
19809: LD_EXP 17
19813: PPUSH
19814: CALL_OW 12
19818: PPUSH
19819: LD_INT 4
19821: PPUSH
19822: LD_INT 14
19824: PPUSH
19825: LD_INT 1
19827: PPUSH
19828: LD_INT 2
19830: PPUSH
19831: CALL 7816 0 12
// end ;
19835: END
// every 20 20$0 do
19836: GO 19838
19838: DISABLE
// begin RespawnAttackInfantry ( 5 , 3 , 4 + [ 2 , 3 , 4 ] [ Difficulty ] , 0 , 0 , 0 , 2 , rand ( ruSoldMinLevel , ruSoldMaxLevel ) , RussianAttack , RussianAttackHeal , 1 , 1 ) ;
19839: LD_INT 5
19841: PPUSH
19842: LD_INT 3
19844: PPUSH
19845: LD_INT 4
19847: PUSH
19848: LD_INT 2
19850: PUSH
19851: LD_INT 3
19853: PUSH
19854: LD_INT 4
19856: PUSH
19857: EMPTY
19858: LIST
19859: LIST
19860: LIST
19861: PUSH
19862: LD_OWVAR 67
19866: ARRAY
19867: PLUS
19868: PPUSH
19869: LD_INT 0
19871: PPUSH
19872: LD_INT 0
19874: PPUSH
19875: LD_INT 0
19877: PPUSH
19878: LD_INT 2
19880: PPUSH
19881: LD_EXP 16
19885: PPUSH
19886: LD_EXP 17
19890: PPUSH
19891: CALL_OW 12
19895: PPUSH
19896: LD_INT 4
19898: PPUSH
19899: LD_INT 14
19901: PPUSH
19902: LD_INT 1
19904: PPUSH
19905: LD_INT 1
19907: PPUSH
19908: CALL 7816 0 12
// end ;
19912: END
// every 25 25$0 do
19913: GO 19915
19915: DISABLE
// begin if Difficulty > 1 then
19916: LD_OWVAR 67
19920: PUSH
19921: LD_INT 1
19923: GREATER
19924: IFFALSE 19934
// specAttack := true ;
19926: LD_ADDR_EXP 47
19930: PUSH
19931: LD_INT 1
19933: ST_TO_ADDR
// RespawnAttackVehicle ( RussianAttack , 5 , [ 4 , 5 , 6 ] [ Difficulty ] , rand ( ruSoldMinLevel , ruSoldMaxLevel ) , 3 , 1 , 1 , [ [ 42 , 42 , 43 ] , [ 42 , 43 ] , [ 43 , 43 , 43 , 44 ] ] [ Difficulty ] , [ ] , [ ] , 1 ) ;
19934: LD_INT 4
19936: PPUSH
19937: LD_INT 5
19939: PPUSH
19940: LD_INT 4
19942: PUSH
19943: LD_INT 5
19945: PUSH
19946: LD_INT 6
19948: PUSH
19949: EMPTY
19950: LIST
19951: LIST
19952: LIST
19953: PUSH
19954: LD_OWVAR 67
19958: ARRAY
19959: PPUSH
19960: LD_EXP 16
19964: PPUSH
19965: LD_EXP 17
19969: PPUSH
19970: CALL_OW 12
19974: PPUSH
19975: LD_INT 3
19977: PPUSH
19978: LD_INT 1
19980: PPUSH
19981: LD_INT 1
19983: PPUSH
19984: LD_INT 42
19986: PUSH
19987: LD_INT 42
19989: PUSH
19990: LD_INT 43
19992: PUSH
19993: EMPTY
19994: LIST
19995: LIST
19996: LIST
19997: PUSH
19998: LD_INT 42
20000: PUSH
20001: LD_INT 43
20003: PUSH
20004: EMPTY
20005: LIST
20006: LIST
20007: PUSH
20008: LD_INT 43
20010: PUSH
20011: LD_INT 43
20013: PUSH
20014: LD_INT 43
20016: PUSH
20017: LD_INT 44
20019: PUSH
20020: EMPTY
20021: LIST
20022: LIST
20023: LIST
20024: LIST
20025: PUSH
20026: EMPTY
20027: LIST
20028: LIST
20029: LIST
20030: PUSH
20031: LD_OWVAR 67
20035: ARRAY
20036: PPUSH
20037: EMPTY
20038: PPUSH
20039: EMPTY
20040: PPUSH
20041: LD_INT 1
20043: PPUSH
20044: CALL 9572 0 11
// end ;
20048: END
// every 0 0$1 trigger specAttack do var un , tmp , i , eng ;
20049: LD_EXP 47
20053: IFFALSE 20416
20055: GO 20057
20057: DISABLE
20058: LD_INT 0
20060: PPUSH
20061: PPUSH
20062: PPUSH
20063: PPUSH
// begin wait ( 0 0$20 ) ;
20064: LD_INT 700
20066: PPUSH
20067: CALL_OW 67
// uc_side := 5 ;
20071: LD_ADDR_OWVAR 20
20075: PUSH
20076: LD_INT 5
20078: ST_TO_ADDR
// uc_nation := 3 ;
20079: LD_ADDR_OWVAR 21
20083: PUSH
20084: LD_INT 3
20086: ST_TO_ADDR
// InitHc ;
20087: CALL_OW 19
// hc_importance := 0 ;
20091: LD_ADDR_OWVAR 32
20095: PUSH
20096: LD_INT 0
20098: ST_TO_ADDR
// tmp := [ ] ;
20099: LD_ADDR_VAR 0 2
20103: PUSH
20104: EMPTY
20105: ST_TO_ADDR
// PrepareHuman ( false , 2 , 6 ) ;
20106: LD_INT 0
20108: PPUSH
20109: LD_INT 2
20111: PPUSH
20112: LD_INT 6
20114: PPUSH
20115: CALL_OW 380
// eng := CreateHuman ;
20119: LD_ADDR_VAR 0 4
20123: PUSH
20124: CALL_OW 44
20128: ST_TO_ADDR
// PlaceUnitXYR ( eng , 78 , 2 , 4 , false ) ;
20129: LD_VAR 0 4
20133: PPUSH
20134: LD_INT 78
20136: PPUSH
20137: LD_INT 2
20139: PPUSH
20140: LD_INT 4
20142: PPUSH
20143: LD_INT 0
20145: PPUSH
20146: CALL_OW 50
// for i = 1 to 2 + Difficulty do
20150: LD_ADDR_VAR 0 3
20154: PUSH
20155: DOUBLE
20156: LD_INT 1
20158: DEC
20159: ST_TO_ADDR
20160: LD_INT 2
20162: PUSH
20163: LD_OWVAR 67
20167: PLUS
20168: PUSH
20169: FOR_TO
20170: IFFALSE 20251
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
20172: LD_INT 0
20174: PPUSH
20175: LD_INT 1
20177: PPUSH
20178: LD_INT 4
20180: PUSH
20181: LD_INT 5
20183: PUSH
20184: LD_INT 6
20186: PUSH
20187: EMPTY
20188: LIST
20189: LIST
20190: LIST
20191: PUSH
20192: LD_OWVAR 67
20196: ARRAY
20197: PPUSH
20198: CALL_OW 380
// un := CreateHuman ;
20202: LD_ADDR_VAR 0 1
20206: PUSH
20207: CALL_OW 44
20211: ST_TO_ADDR
// PlaceUnitXYR ( un , 78 , 2 , 4 , false ) ;
20212: LD_VAR 0 1
20216: PPUSH
20217: LD_INT 78
20219: PPUSH
20220: LD_INT 2
20222: PPUSH
20223: LD_INT 4
20225: PPUSH
20226: LD_INT 0
20228: PPUSH
20229: CALL_OW 50
// tmp := tmp ^ un ;
20233: LD_ADDR_VAR 0 2
20237: PUSH
20238: LD_VAR 0 2
20242: PUSH
20243: LD_VAR 0 1
20247: ADD
20248: ST_TO_ADDR
// end ;
20249: GO 20169
20251: POP
20252: POP
// ComMoveXY ( tmp , 49 , 3 ) ;
20253: LD_VAR 0 2
20257: PPUSH
20258: LD_INT 49
20260: PPUSH
20261: LD_INT 3
20263: PPUSH
20264: CALL_OW 111
// wait ( 0 0$2 ) ;
20268: LD_INT 70
20270: PPUSH
20271: CALL_OW 67
// ComMoveXY ( eng , 49 , 3 ) ;
20275: LD_VAR 0 4
20279: PPUSH
20280: LD_INT 49
20282: PPUSH
20283: LD_INT 3
20285: PPUSH
20286: CALL_OW 111
// AddComDismantle ( eng , ambdept0 ) ;
20290: LD_VAR 0 4
20294: PPUSH
20295: LD_INT 4
20297: PPUSH
20298: CALL_OW 227
// wait ( 0 0$10 ) ;
20302: LD_INT 350
20304: PPUSH
20305: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
20309: LD_INT 35
20311: PPUSH
20312: CALL_OW 67
// for i in tmp do
20316: LD_ADDR_VAR 0 3
20320: PUSH
20321: LD_VAR 0 2
20325: PUSH
20326: FOR_IN
20327: IFFALSE 20407
// if not IsOk ( i ) then
20329: LD_VAR 0 3
20333: PPUSH
20334: CALL_OW 302
20338: NOT
20339: IFFALSE 20359
// tmp := tmp diff i else
20341: LD_ADDR_VAR 0 2
20345: PUSH
20346: LD_VAR 0 2
20350: PUSH
20351: LD_VAR 0 3
20355: DIFF
20356: ST_TO_ADDR
20357: GO 20405
// if not HasTask ( i ) then
20359: LD_VAR 0 3
20363: PPUSH
20364: CALL_OW 314
20368: NOT
20369: IFFALSE 20405
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
20371: LD_VAR 0 3
20375: PPUSH
20376: LD_INT 22
20378: PUSH
20379: LD_INT 1
20381: PUSH
20382: EMPTY
20383: LIST
20384: LIST
20385: PPUSH
20386: CALL_OW 69
20390: PPUSH
20391: LD_VAR 0 3
20395: PPUSH
20396: CALL_OW 74
20400: PPUSH
20401: CALL_OW 115
20405: GO 20326
20407: POP
20408: POP
// until not tmp ;
20409: LD_VAR 0 2
20413: NOT
20414: IFFALSE 20309
// end ; end_of_file
20416: PPOPN 4
20418: END
// every 0 0$1 trigger startTimer = 1 do
20419: LD_EXP 30
20423: PUSH
20424: LD_INT 1
20426: EQUAL
20427: IFFALSE 20557
20429: GO 20431
20431: DISABLE
// begin enable ;
20432: ENABLE
// if timerStatus = 1 then
20433: LD_EXP 29
20437: PUSH
20438: LD_INT 1
20440: EQUAL
20441: IFFALSE 20474
// begin timeToSupport = timeToSupport - 0 0$01 ;
20443: LD_ADDR_EXP 28
20447: PUSH
20448: LD_EXP 28
20452: PUSH
20453: LD_INT 35
20455: MINUS
20456: ST_TO_ADDR
// display_strings = [ #Am04-1 , timeToSupport ] ;
20457: LD_ADDR_OWVAR 47
20461: PUSH
20462: LD_STRING #Am04-1
20464: PUSH
20465: LD_EXP 28
20469: PUSH
20470: EMPTY
20471: LIST
20472: LIST
20473: ST_TO_ADDR
// end ; if timerStatus = 2 then
20474: LD_EXP 29
20478: PUSH
20479: LD_INT 2
20481: EQUAL
20482: IFFALSE 20515
// begin timeToSupport = timeToSupport - 0 0$01 ;
20484: LD_ADDR_EXP 28
20488: PUSH
20489: LD_EXP 28
20493: PUSH
20494: LD_INT 35
20496: MINUS
20497: ST_TO_ADDR
// display_strings = [ #Am04-2 , timeToSupport ] ;
20498: LD_ADDR_OWVAR 47
20502: PUSH
20503: LD_STRING #Am04-2
20505: PUSH
20506: LD_EXP 28
20510: PUSH
20511: EMPTY
20512: LIST
20513: LIST
20514: ST_TO_ADDR
// end ; if timerStatus = 3 then
20515: LD_EXP 29
20519: PUSH
20520: LD_INT 3
20522: EQUAL
20523: IFFALSE 20539
// begin timeToDestroyRuBase = timeToDestroyRuBase - 0 0$01 ;
20525: LD_ADDR_EXP 27
20529: PUSH
20530: LD_EXP 27
20534: PUSH
20535: LD_INT 35
20537: MINUS
20538: ST_TO_ADDR
// end ; if timerStatus = 4 then
20539: LD_EXP 29
20543: PUSH
20544: LD_INT 4
20546: EQUAL
20547: IFFALSE 20557
// begin display_strings =  ;
20549: LD_ADDR_OWVAR 47
20553: PUSH
20554: LD_STRING 
20556: ST_TO_ADDR
// end ; end ; end_of_file
20557: END
// every 0 0$1 trigger IsDead ( ambdept0 ) do
20558: LD_INT 4
20560: PPUSH
20561: CALL_OW 301
20565: IFFALSE 20577
20567: GO 20569
20569: DISABLE
// YouLost ( Base ) ; end_of_file
20570: LD_STRING Base
20572: PPUSH
20573: CALL_OW 104
20577: END
// every 0 0$1 trigger IsDead ( Stolypin ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) < [ 14 , 13 , 12 ] [ Difficulty ] do var i , p ;
20578: LD_EXP 15
20582: PPUSH
20583: CALL_OW 301
20587: PUSH
20588: LD_INT 22
20590: PUSH
20591: LD_INT 3
20593: PUSH
20594: EMPTY
20595: LIST
20596: LIST
20597: PUSH
20598: LD_INT 21
20600: PUSH
20601: LD_INT 1
20603: PUSH
20604: EMPTY
20605: LIST
20606: LIST
20607: PUSH
20608: EMPTY
20609: LIST
20610: LIST
20611: PPUSH
20612: CALL_OW 69
20616: PUSH
20617: LD_INT 14
20619: PUSH
20620: LD_INT 13
20622: PUSH
20623: LD_INT 12
20625: PUSH
20626: EMPTY
20627: LIST
20628: LIST
20629: LIST
20630: PUSH
20631: LD_OWVAR 67
20635: ARRAY
20636: LESS
20637: AND
20638: IFFALSE 21170
20640: GO 20642
20642: DISABLE
20643: LD_INT 0
20645: PPUSH
20646: PPUSH
// begin AIEnable = 0 ;
20647: LD_ADDR_EXP 37
20651: PUSH
20652: LD_INT 0
20654: ST_TO_ADDR
// escapeAvalaible = 1 ;
20655: LD_ADDR_EXP 40
20659: PUSH
20660: LD_INT 1
20662: ST_TO_ADDR
// InGameOn ;
20663: CALL_OW 8
// SetAttitude ( 3 , 1 , att_friend , false ) ;
20667: LD_INT 3
20669: PPUSH
20670: LD_INT 1
20672: PPUSH
20673: LD_INT 1
20675: PPUSH
20676: LD_INT 0
20678: PPUSH
20679: CALL_OW 80
// SetAttitude ( 6 , 1 , att_friend , false ) ;
20683: LD_INT 6
20685: PPUSH
20686: LD_INT 1
20688: PPUSH
20689: LD_INT 1
20691: PPUSH
20692: LD_INT 0
20694: PPUSH
20695: CALL_OW 80
// SetAttitude ( 5 , 1 , att_friend , false ) ;
20699: LD_INT 5
20701: PPUSH
20702: LD_INT 1
20704: PPUSH
20705: LD_INT 1
20707: PPUSH
20708: LD_INT 0
20710: PPUSH
20711: CALL_OW 80
// ChangeSideFog ( 3 , 1 ) ;
20715: LD_INT 3
20717: PPUSH
20718: LD_INT 1
20720: PPUSH
20721: CALL_OW 343
// CenterOnXY ( 97 , 91 ) ;
20725: LD_INT 97
20727: PPUSH
20728: LD_INT 91
20730: PPUSH
20731: CALL_OW 84
// ComExitVehicle ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
20735: LD_INT 22
20737: PUSH
20738: LD_INT 3
20740: PUSH
20741: EMPTY
20742: LIST
20743: LIST
20744: PUSH
20745: LD_INT 21
20747: PUSH
20748: LD_INT 1
20750: PUSH
20751: EMPTY
20752: LIST
20753: LIST
20754: PUSH
20755: EMPTY
20756: LIST
20757: LIST
20758: PPUSH
20759: CALL_OW 69
20763: PPUSH
20764: CALL_OW 121
// wait ( 0 0$01 ) ;
20768: LD_INT 35
20770: PPUSH
20771: CALL_OW 67
// AddComMoveXY ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , 124 , 98 ) ;
20775: LD_INT 22
20777: PUSH
20778: LD_INT 3
20780: PUSH
20781: EMPTY
20782: LIST
20783: LIST
20784: PUSH
20785: LD_INT 21
20787: PUSH
20788: LD_INT 1
20790: PUSH
20791: EMPTY
20792: LIST
20793: LIST
20794: PUSH
20795: EMPTY
20796: LIST
20797: LIST
20798: PPUSH
20799: CALL_OW 69
20803: PPUSH
20804: LD_INT 124
20806: PPUSH
20807: LD_INT 98
20809: PPUSH
20810: CALL_OW 171
// ComExitVehicle ( FilterAllUnits ( [ [ f_side , 5 ] , [ f_type , unit_human ] ] ) ) ;
20814: LD_INT 22
20816: PUSH
20817: LD_INT 5
20819: PUSH
20820: EMPTY
20821: LIST
20822: LIST
20823: PUSH
20824: LD_INT 21
20826: PUSH
20827: LD_INT 1
20829: PUSH
20830: EMPTY
20831: LIST
20832: LIST
20833: PUSH
20834: EMPTY
20835: LIST
20836: LIST
20837: PPUSH
20838: CALL_OW 69
20842: PPUSH
20843: CALL_OW 121
// wait ( 0 0$01 ) ;
20847: LD_INT 35
20849: PPUSH
20850: CALL_OW 67
// AddComMoveXY ( FilterAllUnits ( [ [ f_side , 5 ] , [ f_type , unit_human ] ] ) , 124 , 98 ) ;
20854: LD_INT 22
20856: PUSH
20857: LD_INT 5
20859: PUSH
20860: EMPTY
20861: LIST
20862: LIST
20863: PUSH
20864: LD_INT 21
20866: PUSH
20867: LD_INT 1
20869: PUSH
20870: EMPTY
20871: LIST
20872: LIST
20873: PUSH
20874: EMPTY
20875: LIST
20876: LIST
20877: PPUSH
20878: CALL_OW 69
20882: PPUSH
20883: LD_INT 124
20885: PPUSH
20886: LD_INT 98
20888: PPUSH
20889: CALL_OW 171
// ComExitVehicle ( FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] ] ) ) ;
20893: LD_INT 22
20895: PUSH
20896: LD_INT 6
20898: PUSH
20899: EMPTY
20900: LIST
20901: LIST
20902: PUSH
20903: LD_INT 21
20905: PUSH
20906: LD_INT 1
20908: PUSH
20909: EMPTY
20910: LIST
20911: LIST
20912: PUSH
20913: EMPTY
20914: LIST
20915: LIST
20916: PPUSH
20917: CALL_OW 69
20921: PPUSH
20922: CALL_OW 121
// wait ( 0 0$01 ) ;
20926: LD_INT 35
20928: PPUSH
20929: CALL_OW 67
// AddComMoveXY ( FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] ] ) , 124 , 98 ) ;
20933: LD_INT 22
20935: PUSH
20936: LD_INT 6
20938: PUSH
20939: EMPTY
20940: LIST
20941: LIST
20942: PUSH
20943: LD_INT 21
20945: PUSH
20946: LD_INT 1
20948: PUSH
20949: EMPTY
20950: LIST
20951: LIST
20952: PUSH
20953: EMPTY
20954: LIST
20955: LIST
20956: PPUSH
20957: CALL_OW 69
20961: PPUSH
20962: LD_INT 124
20964: PPUSH
20965: LD_INT 98
20967: PPUSH
20968: CALL_OW 171
// ComAgressiveMove ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) , 124 , 96 ) ;
20972: LD_INT 22
20974: PUSH
20975: LD_INT 1
20977: PUSH
20978: EMPTY
20979: LIST
20980: LIST
20981: PUSH
20982: LD_INT 21
20984: PUSH
20985: LD_INT 1
20987: PUSH
20988: EMPTY
20989: LIST
20990: LIST
20991: PUSH
20992: EMPTY
20993: LIST
20994: LIST
20995: PPUSH
20996: CALL_OW 69
21000: PPUSH
21001: LD_INT 124
21003: PPUSH
21004: LD_INT 96
21006: PPUSH
21007: CALL_OW 114
// wait ( 0 0$1 ) ;
21011: LD_INT 35
21013: PPUSH
21014: CALL_OW 67
// CenterOnXY ( 124 , 96 ) ;
21018: LD_INT 124
21020: PPUSH
21021: LD_INT 96
21023: PPUSH
21024: CALL_OW 84
// p := 0 0$0 ;
21028: LD_ADDR_VAR 0 2
21032: PUSH
21033: LD_INT 0
21035: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
21036: LD_INT 35
21038: PPUSH
21039: CALL_OW 67
// p := p + 0 0$1 ;
21043: LD_ADDR_VAR 0 2
21047: PUSH
21048: LD_VAR 0 2
21052: PUSH
21053: LD_INT 35
21055: PLUS
21056: ST_TO_ADDR
// ComMoveToArea ( FilterAllUnits ( [ [ f_or , [ f_side , 3 ] , [ f_side , 6 ] ] , [ f_type , unit_human ] ] ) , RussianEscape ) ;
21057: LD_INT 2
21059: PUSH
21060: LD_INT 22
21062: PUSH
21063: LD_INT 3
21065: PUSH
21066: EMPTY
21067: LIST
21068: LIST
21069: PUSH
21070: LD_INT 22
21072: PUSH
21073: LD_INT 6
21075: PUSH
21076: EMPTY
21077: LIST
21078: LIST
21079: PUSH
21080: EMPTY
21081: LIST
21082: LIST
21083: LIST
21084: PUSH
21085: LD_INT 21
21087: PUSH
21088: LD_INT 1
21090: PUSH
21091: EMPTY
21092: LIST
21093: LIST
21094: PUSH
21095: EMPTY
21096: LIST
21097: LIST
21098: PPUSH
21099: CALL_OW 69
21103: PPUSH
21104: LD_INT 5
21106: PPUSH
21107: CALL_OW 113
// until FilterAllUnits ( [ [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_lives , 250 ] ] ) = 0 or p >= 0 0$7 ;
21111: LD_INT 23
21113: PUSH
21114: LD_INT 3
21116: PUSH
21117: EMPTY
21118: LIST
21119: LIST
21120: PUSH
21121: LD_INT 21
21123: PUSH
21124: LD_INT 1
21126: PUSH
21127: EMPTY
21128: LIST
21129: LIST
21130: PUSH
21131: LD_INT 24
21133: PUSH
21134: LD_INT 250
21136: PUSH
21137: EMPTY
21138: LIST
21139: LIST
21140: PUSH
21141: EMPTY
21142: LIST
21143: LIST
21144: LIST
21145: PPUSH
21146: CALL_OW 69
21150: PUSH
21151: LD_INT 0
21153: EQUAL
21154: PUSH
21155: LD_VAR 0 2
21159: PUSH
21160: LD_INT 245
21162: GREATEREQUAL
21163: OR
21164: IFFALSE 21036
// FinishMission ;
21166: CALL 21252 0 0
// end ;
21170: PPOPN 2
21172: END
// every 0 0$01 trigger escapeAvalaible do var i ;
21173: LD_EXP 40
21177: IFFALSE 21249
21179: GO 21181
21181: DISABLE
21182: LD_INT 0
21184: PPUSH
// begin enable ;
21185: ENABLE
// for i in FilterUnitsInArea ( RussianEscape , [ [ f_not , [ f_side , 1 ] ] , [ f_not , [ f_empty ] ] ] ) do
21186: LD_ADDR_VAR 0 1
21190: PUSH
21191: LD_INT 5
21193: PPUSH
21194: LD_INT 3
21196: PUSH
21197: LD_INT 22
21199: PUSH
21200: LD_INT 1
21202: PUSH
21203: EMPTY
21204: LIST
21205: LIST
21206: PUSH
21207: EMPTY
21208: LIST
21209: LIST
21210: PUSH
21211: LD_INT 3
21213: PUSH
21214: LD_INT 58
21216: PUSH
21217: EMPTY
21218: LIST
21219: PUSH
21220: EMPTY
21221: LIST
21222: LIST
21223: PUSH
21224: EMPTY
21225: LIST
21226: LIST
21227: PPUSH
21228: CALL_OW 70
21232: PUSH
21233: FOR_IN
21234: IFFALSE 21247
// RemoveUnit ( i ) ;
21236: LD_VAR 0 1
21240: PPUSH
21241: CALL_OW 64
21245: GO 21233
21247: POP
21248: POP
// end ;
21249: PPOPN 1
21251: END
// export function FinishMission ; var tmp , m1 , m2 , m3 ; begin
21252: LD_INT 0
21254: PPUSH
21255: PPUSH
21256: PPUSH
21257: PPUSH
21258: PPUSH
// if not vehicleProduceCounter then
21259: LD_EXP 42
21263: NOT
21264: IFFALSE 21273
// SetAchievement ( ACH_INFANTRY ) ;
21266: LD_STRING ACH_INFANTRY
21268: PPUSH
21269: CALL_OW 543
// if tick <= 20 20$00 then
21273: LD_OWVAR 1
21277: PUSH
21278: LD_INT 42000
21280: LESSEQUAL
21281: IFFALSE 21297
// begin wait ( 3 ) ;
21283: LD_INT 3
21285: PPUSH
21286: CALL_OW 67
// SetAchievement ( ACH_ASPEED_4 ) ;
21290: LD_STRING ACH_ASPEED_4
21292: PPUSH
21293: CALL_OW 543
// end ; SaveBase ( GammBaseArea ) ;
21297: LD_INT 22
21299: PPUSH
21300: CALL 21939 0 1
// SaveVariable ( GetTech ( tech_gatling , 1 ) , GatlingInGamma ) ;
21304: LD_INT 69
21306: PPUSH
21307: LD_INT 1
21309: PPUSH
21310: CALL_OW 321
21314: PPUSH
21315: LD_STRING GatlingInGamma
21317: PPUSH
21318: CALL_OW 39
// m1 := false ;
21322: LD_ADDR_VAR 0 3
21326: PUSH
21327: LD_INT 0
21329: ST_TO_ADDR
// m2 := false ;
21330: LD_ADDR_VAR 0 4
21334: PUSH
21335: LD_INT 0
21337: ST_TO_ADDR
// m3 := false ;
21338: LD_ADDR_VAR 0 5
21342: PUSH
21343: LD_INT 0
21345: ST_TO_ADDR
// if buildOil = 1 and buildPower = 1 then
21346: LD_EXP 34
21350: PUSH
21351: LD_INT 1
21353: EQUAL
21354: PUSH
21355: LD_EXP 35
21359: PUSH
21360: LD_INT 1
21362: EQUAL
21363: AND
21364: IFFALSE 21386
// begin AddMedal ( oil , 1 ) ;
21366: LD_STRING oil
21368: PPUSH
21369: LD_INT 1
21371: PPUSH
21372: CALL_OW 101
// m1 := true ;
21376: LD_ADDR_VAR 0 3
21380: PUSH
21381: LD_INT 1
21383: ST_TO_ADDR
// end else
21384: GO 21479
// begin if buildOil = 1 and buildPower = 0 then
21386: LD_EXP 34
21390: PUSH
21391: LD_INT 1
21393: EQUAL
21394: PUSH
21395: LD_EXP 35
21399: PUSH
21400: LD_INT 0
21402: EQUAL
21403: AND
21404: IFFALSE 21417
// AddMedal ( oil , - 1 ) ;
21406: LD_STRING oil
21408: PPUSH
21409: LD_INT 1
21411: NEG
21412: PPUSH
21413: CALL_OW 101
// if buildOil = 0 and buildPower = 1 then
21417: LD_EXP 34
21421: PUSH
21422: LD_INT 0
21424: EQUAL
21425: PUSH
21426: LD_EXP 35
21430: PUSH
21431: LD_INT 1
21433: EQUAL
21434: AND
21435: IFFALSE 21448
// AddMedal ( oil , - 2 ) ;
21437: LD_STRING oil
21439: PPUSH
21440: LD_INT 2
21442: NEG
21443: PPUSH
21444: CALL_OW 101
// if buildOil = 0 and buildPower = 0 then
21448: LD_EXP 34
21452: PUSH
21453: LD_INT 0
21455: EQUAL
21456: PUSH
21457: LD_EXP 35
21461: PUSH
21462: LD_INT 0
21464: EQUAL
21465: AND
21466: IFFALSE 21479
// AddMedal ( oil , - 3 ) ;
21468: LD_STRING oil
21470: PPUSH
21471: LD_INT 3
21473: NEG
21474: PPUSH
21475: CALL_OW 101
// end ; if lostCounter > 3 then
21479: LD_EXP 38
21483: PUSH
21484: LD_INT 3
21486: GREATER
21487: IFFALSE 21502
// AddMedal ( deaths , - 1 ) else
21489: LD_STRING deaths
21491: PPUSH
21492: LD_INT 1
21494: NEG
21495: PPUSH
21496: CALL_OW 101
21500: GO 21520
// begin AddMedal ( deaths , 1 ) ;
21502: LD_STRING deaths
21504: PPUSH
21505: LD_INT 1
21507: PPUSH
21508: CALL_OW 101
// m2 := true ;
21512: LD_ADDR_VAR 0 4
21516: PUSH
21517: LD_INT 1
21519: ST_TO_ADDR
// end ; if honor = 1 then
21520: LD_EXP 39
21524: PUSH
21525: LD_INT 1
21527: EQUAL
21528: IFFALSE 21550
// begin AddMedal ( honour , 1 ) ;
21530: LD_STRING honour
21532: PPUSH
21533: LD_INT 1
21535: PPUSH
21536: CALL_OW 101
// m3 := true ;
21540: LD_ADDR_VAR 0 5
21544: PUSH
21545: LD_INT 1
21547: ST_TO_ADDR
// end else
21548: GO 21561
// begin AddMedal ( honour , - 1 ) ;
21550: LD_STRING honour
21552: PPUSH
21553: LD_INT 1
21555: NEG
21556: PPUSH
21557: CALL_OW 101
// end ; if m1 and m2 and m3 and Difficulty = 3 then
21561: LD_VAR 0 3
21565: PUSH
21566: LD_VAR 0 4
21570: AND
21571: PUSH
21572: LD_VAR 0 5
21576: AND
21577: PUSH
21578: LD_OWVAR 67
21582: PUSH
21583: LD_INT 3
21585: EQUAL
21586: AND
21587: IFFALSE 21599
// SetAchievementEX ( ACH_AMER , 4 ) ;
21589: LD_STRING ACH_AMER
21591: PPUSH
21592: LD_INT 4
21594: PPUSH
21595: CALL_OW 564
// GiveMedals ( Main ) ;
21599: LD_STRING Main
21601: PPUSH
21602: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_type , unit_human ] ] ) ) ;
21606: LD_INT 22
21608: PUSH
21609: LD_INT 1
21611: PUSH
21612: EMPTY
21613: LIST
21614: LIST
21615: PUSH
21616: LD_INT 23
21618: PUSH
21619: LD_INT 1
21621: PUSH
21622: EMPTY
21623: LIST
21624: LIST
21625: PUSH
21626: LD_INT 21
21628: PUSH
21629: LD_INT 1
21631: PUSH
21632: EMPTY
21633: LIST
21634: LIST
21635: PUSH
21636: EMPTY
21637: LIST
21638: LIST
21639: LIST
21640: PPUSH
21641: CALL_OW 69
21645: PPUSH
21646: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
21650: LD_EXP 1
21654: PPUSH
21655: LD_EXP 48
21659: PUSH
21660: LD_STRING JMM
21662: STR
21663: PPUSH
21664: CALL_OW 38
// if IsOK ( Bobby ) then
21668: LD_EXP 2
21672: PPUSH
21673: CALL_OW 302
21677: IFFALSE 21697
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
21679: LD_EXP 2
21683: PPUSH
21684: LD_EXP 48
21688: PUSH
21689: LD_STRING Bobby
21691: STR
21692: PPUSH
21693: CALL_OW 38
// if IsOK ( Cyrus ) then
21697: LD_EXP 3
21701: PPUSH
21702: CALL_OW 302
21706: IFFALSE 21726
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
21708: LD_EXP 3
21712: PPUSH
21713: LD_EXP 48
21717: PUSH
21718: LD_STRING Cyrus
21720: STR
21721: PPUSH
21722: CALL_OW 38
// if IsOK ( Lisa ) then
21726: LD_EXP 4
21730: PPUSH
21731: CALL_OW 302
21735: IFFALSE 21755
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
21737: LD_EXP 4
21741: PPUSH
21742: LD_EXP 48
21746: PUSH
21747: LD_STRING Lisa
21749: STR
21750: PPUSH
21751: CALL_OW 38
// if IsOK ( Brown ) then
21755: LD_EXP 7
21759: PPUSH
21760: CALL_OW 302
21764: IFFALSE 21784
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
21766: LD_EXP 7
21770: PPUSH
21771: LD_EXP 48
21775: PUSH
21776: LD_STRING Brown
21778: STR
21779: PPUSH
21780: CALL_OW 38
// if IsOK ( Donaldson ) then
21784: LD_EXP 13
21788: PPUSH
21789: CALL_OW 302
21793: IFFALSE 21813
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
21795: LD_EXP 13
21799: PPUSH
21800: LD_EXP 48
21804: PUSH
21805: LD_STRING Donaldson
21807: STR
21808: PPUSH
21809: CALL_OW 38
// if IsOK ( Frank ) then
21813: LD_EXP 5
21817: PPUSH
21818: CALL_OW 302
21822: IFFALSE 21842
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
21824: LD_EXP 5
21828: PPUSH
21829: LD_EXP 48
21833: PUSH
21834: LD_STRING Frank
21836: STR
21837: PPUSH
21838: CALL_OW 38
// SaveCharacters ( FilterAllUnits ( [ [ f_ok ] , [ f_side , 1 ] , [ f_type , unit_human ] ] ) diff [ JMM , Bobby , Cyrus , Lisa , Brown , Donaldson , Frank ] , 04_other_survivors ) ;
21842: LD_INT 50
21844: PUSH
21845: EMPTY
21846: LIST
21847: PUSH
21848: LD_INT 22
21850: PUSH
21851: LD_INT 1
21853: PUSH
21854: EMPTY
21855: LIST
21856: LIST
21857: PUSH
21858: LD_INT 21
21860: PUSH
21861: LD_INT 1
21863: PUSH
21864: EMPTY
21865: LIST
21866: LIST
21867: PUSH
21868: EMPTY
21869: LIST
21870: LIST
21871: LIST
21872: PPUSH
21873: CALL_OW 69
21877: PUSH
21878: LD_EXP 1
21882: PUSH
21883: LD_EXP 2
21887: PUSH
21888: LD_EXP 3
21892: PUSH
21893: LD_EXP 4
21897: PUSH
21898: LD_EXP 7
21902: PUSH
21903: LD_EXP 13
21907: PUSH
21908: LD_EXP 5
21912: PUSH
21913: EMPTY
21914: LIST
21915: LIST
21916: LIST
21917: LIST
21918: LIST
21919: LIST
21920: LIST
21921: DIFF
21922: PPUSH
21923: LD_STRING 04_other_survivors
21925: PPUSH
21926: CALL_OW 38
// YouWin ;
21930: CALL_OW 103
// end ;
21934: LD_VAR 0 1
21938: RET
// export function SaveBase ( area ) ; var i , gammaBase , buildings ; begin
21939: LD_INT 0
21941: PPUSH
21942: PPUSH
21943: PPUSH
21944: PPUSH
// gammaBase = [ ] ;
21945: LD_ADDR_VAR 0 4
21949: PUSH
21950: EMPTY
21951: ST_TO_ADDR
// buildings = FilterUnitsInArea ( area , [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) ;
21952: LD_ADDR_VAR 0 5
21956: PUSH
21957: LD_VAR 0 1
21961: PPUSH
21962: LD_INT 22
21964: PUSH
21965: LD_INT 1
21967: PUSH
21968: EMPTY
21969: LIST
21970: LIST
21971: PUSH
21972: LD_INT 21
21974: PUSH
21975: LD_INT 3
21977: PUSH
21978: EMPTY
21979: LIST
21980: LIST
21981: PUSH
21982: EMPTY
21983: LIST
21984: LIST
21985: PPUSH
21986: CALL_OW 70
21990: ST_TO_ADDR
// for i in buildings do
21991: LD_ADDR_VAR 0 3
21995: PUSH
21996: LD_VAR 0 5
22000: PUSH
22001: FOR_IN
22002: IFFALSE 22339
// begin if GetBType ( i ) in [ b_lab , b_lab_half , b_lab_full ] then
22004: LD_VAR 0 3
22008: PPUSH
22009: CALL_OW 266
22013: PUSH
22014: LD_INT 6
22016: PUSH
22017: LD_INT 7
22019: PUSH
22020: LD_INT 8
22022: PUSH
22023: EMPTY
22024: LIST
22025: LIST
22026: LIST
22027: IN
22028: IFFALSE 22142
// gammaBase = gammaBase ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) ] ] else
22030: LD_ADDR_VAR 0 4
22034: PUSH
22035: LD_VAR 0 4
22039: PUSH
22040: LD_VAR 0 3
22044: PPUSH
22045: CALL_OW 266
22049: PUSH
22050: LD_VAR 0 3
22054: PPUSH
22055: CALL_OW 250
22059: PUSH
22060: LD_VAR 0 3
22064: PPUSH
22065: CALL_OW 251
22069: PUSH
22070: LD_VAR 0 3
22074: PPUSH
22075: CALL_OW 254
22079: PUSH
22080: LD_VAR 0 3
22084: PPUSH
22085: CALL_OW 267
22089: PUSH
22090: LD_VAR 0 3
22094: PPUSH
22095: CALL_OW 248
22099: PUSH
22100: LD_VAR 0 3
22104: PPUSH
22105: LD_INT 1
22107: PPUSH
22108: CALL_OW 268
22112: PUSH
22113: LD_VAR 0 3
22117: PPUSH
22118: LD_INT 2
22120: PPUSH
22121: CALL_OW 268
22125: PUSH
22126: EMPTY
22127: LIST
22128: LIST
22129: LIST
22130: LIST
22131: LIST
22132: LIST
22133: LIST
22134: LIST
22135: PUSH
22136: EMPTY
22137: LIST
22138: ADD
22139: ST_TO_ADDR
22140: GO 22337
// if GetBType ( i ) in [ b_bunker ] then
22142: LD_VAR 0 3
22146: PPUSH
22147: CALL_OW 266
22151: PUSH
22152: LD_INT 32
22154: PUSH
22155: EMPTY
22156: LIST
22157: IN
22158: IFFALSE 22255
// gammaBase = gammaBase ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetBWeapon ( i ) ] ] else
22160: LD_ADDR_VAR 0 4
22164: PUSH
22165: LD_VAR 0 4
22169: PUSH
22170: LD_VAR 0 3
22174: PPUSH
22175: CALL_OW 266
22179: PUSH
22180: LD_VAR 0 3
22184: PPUSH
22185: CALL_OW 250
22189: PUSH
22190: LD_VAR 0 3
22194: PPUSH
22195: CALL_OW 251
22199: PUSH
22200: LD_VAR 0 3
22204: PPUSH
22205: CALL_OW 254
22209: PUSH
22210: LD_VAR 0 3
22214: PPUSH
22215: CALL_OW 267
22219: PUSH
22220: LD_VAR 0 3
22224: PPUSH
22225: CALL_OW 248
22229: PUSH
22230: LD_VAR 0 3
22234: PPUSH
22235: CALL_OW 269
22239: PUSH
22240: EMPTY
22241: LIST
22242: LIST
22243: LIST
22244: LIST
22245: LIST
22246: LIST
22247: LIST
22248: PUSH
22249: EMPTY
22250: LIST
22251: ADD
22252: ST_TO_ADDR
22253: GO 22337
// gammaBase = gammaBase ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) ] ] ;
22255: LD_ADDR_VAR 0 4
22259: PUSH
22260: LD_VAR 0 4
22264: PUSH
22265: LD_VAR 0 3
22269: PPUSH
22270: CALL_OW 266
22274: PUSH
22275: LD_VAR 0 3
22279: PPUSH
22280: CALL_OW 250
22284: PUSH
22285: LD_VAR 0 3
22289: PPUSH
22290: CALL_OW 251
22294: PUSH
22295: LD_VAR 0 3
22299: PPUSH
22300: CALL_OW 254
22304: PUSH
22305: LD_VAR 0 3
22309: PPUSH
22310: CALL_OW 267
22314: PUSH
22315: LD_VAR 0 3
22319: PPUSH
22320: CALL_OW 248
22324: PUSH
22325: EMPTY
22326: LIST
22327: LIST
22328: LIST
22329: LIST
22330: LIST
22331: LIST
22332: PUSH
22333: EMPTY
22334: LIST
22335: ADD
22336: ST_TO_ADDR
// end ;
22337: GO 22001
22339: POP
22340: POP
// SaveVariable ( gammaBase , GammaBase ) ;
22341: LD_VAR 0 4
22345: PPUSH
22346: LD_STRING GammaBase
22348: PPUSH
22349: CALL_OW 39
// end ; end_of_file
22353: LD_VAR 0 2
22357: RET
// every 1 1$15 do
22358: GO 22360
22360: DISABLE
// begin if supply <= 13 and supply > 7 then
22361: LD_EXP 36
22365: PUSH
22366: LD_INT 13
22368: LESSEQUAL
22369: PUSH
22370: LD_EXP 36
22374: PUSH
22375: LD_INT 7
22377: GREATER
22378: AND
22379: IFFALSE 22402
// CreateCratesArea ( rand ( 3 , 5 ) , CratesArea1 , true ) ;
22381: LD_INT 3
22383: PPUSH
22384: LD_INT 5
22386: PPUSH
22387: CALL_OW 12
22391: PPUSH
22392: LD_INT 18
22394: PPUSH
22395: LD_INT 1
22397: PPUSH
22398: CALL_OW 55
// if supply <= 7 and supply > 4 then
22402: LD_EXP 36
22406: PUSH
22407: LD_INT 7
22409: LESSEQUAL
22410: PUSH
22411: LD_EXP 36
22415: PUSH
22416: LD_INT 4
22418: GREATER
22419: AND
22420: IFFALSE 22443
// CreateCratesArea ( rand ( 3 , 5 ) , CratesArea2 , true ) ;
22422: LD_INT 3
22424: PPUSH
22425: LD_INT 5
22427: PPUSH
22428: CALL_OW 12
22432: PPUSH
22433: LD_INT 19
22435: PPUSH
22436: LD_INT 1
22438: PPUSH
22439: CALL_OW 55
// if supply <= 4 and supply > 0 then
22443: LD_EXP 36
22447: PUSH
22448: LD_INT 4
22450: LESSEQUAL
22451: PUSH
22452: LD_EXP 36
22456: PUSH
22457: LD_INT 0
22459: GREATER
22460: AND
22461: IFFALSE 22484
// CreateCratesArea ( rand ( 3 , 5 ) , CratesArea3 , true ) ;
22463: LD_INT 3
22465: PPUSH
22466: LD_INT 5
22468: PPUSH
22469: CALL_OW 12
22473: PPUSH
22474: LD_INT 20
22476: PPUSH
22477: LD_INT 1
22479: PPUSH
22480: CALL_OW 55
// if supply > 0 then
22484: LD_EXP 36
22488: PUSH
22489: LD_INT 0
22491: GREATER
22492: IFFALSE 22509
// begin supply = supply - 1 ;
22494: LD_ADDR_EXP 36
22498: PUSH
22499: LD_EXP 36
22503: PUSH
22504: LD_INT 1
22506: MINUS
22507: ST_TO_ADDR
// enable ;
22508: ENABLE
// end ; end ; end_of_file
22509: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
22510: GO 22512
22512: DISABLE
// begin ru_radar := 98 ;
22513: LD_ADDR_EXP 52
22517: PUSH
22518: LD_INT 98
22520: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
22521: LD_ADDR_EXP 53
22525: PUSH
22526: LD_INT 89
22528: ST_TO_ADDR
// us_hack := 99 ;
22529: LD_ADDR_EXP 54
22533: PUSH
22534: LD_INT 99
22536: ST_TO_ADDR
// us_artillery := 97 ;
22537: LD_ADDR_EXP 55
22541: PUSH
22542: LD_INT 97
22544: ST_TO_ADDR
// ar_bio_bomb := 91 ;
22545: LD_ADDR_EXP 56
22549: PUSH
22550: LD_INT 91
22552: ST_TO_ADDR
// end ; end_of_file end_of_file
22553: END
// export StreamModeActive , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu ; every 0 0$1 do
22554: GO 22556
22556: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
22557: LD_STRING initStreamRollete();
22559: PPUSH
22560: CALL_OW 559
// InitStreamMode ;
22564: CALL 22569 0 0
// end ;
22568: END
// function InitStreamMode ; begin
22569: LD_INT 0
22571: PPUSH
// streamModeActive := false ;
22572: LD_ADDR_EXP 57
22576: PUSH
22577: LD_INT 0
22579: ST_TO_ADDR
// sRocket := false ;
22580: LD_ADDR_EXP 60
22584: PUSH
22585: LD_INT 0
22587: ST_TO_ADDR
// sSpeed := false ;
22588: LD_ADDR_EXP 59
22592: PUSH
22593: LD_INT 0
22595: ST_TO_ADDR
// sEngine := false ;
22596: LD_ADDR_EXP 61
22600: PUSH
22601: LD_INT 0
22603: ST_TO_ADDR
// sSpec := false ;
22604: LD_ADDR_EXP 58
22608: PUSH
22609: LD_INT 0
22611: ST_TO_ADDR
// sLevel := false ;
22612: LD_ADDR_EXP 62
22616: PUSH
22617: LD_INT 0
22619: ST_TO_ADDR
// sArmoury := false ;
22620: LD_ADDR_EXP 63
22624: PUSH
22625: LD_INT 0
22627: ST_TO_ADDR
// sRadar := false ;
22628: LD_ADDR_EXP 64
22632: PUSH
22633: LD_INT 0
22635: ST_TO_ADDR
// sBunker := false ;
22636: LD_ADDR_EXP 65
22640: PUSH
22641: LD_INT 0
22643: ST_TO_ADDR
// sHack := false ;
22644: LD_ADDR_EXP 66
22648: PUSH
22649: LD_INT 0
22651: ST_TO_ADDR
// sFire := false ;
22652: LD_ADDR_EXP 67
22656: PUSH
22657: LD_INT 0
22659: ST_TO_ADDR
// sRefresh := false ;
22660: LD_ADDR_EXP 68
22664: PUSH
22665: LD_INT 0
22667: ST_TO_ADDR
// sExp := false ;
22668: LD_ADDR_EXP 69
22672: PUSH
22673: LD_INT 0
22675: ST_TO_ADDR
// sDepot := false ;
22676: LD_ADDR_EXP 70
22680: PUSH
22681: LD_INT 0
22683: ST_TO_ADDR
// sFlag := false ;
22684: LD_ADDR_EXP 71
22688: PUSH
22689: LD_INT 0
22691: ST_TO_ADDR
// sKamikadze := false ;
22692: LD_ADDR_EXP 79
22696: PUSH
22697: LD_INT 0
22699: ST_TO_ADDR
// sTroll := false ;
22700: LD_ADDR_EXP 80
22704: PUSH
22705: LD_INT 0
22707: ST_TO_ADDR
// sSlow := false ;
22708: LD_ADDR_EXP 81
22712: PUSH
22713: LD_INT 0
22715: ST_TO_ADDR
// sLack := false ;
22716: LD_ADDR_EXP 82
22720: PUSH
22721: LD_INT 0
22723: ST_TO_ADDR
// sTank := false ;
22724: LD_ADDR_EXP 84
22728: PUSH
22729: LD_INT 0
22731: ST_TO_ADDR
// sRemote := false ;
22732: LD_ADDR_EXP 85
22736: PUSH
22737: LD_INT 0
22739: ST_TO_ADDR
// sPowell := false ;
22740: LD_ADDR_EXP 86
22744: PUSH
22745: LD_INT 0
22747: ST_TO_ADDR
// sTeleport := false ;
22748: LD_ADDR_EXP 89
22752: PUSH
22753: LD_INT 0
22755: ST_TO_ADDR
// sOilTower := false ;
22756: LD_ADDR_EXP 91
22760: PUSH
22761: LD_INT 0
22763: ST_TO_ADDR
// sShovel := false ;
22764: LD_ADDR_EXP 92
22768: PUSH
22769: LD_INT 0
22771: ST_TO_ADDR
// sSheik := false ;
22772: LD_ADDR_EXP 93
22776: PUSH
22777: LD_INT 0
22779: ST_TO_ADDR
// sSold := false ;
22780: LD_ADDR_EXP 72
22784: PUSH
22785: LD_INT 0
22787: ST_TO_ADDR
// sDiff := false ;
22788: LD_ADDR_EXP 73
22792: PUSH
22793: LD_INT 0
22795: ST_TO_ADDR
// sFog := false ;
22796: LD_ADDR_EXP 76
22800: PUSH
22801: LD_INT 0
22803: ST_TO_ADDR
// sReset := false ;
22804: LD_ADDR_EXP 77
22808: PUSH
22809: LD_INT 0
22811: ST_TO_ADDR
// sSun := false ;
22812: LD_ADDR_EXP 78
22816: PUSH
22817: LD_INT 0
22819: ST_TO_ADDR
// sTiger := false ;
22820: LD_ADDR_EXP 74
22824: PUSH
22825: LD_INT 0
22827: ST_TO_ADDR
// sBomb := false ;
22828: LD_ADDR_EXP 75
22832: PUSH
22833: LD_INT 0
22835: ST_TO_ADDR
// sWound := false ;
22836: LD_ADDR_EXP 83
22840: PUSH
22841: LD_INT 0
22843: ST_TO_ADDR
// sBetray := false ;
22844: LD_ADDR_EXP 87
22848: PUSH
22849: LD_INT 0
22851: ST_TO_ADDR
// sContamin := false ;
22852: LD_ADDR_EXP 88
22856: PUSH
22857: LD_INT 0
22859: ST_TO_ADDR
// sOil := false ;
22860: LD_ADDR_EXP 90
22864: PUSH
22865: LD_INT 0
22867: ST_TO_ADDR
// sStu := false ;
22868: LD_ADDR_EXP 94
22872: PUSH
22873: LD_INT 0
22875: ST_TO_ADDR
// end ;
22876: LD_VAR 0 1
22880: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
22881: LD_VAR 0 2
22885: PUSH
22886: LD_INT 100
22888: EQUAL
22889: IFFALSE 23586
// begin if not StreamModeActive then
22891: LD_EXP 57
22895: NOT
22896: IFFALSE 22906
// StreamModeActive := true ;
22898: LD_ADDR_EXP 57
22902: PUSH
22903: LD_INT 1
22905: ST_TO_ADDR
// if p3 = 0 then
22906: LD_VAR 0 3
22910: PUSH
22911: LD_INT 0
22913: EQUAL
22914: IFFALSE 22920
// InitStreamMode ;
22916: CALL 22569 0 0
// if p3 = 1 then
22920: LD_VAR 0 3
22924: PUSH
22925: LD_INT 1
22927: EQUAL
22928: IFFALSE 22938
// sRocket := true ;
22930: LD_ADDR_EXP 60
22934: PUSH
22935: LD_INT 1
22937: ST_TO_ADDR
// if p3 = 2 then
22938: LD_VAR 0 3
22942: PUSH
22943: LD_INT 2
22945: EQUAL
22946: IFFALSE 22956
// sSpeed := true ;
22948: LD_ADDR_EXP 59
22952: PUSH
22953: LD_INT 1
22955: ST_TO_ADDR
// if p3 = 3 then
22956: LD_VAR 0 3
22960: PUSH
22961: LD_INT 3
22963: EQUAL
22964: IFFALSE 22974
// sEngine := true ;
22966: LD_ADDR_EXP 61
22970: PUSH
22971: LD_INT 1
22973: ST_TO_ADDR
// if p3 = 4 then
22974: LD_VAR 0 3
22978: PUSH
22979: LD_INT 4
22981: EQUAL
22982: IFFALSE 22992
// sSpec := true ;
22984: LD_ADDR_EXP 58
22988: PUSH
22989: LD_INT 1
22991: ST_TO_ADDR
// if p3 = 5 then
22992: LD_VAR 0 3
22996: PUSH
22997: LD_INT 5
22999: EQUAL
23000: IFFALSE 23010
// sLevel := true ;
23002: LD_ADDR_EXP 62
23006: PUSH
23007: LD_INT 1
23009: ST_TO_ADDR
// if p3 = 6 then
23010: LD_VAR 0 3
23014: PUSH
23015: LD_INT 6
23017: EQUAL
23018: IFFALSE 23028
// sArmoury := true ;
23020: LD_ADDR_EXP 63
23024: PUSH
23025: LD_INT 1
23027: ST_TO_ADDR
// if p3 = 7 then
23028: LD_VAR 0 3
23032: PUSH
23033: LD_INT 7
23035: EQUAL
23036: IFFALSE 23046
// sRadar := true ;
23038: LD_ADDR_EXP 64
23042: PUSH
23043: LD_INT 1
23045: ST_TO_ADDR
// if p3 = 8 then
23046: LD_VAR 0 3
23050: PUSH
23051: LD_INT 8
23053: EQUAL
23054: IFFALSE 23064
// sBunker := true ;
23056: LD_ADDR_EXP 65
23060: PUSH
23061: LD_INT 1
23063: ST_TO_ADDR
// if p3 = 9 then
23064: LD_VAR 0 3
23068: PUSH
23069: LD_INT 9
23071: EQUAL
23072: IFFALSE 23082
// sHack := true ;
23074: LD_ADDR_EXP 66
23078: PUSH
23079: LD_INT 1
23081: ST_TO_ADDR
// if p3 = 10 then
23082: LD_VAR 0 3
23086: PUSH
23087: LD_INT 10
23089: EQUAL
23090: IFFALSE 23100
// sFire := true ;
23092: LD_ADDR_EXP 67
23096: PUSH
23097: LD_INT 1
23099: ST_TO_ADDR
// if p3 = 11 then
23100: LD_VAR 0 3
23104: PUSH
23105: LD_INT 11
23107: EQUAL
23108: IFFALSE 23118
// sRefresh := true ;
23110: LD_ADDR_EXP 68
23114: PUSH
23115: LD_INT 1
23117: ST_TO_ADDR
// if p3 = 12 then
23118: LD_VAR 0 3
23122: PUSH
23123: LD_INT 12
23125: EQUAL
23126: IFFALSE 23136
// sExp := true ;
23128: LD_ADDR_EXP 69
23132: PUSH
23133: LD_INT 1
23135: ST_TO_ADDR
// if p3 = 13 then
23136: LD_VAR 0 3
23140: PUSH
23141: LD_INT 13
23143: EQUAL
23144: IFFALSE 23154
// sDepot := true ;
23146: LD_ADDR_EXP 70
23150: PUSH
23151: LD_INT 1
23153: ST_TO_ADDR
// if p3 = 14 then
23154: LD_VAR 0 3
23158: PUSH
23159: LD_INT 14
23161: EQUAL
23162: IFFALSE 23172
// sFlag := true ;
23164: LD_ADDR_EXP 71
23168: PUSH
23169: LD_INT 1
23171: ST_TO_ADDR
// if p3 = 15 then
23172: LD_VAR 0 3
23176: PUSH
23177: LD_INT 15
23179: EQUAL
23180: IFFALSE 23190
// sKamikadze := true ;
23182: LD_ADDR_EXP 79
23186: PUSH
23187: LD_INT 1
23189: ST_TO_ADDR
// if p3 = 16 then
23190: LD_VAR 0 3
23194: PUSH
23195: LD_INT 16
23197: EQUAL
23198: IFFALSE 23208
// sTroll := true ;
23200: LD_ADDR_EXP 80
23204: PUSH
23205: LD_INT 1
23207: ST_TO_ADDR
// if p3 = 17 then
23208: LD_VAR 0 3
23212: PUSH
23213: LD_INT 17
23215: EQUAL
23216: IFFALSE 23226
// sSlow := true ;
23218: LD_ADDR_EXP 81
23222: PUSH
23223: LD_INT 1
23225: ST_TO_ADDR
// if p3 = 18 then
23226: LD_VAR 0 3
23230: PUSH
23231: LD_INT 18
23233: EQUAL
23234: IFFALSE 23244
// sLack := true ;
23236: LD_ADDR_EXP 82
23240: PUSH
23241: LD_INT 1
23243: ST_TO_ADDR
// if p3 = 19 then
23244: LD_VAR 0 3
23248: PUSH
23249: LD_INT 19
23251: EQUAL
23252: IFFALSE 23262
// sTank := true ;
23254: LD_ADDR_EXP 84
23258: PUSH
23259: LD_INT 1
23261: ST_TO_ADDR
// if p3 = 20 then
23262: LD_VAR 0 3
23266: PUSH
23267: LD_INT 20
23269: EQUAL
23270: IFFALSE 23280
// sRemote := true ;
23272: LD_ADDR_EXP 85
23276: PUSH
23277: LD_INT 1
23279: ST_TO_ADDR
// if p3 = 21 then
23280: LD_VAR 0 3
23284: PUSH
23285: LD_INT 21
23287: EQUAL
23288: IFFALSE 23298
// sPowell := true ;
23290: LD_ADDR_EXP 86
23294: PUSH
23295: LD_INT 1
23297: ST_TO_ADDR
// if p3 = 22 then
23298: LD_VAR 0 3
23302: PUSH
23303: LD_INT 22
23305: EQUAL
23306: IFFALSE 23316
// sTeleport := true ;
23308: LD_ADDR_EXP 89
23312: PUSH
23313: LD_INT 1
23315: ST_TO_ADDR
// if p3 = 23 then
23316: LD_VAR 0 3
23320: PUSH
23321: LD_INT 23
23323: EQUAL
23324: IFFALSE 23334
// sOilTower := true ;
23326: LD_ADDR_EXP 91
23330: PUSH
23331: LD_INT 1
23333: ST_TO_ADDR
// if p3 = 24 then
23334: LD_VAR 0 3
23338: PUSH
23339: LD_INT 24
23341: EQUAL
23342: IFFALSE 23352
// sShovel := true ;
23344: LD_ADDR_EXP 92
23348: PUSH
23349: LD_INT 1
23351: ST_TO_ADDR
// if p3 = 25 then
23352: LD_VAR 0 3
23356: PUSH
23357: LD_INT 25
23359: EQUAL
23360: IFFALSE 23370
// sSheik := true ;
23362: LD_ADDR_EXP 93
23366: PUSH
23367: LD_INT 1
23369: ST_TO_ADDR
// if p3 = 101 then
23370: LD_VAR 0 3
23374: PUSH
23375: LD_INT 101
23377: EQUAL
23378: IFFALSE 23388
// sSold := true ;
23380: LD_ADDR_EXP 72
23384: PUSH
23385: LD_INT 1
23387: ST_TO_ADDR
// if p3 = 102 then
23388: LD_VAR 0 3
23392: PUSH
23393: LD_INT 102
23395: EQUAL
23396: IFFALSE 23406
// sDiff := true ;
23398: LD_ADDR_EXP 73
23402: PUSH
23403: LD_INT 1
23405: ST_TO_ADDR
// if p3 = 103 then
23406: LD_VAR 0 3
23410: PUSH
23411: LD_INT 103
23413: EQUAL
23414: IFFALSE 23424
// sFog := true ;
23416: LD_ADDR_EXP 76
23420: PUSH
23421: LD_INT 1
23423: ST_TO_ADDR
// if p3 = 104 then
23424: LD_VAR 0 3
23428: PUSH
23429: LD_INT 104
23431: EQUAL
23432: IFFALSE 23442
// sReset := true ;
23434: LD_ADDR_EXP 77
23438: PUSH
23439: LD_INT 1
23441: ST_TO_ADDR
// if p3 = 105 then
23442: LD_VAR 0 3
23446: PUSH
23447: LD_INT 105
23449: EQUAL
23450: IFFALSE 23460
// sSun := true ;
23452: LD_ADDR_EXP 78
23456: PUSH
23457: LD_INT 1
23459: ST_TO_ADDR
// if p3 = 106 then
23460: LD_VAR 0 3
23464: PUSH
23465: LD_INT 106
23467: EQUAL
23468: IFFALSE 23478
// sTiger := true ;
23470: LD_ADDR_EXP 74
23474: PUSH
23475: LD_INT 1
23477: ST_TO_ADDR
// if p3 = 107 then
23478: LD_VAR 0 3
23482: PUSH
23483: LD_INT 107
23485: EQUAL
23486: IFFALSE 23496
// sBomb := true ;
23488: LD_ADDR_EXP 75
23492: PUSH
23493: LD_INT 1
23495: ST_TO_ADDR
// if p3 = 108 then
23496: LD_VAR 0 3
23500: PUSH
23501: LD_INT 108
23503: EQUAL
23504: IFFALSE 23514
// sWound := true ;
23506: LD_ADDR_EXP 83
23510: PUSH
23511: LD_INT 1
23513: ST_TO_ADDR
// if p3 = 109 then
23514: LD_VAR 0 3
23518: PUSH
23519: LD_INT 109
23521: EQUAL
23522: IFFALSE 23532
// sBetray := true ;
23524: LD_ADDR_EXP 87
23528: PUSH
23529: LD_INT 1
23531: ST_TO_ADDR
// if p3 = 110 then
23532: LD_VAR 0 3
23536: PUSH
23537: LD_INT 110
23539: EQUAL
23540: IFFALSE 23550
// sContamin := true ;
23542: LD_ADDR_EXP 88
23546: PUSH
23547: LD_INT 1
23549: ST_TO_ADDR
// if p3 = 111 then
23550: LD_VAR 0 3
23554: PUSH
23555: LD_INT 111
23557: EQUAL
23558: IFFALSE 23568
// sOil := true ;
23560: LD_ADDR_EXP 90
23564: PUSH
23565: LD_INT 1
23567: ST_TO_ADDR
// if p3 = 112 then
23568: LD_VAR 0 3
23572: PUSH
23573: LD_INT 112
23575: EQUAL
23576: IFFALSE 23586
// sStu := true ;
23578: LD_ADDR_EXP 94
23582: PUSH
23583: LD_INT 1
23585: ST_TO_ADDR
// end ; end ;
23586: PPOPN 6
23588: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
23589: LD_EXP 57
23593: PUSH
23594: LD_EXP 60
23598: AND
23599: IFFALSE 23723
23601: GO 23603
23603: DISABLE
23604: LD_INT 0
23606: PPUSH
23607: PPUSH
// begin enable ;
23608: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
23609: LD_ADDR_VAR 0 2
23613: PUSH
23614: LD_INT 22
23616: PUSH
23617: LD_OWVAR 2
23621: PUSH
23622: EMPTY
23623: LIST
23624: LIST
23625: PUSH
23626: LD_INT 2
23628: PUSH
23629: LD_INT 34
23631: PUSH
23632: LD_INT 7
23634: PUSH
23635: EMPTY
23636: LIST
23637: LIST
23638: PUSH
23639: LD_INT 34
23641: PUSH
23642: LD_INT 45
23644: PUSH
23645: EMPTY
23646: LIST
23647: LIST
23648: PUSH
23649: LD_INT 34
23651: PUSH
23652: LD_INT 28
23654: PUSH
23655: EMPTY
23656: LIST
23657: LIST
23658: PUSH
23659: LD_INT 34
23661: PUSH
23662: LD_INT 47
23664: PUSH
23665: EMPTY
23666: LIST
23667: LIST
23668: PUSH
23669: EMPTY
23670: LIST
23671: LIST
23672: LIST
23673: LIST
23674: LIST
23675: PUSH
23676: EMPTY
23677: LIST
23678: LIST
23679: PPUSH
23680: CALL_OW 69
23684: ST_TO_ADDR
// if not tmp then
23685: LD_VAR 0 2
23689: NOT
23690: IFFALSE 23694
// exit ;
23692: GO 23723
// for i in tmp do
23694: LD_ADDR_VAR 0 1
23698: PUSH
23699: LD_VAR 0 2
23703: PUSH
23704: FOR_IN
23705: IFFALSE 23721
// begin SetLives ( i , 0 ) ;
23707: LD_VAR 0 1
23711: PPUSH
23712: LD_INT 0
23714: PPUSH
23715: CALL_OW 234
// end ;
23719: GO 23704
23721: POP
23722: POP
// end ;
23723: PPOPN 2
23725: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
23726: LD_EXP 57
23730: PUSH
23731: LD_EXP 61
23735: AND
23736: IFFALSE 23817
23738: GO 23740
23740: DISABLE
23741: LD_INT 0
23743: PPUSH
23744: PPUSH
// begin enable ;
23745: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
23746: LD_ADDR_VAR 0 2
23750: PUSH
23751: LD_INT 22
23753: PUSH
23754: LD_OWVAR 2
23758: PUSH
23759: EMPTY
23760: LIST
23761: LIST
23762: PUSH
23763: LD_INT 32
23765: PUSH
23766: LD_INT 3
23768: PUSH
23769: EMPTY
23770: LIST
23771: LIST
23772: PUSH
23773: EMPTY
23774: LIST
23775: LIST
23776: PPUSH
23777: CALL_OW 69
23781: ST_TO_ADDR
// if not tmp then
23782: LD_VAR 0 2
23786: NOT
23787: IFFALSE 23791
// exit ;
23789: GO 23817
// for i in tmp do
23791: LD_ADDR_VAR 0 1
23795: PUSH
23796: LD_VAR 0 2
23800: PUSH
23801: FOR_IN
23802: IFFALSE 23815
// begin DestroyUnit ( i ) ;
23804: LD_VAR 0 1
23808: PPUSH
23809: CALL_OW 65
// end ;
23813: GO 23801
23815: POP
23816: POP
// end ;
23817: PPOPN 2
23819: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
23820: LD_EXP 57
23824: PUSH
23825: LD_EXP 58
23829: AND
23830: IFFALSE 23923
23832: GO 23834
23834: DISABLE
23835: LD_INT 0
23837: PPUSH
// begin enable ;
23838: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
23839: LD_ADDR_VAR 0 1
23843: PUSH
23844: LD_INT 22
23846: PUSH
23847: LD_OWVAR 2
23851: PUSH
23852: EMPTY
23853: LIST
23854: LIST
23855: PUSH
23856: LD_INT 2
23858: PUSH
23859: LD_INT 25
23861: PUSH
23862: LD_INT 5
23864: PUSH
23865: EMPTY
23866: LIST
23867: LIST
23868: PUSH
23869: LD_INT 25
23871: PUSH
23872: LD_INT 9
23874: PUSH
23875: EMPTY
23876: LIST
23877: LIST
23878: PUSH
23879: LD_INT 25
23881: PUSH
23882: LD_INT 8
23884: PUSH
23885: EMPTY
23886: LIST
23887: LIST
23888: PUSH
23889: EMPTY
23890: LIST
23891: LIST
23892: LIST
23893: LIST
23894: PUSH
23895: EMPTY
23896: LIST
23897: LIST
23898: PPUSH
23899: CALL_OW 69
23903: PUSH
23904: FOR_IN
23905: IFFALSE 23921
// begin SetClass ( i , 1 ) ;
23907: LD_VAR 0 1
23911: PPUSH
23912: LD_INT 1
23914: PPUSH
23915: CALL_OW 336
// end ;
23919: GO 23904
23921: POP
23922: POP
// end ;
23923: PPOPN 1
23925: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
23926: LD_EXP 57
23930: PUSH
23931: LD_EXP 59
23935: AND
23936: PUSH
23937: LD_OWVAR 65
23941: PUSH
23942: LD_INT 7
23944: LESS
23945: AND
23946: IFFALSE 23960
23948: GO 23950
23950: DISABLE
// begin enable ;
23951: ENABLE
// game_speed := 7 ;
23952: LD_ADDR_OWVAR 65
23956: PUSH
23957: LD_INT 7
23959: ST_TO_ADDR
// end ;
23960: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
23961: LD_EXP 57
23965: PUSH
23966: LD_EXP 62
23970: AND
23971: IFFALSE 24173
23973: GO 23975
23975: DISABLE
23976: LD_INT 0
23978: PPUSH
23979: PPUSH
23980: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
23981: LD_ADDR_VAR 0 3
23985: PUSH
23986: LD_INT 81
23988: PUSH
23989: LD_OWVAR 2
23993: PUSH
23994: EMPTY
23995: LIST
23996: LIST
23997: PUSH
23998: LD_INT 21
24000: PUSH
24001: LD_INT 1
24003: PUSH
24004: EMPTY
24005: LIST
24006: LIST
24007: PUSH
24008: EMPTY
24009: LIST
24010: LIST
24011: PPUSH
24012: CALL_OW 69
24016: ST_TO_ADDR
// if not tmp then
24017: LD_VAR 0 3
24021: NOT
24022: IFFALSE 24026
// exit ;
24024: GO 24173
// if tmp > 5 then
24026: LD_VAR 0 3
24030: PUSH
24031: LD_INT 5
24033: GREATER
24034: IFFALSE 24046
// k := 5 else
24036: LD_ADDR_VAR 0 2
24040: PUSH
24041: LD_INT 5
24043: ST_TO_ADDR
24044: GO 24056
// k := tmp ;
24046: LD_ADDR_VAR 0 2
24050: PUSH
24051: LD_VAR 0 3
24055: ST_TO_ADDR
// for i := 1 to k do
24056: LD_ADDR_VAR 0 1
24060: PUSH
24061: DOUBLE
24062: LD_INT 1
24064: DEC
24065: ST_TO_ADDR
24066: LD_VAR 0 2
24070: PUSH
24071: FOR_TO
24072: IFFALSE 24171
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
24074: LD_VAR 0 3
24078: PUSH
24079: LD_VAR 0 1
24083: ARRAY
24084: PPUSH
24085: LD_VAR 0 1
24089: PUSH
24090: LD_INT 4
24092: MOD
24093: PUSH
24094: LD_INT 1
24096: PLUS
24097: PPUSH
24098: CALL_OW 259
24102: PUSH
24103: LD_INT 10
24105: LESS
24106: IFFALSE 24169
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
24108: LD_VAR 0 3
24112: PUSH
24113: LD_VAR 0 1
24117: ARRAY
24118: PPUSH
24119: LD_VAR 0 1
24123: PUSH
24124: LD_INT 4
24126: MOD
24127: PUSH
24128: LD_INT 1
24130: PLUS
24131: PPUSH
24132: LD_VAR 0 3
24136: PUSH
24137: LD_VAR 0 1
24141: ARRAY
24142: PPUSH
24143: LD_VAR 0 1
24147: PUSH
24148: LD_INT 4
24150: MOD
24151: PUSH
24152: LD_INT 1
24154: PLUS
24155: PPUSH
24156: CALL_OW 259
24160: PUSH
24161: LD_INT 1
24163: PLUS
24164: PPUSH
24165: CALL_OW 237
24169: GO 24071
24171: POP
24172: POP
// end ;
24173: PPOPN 3
24175: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
24176: LD_EXP 57
24180: PUSH
24181: LD_EXP 63
24185: AND
24186: IFFALSE 24206
24188: GO 24190
24190: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
24191: LD_INT 4
24193: PPUSH
24194: LD_OWVAR 2
24198: PPUSH
24199: LD_INT 0
24201: PPUSH
24202: CALL_OW 324
24206: END
// every 0 0$1 trigger StreamModeActive and sShovel do
24207: LD_EXP 57
24211: PUSH
24212: LD_EXP 92
24216: AND
24217: IFFALSE 24237
24219: GO 24221
24221: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
24222: LD_INT 19
24224: PPUSH
24225: LD_OWVAR 2
24229: PPUSH
24230: LD_INT 0
24232: PPUSH
24233: CALL_OW 324
24237: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
24238: LD_EXP 57
24242: PUSH
24243: LD_EXP 64
24247: AND
24248: IFFALSE 24347
24250: GO 24252
24252: DISABLE
24253: LD_INT 0
24255: PPUSH
24256: PPUSH
// begin enable ;
24257: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
24258: LD_ADDR_VAR 0 2
24262: PUSH
24263: LD_INT 22
24265: PUSH
24266: LD_OWVAR 2
24270: PUSH
24271: EMPTY
24272: LIST
24273: LIST
24274: PUSH
24275: LD_INT 2
24277: PUSH
24278: LD_INT 34
24280: PUSH
24281: LD_INT 11
24283: PUSH
24284: EMPTY
24285: LIST
24286: LIST
24287: PUSH
24288: LD_INT 34
24290: PUSH
24291: LD_INT 30
24293: PUSH
24294: EMPTY
24295: LIST
24296: LIST
24297: PUSH
24298: EMPTY
24299: LIST
24300: LIST
24301: LIST
24302: PUSH
24303: EMPTY
24304: LIST
24305: LIST
24306: PPUSH
24307: CALL_OW 69
24311: ST_TO_ADDR
// if not tmp then
24312: LD_VAR 0 2
24316: NOT
24317: IFFALSE 24321
// exit ;
24319: GO 24347
// for i in tmp do
24321: LD_ADDR_VAR 0 1
24325: PUSH
24326: LD_VAR 0 2
24330: PUSH
24331: FOR_IN
24332: IFFALSE 24345
// begin DestroyUnit ( i ) ;
24334: LD_VAR 0 1
24338: PPUSH
24339: CALL_OW 65
// end ;
24343: GO 24331
24345: POP
24346: POP
// end ;
24347: PPOPN 2
24349: END
// every 0 0$1 trigger StreamModeActive and sBunker do
24350: LD_EXP 57
24354: PUSH
24355: LD_EXP 65
24359: AND
24360: IFFALSE 24380
24362: GO 24364
24364: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
24365: LD_INT 32
24367: PPUSH
24368: LD_OWVAR 2
24372: PPUSH
24373: LD_INT 0
24375: PPUSH
24376: CALL_OW 324
24380: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
24381: LD_EXP 57
24385: PUSH
24386: LD_EXP 66
24390: AND
24391: IFFALSE 24572
24393: GO 24395
24395: DISABLE
24396: LD_INT 0
24398: PPUSH
24399: PPUSH
24400: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
24401: LD_ADDR_VAR 0 2
24405: PUSH
24406: LD_INT 22
24408: PUSH
24409: LD_OWVAR 2
24413: PUSH
24414: EMPTY
24415: LIST
24416: LIST
24417: PUSH
24418: LD_INT 33
24420: PUSH
24421: LD_INT 3
24423: PUSH
24424: EMPTY
24425: LIST
24426: LIST
24427: PUSH
24428: EMPTY
24429: LIST
24430: LIST
24431: PPUSH
24432: CALL_OW 69
24436: ST_TO_ADDR
// if not tmp then
24437: LD_VAR 0 2
24441: NOT
24442: IFFALSE 24446
// exit ;
24444: GO 24572
// side := 0 ;
24446: LD_ADDR_VAR 0 3
24450: PUSH
24451: LD_INT 0
24453: ST_TO_ADDR
// for i := 1 to 8 do
24454: LD_ADDR_VAR 0 1
24458: PUSH
24459: DOUBLE
24460: LD_INT 1
24462: DEC
24463: ST_TO_ADDR
24464: LD_INT 8
24466: PUSH
24467: FOR_TO
24468: IFFALSE 24516
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
24470: LD_OWVAR 2
24474: PUSH
24475: LD_VAR 0 1
24479: NONEQUAL
24480: PUSH
24481: LD_OWVAR 2
24485: PPUSH
24486: LD_VAR 0 1
24490: PPUSH
24491: CALL_OW 81
24495: PUSH
24496: LD_INT 2
24498: EQUAL
24499: AND
24500: IFFALSE 24514
// begin side := i ;
24502: LD_ADDR_VAR 0 3
24506: PUSH
24507: LD_VAR 0 1
24511: ST_TO_ADDR
// break ;
24512: GO 24516
// end ;
24514: GO 24467
24516: POP
24517: POP
// if not side then
24518: LD_VAR 0 3
24522: NOT
24523: IFFALSE 24527
// exit ;
24525: GO 24572
// for i := 1 to tmp do
24527: LD_ADDR_VAR 0 1
24531: PUSH
24532: DOUBLE
24533: LD_INT 1
24535: DEC
24536: ST_TO_ADDR
24537: LD_VAR 0 2
24541: PUSH
24542: FOR_TO
24543: IFFALSE 24570
// if Prob ( 30 ) then
24545: LD_INT 30
24547: PPUSH
24548: CALL_OW 13
24552: IFFALSE 24568
// SetSide ( i , side ) ;
24554: LD_VAR 0 1
24558: PPUSH
24559: LD_VAR 0 3
24563: PPUSH
24564: CALL_OW 235
24568: GO 24542
24570: POP
24571: POP
// end ;
24572: PPOPN 3
24574: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
24575: LD_EXP 57
24579: PUSH
24580: LD_EXP 68
24584: AND
24585: IFFALSE 24704
24587: GO 24589
24589: DISABLE
24590: LD_INT 0
24592: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
24593: LD_ADDR_VAR 0 1
24597: PUSH
24598: LD_INT 22
24600: PUSH
24601: LD_OWVAR 2
24605: PUSH
24606: EMPTY
24607: LIST
24608: LIST
24609: PUSH
24610: LD_INT 21
24612: PUSH
24613: LD_INT 1
24615: PUSH
24616: EMPTY
24617: LIST
24618: LIST
24619: PUSH
24620: LD_INT 3
24622: PUSH
24623: LD_INT 23
24625: PUSH
24626: LD_INT 0
24628: PUSH
24629: EMPTY
24630: LIST
24631: LIST
24632: PUSH
24633: EMPTY
24634: LIST
24635: LIST
24636: PUSH
24637: EMPTY
24638: LIST
24639: LIST
24640: LIST
24641: PPUSH
24642: CALL_OW 69
24646: PUSH
24647: FOR_IN
24648: IFFALSE 24702
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
24650: LD_VAR 0 1
24654: PPUSH
24655: CALL_OW 257
24659: PUSH
24660: LD_INT 1
24662: PUSH
24663: LD_INT 2
24665: PUSH
24666: LD_INT 3
24668: PUSH
24669: LD_INT 4
24671: PUSH
24672: EMPTY
24673: LIST
24674: LIST
24675: LIST
24676: LIST
24677: IN
24678: IFFALSE 24700
// SetClass ( un , rand ( 1 , 4 ) ) ;
24680: LD_VAR 0 1
24684: PPUSH
24685: LD_INT 1
24687: PPUSH
24688: LD_INT 4
24690: PPUSH
24691: CALL_OW 12
24695: PPUSH
24696: CALL_OW 336
24700: GO 24647
24702: POP
24703: POP
// end ;
24704: PPOPN 1
24706: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
24707: LD_EXP 57
24711: PUSH
24712: LD_EXP 67
24716: AND
24717: IFFALSE 24796
24719: GO 24721
24721: DISABLE
24722: LD_INT 0
24724: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
24725: LD_ADDR_VAR 0 1
24729: PUSH
24730: LD_INT 22
24732: PUSH
24733: LD_OWVAR 2
24737: PUSH
24738: EMPTY
24739: LIST
24740: LIST
24741: PUSH
24742: LD_INT 21
24744: PUSH
24745: LD_INT 3
24747: PUSH
24748: EMPTY
24749: LIST
24750: LIST
24751: PUSH
24752: EMPTY
24753: LIST
24754: LIST
24755: PPUSH
24756: CALL_OW 69
24760: ST_TO_ADDR
// if not tmp then
24761: LD_VAR 0 1
24765: NOT
24766: IFFALSE 24770
// exit ;
24768: GO 24796
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
24770: LD_VAR 0 1
24774: PUSH
24775: LD_INT 1
24777: PPUSH
24778: LD_VAR 0 1
24782: PPUSH
24783: CALL_OW 12
24787: ARRAY
24788: PPUSH
24789: LD_INT 100
24791: PPUSH
24792: CALL_OW 234
// end ;
24796: PPOPN 1
24798: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
24799: LD_EXP 57
24803: PUSH
24804: LD_EXP 69
24808: AND
24809: IFFALSE 24907
24811: GO 24813
24813: DISABLE
24814: LD_INT 0
24816: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
24817: LD_ADDR_VAR 0 1
24821: PUSH
24822: LD_INT 22
24824: PUSH
24825: LD_OWVAR 2
24829: PUSH
24830: EMPTY
24831: LIST
24832: LIST
24833: PUSH
24834: LD_INT 21
24836: PUSH
24837: LD_INT 1
24839: PUSH
24840: EMPTY
24841: LIST
24842: LIST
24843: PUSH
24844: EMPTY
24845: LIST
24846: LIST
24847: PPUSH
24848: CALL_OW 69
24852: ST_TO_ADDR
// if not tmp then
24853: LD_VAR 0 1
24857: NOT
24858: IFFALSE 24862
// exit ;
24860: GO 24907
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
24862: LD_VAR 0 1
24866: PUSH
24867: LD_INT 1
24869: PPUSH
24870: LD_VAR 0 1
24874: PPUSH
24875: CALL_OW 12
24879: ARRAY
24880: PPUSH
24881: LD_INT 1
24883: PPUSH
24884: LD_INT 4
24886: PPUSH
24887: CALL_OW 12
24891: PPUSH
24892: LD_INT 3000
24894: PPUSH
24895: LD_INT 9000
24897: PPUSH
24898: CALL_OW 12
24902: PPUSH
24903: CALL_OW 492
// end ;
24907: PPOPN 1
24909: END
// every 0 0$1 trigger StreamModeActive and sDepot do
24910: LD_EXP 57
24914: PUSH
24915: LD_EXP 70
24919: AND
24920: IFFALSE 24940
24922: GO 24924
24924: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
24925: LD_INT 1
24927: PPUSH
24928: LD_OWVAR 2
24932: PPUSH
24933: LD_INT 0
24935: PPUSH
24936: CALL_OW 324
24940: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
24941: LD_EXP 57
24945: PUSH
24946: LD_EXP 71
24950: AND
24951: IFFALSE 25034
24953: GO 24955
24955: DISABLE
24956: LD_INT 0
24958: PPUSH
24959: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
24960: LD_ADDR_VAR 0 2
24964: PUSH
24965: LD_INT 22
24967: PUSH
24968: LD_OWVAR 2
24972: PUSH
24973: EMPTY
24974: LIST
24975: LIST
24976: PUSH
24977: LD_INT 21
24979: PUSH
24980: LD_INT 3
24982: PUSH
24983: EMPTY
24984: LIST
24985: LIST
24986: PUSH
24987: EMPTY
24988: LIST
24989: LIST
24990: PPUSH
24991: CALL_OW 69
24995: ST_TO_ADDR
// if not tmp then
24996: LD_VAR 0 2
25000: NOT
25001: IFFALSE 25005
// exit ;
25003: GO 25034
// for i in tmp do
25005: LD_ADDR_VAR 0 1
25009: PUSH
25010: LD_VAR 0 2
25014: PUSH
25015: FOR_IN
25016: IFFALSE 25032
// SetBLevel ( i , 10 ) ;
25018: LD_VAR 0 1
25022: PPUSH
25023: LD_INT 10
25025: PPUSH
25026: CALL_OW 241
25030: GO 25015
25032: POP
25033: POP
// end ;
25034: PPOPN 2
25036: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
25037: LD_EXP 57
25041: PUSH
25042: LD_EXP 72
25046: AND
25047: IFFALSE 25158
25049: GO 25051
25051: DISABLE
25052: LD_INT 0
25054: PPUSH
25055: PPUSH
25056: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
25057: LD_ADDR_VAR 0 3
25061: PUSH
25062: LD_INT 22
25064: PUSH
25065: LD_OWVAR 2
25069: PUSH
25070: EMPTY
25071: LIST
25072: LIST
25073: PUSH
25074: LD_INT 25
25076: PUSH
25077: LD_INT 1
25079: PUSH
25080: EMPTY
25081: LIST
25082: LIST
25083: PUSH
25084: EMPTY
25085: LIST
25086: LIST
25087: PPUSH
25088: CALL_OW 69
25092: ST_TO_ADDR
// if not tmp then
25093: LD_VAR 0 3
25097: NOT
25098: IFFALSE 25102
// exit ;
25100: GO 25158
// un := tmp [ rand ( 1 , tmp ) ] ;
25102: LD_ADDR_VAR 0 2
25106: PUSH
25107: LD_VAR 0 3
25111: PUSH
25112: LD_INT 1
25114: PPUSH
25115: LD_VAR 0 3
25119: PPUSH
25120: CALL_OW 12
25124: ARRAY
25125: ST_TO_ADDR
// if Crawls ( un ) then
25126: LD_VAR 0 2
25130: PPUSH
25131: CALL_OW 318
25135: IFFALSE 25146
// ComWalk ( un ) ;
25137: LD_VAR 0 2
25141: PPUSH
25142: CALL_OW 138
// SetClass ( un , class_sniper ) ;
25146: LD_VAR 0 2
25150: PPUSH
25151: LD_INT 5
25153: PPUSH
25154: CALL_OW 336
// end ;
25158: PPOPN 3
25160: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
25161: LD_EXP 57
25165: PUSH
25166: LD_EXP 73
25170: AND
25171: PUSH
25172: LD_OWVAR 67
25176: PUSH
25177: LD_INT 3
25179: LESS
25180: AND
25181: IFFALSE 25200
25183: GO 25185
25185: DISABLE
// Difficulty := Difficulty + 1 ;
25186: LD_ADDR_OWVAR 67
25190: PUSH
25191: LD_OWVAR 67
25195: PUSH
25196: LD_INT 1
25198: PLUS
25199: ST_TO_ADDR
25200: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
25201: LD_EXP 57
25205: PUSH
25206: LD_EXP 74
25210: AND
25211: IFFALSE 25314
25213: GO 25215
25215: DISABLE
25216: LD_INT 0
25218: PPUSH
// begin for i := 1 to 5 do
25219: LD_ADDR_VAR 0 1
25223: PUSH
25224: DOUBLE
25225: LD_INT 1
25227: DEC
25228: ST_TO_ADDR
25229: LD_INT 5
25231: PUSH
25232: FOR_TO
25233: IFFALSE 25312
// begin uc_nation := nation_nature ;
25235: LD_ADDR_OWVAR 21
25239: PUSH
25240: LD_INT 0
25242: ST_TO_ADDR
// uc_side := 0 ;
25243: LD_ADDR_OWVAR 20
25247: PUSH
25248: LD_INT 0
25250: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
25251: LD_ADDR_OWVAR 29
25255: PUSH
25256: LD_INT 12
25258: PUSH
25259: LD_INT 12
25261: PUSH
25262: EMPTY
25263: LIST
25264: LIST
25265: ST_TO_ADDR
// hc_agressivity := 20 ;
25266: LD_ADDR_OWVAR 35
25270: PUSH
25271: LD_INT 20
25273: ST_TO_ADDR
// hc_class := class_tiger ;
25274: LD_ADDR_OWVAR 28
25278: PUSH
25279: LD_INT 14
25281: ST_TO_ADDR
// hc_gallery :=  ;
25282: LD_ADDR_OWVAR 33
25286: PUSH
25287: LD_STRING 
25289: ST_TO_ADDR
// hc_name :=  ;
25290: LD_ADDR_OWVAR 26
25294: PUSH
25295: LD_STRING 
25297: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
25298: CALL_OW 44
25302: PPUSH
25303: LD_INT 0
25305: PPUSH
25306: CALL_OW 51
// end ;
25310: GO 25232
25312: POP
25313: POP
// end ;
25314: PPOPN 1
25316: END
// every 0 0$1 trigger StreamModeActive and sBomb do var i , x , y , result ;
25317: LD_EXP 57
25321: PUSH
25322: LD_EXP 75
25326: AND
25327: IFFALSE 25501
25329: GO 25331
25331: DISABLE
25332: LD_INT 0
25334: PPUSH
25335: PPUSH
25336: PPUSH
25337: PPUSH
// begin result := false ;
25338: LD_ADDR_VAR 0 4
25342: PUSH
25343: LD_INT 0
25345: ST_TO_ADDR
// for i := 1 to 8 do
25346: LD_ADDR_VAR 0 1
25350: PUSH
25351: DOUBLE
25352: LD_INT 1
25354: DEC
25355: ST_TO_ADDR
25356: LD_INT 8
25358: PUSH
25359: FOR_TO
25360: IFFALSE 25471
// begin x := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
25362: LD_ADDR_VAR 0 2
25366: PUSH
25367: LD_INT 10
25369: PUSH
25370: LD_INT 50
25372: PUSH
25373: LD_INT 90
25375: PUSH
25376: LD_INT 140
25378: PUSH
25379: EMPTY
25380: LIST
25381: LIST
25382: LIST
25383: LIST
25384: PUSH
25385: LD_INT 1
25387: PPUSH
25388: LD_INT 4
25390: PPUSH
25391: CALL_OW 12
25395: ARRAY
25396: ST_TO_ADDR
// y := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
25397: LD_ADDR_VAR 0 3
25401: PUSH
25402: LD_INT 10
25404: PUSH
25405: LD_INT 50
25407: PUSH
25408: LD_INT 90
25410: PUSH
25411: LD_INT 140
25413: PUSH
25414: EMPTY
25415: LIST
25416: LIST
25417: LIST
25418: LIST
25419: PUSH
25420: LD_INT 1
25422: PPUSH
25423: LD_INT 4
25425: PPUSH
25426: CALL_OW 12
25430: ARRAY
25431: ST_TO_ADDR
// if ValidHex ( x , y ) then
25432: LD_VAR 0 2
25436: PPUSH
25437: LD_VAR 0 3
25441: PPUSH
25442: CALL_OW 488
25446: IFFALSE 25469
// begin result := [ x , y ] ;
25448: LD_ADDR_VAR 0 4
25452: PUSH
25453: LD_VAR 0 2
25457: PUSH
25458: LD_VAR 0 3
25462: PUSH
25463: EMPTY
25464: LIST
25465: LIST
25466: ST_TO_ADDR
// break ;
25467: GO 25471
// end ; end ;
25469: GO 25359
25471: POP
25472: POP
// if result then
25473: LD_VAR 0 4
25477: IFFALSE 25501
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
25479: LD_VAR 0 4
25483: PUSH
25484: LD_INT 1
25486: ARRAY
25487: PPUSH
25488: LD_VAR 0 4
25492: PUSH
25493: LD_INT 2
25495: ARRAY
25496: PPUSH
25497: CALL_OW 429
// end ;
25501: PPOPN 4
25503: END
// every 0 0$1 trigger StreamModeActive and sReset do
25504: LD_EXP 57
25508: PUSH
25509: LD_EXP 77
25513: AND
25514: IFFALSE 25526
25516: GO 25518
25518: DISABLE
// YouLost (  ) ;
25519: LD_STRING 
25521: PPUSH
25522: CALL_OW 104
25526: END
// every 0 0$1 trigger StreamModeActive and sFog do
25527: LD_EXP 57
25531: PUSH
25532: LD_EXP 76
25536: AND
25537: IFFALSE 25551
25539: GO 25541
25541: DISABLE
// FogOff ( your_side ) ;
25542: LD_OWVAR 2
25546: PPUSH
25547: CALL_OW 344
25551: END
// every 0 0$1 trigger StreamModeActive and sSun do
25552: LD_EXP 57
25556: PUSH
25557: LD_EXP 78
25561: AND
25562: IFFALSE 25590
25564: GO 25566
25566: DISABLE
// begin solar_recharge_percent := 0 ;
25567: LD_ADDR_OWVAR 79
25571: PUSH
25572: LD_INT 0
25574: ST_TO_ADDR
// wait ( 5 5$00 ) ;
25575: LD_INT 10500
25577: PPUSH
25578: CALL_OW 67
// solar_recharge_percent := 100 ;
25582: LD_ADDR_OWVAR 79
25586: PUSH
25587: LD_INT 100
25589: ST_TO_ADDR
// end ;
25590: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
25591: LD_EXP 57
25595: PUSH
25596: LD_EXP 79
25600: AND
25601: IFFALSE 25840
25603: GO 25605
25605: DISABLE
25606: LD_INT 0
25608: PPUSH
25609: PPUSH
25610: PPUSH
// begin tmp := [ ] ;
25611: LD_ADDR_VAR 0 3
25615: PUSH
25616: EMPTY
25617: ST_TO_ADDR
// for i := 1 to 6 do
25618: LD_ADDR_VAR 0 1
25622: PUSH
25623: DOUBLE
25624: LD_INT 1
25626: DEC
25627: ST_TO_ADDR
25628: LD_INT 6
25630: PUSH
25631: FOR_TO
25632: IFFALSE 25737
// begin uc_nation := nation_nature ;
25634: LD_ADDR_OWVAR 21
25638: PUSH
25639: LD_INT 0
25641: ST_TO_ADDR
// uc_side := 0 ;
25642: LD_ADDR_OWVAR 20
25646: PUSH
25647: LD_INT 0
25649: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
25650: LD_ADDR_OWVAR 29
25654: PUSH
25655: LD_INT 12
25657: PUSH
25658: LD_INT 12
25660: PUSH
25661: EMPTY
25662: LIST
25663: LIST
25664: ST_TO_ADDR
// hc_agressivity := 20 ;
25665: LD_ADDR_OWVAR 35
25669: PUSH
25670: LD_INT 20
25672: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
25673: LD_ADDR_OWVAR 28
25677: PUSH
25678: LD_INT 17
25680: ST_TO_ADDR
// hc_gallery :=  ;
25681: LD_ADDR_OWVAR 33
25685: PUSH
25686: LD_STRING 
25688: ST_TO_ADDR
// hc_name :=  ;
25689: LD_ADDR_OWVAR 26
25693: PUSH
25694: LD_STRING 
25696: ST_TO_ADDR
// un := CreateHuman ;
25697: LD_ADDR_VAR 0 2
25701: PUSH
25702: CALL_OW 44
25706: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
25707: LD_VAR 0 2
25711: PPUSH
25712: LD_INT 1
25714: PPUSH
25715: CALL_OW 51
// tmp := tmp * un ;
25719: LD_ADDR_VAR 0 3
25723: PUSH
25724: LD_VAR 0 3
25728: PUSH
25729: LD_VAR 0 2
25733: MUL
25734: ST_TO_ADDR
// end ;
25735: GO 25631
25737: POP
25738: POP
// repeat wait ( 0 0$1 ) ;
25739: LD_INT 35
25741: PPUSH
25742: CALL_OW 67
// for un in tmp do
25746: LD_ADDR_VAR 0 2
25750: PUSH
25751: LD_VAR 0 3
25755: PUSH
25756: FOR_IN
25757: IFFALSE 25831
// begin if IsDead ( un ) then
25759: LD_VAR 0 2
25763: PPUSH
25764: CALL_OW 301
25768: IFFALSE 25788
// begin tmp := tmp diff un ;
25770: LD_ADDR_VAR 0 3
25774: PUSH
25775: LD_VAR 0 3
25779: PUSH
25780: LD_VAR 0 2
25784: DIFF
25785: ST_TO_ADDR
// continue ;
25786: GO 25756
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
25788: LD_VAR 0 2
25792: PPUSH
25793: LD_INT 3
25795: PUSH
25796: LD_INT 22
25798: PUSH
25799: LD_INT 0
25801: PUSH
25802: EMPTY
25803: LIST
25804: LIST
25805: PUSH
25806: EMPTY
25807: LIST
25808: LIST
25809: PPUSH
25810: CALL_OW 69
25814: PPUSH
25815: LD_VAR 0 2
25819: PPUSH
25820: CALL_OW 74
25824: PPUSH
25825: CALL_OW 115
// end ;
25829: GO 25756
25831: POP
25832: POP
// until not tmp ;
25833: LD_VAR 0 3
25837: NOT
25838: IFFALSE 25739
// end ;
25840: PPOPN 3
25842: END
// every 0 0$1 trigger StreamModeActive and sTroll do
25843: LD_EXP 57
25847: PUSH
25848: LD_EXP 80
25852: AND
25853: IFFALSE 25879
25855: GO 25857
25857: DISABLE
// begin ToLua ( displayTroll(); ) ;
25858: LD_STRING displayTroll();
25860: PPUSH
25861: CALL_OW 559
// wait ( 3 3$00 ) ;
25865: LD_INT 6300
25867: PPUSH
25868: CALL_OW 67
// ToLua ( hideTroll(); ) ;
25872: LD_STRING hideTroll();
25874: PPUSH
25875: CALL_OW 559
// end ;
25879: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
25880: LD_EXP 57
25884: PUSH
25885: LD_EXP 81
25889: AND
25890: IFFALSE 25953
25892: GO 25894
25894: DISABLE
25895: LD_INT 0
25897: PPUSH
// begin p := 0 ;
25898: LD_ADDR_VAR 0 1
25902: PUSH
25903: LD_INT 0
25905: ST_TO_ADDR
// repeat game_speed := 1 ;
25906: LD_ADDR_OWVAR 65
25910: PUSH
25911: LD_INT 1
25913: ST_TO_ADDR
// wait ( 0 0$1 ) ;
25914: LD_INT 35
25916: PPUSH
25917: CALL_OW 67
// p := p + 1 ;
25921: LD_ADDR_VAR 0 1
25925: PUSH
25926: LD_VAR 0 1
25930: PUSH
25931: LD_INT 1
25933: PLUS
25934: ST_TO_ADDR
// until p >= 60 ;
25935: LD_VAR 0 1
25939: PUSH
25940: LD_INT 60
25942: GREATEREQUAL
25943: IFFALSE 25906
// game_speed := 4 ;
25945: LD_ADDR_OWVAR 65
25949: PUSH
25950: LD_INT 4
25952: ST_TO_ADDR
// end ;
25953: PPOPN 1
25955: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
25956: LD_EXP 57
25960: PUSH
25961: LD_EXP 82
25965: AND
25966: IFFALSE 26112
25968: GO 25970
25970: DISABLE
25971: LD_INT 0
25973: PPUSH
25974: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
25975: LD_ADDR_VAR 0 1
25979: PUSH
25980: LD_INT 22
25982: PUSH
25983: LD_OWVAR 2
25987: PUSH
25988: EMPTY
25989: LIST
25990: LIST
25991: PUSH
25992: LD_INT 2
25994: PUSH
25995: LD_INT 30
25997: PUSH
25998: LD_INT 0
26000: PUSH
26001: EMPTY
26002: LIST
26003: LIST
26004: PUSH
26005: LD_INT 30
26007: PUSH
26008: LD_INT 1
26010: PUSH
26011: EMPTY
26012: LIST
26013: LIST
26014: PUSH
26015: EMPTY
26016: LIST
26017: LIST
26018: LIST
26019: PUSH
26020: EMPTY
26021: LIST
26022: LIST
26023: PPUSH
26024: CALL_OW 69
26028: ST_TO_ADDR
// if not depot then
26029: LD_VAR 0 1
26033: NOT
26034: IFFALSE 26038
// exit ;
26036: GO 26112
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
26038: LD_ADDR_VAR 0 2
26042: PUSH
26043: LD_VAR 0 1
26047: PUSH
26048: LD_INT 1
26050: PPUSH
26051: LD_VAR 0 1
26055: PPUSH
26056: CALL_OW 12
26060: ARRAY
26061: PPUSH
26062: CALL_OW 274
26066: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
26067: LD_VAR 0 2
26071: PPUSH
26072: LD_INT 1
26074: PPUSH
26075: LD_INT 0
26077: PPUSH
26078: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
26082: LD_VAR 0 2
26086: PPUSH
26087: LD_INT 2
26089: PPUSH
26090: LD_INT 0
26092: PPUSH
26093: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
26097: LD_VAR 0 2
26101: PPUSH
26102: LD_INT 3
26104: PPUSH
26105: LD_INT 0
26107: PPUSH
26108: CALL_OW 277
// end ;
26112: PPOPN 2
26114: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
26115: LD_EXP 57
26119: PUSH
26120: LD_EXP 83
26124: AND
26125: IFFALSE 26222
26127: GO 26129
26129: DISABLE
26130: LD_INT 0
26132: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
26133: LD_ADDR_VAR 0 1
26137: PUSH
26138: LD_INT 22
26140: PUSH
26141: LD_OWVAR 2
26145: PUSH
26146: EMPTY
26147: LIST
26148: LIST
26149: PUSH
26150: LD_INT 21
26152: PUSH
26153: LD_INT 1
26155: PUSH
26156: EMPTY
26157: LIST
26158: LIST
26159: PUSH
26160: LD_INT 3
26162: PUSH
26163: LD_INT 23
26165: PUSH
26166: LD_INT 0
26168: PUSH
26169: EMPTY
26170: LIST
26171: LIST
26172: PUSH
26173: EMPTY
26174: LIST
26175: LIST
26176: PUSH
26177: EMPTY
26178: LIST
26179: LIST
26180: LIST
26181: PPUSH
26182: CALL_OW 69
26186: ST_TO_ADDR
// if not tmp then
26187: LD_VAR 0 1
26191: NOT
26192: IFFALSE 26196
// exit ;
26194: GO 26222
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
26196: LD_VAR 0 1
26200: PUSH
26201: LD_INT 1
26203: PPUSH
26204: LD_VAR 0 1
26208: PPUSH
26209: CALL_OW 12
26213: ARRAY
26214: PPUSH
26215: LD_INT 200
26217: PPUSH
26218: CALL_OW 234
// end ;
26222: PPOPN 1
26224: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
26225: LD_EXP 57
26229: PUSH
26230: LD_EXP 84
26234: AND
26235: IFFALSE 26314
26237: GO 26239
26239: DISABLE
26240: LD_INT 0
26242: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
26243: LD_ADDR_VAR 0 1
26247: PUSH
26248: LD_INT 22
26250: PUSH
26251: LD_OWVAR 2
26255: PUSH
26256: EMPTY
26257: LIST
26258: LIST
26259: PUSH
26260: LD_INT 21
26262: PUSH
26263: LD_INT 2
26265: PUSH
26266: EMPTY
26267: LIST
26268: LIST
26269: PUSH
26270: EMPTY
26271: LIST
26272: LIST
26273: PPUSH
26274: CALL_OW 69
26278: ST_TO_ADDR
// if not tmp then
26279: LD_VAR 0 1
26283: NOT
26284: IFFALSE 26288
// exit ;
26286: GO 26314
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
26288: LD_VAR 0 1
26292: PUSH
26293: LD_INT 1
26295: PPUSH
26296: LD_VAR 0 1
26300: PPUSH
26301: CALL_OW 12
26305: ARRAY
26306: PPUSH
26307: LD_INT 60
26309: PPUSH
26310: CALL_OW 234
// end ;
26314: PPOPN 1
26316: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
26317: LD_EXP 57
26321: PUSH
26322: LD_EXP 85
26326: AND
26327: IFFALSE 26426
26329: GO 26331
26331: DISABLE
26332: LD_INT 0
26334: PPUSH
26335: PPUSH
// begin enable ;
26336: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
26337: LD_ADDR_VAR 0 1
26341: PUSH
26342: LD_INT 22
26344: PUSH
26345: LD_OWVAR 2
26349: PUSH
26350: EMPTY
26351: LIST
26352: LIST
26353: PUSH
26354: LD_INT 61
26356: PUSH
26357: EMPTY
26358: LIST
26359: PUSH
26360: LD_INT 33
26362: PUSH
26363: LD_INT 2
26365: PUSH
26366: EMPTY
26367: LIST
26368: LIST
26369: PUSH
26370: EMPTY
26371: LIST
26372: LIST
26373: LIST
26374: PPUSH
26375: CALL_OW 69
26379: ST_TO_ADDR
// if not tmp then
26380: LD_VAR 0 1
26384: NOT
26385: IFFALSE 26389
// exit ;
26387: GO 26426
// for i in tmp do
26389: LD_ADDR_VAR 0 2
26393: PUSH
26394: LD_VAR 0 1
26398: PUSH
26399: FOR_IN
26400: IFFALSE 26424
// if IsControledBy ( i ) then
26402: LD_VAR 0 2
26406: PPUSH
26407: CALL_OW 312
26411: IFFALSE 26422
// ComUnlink ( i ) ;
26413: LD_VAR 0 2
26417: PPUSH
26418: CALL_OW 136
26422: GO 26399
26424: POP
26425: POP
// end ;
26426: PPOPN 2
26428: END
// every 0 0$1 trigger StreamModeActive and sPowell do
26429: LD_EXP 57
26433: PUSH
26434: LD_EXP 86
26438: AND
26439: IFFALSE 26479
26441: GO 26443
26443: DISABLE
// begin ToLua ( displayPowell(); ) ;
26444: LD_STRING displayPowell();
26446: PPUSH
26447: CALL_OW 559
// wait ( 0 0$20 ) ;
26451: LD_INT 700
26453: PPUSH
26454: CALL_OW 67
// ToLua ( displayPowell(); ) ;
26458: LD_STRING displayPowell();
26460: PPUSH
26461: CALL_OW 559
// wait ( 0 0$40 ) ;
26465: LD_INT 1400
26467: PPUSH
26468: CALL_OW 67
// ToLua ( displayPowell(); ) ;
26472: LD_STRING displayPowell();
26474: PPUSH
26475: CALL_OW 559
// end ;
26479: END
// every 0 0$1 trigger StreamModeActive and sStu do
26480: LD_EXP 57
26484: PUSH
26485: LD_EXP 94
26489: AND
26490: IFFALSE 26502
26492: GO 26494
26494: DISABLE
// begin ToLua ( displayStucuk(); ) ;
26495: LD_STRING displayStucuk();
26497: PPUSH
26498: CALL_OW 559
// end ;
26502: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
26503: LD_EXP 57
26507: PUSH
26508: LD_EXP 87
26512: AND
26513: IFFALSE 26654
26515: GO 26517
26517: DISABLE
26518: LD_INT 0
26520: PPUSH
26521: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
26522: LD_ADDR_VAR 0 2
26526: PUSH
26527: LD_INT 22
26529: PUSH
26530: LD_OWVAR 2
26534: PUSH
26535: EMPTY
26536: LIST
26537: LIST
26538: PUSH
26539: LD_INT 21
26541: PUSH
26542: LD_INT 1
26544: PUSH
26545: EMPTY
26546: LIST
26547: LIST
26548: PUSH
26549: EMPTY
26550: LIST
26551: LIST
26552: PPUSH
26553: CALL_OW 69
26557: ST_TO_ADDR
// if not tmp then
26558: LD_VAR 0 2
26562: NOT
26563: IFFALSE 26567
// exit ;
26565: GO 26654
// un := tmp [ rand ( 1 , tmp ) ] ;
26567: LD_ADDR_VAR 0 1
26571: PUSH
26572: LD_VAR 0 2
26576: PUSH
26577: LD_INT 1
26579: PPUSH
26580: LD_VAR 0 2
26584: PPUSH
26585: CALL_OW 12
26589: ARRAY
26590: ST_TO_ADDR
// SetSide ( un , 0 ) ;
26591: LD_VAR 0 1
26595: PPUSH
26596: LD_INT 0
26598: PPUSH
26599: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
26603: LD_VAR 0 1
26607: PPUSH
26608: LD_OWVAR 3
26612: PUSH
26613: LD_VAR 0 1
26617: DIFF
26618: PPUSH
26619: LD_VAR 0 1
26623: PPUSH
26624: CALL_OW 74
26628: PPUSH
26629: CALL_OW 115
// wait ( 0 0$20 ) ;
26633: LD_INT 700
26635: PPUSH
26636: CALL_OW 67
// SetSide ( un , your_side ) ;
26640: LD_VAR 0 1
26644: PPUSH
26645: LD_OWVAR 2
26649: PPUSH
26650: CALL_OW 235
// end ;
26654: PPOPN 2
26656: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
26657: LD_EXP 57
26661: PUSH
26662: LD_EXP 88
26666: AND
26667: IFFALSE 26773
26669: GO 26671
26671: DISABLE
26672: LD_INT 0
26674: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
26675: LD_ADDR_VAR 0 1
26679: PUSH
26680: LD_INT 22
26682: PUSH
26683: LD_OWVAR 2
26687: PUSH
26688: EMPTY
26689: LIST
26690: LIST
26691: PUSH
26692: LD_INT 2
26694: PUSH
26695: LD_INT 30
26697: PUSH
26698: LD_INT 0
26700: PUSH
26701: EMPTY
26702: LIST
26703: LIST
26704: PUSH
26705: LD_INT 30
26707: PUSH
26708: LD_INT 1
26710: PUSH
26711: EMPTY
26712: LIST
26713: LIST
26714: PUSH
26715: EMPTY
26716: LIST
26717: LIST
26718: LIST
26719: PUSH
26720: EMPTY
26721: LIST
26722: LIST
26723: PPUSH
26724: CALL_OW 69
26728: ST_TO_ADDR
// if not depot then
26729: LD_VAR 0 1
26733: NOT
26734: IFFALSE 26738
// exit ;
26736: GO 26773
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
26738: LD_VAR 0 1
26742: PUSH
26743: LD_INT 1
26745: ARRAY
26746: PPUSH
26747: CALL_OW 250
26751: PPUSH
26752: LD_VAR 0 1
26756: PUSH
26757: LD_INT 1
26759: ARRAY
26760: PPUSH
26761: CALL_OW 251
26765: PPUSH
26766: LD_INT 70
26768: PPUSH
26769: CALL_OW 495
// end ;
26773: PPOPN 1
26775: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
26776: LD_EXP 57
26780: PUSH
26781: LD_EXP 89
26785: AND
26786: IFFALSE 26997
26788: GO 26790
26790: DISABLE
26791: LD_INT 0
26793: PPUSH
26794: PPUSH
26795: PPUSH
26796: PPUSH
26797: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
26798: LD_ADDR_VAR 0 5
26802: PUSH
26803: LD_INT 22
26805: PUSH
26806: LD_OWVAR 2
26810: PUSH
26811: EMPTY
26812: LIST
26813: LIST
26814: PUSH
26815: LD_INT 21
26817: PUSH
26818: LD_INT 1
26820: PUSH
26821: EMPTY
26822: LIST
26823: LIST
26824: PUSH
26825: EMPTY
26826: LIST
26827: LIST
26828: PPUSH
26829: CALL_OW 69
26833: ST_TO_ADDR
// if not tmp then
26834: LD_VAR 0 5
26838: NOT
26839: IFFALSE 26843
// exit ;
26841: GO 26997
// for i in tmp do
26843: LD_ADDR_VAR 0 1
26847: PUSH
26848: LD_VAR 0 5
26852: PUSH
26853: FOR_IN
26854: IFFALSE 26995
// begin d := rand ( 0 , 5 ) ;
26856: LD_ADDR_VAR 0 4
26860: PUSH
26861: LD_INT 0
26863: PPUSH
26864: LD_INT 5
26866: PPUSH
26867: CALL_OW 12
26871: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
26872: LD_ADDR_VAR 0 2
26876: PUSH
26877: LD_VAR 0 1
26881: PPUSH
26882: CALL_OW 250
26886: PPUSH
26887: LD_VAR 0 4
26891: PPUSH
26892: LD_INT 3
26894: PPUSH
26895: LD_INT 12
26897: PPUSH
26898: CALL_OW 12
26902: PPUSH
26903: CALL_OW 272
26907: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
26908: LD_ADDR_VAR 0 3
26912: PUSH
26913: LD_VAR 0 1
26917: PPUSH
26918: CALL_OW 251
26922: PPUSH
26923: LD_VAR 0 4
26927: PPUSH
26928: LD_INT 3
26930: PPUSH
26931: LD_INT 12
26933: PPUSH
26934: CALL_OW 12
26938: PPUSH
26939: CALL_OW 273
26943: ST_TO_ADDR
// if ValidHex ( x , y ) then
26944: LD_VAR 0 2
26948: PPUSH
26949: LD_VAR 0 3
26953: PPUSH
26954: CALL_OW 488
26958: IFFALSE 26993
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
26960: LD_VAR 0 1
26964: PPUSH
26965: LD_VAR 0 2
26969: PPUSH
26970: LD_VAR 0 3
26974: PPUSH
26975: LD_INT 3
26977: PPUSH
26978: LD_INT 6
26980: PPUSH
26981: CALL_OW 12
26985: PPUSH
26986: LD_INT 1
26988: PPUSH
26989: CALL_OW 483
// end ;
26993: GO 26853
26995: POP
26996: POP
// end ;
26997: PPOPN 5
26999: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
27000: LD_EXP 57
27004: PUSH
27005: LD_EXP 90
27009: AND
27010: IFFALSE 27104
27012: GO 27014
27014: DISABLE
27015: LD_INT 0
27017: PPUSH
27018: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
27019: LD_ADDR_VAR 0 2
27023: PUSH
27024: LD_INT 22
27026: PUSH
27027: LD_OWVAR 2
27031: PUSH
27032: EMPTY
27033: LIST
27034: LIST
27035: PUSH
27036: LD_INT 32
27038: PUSH
27039: LD_INT 1
27041: PUSH
27042: EMPTY
27043: LIST
27044: LIST
27045: PUSH
27046: LD_INT 21
27048: PUSH
27049: LD_INT 2
27051: PUSH
27052: EMPTY
27053: LIST
27054: LIST
27055: PUSH
27056: EMPTY
27057: LIST
27058: LIST
27059: LIST
27060: PPUSH
27061: CALL_OW 69
27065: ST_TO_ADDR
// if not tmp then
27066: LD_VAR 0 2
27070: NOT
27071: IFFALSE 27075
// exit ;
27073: GO 27104
// for i in tmp do
27075: LD_ADDR_VAR 0 1
27079: PUSH
27080: LD_VAR 0 2
27084: PUSH
27085: FOR_IN
27086: IFFALSE 27102
// SetFuel ( i , 0 ) ;
27088: LD_VAR 0 1
27092: PPUSH
27093: LD_INT 0
27095: PPUSH
27096: CALL_OW 240
27100: GO 27085
27102: POP
27103: POP
// end ;
27104: PPOPN 2
27106: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
27107: LD_EXP 57
27111: PUSH
27112: LD_EXP 91
27116: AND
27117: IFFALSE 27183
27119: GO 27121
27121: DISABLE
27122: LD_INT 0
27124: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
27125: LD_ADDR_VAR 0 1
27129: PUSH
27130: LD_INT 22
27132: PUSH
27133: LD_OWVAR 2
27137: PUSH
27138: EMPTY
27139: LIST
27140: LIST
27141: PUSH
27142: LD_INT 30
27144: PUSH
27145: LD_INT 29
27147: PUSH
27148: EMPTY
27149: LIST
27150: LIST
27151: PUSH
27152: EMPTY
27153: LIST
27154: LIST
27155: PPUSH
27156: CALL_OW 69
27160: ST_TO_ADDR
// if not tmp then
27161: LD_VAR 0 1
27165: NOT
27166: IFFALSE 27170
// exit ;
27168: GO 27183
// DestroyUnit ( tmp [ 1 ] ) ;
27170: LD_VAR 0 1
27174: PUSH
27175: LD_INT 1
27177: ARRAY
27178: PPUSH
27179: CALL_OW 65
// end ;
27183: PPOPN 1
27185: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
27186: LD_EXP 57
27190: PUSH
27191: LD_EXP 93
27195: AND
27196: IFFALSE 27309
27198: GO 27200
27200: DISABLE
27201: LD_INT 0
27203: PPUSH
// begin uc_side := 0 ;
27204: LD_ADDR_OWVAR 20
27208: PUSH
27209: LD_INT 0
27211: ST_TO_ADDR
// uc_nation := nation_arabian ;
27212: LD_ADDR_OWVAR 21
27216: PUSH
27217: LD_INT 2
27219: ST_TO_ADDR
// PrepareHuman ( sex_male , 10 , class_desert_warior ) ;
27220: LD_INT 1
27222: PPUSH
27223: LD_INT 10
27225: PPUSH
27226: LD_INT 11
27228: PPUSH
27229: CALL_OW 380
// un := CreateHuman ;
27233: LD_ADDR_VAR 0 1
27237: PUSH
27238: CALL_OW 44
27242: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
27243: LD_VAR 0 1
27247: PPUSH
27248: LD_INT 1
27250: PPUSH
27251: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
27255: LD_INT 35
27257: PPUSH
27258: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
27262: LD_VAR 0 1
27266: PPUSH
27267: LD_INT 22
27269: PUSH
27270: LD_OWVAR 2
27274: PUSH
27275: EMPTY
27276: LIST
27277: LIST
27278: PPUSH
27279: CALL_OW 69
27283: PPUSH
27284: LD_VAR 0 1
27288: PPUSH
27289: CALL_OW 74
27293: PPUSH
27294: CALL_OW 115
// until IsDead ( un ) ;
27298: LD_VAR 0 1
27302: PPUSH
27303: CALL_OW 301
27307: IFFALSE 27255
// end ; end_of_file
27309: PPOPN 1
27311: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
27312: LD_INT 0
27314: PPUSH
27315: PPUSH
27316: PPUSH
27317: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
27318: LD_VAR 0 1
27322: PPUSH
27323: CALL_OW 264
27327: PUSH
27328: LD_EXP 56
27332: EQUAL
27333: IFFALSE 27405
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
27335: LD_INT 68
27337: PPUSH
27338: LD_VAR 0 1
27342: PPUSH
27343: CALL_OW 255
27347: PPUSH
27348: CALL_OW 321
27352: PUSH
27353: LD_INT 2
27355: EQUAL
27356: IFFALSE 27368
// eff := 70 else
27358: LD_ADDR_VAR 0 6
27362: PUSH
27363: LD_INT 70
27365: ST_TO_ADDR
27366: GO 27376
// eff := 30 ;
27368: LD_ADDR_VAR 0 6
27372: PUSH
27373: LD_INT 30
27375: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
27376: LD_VAR 0 1
27380: PPUSH
27381: CALL_OW 250
27385: PPUSH
27386: LD_VAR 0 1
27390: PPUSH
27391: CALL_OW 251
27395: PPUSH
27396: LD_VAR 0 6
27400: PPUSH
27401: CALL_OW 495
// end ; end ;
27405: LD_VAR 0 4
27409: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
27410: LD_INT 0
27412: PPUSH
27413: PPUSH
27414: PPUSH
27415: PPUSH
27416: PPUSH
27417: PPUSH
// if cmd = 124 then
27418: LD_VAR 0 1
27422: PUSH
27423: LD_INT 124
27425: EQUAL
27426: IFFALSE 27632
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
27428: LD_ADDR_VAR 0 5
27432: PUSH
27433: LD_INT 2
27435: PUSH
27436: LD_INT 34
27438: PUSH
27439: LD_INT 53
27441: PUSH
27442: EMPTY
27443: LIST
27444: LIST
27445: PUSH
27446: LD_INT 34
27448: PUSH
27449: LD_INT 14
27451: PUSH
27452: EMPTY
27453: LIST
27454: LIST
27455: PUSH
27456: EMPTY
27457: LIST
27458: LIST
27459: LIST
27460: PPUSH
27461: CALL_OW 69
27465: ST_TO_ADDR
// if not tmp then
27466: LD_VAR 0 5
27470: NOT
27471: IFFALSE 27475
// exit ;
27473: GO 27632
// for i in tmp do
27475: LD_ADDR_VAR 0 3
27479: PUSH
27480: LD_VAR 0 5
27484: PUSH
27485: FOR_IN
27486: IFFALSE 27630
// begin taskList := GetTaskList ( i ) ;
27488: LD_ADDR_VAR 0 6
27492: PUSH
27493: LD_VAR 0 3
27497: PPUSH
27498: CALL_OW 437
27502: ST_TO_ADDR
// if not taskList then
27503: LD_VAR 0 6
27507: NOT
27508: IFFALSE 27512
// continue ;
27510: GO 27485
// for j = 1 to taskList do
27512: LD_ADDR_VAR 0 4
27516: PUSH
27517: DOUBLE
27518: LD_INT 1
27520: DEC
27521: ST_TO_ADDR
27522: LD_VAR 0 6
27526: PUSH
27527: FOR_TO
27528: IFFALSE 27626
// if taskList [ j ] [ 1 ] = | then
27530: LD_VAR 0 6
27534: PUSH
27535: LD_VAR 0 4
27539: ARRAY
27540: PUSH
27541: LD_INT 1
27543: ARRAY
27544: PUSH
27545: LD_STRING |
27547: EQUAL
27548: IFFALSE 27624
// begin _taskList := Delete ( taskList , 1 ) ;
27550: LD_ADDR_VAR 0 7
27554: PUSH
27555: LD_VAR 0 6
27559: PPUSH
27560: LD_INT 1
27562: PPUSH
27563: CALL_OW 3
27567: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
27568: LD_VAR 0 3
27572: PPUSH
27573: LD_VAR 0 7
27577: PPUSH
27578: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
27582: LD_VAR 0 3
27586: PPUSH
27587: LD_VAR 0 6
27591: PUSH
27592: LD_VAR 0 4
27596: ARRAY
27597: PUSH
27598: LD_INT 2
27600: ARRAY
27601: PPUSH
27602: LD_VAR 0 6
27606: PUSH
27607: LD_VAR 0 4
27611: ARRAY
27612: PUSH
27613: LD_INT 3
27615: ARRAY
27616: PPUSH
27617: LD_INT 8
27619: PPUSH
27620: CALL 27637 0 4
// end ;
27624: GO 27527
27626: POP
27627: POP
// end ;
27628: GO 27485
27630: POP
27631: POP
// end ; end ;
27632: LD_VAR 0 2
27636: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
27637: LD_INT 0
27639: PPUSH
27640: PPUSH
27641: PPUSH
27642: PPUSH
27643: PPUSH
27644: PPUSH
27645: PPUSH
27646: PPUSH
27647: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
27648: LD_VAR 0 1
27652: NOT
27653: PUSH
27654: LD_VAR 0 2
27658: PPUSH
27659: LD_VAR 0 3
27663: PPUSH
27664: CALL_OW 488
27668: NOT
27669: OR
27670: PUSH
27671: LD_VAR 0 4
27675: NOT
27676: OR
27677: IFFALSE 27681
// exit ;
27679: GO 28021
// list := [ ] ;
27681: LD_ADDR_VAR 0 13
27685: PUSH
27686: EMPTY
27687: ST_TO_ADDR
// if x - r < 0 then
27688: LD_VAR 0 2
27692: PUSH
27693: LD_VAR 0 4
27697: MINUS
27698: PUSH
27699: LD_INT 0
27701: LESS
27702: IFFALSE 27714
// min_x := 0 else
27704: LD_ADDR_VAR 0 7
27708: PUSH
27709: LD_INT 0
27711: ST_TO_ADDR
27712: GO 27730
// min_x := x - r ;
27714: LD_ADDR_VAR 0 7
27718: PUSH
27719: LD_VAR 0 2
27723: PUSH
27724: LD_VAR 0 4
27728: MINUS
27729: ST_TO_ADDR
// if y - r < 0 then
27730: LD_VAR 0 3
27734: PUSH
27735: LD_VAR 0 4
27739: MINUS
27740: PUSH
27741: LD_INT 0
27743: LESS
27744: IFFALSE 27756
// min_y := 0 else
27746: LD_ADDR_VAR 0 8
27750: PUSH
27751: LD_INT 0
27753: ST_TO_ADDR
27754: GO 27772
// min_y := y - r ;
27756: LD_ADDR_VAR 0 8
27760: PUSH
27761: LD_VAR 0 3
27765: PUSH
27766: LD_VAR 0 4
27770: MINUS
27771: ST_TO_ADDR
// max_x := x + r ;
27772: LD_ADDR_VAR 0 9
27776: PUSH
27777: LD_VAR 0 2
27781: PUSH
27782: LD_VAR 0 4
27786: PLUS
27787: ST_TO_ADDR
// max_y := y + r ;
27788: LD_ADDR_VAR 0 10
27792: PUSH
27793: LD_VAR 0 3
27797: PUSH
27798: LD_VAR 0 4
27802: PLUS
27803: ST_TO_ADDR
// for _x = min_x to max_x do
27804: LD_ADDR_VAR 0 11
27808: PUSH
27809: DOUBLE
27810: LD_VAR 0 7
27814: DEC
27815: ST_TO_ADDR
27816: LD_VAR 0 9
27820: PUSH
27821: FOR_TO
27822: IFFALSE 27939
// for _y = min_y to max_y do
27824: LD_ADDR_VAR 0 12
27828: PUSH
27829: DOUBLE
27830: LD_VAR 0 8
27834: DEC
27835: ST_TO_ADDR
27836: LD_VAR 0 10
27840: PUSH
27841: FOR_TO
27842: IFFALSE 27935
// begin if not ValidHex ( _x , _y ) then
27844: LD_VAR 0 11
27848: PPUSH
27849: LD_VAR 0 12
27853: PPUSH
27854: CALL_OW 488
27858: NOT
27859: IFFALSE 27863
// continue ;
27861: GO 27841
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
27863: LD_VAR 0 11
27867: PPUSH
27868: LD_VAR 0 12
27872: PPUSH
27873: CALL_OW 351
27877: PUSH
27878: LD_VAR 0 11
27882: PPUSH
27883: LD_VAR 0 12
27887: PPUSH
27888: CALL_OW 554
27892: AND
27893: IFFALSE 27933
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
27895: LD_ADDR_VAR 0 13
27899: PUSH
27900: LD_VAR 0 13
27904: PPUSH
27905: LD_VAR 0 13
27909: PUSH
27910: LD_INT 1
27912: PLUS
27913: PPUSH
27914: LD_VAR 0 11
27918: PUSH
27919: LD_VAR 0 12
27923: PUSH
27924: EMPTY
27925: LIST
27926: LIST
27927: PPUSH
27928: CALL_OW 2
27932: ST_TO_ADDR
// end ;
27933: GO 27841
27935: POP
27936: POP
27937: GO 27821
27939: POP
27940: POP
// if not list then
27941: LD_VAR 0 13
27945: NOT
27946: IFFALSE 27950
// exit ;
27948: GO 28021
// for i in list do
27950: LD_ADDR_VAR 0 6
27954: PUSH
27955: LD_VAR 0 13
27959: PUSH
27960: FOR_IN
27961: IFFALSE 28019
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
27963: LD_VAR 0 1
27967: PPUSH
27968: LD_STRING M
27970: PUSH
27971: LD_VAR 0 6
27975: PUSH
27976: LD_INT 1
27978: ARRAY
27979: PUSH
27980: LD_VAR 0 6
27984: PUSH
27985: LD_INT 2
27987: ARRAY
27988: PUSH
27989: LD_INT 0
27991: PUSH
27992: LD_INT 0
27994: PUSH
27995: LD_INT 0
27997: PUSH
27998: LD_INT 0
28000: PUSH
28001: EMPTY
28002: LIST
28003: LIST
28004: LIST
28005: LIST
28006: LIST
28007: LIST
28008: LIST
28009: PUSH
28010: EMPTY
28011: LIST
28012: PPUSH
28013: CALL_OW 447
28017: GO 27960
28019: POP
28020: POP
// end ;
28021: LD_VAR 0 5
28025: RET
