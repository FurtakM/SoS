// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// Init ;
  15: CALL 79 0 0
// InitRestrictions ;
  19: CALL 207 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 33
// DebugMode ;
  29: CALL 288 0 0
// SpawnApeman ( apemanStartArea , 2 ) ;
  33: LD_INT 12
  35: PPUSH
  36: LD_INT 2
  38: PPUSH
  39: CALL 658 0 2
// SpawnApeman ( apemanArea , [ 10 , 8 , 7 ] [ Difficulty ] ) ;
  43: LD_INT 11
  45: PPUSH
  46: LD_INT 10
  48: PUSH
  49: LD_INT 8
  51: PUSH
  52: LD_INT 7
  54: PUSH
  55: EMPTY
  56: LIST
  57: LIST
  58: LIST
  59: PUSH
  60: LD_OWVAR 67
  64: ARRAY
  65: PPUSH
  66: CALL 658 0 2
// PrepareAmericans ;
  70: CALL 1257 0 0
// Action ;
  74: CALL 2147 0 0
// end ;
  78: END
// export debug ; export mission_prefix , mission_prefix_prev ; export deltaBuilded , denisArrives , Delta , radar_allowed , first_apeman_tamed , apeman_army , radar_researched , radar_builded ; export apeman_counter , arab_spotted , end_mission , apeKillCounter ; function Init ; begin
  79: LD_INT 0
  81: PPUSH
// debug := false ;
  82: LD_ADDR_EXP 1
  86: PUSH
  87: LD_INT 0
  89: ST_TO_ADDR
// mission_prefix := 05_ ;
  90: LD_ADDR_EXP 2
  94: PUSH
  95: LD_STRING 05_
  97: ST_TO_ADDR
// mission_prefix_prev := 05a_ ;
  98: LD_ADDR_EXP 3
 102: PUSH
 103: LD_STRING 05a_
 105: ST_TO_ADDR
// deltaBuilded := false ;
 106: LD_ADDR_EXP 4
 110: PUSH
 111: LD_INT 0
 113: ST_TO_ADDR
// denisArrives := false ;
 114: LD_ADDR_EXP 5
 118: PUSH
 119: LD_INT 0
 121: ST_TO_ADDR
// radar_allowed := false ;
 122: LD_ADDR_EXP 7
 126: PUSH
 127: LD_INT 0
 129: ST_TO_ADDR
// first_apeman_tamed := false ;
 130: LD_ADDR_EXP 8
 134: PUSH
 135: LD_INT 0
 137: ST_TO_ADDR
// arab_spotted := false ;
 138: LD_ADDR_EXP 13
 142: PUSH
 143: LD_INT 0
 145: ST_TO_ADDR
// end_mission := false ;
 146: LD_ADDR_EXP 14
 150: PUSH
 151: LD_INT 0
 153: ST_TO_ADDR
// apeman_army := false ;
 154: LD_ADDR_EXP 9
 158: PUSH
 159: LD_INT 0
 161: ST_TO_ADDR
// radar_researched := false ;
 162: LD_ADDR_EXP 10
 166: PUSH
 167: LD_INT 0
 169: ST_TO_ADDR
// radar_builded := false ;
 170: LD_ADDR_EXP 11
 174: PUSH
 175: LD_INT 0
 177: ST_TO_ADDR
// apeman_counter := 0 ;
 178: LD_ADDR_EXP 12
 182: PUSH
 183: LD_INT 0
 185: ST_TO_ADDR
// Delta := 0 ;
 186: LD_ADDR_EXP 6
 190: PUSH
 191: LD_INT 0
 193: ST_TO_ADDR
// apeKillCounter := 0 ;
 194: LD_ADDR_EXP 15
 198: PUSH
 199: LD_INT 0
 201: ST_TO_ADDR
// end ;
 202: LD_VAR 0 1
 206: RET
// function InitRestrictions ; begin
 207: LD_INT 0
 209: PPUSH
// SetRestrict ( b_lab_half , 1 , state_enabled ) ;
 210: LD_INT 7
 212: PPUSH
 213: LD_INT 1
 215: PPUSH
 216: LD_INT 1
 218: PPUSH
 219: CALL_OW 324
// SetRestrict ( b_lab_full , 1 , state_enabled ) ;
 223: LD_INT 8
 225: PPUSH
 226: LD_INT 1
 228: PPUSH
 229: LD_INT 1
 231: PPUSH
 232: CALL_OW 324
// SetRestrict ( b_lab_weapon , 1 , state_enabled ) ;
 236: LD_INT 10
 238: PPUSH
 239: LD_INT 1
 241: PPUSH
 242: LD_INT 1
 244: PPUSH
 245: CALL_OW 324
// SetTech ( tech_gatling , 1 , LoadVariable ( GatlingInGamma , 1 ) ) ;
 249: LD_INT 69
 251: PPUSH
 252: LD_INT 1
 254: PPUSH
 255: LD_STRING GatlingInGamma
 257: PPUSH
 258: LD_INT 1
 260: PPUSH
 261: CALL_OW 30
 265: PPUSH
 266: CALL_OW 322
// SetTech ( tech_weap1 , 1 , state_enabled ) ;
 270: LD_INT 51
 272: PPUSH
 273: LD_INT 1
 275: PPUSH
 276: LD_INT 1
 278: PPUSH
 279: CALL_OW 322
// end ;
 283: LD_VAR 0 1
 287: RET
// function DebugMode ; begin
 288: LD_INT 0
 290: PPUSH
// FogOff ( 1 ) ;
 291: LD_INT 1
 293: PPUSH
 294: CALL_OW 344
// Difficulty := 2 ;
 298: LD_ADDR_OWVAR 67
 302: PUSH
 303: LD_INT 2
 305: ST_TO_ADDR
// end ;
 306: LD_VAR 0 1
 310: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 0 ] ] ) >= 7 do
 311: LD_INT 22
 313: PUSH
 314: LD_INT 1
 316: PUSH
 317: EMPTY
 318: LIST
 319: LIST
 320: PUSH
 321: LD_INT 23
 323: PUSH
 324: LD_INT 0
 326: PUSH
 327: EMPTY
 328: LIST
 329: LIST
 330: PUSH
 331: EMPTY
 332: LIST
 333: LIST
 334: PPUSH
 335: CALL_OW 69
 339: PUSH
 340: LD_INT 7
 342: GREATEREQUAL
 343: IFFALSE 355
 345: GO 347
 347: DISABLE
// SetAchievement ( ACH_TAME ) ;
 348: LD_STRING ACH_TAME
 350: PPUSH
 351: CALL_OW 543
 355: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_bweapon , us_radar ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) do
 356: LD_INT 22
 358: PUSH
 359: LD_INT 1
 361: PUSH
 362: EMPTY
 363: LIST
 364: LIST
 365: PUSH
 366: LD_INT 35
 368: PUSH
 369: LD_INT 11
 371: PUSH
 372: EMPTY
 373: LIST
 374: LIST
 375: PUSH
 376: EMPTY
 377: LIST
 378: LIST
 379: PPUSH
 380: CALL_OW 69
 384: PUSH
 385: LD_INT 22
 387: PUSH
 388: LD_INT 1
 390: PUSH
 391: EMPTY
 392: LIST
 393: LIST
 394: PUSH
 395: LD_INT 34
 397: PUSH
 398: LD_INT 11
 400: PUSH
 401: EMPTY
 402: LIST
 403: LIST
 404: PUSH
 405: EMPTY
 406: LIST
 407: LIST
 408: PPUSH
 409: CALL_OW 69
 413: AND
 414: IFFALSE 426
 416: GO 418
 418: DISABLE
// SetAchievement ( ACH_RADAR ) ; end_of_file
 419: LD_STRING ACH_RADAR
 421: PPUSH
 422: CALL_OW 543
 426: END
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 427: LD_INT 0
 429: PPUSH
 430: PPUSH
// if exist_mode then
 431: LD_VAR 0 2
 435: IFFALSE 460
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 437: LD_ADDR_VAR 0 4
 441: PUSH
 442: LD_EXP 3
 446: PUSH
 447: LD_VAR 0 1
 451: STR
 452: PPUSH
 453: CALL_OW 34
 457: ST_TO_ADDR
 458: GO 475
// unit := NewCharacter ( ident ) ;
 460: LD_ADDR_VAR 0 4
 464: PUSH
 465: LD_VAR 0 1
 469: PPUSH
 470: CALL_OW 25
 474: ST_TO_ADDR
// result := unit ;
 475: LD_ADDR_VAR 0 3
 479: PUSH
 480: LD_VAR 0 4
 484: ST_TO_ADDR
// end ;
 485: LD_VAR 0 3
 489: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 490: LD_INT 0
 492: PPUSH
// uc_side := side ;
 493: LD_ADDR_OWVAR 20
 497: PUSH
 498: LD_VAR 0 1
 502: ST_TO_ADDR
// uc_nation := nation ;
 503: LD_ADDR_OWVAR 21
 507: PUSH
 508: LD_VAR 0 2
 512: ST_TO_ADDR
// vc_chassis := chassis ;
 513: LD_ADDR_OWVAR 37
 517: PUSH
 518: LD_VAR 0 3
 522: ST_TO_ADDR
// vc_engine := engine ;
 523: LD_ADDR_OWVAR 39
 527: PUSH
 528: LD_VAR 0 4
 532: ST_TO_ADDR
// vc_control := control ;
 533: LD_ADDR_OWVAR 38
 537: PUSH
 538: LD_VAR 0 5
 542: ST_TO_ADDR
// vc_weapon := weapon ;
 543: LD_ADDR_OWVAR 40
 547: PUSH
 548: LD_VAR 0 6
 552: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 553: LD_ADDR_OWVAR 41
 557: PUSH
 558: LD_VAR 0 7
 562: ST_TO_ADDR
// result := CreateVehicle ;
 563: LD_ADDR_VAR 0 8
 567: PUSH
 568: CALL_OW 45
 572: ST_TO_ADDR
// end ;
 573: LD_VAR 0 8
 577: RET
// export function SayX ( units , ident ) ; var i ; begin
 578: LD_INT 0
 580: PPUSH
 581: PPUSH
// result := false ;
 582: LD_ADDR_VAR 0 3
 586: PUSH
 587: LD_INT 0
 589: ST_TO_ADDR
// if not units then
 590: LD_VAR 0 1
 594: NOT
 595: IFFALSE 599
// exit ;
 597: GO 653
// for i in units do
 599: LD_ADDR_VAR 0 4
 603: PUSH
 604: LD_VAR 0 1
 608: PUSH
 609: FOR_IN
 610: IFFALSE 651
// if IsOk ( i ) then
 612: LD_VAR 0 4
 616: PPUSH
 617: CALL_OW 302
 621: IFFALSE 649
// begin Say ( i , ident ) ;
 623: LD_VAR 0 4
 627: PPUSH
 628: LD_VAR 0 2
 632: PPUSH
 633: CALL_OW 88
// result := i ;
 637: LD_ADDR_VAR 0 3
 641: PUSH
 642: LD_VAR 0 4
 646: ST_TO_ADDR
// break ;
 647: GO 651
// end ;
 649: GO 609
 651: POP
 652: POP
// end ;
 653: LD_VAR 0 3
 657: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 658: LD_INT 0
 660: PPUSH
 661: PPUSH
// InitUc ;
 662: CALL_OW 18
// InitHc ;
 666: CALL_OW 19
// uc_side := 0 ;
 670: LD_ADDR_OWVAR 20
 674: PUSH
 675: LD_INT 0
 677: ST_TO_ADDR
// uc_nation := 0 ;
 678: LD_ADDR_OWVAR 21
 682: PUSH
 683: LD_INT 0
 685: ST_TO_ADDR
// for i = 1 to amount do
 686: LD_ADDR_VAR 0 4
 690: PUSH
 691: DOUBLE
 692: LD_INT 1
 694: DEC
 695: ST_TO_ADDR
 696: LD_VAR 0 2
 700: PUSH
 701: FOR_TO
 702: IFFALSE 784
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 704: LD_ADDR_OWVAR 29
 708: PUSH
 709: LD_INT 9
 711: PPUSH
 712: LD_INT 12
 714: PPUSH
 715: CALL_OW 12
 719: PUSH
 720: LD_INT 9
 722: PPUSH
 723: LD_INT 12
 725: PPUSH
 726: CALL_OW 12
 730: PUSH
 731: EMPTY
 732: LIST
 733: LIST
 734: ST_TO_ADDR
// hc_agressivity := rand ( - 5 , 5 ) ;
 735: LD_ADDR_OWVAR 35
 739: PUSH
 740: LD_INT 5
 742: NEG
 743: PPUSH
 744: LD_INT 5
 746: PPUSH
 747: CALL_OW 12
 751: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 752: LD_INT 0
 754: PPUSH
 755: LD_INT 12
 757: PPUSH
 758: LD_INT 1
 760: PPUSH
 761: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 765: CALL_OW 44
 769: PPUSH
 770: LD_VAR 0 1
 774: PPUSH
 775: LD_INT 0
 777: PPUSH
 778: CALL_OW 49
// end ;
 782: GO 701
 784: POP
 785: POP
// InitHc ;
 786: CALL_OW 19
// end ;
 790: LD_VAR 0 3
 794: RET
// export function Attack ( unit , enemy_list ) ; var target , targets_list ; begin
 795: LD_INT 0
 797: PPUSH
 798: PPUSH
 799: PPUSH
// if not unit then
 800: LD_VAR 0 1
 804: NOT
 805: IFFALSE 809
// exit ;
 807: GO 1252
// if IsInUnit ( unit ) then
 809: LD_VAR 0 1
 813: PPUSH
 814: CALL_OW 310
 818: IFFALSE 835
// unit := IsDrivenBy ( unit ) ;
 820: LD_ADDR_VAR 0 1
 824: PUSH
 825: LD_VAR 0 1
 829: PPUSH
 830: CALL_OW 311
 834: ST_TO_ADDR
// targets_list := [ ] ;
 835: LD_ADDR_VAR 0 5
 839: PUSH
 840: EMPTY
 841: ST_TO_ADDR
// target := UnitFilter ( enemy_list , [ [ f_lives , 250 ] , [ f_not , [ f_weapon , us_cargo_bay ] ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
 842: LD_ADDR_VAR 0 4
 846: PUSH
 847: LD_VAR 0 2
 851: PPUSH
 852: LD_INT 24
 854: PUSH
 855: LD_INT 250
 857: PUSH
 858: EMPTY
 859: LIST
 860: LIST
 861: PUSH
 862: LD_INT 3
 864: PUSH
 865: LD_INT 34
 867: PUSH
 868: LD_INT 12
 870: PUSH
 871: EMPTY
 872: LIST
 873: LIST
 874: PUSH
 875: EMPTY
 876: LIST
 877: LIST
 878: PUSH
 879: LD_INT 21
 881: PUSH
 882: LD_INT 2
 884: PUSH
 885: EMPTY
 886: LIST
 887: LIST
 888: PUSH
 889: LD_INT 58
 891: PUSH
 892: EMPTY
 893: LIST
 894: PUSH
 895: EMPTY
 896: LIST
 897: LIST
 898: LIST
 899: LIST
 900: PPUSH
 901: CALL_OW 72
 905: ST_TO_ADDR
// if GetDistUnits ( NearestUnitToUnit ( target , unit ) , unit ) < 11 and not IsInUnit ( unit ) then
 906: LD_VAR 0 4
 910: PPUSH
 911: LD_VAR 0 1
 915: PPUSH
 916: CALL_OW 74
 920: PPUSH
 921: LD_VAR 0 1
 925: PPUSH
 926: CALL_OW 296
 930: PUSH
 931: LD_INT 11
 933: LESS
 934: PUSH
 935: LD_VAR 0 1
 939: PPUSH
 940: CALL_OW 310
 944: NOT
 945: AND
 946: IFFALSE 974
// begin ComEnterUnit ( unit , NearestUnitToUnit ( target , unit ) ) ;
 948: LD_VAR 0 1
 952: PPUSH
 953: LD_VAR 0 4
 957: PPUSH
 958: LD_VAR 0 1
 962: PPUSH
 963: CALL_OW 74
 967: PPUSH
 968: CALL_OW 120
// exit ;
 972: GO 1252
// end ; targets_list := [ UnitFilter ( enemy_list , [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] ] ) , UnitFilter ( enemy_list , [ f_type , unit_vehicle ] ) , UnitFilter ( enemy_list , [ [ f_type , unit_building ] , [ f_not , [ f_empty ] ] ] ) , enemy_list ] ;
 974: LD_ADDR_VAR 0 5
 978: PUSH
 979: LD_VAR 0 2
 983: PPUSH
 984: LD_INT 21
 986: PUSH
 987: LD_INT 1
 989: PUSH
 990: EMPTY
 991: LIST
 992: LIST
 993: PUSH
 994: LD_INT 3
 996: PUSH
 997: LD_INT 54
 999: PUSH
1000: EMPTY
1001: LIST
1002: PUSH
1003: EMPTY
1004: LIST
1005: LIST
1006: PUSH
1007: EMPTY
1008: LIST
1009: LIST
1010: PPUSH
1011: CALL_OW 72
1015: PUSH
1016: LD_VAR 0 2
1020: PPUSH
1021: LD_INT 21
1023: PUSH
1024: LD_INT 2
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: PPUSH
1031: CALL_OW 72
1035: PUSH
1036: LD_VAR 0 2
1040: PPUSH
1041: LD_INT 21
1043: PUSH
1044: LD_INT 3
1046: PUSH
1047: EMPTY
1048: LIST
1049: LIST
1050: PUSH
1051: LD_INT 3
1053: PUSH
1054: LD_INT 58
1056: PUSH
1057: EMPTY
1058: LIST
1059: PUSH
1060: EMPTY
1061: LIST
1062: LIST
1063: PUSH
1064: EMPTY
1065: LIST
1066: LIST
1067: PPUSH
1068: CALL_OW 72
1072: PUSH
1073: LD_VAR 0 2
1077: PUSH
1078: EMPTY
1079: LIST
1080: LIST
1081: LIST
1082: LIST
1083: ST_TO_ADDR
// for target in targets_list do
1084: LD_ADDR_VAR 0 4
1088: PUSH
1089: LD_VAR 0 5
1093: PUSH
1094: FOR_IN
1095: IFFALSE 1250
// begin if target then
1097: LD_VAR 0 4
1101: IFFALSE 1248
// if GetTag ( unit ) = 11 and ( GetType ( NearestUnitToUnit ( target , unit ) ) = unit_building or GetWeapon ( NearestUnitToUnit ( target , unit ) ) = us_cargo_bay ) then
1103: LD_VAR 0 1
1107: PPUSH
1108: CALL_OW 110
1112: PUSH
1113: LD_INT 11
1115: EQUAL
1116: PUSH
1117: LD_VAR 0 4
1121: PPUSH
1122: LD_VAR 0 1
1126: PPUSH
1127: CALL_OW 74
1131: PPUSH
1132: CALL_OW 247
1136: PUSH
1137: LD_INT 3
1139: EQUAL
1140: PUSH
1141: LD_VAR 0 4
1145: PPUSH
1146: LD_VAR 0 1
1150: PPUSH
1151: CALL_OW 74
1155: PPUSH
1156: CALL_OW 264
1160: PUSH
1161: LD_INT 12
1163: EQUAL
1164: OR
1165: AND
1166: IFFALSE 1212
// begin ComPlaceDelayedCharge ( unit , 0 , 0 , NearestUnitToUnit ( target , unit ) ) ;
1168: LD_VAR 0 1
1172: PPUSH
1173: LD_INT 0
1175: PPUSH
1176: LD_INT 0
1178: PPUSH
1179: LD_VAR 0 4
1183: PPUSH
1184: LD_VAR 0 1
1188: PPUSH
1189: CALL_OW 74
1193: PPUSH
1194: CALL_OW 132
// SetTag ( unit , 0 ) ;
1198: LD_VAR 0 1
1202: PPUSH
1203: LD_INT 0
1205: PPUSH
1206: CALL_OW 109
// end else
1210: GO 1248
// if not HasTask ( unit ) then
1212: LD_VAR 0 1
1216: PPUSH
1217: CALL_OW 314
1221: NOT
1222: IFFALSE 1248
// ComAttackUnit ( unit , NearestUnitToUnit ( target , unit ) ) ;
1224: LD_VAR 0 1
1228: PPUSH
1229: LD_VAR 0 4
1233: PPUSH
1234: LD_VAR 0 1
1238: PPUSH
1239: CALL_OW 74
1243: PPUSH
1244: CALL_OW 115
// end ;
1248: GO 1094
1250: POP
1251: POP
// end ; end_of_file
1252: LD_VAR 0 3
1256: RET
// export JMM , Gladstone , Harrison , Denis , Brown , Donaldson , Lisa , Frank , Bobby , Cyrus ; export others ; export function PrepareAmericans ; var i , points , veh , tmp ; begin
1257: LD_INT 0
1259: PPUSH
1260: PPUSH
1261: PPUSH
1262: PPUSH
1263: PPUSH
// uc_nation := 1 ;
1264: LD_ADDR_OWVAR 21
1268: PUSH
1269: LD_INT 1
1271: ST_TO_ADDR
// uc_side := 4 ;
1272: LD_ADDR_OWVAR 20
1276: PUSH
1277: LD_INT 4
1279: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , false ) ;
1280: LD_ADDR_EXP 19
1284: PUSH
1285: LD_STRING Denis
1287: PPUSH
1288: LD_INT 0
1290: PPUSH
1291: CALL 427 0 2
1295: ST_TO_ADDR
// Harrison := PrepareUnit ( Harisson , false ) ;
1296: LD_ADDR_EXP 18
1300: PUSH
1301: LD_STRING Harisson
1303: PPUSH
1304: LD_INT 0
1306: PPUSH
1307: CALL 427 0 2
1311: ST_TO_ADDR
// uc_side := 1 ;
1312: LD_ADDR_OWVAR 20
1316: PUSH
1317: LD_INT 1
1319: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1320: LD_ADDR_EXP 16
1324: PUSH
1325: LD_STRING JMM
1327: PPUSH
1328: LD_EXP 1
1332: NOT
1333: PPUSH
1334: CALL 427 0 2
1338: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , false ) ;
1339: LD_ADDR_EXP 17
1343: PUSH
1344: LD_STRING Gladstone
1346: PPUSH
1347: LD_INT 0
1349: PPUSH
1350: CALL 427 0 2
1354: ST_TO_ADDR
// if LoadVariable ( BrownInDelta , debug ) then
1355: LD_STRING BrownInDelta
1357: PPUSH
1358: LD_EXP 1
1362: PPUSH
1363: CALL_OW 30
1367: IFFALSE 1404
// begin Brown := PrepareUnit ( Brown , ( not debug ) ) ;
1369: LD_ADDR_EXP 20
1373: PUSH
1374: LD_STRING Brown
1376: PPUSH
1377: LD_EXP 1
1381: NOT
1382: PPUSH
1383: CALL 427 0 2
1387: ST_TO_ADDR
// tmp := tmp ^ Brown ;
1388: LD_ADDR_VAR 0 5
1392: PUSH
1393: LD_VAR 0 5
1397: PUSH
1398: LD_EXP 20
1402: ADD
1403: ST_TO_ADDR
// end ; if LoadVariable ( DonaldsonInDelta , debug ) then
1404: LD_STRING DonaldsonInDelta
1406: PPUSH
1407: LD_EXP 1
1411: PPUSH
1412: CALL_OW 30
1416: IFFALSE 1453
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
1418: LD_ADDR_EXP 21
1422: PUSH
1423: LD_STRING Donaldson
1425: PPUSH
1426: LD_EXP 1
1430: NOT
1431: PPUSH
1432: CALL 427 0 2
1436: ST_TO_ADDR
// tmp := tmp ^ Donaldson ;
1437: LD_ADDR_VAR 0 5
1441: PUSH
1442: LD_VAR 0 5
1446: PUSH
1447: LD_EXP 21
1451: ADD
1452: ST_TO_ADDR
// end ; if LoadVariable ( LisaInDelta , debug ) then
1453: LD_STRING LisaInDelta
1455: PPUSH
1456: LD_EXP 1
1460: PPUSH
1461: CALL_OW 30
1465: IFFALSE 1502
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1467: LD_ADDR_EXP 22
1471: PUSH
1472: LD_STRING Lisa
1474: PPUSH
1475: LD_EXP 1
1479: NOT
1480: PPUSH
1481: CALL 427 0 2
1485: ST_TO_ADDR
// tmp := tmp ^ Lisa ;
1486: LD_ADDR_VAR 0 5
1490: PUSH
1491: LD_VAR 0 5
1495: PUSH
1496: LD_EXP 22
1500: ADD
1501: ST_TO_ADDR
// end ; if LoadVariable ( FrankInDelta , debug ) then
1502: LD_STRING FrankInDelta
1504: PPUSH
1505: LD_EXP 1
1509: PPUSH
1510: CALL_OW 30
1514: IFFALSE 1551
// begin Frank := PrepareUnit ( Frank , ( not debug ) ) ;
1516: LD_ADDR_EXP 23
1520: PUSH
1521: LD_STRING Frank
1523: PPUSH
1524: LD_EXP 1
1528: NOT
1529: PPUSH
1530: CALL 427 0 2
1534: ST_TO_ADDR
// tmp := tmp ^ Frank ;
1535: LD_ADDR_VAR 0 5
1539: PUSH
1540: LD_VAR 0 5
1544: PUSH
1545: LD_EXP 23
1549: ADD
1550: ST_TO_ADDR
// end ; if LoadVariable ( BobbyInDelta , 0 ) then
1551: LD_STRING BobbyInDelta
1553: PPUSH
1554: LD_INT 0
1556: PPUSH
1557: CALL_OW 30
1561: IFFALSE 1598
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1563: LD_ADDR_EXP 24
1567: PUSH
1568: LD_STRING Bobby
1570: PPUSH
1571: LD_EXP 1
1575: NOT
1576: PPUSH
1577: CALL 427 0 2
1581: ST_TO_ADDR
// tmp := tmp ^ Bobby ;
1582: LD_ADDR_VAR 0 5
1586: PUSH
1587: LD_VAR 0 5
1591: PUSH
1592: LD_EXP 24
1596: ADD
1597: ST_TO_ADDR
// end ; if LoadVariable ( CyrusInDelta , 0 ) then
1598: LD_STRING CyrusInDelta
1600: PPUSH
1601: LD_INT 0
1603: PPUSH
1604: CALL_OW 30
1608: IFFALSE 1645
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1610: LD_ADDR_EXP 25
1614: PUSH
1615: LD_STRING Cyrus
1617: PPUSH
1618: LD_EXP 1
1622: NOT
1623: PPUSH
1624: CALL 427 0 2
1628: ST_TO_ADDR
// tmp := tmp ^ Cyrus ;
1629: LD_ADDR_VAR 0 5
1633: PUSH
1634: LD_VAR 0 5
1638: PUSH
1639: LD_EXP 25
1643: ADD
1644: ST_TO_ADDR
// end ; others := CreateCharacterSet ( othersDelta ) ;
1645: LD_ADDR_EXP 26
1649: PUSH
1650: LD_STRING othersDelta
1652: PPUSH
1653: CALL_OW 31
1657: ST_TO_ADDR
// if not others and debug then
1658: LD_EXP 26
1662: NOT
1663: PUSH
1664: LD_EXP 1
1668: AND
1669: IFFALSE 1734
// begin InitHc ;
1671: CALL_OW 19
// for i = 1 to 2 do
1675: LD_ADDR_VAR 0 2
1679: PUSH
1680: DOUBLE
1681: LD_INT 1
1683: DEC
1684: ST_TO_ADDR
1685: LD_INT 2
1687: PUSH
1688: FOR_TO
1689: IFFALSE 1732
// begin PrepareHuman ( false , i mod 4 + 1 , 3 ) ;
1691: LD_INT 0
1693: PPUSH
1694: LD_VAR 0 2
1698: PUSH
1699: LD_INT 4
1701: MOD
1702: PUSH
1703: LD_INT 1
1705: PLUS
1706: PPUSH
1707: LD_INT 3
1709: PPUSH
1710: CALL_OW 380
// others := others ^ CreateHuman ;
1714: LD_ADDR_EXP 26
1718: PUSH
1719: LD_EXP 26
1723: PUSH
1724: CALL_OW 44
1728: ADD
1729: ST_TO_ADDR
// end ;
1730: GO 1688
1732: POP
1733: POP
// end ; if others then
1734: LD_EXP 26
1738: IFFALSE 1756
// tmp := tmp ^ others ;
1740: LD_ADDR_VAR 0 5
1744: PUSH
1745: LD_VAR 0 5
1749: PUSH
1750: LD_EXP 26
1754: ADD
1755: ST_TO_ADDR
// points := [ [ 28 , 49 ] , [ 33 , 54 ] , [ 38 , 56 ] ] ;
1756: LD_ADDR_VAR 0 3
1760: PUSH
1761: LD_INT 28
1763: PUSH
1764: LD_INT 49
1766: PUSH
1767: EMPTY
1768: LIST
1769: LIST
1770: PUSH
1771: LD_INT 33
1773: PUSH
1774: LD_INT 54
1776: PUSH
1777: EMPTY
1778: LIST
1779: LIST
1780: PUSH
1781: LD_INT 38
1783: PUSH
1784: LD_INT 56
1786: PUSH
1787: EMPTY
1788: LIST
1789: LIST
1790: PUSH
1791: EMPTY
1792: LIST
1793: LIST
1794: LIST
1795: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , us_cargo_bay , 80 ) ;
1796: LD_ADDR_VAR 0 4
1800: PUSH
1801: LD_INT 1
1803: PPUSH
1804: LD_INT 1
1806: PPUSH
1807: LD_INT 2
1809: PPUSH
1810: LD_INT 2
1812: PPUSH
1813: LD_INT 1
1815: PPUSH
1816: LD_INT 12
1818: PPUSH
1819: LD_INT 80
1821: PPUSH
1822: CALL 490 0 7
1826: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1827: LD_VAR 0 4
1831: PPUSH
1832: LD_INT 1
1834: PPUSH
1835: CALL_OW 233
// PlaceUnitXY ( veh , points [ 1 ] [ 1 ] , points [ 1 ] [ 2 ] , false ) ;
1839: LD_VAR 0 4
1843: PPUSH
1844: LD_VAR 0 3
1848: PUSH
1849: LD_INT 1
1851: ARRAY
1852: PUSH
1853: LD_INT 1
1855: ARRAY
1856: PPUSH
1857: LD_VAR 0 3
1861: PUSH
1862: LD_INT 1
1864: ARRAY
1865: PUSH
1866: LD_INT 2
1868: ARRAY
1869: PPUSH
1870: LD_INT 0
1872: PPUSH
1873: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
1877: LD_VAR 0 4
1881: PPUSH
1882: LD_INT 1
1884: PPUSH
1885: LD_INT 100
1887: PPUSH
1888: CALL_OW 290
// PlaceHumanInUnit ( others [ 1 ] , veh ) ;
1892: LD_EXP 26
1896: PUSH
1897: LD_INT 1
1899: ARRAY
1900: PPUSH
1901: LD_VAR 0 4
1905: PPUSH
1906: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_machine_gun , 80 ) ;
1910: LD_ADDR_VAR 0 4
1914: PUSH
1915: LD_INT 1
1917: PPUSH
1918: LD_INT 1
1920: PPUSH
1921: LD_INT 1
1923: PPUSH
1924: LD_INT 2
1926: PPUSH
1927: LD_INT 1
1929: PPUSH
1930: LD_INT 2
1932: PPUSH
1933: LD_INT 80
1935: PPUSH
1936: CALL 490 0 7
1940: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1941: LD_VAR 0 4
1945: PPUSH
1946: LD_INT 1
1948: PPUSH
1949: CALL_OW 233
// PlaceUnitXY ( veh , points [ 2 ] [ 1 ] , points [ 2 ] [ 2 ] , false ) ;
1953: LD_VAR 0 4
1957: PPUSH
1958: LD_VAR 0 3
1962: PUSH
1963: LD_INT 2
1965: ARRAY
1966: PUSH
1967: LD_INT 1
1969: ARRAY
1970: PPUSH
1971: LD_VAR 0 3
1975: PUSH
1976: LD_INT 2
1978: ARRAY
1979: PUSH
1980: LD_INT 2
1982: ARRAY
1983: PPUSH
1984: LD_INT 0
1986: PPUSH
1987: CALL_OW 48
// PlaceHumanInUnit ( Gladstone , veh ) ;
1991: LD_EXP 17
1995: PPUSH
1996: LD_VAR 0 4
2000: PPUSH
2001: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_light_gun , 80 ) ;
2005: LD_ADDR_VAR 0 4
2009: PUSH
2010: LD_INT 1
2012: PPUSH
2013: LD_INT 1
2015: PPUSH
2016: LD_INT 1
2018: PPUSH
2019: LD_INT 2
2021: PPUSH
2022: LD_INT 1
2024: PPUSH
2025: LD_INT 3
2027: PPUSH
2028: LD_INT 80
2030: PPUSH
2031: CALL 490 0 7
2035: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
2036: LD_VAR 0 4
2040: PPUSH
2041: LD_INT 1
2043: PPUSH
2044: CALL_OW 233
// PlaceUnitXY ( veh , points [ 3 ] [ 1 ] , points [ 3 ] [ 2 ] , false ) ;
2048: LD_VAR 0 4
2052: PPUSH
2053: LD_VAR 0 3
2057: PUSH
2058: LD_INT 3
2060: ARRAY
2061: PUSH
2062: LD_INT 1
2064: ARRAY
2065: PPUSH
2066: LD_VAR 0 3
2070: PUSH
2071: LD_INT 3
2073: ARRAY
2074: PUSH
2075: LD_INT 2
2077: ARRAY
2078: PPUSH
2079: LD_INT 0
2081: PPUSH
2082: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
2086: LD_EXP 16
2090: PPUSH
2091: LD_VAR 0 4
2095: PPUSH
2096: CALL_OW 52
// for i in tmp diff others [ 1 ] do
2100: LD_ADDR_VAR 0 2
2104: PUSH
2105: LD_VAR 0 5
2109: PUSH
2110: LD_EXP 26
2114: PUSH
2115: LD_INT 1
2117: ARRAY
2118: DIFF
2119: PUSH
2120: FOR_IN
2121: IFFALSE 2140
// PlaceUnitArea ( i , startArea , false ) ;
2123: LD_VAR 0 2
2127: PPUSH
2128: LD_INT 5
2130: PPUSH
2131: LD_INT 0
2133: PPUSH
2134: CALL_OW 49
2138: GO 2120
2140: POP
2141: POP
// end ; end_of_file
2142: LD_VAR 0 1
2146: RET
// export function Action ; var m ; begin
2147: LD_INT 0
2149: PPUSH
2150: PPUSH
// InGameOn ;
2151: CALL_OW 8
// CenterNowOnXY ( 28 , 51 ) ;
2155: LD_INT 28
2157: PPUSH
2158: LD_INT 51
2160: PPUSH
2161: CALL_OW 86
// Wait ( 3 ) ;
2165: LD_INT 3
2167: PPUSH
2168: CALL_OW 67
// Say ( JMM , D1d-JMM-1a ) ;
2172: LD_EXP 16
2176: PPUSH
2177: LD_STRING D1d-JMM-1a
2179: PPUSH
2180: CALL_OW 88
// SayRadio ( Harrison , D1d-Har-1 ) ;
2184: LD_EXP 18
2188: PPUSH
2189: LD_STRING D1d-Har-1
2191: PPUSH
2192: CALL_OW 94
// InGameOff ;
2196: CALL_OW 9
// SaveForQuickRestart ;
2200: CALL_OW 22
// ChangeMissionObjectives ( M1 ) ;
2204: LD_STRING M1
2206: PPUSH
2207: CALL_OW 337
// Wait ( 0 0$2 ) ;
2211: LD_INT 70
2213: PPUSH
2214: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
2218: LD_EXP 16
2222: PPUSH
2223: LD_STRING D2-JMM-1
2225: PPUSH
2226: CALL_OW 88
// Say ( Gladstone , D2-Glad-1 ) ;
2230: LD_EXP 17
2234: PPUSH
2235: LD_STRING D2-Glad-1
2237: PPUSH
2238: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
2242: LD_EXP 16
2246: PPUSH
2247: LD_STRING D2-JMM-2
2249: PPUSH
2250: CALL_OW 88
// Say ( Gladstone , D2-Glad-2 ) ;
2254: LD_EXP 17
2258: PPUSH
2259: LD_STRING D2-Glad-2
2261: PPUSH
2262: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
2266: LD_EXP 16
2270: PPUSH
2271: LD_STRING D2-JMM-3
2273: PPUSH
2274: CALL_OW 88
// Wait ( rand ( 0 0$30 , 1 1$00 ) ) ;
2278: LD_INT 1050
2280: PPUSH
2281: LD_INT 2100
2283: PPUSH
2284: CALL_OW 12
2288: PPUSH
2289: CALL_OW 67
// SetWeather ( 2 , 90 , 150 ) ;
2293: LD_INT 2
2295: PPUSH
2296: LD_INT 90
2298: PPUSH
2299: LD_INT 150
2301: PPUSH
2302: CALL_OW 550
// Wait ( rand ( 3 3$00 , 5 5$00 ) ) ;
2306: LD_INT 6300
2308: PPUSH
2309: LD_INT 10500
2311: PPUSH
2312: CALL_OW 12
2316: PPUSH
2317: CALL_OW 67
// SetWeather ( 0 , 90 , 150 ) ;
2321: LD_INT 0
2323: PPUSH
2324: LD_INT 90
2326: PPUSH
2327: LD_INT 150
2329: PPUSH
2330: CALL_OW 550
// end ;
2334: LD_VAR 0 1
2338: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) and not deltaBuilded do
2339: LD_INT 22
2341: PUSH
2342: LD_INT 1
2344: PUSH
2345: EMPTY
2346: LIST
2347: LIST
2348: PUSH
2349: LD_INT 3
2351: PUSH
2352: LD_INT 57
2354: PUSH
2355: EMPTY
2356: LIST
2357: PUSH
2358: EMPTY
2359: LIST
2360: LIST
2361: PUSH
2362: LD_INT 30
2364: PUSH
2365: LD_INT 0
2367: PUSH
2368: EMPTY
2369: LIST
2370: LIST
2371: PUSH
2372: EMPTY
2373: LIST
2374: LIST
2375: LIST
2376: PUSH
2377: EMPTY
2378: LIST
2379: PPUSH
2380: CALL_OW 69
2384: PUSH
2385: LD_EXP 4
2389: NOT
2390: AND
2391: IFFALSE 2404
2393: GO 2395
2395: DISABLE
// begin deltaBuilded := true ;
2396: LD_ADDR_EXP 4
2400: PUSH
2401: LD_INT 1
2403: ST_TO_ADDR
// end ;
2404: END
// every 0 0$01 trigger not Delta and deltaBuilded and FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) do
2405: LD_EXP 6
2409: NOT
2410: PUSH
2411: LD_EXP 4
2415: AND
2416: PUSH
2417: LD_INT 22
2419: PUSH
2420: LD_INT 1
2422: PUSH
2423: EMPTY
2424: LIST
2425: LIST
2426: PUSH
2427: LD_INT 3
2429: PUSH
2430: LD_INT 57
2432: PUSH
2433: EMPTY
2434: LIST
2435: PUSH
2436: EMPTY
2437: LIST
2438: LIST
2439: PUSH
2440: LD_INT 30
2442: PUSH
2443: LD_INT 0
2445: PUSH
2446: EMPTY
2447: LIST
2448: LIST
2449: PUSH
2450: EMPTY
2451: LIST
2452: LIST
2453: LIST
2454: PUSH
2455: EMPTY
2456: LIST
2457: PPUSH
2458: CALL_OW 69
2462: AND
2463: IFFALSE 2549
2465: GO 2467
2467: DISABLE
// begin enable ;
2468: ENABLE
// SetRestrict ( b_depot , 1 , state_disabled ) ;
2469: LD_INT 0
2471: PPUSH
2472: LD_INT 1
2474: PPUSH
2475: LD_INT 0
2477: PPUSH
2478: CALL_OW 324
// Delta := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) [ 1 ] ;
2482: LD_ADDR_EXP 6
2486: PUSH
2487: LD_INT 22
2489: PUSH
2490: LD_INT 1
2492: PUSH
2493: EMPTY
2494: LIST
2495: LIST
2496: PUSH
2497: LD_INT 3
2499: PUSH
2500: LD_INT 57
2502: PUSH
2503: EMPTY
2504: LIST
2505: PUSH
2506: EMPTY
2507: LIST
2508: LIST
2509: PUSH
2510: LD_INT 30
2512: PUSH
2513: LD_INT 0
2515: PUSH
2516: EMPTY
2517: LIST
2518: LIST
2519: PUSH
2520: EMPTY
2521: LIST
2522: LIST
2523: LIST
2524: PUSH
2525: EMPTY
2526: LIST
2527: PPUSH
2528: CALL_OW 69
2532: PUSH
2533: LD_INT 1
2535: ARRAY
2536: ST_TO_ADDR
// SetBName ( Delta , Delta ) ;
2537: LD_EXP 6
2541: PPUSH
2542: LD_STRING Delta
2544: PPUSH
2545: CALL_OW 500
// end ;
2549: END
// every 0 0$2 trigger GetTech ( tech_ApeLang , 1 ) = state_researched and IsOk ( Gladstone ) do
2550: LD_INT 1
2552: PPUSH
2553: LD_INT 1
2555: PPUSH
2556: CALL_OW 321
2560: PUSH
2561: LD_INT 2
2563: EQUAL
2564: PUSH
2565: LD_EXP 17
2569: PPUSH
2570: CALL_OW 302
2574: AND
2575: IFFALSE 2636
2577: GO 2579
2579: DISABLE
// begin DialogueOn ;
2580: CALL_OW 6
// Say ( Gladstone , D3-Glad-1 ) ;
2584: LD_EXP 17
2588: PPUSH
2589: LD_STRING D3-Glad-1
2591: PPUSH
2592: CALL_OW 88
// Say ( JMM , D3-JMM-1 ) ;
2596: LD_EXP 16
2600: PPUSH
2601: LD_STRING D3-JMM-1
2603: PPUSH
2604: CALL_OW 88
// Say ( Gladstone , D3-Glad-2 ) ;
2608: LD_EXP 17
2612: PPUSH
2613: LD_STRING D3-Glad-2
2615: PPUSH
2616: CALL_OW 88
// Say ( JMM , D3-JMM-2 ) ;
2620: LD_EXP 16
2624: PPUSH
2625: LD_STRING D3-JMM-2
2627: PPUSH
2628: CALL_OW 88
// DialogueOff ;
2632: CALL_OW 7
// end ;
2636: END
// every 0 0$1 trigger GetTech ( tech_ApePsych , 1 ) = state_researched do var sol ;
2637: LD_INT 2
2639: PPUSH
2640: LD_INT 1
2642: PPUSH
2643: CALL_OW 321
2647: PUSH
2648: LD_INT 2
2650: EQUAL
2651: IFFALSE 2828
2653: GO 2655
2655: DISABLE
2656: LD_INT 0
2658: PPUSH
// begin DialogueOn ;
2659: CALL_OW 6
// if Frank then
2663: LD_EXP 23
2667: IFFALSE 2681
// Say ( Frank , D8a-Frank-1 ) ;
2669: LD_EXP 23
2673: PPUSH
2674: LD_STRING D8a-Frank-1
2676: PPUSH
2677: CALL_OW 88
// sol := SayX ( UnitFilter ( others , [ f_sex , sex_male ] ) , D8a-Sol1-1 ) ;
2681: LD_ADDR_VAR 0 1
2685: PUSH
2686: LD_EXP 26
2690: PPUSH
2691: LD_INT 26
2693: PUSH
2694: LD_INT 1
2696: PUSH
2697: EMPTY
2698: LIST
2699: LIST
2700: PPUSH
2701: CALL_OW 72
2705: PPUSH
2706: LD_STRING D8a-Sol1-1
2708: PPUSH
2709: CALL 578 0 2
2713: ST_TO_ADDR
// if Denis and GetSide ( Denis ) = 1 then
2714: LD_EXP 19
2718: PUSH
2719: LD_EXP 19
2723: PPUSH
2724: CALL_OW 255
2728: PUSH
2729: LD_INT 1
2731: EQUAL
2732: AND
2733: IFFALSE 2747
// Say ( Denis , D8a-Den-1 ) ;
2735: LD_EXP 19
2739: PPUSH
2740: LD_STRING D8a-Den-1
2742: PPUSH
2743: CALL_OW 88
// if sol or Denis or Frank then
2747: LD_VAR 0 1
2751: PUSH
2752: LD_EXP 19
2756: OR
2757: PUSH
2758: LD_EXP 23
2762: OR
2763: IFFALSE 2824
// begin SayX ( UnitFilter ( others , [ [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff sol , D8a-Sci1-1 ) ;
2765: LD_EXP 26
2769: PPUSH
2770: LD_INT 25
2772: PUSH
2773: LD_INT 4
2775: PUSH
2776: EMPTY
2777: LIST
2778: LIST
2779: PUSH
2780: LD_INT 26
2782: PUSH
2783: LD_INT 1
2785: PUSH
2786: EMPTY
2787: LIST
2788: LIST
2789: PUSH
2790: EMPTY
2791: LIST
2792: LIST
2793: PPUSH
2794: CALL_OW 72
2798: PUSH
2799: LD_VAR 0 1
2803: DIFF
2804: PPUSH
2805: LD_STRING D8a-Sci1-1
2807: PPUSH
2808: CALL 578 0 2
// Say ( JMM , D8a-JMM-1 ) ;
2812: LD_EXP 16
2816: PPUSH
2817: LD_STRING D8a-JMM-1
2819: PPUSH
2820: CALL_OW 88
// end ; DialogueOff ;
2824: CALL_OW 7
// end ;
2828: PPOPN 1
2830: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) do
2831: LD_INT 22
2833: PUSH
2834: LD_INT 1
2836: PUSH
2837: EMPTY
2838: LIST
2839: LIST
2840: PUSH
2841: LD_INT 25
2843: PUSH
2844: LD_INT 16
2846: PUSH
2847: EMPTY
2848: LIST
2849: LIST
2850: PUSH
2851: EMPTY
2852: LIST
2853: LIST
2854: PPUSH
2855: CALL_OW 69
2859: IFFALSE 2918
2861: GO 2863
2863: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
2864: LD_STRING M1a
2866: PPUSH
2867: CALL_OW 337
// case Query ( Q2 ) of 1 :
2871: LD_STRING Q2
2873: PPUSH
2874: CALL_OW 97
2878: PUSH
2879: LD_INT 1
2881: DOUBLE
2882: EQUAL
2883: IFTRUE 2887
2885: GO 2898
2887: POP
// end_mission := true ; 2 :
2888: LD_ADDR_EXP 14
2892: PUSH
2893: LD_INT 1
2895: ST_TO_ADDR
2896: GO 2918
2898: LD_INT 2
2900: DOUBLE
2901: EQUAL
2902: IFTRUE 2906
2904: GO 2917
2906: POP
// end_the_mission_allowed := true ; end ;
2907: LD_ADDR_OWVAR 57
2911: PUSH
2912: LD_INT 1
2914: ST_TO_ADDR
2915: GO 2918
2917: POP
// end ;
2918: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) and Delta do
2919: LD_INT 22
2921: PUSH
2922: LD_INT 1
2924: PUSH
2925: EMPTY
2926: LIST
2927: LIST
2928: PUSH
2929: LD_INT 2
2931: PUSH
2932: LD_INT 30
2934: PUSH
2935: LD_INT 6
2937: PUSH
2938: EMPTY
2939: LIST
2940: LIST
2941: PUSH
2942: LD_INT 30
2944: PUSH
2945: LD_INT 7
2947: PUSH
2948: EMPTY
2949: LIST
2950: LIST
2951: PUSH
2952: EMPTY
2953: LIST
2954: LIST
2955: LIST
2956: PUSH
2957: EMPTY
2958: LIST
2959: LIST
2960: PPUSH
2961: CALL_OW 69
2965: PUSH
2966: LD_INT 22
2968: PUSH
2969: LD_INT 1
2971: PUSH
2972: EMPTY
2973: LIST
2974: LIST
2975: PUSH
2976: LD_INT 2
2978: PUSH
2979: LD_INT 30
2981: PUSH
2982: LD_INT 2
2984: PUSH
2985: EMPTY
2986: LIST
2987: LIST
2988: PUSH
2989: LD_INT 30
2991: PUSH
2992: LD_INT 3
2994: PUSH
2995: EMPTY
2996: LIST
2997: LIST
2998: PUSH
2999: EMPTY
3000: LIST
3001: LIST
3002: LIST
3003: PUSH
3004: EMPTY
3005: LIST
3006: LIST
3007: PPUSH
3008: CALL_OW 69
3012: AND
3013: PUSH
3014: LD_EXP 6
3018: AND
3019: IFFALSE 3530
3021: GO 3023
3023: DISABLE
// begin Wait ( rand ( 0 0$30 , 0 0$50 ) ) ;
3024: LD_INT 1050
3026: PPUSH
3027: LD_INT 1750
3029: PPUSH
3030: CALL_OW 12
3034: PPUSH
3035: CALL_OW 67
// PlaceUnitArea ( Denis , [ denisArea1 , denisArea2 , denisArea3 ] [ Difficulty ] , false ) ;
3039: LD_EXP 19
3043: PPUSH
3044: LD_INT 6
3046: PUSH
3047: LD_INT 9
3049: PUSH
3050: LD_INT 10
3052: PUSH
3053: EMPTY
3054: LIST
3055: LIST
3056: LIST
3057: PUSH
3058: LD_OWVAR 67
3062: ARRAY
3063: PPUSH
3064: LD_INT 0
3066: PPUSH
3067: CALL_OW 49
// ComHold ( Denis ) ;
3071: LD_EXP 19
3075: PPUSH
3076: CALL_OW 140
// InGameOn ;
3080: CALL_OW 8
// DialogueOn ;
3084: CALL_OW 6
// if Delta then
3088: LD_EXP 6
3092: IFFALSE 3105
// CenterNowOnUnits ( Delta ) else
3094: LD_EXP 6
3098: PPUSH
3099: CALL_OW 87
3103: GO 3114
// CenterNowOnUnits ( JMM ) ;
3105: LD_EXP 16
3109: PPUSH
3110: CALL_OW 87
// SayRadio ( Denis , DD-Den-1 ) ;
3114: LD_EXP 19
3118: PPUSH
3119: LD_STRING DD-Den-1
3121: PPUSH
3122: CALL_OW 94
// Say ( JMM , DD-JMM-1 ) ;
3126: LD_EXP 16
3130: PPUSH
3131: LD_STRING DD-JMM-1
3133: PPUSH
3134: CALL_OW 88
// SayRadio ( Denis , DD-Den-2 ) ;
3138: LD_EXP 19
3142: PPUSH
3143: LD_STRING DD-Den-2
3145: PPUSH
3146: CALL_OW 94
// Wait ( 3 ) ;
3150: LD_INT 3
3152: PPUSH
3153: CALL_OW 67
// DialogueOff ;
3157: CALL_OW 7
// InGameOff ;
3161: CALL_OW 9
// if Difficulty = 1 then
3165: LD_OWVAR 67
3169: PUSH
3170: LD_INT 1
3172: EQUAL
3173: IFFALSE 3249
// begin PlaceSeeing ( GetX ( Denis ) , GetY ( Denis ) , 1 , - 12 ) ;
3175: LD_EXP 19
3179: PPUSH
3180: CALL_OW 250
3184: PPUSH
3185: LD_EXP 19
3189: PPUSH
3190: CALL_OW 251
3194: PPUSH
3195: LD_INT 1
3197: PPUSH
3198: LD_INT 12
3200: NEG
3201: PPUSH
3202: CALL_OW 330
// CenterNowOnUnits ( Denis ) ;
3206: LD_EXP 19
3210: PPUSH
3211: CALL_OW 87
// wait ( 0 0$5 ) ;
3215: LD_INT 175
3217: PPUSH
3218: CALL_OW 67
// RemoveSeeing ( GetX ( Denis ) , GetY ( Denis ) , 1 ) ;
3222: LD_EXP 19
3226: PPUSH
3227: CALL_OW 250
3231: PPUSH
3232: LD_EXP 19
3236: PPUSH
3237: CALL_OW 251
3241: PPUSH
3242: LD_INT 1
3244: PPUSH
3245: CALL_OW 331
// end ; repeat wait ( 0 0$01 ) ;
3249: LD_INT 35
3251: PPUSH
3252: CALL_OW 67
// until See ( 1 , Denis ) or IsDead ( Denis ) ;
3256: LD_INT 1
3258: PPUSH
3259: LD_EXP 19
3263: PPUSH
3264: CALL_OW 292
3268: PUSH
3269: LD_EXP 19
3273: PPUSH
3274: CALL_OW 301
3278: OR
3279: IFFALSE 3249
// if IsDead ( Denis ) then
3281: LD_EXP 19
3285: PPUSH
3286: CALL_OW 301
3290: IFFALSE 3294
// exit ;
3292: GO 3530
// SetSide ( Denis , 1 ) ;
3294: LD_EXP 19
3298: PPUSH
3299: LD_INT 1
3301: PPUSH
3302: CALL_OW 235
// Say ( Denis , DD-Den-2a ) ;
3306: LD_EXP 19
3310: PPUSH
3311: LD_STRING DD-Den-2a
3313: PPUSH
3314: CALL_OW 88
// repeat wait ( 0 0$01 ) ;
3318: LD_INT 35
3320: PPUSH
3321: CALL_OW 67
// until GetBType ( IsInUnit ( Denis ) ) in [ b_lab , b_lab_half , b_lab_full ] or IsDead ( Denis ) ;
3325: LD_EXP 19
3329: PPUSH
3330: CALL_OW 310
3334: PPUSH
3335: CALL_OW 266
3339: PUSH
3340: LD_INT 6
3342: PUSH
3343: LD_INT 7
3345: PUSH
3346: LD_INT 8
3348: PUSH
3349: EMPTY
3350: LIST
3351: LIST
3352: LIST
3353: IN
3354: PUSH
3355: LD_EXP 19
3359: PPUSH
3360: CALL_OW 301
3364: OR
3365: IFFALSE 3318
// if IsDead ( Denis ) then
3367: LD_EXP 19
3371: PPUSH
3372: CALL_OW 301
3376: IFFALSE 3380
// exit ;
3378: GO 3530
// Say ( Denis , DD-Den-2b ) ;
3380: LD_EXP 19
3384: PPUSH
3385: LD_STRING DD-Den-2b
3387: PPUSH
3388: CALL_OW 88
// ComChangeProfession ( Denis , 4 ) ;
3392: LD_EXP 19
3396: PPUSH
3397: LD_INT 4
3399: PPUSH
3400: CALL_OW 123
// Wait ( 0 0$02 ) ;
3404: LD_INT 70
3406: PPUSH
3407: CALL_OW 67
// DialogueOn ;
3411: CALL_OW 6
// CenterNowOnUnits ( Denis ) ;
3415: LD_EXP 19
3419: PPUSH
3420: CALL_OW 87
// Say ( JMM , D4-JMM-1 ) ;
3424: LD_EXP 16
3428: PPUSH
3429: LD_STRING D4-JMM-1
3431: PPUSH
3432: CALL_OW 88
// Say ( Denis , D4-Den-1 ) ;
3436: LD_EXP 19
3440: PPUSH
3441: LD_STRING D4-Den-1
3443: PPUSH
3444: CALL_OW 88
// Say ( JMM , D4-JMM-2 ) ;
3448: LD_EXP 16
3452: PPUSH
3453: LD_STRING D4-JMM-2
3455: PPUSH
3456: CALL_OW 88
// Say ( Denis , D4-Den-2 ) ;
3460: LD_EXP 19
3464: PPUSH
3465: LD_STRING D4-Den-2
3467: PPUSH
3468: CALL_OW 88
// DialogueOff ;
3472: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
3476: LD_STRING M2
3478: PPUSH
3479: CALL_OW 337
// radar_allowed := true ;
3483: LD_ADDR_EXP 7
3487: PUSH
3488: LD_INT 1
3490: ST_TO_ADDR
// SetTech ( tech_radar , 1 , state_enabled ) ;
3491: LD_INT 6
3493: PPUSH
3494: LD_INT 1
3496: PPUSH
3497: LD_INT 1
3499: PPUSH
3500: CALL_OW 322
// SetRestrict ( b_lab_opto , 1 , state_enabled ) ;
3504: LD_INT 15
3506: PPUSH
3507: LD_INT 1
3509: PPUSH
3510: LD_INT 1
3512: PPUSH
3513: CALL_OW 324
// SetRestrict ( b_ext_radar , 1 , state_enabled ) ;
3517: LD_INT 20
3519: PPUSH
3520: LD_INT 1
3522: PPUSH
3523: LD_INT 1
3525: PPUSH
3526: CALL_OW 324
// end ;
3530: END
// every 0 0$1 trigger arab_spotted do var sol , sol2 ;
3531: LD_EXP 13
3535: IFFALSE 4158
3537: GO 3539
3539: DISABLE
3540: LD_INT 0
3542: PPUSH
3543: PPUSH
// begin sol := SayX ( UnitFilter ( others , [ f_sex , sex_male ] ) , D5-Sol1-1 ) ;
3544: LD_ADDR_VAR 0 1
3548: PUSH
3549: LD_EXP 26
3553: PPUSH
3554: LD_INT 26
3556: PUSH
3557: LD_INT 1
3559: PUSH
3560: EMPTY
3561: LIST
3562: LIST
3563: PPUSH
3564: CALL_OW 72
3568: PPUSH
3569: LD_STRING D5-Sol1-1
3571: PPUSH
3572: CALL 578 0 2
3576: ST_TO_ADDR
// if not sol then
3577: LD_VAR 0 1
3581: NOT
3582: IFFALSE 3586
// exit ;
3584: GO 4158
// repeat wait ( 0 0$01 ) ;
3586: LD_INT 35
3588: PPUSH
3589: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 ;
3593: LD_INT 22
3595: PUSH
3596: LD_INT 2
3598: PUSH
3599: EMPTY
3600: LIST
3601: LIST
3602: PUSH
3603: LD_INT 21
3605: PUSH
3606: LD_INT 1
3608: PUSH
3609: EMPTY
3610: LIST
3611: LIST
3612: PUSH
3613: EMPTY
3614: LIST
3615: LIST
3616: PPUSH
3617: CALL_OW 69
3621: PUSH
3622: LD_INT 0
3624: EQUAL
3625: IFFALSE 3586
// if IsOk ( sol ) then
3627: LD_VAR 0 1
3631: PPUSH
3632: CALL_OW 302
3636: IFFALSE 3656
// begin sol2 := others diff sol ;
3638: LD_ADDR_VAR 0 2
3642: PUSH
3643: LD_EXP 26
3647: PUSH
3648: LD_VAR 0 1
3652: DIFF
3653: ST_TO_ADDR
// end else
3654: GO 3658
// exit ;
3656: GO 4158
// if not Lisa and not sol2 then
3658: LD_EXP 22
3662: NOT
3663: PUSH
3664: LD_VAR 0 2
3668: NOT
3669: AND
3670: IFFALSE 3674
// exit ;
3672: GO 4158
// DialogueOn ;
3674: CALL_OW 6
// if Lisa then
3678: LD_EXP 22
3682: IFFALSE 3698
// Say ( Lisa , D5a-Lisa-1 ) else
3684: LD_EXP 22
3688: PPUSH
3689: LD_STRING D5a-Lisa-1
3691: PPUSH
3692: CALL_OW 88
3696: GO 3773
// if sol2 then
3698: LD_VAR 0 2
3702: IFFALSE 3773
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3704: LD_VAR 0 2
3708: PUSH
3709: LD_INT 1
3711: ARRAY
3712: PPUSH
3713: CALL_OW 258
3717: PUSH
3718: LD_INT 1
3720: DOUBLE
3721: EQUAL
3722: IFTRUE 3726
3724: GO 3745
3726: POP
// Say ( sol2 [ 1 ] , D5-Sol2-1 ) ; sex_female :
3727: LD_VAR 0 2
3731: PUSH
3732: LD_INT 1
3734: ARRAY
3735: PPUSH
3736: LD_STRING D5-Sol2-1
3738: PPUSH
3739: CALL_OW 88
3743: GO 3773
3745: LD_INT 2
3747: DOUBLE
3748: EQUAL
3749: IFTRUE 3753
3751: GO 3772
3753: POP
// Say ( sol2 [ 1 ] , D5-FSol2-1 ) ; end ;
3754: LD_VAR 0 2
3758: PUSH
3759: LD_INT 1
3761: ARRAY
3762: PPUSH
3763: LD_STRING D5-FSol2-1
3765: PPUSH
3766: CALL_OW 88
3770: GO 3773
3772: POP
// Say ( sol , D5-Sol1-2 ) ;
3773: LD_VAR 0 1
3777: PPUSH
3778: LD_STRING D5-Sol1-2
3780: PPUSH
3781: CALL_OW 88
// if Lisa then
3785: LD_EXP 22
3789: IFFALSE 3805
// Say ( Lisa , D5a-Lisa-2 ) else
3791: LD_EXP 22
3795: PPUSH
3796: LD_STRING D5a-Lisa-2
3798: PPUSH
3799: CALL_OW 88
3803: GO 3880
// if sol2 then
3805: LD_VAR 0 2
3809: IFFALSE 3880
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3811: LD_VAR 0 2
3815: PUSH
3816: LD_INT 1
3818: ARRAY
3819: PPUSH
3820: CALL_OW 258
3824: PUSH
3825: LD_INT 1
3827: DOUBLE
3828: EQUAL
3829: IFTRUE 3833
3831: GO 3852
3833: POP
// Say ( sol2 [ 1 ] , D5-Sol2-2 ) ; sex_female :
3834: LD_VAR 0 2
3838: PUSH
3839: LD_INT 1
3841: ARRAY
3842: PPUSH
3843: LD_STRING D5-Sol2-2
3845: PPUSH
3846: CALL_OW 88
3850: GO 3880
3852: LD_INT 2
3854: DOUBLE
3855: EQUAL
3856: IFTRUE 3860
3858: GO 3879
3860: POP
// Say ( sol2 [ 1 ] , D5-FSol2-2 ) ; end ;
3861: LD_VAR 0 2
3865: PUSH
3866: LD_INT 1
3868: ARRAY
3869: PPUSH
3870: LD_STRING D5-FSol2-2
3872: PPUSH
3873: CALL_OW 88
3877: GO 3880
3879: POP
// Say ( sol , D5a-Sol1-3 ) ;
3880: LD_VAR 0 1
3884: PPUSH
3885: LD_STRING D5a-Sol1-3
3887: PPUSH
3888: CALL_OW 88
// if Lisa then
3892: LD_EXP 22
3896: IFFALSE 3910
// Say ( Lisa , D5a-Lisa-3 ) ;
3898: LD_EXP 22
3902: PPUSH
3903: LD_STRING D5a-Lisa-3
3905: PPUSH
3906: CALL_OW 88
// if not sol2 then
3910: LD_VAR 0 2
3914: NOT
3915: IFFALSE 3923
// begin DialogueOff ;
3917: CALL_OW 7
// exit ;
3921: GO 4158
// end ; case GetSex ( sol2 [ 1 ] ) of sex_male :
3923: LD_VAR 0 2
3927: PUSH
3928: LD_INT 1
3930: ARRAY
3931: PPUSH
3932: CALL_OW 258
3936: PUSH
3937: LD_INT 1
3939: DOUBLE
3940: EQUAL
3941: IFTRUE 3945
3943: GO 3964
3945: POP
// Say ( sol2 [ 1 ] , D5-Sol2-3 ) ; sex_female :
3946: LD_VAR 0 2
3950: PUSH
3951: LD_INT 1
3953: ARRAY
3954: PPUSH
3955: LD_STRING D5-Sol2-3
3957: PPUSH
3958: CALL_OW 88
3962: GO 3992
3964: LD_INT 2
3966: DOUBLE
3967: EQUAL
3968: IFTRUE 3972
3970: GO 3991
3972: POP
// Say ( sol2 [ 1 ] , D5-FSol2-3 ) ; end ;
3973: LD_VAR 0 2
3977: PUSH
3978: LD_INT 1
3980: ARRAY
3981: PPUSH
3982: LD_STRING D5-FSol2-3
3984: PPUSH
3985: CALL_OW 88
3989: GO 3992
3991: POP
// Say ( sol , D5-Sol1-4 ) ;
3992: LD_VAR 0 1
3996: PPUSH
3997: LD_STRING D5-Sol1-4
3999: PPUSH
4000: CALL_OW 88
// case GetSex ( sol2 [ 1 ] ) of sex_male :
4004: LD_VAR 0 2
4008: PUSH
4009: LD_INT 1
4011: ARRAY
4012: PPUSH
4013: CALL_OW 258
4017: PUSH
4018: LD_INT 1
4020: DOUBLE
4021: EQUAL
4022: IFTRUE 4026
4024: GO 4045
4026: POP
// Say ( sol2 [ 1 ] , D5-Sol2-4 ) ; sex_female :
4027: LD_VAR 0 2
4031: PUSH
4032: LD_INT 1
4034: ARRAY
4035: PPUSH
4036: LD_STRING D5-Sol2-4
4038: PPUSH
4039: CALL_OW 88
4043: GO 4073
4045: LD_INT 2
4047: DOUBLE
4048: EQUAL
4049: IFTRUE 4053
4051: GO 4072
4053: POP
// Say ( sol2 [ 1 ] , D5-FSol2-4 ) ; end ;
4054: LD_VAR 0 2
4058: PUSH
4059: LD_INT 1
4061: ARRAY
4062: PPUSH
4063: LD_STRING D5-FSol2-4
4065: PPUSH
4066: CALL_OW 88
4070: GO 4073
4072: POP
// Say ( sol , D5-Sol1-5 ) ;
4073: LD_VAR 0 1
4077: PPUSH
4078: LD_STRING D5-Sol1-5
4080: PPUSH
4081: CALL_OW 88
// case GetSex ( sol2 [ 1 ] ) of sex_male :
4085: LD_VAR 0 2
4089: PUSH
4090: LD_INT 1
4092: ARRAY
4093: PPUSH
4094: CALL_OW 258
4098: PUSH
4099: LD_INT 1
4101: DOUBLE
4102: EQUAL
4103: IFTRUE 4107
4105: GO 4126
4107: POP
// Say ( sol2 [ 1 ] , D5-Sol2-5 ) ; sex_female :
4108: LD_VAR 0 2
4112: PUSH
4113: LD_INT 1
4115: ARRAY
4116: PPUSH
4117: LD_STRING D5-Sol2-5
4119: PPUSH
4120: CALL_OW 88
4124: GO 4154
4126: LD_INT 2
4128: DOUBLE
4129: EQUAL
4130: IFTRUE 4134
4132: GO 4153
4134: POP
// Say ( sol2 [ 1 ] , D5-FSol2-5 ) ; end ;
4135: LD_VAR 0 2
4139: PUSH
4140: LD_INT 1
4142: ARRAY
4143: PPUSH
4144: LD_STRING D5-FSol2-5
4146: PPUSH
4147: CALL_OW 88
4151: GO 4154
4153: POP
// DialogueOff ;
4154: CALL_OW 7
// end ;
4158: PPOPN 2
4160: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) >= 5 do
4161: LD_INT 22
4163: PUSH
4164: LD_INT 1
4166: PUSH
4167: EMPTY
4168: LIST
4169: LIST
4170: PUSH
4171: LD_INT 25
4173: PUSH
4174: LD_INT 16
4176: PUSH
4177: EMPTY
4178: LIST
4179: LIST
4180: PUSH
4181: EMPTY
4182: LIST
4183: LIST
4184: PPUSH
4185: CALL_OW 69
4189: PUSH
4190: LD_INT 5
4192: GREATEREQUAL
4193: IFFALSE 4213
4195: GO 4197
4197: DISABLE
// begin ChangeMissionObjectives ( M1b ) ;
4198: LD_STRING M1b
4200: PPUSH
4201: CALL_OW 337
// apeman_army := true ;
4205: LD_ADDR_EXP 9
4209: PUSH
4210: LD_INT 1
4212: ST_TO_ADDR
// end ;
4213: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_factory ] , [ f_constructed ] ] ) do
4214: LD_INT 22
4216: PUSH
4217: LD_INT 1
4219: PUSH
4220: EMPTY
4221: LIST
4222: LIST
4223: PUSH
4224: LD_INT 30
4226: PUSH
4227: LD_INT 3
4229: PUSH
4230: EMPTY
4231: LIST
4232: LIST
4233: PUSH
4234: LD_INT 57
4236: PUSH
4237: EMPTY
4238: LIST
4239: PUSH
4240: EMPTY
4241: LIST
4242: LIST
4243: LIST
4244: PPUSH
4245: CALL_OW 69
4249: IFFALSE 4261
4251: GO 4253
4253: DISABLE
// ChangeMissionObjectives ( M1c ) ;
4254: LD_STRING M1c
4256: PPUSH
4257: CALL_OW 337
4261: END
// every 0 0$1 trigger GetTech ( tech_radar , 1 ) = state_researched do
4262: LD_INT 6
4264: PPUSH
4265: LD_INT 1
4267: PPUSH
4268: CALL_OW 321
4272: PUSH
4273: LD_INT 2
4275: EQUAL
4276: IFFALSE 4296
4278: GO 4280
4280: DISABLE
// begin ChangeMissionObjectives ( M2a ) ;
4281: LD_STRING M2a
4283: PPUSH
4284: CALL_OW 337
// radar_researched := true ;
4288: LD_ADDR_EXP 10
4292: PUSH
4293: LD_INT 1
4295: ST_TO_ADDR
// end ;
4296: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_weapon , us_radar ] , [ f_bweapon , us_radar ] ] ] ) do
4297: LD_INT 22
4299: PUSH
4300: LD_INT 1
4302: PUSH
4303: EMPTY
4304: LIST
4305: LIST
4306: PUSH
4307: LD_INT 2
4309: PUSH
4310: LD_INT 34
4312: PUSH
4313: LD_INT 11
4315: PUSH
4316: EMPTY
4317: LIST
4318: LIST
4319: PUSH
4320: LD_INT 35
4322: PUSH
4323: LD_INT 11
4325: PUSH
4326: EMPTY
4327: LIST
4328: LIST
4329: PUSH
4330: EMPTY
4331: LIST
4332: LIST
4333: LIST
4334: PUSH
4335: EMPTY
4336: LIST
4337: LIST
4338: PPUSH
4339: CALL_OW 69
4343: IFFALSE 4363
4345: GO 4347
4347: DISABLE
// begin ChangeMissionObjectives ( M2b ) ;
4348: LD_STRING M2b
4350: PPUSH
4351: CALL_OW 337
// radar_builded := true ;
4355: LD_ADDR_EXP 11
4359: PUSH
4360: LD_INT 1
4362: ST_TO_ADDR
// end ;
4363: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) = 0 and not first_apeman_tamed do
4364: LD_INT 22
4366: PUSH
4367: LD_INT 0
4369: PUSH
4370: EMPTY
4371: LIST
4372: LIST
4373: PUSH
4374: LD_INT 25
4376: PUSH
4377: LD_INT 12
4379: PUSH
4380: EMPTY
4381: LIST
4382: LIST
4383: PUSH
4384: EMPTY
4385: LIST
4386: LIST
4387: PPUSH
4388: CALL_OW 69
4392: PUSH
4393: LD_INT 0
4395: EQUAL
4396: PUSH
4397: LD_EXP 8
4401: NOT
4402: AND
4403: IFFALSE 4415
4405: GO 4407
4407: DISABLE
// YouLost ( Apeman ) ;
4408: LD_STRING Apeman
4410: PPUSH
4411: CALL_OW 104
4415: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) >= 7 do var i , filter ;
4416: LD_INT 22
4418: PUSH
4419: LD_INT 1
4421: PUSH
4422: EMPTY
4423: LIST
4424: LIST
4425: PUSH
4426: LD_INT 25
4428: PUSH
4429: LD_INT 16
4431: PUSH
4432: EMPTY
4433: LIST
4434: LIST
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: PPUSH
4440: CALL_OW 69
4444: PUSH
4445: LD_INT 7
4447: GREATEREQUAL
4448: IFFALSE 4546
4450: GO 4452
4452: DISABLE
4453: LD_INT 0
4455: PPUSH
4456: PPUSH
// begin filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , 4 ] ] ) ^ JMM ;
4457: LD_ADDR_VAR 0 2
4461: PUSH
4462: LD_INT 22
4464: PUSH
4465: LD_INT 1
4467: PUSH
4468: EMPTY
4469: LIST
4470: LIST
4471: PUSH
4472: LD_INT 21
4474: PUSH
4475: LD_INT 1
4477: PUSH
4478: EMPTY
4479: LIST
4480: LIST
4481: PUSH
4482: LD_INT 25
4484: PUSH
4485: LD_INT 4
4487: PUSH
4488: EMPTY
4489: LIST
4490: LIST
4491: PUSH
4492: EMPTY
4493: LIST
4494: LIST
4495: LIST
4496: PPUSH
4497: CALL_OW 69
4501: PUSH
4502: LD_EXP 16
4506: ADD
4507: ST_TO_ADDR
// if filter then
4508: LD_VAR 0 2
4512: IFFALSE 4546
// for i in filter do
4514: LD_ADDR_VAR 0 1
4518: PUSH
4519: LD_VAR 0 2
4523: PUSH
4524: FOR_IN
4525: IFFALSE 4544
// AddExperience ( i , 4 , 3500 ) ;
4527: LD_VAR 0 1
4531: PPUSH
4532: LD_INT 4
4534: PPUSH
4535: LD_INT 3500
4537: PPUSH
4538: CALL_OW 492
4542: GO 4524
4544: POP
4545: POP
// end ;
4546: PPOPN 2
4548: END
// every 0 0$1 trigger end_mission do var i , tmp , m1 , m2 , m3 ;
4549: LD_EXP 14
4553: IFFALSE 5687
4555: GO 4557
4557: DISABLE
4558: LD_INT 0
4560: PPUSH
4561: PPUSH
4562: PPUSH
4563: PPUSH
4564: PPUSH
// begin if apeKillCounter = 0 then
4565: LD_EXP 15
4569: PUSH
4570: LD_INT 0
4572: EQUAL
4573: IFFALSE 4582
// SetAchievement ( ACH_APEKILLER ) ;
4575: LD_STRING ACH_APEKILLER
4577: PPUSH
4578: CALL_OW 543
// if FilterAllUnits ( [ f_side , 2 ] ) then
4582: LD_INT 22
4584: PUSH
4585: LD_INT 2
4587: PUSH
4588: EMPTY
4589: LIST
4590: LIST
4591: PPUSH
4592: CALL_OW 69
4596: IFFALSE 4634
// for i in FilterAllUnits ( [ f_side , 2 ] ) do
4598: LD_ADDR_VAR 0 1
4602: PUSH
4603: LD_INT 22
4605: PUSH
4606: LD_INT 2
4608: PUSH
4609: EMPTY
4610: LIST
4611: LIST
4612: PPUSH
4613: CALL_OW 69
4617: PUSH
4618: FOR_IN
4619: IFFALSE 4632
// RemoveUnit ( i ) ;
4621: LD_VAR 0 1
4625: PPUSH
4626: CALL_OW 64
4630: GO 4618
4632: POP
4633: POP
// m1 := false ;
4634: LD_ADDR_VAR 0 3
4638: PUSH
4639: LD_INT 0
4641: ST_TO_ADDR
// m2 := false ;
4642: LD_ADDR_VAR 0 4
4646: PUSH
4647: LD_INT 0
4649: ST_TO_ADDR
// m3 := false ;
4650: LD_ADDR_VAR 0 5
4654: PUSH
4655: LD_INT 0
4657: ST_TO_ADDR
// if apeman_army then
4658: LD_EXP 9
4662: IFFALSE 4684
// begin AddMedal ( Tame , 1 ) ;
4664: LD_STRING Tame
4666: PPUSH
4667: LD_INT 1
4669: PPUSH
4670: CALL_OW 101
// m1 := true ;
4674: LD_ADDR_VAR 0 3
4678: PUSH
4679: LD_INT 1
4681: ST_TO_ADDR
// end else
4682: GO 4695
// AddMedal ( Tame , - 1 ) ;
4684: LD_STRING Tame
4686: PPUSH
4687: LD_INT 1
4689: NEG
4690: PPUSH
4691: CALL_OW 101
// if radar_researched then
4695: LD_EXP 10
4699: IFFALSE 4731
// begin SaveVariable ( true , radarResInDelta ) ;
4701: LD_INT 1
4703: PPUSH
4704: LD_STRING radarResInDelta
4706: PPUSH
4707: CALL_OW 39
// AddMedal ( Radar , 1 ) ;
4711: LD_STRING Radar
4713: PPUSH
4714: LD_INT 1
4716: PPUSH
4717: CALL_OW 101
// m2 := true ;
4721: LD_ADDR_VAR 0 4
4725: PUSH
4726: LD_INT 1
4728: ST_TO_ADDR
// end else
4729: GO 4761
// if radar_allowed then
4731: LD_EXP 7
4735: IFFALSE 4750
// AddMedal ( Radar , - 2 ) else
4737: LD_STRING Radar
4739: PPUSH
4740: LD_INT 2
4742: NEG
4743: PPUSH
4744: CALL_OW 101
4748: GO 4761
// AddMedal ( Radar , - 1 ) ;
4750: LD_STRING Radar
4752: PPUSH
4753: LD_INT 1
4755: NEG
4756: PPUSH
4757: CALL_OW 101
// if radar_builded then
4761: LD_EXP 11
4765: IFFALSE 4787
// begin AddMedal ( BuildRadar , 1 ) ;
4767: LD_STRING BuildRadar
4769: PPUSH
4770: LD_INT 1
4772: PPUSH
4773: CALL_OW 101
// m3 := true ;
4777: LD_ADDR_VAR 0 5
4781: PUSH
4782: LD_INT 1
4784: ST_TO_ADDR
// end else
4785: GO 4798
// AddMedal ( BuildRadar , - 1 ) ;
4787: LD_STRING BuildRadar
4789: PPUSH
4790: LD_INT 1
4792: NEG
4793: PPUSH
4794: CALL_OW 101
// if tick <= 7 7$00 then
4798: LD_OWVAR 1
4802: PUSH
4803: LD_INT 14700
4805: LESSEQUAL
4806: IFFALSE 4815
// SetAchievement ( ACH_ASPEED_5 ) ;
4808: LD_STRING ACH_ASPEED_5
4810: PPUSH
4811: CALL_OW 543
// if m1 and m2 and m3 and Difficulty = 3 then
4815: LD_VAR 0 3
4819: PUSH
4820: LD_VAR 0 4
4824: AND
4825: PUSH
4826: LD_VAR 0 5
4830: AND
4831: PUSH
4832: LD_OWVAR 67
4836: PUSH
4837: LD_INT 3
4839: EQUAL
4840: AND
4841: IFFALSE 4853
// SetAchievementEX ( ACH_AMER , 5 ) ;
4843: LD_STRING ACH_AMER
4845: PPUSH
4846: LD_INT 5
4848: PPUSH
4849: CALL_OW 564
// GiveMedals ( MAIN ) ;
4853: LD_STRING MAIN
4855: PPUSH
4856: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
4860: LD_ADDR_VAR 0 2
4864: PUSH
4865: LD_INT 22
4867: PUSH
4868: LD_INT 1
4870: PUSH
4871: EMPTY
4872: LIST
4873: LIST
4874: PUSH
4875: LD_INT 21
4877: PUSH
4878: LD_INT 1
4880: PUSH
4881: EMPTY
4882: LIST
4883: LIST
4884: PUSH
4885: LD_INT 2
4887: PUSH
4888: LD_INT 25
4890: PUSH
4891: LD_INT 1
4893: PUSH
4894: EMPTY
4895: LIST
4896: LIST
4897: PUSH
4898: LD_INT 25
4900: PUSH
4901: LD_INT 2
4903: PUSH
4904: EMPTY
4905: LIST
4906: LIST
4907: PUSH
4908: LD_INT 25
4910: PUSH
4911: LD_INT 3
4913: PUSH
4914: EMPTY
4915: LIST
4916: LIST
4917: PUSH
4918: LD_INT 25
4920: PUSH
4921: LD_INT 4
4923: PUSH
4924: EMPTY
4925: LIST
4926: LIST
4927: PUSH
4928: EMPTY
4929: LIST
4930: LIST
4931: LIST
4932: LIST
4933: LIST
4934: PUSH
4935: EMPTY
4936: LIST
4937: LIST
4938: LIST
4939: PPUSH
4940: CALL_OW 69
4944: ST_TO_ADDR
// RewardPeople ( tmp ) ;
4945: LD_VAR 0 2
4949: PPUSH
4950: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
4954: LD_EXP 16
4958: PPUSH
4959: LD_EXP 2
4963: PUSH
4964: LD_STRING JMM
4966: STR
4967: PPUSH
4968: CALL_OW 38
// if IsOk ( Gladstone ) then
4972: LD_EXP 17
4976: PPUSH
4977: CALL_OW 302
4981: IFFALSE 5001
// begin SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
4983: LD_EXP 17
4987: PPUSH
4988: LD_EXP 2
4992: PUSH
4993: LD_STRING Gladstone
4995: STR
4996: PPUSH
4997: CALL_OW 38
// end ; if IsOk ( Denis ) and GetSide ( Denis ) = 1 then
5001: LD_EXP 19
5005: PPUSH
5006: CALL_OW 302
5010: PUSH
5011: LD_EXP 19
5015: PPUSH
5016: CALL_OW 255
5020: PUSH
5021: LD_INT 1
5023: EQUAL
5024: AND
5025: IFFALSE 5055
// begin SaveCharacters ( Denis , mission_prefix & Denis ) ;
5027: LD_EXP 19
5031: PPUSH
5032: LD_EXP 2
5036: PUSH
5037: LD_STRING Denis
5039: STR
5040: PPUSH
5041: CALL_OW 38
// SaveVariable ( true , DenisInDelta ) ;
5045: LD_INT 1
5047: PPUSH
5048: LD_STRING DenisInDelta
5050: PPUSH
5051: CALL_OW 39
// end ; if IsOk ( Lisa ) then
5055: LD_EXP 22
5059: PPUSH
5060: CALL_OW 302
5064: IFFALSE 5084
// begin SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
5066: LD_EXP 22
5070: PPUSH
5071: LD_EXP 2
5075: PUSH
5076: LD_STRING Lisa
5078: STR
5079: PPUSH
5080: CALL_OW 38
// end ; if IsOk ( Frank ) then
5084: LD_EXP 23
5088: PPUSH
5089: CALL_OW 302
5093: IFFALSE 5113
// begin SaveCharacters ( Frank , mission_prefix & Frank ) ;
5095: LD_EXP 23
5099: PPUSH
5100: LD_EXP 2
5104: PUSH
5105: LD_STRING Frank
5107: STR
5108: PPUSH
5109: CALL_OW 38
// end ; if IsOk ( Bobby ) then
5113: LD_EXP 24
5117: PPUSH
5118: CALL_OW 302
5122: IFFALSE 5142
// begin SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
5124: LD_EXP 24
5128: PPUSH
5129: LD_EXP 2
5133: PUSH
5134: LD_STRING Bobby
5136: STR
5137: PPUSH
5138: CALL_OW 38
// end ; if IsOk ( Cyrus ) then
5142: LD_EXP 25
5146: PPUSH
5147: CALL_OW 302
5151: IFFALSE 5171
// begin SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
5153: LD_EXP 25
5157: PPUSH
5158: LD_EXP 2
5162: PUSH
5163: LD_STRING Cyrus
5165: STR
5166: PPUSH
5167: CALL_OW 38
// end ; if IsOk ( Brown ) then
5171: LD_EXP 20
5175: PPUSH
5176: CALL_OW 302
5180: IFFALSE 5200
// begin SaveCharacters ( Brown , mission_prefix & Brown ) ;
5182: LD_EXP 20
5186: PPUSH
5187: LD_EXP 2
5191: PUSH
5192: LD_STRING Brown
5194: STR
5195: PPUSH
5196: CALL_OW 38
// end ; if IsOk ( Donaldson ) then
5200: LD_EXP 21
5204: PPUSH
5205: CALL_OW 302
5209: IFFALSE 5229
// begin SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
5211: LD_EXP 21
5215: PPUSH
5216: LD_EXP 2
5220: PUSH
5221: LD_STRING Donaldson
5223: STR
5224: PPUSH
5225: CALL_OW 38
// end ; if others then
5229: LD_EXP 26
5233: IFFALSE 5247
// SaveCharacters ( others , othersInDelta ) ;
5235: LD_EXP 26
5239: PPUSH
5240: LD_STRING othersInDelta
5242: PPUSH
5243: CALL_OW 38
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) then
5247: LD_INT 22
5249: PUSH
5250: LD_INT 1
5252: PUSH
5253: EMPTY
5254: LIST
5255: LIST
5256: PUSH
5257: LD_INT 25
5259: PUSH
5260: LD_INT 16
5262: PUSH
5263: EMPTY
5264: LIST
5265: LIST
5266: PUSH
5267: EMPTY
5268: LIST
5269: LIST
5270: PPUSH
5271: CALL_OW 69
5275: IFFALSE 5313
// SaveCharacters ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) , apeInDelta ) ;
5277: LD_INT 22
5279: PUSH
5280: LD_INT 1
5282: PUSH
5283: EMPTY
5284: LIST
5285: LIST
5286: PUSH
5287: LD_INT 25
5289: PUSH
5290: LD_INT 16
5292: PUSH
5293: EMPTY
5294: LIST
5295: LIST
5296: PUSH
5297: EMPTY
5298: LIST
5299: LIST
5300: PPUSH
5301: CALL_OW 69
5305: PPUSH
5306: LD_STRING apeInDelta
5308: PPUSH
5309: CALL_OW 38
// tmp := [ ] ;
5313: LD_ADDR_VAR 0 2
5317: PUSH
5318: EMPTY
5319: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) then
5320: LD_INT 22
5322: PUSH
5323: LD_INT 1
5325: PUSH
5326: EMPTY
5327: LIST
5328: LIST
5329: PUSH
5330: LD_INT 21
5332: PUSH
5333: LD_INT 2
5335: PUSH
5336: EMPTY
5337: LIST
5338: LIST
5339: PUSH
5340: EMPTY
5341: LIST
5342: LIST
5343: PPUSH
5344: CALL_OW 69
5348: IFFALSE 5459
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) do
5350: LD_ADDR_VAR 0 1
5354: PUSH
5355: LD_INT 22
5357: PUSH
5358: LD_INT 1
5360: PUSH
5361: EMPTY
5362: LIST
5363: LIST
5364: PUSH
5365: LD_INT 21
5367: PUSH
5368: LD_INT 2
5370: PUSH
5371: EMPTY
5372: LIST
5373: LIST
5374: PUSH
5375: EMPTY
5376: LIST
5377: LIST
5378: PPUSH
5379: CALL_OW 69
5383: PUSH
5384: FOR_IN
5385: IFFALSE 5457
// tmp := tmp ^ [ GetNation ( i ) , GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) ] ;
5387: LD_ADDR_VAR 0 2
5391: PUSH
5392: LD_VAR 0 2
5396: PUSH
5397: LD_VAR 0 1
5401: PPUSH
5402: CALL_OW 248
5406: PUSH
5407: LD_VAR 0 1
5411: PPUSH
5412: CALL_OW 265
5416: PUSH
5417: LD_VAR 0 1
5421: PPUSH
5422: CALL_OW 262
5426: PUSH
5427: LD_VAR 0 1
5431: PPUSH
5432: CALL_OW 263
5436: PUSH
5437: LD_VAR 0 1
5441: PPUSH
5442: CALL_OW 264
5446: PUSH
5447: EMPTY
5448: LIST
5449: LIST
5450: LIST
5451: LIST
5452: LIST
5453: ADD
5454: ST_TO_ADDR
5455: GO 5384
5457: POP
5458: POP
// if tmp then
5459: LD_VAR 0 2
5463: IFFALSE 5477
// SaveVariable ( tmp , vehiclesInDelta ) ;
5465: LD_VAR 0 2
5469: PPUSH
5470: LD_STRING vehiclesInDelta
5472: PPUSH
5473: CALL_OW 39
// tmp := [ ] ;
5477: LD_ADDR_VAR 0 2
5481: PUSH
5482: EMPTY
5483: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) then
5484: LD_INT 22
5486: PUSH
5487: LD_INT 1
5489: PUSH
5490: EMPTY
5491: LIST
5492: LIST
5493: PUSH
5494: LD_INT 21
5496: PUSH
5497: LD_INT 3
5499: PUSH
5500: EMPTY
5501: LIST
5502: LIST
5503: PUSH
5504: EMPTY
5505: LIST
5506: LIST
5507: PPUSH
5508: CALL_OW 69
5512: IFFALSE 5665
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
5514: LD_ADDR_VAR 0 1
5518: PUSH
5519: LD_INT 22
5521: PUSH
5522: LD_INT 1
5524: PUSH
5525: EMPTY
5526: LIST
5527: LIST
5528: PUSH
5529: LD_INT 21
5531: PUSH
5532: LD_INT 3
5534: PUSH
5535: EMPTY
5536: LIST
5537: LIST
5538: PUSH
5539: EMPTY
5540: LIST
5541: LIST
5542: PPUSH
5543: CALL_OW 69
5547: PUSH
5548: FOR_IN
5549: IFFALSE 5663
// tmp := tmp ^ [ [ GetBType ( i ) , GetBLevel ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
5551: LD_ADDR_VAR 0 2
5555: PUSH
5556: LD_VAR 0 2
5560: PUSH
5561: LD_VAR 0 1
5565: PPUSH
5566: CALL_OW 266
5570: PUSH
5571: LD_VAR 0 1
5575: PPUSH
5576: CALL_OW 267
5580: PUSH
5581: LD_VAR 0 1
5585: PPUSH
5586: CALL_OW 250
5590: PUSH
5591: LD_VAR 0 1
5595: PPUSH
5596: CALL_OW 251
5600: PUSH
5601: LD_VAR 0 1
5605: PPUSH
5606: CALL_OW 254
5610: PUSH
5611: LD_VAR 0 1
5615: PPUSH
5616: LD_INT 1
5618: PPUSH
5619: CALL_OW 268
5623: PUSH
5624: LD_VAR 0 1
5628: PPUSH
5629: LD_INT 2
5631: PPUSH
5632: CALL_OW 268
5636: PUSH
5637: LD_VAR 0 1
5641: PPUSH
5642: CALL_OW 269
5646: PUSH
5647: EMPTY
5648: LIST
5649: LIST
5650: LIST
5651: LIST
5652: LIST
5653: LIST
5654: LIST
5655: LIST
5656: PUSH
5657: EMPTY
5658: LIST
5659: ADD
5660: ST_TO_ADDR
5661: GO 5548
5663: POP
5664: POP
// if tmp then
5665: LD_VAR 0 2
5669: IFFALSE 5683
// SaveVariable ( tmp , buildingsInDelta ) ;
5671: LD_VAR 0 2
5675: PPUSH
5676: LD_STRING buildingsInDelta
5678: PPUSH
5679: CALL_OW 39
// YouWin ;
5683: CALL_OW 103
// end ; end_of_file
5687: PPOPN 5
5689: END
// export function PrepareArabianTroops ( amount , skill , area ) ; var i , un , tmp ; begin
5690: LD_INT 0
5692: PPUSH
5693: PPUSH
5694: PPUSH
5695: PPUSH
// InitHc ;
5696: CALL_OW 19
// InitUc ;
5700: CALL_OW 18
// uc_side := 2 ;
5704: LD_ADDR_OWVAR 20
5708: PUSH
5709: LD_INT 2
5711: ST_TO_ADDR
// uc_nation := 2 ;
5712: LD_ADDR_OWVAR 21
5716: PUSH
5717: LD_INT 2
5719: ST_TO_ADDR
// if not amount then
5720: LD_VAR 0 1
5724: NOT
5725: IFFALSE 5729
// exit ;
5727: GO 5852
// for i = 1 to amount do
5729: LD_ADDR_VAR 0 5
5733: PUSH
5734: DOUBLE
5735: LD_INT 1
5737: DEC
5738: ST_TO_ADDR
5739: LD_VAR 0 1
5743: PUSH
5744: FOR_TO
5745: IFFALSE 5840
// begin PrepareHuman ( false , 1 , skill ) ;
5747: LD_INT 0
5749: PPUSH
5750: LD_INT 1
5752: PPUSH
5753: LD_VAR 0 2
5757: PPUSH
5758: CALL_OW 380
// un := CreateHuman ;
5762: LD_ADDR_VAR 0 6
5766: PUSH
5767: CALL_OW 44
5771: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
5772: LD_ADDR_VAR 0 7
5776: PUSH
5777: LD_VAR 0 7
5781: PPUSH
5782: LD_INT 1
5784: PPUSH
5785: LD_VAR 0 6
5789: PPUSH
5790: CALL_OW 2
5794: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5795: LD_VAR 0 6
5799: PPUSH
5800: LD_VAR 0 3
5804: PPUSH
5805: LD_INT 0
5807: PPUSH
5808: CALL_OW 49
// if i mod 2 = 0 then
5812: LD_VAR 0 5
5816: PUSH
5817: LD_INT 2
5819: MOD
5820: PUSH
5821: LD_INT 0
5823: EQUAL
5824: IFFALSE 5838
// SetTag ( un , 11 ) ;
5826: LD_VAR 0 6
5830: PPUSH
5831: LD_INT 11
5833: PPUSH
5834: CALL_OW 109
// end ;
5838: GO 5744
5840: POP
5841: POP
// result := tmp ;
5842: LD_ADDR_VAR 0 4
5846: PUSH
5847: LD_VAR 0 7
5851: ST_TO_ADDR
// end ;
5852: LD_VAR 0 4
5856: RET
// export ar_forces , ap_killers ; every 0 0$1 trigger Delta do var i , timer , more_troops , skill , eng , un , veh , force ;
5857: LD_EXP 6
5861: IFFALSE 6728
5863: GO 5865
5865: DISABLE
5866: LD_INT 0
5868: PPUSH
5869: PPUSH
5870: PPUSH
5871: PPUSH
5872: PPUSH
5873: PPUSH
5874: PPUSH
5875: PPUSH
// begin more_troops := false ;
5876: LD_ADDR_VAR 0 3
5880: PUSH
5881: LD_INT 0
5883: ST_TO_ADDR
// skill := [ 3 , 4 , 5 ] [ Difficulty ] ;
5884: LD_ADDR_VAR 0 4
5888: PUSH
5889: LD_INT 3
5891: PUSH
5892: LD_INT 4
5894: PUSH
5895: LD_INT 5
5897: PUSH
5898: EMPTY
5899: LIST
5900: LIST
5901: LIST
5902: PUSH
5903: LD_OWVAR 67
5907: ARRAY
5908: ST_TO_ADDR
// timer := [ 5 5$00 , 4 4$00 , 3 3$00 ] [ Difficulty ] ;
5909: LD_ADDR_VAR 0 2
5913: PUSH
5914: LD_INT 10500
5916: PUSH
5917: LD_INT 8400
5919: PUSH
5920: LD_INT 6300
5922: PUSH
5923: EMPTY
5924: LIST
5925: LIST
5926: LIST
5927: PUSH
5928: LD_OWVAR 67
5932: ARRAY
5933: ST_TO_ADDR
// force := [ ] ;
5934: LD_ADDR_VAR 0 8
5938: PUSH
5939: EMPTY
5940: ST_TO_ADDR
// ar_forces := [ ] ;
5941: LD_ADDR_EXP 27
5945: PUSH
5946: EMPTY
5947: ST_TO_ADDR
// ap_killers := [ ] ;
5948: LD_ADDR_EXP 28
5952: PUSH
5953: EMPTY
5954: ST_TO_ADDR
// Wait ( timer ) ;
5955: LD_VAR 0 2
5959: PPUSH
5960: CALL_OW 67
// if Denis and GetSide ( Denis ) = 4 then
5964: LD_EXP 19
5968: PUSH
5969: LD_EXP 19
5973: PPUSH
5974: CALL_OW 255
5978: PUSH
5979: LD_INT 4
5981: EQUAL
5982: AND
5983: IFFALSE 5992
// Wait ( 0 0$45 ) ;
5985: LD_INT 1575
5987: PPUSH
5988: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) then
5992: LD_INT 22
5994: PUSH
5995: LD_INT 1
5997: PUSH
5998: EMPTY
5999: LIST
6000: LIST
6001: PUSH
6002: LD_INT 30
6004: PUSH
6005: LD_INT 4
6007: PUSH
6008: EMPTY
6009: LIST
6010: LIST
6011: PUSH
6012: EMPTY
6013: LIST
6014: LIST
6015: PPUSH
6016: CALL_OW 69
6020: IFFALSE 6037
// begin Wait ( 1 1$25 ) ;
6022: LD_INT 2975
6024: PPUSH
6025: CALL_OW 67
// more_troops := true ;
6029: LD_ADDR_VAR 0 3
6033: PUSH
6034: LD_INT 1
6036: ST_TO_ADDR
// end ; if more_troops then
6037: LD_VAR 0 3
6041: IFFALSE 6229
// begin force := PrepareArabianTroops ( [ 4 , 5 , 6 ] [ Difficulty ] , skill , arArea2 ) ;
6043: LD_ADDR_VAR 0 8
6047: PUSH
6048: LD_INT 4
6050: PUSH
6051: LD_INT 5
6053: PUSH
6054: LD_INT 6
6056: PUSH
6057: EMPTY
6058: LIST
6059: LIST
6060: LIST
6061: PUSH
6062: LD_OWVAR 67
6066: ARRAY
6067: PPUSH
6068: LD_VAR 0 4
6072: PPUSH
6073: LD_INT 14
6075: PPUSH
6076: CALL 5690 0 3
6080: ST_TO_ADDR
// veh := PrepareTank ( 2 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_heavy_machine_gun , ru_gatling_gun ] [ Difficulty ] , 90 ) ;
6081: LD_ADDR_VAR 0 7
6085: PUSH
6086: LD_INT 2
6088: PPUSH
6089: LD_INT 3
6091: PPUSH
6092: LD_INT 22
6094: PPUSH
6095: LD_INT 1
6097: PPUSH
6098: LD_INT 1
6100: PPUSH
6101: LD_INT 42
6103: PUSH
6104: LD_INT 42
6106: PUSH
6107: LD_INT 43
6109: PUSH
6110: EMPTY
6111: LIST
6112: LIST
6113: LIST
6114: PUSH
6115: LD_OWVAR 67
6119: ARRAY
6120: PPUSH
6121: LD_INT 90
6123: PPUSH
6124: CALL 490 0 7
6128: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
6129: LD_VAR 0 7
6133: PPUSH
6134: LD_INT 4
6136: PPUSH
6137: CALL_OW 233
// PlaceUnitArea ( veh , arArea1 , false ) ;
6141: LD_VAR 0 7
6145: PPUSH
6146: LD_INT 13
6148: PPUSH
6149: LD_INT 0
6151: PPUSH
6152: CALL_OW 49
// uc_side := 2 ;
6156: LD_ADDR_OWVAR 20
6160: PUSH
6161: LD_INT 2
6163: ST_TO_ADDR
// uc_nation := 2 ;
6164: LD_ADDR_OWVAR 21
6168: PUSH
6169: LD_INT 2
6171: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
6172: LD_INT 0
6174: PPUSH
6175: LD_INT 1
6177: PPUSH
6178: LD_VAR 0 4
6182: PPUSH
6183: CALL_OW 380
// un := CreateHuman ;
6187: LD_ADDR_VAR 0 6
6191: PUSH
6192: CALL_OW 44
6196: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
6197: LD_VAR 0 6
6201: PPUSH
6202: LD_VAR 0 7
6206: PPUSH
6207: CALL_OW 52
// force := force ^ un ;
6211: LD_ADDR_VAR 0 8
6215: PUSH
6216: LD_VAR 0 8
6220: PUSH
6221: LD_VAR 0 6
6225: ADD
6226: ST_TO_ADDR
// end else
6227: GO 6267
// begin force := PrepareArabianTroops ( [ 3 , 4 , 5 ] [ Difficulty ] , skill , arArea2 ) ;
6229: LD_ADDR_VAR 0 8
6233: PUSH
6234: LD_INT 3
6236: PUSH
6237: LD_INT 4
6239: PUSH
6240: LD_INT 5
6242: PUSH
6243: EMPTY
6244: LIST
6245: LIST
6246: LIST
6247: PUSH
6248: LD_OWVAR 67
6252: ARRAY
6253: PPUSH
6254: LD_VAR 0 4
6258: PPUSH
6259: LD_INT 14
6261: PPUSH
6262: CALL 5690 0 3
6266: ST_TO_ADDR
// end ; if force then
6267: LD_VAR 0 8
6271: IFFALSE 6283
// ar_forces := force ;
6273: LD_ADDR_EXP 27
6277: PUSH
6278: LD_VAR 0 8
6282: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
6283: LD_INT 35
6285: PPUSH
6286: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 ;
6290: LD_INT 22
6292: PUSH
6293: LD_INT 2
6295: PUSH
6296: EMPTY
6297: LIST
6298: LIST
6299: PUSH
6300: LD_INT 21
6302: PUSH
6303: LD_INT 1
6305: PUSH
6306: EMPTY
6307: LIST
6308: LIST
6309: PUSH
6310: EMPTY
6311: LIST
6312: LIST
6313: PPUSH
6314: CALL_OW 69
6318: PUSH
6319: LD_INT 0
6321: EQUAL
6322: IFFALSE 6283
// Wait ( timer ) ;
6324: LD_VAR 0 2
6328: PPUSH
6329: CALL_OW 67
// force := PrepareArabianTroops ( [ 4 , 5 , 6 ] [ Difficulty ] , skill , [ arArea1 , arArea2 ] [ rand ( 1 , 2 ) ] ) ;
6333: LD_ADDR_VAR 0 8
6337: PUSH
6338: LD_INT 4
6340: PUSH
6341: LD_INT 5
6343: PUSH
6344: LD_INT 6
6346: PUSH
6347: EMPTY
6348: LIST
6349: LIST
6350: LIST
6351: PUSH
6352: LD_OWVAR 67
6356: ARRAY
6357: PPUSH
6358: LD_VAR 0 4
6362: PPUSH
6363: LD_INT 13
6365: PUSH
6366: LD_INT 14
6368: PUSH
6369: EMPTY
6370: LIST
6371: LIST
6372: PUSH
6373: LD_INT 1
6375: PPUSH
6376: LD_INT 2
6378: PPUSH
6379: CALL_OW 12
6383: ARRAY
6384: PPUSH
6385: CALL 5690 0 3
6389: ST_TO_ADDR
// if Difficulty > 1 and Delta then
6390: LD_OWVAR 67
6394: PUSH
6395: LD_INT 1
6397: GREATER
6398: PUSH
6399: LD_EXP 6
6403: AND
6404: IFFALSE 6483
// begin uc_side := 2 ;
6406: LD_ADDR_OWVAR 20
6410: PUSH
6411: LD_INT 2
6413: ST_TO_ADDR
// uc_nation := 2 ;
6414: LD_ADDR_OWVAR 21
6418: PUSH
6419: LD_INT 2
6421: ST_TO_ADDR
// PrepareHuman ( false , 2 , skill ) ;
6422: LD_INT 0
6424: PPUSH
6425: LD_INT 2
6427: PPUSH
6428: LD_VAR 0 4
6432: PPUSH
6433: CALL_OW 380
// eng := CreateHuman ;
6437: LD_ADDR_VAR 0 5
6441: PUSH
6442: CALL_OW 44
6446: ST_TO_ADDR
// PlaceUnitArea ( eng , arArea1 , false ) ;
6447: LD_VAR 0 5
6451: PPUSH
6452: LD_INT 13
6454: PPUSH
6455: LD_INT 0
6457: PPUSH
6458: CALL_OW 49
// Wait ( 3 ) ;
6462: LD_INT 3
6464: PPUSH
6465: CALL_OW 67
// AddComEnterUnit ( eng , Delta ) ;
6469: LD_VAR 0 5
6473: PPUSH
6474: LD_EXP 6
6478: PPUSH
6479: CALL_OW 180
// end ; if force then
6483: LD_VAR 0 8
6487: IFFALSE 6499
// ar_forces := force ;
6489: LD_ADDR_EXP 27
6493: PUSH
6494: LD_VAR 0 8
6498: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
6499: LD_INT 35
6501: PPUSH
6502: CALL_OW 67
// if eng then
6506: LD_VAR 0 5
6510: IFFALSE 6564
// if GetSide ( Delta ) = 2 and IsOk ( eng ) and not IsInUnit ( eng ) then
6512: LD_EXP 6
6516: PPUSH
6517: CALL_OW 255
6521: PUSH
6522: LD_INT 2
6524: EQUAL
6525: PUSH
6526: LD_VAR 0 5
6530: PPUSH
6531: CALL_OW 302
6535: AND
6536: PUSH
6537: LD_VAR 0 5
6541: PPUSH
6542: CALL_OW 310
6546: NOT
6547: AND
6548: IFFALSE 6564
// ComEnterUnit ( eng , Delta ) ;
6550: LD_VAR 0 5
6554: PPUSH
6555: LD_EXP 6
6559: PPUSH
6560: CALL_OW 120
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 ;
6564: LD_INT 22
6566: PUSH
6567: LD_INT 2
6569: PUSH
6570: EMPTY
6571: LIST
6572: LIST
6573: PUSH
6574: LD_INT 21
6576: PUSH
6577: LD_INT 1
6579: PUSH
6580: EMPTY
6581: LIST
6582: LIST
6583: PUSH
6584: EMPTY
6585: LIST
6586: LIST
6587: PPUSH
6588: CALL_OW 69
6592: PUSH
6593: LD_INT 0
6595: EQUAL
6596: IFFALSE 6499
// Wait ( 2 2$00 ) ;
6598: LD_INT 4200
6600: PPUSH
6601: CALL_OW 67
// ap_killers := PrepareArabianTroops ( [ 1 , 2 , 2 ] [ Difficulty ] , skill , arArea1 ) ;
6605: LD_ADDR_EXP 28
6609: PUSH
6610: LD_INT 1
6612: PUSH
6613: LD_INT 2
6615: PUSH
6616: LD_INT 2
6618: PUSH
6619: EMPTY
6620: LIST
6621: LIST
6622: LIST
6623: PUSH
6624: LD_OWVAR 67
6628: ARRAY
6629: PPUSH
6630: LD_VAR 0 4
6634: PPUSH
6635: LD_INT 13
6637: PPUSH
6638: CALL 5690 0 3
6642: ST_TO_ADDR
// Wait ( timer * 2 ) ;
6643: LD_VAR 0 2
6647: PUSH
6648: LD_INT 2
6650: MUL
6651: PPUSH
6652: CALL_OW 67
// ar_forces := PrepareArabianTroops ( [ 5 , 6 , 7 ] [ Difficulty ] , skill , arArea1 ) ^ PrepareArabianTroops ( [ 3 , 4 , 4 ] [ Difficulty ] , skill , arArea2 ) ;
6656: LD_ADDR_EXP 27
6660: PUSH
6661: LD_INT 5
6663: PUSH
6664: LD_INT 6
6666: PUSH
6667: LD_INT 7
6669: PUSH
6670: EMPTY
6671: LIST
6672: LIST
6673: LIST
6674: PUSH
6675: LD_OWVAR 67
6679: ARRAY
6680: PPUSH
6681: LD_VAR 0 4
6685: PPUSH
6686: LD_INT 13
6688: PPUSH
6689: CALL 5690 0 3
6693: PUSH
6694: LD_INT 3
6696: PUSH
6697: LD_INT 4
6699: PUSH
6700: LD_INT 4
6702: PUSH
6703: EMPTY
6704: LIST
6705: LIST
6706: LIST
6707: PUSH
6708: LD_OWVAR 67
6712: ARRAY
6713: PPUSH
6714: LD_VAR 0 4
6718: PPUSH
6719: LD_INT 14
6721: PPUSH
6722: CALL 5690 0 3
6726: ADD
6727: ST_TO_ADDR
// end ;
6728: PPOPN 8
6730: END
// every 0 0$03 trigger ar_forces do var i , target ;
6731: LD_EXP 27
6735: IFFALSE 6933
6737: GO 6739
6739: DISABLE
6740: LD_INT 0
6742: PPUSH
6743: PPUSH
// begin enable ;
6744: ENABLE
// if not ar_forces then
6745: LD_EXP 27
6749: NOT
6750: IFFALSE 6754
// exit ;
6752: GO 6933
// if Delta then
6754: LD_EXP 6
6758: IFFALSE 6772
// target := Delta else
6760: LD_ADDR_VAR 0 2
6764: PUSH
6765: LD_EXP 6
6769: ST_TO_ADDR
6770: GO 6782
// target := JMM ;
6772: LD_ADDR_VAR 0 2
6776: PUSH
6777: LD_EXP 16
6781: ST_TO_ADDR
// for i in ar_forces do
6782: LD_ADDR_VAR 0 1
6786: PUSH
6787: LD_EXP 27
6791: PUSH
6792: FOR_IN
6793: IFFALSE 6931
// begin if i in FilterAllUnits ( [ f_driving ] ) then
6795: LD_VAR 0 1
6799: PUSH
6800: LD_INT 55
6802: PUSH
6803: EMPTY
6804: LIST
6805: PPUSH
6806: CALL_OW 69
6810: IN
6811: IFFALSE 6854
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , IsInUnit ( i ) ) ) else
6813: LD_VAR 0 1
6817: PPUSH
6818: LD_INT 22
6820: PUSH
6821: LD_INT 1
6823: PUSH
6824: EMPTY
6825: LIST
6826: LIST
6827: PPUSH
6828: CALL_OW 69
6832: PPUSH
6833: LD_VAR 0 1
6837: PPUSH
6838: CALL_OW 310
6842: PPUSH
6843: CALL_OW 74
6847: PPUSH
6848: CALL_OW 115
6852: GO 6929
// if GetDistUnits ( i , target ) > 30 then
6854: LD_VAR 0 1
6858: PPUSH
6859: LD_VAR 0 2
6863: PPUSH
6864: CALL_OW 296
6868: PUSH
6869: LD_INT 30
6871: GREATER
6872: IFFALSE 6905
// ComAgressiveMove ( i , GetX ( target ) , GetY ( target ) ) else
6874: LD_VAR 0 1
6878: PPUSH
6879: LD_VAR 0 2
6883: PPUSH
6884: CALL_OW 250
6888: PPUSH
6889: LD_VAR 0 2
6893: PPUSH
6894: CALL_OW 251
6898: PPUSH
6899: CALL_OW 114
6903: GO 6929
// Attack ( i , FilterAllUnits ( [ f_enemy , 2 ] ) ) ;
6905: LD_VAR 0 1
6909: PPUSH
6910: LD_INT 81
6912: PUSH
6913: LD_INT 2
6915: PUSH
6916: EMPTY
6917: LIST
6918: LIST
6919: PPUSH
6920: CALL_OW 69
6924: PPUSH
6925: CALL 795 0 2
// end ;
6929: GO 6792
6931: POP
6932: POP
// end ;
6933: PPOPN 2
6935: END
// every 0 0$01 trigger ap_killers do var filter , i , target ;
6936: LD_EXP 28
6940: IFFALSE 7100
6942: GO 6944
6944: DISABLE
6945: LD_INT 0
6947: PPUSH
6948: PPUSH
6949: PPUSH
// begin enable ;
6950: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) ;
6951: LD_ADDR_VAR 0 1
6955: PUSH
6956: LD_INT 22
6958: PUSH
6959: LD_INT 0
6961: PUSH
6962: EMPTY
6963: LIST
6964: LIST
6965: PUSH
6966: LD_INT 25
6968: PUSH
6969: LD_INT 12
6971: PUSH
6972: EMPTY
6973: LIST
6974: LIST
6975: PUSH
6976: EMPTY
6977: LIST
6978: LIST
6979: PPUSH
6980: CALL_OW 69
6984: ST_TO_ADDR
// if not filter then
6985: LD_VAR 0 1
6989: NOT
6990: IFFALSE 7017
// begin ar_forces := ar_forces ^ ap_killers ;
6992: LD_ADDR_EXP 27
6996: PUSH
6997: LD_EXP 27
7001: PUSH
7002: LD_EXP 28
7006: ADD
7007: ST_TO_ADDR
// ap_killers := [ ] ;
7008: LD_ADDR_EXP 28
7012: PUSH
7013: EMPTY
7014: ST_TO_ADDR
// exit ;
7015: GO 7100
// end ; for i in ap_killers do
7017: LD_ADDR_VAR 0 2
7021: PUSH
7022: LD_EXP 28
7026: PUSH
7027: FOR_IN
7028: IFFALSE 7098
// begin if not IsOk ( i ) then
7030: LD_VAR 0 2
7034: PPUSH
7035: CALL_OW 302
7039: NOT
7040: IFFALSE 7044
// continue ;
7042: GO 7027
// if not HasTask ( i ) then
7044: LD_VAR 0 2
7048: PPUSH
7049: CALL_OW 314
7053: NOT
7054: IFFALSE 7076
// target := NearestUnitToUnit ( filter , i ) ;
7056: LD_ADDR_VAR 0 3
7060: PUSH
7061: LD_VAR 0 1
7065: PPUSH
7066: LD_VAR 0 2
7070: PPUSH
7071: CALL_OW 74
7075: ST_TO_ADDR
// if target then
7076: LD_VAR 0 3
7080: IFFALSE 7096
// ComAttackUnit ( i , target ) ;
7082: LD_VAR 0 2
7086: PPUSH
7087: LD_VAR 0 3
7091: PPUSH
7092: CALL_OW 115
// end ;
7096: GO 7027
7098: POP
7099: POP
// end ; end_of_file
7100: PPOPN 3
7102: END
// every 0 0$40 + 0 0$2 trigger Delta do var i , counter , cr ;
7103: LD_EXP 6
7107: IFFALSE 7239
7109: GO 7111
7111: DISABLE
7112: LD_INT 0
7114: PPUSH
7115: PPUSH
7116: PPUSH
// begin counter := [ 300 , 250 , 220 ] [ Difficulty ] ;
7117: LD_ADDR_VAR 0 2
7121: PUSH
7122: LD_INT 300
7124: PUSH
7125: LD_INT 250
7127: PUSH
7128: LD_INT 220
7130: PUSH
7131: EMPTY
7132: LIST
7133: LIST
7134: LIST
7135: PUSH
7136: LD_OWVAR 67
7140: ARRAY
7141: ST_TO_ADDR
// CreateCratesArea ( Rand ( 1 , 3 ) , cratesArea , true ) ;
7142: LD_INT 1
7144: PPUSH
7145: LD_INT 3
7147: PPUSH
7148: CALL_OW 12
7152: PPUSH
7153: LD_INT 7
7155: PPUSH
7156: LD_INT 1
7158: PPUSH
7159: CALL_OW 55
// repeat wait ( rand ( 1 1$30 , 2 2$20 ) ) ;
7163: LD_INT 3150
7165: PPUSH
7166: LD_INT 4900
7168: PPUSH
7169: CALL_OW 12
7173: PPUSH
7174: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
7178: LD_ADDR_VAR 0 3
7182: PUSH
7183: LD_INT 1
7185: PPUSH
7186: LD_INT 5
7188: PPUSH
7189: CALL_OW 12
7193: ST_TO_ADDR
// CreateCratesArea ( cr , cratesArea , true ) ;
7194: LD_VAR 0 3
7198: PPUSH
7199: LD_INT 7
7201: PPUSH
7202: LD_INT 1
7204: PPUSH
7205: CALL_OW 55
// counter := counter - cr * 10 ;
7209: LD_ADDR_VAR 0 2
7213: PUSH
7214: LD_VAR 0 2
7218: PUSH
7219: LD_VAR 0 3
7223: PUSH
7224: LD_INT 10
7226: MUL
7227: MINUS
7228: ST_TO_ADDR
// until counter <= 0 ;
7229: LD_VAR 0 2
7233: PUSH
7234: LD_INT 0
7236: LESSEQUAL
7237: IFFALSE 7163
// end ;
7239: PPOPN 3
7241: END
// every 0 0$03 trigger not Delta do var i ;
7242: LD_EXP 6
7246: NOT
7247: IFFALSE 7317
7249: GO 7251
7251: DISABLE
7252: LD_INT 0
7254: PPUSH
// begin for i = 1 to 4 - Difficulty do
7255: LD_ADDR_VAR 0 1
7259: PUSH
7260: DOUBLE
7261: LD_INT 1
7263: DEC
7264: ST_TO_ADDR
7265: LD_INT 4
7267: PUSH
7268: LD_OWVAR 67
7272: MINUS
7273: PUSH
7274: FOR_TO
7275: IFFALSE 7315
// begin CreateCratesArea ( rand ( 2 , 5 ) , deltaMainArea , true ) ;
7277: LD_INT 2
7279: PPUSH
7280: LD_INT 5
7282: PPUSH
7283: CALL_OW 12
7287: PPUSH
7288: LD_INT 8
7290: PPUSH
7291: LD_INT 1
7293: PPUSH
7294: CALL_OW 55
// Wait ( rand ( 0 0$16 , 0 0$39 ) ) ;
7298: LD_INT 560
7300: PPUSH
7301: LD_INT 1365
7303: PPUSH
7304: CALL_OW 12
7308: PPUSH
7309: CALL_OW 67
// end ;
7313: GO 7274
7315: POP
7316: POP
// end ;
7317: PPOPN 1
7319: END
// every 3 3$00 trigger tick < 15 15$00 do
7320: LD_OWVAR 1
7324: PUSH
7325: LD_INT 31500
7327: LESS
7328: IFFALSE 7388
7330: GO 7332
7332: DISABLE
// begin enable ;
7333: ENABLE
// CreateCratesAnyWhere ( rand ( 1 , 3 ) , true ) ;
7334: LD_INT 1
7336: PPUSH
7337: LD_INT 3
7339: PPUSH
7340: CALL_OW 12
7344: PPUSH
7345: LD_INT 1
7347: PPUSH
7348: CALL_OW 57
// Wait ( rand ( 0 0$38 , 0 0$59 ) ) ;
7352: LD_INT 1330
7354: PPUSH
7355: LD_INT 2065
7357: PPUSH
7358: CALL_OW 12
7362: PPUSH
7363: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 4 ) , riverArea , true ) ;
7367: LD_INT 1
7369: PPUSH
7370: LD_INT 4
7372: PPUSH
7373: CALL_OW 12
7377: PPUSH
7378: LD_INT 15
7380: PPUSH
7381: LD_INT 1
7383: PPUSH
7384: CALL_OW 55
// end ; end_of_file
7388: END
// on UnitDestroyed ( un ) do begin if un = JMM then
7389: LD_VAR 0 1
7393: PUSH
7394: LD_EXP 16
7398: EQUAL
7399: IFFALSE 7408
// YouLost ( JMM ) ;
7401: LD_STRING JMM
7403: PPUSH
7404: CALL_OW 104
// if un = Delta then
7408: LD_VAR 0 1
7412: PUSH
7413: LD_EXP 6
7417: EQUAL
7418: IFFALSE 7441
// begin Delta := 0 ;
7420: LD_ADDR_EXP 6
7424: PUSH
7425: LD_INT 0
7427: ST_TO_ADDR
// SetRestrict ( b_depot , 1 , true ) ;
7428: LD_INT 0
7430: PPUSH
7431: LD_INT 1
7433: PPUSH
7434: LD_INT 1
7436: PPUSH
7437: CALL_OW 324
// end ; if un in ar_forces then
7441: LD_VAR 0 1
7445: PUSH
7446: LD_EXP 27
7450: IN
7451: IFFALSE 7469
// ar_forces := ar_forces diff un ;
7453: LD_ADDR_EXP 27
7457: PUSH
7458: LD_EXP 27
7462: PUSH
7463: LD_VAR 0 1
7467: DIFF
7468: ST_TO_ADDR
// if un in ap_killers then
7469: LD_VAR 0 1
7473: PUSH
7474: LD_EXP 28
7478: IN
7479: IFFALSE 7497
// ap_killers := ap_killers diff un ;
7481: LD_ADDR_EXP 28
7485: PUSH
7486: LD_EXP 28
7490: PUSH
7491: LD_VAR 0 1
7495: DIFF
7496: ST_TO_ADDR
// if un in FilterAllUnits ( [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ) then
7497: LD_VAR 0 1
7501: PUSH
7502: LD_INT 2
7504: PUSH
7505: LD_INT 25
7507: PUSH
7508: LD_INT 12
7510: PUSH
7511: EMPTY
7512: LIST
7513: LIST
7514: PUSH
7515: LD_INT 25
7517: PUSH
7518: LD_INT 16
7520: PUSH
7521: EMPTY
7522: LIST
7523: LIST
7524: PUSH
7525: EMPTY
7526: LIST
7527: LIST
7528: LIST
7529: PPUSH
7530: CALL_OW 69
7534: IN
7535: IFFALSE 7551
// apeKillCounter := apeKillCounter + 1 ;
7537: LD_ADDR_EXP 15
7541: PUSH
7542: LD_EXP 15
7546: PUSH
7547: LD_INT 1
7549: PLUS
7550: ST_TO_ADDR
// end ;
7551: PPOPN 1
7553: END
// on Contact ( s1 , s2 ) do if s1 = 1 and s2 = 2 and not arab_spotted then
7554: LD_VAR 0 1
7558: PUSH
7559: LD_INT 1
7561: EQUAL
7562: PUSH
7563: LD_VAR 0 2
7567: PUSH
7568: LD_INT 2
7570: EQUAL
7571: AND
7572: PUSH
7573: LD_EXP 13
7577: NOT
7578: AND
7579: IFFALSE 7589
// arab_spotted := true ;
7581: LD_ADDR_EXP 13
7585: PUSH
7586: LD_INT 1
7588: ST_TO_ADDR
7589: PPOPN 2
7591: END
// on EndTheMissionRaised ( p ) do begin end_the_mission_allowed := false ;
7592: LD_ADDR_OWVAR 57
7596: PUSH
7597: LD_INT 0
7599: ST_TO_ADDR
// end_mission := true ;
7600: LD_ADDR_EXP 14
7604: PUSH
7605: LD_INT 1
7607: ST_TO_ADDR
// end ;
7608: PPOPN 1
7610: END
// on ApemanTamed ( apeman , sci ) do begin if GetSide ( sci ) = 1 then
7611: LD_VAR 0 2
7615: PPUSH
7616: CALL_OW 255
7620: PUSH
7621: LD_INT 1
7623: EQUAL
7624: IFFALSE 7640
// apeman_counter := apeman_counter + 1 ;
7626: LD_ADDR_EXP 12
7630: PUSH
7631: LD_EXP 12
7635: PUSH
7636: LD_INT 1
7638: PLUS
7639: ST_TO_ADDR
// if not first_apeman_tamed then
7640: LD_EXP 8
7644: NOT
7645: IFFALSE 7845
// begin first_apeman_tamed := true ;
7647: LD_ADDR_EXP 8
7651: PUSH
7652: LD_INT 1
7654: ST_TO_ADDR
// if sci = Gladstone then
7655: LD_VAR 0 2
7659: PUSH
7660: LD_EXP 17
7664: EQUAL
7665: IFFALSE 7679
// Say ( Gladstone , D7b-Glad-1 ) ;
7667: LD_EXP 17
7671: PPUSH
7672: LD_STRING D7b-Glad-1
7674: PPUSH
7675: CALL_OW 88
// if sci = Denis then
7679: LD_VAR 0 2
7683: PUSH
7684: LD_EXP 19
7688: EQUAL
7689: IFFALSE 7703
// Say ( Denis , D7a-Den-1 ) ;
7691: LD_EXP 19
7695: PPUSH
7696: LD_STRING D7a-Den-1
7698: PPUSH
7699: CALL_OW 88
// if not sci in [ JMM , Gladstone , Denis , Lisa , Frank , Bobby , Cyrus , Donaldson ] then
7703: LD_VAR 0 2
7707: PUSH
7708: LD_EXP 16
7712: PUSH
7713: LD_EXP 17
7717: PUSH
7718: LD_EXP 19
7722: PUSH
7723: LD_EXP 22
7727: PUSH
7728: LD_EXP 23
7732: PUSH
7733: LD_EXP 24
7737: PUSH
7738: LD_EXP 25
7742: PUSH
7743: LD_EXP 21
7747: PUSH
7748: EMPTY
7749: LIST
7750: LIST
7751: LIST
7752: LIST
7753: LIST
7754: LIST
7755: LIST
7756: LIST
7757: IN
7758: NOT
7759: IFFALSE 7802
// begin if GetSex ( sci ) = sex_male then
7761: LD_VAR 0 2
7765: PPUSH
7766: CALL_OW 258
7770: PUSH
7771: LD_INT 1
7773: EQUAL
7774: IFFALSE 7790
// Say ( sci , D7c-Sci1-1 ) else
7776: LD_VAR 0 2
7780: PPUSH
7781: LD_STRING D7c-Sci1-1
7783: PPUSH
7784: CALL_OW 88
7788: GO 7802
// Say ( sci , D7c-FSci1-1 ) ;
7790: LD_VAR 0 2
7794: PPUSH
7795: LD_STRING D7c-FSci1-1
7797: PPUSH
7798: CALL_OW 88
// end ; if not sci = Gladstone then
7802: LD_VAR 0 2
7806: PUSH
7807: LD_EXP 17
7811: EQUAL
7812: NOT
7813: IFFALSE 7827
// Say ( Gladstone , D7c-Glad-1 ) ;
7815: LD_EXP 17
7819: PPUSH
7820: LD_STRING D7c-Glad-1
7822: PPUSH
7823: CALL_OW 88
// if Lisa then
7827: LD_EXP 22
7831: IFFALSE 7845
// Say ( Lisa , D8-Lisa-1 ) ;
7833: LD_EXP 22
7837: PPUSH
7838: LD_STRING D8-Lisa-1
7840: PPUSH
7841: CALL_OW 88
// end ; end ; end_of_file
7845: PPOPN 2
7847: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
7848: GO 7850
7850: DISABLE
// begin ru_radar := 98 ;
7851: LD_ADDR_EXP 29
7855: PUSH
7856: LD_INT 98
7858: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
7859: LD_ADDR_EXP 30
7863: PUSH
7864: LD_INT 89
7866: ST_TO_ADDR
// us_hack := 99 ;
7867: LD_ADDR_EXP 31
7871: PUSH
7872: LD_INT 99
7874: ST_TO_ADDR
// us_artillery := 97 ;
7875: LD_ADDR_EXP 32
7879: PUSH
7880: LD_INT 97
7882: ST_TO_ADDR
// ar_bio_bomb := 91 ;
7883: LD_ADDR_EXP 33
7887: PUSH
7888: LD_INT 91
7890: ST_TO_ADDR
// end ; end_of_file end_of_file
7891: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
7892: GO 7894
7894: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
7895: LD_STRING initStreamRollete();
7897: PPUSH
7898: CALL_OW 559
// InitStreamMode ;
7902: CALL 7911 0 0
// DefineStreamItems ( ) ;
7906: CALL 8351 0 0
// end ;
7910: END
// function InitStreamMode ; begin
7911: LD_INT 0
7913: PPUSH
// streamModeActive := false ;
7914: LD_ADDR_EXP 34
7918: PUSH
7919: LD_INT 0
7921: ST_TO_ADDR
// normalCounter := 26 ;
7922: LD_ADDR_EXP 35
7926: PUSH
7927: LD_INT 26
7929: ST_TO_ADDR
// hardcoreCounter := 12 ;
7930: LD_ADDR_EXP 36
7934: PUSH
7935: LD_INT 12
7937: ST_TO_ADDR
// sRocket := false ;
7938: LD_ADDR_EXP 39
7942: PUSH
7943: LD_INT 0
7945: ST_TO_ADDR
// sSpeed := false ;
7946: LD_ADDR_EXP 38
7950: PUSH
7951: LD_INT 0
7953: ST_TO_ADDR
// sEngine := false ;
7954: LD_ADDR_EXP 40
7958: PUSH
7959: LD_INT 0
7961: ST_TO_ADDR
// sSpec := false ;
7962: LD_ADDR_EXP 37
7966: PUSH
7967: LD_INT 0
7969: ST_TO_ADDR
// sLevel := false ;
7970: LD_ADDR_EXP 41
7974: PUSH
7975: LD_INT 0
7977: ST_TO_ADDR
// sArmoury := false ;
7978: LD_ADDR_EXP 42
7982: PUSH
7983: LD_INT 0
7985: ST_TO_ADDR
// sRadar := false ;
7986: LD_ADDR_EXP 43
7990: PUSH
7991: LD_INT 0
7993: ST_TO_ADDR
// sBunker := false ;
7994: LD_ADDR_EXP 44
7998: PUSH
7999: LD_INT 0
8001: ST_TO_ADDR
// sHack := false ;
8002: LD_ADDR_EXP 45
8006: PUSH
8007: LD_INT 0
8009: ST_TO_ADDR
// sFire := false ;
8010: LD_ADDR_EXP 46
8014: PUSH
8015: LD_INT 0
8017: ST_TO_ADDR
// sRefresh := false ;
8018: LD_ADDR_EXP 47
8022: PUSH
8023: LD_INT 0
8025: ST_TO_ADDR
// sExp := false ;
8026: LD_ADDR_EXP 48
8030: PUSH
8031: LD_INT 0
8033: ST_TO_ADDR
// sDepot := false ;
8034: LD_ADDR_EXP 49
8038: PUSH
8039: LD_INT 0
8041: ST_TO_ADDR
// sFlag := false ;
8042: LD_ADDR_EXP 50
8046: PUSH
8047: LD_INT 0
8049: ST_TO_ADDR
// sKamikadze := false ;
8050: LD_ADDR_EXP 58
8054: PUSH
8055: LD_INT 0
8057: ST_TO_ADDR
// sTroll := false ;
8058: LD_ADDR_EXP 59
8062: PUSH
8063: LD_INT 0
8065: ST_TO_ADDR
// sSlow := false ;
8066: LD_ADDR_EXP 60
8070: PUSH
8071: LD_INT 0
8073: ST_TO_ADDR
// sLack := false ;
8074: LD_ADDR_EXP 61
8078: PUSH
8079: LD_INT 0
8081: ST_TO_ADDR
// sTank := false ;
8082: LD_ADDR_EXP 63
8086: PUSH
8087: LD_INT 0
8089: ST_TO_ADDR
// sRemote := false ;
8090: LD_ADDR_EXP 64
8094: PUSH
8095: LD_INT 0
8097: ST_TO_ADDR
// sPowell := false ;
8098: LD_ADDR_EXP 65
8102: PUSH
8103: LD_INT 0
8105: ST_TO_ADDR
// sTeleport := false ;
8106: LD_ADDR_EXP 68
8110: PUSH
8111: LD_INT 0
8113: ST_TO_ADDR
// sOilTower := false ;
8114: LD_ADDR_EXP 70
8118: PUSH
8119: LD_INT 0
8121: ST_TO_ADDR
// sShovel := false ;
8122: LD_ADDR_EXP 71
8126: PUSH
8127: LD_INT 0
8129: ST_TO_ADDR
// sSheik := false ;
8130: LD_ADDR_EXP 72
8134: PUSH
8135: LD_INT 0
8137: ST_TO_ADDR
// sEarthquake := false ;
8138: LD_ADDR_EXP 74
8142: PUSH
8143: LD_INT 0
8145: ST_TO_ADDR
// sAI := false ;
8146: LD_ADDR_EXP 75
8150: PUSH
8151: LD_INT 0
8153: ST_TO_ADDR
// sCargo := false ;
8154: LD_ADDR_EXP 78
8158: PUSH
8159: LD_INT 0
8161: ST_TO_ADDR
// sDLaser := false ;
8162: LD_ADDR_EXP 79
8166: PUSH
8167: LD_INT 0
8169: ST_TO_ADDR
// sExchange := false ;
8170: LD_ADDR_EXP 80
8174: PUSH
8175: LD_INT 0
8177: ST_TO_ADDR
// sFac := false ;
8178: LD_ADDR_EXP 81
8182: PUSH
8183: LD_INT 0
8185: ST_TO_ADDR
// sPower := false ;
8186: LD_ADDR_EXP 82
8190: PUSH
8191: LD_INT 0
8193: ST_TO_ADDR
// sRandom := false ;
8194: LD_ADDR_EXP 83
8198: PUSH
8199: LD_INT 0
8201: ST_TO_ADDR
// sShield := false ;
8202: LD_ADDR_EXP 84
8206: PUSH
8207: LD_INT 0
8209: ST_TO_ADDR
// sTime := false ;
8210: LD_ADDR_EXP 85
8214: PUSH
8215: LD_INT 0
8217: ST_TO_ADDR
// sTools := false ;
8218: LD_ADDR_EXP 86
8222: PUSH
8223: LD_INT 0
8225: ST_TO_ADDR
// sSold := false ;
8226: LD_ADDR_EXP 51
8230: PUSH
8231: LD_INT 0
8233: ST_TO_ADDR
// sDiff := false ;
8234: LD_ADDR_EXP 52
8238: PUSH
8239: LD_INT 0
8241: ST_TO_ADDR
// sFog := false ;
8242: LD_ADDR_EXP 55
8246: PUSH
8247: LD_INT 0
8249: ST_TO_ADDR
// sReset := false ;
8250: LD_ADDR_EXP 56
8254: PUSH
8255: LD_INT 0
8257: ST_TO_ADDR
// sSun := false ;
8258: LD_ADDR_EXP 57
8262: PUSH
8263: LD_INT 0
8265: ST_TO_ADDR
// sTiger := false ;
8266: LD_ADDR_EXP 53
8270: PUSH
8271: LD_INT 0
8273: ST_TO_ADDR
// sBomb := false ;
8274: LD_ADDR_EXP 54
8278: PUSH
8279: LD_INT 0
8281: ST_TO_ADDR
// sWound := false ;
8282: LD_ADDR_EXP 62
8286: PUSH
8287: LD_INT 0
8289: ST_TO_ADDR
// sBetray := false ;
8290: LD_ADDR_EXP 66
8294: PUSH
8295: LD_INT 0
8297: ST_TO_ADDR
// sContamin := false ;
8298: LD_ADDR_EXP 67
8302: PUSH
8303: LD_INT 0
8305: ST_TO_ADDR
// sOil := false ;
8306: LD_ADDR_EXP 69
8310: PUSH
8311: LD_INT 0
8313: ST_TO_ADDR
// sStu := false ;
8314: LD_ADDR_EXP 73
8318: PUSH
8319: LD_INT 0
8321: ST_TO_ADDR
// sBazooka := false ;
8322: LD_ADDR_EXP 76
8326: PUSH
8327: LD_INT 0
8329: ST_TO_ADDR
// sMortar := false ;
8330: LD_ADDR_EXP 77
8334: PUSH
8335: LD_INT 0
8337: ST_TO_ADDR
// sRanger := false ;
8338: LD_ADDR_EXP 87
8342: PUSH
8343: LD_INT 0
8345: ST_TO_ADDR
// end ;
8346: LD_VAR 0 1
8350: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
8351: LD_INT 0
8353: PPUSH
8354: PPUSH
8355: PPUSH
8356: PPUSH
8357: PPUSH
// result := [ ] ;
8358: LD_ADDR_VAR 0 1
8362: PUSH
8363: EMPTY
8364: ST_TO_ADDR
// if campaign_id = 1 then
8365: LD_OWVAR 69
8369: PUSH
8370: LD_INT 1
8372: EQUAL
8373: IFFALSE 11309
// begin case mission_number of 1 :
8375: LD_OWVAR 70
8379: PUSH
8380: LD_INT 1
8382: DOUBLE
8383: EQUAL
8384: IFTRUE 8388
8386: GO 8452
8388: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
8389: LD_ADDR_VAR 0 1
8393: PUSH
8394: LD_INT 2
8396: PUSH
8397: LD_INT 4
8399: PUSH
8400: LD_INT 11
8402: PUSH
8403: LD_INT 12
8405: PUSH
8406: LD_INT 15
8408: PUSH
8409: LD_INT 16
8411: PUSH
8412: LD_INT 22
8414: PUSH
8415: LD_INT 23
8417: PUSH
8418: LD_INT 26
8420: PUSH
8421: EMPTY
8422: LIST
8423: LIST
8424: LIST
8425: LIST
8426: LIST
8427: LIST
8428: LIST
8429: LIST
8430: LIST
8431: PUSH
8432: LD_INT 101
8434: PUSH
8435: LD_INT 102
8437: PUSH
8438: LD_INT 106
8440: PUSH
8441: EMPTY
8442: LIST
8443: LIST
8444: LIST
8445: PUSH
8446: EMPTY
8447: LIST
8448: LIST
8449: ST_TO_ADDR
8450: GO 11309
8452: LD_INT 2
8454: DOUBLE
8455: EQUAL
8456: IFTRUE 8460
8458: GO 8532
8460: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
8461: LD_ADDR_VAR 0 1
8465: PUSH
8466: LD_INT 2
8468: PUSH
8469: LD_INT 4
8471: PUSH
8472: LD_INT 11
8474: PUSH
8475: LD_INT 12
8477: PUSH
8478: LD_INT 15
8480: PUSH
8481: LD_INT 16
8483: PUSH
8484: LD_INT 22
8486: PUSH
8487: LD_INT 23
8489: PUSH
8490: LD_INT 26
8492: PUSH
8493: EMPTY
8494: LIST
8495: LIST
8496: LIST
8497: LIST
8498: LIST
8499: LIST
8500: LIST
8501: LIST
8502: LIST
8503: PUSH
8504: LD_INT 101
8506: PUSH
8507: LD_INT 102
8509: PUSH
8510: LD_INT 105
8512: PUSH
8513: LD_INT 106
8515: PUSH
8516: LD_INT 108
8518: PUSH
8519: EMPTY
8520: LIST
8521: LIST
8522: LIST
8523: LIST
8524: LIST
8525: PUSH
8526: EMPTY
8527: LIST
8528: LIST
8529: ST_TO_ADDR
8530: GO 11309
8532: LD_INT 3
8534: DOUBLE
8535: EQUAL
8536: IFTRUE 8540
8538: GO 8616
8540: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
8541: LD_ADDR_VAR 0 1
8545: PUSH
8546: LD_INT 2
8548: PUSH
8549: LD_INT 4
8551: PUSH
8552: LD_INT 5
8554: PUSH
8555: LD_INT 11
8557: PUSH
8558: LD_INT 12
8560: PUSH
8561: LD_INT 15
8563: PUSH
8564: LD_INT 16
8566: PUSH
8567: LD_INT 22
8569: PUSH
8570: LD_INT 26
8572: PUSH
8573: LD_INT 36
8575: PUSH
8576: EMPTY
8577: LIST
8578: LIST
8579: LIST
8580: LIST
8581: LIST
8582: LIST
8583: LIST
8584: LIST
8585: LIST
8586: LIST
8587: PUSH
8588: LD_INT 101
8590: PUSH
8591: LD_INT 102
8593: PUSH
8594: LD_INT 105
8596: PUSH
8597: LD_INT 106
8599: PUSH
8600: LD_INT 108
8602: PUSH
8603: EMPTY
8604: LIST
8605: LIST
8606: LIST
8607: LIST
8608: LIST
8609: PUSH
8610: EMPTY
8611: LIST
8612: LIST
8613: ST_TO_ADDR
8614: GO 11309
8616: LD_INT 4
8618: DOUBLE
8619: EQUAL
8620: IFTRUE 8624
8622: GO 8708
8624: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
8625: LD_ADDR_VAR 0 1
8629: PUSH
8630: LD_INT 2
8632: PUSH
8633: LD_INT 4
8635: PUSH
8636: LD_INT 5
8638: PUSH
8639: LD_INT 8
8641: PUSH
8642: LD_INT 11
8644: PUSH
8645: LD_INT 12
8647: PUSH
8648: LD_INT 15
8650: PUSH
8651: LD_INT 16
8653: PUSH
8654: LD_INT 22
8656: PUSH
8657: LD_INT 23
8659: PUSH
8660: LD_INT 26
8662: PUSH
8663: LD_INT 36
8665: PUSH
8666: EMPTY
8667: LIST
8668: LIST
8669: LIST
8670: LIST
8671: LIST
8672: LIST
8673: LIST
8674: LIST
8675: LIST
8676: LIST
8677: LIST
8678: LIST
8679: PUSH
8680: LD_INT 101
8682: PUSH
8683: LD_INT 102
8685: PUSH
8686: LD_INT 105
8688: PUSH
8689: LD_INT 106
8691: PUSH
8692: LD_INT 108
8694: PUSH
8695: EMPTY
8696: LIST
8697: LIST
8698: LIST
8699: LIST
8700: LIST
8701: PUSH
8702: EMPTY
8703: LIST
8704: LIST
8705: ST_TO_ADDR
8706: GO 11309
8708: LD_INT 5
8710: DOUBLE
8711: EQUAL
8712: IFTRUE 8716
8714: GO 8816
8716: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
8717: LD_ADDR_VAR 0 1
8721: PUSH
8722: LD_INT 2
8724: PUSH
8725: LD_INT 4
8727: PUSH
8728: LD_INT 5
8730: PUSH
8731: LD_INT 6
8733: PUSH
8734: LD_INT 8
8736: PUSH
8737: LD_INT 11
8739: PUSH
8740: LD_INT 12
8742: PUSH
8743: LD_INT 15
8745: PUSH
8746: LD_INT 16
8748: PUSH
8749: LD_INT 22
8751: PUSH
8752: LD_INT 23
8754: PUSH
8755: LD_INT 25
8757: PUSH
8758: LD_INT 26
8760: PUSH
8761: LD_INT 36
8763: PUSH
8764: EMPTY
8765: LIST
8766: LIST
8767: LIST
8768: LIST
8769: LIST
8770: LIST
8771: LIST
8772: LIST
8773: LIST
8774: LIST
8775: LIST
8776: LIST
8777: LIST
8778: LIST
8779: PUSH
8780: LD_INT 101
8782: PUSH
8783: LD_INT 102
8785: PUSH
8786: LD_INT 105
8788: PUSH
8789: LD_INT 106
8791: PUSH
8792: LD_INT 108
8794: PUSH
8795: LD_INT 109
8797: PUSH
8798: LD_INT 112
8800: PUSH
8801: EMPTY
8802: LIST
8803: LIST
8804: LIST
8805: LIST
8806: LIST
8807: LIST
8808: LIST
8809: PUSH
8810: EMPTY
8811: LIST
8812: LIST
8813: ST_TO_ADDR
8814: GO 11309
8816: LD_INT 6
8818: DOUBLE
8819: EQUAL
8820: IFTRUE 8824
8822: GO 8944
8824: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
8825: LD_ADDR_VAR 0 1
8829: PUSH
8830: LD_INT 2
8832: PUSH
8833: LD_INT 4
8835: PUSH
8836: LD_INT 5
8838: PUSH
8839: LD_INT 6
8841: PUSH
8842: LD_INT 8
8844: PUSH
8845: LD_INT 11
8847: PUSH
8848: LD_INT 12
8850: PUSH
8851: LD_INT 15
8853: PUSH
8854: LD_INT 16
8856: PUSH
8857: LD_INT 20
8859: PUSH
8860: LD_INT 21
8862: PUSH
8863: LD_INT 22
8865: PUSH
8866: LD_INT 23
8868: PUSH
8869: LD_INT 25
8871: PUSH
8872: LD_INT 26
8874: PUSH
8875: LD_INT 30
8877: PUSH
8878: LD_INT 31
8880: PUSH
8881: LD_INT 32
8883: PUSH
8884: LD_INT 36
8886: PUSH
8887: EMPTY
8888: LIST
8889: LIST
8890: LIST
8891: LIST
8892: LIST
8893: LIST
8894: LIST
8895: LIST
8896: LIST
8897: LIST
8898: LIST
8899: LIST
8900: LIST
8901: LIST
8902: LIST
8903: LIST
8904: LIST
8905: LIST
8906: LIST
8907: PUSH
8908: LD_INT 101
8910: PUSH
8911: LD_INT 102
8913: PUSH
8914: LD_INT 105
8916: PUSH
8917: LD_INT 106
8919: PUSH
8920: LD_INT 108
8922: PUSH
8923: LD_INT 109
8925: PUSH
8926: LD_INT 112
8928: PUSH
8929: EMPTY
8930: LIST
8931: LIST
8932: LIST
8933: LIST
8934: LIST
8935: LIST
8936: LIST
8937: PUSH
8938: EMPTY
8939: LIST
8940: LIST
8941: ST_TO_ADDR
8942: GO 11309
8944: LD_INT 7
8946: DOUBLE
8947: EQUAL
8948: IFTRUE 8952
8950: GO 9052
8952: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
8953: LD_ADDR_VAR 0 1
8957: PUSH
8958: LD_INT 2
8960: PUSH
8961: LD_INT 4
8963: PUSH
8964: LD_INT 5
8966: PUSH
8967: LD_INT 7
8969: PUSH
8970: LD_INT 11
8972: PUSH
8973: LD_INT 12
8975: PUSH
8976: LD_INT 15
8978: PUSH
8979: LD_INT 16
8981: PUSH
8982: LD_INT 20
8984: PUSH
8985: LD_INT 21
8987: PUSH
8988: LD_INT 22
8990: PUSH
8991: LD_INT 23
8993: PUSH
8994: LD_INT 25
8996: PUSH
8997: LD_INT 26
8999: PUSH
9000: EMPTY
9001: LIST
9002: LIST
9003: LIST
9004: LIST
9005: LIST
9006: LIST
9007: LIST
9008: LIST
9009: LIST
9010: LIST
9011: LIST
9012: LIST
9013: LIST
9014: LIST
9015: PUSH
9016: LD_INT 101
9018: PUSH
9019: LD_INT 102
9021: PUSH
9022: LD_INT 103
9024: PUSH
9025: LD_INT 105
9027: PUSH
9028: LD_INT 106
9030: PUSH
9031: LD_INT 108
9033: PUSH
9034: LD_INT 112
9036: PUSH
9037: EMPTY
9038: LIST
9039: LIST
9040: LIST
9041: LIST
9042: LIST
9043: LIST
9044: LIST
9045: PUSH
9046: EMPTY
9047: LIST
9048: LIST
9049: ST_TO_ADDR
9050: GO 11309
9052: LD_INT 8
9054: DOUBLE
9055: EQUAL
9056: IFTRUE 9060
9058: GO 9188
9060: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
9061: LD_ADDR_VAR 0 1
9065: PUSH
9066: LD_INT 2
9068: PUSH
9069: LD_INT 4
9071: PUSH
9072: LD_INT 5
9074: PUSH
9075: LD_INT 6
9077: PUSH
9078: LD_INT 7
9080: PUSH
9081: LD_INT 8
9083: PUSH
9084: LD_INT 11
9086: PUSH
9087: LD_INT 12
9089: PUSH
9090: LD_INT 15
9092: PUSH
9093: LD_INT 16
9095: PUSH
9096: LD_INT 20
9098: PUSH
9099: LD_INT 21
9101: PUSH
9102: LD_INT 22
9104: PUSH
9105: LD_INT 23
9107: PUSH
9108: LD_INT 25
9110: PUSH
9111: LD_INT 26
9113: PUSH
9114: LD_INT 30
9116: PUSH
9117: LD_INT 31
9119: PUSH
9120: LD_INT 32
9122: PUSH
9123: LD_INT 36
9125: PUSH
9126: EMPTY
9127: LIST
9128: LIST
9129: LIST
9130: LIST
9131: LIST
9132: LIST
9133: LIST
9134: LIST
9135: LIST
9136: LIST
9137: LIST
9138: LIST
9139: LIST
9140: LIST
9141: LIST
9142: LIST
9143: LIST
9144: LIST
9145: LIST
9146: LIST
9147: PUSH
9148: LD_INT 101
9150: PUSH
9151: LD_INT 102
9153: PUSH
9154: LD_INT 103
9156: PUSH
9157: LD_INT 105
9159: PUSH
9160: LD_INT 106
9162: PUSH
9163: LD_INT 108
9165: PUSH
9166: LD_INT 109
9168: PUSH
9169: LD_INT 112
9171: PUSH
9172: EMPTY
9173: LIST
9174: LIST
9175: LIST
9176: LIST
9177: LIST
9178: LIST
9179: LIST
9180: LIST
9181: PUSH
9182: EMPTY
9183: LIST
9184: LIST
9185: ST_TO_ADDR
9186: GO 11309
9188: LD_INT 9
9190: DOUBLE
9191: EQUAL
9192: IFTRUE 9196
9194: GO 9332
9196: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
9197: LD_ADDR_VAR 0 1
9201: PUSH
9202: LD_INT 2
9204: PUSH
9205: LD_INT 4
9207: PUSH
9208: LD_INT 5
9210: PUSH
9211: LD_INT 6
9213: PUSH
9214: LD_INT 7
9216: PUSH
9217: LD_INT 8
9219: PUSH
9220: LD_INT 11
9222: PUSH
9223: LD_INT 12
9225: PUSH
9226: LD_INT 15
9228: PUSH
9229: LD_INT 16
9231: PUSH
9232: LD_INT 20
9234: PUSH
9235: LD_INT 21
9237: PUSH
9238: LD_INT 22
9240: PUSH
9241: LD_INT 23
9243: PUSH
9244: LD_INT 25
9246: PUSH
9247: LD_INT 26
9249: PUSH
9250: LD_INT 28
9252: PUSH
9253: LD_INT 30
9255: PUSH
9256: LD_INT 31
9258: PUSH
9259: LD_INT 32
9261: PUSH
9262: LD_INT 36
9264: PUSH
9265: EMPTY
9266: LIST
9267: LIST
9268: LIST
9269: LIST
9270: LIST
9271: LIST
9272: LIST
9273: LIST
9274: LIST
9275: LIST
9276: LIST
9277: LIST
9278: LIST
9279: LIST
9280: LIST
9281: LIST
9282: LIST
9283: LIST
9284: LIST
9285: LIST
9286: LIST
9287: PUSH
9288: LD_INT 101
9290: PUSH
9291: LD_INT 102
9293: PUSH
9294: LD_INT 103
9296: PUSH
9297: LD_INT 105
9299: PUSH
9300: LD_INT 106
9302: PUSH
9303: LD_INT 108
9305: PUSH
9306: LD_INT 109
9308: PUSH
9309: LD_INT 112
9311: PUSH
9312: LD_INT 114
9314: PUSH
9315: EMPTY
9316: LIST
9317: LIST
9318: LIST
9319: LIST
9320: LIST
9321: LIST
9322: LIST
9323: LIST
9324: LIST
9325: PUSH
9326: EMPTY
9327: LIST
9328: LIST
9329: ST_TO_ADDR
9330: GO 11309
9332: LD_INT 10
9334: DOUBLE
9335: EQUAL
9336: IFTRUE 9340
9338: GO 9524
9340: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
9341: LD_ADDR_VAR 0 1
9345: PUSH
9346: LD_INT 2
9348: PUSH
9349: LD_INT 4
9351: PUSH
9352: LD_INT 5
9354: PUSH
9355: LD_INT 6
9357: PUSH
9358: LD_INT 7
9360: PUSH
9361: LD_INT 8
9363: PUSH
9364: LD_INT 9
9366: PUSH
9367: LD_INT 10
9369: PUSH
9370: LD_INT 11
9372: PUSH
9373: LD_INT 12
9375: PUSH
9376: LD_INT 13
9378: PUSH
9379: LD_INT 14
9381: PUSH
9382: LD_INT 15
9384: PUSH
9385: LD_INT 16
9387: PUSH
9388: LD_INT 17
9390: PUSH
9391: LD_INT 18
9393: PUSH
9394: LD_INT 19
9396: PUSH
9397: LD_INT 20
9399: PUSH
9400: LD_INT 21
9402: PUSH
9403: LD_INT 22
9405: PUSH
9406: LD_INT 23
9408: PUSH
9409: LD_INT 24
9411: PUSH
9412: LD_INT 25
9414: PUSH
9415: LD_INT 26
9417: PUSH
9418: LD_INT 28
9420: PUSH
9421: LD_INT 30
9423: PUSH
9424: LD_INT 31
9426: PUSH
9427: LD_INT 32
9429: PUSH
9430: LD_INT 36
9432: PUSH
9433: EMPTY
9434: LIST
9435: LIST
9436: LIST
9437: LIST
9438: LIST
9439: LIST
9440: LIST
9441: LIST
9442: LIST
9443: LIST
9444: LIST
9445: LIST
9446: LIST
9447: LIST
9448: LIST
9449: LIST
9450: LIST
9451: LIST
9452: LIST
9453: LIST
9454: LIST
9455: LIST
9456: LIST
9457: LIST
9458: LIST
9459: LIST
9460: LIST
9461: LIST
9462: LIST
9463: PUSH
9464: LD_INT 101
9466: PUSH
9467: LD_INT 102
9469: PUSH
9470: LD_INT 103
9472: PUSH
9473: LD_INT 104
9475: PUSH
9476: LD_INT 105
9478: PUSH
9479: LD_INT 106
9481: PUSH
9482: LD_INT 107
9484: PUSH
9485: LD_INT 108
9487: PUSH
9488: LD_INT 109
9490: PUSH
9491: LD_INT 110
9493: PUSH
9494: LD_INT 111
9496: PUSH
9497: LD_INT 112
9499: PUSH
9500: LD_INT 114
9502: PUSH
9503: EMPTY
9504: LIST
9505: LIST
9506: LIST
9507: LIST
9508: LIST
9509: LIST
9510: LIST
9511: LIST
9512: LIST
9513: LIST
9514: LIST
9515: LIST
9516: LIST
9517: PUSH
9518: EMPTY
9519: LIST
9520: LIST
9521: ST_TO_ADDR
9522: GO 11309
9524: LD_INT 11
9526: DOUBLE
9527: EQUAL
9528: IFTRUE 9532
9530: GO 9724
9532: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
9533: LD_ADDR_VAR 0 1
9537: PUSH
9538: LD_INT 2
9540: PUSH
9541: LD_INT 3
9543: PUSH
9544: LD_INT 4
9546: PUSH
9547: LD_INT 5
9549: PUSH
9550: LD_INT 6
9552: PUSH
9553: LD_INT 7
9555: PUSH
9556: LD_INT 8
9558: PUSH
9559: LD_INT 9
9561: PUSH
9562: LD_INT 10
9564: PUSH
9565: LD_INT 11
9567: PUSH
9568: LD_INT 12
9570: PUSH
9571: LD_INT 13
9573: PUSH
9574: LD_INT 14
9576: PUSH
9577: LD_INT 15
9579: PUSH
9580: LD_INT 16
9582: PUSH
9583: LD_INT 17
9585: PUSH
9586: LD_INT 18
9588: PUSH
9589: LD_INT 19
9591: PUSH
9592: LD_INT 20
9594: PUSH
9595: LD_INT 21
9597: PUSH
9598: LD_INT 22
9600: PUSH
9601: LD_INT 23
9603: PUSH
9604: LD_INT 24
9606: PUSH
9607: LD_INT 25
9609: PUSH
9610: LD_INT 26
9612: PUSH
9613: LD_INT 28
9615: PUSH
9616: LD_INT 30
9618: PUSH
9619: LD_INT 31
9621: PUSH
9622: LD_INT 32
9624: PUSH
9625: LD_INT 34
9627: PUSH
9628: LD_INT 36
9630: PUSH
9631: EMPTY
9632: LIST
9633: LIST
9634: LIST
9635: LIST
9636: LIST
9637: LIST
9638: LIST
9639: LIST
9640: LIST
9641: LIST
9642: LIST
9643: LIST
9644: LIST
9645: LIST
9646: LIST
9647: LIST
9648: LIST
9649: LIST
9650: LIST
9651: LIST
9652: LIST
9653: LIST
9654: LIST
9655: LIST
9656: LIST
9657: LIST
9658: LIST
9659: LIST
9660: LIST
9661: LIST
9662: LIST
9663: PUSH
9664: LD_INT 101
9666: PUSH
9667: LD_INT 102
9669: PUSH
9670: LD_INT 103
9672: PUSH
9673: LD_INT 104
9675: PUSH
9676: LD_INT 105
9678: PUSH
9679: LD_INT 106
9681: PUSH
9682: LD_INT 107
9684: PUSH
9685: LD_INT 108
9687: PUSH
9688: LD_INT 109
9690: PUSH
9691: LD_INT 110
9693: PUSH
9694: LD_INT 111
9696: PUSH
9697: LD_INT 112
9699: PUSH
9700: LD_INT 114
9702: PUSH
9703: EMPTY
9704: LIST
9705: LIST
9706: LIST
9707: LIST
9708: LIST
9709: LIST
9710: LIST
9711: LIST
9712: LIST
9713: LIST
9714: LIST
9715: LIST
9716: LIST
9717: PUSH
9718: EMPTY
9719: LIST
9720: LIST
9721: ST_TO_ADDR
9722: GO 11309
9724: LD_INT 12
9726: DOUBLE
9727: EQUAL
9728: IFTRUE 9732
9730: GO 9940
9732: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
9733: LD_ADDR_VAR 0 1
9737: PUSH
9738: LD_INT 1
9740: PUSH
9741: LD_INT 2
9743: PUSH
9744: LD_INT 3
9746: PUSH
9747: LD_INT 4
9749: PUSH
9750: LD_INT 5
9752: PUSH
9753: LD_INT 6
9755: PUSH
9756: LD_INT 7
9758: PUSH
9759: LD_INT 8
9761: PUSH
9762: LD_INT 9
9764: PUSH
9765: LD_INT 10
9767: PUSH
9768: LD_INT 11
9770: PUSH
9771: LD_INT 12
9773: PUSH
9774: LD_INT 13
9776: PUSH
9777: LD_INT 14
9779: PUSH
9780: LD_INT 15
9782: PUSH
9783: LD_INT 16
9785: PUSH
9786: LD_INT 17
9788: PUSH
9789: LD_INT 18
9791: PUSH
9792: LD_INT 19
9794: PUSH
9795: LD_INT 20
9797: PUSH
9798: LD_INT 21
9800: PUSH
9801: LD_INT 22
9803: PUSH
9804: LD_INT 23
9806: PUSH
9807: LD_INT 24
9809: PUSH
9810: LD_INT 25
9812: PUSH
9813: LD_INT 26
9815: PUSH
9816: LD_INT 27
9818: PUSH
9819: LD_INT 28
9821: PUSH
9822: LD_INT 30
9824: PUSH
9825: LD_INT 31
9827: PUSH
9828: LD_INT 32
9830: PUSH
9831: LD_INT 33
9833: PUSH
9834: LD_INT 34
9836: PUSH
9837: LD_INT 36
9839: PUSH
9840: EMPTY
9841: LIST
9842: LIST
9843: LIST
9844: LIST
9845: LIST
9846: LIST
9847: LIST
9848: LIST
9849: LIST
9850: LIST
9851: LIST
9852: LIST
9853: LIST
9854: LIST
9855: LIST
9856: LIST
9857: LIST
9858: LIST
9859: LIST
9860: LIST
9861: LIST
9862: LIST
9863: LIST
9864: LIST
9865: LIST
9866: LIST
9867: LIST
9868: LIST
9869: LIST
9870: LIST
9871: LIST
9872: LIST
9873: LIST
9874: LIST
9875: PUSH
9876: LD_INT 101
9878: PUSH
9879: LD_INT 102
9881: PUSH
9882: LD_INT 103
9884: PUSH
9885: LD_INT 104
9887: PUSH
9888: LD_INT 105
9890: PUSH
9891: LD_INT 106
9893: PUSH
9894: LD_INT 107
9896: PUSH
9897: LD_INT 108
9899: PUSH
9900: LD_INT 109
9902: PUSH
9903: LD_INT 110
9905: PUSH
9906: LD_INT 111
9908: PUSH
9909: LD_INT 112
9911: PUSH
9912: LD_INT 113
9914: PUSH
9915: LD_INT 114
9917: PUSH
9918: EMPTY
9919: LIST
9920: LIST
9921: LIST
9922: LIST
9923: LIST
9924: LIST
9925: LIST
9926: LIST
9927: LIST
9928: LIST
9929: LIST
9930: LIST
9931: LIST
9932: LIST
9933: PUSH
9934: EMPTY
9935: LIST
9936: LIST
9937: ST_TO_ADDR
9938: GO 11309
9940: LD_INT 13
9942: DOUBLE
9943: EQUAL
9944: IFTRUE 9948
9946: GO 10144
9948: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
9949: LD_ADDR_VAR 0 1
9953: PUSH
9954: LD_INT 1
9956: PUSH
9957: LD_INT 2
9959: PUSH
9960: LD_INT 3
9962: PUSH
9963: LD_INT 4
9965: PUSH
9966: LD_INT 5
9968: PUSH
9969: LD_INT 8
9971: PUSH
9972: LD_INT 9
9974: PUSH
9975: LD_INT 10
9977: PUSH
9978: LD_INT 11
9980: PUSH
9981: LD_INT 12
9983: PUSH
9984: LD_INT 14
9986: PUSH
9987: LD_INT 15
9989: PUSH
9990: LD_INT 16
9992: PUSH
9993: LD_INT 17
9995: PUSH
9996: LD_INT 18
9998: PUSH
9999: LD_INT 19
10001: PUSH
10002: LD_INT 20
10004: PUSH
10005: LD_INT 21
10007: PUSH
10008: LD_INT 22
10010: PUSH
10011: LD_INT 23
10013: PUSH
10014: LD_INT 24
10016: PUSH
10017: LD_INT 25
10019: PUSH
10020: LD_INT 26
10022: PUSH
10023: LD_INT 27
10025: PUSH
10026: LD_INT 28
10028: PUSH
10029: LD_INT 30
10031: PUSH
10032: LD_INT 31
10034: PUSH
10035: LD_INT 32
10037: PUSH
10038: LD_INT 33
10040: PUSH
10041: LD_INT 34
10043: PUSH
10044: LD_INT 36
10046: PUSH
10047: EMPTY
10048: LIST
10049: LIST
10050: LIST
10051: LIST
10052: LIST
10053: LIST
10054: LIST
10055: LIST
10056: LIST
10057: LIST
10058: LIST
10059: LIST
10060: LIST
10061: LIST
10062: LIST
10063: LIST
10064: LIST
10065: LIST
10066: LIST
10067: LIST
10068: LIST
10069: LIST
10070: LIST
10071: LIST
10072: LIST
10073: LIST
10074: LIST
10075: LIST
10076: LIST
10077: LIST
10078: LIST
10079: PUSH
10080: LD_INT 101
10082: PUSH
10083: LD_INT 102
10085: PUSH
10086: LD_INT 103
10088: PUSH
10089: LD_INT 104
10091: PUSH
10092: LD_INT 105
10094: PUSH
10095: LD_INT 106
10097: PUSH
10098: LD_INT 107
10100: PUSH
10101: LD_INT 108
10103: PUSH
10104: LD_INT 109
10106: PUSH
10107: LD_INT 110
10109: PUSH
10110: LD_INT 111
10112: PUSH
10113: LD_INT 112
10115: PUSH
10116: LD_INT 113
10118: PUSH
10119: LD_INT 114
10121: PUSH
10122: EMPTY
10123: LIST
10124: LIST
10125: LIST
10126: LIST
10127: LIST
10128: LIST
10129: LIST
10130: LIST
10131: LIST
10132: LIST
10133: LIST
10134: LIST
10135: LIST
10136: LIST
10137: PUSH
10138: EMPTY
10139: LIST
10140: LIST
10141: ST_TO_ADDR
10142: GO 11309
10144: LD_INT 14
10146: DOUBLE
10147: EQUAL
10148: IFTRUE 10152
10150: GO 10364
10152: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
10153: LD_ADDR_VAR 0 1
10157: PUSH
10158: LD_INT 1
10160: PUSH
10161: LD_INT 2
10163: PUSH
10164: LD_INT 3
10166: PUSH
10167: LD_INT 4
10169: PUSH
10170: LD_INT 5
10172: PUSH
10173: LD_INT 6
10175: PUSH
10176: LD_INT 7
10178: PUSH
10179: LD_INT 8
10181: PUSH
10182: LD_INT 9
10184: PUSH
10185: LD_INT 10
10187: PUSH
10188: LD_INT 11
10190: PUSH
10191: LD_INT 12
10193: PUSH
10194: LD_INT 13
10196: PUSH
10197: LD_INT 14
10199: PUSH
10200: LD_INT 15
10202: PUSH
10203: LD_INT 16
10205: PUSH
10206: LD_INT 17
10208: PUSH
10209: LD_INT 18
10211: PUSH
10212: LD_INT 19
10214: PUSH
10215: LD_INT 20
10217: PUSH
10218: LD_INT 21
10220: PUSH
10221: LD_INT 22
10223: PUSH
10224: LD_INT 23
10226: PUSH
10227: LD_INT 24
10229: PUSH
10230: LD_INT 25
10232: PUSH
10233: LD_INT 26
10235: PUSH
10236: LD_INT 27
10238: PUSH
10239: LD_INT 28
10241: PUSH
10242: LD_INT 29
10244: PUSH
10245: LD_INT 30
10247: PUSH
10248: LD_INT 31
10250: PUSH
10251: LD_INT 32
10253: PUSH
10254: LD_INT 33
10256: PUSH
10257: LD_INT 34
10259: PUSH
10260: LD_INT 36
10262: PUSH
10263: EMPTY
10264: LIST
10265: LIST
10266: LIST
10267: LIST
10268: LIST
10269: LIST
10270: LIST
10271: LIST
10272: LIST
10273: LIST
10274: LIST
10275: LIST
10276: LIST
10277: LIST
10278: LIST
10279: LIST
10280: LIST
10281: LIST
10282: LIST
10283: LIST
10284: LIST
10285: LIST
10286: LIST
10287: LIST
10288: LIST
10289: LIST
10290: LIST
10291: LIST
10292: LIST
10293: LIST
10294: LIST
10295: LIST
10296: LIST
10297: LIST
10298: LIST
10299: PUSH
10300: LD_INT 101
10302: PUSH
10303: LD_INT 102
10305: PUSH
10306: LD_INT 103
10308: PUSH
10309: LD_INT 104
10311: PUSH
10312: LD_INT 105
10314: PUSH
10315: LD_INT 106
10317: PUSH
10318: LD_INT 107
10320: PUSH
10321: LD_INT 108
10323: PUSH
10324: LD_INT 109
10326: PUSH
10327: LD_INT 110
10329: PUSH
10330: LD_INT 111
10332: PUSH
10333: LD_INT 112
10335: PUSH
10336: LD_INT 113
10338: PUSH
10339: LD_INT 114
10341: PUSH
10342: EMPTY
10343: LIST
10344: LIST
10345: LIST
10346: LIST
10347: LIST
10348: LIST
10349: LIST
10350: LIST
10351: LIST
10352: LIST
10353: LIST
10354: LIST
10355: LIST
10356: LIST
10357: PUSH
10358: EMPTY
10359: LIST
10360: LIST
10361: ST_TO_ADDR
10362: GO 11309
10364: LD_INT 15
10366: DOUBLE
10367: EQUAL
10368: IFTRUE 10372
10370: GO 10584
10372: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
10373: LD_ADDR_VAR 0 1
10377: PUSH
10378: LD_INT 1
10380: PUSH
10381: LD_INT 2
10383: PUSH
10384: LD_INT 3
10386: PUSH
10387: LD_INT 4
10389: PUSH
10390: LD_INT 5
10392: PUSH
10393: LD_INT 6
10395: PUSH
10396: LD_INT 7
10398: PUSH
10399: LD_INT 8
10401: PUSH
10402: LD_INT 9
10404: PUSH
10405: LD_INT 10
10407: PUSH
10408: LD_INT 11
10410: PUSH
10411: LD_INT 12
10413: PUSH
10414: LD_INT 13
10416: PUSH
10417: LD_INT 14
10419: PUSH
10420: LD_INT 15
10422: PUSH
10423: LD_INT 16
10425: PUSH
10426: LD_INT 17
10428: PUSH
10429: LD_INT 18
10431: PUSH
10432: LD_INT 19
10434: PUSH
10435: LD_INT 20
10437: PUSH
10438: LD_INT 21
10440: PUSH
10441: LD_INT 22
10443: PUSH
10444: LD_INT 23
10446: PUSH
10447: LD_INT 24
10449: PUSH
10450: LD_INT 25
10452: PUSH
10453: LD_INT 26
10455: PUSH
10456: LD_INT 27
10458: PUSH
10459: LD_INT 28
10461: PUSH
10462: LD_INT 29
10464: PUSH
10465: LD_INT 30
10467: PUSH
10468: LD_INT 31
10470: PUSH
10471: LD_INT 32
10473: PUSH
10474: LD_INT 33
10476: PUSH
10477: LD_INT 34
10479: PUSH
10480: LD_INT 36
10482: PUSH
10483: EMPTY
10484: LIST
10485: LIST
10486: LIST
10487: LIST
10488: LIST
10489: LIST
10490: LIST
10491: LIST
10492: LIST
10493: LIST
10494: LIST
10495: LIST
10496: LIST
10497: LIST
10498: LIST
10499: LIST
10500: LIST
10501: LIST
10502: LIST
10503: LIST
10504: LIST
10505: LIST
10506: LIST
10507: LIST
10508: LIST
10509: LIST
10510: LIST
10511: LIST
10512: LIST
10513: LIST
10514: LIST
10515: LIST
10516: LIST
10517: LIST
10518: LIST
10519: PUSH
10520: LD_INT 101
10522: PUSH
10523: LD_INT 102
10525: PUSH
10526: LD_INT 103
10528: PUSH
10529: LD_INT 104
10531: PUSH
10532: LD_INT 105
10534: PUSH
10535: LD_INT 106
10537: PUSH
10538: LD_INT 107
10540: PUSH
10541: LD_INT 108
10543: PUSH
10544: LD_INT 109
10546: PUSH
10547: LD_INT 110
10549: PUSH
10550: LD_INT 111
10552: PUSH
10553: LD_INT 112
10555: PUSH
10556: LD_INT 113
10558: PUSH
10559: LD_INT 114
10561: PUSH
10562: EMPTY
10563: LIST
10564: LIST
10565: LIST
10566: LIST
10567: LIST
10568: LIST
10569: LIST
10570: LIST
10571: LIST
10572: LIST
10573: LIST
10574: LIST
10575: LIST
10576: LIST
10577: PUSH
10578: EMPTY
10579: LIST
10580: LIST
10581: ST_TO_ADDR
10582: GO 11309
10584: LD_INT 16
10586: DOUBLE
10587: EQUAL
10588: IFTRUE 10592
10590: GO 10716
10592: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
10593: LD_ADDR_VAR 0 1
10597: PUSH
10598: LD_INT 2
10600: PUSH
10601: LD_INT 4
10603: PUSH
10604: LD_INT 5
10606: PUSH
10607: LD_INT 7
10609: PUSH
10610: LD_INT 11
10612: PUSH
10613: LD_INT 12
10615: PUSH
10616: LD_INT 15
10618: PUSH
10619: LD_INT 16
10621: PUSH
10622: LD_INT 20
10624: PUSH
10625: LD_INT 21
10627: PUSH
10628: LD_INT 22
10630: PUSH
10631: LD_INT 23
10633: PUSH
10634: LD_INT 25
10636: PUSH
10637: LD_INT 26
10639: PUSH
10640: LD_INT 30
10642: PUSH
10643: LD_INT 31
10645: PUSH
10646: LD_INT 32
10648: PUSH
10649: LD_INT 33
10651: PUSH
10652: LD_INT 34
10654: PUSH
10655: EMPTY
10656: LIST
10657: LIST
10658: LIST
10659: LIST
10660: LIST
10661: LIST
10662: LIST
10663: LIST
10664: LIST
10665: LIST
10666: LIST
10667: LIST
10668: LIST
10669: LIST
10670: LIST
10671: LIST
10672: LIST
10673: LIST
10674: LIST
10675: PUSH
10676: LD_INT 101
10678: PUSH
10679: LD_INT 102
10681: PUSH
10682: LD_INT 103
10684: PUSH
10685: LD_INT 106
10687: PUSH
10688: LD_INT 108
10690: PUSH
10691: LD_INT 112
10693: PUSH
10694: LD_INT 113
10696: PUSH
10697: LD_INT 114
10699: PUSH
10700: EMPTY
10701: LIST
10702: LIST
10703: LIST
10704: LIST
10705: LIST
10706: LIST
10707: LIST
10708: LIST
10709: PUSH
10710: EMPTY
10711: LIST
10712: LIST
10713: ST_TO_ADDR
10714: GO 11309
10716: LD_INT 17
10718: DOUBLE
10719: EQUAL
10720: IFTRUE 10724
10722: GO 10936
10724: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
10725: LD_ADDR_VAR 0 1
10729: PUSH
10730: LD_INT 1
10732: PUSH
10733: LD_INT 2
10735: PUSH
10736: LD_INT 3
10738: PUSH
10739: LD_INT 4
10741: PUSH
10742: LD_INT 5
10744: PUSH
10745: LD_INT 6
10747: PUSH
10748: LD_INT 7
10750: PUSH
10751: LD_INT 8
10753: PUSH
10754: LD_INT 9
10756: PUSH
10757: LD_INT 10
10759: PUSH
10760: LD_INT 11
10762: PUSH
10763: LD_INT 12
10765: PUSH
10766: LD_INT 13
10768: PUSH
10769: LD_INT 14
10771: PUSH
10772: LD_INT 15
10774: PUSH
10775: LD_INT 16
10777: PUSH
10778: LD_INT 17
10780: PUSH
10781: LD_INT 18
10783: PUSH
10784: LD_INT 19
10786: PUSH
10787: LD_INT 20
10789: PUSH
10790: LD_INT 21
10792: PUSH
10793: LD_INT 22
10795: PUSH
10796: LD_INT 23
10798: PUSH
10799: LD_INT 24
10801: PUSH
10802: LD_INT 25
10804: PUSH
10805: LD_INT 26
10807: PUSH
10808: LD_INT 27
10810: PUSH
10811: LD_INT 28
10813: PUSH
10814: LD_INT 29
10816: PUSH
10817: LD_INT 30
10819: PUSH
10820: LD_INT 31
10822: PUSH
10823: LD_INT 32
10825: PUSH
10826: LD_INT 33
10828: PUSH
10829: LD_INT 34
10831: PUSH
10832: LD_INT 36
10834: PUSH
10835: EMPTY
10836: LIST
10837: LIST
10838: LIST
10839: LIST
10840: LIST
10841: LIST
10842: LIST
10843: LIST
10844: LIST
10845: LIST
10846: LIST
10847: LIST
10848: LIST
10849: LIST
10850: LIST
10851: LIST
10852: LIST
10853: LIST
10854: LIST
10855: LIST
10856: LIST
10857: LIST
10858: LIST
10859: LIST
10860: LIST
10861: LIST
10862: LIST
10863: LIST
10864: LIST
10865: LIST
10866: LIST
10867: LIST
10868: LIST
10869: LIST
10870: LIST
10871: PUSH
10872: LD_INT 101
10874: PUSH
10875: LD_INT 102
10877: PUSH
10878: LD_INT 103
10880: PUSH
10881: LD_INT 104
10883: PUSH
10884: LD_INT 105
10886: PUSH
10887: LD_INT 106
10889: PUSH
10890: LD_INT 107
10892: PUSH
10893: LD_INT 108
10895: PUSH
10896: LD_INT 109
10898: PUSH
10899: LD_INT 110
10901: PUSH
10902: LD_INT 111
10904: PUSH
10905: LD_INT 112
10907: PUSH
10908: LD_INT 113
10910: PUSH
10911: LD_INT 114
10913: PUSH
10914: EMPTY
10915: LIST
10916: LIST
10917: LIST
10918: LIST
10919: LIST
10920: LIST
10921: LIST
10922: LIST
10923: LIST
10924: LIST
10925: LIST
10926: LIST
10927: LIST
10928: LIST
10929: PUSH
10930: EMPTY
10931: LIST
10932: LIST
10933: ST_TO_ADDR
10934: GO 11309
10936: LD_INT 18
10938: DOUBLE
10939: EQUAL
10940: IFTRUE 10944
10942: GO 11080
10944: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
10945: LD_ADDR_VAR 0 1
10949: PUSH
10950: LD_INT 2
10952: PUSH
10953: LD_INT 4
10955: PUSH
10956: LD_INT 5
10958: PUSH
10959: LD_INT 7
10961: PUSH
10962: LD_INT 11
10964: PUSH
10965: LD_INT 12
10967: PUSH
10968: LD_INT 15
10970: PUSH
10971: LD_INT 16
10973: PUSH
10974: LD_INT 20
10976: PUSH
10977: LD_INT 21
10979: PUSH
10980: LD_INT 22
10982: PUSH
10983: LD_INT 23
10985: PUSH
10986: LD_INT 25
10988: PUSH
10989: LD_INT 26
10991: PUSH
10992: LD_INT 30
10994: PUSH
10995: LD_INT 31
10997: PUSH
10998: LD_INT 32
11000: PUSH
11001: LD_INT 33
11003: PUSH
11004: LD_INT 34
11006: PUSH
11007: LD_INT 35
11009: PUSH
11010: LD_INT 36
11012: PUSH
11013: EMPTY
11014: LIST
11015: LIST
11016: LIST
11017: LIST
11018: LIST
11019: LIST
11020: LIST
11021: LIST
11022: LIST
11023: LIST
11024: LIST
11025: LIST
11026: LIST
11027: LIST
11028: LIST
11029: LIST
11030: LIST
11031: LIST
11032: LIST
11033: LIST
11034: LIST
11035: PUSH
11036: LD_INT 101
11038: PUSH
11039: LD_INT 102
11041: PUSH
11042: LD_INT 103
11044: PUSH
11045: LD_INT 106
11047: PUSH
11048: LD_INT 108
11050: PUSH
11051: LD_INT 112
11053: PUSH
11054: LD_INT 113
11056: PUSH
11057: LD_INT 114
11059: PUSH
11060: LD_INT 115
11062: PUSH
11063: EMPTY
11064: LIST
11065: LIST
11066: LIST
11067: LIST
11068: LIST
11069: LIST
11070: LIST
11071: LIST
11072: LIST
11073: PUSH
11074: EMPTY
11075: LIST
11076: LIST
11077: ST_TO_ADDR
11078: GO 11309
11080: LD_INT 19
11082: DOUBLE
11083: EQUAL
11084: IFTRUE 11088
11086: GO 11308
11088: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
11089: LD_ADDR_VAR 0 1
11093: PUSH
11094: LD_INT 1
11096: PUSH
11097: LD_INT 2
11099: PUSH
11100: LD_INT 3
11102: PUSH
11103: LD_INT 4
11105: PUSH
11106: LD_INT 5
11108: PUSH
11109: LD_INT 6
11111: PUSH
11112: LD_INT 7
11114: PUSH
11115: LD_INT 8
11117: PUSH
11118: LD_INT 9
11120: PUSH
11121: LD_INT 10
11123: PUSH
11124: LD_INT 11
11126: PUSH
11127: LD_INT 12
11129: PUSH
11130: LD_INT 13
11132: PUSH
11133: LD_INT 14
11135: PUSH
11136: LD_INT 15
11138: PUSH
11139: LD_INT 16
11141: PUSH
11142: LD_INT 17
11144: PUSH
11145: LD_INT 18
11147: PUSH
11148: LD_INT 19
11150: PUSH
11151: LD_INT 20
11153: PUSH
11154: LD_INT 21
11156: PUSH
11157: LD_INT 22
11159: PUSH
11160: LD_INT 23
11162: PUSH
11163: LD_INT 24
11165: PUSH
11166: LD_INT 25
11168: PUSH
11169: LD_INT 26
11171: PUSH
11172: LD_INT 27
11174: PUSH
11175: LD_INT 28
11177: PUSH
11178: LD_INT 29
11180: PUSH
11181: LD_INT 30
11183: PUSH
11184: LD_INT 31
11186: PUSH
11187: LD_INT 32
11189: PUSH
11190: LD_INT 33
11192: PUSH
11193: LD_INT 34
11195: PUSH
11196: LD_INT 35
11198: PUSH
11199: LD_INT 36
11201: PUSH
11202: EMPTY
11203: LIST
11204: LIST
11205: LIST
11206: LIST
11207: LIST
11208: LIST
11209: LIST
11210: LIST
11211: LIST
11212: LIST
11213: LIST
11214: LIST
11215: LIST
11216: LIST
11217: LIST
11218: LIST
11219: LIST
11220: LIST
11221: LIST
11222: LIST
11223: LIST
11224: LIST
11225: LIST
11226: LIST
11227: LIST
11228: LIST
11229: LIST
11230: LIST
11231: LIST
11232: LIST
11233: LIST
11234: LIST
11235: LIST
11236: LIST
11237: LIST
11238: LIST
11239: PUSH
11240: LD_INT 101
11242: PUSH
11243: LD_INT 102
11245: PUSH
11246: LD_INT 103
11248: PUSH
11249: LD_INT 104
11251: PUSH
11252: LD_INT 105
11254: PUSH
11255: LD_INT 106
11257: PUSH
11258: LD_INT 107
11260: PUSH
11261: LD_INT 108
11263: PUSH
11264: LD_INT 109
11266: PUSH
11267: LD_INT 110
11269: PUSH
11270: LD_INT 111
11272: PUSH
11273: LD_INT 112
11275: PUSH
11276: LD_INT 113
11278: PUSH
11279: LD_INT 114
11281: PUSH
11282: LD_INT 115
11284: PUSH
11285: EMPTY
11286: LIST
11287: LIST
11288: LIST
11289: LIST
11290: LIST
11291: LIST
11292: LIST
11293: LIST
11294: LIST
11295: LIST
11296: LIST
11297: LIST
11298: LIST
11299: LIST
11300: LIST
11301: PUSH
11302: EMPTY
11303: LIST
11304: LIST
11305: ST_TO_ADDR
11306: GO 11309
11308: POP
// end ; if result then
11309: LD_VAR 0 1
11313: IFFALSE 11602
// begin normal :=  ;
11315: LD_ADDR_VAR 0 3
11319: PUSH
11320: LD_STRING 
11322: ST_TO_ADDR
// hardcore :=  ;
11323: LD_ADDR_VAR 0 4
11327: PUSH
11328: LD_STRING 
11330: ST_TO_ADDR
// for i = 1 to normalCounter do
11331: LD_ADDR_VAR 0 5
11335: PUSH
11336: DOUBLE
11337: LD_INT 1
11339: DEC
11340: ST_TO_ADDR
11341: LD_EXP 35
11345: PUSH
11346: FOR_TO
11347: IFFALSE 11448
// begin tmp := 0 ;
11349: LD_ADDR_VAR 0 2
11353: PUSH
11354: LD_STRING 0
11356: ST_TO_ADDR
// if result [ 1 ] then
11357: LD_VAR 0 1
11361: PUSH
11362: LD_INT 1
11364: ARRAY
11365: IFFALSE 11430
// if result [ 1 ] [ 1 ] = i then
11367: LD_VAR 0 1
11371: PUSH
11372: LD_INT 1
11374: ARRAY
11375: PUSH
11376: LD_INT 1
11378: ARRAY
11379: PUSH
11380: LD_VAR 0 5
11384: EQUAL
11385: IFFALSE 11430
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
11387: LD_ADDR_VAR 0 1
11391: PUSH
11392: LD_VAR 0 1
11396: PPUSH
11397: LD_INT 1
11399: PPUSH
11400: LD_VAR 0 1
11404: PUSH
11405: LD_INT 1
11407: ARRAY
11408: PPUSH
11409: LD_INT 1
11411: PPUSH
11412: CALL_OW 3
11416: PPUSH
11417: CALL_OW 1
11421: ST_TO_ADDR
// tmp := 1 ;
11422: LD_ADDR_VAR 0 2
11426: PUSH
11427: LD_STRING 1
11429: ST_TO_ADDR
// end ; normal := normal & tmp ;
11430: LD_ADDR_VAR 0 3
11434: PUSH
11435: LD_VAR 0 3
11439: PUSH
11440: LD_VAR 0 2
11444: STR
11445: ST_TO_ADDR
// end ;
11446: GO 11346
11448: POP
11449: POP
// for i = 1 to hardcoreCounter do
11450: LD_ADDR_VAR 0 5
11454: PUSH
11455: DOUBLE
11456: LD_INT 1
11458: DEC
11459: ST_TO_ADDR
11460: LD_EXP 36
11464: PUSH
11465: FOR_TO
11466: IFFALSE 11571
// begin tmp := 0 ;
11468: LD_ADDR_VAR 0 2
11472: PUSH
11473: LD_STRING 0
11475: ST_TO_ADDR
// if result [ 2 ] then
11476: LD_VAR 0 1
11480: PUSH
11481: LD_INT 2
11483: ARRAY
11484: IFFALSE 11553
// if result [ 2 ] [ 1 ] = 100 + i then
11486: LD_VAR 0 1
11490: PUSH
11491: LD_INT 2
11493: ARRAY
11494: PUSH
11495: LD_INT 1
11497: ARRAY
11498: PUSH
11499: LD_INT 100
11501: PUSH
11502: LD_VAR 0 5
11506: PLUS
11507: EQUAL
11508: IFFALSE 11553
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
11510: LD_ADDR_VAR 0 1
11514: PUSH
11515: LD_VAR 0 1
11519: PPUSH
11520: LD_INT 2
11522: PPUSH
11523: LD_VAR 0 1
11527: PUSH
11528: LD_INT 2
11530: ARRAY
11531: PPUSH
11532: LD_INT 1
11534: PPUSH
11535: CALL_OW 3
11539: PPUSH
11540: CALL_OW 1
11544: ST_TO_ADDR
// tmp := 1 ;
11545: LD_ADDR_VAR 0 2
11549: PUSH
11550: LD_STRING 1
11552: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
11553: LD_ADDR_VAR 0 4
11557: PUSH
11558: LD_VAR 0 4
11562: PUSH
11563: LD_VAR 0 2
11567: STR
11568: ST_TO_ADDR
// end ;
11569: GO 11465
11571: POP
11572: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
11573: LD_STRING getStreamItemsFromMission("
11575: PUSH
11576: LD_VAR 0 3
11580: STR
11581: PUSH
11582: LD_STRING ","
11584: STR
11585: PUSH
11586: LD_VAR 0 4
11590: STR
11591: PUSH
11592: LD_STRING ")
11594: STR
11595: PPUSH
11596: CALL_OW 559
// end else
11600: GO 11609
// ToLua ( getStreamItemsFromMission("","") ) ;
11602: LD_STRING getStreamItemsFromMission("","")
11604: PPUSH
11605: CALL_OW 559
// end ;
11609: LD_VAR 0 1
11613: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
11614: LD_VAR 0 2
11618: PUSH
11619: LD_INT 100
11621: EQUAL
11622: IFFALSE 12571
// begin if not StreamModeActive then
11624: LD_EXP 34
11628: NOT
11629: IFFALSE 11639
// StreamModeActive := true ;
11631: LD_ADDR_EXP 34
11635: PUSH
11636: LD_INT 1
11638: ST_TO_ADDR
// if p3 = 0 then
11639: LD_VAR 0 3
11643: PUSH
11644: LD_INT 0
11646: EQUAL
11647: IFFALSE 11653
// InitStreamMode ;
11649: CALL 7911 0 0
// if p3 = 1 then
11653: LD_VAR 0 3
11657: PUSH
11658: LD_INT 1
11660: EQUAL
11661: IFFALSE 11671
// sRocket := true ;
11663: LD_ADDR_EXP 39
11667: PUSH
11668: LD_INT 1
11670: ST_TO_ADDR
// if p3 = 2 then
11671: LD_VAR 0 3
11675: PUSH
11676: LD_INT 2
11678: EQUAL
11679: IFFALSE 11689
// sSpeed := true ;
11681: LD_ADDR_EXP 38
11685: PUSH
11686: LD_INT 1
11688: ST_TO_ADDR
// if p3 = 3 then
11689: LD_VAR 0 3
11693: PUSH
11694: LD_INT 3
11696: EQUAL
11697: IFFALSE 11707
// sEngine := true ;
11699: LD_ADDR_EXP 40
11703: PUSH
11704: LD_INT 1
11706: ST_TO_ADDR
// if p3 = 4 then
11707: LD_VAR 0 3
11711: PUSH
11712: LD_INT 4
11714: EQUAL
11715: IFFALSE 11725
// sSpec := true ;
11717: LD_ADDR_EXP 37
11721: PUSH
11722: LD_INT 1
11724: ST_TO_ADDR
// if p3 = 5 then
11725: LD_VAR 0 3
11729: PUSH
11730: LD_INT 5
11732: EQUAL
11733: IFFALSE 11743
// sLevel := true ;
11735: LD_ADDR_EXP 41
11739: PUSH
11740: LD_INT 1
11742: ST_TO_ADDR
// if p3 = 6 then
11743: LD_VAR 0 3
11747: PUSH
11748: LD_INT 6
11750: EQUAL
11751: IFFALSE 11761
// sArmoury := true ;
11753: LD_ADDR_EXP 42
11757: PUSH
11758: LD_INT 1
11760: ST_TO_ADDR
// if p3 = 7 then
11761: LD_VAR 0 3
11765: PUSH
11766: LD_INT 7
11768: EQUAL
11769: IFFALSE 11779
// sRadar := true ;
11771: LD_ADDR_EXP 43
11775: PUSH
11776: LD_INT 1
11778: ST_TO_ADDR
// if p3 = 8 then
11779: LD_VAR 0 3
11783: PUSH
11784: LD_INT 8
11786: EQUAL
11787: IFFALSE 11797
// sBunker := true ;
11789: LD_ADDR_EXP 44
11793: PUSH
11794: LD_INT 1
11796: ST_TO_ADDR
// if p3 = 9 then
11797: LD_VAR 0 3
11801: PUSH
11802: LD_INT 9
11804: EQUAL
11805: IFFALSE 11815
// sHack := true ;
11807: LD_ADDR_EXP 45
11811: PUSH
11812: LD_INT 1
11814: ST_TO_ADDR
// if p3 = 10 then
11815: LD_VAR 0 3
11819: PUSH
11820: LD_INT 10
11822: EQUAL
11823: IFFALSE 11833
// sFire := true ;
11825: LD_ADDR_EXP 46
11829: PUSH
11830: LD_INT 1
11832: ST_TO_ADDR
// if p3 = 11 then
11833: LD_VAR 0 3
11837: PUSH
11838: LD_INT 11
11840: EQUAL
11841: IFFALSE 11851
// sRefresh := true ;
11843: LD_ADDR_EXP 47
11847: PUSH
11848: LD_INT 1
11850: ST_TO_ADDR
// if p3 = 12 then
11851: LD_VAR 0 3
11855: PUSH
11856: LD_INT 12
11858: EQUAL
11859: IFFALSE 11869
// sExp := true ;
11861: LD_ADDR_EXP 48
11865: PUSH
11866: LD_INT 1
11868: ST_TO_ADDR
// if p3 = 13 then
11869: LD_VAR 0 3
11873: PUSH
11874: LD_INT 13
11876: EQUAL
11877: IFFALSE 11887
// sDepot := true ;
11879: LD_ADDR_EXP 49
11883: PUSH
11884: LD_INT 1
11886: ST_TO_ADDR
// if p3 = 14 then
11887: LD_VAR 0 3
11891: PUSH
11892: LD_INT 14
11894: EQUAL
11895: IFFALSE 11905
// sFlag := true ;
11897: LD_ADDR_EXP 50
11901: PUSH
11902: LD_INT 1
11904: ST_TO_ADDR
// if p3 = 15 then
11905: LD_VAR 0 3
11909: PUSH
11910: LD_INT 15
11912: EQUAL
11913: IFFALSE 11923
// sKamikadze := true ;
11915: LD_ADDR_EXP 58
11919: PUSH
11920: LD_INT 1
11922: ST_TO_ADDR
// if p3 = 16 then
11923: LD_VAR 0 3
11927: PUSH
11928: LD_INT 16
11930: EQUAL
11931: IFFALSE 11941
// sTroll := true ;
11933: LD_ADDR_EXP 59
11937: PUSH
11938: LD_INT 1
11940: ST_TO_ADDR
// if p3 = 17 then
11941: LD_VAR 0 3
11945: PUSH
11946: LD_INT 17
11948: EQUAL
11949: IFFALSE 11959
// sSlow := true ;
11951: LD_ADDR_EXP 60
11955: PUSH
11956: LD_INT 1
11958: ST_TO_ADDR
// if p3 = 18 then
11959: LD_VAR 0 3
11963: PUSH
11964: LD_INT 18
11966: EQUAL
11967: IFFALSE 11977
// sLack := true ;
11969: LD_ADDR_EXP 61
11973: PUSH
11974: LD_INT 1
11976: ST_TO_ADDR
// if p3 = 19 then
11977: LD_VAR 0 3
11981: PUSH
11982: LD_INT 19
11984: EQUAL
11985: IFFALSE 11995
// sTank := true ;
11987: LD_ADDR_EXP 63
11991: PUSH
11992: LD_INT 1
11994: ST_TO_ADDR
// if p3 = 20 then
11995: LD_VAR 0 3
11999: PUSH
12000: LD_INT 20
12002: EQUAL
12003: IFFALSE 12013
// sRemote := true ;
12005: LD_ADDR_EXP 64
12009: PUSH
12010: LD_INT 1
12012: ST_TO_ADDR
// if p3 = 21 then
12013: LD_VAR 0 3
12017: PUSH
12018: LD_INT 21
12020: EQUAL
12021: IFFALSE 12031
// sPowell := true ;
12023: LD_ADDR_EXP 65
12027: PUSH
12028: LD_INT 1
12030: ST_TO_ADDR
// if p3 = 22 then
12031: LD_VAR 0 3
12035: PUSH
12036: LD_INT 22
12038: EQUAL
12039: IFFALSE 12049
// sTeleport := true ;
12041: LD_ADDR_EXP 68
12045: PUSH
12046: LD_INT 1
12048: ST_TO_ADDR
// if p3 = 23 then
12049: LD_VAR 0 3
12053: PUSH
12054: LD_INT 23
12056: EQUAL
12057: IFFALSE 12067
// sOilTower := true ;
12059: LD_ADDR_EXP 70
12063: PUSH
12064: LD_INT 1
12066: ST_TO_ADDR
// if p3 = 24 then
12067: LD_VAR 0 3
12071: PUSH
12072: LD_INT 24
12074: EQUAL
12075: IFFALSE 12085
// sShovel := true ;
12077: LD_ADDR_EXP 71
12081: PUSH
12082: LD_INT 1
12084: ST_TO_ADDR
// if p3 = 25 then
12085: LD_VAR 0 3
12089: PUSH
12090: LD_INT 25
12092: EQUAL
12093: IFFALSE 12103
// sSheik := true ;
12095: LD_ADDR_EXP 72
12099: PUSH
12100: LD_INT 1
12102: ST_TO_ADDR
// if p3 = 26 then
12103: LD_VAR 0 3
12107: PUSH
12108: LD_INT 26
12110: EQUAL
12111: IFFALSE 12121
// sEarthquake := true ;
12113: LD_ADDR_EXP 74
12117: PUSH
12118: LD_INT 1
12120: ST_TO_ADDR
// if p3 = 27 then
12121: LD_VAR 0 3
12125: PUSH
12126: LD_INT 27
12128: EQUAL
12129: IFFALSE 12139
// sAI := true ;
12131: LD_ADDR_EXP 75
12135: PUSH
12136: LD_INT 1
12138: ST_TO_ADDR
// if p3 = 28 then
12139: LD_VAR 0 3
12143: PUSH
12144: LD_INT 28
12146: EQUAL
12147: IFFALSE 12157
// sCargo := true ;
12149: LD_ADDR_EXP 78
12153: PUSH
12154: LD_INT 1
12156: ST_TO_ADDR
// if p3 = 29 then
12157: LD_VAR 0 3
12161: PUSH
12162: LD_INT 29
12164: EQUAL
12165: IFFALSE 12175
// sDLaser := true ;
12167: LD_ADDR_EXP 79
12171: PUSH
12172: LD_INT 1
12174: ST_TO_ADDR
// if p3 = 30 then
12175: LD_VAR 0 3
12179: PUSH
12180: LD_INT 30
12182: EQUAL
12183: IFFALSE 12193
// sExchange := true ;
12185: LD_ADDR_EXP 80
12189: PUSH
12190: LD_INT 1
12192: ST_TO_ADDR
// if p3 = 31 then
12193: LD_VAR 0 3
12197: PUSH
12198: LD_INT 31
12200: EQUAL
12201: IFFALSE 12211
// sFac := true ;
12203: LD_ADDR_EXP 81
12207: PUSH
12208: LD_INT 1
12210: ST_TO_ADDR
// if p3 = 32 then
12211: LD_VAR 0 3
12215: PUSH
12216: LD_INT 32
12218: EQUAL
12219: IFFALSE 12229
// sPower := true ;
12221: LD_ADDR_EXP 82
12225: PUSH
12226: LD_INT 1
12228: ST_TO_ADDR
// if p3 = 33 then
12229: LD_VAR 0 3
12233: PUSH
12234: LD_INT 33
12236: EQUAL
12237: IFFALSE 12247
// sRandom := true ;
12239: LD_ADDR_EXP 83
12243: PUSH
12244: LD_INT 1
12246: ST_TO_ADDR
// if p3 = 34 then
12247: LD_VAR 0 3
12251: PUSH
12252: LD_INT 34
12254: EQUAL
12255: IFFALSE 12265
// sShield := true ;
12257: LD_ADDR_EXP 84
12261: PUSH
12262: LD_INT 1
12264: ST_TO_ADDR
// if p3 = 35 then
12265: LD_VAR 0 3
12269: PUSH
12270: LD_INT 35
12272: EQUAL
12273: IFFALSE 12283
// sTime := true ;
12275: LD_ADDR_EXP 85
12279: PUSH
12280: LD_INT 1
12282: ST_TO_ADDR
// if p3 = 36 then
12283: LD_VAR 0 3
12287: PUSH
12288: LD_INT 36
12290: EQUAL
12291: IFFALSE 12301
// sTools := true ;
12293: LD_ADDR_EXP 86
12297: PUSH
12298: LD_INT 1
12300: ST_TO_ADDR
// if p3 = 101 then
12301: LD_VAR 0 3
12305: PUSH
12306: LD_INT 101
12308: EQUAL
12309: IFFALSE 12319
// sSold := true ;
12311: LD_ADDR_EXP 51
12315: PUSH
12316: LD_INT 1
12318: ST_TO_ADDR
// if p3 = 102 then
12319: LD_VAR 0 3
12323: PUSH
12324: LD_INT 102
12326: EQUAL
12327: IFFALSE 12337
// sDiff := true ;
12329: LD_ADDR_EXP 52
12333: PUSH
12334: LD_INT 1
12336: ST_TO_ADDR
// if p3 = 103 then
12337: LD_VAR 0 3
12341: PUSH
12342: LD_INT 103
12344: EQUAL
12345: IFFALSE 12355
// sFog := true ;
12347: LD_ADDR_EXP 55
12351: PUSH
12352: LD_INT 1
12354: ST_TO_ADDR
// if p3 = 104 then
12355: LD_VAR 0 3
12359: PUSH
12360: LD_INT 104
12362: EQUAL
12363: IFFALSE 12373
// sReset := true ;
12365: LD_ADDR_EXP 56
12369: PUSH
12370: LD_INT 1
12372: ST_TO_ADDR
// if p3 = 105 then
12373: LD_VAR 0 3
12377: PUSH
12378: LD_INT 105
12380: EQUAL
12381: IFFALSE 12391
// sSun := true ;
12383: LD_ADDR_EXP 57
12387: PUSH
12388: LD_INT 1
12390: ST_TO_ADDR
// if p3 = 106 then
12391: LD_VAR 0 3
12395: PUSH
12396: LD_INT 106
12398: EQUAL
12399: IFFALSE 12409
// sTiger := true ;
12401: LD_ADDR_EXP 53
12405: PUSH
12406: LD_INT 1
12408: ST_TO_ADDR
// if p3 = 107 then
12409: LD_VAR 0 3
12413: PUSH
12414: LD_INT 107
12416: EQUAL
12417: IFFALSE 12427
// sBomb := true ;
12419: LD_ADDR_EXP 54
12423: PUSH
12424: LD_INT 1
12426: ST_TO_ADDR
// if p3 = 108 then
12427: LD_VAR 0 3
12431: PUSH
12432: LD_INT 108
12434: EQUAL
12435: IFFALSE 12445
// sWound := true ;
12437: LD_ADDR_EXP 62
12441: PUSH
12442: LD_INT 1
12444: ST_TO_ADDR
// if p3 = 109 then
12445: LD_VAR 0 3
12449: PUSH
12450: LD_INT 109
12452: EQUAL
12453: IFFALSE 12463
// sBetray := true ;
12455: LD_ADDR_EXP 66
12459: PUSH
12460: LD_INT 1
12462: ST_TO_ADDR
// if p3 = 110 then
12463: LD_VAR 0 3
12467: PUSH
12468: LD_INT 110
12470: EQUAL
12471: IFFALSE 12481
// sContamin := true ;
12473: LD_ADDR_EXP 67
12477: PUSH
12478: LD_INT 1
12480: ST_TO_ADDR
// if p3 = 111 then
12481: LD_VAR 0 3
12485: PUSH
12486: LD_INT 111
12488: EQUAL
12489: IFFALSE 12499
// sOil := true ;
12491: LD_ADDR_EXP 69
12495: PUSH
12496: LD_INT 1
12498: ST_TO_ADDR
// if p3 = 112 then
12499: LD_VAR 0 3
12503: PUSH
12504: LD_INT 112
12506: EQUAL
12507: IFFALSE 12517
// sStu := true ;
12509: LD_ADDR_EXP 73
12513: PUSH
12514: LD_INT 1
12516: ST_TO_ADDR
// if p3 = 113 then
12517: LD_VAR 0 3
12521: PUSH
12522: LD_INT 113
12524: EQUAL
12525: IFFALSE 12535
// sBazooka := true ;
12527: LD_ADDR_EXP 76
12531: PUSH
12532: LD_INT 1
12534: ST_TO_ADDR
// if p3 = 114 then
12535: LD_VAR 0 3
12539: PUSH
12540: LD_INT 114
12542: EQUAL
12543: IFFALSE 12553
// sMortar := true ;
12545: LD_ADDR_EXP 77
12549: PUSH
12550: LD_INT 1
12552: ST_TO_ADDR
// if p3 = 115 then
12553: LD_VAR 0 3
12557: PUSH
12558: LD_INT 115
12560: EQUAL
12561: IFFALSE 12571
// sRanger := true ;
12563: LD_ADDR_EXP 87
12567: PUSH
12568: LD_INT 1
12570: ST_TO_ADDR
// end ; end ;
12571: PPOPN 6
12573: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
12574: LD_EXP 34
12578: PUSH
12579: LD_EXP 39
12583: AND
12584: IFFALSE 12708
12586: GO 12588
12588: DISABLE
12589: LD_INT 0
12591: PPUSH
12592: PPUSH
// begin enable ;
12593: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
12594: LD_ADDR_VAR 0 2
12598: PUSH
12599: LD_INT 22
12601: PUSH
12602: LD_OWVAR 2
12606: PUSH
12607: EMPTY
12608: LIST
12609: LIST
12610: PUSH
12611: LD_INT 2
12613: PUSH
12614: LD_INT 34
12616: PUSH
12617: LD_INT 7
12619: PUSH
12620: EMPTY
12621: LIST
12622: LIST
12623: PUSH
12624: LD_INT 34
12626: PUSH
12627: LD_INT 45
12629: PUSH
12630: EMPTY
12631: LIST
12632: LIST
12633: PUSH
12634: LD_INT 34
12636: PUSH
12637: LD_INT 28
12639: PUSH
12640: EMPTY
12641: LIST
12642: LIST
12643: PUSH
12644: LD_INT 34
12646: PUSH
12647: LD_INT 47
12649: PUSH
12650: EMPTY
12651: LIST
12652: LIST
12653: PUSH
12654: EMPTY
12655: LIST
12656: LIST
12657: LIST
12658: LIST
12659: LIST
12660: PUSH
12661: EMPTY
12662: LIST
12663: LIST
12664: PPUSH
12665: CALL_OW 69
12669: ST_TO_ADDR
// if not tmp then
12670: LD_VAR 0 2
12674: NOT
12675: IFFALSE 12679
// exit ;
12677: GO 12708
// for i in tmp do
12679: LD_ADDR_VAR 0 1
12683: PUSH
12684: LD_VAR 0 2
12688: PUSH
12689: FOR_IN
12690: IFFALSE 12706
// begin SetLives ( i , 0 ) ;
12692: LD_VAR 0 1
12696: PPUSH
12697: LD_INT 0
12699: PPUSH
12700: CALL_OW 234
// end ;
12704: GO 12689
12706: POP
12707: POP
// end ;
12708: PPOPN 2
12710: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
12711: LD_EXP 34
12715: PUSH
12716: LD_EXP 40
12720: AND
12721: IFFALSE 12805
12723: GO 12725
12725: DISABLE
12726: LD_INT 0
12728: PPUSH
12729: PPUSH
// begin enable ;
12730: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
12731: LD_ADDR_VAR 0 2
12735: PUSH
12736: LD_INT 22
12738: PUSH
12739: LD_OWVAR 2
12743: PUSH
12744: EMPTY
12745: LIST
12746: LIST
12747: PUSH
12748: LD_INT 32
12750: PUSH
12751: LD_INT 3
12753: PUSH
12754: EMPTY
12755: LIST
12756: LIST
12757: PUSH
12758: EMPTY
12759: LIST
12760: LIST
12761: PPUSH
12762: CALL_OW 69
12766: ST_TO_ADDR
// if not tmp then
12767: LD_VAR 0 2
12771: NOT
12772: IFFALSE 12776
// exit ;
12774: GO 12805
// for i in tmp do
12776: LD_ADDR_VAR 0 1
12780: PUSH
12781: LD_VAR 0 2
12785: PUSH
12786: FOR_IN
12787: IFFALSE 12803
// begin SetLives ( i , 0 ) ;
12789: LD_VAR 0 1
12793: PPUSH
12794: LD_INT 0
12796: PPUSH
12797: CALL_OW 234
// end ;
12801: GO 12786
12803: POP
12804: POP
// end ;
12805: PPOPN 2
12807: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
12808: LD_EXP 34
12812: PUSH
12813: LD_EXP 37
12817: AND
12818: IFFALSE 12911
12820: GO 12822
12822: DISABLE
12823: LD_INT 0
12825: PPUSH
// begin enable ;
12826: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
12827: LD_ADDR_VAR 0 1
12831: PUSH
12832: LD_INT 22
12834: PUSH
12835: LD_OWVAR 2
12839: PUSH
12840: EMPTY
12841: LIST
12842: LIST
12843: PUSH
12844: LD_INT 2
12846: PUSH
12847: LD_INT 25
12849: PUSH
12850: LD_INT 5
12852: PUSH
12853: EMPTY
12854: LIST
12855: LIST
12856: PUSH
12857: LD_INT 25
12859: PUSH
12860: LD_INT 9
12862: PUSH
12863: EMPTY
12864: LIST
12865: LIST
12866: PUSH
12867: LD_INT 25
12869: PUSH
12870: LD_INT 8
12872: PUSH
12873: EMPTY
12874: LIST
12875: LIST
12876: PUSH
12877: EMPTY
12878: LIST
12879: LIST
12880: LIST
12881: LIST
12882: PUSH
12883: EMPTY
12884: LIST
12885: LIST
12886: PPUSH
12887: CALL_OW 69
12891: PUSH
12892: FOR_IN
12893: IFFALSE 12909
// begin SetClass ( i , 1 ) ;
12895: LD_VAR 0 1
12899: PPUSH
12900: LD_INT 1
12902: PPUSH
12903: CALL_OW 336
// end ;
12907: GO 12892
12909: POP
12910: POP
// end ;
12911: PPOPN 1
12913: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
12914: LD_EXP 34
12918: PUSH
12919: LD_EXP 38
12923: AND
12924: PUSH
12925: LD_OWVAR 65
12929: PUSH
12930: LD_INT 7
12932: LESS
12933: AND
12934: IFFALSE 12948
12936: GO 12938
12938: DISABLE
// begin enable ;
12939: ENABLE
// game_speed := 7 ;
12940: LD_ADDR_OWVAR 65
12944: PUSH
12945: LD_INT 7
12947: ST_TO_ADDR
// end ;
12948: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
12949: LD_EXP 34
12953: PUSH
12954: LD_EXP 41
12958: AND
12959: IFFALSE 13161
12961: GO 12963
12963: DISABLE
12964: LD_INT 0
12966: PPUSH
12967: PPUSH
12968: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
12969: LD_ADDR_VAR 0 3
12973: PUSH
12974: LD_INT 81
12976: PUSH
12977: LD_OWVAR 2
12981: PUSH
12982: EMPTY
12983: LIST
12984: LIST
12985: PUSH
12986: LD_INT 21
12988: PUSH
12989: LD_INT 1
12991: PUSH
12992: EMPTY
12993: LIST
12994: LIST
12995: PUSH
12996: EMPTY
12997: LIST
12998: LIST
12999: PPUSH
13000: CALL_OW 69
13004: ST_TO_ADDR
// if not tmp then
13005: LD_VAR 0 3
13009: NOT
13010: IFFALSE 13014
// exit ;
13012: GO 13161
// if tmp > 5 then
13014: LD_VAR 0 3
13018: PUSH
13019: LD_INT 5
13021: GREATER
13022: IFFALSE 13034
// k := 5 else
13024: LD_ADDR_VAR 0 2
13028: PUSH
13029: LD_INT 5
13031: ST_TO_ADDR
13032: GO 13044
// k := tmp ;
13034: LD_ADDR_VAR 0 2
13038: PUSH
13039: LD_VAR 0 3
13043: ST_TO_ADDR
// for i := 1 to k do
13044: LD_ADDR_VAR 0 1
13048: PUSH
13049: DOUBLE
13050: LD_INT 1
13052: DEC
13053: ST_TO_ADDR
13054: LD_VAR 0 2
13058: PUSH
13059: FOR_TO
13060: IFFALSE 13159
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
13062: LD_VAR 0 3
13066: PUSH
13067: LD_VAR 0 1
13071: ARRAY
13072: PPUSH
13073: LD_VAR 0 1
13077: PUSH
13078: LD_INT 4
13080: MOD
13081: PUSH
13082: LD_INT 1
13084: PLUS
13085: PPUSH
13086: CALL_OW 259
13090: PUSH
13091: LD_INT 10
13093: LESS
13094: IFFALSE 13157
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
13096: LD_VAR 0 3
13100: PUSH
13101: LD_VAR 0 1
13105: ARRAY
13106: PPUSH
13107: LD_VAR 0 1
13111: PUSH
13112: LD_INT 4
13114: MOD
13115: PUSH
13116: LD_INT 1
13118: PLUS
13119: PPUSH
13120: LD_VAR 0 3
13124: PUSH
13125: LD_VAR 0 1
13129: ARRAY
13130: PPUSH
13131: LD_VAR 0 1
13135: PUSH
13136: LD_INT 4
13138: MOD
13139: PUSH
13140: LD_INT 1
13142: PLUS
13143: PPUSH
13144: CALL_OW 259
13148: PUSH
13149: LD_INT 1
13151: PLUS
13152: PPUSH
13153: CALL_OW 237
13157: GO 13059
13159: POP
13160: POP
// end ;
13161: PPOPN 3
13163: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
13164: LD_EXP 34
13168: PUSH
13169: LD_EXP 42
13173: AND
13174: IFFALSE 13194
13176: GO 13178
13178: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
13179: LD_INT 4
13181: PPUSH
13182: LD_OWVAR 2
13186: PPUSH
13187: LD_INT 0
13189: PPUSH
13190: CALL_OW 324
13194: END
// every 0 0$1 trigger StreamModeActive and sShovel do
13195: LD_EXP 34
13199: PUSH
13200: LD_EXP 71
13204: AND
13205: IFFALSE 13225
13207: GO 13209
13209: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
13210: LD_INT 19
13212: PPUSH
13213: LD_OWVAR 2
13217: PPUSH
13218: LD_INT 0
13220: PPUSH
13221: CALL_OW 324
13225: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
13226: LD_EXP 34
13230: PUSH
13231: LD_EXP 43
13235: AND
13236: IFFALSE 13338
13238: GO 13240
13240: DISABLE
13241: LD_INT 0
13243: PPUSH
13244: PPUSH
// begin enable ;
13245: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
13246: LD_ADDR_VAR 0 2
13250: PUSH
13251: LD_INT 22
13253: PUSH
13254: LD_OWVAR 2
13258: PUSH
13259: EMPTY
13260: LIST
13261: LIST
13262: PUSH
13263: LD_INT 2
13265: PUSH
13266: LD_INT 34
13268: PUSH
13269: LD_INT 11
13271: PUSH
13272: EMPTY
13273: LIST
13274: LIST
13275: PUSH
13276: LD_INT 34
13278: PUSH
13279: LD_INT 30
13281: PUSH
13282: EMPTY
13283: LIST
13284: LIST
13285: PUSH
13286: EMPTY
13287: LIST
13288: LIST
13289: LIST
13290: PUSH
13291: EMPTY
13292: LIST
13293: LIST
13294: PPUSH
13295: CALL_OW 69
13299: ST_TO_ADDR
// if not tmp then
13300: LD_VAR 0 2
13304: NOT
13305: IFFALSE 13309
// exit ;
13307: GO 13338
// for i in tmp do
13309: LD_ADDR_VAR 0 1
13313: PUSH
13314: LD_VAR 0 2
13318: PUSH
13319: FOR_IN
13320: IFFALSE 13336
// begin SetLives ( i , 0 ) ;
13322: LD_VAR 0 1
13326: PPUSH
13327: LD_INT 0
13329: PPUSH
13330: CALL_OW 234
// end ;
13334: GO 13319
13336: POP
13337: POP
// end ;
13338: PPOPN 2
13340: END
// every 0 0$1 trigger StreamModeActive and sBunker do
13341: LD_EXP 34
13345: PUSH
13346: LD_EXP 44
13350: AND
13351: IFFALSE 13371
13353: GO 13355
13355: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
13356: LD_INT 32
13358: PPUSH
13359: LD_OWVAR 2
13363: PPUSH
13364: LD_INT 0
13366: PPUSH
13367: CALL_OW 324
13371: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
13372: LD_EXP 34
13376: PUSH
13377: LD_EXP 45
13381: AND
13382: IFFALSE 13563
13384: GO 13386
13386: DISABLE
13387: LD_INT 0
13389: PPUSH
13390: PPUSH
13391: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
13392: LD_ADDR_VAR 0 2
13396: PUSH
13397: LD_INT 22
13399: PUSH
13400: LD_OWVAR 2
13404: PUSH
13405: EMPTY
13406: LIST
13407: LIST
13408: PUSH
13409: LD_INT 33
13411: PUSH
13412: LD_INT 3
13414: PUSH
13415: EMPTY
13416: LIST
13417: LIST
13418: PUSH
13419: EMPTY
13420: LIST
13421: LIST
13422: PPUSH
13423: CALL_OW 69
13427: ST_TO_ADDR
// if not tmp then
13428: LD_VAR 0 2
13432: NOT
13433: IFFALSE 13437
// exit ;
13435: GO 13563
// side := 0 ;
13437: LD_ADDR_VAR 0 3
13441: PUSH
13442: LD_INT 0
13444: ST_TO_ADDR
// for i := 1 to 8 do
13445: LD_ADDR_VAR 0 1
13449: PUSH
13450: DOUBLE
13451: LD_INT 1
13453: DEC
13454: ST_TO_ADDR
13455: LD_INT 8
13457: PUSH
13458: FOR_TO
13459: IFFALSE 13507
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
13461: LD_OWVAR 2
13465: PUSH
13466: LD_VAR 0 1
13470: NONEQUAL
13471: PUSH
13472: LD_OWVAR 2
13476: PPUSH
13477: LD_VAR 0 1
13481: PPUSH
13482: CALL_OW 81
13486: PUSH
13487: LD_INT 2
13489: EQUAL
13490: AND
13491: IFFALSE 13505
// begin side := i ;
13493: LD_ADDR_VAR 0 3
13497: PUSH
13498: LD_VAR 0 1
13502: ST_TO_ADDR
// break ;
13503: GO 13507
// end ;
13505: GO 13458
13507: POP
13508: POP
// if not side then
13509: LD_VAR 0 3
13513: NOT
13514: IFFALSE 13518
// exit ;
13516: GO 13563
// for i := 1 to tmp do
13518: LD_ADDR_VAR 0 1
13522: PUSH
13523: DOUBLE
13524: LD_INT 1
13526: DEC
13527: ST_TO_ADDR
13528: LD_VAR 0 2
13532: PUSH
13533: FOR_TO
13534: IFFALSE 13561
// if Prob ( 60 ) then
13536: LD_INT 60
13538: PPUSH
13539: CALL_OW 13
13543: IFFALSE 13559
// SetSide ( i , side ) ;
13545: LD_VAR 0 1
13549: PPUSH
13550: LD_VAR 0 3
13554: PPUSH
13555: CALL_OW 235
13559: GO 13533
13561: POP
13562: POP
// end ;
13563: PPOPN 3
13565: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
13566: LD_EXP 34
13570: PUSH
13571: LD_EXP 47
13575: AND
13576: IFFALSE 13695
13578: GO 13580
13580: DISABLE
13581: LD_INT 0
13583: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
13584: LD_ADDR_VAR 0 1
13588: PUSH
13589: LD_INT 22
13591: PUSH
13592: LD_OWVAR 2
13596: PUSH
13597: EMPTY
13598: LIST
13599: LIST
13600: PUSH
13601: LD_INT 21
13603: PUSH
13604: LD_INT 1
13606: PUSH
13607: EMPTY
13608: LIST
13609: LIST
13610: PUSH
13611: LD_INT 3
13613: PUSH
13614: LD_INT 23
13616: PUSH
13617: LD_INT 0
13619: PUSH
13620: EMPTY
13621: LIST
13622: LIST
13623: PUSH
13624: EMPTY
13625: LIST
13626: LIST
13627: PUSH
13628: EMPTY
13629: LIST
13630: LIST
13631: LIST
13632: PPUSH
13633: CALL_OW 69
13637: PUSH
13638: FOR_IN
13639: IFFALSE 13693
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
13641: LD_VAR 0 1
13645: PPUSH
13646: CALL_OW 257
13650: PUSH
13651: LD_INT 1
13653: PUSH
13654: LD_INT 2
13656: PUSH
13657: LD_INT 3
13659: PUSH
13660: LD_INT 4
13662: PUSH
13663: EMPTY
13664: LIST
13665: LIST
13666: LIST
13667: LIST
13668: IN
13669: IFFALSE 13691
// SetClass ( un , rand ( 1 , 4 ) ) ;
13671: LD_VAR 0 1
13675: PPUSH
13676: LD_INT 1
13678: PPUSH
13679: LD_INT 4
13681: PPUSH
13682: CALL_OW 12
13686: PPUSH
13687: CALL_OW 336
13691: GO 13638
13693: POP
13694: POP
// end ;
13695: PPOPN 1
13697: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
13698: LD_EXP 34
13702: PUSH
13703: LD_EXP 46
13707: AND
13708: IFFALSE 13787
13710: GO 13712
13712: DISABLE
13713: LD_INT 0
13715: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
13716: LD_ADDR_VAR 0 1
13720: PUSH
13721: LD_INT 22
13723: PUSH
13724: LD_OWVAR 2
13728: PUSH
13729: EMPTY
13730: LIST
13731: LIST
13732: PUSH
13733: LD_INT 21
13735: PUSH
13736: LD_INT 3
13738: PUSH
13739: EMPTY
13740: LIST
13741: LIST
13742: PUSH
13743: EMPTY
13744: LIST
13745: LIST
13746: PPUSH
13747: CALL_OW 69
13751: ST_TO_ADDR
// if not tmp then
13752: LD_VAR 0 1
13756: NOT
13757: IFFALSE 13761
// exit ;
13759: GO 13787
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
13761: LD_VAR 0 1
13765: PUSH
13766: LD_INT 1
13768: PPUSH
13769: LD_VAR 0 1
13773: PPUSH
13774: CALL_OW 12
13778: ARRAY
13779: PPUSH
13780: LD_INT 100
13782: PPUSH
13783: CALL_OW 234
// end ;
13787: PPOPN 1
13789: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
13790: LD_EXP 34
13794: PUSH
13795: LD_EXP 48
13799: AND
13800: IFFALSE 13898
13802: GO 13804
13804: DISABLE
13805: LD_INT 0
13807: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
13808: LD_ADDR_VAR 0 1
13812: PUSH
13813: LD_INT 22
13815: PUSH
13816: LD_OWVAR 2
13820: PUSH
13821: EMPTY
13822: LIST
13823: LIST
13824: PUSH
13825: LD_INT 21
13827: PUSH
13828: LD_INT 1
13830: PUSH
13831: EMPTY
13832: LIST
13833: LIST
13834: PUSH
13835: EMPTY
13836: LIST
13837: LIST
13838: PPUSH
13839: CALL_OW 69
13843: ST_TO_ADDR
// if not tmp then
13844: LD_VAR 0 1
13848: NOT
13849: IFFALSE 13853
// exit ;
13851: GO 13898
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
13853: LD_VAR 0 1
13857: PUSH
13858: LD_INT 1
13860: PPUSH
13861: LD_VAR 0 1
13865: PPUSH
13866: CALL_OW 12
13870: ARRAY
13871: PPUSH
13872: LD_INT 1
13874: PPUSH
13875: LD_INT 4
13877: PPUSH
13878: CALL_OW 12
13882: PPUSH
13883: LD_INT 3000
13885: PPUSH
13886: LD_INT 9000
13888: PPUSH
13889: CALL_OW 12
13893: PPUSH
13894: CALL_OW 492
// end ;
13898: PPOPN 1
13900: END
// every 0 0$1 trigger StreamModeActive and sDepot do
13901: LD_EXP 34
13905: PUSH
13906: LD_EXP 49
13910: AND
13911: IFFALSE 13931
13913: GO 13915
13915: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
13916: LD_INT 1
13918: PPUSH
13919: LD_OWVAR 2
13923: PPUSH
13924: LD_INT 0
13926: PPUSH
13927: CALL_OW 324
13931: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
13932: LD_EXP 34
13936: PUSH
13937: LD_EXP 50
13941: AND
13942: IFFALSE 14025
13944: GO 13946
13946: DISABLE
13947: LD_INT 0
13949: PPUSH
13950: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
13951: LD_ADDR_VAR 0 2
13955: PUSH
13956: LD_INT 22
13958: PUSH
13959: LD_OWVAR 2
13963: PUSH
13964: EMPTY
13965: LIST
13966: LIST
13967: PUSH
13968: LD_INT 21
13970: PUSH
13971: LD_INT 3
13973: PUSH
13974: EMPTY
13975: LIST
13976: LIST
13977: PUSH
13978: EMPTY
13979: LIST
13980: LIST
13981: PPUSH
13982: CALL_OW 69
13986: ST_TO_ADDR
// if not tmp then
13987: LD_VAR 0 2
13991: NOT
13992: IFFALSE 13996
// exit ;
13994: GO 14025
// for i in tmp do
13996: LD_ADDR_VAR 0 1
14000: PUSH
14001: LD_VAR 0 2
14005: PUSH
14006: FOR_IN
14007: IFFALSE 14023
// SetBLevel ( i , 10 ) ;
14009: LD_VAR 0 1
14013: PPUSH
14014: LD_INT 10
14016: PPUSH
14017: CALL_OW 241
14021: GO 14006
14023: POP
14024: POP
// end ;
14025: PPOPN 2
14027: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
14028: LD_EXP 34
14032: PUSH
14033: LD_EXP 51
14037: AND
14038: IFFALSE 14149
14040: GO 14042
14042: DISABLE
14043: LD_INT 0
14045: PPUSH
14046: PPUSH
14047: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
14048: LD_ADDR_VAR 0 3
14052: PUSH
14053: LD_INT 22
14055: PUSH
14056: LD_OWVAR 2
14060: PUSH
14061: EMPTY
14062: LIST
14063: LIST
14064: PUSH
14065: LD_INT 25
14067: PUSH
14068: LD_INT 1
14070: PUSH
14071: EMPTY
14072: LIST
14073: LIST
14074: PUSH
14075: EMPTY
14076: LIST
14077: LIST
14078: PPUSH
14079: CALL_OW 69
14083: ST_TO_ADDR
// if not tmp then
14084: LD_VAR 0 3
14088: NOT
14089: IFFALSE 14093
// exit ;
14091: GO 14149
// un := tmp [ rand ( 1 , tmp ) ] ;
14093: LD_ADDR_VAR 0 2
14097: PUSH
14098: LD_VAR 0 3
14102: PUSH
14103: LD_INT 1
14105: PPUSH
14106: LD_VAR 0 3
14110: PPUSH
14111: CALL_OW 12
14115: ARRAY
14116: ST_TO_ADDR
// if Crawls ( un ) then
14117: LD_VAR 0 2
14121: PPUSH
14122: CALL_OW 318
14126: IFFALSE 14137
// ComWalk ( un ) ;
14128: LD_VAR 0 2
14132: PPUSH
14133: CALL_OW 138
// SetClass ( un , class_sniper ) ;
14137: LD_VAR 0 2
14141: PPUSH
14142: LD_INT 5
14144: PPUSH
14145: CALL_OW 336
// end ;
14149: PPOPN 3
14151: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
14152: LD_EXP 34
14156: PUSH
14157: LD_EXP 52
14161: AND
14162: PUSH
14163: LD_OWVAR 67
14167: PUSH
14168: LD_INT 3
14170: LESS
14171: AND
14172: IFFALSE 14191
14174: GO 14176
14176: DISABLE
// Difficulty := Difficulty + 1 ;
14177: LD_ADDR_OWVAR 67
14181: PUSH
14182: LD_OWVAR 67
14186: PUSH
14187: LD_INT 1
14189: PLUS
14190: ST_TO_ADDR
14191: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
14192: LD_EXP 34
14196: PUSH
14197: LD_EXP 53
14201: AND
14202: IFFALSE 14305
14204: GO 14206
14206: DISABLE
14207: LD_INT 0
14209: PPUSH
// begin for i := 1 to 5 do
14210: LD_ADDR_VAR 0 1
14214: PUSH
14215: DOUBLE
14216: LD_INT 1
14218: DEC
14219: ST_TO_ADDR
14220: LD_INT 5
14222: PUSH
14223: FOR_TO
14224: IFFALSE 14303
// begin uc_nation := nation_nature ;
14226: LD_ADDR_OWVAR 21
14230: PUSH
14231: LD_INT 0
14233: ST_TO_ADDR
// uc_side := 0 ;
14234: LD_ADDR_OWVAR 20
14238: PUSH
14239: LD_INT 0
14241: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
14242: LD_ADDR_OWVAR 29
14246: PUSH
14247: LD_INT 12
14249: PUSH
14250: LD_INT 12
14252: PUSH
14253: EMPTY
14254: LIST
14255: LIST
14256: ST_TO_ADDR
// hc_agressivity := 20 ;
14257: LD_ADDR_OWVAR 35
14261: PUSH
14262: LD_INT 20
14264: ST_TO_ADDR
// hc_class := class_tiger ;
14265: LD_ADDR_OWVAR 28
14269: PUSH
14270: LD_INT 14
14272: ST_TO_ADDR
// hc_gallery :=  ;
14273: LD_ADDR_OWVAR 33
14277: PUSH
14278: LD_STRING 
14280: ST_TO_ADDR
// hc_name :=  ;
14281: LD_ADDR_OWVAR 26
14285: PUSH
14286: LD_STRING 
14288: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
14289: CALL_OW 44
14293: PPUSH
14294: LD_INT 0
14296: PPUSH
14297: CALL_OW 51
// end ;
14301: GO 14223
14303: POP
14304: POP
// end ;
14305: PPOPN 1
14307: END
// every 0 0$1 trigger StreamModeActive and sBomb do
14308: LD_EXP 34
14312: PUSH
14313: LD_EXP 54
14317: AND
14318: IFFALSE 14327
14320: GO 14322
14322: DISABLE
// StreamSibBomb ;
14323: CALL 14328 0 0
14327: END
// export function StreamSibBomb ; var i , x , y ; begin
14328: LD_INT 0
14330: PPUSH
14331: PPUSH
14332: PPUSH
14333: PPUSH
// result := false ;
14334: LD_ADDR_VAR 0 1
14338: PUSH
14339: LD_INT 0
14341: ST_TO_ADDR
// for i := 1 to 16 do
14342: LD_ADDR_VAR 0 2
14346: PUSH
14347: DOUBLE
14348: LD_INT 1
14350: DEC
14351: ST_TO_ADDR
14352: LD_INT 16
14354: PUSH
14355: FOR_TO
14356: IFFALSE 14555
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
14358: LD_ADDR_VAR 0 3
14362: PUSH
14363: LD_INT 10
14365: PUSH
14366: LD_INT 20
14368: PUSH
14369: LD_INT 30
14371: PUSH
14372: LD_INT 40
14374: PUSH
14375: LD_INT 50
14377: PUSH
14378: LD_INT 60
14380: PUSH
14381: LD_INT 70
14383: PUSH
14384: LD_INT 80
14386: PUSH
14387: LD_INT 90
14389: PUSH
14390: LD_INT 100
14392: PUSH
14393: LD_INT 110
14395: PUSH
14396: LD_INT 120
14398: PUSH
14399: LD_INT 130
14401: PUSH
14402: LD_INT 140
14404: PUSH
14405: LD_INT 150
14407: PUSH
14408: EMPTY
14409: LIST
14410: LIST
14411: LIST
14412: LIST
14413: LIST
14414: LIST
14415: LIST
14416: LIST
14417: LIST
14418: LIST
14419: LIST
14420: LIST
14421: LIST
14422: LIST
14423: LIST
14424: PUSH
14425: LD_INT 1
14427: PPUSH
14428: LD_INT 15
14430: PPUSH
14431: CALL_OW 12
14435: ARRAY
14436: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
14437: LD_ADDR_VAR 0 4
14441: PUSH
14442: LD_INT 10
14444: PUSH
14445: LD_INT 20
14447: PUSH
14448: LD_INT 30
14450: PUSH
14451: LD_INT 40
14453: PUSH
14454: LD_INT 50
14456: PUSH
14457: LD_INT 60
14459: PUSH
14460: LD_INT 70
14462: PUSH
14463: LD_INT 80
14465: PUSH
14466: LD_INT 90
14468: PUSH
14469: LD_INT 100
14471: PUSH
14472: LD_INT 110
14474: PUSH
14475: LD_INT 120
14477: PUSH
14478: LD_INT 130
14480: PUSH
14481: LD_INT 140
14483: PUSH
14484: LD_INT 150
14486: PUSH
14487: EMPTY
14488: LIST
14489: LIST
14490: LIST
14491: LIST
14492: LIST
14493: LIST
14494: LIST
14495: LIST
14496: LIST
14497: LIST
14498: LIST
14499: LIST
14500: LIST
14501: LIST
14502: LIST
14503: PUSH
14504: LD_INT 1
14506: PPUSH
14507: LD_INT 15
14509: PPUSH
14510: CALL_OW 12
14514: ARRAY
14515: ST_TO_ADDR
// if ValidHex ( x , y ) then
14516: LD_VAR 0 3
14520: PPUSH
14521: LD_VAR 0 4
14525: PPUSH
14526: CALL_OW 488
14530: IFFALSE 14553
// begin result := [ x , y ] ;
14532: LD_ADDR_VAR 0 1
14536: PUSH
14537: LD_VAR 0 3
14541: PUSH
14542: LD_VAR 0 4
14546: PUSH
14547: EMPTY
14548: LIST
14549: LIST
14550: ST_TO_ADDR
// break ;
14551: GO 14555
// end ; end ;
14553: GO 14355
14555: POP
14556: POP
// if result then
14557: LD_VAR 0 1
14561: IFFALSE 14621
// begin ToLua ( playSibBomb() ) ;
14563: LD_STRING playSibBomb()
14565: PPUSH
14566: CALL_OW 559
// wait ( 0 0$14 ) ;
14570: LD_INT 490
14572: PPUSH
14573: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
14577: LD_VAR 0 1
14581: PUSH
14582: LD_INT 1
14584: ARRAY
14585: PPUSH
14586: LD_VAR 0 1
14590: PUSH
14591: LD_INT 2
14593: ARRAY
14594: PPUSH
14595: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
14599: LD_VAR 0 1
14603: PUSH
14604: LD_INT 1
14606: ARRAY
14607: PPUSH
14608: LD_VAR 0 1
14612: PUSH
14613: LD_INT 2
14615: ARRAY
14616: PPUSH
14617: CALL_OW 429
// end ; end ;
14621: LD_VAR 0 1
14625: RET
// every 0 0$1 trigger StreamModeActive and sReset do
14626: LD_EXP 34
14630: PUSH
14631: LD_EXP 56
14635: AND
14636: IFFALSE 14648
14638: GO 14640
14640: DISABLE
// YouLost (  ) ;
14641: LD_STRING 
14643: PPUSH
14644: CALL_OW 104
14648: END
// every 0 0$1 trigger StreamModeActive and sFog do
14649: LD_EXP 34
14653: PUSH
14654: LD_EXP 55
14658: AND
14659: IFFALSE 14673
14661: GO 14663
14663: DISABLE
// FogOff ( your_side ) ;
14664: LD_OWVAR 2
14668: PPUSH
14669: CALL_OW 344
14673: END
// every 0 0$1 trigger StreamModeActive and sSun do
14674: LD_EXP 34
14678: PUSH
14679: LD_EXP 57
14683: AND
14684: IFFALSE 14712
14686: GO 14688
14688: DISABLE
// begin solar_recharge_percent := 0 ;
14689: LD_ADDR_OWVAR 79
14693: PUSH
14694: LD_INT 0
14696: ST_TO_ADDR
// wait ( 5 5$00 ) ;
14697: LD_INT 10500
14699: PPUSH
14700: CALL_OW 67
// solar_recharge_percent := 100 ;
14704: LD_ADDR_OWVAR 79
14708: PUSH
14709: LD_INT 100
14711: ST_TO_ADDR
// end ;
14712: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
14713: LD_EXP 34
14717: PUSH
14718: LD_EXP 58
14722: AND
14723: IFFALSE 14962
14725: GO 14727
14727: DISABLE
14728: LD_INT 0
14730: PPUSH
14731: PPUSH
14732: PPUSH
// begin tmp := [ ] ;
14733: LD_ADDR_VAR 0 3
14737: PUSH
14738: EMPTY
14739: ST_TO_ADDR
// for i := 1 to 6 do
14740: LD_ADDR_VAR 0 1
14744: PUSH
14745: DOUBLE
14746: LD_INT 1
14748: DEC
14749: ST_TO_ADDR
14750: LD_INT 6
14752: PUSH
14753: FOR_TO
14754: IFFALSE 14859
// begin uc_nation := nation_nature ;
14756: LD_ADDR_OWVAR 21
14760: PUSH
14761: LD_INT 0
14763: ST_TO_ADDR
// uc_side := 0 ;
14764: LD_ADDR_OWVAR 20
14768: PUSH
14769: LD_INT 0
14771: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
14772: LD_ADDR_OWVAR 29
14776: PUSH
14777: LD_INT 12
14779: PUSH
14780: LD_INT 12
14782: PUSH
14783: EMPTY
14784: LIST
14785: LIST
14786: ST_TO_ADDR
// hc_agressivity := 20 ;
14787: LD_ADDR_OWVAR 35
14791: PUSH
14792: LD_INT 20
14794: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
14795: LD_ADDR_OWVAR 28
14799: PUSH
14800: LD_INT 17
14802: ST_TO_ADDR
// hc_gallery :=  ;
14803: LD_ADDR_OWVAR 33
14807: PUSH
14808: LD_STRING 
14810: ST_TO_ADDR
// hc_name :=  ;
14811: LD_ADDR_OWVAR 26
14815: PUSH
14816: LD_STRING 
14818: ST_TO_ADDR
// un := CreateHuman ;
14819: LD_ADDR_VAR 0 2
14823: PUSH
14824: CALL_OW 44
14828: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
14829: LD_VAR 0 2
14833: PPUSH
14834: LD_INT 1
14836: PPUSH
14837: CALL_OW 51
// tmp := tmp ^ un ;
14841: LD_ADDR_VAR 0 3
14845: PUSH
14846: LD_VAR 0 3
14850: PUSH
14851: LD_VAR 0 2
14855: ADD
14856: ST_TO_ADDR
// end ;
14857: GO 14753
14859: POP
14860: POP
// repeat wait ( 0 0$1 ) ;
14861: LD_INT 35
14863: PPUSH
14864: CALL_OW 67
// for un in tmp do
14868: LD_ADDR_VAR 0 2
14872: PUSH
14873: LD_VAR 0 3
14877: PUSH
14878: FOR_IN
14879: IFFALSE 14953
// begin if IsDead ( un ) then
14881: LD_VAR 0 2
14885: PPUSH
14886: CALL_OW 301
14890: IFFALSE 14910
// begin tmp := tmp diff un ;
14892: LD_ADDR_VAR 0 3
14896: PUSH
14897: LD_VAR 0 3
14901: PUSH
14902: LD_VAR 0 2
14906: DIFF
14907: ST_TO_ADDR
// continue ;
14908: GO 14878
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
14910: LD_VAR 0 2
14914: PPUSH
14915: LD_INT 3
14917: PUSH
14918: LD_INT 22
14920: PUSH
14921: LD_INT 0
14923: PUSH
14924: EMPTY
14925: LIST
14926: LIST
14927: PUSH
14928: EMPTY
14929: LIST
14930: LIST
14931: PPUSH
14932: CALL_OW 69
14936: PPUSH
14937: LD_VAR 0 2
14941: PPUSH
14942: CALL_OW 74
14946: PPUSH
14947: CALL_OW 115
// end ;
14951: GO 14878
14953: POP
14954: POP
// until not tmp ;
14955: LD_VAR 0 3
14959: NOT
14960: IFFALSE 14861
// end ;
14962: PPOPN 3
14964: END
// every 0 0$1 trigger StreamModeActive and sTroll do
14965: LD_EXP 34
14969: PUSH
14970: LD_EXP 59
14974: AND
14975: IFFALSE 15029
14977: GO 14979
14979: DISABLE
// begin ToLua ( displayTroll(); ) ;
14980: LD_STRING displayTroll();
14982: PPUSH
14983: CALL_OW 559
// wait ( 3 3$00 ) ;
14987: LD_INT 6300
14989: PPUSH
14990: CALL_OW 67
// ToLua ( hideTroll(); ) ;
14994: LD_STRING hideTroll();
14996: PPUSH
14997: CALL_OW 559
// wait ( 1 1$00 ) ;
15001: LD_INT 2100
15003: PPUSH
15004: CALL_OW 67
// ToLua ( displayTroll(); ) ;
15008: LD_STRING displayTroll();
15010: PPUSH
15011: CALL_OW 559
// wait ( 1 1$00 ) ;
15015: LD_INT 2100
15017: PPUSH
15018: CALL_OW 67
// ToLua ( hideTroll(); ) ;
15022: LD_STRING hideTroll();
15024: PPUSH
15025: CALL_OW 559
// end ;
15029: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
15030: LD_EXP 34
15034: PUSH
15035: LD_EXP 60
15039: AND
15040: IFFALSE 15103
15042: GO 15044
15044: DISABLE
15045: LD_INT 0
15047: PPUSH
// begin p := 0 ;
15048: LD_ADDR_VAR 0 1
15052: PUSH
15053: LD_INT 0
15055: ST_TO_ADDR
// repeat game_speed := 1 ;
15056: LD_ADDR_OWVAR 65
15060: PUSH
15061: LD_INT 1
15063: ST_TO_ADDR
// wait ( 0 0$1 ) ;
15064: LD_INT 35
15066: PPUSH
15067: CALL_OW 67
// p := p + 1 ;
15071: LD_ADDR_VAR 0 1
15075: PUSH
15076: LD_VAR 0 1
15080: PUSH
15081: LD_INT 1
15083: PLUS
15084: ST_TO_ADDR
// until p >= 60 ;
15085: LD_VAR 0 1
15089: PUSH
15090: LD_INT 60
15092: GREATEREQUAL
15093: IFFALSE 15056
// game_speed := 4 ;
15095: LD_ADDR_OWVAR 65
15099: PUSH
15100: LD_INT 4
15102: ST_TO_ADDR
// end ;
15103: PPOPN 1
15105: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
15106: LD_EXP 34
15110: PUSH
15111: LD_EXP 61
15115: AND
15116: IFFALSE 15262
15118: GO 15120
15120: DISABLE
15121: LD_INT 0
15123: PPUSH
15124: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
15125: LD_ADDR_VAR 0 1
15129: PUSH
15130: LD_INT 22
15132: PUSH
15133: LD_OWVAR 2
15137: PUSH
15138: EMPTY
15139: LIST
15140: LIST
15141: PUSH
15142: LD_INT 2
15144: PUSH
15145: LD_INT 30
15147: PUSH
15148: LD_INT 0
15150: PUSH
15151: EMPTY
15152: LIST
15153: LIST
15154: PUSH
15155: LD_INT 30
15157: PUSH
15158: LD_INT 1
15160: PUSH
15161: EMPTY
15162: LIST
15163: LIST
15164: PUSH
15165: EMPTY
15166: LIST
15167: LIST
15168: LIST
15169: PUSH
15170: EMPTY
15171: LIST
15172: LIST
15173: PPUSH
15174: CALL_OW 69
15178: ST_TO_ADDR
// if not depot then
15179: LD_VAR 0 1
15183: NOT
15184: IFFALSE 15188
// exit ;
15186: GO 15262
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
15188: LD_ADDR_VAR 0 2
15192: PUSH
15193: LD_VAR 0 1
15197: PUSH
15198: LD_INT 1
15200: PPUSH
15201: LD_VAR 0 1
15205: PPUSH
15206: CALL_OW 12
15210: ARRAY
15211: PPUSH
15212: CALL_OW 274
15216: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
15217: LD_VAR 0 2
15221: PPUSH
15222: LD_INT 1
15224: PPUSH
15225: LD_INT 0
15227: PPUSH
15228: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
15232: LD_VAR 0 2
15236: PPUSH
15237: LD_INT 2
15239: PPUSH
15240: LD_INT 0
15242: PPUSH
15243: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
15247: LD_VAR 0 2
15251: PPUSH
15252: LD_INT 3
15254: PPUSH
15255: LD_INT 0
15257: PPUSH
15258: CALL_OW 277
// end ;
15262: PPOPN 2
15264: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
15265: LD_EXP 34
15269: PUSH
15270: LD_EXP 62
15274: AND
15275: IFFALSE 15372
15277: GO 15279
15279: DISABLE
15280: LD_INT 0
15282: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
15283: LD_ADDR_VAR 0 1
15287: PUSH
15288: LD_INT 22
15290: PUSH
15291: LD_OWVAR 2
15295: PUSH
15296: EMPTY
15297: LIST
15298: LIST
15299: PUSH
15300: LD_INT 21
15302: PUSH
15303: LD_INT 1
15305: PUSH
15306: EMPTY
15307: LIST
15308: LIST
15309: PUSH
15310: LD_INT 3
15312: PUSH
15313: LD_INT 23
15315: PUSH
15316: LD_INT 0
15318: PUSH
15319: EMPTY
15320: LIST
15321: LIST
15322: PUSH
15323: EMPTY
15324: LIST
15325: LIST
15326: PUSH
15327: EMPTY
15328: LIST
15329: LIST
15330: LIST
15331: PPUSH
15332: CALL_OW 69
15336: ST_TO_ADDR
// if not tmp then
15337: LD_VAR 0 1
15341: NOT
15342: IFFALSE 15346
// exit ;
15344: GO 15372
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
15346: LD_VAR 0 1
15350: PUSH
15351: LD_INT 1
15353: PPUSH
15354: LD_VAR 0 1
15358: PPUSH
15359: CALL_OW 12
15363: ARRAY
15364: PPUSH
15365: LD_INT 200
15367: PPUSH
15368: CALL_OW 234
// end ;
15372: PPOPN 1
15374: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
15375: LD_EXP 34
15379: PUSH
15380: LD_EXP 63
15384: AND
15385: IFFALSE 15464
15387: GO 15389
15389: DISABLE
15390: LD_INT 0
15392: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
15393: LD_ADDR_VAR 0 1
15397: PUSH
15398: LD_INT 22
15400: PUSH
15401: LD_OWVAR 2
15405: PUSH
15406: EMPTY
15407: LIST
15408: LIST
15409: PUSH
15410: LD_INT 21
15412: PUSH
15413: LD_INT 2
15415: PUSH
15416: EMPTY
15417: LIST
15418: LIST
15419: PUSH
15420: EMPTY
15421: LIST
15422: LIST
15423: PPUSH
15424: CALL_OW 69
15428: ST_TO_ADDR
// if not tmp then
15429: LD_VAR 0 1
15433: NOT
15434: IFFALSE 15438
// exit ;
15436: GO 15464
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
15438: LD_VAR 0 1
15442: PUSH
15443: LD_INT 1
15445: PPUSH
15446: LD_VAR 0 1
15450: PPUSH
15451: CALL_OW 12
15455: ARRAY
15456: PPUSH
15457: LD_INT 60
15459: PPUSH
15460: CALL_OW 234
// end ;
15464: PPOPN 1
15466: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
15467: LD_EXP 34
15471: PUSH
15472: LD_EXP 64
15476: AND
15477: IFFALSE 15576
15479: GO 15481
15481: DISABLE
15482: LD_INT 0
15484: PPUSH
15485: PPUSH
// begin enable ;
15486: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
15487: LD_ADDR_VAR 0 1
15491: PUSH
15492: LD_INT 22
15494: PUSH
15495: LD_OWVAR 2
15499: PUSH
15500: EMPTY
15501: LIST
15502: LIST
15503: PUSH
15504: LD_INT 61
15506: PUSH
15507: EMPTY
15508: LIST
15509: PUSH
15510: LD_INT 33
15512: PUSH
15513: LD_INT 2
15515: PUSH
15516: EMPTY
15517: LIST
15518: LIST
15519: PUSH
15520: EMPTY
15521: LIST
15522: LIST
15523: LIST
15524: PPUSH
15525: CALL_OW 69
15529: ST_TO_ADDR
// if not tmp then
15530: LD_VAR 0 1
15534: NOT
15535: IFFALSE 15539
// exit ;
15537: GO 15576
// for i in tmp do
15539: LD_ADDR_VAR 0 2
15543: PUSH
15544: LD_VAR 0 1
15548: PUSH
15549: FOR_IN
15550: IFFALSE 15574
// if IsControledBy ( i ) then
15552: LD_VAR 0 2
15556: PPUSH
15557: CALL_OW 312
15561: IFFALSE 15572
// ComUnlink ( i ) ;
15563: LD_VAR 0 2
15567: PPUSH
15568: CALL_OW 136
15572: GO 15549
15574: POP
15575: POP
// end ;
15576: PPOPN 2
15578: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
15579: LD_EXP 34
15583: PUSH
15584: LD_EXP 65
15588: AND
15589: IFFALSE 15729
15591: GO 15593
15593: DISABLE
15594: LD_INT 0
15596: PPUSH
15597: PPUSH
// begin ToLua ( displayPowell(); ) ;
15598: LD_STRING displayPowell();
15600: PPUSH
15601: CALL_OW 559
// uc_side := 0 ;
15605: LD_ADDR_OWVAR 20
15609: PUSH
15610: LD_INT 0
15612: ST_TO_ADDR
// uc_nation := 2 ;
15613: LD_ADDR_OWVAR 21
15617: PUSH
15618: LD_INT 2
15620: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
15621: LD_ADDR_OWVAR 37
15625: PUSH
15626: LD_INT 14
15628: ST_TO_ADDR
// vc_engine := engine_siberite ;
15629: LD_ADDR_OWVAR 39
15633: PUSH
15634: LD_INT 3
15636: ST_TO_ADDR
// vc_control := control_apeman ;
15637: LD_ADDR_OWVAR 38
15641: PUSH
15642: LD_INT 5
15644: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
15645: LD_ADDR_OWVAR 40
15649: PUSH
15650: LD_INT 29
15652: ST_TO_ADDR
// un := CreateVehicle ;
15653: LD_ADDR_VAR 0 2
15657: PUSH
15658: CALL_OW 45
15662: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
15663: LD_VAR 0 2
15667: PPUSH
15668: LD_INT 1
15670: PPUSH
15671: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
15675: LD_INT 35
15677: PPUSH
15678: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
15682: LD_VAR 0 2
15686: PPUSH
15687: LD_INT 22
15689: PUSH
15690: LD_OWVAR 2
15694: PUSH
15695: EMPTY
15696: LIST
15697: LIST
15698: PPUSH
15699: CALL_OW 69
15703: PPUSH
15704: LD_VAR 0 2
15708: PPUSH
15709: CALL_OW 74
15713: PPUSH
15714: CALL_OW 115
// until IsDead ( un ) ;
15718: LD_VAR 0 2
15722: PPUSH
15723: CALL_OW 301
15727: IFFALSE 15675
// end ;
15729: PPOPN 2
15731: END
// every 0 0$1 trigger StreamModeActive and sStu do
15732: LD_EXP 34
15736: PUSH
15737: LD_EXP 73
15741: AND
15742: IFFALSE 15758
15744: GO 15746
15746: DISABLE
// begin ToLua ( displayStucuk(); ) ;
15747: LD_STRING displayStucuk();
15749: PPUSH
15750: CALL_OW 559
// ResetFog ;
15754: CALL_OW 335
// end ;
15758: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
15759: LD_EXP 34
15763: PUSH
15764: LD_EXP 66
15768: AND
15769: IFFALSE 15910
15771: GO 15773
15773: DISABLE
15774: LD_INT 0
15776: PPUSH
15777: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
15778: LD_ADDR_VAR 0 2
15782: PUSH
15783: LD_INT 22
15785: PUSH
15786: LD_OWVAR 2
15790: PUSH
15791: EMPTY
15792: LIST
15793: LIST
15794: PUSH
15795: LD_INT 21
15797: PUSH
15798: LD_INT 1
15800: PUSH
15801: EMPTY
15802: LIST
15803: LIST
15804: PUSH
15805: EMPTY
15806: LIST
15807: LIST
15808: PPUSH
15809: CALL_OW 69
15813: ST_TO_ADDR
// if not tmp then
15814: LD_VAR 0 2
15818: NOT
15819: IFFALSE 15823
// exit ;
15821: GO 15910
// un := tmp [ rand ( 1 , tmp ) ] ;
15823: LD_ADDR_VAR 0 1
15827: PUSH
15828: LD_VAR 0 2
15832: PUSH
15833: LD_INT 1
15835: PPUSH
15836: LD_VAR 0 2
15840: PPUSH
15841: CALL_OW 12
15845: ARRAY
15846: ST_TO_ADDR
// SetSide ( un , 0 ) ;
15847: LD_VAR 0 1
15851: PPUSH
15852: LD_INT 0
15854: PPUSH
15855: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
15859: LD_VAR 0 1
15863: PPUSH
15864: LD_OWVAR 3
15868: PUSH
15869: LD_VAR 0 1
15873: DIFF
15874: PPUSH
15875: LD_VAR 0 1
15879: PPUSH
15880: CALL_OW 74
15884: PPUSH
15885: CALL_OW 115
// wait ( 0 0$20 ) ;
15889: LD_INT 700
15891: PPUSH
15892: CALL_OW 67
// SetSide ( un , your_side ) ;
15896: LD_VAR 0 1
15900: PPUSH
15901: LD_OWVAR 2
15905: PPUSH
15906: CALL_OW 235
// end ;
15910: PPOPN 2
15912: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
15913: LD_EXP 34
15917: PUSH
15918: LD_EXP 67
15922: AND
15923: IFFALSE 16029
15925: GO 15927
15927: DISABLE
15928: LD_INT 0
15930: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
15931: LD_ADDR_VAR 0 1
15935: PUSH
15936: LD_INT 22
15938: PUSH
15939: LD_OWVAR 2
15943: PUSH
15944: EMPTY
15945: LIST
15946: LIST
15947: PUSH
15948: LD_INT 2
15950: PUSH
15951: LD_INT 30
15953: PUSH
15954: LD_INT 0
15956: PUSH
15957: EMPTY
15958: LIST
15959: LIST
15960: PUSH
15961: LD_INT 30
15963: PUSH
15964: LD_INT 1
15966: PUSH
15967: EMPTY
15968: LIST
15969: LIST
15970: PUSH
15971: EMPTY
15972: LIST
15973: LIST
15974: LIST
15975: PUSH
15976: EMPTY
15977: LIST
15978: LIST
15979: PPUSH
15980: CALL_OW 69
15984: ST_TO_ADDR
// if not depot then
15985: LD_VAR 0 1
15989: NOT
15990: IFFALSE 15994
// exit ;
15992: GO 16029
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
15994: LD_VAR 0 1
15998: PUSH
15999: LD_INT 1
16001: ARRAY
16002: PPUSH
16003: CALL_OW 250
16007: PPUSH
16008: LD_VAR 0 1
16012: PUSH
16013: LD_INT 1
16015: ARRAY
16016: PPUSH
16017: CALL_OW 251
16021: PPUSH
16022: LD_INT 70
16024: PPUSH
16025: CALL_OW 495
// end ;
16029: PPOPN 1
16031: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
16032: LD_EXP 34
16036: PUSH
16037: LD_EXP 68
16041: AND
16042: IFFALSE 16253
16044: GO 16046
16046: DISABLE
16047: LD_INT 0
16049: PPUSH
16050: PPUSH
16051: PPUSH
16052: PPUSH
16053: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
16054: LD_ADDR_VAR 0 5
16058: PUSH
16059: LD_INT 22
16061: PUSH
16062: LD_OWVAR 2
16066: PUSH
16067: EMPTY
16068: LIST
16069: LIST
16070: PUSH
16071: LD_INT 21
16073: PUSH
16074: LD_INT 1
16076: PUSH
16077: EMPTY
16078: LIST
16079: LIST
16080: PUSH
16081: EMPTY
16082: LIST
16083: LIST
16084: PPUSH
16085: CALL_OW 69
16089: ST_TO_ADDR
// if not tmp then
16090: LD_VAR 0 5
16094: NOT
16095: IFFALSE 16099
// exit ;
16097: GO 16253
// for i in tmp do
16099: LD_ADDR_VAR 0 1
16103: PUSH
16104: LD_VAR 0 5
16108: PUSH
16109: FOR_IN
16110: IFFALSE 16251
// begin d := rand ( 0 , 5 ) ;
16112: LD_ADDR_VAR 0 4
16116: PUSH
16117: LD_INT 0
16119: PPUSH
16120: LD_INT 5
16122: PPUSH
16123: CALL_OW 12
16127: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
16128: LD_ADDR_VAR 0 2
16132: PUSH
16133: LD_VAR 0 1
16137: PPUSH
16138: CALL_OW 250
16142: PPUSH
16143: LD_VAR 0 4
16147: PPUSH
16148: LD_INT 3
16150: PPUSH
16151: LD_INT 12
16153: PPUSH
16154: CALL_OW 12
16158: PPUSH
16159: CALL_OW 272
16163: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
16164: LD_ADDR_VAR 0 3
16168: PUSH
16169: LD_VAR 0 1
16173: PPUSH
16174: CALL_OW 251
16178: PPUSH
16179: LD_VAR 0 4
16183: PPUSH
16184: LD_INT 3
16186: PPUSH
16187: LD_INT 12
16189: PPUSH
16190: CALL_OW 12
16194: PPUSH
16195: CALL_OW 273
16199: ST_TO_ADDR
// if ValidHex ( x , y ) then
16200: LD_VAR 0 2
16204: PPUSH
16205: LD_VAR 0 3
16209: PPUSH
16210: CALL_OW 488
16214: IFFALSE 16249
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
16216: LD_VAR 0 1
16220: PPUSH
16221: LD_VAR 0 2
16225: PPUSH
16226: LD_VAR 0 3
16230: PPUSH
16231: LD_INT 3
16233: PPUSH
16234: LD_INT 6
16236: PPUSH
16237: CALL_OW 12
16241: PPUSH
16242: LD_INT 1
16244: PPUSH
16245: CALL_OW 483
// end ;
16249: GO 16109
16251: POP
16252: POP
// end ;
16253: PPOPN 5
16255: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
16256: LD_EXP 34
16260: PUSH
16261: LD_EXP 69
16265: AND
16266: IFFALSE 16360
16268: GO 16270
16270: DISABLE
16271: LD_INT 0
16273: PPUSH
16274: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
16275: LD_ADDR_VAR 0 2
16279: PUSH
16280: LD_INT 22
16282: PUSH
16283: LD_OWVAR 2
16287: PUSH
16288: EMPTY
16289: LIST
16290: LIST
16291: PUSH
16292: LD_INT 32
16294: PUSH
16295: LD_INT 1
16297: PUSH
16298: EMPTY
16299: LIST
16300: LIST
16301: PUSH
16302: LD_INT 21
16304: PUSH
16305: LD_INT 2
16307: PUSH
16308: EMPTY
16309: LIST
16310: LIST
16311: PUSH
16312: EMPTY
16313: LIST
16314: LIST
16315: LIST
16316: PPUSH
16317: CALL_OW 69
16321: ST_TO_ADDR
// if not tmp then
16322: LD_VAR 0 2
16326: NOT
16327: IFFALSE 16331
// exit ;
16329: GO 16360
// for i in tmp do
16331: LD_ADDR_VAR 0 1
16335: PUSH
16336: LD_VAR 0 2
16340: PUSH
16341: FOR_IN
16342: IFFALSE 16358
// SetFuel ( i , 0 ) ;
16344: LD_VAR 0 1
16348: PPUSH
16349: LD_INT 0
16351: PPUSH
16352: CALL_OW 240
16356: GO 16341
16358: POP
16359: POP
// end ;
16360: PPOPN 2
16362: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
16363: LD_EXP 34
16367: PUSH
16368: LD_EXP 70
16372: AND
16373: IFFALSE 16439
16375: GO 16377
16377: DISABLE
16378: LD_INT 0
16380: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
16381: LD_ADDR_VAR 0 1
16385: PUSH
16386: LD_INT 22
16388: PUSH
16389: LD_OWVAR 2
16393: PUSH
16394: EMPTY
16395: LIST
16396: LIST
16397: PUSH
16398: LD_INT 30
16400: PUSH
16401: LD_INT 29
16403: PUSH
16404: EMPTY
16405: LIST
16406: LIST
16407: PUSH
16408: EMPTY
16409: LIST
16410: LIST
16411: PPUSH
16412: CALL_OW 69
16416: ST_TO_ADDR
// if not tmp then
16417: LD_VAR 0 1
16421: NOT
16422: IFFALSE 16426
// exit ;
16424: GO 16439
// DestroyUnit ( tmp [ 1 ] ) ;
16426: LD_VAR 0 1
16430: PUSH
16431: LD_INT 1
16433: ARRAY
16434: PPUSH
16435: CALL_OW 65
// end ;
16439: PPOPN 1
16441: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
16442: LD_EXP 34
16446: PUSH
16447: LD_EXP 72
16451: AND
16452: IFFALSE 16581
16454: GO 16456
16456: DISABLE
16457: LD_INT 0
16459: PPUSH
// begin uc_side := 0 ;
16460: LD_ADDR_OWVAR 20
16464: PUSH
16465: LD_INT 0
16467: ST_TO_ADDR
// uc_nation := nation_arabian ;
16468: LD_ADDR_OWVAR 21
16472: PUSH
16473: LD_INT 2
16475: ST_TO_ADDR
// hc_gallery :=  ;
16476: LD_ADDR_OWVAR 33
16480: PUSH
16481: LD_STRING 
16483: ST_TO_ADDR
// hc_name :=  ;
16484: LD_ADDR_OWVAR 26
16488: PUSH
16489: LD_STRING 
16491: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
16492: LD_INT 1
16494: PPUSH
16495: LD_INT 11
16497: PPUSH
16498: LD_INT 10
16500: PPUSH
16501: CALL_OW 380
// un := CreateHuman ;
16505: LD_ADDR_VAR 0 1
16509: PUSH
16510: CALL_OW 44
16514: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
16515: LD_VAR 0 1
16519: PPUSH
16520: LD_INT 1
16522: PPUSH
16523: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
16527: LD_INT 35
16529: PPUSH
16530: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
16534: LD_VAR 0 1
16538: PPUSH
16539: LD_INT 22
16541: PUSH
16542: LD_OWVAR 2
16546: PUSH
16547: EMPTY
16548: LIST
16549: LIST
16550: PPUSH
16551: CALL_OW 69
16555: PPUSH
16556: LD_VAR 0 1
16560: PPUSH
16561: CALL_OW 74
16565: PPUSH
16566: CALL_OW 115
// until IsDead ( un ) ;
16570: LD_VAR 0 1
16574: PPUSH
16575: CALL_OW 301
16579: IFFALSE 16527
// end ;
16581: PPOPN 1
16583: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
16584: LD_EXP 34
16588: PUSH
16589: LD_EXP 74
16593: AND
16594: IFFALSE 16606
16596: GO 16598
16598: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
16599: LD_STRING earthquake(getX(game), 0, 32)
16601: PPUSH
16602: CALL_OW 559
16606: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
16607: LD_EXP 34
16611: PUSH
16612: LD_EXP 75
16616: AND
16617: IFFALSE 16708
16619: GO 16621
16621: DISABLE
16622: LD_INT 0
16624: PPUSH
// begin enable ;
16625: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
16626: LD_ADDR_VAR 0 1
16630: PUSH
16631: LD_INT 22
16633: PUSH
16634: LD_OWVAR 2
16638: PUSH
16639: EMPTY
16640: LIST
16641: LIST
16642: PUSH
16643: LD_INT 21
16645: PUSH
16646: LD_INT 2
16648: PUSH
16649: EMPTY
16650: LIST
16651: LIST
16652: PUSH
16653: LD_INT 33
16655: PUSH
16656: LD_INT 3
16658: PUSH
16659: EMPTY
16660: LIST
16661: LIST
16662: PUSH
16663: EMPTY
16664: LIST
16665: LIST
16666: LIST
16667: PPUSH
16668: CALL_OW 69
16672: ST_TO_ADDR
// if not tmp then
16673: LD_VAR 0 1
16677: NOT
16678: IFFALSE 16682
// exit ;
16680: GO 16708
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
16682: LD_VAR 0 1
16686: PUSH
16687: LD_INT 1
16689: PPUSH
16690: LD_VAR 0 1
16694: PPUSH
16695: CALL_OW 12
16699: ARRAY
16700: PPUSH
16701: LD_INT 1
16703: PPUSH
16704: CALL_OW 234
// end ;
16708: PPOPN 1
16710: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
16711: LD_EXP 34
16715: PUSH
16716: LD_EXP 76
16720: AND
16721: IFFALSE 16862
16723: GO 16725
16725: DISABLE
16726: LD_INT 0
16728: PPUSH
16729: PPUSH
16730: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
16731: LD_ADDR_VAR 0 3
16735: PUSH
16736: LD_INT 22
16738: PUSH
16739: LD_OWVAR 2
16743: PUSH
16744: EMPTY
16745: LIST
16746: LIST
16747: PUSH
16748: LD_INT 25
16750: PUSH
16751: LD_INT 1
16753: PUSH
16754: EMPTY
16755: LIST
16756: LIST
16757: PUSH
16758: EMPTY
16759: LIST
16760: LIST
16761: PPUSH
16762: CALL_OW 69
16766: ST_TO_ADDR
// if not tmp then
16767: LD_VAR 0 3
16771: NOT
16772: IFFALSE 16776
// exit ;
16774: GO 16862
// un := tmp [ rand ( 1 , tmp ) ] ;
16776: LD_ADDR_VAR 0 2
16780: PUSH
16781: LD_VAR 0 3
16785: PUSH
16786: LD_INT 1
16788: PPUSH
16789: LD_VAR 0 3
16793: PPUSH
16794: CALL_OW 12
16798: ARRAY
16799: ST_TO_ADDR
// if Crawls ( un ) then
16800: LD_VAR 0 2
16804: PPUSH
16805: CALL_OW 318
16809: IFFALSE 16820
// ComWalk ( un ) ;
16811: LD_VAR 0 2
16815: PPUSH
16816: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
16820: LD_VAR 0 2
16824: PPUSH
16825: LD_INT 9
16827: PPUSH
16828: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
16832: LD_INT 28
16834: PPUSH
16835: LD_OWVAR 2
16839: PPUSH
16840: LD_INT 2
16842: PPUSH
16843: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
16847: LD_INT 29
16849: PPUSH
16850: LD_OWVAR 2
16854: PPUSH
16855: LD_INT 2
16857: PPUSH
16858: CALL_OW 322
// end ;
16862: PPOPN 3
16864: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
16865: LD_EXP 34
16869: PUSH
16870: LD_EXP 77
16874: AND
16875: IFFALSE 16986
16877: GO 16879
16879: DISABLE
16880: LD_INT 0
16882: PPUSH
16883: PPUSH
16884: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
16885: LD_ADDR_VAR 0 3
16889: PUSH
16890: LD_INT 22
16892: PUSH
16893: LD_OWVAR 2
16897: PUSH
16898: EMPTY
16899: LIST
16900: LIST
16901: PUSH
16902: LD_INT 25
16904: PUSH
16905: LD_INT 1
16907: PUSH
16908: EMPTY
16909: LIST
16910: LIST
16911: PUSH
16912: EMPTY
16913: LIST
16914: LIST
16915: PPUSH
16916: CALL_OW 69
16920: ST_TO_ADDR
// if not tmp then
16921: LD_VAR 0 3
16925: NOT
16926: IFFALSE 16930
// exit ;
16928: GO 16986
// un := tmp [ rand ( 1 , tmp ) ] ;
16930: LD_ADDR_VAR 0 2
16934: PUSH
16935: LD_VAR 0 3
16939: PUSH
16940: LD_INT 1
16942: PPUSH
16943: LD_VAR 0 3
16947: PPUSH
16948: CALL_OW 12
16952: ARRAY
16953: ST_TO_ADDR
// if Crawls ( un ) then
16954: LD_VAR 0 2
16958: PPUSH
16959: CALL_OW 318
16963: IFFALSE 16974
// ComWalk ( un ) ;
16965: LD_VAR 0 2
16969: PPUSH
16970: CALL_OW 138
// SetClass ( un , class_mortar ) ;
16974: LD_VAR 0 2
16978: PPUSH
16979: LD_INT 8
16981: PPUSH
16982: CALL_OW 336
// end ;
16986: PPOPN 3
16988: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
16989: LD_EXP 34
16993: PUSH
16994: LD_EXP 78
16998: AND
16999: IFFALSE 17143
17001: GO 17003
17003: DISABLE
17004: LD_INT 0
17006: PPUSH
17007: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
17008: LD_ADDR_VAR 0 2
17012: PUSH
17013: LD_INT 22
17015: PUSH
17016: LD_OWVAR 2
17020: PUSH
17021: EMPTY
17022: LIST
17023: LIST
17024: PUSH
17025: LD_INT 21
17027: PUSH
17028: LD_INT 2
17030: PUSH
17031: EMPTY
17032: LIST
17033: LIST
17034: PUSH
17035: LD_INT 2
17037: PUSH
17038: LD_INT 34
17040: PUSH
17041: LD_INT 12
17043: PUSH
17044: EMPTY
17045: LIST
17046: LIST
17047: PUSH
17048: LD_INT 34
17050: PUSH
17051: LD_INT 51
17053: PUSH
17054: EMPTY
17055: LIST
17056: LIST
17057: PUSH
17058: LD_INT 34
17060: PUSH
17061: LD_INT 32
17063: PUSH
17064: EMPTY
17065: LIST
17066: LIST
17067: PUSH
17068: EMPTY
17069: LIST
17070: LIST
17071: LIST
17072: LIST
17073: PUSH
17074: EMPTY
17075: LIST
17076: LIST
17077: LIST
17078: PPUSH
17079: CALL_OW 69
17083: ST_TO_ADDR
// if not tmp then
17084: LD_VAR 0 2
17088: NOT
17089: IFFALSE 17093
// exit ;
17091: GO 17143
// for i in tmp do
17093: LD_ADDR_VAR 0 1
17097: PUSH
17098: LD_VAR 0 2
17102: PUSH
17103: FOR_IN
17104: IFFALSE 17141
// if GetCargo ( i , mat_artifact ) = 0 then
17106: LD_VAR 0 1
17110: PPUSH
17111: LD_INT 4
17113: PPUSH
17114: CALL_OW 289
17118: PUSH
17119: LD_INT 0
17121: EQUAL
17122: IFFALSE 17139
// SetCargo ( i , mat_siberit , 100 ) ;
17124: LD_VAR 0 1
17128: PPUSH
17129: LD_INT 3
17131: PPUSH
17132: LD_INT 100
17134: PPUSH
17135: CALL_OW 290
17139: GO 17103
17141: POP
17142: POP
// end ;
17143: PPOPN 2
17145: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
17146: LD_EXP 34
17150: PUSH
17151: LD_EXP 79
17155: AND
17156: IFFALSE 17309
17158: GO 17160
17160: DISABLE
17161: LD_INT 0
17163: PPUSH
17164: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
17165: LD_ADDR_VAR 0 2
17169: PUSH
17170: LD_INT 22
17172: PUSH
17173: LD_OWVAR 2
17177: PUSH
17178: EMPTY
17179: LIST
17180: LIST
17181: PPUSH
17182: CALL_OW 69
17186: ST_TO_ADDR
// if not tmp then
17187: LD_VAR 0 2
17191: NOT
17192: IFFALSE 17196
// exit ;
17194: GO 17309
// for i := 1 to 2 do
17196: LD_ADDR_VAR 0 1
17200: PUSH
17201: DOUBLE
17202: LD_INT 1
17204: DEC
17205: ST_TO_ADDR
17206: LD_INT 2
17208: PUSH
17209: FOR_TO
17210: IFFALSE 17307
// begin uc_side := your_side ;
17212: LD_ADDR_OWVAR 20
17216: PUSH
17217: LD_OWVAR 2
17221: ST_TO_ADDR
// uc_nation := nation_american ;
17222: LD_ADDR_OWVAR 21
17226: PUSH
17227: LD_INT 1
17229: ST_TO_ADDR
// vc_chassis := us_morphling ;
17230: LD_ADDR_OWVAR 37
17234: PUSH
17235: LD_INT 5
17237: ST_TO_ADDR
// vc_engine := engine_siberite ;
17238: LD_ADDR_OWVAR 39
17242: PUSH
17243: LD_INT 3
17245: ST_TO_ADDR
// vc_control := control_computer ;
17246: LD_ADDR_OWVAR 38
17250: PUSH
17251: LD_INT 3
17253: ST_TO_ADDR
// vc_weapon := us_double_laser ;
17254: LD_ADDR_OWVAR 40
17258: PUSH
17259: LD_INT 10
17261: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
17262: CALL_OW 45
17266: PPUSH
17267: LD_VAR 0 2
17271: PUSH
17272: LD_INT 1
17274: ARRAY
17275: PPUSH
17276: CALL_OW 250
17280: PPUSH
17281: LD_VAR 0 2
17285: PUSH
17286: LD_INT 1
17288: ARRAY
17289: PPUSH
17290: CALL_OW 251
17294: PPUSH
17295: LD_INT 12
17297: PPUSH
17298: LD_INT 1
17300: PPUSH
17301: CALL_OW 50
// end ;
17305: GO 17209
17307: POP
17308: POP
// end ;
17309: PPOPN 2
17311: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
17312: LD_EXP 34
17316: PUSH
17317: LD_EXP 80
17321: AND
17322: IFFALSE 17544
17324: GO 17326
17326: DISABLE
17327: LD_INT 0
17329: PPUSH
17330: PPUSH
17331: PPUSH
17332: PPUSH
17333: PPUSH
17334: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
17335: LD_ADDR_VAR 0 6
17339: PUSH
17340: LD_INT 22
17342: PUSH
17343: LD_OWVAR 2
17347: PUSH
17348: EMPTY
17349: LIST
17350: LIST
17351: PUSH
17352: LD_INT 21
17354: PUSH
17355: LD_INT 1
17357: PUSH
17358: EMPTY
17359: LIST
17360: LIST
17361: PUSH
17362: LD_INT 3
17364: PUSH
17365: LD_INT 23
17367: PUSH
17368: LD_INT 0
17370: PUSH
17371: EMPTY
17372: LIST
17373: LIST
17374: PUSH
17375: EMPTY
17376: LIST
17377: LIST
17378: PUSH
17379: EMPTY
17380: LIST
17381: LIST
17382: LIST
17383: PPUSH
17384: CALL_OW 69
17388: ST_TO_ADDR
// if not tmp then
17389: LD_VAR 0 6
17393: NOT
17394: IFFALSE 17398
// exit ;
17396: GO 17544
// s1 := rand ( 1 , 4 ) ;
17398: LD_ADDR_VAR 0 2
17402: PUSH
17403: LD_INT 1
17405: PPUSH
17406: LD_INT 4
17408: PPUSH
17409: CALL_OW 12
17413: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
17414: LD_ADDR_VAR 0 4
17418: PUSH
17419: LD_VAR 0 6
17423: PUSH
17424: LD_INT 1
17426: ARRAY
17427: PPUSH
17428: LD_VAR 0 2
17432: PPUSH
17433: CALL_OW 259
17437: ST_TO_ADDR
// if s1 = 1 then
17438: LD_VAR 0 2
17442: PUSH
17443: LD_INT 1
17445: EQUAL
17446: IFFALSE 17466
// s2 := rand ( 2 , 4 ) else
17448: LD_ADDR_VAR 0 3
17452: PUSH
17453: LD_INT 2
17455: PPUSH
17456: LD_INT 4
17458: PPUSH
17459: CALL_OW 12
17463: ST_TO_ADDR
17464: GO 17474
// s2 := 1 ;
17466: LD_ADDR_VAR 0 3
17470: PUSH
17471: LD_INT 1
17473: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
17474: LD_ADDR_VAR 0 5
17478: PUSH
17479: LD_VAR 0 6
17483: PUSH
17484: LD_INT 1
17486: ARRAY
17487: PPUSH
17488: LD_VAR 0 3
17492: PPUSH
17493: CALL_OW 259
17497: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
17498: LD_VAR 0 6
17502: PUSH
17503: LD_INT 1
17505: ARRAY
17506: PPUSH
17507: LD_VAR 0 2
17511: PPUSH
17512: LD_VAR 0 5
17516: PPUSH
17517: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
17521: LD_VAR 0 6
17525: PUSH
17526: LD_INT 1
17528: ARRAY
17529: PPUSH
17530: LD_VAR 0 3
17534: PPUSH
17535: LD_VAR 0 4
17539: PPUSH
17540: CALL_OW 237
// end ;
17544: PPOPN 6
17546: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
17547: LD_EXP 34
17551: PUSH
17552: LD_EXP 81
17556: AND
17557: IFFALSE 17636
17559: GO 17561
17561: DISABLE
17562: LD_INT 0
17564: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
17565: LD_ADDR_VAR 0 1
17569: PUSH
17570: LD_INT 22
17572: PUSH
17573: LD_OWVAR 2
17577: PUSH
17578: EMPTY
17579: LIST
17580: LIST
17581: PUSH
17582: LD_INT 30
17584: PUSH
17585: LD_INT 3
17587: PUSH
17588: EMPTY
17589: LIST
17590: LIST
17591: PUSH
17592: EMPTY
17593: LIST
17594: LIST
17595: PPUSH
17596: CALL_OW 69
17600: ST_TO_ADDR
// if not tmp then
17601: LD_VAR 0 1
17605: NOT
17606: IFFALSE 17610
// exit ;
17608: GO 17636
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
17610: LD_VAR 0 1
17614: PUSH
17615: LD_INT 1
17617: PPUSH
17618: LD_VAR 0 1
17622: PPUSH
17623: CALL_OW 12
17627: ARRAY
17628: PPUSH
17629: LD_INT 1
17631: PPUSH
17632: CALL_OW 234
// end ;
17636: PPOPN 1
17638: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
17639: LD_EXP 34
17643: PUSH
17644: LD_EXP 82
17648: AND
17649: IFFALSE 17761
17651: GO 17653
17653: DISABLE
17654: LD_INT 0
17656: PPUSH
17657: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
17658: LD_ADDR_VAR 0 2
17662: PUSH
17663: LD_INT 22
17665: PUSH
17666: LD_OWVAR 2
17670: PUSH
17671: EMPTY
17672: LIST
17673: LIST
17674: PUSH
17675: LD_INT 2
17677: PUSH
17678: LD_INT 30
17680: PUSH
17681: LD_INT 27
17683: PUSH
17684: EMPTY
17685: LIST
17686: LIST
17687: PUSH
17688: LD_INT 30
17690: PUSH
17691: LD_INT 26
17693: PUSH
17694: EMPTY
17695: LIST
17696: LIST
17697: PUSH
17698: LD_INT 30
17700: PUSH
17701: LD_INT 28
17703: PUSH
17704: EMPTY
17705: LIST
17706: LIST
17707: PUSH
17708: EMPTY
17709: LIST
17710: LIST
17711: LIST
17712: LIST
17713: PUSH
17714: EMPTY
17715: LIST
17716: LIST
17717: PPUSH
17718: CALL_OW 69
17722: ST_TO_ADDR
// if not tmp then
17723: LD_VAR 0 2
17727: NOT
17728: IFFALSE 17732
// exit ;
17730: GO 17761
// for i in tmp do
17732: LD_ADDR_VAR 0 1
17736: PUSH
17737: LD_VAR 0 2
17741: PUSH
17742: FOR_IN
17743: IFFALSE 17759
// SetLives ( i , 1 ) ;
17745: LD_VAR 0 1
17749: PPUSH
17750: LD_INT 1
17752: PPUSH
17753: CALL_OW 234
17757: GO 17742
17759: POP
17760: POP
// end ;
17761: PPOPN 2
17763: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
17764: LD_EXP 34
17768: PUSH
17769: LD_EXP 83
17773: AND
17774: IFFALSE 18048
17776: GO 17778
17778: DISABLE
17779: LD_INT 0
17781: PPUSH
17782: PPUSH
17783: PPUSH
// begin i := rand ( 1 , 7 ) ;
17784: LD_ADDR_VAR 0 1
17788: PUSH
17789: LD_INT 1
17791: PPUSH
17792: LD_INT 7
17794: PPUSH
17795: CALL_OW 12
17799: ST_TO_ADDR
// case i of 1 :
17800: LD_VAR 0 1
17804: PUSH
17805: LD_INT 1
17807: DOUBLE
17808: EQUAL
17809: IFTRUE 17813
17811: GO 17823
17813: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
17814: LD_STRING earthquake(getX(game), 0, 32)
17816: PPUSH
17817: CALL_OW 559
17821: GO 18048
17823: LD_INT 2
17825: DOUBLE
17826: EQUAL
17827: IFTRUE 17831
17829: GO 17845
17831: POP
// begin ToLua ( displayStucuk(); ) ;
17832: LD_STRING displayStucuk();
17834: PPUSH
17835: CALL_OW 559
// ResetFog ;
17839: CALL_OW 335
// end ; 3 :
17843: GO 18048
17845: LD_INT 3
17847: DOUBLE
17848: EQUAL
17849: IFTRUE 17853
17851: GO 17957
17853: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
17854: LD_ADDR_VAR 0 2
17858: PUSH
17859: LD_INT 22
17861: PUSH
17862: LD_OWVAR 2
17866: PUSH
17867: EMPTY
17868: LIST
17869: LIST
17870: PUSH
17871: LD_INT 25
17873: PUSH
17874: LD_INT 1
17876: PUSH
17877: EMPTY
17878: LIST
17879: LIST
17880: PUSH
17881: EMPTY
17882: LIST
17883: LIST
17884: PPUSH
17885: CALL_OW 69
17889: ST_TO_ADDR
// if not tmp then
17890: LD_VAR 0 2
17894: NOT
17895: IFFALSE 17899
// exit ;
17897: GO 18048
// un := tmp [ rand ( 1 , tmp ) ] ;
17899: LD_ADDR_VAR 0 3
17903: PUSH
17904: LD_VAR 0 2
17908: PUSH
17909: LD_INT 1
17911: PPUSH
17912: LD_VAR 0 2
17916: PPUSH
17917: CALL_OW 12
17921: ARRAY
17922: ST_TO_ADDR
// if Crawls ( un ) then
17923: LD_VAR 0 3
17927: PPUSH
17928: CALL_OW 318
17932: IFFALSE 17943
// ComWalk ( un ) ;
17934: LD_VAR 0 3
17938: PPUSH
17939: CALL_OW 138
// SetClass ( un , class_mortar ) ;
17943: LD_VAR 0 3
17947: PPUSH
17948: LD_INT 8
17950: PPUSH
17951: CALL_OW 336
// end ; 4 :
17955: GO 18048
17957: LD_INT 4
17959: DOUBLE
17960: EQUAL
17961: IFTRUE 17965
17963: GO 18026
17965: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
17966: LD_ADDR_VAR 0 2
17970: PUSH
17971: LD_INT 22
17973: PUSH
17974: LD_OWVAR 2
17978: PUSH
17979: EMPTY
17980: LIST
17981: LIST
17982: PUSH
17983: LD_INT 30
17985: PUSH
17986: LD_INT 29
17988: PUSH
17989: EMPTY
17990: LIST
17991: LIST
17992: PUSH
17993: EMPTY
17994: LIST
17995: LIST
17996: PPUSH
17997: CALL_OW 69
18001: ST_TO_ADDR
// if not tmp then
18002: LD_VAR 0 2
18006: NOT
18007: IFFALSE 18011
// exit ;
18009: GO 18048
// DestroyUnit ( tmp [ 1 ] ) ;
18011: LD_VAR 0 2
18015: PUSH
18016: LD_INT 1
18018: ARRAY
18019: PPUSH
18020: CALL_OW 65
// end ; 5 .. 7 :
18024: GO 18048
18026: LD_INT 5
18028: DOUBLE
18029: GREATEREQUAL
18030: IFFALSE 18038
18032: LD_INT 7
18034: DOUBLE
18035: LESSEQUAL
18036: IFTRUE 18040
18038: GO 18047
18040: POP
// StreamSibBomb ; end ;
18041: CALL 14328 0 0
18045: GO 18048
18047: POP
// end ;
18048: PPOPN 3
18050: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
18051: LD_EXP 34
18055: PUSH
18056: LD_EXP 84
18060: AND
18061: IFFALSE 18217
18063: GO 18065
18065: DISABLE
18066: LD_INT 0
18068: PPUSH
18069: PPUSH
18070: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
18071: LD_ADDR_VAR 0 2
18075: PUSH
18076: LD_INT 81
18078: PUSH
18079: LD_OWVAR 2
18083: PUSH
18084: EMPTY
18085: LIST
18086: LIST
18087: PUSH
18088: LD_INT 2
18090: PUSH
18091: LD_INT 21
18093: PUSH
18094: LD_INT 1
18096: PUSH
18097: EMPTY
18098: LIST
18099: LIST
18100: PUSH
18101: LD_INT 21
18103: PUSH
18104: LD_INT 2
18106: PUSH
18107: EMPTY
18108: LIST
18109: LIST
18110: PUSH
18111: EMPTY
18112: LIST
18113: LIST
18114: LIST
18115: PUSH
18116: EMPTY
18117: LIST
18118: LIST
18119: PPUSH
18120: CALL_OW 69
18124: ST_TO_ADDR
// if not tmp then
18125: LD_VAR 0 2
18129: NOT
18130: IFFALSE 18134
// exit ;
18132: GO 18217
// p := 0 ;
18134: LD_ADDR_VAR 0 3
18138: PUSH
18139: LD_INT 0
18141: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18142: LD_INT 35
18144: PPUSH
18145: CALL_OW 67
// p := p + 1 ;
18149: LD_ADDR_VAR 0 3
18153: PUSH
18154: LD_VAR 0 3
18158: PUSH
18159: LD_INT 1
18161: PLUS
18162: ST_TO_ADDR
// for i in tmp do
18163: LD_ADDR_VAR 0 1
18167: PUSH
18168: LD_VAR 0 2
18172: PUSH
18173: FOR_IN
18174: IFFALSE 18205
// if GetLives ( i ) < 1000 then
18176: LD_VAR 0 1
18180: PPUSH
18181: CALL_OW 256
18185: PUSH
18186: LD_INT 1000
18188: LESS
18189: IFFALSE 18203
// SetLives ( i , 1000 ) ;
18191: LD_VAR 0 1
18195: PPUSH
18196: LD_INT 1000
18198: PPUSH
18199: CALL_OW 234
18203: GO 18173
18205: POP
18206: POP
// until p > 20 ;
18207: LD_VAR 0 3
18211: PUSH
18212: LD_INT 20
18214: GREATER
18215: IFFALSE 18142
// end ;
18217: PPOPN 3
18219: END
// every 0 0$1 trigger StreamModeActive and sTime do
18220: LD_EXP 34
18224: PUSH
18225: LD_EXP 85
18229: AND
18230: IFFALSE 18265
18232: GO 18234
18234: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
18235: LD_INT 28
18237: PPUSH
18238: LD_OWVAR 2
18242: PPUSH
18243: LD_INT 2
18245: PPUSH
18246: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
18250: LD_INT 30
18252: PPUSH
18253: LD_OWVAR 2
18257: PPUSH
18258: LD_INT 2
18260: PPUSH
18261: CALL_OW 322
// end ;
18265: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
18266: LD_EXP 34
18270: PUSH
18271: LD_EXP 86
18275: AND
18276: IFFALSE 18397
18278: GO 18280
18280: DISABLE
18281: LD_INT 0
18283: PPUSH
18284: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
18285: LD_ADDR_VAR 0 2
18289: PUSH
18290: LD_INT 22
18292: PUSH
18293: LD_OWVAR 2
18297: PUSH
18298: EMPTY
18299: LIST
18300: LIST
18301: PUSH
18302: LD_INT 21
18304: PUSH
18305: LD_INT 1
18307: PUSH
18308: EMPTY
18309: LIST
18310: LIST
18311: PUSH
18312: LD_INT 3
18314: PUSH
18315: LD_INT 23
18317: PUSH
18318: LD_INT 0
18320: PUSH
18321: EMPTY
18322: LIST
18323: LIST
18324: PUSH
18325: EMPTY
18326: LIST
18327: LIST
18328: PUSH
18329: EMPTY
18330: LIST
18331: LIST
18332: LIST
18333: PPUSH
18334: CALL_OW 69
18338: ST_TO_ADDR
// if not tmp then
18339: LD_VAR 0 2
18343: NOT
18344: IFFALSE 18348
// exit ;
18346: GO 18397
// for i in tmp do
18348: LD_ADDR_VAR 0 1
18352: PUSH
18353: LD_VAR 0 2
18357: PUSH
18358: FOR_IN
18359: IFFALSE 18395
// begin if Crawls ( i ) then
18361: LD_VAR 0 1
18365: PPUSH
18366: CALL_OW 318
18370: IFFALSE 18381
// ComWalk ( i ) ;
18372: LD_VAR 0 1
18376: PPUSH
18377: CALL_OW 138
// SetClass ( i , 2 ) ;
18381: LD_VAR 0 1
18385: PPUSH
18386: LD_INT 2
18388: PPUSH
18389: CALL_OW 336
// end ;
18393: GO 18358
18395: POP
18396: POP
// end ;
18397: PPOPN 2
18399: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
18400: LD_EXP 34
18404: PUSH
18405: LD_EXP 87
18409: AND
18410: IFFALSE 18631
18412: GO 18414
18414: DISABLE
18415: LD_INT 0
18417: PPUSH
18418: PPUSH
18419: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
18420: LD_OWVAR 2
18424: PPUSH
18425: LD_INT 9
18427: PPUSH
18428: LD_INT 1
18430: PPUSH
18431: LD_INT 1
18433: PPUSH
18434: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
18438: LD_INT 9
18440: PPUSH
18441: LD_OWVAR 2
18445: PPUSH
18446: CALL_OW 343
// uc_side := 9 ;
18450: LD_ADDR_OWVAR 20
18454: PUSH
18455: LD_INT 9
18457: ST_TO_ADDR
// uc_nation := 2 ;
18458: LD_ADDR_OWVAR 21
18462: PUSH
18463: LD_INT 2
18465: ST_TO_ADDR
// hc_name := Dark Warrior ;
18466: LD_ADDR_OWVAR 26
18470: PUSH
18471: LD_STRING Dark Warrior
18473: ST_TO_ADDR
// hc_gallery :=  ;
18474: LD_ADDR_OWVAR 33
18478: PUSH
18479: LD_STRING 
18481: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 10 ) ;
18482: LD_INT 1
18484: PPUSH
18485: LD_INT 1
18487: PPUSH
18488: LD_INT 10
18490: PPUSH
18491: CALL_OW 380
// un := CreateHuman ;
18495: LD_ADDR_VAR 0 3
18499: PUSH
18500: CALL_OW 44
18504: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
18505: LD_VAR 0 3
18509: PPUSH
18510: LD_INT 1
18512: PPUSH
18513: CALL_OW 51
// p := 0 ;
18517: LD_ADDR_VAR 0 2
18521: PUSH
18522: LD_INT 0
18524: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18525: LD_INT 35
18527: PPUSH
18528: CALL_OW 67
// if GetLives ( un ) < 1000 then
18532: LD_VAR 0 3
18536: PPUSH
18537: CALL_OW 256
18541: PUSH
18542: LD_INT 1000
18544: LESS
18545: IFFALSE 18559
// SetLives ( un , 1000 ) ;
18547: LD_VAR 0 3
18551: PPUSH
18552: LD_INT 1000
18554: PPUSH
18555: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , your_side ] ) , un ) ) ;
18559: LD_VAR 0 3
18563: PPUSH
18564: LD_INT 81
18566: PUSH
18567: LD_OWVAR 2
18571: PUSH
18572: EMPTY
18573: LIST
18574: LIST
18575: PPUSH
18576: CALL_OW 69
18580: PPUSH
18581: LD_VAR 0 3
18585: PPUSH
18586: CALL_OW 74
18590: PPUSH
18591: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
18595: LD_VAR 0 2
18599: PUSH
18600: LD_INT 60
18602: GREATER
18603: PUSH
18604: LD_VAR 0 3
18608: PPUSH
18609: CALL_OW 301
18613: OR
18614: IFFALSE 18525
// if un then
18616: LD_VAR 0 3
18620: IFFALSE 18631
// RemoveUnit ( un ) ;
18622: LD_VAR 0 3
18626: PPUSH
18627: CALL_OW 64
// end ; end_of_file
18631: PPOPN 3
18633: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
18634: LD_INT 0
18636: PPUSH
18637: PPUSH
18638: PPUSH
18639: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
18640: LD_VAR 0 1
18644: PPUSH
18645: CALL_OW 264
18649: PUSH
18650: LD_EXP 33
18654: EQUAL
18655: IFFALSE 18727
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
18657: LD_INT 68
18659: PPUSH
18660: LD_VAR 0 1
18664: PPUSH
18665: CALL_OW 255
18669: PPUSH
18670: CALL_OW 321
18674: PUSH
18675: LD_INT 2
18677: EQUAL
18678: IFFALSE 18690
// eff := 70 else
18680: LD_ADDR_VAR 0 6
18684: PUSH
18685: LD_INT 70
18687: ST_TO_ADDR
18688: GO 18698
// eff := 30 ;
18690: LD_ADDR_VAR 0 6
18694: PUSH
18695: LD_INT 30
18697: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
18698: LD_VAR 0 1
18702: PPUSH
18703: CALL_OW 250
18707: PPUSH
18708: LD_VAR 0 1
18712: PPUSH
18713: CALL_OW 251
18717: PPUSH
18718: LD_VAR 0 6
18722: PPUSH
18723: CALL_OW 495
// end ; end ;
18727: LD_VAR 0 4
18731: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
18732: LD_INT 0
18734: PPUSH
18735: PPUSH
18736: PPUSH
18737: PPUSH
18738: PPUSH
18739: PPUSH
// if cmd = 124 then
18740: LD_VAR 0 1
18744: PUSH
18745: LD_INT 124
18747: EQUAL
18748: IFFALSE 18954
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
18750: LD_ADDR_VAR 0 5
18754: PUSH
18755: LD_INT 2
18757: PUSH
18758: LD_INT 34
18760: PUSH
18761: LD_INT 53
18763: PUSH
18764: EMPTY
18765: LIST
18766: LIST
18767: PUSH
18768: LD_INT 34
18770: PUSH
18771: LD_INT 14
18773: PUSH
18774: EMPTY
18775: LIST
18776: LIST
18777: PUSH
18778: EMPTY
18779: LIST
18780: LIST
18781: LIST
18782: PPUSH
18783: CALL_OW 69
18787: ST_TO_ADDR
// if not tmp then
18788: LD_VAR 0 5
18792: NOT
18793: IFFALSE 18797
// exit ;
18795: GO 18954
// for i in tmp do
18797: LD_ADDR_VAR 0 3
18801: PUSH
18802: LD_VAR 0 5
18806: PUSH
18807: FOR_IN
18808: IFFALSE 18952
// begin taskList := GetTaskList ( i ) ;
18810: LD_ADDR_VAR 0 6
18814: PUSH
18815: LD_VAR 0 3
18819: PPUSH
18820: CALL_OW 437
18824: ST_TO_ADDR
// if not taskList then
18825: LD_VAR 0 6
18829: NOT
18830: IFFALSE 18834
// continue ;
18832: GO 18807
// for j = 1 to taskList do
18834: LD_ADDR_VAR 0 4
18838: PUSH
18839: DOUBLE
18840: LD_INT 1
18842: DEC
18843: ST_TO_ADDR
18844: LD_VAR 0 6
18848: PUSH
18849: FOR_TO
18850: IFFALSE 18948
// if taskList [ j ] [ 1 ] = | then
18852: LD_VAR 0 6
18856: PUSH
18857: LD_VAR 0 4
18861: ARRAY
18862: PUSH
18863: LD_INT 1
18865: ARRAY
18866: PUSH
18867: LD_STRING |
18869: EQUAL
18870: IFFALSE 18946
// begin _taskList := Delete ( taskList , 1 ) ;
18872: LD_ADDR_VAR 0 7
18876: PUSH
18877: LD_VAR 0 6
18881: PPUSH
18882: LD_INT 1
18884: PPUSH
18885: CALL_OW 3
18889: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
18890: LD_VAR 0 3
18894: PPUSH
18895: LD_VAR 0 7
18899: PPUSH
18900: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
18904: LD_VAR 0 3
18908: PPUSH
18909: LD_VAR 0 6
18913: PUSH
18914: LD_VAR 0 4
18918: ARRAY
18919: PUSH
18920: LD_INT 2
18922: ARRAY
18923: PPUSH
18924: LD_VAR 0 6
18928: PUSH
18929: LD_VAR 0 4
18933: ARRAY
18934: PUSH
18935: LD_INT 3
18937: ARRAY
18938: PPUSH
18939: LD_INT 8
18941: PPUSH
18942: CALL 18959 0 4
// end ;
18946: GO 18849
18948: POP
18949: POP
// end ;
18950: GO 18807
18952: POP
18953: POP
// end ; end ;
18954: LD_VAR 0 2
18958: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
18959: LD_INT 0
18961: PPUSH
18962: PPUSH
18963: PPUSH
18964: PPUSH
18965: PPUSH
18966: PPUSH
18967: PPUSH
18968: PPUSH
18969: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
18970: LD_VAR 0 1
18974: NOT
18975: PUSH
18976: LD_VAR 0 2
18980: PPUSH
18981: LD_VAR 0 3
18985: PPUSH
18986: CALL_OW 488
18990: NOT
18991: OR
18992: PUSH
18993: LD_VAR 0 4
18997: NOT
18998: OR
18999: IFFALSE 19003
// exit ;
19001: GO 19343
// list := [ ] ;
19003: LD_ADDR_VAR 0 13
19007: PUSH
19008: EMPTY
19009: ST_TO_ADDR
// if x - r < 0 then
19010: LD_VAR 0 2
19014: PUSH
19015: LD_VAR 0 4
19019: MINUS
19020: PUSH
19021: LD_INT 0
19023: LESS
19024: IFFALSE 19036
// min_x := 0 else
19026: LD_ADDR_VAR 0 7
19030: PUSH
19031: LD_INT 0
19033: ST_TO_ADDR
19034: GO 19052
// min_x := x - r ;
19036: LD_ADDR_VAR 0 7
19040: PUSH
19041: LD_VAR 0 2
19045: PUSH
19046: LD_VAR 0 4
19050: MINUS
19051: ST_TO_ADDR
// if y - r < 0 then
19052: LD_VAR 0 3
19056: PUSH
19057: LD_VAR 0 4
19061: MINUS
19062: PUSH
19063: LD_INT 0
19065: LESS
19066: IFFALSE 19078
// min_y := 0 else
19068: LD_ADDR_VAR 0 8
19072: PUSH
19073: LD_INT 0
19075: ST_TO_ADDR
19076: GO 19094
// min_y := y - r ;
19078: LD_ADDR_VAR 0 8
19082: PUSH
19083: LD_VAR 0 3
19087: PUSH
19088: LD_VAR 0 4
19092: MINUS
19093: ST_TO_ADDR
// max_x := x + r ;
19094: LD_ADDR_VAR 0 9
19098: PUSH
19099: LD_VAR 0 2
19103: PUSH
19104: LD_VAR 0 4
19108: PLUS
19109: ST_TO_ADDR
// max_y := y + r ;
19110: LD_ADDR_VAR 0 10
19114: PUSH
19115: LD_VAR 0 3
19119: PUSH
19120: LD_VAR 0 4
19124: PLUS
19125: ST_TO_ADDR
// for _x = min_x to max_x do
19126: LD_ADDR_VAR 0 11
19130: PUSH
19131: DOUBLE
19132: LD_VAR 0 7
19136: DEC
19137: ST_TO_ADDR
19138: LD_VAR 0 9
19142: PUSH
19143: FOR_TO
19144: IFFALSE 19261
// for _y = min_y to max_y do
19146: LD_ADDR_VAR 0 12
19150: PUSH
19151: DOUBLE
19152: LD_VAR 0 8
19156: DEC
19157: ST_TO_ADDR
19158: LD_VAR 0 10
19162: PUSH
19163: FOR_TO
19164: IFFALSE 19257
// begin if not ValidHex ( _x , _y ) then
19166: LD_VAR 0 11
19170: PPUSH
19171: LD_VAR 0 12
19175: PPUSH
19176: CALL_OW 488
19180: NOT
19181: IFFALSE 19185
// continue ;
19183: GO 19163
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
19185: LD_VAR 0 11
19189: PPUSH
19190: LD_VAR 0 12
19194: PPUSH
19195: CALL_OW 351
19199: PUSH
19200: LD_VAR 0 11
19204: PPUSH
19205: LD_VAR 0 12
19209: PPUSH
19210: CALL_OW 554
19214: AND
19215: IFFALSE 19255
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
19217: LD_ADDR_VAR 0 13
19221: PUSH
19222: LD_VAR 0 13
19226: PPUSH
19227: LD_VAR 0 13
19231: PUSH
19232: LD_INT 1
19234: PLUS
19235: PPUSH
19236: LD_VAR 0 11
19240: PUSH
19241: LD_VAR 0 12
19245: PUSH
19246: EMPTY
19247: LIST
19248: LIST
19249: PPUSH
19250: CALL_OW 2
19254: ST_TO_ADDR
// end ;
19255: GO 19163
19257: POP
19258: POP
19259: GO 19143
19261: POP
19262: POP
// if not list then
19263: LD_VAR 0 13
19267: NOT
19268: IFFALSE 19272
// exit ;
19270: GO 19343
// for i in list do
19272: LD_ADDR_VAR 0 6
19276: PUSH
19277: LD_VAR 0 13
19281: PUSH
19282: FOR_IN
19283: IFFALSE 19341
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
19285: LD_VAR 0 1
19289: PPUSH
19290: LD_STRING M
19292: PUSH
19293: LD_VAR 0 6
19297: PUSH
19298: LD_INT 1
19300: ARRAY
19301: PUSH
19302: LD_VAR 0 6
19306: PUSH
19307: LD_INT 2
19309: ARRAY
19310: PUSH
19311: LD_INT 0
19313: PUSH
19314: LD_INT 0
19316: PUSH
19317: LD_INT 0
19319: PUSH
19320: LD_INT 0
19322: PUSH
19323: EMPTY
19324: LIST
19325: LIST
19326: LIST
19327: LIST
19328: LIST
19329: LIST
19330: LIST
19331: PUSH
19332: EMPTY
19333: LIST
19334: PPUSH
19335: CALL_OW 447
19339: GO 19282
19341: POP
19342: POP
// end ;
19343: LD_VAR 0 5
19347: RET
