// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// Init ;
  15: CALL 79 0 0
// InitRestrictions ;
  19: CALL 207 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 33
// DebugMode ;
  29: CALL 288 0 0
// SpawnApeman ( apemanStartArea , 2 ) ;
  33: LD_INT 12
  35: PPUSH
  36: LD_INT 2
  38: PPUSH
  39: CALL 658 0 2
// SpawnApeman ( apemanArea , [ 10 , 8 , 7 ] [ Difficulty ] ) ;
  43: LD_INT 11
  45: PPUSH
  46: LD_INT 10
  48: PUSH
  49: LD_INT 8
  51: PUSH
  52: LD_INT 7
  54: PUSH
  55: EMPTY
  56: LIST
  57: LIST
  58: LIST
  59: PUSH
  60: LD_OWVAR 67
  64: ARRAY
  65: PPUSH
  66: CALL 658 0 2
// PrepareAmericans ;
  70: CALL 1257 0 0
// Action ;
  74: CALL 2147 0 0
// end ;
  78: END
// export debug ; export mission_prefix , mission_prefix_prev ; export deltaBuilded , denisArrives , Delta , radar_allowed , first_apeman_tamed , apeman_army , radar_researched , radar_builded ; export apeman_counter , arab_spotted , end_mission , apeKillCounter ; function Init ; begin
  79: LD_INT 0
  81: PPUSH
// debug := false ;
  82: LD_ADDR_EXP 1
  86: PUSH
  87: LD_INT 0
  89: ST_TO_ADDR
// mission_prefix := 05_ ;
  90: LD_ADDR_EXP 2
  94: PUSH
  95: LD_STRING 05_
  97: ST_TO_ADDR
// mission_prefix_prev := 05a_ ;
  98: LD_ADDR_EXP 3
 102: PUSH
 103: LD_STRING 05a_
 105: ST_TO_ADDR
// deltaBuilded := false ;
 106: LD_ADDR_EXP 4
 110: PUSH
 111: LD_INT 0
 113: ST_TO_ADDR
// denisArrives := false ;
 114: LD_ADDR_EXP 5
 118: PUSH
 119: LD_INT 0
 121: ST_TO_ADDR
// radar_allowed := false ;
 122: LD_ADDR_EXP 7
 126: PUSH
 127: LD_INT 0
 129: ST_TO_ADDR
// first_apeman_tamed := false ;
 130: LD_ADDR_EXP 8
 134: PUSH
 135: LD_INT 0
 137: ST_TO_ADDR
// arab_spotted := false ;
 138: LD_ADDR_EXP 13
 142: PUSH
 143: LD_INT 0
 145: ST_TO_ADDR
// end_mission := false ;
 146: LD_ADDR_EXP 14
 150: PUSH
 151: LD_INT 0
 153: ST_TO_ADDR
// apeman_army := false ;
 154: LD_ADDR_EXP 9
 158: PUSH
 159: LD_INT 0
 161: ST_TO_ADDR
// radar_researched := false ;
 162: LD_ADDR_EXP 10
 166: PUSH
 167: LD_INT 0
 169: ST_TO_ADDR
// radar_builded := false ;
 170: LD_ADDR_EXP 11
 174: PUSH
 175: LD_INT 0
 177: ST_TO_ADDR
// apeman_counter := 0 ;
 178: LD_ADDR_EXP 12
 182: PUSH
 183: LD_INT 0
 185: ST_TO_ADDR
// Delta := 0 ;
 186: LD_ADDR_EXP 6
 190: PUSH
 191: LD_INT 0
 193: ST_TO_ADDR
// apeKillCounter := 0 ;
 194: LD_ADDR_EXP 15
 198: PUSH
 199: LD_INT 0
 201: ST_TO_ADDR
// end ;
 202: LD_VAR 0 1
 206: RET
// function InitRestrictions ; begin
 207: LD_INT 0
 209: PPUSH
// SetRestrict ( b_lab_half , 1 , state_enabled ) ;
 210: LD_INT 7
 212: PPUSH
 213: LD_INT 1
 215: PPUSH
 216: LD_INT 1
 218: PPUSH
 219: CALL_OW 324
// SetRestrict ( b_lab_full , 1 , state_enabled ) ;
 223: LD_INT 8
 225: PPUSH
 226: LD_INT 1
 228: PPUSH
 229: LD_INT 1
 231: PPUSH
 232: CALL_OW 324
// SetRestrict ( b_lab_weapon , 1 , state_enabled ) ;
 236: LD_INT 10
 238: PPUSH
 239: LD_INT 1
 241: PPUSH
 242: LD_INT 1
 244: PPUSH
 245: CALL_OW 324
// SetTech ( tech_gatling , 1 , LoadVariable ( GatlingInGamma , 1 ) ) ;
 249: LD_INT 69
 251: PPUSH
 252: LD_INT 1
 254: PPUSH
 255: LD_STRING GatlingInGamma
 257: PPUSH
 258: LD_INT 1
 260: PPUSH
 261: CALL_OW 30
 265: PPUSH
 266: CALL_OW 322
// SetTech ( tech_weap1 , 1 , state_enabled ) ;
 270: LD_INT 51
 272: PPUSH
 273: LD_INT 1
 275: PPUSH
 276: LD_INT 1
 278: PPUSH
 279: CALL_OW 322
// end ;
 283: LD_VAR 0 1
 287: RET
// function DebugMode ; begin
 288: LD_INT 0
 290: PPUSH
// FogOff ( 1 ) ;
 291: LD_INT 1
 293: PPUSH
 294: CALL_OW 344
// Difficulty := 2 ;
 298: LD_ADDR_OWVAR 67
 302: PUSH
 303: LD_INT 2
 305: ST_TO_ADDR
// end ;
 306: LD_VAR 0 1
 310: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 0 ] ] ) >= 7 do
 311: LD_INT 22
 313: PUSH
 314: LD_INT 1
 316: PUSH
 317: EMPTY
 318: LIST
 319: LIST
 320: PUSH
 321: LD_INT 23
 323: PUSH
 324: LD_INT 0
 326: PUSH
 327: EMPTY
 328: LIST
 329: LIST
 330: PUSH
 331: EMPTY
 332: LIST
 333: LIST
 334: PPUSH
 335: CALL_OW 69
 339: PUSH
 340: LD_INT 7
 342: GREATEREQUAL
 343: IFFALSE 355
 345: GO 347
 347: DISABLE
// SetAchievement ( ACH_TAME ) ;
 348: LD_STRING ACH_TAME
 350: PPUSH
 351: CALL_OW 543
 355: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_bweapon , us_radar ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) do
 356: LD_INT 22
 358: PUSH
 359: LD_INT 1
 361: PUSH
 362: EMPTY
 363: LIST
 364: LIST
 365: PUSH
 366: LD_INT 35
 368: PUSH
 369: LD_INT 11
 371: PUSH
 372: EMPTY
 373: LIST
 374: LIST
 375: PUSH
 376: EMPTY
 377: LIST
 378: LIST
 379: PPUSH
 380: CALL_OW 69
 384: PUSH
 385: LD_INT 22
 387: PUSH
 388: LD_INT 1
 390: PUSH
 391: EMPTY
 392: LIST
 393: LIST
 394: PUSH
 395: LD_INT 34
 397: PUSH
 398: LD_INT 11
 400: PUSH
 401: EMPTY
 402: LIST
 403: LIST
 404: PUSH
 405: EMPTY
 406: LIST
 407: LIST
 408: PPUSH
 409: CALL_OW 69
 413: AND
 414: IFFALSE 426
 416: GO 418
 418: DISABLE
// SetAchievement ( ACH_RADAR ) ; end_of_file
 419: LD_STRING ACH_RADAR
 421: PPUSH
 422: CALL_OW 543
 426: END
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 427: LD_INT 0
 429: PPUSH
 430: PPUSH
// if exist_mode then
 431: LD_VAR 0 2
 435: IFFALSE 460
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 437: LD_ADDR_VAR 0 4
 441: PUSH
 442: LD_EXP 3
 446: PUSH
 447: LD_VAR 0 1
 451: STR
 452: PPUSH
 453: CALL_OW 34
 457: ST_TO_ADDR
 458: GO 475
// unit := NewCharacter ( ident ) ;
 460: LD_ADDR_VAR 0 4
 464: PUSH
 465: LD_VAR 0 1
 469: PPUSH
 470: CALL_OW 25
 474: ST_TO_ADDR
// result := unit ;
 475: LD_ADDR_VAR 0 3
 479: PUSH
 480: LD_VAR 0 4
 484: ST_TO_ADDR
// end ;
 485: LD_VAR 0 3
 489: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 490: LD_INT 0
 492: PPUSH
// uc_side := side ;
 493: LD_ADDR_OWVAR 20
 497: PUSH
 498: LD_VAR 0 1
 502: ST_TO_ADDR
// uc_nation := nation ;
 503: LD_ADDR_OWVAR 21
 507: PUSH
 508: LD_VAR 0 2
 512: ST_TO_ADDR
// vc_chassis := chassis ;
 513: LD_ADDR_OWVAR 37
 517: PUSH
 518: LD_VAR 0 3
 522: ST_TO_ADDR
// vc_engine := engine ;
 523: LD_ADDR_OWVAR 39
 527: PUSH
 528: LD_VAR 0 4
 532: ST_TO_ADDR
// vc_control := control ;
 533: LD_ADDR_OWVAR 38
 537: PUSH
 538: LD_VAR 0 5
 542: ST_TO_ADDR
// vc_weapon := weapon ;
 543: LD_ADDR_OWVAR 40
 547: PUSH
 548: LD_VAR 0 6
 552: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 553: LD_ADDR_OWVAR 41
 557: PUSH
 558: LD_VAR 0 7
 562: ST_TO_ADDR
// result := CreateVehicle ;
 563: LD_ADDR_VAR 0 8
 567: PUSH
 568: CALL_OW 45
 572: ST_TO_ADDR
// end ;
 573: LD_VAR 0 8
 577: RET
// export function SayX ( units , ident ) ; var i ; begin
 578: LD_INT 0
 580: PPUSH
 581: PPUSH
// result := false ;
 582: LD_ADDR_VAR 0 3
 586: PUSH
 587: LD_INT 0
 589: ST_TO_ADDR
// if not units then
 590: LD_VAR 0 1
 594: NOT
 595: IFFALSE 599
// exit ;
 597: GO 653
// for i in units do
 599: LD_ADDR_VAR 0 4
 603: PUSH
 604: LD_VAR 0 1
 608: PUSH
 609: FOR_IN
 610: IFFALSE 651
// if IsOk ( i ) then
 612: LD_VAR 0 4
 616: PPUSH
 617: CALL_OW 302
 621: IFFALSE 649
// begin Say ( i , ident ) ;
 623: LD_VAR 0 4
 627: PPUSH
 628: LD_VAR 0 2
 632: PPUSH
 633: CALL_OW 88
// result := i ;
 637: LD_ADDR_VAR 0 3
 641: PUSH
 642: LD_VAR 0 4
 646: ST_TO_ADDR
// break ;
 647: GO 651
// end ;
 649: GO 609
 651: POP
 652: POP
// end ;
 653: LD_VAR 0 3
 657: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 658: LD_INT 0
 660: PPUSH
 661: PPUSH
// InitUc ;
 662: CALL_OW 18
// InitHc ;
 666: CALL_OW 19
// uc_side := 0 ;
 670: LD_ADDR_OWVAR 20
 674: PUSH
 675: LD_INT 0
 677: ST_TO_ADDR
// uc_nation := 0 ;
 678: LD_ADDR_OWVAR 21
 682: PUSH
 683: LD_INT 0
 685: ST_TO_ADDR
// for i = 1 to amount do
 686: LD_ADDR_VAR 0 4
 690: PUSH
 691: DOUBLE
 692: LD_INT 1
 694: DEC
 695: ST_TO_ADDR
 696: LD_VAR 0 2
 700: PUSH
 701: FOR_TO
 702: IFFALSE 784
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 704: LD_ADDR_OWVAR 29
 708: PUSH
 709: LD_INT 9
 711: PPUSH
 712: LD_INT 12
 714: PPUSH
 715: CALL_OW 12
 719: PUSH
 720: LD_INT 9
 722: PPUSH
 723: LD_INT 12
 725: PPUSH
 726: CALL_OW 12
 730: PUSH
 731: EMPTY
 732: LIST
 733: LIST
 734: ST_TO_ADDR
// hc_agressivity := rand ( - 5 , 5 ) ;
 735: LD_ADDR_OWVAR 35
 739: PUSH
 740: LD_INT 5
 742: NEG
 743: PPUSH
 744: LD_INT 5
 746: PPUSH
 747: CALL_OW 12
 751: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 752: LD_INT 0
 754: PPUSH
 755: LD_INT 12
 757: PPUSH
 758: LD_INT 1
 760: PPUSH
 761: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 765: CALL_OW 44
 769: PPUSH
 770: LD_VAR 0 1
 774: PPUSH
 775: LD_INT 0
 777: PPUSH
 778: CALL_OW 49
// end ;
 782: GO 701
 784: POP
 785: POP
// InitHc ;
 786: CALL_OW 19
// end ;
 790: LD_VAR 0 3
 794: RET
// export function Attack ( unit , enemy_list ) ; var target , targets_list ; begin
 795: LD_INT 0
 797: PPUSH
 798: PPUSH
 799: PPUSH
// if not unit then
 800: LD_VAR 0 1
 804: NOT
 805: IFFALSE 809
// exit ;
 807: GO 1252
// if IsInUnit ( unit ) then
 809: LD_VAR 0 1
 813: PPUSH
 814: CALL_OW 310
 818: IFFALSE 835
// unit := IsDrivenBy ( unit ) ;
 820: LD_ADDR_VAR 0 1
 824: PUSH
 825: LD_VAR 0 1
 829: PPUSH
 830: CALL_OW 311
 834: ST_TO_ADDR
// targets_list := [ ] ;
 835: LD_ADDR_VAR 0 5
 839: PUSH
 840: EMPTY
 841: ST_TO_ADDR
// target := UnitFilter ( enemy_list , [ [ f_lives , 250 ] , [ f_not , [ f_weapon , us_cargo_bay ] ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
 842: LD_ADDR_VAR 0 4
 846: PUSH
 847: LD_VAR 0 2
 851: PPUSH
 852: LD_INT 24
 854: PUSH
 855: LD_INT 250
 857: PUSH
 858: EMPTY
 859: LIST
 860: LIST
 861: PUSH
 862: LD_INT 3
 864: PUSH
 865: LD_INT 34
 867: PUSH
 868: LD_INT 12
 870: PUSH
 871: EMPTY
 872: LIST
 873: LIST
 874: PUSH
 875: EMPTY
 876: LIST
 877: LIST
 878: PUSH
 879: LD_INT 21
 881: PUSH
 882: LD_INT 2
 884: PUSH
 885: EMPTY
 886: LIST
 887: LIST
 888: PUSH
 889: LD_INT 58
 891: PUSH
 892: EMPTY
 893: LIST
 894: PUSH
 895: EMPTY
 896: LIST
 897: LIST
 898: LIST
 899: LIST
 900: PPUSH
 901: CALL_OW 72
 905: ST_TO_ADDR
// if GetDistUnits ( NearestUnitToUnit ( target , unit ) , unit ) < 11 and not IsInUnit ( unit ) then
 906: LD_VAR 0 4
 910: PPUSH
 911: LD_VAR 0 1
 915: PPUSH
 916: CALL_OW 74
 920: PPUSH
 921: LD_VAR 0 1
 925: PPUSH
 926: CALL_OW 296
 930: PUSH
 931: LD_INT 11
 933: LESS
 934: PUSH
 935: LD_VAR 0 1
 939: PPUSH
 940: CALL_OW 310
 944: NOT
 945: AND
 946: IFFALSE 974
// begin ComEnterUnit ( unit , NearestUnitToUnit ( target , unit ) ) ;
 948: LD_VAR 0 1
 952: PPUSH
 953: LD_VAR 0 4
 957: PPUSH
 958: LD_VAR 0 1
 962: PPUSH
 963: CALL_OW 74
 967: PPUSH
 968: CALL_OW 120
// exit ;
 972: GO 1252
// end ; targets_list := [ UnitFilter ( enemy_list , [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] ] ) , UnitFilter ( enemy_list , [ f_type , unit_vehicle ] ) , UnitFilter ( enemy_list , [ [ f_type , unit_building ] , [ f_not , [ f_empty ] ] ] ) , enemy_list ] ;
 974: LD_ADDR_VAR 0 5
 978: PUSH
 979: LD_VAR 0 2
 983: PPUSH
 984: LD_INT 21
 986: PUSH
 987: LD_INT 1
 989: PUSH
 990: EMPTY
 991: LIST
 992: LIST
 993: PUSH
 994: LD_INT 3
 996: PUSH
 997: LD_INT 54
 999: PUSH
1000: EMPTY
1001: LIST
1002: PUSH
1003: EMPTY
1004: LIST
1005: LIST
1006: PUSH
1007: EMPTY
1008: LIST
1009: LIST
1010: PPUSH
1011: CALL_OW 72
1015: PUSH
1016: LD_VAR 0 2
1020: PPUSH
1021: LD_INT 21
1023: PUSH
1024: LD_INT 2
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: PPUSH
1031: CALL_OW 72
1035: PUSH
1036: LD_VAR 0 2
1040: PPUSH
1041: LD_INT 21
1043: PUSH
1044: LD_INT 3
1046: PUSH
1047: EMPTY
1048: LIST
1049: LIST
1050: PUSH
1051: LD_INT 3
1053: PUSH
1054: LD_INT 58
1056: PUSH
1057: EMPTY
1058: LIST
1059: PUSH
1060: EMPTY
1061: LIST
1062: LIST
1063: PUSH
1064: EMPTY
1065: LIST
1066: LIST
1067: PPUSH
1068: CALL_OW 72
1072: PUSH
1073: LD_VAR 0 2
1077: PUSH
1078: EMPTY
1079: LIST
1080: LIST
1081: LIST
1082: LIST
1083: ST_TO_ADDR
// for target in targets_list do
1084: LD_ADDR_VAR 0 4
1088: PUSH
1089: LD_VAR 0 5
1093: PUSH
1094: FOR_IN
1095: IFFALSE 1250
// begin if target then
1097: LD_VAR 0 4
1101: IFFALSE 1248
// if GetTag ( unit ) = 11 and ( GetType ( NearestUnitToUnit ( target , unit ) ) = unit_building or GetWeapon ( NearestUnitToUnit ( target , unit ) ) = us_cargo_bay ) then
1103: LD_VAR 0 1
1107: PPUSH
1108: CALL_OW 110
1112: PUSH
1113: LD_INT 11
1115: EQUAL
1116: PUSH
1117: LD_VAR 0 4
1121: PPUSH
1122: LD_VAR 0 1
1126: PPUSH
1127: CALL_OW 74
1131: PPUSH
1132: CALL_OW 247
1136: PUSH
1137: LD_INT 3
1139: EQUAL
1140: PUSH
1141: LD_VAR 0 4
1145: PPUSH
1146: LD_VAR 0 1
1150: PPUSH
1151: CALL_OW 74
1155: PPUSH
1156: CALL_OW 264
1160: PUSH
1161: LD_INT 12
1163: EQUAL
1164: OR
1165: AND
1166: IFFALSE 1212
// begin ComPlaceDelayedCharge ( unit , 0 , 0 , NearestUnitToUnit ( target , unit ) ) ;
1168: LD_VAR 0 1
1172: PPUSH
1173: LD_INT 0
1175: PPUSH
1176: LD_INT 0
1178: PPUSH
1179: LD_VAR 0 4
1183: PPUSH
1184: LD_VAR 0 1
1188: PPUSH
1189: CALL_OW 74
1193: PPUSH
1194: CALL_OW 132
// SetTag ( unit , 0 ) ;
1198: LD_VAR 0 1
1202: PPUSH
1203: LD_INT 0
1205: PPUSH
1206: CALL_OW 109
// end else
1210: GO 1248
// if not HasTask ( unit ) then
1212: LD_VAR 0 1
1216: PPUSH
1217: CALL_OW 314
1221: NOT
1222: IFFALSE 1248
// ComAttackUnit ( unit , NearestUnitToUnit ( target , unit ) ) ;
1224: LD_VAR 0 1
1228: PPUSH
1229: LD_VAR 0 4
1233: PPUSH
1234: LD_VAR 0 1
1238: PPUSH
1239: CALL_OW 74
1243: PPUSH
1244: CALL_OW 115
// end ;
1248: GO 1094
1250: POP
1251: POP
// end ; end_of_file
1252: LD_VAR 0 3
1256: RET
// export JMM , Gladstone , Harrison , Denis , Brown , Donaldson , Lisa , Frank , Bobby , Cyrus ; export others ; export function PrepareAmericans ; var i , points , veh , tmp ; begin
1257: LD_INT 0
1259: PPUSH
1260: PPUSH
1261: PPUSH
1262: PPUSH
1263: PPUSH
// uc_nation := 1 ;
1264: LD_ADDR_OWVAR 21
1268: PUSH
1269: LD_INT 1
1271: ST_TO_ADDR
// uc_side := 4 ;
1272: LD_ADDR_OWVAR 20
1276: PUSH
1277: LD_INT 4
1279: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , false ) ;
1280: LD_ADDR_EXP 19
1284: PUSH
1285: LD_STRING Denis
1287: PPUSH
1288: LD_INT 0
1290: PPUSH
1291: CALL 427 0 2
1295: ST_TO_ADDR
// Harrison := PrepareUnit ( Harisson , false ) ;
1296: LD_ADDR_EXP 18
1300: PUSH
1301: LD_STRING Harisson
1303: PPUSH
1304: LD_INT 0
1306: PPUSH
1307: CALL 427 0 2
1311: ST_TO_ADDR
// uc_side := 1 ;
1312: LD_ADDR_OWVAR 20
1316: PUSH
1317: LD_INT 1
1319: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1320: LD_ADDR_EXP 16
1324: PUSH
1325: LD_STRING JMM
1327: PPUSH
1328: LD_EXP 1
1332: NOT
1333: PPUSH
1334: CALL 427 0 2
1338: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , false ) ;
1339: LD_ADDR_EXP 17
1343: PUSH
1344: LD_STRING Gladstone
1346: PPUSH
1347: LD_INT 0
1349: PPUSH
1350: CALL 427 0 2
1354: ST_TO_ADDR
// if LoadVariable ( BrownInDelta , debug ) then
1355: LD_STRING BrownInDelta
1357: PPUSH
1358: LD_EXP 1
1362: PPUSH
1363: CALL_OW 30
1367: IFFALSE 1404
// begin Brown := PrepareUnit ( Brown , ( not debug ) ) ;
1369: LD_ADDR_EXP 20
1373: PUSH
1374: LD_STRING Brown
1376: PPUSH
1377: LD_EXP 1
1381: NOT
1382: PPUSH
1383: CALL 427 0 2
1387: ST_TO_ADDR
// tmp := tmp ^ Brown ;
1388: LD_ADDR_VAR 0 5
1392: PUSH
1393: LD_VAR 0 5
1397: PUSH
1398: LD_EXP 20
1402: ADD
1403: ST_TO_ADDR
// end ; if LoadVariable ( DonaldsonInDelta , debug ) then
1404: LD_STRING DonaldsonInDelta
1406: PPUSH
1407: LD_EXP 1
1411: PPUSH
1412: CALL_OW 30
1416: IFFALSE 1453
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
1418: LD_ADDR_EXP 21
1422: PUSH
1423: LD_STRING Donaldson
1425: PPUSH
1426: LD_EXP 1
1430: NOT
1431: PPUSH
1432: CALL 427 0 2
1436: ST_TO_ADDR
// tmp := tmp ^ Donaldson ;
1437: LD_ADDR_VAR 0 5
1441: PUSH
1442: LD_VAR 0 5
1446: PUSH
1447: LD_EXP 21
1451: ADD
1452: ST_TO_ADDR
// end ; if LoadVariable ( LisaInDelta , debug ) then
1453: LD_STRING LisaInDelta
1455: PPUSH
1456: LD_EXP 1
1460: PPUSH
1461: CALL_OW 30
1465: IFFALSE 1502
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1467: LD_ADDR_EXP 22
1471: PUSH
1472: LD_STRING Lisa
1474: PPUSH
1475: LD_EXP 1
1479: NOT
1480: PPUSH
1481: CALL 427 0 2
1485: ST_TO_ADDR
// tmp := tmp ^ Lisa ;
1486: LD_ADDR_VAR 0 5
1490: PUSH
1491: LD_VAR 0 5
1495: PUSH
1496: LD_EXP 22
1500: ADD
1501: ST_TO_ADDR
// end ; if LoadVariable ( FrankInDelta , debug ) then
1502: LD_STRING FrankInDelta
1504: PPUSH
1505: LD_EXP 1
1509: PPUSH
1510: CALL_OW 30
1514: IFFALSE 1551
// begin Frank := PrepareUnit ( Frank , ( not debug ) ) ;
1516: LD_ADDR_EXP 23
1520: PUSH
1521: LD_STRING Frank
1523: PPUSH
1524: LD_EXP 1
1528: NOT
1529: PPUSH
1530: CALL 427 0 2
1534: ST_TO_ADDR
// tmp := tmp ^ Frank ;
1535: LD_ADDR_VAR 0 5
1539: PUSH
1540: LD_VAR 0 5
1544: PUSH
1545: LD_EXP 23
1549: ADD
1550: ST_TO_ADDR
// end ; if LoadVariable ( BobbyInDelta , 0 ) then
1551: LD_STRING BobbyInDelta
1553: PPUSH
1554: LD_INT 0
1556: PPUSH
1557: CALL_OW 30
1561: IFFALSE 1598
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1563: LD_ADDR_EXP 24
1567: PUSH
1568: LD_STRING Bobby
1570: PPUSH
1571: LD_EXP 1
1575: NOT
1576: PPUSH
1577: CALL 427 0 2
1581: ST_TO_ADDR
// tmp := tmp ^ Bobby ;
1582: LD_ADDR_VAR 0 5
1586: PUSH
1587: LD_VAR 0 5
1591: PUSH
1592: LD_EXP 24
1596: ADD
1597: ST_TO_ADDR
// end ; if LoadVariable ( CyrusInDelta , 0 ) then
1598: LD_STRING CyrusInDelta
1600: PPUSH
1601: LD_INT 0
1603: PPUSH
1604: CALL_OW 30
1608: IFFALSE 1645
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1610: LD_ADDR_EXP 25
1614: PUSH
1615: LD_STRING Cyrus
1617: PPUSH
1618: LD_EXP 1
1622: NOT
1623: PPUSH
1624: CALL 427 0 2
1628: ST_TO_ADDR
// tmp := tmp ^ Cyrus ;
1629: LD_ADDR_VAR 0 5
1633: PUSH
1634: LD_VAR 0 5
1638: PUSH
1639: LD_EXP 25
1643: ADD
1644: ST_TO_ADDR
// end ; others := CreateCharacterSet ( othersDelta ) ;
1645: LD_ADDR_EXP 26
1649: PUSH
1650: LD_STRING othersDelta
1652: PPUSH
1653: CALL_OW 31
1657: ST_TO_ADDR
// if not others and debug then
1658: LD_EXP 26
1662: NOT
1663: PUSH
1664: LD_EXP 1
1668: AND
1669: IFFALSE 1734
// begin InitHc ;
1671: CALL_OW 19
// for i = 1 to 2 do
1675: LD_ADDR_VAR 0 2
1679: PUSH
1680: DOUBLE
1681: LD_INT 1
1683: DEC
1684: ST_TO_ADDR
1685: LD_INT 2
1687: PUSH
1688: FOR_TO
1689: IFFALSE 1732
// begin PrepareHuman ( false , i mod 4 + 1 , 3 ) ;
1691: LD_INT 0
1693: PPUSH
1694: LD_VAR 0 2
1698: PUSH
1699: LD_INT 4
1701: MOD
1702: PUSH
1703: LD_INT 1
1705: PLUS
1706: PPUSH
1707: LD_INT 3
1709: PPUSH
1710: CALL_OW 380
// others := others ^ CreateHuman ;
1714: LD_ADDR_EXP 26
1718: PUSH
1719: LD_EXP 26
1723: PUSH
1724: CALL_OW 44
1728: ADD
1729: ST_TO_ADDR
// end ;
1730: GO 1688
1732: POP
1733: POP
// end ; if others then
1734: LD_EXP 26
1738: IFFALSE 1756
// tmp := tmp ^ others ;
1740: LD_ADDR_VAR 0 5
1744: PUSH
1745: LD_VAR 0 5
1749: PUSH
1750: LD_EXP 26
1754: ADD
1755: ST_TO_ADDR
// points := [ [ 28 , 49 ] , [ 33 , 54 ] , [ 38 , 56 ] ] ;
1756: LD_ADDR_VAR 0 3
1760: PUSH
1761: LD_INT 28
1763: PUSH
1764: LD_INT 49
1766: PUSH
1767: EMPTY
1768: LIST
1769: LIST
1770: PUSH
1771: LD_INT 33
1773: PUSH
1774: LD_INT 54
1776: PUSH
1777: EMPTY
1778: LIST
1779: LIST
1780: PUSH
1781: LD_INT 38
1783: PUSH
1784: LD_INT 56
1786: PUSH
1787: EMPTY
1788: LIST
1789: LIST
1790: PUSH
1791: EMPTY
1792: LIST
1793: LIST
1794: LIST
1795: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , us_cargo_bay , 80 ) ;
1796: LD_ADDR_VAR 0 4
1800: PUSH
1801: LD_INT 1
1803: PPUSH
1804: LD_INT 1
1806: PPUSH
1807: LD_INT 2
1809: PPUSH
1810: LD_INT 2
1812: PPUSH
1813: LD_INT 1
1815: PPUSH
1816: LD_INT 12
1818: PPUSH
1819: LD_INT 80
1821: PPUSH
1822: CALL 490 0 7
1826: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1827: LD_VAR 0 4
1831: PPUSH
1832: LD_INT 1
1834: PPUSH
1835: CALL_OW 233
// PlaceUnitXY ( veh , points [ 1 ] [ 1 ] , points [ 1 ] [ 2 ] , false ) ;
1839: LD_VAR 0 4
1843: PPUSH
1844: LD_VAR 0 3
1848: PUSH
1849: LD_INT 1
1851: ARRAY
1852: PUSH
1853: LD_INT 1
1855: ARRAY
1856: PPUSH
1857: LD_VAR 0 3
1861: PUSH
1862: LD_INT 1
1864: ARRAY
1865: PUSH
1866: LD_INT 2
1868: ARRAY
1869: PPUSH
1870: LD_INT 0
1872: PPUSH
1873: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
1877: LD_VAR 0 4
1881: PPUSH
1882: LD_INT 1
1884: PPUSH
1885: LD_INT 100
1887: PPUSH
1888: CALL_OW 290
// PlaceHumanInUnit ( others [ 1 ] , veh ) ;
1892: LD_EXP 26
1896: PUSH
1897: LD_INT 1
1899: ARRAY
1900: PPUSH
1901: LD_VAR 0 4
1905: PPUSH
1906: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_machine_gun , 80 ) ;
1910: LD_ADDR_VAR 0 4
1914: PUSH
1915: LD_INT 1
1917: PPUSH
1918: LD_INT 1
1920: PPUSH
1921: LD_INT 1
1923: PPUSH
1924: LD_INT 2
1926: PPUSH
1927: LD_INT 1
1929: PPUSH
1930: LD_INT 2
1932: PPUSH
1933: LD_INT 80
1935: PPUSH
1936: CALL 490 0 7
1940: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1941: LD_VAR 0 4
1945: PPUSH
1946: LD_INT 1
1948: PPUSH
1949: CALL_OW 233
// PlaceUnitXY ( veh , points [ 2 ] [ 1 ] , points [ 2 ] [ 2 ] , false ) ;
1953: LD_VAR 0 4
1957: PPUSH
1958: LD_VAR 0 3
1962: PUSH
1963: LD_INT 2
1965: ARRAY
1966: PUSH
1967: LD_INT 1
1969: ARRAY
1970: PPUSH
1971: LD_VAR 0 3
1975: PUSH
1976: LD_INT 2
1978: ARRAY
1979: PUSH
1980: LD_INT 2
1982: ARRAY
1983: PPUSH
1984: LD_INT 0
1986: PPUSH
1987: CALL_OW 48
// PlaceHumanInUnit ( Gladstone , veh ) ;
1991: LD_EXP 17
1995: PPUSH
1996: LD_VAR 0 4
2000: PPUSH
2001: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_light_gun , 80 ) ;
2005: LD_ADDR_VAR 0 4
2009: PUSH
2010: LD_INT 1
2012: PPUSH
2013: LD_INT 1
2015: PPUSH
2016: LD_INT 1
2018: PPUSH
2019: LD_INT 2
2021: PPUSH
2022: LD_INT 1
2024: PPUSH
2025: LD_INT 3
2027: PPUSH
2028: LD_INT 80
2030: PPUSH
2031: CALL 490 0 7
2035: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
2036: LD_VAR 0 4
2040: PPUSH
2041: LD_INT 1
2043: PPUSH
2044: CALL_OW 233
// PlaceUnitXY ( veh , points [ 3 ] [ 1 ] , points [ 3 ] [ 2 ] , false ) ;
2048: LD_VAR 0 4
2052: PPUSH
2053: LD_VAR 0 3
2057: PUSH
2058: LD_INT 3
2060: ARRAY
2061: PUSH
2062: LD_INT 1
2064: ARRAY
2065: PPUSH
2066: LD_VAR 0 3
2070: PUSH
2071: LD_INT 3
2073: ARRAY
2074: PUSH
2075: LD_INT 2
2077: ARRAY
2078: PPUSH
2079: LD_INT 0
2081: PPUSH
2082: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
2086: LD_EXP 16
2090: PPUSH
2091: LD_VAR 0 4
2095: PPUSH
2096: CALL_OW 52
// for i in tmp diff others [ 1 ] do
2100: LD_ADDR_VAR 0 2
2104: PUSH
2105: LD_VAR 0 5
2109: PUSH
2110: LD_EXP 26
2114: PUSH
2115: LD_INT 1
2117: ARRAY
2118: DIFF
2119: PUSH
2120: FOR_IN
2121: IFFALSE 2140
// PlaceUnitArea ( i , startArea , false ) ;
2123: LD_VAR 0 2
2127: PPUSH
2128: LD_INT 5
2130: PPUSH
2131: LD_INT 0
2133: PPUSH
2134: CALL_OW 49
2138: GO 2120
2140: POP
2141: POP
// end ; end_of_file
2142: LD_VAR 0 1
2146: RET
// export function Action ; var m ; begin
2147: LD_INT 0
2149: PPUSH
2150: PPUSH
// InGameOn ;
2151: CALL_OW 8
// CenterNowOnXY ( 28 , 51 ) ;
2155: LD_INT 28
2157: PPUSH
2158: LD_INT 51
2160: PPUSH
2161: CALL_OW 86
// Wait ( 3 ) ;
2165: LD_INT 3
2167: PPUSH
2168: CALL_OW 67
// Say ( JMM , D1d-JMM-1a ) ;
2172: LD_EXP 16
2176: PPUSH
2177: LD_STRING D1d-JMM-1a
2179: PPUSH
2180: CALL_OW 88
// SayRadio ( Harrison , D1d-Har-1 ) ;
2184: LD_EXP 18
2188: PPUSH
2189: LD_STRING D1d-Har-1
2191: PPUSH
2192: CALL_OW 94
// InGameOff ;
2196: CALL_OW 9
// SaveForQuickRestart ;
2200: CALL_OW 22
// ChangeMissionObjectives ( M1 ) ;
2204: LD_STRING M1
2206: PPUSH
2207: CALL_OW 337
// Wait ( 0 0$2 ) ;
2211: LD_INT 70
2213: PPUSH
2214: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
2218: LD_EXP 16
2222: PPUSH
2223: LD_STRING D2-JMM-1
2225: PPUSH
2226: CALL_OW 88
// Say ( Gladstone , D2-Glad-1 ) ;
2230: LD_EXP 17
2234: PPUSH
2235: LD_STRING D2-Glad-1
2237: PPUSH
2238: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
2242: LD_EXP 16
2246: PPUSH
2247: LD_STRING D2-JMM-2
2249: PPUSH
2250: CALL_OW 88
// Say ( Gladstone , D2-Glad-2 ) ;
2254: LD_EXP 17
2258: PPUSH
2259: LD_STRING D2-Glad-2
2261: PPUSH
2262: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
2266: LD_EXP 16
2270: PPUSH
2271: LD_STRING D2-JMM-3
2273: PPUSH
2274: CALL_OW 88
// Wait ( rand ( 0 0$30 , 1 1$00 ) ) ;
2278: LD_INT 1050
2280: PPUSH
2281: LD_INT 2100
2283: PPUSH
2284: CALL_OW 12
2288: PPUSH
2289: CALL_OW 67
// SetWeather ( 2 , 90 , 150 ) ;
2293: LD_INT 2
2295: PPUSH
2296: LD_INT 90
2298: PPUSH
2299: LD_INT 150
2301: PPUSH
2302: CALL_OW 550
// Wait ( rand ( 3 3$00 , 5 5$00 ) ) ;
2306: LD_INT 6300
2308: PPUSH
2309: LD_INT 10500
2311: PPUSH
2312: CALL_OW 12
2316: PPUSH
2317: CALL_OW 67
// SetWeather ( 0 , 90 , 150 ) ;
2321: LD_INT 0
2323: PPUSH
2324: LD_INT 90
2326: PPUSH
2327: LD_INT 150
2329: PPUSH
2330: CALL_OW 550
// end ;
2334: LD_VAR 0 1
2338: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) and not deltaBuilded do
2339: LD_INT 22
2341: PUSH
2342: LD_INT 1
2344: PUSH
2345: EMPTY
2346: LIST
2347: LIST
2348: PUSH
2349: LD_INT 3
2351: PUSH
2352: LD_INT 57
2354: PUSH
2355: EMPTY
2356: LIST
2357: PUSH
2358: EMPTY
2359: LIST
2360: LIST
2361: PUSH
2362: LD_INT 30
2364: PUSH
2365: LD_INT 0
2367: PUSH
2368: EMPTY
2369: LIST
2370: LIST
2371: PUSH
2372: EMPTY
2373: LIST
2374: LIST
2375: LIST
2376: PUSH
2377: EMPTY
2378: LIST
2379: PPUSH
2380: CALL_OW 69
2384: PUSH
2385: LD_EXP 4
2389: NOT
2390: AND
2391: IFFALSE 2404
2393: GO 2395
2395: DISABLE
// begin deltaBuilded := true ;
2396: LD_ADDR_EXP 4
2400: PUSH
2401: LD_INT 1
2403: ST_TO_ADDR
// end ;
2404: END
// every 0 0$01 trigger not Delta and deltaBuilded and FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) do
2405: LD_EXP 6
2409: NOT
2410: PUSH
2411: LD_EXP 4
2415: AND
2416: PUSH
2417: LD_INT 22
2419: PUSH
2420: LD_INT 1
2422: PUSH
2423: EMPTY
2424: LIST
2425: LIST
2426: PUSH
2427: LD_INT 3
2429: PUSH
2430: LD_INT 57
2432: PUSH
2433: EMPTY
2434: LIST
2435: PUSH
2436: EMPTY
2437: LIST
2438: LIST
2439: PUSH
2440: LD_INT 30
2442: PUSH
2443: LD_INT 0
2445: PUSH
2446: EMPTY
2447: LIST
2448: LIST
2449: PUSH
2450: EMPTY
2451: LIST
2452: LIST
2453: LIST
2454: PUSH
2455: EMPTY
2456: LIST
2457: PPUSH
2458: CALL_OW 69
2462: AND
2463: IFFALSE 2549
2465: GO 2467
2467: DISABLE
// begin enable ;
2468: ENABLE
// SetRestrict ( b_depot , 1 , state_disabled ) ;
2469: LD_INT 0
2471: PPUSH
2472: LD_INT 1
2474: PPUSH
2475: LD_INT 0
2477: PPUSH
2478: CALL_OW 324
// Delta := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) [ 1 ] ;
2482: LD_ADDR_EXP 6
2486: PUSH
2487: LD_INT 22
2489: PUSH
2490: LD_INT 1
2492: PUSH
2493: EMPTY
2494: LIST
2495: LIST
2496: PUSH
2497: LD_INT 3
2499: PUSH
2500: LD_INT 57
2502: PUSH
2503: EMPTY
2504: LIST
2505: PUSH
2506: EMPTY
2507: LIST
2508: LIST
2509: PUSH
2510: LD_INT 30
2512: PUSH
2513: LD_INT 0
2515: PUSH
2516: EMPTY
2517: LIST
2518: LIST
2519: PUSH
2520: EMPTY
2521: LIST
2522: LIST
2523: LIST
2524: PUSH
2525: EMPTY
2526: LIST
2527: PPUSH
2528: CALL_OW 69
2532: PUSH
2533: LD_INT 1
2535: ARRAY
2536: ST_TO_ADDR
// SetBName ( Delta , Delta ) ;
2537: LD_EXP 6
2541: PPUSH
2542: LD_STRING Delta
2544: PPUSH
2545: CALL_OW 500
// end ;
2549: END
// every 0 0$2 trigger GetTech ( tech_ApeLang , 1 ) = state_researched and IsOk ( Gladstone ) do
2550: LD_INT 1
2552: PPUSH
2553: LD_INT 1
2555: PPUSH
2556: CALL_OW 321
2560: PUSH
2561: LD_INT 2
2563: EQUAL
2564: PUSH
2565: LD_EXP 17
2569: PPUSH
2570: CALL_OW 302
2574: AND
2575: IFFALSE 2636
2577: GO 2579
2579: DISABLE
// begin DialogueOn ;
2580: CALL_OW 6
// Say ( Gladstone , D3-Glad-1 ) ;
2584: LD_EXP 17
2588: PPUSH
2589: LD_STRING D3-Glad-1
2591: PPUSH
2592: CALL_OW 88
// Say ( JMM , D3-JMM-1 ) ;
2596: LD_EXP 16
2600: PPUSH
2601: LD_STRING D3-JMM-1
2603: PPUSH
2604: CALL_OW 88
// Say ( Gladstone , D3-Glad-2 ) ;
2608: LD_EXP 17
2612: PPUSH
2613: LD_STRING D3-Glad-2
2615: PPUSH
2616: CALL_OW 88
// Say ( JMM , D3-JMM-2 ) ;
2620: LD_EXP 16
2624: PPUSH
2625: LD_STRING D3-JMM-2
2627: PPUSH
2628: CALL_OW 88
// DialogueOff ;
2632: CALL_OW 7
// end ;
2636: END
// every 0 0$1 trigger GetTech ( tech_ApePsych , 1 ) = state_researched do var sol ;
2637: LD_INT 2
2639: PPUSH
2640: LD_INT 1
2642: PPUSH
2643: CALL_OW 321
2647: PUSH
2648: LD_INT 2
2650: EQUAL
2651: IFFALSE 2828
2653: GO 2655
2655: DISABLE
2656: LD_INT 0
2658: PPUSH
// begin DialogueOn ;
2659: CALL_OW 6
// if Frank then
2663: LD_EXP 23
2667: IFFALSE 2681
// Say ( Frank , D8a-Frank-1 ) ;
2669: LD_EXP 23
2673: PPUSH
2674: LD_STRING D8a-Frank-1
2676: PPUSH
2677: CALL_OW 88
// sol := SayX ( UnitFilter ( others , [ f_sex , sex_male ] ) , D8a-Sol1-1 ) ;
2681: LD_ADDR_VAR 0 1
2685: PUSH
2686: LD_EXP 26
2690: PPUSH
2691: LD_INT 26
2693: PUSH
2694: LD_INT 1
2696: PUSH
2697: EMPTY
2698: LIST
2699: LIST
2700: PPUSH
2701: CALL_OW 72
2705: PPUSH
2706: LD_STRING D8a-Sol1-1
2708: PPUSH
2709: CALL 578 0 2
2713: ST_TO_ADDR
// if Denis and GetSide ( Denis ) = 1 then
2714: LD_EXP 19
2718: PUSH
2719: LD_EXP 19
2723: PPUSH
2724: CALL_OW 255
2728: PUSH
2729: LD_INT 1
2731: EQUAL
2732: AND
2733: IFFALSE 2747
// Say ( Denis , D8a-Den-1 ) ;
2735: LD_EXP 19
2739: PPUSH
2740: LD_STRING D8a-Den-1
2742: PPUSH
2743: CALL_OW 88
// if sol or Denis or Frank then
2747: LD_VAR 0 1
2751: PUSH
2752: LD_EXP 19
2756: OR
2757: PUSH
2758: LD_EXP 23
2762: OR
2763: IFFALSE 2824
// begin SayX ( UnitFilter ( others , [ [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff sol , D8a-Sci1-1 ) ;
2765: LD_EXP 26
2769: PPUSH
2770: LD_INT 25
2772: PUSH
2773: LD_INT 4
2775: PUSH
2776: EMPTY
2777: LIST
2778: LIST
2779: PUSH
2780: LD_INT 26
2782: PUSH
2783: LD_INT 1
2785: PUSH
2786: EMPTY
2787: LIST
2788: LIST
2789: PUSH
2790: EMPTY
2791: LIST
2792: LIST
2793: PPUSH
2794: CALL_OW 72
2798: PUSH
2799: LD_VAR 0 1
2803: DIFF
2804: PPUSH
2805: LD_STRING D8a-Sci1-1
2807: PPUSH
2808: CALL 578 0 2
// Say ( JMM , D8a-JMM-1 ) ;
2812: LD_EXP 16
2816: PPUSH
2817: LD_STRING D8a-JMM-1
2819: PPUSH
2820: CALL_OW 88
// end ; DialogueOff ;
2824: CALL_OW 7
// end ;
2828: PPOPN 1
2830: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) do
2831: LD_INT 22
2833: PUSH
2834: LD_INT 1
2836: PUSH
2837: EMPTY
2838: LIST
2839: LIST
2840: PUSH
2841: LD_INT 25
2843: PUSH
2844: LD_INT 16
2846: PUSH
2847: EMPTY
2848: LIST
2849: LIST
2850: PUSH
2851: EMPTY
2852: LIST
2853: LIST
2854: PPUSH
2855: CALL_OW 69
2859: IFFALSE 2918
2861: GO 2863
2863: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
2864: LD_STRING M1a
2866: PPUSH
2867: CALL_OW 337
// case Query ( Q2 ) of 1 :
2871: LD_STRING Q2
2873: PPUSH
2874: CALL_OW 97
2878: PUSH
2879: LD_INT 1
2881: DOUBLE
2882: EQUAL
2883: IFTRUE 2887
2885: GO 2898
2887: POP
// end_mission := true ; 2 :
2888: LD_ADDR_EXP 14
2892: PUSH
2893: LD_INT 1
2895: ST_TO_ADDR
2896: GO 2918
2898: LD_INT 2
2900: DOUBLE
2901: EQUAL
2902: IFTRUE 2906
2904: GO 2917
2906: POP
// end_the_mission_allowed := true ; end ;
2907: LD_ADDR_OWVAR 57
2911: PUSH
2912: LD_INT 1
2914: ST_TO_ADDR
2915: GO 2918
2917: POP
// end ;
2918: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) and Delta do
2919: LD_INT 22
2921: PUSH
2922: LD_INT 1
2924: PUSH
2925: EMPTY
2926: LIST
2927: LIST
2928: PUSH
2929: LD_INT 2
2931: PUSH
2932: LD_INT 30
2934: PUSH
2935: LD_INT 6
2937: PUSH
2938: EMPTY
2939: LIST
2940: LIST
2941: PUSH
2942: LD_INT 30
2944: PUSH
2945: LD_INT 7
2947: PUSH
2948: EMPTY
2949: LIST
2950: LIST
2951: PUSH
2952: EMPTY
2953: LIST
2954: LIST
2955: LIST
2956: PUSH
2957: EMPTY
2958: LIST
2959: LIST
2960: PPUSH
2961: CALL_OW 69
2965: PUSH
2966: LD_INT 22
2968: PUSH
2969: LD_INT 1
2971: PUSH
2972: EMPTY
2973: LIST
2974: LIST
2975: PUSH
2976: LD_INT 2
2978: PUSH
2979: LD_INT 30
2981: PUSH
2982: LD_INT 2
2984: PUSH
2985: EMPTY
2986: LIST
2987: LIST
2988: PUSH
2989: LD_INT 30
2991: PUSH
2992: LD_INT 3
2994: PUSH
2995: EMPTY
2996: LIST
2997: LIST
2998: PUSH
2999: EMPTY
3000: LIST
3001: LIST
3002: LIST
3003: PUSH
3004: EMPTY
3005: LIST
3006: LIST
3007: PPUSH
3008: CALL_OW 69
3012: AND
3013: PUSH
3014: LD_EXP 6
3018: AND
3019: IFFALSE 3446
3021: GO 3023
3023: DISABLE
// begin Wait ( rand ( 0 0$20 , 0 0$40 ) ) ;
3024: LD_INT 700
3026: PPUSH
3027: LD_INT 1400
3029: PPUSH
3030: CALL_OW 12
3034: PPUSH
3035: CALL_OW 67
// PlaceUnitArea ( Denis , [ denisArea1 , denisArea2 , denisArea3 ] [ Difficulty ] , false ) ;
3039: LD_EXP 19
3043: PPUSH
3044: LD_INT 6
3046: PUSH
3047: LD_INT 9
3049: PUSH
3050: LD_INT 10
3052: PUSH
3053: EMPTY
3054: LIST
3055: LIST
3056: LIST
3057: PUSH
3058: LD_OWVAR 67
3062: ARRAY
3063: PPUSH
3064: LD_INT 0
3066: PPUSH
3067: CALL_OW 49
// ComHold ( Denis ) ;
3071: LD_EXP 19
3075: PPUSH
3076: CALL_OW 140
// InGameOn ;
3080: CALL_OW 8
// DialogueOn ;
3084: CALL_OW 6
// if Delta then
3088: LD_EXP 6
3092: IFFALSE 3105
// CenterNowOnUnits ( Delta ) else
3094: LD_EXP 6
3098: PPUSH
3099: CALL_OW 87
3103: GO 3114
// CenterNowOnUnits ( JMM ) ;
3105: LD_EXP 16
3109: PPUSH
3110: CALL_OW 87
// SayRadio ( Denis , DD-Den-1 ) ;
3114: LD_EXP 19
3118: PPUSH
3119: LD_STRING DD-Den-1
3121: PPUSH
3122: CALL_OW 94
// Say ( JMM , DD-JMM-1 ) ;
3126: LD_EXP 16
3130: PPUSH
3131: LD_STRING DD-JMM-1
3133: PPUSH
3134: CALL_OW 88
// SayRadio ( Denis , DD-Den-2 ) ;
3138: LD_EXP 19
3142: PPUSH
3143: LD_STRING DD-Den-2
3145: PPUSH
3146: CALL_OW 94
// Wait ( 3 ) ;
3150: LD_INT 3
3152: PPUSH
3153: CALL_OW 67
// DialogueOff ;
3157: CALL_OW 7
// InGameOff ;
3161: CALL_OW 9
// repeat wait ( 0 0$01 ) ;
3165: LD_INT 35
3167: PPUSH
3168: CALL_OW 67
// until See ( 1 , Denis ) or IsDead ( Denis ) ;
3172: LD_INT 1
3174: PPUSH
3175: LD_EXP 19
3179: PPUSH
3180: CALL_OW 292
3184: PUSH
3185: LD_EXP 19
3189: PPUSH
3190: CALL_OW 301
3194: OR
3195: IFFALSE 3165
// if IsDead ( Denis ) then
3197: LD_EXP 19
3201: PPUSH
3202: CALL_OW 301
3206: IFFALSE 3210
// exit ;
3208: GO 3446
// SetSide ( Denis , 1 ) ;
3210: LD_EXP 19
3214: PPUSH
3215: LD_INT 1
3217: PPUSH
3218: CALL_OW 235
// Say ( Denis , DD-Den-2a ) ;
3222: LD_EXP 19
3226: PPUSH
3227: LD_STRING DD-Den-2a
3229: PPUSH
3230: CALL_OW 88
// repeat wait ( 0 0$01 ) ;
3234: LD_INT 35
3236: PPUSH
3237: CALL_OW 67
// until GetBType ( IsInUnit ( Denis ) ) in [ b_lab , b_lab_half , b_lab_full ] or IsDead ( Denis ) ;
3241: LD_EXP 19
3245: PPUSH
3246: CALL_OW 310
3250: PPUSH
3251: CALL_OW 266
3255: PUSH
3256: LD_INT 6
3258: PUSH
3259: LD_INT 7
3261: PUSH
3262: LD_INT 8
3264: PUSH
3265: EMPTY
3266: LIST
3267: LIST
3268: LIST
3269: IN
3270: PUSH
3271: LD_EXP 19
3275: PPUSH
3276: CALL_OW 301
3280: OR
3281: IFFALSE 3234
// if IsDead ( Denis ) then
3283: LD_EXP 19
3287: PPUSH
3288: CALL_OW 301
3292: IFFALSE 3296
// exit ;
3294: GO 3446
// Say ( Denis , DD-Den-2b ) ;
3296: LD_EXP 19
3300: PPUSH
3301: LD_STRING DD-Den-2b
3303: PPUSH
3304: CALL_OW 88
// ComChangeProfession ( Denis , 4 ) ;
3308: LD_EXP 19
3312: PPUSH
3313: LD_INT 4
3315: PPUSH
3316: CALL_OW 123
// Wait ( 0 0$02 ) ;
3320: LD_INT 70
3322: PPUSH
3323: CALL_OW 67
// DialogueOn ;
3327: CALL_OW 6
// CenterNowOnUnits ( Denis ) ;
3331: LD_EXP 19
3335: PPUSH
3336: CALL_OW 87
// Say ( JMM , D4-JMM-1 ) ;
3340: LD_EXP 16
3344: PPUSH
3345: LD_STRING D4-JMM-1
3347: PPUSH
3348: CALL_OW 88
// Say ( Denis , D4-Den-1 ) ;
3352: LD_EXP 19
3356: PPUSH
3357: LD_STRING D4-Den-1
3359: PPUSH
3360: CALL_OW 88
// Say ( JMM , D4-JMM-2 ) ;
3364: LD_EXP 16
3368: PPUSH
3369: LD_STRING D4-JMM-2
3371: PPUSH
3372: CALL_OW 88
// Say ( Denis , D4-Den-2 ) ;
3376: LD_EXP 19
3380: PPUSH
3381: LD_STRING D4-Den-2
3383: PPUSH
3384: CALL_OW 88
// DialogueOff ;
3388: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
3392: LD_STRING M2
3394: PPUSH
3395: CALL_OW 337
// radar_allowed := true ;
3399: LD_ADDR_EXP 7
3403: PUSH
3404: LD_INT 1
3406: ST_TO_ADDR
// SetTech ( tech_radar , 1 , state_enabled ) ;
3407: LD_INT 6
3409: PPUSH
3410: LD_INT 1
3412: PPUSH
3413: LD_INT 1
3415: PPUSH
3416: CALL_OW 322
// SetRestrict ( b_lab_opto , 1 , state_enabled ) ;
3420: LD_INT 15
3422: PPUSH
3423: LD_INT 1
3425: PPUSH
3426: LD_INT 1
3428: PPUSH
3429: CALL_OW 324
// SetRestrict ( b_ext_radar , 1 , state_enabled ) ;
3433: LD_INT 20
3435: PPUSH
3436: LD_INT 1
3438: PPUSH
3439: LD_INT 1
3441: PPUSH
3442: CALL_OW 324
// end ;
3446: END
// every 0 0$1 trigger arab_spotted do var sol , sol2 ;
3447: LD_EXP 13
3451: IFFALSE 4074
3453: GO 3455
3455: DISABLE
3456: LD_INT 0
3458: PPUSH
3459: PPUSH
// begin sol := SayX ( UnitFilter ( others , [ f_sex , sex_male ] ) , D5-Sol1-1 ) ;
3460: LD_ADDR_VAR 0 1
3464: PUSH
3465: LD_EXP 26
3469: PPUSH
3470: LD_INT 26
3472: PUSH
3473: LD_INT 1
3475: PUSH
3476: EMPTY
3477: LIST
3478: LIST
3479: PPUSH
3480: CALL_OW 72
3484: PPUSH
3485: LD_STRING D5-Sol1-1
3487: PPUSH
3488: CALL 578 0 2
3492: ST_TO_ADDR
// if not sol then
3493: LD_VAR 0 1
3497: NOT
3498: IFFALSE 3502
// exit ;
3500: GO 4074
// repeat wait ( 0 0$01 ) ;
3502: LD_INT 35
3504: PPUSH
3505: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 ;
3509: LD_INT 22
3511: PUSH
3512: LD_INT 2
3514: PUSH
3515: EMPTY
3516: LIST
3517: LIST
3518: PUSH
3519: LD_INT 21
3521: PUSH
3522: LD_INT 1
3524: PUSH
3525: EMPTY
3526: LIST
3527: LIST
3528: PUSH
3529: EMPTY
3530: LIST
3531: LIST
3532: PPUSH
3533: CALL_OW 69
3537: PUSH
3538: LD_INT 0
3540: EQUAL
3541: IFFALSE 3502
// if IsOk ( sol ) then
3543: LD_VAR 0 1
3547: PPUSH
3548: CALL_OW 302
3552: IFFALSE 3572
// begin sol2 := others diff sol ;
3554: LD_ADDR_VAR 0 2
3558: PUSH
3559: LD_EXP 26
3563: PUSH
3564: LD_VAR 0 1
3568: DIFF
3569: ST_TO_ADDR
// end else
3570: GO 3574
// exit ;
3572: GO 4074
// if not Lisa and not sol2 then
3574: LD_EXP 22
3578: NOT
3579: PUSH
3580: LD_VAR 0 2
3584: NOT
3585: AND
3586: IFFALSE 3590
// exit ;
3588: GO 4074
// DialogueOn ;
3590: CALL_OW 6
// if Lisa then
3594: LD_EXP 22
3598: IFFALSE 3614
// Say ( Lisa , D5a-Lisa-1 ) else
3600: LD_EXP 22
3604: PPUSH
3605: LD_STRING D5a-Lisa-1
3607: PPUSH
3608: CALL_OW 88
3612: GO 3689
// if sol2 then
3614: LD_VAR 0 2
3618: IFFALSE 3689
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3620: LD_VAR 0 2
3624: PUSH
3625: LD_INT 1
3627: ARRAY
3628: PPUSH
3629: CALL_OW 258
3633: PUSH
3634: LD_INT 1
3636: DOUBLE
3637: EQUAL
3638: IFTRUE 3642
3640: GO 3661
3642: POP
// Say ( sol2 [ 1 ] , D5-Sol2-1 ) ; sex_female :
3643: LD_VAR 0 2
3647: PUSH
3648: LD_INT 1
3650: ARRAY
3651: PPUSH
3652: LD_STRING D5-Sol2-1
3654: PPUSH
3655: CALL_OW 88
3659: GO 3689
3661: LD_INT 2
3663: DOUBLE
3664: EQUAL
3665: IFTRUE 3669
3667: GO 3688
3669: POP
// Say ( sol2 [ 1 ] , D5-FSol2-1 ) ; end ;
3670: LD_VAR 0 2
3674: PUSH
3675: LD_INT 1
3677: ARRAY
3678: PPUSH
3679: LD_STRING D5-FSol2-1
3681: PPUSH
3682: CALL_OW 88
3686: GO 3689
3688: POP
// Say ( sol , D5-Sol1-2 ) ;
3689: LD_VAR 0 1
3693: PPUSH
3694: LD_STRING D5-Sol1-2
3696: PPUSH
3697: CALL_OW 88
// if Lisa then
3701: LD_EXP 22
3705: IFFALSE 3721
// Say ( Lisa , D5a-Lisa-2 ) else
3707: LD_EXP 22
3711: PPUSH
3712: LD_STRING D5a-Lisa-2
3714: PPUSH
3715: CALL_OW 88
3719: GO 3796
// if sol2 then
3721: LD_VAR 0 2
3725: IFFALSE 3796
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3727: LD_VAR 0 2
3731: PUSH
3732: LD_INT 1
3734: ARRAY
3735: PPUSH
3736: CALL_OW 258
3740: PUSH
3741: LD_INT 1
3743: DOUBLE
3744: EQUAL
3745: IFTRUE 3749
3747: GO 3768
3749: POP
// Say ( sol2 [ 1 ] , D5-Sol2-2 ) ; sex_female :
3750: LD_VAR 0 2
3754: PUSH
3755: LD_INT 1
3757: ARRAY
3758: PPUSH
3759: LD_STRING D5-Sol2-2
3761: PPUSH
3762: CALL_OW 88
3766: GO 3796
3768: LD_INT 2
3770: DOUBLE
3771: EQUAL
3772: IFTRUE 3776
3774: GO 3795
3776: POP
// Say ( sol2 [ 1 ] , D5-FSol2-2 ) ; end ;
3777: LD_VAR 0 2
3781: PUSH
3782: LD_INT 1
3784: ARRAY
3785: PPUSH
3786: LD_STRING D5-FSol2-2
3788: PPUSH
3789: CALL_OW 88
3793: GO 3796
3795: POP
// Say ( sol , D5a-Sol1-3 ) ;
3796: LD_VAR 0 1
3800: PPUSH
3801: LD_STRING D5a-Sol1-3
3803: PPUSH
3804: CALL_OW 88
// if Lisa then
3808: LD_EXP 22
3812: IFFALSE 3826
// Say ( Lisa , D5a-Lisa-3 ) ;
3814: LD_EXP 22
3818: PPUSH
3819: LD_STRING D5a-Lisa-3
3821: PPUSH
3822: CALL_OW 88
// if not sol2 then
3826: LD_VAR 0 2
3830: NOT
3831: IFFALSE 3839
// begin DialogueOff ;
3833: CALL_OW 7
// exit ;
3837: GO 4074
// end ; case GetSex ( sol2 [ 1 ] ) of sex_male :
3839: LD_VAR 0 2
3843: PUSH
3844: LD_INT 1
3846: ARRAY
3847: PPUSH
3848: CALL_OW 258
3852: PUSH
3853: LD_INT 1
3855: DOUBLE
3856: EQUAL
3857: IFTRUE 3861
3859: GO 3880
3861: POP
// Say ( sol2 [ 1 ] , D5-Sol2-3 ) ; sex_female :
3862: LD_VAR 0 2
3866: PUSH
3867: LD_INT 1
3869: ARRAY
3870: PPUSH
3871: LD_STRING D5-Sol2-3
3873: PPUSH
3874: CALL_OW 88
3878: GO 3908
3880: LD_INT 2
3882: DOUBLE
3883: EQUAL
3884: IFTRUE 3888
3886: GO 3907
3888: POP
// Say ( sol2 [ 1 ] , D5-FSol2-3 ) ; end ;
3889: LD_VAR 0 2
3893: PUSH
3894: LD_INT 1
3896: ARRAY
3897: PPUSH
3898: LD_STRING D5-FSol2-3
3900: PPUSH
3901: CALL_OW 88
3905: GO 3908
3907: POP
// Say ( sol , D5-Sol1-4 ) ;
3908: LD_VAR 0 1
3912: PPUSH
3913: LD_STRING D5-Sol1-4
3915: PPUSH
3916: CALL_OW 88
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3920: LD_VAR 0 2
3924: PUSH
3925: LD_INT 1
3927: ARRAY
3928: PPUSH
3929: CALL_OW 258
3933: PUSH
3934: LD_INT 1
3936: DOUBLE
3937: EQUAL
3938: IFTRUE 3942
3940: GO 3961
3942: POP
// Say ( sol2 [ 1 ] , D5-Sol2-4 ) ; sex_female :
3943: LD_VAR 0 2
3947: PUSH
3948: LD_INT 1
3950: ARRAY
3951: PPUSH
3952: LD_STRING D5-Sol2-4
3954: PPUSH
3955: CALL_OW 88
3959: GO 3989
3961: LD_INT 2
3963: DOUBLE
3964: EQUAL
3965: IFTRUE 3969
3967: GO 3988
3969: POP
// Say ( sol2 [ 1 ] , D5-FSol2-4 ) ; end ;
3970: LD_VAR 0 2
3974: PUSH
3975: LD_INT 1
3977: ARRAY
3978: PPUSH
3979: LD_STRING D5-FSol2-4
3981: PPUSH
3982: CALL_OW 88
3986: GO 3989
3988: POP
// Say ( sol , D5-Sol1-5 ) ;
3989: LD_VAR 0 1
3993: PPUSH
3994: LD_STRING D5-Sol1-5
3996: PPUSH
3997: CALL_OW 88
// case GetSex ( sol2 [ 1 ] ) of sex_male :
4001: LD_VAR 0 2
4005: PUSH
4006: LD_INT 1
4008: ARRAY
4009: PPUSH
4010: CALL_OW 258
4014: PUSH
4015: LD_INT 1
4017: DOUBLE
4018: EQUAL
4019: IFTRUE 4023
4021: GO 4042
4023: POP
// Say ( sol2 [ 1 ] , D5-Sol2-5 ) ; sex_female :
4024: LD_VAR 0 2
4028: PUSH
4029: LD_INT 1
4031: ARRAY
4032: PPUSH
4033: LD_STRING D5-Sol2-5
4035: PPUSH
4036: CALL_OW 88
4040: GO 4070
4042: LD_INT 2
4044: DOUBLE
4045: EQUAL
4046: IFTRUE 4050
4048: GO 4069
4050: POP
// Say ( sol2 [ 1 ] , D5-FSol2-5 ) ; end ;
4051: LD_VAR 0 2
4055: PUSH
4056: LD_INT 1
4058: ARRAY
4059: PPUSH
4060: LD_STRING D5-FSol2-5
4062: PPUSH
4063: CALL_OW 88
4067: GO 4070
4069: POP
// DialogueOff ;
4070: CALL_OW 7
// end ;
4074: PPOPN 2
4076: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) >= 5 do
4077: LD_INT 22
4079: PUSH
4080: LD_INT 1
4082: PUSH
4083: EMPTY
4084: LIST
4085: LIST
4086: PUSH
4087: LD_INT 25
4089: PUSH
4090: LD_INT 16
4092: PUSH
4093: EMPTY
4094: LIST
4095: LIST
4096: PUSH
4097: EMPTY
4098: LIST
4099: LIST
4100: PPUSH
4101: CALL_OW 69
4105: PUSH
4106: LD_INT 5
4108: GREATEREQUAL
4109: IFFALSE 4129
4111: GO 4113
4113: DISABLE
// begin ChangeMissionObjectives ( M1b ) ;
4114: LD_STRING M1b
4116: PPUSH
4117: CALL_OW 337
// apeman_army := true ;
4121: LD_ADDR_EXP 9
4125: PUSH
4126: LD_INT 1
4128: ST_TO_ADDR
// end ;
4129: END
// every 0 0$1 trigger GetTech ( tech_radar , 1 ) = state_researched do
4130: LD_INT 6
4132: PPUSH
4133: LD_INT 1
4135: PPUSH
4136: CALL_OW 321
4140: PUSH
4141: LD_INT 2
4143: EQUAL
4144: IFFALSE 4164
4146: GO 4148
4148: DISABLE
// begin ChangeMissionObjectives ( M2a ) ;
4149: LD_STRING M2a
4151: PPUSH
4152: CALL_OW 337
// radar_researched := true ;
4156: LD_ADDR_EXP 10
4160: PUSH
4161: LD_INT 1
4163: ST_TO_ADDR
// end ;
4164: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_weapon , us_radar ] , [ f_bweapon , us_radar ] ] ] ) do
4165: LD_INT 22
4167: PUSH
4168: LD_INT 1
4170: PUSH
4171: EMPTY
4172: LIST
4173: LIST
4174: PUSH
4175: LD_INT 2
4177: PUSH
4178: LD_INT 34
4180: PUSH
4181: LD_INT 11
4183: PUSH
4184: EMPTY
4185: LIST
4186: LIST
4187: PUSH
4188: LD_INT 35
4190: PUSH
4191: LD_INT 11
4193: PUSH
4194: EMPTY
4195: LIST
4196: LIST
4197: PUSH
4198: EMPTY
4199: LIST
4200: LIST
4201: LIST
4202: PUSH
4203: EMPTY
4204: LIST
4205: LIST
4206: PPUSH
4207: CALL_OW 69
4211: IFFALSE 4231
4213: GO 4215
4215: DISABLE
// begin ChangeMissionObjectives ( M2b ) ;
4216: LD_STRING M2b
4218: PPUSH
4219: CALL_OW 337
// radar_builded := true ;
4223: LD_ADDR_EXP 11
4227: PUSH
4228: LD_INT 1
4230: ST_TO_ADDR
// end ;
4231: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) = 0 and not first_apeman_tamed do
4232: LD_INT 22
4234: PUSH
4235: LD_INT 0
4237: PUSH
4238: EMPTY
4239: LIST
4240: LIST
4241: PUSH
4242: LD_INT 25
4244: PUSH
4245: LD_INT 12
4247: PUSH
4248: EMPTY
4249: LIST
4250: LIST
4251: PUSH
4252: EMPTY
4253: LIST
4254: LIST
4255: PPUSH
4256: CALL_OW 69
4260: PUSH
4261: LD_INT 0
4263: EQUAL
4264: PUSH
4265: LD_EXP 8
4269: NOT
4270: AND
4271: IFFALSE 4283
4273: GO 4275
4275: DISABLE
// YouLost ( Apeman ) ;
4276: LD_STRING Apeman
4278: PPUSH
4279: CALL_OW 104
4283: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) >= 7 do var i , filter ;
4284: LD_INT 22
4286: PUSH
4287: LD_INT 1
4289: PUSH
4290: EMPTY
4291: LIST
4292: LIST
4293: PUSH
4294: LD_INT 25
4296: PUSH
4297: LD_INT 16
4299: PUSH
4300: EMPTY
4301: LIST
4302: LIST
4303: PUSH
4304: EMPTY
4305: LIST
4306: LIST
4307: PPUSH
4308: CALL_OW 69
4312: PUSH
4313: LD_INT 7
4315: GREATEREQUAL
4316: IFFALSE 4414
4318: GO 4320
4320: DISABLE
4321: LD_INT 0
4323: PPUSH
4324: PPUSH
// begin filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , 4 ] ] ) ^ JMM ;
4325: LD_ADDR_VAR 0 2
4329: PUSH
4330: LD_INT 22
4332: PUSH
4333: LD_INT 1
4335: PUSH
4336: EMPTY
4337: LIST
4338: LIST
4339: PUSH
4340: LD_INT 21
4342: PUSH
4343: LD_INT 1
4345: PUSH
4346: EMPTY
4347: LIST
4348: LIST
4349: PUSH
4350: LD_INT 25
4352: PUSH
4353: LD_INT 4
4355: PUSH
4356: EMPTY
4357: LIST
4358: LIST
4359: PUSH
4360: EMPTY
4361: LIST
4362: LIST
4363: LIST
4364: PPUSH
4365: CALL_OW 69
4369: PUSH
4370: LD_EXP 16
4374: ADD
4375: ST_TO_ADDR
// if filter then
4376: LD_VAR 0 2
4380: IFFALSE 4414
// for i in filter do
4382: LD_ADDR_VAR 0 1
4386: PUSH
4387: LD_VAR 0 2
4391: PUSH
4392: FOR_IN
4393: IFFALSE 4412
// AddExperience ( i , 4 , 3500 ) ;
4395: LD_VAR 0 1
4399: PPUSH
4400: LD_INT 4
4402: PPUSH
4403: LD_INT 3500
4405: PPUSH
4406: CALL_OW 492
4410: GO 4392
4412: POP
4413: POP
// end ;
4414: PPOPN 2
4416: END
// every 0 0$1 trigger end_mission do var i , tmp , m1 , m2 , m3 ;
4417: LD_EXP 14
4421: IFFALSE 5555
4423: GO 4425
4425: DISABLE
4426: LD_INT 0
4428: PPUSH
4429: PPUSH
4430: PPUSH
4431: PPUSH
4432: PPUSH
// begin if apeKillCounter = 0 then
4433: LD_EXP 15
4437: PUSH
4438: LD_INT 0
4440: EQUAL
4441: IFFALSE 4450
// SetAchievement ( ACH_APEKILLER ) ;
4443: LD_STRING ACH_APEKILLER
4445: PPUSH
4446: CALL_OW 543
// if FilterAllUnits ( [ f_side , 2 ] ) then
4450: LD_INT 22
4452: PUSH
4453: LD_INT 2
4455: PUSH
4456: EMPTY
4457: LIST
4458: LIST
4459: PPUSH
4460: CALL_OW 69
4464: IFFALSE 4502
// for i in FilterAllUnits ( [ f_side , 2 ] ) do
4466: LD_ADDR_VAR 0 1
4470: PUSH
4471: LD_INT 22
4473: PUSH
4474: LD_INT 2
4476: PUSH
4477: EMPTY
4478: LIST
4479: LIST
4480: PPUSH
4481: CALL_OW 69
4485: PUSH
4486: FOR_IN
4487: IFFALSE 4500
// RemoveUnit ( i ) ;
4489: LD_VAR 0 1
4493: PPUSH
4494: CALL_OW 64
4498: GO 4486
4500: POP
4501: POP
// m1 := false ;
4502: LD_ADDR_VAR 0 3
4506: PUSH
4507: LD_INT 0
4509: ST_TO_ADDR
// m2 := false ;
4510: LD_ADDR_VAR 0 4
4514: PUSH
4515: LD_INT 0
4517: ST_TO_ADDR
// m3 := false ;
4518: LD_ADDR_VAR 0 5
4522: PUSH
4523: LD_INT 0
4525: ST_TO_ADDR
// if apeman_army then
4526: LD_EXP 9
4530: IFFALSE 4552
// begin AddMedal ( Tame , 1 ) ;
4532: LD_STRING Tame
4534: PPUSH
4535: LD_INT 1
4537: PPUSH
4538: CALL_OW 101
// m1 := true ;
4542: LD_ADDR_VAR 0 3
4546: PUSH
4547: LD_INT 1
4549: ST_TO_ADDR
// end else
4550: GO 4563
// AddMedal ( Tame , - 1 ) ;
4552: LD_STRING Tame
4554: PPUSH
4555: LD_INT 1
4557: NEG
4558: PPUSH
4559: CALL_OW 101
// if radar_researched then
4563: LD_EXP 10
4567: IFFALSE 4599
// begin SaveVariable ( true , radarResInDelta ) ;
4569: LD_INT 1
4571: PPUSH
4572: LD_STRING radarResInDelta
4574: PPUSH
4575: CALL_OW 39
// AddMedal ( Radar , 1 ) ;
4579: LD_STRING Radar
4581: PPUSH
4582: LD_INT 1
4584: PPUSH
4585: CALL_OW 101
// m2 := true ;
4589: LD_ADDR_VAR 0 4
4593: PUSH
4594: LD_INT 1
4596: ST_TO_ADDR
// end else
4597: GO 4629
// if radar_allowed then
4599: LD_EXP 7
4603: IFFALSE 4618
// AddMedal ( Radar , - 2 ) else
4605: LD_STRING Radar
4607: PPUSH
4608: LD_INT 2
4610: NEG
4611: PPUSH
4612: CALL_OW 101
4616: GO 4629
// AddMedal ( Radar , - 1 ) ;
4618: LD_STRING Radar
4620: PPUSH
4621: LD_INT 1
4623: NEG
4624: PPUSH
4625: CALL_OW 101
// if radar_builded then
4629: LD_EXP 11
4633: IFFALSE 4655
// begin AddMedal ( BuildRadar , 1 ) ;
4635: LD_STRING BuildRadar
4637: PPUSH
4638: LD_INT 1
4640: PPUSH
4641: CALL_OW 101
// m3 := true ;
4645: LD_ADDR_VAR 0 5
4649: PUSH
4650: LD_INT 1
4652: ST_TO_ADDR
// end else
4653: GO 4666
// AddMedal ( BuildRadar , - 1 ) ;
4655: LD_STRING BuildRadar
4657: PPUSH
4658: LD_INT 1
4660: NEG
4661: PPUSH
4662: CALL_OW 101
// if tick <= 7 7$00 then
4666: LD_OWVAR 1
4670: PUSH
4671: LD_INT 14700
4673: LESSEQUAL
4674: IFFALSE 4683
// SetAchievement ( ACH_ASPEED_5 ) ;
4676: LD_STRING ACH_ASPEED_5
4678: PPUSH
4679: CALL_OW 543
// if m1 and m2 and m3 and Difficulty = 3 then
4683: LD_VAR 0 3
4687: PUSH
4688: LD_VAR 0 4
4692: AND
4693: PUSH
4694: LD_VAR 0 5
4698: AND
4699: PUSH
4700: LD_OWVAR 67
4704: PUSH
4705: LD_INT 3
4707: EQUAL
4708: AND
4709: IFFALSE 4721
// SetAchievementEX ( ACH_AMER , 5 ) ;
4711: LD_STRING ACH_AMER
4713: PPUSH
4714: LD_INT 5
4716: PPUSH
4717: CALL_OW 564
// GiveMedals ( MAIN ) ;
4721: LD_STRING MAIN
4723: PPUSH
4724: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
4728: LD_ADDR_VAR 0 2
4732: PUSH
4733: LD_INT 22
4735: PUSH
4736: LD_INT 1
4738: PUSH
4739: EMPTY
4740: LIST
4741: LIST
4742: PUSH
4743: LD_INT 21
4745: PUSH
4746: LD_INT 1
4748: PUSH
4749: EMPTY
4750: LIST
4751: LIST
4752: PUSH
4753: LD_INT 2
4755: PUSH
4756: LD_INT 25
4758: PUSH
4759: LD_INT 1
4761: PUSH
4762: EMPTY
4763: LIST
4764: LIST
4765: PUSH
4766: LD_INT 25
4768: PUSH
4769: LD_INT 2
4771: PUSH
4772: EMPTY
4773: LIST
4774: LIST
4775: PUSH
4776: LD_INT 25
4778: PUSH
4779: LD_INT 3
4781: PUSH
4782: EMPTY
4783: LIST
4784: LIST
4785: PUSH
4786: LD_INT 25
4788: PUSH
4789: LD_INT 4
4791: PUSH
4792: EMPTY
4793: LIST
4794: LIST
4795: PUSH
4796: EMPTY
4797: LIST
4798: LIST
4799: LIST
4800: LIST
4801: LIST
4802: PUSH
4803: EMPTY
4804: LIST
4805: LIST
4806: LIST
4807: PPUSH
4808: CALL_OW 69
4812: ST_TO_ADDR
// RewardPeople ( tmp ) ;
4813: LD_VAR 0 2
4817: PPUSH
4818: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
4822: LD_EXP 16
4826: PPUSH
4827: LD_EXP 2
4831: PUSH
4832: LD_STRING JMM
4834: STR
4835: PPUSH
4836: CALL_OW 38
// if IsOk ( Gladstone ) then
4840: LD_EXP 17
4844: PPUSH
4845: CALL_OW 302
4849: IFFALSE 4869
// begin SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
4851: LD_EXP 17
4855: PPUSH
4856: LD_EXP 2
4860: PUSH
4861: LD_STRING Gladstone
4863: STR
4864: PPUSH
4865: CALL_OW 38
// end ; if IsOk ( Denis ) and GetSide ( Denis ) = 1 then
4869: LD_EXP 19
4873: PPUSH
4874: CALL_OW 302
4878: PUSH
4879: LD_EXP 19
4883: PPUSH
4884: CALL_OW 255
4888: PUSH
4889: LD_INT 1
4891: EQUAL
4892: AND
4893: IFFALSE 4923
// begin SaveCharacters ( Denis , mission_prefix & Denis ) ;
4895: LD_EXP 19
4899: PPUSH
4900: LD_EXP 2
4904: PUSH
4905: LD_STRING Denis
4907: STR
4908: PPUSH
4909: CALL_OW 38
// SaveVariable ( true , DenisInDelta ) ;
4913: LD_INT 1
4915: PPUSH
4916: LD_STRING DenisInDelta
4918: PPUSH
4919: CALL_OW 39
// end ; if IsOk ( Lisa ) then
4923: LD_EXP 22
4927: PPUSH
4928: CALL_OW 302
4932: IFFALSE 4952
// begin SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
4934: LD_EXP 22
4938: PPUSH
4939: LD_EXP 2
4943: PUSH
4944: LD_STRING Lisa
4946: STR
4947: PPUSH
4948: CALL_OW 38
// end ; if IsOk ( Frank ) then
4952: LD_EXP 23
4956: PPUSH
4957: CALL_OW 302
4961: IFFALSE 4981
// begin SaveCharacters ( Frank , mission_prefix & Frank ) ;
4963: LD_EXP 23
4967: PPUSH
4968: LD_EXP 2
4972: PUSH
4973: LD_STRING Frank
4975: STR
4976: PPUSH
4977: CALL_OW 38
// end ; if IsOk ( Bobby ) then
4981: LD_EXP 24
4985: PPUSH
4986: CALL_OW 302
4990: IFFALSE 5010
// begin SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
4992: LD_EXP 24
4996: PPUSH
4997: LD_EXP 2
5001: PUSH
5002: LD_STRING Bobby
5004: STR
5005: PPUSH
5006: CALL_OW 38
// end ; if IsOk ( Cyrus ) then
5010: LD_EXP 25
5014: PPUSH
5015: CALL_OW 302
5019: IFFALSE 5039
// begin SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
5021: LD_EXP 25
5025: PPUSH
5026: LD_EXP 2
5030: PUSH
5031: LD_STRING Cyrus
5033: STR
5034: PPUSH
5035: CALL_OW 38
// end ; if IsOk ( Brown ) then
5039: LD_EXP 20
5043: PPUSH
5044: CALL_OW 302
5048: IFFALSE 5068
// begin SaveCharacters ( Brown , mission_prefix & Brown ) ;
5050: LD_EXP 20
5054: PPUSH
5055: LD_EXP 2
5059: PUSH
5060: LD_STRING Brown
5062: STR
5063: PPUSH
5064: CALL_OW 38
// end ; if IsOk ( Donaldson ) then
5068: LD_EXP 21
5072: PPUSH
5073: CALL_OW 302
5077: IFFALSE 5097
// begin SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
5079: LD_EXP 21
5083: PPUSH
5084: LD_EXP 2
5088: PUSH
5089: LD_STRING Donaldson
5091: STR
5092: PPUSH
5093: CALL_OW 38
// end ; if others then
5097: LD_EXP 26
5101: IFFALSE 5115
// SaveCharacters ( others , othersInDelta ) ;
5103: LD_EXP 26
5107: PPUSH
5108: LD_STRING othersInDelta
5110: PPUSH
5111: CALL_OW 38
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) then
5115: LD_INT 22
5117: PUSH
5118: LD_INT 1
5120: PUSH
5121: EMPTY
5122: LIST
5123: LIST
5124: PUSH
5125: LD_INT 25
5127: PUSH
5128: LD_INT 16
5130: PUSH
5131: EMPTY
5132: LIST
5133: LIST
5134: PUSH
5135: EMPTY
5136: LIST
5137: LIST
5138: PPUSH
5139: CALL_OW 69
5143: IFFALSE 5181
// SaveCharacters ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) , apeInDelta ) ;
5145: LD_INT 22
5147: PUSH
5148: LD_INT 1
5150: PUSH
5151: EMPTY
5152: LIST
5153: LIST
5154: PUSH
5155: LD_INT 25
5157: PUSH
5158: LD_INT 16
5160: PUSH
5161: EMPTY
5162: LIST
5163: LIST
5164: PUSH
5165: EMPTY
5166: LIST
5167: LIST
5168: PPUSH
5169: CALL_OW 69
5173: PPUSH
5174: LD_STRING apeInDelta
5176: PPUSH
5177: CALL_OW 38
// tmp := [ ] ;
5181: LD_ADDR_VAR 0 2
5185: PUSH
5186: EMPTY
5187: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) then
5188: LD_INT 22
5190: PUSH
5191: LD_INT 1
5193: PUSH
5194: EMPTY
5195: LIST
5196: LIST
5197: PUSH
5198: LD_INT 21
5200: PUSH
5201: LD_INT 2
5203: PUSH
5204: EMPTY
5205: LIST
5206: LIST
5207: PUSH
5208: EMPTY
5209: LIST
5210: LIST
5211: PPUSH
5212: CALL_OW 69
5216: IFFALSE 5327
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) do
5218: LD_ADDR_VAR 0 1
5222: PUSH
5223: LD_INT 22
5225: PUSH
5226: LD_INT 1
5228: PUSH
5229: EMPTY
5230: LIST
5231: LIST
5232: PUSH
5233: LD_INT 21
5235: PUSH
5236: LD_INT 2
5238: PUSH
5239: EMPTY
5240: LIST
5241: LIST
5242: PUSH
5243: EMPTY
5244: LIST
5245: LIST
5246: PPUSH
5247: CALL_OW 69
5251: PUSH
5252: FOR_IN
5253: IFFALSE 5325
// tmp := tmp ^ [ GetNation ( i ) , GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) ] ;
5255: LD_ADDR_VAR 0 2
5259: PUSH
5260: LD_VAR 0 2
5264: PUSH
5265: LD_VAR 0 1
5269: PPUSH
5270: CALL_OW 248
5274: PUSH
5275: LD_VAR 0 1
5279: PPUSH
5280: CALL_OW 265
5284: PUSH
5285: LD_VAR 0 1
5289: PPUSH
5290: CALL_OW 262
5294: PUSH
5295: LD_VAR 0 1
5299: PPUSH
5300: CALL_OW 263
5304: PUSH
5305: LD_VAR 0 1
5309: PPUSH
5310: CALL_OW 264
5314: PUSH
5315: EMPTY
5316: LIST
5317: LIST
5318: LIST
5319: LIST
5320: LIST
5321: ADD
5322: ST_TO_ADDR
5323: GO 5252
5325: POP
5326: POP
// if tmp then
5327: LD_VAR 0 2
5331: IFFALSE 5345
// SaveVariable ( tmp , vehiclesInDelta ) ;
5333: LD_VAR 0 2
5337: PPUSH
5338: LD_STRING vehiclesInDelta
5340: PPUSH
5341: CALL_OW 39
// tmp := [ ] ;
5345: LD_ADDR_VAR 0 2
5349: PUSH
5350: EMPTY
5351: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) then
5352: LD_INT 22
5354: PUSH
5355: LD_INT 1
5357: PUSH
5358: EMPTY
5359: LIST
5360: LIST
5361: PUSH
5362: LD_INT 21
5364: PUSH
5365: LD_INT 3
5367: PUSH
5368: EMPTY
5369: LIST
5370: LIST
5371: PUSH
5372: EMPTY
5373: LIST
5374: LIST
5375: PPUSH
5376: CALL_OW 69
5380: IFFALSE 5533
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
5382: LD_ADDR_VAR 0 1
5386: PUSH
5387: LD_INT 22
5389: PUSH
5390: LD_INT 1
5392: PUSH
5393: EMPTY
5394: LIST
5395: LIST
5396: PUSH
5397: LD_INT 21
5399: PUSH
5400: LD_INT 3
5402: PUSH
5403: EMPTY
5404: LIST
5405: LIST
5406: PUSH
5407: EMPTY
5408: LIST
5409: LIST
5410: PPUSH
5411: CALL_OW 69
5415: PUSH
5416: FOR_IN
5417: IFFALSE 5531
// tmp := tmp ^ [ [ GetBType ( i ) , GetBLevel ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
5419: LD_ADDR_VAR 0 2
5423: PUSH
5424: LD_VAR 0 2
5428: PUSH
5429: LD_VAR 0 1
5433: PPUSH
5434: CALL_OW 266
5438: PUSH
5439: LD_VAR 0 1
5443: PPUSH
5444: CALL_OW 267
5448: PUSH
5449: LD_VAR 0 1
5453: PPUSH
5454: CALL_OW 250
5458: PUSH
5459: LD_VAR 0 1
5463: PPUSH
5464: CALL_OW 251
5468: PUSH
5469: LD_VAR 0 1
5473: PPUSH
5474: CALL_OW 254
5478: PUSH
5479: LD_VAR 0 1
5483: PPUSH
5484: LD_INT 1
5486: PPUSH
5487: CALL_OW 268
5491: PUSH
5492: LD_VAR 0 1
5496: PPUSH
5497: LD_INT 2
5499: PPUSH
5500: CALL_OW 268
5504: PUSH
5505: LD_VAR 0 1
5509: PPUSH
5510: CALL_OW 269
5514: PUSH
5515: EMPTY
5516: LIST
5517: LIST
5518: LIST
5519: LIST
5520: LIST
5521: LIST
5522: LIST
5523: LIST
5524: PUSH
5525: EMPTY
5526: LIST
5527: ADD
5528: ST_TO_ADDR
5529: GO 5416
5531: POP
5532: POP
// if tmp then
5533: LD_VAR 0 2
5537: IFFALSE 5551
// SaveVariable ( tmp , buildingsInDelta ) ;
5539: LD_VAR 0 2
5543: PPUSH
5544: LD_STRING buildingsInDelta
5546: PPUSH
5547: CALL_OW 39
// YouWin ;
5551: CALL_OW 103
// end ; end_of_file
5555: PPOPN 5
5557: END
// export function PrepareArabianTroops ( amount , skill , area ) ; var i , un , tmp ; begin
5558: LD_INT 0
5560: PPUSH
5561: PPUSH
5562: PPUSH
5563: PPUSH
// InitHc ;
5564: CALL_OW 19
// InitUc ;
5568: CALL_OW 18
// uc_side := 2 ;
5572: LD_ADDR_OWVAR 20
5576: PUSH
5577: LD_INT 2
5579: ST_TO_ADDR
// uc_nation := 2 ;
5580: LD_ADDR_OWVAR 21
5584: PUSH
5585: LD_INT 2
5587: ST_TO_ADDR
// if not amount then
5588: LD_VAR 0 1
5592: NOT
5593: IFFALSE 5597
// exit ;
5595: GO 5720
// for i = 1 to amount do
5597: LD_ADDR_VAR 0 5
5601: PUSH
5602: DOUBLE
5603: LD_INT 1
5605: DEC
5606: ST_TO_ADDR
5607: LD_VAR 0 1
5611: PUSH
5612: FOR_TO
5613: IFFALSE 5708
// begin PrepareHuman ( false , 1 , skill ) ;
5615: LD_INT 0
5617: PPUSH
5618: LD_INT 1
5620: PPUSH
5621: LD_VAR 0 2
5625: PPUSH
5626: CALL_OW 380
// un := CreateHuman ;
5630: LD_ADDR_VAR 0 6
5634: PUSH
5635: CALL_OW 44
5639: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
5640: LD_ADDR_VAR 0 7
5644: PUSH
5645: LD_VAR 0 7
5649: PPUSH
5650: LD_INT 1
5652: PPUSH
5653: LD_VAR 0 6
5657: PPUSH
5658: CALL_OW 2
5662: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5663: LD_VAR 0 6
5667: PPUSH
5668: LD_VAR 0 3
5672: PPUSH
5673: LD_INT 0
5675: PPUSH
5676: CALL_OW 49
// if i mod 2 = 0 then
5680: LD_VAR 0 5
5684: PUSH
5685: LD_INT 2
5687: MOD
5688: PUSH
5689: LD_INT 0
5691: EQUAL
5692: IFFALSE 5706
// SetTag ( un , 11 ) ;
5694: LD_VAR 0 6
5698: PPUSH
5699: LD_INT 11
5701: PPUSH
5702: CALL_OW 109
// end ;
5706: GO 5612
5708: POP
5709: POP
// result := tmp ;
5710: LD_ADDR_VAR 0 4
5714: PUSH
5715: LD_VAR 0 7
5719: ST_TO_ADDR
// end ;
5720: LD_VAR 0 4
5724: RET
// export ar_forces , ap_killers ; every 0 0$1 trigger Delta do var i , timer , more_troops , skill , eng , un , veh , force ;
5725: LD_EXP 6
5729: IFFALSE 6596
5731: GO 5733
5733: DISABLE
5734: LD_INT 0
5736: PPUSH
5737: PPUSH
5738: PPUSH
5739: PPUSH
5740: PPUSH
5741: PPUSH
5742: PPUSH
5743: PPUSH
// begin more_troops := false ;
5744: LD_ADDR_VAR 0 3
5748: PUSH
5749: LD_INT 0
5751: ST_TO_ADDR
// skill := [ 3 , 4 , 5 ] [ Difficulty ] ;
5752: LD_ADDR_VAR 0 4
5756: PUSH
5757: LD_INT 3
5759: PUSH
5760: LD_INT 4
5762: PUSH
5763: LD_INT 5
5765: PUSH
5766: EMPTY
5767: LIST
5768: LIST
5769: LIST
5770: PUSH
5771: LD_OWVAR 67
5775: ARRAY
5776: ST_TO_ADDR
// timer := [ 5 5$00 , 4 4$00 , 3 3$00 ] [ Difficulty ] ;
5777: LD_ADDR_VAR 0 2
5781: PUSH
5782: LD_INT 10500
5784: PUSH
5785: LD_INT 8400
5787: PUSH
5788: LD_INT 6300
5790: PUSH
5791: EMPTY
5792: LIST
5793: LIST
5794: LIST
5795: PUSH
5796: LD_OWVAR 67
5800: ARRAY
5801: ST_TO_ADDR
// force := [ ] ;
5802: LD_ADDR_VAR 0 8
5806: PUSH
5807: EMPTY
5808: ST_TO_ADDR
// ar_forces := [ ] ;
5809: LD_ADDR_EXP 27
5813: PUSH
5814: EMPTY
5815: ST_TO_ADDR
// ap_killers := [ ] ;
5816: LD_ADDR_EXP 28
5820: PUSH
5821: EMPTY
5822: ST_TO_ADDR
// Wait ( timer ) ;
5823: LD_VAR 0 2
5827: PPUSH
5828: CALL_OW 67
// if Denis and GetSide ( Denis ) = 4 then
5832: LD_EXP 19
5836: PUSH
5837: LD_EXP 19
5841: PPUSH
5842: CALL_OW 255
5846: PUSH
5847: LD_INT 4
5849: EQUAL
5850: AND
5851: IFFALSE 5860
// Wait ( 0 0$45 ) ;
5853: LD_INT 1575
5855: PPUSH
5856: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) then
5860: LD_INT 22
5862: PUSH
5863: LD_INT 1
5865: PUSH
5866: EMPTY
5867: LIST
5868: LIST
5869: PUSH
5870: LD_INT 30
5872: PUSH
5873: LD_INT 4
5875: PUSH
5876: EMPTY
5877: LIST
5878: LIST
5879: PUSH
5880: EMPTY
5881: LIST
5882: LIST
5883: PPUSH
5884: CALL_OW 69
5888: IFFALSE 5905
// begin Wait ( 1 1$25 ) ;
5890: LD_INT 2975
5892: PPUSH
5893: CALL_OW 67
// more_troops := true ;
5897: LD_ADDR_VAR 0 3
5901: PUSH
5902: LD_INT 1
5904: ST_TO_ADDR
// end ; if more_troops then
5905: LD_VAR 0 3
5909: IFFALSE 6097
// begin force := PrepareArabianTroops ( [ 4 , 5 , 6 ] [ Difficulty ] , skill , arArea2 ) ;
5911: LD_ADDR_VAR 0 8
5915: PUSH
5916: LD_INT 4
5918: PUSH
5919: LD_INT 5
5921: PUSH
5922: LD_INT 6
5924: PUSH
5925: EMPTY
5926: LIST
5927: LIST
5928: LIST
5929: PUSH
5930: LD_OWVAR 67
5934: ARRAY
5935: PPUSH
5936: LD_VAR 0 4
5940: PPUSH
5941: LD_INT 14
5943: PPUSH
5944: CALL 5558 0 3
5948: ST_TO_ADDR
// veh := PrepareTank ( 2 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_heavy_machine_gun , ru_gatling_gun ] [ Difficulty ] , 90 ) ;
5949: LD_ADDR_VAR 0 7
5953: PUSH
5954: LD_INT 2
5956: PPUSH
5957: LD_INT 3
5959: PPUSH
5960: LD_INT 22
5962: PPUSH
5963: LD_INT 1
5965: PPUSH
5966: LD_INT 1
5968: PPUSH
5969: LD_INT 42
5971: PUSH
5972: LD_INT 42
5974: PUSH
5975: LD_INT 43
5977: PUSH
5978: EMPTY
5979: LIST
5980: LIST
5981: LIST
5982: PUSH
5983: LD_OWVAR 67
5987: ARRAY
5988: PPUSH
5989: LD_INT 90
5991: PPUSH
5992: CALL 490 0 7
5996: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5997: LD_VAR 0 7
6001: PPUSH
6002: LD_INT 4
6004: PPUSH
6005: CALL_OW 233
// PlaceUnitArea ( veh , arArea1 , false ) ;
6009: LD_VAR 0 7
6013: PPUSH
6014: LD_INT 13
6016: PPUSH
6017: LD_INT 0
6019: PPUSH
6020: CALL_OW 49
// uc_side := 2 ;
6024: LD_ADDR_OWVAR 20
6028: PUSH
6029: LD_INT 2
6031: ST_TO_ADDR
// uc_nation := 2 ;
6032: LD_ADDR_OWVAR 21
6036: PUSH
6037: LD_INT 2
6039: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
6040: LD_INT 0
6042: PPUSH
6043: LD_INT 1
6045: PPUSH
6046: LD_VAR 0 4
6050: PPUSH
6051: CALL_OW 380
// un := CreateHuman ;
6055: LD_ADDR_VAR 0 6
6059: PUSH
6060: CALL_OW 44
6064: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
6065: LD_VAR 0 6
6069: PPUSH
6070: LD_VAR 0 7
6074: PPUSH
6075: CALL_OW 52
// force := force ^ un ;
6079: LD_ADDR_VAR 0 8
6083: PUSH
6084: LD_VAR 0 8
6088: PUSH
6089: LD_VAR 0 6
6093: ADD
6094: ST_TO_ADDR
// end else
6095: GO 6135
// begin force := PrepareArabianTroops ( [ 3 , 4 , 5 ] [ Difficulty ] , skill , arArea2 ) ;
6097: LD_ADDR_VAR 0 8
6101: PUSH
6102: LD_INT 3
6104: PUSH
6105: LD_INT 4
6107: PUSH
6108: LD_INT 5
6110: PUSH
6111: EMPTY
6112: LIST
6113: LIST
6114: LIST
6115: PUSH
6116: LD_OWVAR 67
6120: ARRAY
6121: PPUSH
6122: LD_VAR 0 4
6126: PPUSH
6127: LD_INT 14
6129: PPUSH
6130: CALL 5558 0 3
6134: ST_TO_ADDR
// end ; if force then
6135: LD_VAR 0 8
6139: IFFALSE 6151
// ar_forces := force ;
6141: LD_ADDR_EXP 27
6145: PUSH
6146: LD_VAR 0 8
6150: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
6151: LD_INT 35
6153: PPUSH
6154: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 ;
6158: LD_INT 22
6160: PUSH
6161: LD_INT 2
6163: PUSH
6164: EMPTY
6165: LIST
6166: LIST
6167: PUSH
6168: LD_INT 21
6170: PUSH
6171: LD_INT 1
6173: PUSH
6174: EMPTY
6175: LIST
6176: LIST
6177: PUSH
6178: EMPTY
6179: LIST
6180: LIST
6181: PPUSH
6182: CALL_OW 69
6186: PUSH
6187: LD_INT 0
6189: EQUAL
6190: IFFALSE 6151
// Wait ( timer ) ;
6192: LD_VAR 0 2
6196: PPUSH
6197: CALL_OW 67
// force := PrepareArabianTroops ( [ 4 , 5 , 6 ] [ Difficulty ] , skill , [ arArea1 , arArea2 ] [ rand ( 1 , 2 ) ] ) ;
6201: LD_ADDR_VAR 0 8
6205: PUSH
6206: LD_INT 4
6208: PUSH
6209: LD_INT 5
6211: PUSH
6212: LD_INT 6
6214: PUSH
6215: EMPTY
6216: LIST
6217: LIST
6218: LIST
6219: PUSH
6220: LD_OWVAR 67
6224: ARRAY
6225: PPUSH
6226: LD_VAR 0 4
6230: PPUSH
6231: LD_INT 13
6233: PUSH
6234: LD_INT 14
6236: PUSH
6237: EMPTY
6238: LIST
6239: LIST
6240: PUSH
6241: LD_INT 1
6243: PPUSH
6244: LD_INT 2
6246: PPUSH
6247: CALL_OW 12
6251: ARRAY
6252: PPUSH
6253: CALL 5558 0 3
6257: ST_TO_ADDR
// if Difficulty > 1 and Delta then
6258: LD_OWVAR 67
6262: PUSH
6263: LD_INT 1
6265: GREATER
6266: PUSH
6267: LD_EXP 6
6271: AND
6272: IFFALSE 6351
// begin uc_side := 2 ;
6274: LD_ADDR_OWVAR 20
6278: PUSH
6279: LD_INT 2
6281: ST_TO_ADDR
// uc_nation := 2 ;
6282: LD_ADDR_OWVAR 21
6286: PUSH
6287: LD_INT 2
6289: ST_TO_ADDR
// PrepareHuman ( false , 2 , skill ) ;
6290: LD_INT 0
6292: PPUSH
6293: LD_INT 2
6295: PPUSH
6296: LD_VAR 0 4
6300: PPUSH
6301: CALL_OW 380
// eng := CreateHuman ;
6305: LD_ADDR_VAR 0 5
6309: PUSH
6310: CALL_OW 44
6314: ST_TO_ADDR
// PlaceUnitArea ( eng , arArea1 , false ) ;
6315: LD_VAR 0 5
6319: PPUSH
6320: LD_INT 13
6322: PPUSH
6323: LD_INT 0
6325: PPUSH
6326: CALL_OW 49
// Wait ( 3 ) ;
6330: LD_INT 3
6332: PPUSH
6333: CALL_OW 67
// AddComEnterUnit ( eng , Delta ) ;
6337: LD_VAR 0 5
6341: PPUSH
6342: LD_EXP 6
6346: PPUSH
6347: CALL_OW 180
// end ; if force then
6351: LD_VAR 0 8
6355: IFFALSE 6367
// ar_forces := force ;
6357: LD_ADDR_EXP 27
6361: PUSH
6362: LD_VAR 0 8
6366: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
6367: LD_INT 35
6369: PPUSH
6370: CALL_OW 67
// if eng then
6374: LD_VAR 0 5
6378: IFFALSE 6432
// if GetSide ( Delta ) = 2 and IsOk ( eng ) and not IsInUnit ( eng ) then
6380: LD_EXP 6
6384: PPUSH
6385: CALL_OW 255
6389: PUSH
6390: LD_INT 2
6392: EQUAL
6393: PUSH
6394: LD_VAR 0 5
6398: PPUSH
6399: CALL_OW 302
6403: AND
6404: PUSH
6405: LD_VAR 0 5
6409: PPUSH
6410: CALL_OW 310
6414: NOT
6415: AND
6416: IFFALSE 6432
// ComEnterUnit ( eng , Delta ) ;
6418: LD_VAR 0 5
6422: PPUSH
6423: LD_EXP 6
6427: PPUSH
6428: CALL_OW 120
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 ;
6432: LD_INT 22
6434: PUSH
6435: LD_INT 2
6437: PUSH
6438: EMPTY
6439: LIST
6440: LIST
6441: PUSH
6442: LD_INT 21
6444: PUSH
6445: LD_INT 1
6447: PUSH
6448: EMPTY
6449: LIST
6450: LIST
6451: PUSH
6452: EMPTY
6453: LIST
6454: LIST
6455: PPUSH
6456: CALL_OW 69
6460: PUSH
6461: LD_INT 0
6463: EQUAL
6464: IFFALSE 6367
// Wait ( 2 2$00 ) ;
6466: LD_INT 4200
6468: PPUSH
6469: CALL_OW 67
// ap_killers := PrepareArabianTroops ( [ 1 , 2 , 2 ] [ Difficulty ] , skill , arArea1 ) ;
6473: LD_ADDR_EXP 28
6477: PUSH
6478: LD_INT 1
6480: PUSH
6481: LD_INT 2
6483: PUSH
6484: LD_INT 2
6486: PUSH
6487: EMPTY
6488: LIST
6489: LIST
6490: LIST
6491: PUSH
6492: LD_OWVAR 67
6496: ARRAY
6497: PPUSH
6498: LD_VAR 0 4
6502: PPUSH
6503: LD_INT 13
6505: PPUSH
6506: CALL 5558 0 3
6510: ST_TO_ADDR
// Wait ( timer * 2 ) ;
6511: LD_VAR 0 2
6515: PUSH
6516: LD_INT 2
6518: MUL
6519: PPUSH
6520: CALL_OW 67
// ar_forces := PrepareArabianTroops ( [ 5 , 6 , 7 ] [ Difficulty ] , skill , arArea1 ) ^ PrepareArabianTroops ( [ 3 , 4 , 4 ] [ Difficulty ] , skill , arArea2 ) ;
6524: LD_ADDR_EXP 27
6528: PUSH
6529: LD_INT 5
6531: PUSH
6532: LD_INT 6
6534: PUSH
6535: LD_INT 7
6537: PUSH
6538: EMPTY
6539: LIST
6540: LIST
6541: LIST
6542: PUSH
6543: LD_OWVAR 67
6547: ARRAY
6548: PPUSH
6549: LD_VAR 0 4
6553: PPUSH
6554: LD_INT 13
6556: PPUSH
6557: CALL 5558 0 3
6561: PUSH
6562: LD_INT 3
6564: PUSH
6565: LD_INT 4
6567: PUSH
6568: LD_INT 4
6570: PUSH
6571: EMPTY
6572: LIST
6573: LIST
6574: LIST
6575: PUSH
6576: LD_OWVAR 67
6580: ARRAY
6581: PPUSH
6582: LD_VAR 0 4
6586: PPUSH
6587: LD_INT 14
6589: PPUSH
6590: CALL 5558 0 3
6594: ADD
6595: ST_TO_ADDR
// end ;
6596: PPOPN 8
6598: END
// every 0 0$03 trigger ar_forces do var i , target ;
6599: LD_EXP 27
6603: IFFALSE 6801
6605: GO 6607
6607: DISABLE
6608: LD_INT 0
6610: PPUSH
6611: PPUSH
// begin enable ;
6612: ENABLE
// if not ar_forces then
6613: LD_EXP 27
6617: NOT
6618: IFFALSE 6622
// exit ;
6620: GO 6801
// if Delta then
6622: LD_EXP 6
6626: IFFALSE 6640
// target := Delta else
6628: LD_ADDR_VAR 0 2
6632: PUSH
6633: LD_EXP 6
6637: ST_TO_ADDR
6638: GO 6650
// target := JMM ;
6640: LD_ADDR_VAR 0 2
6644: PUSH
6645: LD_EXP 16
6649: ST_TO_ADDR
// for i in ar_forces do
6650: LD_ADDR_VAR 0 1
6654: PUSH
6655: LD_EXP 27
6659: PUSH
6660: FOR_IN
6661: IFFALSE 6799
// begin if i in FilterAllUnits ( [ f_driving ] ) then
6663: LD_VAR 0 1
6667: PUSH
6668: LD_INT 55
6670: PUSH
6671: EMPTY
6672: LIST
6673: PPUSH
6674: CALL_OW 69
6678: IN
6679: IFFALSE 6722
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , IsInUnit ( i ) ) ) else
6681: LD_VAR 0 1
6685: PPUSH
6686: LD_INT 22
6688: PUSH
6689: LD_INT 1
6691: PUSH
6692: EMPTY
6693: LIST
6694: LIST
6695: PPUSH
6696: CALL_OW 69
6700: PPUSH
6701: LD_VAR 0 1
6705: PPUSH
6706: CALL_OW 310
6710: PPUSH
6711: CALL_OW 74
6715: PPUSH
6716: CALL_OW 115
6720: GO 6797
// if GetDistUnits ( i , target ) > 30 then
6722: LD_VAR 0 1
6726: PPUSH
6727: LD_VAR 0 2
6731: PPUSH
6732: CALL_OW 296
6736: PUSH
6737: LD_INT 30
6739: GREATER
6740: IFFALSE 6773
// ComAgressiveMove ( i , GetX ( target ) , GetY ( target ) ) else
6742: LD_VAR 0 1
6746: PPUSH
6747: LD_VAR 0 2
6751: PPUSH
6752: CALL_OW 250
6756: PPUSH
6757: LD_VAR 0 2
6761: PPUSH
6762: CALL_OW 251
6766: PPUSH
6767: CALL_OW 114
6771: GO 6797
// Attack ( i , FilterAllUnits ( [ f_enemy , 2 ] ) ) ;
6773: LD_VAR 0 1
6777: PPUSH
6778: LD_INT 81
6780: PUSH
6781: LD_INT 2
6783: PUSH
6784: EMPTY
6785: LIST
6786: LIST
6787: PPUSH
6788: CALL_OW 69
6792: PPUSH
6793: CALL 795 0 2
// end ;
6797: GO 6660
6799: POP
6800: POP
// end ;
6801: PPOPN 2
6803: END
// every 0 0$01 trigger ap_killers do var filter , i , target ;
6804: LD_EXP 28
6808: IFFALSE 6968
6810: GO 6812
6812: DISABLE
6813: LD_INT 0
6815: PPUSH
6816: PPUSH
6817: PPUSH
// begin enable ;
6818: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) ;
6819: LD_ADDR_VAR 0 1
6823: PUSH
6824: LD_INT 22
6826: PUSH
6827: LD_INT 0
6829: PUSH
6830: EMPTY
6831: LIST
6832: LIST
6833: PUSH
6834: LD_INT 25
6836: PUSH
6837: LD_INT 12
6839: PUSH
6840: EMPTY
6841: LIST
6842: LIST
6843: PUSH
6844: EMPTY
6845: LIST
6846: LIST
6847: PPUSH
6848: CALL_OW 69
6852: ST_TO_ADDR
// if not filter then
6853: LD_VAR 0 1
6857: NOT
6858: IFFALSE 6885
// begin ar_forces := ar_forces ^ ap_killers ;
6860: LD_ADDR_EXP 27
6864: PUSH
6865: LD_EXP 27
6869: PUSH
6870: LD_EXP 28
6874: ADD
6875: ST_TO_ADDR
// ap_killers := [ ] ;
6876: LD_ADDR_EXP 28
6880: PUSH
6881: EMPTY
6882: ST_TO_ADDR
// exit ;
6883: GO 6968
// end ; for i in ap_killers do
6885: LD_ADDR_VAR 0 2
6889: PUSH
6890: LD_EXP 28
6894: PUSH
6895: FOR_IN
6896: IFFALSE 6966
// begin if not IsOk ( i ) then
6898: LD_VAR 0 2
6902: PPUSH
6903: CALL_OW 302
6907: NOT
6908: IFFALSE 6912
// continue ;
6910: GO 6895
// if not HasTask ( i ) then
6912: LD_VAR 0 2
6916: PPUSH
6917: CALL_OW 314
6921: NOT
6922: IFFALSE 6944
// target := NearestUnitToUnit ( filter , i ) ;
6924: LD_ADDR_VAR 0 3
6928: PUSH
6929: LD_VAR 0 1
6933: PPUSH
6934: LD_VAR 0 2
6938: PPUSH
6939: CALL_OW 74
6943: ST_TO_ADDR
// if target then
6944: LD_VAR 0 3
6948: IFFALSE 6964
// ComAttackUnit ( i , target ) ;
6950: LD_VAR 0 2
6954: PPUSH
6955: LD_VAR 0 3
6959: PPUSH
6960: CALL_OW 115
// end ;
6964: GO 6895
6966: POP
6967: POP
// end ; end_of_file
6968: PPOPN 3
6970: END
// every 0 0$40 + 0 0$2 trigger Delta do var i , counter , cr ;
6971: LD_EXP 6
6975: IFFALSE 7107
6977: GO 6979
6979: DISABLE
6980: LD_INT 0
6982: PPUSH
6983: PPUSH
6984: PPUSH
// begin counter := [ 300 , 250 , 220 ] [ Difficulty ] ;
6985: LD_ADDR_VAR 0 2
6989: PUSH
6990: LD_INT 300
6992: PUSH
6993: LD_INT 250
6995: PUSH
6996: LD_INT 220
6998: PUSH
6999: EMPTY
7000: LIST
7001: LIST
7002: LIST
7003: PUSH
7004: LD_OWVAR 67
7008: ARRAY
7009: ST_TO_ADDR
// CreateCratesArea ( Rand ( 1 , 3 ) , cratesArea , true ) ;
7010: LD_INT 1
7012: PPUSH
7013: LD_INT 3
7015: PPUSH
7016: CALL_OW 12
7020: PPUSH
7021: LD_INT 7
7023: PPUSH
7024: LD_INT 1
7026: PPUSH
7027: CALL_OW 55
// repeat wait ( rand ( 1 1$30 , 2 2$20 ) ) ;
7031: LD_INT 3150
7033: PPUSH
7034: LD_INT 4900
7036: PPUSH
7037: CALL_OW 12
7041: PPUSH
7042: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
7046: LD_ADDR_VAR 0 3
7050: PUSH
7051: LD_INT 1
7053: PPUSH
7054: LD_INT 5
7056: PPUSH
7057: CALL_OW 12
7061: ST_TO_ADDR
// CreateCratesArea ( cr , cratesArea , true ) ;
7062: LD_VAR 0 3
7066: PPUSH
7067: LD_INT 7
7069: PPUSH
7070: LD_INT 1
7072: PPUSH
7073: CALL_OW 55
// counter := counter - cr * 10 ;
7077: LD_ADDR_VAR 0 2
7081: PUSH
7082: LD_VAR 0 2
7086: PUSH
7087: LD_VAR 0 3
7091: PUSH
7092: LD_INT 10
7094: MUL
7095: MINUS
7096: ST_TO_ADDR
// until counter <= 0 ;
7097: LD_VAR 0 2
7101: PUSH
7102: LD_INT 0
7104: LESSEQUAL
7105: IFFALSE 7031
// end ;
7107: PPOPN 3
7109: END
// every 0 0$03 trigger not Delta do var i ;
7110: LD_EXP 6
7114: NOT
7115: IFFALSE 7185
7117: GO 7119
7119: DISABLE
7120: LD_INT 0
7122: PPUSH
// begin for i = 1 to 4 - Difficulty do
7123: LD_ADDR_VAR 0 1
7127: PUSH
7128: DOUBLE
7129: LD_INT 1
7131: DEC
7132: ST_TO_ADDR
7133: LD_INT 4
7135: PUSH
7136: LD_OWVAR 67
7140: MINUS
7141: PUSH
7142: FOR_TO
7143: IFFALSE 7183
// begin CreateCratesArea ( rand ( 2 , 5 ) , deltaMainArea , true ) ;
7145: LD_INT 2
7147: PPUSH
7148: LD_INT 5
7150: PPUSH
7151: CALL_OW 12
7155: PPUSH
7156: LD_INT 8
7158: PPUSH
7159: LD_INT 1
7161: PPUSH
7162: CALL_OW 55
// Wait ( rand ( 0 0$16 , 0 0$39 ) ) ;
7166: LD_INT 560
7168: PPUSH
7169: LD_INT 1365
7171: PPUSH
7172: CALL_OW 12
7176: PPUSH
7177: CALL_OW 67
// end ;
7181: GO 7142
7183: POP
7184: POP
// end ;
7185: PPOPN 1
7187: END
// every 3 3$00 trigger tick < 15 15$00 do
7188: LD_OWVAR 1
7192: PUSH
7193: LD_INT 31500
7195: LESS
7196: IFFALSE 7256
7198: GO 7200
7200: DISABLE
// begin enable ;
7201: ENABLE
// CreateCratesAnyWhere ( rand ( 1 , 3 ) , true ) ;
7202: LD_INT 1
7204: PPUSH
7205: LD_INT 3
7207: PPUSH
7208: CALL_OW 12
7212: PPUSH
7213: LD_INT 1
7215: PPUSH
7216: CALL_OW 57
// Wait ( rand ( 0 0$38 , 0 0$59 ) ) ;
7220: LD_INT 1330
7222: PPUSH
7223: LD_INT 2065
7225: PPUSH
7226: CALL_OW 12
7230: PPUSH
7231: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 4 ) , riverArea , true ) ;
7235: LD_INT 1
7237: PPUSH
7238: LD_INT 4
7240: PPUSH
7241: CALL_OW 12
7245: PPUSH
7246: LD_INT 15
7248: PPUSH
7249: LD_INT 1
7251: PPUSH
7252: CALL_OW 55
// end ; end_of_file
7256: END
// on UnitDestroyed ( un ) do begin if un = JMM then
7257: LD_VAR 0 1
7261: PUSH
7262: LD_EXP 16
7266: EQUAL
7267: IFFALSE 7276
// YouLost ( JMM ) ;
7269: LD_STRING JMM
7271: PPUSH
7272: CALL_OW 104
// if un = Delta then
7276: LD_VAR 0 1
7280: PUSH
7281: LD_EXP 6
7285: EQUAL
7286: IFFALSE 7309
// begin Delta := 0 ;
7288: LD_ADDR_EXP 6
7292: PUSH
7293: LD_INT 0
7295: ST_TO_ADDR
// SetRestrict ( b_depot , 1 , true ) ;
7296: LD_INT 0
7298: PPUSH
7299: LD_INT 1
7301: PPUSH
7302: LD_INT 1
7304: PPUSH
7305: CALL_OW 324
// end ; if un in ar_forces then
7309: LD_VAR 0 1
7313: PUSH
7314: LD_EXP 27
7318: IN
7319: IFFALSE 7337
// ar_forces := ar_forces diff un ;
7321: LD_ADDR_EXP 27
7325: PUSH
7326: LD_EXP 27
7330: PUSH
7331: LD_VAR 0 1
7335: DIFF
7336: ST_TO_ADDR
// if un in ap_killers then
7337: LD_VAR 0 1
7341: PUSH
7342: LD_EXP 28
7346: IN
7347: IFFALSE 7365
// ap_killers := ap_killers diff un ;
7349: LD_ADDR_EXP 28
7353: PUSH
7354: LD_EXP 28
7358: PUSH
7359: LD_VAR 0 1
7363: DIFF
7364: ST_TO_ADDR
// if un in FilterAllUnits ( [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ) then
7365: LD_VAR 0 1
7369: PUSH
7370: LD_INT 2
7372: PUSH
7373: LD_INT 25
7375: PUSH
7376: LD_INT 12
7378: PUSH
7379: EMPTY
7380: LIST
7381: LIST
7382: PUSH
7383: LD_INT 25
7385: PUSH
7386: LD_INT 16
7388: PUSH
7389: EMPTY
7390: LIST
7391: LIST
7392: PUSH
7393: EMPTY
7394: LIST
7395: LIST
7396: LIST
7397: PPUSH
7398: CALL_OW 69
7402: IN
7403: IFFALSE 7419
// apeKillCounter := apeKillCounter + 1 ;
7405: LD_ADDR_EXP 15
7409: PUSH
7410: LD_EXP 15
7414: PUSH
7415: LD_INT 1
7417: PLUS
7418: ST_TO_ADDR
// end ;
7419: PPOPN 1
7421: END
// on Contact ( s1 , s2 ) do if s1 = 1 and s2 = 2 and not arab_spotted then
7422: LD_VAR 0 1
7426: PUSH
7427: LD_INT 1
7429: EQUAL
7430: PUSH
7431: LD_VAR 0 2
7435: PUSH
7436: LD_INT 2
7438: EQUAL
7439: AND
7440: PUSH
7441: LD_EXP 13
7445: NOT
7446: AND
7447: IFFALSE 7457
// arab_spotted := true ;
7449: LD_ADDR_EXP 13
7453: PUSH
7454: LD_INT 1
7456: ST_TO_ADDR
7457: PPOPN 2
7459: END
// on EndTheMissionRaised ( p ) do begin end_the_mission_allowed := false ;
7460: LD_ADDR_OWVAR 57
7464: PUSH
7465: LD_INT 0
7467: ST_TO_ADDR
// end_mission := true ;
7468: LD_ADDR_EXP 14
7472: PUSH
7473: LD_INT 1
7475: ST_TO_ADDR
// end ;
7476: PPOPN 1
7478: END
// on ApemanTamed ( apeman , sci ) do begin if GetSide ( sci ) = 1 then
7479: LD_VAR 0 2
7483: PPUSH
7484: CALL_OW 255
7488: PUSH
7489: LD_INT 1
7491: EQUAL
7492: IFFALSE 7508
// apeman_counter := apeman_counter + 1 ;
7494: LD_ADDR_EXP 12
7498: PUSH
7499: LD_EXP 12
7503: PUSH
7504: LD_INT 1
7506: PLUS
7507: ST_TO_ADDR
// if not first_apeman_tamed then
7508: LD_EXP 8
7512: NOT
7513: IFFALSE 7713
// begin first_apeman_tamed := true ;
7515: LD_ADDR_EXP 8
7519: PUSH
7520: LD_INT 1
7522: ST_TO_ADDR
// if sci = Gladstone then
7523: LD_VAR 0 2
7527: PUSH
7528: LD_EXP 17
7532: EQUAL
7533: IFFALSE 7547
// Say ( Gladstone , D7b-Glad-1 ) ;
7535: LD_EXP 17
7539: PPUSH
7540: LD_STRING D7b-Glad-1
7542: PPUSH
7543: CALL_OW 88
// if sci = Denis then
7547: LD_VAR 0 2
7551: PUSH
7552: LD_EXP 19
7556: EQUAL
7557: IFFALSE 7571
// Say ( Denis , D7a-Den-1 ) ;
7559: LD_EXP 19
7563: PPUSH
7564: LD_STRING D7a-Den-1
7566: PPUSH
7567: CALL_OW 88
// if not sci in [ JMM , Gladstone , Denis , Lisa , Frank , Bobby , Cyrus , Donaldson ] then
7571: LD_VAR 0 2
7575: PUSH
7576: LD_EXP 16
7580: PUSH
7581: LD_EXP 17
7585: PUSH
7586: LD_EXP 19
7590: PUSH
7591: LD_EXP 22
7595: PUSH
7596: LD_EXP 23
7600: PUSH
7601: LD_EXP 24
7605: PUSH
7606: LD_EXP 25
7610: PUSH
7611: LD_EXP 21
7615: PUSH
7616: EMPTY
7617: LIST
7618: LIST
7619: LIST
7620: LIST
7621: LIST
7622: LIST
7623: LIST
7624: LIST
7625: IN
7626: NOT
7627: IFFALSE 7670
// begin if GetSex ( sci ) = sex_male then
7629: LD_VAR 0 2
7633: PPUSH
7634: CALL_OW 258
7638: PUSH
7639: LD_INT 1
7641: EQUAL
7642: IFFALSE 7658
// Say ( sci , D7c-Sci1-1 ) else
7644: LD_VAR 0 2
7648: PPUSH
7649: LD_STRING D7c-Sci1-1
7651: PPUSH
7652: CALL_OW 88
7656: GO 7670
// Say ( sci , D7c-FSci1-1 ) ;
7658: LD_VAR 0 2
7662: PPUSH
7663: LD_STRING D7c-FSci1-1
7665: PPUSH
7666: CALL_OW 88
// end ; if not sci = Gladstone then
7670: LD_VAR 0 2
7674: PUSH
7675: LD_EXP 17
7679: EQUAL
7680: NOT
7681: IFFALSE 7695
// Say ( Gladstone , D7c-Glad-1 ) ;
7683: LD_EXP 17
7687: PPUSH
7688: LD_STRING D7c-Glad-1
7690: PPUSH
7691: CALL_OW 88
// if Lisa then
7695: LD_EXP 22
7699: IFFALSE 7713
// Say ( Lisa , D8-Lisa-1 ) ;
7701: LD_EXP 22
7705: PPUSH
7706: LD_STRING D8-Lisa-1
7708: PPUSH
7709: CALL_OW 88
// end ; end ; end_of_file
7713: PPOPN 2
7715: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
7716: GO 7718
7718: DISABLE
// begin ru_radar := 98 ;
7719: LD_ADDR_EXP 29
7723: PUSH
7724: LD_INT 98
7726: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
7727: LD_ADDR_EXP 30
7731: PUSH
7732: LD_INT 89
7734: ST_TO_ADDR
// us_hack := 99 ;
7735: LD_ADDR_EXP 31
7739: PUSH
7740: LD_INT 99
7742: ST_TO_ADDR
// us_artillery := 97 ;
7743: LD_ADDR_EXP 32
7747: PUSH
7748: LD_INT 97
7750: ST_TO_ADDR
// ar_bio_bomb := 91 ;
7751: LD_ADDR_EXP 33
7755: PUSH
7756: LD_INT 91
7758: ST_TO_ADDR
// end ; end_of_file end_of_file
7759: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
7760: GO 7762
7762: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
7763: LD_STRING initStreamRollete();
7765: PPUSH
7766: CALL_OW 559
// InitStreamMode ;
7770: CALL 7779 0 0
// DefineStreamItems ( ) ;
7774: CALL 8219 0 0
// end ;
7778: END
// function InitStreamMode ; begin
7779: LD_INT 0
7781: PPUSH
// streamModeActive := false ;
7782: LD_ADDR_EXP 34
7786: PUSH
7787: LD_INT 0
7789: ST_TO_ADDR
// normalCounter := 26 ;
7790: LD_ADDR_EXP 35
7794: PUSH
7795: LD_INT 26
7797: ST_TO_ADDR
// hardcoreCounter := 12 ;
7798: LD_ADDR_EXP 36
7802: PUSH
7803: LD_INT 12
7805: ST_TO_ADDR
// sRocket := false ;
7806: LD_ADDR_EXP 39
7810: PUSH
7811: LD_INT 0
7813: ST_TO_ADDR
// sSpeed := false ;
7814: LD_ADDR_EXP 38
7818: PUSH
7819: LD_INT 0
7821: ST_TO_ADDR
// sEngine := false ;
7822: LD_ADDR_EXP 40
7826: PUSH
7827: LD_INT 0
7829: ST_TO_ADDR
// sSpec := false ;
7830: LD_ADDR_EXP 37
7834: PUSH
7835: LD_INT 0
7837: ST_TO_ADDR
// sLevel := false ;
7838: LD_ADDR_EXP 41
7842: PUSH
7843: LD_INT 0
7845: ST_TO_ADDR
// sArmoury := false ;
7846: LD_ADDR_EXP 42
7850: PUSH
7851: LD_INT 0
7853: ST_TO_ADDR
// sRadar := false ;
7854: LD_ADDR_EXP 43
7858: PUSH
7859: LD_INT 0
7861: ST_TO_ADDR
// sBunker := false ;
7862: LD_ADDR_EXP 44
7866: PUSH
7867: LD_INT 0
7869: ST_TO_ADDR
// sHack := false ;
7870: LD_ADDR_EXP 45
7874: PUSH
7875: LD_INT 0
7877: ST_TO_ADDR
// sFire := false ;
7878: LD_ADDR_EXP 46
7882: PUSH
7883: LD_INT 0
7885: ST_TO_ADDR
// sRefresh := false ;
7886: LD_ADDR_EXP 47
7890: PUSH
7891: LD_INT 0
7893: ST_TO_ADDR
// sExp := false ;
7894: LD_ADDR_EXP 48
7898: PUSH
7899: LD_INT 0
7901: ST_TO_ADDR
// sDepot := false ;
7902: LD_ADDR_EXP 49
7906: PUSH
7907: LD_INT 0
7909: ST_TO_ADDR
// sFlag := false ;
7910: LD_ADDR_EXP 50
7914: PUSH
7915: LD_INT 0
7917: ST_TO_ADDR
// sKamikadze := false ;
7918: LD_ADDR_EXP 58
7922: PUSH
7923: LD_INT 0
7925: ST_TO_ADDR
// sTroll := false ;
7926: LD_ADDR_EXP 59
7930: PUSH
7931: LD_INT 0
7933: ST_TO_ADDR
// sSlow := false ;
7934: LD_ADDR_EXP 60
7938: PUSH
7939: LD_INT 0
7941: ST_TO_ADDR
// sLack := false ;
7942: LD_ADDR_EXP 61
7946: PUSH
7947: LD_INT 0
7949: ST_TO_ADDR
// sTank := false ;
7950: LD_ADDR_EXP 63
7954: PUSH
7955: LD_INT 0
7957: ST_TO_ADDR
// sRemote := false ;
7958: LD_ADDR_EXP 64
7962: PUSH
7963: LD_INT 0
7965: ST_TO_ADDR
// sPowell := false ;
7966: LD_ADDR_EXP 65
7970: PUSH
7971: LD_INT 0
7973: ST_TO_ADDR
// sTeleport := false ;
7974: LD_ADDR_EXP 68
7978: PUSH
7979: LD_INT 0
7981: ST_TO_ADDR
// sOilTower := false ;
7982: LD_ADDR_EXP 70
7986: PUSH
7987: LD_INT 0
7989: ST_TO_ADDR
// sShovel := false ;
7990: LD_ADDR_EXP 71
7994: PUSH
7995: LD_INT 0
7997: ST_TO_ADDR
// sSheik := false ;
7998: LD_ADDR_EXP 72
8002: PUSH
8003: LD_INT 0
8005: ST_TO_ADDR
// sEarthquake := false ;
8006: LD_ADDR_EXP 74
8010: PUSH
8011: LD_INT 0
8013: ST_TO_ADDR
// sAI := false ;
8014: LD_ADDR_EXP 75
8018: PUSH
8019: LD_INT 0
8021: ST_TO_ADDR
// sCargo := false ;
8022: LD_ADDR_EXP 78
8026: PUSH
8027: LD_INT 0
8029: ST_TO_ADDR
// sDLaser := false ;
8030: LD_ADDR_EXP 79
8034: PUSH
8035: LD_INT 0
8037: ST_TO_ADDR
// sExchange := false ;
8038: LD_ADDR_EXP 80
8042: PUSH
8043: LD_INT 0
8045: ST_TO_ADDR
// sFac := false ;
8046: LD_ADDR_EXP 81
8050: PUSH
8051: LD_INT 0
8053: ST_TO_ADDR
// sPower := false ;
8054: LD_ADDR_EXP 82
8058: PUSH
8059: LD_INT 0
8061: ST_TO_ADDR
// sRandom := false ;
8062: LD_ADDR_EXP 83
8066: PUSH
8067: LD_INT 0
8069: ST_TO_ADDR
// sShield := false ;
8070: LD_ADDR_EXP 84
8074: PUSH
8075: LD_INT 0
8077: ST_TO_ADDR
// sTime := false ;
8078: LD_ADDR_EXP 85
8082: PUSH
8083: LD_INT 0
8085: ST_TO_ADDR
// sTools := false ;
8086: LD_ADDR_EXP 86
8090: PUSH
8091: LD_INT 0
8093: ST_TO_ADDR
// sSold := false ;
8094: LD_ADDR_EXP 51
8098: PUSH
8099: LD_INT 0
8101: ST_TO_ADDR
// sDiff := false ;
8102: LD_ADDR_EXP 52
8106: PUSH
8107: LD_INT 0
8109: ST_TO_ADDR
// sFog := false ;
8110: LD_ADDR_EXP 55
8114: PUSH
8115: LD_INT 0
8117: ST_TO_ADDR
// sReset := false ;
8118: LD_ADDR_EXP 56
8122: PUSH
8123: LD_INT 0
8125: ST_TO_ADDR
// sSun := false ;
8126: LD_ADDR_EXP 57
8130: PUSH
8131: LD_INT 0
8133: ST_TO_ADDR
// sTiger := false ;
8134: LD_ADDR_EXP 53
8138: PUSH
8139: LD_INT 0
8141: ST_TO_ADDR
// sBomb := false ;
8142: LD_ADDR_EXP 54
8146: PUSH
8147: LD_INT 0
8149: ST_TO_ADDR
// sWound := false ;
8150: LD_ADDR_EXP 62
8154: PUSH
8155: LD_INT 0
8157: ST_TO_ADDR
// sBetray := false ;
8158: LD_ADDR_EXP 66
8162: PUSH
8163: LD_INT 0
8165: ST_TO_ADDR
// sContamin := false ;
8166: LD_ADDR_EXP 67
8170: PUSH
8171: LD_INT 0
8173: ST_TO_ADDR
// sOil := false ;
8174: LD_ADDR_EXP 69
8178: PUSH
8179: LD_INT 0
8181: ST_TO_ADDR
// sStu := false ;
8182: LD_ADDR_EXP 73
8186: PUSH
8187: LD_INT 0
8189: ST_TO_ADDR
// sBazooka := false ;
8190: LD_ADDR_EXP 76
8194: PUSH
8195: LD_INT 0
8197: ST_TO_ADDR
// sMortar := false ;
8198: LD_ADDR_EXP 77
8202: PUSH
8203: LD_INT 0
8205: ST_TO_ADDR
// sRanger := false ;
8206: LD_ADDR_EXP 87
8210: PUSH
8211: LD_INT 0
8213: ST_TO_ADDR
// end ;
8214: LD_VAR 0 1
8218: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
8219: LD_INT 0
8221: PPUSH
8222: PPUSH
8223: PPUSH
8224: PPUSH
8225: PPUSH
// result := [ ] ;
8226: LD_ADDR_VAR 0 1
8230: PUSH
8231: EMPTY
8232: ST_TO_ADDR
// if campaign_id = 1 then
8233: LD_OWVAR 69
8237: PUSH
8238: LD_INT 1
8240: EQUAL
8241: IFFALSE 11189
// begin case mission_number of 1 :
8243: LD_OWVAR 70
8247: PUSH
8248: LD_INT 1
8250: DOUBLE
8251: EQUAL
8252: IFTRUE 8256
8254: GO 8320
8256: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
8257: LD_ADDR_VAR 0 1
8261: PUSH
8262: LD_INT 2
8264: PUSH
8265: LD_INT 4
8267: PUSH
8268: LD_INT 11
8270: PUSH
8271: LD_INT 12
8273: PUSH
8274: LD_INT 15
8276: PUSH
8277: LD_INT 16
8279: PUSH
8280: LD_INT 22
8282: PUSH
8283: LD_INT 23
8285: PUSH
8286: LD_INT 26
8288: PUSH
8289: EMPTY
8290: LIST
8291: LIST
8292: LIST
8293: LIST
8294: LIST
8295: LIST
8296: LIST
8297: LIST
8298: LIST
8299: PUSH
8300: LD_INT 101
8302: PUSH
8303: LD_INT 102
8305: PUSH
8306: LD_INT 106
8308: PUSH
8309: EMPTY
8310: LIST
8311: LIST
8312: LIST
8313: PUSH
8314: EMPTY
8315: LIST
8316: LIST
8317: ST_TO_ADDR
8318: GO 11189
8320: LD_INT 2
8322: DOUBLE
8323: EQUAL
8324: IFTRUE 8328
8326: GO 8400
8328: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
8329: LD_ADDR_VAR 0 1
8333: PUSH
8334: LD_INT 2
8336: PUSH
8337: LD_INT 4
8339: PUSH
8340: LD_INT 11
8342: PUSH
8343: LD_INT 12
8345: PUSH
8346: LD_INT 15
8348: PUSH
8349: LD_INT 16
8351: PUSH
8352: LD_INT 22
8354: PUSH
8355: LD_INT 23
8357: PUSH
8358: LD_INT 26
8360: PUSH
8361: EMPTY
8362: LIST
8363: LIST
8364: LIST
8365: LIST
8366: LIST
8367: LIST
8368: LIST
8369: LIST
8370: LIST
8371: PUSH
8372: LD_INT 101
8374: PUSH
8375: LD_INT 102
8377: PUSH
8378: LD_INT 105
8380: PUSH
8381: LD_INT 106
8383: PUSH
8384: LD_INT 108
8386: PUSH
8387: EMPTY
8388: LIST
8389: LIST
8390: LIST
8391: LIST
8392: LIST
8393: PUSH
8394: EMPTY
8395: LIST
8396: LIST
8397: ST_TO_ADDR
8398: GO 11189
8400: LD_INT 3
8402: DOUBLE
8403: EQUAL
8404: IFTRUE 8408
8406: GO 8484
8408: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
8409: LD_ADDR_VAR 0 1
8413: PUSH
8414: LD_INT 2
8416: PUSH
8417: LD_INT 4
8419: PUSH
8420: LD_INT 5
8422: PUSH
8423: LD_INT 11
8425: PUSH
8426: LD_INT 12
8428: PUSH
8429: LD_INT 15
8431: PUSH
8432: LD_INT 16
8434: PUSH
8435: LD_INT 22
8437: PUSH
8438: LD_INT 26
8440: PUSH
8441: LD_INT 36
8443: PUSH
8444: EMPTY
8445: LIST
8446: LIST
8447: LIST
8448: LIST
8449: LIST
8450: LIST
8451: LIST
8452: LIST
8453: LIST
8454: LIST
8455: PUSH
8456: LD_INT 101
8458: PUSH
8459: LD_INT 102
8461: PUSH
8462: LD_INT 105
8464: PUSH
8465: LD_INT 106
8467: PUSH
8468: LD_INT 108
8470: PUSH
8471: EMPTY
8472: LIST
8473: LIST
8474: LIST
8475: LIST
8476: LIST
8477: PUSH
8478: EMPTY
8479: LIST
8480: LIST
8481: ST_TO_ADDR
8482: GO 11189
8484: LD_INT 4
8486: DOUBLE
8487: EQUAL
8488: IFTRUE 8492
8490: GO 8576
8492: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
8493: LD_ADDR_VAR 0 1
8497: PUSH
8498: LD_INT 2
8500: PUSH
8501: LD_INT 4
8503: PUSH
8504: LD_INT 5
8506: PUSH
8507: LD_INT 8
8509: PUSH
8510: LD_INT 11
8512: PUSH
8513: LD_INT 12
8515: PUSH
8516: LD_INT 15
8518: PUSH
8519: LD_INT 16
8521: PUSH
8522: LD_INT 22
8524: PUSH
8525: LD_INT 23
8527: PUSH
8528: LD_INT 26
8530: PUSH
8531: LD_INT 36
8533: PUSH
8534: EMPTY
8535: LIST
8536: LIST
8537: LIST
8538: LIST
8539: LIST
8540: LIST
8541: LIST
8542: LIST
8543: LIST
8544: LIST
8545: LIST
8546: LIST
8547: PUSH
8548: LD_INT 101
8550: PUSH
8551: LD_INT 102
8553: PUSH
8554: LD_INT 105
8556: PUSH
8557: LD_INT 106
8559: PUSH
8560: LD_INT 108
8562: PUSH
8563: EMPTY
8564: LIST
8565: LIST
8566: LIST
8567: LIST
8568: LIST
8569: PUSH
8570: EMPTY
8571: LIST
8572: LIST
8573: ST_TO_ADDR
8574: GO 11189
8576: LD_INT 5
8578: DOUBLE
8579: EQUAL
8580: IFTRUE 8584
8582: GO 8684
8584: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
8585: LD_ADDR_VAR 0 1
8589: PUSH
8590: LD_INT 2
8592: PUSH
8593: LD_INT 4
8595: PUSH
8596: LD_INT 5
8598: PUSH
8599: LD_INT 6
8601: PUSH
8602: LD_INT 8
8604: PUSH
8605: LD_INT 11
8607: PUSH
8608: LD_INT 12
8610: PUSH
8611: LD_INT 15
8613: PUSH
8614: LD_INT 16
8616: PUSH
8617: LD_INT 22
8619: PUSH
8620: LD_INT 23
8622: PUSH
8623: LD_INT 25
8625: PUSH
8626: LD_INT 26
8628: PUSH
8629: LD_INT 36
8631: PUSH
8632: EMPTY
8633: LIST
8634: LIST
8635: LIST
8636: LIST
8637: LIST
8638: LIST
8639: LIST
8640: LIST
8641: LIST
8642: LIST
8643: LIST
8644: LIST
8645: LIST
8646: LIST
8647: PUSH
8648: LD_INT 101
8650: PUSH
8651: LD_INT 102
8653: PUSH
8654: LD_INT 105
8656: PUSH
8657: LD_INT 106
8659: PUSH
8660: LD_INT 108
8662: PUSH
8663: LD_INT 109
8665: PUSH
8666: LD_INT 112
8668: PUSH
8669: EMPTY
8670: LIST
8671: LIST
8672: LIST
8673: LIST
8674: LIST
8675: LIST
8676: LIST
8677: PUSH
8678: EMPTY
8679: LIST
8680: LIST
8681: ST_TO_ADDR
8682: GO 11189
8684: LD_INT 6
8686: DOUBLE
8687: EQUAL
8688: IFTRUE 8692
8690: GO 8812
8692: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
8693: LD_ADDR_VAR 0 1
8697: PUSH
8698: LD_INT 2
8700: PUSH
8701: LD_INT 4
8703: PUSH
8704: LD_INT 5
8706: PUSH
8707: LD_INT 6
8709: PUSH
8710: LD_INT 8
8712: PUSH
8713: LD_INT 11
8715: PUSH
8716: LD_INT 12
8718: PUSH
8719: LD_INT 15
8721: PUSH
8722: LD_INT 16
8724: PUSH
8725: LD_INT 20
8727: PUSH
8728: LD_INT 21
8730: PUSH
8731: LD_INT 22
8733: PUSH
8734: LD_INT 23
8736: PUSH
8737: LD_INT 25
8739: PUSH
8740: LD_INT 26
8742: PUSH
8743: LD_INT 30
8745: PUSH
8746: LD_INT 31
8748: PUSH
8749: LD_INT 32
8751: PUSH
8752: LD_INT 36
8754: PUSH
8755: EMPTY
8756: LIST
8757: LIST
8758: LIST
8759: LIST
8760: LIST
8761: LIST
8762: LIST
8763: LIST
8764: LIST
8765: LIST
8766: LIST
8767: LIST
8768: LIST
8769: LIST
8770: LIST
8771: LIST
8772: LIST
8773: LIST
8774: LIST
8775: PUSH
8776: LD_INT 101
8778: PUSH
8779: LD_INT 102
8781: PUSH
8782: LD_INT 105
8784: PUSH
8785: LD_INT 106
8787: PUSH
8788: LD_INT 108
8790: PUSH
8791: LD_INT 109
8793: PUSH
8794: LD_INT 112
8796: PUSH
8797: EMPTY
8798: LIST
8799: LIST
8800: LIST
8801: LIST
8802: LIST
8803: LIST
8804: LIST
8805: PUSH
8806: EMPTY
8807: LIST
8808: LIST
8809: ST_TO_ADDR
8810: GO 11189
8812: LD_INT 7
8814: DOUBLE
8815: EQUAL
8816: IFTRUE 8820
8818: GO 8920
8820: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
8821: LD_ADDR_VAR 0 1
8825: PUSH
8826: LD_INT 2
8828: PUSH
8829: LD_INT 4
8831: PUSH
8832: LD_INT 5
8834: PUSH
8835: LD_INT 7
8837: PUSH
8838: LD_INT 11
8840: PUSH
8841: LD_INT 12
8843: PUSH
8844: LD_INT 15
8846: PUSH
8847: LD_INT 16
8849: PUSH
8850: LD_INT 20
8852: PUSH
8853: LD_INT 21
8855: PUSH
8856: LD_INT 22
8858: PUSH
8859: LD_INT 23
8861: PUSH
8862: LD_INT 25
8864: PUSH
8865: LD_INT 26
8867: PUSH
8868: EMPTY
8869: LIST
8870: LIST
8871: LIST
8872: LIST
8873: LIST
8874: LIST
8875: LIST
8876: LIST
8877: LIST
8878: LIST
8879: LIST
8880: LIST
8881: LIST
8882: LIST
8883: PUSH
8884: LD_INT 101
8886: PUSH
8887: LD_INT 102
8889: PUSH
8890: LD_INT 103
8892: PUSH
8893: LD_INT 105
8895: PUSH
8896: LD_INT 106
8898: PUSH
8899: LD_INT 108
8901: PUSH
8902: LD_INT 112
8904: PUSH
8905: EMPTY
8906: LIST
8907: LIST
8908: LIST
8909: LIST
8910: LIST
8911: LIST
8912: LIST
8913: PUSH
8914: EMPTY
8915: LIST
8916: LIST
8917: ST_TO_ADDR
8918: GO 11189
8920: LD_INT 8
8922: DOUBLE
8923: EQUAL
8924: IFTRUE 8928
8926: GO 9056
8928: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
8929: LD_ADDR_VAR 0 1
8933: PUSH
8934: LD_INT 2
8936: PUSH
8937: LD_INT 4
8939: PUSH
8940: LD_INT 5
8942: PUSH
8943: LD_INT 6
8945: PUSH
8946: LD_INT 7
8948: PUSH
8949: LD_INT 8
8951: PUSH
8952: LD_INT 11
8954: PUSH
8955: LD_INT 12
8957: PUSH
8958: LD_INT 15
8960: PUSH
8961: LD_INT 16
8963: PUSH
8964: LD_INT 20
8966: PUSH
8967: LD_INT 21
8969: PUSH
8970: LD_INT 22
8972: PUSH
8973: LD_INT 23
8975: PUSH
8976: LD_INT 25
8978: PUSH
8979: LD_INT 26
8981: PUSH
8982: LD_INT 30
8984: PUSH
8985: LD_INT 31
8987: PUSH
8988: LD_INT 32
8990: PUSH
8991: LD_INT 36
8993: PUSH
8994: EMPTY
8995: LIST
8996: LIST
8997: LIST
8998: LIST
8999: LIST
9000: LIST
9001: LIST
9002: LIST
9003: LIST
9004: LIST
9005: LIST
9006: LIST
9007: LIST
9008: LIST
9009: LIST
9010: LIST
9011: LIST
9012: LIST
9013: LIST
9014: LIST
9015: PUSH
9016: LD_INT 101
9018: PUSH
9019: LD_INT 102
9021: PUSH
9022: LD_INT 103
9024: PUSH
9025: LD_INT 105
9027: PUSH
9028: LD_INT 106
9030: PUSH
9031: LD_INT 108
9033: PUSH
9034: LD_INT 109
9036: PUSH
9037: LD_INT 112
9039: PUSH
9040: EMPTY
9041: LIST
9042: LIST
9043: LIST
9044: LIST
9045: LIST
9046: LIST
9047: LIST
9048: LIST
9049: PUSH
9050: EMPTY
9051: LIST
9052: LIST
9053: ST_TO_ADDR
9054: GO 11189
9056: LD_INT 9
9058: DOUBLE
9059: EQUAL
9060: IFTRUE 9064
9062: GO 9200
9064: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
9065: LD_ADDR_VAR 0 1
9069: PUSH
9070: LD_INT 2
9072: PUSH
9073: LD_INT 4
9075: PUSH
9076: LD_INT 5
9078: PUSH
9079: LD_INT 6
9081: PUSH
9082: LD_INT 7
9084: PUSH
9085: LD_INT 8
9087: PUSH
9088: LD_INT 11
9090: PUSH
9091: LD_INT 12
9093: PUSH
9094: LD_INT 15
9096: PUSH
9097: LD_INT 16
9099: PUSH
9100: LD_INT 20
9102: PUSH
9103: LD_INT 21
9105: PUSH
9106: LD_INT 22
9108: PUSH
9109: LD_INT 23
9111: PUSH
9112: LD_INT 25
9114: PUSH
9115: LD_INT 26
9117: PUSH
9118: LD_INT 28
9120: PUSH
9121: LD_INT 30
9123: PUSH
9124: LD_INT 31
9126: PUSH
9127: LD_INT 32
9129: PUSH
9130: LD_INT 36
9132: PUSH
9133: EMPTY
9134: LIST
9135: LIST
9136: LIST
9137: LIST
9138: LIST
9139: LIST
9140: LIST
9141: LIST
9142: LIST
9143: LIST
9144: LIST
9145: LIST
9146: LIST
9147: LIST
9148: LIST
9149: LIST
9150: LIST
9151: LIST
9152: LIST
9153: LIST
9154: LIST
9155: PUSH
9156: LD_INT 101
9158: PUSH
9159: LD_INT 102
9161: PUSH
9162: LD_INT 103
9164: PUSH
9165: LD_INT 105
9167: PUSH
9168: LD_INT 106
9170: PUSH
9171: LD_INT 108
9173: PUSH
9174: LD_INT 109
9176: PUSH
9177: LD_INT 112
9179: PUSH
9180: LD_INT 114
9182: PUSH
9183: EMPTY
9184: LIST
9185: LIST
9186: LIST
9187: LIST
9188: LIST
9189: LIST
9190: LIST
9191: LIST
9192: LIST
9193: PUSH
9194: EMPTY
9195: LIST
9196: LIST
9197: ST_TO_ADDR
9198: GO 11189
9200: LD_INT 10
9202: DOUBLE
9203: EQUAL
9204: IFTRUE 9208
9206: GO 9392
9208: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
9209: LD_ADDR_VAR 0 1
9213: PUSH
9214: LD_INT 2
9216: PUSH
9217: LD_INT 4
9219: PUSH
9220: LD_INT 5
9222: PUSH
9223: LD_INT 6
9225: PUSH
9226: LD_INT 7
9228: PUSH
9229: LD_INT 8
9231: PUSH
9232: LD_INT 9
9234: PUSH
9235: LD_INT 10
9237: PUSH
9238: LD_INT 11
9240: PUSH
9241: LD_INT 12
9243: PUSH
9244: LD_INT 13
9246: PUSH
9247: LD_INT 14
9249: PUSH
9250: LD_INT 15
9252: PUSH
9253: LD_INT 16
9255: PUSH
9256: LD_INT 17
9258: PUSH
9259: LD_INT 18
9261: PUSH
9262: LD_INT 19
9264: PUSH
9265: LD_INT 20
9267: PUSH
9268: LD_INT 21
9270: PUSH
9271: LD_INT 22
9273: PUSH
9274: LD_INT 23
9276: PUSH
9277: LD_INT 24
9279: PUSH
9280: LD_INT 25
9282: PUSH
9283: LD_INT 26
9285: PUSH
9286: LD_INT 28
9288: PUSH
9289: LD_INT 30
9291: PUSH
9292: LD_INT 31
9294: PUSH
9295: LD_INT 32
9297: PUSH
9298: LD_INT 36
9300: PUSH
9301: EMPTY
9302: LIST
9303: LIST
9304: LIST
9305: LIST
9306: LIST
9307: LIST
9308: LIST
9309: LIST
9310: LIST
9311: LIST
9312: LIST
9313: LIST
9314: LIST
9315: LIST
9316: LIST
9317: LIST
9318: LIST
9319: LIST
9320: LIST
9321: LIST
9322: LIST
9323: LIST
9324: LIST
9325: LIST
9326: LIST
9327: LIST
9328: LIST
9329: LIST
9330: LIST
9331: PUSH
9332: LD_INT 101
9334: PUSH
9335: LD_INT 102
9337: PUSH
9338: LD_INT 103
9340: PUSH
9341: LD_INT 104
9343: PUSH
9344: LD_INT 105
9346: PUSH
9347: LD_INT 106
9349: PUSH
9350: LD_INT 107
9352: PUSH
9353: LD_INT 108
9355: PUSH
9356: LD_INT 109
9358: PUSH
9359: LD_INT 110
9361: PUSH
9362: LD_INT 111
9364: PUSH
9365: LD_INT 112
9367: PUSH
9368: LD_INT 114
9370: PUSH
9371: EMPTY
9372: LIST
9373: LIST
9374: LIST
9375: LIST
9376: LIST
9377: LIST
9378: LIST
9379: LIST
9380: LIST
9381: LIST
9382: LIST
9383: LIST
9384: LIST
9385: PUSH
9386: EMPTY
9387: LIST
9388: LIST
9389: ST_TO_ADDR
9390: GO 11189
9392: LD_INT 11
9394: DOUBLE
9395: EQUAL
9396: IFTRUE 9400
9398: GO 9592
9400: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
9401: LD_ADDR_VAR 0 1
9405: PUSH
9406: LD_INT 2
9408: PUSH
9409: LD_INT 3
9411: PUSH
9412: LD_INT 4
9414: PUSH
9415: LD_INT 5
9417: PUSH
9418: LD_INT 6
9420: PUSH
9421: LD_INT 7
9423: PUSH
9424: LD_INT 8
9426: PUSH
9427: LD_INT 9
9429: PUSH
9430: LD_INT 10
9432: PUSH
9433: LD_INT 11
9435: PUSH
9436: LD_INT 12
9438: PUSH
9439: LD_INT 13
9441: PUSH
9442: LD_INT 14
9444: PUSH
9445: LD_INT 15
9447: PUSH
9448: LD_INT 16
9450: PUSH
9451: LD_INT 17
9453: PUSH
9454: LD_INT 18
9456: PUSH
9457: LD_INT 19
9459: PUSH
9460: LD_INT 20
9462: PUSH
9463: LD_INT 21
9465: PUSH
9466: LD_INT 22
9468: PUSH
9469: LD_INT 23
9471: PUSH
9472: LD_INT 24
9474: PUSH
9475: LD_INT 25
9477: PUSH
9478: LD_INT 26
9480: PUSH
9481: LD_INT 28
9483: PUSH
9484: LD_INT 30
9486: PUSH
9487: LD_INT 31
9489: PUSH
9490: LD_INT 32
9492: PUSH
9493: LD_INT 34
9495: PUSH
9496: LD_INT 36
9498: PUSH
9499: EMPTY
9500: LIST
9501: LIST
9502: LIST
9503: LIST
9504: LIST
9505: LIST
9506: LIST
9507: LIST
9508: LIST
9509: LIST
9510: LIST
9511: LIST
9512: LIST
9513: LIST
9514: LIST
9515: LIST
9516: LIST
9517: LIST
9518: LIST
9519: LIST
9520: LIST
9521: LIST
9522: LIST
9523: LIST
9524: LIST
9525: LIST
9526: LIST
9527: LIST
9528: LIST
9529: LIST
9530: LIST
9531: PUSH
9532: LD_INT 101
9534: PUSH
9535: LD_INT 102
9537: PUSH
9538: LD_INT 103
9540: PUSH
9541: LD_INT 104
9543: PUSH
9544: LD_INT 105
9546: PUSH
9547: LD_INT 106
9549: PUSH
9550: LD_INT 107
9552: PUSH
9553: LD_INT 108
9555: PUSH
9556: LD_INT 109
9558: PUSH
9559: LD_INT 110
9561: PUSH
9562: LD_INT 111
9564: PUSH
9565: LD_INT 112
9567: PUSH
9568: LD_INT 114
9570: PUSH
9571: EMPTY
9572: LIST
9573: LIST
9574: LIST
9575: LIST
9576: LIST
9577: LIST
9578: LIST
9579: LIST
9580: LIST
9581: LIST
9582: LIST
9583: LIST
9584: LIST
9585: PUSH
9586: EMPTY
9587: LIST
9588: LIST
9589: ST_TO_ADDR
9590: GO 11189
9592: LD_INT 12
9594: DOUBLE
9595: EQUAL
9596: IFTRUE 9600
9598: GO 9808
9600: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
9601: LD_ADDR_VAR 0 1
9605: PUSH
9606: LD_INT 1
9608: PUSH
9609: LD_INT 2
9611: PUSH
9612: LD_INT 3
9614: PUSH
9615: LD_INT 4
9617: PUSH
9618: LD_INT 5
9620: PUSH
9621: LD_INT 6
9623: PUSH
9624: LD_INT 7
9626: PUSH
9627: LD_INT 8
9629: PUSH
9630: LD_INT 9
9632: PUSH
9633: LD_INT 10
9635: PUSH
9636: LD_INT 11
9638: PUSH
9639: LD_INT 12
9641: PUSH
9642: LD_INT 13
9644: PUSH
9645: LD_INT 14
9647: PUSH
9648: LD_INT 15
9650: PUSH
9651: LD_INT 16
9653: PUSH
9654: LD_INT 17
9656: PUSH
9657: LD_INT 18
9659: PUSH
9660: LD_INT 19
9662: PUSH
9663: LD_INT 20
9665: PUSH
9666: LD_INT 21
9668: PUSH
9669: LD_INT 22
9671: PUSH
9672: LD_INT 23
9674: PUSH
9675: LD_INT 24
9677: PUSH
9678: LD_INT 25
9680: PUSH
9681: LD_INT 26
9683: PUSH
9684: LD_INT 27
9686: PUSH
9687: LD_INT 28
9689: PUSH
9690: LD_INT 30
9692: PUSH
9693: LD_INT 31
9695: PUSH
9696: LD_INT 32
9698: PUSH
9699: LD_INT 33
9701: PUSH
9702: LD_INT 34
9704: PUSH
9705: LD_INT 36
9707: PUSH
9708: EMPTY
9709: LIST
9710: LIST
9711: LIST
9712: LIST
9713: LIST
9714: LIST
9715: LIST
9716: LIST
9717: LIST
9718: LIST
9719: LIST
9720: LIST
9721: LIST
9722: LIST
9723: LIST
9724: LIST
9725: LIST
9726: LIST
9727: LIST
9728: LIST
9729: LIST
9730: LIST
9731: LIST
9732: LIST
9733: LIST
9734: LIST
9735: LIST
9736: LIST
9737: LIST
9738: LIST
9739: LIST
9740: LIST
9741: LIST
9742: LIST
9743: PUSH
9744: LD_INT 101
9746: PUSH
9747: LD_INT 102
9749: PUSH
9750: LD_INT 103
9752: PUSH
9753: LD_INT 104
9755: PUSH
9756: LD_INT 105
9758: PUSH
9759: LD_INT 106
9761: PUSH
9762: LD_INT 107
9764: PUSH
9765: LD_INT 108
9767: PUSH
9768: LD_INT 109
9770: PUSH
9771: LD_INT 110
9773: PUSH
9774: LD_INT 111
9776: PUSH
9777: LD_INT 112
9779: PUSH
9780: LD_INT 113
9782: PUSH
9783: LD_INT 114
9785: PUSH
9786: EMPTY
9787: LIST
9788: LIST
9789: LIST
9790: LIST
9791: LIST
9792: LIST
9793: LIST
9794: LIST
9795: LIST
9796: LIST
9797: LIST
9798: LIST
9799: LIST
9800: LIST
9801: PUSH
9802: EMPTY
9803: LIST
9804: LIST
9805: ST_TO_ADDR
9806: GO 11189
9808: LD_INT 13
9810: DOUBLE
9811: EQUAL
9812: IFTRUE 9816
9814: GO 10024
9816: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
9817: LD_ADDR_VAR 0 1
9821: PUSH
9822: LD_INT 1
9824: PUSH
9825: LD_INT 2
9827: PUSH
9828: LD_INT 3
9830: PUSH
9831: LD_INT 4
9833: PUSH
9834: LD_INT 5
9836: PUSH
9837: LD_INT 6
9839: PUSH
9840: LD_INT 7
9842: PUSH
9843: LD_INT 8
9845: PUSH
9846: LD_INT 9
9848: PUSH
9849: LD_INT 10
9851: PUSH
9852: LD_INT 11
9854: PUSH
9855: LD_INT 12
9857: PUSH
9858: LD_INT 13
9860: PUSH
9861: LD_INT 14
9863: PUSH
9864: LD_INT 15
9866: PUSH
9867: LD_INT 16
9869: PUSH
9870: LD_INT 17
9872: PUSH
9873: LD_INT 18
9875: PUSH
9876: LD_INT 19
9878: PUSH
9879: LD_INT 20
9881: PUSH
9882: LD_INT 21
9884: PUSH
9885: LD_INT 22
9887: PUSH
9888: LD_INT 23
9890: PUSH
9891: LD_INT 24
9893: PUSH
9894: LD_INT 25
9896: PUSH
9897: LD_INT 26
9899: PUSH
9900: LD_INT 27
9902: PUSH
9903: LD_INT 28
9905: PUSH
9906: LD_INT 30
9908: PUSH
9909: LD_INT 31
9911: PUSH
9912: LD_INT 32
9914: PUSH
9915: LD_INT 33
9917: PUSH
9918: LD_INT 34
9920: PUSH
9921: LD_INT 36
9923: PUSH
9924: EMPTY
9925: LIST
9926: LIST
9927: LIST
9928: LIST
9929: LIST
9930: LIST
9931: LIST
9932: LIST
9933: LIST
9934: LIST
9935: LIST
9936: LIST
9937: LIST
9938: LIST
9939: LIST
9940: LIST
9941: LIST
9942: LIST
9943: LIST
9944: LIST
9945: LIST
9946: LIST
9947: LIST
9948: LIST
9949: LIST
9950: LIST
9951: LIST
9952: LIST
9953: LIST
9954: LIST
9955: LIST
9956: LIST
9957: LIST
9958: LIST
9959: PUSH
9960: LD_INT 101
9962: PUSH
9963: LD_INT 102
9965: PUSH
9966: LD_INT 103
9968: PUSH
9969: LD_INT 104
9971: PUSH
9972: LD_INT 105
9974: PUSH
9975: LD_INT 106
9977: PUSH
9978: LD_INT 107
9980: PUSH
9981: LD_INT 108
9983: PUSH
9984: LD_INT 109
9986: PUSH
9987: LD_INT 110
9989: PUSH
9990: LD_INT 111
9992: PUSH
9993: LD_INT 112
9995: PUSH
9996: LD_INT 113
9998: PUSH
9999: LD_INT 114
10001: PUSH
10002: EMPTY
10003: LIST
10004: LIST
10005: LIST
10006: LIST
10007: LIST
10008: LIST
10009: LIST
10010: LIST
10011: LIST
10012: LIST
10013: LIST
10014: LIST
10015: LIST
10016: LIST
10017: PUSH
10018: EMPTY
10019: LIST
10020: LIST
10021: ST_TO_ADDR
10022: GO 11189
10024: LD_INT 14
10026: DOUBLE
10027: EQUAL
10028: IFTRUE 10032
10030: GO 10244
10032: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
10033: LD_ADDR_VAR 0 1
10037: PUSH
10038: LD_INT 1
10040: PUSH
10041: LD_INT 2
10043: PUSH
10044: LD_INT 3
10046: PUSH
10047: LD_INT 4
10049: PUSH
10050: LD_INT 5
10052: PUSH
10053: LD_INT 6
10055: PUSH
10056: LD_INT 7
10058: PUSH
10059: LD_INT 8
10061: PUSH
10062: LD_INT 9
10064: PUSH
10065: LD_INT 10
10067: PUSH
10068: LD_INT 11
10070: PUSH
10071: LD_INT 12
10073: PUSH
10074: LD_INT 13
10076: PUSH
10077: LD_INT 14
10079: PUSH
10080: LD_INT 15
10082: PUSH
10083: LD_INT 16
10085: PUSH
10086: LD_INT 17
10088: PUSH
10089: LD_INT 18
10091: PUSH
10092: LD_INT 19
10094: PUSH
10095: LD_INT 20
10097: PUSH
10098: LD_INT 21
10100: PUSH
10101: LD_INT 22
10103: PUSH
10104: LD_INT 23
10106: PUSH
10107: LD_INT 24
10109: PUSH
10110: LD_INT 25
10112: PUSH
10113: LD_INT 26
10115: PUSH
10116: LD_INT 27
10118: PUSH
10119: LD_INT 28
10121: PUSH
10122: LD_INT 29
10124: PUSH
10125: LD_INT 30
10127: PUSH
10128: LD_INT 31
10130: PUSH
10131: LD_INT 32
10133: PUSH
10134: LD_INT 33
10136: PUSH
10137: LD_INT 34
10139: PUSH
10140: LD_INT 36
10142: PUSH
10143: EMPTY
10144: LIST
10145: LIST
10146: LIST
10147: LIST
10148: LIST
10149: LIST
10150: LIST
10151: LIST
10152: LIST
10153: LIST
10154: LIST
10155: LIST
10156: LIST
10157: LIST
10158: LIST
10159: LIST
10160: LIST
10161: LIST
10162: LIST
10163: LIST
10164: LIST
10165: LIST
10166: LIST
10167: LIST
10168: LIST
10169: LIST
10170: LIST
10171: LIST
10172: LIST
10173: LIST
10174: LIST
10175: LIST
10176: LIST
10177: LIST
10178: LIST
10179: PUSH
10180: LD_INT 101
10182: PUSH
10183: LD_INT 102
10185: PUSH
10186: LD_INT 103
10188: PUSH
10189: LD_INT 104
10191: PUSH
10192: LD_INT 105
10194: PUSH
10195: LD_INT 106
10197: PUSH
10198: LD_INT 107
10200: PUSH
10201: LD_INT 108
10203: PUSH
10204: LD_INT 109
10206: PUSH
10207: LD_INT 110
10209: PUSH
10210: LD_INT 111
10212: PUSH
10213: LD_INT 112
10215: PUSH
10216: LD_INT 113
10218: PUSH
10219: LD_INT 114
10221: PUSH
10222: EMPTY
10223: LIST
10224: LIST
10225: LIST
10226: LIST
10227: LIST
10228: LIST
10229: LIST
10230: LIST
10231: LIST
10232: LIST
10233: LIST
10234: LIST
10235: LIST
10236: LIST
10237: PUSH
10238: EMPTY
10239: LIST
10240: LIST
10241: ST_TO_ADDR
10242: GO 11189
10244: LD_INT 15
10246: DOUBLE
10247: EQUAL
10248: IFTRUE 10252
10250: GO 10464
10252: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
10253: LD_ADDR_VAR 0 1
10257: PUSH
10258: LD_INT 1
10260: PUSH
10261: LD_INT 2
10263: PUSH
10264: LD_INT 3
10266: PUSH
10267: LD_INT 4
10269: PUSH
10270: LD_INT 5
10272: PUSH
10273: LD_INT 6
10275: PUSH
10276: LD_INT 7
10278: PUSH
10279: LD_INT 8
10281: PUSH
10282: LD_INT 9
10284: PUSH
10285: LD_INT 10
10287: PUSH
10288: LD_INT 11
10290: PUSH
10291: LD_INT 12
10293: PUSH
10294: LD_INT 13
10296: PUSH
10297: LD_INT 14
10299: PUSH
10300: LD_INT 15
10302: PUSH
10303: LD_INT 16
10305: PUSH
10306: LD_INT 17
10308: PUSH
10309: LD_INT 18
10311: PUSH
10312: LD_INT 19
10314: PUSH
10315: LD_INT 20
10317: PUSH
10318: LD_INT 21
10320: PUSH
10321: LD_INT 22
10323: PUSH
10324: LD_INT 23
10326: PUSH
10327: LD_INT 24
10329: PUSH
10330: LD_INT 25
10332: PUSH
10333: LD_INT 26
10335: PUSH
10336: LD_INT 27
10338: PUSH
10339: LD_INT 28
10341: PUSH
10342: LD_INT 29
10344: PUSH
10345: LD_INT 30
10347: PUSH
10348: LD_INT 31
10350: PUSH
10351: LD_INT 32
10353: PUSH
10354: LD_INT 33
10356: PUSH
10357: LD_INT 34
10359: PUSH
10360: LD_INT 36
10362: PUSH
10363: EMPTY
10364: LIST
10365: LIST
10366: LIST
10367: LIST
10368: LIST
10369: LIST
10370: LIST
10371: LIST
10372: LIST
10373: LIST
10374: LIST
10375: LIST
10376: LIST
10377: LIST
10378: LIST
10379: LIST
10380: LIST
10381: LIST
10382: LIST
10383: LIST
10384: LIST
10385: LIST
10386: LIST
10387: LIST
10388: LIST
10389: LIST
10390: LIST
10391: LIST
10392: LIST
10393: LIST
10394: LIST
10395: LIST
10396: LIST
10397: LIST
10398: LIST
10399: PUSH
10400: LD_INT 101
10402: PUSH
10403: LD_INT 102
10405: PUSH
10406: LD_INT 103
10408: PUSH
10409: LD_INT 104
10411: PUSH
10412: LD_INT 105
10414: PUSH
10415: LD_INT 106
10417: PUSH
10418: LD_INT 107
10420: PUSH
10421: LD_INT 108
10423: PUSH
10424: LD_INT 109
10426: PUSH
10427: LD_INT 110
10429: PUSH
10430: LD_INT 111
10432: PUSH
10433: LD_INT 112
10435: PUSH
10436: LD_INT 113
10438: PUSH
10439: LD_INT 114
10441: PUSH
10442: EMPTY
10443: LIST
10444: LIST
10445: LIST
10446: LIST
10447: LIST
10448: LIST
10449: LIST
10450: LIST
10451: LIST
10452: LIST
10453: LIST
10454: LIST
10455: LIST
10456: LIST
10457: PUSH
10458: EMPTY
10459: LIST
10460: LIST
10461: ST_TO_ADDR
10462: GO 11189
10464: LD_INT 16
10466: DOUBLE
10467: EQUAL
10468: IFTRUE 10472
10470: GO 10596
10472: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
10473: LD_ADDR_VAR 0 1
10477: PUSH
10478: LD_INT 2
10480: PUSH
10481: LD_INT 4
10483: PUSH
10484: LD_INT 5
10486: PUSH
10487: LD_INT 7
10489: PUSH
10490: LD_INT 11
10492: PUSH
10493: LD_INT 12
10495: PUSH
10496: LD_INT 15
10498: PUSH
10499: LD_INT 16
10501: PUSH
10502: LD_INT 20
10504: PUSH
10505: LD_INT 21
10507: PUSH
10508: LD_INT 22
10510: PUSH
10511: LD_INT 23
10513: PUSH
10514: LD_INT 25
10516: PUSH
10517: LD_INT 26
10519: PUSH
10520: LD_INT 30
10522: PUSH
10523: LD_INT 31
10525: PUSH
10526: LD_INT 32
10528: PUSH
10529: LD_INT 33
10531: PUSH
10532: LD_INT 34
10534: PUSH
10535: EMPTY
10536: LIST
10537: LIST
10538: LIST
10539: LIST
10540: LIST
10541: LIST
10542: LIST
10543: LIST
10544: LIST
10545: LIST
10546: LIST
10547: LIST
10548: LIST
10549: LIST
10550: LIST
10551: LIST
10552: LIST
10553: LIST
10554: LIST
10555: PUSH
10556: LD_INT 101
10558: PUSH
10559: LD_INT 102
10561: PUSH
10562: LD_INT 103
10564: PUSH
10565: LD_INT 106
10567: PUSH
10568: LD_INT 108
10570: PUSH
10571: LD_INT 112
10573: PUSH
10574: LD_INT 113
10576: PUSH
10577: LD_INT 114
10579: PUSH
10580: EMPTY
10581: LIST
10582: LIST
10583: LIST
10584: LIST
10585: LIST
10586: LIST
10587: LIST
10588: LIST
10589: PUSH
10590: EMPTY
10591: LIST
10592: LIST
10593: ST_TO_ADDR
10594: GO 11189
10596: LD_INT 17
10598: DOUBLE
10599: EQUAL
10600: IFTRUE 10604
10602: GO 10816
10604: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
10605: LD_ADDR_VAR 0 1
10609: PUSH
10610: LD_INT 1
10612: PUSH
10613: LD_INT 2
10615: PUSH
10616: LD_INT 3
10618: PUSH
10619: LD_INT 4
10621: PUSH
10622: LD_INT 5
10624: PUSH
10625: LD_INT 6
10627: PUSH
10628: LD_INT 7
10630: PUSH
10631: LD_INT 8
10633: PUSH
10634: LD_INT 9
10636: PUSH
10637: LD_INT 10
10639: PUSH
10640: LD_INT 11
10642: PUSH
10643: LD_INT 12
10645: PUSH
10646: LD_INT 13
10648: PUSH
10649: LD_INT 14
10651: PUSH
10652: LD_INT 15
10654: PUSH
10655: LD_INT 16
10657: PUSH
10658: LD_INT 17
10660: PUSH
10661: LD_INT 18
10663: PUSH
10664: LD_INT 19
10666: PUSH
10667: LD_INT 20
10669: PUSH
10670: LD_INT 21
10672: PUSH
10673: LD_INT 22
10675: PUSH
10676: LD_INT 23
10678: PUSH
10679: LD_INT 24
10681: PUSH
10682: LD_INT 25
10684: PUSH
10685: LD_INT 26
10687: PUSH
10688: LD_INT 27
10690: PUSH
10691: LD_INT 28
10693: PUSH
10694: LD_INT 29
10696: PUSH
10697: LD_INT 30
10699: PUSH
10700: LD_INT 31
10702: PUSH
10703: LD_INT 32
10705: PUSH
10706: LD_INT 33
10708: PUSH
10709: LD_INT 34
10711: PUSH
10712: LD_INT 36
10714: PUSH
10715: EMPTY
10716: LIST
10717: LIST
10718: LIST
10719: LIST
10720: LIST
10721: LIST
10722: LIST
10723: LIST
10724: LIST
10725: LIST
10726: LIST
10727: LIST
10728: LIST
10729: LIST
10730: LIST
10731: LIST
10732: LIST
10733: LIST
10734: LIST
10735: LIST
10736: LIST
10737: LIST
10738: LIST
10739: LIST
10740: LIST
10741: LIST
10742: LIST
10743: LIST
10744: LIST
10745: LIST
10746: LIST
10747: LIST
10748: LIST
10749: LIST
10750: LIST
10751: PUSH
10752: LD_INT 101
10754: PUSH
10755: LD_INT 102
10757: PUSH
10758: LD_INT 103
10760: PUSH
10761: LD_INT 104
10763: PUSH
10764: LD_INT 105
10766: PUSH
10767: LD_INT 106
10769: PUSH
10770: LD_INT 107
10772: PUSH
10773: LD_INT 108
10775: PUSH
10776: LD_INT 109
10778: PUSH
10779: LD_INT 110
10781: PUSH
10782: LD_INT 111
10784: PUSH
10785: LD_INT 112
10787: PUSH
10788: LD_INT 113
10790: PUSH
10791: LD_INT 114
10793: PUSH
10794: EMPTY
10795: LIST
10796: LIST
10797: LIST
10798: LIST
10799: LIST
10800: LIST
10801: LIST
10802: LIST
10803: LIST
10804: LIST
10805: LIST
10806: LIST
10807: LIST
10808: LIST
10809: PUSH
10810: EMPTY
10811: LIST
10812: LIST
10813: ST_TO_ADDR
10814: GO 11189
10816: LD_INT 18
10818: DOUBLE
10819: EQUAL
10820: IFTRUE 10824
10822: GO 10960
10824: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
10825: LD_ADDR_VAR 0 1
10829: PUSH
10830: LD_INT 2
10832: PUSH
10833: LD_INT 4
10835: PUSH
10836: LD_INT 5
10838: PUSH
10839: LD_INT 7
10841: PUSH
10842: LD_INT 11
10844: PUSH
10845: LD_INT 12
10847: PUSH
10848: LD_INT 15
10850: PUSH
10851: LD_INT 16
10853: PUSH
10854: LD_INT 20
10856: PUSH
10857: LD_INT 21
10859: PUSH
10860: LD_INT 22
10862: PUSH
10863: LD_INT 23
10865: PUSH
10866: LD_INT 25
10868: PUSH
10869: LD_INT 26
10871: PUSH
10872: LD_INT 30
10874: PUSH
10875: LD_INT 31
10877: PUSH
10878: LD_INT 32
10880: PUSH
10881: LD_INT 33
10883: PUSH
10884: LD_INT 34
10886: PUSH
10887: LD_INT 35
10889: PUSH
10890: LD_INT 36
10892: PUSH
10893: EMPTY
10894: LIST
10895: LIST
10896: LIST
10897: LIST
10898: LIST
10899: LIST
10900: LIST
10901: LIST
10902: LIST
10903: LIST
10904: LIST
10905: LIST
10906: LIST
10907: LIST
10908: LIST
10909: LIST
10910: LIST
10911: LIST
10912: LIST
10913: LIST
10914: LIST
10915: PUSH
10916: LD_INT 101
10918: PUSH
10919: LD_INT 102
10921: PUSH
10922: LD_INT 103
10924: PUSH
10925: LD_INT 106
10927: PUSH
10928: LD_INT 108
10930: PUSH
10931: LD_INT 112
10933: PUSH
10934: LD_INT 113
10936: PUSH
10937: LD_INT 114
10939: PUSH
10940: LD_INT 115
10942: PUSH
10943: EMPTY
10944: LIST
10945: LIST
10946: LIST
10947: LIST
10948: LIST
10949: LIST
10950: LIST
10951: LIST
10952: LIST
10953: PUSH
10954: EMPTY
10955: LIST
10956: LIST
10957: ST_TO_ADDR
10958: GO 11189
10960: LD_INT 19
10962: DOUBLE
10963: EQUAL
10964: IFTRUE 10968
10966: GO 11188
10968: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
10969: LD_ADDR_VAR 0 1
10973: PUSH
10974: LD_INT 1
10976: PUSH
10977: LD_INT 2
10979: PUSH
10980: LD_INT 3
10982: PUSH
10983: LD_INT 4
10985: PUSH
10986: LD_INT 5
10988: PUSH
10989: LD_INT 6
10991: PUSH
10992: LD_INT 7
10994: PUSH
10995: LD_INT 8
10997: PUSH
10998: LD_INT 9
11000: PUSH
11001: LD_INT 10
11003: PUSH
11004: LD_INT 11
11006: PUSH
11007: LD_INT 12
11009: PUSH
11010: LD_INT 13
11012: PUSH
11013: LD_INT 14
11015: PUSH
11016: LD_INT 15
11018: PUSH
11019: LD_INT 16
11021: PUSH
11022: LD_INT 17
11024: PUSH
11025: LD_INT 18
11027: PUSH
11028: LD_INT 19
11030: PUSH
11031: LD_INT 20
11033: PUSH
11034: LD_INT 21
11036: PUSH
11037: LD_INT 22
11039: PUSH
11040: LD_INT 23
11042: PUSH
11043: LD_INT 24
11045: PUSH
11046: LD_INT 25
11048: PUSH
11049: LD_INT 26
11051: PUSH
11052: LD_INT 27
11054: PUSH
11055: LD_INT 28
11057: PUSH
11058: LD_INT 29
11060: PUSH
11061: LD_INT 30
11063: PUSH
11064: LD_INT 31
11066: PUSH
11067: LD_INT 32
11069: PUSH
11070: LD_INT 33
11072: PUSH
11073: LD_INT 34
11075: PUSH
11076: LD_INT 35
11078: PUSH
11079: LD_INT 36
11081: PUSH
11082: EMPTY
11083: LIST
11084: LIST
11085: LIST
11086: LIST
11087: LIST
11088: LIST
11089: LIST
11090: LIST
11091: LIST
11092: LIST
11093: LIST
11094: LIST
11095: LIST
11096: LIST
11097: LIST
11098: LIST
11099: LIST
11100: LIST
11101: LIST
11102: LIST
11103: LIST
11104: LIST
11105: LIST
11106: LIST
11107: LIST
11108: LIST
11109: LIST
11110: LIST
11111: LIST
11112: LIST
11113: LIST
11114: LIST
11115: LIST
11116: LIST
11117: LIST
11118: LIST
11119: PUSH
11120: LD_INT 101
11122: PUSH
11123: LD_INT 102
11125: PUSH
11126: LD_INT 103
11128: PUSH
11129: LD_INT 104
11131: PUSH
11132: LD_INT 105
11134: PUSH
11135: LD_INT 106
11137: PUSH
11138: LD_INT 107
11140: PUSH
11141: LD_INT 108
11143: PUSH
11144: LD_INT 109
11146: PUSH
11147: LD_INT 110
11149: PUSH
11150: LD_INT 111
11152: PUSH
11153: LD_INT 112
11155: PUSH
11156: LD_INT 113
11158: PUSH
11159: LD_INT 114
11161: PUSH
11162: LD_INT 115
11164: PUSH
11165: EMPTY
11166: LIST
11167: LIST
11168: LIST
11169: LIST
11170: LIST
11171: LIST
11172: LIST
11173: LIST
11174: LIST
11175: LIST
11176: LIST
11177: LIST
11178: LIST
11179: LIST
11180: LIST
11181: PUSH
11182: EMPTY
11183: LIST
11184: LIST
11185: ST_TO_ADDR
11186: GO 11189
11188: POP
// end ; if result then
11189: LD_VAR 0 1
11193: IFFALSE 11482
// begin normal :=  ;
11195: LD_ADDR_VAR 0 3
11199: PUSH
11200: LD_STRING 
11202: ST_TO_ADDR
// hardcore :=  ;
11203: LD_ADDR_VAR 0 4
11207: PUSH
11208: LD_STRING 
11210: ST_TO_ADDR
// for i = 1 to normalCounter do
11211: LD_ADDR_VAR 0 5
11215: PUSH
11216: DOUBLE
11217: LD_INT 1
11219: DEC
11220: ST_TO_ADDR
11221: LD_EXP 35
11225: PUSH
11226: FOR_TO
11227: IFFALSE 11328
// begin tmp := 0 ;
11229: LD_ADDR_VAR 0 2
11233: PUSH
11234: LD_STRING 0
11236: ST_TO_ADDR
// if result [ 1 ] then
11237: LD_VAR 0 1
11241: PUSH
11242: LD_INT 1
11244: ARRAY
11245: IFFALSE 11310
// if result [ 1 ] [ 1 ] = i then
11247: LD_VAR 0 1
11251: PUSH
11252: LD_INT 1
11254: ARRAY
11255: PUSH
11256: LD_INT 1
11258: ARRAY
11259: PUSH
11260: LD_VAR 0 5
11264: EQUAL
11265: IFFALSE 11310
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
11267: LD_ADDR_VAR 0 1
11271: PUSH
11272: LD_VAR 0 1
11276: PPUSH
11277: LD_INT 1
11279: PPUSH
11280: LD_VAR 0 1
11284: PUSH
11285: LD_INT 1
11287: ARRAY
11288: PPUSH
11289: LD_INT 1
11291: PPUSH
11292: CALL_OW 3
11296: PPUSH
11297: CALL_OW 1
11301: ST_TO_ADDR
// tmp := 1 ;
11302: LD_ADDR_VAR 0 2
11306: PUSH
11307: LD_STRING 1
11309: ST_TO_ADDR
// end ; normal := normal & tmp ;
11310: LD_ADDR_VAR 0 3
11314: PUSH
11315: LD_VAR 0 3
11319: PUSH
11320: LD_VAR 0 2
11324: STR
11325: ST_TO_ADDR
// end ;
11326: GO 11226
11328: POP
11329: POP
// for i = 1 to hardcoreCounter do
11330: LD_ADDR_VAR 0 5
11334: PUSH
11335: DOUBLE
11336: LD_INT 1
11338: DEC
11339: ST_TO_ADDR
11340: LD_EXP 36
11344: PUSH
11345: FOR_TO
11346: IFFALSE 11451
// begin tmp := 0 ;
11348: LD_ADDR_VAR 0 2
11352: PUSH
11353: LD_STRING 0
11355: ST_TO_ADDR
// if result [ 2 ] then
11356: LD_VAR 0 1
11360: PUSH
11361: LD_INT 2
11363: ARRAY
11364: IFFALSE 11433
// if result [ 2 ] [ 1 ] = 100 + i then
11366: LD_VAR 0 1
11370: PUSH
11371: LD_INT 2
11373: ARRAY
11374: PUSH
11375: LD_INT 1
11377: ARRAY
11378: PUSH
11379: LD_INT 100
11381: PUSH
11382: LD_VAR 0 5
11386: PLUS
11387: EQUAL
11388: IFFALSE 11433
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
11390: LD_ADDR_VAR 0 1
11394: PUSH
11395: LD_VAR 0 1
11399: PPUSH
11400: LD_INT 2
11402: PPUSH
11403: LD_VAR 0 1
11407: PUSH
11408: LD_INT 2
11410: ARRAY
11411: PPUSH
11412: LD_INT 1
11414: PPUSH
11415: CALL_OW 3
11419: PPUSH
11420: CALL_OW 1
11424: ST_TO_ADDR
// tmp := 1 ;
11425: LD_ADDR_VAR 0 2
11429: PUSH
11430: LD_STRING 1
11432: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
11433: LD_ADDR_VAR 0 4
11437: PUSH
11438: LD_VAR 0 4
11442: PUSH
11443: LD_VAR 0 2
11447: STR
11448: ST_TO_ADDR
// end ;
11449: GO 11345
11451: POP
11452: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
11453: LD_STRING getStreamItemsFromMission("
11455: PUSH
11456: LD_VAR 0 3
11460: STR
11461: PUSH
11462: LD_STRING ","
11464: STR
11465: PUSH
11466: LD_VAR 0 4
11470: STR
11471: PUSH
11472: LD_STRING ")
11474: STR
11475: PPUSH
11476: CALL_OW 559
// end else
11480: GO 11489
// ToLua ( getStreamItemsFromMission("","") ) ;
11482: LD_STRING getStreamItemsFromMission("","")
11484: PPUSH
11485: CALL_OW 559
// end ;
11489: LD_VAR 0 1
11493: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
11494: LD_VAR 0 2
11498: PUSH
11499: LD_INT 100
11501: EQUAL
11502: IFFALSE 12451
// begin if not StreamModeActive then
11504: LD_EXP 34
11508: NOT
11509: IFFALSE 11519
// StreamModeActive := true ;
11511: LD_ADDR_EXP 34
11515: PUSH
11516: LD_INT 1
11518: ST_TO_ADDR
// if p3 = 0 then
11519: LD_VAR 0 3
11523: PUSH
11524: LD_INT 0
11526: EQUAL
11527: IFFALSE 11533
// InitStreamMode ;
11529: CALL 7779 0 0
// if p3 = 1 then
11533: LD_VAR 0 3
11537: PUSH
11538: LD_INT 1
11540: EQUAL
11541: IFFALSE 11551
// sRocket := true ;
11543: LD_ADDR_EXP 39
11547: PUSH
11548: LD_INT 1
11550: ST_TO_ADDR
// if p3 = 2 then
11551: LD_VAR 0 3
11555: PUSH
11556: LD_INT 2
11558: EQUAL
11559: IFFALSE 11569
// sSpeed := true ;
11561: LD_ADDR_EXP 38
11565: PUSH
11566: LD_INT 1
11568: ST_TO_ADDR
// if p3 = 3 then
11569: LD_VAR 0 3
11573: PUSH
11574: LD_INT 3
11576: EQUAL
11577: IFFALSE 11587
// sEngine := true ;
11579: LD_ADDR_EXP 40
11583: PUSH
11584: LD_INT 1
11586: ST_TO_ADDR
// if p3 = 4 then
11587: LD_VAR 0 3
11591: PUSH
11592: LD_INT 4
11594: EQUAL
11595: IFFALSE 11605
// sSpec := true ;
11597: LD_ADDR_EXP 37
11601: PUSH
11602: LD_INT 1
11604: ST_TO_ADDR
// if p3 = 5 then
11605: LD_VAR 0 3
11609: PUSH
11610: LD_INT 5
11612: EQUAL
11613: IFFALSE 11623
// sLevel := true ;
11615: LD_ADDR_EXP 41
11619: PUSH
11620: LD_INT 1
11622: ST_TO_ADDR
// if p3 = 6 then
11623: LD_VAR 0 3
11627: PUSH
11628: LD_INT 6
11630: EQUAL
11631: IFFALSE 11641
// sArmoury := true ;
11633: LD_ADDR_EXP 42
11637: PUSH
11638: LD_INT 1
11640: ST_TO_ADDR
// if p3 = 7 then
11641: LD_VAR 0 3
11645: PUSH
11646: LD_INT 7
11648: EQUAL
11649: IFFALSE 11659
// sRadar := true ;
11651: LD_ADDR_EXP 43
11655: PUSH
11656: LD_INT 1
11658: ST_TO_ADDR
// if p3 = 8 then
11659: LD_VAR 0 3
11663: PUSH
11664: LD_INT 8
11666: EQUAL
11667: IFFALSE 11677
// sBunker := true ;
11669: LD_ADDR_EXP 44
11673: PUSH
11674: LD_INT 1
11676: ST_TO_ADDR
// if p3 = 9 then
11677: LD_VAR 0 3
11681: PUSH
11682: LD_INT 9
11684: EQUAL
11685: IFFALSE 11695
// sHack := true ;
11687: LD_ADDR_EXP 45
11691: PUSH
11692: LD_INT 1
11694: ST_TO_ADDR
// if p3 = 10 then
11695: LD_VAR 0 3
11699: PUSH
11700: LD_INT 10
11702: EQUAL
11703: IFFALSE 11713
// sFire := true ;
11705: LD_ADDR_EXP 46
11709: PUSH
11710: LD_INT 1
11712: ST_TO_ADDR
// if p3 = 11 then
11713: LD_VAR 0 3
11717: PUSH
11718: LD_INT 11
11720: EQUAL
11721: IFFALSE 11731
// sRefresh := true ;
11723: LD_ADDR_EXP 47
11727: PUSH
11728: LD_INT 1
11730: ST_TO_ADDR
// if p3 = 12 then
11731: LD_VAR 0 3
11735: PUSH
11736: LD_INT 12
11738: EQUAL
11739: IFFALSE 11749
// sExp := true ;
11741: LD_ADDR_EXP 48
11745: PUSH
11746: LD_INT 1
11748: ST_TO_ADDR
// if p3 = 13 then
11749: LD_VAR 0 3
11753: PUSH
11754: LD_INT 13
11756: EQUAL
11757: IFFALSE 11767
// sDepot := true ;
11759: LD_ADDR_EXP 49
11763: PUSH
11764: LD_INT 1
11766: ST_TO_ADDR
// if p3 = 14 then
11767: LD_VAR 0 3
11771: PUSH
11772: LD_INT 14
11774: EQUAL
11775: IFFALSE 11785
// sFlag := true ;
11777: LD_ADDR_EXP 50
11781: PUSH
11782: LD_INT 1
11784: ST_TO_ADDR
// if p3 = 15 then
11785: LD_VAR 0 3
11789: PUSH
11790: LD_INT 15
11792: EQUAL
11793: IFFALSE 11803
// sKamikadze := true ;
11795: LD_ADDR_EXP 58
11799: PUSH
11800: LD_INT 1
11802: ST_TO_ADDR
// if p3 = 16 then
11803: LD_VAR 0 3
11807: PUSH
11808: LD_INT 16
11810: EQUAL
11811: IFFALSE 11821
// sTroll := true ;
11813: LD_ADDR_EXP 59
11817: PUSH
11818: LD_INT 1
11820: ST_TO_ADDR
// if p3 = 17 then
11821: LD_VAR 0 3
11825: PUSH
11826: LD_INT 17
11828: EQUAL
11829: IFFALSE 11839
// sSlow := true ;
11831: LD_ADDR_EXP 60
11835: PUSH
11836: LD_INT 1
11838: ST_TO_ADDR
// if p3 = 18 then
11839: LD_VAR 0 3
11843: PUSH
11844: LD_INT 18
11846: EQUAL
11847: IFFALSE 11857
// sLack := true ;
11849: LD_ADDR_EXP 61
11853: PUSH
11854: LD_INT 1
11856: ST_TO_ADDR
// if p3 = 19 then
11857: LD_VAR 0 3
11861: PUSH
11862: LD_INT 19
11864: EQUAL
11865: IFFALSE 11875
// sTank := true ;
11867: LD_ADDR_EXP 63
11871: PUSH
11872: LD_INT 1
11874: ST_TO_ADDR
// if p3 = 20 then
11875: LD_VAR 0 3
11879: PUSH
11880: LD_INT 20
11882: EQUAL
11883: IFFALSE 11893
// sRemote := true ;
11885: LD_ADDR_EXP 64
11889: PUSH
11890: LD_INT 1
11892: ST_TO_ADDR
// if p3 = 21 then
11893: LD_VAR 0 3
11897: PUSH
11898: LD_INT 21
11900: EQUAL
11901: IFFALSE 11911
// sPowell := true ;
11903: LD_ADDR_EXP 65
11907: PUSH
11908: LD_INT 1
11910: ST_TO_ADDR
// if p3 = 22 then
11911: LD_VAR 0 3
11915: PUSH
11916: LD_INT 22
11918: EQUAL
11919: IFFALSE 11929
// sTeleport := true ;
11921: LD_ADDR_EXP 68
11925: PUSH
11926: LD_INT 1
11928: ST_TO_ADDR
// if p3 = 23 then
11929: LD_VAR 0 3
11933: PUSH
11934: LD_INT 23
11936: EQUAL
11937: IFFALSE 11947
// sOilTower := true ;
11939: LD_ADDR_EXP 70
11943: PUSH
11944: LD_INT 1
11946: ST_TO_ADDR
// if p3 = 24 then
11947: LD_VAR 0 3
11951: PUSH
11952: LD_INT 24
11954: EQUAL
11955: IFFALSE 11965
// sShovel := true ;
11957: LD_ADDR_EXP 71
11961: PUSH
11962: LD_INT 1
11964: ST_TO_ADDR
// if p3 = 25 then
11965: LD_VAR 0 3
11969: PUSH
11970: LD_INT 25
11972: EQUAL
11973: IFFALSE 11983
// sSheik := true ;
11975: LD_ADDR_EXP 72
11979: PUSH
11980: LD_INT 1
11982: ST_TO_ADDR
// if p3 = 26 then
11983: LD_VAR 0 3
11987: PUSH
11988: LD_INT 26
11990: EQUAL
11991: IFFALSE 12001
// sEarthquake := true ;
11993: LD_ADDR_EXP 74
11997: PUSH
11998: LD_INT 1
12000: ST_TO_ADDR
// if p3 = 27 then
12001: LD_VAR 0 3
12005: PUSH
12006: LD_INT 27
12008: EQUAL
12009: IFFALSE 12019
// sAI := true ;
12011: LD_ADDR_EXP 75
12015: PUSH
12016: LD_INT 1
12018: ST_TO_ADDR
// if p3 = 28 then
12019: LD_VAR 0 3
12023: PUSH
12024: LD_INT 28
12026: EQUAL
12027: IFFALSE 12037
// sCargo := true ;
12029: LD_ADDR_EXP 78
12033: PUSH
12034: LD_INT 1
12036: ST_TO_ADDR
// if p3 = 29 then
12037: LD_VAR 0 3
12041: PUSH
12042: LD_INT 29
12044: EQUAL
12045: IFFALSE 12055
// sDLaser := true ;
12047: LD_ADDR_EXP 79
12051: PUSH
12052: LD_INT 1
12054: ST_TO_ADDR
// if p3 = 30 then
12055: LD_VAR 0 3
12059: PUSH
12060: LD_INT 30
12062: EQUAL
12063: IFFALSE 12073
// sExchange := true ;
12065: LD_ADDR_EXP 80
12069: PUSH
12070: LD_INT 1
12072: ST_TO_ADDR
// if p3 = 31 then
12073: LD_VAR 0 3
12077: PUSH
12078: LD_INT 31
12080: EQUAL
12081: IFFALSE 12091
// sFac := true ;
12083: LD_ADDR_EXP 81
12087: PUSH
12088: LD_INT 1
12090: ST_TO_ADDR
// if p3 = 32 then
12091: LD_VAR 0 3
12095: PUSH
12096: LD_INT 32
12098: EQUAL
12099: IFFALSE 12109
// sPower := true ;
12101: LD_ADDR_EXP 82
12105: PUSH
12106: LD_INT 1
12108: ST_TO_ADDR
// if p3 = 33 then
12109: LD_VAR 0 3
12113: PUSH
12114: LD_INT 33
12116: EQUAL
12117: IFFALSE 12127
// sRandom := true ;
12119: LD_ADDR_EXP 83
12123: PUSH
12124: LD_INT 1
12126: ST_TO_ADDR
// if p3 = 34 then
12127: LD_VAR 0 3
12131: PUSH
12132: LD_INT 34
12134: EQUAL
12135: IFFALSE 12145
// sShield := true ;
12137: LD_ADDR_EXP 84
12141: PUSH
12142: LD_INT 1
12144: ST_TO_ADDR
// if p3 = 35 then
12145: LD_VAR 0 3
12149: PUSH
12150: LD_INT 35
12152: EQUAL
12153: IFFALSE 12163
// sTime := true ;
12155: LD_ADDR_EXP 85
12159: PUSH
12160: LD_INT 1
12162: ST_TO_ADDR
// if p3 = 36 then
12163: LD_VAR 0 3
12167: PUSH
12168: LD_INT 36
12170: EQUAL
12171: IFFALSE 12181
// sTools := true ;
12173: LD_ADDR_EXP 86
12177: PUSH
12178: LD_INT 1
12180: ST_TO_ADDR
// if p3 = 101 then
12181: LD_VAR 0 3
12185: PUSH
12186: LD_INT 101
12188: EQUAL
12189: IFFALSE 12199
// sSold := true ;
12191: LD_ADDR_EXP 51
12195: PUSH
12196: LD_INT 1
12198: ST_TO_ADDR
// if p3 = 102 then
12199: LD_VAR 0 3
12203: PUSH
12204: LD_INT 102
12206: EQUAL
12207: IFFALSE 12217
// sDiff := true ;
12209: LD_ADDR_EXP 52
12213: PUSH
12214: LD_INT 1
12216: ST_TO_ADDR
// if p3 = 103 then
12217: LD_VAR 0 3
12221: PUSH
12222: LD_INT 103
12224: EQUAL
12225: IFFALSE 12235
// sFog := true ;
12227: LD_ADDR_EXP 55
12231: PUSH
12232: LD_INT 1
12234: ST_TO_ADDR
// if p3 = 104 then
12235: LD_VAR 0 3
12239: PUSH
12240: LD_INT 104
12242: EQUAL
12243: IFFALSE 12253
// sReset := true ;
12245: LD_ADDR_EXP 56
12249: PUSH
12250: LD_INT 1
12252: ST_TO_ADDR
// if p3 = 105 then
12253: LD_VAR 0 3
12257: PUSH
12258: LD_INT 105
12260: EQUAL
12261: IFFALSE 12271
// sSun := true ;
12263: LD_ADDR_EXP 57
12267: PUSH
12268: LD_INT 1
12270: ST_TO_ADDR
// if p3 = 106 then
12271: LD_VAR 0 3
12275: PUSH
12276: LD_INT 106
12278: EQUAL
12279: IFFALSE 12289
// sTiger := true ;
12281: LD_ADDR_EXP 53
12285: PUSH
12286: LD_INT 1
12288: ST_TO_ADDR
// if p3 = 107 then
12289: LD_VAR 0 3
12293: PUSH
12294: LD_INT 107
12296: EQUAL
12297: IFFALSE 12307
// sBomb := true ;
12299: LD_ADDR_EXP 54
12303: PUSH
12304: LD_INT 1
12306: ST_TO_ADDR
// if p3 = 108 then
12307: LD_VAR 0 3
12311: PUSH
12312: LD_INT 108
12314: EQUAL
12315: IFFALSE 12325
// sWound := true ;
12317: LD_ADDR_EXP 62
12321: PUSH
12322: LD_INT 1
12324: ST_TO_ADDR
// if p3 = 109 then
12325: LD_VAR 0 3
12329: PUSH
12330: LD_INT 109
12332: EQUAL
12333: IFFALSE 12343
// sBetray := true ;
12335: LD_ADDR_EXP 66
12339: PUSH
12340: LD_INT 1
12342: ST_TO_ADDR
// if p3 = 110 then
12343: LD_VAR 0 3
12347: PUSH
12348: LD_INT 110
12350: EQUAL
12351: IFFALSE 12361
// sContamin := true ;
12353: LD_ADDR_EXP 67
12357: PUSH
12358: LD_INT 1
12360: ST_TO_ADDR
// if p3 = 111 then
12361: LD_VAR 0 3
12365: PUSH
12366: LD_INT 111
12368: EQUAL
12369: IFFALSE 12379
// sOil := true ;
12371: LD_ADDR_EXP 69
12375: PUSH
12376: LD_INT 1
12378: ST_TO_ADDR
// if p3 = 112 then
12379: LD_VAR 0 3
12383: PUSH
12384: LD_INT 112
12386: EQUAL
12387: IFFALSE 12397
// sStu := true ;
12389: LD_ADDR_EXP 73
12393: PUSH
12394: LD_INT 1
12396: ST_TO_ADDR
// if p3 = 113 then
12397: LD_VAR 0 3
12401: PUSH
12402: LD_INT 113
12404: EQUAL
12405: IFFALSE 12415
// sBazooka := true ;
12407: LD_ADDR_EXP 76
12411: PUSH
12412: LD_INT 1
12414: ST_TO_ADDR
// if p3 = 114 then
12415: LD_VAR 0 3
12419: PUSH
12420: LD_INT 114
12422: EQUAL
12423: IFFALSE 12433
// sMortar := true ;
12425: LD_ADDR_EXP 77
12429: PUSH
12430: LD_INT 1
12432: ST_TO_ADDR
// if p3 = 115 then
12433: LD_VAR 0 3
12437: PUSH
12438: LD_INT 115
12440: EQUAL
12441: IFFALSE 12451
// sRanger := true ;
12443: LD_ADDR_EXP 87
12447: PUSH
12448: LD_INT 1
12450: ST_TO_ADDR
// end ; end ;
12451: PPOPN 6
12453: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
12454: LD_EXP 34
12458: PUSH
12459: LD_EXP 39
12463: AND
12464: IFFALSE 12588
12466: GO 12468
12468: DISABLE
12469: LD_INT 0
12471: PPUSH
12472: PPUSH
// begin enable ;
12473: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
12474: LD_ADDR_VAR 0 2
12478: PUSH
12479: LD_INT 22
12481: PUSH
12482: LD_OWVAR 2
12486: PUSH
12487: EMPTY
12488: LIST
12489: LIST
12490: PUSH
12491: LD_INT 2
12493: PUSH
12494: LD_INT 34
12496: PUSH
12497: LD_INT 7
12499: PUSH
12500: EMPTY
12501: LIST
12502: LIST
12503: PUSH
12504: LD_INT 34
12506: PUSH
12507: LD_INT 45
12509: PUSH
12510: EMPTY
12511: LIST
12512: LIST
12513: PUSH
12514: LD_INT 34
12516: PUSH
12517: LD_INT 28
12519: PUSH
12520: EMPTY
12521: LIST
12522: LIST
12523: PUSH
12524: LD_INT 34
12526: PUSH
12527: LD_INT 47
12529: PUSH
12530: EMPTY
12531: LIST
12532: LIST
12533: PUSH
12534: EMPTY
12535: LIST
12536: LIST
12537: LIST
12538: LIST
12539: LIST
12540: PUSH
12541: EMPTY
12542: LIST
12543: LIST
12544: PPUSH
12545: CALL_OW 69
12549: ST_TO_ADDR
// if not tmp then
12550: LD_VAR 0 2
12554: NOT
12555: IFFALSE 12559
// exit ;
12557: GO 12588
// for i in tmp do
12559: LD_ADDR_VAR 0 1
12563: PUSH
12564: LD_VAR 0 2
12568: PUSH
12569: FOR_IN
12570: IFFALSE 12586
// begin SetLives ( i , 0 ) ;
12572: LD_VAR 0 1
12576: PPUSH
12577: LD_INT 0
12579: PPUSH
12580: CALL_OW 234
// end ;
12584: GO 12569
12586: POP
12587: POP
// end ;
12588: PPOPN 2
12590: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
12591: LD_EXP 34
12595: PUSH
12596: LD_EXP 40
12600: AND
12601: IFFALSE 12685
12603: GO 12605
12605: DISABLE
12606: LD_INT 0
12608: PPUSH
12609: PPUSH
// begin enable ;
12610: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
12611: LD_ADDR_VAR 0 2
12615: PUSH
12616: LD_INT 22
12618: PUSH
12619: LD_OWVAR 2
12623: PUSH
12624: EMPTY
12625: LIST
12626: LIST
12627: PUSH
12628: LD_INT 32
12630: PUSH
12631: LD_INT 3
12633: PUSH
12634: EMPTY
12635: LIST
12636: LIST
12637: PUSH
12638: EMPTY
12639: LIST
12640: LIST
12641: PPUSH
12642: CALL_OW 69
12646: ST_TO_ADDR
// if not tmp then
12647: LD_VAR 0 2
12651: NOT
12652: IFFALSE 12656
// exit ;
12654: GO 12685
// for i in tmp do
12656: LD_ADDR_VAR 0 1
12660: PUSH
12661: LD_VAR 0 2
12665: PUSH
12666: FOR_IN
12667: IFFALSE 12683
// begin SetLives ( i , 0 ) ;
12669: LD_VAR 0 1
12673: PPUSH
12674: LD_INT 0
12676: PPUSH
12677: CALL_OW 234
// end ;
12681: GO 12666
12683: POP
12684: POP
// end ;
12685: PPOPN 2
12687: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
12688: LD_EXP 34
12692: PUSH
12693: LD_EXP 37
12697: AND
12698: IFFALSE 12791
12700: GO 12702
12702: DISABLE
12703: LD_INT 0
12705: PPUSH
// begin enable ;
12706: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
12707: LD_ADDR_VAR 0 1
12711: PUSH
12712: LD_INT 22
12714: PUSH
12715: LD_OWVAR 2
12719: PUSH
12720: EMPTY
12721: LIST
12722: LIST
12723: PUSH
12724: LD_INT 2
12726: PUSH
12727: LD_INT 25
12729: PUSH
12730: LD_INT 5
12732: PUSH
12733: EMPTY
12734: LIST
12735: LIST
12736: PUSH
12737: LD_INT 25
12739: PUSH
12740: LD_INT 9
12742: PUSH
12743: EMPTY
12744: LIST
12745: LIST
12746: PUSH
12747: LD_INT 25
12749: PUSH
12750: LD_INT 8
12752: PUSH
12753: EMPTY
12754: LIST
12755: LIST
12756: PUSH
12757: EMPTY
12758: LIST
12759: LIST
12760: LIST
12761: LIST
12762: PUSH
12763: EMPTY
12764: LIST
12765: LIST
12766: PPUSH
12767: CALL_OW 69
12771: PUSH
12772: FOR_IN
12773: IFFALSE 12789
// begin SetClass ( i , 1 ) ;
12775: LD_VAR 0 1
12779: PPUSH
12780: LD_INT 1
12782: PPUSH
12783: CALL_OW 336
// end ;
12787: GO 12772
12789: POP
12790: POP
// end ;
12791: PPOPN 1
12793: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
12794: LD_EXP 34
12798: PUSH
12799: LD_EXP 38
12803: AND
12804: PUSH
12805: LD_OWVAR 65
12809: PUSH
12810: LD_INT 7
12812: LESS
12813: AND
12814: IFFALSE 12828
12816: GO 12818
12818: DISABLE
// begin enable ;
12819: ENABLE
// game_speed := 7 ;
12820: LD_ADDR_OWVAR 65
12824: PUSH
12825: LD_INT 7
12827: ST_TO_ADDR
// end ;
12828: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
12829: LD_EXP 34
12833: PUSH
12834: LD_EXP 41
12838: AND
12839: IFFALSE 13041
12841: GO 12843
12843: DISABLE
12844: LD_INT 0
12846: PPUSH
12847: PPUSH
12848: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
12849: LD_ADDR_VAR 0 3
12853: PUSH
12854: LD_INT 81
12856: PUSH
12857: LD_OWVAR 2
12861: PUSH
12862: EMPTY
12863: LIST
12864: LIST
12865: PUSH
12866: LD_INT 21
12868: PUSH
12869: LD_INT 1
12871: PUSH
12872: EMPTY
12873: LIST
12874: LIST
12875: PUSH
12876: EMPTY
12877: LIST
12878: LIST
12879: PPUSH
12880: CALL_OW 69
12884: ST_TO_ADDR
// if not tmp then
12885: LD_VAR 0 3
12889: NOT
12890: IFFALSE 12894
// exit ;
12892: GO 13041
// if tmp > 5 then
12894: LD_VAR 0 3
12898: PUSH
12899: LD_INT 5
12901: GREATER
12902: IFFALSE 12914
// k := 5 else
12904: LD_ADDR_VAR 0 2
12908: PUSH
12909: LD_INT 5
12911: ST_TO_ADDR
12912: GO 12924
// k := tmp ;
12914: LD_ADDR_VAR 0 2
12918: PUSH
12919: LD_VAR 0 3
12923: ST_TO_ADDR
// for i := 1 to k do
12924: LD_ADDR_VAR 0 1
12928: PUSH
12929: DOUBLE
12930: LD_INT 1
12932: DEC
12933: ST_TO_ADDR
12934: LD_VAR 0 2
12938: PUSH
12939: FOR_TO
12940: IFFALSE 13039
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
12942: LD_VAR 0 3
12946: PUSH
12947: LD_VAR 0 1
12951: ARRAY
12952: PPUSH
12953: LD_VAR 0 1
12957: PUSH
12958: LD_INT 4
12960: MOD
12961: PUSH
12962: LD_INT 1
12964: PLUS
12965: PPUSH
12966: CALL_OW 259
12970: PUSH
12971: LD_INT 10
12973: LESS
12974: IFFALSE 13037
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
12976: LD_VAR 0 3
12980: PUSH
12981: LD_VAR 0 1
12985: ARRAY
12986: PPUSH
12987: LD_VAR 0 1
12991: PUSH
12992: LD_INT 4
12994: MOD
12995: PUSH
12996: LD_INT 1
12998: PLUS
12999: PPUSH
13000: LD_VAR 0 3
13004: PUSH
13005: LD_VAR 0 1
13009: ARRAY
13010: PPUSH
13011: LD_VAR 0 1
13015: PUSH
13016: LD_INT 4
13018: MOD
13019: PUSH
13020: LD_INT 1
13022: PLUS
13023: PPUSH
13024: CALL_OW 259
13028: PUSH
13029: LD_INT 1
13031: PLUS
13032: PPUSH
13033: CALL_OW 237
13037: GO 12939
13039: POP
13040: POP
// end ;
13041: PPOPN 3
13043: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
13044: LD_EXP 34
13048: PUSH
13049: LD_EXP 42
13053: AND
13054: IFFALSE 13074
13056: GO 13058
13058: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
13059: LD_INT 4
13061: PPUSH
13062: LD_OWVAR 2
13066: PPUSH
13067: LD_INT 0
13069: PPUSH
13070: CALL_OW 324
13074: END
// every 0 0$1 trigger StreamModeActive and sShovel do
13075: LD_EXP 34
13079: PUSH
13080: LD_EXP 71
13084: AND
13085: IFFALSE 13105
13087: GO 13089
13089: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
13090: LD_INT 19
13092: PPUSH
13093: LD_OWVAR 2
13097: PPUSH
13098: LD_INT 0
13100: PPUSH
13101: CALL_OW 324
13105: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
13106: LD_EXP 34
13110: PUSH
13111: LD_EXP 43
13115: AND
13116: IFFALSE 13218
13118: GO 13120
13120: DISABLE
13121: LD_INT 0
13123: PPUSH
13124: PPUSH
// begin enable ;
13125: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
13126: LD_ADDR_VAR 0 2
13130: PUSH
13131: LD_INT 22
13133: PUSH
13134: LD_OWVAR 2
13138: PUSH
13139: EMPTY
13140: LIST
13141: LIST
13142: PUSH
13143: LD_INT 2
13145: PUSH
13146: LD_INT 34
13148: PUSH
13149: LD_INT 11
13151: PUSH
13152: EMPTY
13153: LIST
13154: LIST
13155: PUSH
13156: LD_INT 34
13158: PUSH
13159: LD_INT 30
13161: PUSH
13162: EMPTY
13163: LIST
13164: LIST
13165: PUSH
13166: EMPTY
13167: LIST
13168: LIST
13169: LIST
13170: PUSH
13171: EMPTY
13172: LIST
13173: LIST
13174: PPUSH
13175: CALL_OW 69
13179: ST_TO_ADDR
// if not tmp then
13180: LD_VAR 0 2
13184: NOT
13185: IFFALSE 13189
// exit ;
13187: GO 13218
// for i in tmp do
13189: LD_ADDR_VAR 0 1
13193: PUSH
13194: LD_VAR 0 2
13198: PUSH
13199: FOR_IN
13200: IFFALSE 13216
// begin SetLives ( i , 0 ) ;
13202: LD_VAR 0 1
13206: PPUSH
13207: LD_INT 0
13209: PPUSH
13210: CALL_OW 234
// end ;
13214: GO 13199
13216: POP
13217: POP
// end ;
13218: PPOPN 2
13220: END
// every 0 0$1 trigger StreamModeActive and sBunker do
13221: LD_EXP 34
13225: PUSH
13226: LD_EXP 44
13230: AND
13231: IFFALSE 13251
13233: GO 13235
13235: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
13236: LD_INT 32
13238: PPUSH
13239: LD_OWVAR 2
13243: PPUSH
13244: LD_INT 0
13246: PPUSH
13247: CALL_OW 324
13251: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
13252: LD_EXP 34
13256: PUSH
13257: LD_EXP 45
13261: AND
13262: IFFALSE 13443
13264: GO 13266
13266: DISABLE
13267: LD_INT 0
13269: PPUSH
13270: PPUSH
13271: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
13272: LD_ADDR_VAR 0 2
13276: PUSH
13277: LD_INT 22
13279: PUSH
13280: LD_OWVAR 2
13284: PUSH
13285: EMPTY
13286: LIST
13287: LIST
13288: PUSH
13289: LD_INT 33
13291: PUSH
13292: LD_INT 3
13294: PUSH
13295: EMPTY
13296: LIST
13297: LIST
13298: PUSH
13299: EMPTY
13300: LIST
13301: LIST
13302: PPUSH
13303: CALL_OW 69
13307: ST_TO_ADDR
// if not tmp then
13308: LD_VAR 0 2
13312: NOT
13313: IFFALSE 13317
// exit ;
13315: GO 13443
// side := 0 ;
13317: LD_ADDR_VAR 0 3
13321: PUSH
13322: LD_INT 0
13324: ST_TO_ADDR
// for i := 1 to 8 do
13325: LD_ADDR_VAR 0 1
13329: PUSH
13330: DOUBLE
13331: LD_INT 1
13333: DEC
13334: ST_TO_ADDR
13335: LD_INT 8
13337: PUSH
13338: FOR_TO
13339: IFFALSE 13387
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
13341: LD_OWVAR 2
13345: PUSH
13346: LD_VAR 0 1
13350: NONEQUAL
13351: PUSH
13352: LD_OWVAR 2
13356: PPUSH
13357: LD_VAR 0 1
13361: PPUSH
13362: CALL_OW 81
13366: PUSH
13367: LD_INT 2
13369: EQUAL
13370: AND
13371: IFFALSE 13385
// begin side := i ;
13373: LD_ADDR_VAR 0 3
13377: PUSH
13378: LD_VAR 0 1
13382: ST_TO_ADDR
// break ;
13383: GO 13387
// end ;
13385: GO 13338
13387: POP
13388: POP
// if not side then
13389: LD_VAR 0 3
13393: NOT
13394: IFFALSE 13398
// exit ;
13396: GO 13443
// for i := 1 to tmp do
13398: LD_ADDR_VAR 0 1
13402: PUSH
13403: DOUBLE
13404: LD_INT 1
13406: DEC
13407: ST_TO_ADDR
13408: LD_VAR 0 2
13412: PUSH
13413: FOR_TO
13414: IFFALSE 13441
// if Prob ( 30 ) then
13416: LD_INT 30
13418: PPUSH
13419: CALL_OW 13
13423: IFFALSE 13439
// SetSide ( i , side ) ;
13425: LD_VAR 0 1
13429: PPUSH
13430: LD_VAR 0 3
13434: PPUSH
13435: CALL_OW 235
13439: GO 13413
13441: POP
13442: POP
// end ;
13443: PPOPN 3
13445: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
13446: LD_EXP 34
13450: PUSH
13451: LD_EXP 47
13455: AND
13456: IFFALSE 13575
13458: GO 13460
13460: DISABLE
13461: LD_INT 0
13463: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
13464: LD_ADDR_VAR 0 1
13468: PUSH
13469: LD_INT 22
13471: PUSH
13472: LD_OWVAR 2
13476: PUSH
13477: EMPTY
13478: LIST
13479: LIST
13480: PUSH
13481: LD_INT 21
13483: PUSH
13484: LD_INT 1
13486: PUSH
13487: EMPTY
13488: LIST
13489: LIST
13490: PUSH
13491: LD_INT 3
13493: PUSH
13494: LD_INT 23
13496: PUSH
13497: LD_INT 0
13499: PUSH
13500: EMPTY
13501: LIST
13502: LIST
13503: PUSH
13504: EMPTY
13505: LIST
13506: LIST
13507: PUSH
13508: EMPTY
13509: LIST
13510: LIST
13511: LIST
13512: PPUSH
13513: CALL_OW 69
13517: PUSH
13518: FOR_IN
13519: IFFALSE 13573
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
13521: LD_VAR 0 1
13525: PPUSH
13526: CALL_OW 257
13530: PUSH
13531: LD_INT 1
13533: PUSH
13534: LD_INT 2
13536: PUSH
13537: LD_INT 3
13539: PUSH
13540: LD_INT 4
13542: PUSH
13543: EMPTY
13544: LIST
13545: LIST
13546: LIST
13547: LIST
13548: IN
13549: IFFALSE 13571
// SetClass ( un , rand ( 1 , 4 ) ) ;
13551: LD_VAR 0 1
13555: PPUSH
13556: LD_INT 1
13558: PPUSH
13559: LD_INT 4
13561: PPUSH
13562: CALL_OW 12
13566: PPUSH
13567: CALL_OW 336
13571: GO 13518
13573: POP
13574: POP
// end ;
13575: PPOPN 1
13577: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
13578: LD_EXP 34
13582: PUSH
13583: LD_EXP 46
13587: AND
13588: IFFALSE 13667
13590: GO 13592
13592: DISABLE
13593: LD_INT 0
13595: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
13596: LD_ADDR_VAR 0 1
13600: PUSH
13601: LD_INT 22
13603: PUSH
13604: LD_OWVAR 2
13608: PUSH
13609: EMPTY
13610: LIST
13611: LIST
13612: PUSH
13613: LD_INT 21
13615: PUSH
13616: LD_INT 3
13618: PUSH
13619: EMPTY
13620: LIST
13621: LIST
13622: PUSH
13623: EMPTY
13624: LIST
13625: LIST
13626: PPUSH
13627: CALL_OW 69
13631: ST_TO_ADDR
// if not tmp then
13632: LD_VAR 0 1
13636: NOT
13637: IFFALSE 13641
// exit ;
13639: GO 13667
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
13641: LD_VAR 0 1
13645: PUSH
13646: LD_INT 1
13648: PPUSH
13649: LD_VAR 0 1
13653: PPUSH
13654: CALL_OW 12
13658: ARRAY
13659: PPUSH
13660: LD_INT 100
13662: PPUSH
13663: CALL_OW 234
// end ;
13667: PPOPN 1
13669: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
13670: LD_EXP 34
13674: PUSH
13675: LD_EXP 48
13679: AND
13680: IFFALSE 13778
13682: GO 13684
13684: DISABLE
13685: LD_INT 0
13687: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
13688: LD_ADDR_VAR 0 1
13692: PUSH
13693: LD_INT 22
13695: PUSH
13696: LD_OWVAR 2
13700: PUSH
13701: EMPTY
13702: LIST
13703: LIST
13704: PUSH
13705: LD_INT 21
13707: PUSH
13708: LD_INT 1
13710: PUSH
13711: EMPTY
13712: LIST
13713: LIST
13714: PUSH
13715: EMPTY
13716: LIST
13717: LIST
13718: PPUSH
13719: CALL_OW 69
13723: ST_TO_ADDR
// if not tmp then
13724: LD_VAR 0 1
13728: NOT
13729: IFFALSE 13733
// exit ;
13731: GO 13778
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
13733: LD_VAR 0 1
13737: PUSH
13738: LD_INT 1
13740: PPUSH
13741: LD_VAR 0 1
13745: PPUSH
13746: CALL_OW 12
13750: ARRAY
13751: PPUSH
13752: LD_INT 1
13754: PPUSH
13755: LD_INT 4
13757: PPUSH
13758: CALL_OW 12
13762: PPUSH
13763: LD_INT 3000
13765: PPUSH
13766: LD_INT 9000
13768: PPUSH
13769: CALL_OW 12
13773: PPUSH
13774: CALL_OW 492
// end ;
13778: PPOPN 1
13780: END
// every 0 0$1 trigger StreamModeActive and sDepot do
13781: LD_EXP 34
13785: PUSH
13786: LD_EXP 49
13790: AND
13791: IFFALSE 13811
13793: GO 13795
13795: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
13796: LD_INT 1
13798: PPUSH
13799: LD_OWVAR 2
13803: PPUSH
13804: LD_INT 0
13806: PPUSH
13807: CALL_OW 324
13811: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
13812: LD_EXP 34
13816: PUSH
13817: LD_EXP 50
13821: AND
13822: IFFALSE 13905
13824: GO 13826
13826: DISABLE
13827: LD_INT 0
13829: PPUSH
13830: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
13831: LD_ADDR_VAR 0 2
13835: PUSH
13836: LD_INT 22
13838: PUSH
13839: LD_OWVAR 2
13843: PUSH
13844: EMPTY
13845: LIST
13846: LIST
13847: PUSH
13848: LD_INT 21
13850: PUSH
13851: LD_INT 3
13853: PUSH
13854: EMPTY
13855: LIST
13856: LIST
13857: PUSH
13858: EMPTY
13859: LIST
13860: LIST
13861: PPUSH
13862: CALL_OW 69
13866: ST_TO_ADDR
// if not tmp then
13867: LD_VAR 0 2
13871: NOT
13872: IFFALSE 13876
// exit ;
13874: GO 13905
// for i in tmp do
13876: LD_ADDR_VAR 0 1
13880: PUSH
13881: LD_VAR 0 2
13885: PUSH
13886: FOR_IN
13887: IFFALSE 13903
// SetBLevel ( i , 10 ) ;
13889: LD_VAR 0 1
13893: PPUSH
13894: LD_INT 10
13896: PPUSH
13897: CALL_OW 241
13901: GO 13886
13903: POP
13904: POP
// end ;
13905: PPOPN 2
13907: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
13908: LD_EXP 34
13912: PUSH
13913: LD_EXP 51
13917: AND
13918: IFFALSE 14029
13920: GO 13922
13922: DISABLE
13923: LD_INT 0
13925: PPUSH
13926: PPUSH
13927: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
13928: LD_ADDR_VAR 0 3
13932: PUSH
13933: LD_INT 22
13935: PUSH
13936: LD_OWVAR 2
13940: PUSH
13941: EMPTY
13942: LIST
13943: LIST
13944: PUSH
13945: LD_INT 25
13947: PUSH
13948: LD_INT 1
13950: PUSH
13951: EMPTY
13952: LIST
13953: LIST
13954: PUSH
13955: EMPTY
13956: LIST
13957: LIST
13958: PPUSH
13959: CALL_OW 69
13963: ST_TO_ADDR
// if not tmp then
13964: LD_VAR 0 3
13968: NOT
13969: IFFALSE 13973
// exit ;
13971: GO 14029
// un := tmp [ rand ( 1 , tmp ) ] ;
13973: LD_ADDR_VAR 0 2
13977: PUSH
13978: LD_VAR 0 3
13982: PUSH
13983: LD_INT 1
13985: PPUSH
13986: LD_VAR 0 3
13990: PPUSH
13991: CALL_OW 12
13995: ARRAY
13996: ST_TO_ADDR
// if Crawls ( un ) then
13997: LD_VAR 0 2
14001: PPUSH
14002: CALL_OW 318
14006: IFFALSE 14017
// ComWalk ( un ) ;
14008: LD_VAR 0 2
14012: PPUSH
14013: CALL_OW 138
// SetClass ( un , class_sniper ) ;
14017: LD_VAR 0 2
14021: PPUSH
14022: LD_INT 5
14024: PPUSH
14025: CALL_OW 336
// end ;
14029: PPOPN 3
14031: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
14032: LD_EXP 34
14036: PUSH
14037: LD_EXP 52
14041: AND
14042: PUSH
14043: LD_OWVAR 67
14047: PUSH
14048: LD_INT 3
14050: LESS
14051: AND
14052: IFFALSE 14071
14054: GO 14056
14056: DISABLE
// Difficulty := Difficulty + 1 ;
14057: LD_ADDR_OWVAR 67
14061: PUSH
14062: LD_OWVAR 67
14066: PUSH
14067: LD_INT 1
14069: PLUS
14070: ST_TO_ADDR
14071: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
14072: LD_EXP 34
14076: PUSH
14077: LD_EXP 53
14081: AND
14082: IFFALSE 14185
14084: GO 14086
14086: DISABLE
14087: LD_INT 0
14089: PPUSH
// begin for i := 1 to 5 do
14090: LD_ADDR_VAR 0 1
14094: PUSH
14095: DOUBLE
14096: LD_INT 1
14098: DEC
14099: ST_TO_ADDR
14100: LD_INT 5
14102: PUSH
14103: FOR_TO
14104: IFFALSE 14183
// begin uc_nation := nation_nature ;
14106: LD_ADDR_OWVAR 21
14110: PUSH
14111: LD_INT 0
14113: ST_TO_ADDR
// uc_side := 0 ;
14114: LD_ADDR_OWVAR 20
14118: PUSH
14119: LD_INT 0
14121: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
14122: LD_ADDR_OWVAR 29
14126: PUSH
14127: LD_INT 12
14129: PUSH
14130: LD_INT 12
14132: PUSH
14133: EMPTY
14134: LIST
14135: LIST
14136: ST_TO_ADDR
// hc_agressivity := 20 ;
14137: LD_ADDR_OWVAR 35
14141: PUSH
14142: LD_INT 20
14144: ST_TO_ADDR
// hc_class := class_tiger ;
14145: LD_ADDR_OWVAR 28
14149: PUSH
14150: LD_INT 14
14152: ST_TO_ADDR
// hc_gallery :=  ;
14153: LD_ADDR_OWVAR 33
14157: PUSH
14158: LD_STRING 
14160: ST_TO_ADDR
// hc_name :=  ;
14161: LD_ADDR_OWVAR 26
14165: PUSH
14166: LD_STRING 
14168: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
14169: CALL_OW 44
14173: PPUSH
14174: LD_INT 0
14176: PPUSH
14177: CALL_OW 51
// end ;
14181: GO 14103
14183: POP
14184: POP
// end ;
14185: PPOPN 1
14187: END
// every 0 0$1 trigger StreamModeActive and sBomb do
14188: LD_EXP 34
14192: PUSH
14193: LD_EXP 54
14197: AND
14198: IFFALSE 14207
14200: GO 14202
14202: DISABLE
// StreamSibBomb ;
14203: CALL 14208 0 0
14207: END
// export function StreamSibBomb ; var i , x , y ; begin
14208: LD_INT 0
14210: PPUSH
14211: PPUSH
14212: PPUSH
14213: PPUSH
// result := false ;
14214: LD_ADDR_VAR 0 1
14218: PUSH
14219: LD_INT 0
14221: ST_TO_ADDR
// for i := 1 to 16 do
14222: LD_ADDR_VAR 0 2
14226: PUSH
14227: DOUBLE
14228: LD_INT 1
14230: DEC
14231: ST_TO_ADDR
14232: LD_INT 16
14234: PUSH
14235: FOR_TO
14236: IFFALSE 14435
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
14238: LD_ADDR_VAR 0 3
14242: PUSH
14243: LD_INT 10
14245: PUSH
14246: LD_INT 20
14248: PUSH
14249: LD_INT 30
14251: PUSH
14252: LD_INT 40
14254: PUSH
14255: LD_INT 50
14257: PUSH
14258: LD_INT 60
14260: PUSH
14261: LD_INT 70
14263: PUSH
14264: LD_INT 80
14266: PUSH
14267: LD_INT 90
14269: PUSH
14270: LD_INT 100
14272: PUSH
14273: LD_INT 110
14275: PUSH
14276: LD_INT 120
14278: PUSH
14279: LD_INT 130
14281: PUSH
14282: LD_INT 140
14284: PUSH
14285: LD_INT 150
14287: PUSH
14288: EMPTY
14289: LIST
14290: LIST
14291: LIST
14292: LIST
14293: LIST
14294: LIST
14295: LIST
14296: LIST
14297: LIST
14298: LIST
14299: LIST
14300: LIST
14301: LIST
14302: LIST
14303: LIST
14304: PUSH
14305: LD_INT 1
14307: PPUSH
14308: LD_INT 15
14310: PPUSH
14311: CALL_OW 12
14315: ARRAY
14316: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
14317: LD_ADDR_VAR 0 4
14321: PUSH
14322: LD_INT 10
14324: PUSH
14325: LD_INT 20
14327: PUSH
14328: LD_INT 30
14330: PUSH
14331: LD_INT 40
14333: PUSH
14334: LD_INT 50
14336: PUSH
14337: LD_INT 60
14339: PUSH
14340: LD_INT 70
14342: PUSH
14343: LD_INT 80
14345: PUSH
14346: LD_INT 90
14348: PUSH
14349: LD_INT 100
14351: PUSH
14352: LD_INT 110
14354: PUSH
14355: LD_INT 120
14357: PUSH
14358: LD_INT 130
14360: PUSH
14361: LD_INT 140
14363: PUSH
14364: LD_INT 150
14366: PUSH
14367: EMPTY
14368: LIST
14369: LIST
14370: LIST
14371: LIST
14372: LIST
14373: LIST
14374: LIST
14375: LIST
14376: LIST
14377: LIST
14378: LIST
14379: LIST
14380: LIST
14381: LIST
14382: LIST
14383: PUSH
14384: LD_INT 1
14386: PPUSH
14387: LD_INT 15
14389: PPUSH
14390: CALL_OW 12
14394: ARRAY
14395: ST_TO_ADDR
// if ValidHex ( x , y ) then
14396: LD_VAR 0 3
14400: PPUSH
14401: LD_VAR 0 4
14405: PPUSH
14406: CALL_OW 488
14410: IFFALSE 14433
// begin result := [ x , y ] ;
14412: LD_ADDR_VAR 0 1
14416: PUSH
14417: LD_VAR 0 3
14421: PUSH
14422: LD_VAR 0 4
14426: PUSH
14427: EMPTY
14428: LIST
14429: LIST
14430: ST_TO_ADDR
// break ;
14431: GO 14435
// end ; end ;
14433: GO 14235
14435: POP
14436: POP
// if result then
14437: LD_VAR 0 1
14441: IFFALSE 14501
// begin ToLua ( playSibBomb() ) ;
14443: LD_STRING playSibBomb()
14445: PPUSH
14446: CALL_OW 559
// wait ( 0 0$14 ) ;
14450: LD_INT 490
14452: PPUSH
14453: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
14457: LD_VAR 0 1
14461: PUSH
14462: LD_INT 1
14464: ARRAY
14465: PPUSH
14466: LD_VAR 0 1
14470: PUSH
14471: LD_INT 2
14473: ARRAY
14474: PPUSH
14475: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
14479: LD_VAR 0 1
14483: PUSH
14484: LD_INT 1
14486: ARRAY
14487: PPUSH
14488: LD_VAR 0 1
14492: PUSH
14493: LD_INT 2
14495: ARRAY
14496: PPUSH
14497: CALL_OW 429
// end ; end ;
14501: LD_VAR 0 1
14505: RET
// every 0 0$1 trigger StreamModeActive and sReset do
14506: LD_EXP 34
14510: PUSH
14511: LD_EXP 56
14515: AND
14516: IFFALSE 14528
14518: GO 14520
14520: DISABLE
// YouLost (  ) ;
14521: LD_STRING 
14523: PPUSH
14524: CALL_OW 104
14528: END
// every 0 0$1 trigger StreamModeActive and sFog do
14529: LD_EXP 34
14533: PUSH
14534: LD_EXP 55
14538: AND
14539: IFFALSE 14553
14541: GO 14543
14543: DISABLE
// FogOff ( your_side ) ;
14544: LD_OWVAR 2
14548: PPUSH
14549: CALL_OW 344
14553: END
// every 0 0$1 trigger StreamModeActive and sSun do
14554: LD_EXP 34
14558: PUSH
14559: LD_EXP 57
14563: AND
14564: IFFALSE 14592
14566: GO 14568
14568: DISABLE
// begin solar_recharge_percent := 0 ;
14569: LD_ADDR_OWVAR 79
14573: PUSH
14574: LD_INT 0
14576: ST_TO_ADDR
// wait ( 5 5$00 ) ;
14577: LD_INT 10500
14579: PPUSH
14580: CALL_OW 67
// solar_recharge_percent := 100 ;
14584: LD_ADDR_OWVAR 79
14588: PUSH
14589: LD_INT 100
14591: ST_TO_ADDR
// end ;
14592: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
14593: LD_EXP 34
14597: PUSH
14598: LD_EXP 58
14602: AND
14603: IFFALSE 14842
14605: GO 14607
14607: DISABLE
14608: LD_INT 0
14610: PPUSH
14611: PPUSH
14612: PPUSH
// begin tmp := [ ] ;
14613: LD_ADDR_VAR 0 3
14617: PUSH
14618: EMPTY
14619: ST_TO_ADDR
// for i := 1 to 6 do
14620: LD_ADDR_VAR 0 1
14624: PUSH
14625: DOUBLE
14626: LD_INT 1
14628: DEC
14629: ST_TO_ADDR
14630: LD_INT 6
14632: PUSH
14633: FOR_TO
14634: IFFALSE 14739
// begin uc_nation := nation_nature ;
14636: LD_ADDR_OWVAR 21
14640: PUSH
14641: LD_INT 0
14643: ST_TO_ADDR
// uc_side := 0 ;
14644: LD_ADDR_OWVAR 20
14648: PUSH
14649: LD_INT 0
14651: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
14652: LD_ADDR_OWVAR 29
14656: PUSH
14657: LD_INT 12
14659: PUSH
14660: LD_INT 12
14662: PUSH
14663: EMPTY
14664: LIST
14665: LIST
14666: ST_TO_ADDR
// hc_agressivity := 20 ;
14667: LD_ADDR_OWVAR 35
14671: PUSH
14672: LD_INT 20
14674: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
14675: LD_ADDR_OWVAR 28
14679: PUSH
14680: LD_INT 17
14682: ST_TO_ADDR
// hc_gallery :=  ;
14683: LD_ADDR_OWVAR 33
14687: PUSH
14688: LD_STRING 
14690: ST_TO_ADDR
// hc_name :=  ;
14691: LD_ADDR_OWVAR 26
14695: PUSH
14696: LD_STRING 
14698: ST_TO_ADDR
// un := CreateHuman ;
14699: LD_ADDR_VAR 0 2
14703: PUSH
14704: CALL_OW 44
14708: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
14709: LD_VAR 0 2
14713: PPUSH
14714: LD_INT 1
14716: PPUSH
14717: CALL_OW 51
// tmp := tmp ^ un ;
14721: LD_ADDR_VAR 0 3
14725: PUSH
14726: LD_VAR 0 3
14730: PUSH
14731: LD_VAR 0 2
14735: ADD
14736: ST_TO_ADDR
// end ;
14737: GO 14633
14739: POP
14740: POP
// repeat wait ( 0 0$1 ) ;
14741: LD_INT 35
14743: PPUSH
14744: CALL_OW 67
// for un in tmp do
14748: LD_ADDR_VAR 0 2
14752: PUSH
14753: LD_VAR 0 3
14757: PUSH
14758: FOR_IN
14759: IFFALSE 14833
// begin if IsDead ( un ) then
14761: LD_VAR 0 2
14765: PPUSH
14766: CALL_OW 301
14770: IFFALSE 14790
// begin tmp := tmp diff un ;
14772: LD_ADDR_VAR 0 3
14776: PUSH
14777: LD_VAR 0 3
14781: PUSH
14782: LD_VAR 0 2
14786: DIFF
14787: ST_TO_ADDR
// continue ;
14788: GO 14758
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
14790: LD_VAR 0 2
14794: PPUSH
14795: LD_INT 3
14797: PUSH
14798: LD_INT 22
14800: PUSH
14801: LD_INT 0
14803: PUSH
14804: EMPTY
14805: LIST
14806: LIST
14807: PUSH
14808: EMPTY
14809: LIST
14810: LIST
14811: PPUSH
14812: CALL_OW 69
14816: PPUSH
14817: LD_VAR 0 2
14821: PPUSH
14822: CALL_OW 74
14826: PPUSH
14827: CALL_OW 115
// end ;
14831: GO 14758
14833: POP
14834: POP
// until not tmp ;
14835: LD_VAR 0 3
14839: NOT
14840: IFFALSE 14741
// end ;
14842: PPOPN 3
14844: END
// every 0 0$1 trigger StreamModeActive and sTroll do
14845: LD_EXP 34
14849: PUSH
14850: LD_EXP 59
14854: AND
14855: IFFALSE 14909
14857: GO 14859
14859: DISABLE
// begin ToLua ( displayTroll(); ) ;
14860: LD_STRING displayTroll();
14862: PPUSH
14863: CALL_OW 559
// wait ( 3 3$00 ) ;
14867: LD_INT 6300
14869: PPUSH
14870: CALL_OW 67
// ToLua ( hideTroll(); ) ;
14874: LD_STRING hideTroll();
14876: PPUSH
14877: CALL_OW 559
// wait ( 1 1$00 ) ;
14881: LD_INT 2100
14883: PPUSH
14884: CALL_OW 67
// ToLua ( displayTroll(); ) ;
14888: LD_STRING displayTroll();
14890: PPUSH
14891: CALL_OW 559
// wait ( 1 1$00 ) ;
14895: LD_INT 2100
14897: PPUSH
14898: CALL_OW 67
// ToLua ( hideTroll(); ) ;
14902: LD_STRING hideTroll();
14904: PPUSH
14905: CALL_OW 559
// end ;
14909: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
14910: LD_EXP 34
14914: PUSH
14915: LD_EXP 60
14919: AND
14920: IFFALSE 14983
14922: GO 14924
14924: DISABLE
14925: LD_INT 0
14927: PPUSH
// begin p := 0 ;
14928: LD_ADDR_VAR 0 1
14932: PUSH
14933: LD_INT 0
14935: ST_TO_ADDR
// repeat game_speed := 1 ;
14936: LD_ADDR_OWVAR 65
14940: PUSH
14941: LD_INT 1
14943: ST_TO_ADDR
// wait ( 0 0$1 ) ;
14944: LD_INT 35
14946: PPUSH
14947: CALL_OW 67
// p := p + 1 ;
14951: LD_ADDR_VAR 0 1
14955: PUSH
14956: LD_VAR 0 1
14960: PUSH
14961: LD_INT 1
14963: PLUS
14964: ST_TO_ADDR
// until p >= 60 ;
14965: LD_VAR 0 1
14969: PUSH
14970: LD_INT 60
14972: GREATEREQUAL
14973: IFFALSE 14936
// game_speed := 4 ;
14975: LD_ADDR_OWVAR 65
14979: PUSH
14980: LD_INT 4
14982: ST_TO_ADDR
// end ;
14983: PPOPN 1
14985: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
14986: LD_EXP 34
14990: PUSH
14991: LD_EXP 61
14995: AND
14996: IFFALSE 15142
14998: GO 15000
15000: DISABLE
15001: LD_INT 0
15003: PPUSH
15004: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
15005: LD_ADDR_VAR 0 1
15009: PUSH
15010: LD_INT 22
15012: PUSH
15013: LD_OWVAR 2
15017: PUSH
15018: EMPTY
15019: LIST
15020: LIST
15021: PUSH
15022: LD_INT 2
15024: PUSH
15025: LD_INT 30
15027: PUSH
15028: LD_INT 0
15030: PUSH
15031: EMPTY
15032: LIST
15033: LIST
15034: PUSH
15035: LD_INT 30
15037: PUSH
15038: LD_INT 1
15040: PUSH
15041: EMPTY
15042: LIST
15043: LIST
15044: PUSH
15045: EMPTY
15046: LIST
15047: LIST
15048: LIST
15049: PUSH
15050: EMPTY
15051: LIST
15052: LIST
15053: PPUSH
15054: CALL_OW 69
15058: ST_TO_ADDR
// if not depot then
15059: LD_VAR 0 1
15063: NOT
15064: IFFALSE 15068
// exit ;
15066: GO 15142
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
15068: LD_ADDR_VAR 0 2
15072: PUSH
15073: LD_VAR 0 1
15077: PUSH
15078: LD_INT 1
15080: PPUSH
15081: LD_VAR 0 1
15085: PPUSH
15086: CALL_OW 12
15090: ARRAY
15091: PPUSH
15092: CALL_OW 274
15096: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
15097: LD_VAR 0 2
15101: PPUSH
15102: LD_INT 1
15104: PPUSH
15105: LD_INT 0
15107: PPUSH
15108: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
15112: LD_VAR 0 2
15116: PPUSH
15117: LD_INT 2
15119: PPUSH
15120: LD_INT 0
15122: PPUSH
15123: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
15127: LD_VAR 0 2
15131: PPUSH
15132: LD_INT 3
15134: PPUSH
15135: LD_INT 0
15137: PPUSH
15138: CALL_OW 277
// end ;
15142: PPOPN 2
15144: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
15145: LD_EXP 34
15149: PUSH
15150: LD_EXP 62
15154: AND
15155: IFFALSE 15252
15157: GO 15159
15159: DISABLE
15160: LD_INT 0
15162: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
15163: LD_ADDR_VAR 0 1
15167: PUSH
15168: LD_INT 22
15170: PUSH
15171: LD_OWVAR 2
15175: PUSH
15176: EMPTY
15177: LIST
15178: LIST
15179: PUSH
15180: LD_INT 21
15182: PUSH
15183: LD_INT 1
15185: PUSH
15186: EMPTY
15187: LIST
15188: LIST
15189: PUSH
15190: LD_INT 3
15192: PUSH
15193: LD_INT 23
15195: PUSH
15196: LD_INT 0
15198: PUSH
15199: EMPTY
15200: LIST
15201: LIST
15202: PUSH
15203: EMPTY
15204: LIST
15205: LIST
15206: PUSH
15207: EMPTY
15208: LIST
15209: LIST
15210: LIST
15211: PPUSH
15212: CALL_OW 69
15216: ST_TO_ADDR
// if not tmp then
15217: LD_VAR 0 1
15221: NOT
15222: IFFALSE 15226
// exit ;
15224: GO 15252
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
15226: LD_VAR 0 1
15230: PUSH
15231: LD_INT 1
15233: PPUSH
15234: LD_VAR 0 1
15238: PPUSH
15239: CALL_OW 12
15243: ARRAY
15244: PPUSH
15245: LD_INT 200
15247: PPUSH
15248: CALL_OW 234
// end ;
15252: PPOPN 1
15254: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
15255: LD_EXP 34
15259: PUSH
15260: LD_EXP 63
15264: AND
15265: IFFALSE 15344
15267: GO 15269
15269: DISABLE
15270: LD_INT 0
15272: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
15273: LD_ADDR_VAR 0 1
15277: PUSH
15278: LD_INT 22
15280: PUSH
15281: LD_OWVAR 2
15285: PUSH
15286: EMPTY
15287: LIST
15288: LIST
15289: PUSH
15290: LD_INT 21
15292: PUSH
15293: LD_INT 2
15295: PUSH
15296: EMPTY
15297: LIST
15298: LIST
15299: PUSH
15300: EMPTY
15301: LIST
15302: LIST
15303: PPUSH
15304: CALL_OW 69
15308: ST_TO_ADDR
// if not tmp then
15309: LD_VAR 0 1
15313: NOT
15314: IFFALSE 15318
// exit ;
15316: GO 15344
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
15318: LD_VAR 0 1
15322: PUSH
15323: LD_INT 1
15325: PPUSH
15326: LD_VAR 0 1
15330: PPUSH
15331: CALL_OW 12
15335: ARRAY
15336: PPUSH
15337: LD_INT 60
15339: PPUSH
15340: CALL_OW 234
// end ;
15344: PPOPN 1
15346: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
15347: LD_EXP 34
15351: PUSH
15352: LD_EXP 64
15356: AND
15357: IFFALSE 15456
15359: GO 15361
15361: DISABLE
15362: LD_INT 0
15364: PPUSH
15365: PPUSH
// begin enable ;
15366: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
15367: LD_ADDR_VAR 0 1
15371: PUSH
15372: LD_INT 22
15374: PUSH
15375: LD_OWVAR 2
15379: PUSH
15380: EMPTY
15381: LIST
15382: LIST
15383: PUSH
15384: LD_INT 61
15386: PUSH
15387: EMPTY
15388: LIST
15389: PUSH
15390: LD_INT 33
15392: PUSH
15393: LD_INT 2
15395: PUSH
15396: EMPTY
15397: LIST
15398: LIST
15399: PUSH
15400: EMPTY
15401: LIST
15402: LIST
15403: LIST
15404: PPUSH
15405: CALL_OW 69
15409: ST_TO_ADDR
// if not tmp then
15410: LD_VAR 0 1
15414: NOT
15415: IFFALSE 15419
// exit ;
15417: GO 15456
// for i in tmp do
15419: LD_ADDR_VAR 0 2
15423: PUSH
15424: LD_VAR 0 1
15428: PUSH
15429: FOR_IN
15430: IFFALSE 15454
// if IsControledBy ( i ) then
15432: LD_VAR 0 2
15436: PPUSH
15437: CALL_OW 312
15441: IFFALSE 15452
// ComUnlink ( i ) ;
15443: LD_VAR 0 2
15447: PPUSH
15448: CALL_OW 136
15452: GO 15429
15454: POP
15455: POP
// end ;
15456: PPOPN 2
15458: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
15459: LD_EXP 34
15463: PUSH
15464: LD_EXP 65
15468: AND
15469: IFFALSE 15603
15471: GO 15473
15473: DISABLE
15474: LD_INT 0
15476: PPUSH
15477: PPUSH
// begin ToLua ( displayPowell(); ) ;
15478: LD_STRING displayPowell();
15480: PPUSH
15481: CALL_OW 559
// uc_side := 0 ;
15485: LD_ADDR_OWVAR 20
15489: PUSH
15490: LD_INT 0
15492: ST_TO_ADDR
// uc_nation := 2 ;
15493: LD_ADDR_OWVAR 21
15497: PUSH
15498: LD_INT 2
15500: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
15501: LD_ADDR_OWVAR 37
15505: PUSH
15506: LD_INT 14
15508: ST_TO_ADDR
// vc_engine := engine_siberite ;
15509: LD_ADDR_OWVAR 39
15513: PUSH
15514: LD_INT 3
15516: ST_TO_ADDR
// vc_control := control_apeman ;
15517: LD_ADDR_OWVAR 38
15521: PUSH
15522: LD_INT 5
15524: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
15525: LD_ADDR_OWVAR 40
15529: PUSH
15530: LD_INT 29
15532: ST_TO_ADDR
// un := CreateVehicle ;
15533: LD_ADDR_VAR 0 2
15537: PUSH
15538: CALL_OW 45
15542: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
15543: LD_VAR 0 2
15547: PPUSH
15548: LD_INT 1
15550: PPUSH
15551: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
15555: LD_INT 35
15557: PPUSH
15558: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
15562: LD_VAR 0 2
15566: PPUSH
15567: LD_OWVAR 3
15571: PUSH
15572: LD_VAR 0 2
15576: DIFF
15577: PPUSH
15578: LD_VAR 0 2
15582: PPUSH
15583: CALL_OW 74
15587: PPUSH
15588: CALL_OW 115
// until IsOk ( un ) ;
15592: LD_VAR 0 2
15596: PPUSH
15597: CALL_OW 302
15601: IFFALSE 15555
// end ;
15603: PPOPN 2
15605: END
// every 0 0$1 trigger StreamModeActive and sStu do
15606: LD_EXP 34
15610: PUSH
15611: LD_EXP 73
15615: AND
15616: IFFALSE 15628
15618: GO 15620
15620: DISABLE
// begin ToLua ( displayStucuk(); ) ;
15621: LD_STRING displayStucuk();
15623: PPUSH
15624: CALL_OW 559
// end ;
15628: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
15629: LD_EXP 34
15633: PUSH
15634: LD_EXP 66
15638: AND
15639: IFFALSE 15780
15641: GO 15643
15643: DISABLE
15644: LD_INT 0
15646: PPUSH
15647: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
15648: LD_ADDR_VAR 0 2
15652: PUSH
15653: LD_INT 22
15655: PUSH
15656: LD_OWVAR 2
15660: PUSH
15661: EMPTY
15662: LIST
15663: LIST
15664: PUSH
15665: LD_INT 21
15667: PUSH
15668: LD_INT 1
15670: PUSH
15671: EMPTY
15672: LIST
15673: LIST
15674: PUSH
15675: EMPTY
15676: LIST
15677: LIST
15678: PPUSH
15679: CALL_OW 69
15683: ST_TO_ADDR
// if not tmp then
15684: LD_VAR 0 2
15688: NOT
15689: IFFALSE 15693
// exit ;
15691: GO 15780
// un := tmp [ rand ( 1 , tmp ) ] ;
15693: LD_ADDR_VAR 0 1
15697: PUSH
15698: LD_VAR 0 2
15702: PUSH
15703: LD_INT 1
15705: PPUSH
15706: LD_VAR 0 2
15710: PPUSH
15711: CALL_OW 12
15715: ARRAY
15716: ST_TO_ADDR
// SetSide ( un , 0 ) ;
15717: LD_VAR 0 1
15721: PPUSH
15722: LD_INT 0
15724: PPUSH
15725: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
15729: LD_VAR 0 1
15733: PPUSH
15734: LD_OWVAR 3
15738: PUSH
15739: LD_VAR 0 1
15743: DIFF
15744: PPUSH
15745: LD_VAR 0 1
15749: PPUSH
15750: CALL_OW 74
15754: PPUSH
15755: CALL_OW 115
// wait ( 0 0$20 ) ;
15759: LD_INT 700
15761: PPUSH
15762: CALL_OW 67
// SetSide ( un , your_side ) ;
15766: LD_VAR 0 1
15770: PPUSH
15771: LD_OWVAR 2
15775: PPUSH
15776: CALL_OW 235
// end ;
15780: PPOPN 2
15782: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
15783: LD_EXP 34
15787: PUSH
15788: LD_EXP 67
15792: AND
15793: IFFALSE 15899
15795: GO 15797
15797: DISABLE
15798: LD_INT 0
15800: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
15801: LD_ADDR_VAR 0 1
15805: PUSH
15806: LD_INT 22
15808: PUSH
15809: LD_OWVAR 2
15813: PUSH
15814: EMPTY
15815: LIST
15816: LIST
15817: PUSH
15818: LD_INT 2
15820: PUSH
15821: LD_INT 30
15823: PUSH
15824: LD_INT 0
15826: PUSH
15827: EMPTY
15828: LIST
15829: LIST
15830: PUSH
15831: LD_INT 30
15833: PUSH
15834: LD_INT 1
15836: PUSH
15837: EMPTY
15838: LIST
15839: LIST
15840: PUSH
15841: EMPTY
15842: LIST
15843: LIST
15844: LIST
15845: PUSH
15846: EMPTY
15847: LIST
15848: LIST
15849: PPUSH
15850: CALL_OW 69
15854: ST_TO_ADDR
// if not depot then
15855: LD_VAR 0 1
15859: NOT
15860: IFFALSE 15864
// exit ;
15862: GO 15899
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
15864: LD_VAR 0 1
15868: PUSH
15869: LD_INT 1
15871: ARRAY
15872: PPUSH
15873: CALL_OW 250
15877: PPUSH
15878: LD_VAR 0 1
15882: PUSH
15883: LD_INT 1
15885: ARRAY
15886: PPUSH
15887: CALL_OW 251
15891: PPUSH
15892: LD_INT 70
15894: PPUSH
15895: CALL_OW 495
// end ;
15899: PPOPN 1
15901: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
15902: LD_EXP 34
15906: PUSH
15907: LD_EXP 68
15911: AND
15912: IFFALSE 16123
15914: GO 15916
15916: DISABLE
15917: LD_INT 0
15919: PPUSH
15920: PPUSH
15921: PPUSH
15922: PPUSH
15923: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
15924: LD_ADDR_VAR 0 5
15928: PUSH
15929: LD_INT 22
15931: PUSH
15932: LD_OWVAR 2
15936: PUSH
15937: EMPTY
15938: LIST
15939: LIST
15940: PUSH
15941: LD_INT 21
15943: PUSH
15944: LD_INT 1
15946: PUSH
15947: EMPTY
15948: LIST
15949: LIST
15950: PUSH
15951: EMPTY
15952: LIST
15953: LIST
15954: PPUSH
15955: CALL_OW 69
15959: ST_TO_ADDR
// if not tmp then
15960: LD_VAR 0 5
15964: NOT
15965: IFFALSE 15969
// exit ;
15967: GO 16123
// for i in tmp do
15969: LD_ADDR_VAR 0 1
15973: PUSH
15974: LD_VAR 0 5
15978: PUSH
15979: FOR_IN
15980: IFFALSE 16121
// begin d := rand ( 0 , 5 ) ;
15982: LD_ADDR_VAR 0 4
15986: PUSH
15987: LD_INT 0
15989: PPUSH
15990: LD_INT 5
15992: PPUSH
15993: CALL_OW 12
15997: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
15998: LD_ADDR_VAR 0 2
16002: PUSH
16003: LD_VAR 0 1
16007: PPUSH
16008: CALL_OW 250
16012: PPUSH
16013: LD_VAR 0 4
16017: PPUSH
16018: LD_INT 3
16020: PPUSH
16021: LD_INT 12
16023: PPUSH
16024: CALL_OW 12
16028: PPUSH
16029: CALL_OW 272
16033: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
16034: LD_ADDR_VAR 0 3
16038: PUSH
16039: LD_VAR 0 1
16043: PPUSH
16044: CALL_OW 251
16048: PPUSH
16049: LD_VAR 0 4
16053: PPUSH
16054: LD_INT 3
16056: PPUSH
16057: LD_INT 12
16059: PPUSH
16060: CALL_OW 12
16064: PPUSH
16065: CALL_OW 273
16069: ST_TO_ADDR
// if ValidHex ( x , y ) then
16070: LD_VAR 0 2
16074: PPUSH
16075: LD_VAR 0 3
16079: PPUSH
16080: CALL_OW 488
16084: IFFALSE 16119
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
16086: LD_VAR 0 1
16090: PPUSH
16091: LD_VAR 0 2
16095: PPUSH
16096: LD_VAR 0 3
16100: PPUSH
16101: LD_INT 3
16103: PPUSH
16104: LD_INT 6
16106: PPUSH
16107: CALL_OW 12
16111: PPUSH
16112: LD_INT 1
16114: PPUSH
16115: CALL_OW 483
// end ;
16119: GO 15979
16121: POP
16122: POP
// end ;
16123: PPOPN 5
16125: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
16126: LD_EXP 34
16130: PUSH
16131: LD_EXP 69
16135: AND
16136: IFFALSE 16230
16138: GO 16140
16140: DISABLE
16141: LD_INT 0
16143: PPUSH
16144: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
16145: LD_ADDR_VAR 0 2
16149: PUSH
16150: LD_INT 22
16152: PUSH
16153: LD_OWVAR 2
16157: PUSH
16158: EMPTY
16159: LIST
16160: LIST
16161: PUSH
16162: LD_INT 32
16164: PUSH
16165: LD_INT 1
16167: PUSH
16168: EMPTY
16169: LIST
16170: LIST
16171: PUSH
16172: LD_INT 21
16174: PUSH
16175: LD_INT 2
16177: PUSH
16178: EMPTY
16179: LIST
16180: LIST
16181: PUSH
16182: EMPTY
16183: LIST
16184: LIST
16185: LIST
16186: PPUSH
16187: CALL_OW 69
16191: ST_TO_ADDR
// if not tmp then
16192: LD_VAR 0 2
16196: NOT
16197: IFFALSE 16201
// exit ;
16199: GO 16230
// for i in tmp do
16201: LD_ADDR_VAR 0 1
16205: PUSH
16206: LD_VAR 0 2
16210: PUSH
16211: FOR_IN
16212: IFFALSE 16228
// SetFuel ( i , 0 ) ;
16214: LD_VAR 0 1
16218: PPUSH
16219: LD_INT 0
16221: PPUSH
16222: CALL_OW 240
16226: GO 16211
16228: POP
16229: POP
// end ;
16230: PPOPN 2
16232: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
16233: LD_EXP 34
16237: PUSH
16238: LD_EXP 70
16242: AND
16243: IFFALSE 16309
16245: GO 16247
16247: DISABLE
16248: LD_INT 0
16250: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
16251: LD_ADDR_VAR 0 1
16255: PUSH
16256: LD_INT 22
16258: PUSH
16259: LD_OWVAR 2
16263: PUSH
16264: EMPTY
16265: LIST
16266: LIST
16267: PUSH
16268: LD_INT 30
16270: PUSH
16271: LD_INT 29
16273: PUSH
16274: EMPTY
16275: LIST
16276: LIST
16277: PUSH
16278: EMPTY
16279: LIST
16280: LIST
16281: PPUSH
16282: CALL_OW 69
16286: ST_TO_ADDR
// if not tmp then
16287: LD_VAR 0 1
16291: NOT
16292: IFFALSE 16296
// exit ;
16294: GO 16309
// DestroyUnit ( tmp [ 1 ] ) ;
16296: LD_VAR 0 1
16300: PUSH
16301: LD_INT 1
16303: ARRAY
16304: PPUSH
16305: CALL_OW 65
// end ;
16309: PPOPN 1
16311: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
16312: LD_EXP 34
16316: PUSH
16317: LD_EXP 72
16321: AND
16322: IFFALSE 16451
16324: GO 16326
16326: DISABLE
16327: LD_INT 0
16329: PPUSH
// begin uc_side := 0 ;
16330: LD_ADDR_OWVAR 20
16334: PUSH
16335: LD_INT 0
16337: ST_TO_ADDR
// uc_nation := nation_arabian ;
16338: LD_ADDR_OWVAR 21
16342: PUSH
16343: LD_INT 2
16345: ST_TO_ADDR
// hc_gallery :=  ;
16346: LD_ADDR_OWVAR 33
16350: PUSH
16351: LD_STRING 
16353: ST_TO_ADDR
// hc_name :=  ;
16354: LD_ADDR_OWVAR 26
16358: PUSH
16359: LD_STRING 
16361: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
16362: LD_INT 1
16364: PPUSH
16365: LD_INT 11
16367: PPUSH
16368: LD_INT 10
16370: PPUSH
16371: CALL_OW 380
// un := CreateHuman ;
16375: LD_ADDR_VAR 0 1
16379: PUSH
16380: CALL_OW 44
16384: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
16385: LD_VAR 0 1
16389: PPUSH
16390: LD_INT 1
16392: PPUSH
16393: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
16397: LD_INT 35
16399: PPUSH
16400: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
16404: LD_VAR 0 1
16408: PPUSH
16409: LD_INT 22
16411: PUSH
16412: LD_OWVAR 2
16416: PUSH
16417: EMPTY
16418: LIST
16419: LIST
16420: PPUSH
16421: CALL_OW 69
16425: PPUSH
16426: LD_VAR 0 1
16430: PPUSH
16431: CALL_OW 74
16435: PPUSH
16436: CALL_OW 115
// until IsDead ( un ) ;
16440: LD_VAR 0 1
16444: PPUSH
16445: CALL_OW 301
16449: IFFALSE 16397
// end ;
16451: PPOPN 1
16453: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
16454: LD_EXP 34
16458: PUSH
16459: LD_EXP 74
16463: AND
16464: IFFALSE 16476
16466: GO 16468
16468: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
16469: LD_STRING earthquake(getX(game), 0, 32)
16471: PPUSH
16472: CALL_OW 559
16476: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
16477: LD_EXP 34
16481: PUSH
16482: LD_EXP 75
16486: AND
16487: IFFALSE 16578
16489: GO 16491
16491: DISABLE
16492: LD_INT 0
16494: PPUSH
// begin enable ;
16495: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
16496: LD_ADDR_VAR 0 1
16500: PUSH
16501: LD_INT 22
16503: PUSH
16504: LD_OWVAR 2
16508: PUSH
16509: EMPTY
16510: LIST
16511: LIST
16512: PUSH
16513: LD_INT 21
16515: PUSH
16516: LD_INT 2
16518: PUSH
16519: EMPTY
16520: LIST
16521: LIST
16522: PUSH
16523: LD_INT 33
16525: PUSH
16526: LD_INT 3
16528: PUSH
16529: EMPTY
16530: LIST
16531: LIST
16532: PUSH
16533: EMPTY
16534: LIST
16535: LIST
16536: LIST
16537: PPUSH
16538: CALL_OW 69
16542: ST_TO_ADDR
// if not tmp then
16543: LD_VAR 0 1
16547: NOT
16548: IFFALSE 16552
// exit ;
16550: GO 16578
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
16552: LD_VAR 0 1
16556: PUSH
16557: LD_INT 1
16559: PPUSH
16560: LD_VAR 0 1
16564: PPUSH
16565: CALL_OW 12
16569: ARRAY
16570: PPUSH
16571: LD_INT 1
16573: PPUSH
16574: CALL_OW 234
// end ;
16578: PPOPN 1
16580: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
16581: LD_EXP 34
16585: PUSH
16586: LD_EXP 76
16590: AND
16591: IFFALSE 16732
16593: GO 16595
16595: DISABLE
16596: LD_INT 0
16598: PPUSH
16599: PPUSH
16600: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
16601: LD_ADDR_VAR 0 3
16605: PUSH
16606: LD_INT 22
16608: PUSH
16609: LD_OWVAR 2
16613: PUSH
16614: EMPTY
16615: LIST
16616: LIST
16617: PUSH
16618: LD_INT 25
16620: PUSH
16621: LD_INT 1
16623: PUSH
16624: EMPTY
16625: LIST
16626: LIST
16627: PUSH
16628: EMPTY
16629: LIST
16630: LIST
16631: PPUSH
16632: CALL_OW 69
16636: ST_TO_ADDR
// if not tmp then
16637: LD_VAR 0 3
16641: NOT
16642: IFFALSE 16646
// exit ;
16644: GO 16732
// un := tmp [ rand ( 1 , tmp ) ] ;
16646: LD_ADDR_VAR 0 2
16650: PUSH
16651: LD_VAR 0 3
16655: PUSH
16656: LD_INT 1
16658: PPUSH
16659: LD_VAR 0 3
16663: PPUSH
16664: CALL_OW 12
16668: ARRAY
16669: ST_TO_ADDR
// if Crawls ( un ) then
16670: LD_VAR 0 2
16674: PPUSH
16675: CALL_OW 318
16679: IFFALSE 16690
// ComWalk ( un ) ;
16681: LD_VAR 0 2
16685: PPUSH
16686: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
16690: LD_VAR 0 2
16694: PPUSH
16695: LD_INT 9
16697: PPUSH
16698: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
16702: LD_INT 28
16704: PPUSH
16705: LD_OWVAR 2
16709: PPUSH
16710: LD_INT 2
16712: PPUSH
16713: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
16717: LD_INT 29
16719: PPUSH
16720: LD_OWVAR 2
16724: PPUSH
16725: LD_INT 2
16727: PPUSH
16728: CALL_OW 322
// end ;
16732: PPOPN 3
16734: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
16735: LD_EXP 34
16739: PUSH
16740: LD_EXP 77
16744: AND
16745: IFFALSE 16856
16747: GO 16749
16749: DISABLE
16750: LD_INT 0
16752: PPUSH
16753: PPUSH
16754: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
16755: LD_ADDR_VAR 0 3
16759: PUSH
16760: LD_INT 22
16762: PUSH
16763: LD_OWVAR 2
16767: PUSH
16768: EMPTY
16769: LIST
16770: LIST
16771: PUSH
16772: LD_INT 25
16774: PUSH
16775: LD_INT 1
16777: PUSH
16778: EMPTY
16779: LIST
16780: LIST
16781: PUSH
16782: EMPTY
16783: LIST
16784: LIST
16785: PPUSH
16786: CALL_OW 69
16790: ST_TO_ADDR
// if not tmp then
16791: LD_VAR 0 3
16795: NOT
16796: IFFALSE 16800
// exit ;
16798: GO 16856
// un := tmp [ rand ( 1 , tmp ) ] ;
16800: LD_ADDR_VAR 0 2
16804: PUSH
16805: LD_VAR 0 3
16809: PUSH
16810: LD_INT 1
16812: PPUSH
16813: LD_VAR 0 3
16817: PPUSH
16818: CALL_OW 12
16822: ARRAY
16823: ST_TO_ADDR
// if Crawls ( un ) then
16824: LD_VAR 0 2
16828: PPUSH
16829: CALL_OW 318
16833: IFFALSE 16844
// ComWalk ( un ) ;
16835: LD_VAR 0 2
16839: PPUSH
16840: CALL_OW 138
// SetClass ( un , class_mortar ) ;
16844: LD_VAR 0 2
16848: PPUSH
16849: LD_INT 8
16851: PPUSH
16852: CALL_OW 336
// end ;
16856: PPOPN 3
16858: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
16859: LD_EXP 34
16863: PUSH
16864: LD_EXP 78
16868: AND
16869: IFFALSE 17013
16871: GO 16873
16873: DISABLE
16874: LD_INT 0
16876: PPUSH
16877: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
16878: LD_ADDR_VAR 0 2
16882: PUSH
16883: LD_INT 22
16885: PUSH
16886: LD_OWVAR 2
16890: PUSH
16891: EMPTY
16892: LIST
16893: LIST
16894: PUSH
16895: LD_INT 21
16897: PUSH
16898: LD_INT 2
16900: PUSH
16901: EMPTY
16902: LIST
16903: LIST
16904: PUSH
16905: LD_INT 2
16907: PUSH
16908: LD_INT 34
16910: PUSH
16911: LD_INT 12
16913: PUSH
16914: EMPTY
16915: LIST
16916: LIST
16917: PUSH
16918: LD_INT 34
16920: PUSH
16921: LD_INT 51
16923: PUSH
16924: EMPTY
16925: LIST
16926: LIST
16927: PUSH
16928: LD_INT 34
16930: PUSH
16931: LD_INT 32
16933: PUSH
16934: EMPTY
16935: LIST
16936: LIST
16937: PUSH
16938: EMPTY
16939: LIST
16940: LIST
16941: LIST
16942: LIST
16943: PUSH
16944: EMPTY
16945: LIST
16946: LIST
16947: LIST
16948: PPUSH
16949: CALL_OW 69
16953: ST_TO_ADDR
// if not tmp then
16954: LD_VAR 0 2
16958: NOT
16959: IFFALSE 16963
// exit ;
16961: GO 17013
// for i in tmp do
16963: LD_ADDR_VAR 0 1
16967: PUSH
16968: LD_VAR 0 2
16972: PUSH
16973: FOR_IN
16974: IFFALSE 17011
// if GetCargo ( i , mat_artifact ) = 0 then
16976: LD_VAR 0 1
16980: PPUSH
16981: LD_INT 4
16983: PPUSH
16984: CALL_OW 289
16988: PUSH
16989: LD_INT 0
16991: EQUAL
16992: IFFALSE 17009
// SetCargo ( i , mat_siberit , 100 ) ;
16994: LD_VAR 0 1
16998: PPUSH
16999: LD_INT 3
17001: PPUSH
17002: LD_INT 100
17004: PPUSH
17005: CALL_OW 290
17009: GO 16973
17011: POP
17012: POP
// end ;
17013: PPOPN 2
17015: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
17016: LD_EXP 34
17020: PUSH
17021: LD_EXP 79
17025: AND
17026: IFFALSE 17179
17028: GO 17030
17030: DISABLE
17031: LD_INT 0
17033: PPUSH
17034: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
17035: LD_ADDR_VAR 0 2
17039: PUSH
17040: LD_INT 22
17042: PUSH
17043: LD_OWVAR 2
17047: PUSH
17048: EMPTY
17049: LIST
17050: LIST
17051: PPUSH
17052: CALL_OW 69
17056: ST_TO_ADDR
// if not tmp then
17057: LD_VAR 0 2
17061: NOT
17062: IFFALSE 17066
// exit ;
17064: GO 17179
// for i := 1 to 2 do
17066: LD_ADDR_VAR 0 1
17070: PUSH
17071: DOUBLE
17072: LD_INT 1
17074: DEC
17075: ST_TO_ADDR
17076: LD_INT 2
17078: PUSH
17079: FOR_TO
17080: IFFALSE 17177
// begin uc_side := your_side ;
17082: LD_ADDR_OWVAR 20
17086: PUSH
17087: LD_OWVAR 2
17091: ST_TO_ADDR
// uc_nation := nation_american ;
17092: LD_ADDR_OWVAR 21
17096: PUSH
17097: LD_INT 1
17099: ST_TO_ADDR
// vc_chassis := us_morphling ;
17100: LD_ADDR_OWVAR 37
17104: PUSH
17105: LD_INT 5
17107: ST_TO_ADDR
// vc_engine := engine_siberite ;
17108: LD_ADDR_OWVAR 39
17112: PUSH
17113: LD_INT 3
17115: ST_TO_ADDR
// vc_control := control_computer ;
17116: LD_ADDR_OWVAR 38
17120: PUSH
17121: LD_INT 3
17123: ST_TO_ADDR
// vc_weapon := us_double_laser ;
17124: LD_ADDR_OWVAR 40
17128: PUSH
17129: LD_INT 10
17131: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
17132: CALL_OW 45
17136: PPUSH
17137: LD_VAR 0 2
17141: PUSH
17142: LD_INT 1
17144: ARRAY
17145: PPUSH
17146: CALL_OW 250
17150: PPUSH
17151: LD_VAR 0 2
17155: PUSH
17156: LD_INT 1
17158: ARRAY
17159: PPUSH
17160: CALL_OW 251
17164: PPUSH
17165: LD_INT 12
17167: PPUSH
17168: LD_INT 1
17170: PPUSH
17171: CALL_OW 50
// end ;
17175: GO 17079
17177: POP
17178: POP
// end ;
17179: PPOPN 2
17181: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
17182: LD_EXP 34
17186: PUSH
17187: LD_EXP 80
17191: AND
17192: IFFALSE 17414
17194: GO 17196
17196: DISABLE
17197: LD_INT 0
17199: PPUSH
17200: PPUSH
17201: PPUSH
17202: PPUSH
17203: PPUSH
17204: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
17205: LD_ADDR_VAR 0 6
17209: PUSH
17210: LD_INT 22
17212: PUSH
17213: LD_OWVAR 2
17217: PUSH
17218: EMPTY
17219: LIST
17220: LIST
17221: PUSH
17222: LD_INT 21
17224: PUSH
17225: LD_INT 1
17227: PUSH
17228: EMPTY
17229: LIST
17230: LIST
17231: PUSH
17232: LD_INT 3
17234: PUSH
17235: LD_INT 23
17237: PUSH
17238: LD_INT 0
17240: PUSH
17241: EMPTY
17242: LIST
17243: LIST
17244: PUSH
17245: EMPTY
17246: LIST
17247: LIST
17248: PUSH
17249: EMPTY
17250: LIST
17251: LIST
17252: LIST
17253: PPUSH
17254: CALL_OW 69
17258: ST_TO_ADDR
// if not tmp then
17259: LD_VAR 0 6
17263: NOT
17264: IFFALSE 17268
// exit ;
17266: GO 17414
// s1 := rand ( 1 , 4 ) ;
17268: LD_ADDR_VAR 0 2
17272: PUSH
17273: LD_INT 1
17275: PPUSH
17276: LD_INT 4
17278: PPUSH
17279: CALL_OW 12
17283: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
17284: LD_ADDR_VAR 0 4
17288: PUSH
17289: LD_VAR 0 6
17293: PUSH
17294: LD_INT 1
17296: ARRAY
17297: PPUSH
17298: LD_VAR 0 2
17302: PPUSH
17303: CALL_OW 259
17307: ST_TO_ADDR
// if s1 = 1 then
17308: LD_VAR 0 2
17312: PUSH
17313: LD_INT 1
17315: EQUAL
17316: IFFALSE 17336
// s2 := rand ( 2 , 4 ) else
17318: LD_ADDR_VAR 0 3
17322: PUSH
17323: LD_INT 2
17325: PPUSH
17326: LD_INT 4
17328: PPUSH
17329: CALL_OW 12
17333: ST_TO_ADDR
17334: GO 17344
// s2 := 1 ;
17336: LD_ADDR_VAR 0 3
17340: PUSH
17341: LD_INT 1
17343: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
17344: LD_ADDR_VAR 0 5
17348: PUSH
17349: LD_VAR 0 6
17353: PUSH
17354: LD_INT 1
17356: ARRAY
17357: PPUSH
17358: LD_VAR 0 3
17362: PPUSH
17363: CALL_OW 259
17367: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
17368: LD_VAR 0 6
17372: PUSH
17373: LD_INT 1
17375: ARRAY
17376: PPUSH
17377: LD_VAR 0 2
17381: PPUSH
17382: LD_VAR 0 5
17386: PPUSH
17387: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
17391: LD_VAR 0 6
17395: PUSH
17396: LD_INT 1
17398: ARRAY
17399: PPUSH
17400: LD_VAR 0 3
17404: PPUSH
17405: LD_VAR 0 4
17409: PPUSH
17410: CALL_OW 237
// end ;
17414: PPOPN 6
17416: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
17417: LD_EXP 34
17421: PUSH
17422: LD_EXP 81
17426: AND
17427: IFFALSE 17506
17429: GO 17431
17431: DISABLE
17432: LD_INT 0
17434: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
17435: LD_ADDR_VAR 0 1
17439: PUSH
17440: LD_INT 22
17442: PUSH
17443: LD_OWVAR 2
17447: PUSH
17448: EMPTY
17449: LIST
17450: LIST
17451: PUSH
17452: LD_INT 30
17454: PUSH
17455: LD_INT 3
17457: PUSH
17458: EMPTY
17459: LIST
17460: LIST
17461: PUSH
17462: EMPTY
17463: LIST
17464: LIST
17465: PPUSH
17466: CALL_OW 69
17470: ST_TO_ADDR
// if not tmp then
17471: LD_VAR 0 1
17475: NOT
17476: IFFALSE 17480
// exit ;
17478: GO 17506
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
17480: LD_VAR 0 1
17484: PUSH
17485: LD_INT 1
17487: PPUSH
17488: LD_VAR 0 1
17492: PPUSH
17493: CALL_OW 12
17497: ARRAY
17498: PPUSH
17499: LD_INT 1
17501: PPUSH
17502: CALL_OW 234
// end ;
17506: PPOPN 1
17508: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
17509: LD_EXP 34
17513: PUSH
17514: LD_EXP 82
17518: AND
17519: IFFALSE 17631
17521: GO 17523
17523: DISABLE
17524: LD_INT 0
17526: PPUSH
17527: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
17528: LD_ADDR_VAR 0 2
17532: PUSH
17533: LD_INT 22
17535: PUSH
17536: LD_OWVAR 2
17540: PUSH
17541: EMPTY
17542: LIST
17543: LIST
17544: PUSH
17545: LD_INT 2
17547: PUSH
17548: LD_INT 30
17550: PUSH
17551: LD_INT 27
17553: PUSH
17554: EMPTY
17555: LIST
17556: LIST
17557: PUSH
17558: LD_INT 30
17560: PUSH
17561: LD_INT 26
17563: PUSH
17564: EMPTY
17565: LIST
17566: LIST
17567: PUSH
17568: LD_INT 30
17570: PUSH
17571: LD_INT 28
17573: PUSH
17574: EMPTY
17575: LIST
17576: LIST
17577: PUSH
17578: EMPTY
17579: LIST
17580: LIST
17581: LIST
17582: LIST
17583: PUSH
17584: EMPTY
17585: LIST
17586: LIST
17587: PPUSH
17588: CALL_OW 69
17592: ST_TO_ADDR
// if not tmp then
17593: LD_VAR 0 2
17597: NOT
17598: IFFALSE 17602
// exit ;
17600: GO 17631
// for i in tmp do
17602: LD_ADDR_VAR 0 1
17606: PUSH
17607: LD_VAR 0 2
17611: PUSH
17612: FOR_IN
17613: IFFALSE 17629
// SetLives ( i , 1 ) ;
17615: LD_VAR 0 1
17619: PPUSH
17620: LD_INT 1
17622: PPUSH
17623: CALL_OW 234
17627: GO 17612
17629: POP
17630: POP
// end ;
17631: PPOPN 2
17633: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
17634: LD_EXP 34
17638: PUSH
17639: LD_EXP 83
17643: AND
17644: IFFALSE 17914
17646: GO 17648
17648: DISABLE
17649: LD_INT 0
17651: PPUSH
17652: PPUSH
17653: PPUSH
// begin i := rand ( 1 , 7 ) ;
17654: LD_ADDR_VAR 0 1
17658: PUSH
17659: LD_INT 1
17661: PPUSH
17662: LD_INT 7
17664: PPUSH
17665: CALL_OW 12
17669: ST_TO_ADDR
// case i of 1 :
17670: LD_VAR 0 1
17674: PUSH
17675: LD_INT 1
17677: DOUBLE
17678: EQUAL
17679: IFTRUE 17683
17681: GO 17693
17683: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
17684: LD_STRING earthquake(getX(game), 0, 32)
17686: PPUSH
17687: CALL_OW 559
17691: GO 17914
17693: LD_INT 2
17695: DOUBLE
17696: EQUAL
17697: IFTRUE 17701
17699: GO 17711
17701: POP
// ToLua ( displayStucuk(); ) ; 3 :
17702: LD_STRING displayStucuk();
17704: PPUSH
17705: CALL_OW 559
17709: GO 17914
17711: LD_INT 3
17713: DOUBLE
17714: EQUAL
17715: IFTRUE 17719
17717: GO 17823
17719: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
17720: LD_ADDR_VAR 0 2
17724: PUSH
17725: LD_INT 22
17727: PUSH
17728: LD_OWVAR 2
17732: PUSH
17733: EMPTY
17734: LIST
17735: LIST
17736: PUSH
17737: LD_INT 25
17739: PUSH
17740: LD_INT 1
17742: PUSH
17743: EMPTY
17744: LIST
17745: LIST
17746: PUSH
17747: EMPTY
17748: LIST
17749: LIST
17750: PPUSH
17751: CALL_OW 69
17755: ST_TO_ADDR
// if not tmp then
17756: LD_VAR 0 2
17760: NOT
17761: IFFALSE 17765
// exit ;
17763: GO 17914
// un := tmp [ rand ( 1 , tmp ) ] ;
17765: LD_ADDR_VAR 0 3
17769: PUSH
17770: LD_VAR 0 2
17774: PUSH
17775: LD_INT 1
17777: PPUSH
17778: LD_VAR 0 2
17782: PPUSH
17783: CALL_OW 12
17787: ARRAY
17788: ST_TO_ADDR
// if Crawls ( un ) then
17789: LD_VAR 0 3
17793: PPUSH
17794: CALL_OW 318
17798: IFFALSE 17809
// ComWalk ( un ) ;
17800: LD_VAR 0 3
17804: PPUSH
17805: CALL_OW 138
// SetClass ( un , class_mortar ) ;
17809: LD_VAR 0 3
17813: PPUSH
17814: LD_INT 8
17816: PPUSH
17817: CALL_OW 336
// end ; 4 :
17821: GO 17914
17823: LD_INT 4
17825: DOUBLE
17826: EQUAL
17827: IFTRUE 17831
17829: GO 17892
17831: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
17832: LD_ADDR_VAR 0 2
17836: PUSH
17837: LD_INT 22
17839: PUSH
17840: LD_OWVAR 2
17844: PUSH
17845: EMPTY
17846: LIST
17847: LIST
17848: PUSH
17849: LD_INT 30
17851: PUSH
17852: LD_INT 29
17854: PUSH
17855: EMPTY
17856: LIST
17857: LIST
17858: PUSH
17859: EMPTY
17860: LIST
17861: LIST
17862: PPUSH
17863: CALL_OW 69
17867: ST_TO_ADDR
// if not tmp then
17868: LD_VAR 0 2
17872: NOT
17873: IFFALSE 17877
// exit ;
17875: GO 17914
// DestroyUnit ( tmp [ 1 ] ) ;
17877: LD_VAR 0 2
17881: PUSH
17882: LD_INT 1
17884: ARRAY
17885: PPUSH
17886: CALL_OW 65
// end ; 5 .. 7 :
17890: GO 17914
17892: LD_INT 5
17894: DOUBLE
17895: GREATEREQUAL
17896: IFFALSE 17904
17898: LD_INT 7
17900: DOUBLE
17901: LESSEQUAL
17902: IFTRUE 17906
17904: GO 17913
17906: POP
// StreamSibBomb ; end ;
17907: CALL 14208 0 0
17911: GO 17914
17913: POP
// end ;
17914: PPOPN 3
17916: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
17917: LD_EXP 34
17921: PUSH
17922: LD_EXP 84
17926: AND
17927: IFFALSE 18083
17929: GO 17931
17931: DISABLE
17932: LD_INT 0
17934: PPUSH
17935: PPUSH
17936: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
17937: LD_ADDR_VAR 0 2
17941: PUSH
17942: LD_INT 81
17944: PUSH
17945: LD_OWVAR 2
17949: PUSH
17950: EMPTY
17951: LIST
17952: LIST
17953: PUSH
17954: LD_INT 2
17956: PUSH
17957: LD_INT 21
17959: PUSH
17960: LD_INT 1
17962: PUSH
17963: EMPTY
17964: LIST
17965: LIST
17966: PUSH
17967: LD_INT 21
17969: PUSH
17970: LD_INT 2
17972: PUSH
17973: EMPTY
17974: LIST
17975: LIST
17976: PUSH
17977: EMPTY
17978: LIST
17979: LIST
17980: LIST
17981: PUSH
17982: EMPTY
17983: LIST
17984: LIST
17985: PPUSH
17986: CALL_OW 69
17990: ST_TO_ADDR
// if not tmp then
17991: LD_VAR 0 2
17995: NOT
17996: IFFALSE 18000
// exit ;
17998: GO 18083
// p := 0 ;
18000: LD_ADDR_VAR 0 3
18004: PUSH
18005: LD_INT 0
18007: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18008: LD_INT 35
18010: PPUSH
18011: CALL_OW 67
// p := p + 1 ;
18015: LD_ADDR_VAR 0 3
18019: PUSH
18020: LD_VAR 0 3
18024: PUSH
18025: LD_INT 1
18027: PLUS
18028: ST_TO_ADDR
// for i in tmp do
18029: LD_ADDR_VAR 0 1
18033: PUSH
18034: LD_VAR 0 2
18038: PUSH
18039: FOR_IN
18040: IFFALSE 18071
// if GetLives ( i ) < 1000 then
18042: LD_VAR 0 1
18046: PPUSH
18047: CALL_OW 256
18051: PUSH
18052: LD_INT 1000
18054: LESS
18055: IFFALSE 18069
// SetLives ( i , 1000 ) ;
18057: LD_VAR 0 1
18061: PPUSH
18062: LD_INT 1000
18064: PPUSH
18065: CALL_OW 234
18069: GO 18039
18071: POP
18072: POP
// until p > 20 ;
18073: LD_VAR 0 3
18077: PUSH
18078: LD_INT 20
18080: GREATER
18081: IFFALSE 18008
// end ;
18083: PPOPN 3
18085: END
// every 0 0$1 trigger StreamModeActive and sTime do
18086: LD_EXP 34
18090: PUSH
18091: LD_EXP 85
18095: AND
18096: IFFALSE 18131
18098: GO 18100
18100: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
18101: LD_INT 28
18103: PPUSH
18104: LD_OWVAR 2
18108: PPUSH
18109: LD_INT 2
18111: PPUSH
18112: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
18116: LD_INT 30
18118: PPUSH
18119: LD_OWVAR 2
18123: PPUSH
18124: LD_INT 2
18126: PPUSH
18127: CALL_OW 322
// end ;
18131: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
18132: LD_EXP 34
18136: PUSH
18137: LD_EXP 86
18141: AND
18142: IFFALSE 18263
18144: GO 18146
18146: DISABLE
18147: LD_INT 0
18149: PPUSH
18150: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
18151: LD_ADDR_VAR 0 2
18155: PUSH
18156: LD_INT 22
18158: PUSH
18159: LD_OWVAR 2
18163: PUSH
18164: EMPTY
18165: LIST
18166: LIST
18167: PUSH
18168: LD_INT 21
18170: PUSH
18171: LD_INT 1
18173: PUSH
18174: EMPTY
18175: LIST
18176: LIST
18177: PUSH
18178: LD_INT 3
18180: PUSH
18181: LD_INT 23
18183: PUSH
18184: LD_INT 0
18186: PUSH
18187: EMPTY
18188: LIST
18189: LIST
18190: PUSH
18191: EMPTY
18192: LIST
18193: LIST
18194: PUSH
18195: EMPTY
18196: LIST
18197: LIST
18198: LIST
18199: PPUSH
18200: CALL_OW 69
18204: ST_TO_ADDR
// if not tmp then
18205: LD_VAR 0 2
18209: NOT
18210: IFFALSE 18214
// exit ;
18212: GO 18263
// for i in tmp do
18214: LD_ADDR_VAR 0 1
18218: PUSH
18219: LD_VAR 0 2
18223: PUSH
18224: FOR_IN
18225: IFFALSE 18261
// begin if Crawls ( i ) then
18227: LD_VAR 0 1
18231: PPUSH
18232: CALL_OW 318
18236: IFFALSE 18247
// ComWalk ( i ) ;
18238: LD_VAR 0 1
18242: PPUSH
18243: CALL_OW 138
// SetClass ( i , 2 ) ;
18247: LD_VAR 0 1
18251: PPUSH
18252: LD_INT 2
18254: PPUSH
18255: CALL_OW 336
// end ;
18259: GO 18224
18261: POP
18262: POP
// end ;
18263: PPOPN 2
18265: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
18266: LD_EXP 34
18270: PUSH
18271: LD_EXP 87
18275: AND
18276: IFFALSE 18481
18278: GO 18280
18280: DISABLE
18281: LD_INT 0
18283: PPUSH
18284: PPUSH
18285: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
18286: LD_OWVAR 2
18290: PPUSH
18291: LD_INT 9
18293: PPUSH
18294: LD_INT 1
18296: PPUSH
18297: LD_INT 1
18299: PPUSH
18300: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
18304: LD_INT 9
18306: PPUSH
18307: LD_OWVAR 2
18311: PPUSH
18312: CALL_OW 343
// hc_name := Dark Warrior ;
18316: LD_ADDR_OWVAR 26
18320: PUSH
18321: LD_STRING Dark Warrior
18323: ST_TO_ADDR
// hc_gallery :=  ;
18324: LD_ADDR_OWVAR 33
18328: PUSH
18329: LD_STRING 
18331: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 10 ) ;
18332: LD_INT 1
18334: PPUSH
18335: LD_INT 1
18337: PPUSH
18338: LD_INT 10
18340: PPUSH
18341: CALL_OW 380
// un := CreateHuman ;
18345: LD_ADDR_VAR 0 3
18349: PUSH
18350: CALL_OW 44
18354: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
18355: LD_VAR 0 3
18359: PPUSH
18360: LD_INT 1
18362: PPUSH
18363: CALL_OW 51
// p := 0 ;
18367: LD_ADDR_VAR 0 2
18371: PUSH
18372: LD_INT 0
18374: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18375: LD_INT 35
18377: PPUSH
18378: CALL_OW 67
// if GetLives ( un ) < 1000 then
18382: LD_VAR 0 3
18386: PPUSH
18387: CALL_OW 256
18391: PUSH
18392: LD_INT 1000
18394: LESS
18395: IFFALSE 18409
// SetLives ( un , 1000 ) ;
18397: LD_VAR 0 3
18401: PPUSH
18402: LD_INT 1000
18404: PPUSH
18405: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , your_side ] ) , un ) ) ;
18409: LD_VAR 0 3
18413: PPUSH
18414: LD_INT 81
18416: PUSH
18417: LD_OWVAR 2
18421: PUSH
18422: EMPTY
18423: LIST
18424: LIST
18425: PPUSH
18426: CALL_OW 69
18430: PPUSH
18431: LD_VAR 0 3
18435: PPUSH
18436: CALL_OW 74
18440: PPUSH
18441: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
18445: LD_VAR 0 2
18449: PUSH
18450: LD_INT 60
18452: GREATER
18453: PUSH
18454: LD_VAR 0 3
18458: PPUSH
18459: CALL_OW 301
18463: OR
18464: IFFALSE 18375
// if un then
18466: LD_VAR 0 3
18470: IFFALSE 18481
// RemoveUnit ( un ) ;
18472: LD_VAR 0 3
18476: PPUSH
18477: CALL_OW 64
// end ; end_of_file
18481: PPOPN 3
18483: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
18484: LD_INT 0
18486: PPUSH
18487: PPUSH
18488: PPUSH
18489: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
18490: LD_VAR 0 1
18494: PPUSH
18495: CALL_OW 264
18499: PUSH
18500: LD_EXP 33
18504: EQUAL
18505: IFFALSE 18577
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
18507: LD_INT 68
18509: PPUSH
18510: LD_VAR 0 1
18514: PPUSH
18515: CALL_OW 255
18519: PPUSH
18520: CALL_OW 321
18524: PUSH
18525: LD_INT 2
18527: EQUAL
18528: IFFALSE 18540
// eff := 70 else
18530: LD_ADDR_VAR 0 6
18534: PUSH
18535: LD_INT 70
18537: ST_TO_ADDR
18538: GO 18548
// eff := 30 ;
18540: LD_ADDR_VAR 0 6
18544: PUSH
18545: LD_INT 30
18547: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
18548: LD_VAR 0 1
18552: PPUSH
18553: CALL_OW 250
18557: PPUSH
18558: LD_VAR 0 1
18562: PPUSH
18563: CALL_OW 251
18567: PPUSH
18568: LD_VAR 0 6
18572: PPUSH
18573: CALL_OW 495
// end ; end ;
18577: LD_VAR 0 4
18581: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
18582: LD_INT 0
18584: PPUSH
18585: PPUSH
18586: PPUSH
18587: PPUSH
18588: PPUSH
18589: PPUSH
// if cmd = 124 then
18590: LD_VAR 0 1
18594: PUSH
18595: LD_INT 124
18597: EQUAL
18598: IFFALSE 18804
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
18600: LD_ADDR_VAR 0 5
18604: PUSH
18605: LD_INT 2
18607: PUSH
18608: LD_INT 34
18610: PUSH
18611: LD_INT 53
18613: PUSH
18614: EMPTY
18615: LIST
18616: LIST
18617: PUSH
18618: LD_INT 34
18620: PUSH
18621: LD_INT 14
18623: PUSH
18624: EMPTY
18625: LIST
18626: LIST
18627: PUSH
18628: EMPTY
18629: LIST
18630: LIST
18631: LIST
18632: PPUSH
18633: CALL_OW 69
18637: ST_TO_ADDR
// if not tmp then
18638: LD_VAR 0 5
18642: NOT
18643: IFFALSE 18647
// exit ;
18645: GO 18804
// for i in tmp do
18647: LD_ADDR_VAR 0 3
18651: PUSH
18652: LD_VAR 0 5
18656: PUSH
18657: FOR_IN
18658: IFFALSE 18802
// begin taskList := GetTaskList ( i ) ;
18660: LD_ADDR_VAR 0 6
18664: PUSH
18665: LD_VAR 0 3
18669: PPUSH
18670: CALL_OW 437
18674: ST_TO_ADDR
// if not taskList then
18675: LD_VAR 0 6
18679: NOT
18680: IFFALSE 18684
// continue ;
18682: GO 18657
// for j = 1 to taskList do
18684: LD_ADDR_VAR 0 4
18688: PUSH
18689: DOUBLE
18690: LD_INT 1
18692: DEC
18693: ST_TO_ADDR
18694: LD_VAR 0 6
18698: PUSH
18699: FOR_TO
18700: IFFALSE 18798
// if taskList [ j ] [ 1 ] = | then
18702: LD_VAR 0 6
18706: PUSH
18707: LD_VAR 0 4
18711: ARRAY
18712: PUSH
18713: LD_INT 1
18715: ARRAY
18716: PUSH
18717: LD_STRING |
18719: EQUAL
18720: IFFALSE 18796
// begin _taskList := Delete ( taskList , 1 ) ;
18722: LD_ADDR_VAR 0 7
18726: PUSH
18727: LD_VAR 0 6
18731: PPUSH
18732: LD_INT 1
18734: PPUSH
18735: CALL_OW 3
18739: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
18740: LD_VAR 0 3
18744: PPUSH
18745: LD_VAR 0 7
18749: PPUSH
18750: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
18754: LD_VAR 0 3
18758: PPUSH
18759: LD_VAR 0 6
18763: PUSH
18764: LD_VAR 0 4
18768: ARRAY
18769: PUSH
18770: LD_INT 2
18772: ARRAY
18773: PPUSH
18774: LD_VAR 0 6
18778: PUSH
18779: LD_VAR 0 4
18783: ARRAY
18784: PUSH
18785: LD_INT 3
18787: ARRAY
18788: PPUSH
18789: LD_INT 8
18791: PPUSH
18792: CALL 18809 0 4
// end ;
18796: GO 18699
18798: POP
18799: POP
// end ;
18800: GO 18657
18802: POP
18803: POP
// end ; end ;
18804: LD_VAR 0 2
18808: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
18809: LD_INT 0
18811: PPUSH
18812: PPUSH
18813: PPUSH
18814: PPUSH
18815: PPUSH
18816: PPUSH
18817: PPUSH
18818: PPUSH
18819: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
18820: LD_VAR 0 1
18824: NOT
18825: PUSH
18826: LD_VAR 0 2
18830: PPUSH
18831: LD_VAR 0 3
18835: PPUSH
18836: CALL_OW 488
18840: NOT
18841: OR
18842: PUSH
18843: LD_VAR 0 4
18847: NOT
18848: OR
18849: IFFALSE 18853
// exit ;
18851: GO 19193
// list := [ ] ;
18853: LD_ADDR_VAR 0 13
18857: PUSH
18858: EMPTY
18859: ST_TO_ADDR
// if x - r < 0 then
18860: LD_VAR 0 2
18864: PUSH
18865: LD_VAR 0 4
18869: MINUS
18870: PUSH
18871: LD_INT 0
18873: LESS
18874: IFFALSE 18886
// min_x := 0 else
18876: LD_ADDR_VAR 0 7
18880: PUSH
18881: LD_INT 0
18883: ST_TO_ADDR
18884: GO 18902
// min_x := x - r ;
18886: LD_ADDR_VAR 0 7
18890: PUSH
18891: LD_VAR 0 2
18895: PUSH
18896: LD_VAR 0 4
18900: MINUS
18901: ST_TO_ADDR
// if y - r < 0 then
18902: LD_VAR 0 3
18906: PUSH
18907: LD_VAR 0 4
18911: MINUS
18912: PUSH
18913: LD_INT 0
18915: LESS
18916: IFFALSE 18928
// min_y := 0 else
18918: LD_ADDR_VAR 0 8
18922: PUSH
18923: LD_INT 0
18925: ST_TO_ADDR
18926: GO 18944
// min_y := y - r ;
18928: LD_ADDR_VAR 0 8
18932: PUSH
18933: LD_VAR 0 3
18937: PUSH
18938: LD_VAR 0 4
18942: MINUS
18943: ST_TO_ADDR
// max_x := x + r ;
18944: LD_ADDR_VAR 0 9
18948: PUSH
18949: LD_VAR 0 2
18953: PUSH
18954: LD_VAR 0 4
18958: PLUS
18959: ST_TO_ADDR
// max_y := y + r ;
18960: LD_ADDR_VAR 0 10
18964: PUSH
18965: LD_VAR 0 3
18969: PUSH
18970: LD_VAR 0 4
18974: PLUS
18975: ST_TO_ADDR
// for _x = min_x to max_x do
18976: LD_ADDR_VAR 0 11
18980: PUSH
18981: DOUBLE
18982: LD_VAR 0 7
18986: DEC
18987: ST_TO_ADDR
18988: LD_VAR 0 9
18992: PUSH
18993: FOR_TO
18994: IFFALSE 19111
// for _y = min_y to max_y do
18996: LD_ADDR_VAR 0 12
19000: PUSH
19001: DOUBLE
19002: LD_VAR 0 8
19006: DEC
19007: ST_TO_ADDR
19008: LD_VAR 0 10
19012: PUSH
19013: FOR_TO
19014: IFFALSE 19107
// begin if not ValidHex ( _x , _y ) then
19016: LD_VAR 0 11
19020: PPUSH
19021: LD_VAR 0 12
19025: PPUSH
19026: CALL_OW 488
19030: NOT
19031: IFFALSE 19035
// continue ;
19033: GO 19013
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
19035: LD_VAR 0 11
19039: PPUSH
19040: LD_VAR 0 12
19044: PPUSH
19045: CALL_OW 351
19049: PUSH
19050: LD_VAR 0 11
19054: PPUSH
19055: LD_VAR 0 12
19059: PPUSH
19060: CALL_OW 554
19064: AND
19065: IFFALSE 19105
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
19067: LD_ADDR_VAR 0 13
19071: PUSH
19072: LD_VAR 0 13
19076: PPUSH
19077: LD_VAR 0 13
19081: PUSH
19082: LD_INT 1
19084: PLUS
19085: PPUSH
19086: LD_VAR 0 11
19090: PUSH
19091: LD_VAR 0 12
19095: PUSH
19096: EMPTY
19097: LIST
19098: LIST
19099: PPUSH
19100: CALL_OW 2
19104: ST_TO_ADDR
// end ;
19105: GO 19013
19107: POP
19108: POP
19109: GO 18993
19111: POP
19112: POP
// if not list then
19113: LD_VAR 0 13
19117: NOT
19118: IFFALSE 19122
// exit ;
19120: GO 19193
// for i in list do
19122: LD_ADDR_VAR 0 6
19126: PUSH
19127: LD_VAR 0 13
19131: PUSH
19132: FOR_IN
19133: IFFALSE 19191
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
19135: LD_VAR 0 1
19139: PPUSH
19140: LD_STRING M
19142: PUSH
19143: LD_VAR 0 6
19147: PUSH
19148: LD_INT 1
19150: ARRAY
19151: PUSH
19152: LD_VAR 0 6
19156: PUSH
19157: LD_INT 2
19159: ARRAY
19160: PUSH
19161: LD_INT 0
19163: PUSH
19164: LD_INT 0
19166: PUSH
19167: LD_INT 0
19169: PUSH
19170: LD_INT 0
19172: PUSH
19173: EMPTY
19174: LIST
19175: LIST
19176: LIST
19177: LIST
19178: LIST
19179: LIST
19180: LIST
19181: PUSH
19182: EMPTY
19183: LIST
19184: PPUSH
19185: CALL_OW 447
19189: GO 19132
19191: POP
19192: POP
// end ;
19193: LD_VAR 0 5
19197: RET
