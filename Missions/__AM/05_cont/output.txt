// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// Init ;
  15: CALL 79 0 0
// InitRestrictions ;
  19: CALL 207 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 33
// DebugMode ;
  29: CALL 288 0 0
// SpawnApeman ( apemanStartArea , 2 ) ;
  33: LD_INT 12
  35: PPUSH
  36: LD_INT 2
  38: PPUSH
  39: CALL 658 0 2
// SpawnApeman ( apemanArea , [ 10 , 8 , 7 ] [ Difficulty ] ) ;
  43: LD_INT 11
  45: PPUSH
  46: LD_INT 10
  48: PUSH
  49: LD_INT 8
  51: PUSH
  52: LD_INT 7
  54: PUSH
  55: EMPTY
  56: LIST
  57: LIST
  58: LIST
  59: PUSH
  60: LD_OWVAR 67
  64: ARRAY
  65: PPUSH
  66: CALL 658 0 2
// PrepareAmericans ;
  70: CALL 1257 0 0
// Action ;
  74: CALL 2147 0 0
// end ;
  78: END
// export debug ; export mission_prefix , mission_prefix_prev ; export deltaBuilded , denisArrives , Delta , radar_allowed , first_apeman_tamed , apeman_army , radar_researched , radar_builded ; export apeman_counter , arab_spotted , end_mission , apeKillCounter ; function Init ; begin
  79: LD_INT 0
  81: PPUSH
// debug := false ;
  82: LD_ADDR_EXP 1
  86: PUSH
  87: LD_INT 0
  89: ST_TO_ADDR
// mission_prefix := 05_ ;
  90: LD_ADDR_EXP 2
  94: PUSH
  95: LD_STRING 05_
  97: ST_TO_ADDR
// mission_prefix_prev := 05a_ ;
  98: LD_ADDR_EXP 3
 102: PUSH
 103: LD_STRING 05a_
 105: ST_TO_ADDR
// deltaBuilded := false ;
 106: LD_ADDR_EXP 4
 110: PUSH
 111: LD_INT 0
 113: ST_TO_ADDR
// denisArrives := false ;
 114: LD_ADDR_EXP 5
 118: PUSH
 119: LD_INT 0
 121: ST_TO_ADDR
// radar_allowed := false ;
 122: LD_ADDR_EXP 7
 126: PUSH
 127: LD_INT 0
 129: ST_TO_ADDR
// first_apeman_tamed := false ;
 130: LD_ADDR_EXP 8
 134: PUSH
 135: LD_INT 0
 137: ST_TO_ADDR
// arab_spotted := false ;
 138: LD_ADDR_EXP 13
 142: PUSH
 143: LD_INT 0
 145: ST_TO_ADDR
// end_mission := false ;
 146: LD_ADDR_EXP 14
 150: PUSH
 151: LD_INT 0
 153: ST_TO_ADDR
// apeman_army := false ;
 154: LD_ADDR_EXP 9
 158: PUSH
 159: LD_INT 0
 161: ST_TO_ADDR
// radar_researched := false ;
 162: LD_ADDR_EXP 10
 166: PUSH
 167: LD_INT 0
 169: ST_TO_ADDR
// radar_builded := false ;
 170: LD_ADDR_EXP 11
 174: PUSH
 175: LD_INT 0
 177: ST_TO_ADDR
// apeman_counter := 0 ;
 178: LD_ADDR_EXP 12
 182: PUSH
 183: LD_INT 0
 185: ST_TO_ADDR
// Delta := 0 ;
 186: LD_ADDR_EXP 6
 190: PUSH
 191: LD_INT 0
 193: ST_TO_ADDR
// apeKillCounter := 0 ;
 194: LD_ADDR_EXP 15
 198: PUSH
 199: LD_INT 0
 201: ST_TO_ADDR
// end ;
 202: LD_VAR 0 1
 206: RET
// function InitRestrictions ; begin
 207: LD_INT 0
 209: PPUSH
// SetRestrict ( b_lab_half , 1 , state_enabled ) ;
 210: LD_INT 7
 212: PPUSH
 213: LD_INT 1
 215: PPUSH
 216: LD_INT 1
 218: PPUSH
 219: CALL_OW 324
// SetRestrict ( b_lab_full , 1 , state_enabled ) ;
 223: LD_INT 8
 225: PPUSH
 226: LD_INT 1
 228: PPUSH
 229: LD_INT 1
 231: PPUSH
 232: CALL_OW 324
// SetRestrict ( b_lab_weapon , 1 , state_enabled ) ;
 236: LD_INT 10
 238: PPUSH
 239: LD_INT 1
 241: PPUSH
 242: LD_INT 1
 244: PPUSH
 245: CALL_OW 324
// SetTech ( tech_gatling , 1 , LoadVariable ( GatlingInGamma , 1 ) ) ;
 249: LD_INT 69
 251: PPUSH
 252: LD_INT 1
 254: PPUSH
 255: LD_STRING GatlingInGamma
 257: PPUSH
 258: LD_INT 1
 260: PPUSH
 261: CALL_OW 30
 265: PPUSH
 266: CALL_OW 322
// SetTech ( tech_weap1 , 1 , state_enabled ) ;
 270: LD_INT 51
 272: PPUSH
 273: LD_INT 1
 275: PPUSH
 276: LD_INT 1
 278: PPUSH
 279: CALL_OW 322
// end ;
 283: LD_VAR 0 1
 287: RET
// function DebugMode ; begin
 288: LD_INT 0
 290: PPUSH
// FogOff ( 1 ) ;
 291: LD_INT 1
 293: PPUSH
 294: CALL_OW 344
// Difficulty := 2 ;
 298: LD_ADDR_OWVAR 67
 302: PUSH
 303: LD_INT 2
 305: ST_TO_ADDR
// end ;
 306: LD_VAR 0 1
 310: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 0 ] ] ) >= 7 do
 311: LD_INT 22
 313: PUSH
 314: LD_INT 1
 316: PUSH
 317: EMPTY
 318: LIST
 319: LIST
 320: PUSH
 321: LD_INT 23
 323: PUSH
 324: LD_INT 0
 326: PUSH
 327: EMPTY
 328: LIST
 329: LIST
 330: PUSH
 331: EMPTY
 332: LIST
 333: LIST
 334: PPUSH
 335: CALL_OW 69
 339: PUSH
 340: LD_INT 7
 342: GREATEREQUAL
 343: IFFALSE 355
 345: GO 347
 347: DISABLE
// SetAchievement ( ACH_TAME ) ;
 348: LD_STRING ACH_TAME
 350: PPUSH
 351: CALL_OW 543
 355: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_bweapon , us_radar ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) do
 356: LD_INT 22
 358: PUSH
 359: LD_INT 1
 361: PUSH
 362: EMPTY
 363: LIST
 364: LIST
 365: PUSH
 366: LD_INT 35
 368: PUSH
 369: LD_INT 11
 371: PUSH
 372: EMPTY
 373: LIST
 374: LIST
 375: PUSH
 376: EMPTY
 377: LIST
 378: LIST
 379: PPUSH
 380: CALL_OW 69
 384: PUSH
 385: LD_INT 22
 387: PUSH
 388: LD_INT 1
 390: PUSH
 391: EMPTY
 392: LIST
 393: LIST
 394: PUSH
 395: LD_INT 34
 397: PUSH
 398: LD_INT 11
 400: PUSH
 401: EMPTY
 402: LIST
 403: LIST
 404: PUSH
 405: EMPTY
 406: LIST
 407: LIST
 408: PPUSH
 409: CALL_OW 69
 413: AND
 414: IFFALSE 426
 416: GO 418
 418: DISABLE
// SetAchievement ( ACH_RADAR ) ; end_of_file
 419: LD_STRING ACH_RADAR
 421: PPUSH
 422: CALL_OW 543
 426: END
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 427: LD_INT 0
 429: PPUSH
 430: PPUSH
// if exist_mode then
 431: LD_VAR 0 2
 435: IFFALSE 460
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 437: LD_ADDR_VAR 0 4
 441: PUSH
 442: LD_EXP 3
 446: PUSH
 447: LD_VAR 0 1
 451: STR
 452: PPUSH
 453: CALL_OW 34
 457: ST_TO_ADDR
 458: GO 475
// unit := NewCharacter ( ident ) ;
 460: LD_ADDR_VAR 0 4
 464: PUSH
 465: LD_VAR 0 1
 469: PPUSH
 470: CALL_OW 25
 474: ST_TO_ADDR
// result := unit ;
 475: LD_ADDR_VAR 0 3
 479: PUSH
 480: LD_VAR 0 4
 484: ST_TO_ADDR
// end ;
 485: LD_VAR 0 3
 489: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 490: LD_INT 0
 492: PPUSH
// uc_side := side ;
 493: LD_ADDR_OWVAR 20
 497: PUSH
 498: LD_VAR 0 1
 502: ST_TO_ADDR
// uc_nation := nation ;
 503: LD_ADDR_OWVAR 21
 507: PUSH
 508: LD_VAR 0 2
 512: ST_TO_ADDR
// vc_chassis := chassis ;
 513: LD_ADDR_OWVAR 37
 517: PUSH
 518: LD_VAR 0 3
 522: ST_TO_ADDR
// vc_engine := engine ;
 523: LD_ADDR_OWVAR 39
 527: PUSH
 528: LD_VAR 0 4
 532: ST_TO_ADDR
// vc_control := control ;
 533: LD_ADDR_OWVAR 38
 537: PUSH
 538: LD_VAR 0 5
 542: ST_TO_ADDR
// vc_weapon := weapon ;
 543: LD_ADDR_OWVAR 40
 547: PUSH
 548: LD_VAR 0 6
 552: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 553: LD_ADDR_OWVAR 41
 557: PUSH
 558: LD_VAR 0 7
 562: ST_TO_ADDR
// result := CreateVehicle ;
 563: LD_ADDR_VAR 0 8
 567: PUSH
 568: CALL_OW 45
 572: ST_TO_ADDR
// end ;
 573: LD_VAR 0 8
 577: RET
// export function SayX ( units , ident ) ; var i ; begin
 578: LD_INT 0
 580: PPUSH
 581: PPUSH
// result := false ;
 582: LD_ADDR_VAR 0 3
 586: PUSH
 587: LD_INT 0
 589: ST_TO_ADDR
// if not units then
 590: LD_VAR 0 1
 594: NOT
 595: IFFALSE 599
// exit ;
 597: GO 653
// for i in units do
 599: LD_ADDR_VAR 0 4
 603: PUSH
 604: LD_VAR 0 1
 608: PUSH
 609: FOR_IN
 610: IFFALSE 651
// if IsOk ( i ) then
 612: LD_VAR 0 4
 616: PPUSH
 617: CALL_OW 302
 621: IFFALSE 649
// begin Say ( i , ident ) ;
 623: LD_VAR 0 4
 627: PPUSH
 628: LD_VAR 0 2
 632: PPUSH
 633: CALL_OW 88
// result := i ;
 637: LD_ADDR_VAR 0 3
 641: PUSH
 642: LD_VAR 0 4
 646: ST_TO_ADDR
// break ;
 647: GO 651
// end ;
 649: GO 609
 651: POP
 652: POP
// end ;
 653: LD_VAR 0 3
 657: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 658: LD_INT 0
 660: PPUSH
 661: PPUSH
// InitUc ;
 662: CALL_OW 18
// InitHc ;
 666: CALL_OW 19
// uc_side := 0 ;
 670: LD_ADDR_OWVAR 20
 674: PUSH
 675: LD_INT 0
 677: ST_TO_ADDR
// uc_nation := 0 ;
 678: LD_ADDR_OWVAR 21
 682: PUSH
 683: LD_INT 0
 685: ST_TO_ADDR
// for i = 1 to amount do
 686: LD_ADDR_VAR 0 4
 690: PUSH
 691: DOUBLE
 692: LD_INT 1
 694: DEC
 695: ST_TO_ADDR
 696: LD_VAR 0 2
 700: PUSH
 701: FOR_TO
 702: IFFALSE 784
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 704: LD_ADDR_OWVAR 29
 708: PUSH
 709: LD_INT 9
 711: PPUSH
 712: LD_INT 12
 714: PPUSH
 715: CALL_OW 12
 719: PUSH
 720: LD_INT 9
 722: PPUSH
 723: LD_INT 12
 725: PPUSH
 726: CALL_OW 12
 730: PUSH
 731: EMPTY
 732: LIST
 733: LIST
 734: ST_TO_ADDR
// hc_agressivity := rand ( - 5 , 5 ) ;
 735: LD_ADDR_OWVAR 35
 739: PUSH
 740: LD_INT 5
 742: NEG
 743: PPUSH
 744: LD_INT 5
 746: PPUSH
 747: CALL_OW 12
 751: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 752: LD_INT 0
 754: PPUSH
 755: LD_INT 12
 757: PPUSH
 758: LD_INT 1
 760: PPUSH
 761: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 765: CALL_OW 44
 769: PPUSH
 770: LD_VAR 0 1
 774: PPUSH
 775: LD_INT 0
 777: PPUSH
 778: CALL_OW 49
// end ;
 782: GO 701
 784: POP
 785: POP
// InitHc ;
 786: CALL_OW 19
// end ;
 790: LD_VAR 0 3
 794: RET
// export function Attack ( unit , enemy_list ) ; var target , targets_list ; begin
 795: LD_INT 0
 797: PPUSH
 798: PPUSH
 799: PPUSH
// if not unit then
 800: LD_VAR 0 1
 804: NOT
 805: IFFALSE 809
// exit ;
 807: GO 1252
// if IsInUnit ( unit ) then
 809: LD_VAR 0 1
 813: PPUSH
 814: CALL_OW 310
 818: IFFALSE 835
// unit := IsDrivenBy ( unit ) ;
 820: LD_ADDR_VAR 0 1
 824: PUSH
 825: LD_VAR 0 1
 829: PPUSH
 830: CALL_OW 311
 834: ST_TO_ADDR
// targets_list := [ ] ;
 835: LD_ADDR_VAR 0 5
 839: PUSH
 840: EMPTY
 841: ST_TO_ADDR
// target := UnitFilter ( enemy_list , [ [ f_lives , 250 ] , [ f_not , [ f_weapon , us_cargo_bay ] ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
 842: LD_ADDR_VAR 0 4
 846: PUSH
 847: LD_VAR 0 2
 851: PPUSH
 852: LD_INT 24
 854: PUSH
 855: LD_INT 250
 857: PUSH
 858: EMPTY
 859: LIST
 860: LIST
 861: PUSH
 862: LD_INT 3
 864: PUSH
 865: LD_INT 34
 867: PUSH
 868: LD_INT 12
 870: PUSH
 871: EMPTY
 872: LIST
 873: LIST
 874: PUSH
 875: EMPTY
 876: LIST
 877: LIST
 878: PUSH
 879: LD_INT 21
 881: PUSH
 882: LD_INT 2
 884: PUSH
 885: EMPTY
 886: LIST
 887: LIST
 888: PUSH
 889: LD_INT 58
 891: PUSH
 892: EMPTY
 893: LIST
 894: PUSH
 895: EMPTY
 896: LIST
 897: LIST
 898: LIST
 899: LIST
 900: PPUSH
 901: CALL_OW 72
 905: ST_TO_ADDR
// if GetDistUnits ( NearestUnitToUnit ( target , unit ) , unit ) < 11 and not IsInUnit ( unit ) then
 906: LD_VAR 0 4
 910: PPUSH
 911: LD_VAR 0 1
 915: PPUSH
 916: CALL_OW 74
 920: PPUSH
 921: LD_VAR 0 1
 925: PPUSH
 926: CALL_OW 296
 930: PUSH
 931: LD_INT 11
 933: LESS
 934: PUSH
 935: LD_VAR 0 1
 939: PPUSH
 940: CALL_OW 310
 944: NOT
 945: AND
 946: IFFALSE 974
// begin ComEnterUnit ( unit , NearestUnitToUnit ( target , unit ) ) ;
 948: LD_VAR 0 1
 952: PPUSH
 953: LD_VAR 0 4
 957: PPUSH
 958: LD_VAR 0 1
 962: PPUSH
 963: CALL_OW 74
 967: PPUSH
 968: CALL_OW 120
// exit ;
 972: GO 1252
// end ; targets_list := [ UnitFilter ( enemy_list , [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] ] ) , UnitFilter ( enemy_list , [ f_type , unit_vehicle ] ) , UnitFilter ( enemy_list , [ [ f_type , unit_building ] , [ f_not , [ f_empty ] ] ] ) , enemy_list ] ;
 974: LD_ADDR_VAR 0 5
 978: PUSH
 979: LD_VAR 0 2
 983: PPUSH
 984: LD_INT 21
 986: PUSH
 987: LD_INT 1
 989: PUSH
 990: EMPTY
 991: LIST
 992: LIST
 993: PUSH
 994: LD_INT 3
 996: PUSH
 997: LD_INT 54
 999: PUSH
1000: EMPTY
1001: LIST
1002: PUSH
1003: EMPTY
1004: LIST
1005: LIST
1006: PUSH
1007: EMPTY
1008: LIST
1009: LIST
1010: PPUSH
1011: CALL_OW 72
1015: PUSH
1016: LD_VAR 0 2
1020: PPUSH
1021: LD_INT 21
1023: PUSH
1024: LD_INT 2
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: PPUSH
1031: CALL_OW 72
1035: PUSH
1036: LD_VAR 0 2
1040: PPUSH
1041: LD_INT 21
1043: PUSH
1044: LD_INT 3
1046: PUSH
1047: EMPTY
1048: LIST
1049: LIST
1050: PUSH
1051: LD_INT 3
1053: PUSH
1054: LD_INT 58
1056: PUSH
1057: EMPTY
1058: LIST
1059: PUSH
1060: EMPTY
1061: LIST
1062: LIST
1063: PUSH
1064: EMPTY
1065: LIST
1066: LIST
1067: PPUSH
1068: CALL_OW 72
1072: PUSH
1073: LD_VAR 0 2
1077: PUSH
1078: EMPTY
1079: LIST
1080: LIST
1081: LIST
1082: LIST
1083: ST_TO_ADDR
// for target in targets_list do
1084: LD_ADDR_VAR 0 4
1088: PUSH
1089: LD_VAR 0 5
1093: PUSH
1094: FOR_IN
1095: IFFALSE 1250
// begin if target then
1097: LD_VAR 0 4
1101: IFFALSE 1248
// if GetTag ( unit ) = 11 and ( GetType ( NearestUnitToUnit ( target , unit ) ) = unit_building or GetWeapon ( NearestUnitToUnit ( target , unit ) ) = us_cargo_bay ) then
1103: LD_VAR 0 1
1107: PPUSH
1108: CALL_OW 110
1112: PUSH
1113: LD_INT 11
1115: EQUAL
1116: PUSH
1117: LD_VAR 0 4
1121: PPUSH
1122: LD_VAR 0 1
1126: PPUSH
1127: CALL_OW 74
1131: PPUSH
1132: CALL_OW 247
1136: PUSH
1137: LD_INT 3
1139: EQUAL
1140: PUSH
1141: LD_VAR 0 4
1145: PPUSH
1146: LD_VAR 0 1
1150: PPUSH
1151: CALL_OW 74
1155: PPUSH
1156: CALL_OW 264
1160: PUSH
1161: LD_INT 12
1163: EQUAL
1164: OR
1165: AND
1166: IFFALSE 1212
// begin ComPlaceDelayedCharge ( unit , 0 , 0 , NearestUnitToUnit ( target , unit ) ) ;
1168: LD_VAR 0 1
1172: PPUSH
1173: LD_INT 0
1175: PPUSH
1176: LD_INT 0
1178: PPUSH
1179: LD_VAR 0 4
1183: PPUSH
1184: LD_VAR 0 1
1188: PPUSH
1189: CALL_OW 74
1193: PPUSH
1194: CALL_OW 132
// SetTag ( unit , 0 ) ;
1198: LD_VAR 0 1
1202: PPUSH
1203: LD_INT 0
1205: PPUSH
1206: CALL_OW 109
// end else
1210: GO 1248
// if not HasTask ( unit ) then
1212: LD_VAR 0 1
1216: PPUSH
1217: CALL_OW 314
1221: NOT
1222: IFFALSE 1248
// ComAttackUnit ( unit , NearestUnitToUnit ( target , unit ) ) ;
1224: LD_VAR 0 1
1228: PPUSH
1229: LD_VAR 0 4
1233: PPUSH
1234: LD_VAR 0 1
1238: PPUSH
1239: CALL_OW 74
1243: PPUSH
1244: CALL_OW 115
// end ;
1248: GO 1094
1250: POP
1251: POP
// end ; end_of_file
1252: LD_VAR 0 3
1256: RET
// export JMM , Gladstone , Harrison , Denis , Brown , Donaldson , Lisa , Frank , Bobby , Cyrus ; export others ; export function PrepareAmericans ; var i , points , veh , tmp ; begin
1257: LD_INT 0
1259: PPUSH
1260: PPUSH
1261: PPUSH
1262: PPUSH
1263: PPUSH
// uc_nation := 1 ;
1264: LD_ADDR_OWVAR 21
1268: PUSH
1269: LD_INT 1
1271: ST_TO_ADDR
// uc_side := 4 ;
1272: LD_ADDR_OWVAR 20
1276: PUSH
1277: LD_INT 4
1279: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , false ) ;
1280: LD_ADDR_EXP 19
1284: PUSH
1285: LD_STRING Denis
1287: PPUSH
1288: LD_INT 0
1290: PPUSH
1291: CALL 427 0 2
1295: ST_TO_ADDR
// Harrison := PrepareUnit ( Harisson , false ) ;
1296: LD_ADDR_EXP 18
1300: PUSH
1301: LD_STRING Harisson
1303: PPUSH
1304: LD_INT 0
1306: PPUSH
1307: CALL 427 0 2
1311: ST_TO_ADDR
// uc_side := 1 ;
1312: LD_ADDR_OWVAR 20
1316: PUSH
1317: LD_INT 1
1319: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1320: LD_ADDR_EXP 16
1324: PUSH
1325: LD_STRING JMM
1327: PPUSH
1328: LD_EXP 1
1332: NOT
1333: PPUSH
1334: CALL 427 0 2
1338: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , false ) ;
1339: LD_ADDR_EXP 17
1343: PUSH
1344: LD_STRING Gladstone
1346: PPUSH
1347: LD_INT 0
1349: PPUSH
1350: CALL 427 0 2
1354: ST_TO_ADDR
// if LoadVariable ( BrownInDelta , debug ) then
1355: LD_STRING BrownInDelta
1357: PPUSH
1358: LD_EXP 1
1362: PPUSH
1363: CALL_OW 30
1367: IFFALSE 1404
// begin Brown := PrepareUnit ( Brown , ( not debug ) ) ;
1369: LD_ADDR_EXP 20
1373: PUSH
1374: LD_STRING Brown
1376: PPUSH
1377: LD_EXP 1
1381: NOT
1382: PPUSH
1383: CALL 427 0 2
1387: ST_TO_ADDR
// tmp := tmp ^ Brown ;
1388: LD_ADDR_VAR 0 5
1392: PUSH
1393: LD_VAR 0 5
1397: PUSH
1398: LD_EXP 20
1402: ADD
1403: ST_TO_ADDR
// end ; if LoadVariable ( DonaldsonInDelta , debug ) then
1404: LD_STRING DonaldsonInDelta
1406: PPUSH
1407: LD_EXP 1
1411: PPUSH
1412: CALL_OW 30
1416: IFFALSE 1453
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
1418: LD_ADDR_EXP 21
1422: PUSH
1423: LD_STRING Donaldson
1425: PPUSH
1426: LD_EXP 1
1430: NOT
1431: PPUSH
1432: CALL 427 0 2
1436: ST_TO_ADDR
// tmp := tmp ^ Donaldson ;
1437: LD_ADDR_VAR 0 5
1441: PUSH
1442: LD_VAR 0 5
1446: PUSH
1447: LD_EXP 21
1451: ADD
1452: ST_TO_ADDR
// end ; if LoadVariable ( LisaInDelta , debug ) then
1453: LD_STRING LisaInDelta
1455: PPUSH
1456: LD_EXP 1
1460: PPUSH
1461: CALL_OW 30
1465: IFFALSE 1502
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1467: LD_ADDR_EXP 22
1471: PUSH
1472: LD_STRING Lisa
1474: PPUSH
1475: LD_EXP 1
1479: NOT
1480: PPUSH
1481: CALL 427 0 2
1485: ST_TO_ADDR
// tmp := tmp ^ Lisa ;
1486: LD_ADDR_VAR 0 5
1490: PUSH
1491: LD_VAR 0 5
1495: PUSH
1496: LD_EXP 22
1500: ADD
1501: ST_TO_ADDR
// end ; if LoadVariable ( FrankInDelta , debug ) then
1502: LD_STRING FrankInDelta
1504: PPUSH
1505: LD_EXP 1
1509: PPUSH
1510: CALL_OW 30
1514: IFFALSE 1551
// begin Frank := PrepareUnit ( Frank , ( not debug ) ) ;
1516: LD_ADDR_EXP 23
1520: PUSH
1521: LD_STRING Frank
1523: PPUSH
1524: LD_EXP 1
1528: NOT
1529: PPUSH
1530: CALL 427 0 2
1534: ST_TO_ADDR
// tmp := tmp ^ Frank ;
1535: LD_ADDR_VAR 0 5
1539: PUSH
1540: LD_VAR 0 5
1544: PUSH
1545: LD_EXP 23
1549: ADD
1550: ST_TO_ADDR
// end ; if LoadVariable ( BobbyInDelta , 0 ) then
1551: LD_STRING BobbyInDelta
1553: PPUSH
1554: LD_INT 0
1556: PPUSH
1557: CALL_OW 30
1561: IFFALSE 1598
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1563: LD_ADDR_EXP 24
1567: PUSH
1568: LD_STRING Bobby
1570: PPUSH
1571: LD_EXP 1
1575: NOT
1576: PPUSH
1577: CALL 427 0 2
1581: ST_TO_ADDR
// tmp := tmp ^ Bobby ;
1582: LD_ADDR_VAR 0 5
1586: PUSH
1587: LD_VAR 0 5
1591: PUSH
1592: LD_EXP 24
1596: ADD
1597: ST_TO_ADDR
// end ; if LoadVariable ( CyrusInDelta , 0 ) then
1598: LD_STRING CyrusInDelta
1600: PPUSH
1601: LD_INT 0
1603: PPUSH
1604: CALL_OW 30
1608: IFFALSE 1645
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1610: LD_ADDR_EXP 25
1614: PUSH
1615: LD_STRING Cyrus
1617: PPUSH
1618: LD_EXP 1
1622: NOT
1623: PPUSH
1624: CALL 427 0 2
1628: ST_TO_ADDR
// tmp := tmp ^ Cyrus ;
1629: LD_ADDR_VAR 0 5
1633: PUSH
1634: LD_VAR 0 5
1638: PUSH
1639: LD_EXP 25
1643: ADD
1644: ST_TO_ADDR
// end ; others := CreateCharacterSet ( othersDelta ) ;
1645: LD_ADDR_EXP 26
1649: PUSH
1650: LD_STRING othersDelta
1652: PPUSH
1653: CALL_OW 31
1657: ST_TO_ADDR
// if not others and debug then
1658: LD_EXP 26
1662: NOT
1663: PUSH
1664: LD_EXP 1
1668: AND
1669: IFFALSE 1734
// begin InitHc ;
1671: CALL_OW 19
// for i = 1 to 2 do
1675: LD_ADDR_VAR 0 2
1679: PUSH
1680: DOUBLE
1681: LD_INT 1
1683: DEC
1684: ST_TO_ADDR
1685: LD_INT 2
1687: PUSH
1688: FOR_TO
1689: IFFALSE 1732
// begin PrepareHuman ( false , i mod 4 + 1 , 3 ) ;
1691: LD_INT 0
1693: PPUSH
1694: LD_VAR 0 2
1698: PUSH
1699: LD_INT 4
1701: MOD
1702: PUSH
1703: LD_INT 1
1705: PLUS
1706: PPUSH
1707: LD_INT 3
1709: PPUSH
1710: CALL_OW 380
// others := others ^ CreateHuman ;
1714: LD_ADDR_EXP 26
1718: PUSH
1719: LD_EXP 26
1723: PUSH
1724: CALL_OW 44
1728: ADD
1729: ST_TO_ADDR
// end ;
1730: GO 1688
1732: POP
1733: POP
// end ; if others then
1734: LD_EXP 26
1738: IFFALSE 1756
// tmp := tmp ^ others ;
1740: LD_ADDR_VAR 0 5
1744: PUSH
1745: LD_VAR 0 5
1749: PUSH
1750: LD_EXP 26
1754: ADD
1755: ST_TO_ADDR
// points := [ [ 28 , 49 ] , [ 33 , 54 ] , [ 38 , 56 ] ] ;
1756: LD_ADDR_VAR 0 3
1760: PUSH
1761: LD_INT 28
1763: PUSH
1764: LD_INT 49
1766: PUSH
1767: EMPTY
1768: LIST
1769: LIST
1770: PUSH
1771: LD_INT 33
1773: PUSH
1774: LD_INT 54
1776: PUSH
1777: EMPTY
1778: LIST
1779: LIST
1780: PUSH
1781: LD_INT 38
1783: PUSH
1784: LD_INT 56
1786: PUSH
1787: EMPTY
1788: LIST
1789: LIST
1790: PUSH
1791: EMPTY
1792: LIST
1793: LIST
1794: LIST
1795: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , us_cargo_bay , 80 ) ;
1796: LD_ADDR_VAR 0 4
1800: PUSH
1801: LD_INT 1
1803: PPUSH
1804: LD_INT 1
1806: PPUSH
1807: LD_INT 2
1809: PPUSH
1810: LD_INT 2
1812: PPUSH
1813: LD_INT 1
1815: PPUSH
1816: LD_INT 12
1818: PPUSH
1819: LD_INT 80
1821: PPUSH
1822: CALL 490 0 7
1826: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1827: LD_VAR 0 4
1831: PPUSH
1832: LD_INT 1
1834: PPUSH
1835: CALL_OW 233
// PlaceUnitXY ( veh , points [ 1 ] [ 1 ] , points [ 1 ] [ 2 ] , false ) ;
1839: LD_VAR 0 4
1843: PPUSH
1844: LD_VAR 0 3
1848: PUSH
1849: LD_INT 1
1851: ARRAY
1852: PUSH
1853: LD_INT 1
1855: ARRAY
1856: PPUSH
1857: LD_VAR 0 3
1861: PUSH
1862: LD_INT 1
1864: ARRAY
1865: PUSH
1866: LD_INT 2
1868: ARRAY
1869: PPUSH
1870: LD_INT 0
1872: PPUSH
1873: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
1877: LD_VAR 0 4
1881: PPUSH
1882: LD_INT 1
1884: PPUSH
1885: LD_INT 100
1887: PPUSH
1888: CALL_OW 290
// PlaceHumanInUnit ( others [ 1 ] , veh ) ;
1892: LD_EXP 26
1896: PUSH
1897: LD_INT 1
1899: ARRAY
1900: PPUSH
1901: LD_VAR 0 4
1905: PPUSH
1906: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_machine_gun , 80 ) ;
1910: LD_ADDR_VAR 0 4
1914: PUSH
1915: LD_INT 1
1917: PPUSH
1918: LD_INT 1
1920: PPUSH
1921: LD_INT 1
1923: PPUSH
1924: LD_INT 2
1926: PPUSH
1927: LD_INT 1
1929: PPUSH
1930: LD_INT 2
1932: PPUSH
1933: LD_INT 80
1935: PPUSH
1936: CALL 490 0 7
1940: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1941: LD_VAR 0 4
1945: PPUSH
1946: LD_INT 1
1948: PPUSH
1949: CALL_OW 233
// PlaceUnitXY ( veh , points [ 2 ] [ 1 ] , points [ 2 ] [ 2 ] , false ) ;
1953: LD_VAR 0 4
1957: PPUSH
1958: LD_VAR 0 3
1962: PUSH
1963: LD_INT 2
1965: ARRAY
1966: PUSH
1967: LD_INT 1
1969: ARRAY
1970: PPUSH
1971: LD_VAR 0 3
1975: PUSH
1976: LD_INT 2
1978: ARRAY
1979: PUSH
1980: LD_INT 2
1982: ARRAY
1983: PPUSH
1984: LD_INT 0
1986: PPUSH
1987: CALL_OW 48
// PlaceHumanInUnit ( Gladstone , veh ) ;
1991: LD_EXP 17
1995: PPUSH
1996: LD_VAR 0 4
2000: PPUSH
2001: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_light_gun , 80 ) ;
2005: LD_ADDR_VAR 0 4
2009: PUSH
2010: LD_INT 1
2012: PPUSH
2013: LD_INT 1
2015: PPUSH
2016: LD_INT 1
2018: PPUSH
2019: LD_INT 2
2021: PPUSH
2022: LD_INT 1
2024: PPUSH
2025: LD_INT 3
2027: PPUSH
2028: LD_INT 80
2030: PPUSH
2031: CALL 490 0 7
2035: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
2036: LD_VAR 0 4
2040: PPUSH
2041: LD_INT 1
2043: PPUSH
2044: CALL_OW 233
// PlaceUnitXY ( veh , points [ 3 ] [ 1 ] , points [ 3 ] [ 2 ] , false ) ;
2048: LD_VAR 0 4
2052: PPUSH
2053: LD_VAR 0 3
2057: PUSH
2058: LD_INT 3
2060: ARRAY
2061: PUSH
2062: LD_INT 1
2064: ARRAY
2065: PPUSH
2066: LD_VAR 0 3
2070: PUSH
2071: LD_INT 3
2073: ARRAY
2074: PUSH
2075: LD_INT 2
2077: ARRAY
2078: PPUSH
2079: LD_INT 0
2081: PPUSH
2082: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
2086: LD_EXP 16
2090: PPUSH
2091: LD_VAR 0 4
2095: PPUSH
2096: CALL_OW 52
// for i in tmp diff others [ 1 ] do
2100: LD_ADDR_VAR 0 2
2104: PUSH
2105: LD_VAR 0 5
2109: PUSH
2110: LD_EXP 26
2114: PUSH
2115: LD_INT 1
2117: ARRAY
2118: DIFF
2119: PUSH
2120: FOR_IN
2121: IFFALSE 2140
// PlaceUnitArea ( i , startArea , false ) ;
2123: LD_VAR 0 2
2127: PPUSH
2128: LD_INT 5
2130: PPUSH
2131: LD_INT 0
2133: PPUSH
2134: CALL_OW 49
2138: GO 2120
2140: POP
2141: POP
// end ; end_of_file
2142: LD_VAR 0 1
2146: RET
// export function Action ; var m ; begin
2147: LD_INT 0
2149: PPUSH
2150: PPUSH
// InGameOn ;
2151: CALL_OW 8
// CenterNowOnXY ( 28 , 51 ) ;
2155: LD_INT 28
2157: PPUSH
2158: LD_INT 51
2160: PPUSH
2161: CALL_OW 86
// Wait ( 3 ) ;
2165: LD_INT 3
2167: PPUSH
2168: CALL_OW 67
// Say ( JMM , D1d-JMM-1a ) ;
2172: LD_EXP 16
2176: PPUSH
2177: LD_STRING D1d-JMM-1a
2179: PPUSH
2180: CALL_OW 88
// SayRadio ( Harrison , D1d-Har-1 ) ;
2184: LD_EXP 18
2188: PPUSH
2189: LD_STRING D1d-Har-1
2191: PPUSH
2192: CALL_OW 94
// InGameOff ;
2196: CALL_OW 9
// SaveForQuickRestart ;
2200: CALL_OW 22
// ChangeMissionObjectives ( M1 ) ;
2204: LD_STRING M1
2206: PPUSH
2207: CALL_OW 337
// Wait ( 0 0$2 ) ;
2211: LD_INT 70
2213: PPUSH
2214: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
2218: LD_EXP 16
2222: PPUSH
2223: LD_STRING D2-JMM-1
2225: PPUSH
2226: CALL_OW 88
// Say ( Gladstone , D2-Glad-1 ) ;
2230: LD_EXP 17
2234: PPUSH
2235: LD_STRING D2-Glad-1
2237: PPUSH
2238: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
2242: LD_EXP 16
2246: PPUSH
2247: LD_STRING D2-JMM-2
2249: PPUSH
2250: CALL_OW 88
// Say ( Gladstone , D2-Glad-2 ) ;
2254: LD_EXP 17
2258: PPUSH
2259: LD_STRING D2-Glad-2
2261: PPUSH
2262: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
2266: LD_EXP 16
2270: PPUSH
2271: LD_STRING D2-JMM-3
2273: PPUSH
2274: CALL_OW 88
// Wait ( rand ( 0 0$30 , 1 1$00 ) ) ;
2278: LD_INT 1050
2280: PPUSH
2281: LD_INT 2100
2283: PPUSH
2284: CALL_OW 12
2288: PPUSH
2289: CALL_OW 67
// SetWeather ( 1 , 570 , 350 ) ;
2293: LD_INT 1
2295: PPUSH
2296: LD_INT 570
2298: PPUSH
2299: LD_INT 350
2301: PPUSH
2302: CALL_OW 550
// Wait ( rand ( 3 3$00 , 5 5$00 ) ) ;
2306: LD_INT 6300
2308: PPUSH
2309: LD_INT 10500
2311: PPUSH
2312: CALL_OW 12
2316: PPUSH
2317: CALL_OW 67
// SetWeather ( 0 , 570 , 350 ) ;
2321: LD_INT 0
2323: PPUSH
2324: LD_INT 570
2326: PPUSH
2327: LD_INT 350
2329: PPUSH
2330: CALL_OW 550
// end ;
2334: LD_VAR 0 1
2338: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) and not deltaBuilded do
2339: LD_INT 22
2341: PUSH
2342: LD_INT 1
2344: PUSH
2345: EMPTY
2346: LIST
2347: LIST
2348: PUSH
2349: LD_INT 3
2351: PUSH
2352: LD_INT 57
2354: PUSH
2355: EMPTY
2356: LIST
2357: PUSH
2358: EMPTY
2359: LIST
2360: LIST
2361: PUSH
2362: LD_INT 30
2364: PUSH
2365: LD_INT 0
2367: PUSH
2368: EMPTY
2369: LIST
2370: LIST
2371: PUSH
2372: EMPTY
2373: LIST
2374: LIST
2375: LIST
2376: PUSH
2377: EMPTY
2378: LIST
2379: PPUSH
2380: CALL_OW 69
2384: PUSH
2385: LD_EXP 4
2389: NOT
2390: AND
2391: IFFALSE 2404
2393: GO 2395
2395: DISABLE
// begin deltaBuilded := true ;
2396: LD_ADDR_EXP 4
2400: PUSH
2401: LD_INT 1
2403: ST_TO_ADDR
// end ;
2404: END
// every 0 0$01 trigger not Delta and deltaBuilded and FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) do
2405: LD_EXP 6
2409: NOT
2410: PUSH
2411: LD_EXP 4
2415: AND
2416: PUSH
2417: LD_INT 22
2419: PUSH
2420: LD_INT 1
2422: PUSH
2423: EMPTY
2424: LIST
2425: LIST
2426: PUSH
2427: LD_INT 3
2429: PUSH
2430: LD_INT 57
2432: PUSH
2433: EMPTY
2434: LIST
2435: PUSH
2436: EMPTY
2437: LIST
2438: LIST
2439: PUSH
2440: LD_INT 30
2442: PUSH
2443: LD_INT 0
2445: PUSH
2446: EMPTY
2447: LIST
2448: LIST
2449: PUSH
2450: EMPTY
2451: LIST
2452: LIST
2453: LIST
2454: PUSH
2455: EMPTY
2456: LIST
2457: PPUSH
2458: CALL_OW 69
2462: AND
2463: IFFALSE 2549
2465: GO 2467
2467: DISABLE
// begin enable ;
2468: ENABLE
// SetRestrict ( b_depot , 1 , state_disabled ) ;
2469: LD_INT 0
2471: PPUSH
2472: LD_INT 1
2474: PPUSH
2475: LD_INT 0
2477: PPUSH
2478: CALL_OW 324
// Delta := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) [ 1 ] ;
2482: LD_ADDR_EXP 6
2486: PUSH
2487: LD_INT 22
2489: PUSH
2490: LD_INT 1
2492: PUSH
2493: EMPTY
2494: LIST
2495: LIST
2496: PUSH
2497: LD_INT 3
2499: PUSH
2500: LD_INT 57
2502: PUSH
2503: EMPTY
2504: LIST
2505: PUSH
2506: EMPTY
2507: LIST
2508: LIST
2509: PUSH
2510: LD_INT 30
2512: PUSH
2513: LD_INT 0
2515: PUSH
2516: EMPTY
2517: LIST
2518: LIST
2519: PUSH
2520: EMPTY
2521: LIST
2522: LIST
2523: LIST
2524: PUSH
2525: EMPTY
2526: LIST
2527: PPUSH
2528: CALL_OW 69
2532: PUSH
2533: LD_INT 1
2535: ARRAY
2536: ST_TO_ADDR
// SetBName ( Delta , Delta ) ;
2537: LD_EXP 6
2541: PPUSH
2542: LD_STRING Delta
2544: PPUSH
2545: CALL_OW 500
// end ;
2549: END
// every 0 0$2 trigger GetTech ( tech_ApeLang , 1 ) = state_researched and IsOk ( Gladstone ) do
2550: LD_INT 1
2552: PPUSH
2553: LD_INT 1
2555: PPUSH
2556: CALL_OW 321
2560: PUSH
2561: LD_INT 2
2563: EQUAL
2564: PUSH
2565: LD_EXP 17
2569: PPUSH
2570: CALL_OW 302
2574: AND
2575: IFFALSE 2636
2577: GO 2579
2579: DISABLE
// begin DialogueOn ;
2580: CALL_OW 6
// Say ( Gladstone , D3-Glad-1 ) ;
2584: LD_EXP 17
2588: PPUSH
2589: LD_STRING D3-Glad-1
2591: PPUSH
2592: CALL_OW 88
// Say ( JMM , D3-JMM-1 ) ;
2596: LD_EXP 16
2600: PPUSH
2601: LD_STRING D3-JMM-1
2603: PPUSH
2604: CALL_OW 88
// Say ( Gladstone , D3-Glad-2 ) ;
2608: LD_EXP 17
2612: PPUSH
2613: LD_STRING D3-Glad-2
2615: PPUSH
2616: CALL_OW 88
// Say ( JMM , D3-JMM-2 ) ;
2620: LD_EXP 16
2624: PPUSH
2625: LD_STRING D3-JMM-2
2627: PPUSH
2628: CALL_OW 88
// DialogueOff ;
2632: CALL_OW 7
// end ;
2636: END
// every 0 0$1 trigger GetTech ( tech_ApePsych , 1 ) = state_researched do var sol ;
2637: LD_INT 2
2639: PPUSH
2640: LD_INT 1
2642: PPUSH
2643: CALL_OW 321
2647: PUSH
2648: LD_INT 2
2650: EQUAL
2651: IFFALSE 2828
2653: GO 2655
2655: DISABLE
2656: LD_INT 0
2658: PPUSH
// begin DialogueOn ;
2659: CALL_OW 6
// if Frank then
2663: LD_EXP 23
2667: IFFALSE 2681
// Say ( Frank , D8a-Frank-1 ) ;
2669: LD_EXP 23
2673: PPUSH
2674: LD_STRING D8a-Frank-1
2676: PPUSH
2677: CALL_OW 88
// sol := SayX ( UnitFilter ( others , [ f_sex , sex_male ] ) , D8a-Sol1-1 ) ;
2681: LD_ADDR_VAR 0 1
2685: PUSH
2686: LD_EXP 26
2690: PPUSH
2691: LD_INT 26
2693: PUSH
2694: LD_INT 1
2696: PUSH
2697: EMPTY
2698: LIST
2699: LIST
2700: PPUSH
2701: CALL_OW 72
2705: PPUSH
2706: LD_STRING D8a-Sol1-1
2708: PPUSH
2709: CALL 578 0 2
2713: ST_TO_ADDR
// if Denis and GetSide ( Denis ) = 1 then
2714: LD_EXP 19
2718: PUSH
2719: LD_EXP 19
2723: PPUSH
2724: CALL_OW 255
2728: PUSH
2729: LD_INT 1
2731: EQUAL
2732: AND
2733: IFFALSE 2747
// Say ( Denis , D8a-Den-1 ) ;
2735: LD_EXP 19
2739: PPUSH
2740: LD_STRING D8a-Den-1
2742: PPUSH
2743: CALL_OW 88
// if sol or Denis or Frank then
2747: LD_VAR 0 1
2751: PUSH
2752: LD_EXP 19
2756: OR
2757: PUSH
2758: LD_EXP 23
2762: OR
2763: IFFALSE 2824
// begin SayX ( UnitFilter ( others , [ [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff sol , D8a-Sci1-1 ) ;
2765: LD_EXP 26
2769: PPUSH
2770: LD_INT 25
2772: PUSH
2773: LD_INT 4
2775: PUSH
2776: EMPTY
2777: LIST
2778: LIST
2779: PUSH
2780: LD_INT 26
2782: PUSH
2783: LD_INT 1
2785: PUSH
2786: EMPTY
2787: LIST
2788: LIST
2789: PUSH
2790: EMPTY
2791: LIST
2792: LIST
2793: PPUSH
2794: CALL_OW 72
2798: PUSH
2799: LD_VAR 0 1
2803: DIFF
2804: PPUSH
2805: LD_STRING D8a-Sci1-1
2807: PPUSH
2808: CALL 578 0 2
// Say ( JMM , D8a-JMM-1 ) ;
2812: LD_EXP 16
2816: PPUSH
2817: LD_STRING D8a-JMM-1
2819: PPUSH
2820: CALL_OW 88
// end ; DialogueOff ;
2824: CALL_OW 7
// end ;
2828: PPOPN 1
2830: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) do
2831: LD_INT 22
2833: PUSH
2834: LD_INT 1
2836: PUSH
2837: EMPTY
2838: LIST
2839: LIST
2840: PUSH
2841: LD_INT 25
2843: PUSH
2844: LD_INT 16
2846: PUSH
2847: EMPTY
2848: LIST
2849: LIST
2850: PUSH
2851: EMPTY
2852: LIST
2853: LIST
2854: PPUSH
2855: CALL_OW 69
2859: IFFALSE 2918
2861: GO 2863
2863: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
2864: LD_STRING M1a
2866: PPUSH
2867: CALL_OW 337
// case Query ( Q2 ) of 1 :
2871: LD_STRING Q2
2873: PPUSH
2874: CALL_OW 97
2878: PUSH
2879: LD_INT 1
2881: DOUBLE
2882: EQUAL
2883: IFTRUE 2887
2885: GO 2898
2887: POP
// end_mission := true ; 2 :
2888: LD_ADDR_EXP 14
2892: PUSH
2893: LD_INT 1
2895: ST_TO_ADDR
2896: GO 2918
2898: LD_INT 2
2900: DOUBLE
2901: EQUAL
2902: IFTRUE 2906
2904: GO 2917
2906: POP
// end_the_mission_allowed := true ; end ;
2907: LD_ADDR_OWVAR 57
2911: PUSH
2912: LD_INT 1
2914: ST_TO_ADDR
2915: GO 2918
2917: POP
// end ;
2918: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) and Delta do
2919: LD_INT 22
2921: PUSH
2922: LD_INT 1
2924: PUSH
2925: EMPTY
2926: LIST
2927: LIST
2928: PUSH
2929: LD_INT 2
2931: PUSH
2932: LD_INT 30
2934: PUSH
2935: LD_INT 6
2937: PUSH
2938: EMPTY
2939: LIST
2940: LIST
2941: PUSH
2942: LD_INT 30
2944: PUSH
2945: LD_INT 7
2947: PUSH
2948: EMPTY
2949: LIST
2950: LIST
2951: PUSH
2952: EMPTY
2953: LIST
2954: LIST
2955: LIST
2956: PUSH
2957: EMPTY
2958: LIST
2959: LIST
2960: PPUSH
2961: CALL_OW 69
2965: PUSH
2966: LD_INT 22
2968: PUSH
2969: LD_INT 1
2971: PUSH
2972: EMPTY
2973: LIST
2974: LIST
2975: PUSH
2976: LD_INT 2
2978: PUSH
2979: LD_INT 30
2981: PUSH
2982: LD_INT 2
2984: PUSH
2985: EMPTY
2986: LIST
2987: LIST
2988: PUSH
2989: LD_INT 30
2991: PUSH
2992: LD_INT 3
2994: PUSH
2995: EMPTY
2996: LIST
2997: LIST
2998: PUSH
2999: EMPTY
3000: LIST
3001: LIST
3002: LIST
3003: PUSH
3004: EMPTY
3005: LIST
3006: LIST
3007: PPUSH
3008: CALL_OW 69
3012: AND
3013: PUSH
3014: LD_EXP 6
3018: AND
3019: IFFALSE 3530
3021: GO 3023
3023: DISABLE
// begin Wait ( rand ( 0 0$30 , 0 0$50 ) ) ;
3024: LD_INT 1050
3026: PPUSH
3027: LD_INT 1750
3029: PPUSH
3030: CALL_OW 12
3034: PPUSH
3035: CALL_OW 67
// PlaceUnitArea ( Denis , [ denisArea1 , denisArea2 , denisArea3 ] [ Difficulty ] , false ) ;
3039: LD_EXP 19
3043: PPUSH
3044: LD_INT 6
3046: PUSH
3047: LD_INT 9
3049: PUSH
3050: LD_INT 10
3052: PUSH
3053: EMPTY
3054: LIST
3055: LIST
3056: LIST
3057: PUSH
3058: LD_OWVAR 67
3062: ARRAY
3063: PPUSH
3064: LD_INT 0
3066: PPUSH
3067: CALL_OW 49
// ComHold ( Denis ) ;
3071: LD_EXP 19
3075: PPUSH
3076: CALL_OW 140
// InGameOn ;
3080: CALL_OW 8
// DialogueOn ;
3084: CALL_OW 6
// if Delta then
3088: LD_EXP 6
3092: IFFALSE 3105
// CenterNowOnUnits ( Delta ) else
3094: LD_EXP 6
3098: PPUSH
3099: CALL_OW 87
3103: GO 3114
// CenterNowOnUnits ( JMM ) ;
3105: LD_EXP 16
3109: PPUSH
3110: CALL_OW 87
// SayRadio ( Denis , DD-Den-1 ) ;
3114: LD_EXP 19
3118: PPUSH
3119: LD_STRING DD-Den-1
3121: PPUSH
3122: CALL_OW 94
// Say ( JMM , DD-JMM-1 ) ;
3126: LD_EXP 16
3130: PPUSH
3131: LD_STRING DD-JMM-1
3133: PPUSH
3134: CALL_OW 88
// SayRadio ( Denis , DD-Den-2 ) ;
3138: LD_EXP 19
3142: PPUSH
3143: LD_STRING DD-Den-2
3145: PPUSH
3146: CALL_OW 94
// Wait ( 3 ) ;
3150: LD_INT 3
3152: PPUSH
3153: CALL_OW 67
// DialogueOff ;
3157: CALL_OW 7
// InGameOff ;
3161: CALL_OW 9
// if Difficulty = 1 then
3165: LD_OWVAR 67
3169: PUSH
3170: LD_INT 1
3172: EQUAL
3173: IFFALSE 3249
// begin PlaceSeeing ( GetX ( Denis ) , GetY ( Denis ) , 1 , - 12 ) ;
3175: LD_EXP 19
3179: PPUSH
3180: CALL_OW 250
3184: PPUSH
3185: LD_EXP 19
3189: PPUSH
3190: CALL_OW 251
3194: PPUSH
3195: LD_INT 1
3197: PPUSH
3198: LD_INT 12
3200: NEG
3201: PPUSH
3202: CALL_OW 330
// CenterNowOnUnits ( Denis ) ;
3206: LD_EXP 19
3210: PPUSH
3211: CALL_OW 87
// wait ( 0 0$5 ) ;
3215: LD_INT 175
3217: PPUSH
3218: CALL_OW 67
// RemoveSeeing ( GetX ( Denis ) , GetY ( Denis ) , 1 ) ;
3222: LD_EXP 19
3226: PPUSH
3227: CALL_OW 250
3231: PPUSH
3232: LD_EXP 19
3236: PPUSH
3237: CALL_OW 251
3241: PPUSH
3242: LD_INT 1
3244: PPUSH
3245: CALL_OW 331
// end ; repeat wait ( 0 0$01 ) ;
3249: LD_INT 35
3251: PPUSH
3252: CALL_OW 67
// until See ( 1 , Denis ) or IsDead ( Denis ) ;
3256: LD_INT 1
3258: PPUSH
3259: LD_EXP 19
3263: PPUSH
3264: CALL_OW 292
3268: PUSH
3269: LD_EXP 19
3273: PPUSH
3274: CALL_OW 301
3278: OR
3279: IFFALSE 3249
// if IsDead ( Denis ) then
3281: LD_EXP 19
3285: PPUSH
3286: CALL_OW 301
3290: IFFALSE 3294
// exit ;
3292: GO 3530
// SetSide ( Denis , 1 ) ;
3294: LD_EXP 19
3298: PPUSH
3299: LD_INT 1
3301: PPUSH
3302: CALL_OW 235
// Say ( Denis , DD-Den-2a ) ;
3306: LD_EXP 19
3310: PPUSH
3311: LD_STRING DD-Den-2a
3313: PPUSH
3314: CALL_OW 88
// repeat wait ( 0 0$01 ) ;
3318: LD_INT 35
3320: PPUSH
3321: CALL_OW 67
// until GetBType ( IsInUnit ( Denis ) ) in [ b_lab , b_lab_half , b_lab_full ] or IsDead ( Denis ) ;
3325: LD_EXP 19
3329: PPUSH
3330: CALL_OW 310
3334: PPUSH
3335: CALL_OW 266
3339: PUSH
3340: LD_INT 6
3342: PUSH
3343: LD_INT 7
3345: PUSH
3346: LD_INT 8
3348: PUSH
3349: EMPTY
3350: LIST
3351: LIST
3352: LIST
3353: IN
3354: PUSH
3355: LD_EXP 19
3359: PPUSH
3360: CALL_OW 301
3364: OR
3365: IFFALSE 3318
// if IsDead ( Denis ) then
3367: LD_EXP 19
3371: PPUSH
3372: CALL_OW 301
3376: IFFALSE 3380
// exit ;
3378: GO 3530
// Say ( Denis , DD-Den-2b ) ;
3380: LD_EXP 19
3384: PPUSH
3385: LD_STRING DD-Den-2b
3387: PPUSH
3388: CALL_OW 88
// ComChangeProfession ( Denis , 4 ) ;
3392: LD_EXP 19
3396: PPUSH
3397: LD_INT 4
3399: PPUSH
3400: CALL_OW 123
// Wait ( 0 0$02 ) ;
3404: LD_INT 70
3406: PPUSH
3407: CALL_OW 67
// DialogueOn ;
3411: CALL_OW 6
// CenterNowOnUnits ( Denis ) ;
3415: LD_EXP 19
3419: PPUSH
3420: CALL_OW 87
// Say ( JMM , D4-JMM-1 ) ;
3424: LD_EXP 16
3428: PPUSH
3429: LD_STRING D4-JMM-1
3431: PPUSH
3432: CALL_OW 88
// Say ( Denis , D4-Den-1 ) ;
3436: LD_EXP 19
3440: PPUSH
3441: LD_STRING D4-Den-1
3443: PPUSH
3444: CALL_OW 88
// Say ( JMM , D4-JMM-2 ) ;
3448: LD_EXP 16
3452: PPUSH
3453: LD_STRING D4-JMM-2
3455: PPUSH
3456: CALL_OW 88
// Say ( Denis , D4-Den-2 ) ;
3460: LD_EXP 19
3464: PPUSH
3465: LD_STRING D4-Den-2
3467: PPUSH
3468: CALL_OW 88
// DialogueOff ;
3472: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
3476: LD_STRING M2
3478: PPUSH
3479: CALL_OW 337
// radar_allowed := true ;
3483: LD_ADDR_EXP 7
3487: PUSH
3488: LD_INT 1
3490: ST_TO_ADDR
// SetTech ( tech_radar , 1 , state_enabled ) ;
3491: LD_INT 6
3493: PPUSH
3494: LD_INT 1
3496: PPUSH
3497: LD_INT 1
3499: PPUSH
3500: CALL_OW 322
// SetRestrict ( b_lab_opto , 1 , state_enabled ) ;
3504: LD_INT 15
3506: PPUSH
3507: LD_INT 1
3509: PPUSH
3510: LD_INT 1
3512: PPUSH
3513: CALL_OW 324
// SetRestrict ( b_ext_radar , 1 , state_enabled ) ;
3517: LD_INT 20
3519: PPUSH
3520: LD_INT 1
3522: PPUSH
3523: LD_INT 1
3525: PPUSH
3526: CALL_OW 324
// end ;
3530: END
// every 0 0$1 trigger arab_spotted do var sol , sol2 ;
3531: LD_EXP 13
3535: IFFALSE 4158
3537: GO 3539
3539: DISABLE
3540: LD_INT 0
3542: PPUSH
3543: PPUSH
// begin sol := SayX ( UnitFilter ( others , [ f_sex , sex_male ] ) , D5-Sol1-1 ) ;
3544: LD_ADDR_VAR 0 1
3548: PUSH
3549: LD_EXP 26
3553: PPUSH
3554: LD_INT 26
3556: PUSH
3557: LD_INT 1
3559: PUSH
3560: EMPTY
3561: LIST
3562: LIST
3563: PPUSH
3564: CALL_OW 72
3568: PPUSH
3569: LD_STRING D5-Sol1-1
3571: PPUSH
3572: CALL 578 0 2
3576: ST_TO_ADDR
// if not sol then
3577: LD_VAR 0 1
3581: NOT
3582: IFFALSE 3586
// exit ;
3584: GO 4158
// repeat wait ( 0 0$01 ) ;
3586: LD_INT 35
3588: PPUSH
3589: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 ;
3593: LD_INT 22
3595: PUSH
3596: LD_INT 2
3598: PUSH
3599: EMPTY
3600: LIST
3601: LIST
3602: PUSH
3603: LD_INT 21
3605: PUSH
3606: LD_INT 1
3608: PUSH
3609: EMPTY
3610: LIST
3611: LIST
3612: PUSH
3613: EMPTY
3614: LIST
3615: LIST
3616: PPUSH
3617: CALL_OW 69
3621: PUSH
3622: LD_INT 0
3624: EQUAL
3625: IFFALSE 3586
// if IsOk ( sol ) then
3627: LD_VAR 0 1
3631: PPUSH
3632: CALL_OW 302
3636: IFFALSE 3656
// begin sol2 := others diff sol ;
3638: LD_ADDR_VAR 0 2
3642: PUSH
3643: LD_EXP 26
3647: PUSH
3648: LD_VAR 0 1
3652: DIFF
3653: ST_TO_ADDR
// end else
3654: GO 3658
// exit ;
3656: GO 4158
// if not Lisa and not sol2 then
3658: LD_EXP 22
3662: NOT
3663: PUSH
3664: LD_VAR 0 2
3668: NOT
3669: AND
3670: IFFALSE 3674
// exit ;
3672: GO 4158
// DialogueOn ;
3674: CALL_OW 6
// if Lisa then
3678: LD_EXP 22
3682: IFFALSE 3698
// Say ( Lisa , D5a-Lisa-1 ) else
3684: LD_EXP 22
3688: PPUSH
3689: LD_STRING D5a-Lisa-1
3691: PPUSH
3692: CALL_OW 88
3696: GO 3773
// if sol2 then
3698: LD_VAR 0 2
3702: IFFALSE 3773
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3704: LD_VAR 0 2
3708: PUSH
3709: LD_INT 1
3711: ARRAY
3712: PPUSH
3713: CALL_OW 258
3717: PUSH
3718: LD_INT 1
3720: DOUBLE
3721: EQUAL
3722: IFTRUE 3726
3724: GO 3745
3726: POP
// Say ( sol2 [ 1 ] , D5-Sol2-1 ) ; sex_female :
3727: LD_VAR 0 2
3731: PUSH
3732: LD_INT 1
3734: ARRAY
3735: PPUSH
3736: LD_STRING D5-Sol2-1
3738: PPUSH
3739: CALL_OW 88
3743: GO 3773
3745: LD_INT 2
3747: DOUBLE
3748: EQUAL
3749: IFTRUE 3753
3751: GO 3772
3753: POP
// Say ( sol2 [ 1 ] , D5-FSol2-1 ) ; end ;
3754: LD_VAR 0 2
3758: PUSH
3759: LD_INT 1
3761: ARRAY
3762: PPUSH
3763: LD_STRING D5-FSol2-1
3765: PPUSH
3766: CALL_OW 88
3770: GO 3773
3772: POP
// Say ( sol , D5-Sol1-2 ) ;
3773: LD_VAR 0 1
3777: PPUSH
3778: LD_STRING D5-Sol1-2
3780: PPUSH
3781: CALL_OW 88
// if Lisa then
3785: LD_EXP 22
3789: IFFALSE 3805
// Say ( Lisa , D5a-Lisa-2 ) else
3791: LD_EXP 22
3795: PPUSH
3796: LD_STRING D5a-Lisa-2
3798: PPUSH
3799: CALL_OW 88
3803: GO 3880
// if sol2 then
3805: LD_VAR 0 2
3809: IFFALSE 3880
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3811: LD_VAR 0 2
3815: PUSH
3816: LD_INT 1
3818: ARRAY
3819: PPUSH
3820: CALL_OW 258
3824: PUSH
3825: LD_INT 1
3827: DOUBLE
3828: EQUAL
3829: IFTRUE 3833
3831: GO 3852
3833: POP
// Say ( sol2 [ 1 ] , D5-Sol2-2 ) ; sex_female :
3834: LD_VAR 0 2
3838: PUSH
3839: LD_INT 1
3841: ARRAY
3842: PPUSH
3843: LD_STRING D5-Sol2-2
3845: PPUSH
3846: CALL_OW 88
3850: GO 3880
3852: LD_INT 2
3854: DOUBLE
3855: EQUAL
3856: IFTRUE 3860
3858: GO 3879
3860: POP
// Say ( sol2 [ 1 ] , D5-FSol2-2 ) ; end ;
3861: LD_VAR 0 2
3865: PUSH
3866: LD_INT 1
3868: ARRAY
3869: PPUSH
3870: LD_STRING D5-FSol2-2
3872: PPUSH
3873: CALL_OW 88
3877: GO 3880
3879: POP
// Say ( sol , D5a-Sol1-3 ) ;
3880: LD_VAR 0 1
3884: PPUSH
3885: LD_STRING D5a-Sol1-3
3887: PPUSH
3888: CALL_OW 88
// if Lisa then
3892: LD_EXP 22
3896: IFFALSE 3910
// Say ( Lisa , D5a-Lisa-3 ) ;
3898: LD_EXP 22
3902: PPUSH
3903: LD_STRING D5a-Lisa-3
3905: PPUSH
3906: CALL_OW 88
// if not sol2 then
3910: LD_VAR 0 2
3914: NOT
3915: IFFALSE 3923
// begin DialogueOff ;
3917: CALL_OW 7
// exit ;
3921: GO 4158
// end ; case GetSex ( sol2 [ 1 ] ) of sex_male :
3923: LD_VAR 0 2
3927: PUSH
3928: LD_INT 1
3930: ARRAY
3931: PPUSH
3932: CALL_OW 258
3936: PUSH
3937: LD_INT 1
3939: DOUBLE
3940: EQUAL
3941: IFTRUE 3945
3943: GO 3964
3945: POP
// Say ( sol2 [ 1 ] , D5-Sol2-3 ) ; sex_female :
3946: LD_VAR 0 2
3950: PUSH
3951: LD_INT 1
3953: ARRAY
3954: PPUSH
3955: LD_STRING D5-Sol2-3
3957: PPUSH
3958: CALL_OW 88
3962: GO 3992
3964: LD_INT 2
3966: DOUBLE
3967: EQUAL
3968: IFTRUE 3972
3970: GO 3991
3972: POP
// Say ( sol2 [ 1 ] , D5-FSol2-3 ) ; end ;
3973: LD_VAR 0 2
3977: PUSH
3978: LD_INT 1
3980: ARRAY
3981: PPUSH
3982: LD_STRING D5-FSol2-3
3984: PPUSH
3985: CALL_OW 88
3989: GO 3992
3991: POP
// Say ( sol , D5-Sol1-4 ) ;
3992: LD_VAR 0 1
3996: PPUSH
3997: LD_STRING D5-Sol1-4
3999: PPUSH
4000: CALL_OW 88
// case GetSex ( sol2 [ 1 ] ) of sex_male :
4004: LD_VAR 0 2
4008: PUSH
4009: LD_INT 1
4011: ARRAY
4012: PPUSH
4013: CALL_OW 258
4017: PUSH
4018: LD_INT 1
4020: DOUBLE
4021: EQUAL
4022: IFTRUE 4026
4024: GO 4045
4026: POP
// Say ( sol2 [ 1 ] , D5-Sol2-4 ) ; sex_female :
4027: LD_VAR 0 2
4031: PUSH
4032: LD_INT 1
4034: ARRAY
4035: PPUSH
4036: LD_STRING D5-Sol2-4
4038: PPUSH
4039: CALL_OW 88
4043: GO 4073
4045: LD_INT 2
4047: DOUBLE
4048: EQUAL
4049: IFTRUE 4053
4051: GO 4072
4053: POP
// Say ( sol2 [ 1 ] , D5-FSol2-4 ) ; end ;
4054: LD_VAR 0 2
4058: PUSH
4059: LD_INT 1
4061: ARRAY
4062: PPUSH
4063: LD_STRING D5-FSol2-4
4065: PPUSH
4066: CALL_OW 88
4070: GO 4073
4072: POP
// Say ( sol , D5-Sol1-5 ) ;
4073: LD_VAR 0 1
4077: PPUSH
4078: LD_STRING D5-Sol1-5
4080: PPUSH
4081: CALL_OW 88
// case GetSex ( sol2 [ 1 ] ) of sex_male :
4085: LD_VAR 0 2
4089: PUSH
4090: LD_INT 1
4092: ARRAY
4093: PPUSH
4094: CALL_OW 258
4098: PUSH
4099: LD_INT 1
4101: DOUBLE
4102: EQUAL
4103: IFTRUE 4107
4105: GO 4126
4107: POP
// Say ( sol2 [ 1 ] , D5-Sol2-5 ) ; sex_female :
4108: LD_VAR 0 2
4112: PUSH
4113: LD_INT 1
4115: ARRAY
4116: PPUSH
4117: LD_STRING D5-Sol2-5
4119: PPUSH
4120: CALL_OW 88
4124: GO 4154
4126: LD_INT 2
4128: DOUBLE
4129: EQUAL
4130: IFTRUE 4134
4132: GO 4153
4134: POP
// Say ( sol2 [ 1 ] , D5-FSol2-5 ) ; end ;
4135: LD_VAR 0 2
4139: PUSH
4140: LD_INT 1
4142: ARRAY
4143: PPUSH
4144: LD_STRING D5-FSol2-5
4146: PPUSH
4147: CALL_OW 88
4151: GO 4154
4153: POP
// DialogueOff ;
4154: CALL_OW 7
// end ;
4158: PPOPN 2
4160: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) >= 5 do
4161: LD_INT 22
4163: PUSH
4164: LD_INT 1
4166: PUSH
4167: EMPTY
4168: LIST
4169: LIST
4170: PUSH
4171: LD_INT 25
4173: PUSH
4174: LD_INT 16
4176: PUSH
4177: EMPTY
4178: LIST
4179: LIST
4180: PUSH
4181: EMPTY
4182: LIST
4183: LIST
4184: PPUSH
4185: CALL_OW 69
4189: PUSH
4190: LD_INT 5
4192: GREATEREQUAL
4193: IFFALSE 4213
4195: GO 4197
4197: DISABLE
// begin ChangeMissionObjectives ( M1b ) ;
4198: LD_STRING M1b
4200: PPUSH
4201: CALL_OW 337
// apeman_army := true ;
4205: LD_ADDR_EXP 9
4209: PUSH
4210: LD_INT 1
4212: ST_TO_ADDR
// end ;
4213: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_factory ] , [ f_constructed ] ] ) do
4214: LD_INT 22
4216: PUSH
4217: LD_INT 1
4219: PUSH
4220: EMPTY
4221: LIST
4222: LIST
4223: PUSH
4224: LD_INT 30
4226: PUSH
4227: LD_INT 3
4229: PUSH
4230: EMPTY
4231: LIST
4232: LIST
4233: PUSH
4234: LD_INT 57
4236: PUSH
4237: EMPTY
4238: LIST
4239: PUSH
4240: EMPTY
4241: LIST
4242: LIST
4243: LIST
4244: PPUSH
4245: CALL_OW 69
4249: IFFALSE 4261
4251: GO 4253
4253: DISABLE
// ChangeMissionObjectives ( M1c ) ;
4254: LD_STRING M1c
4256: PPUSH
4257: CALL_OW 337
4261: END
// every 0 0$1 trigger GetTech ( tech_radar , 1 ) = state_researched do
4262: LD_INT 6
4264: PPUSH
4265: LD_INT 1
4267: PPUSH
4268: CALL_OW 321
4272: PUSH
4273: LD_INT 2
4275: EQUAL
4276: IFFALSE 4296
4278: GO 4280
4280: DISABLE
// begin ChangeMissionObjectives ( M2a ) ;
4281: LD_STRING M2a
4283: PPUSH
4284: CALL_OW 337
// radar_researched := true ;
4288: LD_ADDR_EXP 10
4292: PUSH
4293: LD_INT 1
4295: ST_TO_ADDR
// end ;
4296: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_weapon , us_radar ] , [ f_bweapon , us_radar ] ] ] ) do
4297: LD_INT 22
4299: PUSH
4300: LD_INT 1
4302: PUSH
4303: EMPTY
4304: LIST
4305: LIST
4306: PUSH
4307: LD_INT 2
4309: PUSH
4310: LD_INT 34
4312: PUSH
4313: LD_INT 11
4315: PUSH
4316: EMPTY
4317: LIST
4318: LIST
4319: PUSH
4320: LD_INT 35
4322: PUSH
4323: LD_INT 11
4325: PUSH
4326: EMPTY
4327: LIST
4328: LIST
4329: PUSH
4330: EMPTY
4331: LIST
4332: LIST
4333: LIST
4334: PUSH
4335: EMPTY
4336: LIST
4337: LIST
4338: PPUSH
4339: CALL_OW 69
4343: IFFALSE 4363
4345: GO 4347
4347: DISABLE
// begin ChangeMissionObjectives ( M2b ) ;
4348: LD_STRING M2b
4350: PPUSH
4351: CALL_OW 337
// radar_builded := true ;
4355: LD_ADDR_EXP 11
4359: PUSH
4360: LD_INT 1
4362: ST_TO_ADDR
// end ;
4363: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) = 0 and not first_apeman_tamed do
4364: LD_INT 22
4366: PUSH
4367: LD_INT 0
4369: PUSH
4370: EMPTY
4371: LIST
4372: LIST
4373: PUSH
4374: LD_INT 25
4376: PUSH
4377: LD_INT 12
4379: PUSH
4380: EMPTY
4381: LIST
4382: LIST
4383: PUSH
4384: EMPTY
4385: LIST
4386: LIST
4387: PPUSH
4388: CALL_OW 69
4392: PUSH
4393: LD_INT 0
4395: EQUAL
4396: PUSH
4397: LD_EXP 8
4401: NOT
4402: AND
4403: IFFALSE 4415
4405: GO 4407
4407: DISABLE
// YouLost ( Apeman ) ;
4408: LD_STRING Apeman
4410: PPUSH
4411: CALL_OW 104
4415: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) >= 7 do var i , filter ;
4416: LD_INT 22
4418: PUSH
4419: LD_INT 1
4421: PUSH
4422: EMPTY
4423: LIST
4424: LIST
4425: PUSH
4426: LD_INT 25
4428: PUSH
4429: LD_INT 16
4431: PUSH
4432: EMPTY
4433: LIST
4434: LIST
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: PPUSH
4440: CALL_OW 69
4444: PUSH
4445: LD_INT 7
4447: GREATEREQUAL
4448: IFFALSE 4546
4450: GO 4452
4452: DISABLE
4453: LD_INT 0
4455: PPUSH
4456: PPUSH
// begin filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , 4 ] ] ) ^ JMM ;
4457: LD_ADDR_VAR 0 2
4461: PUSH
4462: LD_INT 22
4464: PUSH
4465: LD_INT 1
4467: PUSH
4468: EMPTY
4469: LIST
4470: LIST
4471: PUSH
4472: LD_INT 21
4474: PUSH
4475: LD_INT 1
4477: PUSH
4478: EMPTY
4479: LIST
4480: LIST
4481: PUSH
4482: LD_INT 25
4484: PUSH
4485: LD_INT 4
4487: PUSH
4488: EMPTY
4489: LIST
4490: LIST
4491: PUSH
4492: EMPTY
4493: LIST
4494: LIST
4495: LIST
4496: PPUSH
4497: CALL_OW 69
4501: PUSH
4502: LD_EXP 16
4506: ADD
4507: ST_TO_ADDR
// if filter then
4508: LD_VAR 0 2
4512: IFFALSE 4546
// for i in filter do
4514: LD_ADDR_VAR 0 1
4518: PUSH
4519: LD_VAR 0 2
4523: PUSH
4524: FOR_IN
4525: IFFALSE 4544
// AddExperience ( i , 4 , 3500 ) ;
4527: LD_VAR 0 1
4531: PPUSH
4532: LD_INT 4
4534: PPUSH
4535: LD_INT 3500
4537: PPUSH
4538: CALL_OW 492
4542: GO 4524
4544: POP
4545: POP
// end ;
4546: PPOPN 2
4548: END
// every 0 0$1 trigger end_mission do var i , tmp , m1 , m2 , m3 ;
4549: LD_EXP 14
4553: IFFALSE 5687
4555: GO 4557
4557: DISABLE
4558: LD_INT 0
4560: PPUSH
4561: PPUSH
4562: PPUSH
4563: PPUSH
4564: PPUSH
// begin if apeKillCounter = 0 then
4565: LD_EXP 15
4569: PUSH
4570: LD_INT 0
4572: EQUAL
4573: IFFALSE 4582
// SetAchievement ( ACH_APEKILLER ) ;
4575: LD_STRING ACH_APEKILLER
4577: PPUSH
4578: CALL_OW 543
// if FilterAllUnits ( [ f_side , 2 ] ) then
4582: LD_INT 22
4584: PUSH
4585: LD_INT 2
4587: PUSH
4588: EMPTY
4589: LIST
4590: LIST
4591: PPUSH
4592: CALL_OW 69
4596: IFFALSE 4634
// for i in FilterAllUnits ( [ f_side , 2 ] ) do
4598: LD_ADDR_VAR 0 1
4602: PUSH
4603: LD_INT 22
4605: PUSH
4606: LD_INT 2
4608: PUSH
4609: EMPTY
4610: LIST
4611: LIST
4612: PPUSH
4613: CALL_OW 69
4617: PUSH
4618: FOR_IN
4619: IFFALSE 4632
// RemoveUnit ( i ) ;
4621: LD_VAR 0 1
4625: PPUSH
4626: CALL_OW 64
4630: GO 4618
4632: POP
4633: POP
// m1 := false ;
4634: LD_ADDR_VAR 0 3
4638: PUSH
4639: LD_INT 0
4641: ST_TO_ADDR
// m2 := false ;
4642: LD_ADDR_VAR 0 4
4646: PUSH
4647: LD_INT 0
4649: ST_TO_ADDR
// m3 := false ;
4650: LD_ADDR_VAR 0 5
4654: PUSH
4655: LD_INT 0
4657: ST_TO_ADDR
// if apeman_army then
4658: LD_EXP 9
4662: IFFALSE 4684
// begin AddMedal ( Tame , 1 ) ;
4664: LD_STRING Tame
4666: PPUSH
4667: LD_INT 1
4669: PPUSH
4670: CALL_OW 101
// m1 := true ;
4674: LD_ADDR_VAR 0 3
4678: PUSH
4679: LD_INT 1
4681: ST_TO_ADDR
// end else
4682: GO 4695
// AddMedal ( Tame , - 1 ) ;
4684: LD_STRING Tame
4686: PPUSH
4687: LD_INT 1
4689: NEG
4690: PPUSH
4691: CALL_OW 101
// if radar_researched then
4695: LD_EXP 10
4699: IFFALSE 4731
// begin SaveVariable ( true , radarResInDelta ) ;
4701: LD_INT 1
4703: PPUSH
4704: LD_STRING radarResInDelta
4706: PPUSH
4707: CALL_OW 39
// AddMedal ( Radar , 1 ) ;
4711: LD_STRING Radar
4713: PPUSH
4714: LD_INT 1
4716: PPUSH
4717: CALL_OW 101
// m2 := true ;
4721: LD_ADDR_VAR 0 4
4725: PUSH
4726: LD_INT 1
4728: ST_TO_ADDR
// end else
4729: GO 4761
// if radar_allowed then
4731: LD_EXP 7
4735: IFFALSE 4750
// AddMedal ( Radar , - 2 ) else
4737: LD_STRING Radar
4739: PPUSH
4740: LD_INT 2
4742: NEG
4743: PPUSH
4744: CALL_OW 101
4748: GO 4761
// AddMedal ( Radar , - 1 ) ;
4750: LD_STRING Radar
4752: PPUSH
4753: LD_INT 1
4755: NEG
4756: PPUSH
4757: CALL_OW 101
// if radar_builded then
4761: LD_EXP 11
4765: IFFALSE 4787
// begin AddMedal ( BuildRadar , 1 ) ;
4767: LD_STRING BuildRadar
4769: PPUSH
4770: LD_INT 1
4772: PPUSH
4773: CALL_OW 101
// m3 := true ;
4777: LD_ADDR_VAR 0 5
4781: PUSH
4782: LD_INT 1
4784: ST_TO_ADDR
// end else
4785: GO 4798
// AddMedal ( BuildRadar , - 1 ) ;
4787: LD_STRING BuildRadar
4789: PPUSH
4790: LD_INT 1
4792: NEG
4793: PPUSH
4794: CALL_OW 101
// if tick <= 7 7$00 then
4798: LD_OWVAR 1
4802: PUSH
4803: LD_INT 14700
4805: LESSEQUAL
4806: IFFALSE 4815
// SetAchievement ( ACH_ASPEED_5 ) ;
4808: LD_STRING ACH_ASPEED_5
4810: PPUSH
4811: CALL_OW 543
// if m1 and m2 and m3 and Difficulty = 3 then
4815: LD_VAR 0 3
4819: PUSH
4820: LD_VAR 0 4
4824: AND
4825: PUSH
4826: LD_VAR 0 5
4830: AND
4831: PUSH
4832: LD_OWVAR 67
4836: PUSH
4837: LD_INT 3
4839: EQUAL
4840: AND
4841: IFFALSE 4853
// SetAchievementEX ( ACH_AMER , 5 ) ;
4843: LD_STRING ACH_AMER
4845: PPUSH
4846: LD_INT 5
4848: PPUSH
4849: CALL_OW 564
// GiveMedals ( MAIN ) ;
4853: LD_STRING MAIN
4855: PPUSH
4856: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
4860: LD_ADDR_VAR 0 2
4864: PUSH
4865: LD_INT 22
4867: PUSH
4868: LD_INT 1
4870: PUSH
4871: EMPTY
4872: LIST
4873: LIST
4874: PUSH
4875: LD_INT 21
4877: PUSH
4878: LD_INT 1
4880: PUSH
4881: EMPTY
4882: LIST
4883: LIST
4884: PUSH
4885: LD_INT 2
4887: PUSH
4888: LD_INT 25
4890: PUSH
4891: LD_INT 1
4893: PUSH
4894: EMPTY
4895: LIST
4896: LIST
4897: PUSH
4898: LD_INT 25
4900: PUSH
4901: LD_INT 2
4903: PUSH
4904: EMPTY
4905: LIST
4906: LIST
4907: PUSH
4908: LD_INT 25
4910: PUSH
4911: LD_INT 3
4913: PUSH
4914: EMPTY
4915: LIST
4916: LIST
4917: PUSH
4918: LD_INT 25
4920: PUSH
4921: LD_INT 4
4923: PUSH
4924: EMPTY
4925: LIST
4926: LIST
4927: PUSH
4928: EMPTY
4929: LIST
4930: LIST
4931: LIST
4932: LIST
4933: LIST
4934: PUSH
4935: EMPTY
4936: LIST
4937: LIST
4938: LIST
4939: PPUSH
4940: CALL_OW 69
4944: ST_TO_ADDR
// RewardPeople ( tmp ) ;
4945: LD_VAR 0 2
4949: PPUSH
4950: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
4954: LD_EXP 16
4958: PPUSH
4959: LD_EXP 2
4963: PUSH
4964: LD_STRING JMM
4966: STR
4967: PPUSH
4968: CALL_OW 38
// if IsOk ( Gladstone ) then
4972: LD_EXP 17
4976: PPUSH
4977: CALL_OW 302
4981: IFFALSE 5001
// begin SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
4983: LD_EXP 17
4987: PPUSH
4988: LD_EXP 2
4992: PUSH
4993: LD_STRING Gladstone
4995: STR
4996: PPUSH
4997: CALL_OW 38
// end ; if IsOk ( Denis ) and GetSide ( Denis ) = 1 then
5001: LD_EXP 19
5005: PPUSH
5006: CALL_OW 302
5010: PUSH
5011: LD_EXP 19
5015: PPUSH
5016: CALL_OW 255
5020: PUSH
5021: LD_INT 1
5023: EQUAL
5024: AND
5025: IFFALSE 5055
// begin SaveCharacters ( Denis , mission_prefix & Denis ) ;
5027: LD_EXP 19
5031: PPUSH
5032: LD_EXP 2
5036: PUSH
5037: LD_STRING Denis
5039: STR
5040: PPUSH
5041: CALL_OW 38
// SaveVariable ( true , DenisInDelta ) ;
5045: LD_INT 1
5047: PPUSH
5048: LD_STRING DenisInDelta
5050: PPUSH
5051: CALL_OW 39
// end ; if IsOk ( Lisa ) then
5055: LD_EXP 22
5059: PPUSH
5060: CALL_OW 302
5064: IFFALSE 5084
// begin SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
5066: LD_EXP 22
5070: PPUSH
5071: LD_EXP 2
5075: PUSH
5076: LD_STRING Lisa
5078: STR
5079: PPUSH
5080: CALL_OW 38
// end ; if IsOk ( Frank ) then
5084: LD_EXP 23
5088: PPUSH
5089: CALL_OW 302
5093: IFFALSE 5113
// begin SaveCharacters ( Frank , mission_prefix & Frank ) ;
5095: LD_EXP 23
5099: PPUSH
5100: LD_EXP 2
5104: PUSH
5105: LD_STRING Frank
5107: STR
5108: PPUSH
5109: CALL_OW 38
// end ; if IsOk ( Bobby ) then
5113: LD_EXP 24
5117: PPUSH
5118: CALL_OW 302
5122: IFFALSE 5142
// begin SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
5124: LD_EXP 24
5128: PPUSH
5129: LD_EXP 2
5133: PUSH
5134: LD_STRING Bobby
5136: STR
5137: PPUSH
5138: CALL_OW 38
// end ; if IsOk ( Cyrus ) then
5142: LD_EXP 25
5146: PPUSH
5147: CALL_OW 302
5151: IFFALSE 5171
// begin SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
5153: LD_EXP 25
5157: PPUSH
5158: LD_EXP 2
5162: PUSH
5163: LD_STRING Cyrus
5165: STR
5166: PPUSH
5167: CALL_OW 38
// end ; if IsOk ( Brown ) then
5171: LD_EXP 20
5175: PPUSH
5176: CALL_OW 302
5180: IFFALSE 5200
// begin SaveCharacters ( Brown , mission_prefix & Brown ) ;
5182: LD_EXP 20
5186: PPUSH
5187: LD_EXP 2
5191: PUSH
5192: LD_STRING Brown
5194: STR
5195: PPUSH
5196: CALL_OW 38
// end ; if IsOk ( Donaldson ) then
5200: LD_EXP 21
5204: PPUSH
5205: CALL_OW 302
5209: IFFALSE 5229
// begin SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
5211: LD_EXP 21
5215: PPUSH
5216: LD_EXP 2
5220: PUSH
5221: LD_STRING Donaldson
5223: STR
5224: PPUSH
5225: CALL_OW 38
// end ; if others then
5229: LD_EXP 26
5233: IFFALSE 5247
// SaveCharacters ( others , othersInDelta ) ;
5235: LD_EXP 26
5239: PPUSH
5240: LD_STRING othersInDelta
5242: PPUSH
5243: CALL_OW 38
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) then
5247: LD_INT 22
5249: PUSH
5250: LD_INT 1
5252: PUSH
5253: EMPTY
5254: LIST
5255: LIST
5256: PUSH
5257: LD_INT 25
5259: PUSH
5260: LD_INT 16
5262: PUSH
5263: EMPTY
5264: LIST
5265: LIST
5266: PUSH
5267: EMPTY
5268: LIST
5269: LIST
5270: PPUSH
5271: CALL_OW 69
5275: IFFALSE 5313
// SaveCharacters ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) , apeInDelta ) ;
5277: LD_INT 22
5279: PUSH
5280: LD_INT 1
5282: PUSH
5283: EMPTY
5284: LIST
5285: LIST
5286: PUSH
5287: LD_INT 25
5289: PUSH
5290: LD_INT 16
5292: PUSH
5293: EMPTY
5294: LIST
5295: LIST
5296: PUSH
5297: EMPTY
5298: LIST
5299: LIST
5300: PPUSH
5301: CALL_OW 69
5305: PPUSH
5306: LD_STRING apeInDelta
5308: PPUSH
5309: CALL_OW 38
// tmp := [ ] ;
5313: LD_ADDR_VAR 0 2
5317: PUSH
5318: EMPTY
5319: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) then
5320: LD_INT 22
5322: PUSH
5323: LD_INT 1
5325: PUSH
5326: EMPTY
5327: LIST
5328: LIST
5329: PUSH
5330: LD_INT 21
5332: PUSH
5333: LD_INT 2
5335: PUSH
5336: EMPTY
5337: LIST
5338: LIST
5339: PUSH
5340: EMPTY
5341: LIST
5342: LIST
5343: PPUSH
5344: CALL_OW 69
5348: IFFALSE 5459
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) do
5350: LD_ADDR_VAR 0 1
5354: PUSH
5355: LD_INT 22
5357: PUSH
5358: LD_INT 1
5360: PUSH
5361: EMPTY
5362: LIST
5363: LIST
5364: PUSH
5365: LD_INT 21
5367: PUSH
5368: LD_INT 2
5370: PUSH
5371: EMPTY
5372: LIST
5373: LIST
5374: PUSH
5375: EMPTY
5376: LIST
5377: LIST
5378: PPUSH
5379: CALL_OW 69
5383: PUSH
5384: FOR_IN
5385: IFFALSE 5457
// tmp := tmp ^ [ GetNation ( i ) , GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) ] ;
5387: LD_ADDR_VAR 0 2
5391: PUSH
5392: LD_VAR 0 2
5396: PUSH
5397: LD_VAR 0 1
5401: PPUSH
5402: CALL_OW 248
5406: PUSH
5407: LD_VAR 0 1
5411: PPUSH
5412: CALL_OW 265
5416: PUSH
5417: LD_VAR 0 1
5421: PPUSH
5422: CALL_OW 262
5426: PUSH
5427: LD_VAR 0 1
5431: PPUSH
5432: CALL_OW 263
5436: PUSH
5437: LD_VAR 0 1
5441: PPUSH
5442: CALL_OW 264
5446: PUSH
5447: EMPTY
5448: LIST
5449: LIST
5450: LIST
5451: LIST
5452: LIST
5453: ADD
5454: ST_TO_ADDR
5455: GO 5384
5457: POP
5458: POP
// if tmp then
5459: LD_VAR 0 2
5463: IFFALSE 5477
// SaveVariable ( tmp , vehiclesInDelta ) ;
5465: LD_VAR 0 2
5469: PPUSH
5470: LD_STRING vehiclesInDelta
5472: PPUSH
5473: CALL_OW 39
// tmp := [ ] ;
5477: LD_ADDR_VAR 0 2
5481: PUSH
5482: EMPTY
5483: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) then
5484: LD_INT 22
5486: PUSH
5487: LD_INT 1
5489: PUSH
5490: EMPTY
5491: LIST
5492: LIST
5493: PUSH
5494: LD_INT 21
5496: PUSH
5497: LD_INT 3
5499: PUSH
5500: EMPTY
5501: LIST
5502: LIST
5503: PUSH
5504: EMPTY
5505: LIST
5506: LIST
5507: PPUSH
5508: CALL_OW 69
5512: IFFALSE 5665
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
5514: LD_ADDR_VAR 0 1
5518: PUSH
5519: LD_INT 22
5521: PUSH
5522: LD_INT 1
5524: PUSH
5525: EMPTY
5526: LIST
5527: LIST
5528: PUSH
5529: LD_INT 21
5531: PUSH
5532: LD_INT 3
5534: PUSH
5535: EMPTY
5536: LIST
5537: LIST
5538: PUSH
5539: EMPTY
5540: LIST
5541: LIST
5542: PPUSH
5543: CALL_OW 69
5547: PUSH
5548: FOR_IN
5549: IFFALSE 5663
// tmp := tmp ^ [ [ GetBType ( i ) , GetBLevel ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
5551: LD_ADDR_VAR 0 2
5555: PUSH
5556: LD_VAR 0 2
5560: PUSH
5561: LD_VAR 0 1
5565: PPUSH
5566: CALL_OW 266
5570: PUSH
5571: LD_VAR 0 1
5575: PPUSH
5576: CALL_OW 267
5580: PUSH
5581: LD_VAR 0 1
5585: PPUSH
5586: CALL_OW 250
5590: PUSH
5591: LD_VAR 0 1
5595: PPUSH
5596: CALL_OW 251
5600: PUSH
5601: LD_VAR 0 1
5605: PPUSH
5606: CALL_OW 254
5610: PUSH
5611: LD_VAR 0 1
5615: PPUSH
5616: LD_INT 1
5618: PPUSH
5619: CALL_OW 268
5623: PUSH
5624: LD_VAR 0 1
5628: PPUSH
5629: LD_INT 2
5631: PPUSH
5632: CALL_OW 268
5636: PUSH
5637: LD_VAR 0 1
5641: PPUSH
5642: CALL_OW 269
5646: PUSH
5647: EMPTY
5648: LIST
5649: LIST
5650: LIST
5651: LIST
5652: LIST
5653: LIST
5654: LIST
5655: LIST
5656: PUSH
5657: EMPTY
5658: LIST
5659: ADD
5660: ST_TO_ADDR
5661: GO 5548
5663: POP
5664: POP
// if tmp then
5665: LD_VAR 0 2
5669: IFFALSE 5683
// SaveVariable ( tmp , buildingsInDelta ) ;
5671: LD_VAR 0 2
5675: PPUSH
5676: LD_STRING buildingsInDelta
5678: PPUSH
5679: CALL_OW 39
// YouWin ;
5683: CALL_OW 103
// end ; end_of_file
5687: PPOPN 5
5689: END
// export function PrepareArabianTroops ( amount , skill , area ) ; var i , un , tmp ; begin
5690: LD_INT 0
5692: PPUSH
5693: PPUSH
5694: PPUSH
5695: PPUSH
// InitHc ;
5696: CALL_OW 19
// InitUc ;
5700: CALL_OW 18
// uc_side := 2 ;
5704: LD_ADDR_OWVAR 20
5708: PUSH
5709: LD_INT 2
5711: ST_TO_ADDR
// uc_nation := 2 ;
5712: LD_ADDR_OWVAR 21
5716: PUSH
5717: LD_INT 2
5719: ST_TO_ADDR
// if not amount then
5720: LD_VAR 0 1
5724: NOT
5725: IFFALSE 5729
// exit ;
5727: GO 5852
// for i = 1 to amount do
5729: LD_ADDR_VAR 0 5
5733: PUSH
5734: DOUBLE
5735: LD_INT 1
5737: DEC
5738: ST_TO_ADDR
5739: LD_VAR 0 1
5743: PUSH
5744: FOR_TO
5745: IFFALSE 5840
// begin PrepareHuman ( false , 1 , skill ) ;
5747: LD_INT 0
5749: PPUSH
5750: LD_INT 1
5752: PPUSH
5753: LD_VAR 0 2
5757: PPUSH
5758: CALL_OW 380
// un := CreateHuman ;
5762: LD_ADDR_VAR 0 6
5766: PUSH
5767: CALL_OW 44
5771: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
5772: LD_ADDR_VAR 0 7
5776: PUSH
5777: LD_VAR 0 7
5781: PPUSH
5782: LD_INT 1
5784: PPUSH
5785: LD_VAR 0 6
5789: PPUSH
5790: CALL_OW 2
5794: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5795: LD_VAR 0 6
5799: PPUSH
5800: LD_VAR 0 3
5804: PPUSH
5805: LD_INT 0
5807: PPUSH
5808: CALL_OW 49
// if i mod 2 = 0 then
5812: LD_VAR 0 5
5816: PUSH
5817: LD_INT 2
5819: MOD
5820: PUSH
5821: LD_INT 0
5823: EQUAL
5824: IFFALSE 5838
// SetTag ( un , 11 ) ;
5826: LD_VAR 0 6
5830: PPUSH
5831: LD_INT 11
5833: PPUSH
5834: CALL_OW 109
// end ;
5838: GO 5744
5840: POP
5841: POP
// result := tmp ;
5842: LD_ADDR_VAR 0 4
5846: PUSH
5847: LD_VAR 0 7
5851: ST_TO_ADDR
// end ;
5852: LD_VAR 0 4
5856: RET
// export ar_forces , ap_killers ; every 0 0$1 trigger Delta do var i , timer , more_troops , skill , eng , un , veh , force ;
5857: LD_EXP 6
5861: IFFALSE 6728
5863: GO 5865
5865: DISABLE
5866: LD_INT 0
5868: PPUSH
5869: PPUSH
5870: PPUSH
5871: PPUSH
5872: PPUSH
5873: PPUSH
5874: PPUSH
5875: PPUSH
// begin more_troops := false ;
5876: LD_ADDR_VAR 0 3
5880: PUSH
5881: LD_INT 0
5883: ST_TO_ADDR
// skill := [ 3 , 4 , 5 ] [ Difficulty ] ;
5884: LD_ADDR_VAR 0 4
5888: PUSH
5889: LD_INT 3
5891: PUSH
5892: LD_INT 4
5894: PUSH
5895: LD_INT 5
5897: PUSH
5898: EMPTY
5899: LIST
5900: LIST
5901: LIST
5902: PUSH
5903: LD_OWVAR 67
5907: ARRAY
5908: ST_TO_ADDR
// timer := [ 5 5$00 , 4 4$00 , 3 3$00 ] [ Difficulty ] ;
5909: LD_ADDR_VAR 0 2
5913: PUSH
5914: LD_INT 10500
5916: PUSH
5917: LD_INT 8400
5919: PUSH
5920: LD_INT 6300
5922: PUSH
5923: EMPTY
5924: LIST
5925: LIST
5926: LIST
5927: PUSH
5928: LD_OWVAR 67
5932: ARRAY
5933: ST_TO_ADDR
// force := [ ] ;
5934: LD_ADDR_VAR 0 8
5938: PUSH
5939: EMPTY
5940: ST_TO_ADDR
// ar_forces := [ ] ;
5941: LD_ADDR_EXP 27
5945: PUSH
5946: EMPTY
5947: ST_TO_ADDR
// ap_killers := [ ] ;
5948: LD_ADDR_EXP 28
5952: PUSH
5953: EMPTY
5954: ST_TO_ADDR
// Wait ( timer ) ;
5955: LD_VAR 0 2
5959: PPUSH
5960: CALL_OW 67
// if Denis and GetSide ( Denis ) = 4 then
5964: LD_EXP 19
5968: PUSH
5969: LD_EXP 19
5973: PPUSH
5974: CALL_OW 255
5978: PUSH
5979: LD_INT 4
5981: EQUAL
5982: AND
5983: IFFALSE 5992
// Wait ( 0 0$45 ) ;
5985: LD_INT 1575
5987: PPUSH
5988: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) then
5992: LD_INT 22
5994: PUSH
5995: LD_INT 1
5997: PUSH
5998: EMPTY
5999: LIST
6000: LIST
6001: PUSH
6002: LD_INT 30
6004: PUSH
6005: LD_INT 4
6007: PUSH
6008: EMPTY
6009: LIST
6010: LIST
6011: PUSH
6012: EMPTY
6013: LIST
6014: LIST
6015: PPUSH
6016: CALL_OW 69
6020: IFFALSE 6037
// begin Wait ( 1 1$25 ) ;
6022: LD_INT 2975
6024: PPUSH
6025: CALL_OW 67
// more_troops := true ;
6029: LD_ADDR_VAR 0 3
6033: PUSH
6034: LD_INT 1
6036: ST_TO_ADDR
// end ; if more_troops then
6037: LD_VAR 0 3
6041: IFFALSE 6229
// begin force := PrepareArabianTroops ( [ 4 , 5 , 6 ] [ Difficulty ] , skill , arArea2 ) ;
6043: LD_ADDR_VAR 0 8
6047: PUSH
6048: LD_INT 4
6050: PUSH
6051: LD_INT 5
6053: PUSH
6054: LD_INT 6
6056: PUSH
6057: EMPTY
6058: LIST
6059: LIST
6060: LIST
6061: PUSH
6062: LD_OWVAR 67
6066: ARRAY
6067: PPUSH
6068: LD_VAR 0 4
6072: PPUSH
6073: LD_INT 14
6075: PPUSH
6076: CALL 5690 0 3
6080: ST_TO_ADDR
// veh := PrepareTank ( 2 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_heavy_machine_gun , ru_gatling_gun ] [ Difficulty ] , 90 ) ;
6081: LD_ADDR_VAR 0 7
6085: PUSH
6086: LD_INT 2
6088: PPUSH
6089: LD_INT 3
6091: PPUSH
6092: LD_INT 22
6094: PPUSH
6095: LD_INT 1
6097: PPUSH
6098: LD_INT 1
6100: PPUSH
6101: LD_INT 42
6103: PUSH
6104: LD_INT 42
6106: PUSH
6107: LD_INT 43
6109: PUSH
6110: EMPTY
6111: LIST
6112: LIST
6113: LIST
6114: PUSH
6115: LD_OWVAR 67
6119: ARRAY
6120: PPUSH
6121: LD_INT 90
6123: PPUSH
6124: CALL 490 0 7
6128: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
6129: LD_VAR 0 7
6133: PPUSH
6134: LD_INT 4
6136: PPUSH
6137: CALL_OW 233
// PlaceUnitArea ( veh , arArea1 , false ) ;
6141: LD_VAR 0 7
6145: PPUSH
6146: LD_INT 13
6148: PPUSH
6149: LD_INT 0
6151: PPUSH
6152: CALL_OW 49
// uc_side := 2 ;
6156: LD_ADDR_OWVAR 20
6160: PUSH
6161: LD_INT 2
6163: ST_TO_ADDR
// uc_nation := 2 ;
6164: LD_ADDR_OWVAR 21
6168: PUSH
6169: LD_INT 2
6171: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
6172: LD_INT 0
6174: PPUSH
6175: LD_INT 1
6177: PPUSH
6178: LD_VAR 0 4
6182: PPUSH
6183: CALL_OW 380
// un := CreateHuman ;
6187: LD_ADDR_VAR 0 6
6191: PUSH
6192: CALL_OW 44
6196: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
6197: LD_VAR 0 6
6201: PPUSH
6202: LD_VAR 0 7
6206: PPUSH
6207: CALL_OW 52
// force := force ^ un ;
6211: LD_ADDR_VAR 0 8
6215: PUSH
6216: LD_VAR 0 8
6220: PUSH
6221: LD_VAR 0 6
6225: ADD
6226: ST_TO_ADDR
// end else
6227: GO 6267
// begin force := PrepareArabianTroops ( [ 3 , 4 , 5 ] [ Difficulty ] , skill , arArea2 ) ;
6229: LD_ADDR_VAR 0 8
6233: PUSH
6234: LD_INT 3
6236: PUSH
6237: LD_INT 4
6239: PUSH
6240: LD_INT 5
6242: PUSH
6243: EMPTY
6244: LIST
6245: LIST
6246: LIST
6247: PUSH
6248: LD_OWVAR 67
6252: ARRAY
6253: PPUSH
6254: LD_VAR 0 4
6258: PPUSH
6259: LD_INT 14
6261: PPUSH
6262: CALL 5690 0 3
6266: ST_TO_ADDR
// end ; if force then
6267: LD_VAR 0 8
6271: IFFALSE 6283
// ar_forces := force ;
6273: LD_ADDR_EXP 27
6277: PUSH
6278: LD_VAR 0 8
6282: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
6283: LD_INT 35
6285: PPUSH
6286: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 ;
6290: LD_INT 22
6292: PUSH
6293: LD_INT 2
6295: PUSH
6296: EMPTY
6297: LIST
6298: LIST
6299: PUSH
6300: LD_INT 21
6302: PUSH
6303: LD_INT 1
6305: PUSH
6306: EMPTY
6307: LIST
6308: LIST
6309: PUSH
6310: EMPTY
6311: LIST
6312: LIST
6313: PPUSH
6314: CALL_OW 69
6318: PUSH
6319: LD_INT 0
6321: EQUAL
6322: IFFALSE 6283
// Wait ( timer ) ;
6324: LD_VAR 0 2
6328: PPUSH
6329: CALL_OW 67
// force := PrepareArabianTroops ( [ 4 , 5 , 6 ] [ Difficulty ] , skill , [ arArea1 , arArea2 ] [ rand ( 1 , 2 ) ] ) ;
6333: LD_ADDR_VAR 0 8
6337: PUSH
6338: LD_INT 4
6340: PUSH
6341: LD_INT 5
6343: PUSH
6344: LD_INT 6
6346: PUSH
6347: EMPTY
6348: LIST
6349: LIST
6350: LIST
6351: PUSH
6352: LD_OWVAR 67
6356: ARRAY
6357: PPUSH
6358: LD_VAR 0 4
6362: PPUSH
6363: LD_INT 13
6365: PUSH
6366: LD_INT 14
6368: PUSH
6369: EMPTY
6370: LIST
6371: LIST
6372: PUSH
6373: LD_INT 1
6375: PPUSH
6376: LD_INT 2
6378: PPUSH
6379: CALL_OW 12
6383: ARRAY
6384: PPUSH
6385: CALL 5690 0 3
6389: ST_TO_ADDR
// if Difficulty > 1 and Delta then
6390: LD_OWVAR 67
6394: PUSH
6395: LD_INT 1
6397: GREATER
6398: PUSH
6399: LD_EXP 6
6403: AND
6404: IFFALSE 6483
// begin uc_side := 2 ;
6406: LD_ADDR_OWVAR 20
6410: PUSH
6411: LD_INT 2
6413: ST_TO_ADDR
// uc_nation := 2 ;
6414: LD_ADDR_OWVAR 21
6418: PUSH
6419: LD_INT 2
6421: ST_TO_ADDR
// PrepareHuman ( false , 2 , skill ) ;
6422: LD_INT 0
6424: PPUSH
6425: LD_INT 2
6427: PPUSH
6428: LD_VAR 0 4
6432: PPUSH
6433: CALL_OW 380
// eng := CreateHuman ;
6437: LD_ADDR_VAR 0 5
6441: PUSH
6442: CALL_OW 44
6446: ST_TO_ADDR
// PlaceUnitArea ( eng , arArea1 , false ) ;
6447: LD_VAR 0 5
6451: PPUSH
6452: LD_INT 13
6454: PPUSH
6455: LD_INT 0
6457: PPUSH
6458: CALL_OW 49
// Wait ( 3 ) ;
6462: LD_INT 3
6464: PPUSH
6465: CALL_OW 67
// AddComEnterUnit ( eng , Delta ) ;
6469: LD_VAR 0 5
6473: PPUSH
6474: LD_EXP 6
6478: PPUSH
6479: CALL_OW 180
// end ; if force then
6483: LD_VAR 0 8
6487: IFFALSE 6499
// ar_forces := force ;
6489: LD_ADDR_EXP 27
6493: PUSH
6494: LD_VAR 0 8
6498: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
6499: LD_INT 35
6501: PPUSH
6502: CALL_OW 67
// if eng then
6506: LD_VAR 0 5
6510: IFFALSE 6564
// if GetSide ( Delta ) = 2 and IsOk ( eng ) and not IsInUnit ( eng ) then
6512: LD_EXP 6
6516: PPUSH
6517: CALL_OW 255
6521: PUSH
6522: LD_INT 2
6524: EQUAL
6525: PUSH
6526: LD_VAR 0 5
6530: PPUSH
6531: CALL_OW 302
6535: AND
6536: PUSH
6537: LD_VAR 0 5
6541: PPUSH
6542: CALL_OW 310
6546: NOT
6547: AND
6548: IFFALSE 6564
// ComEnterUnit ( eng , Delta ) ;
6550: LD_VAR 0 5
6554: PPUSH
6555: LD_EXP 6
6559: PPUSH
6560: CALL_OW 120
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 ;
6564: LD_INT 22
6566: PUSH
6567: LD_INT 2
6569: PUSH
6570: EMPTY
6571: LIST
6572: LIST
6573: PUSH
6574: LD_INT 21
6576: PUSH
6577: LD_INT 1
6579: PUSH
6580: EMPTY
6581: LIST
6582: LIST
6583: PUSH
6584: EMPTY
6585: LIST
6586: LIST
6587: PPUSH
6588: CALL_OW 69
6592: PUSH
6593: LD_INT 0
6595: EQUAL
6596: IFFALSE 6499
// Wait ( 2 2$00 ) ;
6598: LD_INT 4200
6600: PPUSH
6601: CALL_OW 67
// ap_killers := PrepareArabianTroops ( [ 1 , 2 , 2 ] [ Difficulty ] , skill , arArea1 ) ;
6605: LD_ADDR_EXP 28
6609: PUSH
6610: LD_INT 1
6612: PUSH
6613: LD_INT 2
6615: PUSH
6616: LD_INT 2
6618: PUSH
6619: EMPTY
6620: LIST
6621: LIST
6622: LIST
6623: PUSH
6624: LD_OWVAR 67
6628: ARRAY
6629: PPUSH
6630: LD_VAR 0 4
6634: PPUSH
6635: LD_INT 13
6637: PPUSH
6638: CALL 5690 0 3
6642: ST_TO_ADDR
// Wait ( timer * 2 ) ;
6643: LD_VAR 0 2
6647: PUSH
6648: LD_INT 2
6650: MUL
6651: PPUSH
6652: CALL_OW 67
// ar_forces := PrepareArabianTroops ( [ 5 , 6 , 7 ] [ Difficulty ] , skill , arArea1 ) ^ PrepareArabianTroops ( [ 3 , 4 , 4 ] [ Difficulty ] , skill , arArea2 ) ;
6656: LD_ADDR_EXP 27
6660: PUSH
6661: LD_INT 5
6663: PUSH
6664: LD_INT 6
6666: PUSH
6667: LD_INT 7
6669: PUSH
6670: EMPTY
6671: LIST
6672: LIST
6673: LIST
6674: PUSH
6675: LD_OWVAR 67
6679: ARRAY
6680: PPUSH
6681: LD_VAR 0 4
6685: PPUSH
6686: LD_INT 13
6688: PPUSH
6689: CALL 5690 0 3
6693: PUSH
6694: LD_INT 3
6696: PUSH
6697: LD_INT 4
6699: PUSH
6700: LD_INT 4
6702: PUSH
6703: EMPTY
6704: LIST
6705: LIST
6706: LIST
6707: PUSH
6708: LD_OWVAR 67
6712: ARRAY
6713: PPUSH
6714: LD_VAR 0 4
6718: PPUSH
6719: LD_INT 14
6721: PPUSH
6722: CALL 5690 0 3
6726: ADD
6727: ST_TO_ADDR
// end ;
6728: PPOPN 8
6730: END
// every 0 0$03 trigger ar_forces do var i , target ;
6731: LD_EXP 27
6735: IFFALSE 6933
6737: GO 6739
6739: DISABLE
6740: LD_INT 0
6742: PPUSH
6743: PPUSH
// begin enable ;
6744: ENABLE
// if not ar_forces then
6745: LD_EXP 27
6749: NOT
6750: IFFALSE 6754
// exit ;
6752: GO 6933
// if Delta then
6754: LD_EXP 6
6758: IFFALSE 6772
// target := Delta else
6760: LD_ADDR_VAR 0 2
6764: PUSH
6765: LD_EXP 6
6769: ST_TO_ADDR
6770: GO 6782
// target := JMM ;
6772: LD_ADDR_VAR 0 2
6776: PUSH
6777: LD_EXP 16
6781: ST_TO_ADDR
// for i in ar_forces do
6782: LD_ADDR_VAR 0 1
6786: PUSH
6787: LD_EXP 27
6791: PUSH
6792: FOR_IN
6793: IFFALSE 6931
// begin if i in FilterAllUnits ( [ f_driving ] ) then
6795: LD_VAR 0 1
6799: PUSH
6800: LD_INT 55
6802: PUSH
6803: EMPTY
6804: LIST
6805: PPUSH
6806: CALL_OW 69
6810: IN
6811: IFFALSE 6854
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , IsInUnit ( i ) ) ) else
6813: LD_VAR 0 1
6817: PPUSH
6818: LD_INT 22
6820: PUSH
6821: LD_INT 1
6823: PUSH
6824: EMPTY
6825: LIST
6826: LIST
6827: PPUSH
6828: CALL_OW 69
6832: PPUSH
6833: LD_VAR 0 1
6837: PPUSH
6838: CALL_OW 310
6842: PPUSH
6843: CALL_OW 74
6847: PPUSH
6848: CALL_OW 115
6852: GO 6929
// if GetDistUnits ( i , target ) > 30 then
6854: LD_VAR 0 1
6858: PPUSH
6859: LD_VAR 0 2
6863: PPUSH
6864: CALL_OW 296
6868: PUSH
6869: LD_INT 30
6871: GREATER
6872: IFFALSE 6905
// ComAgressiveMove ( i , GetX ( target ) , GetY ( target ) ) else
6874: LD_VAR 0 1
6878: PPUSH
6879: LD_VAR 0 2
6883: PPUSH
6884: CALL_OW 250
6888: PPUSH
6889: LD_VAR 0 2
6893: PPUSH
6894: CALL_OW 251
6898: PPUSH
6899: CALL_OW 114
6903: GO 6929
// Attack ( i , FilterAllUnits ( [ f_enemy , 2 ] ) ) ;
6905: LD_VAR 0 1
6909: PPUSH
6910: LD_INT 81
6912: PUSH
6913: LD_INT 2
6915: PUSH
6916: EMPTY
6917: LIST
6918: LIST
6919: PPUSH
6920: CALL_OW 69
6924: PPUSH
6925: CALL 795 0 2
// end ;
6929: GO 6792
6931: POP
6932: POP
// end ;
6933: PPOPN 2
6935: END
// every 0 0$01 trigger ap_killers do var filter , i , target ;
6936: LD_EXP 28
6940: IFFALSE 7100
6942: GO 6944
6944: DISABLE
6945: LD_INT 0
6947: PPUSH
6948: PPUSH
6949: PPUSH
// begin enable ;
6950: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) ;
6951: LD_ADDR_VAR 0 1
6955: PUSH
6956: LD_INT 22
6958: PUSH
6959: LD_INT 0
6961: PUSH
6962: EMPTY
6963: LIST
6964: LIST
6965: PUSH
6966: LD_INT 25
6968: PUSH
6969: LD_INT 12
6971: PUSH
6972: EMPTY
6973: LIST
6974: LIST
6975: PUSH
6976: EMPTY
6977: LIST
6978: LIST
6979: PPUSH
6980: CALL_OW 69
6984: ST_TO_ADDR
// if not filter then
6985: LD_VAR 0 1
6989: NOT
6990: IFFALSE 7017
// begin ar_forces := ar_forces ^ ap_killers ;
6992: LD_ADDR_EXP 27
6996: PUSH
6997: LD_EXP 27
7001: PUSH
7002: LD_EXP 28
7006: ADD
7007: ST_TO_ADDR
// ap_killers := [ ] ;
7008: LD_ADDR_EXP 28
7012: PUSH
7013: EMPTY
7014: ST_TO_ADDR
// exit ;
7015: GO 7100
// end ; for i in ap_killers do
7017: LD_ADDR_VAR 0 2
7021: PUSH
7022: LD_EXP 28
7026: PUSH
7027: FOR_IN
7028: IFFALSE 7098
// begin if not IsOk ( i ) then
7030: LD_VAR 0 2
7034: PPUSH
7035: CALL_OW 302
7039: NOT
7040: IFFALSE 7044
// continue ;
7042: GO 7027
// if not HasTask ( i ) then
7044: LD_VAR 0 2
7048: PPUSH
7049: CALL_OW 314
7053: NOT
7054: IFFALSE 7076
// target := NearestUnitToUnit ( filter , i ) ;
7056: LD_ADDR_VAR 0 3
7060: PUSH
7061: LD_VAR 0 1
7065: PPUSH
7066: LD_VAR 0 2
7070: PPUSH
7071: CALL_OW 74
7075: ST_TO_ADDR
// if target then
7076: LD_VAR 0 3
7080: IFFALSE 7096
// ComAttackUnit ( i , target ) ;
7082: LD_VAR 0 2
7086: PPUSH
7087: LD_VAR 0 3
7091: PPUSH
7092: CALL_OW 115
// end ;
7096: GO 7027
7098: POP
7099: POP
// end ; end_of_file
7100: PPOPN 3
7102: END
// every 0 0$40 + 0 0$2 trigger Delta do var i , counter , cr ;
7103: LD_EXP 6
7107: IFFALSE 7239
7109: GO 7111
7111: DISABLE
7112: LD_INT 0
7114: PPUSH
7115: PPUSH
7116: PPUSH
// begin counter := [ 300 , 250 , 220 ] [ Difficulty ] ;
7117: LD_ADDR_VAR 0 2
7121: PUSH
7122: LD_INT 300
7124: PUSH
7125: LD_INT 250
7127: PUSH
7128: LD_INT 220
7130: PUSH
7131: EMPTY
7132: LIST
7133: LIST
7134: LIST
7135: PUSH
7136: LD_OWVAR 67
7140: ARRAY
7141: ST_TO_ADDR
// CreateCratesArea ( Rand ( 1 , 3 ) , cratesArea , true ) ;
7142: LD_INT 1
7144: PPUSH
7145: LD_INT 3
7147: PPUSH
7148: CALL_OW 12
7152: PPUSH
7153: LD_INT 7
7155: PPUSH
7156: LD_INT 1
7158: PPUSH
7159: CALL_OW 55
// repeat wait ( rand ( 1 1$30 , 2 2$20 ) ) ;
7163: LD_INT 3150
7165: PPUSH
7166: LD_INT 4900
7168: PPUSH
7169: CALL_OW 12
7173: PPUSH
7174: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
7178: LD_ADDR_VAR 0 3
7182: PUSH
7183: LD_INT 1
7185: PPUSH
7186: LD_INT 5
7188: PPUSH
7189: CALL_OW 12
7193: ST_TO_ADDR
// CreateCratesArea ( cr , cratesArea , true ) ;
7194: LD_VAR 0 3
7198: PPUSH
7199: LD_INT 7
7201: PPUSH
7202: LD_INT 1
7204: PPUSH
7205: CALL_OW 55
// counter := counter - cr * 10 ;
7209: LD_ADDR_VAR 0 2
7213: PUSH
7214: LD_VAR 0 2
7218: PUSH
7219: LD_VAR 0 3
7223: PUSH
7224: LD_INT 10
7226: MUL
7227: MINUS
7228: ST_TO_ADDR
// until counter <= 0 ;
7229: LD_VAR 0 2
7233: PUSH
7234: LD_INT 0
7236: LESSEQUAL
7237: IFFALSE 7163
// end ;
7239: PPOPN 3
7241: END
// every 0 0$03 trigger not Delta do var i ;
7242: LD_EXP 6
7246: NOT
7247: IFFALSE 7317
7249: GO 7251
7251: DISABLE
7252: LD_INT 0
7254: PPUSH
// begin for i = 1 to 4 - Difficulty do
7255: LD_ADDR_VAR 0 1
7259: PUSH
7260: DOUBLE
7261: LD_INT 1
7263: DEC
7264: ST_TO_ADDR
7265: LD_INT 4
7267: PUSH
7268: LD_OWVAR 67
7272: MINUS
7273: PUSH
7274: FOR_TO
7275: IFFALSE 7315
// begin CreateCratesArea ( rand ( 2 , 5 ) , deltaMainArea , true ) ;
7277: LD_INT 2
7279: PPUSH
7280: LD_INT 5
7282: PPUSH
7283: CALL_OW 12
7287: PPUSH
7288: LD_INT 8
7290: PPUSH
7291: LD_INT 1
7293: PPUSH
7294: CALL_OW 55
// Wait ( rand ( 0 0$16 , 0 0$39 ) ) ;
7298: LD_INT 560
7300: PPUSH
7301: LD_INT 1365
7303: PPUSH
7304: CALL_OW 12
7308: PPUSH
7309: CALL_OW 67
// end ;
7313: GO 7274
7315: POP
7316: POP
// end ;
7317: PPOPN 1
7319: END
// every 3 3$00 trigger tick < 15 15$00 do
7320: LD_OWVAR 1
7324: PUSH
7325: LD_INT 31500
7327: LESS
7328: IFFALSE 7388
7330: GO 7332
7332: DISABLE
// begin enable ;
7333: ENABLE
// CreateCratesAnyWhere ( rand ( 1 , 3 ) , true ) ;
7334: LD_INT 1
7336: PPUSH
7337: LD_INT 3
7339: PPUSH
7340: CALL_OW 12
7344: PPUSH
7345: LD_INT 1
7347: PPUSH
7348: CALL_OW 57
// Wait ( rand ( 0 0$38 , 0 0$59 ) ) ;
7352: LD_INT 1330
7354: PPUSH
7355: LD_INT 2065
7357: PPUSH
7358: CALL_OW 12
7362: PPUSH
7363: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 4 ) , riverArea , true ) ;
7367: LD_INT 1
7369: PPUSH
7370: LD_INT 4
7372: PPUSH
7373: CALL_OW 12
7377: PPUSH
7378: LD_INT 15
7380: PPUSH
7381: LD_INT 1
7383: PPUSH
7384: CALL_OW 55
// end ; end_of_file
7388: END
// on UnitDestroyed ( un ) do begin if un = JMM then
7389: LD_VAR 0 1
7393: PUSH
7394: LD_EXP 16
7398: EQUAL
7399: IFFALSE 7408
// YouLost ( JMM ) ;
7401: LD_STRING JMM
7403: PPUSH
7404: CALL_OW 104
// if un = Delta then
7408: LD_VAR 0 1
7412: PUSH
7413: LD_EXP 6
7417: EQUAL
7418: IFFALSE 7441
// begin Delta := 0 ;
7420: LD_ADDR_EXP 6
7424: PUSH
7425: LD_INT 0
7427: ST_TO_ADDR
// SetRestrict ( b_depot , 1 , true ) ;
7428: LD_INT 0
7430: PPUSH
7431: LD_INT 1
7433: PPUSH
7434: LD_INT 1
7436: PPUSH
7437: CALL_OW 324
// end ; if un in ar_forces then
7441: LD_VAR 0 1
7445: PUSH
7446: LD_EXP 27
7450: IN
7451: IFFALSE 7469
// ar_forces := ar_forces diff un ;
7453: LD_ADDR_EXP 27
7457: PUSH
7458: LD_EXP 27
7462: PUSH
7463: LD_VAR 0 1
7467: DIFF
7468: ST_TO_ADDR
// if un in ap_killers then
7469: LD_VAR 0 1
7473: PUSH
7474: LD_EXP 28
7478: IN
7479: IFFALSE 7497
// ap_killers := ap_killers diff un ;
7481: LD_ADDR_EXP 28
7485: PUSH
7486: LD_EXP 28
7490: PUSH
7491: LD_VAR 0 1
7495: DIFF
7496: ST_TO_ADDR
// if un in FilterAllUnits ( [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ) then
7497: LD_VAR 0 1
7501: PUSH
7502: LD_INT 2
7504: PUSH
7505: LD_INT 25
7507: PUSH
7508: LD_INT 12
7510: PUSH
7511: EMPTY
7512: LIST
7513: LIST
7514: PUSH
7515: LD_INT 25
7517: PUSH
7518: LD_INT 16
7520: PUSH
7521: EMPTY
7522: LIST
7523: LIST
7524: PUSH
7525: EMPTY
7526: LIST
7527: LIST
7528: LIST
7529: PPUSH
7530: CALL_OW 69
7534: IN
7535: IFFALSE 7551
// apeKillCounter := apeKillCounter + 1 ;
7537: LD_ADDR_EXP 15
7541: PUSH
7542: LD_EXP 15
7546: PUSH
7547: LD_INT 1
7549: PLUS
7550: ST_TO_ADDR
// end ;
7551: PPOPN 1
7553: END
// on Contact ( s1 , s2 ) do if s1 = 1 and s2 = 2 and not arab_spotted then
7554: LD_VAR 0 1
7558: PUSH
7559: LD_INT 1
7561: EQUAL
7562: PUSH
7563: LD_VAR 0 2
7567: PUSH
7568: LD_INT 2
7570: EQUAL
7571: AND
7572: PUSH
7573: LD_EXP 13
7577: NOT
7578: AND
7579: IFFALSE 7589
// arab_spotted := true ;
7581: LD_ADDR_EXP 13
7585: PUSH
7586: LD_INT 1
7588: ST_TO_ADDR
7589: PPOPN 2
7591: END
// on EndTheMissionRaised ( p ) do begin end_the_mission_allowed := false ;
7592: LD_ADDR_OWVAR 57
7596: PUSH
7597: LD_INT 0
7599: ST_TO_ADDR
// end_mission := true ;
7600: LD_ADDR_EXP 14
7604: PUSH
7605: LD_INT 1
7607: ST_TO_ADDR
// end ;
7608: PPOPN 1
7610: END
// on ApemanTamed ( apeman , sci ) do begin if GetSide ( sci ) = 1 then
7611: LD_VAR 0 2
7615: PPUSH
7616: CALL_OW 255
7620: PUSH
7621: LD_INT 1
7623: EQUAL
7624: IFFALSE 7640
// apeman_counter := apeman_counter + 1 ;
7626: LD_ADDR_EXP 12
7630: PUSH
7631: LD_EXP 12
7635: PUSH
7636: LD_INT 1
7638: PLUS
7639: ST_TO_ADDR
// if not first_apeman_tamed then
7640: LD_EXP 8
7644: NOT
7645: IFFALSE 7845
// begin first_apeman_tamed := true ;
7647: LD_ADDR_EXP 8
7651: PUSH
7652: LD_INT 1
7654: ST_TO_ADDR
// if sci = Gladstone then
7655: LD_VAR 0 2
7659: PUSH
7660: LD_EXP 17
7664: EQUAL
7665: IFFALSE 7679
// Say ( Gladstone , D7b-Glad-1 ) ;
7667: LD_EXP 17
7671: PPUSH
7672: LD_STRING D7b-Glad-1
7674: PPUSH
7675: CALL_OW 88
// if sci = Denis then
7679: LD_VAR 0 2
7683: PUSH
7684: LD_EXP 19
7688: EQUAL
7689: IFFALSE 7703
// Say ( Denis , D7a-Den-1 ) ;
7691: LD_EXP 19
7695: PPUSH
7696: LD_STRING D7a-Den-1
7698: PPUSH
7699: CALL_OW 88
// if not sci in [ JMM , Gladstone , Denis , Lisa , Frank , Bobby , Cyrus , Donaldson ] then
7703: LD_VAR 0 2
7707: PUSH
7708: LD_EXP 16
7712: PUSH
7713: LD_EXP 17
7717: PUSH
7718: LD_EXP 19
7722: PUSH
7723: LD_EXP 22
7727: PUSH
7728: LD_EXP 23
7732: PUSH
7733: LD_EXP 24
7737: PUSH
7738: LD_EXP 25
7742: PUSH
7743: LD_EXP 21
7747: PUSH
7748: EMPTY
7749: LIST
7750: LIST
7751: LIST
7752: LIST
7753: LIST
7754: LIST
7755: LIST
7756: LIST
7757: IN
7758: NOT
7759: IFFALSE 7802
// begin if GetSex ( sci ) = sex_male then
7761: LD_VAR 0 2
7765: PPUSH
7766: CALL_OW 258
7770: PUSH
7771: LD_INT 1
7773: EQUAL
7774: IFFALSE 7790
// Say ( sci , D7c-Sci1-1 ) else
7776: LD_VAR 0 2
7780: PPUSH
7781: LD_STRING D7c-Sci1-1
7783: PPUSH
7784: CALL_OW 88
7788: GO 7802
// Say ( sci , D7c-FSci1-1 ) ;
7790: LD_VAR 0 2
7794: PPUSH
7795: LD_STRING D7c-FSci1-1
7797: PPUSH
7798: CALL_OW 88
// end ; if not sci = Gladstone then
7802: LD_VAR 0 2
7806: PUSH
7807: LD_EXP 17
7811: EQUAL
7812: NOT
7813: IFFALSE 7827
// Say ( Gladstone , D7c-Glad-1 ) ;
7815: LD_EXP 17
7819: PPUSH
7820: LD_STRING D7c-Glad-1
7822: PPUSH
7823: CALL_OW 88
// if Lisa then
7827: LD_EXP 22
7831: IFFALSE 7845
// Say ( Lisa , D8-Lisa-1 ) ;
7833: LD_EXP 22
7837: PPUSH
7838: LD_STRING D8-Lisa-1
7840: PPUSH
7841: CALL_OW 88
// end ; end ; end_of_file
7845: PPOPN 2
7847: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
7848: GO 7850
7850: DISABLE
// begin ru_radar := 98 ;
7851: LD_ADDR_EXP 29
7855: PUSH
7856: LD_INT 98
7858: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
7859: LD_ADDR_EXP 30
7863: PUSH
7864: LD_INT 89
7866: ST_TO_ADDR
// us_hack := 99 ;
7867: LD_ADDR_EXP 31
7871: PUSH
7872: LD_INT 99
7874: ST_TO_ADDR
// us_artillery := 97 ;
7875: LD_ADDR_EXP 32
7879: PUSH
7880: LD_INT 97
7882: ST_TO_ADDR
// ar_bio_bomb := 91 ;
7883: LD_ADDR_EXP 33
7887: PUSH
7888: LD_INT 91
7890: ST_TO_ADDR
// tech_Artillery := 80 ;
7891: LD_ADDR_EXP 34
7895: PUSH
7896: LD_INT 80
7898: ST_TO_ADDR
// tech_RadMat := 81 ;
7899: LD_ADDR_EXP 35
7903: PUSH
7904: LD_INT 81
7906: ST_TO_ADDR
// tech_BasicTools := 82 ;
7907: LD_ADDR_EXP 36
7911: PUSH
7912: LD_INT 82
7914: ST_TO_ADDR
// tech_Cargo := 83 ;
7915: LD_ADDR_EXP 37
7919: PUSH
7920: LD_INT 83
7922: ST_TO_ADDR
// tech_Track := 84 ;
7923: LD_ADDR_EXP 38
7927: PUSH
7928: LD_INT 84
7930: ST_TO_ADDR
// tech_Crane := 85 ;
7931: LD_ADDR_EXP 39
7935: PUSH
7936: LD_INT 85
7938: ST_TO_ADDR
// tech_Bulldozer := 86 ;
7939: LD_ADDR_EXP 40
7943: PUSH
7944: LD_INT 86
7946: ST_TO_ADDR
// tech_Hovercraft := 87 ;
7947: LD_ADDR_EXP 41
7951: PUSH
7952: LD_INT 87
7954: ST_TO_ADDR
// end ; end_of_file end_of_file
7955: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
7956: GO 7958
7958: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
7959: LD_STRING initStreamRollete();
7961: PPUSH
7962: CALL_OW 559
// InitStreamMode ;
7966: CALL 7975 0 0
// DefineStreamItems ( ) ;
7970: CALL 8415 0 0
// end ;
7974: END
// function InitStreamMode ; begin
7975: LD_INT 0
7977: PPUSH
// streamModeActive := false ;
7978: LD_ADDR_EXP 42
7982: PUSH
7983: LD_INT 0
7985: ST_TO_ADDR
// normalCounter := 36 ;
7986: LD_ADDR_EXP 43
7990: PUSH
7991: LD_INT 36
7993: ST_TO_ADDR
// hardcoreCounter := 16 ;
7994: LD_ADDR_EXP 44
7998: PUSH
7999: LD_INT 16
8001: ST_TO_ADDR
// sRocket := false ;
8002: LD_ADDR_EXP 47
8006: PUSH
8007: LD_INT 0
8009: ST_TO_ADDR
// sSpeed := false ;
8010: LD_ADDR_EXP 46
8014: PUSH
8015: LD_INT 0
8017: ST_TO_ADDR
// sEngine := false ;
8018: LD_ADDR_EXP 48
8022: PUSH
8023: LD_INT 0
8025: ST_TO_ADDR
// sSpec := false ;
8026: LD_ADDR_EXP 45
8030: PUSH
8031: LD_INT 0
8033: ST_TO_ADDR
// sLevel := false ;
8034: LD_ADDR_EXP 49
8038: PUSH
8039: LD_INT 0
8041: ST_TO_ADDR
// sArmoury := false ;
8042: LD_ADDR_EXP 50
8046: PUSH
8047: LD_INT 0
8049: ST_TO_ADDR
// sRadar := false ;
8050: LD_ADDR_EXP 51
8054: PUSH
8055: LD_INT 0
8057: ST_TO_ADDR
// sBunker := false ;
8058: LD_ADDR_EXP 52
8062: PUSH
8063: LD_INT 0
8065: ST_TO_ADDR
// sHack := false ;
8066: LD_ADDR_EXP 53
8070: PUSH
8071: LD_INT 0
8073: ST_TO_ADDR
// sFire := false ;
8074: LD_ADDR_EXP 54
8078: PUSH
8079: LD_INT 0
8081: ST_TO_ADDR
// sRefresh := false ;
8082: LD_ADDR_EXP 55
8086: PUSH
8087: LD_INT 0
8089: ST_TO_ADDR
// sExp := false ;
8090: LD_ADDR_EXP 56
8094: PUSH
8095: LD_INT 0
8097: ST_TO_ADDR
// sDepot := false ;
8098: LD_ADDR_EXP 57
8102: PUSH
8103: LD_INT 0
8105: ST_TO_ADDR
// sFlag := false ;
8106: LD_ADDR_EXP 58
8110: PUSH
8111: LD_INT 0
8113: ST_TO_ADDR
// sKamikadze := false ;
8114: LD_ADDR_EXP 66
8118: PUSH
8119: LD_INT 0
8121: ST_TO_ADDR
// sTroll := false ;
8122: LD_ADDR_EXP 67
8126: PUSH
8127: LD_INT 0
8129: ST_TO_ADDR
// sSlow := false ;
8130: LD_ADDR_EXP 68
8134: PUSH
8135: LD_INT 0
8137: ST_TO_ADDR
// sLack := false ;
8138: LD_ADDR_EXP 69
8142: PUSH
8143: LD_INT 0
8145: ST_TO_ADDR
// sTank := false ;
8146: LD_ADDR_EXP 71
8150: PUSH
8151: LD_INT 0
8153: ST_TO_ADDR
// sRemote := false ;
8154: LD_ADDR_EXP 72
8158: PUSH
8159: LD_INT 0
8161: ST_TO_ADDR
// sPowell := false ;
8162: LD_ADDR_EXP 73
8166: PUSH
8167: LD_INT 0
8169: ST_TO_ADDR
// sTeleport := false ;
8170: LD_ADDR_EXP 76
8174: PUSH
8175: LD_INT 0
8177: ST_TO_ADDR
// sOilTower := false ;
8178: LD_ADDR_EXP 78
8182: PUSH
8183: LD_INT 0
8185: ST_TO_ADDR
// sShovel := false ;
8186: LD_ADDR_EXP 79
8190: PUSH
8191: LD_INT 0
8193: ST_TO_ADDR
// sSheik := false ;
8194: LD_ADDR_EXP 80
8198: PUSH
8199: LD_INT 0
8201: ST_TO_ADDR
// sEarthquake := false ;
8202: LD_ADDR_EXP 82
8206: PUSH
8207: LD_INT 0
8209: ST_TO_ADDR
// sAI := false ;
8210: LD_ADDR_EXP 83
8214: PUSH
8215: LD_INT 0
8217: ST_TO_ADDR
// sCargo := false ;
8218: LD_ADDR_EXP 86
8222: PUSH
8223: LD_INT 0
8225: ST_TO_ADDR
// sDLaser := false ;
8226: LD_ADDR_EXP 87
8230: PUSH
8231: LD_INT 0
8233: ST_TO_ADDR
// sExchange := false ;
8234: LD_ADDR_EXP 88
8238: PUSH
8239: LD_INT 0
8241: ST_TO_ADDR
// sFac := false ;
8242: LD_ADDR_EXP 89
8246: PUSH
8247: LD_INT 0
8249: ST_TO_ADDR
// sPower := false ;
8250: LD_ADDR_EXP 90
8254: PUSH
8255: LD_INT 0
8257: ST_TO_ADDR
// sRandom := false ;
8258: LD_ADDR_EXP 91
8262: PUSH
8263: LD_INT 0
8265: ST_TO_ADDR
// sShield := false ;
8266: LD_ADDR_EXP 92
8270: PUSH
8271: LD_INT 0
8273: ST_TO_ADDR
// sTime := false ;
8274: LD_ADDR_EXP 93
8278: PUSH
8279: LD_INT 0
8281: ST_TO_ADDR
// sTools := false ;
8282: LD_ADDR_EXP 94
8286: PUSH
8287: LD_INT 0
8289: ST_TO_ADDR
// sSold := false ;
8290: LD_ADDR_EXP 59
8294: PUSH
8295: LD_INT 0
8297: ST_TO_ADDR
// sDiff := false ;
8298: LD_ADDR_EXP 60
8302: PUSH
8303: LD_INT 0
8305: ST_TO_ADDR
// sFog := false ;
8306: LD_ADDR_EXP 63
8310: PUSH
8311: LD_INT 0
8313: ST_TO_ADDR
// sReset := false ;
8314: LD_ADDR_EXP 64
8318: PUSH
8319: LD_INT 0
8321: ST_TO_ADDR
// sSun := false ;
8322: LD_ADDR_EXP 65
8326: PUSH
8327: LD_INT 0
8329: ST_TO_ADDR
// sTiger := false ;
8330: LD_ADDR_EXP 61
8334: PUSH
8335: LD_INT 0
8337: ST_TO_ADDR
// sBomb := false ;
8338: LD_ADDR_EXP 62
8342: PUSH
8343: LD_INT 0
8345: ST_TO_ADDR
// sWound := false ;
8346: LD_ADDR_EXP 70
8350: PUSH
8351: LD_INT 0
8353: ST_TO_ADDR
// sBetray := false ;
8354: LD_ADDR_EXP 74
8358: PUSH
8359: LD_INT 0
8361: ST_TO_ADDR
// sContamin := false ;
8362: LD_ADDR_EXP 75
8366: PUSH
8367: LD_INT 0
8369: ST_TO_ADDR
// sOil := false ;
8370: LD_ADDR_EXP 77
8374: PUSH
8375: LD_INT 0
8377: ST_TO_ADDR
// sStu := false ;
8378: LD_ADDR_EXP 81
8382: PUSH
8383: LD_INT 0
8385: ST_TO_ADDR
// sBazooka := false ;
8386: LD_ADDR_EXP 84
8390: PUSH
8391: LD_INT 0
8393: ST_TO_ADDR
// sMortar := false ;
8394: LD_ADDR_EXP 85
8398: PUSH
8399: LD_INT 0
8401: ST_TO_ADDR
// sRanger := false ;
8402: LD_ADDR_EXP 95
8406: PUSH
8407: LD_INT 0
8409: ST_TO_ADDR
// end ;
8410: LD_VAR 0 1
8414: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
8415: LD_INT 0
8417: PPUSH
8418: PPUSH
8419: PPUSH
8420: PPUSH
8421: PPUSH
// result := [ ] ;
8422: LD_ADDR_VAR 0 1
8426: PUSH
8427: EMPTY
8428: ST_TO_ADDR
// if campaign_id = 1 then
8429: LD_OWVAR 69
8433: PUSH
8434: LD_INT 1
8436: EQUAL
8437: IFFALSE 11375
// begin case mission_number of 1 :
8439: LD_OWVAR 70
8443: PUSH
8444: LD_INT 1
8446: DOUBLE
8447: EQUAL
8448: IFTRUE 8452
8450: GO 8516
8452: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
8453: LD_ADDR_VAR 0 1
8457: PUSH
8458: LD_INT 2
8460: PUSH
8461: LD_INT 4
8463: PUSH
8464: LD_INT 11
8466: PUSH
8467: LD_INT 12
8469: PUSH
8470: LD_INT 15
8472: PUSH
8473: LD_INT 16
8475: PUSH
8476: LD_INT 22
8478: PUSH
8479: LD_INT 23
8481: PUSH
8482: LD_INT 26
8484: PUSH
8485: EMPTY
8486: LIST
8487: LIST
8488: LIST
8489: LIST
8490: LIST
8491: LIST
8492: LIST
8493: LIST
8494: LIST
8495: PUSH
8496: LD_INT 101
8498: PUSH
8499: LD_INT 102
8501: PUSH
8502: LD_INT 106
8504: PUSH
8505: EMPTY
8506: LIST
8507: LIST
8508: LIST
8509: PUSH
8510: EMPTY
8511: LIST
8512: LIST
8513: ST_TO_ADDR
8514: GO 11373
8516: LD_INT 2
8518: DOUBLE
8519: EQUAL
8520: IFTRUE 8524
8522: GO 8596
8524: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
8525: LD_ADDR_VAR 0 1
8529: PUSH
8530: LD_INT 2
8532: PUSH
8533: LD_INT 4
8535: PUSH
8536: LD_INT 11
8538: PUSH
8539: LD_INT 12
8541: PUSH
8542: LD_INT 15
8544: PUSH
8545: LD_INT 16
8547: PUSH
8548: LD_INT 22
8550: PUSH
8551: LD_INT 23
8553: PUSH
8554: LD_INT 26
8556: PUSH
8557: EMPTY
8558: LIST
8559: LIST
8560: LIST
8561: LIST
8562: LIST
8563: LIST
8564: LIST
8565: LIST
8566: LIST
8567: PUSH
8568: LD_INT 101
8570: PUSH
8571: LD_INT 102
8573: PUSH
8574: LD_INT 105
8576: PUSH
8577: LD_INT 106
8579: PUSH
8580: LD_INT 108
8582: PUSH
8583: EMPTY
8584: LIST
8585: LIST
8586: LIST
8587: LIST
8588: LIST
8589: PUSH
8590: EMPTY
8591: LIST
8592: LIST
8593: ST_TO_ADDR
8594: GO 11373
8596: LD_INT 3
8598: DOUBLE
8599: EQUAL
8600: IFTRUE 8604
8602: GO 8680
8604: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
8605: LD_ADDR_VAR 0 1
8609: PUSH
8610: LD_INT 2
8612: PUSH
8613: LD_INT 4
8615: PUSH
8616: LD_INT 5
8618: PUSH
8619: LD_INT 11
8621: PUSH
8622: LD_INT 12
8624: PUSH
8625: LD_INT 15
8627: PUSH
8628: LD_INT 16
8630: PUSH
8631: LD_INT 22
8633: PUSH
8634: LD_INT 26
8636: PUSH
8637: LD_INT 36
8639: PUSH
8640: EMPTY
8641: LIST
8642: LIST
8643: LIST
8644: LIST
8645: LIST
8646: LIST
8647: LIST
8648: LIST
8649: LIST
8650: LIST
8651: PUSH
8652: LD_INT 101
8654: PUSH
8655: LD_INT 102
8657: PUSH
8658: LD_INT 105
8660: PUSH
8661: LD_INT 106
8663: PUSH
8664: LD_INT 108
8666: PUSH
8667: EMPTY
8668: LIST
8669: LIST
8670: LIST
8671: LIST
8672: LIST
8673: PUSH
8674: EMPTY
8675: LIST
8676: LIST
8677: ST_TO_ADDR
8678: GO 11373
8680: LD_INT 4
8682: DOUBLE
8683: EQUAL
8684: IFTRUE 8688
8686: GO 8772
8688: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
8689: LD_ADDR_VAR 0 1
8693: PUSH
8694: LD_INT 2
8696: PUSH
8697: LD_INT 4
8699: PUSH
8700: LD_INT 5
8702: PUSH
8703: LD_INT 8
8705: PUSH
8706: LD_INT 11
8708: PUSH
8709: LD_INT 12
8711: PUSH
8712: LD_INT 15
8714: PUSH
8715: LD_INT 16
8717: PUSH
8718: LD_INT 22
8720: PUSH
8721: LD_INT 23
8723: PUSH
8724: LD_INT 26
8726: PUSH
8727: LD_INT 36
8729: PUSH
8730: EMPTY
8731: LIST
8732: LIST
8733: LIST
8734: LIST
8735: LIST
8736: LIST
8737: LIST
8738: LIST
8739: LIST
8740: LIST
8741: LIST
8742: LIST
8743: PUSH
8744: LD_INT 101
8746: PUSH
8747: LD_INT 102
8749: PUSH
8750: LD_INT 105
8752: PUSH
8753: LD_INT 106
8755: PUSH
8756: LD_INT 108
8758: PUSH
8759: EMPTY
8760: LIST
8761: LIST
8762: LIST
8763: LIST
8764: LIST
8765: PUSH
8766: EMPTY
8767: LIST
8768: LIST
8769: ST_TO_ADDR
8770: GO 11373
8772: LD_INT 5
8774: DOUBLE
8775: EQUAL
8776: IFTRUE 8780
8778: GO 8880
8780: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
8781: LD_ADDR_VAR 0 1
8785: PUSH
8786: LD_INT 2
8788: PUSH
8789: LD_INT 4
8791: PUSH
8792: LD_INT 5
8794: PUSH
8795: LD_INT 6
8797: PUSH
8798: LD_INT 8
8800: PUSH
8801: LD_INT 11
8803: PUSH
8804: LD_INT 12
8806: PUSH
8807: LD_INT 15
8809: PUSH
8810: LD_INT 16
8812: PUSH
8813: LD_INT 22
8815: PUSH
8816: LD_INT 23
8818: PUSH
8819: LD_INT 25
8821: PUSH
8822: LD_INT 26
8824: PUSH
8825: LD_INT 36
8827: PUSH
8828: EMPTY
8829: LIST
8830: LIST
8831: LIST
8832: LIST
8833: LIST
8834: LIST
8835: LIST
8836: LIST
8837: LIST
8838: LIST
8839: LIST
8840: LIST
8841: LIST
8842: LIST
8843: PUSH
8844: LD_INT 101
8846: PUSH
8847: LD_INT 102
8849: PUSH
8850: LD_INT 105
8852: PUSH
8853: LD_INT 106
8855: PUSH
8856: LD_INT 108
8858: PUSH
8859: LD_INT 109
8861: PUSH
8862: LD_INT 112
8864: PUSH
8865: EMPTY
8866: LIST
8867: LIST
8868: LIST
8869: LIST
8870: LIST
8871: LIST
8872: LIST
8873: PUSH
8874: EMPTY
8875: LIST
8876: LIST
8877: ST_TO_ADDR
8878: GO 11373
8880: LD_INT 6
8882: DOUBLE
8883: EQUAL
8884: IFTRUE 8888
8886: GO 9008
8888: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
8889: LD_ADDR_VAR 0 1
8893: PUSH
8894: LD_INT 2
8896: PUSH
8897: LD_INT 4
8899: PUSH
8900: LD_INT 5
8902: PUSH
8903: LD_INT 6
8905: PUSH
8906: LD_INT 8
8908: PUSH
8909: LD_INT 11
8911: PUSH
8912: LD_INT 12
8914: PUSH
8915: LD_INT 15
8917: PUSH
8918: LD_INT 16
8920: PUSH
8921: LD_INT 20
8923: PUSH
8924: LD_INT 21
8926: PUSH
8927: LD_INT 22
8929: PUSH
8930: LD_INT 23
8932: PUSH
8933: LD_INT 25
8935: PUSH
8936: LD_INT 26
8938: PUSH
8939: LD_INT 30
8941: PUSH
8942: LD_INT 31
8944: PUSH
8945: LD_INT 32
8947: PUSH
8948: LD_INT 36
8950: PUSH
8951: EMPTY
8952: LIST
8953: LIST
8954: LIST
8955: LIST
8956: LIST
8957: LIST
8958: LIST
8959: LIST
8960: LIST
8961: LIST
8962: LIST
8963: LIST
8964: LIST
8965: LIST
8966: LIST
8967: LIST
8968: LIST
8969: LIST
8970: LIST
8971: PUSH
8972: LD_INT 101
8974: PUSH
8975: LD_INT 102
8977: PUSH
8978: LD_INT 105
8980: PUSH
8981: LD_INT 106
8983: PUSH
8984: LD_INT 108
8986: PUSH
8987: LD_INT 109
8989: PUSH
8990: LD_INT 112
8992: PUSH
8993: EMPTY
8994: LIST
8995: LIST
8996: LIST
8997: LIST
8998: LIST
8999: LIST
9000: LIST
9001: PUSH
9002: EMPTY
9003: LIST
9004: LIST
9005: ST_TO_ADDR
9006: GO 11373
9008: LD_INT 7
9010: DOUBLE
9011: EQUAL
9012: IFTRUE 9016
9014: GO 9116
9016: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
9017: LD_ADDR_VAR 0 1
9021: PUSH
9022: LD_INT 2
9024: PUSH
9025: LD_INT 4
9027: PUSH
9028: LD_INT 5
9030: PUSH
9031: LD_INT 7
9033: PUSH
9034: LD_INT 11
9036: PUSH
9037: LD_INT 12
9039: PUSH
9040: LD_INT 15
9042: PUSH
9043: LD_INT 16
9045: PUSH
9046: LD_INT 20
9048: PUSH
9049: LD_INT 21
9051: PUSH
9052: LD_INT 22
9054: PUSH
9055: LD_INT 23
9057: PUSH
9058: LD_INT 25
9060: PUSH
9061: LD_INT 26
9063: PUSH
9064: EMPTY
9065: LIST
9066: LIST
9067: LIST
9068: LIST
9069: LIST
9070: LIST
9071: LIST
9072: LIST
9073: LIST
9074: LIST
9075: LIST
9076: LIST
9077: LIST
9078: LIST
9079: PUSH
9080: LD_INT 101
9082: PUSH
9083: LD_INT 102
9085: PUSH
9086: LD_INT 103
9088: PUSH
9089: LD_INT 105
9091: PUSH
9092: LD_INT 106
9094: PUSH
9095: LD_INT 108
9097: PUSH
9098: LD_INT 112
9100: PUSH
9101: EMPTY
9102: LIST
9103: LIST
9104: LIST
9105: LIST
9106: LIST
9107: LIST
9108: LIST
9109: PUSH
9110: EMPTY
9111: LIST
9112: LIST
9113: ST_TO_ADDR
9114: GO 11373
9116: LD_INT 8
9118: DOUBLE
9119: EQUAL
9120: IFTRUE 9124
9122: GO 9252
9124: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
9125: LD_ADDR_VAR 0 1
9129: PUSH
9130: LD_INT 2
9132: PUSH
9133: LD_INT 4
9135: PUSH
9136: LD_INT 5
9138: PUSH
9139: LD_INT 6
9141: PUSH
9142: LD_INT 7
9144: PUSH
9145: LD_INT 8
9147: PUSH
9148: LD_INT 11
9150: PUSH
9151: LD_INT 12
9153: PUSH
9154: LD_INT 15
9156: PUSH
9157: LD_INT 16
9159: PUSH
9160: LD_INT 20
9162: PUSH
9163: LD_INT 21
9165: PUSH
9166: LD_INT 22
9168: PUSH
9169: LD_INT 23
9171: PUSH
9172: LD_INT 25
9174: PUSH
9175: LD_INT 26
9177: PUSH
9178: LD_INT 30
9180: PUSH
9181: LD_INT 31
9183: PUSH
9184: LD_INT 32
9186: PUSH
9187: LD_INT 36
9189: PUSH
9190: EMPTY
9191: LIST
9192: LIST
9193: LIST
9194: LIST
9195: LIST
9196: LIST
9197: LIST
9198: LIST
9199: LIST
9200: LIST
9201: LIST
9202: LIST
9203: LIST
9204: LIST
9205: LIST
9206: LIST
9207: LIST
9208: LIST
9209: LIST
9210: LIST
9211: PUSH
9212: LD_INT 101
9214: PUSH
9215: LD_INT 102
9217: PUSH
9218: LD_INT 103
9220: PUSH
9221: LD_INT 105
9223: PUSH
9224: LD_INT 106
9226: PUSH
9227: LD_INT 108
9229: PUSH
9230: LD_INT 109
9232: PUSH
9233: LD_INT 112
9235: PUSH
9236: EMPTY
9237: LIST
9238: LIST
9239: LIST
9240: LIST
9241: LIST
9242: LIST
9243: LIST
9244: LIST
9245: PUSH
9246: EMPTY
9247: LIST
9248: LIST
9249: ST_TO_ADDR
9250: GO 11373
9252: LD_INT 9
9254: DOUBLE
9255: EQUAL
9256: IFTRUE 9260
9258: GO 9396
9260: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
9261: LD_ADDR_VAR 0 1
9265: PUSH
9266: LD_INT 2
9268: PUSH
9269: LD_INT 4
9271: PUSH
9272: LD_INT 5
9274: PUSH
9275: LD_INT 6
9277: PUSH
9278: LD_INT 7
9280: PUSH
9281: LD_INT 8
9283: PUSH
9284: LD_INT 11
9286: PUSH
9287: LD_INT 12
9289: PUSH
9290: LD_INT 15
9292: PUSH
9293: LD_INT 16
9295: PUSH
9296: LD_INT 20
9298: PUSH
9299: LD_INT 21
9301: PUSH
9302: LD_INT 22
9304: PUSH
9305: LD_INT 23
9307: PUSH
9308: LD_INT 25
9310: PUSH
9311: LD_INT 26
9313: PUSH
9314: LD_INT 28
9316: PUSH
9317: LD_INT 30
9319: PUSH
9320: LD_INT 31
9322: PUSH
9323: LD_INT 32
9325: PUSH
9326: LD_INT 36
9328: PUSH
9329: EMPTY
9330: LIST
9331: LIST
9332: LIST
9333: LIST
9334: LIST
9335: LIST
9336: LIST
9337: LIST
9338: LIST
9339: LIST
9340: LIST
9341: LIST
9342: LIST
9343: LIST
9344: LIST
9345: LIST
9346: LIST
9347: LIST
9348: LIST
9349: LIST
9350: LIST
9351: PUSH
9352: LD_INT 101
9354: PUSH
9355: LD_INT 102
9357: PUSH
9358: LD_INT 103
9360: PUSH
9361: LD_INT 105
9363: PUSH
9364: LD_INT 106
9366: PUSH
9367: LD_INT 108
9369: PUSH
9370: LD_INT 109
9372: PUSH
9373: LD_INT 112
9375: PUSH
9376: LD_INT 114
9378: PUSH
9379: EMPTY
9380: LIST
9381: LIST
9382: LIST
9383: LIST
9384: LIST
9385: LIST
9386: LIST
9387: LIST
9388: LIST
9389: PUSH
9390: EMPTY
9391: LIST
9392: LIST
9393: ST_TO_ADDR
9394: GO 11373
9396: LD_INT 10
9398: DOUBLE
9399: EQUAL
9400: IFTRUE 9404
9402: GO 9588
9404: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
9405: LD_ADDR_VAR 0 1
9409: PUSH
9410: LD_INT 2
9412: PUSH
9413: LD_INT 4
9415: PUSH
9416: LD_INT 5
9418: PUSH
9419: LD_INT 6
9421: PUSH
9422: LD_INT 7
9424: PUSH
9425: LD_INT 8
9427: PUSH
9428: LD_INT 9
9430: PUSH
9431: LD_INT 10
9433: PUSH
9434: LD_INT 11
9436: PUSH
9437: LD_INT 12
9439: PUSH
9440: LD_INT 13
9442: PUSH
9443: LD_INT 14
9445: PUSH
9446: LD_INT 15
9448: PUSH
9449: LD_INT 16
9451: PUSH
9452: LD_INT 17
9454: PUSH
9455: LD_INT 18
9457: PUSH
9458: LD_INT 19
9460: PUSH
9461: LD_INT 20
9463: PUSH
9464: LD_INT 21
9466: PUSH
9467: LD_INT 22
9469: PUSH
9470: LD_INT 23
9472: PUSH
9473: LD_INT 24
9475: PUSH
9476: LD_INT 25
9478: PUSH
9479: LD_INT 26
9481: PUSH
9482: LD_INT 28
9484: PUSH
9485: LD_INT 30
9487: PUSH
9488: LD_INT 31
9490: PUSH
9491: LD_INT 32
9493: PUSH
9494: LD_INT 36
9496: PUSH
9497: EMPTY
9498: LIST
9499: LIST
9500: LIST
9501: LIST
9502: LIST
9503: LIST
9504: LIST
9505: LIST
9506: LIST
9507: LIST
9508: LIST
9509: LIST
9510: LIST
9511: LIST
9512: LIST
9513: LIST
9514: LIST
9515: LIST
9516: LIST
9517: LIST
9518: LIST
9519: LIST
9520: LIST
9521: LIST
9522: LIST
9523: LIST
9524: LIST
9525: LIST
9526: LIST
9527: PUSH
9528: LD_INT 101
9530: PUSH
9531: LD_INT 102
9533: PUSH
9534: LD_INT 103
9536: PUSH
9537: LD_INT 104
9539: PUSH
9540: LD_INT 105
9542: PUSH
9543: LD_INT 106
9545: PUSH
9546: LD_INT 107
9548: PUSH
9549: LD_INT 108
9551: PUSH
9552: LD_INT 109
9554: PUSH
9555: LD_INT 110
9557: PUSH
9558: LD_INT 111
9560: PUSH
9561: LD_INT 112
9563: PUSH
9564: LD_INT 114
9566: PUSH
9567: EMPTY
9568: LIST
9569: LIST
9570: LIST
9571: LIST
9572: LIST
9573: LIST
9574: LIST
9575: LIST
9576: LIST
9577: LIST
9578: LIST
9579: LIST
9580: LIST
9581: PUSH
9582: EMPTY
9583: LIST
9584: LIST
9585: ST_TO_ADDR
9586: GO 11373
9588: LD_INT 11
9590: DOUBLE
9591: EQUAL
9592: IFTRUE 9596
9594: GO 9788
9596: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
9597: LD_ADDR_VAR 0 1
9601: PUSH
9602: LD_INT 2
9604: PUSH
9605: LD_INT 3
9607: PUSH
9608: LD_INT 4
9610: PUSH
9611: LD_INT 5
9613: PUSH
9614: LD_INT 6
9616: PUSH
9617: LD_INT 7
9619: PUSH
9620: LD_INT 8
9622: PUSH
9623: LD_INT 9
9625: PUSH
9626: LD_INT 10
9628: PUSH
9629: LD_INT 11
9631: PUSH
9632: LD_INT 12
9634: PUSH
9635: LD_INT 13
9637: PUSH
9638: LD_INT 14
9640: PUSH
9641: LD_INT 15
9643: PUSH
9644: LD_INT 16
9646: PUSH
9647: LD_INT 17
9649: PUSH
9650: LD_INT 18
9652: PUSH
9653: LD_INT 19
9655: PUSH
9656: LD_INT 20
9658: PUSH
9659: LD_INT 21
9661: PUSH
9662: LD_INT 22
9664: PUSH
9665: LD_INT 23
9667: PUSH
9668: LD_INT 24
9670: PUSH
9671: LD_INT 25
9673: PUSH
9674: LD_INT 26
9676: PUSH
9677: LD_INT 28
9679: PUSH
9680: LD_INT 30
9682: PUSH
9683: LD_INT 31
9685: PUSH
9686: LD_INT 32
9688: PUSH
9689: LD_INT 34
9691: PUSH
9692: LD_INT 36
9694: PUSH
9695: EMPTY
9696: LIST
9697: LIST
9698: LIST
9699: LIST
9700: LIST
9701: LIST
9702: LIST
9703: LIST
9704: LIST
9705: LIST
9706: LIST
9707: LIST
9708: LIST
9709: LIST
9710: LIST
9711: LIST
9712: LIST
9713: LIST
9714: LIST
9715: LIST
9716: LIST
9717: LIST
9718: LIST
9719: LIST
9720: LIST
9721: LIST
9722: LIST
9723: LIST
9724: LIST
9725: LIST
9726: LIST
9727: PUSH
9728: LD_INT 101
9730: PUSH
9731: LD_INT 102
9733: PUSH
9734: LD_INT 103
9736: PUSH
9737: LD_INT 104
9739: PUSH
9740: LD_INT 105
9742: PUSH
9743: LD_INT 106
9745: PUSH
9746: LD_INT 107
9748: PUSH
9749: LD_INT 108
9751: PUSH
9752: LD_INT 109
9754: PUSH
9755: LD_INT 110
9757: PUSH
9758: LD_INT 111
9760: PUSH
9761: LD_INT 112
9763: PUSH
9764: LD_INT 114
9766: PUSH
9767: EMPTY
9768: LIST
9769: LIST
9770: LIST
9771: LIST
9772: LIST
9773: LIST
9774: LIST
9775: LIST
9776: LIST
9777: LIST
9778: LIST
9779: LIST
9780: LIST
9781: PUSH
9782: EMPTY
9783: LIST
9784: LIST
9785: ST_TO_ADDR
9786: GO 11373
9788: LD_INT 12
9790: DOUBLE
9791: EQUAL
9792: IFTRUE 9796
9794: GO 10004
9796: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
9797: LD_ADDR_VAR 0 1
9801: PUSH
9802: LD_INT 1
9804: PUSH
9805: LD_INT 2
9807: PUSH
9808: LD_INT 3
9810: PUSH
9811: LD_INT 4
9813: PUSH
9814: LD_INT 5
9816: PUSH
9817: LD_INT 6
9819: PUSH
9820: LD_INT 7
9822: PUSH
9823: LD_INT 8
9825: PUSH
9826: LD_INT 9
9828: PUSH
9829: LD_INT 10
9831: PUSH
9832: LD_INT 11
9834: PUSH
9835: LD_INT 12
9837: PUSH
9838: LD_INT 13
9840: PUSH
9841: LD_INT 14
9843: PUSH
9844: LD_INT 15
9846: PUSH
9847: LD_INT 16
9849: PUSH
9850: LD_INT 17
9852: PUSH
9853: LD_INT 18
9855: PUSH
9856: LD_INT 19
9858: PUSH
9859: LD_INT 20
9861: PUSH
9862: LD_INT 21
9864: PUSH
9865: LD_INT 22
9867: PUSH
9868: LD_INT 23
9870: PUSH
9871: LD_INT 24
9873: PUSH
9874: LD_INT 25
9876: PUSH
9877: LD_INT 26
9879: PUSH
9880: LD_INT 27
9882: PUSH
9883: LD_INT 28
9885: PUSH
9886: LD_INT 30
9888: PUSH
9889: LD_INT 31
9891: PUSH
9892: LD_INT 32
9894: PUSH
9895: LD_INT 33
9897: PUSH
9898: LD_INT 34
9900: PUSH
9901: LD_INT 36
9903: PUSH
9904: EMPTY
9905: LIST
9906: LIST
9907: LIST
9908: LIST
9909: LIST
9910: LIST
9911: LIST
9912: LIST
9913: LIST
9914: LIST
9915: LIST
9916: LIST
9917: LIST
9918: LIST
9919: LIST
9920: LIST
9921: LIST
9922: LIST
9923: LIST
9924: LIST
9925: LIST
9926: LIST
9927: LIST
9928: LIST
9929: LIST
9930: LIST
9931: LIST
9932: LIST
9933: LIST
9934: LIST
9935: LIST
9936: LIST
9937: LIST
9938: LIST
9939: PUSH
9940: LD_INT 101
9942: PUSH
9943: LD_INT 102
9945: PUSH
9946: LD_INT 103
9948: PUSH
9949: LD_INT 104
9951: PUSH
9952: LD_INT 105
9954: PUSH
9955: LD_INT 106
9957: PUSH
9958: LD_INT 107
9960: PUSH
9961: LD_INT 108
9963: PUSH
9964: LD_INT 109
9966: PUSH
9967: LD_INT 110
9969: PUSH
9970: LD_INT 111
9972: PUSH
9973: LD_INT 112
9975: PUSH
9976: LD_INT 113
9978: PUSH
9979: LD_INT 114
9981: PUSH
9982: EMPTY
9983: LIST
9984: LIST
9985: LIST
9986: LIST
9987: LIST
9988: LIST
9989: LIST
9990: LIST
9991: LIST
9992: LIST
9993: LIST
9994: LIST
9995: LIST
9996: LIST
9997: PUSH
9998: EMPTY
9999: LIST
10000: LIST
10001: ST_TO_ADDR
10002: GO 11373
10004: LD_INT 13
10006: DOUBLE
10007: EQUAL
10008: IFTRUE 10012
10010: GO 10208
10012: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
10013: LD_ADDR_VAR 0 1
10017: PUSH
10018: LD_INT 1
10020: PUSH
10021: LD_INT 2
10023: PUSH
10024: LD_INT 3
10026: PUSH
10027: LD_INT 4
10029: PUSH
10030: LD_INT 5
10032: PUSH
10033: LD_INT 8
10035: PUSH
10036: LD_INT 9
10038: PUSH
10039: LD_INT 10
10041: PUSH
10042: LD_INT 11
10044: PUSH
10045: LD_INT 12
10047: PUSH
10048: LD_INT 14
10050: PUSH
10051: LD_INT 15
10053: PUSH
10054: LD_INT 16
10056: PUSH
10057: LD_INT 17
10059: PUSH
10060: LD_INT 18
10062: PUSH
10063: LD_INT 19
10065: PUSH
10066: LD_INT 20
10068: PUSH
10069: LD_INT 21
10071: PUSH
10072: LD_INT 22
10074: PUSH
10075: LD_INT 23
10077: PUSH
10078: LD_INT 24
10080: PUSH
10081: LD_INT 25
10083: PUSH
10084: LD_INT 26
10086: PUSH
10087: LD_INT 27
10089: PUSH
10090: LD_INT 28
10092: PUSH
10093: LD_INT 30
10095: PUSH
10096: LD_INT 31
10098: PUSH
10099: LD_INT 32
10101: PUSH
10102: LD_INT 33
10104: PUSH
10105: LD_INT 34
10107: PUSH
10108: LD_INT 36
10110: PUSH
10111: EMPTY
10112: LIST
10113: LIST
10114: LIST
10115: LIST
10116: LIST
10117: LIST
10118: LIST
10119: LIST
10120: LIST
10121: LIST
10122: LIST
10123: LIST
10124: LIST
10125: LIST
10126: LIST
10127: LIST
10128: LIST
10129: LIST
10130: LIST
10131: LIST
10132: LIST
10133: LIST
10134: LIST
10135: LIST
10136: LIST
10137: LIST
10138: LIST
10139: LIST
10140: LIST
10141: LIST
10142: LIST
10143: PUSH
10144: LD_INT 101
10146: PUSH
10147: LD_INT 102
10149: PUSH
10150: LD_INT 103
10152: PUSH
10153: LD_INT 104
10155: PUSH
10156: LD_INT 105
10158: PUSH
10159: LD_INT 106
10161: PUSH
10162: LD_INT 107
10164: PUSH
10165: LD_INT 108
10167: PUSH
10168: LD_INT 109
10170: PUSH
10171: LD_INT 110
10173: PUSH
10174: LD_INT 111
10176: PUSH
10177: LD_INT 112
10179: PUSH
10180: LD_INT 113
10182: PUSH
10183: LD_INT 114
10185: PUSH
10186: EMPTY
10187: LIST
10188: LIST
10189: LIST
10190: LIST
10191: LIST
10192: LIST
10193: LIST
10194: LIST
10195: LIST
10196: LIST
10197: LIST
10198: LIST
10199: LIST
10200: LIST
10201: PUSH
10202: EMPTY
10203: LIST
10204: LIST
10205: ST_TO_ADDR
10206: GO 11373
10208: LD_INT 14
10210: DOUBLE
10211: EQUAL
10212: IFTRUE 10216
10214: GO 10428
10216: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
10217: LD_ADDR_VAR 0 1
10221: PUSH
10222: LD_INT 1
10224: PUSH
10225: LD_INT 2
10227: PUSH
10228: LD_INT 3
10230: PUSH
10231: LD_INT 4
10233: PUSH
10234: LD_INT 5
10236: PUSH
10237: LD_INT 6
10239: PUSH
10240: LD_INT 7
10242: PUSH
10243: LD_INT 8
10245: PUSH
10246: LD_INT 9
10248: PUSH
10249: LD_INT 10
10251: PUSH
10252: LD_INT 11
10254: PUSH
10255: LD_INT 12
10257: PUSH
10258: LD_INT 13
10260: PUSH
10261: LD_INT 14
10263: PUSH
10264: LD_INT 15
10266: PUSH
10267: LD_INT 16
10269: PUSH
10270: LD_INT 17
10272: PUSH
10273: LD_INT 18
10275: PUSH
10276: LD_INT 19
10278: PUSH
10279: LD_INT 20
10281: PUSH
10282: LD_INT 21
10284: PUSH
10285: LD_INT 22
10287: PUSH
10288: LD_INT 23
10290: PUSH
10291: LD_INT 24
10293: PUSH
10294: LD_INT 25
10296: PUSH
10297: LD_INT 26
10299: PUSH
10300: LD_INT 27
10302: PUSH
10303: LD_INT 28
10305: PUSH
10306: LD_INT 29
10308: PUSH
10309: LD_INT 30
10311: PUSH
10312: LD_INT 31
10314: PUSH
10315: LD_INT 32
10317: PUSH
10318: LD_INT 33
10320: PUSH
10321: LD_INT 34
10323: PUSH
10324: LD_INT 36
10326: PUSH
10327: EMPTY
10328: LIST
10329: LIST
10330: LIST
10331: LIST
10332: LIST
10333: LIST
10334: LIST
10335: LIST
10336: LIST
10337: LIST
10338: LIST
10339: LIST
10340: LIST
10341: LIST
10342: LIST
10343: LIST
10344: LIST
10345: LIST
10346: LIST
10347: LIST
10348: LIST
10349: LIST
10350: LIST
10351: LIST
10352: LIST
10353: LIST
10354: LIST
10355: LIST
10356: LIST
10357: LIST
10358: LIST
10359: LIST
10360: LIST
10361: LIST
10362: LIST
10363: PUSH
10364: LD_INT 101
10366: PUSH
10367: LD_INT 102
10369: PUSH
10370: LD_INT 103
10372: PUSH
10373: LD_INT 104
10375: PUSH
10376: LD_INT 105
10378: PUSH
10379: LD_INT 106
10381: PUSH
10382: LD_INT 107
10384: PUSH
10385: LD_INT 108
10387: PUSH
10388: LD_INT 109
10390: PUSH
10391: LD_INT 110
10393: PUSH
10394: LD_INT 111
10396: PUSH
10397: LD_INT 112
10399: PUSH
10400: LD_INT 113
10402: PUSH
10403: LD_INT 114
10405: PUSH
10406: EMPTY
10407: LIST
10408: LIST
10409: LIST
10410: LIST
10411: LIST
10412: LIST
10413: LIST
10414: LIST
10415: LIST
10416: LIST
10417: LIST
10418: LIST
10419: LIST
10420: LIST
10421: PUSH
10422: EMPTY
10423: LIST
10424: LIST
10425: ST_TO_ADDR
10426: GO 11373
10428: LD_INT 15
10430: DOUBLE
10431: EQUAL
10432: IFTRUE 10436
10434: GO 10648
10436: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
10437: LD_ADDR_VAR 0 1
10441: PUSH
10442: LD_INT 1
10444: PUSH
10445: LD_INT 2
10447: PUSH
10448: LD_INT 3
10450: PUSH
10451: LD_INT 4
10453: PUSH
10454: LD_INT 5
10456: PUSH
10457: LD_INT 6
10459: PUSH
10460: LD_INT 7
10462: PUSH
10463: LD_INT 8
10465: PUSH
10466: LD_INT 9
10468: PUSH
10469: LD_INT 10
10471: PUSH
10472: LD_INT 11
10474: PUSH
10475: LD_INT 12
10477: PUSH
10478: LD_INT 13
10480: PUSH
10481: LD_INT 14
10483: PUSH
10484: LD_INT 15
10486: PUSH
10487: LD_INT 16
10489: PUSH
10490: LD_INT 17
10492: PUSH
10493: LD_INT 18
10495: PUSH
10496: LD_INT 19
10498: PUSH
10499: LD_INT 20
10501: PUSH
10502: LD_INT 21
10504: PUSH
10505: LD_INT 22
10507: PUSH
10508: LD_INT 23
10510: PUSH
10511: LD_INT 24
10513: PUSH
10514: LD_INT 25
10516: PUSH
10517: LD_INT 26
10519: PUSH
10520: LD_INT 27
10522: PUSH
10523: LD_INT 28
10525: PUSH
10526: LD_INT 29
10528: PUSH
10529: LD_INT 30
10531: PUSH
10532: LD_INT 31
10534: PUSH
10535: LD_INT 32
10537: PUSH
10538: LD_INT 33
10540: PUSH
10541: LD_INT 34
10543: PUSH
10544: LD_INT 36
10546: PUSH
10547: EMPTY
10548: LIST
10549: LIST
10550: LIST
10551: LIST
10552: LIST
10553: LIST
10554: LIST
10555: LIST
10556: LIST
10557: LIST
10558: LIST
10559: LIST
10560: LIST
10561: LIST
10562: LIST
10563: LIST
10564: LIST
10565: LIST
10566: LIST
10567: LIST
10568: LIST
10569: LIST
10570: LIST
10571: LIST
10572: LIST
10573: LIST
10574: LIST
10575: LIST
10576: LIST
10577: LIST
10578: LIST
10579: LIST
10580: LIST
10581: LIST
10582: LIST
10583: PUSH
10584: LD_INT 101
10586: PUSH
10587: LD_INT 102
10589: PUSH
10590: LD_INT 103
10592: PUSH
10593: LD_INT 104
10595: PUSH
10596: LD_INT 105
10598: PUSH
10599: LD_INT 106
10601: PUSH
10602: LD_INT 107
10604: PUSH
10605: LD_INT 108
10607: PUSH
10608: LD_INT 109
10610: PUSH
10611: LD_INT 110
10613: PUSH
10614: LD_INT 111
10616: PUSH
10617: LD_INT 112
10619: PUSH
10620: LD_INT 113
10622: PUSH
10623: LD_INT 114
10625: PUSH
10626: EMPTY
10627: LIST
10628: LIST
10629: LIST
10630: LIST
10631: LIST
10632: LIST
10633: LIST
10634: LIST
10635: LIST
10636: LIST
10637: LIST
10638: LIST
10639: LIST
10640: LIST
10641: PUSH
10642: EMPTY
10643: LIST
10644: LIST
10645: ST_TO_ADDR
10646: GO 11373
10648: LD_INT 16
10650: DOUBLE
10651: EQUAL
10652: IFTRUE 10656
10654: GO 10780
10656: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
10657: LD_ADDR_VAR 0 1
10661: PUSH
10662: LD_INT 2
10664: PUSH
10665: LD_INT 4
10667: PUSH
10668: LD_INT 5
10670: PUSH
10671: LD_INT 7
10673: PUSH
10674: LD_INT 11
10676: PUSH
10677: LD_INT 12
10679: PUSH
10680: LD_INT 15
10682: PUSH
10683: LD_INT 16
10685: PUSH
10686: LD_INT 20
10688: PUSH
10689: LD_INT 21
10691: PUSH
10692: LD_INT 22
10694: PUSH
10695: LD_INT 23
10697: PUSH
10698: LD_INT 25
10700: PUSH
10701: LD_INT 26
10703: PUSH
10704: LD_INT 30
10706: PUSH
10707: LD_INT 31
10709: PUSH
10710: LD_INT 32
10712: PUSH
10713: LD_INT 33
10715: PUSH
10716: LD_INT 34
10718: PUSH
10719: EMPTY
10720: LIST
10721: LIST
10722: LIST
10723: LIST
10724: LIST
10725: LIST
10726: LIST
10727: LIST
10728: LIST
10729: LIST
10730: LIST
10731: LIST
10732: LIST
10733: LIST
10734: LIST
10735: LIST
10736: LIST
10737: LIST
10738: LIST
10739: PUSH
10740: LD_INT 101
10742: PUSH
10743: LD_INT 102
10745: PUSH
10746: LD_INT 103
10748: PUSH
10749: LD_INT 106
10751: PUSH
10752: LD_INT 108
10754: PUSH
10755: LD_INT 112
10757: PUSH
10758: LD_INT 113
10760: PUSH
10761: LD_INT 114
10763: PUSH
10764: EMPTY
10765: LIST
10766: LIST
10767: LIST
10768: LIST
10769: LIST
10770: LIST
10771: LIST
10772: LIST
10773: PUSH
10774: EMPTY
10775: LIST
10776: LIST
10777: ST_TO_ADDR
10778: GO 11373
10780: LD_INT 17
10782: DOUBLE
10783: EQUAL
10784: IFTRUE 10788
10786: GO 11000
10788: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
10789: LD_ADDR_VAR 0 1
10793: PUSH
10794: LD_INT 1
10796: PUSH
10797: LD_INT 2
10799: PUSH
10800: LD_INT 3
10802: PUSH
10803: LD_INT 4
10805: PUSH
10806: LD_INT 5
10808: PUSH
10809: LD_INT 6
10811: PUSH
10812: LD_INT 7
10814: PUSH
10815: LD_INT 8
10817: PUSH
10818: LD_INT 9
10820: PUSH
10821: LD_INT 10
10823: PUSH
10824: LD_INT 11
10826: PUSH
10827: LD_INT 12
10829: PUSH
10830: LD_INT 13
10832: PUSH
10833: LD_INT 14
10835: PUSH
10836: LD_INT 15
10838: PUSH
10839: LD_INT 16
10841: PUSH
10842: LD_INT 17
10844: PUSH
10845: LD_INT 18
10847: PUSH
10848: LD_INT 19
10850: PUSH
10851: LD_INT 20
10853: PUSH
10854: LD_INT 21
10856: PUSH
10857: LD_INT 22
10859: PUSH
10860: LD_INT 23
10862: PUSH
10863: LD_INT 24
10865: PUSH
10866: LD_INT 25
10868: PUSH
10869: LD_INT 26
10871: PUSH
10872: LD_INT 27
10874: PUSH
10875: LD_INT 28
10877: PUSH
10878: LD_INT 29
10880: PUSH
10881: LD_INT 30
10883: PUSH
10884: LD_INT 31
10886: PUSH
10887: LD_INT 32
10889: PUSH
10890: LD_INT 33
10892: PUSH
10893: LD_INT 34
10895: PUSH
10896: LD_INT 36
10898: PUSH
10899: EMPTY
10900: LIST
10901: LIST
10902: LIST
10903: LIST
10904: LIST
10905: LIST
10906: LIST
10907: LIST
10908: LIST
10909: LIST
10910: LIST
10911: LIST
10912: LIST
10913: LIST
10914: LIST
10915: LIST
10916: LIST
10917: LIST
10918: LIST
10919: LIST
10920: LIST
10921: LIST
10922: LIST
10923: LIST
10924: LIST
10925: LIST
10926: LIST
10927: LIST
10928: LIST
10929: LIST
10930: LIST
10931: LIST
10932: LIST
10933: LIST
10934: LIST
10935: PUSH
10936: LD_INT 101
10938: PUSH
10939: LD_INT 102
10941: PUSH
10942: LD_INT 103
10944: PUSH
10945: LD_INT 104
10947: PUSH
10948: LD_INT 105
10950: PUSH
10951: LD_INT 106
10953: PUSH
10954: LD_INT 107
10956: PUSH
10957: LD_INT 108
10959: PUSH
10960: LD_INT 109
10962: PUSH
10963: LD_INT 110
10965: PUSH
10966: LD_INT 111
10968: PUSH
10969: LD_INT 112
10971: PUSH
10972: LD_INT 113
10974: PUSH
10975: LD_INT 114
10977: PUSH
10978: EMPTY
10979: LIST
10980: LIST
10981: LIST
10982: LIST
10983: LIST
10984: LIST
10985: LIST
10986: LIST
10987: LIST
10988: LIST
10989: LIST
10990: LIST
10991: LIST
10992: LIST
10993: PUSH
10994: EMPTY
10995: LIST
10996: LIST
10997: ST_TO_ADDR
10998: GO 11373
11000: LD_INT 18
11002: DOUBLE
11003: EQUAL
11004: IFTRUE 11008
11006: GO 11144
11008: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
11009: LD_ADDR_VAR 0 1
11013: PUSH
11014: LD_INT 2
11016: PUSH
11017: LD_INT 4
11019: PUSH
11020: LD_INT 5
11022: PUSH
11023: LD_INT 7
11025: PUSH
11026: LD_INT 11
11028: PUSH
11029: LD_INT 12
11031: PUSH
11032: LD_INT 15
11034: PUSH
11035: LD_INT 16
11037: PUSH
11038: LD_INT 20
11040: PUSH
11041: LD_INT 21
11043: PUSH
11044: LD_INT 22
11046: PUSH
11047: LD_INT 23
11049: PUSH
11050: LD_INT 25
11052: PUSH
11053: LD_INT 26
11055: PUSH
11056: LD_INT 30
11058: PUSH
11059: LD_INT 31
11061: PUSH
11062: LD_INT 32
11064: PUSH
11065: LD_INT 33
11067: PUSH
11068: LD_INT 34
11070: PUSH
11071: LD_INT 35
11073: PUSH
11074: LD_INT 36
11076: PUSH
11077: EMPTY
11078: LIST
11079: LIST
11080: LIST
11081: LIST
11082: LIST
11083: LIST
11084: LIST
11085: LIST
11086: LIST
11087: LIST
11088: LIST
11089: LIST
11090: LIST
11091: LIST
11092: LIST
11093: LIST
11094: LIST
11095: LIST
11096: LIST
11097: LIST
11098: LIST
11099: PUSH
11100: LD_INT 101
11102: PUSH
11103: LD_INT 102
11105: PUSH
11106: LD_INT 103
11108: PUSH
11109: LD_INT 106
11111: PUSH
11112: LD_INT 108
11114: PUSH
11115: LD_INT 112
11117: PUSH
11118: LD_INT 113
11120: PUSH
11121: LD_INT 114
11123: PUSH
11124: LD_INT 115
11126: PUSH
11127: EMPTY
11128: LIST
11129: LIST
11130: LIST
11131: LIST
11132: LIST
11133: LIST
11134: LIST
11135: LIST
11136: LIST
11137: PUSH
11138: EMPTY
11139: LIST
11140: LIST
11141: ST_TO_ADDR
11142: GO 11373
11144: LD_INT 19
11146: DOUBLE
11147: EQUAL
11148: IFTRUE 11152
11150: GO 11372
11152: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
11153: LD_ADDR_VAR 0 1
11157: PUSH
11158: LD_INT 1
11160: PUSH
11161: LD_INT 2
11163: PUSH
11164: LD_INT 3
11166: PUSH
11167: LD_INT 4
11169: PUSH
11170: LD_INT 5
11172: PUSH
11173: LD_INT 6
11175: PUSH
11176: LD_INT 7
11178: PUSH
11179: LD_INT 8
11181: PUSH
11182: LD_INT 9
11184: PUSH
11185: LD_INT 10
11187: PUSH
11188: LD_INT 11
11190: PUSH
11191: LD_INT 12
11193: PUSH
11194: LD_INT 13
11196: PUSH
11197: LD_INT 14
11199: PUSH
11200: LD_INT 15
11202: PUSH
11203: LD_INT 16
11205: PUSH
11206: LD_INT 17
11208: PUSH
11209: LD_INT 18
11211: PUSH
11212: LD_INT 19
11214: PUSH
11215: LD_INT 20
11217: PUSH
11218: LD_INT 21
11220: PUSH
11221: LD_INT 22
11223: PUSH
11224: LD_INT 23
11226: PUSH
11227: LD_INT 24
11229: PUSH
11230: LD_INT 25
11232: PUSH
11233: LD_INT 26
11235: PUSH
11236: LD_INT 27
11238: PUSH
11239: LD_INT 28
11241: PUSH
11242: LD_INT 29
11244: PUSH
11245: LD_INT 30
11247: PUSH
11248: LD_INT 31
11250: PUSH
11251: LD_INT 32
11253: PUSH
11254: LD_INT 33
11256: PUSH
11257: LD_INT 34
11259: PUSH
11260: LD_INT 35
11262: PUSH
11263: LD_INT 36
11265: PUSH
11266: EMPTY
11267: LIST
11268: LIST
11269: LIST
11270: LIST
11271: LIST
11272: LIST
11273: LIST
11274: LIST
11275: LIST
11276: LIST
11277: LIST
11278: LIST
11279: LIST
11280: LIST
11281: LIST
11282: LIST
11283: LIST
11284: LIST
11285: LIST
11286: LIST
11287: LIST
11288: LIST
11289: LIST
11290: LIST
11291: LIST
11292: LIST
11293: LIST
11294: LIST
11295: LIST
11296: LIST
11297: LIST
11298: LIST
11299: LIST
11300: LIST
11301: LIST
11302: LIST
11303: PUSH
11304: LD_INT 101
11306: PUSH
11307: LD_INT 102
11309: PUSH
11310: LD_INT 103
11312: PUSH
11313: LD_INT 104
11315: PUSH
11316: LD_INT 105
11318: PUSH
11319: LD_INT 106
11321: PUSH
11322: LD_INT 107
11324: PUSH
11325: LD_INT 108
11327: PUSH
11328: LD_INT 109
11330: PUSH
11331: LD_INT 110
11333: PUSH
11334: LD_INT 111
11336: PUSH
11337: LD_INT 112
11339: PUSH
11340: LD_INT 113
11342: PUSH
11343: LD_INT 114
11345: PUSH
11346: LD_INT 115
11348: PUSH
11349: EMPTY
11350: LIST
11351: LIST
11352: LIST
11353: LIST
11354: LIST
11355: LIST
11356: LIST
11357: LIST
11358: LIST
11359: LIST
11360: LIST
11361: LIST
11362: LIST
11363: LIST
11364: LIST
11365: PUSH
11366: EMPTY
11367: LIST
11368: LIST
11369: ST_TO_ADDR
11370: GO 11373
11372: POP
// end else
11373: GO 11592
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
11375: LD_ADDR_VAR 0 1
11379: PUSH
11380: LD_INT 1
11382: PUSH
11383: LD_INT 2
11385: PUSH
11386: LD_INT 3
11388: PUSH
11389: LD_INT 4
11391: PUSH
11392: LD_INT 5
11394: PUSH
11395: LD_INT 6
11397: PUSH
11398: LD_INT 7
11400: PUSH
11401: LD_INT 8
11403: PUSH
11404: LD_INT 9
11406: PUSH
11407: LD_INT 10
11409: PUSH
11410: LD_INT 11
11412: PUSH
11413: LD_INT 12
11415: PUSH
11416: LD_INT 13
11418: PUSH
11419: LD_INT 14
11421: PUSH
11422: LD_INT 15
11424: PUSH
11425: LD_INT 16
11427: PUSH
11428: LD_INT 17
11430: PUSH
11431: LD_INT 18
11433: PUSH
11434: LD_INT 19
11436: PUSH
11437: LD_INT 20
11439: PUSH
11440: LD_INT 21
11442: PUSH
11443: LD_INT 22
11445: PUSH
11446: LD_INT 23
11448: PUSH
11449: LD_INT 24
11451: PUSH
11452: LD_INT 25
11454: PUSH
11455: LD_INT 26
11457: PUSH
11458: LD_INT 27
11460: PUSH
11461: LD_INT 28
11463: PUSH
11464: LD_INT 29
11466: PUSH
11467: LD_INT 30
11469: PUSH
11470: LD_INT 31
11472: PUSH
11473: LD_INT 32
11475: PUSH
11476: LD_INT 33
11478: PUSH
11479: LD_INT 34
11481: PUSH
11482: LD_INT 35
11484: PUSH
11485: LD_INT 36
11487: PUSH
11488: EMPTY
11489: LIST
11490: LIST
11491: LIST
11492: LIST
11493: LIST
11494: LIST
11495: LIST
11496: LIST
11497: LIST
11498: LIST
11499: LIST
11500: LIST
11501: LIST
11502: LIST
11503: LIST
11504: LIST
11505: LIST
11506: LIST
11507: LIST
11508: LIST
11509: LIST
11510: LIST
11511: LIST
11512: LIST
11513: LIST
11514: LIST
11515: LIST
11516: LIST
11517: LIST
11518: LIST
11519: LIST
11520: LIST
11521: LIST
11522: LIST
11523: LIST
11524: LIST
11525: PUSH
11526: LD_INT 101
11528: PUSH
11529: LD_INT 102
11531: PUSH
11532: LD_INT 103
11534: PUSH
11535: LD_INT 104
11537: PUSH
11538: LD_INT 105
11540: PUSH
11541: LD_INT 106
11543: PUSH
11544: LD_INT 107
11546: PUSH
11547: LD_INT 108
11549: PUSH
11550: LD_INT 109
11552: PUSH
11553: LD_INT 110
11555: PUSH
11556: LD_INT 111
11558: PUSH
11559: LD_INT 112
11561: PUSH
11562: LD_INT 113
11564: PUSH
11565: LD_INT 114
11567: PUSH
11568: LD_INT 115
11570: PUSH
11571: EMPTY
11572: LIST
11573: LIST
11574: LIST
11575: LIST
11576: LIST
11577: LIST
11578: LIST
11579: LIST
11580: LIST
11581: LIST
11582: LIST
11583: LIST
11584: LIST
11585: LIST
11586: LIST
11587: PUSH
11588: EMPTY
11589: LIST
11590: LIST
11591: ST_TO_ADDR
// if result then
11592: LD_VAR 0 1
11596: IFFALSE 11885
// begin normal :=  ;
11598: LD_ADDR_VAR 0 3
11602: PUSH
11603: LD_STRING 
11605: ST_TO_ADDR
// hardcore :=  ;
11606: LD_ADDR_VAR 0 4
11610: PUSH
11611: LD_STRING 
11613: ST_TO_ADDR
// for i = 1 to normalCounter do
11614: LD_ADDR_VAR 0 5
11618: PUSH
11619: DOUBLE
11620: LD_INT 1
11622: DEC
11623: ST_TO_ADDR
11624: LD_EXP 43
11628: PUSH
11629: FOR_TO
11630: IFFALSE 11731
// begin tmp := 0 ;
11632: LD_ADDR_VAR 0 2
11636: PUSH
11637: LD_STRING 0
11639: ST_TO_ADDR
// if result [ 1 ] then
11640: LD_VAR 0 1
11644: PUSH
11645: LD_INT 1
11647: ARRAY
11648: IFFALSE 11713
// if result [ 1 ] [ 1 ] = i then
11650: LD_VAR 0 1
11654: PUSH
11655: LD_INT 1
11657: ARRAY
11658: PUSH
11659: LD_INT 1
11661: ARRAY
11662: PUSH
11663: LD_VAR 0 5
11667: EQUAL
11668: IFFALSE 11713
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
11670: LD_ADDR_VAR 0 1
11674: PUSH
11675: LD_VAR 0 1
11679: PPUSH
11680: LD_INT 1
11682: PPUSH
11683: LD_VAR 0 1
11687: PUSH
11688: LD_INT 1
11690: ARRAY
11691: PPUSH
11692: LD_INT 1
11694: PPUSH
11695: CALL_OW 3
11699: PPUSH
11700: CALL_OW 1
11704: ST_TO_ADDR
// tmp := 1 ;
11705: LD_ADDR_VAR 0 2
11709: PUSH
11710: LD_STRING 1
11712: ST_TO_ADDR
// end ; normal := normal & tmp ;
11713: LD_ADDR_VAR 0 3
11717: PUSH
11718: LD_VAR 0 3
11722: PUSH
11723: LD_VAR 0 2
11727: STR
11728: ST_TO_ADDR
// end ;
11729: GO 11629
11731: POP
11732: POP
// for i = 1 to hardcoreCounter do
11733: LD_ADDR_VAR 0 5
11737: PUSH
11738: DOUBLE
11739: LD_INT 1
11741: DEC
11742: ST_TO_ADDR
11743: LD_EXP 44
11747: PUSH
11748: FOR_TO
11749: IFFALSE 11854
// begin tmp := 0 ;
11751: LD_ADDR_VAR 0 2
11755: PUSH
11756: LD_STRING 0
11758: ST_TO_ADDR
// if result [ 2 ] then
11759: LD_VAR 0 1
11763: PUSH
11764: LD_INT 2
11766: ARRAY
11767: IFFALSE 11836
// if result [ 2 ] [ 1 ] = 100 + i then
11769: LD_VAR 0 1
11773: PUSH
11774: LD_INT 2
11776: ARRAY
11777: PUSH
11778: LD_INT 1
11780: ARRAY
11781: PUSH
11782: LD_INT 100
11784: PUSH
11785: LD_VAR 0 5
11789: PLUS
11790: EQUAL
11791: IFFALSE 11836
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
11793: LD_ADDR_VAR 0 1
11797: PUSH
11798: LD_VAR 0 1
11802: PPUSH
11803: LD_INT 2
11805: PPUSH
11806: LD_VAR 0 1
11810: PUSH
11811: LD_INT 2
11813: ARRAY
11814: PPUSH
11815: LD_INT 1
11817: PPUSH
11818: CALL_OW 3
11822: PPUSH
11823: CALL_OW 1
11827: ST_TO_ADDR
// tmp := 1 ;
11828: LD_ADDR_VAR 0 2
11832: PUSH
11833: LD_STRING 1
11835: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
11836: LD_ADDR_VAR 0 4
11840: PUSH
11841: LD_VAR 0 4
11845: PUSH
11846: LD_VAR 0 2
11850: STR
11851: ST_TO_ADDR
// end ;
11852: GO 11748
11854: POP
11855: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
11856: LD_STRING getStreamItemsFromMission("
11858: PUSH
11859: LD_VAR 0 3
11863: STR
11864: PUSH
11865: LD_STRING ","
11867: STR
11868: PUSH
11869: LD_VAR 0 4
11873: STR
11874: PUSH
11875: LD_STRING ")
11877: STR
11878: PPUSH
11879: CALL_OW 559
// end else
11883: GO 11892
// ToLua ( getStreamItemsFromMission("","") ) ;
11885: LD_STRING getStreamItemsFromMission("","")
11887: PPUSH
11888: CALL_OW 559
// end ;
11892: LD_VAR 0 1
11896: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
11897: LD_VAR 0 2
11901: PUSH
11902: LD_INT 100
11904: EQUAL
11905: IFFALSE 12854
// begin if not StreamModeActive then
11907: LD_EXP 42
11911: NOT
11912: IFFALSE 11922
// StreamModeActive := true ;
11914: LD_ADDR_EXP 42
11918: PUSH
11919: LD_INT 1
11921: ST_TO_ADDR
// if p3 = 0 then
11922: LD_VAR 0 3
11926: PUSH
11927: LD_INT 0
11929: EQUAL
11930: IFFALSE 11936
// InitStreamMode ;
11932: CALL 7975 0 0
// if p3 = 1 then
11936: LD_VAR 0 3
11940: PUSH
11941: LD_INT 1
11943: EQUAL
11944: IFFALSE 11954
// sRocket := true ;
11946: LD_ADDR_EXP 47
11950: PUSH
11951: LD_INT 1
11953: ST_TO_ADDR
// if p3 = 2 then
11954: LD_VAR 0 3
11958: PUSH
11959: LD_INT 2
11961: EQUAL
11962: IFFALSE 11972
// sSpeed := true ;
11964: LD_ADDR_EXP 46
11968: PUSH
11969: LD_INT 1
11971: ST_TO_ADDR
// if p3 = 3 then
11972: LD_VAR 0 3
11976: PUSH
11977: LD_INT 3
11979: EQUAL
11980: IFFALSE 11990
// sEngine := true ;
11982: LD_ADDR_EXP 48
11986: PUSH
11987: LD_INT 1
11989: ST_TO_ADDR
// if p3 = 4 then
11990: LD_VAR 0 3
11994: PUSH
11995: LD_INT 4
11997: EQUAL
11998: IFFALSE 12008
// sSpec := true ;
12000: LD_ADDR_EXP 45
12004: PUSH
12005: LD_INT 1
12007: ST_TO_ADDR
// if p3 = 5 then
12008: LD_VAR 0 3
12012: PUSH
12013: LD_INT 5
12015: EQUAL
12016: IFFALSE 12026
// sLevel := true ;
12018: LD_ADDR_EXP 49
12022: PUSH
12023: LD_INT 1
12025: ST_TO_ADDR
// if p3 = 6 then
12026: LD_VAR 0 3
12030: PUSH
12031: LD_INT 6
12033: EQUAL
12034: IFFALSE 12044
// sArmoury := true ;
12036: LD_ADDR_EXP 50
12040: PUSH
12041: LD_INT 1
12043: ST_TO_ADDR
// if p3 = 7 then
12044: LD_VAR 0 3
12048: PUSH
12049: LD_INT 7
12051: EQUAL
12052: IFFALSE 12062
// sRadar := true ;
12054: LD_ADDR_EXP 51
12058: PUSH
12059: LD_INT 1
12061: ST_TO_ADDR
// if p3 = 8 then
12062: LD_VAR 0 3
12066: PUSH
12067: LD_INT 8
12069: EQUAL
12070: IFFALSE 12080
// sBunker := true ;
12072: LD_ADDR_EXP 52
12076: PUSH
12077: LD_INT 1
12079: ST_TO_ADDR
// if p3 = 9 then
12080: LD_VAR 0 3
12084: PUSH
12085: LD_INT 9
12087: EQUAL
12088: IFFALSE 12098
// sHack := true ;
12090: LD_ADDR_EXP 53
12094: PUSH
12095: LD_INT 1
12097: ST_TO_ADDR
// if p3 = 10 then
12098: LD_VAR 0 3
12102: PUSH
12103: LD_INT 10
12105: EQUAL
12106: IFFALSE 12116
// sFire := true ;
12108: LD_ADDR_EXP 54
12112: PUSH
12113: LD_INT 1
12115: ST_TO_ADDR
// if p3 = 11 then
12116: LD_VAR 0 3
12120: PUSH
12121: LD_INT 11
12123: EQUAL
12124: IFFALSE 12134
// sRefresh := true ;
12126: LD_ADDR_EXP 55
12130: PUSH
12131: LD_INT 1
12133: ST_TO_ADDR
// if p3 = 12 then
12134: LD_VAR 0 3
12138: PUSH
12139: LD_INT 12
12141: EQUAL
12142: IFFALSE 12152
// sExp := true ;
12144: LD_ADDR_EXP 56
12148: PUSH
12149: LD_INT 1
12151: ST_TO_ADDR
// if p3 = 13 then
12152: LD_VAR 0 3
12156: PUSH
12157: LD_INT 13
12159: EQUAL
12160: IFFALSE 12170
// sDepot := true ;
12162: LD_ADDR_EXP 57
12166: PUSH
12167: LD_INT 1
12169: ST_TO_ADDR
// if p3 = 14 then
12170: LD_VAR 0 3
12174: PUSH
12175: LD_INT 14
12177: EQUAL
12178: IFFALSE 12188
// sFlag := true ;
12180: LD_ADDR_EXP 58
12184: PUSH
12185: LD_INT 1
12187: ST_TO_ADDR
// if p3 = 15 then
12188: LD_VAR 0 3
12192: PUSH
12193: LD_INT 15
12195: EQUAL
12196: IFFALSE 12206
// sKamikadze := true ;
12198: LD_ADDR_EXP 66
12202: PUSH
12203: LD_INT 1
12205: ST_TO_ADDR
// if p3 = 16 then
12206: LD_VAR 0 3
12210: PUSH
12211: LD_INT 16
12213: EQUAL
12214: IFFALSE 12224
// sTroll := true ;
12216: LD_ADDR_EXP 67
12220: PUSH
12221: LD_INT 1
12223: ST_TO_ADDR
// if p3 = 17 then
12224: LD_VAR 0 3
12228: PUSH
12229: LD_INT 17
12231: EQUAL
12232: IFFALSE 12242
// sSlow := true ;
12234: LD_ADDR_EXP 68
12238: PUSH
12239: LD_INT 1
12241: ST_TO_ADDR
// if p3 = 18 then
12242: LD_VAR 0 3
12246: PUSH
12247: LD_INT 18
12249: EQUAL
12250: IFFALSE 12260
// sLack := true ;
12252: LD_ADDR_EXP 69
12256: PUSH
12257: LD_INT 1
12259: ST_TO_ADDR
// if p3 = 19 then
12260: LD_VAR 0 3
12264: PUSH
12265: LD_INT 19
12267: EQUAL
12268: IFFALSE 12278
// sTank := true ;
12270: LD_ADDR_EXP 71
12274: PUSH
12275: LD_INT 1
12277: ST_TO_ADDR
// if p3 = 20 then
12278: LD_VAR 0 3
12282: PUSH
12283: LD_INT 20
12285: EQUAL
12286: IFFALSE 12296
// sRemote := true ;
12288: LD_ADDR_EXP 72
12292: PUSH
12293: LD_INT 1
12295: ST_TO_ADDR
// if p3 = 21 then
12296: LD_VAR 0 3
12300: PUSH
12301: LD_INT 21
12303: EQUAL
12304: IFFALSE 12314
// sPowell := true ;
12306: LD_ADDR_EXP 73
12310: PUSH
12311: LD_INT 1
12313: ST_TO_ADDR
// if p3 = 22 then
12314: LD_VAR 0 3
12318: PUSH
12319: LD_INT 22
12321: EQUAL
12322: IFFALSE 12332
// sTeleport := true ;
12324: LD_ADDR_EXP 76
12328: PUSH
12329: LD_INT 1
12331: ST_TO_ADDR
// if p3 = 23 then
12332: LD_VAR 0 3
12336: PUSH
12337: LD_INT 23
12339: EQUAL
12340: IFFALSE 12350
// sOilTower := true ;
12342: LD_ADDR_EXP 78
12346: PUSH
12347: LD_INT 1
12349: ST_TO_ADDR
// if p3 = 24 then
12350: LD_VAR 0 3
12354: PUSH
12355: LD_INT 24
12357: EQUAL
12358: IFFALSE 12368
// sShovel := true ;
12360: LD_ADDR_EXP 79
12364: PUSH
12365: LD_INT 1
12367: ST_TO_ADDR
// if p3 = 25 then
12368: LD_VAR 0 3
12372: PUSH
12373: LD_INT 25
12375: EQUAL
12376: IFFALSE 12386
// sSheik := true ;
12378: LD_ADDR_EXP 80
12382: PUSH
12383: LD_INT 1
12385: ST_TO_ADDR
// if p3 = 26 then
12386: LD_VAR 0 3
12390: PUSH
12391: LD_INT 26
12393: EQUAL
12394: IFFALSE 12404
// sEarthquake := true ;
12396: LD_ADDR_EXP 82
12400: PUSH
12401: LD_INT 1
12403: ST_TO_ADDR
// if p3 = 27 then
12404: LD_VAR 0 3
12408: PUSH
12409: LD_INT 27
12411: EQUAL
12412: IFFALSE 12422
// sAI := true ;
12414: LD_ADDR_EXP 83
12418: PUSH
12419: LD_INT 1
12421: ST_TO_ADDR
// if p3 = 28 then
12422: LD_VAR 0 3
12426: PUSH
12427: LD_INT 28
12429: EQUAL
12430: IFFALSE 12440
// sCargo := true ;
12432: LD_ADDR_EXP 86
12436: PUSH
12437: LD_INT 1
12439: ST_TO_ADDR
// if p3 = 29 then
12440: LD_VAR 0 3
12444: PUSH
12445: LD_INT 29
12447: EQUAL
12448: IFFALSE 12458
// sDLaser := true ;
12450: LD_ADDR_EXP 87
12454: PUSH
12455: LD_INT 1
12457: ST_TO_ADDR
// if p3 = 30 then
12458: LD_VAR 0 3
12462: PUSH
12463: LD_INT 30
12465: EQUAL
12466: IFFALSE 12476
// sExchange := true ;
12468: LD_ADDR_EXP 88
12472: PUSH
12473: LD_INT 1
12475: ST_TO_ADDR
// if p3 = 31 then
12476: LD_VAR 0 3
12480: PUSH
12481: LD_INT 31
12483: EQUAL
12484: IFFALSE 12494
// sFac := true ;
12486: LD_ADDR_EXP 89
12490: PUSH
12491: LD_INT 1
12493: ST_TO_ADDR
// if p3 = 32 then
12494: LD_VAR 0 3
12498: PUSH
12499: LD_INT 32
12501: EQUAL
12502: IFFALSE 12512
// sPower := true ;
12504: LD_ADDR_EXP 90
12508: PUSH
12509: LD_INT 1
12511: ST_TO_ADDR
// if p3 = 33 then
12512: LD_VAR 0 3
12516: PUSH
12517: LD_INT 33
12519: EQUAL
12520: IFFALSE 12530
// sRandom := true ;
12522: LD_ADDR_EXP 91
12526: PUSH
12527: LD_INT 1
12529: ST_TO_ADDR
// if p3 = 34 then
12530: LD_VAR 0 3
12534: PUSH
12535: LD_INT 34
12537: EQUAL
12538: IFFALSE 12548
// sShield := true ;
12540: LD_ADDR_EXP 92
12544: PUSH
12545: LD_INT 1
12547: ST_TO_ADDR
// if p3 = 35 then
12548: LD_VAR 0 3
12552: PUSH
12553: LD_INT 35
12555: EQUAL
12556: IFFALSE 12566
// sTime := true ;
12558: LD_ADDR_EXP 93
12562: PUSH
12563: LD_INT 1
12565: ST_TO_ADDR
// if p3 = 36 then
12566: LD_VAR 0 3
12570: PUSH
12571: LD_INT 36
12573: EQUAL
12574: IFFALSE 12584
// sTools := true ;
12576: LD_ADDR_EXP 94
12580: PUSH
12581: LD_INT 1
12583: ST_TO_ADDR
// if p3 = 101 then
12584: LD_VAR 0 3
12588: PUSH
12589: LD_INT 101
12591: EQUAL
12592: IFFALSE 12602
// sSold := true ;
12594: LD_ADDR_EXP 59
12598: PUSH
12599: LD_INT 1
12601: ST_TO_ADDR
// if p3 = 102 then
12602: LD_VAR 0 3
12606: PUSH
12607: LD_INT 102
12609: EQUAL
12610: IFFALSE 12620
// sDiff := true ;
12612: LD_ADDR_EXP 60
12616: PUSH
12617: LD_INT 1
12619: ST_TO_ADDR
// if p3 = 103 then
12620: LD_VAR 0 3
12624: PUSH
12625: LD_INT 103
12627: EQUAL
12628: IFFALSE 12638
// sFog := true ;
12630: LD_ADDR_EXP 63
12634: PUSH
12635: LD_INT 1
12637: ST_TO_ADDR
// if p3 = 104 then
12638: LD_VAR 0 3
12642: PUSH
12643: LD_INT 104
12645: EQUAL
12646: IFFALSE 12656
// sReset := true ;
12648: LD_ADDR_EXP 64
12652: PUSH
12653: LD_INT 1
12655: ST_TO_ADDR
// if p3 = 105 then
12656: LD_VAR 0 3
12660: PUSH
12661: LD_INT 105
12663: EQUAL
12664: IFFALSE 12674
// sSun := true ;
12666: LD_ADDR_EXP 65
12670: PUSH
12671: LD_INT 1
12673: ST_TO_ADDR
// if p3 = 106 then
12674: LD_VAR 0 3
12678: PUSH
12679: LD_INT 106
12681: EQUAL
12682: IFFALSE 12692
// sTiger := true ;
12684: LD_ADDR_EXP 61
12688: PUSH
12689: LD_INT 1
12691: ST_TO_ADDR
// if p3 = 107 then
12692: LD_VAR 0 3
12696: PUSH
12697: LD_INT 107
12699: EQUAL
12700: IFFALSE 12710
// sBomb := true ;
12702: LD_ADDR_EXP 62
12706: PUSH
12707: LD_INT 1
12709: ST_TO_ADDR
// if p3 = 108 then
12710: LD_VAR 0 3
12714: PUSH
12715: LD_INT 108
12717: EQUAL
12718: IFFALSE 12728
// sWound := true ;
12720: LD_ADDR_EXP 70
12724: PUSH
12725: LD_INT 1
12727: ST_TO_ADDR
// if p3 = 109 then
12728: LD_VAR 0 3
12732: PUSH
12733: LD_INT 109
12735: EQUAL
12736: IFFALSE 12746
// sBetray := true ;
12738: LD_ADDR_EXP 74
12742: PUSH
12743: LD_INT 1
12745: ST_TO_ADDR
// if p3 = 110 then
12746: LD_VAR 0 3
12750: PUSH
12751: LD_INT 110
12753: EQUAL
12754: IFFALSE 12764
// sContamin := true ;
12756: LD_ADDR_EXP 75
12760: PUSH
12761: LD_INT 1
12763: ST_TO_ADDR
// if p3 = 111 then
12764: LD_VAR 0 3
12768: PUSH
12769: LD_INT 111
12771: EQUAL
12772: IFFALSE 12782
// sOil := true ;
12774: LD_ADDR_EXP 77
12778: PUSH
12779: LD_INT 1
12781: ST_TO_ADDR
// if p3 = 112 then
12782: LD_VAR 0 3
12786: PUSH
12787: LD_INT 112
12789: EQUAL
12790: IFFALSE 12800
// sStu := true ;
12792: LD_ADDR_EXP 81
12796: PUSH
12797: LD_INT 1
12799: ST_TO_ADDR
// if p3 = 113 then
12800: LD_VAR 0 3
12804: PUSH
12805: LD_INT 113
12807: EQUAL
12808: IFFALSE 12818
// sBazooka := true ;
12810: LD_ADDR_EXP 84
12814: PUSH
12815: LD_INT 1
12817: ST_TO_ADDR
// if p3 = 114 then
12818: LD_VAR 0 3
12822: PUSH
12823: LD_INT 114
12825: EQUAL
12826: IFFALSE 12836
// sMortar := true ;
12828: LD_ADDR_EXP 85
12832: PUSH
12833: LD_INT 1
12835: ST_TO_ADDR
// if p3 = 115 then
12836: LD_VAR 0 3
12840: PUSH
12841: LD_INT 115
12843: EQUAL
12844: IFFALSE 12854
// sRanger := true ;
12846: LD_ADDR_EXP 95
12850: PUSH
12851: LD_INT 1
12853: ST_TO_ADDR
// end ; end ;
12854: PPOPN 6
12856: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
12857: LD_EXP 42
12861: PUSH
12862: LD_EXP 47
12866: AND
12867: IFFALSE 12991
12869: GO 12871
12871: DISABLE
12872: LD_INT 0
12874: PPUSH
12875: PPUSH
// begin enable ;
12876: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
12877: LD_ADDR_VAR 0 2
12881: PUSH
12882: LD_INT 22
12884: PUSH
12885: LD_OWVAR 2
12889: PUSH
12890: EMPTY
12891: LIST
12892: LIST
12893: PUSH
12894: LD_INT 2
12896: PUSH
12897: LD_INT 34
12899: PUSH
12900: LD_INT 7
12902: PUSH
12903: EMPTY
12904: LIST
12905: LIST
12906: PUSH
12907: LD_INT 34
12909: PUSH
12910: LD_INT 45
12912: PUSH
12913: EMPTY
12914: LIST
12915: LIST
12916: PUSH
12917: LD_INT 34
12919: PUSH
12920: LD_INT 28
12922: PUSH
12923: EMPTY
12924: LIST
12925: LIST
12926: PUSH
12927: LD_INT 34
12929: PUSH
12930: LD_INT 47
12932: PUSH
12933: EMPTY
12934: LIST
12935: LIST
12936: PUSH
12937: EMPTY
12938: LIST
12939: LIST
12940: LIST
12941: LIST
12942: LIST
12943: PUSH
12944: EMPTY
12945: LIST
12946: LIST
12947: PPUSH
12948: CALL_OW 69
12952: ST_TO_ADDR
// if not tmp then
12953: LD_VAR 0 2
12957: NOT
12958: IFFALSE 12962
// exit ;
12960: GO 12991
// for i in tmp do
12962: LD_ADDR_VAR 0 1
12966: PUSH
12967: LD_VAR 0 2
12971: PUSH
12972: FOR_IN
12973: IFFALSE 12989
// begin SetLives ( i , 0 ) ;
12975: LD_VAR 0 1
12979: PPUSH
12980: LD_INT 0
12982: PPUSH
12983: CALL_OW 234
// end ;
12987: GO 12972
12989: POP
12990: POP
// end ;
12991: PPOPN 2
12993: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
12994: LD_EXP 42
12998: PUSH
12999: LD_EXP 48
13003: AND
13004: IFFALSE 13088
13006: GO 13008
13008: DISABLE
13009: LD_INT 0
13011: PPUSH
13012: PPUSH
// begin enable ;
13013: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
13014: LD_ADDR_VAR 0 2
13018: PUSH
13019: LD_INT 22
13021: PUSH
13022: LD_OWVAR 2
13026: PUSH
13027: EMPTY
13028: LIST
13029: LIST
13030: PUSH
13031: LD_INT 32
13033: PUSH
13034: LD_INT 3
13036: PUSH
13037: EMPTY
13038: LIST
13039: LIST
13040: PUSH
13041: EMPTY
13042: LIST
13043: LIST
13044: PPUSH
13045: CALL_OW 69
13049: ST_TO_ADDR
// if not tmp then
13050: LD_VAR 0 2
13054: NOT
13055: IFFALSE 13059
// exit ;
13057: GO 13088
// for i in tmp do
13059: LD_ADDR_VAR 0 1
13063: PUSH
13064: LD_VAR 0 2
13068: PUSH
13069: FOR_IN
13070: IFFALSE 13086
// begin SetLives ( i , 0 ) ;
13072: LD_VAR 0 1
13076: PPUSH
13077: LD_INT 0
13079: PPUSH
13080: CALL_OW 234
// end ;
13084: GO 13069
13086: POP
13087: POP
// end ;
13088: PPOPN 2
13090: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
13091: LD_EXP 42
13095: PUSH
13096: LD_EXP 45
13100: AND
13101: IFFALSE 13194
13103: GO 13105
13105: DISABLE
13106: LD_INT 0
13108: PPUSH
// begin enable ;
13109: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
13110: LD_ADDR_VAR 0 1
13114: PUSH
13115: LD_INT 22
13117: PUSH
13118: LD_OWVAR 2
13122: PUSH
13123: EMPTY
13124: LIST
13125: LIST
13126: PUSH
13127: LD_INT 2
13129: PUSH
13130: LD_INT 25
13132: PUSH
13133: LD_INT 5
13135: PUSH
13136: EMPTY
13137: LIST
13138: LIST
13139: PUSH
13140: LD_INT 25
13142: PUSH
13143: LD_INT 9
13145: PUSH
13146: EMPTY
13147: LIST
13148: LIST
13149: PUSH
13150: LD_INT 25
13152: PUSH
13153: LD_INT 8
13155: PUSH
13156: EMPTY
13157: LIST
13158: LIST
13159: PUSH
13160: EMPTY
13161: LIST
13162: LIST
13163: LIST
13164: LIST
13165: PUSH
13166: EMPTY
13167: LIST
13168: LIST
13169: PPUSH
13170: CALL_OW 69
13174: PUSH
13175: FOR_IN
13176: IFFALSE 13192
// begin SetClass ( i , 1 ) ;
13178: LD_VAR 0 1
13182: PPUSH
13183: LD_INT 1
13185: PPUSH
13186: CALL_OW 336
// end ;
13190: GO 13175
13192: POP
13193: POP
// end ;
13194: PPOPN 1
13196: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
13197: LD_EXP 42
13201: PUSH
13202: LD_EXP 46
13206: AND
13207: PUSH
13208: LD_OWVAR 65
13212: PUSH
13213: LD_INT 7
13215: LESS
13216: AND
13217: IFFALSE 13231
13219: GO 13221
13221: DISABLE
// begin enable ;
13222: ENABLE
// game_speed := 7 ;
13223: LD_ADDR_OWVAR 65
13227: PUSH
13228: LD_INT 7
13230: ST_TO_ADDR
// end ;
13231: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
13232: LD_EXP 42
13236: PUSH
13237: LD_EXP 49
13241: AND
13242: IFFALSE 13444
13244: GO 13246
13246: DISABLE
13247: LD_INT 0
13249: PPUSH
13250: PPUSH
13251: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
13252: LD_ADDR_VAR 0 3
13256: PUSH
13257: LD_INT 81
13259: PUSH
13260: LD_OWVAR 2
13264: PUSH
13265: EMPTY
13266: LIST
13267: LIST
13268: PUSH
13269: LD_INT 21
13271: PUSH
13272: LD_INT 1
13274: PUSH
13275: EMPTY
13276: LIST
13277: LIST
13278: PUSH
13279: EMPTY
13280: LIST
13281: LIST
13282: PPUSH
13283: CALL_OW 69
13287: ST_TO_ADDR
// if not tmp then
13288: LD_VAR 0 3
13292: NOT
13293: IFFALSE 13297
// exit ;
13295: GO 13444
// if tmp > 5 then
13297: LD_VAR 0 3
13301: PUSH
13302: LD_INT 5
13304: GREATER
13305: IFFALSE 13317
// k := 5 else
13307: LD_ADDR_VAR 0 2
13311: PUSH
13312: LD_INT 5
13314: ST_TO_ADDR
13315: GO 13327
// k := tmp ;
13317: LD_ADDR_VAR 0 2
13321: PUSH
13322: LD_VAR 0 3
13326: ST_TO_ADDR
// for i := 1 to k do
13327: LD_ADDR_VAR 0 1
13331: PUSH
13332: DOUBLE
13333: LD_INT 1
13335: DEC
13336: ST_TO_ADDR
13337: LD_VAR 0 2
13341: PUSH
13342: FOR_TO
13343: IFFALSE 13442
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
13345: LD_VAR 0 3
13349: PUSH
13350: LD_VAR 0 1
13354: ARRAY
13355: PPUSH
13356: LD_VAR 0 1
13360: PUSH
13361: LD_INT 4
13363: MOD
13364: PUSH
13365: LD_INT 1
13367: PLUS
13368: PPUSH
13369: CALL_OW 259
13373: PUSH
13374: LD_INT 10
13376: LESS
13377: IFFALSE 13440
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
13379: LD_VAR 0 3
13383: PUSH
13384: LD_VAR 0 1
13388: ARRAY
13389: PPUSH
13390: LD_VAR 0 1
13394: PUSH
13395: LD_INT 4
13397: MOD
13398: PUSH
13399: LD_INT 1
13401: PLUS
13402: PPUSH
13403: LD_VAR 0 3
13407: PUSH
13408: LD_VAR 0 1
13412: ARRAY
13413: PPUSH
13414: LD_VAR 0 1
13418: PUSH
13419: LD_INT 4
13421: MOD
13422: PUSH
13423: LD_INT 1
13425: PLUS
13426: PPUSH
13427: CALL_OW 259
13431: PUSH
13432: LD_INT 1
13434: PLUS
13435: PPUSH
13436: CALL_OW 237
13440: GO 13342
13442: POP
13443: POP
// end ;
13444: PPOPN 3
13446: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
13447: LD_EXP 42
13451: PUSH
13452: LD_EXP 50
13456: AND
13457: IFFALSE 13477
13459: GO 13461
13461: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
13462: LD_INT 4
13464: PPUSH
13465: LD_OWVAR 2
13469: PPUSH
13470: LD_INT 0
13472: PPUSH
13473: CALL_OW 324
13477: END
// every 0 0$1 trigger StreamModeActive and sShovel do
13478: LD_EXP 42
13482: PUSH
13483: LD_EXP 79
13487: AND
13488: IFFALSE 13508
13490: GO 13492
13492: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
13493: LD_INT 19
13495: PPUSH
13496: LD_OWVAR 2
13500: PPUSH
13501: LD_INT 0
13503: PPUSH
13504: CALL_OW 324
13508: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
13509: LD_EXP 42
13513: PUSH
13514: LD_EXP 51
13518: AND
13519: IFFALSE 13621
13521: GO 13523
13523: DISABLE
13524: LD_INT 0
13526: PPUSH
13527: PPUSH
// begin enable ;
13528: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
13529: LD_ADDR_VAR 0 2
13533: PUSH
13534: LD_INT 22
13536: PUSH
13537: LD_OWVAR 2
13541: PUSH
13542: EMPTY
13543: LIST
13544: LIST
13545: PUSH
13546: LD_INT 2
13548: PUSH
13549: LD_INT 34
13551: PUSH
13552: LD_INT 11
13554: PUSH
13555: EMPTY
13556: LIST
13557: LIST
13558: PUSH
13559: LD_INT 34
13561: PUSH
13562: LD_INT 30
13564: PUSH
13565: EMPTY
13566: LIST
13567: LIST
13568: PUSH
13569: EMPTY
13570: LIST
13571: LIST
13572: LIST
13573: PUSH
13574: EMPTY
13575: LIST
13576: LIST
13577: PPUSH
13578: CALL_OW 69
13582: ST_TO_ADDR
// if not tmp then
13583: LD_VAR 0 2
13587: NOT
13588: IFFALSE 13592
// exit ;
13590: GO 13621
// for i in tmp do
13592: LD_ADDR_VAR 0 1
13596: PUSH
13597: LD_VAR 0 2
13601: PUSH
13602: FOR_IN
13603: IFFALSE 13619
// begin SetLives ( i , 0 ) ;
13605: LD_VAR 0 1
13609: PPUSH
13610: LD_INT 0
13612: PPUSH
13613: CALL_OW 234
// end ;
13617: GO 13602
13619: POP
13620: POP
// end ;
13621: PPOPN 2
13623: END
// every 0 0$1 trigger StreamModeActive and sBunker do
13624: LD_EXP 42
13628: PUSH
13629: LD_EXP 52
13633: AND
13634: IFFALSE 13654
13636: GO 13638
13638: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
13639: LD_INT 32
13641: PPUSH
13642: LD_OWVAR 2
13646: PPUSH
13647: LD_INT 0
13649: PPUSH
13650: CALL_OW 324
13654: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
13655: LD_EXP 42
13659: PUSH
13660: LD_EXP 53
13664: AND
13665: IFFALSE 13846
13667: GO 13669
13669: DISABLE
13670: LD_INT 0
13672: PPUSH
13673: PPUSH
13674: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
13675: LD_ADDR_VAR 0 2
13679: PUSH
13680: LD_INT 22
13682: PUSH
13683: LD_OWVAR 2
13687: PUSH
13688: EMPTY
13689: LIST
13690: LIST
13691: PUSH
13692: LD_INT 33
13694: PUSH
13695: LD_INT 3
13697: PUSH
13698: EMPTY
13699: LIST
13700: LIST
13701: PUSH
13702: EMPTY
13703: LIST
13704: LIST
13705: PPUSH
13706: CALL_OW 69
13710: ST_TO_ADDR
// if not tmp then
13711: LD_VAR 0 2
13715: NOT
13716: IFFALSE 13720
// exit ;
13718: GO 13846
// side := 0 ;
13720: LD_ADDR_VAR 0 3
13724: PUSH
13725: LD_INT 0
13727: ST_TO_ADDR
// for i := 1 to 8 do
13728: LD_ADDR_VAR 0 1
13732: PUSH
13733: DOUBLE
13734: LD_INT 1
13736: DEC
13737: ST_TO_ADDR
13738: LD_INT 8
13740: PUSH
13741: FOR_TO
13742: IFFALSE 13790
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
13744: LD_OWVAR 2
13748: PUSH
13749: LD_VAR 0 1
13753: NONEQUAL
13754: PUSH
13755: LD_OWVAR 2
13759: PPUSH
13760: LD_VAR 0 1
13764: PPUSH
13765: CALL_OW 81
13769: PUSH
13770: LD_INT 2
13772: EQUAL
13773: AND
13774: IFFALSE 13788
// begin side := i ;
13776: LD_ADDR_VAR 0 3
13780: PUSH
13781: LD_VAR 0 1
13785: ST_TO_ADDR
// break ;
13786: GO 13790
// end ;
13788: GO 13741
13790: POP
13791: POP
// if not side then
13792: LD_VAR 0 3
13796: NOT
13797: IFFALSE 13801
// exit ;
13799: GO 13846
// for i := 1 to tmp do
13801: LD_ADDR_VAR 0 1
13805: PUSH
13806: DOUBLE
13807: LD_INT 1
13809: DEC
13810: ST_TO_ADDR
13811: LD_VAR 0 2
13815: PUSH
13816: FOR_TO
13817: IFFALSE 13844
// if Prob ( 60 ) then
13819: LD_INT 60
13821: PPUSH
13822: CALL_OW 13
13826: IFFALSE 13842
// SetSide ( i , side ) ;
13828: LD_VAR 0 1
13832: PPUSH
13833: LD_VAR 0 3
13837: PPUSH
13838: CALL_OW 235
13842: GO 13816
13844: POP
13845: POP
// end ;
13846: PPOPN 3
13848: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
13849: LD_EXP 42
13853: PUSH
13854: LD_EXP 55
13858: AND
13859: IFFALSE 13978
13861: GO 13863
13863: DISABLE
13864: LD_INT 0
13866: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
13867: LD_ADDR_VAR 0 1
13871: PUSH
13872: LD_INT 22
13874: PUSH
13875: LD_OWVAR 2
13879: PUSH
13880: EMPTY
13881: LIST
13882: LIST
13883: PUSH
13884: LD_INT 21
13886: PUSH
13887: LD_INT 1
13889: PUSH
13890: EMPTY
13891: LIST
13892: LIST
13893: PUSH
13894: LD_INT 3
13896: PUSH
13897: LD_INT 23
13899: PUSH
13900: LD_INT 0
13902: PUSH
13903: EMPTY
13904: LIST
13905: LIST
13906: PUSH
13907: EMPTY
13908: LIST
13909: LIST
13910: PUSH
13911: EMPTY
13912: LIST
13913: LIST
13914: LIST
13915: PPUSH
13916: CALL_OW 69
13920: PUSH
13921: FOR_IN
13922: IFFALSE 13976
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
13924: LD_VAR 0 1
13928: PPUSH
13929: CALL_OW 257
13933: PUSH
13934: LD_INT 1
13936: PUSH
13937: LD_INT 2
13939: PUSH
13940: LD_INT 3
13942: PUSH
13943: LD_INT 4
13945: PUSH
13946: EMPTY
13947: LIST
13948: LIST
13949: LIST
13950: LIST
13951: IN
13952: IFFALSE 13974
// SetClass ( un , rand ( 1 , 4 ) ) ;
13954: LD_VAR 0 1
13958: PPUSH
13959: LD_INT 1
13961: PPUSH
13962: LD_INT 4
13964: PPUSH
13965: CALL_OW 12
13969: PPUSH
13970: CALL_OW 336
13974: GO 13921
13976: POP
13977: POP
// end ;
13978: PPOPN 1
13980: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
13981: LD_EXP 42
13985: PUSH
13986: LD_EXP 54
13990: AND
13991: IFFALSE 14070
13993: GO 13995
13995: DISABLE
13996: LD_INT 0
13998: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
13999: LD_ADDR_VAR 0 1
14003: PUSH
14004: LD_INT 22
14006: PUSH
14007: LD_OWVAR 2
14011: PUSH
14012: EMPTY
14013: LIST
14014: LIST
14015: PUSH
14016: LD_INT 21
14018: PUSH
14019: LD_INT 3
14021: PUSH
14022: EMPTY
14023: LIST
14024: LIST
14025: PUSH
14026: EMPTY
14027: LIST
14028: LIST
14029: PPUSH
14030: CALL_OW 69
14034: ST_TO_ADDR
// if not tmp then
14035: LD_VAR 0 1
14039: NOT
14040: IFFALSE 14044
// exit ;
14042: GO 14070
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
14044: LD_VAR 0 1
14048: PUSH
14049: LD_INT 1
14051: PPUSH
14052: LD_VAR 0 1
14056: PPUSH
14057: CALL_OW 12
14061: ARRAY
14062: PPUSH
14063: LD_INT 100
14065: PPUSH
14066: CALL_OW 234
// end ;
14070: PPOPN 1
14072: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
14073: LD_EXP 42
14077: PUSH
14078: LD_EXP 56
14082: AND
14083: IFFALSE 14181
14085: GO 14087
14087: DISABLE
14088: LD_INT 0
14090: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
14091: LD_ADDR_VAR 0 1
14095: PUSH
14096: LD_INT 22
14098: PUSH
14099: LD_OWVAR 2
14103: PUSH
14104: EMPTY
14105: LIST
14106: LIST
14107: PUSH
14108: LD_INT 21
14110: PUSH
14111: LD_INT 1
14113: PUSH
14114: EMPTY
14115: LIST
14116: LIST
14117: PUSH
14118: EMPTY
14119: LIST
14120: LIST
14121: PPUSH
14122: CALL_OW 69
14126: ST_TO_ADDR
// if not tmp then
14127: LD_VAR 0 1
14131: NOT
14132: IFFALSE 14136
// exit ;
14134: GO 14181
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
14136: LD_VAR 0 1
14140: PUSH
14141: LD_INT 1
14143: PPUSH
14144: LD_VAR 0 1
14148: PPUSH
14149: CALL_OW 12
14153: ARRAY
14154: PPUSH
14155: LD_INT 1
14157: PPUSH
14158: LD_INT 4
14160: PPUSH
14161: CALL_OW 12
14165: PPUSH
14166: LD_INT 3000
14168: PPUSH
14169: LD_INT 9000
14171: PPUSH
14172: CALL_OW 12
14176: PPUSH
14177: CALL_OW 492
// end ;
14181: PPOPN 1
14183: END
// every 0 0$1 trigger StreamModeActive and sDepot do
14184: LD_EXP 42
14188: PUSH
14189: LD_EXP 57
14193: AND
14194: IFFALSE 14214
14196: GO 14198
14198: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
14199: LD_INT 1
14201: PPUSH
14202: LD_OWVAR 2
14206: PPUSH
14207: LD_INT 0
14209: PPUSH
14210: CALL_OW 324
14214: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
14215: LD_EXP 42
14219: PUSH
14220: LD_EXP 58
14224: AND
14225: IFFALSE 14308
14227: GO 14229
14229: DISABLE
14230: LD_INT 0
14232: PPUSH
14233: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
14234: LD_ADDR_VAR 0 2
14238: PUSH
14239: LD_INT 22
14241: PUSH
14242: LD_OWVAR 2
14246: PUSH
14247: EMPTY
14248: LIST
14249: LIST
14250: PUSH
14251: LD_INT 21
14253: PUSH
14254: LD_INT 3
14256: PUSH
14257: EMPTY
14258: LIST
14259: LIST
14260: PUSH
14261: EMPTY
14262: LIST
14263: LIST
14264: PPUSH
14265: CALL_OW 69
14269: ST_TO_ADDR
// if not tmp then
14270: LD_VAR 0 2
14274: NOT
14275: IFFALSE 14279
// exit ;
14277: GO 14308
// for i in tmp do
14279: LD_ADDR_VAR 0 1
14283: PUSH
14284: LD_VAR 0 2
14288: PUSH
14289: FOR_IN
14290: IFFALSE 14306
// SetBLevel ( i , 10 ) ;
14292: LD_VAR 0 1
14296: PPUSH
14297: LD_INT 10
14299: PPUSH
14300: CALL_OW 241
14304: GO 14289
14306: POP
14307: POP
// end ;
14308: PPOPN 2
14310: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
14311: LD_EXP 42
14315: PUSH
14316: LD_EXP 59
14320: AND
14321: IFFALSE 14432
14323: GO 14325
14325: DISABLE
14326: LD_INT 0
14328: PPUSH
14329: PPUSH
14330: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
14331: LD_ADDR_VAR 0 3
14335: PUSH
14336: LD_INT 22
14338: PUSH
14339: LD_OWVAR 2
14343: PUSH
14344: EMPTY
14345: LIST
14346: LIST
14347: PUSH
14348: LD_INT 25
14350: PUSH
14351: LD_INT 1
14353: PUSH
14354: EMPTY
14355: LIST
14356: LIST
14357: PUSH
14358: EMPTY
14359: LIST
14360: LIST
14361: PPUSH
14362: CALL_OW 69
14366: ST_TO_ADDR
// if not tmp then
14367: LD_VAR 0 3
14371: NOT
14372: IFFALSE 14376
// exit ;
14374: GO 14432
// un := tmp [ rand ( 1 , tmp ) ] ;
14376: LD_ADDR_VAR 0 2
14380: PUSH
14381: LD_VAR 0 3
14385: PUSH
14386: LD_INT 1
14388: PPUSH
14389: LD_VAR 0 3
14393: PPUSH
14394: CALL_OW 12
14398: ARRAY
14399: ST_TO_ADDR
// if Crawls ( un ) then
14400: LD_VAR 0 2
14404: PPUSH
14405: CALL_OW 318
14409: IFFALSE 14420
// ComWalk ( un ) ;
14411: LD_VAR 0 2
14415: PPUSH
14416: CALL_OW 138
// SetClass ( un , class_sniper ) ;
14420: LD_VAR 0 2
14424: PPUSH
14425: LD_INT 5
14427: PPUSH
14428: CALL_OW 336
// end ;
14432: PPOPN 3
14434: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
14435: LD_EXP 42
14439: PUSH
14440: LD_EXP 60
14444: AND
14445: PUSH
14446: LD_OWVAR 67
14450: PUSH
14451: LD_INT 3
14453: LESS
14454: AND
14455: IFFALSE 14474
14457: GO 14459
14459: DISABLE
// Difficulty := Difficulty + 1 ;
14460: LD_ADDR_OWVAR 67
14464: PUSH
14465: LD_OWVAR 67
14469: PUSH
14470: LD_INT 1
14472: PLUS
14473: ST_TO_ADDR
14474: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
14475: LD_EXP 42
14479: PUSH
14480: LD_EXP 61
14484: AND
14485: IFFALSE 14588
14487: GO 14489
14489: DISABLE
14490: LD_INT 0
14492: PPUSH
// begin for i := 1 to 5 do
14493: LD_ADDR_VAR 0 1
14497: PUSH
14498: DOUBLE
14499: LD_INT 1
14501: DEC
14502: ST_TO_ADDR
14503: LD_INT 5
14505: PUSH
14506: FOR_TO
14507: IFFALSE 14586
// begin uc_nation := nation_nature ;
14509: LD_ADDR_OWVAR 21
14513: PUSH
14514: LD_INT 0
14516: ST_TO_ADDR
// uc_side := 0 ;
14517: LD_ADDR_OWVAR 20
14521: PUSH
14522: LD_INT 0
14524: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
14525: LD_ADDR_OWVAR 29
14529: PUSH
14530: LD_INT 12
14532: PUSH
14533: LD_INT 12
14535: PUSH
14536: EMPTY
14537: LIST
14538: LIST
14539: ST_TO_ADDR
// hc_agressivity := 20 ;
14540: LD_ADDR_OWVAR 35
14544: PUSH
14545: LD_INT 20
14547: ST_TO_ADDR
// hc_class := class_tiger ;
14548: LD_ADDR_OWVAR 28
14552: PUSH
14553: LD_INT 14
14555: ST_TO_ADDR
// hc_gallery :=  ;
14556: LD_ADDR_OWVAR 33
14560: PUSH
14561: LD_STRING 
14563: ST_TO_ADDR
// hc_name :=  ;
14564: LD_ADDR_OWVAR 26
14568: PUSH
14569: LD_STRING 
14571: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
14572: CALL_OW 44
14576: PPUSH
14577: LD_INT 0
14579: PPUSH
14580: CALL_OW 51
// end ;
14584: GO 14506
14586: POP
14587: POP
// end ;
14588: PPOPN 1
14590: END
// every 0 0$1 trigger StreamModeActive and sBomb do
14591: LD_EXP 42
14595: PUSH
14596: LD_EXP 62
14600: AND
14601: IFFALSE 14610
14603: GO 14605
14605: DISABLE
// StreamSibBomb ;
14606: CALL 14611 0 0
14610: END
// export function StreamSibBomb ; var i , x , y ; begin
14611: LD_INT 0
14613: PPUSH
14614: PPUSH
14615: PPUSH
14616: PPUSH
// result := false ;
14617: LD_ADDR_VAR 0 1
14621: PUSH
14622: LD_INT 0
14624: ST_TO_ADDR
// for i := 1 to 16 do
14625: LD_ADDR_VAR 0 2
14629: PUSH
14630: DOUBLE
14631: LD_INT 1
14633: DEC
14634: ST_TO_ADDR
14635: LD_INT 16
14637: PUSH
14638: FOR_TO
14639: IFFALSE 14838
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
14641: LD_ADDR_VAR 0 3
14645: PUSH
14646: LD_INT 10
14648: PUSH
14649: LD_INT 20
14651: PUSH
14652: LD_INT 30
14654: PUSH
14655: LD_INT 40
14657: PUSH
14658: LD_INT 50
14660: PUSH
14661: LD_INT 60
14663: PUSH
14664: LD_INT 70
14666: PUSH
14667: LD_INT 80
14669: PUSH
14670: LD_INT 90
14672: PUSH
14673: LD_INT 100
14675: PUSH
14676: LD_INT 110
14678: PUSH
14679: LD_INT 120
14681: PUSH
14682: LD_INT 130
14684: PUSH
14685: LD_INT 140
14687: PUSH
14688: LD_INT 150
14690: PUSH
14691: EMPTY
14692: LIST
14693: LIST
14694: LIST
14695: LIST
14696: LIST
14697: LIST
14698: LIST
14699: LIST
14700: LIST
14701: LIST
14702: LIST
14703: LIST
14704: LIST
14705: LIST
14706: LIST
14707: PUSH
14708: LD_INT 1
14710: PPUSH
14711: LD_INT 15
14713: PPUSH
14714: CALL_OW 12
14718: ARRAY
14719: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
14720: LD_ADDR_VAR 0 4
14724: PUSH
14725: LD_INT 10
14727: PUSH
14728: LD_INT 20
14730: PUSH
14731: LD_INT 30
14733: PUSH
14734: LD_INT 40
14736: PUSH
14737: LD_INT 50
14739: PUSH
14740: LD_INT 60
14742: PUSH
14743: LD_INT 70
14745: PUSH
14746: LD_INT 80
14748: PUSH
14749: LD_INT 90
14751: PUSH
14752: LD_INT 100
14754: PUSH
14755: LD_INT 110
14757: PUSH
14758: LD_INT 120
14760: PUSH
14761: LD_INT 130
14763: PUSH
14764: LD_INT 140
14766: PUSH
14767: LD_INT 150
14769: PUSH
14770: EMPTY
14771: LIST
14772: LIST
14773: LIST
14774: LIST
14775: LIST
14776: LIST
14777: LIST
14778: LIST
14779: LIST
14780: LIST
14781: LIST
14782: LIST
14783: LIST
14784: LIST
14785: LIST
14786: PUSH
14787: LD_INT 1
14789: PPUSH
14790: LD_INT 15
14792: PPUSH
14793: CALL_OW 12
14797: ARRAY
14798: ST_TO_ADDR
// if ValidHex ( x , y ) then
14799: LD_VAR 0 3
14803: PPUSH
14804: LD_VAR 0 4
14808: PPUSH
14809: CALL_OW 488
14813: IFFALSE 14836
// begin result := [ x , y ] ;
14815: LD_ADDR_VAR 0 1
14819: PUSH
14820: LD_VAR 0 3
14824: PUSH
14825: LD_VAR 0 4
14829: PUSH
14830: EMPTY
14831: LIST
14832: LIST
14833: ST_TO_ADDR
// break ;
14834: GO 14838
// end ; end ;
14836: GO 14638
14838: POP
14839: POP
// if result then
14840: LD_VAR 0 1
14844: IFFALSE 14904
// begin ToLua ( playSibBomb() ) ;
14846: LD_STRING playSibBomb()
14848: PPUSH
14849: CALL_OW 559
// wait ( 0 0$14 ) ;
14853: LD_INT 490
14855: PPUSH
14856: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
14860: LD_VAR 0 1
14864: PUSH
14865: LD_INT 1
14867: ARRAY
14868: PPUSH
14869: LD_VAR 0 1
14873: PUSH
14874: LD_INT 2
14876: ARRAY
14877: PPUSH
14878: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
14882: LD_VAR 0 1
14886: PUSH
14887: LD_INT 1
14889: ARRAY
14890: PPUSH
14891: LD_VAR 0 1
14895: PUSH
14896: LD_INT 2
14898: ARRAY
14899: PPUSH
14900: CALL_OW 429
// end ; end ;
14904: LD_VAR 0 1
14908: RET
// every 0 0$1 trigger StreamModeActive and sReset do
14909: LD_EXP 42
14913: PUSH
14914: LD_EXP 64
14918: AND
14919: IFFALSE 14931
14921: GO 14923
14923: DISABLE
// YouLost (  ) ;
14924: LD_STRING 
14926: PPUSH
14927: CALL_OW 104
14931: END
// every 0 0$1 trigger StreamModeActive and sFog do
14932: LD_EXP 42
14936: PUSH
14937: LD_EXP 63
14941: AND
14942: IFFALSE 14956
14944: GO 14946
14946: DISABLE
// FogOff ( your_side ) ;
14947: LD_OWVAR 2
14951: PPUSH
14952: CALL_OW 344
14956: END
// every 0 0$1 trigger StreamModeActive and sSun do
14957: LD_EXP 42
14961: PUSH
14962: LD_EXP 65
14966: AND
14967: IFFALSE 14995
14969: GO 14971
14971: DISABLE
// begin solar_recharge_percent := 0 ;
14972: LD_ADDR_OWVAR 79
14976: PUSH
14977: LD_INT 0
14979: ST_TO_ADDR
// wait ( 5 5$00 ) ;
14980: LD_INT 10500
14982: PPUSH
14983: CALL_OW 67
// solar_recharge_percent := 100 ;
14987: LD_ADDR_OWVAR 79
14991: PUSH
14992: LD_INT 100
14994: ST_TO_ADDR
// end ;
14995: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
14996: LD_EXP 42
15000: PUSH
15001: LD_EXP 66
15005: AND
15006: IFFALSE 15245
15008: GO 15010
15010: DISABLE
15011: LD_INT 0
15013: PPUSH
15014: PPUSH
15015: PPUSH
// begin tmp := [ ] ;
15016: LD_ADDR_VAR 0 3
15020: PUSH
15021: EMPTY
15022: ST_TO_ADDR
// for i := 1 to 6 do
15023: LD_ADDR_VAR 0 1
15027: PUSH
15028: DOUBLE
15029: LD_INT 1
15031: DEC
15032: ST_TO_ADDR
15033: LD_INT 6
15035: PUSH
15036: FOR_TO
15037: IFFALSE 15142
// begin uc_nation := nation_nature ;
15039: LD_ADDR_OWVAR 21
15043: PUSH
15044: LD_INT 0
15046: ST_TO_ADDR
// uc_side := 0 ;
15047: LD_ADDR_OWVAR 20
15051: PUSH
15052: LD_INT 0
15054: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
15055: LD_ADDR_OWVAR 29
15059: PUSH
15060: LD_INT 12
15062: PUSH
15063: LD_INT 12
15065: PUSH
15066: EMPTY
15067: LIST
15068: LIST
15069: ST_TO_ADDR
// hc_agressivity := 20 ;
15070: LD_ADDR_OWVAR 35
15074: PUSH
15075: LD_INT 20
15077: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
15078: LD_ADDR_OWVAR 28
15082: PUSH
15083: LD_INT 17
15085: ST_TO_ADDR
// hc_gallery :=  ;
15086: LD_ADDR_OWVAR 33
15090: PUSH
15091: LD_STRING 
15093: ST_TO_ADDR
// hc_name :=  ;
15094: LD_ADDR_OWVAR 26
15098: PUSH
15099: LD_STRING 
15101: ST_TO_ADDR
// un := CreateHuman ;
15102: LD_ADDR_VAR 0 2
15106: PUSH
15107: CALL_OW 44
15111: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
15112: LD_VAR 0 2
15116: PPUSH
15117: LD_INT 1
15119: PPUSH
15120: CALL_OW 51
// tmp := tmp ^ un ;
15124: LD_ADDR_VAR 0 3
15128: PUSH
15129: LD_VAR 0 3
15133: PUSH
15134: LD_VAR 0 2
15138: ADD
15139: ST_TO_ADDR
// end ;
15140: GO 15036
15142: POP
15143: POP
// repeat wait ( 0 0$1 ) ;
15144: LD_INT 35
15146: PPUSH
15147: CALL_OW 67
// for un in tmp do
15151: LD_ADDR_VAR 0 2
15155: PUSH
15156: LD_VAR 0 3
15160: PUSH
15161: FOR_IN
15162: IFFALSE 15236
// begin if IsDead ( un ) then
15164: LD_VAR 0 2
15168: PPUSH
15169: CALL_OW 301
15173: IFFALSE 15193
// begin tmp := tmp diff un ;
15175: LD_ADDR_VAR 0 3
15179: PUSH
15180: LD_VAR 0 3
15184: PUSH
15185: LD_VAR 0 2
15189: DIFF
15190: ST_TO_ADDR
// continue ;
15191: GO 15161
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
15193: LD_VAR 0 2
15197: PPUSH
15198: LD_INT 3
15200: PUSH
15201: LD_INT 22
15203: PUSH
15204: LD_INT 0
15206: PUSH
15207: EMPTY
15208: LIST
15209: LIST
15210: PUSH
15211: EMPTY
15212: LIST
15213: LIST
15214: PPUSH
15215: CALL_OW 69
15219: PPUSH
15220: LD_VAR 0 2
15224: PPUSH
15225: CALL_OW 74
15229: PPUSH
15230: CALL_OW 115
// end ;
15234: GO 15161
15236: POP
15237: POP
// until not tmp ;
15238: LD_VAR 0 3
15242: NOT
15243: IFFALSE 15144
// end ;
15245: PPOPN 3
15247: END
// every 0 0$1 trigger StreamModeActive and sTroll do
15248: LD_EXP 42
15252: PUSH
15253: LD_EXP 67
15257: AND
15258: IFFALSE 15312
15260: GO 15262
15262: DISABLE
// begin ToLua ( displayTroll(); ) ;
15263: LD_STRING displayTroll();
15265: PPUSH
15266: CALL_OW 559
// wait ( 3 3$00 ) ;
15270: LD_INT 6300
15272: PPUSH
15273: CALL_OW 67
// ToLua ( hideTroll(); ) ;
15277: LD_STRING hideTroll();
15279: PPUSH
15280: CALL_OW 559
// wait ( 1 1$00 ) ;
15284: LD_INT 2100
15286: PPUSH
15287: CALL_OW 67
// ToLua ( displayTroll(); ) ;
15291: LD_STRING displayTroll();
15293: PPUSH
15294: CALL_OW 559
// wait ( 1 1$00 ) ;
15298: LD_INT 2100
15300: PPUSH
15301: CALL_OW 67
// ToLua ( hideTroll(); ) ;
15305: LD_STRING hideTroll();
15307: PPUSH
15308: CALL_OW 559
// end ;
15312: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
15313: LD_EXP 42
15317: PUSH
15318: LD_EXP 68
15322: AND
15323: IFFALSE 15386
15325: GO 15327
15327: DISABLE
15328: LD_INT 0
15330: PPUSH
// begin p := 0 ;
15331: LD_ADDR_VAR 0 1
15335: PUSH
15336: LD_INT 0
15338: ST_TO_ADDR
// repeat game_speed := 1 ;
15339: LD_ADDR_OWVAR 65
15343: PUSH
15344: LD_INT 1
15346: ST_TO_ADDR
// wait ( 0 0$1 ) ;
15347: LD_INT 35
15349: PPUSH
15350: CALL_OW 67
// p := p + 1 ;
15354: LD_ADDR_VAR 0 1
15358: PUSH
15359: LD_VAR 0 1
15363: PUSH
15364: LD_INT 1
15366: PLUS
15367: ST_TO_ADDR
// until p >= 60 ;
15368: LD_VAR 0 1
15372: PUSH
15373: LD_INT 60
15375: GREATEREQUAL
15376: IFFALSE 15339
// game_speed := 4 ;
15378: LD_ADDR_OWVAR 65
15382: PUSH
15383: LD_INT 4
15385: ST_TO_ADDR
// end ;
15386: PPOPN 1
15388: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
15389: LD_EXP 42
15393: PUSH
15394: LD_EXP 69
15398: AND
15399: IFFALSE 15545
15401: GO 15403
15403: DISABLE
15404: LD_INT 0
15406: PPUSH
15407: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
15408: LD_ADDR_VAR 0 1
15412: PUSH
15413: LD_INT 22
15415: PUSH
15416: LD_OWVAR 2
15420: PUSH
15421: EMPTY
15422: LIST
15423: LIST
15424: PUSH
15425: LD_INT 2
15427: PUSH
15428: LD_INT 30
15430: PUSH
15431: LD_INT 0
15433: PUSH
15434: EMPTY
15435: LIST
15436: LIST
15437: PUSH
15438: LD_INT 30
15440: PUSH
15441: LD_INT 1
15443: PUSH
15444: EMPTY
15445: LIST
15446: LIST
15447: PUSH
15448: EMPTY
15449: LIST
15450: LIST
15451: LIST
15452: PUSH
15453: EMPTY
15454: LIST
15455: LIST
15456: PPUSH
15457: CALL_OW 69
15461: ST_TO_ADDR
// if not depot then
15462: LD_VAR 0 1
15466: NOT
15467: IFFALSE 15471
// exit ;
15469: GO 15545
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
15471: LD_ADDR_VAR 0 2
15475: PUSH
15476: LD_VAR 0 1
15480: PUSH
15481: LD_INT 1
15483: PPUSH
15484: LD_VAR 0 1
15488: PPUSH
15489: CALL_OW 12
15493: ARRAY
15494: PPUSH
15495: CALL_OW 274
15499: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
15500: LD_VAR 0 2
15504: PPUSH
15505: LD_INT 1
15507: PPUSH
15508: LD_INT 0
15510: PPUSH
15511: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
15515: LD_VAR 0 2
15519: PPUSH
15520: LD_INT 2
15522: PPUSH
15523: LD_INT 0
15525: PPUSH
15526: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
15530: LD_VAR 0 2
15534: PPUSH
15535: LD_INT 3
15537: PPUSH
15538: LD_INT 0
15540: PPUSH
15541: CALL_OW 277
// end ;
15545: PPOPN 2
15547: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
15548: LD_EXP 42
15552: PUSH
15553: LD_EXP 70
15557: AND
15558: IFFALSE 15655
15560: GO 15562
15562: DISABLE
15563: LD_INT 0
15565: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
15566: LD_ADDR_VAR 0 1
15570: PUSH
15571: LD_INT 22
15573: PUSH
15574: LD_OWVAR 2
15578: PUSH
15579: EMPTY
15580: LIST
15581: LIST
15582: PUSH
15583: LD_INT 21
15585: PUSH
15586: LD_INT 1
15588: PUSH
15589: EMPTY
15590: LIST
15591: LIST
15592: PUSH
15593: LD_INT 3
15595: PUSH
15596: LD_INT 23
15598: PUSH
15599: LD_INT 0
15601: PUSH
15602: EMPTY
15603: LIST
15604: LIST
15605: PUSH
15606: EMPTY
15607: LIST
15608: LIST
15609: PUSH
15610: EMPTY
15611: LIST
15612: LIST
15613: LIST
15614: PPUSH
15615: CALL_OW 69
15619: ST_TO_ADDR
// if not tmp then
15620: LD_VAR 0 1
15624: NOT
15625: IFFALSE 15629
// exit ;
15627: GO 15655
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
15629: LD_VAR 0 1
15633: PUSH
15634: LD_INT 1
15636: PPUSH
15637: LD_VAR 0 1
15641: PPUSH
15642: CALL_OW 12
15646: ARRAY
15647: PPUSH
15648: LD_INT 200
15650: PPUSH
15651: CALL_OW 234
// end ;
15655: PPOPN 1
15657: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
15658: LD_EXP 42
15662: PUSH
15663: LD_EXP 71
15667: AND
15668: IFFALSE 15747
15670: GO 15672
15672: DISABLE
15673: LD_INT 0
15675: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
15676: LD_ADDR_VAR 0 1
15680: PUSH
15681: LD_INT 22
15683: PUSH
15684: LD_OWVAR 2
15688: PUSH
15689: EMPTY
15690: LIST
15691: LIST
15692: PUSH
15693: LD_INT 21
15695: PUSH
15696: LD_INT 2
15698: PUSH
15699: EMPTY
15700: LIST
15701: LIST
15702: PUSH
15703: EMPTY
15704: LIST
15705: LIST
15706: PPUSH
15707: CALL_OW 69
15711: ST_TO_ADDR
// if not tmp then
15712: LD_VAR 0 1
15716: NOT
15717: IFFALSE 15721
// exit ;
15719: GO 15747
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
15721: LD_VAR 0 1
15725: PUSH
15726: LD_INT 1
15728: PPUSH
15729: LD_VAR 0 1
15733: PPUSH
15734: CALL_OW 12
15738: ARRAY
15739: PPUSH
15740: LD_INT 60
15742: PPUSH
15743: CALL_OW 234
// end ;
15747: PPOPN 1
15749: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
15750: LD_EXP 42
15754: PUSH
15755: LD_EXP 72
15759: AND
15760: IFFALSE 15859
15762: GO 15764
15764: DISABLE
15765: LD_INT 0
15767: PPUSH
15768: PPUSH
// begin enable ;
15769: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
15770: LD_ADDR_VAR 0 1
15774: PUSH
15775: LD_INT 22
15777: PUSH
15778: LD_OWVAR 2
15782: PUSH
15783: EMPTY
15784: LIST
15785: LIST
15786: PUSH
15787: LD_INT 61
15789: PUSH
15790: EMPTY
15791: LIST
15792: PUSH
15793: LD_INT 33
15795: PUSH
15796: LD_INT 2
15798: PUSH
15799: EMPTY
15800: LIST
15801: LIST
15802: PUSH
15803: EMPTY
15804: LIST
15805: LIST
15806: LIST
15807: PPUSH
15808: CALL_OW 69
15812: ST_TO_ADDR
// if not tmp then
15813: LD_VAR 0 1
15817: NOT
15818: IFFALSE 15822
// exit ;
15820: GO 15859
// for i in tmp do
15822: LD_ADDR_VAR 0 2
15826: PUSH
15827: LD_VAR 0 1
15831: PUSH
15832: FOR_IN
15833: IFFALSE 15857
// if IsControledBy ( i ) then
15835: LD_VAR 0 2
15839: PPUSH
15840: CALL_OW 312
15844: IFFALSE 15855
// ComUnlink ( i ) ;
15846: LD_VAR 0 2
15850: PPUSH
15851: CALL_OW 136
15855: GO 15832
15857: POP
15858: POP
// end ;
15859: PPOPN 2
15861: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
15862: LD_EXP 42
15866: PUSH
15867: LD_EXP 73
15871: AND
15872: IFFALSE 16012
15874: GO 15876
15876: DISABLE
15877: LD_INT 0
15879: PPUSH
15880: PPUSH
// begin ToLua ( displayPowell(); ) ;
15881: LD_STRING displayPowell();
15883: PPUSH
15884: CALL_OW 559
// uc_side := 0 ;
15888: LD_ADDR_OWVAR 20
15892: PUSH
15893: LD_INT 0
15895: ST_TO_ADDR
// uc_nation := 2 ;
15896: LD_ADDR_OWVAR 21
15900: PUSH
15901: LD_INT 2
15903: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
15904: LD_ADDR_OWVAR 37
15908: PUSH
15909: LD_INT 14
15911: ST_TO_ADDR
// vc_engine := engine_siberite ;
15912: LD_ADDR_OWVAR 39
15916: PUSH
15917: LD_INT 3
15919: ST_TO_ADDR
// vc_control := control_apeman ;
15920: LD_ADDR_OWVAR 38
15924: PUSH
15925: LD_INT 5
15927: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
15928: LD_ADDR_OWVAR 40
15932: PUSH
15933: LD_INT 29
15935: ST_TO_ADDR
// un := CreateVehicle ;
15936: LD_ADDR_VAR 0 2
15940: PUSH
15941: CALL_OW 45
15945: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
15946: LD_VAR 0 2
15950: PPUSH
15951: LD_INT 1
15953: PPUSH
15954: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
15958: LD_INT 35
15960: PPUSH
15961: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
15965: LD_VAR 0 2
15969: PPUSH
15970: LD_INT 22
15972: PUSH
15973: LD_OWVAR 2
15977: PUSH
15978: EMPTY
15979: LIST
15980: LIST
15981: PPUSH
15982: CALL_OW 69
15986: PPUSH
15987: LD_VAR 0 2
15991: PPUSH
15992: CALL_OW 74
15996: PPUSH
15997: CALL_OW 115
// until IsDead ( un ) ;
16001: LD_VAR 0 2
16005: PPUSH
16006: CALL_OW 301
16010: IFFALSE 15958
// end ;
16012: PPOPN 2
16014: END
// every 0 0$1 trigger StreamModeActive and sStu do
16015: LD_EXP 42
16019: PUSH
16020: LD_EXP 81
16024: AND
16025: IFFALSE 16041
16027: GO 16029
16029: DISABLE
// begin ToLua ( displayStucuk(); ) ;
16030: LD_STRING displayStucuk();
16032: PPUSH
16033: CALL_OW 559
// ResetFog ;
16037: CALL_OW 335
// end ;
16041: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
16042: LD_EXP 42
16046: PUSH
16047: LD_EXP 74
16051: AND
16052: IFFALSE 16193
16054: GO 16056
16056: DISABLE
16057: LD_INT 0
16059: PPUSH
16060: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
16061: LD_ADDR_VAR 0 2
16065: PUSH
16066: LD_INT 22
16068: PUSH
16069: LD_OWVAR 2
16073: PUSH
16074: EMPTY
16075: LIST
16076: LIST
16077: PUSH
16078: LD_INT 21
16080: PUSH
16081: LD_INT 1
16083: PUSH
16084: EMPTY
16085: LIST
16086: LIST
16087: PUSH
16088: EMPTY
16089: LIST
16090: LIST
16091: PPUSH
16092: CALL_OW 69
16096: ST_TO_ADDR
// if not tmp then
16097: LD_VAR 0 2
16101: NOT
16102: IFFALSE 16106
// exit ;
16104: GO 16193
// un := tmp [ rand ( 1 , tmp ) ] ;
16106: LD_ADDR_VAR 0 1
16110: PUSH
16111: LD_VAR 0 2
16115: PUSH
16116: LD_INT 1
16118: PPUSH
16119: LD_VAR 0 2
16123: PPUSH
16124: CALL_OW 12
16128: ARRAY
16129: ST_TO_ADDR
// SetSide ( un , 0 ) ;
16130: LD_VAR 0 1
16134: PPUSH
16135: LD_INT 0
16137: PPUSH
16138: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
16142: LD_VAR 0 1
16146: PPUSH
16147: LD_OWVAR 3
16151: PUSH
16152: LD_VAR 0 1
16156: DIFF
16157: PPUSH
16158: LD_VAR 0 1
16162: PPUSH
16163: CALL_OW 74
16167: PPUSH
16168: CALL_OW 115
// wait ( 0 0$20 ) ;
16172: LD_INT 700
16174: PPUSH
16175: CALL_OW 67
// SetSide ( un , your_side ) ;
16179: LD_VAR 0 1
16183: PPUSH
16184: LD_OWVAR 2
16188: PPUSH
16189: CALL_OW 235
// end ;
16193: PPOPN 2
16195: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
16196: LD_EXP 42
16200: PUSH
16201: LD_EXP 75
16205: AND
16206: IFFALSE 16312
16208: GO 16210
16210: DISABLE
16211: LD_INT 0
16213: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
16214: LD_ADDR_VAR 0 1
16218: PUSH
16219: LD_INT 22
16221: PUSH
16222: LD_OWVAR 2
16226: PUSH
16227: EMPTY
16228: LIST
16229: LIST
16230: PUSH
16231: LD_INT 2
16233: PUSH
16234: LD_INT 30
16236: PUSH
16237: LD_INT 0
16239: PUSH
16240: EMPTY
16241: LIST
16242: LIST
16243: PUSH
16244: LD_INT 30
16246: PUSH
16247: LD_INT 1
16249: PUSH
16250: EMPTY
16251: LIST
16252: LIST
16253: PUSH
16254: EMPTY
16255: LIST
16256: LIST
16257: LIST
16258: PUSH
16259: EMPTY
16260: LIST
16261: LIST
16262: PPUSH
16263: CALL_OW 69
16267: ST_TO_ADDR
// if not depot then
16268: LD_VAR 0 1
16272: NOT
16273: IFFALSE 16277
// exit ;
16275: GO 16312
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
16277: LD_VAR 0 1
16281: PUSH
16282: LD_INT 1
16284: ARRAY
16285: PPUSH
16286: CALL_OW 250
16290: PPUSH
16291: LD_VAR 0 1
16295: PUSH
16296: LD_INT 1
16298: ARRAY
16299: PPUSH
16300: CALL_OW 251
16304: PPUSH
16305: LD_INT 70
16307: PPUSH
16308: CALL_OW 495
// end ;
16312: PPOPN 1
16314: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
16315: LD_EXP 42
16319: PUSH
16320: LD_EXP 76
16324: AND
16325: IFFALSE 16536
16327: GO 16329
16329: DISABLE
16330: LD_INT 0
16332: PPUSH
16333: PPUSH
16334: PPUSH
16335: PPUSH
16336: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
16337: LD_ADDR_VAR 0 5
16341: PUSH
16342: LD_INT 22
16344: PUSH
16345: LD_OWVAR 2
16349: PUSH
16350: EMPTY
16351: LIST
16352: LIST
16353: PUSH
16354: LD_INT 21
16356: PUSH
16357: LD_INT 1
16359: PUSH
16360: EMPTY
16361: LIST
16362: LIST
16363: PUSH
16364: EMPTY
16365: LIST
16366: LIST
16367: PPUSH
16368: CALL_OW 69
16372: ST_TO_ADDR
// if not tmp then
16373: LD_VAR 0 5
16377: NOT
16378: IFFALSE 16382
// exit ;
16380: GO 16536
// for i in tmp do
16382: LD_ADDR_VAR 0 1
16386: PUSH
16387: LD_VAR 0 5
16391: PUSH
16392: FOR_IN
16393: IFFALSE 16534
// begin d := rand ( 0 , 5 ) ;
16395: LD_ADDR_VAR 0 4
16399: PUSH
16400: LD_INT 0
16402: PPUSH
16403: LD_INT 5
16405: PPUSH
16406: CALL_OW 12
16410: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
16411: LD_ADDR_VAR 0 2
16415: PUSH
16416: LD_VAR 0 1
16420: PPUSH
16421: CALL_OW 250
16425: PPUSH
16426: LD_VAR 0 4
16430: PPUSH
16431: LD_INT 3
16433: PPUSH
16434: LD_INT 12
16436: PPUSH
16437: CALL_OW 12
16441: PPUSH
16442: CALL_OW 272
16446: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
16447: LD_ADDR_VAR 0 3
16451: PUSH
16452: LD_VAR 0 1
16456: PPUSH
16457: CALL_OW 251
16461: PPUSH
16462: LD_VAR 0 4
16466: PPUSH
16467: LD_INT 3
16469: PPUSH
16470: LD_INT 12
16472: PPUSH
16473: CALL_OW 12
16477: PPUSH
16478: CALL_OW 273
16482: ST_TO_ADDR
// if ValidHex ( x , y ) then
16483: LD_VAR 0 2
16487: PPUSH
16488: LD_VAR 0 3
16492: PPUSH
16493: CALL_OW 488
16497: IFFALSE 16532
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
16499: LD_VAR 0 1
16503: PPUSH
16504: LD_VAR 0 2
16508: PPUSH
16509: LD_VAR 0 3
16513: PPUSH
16514: LD_INT 3
16516: PPUSH
16517: LD_INT 6
16519: PPUSH
16520: CALL_OW 12
16524: PPUSH
16525: LD_INT 1
16527: PPUSH
16528: CALL_OW 483
// end ;
16532: GO 16392
16534: POP
16535: POP
// end ;
16536: PPOPN 5
16538: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
16539: LD_EXP 42
16543: PUSH
16544: LD_EXP 77
16548: AND
16549: IFFALSE 16643
16551: GO 16553
16553: DISABLE
16554: LD_INT 0
16556: PPUSH
16557: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
16558: LD_ADDR_VAR 0 2
16562: PUSH
16563: LD_INT 22
16565: PUSH
16566: LD_OWVAR 2
16570: PUSH
16571: EMPTY
16572: LIST
16573: LIST
16574: PUSH
16575: LD_INT 32
16577: PUSH
16578: LD_INT 1
16580: PUSH
16581: EMPTY
16582: LIST
16583: LIST
16584: PUSH
16585: LD_INT 21
16587: PUSH
16588: LD_INT 2
16590: PUSH
16591: EMPTY
16592: LIST
16593: LIST
16594: PUSH
16595: EMPTY
16596: LIST
16597: LIST
16598: LIST
16599: PPUSH
16600: CALL_OW 69
16604: ST_TO_ADDR
// if not tmp then
16605: LD_VAR 0 2
16609: NOT
16610: IFFALSE 16614
// exit ;
16612: GO 16643
// for i in tmp do
16614: LD_ADDR_VAR 0 1
16618: PUSH
16619: LD_VAR 0 2
16623: PUSH
16624: FOR_IN
16625: IFFALSE 16641
// SetFuel ( i , 0 ) ;
16627: LD_VAR 0 1
16631: PPUSH
16632: LD_INT 0
16634: PPUSH
16635: CALL_OW 240
16639: GO 16624
16641: POP
16642: POP
// end ;
16643: PPOPN 2
16645: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
16646: LD_EXP 42
16650: PUSH
16651: LD_EXP 78
16655: AND
16656: IFFALSE 16722
16658: GO 16660
16660: DISABLE
16661: LD_INT 0
16663: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
16664: LD_ADDR_VAR 0 1
16668: PUSH
16669: LD_INT 22
16671: PUSH
16672: LD_OWVAR 2
16676: PUSH
16677: EMPTY
16678: LIST
16679: LIST
16680: PUSH
16681: LD_INT 30
16683: PUSH
16684: LD_INT 29
16686: PUSH
16687: EMPTY
16688: LIST
16689: LIST
16690: PUSH
16691: EMPTY
16692: LIST
16693: LIST
16694: PPUSH
16695: CALL_OW 69
16699: ST_TO_ADDR
// if not tmp then
16700: LD_VAR 0 1
16704: NOT
16705: IFFALSE 16709
// exit ;
16707: GO 16722
// DestroyUnit ( tmp [ 1 ] ) ;
16709: LD_VAR 0 1
16713: PUSH
16714: LD_INT 1
16716: ARRAY
16717: PPUSH
16718: CALL_OW 65
// end ;
16722: PPOPN 1
16724: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
16725: LD_EXP 42
16729: PUSH
16730: LD_EXP 80
16734: AND
16735: IFFALSE 16864
16737: GO 16739
16739: DISABLE
16740: LD_INT 0
16742: PPUSH
// begin uc_side := 0 ;
16743: LD_ADDR_OWVAR 20
16747: PUSH
16748: LD_INT 0
16750: ST_TO_ADDR
// uc_nation := nation_arabian ;
16751: LD_ADDR_OWVAR 21
16755: PUSH
16756: LD_INT 2
16758: ST_TO_ADDR
// hc_gallery :=  ;
16759: LD_ADDR_OWVAR 33
16763: PUSH
16764: LD_STRING 
16766: ST_TO_ADDR
// hc_name :=  ;
16767: LD_ADDR_OWVAR 26
16771: PUSH
16772: LD_STRING 
16774: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
16775: LD_INT 1
16777: PPUSH
16778: LD_INT 11
16780: PPUSH
16781: LD_INT 10
16783: PPUSH
16784: CALL_OW 380
// un := CreateHuman ;
16788: LD_ADDR_VAR 0 1
16792: PUSH
16793: CALL_OW 44
16797: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
16798: LD_VAR 0 1
16802: PPUSH
16803: LD_INT 1
16805: PPUSH
16806: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
16810: LD_INT 35
16812: PPUSH
16813: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
16817: LD_VAR 0 1
16821: PPUSH
16822: LD_INT 22
16824: PUSH
16825: LD_OWVAR 2
16829: PUSH
16830: EMPTY
16831: LIST
16832: LIST
16833: PPUSH
16834: CALL_OW 69
16838: PPUSH
16839: LD_VAR 0 1
16843: PPUSH
16844: CALL_OW 74
16848: PPUSH
16849: CALL_OW 115
// until IsDead ( un ) ;
16853: LD_VAR 0 1
16857: PPUSH
16858: CALL_OW 301
16862: IFFALSE 16810
// end ;
16864: PPOPN 1
16866: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
16867: LD_EXP 42
16871: PUSH
16872: LD_EXP 82
16876: AND
16877: IFFALSE 16889
16879: GO 16881
16881: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
16882: LD_STRING earthquake(getX(game), 0, 32)
16884: PPUSH
16885: CALL_OW 559
16889: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
16890: LD_EXP 42
16894: PUSH
16895: LD_EXP 83
16899: AND
16900: IFFALSE 16991
16902: GO 16904
16904: DISABLE
16905: LD_INT 0
16907: PPUSH
// begin enable ;
16908: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
16909: LD_ADDR_VAR 0 1
16913: PUSH
16914: LD_INT 22
16916: PUSH
16917: LD_OWVAR 2
16921: PUSH
16922: EMPTY
16923: LIST
16924: LIST
16925: PUSH
16926: LD_INT 21
16928: PUSH
16929: LD_INT 2
16931: PUSH
16932: EMPTY
16933: LIST
16934: LIST
16935: PUSH
16936: LD_INT 33
16938: PUSH
16939: LD_INT 3
16941: PUSH
16942: EMPTY
16943: LIST
16944: LIST
16945: PUSH
16946: EMPTY
16947: LIST
16948: LIST
16949: LIST
16950: PPUSH
16951: CALL_OW 69
16955: ST_TO_ADDR
// if not tmp then
16956: LD_VAR 0 1
16960: NOT
16961: IFFALSE 16965
// exit ;
16963: GO 16991
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
16965: LD_VAR 0 1
16969: PUSH
16970: LD_INT 1
16972: PPUSH
16973: LD_VAR 0 1
16977: PPUSH
16978: CALL_OW 12
16982: ARRAY
16983: PPUSH
16984: LD_INT 1
16986: PPUSH
16987: CALL_OW 234
// end ;
16991: PPOPN 1
16993: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
16994: LD_EXP 42
16998: PUSH
16999: LD_EXP 84
17003: AND
17004: IFFALSE 17145
17006: GO 17008
17008: DISABLE
17009: LD_INT 0
17011: PPUSH
17012: PPUSH
17013: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
17014: LD_ADDR_VAR 0 3
17018: PUSH
17019: LD_INT 22
17021: PUSH
17022: LD_OWVAR 2
17026: PUSH
17027: EMPTY
17028: LIST
17029: LIST
17030: PUSH
17031: LD_INT 25
17033: PUSH
17034: LD_INT 1
17036: PUSH
17037: EMPTY
17038: LIST
17039: LIST
17040: PUSH
17041: EMPTY
17042: LIST
17043: LIST
17044: PPUSH
17045: CALL_OW 69
17049: ST_TO_ADDR
// if not tmp then
17050: LD_VAR 0 3
17054: NOT
17055: IFFALSE 17059
// exit ;
17057: GO 17145
// un := tmp [ rand ( 1 , tmp ) ] ;
17059: LD_ADDR_VAR 0 2
17063: PUSH
17064: LD_VAR 0 3
17068: PUSH
17069: LD_INT 1
17071: PPUSH
17072: LD_VAR 0 3
17076: PPUSH
17077: CALL_OW 12
17081: ARRAY
17082: ST_TO_ADDR
// if Crawls ( un ) then
17083: LD_VAR 0 2
17087: PPUSH
17088: CALL_OW 318
17092: IFFALSE 17103
// ComWalk ( un ) ;
17094: LD_VAR 0 2
17098: PPUSH
17099: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
17103: LD_VAR 0 2
17107: PPUSH
17108: LD_INT 9
17110: PPUSH
17111: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
17115: LD_INT 28
17117: PPUSH
17118: LD_OWVAR 2
17122: PPUSH
17123: LD_INT 2
17125: PPUSH
17126: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
17130: LD_INT 29
17132: PPUSH
17133: LD_OWVAR 2
17137: PPUSH
17138: LD_INT 2
17140: PPUSH
17141: CALL_OW 322
// end ;
17145: PPOPN 3
17147: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
17148: LD_EXP 42
17152: PUSH
17153: LD_EXP 85
17157: AND
17158: IFFALSE 17269
17160: GO 17162
17162: DISABLE
17163: LD_INT 0
17165: PPUSH
17166: PPUSH
17167: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
17168: LD_ADDR_VAR 0 3
17172: PUSH
17173: LD_INT 22
17175: PUSH
17176: LD_OWVAR 2
17180: PUSH
17181: EMPTY
17182: LIST
17183: LIST
17184: PUSH
17185: LD_INT 25
17187: PUSH
17188: LD_INT 1
17190: PUSH
17191: EMPTY
17192: LIST
17193: LIST
17194: PUSH
17195: EMPTY
17196: LIST
17197: LIST
17198: PPUSH
17199: CALL_OW 69
17203: ST_TO_ADDR
// if not tmp then
17204: LD_VAR 0 3
17208: NOT
17209: IFFALSE 17213
// exit ;
17211: GO 17269
// un := tmp [ rand ( 1 , tmp ) ] ;
17213: LD_ADDR_VAR 0 2
17217: PUSH
17218: LD_VAR 0 3
17222: PUSH
17223: LD_INT 1
17225: PPUSH
17226: LD_VAR 0 3
17230: PPUSH
17231: CALL_OW 12
17235: ARRAY
17236: ST_TO_ADDR
// if Crawls ( un ) then
17237: LD_VAR 0 2
17241: PPUSH
17242: CALL_OW 318
17246: IFFALSE 17257
// ComWalk ( un ) ;
17248: LD_VAR 0 2
17252: PPUSH
17253: CALL_OW 138
// SetClass ( un , class_mortar ) ;
17257: LD_VAR 0 2
17261: PPUSH
17262: LD_INT 8
17264: PPUSH
17265: CALL_OW 336
// end ;
17269: PPOPN 3
17271: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
17272: LD_EXP 42
17276: PUSH
17277: LD_EXP 86
17281: AND
17282: IFFALSE 17426
17284: GO 17286
17286: DISABLE
17287: LD_INT 0
17289: PPUSH
17290: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
17291: LD_ADDR_VAR 0 2
17295: PUSH
17296: LD_INT 22
17298: PUSH
17299: LD_OWVAR 2
17303: PUSH
17304: EMPTY
17305: LIST
17306: LIST
17307: PUSH
17308: LD_INT 21
17310: PUSH
17311: LD_INT 2
17313: PUSH
17314: EMPTY
17315: LIST
17316: LIST
17317: PUSH
17318: LD_INT 2
17320: PUSH
17321: LD_INT 34
17323: PUSH
17324: LD_INT 12
17326: PUSH
17327: EMPTY
17328: LIST
17329: LIST
17330: PUSH
17331: LD_INT 34
17333: PUSH
17334: LD_INT 51
17336: PUSH
17337: EMPTY
17338: LIST
17339: LIST
17340: PUSH
17341: LD_INT 34
17343: PUSH
17344: LD_INT 32
17346: PUSH
17347: EMPTY
17348: LIST
17349: LIST
17350: PUSH
17351: EMPTY
17352: LIST
17353: LIST
17354: LIST
17355: LIST
17356: PUSH
17357: EMPTY
17358: LIST
17359: LIST
17360: LIST
17361: PPUSH
17362: CALL_OW 69
17366: ST_TO_ADDR
// if not tmp then
17367: LD_VAR 0 2
17371: NOT
17372: IFFALSE 17376
// exit ;
17374: GO 17426
// for i in tmp do
17376: LD_ADDR_VAR 0 1
17380: PUSH
17381: LD_VAR 0 2
17385: PUSH
17386: FOR_IN
17387: IFFALSE 17424
// if GetCargo ( i , mat_artifact ) = 0 then
17389: LD_VAR 0 1
17393: PPUSH
17394: LD_INT 4
17396: PPUSH
17397: CALL_OW 289
17401: PUSH
17402: LD_INT 0
17404: EQUAL
17405: IFFALSE 17422
// SetCargo ( i , mat_siberit , 100 ) ;
17407: LD_VAR 0 1
17411: PPUSH
17412: LD_INT 3
17414: PPUSH
17415: LD_INT 100
17417: PPUSH
17418: CALL_OW 290
17422: GO 17386
17424: POP
17425: POP
// end ;
17426: PPOPN 2
17428: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
17429: LD_EXP 42
17433: PUSH
17434: LD_EXP 87
17438: AND
17439: IFFALSE 17592
17441: GO 17443
17443: DISABLE
17444: LD_INT 0
17446: PPUSH
17447: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
17448: LD_ADDR_VAR 0 2
17452: PUSH
17453: LD_INT 22
17455: PUSH
17456: LD_OWVAR 2
17460: PUSH
17461: EMPTY
17462: LIST
17463: LIST
17464: PPUSH
17465: CALL_OW 69
17469: ST_TO_ADDR
// if not tmp then
17470: LD_VAR 0 2
17474: NOT
17475: IFFALSE 17479
// exit ;
17477: GO 17592
// for i := 1 to 2 do
17479: LD_ADDR_VAR 0 1
17483: PUSH
17484: DOUBLE
17485: LD_INT 1
17487: DEC
17488: ST_TO_ADDR
17489: LD_INT 2
17491: PUSH
17492: FOR_TO
17493: IFFALSE 17590
// begin uc_side := your_side ;
17495: LD_ADDR_OWVAR 20
17499: PUSH
17500: LD_OWVAR 2
17504: ST_TO_ADDR
// uc_nation := nation_american ;
17505: LD_ADDR_OWVAR 21
17509: PUSH
17510: LD_INT 1
17512: ST_TO_ADDR
// vc_chassis := us_morphling ;
17513: LD_ADDR_OWVAR 37
17517: PUSH
17518: LD_INT 5
17520: ST_TO_ADDR
// vc_engine := engine_siberite ;
17521: LD_ADDR_OWVAR 39
17525: PUSH
17526: LD_INT 3
17528: ST_TO_ADDR
// vc_control := control_computer ;
17529: LD_ADDR_OWVAR 38
17533: PUSH
17534: LD_INT 3
17536: ST_TO_ADDR
// vc_weapon := us_double_laser ;
17537: LD_ADDR_OWVAR 40
17541: PUSH
17542: LD_INT 10
17544: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
17545: CALL_OW 45
17549: PPUSH
17550: LD_VAR 0 2
17554: PUSH
17555: LD_INT 1
17557: ARRAY
17558: PPUSH
17559: CALL_OW 250
17563: PPUSH
17564: LD_VAR 0 2
17568: PUSH
17569: LD_INT 1
17571: ARRAY
17572: PPUSH
17573: CALL_OW 251
17577: PPUSH
17578: LD_INT 12
17580: PPUSH
17581: LD_INT 1
17583: PPUSH
17584: CALL_OW 50
// end ;
17588: GO 17492
17590: POP
17591: POP
// end ;
17592: PPOPN 2
17594: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
17595: LD_EXP 42
17599: PUSH
17600: LD_EXP 88
17604: AND
17605: IFFALSE 17827
17607: GO 17609
17609: DISABLE
17610: LD_INT 0
17612: PPUSH
17613: PPUSH
17614: PPUSH
17615: PPUSH
17616: PPUSH
17617: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
17618: LD_ADDR_VAR 0 6
17622: PUSH
17623: LD_INT 22
17625: PUSH
17626: LD_OWVAR 2
17630: PUSH
17631: EMPTY
17632: LIST
17633: LIST
17634: PUSH
17635: LD_INT 21
17637: PUSH
17638: LD_INT 1
17640: PUSH
17641: EMPTY
17642: LIST
17643: LIST
17644: PUSH
17645: LD_INT 3
17647: PUSH
17648: LD_INT 23
17650: PUSH
17651: LD_INT 0
17653: PUSH
17654: EMPTY
17655: LIST
17656: LIST
17657: PUSH
17658: EMPTY
17659: LIST
17660: LIST
17661: PUSH
17662: EMPTY
17663: LIST
17664: LIST
17665: LIST
17666: PPUSH
17667: CALL_OW 69
17671: ST_TO_ADDR
// if not tmp then
17672: LD_VAR 0 6
17676: NOT
17677: IFFALSE 17681
// exit ;
17679: GO 17827
// s1 := rand ( 1 , 4 ) ;
17681: LD_ADDR_VAR 0 2
17685: PUSH
17686: LD_INT 1
17688: PPUSH
17689: LD_INT 4
17691: PPUSH
17692: CALL_OW 12
17696: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
17697: LD_ADDR_VAR 0 4
17701: PUSH
17702: LD_VAR 0 6
17706: PUSH
17707: LD_INT 1
17709: ARRAY
17710: PPUSH
17711: LD_VAR 0 2
17715: PPUSH
17716: CALL_OW 259
17720: ST_TO_ADDR
// if s1 = 1 then
17721: LD_VAR 0 2
17725: PUSH
17726: LD_INT 1
17728: EQUAL
17729: IFFALSE 17749
// s2 := rand ( 2 , 4 ) else
17731: LD_ADDR_VAR 0 3
17735: PUSH
17736: LD_INT 2
17738: PPUSH
17739: LD_INT 4
17741: PPUSH
17742: CALL_OW 12
17746: ST_TO_ADDR
17747: GO 17757
// s2 := 1 ;
17749: LD_ADDR_VAR 0 3
17753: PUSH
17754: LD_INT 1
17756: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
17757: LD_ADDR_VAR 0 5
17761: PUSH
17762: LD_VAR 0 6
17766: PUSH
17767: LD_INT 1
17769: ARRAY
17770: PPUSH
17771: LD_VAR 0 3
17775: PPUSH
17776: CALL_OW 259
17780: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
17781: LD_VAR 0 6
17785: PUSH
17786: LD_INT 1
17788: ARRAY
17789: PPUSH
17790: LD_VAR 0 2
17794: PPUSH
17795: LD_VAR 0 5
17799: PPUSH
17800: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
17804: LD_VAR 0 6
17808: PUSH
17809: LD_INT 1
17811: ARRAY
17812: PPUSH
17813: LD_VAR 0 3
17817: PPUSH
17818: LD_VAR 0 4
17822: PPUSH
17823: CALL_OW 237
// end ;
17827: PPOPN 6
17829: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
17830: LD_EXP 42
17834: PUSH
17835: LD_EXP 89
17839: AND
17840: IFFALSE 17919
17842: GO 17844
17844: DISABLE
17845: LD_INT 0
17847: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
17848: LD_ADDR_VAR 0 1
17852: PUSH
17853: LD_INT 22
17855: PUSH
17856: LD_OWVAR 2
17860: PUSH
17861: EMPTY
17862: LIST
17863: LIST
17864: PUSH
17865: LD_INT 30
17867: PUSH
17868: LD_INT 3
17870: PUSH
17871: EMPTY
17872: LIST
17873: LIST
17874: PUSH
17875: EMPTY
17876: LIST
17877: LIST
17878: PPUSH
17879: CALL_OW 69
17883: ST_TO_ADDR
// if not tmp then
17884: LD_VAR 0 1
17888: NOT
17889: IFFALSE 17893
// exit ;
17891: GO 17919
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
17893: LD_VAR 0 1
17897: PUSH
17898: LD_INT 1
17900: PPUSH
17901: LD_VAR 0 1
17905: PPUSH
17906: CALL_OW 12
17910: ARRAY
17911: PPUSH
17912: LD_INT 1
17914: PPUSH
17915: CALL_OW 234
// end ;
17919: PPOPN 1
17921: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
17922: LD_EXP 42
17926: PUSH
17927: LD_EXP 90
17931: AND
17932: IFFALSE 18044
17934: GO 17936
17936: DISABLE
17937: LD_INT 0
17939: PPUSH
17940: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
17941: LD_ADDR_VAR 0 2
17945: PUSH
17946: LD_INT 22
17948: PUSH
17949: LD_OWVAR 2
17953: PUSH
17954: EMPTY
17955: LIST
17956: LIST
17957: PUSH
17958: LD_INT 2
17960: PUSH
17961: LD_INT 30
17963: PUSH
17964: LD_INT 27
17966: PUSH
17967: EMPTY
17968: LIST
17969: LIST
17970: PUSH
17971: LD_INT 30
17973: PUSH
17974: LD_INT 26
17976: PUSH
17977: EMPTY
17978: LIST
17979: LIST
17980: PUSH
17981: LD_INT 30
17983: PUSH
17984: LD_INT 28
17986: PUSH
17987: EMPTY
17988: LIST
17989: LIST
17990: PUSH
17991: EMPTY
17992: LIST
17993: LIST
17994: LIST
17995: LIST
17996: PUSH
17997: EMPTY
17998: LIST
17999: LIST
18000: PPUSH
18001: CALL_OW 69
18005: ST_TO_ADDR
// if not tmp then
18006: LD_VAR 0 2
18010: NOT
18011: IFFALSE 18015
// exit ;
18013: GO 18044
// for i in tmp do
18015: LD_ADDR_VAR 0 1
18019: PUSH
18020: LD_VAR 0 2
18024: PUSH
18025: FOR_IN
18026: IFFALSE 18042
// SetLives ( i , 1 ) ;
18028: LD_VAR 0 1
18032: PPUSH
18033: LD_INT 1
18035: PPUSH
18036: CALL_OW 234
18040: GO 18025
18042: POP
18043: POP
// end ;
18044: PPOPN 2
18046: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
18047: LD_EXP 42
18051: PUSH
18052: LD_EXP 91
18056: AND
18057: IFFALSE 18331
18059: GO 18061
18061: DISABLE
18062: LD_INT 0
18064: PPUSH
18065: PPUSH
18066: PPUSH
// begin i := rand ( 1 , 7 ) ;
18067: LD_ADDR_VAR 0 1
18071: PUSH
18072: LD_INT 1
18074: PPUSH
18075: LD_INT 7
18077: PPUSH
18078: CALL_OW 12
18082: ST_TO_ADDR
// case i of 1 :
18083: LD_VAR 0 1
18087: PUSH
18088: LD_INT 1
18090: DOUBLE
18091: EQUAL
18092: IFTRUE 18096
18094: GO 18106
18096: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
18097: LD_STRING earthquake(getX(game), 0, 32)
18099: PPUSH
18100: CALL_OW 559
18104: GO 18331
18106: LD_INT 2
18108: DOUBLE
18109: EQUAL
18110: IFTRUE 18114
18112: GO 18128
18114: POP
// begin ToLua ( displayStucuk(); ) ;
18115: LD_STRING displayStucuk();
18117: PPUSH
18118: CALL_OW 559
// ResetFog ;
18122: CALL_OW 335
// end ; 3 :
18126: GO 18331
18128: LD_INT 3
18130: DOUBLE
18131: EQUAL
18132: IFTRUE 18136
18134: GO 18240
18136: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
18137: LD_ADDR_VAR 0 2
18141: PUSH
18142: LD_INT 22
18144: PUSH
18145: LD_OWVAR 2
18149: PUSH
18150: EMPTY
18151: LIST
18152: LIST
18153: PUSH
18154: LD_INT 25
18156: PUSH
18157: LD_INT 1
18159: PUSH
18160: EMPTY
18161: LIST
18162: LIST
18163: PUSH
18164: EMPTY
18165: LIST
18166: LIST
18167: PPUSH
18168: CALL_OW 69
18172: ST_TO_ADDR
// if not tmp then
18173: LD_VAR 0 2
18177: NOT
18178: IFFALSE 18182
// exit ;
18180: GO 18331
// un := tmp [ rand ( 1 , tmp ) ] ;
18182: LD_ADDR_VAR 0 3
18186: PUSH
18187: LD_VAR 0 2
18191: PUSH
18192: LD_INT 1
18194: PPUSH
18195: LD_VAR 0 2
18199: PPUSH
18200: CALL_OW 12
18204: ARRAY
18205: ST_TO_ADDR
// if Crawls ( un ) then
18206: LD_VAR 0 3
18210: PPUSH
18211: CALL_OW 318
18215: IFFALSE 18226
// ComWalk ( un ) ;
18217: LD_VAR 0 3
18221: PPUSH
18222: CALL_OW 138
// SetClass ( un , class_mortar ) ;
18226: LD_VAR 0 3
18230: PPUSH
18231: LD_INT 8
18233: PPUSH
18234: CALL_OW 336
// end ; 4 :
18238: GO 18331
18240: LD_INT 4
18242: DOUBLE
18243: EQUAL
18244: IFTRUE 18248
18246: GO 18309
18248: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
18249: LD_ADDR_VAR 0 2
18253: PUSH
18254: LD_INT 22
18256: PUSH
18257: LD_OWVAR 2
18261: PUSH
18262: EMPTY
18263: LIST
18264: LIST
18265: PUSH
18266: LD_INT 30
18268: PUSH
18269: LD_INT 29
18271: PUSH
18272: EMPTY
18273: LIST
18274: LIST
18275: PUSH
18276: EMPTY
18277: LIST
18278: LIST
18279: PPUSH
18280: CALL_OW 69
18284: ST_TO_ADDR
// if not tmp then
18285: LD_VAR 0 2
18289: NOT
18290: IFFALSE 18294
// exit ;
18292: GO 18331
// DestroyUnit ( tmp [ 1 ] ) ;
18294: LD_VAR 0 2
18298: PUSH
18299: LD_INT 1
18301: ARRAY
18302: PPUSH
18303: CALL_OW 65
// end ; 5 .. 7 :
18307: GO 18331
18309: LD_INT 5
18311: DOUBLE
18312: GREATEREQUAL
18313: IFFALSE 18321
18315: LD_INT 7
18317: DOUBLE
18318: LESSEQUAL
18319: IFTRUE 18323
18321: GO 18330
18323: POP
// StreamSibBomb ; end ;
18324: CALL 14611 0 0
18328: GO 18331
18330: POP
// end ;
18331: PPOPN 3
18333: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
18334: LD_EXP 42
18338: PUSH
18339: LD_EXP 92
18343: AND
18344: IFFALSE 18500
18346: GO 18348
18348: DISABLE
18349: LD_INT 0
18351: PPUSH
18352: PPUSH
18353: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
18354: LD_ADDR_VAR 0 2
18358: PUSH
18359: LD_INT 81
18361: PUSH
18362: LD_OWVAR 2
18366: PUSH
18367: EMPTY
18368: LIST
18369: LIST
18370: PUSH
18371: LD_INT 2
18373: PUSH
18374: LD_INT 21
18376: PUSH
18377: LD_INT 1
18379: PUSH
18380: EMPTY
18381: LIST
18382: LIST
18383: PUSH
18384: LD_INT 21
18386: PUSH
18387: LD_INT 2
18389: PUSH
18390: EMPTY
18391: LIST
18392: LIST
18393: PUSH
18394: EMPTY
18395: LIST
18396: LIST
18397: LIST
18398: PUSH
18399: EMPTY
18400: LIST
18401: LIST
18402: PPUSH
18403: CALL_OW 69
18407: ST_TO_ADDR
// if not tmp then
18408: LD_VAR 0 2
18412: NOT
18413: IFFALSE 18417
// exit ;
18415: GO 18500
// p := 0 ;
18417: LD_ADDR_VAR 0 3
18421: PUSH
18422: LD_INT 0
18424: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18425: LD_INT 35
18427: PPUSH
18428: CALL_OW 67
// p := p + 1 ;
18432: LD_ADDR_VAR 0 3
18436: PUSH
18437: LD_VAR 0 3
18441: PUSH
18442: LD_INT 1
18444: PLUS
18445: ST_TO_ADDR
// for i in tmp do
18446: LD_ADDR_VAR 0 1
18450: PUSH
18451: LD_VAR 0 2
18455: PUSH
18456: FOR_IN
18457: IFFALSE 18488
// if GetLives ( i ) < 1000 then
18459: LD_VAR 0 1
18463: PPUSH
18464: CALL_OW 256
18468: PUSH
18469: LD_INT 1000
18471: LESS
18472: IFFALSE 18486
// SetLives ( i , 1000 ) ;
18474: LD_VAR 0 1
18478: PPUSH
18479: LD_INT 1000
18481: PPUSH
18482: CALL_OW 234
18486: GO 18456
18488: POP
18489: POP
// until p > 20 ;
18490: LD_VAR 0 3
18494: PUSH
18495: LD_INT 20
18497: GREATER
18498: IFFALSE 18425
// end ;
18500: PPOPN 3
18502: END
// every 0 0$1 trigger StreamModeActive and sTime do
18503: LD_EXP 42
18507: PUSH
18508: LD_EXP 93
18512: AND
18513: IFFALSE 18548
18515: GO 18517
18517: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
18518: LD_INT 28
18520: PPUSH
18521: LD_OWVAR 2
18525: PPUSH
18526: LD_INT 2
18528: PPUSH
18529: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
18533: LD_INT 30
18535: PPUSH
18536: LD_OWVAR 2
18540: PPUSH
18541: LD_INT 2
18543: PPUSH
18544: CALL_OW 322
// end ;
18548: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
18549: LD_EXP 42
18553: PUSH
18554: LD_EXP 94
18558: AND
18559: IFFALSE 18680
18561: GO 18563
18563: DISABLE
18564: LD_INT 0
18566: PPUSH
18567: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
18568: LD_ADDR_VAR 0 2
18572: PUSH
18573: LD_INT 22
18575: PUSH
18576: LD_OWVAR 2
18580: PUSH
18581: EMPTY
18582: LIST
18583: LIST
18584: PUSH
18585: LD_INT 21
18587: PUSH
18588: LD_INT 1
18590: PUSH
18591: EMPTY
18592: LIST
18593: LIST
18594: PUSH
18595: LD_INT 3
18597: PUSH
18598: LD_INT 23
18600: PUSH
18601: LD_INT 0
18603: PUSH
18604: EMPTY
18605: LIST
18606: LIST
18607: PUSH
18608: EMPTY
18609: LIST
18610: LIST
18611: PUSH
18612: EMPTY
18613: LIST
18614: LIST
18615: LIST
18616: PPUSH
18617: CALL_OW 69
18621: ST_TO_ADDR
// if not tmp then
18622: LD_VAR 0 2
18626: NOT
18627: IFFALSE 18631
// exit ;
18629: GO 18680
// for i in tmp do
18631: LD_ADDR_VAR 0 1
18635: PUSH
18636: LD_VAR 0 2
18640: PUSH
18641: FOR_IN
18642: IFFALSE 18678
// begin if Crawls ( i ) then
18644: LD_VAR 0 1
18648: PPUSH
18649: CALL_OW 318
18653: IFFALSE 18664
// ComWalk ( i ) ;
18655: LD_VAR 0 1
18659: PPUSH
18660: CALL_OW 138
// SetClass ( i , 2 ) ;
18664: LD_VAR 0 1
18668: PPUSH
18669: LD_INT 2
18671: PPUSH
18672: CALL_OW 336
// end ;
18676: GO 18641
18678: POP
18679: POP
// end ;
18680: PPOPN 2
18682: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
18683: LD_EXP 42
18687: PUSH
18688: LD_EXP 95
18692: AND
18693: IFFALSE 18974
18695: GO 18697
18697: DISABLE
18698: LD_INT 0
18700: PPUSH
18701: PPUSH
18702: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
18703: LD_OWVAR 2
18707: PPUSH
18708: LD_INT 9
18710: PPUSH
18711: LD_INT 1
18713: PPUSH
18714: LD_INT 1
18716: PPUSH
18717: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
18721: LD_INT 9
18723: PPUSH
18724: LD_OWVAR 2
18728: PPUSH
18729: CALL_OW 343
// uc_side := 9 ;
18733: LD_ADDR_OWVAR 20
18737: PUSH
18738: LD_INT 9
18740: ST_TO_ADDR
// uc_nation := 2 ;
18741: LD_ADDR_OWVAR 21
18745: PUSH
18746: LD_INT 2
18748: ST_TO_ADDR
// hc_name := Dark Warrior ;
18749: LD_ADDR_OWVAR 26
18753: PUSH
18754: LD_STRING Dark Warrior
18756: ST_TO_ADDR
// hc_gallery :=  ;
18757: LD_ADDR_OWVAR 33
18761: PUSH
18762: LD_STRING 
18764: ST_TO_ADDR
// hc_noskilllimit := true ;
18765: LD_ADDR_OWVAR 76
18769: PUSH
18770: LD_INT 1
18772: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
18773: LD_ADDR_OWVAR 31
18777: PUSH
18778: LD_INT 30
18780: PUSH
18781: LD_INT 30
18783: PUSH
18784: LD_INT 30
18786: PUSH
18787: LD_INT 30
18789: PUSH
18790: EMPTY
18791: LIST
18792: LIST
18793: LIST
18794: LIST
18795: ST_TO_ADDR
// un := CreateHuman ;
18796: LD_ADDR_VAR 0 3
18800: PUSH
18801: CALL_OW 44
18805: ST_TO_ADDR
// hc_noskilllimit := false ;
18806: LD_ADDR_OWVAR 76
18810: PUSH
18811: LD_INT 0
18813: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
18814: LD_VAR 0 3
18818: PPUSH
18819: LD_INT 1
18821: PPUSH
18822: CALL_OW 51
// p := 0 ;
18826: LD_ADDR_VAR 0 2
18830: PUSH
18831: LD_INT 0
18833: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18834: LD_INT 35
18836: PPUSH
18837: CALL_OW 67
// p := p + 1 ;
18841: LD_ADDR_VAR 0 2
18845: PUSH
18846: LD_VAR 0 2
18850: PUSH
18851: LD_INT 1
18853: PLUS
18854: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
18855: LD_VAR 0 3
18859: PPUSH
18860: CALL_OW 256
18864: PUSH
18865: LD_INT 1000
18867: LESS
18868: IFFALSE 18882
// SetLives ( un , 1000 ) ;
18870: LD_VAR 0 3
18874: PPUSH
18875: LD_INT 1000
18877: PPUSH
18878: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
18882: LD_VAR 0 3
18886: PPUSH
18887: LD_INT 81
18889: PUSH
18890: LD_OWVAR 2
18894: PUSH
18895: EMPTY
18896: LIST
18897: LIST
18898: PUSH
18899: LD_INT 91
18901: PUSH
18902: LD_VAR 0 3
18906: PUSH
18907: LD_INT 30
18909: PUSH
18910: EMPTY
18911: LIST
18912: LIST
18913: LIST
18914: PUSH
18915: EMPTY
18916: LIST
18917: LIST
18918: PPUSH
18919: CALL_OW 69
18923: PPUSH
18924: LD_VAR 0 3
18928: PPUSH
18929: CALL_OW 74
18933: PPUSH
18934: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
18938: LD_VAR 0 2
18942: PUSH
18943: LD_INT 60
18945: GREATER
18946: PUSH
18947: LD_VAR 0 3
18951: PPUSH
18952: CALL_OW 301
18956: OR
18957: IFFALSE 18834
// if un then
18959: LD_VAR 0 3
18963: IFFALSE 18974
// RemoveUnit ( un ) ;
18965: LD_VAR 0 3
18969: PPUSH
18970: CALL_OW 64
// end ; end_of_file
18974: PPOPN 3
18976: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
18977: LD_INT 0
18979: PPUSH
18980: PPUSH
18981: PPUSH
18982: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
18983: LD_VAR 0 1
18987: PPUSH
18988: CALL_OW 264
18992: PUSH
18993: LD_EXP 33
18997: EQUAL
18998: IFFALSE 19070
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
19000: LD_INT 68
19002: PPUSH
19003: LD_VAR 0 1
19007: PPUSH
19008: CALL_OW 255
19012: PPUSH
19013: CALL_OW 321
19017: PUSH
19018: LD_INT 2
19020: EQUAL
19021: IFFALSE 19033
// eff := 70 else
19023: LD_ADDR_VAR 0 4
19027: PUSH
19028: LD_INT 70
19030: ST_TO_ADDR
19031: GO 19041
// eff := 30 ;
19033: LD_ADDR_VAR 0 4
19037: PUSH
19038: LD_INT 30
19040: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
19041: LD_VAR 0 1
19045: PPUSH
19046: CALL_OW 250
19050: PPUSH
19051: LD_VAR 0 1
19055: PPUSH
19056: CALL_OW 251
19060: PPUSH
19061: LD_VAR 0 4
19065: PPUSH
19066: CALL_OW 495
// end ; end ;
19070: LD_VAR 0 2
19074: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
19075: LD_INT 0
19077: PPUSH
// end ;
19078: LD_VAR 0 4
19082: RET
// export function SOS_Command ( cmd ) ; begin
19083: LD_INT 0
19085: PPUSH
// end ;
19086: LD_VAR 0 2
19090: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
19091: LD_VAR 0 1
19095: PUSH
19096: LD_INT 255
19098: EQUAL
19099: PUSH
19100: LD_VAR 0 2
19104: PPUSH
19105: CALL_OW 264
19109: PUSH
19110: LD_INT 14
19112: PUSH
19113: LD_INT 53
19115: PUSH
19116: EMPTY
19117: LIST
19118: LIST
19119: IN
19120: AND
19121: PUSH
19122: LD_VAR 0 4
19126: PPUSH
19127: LD_VAR 0 5
19131: PPUSH
19132: CALL_OW 488
19136: AND
19137: IFFALSE 19161
// CutTreeXYR ( unit , x , y , 12 ) ;
19139: LD_VAR 0 2
19143: PPUSH
19144: LD_VAR 0 4
19148: PPUSH
19149: LD_VAR 0 5
19153: PPUSH
19154: LD_INT 12
19156: PPUSH
19157: CALL 19164 0 4
// end ;
19161: PPOPN 5
19163: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
19164: LD_INT 0
19166: PPUSH
19167: PPUSH
19168: PPUSH
19169: PPUSH
19170: PPUSH
19171: PPUSH
19172: PPUSH
19173: PPUSH
19174: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
19175: LD_VAR 0 1
19179: NOT
19180: PUSH
19181: LD_VAR 0 2
19185: PPUSH
19186: LD_VAR 0 3
19190: PPUSH
19191: CALL_OW 488
19195: NOT
19196: OR
19197: PUSH
19198: LD_VAR 0 4
19202: NOT
19203: OR
19204: IFFALSE 19208
// exit ;
19206: GO 19548
// list := [ ] ;
19208: LD_ADDR_VAR 0 13
19212: PUSH
19213: EMPTY
19214: ST_TO_ADDR
// if x - r < 0 then
19215: LD_VAR 0 2
19219: PUSH
19220: LD_VAR 0 4
19224: MINUS
19225: PUSH
19226: LD_INT 0
19228: LESS
19229: IFFALSE 19241
// min_x := 0 else
19231: LD_ADDR_VAR 0 7
19235: PUSH
19236: LD_INT 0
19238: ST_TO_ADDR
19239: GO 19257
// min_x := x - r ;
19241: LD_ADDR_VAR 0 7
19245: PUSH
19246: LD_VAR 0 2
19250: PUSH
19251: LD_VAR 0 4
19255: MINUS
19256: ST_TO_ADDR
// if y - r < 0 then
19257: LD_VAR 0 3
19261: PUSH
19262: LD_VAR 0 4
19266: MINUS
19267: PUSH
19268: LD_INT 0
19270: LESS
19271: IFFALSE 19283
// min_y := 0 else
19273: LD_ADDR_VAR 0 8
19277: PUSH
19278: LD_INT 0
19280: ST_TO_ADDR
19281: GO 19299
// min_y := y - r ;
19283: LD_ADDR_VAR 0 8
19287: PUSH
19288: LD_VAR 0 3
19292: PUSH
19293: LD_VAR 0 4
19297: MINUS
19298: ST_TO_ADDR
// max_x := x + r ;
19299: LD_ADDR_VAR 0 9
19303: PUSH
19304: LD_VAR 0 2
19308: PUSH
19309: LD_VAR 0 4
19313: PLUS
19314: ST_TO_ADDR
// max_y := y + r ;
19315: LD_ADDR_VAR 0 10
19319: PUSH
19320: LD_VAR 0 3
19324: PUSH
19325: LD_VAR 0 4
19329: PLUS
19330: ST_TO_ADDR
// for _x = min_x to max_x do
19331: LD_ADDR_VAR 0 11
19335: PUSH
19336: DOUBLE
19337: LD_VAR 0 7
19341: DEC
19342: ST_TO_ADDR
19343: LD_VAR 0 9
19347: PUSH
19348: FOR_TO
19349: IFFALSE 19466
// for _y = min_y to max_y do
19351: LD_ADDR_VAR 0 12
19355: PUSH
19356: DOUBLE
19357: LD_VAR 0 8
19361: DEC
19362: ST_TO_ADDR
19363: LD_VAR 0 10
19367: PUSH
19368: FOR_TO
19369: IFFALSE 19462
// begin if not ValidHex ( _x , _y ) then
19371: LD_VAR 0 11
19375: PPUSH
19376: LD_VAR 0 12
19380: PPUSH
19381: CALL_OW 488
19385: NOT
19386: IFFALSE 19390
// continue ;
19388: GO 19368
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
19390: LD_VAR 0 11
19394: PPUSH
19395: LD_VAR 0 12
19399: PPUSH
19400: CALL_OW 351
19404: PUSH
19405: LD_VAR 0 11
19409: PPUSH
19410: LD_VAR 0 12
19414: PPUSH
19415: CALL_OW 554
19419: AND
19420: IFFALSE 19460
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
19422: LD_ADDR_VAR 0 13
19426: PUSH
19427: LD_VAR 0 13
19431: PPUSH
19432: LD_VAR 0 13
19436: PUSH
19437: LD_INT 1
19439: PLUS
19440: PPUSH
19441: LD_VAR 0 11
19445: PUSH
19446: LD_VAR 0 12
19450: PUSH
19451: EMPTY
19452: LIST
19453: LIST
19454: PPUSH
19455: CALL_OW 2
19459: ST_TO_ADDR
// end ;
19460: GO 19368
19462: POP
19463: POP
19464: GO 19348
19466: POP
19467: POP
// if not list then
19468: LD_VAR 0 13
19472: NOT
19473: IFFALSE 19477
// exit ;
19475: GO 19548
// for i in list do
19477: LD_ADDR_VAR 0 6
19481: PUSH
19482: LD_VAR 0 13
19486: PUSH
19487: FOR_IN
19488: IFFALSE 19546
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
19490: LD_VAR 0 1
19494: PPUSH
19495: LD_STRING M
19497: PUSH
19498: LD_VAR 0 6
19502: PUSH
19503: LD_INT 1
19505: ARRAY
19506: PUSH
19507: LD_VAR 0 6
19511: PUSH
19512: LD_INT 2
19514: ARRAY
19515: PUSH
19516: LD_INT 0
19518: PUSH
19519: LD_INT 0
19521: PUSH
19522: LD_INT 0
19524: PUSH
19525: LD_INT 0
19527: PUSH
19528: EMPTY
19529: LIST
19530: LIST
19531: LIST
19532: LIST
19533: LIST
19534: LIST
19535: LIST
19536: PUSH
19537: EMPTY
19538: LIST
19539: PPUSH
19540: CALL_OW 447
19544: GO 19487
19546: POP
19547: POP
// end ;
19548: LD_VAR 0 5
19552: RET
