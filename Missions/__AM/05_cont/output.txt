// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// Init ;
  15: CALL 79 0 0
// InitRestrictions ;
  19: CALL 207 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 33
// DebugMode ;
  29: CALL 288 0 0
// SpawnApeman ( apemanStartArea , 2 ) ;
  33: LD_INT 12
  35: PPUSH
  36: LD_INT 2
  38: PPUSH
  39: CALL 658 0 2
// SpawnApeman ( apemanArea , [ 10 , 8 , 7 ] [ Difficulty ] ) ;
  43: LD_INT 11
  45: PPUSH
  46: LD_INT 10
  48: PUSH
  49: LD_INT 8
  51: PUSH
  52: LD_INT 7
  54: PUSH
  55: EMPTY
  56: LIST
  57: LIST
  58: LIST
  59: PUSH
  60: LD_OWVAR 67
  64: ARRAY
  65: PPUSH
  66: CALL 658 0 2
// PrepareAmericans ;
  70: CALL 1257 0 0
// Action ;
  74: CALL 2147 0 0
// end ;
  78: END
// export debug ; export mission_prefix , mission_prefix_prev ; export deltaBuilded , denisArrives , Delta , radar_allowed , first_apeman_tamed , apeman_army , radar_researched , radar_builded ; export apeman_counter , arab_spotted , end_mission , apeKillCounter ; function Init ; begin
  79: LD_INT 0
  81: PPUSH
// debug := false ;
  82: LD_ADDR_EXP 1
  86: PUSH
  87: LD_INT 0
  89: ST_TO_ADDR
// mission_prefix := 05_ ;
  90: LD_ADDR_EXP 2
  94: PUSH
  95: LD_STRING 05_
  97: ST_TO_ADDR
// mission_prefix_prev := 05a_ ;
  98: LD_ADDR_EXP 3
 102: PUSH
 103: LD_STRING 05a_
 105: ST_TO_ADDR
// deltaBuilded := false ;
 106: LD_ADDR_EXP 4
 110: PUSH
 111: LD_INT 0
 113: ST_TO_ADDR
// denisArrives := false ;
 114: LD_ADDR_EXP 5
 118: PUSH
 119: LD_INT 0
 121: ST_TO_ADDR
// radar_allowed := false ;
 122: LD_ADDR_EXP 7
 126: PUSH
 127: LD_INT 0
 129: ST_TO_ADDR
// first_apeman_tamed := false ;
 130: LD_ADDR_EXP 8
 134: PUSH
 135: LD_INT 0
 137: ST_TO_ADDR
// arab_spotted := false ;
 138: LD_ADDR_EXP 13
 142: PUSH
 143: LD_INT 0
 145: ST_TO_ADDR
// end_mission := false ;
 146: LD_ADDR_EXP 14
 150: PUSH
 151: LD_INT 0
 153: ST_TO_ADDR
// apeman_army := false ;
 154: LD_ADDR_EXP 9
 158: PUSH
 159: LD_INT 0
 161: ST_TO_ADDR
// radar_researched := false ;
 162: LD_ADDR_EXP 10
 166: PUSH
 167: LD_INT 0
 169: ST_TO_ADDR
// radar_builded := false ;
 170: LD_ADDR_EXP 11
 174: PUSH
 175: LD_INT 0
 177: ST_TO_ADDR
// apeman_counter := 0 ;
 178: LD_ADDR_EXP 12
 182: PUSH
 183: LD_INT 0
 185: ST_TO_ADDR
// Delta := 0 ;
 186: LD_ADDR_EXP 6
 190: PUSH
 191: LD_INT 0
 193: ST_TO_ADDR
// apeKillCounter := 0 ;
 194: LD_ADDR_EXP 15
 198: PUSH
 199: LD_INT 0
 201: ST_TO_ADDR
// end ;
 202: LD_VAR 0 1
 206: RET
// function InitRestrictions ; begin
 207: LD_INT 0
 209: PPUSH
// SetRestrict ( b_lab_half , 1 , state_enabled ) ;
 210: LD_INT 7
 212: PPUSH
 213: LD_INT 1
 215: PPUSH
 216: LD_INT 1
 218: PPUSH
 219: CALL_OW 324
// SetRestrict ( b_lab_full , 1 , state_enabled ) ;
 223: LD_INT 8
 225: PPUSH
 226: LD_INT 1
 228: PPUSH
 229: LD_INT 1
 231: PPUSH
 232: CALL_OW 324
// SetRestrict ( b_lab_weapon , 1 , state_enabled ) ;
 236: LD_INT 10
 238: PPUSH
 239: LD_INT 1
 241: PPUSH
 242: LD_INT 1
 244: PPUSH
 245: CALL_OW 324
// SetTech ( tech_gatling , 1 , LoadVariable ( GatlingInGamma , 1 ) ) ;
 249: LD_INT 69
 251: PPUSH
 252: LD_INT 1
 254: PPUSH
 255: LD_STRING GatlingInGamma
 257: PPUSH
 258: LD_INT 1
 260: PPUSH
 261: CALL_OW 30
 265: PPUSH
 266: CALL_OW 322
// SetTech ( tech_weap1 , 1 , state_enabled ) ;
 270: LD_INT 51
 272: PPUSH
 273: LD_INT 1
 275: PPUSH
 276: LD_INT 1
 278: PPUSH
 279: CALL_OW 322
// end ;
 283: LD_VAR 0 1
 287: RET
// function DebugMode ; begin
 288: LD_INT 0
 290: PPUSH
// FogOff ( 1 ) ;
 291: LD_INT 1
 293: PPUSH
 294: CALL_OW 344
// Difficulty := 2 ;
 298: LD_ADDR_OWVAR 67
 302: PUSH
 303: LD_INT 2
 305: ST_TO_ADDR
// end ;
 306: LD_VAR 0 1
 310: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 0 ] ] ) >= 7 do
 311: LD_INT 22
 313: PUSH
 314: LD_INT 1
 316: PUSH
 317: EMPTY
 318: LIST
 319: LIST
 320: PUSH
 321: LD_INT 23
 323: PUSH
 324: LD_INT 0
 326: PUSH
 327: EMPTY
 328: LIST
 329: LIST
 330: PUSH
 331: EMPTY
 332: LIST
 333: LIST
 334: PPUSH
 335: CALL_OW 69
 339: PUSH
 340: LD_INT 7
 342: GREATEREQUAL
 343: IFFALSE 355
 345: GO 347
 347: DISABLE
// SetAchievement ( ACH_TAME ) ;
 348: LD_STRING ACH_TAME
 350: PPUSH
 351: CALL_OW 543
 355: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_bweapon , us_radar ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) do
 356: LD_INT 22
 358: PUSH
 359: LD_INT 1
 361: PUSH
 362: EMPTY
 363: LIST
 364: LIST
 365: PUSH
 366: LD_INT 35
 368: PUSH
 369: LD_INT 11
 371: PUSH
 372: EMPTY
 373: LIST
 374: LIST
 375: PUSH
 376: EMPTY
 377: LIST
 378: LIST
 379: PPUSH
 380: CALL_OW 69
 384: PUSH
 385: LD_INT 22
 387: PUSH
 388: LD_INT 1
 390: PUSH
 391: EMPTY
 392: LIST
 393: LIST
 394: PUSH
 395: LD_INT 34
 397: PUSH
 398: LD_INT 11
 400: PUSH
 401: EMPTY
 402: LIST
 403: LIST
 404: PUSH
 405: EMPTY
 406: LIST
 407: LIST
 408: PPUSH
 409: CALL_OW 69
 413: AND
 414: IFFALSE 426
 416: GO 418
 418: DISABLE
// SetAchievement ( ACH_RADAR ) ; end_of_file
 419: LD_STRING ACH_RADAR
 421: PPUSH
 422: CALL_OW 543
 426: END
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 427: LD_INT 0
 429: PPUSH
 430: PPUSH
// if exist_mode then
 431: LD_VAR 0 2
 435: IFFALSE 460
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 437: LD_ADDR_VAR 0 4
 441: PUSH
 442: LD_EXP 3
 446: PUSH
 447: LD_VAR 0 1
 451: STR
 452: PPUSH
 453: CALL_OW 34
 457: ST_TO_ADDR
 458: GO 475
// unit := NewCharacter ( ident ) ;
 460: LD_ADDR_VAR 0 4
 464: PUSH
 465: LD_VAR 0 1
 469: PPUSH
 470: CALL_OW 25
 474: ST_TO_ADDR
// result := unit ;
 475: LD_ADDR_VAR 0 3
 479: PUSH
 480: LD_VAR 0 4
 484: ST_TO_ADDR
// end ;
 485: LD_VAR 0 3
 489: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 490: LD_INT 0
 492: PPUSH
// uc_side := side ;
 493: LD_ADDR_OWVAR 20
 497: PUSH
 498: LD_VAR 0 1
 502: ST_TO_ADDR
// uc_nation := nation ;
 503: LD_ADDR_OWVAR 21
 507: PUSH
 508: LD_VAR 0 2
 512: ST_TO_ADDR
// vc_chassis := chassis ;
 513: LD_ADDR_OWVAR 37
 517: PUSH
 518: LD_VAR 0 3
 522: ST_TO_ADDR
// vc_engine := engine ;
 523: LD_ADDR_OWVAR 39
 527: PUSH
 528: LD_VAR 0 4
 532: ST_TO_ADDR
// vc_control := control ;
 533: LD_ADDR_OWVAR 38
 537: PUSH
 538: LD_VAR 0 5
 542: ST_TO_ADDR
// vc_weapon := weapon ;
 543: LD_ADDR_OWVAR 40
 547: PUSH
 548: LD_VAR 0 6
 552: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 553: LD_ADDR_OWVAR 41
 557: PUSH
 558: LD_VAR 0 7
 562: ST_TO_ADDR
// result := CreateVehicle ;
 563: LD_ADDR_VAR 0 8
 567: PUSH
 568: CALL_OW 45
 572: ST_TO_ADDR
// end ;
 573: LD_VAR 0 8
 577: RET
// export function SayX ( units , ident ) ; var i ; begin
 578: LD_INT 0
 580: PPUSH
 581: PPUSH
// result := false ;
 582: LD_ADDR_VAR 0 3
 586: PUSH
 587: LD_INT 0
 589: ST_TO_ADDR
// if not units then
 590: LD_VAR 0 1
 594: NOT
 595: IFFALSE 599
// exit ;
 597: GO 653
// for i in units do
 599: LD_ADDR_VAR 0 4
 603: PUSH
 604: LD_VAR 0 1
 608: PUSH
 609: FOR_IN
 610: IFFALSE 651
// if IsOk ( i ) then
 612: LD_VAR 0 4
 616: PPUSH
 617: CALL_OW 302
 621: IFFALSE 649
// begin Say ( i , ident ) ;
 623: LD_VAR 0 4
 627: PPUSH
 628: LD_VAR 0 2
 632: PPUSH
 633: CALL_OW 88
// result := i ;
 637: LD_ADDR_VAR 0 3
 641: PUSH
 642: LD_VAR 0 4
 646: ST_TO_ADDR
// break ;
 647: GO 651
// end ;
 649: GO 609
 651: POP
 652: POP
// end ;
 653: LD_VAR 0 3
 657: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 658: LD_INT 0
 660: PPUSH
 661: PPUSH
// InitUc ;
 662: CALL_OW 18
// InitHc ;
 666: CALL_OW 19
// uc_side := 0 ;
 670: LD_ADDR_OWVAR 20
 674: PUSH
 675: LD_INT 0
 677: ST_TO_ADDR
// uc_nation := 0 ;
 678: LD_ADDR_OWVAR 21
 682: PUSH
 683: LD_INT 0
 685: ST_TO_ADDR
// for i = 1 to amount do
 686: LD_ADDR_VAR 0 4
 690: PUSH
 691: DOUBLE
 692: LD_INT 1
 694: DEC
 695: ST_TO_ADDR
 696: LD_VAR 0 2
 700: PUSH
 701: FOR_TO
 702: IFFALSE 784
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 704: LD_ADDR_OWVAR 29
 708: PUSH
 709: LD_INT 9
 711: PPUSH
 712: LD_INT 12
 714: PPUSH
 715: CALL_OW 12
 719: PUSH
 720: LD_INT 9
 722: PPUSH
 723: LD_INT 12
 725: PPUSH
 726: CALL_OW 12
 730: PUSH
 731: EMPTY
 732: LIST
 733: LIST
 734: ST_TO_ADDR
// hc_agressivity := rand ( - 5 , 5 ) ;
 735: LD_ADDR_OWVAR 35
 739: PUSH
 740: LD_INT 5
 742: NEG
 743: PPUSH
 744: LD_INT 5
 746: PPUSH
 747: CALL_OW 12
 751: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 752: LD_INT 0
 754: PPUSH
 755: LD_INT 12
 757: PPUSH
 758: LD_INT 1
 760: PPUSH
 761: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 765: CALL_OW 44
 769: PPUSH
 770: LD_VAR 0 1
 774: PPUSH
 775: LD_INT 0
 777: PPUSH
 778: CALL_OW 49
// end ;
 782: GO 701
 784: POP
 785: POP
// InitHc ;
 786: CALL_OW 19
// end ;
 790: LD_VAR 0 3
 794: RET
// export function Attack ( unit , enemy_list ) ; var target , targets_list ; begin
 795: LD_INT 0
 797: PPUSH
 798: PPUSH
 799: PPUSH
// if not unit then
 800: LD_VAR 0 1
 804: NOT
 805: IFFALSE 809
// exit ;
 807: GO 1252
// if IsInUnit ( unit ) then
 809: LD_VAR 0 1
 813: PPUSH
 814: CALL_OW 310
 818: IFFALSE 835
// unit := IsDrivenBy ( unit ) ;
 820: LD_ADDR_VAR 0 1
 824: PUSH
 825: LD_VAR 0 1
 829: PPUSH
 830: CALL_OW 311
 834: ST_TO_ADDR
// targets_list := [ ] ;
 835: LD_ADDR_VAR 0 5
 839: PUSH
 840: EMPTY
 841: ST_TO_ADDR
// target := UnitFilter ( enemy_list , [ [ f_lives , 250 ] , [ f_not , [ f_weapon , us_cargo_bay ] ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
 842: LD_ADDR_VAR 0 4
 846: PUSH
 847: LD_VAR 0 2
 851: PPUSH
 852: LD_INT 24
 854: PUSH
 855: LD_INT 250
 857: PUSH
 858: EMPTY
 859: LIST
 860: LIST
 861: PUSH
 862: LD_INT 3
 864: PUSH
 865: LD_INT 34
 867: PUSH
 868: LD_INT 12
 870: PUSH
 871: EMPTY
 872: LIST
 873: LIST
 874: PUSH
 875: EMPTY
 876: LIST
 877: LIST
 878: PUSH
 879: LD_INT 21
 881: PUSH
 882: LD_INT 2
 884: PUSH
 885: EMPTY
 886: LIST
 887: LIST
 888: PUSH
 889: LD_INT 58
 891: PUSH
 892: EMPTY
 893: LIST
 894: PUSH
 895: EMPTY
 896: LIST
 897: LIST
 898: LIST
 899: LIST
 900: PPUSH
 901: CALL_OW 72
 905: ST_TO_ADDR
// if GetDistUnits ( NearestUnitToUnit ( target , unit ) , unit ) < 11 and not IsInUnit ( unit ) then
 906: LD_VAR 0 4
 910: PPUSH
 911: LD_VAR 0 1
 915: PPUSH
 916: CALL_OW 74
 920: PPUSH
 921: LD_VAR 0 1
 925: PPUSH
 926: CALL_OW 296
 930: PUSH
 931: LD_INT 11
 933: LESS
 934: PUSH
 935: LD_VAR 0 1
 939: PPUSH
 940: CALL_OW 310
 944: NOT
 945: AND
 946: IFFALSE 974
// begin ComEnterUnit ( unit , NearestUnitToUnit ( target , unit ) ) ;
 948: LD_VAR 0 1
 952: PPUSH
 953: LD_VAR 0 4
 957: PPUSH
 958: LD_VAR 0 1
 962: PPUSH
 963: CALL_OW 74
 967: PPUSH
 968: CALL_OW 120
// exit ;
 972: GO 1252
// end ; targets_list := [ UnitFilter ( enemy_list , [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] ] ) , UnitFilter ( enemy_list , [ f_type , unit_vehicle ] ) , UnitFilter ( enemy_list , [ [ f_type , unit_building ] , [ f_not , [ f_empty ] ] ] ) , enemy_list ] ;
 974: LD_ADDR_VAR 0 5
 978: PUSH
 979: LD_VAR 0 2
 983: PPUSH
 984: LD_INT 21
 986: PUSH
 987: LD_INT 1
 989: PUSH
 990: EMPTY
 991: LIST
 992: LIST
 993: PUSH
 994: LD_INT 3
 996: PUSH
 997: LD_INT 54
 999: PUSH
1000: EMPTY
1001: LIST
1002: PUSH
1003: EMPTY
1004: LIST
1005: LIST
1006: PUSH
1007: EMPTY
1008: LIST
1009: LIST
1010: PPUSH
1011: CALL_OW 72
1015: PUSH
1016: LD_VAR 0 2
1020: PPUSH
1021: LD_INT 21
1023: PUSH
1024: LD_INT 2
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: PPUSH
1031: CALL_OW 72
1035: PUSH
1036: LD_VAR 0 2
1040: PPUSH
1041: LD_INT 21
1043: PUSH
1044: LD_INT 3
1046: PUSH
1047: EMPTY
1048: LIST
1049: LIST
1050: PUSH
1051: LD_INT 3
1053: PUSH
1054: LD_INT 58
1056: PUSH
1057: EMPTY
1058: LIST
1059: PUSH
1060: EMPTY
1061: LIST
1062: LIST
1063: PUSH
1064: EMPTY
1065: LIST
1066: LIST
1067: PPUSH
1068: CALL_OW 72
1072: PUSH
1073: LD_VAR 0 2
1077: PUSH
1078: EMPTY
1079: LIST
1080: LIST
1081: LIST
1082: LIST
1083: ST_TO_ADDR
// for target in targets_list do
1084: LD_ADDR_VAR 0 4
1088: PUSH
1089: LD_VAR 0 5
1093: PUSH
1094: FOR_IN
1095: IFFALSE 1250
// begin if target then
1097: LD_VAR 0 4
1101: IFFALSE 1248
// if GetTag ( unit ) = 11 and ( GetType ( NearestUnitToUnit ( target , unit ) ) = unit_building or GetWeapon ( NearestUnitToUnit ( target , unit ) ) = us_cargo_bay ) then
1103: LD_VAR 0 1
1107: PPUSH
1108: CALL_OW 110
1112: PUSH
1113: LD_INT 11
1115: EQUAL
1116: PUSH
1117: LD_VAR 0 4
1121: PPUSH
1122: LD_VAR 0 1
1126: PPUSH
1127: CALL_OW 74
1131: PPUSH
1132: CALL_OW 247
1136: PUSH
1137: LD_INT 3
1139: EQUAL
1140: PUSH
1141: LD_VAR 0 4
1145: PPUSH
1146: LD_VAR 0 1
1150: PPUSH
1151: CALL_OW 74
1155: PPUSH
1156: CALL_OW 264
1160: PUSH
1161: LD_INT 12
1163: EQUAL
1164: OR
1165: AND
1166: IFFALSE 1212
// begin ComPlaceDelayedCharge ( unit , 0 , 0 , NearestUnitToUnit ( target , unit ) ) ;
1168: LD_VAR 0 1
1172: PPUSH
1173: LD_INT 0
1175: PPUSH
1176: LD_INT 0
1178: PPUSH
1179: LD_VAR 0 4
1183: PPUSH
1184: LD_VAR 0 1
1188: PPUSH
1189: CALL_OW 74
1193: PPUSH
1194: CALL_OW 132
// SetTag ( unit , 0 ) ;
1198: LD_VAR 0 1
1202: PPUSH
1203: LD_INT 0
1205: PPUSH
1206: CALL_OW 109
// end else
1210: GO 1248
// if not HasTask ( unit ) then
1212: LD_VAR 0 1
1216: PPUSH
1217: CALL_OW 314
1221: NOT
1222: IFFALSE 1248
// ComAttackUnit ( unit , NearestUnitToUnit ( target , unit ) ) ;
1224: LD_VAR 0 1
1228: PPUSH
1229: LD_VAR 0 4
1233: PPUSH
1234: LD_VAR 0 1
1238: PPUSH
1239: CALL_OW 74
1243: PPUSH
1244: CALL_OW 115
// end ;
1248: GO 1094
1250: POP
1251: POP
// end ; end_of_file
1252: LD_VAR 0 3
1256: RET
// export JMM , Gladstone , Harrison , Denis , Brown , Donaldson , Lisa , Frank , Bobby , Cyrus ; export others ; export function PrepareAmericans ; var i , points , veh , tmp ; begin
1257: LD_INT 0
1259: PPUSH
1260: PPUSH
1261: PPUSH
1262: PPUSH
1263: PPUSH
// uc_nation := 1 ;
1264: LD_ADDR_OWVAR 21
1268: PUSH
1269: LD_INT 1
1271: ST_TO_ADDR
// uc_side := 4 ;
1272: LD_ADDR_OWVAR 20
1276: PUSH
1277: LD_INT 4
1279: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , false ) ;
1280: LD_ADDR_EXP 19
1284: PUSH
1285: LD_STRING Denis
1287: PPUSH
1288: LD_INT 0
1290: PPUSH
1291: CALL 427 0 2
1295: ST_TO_ADDR
// Harrison := PrepareUnit ( Harisson , false ) ;
1296: LD_ADDR_EXP 18
1300: PUSH
1301: LD_STRING Harisson
1303: PPUSH
1304: LD_INT 0
1306: PPUSH
1307: CALL 427 0 2
1311: ST_TO_ADDR
// uc_side := 1 ;
1312: LD_ADDR_OWVAR 20
1316: PUSH
1317: LD_INT 1
1319: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1320: LD_ADDR_EXP 16
1324: PUSH
1325: LD_STRING JMM
1327: PPUSH
1328: LD_EXP 1
1332: NOT
1333: PPUSH
1334: CALL 427 0 2
1338: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , false ) ;
1339: LD_ADDR_EXP 17
1343: PUSH
1344: LD_STRING Gladstone
1346: PPUSH
1347: LD_INT 0
1349: PPUSH
1350: CALL 427 0 2
1354: ST_TO_ADDR
// if LoadVariable ( BrownInDelta , debug ) then
1355: LD_STRING BrownInDelta
1357: PPUSH
1358: LD_EXP 1
1362: PPUSH
1363: CALL_OW 30
1367: IFFALSE 1404
// begin Brown := PrepareUnit ( Brown , ( not debug ) ) ;
1369: LD_ADDR_EXP 20
1373: PUSH
1374: LD_STRING Brown
1376: PPUSH
1377: LD_EXP 1
1381: NOT
1382: PPUSH
1383: CALL 427 0 2
1387: ST_TO_ADDR
// tmp := tmp ^ Brown ;
1388: LD_ADDR_VAR 0 5
1392: PUSH
1393: LD_VAR 0 5
1397: PUSH
1398: LD_EXP 20
1402: ADD
1403: ST_TO_ADDR
// end ; if LoadVariable ( DonaldsonInDelta , debug ) then
1404: LD_STRING DonaldsonInDelta
1406: PPUSH
1407: LD_EXP 1
1411: PPUSH
1412: CALL_OW 30
1416: IFFALSE 1453
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
1418: LD_ADDR_EXP 21
1422: PUSH
1423: LD_STRING Donaldson
1425: PPUSH
1426: LD_EXP 1
1430: NOT
1431: PPUSH
1432: CALL 427 0 2
1436: ST_TO_ADDR
// tmp := tmp ^ Donaldson ;
1437: LD_ADDR_VAR 0 5
1441: PUSH
1442: LD_VAR 0 5
1446: PUSH
1447: LD_EXP 21
1451: ADD
1452: ST_TO_ADDR
// end ; if LoadVariable ( LisaInDelta , debug ) then
1453: LD_STRING LisaInDelta
1455: PPUSH
1456: LD_EXP 1
1460: PPUSH
1461: CALL_OW 30
1465: IFFALSE 1502
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1467: LD_ADDR_EXP 22
1471: PUSH
1472: LD_STRING Lisa
1474: PPUSH
1475: LD_EXP 1
1479: NOT
1480: PPUSH
1481: CALL 427 0 2
1485: ST_TO_ADDR
// tmp := tmp ^ Lisa ;
1486: LD_ADDR_VAR 0 5
1490: PUSH
1491: LD_VAR 0 5
1495: PUSH
1496: LD_EXP 22
1500: ADD
1501: ST_TO_ADDR
// end ; if LoadVariable ( FrankInDelta , debug ) then
1502: LD_STRING FrankInDelta
1504: PPUSH
1505: LD_EXP 1
1509: PPUSH
1510: CALL_OW 30
1514: IFFALSE 1551
// begin Frank := PrepareUnit ( Frank , ( not debug ) ) ;
1516: LD_ADDR_EXP 23
1520: PUSH
1521: LD_STRING Frank
1523: PPUSH
1524: LD_EXP 1
1528: NOT
1529: PPUSH
1530: CALL 427 0 2
1534: ST_TO_ADDR
// tmp := tmp ^ Frank ;
1535: LD_ADDR_VAR 0 5
1539: PUSH
1540: LD_VAR 0 5
1544: PUSH
1545: LD_EXP 23
1549: ADD
1550: ST_TO_ADDR
// end ; if LoadVariable ( BobbyInDelta , 0 ) then
1551: LD_STRING BobbyInDelta
1553: PPUSH
1554: LD_INT 0
1556: PPUSH
1557: CALL_OW 30
1561: IFFALSE 1598
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1563: LD_ADDR_EXP 24
1567: PUSH
1568: LD_STRING Bobby
1570: PPUSH
1571: LD_EXP 1
1575: NOT
1576: PPUSH
1577: CALL 427 0 2
1581: ST_TO_ADDR
// tmp := tmp ^ Bobby ;
1582: LD_ADDR_VAR 0 5
1586: PUSH
1587: LD_VAR 0 5
1591: PUSH
1592: LD_EXP 24
1596: ADD
1597: ST_TO_ADDR
// end ; if LoadVariable ( CyrusInDelta , 0 ) then
1598: LD_STRING CyrusInDelta
1600: PPUSH
1601: LD_INT 0
1603: PPUSH
1604: CALL_OW 30
1608: IFFALSE 1645
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1610: LD_ADDR_EXP 25
1614: PUSH
1615: LD_STRING Cyrus
1617: PPUSH
1618: LD_EXP 1
1622: NOT
1623: PPUSH
1624: CALL 427 0 2
1628: ST_TO_ADDR
// tmp := tmp ^ Cyrus ;
1629: LD_ADDR_VAR 0 5
1633: PUSH
1634: LD_VAR 0 5
1638: PUSH
1639: LD_EXP 25
1643: ADD
1644: ST_TO_ADDR
// end ; others := CreateCharacterSet ( othersDelta ) ;
1645: LD_ADDR_EXP 26
1649: PUSH
1650: LD_STRING othersDelta
1652: PPUSH
1653: CALL_OW 31
1657: ST_TO_ADDR
// if not others and debug then
1658: LD_EXP 26
1662: NOT
1663: PUSH
1664: LD_EXP 1
1668: AND
1669: IFFALSE 1734
// begin InitHc ;
1671: CALL_OW 19
// for i = 1 to 2 do
1675: LD_ADDR_VAR 0 2
1679: PUSH
1680: DOUBLE
1681: LD_INT 1
1683: DEC
1684: ST_TO_ADDR
1685: LD_INT 2
1687: PUSH
1688: FOR_TO
1689: IFFALSE 1732
// begin PrepareHuman ( false , i mod 4 + 1 , 3 ) ;
1691: LD_INT 0
1693: PPUSH
1694: LD_VAR 0 2
1698: PUSH
1699: LD_INT 4
1701: MOD
1702: PUSH
1703: LD_INT 1
1705: PLUS
1706: PPUSH
1707: LD_INT 3
1709: PPUSH
1710: CALL_OW 380
// others := others ^ CreateHuman ;
1714: LD_ADDR_EXP 26
1718: PUSH
1719: LD_EXP 26
1723: PUSH
1724: CALL_OW 44
1728: ADD
1729: ST_TO_ADDR
// end ;
1730: GO 1688
1732: POP
1733: POP
// end ; if others then
1734: LD_EXP 26
1738: IFFALSE 1756
// tmp := tmp ^ others ;
1740: LD_ADDR_VAR 0 5
1744: PUSH
1745: LD_VAR 0 5
1749: PUSH
1750: LD_EXP 26
1754: ADD
1755: ST_TO_ADDR
// points := [ [ 28 , 49 ] , [ 33 , 54 ] , [ 38 , 56 ] ] ;
1756: LD_ADDR_VAR 0 3
1760: PUSH
1761: LD_INT 28
1763: PUSH
1764: LD_INT 49
1766: PUSH
1767: EMPTY
1768: LIST
1769: LIST
1770: PUSH
1771: LD_INT 33
1773: PUSH
1774: LD_INT 54
1776: PUSH
1777: EMPTY
1778: LIST
1779: LIST
1780: PUSH
1781: LD_INT 38
1783: PUSH
1784: LD_INT 56
1786: PUSH
1787: EMPTY
1788: LIST
1789: LIST
1790: PUSH
1791: EMPTY
1792: LIST
1793: LIST
1794: LIST
1795: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , us_cargo_bay , 80 ) ;
1796: LD_ADDR_VAR 0 4
1800: PUSH
1801: LD_INT 1
1803: PPUSH
1804: LD_INT 1
1806: PPUSH
1807: LD_INT 2
1809: PPUSH
1810: LD_INT 2
1812: PPUSH
1813: LD_INT 1
1815: PPUSH
1816: LD_INT 12
1818: PPUSH
1819: LD_INT 80
1821: PPUSH
1822: CALL 490 0 7
1826: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1827: LD_VAR 0 4
1831: PPUSH
1832: LD_INT 1
1834: PPUSH
1835: CALL_OW 233
// PlaceUnitXY ( veh , points [ 1 ] [ 1 ] , points [ 1 ] [ 2 ] , false ) ;
1839: LD_VAR 0 4
1843: PPUSH
1844: LD_VAR 0 3
1848: PUSH
1849: LD_INT 1
1851: ARRAY
1852: PUSH
1853: LD_INT 1
1855: ARRAY
1856: PPUSH
1857: LD_VAR 0 3
1861: PUSH
1862: LD_INT 1
1864: ARRAY
1865: PUSH
1866: LD_INT 2
1868: ARRAY
1869: PPUSH
1870: LD_INT 0
1872: PPUSH
1873: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
1877: LD_VAR 0 4
1881: PPUSH
1882: LD_INT 1
1884: PPUSH
1885: LD_INT 100
1887: PPUSH
1888: CALL_OW 290
// PlaceHumanInUnit ( others [ 1 ] , veh ) ;
1892: LD_EXP 26
1896: PUSH
1897: LD_INT 1
1899: ARRAY
1900: PPUSH
1901: LD_VAR 0 4
1905: PPUSH
1906: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_machine_gun , 80 ) ;
1910: LD_ADDR_VAR 0 4
1914: PUSH
1915: LD_INT 1
1917: PPUSH
1918: LD_INT 1
1920: PPUSH
1921: LD_INT 1
1923: PPUSH
1924: LD_INT 2
1926: PPUSH
1927: LD_INT 1
1929: PPUSH
1930: LD_INT 2
1932: PPUSH
1933: LD_INT 80
1935: PPUSH
1936: CALL 490 0 7
1940: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1941: LD_VAR 0 4
1945: PPUSH
1946: LD_INT 1
1948: PPUSH
1949: CALL_OW 233
// PlaceUnitXY ( veh , points [ 2 ] [ 1 ] , points [ 2 ] [ 2 ] , false ) ;
1953: LD_VAR 0 4
1957: PPUSH
1958: LD_VAR 0 3
1962: PUSH
1963: LD_INT 2
1965: ARRAY
1966: PUSH
1967: LD_INT 1
1969: ARRAY
1970: PPUSH
1971: LD_VAR 0 3
1975: PUSH
1976: LD_INT 2
1978: ARRAY
1979: PUSH
1980: LD_INT 2
1982: ARRAY
1983: PPUSH
1984: LD_INT 0
1986: PPUSH
1987: CALL_OW 48
// PlaceHumanInUnit ( Gladstone , veh ) ;
1991: LD_EXP 17
1995: PPUSH
1996: LD_VAR 0 4
2000: PPUSH
2001: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_light_gun , 80 ) ;
2005: LD_ADDR_VAR 0 4
2009: PUSH
2010: LD_INT 1
2012: PPUSH
2013: LD_INT 1
2015: PPUSH
2016: LD_INT 1
2018: PPUSH
2019: LD_INT 2
2021: PPUSH
2022: LD_INT 1
2024: PPUSH
2025: LD_INT 3
2027: PPUSH
2028: LD_INT 80
2030: PPUSH
2031: CALL 490 0 7
2035: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
2036: LD_VAR 0 4
2040: PPUSH
2041: LD_INT 1
2043: PPUSH
2044: CALL_OW 233
// PlaceUnitXY ( veh , points [ 3 ] [ 1 ] , points [ 3 ] [ 2 ] , false ) ;
2048: LD_VAR 0 4
2052: PPUSH
2053: LD_VAR 0 3
2057: PUSH
2058: LD_INT 3
2060: ARRAY
2061: PUSH
2062: LD_INT 1
2064: ARRAY
2065: PPUSH
2066: LD_VAR 0 3
2070: PUSH
2071: LD_INT 3
2073: ARRAY
2074: PUSH
2075: LD_INT 2
2077: ARRAY
2078: PPUSH
2079: LD_INT 0
2081: PPUSH
2082: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
2086: LD_EXP 16
2090: PPUSH
2091: LD_VAR 0 4
2095: PPUSH
2096: CALL_OW 52
// for i in tmp diff others [ 1 ] do
2100: LD_ADDR_VAR 0 2
2104: PUSH
2105: LD_VAR 0 5
2109: PUSH
2110: LD_EXP 26
2114: PUSH
2115: LD_INT 1
2117: ARRAY
2118: DIFF
2119: PUSH
2120: FOR_IN
2121: IFFALSE 2140
// PlaceUnitArea ( i , startArea , false ) ;
2123: LD_VAR 0 2
2127: PPUSH
2128: LD_INT 5
2130: PPUSH
2131: LD_INT 0
2133: PPUSH
2134: CALL_OW 49
2138: GO 2120
2140: POP
2141: POP
// end ; end_of_file
2142: LD_VAR 0 1
2146: RET
// export function Action ; var m ; begin
2147: LD_INT 0
2149: PPUSH
2150: PPUSH
// InGameOn ;
2151: CALL_OW 8
// CenterNowOnXY ( 28 , 51 ) ;
2155: LD_INT 28
2157: PPUSH
2158: LD_INT 51
2160: PPUSH
2161: CALL_OW 86
// Wait ( 3 ) ;
2165: LD_INT 3
2167: PPUSH
2168: CALL_OW 67
// Say ( JMM , D1d-JMM-1a ) ;
2172: LD_EXP 16
2176: PPUSH
2177: LD_STRING D1d-JMM-1a
2179: PPUSH
2180: CALL_OW 88
// SayRadio ( Harrison , D1d-Har-1 ) ;
2184: LD_EXP 18
2188: PPUSH
2189: LD_STRING D1d-Har-1
2191: PPUSH
2192: CALL_OW 94
// InGameOff ;
2196: CALL_OW 9
// SaveForQuickRestart ;
2200: CALL_OW 22
// ChangeMissionObjectives ( M1 ) ;
2204: LD_STRING M1
2206: PPUSH
2207: CALL_OW 337
// Wait ( 0 0$2 ) ;
2211: LD_INT 70
2213: PPUSH
2214: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
2218: LD_EXP 16
2222: PPUSH
2223: LD_STRING D2-JMM-1
2225: PPUSH
2226: CALL_OW 88
// Say ( Gladstone , D2-Glad-1 ) ;
2230: LD_EXP 17
2234: PPUSH
2235: LD_STRING D2-Glad-1
2237: PPUSH
2238: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
2242: LD_EXP 16
2246: PPUSH
2247: LD_STRING D2-JMM-2
2249: PPUSH
2250: CALL_OW 88
// Say ( Gladstone , D2-Glad-2 ) ;
2254: LD_EXP 17
2258: PPUSH
2259: LD_STRING D2-Glad-2
2261: PPUSH
2262: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
2266: LD_EXP 16
2270: PPUSH
2271: LD_STRING D2-JMM-3
2273: PPUSH
2274: CALL_OW 88
// Wait ( rand ( 0 0$30 , 1 1$00 ) ) ;
2278: LD_INT 1050
2280: PPUSH
2281: LD_INT 2100
2283: PPUSH
2284: CALL_OW 12
2288: PPUSH
2289: CALL_OW 67
// SetWeather ( 1 , 570 , 350 ) ;
2293: LD_INT 1
2295: PPUSH
2296: LD_INT 570
2298: PPUSH
2299: LD_INT 350
2301: PPUSH
2302: CALL_OW 550
// Wait ( rand ( 3 3$00 , 5 5$00 ) ) ;
2306: LD_INT 6300
2308: PPUSH
2309: LD_INT 10500
2311: PPUSH
2312: CALL_OW 12
2316: PPUSH
2317: CALL_OW 67
// SetWeather ( 0 , 570 , 350 ) ;
2321: LD_INT 0
2323: PPUSH
2324: LD_INT 570
2326: PPUSH
2327: LD_INT 350
2329: PPUSH
2330: CALL_OW 550
// end ;
2334: LD_VAR 0 1
2338: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) and not deltaBuilded do
2339: LD_INT 22
2341: PUSH
2342: LD_INT 1
2344: PUSH
2345: EMPTY
2346: LIST
2347: LIST
2348: PUSH
2349: LD_INT 3
2351: PUSH
2352: LD_INT 57
2354: PUSH
2355: EMPTY
2356: LIST
2357: PUSH
2358: EMPTY
2359: LIST
2360: LIST
2361: PUSH
2362: LD_INT 30
2364: PUSH
2365: LD_INT 0
2367: PUSH
2368: EMPTY
2369: LIST
2370: LIST
2371: PUSH
2372: EMPTY
2373: LIST
2374: LIST
2375: LIST
2376: PUSH
2377: EMPTY
2378: LIST
2379: PPUSH
2380: CALL_OW 69
2384: PUSH
2385: LD_EXP 4
2389: NOT
2390: AND
2391: IFFALSE 2404
2393: GO 2395
2395: DISABLE
// begin deltaBuilded := true ;
2396: LD_ADDR_EXP 4
2400: PUSH
2401: LD_INT 1
2403: ST_TO_ADDR
// end ;
2404: END
// every 0 0$01 trigger not Delta and deltaBuilded and FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) do
2405: LD_EXP 6
2409: NOT
2410: PUSH
2411: LD_EXP 4
2415: AND
2416: PUSH
2417: LD_INT 22
2419: PUSH
2420: LD_INT 1
2422: PUSH
2423: EMPTY
2424: LIST
2425: LIST
2426: PUSH
2427: LD_INT 3
2429: PUSH
2430: LD_INT 57
2432: PUSH
2433: EMPTY
2434: LIST
2435: PUSH
2436: EMPTY
2437: LIST
2438: LIST
2439: PUSH
2440: LD_INT 30
2442: PUSH
2443: LD_INT 0
2445: PUSH
2446: EMPTY
2447: LIST
2448: LIST
2449: PUSH
2450: EMPTY
2451: LIST
2452: LIST
2453: LIST
2454: PUSH
2455: EMPTY
2456: LIST
2457: PPUSH
2458: CALL_OW 69
2462: AND
2463: IFFALSE 2549
2465: GO 2467
2467: DISABLE
// begin enable ;
2468: ENABLE
// SetRestrict ( b_depot , 1 , state_disabled ) ;
2469: LD_INT 0
2471: PPUSH
2472: LD_INT 1
2474: PPUSH
2475: LD_INT 0
2477: PPUSH
2478: CALL_OW 324
// Delta := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) [ 1 ] ;
2482: LD_ADDR_EXP 6
2486: PUSH
2487: LD_INT 22
2489: PUSH
2490: LD_INT 1
2492: PUSH
2493: EMPTY
2494: LIST
2495: LIST
2496: PUSH
2497: LD_INT 3
2499: PUSH
2500: LD_INT 57
2502: PUSH
2503: EMPTY
2504: LIST
2505: PUSH
2506: EMPTY
2507: LIST
2508: LIST
2509: PUSH
2510: LD_INT 30
2512: PUSH
2513: LD_INT 0
2515: PUSH
2516: EMPTY
2517: LIST
2518: LIST
2519: PUSH
2520: EMPTY
2521: LIST
2522: LIST
2523: LIST
2524: PUSH
2525: EMPTY
2526: LIST
2527: PPUSH
2528: CALL_OW 69
2532: PUSH
2533: LD_INT 1
2535: ARRAY
2536: ST_TO_ADDR
// SetBName ( Delta , Delta ) ;
2537: LD_EXP 6
2541: PPUSH
2542: LD_STRING Delta
2544: PPUSH
2545: CALL_OW 500
// end ;
2549: END
// every 0 0$2 trigger GetTech ( tech_ApeLang , 1 ) = state_researched and IsOk ( Gladstone ) do
2550: LD_INT 1
2552: PPUSH
2553: LD_INT 1
2555: PPUSH
2556: CALL_OW 321
2560: PUSH
2561: LD_INT 2
2563: EQUAL
2564: PUSH
2565: LD_EXP 17
2569: PPUSH
2570: CALL_OW 302
2574: AND
2575: IFFALSE 2636
2577: GO 2579
2579: DISABLE
// begin DialogueOn ;
2580: CALL_OW 6
// Say ( Gladstone , D3-Glad-1 ) ;
2584: LD_EXP 17
2588: PPUSH
2589: LD_STRING D3-Glad-1
2591: PPUSH
2592: CALL_OW 88
// Say ( JMM , D3-JMM-1 ) ;
2596: LD_EXP 16
2600: PPUSH
2601: LD_STRING D3-JMM-1
2603: PPUSH
2604: CALL_OW 88
// Say ( Gladstone , D3-Glad-2 ) ;
2608: LD_EXP 17
2612: PPUSH
2613: LD_STRING D3-Glad-2
2615: PPUSH
2616: CALL_OW 88
// Say ( JMM , D3-JMM-2 ) ;
2620: LD_EXP 16
2624: PPUSH
2625: LD_STRING D3-JMM-2
2627: PPUSH
2628: CALL_OW 88
// DialogueOff ;
2632: CALL_OW 7
// end ;
2636: END
// every 0 0$1 trigger GetTech ( tech_ApePsych , 1 ) = state_researched do var sol ;
2637: LD_INT 2
2639: PPUSH
2640: LD_INT 1
2642: PPUSH
2643: CALL_OW 321
2647: PUSH
2648: LD_INT 2
2650: EQUAL
2651: IFFALSE 2828
2653: GO 2655
2655: DISABLE
2656: LD_INT 0
2658: PPUSH
// begin DialogueOn ;
2659: CALL_OW 6
// if Frank then
2663: LD_EXP 23
2667: IFFALSE 2681
// Say ( Frank , D8a-Frank-1 ) ;
2669: LD_EXP 23
2673: PPUSH
2674: LD_STRING D8a-Frank-1
2676: PPUSH
2677: CALL_OW 88
// sol := SayX ( UnitFilter ( others , [ f_sex , sex_male ] ) , D8a-Sol1-1 ) ;
2681: LD_ADDR_VAR 0 1
2685: PUSH
2686: LD_EXP 26
2690: PPUSH
2691: LD_INT 26
2693: PUSH
2694: LD_INT 1
2696: PUSH
2697: EMPTY
2698: LIST
2699: LIST
2700: PPUSH
2701: CALL_OW 72
2705: PPUSH
2706: LD_STRING D8a-Sol1-1
2708: PPUSH
2709: CALL 578 0 2
2713: ST_TO_ADDR
// if Denis and GetSide ( Denis ) = 1 then
2714: LD_EXP 19
2718: PUSH
2719: LD_EXP 19
2723: PPUSH
2724: CALL_OW 255
2728: PUSH
2729: LD_INT 1
2731: EQUAL
2732: AND
2733: IFFALSE 2747
// Say ( Denis , D8a-Den-1 ) ;
2735: LD_EXP 19
2739: PPUSH
2740: LD_STRING D8a-Den-1
2742: PPUSH
2743: CALL_OW 88
// if sol or Denis or Frank then
2747: LD_VAR 0 1
2751: PUSH
2752: LD_EXP 19
2756: OR
2757: PUSH
2758: LD_EXP 23
2762: OR
2763: IFFALSE 2824
// begin SayX ( UnitFilter ( others , [ [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff sol , D8a-Sci1-1 ) ;
2765: LD_EXP 26
2769: PPUSH
2770: LD_INT 25
2772: PUSH
2773: LD_INT 4
2775: PUSH
2776: EMPTY
2777: LIST
2778: LIST
2779: PUSH
2780: LD_INT 26
2782: PUSH
2783: LD_INT 1
2785: PUSH
2786: EMPTY
2787: LIST
2788: LIST
2789: PUSH
2790: EMPTY
2791: LIST
2792: LIST
2793: PPUSH
2794: CALL_OW 72
2798: PUSH
2799: LD_VAR 0 1
2803: DIFF
2804: PPUSH
2805: LD_STRING D8a-Sci1-1
2807: PPUSH
2808: CALL 578 0 2
// Say ( JMM , D8a-JMM-1 ) ;
2812: LD_EXP 16
2816: PPUSH
2817: LD_STRING D8a-JMM-1
2819: PPUSH
2820: CALL_OW 88
// end ; DialogueOff ;
2824: CALL_OW 7
// end ;
2828: PPOPN 1
2830: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) do
2831: LD_INT 22
2833: PUSH
2834: LD_INT 1
2836: PUSH
2837: EMPTY
2838: LIST
2839: LIST
2840: PUSH
2841: LD_INT 25
2843: PUSH
2844: LD_INT 16
2846: PUSH
2847: EMPTY
2848: LIST
2849: LIST
2850: PUSH
2851: EMPTY
2852: LIST
2853: LIST
2854: PPUSH
2855: CALL_OW 69
2859: IFFALSE 2918
2861: GO 2863
2863: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
2864: LD_STRING M1a
2866: PPUSH
2867: CALL_OW 337
// case Query ( Q2 ) of 1 :
2871: LD_STRING Q2
2873: PPUSH
2874: CALL_OW 97
2878: PUSH
2879: LD_INT 1
2881: DOUBLE
2882: EQUAL
2883: IFTRUE 2887
2885: GO 2898
2887: POP
// end_mission := true ; 2 :
2888: LD_ADDR_EXP 14
2892: PUSH
2893: LD_INT 1
2895: ST_TO_ADDR
2896: GO 2918
2898: LD_INT 2
2900: DOUBLE
2901: EQUAL
2902: IFTRUE 2906
2904: GO 2917
2906: POP
// end_the_mission_allowed := true ; end ;
2907: LD_ADDR_OWVAR 57
2911: PUSH
2912: LD_INT 1
2914: ST_TO_ADDR
2915: GO 2918
2917: POP
// end ;
2918: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) and Delta do
2919: LD_INT 22
2921: PUSH
2922: LD_INT 1
2924: PUSH
2925: EMPTY
2926: LIST
2927: LIST
2928: PUSH
2929: LD_INT 2
2931: PUSH
2932: LD_INT 30
2934: PUSH
2935: LD_INT 6
2937: PUSH
2938: EMPTY
2939: LIST
2940: LIST
2941: PUSH
2942: LD_INT 30
2944: PUSH
2945: LD_INT 7
2947: PUSH
2948: EMPTY
2949: LIST
2950: LIST
2951: PUSH
2952: EMPTY
2953: LIST
2954: LIST
2955: LIST
2956: PUSH
2957: EMPTY
2958: LIST
2959: LIST
2960: PPUSH
2961: CALL_OW 69
2965: PUSH
2966: LD_INT 22
2968: PUSH
2969: LD_INT 1
2971: PUSH
2972: EMPTY
2973: LIST
2974: LIST
2975: PUSH
2976: LD_INT 2
2978: PUSH
2979: LD_INT 30
2981: PUSH
2982: LD_INT 2
2984: PUSH
2985: EMPTY
2986: LIST
2987: LIST
2988: PUSH
2989: LD_INT 30
2991: PUSH
2992: LD_INT 3
2994: PUSH
2995: EMPTY
2996: LIST
2997: LIST
2998: PUSH
2999: EMPTY
3000: LIST
3001: LIST
3002: LIST
3003: PUSH
3004: EMPTY
3005: LIST
3006: LIST
3007: PPUSH
3008: CALL_OW 69
3012: AND
3013: PUSH
3014: LD_EXP 6
3018: AND
3019: IFFALSE 3530
3021: GO 3023
3023: DISABLE
// begin Wait ( rand ( 0 0$30 , 0 0$50 ) ) ;
3024: LD_INT 1050
3026: PPUSH
3027: LD_INT 1750
3029: PPUSH
3030: CALL_OW 12
3034: PPUSH
3035: CALL_OW 67
// PlaceUnitArea ( Denis , [ denisArea1 , denisArea2 , denisArea3 ] [ Difficulty ] , false ) ;
3039: LD_EXP 19
3043: PPUSH
3044: LD_INT 6
3046: PUSH
3047: LD_INT 9
3049: PUSH
3050: LD_INT 10
3052: PUSH
3053: EMPTY
3054: LIST
3055: LIST
3056: LIST
3057: PUSH
3058: LD_OWVAR 67
3062: ARRAY
3063: PPUSH
3064: LD_INT 0
3066: PPUSH
3067: CALL_OW 49
// ComHold ( Denis ) ;
3071: LD_EXP 19
3075: PPUSH
3076: CALL_OW 140
// InGameOn ;
3080: CALL_OW 8
// DialogueOn ;
3084: CALL_OW 6
// if Delta then
3088: LD_EXP 6
3092: IFFALSE 3105
// CenterNowOnUnits ( Delta ) else
3094: LD_EXP 6
3098: PPUSH
3099: CALL_OW 87
3103: GO 3114
// CenterNowOnUnits ( JMM ) ;
3105: LD_EXP 16
3109: PPUSH
3110: CALL_OW 87
// SayRadio ( Denis , DD-Den-1 ) ;
3114: LD_EXP 19
3118: PPUSH
3119: LD_STRING DD-Den-1
3121: PPUSH
3122: CALL_OW 94
// Say ( JMM , DD-JMM-1 ) ;
3126: LD_EXP 16
3130: PPUSH
3131: LD_STRING DD-JMM-1
3133: PPUSH
3134: CALL_OW 88
// SayRadio ( Denis , DD-Den-2 ) ;
3138: LD_EXP 19
3142: PPUSH
3143: LD_STRING DD-Den-2
3145: PPUSH
3146: CALL_OW 94
// Wait ( 3 ) ;
3150: LD_INT 3
3152: PPUSH
3153: CALL_OW 67
// DialogueOff ;
3157: CALL_OW 7
// InGameOff ;
3161: CALL_OW 9
// if Difficulty = 1 then
3165: LD_OWVAR 67
3169: PUSH
3170: LD_INT 1
3172: EQUAL
3173: IFFALSE 3249
// begin PlaceSeeing ( GetX ( Denis ) , GetY ( Denis ) , 1 , - 12 ) ;
3175: LD_EXP 19
3179: PPUSH
3180: CALL_OW 250
3184: PPUSH
3185: LD_EXP 19
3189: PPUSH
3190: CALL_OW 251
3194: PPUSH
3195: LD_INT 1
3197: PPUSH
3198: LD_INT 12
3200: NEG
3201: PPUSH
3202: CALL_OW 330
// CenterNowOnUnits ( Denis ) ;
3206: LD_EXP 19
3210: PPUSH
3211: CALL_OW 87
// wait ( 0 0$5 ) ;
3215: LD_INT 175
3217: PPUSH
3218: CALL_OW 67
// RemoveSeeing ( GetX ( Denis ) , GetY ( Denis ) , 1 ) ;
3222: LD_EXP 19
3226: PPUSH
3227: CALL_OW 250
3231: PPUSH
3232: LD_EXP 19
3236: PPUSH
3237: CALL_OW 251
3241: PPUSH
3242: LD_INT 1
3244: PPUSH
3245: CALL_OW 331
// end ; repeat wait ( 0 0$01 ) ;
3249: LD_INT 35
3251: PPUSH
3252: CALL_OW 67
// until See ( 1 , Denis ) or IsDead ( Denis ) ;
3256: LD_INT 1
3258: PPUSH
3259: LD_EXP 19
3263: PPUSH
3264: CALL_OW 292
3268: PUSH
3269: LD_EXP 19
3273: PPUSH
3274: CALL_OW 301
3278: OR
3279: IFFALSE 3249
// if IsDead ( Denis ) then
3281: LD_EXP 19
3285: PPUSH
3286: CALL_OW 301
3290: IFFALSE 3294
// exit ;
3292: GO 3530
// SetSide ( Denis , 1 ) ;
3294: LD_EXP 19
3298: PPUSH
3299: LD_INT 1
3301: PPUSH
3302: CALL_OW 235
// Say ( Denis , DD-Den-2a ) ;
3306: LD_EXP 19
3310: PPUSH
3311: LD_STRING DD-Den-2a
3313: PPUSH
3314: CALL_OW 88
// repeat wait ( 0 0$01 ) ;
3318: LD_INT 35
3320: PPUSH
3321: CALL_OW 67
// until GetBType ( IsInUnit ( Denis ) ) in [ b_lab , b_lab_half , b_lab_full ] or IsDead ( Denis ) ;
3325: LD_EXP 19
3329: PPUSH
3330: CALL_OW 310
3334: PPUSH
3335: CALL_OW 266
3339: PUSH
3340: LD_INT 6
3342: PUSH
3343: LD_INT 7
3345: PUSH
3346: LD_INT 8
3348: PUSH
3349: EMPTY
3350: LIST
3351: LIST
3352: LIST
3353: IN
3354: PUSH
3355: LD_EXP 19
3359: PPUSH
3360: CALL_OW 301
3364: OR
3365: IFFALSE 3318
// if IsDead ( Denis ) then
3367: LD_EXP 19
3371: PPUSH
3372: CALL_OW 301
3376: IFFALSE 3380
// exit ;
3378: GO 3530
// Say ( Denis , DD-Den-2b ) ;
3380: LD_EXP 19
3384: PPUSH
3385: LD_STRING DD-Den-2b
3387: PPUSH
3388: CALL_OW 88
// ComChangeProfession ( Denis , 4 ) ;
3392: LD_EXP 19
3396: PPUSH
3397: LD_INT 4
3399: PPUSH
3400: CALL_OW 123
// Wait ( 0 0$02 ) ;
3404: LD_INT 70
3406: PPUSH
3407: CALL_OW 67
// DialogueOn ;
3411: CALL_OW 6
// CenterNowOnUnits ( Denis ) ;
3415: LD_EXP 19
3419: PPUSH
3420: CALL_OW 87
// Say ( JMM , D4-JMM-1 ) ;
3424: LD_EXP 16
3428: PPUSH
3429: LD_STRING D4-JMM-1
3431: PPUSH
3432: CALL_OW 88
// Say ( Denis , D4-Den-1 ) ;
3436: LD_EXP 19
3440: PPUSH
3441: LD_STRING D4-Den-1
3443: PPUSH
3444: CALL_OW 88
// Say ( JMM , D4-JMM-2 ) ;
3448: LD_EXP 16
3452: PPUSH
3453: LD_STRING D4-JMM-2
3455: PPUSH
3456: CALL_OW 88
// Say ( Denis , D4-Den-2 ) ;
3460: LD_EXP 19
3464: PPUSH
3465: LD_STRING D4-Den-2
3467: PPUSH
3468: CALL_OW 88
// DialogueOff ;
3472: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
3476: LD_STRING M2
3478: PPUSH
3479: CALL_OW 337
// radar_allowed := true ;
3483: LD_ADDR_EXP 7
3487: PUSH
3488: LD_INT 1
3490: ST_TO_ADDR
// SetTech ( tech_radar , 1 , state_enabled ) ;
3491: LD_INT 6
3493: PPUSH
3494: LD_INT 1
3496: PPUSH
3497: LD_INT 1
3499: PPUSH
3500: CALL_OW 322
// SetRestrict ( b_lab_opto , 1 , state_enabled ) ;
3504: LD_INT 15
3506: PPUSH
3507: LD_INT 1
3509: PPUSH
3510: LD_INT 1
3512: PPUSH
3513: CALL_OW 324
// SetRestrict ( b_ext_radar , 1 , state_enabled ) ;
3517: LD_INT 20
3519: PPUSH
3520: LD_INT 1
3522: PPUSH
3523: LD_INT 1
3525: PPUSH
3526: CALL_OW 324
// end ;
3530: END
// every 0 0$1 trigger arab_spotted do var sol , sol2 ;
3531: LD_EXP 13
3535: IFFALSE 4158
3537: GO 3539
3539: DISABLE
3540: LD_INT 0
3542: PPUSH
3543: PPUSH
// begin sol := SayX ( UnitFilter ( others , [ f_sex , sex_male ] ) , D5-Sol1-1 ) ;
3544: LD_ADDR_VAR 0 1
3548: PUSH
3549: LD_EXP 26
3553: PPUSH
3554: LD_INT 26
3556: PUSH
3557: LD_INT 1
3559: PUSH
3560: EMPTY
3561: LIST
3562: LIST
3563: PPUSH
3564: CALL_OW 72
3568: PPUSH
3569: LD_STRING D5-Sol1-1
3571: PPUSH
3572: CALL 578 0 2
3576: ST_TO_ADDR
// if not sol then
3577: LD_VAR 0 1
3581: NOT
3582: IFFALSE 3586
// exit ;
3584: GO 4158
// repeat wait ( 0 0$01 ) ;
3586: LD_INT 35
3588: PPUSH
3589: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 ;
3593: LD_INT 22
3595: PUSH
3596: LD_INT 2
3598: PUSH
3599: EMPTY
3600: LIST
3601: LIST
3602: PUSH
3603: LD_INT 21
3605: PUSH
3606: LD_INT 1
3608: PUSH
3609: EMPTY
3610: LIST
3611: LIST
3612: PUSH
3613: EMPTY
3614: LIST
3615: LIST
3616: PPUSH
3617: CALL_OW 69
3621: PUSH
3622: LD_INT 0
3624: EQUAL
3625: IFFALSE 3586
// if IsOk ( sol ) then
3627: LD_VAR 0 1
3631: PPUSH
3632: CALL_OW 302
3636: IFFALSE 3656
// begin sol2 := others diff sol ;
3638: LD_ADDR_VAR 0 2
3642: PUSH
3643: LD_EXP 26
3647: PUSH
3648: LD_VAR 0 1
3652: DIFF
3653: ST_TO_ADDR
// end else
3654: GO 3658
// exit ;
3656: GO 4158
// if not Lisa and not sol2 then
3658: LD_EXP 22
3662: NOT
3663: PUSH
3664: LD_VAR 0 2
3668: NOT
3669: AND
3670: IFFALSE 3674
// exit ;
3672: GO 4158
// DialogueOn ;
3674: CALL_OW 6
// if Lisa then
3678: LD_EXP 22
3682: IFFALSE 3698
// Say ( Lisa , D5a-Lisa-1 ) else
3684: LD_EXP 22
3688: PPUSH
3689: LD_STRING D5a-Lisa-1
3691: PPUSH
3692: CALL_OW 88
3696: GO 3773
// if sol2 then
3698: LD_VAR 0 2
3702: IFFALSE 3773
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3704: LD_VAR 0 2
3708: PUSH
3709: LD_INT 1
3711: ARRAY
3712: PPUSH
3713: CALL_OW 258
3717: PUSH
3718: LD_INT 1
3720: DOUBLE
3721: EQUAL
3722: IFTRUE 3726
3724: GO 3745
3726: POP
// Say ( sol2 [ 1 ] , D5-Sol2-1 ) ; sex_female :
3727: LD_VAR 0 2
3731: PUSH
3732: LD_INT 1
3734: ARRAY
3735: PPUSH
3736: LD_STRING D5-Sol2-1
3738: PPUSH
3739: CALL_OW 88
3743: GO 3773
3745: LD_INT 2
3747: DOUBLE
3748: EQUAL
3749: IFTRUE 3753
3751: GO 3772
3753: POP
// Say ( sol2 [ 1 ] , D5-FSol2-1 ) ; end ;
3754: LD_VAR 0 2
3758: PUSH
3759: LD_INT 1
3761: ARRAY
3762: PPUSH
3763: LD_STRING D5-FSol2-1
3765: PPUSH
3766: CALL_OW 88
3770: GO 3773
3772: POP
// Say ( sol , D5-Sol1-2 ) ;
3773: LD_VAR 0 1
3777: PPUSH
3778: LD_STRING D5-Sol1-2
3780: PPUSH
3781: CALL_OW 88
// if Lisa then
3785: LD_EXP 22
3789: IFFALSE 3805
// Say ( Lisa , D5a-Lisa-2 ) else
3791: LD_EXP 22
3795: PPUSH
3796: LD_STRING D5a-Lisa-2
3798: PPUSH
3799: CALL_OW 88
3803: GO 3880
// if sol2 then
3805: LD_VAR 0 2
3809: IFFALSE 3880
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3811: LD_VAR 0 2
3815: PUSH
3816: LD_INT 1
3818: ARRAY
3819: PPUSH
3820: CALL_OW 258
3824: PUSH
3825: LD_INT 1
3827: DOUBLE
3828: EQUAL
3829: IFTRUE 3833
3831: GO 3852
3833: POP
// Say ( sol2 [ 1 ] , D5-Sol2-2 ) ; sex_female :
3834: LD_VAR 0 2
3838: PUSH
3839: LD_INT 1
3841: ARRAY
3842: PPUSH
3843: LD_STRING D5-Sol2-2
3845: PPUSH
3846: CALL_OW 88
3850: GO 3880
3852: LD_INT 2
3854: DOUBLE
3855: EQUAL
3856: IFTRUE 3860
3858: GO 3879
3860: POP
// Say ( sol2 [ 1 ] , D5-FSol2-2 ) ; end ;
3861: LD_VAR 0 2
3865: PUSH
3866: LD_INT 1
3868: ARRAY
3869: PPUSH
3870: LD_STRING D5-FSol2-2
3872: PPUSH
3873: CALL_OW 88
3877: GO 3880
3879: POP
// Say ( sol , D5a-Sol1-3 ) ;
3880: LD_VAR 0 1
3884: PPUSH
3885: LD_STRING D5a-Sol1-3
3887: PPUSH
3888: CALL_OW 88
// if Lisa then
3892: LD_EXP 22
3896: IFFALSE 3910
// Say ( Lisa , D5a-Lisa-3 ) ;
3898: LD_EXP 22
3902: PPUSH
3903: LD_STRING D5a-Lisa-3
3905: PPUSH
3906: CALL_OW 88
// if not sol2 then
3910: LD_VAR 0 2
3914: NOT
3915: IFFALSE 3923
// begin DialogueOff ;
3917: CALL_OW 7
// exit ;
3921: GO 4158
// end ; case GetSex ( sol2 [ 1 ] ) of sex_male :
3923: LD_VAR 0 2
3927: PUSH
3928: LD_INT 1
3930: ARRAY
3931: PPUSH
3932: CALL_OW 258
3936: PUSH
3937: LD_INT 1
3939: DOUBLE
3940: EQUAL
3941: IFTRUE 3945
3943: GO 3964
3945: POP
// Say ( sol2 [ 1 ] , D5-Sol2-3 ) ; sex_female :
3946: LD_VAR 0 2
3950: PUSH
3951: LD_INT 1
3953: ARRAY
3954: PPUSH
3955: LD_STRING D5-Sol2-3
3957: PPUSH
3958: CALL_OW 88
3962: GO 3992
3964: LD_INT 2
3966: DOUBLE
3967: EQUAL
3968: IFTRUE 3972
3970: GO 3991
3972: POP
// Say ( sol2 [ 1 ] , D5-FSol2-3 ) ; end ;
3973: LD_VAR 0 2
3977: PUSH
3978: LD_INT 1
3980: ARRAY
3981: PPUSH
3982: LD_STRING D5-FSol2-3
3984: PPUSH
3985: CALL_OW 88
3989: GO 3992
3991: POP
// Say ( sol , D5-Sol1-4 ) ;
3992: LD_VAR 0 1
3996: PPUSH
3997: LD_STRING D5-Sol1-4
3999: PPUSH
4000: CALL_OW 88
// case GetSex ( sol2 [ 1 ] ) of sex_male :
4004: LD_VAR 0 2
4008: PUSH
4009: LD_INT 1
4011: ARRAY
4012: PPUSH
4013: CALL_OW 258
4017: PUSH
4018: LD_INT 1
4020: DOUBLE
4021: EQUAL
4022: IFTRUE 4026
4024: GO 4045
4026: POP
// Say ( sol2 [ 1 ] , D5-Sol2-4 ) ; sex_female :
4027: LD_VAR 0 2
4031: PUSH
4032: LD_INT 1
4034: ARRAY
4035: PPUSH
4036: LD_STRING D5-Sol2-4
4038: PPUSH
4039: CALL_OW 88
4043: GO 4073
4045: LD_INT 2
4047: DOUBLE
4048: EQUAL
4049: IFTRUE 4053
4051: GO 4072
4053: POP
// Say ( sol2 [ 1 ] , D5-FSol2-4 ) ; end ;
4054: LD_VAR 0 2
4058: PUSH
4059: LD_INT 1
4061: ARRAY
4062: PPUSH
4063: LD_STRING D5-FSol2-4
4065: PPUSH
4066: CALL_OW 88
4070: GO 4073
4072: POP
// Say ( sol , D5-Sol1-5 ) ;
4073: LD_VAR 0 1
4077: PPUSH
4078: LD_STRING D5-Sol1-5
4080: PPUSH
4081: CALL_OW 88
// case GetSex ( sol2 [ 1 ] ) of sex_male :
4085: LD_VAR 0 2
4089: PUSH
4090: LD_INT 1
4092: ARRAY
4093: PPUSH
4094: CALL_OW 258
4098: PUSH
4099: LD_INT 1
4101: DOUBLE
4102: EQUAL
4103: IFTRUE 4107
4105: GO 4126
4107: POP
// Say ( sol2 [ 1 ] , D5-Sol2-5 ) ; sex_female :
4108: LD_VAR 0 2
4112: PUSH
4113: LD_INT 1
4115: ARRAY
4116: PPUSH
4117: LD_STRING D5-Sol2-5
4119: PPUSH
4120: CALL_OW 88
4124: GO 4154
4126: LD_INT 2
4128: DOUBLE
4129: EQUAL
4130: IFTRUE 4134
4132: GO 4153
4134: POP
// Say ( sol2 [ 1 ] , D5-FSol2-5 ) ; end ;
4135: LD_VAR 0 2
4139: PUSH
4140: LD_INT 1
4142: ARRAY
4143: PPUSH
4144: LD_STRING D5-FSol2-5
4146: PPUSH
4147: CALL_OW 88
4151: GO 4154
4153: POP
// DialogueOff ;
4154: CALL_OW 7
// end ;
4158: PPOPN 2
4160: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) >= 5 do
4161: LD_INT 22
4163: PUSH
4164: LD_INT 1
4166: PUSH
4167: EMPTY
4168: LIST
4169: LIST
4170: PUSH
4171: LD_INT 25
4173: PUSH
4174: LD_INT 16
4176: PUSH
4177: EMPTY
4178: LIST
4179: LIST
4180: PUSH
4181: EMPTY
4182: LIST
4183: LIST
4184: PPUSH
4185: CALL_OW 69
4189: PUSH
4190: LD_INT 5
4192: GREATEREQUAL
4193: IFFALSE 4213
4195: GO 4197
4197: DISABLE
// begin ChangeMissionObjectives ( M1b ) ;
4198: LD_STRING M1b
4200: PPUSH
4201: CALL_OW 337
// apeman_army := true ;
4205: LD_ADDR_EXP 9
4209: PUSH
4210: LD_INT 1
4212: ST_TO_ADDR
// end ;
4213: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_factory ] , [ f_constructed ] ] ) do
4214: LD_INT 22
4216: PUSH
4217: LD_INT 1
4219: PUSH
4220: EMPTY
4221: LIST
4222: LIST
4223: PUSH
4224: LD_INT 30
4226: PUSH
4227: LD_INT 3
4229: PUSH
4230: EMPTY
4231: LIST
4232: LIST
4233: PUSH
4234: LD_INT 57
4236: PUSH
4237: EMPTY
4238: LIST
4239: PUSH
4240: EMPTY
4241: LIST
4242: LIST
4243: LIST
4244: PPUSH
4245: CALL_OW 69
4249: IFFALSE 4261
4251: GO 4253
4253: DISABLE
// ChangeMissionObjectives ( M1c ) ;
4254: LD_STRING M1c
4256: PPUSH
4257: CALL_OW 337
4261: END
// every 0 0$1 trigger GetTech ( tech_radar , 1 ) = state_researched do
4262: LD_INT 6
4264: PPUSH
4265: LD_INT 1
4267: PPUSH
4268: CALL_OW 321
4272: PUSH
4273: LD_INT 2
4275: EQUAL
4276: IFFALSE 4296
4278: GO 4280
4280: DISABLE
// begin ChangeMissionObjectives ( M2a ) ;
4281: LD_STRING M2a
4283: PPUSH
4284: CALL_OW 337
// radar_researched := true ;
4288: LD_ADDR_EXP 10
4292: PUSH
4293: LD_INT 1
4295: ST_TO_ADDR
// end ;
4296: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_weapon , us_radar ] , [ f_bweapon , us_radar ] ] ] ) do
4297: LD_INT 22
4299: PUSH
4300: LD_INT 1
4302: PUSH
4303: EMPTY
4304: LIST
4305: LIST
4306: PUSH
4307: LD_INT 2
4309: PUSH
4310: LD_INT 34
4312: PUSH
4313: LD_INT 11
4315: PUSH
4316: EMPTY
4317: LIST
4318: LIST
4319: PUSH
4320: LD_INT 35
4322: PUSH
4323: LD_INT 11
4325: PUSH
4326: EMPTY
4327: LIST
4328: LIST
4329: PUSH
4330: EMPTY
4331: LIST
4332: LIST
4333: LIST
4334: PUSH
4335: EMPTY
4336: LIST
4337: LIST
4338: PPUSH
4339: CALL_OW 69
4343: IFFALSE 4363
4345: GO 4347
4347: DISABLE
// begin ChangeMissionObjectives ( M2b ) ;
4348: LD_STRING M2b
4350: PPUSH
4351: CALL_OW 337
// radar_builded := true ;
4355: LD_ADDR_EXP 11
4359: PUSH
4360: LD_INT 1
4362: ST_TO_ADDR
// end ;
4363: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) = 0 and not first_apeman_tamed do
4364: LD_INT 22
4366: PUSH
4367: LD_INT 0
4369: PUSH
4370: EMPTY
4371: LIST
4372: LIST
4373: PUSH
4374: LD_INT 25
4376: PUSH
4377: LD_INT 12
4379: PUSH
4380: EMPTY
4381: LIST
4382: LIST
4383: PUSH
4384: EMPTY
4385: LIST
4386: LIST
4387: PPUSH
4388: CALL_OW 69
4392: PUSH
4393: LD_INT 0
4395: EQUAL
4396: PUSH
4397: LD_EXP 8
4401: NOT
4402: AND
4403: IFFALSE 4415
4405: GO 4407
4407: DISABLE
// YouLost ( Apeman ) ;
4408: LD_STRING Apeman
4410: PPUSH
4411: CALL_OW 104
4415: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) >= 7 do var i , filter ;
4416: LD_INT 22
4418: PUSH
4419: LD_INT 1
4421: PUSH
4422: EMPTY
4423: LIST
4424: LIST
4425: PUSH
4426: LD_INT 25
4428: PUSH
4429: LD_INT 16
4431: PUSH
4432: EMPTY
4433: LIST
4434: LIST
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: PPUSH
4440: CALL_OW 69
4444: PUSH
4445: LD_INT 7
4447: GREATEREQUAL
4448: IFFALSE 4546
4450: GO 4452
4452: DISABLE
4453: LD_INT 0
4455: PPUSH
4456: PPUSH
// begin filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , 4 ] ] ) ^ JMM ;
4457: LD_ADDR_VAR 0 2
4461: PUSH
4462: LD_INT 22
4464: PUSH
4465: LD_INT 1
4467: PUSH
4468: EMPTY
4469: LIST
4470: LIST
4471: PUSH
4472: LD_INT 21
4474: PUSH
4475: LD_INT 1
4477: PUSH
4478: EMPTY
4479: LIST
4480: LIST
4481: PUSH
4482: LD_INT 25
4484: PUSH
4485: LD_INT 4
4487: PUSH
4488: EMPTY
4489: LIST
4490: LIST
4491: PUSH
4492: EMPTY
4493: LIST
4494: LIST
4495: LIST
4496: PPUSH
4497: CALL_OW 69
4501: PUSH
4502: LD_EXP 16
4506: ADD
4507: ST_TO_ADDR
// if filter then
4508: LD_VAR 0 2
4512: IFFALSE 4546
// for i in filter do
4514: LD_ADDR_VAR 0 1
4518: PUSH
4519: LD_VAR 0 2
4523: PUSH
4524: FOR_IN
4525: IFFALSE 4544
// AddExperience ( i , 4 , 3500 ) ;
4527: LD_VAR 0 1
4531: PPUSH
4532: LD_INT 4
4534: PPUSH
4535: LD_INT 3500
4537: PPUSH
4538: CALL_OW 492
4542: GO 4524
4544: POP
4545: POP
// end ;
4546: PPOPN 2
4548: END
// every 0 0$1 trigger end_mission do var i , tmp , m1 , m2 , m3 ;
4549: LD_EXP 14
4553: IFFALSE 5687
4555: GO 4557
4557: DISABLE
4558: LD_INT 0
4560: PPUSH
4561: PPUSH
4562: PPUSH
4563: PPUSH
4564: PPUSH
// begin if apeKillCounter = 0 then
4565: LD_EXP 15
4569: PUSH
4570: LD_INT 0
4572: EQUAL
4573: IFFALSE 4582
// SetAchievement ( ACH_APEKILLER ) ;
4575: LD_STRING ACH_APEKILLER
4577: PPUSH
4578: CALL_OW 543
// if FilterAllUnits ( [ f_side , 2 ] ) then
4582: LD_INT 22
4584: PUSH
4585: LD_INT 2
4587: PUSH
4588: EMPTY
4589: LIST
4590: LIST
4591: PPUSH
4592: CALL_OW 69
4596: IFFALSE 4634
// for i in FilterAllUnits ( [ f_side , 2 ] ) do
4598: LD_ADDR_VAR 0 1
4602: PUSH
4603: LD_INT 22
4605: PUSH
4606: LD_INT 2
4608: PUSH
4609: EMPTY
4610: LIST
4611: LIST
4612: PPUSH
4613: CALL_OW 69
4617: PUSH
4618: FOR_IN
4619: IFFALSE 4632
// RemoveUnit ( i ) ;
4621: LD_VAR 0 1
4625: PPUSH
4626: CALL_OW 64
4630: GO 4618
4632: POP
4633: POP
// m1 := false ;
4634: LD_ADDR_VAR 0 3
4638: PUSH
4639: LD_INT 0
4641: ST_TO_ADDR
// m2 := false ;
4642: LD_ADDR_VAR 0 4
4646: PUSH
4647: LD_INT 0
4649: ST_TO_ADDR
// m3 := false ;
4650: LD_ADDR_VAR 0 5
4654: PUSH
4655: LD_INT 0
4657: ST_TO_ADDR
// if apeman_army then
4658: LD_EXP 9
4662: IFFALSE 4684
// begin AddMedal ( Tame , 1 ) ;
4664: LD_STRING Tame
4666: PPUSH
4667: LD_INT 1
4669: PPUSH
4670: CALL_OW 101
// m1 := true ;
4674: LD_ADDR_VAR 0 3
4678: PUSH
4679: LD_INT 1
4681: ST_TO_ADDR
// end else
4682: GO 4695
// AddMedal ( Tame , - 1 ) ;
4684: LD_STRING Tame
4686: PPUSH
4687: LD_INT 1
4689: NEG
4690: PPUSH
4691: CALL_OW 101
// if radar_researched then
4695: LD_EXP 10
4699: IFFALSE 4731
// begin SaveVariable ( true , radarResInDelta ) ;
4701: LD_INT 1
4703: PPUSH
4704: LD_STRING radarResInDelta
4706: PPUSH
4707: CALL_OW 39
// AddMedal ( Radar , 1 ) ;
4711: LD_STRING Radar
4713: PPUSH
4714: LD_INT 1
4716: PPUSH
4717: CALL_OW 101
// m2 := true ;
4721: LD_ADDR_VAR 0 4
4725: PUSH
4726: LD_INT 1
4728: ST_TO_ADDR
// end else
4729: GO 4761
// if radar_allowed then
4731: LD_EXP 7
4735: IFFALSE 4750
// AddMedal ( Radar , - 2 ) else
4737: LD_STRING Radar
4739: PPUSH
4740: LD_INT 2
4742: NEG
4743: PPUSH
4744: CALL_OW 101
4748: GO 4761
// AddMedal ( Radar , - 1 ) ;
4750: LD_STRING Radar
4752: PPUSH
4753: LD_INT 1
4755: NEG
4756: PPUSH
4757: CALL_OW 101
// if radar_builded then
4761: LD_EXP 11
4765: IFFALSE 4787
// begin AddMedal ( BuildRadar , 1 ) ;
4767: LD_STRING BuildRadar
4769: PPUSH
4770: LD_INT 1
4772: PPUSH
4773: CALL_OW 101
// m3 := true ;
4777: LD_ADDR_VAR 0 5
4781: PUSH
4782: LD_INT 1
4784: ST_TO_ADDR
// end else
4785: GO 4798
// AddMedal ( BuildRadar , - 1 ) ;
4787: LD_STRING BuildRadar
4789: PPUSH
4790: LD_INT 1
4792: NEG
4793: PPUSH
4794: CALL_OW 101
// if tick <= 7 7$00 then
4798: LD_OWVAR 1
4802: PUSH
4803: LD_INT 14700
4805: LESSEQUAL
4806: IFFALSE 4815
// SetAchievement ( ACH_ASPEED_5 ) ;
4808: LD_STRING ACH_ASPEED_5
4810: PPUSH
4811: CALL_OW 543
// if m1 and m2 and m3 and Difficulty = 3 then
4815: LD_VAR 0 3
4819: PUSH
4820: LD_VAR 0 4
4824: AND
4825: PUSH
4826: LD_VAR 0 5
4830: AND
4831: PUSH
4832: LD_OWVAR 67
4836: PUSH
4837: LD_INT 3
4839: EQUAL
4840: AND
4841: IFFALSE 4853
// SetAchievementEX ( ACH_AMER , 5 ) ;
4843: LD_STRING ACH_AMER
4845: PPUSH
4846: LD_INT 5
4848: PPUSH
4849: CALL_OW 564
// GiveMedals ( MAIN ) ;
4853: LD_STRING MAIN
4855: PPUSH
4856: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
4860: LD_ADDR_VAR 0 2
4864: PUSH
4865: LD_INT 22
4867: PUSH
4868: LD_INT 1
4870: PUSH
4871: EMPTY
4872: LIST
4873: LIST
4874: PUSH
4875: LD_INT 21
4877: PUSH
4878: LD_INT 1
4880: PUSH
4881: EMPTY
4882: LIST
4883: LIST
4884: PUSH
4885: LD_INT 2
4887: PUSH
4888: LD_INT 25
4890: PUSH
4891: LD_INT 1
4893: PUSH
4894: EMPTY
4895: LIST
4896: LIST
4897: PUSH
4898: LD_INT 25
4900: PUSH
4901: LD_INT 2
4903: PUSH
4904: EMPTY
4905: LIST
4906: LIST
4907: PUSH
4908: LD_INT 25
4910: PUSH
4911: LD_INT 3
4913: PUSH
4914: EMPTY
4915: LIST
4916: LIST
4917: PUSH
4918: LD_INT 25
4920: PUSH
4921: LD_INT 4
4923: PUSH
4924: EMPTY
4925: LIST
4926: LIST
4927: PUSH
4928: EMPTY
4929: LIST
4930: LIST
4931: LIST
4932: LIST
4933: LIST
4934: PUSH
4935: EMPTY
4936: LIST
4937: LIST
4938: LIST
4939: PPUSH
4940: CALL_OW 69
4944: ST_TO_ADDR
// RewardPeople ( tmp ) ;
4945: LD_VAR 0 2
4949: PPUSH
4950: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
4954: LD_EXP 16
4958: PPUSH
4959: LD_EXP 2
4963: PUSH
4964: LD_STRING JMM
4966: STR
4967: PPUSH
4968: CALL_OW 38
// if IsOk ( Gladstone ) then
4972: LD_EXP 17
4976: PPUSH
4977: CALL_OW 302
4981: IFFALSE 5001
// begin SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
4983: LD_EXP 17
4987: PPUSH
4988: LD_EXP 2
4992: PUSH
4993: LD_STRING Gladstone
4995: STR
4996: PPUSH
4997: CALL_OW 38
// end ; if IsOk ( Denis ) and GetSide ( Denis ) = 1 then
5001: LD_EXP 19
5005: PPUSH
5006: CALL_OW 302
5010: PUSH
5011: LD_EXP 19
5015: PPUSH
5016: CALL_OW 255
5020: PUSH
5021: LD_INT 1
5023: EQUAL
5024: AND
5025: IFFALSE 5055
// begin SaveCharacters ( Denis , mission_prefix & Denis ) ;
5027: LD_EXP 19
5031: PPUSH
5032: LD_EXP 2
5036: PUSH
5037: LD_STRING Denis
5039: STR
5040: PPUSH
5041: CALL_OW 38
// SaveVariable ( true , DenisInDelta ) ;
5045: LD_INT 1
5047: PPUSH
5048: LD_STRING DenisInDelta
5050: PPUSH
5051: CALL_OW 39
// end ; if IsOk ( Lisa ) then
5055: LD_EXP 22
5059: PPUSH
5060: CALL_OW 302
5064: IFFALSE 5084
// begin SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
5066: LD_EXP 22
5070: PPUSH
5071: LD_EXP 2
5075: PUSH
5076: LD_STRING Lisa
5078: STR
5079: PPUSH
5080: CALL_OW 38
// end ; if IsOk ( Frank ) then
5084: LD_EXP 23
5088: PPUSH
5089: CALL_OW 302
5093: IFFALSE 5113
// begin SaveCharacters ( Frank , mission_prefix & Frank ) ;
5095: LD_EXP 23
5099: PPUSH
5100: LD_EXP 2
5104: PUSH
5105: LD_STRING Frank
5107: STR
5108: PPUSH
5109: CALL_OW 38
// end ; if IsOk ( Bobby ) then
5113: LD_EXP 24
5117: PPUSH
5118: CALL_OW 302
5122: IFFALSE 5142
// begin SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
5124: LD_EXP 24
5128: PPUSH
5129: LD_EXP 2
5133: PUSH
5134: LD_STRING Bobby
5136: STR
5137: PPUSH
5138: CALL_OW 38
// end ; if IsOk ( Cyrus ) then
5142: LD_EXP 25
5146: PPUSH
5147: CALL_OW 302
5151: IFFALSE 5171
// begin SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
5153: LD_EXP 25
5157: PPUSH
5158: LD_EXP 2
5162: PUSH
5163: LD_STRING Cyrus
5165: STR
5166: PPUSH
5167: CALL_OW 38
// end ; if IsOk ( Brown ) then
5171: LD_EXP 20
5175: PPUSH
5176: CALL_OW 302
5180: IFFALSE 5200
// begin SaveCharacters ( Brown , mission_prefix & Brown ) ;
5182: LD_EXP 20
5186: PPUSH
5187: LD_EXP 2
5191: PUSH
5192: LD_STRING Brown
5194: STR
5195: PPUSH
5196: CALL_OW 38
// end ; if IsOk ( Donaldson ) then
5200: LD_EXP 21
5204: PPUSH
5205: CALL_OW 302
5209: IFFALSE 5229
// begin SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
5211: LD_EXP 21
5215: PPUSH
5216: LD_EXP 2
5220: PUSH
5221: LD_STRING Donaldson
5223: STR
5224: PPUSH
5225: CALL_OW 38
// end ; if others then
5229: LD_EXP 26
5233: IFFALSE 5247
// SaveCharacters ( others , othersInDelta ) ;
5235: LD_EXP 26
5239: PPUSH
5240: LD_STRING othersInDelta
5242: PPUSH
5243: CALL_OW 38
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) then
5247: LD_INT 22
5249: PUSH
5250: LD_INT 1
5252: PUSH
5253: EMPTY
5254: LIST
5255: LIST
5256: PUSH
5257: LD_INT 25
5259: PUSH
5260: LD_INT 16
5262: PUSH
5263: EMPTY
5264: LIST
5265: LIST
5266: PUSH
5267: EMPTY
5268: LIST
5269: LIST
5270: PPUSH
5271: CALL_OW 69
5275: IFFALSE 5313
// SaveCharacters ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) , apeInDelta ) ;
5277: LD_INT 22
5279: PUSH
5280: LD_INT 1
5282: PUSH
5283: EMPTY
5284: LIST
5285: LIST
5286: PUSH
5287: LD_INT 25
5289: PUSH
5290: LD_INT 16
5292: PUSH
5293: EMPTY
5294: LIST
5295: LIST
5296: PUSH
5297: EMPTY
5298: LIST
5299: LIST
5300: PPUSH
5301: CALL_OW 69
5305: PPUSH
5306: LD_STRING apeInDelta
5308: PPUSH
5309: CALL_OW 38
// tmp := [ ] ;
5313: LD_ADDR_VAR 0 2
5317: PUSH
5318: EMPTY
5319: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) then
5320: LD_INT 22
5322: PUSH
5323: LD_INT 1
5325: PUSH
5326: EMPTY
5327: LIST
5328: LIST
5329: PUSH
5330: LD_INT 21
5332: PUSH
5333: LD_INT 2
5335: PUSH
5336: EMPTY
5337: LIST
5338: LIST
5339: PUSH
5340: EMPTY
5341: LIST
5342: LIST
5343: PPUSH
5344: CALL_OW 69
5348: IFFALSE 5459
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) do
5350: LD_ADDR_VAR 0 1
5354: PUSH
5355: LD_INT 22
5357: PUSH
5358: LD_INT 1
5360: PUSH
5361: EMPTY
5362: LIST
5363: LIST
5364: PUSH
5365: LD_INT 21
5367: PUSH
5368: LD_INT 2
5370: PUSH
5371: EMPTY
5372: LIST
5373: LIST
5374: PUSH
5375: EMPTY
5376: LIST
5377: LIST
5378: PPUSH
5379: CALL_OW 69
5383: PUSH
5384: FOR_IN
5385: IFFALSE 5457
// tmp := tmp ^ [ GetNation ( i ) , GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) ] ;
5387: LD_ADDR_VAR 0 2
5391: PUSH
5392: LD_VAR 0 2
5396: PUSH
5397: LD_VAR 0 1
5401: PPUSH
5402: CALL_OW 248
5406: PUSH
5407: LD_VAR 0 1
5411: PPUSH
5412: CALL_OW 265
5416: PUSH
5417: LD_VAR 0 1
5421: PPUSH
5422: CALL_OW 262
5426: PUSH
5427: LD_VAR 0 1
5431: PPUSH
5432: CALL_OW 263
5436: PUSH
5437: LD_VAR 0 1
5441: PPUSH
5442: CALL_OW 264
5446: PUSH
5447: EMPTY
5448: LIST
5449: LIST
5450: LIST
5451: LIST
5452: LIST
5453: ADD
5454: ST_TO_ADDR
5455: GO 5384
5457: POP
5458: POP
// if tmp then
5459: LD_VAR 0 2
5463: IFFALSE 5477
// SaveVariable ( tmp , vehiclesInDelta ) ;
5465: LD_VAR 0 2
5469: PPUSH
5470: LD_STRING vehiclesInDelta
5472: PPUSH
5473: CALL_OW 39
// tmp := [ ] ;
5477: LD_ADDR_VAR 0 2
5481: PUSH
5482: EMPTY
5483: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) then
5484: LD_INT 22
5486: PUSH
5487: LD_INT 1
5489: PUSH
5490: EMPTY
5491: LIST
5492: LIST
5493: PUSH
5494: LD_INT 21
5496: PUSH
5497: LD_INT 3
5499: PUSH
5500: EMPTY
5501: LIST
5502: LIST
5503: PUSH
5504: EMPTY
5505: LIST
5506: LIST
5507: PPUSH
5508: CALL_OW 69
5512: IFFALSE 5665
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
5514: LD_ADDR_VAR 0 1
5518: PUSH
5519: LD_INT 22
5521: PUSH
5522: LD_INT 1
5524: PUSH
5525: EMPTY
5526: LIST
5527: LIST
5528: PUSH
5529: LD_INT 21
5531: PUSH
5532: LD_INT 3
5534: PUSH
5535: EMPTY
5536: LIST
5537: LIST
5538: PUSH
5539: EMPTY
5540: LIST
5541: LIST
5542: PPUSH
5543: CALL_OW 69
5547: PUSH
5548: FOR_IN
5549: IFFALSE 5663
// tmp := tmp ^ [ [ GetBType ( i ) , GetBLevel ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
5551: LD_ADDR_VAR 0 2
5555: PUSH
5556: LD_VAR 0 2
5560: PUSH
5561: LD_VAR 0 1
5565: PPUSH
5566: CALL_OW 266
5570: PUSH
5571: LD_VAR 0 1
5575: PPUSH
5576: CALL_OW 267
5580: PUSH
5581: LD_VAR 0 1
5585: PPUSH
5586: CALL_OW 250
5590: PUSH
5591: LD_VAR 0 1
5595: PPUSH
5596: CALL_OW 251
5600: PUSH
5601: LD_VAR 0 1
5605: PPUSH
5606: CALL_OW 254
5610: PUSH
5611: LD_VAR 0 1
5615: PPUSH
5616: LD_INT 1
5618: PPUSH
5619: CALL_OW 268
5623: PUSH
5624: LD_VAR 0 1
5628: PPUSH
5629: LD_INT 2
5631: PPUSH
5632: CALL_OW 268
5636: PUSH
5637: LD_VAR 0 1
5641: PPUSH
5642: CALL_OW 269
5646: PUSH
5647: EMPTY
5648: LIST
5649: LIST
5650: LIST
5651: LIST
5652: LIST
5653: LIST
5654: LIST
5655: LIST
5656: PUSH
5657: EMPTY
5658: LIST
5659: ADD
5660: ST_TO_ADDR
5661: GO 5548
5663: POP
5664: POP
// if tmp then
5665: LD_VAR 0 2
5669: IFFALSE 5683
// SaveVariable ( tmp , buildingsInDelta ) ;
5671: LD_VAR 0 2
5675: PPUSH
5676: LD_STRING buildingsInDelta
5678: PPUSH
5679: CALL_OW 39
// YouWin ;
5683: CALL_OW 103
// end ; end_of_file
5687: PPOPN 5
5689: END
// export function PrepareArabianTroops ( amount , skill , area ) ; var i , un , tmp ; begin
5690: LD_INT 0
5692: PPUSH
5693: PPUSH
5694: PPUSH
5695: PPUSH
// InitHc ;
5696: CALL_OW 19
// InitUc ;
5700: CALL_OW 18
// uc_side := 2 ;
5704: LD_ADDR_OWVAR 20
5708: PUSH
5709: LD_INT 2
5711: ST_TO_ADDR
// uc_nation := 2 ;
5712: LD_ADDR_OWVAR 21
5716: PUSH
5717: LD_INT 2
5719: ST_TO_ADDR
// if not amount then
5720: LD_VAR 0 1
5724: NOT
5725: IFFALSE 5729
// exit ;
5727: GO 5852
// for i = 1 to amount do
5729: LD_ADDR_VAR 0 5
5733: PUSH
5734: DOUBLE
5735: LD_INT 1
5737: DEC
5738: ST_TO_ADDR
5739: LD_VAR 0 1
5743: PUSH
5744: FOR_TO
5745: IFFALSE 5840
// begin PrepareHuman ( false , 1 , skill ) ;
5747: LD_INT 0
5749: PPUSH
5750: LD_INT 1
5752: PPUSH
5753: LD_VAR 0 2
5757: PPUSH
5758: CALL_OW 380
// un := CreateHuman ;
5762: LD_ADDR_VAR 0 6
5766: PUSH
5767: CALL_OW 44
5771: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
5772: LD_ADDR_VAR 0 7
5776: PUSH
5777: LD_VAR 0 7
5781: PPUSH
5782: LD_INT 1
5784: PPUSH
5785: LD_VAR 0 6
5789: PPUSH
5790: CALL_OW 2
5794: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5795: LD_VAR 0 6
5799: PPUSH
5800: LD_VAR 0 3
5804: PPUSH
5805: LD_INT 0
5807: PPUSH
5808: CALL_OW 49
// if i mod 2 = 0 then
5812: LD_VAR 0 5
5816: PUSH
5817: LD_INT 2
5819: MOD
5820: PUSH
5821: LD_INT 0
5823: EQUAL
5824: IFFALSE 5838
// SetTag ( un , 11 ) ;
5826: LD_VAR 0 6
5830: PPUSH
5831: LD_INT 11
5833: PPUSH
5834: CALL_OW 109
// end ;
5838: GO 5744
5840: POP
5841: POP
// result := tmp ;
5842: LD_ADDR_VAR 0 4
5846: PUSH
5847: LD_VAR 0 7
5851: ST_TO_ADDR
// end ;
5852: LD_VAR 0 4
5856: RET
// export ar_forces , ap_killers ; every 0 0$1 trigger Delta do var i , timer , more_troops , skill , eng , un , veh , force ;
5857: LD_EXP 6
5861: IFFALSE 6728
5863: GO 5865
5865: DISABLE
5866: LD_INT 0
5868: PPUSH
5869: PPUSH
5870: PPUSH
5871: PPUSH
5872: PPUSH
5873: PPUSH
5874: PPUSH
5875: PPUSH
// begin more_troops := false ;
5876: LD_ADDR_VAR 0 3
5880: PUSH
5881: LD_INT 0
5883: ST_TO_ADDR
// skill := [ 3 , 4 , 5 ] [ Difficulty ] ;
5884: LD_ADDR_VAR 0 4
5888: PUSH
5889: LD_INT 3
5891: PUSH
5892: LD_INT 4
5894: PUSH
5895: LD_INT 5
5897: PUSH
5898: EMPTY
5899: LIST
5900: LIST
5901: LIST
5902: PUSH
5903: LD_OWVAR 67
5907: ARRAY
5908: ST_TO_ADDR
// timer := [ 5 5$00 , 4 4$00 , 3 3$00 ] [ Difficulty ] ;
5909: LD_ADDR_VAR 0 2
5913: PUSH
5914: LD_INT 10500
5916: PUSH
5917: LD_INT 8400
5919: PUSH
5920: LD_INT 6300
5922: PUSH
5923: EMPTY
5924: LIST
5925: LIST
5926: LIST
5927: PUSH
5928: LD_OWVAR 67
5932: ARRAY
5933: ST_TO_ADDR
// force := [ ] ;
5934: LD_ADDR_VAR 0 8
5938: PUSH
5939: EMPTY
5940: ST_TO_ADDR
// ar_forces := [ ] ;
5941: LD_ADDR_EXP 27
5945: PUSH
5946: EMPTY
5947: ST_TO_ADDR
// ap_killers := [ ] ;
5948: LD_ADDR_EXP 28
5952: PUSH
5953: EMPTY
5954: ST_TO_ADDR
// Wait ( timer ) ;
5955: LD_VAR 0 2
5959: PPUSH
5960: CALL_OW 67
// if Denis and GetSide ( Denis ) = 4 then
5964: LD_EXP 19
5968: PUSH
5969: LD_EXP 19
5973: PPUSH
5974: CALL_OW 255
5978: PUSH
5979: LD_INT 4
5981: EQUAL
5982: AND
5983: IFFALSE 5992
// Wait ( 0 0$45 ) ;
5985: LD_INT 1575
5987: PPUSH
5988: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) then
5992: LD_INT 22
5994: PUSH
5995: LD_INT 1
5997: PUSH
5998: EMPTY
5999: LIST
6000: LIST
6001: PUSH
6002: LD_INT 30
6004: PUSH
6005: LD_INT 4
6007: PUSH
6008: EMPTY
6009: LIST
6010: LIST
6011: PUSH
6012: EMPTY
6013: LIST
6014: LIST
6015: PPUSH
6016: CALL_OW 69
6020: IFFALSE 6037
// begin Wait ( 1 1$25 ) ;
6022: LD_INT 2975
6024: PPUSH
6025: CALL_OW 67
// more_troops := true ;
6029: LD_ADDR_VAR 0 3
6033: PUSH
6034: LD_INT 1
6036: ST_TO_ADDR
// end ; if more_troops then
6037: LD_VAR 0 3
6041: IFFALSE 6229
// begin force := PrepareArabianTroops ( [ 4 , 5 , 6 ] [ Difficulty ] , skill , arArea2 ) ;
6043: LD_ADDR_VAR 0 8
6047: PUSH
6048: LD_INT 4
6050: PUSH
6051: LD_INT 5
6053: PUSH
6054: LD_INT 6
6056: PUSH
6057: EMPTY
6058: LIST
6059: LIST
6060: LIST
6061: PUSH
6062: LD_OWVAR 67
6066: ARRAY
6067: PPUSH
6068: LD_VAR 0 4
6072: PPUSH
6073: LD_INT 14
6075: PPUSH
6076: CALL 5690 0 3
6080: ST_TO_ADDR
// veh := PrepareTank ( 2 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_heavy_machine_gun , ru_gatling_gun ] [ Difficulty ] , 90 ) ;
6081: LD_ADDR_VAR 0 7
6085: PUSH
6086: LD_INT 2
6088: PPUSH
6089: LD_INT 3
6091: PPUSH
6092: LD_INT 22
6094: PPUSH
6095: LD_INT 1
6097: PPUSH
6098: LD_INT 1
6100: PPUSH
6101: LD_INT 42
6103: PUSH
6104: LD_INT 42
6106: PUSH
6107: LD_INT 43
6109: PUSH
6110: EMPTY
6111: LIST
6112: LIST
6113: LIST
6114: PUSH
6115: LD_OWVAR 67
6119: ARRAY
6120: PPUSH
6121: LD_INT 90
6123: PPUSH
6124: CALL 490 0 7
6128: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
6129: LD_VAR 0 7
6133: PPUSH
6134: LD_INT 4
6136: PPUSH
6137: CALL_OW 233
// PlaceUnitArea ( veh , arArea1 , false ) ;
6141: LD_VAR 0 7
6145: PPUSH
6146: LD_INT 13
6148: PPUSH
6149: LD_INT 0
6151: PPUSH
6152: CALL_OW 49
// uc_side := 2 ;
6156: LD_ADDR_OWVAR 20
6160: PUSH
6161: LD_INT 2
6163: ST_TO_ADDR
// uc_nation := 2 ;
6164: LD_ADDR_OWVAR 21
6168: PUSH
6169: LD_INT 2
6171: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
6172: LD_INT 0
6174: PPUSH
6175: LD_INT 1
6177: PPUSH
6178: LD_VAR 0 4
6182: PPUSH
6183: CALL_OW 380
// un := CreateHuman ;
6187: LD_ADDR_VAR 0 6
6191: PUSH
6192: CALL_OW 44
6196: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
6197: LD_VAR 0 6
6201: PPUSH
6202: LD_VAR 0 7
6206: PPUSH
6207: CALL_OW 52
// force := force ^ un ;
6211: LD_ADDR_VAR 0 8
6215: PUSH
6216: LD_VAR 0 8
6220: PUSH
6221: LD_VAR 0 6
6225: ADD
6226: ST_TO_ADDR
// end else
6227: GO 6267
// begin force := PrepareArabianTroops ( [ 3 , 4 , 5 ] [ Difficulty ] , skill , arArea2 ) ;
6229: LD_ADDR_VAR 0 8
6233: PUSH
6234: LD_INT 3
6236: PUSH
6237: LD_INT 4
6239: PUSH
6240: LD_INT 5
6242: PUSH
6243: EMPTY
6244: LIST
6245: LIST
6246: LIST
6247: PUSH
6248: LD_OWVAR 67
6252: ARRAY
6253: PPUSH
6254: LD_VAR 0 4
6258: PPUSH
6259: LD_INT 14
6261: PPUSH
6262: CALL 5690 0 3
6266: ST_TO_ADDR
// end ; if force then
6267: LD_VAR 0 8
6271: IFFALSE 6283
// ar_forces := force ;
6273: LD_ADDR_EXP 27
6277: PUSH
6278: LD_VAR 0 8
6282: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
6283: LD_INT 35
6285: PPUSH
6286: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 ;
6290: LD_INT 22
6292: PUSH
6293: LD_INT 2
6295: PUSH
6296: EMPTY
6297: LIST
6298: LIST
6299: PUSH
6300: LD_INT 21
6302: PUSH
6303: LD_INT 1
6305: PUSH
6306: EMPTY
6307: LIST
6308: LIST
6309: PUSH
6310: EMPTY
6311: LIST
6312: LIST
6313: PPUSH
6314: CALL_OW 69
6318: PUSH
6319: LD_INT 0
6321: EQUAL
6322: IFFALSE 6283
// Wait ( timer ) ;
6324: LD_VAR 0 2
6328: PPUSH
6329: CALL_OW 67
// force := PrepareArabianTroops ( [ 4 , 5 , 6 ] [ Difficulty ] , skill , [ arArea1 , arArea2 ] [ rand ( 1 , 2 ) ] ) ;
6333: LD_ADDR_VAR 0 8
6337: PUSH
6338: LD_INT 4
6340: PUSH
6341: LD_INT 5
6343: PUSH
6344: LD_INT 6
6346: PUSH
6347: EMPTY
6348: LIST
6349: LIST
6350: LIST
6351: PUSH
6352: LD_OWVAR 67
6356: ARRAY
6357: PPUSH
6358: LD_VAR 0 4
6362: PPUSH
6363: LD_INT 13
6365: PUSH
6366: LD_INT 14
6368: PUSH
6369: EMPTY
6370: LIST
6371: LIST
6372: PUSH
6373: LD_INT 1
6375: PPUSH
6376: LD_INT 2
6378: PPUSH
6379: CALL_OW 12
6383: ARRAY
6384: PPUSH
6385: CALL 5690 0 3
6389: ST_TO_ADDR
// if Difficulty > 1 and Delta then
6390: LD_OWVAR 67
6394: PUSH
6395: LD_INT 1
6397: GREATER
6398: PUSH
6399: LD_EXP 6
6403: AND
6404: IFFALSE 6483
// begin uc_side := 2 ;
6406: LD_ADDR_OWVAR 20
6410: PUSH
6411: LD_INT 2
6413: ST_TO_ADDR
// uc_nation := 2 ;
6414: LD_ADDR_OWVAR 21
6418: PUSH
6419: LD_INT 2
6421: ST_TO_ADDR
// PrepareHuman ( false , 2 , skill ) ;
6422: LD_INT 0
6424: PPUSH
6425: LD_INT 2
6427: PPUSH
6428: LD_VAR 0 4
6432: PPUSH
6433: CALL_OW 380
// eng := CreateHuman ;
6437: LD_ADDR_VAR 0 5
6441: PUSH
6442: CALL_OW 44
6446: ST_TO_ADDR
// PlaceUnitArea ( eng , arArea1 , false ) ;
6447: LD_VAR 0 5
6451: PPUSH
6452: LD_INT 13
6454: PPUSH
6455: LD_INT 0
6457: PPUSH
6458: CALL_OW 49
// Wait ( 3 ) ;
6462: LD_INT 3
6464: PPUSH
6465: CALL_OW 67
// AddComEnterUnit ( eng , Delta ) ;
6469: LD_VAR 0 5
6473: PPUSH
6474: LD_EXP 6
6478: PPUSH
6479: CALL_OW 180
// end ; if force then
6483: LD_VAR 0 8
6487: IFFALSE 6499
// ar_forces := force ;
6489: LD_ADDR_EXP 27
6493: PUSH
6494: LD_VAR 0 8
6498: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
6499: LD_INT 35
6501: PPUSH
6502: CALL_OW 67
// if eng then
6506: LD_VAR 0 5
6510: IFFALSE 6564
// if GetSide ( Delta ) = 2 and IsOk ( eng ) and not IsInUnit ( eng ) then
6512: LD_EXP 6
6516: PPUSH
6517: CALL_OW 255
6521: PUSH
6522: LD_INT 2
6524: EQUAL
6525: PUSH
6526: LD_VAR 0 5
6530: PPUSH
6531: CALL_OW 302
6535: AND
6536: PUSH
6537: LD_VAR 0 5
6541: PPUSH
6542: CALL_OW 310
6546: NOT
6547: AND
6548: IFFALSE 6564
// ComEnterUnit ( eng , Delta ) ;
6550: LD_VAR 0 5
6554: PPUSH
6555: LD_EXP 6
6559: PPUSH
6560: CALL_OW 120
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 ;
6564: LD_INT 22
6566: PUSH
6567: LD_INT 2
6569: PUSH
6570: EMPTY
6571: LIST
6572: LIST
6573: PUSH
6574: LD_INT 21
6576: PUSH
6577: LD_INT 1
6579: PUSH
6580: EMPTY
6581: LIST
6582: LIST
6583: PUSH
6584: EMPTY
6585: LIST
6586: LIST
6587: PPUSH
6588: CALL_OW 69
6592: PUSH
6593: LD_INT 0
6595: EQUAL
6596: IFFALSE 6499
// Wait ( 2 2$00 ) ;
6598: LD_INT 4200
6600: PPUSH
6601: CALL_OW 67
// ap_killers := PrepareArabianTroops ( [ 1 , 2 , 2 ] [ Difficulty ] , skill , arArea1 ) ;
6605: LD_ADDR_EXP 28
6609: PUSH
6610: LD_INT 1
6612: PUSH
6613: LD_INT 2
6615: PUSH
6616: LD_INT 2
6618: PUSH
6619: EMPTY
6620: LIST
6621: LIST
6622: LIST
6623: PUSH
6624: LD_OWVAR 67
6628: ARRAY
6629: PPUSH
6630: LD_VAR 0 4
6634: PPUSH
6635: LD_INT 13
6637: PPUSH
6638: CALL 5690 0 3
6642: ST_TO_ADDR
// Wait ( timer * 2 ) ;
6643: LD_VAR 0 2
6647: PUSH
6648: LD_INT 2
6650: MUL
6651: PPUSH
6652: CALL_OW 67
// ar_forces := PrepareArabianTroops ( [ 5 , 6 , 7 ] [ Difficulty ] , skill , arArea1 ) ^ PrepareArabianTroops ( [ 3 , 4 , 4 ] [ Difficulty ] , skill , arArea2 ) ;
6656: LD_ADDR_EXP 27
6660: PUSH
6661: LD_INT 5
6663: PUSH
6664: LD_INT 6
6666: PUSH
6667: LD_INT 7
6669: PUSH
6670: EMPTY
6671: LIST
6672: LIST
6673: LIST
6674: PUSH
6675: LD_OWVAR 67
6679: ARRAY
6680: PPUSH
6681: LD_VAR 0 4
6685: PPUSH
6686: LD_INT 13
6688: PPUSH
6689: CALL 5690 0 3
6693: PUSH
6694: LD_INT 3
6696: PUSH
6697: LD_INT 4
6699: PUSH
6700: LD_INT 4
6702: PUSH
6703: EMPTY
6704: LIST
6705: LIST
6706: LIST
6707: PUSH
6708: LD_OWVAR 67
6712: ARRAY
6713: PPUSH
6714: LD_VAR 0 4
6718: PPUSH
6719: LD_INT 14
6721: PPUSH
6722: CALL 5690 0 3
6726: ADD
6727: ST_TO_ADDR
// end ;
6728: PPOPN 8
6730: END
// every 0 0$03 trigger ar_forces do var i , target ;
6731: LD_EXP 27
6735: IFFALSE 6933
6737: GO 6739
6739: DISABLE
6740: LD_INT 0
6742: PPUSH
6743: PPUSH
// begin enable ;
6744: ENABLE
// if not ar_forces then
6745: LD_EXP 27
6749: NOT
6750: IFFALSE 6754
// exit ;
6752: GO 6933
// if Delta then
6754: LD_EXP 6
6758: IFFALSE 6772
// target := Delta else
6760: LD_ADDR_VAR 0 2
6764: PUSH
6765: LD_EXP 6
6769: ST_TO_ADDR
6770: GO 6782
// target := JMM ;
6772: LD_ADDR_VAR 0 2
6776: PUSH
6777: LD_EXP 16
6781: ST_TO_ADDR
// for i in ar_forces do
6782: LD_ADDR_VAR 0 1
6786: PUSH
6787: LD_EXP 27
6791: PUSH
6792: FOR_IN
6793: IFFALSE 6931
// begin if i in FilterAllUnits ( [ f_driving ] ) then
6795: LD_VAR 0 1
6799: PUSH
6800: LD_INT 55
6802: PUSH
6803: EMPTY
6804: LIST
6805: PPUSH
6806: CALL_OW 69
6810: IN
6811: IFFALSE 6854
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , IsInUnit ( i ) ) ) else
6813: LD_VAR 0 1
6817: PPUSH
6818: LD_INT 22
6820: PUSH
6821: LD_INT 1
6823: PUSH
6824: EMPTY
6825: LIST
6826: LIST
6827: PPUSH
6828: CALL_OW 69
6832: PPUSH
6833: LD_VAR 0 1
6837: PPUSH
6838: CALL_OW 310
6842: PPUSH
6843: CALL_OW 74
6847: PPUSH
6848: CALL_OW 115
6852: GO 6929
// if GetDistUnits ( i , target ) > 30 then
6854: LD_VAR 0 1
6858: PPUSH
6859: LD_VAR 0 2
6863: PPUSH
6864: CALL_OW 296
6868: PUSH
6869: LD_INT 30
6871: GREATER
6872: IFFALSE 6905
// ComAgressiveMove ( i , GetX ( target ) , GetY ( target ) ) else
6874: LD_VAR 0 1
6878: PPUSH
6879: LD_VAR 0 2
6883: PPUSH
6884: CALL_OW 250
6888: PPUSH
6889: LD_VAR 0 2
6893: PPUSH
6894: CALL_OW 251
6898: PPUSH
6899: CALL_OW 114
6903: GO 6929
// Attack ( i , FilterAllUnits ( [ f_enemy , 2 ] ) ) ;
6905: LD_VAR 0 1
6909: PPUSH
6910: LD_INT 81
6912: PUSH
6913: LD_INT 2
6915: PUSH
6916: EMPTY
6917: LIST
6918: LIST
6919: PPUSH
6920: CALL_OW 69
6924: PPUSH
6925: CALL 795 0 2
// end ;
6929: GO 6792
6931: POP
6932: POP
// end ;
6933: PPOPN 2
6935: END
// every 0 0$01 trigger ap_killers do var filter , i , target ;
6936: LD_EXP 28
6940: IFFALSE 7100
6942: GO 6944
6944: DISABLE
6945: LD_INT 0
6947: PPUSH
6948: PPUSH
6949: PPUSH
// begin enable ;
6950: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) ;
6951: LD_ADDR_VAR 0 1
6955: PUSH
6956: LD_INT 22
6958: PUSH
6959: LD_INT 0
6961: PUSH
6962: EMPTY
6963: LIST
6964: LIST
6965: PUSH
6966: LD_INT 25
6968: PUSH
6969: LD_INT 12
6971: PUSH
6972: EMPTY
6973: LIST
6974: LIST
6975: PUSH
6976: EMPTY
6977: LIST
6978: LIST
6979: PPUSH
6980: CALL_OW 69
6984: ST_TO_ADDR
// if not filter then
6985: LD_VAR 0 1
6989: NOT
6990: IFFALSE 7017
// begin ar_forces := ar_forces ^ ap_killers ;
6992: LD_ADDR_EXP 27
6996: PUSH
6997: LD_EXP 27
7001: PUSH
7002: LD_EXP 28
7006: ADD
7007: ST_TO_ADDR
// ap_killers := [ ] ;
7008: LD_ADDR_EXP 28
7012: PUSH
7013: EMPTY
7014: ST_TO_ADDR
// exit ;
7015: GO 7100
// end ; for i in ap_killers do
7017: LD_ADDR_VAR 0 2
7021: PUSH
7022: LD_EXP 28
7026: PUSH
7027: FOR_IN
7028: IFFALSE 7098
// begin if not IsOk ( i ) then
7030: LD_VAR 0 2
7034: PPUSH
7035: CALL_OW 302
7039: NOT
7040: IFFALSE 7044
// continue ;
7042: GO 7027
// if not HasTask ( i ) then
7044: LD_VAR 0 2
7048: PPUSH
7049: CALL_OW 314
7053: NOT
7054: IFFALSE 7076
// target := NearestUnitToUnit ( filter , i ) ;
7056: LD_ADDR_VAR 0 3
7060: PUSH
7061: LD_VAR 0 1
7065: PPUSH
7066: LD_VAR 0 2
7070: PPUSH
7071: CALL_OW 74
7075: ST_TO_ADDR
// if target then
7076: LD_VAR 0 3
7080: IFFALSE 7096
// ComAttackUnit ( i , target ) ;
7082: LD_VAR 0 2
7086: PPUSH
7087: LD_VAR 0 3
7091: PPUSH
7092: CALL_OW 115
// end ;
7096: GO 7027
7098: POP
7099: POP
// end ; end_of_file
7100: PPOPN 3
7102: END
// every 0 0$40 + 0 0$2 trigger Delta do var i , counter , cr ;
7103: LD_EXP 6
7107: IFFALSE 7239
7109: GO 7111
7111: DISABLE
7112: LD_INT 0
7114: PPUSH
7115: PPUSH
7116: PPUSH
// begin counter := [ 300 , 250 , 220 ] [ Difficulty ] ;
7117: LD_ADDR_VAR 0 2
7121: PUSH
7122: LD_INT 300
7124: PUSH
7125: LD_INT 250
7127: PUSH
7128: LD_INT 220
7130: PUSH
7131: EMPTY
7132: LIST
7133: LIST
7134: LIST
7135: PUSH
7136: LD_OWVAR 67
7140: ARRAY
7141: ST_TO_ADDR
// CreateCratesArea ( Rand ( 1 , 3 ) , cratesArea , true ) ;
7142: LD_INT 1
7144: PPUSH
7145: LD_INT 3
7147: PPUSH
7148: CALL_OW 12
7152: PPUSH
7153: LD_INT 7
7155: PPUSH
7156: LD_INT 1
7158: PPUSH
7159: CALL_OW 55
// repeat wait ( rand ( 1 1$30 , 2 2$20 ) ) ;
7163: LD_INT 3150
7165: PPUSH
7166: LD_INT 4900
7168: PPUSH
7169: CALL_OW 12
7173: PPUSH
7174: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
7178: LD_ADDR_VAR 0 3
7182: PUSH
7183: LD_INT 1
7185: PPUSH
7186: LD_INT 5
7188: PPUSH
7189: CALL_OW 12
7193: ST_TO_ADDR
// CreateCratesArea ( cr , cratesArea , true ) ;
7194: LD_VAR 0 3
7198: PPUSH
7199: LD_INT 7
7201: PPUSH
7202: LD_INT 1
7204: PPUSH
7205: CALL_OW 55
// counter := counter - cr * 10 ;
7209: LD_ADDR_VAR 0 2
7213: PUSH
7214: LD_VAR 0 2
7218: PUSH
7219: LD_VAR 0 3
7223: PUSH
7224: LD_INT 10
7226: MUL
7227: MINUS
7228: ST_TO_ADDR
// until counter <= 0 ;
7229: LD_VAR 0 2
7233: PUSH
7234: LD_INT 0
7236: LESSEQUAL
7237: IFFALSE 7163
// end ;
7239: PPOPN 3
7241: END
// every 0 0$03 trigger not Delta do var i ;
7242: LD_EXP 6
7246: NOT
7247: IFFALSE 7317
7249: GO 7251
7251: DISABLE
7252: LD_INT 0
7254: PPUSH
// begin for i = 1 to 4 - Difficulty do
7255: LD_ADDR_VAR 0 1
7259: PUSH
7260: DOUBLE
7261: LD_INT 1
7263: DEC
7264: ST_TO_ADDR
7265: LD_INT 4
7267: PUSH
7268: LD_OWVAR 67
7272: MINUS
7273: PUSH
7274: FOR_TO
7275: IFFALSE 7315
// begin CreateCratesArea ( rand ( 2 , 5 ) , deltaMainArea , true ) ;
7277: LD_INT 2
7279: PPUSH
7280: LD_INT 5
7282: PPUSH
7283: CALL_OW 12
7287: PPUSH
7288: LD_INT 8
7290: PPUSH
7291: LD_INT 1
7293: PPUSH
7294: CALL_OW 55
// Wait ( rand ( 0 0$16 , 0 0$39 ) ) ;
7298: LD_INT 560
7300: PPUSH
7301: LD_INT 1365
7303: PPUSH
7304: CALL_OW 12
7308: PPUSH
7309: CALL_OW 67
// end ;
7313: GO 7274
7315: POP
7316: POP
// end ;
7317: PPOPN 1
7319: END
// every 3 3$00 trigger tick < 15 15$00 do
7320: LD_OWVAR 1
7324: PUSH
7325: LD_INT 31500
7327: LESS
7328: IFFALSE 7388
7330: GO 7332
7332: DISABLE
// begin enable ;
7333: ENABLE
// CreateCratesAnyWhere ( rand ( 1 , 3 ) , true ) ;
7334: LD_INT 1
7336: PPUSH
7337: LD_INT 3
7339: PPUSH
7340: CALL_OW 12
7344: PPUSH
7345: LD_INT 1
7347: PPUSH
7348: CALL_OW 57
// Wait ( rand ( 0 0$38 , 0 0$59 ) ) ;
7352: LD_INT 1330
7354: PPUSH
7355: LD_INT 2065
7357: PPUSH
7358: CALL_OW 12
7362: PPUSH
7363: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 4 ) , riverArea , true ) ;
7367: LD_INT 1
7369: PPUSH
7370: LD_INT 4
7372: PPUSH
7373: CALL_OW 12
7377: PPUSH
7378: LD_INT 15
7380: PPUSH
7381: LD_INT 1
7383: PPUSH
7384: CALL_OW 55
// end ; end_of_file
7388: END
// on UnitDestroyed ( un ) do begin if un = JMM then
7389: LD_VAR 0 1
7393: PUSH
7394: LD_EXP 16
7398: EQUAL
7399: IFFALSE 7408
// YouLost ( JMM ) ;
7401: LD_STRING JMM
7403: PPUSH
7404: CALL_OW 104
// if un = Delta then
7408: LD_VAR 0 1
7412: PUSH
7413: LD_EXP 6
7417: EQUAL
7418: IFFALSE 7441
// begin Delta := 0 ;
7420: LD_ADDR_EXP 6
7424: PUSH
7425: LD_INT 0
7427: ST_TO_ADDR
// SetRestrict ( b_depot , 1 , true ) ;
7428: LD_INT 0
7430: PPUSH
7431: LD_INT 1
7433: PPUSH
7434: LD_INT 1
7436: PPUSH
7437: CALL_OW 324
// end ; if un in ar_forces then
7441: LD_VAR 0 1
7445: PUSH
7446: LD_EXP 27
7450: IN
7451: IFFALSE 7469
// ar_forces := ar_forces diff un ;
7453: LD_ADDR_EXP 27
7457: PUSH
7458: LD_EXP 27
7462: PUSH
7463: LD_VAR 0 1
7467: DIFF
7468: ST_TO_ADDR
// if un in ap_killers then
7469: LD_VAR 0 1
7473: PUSH
7474: LD_EXP 28
7478: IN
7479: IFFALSE 7497
// ap_killers := ap_killers diff un ;
7481: LD_ADDR_EXP 28
7485: PUSH
7486: LD_EXP 28
7490: PUSH
7491: LD_VAR 0 1
7495: DIFF
7496: ST_TO_ADDR
// if un in FilterAllUnits ( [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ) then
7497: LD_VAR 0 1
7501: PUSH
7502: LD_INT 2
7504: PUSH
7505: LD_INT 25
7507: PUSH
7508: LD_INT 12
7510: PUSH
7511: EMPTY
7512: LIST
7513: LIST
7514: PUSH
7515: LD_INT 25
7517: PUSH
7518: LD_INT 16
7520: PUSH
7521: EMPTY
7522: LIST
7523: LIST
7524: PUSH
7525: EMPTY
7526: LIST
7527: LIST
7528: LIST
7529: PPUSH
7530: CALL_OW 69
7534: IN
7535: IFFALSE 7551
// apeKillCounter := apeKillCounter + 1 ;
7537: LD_ADDR_EXP 15
7541: PUSH
7542: LD_EXP 15
7546: PUSH
7547: LD_INT 1
7549: PLUS
7550: ST_TO_ADDR
// end ;
7551: PPOPN 1
7553: END
// on Contact ( s1 , s2 ) do if s1 = 1 and s2 = 2 and not arab_spotted then
7554: LD_VAR 0 1
7558: PUSH
7559: LD_INT 1
7561: EQUAL
7562: PUSH
7563: LD_VAR 0 2
7567: PUSH
7568: LD_INT 2
7570: EQUAL
7571: AND
7572: PUSH
7573: LD_EXP 13
7577: NOT
7578: AND
7579: IFFALSE 7589
// arab_spotted := true ;
7581: LD_ADDR_EXP 13
7585: PUSH
7586: LD_INT 1
7588: ST_TO_ADDR
7589: PPOPN 2
7591: END
// on EndTheMissionRaised ( p ) do begin end_the_mission_allowed := false ;
7592: LD_ADDR_OWVAR 57
7596: PUSH
7597: LD_INT 0
7599: ST_TO_ADDR
// end_mission := true ;
7600: LD_ADDR_EXP 14
7604: PUSH
7605: LD_INT 1
7607: ST_TO_ADDR
// end ;
7608: PPOPN 1
7610: END
// on ApemanTamed ( apeman , sci ) do begin if GetSide ( sci ) = 1 then
7611: LD_VAR 0 2
7615: PPUSH
7616: CALL_OW 255
7620: PUSH
7621: LD_INT 1
7623: EQUAL
7624: IFFALSE 7640
// apeman_counter := apeman_counter + 1 ;
7626: LD_ADDR_EXP 12
7630: PUSH
7631: LD_EXP 12
7635: PUSH
7636: LD_INT 1
7638: PLUS
7639: ST_TO_ADDR
// if not first_apeman_tamed then
7640: LD_EXP 8
7644: NOT
7645: IFFALSE 7845
// begin first_apeman_tamed := true ;
7647: LD_ADDR_EXP 8
7651: PUSH
7652: LD_INT 1
7654: ST_TO_ADDR
// if sci = Gladstone then
7655: LD_VAR 0 2
7659: PUSH
7660: LD_EXP 17
7664: EQUAL
7665: IFFALSE 7679
// Say ( Gladstone , D7b-Glad-1 ) ;
7667: LD_EXP 17
7671: PPUSH
7672: LD_STRING D7b-Glad-1
7674: PPUSH
7675: CALL_OW 88
// if sci = Denis then
7679: LD_VAR 0 2
7683: PUSH
7684: LD_EXP 19
7688: EQUAL
7689: IFFALSE 7703
// Say ( Denis , D7a-Den-1 ) ;
7691: LD_EXP 19
7695: PPUSH
7696: LD_STRING D7a-Den-1
7698: PPUSH
7699: CALL_OW 88
// if not sci in [ JMM , Gladstone , Denis , Lisa , Frank , Bobby , Cyrus , Donaldson ] then
7703: LD_VAR 0 2
7707: PUSH
7708: LD_EXP 16
7712: PUSH
7713: LD_EXP 17
7717: PUSH
7718: LD_EXP 19
7722: PUSH
7723: LD_EXP 22
7727: PUSH
7728: LD_EXP 23
7732: PUSH
7733: LD_EXP 24
7737: PUSH
7738: LD_EXP 25
7742: PUSH
7743: LD_EXP 21
7747: PUSH
7748: EMPTY
7749: LIST
7750: LIST
7751: LIST
7752: LIST
7753: LIST
7754: LIST
7755: LIST
7756: LIST
7757: IN
7758: NOT
7759: IFFALSE 7802
// begin if GetSex ( sci ) = sex_male then
7761: LD_VAR 0 2
7765: PPUSH
7766: CALL_OW 258
7770: PUSH
7771: LD_INT 1
7773: EQUAL
7774: IFFALSE 7790
// Say ( sci , D7c-Sci1-1 ) else
7776: LD_VAR 0 2
7780: PPUSH
7781: LD_STRING D7c-Sci1-1
7783: PPUSH
7784: CALL_OW 88
7788: GO 7802
// Say ( sci , D7c-FSci1-1 ) ;
7790: LD_VAR 0 2
7794: PPUSH
7795: LD_STRING D7c-FSci1-1
7797: PPUSH
7798: CALL_OW 88
// end ; if not sci = Gladstone then
7802: LD_VAR 0 2
7806: PUSH
7807: LD_EXP 17
7811: EQUAL
7812: NOT
7813: IFFALSE 7827
// Say ( Gladstone , D7c-Glad-1 ) ;
7815: LD_EXP 17
7819: PPUSH
7820: LD_STRING D7c-Glad-1
7822: PPUSH
7823: CALL_OW 88
// if Lisa then
7827: LD_EXP 22
7831: IFFALSE 7845
// Say ( Lisa , D8-Lisa-1 ) ;
7833: LD_EXP 22
7837: PPUSH
7838: LD_STRING D8-Lisa-1
7840: PPUSH
7841: CALL_OW 88
// end ; end ; end_of_file
7845: PPOPN 2
7847: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
7848: GO 7850
7850: DISABLE
// begin ru_radar := 98 ;
7851: LD_ADDR_EXP 29
7855: PUSH
7856: LD_INT 98
7858: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
7859: LD_ADDR_EXP 30
7863: PUSH
7864: LD_INT 89
7866: ST_TO_ADDR
// us_hack := 99 ;
7867: LD_ADDR_EXP 31
7871: PUSH
7872: LD_INT 99
7874: ST_TO_ADDR
// us_artillery := 97 ;
7875: LD_ADDR_EXP 32
7879: PUSH
7880: LD_INT 97
7882: ST_TO_ADDR
// ar_bio_bomb := 91 ;
7883: LD_ADDR_EXP 33
7887: PUSH
7888: LD_INT 91
7890: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
7891: LD_ADDR_EXP 34
7895: PUSH
7896: LD_INT 92
7898: ST_TO_ADDR
// tech_Artillery := 80 ;
7899: LD_ADDR_EXP 35
7903: PUSH
7904: LD_INT 80
7906: ST_TO_ADDR
// tech_RadMat := 81 ;
7907: LD_ADDR_EXP 36
7911: PUSH
7912: LD_INT 81
7914: ST_TO_ADDR
// tech_BasicTools := 82 ;
7915: LD_ADDR_EXP 37
7919: PUSH
7920: LD_INT 82
7922: ST_TO_ADDR
// tech_Cargo := 83 ;
7923: LD_ADDR_EXP 38
7927: PUSH
7928: LD_INT 83
7930: ST_TO_ADDR
// tech_Track := 84 ;
7931: LD_ADDR_EXP 39
7935: PUSH
7936: LD_INT 84
7938: ST_TO_ADDR
// tech_Crane := 85 ;
7939: LD_ADDR_EXP 40
7943: PUSH
7944: LD_INT 85
7946: ST_TO_ADDR
// tech_Bulldozer := 86 ;
7947: LD_ADDR_EXP 41
7951: PUSH
7952: LD_INT 86
7954: ST_TO_ADDR
// tech_Hovercraft := 87 ;
7955: LD_ADDR_EXP 42
7959: PUSH
7960: LD_INT 87
7962: ST_TO_ADDR
// end ; end_of_file end_of_file
7963: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
7964: GO 7966
7966: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
7967: LD_STRING initStreamRollete();
7969: PPUSH
7970: CALL_OW 559
// InitStreamMode ;
7974: CALL 7983 0 0
// DefineStreamItems ( ) ;
7978: CALL 8423 0 0
// end ;
7982: END
// function InitStreamMode ; begin
7983: LD_INT 0
7985: PPUSH
// streamModeActive := false ;
7986: LD_ADDR_EXP 43
7990: PUSH
7991: LD_INT 0
7993: ST_TO_ADDR
// normalCounter := 36 ;
7994: LD_ADDR_EXP 44
7998: PUSH
7999: LD_INT 36
8001: ST_TO_ADDR
// hardcoreCounter := 16 ;
8002: LD_ADDR_EXP 45
8006: PUSH
8007: LD_INT 16
8009: ST_TO_ADDR
// sRocket := false ;
8010: LD_ADDR_EXP 48
8014: PUSH
8015: LD_INT 0
8017: ST_TO_ADDR
// sSpeed := false ;
8018: LD_ADDR_EXP 47
8022: PUSH
8023: LD_INT 0
8025: ST_TO_ADDR
// sEngine := false ;
8026: LD_ADDR_EXP 49
8030: PUSH
8031: LD_INT 0
8033: ST_TO_ADDR
// sSpec := false ;
8034: LD_ADDR_EXP 46
8038: PUSH
8039: LD_INT 0
8041: ST_TO_ADDR
// sLevel := false ;
8042: LD_ADDR_EXP 50
8046: PUSH
8047: LD_INT 0
8049: ST_TO_ADDR
// sArmoury := false ;
8050: LD_ADDR_EXP 51
8054: PUSH
8055: LD_INT 0
8057: ST_TO_ADDR
// sRadar := false ;
8058: LD_ADDR_EXP 52
8062: PUSH
8063: LD_INT 0
8065: ST_TO_ADDR
// sBunker := false ;
8066: LD_ADDR_EXP 53
8070: PUSH
8071: LD_INT 0
8073: ST_TO_ADDR
// sHack := false ;
8074: LD_ADDR_EXP 54
8078: PUSH
8079: LD_INT 0
8081: ST_TO_ADDR
// sFire := false ;
8082: LD_ADDR_EXP 55
8086: PUSH
8087: LD_INT 0
8089: ST_TO_ADDR
// sRefresh := false ;
8090: LD_ADDR_EXP 56
8094: PUSH
8095: LD_INT 0
8097: ST_TO_ADDR
// sExp := false ;
8098: LD_ADDR_EXP 57
8102: PUSH
8103: LD_INT 0
8105: ST_TO_ADDR
// sDepot := false ;
8106: LD_ADDR_EXP 58
8110: PUSH
8111: LD_INT 0
8113: ST_TO_ADDR
// sFlag := false ;
8114: LD_ADDR_EXP 59
8118: PUSH
8119: LD_INT 0
8121: ST_TO_ADDR
// sKamikadze := false ;
8122: LD_ADDR_EXP 67
8126: PUSH
8127: LD_INT 0
8129: ST_TO_ADDR
// sTroll := false ;
8130: LD_ADDR_EXP 68
8134: PUSH
8135: LD_INT 0
8137: ST_TO_ADDR
// sSlow := false ;
8138: LD_ADDR_EXP 69
8142: PUSH
8143: LD_INT 0
8145: ST_TO_ADDR
// sLack := false ;
8146: LD_ADDR_EXP 70
8150: PUSH
8151: LD_INT 0
8153: ST_TO_ADDR
// sTank := false ;
8154: LD_ADDR_EXP 72
8158: PUSH
8159: LD_INT 0
8161: ST_TO_ADDR
// sRemote := false ;
8162: LD_ADDR_EXP 73
8166: PUSH
8167: LD_INT 0
8169: ST_TO_ADDR
// sPowell := false ;
8170: LD_ADDR_EXP 74
8174: PUSH
8175: LD_INT 0
8177: ST_TO_ADDR
// sTeleport := false ;
8178: LD_ADDR_EXP 77
8182: PUSH
8183: LD_INT 0
8185: ST_TO_ADDR
// sOilTower := false ;
8186: LD_ADDR_EXP 79
8190: PUSH
8191: LD_INT 0
8193: ST_TO_ADDR
// sShovel := false ;
8194: LD_ADDR_EXP 80
8198: PUSH
8199: LD_INT 0
8201: ST_TO_ADDR
// sSheik := false ;
8202: LD_ADDR_EXP 81
8206: PUSH
8207: LD_INT 0
8209: ST_TO_ADDR
// sEarthquake := false ;
8210: LD_ADDR_EXP 83
8214: PUSH
8215: LD_INT 0
8217: ST_TO_ADDR
// sAI := false ;
8218: LD_ADDR_EXP 84
8222: PUSH
8223: LD_INT 0
8225: ST_TO_ADDR
// sCargo := false ;
8226: LD_ADDR_EXP 87
8230: PUSH
8231: LD_INT 0
8233: ST_TO_ADDR
// sDLaser := false ;
8234: LD_ADDR_EXP 88
8238: PUSH
8239: LD_INT 0
8241: ST_TO_ADDR
// sExchange := false ;
8242: LD_ADDR_EXP 89
8246: PUSH
8247: LD_INT 0
8249: ST_TO_ADDR
// sFac := false ;
8250: LD_ADDR_EXP 90
8254: PUSH
8255: LD_INT 0
8257: ST_TO_ADDR
// sPower := false ;
8258: LD_ADDR_EXP 91
8262: PUSH
8263: LD_INT 0
8265: ST_TO_ADDR
// sRandom := false ;
8266: LD_ADDR_EXP 92
8270: PUSH
8271: LD_INT 0
8273: ST_TO_ADDR
// sShield := false ;
8274: LD_ADDR_EXP 93
8278: PUSH
8279: LD_INT 0
8281: ST_TO_ADDR
// sTime := false ;
8282: LD_ADDR_EXP 94
8286: PUSH
8287: LD_INT 0
8289: ST_TO_ADDR
// sTools := false ;
8290: LD_ADDR_EXP 95
8294: PUSH
8295: LD_INT 0
8297: ST_TO_ADDR
// sSold := false ;
8298: LD_ADDR_EXP 60
8302: PUSH
8303: LD_INT 0
8305: ST_TO_ADDR
// sDiff := false ;
8306: LD_ADDR_EXP 61
8310: PUSH
8311: LD_INT 0
8313: ST_TO_ADDR
// sFog := false ;
8314: LD_ADDR_EXP 64
8318: PUSH
8319: LD_INT 0
8321: ST_TO_ADDR
// sReset := false ;
8322: LD_ADDR_EXP 65
8326: PUSH
8327: LD_INT 0
8329: ST_TO_ADDR
// sSun := false ;
8330: LD_ADDR_EXP 66
8334: PUSH
8335: LD_INT 0
8337: ST_TO_ADDR
// sTiger := false ;
8338: LD_ADDR_EXP 62
8342: PUSH
8343: LD_INT 0
8345: ST_TO_ADDR
// sBomb := false ;
8346: LD_ADDR_EXP 63
8350: PUSH
8351: LD_INT 0
8353: ST_TO_ADDR
// sWound := false ;
8354: LD_ADDR_EXP 71
8358: PUSH
8359: LD_INT 0
8361: ST_TO_ADDR
// sBetray := false ;
8362: LD_ADDR_EXP 75
8366: PUSH
8367: LD_INT 0
8369: ST_TO_ADDR
// sContamin := false ;
8370: LD_ADDR_EXP 76
8374: PUSH
8375: LD_INT 0
8377: ST_TO_ADDR
// sOil := false ;
8378: LD_ADDR_EXP 78
8382: PUSH
8383: LD_INT 0
8385: ST_TO_ADDR
// sStu := false ;
8386: LD_ADDR_EXP 82
8390: PUSH
8391: LD_INT 0
8393: ST_TO_ADDR
// sBazooka := false ;
8394: LD_ADDR_EXP 85
8398: PUSH
8399: LD_INT 0
8401: ST_TO_ADDR
// sMortar := false ;
8402: LD_ADDR_EXP 86
8406: PUSH
8407: LD_INT 0
8409: ST_TO_ADDR
// sRanger := false ;
8410: LD_ADDR_EXP 96
8414: PUSH
8415: LD_INT 0
8417: ST_TO_ADDR
// end ;
8418: LD_VAR 0 1
8422: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
8423: LD_INT 0
8425: PPUSH
8426: PPUSH
8427: PPUSH
8428: PPUSH
8429: PPUSH
// result := [ ] ;
8430: LD_ADDR_VAR 0 1
8434: PUSH
8435: EMPTY
8436: ST_TO_ADDR
// if campaign_id = 1 then
8437: LD_OWVAR 69
8441: PUSH
8442: LD_INT 1
8444: EQUAL
8445: IFFALSE 11383
// begin case mission_number of 1 :
8447: LD_OWVAR 70
8451: PUSH
8452: LD_INT 1
8454: DOUBLE
8455: EQUAL
8456: IFTRUE 8460
8458: GO 8524
8460: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
8461: LD_ADDR_VAR 0 1
8465: PUSH
8466: LD_INT 2
8468: PUSH
8469: LD_INT 4
8471: PUSH
8472: LD_INT 11
8474: PUSH
8475: LD_INT 12
8477: PUSH
8478: LD_INT 15
8480: PUSH
8481: LD_INT 16
8483: PUSH
8484: LD_INT 22
8486: PUSH
8487: LD_INT 23
8489: PUSH
8490: LD_INT 26
8492: PUSH
8493: EMPTY
8494: LIST
8495: LIST
8496: LIST
8497: LIST
8498: LIST
8499: LIST
8500: LIST
8501: LIST
8502: LIST
8503: PUSH
8504: LD_INT 101
8506: PUSH
8507: LD_INT 102
8509: PUSH
8510: LD_INT 106
8512: PUSH
8513: EMPTY
8514: LIST
8515: LIST
8516: LIST
8517: PUSH
8518: EMPTY
8519: LIST
8520: LIST
8521: ST_TO_ADDR
8522: GO 11381
8524: LD_INT 2
8526: DOUBLE
8527: EQUAL
8528: IFTRUE 8532
8530: GO 8604
8532: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
8533: LD_ADDR_VAR 0 1
8537: PUSH
8538: LD_INT 2
8540: PUSH
8541: LD_INT 4
8543: PUSH
8544: LD_INT 11
8546: PUSH
8547: LD_INT 12
8549: PUSH
8550: LD_INT 15
8552: PUSH
8553: LD_INT 16
8555: PUSH
8556: LD_INT 22
8558: PUSH
8559: LD_INT 23
8561: PUSH
8562: LD_INT 26
8564: PUSH
8565: EMPTY
8566: LIST
8567: LIST
8568: LIST
8569: LIST
8570: LIST
8571: LIST
8572: LIST
8573: LIST
8574: LIST
8575: PUSH
8576: LD_INT 101
8578: PUSH
8579: LD_INT 102
8581: PUSH
8582: LD_INT 105
8584: PUSH
8585: LD_INT 106
8587: PUSH
8588: LD_INT 108
8590: PUSH
8591: EMPTY
8592: LIST
8593: LIST
8594: LIST
8595: LIST
8596: LIST
8597: PUSH
8598: EMPTY
8599: LIST
8600: LIST
8601: ST_TO_ADDR
8602: GO 11381
8604: LD_INT 3
8606: DOUBLE
8607: EQUAL
8608: IFTRUE 8612
8610: GO 8688
8612: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
8613: LD_ADDR_VAR 0 1
8617: PUSH
8618: LD_INT 2
8620: PUSH
8621: LD_INT 4
8623: PUSH
8624: LD_INT 5
8626: PUSH
8627: LD_INT 11
8629: PUSH
8630: LD_INT 12
8632: PUSH
8633: LD_INT 15
8635: PUSH
8636: LD_INT 16
8638: PUSH
8639: LD_INT 22
8641: PUSH
8642: LD_INT 26
8644: PUSH
8645: LD_INT 36
8647: PUSH
8648: EMPTY
8649: LIST
8650: LIST
8651: LIST
8652: LIST
8653: LIST
8654: LIST
8655: LIST
8656: LIST
8657: LIST
8658: LIST
8659: PUSH
8660: LD_INT 101
8662: PUSH
8663: LD_INT 102
8665: PUSH
8666: LD_INT 105
8668: PUSH
8669: LD_INT 106
8671: PUSH
8672: LD_INT 108
8674: PUSH
8675: EMPTY
8676: LIST
8677: LIST
8678: LIST
8679: LIST
8680: LIST
8681: PUSH
8682: EMPTY
8683: LIST
8684: LIST
8685: ST_TO_ADDR
8686: GO 11381
8688: LD_INT 4
8690: DOUBLE
8691: EQUAL
8692: IFTRUE 8696
8694: GO 8780
8696: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
8697: LD_ADDR_VAR 0 1
8701: PUSH
8702: LD_INT 2
8704: PUSH
8705: LD_INT 4
8707: PUSH
8708: LD_INT 5
8710: PUSH
8711: LD_INT 8
8713: PUSH
8714: LD_INT 11
8716: PUSH
8717: LD_INT 12
8719: PUSH
8720: LD_INT 15
8722: PUSH
8723: LD_INT 16
8725: PUSH
8726: LD_INT 22
8728: PUSH
8729: LD_INT 23
8731: PUSH
8732: LD_INT 26
8734: PUSH
8735: LD_INT 36
8737: PUSH
8738: EMPTY
8739: LIST
8740: LIST
8741: LIST
8742: LIST
8743: LIST
8744: LIST
8745: LIST
8746: LIST
8747: LIST
8748: LIST
8749: LIST
8750: LIST
8751: PUSH
8752: LD_INT 101
8754: PUSH
8755: LD_INT 102
8757: PUSH
8758: LD_INT 105
8760: PUSH
8761: LD_INT 106
8763: PUSH
8764: LD_INT 108
8766: PUSH
8767: EMPTY
8768: LIST
8769: LIST
8770: LIST
8771: LIST
8772: LIST
8773: PUSH
8774: EMPTY
8775: LIST
8776: LIST
8777: ST_TO_ADDR
8778: GO 11381
8780: LD_INT 5
8782: DOUBLE
8783: EQUAL
8784: IFTRUE 8788
8786: GO 8888
8788: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
8789: LD_ADDR_VAR 0 1
8793: PUSH
8794: LD_INT 2
8796: PUSH
8797: LD_INT 4
8799: PUSH
8800: LD_INT 5
8802: PUSH
8803: LD_INT 6
8805: PUSH
8806: LD_INT 8
8808: PUSH
8809: LD_INT 11
8811: PUSH
8812: LD_INT 12
8814: PUSH
8815: LD_INT 15
8817: PUSH
8818: LD_INT 16
8820: PUSH
8821: LD_INT 22
8823: PUSH
8824: LD_INT 23
8826: PUSH
8827: LD_INT 25
8829: PUSH
8830: LD_INT 26
8832: PUSH
8833: LD_INT 36
8835: PUSH
8836: EMPTY
8837: LIST
8838: LIST
8839: LIST
8840: LIST
8841: LIST
8842: LIST
8843: LIST
8844: LIST
8845: LIST
8846: LIST
8847: LIST
8848: LIST
8849: LIST
8850: LIST
8851: PUSH
8852: LD_INT 101
8854: PUSH
8855: LD_INT 102
8857: PUSH
8858: LD_INT 105
8860: PUSH
8861: LD_INT 106
8863: PUSH
8864: LD_INT 108
8866: PUSH
8867: LD_INT 109
8869: PUSH
8870: LD_INT 112
8872: PUSH
8873: EMPTY
8874: LIST
8875: LIST
8876: LIST
8877: LIST
8878: LIST
8879: LIST
8880: LIST
8881: PUSH
8882: EMPTY
8883: LIST
8884: LIST
8885: ST_TO_ADDR
8886: GO 11381
8888: LD_INT 6
8890: DOUBLE
8891: EQUAL
8892: IFTRUE 8896
8894: GO 9016
8896: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
8897: LD_ADDR_VAR 0 1
8901: PUSH
8902: LD_INT 2
8904: PUSH
8905: LD_INT 4
8907: PUSH
8908: LD_INT 5
8910: PUSH
8911: LD_INT 6
8913: PUSH
8914: LD_INT 8
8916: PUSH
8917: LD_INT 11
8919: PUSH
8920: LD_INT 12
8922: PUSH
8923: LD_INT 15
8925: PUSH
8926: LD_INT 16
8928: PUSH
8929: LD_INT 20
8931: PUSH
8932: LD_INT 21
8934: PUSH
8935: LD_INT 22
8937: PUSH
8938: LD_INT 23
8940: PUSH
8941: LD_INT 25
8943: PUSH
8944: LD_INT 26
8946: PUSH
8947: LD_INT 30
8949: PUSH
8950: LD_INT 31
8952: PUSH
8953: LD_INT 32
8955: PUSH
8956: LD_INT 36
8958: PUSH
8959: EMPTY
8960: LIST
8961: LIST
8962: LIST
8963: LIST
8964: LIST
8965: LIST
8966: LIST
8967: LIST
8968: LIST
8969: LIST
8970: LIST
8971: LIST
8972: LIST
8973: LIST
8974: LIST
8975: LIST
8976: LIST
8977: LIST
8978: LIST
8979: PUSH
8980: LD_INT 101
8982: PUSH
8983: LD_INT 102
8985: PUSH
8986: LD_INT 105
8988: PUSH
8989: LD_INT 106
8991: PUSH
8992: LD_INT 108
8994: PUSH
8995: LD_INT 109
8997: PUSH
8998: LD_INT 112
9000: PUSH
9001: EMPTY
9002: LIST
9003: LIST
9004: LIST
9005: LIST
9006: LIST
9007: LIST
9008: LIST
9009: PUSH
9010: EMPTY
9011: LIST
9012: LIST
9013: ST_TO_ADDR
9014: GO 11381
9016: LD_INT 7
9018: DOUBLE
9019: EQUAL
9020: IFTRUE 9024
9022: GO 9124
9024: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
9025: LD_ADDR_VAR 0 1
9029: PUSH
9030: LD_INT 2
9032: PUSH
9033: LD_INT 4
9035: PUSH
9036: LD_INT 5
9038: PUSH
9039: LD_INT 7
9041: PUSH
9042: LD_INT 11
9044: PUSH
9045: LD_INT 12
9047: PUSH
9048: LD_INT 15
9050: PUSH
9051: LD_INT 16
9053: PUSH
9054: LD_INT 20
9056: PUSH
9057: LD_INT 21
9059: PUSH
9060: LD_INT 22
9062: PUSH
9063: LD_INT 23
9065: PUSH
9066: LD_INT 25
9068: PUSH
9069: LD_INT 26
9071: PUSH
9072: EMPTY
9073: LIST
9074: LIST
9075: LIST
9076: LIST
9077: LIST
9078: LIST
9079: LIST
9080: LIST
9081: LIST
9082: LIST
9083: LIST
9084: LIST
9085: LIST
9086: LIST
9087: PUSH
9088: LD_INT 101
9090: PUSH
9091: LD_INT 102
9093: PUSH
9094: LD_INT 103
9096: PUSH
9097: LD_INT 105
9099: PUSH
9100: LD_INT 106
9102: PUSH
9103: LD_INT 108
9105: PUSH
9106: LD_INT 112
9108: PUSH
9109: EMPTY
9110: LIST
9111: LIST
9112: LIST
9113: LIST
9114: LIST
9115: LIST
9116: LIST
9117: PUSH
9118: EMPTY
9119: LIST
9120: LIST
9121: ST_TO_ADDR
9122: GO 11381
9124: LD_INT 8
9126: DOUBLE
9127: EQUAL
9128: IFTRUE 9132
9130: GO 9260
9132: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
9133: LD_ADDR_VAR 0 1
9137: PUSH
9138: LD_INT 2
9140: PUSH
9141: LD_INT 4
9143: PUSH
9144: LD_INT 5
9146: PUSH
9147: LD_INT 6
9149: PUSH
9150: LD_INT 7
9152: PUSH
9153: LD_INT 8
9155: PUSH
9156: LD_INT 11
9158: PUSH
9159: LD_INT 12
9161: PUSH
9162: LD_INT 15
9164: PUSH
9165: LD_INT 16
9167: PUSH
9168: LD_INT 20
9170: PUSH
9171: LD_INT 21
9173: PUSH
9174: LD_INT 22
9176: PUSH
9177: LD_INT 23
9179: PUSH
9180: LD_INT 25
9182: PUSH
9183: LD_INT 26
9185: PUSH
9186: LD_INT 30
9188: PUSH
9189: LD_INT 31
9191: PUSH
9192: LD_INT 32
9194: PUSH
9195: LD_INT 36
9197: PUSH
9198: EMPTY
9199: LIST
9200: LIST
9201: LIST
9202: LIST
9203: LIST
9204: LIST
9205: LIST
9206: LIST
9207: LIST
9208: LIST
9209: LIST
9210: LIST
9211: LIST
9212: LIST
9213: LIST
9214: LIST
9215: LIST
9216: LIST
9217: LIST
9218: LIST
9219: PUSH
9220: LD_INT 101
9222: PUSH
9223: LD_INT 102
9225: PUSH
9226: LD_INT 103
9228: PUSH
9229: LD_INT 105
9231: PUSH
9232: LD_INT 106
9234: PUSH
9235: LD_INT 108
9237: PUSH
9238: LD_INT 109
9240: PUSH
9241: LD_INT 112
9243: PUSH
9244: EMPTY
9245: LIST
9246: LIST
9247: LIST
9248: LIST
9249: LIST
9250: LIST
9251: LIST
9252: LIST
9253: PUSH
9254: EMPTY
9255: LIST
9256: LIST
9257: ST_TO_ADDR
9258: GO 11381
9260: LD_INT 9
9262: DOUBLE
9263: EQUAL
9264: IFTRUE 9268
9266: GO 9404
9268: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
9269: LD_ADDR_VAR 0 1
9273: PUSH
9274: LD_INT 2
9276: PUSH
9277: LD_INT 4
9279: PUSH
9280: LD_INT 5
9282: PUSH
9283: LD_INT 6
9285: PUSH
9286: LD_INT 7
9288: PUSH
9289: LD_INT 8
9291: PUSH
9292: LD_INT 11
9294: PUSH
9295: LD_INT 12
9297: PUSH
9298: LD_INT 15
9300: PUSH
9301: LD_INT 16
9303: PUSH
9304: LD_INT 20
9306: PUSH
9307: LD_INT 21
9309: PUSH
9310: LD_INT 22
9312: PUSH
9313: LD_INT 23
9315: PUSH
9316: LD_INT 25
9318: PUSH
9319: LD_INT 26
9321: PUSH
9322: LD_INT 28
9324: PUSH
9325: LD_INT 30
9327: PUSH
9328: LD_INT 31
9330: PUSH
9331: LD_INT 32
9333: PUSH
9334: LD_INT 36
9336: PUSH
9337: EMPTY
9338: LIST
9339: LIST
9340: LIST
9341: LIST
9342: LIST
9343: LIST
9344: LIST
9345: LIST
9346: LIST
9347: LIST
9348: LIST
9349: LIST
9350: LIST
9351: LIST
9352: LIST
9353: LIST
9354: LIST
9355: LIST
9356: LIST
9357: LIST
9358: LIST
9359: PUSH
9360: LD_INT 101
9362: PUSH
9363: LD_INT 102
9365: PUSH
9366: LD_INT 103
9368: PUSH
9369: LD_INT 105
9371: PUSH
9372: LD_INT 106
9374: PUSH
9375: LD_INT 108
9377: PUSH
9378: LD_INT 109
9380: PUSH
9381: LD_INT 112
9383: PUSH
9384: LD_INT 114
9386: PUSH
9387: EMPTY
9388: LIST
9389: LIST
9390: LIST
9391: LIST
9392: LIST
9393: LIST
9394: LIST
9395: LIST
9396: LIST
9397: PUSH
9398: EMPTY
9399: LIST
9400: LIST
9401: ST_TO_ADDR
9402: GO 11381
9404: LD_INT 10
9406: DOUBLE
9407: EQUAL
9408: IFTRUE 9412
9410: GO 9596
9412: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
9413: LD_ADDR_VAR 0 1
9417: PUSH
9418: LD_INT 2
9420: PUSH
9421: LD_INT 4
9423: PUSH
9424: LD_INT 5
9426: PUSH
9427: LD_INT 6
9429: PUSH
9430: LD_INT 7
9432: PUSH
9433: LD_INT 8
9435: PUSH
9436: LD_INT 9
9438: PUSH
9439: LD_INT 10
9441: PUSH
9442: LD_INT 11
9444: PUSH
9445: LD_INT 12
9447: PUSH
9448: LD_INT 13
9450: PUSH
9451: LD_INT 14
9453: PUSH
9454: LD_INT 15
9456: PUSH
9457: LD_INT 16
9459: PUSH
9460: LD_INT 17
9462: PUSH
9463: LD_INT 18
9465: PUSH
9466: LD_INT 19
9468: PUSH
9469: LD_INT 20
9471: PUSH
9472: LD_INT 21
9474: PUSH
9475: LD_INT 22
9477: PUSH
9478: LD_INT 23
9480: PUSH
9481: LD_INT 24
9483: PUSH
9484: LD_INT 25
9486: PUSH
9487: LD_INT 26
9489: PUSH
9490: LD_INT 28
9492: PUSH
9493: LD_INT 30
9495: PUSH
9496: LD_INT 31
9498: PUSH
9499: LD_INT 32
9501: PUSH
9502: LD_INT 36
9504: PUSH
9505: EMPTY
9506: LIST
9507: LIST
9508: LIST
9509: LIST
9510: LIST
9511: LIST
9512: LIST
9513: LIST
9514: LIST
9515: LIST
9516: LIST
9517: LIST
9518: LIST
9519: LIST
9520: LIST
9521: LIST
9522: LIST
9523: LIST
9524: LIST
9525: LIST
9526: LIST
9527: LIST
9528: LIST
9529: LIST
9530: LIST
9531: LIST
9532: LIST
9533: LIST
9534: LIST
9535: PUSH
9536: LD_INT 101
9538: PUSH
9539: LD_INT 102
9541: PUSH
9542: LD_INT 103
9544: PUSH
9545: LD_INT 104
9547: PUSH
9548: LD_INT 105
9550: PUSH
9551: LD_INT 106
9553: PUSH
9554: LD_INT 107
9556: PUSH
9557: LD_INT 108
9559: PUSH
9560: LD_INT 109
9562: PUSH
9563: LD_INT 110
9565: PUSH
9566: LD_INT 111
9568: PUSH
9569: LD_INT 112
9571: PUSH
9572: LD_INT 114
9574: PUSH
9575: EMPTY
9576: LIST
9577: LIST
9578: LIST
9579: LIST
9580: LIST
9581: LIST
9582: LIST
9583: LIST
9584: LIST
9585: LIST
9586: LIST
9587: LIST
9588: LIST
9589: PUSH
9590: EMPTY
9591: LIST
9592: LIST
9593: ST_TO_ADDR
9594: GO 11381
9596: LD_INT 11
9598: DOUBLE
9599: EQUAL
9600: IFTRUE 9604
9602: GO 9796
9604: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
9605: LD_ADDR_VAR 0 1
9609: PUSH
9610: LD_INT 2
9612: PUSH
9613: LD_INT 3
9615: PUSH
9616: LD_INT 4
9618: PUSH
9619: LD_INT 5
9621: PUSH
9622: LD_INT 6
9624: PUSH
9625: LD_INT 7
9627: PUSH
9628: LD_INT 8
9630: PUSH
9631: LD_INT 9
9633: PUSH
9634: LD_INT 10
9636: PUSH
9637: LD_INT 11
9639: PUSH
9640: LD_INT 12
9642: PUSH
9643: LD_INT 13
9645: PUSH
9646: LD_INT 14
9648: PUSH
9649: LD_INT 15
9651: PUSH
9652: LD_INT 16
9654: PUSH
9655: LD_INT 17
9657: PUSH
9658: LD_INT 18
9660: PUSH
9661: LD_INT 19
9663: PUSH
9664: LD_INT 20
9666: PUSH
9667: LD_INT 21
9669: PUSH
9670: LD_INT 22
9672: PUSH
9673: LD_INT 23
9675: PUSH
9676: LD_INT 24
9678: PUSH
9679: LD_INT 25
9681: PUSH
9682: LD_INT 26
9684: PUSH
9685: LD_INT 28
9687: PUSH
9688: LD_INT 30
9690: PUSH
9691: LD_INT 31
9693: PUSH
9694: LD_INT 32
9696: PUSH
9697: LD_INT 34
9699: PUSH
9700: LD_INT 36
9702: PUSH
9703: EMPTY
9704: LIST
9705: LIST
9706: LIST
9707: LIST
9708: LIST
9709: LIST
9710: LIST
9711: LIST
9712: LIST
9713: LIST
9714: LIST
9715: LIST
9716: LIST
9717: LIST
9718: LIST
9719: LIST
9720: LIST
9721: LIST
9722: LIST
9723: LIST
9724: LIST
9725: LIST
9726: LIST
9727: LIST
9728: LIST
9729: LIST
9730: LIST
9731: LIST
9732: LIST
9733: LIST
9734: LIST
9735: PUSH
9736: LD_INT 101
9738: PUSH
9739: LD_INT 102
9741: PUSH
9742: LD_INT 103
9744: PUSH
9745: LD_INT 104
9747: PUSH
9748: LD_INT 105
9750: PUSH
9751: LD_INT 106
9753: PUSH
9754: LD_INT 107
9756: PUSH
9757: LD_INT 108
9759: PUSH
9760: LD_INT 109
9762: PUSH
9763: LD_INT 110
9765: PUSH
9766: LD_INT 111
9768: PUSH
9769: LD_INT 112
9771: PUSH
9772: LD_INT 114
9774: PUSH
9775: EMPTY
9776: LIST
9777: LIST
9778: LIST
9779: LIST
9780: LIST
9781: LIST
9782: LIST
9783: LIST
9784: LIST
9785: LIST
9786: LIST
9787: LIST
9788: LIST
9789: PUSH
9790: EMPTY
9791: LIST
9792: LIST
9793: ST_TO_ADDR
9794: GO 11381
9796: LD_INT 12
9798: DOUBLE
9799: EQUAL
9800: IFTRUE 9804
9802: GO 10012
9804: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
9805: LD_ADDR_VAR 0 1
9809: PUSH
9810: LD_INT 1
9812: PUSH
9813: LD_INT 2
9815: PUSH
9816: LD_INT 3
9818: PUSH
9819: LD_INT 4
9821: PUSH
9822: LD_INT 5
9824: PUSH
9825: LD_INT 6
9827: PUSH
9828: LD_INT 7
9830: PUSH
9831: LD_INT 8
9833: PUSH
9834: LD_INT 9
9836: PUSH
9837: LD_INT 10
9839: PUSH
9840: LD_INT 11
9842: PUSH
9843: LD_INT 12
9845: PUSH
9846: LD_INT 13
9848: PUSH
9849: LD_INT 14
9851: PUSH
9852: LD_INT 15
9854: PUSH
9855: LD_INT 16
9857: PUSH
9858: LD_INT 17
9860: PUSH
9861: LD_INT 18
9863: PUSH
9864: LD_INT 19
9866: PUSH
9867: LD_INT 20
9869: PUSH
9870: LD_INT 21
9872: PUSH
9873: LD_INT 22
9875: PUSH
9876: LD_INT 23
9878: PUSH
9879: LD_INT 24
9881: PUSH
9882: LD_INT 25
9884: PUSH
9885: LD_INT 26
9887: PUSH
9888: LD_INT 27
9890: PUSH
9891: LD_INT 28
9893: PUSH
9894: LD_INT 30
9896: PUSH
9897: LD_INT 31
9899: PUSH
9900: LD_INT 32
9902: PUSH
9903: LD_INT 33
9905: PUSH
9906: LD_INT 34
9908: PUSH
9909: LD_INT 36
9911: PUSH
9912: EMPTY
9913: LIST
9914: LIST
9915: LIST
9916: LIST
9917: LIST
9918: LIST
9919: LIST
9920: LIST
9921: LIST
9922: LIST
9923: LIST
9924: LIST
9925: LIST
9926: LIST
9927: LIST
9928: LIST
9929: LIST
9930: LIST
9931: LIST
9932: LIST
9933: LIST
9934: LIST
9935: LIST
9936: LIST
9937: LIST
9938: LIST
9939: LIST
9940: LIST
9941: LIST
9942: LIST
9943: LIST
9944: LIST
9945: LIST
9946: LIST
9947: PUSH
9948: LD_INT 101
9950: PUSH
9951: LD_INT 102
9953: PUSH
9954: LD_INT 103
9956: PUSH
9957: LD_INT 104
9959: PUSH
9960: LD_INT 105
9962: PUSH
9963: LD_INT 106
9965: PUSH
9966: LD_INT 107
9968: PUSH
9969: LD_INT 108
9971: PUSH
9972: LD_INT 109
9974: PUSH
9975: LD_INT 110
9977: PUSH
9978: LD_INT 111
9980: PUSH
9981: LD_INT 112
9983: PUSH
9984: LD_INT 113
9986: PUSH
9987: LD_INT 114
9989: PUSH
9990: EMPTY
9991: LIST
9992: LIST
9993: LIST
9994: LIST
9995: LIST
9996: LIST
9997: LIST
9998: LIST
9999: LIST
10000: LIST
10001: LIST
10002: LIST
10003: LIST
10004: LIST
10005: PUSH
10006: EMPTY
10007: LIST
10008: LIST
10009: ST_TO_ADDR
10010: GO 11381
10012: LD_INT 13
10014: DOUBLE
10015: EQUAL
10016: IFTRUE 10020
10018: GO 10216
10020: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
10021: LD_ADDR_VAR 0 1
10025: PUSH
10026: LD_INT 1
10028: PUSH
10029: LD_INT 2
10031: PUSH
10032: LD_INT 3
10034: PUSH
10035: LD_INT 4
10037: PUSH
10038: LD_INT 5
10040: PUSH
10041: LD_INT 8
10043: PUSH
10044: LD_INT 9
10046: PUSH
10047: LD_INT 10
10049: PUSH
10050: LD_INT 11
10052: PUSH
10053: LD_INT 12
10055: PUSH
10056: LD_INT 14
10058: PUSH
10059: LD_INT 15
10061: PUSH
10062: LD_INT 16
10064: PUSH
10065: LD_INT 17
10067: PUSH
10068: LD_INT 18
10070: PUSH
10071: LD_INT 19
10073: PUSH
10074: LD_INT 20
10076: PUSH
10077: LD_INT 21
10079: PUSH
10080: LD_INT 22
10082: PUSH
10083: LD_INT 23
10085: PUSH
10086: LD_INT 24
10088: PUSH
10089: LD_INT 25
10091: PUSH
10092: LD_INT 26
10094: PUSH
10095: LD_INT 27
10097: PUSH
10098: LD_INT 28
10100: PUSH
10101: LD_INT 30
10103: PUSH
10104: LD_INT 31
10106: PUSH
10107: LD_INT 32
10109: PUSH
10110: LD_INT 33
10112: PUSH
10113: LD_INT 34
10115: PUSH
10116: LD_INT 36
10118: PUSH
10119: EMPTY
10120: LIST
10121: LIST
10122: LIST
10123: LIST
10124: LIST
10125: LIST
10126: LIST
10127: LIST
10128: LIST
10129: LIST
10130: LIST
10131: LIST
10132: LIST
10133: LIST
10134: LIST
10135: LIST
10136: LIST
10137: LIST
10138: LIST
10139: LIST
10140: LIST
10141: LIST
10142: LIST
10143: LIST
10144: LIST
10145: LIST
10146: LIST
10147: LIST
10148: LIST
10149: LIST
10150: LIST
10151: PUSH
10152: LD_INT 101
10154: PUSH
10155: LD_INT 102
10157: PUSH
10158: LD_INT 103
10160: PUSH
10161: LD_INT 104
10163: PUSH
10164: LD_INT 105
10166: PUSH
10167: LD_INT 106
10169: PUSH
10170: LD_INT 107
10172: PUSH
10173: LD_INT 108
10175: PUSH
10176: LD_INT 109
10178: PUSH
10179: LD_INT 110
10181: PUSH
10182: LD_INT 111
10184: PUSH
10185: LD_INT 112
10187: PUSH
10188: LD_INT 113
10190: PUSH
10191: LD_INT 114
10193: PUSH
10194: EMPTY
10195: LIST
10196: LIST
10197: LIST
10198: LIST
10199: LIST
10200: LIST
10201: LIST
10202: LIST
10203: LIST
10204: LIST
10205: LIST
10206: LIST
10207: LIST
10208: LIST
10209: PUSH
10210: EMPTY
10211: LIST
10212: LIST
10213: ST_TO_ADDR
10214: GO 11381
10216: LD_INT 14
10218: DOUBLE
10219: EQUAL
10220: IFTRUE 10224
10222: GO 10436
10224: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
10225: LD_ADDR_VAR 0 1
10229: PUSH
10230: LD_INT 1
10232: PUSH
10233: LD_INT 2
10235: PUSH
10236: LD_INT 3
10238: PUSH
10239: LD_INT 4
10241: PUSH
10242: LD_INT 5
10244: PUSH
10245: LD_INT 6
10247: PUSH
10248: LD_INT 7
10250: PUSH
10251: LD_INT 8
10253: PUSH
10254: LD_INT 9
10256: PUSH
10257: LD_INT 10
10259: PUSH
10260: LD_INT 11
10262: PUSH
10263: LD_INT 12
10265: PUSH
10266: LD_INT 13
10268: PUSH
10269: LD_INT 14
10271: PUSH
10272: LD_INT 15
10274: PUSH
10275: LD_INT 16
10277: PUSH
10278: LD_INT 17
10280: PUSH
10281: LD_INT 18
10283: PUSH
10284: LD_INT 19
10286: PUSH
10287: LD_INT 20
10289: PUSH
10290: LD_INT 21
10292: PUSH
10293: LD_INT 22
10295: PUSH
10296: LD_INT 23
10298: PUSH
10299: LD_INT 24
10301: PUSH
10302: LD_INT 25
10304: PUSH
10305: LD_INT 26
10307: PUSH
10308: LD_INT 27
10310: PUSH
10311: LD_INT 28
10313: PUSH
10314: LD_INT 29
10316: PUSH
10317: LD_INT 30
10319: PUSH
10320: LD_INT 31
10322: PUSH
10323: LD_INT 32
10325: PUSH
10326: LD_INT 33
10328: PUSH
10329: LD_INT 34
10331: PUSH
10332: LD_INT 36
10334: PUSH
10335: EMPTY
10336: LIST
10337: LIST
10338: LIST
10339: LIST
10340: LIST
10341: LIST
10342: LIST
10343: LIST
10344: LIST
10345: LIST
10346: LIST
10347: LIST
10348: LIST
10349: LIST
10350: LIST
10351: LIST
10352: LIST
10353: LIST
10354: LIST
10355: LIST
10356: LIST
10357: LIST
10358: LIST
10359: LIST
10360: LIST
10361: LIST
10362: LIST
10363: LIST
10364: LIST
10365: LIST
10366: LIST
10367: LIST
10368: LIST
10369: LIST
10370: LIST
10371: PUSH
10372: LD_INT 101
10374: PUSH
10375: LD_INT 102
10377: PUSH
10378: LD_INT 103
10380: PUSH
10381: LD_INT 104
10383: PUSH
10384: LD_INT 105
10386: PUSH
10387: LD_INT 106
10389: PUSH
10390: LD_INT 107
10392: PUSH
10393: LD_INT 108
10395: PUSH
10396: LD_INT 109
10398: PUSH
10399: LD_INT 110
10401: PUSH
10402: LD_INT 111
10404: PUSH
10405: LD_INT 112
10407: PUSH
10408: LD_INT 113
10410: PUSH
10411: LD_INT 114
10413: PUSH
10414: EMPTY
10415: LIST
10416: LIST
10417: LIST
10418: LIST
10419: LIST
10420: LIST
10421: LIST
10422: LIST
10423: LIST
10424: LIST
10425: LIST
10426: LIST
10427: LIST
10428: LIST
10429: PUSH
10430: EMPTY
10431: LIST
10432: LIST
10433: ST_TO_ADDR
10434: GO 11381
10436: LD_INT 15
10438: DOUBLE
10439: EQUAL
10440: IFTRUE 10444
10442: GO 10656
10444: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
10445: LD_ADDR_VAR 0 1
10449: PUSH
10450: LD_INT 1
10452: PUSH
10453: LD_INT 2
10455: PUSH
10456: LD_INT 3
10458: PUSH
10459: LD_INT 4
10461: PUSH
10462: LD_INT 5
10464: PUSH
10465: LD_INT 6
10467: PUSH
10468: LD_INT 7
10470: PUSH
10471: LD_INT 8
10473: PUSH
10474: LD_INT 9
10476: PUSH
10477: LD_INT 10
10479: PUSH
10480: LD_INT 11
10482: PUSH
10483: LD_INT 12
10485: PUSH
10486: LD_INT 13
10488: PUSH
10489: LD_INT 14
10491: PUSH
10492: LD_INT 15
10494: PUSH
10495: LD_INT 16
10497: PUSH
10498: LD_INT 17
10500: PUSH
10501: LD_INT 18
10503: PUSH
10504: LD_INT 19
10506: PUSH
10507: LD_INT 20
10509: PUSH
10510: LD_INT 21
10512: PUSH
10513: LD_INT 22
10515: PUSH
10516: LD_INT 23
10518: PUSH
10519: LD_INT 24
10521: PUSH
10522: LD_INT 25
10524: PUSH
10525: LD_INT 26
10527: PUSH
10528: LD_INT 27
10530: PUSH
10531: LD_INT 28
10533: PUSH
10534: LD_INT 29
10536: PUSH
10537: LD_INT 30
10539: PUSH
10540: LD_INT 31
10542: PUSH
10543: LD_INT 32
10545: PUSH
10546: LD_INT 33
10548: PUSH
10549: LD_INT 34
10551: PUSH
10552: LD_INT 36
10554: PUSH
10555: EMPTY
10556: LIST
10557: LIST
10558: LIST
10559: LIST
10560: LIST
10561: LIST
10562: LIST
10563: LIST
10564: LIST
10565: LIST
10566: LIST
10567: LIST
10568: LIST
10569: LIST
10570: LIST
10571: LIST
10572: LIST
10573: LIST
10574: LIST
10575: LIST
10576: LIST
10577: LIST
10578: LIST
10579: LIST
10580: LIST
10581: LIST
10582: LIST
10583: LIST
10584: LIST
10585: LIST
10586: LIST
10587: LIST
10588: LIST
10589: LIST
10590: LIST
10591: PUSH
10592: LD_INT 101
10594: PUSH
10595: LD_INT 102
10597: PUSH
10598: LD_INT 103
10600: PUSH
10601: LD_INT 104
10603: PUSH
10604: LD_INT 105
10606: PUSH
10607: LD_INT 106
10609: PUSH
10610: LD_INT 107
10612: PUSH
10613: LD_INT 108
10615: PUSH
10616: LD_INT 109
10618: PUSH
10619: LD_INT 110
10621: PUSH
10622: LD_INT 111
10624: PUSH
10625: LD_INT 112
10627: PUSH
10628: LD_INT 113
10630: PUSH
10631: LD_INT 114
10633: PUSH
10634: EMPTY
10635: LIST
10636: LIST
10637: LIST
10638: LIST
10639: LIST
10640: LIST
10641: LIST
10642: LIST
10643: LIST
10644: LIST
10645: LIST
10646: LIST
10647: LIST
10648: LIST
10649: PUSH
10650: EMPTY
10651: LIST
10652: LIST
10653: ST_TO_ADDR
10654: GO 11381
10656: LD_INT 16
10658: DOUBLE
10659: EQUAL
10660: IFTRUE 10664
10662: GO 10788
10664: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
10665: LD_ADDR_VAR 0 1
10669: PUSH
10670: LD_INT 2
10672: PUSH
10673: LD_INT 4
10675: PUSH
10676: LD_INT 5
10678: PUSH
10679: LD_INT 7
10681: PUSH
10682: LD_INT 11
10684: PUSH
10685: LD_INT 12
10687: PUSH
10688: LD_INT 15
10690: PUSH
10691: LD_INT 16
10693: PUSH
10694: LD_INT 20
10696: PUSH
10697: LD_INT 21
10699: PUSH
10700: LD_INT 22
10702: PUSH
10703: LD_INT 23
10705: PUSH
10706: LD_INT 25
10708: PUSH
10709: LD_INT 26
10711: PUSH
10712: LD_INT 30
10714: PUSH
10715: LD_INT 31
10717: PUSH
10718: LD_INT 32
10720: PUSH
10721: LD_INT 33
10723: PUSH
10724: LD_INT 34
10726: PUSH
10727: EMPTY
10728: LIST
10729: LIST
10730: LIST
10731: LIST
10732: LIST
10733: LIST
10734: LIST
10735: LIST
10736: LIST
10737: LIST
10738: LIST
10739: LIST
10740: LIST
10741: LIST
10742: LIST
10743: LIST
10744: LIST
10745: LIST
10746: LIST
10747: PUSH
10748: LD_INT 101
10750: PUSH
10751: LD_INT 102
10753: PUSH
10754: LD_INT 103
10756: PUSH
10757: LD_INT 106
10759: PUSH
10760: LD_INT 108
10762: PUSH
10763: LD_INT 112
10765: PUSH
10766: LD_INT 113
10768: PUSH
10769: LD_INT 114
10771: PUSH
10772: EMPTY
10773: LIST
10774: LIST
10775: LIST
10776: LIST
10777: LIST
10778: LIST
10779: LIST
10780: LIST
10781: PUSH
10782: EMPTY
10783: LIST
10784: LIST
10785: ST_TO_ADDR
10786: GO 11381
10788: LD_INT 17
10790: DOUBLE
10791: EQUAL
10792: IFTRUE 10796
10794: GO 11008
10796: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
10797: LD_ADDR_VAR 0 1
10801: PUSH
10802: LD_INT 1
10804: PUSH
10805: LD_INT 2
10807: PUSH
10808: LD_INT 3
10810: PUSH
10811: LD_INT 4
10813: PUSH
10814: LD_INT 5
10816: PUSH
10817: LD_INT 6
10819: PUSH
10820: LD_INT 7
10822: PUSH
10823: LD_INT 8
10825: PUSH
10826: LD_INT 9
10828: PUSH
10829: LD_INT 10
10831: PUSH
10832: LD_INT 11
10834: PUSH
10835: LD_INT 12
10837: PUSH
10838: LD_INT 13
10840: PUSH
10841: LD_INT 14
10843: PUSH
10844: LD_INT 15
10846: PUSH
10847: LD_INT 16
10849: PUSH
10850: LD_INT 17
10852: PUSH
10853: LD_INT 18
10855: PUSH
10856: LD_INT 19
10858: PUSH
10859: LD_INT 20
10861: PUSH
10862: LD_INT 21
10864: PUSH
10865: LD_INT 22
10867: PUSH
10868: LD_INT 23
10870: PUSH
10871: LD_INT 24
10873: PUSH
10874: LD_INT 25
10876: PUSH
10877: LD_INT 26
10879: PUSH
10880: LD_INT 27
10882: PUSH
10883: LD_INT 28
10885: PUSH
10886: LD_INT 29
10888: PUSH
10889: LD_INT 30
10891: PUSH
10892: LD_INT 31
10894: PUSH
10895: LD_INT 32
10897: PUSH
10898: LD_INT 33
10900: PUSH
10901: LD_INT 34
10903: PUSH
10904: LD_INT 36
10906: PUSH
10907: EMPTY
10908: LIST
10909: LIST
10910: LIST
10911: LIST
10912: LIST
10913: LIST
10914: LIST
10915: LIST
10916: LIST
10917: LIST
10918: LIST
10919: LIST
10920: LIST
10921: LIST
10922: LIST
10923: LIST
10924: LIST
10925: LIST
10926: LIST
10927: LIST
10928: LIST
10929: LIST
10930: LIST
10931: LIST
10932: LIST
10933: LIST
10934: LIST
10935: LIST
10936: LIST
10937: LIST
10938: LIST
10939: LIST
10940: LIST
10941: LIST
10942: LIST
10943: PUSH
10944: LD_INT 101
10946: PUSH
10947: LD_INT 102
10949: PUSH
10950: LD_INT 103
10952: PUSH
10953: LD_INT 104
10955: PUSH
10956: LD_INT 105
10958: PUSH
10959: LD_INT 106
10961: PUSH
10962: LD_INT 107
10964: PUSH
10965: LD_INT 108
10967: PUSH
10968: LD_INT 109
10970: PUSH
10971: LD_INT 110
10973: PUSH
10974: LD_INT 111
10976: PUSH
10977: LD_INT 112
10979: PUSH
10980: LD_INT 113
10982: PUSH
10983: LD_INT 114
10985: PUSH
10986: EMPTY
10987: LIST
10988: LIST
10989: LIST
10990: LIST
10991: LIST
10992: LIST
10993: LIST
10994: LIST
10995: LIST
10996: LIST
10997: LIST
10998: LIST
10999: LIST
11000: LIST
11001: PUSH
11002: EMPTY
11003: LIST
11004: LIST
11005: ST_TO_ADDR
11006: GO 11381
11008: LD_INT 18
11010: DOUBLE
11011: EQUAL
11012: IFTRUE 11016
11014: GO 11152
11016: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
11017: LD_ADDR_VAR 0 1
11021: PUSH
11022: LD_INT 2
11024: PUSH
11025: LD_INT 4
11027: PUSH
11028: LD_INT 5
11030: PUSH
11031: LD_INT 7
11033: PUSH
11034: LD_INT 11
11036: PUSH
11037: LD_INT 12
11039: PUSH
11040: LD_INT 15
11042: PUSH
11043: LD_INT 16
11045: PUSH
11046: LD_INT 20
11048: PUSH
11049: LD_INT 21
11051: PUSH
11052: LD_INT 22
11054: PUSH
11055: LD_INT 23
11057: PUSH
11058: LD_INT 25
11060: PUSH
11061: LD_INT 26
11063: PUSH
11064: LD_INT 30
11066: PUSH
11067: LD_INT 31
11069: PUSH
11070: LD_INT 32
11072: PUSH
11073: LD_INT 33
11075: PUSH
11076: LD_INT 34
11078: PUSH
11079: LD_INT 35
11081: PUSH
11082: LD_INT 36
11084: PUSH
11085: EMPTY
11086: LIST
11087: LIST
11088: LIST
11089: LIST
11090: LIST
11091: LIST
11092: LIST
11093: LIST
11094: LIST
11095: LIST
11096: LIST
11097: LIST
11098: LIST
11099: LIST
11100: LIST
11101: LIST
11102: LIST
11103: LIST
11104: LIST
11105: LIST
11106: LIST
11107: PUSH
11108: LD_INT 101
11110: PUSH
11111: LD_INT 102
11113: PUSH
11114: LD_INT 103
11116: PUSH
11117: LD_INT 106
11119: PUSH
11120: LD_INT 108
11122: PUSH
11123: LD_INT 112
11125: PUSH
11126: LD_INT 113
11128: PUSH
11129: LD_INT 114
11131: PUSH
11132: LD_INT 115
11134: PUSH
11135: EMPTY
11136: LIST
11137: LIST
11138: LIST
11139: LIST
11140: LIST
11141: LIST
11142: LIST
11143: LIST
11144: LIST
11145: PUSH
11146: EMPTY
11147: LIST
11148: LIST
11149: ST_TO_ADDR
11150: GO 11381
11152: LD_INT 19
11154: DOUBLE
11155: EQUAL
11156: IFTRUE 11160
11158: GO 11380
11160: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
11161: LD_ADDR_VAR 0 1
11165: PUSH
11166: LD_INT 1
11168: PUSH
11169: LD_INT 2
11171: PUSH
11172: LD_INT 3
11174: PUSH
11175: LD_INT 4
11177: PUSH
11178: LD_INT 5
11180: PUSH
11181: LD_INT 6
11183: PUSH
11184: LD_INT 7
11186: PUSH
11187: LD_INT 8
11189: PUSH
11190: LD_INT 9
11192: PUSH
11193: LD_INT 10
11195: PUSH
11196: LD_INT 11
11198: PUSH
11199: LD_INT 12
11201: PUSH
11202: LD_INT 13
11204: PUSH
11205: LD_INT 14
11207: PUSH
11208: LD_INT 15
11210: PUSH
11211: LD_INT 16
11213: PUSH
11214: LD_INT 17
11216: PUSH
11217: LD_INT 18
11219: PUSH
11220: LD_INT 19
11222: PUSH
11223: LD_INT 20
11225: PUSH
11226: LD_INT 21
11228: PUSH
11229: LD_INT 22
11231: PUSH
11232: LD_INT 23
11234: PUSH
11235: LD_INT 24
11237: PUSH
11238: LD_INT 25
11240: PUSH
11241: LD_INT 26
11243: PUSH
11244: LD_INT 27
11246: PUSH
11247: LD_INT 28
11249: PUSH
11250: LD_INT 29
11252: PUSH
11253: LD_INT 30
11255: PUSH
11256: LD_INT 31
11258: PUSH
11259: LD_INT 32
11261: PUSH
11262: LD_INT 33
11264: PUSH
11265: LD_INT 34
11267: PUSH
11268: LD_INT 35
11270: PUSH
11271: LD_INT 36
11273: PUSH
11274: EMPTY
11275: LIST
11276: LIST
11277: LIST
11278: LIST
11279: LIST
11280: LIST
11281: LIST
11282: LIST
11283: LIST
11284: LIST
11285: LIST
11286: LIST
11287: LIST
11288: LIST
11289: LIST
11290: LIST
11291: LIST
11292: LIST
11293: LIST
11294: LIST
11295: LIST
11296: LIST
11297: LIST
11298: LIST
11299: LIST
11300: LIST
11301: LIST
11302: LIST
11303: LIST
11304: LIST
11305: LIST
11306: LIST
11307: LIST
11308: LIST
11309: LIST
11310: LIST
11311: PUSH
11312: LD_INT 101
11314: PUSH
11315: LD_INT 102
11317: PUSH
11318: LD_INT 103
11320: PUSH
11321: LD_INT 104
11323: PUSH
11324: LD_INT 105
11326: PUSH
11327: LD_INT 106
11329: PUSH
11330: LD_INT 107
11332: PUSH
11333: LD_INT 108
11335: PUSH
11336: LD_INT 109
11338: PUSH
11339: LD_INT 110
11341: PUSH
11342: LD_INT 111
11344: PUSH
11345: LD_INT 112
11347: PUSH
11348: LD_INT 113
11350: PUSH
11351: LD_INT 114
11353: PUSH
11354: LD_INT 115
11356: PUSH
11357: EMPTY
11358: LIST
11359: LIST
11360: LIST
11361: LIST
11362: LIST
11363: LIST
11364: LIST
11365: LIST
11366: LIST
11367: LIST
11368: LIST
11369: LIST
11370: LIST
11371: LIST
11372: LIST
11373: PUSH
11374: EMPTY
11375: LIST
11376: LIST
11377: ST_TO_ADDR
11378: GO 11381
11380: POP
// end else
11381: GO 11600
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
11383: LD_ADDR_VAR 0 1
11387: PUSH
11388: LD_INT 1
11390: PUSH
11391: LD_INT 2
11393: PUSH
11394: LD_INT 3
11396: PUSH
11397: LD_INT 4
11399: PUSH
11400: LD_INT 5
11402: PUSH
11403: LD_INT 6
11405: PUSH
11406: LD_INT 7
11408: PUSH
11409: LD_INT 8
11411: PUSH
11412: LD_INT 9
11414: PUSH
11415: LD_INT 10
11417: PUSH
11418: LD_INT 11
11420: PUSH
11421: LD_INT 12
11423: PUSH
11424: LD_INT 13
11426: PUSH
11427: LD_INT 14
11429: PUSH
11430: LD_INT 15
11432: PUSH
11433: LD_INT 16
11435: PUSH
11436: LD_INT 17
11438: PUSH
11439: LD_INT 18
11441: PUSH
11442: LD_INT 19
11444: PUSH
11445: LD_INT 20
11447: PUSH
11448: LD_INT 21
11450: PUSH
11451: LD_INT 22
11453: PUSH
11454: LD_INT 23
11456: PUSH
11457: LD_INT 24
11459: PUSH
11460: LD_INT 25
11462: PUSH
11463: LD_INT 26
11465: PUSH
11466: LD_INT 27
11468: PUSH
11469: LD_INT 28
11471: PUSH
11472: LD_INT 29
11474: PUSH
11475: LD_INT 30
11477: PUSH
11478: LD_INT 31
11480: PUSH
11481: LD_INT 32
11483: PUSH
11484: LD_INT 33
11486: PUSH
11487: LD_INT 34
11489: PUSH
11490: LD_INT 35
11492: PUSH
11493: LD_INT 36
11495: PUSH
11496: EMPTY
11497: LIST
11498: LIST
11499: LIST
11500: LIST
11501: LIST
11502: LIST
11503: LIST
11504: LIST
11505: LIST
11506: LIST
11507: LIST
11508: LIST
11509: LIST
11510: LIST
11511: LIST
11512: LIST
11513: LIST
11514: LIST
11515: LIST
11516: LIST
11517: LIST
11518: LIST
11519: LIST
11520: LIST
11521: LIST
11522: LIST
11523: LIST
11524: LIST
11525: LIST
11526: LIST
11527: LIST
11528: LIST
11529: LIST
11530: LIST
11531: LIST
11532: LIST
11533: PUSH
11534: LD_INT 101
11536: PUSH
11537: LD_INT 102
11539: PUSH
11540: LD_INT 103
11542: PUSH
11543: LD_INT 104
11545: PUSH
11546: LD_INT 105
11548: PUSH
11549: LD_INT 106
11551: PUSH
11552: LD_INT 107
11554: PUSH
11555: LD_INT 108
11557: PUSH
11558: LD_INT 109
11560: PUSH
11561: LD_INT 110
11563: PUSH
11564: LD_INT 111
11566: PUSH
11567: LD_INT 112
11569: PUSH
11570: LD_INT 113
11572: PUSH
11573: LD_INT 114
11575: PUSH
11576: LD_INT 115
11578: PUSH
11579: EMPTY
11580: LIST
11581: LIST
11582: LIST
11583: LIST
11584: LIST
11585: LIST
11586: LIST
11587: LIST
11588: LIST
11589: LIST
11590: LIST
11591: LIST
11592: LIST
11593: LIST
11594: LIST
11595: PUSH
11596: EMPTY
11597: LIST
11598: LIST
11599: ST_TO_ADDR
// if result then
11600: LD_VAR 0 1
11604: IFFALSE 11893
// begin normal :=  ;
11606: LD_ADDR_VAR 0 3
11610: PUSH
11611: LD_STRING 
11613: ST_TO_ADDR
// hardcore :=  ;
11614: LD_ADDR_VAR 0 4
11618: PUSH
11619: LD_STRING 
11621: ST_TO_ADDR
// for i = 1 to normalCounter do
11622: LD_ADDR_VAR 0 5
11626: PUSH
11627: DOUBLE
11628: LD_INT 1
11630: DEC
11631: ST_TO_ADDR
11632: LD_EXP 44
11636: PUSH
11637: FOR_TO
11638: IFFALSE 11739
// begin tmp := 0 ;
11640: LD_ADDR_VAR 0 2
11644: PUSH
11645: LD_STRING 0
11647: ST_TO_ADDR
// if result [ 1 ] then
11648: LD_VAR 0 1
11652: PUSH
11653: LD_INT 1
11655: ARRAY
11656: IFFALSE 11721
// if result [ 1 ] [ 1 ] = i then
11658: LD_VAR 0 1
11662: PUSH
11663: LD_INT 1
11665: ARRAY
11666: PUSH
11667: LD_INT 1
11669: ARRAY
11670: PUSH
11671: LD_VAR 0 5
11675: EQUAL
11676: IFFALSE 11721
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
11678: LD_ADDR_VAR 0 1
11682: PUSH
11683: LD_VAR 0 1
11687: PPUSH
11688: LD_INT 1
11690: PPUSH
11691: LD_VAR 0 1
11695: PUSH
11696: LD_INT 1
11698: ARRAY
11699: PPUSH
11700: LD_INT 1
11702: PPUSH
11703: CALL_OW 3
11707: PPUSH
11708: CALL_OW 1
11712: ST_TO_ADDR
// tmp := 1 ;
11713: LD_ADDR_VAR 0 2
11717: PUSH
11718: LD_STRING 1
11720: ST_TO_ADDR
// end ; normal := normal & tmp ;
11721: LD_ADDR_VAR 0 3
11725: PUSH
11726: LD_VAR 0 3
11730: PUSH
11731: LD_VAR 0 2
11735: STR
11736: ST_TO_ADDR
// end ;
11737: GO 11637
11739: POP
11740: POP
// for i = 1 to hardcoreCounter do
11741: LD_ADDR_VAR 0 5
11745: PUSH
11746: DOUBLE
11747: LD_INT 1
11749: DEC
11750: ST_TO_ADDR
11751: LD_EXP 45
11755: PUSH
11756: FOR_TO
11757: IFFALSE 11862
// begin tmp := 0 ;
11759: LD_ADDR_VAR 0 2
11763: PUSH
11764: LD_STRING 0
11766: ST_TO_ADDR
// if result [ 2 ] then
11767: LD_VAR 0 1
11771: PUSH
11772: LD_INT 2
11774: ARRAY
11775: IFFALSE 11844
// if result [ 2 ] [ 1 ] = 100 + i then
11777: LD_VAR 0 1
11781: PUSH
11782: LD_INT 2
11784: ARRAY
11785: PUSH
11786: LD_INT 1
11788: ARRAY
11789: PUSH
11790: LD_INT 100
11792: PUSH
11793: LD_VAR 0 5
11797: PLUS
11798: EQUAL
11799: IFFALSE 11844
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
11801: LD_ADDR_VAR 0 1
11805: PUSH
11806: LD_VAR 0 1
11810: PPUSH
11811: LD_INT 2
11813: PPUSH
11814: LD_VAR 0 1
11818: PUSH
11819: LD_INT 2
11821: ARRAY
11822: PPUSH
11823: LD_INT 1
11825: PPUSH
11826: CALL_OW 3
11830: PPUSH
11831: CALL_OW 1
11835: ST_TO_ADDR
// tmp := 1 ;
11836: LD_ADDR_VAR 0 2
11840: PUSH
11841: LD_STRING 1
11843: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
11844: LD_ADDR_VAR 0 4
11848: PUSH
11849: LD_VAR 0 4
11853: PUSH
11854: LD_VAR 0 2
11858: STR
11859: ST_TO_ADDR
// end ;
11860: GO 11756
11862: POP
11863: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
11864: LD_STRING getStreamItemsFromMission("
11866: PUSH
11867: LD_VAR 0 3
11871: STR
11872: PUSH
11873: LD_STRING ","
11875: STR
11876: PUSH
11877: LD_VAR 0 4
11881: STR
11882: PUSH
11883: LD_STRING ")
11885: STR
11886: PPUSH
11887: CALL_OW 559
// end else
11891: GO 11900
// ToLua ( getStreamItemsFromMission("","") ) ;
11893: LD_STRING getStreamItemsFromMission("","")
11895: PPUSH
11896: CALL_OW 559
// end ;
11900: LD_VAR 0 1
11904: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
11905: LD_VAR 0 2
11909: PUSH
11910: LD_INT 100
11912: EQUAL
11913: IFFALSE 12862
// begin if not StreamModeActive then
11915: LD_EXP 43
11919: NOT
11920: IFFALSE 11930
// StreamModeActive := true ;
11922: LD_ADDR_EXP 43
11926: PUSH
11927: LD_INT 1
11929: ST_TO_ADDR
// if p3 = 0 then
11930: LD_VAR 0 3
11934: PUSH
11935: LD_INT 0
11937: EQUAL
11938: IFFALSE 11944
// InitStreamMode ;
11940: CALL 7983 0 0
// if p3 = 1 then
11944: LD_VAR 0 3
11948: PUSH
11949: LD_INT 1
11951: EQUAL
11952: IFFALSE 11962
// sRocket := true ;
11954: LD_ADDR_EXP 48
11958: PUSH
11959: LD_INT 1
11961: ST_TO_ADDR
// if p3 = 2 then
11962: LD_VAR 0 3
11966: PUSH
11967: LD_INT 2
11969: EQUAL
11970: IFFALSE 11980
// sSpeed := true ;
11972: LD_ADDR_EXP 47
11976: PUSH
11977: LD_INT 1
11979: ST_TO_ADDR
// if p3 = 3 then
11980: LD_VAR 0 3
11984: PUSH
11985: LD_INT 3
11987: EQUAL
11988: IFFALSE 11998
// sEngine := true ;
11990: LD_ADDR_EXP 49
11994: PUSH
11995: LD_INT 1
11997: ST_TO_ADDR
// if p3 = 4 then
11998: LD_VAR 0 3
12002: PUSH
12003: LD_INT 4
12005: EQUAL
12006: IFFALSE 12016
// sSpec := true ;
12008: LD_ADDR_EXP 46
12012: PUSH
12013: LD_INT 1
12015: ST_TO_ADDR
// if p3 = 5 then
12016: LD_VAR 0 3
12020: PUSH
12021: LD_INT 5
12023: EQUAL
12024: IFFALSE 12034
// sLevel := true ;
12026: LD_ADDR_EXP 50
12030: PUSH
12031: LD_INT 1
12033: ST_TO_ADDR
// if p3 = 6 then
12034: LD_VAR 0 3
12038: PUSH
12039: LD_INT 6
12041: EQUAL
12042: IFFALSE 12052
// sArmoury := true ;
12044: LD_ADDR_EXP 51
12048: PUSH
12049: LD_INT 1
12051: ST_TO_ADDR
// if p3 = 7 then
12052: LD_VAR 0 3
12056: PUSH
12057: LD_INT 7
12059: EQUAL
12060: IFFALSE 12070
// sRadar := true ;
12062: LD_ADDR_EXP 52
12066: PUSH
12067: LD_INT 1
12069: ST_TO_ADDR
// if p3 = 8 then
12070: LD_VAR 0 3
12074: PUSH
12075: LD_INT 8
12077: EQUAL
12078: IFFALSE 12088
// sBunker := true ;
12080: LD_ADDR_EXP 53
12084: PUSH
12085: LD_INT 1
12087: ST_TO_ADDR
// if p3 = 9 then
12088: LD_VAR 0 3
12092: PUSH
12093: LD_INT 9
12095: EQUAL
12096: IFFALSE 12106
// sHack := true ;
12098: LD_ADDR_EXP 54
12102: PUSH
12103: LD_INT 1
12105: ST_TO_ADDR
// if p3 = 10 then
12106: LD_VAR 0 3
12110: PUSH
12111: LD_INT 10
12113: EQUAL
12114: IFFALSE 12124
// sFire := true ;
12116: LD_ADDR_EXP 55
12120: PUSH
12121: LD_INT 1
12123: ST_TO_ADDR
// if p3 = 11 then
12124: LD_VAR 0 3
12128: PUSH
12129: LD_INT 11
12131: EQUAL
12132: IFFALSE 12142
// sRefresh := true ;
12134: LD_ADDR_EXP 56
12138: PUSH
12139: LD_INT 1
12141: ST_TO_ADDR
// if p3 = 12 then
12142: LD_VAR 0 3
12146: PUSH
12147: LD_INT 12
12149: EQUAL
12150: IFFALSE 12160
// sExp := true ;
12152: LD_ADDR_EXP 57
12156: PUSH
12157: LD_INT 1
12159: ST_TO_ADDR
// if p3 = 13 then
12160: LD_VAR 0 3
12164: PUSH
12165: LD_INT 13
12167: EQUAL
12168: IFFALSE 12178
// sDepot := true ;
12170: LD_ADDR_EXP 58
12174: PUSH
12175: LD_INT 1
12177: ST_TO_ADDR
// if p3 = 14 then
12178: LD_VAR 0 3
12182: PUSH
12183: LD_INT 14
12185: EQUAL
12186: IFFALSE 12196
// sFlag := true ;
12188: LD_ADDR_EXP 59
12192: PUSH
12193: LD_INT 1
12195: ST_TO_ADDR
// if p3 = 15 then
12196: LD_VAR 0 3
12200: PUSH
12201: LD_INT 15
12203: EQUAL
12204: IFFALSE 12214
// sKamikadze := true ;
12206: LD_ADDR_EXP 67
12210: PUSH
12211: LD_INT 1
12213: ST_TO_ADDR
// if p3 = 16 then
12214: LD_VAR 0 3
12218: PUSH
12219: LD_INT 16
12221: EQUAL
12222: IFFALSE 12232
// sTroll := true ;
12224: LD_ADDR_EXP 68
12228: PUSH
12229: LD_INT 1
12231: ST_TO_ADDR
// if p3 = 17 then
12232: LD_VAR 0 3
12236: PUSH
12237: LD_INT 17
12239: EQUAL
12240: IFFALSE 12250
// sSlow := true ;
12242: LD_ADDR_EXP 69
12246: PUSH
12247: LD_INT 1
12249: ST_TO_ADDR
// if p3 = 18 then
12250: LD_VAR 0 3
12254: PUSH
12255: LD_INT 18
12257: EQUAL
12258: IFFALSE 12268
// sLack := true ;
12260: LD_ADDR_EXP 70
12264: PUSH
12265: LD_INT 1
12267: ST_TO_ADDR
// if p3 = 19 then
12268: LD_VAR 0 3
12272: PUSH
12273: LD_INT 19
12275: EQUAL
12276: IFFALSE 12286
// sTank := true ;
12278: LD_ADDR_EXP 72
12282: PUSH
12283: LD_INT 1
12285: ST_TO_ADDR
// if p3 = 20 then
12286: LD_VAR 0 3
12290: PUSH
12291: LD_INT 20
12293: EQUAL
12294: IFFALSE 12304
// sRemote := true ;
12296: LD_ADDR_EXP 73
12300: PUSH
12301: LD_INT 1
12303: ST_TO_ADDR
// if p3 = 21 then
12304: LD_VAR 0 3
12308: PUSH
12309: LD_INT 21
12311: EQUAL
12312: IFFALSE 12322
// sPowell := true ;
12314: LD_ADDR_EXP 74
12318: PUSH
12319: LD_INT 1
12321: ST_TO_ADDR
// if p3 = 22 then
12322: LD_VAR 0 3
12326: PUSH
12327: LD_INT 22
12329: EQUAL
12330: IFFALSE 12340
// sTeleport := true ;
12332: LD_ADDR_EXP 77
12336: PUSH
12337: LD_INT 1
12339: ST_TO_ADDR
// if p3 = 23 then
12340: LD_VAR 0 3
12344: PUSH
12345: LD_INT 23
12347: EQUAL
12348: IFFALSE 12358
// sOilTower := true ;
12350: LD_ADDR_EXP 79
12354: PUSH
12355: LD_INT 1
12357: ST_TO_ADDR
// if p3 = 24 then
12358: LD_VAR 0 3
12362: PUSH
12363: LD_INT 24
12365: EQUAL
12366: IFFALSE 12376
// sShovel := true ;
12368: LD_ADDR_EXP 80
12372: PUSH
12373: LD_INT 1
12375: ST_TO_ADDR
// if p3 = 25 then
12376: LD_VAR 0 3
12380: PUSH
12381: LD_INT 25
12383: EQUAL
12384: IFFALSE 12394
// sSheik := true ;
12386: LD_ADDR_EXP 81
12390: PUSH
12391: LD_INT 1
12393: ST_TO_ADDR
// if p3 = 26 then
12394: LD_VAR 0 3
12398: PUSH
12399: LD_INT 26
12401: EQUAL
12402: IFFALSE 12412
// sEarthquake := true ;
12404: LD_ADDR_EXP 83
12408: PUSH
12409: LD_INT 1
12411: ST_TO_ADDR
// if p3 = 27 then
12412: LD_VAR 0 3
12416: PUSH
12417: LD_INT 27
12419: EQUAL
12420: IFFALSE 12430
// sAI := true ;
12422: LD_ADDR_EXP 84
12426: PUSH
12427: LD_INT 1
12429: ST_TO_ADDR
// if p3 = 28 then
12430: LD_VAR 0 3
12434: PUSH
12435: LD_INT 28
12437: EQUAL
12438: IFFALSE 12448
// sCargo := true ;
12440: LD_ADDR_EXP 87
12444: PUSH
12445: LD_INT 1
12447: ST_TO_ADDR
// if p3 = 29 then
12448: LD_VAR 0 3
12452: PUSH
12453: LD_INT 29
12455: EQUAL
12456: IFFALSE 12466
// sDLaser := true ;
12458: LD_ADDR_EXP 88
12462: PUSH
12463: LD_INT 1
12465: ST_TO_ADDR
// if p3 = 30 then
12466: LD_VAR 0 3
12470: PUSH
12471: LD_INT 30
12473: EQUAL
12474: IFFALSE 12484
// sExchange := true ;
12476: LD_ADDR_EXP 89
12480: PUSH
12481: LD_INT 1
12483: ST_TO_ADDR
// if p3 = 31 then
12484: LD_VAR 0 3
12488: PUSH
12489: LD_INT 31
12491: EQUAL
12492: IFFALSE 12502
// sFac := true ;
12494: LD_ADDR_EXP 90
12498: PUSH
12499: LD_INT 1
12501: ST_TO_ADDR
// if p3 = 32 then
12502: LD_VAR 0 3
12506: PUSH
12507: LD_INT 32
12509: EQUAL
12510: IFFALSE 12520
// sPower := true ;
12512: LD_ADDR_EXP 91
12516: PUSH
12517: LD_INT 1
12519: ST_TO_ADDR
// if p3 = 33 then
12520: LD_VAR 0 3
12524: PUSH
12525: LD_INT 33
12527: EQUAL
12528: IFFALSE 12538
// sRandom := true ;
12530: LD_ADDR_EXP 92
12534: PUSH
12535: LD_INT 1
12537: ST_TO_ADDR
// if p3 = 34 then
12538: LD_VAR 0 3
12542: PUSH
12543: LD_INT 34
12545: EQUAL
12546: IFFALSE 12556
// sShield := true ;
12548: LD_ADDR_EXP 93
12552: PUSH
12553: LD_INT 1
12555: ST_TO_ADDR
// if p3 = 35 then
12556: LD_VAR 0 3
12560: PUSH
12561: LD_INT 35
12563: EQUAL
12564: IFFALSE 12574
// sTime := true ;
12566: LD_ADDR_EXP 94
12570: PUSH
12571: LD_INT 1
12573: ST_TO_ADDR
// if p3 = 36 then
12574: LD_VAR 0 3
12578: PUSH
12579: LD_INT 36
12581: EQUAL
12582: IFFALSE 12592
// sTools := true ;
12584: LD_ADDR_EXP 95
12588: PUSH
12589: LD_INT 1
12591: ST_TO_ADDR
// if p3 = 101 then
12592: LD_VAR 0 3
12596: PUSH
12597: LD_INT 101
12599: EQUAL
12600: IFFALSE 12610
// sSold := true ;
12602: LD_ADDR_EXP 60
12606: PUSH
12607: LD_INT 1
12609: ST_TO_ADDR
// if p3 = 102 then
12610: LD_VAR 0 3
12614: PUSH
12615: LD_INT 102
12617: EQUAL
12618: IFFALSE 12628
// sDiff := true ;
12620: LD_ADDR_EXP 61
12624: PUSH
12625: LD_INT 1
12627: ST_TO_ADDR
// if p3 = 103 then
12628: LD_VAR 0 3
12632: PUSH
12633: LD_INT 103
12635: EQUAL
12636: IFFALSE 12646
// sFog := true ;
12638: LD_ADDR_EXP 64
12642: PUSH
12643: LD_INT 1
12645: ST_TO_ADDR
// if p3 = 104 then
12646: LD_VAR 0 3
12650: PUSH
12651: LD_INT 104
12653: EQUAL
12654: IFFALSE 12664
// sReset := true ;
12656: LD_ADDR_EXP 65
12660: PUSH
12661: LD_INT 1
12663: ST_TO_ADDR
// if p3 = 105 then
12664: LD_VAR 0 3
12668: PUSH
12669: LD_INT 105
12671: EQUAL
12672: IFFALSE 12682
// sSun := true ;
12674: LD_ADDR_EXP 66
12678: PUSH
12679: LD_INT 1
12681: ST_TO_ADDR
// if p3 = 106 then
12682: LD_VAR 0 3
12686: PUSH
12687: LD_INT 106
12689: EQUAL
12690: IFFALSE 12700
// sTiger := true ;
12692: LD_ADDR_EXP 62
12696: PUSH
12697: LD_INT 1
12699: ST_TO_ADDR
// if p3 = 107 then
12700: LD_VAR 0 3
12704: PUSH
12705: LD_INT 107
12707: EQUAL
12708: IFFALSE 12718
// sBomb := true ;
12710: LD_ADDR_EXP 63
12714: PUSH
12715: LD_INT 1
12717: ST_TO_ADDR
// if p3 = 108 then
12718: LD_VAR 0 3
12722: PUSH
12723: LD_INT 108
12725: EQUAL
12726: IFFALSE 12736
// sWound := true ;
12728: LD_ADDR_EXP 71
12732: PUSH
12733: LD_INT 1
12735: ST_TO_ADDR
// if p3 = 109 then
12736: LD_VAR 0 3
12740: PUSH
12741: LD_INT 109
12743: EQUAL
12744: IFFALSE 12754
// sBetray := true ;
12746: LD_ADDR_EXP 75
12750: PUSH
12751: LD_INT 1
12753: ST_TO_ADDR
// if p3 = 110 then
12754: LD_VAR 0 3
12758: PUSH
12759: LD_INT 110
12761: EQUAL
12762: IFFALSE 12772
// sContamin := true ;
12764: LD_ADDR_EXP 76
12768: PUSH
12769: LD_INT 1
12771: ST_TO_ADDR
// if p3 = 111 then
12772: LD_VAR 0 3
12776: PUSH
12777: LD_INT 111
12779: EQUAL
12780: IFFALSE 12790
// sOil := true ;
12782: LD_ADDR_EXP 78
12786: PUSH
12787: LD_INT 1
12789: ST_TO_ADDR
// if p3 = 112 then
12790: LD_VAR 0 3
12794: PUSH
12795: LD_INT 112
12797: EQUAL
12798: IFFALSE 12808
// sStu := true ;
12800: LD_ADDR_EXP 82
12804: PUSH
12805: LD_INT 1
12807: ST_TO_ADDR
// if p3 = 113 then
12808: LD_VAR 0 3
12812: PUSH
12813: LD_INT 113
12815: EQUAL
12816: IFFALSE 12826
// sBazooka := true ;
12818: LD_ADDR_EXP 85
12822: PUSH
12823: LD_INT 1
12825: ST_TO_ADDR
// if p3 = 114 then
12826: LD_VAR 0 3
12830: PUSH
12831: LD_INT 114
12833: EQUAL
12834: IFFALSE 12844
// sMortar := true ;
12836: LD_ADDR_EXP 86
12840: PUSH
12841: LD_INT 1
12843: ST_TO_ADDR
// if p3 = 115 then
12844: LD_VAR 0 3
12848: PUSH
12849: LD_INT 115
12851: EQUAL
12852: IFFALSE 12862
// sRanger := true ;
12854: LD_ADDR_EXP 96
12858: PUSH
12859: LD_INT 1
12861: ST_TO_ADDR
// end ; end ;
12862: PPOPN 6
12864: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
12865: LD_EXP 43
12869: PUSH
12870: LD_EXP 48
12874: AND
12875: IFFALSE 12999
12877: GO 12879
12879: DISABLE
12880: LD_INT 0
12882: PPUSH
12883: PPUSH
// begin enable ;
12884: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
12885: LD_ADDR_VAR 0 2
12889: PUSH
12890: LD_INT 22
12892: PUSH
12893: LD_OWVAR 2
12897: PUSH
12898: EMPTY
12899: LIST
12900: LIST
12901: PUSH
12902: LD_INT 2
12904: PUSH
12905: LD_INT 34
12907: PUSH
12908: LD_INT 7
12910: PUSH
12911: EMPTY
12912: LIST
12913: LIST
12914: PUSH
12915: LD_INT 34
12917: PUSH
12918: LD_INT 45
12920: PUSH
12921: EMPTY
12922: LIST
12923: LIST
12924: PUSH
12925: LD_INT 34
12927: PUSH
12928: LD_INT 28
12930: PUSH
12931: EMPTY
12932: LIST
12933: LIST
12934: PUSH
12935: LD_INT 34
12937: PUSH
12938: LD_INT 47
12940: PUSH
12941: EMPTY
12942: LIST
12943: LIST
12944: PUSH
12945: EMPTY
12946: LIST
12947: LIST
12948: LIST
12949: LIST
12950: LIST
12951: PUSH
12952: EMPTY
12953: LIST
12954: LIST
12955: PPUSH
12956: CALL_OW 69
12960: ST_TO_ADDR
// if not tmp then
12961: LD_VAR 0 2
12965: NOT
12966: IFFALSE 12970
// exit ;
12968: GO 12999
// for i in tmp do
12970: LD_ADDR_VAR 0 1
12974: PUSH
12975: LD_VAR 0 2
12979: PUSH
12980: FOR_IN
12981: IFFALSE 12997
// begin SetLives ( i , 0 ) ;
12983: LD_VAR 0 1
12987: PPUSH
12988: LD_INT 0
12990: PPUSH
12991: CALL_OW 234
// end ;
12995: GO 12980
12997: POP
12998: POP
// end ;
12999: PPOPN 2
13001: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
13002: LD_EXP 43
13006: PUSH
13007: LD_EXP 49
13011: AND
13012: IFFALSE 13096
13014: GO 13016
13016: DISABLE
13017: LD_INT 0
13019: PPUSH
13020: PPUSH
// begin enable ;
13021: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
13022: LD_ADDR_VAR 0 2
13026: PUSH
13027: LD_INT 22
13029: PUSH
13030: LD_OWVAR 2
13034: PUSH
13035: EMPTY
13036: LIST
13037: LIST
13038: PUSH
13039: LD_INT 32
13041: PUSH
13042: LD_INT 3
13044: PUSH
13045: EMPTY
13046: LIST
13047: LIST
13048: PUSH
13049: EMPTY
13050: LIST
13051: LIST
13052: PPUSH
13053: CALL_OW 69
13057: ST_TO_ADDR
// if not tmp then
13058: LD_VAR 0 2
13062: NOT
13063: IFFALSE 13067
// exit ;
13065: GO 13096
// for i in tmp do
13067: LD_ADDR_VAR 0 1
13071: PUSH
13072: LD_VAR 0 2
13076: PUSH
13077: FOR_IN
13078: IFFALSE 13094
// begin SetLives ( i , 0 ) ;
13080: LD_VAR 0 1
13084: PPUSH
13085: LD_INT 0
13087: PPUSH
13088: CALL_OW 234
// end ;
13092: GO 13077
13094: POP
13095: POP
// end ;
13096: PPOPN 2
13098: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
13099: LD_EXP 43
13103: PUSH
13104: LD_EXP 46
13108: AND
13109: IFFALSE 13202
13111: GO 13113
13113: DISABLE
13114: LD_INT 0
13116: PPUSH
// begin enable ;
13117: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
13118: LD_ADDR_VAR 0 1
13122: PUSH
13123: LD_INT 22
13125: PUSH
13126: LD_OWVAR 2
13130: PUSH
13131: EMPTY
13132: LIST
13133: LIST
13134: PUSH
13135: LD_INT 2
13137: PUSH
13138: LD_INT 25
13140: PUSH
13141: LD_INT 5
13143: PUSH
13144: EMPTY
13145: LIST
13146: LIST
13147: PUSH
13148: LD_INT 25
13150: PUSH
13151: LD_INT 9
13153: PUSH
13154: EMPTY
13155: LIST
13156: LIST
13157: PUSH
13158: LD_INT 25
13160: PUSH
13161: LD_INT 8
13163: PUSH
13164: EMPTY
13165: LIST
13166: LIST
13167: PUSH
13168: EMPTY
13169: LIST
13170: LIST
13171: LIST
13172: LIST
13173: PUSH
13174: EMPTY
13175: LIST
13176: LIST
13177: PPUSH
13178: CALL_OW 69
13182: PUSH
13183: FOR_IN
13184: IFFALSE 13200
// begin SetClass ( i , 1 ) ;
13186: LD_VAR 0 1
13190: PPUSH
13191: LD_INT 1
13193: PPUSH
13194: CALL_OW 336
// end ;
13198: GO 13183
13200: POP
13201: POP
// end ;
13202: PPOPN 1
13204: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
13205: LD_EXP 43
13209: PUSH
13210: LD_EXP 47
13214: AND
13215: PUSH
13216: LD_OWVAR 65
13220: PUSH
13221: LD_INT 7
13223: LESS
13224: AND
13225: IFFALSE 13239
13227: GO 13229
13229: DISABLE
// begin enable ;
13230: ENABLE
// game_speed := 7 ;
13231: LD_ADDR_OWVAR 65
13235: PUSH
13236: LD_INT 7
13238: ST_TO_ADDR
// end ;
13239: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
13240: LD_EXP 43
13244: PUSH
13245: LD_EXP 50
13249: AND
13250: IFFALSE 13452
13252: GO 13254
13254: DISABLE
13255: LD_INT 0
13257: PPUSH
13258: PPUSH
13259: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
13260: LD_ADDR_VAR 0 3
13264: PUSH
13265: LD_INT 81
13267: PUSH
13268: LD_OWVAR 2
13272: PUSH
13273: EMPTY
13274: LIST
13275: LIST
13276: PUSH
13277: LD_INT 21
13279: PUSH
13280: LD_INT 1
13282: PUSH
13283: EMPTY
13284: LIST
13285: LIST
13286: PUSH
13287: EMPTY
13288: LIST
13289: LIST
13290: PPUSH
13291: CALL_OW 69
13295: ST_TO_ADDR
// if not tmp then
13296: LD_VAR 0 3
13300: NOT
13301: IFFALSE 13305
// exit ;
13303: GO 13452
// if tmp > 5 then
13305: LD_VAR 0 3
13309: PUSH
13310: LD_INT 5
13312: GREATER
13313: IFFALSE 13325
// k := 5 else
13315: LD_ADDR_VAR 0 2
13319: PUSH
13320: LD_INT 5
13322: ST_TO_ADDR
13323: GO 13335
// k := tmp ;
13325: LD_ADDR_VAR 0 2
13329: PUSH
13330: LD_VAR 0 3
13334: ST_TO_ADDR
// for i := 1 to k do
13335: LD_ADDR_VAR 0 1
13339: PUSH
13340: DOUBLE
13341: LD_INT 1
13343: DEC
13344: ST_TO_ADDR
13345: LD_VAR 0 2
13349: PUSH
13350: FOR_TO
13351: IFFALSE 13450
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
13353: LD_VAR 0 3
13357: PUSH
13358: LD_VAR 0 1
13362: ARRAY
13363: PPUSH
13364: LD_VAR 0 1
13368: PUSH
13369: LD_INT 4
13371: MOD
13372: PUSH
13373: LD_INT 1
13375: PLUS
13376: PPUSH
13377: CALL_OW 259
13381: PUSH
13382: LD_INT 10
13384: LESS
13385: IFFALSE 13448
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
13387: LD_VAR 0 3
13391: PUSH
13392: LD_VAR 0 1
13396: ARRAY
13397: PPUSH
13398: LD_VAR 0 1
13402: PUSH
13403: LD_INT 4
13405: MOD
13406: PUSH
13407: LD_INT 1
13409: PLUS
13410: PPUSH
13411: LD_VAR 0 3
13415: PUSH
13416: LD_VAR 0 1
13420: ARRAY
13421: PPUSH
13422: LD_VAR 0 1
13426: PUSH
13427: LD_INT 4
13429: MOD
13430: PUSH
13431: LD_INT 1
13433: PLUS
13434: PPUSH
13435: CALL_OW 259
13439: PUSH
13440: LD_INT 1
13442: PLUS
13443: PPUSH
13444: CALL_OW 237
13448: GO 13350
13450: POP
13451: POP
// end ;
13452: PPOPN 3
13454: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
13455: LD_EXP 43
13459: PUSH
13460: LD_EXP 51
13464: AND
13465: IFFALSE 13485
13467: GO 13469
13469: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
13470: LD_INT 4
13472: PPUSH
13473: LD_OWVAR 2
13477: PPUSH
13478: LD_INT 0
13480: PPUSH
13481: CALL_OW 324
13485: END
// every 0 0$1 trigger StreamModeActive and sShovel do
13486: LD_EXP 43
13490: PUSH
13491: LD_EXP 80
13495: AND
13496: IFFALSE 13516
13498: GO 13500
13500: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
13501: LD_INT 19
13503: PPUSH
13504: LD_OWVAR 2
13508: PPUSH
13509: LD_INT 0
13511: PPUSH
13512: CALL_OW 324
13516: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
13517: LD_EXP 43
13521: PUSH
13522: LD_EXP 52
13526: AND
13527: IFFALSE 13629
13529: GO 13531
13531: DISABLE
13532: LD_INT 0
13534: PPUSH
13535: PPUSH
// begin enable ;
13536: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
13537: LD_ADDR_VAR 0 2
13541: PUSH
13542: LD_INT 22
13544: PUSH
13545: LD_OWVAR 2
13549: PUSH
13550: EMPTY
13551: LIST
13552: LIST
13553: PUSH
13554: LD_INT 2
13556: PUSH
13557: LD_INT 34
13559: PUSH
13560: LD_INT 11
13562: PUSH
13563: EMPTY
13564: LIST
13565: LIST
13566: PUSH
13567: LD_INT 34
13569: PUSH
13570: LD_INT 30
13572: PUSH
13573: EMPTY
13574: LIST
13575: LIST
13576: PUSH
13577: EMPTY
13578: LIST
13579: LIST
13580: LIST
13581: PUSH
13582: EMPTY
13583: LIST
13584: LIST
13585: PPUSH
13586: CALL_OW 69
13590: ST_TO_ADDR
// if not tmp then
13591: LD_VAR 0 2
13595: NOT
13596: IFFALSE 13600
// exit ;
13598: GO 13629
// for i in tmp do
13600: LD_ADDR_VAR 0 1
13604: PUSH
13605: LD_VAR 0 2
13609: PUSH
13610: FOR_IN
13611: IFFALSE 13627
// begin SetLives ( i , 0 ) ;
13613: LD_VAR 0 1
13617: PPUSH
13618: LD_INT 0
13620: PPUSH
13621: CALL_OW 234
// end ;
13625: GO 13610
13627: POP
13628: POP
// end ;
13629: PPOPN 2
13631: END
// every 0 0$1 trigger StreamModeActive and sBunker do
13632: LD_EXP 43
13636: PUSH
13637: LD_EXP 53
13641: AND
13642: IFFALSE 13662
13644: GO 13646
13646: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
13647: LD_INT 32
13649: PPUSH
13650: LD_OWVAR 2
13654: PPUSH
13655: LD_INT 0
13657: PPUSH
13658: CALL_OW 324
13662: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
13663: LD_EXP 43
13667: PUSH
13668: LD_EXP 54
13672: AND
13673: IFFALSE 13854
13675: GO 13677
13677: DISABLE
13678: LD_INT 0
13680: PPUSH
13681: PPUSH
13682: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
13683: LD_ADDR_VAR 0 2
13687: PUSH
13688: LD_INT 22
13690: PUSH
13691: LD_OWVAR 2
13695: PUSH
13696: EMPTY
13697: LIST
13698: LIST
13699: PUSH
13700: LD_INT 33
13702: PUSH
13703: LD_INT 3
13705: PUSH
13706: EMPTY
13707: LIST
13708: LIST
13709: PUSH
13710: EMPTY
13711: LIST
13712: LIST
13713: PPUSH
13714: CALL_OW 69
13718: ST_TO_ADDR
// if not tmp then
13719: LD_VAR 0 2
13723: NOT
13724: IFFALSE 13728
// exit ;
13726: GO 13854
// side := 0 ;
13728: LD_ADDR_VAR 0 3
13732: PUSH
13733: LD_INT 0
13735: ST_TO_ADDR
// for i := 1 to 8 do
13736: LD_ADDR_VAR 0 1
13740: PUSH
13741: DOUBLE
13742: LD_INT 1
13744: DEC
13745: ST_TO_ADDR
13746: LD_INT 8
13748: PUSH
13749: FOR_TO
13750: IFFALSE 13798
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
13752: LD_OWVAR 2
13756: PUSH
13757: LD_VAR 0 1
13761: NONEQUAL
13762: PUSH
13763: LD_OWVAR 2
13767: PPUSH
13768: LD_VAR 0 1
13772: PPUSH
13773: CALL_OW 81
13777: PUSH
13778: LD_INT 2
13780: EQUAL
13781: AND
13782: IFFALSE 13796
// begin side := i ;
13784: LD_ADDR_VAR 0 3
13788: PUSH
13789: LD_VAR 0 1
13793: ST_TO_ADDR
// break ;
13794: GO 13798
// end ;
13796: GO 13749
13798: POP
13799: POP
// if not side then
13800: LD_VAR 0 3
13804: NOT
13805: IFFALSE 13809
// exit ;
13807: GO 13854
// for i := 1 to tmp do
13809: LD_ADDR_VAR 0 1
13813: PUSH
13814: DOUBLE
13815: LD_INT 1
13817: DEC
13818: ST_TO_ADDR
13819: LD_VAR 0 2
13823: PUSH
13824: FOR_TO
13825: IFFALSE 13852
// if Prob ( 60 ) then
13827: LD_INT 60
13829: PPUSH
13830: CALL_OW 13
13834: IFFALSE 13850
// SetSide ( i , side ) ;
13836: LD_VAR 0 1
13840: PPUSH
13841: LD_VAR 0 3
13845: PPUSH
13846: CALL_OW 235
13850: GO 13824
13852: POP
13853: POP
// end ;
13854: PPOPN 3
13856: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
13857: LD_EXP 43
13861: PUSH
13862: LD_EXP 56
13866: AND
13867: IFFALSE 13986
13869: GO 13871
13871: DISABLE
13872: LD_INT 0
13874: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
13875: LD_ADDR_VAR 0 1
13879: PUSH
13880: LD_INT 22
13882: PUSH
13883: LD_OWVAR 2
13887: PUSH
13888: EMPTY
13889: LIST
13890: LIST
13891: PUSH
13892: LD_INT 21
13894: PUSH
13895: LD_INT 1
13897: PUSH
13898: EMPTY
13899: LIST
13900: LIST
13901: PUSH
13902: LD_INT 3
13904: PUSH
13905: LD_INT 23
13907: PUSH
13908: LD_INT 0
13910: PUSH
13911: EMPTY
13912: LIST
13913: LIST
13914: PUSH
13915: EMPTY
13916: LIST
13917: LIST
13918: PUSH
13919: EMPTY
13920: LIST
13921: LIST
13922: LIST
13923: PPUSH
13924: CALL_OW 69
13928: PUSH
13929: FOR_IN
13930: IFFALSE 13984
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
13932: LD_VAR 0 1
13936: PPUSH
13937: CALL_OW 257
13941: PUSH
13942: LD_INT 1
13944: PUSH
13945: LD_INT 2
13947: PUSH
13948: LD_INT 3
13950: PUSH
13951: LD_INT 4
13953: PUSH
13954: EMPTY
13955: LIST
13956: LIST
13957: LIST
13958: LIST
13959: IN
13960: IFFALSE 13982
// SetClass ( un , rand ( 1 , 4 ) ) ;
13962: LD_VAR 0 1
13966: PPUSH
13967: LD_INT 1
13969: PPUSH
13970: LD_INT 4
13972: PPUSH
13973: CALL_OW 12
13977: PPUSH
13978: CALL_OW 336
13982: GO 13929
13984: POP
13985: POP
// end ;
13986: PPOPN 1
13988: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
13989: LD_EXP 43
13993: PUSH
13994: LD_EXP 55
13998: AND
13999: IFFALSE 14078
14001: GO 14003
14003: DISABLE
14004: LD_INT 0
14006: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
14007: LD_ADDR_VAR 0 1
14011: PUSH
14012: LD_INT 22
14014: PUSH
14015: LD_OWVAR 2
14019: PUSH
14020: EMPTY
14021: LIST
14022: LIST
14023: PUSH
14024: LD_INT 21
14026: PUSH
14027: LD_INT 3
14029: PUSH
14030: EMPTY
14031: LIST
14032: LIST
14033: PUSH
14034: EMPTY
14035: LIST
14036: LIST
14037: PPUSH
14038: CALL_OW 69
14042: ST_TO_ADDR
// if not tmp then
14043: LD_VAR 0 1
14047: NOT
14048: IFFALSE 14052
// exit ;
14050: GO 14078
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
14052: LD_VAR 0 1
14056: PUSH
14057: LD_INT 1
14059: PPUSH
14060: LD_VAR 0 1
14064: PPUSH
14065: CALL_OW 12
14069: ARRAY
14070: PPUSH
14071: LD_INT 100
14073: PPUSH
14074: CALL_OW 234
// end ;
14078: PPOPN 1
14080: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
14081: LD_EXP 43
14085: PUSH
14086: LD_EXP 57
14090: AND
14091: IFFALSE 14189
14093: GO 14095
14095: DISABLE
14096: LD_INT 0
14098: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
14099: LD_ADDR_VAR 0 1
14103: PUSH
14104: LD_INT 22
14106: PUSH
14107: LD_OWVAR 2
14111: PUSH
14112: EMPTY
14113: LIST
14114: LIST
14115: PUSH
14116: LD_INT 21
14118: PUSH
14119: LD_INT 1
14121: PUSH
14122: EMPTY
14123: LIST
14124: LIST
14125: PUSH
14126: EMPTY
14127: LIST
14128: LIST
14129: PPUSH
14130: CALL_OW 69
14134: ST_TO_ADDR
// if not tmp then
14135: LD_VAR 0 1
14139: NOT
14140: IFFALSE 14144
// exit ;
14142: GO 14189
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
14144: LD_VAR 0 1
14148: PUSH
14149: LD_INT 1
14151: PPUSH
14152: LD_VAR 0 1
14156: PPUSH
14157: CALL_OW 12
14161: ARRAY
14162: PPUSH
14163: LD_INT 1
14165: PPUSH
14166: LD_INT 4
14168: PPUSH
14169: CALL_OW 12
14173: PPUSH
14174: LD_INT 3000
14176: PPUSH
14177: LD_INT 9000
14179: PPUSH
14180: CALL_OW 12
14184: PPUSH
14185: CALL_OW 492
// end ;
14189: PPOPN 1
14191: END
// every 0 0$1 trigger StreamModeActive and sDepot do
14192: LD_EXP 43
14196: PUSH
14197: LD_EXP 58
14201: AND
14202: IFFALSE 14222
14204: GO 14206
14206: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
14207: LD_INT 1
14209: PPUSH
14210: LD_OWVAR 2
14214: PPUSH
14215: LD_INT 0
14217: PPUSH
14218: CALL_OW 324
14222: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
14223: LD_EXP 43
14227: PUSH
14228: LD_EXP 59
14232: AND
14233: IFFALSE 14316
14235: GO 14237
14237: DISABLE
14238: LD_INT 0
14240: PPUSH
14241: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
14242: LD_ADDR_VAR 0 2
14246: PUSH
14247: LD_INT 22
14249: PUSH
14250: LD_OWVAR 2
14254: PUSH
14255: EMPTY
14256: LIST
14257: LIST
14258: PUSH
14259: LD_INT 21
14261: PUSH
14262: LD_INT 3
14264: PUSH
14265: EMPTY
14266: LIST
14267: LIST
14268: PUSH
14269: EMPTY
14270: LIST
14271: LIST
14272: PPUSH
14273: CALL_OW 69
14277: ST_TO_ADDR
// if not tmp then
14278: LD_VAR 0 2
14282: NOT
14283: IFFALSE 14287
// exit ;
14285: GO 14316
// for i in tmp do
14287: LD_ADDR_VAR 0 1
14291: PUSH
14292: LD_VAR 0 2
14296: PUSH
14297: FOR_IN
14298: IFFALSE 14314
// SetBLevel ( i , 10 ) ;
14300: LD_VAR 0 1
14304: PPUSH
14305: LD_INT 10
14307: PPUSH
14308: CALL_OW 241
14312: GO 14297
14314: POP
14315: POP
// end ;
14316: PPOPN 2
14318: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
14319: LD_EXP 43
14323: PUSH
14324: LD_EXP 60
14328: AND
14329: IFFALSE 14440
14331: GO 14333
14333: DISABLE
14334: LD_INT 0
14336: PPUSH
14337: PPUSH
14338: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
14339: LD_ADDR_VAR 0 3
14343: PUSH
14344: LD_INT 22
14346: PUSH
14347: LD_OWVAR 2
14351: PUSH
14352: EMPTY
14353: LIST
14354: LIST
14355: PUSH
14356: LD_INT 25
14358: PUSH
14359: LD_INT 1
14361: PUSH
14362: EMPTY
14363: LIST
14364: LIST
14365: PUSH
14366: EMPTY
14367: LIST
14368: LIST
14369: PPUSH
14370: CALL_OW 69
14374: ST_TO_ADDR
// if not tmp then
14375: LD_VAR 0 3
14379: NOT
14380: IFFALSE 14384
// exit ;
14382: GO 14440
// un := tmp [ rand ( 1 , tmp ) ] ;
14384: LD_ADDR_VAR 0 2
14388: PUSH
14389: LD_VAR 0 3
14393: PUSH
14394: LD_INT 1
14396: PPUSH
14397: LD_VAR 0 3
14401: PPUSH
14402: CALL_OW 12
14406: ARRAY
14407: ST_TO_ADDR
// if Crawls ( un ) then
14408: LD_VAR 0 2
14412: PPUSH
14413: CALL_OW 318
14417: IFFALSE 14428
// ComWalk ( un ) ;
14419: LD_VAR 0 2
14423: PPUSH
14424: CALL_OW 138
// SetClass ( un , class_sniper ) ;
14428: LD_VAR 0 2
14432: PPUSH
14433: LD_INT 5
14435: PPUSH
14436: CALL_OW 336
// end ;
14440: PPOPN 3
14442: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
14443: LD_EXP 43
14447: PUSH
14448: LD_EXP 61
14452: AND
14453: PUSH
14454: LD_OWVAR 67
14458: PUSH
14459: LD_INT 3
14461: LESS
14462: AND
14463: IFFALSE 14482
14465: GO 14467
14467: DISABLE
// Difficulty := Difficulty + 1 ;
14468: LD_ADDR_OWVAR 67
14472: PUSH
14473: LD_OWVAR 67
14477: PUSH
14478: LD_INT 1
14480: PLUS
14481: ST_TO_ADDR
14482: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
14483: LD_EXP 43
14487: PUSH
14488: LD_EXP 62
14492: AND
14493: IFFALSE 14596
14495: GO 14497
14497: DISABLE
14498: LD_INT 0
14500: PPUSH
// begin for i := 1 to 5 do
14501: LD_ADDR_VAR 0 1
14505: PUSH
14506: DOUBLE
14507: LD_INT 1
14509: DEC
14510: ST_TO_ADDR
14511: LD_INT 5
14513: PUSH
14514: FOR_TO
14515: IFFALSE 14594
// begin uc_nation := nation_nature ;
14517: LD_ADDR_OWVAR 21
14521: PUSH
14522: LD_INT 0
14524: ST_TO_ADDR
// uc_side := 0 ;
14525: LD_ADDR_OWVAR 20
14529: PUSH
14530: LD_INT 0
14532: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
14533: LD_ADDR_OWVAR 29
14537: PUSH
14538: LD_INT 12
14540: PUSH
14541: LD_INT 12
14543: PUSH
14544: EMPTY
14545: LIST
14546: LIST
14547: ST_TO_ADDR
// hc_agressivity := 20 ;
14548: LD_ADDR_OWVAR 35
14552: PUSH
14553: LD_INT 20
14555: ST_TO_ADDR
// hc_class := class_tiger ;
14556: LD_ADDR_OWVAR 28
14560: PUSH
14561: LD_INT 14
14563: ST_TO_ADDR
// hc_gallery :=  ;
14564: LD_ADDR_OWVAR 33
14568: PUSH
14569: LD_STRING 
14571: ST_TO_ADDR
// hc_name :=  ;
14572: LD_ADDR_OWVAR 26
14576: PUSH
14577: LD_STRING 
14579: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
14580: CALL_OW 44
14584: PPUSH
14585: LD_INT 0
14587: PPUSH
14588: CALL_OW 51
// end ;
14592: GO 14514
14594: POP
14595: POP
// end ;
14596: PPOPN 1
14598: END
// every 0 0$1 trigger StreamModeActive and sBomb do
14599: LD_EXP 43
14603: PUSH
14604: LD_EXP 63
14608: AND
14609: IFFALSE 14618
14611: GO 14613
14613: DISABLE
// StreamSibBomb ;
14614: CALL 14619 0 0
14618: END
// export function StreamSibBomb ; var i , x , y ; begin
14619: LD_INT 0
14621: PPUSH
14622: PPUSH
14623: PPUSH
14624: PPUSH
// result := false ;
14625: LD_ADDR_VAR 0 1
14629: PUSH
14630: LD_INT 0
14632: ST_TO_ADDR
// for i := 1 to 16 do
14633: LD_ADDR_VAR 0 2
14637: PUSH
14638: DOUBLE
14639: LD_INT 1
14641: DEC
14642: ST_TO_ADDR
14643: LD_INT 16
14645: PUSH
14646: FOR_TO
14647: IFFALSE 14846
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
14649: LD_ADDR_VAR 0 3
14653: PUSH
14654: LD_INT 10
14656: PUSH
14657: LD_INT 20
14659: PUSH
14660: LD_INT 30
14662: PUSH
14663: LD_INT 40
14665: PUSH
14666: LD_INT 50
14668: PUSH
14669: LD_INT 60
14671: PUSH
14672: LD_INT 70
14674: PUSH
14675: LD_INT 80
14677: PUSH
14678: LD_INT 90
14680: PUSH
14681: LD_INT 100
14683: PUSH
14684: LD_INT 110
14686: PUSH
14687: LD_INT 120
14689: PUSH
14690: LD_INT 130
14692: PUSH
14693: LD_INT 140
14695: PUSH
14696: LD_INT 150
14698: PUSH
14699: EMPTY
14700: LIST
14701: LIST
14702: LIST
14703: LIST
14704: LIST
14705: LIST
14706: LIST
14707: LIST
14708: LIST
14709: LIST
14710: LIST
14711: LIST
14712: LIST
14713: LIST
14714: LIST
14715: PUSH
14716: LD_INT 1
14718: PPUSH
14719: LD_INT 15
14721: PPUSH
14722: CALL_OW 12
14726: ARRAY
14727: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
14728: LD_ADDR_VAR 0 4
14732: PUSH
14733: LD_INT 10
14735: PUSH
14736: LD_INT 20
14738: PUSH
14739: LD_INT 30
14741: PUSH
14742: LD_INT 40
14744: PUSH
14745: LD_INT 50
14747: PUSH
14748: LD_INT 60
14750: PUSH
14751: LD_INT 70
14753: PUSH
14754: LD_INT 80
14756: PUSH
14757: LD_INT 90
14759: PUSH
14760: LD_INT 100
14762: PUSH
14763: LD_INT 110
14765: PUSH
14766: LD_INT 120
14768: PUSH
14769: LD_INT 130
14771: PUSH
14772: LD_INT 140
14774: PUSH
14775: LD_INT 150
14777: PUSH
14778: EMPTY
14779: LIST
14780: LIST
14781: LIST
14782: LIST
14783: LIST
14784: LIST
14785: LIST
14786: LIST
14787: LIST
14788: LIST
14789: LIST
14790: LIST
14791: LIST
14792: LIST
14793: LIST
14794: PUSH
14795: LD_INT 1
14797: PPUSH
14798: LD_INT 15
14800: PPUSH
14801: CALL_OW 12
14805: ARRAY
14806: ST_TO_ADDR
// if ValidHex ( x , y ) then
14807: LD_VAR 0 3
14811: PPUSH
14812: LD_VAR 0 4
14816: PPUSH
14817: CALL_OW 488
14821: IFFALSE 14844
// begin result := [ x , y ] ;
14823: LD_ADDR_VAR 0 1
14827: PUSH
14828: LD_VAR 0 3
14832: PUSH
14833: LD_VAR 0 4
14837: PUSH
14838: EMPTY
14839: LIST
14840: LIST
14841: ST_TO_ADDR
// break ;
14842: GO 14846
// end ; end ;
14844: GO 14646
14846: POP
14847: POP
// if result then
14848: LD_VAR 0 1
14852: IFFALSE 14912
// begin ToLua ( playSibBomb() ) ;
14854: LD_STRING playSibBomb()
14856: PPUSH
14857: CALL_OW 559
// wait ( 0 0$14 ) ;
14861: LD_INT 490
14863: PPUSH
14864: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
14868: LD_VAR 0 1
14872: PUSH
14873: LD_INT 1
14875: ARRAY
14876: PPUSH
14877: LD_VAR 0 1
14881: PUSH
14882: LD_INT 2
14884: ARRAY
14885: PPUSH
14886: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
14890: LD_VAR 0 1
14894: PUSH
14895: LD_INT 1
14897: ARRAY
14898: PPUSH
14899: LD_VAR 0 1
14903: PUSH
14904: LD_INT 2
14906: ARRAY
14907: PPUSH
14908: CALL_OW 429
// end ; end ;
14912: LD_VAR 0 1
14916: RET
// every 0 0$1 trigger StreamModeActive and sReset do
14917: LD_EXP 43
14921: PUSH
14922: LD_EXP 65
14926: AND
14927: IFFALSE 14939
14929: GO 14931
14931: DISABLE
// YouLost (  ) ;
14932: LD_STRING 
14934: PPUSH
14935: CALL_OW 104
14939: END
// every 0 0$1 trigger StreamModeActive and sFog do
14940: LD_EXP 43
14944: PUSH
14945: LD_EXP 64
14949: AND
14950: IFFALSE 14964
14952: GO 14954
14954: DISABLE
// FogOff ( your_side ) ;
14955: LD_OWVAR 2
14959: PPUSH
14960: CALL_OW 344
14964: END
// every 0 0$1 trigger StreamModeActive and sSun do
14965: LD_EXP 43
14969: PUSH
14970: LD_EXP 66
14974: AND
14975: IFFALSE 15003
14977: GO 14979
14979: DISABLE
// begin solar_recharge_percent := 0 ;
14980: LD_ADDR_OWVAR 79
14984: PUSH
14985: LD_INT 0
14987: ST_TO_ADDR
// wait ( 5 5$00 ) ;
14988: LD_INT 10500
14990: PPUSH
14991: CALL_OW 67
// solar_recharge_percent := 100 ;
14995: LD_ADDR_OWVAR 79
14999: PUSH
15000: LD_INT 100
15002: ST_TO_ADDR
// end ;
15003: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
15004: LD_EXP 43
15008: PUSH
15009: LD_EXP 67
15013: AND
15014: IFFALSE 15253
15016: GO 15018
15018: DISABLE
15019: LD_INT 0
15021: PPUSH
15022: PPUSH
15023: PPUSH
// begin tmp := [ ] ;
15024: LD_ADDR_VAR 0 3
15028: PUSH
15029: EMPTY
15030: ST_TO_ADDR
// for i := 1 to 6 do
15031: LD_ADDR_VAR 0 1
15035: PUSH
15036: DOUBLE
15037: LD_INT 1
15039: DEC
15040: ST_TO_ADDR
15041: LD_INT 6
15043: PUSH
15044: FOR_TO
15045: IFFALSE 15150
// begin uc_nation := nation_nature ;
15047: LD_ADDR_OWVAR 21
15051: PUSH
15052: LD_INT 0
15054: ST_TO_ADDR
// uc_side := 0 ;
15055: LD_ADDR_OWVAR 20
15059: PUSH
15060: LD_INT 0
15062: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
15063: LD_ADDR_OWVAR 29
15067: PUSH
15068: LD_INT 12
15070: PUSH
15071: LD_INT 12
15073: PUSH
15074: EMPTY
15075: LIST
15076: LIST
15077: ST_TO_ADDR
// hc_agressivity := 20 ;
15078: LD_ADDR_OWVAR 35
15082: PUSH
15083: LD_INT 20
15085: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
15086: LD_ADDR_OWVAR 28
15090: PUSH
15091: LD_INT 17
15093: ST_TO_ADDR
// hc_gallery :=  ;
15094: LD_ADDR_OWVAR 33
15098: PUSH
15099: LD_STRING 
15101: ST_TO_ADDR
// hc_name :=  ;
15102: LD_ADDR_OWVAR 26
15106: PUSH
15107: LD_STRING 
15109: ST_TO_ADDR
// un := CreateHuman ;
15110: LD_ADDR_VAR 0 2
15114: PUSH
15115: CALL_OW 44
15119: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
15120: LD_VAR 0 2
15124: PPUSH
15125: LD_INT 1
15127: PPUSH
15128: CALL_OW 51
// tmp := tmp ^ un ;
15132: LD_ADDR_VAR 0 3
15136: PUSH
15137: LD_VAR 0 3
15141: PUSH
15142: LD_VAR 0 2
15146: ADD
15147: ST_TO_ADDR
// end ;
15148: GO 15044
15150: POP
15151: POP
// repeat wait ( 0 0$1 ) ;
15152: LD_INT 35
15154: PPUSH
15155: CALL_OW 67
// for un in tmp do
15159: LD_ADDR_VAR 0 2
15163: PUSH
15164: LD_VAR 0 3
15168: PUSH
15169: FOR_IN
15170: IFFALSE 15244
// begin if IsDead ( un ) then
15172: LD_VAR 0 2
15176: PPUSH
15177: CALL_OW 301
15181: IFFALSE 15201
// begin tmp := tmp diff un ;
15183: LD_ADDR_VAR 0 3
15187: PUSH
15188: LD_VAR 0 3
15192: PUSH
15193: LD_VAR 0 2
15197: DIFF
15198: ST_TO_ADDR
// continue ;
15199: GO 15169
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
15201: LD_VAR 0 2
15205: PPUSH
15206: LD_INT 3
15208: PUSH
15209: LD_INT 22
15211: PUSH
15212: LD_INT 0
15214: PUSH
15215: EMPTY
15216: LIST
15217: LIST
15218: PUSH
15219: EMPTY
15220: LIST
15221: LIST
15222: PPUSH
15223: CALL_OW 69
15227: PPUSH
15228: LD_VAR 0 2
15232: PPUSH
15233: CALL_OW 74
15237: PPUSH
15238: CALL_OW 115
// end ;
15242: GO 15169
15244: POP
15245: POP
// until not tmp ;
15246: LD_VAR 0 3
15250: NOT
15251: IFFALSE 15152
// end ;
15253: PPOPN 3
15255: END
// every 0 0$1 trigger StreamModeActive and sTroll do
15256: LD_EXP 43
15260: PUSH
15261: LD_EXP 68
15265: AND
15266: IFFALSE 15320
15268: GO 15270
15270: DISABLE
// begin ToLua ( displayTroll(); ) ;
15271: LD_STRING displayTroll();
15273: PPUSH
15274: CALL_OW 559
// wait ( 3 3$00 ) ;
15278: LD_INT 6300
15280: PPUSH
15281: CALL_OW 67
// ToLua ( hideTroll(); ) ;
15285: LD_STRING hideTroll();
15287: PPUSH
15288: CALL_OW 559
// wait ( 1 1$00 ) ;
15292: LD_INT 2100
15294: PPUSH
15295: CALL_OW 67
// ToLua ( displayTroll(); ) ;
15299: LD_STRING displayTroll();
15301: PPUSH
15302: CALL_OW 559
// wait ( 1 1$00 ) ;
15306: LD_INT 2100
15308: PPUSH
15309: CALL_OW 67
// ToLua ( hideTroll(); ) ;
15313: LD_STRING hideTroll();
15315: PPUSH
15316: CALL_OW 559
// end ;
15320: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
15321: LD_EXP 43
15325: PUSH
15326: LD_EXP 69
15330: AND
15331: IFFALSE 15394
15333: GO 15335
15335: DISABLE
15336: LD_INT 0
15338: PPUSH
// begin p := 0 ;
15339: LD_ADDR_VAR 0 1
15343: PUSH
15344: LD_INT 0
15346: ST_TO_ADDR
// repeat game_speed := 1 ;
15347: LD_ADDR_OWVAR 65
15351: PUSH
15352: LD_INT 1
15354: ST_TO_ADDR
// wait ( 0 0$1 ) ;
15355: LD_INT 35
15357: PPUSH
15358: CALL_OW 67
// p := p + 1 ;
15362: LD_ADDR_VAR 0 1
15366: PUSH
15367: LD_VAR 0 1
15371: PUSH
15372: LD_INT 1
15374: PLUS
15375: ST_TO_ADDR
// until p >= 60 ;
15376: LD_VAR 0 1
15380: PUSH
15381: LD_INT 60
15383: GREATEREQUAL
15384: IFFALSE 15347
// game_speed := 4 ;
15386: LD_ADDR_OWVAR 65
15390: PUSH
15391: LD_INT 4
15393: ST_TO_ADDR
// end ;
15394: PPOPN 1
15396: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
15397: LD_EXP 43
15401: PUSH
15402: LD_EXP 70
15406: AND
15407: IFFALSE 15553
15409: GO 15411
15411: DISABLE
15412: LD_INT 0
15414: PPUSH
15415: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
15416: LD_ADDR_VAR 0 1
15420: PUSH
15421: LD_INT 22
15423: PUSH
15424: LD_OWVAR 2
15428: PUSH
15429: EMPTY
15430: LIST
15431: LIST
15432: PUSH
15433: LD_INT 2
15435: PUSH
15436: LD_INT 30
15438: PUSH
15439: LD_INT 0
15441: PUSH
15442: EMPTY
15443: LIST
15444: LIST
15445: PUSH
15446: LD_INT 30
15448: PUSH
15449: LD_INT 1
15451: PUSH
15452: EMPTY
15453: LIST
15454: LIST
15455: PUSH
15456: EMPTY
15457: LIST
15458: LIST
15459: LIST
15460: PUSH
15461: EMPTY
15462: LIST
15463: LIST
15464: PPUSH
15465: CALL_OW 69
15469: ST_TO_ADDR
// if not depot then
15470: LD_VAR 0 1
15474: NOT
15475: IFFALSE 15479
// exit ;
15477: GO 15553
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
15479: LD_ADDR_VAR 0 2
15483: PUSH
15484: LD_VAR 0 1
15488: PUSH
15489: LD_INT 1
15491: PPUSH
15492: LD_VAR 0 1
15496: PPUSH
15497: CALL_OW 12
15501: ARRAY
15502: PPUSH
15503: CALL_OW 274
15507: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
15508: LD_VAR 0 2
15512: PPUSH
15513: LD_INT 1
15515: PPUSH
15516: LD_INT 0
15518: PPUSH
15519: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
15523: LD_VAR 0 2
15527: PPUSH
15528: LD_INT 2
15530: PPUSH
15531: LD_INT 0
15533: PPUSH
15534: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
15538: LD_VAR 0 2
15542: PPUSH
15543: LD_INT 3
15545: PPUSH
15546: LD_INT 0
15548: PPUSH
15549: CALL_OW 277
// end ;
15553: PPOPN 2
15555: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
15556: LD_EXP 43
15560: PUSH
15561: LD_EXP 71
15565: AND
15566: IFFALSE 15663
15568: GO 15570
15570: DISABLE
15571: LD_INT 0
15573: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
15574: LD_ADDR_VAR 0 1
15578: PUSH
15579: LD_INT 22
15581: PUSH
15582: LD_OWVAR 2
15586: PUSH
15587: EMPTY
15588: LIST
15589: LIST
15590: PUSH
15591: LD_INT 21
15593: PUSH
15594: LD_INT 1
15596: PUSH
15597: EMPTY
15598: LIST
15599: LIST
15600: PUSH
15601: LD_INT 3
15603: PUSH
15604: LD_INT 23
15606: PUSH
15607: LD_INT 0
15609: PUSH
15610: EMPTY
15611: LIST
15612: LIST
15613: PUSH
15614: EMPTY
15615: LIST
15616: LIST
15617: PUSH
15618: EMPTY
15619: LIST
15620: LIST
15621: LIST
15622: PPUSH
15623: CALL_OW 69
15627: ST_TO_ADDR
// if not tmp then
15628: LD_VAR 0 1
15632: NOT
15633: IFFALSE 15637
// exit ;
15635: GO 15663
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
15637: LD_VAR 0 1
15641: PUSH
15642: LD_INT 1
15644: PPUSH
15645: LD_VAR 0 1
15649: PPUSH
15650: CALL_OW 12
15654: ARRAY
15655: PPUSH
15656: LD_INT 200
15658: PPUSH
15659: CALL_OW 234
// end ;
15663: PPOPN 1
15665: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
15666: LD_EXP 43
15670: PUSH
15671: LD_EXP 72
15675: AND
15676: IFFALSE 15755
15678: GO 15680
15680: DISABLE
15681: LD_INT 0
15683: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
15684: LD_ADDR_VAR 0 1
15688: PUSH
15689: LD_INT 22
15691: PUSH
15692: LD_OWVAR 2
15696: PUSH
15697: EMPTY
15698: LIST
15699: LIST
15700: PUSH
15701: LD_INT 21
15703: PUSH
15704: LD_INT 2
15706: PUSH
15707: EMPTY
15708: LIST
15709: LIST
15710: PUSH
15711: EMPTY
15712: LIST
15713: LIST
15714: PPUSH
15715: CALL_OW 69
15719: ST_TO_ADDR
// if not tmp then
15720: LD_VAR 0 1
15724: NOT
15725: IFFALSE 15729
// exit ;
15727: GO 15755
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
15729: LD_VAR 0 1
15733: PUSH
15734: LD_INT 1
15736: PPUSH
15737: LD_VAR 0 1
15741: PPUSH
15742: CALL_OW 12
15746: ARRAY
15747: PPUSH
15748: LD_INT 60
15750: PPUSH
15751: CALL_OW 234
// end ;
15755: PPOPN 1
15757: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
15758: LD_EXP 43
15762: PUSH
15763: LD_EXP 73
15767: AND
15768: IFFALSE 15867
15770: GO 15772
15772: DISABLE
15773: LD_INT 0
15775: PPUSH
15776: PPUSH
// begin enable ;
15777: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
15778: LD_ADDR_VAR 0 1
15782: PUSH
15783: LD_INT 22
15785: PUSH
15786: LD_OWVAR 2
15790: PUSH
15791: EMPTY
15792: LIST
15793: LIST
15794: PUSH
15795: LD_INT 61
15797: PUSH
15798: EMPTY
15799: LIST
15800: PUSH
15801: LD_INT 33
15803: PUSH
15804: LD_INT 2
15806: PUSH
15807: EMPTY
15808: LIST
15809: LIST
15810: PUSH
15811: EMPTY
15812: LIST
15813: LIST
15814: LIST
15815: PPUSH
15816: CALL_OW 69
15820: ST_TO_ADDR
// if not tmp then
15821: LD_VAR 0 1
15825: NOT
15826: IFFALSE 15830
// exit ;
15828: GO 15867
// for i in tmp do
15830: LD_ADDR_VAR 0 2
15834: PUSH
15835: LD_VAR 0 1
15839: PUSH
15840: FOR_IN
15841: IFFALSE 15865
// if IsControledBy ( i ) then
15843: LD_VAR 0 2
15847: PPUSH
15848: CALL_OW 312
15852: IFFALSE 15863
// ComUnlink ( i ) ;
15854: LD_VAR 0 2
15858: PPUSH
15859: CALL_OW 136
15863: GO 15840
15865: POP
15866: POP
// end ;
15867: PPOPN 2
15869: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
15870: LD_EXP 43
15874: PUSH
15875: LD_EXP 74
15879: AND
15880: IFFALSE 16020
15882: GO 15884
15884: DISABLE
15885: LD_INT 0
15887: PPUSH
15888: PPUSH
// begin ToLua ( displayPowell(); ) ;
15889: LD_STRING displayPowell();
15891: PPUSH
15892: CALL_OW 559
// uc_side := 0 ;
15896: LD_ADDR_OWVAR 20
15900: PUSH
15901: LD_INT 0
15903: ST_TO_ADDR
// uc_nation := 2 ;
15904: LD_ADDR_OWVAR 21
15908: PUSH
15909: LD_INT 2
15911: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
15912: LD_ADDR_OWVAR 37
15916: PUSH
15917: LD_INT 14
15919: ST_TO_ADDR
// vc_engine := engine_siberite ;
15920: LD_ADDR_OWVAR 39
15924: PUSH
15925: LD_INT 3
15927: ST_TO_ADDR
// vc_control := control_apeman ;
15928: LD_ADDR_OWVAR 38
15932: PUSH
15933: LD_INT 5
15935: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
15936: LD_ADDR_OWVAR 40
15940: PUSH
15941: LD_INT 29
15943: ST_TO_ADDR
// un := CreateVehicle ;
15944: LD_ADDR_VAR 0 2
15948: PUSH
15949: CALL_OW 45
15953: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
15954: LD_VAR 0 2
15958: PPUSH
15959: LD_INT 1
15961: PPUSH
15962: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
15966: LD_INT 35
15968: PPUSH
15969: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
15973: LD_VAR 0 2
15977: PPUSH
15978: LD_INT 22
15980: PUSH
15981: LD_OWVAR 2
15985: PUSH
15986: EMPTY
15987: LIST
15988: LIST
15989: PPUSH
15990: CALL_OW 69
15994: PPUSH
15995: LD_VAR 0 2
15999: PPUSH
16000: CALL_OW 74
16004: PPUSH
16005: CALL_OW 115
// until IsDead ( un ) ;
16009: LD_VAR 0 2
16013: PPUSH
16014: CALL_OW 301
16018: IFFALSE 15966
// end ;
16020: PPOPN 2
16022: END
// every 0 0$1 trigger StreamModeActive and sStu do
16023: LD_EXP 43
16027: PUSH
16028: LD_EXP 82
16032: AND
16033: IFFALSE 16049
16035: GO 16037
16037: DISABLE
// begin ToLua ( displayStucuk(); ) ;
16038: LD_STRING displayStucuk();
16040: PPUSH
16041: CALL_OW 559
// ResetFog ;
16045: CALL_OW 335
// end ;
16049: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
16050: LD_EXP 43
16054: PUSH
16055: LD_EXP 75
16059: AND
16060: IFFALSE 16201
16062: GO 16064
16064: DISABLE
16065: LD_INT 0
16067: PPUSH
16068: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
16069: LD_ADDR_VAR 0 2
16073: PUSH
16074: LD_INT 22
16076: PUSH
16077: LD_OWVAR 2
16081: PUSH
16082: EMPTY
16083: LIST
16084: LIST
16085: PUSH
16086: LD_INT 21
16088: PUSH
16089: LD_INT 1
16091: PUSH
16092: EMPTY
16093: LIST
16094: LIST
16095: PUSH
16096: EMPTY
16097: LIST
16098: LIST
16099: PPUSH
16100: CALL_OW 69
16104: ST_TO_ADDR
// if not tmp then
16105: LD_VAR 0 2
16109: NOT
16110: IFFALSE 16114
// exit ;
16112: GO 16201
// un := tmp [ rand ( 1 , tmp ) ] ;
16114: LD_ADDR_VAR 0 1
16118: PUSH
16119: LD_VAR 0 2
16123: PUSH
16124: LD_INT 1
16126: PPUSH
16127: LD_VAR 0 2
16131: PPUSH
16132: CALL_OW 12
16136: ARRAY
16137: ST_TO_ADDR
// SetSide ( un , 0 ) ;
16138: LD_VAR 0 1
16142: PPUSH
16143: LD_INT 0
16145: PPUSH
16146: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
16150: LD_VAR 0 1
16154: PPUSH
16155: LD_OWVAR 3
16159: PUSH
16160: LD_VAR 0 1
16164: DIFF
16165: PPUSH
16166: LD_VAR 0 1
16170: PPUSH
16171: CALL_OW 74
16175: PPUSH
16176: CALL_OW 115
// wait ( 0 0$20 ) ;
16180: LD_INT 700
16182: PPUSH
16183: CALL_OW 67
// SetSide ( un , your_side ) ;
16187: LD_VAR 0 1
16191: PPUSH
16192: LD_OWVAR 2
16196: PPUSH
16197: CALL_OW 235
// end ;
16201: PPOPN 2
16203: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
16204: LD_EXP 43
16208: PUSH
16209: LD_EXP 76
16213: AND
16214: IFFALSE 16320
16216: GO 16218
16218: DISABLE
16219: LD_INT 0
16221: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
16222: LD_ADDR_VAR 0 1
16226: PUSH
16227: LD_INT 22
16229: PUSH
16230: LD_OWVAR 2
16234: PUSH
16235: EMPTY
16236: LIST
16237: LIST
16238: PUSH
16239: LD_INT 2
16241: PUSH
16242: LD_INT 30
16244: PUSH
16245: LD_INT 0
16247: PUSH
16248: EMPTY
16249: LIST
16250: LIST
16251: PUSH
16252: LD_INT 30
16254: PUSH
16255: LD_INT 1
16257: PUSH
16258: EMPTY
16259: LIST
16260: LIST
16261: PUSH
16262: EMPTY
16263: LIST
16264: LIST
16265: LIST
16266: PUSH
16267: EMPTY
16268: LIST
16269: LIST
16270: PPUSH
16271: CALL_OW 69
16275: ST_TO_ADDR
// if not depot then
16276: LD_VAR 0 1
16280: NOT
16281: IFFALSE 16285
// exit ;
16283: GO 16320
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
16285: LD_VAR 0 1
16289: PUSH
16290: LD_INT 1
16292: ARRAY
16293: PPUSH
16294: CALL_OW 250
16298: PPUSH
16299: LD_VAR 0 1
16303: PUSH
16304: LD_INT 1
16306: ARRAY
16307: PPUSH
16308: CALL_OW 251
16312: PPUSH
16313: LD_INT 70
16315: PPUSH
16316: CALL_OW 495
// end ;
16320: PPOPN 1
16322: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
16323: LD_EXP 43
16327: PUSH
16328: LD_EXP 77
16332: AND
16333: IFFALSE 16544
16335: GO 16337
16337: DISABLE
16338: LD_INT 0
16340: PPUSH
16341: PPUSH
16342: PPUSH
16343: PPUSH
16344: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
16345: LD_ADDR_VAR 0 5
16349: PUSH
16350: LD_INT 22
16352: PUSH
16353: LD_OWVAR 2
16357: PUSH
16358: EMPTY
16359: LIST
16360: LIST
16361: PUSH
16362: LD_INT 21
16364: PUSH
16365: LD_INT 1
16367: PUSH
16368: EMPTY
16369: LIST
16370: LIST
16371: PUSH
16372: EMPTY
16373: LIST
16374: LIST
16375: PPUSH
16376: CALL_OW 69
16380: ST_TO_ADDR
// if not tmp then
16381: LD_VAR 0 5
16385: NOT
16386: IFFALSE 16390
// exit ;
16388: GO 16544
// for i in tmp do
16390: LD_ADDR_VAR 0 1
16394: PUSH
16395: LD_VAR 0 5
16399: PUSH
16400: FOR_IN
16401: IFFALSE 16542
// begin d := rand ( 0 , 5 ) ;
16403: LD_ADDR_VAR 0 4
16407: PUSH
16408: LD_INT 0
16410: PPUSH
16411: LD_INT 5
16413: PPUSH
16414: CALL_OW 12
16418: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
16419: LD_ADDR_VAR 0 2
16423: PUSH
16424: LD_VAR 0 1
16428: PPUSH
16429: CALL_OW 250
16433: PPUSH
16434: LD_VAR 0 4
16438: PPUSH
16439: LD_INT 3
16441: PPUSH
16442: LD_INT 12
16444: PPUSH
16445: CALL_OW 12
16449: PPUSH
16450: CALL_OW 272
16454: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
16455: LD_ADDR_VAR 0 3
16459: PUSH
16460: LD_VAR 0 1
16464: PPUSH
16465: CALL_OW 251
16469: PPUSH
16470: LD_VAR 0 4
16474: PPUSH
16475: LD_INT 3
16477: PPUSH
16478: LD_INT 12
16480: PPUSH
16481: CALL_OW 12
16485: PPUSH
16486: CALL_OW 273
16490: ST_TO_ADDR
// if ValidHex ( x , y ) then
16491: LD_VAR 0 2
16495: PPUSH
16496: LD_VAR 0 3
16500: PPUSH
16501: CALL_OW 488
16505: IFFALSE 16540
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
16507: LD_VAR 0 1
16511: PPUSH
16512: LD_VAR 0 2
16516: PPUSH
16517: LD_VAR 0 3
16521: PPUSH
16522: LD_INT 3
16524: PPUSH
16525: LD_INT 6
16527: PPUSH
16528: CALL_OW 12
16532: PPUSH
16533: LD_INT 1
16535: PPUSH
16536: CALL_OW 483
// end ;
16540: GO 16400
16542: POP
16543: POP
// end ;
16544: PPOPN 5
16546: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
16547: LD_EXP 43
16551: PUSH
16552: LD_EXP 78
16556: AND
16557: IFFALSE 16651
16559: GO 16561
16561: DISABLE
16562: LD_INT 0
16564: PPUSH
16565: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
16566: LD_ADDR_VAR 0 2
16570: PUSH
16571: LD_INT 22
16573: PUSH
16574: LD_OWVAR 2
16578: PUSH
16579: EMPTY
16580: LIST
16581: LIST
16582: PUSH
16583: LD_INT 32
16585: PUSH
16586: LD_INT 1
16588: PUSH
16589: EMPTY
16590: LIST
16591: LIST
16592: PUSH
16593: LD_INT 21
16595: PUSH
16596: LD_INT 2
16598: PUSH
16599: EMPTY
16600: LIST
16601: LIST
16602: PUSH
16603: EMPTY
16604: LIST
16605: LIST
16606: LIST
16607: PPUSH
16608: CALL_OW 69
16612: ST_TO_ADDR
// if not tmp then
16613: LD_VAR 0 2
16617: NOT
16618: IFFALSE 16622
// exit ;
16620: GO 16651
// for i in tmp do
16622: LD_ADDR_VAR 0 1
16626: PUSH
16627: LD_VAR 0 2
16631: PUSH
16632: FOR_IN
16633: IFFALSE 16649
// SetFuel ( i , 0 ) ;
16635: LD_VAR 0 1
16639: PPUSH
16640: LD_INT 0
16642: PPUSH
16643: CALL_OW 240
16647: GO 16632
16649: POP
16650: POP
// end ;
16651: PPOPN 2
16653: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
16654: LD_EXP 43
16658: PUSH
16659: LD_EXP 79
16663: AND
16664: IFFALSE 16730
16666: GO 16668
16668: DISABLE
16669: LD_INT 0
16671: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
16672: LD_ADDR_VAR 0 1
16676: PUSH
16677: LD_INT 22
16679: PUSH
16680: LD_OWVAR 2
16684: PUSH
16685: EMPTY
16686: LIST
16687: LIST
16688: PUSH
16689: LD_INT 30
16691: PUSH
16692: LD_INT 29
16694: PUSH
16695: EMPTY
16696: LIST
16697: LIST
16698: PUSH
16699: EMPTY
16700: LIST
16701: LIST
16702: PPUSH
16703: CALL_OW 69
16707: ST_TO_ADDR
// if not tmp then
16708: LD_VAR 0 1
16712: NOT
16713: IFFALSE 16717
// exit ;
16715: GO 16730
// DestroyUnit ( tmp [ 1 ] ) ;
16717: LD_VAR 0 1
16721: PUSH
16722: LD_INT 1
16724: ARRAY
16725: PPUSH
16726: CALL_OW 65
// end ;
16730: PPOPN 1
16732: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
16733: LD_EXP 43
16737: PUSH
16738: LD_EXP 81
16742: AND
16743: IFFALSE 16872
16745: GO 16747
16747: DISABLE
16748: LD_INT 0
16750: PPUSH
// begin uc_side := 0 ;
16751: LD_ADDR_OWVAR 20
16755: PUSH
16756: LD_INT 0
16758: ST_TO_ADDR
// uc_nation := nation_arabian ;
16759: LD_ADDR_OWVAR 21
16763: PUSH
16764: LD_INT 2
16766: ST_TO_ADDR
// hc_gallery :=  ;
16767: LD_ADDR_OWVAR 33
16771: PUSH
16772: LD_STRING 
16774: ST_TO_ADDR
// hc_name :=  ;
16775: LD_ADDR_OWVAR 26
16779: PUSH
16780: LD_STRING 
16782: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
16783: LD_INT 1
16785: PPUSH
16786: LD_INT 11
16788: PPUSH
16789: LD_INT 10
16791: PPUSH
16792: CALL_OW 380
// un := CreateHuman ;
16796: LD_ADDR_VAR 0 1
16800: PUSH
16801: CALL_OW 44
16805: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
16806: LD_VAR 0 1
16810: PPUSH
16811: LD_INT 1
16813: PPUSH
16814: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
16818: LD_INT 35
16820: PPUSH
16821: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
16825: LD_VAR 0 1
16829: PPUSH
16830: LD_INT 22
16832: PUSH
16833: LD_OWVAR 2
16837: PUSH
16838: EMPTY
16839: LIST
16840: LIST
16841: PPUSH
16842: CALL_OW 69
16846: PPUSH
16847: LD_VAR 0 1
16851: PPUSH
16852: CALL_OW 74
16856: PPUSH
16857: CALL_OW 115
// until IsDead ( un ) ;
16861: LD_VAR 0 1
16865: PPUSH
16866: CALL_OW 301
16870: IFFALSE 16818
// end ;
16872: PPOPN 1
16874: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
16875: LD_EXP 43
16879: PUSH
16880: LD_EXP 83
16884: AND
16885: IFFALSE 16897
16887: GO 16889
16889: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
16890: LD_STRING earthquake(getX(game), 0, 32)
16892: PPUSH
16893: CALL_OW 559
16897: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
16898: LD_EXP 43
16902: PUSH
16903: LD_EXP 84
16907: AND
16908: IFFALSE 16999
16910: GO 16912
16912: DISABLE
16913: LD_INT 0
16915: PPUSH
// begin enable ;
16916: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
16917: LD_ADDR_VAR 0 1
16921: PUSH
16922: LD_INT 22
16924: PUSH
16925: LD_OWVAR 2
16929: PUSH
16930: EMPTY
16931: LIST
16932: LIST
16933: PUSH
16934: LD_INT 21
16936: PUSH
16937: LD_INT 2
16939: PUSH
16940: EMPTY
16941: LIST
16942: LIST
16943: PUSH
16944: LD_INT 33
16946: PUSH
16947: LD_INT 3
16949: PUSH
16950: EMPTY
16951: LIST
16952: LIST
16953: PUSH
16954: EMPTY
16955: LIST
16956: LIST
16957: LIST
16958: PPUSH
16959: CALL_OW 69
16963: ST_TO_ADDR
// if not tmp then
16964: LD_VAR 0 1
16968: NOT
16969: IFFALSE 16973
// exit ;
16971: GO 16999
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
16973: LD_VAR 0 1
16977: PUSH
16978: LD_INT 1
16980: PPUSH
16981: LD_VAR 0 1
16985: PPUSH
16986: CALL_OW 12
16990: ARRAY
16991: PPUSH
16992: LD_INT 1
16994: PPUSH
16995: CALL_OW 234
// end ;
16999: PPOPN 1
17001: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
17002: LD_EXP 43
17006: PUSH
17007: LD_EXP 85
17011: AND
17012: IFFALSE 17153
17014: GO 17016
17016: DISABLE
17017: LD_INT 0
17019: PPUSH
17020: PPUSH
17021: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
17022: LD_ADDR_VAR 0 3
17026: PUSH
17027: LD_INT 22
17029: PUSH
17030: LD_OWVAR 2
17034: PUSH
17035: EMPTY
17036: LIST
17037: LIST
17038: PUSH
17039: LD_INT 25
17041: PUSH
17042: LD_INT 1
17044: PUSH
17045: EMPTY
17046: LIST
17047: LIST
17048: PUSH
17049: EMPTY
17050: LIST
17051: LIST
17052: PPUSH
17053: CALL_OW 69
17057: ST_TO_ADDR
// if not tmp then
17058: LD_VAR 0 3
17062: NOT
17063: IFFALSE 17067
// exit ;
17065: GO 17153
// un := tmp [ rand ( 1 , tmp ) ] ;
17067: LD_ADDR_VAR 0 2
17071: PUSH
17072: LD_VAR 0 3
17076: PUSH
17077: LD_INT 1
17079: PPUSH
17080: LD_VAR 0 3
17084: PPUSH
17085: CALL_OW 12
17089: ARRAY
17090: ST_TO_ADDR
// if Crawls ( un ) then
17091: LD_VAR 0 2
17095: PPUSH
17096: CALL_OW 318
17100: IFFALSE 17111
// ComWalk ( un ) ;
17102: LD_VAR 0 2
17106: PPUSH
17107: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
17111: LD_VAR 0 2
17115: PPUSH
17116: LD_INT 9
17118: PPUSH
17119: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
17123: LD_INT 28
17125: PPUSH
17126: LD_OWVAR 2
17130: PPUSH
17131: LD_INT 2
17133: PPUSH
17134: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
17138: LD_INT 29
17140: PPUSH
17141: LD_OWVAR 2
17145: PPUSH
17146: LD_INT 2
17148: PPUSH
17149: CALL_OW 322
// end ;
17153: PPOPN 3
17155: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
17156: LD_EXP 43
17160: PUSH
17161: LD_EXP 86
17165: AND
17166: IFFALSE 17277
17168: GO 17170
17170: DISABLE
17171: LD_INT 0
17173: PPUSH
17174: PPUSH
17175: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
17176: LD_ADDR_VAR 0 3
17180: PUSH
17181: LD_INT 22
17183: PUSH
17184: LD_OWVAR 2
17188: PUSH
17189: EMPTY
17190: LIST
17191: LIST
17192: PUSH
17193: LD_INT 25
17195: PUSH
17196: LD_INT 1
17198: PUSH
17199: EMPTY
17200: LIST
17201: LIST
17202: PUSH
17203: EMPTY
17204: LIST
17205: LIST
17206: PPUSH
17207: CALL_OW 69
17211: ST_TO_ADDR
// if not tmp then
17212: LD_VAR 0 3
17216: NOT
17217: IFFALSE 17221
// exit ;
17219: GO 17277
// un := tmp [ rand ( 1 , tmp ) ] ;
17221: LD_ADDR_VAR 0 2
17225: PUSH
17226: LD_VAR 0 3
17230: PUSH
17231: LD_INT 1
17233: PPUSH
17234: LD_VAR 0 3
17238: PPUSH
17239: CALL_OW 12
17243: ARRAY
17244: ST_TO_ADDR
// if Crawls ( un ) then
17245: LD_VAR 0 2
17249: PPUSH
17250: CALL_OW 318
17254: IFFALSE 17265
// ComWalk ( un ) ;
17256: LD_VAR 0 2
17260: PPUSH
17261: CALL_OW 138
// SetClass ( un , class_mortar ) ;
17265: LD_VAR 0 2
17269: PPUSH
17270: LD_INT 8
17272: PPUSH
17273: CALL_OW 336
// end ;
17277: PPOPN 3
17279: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
17280: LD_EXP 43
17284: PUSH
17285: LD_EXP 87
17289: AND
17290: IFFALSE 17434
17292: GO 17294
17294: DISABLE
17295: LD_INT 0
17297: PPUSH
17298: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
17299: LD_ADDR_VAR 0 2
17303: PUSH
17304: LD_INT 22
17306: PUSH
17307: LD_OWVAR 2
17311: PUSH
17312: EMPTY
17313: LIST
17314: LIST
17315: PUSH
17316: LD_INT 21
17318: PUSH
17319: LD_INT 2
17321: PUSH
17322: EMPTY
17323: LIST
17324: LIST
17325: PUSH
17326: LD_INT 2
17328: PUSH
17329: LD_INT 34
17331: PUSH
17332: LD_INT 12
17334: PUSH
17335: EMPTY
17336: LIST
17337: LIST
17338: PUSH
17339: LD_INT 34
17341: PUSH
17342: LD_INT 51
17344: PUSH
17345: EMPTY
17346: LIST
17347: LIST
17348: PUSH
17349: LD_INT 34
17351: PUSH
17352: LD_INT 32
17354: PUSH
17355: EMPTY
17356: LIST
17357: LIST
17358: PUSH
17359: EMPTY
17360: LIST
17361: LIST
17362: LIST
17363: LIST
17364: PUSH
17365: EMPTY
17366: LIST
17367: LIST
17368: LIST
17369: PPUSH
17370: CALL_OW 69
17374: ST_TO_ADDR
// if not tmp then
17375: LD_VAR 0 2
17379: NOT
17380: IFFALSE 17384
// exit ;
17382: GO 17434
// for i in tmp do
17384: LD_ADDR_VAR 0 1
17388: PUSH
17389: LD_VAR 0 2
17393: PUSH
17394: FOR_IN
17395: IFFALSE 17432
// if GetCargo ( i , mat_artifact ) = 0 then
17397: LD_VAR 0 1
17401: PPUSH
17402: LD_INT 4
17404: PPUSH
17405: CALL_OW 289
17409: PUSH
17410: LD_INT 0
17412: EQUAL
17413: IFFALSE 17430
// SetCargo ( i , mat_siberit , 100 ) ;
17415: LD_VAR 0 1
17419: PPUSH
17420: LD_INT 3
17422: PPUSH
17423: LD_INT 100
17425: PPUSH
17426: CALL_OW 290
17430: GO 17394
17432: POP
17433: POP
// end ;
17434: PPOPN 2
17436: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
17437: LD_EXP 43
17441: PUSH
17442: LD_EXP 88
17446: AND
17447: IFFALSE 17630
17449: GO 17451
17451: DISABLE
17452: LD_INT 0
17454: PPUSH
17455: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
17456: LD_ADDR_VAR 0 2
17460: PUSH
17461: LD_INT 22
17463: PUSH
17464: LD_OWVAR 2
17468: PUSH
17469: EMPTY
17470: LIST
17471: LIST
17472: PPUSH
17473: CALL_OW 69
17477: ST_TO_ADDR
// if not tmp then
17478: LD_VAR 0 2
17482: NOT
17483: IFFALSE 17487
// exit ;
17485: GO 17630
// for i := 1 to 2 do
17487: LD_ADDR_VAR 0 1
17491: PUSH
17492: DOUBLE
17493: LD_INT 1
17495: DEC
17496: ST_TO_ADDR
17497: LD_INT 2
17499: PUSH
17500: FOR_TO
17501: IFFALSE 17628
// begin uc_side := your_side ;
17503: LD_ADDR_OWVAR 20
17507: PUSH
17508: LD_OWVAR 2
17512: ST_TO_ADDR
// uc_nation := nation_american ;
17513: LD_ADDR_OWVAR 21
17517: PUSH
17518: LD_INT 1
17520: ST_TO_ADDR
// vc_chassis := us_morphling ;
17521: LD_ADDR_OWVAR 37
17525: PUSH
17526: LD_INT 5
17528: ST_TO_ADDR
// vc_engine := engine_siberite ;
17529: LD_ADDR_OWVAR 39
17533: PUSH
17534: LD_INT 3
17536: ST_TO_ADDR
// vc_control := control_computer ;
17537: LD_ADDR_OWVAR 38
17541: PUSH
17542: LD_INT 3
17544: ST_TO_ADDR
// vc_weapon := us_double_laser ;
17545: LD_ADDR_OWVAR 40
17549: PUSH
17550: LD_INT 10
17552: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
17553: LD_VAR 0 2
17557: PUSH
17558: LD_INT 1
17560: ARRAY
17561: PPUSH
17562: CALL_OW 310
17566: NOT
17567: IFFALSE 17614
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
17569: CALL_OW 45
17573: PPUSH
17574: LD_VAR 0 2
17578: PUSH
17579: LD_INT 1
17581: ARRAY
17582: PPUSH
17583: CALL_OW 250
17587: PPUSH
17588: LD_VAR 0 2
17592: PUSH
17593: LD_INT 1
17595: ARRAY
17596: PPUSH
17597: CALL_OW 251
17601: PPUSH
17602: LD_INT 12
17604: PPUSH
17605: LD_INT 1
17607: PPUSH
17608: CALL_OW 50
17612: GO 17626
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
17614: CALL_OW 45
17618: PPUSH
17619: LD_INT 1
17621: PPUSH
17622: CALL_OW 51
// end ;
17626: GO 17500
17628: POP
17629: POP
// end ;
17630: PPOPN 2
17632: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
17633: LD_EXP 43
17637: PUSH
17638: LD_EXP 89
17642: AND
17643: IFFALSE 17865
17645: GO 17647
17647: DISABLE
17648: LD_INT 0
17650: PPUSH
17651: PPUSH
17652: PPUSH
17653: PPUSH
17654: PPUSH
17655: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
17656: LD_ADDR_VAR 0 6
17660: PUSH
17661: LD_INT 22
17663: PUSH
17664: LD_OWVAR 2
17668: PUSH
17669: EMPTY
17670: LIST
17671: LIST
17672: PUSH
17673: LD_INT 21
17675: PUSH
17676: LD_INT 1
17678: PUSH
17679: EMPTY
17680: LIST
17681: LIST
17682: PUSH
17683: LD_INT 3
17685: PUSH
17686: LD_INT 23
17688: PUSH
17689: LD_INT 0
17691: PUSH
17692: EMPTY
17693: LIST
17694: LIST
17695: PUSH
17696: EMPTY
17697: LIST
17698: LIST
17699: PUSH
17700: EMPTY
17701: LIST
17702: LIST
17703: LIST
17704: PPUSH
17705: CALL_OW 69
17709: ST_TO_ADDR
// if not tmp then
17710: LD_VAR 0 6
17714: NOT
17715: IFFALSE 17719
// exit ;
17717: GO 17865
// s1 := rand ( 1 , 4 ) ;
17719: LD_ADDR_VAR 0 2
17723: PUSH
17724: LD_INT 1
17726: PPUSH
17727: LD_INT 4
17729: PPUSH
17730: CALL_OW 12
17734: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
17735: LD_ADDR_VAR 0 4
17739: PUSH
17740: LD_VAR 0 6
17744: PUSH
17745: LD_INT 1
17747: ARRAY
17748: PPUSH
17749: LD_VAR 0 2
17753: PPUSH
17754: CALL_OW 259
17758: ST_TO_ADDR
// if s1 = 1 then
17759: LD_VAR 0 2
17763: PUSH
17764: LD_INT 1
17766: EQUAL
17767: IFFALSE 17787
// s2 := rand ( 2 , 4 ) else
17769: LD_ADDR_VAR 0 3
17773: PUSH
17774: LD_INT 2
17776: PPUSH
17777: LD_INT 4
17779: PPUSH
17780: CALL_OW 12
17784: ST_TO_ADDR
17785: GO 17795
// s2 := 1 ;
17787: LD_ADDR_VAR 0 3
17791: PUSH
17792: LD_INT 1
17794: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
17795: LD_ADDR_VAR 0 5
17799: PUSH
17800: LD_VAR 0 6
17804: PUSH
17805: LD_INT 1
17807: ARRAY
17808: PPUSH
17809: LD_VAR 0 3
17813: PPUSH
17814: CALL_OW 259
17818: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
17819: LD_VAR 0 6
17823: PUSH
17824: LD_INT 1
17826: ARRAY
17827: PPUSH
17828: LD_VAR 0 2
17832: PPUSH
17833: LD_VAR 0 5
17837: PPUSH
17838: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
17842: LD_VAR 0 6
17846: PUSH
17847: LD_INT 1
17849: ARRAY
17850: PPUSH
17851: LD_VAR 0 3
17855: PPUSH
17856: LD_VAR 0 4
17860: PPUSH
17861: CALL_OW 237
// end ;
17865: PPOPN 6
17867: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
17868: LD_EXP 43
17872: PUSH
17873: LD_EXP 90
17877: AND
17878: IFFALSE 17957
17880: GO 17882
17882: DISABLE
17883: LD_INT 0
17885: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
17886: LD_ADDR_VAR 0 1
17890: PUSH
17891: LD_INT 22
17893: PUSH
17894: LD_OWVAR 2
17898: PUSH
17899: EMPTY
17900: LIST
17901: LIST
17902: PUSH
17903: LD_INT 30
17905: PUSH
17906: LD_INT 3
17908: PUSH
17909: EMPTY
17910: LIST
17911: LIST
17912: PUSH
17913: EMPTY
17914: LIST
17915: LIST
17916: PPUSH
17917: CALL_OW 69
17921: ST_TO_ADDR
// if not tmp then
17922: LD_VAR 0 1
17926: NOT
17927: IFFALSE 17931
// exit ;
17929: GO 17957
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
17931: LD_VAR 0 1
17935: PUSH
17936: LD_INT 1
17938: PPUSH
17939: LD_VAR 0 1
17943: PPUSH
17944: CALL_OW 12
17948: ARRAY
17949: PPUSH
17950: LD_INT 1
17952: PPUSH
17953: CALL_OW 234
// end ;
17957: PPOPN 1
17959: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
17960: LD_EXP 43
17964: PUSH
17965: LD_EXP 91
17969: AND
17970: IFFALSE 18082
17972: GO 17974
17974: DISABLE
17975: LD_INT 0
17977: PPUSH
17978: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
17979: LD_ADDR_VAR 0 2
17983: PUSH
17984: LD_INT 22
17986: PUSH
17987: LD_OWVAR 2
17991: PUSH
17992: EMPTY
17993: LIST
17994: LIST
17995: PUSH
17996: LD_INT 2
17998: PUSH
17999: LD_INT 30
18001: PUSH
18002: LD_INT 27
18004: PUSH
18005: EMPTY
18006: LIST
18007: LIST
18008: PUSH
18009: LD_INT 30
18011: PUSH
18012: LD_INT 26
18014: PUSH
18015: EMPTY
18016: LIST
18017: LIST
18018: PUSH
18019: LD_INT 30
18021: PUSH
18022: LD_INT 28
18024: PUSH
18025: EMPTY
18026: LIST
18027: LIST
18028: PUSH
18029: EMPTY
18030: LIST
18031: LIST
18032: LIST
18033: LIST
18034: PUSH
18035: EMPTY
18036: LIST
18037: LIST
18038: PPUSH
18039: CALL_OW 69
18043: ST_TO_ADDR
// if not tmp then
18044: LD_VAR 0 2
18048: NOT
18049: IFFALSE 18053
// exit ;
18051: GO 18082
// for i in tmp do
18053: LD_ADDR_VAR 0 1
18057: PUSH
18058: LD_VAR 0 2
18062: PUSH
18063: FOR_IN
18064: IFFALSE 18080
// SetLives ( i , 1 ) ;
18066: LD_VAR 0 1
18070: PPUSH
18071: LD_INT 1
18073: PPUSH
18074: CALL_OW 234
18078: GO 18063
18080: POP
18081: POP
// end ;
18082: PPOPN 2
18084: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
18085: LD_EXP 43
18089: PUSH
18090: LD_EXP 92
18094: AND
18095: IFFALSE 18369
18097: GO 18099
18099: DISABLE
18100: LD_INT 0
18102: PPUSH
18103: PPUSH
18104: PPUSH
// begin i := rand ( 1 , 7 ) ;
18105: LD_ADDR_VAR 0 1
18109: PUSH
18110: LD_INT 1
18112: PPUSH
18113: LD_INT 7
18115: PPUSH
18116: CALL_OW 12
18120: ST_TO_ADDR
// case i of 1 :
18121: LD_VAR 0 1
18125: PUSH
18126: LD_INT 1
18128: DOUBLE
18129: EQUAL
18130: IFTRUE 18134
18132: GO 18144
18134: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
18135: LD_STRING earthquake(getX(game), 0, 32)
18137: PPUSH
18138: CALL_OW 559
18142: GO 18369
18144: LD_INT 2
18146: DOUBLE
18147: EQUAL
18148: IFTRUE 18152
18150: GO 18166
18152: POP
// begin ToLua ( displayStucuk(); ) ;
18153: LD_STRING displayStucuk();
18155: PPUSH
18156: CALL_OW 559
// ResetFog ;
18160: CALL_OW 335
// end ; 3 :
18164: GO 18369
18166: LD_INT 3
18168: DOUBLE
18169: EQUAL
18170: IFTRUE 18174
18172: GO 18278
18174: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
18175: LD_ADDR_VAR 0 2
18179: PUSH
18180: LD_INT 22
18182: PUSH
18183: LD_OWVAR 2
18187: PUSH
18188: EMPTY
18189: LIST
18190: LIST
18191: PUSH
18192: LD_INT 25
18194: PUSH
18195: LD_INT 1
18197: PUSH
18198: EMPTY
18199: LIST
18200: LIST
18201: PUSH
18202: EMPTY
18203: LIST
18204: LIST
18205: PPUSH
18206: CALL_OW 69
18210: ST_TO_ADDR
// if not tmp then
18211: LD_VAR 0 2
18215: NOT
18216: IFFALSE 18220
// exit ;
18218: GO 18369
// un := tmp [ rand ( 1 , tmp ) ] ;
18220: LD_ADDR_VAR 0 3
18224: PUSH
18225: LD_VAR 0 2
18229: PUSH
18230: LD_INT 1
18232: PPUSH
18233: LD_VAR 0 2
18237: PPUSH
18238: CALL_OW 12
18242: ARRAY
18243: ST_TO_ADDR
// if Crawls ( un ) then
18244: LD_VAR 0 3
18248: PPUSH
18249: CALL_OW 318
18253: IFFALSE 18264
// ComWalk ( un ) ;
18255: LD_VAR 0 3
18259: PPUSH
18260: CALL_OW 138
// SetClass ( un , class_mortar ) ;
18264: LD_VAR 0 3
18268: PPUSH
18269: LD_INT 8
18271: PPUSH
18272: CALL_OW 336
// end ; 4 :
18276: GO 18369
18278: LD_INT 4
18280: DOUBLE
18281: EQUAL
18282: IFTRUE 18286
18284: GO 18347
18286: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
18287: LD_ADDR_VAR 0 2
18291: PUSH
18292: LD_INT 22
18294: PUSH
18295: LD_OWVAR 2
18299: PUSH
18300: EMPTY
18301: LIST
18302: LIST
18303: PUSH
18304: LD_INT 30
18306: PUSH
18307: LD_INT 29
18309: PUSH
18310: EMPTY
18311: LIST
18312: LIST
18313: PUSH
18314: EMPTY
18315: LIST
18316: LIST
18317: PPUSH
18318: CALL_OW 69
18322: ST_TO_ADDR
// if not tmp then
18323: LD_VAR 0 2
18327: NOT
18328: IFFALSE 18332
// exit ;
18330: GO 18369
// DestroyUnit ( tmp [ 1 ] ) ;
18332: LD_VAR 0 2
18336: PUSH
18337: LD_INT 1
18339: ARRAY
18340: PPUSH
18341: CALL_OW 65
// end ; 5 .. 7 :
18345: GO 18369
18347: LD_INT 5
18349: DOUBLE
18350: GREATEREQUAL
18351: IFFALSE 18359
18353: LD_INT 7
18355: DOUBLE
18356: LESSEQUAL
18357: IFTRUE 18361
18359: GO 18368
18361: POP
// StreamSibBomb ; end ;
18362: CALL 14619 0 0
18366: GO 18369
18368: POP
// end ;
18369: PPOPN 3
18371: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
18372: LD_EXP 43
18376: PUSH
18377: LD_EXP 93
18381: AND
18382: IFFALSE 18538
18384: GO 18386
18386: DISABLE
18387: LD_INT 0
18389: PPUSH
18390: PPUSH
18391: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
18392: LD_ADDR_VAR 0 2
18396: PUSH
18397: LD_INT 81
18399: PUSH
18400: LD_OWVAR 2
18404: PUSH
18405: EMPTY
18406: LIST
18407: LIST
18408: PUSH
18409: LD_INT 2
18411: PUSH
18412: LD_INT 21
18414: PUSH
18415: LD_INT 1
18417: PUSH
18418: EMPTY
18419: LIST
18420: LIST
18421: PUSH
18422: LD_INT 21
18424: PUSH
18425: LD_INT 2
18427: PUSH
18428: EMPTY
18429: LIST
18430: LIST
18431: PUSH
18432: EMPTY
18433: LIST
18434: LIST
18435: LIST
18436: PUSH
18437: EMPTY
18438: LIST
18439: LIST
18440: PPUSH
18441: CALL_OW 69
18445: ST_TO_ADDR
// if not tmp then
18446: LD_VAR 0 2
18450: NOT
18451: IFFALSE 18455
// exit ;
18453: GO 18538
// p := 0 ;
18455: LD_ADDR_VAR 0 3
18459: PUSH
18460: LD_INT 0
18462: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18463: LD_INT 35
18465: PPUSH
18466: CALL_OW 67
// p := p + 1 ;
18470: LD_ADDR_VAR 0 3
18474: PUSH
18475: LD_VAR 0 3
18479: PUSH
18480: LD_INT 1
18482: PLUS
18483: ST_TO_ADDR
// for i in tmp do
18484: LD_ADDR_VAR 0 1
18488: PUSH
18489: LD_VAR 0 2
18493: PUSH
18494: FOR_IN
18495: IFFALSE 18526
// if GetLives ( i ) < 1000 then
18497: LD_VAR 0 1
18501: PPUSH
18502: CALL_OW 256
18506: PUSH
18507: LD_INT 1000
18509: LESS
18510: IFFALSE 18524
// SetLives ( i , 1000 ) ;
18512: LD_VAR 0 1
18516: PPUSH
18517: LD_INT 1000
18519: PPUSH
18520: CALL_OW 234
18524: GO 18494
18526: POP
18527: POP
// until p > 20 ;
18528: LD_VAR 0 3
18532: PUSH
18533: LD_INT 20
18535: GREATER
18536: IFFALSE 18463
// end ;
18538: PPOPN 3
18540: END
// every 0 0$1 trigger StreamModeActive and sTime do
18541: LD_EXP 43
18545: PUSH
18546: LD_EXP 94
18550: AND
18551: IFFALSE 18586
18553: GO 18555
18555: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
18556: LD_INT 28
18558: PPUSH
18559: LD_OWVAR 2
18563: PPUSH
18564: LD_INT 2
18566: PPUSH
18567: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
18571: LD_INT 30
18573: PPUSH
18574: LD_OWVAR 2
18578: PPUSH
18579: LD_INT 2
18581: PPUSH
18582: CALL_OW 322
// end ;
18586: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
18587: LD_EXP 43
18591: PUSH
18592: LD_EXP 95
18596: AND
18597: IFFALSE 18718
18599: GO 18601
18601: DISABLE
18602: LD_INT 0
18604: PPUSH
18605: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
18606: LD_ADDR_VAR 0 2
18610: PUSH
18611: LD_INT 22
18613: PUSH
18614: LD_OWVAR 2
18618: PUSH
18619: EMPTY
18620: LIST
18621: LIST
18622: PUSH
18623: LD_INT 21
18625: PUSH
18626: LD_INT 1
18628: PUSH
18629: EMPTY
18630: LIST
18631: LIST
18632: PUSH
18633: LD_INT 3
18635: PUSH
18636: LD_INT 23
18638: PUSH
18639: LD_INT 0
18641: PUSH
18642: EMPTY
18643: LIST
18644: LIST
18645: PUSH
18646: EMPTY
18647: LIST
18648: LIST
18649: PUSH
18650: EMPTY
18651: LIST
18652: LIST
18653: LIST
18654: PPUSH
18655: CALL_OW 69
18659: ST_TO_ADDR
// if not tmp then
18660: LD_VAR 0 2
18664: NOT
18665: IFFALSE 18669
// exit ;
18667: GO 18718
// for i in tmp do
18669: LD_ADDR_VAR 0 1
18673: PUSH
18674: LD_VAR 0 2
18678: PUSH
18679: FOR_IN
18680: IFFALSE 18716
// begin if Crawls ( i ) then
18682: LD_VAR 0 1
18686: PPUSH
18687: CALL_OW 318
18691: IFFALSE 18702
// ComWalk ( i ) ;
18693: LD_VAR 0 1
18697: PPUSH
18698: CALL_OW 138
// SetClass ( i , 2 ) ;
18702: LD_VAR 0 1
18706: PPUSH
18707: LD_INT 2
18709: PPUSH
18710: CALL_OW 336
// end ;
18714: GO 18679
18716: POP
18717: POP
// end ;
18718: PPOPN 2
18720: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
18721: LD_EXP 43
18725: PUSH
18726: LD_EXP 96
18730: AND
18731: IFFALSE 19012
18733: GO 18735
18735: DISABLE
18736: LD_INT 0
18738: PPUSH
18739: PPUSH
18740: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
18741: LD_OWVAR 2
18745: PPUSH
18746: LD_INT 9
18748: PPUSH
18749: LD_INT 1
18751: PPUSH
18752: LD_INT 1
18754: PPUSH
18755: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
18759: LD_INT 9
18761: PPUSH
18762: LD_OWVAR 2
18766: PPUSH
18767: CALL_OW 343
// uc_side := 9 ;
18771: LD_ADDR_OWVAR 20
18775: PUSH
18776: LD_INT 9
18778: ST_TO_ADDR
// uc_nation := 2 ;
18779: LD_ADDR_OWVAR 21
18783: PUSH
18784: LD_INT 2
18786: ST_TO_ADDR
// hc_name := Dark Warrior ;
18787: LD_ADDR_OWVAR 26
18791: PUSH
18792: LD_STRING Dark Warrior
18794: ST_TO_ADDR
// hc_gallery :=  ;
18795: LD_ADDR_OWVAR 33
18799: PUSH
18800: LD_STRING 
18802: ST_TO_ADDR
// hc_noskilllimit := true ;
18803: LD_ADDR_OWVAR 76
18807: PUSH
18808: LD_INT 1
18810: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
18811: LD_ADDR_OWVAR 31
18815: PUSH
18816: LD_INT 30
18818: PUSH
18819: LD_INT 30
18821: PUSH
18822: LD_INT 30
18824: PUSH
18825: LD_INT 30
18827: PUSH
18828: EMPTY
18829: LIST
18830: LIST
18831: LIST
18832: LIST
18833: ST_TO_ADDR
// un := CreateHuman ;
18834: LD_ADDR_VAR 0 3
18838: PUSH
18839: CALL_OW 44
18843: ST_TO_ADDR
// hc_noskilllimit := false ;
18844: LD_ADDR_OWVAR 76
18848: PUSH
18849: LD_INT 0
18851: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
18852: LD_VAR 0 3
18856: PPUSH
18857: LD_INT 1
18859: PPUSH
18860: CALL_OW 51
// p := 0 ;
18864: LD_ADDR_VAR 0 2
18868: PUSH
18869: LD_INT 0
18871: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18872: LD_INT 35
18874: PPUSH
18875: CALL_OW 67
// p := p + 1 ;
18879: LD_ADDR_VAR 0 2
18883: PUSH
18884: LD_VAR 0 2
18888: PUSH
18889: LD_INT 1
18891: PLUS
18892: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
18893: LD_VAR 0 3
18897: PPUSH
18898: CALL_OW 256
18902: PUSH
18903: LD_INT 1000
18905: LESS
18906: IFFALSE 18920
// SetLives ( un , 1000 ) ;
18908: LD_VAR 0 3
18912: PPUSH
18913: LD_INT 1000
18915: PPUSH
18916: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
18920: LD_VAR 0 3
18924: PPUSH
18925: LD_INT 81
18927: PUSH
18928: LD_OWVAR 2
18932: PUSH
18933: EMPTY
18934: LIST
18935: LIST
18936: PUSH
18937: LD_INT 91
18939: PUSH
18940: LD_VAR 0 3
18944: PUSH
18945: LD_INT 30
18947: PUSH
18948: EMPTY
18949: LIST
18950: LIST
18951: LIST
18952: PUSH
18953: EMPTY
18954: LIST
18955: LIST
18956: PPUSH
18957: CALL_OW 69
18961: PPUSH
18962: LD_VAR 0 3
18966: PPUSH
18967: CALL_OW 74
18971: PPUSH
18972: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
18976: LD_VAR 0 2
18980: PUSH
18981: LD_INT 60
18983: GREATER
18984: PUSH
18985: LD_VAR 0 3
18989: PPUSH
18990: CALL_OW 301
18994: OR
18995: IFFALSE 18872
// if un then
18997: LD_VAR 0 3
19001: IFFALSE 19012
// RemoveUnit ( un ) ;
19003: LD_VAR 0 3
19007: PPUSH
19008: CALL_OW 64
// end ; end_of_file
19012: PPOPN 3
19014: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
19015: LD_INT 0
19017: PPUSH
19018: PPUSH
19019: PPUSH
19020: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
19021: LD_VAR 0 1
19025: PPUSH
19026: CALL_OW 264
19030: PUSH
19031: LD_EXP 33
19035: EQUAL
19036: IFFALSE 19108
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
19038: LD_INT 68
19040: PPUSH
19041: LD_VAR 0 1
19045: PPUSH
19046: CALL_OW 255
19050: PPUSH
19051: CALL_OW 321
19055: PUSH
19056: LD_INT 2
19058: EQUAL
19059: IFFALSE 19071
// eff := 70 else
19061: LD_ADDR_VAR 0 4
19065: PUSH
19066: LD_INT 70
19068: ST_TO_ADDR
19069: GO 19079
// eff := 30 ;
19071: LD_ADDR_VAR 0 4
19075: PUSH
19076: LD_INT 30
19078: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
19079: LD_VAR 0 1
19083: PPUSH
19084: CALL_OW 250
19088: PPUSH
19089: LD_VAR 0 1
19093: PPUSH
19094: CALL_OW 251
19098: PPUSH
19099: LD_VAR 0 4
19103: PPUSH
19104: CALL_OW 495
// end ; end ;
19108: LD_VAR 0 2
19112: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
19113: LD_INT 0
19115: PPUSH
// end ;
19116: LD_VAR 0 4
19120: RET
// export function SOS_Command ( cmd ) ; begin
19121: LD_INT 0
19123: PPUSH
// end ;
19124: LD_VAR 0 2
19128: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
19129: LD_VAR 0 1
19133: PUSH
19134: LD_INT 255
19136: EQUAL
19137: PUSH
19138: LD_VAR 0 2
19142: PPUSH
19143: CALL_OW 264
19147: PUSH
19148: LD_INT 14
19150: PUSH
19151: LD_INT 53
19153: PUSH
19154: EMPTY
19155: LIST
19156: LIST
19157: IN
19158: AND
19159: PUSH
19160: LD_VAR 0 4
19164: PPUSH
19165: LD_VAR 0 5
19169: PPUSH
19170: CALL_OW 488
19174: AND
19175: IFFALSE 19199
// CutTreeXYR ( unit , x , y , 12 ) ;
19177: LD_VAR 0 2
19181: PPUSH
19182: LD_VAR 0 4
19186: PPUSH
19187: LD_VAR 0 5
19191: PPUSH
19192: LD_INT 12
19194: PPUSH
19195: CALL 19202 0 4
// end ;
19199: PPOPN 5
19201: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
19202: LD_INT 0
19204: PPUSH
19205: PPUSH
19206: PPUSH
19207: PPUSH
19208: PPUSH
19209: PPUSH
19210: PPUSH
19211: PPUSH
19212: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
19213: LD_VAR 0 1
19217: NOT
19218: PUSH
19219: LD_VAR 0 2
19223: PPUSH
19224: LD_VAR 0 3
19228: PPUSH
19229: CALL_OW 488
19233: NOT
19234: OR
19235: PUSH
19236: LD_VAR 0 4
19240: NOT
19241: OR
19242: IFFALSE 19246
// exit ;
19244: GO 19586
// list := [ ] ;
19246: LD_ADDR_VAR 0 13
19250: PUSH
19251: EMPTY
19252: ST_TO_ADDR
// if x - r < 0 then
19253: LD_VAR 0 2
19257: PUSH
19258: LD_VAR 0 4
19262: MINUS
19263: PUSH
19264: LD_INT 0
19266: LESS
19267: IFFALSE 19279
// min_x := 0 else
19269: LD_ADDR_VAR 0 7
19273: PUSH
19274: LD_INT 0
19276: ST_TO_ADDR
19277: GO 19295
// min_x := x - r ;
19279: LD_ADDR_VAR 0 7
19283: PUSH
19284: LD_VAR 0 2
19288: PUSH
19289: LD_VAR 0 4
19293: MINUS
19294: ST_TO_ADDR
// if y - r < 0 then
19295: LD_VAR 0 3
19299: PUSH
19300: LD_VAR 0 4
19304: MINUS
19305: PUSH
19306: LD_INT 0
19308: LESS
19309: IFFALSE 19321
// min_y := 0 else
19311: LD_ADDR_VAR 0 8
19315: PUSH
19316: LD_INT 0
19318: ST_TO_ADDR
19319: GO 19337
// min_y := y - r ;
19321: LD_ADDR_VAR 0 8
19325: PUSH
19326: LD_VAR 0 3
19330: PUSH
19331: LD_VAR 0 4
19335: MINUS
19336: ST_TO_ADDR
// max_x := x + r ;
19337: LD_ADDR_VAR 0 9
19341: PUSH
19342: LD_VAR 0 2
19346: PUSH
19347: LD_VAR 0 4
19351: PLUS
19352: ST_TO_ADDR
// max_y := y + r ;
19353: LD_ADDR_VAR 0 10
19357: PUSH
19358: LD_VAR 0 3
19362: PUSH
19363: LD_VAR 0 4
19367: PLUS
19368: ST_TO_ADDR
// for _x = min_x to max_x do
19369: LD_ADDR_VAR 0 11
19373: PUSH
19374: DOUBLE
19375: LD_VAR 0 7
19379: DEC
19380: ST_TO_ADDR
19381: LD_VAR 0 9
19385: PUSH
19386: FOR_TO
19387: IFFALSE 19504
// for _y = min_y to max_y do
19389: LD_ADDR_VAR 0 12
19393: PUSH
19394: DOUBLE
19395: LD_VAR 0 8
19399: DEC
19400: ST_TO_ADDR
19401: LD_VAR 0 10
19405: PUSH
19406: FOR_TO
19407: IFFALSE 19500
// begin if not ValidHex ( _x , _y ) then
19409: LD_VAR 0 11
19413: PPUSH
19414: LD_VAR 0 12
19418: PPUSH
19419: CALL_OW 488
19423: NOT
19424: IFFALSE 19428
// continue ;
19426: GO 19406
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
19428: LD_VAR 0 11
19432: PPUSH
19433: LD_VAR 0 12
19437: PPUSH
19438: CALL_OW 351
19442: PUSH
19443: LD_VAR 0 11
19447: PPUSH
19448: LD_VAR 0 12
19452: PPUSH
19453: CALL_OW 554
19457: AND
19458: IFFALSE 19498
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
19460: LD_ADDR_VAR 0 13
19464: PUSH
19465: LD_VAR 0 13
19469: PPUSH
19470: LD_VAR 0 13
19474: PUSH
19475: LD_INT 1
19477: PLUS
19478: PPUSH
19479: LD_VAR 0 11
19483: PUSH
19484: LD_VAR 0 12
19488: PUSH
19489: EMPTY
19490: LIST
19491: LIST
19492: PPUSH
19493: CALL_OW 2
19497: ST_TO_ADDR
// end ;
19498: GO 19406
19500: POP
19501: POP
19502: GO 19386
19504: POP
19505: POP
// if not list then
19506: LD_VAR 0 13
19510: NOT
19511: IFFALSE 19515
// exit ;
19513: GO 19586
// for i in list do
19515: LD_ADDR_VAR 0 6
19519: PUSH
19520: LD_VAR 0 13
19524: PUSH
19525: FOR_IN
19526: IFFALSE 19584
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
19528: LD_VAR 0 1
19532: PPUSH
19533: LD_STRING M
19535: PUSH
19536: LD_VAR 0 6
19540: PUSH
19541: LD_INT 1
19543: ARRAY
19544: PUSH
19545: LD_VAR 0 6
19549: PUSH
19550: LD_INT 2
19552: ARRAY
19553: PUSH
19554: LD_INT 0
19556: PUSH
19557: LD_INT 0
19559: PUSH
19560: LD_INT 0
19562: PUSH
19563: LD_INT 0
19565: PUSH
19566: EMPTY
19567: LIST
19568: LIST
19569: LIST
19570: LIST
19571: LIST
19572: LIST
19573: LIST
19574: PUSH
19575: EMPTY
19576: LIST
19577: PPUSH
19578: CALL_OW 447
19582: GO 19525
19584: POP
19585: POP
// end ;
19586: LD_VAR 0 5
19590: RET
