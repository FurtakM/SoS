// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// Init ;
  15: CALL 79 0 0
// InitRestrictions ;
  19: CALL 207 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 33
// DebugMode ;
  29: CALL 288 0 0
// SpawnApeman ( apemanStartArea , 2 ) ;
  33: LD_INT 12
  35: PPUSH
  36: LD_INT 2
  38: PPUSH
  39: CALL 658 0 2
// SpawnApeman ( apemanArea , [ 10 , 8 , 7 ] [ Difficulty ] ) ;
  43: LD_INT 11
  45: PPUSH
  46: LD_INT 10
  48: PUSH
  49: LD_INT 8
  51: PUSH
  52: LD_INT 7
  54: PUSH
  55: EMPTY
  56: LIST
  57: LIST
  58: LIST
  59: PUSH
  60: LD_OWVAR 67
  64: ARRAY
  65: PPUSH
  66: CALL 658 0 2
// PrepareAmericans ;
  70: CALL 1257 0 0
// Action ;
  74: CALL 2147 0 0
// end ;
  78: END
// export debug ; export mission_prefix , mission_prefix_prev ; export deltaBuilded , denisArrives , Delta , radar_allowed , first_apeman_tamed , apeman_army , radar_researched , radar_builded ; export apeman_counter , arab_spotted , end_mission , apeKillCounter ; function Init ; begin
  79: LD_INT 0
  81: PPUSH
// debug := false ;
  82: LD_ADDR_EXP 1
  86: PUSH
  87: LD_INT 0
  89: ST_TO_ADDR
// mission_prefix := 05_ ;
  90: LD_ADDR_EXP 2
  94: PUSH
  95: LD_STRING 05_
  97: ST_TO_ADDR
// mission_prefix_prev := 05a_ ;
  98: LD_ADDR_EXP 3
 102: PUSH
 103: LD_STRING 05a_
 105: ST_TO_ADDR
// deltaBuilded := false ;
 106: LD_ADDR_EXP 4
 110: PUSH
 111: LD_INT 0
 113: ST_TO_ADDR
// denisArrives := false ;
 114: LD_ADDR_EXP 5
 118: PUSH
 119: LD_INT 0
 121: ST_TO_ADDR
// radar_allowed := false ;
 122: LD_ADDR_EXP 7
 126: PUSH
 127: LD_INT 0
 129: ST_TO_ADDR
// first_apeman_tamed := false ;
 130: LD_ADDR_EXP 8
 134: PUSH
 135: LD_INT 0
 137: ST_TO_ADDR
// arab_spotted := false ;
 138: LD_ADDR_EXP 13
 142: PUSH
 143: LD_INT 0
 145: ST_TO_ADDR
// end_mission := false ;
 146: LD_ADDR_EXP 14
 150: PUSH
 151: LD_INT 0
 153: ST_TO_ADDR
// apeman_army := false ;
 154: LD_ADDR_EXP 9
 158: PUSH
 159: LD_INT 0
 161: ST_TO_ADDR
// radar_researched := false ;
 162: LD_ADDR_EXP 10
 166: PUSH
 167: LD_INT 0
 169: ST_TO_ADDR
// radar_builded := false ;
 170: LD_ADDR_EXP 11
 174: PUSH
 175: LD_INT 0
 177: ST_TO_ADDR
// apeman_counter := 0 ;
 178: LD_ADDR_EXP 12
 182: PUSH
 183: LD_INT 0
 185: ST_TO_ADDR
// Delta := 0 ;
 186: LD_ADDR_EXP 6
 190: PUSH
 191: LD_INT 0
 193: ST_TO_ADDR
// apeKillCounter := 0 ;
 194: LD_ADDR_EXP 15
 198: PUSH
 199: LD_INT 0
 201: ST_TO_ADDR
// end ;
 202: LD_VAR 0 1
 206: RET
// function InitRestrictions ; begin
 207: LD_INT 0
 209: PPUSH
// SetRestrict ( b_lab_half , 1 , state_enabled ) ;
 210: LD_INT 7
 212: PPUSH
 213: LD_INT 1
 215: PPUSH
 216: LD_INT 1
 218: PPUSH
 219: CALL_OW 324
// SetRestrict ( b_lab_full , 1 , state_enabled ) ;
 223: LD_INT 8
 225: PPUSH
 226: LD_INT 1
 228: PPUSH
 229: LD_INT 1
 231: PPUSH
 232: CALL_OW 324
// SetRestrict ( b_lab_weapon , 1 , state_enabled ) ;
 236: LD_INT 10
 238: PPUSH
 239: LD_INT 1
 241: PPUSH
 242: LD_INT 1
 244: PPUSH
 245: CALL_OW 324
// SetTech ( tech_gatling , 1 , LoadVariable ( GatlingInGamma , 1 ) ) ;
 249: LD_INT 69
 251: PPUSH
 252: LD_INT 1
 254: PPUSH
 255: LD_STRING GatlingInGamma
 257: PPUSH
 258: LD_INT 1
 260: PPUSH
 261: CALL_OW 30
 265: PPUSH
 266: CALL_OW 322
// SetTech ( tech_weap1 , 1 , state_enabled ) ;
 270: LD_INT 51
 272: PPUSH
 273: LD_INT 1
 275: PPUSH
 276: LD_INT 1
 278: PPUSH
 279: CALL_OW 322
// end ;
 283: LD_VAR 0 1
 287: RET
// function DebugMode ; begin
 288: LD_INT 0
 290: PPUSH
// FogOff ( 1 ) ;
 291: LD_INT 1
 293: PPUSH
 294: CALL_OW 344
// Difficulty := 2 ;
 298: LD_ADDR_OWVAR 67
 302: PUSH
 303: LD_INT 2
 305: ST_TO_ADDR
// end ;
 306: LD_VAR 0 1
 310: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 0 ] ] ) >= 7 do
 311: LD_INT 22
 313: PUSH
 314: LD_INT 1
 316: PUSH
 317: EMPTY
 318: LIST
 319: LIST
 320: PUSH
 321: LD_INT 23
 323: PUSH
 324: LD_INT 0
 326: PUSH
 327: EMPTY
 328: LIST
 329: LIST
 330: PUSH
 331: EMPTY
 332: LIST
 333: LIST
 334: PPUSH
 335: CALL_OW 69
 339: PUSH
 340: LD_INT 7
 342: GREATEREQUAL
 343: IFFALSE 355
 345: GO 347
 347: DISABLE
// SetAchievement ( ACH_TAME ) ;
 348: LD_STRING ACH_TAME
 350: PPUSH
 351: CALL_OW 543
 355: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_bweapon , us_radar ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) do
 356: LD_INT 22
 358: PUSH
 359: LD_INT 1
 361: PUSH
 362: EMPTY
 363: LIST
 364: LIST
 365: PUSH
 366: LD_INT 35
 368: PUSH
 369: LD_INT 11
 371: PUSH
 372: EMPTY
 373: LIST
 374: LIST
 375: PUSH
 376: EMPTY
 377: LIST
 378: LIST
 379: PPUSH
 380: CALL_OW 69
 384: PUSH
 385: LD_INT 22
 387: PUSH
 388: LD_INT 1
 390: PUSH
 391: EMPTY
 392: LIST
 393: LIST
 394: PUSH
 395: LD_INT 34
 397: PUSH
 398: LD_INT 11
 400: PUSH
 401: EMPTY
 402: LIST
 403: LIST
 404: PUSH
 405: EMPTY
 406: LIST
 407: LIST
 408: PPUSH
 409: CALL_OW 69
 413: AND
 414: IFFALSE 426
 416: GO 418
 418: DISABLE
// SetAchievement ( ACH_RADAR ) ; end_of_file
 419: LD_STRING ACH_RADAR
 421: PPUSH
 422: CALL_OW 543
 426: END
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 427: LD_INT 0
 429: PPUSH
 430: PPUSH
// if exist_mode then
 431: LD_VAR 0 2
 435: IFFALSE 460
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 437: LD_ADDR_VAR 0 4
 441: PUSH
 442: LD_EXP 3
 446: PUSH
 447: LD_VAR 0 1
 451: STR
 452: PPUSH
 453: CALL_OW 34
 457: ST_TO_ADDR
 458: GO 475
// unit := NewCharacter ( ident ) ;
 460: LD_ADDR_VAR 0 4
 464: PUSH
 465: LD_VAR 0 1
 469: PPUSH
 470: CALL_OW 25
 474: ST_TO_ADDR
// result := unit ;
 475: LD_ADDR_VAR 0 3
 479: PUSH
 480: LD_VAR 0 4
 484: ST_TO_ADDR
// end ;
 485: LD_VAR 0 3
 489: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 490: LD_INT 0
 492: PPUSH
// uc_side := side ;
 493: LD_ADDR_OWVAR 20
 497: PUSH
 498: LD_VAR 0 1
 502: ST_TO_ADDR
// uc_nation := nation ;
 503: LD_ADDR_OWVAR 21
 507: PUSH
 508: LD_VAR 0 2
 512: ST_TO_ADDR
// vc_chassis := chassis ;
 513: LD_ADDR_OWVAR 37
 517: PUSH
 518: LD_VAR 0 3
 522: ST_TO_ADDR
// vc_engine := engine ;
 523: LD_ADDR_OWVAR 39
 527: PUSH
 528: LD_VAR 0 4
 532: ST_TO_ADDR
// vc_control := control ;
 533: LD_ADDR_OWVAR 38
 537: PUSH
 538: LD_VAR 0 5
 542: ST_TO_ADDR
// vc_weapon := weapon ;
 543: LD_ADDR_OWVAR 40
 547: PUSH
 548: LD_VAR 0 6
 552: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 553: LD_ADDR_OWVAR 41
 557: PUSH
 558: LD_VAR 0 7
 562: ST_TO_ADDR
// result := CreateVehicle ;
 563: LD_ADDR_VAR 0 8
 567: PUSH
 568: CALL_OW 45
 572: ST_TO_ADDR
// end ;
 573: LD_VAR 0 8
 577: RET
// export function SayX ( units , ident ) ; var i ; begin
 578: LD_INT 0
 580: PPUSH
 581: PPUSH
// result := false ;
 582: LD_ADDR_VAR 0 3
 586: PUSH
 587: LD_INT 0
 589: ST_TO_ADDR
// if not units then
 590: LD_VAR 0 1
 594: NOT
 595: IFFALSE 599
// exit ;
 597: GO 653
// for i in units do
 599: LD_ADDR_VAR 0 4
 603: PUSH
 604: LD_VAR 0 1
 608: PUSH
 609: FOR_IN
 610: IFFALSE 651
// if IsOk ( i ) then
 612: LD_VAR 0 4
 616: PPUSH
 617: CALL_OW 302
 621: IFFALSE 649
// begin Say ( i , ident ) ;
 623: LD_VAR 0 4
 627: PPUSH
 628: LD_VAR 0 2
 632: PPUSH
 633: CALL_OW 88
// result := i ;
 637: LD_ADDR_VAR 0 3
 641: PUSH
 642: LD_VAR 0 4
 646: ST_TO_ADDR
// break ;
 647: GO 651
// end ;
 649: GO 609
 651: POP
 652: POP
// end ;
 653: LD_VAR 0 3
 657: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 658: LD_INT 0
 660: PPUSH
 661: PPUSH
// InitUc ;
 662: CALL_OW 18
// InitHc ;
 666: CALL_OW 19
// uc_side := 0 ;
 670: LD_ADDR_OWVAR 20
 674: PUSH
 675: LD_INT 0
 677: ST_TO_ADDR
// uc_nation := 0 ;
 678: LD_ADDR_OWVAR 21
 682: PUSH
 683: LD_INT 0
 685: ST_TO_ADDR
// for i = 1 to amount do
 686: LD_ADDR_VAR 0 4
 690: PUSH
 691: DOUBLE
 692: LD_INT 1
 694: DEC
 695: ST_TO_ADDR
 696: LD_VAR 0 2
 700: PUSH
 701: FOR_TO
 702: IFFALSE 784
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 704: LD_ADDR_OWVAR 29
 708: PUSH
 709: LD_INT 9
 711: PPUSH
 712: LD_INT 12
 714: PPUSH
 715: CALL_OW 12
 719: PUSH
 720: LD_INT 9
 722: PPUSH
 723: LD_INT 12
 725: PPUSH
 726: CALL_OW 12
 730: PUSH
 731: EMPTY
 732: LIST
 733: LIST
 734: ST_TO_ADDR
// hc_agressivity := rand ( - 5 , 5 ) ;
 735: LD_ADDR_OWVAR 35
 739: PUSH
 740: LD_INT 5
 742: NEG
 743: PPUSH
 744: LD_INT 5
 746: PPUSH
 747: CALL_OW 12
 751: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 752: LD_INT 0
 754: PPUSH
 755: LD_INT 12
 757: PPUSH
 758: LD_INT 1
 760: PPUSH
 761: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 765: CALL_OW 44
 769: PPUSH
 770: LD_VAR 0 1
 774: PPUSH
 775: LD_INT 0
 777: PPUSH
 778: CALL_OW 49
// end ;
 782: GO 701
 784: POP
 785: POP
// InitHc ;
 786: CALL_OW 19
// end ;
 790: LD_VAR 0 3
 794: RET
// export function Attack ( unit , enemy_list ) ; var target , targets_list ; begin
 795: LD_INT 0
 797: PPUSH
 798: PPUSH
 799: PPUSH
// if not unit then
 800: LD_VAR 0 1
 804: NOT
 805: IFFALSE 809
// exit ;
 807: GO 1252
// if IsInUnit ( unit ) then
 809: LD_VAR 0 1
 813: PPUSH
 814: CALL_OW 310
 818: IFFALSE 835
// unit := IsDrivenBy ( unit ) ;
 820: LD_ADDR_VAR 0 1
 824: PUSH
 825: LD_VAR 0 1
 829: PPUSH
 830: CALL_OW 311
 834: ST_TO_ADDR
// targets_list := [ ] ;
 835: LD_ADDR_VAR 0 5
 839: PUSH
 840: EMPTY
 841: ST_TO_ADDR
// target := UnitFilter ( enemy_list , [ [ f_lives , 250 ] , [ f_not , [ f_weapon , us_cargo_bay ] ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
 842: LD_ADDR_VAR 0 4
 846: PUSH
 847: LD_VAR 0 2
 851: PPUSH
 852: LD_INT 24
 854: PUSH
 855: LD_INT 250
 857: PUSH
 858: EMPTY
 859: LIST
 860: LIST
 861: PUSH
 862: LD_INT 3
 864: PUSH
 865: LD_INT 34
 867: PUSH
 868: LD_INT 12
 870: PUSH
 871: EMPTY
 872: LIST
 873: LIST
 874: PUSH
 875: EMPTY
 876: LIST
 877: LIST
 878: PUSH
 879: LD_INT 21
 881: PUSH
 882: LD_INT 2
 884: PUSH
 885: EMPTY
 886: LIST
 887: LIST
 888: PUSH
 889: LD_INT 58
 891: PUSH
 892: EMPTY
 893: LIST
 894: PUSH
 895: EMPTY
 896: LIST
 897: LIST
 898: LIST
 899: LIST
 900: PPUSH
 901: CALL_OW 72
 905: ST_TO_ADDR
// if GetDistUnits ( NearestUnitToUnit ( target , unit ) , unit ) < 11 and not IsInUnit ( unit ) then
 906: LD_VAR 0 4
 910: PPUSH
 911: LD_VAR 0 1
 915: PPUSH
 916: CALL_OW 74
 920: PPUSH
 921: LD_VAR 0 1
 925: PPUSH
 926: CALL_OW 296
 930: PUSH
 931: LD_INT 11
 933: LESS
 934: PUSH
 935: LD_VAR 0 1
 939: PPUSH
 940: CALL_OW 310
 944: NOT
 945: AND
 946: IFFALSE 974
// begin ComEnterUnit ( unit , NearestUnitToUnit ( target , unit ) ) ;
 948: LD_VAR 0 1
 952: PPUSH
 953: LD_VAR 0 4
 957: PPUSH
 958: LD_VAR 0 1
 962: PPUSH
 963: CALL_OW 74
 967: PPUSH
 968: CALL_OW 120
// exit ;
 972: GO 1252
// end ; targets_list := [ UnitFilter ( enemy_list , [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] ] ) , UnitFilter ( enemy_list , [ f_type , unit_vehicle ] ) , UnitFilter ( enemy_list , [ [ f_type , unit_building ] , [ f_not , [ f_empty ] ] ] ) , enemy_list ] ;
 974: LD_ADDR_VAR 0 5
 978: PUSH
 979: LD_VAR 0 2
 983: PPUSH
 984: LD_INT 21
 986: PUSH
 987: LD_INT 1
 989: PUSH
 990: EMPTY
 991: LIST
 992: LIST
 993: PUSH
 994: LD_INT 3
 996: PUSH
 997: LD_INT 54
 999: PUSH
1000: EMPTY
1001: LIST
1002: PUSH
1003: EMPTY
1004: LIST
1005: LIST
1006: PUSH
1007: EMPTY
1008: LIST
1009: LIST
1010: PPUSH
1011: CALL_OW 72
1015: PUSH
1016: LD_VAR 0 2
1020: PPUSH
1021: LD_INT 21
1023: PUSH
1024: LD_INT 2
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: PPUSH
1031: CALL_OW 72
1035: PUSH
1036: LD_VAR 0 2
1040: PPUSH
1041: LD_INT 21
1043: PUSH
1044: LD_INT 3
1046: PUSH
1047: EMPTY
1048: LIST
1049: LIST
1050: PUSH
1051: LD_INT 3
1053: PUSH
1054: LD_INT 58
1056: PUSH
1057: EMPTY
1058: LIST
1059: PUSH
1060: EMPTY
1061: LIST
1062: LIST
1063: PUSH
1064: EMPTY
1065: LIST
1066: LIST
1067: PPUSH
1068: CALL_OW 72
1072: PUSH
1073: LD_VAR 0 2
1077: PUSH
1078: EMPTY
1079: LIST
1080: LIST
1081: LIST
1082: LIST
1083: ST_TO_ADDR
// for target in targets_list do
1084: LD_ADDR_VAR 0 4
1088: PUSH
1089: LD_VAR 0 5
1093: PUSH
1094: FOR_IN
1095: IFFALSE 1250
// begin if target then
1097: LD_VAR 0 4
1101: IFFALSE 1248
// if GetTag ( unit ) = 11 and ( GetType ( NearestUnitToUnit ( target , unit ) ) = unit_building or GetWeapon ( NearestUnitToUnit ( target , unit ) ) = us_cargo_bay ) then
1103: LD_VAR 0 1
1107: PPUSH
1108: CALL_OW 110
1112: PUSH
1113: LD_INT 11
1115: EQUAL
1116: PUSH
1117: LD_VAR 0 4
1121: PPUSH
1122: LD_VAR 0 1
1126: PPUSH
1127: CALL_OW 74
1131: PPUSH
1132: CALL_OW 247
1136: PUSH
1137: LD_INT 3
1139: EQUAL
1140: PUSH
1141: LD_VAR 0 4
1145: PPUSH
1146: LD_VAR 0 1
1150: PPUSH
1151: CALL_OW 74
1155: PPUSH
1156: CALL_OW 264
1160: PUSH
1161: LD_INT 12
1163: EQUAL
1164: OR
1165: AND
1166: IFFALSE 1212
// begin ComPlaceDelayedCharge ( unit , 0 , 0 , NearestUnitToUnit ( target , unit ) ) ;
1168: LD_VAR 0 1
1172: PPUSH
1173: LD_INT 0
1175: PPUSH
1176: LD_INT 0
1178: PPUSH
1179: LD_VAR 0 4
1183: PPUSH
1184: LD_VAR 0 1
1188: PPUSH
1189: CALL_OW 74
1193: PPUSH
1194: CALL_OW 132
// SetTag ( unit , 0 ) ;
1198: LD_VAR 0 1
1202: PPUSH
1203: LD_INT 0
1205: PPUSH
1206: CALL_OW 109
// end else
1210: GO 1248
// if not HasTask ( unit ) then
1212: LD_VAR 0 1
1216: PPUSH
1217: CALL_OW 314
1221: NOT
1222: IFFALSE 1248
// ComAttackUnit ( unit , NearestUnitToUnit ( target , unit ) ) ;
1224: LD_VAR 0 1
1228: PPUSH
1229: LD_VAR 0 4
1233: PPUSH
1234: LD_VAR 0 1
1238: PPUSH
1239: CALL_OW 74
1243: PPUSH
1244: CALL_OW 115
// end ;
1248: GO 1094
1250: POP
1251: POP
// end ; end_of_file
1252: LD_VAR 0 3
1256: RET
// export JMM , Gladstone , Harrison , Denis , Brown , Donaldson , Lisa , Frank , Bobby , Cyrus ; export others ; export function PrepareAmericans ; var i , points , veh , tmp ; begin
1257: LD_INT 0
1259: PPUSH
1260: PPUSH
1261: PPUSH
1262: PPUSH
1263: PPUSH
// uc_nation := 1 ;
1264: LD_ADDR_OWVAR 21
1268: PUSH
1269: LD_INT 1
1271: ST_TO_ADDR
// uc_side := 4 ;
1272: LD_ADDR_OWVAR 20
1276: PUSH
1277: LD_INT 4
1279: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , false ) ;
1280: LD_ADDR_EXP 19
1284: PUSH
1285: LD_STRING Denis
1287: PPUSH
1288: LD_INT 0
1290: PPUSH
1291: CALL 427 0 2
1295: ST_TO_ADDR
// Harrison := PrepareUnit ( Harisson , false ) ;
1296: LD_ADDR_EXP 18
1300: PUSH
1301: LD_STRING Harisson
1303: PPUSH
1304: LD_INT 0
1306: PPUSH
1307: CALL 427 0 2
1311: ST_TO_ADDR
// uc_side := 1 ;
1312: LD_ADDR_OWVAR 20
1316: PUSH
1317: LD_INT 1
1319: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1320: LD_ADDR_EXP 16
1324: PUSH
1325: LD_STRING JMM
1327: PPUSH
1328: LD_EXP 1
1332: NOT
1333: PPUSH
1334: CALL 427 0 2
1338: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , false ) ;
1339: LD_ADDR_EXP 17
1343: PUSH
1344: LD_STRING Gladstone
1346: PPUSH
1347: LD_INT 0
1349: PPUSH
1350: CALL 427 0 2
1354: ST_TO_ADDR
// if LoadVariable ( BrownInDelta , debug ) then
1355: LD_STRING BrownInDelta
1357: PPUSH
1358: LD_EXP 1
1362: PPUSH
1363: CALL_OW 30
1367: IFFALSE 1404
// begin Brown := PrepareUnit ( Brown , ( not debug ) ) ;
1369: LD_ADDR_EXP 20
1373: PUSH
1374: LD_STRING Brown
1376: PPUSH
1377: LD_EXP 1
1381: NOT
1382: PPUSH
1383: CALL 427 0 2
1387: ST_TO_ADDR
// tmp := tmp ^ Brown ;
1388: LD_ADDR_VAR 0 5
1392: PUSH
1393: LD_VAR 0 5
1397: PUSH
1398: LD_EXP 20
1402: ADD
1403: ST_TO_ADDR
// end ; if LoadVariable ( DonaldsonInDelta , debug ) then
1404: LD_STRING DonaldsonInDelta
1406: PPUSH
1407: LD_EXP 1
1411: PPUSH
1412: CALL_OW 30
1416: IFFALSE 1453
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
1418: LD_ADDR_EXP 21
1422: PUSH
1423: LD_STRING Donaldson
1425: PPUSH
1426: LD_EXP 1
1430: NOT
1431: PPUSH
1432: CALL 427 0 2
1436: ST_TO_ADDR
// tmp := tmp ^ Donaldson ;
1437: LD_ADDR_VAR 0 5
1441: PUSH
1442: LD_VAR 0 5
1446: PUSH
1447: LD_EXP 21
1451: ADD
1452: ST_TO_ADDR
// end ; if LoadVariable ( LisaInDelta , debug ) then
1453: LD_STRING LisaInDelta
1455: PPUSH
1456: LD_EXP 1
1460: PPUSH
1461: CALL_OW 30
1465: IFFALSE 1502
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1467: LD_ADDR_EXP 22
1471: PUSH
1472: LD_STRING Lisa
1474: PPUSH
1475: LD_EXP 1
1479: NOT
1480: PPUSH
1481: CALL 427 0 2
1485: ST_TO_ADDR
// tmp := tmp ^ Lisa ;
1486: LD_ADDR_VAR 0 5
1490: PUSH
1491: LD_VAR 0 5
1495: PUSH
1496: LD_EXP 22
1500: ADD
1501: ST_TO_ADDR
// end ; if LoadVariable ( FrankInDelta , debug ) then
1502: LD_STRING FrankInDelta
1504: PPUSH
1505: LD_EXP 1
1509: PPUSH
1510: CALL_OW 30
1514: IFFALSE 1551
// begin Frank := PrepareUnit ( Frank , ( not debug ) ) ;
1516: LD_ADDR_EXP 23
1520: PUSH
1521: LD_STRING Frank
1523: PPUSH
1524: LD_EXP 1
1528: NOT
1529: PPUSH
1530: CALL 427 0 2
1534: ST_TO_ADDR
// tmp := tmp ^ Frank ;
1535: LD_ADDR_VAR 0 5
1539: PUSH
1540: LD_VAR 0 5
1544: PUSH
1545: LD_EXP 23
1549: ADD
1550: ST_TO_ADDR
// end ; if LoadVariable ( BobbyInDelta , 0 ) then
1551: LD_STRING BobbyInDelta
1553: PPUSH
1554: LD_INT 0
1556: PPUSH
1557: CALL_OW 30
1561: IFFALSE 1598
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1563: LD_ADDR_EXP 24
1567: PUSH
1568: LD_STRING Bobby
1570: PPUSH
1571: LD_EXP 1
1575: NOT
1576: PPUSH
1577: CALL 427 0 2
1581: ST_TO_ADDR
// tmp := tmp ^ Bobby ;
1582: LD_ADDR_VAR 0 5
1586: PUSH
1587: LD_VAR 0 5
1591: PUSH
1592: LD_EXP 24
1596: ADD
1597: ST_TO_ADDR
// end ; if LoadVariable ( CyrusInDelta , 0 ) then
1598: LD_STRING CyrusInDelta
1600: PPUSH
1601: LD_INT 0
1603: PPUSH
1604: CALL_OW 30
1608: IFFALSE 1645
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1610: LD_ADDR_EXP 25
1614: PUSH
1615: LD_STRING Cyrus
1617: PPUSH
1618: LD_EXP 1
1622: NOT
1623: PPUSH
1624: CALL 427 0 2
1628: ST_TO_ADDR
// tmp := tmp ^ Cyrus ;
1629: LD_ADDR_VAR 0 5
1633: PUSH
1634: LD_VAR 0 5
1638: PUSH
1639: LD_EXP 25
1643: ADD
1644: ST_TO_ADDR
// end ; others := CreateCharacterSet ( othersDelta ) ;
1645: LD_ADDR_EXP 26
1649: PUSH
1650: LD_STRING othersDelta
1652: PPUSH
1653: CALL_OW 31
1657: ST_TO_ADDR
// if not others and debug then
1658: LD_EXP 26
1662: NOT
1663: PUSH
1664: LD_EXP 1
1668: AND
1669: IFFALSE 1734
// begin InitHc ;
1671: CALL_OW 19
// for i = 1 to 2 do
1675: LD_ADDR_VAR 0 2
1679: PUSH
1680: DOUBLE
1681: LD_INT 1
1683: DEC
1684: ST_TO_ADDR
1685: LD_INT 2
1687: PUSH
1688: FOR_TO
1689: IFFALSE 1732
// begin PrepareHuman ( false , i mod 4 + 1 , 3 ) ;
1691: LD_INT 0
1693: PPUSH
1694: LD_VAR 0 2
1698: PUSH
1699: LD_INT 4
1701: MOD
1702: PUSH
1703: LD_INT 1
1705: PLUS
1706: PPUSH
1707: LD_INT 3
1709: PPUSH
1710: CALL_OW 380
// others := others ^ CreateHuman ;
1714: LD_ADDR_EXP 26
1718: PUSH
1719: LD_EXP 26
1723: PUSH
1724: CALL_OW 44
1728: ADD
1729: ST_TO_ADDR
// end ;
1730: GO 1688
1732: POP
1733: POP
// end ; if others then
1734: LD_EXP 26
1738: IFFALSE 1756
// tmp := tmp ^ others ;
1740: LD_ADDR_VAR 0 5
1744: PUSH
1745: LD_VAR 0 5
1749: PUSH
1750: LD_EXP 26
1754: ADD
1755: ST_TO_ADDR
// points := [ [ 28 , 49 ] , [ 33 , 54 ] , [ 38 , 56 ] ] ;
1756: LD_ADDR_VAR 0 3
1760: PUSH
1761: LD_INT 28
1763: PUSH
1764: LD_INT 49
1766: PUSH
1767: EMPTY
1768: LIST
1769: LIST
1770: PUSH
1771: LD_INT 33
1773: PUSH
1774: LD_INT 54
1776: PUSH
1777: EMPTY
1778: LIST
1779: LIST
1780: PUSH
1781: LD_INT 38
1783: PUSH
1784: LD_INT 56
1786: PUSH
1787: EMPTY
1788: LIST
1789: LIST
1790: PUSH
1791: EMPTY
1792: LIST
1793: LIST
1794: LIST
1795: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , us_cargo_bay , 80 ) ;
1796: LD_ADDR_VAR 0 4
1800: PUSH
1801: LD_INT 1
1803: PPUSH
1804: LD_INT 1
1806: PPUSH
1807: LD_INT 2
1809: PPUSH
1810: LD_INT 2
1812: PPUSH
1813: LD_INT 1
1815: PPUSH
1816: LD_INT 12
1818: PPUSH
1819: LD_INT 80
1821: PPUSH
1822: CALL 490 0 7
1826: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1827: LD_VAR 0 4
1831: PPUSH
1832: LD_INT 1
1834: PPUSH
1835: CALL_OW 233
// PlaceUnitXY ( veh , points [ 1 ] [ 1 ] , points [ 1 ] [ 2 ] , false ) ;
1839: LD_VAR 0 4
1843: PPUSH
1844: LD_VAR 0 3
1848: PUSH
1849: LD_INT 1
1851: ARRAY
1852: PUSH
1853: LD_INT 1
1855: ARRAY
1856: PPUSH
1857: LD_VAR 0 3
1861: PUSH
1862: LD_INT 1
1864: ARRAY
1865: PUSH
1866: LD_INT 2
1868: ARRAY
1869: PPUSH
1870: LD_INT 0
1872: PPUSH
1873: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
1877: LD_VAR 0 4
1881: PPUSH
1882: LD_INT 1
1884: PPUSH
1885: LD_INT 100
1887: PPUSH
1888: CALL_OW 290
// PlaceHumanInUnit ( others [ 1 ] , veh ) ;
1892: LD_EXP 26
1896: PUSH
1897: LD_INT 1
1899: ARRAY
1900: PPUSH
1901: LD_VAR 0 4
1905: PPUSH
1906: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_machine_gun , 80 ) ;
1910: LD_ADDR_VAR 0 4
1914: PUSH
1915: LD_INT 1
1917: PPUSH
1918: LD_INT 1
1920: PPUSH
1921: LD_INT 1
1923: PPUSH
1924: LD_INT 2
1926: PPUSH
1927: LD_INT 1
1929: PPUSH
1930: LD_INT 2
1932: PPUSH
1933: LD_INT 80
1935: PPUSH
1936: CALL 490 0 7
1940: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1941: LD_VAR 0 4
1945: PPUSH
1946: LD_INT 1
1948: PPUSH
1949: CALL_OW 233
// PlaceUnitXY ( veh , points [ 2 ] [ 1 ] , points [ 2 ] [ 2 ] , false ) ;
1953: LD_VAR 0 4
1957: PPUSH
1958: LD_VAR 0 3
1962: PUSH
1963: LD_INT 2
1965: ARRAY
1966: PUSH
1967: LD_INT 1
1969: ARRAY
1970: PPUSH
1971: LD_VAR 0 3
1975: PUSH
1976: LD_INT 2
1978: ARRAY
1979: PUSH
1980: LD_INT 2
1982: ARRAY
1983: PPUSH
1984: LD_INT 0
1986: PPUSH
1987: CALL_OW 48
// PlaceHumanInUnit ( Gladstone , veh ) ;
1991: LD_EXP 17
1995: PPUSH
1996: LD_VAR 0 4
2000: PPUSH
2001: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_light_gun , 80 ) ;
2005: LD_ADDR_VAR 0 4
2009: PUSH
2010: LD_INT 1
2012: PPUSH
2013: LD_INT 1
2015: PPUSH
2016: LD_INT 1
2018: PPUSH
2019: LD_INT 2
2021: PPUSH
2022: LD_INT 1
2024: PPUSH
2025: LD_INT 3
2027: PPUSH
2028: LD_INT 80
2030: PPUSH
2031: CALL 490 0 7
2035: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
2036: LD_VAR 0 4
2040: PPUSH
2041: LD_INT 1
2043: PPUSH
2044: CALL_OW 233
// PlaceUnitXY ( veh , points [ 3 ] [ 1 ] , points [ 3 ] [ 2 ] , false ) ;
2048: LD_VAR 0 4
2052: PPUSH
2053: LD_VAR 0 3
2057: PUSH
2058: LD_INT 3
2060: ARRAY
2061: PUSH
2062: LD_INT 1
2064: ARRAY
2065: PPUSH
2066: LD_VAR 0 3
2070: PUSH
2071: LD_INT 3
2073: ARRAY
2074: PUSH
2075: LD_INT 2
2077: ARRAY
2078: PPUSH
2079: LD_INT 0
2081: PPUSH
2082: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
2086: LD_EXP 16
2090: PPUSH
2091: LD_VAR 0 4
2095: PPUSH
2096: CALL_OW 52
// for i in tmp diff others [ 1 ] do
2100: LD_ADDR_VAR 0 2
2104: PUSH
2105: LD_VAR 0 5
2109: PUSH
2110: LD_EXP 26
2114: PUSH
2115: LD_INT 1
2117: ARRAY
2118: DIFF
2119: PUSH
2120: FOR_IN
2121: IFFALSE 2140
// PlaceUnitArea ( i , startArea , false ) ;
2123: LD_VAR 0 2
2127: PPUSH
2128: LD_INT 5
2130: PPUSH
2131: LD_INT 0
2133: PPUSH
2134: CALL_OW 49
2138: GO 2120
2140: POP
2141: POP
// end ; end_of_file
2142: LD_VAR 0 1
2146: RET
// export function Action ; var m ; begin
2147: LD_INT 0
2149: PPUSH
2150: PPUSH
// InGameOn ;
2151: CALL_OW 8
// CenterNowOnXY ( 28 , 51 ) ;
2155: LD_INT 28
2157: PPUSH
2158: LD_INT 51
2160: PPUSH
2161: CALL_OW 86
// Wait ( 3 ) ;
2165: LD_INT 3
2167: PPUSH
2168: CALL_OW 67
// Say ( JMM , D1d-JMM-1a ) ;
2172: LD_EXP 16
2176: PPUSH
2177: LD_STRING D1d-JMM-1a
2179: PPUSH
2180: CALL_OW 88
// SayRadio ( Harrison , D1d-Har-1 ) ;
2184: LD_EXP 18
2188: PPUSH
2189: LD_STRING D1d-Har-1
2191: PPUSH
2192: CALL_OW 94
// InGameOff ;
2196: CALL_OW 9
// SaveForQuickRestart ;
2200: CALL_OW 22
// ChangeMissionObjectives ( M1 ) ;
2204: LD_STRING M1
2206: PPUSH
2207: CALL_OW 337
// Wait ( 0 0$2 ) ;
2211: LD_INT 70
2213: PPUSH
2214: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
2218: LD_EXP 16
2222: PPUSH
2223: LD_STRING D2-JMM-1
2225: PPUSH
2226: CALL_OW 88
// Say ( Gladstone , D2-Glad-1 ) ;
2230: LD_EXP 17
2234: PPUSH
2235: LD_STRING D2-Glad-1
2237: PPUSH
2238: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
2242: LD_EXP 16
2246: PPUSH
2247: LD_STRING D2-JMM-2
2249: PPUSH
2250: CALL_OW 88
// Say ( Gladstone , D2-Glad-2 ) ;
2254: LD_EXP 17
2258: PPUSH
2259: LD_STRING D2-Glad-2
2261: PPUSH
2262: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
2266: LD_EXP 16
2270: PPUSH
2271: LD_STRING D2-JMM-3
2273: PPUSH
2274: CALL_OW 88
// Wait ( rand ( 0 0$30 , 1 1$00 ) ) ;
2278: LD_INT 1050
2280: PPUSH
2281: LD_INT 2100
2283: PPUSH
2284: CALL_OW 12
2288: PPUSH
2289: CALL_OW 67
// SetWeather ( 1 , 570 , 350 ) ;
2293: LD_INT 1
2295: PPUSH
2296: LD_INT 570
2298: PPUSH
2299: LD_INT 350
2301: PPUSH
2302: CALL_OW 550
// Wait ( rand ( 3 3$00 , 5 5$00 ) ) ;
2306: LD_INT 6300
2308: PPUSH
2309: LD_INT 10500
2311: PPUSH
2312: CALL_OW 12
2316: PPUSH
2317: CALL_OW 67
// SetWeather ( 0 , 570 , 350 ) ;
2321: LD_INT 0
2323: PPUSH
2324: LD_INT 570
2326: PPUSH
2327: LD_INT 350
2329: PPUSH
2330: CALL_OW 550
// end ;
2334: LD_VAR 0 1
2338: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) and not deltaBuilded do
2339: LD_INT 22
2341: PUSH
2342: LD_INT 1
2344: PUSH
2345: EMPTY
2346: LIST
2347: LIST
2348: PUSH
2349: LD_INT 3
2351: PUSH
2352: LD_INT 57
2354: PUSH
2355: EMPTY
2356: LIST
2357: PUSH
2358: EMPTY
2359: LIST
2360: LIST
2361: PUSH
2362: LD_INT 30
2364: PUSH
2365: LD_INT 0
2367: PUSH
2368: EMPTY
2369: LIST
2370: LIST
2371: PUSH
2372: EMPTY
2373: LIST
2374: LIST
2375: LIST
2376: PUSH
2377: EMPTY
2378: LIST
2379: PPUSH
2380: CALL_OW 69
2384: PUSH
2385: LD_EXP 4
2389: NOT
2390: AND
2391: IFFALSE 2404
2393: GO 2395
2395: DISABLE
// begin deltaBuilded := true ;
2396: LD_ADDR_EXP 4
2400: PUSH
2401: LD_INT 1
2403: ST_TO_ADDR
// end ;
2404: END
// every 0 0$01 trigger not Delta and deltaBuilded and FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) do
2405: LD_EXP 6
2409: NOT
2410: PUSH
2411: LD_EXP 4
2415: AND
2416: PUSH
2417: LD_INT 22
2419: PUSH
2420: LD_INT 1
2422: PUSH
2423: EMPTY
2424: LIST
2425: LIST
2426: PUSH
2427: LD_INT 3
2429: PUSH
2430: LD_INT 57
2432: PUSH
2433: EMPTY
2434: LIST
2435: PUSH
2436: EMPTY
2437: LIST
2438: LIST
2439: PUSH
2440: LD_INT 30
2442: PUSH
2443: LD_INT 0
2445: PUSH
2446: EMPTY
2447: LIST
2448: LIST
2449: PUSH
2450: EMPTY
2451: LIST
2452: LIST
2453: LIST
2454: PUSH
2455: EMPTY
2456: LIST
2457: PPUSH
2458: CALL_OW 69
2462: AND
2463: IFFALSE 2549
2465: GO 2467
2467: DISABLE
// begin enable ;
2468: ENABLE
// SetRestrict ( b_depot , 1 , state_disabled ) ;
2469: LD_INT 0
2471: PPUSH
2472: LD_INT 1
2474: PPUSH
2475: LD_INT 0
2477: PPUSH
2478: CALL_OW 324
// Delta := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) [ 1 ] ;
2482: LD_ADDR_EXP 6
2486: PUSH
2487: LD_INT 22
2489: PUSH
2490: LD_INT 1
2492: PUSH
2493: EMPTY
2494: LIST
2495: LIST
2496: PUSH
2497: LD_INT 3
2499: PUSH
2500: LD_INT 57
2502: PUSH
2503: EMPTY
2504: LIST
2505: PUSH
2506: EMPTY
2507: LIST
2508: LIST
2509: PUSH
2510: LD_INT 30
2512: PUSH
2513: LD_INT 0
2515: PUSH
2516: EMPTY
2517: LIST
2518: LIST
2519: PUSH
2520: EMPTY
2521: LIST
2522: LIST
2523: LIST
2524: PUSH
2525: EMPTY
2526: LIST
2527: PPUSH
2528: CALL_OW 69
2532: PUSH
2533: LD_INT 1
2535: ARRAY
2536: ST_TO_ADDR
// SetBName ( Delta , Delta ) ;
2537: LD_EXP 6
2541: PPUSH
2542: LD_STRING Delta
2544: PPUSH
2545: CALL_OW 500
// end ;
2549: END
// every 0 0$2 trigger GetTech ( tech_ApeLang , 1 ) = state_researched and IsOk ( Gladstone ) do
2550: LD_INT 1
2552: PPUSH
2553: LD_INT 1
2555: PPUSH
2556: CALL_OW 321
2560: PUSH
2561: LD_INT 2
2563: EQUAL
2564: PUSH
2565: LD_EXP 17
2569: PPUSH
2570: CALL_OW 302
2574: AND
2575: IFFALSE 2636
2577: GO 2579
2579: DISABLE
// begin DialogueOn ;
2580: CALL_OW 6
// Say ( Gladstone , D3-Glad-1 ) ;
2584: LD_EXP 17
2588: PPUSH
2589: LD_STRING D3-Glad-1
2591: PPUSH
2592: CALL_OW 88
// Say ( JMM , D3-JMM-1 ) ;
2596: LD_EXP 16
2600: PPUSH
2601: LD_STRING D3-JMM-1
2603: PPUSH
2604: CALL_OW 88
// Say ( Gladstone , D3-Glad-2 ) ;
2608: LD_EXP 17
2612: PPUSH
2613: LD_STRING D3-Glad-2
2615: PPUSH
2616: CALL_OW 88
// Say ( JMM , D3-JMM-2 ) ;
2620: LD_EXP 16
2624: PPUSH
2625: LD_STRING D3-JMM-2
2627: PPUSH
2628: CALL_OW 88
// DialogueOff ;
2632: CALL_OW 7
// end ;
2636: END
// every 0 0$1 trigger GetTech ( tech_ApePsych , 1 ) = state_researched do var sol ;
2637: LD_INT 2
2639: PPUSH
2640: LD_INT 1
2642: PPUSH
2643: CALL_OW 321
2647: PUSH
2648: LD_INT 2
2650: EQUAL
2651: IFFALSE 2828
2653: GO 2655
2655: DISABLE
2656: LD_INT 0
2658: PPUSH
// begin DialogueOn ;
2659: CALL_OW 6
// if Frank then
2663: LD_EXP 23
2667: IFFALSE 2681
// Say ( Frank , D8a-Frank-1 ) ;
2669: LD_EXP 23
2673: PPUSH
2674: LD_STRING D8a-Frank-1
2676: PPUSH
2677: CALL_OW 88
// sol := SayX ( UnitFilter ( others , [ f_sex , sex_male ] ) , D8a-Sol1-1 ) ;
2681: LD_ADDR_VAR 0 1
2685: PUSH
2686: LD_EXP 26
2690: PPUSH
2691: LD_INT 26
2693: PUSH
2694: LD_INT 1
2696: PUSH
2697: EMPTY
2698: LIST
2699: LIST
2700: PPUSH
2701: CALL_OW 72
2705: PPUSH
2706: LD_STRING D8a-Sol1-1
2708: PPUSH
2709: CALL 578 0 2
2713: ST_TO_ADDR
// if Denis and GetSide ( Denis ) = 1 then
2714: LD_EXP 19
2718: PUSH
2719: LD_EXP 19
2723: PPUSH
2724: CALL_OW 255
2728: PUSH
2729: LD_INT 1
2731: EQUAL
2732: AND
2733: IFFALSE 2747
// Say ( Denis , D8a-Den-1 ) ;
2735: LD_EXP 19
2739: PPUSH
2740: LD_STRING D8a-Den-1
2742: PPUSH
2743: CALL_OW 88
// if sol or Denis or Frank then
2747: LD_VAR 0 1
2751: PUSH
2752: LD_EXP 19
2756: OR
2757: PUSH
2758: LD_EXP 23
2762: OR
2763: IFFALSE 2824
// begin SayX ( UnitFilter ( others , [ [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff sol , D8a-Sci1-1 ) ;
2765: LD_EXP 26
2769: PPUSH
2770: LD_INT 25
2772: PUSH
2773: LD_INT 4
2775: PUSH
2776: EMPTY
2777: LIST
2778: LIST
2779: PUSH
2780: LD_INT 26
2782: PUSH
2783: LD_INT 1
2785: PUSH
2786: EMPTY
2787: LIST
2788: LIST
2789: PUSH
2790: EMPTY
2791: LIST
2792: LIST
2793: PPUSH
2794: CALL_OW 72
2798: PUSH
2799: LD_VAR 0 1
2803: DIFF
2804: PPUSH
2805: LD_STRING D8a-Sci1-1
2807: PPUSH
2808: CALL 578 0 2
// Say ( JMM , D8a-JMM-1 ) ;
2812: LD_EXP 16
2816: PPUSH
2817: LD_STRING D8a-JMM-1
2819: PPUSH
2820: CALL_OW 88
// end ; DialogueOff ;
2824: CALL_OW 7
// end ;
2828: PPOPN 1
2830: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) do
2831: LD_INT 22
2833: PUSH
2834: LD_INT 1
2836: PUSH
2837: EMPTY
2838: LIST
2839: LIST
2840: PUSH
2841: LD_INT 25
2843: PUSH
2844: LD_INT 16
2846: PUSH
2847: EMPTY
2848: LIST
2849: LIST
2850: PUSH
2851: EMPTY
2852: LIST
2853: LIST
2854: PPUSH
2855: CALL_OW 69
2859: IFFALSE 2918
2861: GO 2863
2863: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
2864: LD_STRING M1a
2866: PPUSH
2867: CALL_OW 337
// case Query ( Q2 ) of 1 :
2871: LD_STRING Q2
2873: PPUSH
2874: CALL_OW 97
2878: PUSH
2879: LD_INT 1
2881: DOUBLE
2882: EQUAL
2883: IFTRUE 2887
2885: GO 2898
2887: POP
// end_mission := true ; 2 :
2888: LD_ADDR_EXP 14
2892: PUSH
2893: LD_INT 1
2895: ST_TO_ADDR
2896: GO 2918
2898: LD_INT 2
2900: DOUBLE
2901: EQUAL
2902: IFTRUE 2906
2904: GO 2917
2906: POP
// end_the_mission_allowed := true ; end ;
2907: LD_ADDR_OWVAR 57
2911: PUSH
2912: LD_INT 1
2914: ST_TO_ADDR
2915: GO 2918
2917: POP
// end ;
2918: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) and Delta do
2919: LD_INT 22
2921: PUSH
2922: LD_INT 1
2924: PUSH
2925: EMPTY
2926: LIST
2927: LIST
2928: PUSH
2929: LD_INT 2
2931: PUSH
2932: LD_INT 30
2934: PUSH
2935: LD_INT 6
2937: PUSH
2938: EMPTY
2939: LIST
2940: LIST
2941: PUSH
2942: LD_INT 30
2944: PUSH
2945: LD_INT 7
2947: PUSH
2948: EMPTY
2949: LIST
2950: LIST
2951: PUSH
2952: EMPTY
2953: LIST
2954: LIST
2955: LIST
2956: PUSH
2957: EMPTY
2958: LIST
2959: LIST
2960: PPUSH
2961: CALL_OW 69
2965: PUSH
2966: LD_INT 22
2968: PUSH
2969: LD_INT 1
2971: PUSH
2972: EMPTY
2973: LIST
2974: LIST
2975: PUSH
2976: LD_INT 2
2978: PUSH
2979: LD_INT 30
2981: PUSH
2982: LD_INT 2
2984: PUSH
2985: EMPTY
2986: LIST
2987: LIST
2988: PUSH
2989: LD_INT 30
2991: PUSH
2992: LD_INT 3
2994: PUSH
2995: EMPTY
2996: LIST
2997: LIST
2998: PUSH
2999: EMPTY
3000: LIST
3001: LIST
3002: LIST
3003: PUSH
3004: EMPTY
3005: LIST
3006: LIST
3007: PPUSH
3008: CALL_OW 69
3012: AND
3013: PUSH
3014: LD_EXP 6
3018: AND
3019: IFFALSE 3530
3021: GO 3023
3023: DISABLE
// begin Wait ( rand ( 0 0$30 , 0 0$50 ) ) ;
3024: LD_INT 1050
3026: PPUSH
3027: LD_INT 1750
3029: PPUSH
3030: CALL_OW 12
3034: PPUSH
3035: CALL_OW 67
// PlaceUnitArea ( Denis , [ denisArea1 , denisArea2 , denisArea3 ] [ Difficulty ] , false ) ;
3039: LD_EXP 19
3043: PPUSH
3044: LD_INT 6
3046: PUSH
3047: LD_INT 9
3049: PUSH
3050: LD_INT 10
3052: PUSH
3053: EMPTY
3054: LIST
3055: LIST
3056: LIST
3057: PUSH
3058: LD_OWVAR 67
3062: ARRAY
3063: PPUSH
3064: LD_INT 0
3066: PPUSH
3067: CALL_OW 49
// ComHold ( Denis ) ;
3071: LD_EXP 19
3075: PPUSH
3076: CALL_OW 140
// InGameOn ;
3080: CALL_OW 8
// DialogueOn ;
3084: CALL_OW 6
// if Delta then
3088: LD_EXP 6
3092: IFFALSE 3105
// CenterNowOnUnits ( Delta ) else
3094: LD_EXP 6
3098: PPUSH
3099: CALL_OW 87
3103: GO 3114
// CenterNowOnUnits ( JMM ) ;
3105: LD_EXP 16
3109: PPUSH
3110: CALL_OW 87
// SayRadio ( Denis , DD-Den-1 ) ;
3114: LD_EXP 19
3118: PPUSH
3119: LD_STRING DD-Den-1
3121: PPUSH
3122: CALL_OW 94
// Say ( JMM , DD-JMM-1 ) ;
3126: LD_EXP 16
3130: PPUSH
3131: LD_STRING DD-JMM-1
3133: PPUSH
3134: CALL_OW 88
// SayRadio ( Denis , DD-Den-2 ) ;
3138: LD_EXP 19
3142: PPUSH
3143: LD_STRING DD-Den-2
3145: PPUSH
3146: CALL_OW 94
// Wait ( 3 ) ;
3150: LD_INT 3
3152: PPUSH
3153: CALL_OW 67
// DialogueOff ;
3157: CALL_OW 7
// InGameOff ;
3161: CALL_OW 9
// if Difficulty = 1 then
3165: LD_OWVAR 67
3169: PUSH
3170: LD_INT 1
3172: EQUAL
3173: IFFALSE 3249
// begin PlaceSeeing ( GetX ( Denis ) , GetY ( Denis ) , 1 , - 12 ) ;
3175: LD_EXP 19
3179: PPUSH
3180: CALL_OW 250
3184: PPUSH
3185: LD_EXP 19
3189: PPUSH
3190: CALL_OW 251
3194: PPUSH
3195: LD_INT 1
3197: PPUSH
3198: LD_INT 12
3200: NEG
3201: PPUSH
3202: CALL_OW 330
// CenterNowOnUnits ( Denis ) ;
3206: LD_EXP 19
3210: PPUSH
3211: CALL_OW 87
// wait ( 0 0$5 ) ;
3215: LD_INT 175
3217: PPUSH
3218: CALL_OW 67
// RemoveSeeing ( GetX ( Denis ) , GetY ( Denis ) , 1 ) ;
3222: LD_EXP 19
3226: PPUSH
3227: CALL_OW 250
3231: PPUSH
3232: LD_EXP 19
3236: PPUSH
3237: CALL_OW 251
3241: PPUSH
3242: LD_INT 1
3244: PPUSH
3245: CALL_OW 331
// end ; repeat wait ( 0 0$01 ) ;
3249: LD_INT 35
3251: PPUSH
3252: CALL_OW 67
// until See ( 1 , Denis ) or IsDead ( Denis ) ;
3256: LD_INT 1
3258: PPUSH
3259: LD_EXP 19
3263: PPUSH
3264: CALL_OW 292
3268: PUSH
3269: LD_EXP 19
3273: PPUSH
3274: CALL_OW 301
3278: OR
3279: IFFALSE 3249
// if IsDead ( Denis ) then
3281: LD_EXP 19
3285: PPUSH
3286: CALL_OW 301
3290: IFFALSE 3294
// exit ;
3292: GO 3530
// SetSide ( Denis , 1 ) ;
3294: LD_EXP 19
3298: PPUSH
3299: LD_INT 1
3301: PPUSH
3302: CALL_OW 235
// Say ( Denis , DD-Den-2a ) ;
3306: LD_EXP 19
3310: PPUSH
3311: LD_STRING DD-Den-2a
3313: PPUSH
3314: CALL_OW 88
// repeat wait ( 0 0$01 ) ;
3318: LD_INT 35
3320: PPUSH
3321: CALL_OW 67
// until GetBType ( IsInUnit ( Denis ) ) in [ b_lab , b_lab_half , b_lab_full ] or IsDead ( Denis ) ;
3325: LD_EXP 19
3329: PPUSH
3330: CALL_OW 310
3334: PPUSH
3335: CALL_OW 266
3339: PUSH
3340: LD_INT 6
3342: PUSH
3343: LD_INT 7
3345: PUSH
3346: LD_INT 8
3348: PUSH
3349: EMPTY
3350: LIST
3351: LIST
3352: LIST
3353: IN
3354: PUSH
3355: LD_EXP 19
3359: PPUSH
3360: CALL_OW 301
3364: OR
3365: IFFALSE 3318
// if IsDead ( Denis ) then
3367: LD_EXP 19
3371: PPUSH
3372: CALL_OW 301
3376: IFFALSE 3380
// exit ;
3378: GO 3530
// Say ( Denis , DD-Den-2b ) ;
3380: LD_EXP 19
3384: PPUSH
3385: LD_STRING DD-Den-2b
3387: PPUSH
3388: CALL_OW 88
// ComChangeProfession ( Denis , 4 ) ;
3392: LD_EXP 19
3396: PPUSH
3397: LD_INT 4
3399: PPUSH
3400: CALL_OW 123
// Wait ( 0 0$02 ) ;
3404: LD_INT 70
3406: PPUSH
3407: CALL_OW 67
// DialogueOn ;
3411: CALL_OW 6
// CenterNowOnUnits ( Denis ) ;
3415: LD_EXP 19
3419: PPUSH
3420: CALL_OW 87
// Say ( JMM , D4-JMM-1 ) ;
3424: LD_EXP 16
3428: PPUSH
3429: LD_STRING D4-JMM-1
3431: PPUSH
3432: CALL_OW 88
// Say ( Denis , D4-Den-1 ) ;
3436: LD_EXP 19
3440: PPUSH
3441: LD_STRING D4-Den-1
3443: PPUSH
3444: CALL_OW 88
// Say ( JMM , D4-JMM-2 ) ;
3448: LD_EXP 16
3452: PPUSH
3453: LD_STRING D4-JMM-2
3455: PPUSH
3456: CALL_OW 88
// Say ( Denis , D4-Den-2 ) ;
3460: LD_EXP 19
3464: PPUSH
3465: LD_STRING D4-Den-2
3467: PPUSH
3468: CALL_OW 88
// DialogueOff ;
3472: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
3476: LD_STRING M2
3478: PPUSH
3479: CALL_OW 337
// radar_allowed := true ;
3483: LD_ADDR_EXP 7
3487: PUSH
3488: LD_INT 1
3490: ST_TO_ADDR
// SetTech ( tech_radar , 1 , state_enabled ) ;
3491: LD_INT 6
3493: PPUSH
3494: LD_INT 1
3496: PPUSH
3497: LD_INT 1
3499: PPUSH
3500: CALL_OW 322
// SetRestrict ( b_lab_opto , 1 , state_enabled ) ;
3504: LD_INT 15
3506: PPUSH
3507: LD_INT 1
3509: PPUSH
3510: LD_INT 1
3512: PPUSH
3513: CALL_OW 324
// SetRestrict ( b_ext_radar , 1 , state_enabled ) ;
3517: LD_INT 20
3519: PPUSH
3520: LD_INT 1
3522: PPUSH
3523: LD_INT 1
3525: PPUSH
3526: CALL_OW 324
// end ;
3530: END
// every 0 0$1 trigger arab_spotted do var sol , sol2 ;
3531: LD_EXP 13
3535: IFFALSE 4158
3537: GO 3539
3539: DISABLE
3540: LD_INT 0
3542: PPUSH
3543: PPUSH
// begin sol := SayX ( UnitFilter ( others , [ f_sex , sex_male ] ) , D5-Sol1-1 ) ;
3544: LD_ADDR_VAR 0 1
3548: PUSH
3549: LD_EXP 26
3553: PPUSH
3554: LD_INT 26
3556: PUSH
3557: LD_INT 1
3559: PUSH
3560: EMPTY
3561: LIST
3562: LIST
3563: PPUSH
3564: CALL_OW 72
3568: PPUSH
3569: LD_STRING D5-Sol1-1
3571: PPUSH
3572: CALL 578 0 2
3576: ST_TO_ADDR
// if not sol then
3577: LD_VAR 0 1
3581: NOT
3582: IFFALSE 3586
// exit ;
3584: GO 4158
// repeat wait ( 0 0$01 ) ;
3586: LD_INT 35
3588: PPUSH
3589: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 ;
3593: LD_INT 22
3595: PUSH
3596: LD_INT 2
3598: PUSH
3599: EMPTY
3600: LIST
3601: LIST
3602: PUSH
3603: LD_INT 21
3605: PUSH
3606: LD_INT 1
3608: PUSH
3609: EMPTY
3610: LIST
3611: LIST
3612: PUSH
3613: EMPTY
3614: LIST
3615: LIST
3616: PPUSH
3617: CALL_OW 69
3621: PUSH
3622: LD_INT 0
3624: EQUAL
3625: IFFALSE 3586
// if IsOk ( sol ) then
3627: LD_VAR 0 1
3631: PPUSH
3632: CALL_OW 302
3636: IFFALSE 3656
// begin sol2 := others diff sol ;
3638: LD_ADDR_VAR 0 2
3642: PUSH
3643: LD_EXP 26
3647: PUSH
3648: LD_VAR 0 1
3652: DIFF
3653: ST_TO_ADDR
// end else
3654: GO 3658
// exit ;
3656: GO 4158
// if not Lisa and not sol2 then
3658: LD_EXP 22
3662: NOT
3663: PUSH
3664: LD_VAR 0 2
3668: NOT
3669: AND
3670: IFFALSE 3674
// exit ;
3672: GO 4158
// DialogueOn ;
3674: CALL_OW 6
// if Lisa then
3678: LD_EXP 22
3682: IFFALSE 3698
// Say ( Lisa , D5a-Lisa-1 ) else
3684: LD_EXP 22
3688: PPUSH
3689: LD_STRING D5a-Lisa-1
3691: PPUSH
3692: CALL_OW 88
3696: GO 3773
// if sol2 then
3698: LD_VAR 0 2
3702: IFFALSE 3773
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3704: LD_VAR 0 2
3708: PUSH
3709: LD_INT 1
3711: ARRAY
3712: PPUSH
3713: CALL_OW 258
3717: PUSH
3718: LD_INT 1
3720: DOUBLE
3721: EQUAL
3722: IFTRUE 3726
3724: GO 3745
3726: POP
// Say ( sol2 [ 1 ] , D5-Sol2-1 ) ; sex_female :
3727: LD_VAR 0 2
3731: PUSH
3732: LD_INT 1
3734: ARRAY
3735: PPUSH
3736: LD_STRING D5-Sol2-1
3738: PPUSH
3739: CALL_OW 88
3743: GO 3773
3745: LD_INT 2
3747: DOUBLE
3748: EQUAL
3749: IFTRUE 3753
3751: GO 3772
3753: POP
// Say ( sol2 [ 1 ] , D5-FSol2-1 ) ; end ;
3754: LD_VAR 0 2
3758: PUSH
3759: LD_INT 1
3761: ARRAY
3762: PPUSH
3763: LD_STRING D5-FSol2-1
3765: PPUSH
3766: CALL_OW 88
3770: GO 3773
3772: POP
// Say ( sol , D5-Sol1-2 ) ;
3773: LD_VAR 0 1
3777: PPUSH
3778: LD_STRING D5-Sol1-2
3780: PPUSH
3781: CALL_OW 88
// if Lisa then
3785: LD_EXP 22
3789: IFFALSE 3805
// Say ( Lisa , D5a-Lisa-2 ) else
3791: LD_EXP 22
3795: PPUSH
3796: LD_STRING D5a-Lisa-2
3798: PPUSH
3799: CALL_OW 88
3803: GO 3880
// if sol2 then
3805: LD_VAR 0 2
3809: IFFALSE 3880
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3811: LD_VAR 0 2
3815: PUSH
3816: LD_INT 1
3818: ARRAY
3819: PPUSH
3820: CALL_OW 258
3824: PUSH
3825: LD_INT 1
3827: DOUBLE
3828: EQUAL
3829: IFTRUE 3833
3831: GO 3852
3833: POP
// Say ( sol2 [ 1 ] , D5-Sol2-2 ) ; sex_female :
3834: LD_VAR 0 2
3838: PUSH
3839: LD_INT 1
3841: ARRAY
3842: PPUSH
3843: LD_STRING D5-Sol2-2
3845: PPUSH
3846: CALL_OW 88
3850: GO 3880
3852: LD_INT 2
3854: DOUBLE
3855: EQUAL
3856: IFTRUE 3860
3858: GO 3879
3860: POP
// Say ( sol2 [ 1 ] , D5-FSol2-2 ) ; end ;
3861: LD_VAR 0 2
3865: PUSH
3866: LD_INT 1
3868: ARRAY
3869: PPUSH
3870: LD_STRING D5-FSol2-2
3872: PPUSH
3873: CALL_OW 88
3877: GO 3880
3879: POP
// Say ( sol , D5a-Sol1-3 ) ;
3880: LD_VAR 0 1
3884: PPUSH
3885: LD_STRING D5a-Sol1-3
3887: PPUSH
3888: CALL_OW 88
// if Lisa then
3892: LD_EXP 22
3896: IFFALSE 3910
// Say ( Lisa , D5a-Lisa-3 ) ;
3898: LD_EXP 22
3902: PPUSH
3903: LD_STRING D5a-Lisa-3
3905: PPUSH
3906: CALL_OW 88
// if not sol2 then
3910: LD_VAR 0 2
3914: NOT
3915: IFFALSE 3923
// begin DialogueOff ;
3917: CALL_OW 7
// exit ;
3921: GO 4158
// end ; case GetSex ( sol2 [ 1 ] ) of sex_male :
3923: LD_VAR 0 2
3927: PUSH
3928: LD_INT 1
3930: ARRAY
3931: PPUSH
3932: CALL_OW 258
3936: PUSH
3937: LD_INT 1
3939: DOUBLE
3940: EQUAL
3941: IFTRUE 3945
3943: GO 3964
3945: POP
// Say ( sol2 [ 1 ] , D5-Sol2-3 ) ; sex_female :
3946: LD_VAR 0 2
3950: PUSH
3951: LD_INT 1
3953: ARRAY
3954: PPUSH
3955: LD_STRING D5-Sol2-3
3957: PPUSH
3958: CALL_OW 88
3962: GO 3992
3964: LD_INT 2
3966: DOUBLE
3967: EQUAL
3968: IFTRUE 3972
3970: GO 3991
3972: POP
// Say ( sol2 [ 1 ] , D5-FSol2-3 ) ; end ;
3973: LD_VAR 0 2
3977: PUSH
3978: LD_INT 1
3980: ARRAY
3981: PPUSH
3982: LD_STRING D5-FSol2-3
3984: PPUSH
3985: CALL_OW 88
3989: GO 3992
3991: POP
// Say ( sol , D5-Sol1-4 ) ;
3992: LD_VAR 0 1
3996: PPUSH
3997: LD_STRING D5-Sol1-4
3999: PPUSH
4000: CALL_OW 88
// case GetSex ( sol2 [ 1 ] ) of sex_male :
4004: LD_VAR 0 2
4008: PUSH
4009: LD_INT 1
4011: ARRAY
4012: PPUSH
4013: CALL_OW 258
4017: PUSH
4018: LD_INT 1
4020: DOUBLE
4021: EQUAL
4022: IFTRUE 4026
4024: GO 4045
4026: POP
// Say ( sol2 [ 1 ] , D5-Sol2-4 ) ; sex_female :
4027: LD_VAR 0 2
4031: PUSH
4032: LD_INT 1
4034: ARRAY
4035: PPUSH
4036: LD_STRING D5-Sol2-4
4038: PPUSH
4039: CALL_OW 88
4043: GO 4073
4045: LD_INT 2
4047: DOUBLE
4048: EQUAL
4049: IFTRUE 4053
4051: GO 4072
4053: POP
// Say ( sol2 [ 1 ] , D5-FSol2-4 ) ; end ;
4054: LD_VAR 0 2
4058: PUSH
4059: LD_INT 1
4061: ARRAY
4062: PPUSH
4063: LD_STRING D5-FSol2-4
4065: PPUSH
4066: CALL_OW 88
4070: GO 4073
4072: POP
// Say ( sol , D5-Sol1-5 ) ;
4073: LD_VAR 0 1
4077: PPUSH
4078: LD_STRING D5-Sol1-5
4080: PPUSH
4081: CALL_OW 88
// case GetSex ( sol2 [ 1 ] ) of sex_male :
4085: LD_VAR 0 2
4089: PUSH
4090: LD_INT 1
4092: ARRAY
4093: PPUSH
4094: CALL_OW 258
4098: PUSH
4099: LD_INT 1
4101: DOUBLE
4102: EQUAL
4103: IFTRUE 4107
4105: GO 4126
4107: POP
// Say ( sol2 [ 1 ] , D5-Sol2-5 ) ; sex_female :
4108: LD_VAR 0 2
4112: PUSH
4113: LD_INT 1
4115: ARRAY
4116: PPUSH
4117: LD_STRING D5-Sol2-5
4119: PPUSH
4120: CALL_OW 88
4124: GO 4154
4126: LD_INT 2
4128: DOUBLE
4129: EQUAL
4130: IFTRUE 4134
4132: GO 4153
4134: POP
// Say ( sol2 [ 1 ] , D5-FSol2-5 ) ; end ;
4135: LD_VAR 0 2
4139: PUSH
4140: LD_INT 1
4142: ARRAY
4143: PPUSH
4144: LD_STRING D5-FSol2-5
4146: PPUSH
4147: CALL_OW 88
4151: GO 4154
4153: POP
// DialogueOff ;
4154: CALL_OW 7
// end ;
4158: PPOPN 2
4160: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) >= 5 do
4161: LD_INT 22
4163: PUSH
4164: LD_INT 1
4166: PUSH
4167: EMPTY
4168: LIST
4169: LIST
4170: PUSH
4171: LD_INT 25
4173: PUSH
4174: LD_INT 16
4176: PUSH
4177: EMPTY
4178: LIST
4179: LIST
4180: PUSH
4181: EMPTY
4182: LIST
4183: LIST
4184: PPUSH
4185: CALL_OW 69
4189: PUSH
4190: LD_INT 5
4192: GREATEREQUAL
4193: IFFALSE 4213
4195: GO 4197
4197: DISABLE
// begin ChangeMissionObjectives ( M1b ) ;
4198: LD_STRING M1b
4200: PPUSH
4201: CALL_OW 337
// apeman_army := true ;
4205: LD_ADDR_EXP 9
4209: PUSH
4210: LD_INT 1
4212: ST_TO_ADDR
// end ;
4213: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_factory ] , [ f_constructed ] ] ) do
4214: LD_INT 22
4216: PUSH
4217: LD_INT 1
4219: PUSH
4220: EMPTY
4221: LIST
4222: LIST
4223: PUSH
4224: LD_INT 30
4226: PUSH
4227: LD_INT 3
4229: PUSH
4230: EMPTY
4231: LIST
4232: LIST
4233: PUSH
4234: LD_INT 57
4236: PUSH
4237: EMPTY
4238: LIST
4239: PUSH
4240: EMPTY
4241: LIST
4242: LIST
4243: LIST
4244: PPUSH
4245: CALL_OW 69
4249: IFFALSE 4261
4251: GO 4253
4253: DISABLE
// ChangeMissionObjectives ( M1c ) ;
4254: LD_STRING M1c
4256: PPUSH
4257: CALL_OW 337
4261: END
// every 0 0$1 trigger GetTech ( tech_radar , 1 ) = state_researched do
4262: LD_INT 6
4264: PPUSH
4265: LD_INT 1
4267: PPUSH
4268: CALL_OW 321
4272: PUSH
4273: LD_INT 2
4275: EQUAL
4276: IFFALSE 4296
4278: GO 4280
4280: DISABLE
// begin ChangeMissionObjectives ( M2a ) ;
4281: LD_STRING M2a
4283: PPUSH
4284: CALL_OW 337
// radar_researched := true ;
4288: LD_ADDR_EXP 10
4292: PUSH
4293: LD_INT 1
4295: ST_TO_ADDR
// end ;
4296: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_weapon , us_radar ] , [ f_bweapon , us_radar ] ] ] ) do
4297: LD_INT 22
4299: PUSH
4300: LD_INT 1
4302: PUSH
4303: EMPTY
4304: LIST
4305: LIST
4306: PUSH
4307: LD_INT 2
4309: PUSH
4310: LD_INT 34
4312: PUSH
4313: LD_INT 11
4315: PUSH
4316: EMPTY
4317: LIST
4318: LIST
4319: PUSH
4320: LD_INT 35
4322: PUSH
4323: LD_INT 11
4325: PUSH
4326: EMPTY
4327: LIST
4328: LIST
4329: PUSH
4330: EMPTY
4331: LIST
4332: LIST
4333: LIST
4334: PUSH
4335: EMPTY
4336: LIST
4337: LIST
4338: PPUSH
4339: CALL_OW 69
4343: IFFALSE 4363
4345: GO 4347
4347: DISABLE
// begin ChangeMissionObjectives ( M2b ) ;
4348: LD_STRING M2b
4350: PPUSH
4351: CALL_OW 337
// radar_builded := true ;
4355: LD_ADDR_EXP 11
4359: PUSH
4360: LD_INT 1
4362: ST_TO_ADDR
// end ;
4363: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) = 0 and not first_apeman_tamed do
4364: LD_INT 22
4366: PUSH
4367: LD_INT 0
4369: PUSH
4370: EMPTY
4371: LIST
4372: LIST
4373: PUSH
4374: LD_INT 25
4376: PUSH
4377: LD_INT 12
4379: PUSH
4380: EMPTY
4381: LIST
4382: LIST
4383: PUSH
4384: EMPTY
4385: LIST
4386: LIST
4387: PPUSH
4388: CALL_OW 69
4392: PUSH
4393: LD_INT 0
4395: EQUAL
4396: PUSH
4397: LD_EXP 8
4401: NOT
4402: AND
4403: IFFALSE 4415
4405: GO 4407
4407: DISABLE
// YouLost ( Apeman ) ;
4408: LD_STRING Apeman
4410: PPUSH
4411: CALL_OW 104
4415: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) >= 7 do var i , filter ;
4416: LD_INT 22
4418: PUSH
4419: LD_INT 1
4421: PUSH
4422: EMPTY
4423: LIST
4424: LIST
4425: PUSH
4426: LD_INT 25
4428: PUSH
4429: LD_INT 16
4431: PUSH
4432: EMPTY
4433: LIST
4434: LIST
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: PPUSH
4440: CALL_OW 69
4444: PUSH
4445: LD_INT 7
4447: GREATEREQUAL
4448: IFFALSE 4546
4450: GO 4452
4452: DISABLE
4453: LD_INT 0
4455: PPUSH
4456: PPUSH
// begin filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , 4 ] ] ) ^ JMM ;
4457: LD_ADDR_VAR 0 2
4461: PUSH
4462: LD_INT 22
4464: PUSH
4465: LD_INT 1
4467: PUSH
4468: EMPTY
4469: LIST
4470: LIST
4471: PUSH
4472: LD_INT 21
4474: PUSH
4475: LD_INT 1
4477: PUSH
4478: EMPTY
4479: LIST
4480: LIST
4481: PUSH
4482: LD_INT 25
4484: PUSH
4485: LD_INT 4
4487: PUSH
4488: EMPTY
4489: LIST
4490: LIST
4491: PUSH
4492: EMPTY
4493: LIST
4494: LIST
4495: LIST
4496: PPUSH
4497: CALL_OW 69
4501: PUSH
4502: LD_EXP 16
4506: ADD
4507: ST_TO_ADDR
// if filter then
4508: LD_VAR 0 2
4512: IFFALSE 4546
// for i in filter do
4514: LD_ADDR_VAR 0 1
4518: PUSH
4519: LD_VAR 0 2
4523: PUSH
4524: FOR_IN
4525: IFFALSE 4544
// AddExperience ( i , 4 , 3500 ) ;
4527: LD_VAR 0 1
4531: PPUSH
4532: LD_INT 4
4534: PPUSH
4535: LD_INT 3500
4537: PPUSH
4538: CALL_OW 492
4542: GO 4524
4544: POP
4545: POP
// end ;
4546: PPOPN 2
4548: END
// every 0 0$1 trigger end_mission do var i , tmp , m1 , m2 , m3 ;
4549: LD_EXP 14
4553: IFFALSE 5687
4555: GO 4557
4557: DISABLE
4558: LD_INT 0
4560: PPUSH
4561: PPUSH
4562: PPUSH
4563: PPUSH
4564: PPUSH
// begin if apeKillCounter = 0 then
4565: LD_EXP 15
4569: PUSH
4570: LD_INT 0
4572: EQUAL
4573: IFFALSE 4582
// SetAchievement ( ACH_APEKILLER ) ;
4575: LD_STRING ACH_APEKILLER
4577: PPUSH
4578: CALL_OW 543
// if FilterAllUnits ( [ f_side , 2 ] ) then
4582: LD_INT 22
4584: PUSH
4585: LD_INT 2
4587: PUSH
4588: EMPTY
4589: LIST
4590: LIST
4591: PPUSH
4592: CALL_OW 69
4596: IFFALSE 4634
// for i in FilterAllUnits ( [ f_side , 2 ] ) do
4598: LD_ADDR_VAR 0 1
4602: PUSH
4603: LD_INT 22
4605: PUSH
4606: LD_INT 2
4608: PUSH
4609: EMPTY
4610: LIST
4611: LIST
4612: PPUSH
4613: CALL_OW 69
4617: PUSH
4618: FOR_IN
4619: IFFALSE 4632
// RemoveUnit ( i ) ;
4621: LD_VAR 0 1
4625: PPUSH
4626: CALL_OW 64
4630: GO 4618
4632: POP
4633: POP
// m1 := false ;
4634: LD_ADDR_VAR 0 3
4638: PUSH
4639: LD_INT 0
4641: ST_TO_ADDR
// m2 := false ;
4642: LD_ADDR_VAR 0 4
4646: PUSH
4647: LD_INT 0
4649: ST_TO_ADDR
// m3 := false ;
4650: LD_ADDR_VAR 0 5
4654: PUSH
4655: LD_INT 0
4657: ST_TO_ADDR
// if apeman_army then
4658: LD_EXP 9
4662: IFFALSE 4684
// begin AddMedal ( Tame , 1 ) ;
4664: LD_STRING Tame
4666: PPUSH
4667: LD_INT 1
4669: PPUSH
4670: CALL_OW 101
// m1 := true ;
4674: LD_ADDR_VAR 0 3
4678: PUSH
4679: LD_INT 1
4681: ST_TO_ADDR
// end else
4682: GO 4695
// AddMedal ( Tame , - 1 ) ;
4684: LD_STRING Tame
4686: PPUSH
4687: LD_INT 1
4689: NEG
4690: PPUSH
4691: CALL_OW 101
// if radar_researched then
4695: LD_EXP 10
4699: IFFALSE 4731
// begin SaveVariable ( true , radarResInDelta ) ;
4701: LD_INT 1
4703: PPUSH
4704: LD_STRING radarResInDelta
4706: PPUSH
4707: CALL_OW 39
// AddMedal ( Radar , 1 ) ;
4711: LD_STRING Radar
4713: PPUSH
4714: LD_INT 1
4716: PPUSH
4717: CALL_OW 101
// m2 := true ;
4721: LD_ADDR_VAR 0 4
4725: PUSH
4726: LD_INT 1
4728: ST_TO_ADDR
// end else
4729: GO 4761
// if radar_allowed then
4731: LD_EXP 7
4735: IFFALSE 4750
// AddMedal ( Radar , - 2 ) else
4737: LD_STRING Radar
4739: PPUSH
4740: LD_INT 2
4742: NEG
4743: PPUSH
4744: CALL_OW 101
4748: GO 4761
// AddMedal ( Radar , - 1 ) ;
4750: LD_STRING Radar
4752: PPUSH
4753: LD_INT 1
4755: NEG
4756: PPUSH
4757: CALL_OW 101
// if radar_builded then
4761: LD_EXP 11
4765: IFFALSE 4787
// begin AddMedal ( BuildRadar , 1 ) ;
4767: LD_STRING BuildRadar
4769: PPUSH
4770: LD_INT 1
4772: PPUSH
4773: CALL_OW 101
// m3 := true ;
4777: LD_ADDR_VAR 0 5
4781: PUSH
4782: LD_INT 1
4784: ST_TO_ADDR
// end else
4785: GO 4798
// AddMedal ( BuildRadar , - 1 ) ;
4787: LD_STRING BuildRadar
4789: PPUSH
4790: LD_INT 1
4792: NEG
4793: PPUSH
4794: CALL_OW 101
// if tick <= 7 7$00 then
4798: LD_OWVAR 1
4802: PUSH
4803: LD_INT 14700
4805: LESSEQUAL
4806: IFFALSE 4815
// SetAchievement ( ACH_ASPEED_5 ) ;
4808: LD_STRING ACH_ASPEED_5
4810: PPUSH
4811: CALL_OW 543
// if m1 and m2 and m3 and Difficulty = 3 then
4815: LD_VAR 0 3
4819: PUSH
4820: LD_VAR 0 4
4824: AND
4825: PUSH
4826: LD_VAR 0 5
4830: AND
4831: PUSH
4832: LD_OWVAR 67
4836: PUSH
4837: LD_INT 3
4839: EQUAL
4840: AND
4841: IFFALSE 4853
// SetAchievementEX ( ACH_AMER , 5 ) ;
4843: LD_STRING ACH_AMER
4845: PPUSH
4846: LD_INT 5
4848: PPUSH
4849: CALL_OW 564
// GiveMedals ( MAIN ) ;
4853: LD_STRING MAIN
4855: PPUSH
4856: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
4860: LD_ADDR_VAR 0 2
4864: PUSH
4865: LD_INT 22
4867: PUSH
4868: LD_INT 1
4870: PUSH
4871: EMPTY
4872: LIST
4873: LIST
4874: PUSH
4875: LD_INT 21
4877: PUSH
4878: LD_INT 1
4880: PUSH
4881: EMPTY
4882: LIST
4883: LIST
4884: PUSH
4885: LD_INT 2
4887: PUSH
4888: LD_INT 25
4890: PUSH
4891: LD_INT 1
4893: PUSH
4894: EMPTY
4895: LIST
4896: LIST
4897: PUSH
4898: LD_INT 25
4900: PUSH
4901: LD_INT 2
4903: PUSH
4904: EMPTY
4905: LIST
4906: LIST
4907: PUSH
4908: LD_INT 25
4910: PUSH
4911: LD_INT 3
4913: PUSH
4914: EMPTY
4915: LIST
4916: LIST
4917: PUSH
4918: LD_INT 25
4920: PUSH
4921: LD_INT 4
4923: PUSH
4924: EMPTY
4925: LIST
4926: LIST
4927: PUSH
4928: EMPTY
4929: LIST
4930: LIST
4931: LIST
4932: LIST
4933: LIST
4934: PUSH
4935: EMPTY
4936: LIST
4937: LIST
4938: LIST
4939: PPUSH
4940: CALL_OW 69
4944: ST_TO_ADDR
// RewardPeople ( tmp ) ;
4945: LD_VAR 0 2
4949: PPUSH
4950: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
4954: LD_EXP 16
4958: PPUSH
4959: LD_EXP 2
4963: PUSH
4964: LD_STRING JMM
4966: STR
4967: PPUSH
4968: CALL_OW 38
// if IsOk ( Gladstone ) then
4972: LD_EXP 17
4976: PPUSH
4977: CALL_OW 302
4981: IFFALSE 5001
// begin SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
4983: LD_EXP 17
4987: PPUSH
4988: LD_EXP 2
4992: PUSH
4993: LD_STRING Gladstone
4995: STR
4996: PPUSH
4997: CALL_OW 38
// end ; if IsOk ( Denis ) and GetSide ( Denis ) = 1 then
5001: LD_EXP 19
5005: PPUSH
5006: CALL_OW 302
5010: PUSH
5011: LD_EXP 19
5015: PPUSH
5016: CALL_OW 255
5020: PUSH
5021: LD_INT 1
5023: EQUAL
5024: AND
5025: IFFALSE 5055
// begin SaveCharacters ( Denis , mission_prefix & Denis ) ;
5027: LD_EXP 19
5031: PPUSH
5032: LD_EXP 2
5036: PUSH
5037: LD_STRING Denis
5039: STR
5040: PPUSH
5041: CALL_OW 38
// SaveVariable ( true , DenisInDelta ) ;
5045: LD_INT 1
5047: PPUSH
5048: LD_STRING DenisInDelta
5050: PPUSH
5051: CALL_OW 39
// end ; if IsOk ( Lisa ) then
5055: LD_EXP 22
5059: PPUSH
5060: CALL_OW 302
5064: IFFALSE 5084
// begin SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
5066: LD_EXP 22
5070: PPUSH
5071: LD_EXP 2
5075: PUSH
5076: LD_STRING Lisa
5078: STR
5079: PPUSH
5080: CALL_OW 38
// end ; if IsOk ( Frank ) then
5084: LD_EXP 23
5088: PPUSH
5089: CALL_OW 302
5093: IFFALSE 5113
// begin SaveCharacters ( Frank , mission_prefix & Frank ) ;
5095: LD_EXP 23
5099: PPUSH
5100: LD_EXP 2
5104: PUSH
5105: LD_STRING Frank
5107: STR
5108: PPUSH
5109: CALL_OW 38
// end ; if IsOk ( Bobby ) then
5113: LD_EXP 24
5117: PPUSH
5118: CALL_OW 302
5122: IFFALSE 5142
// begin SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
5124: LD_EXP 24
5128: PPUSH
5129: LD_EXP 2
5133: PUSH
5134: LD_STRING Bobby
5136: STR
5137: PPUSH
5138: CALL_OW 38
// end ; if IsOk ( Cyrus ) then
5142: LD_EXP 25
5146: PPUSH
5147: CALL_OW 302
5151: IFFALSE 5171
// begin SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
5153: LD_EXP 25
5157: PPUSH
5158: LD_EXP 2
5162: PUSH
5163: LD_STRING Cyrus
5165: STR
5166: PPUSH
5167: CALL_OW 38
// end ; if IsOk ( Brown ) then
5171: LD_EXP 20
5175: PPUSH
5176: CALL_OW 302
5180: IFFALSE 5200
// begin SaveCharacters ( Brown , mission_prefix & Brown ) ;
5182: LD_EXP 20
5186: PPUSH
5187: LD_EXP 2
5191: PUSH
5192: LD_STRING Brown
5194: STR
5195: PPUSH
5196: CALL_OW 38
// end ; if IsOk ( Donaldson ) then
5200: LD_EXP 21
5204: PPUSH
5205: CALL_OW 302
5209: IFFALSE 5229
// begin SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
5211: LD_EXP 21
5215: PPUSH
5216: LD_EXP 2
5220: PUSH
5221: LD_STRING Donaldson
5223: STR
5224: PPUSH
5225: CALL_OW 38
// end ; if others then
5229: LD_EXP 26
5233: IFFALSE 5247
// SaveCharacters ( others , othersInDelta ) ;
5235: LD_EXP 26
5239: PPUSH
5240: LD_STRING othersInDelta
5242: PPUSH
5243: CALL_OW 38
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) then
5247: LD_INT 22
5249: PUSH
5250: LD_INT 1
5252: PUSH
5253: EMPTY
5254: LIST
5255: LIST
5256: PUSH
5257: LD_INT 25
5259: PUSH
5260: LD_INT 16
5262: PUSH
5263: EMPTY
5264: LIST
5265: LIST
5266: PUSH
5267: EMPTY
5268: LIST
5269: LIST
5270: PPUSH
5271: CALL_OW 69
5275: IFFALSE 5313
// SaveCharacters ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) , apeInDelta ) ;
5277: LD_INT 22
5279: PUSH
5280: LD_INT 1
5282: PUSH
5283: EMPTY
5284: LIST
5285: LIST
5286: PUSH
5287: LD_INT 25
5289: PUSH
5290: LD_INT 16
5292: PUSH
5293: EMPTY
5294: LIST
5295: LIST
5296: PUSH
5297: EMPTY
5298: LIST
5299: LIST
5300: PPUSH
5301: CALL_OW 69
5305: PPUSH
5306: LD_STRING apeInDelta
5308: PPUSH
5309: CALL_OW 38
// tmp := [ ] ;
5313: LD_ADDR_VAR 0 2
5317: PUSH
5318: EMPTY
5319: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) then
5320: LD_INT 22
5322: PUSH
5323: LD_INT 1
5325: PUSH
5326: EMPTY
5327: LIST
5328: LIST
5329: PUSH
5330: LD_INT 21
5332: PUSH
5333: LD_INT 2
5335: PUSH
5336: EMPTY
5337: LIST
5338: LIST
5339: PUSH
5340: EMPTY
5341: LIST
5342: LIST
5343: PPUSH
5344: CALL_OW 69
5348: IFFALSE 5459
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) do
5350: LD_ADDR_VAR 0 1
5354: PUSH
5355: LD_INT 22
5357: PUSH
5358: LD_INT 1
5360: PUSH
5361: EMPTY
5362: LIST
5363: LIST
5364: PUSH
5365: LD_INT 21
5367: PUSH
5368: LD_INT 2
5370: PUSH
5371: EMPTY
5372: LIST
5373: LIST
5374: PUSH
5375: EMPTY
5376: LIST
5377: LIST
5378: PPUSH
5379: CALL_OW 69
5383: PUSH
5384: FOR_IN
5385: IFFALSE 5457
// tmp := tmp ^ [ GetNation ( i ) , GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) ] ;
5387: LD_ADDR_VAR 0 2
5391: PUSH
5392: LD_VAR 0 2
5396: PUSH
5397: LD_VAR 0 1
5401: PPUSH
5402: CALL_OW 248
5406: PUSH
5407: LD_VAR 0 1
5411: PPUSH
5412: CALL_OW 265
5416: PUSH
5417: LD_VAR 0 1
5421: PPUSH
5422: CALL_OW 262
5426: PUSH
5427: LD_VAR 0 1
5431: PPUSH
5432: CALL_OW 263
5436: PUSH
5437: LD_VAR 0 1
5441: PPUSH
5442: CALL_OW 264
5446: PUSH
5447: EMPTY
5448: LIST
5449: LIST
5450: LIST
5451: LIST
5452: LIST
5453: ADD
5454: ST_TO_ADDR
5455: GO 5384
5457: POP
5458: POP
// if tmp then
5459: LD_VAR 0 2
5463: IFFALSE 5477
// SaveVariable ( tmp , vehiclesInDelta ) ;
5465: LD_VAR 0 2
5469: PPUSH
5470: LD_STRING vehiclesInDelta
5472: PPUSH
5473: CALL_OW 39
// tmp := [ ] ;
5477: LD_ADDR_VAR 0 2
5481: PUSH
5482: EMPTY
5483: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) then
5484: LD_INT 22
5486: PUSH
5487: LD_INT 1
5489: PUSH
5490: EMPTY
5491: LIST
5492: LIST
5493: PUSH
5494: LD_INT 21
5496: PUSH
5497: LD_INT 3
5499: PUSH
5500: EMPTY
5501: LIST
5502: LIST
5503: PUSH
5504: EMPTY
5505: LIST
5506: LIST
5507: PPUSH
5508: CALL_OW 69
5512: IFFALSE 5665
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
5514: LD_ADDR_VAR 0 1
5518: PUSH
5519: LD_INT 22
5521: PUSH
5522: LD_INT 1
5524: PUSH
5525: EMPTY
5526: LIST
5527: LIST
5528: PUSH
5529: LD_INT 21
5531: PUSH
5532: LD_INT 3
5534: PUSH
5535: EMPTY
5536: LIST
5537: LIST
5538: PUSH
5539: EMPTY
5540: LIST
5541: LIST
5542: PPUSH
5543: CALL_OW 69
5547: PUSH
5548: FOR_IN
5549: IFFALSE 5663
// tmp := tmp ^ [ [ GetBType ( i ) , GetBLevel ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
5551: LD_ADDR_VAR 0 2
5555: PUSH
5556: LD_VAR 0 2
5560: PUSH
5561: LD_VAR 0 1
5565: PPUSH
5566: CALL_OW 266
5570: PUSH
5571: LD_VAR 0 1
5575: PPUSH
5576: CALL_OW 267
5580: PUSH
5581: LD_VAR 0 1
5585: PPUSH
5586: CALL_OW 250
5590: PUSH
5591: LD_VAR 0 1
5595: PPUSH
5596: CALL_OW 251
5600: PUSH
5601: LD_VAR 0 1
5605: PPUSH
5606: CALL_OW 254
5610: PUSH
5611: LD_VAR 0 1
5615: PPUSH
5616: LD_INT 1
5618: PPUSH
5619: CALL_OW 268
5623: PUSH
5624: LD_VAR 0 1
5628: PPUSH
5629: LD_INT 2
5631: PPUSH
5632: CALL_OW 268
5636: PUSH
5637: LD_VAR 0 1
5641: PPUSH
5642: CALL_OW 269
5646: PUSH
5647: EMPTY
5648: LIST
5649: LIST
5650: LIST
5651: LIST
5652: LIST
5653: LIST
5654: LIST
5655: LIST
5656: PUSH
5657: EMPTY
5658: LIST
5659: ADD
5660: ST_TO_ADDR
5661: GO 5548
5663: POP
5664: POP
// if tmp then
5665: LD_VAR 0 2
5669: IFFALSE 5683
// SaveVariable ( tmp , buildingsInDelta ) ;
5671: LD_VAR 0 2
5675: PPUSH
5676: LD_STRING buildingsInDelta
5678: PPUSH
5679: CALL_OW 39
// YouWin ;
5683: CALL_OW 103
// end ; end_of_file
5687: PPOPN 5
5689: END
// export function PrepareArabianTroops ( amount , skill , area ) ; var i , un , tmp ; begin
5690: LD_INT 0
5692: PPUSH
5693: PPUSH
5694: PPUSH
5695: PPUSH
// InitHc ;
5696: CALL_OW 19
// InitUc ;
5700: CALL_OW 18
// uc_side := 2 ;
5704: LD_ADDR_OWVAR 20
5708: PUSH
5709: LD_INT 2
5711: ST_TO_ADDR
// uc_nation := 2 ;
5712: LD_ADDR_OWVAR 21
5716: PUSH
5717: LD_INT 2
5719: ST_TO_ADDR
// if not amount then
5720: LD_VAR 0 1
5724: NOT
5725: IFFALSE 5729
// exit ;
5727: GO 5852
// for i = 1 to amount do
5729: LD_ADDR_VAR 0 5
5733: PUSH
5734: DOUBLE
5735: LD_INT 1
5737: DEC
5738: ST_TO_ADDR
5739: LD_VAR 0 1
5743: PUSH
5744: FOR_TO
5745: IFFALSE 5840
// begin PrepareHuman ( false , 1 , skill ) ;
5747: LD_INT 0
5749: PPUSH
5750: LD_INT 1
5752: PPUSH
5753: LD_VAR 0 2
5757: PPUSH
5758: CALL_OW 380
// un := CreateHuman ;
5762: LD_ADDR_VAR 0 6
5766: PUSH
5767: CALL_OW 44
5771: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
5772: LD_ADDR_VAR 0 7
5776: PUSH
5777: LD_VAR 0 7
5781: PPUSH
5782: LD_INT 1
5784: PPUSH
5785: LD_VAR 0 6
5789: PPUSH
5790: CALL_OW 2
5794: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5795: LD_VAR 0 6
5799: PPUSH
5800: LD_VAR 0 3
5804: PPUSH
5805: LD_INT 0
5807: PPUSH
5808: CALL_OW 49
// if i mod 2 = 0 then
5812: LD_VAR 0 5
5816: PUSH
5817: LD_INT 2
5819: MOD
5820: PUSH
5821: LD_INT 0
5823: EQUAL
5824: IFFALSE 5838
// SetTag ( un , 11 ) ;
5826: LD_VAR 0 6
5830: PPUSH
5831: LD_INT 11
5833: PPUSH
5834: CALL_OW 109
// end ;
5838: GO 5744
5840: POP
5841: POP
// result := tmp ;
5842: LD_ADDR_VAR 0 4
5846: PUSH
5847: LD_VAR 0 7
5851: ST_TO_ADDR
// end ;
5852: LD_VAR 0 4
5856: RET
// export ar_forces , ap_killers ; every 0 0$1 trigger Delta do var i , timer , more_troops , skill , eng , un , veh , force ;
5857: LD_EXP 6
5861: IFFALSE 6728
5863: GO 5865
5865: DISABLE
5866: LD_INT 0
5868: PPUSH
5869: PPUSH
5870: PPUSH
5871: PPUSH
5872: PPUSH
5873: PPUSH
5874: PPUSH
5875: PPUSH
// begin more_troops := false ;
5876: LD_ADDR_VAR 0 3
5880: PUSH
5881: LD_INT 0
5883: ST_TO_ADDR
// skill := [ 3 , 4 , 5 ] [ Difficulty ] ;
5884: LD_ADDR_VAR 0 4
5888: PUSH
5889: LD_INT 3
5891: PUSH
5892: LD_INT 4
5894: PUSH
5895: LD_INT 5
5897: PUSH
5898: EMPTY
5899: LIST
5900: LIST
5901: LIST
5902: PUSH
5903: LD_OWVAR 67
5907: ARRAY
5908: ST_TO_ADDR
// timer := [ 5 5$00 , 4 4$00 , 3 3$00 ] [ Difficulty ] ;
5909: LD_ADDR_VAR 0 2
5913: PUSH
5914: LD_INT 10500
5916: PUSH
5917: LD_INT 8400
5919: PUSH
5920: LD_INT 6300
5922: PUSH
5923: EMPTY
5924: LIST
5925: LIST
5926: LIST
5927: PUSH
5928: LD_OWVAR 67
5932: ARRAY
5933: ST_TO_ADDR
// force := [ ] ;
5934: LD_ADDR_VAR 0 8
5938: PUSH
5939: EMPTY
5940: ST_TO_ADDR
// ar_forces := [ ] ;
5941: LD_ADDR_EXP 27
5945: PUSH
5946: EMPTY
5947: ST_TO_ADDR
// ap_killers := [ ] ;
5948: LD_ADDR_EXP 28
5952: PUSH
5953: EMPTY
5954: ST_TO_ADDR
// Wait ( timer ) ;
5955: LD_VAR 0 2
5959: PPUSH
5960: CALL_OW 67
// if Denis and GetSide ( Denis ) = 4 then
5964: LD_EXP 19
5968: PUSH
5969: LD_EXP 19
5973: PPUSH
5974: CALL_OW 255
5978: PUSH
5979: LD_INT 4
5981: EQUAL
5982: AND
5983: IFFALSE 5992
// Wait ( 0 0$45 ) ;
5985: LD_INT 1575
5987: PPUSH
5988: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) then
5992: LD_INT 22
5994: PUSH
5995: LD_INT 1
5997: PUSH
5998: EMPTY
5999: LIST
6000: LIST
6001: PUSH
6002: LD_INT 30
6004: PUSH
6005: LD_INT 4
6007: PUSH
6008: EMPTY
6009: LIST
6010: LIST
6011: PUSH
6012: EMPTY
6013: LIST
6014: LIST
6015: PPUSH
6016: CALL_OW 69
6020: IFFALSE 6037
// begin Wait ( 1 1$25 ) ;
6022: LD_INT 2975
6024: PPUSH
6025: CALL_OW 67
// more_troops := true ;
6029: LD_ADDR_VAR 0 3
6033: PUSH
6034: LD_INT 1
6036: ST_TO_ADDR
// end ; if more_troops then
6037: LD_VAR 0 3
6041: IFFALSE 6229
// begin force := PrepareArabianTroops ( [ 4 , 5 , 6 ] [ Difficulty ] , skill , arArea2 ) ;
6043: LD_ADDR_VAR 0 8
6047: PUSH
6048: LD_INT 4
6050: PUSH
6051: LD_INT 5
6053: PUSH
6054: LD_INT 6
6056: PUSH
6057: EMPTY
6058: LIST
6059: LIST
6060: LIST
6061: PUSH
6062: LD_OWVAR 67
6066: ARRAY
6067: PPUSH
6068: LD_VAR 0 4
6072: PPUSH
6073: LD_INT 14
6075: PPUSH
6076: CALL 5690 0 3
6080: ST_TO_ADDR
// veh := PrepareTank ( 2 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_heavy_machine_gun , ru_gatling_gun ] [ Difficulty ] , 90 ) ;
6081: LD_ADDR_VAR 0 7
6085: PUSH
6086: LD_INT 2
6088: PPUSH
6089: LD_INT 3
6091: PPUSH
6092: LD_INT 22
6094: PPUSH
6095: LD_INT 1
6097: PPUSH
6098: LD_INT 1
6100: PPUSH
6101: LD_INT 42
6103: PUSH
6104: LD_INT 42
6106: PUSH
6107: LD_INT 43
6109: PUSH
6110: EMPTY
6111: LIST
6112: LIST
6113: LIST
6114: PUSH
6115: LD_OWVAR 67
6119: ARRAY
6120: PPUSH
6121: LD_INT 90
6123: PPUSH
6124: CALL 490 0 7
6128: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
6129: LD_VAR 0 7
6133: PPUSH
6134: LD_INT 4
6136: PPUSH
6137: CALL_OW 233
// PlaceUnitArea ( veh , arArea1 , false ) ;
6141: LD_VAR 0 7
6145: PPUSH
6146: LD_INT 13
6148: PPUSH
6149: LD_INT 0
6151: PPUSH
6152: CALL_OW 49
// uc_side := 2 ;
6156: LD_ADDR_OWVAR 20
6160: PUSH
6161: LD_INT 2
6163: ST_TO_ADDR
// uc_nation := 2 ;
6164: LD_ADDR_OWVAR 21
6168: PUSH
6169: LD_INT 2
6171: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
6172: LD_INT 0
6174: PPUSH
6175: LD_INT 1
6177: PPUSH
6178: LD_VAR 0 4
6182: PPUSH
6183: CALL_OW 380
// un := CreateHuman ;
6187: LD_ADDR_VAR 0 6
6191: PUSH
6192: CALL_OW 44
6196: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
6197: LD_VAR 0 6
6201: PPUSH
6202: LD_VAR 0 7
6206: PPUSH
6207: CALL_OW 52
// force := force ^ un ;
6211: LD_ADDR_VAR 0 8
6215: PUSH
6216: LD_VAR 0 8
6220: PUSH
6221: LD_VAR 0 6
6225: ADD
6226: ST_TO_ADDR
// end else
6227: GO 6267
// begin force := PrepareArabianTroops ( [ 3 , 4 , 5 ] [ Difficulty ] , skill , arArea2 ) ;
6229: LD_ADDR_VAR 0 8
6233: PUSH
6234: LD_INT 3
6236: PUSH
6237: LD_INT 4
6239: PUSH
6240: LD_INT 5
6242: PUSH
6243: EMPTY
6244: LIST
6245: LIST
6246: LIST
6247: PUSH
6248: LD_OWVAR 67
6252: ARRAY
6253: PPUSH
6254: LD_VAR 0 4
6258: PPUSH
6259: LD_INT 14
6261: PPUSH
6262: CALL 5690 0 3
6266: ST_TO_ADDR
// end ; if force then
6267: LD_VAR 0 8
6271: IFFALSE 6283
// ar_forces := force ;
6273: LD_ADDR_EXP 27
6277: PUSH
6278: LD_VAR 0 8
6282: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
6283: LD_INT 35
6285: PPUSH
6286: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 ;
6290: LD_INT 22
6292: PUSH
6293: LD_INT 2
6295: PUSH
6296: EMPTY
6297: LIST
6298: LIST
6299: PUSH
6300: LD_INT 21
6302: PUSH
6303: LD_INT 1
6305: PUSH
6306: EMPTY
6307: LIST
6308: LIST
6309: PUSH
6310: EMPTY
6311: LIST
6312: LIST
6313: PPUSH
6314: CALL_OW 69
6318: PUSH
6319: LD_INT 0
6321: EQUAL
6322: IFFALSE 6283
// Wait ( timer ) ;
6324: LD_VAR 0 2
6328: PPUSH
6329: CALL_OW 67
// force := PrepareArabianTroops ( [ 4 , 5 , 6 ] [ Difficulty ] , skill , [ arArea1 , arArea2 ] [ rand ( 1 , 2 ) ] ) ;
6333: LD_ADDR_VAR 0 8
6337: PUSH
6338: LD_INT 4
6340: PUSH
6341: LD_INT 5
6343: PUSH
6344: LD_INT 6
6346: PUSH
6347: EMPTY
6348: LIST
6349: LIST
6350: LIST
6351: PUSH
6352: LD_OWVAR 67
6356: ARRAY
6357: PPUSH
6358: LD_VAR 0 4
6362: PPUSH
6363: LD_INT 13
6365: PUSH
6366: LD_INT 14
6368: PUSH
6369: EMPTY
6370: LIST
6371: LIST
6372: PUSH
6373: LD_INT 1
6375: PPUSH
6376: LD_INT 2
6378: PPUSH
6379: CALL_OW 12
6383: ARRAY
6384: PPUSH
6385: CALL 5690 0 3
6389: ST_TO_ADDR
// if Difficulty > 1 and Delta then
6390: LD_OWVAR 67
6394: PUSH
6395: LD_INT 1
6397: GREATER
6398: PUSH
6399: LD_EXP 6
6403: AND
6404: IFFALSE 6483
// begin uc_side := 2 ;
6406: LD_ADDR_OWVAR 20
6410: PUSH
6411: LD_INT 2
6413: ST_TO_ADDR
// uc_nation := 2 ;
6414: LD_ADDR_OWVAR 21
6418: PUSH
6419: LD_INT 2
6421: ST_TO_ADDR
// PrepareHuman ( false , 2 , skill ) ;
6422: LD_INT 0
6424: PPUSH
6425: LD_INT 2
6427: PPUSH
6428: LD_VAR 0 4
6432: PPUSH
6433: CALL_OW 380
// eng := CreateHuman ;
6437: LD_ADDR_VAR 0 5
6441: PUSH
6442: CALL_OW 44
6446: ST_TO_ADDR
// PlaceUnitArea ( eng , arArea1 , false ) ;
6447: LD_VAR 0 5
6451: PPUSH
6452: LD_INT 13
6454: PPUSH
6455: LD_INT 0
6457: PPUSH
6458: CALL_OW 49
// Wait ( 3 ) ;
6462: LD_INT 3
6464: PPUSH
6465: CALL_OW 67
// AddComEnterUnit ( eng , Delta ) ;
6469: LD_VAR 0 5
6473: PPUSH
6474: LD_EXP 6
6478: PPUSH
6479: CALL_OW 180
// end ; if force then
6483: LD_VAR 0 8
6487: IFFALSE 6499
// ar_forces := force ;
6489: LD_ADDR_EXP 27
6493: PUSH
6494: LD_VAR 0 8
6498: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
6499: LD_INT 35
6501: PPUSH
6502: CALL_OW 67
// if eng then
6506: LD_VAR 0 5
6510: IFFALSE 6564
// if GetSide ( Delta ) = 2 and IsOk ( eng ) and not IsInUnit ( eng ) then
6512: LD_EXP 6
6516: PPUSH
6517: CALL_OW 255
6521: PUSH
6522: LD_INT 2
6524: EQUAL
6525: PUSH
6526: LD_VAR 0 5
6530: PPUSH
6531: CALL_OW 302
6535: AND
6536: PUSH
6537: LD_VAR 0 5
6541: PPUSH
6542: CALL_OW 310
6546: NOT
6547: AND
6548: IFFALSE 6564
// ComEnterUnit ( eng , Delta ) ;
6550: LD_VAR 0 5
6554: PPUSH
6555: LD_EXP 6
6559: PPUSH
6560: CALL_OW 120
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 ;
6564: LD_INT 22
6566: PUSH
6567: LD_INT 2
6569: PUSH
6570: EMPTY
6571: LIST
6572: LIST
6573: PUSH
6574: LD_INT 21
6576: PUSH
6577: LD_INT 1
6579: PUSH
6580: EMPTY
6581: LIST
6582: LIST
6583: PUSH
6584: EMPTY
6585: LIST
6586: LIST
6587: PPUSH
6588: CALL_OW 69
6592: PUSH
6593: LD_INT 0
6595: EQUAL
6596: IFFALSE 6499
// Wait ( 2 2$00 ) ;
6598: LD_INT 4200
6600: PPUSH
6601: CALL_OW 67
// ap_killers := PrepareArabianTroops ( [ 1 , 2 , 2 ] [ Difficulty ] , skill , arArea1 ) ;
6605: LD_ADDR_EXP 28
6609: PUSH
6610: LD_INT 1
6612: PUSH
6613: LD_INT 2
6615: PUSH
6616: LD_INT 2
6618: PUSH
6619: EMPTY
6620: LIST
6621: LIST
6622: LIST
6623: PUSH
6624: LD_OWVAR 67
6628: ARRAY
6629: PPUSH
6630: LD_VAR 0 4
6634: PPUSH
6635: LD_INT 13
6637: PPUSH
6638: CALL 5690 0 3
6642: ST_TO_ADDR
// Wait ( timer * 2 ) ;
6643: LD_VAR 0 2
6647: PUSH
6648: LD_INT 2
6650: MUL
6651: PPUSH
6652: CALL_OW 67
// ar_forces := PrepareArabianTroops ( [ 5 , 6 , 7 ] [ Difficulty ] , skill , arArea1 ) ^ PrepareArabianTroops ( [ 3 , 4 , 4 ] [ Difficulty ] , skill , arArea2 ) ;
6656: LD_ADDR_EXP 27
6660: PUSH
6661: LD_INT 5
6663: PUSH
6664: LD_INT 6
6666: PUSH
6667: LD_INT 7
6669: PUSH
6670: EMPTY
6671: LIST
6672: LIST
6673: LIST
6674: PUSH
6675: LD_OWVAR 67
6679: ARRAY
6680: PPUSH
6681: LD_VAR 0 4
6685: PPUSH
6686: LD_INT 13
6688: PPUSH
6689: CALL 5690 0 3
6693: PUSH
6694: LD_INT 3
6696: PUSH
6697: LD_INT 4
6699: PUSH
6700: LD_INT 4
6702: PUSH
6703: EMPTY
6704: LIST
6705: LIST
6706: LIST
6707: PUSH
6708: LD_OWVAR 67
6712: ARRAY
6713: PPUSH
6714: LD_VAR 0 4
6718: PPUSH
6719: LD_INT 14
6721: PPUSH
6722: CALL 5690 0 3
6726: ADD
6727: ST_TO_ADDR
// end ;
6728: PPOPN 8
6730: END
// every 0 0$03 trigger ar_forces do var i , target ;
6731: LD_EXP 27
6735: IFFALSE 6933
6737: GO 6739
6739: DISABLE
6740: LD_INT 0
6742: PPUSH
6743: PPUSH
// begin enable ;
6744: ENABLE
// if not ar_forces then
6745: LD_EXP 27
6749: NOT
6750: IFFALSE 6754
// exit ;
6752: GO 6933
// if Delta then
6754: LD_EXP 6
6758: IFFALSE 6772
// target := Delta else
6760: LD_ADDR_VAR 0 2
6764: PUSH
6765: LD_EXP 6
6769: ST_TO_ADDR
6770: GO 6782
// target := JMM ;
6772: LD_ADDR_VAR 0 2
6776: PUSH
6777: LD_EXP 16
6781: ST_TO_ADDR
// for i in ar_forces do
6782: LD_ADDR_VAR 0 1
6786: PUSH
6787: LD_EXP 27
6791: PUSH
6792: FOR_IN
6793: IFFALSE 6931
// begin if i in FilterAllUnits ( [ f_driving ] ) then
6795: LD_VAR 0 1
6799: PUSH
6800: LD_INT 55
6802: PUSH
6803: EMPTY
6804: LIST
6805: PPUSH
6806: CALL_OW 69
6810: IN
6811: IFFALSE 6854
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , IsInUnit ( i ) ) ) else
6813: LD_VAR 0 1
6817: PPUSH
6818: LD_INT 22
6820: PUSH
6821: LD_INT 1
6823: PUSH
6824: EMPTY
6825: LIST
6826: LIST
6827: PPUSH
6828: CALL_OW 69
6832: PPUSH
6833: LD_VAR 0 1
6837: PPUSH
6838: CALL_OW 310
6842: PPUSH
6843: CALL_OW 74
6847: PPUSH
6848: CALL_OW 115
6852: GO 6929
// if GetDistUnits ( i , target ) > 30 then
6854: LD_VAR 0 1
6858: PPUSH
6859: LD_VAR 0 2
6863: PPUSH
6864: CALL_OW 296
6868: PUSH
6869: LD_INT 30
6871: GREATER
6872: IFFALSE 6905
// ComAgressiveMove ( i , GetX ( target ) , GetY ( target ) ) else
6874: LD_VAR 0 1
6878: PPUSH
6879: LD_VAR 0 2
6883: PPUSH
6884: CALL_OW 250
6888: PPUSH
6889: LD_VAR 0 2
6893: PPUSH
6894: CALL_OW 251
6898: PPUSH
6899: CALL_OW 114
6903: GO 6929
// Attack ( i , FilterAllUnits ( [ f_enemy , 2 ] ) ) ;
6905: LD_VAR 0 1
6909: PPUSH
6910: LD_INT 81
6912: PUSH
6913: LD_INT 2
6915: PUSH
6916: EMPTY
6917: LIST
6918: LIST
6919: PPUSH
6920: CALL_OW 69
6924: PPUSH
6925: CALL 795 0 2
// end ;
6929: GO 6792
6931: POP
6932: POP
// end ;
6933: PPOPN 2
6935: END
// every 0 0$01 trigger ap_killers do var filter , i , target ;
6936: LD_EXP 28
6940: IFFALSE 7100
6942: GO 6944
6944: DISABLE
6945: LD_INT 0
6947: PPUSH
6948: PPUSH
6949: PPUSH
// begin enable ;
6950: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) ;
6951: LD_ADDR_VAR 0 1
6955: PUSH
6956: LD_INT 22
6958: PUSH
6959: LD_INT 0
6961: PUSH
6962: EMPTY
6963: LIST
6964: LIST
6965: PUSH
6966: LD_INT 25
6968: PUSH
6969: LD_INT 12
6971: PUSH
6972: EMPTY
6973: LIST
6974: LIST
6975: PUSH
6976: EMPTY
6977: LIST
6978: LIST
6979: PPUSH
6980: CALL_OW 69
6984: ST_TO_ADDR
// if not filter then
6985: LD_VAR 0 1
6989: NOT
6990: IFFALSE 7017
// begin ar_forces := ar_forces ^ ap_killers ;
6992: LD_ADDR_EXP 27
6996: PUSH
6997: LD_EXP 27
7001: PUSH
7002: LD_EXP 28
7006: ADD
7007: ST_TO_ADDR
// ap_killers := [ ] ;
7008: LD_ADDR_EXP 28
7012: PUSH
7013: EMPTY
7014: ST_TO_ADDR
// exit ;
7015: GO 7100
// end ; for i in ap_killers do
7017: LD_ADDR_VAR 0 2
7021: PUSH
7022: LD_EXP 28
7026: PUSH
7027: FOR_IN
7028: IFFALSE 7098
// begin if not IsOk ( i ) then
7030: LD_VAR 0 2
7034: PPUSH
7035: CALL_OW 302
7039: NOT
7040: IFFALSE 7044
// continue ;
7042: GO 7027
// if not HasTask ( i ) then
7044: LD_VAR 0 2
7048: PPUSH
7049: CALL_OW 314
7053: NOT
7054: IFFALSE 7076
// target := NearestUnitToUnit ( filter , i ) ;
7056: LD_ADDR_VAR 0 3
7060: PUSH
7061: LD_VAR 0 1
7065: PPUSH
7066: LD_VAR 0 2
7070: PPUSH
7071: CALL_OW 74
7075: ST_TO_ADDR
// if target then
7076: LD_VAR 0 3
7080: IFFALSE 7096
// ComAttackUnit ( i , target ) ;
7082: LD_VAR 0 2
7086: PPUSH
7087: LD_VAR 0 3
7091: PPUSH
7092: CALL_OW 115
// end ;
7096: GO 7027
7098: POP
7099: POP
// end ; end_of_file
7100: PPOPN 3
7102: END
// every 0 0$40 + 0 0$2 trigger Delta do var i , counter , cr ;
7103: LD_EXP 6
7107: IFFALSE 7239
7109: GO 7111
7111: DISABLE
7112: LD_INT 0
7114: PPUSH
7115: PPUSH
7116: PPUSH
// begin counter := [ 300 , 250 , 220 ] [ Difficulty ] ;
7117: LD_ADDR_VAR 0 2
7121: PUSH
7122: LD_INT 300
7124: PUSH
7125: LD_INT 250
7127: PUSH
7128: LD_INT 220
7130: PUSH
7131: EMPTY
7132: LIST
7133: LIST
7134: LIST
7135: PUSH
7136: LD_OWVAR 67
7140: ARRAY
7141: ST_TO_ADDR
// CreateCratesArea ( Rand ( 1 , 3 ) , cratesArea , true ) ;
7142: LD_INT 1
7144: PPUSH
7145: LD_INT 3
7147: PPUSH
7148: CALL_OW 12
7152: PPUSH
7153: LD_INT 7
7155: PPUSH
7156: LD_INT 1
7158: PPUSH
7159: CALL_OW 55
// repeat wait ( rand ( 1 1$30 , 2 2$20 ) ) ;
7163: LD_INT 3150
7165: PPUSH
7166: LD_INT 4900
7168: PPUSH
7169: CALL_OW 12
7173: PPUSH
7174: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
7178: LD_ADDR_VAR 0 3
7182: PUSH
7183: LD_INT 1
7185: PPUSH
7186: LD_INT 5
7188: PPUSH
7189: CALL_OW 12
7193: ST_TO_ADDR
// CreateCratesArea ( cr , cratesArea , true ) ;
7194: LD_VAR 0 3
7198: PPUSH
7199: LD_INT 7
7201: PPUSH
7202: LD_INT 1
7204: PPUSH
7205: CALL_OW 55
// counter := counter - cr * 10 ;
7209: LD_ADDR_VAR 0 2
7213: PUSH
7214: LD_VAR 0 2
7218: PUSH
7219: LD_VAR 0 3
7223: PUSH
7224: LD_INT 10
7226: MUL
7227: MINUS
7228: ST_TO_ADDR
// until counter <= 0 ;
7229: LD_VAR 0 2
7233: PUSH
7234: LD_INT 0
7236: LESSEQUAL
7237: IFFALSE 7163
// end ;
7239: PPOPN 3
7241: END
// every 0 0$03 trigger not Delta do var i ;
7242: LD_EXP 6
7246: NOT
7247: IFFALSE 7317
7249: GO 7251
7251: DISABLE
7252: LD_INT 0
7254: PPUSH
// begin for i = 1 to 4 - Difficulty do
7255: LD_ADDR_VAR 0 1
7259: PUSH
7260: DOUBLE
7261: LD_INT 1
7263: DEC
7264: ST_TO_ADDR
7265: LD_INT 4
7267: PUSH
7268: LD_OWVAR 67
7272: MINUS
7273: PUSH
7274: FOR_TO
7275: IFFALSE 7315
// begin CreateCratesArea ( rand ( 2 , 5 ) , deltaMainArea , true ) ;
7277: LD_INT 2
7279: PPUSH
7280: LD_INT 5
7282: PPUSH
7283: CALL_OW 12
7287: PPUSH
7288: LD_INT 8
7290: PPUSH
7291: LD_INT 1
7293: PPUSH
7294: CALL_OW 55
// Wait ( rand ( 0 0$16 , 0 0$39 ) ) ;
7298: LD_INT 560
7300: PPUSH
7301: LD_INT 1365
7303: PPUSH
7304: CALL_OW 12
7308: PPUSH
7309: CALL_OW 67
// end ;
7313: GO 7274
7315: POP
7316: POP
// end ;
7317: PPOPN 1
7319: END
// every 3 3$00 trigger tick < 15 15$00 do
7320: LD_OWVAR 1
7324: PUSH
7325: LD_INT 31500
7327: LESS
7328: IFFALSE 7388
7330: GO 7332
7332: DISABLE
// begin enable ;
7333: ENABLE
// CreateCratesAnyWhere ( rand ( 1 , 3 ) , true ) ;
7334: LD_INT 1
7336: PPUSH
7337: LD_INT 3
7339: PPUSH
7340: CALL_OW 12
7344: PPUSH
7345: LD_INT 1
7347: PPUSH
7348: CALL_OW 57
// Wait ( rand ( 0 0$38 , 0 0$59 ) ) ;
7352: LD_INT 1330
7354: PPUSH
7355: LD_INT 2065
7357: PPUSH
7358: CALL_OW 12
7362: PPUSH
7363: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 4 ) , riverArea , true ) ;
7367: LD_INT 1
7369: PPUSH
7370: LD_INT 4
7372: PPUSH
7373: CALL_OW 12
7377: PPUSH
7378: LD_INT 15
7380: PPUSH
7381: LD_INT 1
7383: PPUSH
7384: CALL_OW 55
// end ; end_of_file
7388: END
// on UnitDestroyed ( un ) do begin if un = JMM then
7389: LD_VAR 0 1
7393: PUSH
7394: LD_EXP 16
7398: EQUAL
7399: IFFALSE 7408
// YouLost ( JMM ) ;
7401: LD_STRING JMM
7403: PPUSH
7404: CALL_OW 104
// if un = Delta then
7408: LD_VAR 0 1
7412: PUSH
7413: LD_EXP 6
7417: EQUAL
7418: IFFALSE 7441
// begin Delta := 0 ;
7420: LD_ADDR_EXP 6
7424: PUSH
7425: LD_INT 0
7427: ST_TO_ADDR
// SetRestrict ( b_depot , 1 , true ) ;
7428: LD_INT 0
7430: PPUSH
7431: LD_INT 1
7433: PPUSH
7434: LD_INT 1
7436: PPUSH
7437: CALL_OW 324
// end ; if un in ar_forces then
7441: LD_VAR 0 1
7445: PUSH
7446: LD_EXP 27
7450: IN
7451: IFFALSE 7469
// ar_forces := ar_forces diff un ;
7453: LD_ADDR_EXP 27
7457: PUSH
7458: LD_EXP 27
7462: PUSH
7463: LD_VAR 0 1
7467: DIFF
7468: ST_TO_ADDR
// if un in ap_killers then
7469: LD_VAR 0 1
7473: PUSH
7474: LD_EXP 28
7478: IN
7479: IFFALSE 7497
// ap_killers := ap_killers diff un ;
7481: LD_ADDR_EXP 28
7485: PUSH
7486: LD_EXP 28
7490: PUSH
7491: LD_VAR 0 1
7495: DIFF
7496: ST_TO_ADDR
// if un in FilterAllUnits ( [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ) then
7497: LD_VAR 0 1
7501: PUSH
7502: LD_INT 2
7504: PUSH
7505: LD_INT 25
7507: PUSH
7508: LD_INT 12
7510: PUSH
7511: EMPTY
7512: LIST
7513: LIST
7514: PUSH
7515: LD_INT 25
7517: PUSH
7518: LD_INT 16
7520: PUSH
7521: EMPTY
7522: LIST
7523: LIST
7524: PUSH
7525: EMPTY
7526: LIST
7527: LIST
7528: LIST
7529: PPUSH
7530: CALL_OW 69
7534: IN
7535: IFFALSE 7551
// apeKillCounter := apeKillCounter + 1 ;
7537: LD_ADDR_EXP 15
7541: PUSH
7542: LD_EXP 15
7546: PUSH
7547: LD_INT 1
7549: PLUS
7550: ST_TO_ADDR
// end ;
7551: PPOPN 1
7553: END
// on Contact ( s1 , s2 ) do if s1 = 1 and s2 = 2 and not arab_spotted then
7554: LD_VAR 0 1
7558: PUSH
7559: LD_INT 1
7561: EQUAL
7562: PUSH
7563: LD_VAR 0 2
7567: PUSH
7568: LD_INT 2
7570: EQUAL
7571: AND
7572: PUSH
7573: LD_EXP 13
7577: NOT
7578: AND
7579: IFFALSE 7589
// arab_spotted := true ;
7581: LD_ADDR_EXP 13
7585: PUSH
7586: LD_INT 1
7588: ST_TO_ADDR
7589: PPOPN 2
7591: END
// on EndTheMissionRaised ( p ) do begin end_the_mission_allowed := false ;
7592: LD_ADDR_OWVAR 57
7596: PUSH
7597: LD_INT 0
7599: ST_TO_ADDR
// end_mission := true ;
7600: LD_ADDR_EXP 14
7604: PUSH
7605: LD_INT 1
7607: ST_TO_ADDR
// end ;
7608: PPOPN 1
7610: END
// on ApemanTamed ( apeman , sci ) do begin if GetSide ( sci ) = 1 then
7611: LD_VAR 0 2
7615: PPUSH
7616: CALL_OW 255
7620: PUSH
7621: LD_INT 1
7623: EQUAL
7624: IFFALSE 7640
// apeman_counter := apeman_counter + 1 ;
7626: LD_ADDR_EXP 12
7630: PUSH
7631: LD_EXP 12
7635: PUSH
7636: LD_INT 1
7638: PLUS
7639: ST_TO_ADDR
// if not first_apeman_tamed then
7640: LD_EXP 8
7644: NOT
7645: IFFALSE 7845
// begin first_apeman_tamed := true ;
7647: LD_ADDR_EXP 8
7651: PUSH
7652: LD_INT 1
7654: ST_TO_ADDR
// if sci = Gladstone then
7655: LD_VAR 0 2
7659: PUSH
7660: LD_EXP 17
7664: EQUAL
7665: IFFALSE 7679
// Say ( Gladstone , D7b-Glad-1 ) ;
7667: LD_EXP 17
7671: PPUSH
7672: LD_STRING D7b-Glad-1
7674: PPUSH
7675: CALL_OW 88
// if sci = Denis then
7679: LD_VAR 0 2
7683: PUSH
7684: LD_EXP 19
7688: EQUAL
7689: IFFALSE 7703
// Say ( Denis , D7a-Den-1 ) ;
7691: LD_EXP 19
7695: PPUSH
7696: LD_STRING D7a-Den-1
7698: PPUSH
7699: CALL_OW 88
// if not sci in [ JMM , Gladstone , Denis , Lisa , Frank , Bobby , Cyrus , Donaldson ] then
7703: LD_VAR 0 2
7707: PUSH
7708: LD_EXP 16
7712: PUSH
7713: LD_EXP 17
7717: PUSH
7718: LD_EXP 19
7722: PUSH
7723: LD_EXP 22
7727: PUSH
7728: LD_EXP 23
7732: PUSH
7733: LD_EXP 24
7737: PUSH
7738: LD_EXP 25
7742: PUSH
7743: LD_EXP 21
7747: PUSH
7748: EMPTY
7749: LIST
7750: LIST
7751: LIST
7752: LIST
7753: LIST
7754: LIST
7755: LIST
7756: LIST
7757: IN
7758: NOT
7759: IFFALSE 7802
// begin if GetSex ( sci ) = sex_male then
7761: LD_VAR 0 2
7765: PPUSH
7766: CALL_OW 258
7770: PUSH
7771: LD_INT 1
7773: EQUAL
7774: IFFALSE 7790
// Say ( sci , D7c-Sci1-1 ) else
7776: LD_VAR 0 2
7780: PPUSH
7781: LD_STRING D7c-Sci1-1
7783: PPUSH
7784: CALL_OW 88
7788: GO 7802
// Say ( sci , D7c-FSci1-1 ) ;
7790: LD_VAR 0 2
7794: PPUSH
7795: LD_STRING D7c-FSci1-1
7797: PPUSH
7798: CALL_OW 88
// end ; if not sci = Gladstone then
7802: LD_VAR 0 2
7806: PUSH
7807: LD_EXP 17
7811: EQUAL
7812: NOT
7813: IFFALSE 7827
// Say ( Gladstone , D7c-Glad-1 ) ;
7815: LD_EXP 17
7819: PPUSH
7820: LD_STRING D7c-Glad-1
7822: PPUSH
7823: CALL_OW 88
// if Lisa then
7827: LD_EXP 22
7831: IFFALSE 7845
// Say ( Lisa , D8-Lisa-1 ) ;
7833: LD_EXP 22
7837: PPUSH
7838: LD_STRING D8-Lisa-1
7840: PPUSH
7841: CALL_OW 88
// end ; end ; end_of_file
7845: PPOPN 2
7847: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
7848: GO 7850
7850: DISABLE
// begin ru_radar := 98 ;
7851: LD_ADDR_EXP 29
7855: PUSH
7856: LD_INT 98
7858: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
7859: LD_ADDR_EXP 30
7863: PUSH
7864: LD_INT 89
7866: ST_TO_ADDR
// us_hack := 99 ;
7867: LD_ADDR_EXP 31
7871: PUSH
7872: LD_INT 99
7874: ST_TO_ADDR
// us_artillery := 97 ;
7875: LD_ADDR_EXP 32
7879: PUSH
7880: LD_INT 97
7882: ST_TO_ADDR
// ar_bio_bomb := 91 ;
7883: LD_ADDR_EXP 33
7887: PUSH
7888: LD_INT 91
7890: ST_TO_ADDR
// end ; end_of_file end_of_file
7891: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
7892: GO 7894
7894: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
7895: LD_STRING initStreamRollete();
7897: PPUSH
7898: CALL_OW 559
// InitStreamMode ;
7902: CALL 7911 0 0
// DefineStreamItems ( ) ;
7906: CALL 8351 0 0
// end ;
7910: END
// function InitStreamMode ; begin
7911: LD_INT 0
7913: PPUSH
// streamModeActive := false ;
7914: LD_ADDR_EXP 34
7918: PUSH
7919: LD_INT 0
7921: ST_TO_ADDR
// normalCounter := 36 ;
7922: LD_ADDR_EXP 35
7926: PUSH
7927: LD_INT 36
7929: ST_TO_ADDR
// hardcoreCounter := 16 ;
7930: LD_ADDR_EXP 36
7934: PUSH
7935: LD_INT 16
7937: ST_TO_ADDR
// sRocket := false ;
7938: LD_ADDR_EXP 39
7942: PUSH
7943: LD_INT 0
7945: ST_TO_ADDR
// sSpeed := false ;
7946: LD_ADDR_EXP 38
7950: PUSH
7951: LD_INT 0
7953: ST_TO_ADDR
// sEngine := false ;
7954: LD_ADDR_EXP 40
7958: PUSH
7959: LD_INT 0
7961: ST_TO_ADDR
// sSpec := false ;
7962: LD_ADDR_EXP 37
7966: PUSH
7967: LD_INT 0
7969: ST_TO_ADDR
// sLevel := false ;
7970: LD_ADDR_EXP 41
7974: PUSH
7975: LD_INT 0
7977: ST_TO_ADDR
// sArmoury := false ;
7978: LD_ADDR_EXP 42
7982: PUSH
7983: LD_INT 0
7985: ST_TO_ADDR
// sRadar := false ;
7986: LD_ADDR_EXP 43
7990: PUSH
7991: LD_INT 0
7993: ST_TO_ADDR
// sBunker := false ;
7994: LD_ADDR_EXP 44
7998: PUSH
7999: LD_INT 0
8001: ST_TO_ADDR
// sHack := false ;
8002: LD_ADDR_EXP 45
8006: PUSH
8007: LD_INT 0
8009: ST_TO_ADDR
// sFire := false ;
8010: LD_ADDR_EXP 46
8014: PUSH
8015: LD_INT 0
8017: ST_TO_ADDR
// sRefresh := false ;
8018: LD_ADDR_EXP 47
8022: PUSH
8023: LD_INT 0
8025: ST_TO_ADDR
// sExp := false ;
8026: LD_ADDR_EXP 48
8030: PUSH
8031: LD_INT 0
8033: ST_TO_ADDR
// sDepot := false ;
8034: LD_ADDR_EXP 49
8038: PUSH
8039: LD_INT 0
8041: ST_TO_ADDR
// sFlag := false ;
8042: LD_ADDR_EXP 50
8046: PUSH
8047: LD_INT 0
8049: ST_TO_ADDR
// sKamikadze := false ;
8050: LD_ADDR_EXP 58
8054: PUSH
8055: LD_INT 0
8057: ST_TO_ADDR
// sTroll := false ;
8058: LD_ADDR_EXP 59
8062: PUSH
8063: LD_INT 0
8065: ST_TO_ADDR
// sSlow := false ;
8066: LD_ADDR_EXP 60
8070: PUSH
8071: LD_INT 0
8073: ST_TO_ADDR
// sLack := false ;
8074: LD_ADDR_EXP 61
8078: PUSH
8079: LD_INT 0
8081: ST_TO_ADDR
// sTank := false ;
8082: LD_ADDR_EXP 63
8086: PUSH
8087: LD_INT 0
8089: ST_TO_ADDR
// sRemote := false ;
8090: LD_ADDR_EXP 64
8094: PUSH
8095: LD_INT 0
8097: ST_TO_ADDR
// sPowell := false ;
8098: LD_ADDR_EXP 65
8102: PUSH
8103: LD_INT 0
8105: ST_TO_ADDR
// sTeleport := false ;
8106: LD_ADDR_EXP 68
8110: PUSH
8111: LD_INT 0
8113: ST_TO_ADDR
// sOilTower := false ;
8114: LD_ADDR_EXP 70
8118: PUSH
8119: LD_INT 0
8121: ST_TO_ADDR
// sShovel := false ;
8122: LD_ADDR_EXP 71
8126: PUSH
8127: LD_INT 0
8129: ST_TO_ADDR
// sSheik := false ;
8130: LD_ADDR_EXP 72
8134: PUSH
8135: LD_INT 0
8137: ST_TO_ADDR
// sEarthquake := false ;
8138: LD_ADDR_EXP 74
8142: PUSH
8143: LD_INT 0
8145: ST_TO_ADDR
// sAI := false ;
8146: LD_ADDR_EXP 75
8150: PUSH
8151: LD_INT 0
8153: ST_TO_ADDR
// sCargo := false ;
8154: LD_ADDR_EXP 78
8158: PUSH
8159: LD_INT 0
8161: ST_TO_ADDR
// sDLaser := false ;
8162: LD_ADDR_EXP 79
8166: PUSH
8167: LD_INT 0
8169: ST_TO_ADDR
// sExchange := false ;
8170: LD_ADDR_EXP 80
8174: PUSH
8175: LD_INT 0
8177: ST_TO_ADDR
// sFac := false ;
8178: LD_ADDR_EXP 81
8182: PUSH
8183: LD_INT 0
8185: ST_TO_ADDR
// sPower := false ;
8186: LD_ADDR_EXP 82
8190: PUSH
8191: LD_INT 0
8193: ST_TO_ADDR
// sRandom := false ;
8194: LD_ADDR_EXP 83
8198: PUSH
8199: LD_INT 0
8201: ST_TO_ADDR
// sShield := false ;
8202: LD_ADDR_EXP 84
8206: PUSH
8207: LD_INT 0
8209: ST_TO_ADDR
// sTime := false ;
8210: LD_ADDR_EXP 85
8214: PUSH
8215: LD_INT 0
8217: ST_TO_ADDR
// sTools := false ;
8218: LD_ADDR_EXP 86
8222: PUSH
8223: LD_INT 0
8225: ST_TO_ADDR
// sSold := false ;
8226: LD_ADDR_EXP 51
8230: PUSH
8231: LD_INT 0
8233: ST_TO_ADDR
// sDiff := false ;
8234: LD_ADDR_EXP 52
8238: PUSH
8239: LD_INT 0
8241: ST_TO_ADDR
// sFog := false ;
8242: LD_ADDR_EXP 55
8246: PUSH
8247: LD_INT 0
8249: ST_TO_ADDR
// sReset := false ;
8250: LD_ADDR_EXP 56
8254: PUSH
8255: LD_INT 0
8257: ST_TO_ADDR
// sSun := false ;
8258: LD_ADDR_EXP 57
8262: PUSH
8263: LD_INT 0
8265: ST_TO_ADDR
// sTiger := false ;
8266: LD_ADDR_EXP 53
8270: PUSH
8271: LD_INT 0
8273: ST_TO_ADDR
// sBomb := false ;
8274: LD_ADDR_EXP 54
8278: PUSH
8279: LD_INT 0
8281: ST_TO_ADDR
// sWound := false ;
8282: LD_ADDR_EXP 62
8286: PUSH
8287: LD_INT 0
8289: ST_TO_ADDR
// sBetray := false ;
8290: LD_ADDR_EXP 66
8294: PUSH
8295: LD_INT 0
8297: ST_TO_ADDR
// sContamin := false ;
8298: LD_ADDR_EXP 67
8302: PUSH
8303: LD_INT 0
8305: ST_TO_ADDR
// sOil := false ;
8306: LD_ADDR_EXP 69
8310: PUSH
8311: LD_INT 0
8313: ST_TO_ADDR
// sStu := false ;
8314: LD_ADDR_EXP 73
8318: PUSH
8319: LD_INT 0
8321: ST_TO_ADDR
// sBazooka := false ;
8322: LD_ADDR_EXP 76
8326: PUSH
8327: LD_INT 0
8329: ST_TO_ADDR
// sMortar := false ;
8330: LD_ADDR_EXP 77
8334: PUSH
8335: LD_INT 0
8337: ST_TO_ADDR
// sRanger := false ;
8338: LD_ADDR_EXP 87
8342: PUSH
8343: LD_INT 0
8345: ST_TO_ADDR
// end ;
8346: LD_VAR 0 1
8350: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
8351: LD_INT 0
8353: PPUSH
8354: PPUSH
8355: PPUSH
8356: PPUSH
8357: PPUSH
// result := [ ] ;
8358: LD_ADDR_VAR 0 1
8362: PUSH
8363: EMPTY
8364: ST_TO_ADDR
// if campaign_id = 1 then
8365: LD_OWVAR 69
8369: PUSH
8370: LD_INT 1
8372: EQUAL
8373: IFFALSE 11311
// begin case mission_number of 1 :
8375: LD_OWVAR 70
8379: PUSH
8380: LD_INT 1
8382: DOUBLE
8383: EQUAL
8384: IFTRUE 8388
8386: GO 8452
8388: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
8389: LD_ADDR_VAR 0 1
8393: PUSH
8394: LD_INT 2
8396: PUSH
8397: LD_INT 4
8399: PUSH
8400: LD_INT 11
8402: PUSH
8403: LD_INT 12
8405: PUSH
8406: LD_INT 15
8408: PUSH
8409: LD_INT 16
8411: PUSH
8412: LD_INT 22
8414: PUSH
8415: LD_INT 23
8417: PUSH
8418: LD_INT 26
8420: PUSH
8421: EMPTY
8422: LIST
8423: LIST
8424: LIST
8425: LIST
8426: LIST
8427: LIST
8428: LIST
8429: LIST
8430: LIST
8431: PUSH
8432: LD_INT 101
8434: PUSH
8435: LD_INT 102
8437: PUSH
8438: LD_INT 106
8440: PUSH
8441: EMPTY
8442: LIST
8443: LIST
8444: LIST
8445: PUSH
8446: EMPTY
8447: LIST
8448: LIST
8449: ST_TO_ADDR
8450: GO 11309
8452: LD_INT 2
8454: DOUBLE
8455: EQUAL
8456: IFTRUE 8460
8458: GO 8532
8460: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
8461: LD_ADDR_VAR 0 1
8465: PUSH
8466: LD_INT 2
8468: PUSH
8469: LD_INT 4
8471: PUSH
8472: LD_INT 11
8474: PUSH
8475: LD_INT 12
8477: PUSH
8478: LD_INT 15
8480: PUSH
8481: LD_INT 16
8483: PUSH
8484: LD_INT 22
8486: PUSH
8487: LD_INT 23
8489: PUSH
8490: LD_INT 26
8492: PUSH
8493: EMPTY
8494: LIST
8495: LIST
8496: LIST
8497: LIST
8498: LIST
8499: LIST
8500: LIST
8501: LIST
8502: LIST
8503: PUSH
8504: LD_INT 101
8506: PUSH
8507: LD_INT 102
8509: PUSH
8510: LD_INT 105
8512: PUSH
8513: LD_INT 106
8515: PUSH
8516: LD_INT 108
8518: PUSH
8519: EMPTY
8520: LIST
8521: LIST
8522: LIST
8523: LIST
8524: LIST
8525: PUSH
8526: EMPTY
8527: LIST
8528: LIST
8529: ST_TO_ADDR
8530: GO 11309
8532: LD_INT 3
8534: DOUBLE
8535: EQUAL
8536: IFTRUE 8540
8538: GO 8616
8540: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
8541: LD_ADDR_VAR 0 1
8545: PUSH
8546: LD_INT 2
8548: PUSH
8549: LD_INT 4
8551: PUSH
8552: LD_INT 5
8554: PUSH
8555: LD_INT 11
8557: PUSH
8558: LD_INT 12
8560: PUSH
8561: LD_INT 15
8563: PUSH
8564: LD_INT 16
8566: PUSH
8567: LD_INT 22
8569: PUSH
8570: LD_INT 26
8572: PUSH
8573: LD_INT 36
8575: PUSH
8576: EMPTY
8577: LIST
8578: LIST
8579: LIST
8580: LIST
8581: LIST
8582: LIST
8583: LIST
8584: LIST
8585: LIST
8586: LIST
8587: PUSH
8588: LD_INT 101
8590: PUSH
8591: LD_INT 102
8593: PUSH
8594: LD_INT 105
8596: PUSH
8597: LD_INT 106
8599: PUSH
8600: LD_INT 108
8602: PUSH
8603: EMPTY
8604: LIST
8605: LIST
8606: LIST
8607: LIST
8608: LIST
8609: PUSH
8610: EMPTY
8611: LIST
8612: LIST
8613: ST_TO_ADDR
8614: GO 11309
8616: LD_INT 4
8618: DOUBLE
8619: EQUAL
8620: IFTRUE 8624
8622: GO 8708
8624: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
8625: LD_ADDR_VAR 0 1
8629: PUSH
8630: LD_INT 2
8632: PUSH
8633: LD_INT 4
8635: PUSH
8636: LD_INT 5
8638: PUSH
8639: LD_INT 8
8641: PUSH
8642: LD_INT 11
8644: PUSH
8645: LD_INT 12
8647: PUSH
8648: LD_INT 15
8650: PUSH
8651: LD_INT 16
8653: PUSH
8654: LD_INT 22
8656: PUSH
8657: LD_INT 23
8659: PUSH
8660: LD_INT 26
8662: PUSH
8663: LD_INT 36
8665: PUSH
8666: EMPTY
8667: LIST
8668: LIST
8669: LIST
8670: LIST
8671: LIST
8672: LIST
8673: LIST
8674: LIST
8675: LIST
8676: LIST
8677: LIST
8678: LIST
8679: PUSH
8680: LD_INT 101
8682: PUSH
8683: LD_INT 102
8685: PUSH
8686: LD_INT 105
8688: PUSH
8689: LD_INT 106
8691: PUSH
8692: LD_INT 108
8694: PUSH
8695: EMPTY
8696: LIST
8697: LIST
8698: LIST
8699: LIST
8700: LIST
8701: PUSH
8702: EMPTY
8703: LIST
8704: LIST
8705: ST_TO_ADDR
8706: GO 11309
8708: LD_INT 5
8710: DOUBLE
8711: EQUAL
8712: IFTRUE 8716
8714: GO 8816
8716: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
8717: LD_ADDR_VAR 0 1
8721: PUSH
8722: LD_INT 2
8724: PUSH
8725: LD_INT 4
8727: PUSH
8728: LD_INT 5
8730: PUSH
8731: LD_INT 6
8733: PUSH
8734: LD_INT 8
8736: PUSH
8737: LD_INT 11
8739: PUSH
8740: LD_INT 12
8742: PUSH
8743: LD_INT 15
8745: PUSH
8746: LD_INT 16
8748: PUSH
8749: LD_INT 22
8751: PUSH
8752: LD_INT 23
8754: PUSH
8755: LD_INT 25
8757: PUSH
8758: LD_INT 26
8760: PUSH
8761: LD_INT 36
8763: PUSH
8764: EMPTY
8765: LIST
8766: LIST
8767: LIST
8768: LIST
8769: LIST
8770: LIST
8771: LIST
8772: LIST
8773: LIST
8774: LIST
8775: LIST
8776: LIST
8777: LIST
8778: LIST
8779: PUSH
8780: LD_INT 101
8782: PUSH
8783: LD_INT 102
8785: PUSH
8786: LD_INT 105
8788: PUSH
8789: LD_INT 106
8791: PUSH
8792: LD_INT 108
8794: PUSH
8795: LD_INT 109
8797: PUSH
8798: LD_INT 112
8800: PUSH
8801: EMPTY
8802: LIST
8803: LIST
8804: LIST
8805: LIST
8806: LIST
8807: LIST
8808: LIST
8809: PUSH
8810: EMPTY
8811: LIST
8812: LIST
8813: ST_TO_ADDR
8814: GO 11309
8816: LD_INT 6
8818: DOUBLE
8819: EQUAL
8820: IFTRUE 8824
8822: GO 8944
8824: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
8825: LD_ADDR_VAR 0 1
8829: PUSH
8830: LD_INT 2
8832: PUSH
8833: LD_INT 4
8835: PUSH
8836: LD_INT 5
8838: PUSH
8839: LD_INT 6
8841: PUSH
8842: LD_INT 8
8844: PUSH
8845: LD_INT 11
8847: PUSH
8848: LD_INT 12
8850: PUSH
8851: LD_INT 15
8853: PUSH
8854: LD_INT 16
8856: PUSH
8857: LD_INT 20
8859: PUSH
8860: LD_INT 21
8862: PUSH
8863: LD_INT 22
8865: PUSH
8866: LD_INT 23
8868: PUSH
8869: LD_INT 25
8871: PUSH
8872: LD_INT 26
8874: PUSH
8875: LD_INT 30
8877: PUSH
8878: LD_INT 31
8880: PUSH
8881: LD_INT 32
8883: PUSH
8884: LD_INT 36
8886: PUSH
8887: EMPTY
8888: LIST
8889: LIST
8890: LIST
8891: LIST
8892: LIST
8893: LIST
8894: LIST
8895: LIST
8896: LIST
8897: LIST
8898: LIST
8899: LIST
8900: LIST
8901: LIST
8902: LIST
8903: LIST
8904: LIST
8905: LIST
8906: LIST
8907: PUSH
8908: LD_INT 101
8910: PUSH
8911: LD_INT 102
8913: PUSH
8914: LD_INT 105
8916: PUSH
8917: LD_INT 106
8919: PUSH
8920: LD_INT 108
8922: PUSH
8923: LD_INT 109
8925: PUSH
8926: LD_INT 112
8928: PUSH
8929: EMPTY
8930: LIST
8931: LIST
8932: LIST
8933: LIST
8934: LIST
8935: LIST
8936: LIST
8937: PUSH
8938: EMPTY
8939: LIST
8940: LIST
8941: ST_TO_ADDR
8942: GO 11309
8944: LD_INT 7
8946: DOUBLE
8947: EQUAL
8948: IFTRUE 8952
8950: GO 9052
8952: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
8953: LD_ADDR_VAR 0 1
8957: PUSH
8958: LD_INT 2
8960: PUSH
8961: LD_INT 4
8963: PUSH
8964: LD_INT 5
8966: PUSH
8967: LD_INT 7
8969: PUSH
8970: LD_INT 11
8972: PUSH
8973: LD_INT 12
8975: PUSH
8976: LD_INT 15
8978: PUSH
8979: LD_INT 16
8981: PUSH
8982: LD_INT 20
8984: PUSH
8985: LD_INT 21
8987: PUSH
8988: LD_INT 22
8990: PUSH
8991: LD_INT 23
8993: PUSH
8994: LD_INT 25
8996: PUSH
8997: LD_INT 26
8999: PUSH
9000: EMPTY
9001: LIST
9002: LIST
9003: LIST
9004: LIST
9005: LIST
9006: LIST
9007: LIST
9008: LIST
9009: LIST
9010: LIST
9011: LIST
9012: LIST
9013: LIST
9014: LIST
9015: PUSH
9016: LD_INT 101
9018: PUSH
9019: LD_INT 102
9021: PUSH
9022: LD_INT 103
9024: PUSH
9025: LD_INT 105
9027: PUSH
9028: LD_INT 106
9030: PUSH
9031: LD_INT 108
9033: PUSH
9034: LD_INT 112
9036: PUSH
9037: EMPTY
9038: LIST
9039: LIST
9040: LIST
9041: LIST
9042: LIST
9043: LIST
9044: LIST
9045: PUSH
9046: EMPTY
9047: LIST
9048: LIST
9049: ST_TO_ADDR
9050: GO 11309
9052: LD_INT 8
9054: DOUBLE
9055: EQUAL
9056: IFTRUE 9060
9058: GO 9188
9060: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
9061: LD_ADDR_VAR 0 1
9065: PUSH
9066: LD_INT 2
9068: PUSH
9069: LD_INT 4
9071: PUSH
9072: LD_INT 5
9074: PUSH
9075: LD_INT 6
9077: PUSH
9078: LD_INT 7
9080: PUSH
9081: LD_INT 8
9083: PUSH
9084: LD_INT 11
9086: PUSH
9087: LD_INT 12
9089: PUSH
9090: LD_INT 15
9092: PUSH
9093: LD_INT 16
9095: PUSH
9096: LD_INT 20
9098: PUSH
9099: LD_INT 21
9101: PUSH
9102: LD_INT 22
9104: PUSH
9105: LD_INT 23
9107: PUSH
9108: LD_INT 25
9110: PUSH
9111: LD_INT 26
9113: PUSH
9114: LD_INT 30
9116: PUSH
9117: LD_INT 31
9119: PUSH
9120: LD_INT 32
9122: PUSH
9123: LD_INT 36
9125: PUSH
9126: EMPTY
9127: LIST
9128: LIST
9129: LIST
9130: LIST
9131: LIST
9132: LIST
9133: LIST
9134: LIST
9135: LIST
9136: LIST
9137: LIST
9138: LIST
9139: LIST
9140: LIST
9141: LIST
9142: LIST
9143: LIST
9144: LIST
9145: LIST
9146: LIST
9147: PUSH
9148: LD_INT 101
9150: PUSH
9151: LD_INT 102
9153: PUSH
9154: LD_INT 103
9156: PUSH
9157: LD_INT 105
9159: PUSH
9160: LD_INT 106
9162: PUSH
9163: LD_INT 108
9165: PUSH
9166: LD_INT 109
9168: PUSH
9169: LD_INT 112
9171: PUSH
9172: EMPTY
9173: LIST
9174: LIST
9175: LIST
9176: LIST
9177: LIST
9178: LIST
9179: LIST
9180: LIST
9181: PUSH
9182: EMPTY
9183: LIST
9184: LIST
9185: ST_TO_ADDR
9186: GO 11309
9188: LD_INT 9
9190: DOUBLE
9191: EQUAL
9192: IFTRUE 9196
9194: GO 9332
9196: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
9197: LD_ADDR_VAR 0 1
9201: PUSH
9202: LD_INT 2
9204: PUSH
9205: LD_INT 4
9207: PUSH
9208: LD_INT 5
9210: PUSH
9211: LD_INT 6
9213: PUSH
9214: LD_INT 7
9216: PUSH
9217: LD_INT 8
9219: PUSH
9220: LD_INT 11
9222: PUSH
9223: LD_INT 12
9225: PUSH
9226: LD_INT 15
9228: PUSH
9229: LD_INT 16
9231: PUSH
9232: LD_INT 20
9234: PUSH
9235: LD_INT 21
9237: PUSH
9238: LD_INT 22
9240: PUSH
9241: LD_INT 23
9243: PUSH
9244: LD_INT 25
9246: PUSH
9247: LD_INT 26
9249: PUSH
9250: LD_INT 28
9252: PUSH
9253: LD_INT 30
9255: PUSH
9256: LD_INT 31
9258: PUSH
9259: LD_INT 32
9261: PUSH
9262: LD_INT 36
9264: PUSH
9265: EMPTY
9266: LIST
9267: LIST
9268: LIST
9269: LIST
9270: LIST
9271: LIST
9272: LIST
9273: LIST
9274: LIST
9275: LIST
9276: LIST
9277: LIST
9278: LIST
9279: LIST
9280: LIST
9281: LIST
9282: LIST
9283: LIST
9284: LIST
9285: LIST
9286: LIST
9287: PUSH
9288: LD_INT 101
9290: PUSH
9291: LD_INT 102
9293: PUSH
9294: LD_INT 103
9296: PUSH
9297: LD_INT 105
9299: PUSH
9300: LD_INT 106
9302: PUSH
9303: LD_INT 108
9305: PUSH
9306: LD_INT 109
9308: PUSH
9309: LD_INT 112
9311: PUSH
9312: LD_INT 114
9314: PUSH
9315: EMPTY
9316: LIST
9317: LIST
9318: LIST
9319: LIST
9320: LIST
9321: LIST
9322: LIST
9323: LIST
9324: LIST
9325: PUSH
9326: EMPTY
9327: LIST
9328: LIST
9329: ST_TO_ADDR
9330: GO 11309
9332: LD_INT 10
9334: DOUBLE
9335: EQUAL
9336: IFTRUE 9340
9338: GO 9524
9340: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
9341: LD_ADDR_VAR 0 1
9345: PUSH
9346: LD_INT 2
9348: PUSH
9349: LD_INT 4
9351: PUSH
9352: LD_INT 5
9354: PUSH
9355: LD_INT 6
9357: PUSH
9358: LD_INT 7
9360: PUSH
9361: LD_INT 8
9363: PUSH
9364: LD_INT 9
9366: PUSH
9367: LD_INT 10
9369: PUSH
9370: LD_INT 11
9372: PUSH
9373: LD_INT 12
9375: PUSH
9376: LD_INT 13
9378: PUSH
9379: LD_INT 14
9381: PUSH
9382: LD_INT 15
9384: PUSH
9385: LD_INT 16
9387: PUSH
9388: LD_INT 17
9390: PUSH
9391: LD_INT 18
9393: PUSH
9394: LD_INT 19
9396: PUSH
9397: LD_INT 20
9399: PUSH
9400: LD_INT 21
9402: PUSH
9403: LD_INT 22
9405: PUSH
9406: LD_INT 23
9408: PUSH
9409: LD_INT 24
9411: PUSH
9412: LD_INT 25
9414: PUSH
9415: LD_INT 26
9417: PUSH
9418: LD_INT 28
9420: PUSH
9421: LD_INT 30
9423: PUSH
9424: LD_INT 31
9426: PUSH
9427: LD_INT 32
9429: PUSH
9430: LD_INT 36
9432: PUSH
9433: EMPTY
9434: LIST
9435: LIST
9436: LIST
9437: LIST
9438: LIST
9439: LIST
9440: LIST
9441: LIST
9442: LIST
9443: LIST
9444: LIST
9445: LIST
9446: LIST
9447: LIST
9448: LIST
9449: LIST
9450: LIST
9451: LIST
9452: LIST
9453: LIST
9454: LIST
9455: LIST
9456: LIST
9457: LIST
9458: LIST
9459: LIST
9460: LIST
9461: LIST
9462: LIST
9463: PUSH
9464: LD_INT 101
9466: PUSH
9467: LD_INT 102
9469: PUSH
9470: LD_INT 103
9472: PUSH
9473: LD_INT 104
9475: PUSH
9476: LD_INT 105
9478: PUSH
9479: LD_INT 106
9481: PUSH
9482: LD_INT 107
9484: PUSH
9485: LD_INT 108
9487: PUSH
9488: LD_INT 109
9490: PUSH
9491: LD_INT 110
9493: PUSH
9494: LD_INT 111
9496: PUSH
9497: LD_INT 112
9499: PUSH
9500: LD_INT 114
9502: PUSH
9503: EMPTY
9504: LIST
9505: LIST
9506: LIST
9507: LIST
9508: LIST
9509: LIST
9510: LIST
9511: LIST
9512: LIST
9513: LIST
9514: LIST
9515: LIST
9516: LIST
9517: PUSH
9518: EMPTY
9519: LIST
9520: LIST
9521: ST_TO_ADDR
9522: GO 11309
9524: LD_INT 11
9526: DOUBLE
9527: EQUAL
9528: IFTRUE 9532
9530: GO 9724
9532: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
9533: LD_ADDR_VAR 0 1
9537: PUSH
9538: LD_INT 2
9540: PUSH
9541: LD_INT 3
9543: PUSH
9544: LD_INT 4
9546: PUSH
9547: LD_INT 5
9549: PUSH
9550: LD_INT 6
9552: PUSH
9553: LD_INT 7
9555: PUSH
9556: LD_INT 8
9558: PUSH
9559: LD_INT 9
9561: PUSH
9562: LD_INT 10
9564: PUSH
9565: LD_INT 11
9567: PUSH
9568: LD_INT 12
9570: PUSH
9571: LD_INT 13
9573: PUSH
9574: LD_INT 14
9576: PUSH
9577: LD_INT 15
9579: PUSH
9580: LD_INT 16
9582: PUSH
9583: LD_INT 17
9585: PUSH
9586: LD_INT 18
9588: PUSH
9589: LD_INT 19
9591: PUSH
9592: LD_INT 20
9594: PUSH
9595: LD_INT 21
9597: PUSH
9598: LD_INT 22
9600: PUSH
9601: LD_INT 23
9603: PUSH
9604: LD_INT 24
9606: PUSH
9607: LD_INT 25
9609: PUSH
9610: LD_INT 26
9612: PUSH
9613: LD_INT 28
9615: PUSH
9616: LD_INT 30
9618: PUSH
9619: LD_INT 31
9621: PUSH
9622: LD_INT 32
9624: PUSH
9625: LD_INT 34
9627: PUSH
9628: LD_INT 36
9630: PUSH
9631: EMPTY
9632: LIST
9633: LIST
9634: LIST
9635: LIST
9636: LIST
9637: LIST
9638: LIST
9639: LIST
9640: LIST
9641: LIST
9642: LIST
9643: LIST
9644: LIST
9645: LIST
9646: LIST
9647: LIST
9648: LIST
9649: LIST
9650: LIST
9651: LIST
9652: LIST
9653: LIST
9654: LIST
9655: LIST
9656: LIST
9657: LIST
9658: LIST
9659: LIST
9660: LIST
9661: LIST
9662: LIST
9663: PUSH
9664: LD_INT 101
9666: PUSH
9667: LD_INT 102
9669: PUSH
9670: LD_INT 103
9672: PUSH
9673: LD_INT 104
9675: PUSH
9676: LD_INT 105
9678: PUSH
9679: LD_INT 106
9681: PUSH
9682: LD_INT 107
9684: PUSH
9685: LD_INT 108
9687: PUSH
9688: LD_INT 109
9690: PUSH
9691: LD_INT 110
9693: PUSH
9694: LD_INT 111
9696: PUSH
9697: LD_INT 112
9699: PUSH
9700: LD_INT 114
9702: PUSH
9703: EMPTY
9704: LIST
9705: LIST
9706: LIST
9707: LIST
9708: LIST
9709: LIST
9710: LIST
9711: LIST
9712: LIST
9713: LIST
9714: LIST
9715: LIST
9716: LIST
9717: PUSH
9718: EMPTY
9719: LIST
9720: LIST
9721: ST_TO_ADDR
9722: GO 11309
9724: LD_INT 12
9726: DOUBLE
9727: EQUAL
9728: IFTRUE 9732
9730: GO 9940
9732: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
9733: LD_ADDR_VAR 0 1
9737: PUSH
9738: LD_INT 1
9740: PUSH
9741: LD_INT 2
9743: PUSH
9744: LD_INT 3
9746: PUSH
9747: LD_INT 4
9749: PUSH
9750: LD_INT 5
9752: PUSH
9753: LD_INT 6
9755: PUSH
9756: LD_INT 7
9758: PUSH
9759: LD_INT 8
9761: PUSH
9762: LD_INT 9
9764: PUSH
9765: LD_INT 10
9767: PUSH
9768: LD_INT 11
9770: PUSH
9771: LD_INT 12
9773: PUSH
9774: LD_INT 13
9776: PUSH
9777: LD_INT 14
9779: PUSH
9780: LD_INT 15
9782: PUSH
9783: LD_INT 16
9785: PUSH
9786: LD_INT 17
9788: PUSH
9789: LD_INT 18
9791: PUSH
9792: LD_INT 19
9794: PUSH
9795: LD_INT 20
9797: PUSH
9798: LD_INT 21
9800: PUSH
9801: LD_INT 22
9803: PUSH
9804: LD_INT 23
9806: PUSH
9807: LD_INT 24
9809: PUSH
9810: LD_INT 25
9812: PUSH
9813: LD_INT 26
9815: PUSH
9816: LD_INT 27
9818: PUSH
9819: LD_INT 28
9821: PUSH
9822: LD_INT 30
9824: PUSH
9825: LD_INT 31
9827: PUSH
9828: LD_INT 32
9830: PUSH
9831: LD_INT 33
9833: PUSH
9834: LD_INT 34
9836: PUSH
9837: LD_INT 36
9839: PUSH
9840: EMPTY
9841: LIST
9842: LIST
9843: LIST
9844: LIST
9845: LIST
9846: LIST
9847: LIST
9848: LIST
9849: LIST
9850: LIST
9851: LIST
9852: LIST
9853: LIST
9854: LIST
9855: LIST
9856: LIST
9857: LIST
9858: LIST
9859: LIST
9860: LIST
9861: LIST
9862: LIST
9863: LIST
9864: LIST
9865: LIST
9866: LIST
9867: LIST
9868: LIST
9869: LIST
9870: LIST
9871: LIST
9872: LIST
9873: LIST
9874: LIST
9875: PUSH
9876: LD_INT 101
9878: PUSH
9879: LD_INT 102
9881: PUSH
9882: LD_INT 103
9884: PUSH
9885: LD_INT 104
9887: PUSH
9888: LD_INT 105
9890: PUSH
9891: LD_INT 106
9893: PUSH
9894: LD_INT 107
9896: PUSH
9897: LD_INT 108
9899: PUSH
9900: LD_INT 109
9902: PUSH
9903: LD_INT 110
9905: PUSH
9906: LD_INT 111
9908: PUSH
9909: LD_INT 112
9911: PUSH
9912: LD_INT 113
9914: PUSH
9915: LD_INT 114
9917: PUSH
9918: EMPTY
9919: LIST
9920: LIST
9921: LIST
9922: LIST
9923: LIST
9924: LIST
9925: LIST
9926: LIST
9927: LIST
9928: LIST
9929: LIST
9930: LIST
9931: LIST
9932: LIST
9933: PUSH
9934: EMPTY
9935: LIST
9936: LIST
9937: ST_TO_ADDR
9938: GO 11309
9940: LD_INT 13
9942: DOUBLE
9943: EQUAL
9944: IFTRUE 9948
9946: GO 10144
9948: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
9949: LD_ADDR_VAR 0 1
9953: PUSH
9954: LD_INT 1
9956: PUSH
9957: LD_INT 2
9959: PUSH
9960: LD_INT 3
9962: PUSH
9963: LD_INT 4
9965: PUSH
9966: LD_INT 5
9968: PUSH
9969: LD_INT 8
9971: PUSH
9972: LD_INT 9
9974: PUSH
9975: LD_INT 10
9977: PUSH
9978: LD_INT 11
9980: PUSH
9981: LD_INT 12
9983: PUSH
9984: LD_INT 14
9986: PUSH
9987: LD_INT 15
9989: PUSH
9990: LD_INT 16
9992: PUSH
9993: LD_INT 17
9995: PUSH
9996: LD_INT 18
9998: PUSH
9999: LD_INT 19
10001: PUSH
10002: LD_INT 20
10004: PUSH
10005: LD_INT 21
10007: PUSH
10008: LD_INT 22
10010: PUSH
10011: LD_INT 23
10013: PUSH
10014: LD_INT 24
10016: PUSH
10017: LD_INT 25
10019: PUSH
10020: LD_INT 26
10022: PUSH
10023: LD_INT 27
10025: PUSH
10026: LD_INT 28
10028: PUSH
10029: LD_INT 30
10031: PUSH
10032: LD_INT 31
10034: PUSH
10035: LD_INT 32
10037: PUSH
10038: LD_INT 33
10040: PUSH
10041: LD_INT 34
10043: PUSH
10044: LD_INT 36
10046: PUSH
10047: EMPTY
10048: LIST
10049: LIST
10050: LIST
10051: LIST
10052: LIST
10053: LIST
10054: LIST
10055: LIST
10056: LIST
10057: LIST
10058: LIST
10059: LIST
10060: LIST
10061: LIST
10062: LIST
10063: LIST
10064: LIST
10065: LIST
10066: LIST
10067: LIST
10068: LIST
10069: LIST
10070: LIST
10071: LIST
10072: LIST
10073: LIST
10074: LIST
10075: LIST
10076: LIST
10077: LIST
10078: LIST
10079: PUSH
10080: LD_INT 101
10082: PUSH
10083: LD_INT 102
10085: PUSH
10086: LD_INT 103
10088: PUSH
10089: LD_INT 104
10091: PUSH
10092: LD_INT 105
10094: PUSH
10095: LD_INT 106
10097: PUSH
10098: LD_INT 107
10100: PUSH
10101: LD_INT 108
10103: PUSH
10104: LD_INT 109
10106: PUSH
10107: LD_INT 110
10109: PUSH
10110: LD_INT 111
10112: PUSH
10113: LD_INT 112
10115: PUSH
10116: LD_INT 113
10118: PUSH
10119: LD_INT 114
10121: PUSH
10122: EMPTY
10123: LIST
10124: LIST
10125: LIST
10126: LIST
10127: LIST
10128: LIST
10129: LIST
10130: LIST
10131: LIST
10132: LIST
10133: LIST
10134: LIST
10135: LIST
10136: LIST
10137: PUSH
10138: EMPTY
10139: LIST
10140: LIST
10141: ST_TO_ADDR
10142: GO 11309
10144: LD_INT 14
10146: DOUBLE
10147: EQUAL
10148: IFTRUE 10152
10150: GO 10364
10152: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
10153: LD_ADDR_VAR 0 1
10157: PUSH
10158: LD_INT 1
10160: PUSH
10161: LD_INT 2
10163: PUSH
10164: LD_INT 3
10166: PUSH
10167: LD_INT 4
10169: PUSH
10170: LD_INT 5
10172: PUSH
10173: LD_INT 6
10175: PUSH
10176: LD_INT 7
10178: PUSH
10179: LD_INT 8
10181: PUSH
10182: LD_INT 9
10184: PUSH
10185: LD_INT 10
10187: PUSH
10188: LD_INT 11
10190: PUSH
10191: LD_INT 12
10193: PUSH
10194: LD_INT 13
10196: PUSH
10197: LD_INT 14
10199: PUSH
10200: LD_INT 15
10202: PUSH
10203: LD_INT 16
10205: PUSH
10206: LD_INT 17
10208: PUSH
10209: LD_INT 18
10211: PUSH
10212: LD_INT 19
10214: PUSH
10215: LD_INT 20
10217: PUSH
10218: LD_INT 21
10220: PUSH
10221: LD_INT 22
10223: PUSH
10224: LD_INT 23
10226: PUSH
10227: LD_INT 24
10229: PUSH
10230: LD_INT 25
10232: PUSH
10233: LD_INT 26
10235: PUSH
10236: LD_INT 27
10238: PUSH
10239: LD_INT 28
10241: PUSH
10242: LD_INT 29
10244: PUSH
10245: LD_INT 30
10247: PUSH
10248: LD_INT 31
10250: PUSH
10251: LD_INT 32
10253: PUSH
10254: LD_INT 33
10256: PUSH
10257: LD_INT 34
10259: PUSH
10260: LD_INT 36
10262: PUSH
10263: EMPTY
10264: LIST
10265: LIST
10266: LIST
10267: LIST
10268: LIST
10269: LIST
10270: LIST
10271: LIST
10272: LIST
10273: LIST
10274: LIST
10275: LIST
10276: LIST
10277: LIST
10278: LIST
10279: LIST
10280: LIST
10281: LIST
10282: LIST
10283: LIST
10284: LIST
10285: LIST
10286: LIST
10287: LIST
10288: LIST
10289: LIST
10290: LIST
10291: LIST
10292: LIST
10293: LIST
10294: LIST
10295: LIST
10296: LIST
10297: LIST
10298: LIST
10299: PUSH
10300: LD_INT 101
10302: PUSH
10303: LD_INT 102
10305: PUSH
10306: LD_INT 103
10308: PUSH
10309: LD_INT 104
10311: PUSH
10312: LD_INT 105
10314: PUSH
10315: LD_INT 106
10317: PUSH
10318: LD_INT 107
10320: PUSH
10321: LD_INT 108
10323: PUSH
10324: LD_INT 109
10326: PUSH
10327: LD_INT 110
10329: PUSH
10330: LD_INT 111
10332: PUSH
10333: LD_INT 112
10335: PUSH
10336: LD_INT 113
10338: PUSH
10339: LD_INT 114
10341: PUSH
10342: EMPTY
10343: LIST
10344: LIST
10345: LIST
10346: LIST
10347: LIST
10348: LIST
10349: LIST
10350: LIST
10351: LIST
10352: LIST
10353: LIST
10354: LIST
10355: LIST
10356: LIST
10357: PUSH
10358: EMPTY
10359: LIST
10360: LIST
10361: ST_TO_ADDR
10362: GO 11309
10364: LD_INT 15
10366: DOUBLE
10367: EQUAL
10368: IFTRUE 10372
10370: GO 10584
10372: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
10373: LD_ADDR_VAR 0 1
10377: PUSH
10378: LD_INT 1
10380: PUSH
10381: LD_INT 2
10383: PUSH
10384: LD_INT 3
10386: PUSH
10387: LD_INT 4
10389: PUSH
10390: LD_INT 5
10392: PUSH
10393: LD_INT 6
10395: PUSH
10396: LD_INT 7
10398: PUSH
10399: LD_INT 8
10401: PUSH
10402: LD_INT 9
10404: PUSH
10405: LD_INT 10
10407: PUSH
10408: LD_INT 11
10410: PUSH
10411: LD_INT 12
10413: PUSH
10414: LD_INT 13
10416: PUSH
10417: LD_INT 14
10419: PUSH
10420: LD_INT 15
10422: PUSH
10423: LD_INT 16
10425: PUSH
10426: LD_INT 17
10428: PUSH
10429: LD_INT 18
10431: PUSH
10432: LD_INT 19
10434: PUSH
10435: LD_INT 20
10437: PUSH
10438: LD_INT 21
10440: PUSH
10441: LD_INT 22
10443: PUSH
10444: LD_INT 23
10446: PUSH
10447: LD_INT 24
10449: PUSH
10450: LD_INT 25
10452: PUSH
10453: LD_INT 26
10455: PUSH
10456: LD_INT 27
10458: PUSH
10459: LD_INT 28
10461: PUSH
10462: LD_INT 29
10464: PUSH
10465: LD_INT 30
10467: PUSH
10468: LD_INT 31
10470: PUSH
10471: LD_INT 32
10473: PUSH
10474: LD_INT 33
10476: PUSH
10477: LD_INT 34
10479: PUSH
10480: LD_INT 36
10482: PUSH
10483: EMPTY
10484: LIST
10485: LIST
10486: LIST
10487: LIST
10488: LIST
10489: LIST
10490: LIST
10491: LIST
10492: LIST
10493: LIST
10494: LIST
10495: LIST
10496: LIST
10497: LIST
10498: LIST
10499: LIST
10500: LIST
10501: LIST
10502: LIST
10503: LIST
10504: LIST
10505: LIST
10506: LIST
10507: LIST
10508: LIST
10509: LIST
10510: LIST
10511: LIST
10512: LIST
10513: LIST
10514: LIST
10515: LIST
10516: LIST
10517: LIST
10518: LIST
10519: PUSH
10520: LD_INT 101
10522: PUSH
10523: LD_INT 102
10525: PUSH
10526: LD_INT 103
10528: PUSH
10529: LD_INT 104
10531: PUSH
10532: LD_INT 105
10534: PUSH
10535: LD_INT 106
10537: PUSH
10538: LD_INT 107
10540: PUSH
10541: LD_INT 108
10543: PUSH
10544: LD_INT 109
10546: PUSH
10547: LD_INT 110
10549: PUSH
10550: LD_INT 111
10552: PUSH
10553: LD_INT 112
10555: PUSH
10556: LD_INT 113
10558: PUSH
10559: LD_INT 114
10561: PUSH
10562: EMPTY
10563: LIST
10564: LIST
10565: LIST
10566: LIST
10567: LIST
10568: LIST
10569: LIST
10570: LIST
10571: LIST
10572: LIST
10573: LIST
10574: LIST
10575: LIST
10576: LIST
10577: PUSH
10578: EMPTY
10579: LIST
10580: LIST
10581: ST_TO_ADDR
10582: GO 11309
10584: LD_INT 16
10586: DOUBLE
10587: EQUAL
10588: IFTRUE 10592
10590: GO 10716
10592: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
10593: LD_ADDR_VAR 0 1
10597: PUSH
10598: LD_INT 2
10600: PUSH
10601: LD_INT 4
10603: PUSH
10604: LD_INT 5
10606: PUSH
10607: LD_INT 7
10609: PUSH
10610: LD_INT 11
10612: PUSH
10613: LD_INT 12
10615: PUSH
10616: LD_INT 15
10618: PUSH
10619: LD_INT 16
10621: PUSH
10622: LD_INT 20
10624: PUSH
10625: LD_INT 21
10627: PUSH
10628: LD_INT 22
10630: PUSH
10631: LD_INT 23
10633: PUSH
10634: LD_INT 25
10636: PUSH
10637: LD_INT 26
10639: PUSH
10640: LD_INT 30
10642: PUSH
10643: LD_INT 31
10645: PUSH
10646: LD_INT 32
10648: PUSH
10649: LD_INT 33
10651: PUSH
10652: LD_INT 34
10654: PUSH
10655: EMPTY
10656: LIST
10657: LIST
10658: LIST
10659: LIST
10660: LIST
10661: LIST
10662: LIST
10663: LIST
10664: LIST
10665: LIST
10666: LIST
10667: LIST
10668: LIST
10669: LIST
10670: LIST
10671: LIST
10672: LIST
10673: LIST
10674: LIST
10675: PUSH
10676: LD_INT 101
10678: PUSH
10679: LD_INT 102
10681: PUSH
10682: LD_INT 103
10684: PUSH
10685: LD_INT 106
10687: PUSH
10688: LD_INT 108
10690: PUSH
10691: LD_INT 112
10693: PUSH
10694: LD_INT 113
10696: PUSH
10697: LD_INT 114
10699: PUSH
10700: EMPTY
10701: LIST
10702: LIST
10703: LIST
10704: LIST
10705: LIST
10706: LIST
10707: LIST
10708: LIST
10709: PUSH
10710: EMPTY
10711: LIST
10712: LIST
10713: ST_TO_ADDR
10714: GO 11309
10716: LD_INT 17
10718: DOUBLE
10719: EQUAL
10720: IFTRUE 10724
10722: GO 10936
10724: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
10725: LD_ADDR_VAR 0 1
10729: PUSH
10730: LD_INT 1
10732: PUSH
10733: LD_INT 2
10735: PUSH
10736: LD_INT 3
10738: PUSH
10739: LD_INT 4
10741: PUSH
10742: LD_INT 5
10744: PUSH
10745: LD_INT 6
10747: PUSH
10748: LD_INT 7
10750: PUSH
10751: LD_INT 8
10753: PUSH
10754: LD_INT 9
10756: PUSH
10757: LD_INT 10
10759: PUSH
10760: LD_INT 11
10762: PUSH
10763: LD_INT 12
10765: PUSH
10766: LD_INT 13
10768: PUSH
10769: LD_INT 14
10771: PUSH
10772: LD_INT 15
10774: PUSH
10775: LD_INT 16
10777: PUSH
10778: LD_INT 17
10780: PUSH
10781: LD_INT 18
10783: PUSH
10784: LD_INT 19
10786: PUSH
10787: LD_INT 20
10789: PUSH
10790: LD_INT 21
10792: PUSH
10793: LD_INT 22
10795: PUSH
10796: LD_INT 23
10798: PUSH
10799: LD_INT 24
10801: PUSH
10802: LD_INT 25
10804: PUSH
10805: LD_INT 26
10807: PUSH
10808: LD_INT 27
10810: PUSH
10811: LD_INT 28
10813: PUSH
10814: LD_INT 29
10816: PUSH
10817: LD_INT 30
10819: PUSH
10820: LD_INT 31
10822: PUSH
10823: LD_INT 32
10825: PUSH
10826: LD_INT 33
10828: PUSH
10829: LD_INT 34
10831: PUSH
10832: LD_INT 36
10834: PUSH
10835: EMPTY
10836: LIST
10837: LIST
10838: LIST
10839: LIST
10840: LIST
10841: LIST
10842: LIST
10843: LIST
10844: LIST
10845: LIST
10846: LIST
10847: LIST
10848: LIST
10849: LIST
10850: LIST
10851: LIST
10852: LIST
10853: LIST
10854: LIST
10855: LIST
10856: LIST
10857: LIST
10858: LIST
10859: LIST
10860: LIST
10861: LIST
10862: LIST
10863: LIST
10864: LIST
10865: LIST
10866: LIST
10867: LIST
10868: LIST
10869: LIST
10870: LIST
10871: PUSH
10872: LD_INT 101
10874: PUSH
10875: LD_INT 102
10877: PUSH
10878: LD_INT 103
10880: PUSH
10881: LD_INT 104
10883: PUSH
10884: LD_INT 105
10886: PUSH
10887: LD_INT 106
10889: PUSH
10890: LD_INT 107
10892: PUSH
10893: LD_INT 108
10895: PUSH
10896: LD_INT 109
10898: PUSH
10899: LD_INT 110
10901: PUSH
10902: LD_INT 111
10904: PUSH
10905: LD_INT 112
10907: PUSH
10908: LD_INT 113
10910: PUSH
10911: LD_INT 114
10913: PUSH
10914: EMPTY
10915: LIST
10916: LIST
10917: LIST
10918: LIST
10919: LIST
10920: LIST
10921: LIST
10922: LIST
10923: LIST
10924: LIST
10925: LIST
10926: LIST
10927: LIST
10928: LIST
10929: PUSH
10930: EMPTY
10931: LIST
10932: LIST
10933: ST_TO_ADDR
10934: GO 11309
10936: LD_INT 18
10938: DOUBLE
10939: EQUAL
10940: IFTRUE 10944
10942: GO 11080
10944: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
10945: LD_ADDR_VAR 0 1
10949: PUSH
10950: LD_INT 2
10952: PUSH
10953: LD_INT 4
10955: PUSH
10956: LD_INT 5
10958: PUSH
10959: LD_INT 7
10961: PUSH
10962: LD_INT 11
10964: PUSH
10965: LD_INT 12
10967: PUSH
10968: LD_INT 15
10970: PUSH
10971: LD_INT 16
10973: PUSH
10974: LD_INT 20
10976: PUSH
10977: LD_INT 21
10979: PUSH
10980: LD_INT 22
10982: PUSH
10983: LD_INT 23
10985: PUSH
10986: LD_INT 25
10988: PUSH
10989: LD_INT 26
10991: PUSH
10992: LD_INT 30
10994: PUSH
10995: LD_INT 31
10997: PUSH
10998: LD_INT 32
11000: PUSH
11001: LD_INT 33
11003: PUSH
11004: LD_INT 34
11006: PUSH
11007: LD_INT 35
11009: PUSH
11010: LD_INT 36
11012: PUSH
11013: EMPTY
11014: LIST
11015: LIST
11016: LIST
11017: LIST
11018: LIST
11019: LIST
11020: LIST
11021: LIST
11022: LIST
11023: LIST
11024: LIST
11025: LIST
11026: LIST
11027: LIST
11028: LIST
11029: LIST
11030: LIST
11031: LIST
11032: LIST
11033: LIST
11034: LIST
11035: PUSH
11036: LD_INT 101
11038: PUSH
11039: LD_INT 102
11041: PUSH
11042: LD_INT 103
11044: PUSH
11045: LD_INT 106
11047: PUSH
11048: LD_INT 108
11050: PUSH
11051: LD_INT 112
11053: PUSH
11054: LD_INT 113
11056: PUSH
11057: LD_INT 114
11059: PUSH
11060: LD_INT 115
11062: PUSH
11063: EMPTY
11064: LIST
11065: LIST
11066: LIST
11067: LIST
11068: LIST
11069: LIST
11070: LIST
11071: LIST
11072: LIST
11073: PUSH
11074: EMPTY
11075: LIST
11076: LIST
11077: ST_TO_ADDR
11078: GO 11309
11080: LD_INT 19
11082: DOUBLE
11083: EQUAL
11084: IFTRUE 11088
11086: GO 11308
11088: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
11089: LD_ADDR_VAR 0 1
11093: PUSH
11094: LD_INT 1
11096: PUSH
11097: LD_INT 2
11099: PUSH
11100: LD_INT 3
11102: PUSH
11103: LD_INT 4
11105: PUSH
11106: LD_INT 5
11108: PUSH
11109: LD_INT 6
11111: PUSH
11112: LD_INT 7
11114: PUSH
11115: LD_INT 8
11117: PUSH
11118: LD_INT 9
11120: PUSH
11121: LD_INT 10
11123: PUSH
11124: LD_INT 11
11126: PUSH
11127: LD_INT 12
11129: PUSH
11130: LD_INT 13
11132: PUSH
11133: LD_INT 14
11135: PUSH
11136: LD_INT 15
11138: PUSH
11139: LD_INT 16
11141: PUSH
11142: LD_INT 17
11144: PUSH
11145: LD_INT 18
11147: PUSH
11148: LD_INT 19
11150: PUSH
11151: LD_INT 20
11153: PUSH
11154: LD_INT 21
11156: PUSH
11157: LD_INT 22
11159: PUSH
11160: LD_INT 23
11162: PUSH
11163: LD_INT 24
11165: PUSH
11166: LD_INT 25
11168: PUSH
11169: LD_INT 26
11171: PUSH
11172: LD_INT 27
11174: PUSH
11175: LD_INT 28
11177: PUSH
11178: LD_INT 29
11180: PUSH
11181: LD_INT 30
11183: PUSH
11184: LD_INT 31
11186: PUSH
11187: LD_INT 32
11189: PUSH
11190: LD_INT 33
11192: PUSH
11193: LD_INT 34
11195: PUSH
11196: LD_INT 35
11198: PUSH
11199: LD_INT 36
11201: PUSH
11202: EMPTY
11203: LIST
11204: LIST
11205: LIST
11206: LIST
11207: LIST
11208: LIST
11209: LIST
11210: LIST
11211: LIST
11212: LIST
11213: LIST
11214: LIST
11215: LIST
11216: LIST
11217: LIST
11218: LIST
11219: LIST
11220: LIST
11221: LIST
11222: LIST
11223: LIST
11224: LIST
11225: LIST
11226: LIST
11227: LIST
11228: LIST
11229: LIST
11230: LIST
11231: LIST
11232: LIST
11233: LIST
11234: LIST
11235: LIST
11236: LIST
11237: LIST
11238: LIST
11239: PUSH
11240: LD_INT 101
11242: PUSH
11243: LD_INT 102
11245: PUSH
11246: LD_INT 103
11248: PUSH
11249: LD_INT 104
11251: PUSH
11252: LD_INT 105
11254: PUSH
11255: LD_INT 106
11257: PUSH
11258: LD_INT 107
11260: PUSH
11261: LD_INT 108
11263: PUSH
11264: LD_INT 109
11266: PUSH
11267: LD_INT 110
11269: PUSH
11270: LD_INT 111
11272: PUSH
11273: LD_INT 112
11275: PUSH
11276: LD_INT 113
11278: PUSH
11279: LD_INT 114
11281: PUSH
11282: LD_INT 115
11284: PUSH
11285: EMPTY
11286: LIST
11287: LIST
11288: LIST
11289: LIST
11290: LIST
11291: LIST
11292: LIST
11293: LIST
11294: LIST
11295: LIST
11296: LIST
11297: LIST
11298: LIST
11299: LIST
11300: LIST
11301: PUSH
11302: EMPTY
11303: LIST
11304: LIST
11305: ST_TO_ADDR
11306: GO 11309
11308: POP
// end else
11309: GO 11346
// if campaign_id = 5 then
11311: LD_OWVAR 69
11315: PUSH
11316: LD_INT 5
11318: EQUAL
11319: IFFALSE 11346
// begin result := [ [ 1 , 2 ] , [ 100 ] ] ;
11321: LD_ADDR_VAR 0 1
11325: PUSH
11326: LD_INT 1
11328: PUSH
11329: LD_INT 2
11331: PUSH
11332: EMPTY
11333: LIST
11334: LIST
11335: PUSH
11336: LD_INT 100
11338: PUSH
11339: EMPTY
11340: LIST
11341: PUSH
11342: EMPTY
11343: LIST
11344: LIST
11345: ST_TO_ADDR
// end ; if result then
11346: LD_VAR 0 1
11350: IFFALSE 11639
// begin normal :=  ;
11352: LD_ADDR_VAR 0 3
11356: PUSH
11357: LD_STRING 
11359: ST_TO_ADDR
// hardcore :=  ;
11360: LD_ADDR_VAR 0 4
11364: PUSH
11365: LD_STRING 
11367: ST_TO_ADDR
// for i = 1 to normalCounter do
11368: LD_ADDR_VAR 0 5
11372: PUSH
11373: DOUBLE
11374: LD_INT 1
11376: DEC
11377: ST_TO_ADDR
11378: LD_EXP 35
11382: PUSH
11383: FOR_TO
11384: IFFALSE 11485
// begin tmp := 0 ;
11386: LD_ADDR_VAR 0 2
11390: PUSH
11391: LD_STRING 0
11393: ST_TO_ADDR
// if result [ 1 ] then
11394: LD_VAR 0 1
11398: PUSH
11399: LD_INT 1
11401: ARRAY
11402: IFFALSE 11467
// if result [ 1 ] [ 1 ] = i then
11404: LD_VAR 0 1
11408: PUSH
11409: LD_INT 1
11411: ARRAY
11412: PUSH
11413: LD_INT 1
11415: ARRAY
11416: PUSH
11417: LD_VAR 0 5
11421: EQUAL
11422: IFFALSE 11467
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
11424: LD_ADDR_VAR 0 1
11428: PUSH
11429: LD_VAR 0 1
11433: PPUSH
11434: LD_INT 1
11436: PPUSH
11437: LD_VAR 0 1
11441: PUSH
11442: LD_INT 1
11444: ARRAY
11445: PPUSH
11446: LD_INT 1
11448: PPUSH
11449: CALL_OW 3
11453: PPUSH
11454: CALL_OW 1
11458: ST_TO_ADDR
// tmp := 1 ;
11459: LD_ADDR_VAR 0 2
11463: PUSH
11464: LD_STRING 1
11466: ST_TO_ADDR
// end ; normal := normal & tmp ;
11467: LD_ADDR_VAR 0 3
11471: PUSH
11472: LD_VAR 0 3
11476: PUSH
11477: LD_VAR 0 2
11481: STR
11482: ST_TO_ADDR
// end ;
11483: GO 11383
11485: POP
11486: POP
// for i = 1 to hardcoreCounter do
11487: LD_ADDR_VAR 0 5
11491: PUSH
11492: DOUBLE
11493: LD_INT 1
11495: DEC
11496: ST_TO_ADDR
11497: LD_EXP 36
11501: PUSH
11502: FOR_TO
11503: IFFALSE 11608
// begin tmp := 0 ;
11505: LD_ADDR_VAR 0 2
11509: PUSH
11510: LD_STRING 0
11512: ST_TO_ADDR
// if result [ 2 ] then
11513: LD_VAR 0 1
11517: PUSH
11518: LD_INT 2
11520: ARRAY
11521: IFFALSE 11590
// if result [ 2 ] [ 1 ] = 100 + i then
11523: LD_VAR 0 1
11527: PUSH
11528: LD_INT 2
11530: ARRAY
11531: PUSH
11532: LD_INT 1
11534: ARRAY
11535: PUSH
11536: LD_INT 100
11538: PUSH
11539: LD_VAR 0 5
11543: PLUS
11544: EQUAL
11545: IFFALSE 11590
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
11547: LD_ADDR_VAR 0 1
11551: PUSH
11552: LD_VAR 0 1
11556: PPUSH
11557: LD_INT 2
11559: PPUSH
11560: LD_VAR 0 1
11564: PUSH
11565: LD_INT 2
11567: ARRAY
11568: PPUSH
11569: LD_INT 1
11571: PPUSH
11572: CALL_OW 3
11576: PPUSH
11577: CALL_OW 1
11581: ST_TO_ADDR
// tmp := 1 ;
11582: LD_ADDR_VAR 0 2
11586: PUSH
11587: LD_STRING 1
11589: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
11590: LD_ADDR_VAR 0 4
11594: PUSH
11595: LD_VAR 0 4
11599: PUSH
11600: LD_VAR 0 2
11604: STR
11605: ST_TO_ADDR
// end ;
11606: GO 11502
11608: POP
11609: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
11610: LD_STRING getStreamItemsFromMission("
11612: PUSH
11613: LD_VAR 0 3
11617: STR
11618: PUSH
11619: LD_STRING ","
11621: STR
11622: PUSH
11623: LD_VAR 0 4
11627: STR
11628: PUSH
11629: LD_STRING ")
11631: STR
11632: PPUSH
11633: CALL_OW 559
// end else
11637: GO 11646
// ToLua ( getStreamItemsFromMission("","") ) ;
11639: LD_STRING getStreamItemsFromMission("","")
11641: PPUSH
11642: CALL_OW 559
// end ;
11646: LD_VAR 0 1
11650: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
11651: LD_VAR 0 2
11655: PUSH
11656: LD_INT 100
11658: EQUAL
11659: IFFALSE 12608
// begin if not StreamModeActive then
11661: LD_EXP 34
11665: NOT
11666: IFFALSE 11676
// StreamModeActive := true ;
11668: LD_ADDR_EXP 34
11672: PUSH
11673: LD_INT 1
11675: ST_TO_ADDR
// if p3 = 0 then
11676: LD_VAR 0 3
11680: PUSH
11681: LD_INT 0
11683: EQUAL
11684: IFFALSE 11690
// InitStreamMode ;
11686: CALL 7911 0 0
// if p3 = 1 then
11690: LD_VAR 0 3
11694: PUSH
11695: LD_INT 1
11697: EQUAL
11698: IFFALSE 11708
// sRocket := true ;
11700: LD_ADDR_EXP 39
11704: PUSH
11705: LD_INT 1
11707: ST_TO_ADDR
// if p3 = 2 then
11708: LD_VAR 0 3
11712: PUSH
11713: LD_INT 2
11715: EQUAL
11716: IFFALSE 11726
// sSpeed := true ;
11718: LD_ADDR_EXP 38
11722: PUSH
11723: LD_INT 1
11725: ST_TO_ADDR
// if p3 = 3 then
11726: LD_VAR 0 3
11730: PUSH
11731: LD_INT 3
11733: EQUAL
11734: IFFALSE 11744
// sEngine := true ;
11736: LD_ADDR_EXP 40
11740: PUSH
11741: LD_INT 1
11743: ST_TO_ADDR
// if p3 = 4 then
11744: LD_VAR 0 3
11748: PUSH
11749: LD_INT 4
11751: EQUAL
11752: IFFALSE 11762
// sSpec := true ;
11754: LD_ADDR_EXP 37
11758: PUSH
11759: LD_INT 1
11761: ST_TO_ADDR
// if p3 = 5 then
11762: LD_VAR 0 3
11766: PUSH
11767: LD_INT 5
11769: EQUAL
11770: IFFALSE 11780
// sLevel := true ;
11772: LD_ADDR_EXP 41
11776: PUSH
11777: LD_INT 1
11779: ST_TO_ADDR
// if p3 = 6 then
11780: LD_VAR 0 3
11784: PUSH
11785: LD_INT 6
11787: EQUAL
11788: IFFALSE 11798
// sArmoury := true ;
11790: LD_ADDR_EXP 42
11794: PUSH
11795: LD_INT 1
11797: ST_TO_ADDR
// if p3 = 7 then
11798: LD_VAR 0 3
11802: PUSH
11803: LD_INT 7
11805: EQUAL
11806: IFFALSE 11816
// sRadar := true ;
11808: LD_ADDR_EXP 43
11812: PUSH
11813: LD_INT 1
11815: ST_TO_ADDR
// if p3 = 8 then
11816: LD_VAR 0 3
11820: PUSH
11821: LD_INT 8
11823: EQUAL
11824: IFFALSE 11834
// sBunker := true ;
11826: LD_ADDR_EXP 44
11830: PUSH
11831: LD_INT 1
11833: ST_TO_ADDR
// if p3 = 9 then
11834: LD_VAR 0 3
11838: PUSH
11839: LD_INT 9
11841: EQUAL
11842: IFFALSE 11852
// sHack := true ;
11844: LD_ADDR_EXP 45
11848: PUSH
11849: LD_INT 1
11851: ST_TO_ADDR
// if p3 = 10 then
11852: LD_VAR 0 3
11856: PUSH
11857: LD_INT 10
11859: EQUAL
11860: IFFALSE 11870
// sFire := true ;
11862: LD_ADDR_EXP 46
11866: PUSH
11867: LD_INT 1
11869: ST_TO_ADDR
// if p3 = 11 then
11870: LD_VAR 0 3
11874: PUSH
11875: LD_INT 11
11877: EQUAL
11878: IFFALSE 11888
// sRefresh := true ;
11880: LD_ADDR_EXP 47
11884: PUSH
11885: LD_INT 1
11887: ST_TO_ADDR
// if p3 = 12 then
11888: LD_VAR 0 3
11892: PUSH
11893: LD_INT 12
11895: EQUAL
11896: IFFALSE 11906
// sExp := true ;
11898: LD_ADDR_EXP 48
11902: PUSH
11903: LD_INT 1
11905: ST_TO_ADDR
// if p3 = 13 then
11906: LD_VAR 0 3
11910: PUSH
11911: LD_INT 13
11913: EQUAL
11914: IFFALSE 11924
// sDepot := true ;
11916: LD_ADDR_EXP 49
11920: PUSH
11921: LD_INT 1
11923: ST_TO_ADDR
// if p3 = 14 then
11924: LD_VAR 0 3
11928: PUSH
11929: LD_INT 14
11931: EQUAL
11932: IFFALSE 11942
// sFlag := true ;
11934: LD_ADDR_EXP 50
11938: PUSH
11939: LD_INT 1
11941: ST_TO_ADDR
// if p3 = 15 then
11942: LD_VAR 0 3
11946: PUSH
11947: LD_INT 15
11949: EQUAL
11950: IFFALSE 11960
// sKamikadze := true ;
11952: LD_ADDR_EXP 58
11956: PUSH
11957: LD_INT 1
11959: ST_TO_ADDR
// if p3 = 16 then
11960: LD_VAR 0 3
11964: PUSH
11965: LD_INT 16
11967: EQUAL
11968: IFFALSE 11978
// sTroll := true ;
11970: LD_ADDR_EXP 59
11974: PUSH
11975: LD_INT 1
11977: ST_TO_ADDR
// if p3 = 17 then
11978: LD_VAR 0 3
11982: PUSH
11983: LD_INT 17
11985: EQUAL
11986: IFFALSE 11996
// sSlow := true ;
11988: LD_ADDR_EXP 60
11992: PUSH
11993: LD_INT 1
11995: ST_TO_ADDR
// if p3 = 18 then
11996: LD_VAR 0 3
12000: PUSH
12001: LD_INT 18
12003: EQUAL
12004: IFFALSE 12014
// sLack := true ;
12006: LD_ADDR_EXP 61
12010: PUSH
12011: LD_INT 1
12013: ST_TO_ADDR
// if p3 = 19 then
12014: LD_VAR 0 3
12018: PUSH
12019: LD_INT 19
12021: EQUAL
12022: IFFALSE 12032
// sTank := true ;
12024: LD_ADDR_EXP 63
12028: PUSH
12029: LD_INT 1
12031: ST_TO_ADDR
// if p3 = 20 then
12032: LD_VAR 0 3
12036: PUSH
12037: LD_INT 20
12039: EQUAL
12040: IFFALSE 12050
// sRemote := true ;
12042: LD_ADDR_EXP 64
12046: PUSH
12047: LD_INT 1
12049: ST_TO_ADDR
// if p3 = 21 then
12050: LD_VAR 0 3
12054: PUSH
12055: LD_INT 21
12057: EQUAL
12058: IFFALSE 12068
// sPowell := true ;
12060: LD_ADDR_EXP 65
12064: PUSH
12065: LD_INT 1
12067: ST_TO_ADDR
// if p3 = 22 then
12068: LD_VAR 0 3
12072: PUSH
12073: LD_INT 22
12075: EQUAL
12076: IFFALSE 12086
// sTeleport := true ;
12078: LD_ADDR_EXP 68
12082: PUSH
12083: LD_INT 1
12085: ST_TO_ADDR
// if p3 = 23 then
12086: LD_VAR 0 3
12090: PUSH
12091: LD_INT 23
12093: EQUAL
12094: IFFALSE 12104
// sOilTower := true ;
12096: LD_ADDR_EXP 70
12100: PUSH
12101: LD_INT 1
12103: ST_TO_ADDR
// if p3 = 24 then
12104: LD_VAR 0 3
12108: PUSH
12109: LD_INT 24
12111: EQUAL
12112: IFFALSE 12122
// sShovel := true ;
12114: LD_ADDR_EXP 71
12118: PUSH
12119: LD_INT 1
12121: ST_TO_ADDR
// if p3 = 25 then
12122: LD_VAR 0 3
12126: PUSH
12127: LD_INT 25
12129: EQUAL
12130: IFFALSE 12140
// sSheik := true ;
12132: LD_ADDR_EXP 72
12136: PUSH
12137: LD_INT 1
12139: ST_TO_ADDR
// if p3 = 26 then
12140: LD_VAR 0 3
12144: PUSH
12145: LD_INT 26
12147: EQUAL
12148: IFFALSE 12158
// sEarthquake := true ;
12150: LD_ADDR_EXP 74
12154: PUSH
12155: LD_INT 1
12157: ST_TO_ADDR
// if p3 = 27 then
12158: LD_VAR 0 3
12162: PUSH
12163: LD_INT 27
12165: EQUAL
12166: IFFALSE 12176
// sAI := true ;
12168: LD_ADDR_EXP 75
12172: PUSH
12173: LD_INT 1
12175: ST_TO_ADDR
// if p3 = 28 then
12176: LD_VAR 0 3
12180: PUSH
12181: LD_INT 28
12183: EQUAL
12184: IFFALSE 12194
// sCargo := true ;
12186: LD_ADDR_EXP 78
12190: PUSH
12191: LD_INT 1
12193: ST_TO_ADDR
// if p3 = 29 then
12194: LD_VAR 0 3
12198: PUSH
12199: LD_INT 29
12201: EQUAL
12202: IFFALSE 12212
// sDLaser := true ;
12204: LD_ADDR_EXP 79
12208: PUSH
12209: LD_INT 1
12211: ST_TO_ADDR
// if p3 = 30 then
12212: LD_VAR 0 3
12216: PUSH
12217: LD_INT 30
12219: EQUAL
12220: IFFALSE 12230
// sExchange := true ;
12222: LD_ADDR_EXP 80
12226: PUSH
12227: LD_INT 1
12229: ST_TO_ADDR
// if p3 = 31 then
12230: LD_VAR 0 3
12234: PUSH
12235: LD_INT 31
12237: EQUAL
12238: IFFALSE 12248
// sFac := true ;
12240: LD_ADDR_EXP 81
12244: PUSH
12245: LD_INT 1
12247: ST_TO_ADDR
// if p3 = 32 then
12248: LD_VAR 0 3
12252: PUSH
12253: LD_INT 32
12255: EQUAL
12256: IFFALSE 12266
// sPower := true ;
12258: LD_ADDR_EXP 82
12262: PUSH
12263: LD_INT 1
12265: ST_TO_ADDR
// if p3 = 33 then
12266: LD_VAR 0 3
12270: PUSH
12271: LD_INT 33
12273: EQUAL
12274: IFFALSE 12284
// sRandom := true ;
12276: LD_ADDR_EXP 83
12280: PUSH
12281: LD_INT 1
12283: ST_TO_ADDR
// if p3 = 34 then
12284: LD_VAR 0 3
12288: PUSH
12289: LD_INT 34
12291: EQUAL
12292: IFFALSE 12302
// sShield := true ;
12294: LD_ADDR_EXP 84
12298: PUSH
12299: LD_INT 1
12301: ST_TO_ADDR
// if p3 = 35 then
12302: LD_VAR 0 3
12306: PUSH
12307: LD_INT 35
12309: EQUAL
12310: IFFALSE 12320
// sTime := true ;
12312: LD_ADDR_EXP 85
12316: PUSH
12317: LD_INT 1
12319: ST_TO_ADDR
// if p3 = 36 then
12320: LD_VAR 0 3
12324: PUSH
12325: LD_INT 36
12327: EQUAL
12328: IFFALSE 12338
// sTools := true ;
12330: LD_ADDR_EXP 86
12334: PUSH
12335: LD_INT 1
12337: ST_TO_ADDR
// if p3 = 101 then
12338: LD_VAR 0 3
12342: PUSH
12343: LD_INT 101
12345: EQUAL
12346: IFFALSE 12356
// sSold := true ;
12348: LD_ADDR_EXP 51
12352: PUSH
12353: LD_INT 1
12355: ST_TO_ADDR
// if p3 = 102 then
12356: LD_VAR 0 3
12360: PUSH
12361: LD_INT 102
12363: EQUAL
12364: IFFALSE 12374
// sDiff := true ;
12366: LD_ADDR_EXP 52
12370: PUSH
12371: LD_INT 1
12373: ST_TO_ADDR
// if p3 = 103 then
12374: LD_VAR 0 3
12378: PUSH
12379: LD_INT 103
12381: EQUAL
12382: IFFALSE 12392
// sFog := true ;
12384: LD_ADDR_EXP 55
12388: PUSH
12389: LD_INT 1
12391: ST_TO_ADDR
// if p3 = 104 then
12392: LD_VAR 0 3
12396: PUSH
12397: LD_INT 104
12399: EQUAL
12400: IFFALSE 12410
// sReset := true ;
12402: LD_ADDR_EXP 56
12406: PUSH
12407: LD_INT 1
12409: ST_TO_ADDR
// if p3 = 105 then
12410: LD_VAR 0 3
12414: PUSH
12415: LD_INT 105
12417: EQUAL
12418: IFFALSE 12428
// sSun := true ;
12420: LD_ADDR_EXP 57
12424: PUSH
12425: LD_INT 1
12427: ST_TO_ADDR
// if p3 = 106 then
12428: LD_VAR 0 3
12432: PUSH
12433: LD_INT 106
12435: EQUAL
12436: IFFALSE 12446
// sTiger := true ;
12438: LD_ADDR_EXP 53
12442: PUSH
12443: LD_INT 1
12445: ST_TO_ADDR
// if p3 = 107 then
12446: LD_VAR 0 3
12450: PUSH
12451: LD_INT 107
12453: EQUAL
12454: IFFALSE 12464
// sBomb := true ;
12456: LD_ADDR_EXP 54
12460: PUSH
12461: LD_INT 1
12463: ST_TO_ADDR
// if p3 = 108 then
12464: LD_VAR 0 3
12468: PUSH
12469: LD_INT 108
12471: EQUAL
12472: IFFALSE 12482
// sWound := true ;
12474: LD_ADDR_EXP 62
12478: PUSH
12479: LD_INT 1
12481: ST_TO_ADDR
// if p3 = 109 then
12482: LD_VAR 0 3
12486: PUSH
12487: LD_INT 109
12489: EQUAL
12490: IFFALSE 12500
// sBetray := true ;
12492: LD_ADDR_EXP 66
12496: PUSH
12497: LD_INT 1
12499: ST_TO_ADDR
// if p3 = 110 then
12500: LD_VAR 0 3
12504: PUSH
12505: LD_INT 110
12507: EQUAL
12508: IFFALSE 12518
// sContamin := true ;
12510: LD_ADDR_EXP 67
12514: PUSH
12515: LD_INT 1
12517: ST_TO_ADDR
// if p3 = 111 then
12518: LD_VAR 0 3
12522: PUSH
12523: LD_INT 111
12525: EQUAL
12526: IFFALSE 12536
// sOil := true ;
12528: LD_ADDR_EXP 69
12532: PUSH
12533: LD_INT 1
12535: ST_TO_ADDR
// if p3 = 112 then
12536: LD_VAR 0 3
12540: PUSH
12541: LD_INT 112
12543: EQUAL
12544: IFFALSE 12554
// sStu := true ;
12546: LD_ADDR_EXP 73
12550: PUSH
12551: LD_INT 1
12553: ST_TO_ADDR
// if p3 = 113 then
12554: LD_VAR 0 3
12558: PUSH
12559: LD_INT 113
12561: EQUAL
12562: IFFALSE 12572
// sBazooka := true ;
12564: LD_ADDR_EXP 76
12568: PUSH
12569: LD_INT 1
12571: ST_TO_ADDR
// if p3 = 114 then
12572: LD_VAR 0 3
12576: PUSH
12577: LD_INT 114
12579: EQUAL
12580: IFFALSE 12590
// sMortar := true ;
12582: LD_ADDR_EXP 77
12586: PUSH
12587: LD_INT 1
12589: ST_TO_ADDR
// if p3 = 115 then
12590: LD_VAR 0 3
12594: PUSH
12595: LD_INT 115
12597: EQUAL
12598: IFFALSE 12608
// sRanger := true ;
12600: LD_ADDR_EXP 87
12604: PUSH
12605: LD_INT 1
12607: ST_TO_ADDR
// end ; end ;
12608: PPOPN 6
12610: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
12611: LD_EXP 34
12615: PUSH
12616: LD_EXP 39
12620: AND
12621: IFFALSE 12745
12623: GO 12625
12625: DISABLE
12626: LD_INT 0
12628: PPUSH
12629: PPUSH
// begin enable ;
12630: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
12631: LD_ADDR_VAR 0 2
12635: PUSH
12636: LD_INT 22
12638: PUSH
12639: LD_OWVAR 2
12643: PUSH
12644: EMPTY
12645: LIST
12646: LIST
12647: PUSH
12648: LD_INT 2
12650: PUSH
12651: LD_INT 34
12653: PUSH
12654: LD_INT 7
12656: PUSH
12657: EMPTY
12658: LIST
12659: LIST
12660: PUSH
12661: LD_INT 34
12663: PUSH
12664: LD_INT 45
12666: PUSH
12667: EMPTY
12668: LIST
12669: LIST
12670: PUSH
12671: LD_INT 34
12673: PUSH
12674: LD_INT 28
12676: PUSH
12677: EMPTY
12678: LIST
12679: LIST
12680: PUSH
12681: LD_INT 34
12683: PUSH
12684: LD_INT 47
12686: PUSH
12687: EMPTY
12688: LIST
12689: LIST
12690: PUSH
12691: EMPTY
12692: LIST
12693: LIST
12694: LIST
12695: LIST
12696: LIST
12697: PUSH
12698: EMPTY
12699: LIST
12700: LIST
12701: PPUSH
12702: CALL_OW 69
12706: ST_TO_ADDR
// if not tmp then
12707: LD_VAR 0 2
12711: NOT
12712: IFFALSE 12716
// exit ;
12714: GO 12745
// for i in tmp do
12716: LD_ADDR_VAR 0 1
12720: PUSH
12721: LD_VAR 0 2
12725: PUSH
12726: FOR_IN
12727: IFFALSE 12743
// begin SetLives ( i , 0 ) ;
12729: LD_VAR 0 1
12733: PPUSH
12734: LD_INT 0
12736: PPUSH
12737: CALL_OW 234
// end ;
12741: GO 12726
12743: POP
12744: POP
// end ;
12745: PPOPN 2
12747: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
12748: LD_EXP 34
12752: PUSH
12753: LD_EXP 40
12757: AND
12758: IFFALSE 12842
12760: GO 12762
12762: DISABLE
12763: LD_INT 0
12765: PPUSH
12766: PPUSH
// begin enable ;
12767: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
12768: LD_ADDR_VAR 0 2
12772: PUSH
12773: LD_INT 22
12775: PUSH
12776: LD_OWVAR 2
12780: PUSH
12781: EMPTY
12782: LIST
12783: LIST
12784: PUSH
12785: LD_INT 32
12787: PUSH
12788: LD_INT 3
12790: PUSH
12791: EMPTY
12792: LIST
12793: LIST
12794: PUSH
12795: EMPTY
12796: LIST
12797: LIST
12798: PPUSH
12799: CALL_OW 69
12803: ST_TO_ADDR
// if not tmp then
12804: LD_VAR 0 2
12808: NOT
12809: IFFALSE 12813
// exit ;
12811: GO 12842
// for i in tmp do
12813: LD_ADDR_VAR 0 1
12817: PUSH
12818: LD_VAR 0 2
12822: PUSH
12823: FOR_IN
12824: IFFALSE 12840
// begin SetLives ( i , 0 ) ;
12826: LD_VAR 0 1
12830: PPUSH
12831: LD_INT 0
12833: PPUSH
12834: CALL_OW 234
// end ;
12838: GO 12823
12840: POP
12841: POP
// end ;
12842: PPOPN 2
12844: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
12845: LD_EXP 34
12849: PUSH
12850: LD_EXP 37
12854: AND
12855: IFFALSE 12948
12857: GO 12859
12859: DISABLE
12860: LD_INT 0
12862: PPUSH
// begin enable ;
12863: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
12864: LD_ADDR_VAR 0 1
12868: PUSH
12869: LD_INT 22
12871: PUSH
12872: LD_OWVAR 2
12876: PUSH
12877: EMPTY
12878: LIST
12879: LIST
12880: PUSH
12881: LD_INT 2
12883: PUSH
12884: LD_INT 25
12886: PUSH
12887: LD_INT 5
12889: PUSH
12890: EMPTY
12891: LIST
12892: LIST
12893: PUSH
12894: LD_INT 25
12896: PUSH
12897: LD_INT 9
12899: PUSH
12900: EMPTY
12901: LIST
12902: LIST
12903: PUSH
12904: LD_INT 25
12906: PUSH
12907: LD_INT 8
12909: PUSH
12910: EMPTY
12911: LIST
12912: LIST
12913: PUSH
12914: EMPTY
12915: LIST
12916: LIST
12917: LIST
12918: LIST
12919: PUSH
12920: EMPTY
12921: LIST
12922: LIST
12923: PPUSH
12924: CALL_OW 69
12928: PUSH
12929: FOR_IN
12930: IFFALSE 12946
// begin SetClass ( i , 1 ) ;
12932: LD_VAR 0 1
12936: PPUSH
12937: LD_INT 1
12939: PPUSH
12940: CALL_OW 336
// end ;
12944: GO 12929
12946: POP
12947: POP
// end ;
12948: PPOPN 1
12950: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
12951: LD_EXP 34
12955: PUSH
12956: LD_EXP 38
12960: AND
12961: PUSH
12962: LD_OWVAR 65
12966: PUSH
12967: LD_INT 7
12969: LESS
12970: AND
12971: IFFALSE 12985
12973: GO 12975
12975: DISABLE
// begin enable ;
12976: ENABLE
// game_speed := 7 ;
12977: LD_ADDR_OWVAR 65
12981: PUSH
12982: LD_INT 7
12984: ST_TO_ADDR
// end ;
12985: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
12986: LD_EXP 34
12990: PUSH
12991: LD_EXP 41
12995: AND
12996: IFFALSE 13198
12998: GO 13000
13000: DISABLE
13001: LD_INT 0
13003: PPUSH
13004: PPUSH
13005: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
13006: LD_ADDR_VAR 0 3
13010: PUSH
13011: LD_INT 81
13013: PUSH
13014: LD_OWVAR 2
13018: PUSH
13019: EMPTY
13020: LIST
13021: LIST
13022: PUSH
13023: LD_INT 21
13025: PUSH
13026: LD_INT 1
13028: PUSH
13029: EMPTY
13030: LIST
13031: LIST
13032: PUSH
13033: EMPTY
13034: LIST
13035: LIST
13036: PPUSH
13037: CALL_OW 69
13041: ST_TO_ADDR
// if not tmp then
13042: LD_VAR 0 3
13046: NOT
13047: IFFALSE 13051
// exit ;
13049: GO 13198
// if tmp > 5 then
13051: LD_VAR 0 3
13055: PUSH
13056: LD_INT 5
13058: GREATER
13059: IFFALSE 13071
// k := 5 else
13061: LD_ADDR_VAR 0 2
13065: PUSH
13066: LD_INT 5
13068: ST_TO_ADDR
13069: GO 13081
// k := tmp ;
13071: LD_ADDR_VAR 0 2
13075: PUSH
13076: LD_VAR 0 3
13080: ST_TO_ADDR
// for i := 1 to k do
13081: LD_ADDR_VAR 0 1
13085: PUSH
13086: DOUBLE
13087: LD_INT 1
13089: DEC
13090: ST_TO_ADDR
13091: LD_VAR 0 2
13095: PUSH
13096: FOR_TO
13097: IFFALSE 13196
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
13099: LD_VAR 0 3
13103: PUSH
13104: LD_VAR 0 1
13108: ARRAY
13109: PPUSH
13110: LD_VAR 0 1
13114: PUSH
13115: LD_INT 4
13117: MOD
13118: PUSH
13119: LD_INT 1
13121: PLUS
13122: PPUSH
13123: CALL_OW 259
13127: PUSH
13128: LD_INT 10
13130: LESS
13131: IFFALSE 13194
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
13133: LD_VAR 0 3
13137: PUSH
13138: LD_VAR 0 1
13142: ARRAY
13143: PPUSH
13144: LD_VAR 0 1
13148: PUSH
13149: LD_INT 4
13151: MOD
13152: PUSH
13153: LD_INT 1
13155: PLUS
13156: PPUSH
13157: LD_VAR 0 3
13161: PUSH
13162: LD_VAR 0 1
13166: ARRAY
13167: PPUSH
13168: LD_VAR 0 1
13172: PUSH
13173: LD_INT 4
13175: MOD
13176: PUSH
13177: LD_INT 1
13179: PLUS
13180: PPUSH
13181: CALL_OW 259
13185: PUSH
13186: LD_INT 1
13188: PLUS
13189: PPUSH
13190: CALL_OW 237
13194: GO 13096
13196: POP
13197: POP
// end ;
13198: PPOPN 3
13200: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
13201: LD_EXP 34
13205: PUSH
13206: LD_EXP 42
13210: AND
13211: IFFALSE 13231
13213: GO 13215
13215: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
13216: LD_INT 4
13218: PPUSH
13219: LD_OWVAR 2
13223: PPUSH
13224: LD_INT 0
13226: PPUSH
13227: CALL_OW 324
13231: END
// every 0 0$1 trigger StreamModeActive and sShovel do
13232: LD_EXP 34
13236: PUSH
13237: LD_EXP 71
13241: AND
13242: IFFALSE 13262
13244: GO 13246
13246: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
13247: LD_INT 19
13249: PPUSH
13250: LD_OWVAR 2
13254: PPUSH
13255: LD_INT 0
13257: PPUSH
13258: CALL_OW 324
13262: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
13263: LD_EXP 34
13267: PUSH
13268: LD_EXP 43
13272: AND
13273: IFFALSE 13375
13275: GO 13277
13277: DISABLE
13278: LD_INT 0
13280: PPUSH
13281: PPUSH
// begin enable ;
13282: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
13283: LD_ADDR_VAR 0 2
13287: PUSH
13288: LD_INT 22
13290: PUSH
13291: LD_OWVAR 2
13295: PUSH
13296: EMPTY
13297: LIST
13298: LIST
13299: PUSH
13300: LD_INT 2
13302: PUSH
13303: LD_INT 34
13305: PUSH
13306: LD_INT 11
13308: PUSH
13309: EMPTY
13310: LIST
13311: LIST
13312: PUSH
13313: LD_INT 34
13315: PUSH
13316: LD_INT 30
13318: PUSH
13319: EMPTY
13320: LIST
13321: LIST
13322: PUSH
13323: EMPTY
13324: LIST
13325: LIST
13326: LIST
13327: PUSH
13328: EMPTY
13329: LIST
13330: LIST
13331: PPUSH
13332: CALL_OW 69
13336: ST_TO_ADDR
// if not tmp then
13337: LD_VAR 0 2
13341: NOT
13342: IFFALSE 13346
// exit ;
13344: GO 13375
// for i in tmp do
13346: LD_ADDR_VAR 0 1
13350: PUSH
13351: LD_VAR 0 2
13355: PUSH
13356: FOR_IN
13357: IFFALSE 13373
// begin SetLives ( i , 0 ) ;
13359: LD_VAR 0 1
13363: PPUSH
13364: LD_INT 0
13366: PPUSH
13367: CALL_OW 234
// end ;
13371: GO 13356
13373: POP
13374: POP
// end ;
13375: PPOPN 2
13377: END
// every 0 0$1 trigger StreamModeActive and sBunker do
13378: LD_EXP 34
13382: PUSH
13383: LD_EXP 44
13387: AND
13388: IFFALSE 13408
13390: GO 13392
13392: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
13393: LD_INT 32
13395: PPUSH
13396: LD_OWVAR 2
13400: PPUSH
13401: LD_INT 0
13403: PPUSH
13404: CALL_OW 324
13408: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
13409: LD_EXP 34
13413: PUSH
13414: LD_EXP 45
13418: AND
13419: IFFALSE 13600
13421: GO 13423
13423: DISABLE
13424: LD_INT 0
13426: PPUSH
13427: PPUSH
13428: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
13429: LD_ADDR_VAR 0 2
13433: PUSH
13434: LD_INT 22
13436: PUSH
13437: LD_OWVAR 2
13441: PUSH
13442: EMPTY
13443: LIST
13444: LIST
13445: PUSH
13446: LD_INT 33
13448: PUSH
13449: LD_INT 3
13451: PUSH
13452: EMPTY
13453: LIST
13454: LIST
13455: PUSH
13456: EMPTY
13457: LIST
13458: LIST
13459: PPUSH
13460: CALL_OW 69
13464: ST_TO_ADDR
// if not tmp then
13465: LD_VAR 0 2
13469: NOT
13470: IFFALSE 13474
// exit ;
13472: GO 13600
// side := 0 ;
13474: LD_ADDR_VAR 0 3
13478: PUSH
13479: LD_INT 0
13481: ST_TO_ADDR
// for i := 1 to 8 do
13482: LD_ADDR_VAR 0 1
13486: PUSH
13487: DOUBLE
13488: LD_INT 1
13490: DEC
13491: ST_TO_ADDR
13492: LD_INT 8
13494: PUSH
13495: FOR_TO
13496: IFFALSE 13544
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
13498: LD_OWVAR 2
13502: PUSH
13503: LD_VAR 0 1
13507: NONEQUAL
13508: PUSH
13509: LD_OWVAR 2
13513: PPUSH
13514: LD_VAR 0 1
13518: PPUSH
13519: CALL_OW 81
13523: PUSH
13524: LD_INT 2
13526: EQUAL
13527: AND
13528: IFFALSE 13542
// begin side := i ;
13530: LD_ADDR_VAR 0 3
13534: PUSH
13535: LD_VAR 0 1
13539: ST_TO_ADDR
// break ;
13540: GO 13544
// end ;
13542: GO 13495
13544: POP
13545: POP
// if not side then
13546: LD_VAR 0 3
13550: NOT
13551: IFFALSE 13555
// exit ;
13553: GO 13600
// for i := 1 to tmp do
13555: LD_ADDR_VAR 0 1
13559: PUSH
13560: DOUBLE
13561: LD_INT 1
13563: DEC
13564: ST_TO_ADDR
13565: LD_VAR 0 2
13569: PUSH
13570: FOR_TO
13571: IFFALSE 13598
// if Prob ( 60 ) then
13573: LD_INT 60
13575: PPUSH
13576: CALL_OW 13
13580: IFFALSE 13596
// SetSide ( i , side ) ;
13582: LD_VAR 0 1
13586: PPUSH
13587: LD_VAR 0 3
13591: PPUSH
13592: CALL_OW 235
13596: GO 13570
13598: POP
13599: POP
// end ;
13600: PPOPN 3
13602: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
13603: LD_EXP 34
13607: PUSH
13608: LD_EXP 47
13612: AND
13613: IFFALSE 13732
13615: GO 13617
13617: DISABLE
13618: LD_INT 0
13620: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
13621: LD_ADDR_VAR 0 1
13625: PUSH
13626: LD_INT 22
13628: PUSH
13629: LD_OWVAR 2
13633: PUSH
13634: EMPTY
13635: LIST
13636: LIST
13637: PUSH
13638: LD_INT 21
13640: PUSH
13641: LD_INT 1
13643: PUSH
13644: EMPTY
13645: LIST
13646: LIST
13647: PUSH
13648: LD_INT 3
13650: PUSH
13651: LD_INT 23
13653: PUSH
13654: LD_INT 0
13656: PUSH
13657: EMPTY
13658: LIST
13659: LIST
13660: PUSH
13661: EMPTY
13662: LIST
13663: LIST
13664: PUSH
13665: EMPTY
13666: LIST
13667: LIST
13668: LIST
13669: PPUSH
13670: CALL_OW 69
13674: PUSH
13675: FOR_IN
13676: IFFALSE 13730
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
13678: LD_VAR 0 1
13682: PPUSH
13683: CALL_OW 257
13687: PUSH
13688: LD_INT 1
13690: PUSH
13691: LD_INT 2
13693: PUSH
13694: LD_INT 3
13696: PUSH
13697: LD_INT 4
13699: PUSH
13700: EMPTY
13701: LIST
13702: LIST
13703: LIST
13704: LIST
13705: IN
13706: IFFALSE 13728
// SetClass ( un , rand ( 1 , 4 ) ) ;
13708: LD_VAR 0 1
13712: PPUSH
13713: LD_INT 1
13715: PPUSH
13716: LD_INT 4
13718: PPUSH
13719: CALL_OW 12
13723: PPUSH
13724: CALL_OW 336
13728: GO 13675
13730: POP
13731: POP
// end ;
13732: PPOPN 1
13734: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
13735: LD_EXP 34
13739: PUSH
13740: LD_EXP 46
13744: AND
13745: IFFALSE 13824
13747: GO 13749
13749: DISABLE
13750: LD_INT 0
13752: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
13753: LD_ADDR_VAR 0 1
13757: PUSH
13758: LD_INT 22
13760: PUSH
13761: LD_OWVAR 2
13765: PUSH
13766: EMPTY
13767: LIST
13768: LIST
13769: PUSH
13770: LD_INT 21
13772: PUSH
13773: LD_INT 3
13775: PUSH
13776: EMPTY
13777: LIST
13778: LIST
13779: PUSH
13780: EMPTY
13781: LIST
13782: LIST
13783: PPUSH
13784: CALL_OW 69
13788: ST_TO_ADDR
// if not tmp then
13789: LD_VAR 0 1
13793: NOT
13794: IFFALSE 13798
// exit ;
13796: GO 13824
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
13798: LD_VAR 0 1
13802: PUSH
13803: LD_INT 1
13805: PPUSH
13806: LD_VAR 0 1
13810: PPUSH
13811: CALL_OW 12
13815: ARRAY
13816: PPUSH
13817: LD_INT 100
13819: PPUSH
13820: CALL_OW 234
// end ;
13824: PPOPN 1
13826: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
13827: LD_EXP 34
13831: PUSH
13832: LD_EXP 48
13836: AND
13837: IFFALSE 13935
13839: GO 13841
13841: DISABLE
13842: LD_INT 0
13844: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
13845: LD_ADDR_VAR 0 1
13849: PUSH
13850: LD_INT 22
13852: PUSH
13853: LD_OWVAR 2
13857: PUSH
13858: EMPTY
13859: LIST
13860: LIST
13861: PUSH
13862: LD_INT 21
13864: PUSH
13865: LD_INT 1
13867: PUSH
13868: EMPTY
13869: LIST
13870: LIST
13871: PUSH
13872: EMPTY
13873: LIST
13874: LIST
13875: PPUSH
13876: CALL_OW 69
13880: ST_TO_ADDR
// if not tmp then
13881: LD_VAR 0 1
13885: NOT
13886: IFFALSE 13890
// exit ;
13888: GO 13935
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
13890: LD_VAR 0 1
13894: PUSH
13895: LD_INT 1
13897: PPUSH
13898: LD_VAR 0 1
13902: PPUSH
13903: CALL_OW 12
13907: ARRAY
13908: PPUSH
13909: LD_INT 1
13911: PPUSH
13912: LD_INT 4
13914: PPUSH
13915: CALL_OW 12
13919: PPUSH
13920: LD_INT 3000
13922: PPUSH
13923: LD_INT 9000
13925: PPUSH
13926: CALL_OW 12
13930: PPUSH
13931: CALL_OW 492
// end ;
13935: PPOPN 1
13937: END
// every 0 0$1 trigger StreamModeActive and sDepot do
13938: LD_EXP 34
13942: PUSH
13943: LD_EXP 49
13947: AND
13948: IFFALSE 13968
13950: GO 13952
13952: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
13953: LD_INT 1
13955: PPUSH
13956: LD_OWVAR 2
13960: PPUSH
13961: LD_INT 0
13963: PPUSH
13964: CALL_OW 324
13968: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
13969: LD_EXP 34
13973: PUSH
13974: LD_EXP 50
13978: AND
13979: IFFALSE 14062
13981: GO 13983
13983: DISABLE
13984: LD_INT 0
13986: PPUSH
13987: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
13988: LD_ADDR_VAR 0 2
13992: PUSH
13993: LD_INT 22
13995: PUSH
13996: LD_OWVAR 2
14000: PUSH
14001: EMPTY
14002: LIST
14003: LIST
14004: PUSH
14005: LD_INT 21
14007: PUSH
14008: LD_INT 3
14010: PUSH
14011: EMPTY
14012: LIST
14013: LIST
14014: PUSH
14015: EMPTY
14016: LIST
14017: LIST
14018: PPUSH
14019: CALL_OW 69
14023: ST_TO_ADDR
// if not tmp then
14024: LD_VAR 0 2
14028: NOT
14029: IFFALSE 14033
// exit ;
14031: GO 14062
// for i in tmp do
14033: LD_ADDR_VAR 0 1
14037: PUSH
14038: LD_VAR 0 2
14042: PUSH
14043: FOR_IN
14044: IFFALSE 14060
// SetBLevel ( i , 10 ) ;
14046: LD_VAR 0 1
14050: PPUSH
14051: LD_INT 10
14053: PPUSH
14054: CALL_OW 241
14058: GO 14043
14060: POP
14061: POP
// end ;
14062: PPOPN 2
14064: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
14065: LD_EXP 34
14069: PUSH
14070: LD_EXP 51
14074: AND
14075: IFFALSE 14186
14077: GO 14079
14079: DISABLE
14080: LD_INT 0
14082: PPUSH
14083: PPUSH
14084: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
14085: LD_ADDR_VAR 0 3
14089: PUSH
14090: LD_INT 22
14092: PUSH
14093: LD_OWVAR 2
14097: PUSH
14098: EMPTY
14099: LIST
14100: LIST
14101: PUSH
14102: LD_INT 25
14104: PUSH
14105: LD_INT 1
14107: PUSH
14108: EMPTY
14109: LIST
14110: LIST
14111: PUSH
14112: EMPTY
14113: LIST
14114: LIST
14115: PPUSH
14116: CALL_OW 69
14120: ST_TO_ADDR
// if not tmp then
14121: LD_VAR 0 3
14125: NOT
14126: IFFALSE 14130
// exit ;
14128: GO 14186
// un := tmp [ rand ( 1 , tmp ) ] ;
14130: LD_ADDR_VAR 0 2
14134: PUSH
14135: LD_VAR 0 3
14139: PUSH
14140: LD_INT 1
14142: PPUSH
14143: LD_VAR 0 3
14147: PPUSH
14148: CALL_OW 12
14152: ARRAY
14153: ST_TO_ADDR
// if Crawls ( un ) then
14154: LD_VAR 0 2
14158: PPUSH
14159: CALL_OW 318
14163: IFFALSE 14174
// ComWalk ( un ) ;
14165: LD_VAR 0 2
14169: PPUSH
14170: CALL_OW 138
// SetClass ( un , class_sniper ) ;
14174: LD_VAR 0 2
14178: PPUSH
14179: LD_INT 5
14181: PPUSH
14182: CALL_OW 336
// end ;
14186: PPOPN 3
14188: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
14189: LD_EXP 34
14193: PUSH
14194: LD_EXP 52
14198: AND
14199: PUSH
14200: LD_OWVAR 67
14204: PUSH
14205: LD_INT 3
14207: LESS
14208: AND
14209: IFFALSE 14228
14211: GO 14213
14213: DISABLE
// Difficulty := Difficulty + 1 ;
14214: LD_ADDR_OWVAR 67
14218: PUSH
14219: LD_OWVAR 67
14223: PUSH
14224: LD_INT 1
14226: PLUS
14227: ST_TO_ADDR
14228: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
14229: LD_EXP 34
14233: PUSH
14234: LD_EXP 53
14238: AND
14239: IFFALSE 14342
14241: GO 14243
14243: DISABLE
14244: LD_INT 0
14246: PPUSH
// begin for i := 1 to 5 do
14247: LD_ADDR_VAR 0 1
14251: PUSH
14252: DOUBLE
14253: LD_INT 1
14255: DEC
14256: ST_TO_ADDR
14257: LD_INT 5
14259: PUSH
14260: FOR_TO
14261: IFFALSE 14340
// begin uc_nation := nation_nature ;
14263: LD_ADDR_OWVAR 21
14267: PUSH
14268: LD_INT 0
14270: ST_TO_ADDR
// uc_side := 0 ;
14271: LD_ADDR_OWVAR 20
14275: PUSH
14276: LD_INT 0
14278: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
14279: LD_ADDR_OWVAR 29
14283: PUSH
14284: LD_INT 12
14286: PUSH
14287: LD_INT 12
14289: PUSH
14290: EMPTY
14291: LIST
14292: LIST
14293: ST_TO_ADDR
// hc_agressivity := 20 ;
14294: LD_ADDR_OWVAR 35
14298: PUSH
14299: LD_INT 20
14301: ST_TO_ADDR
// hc_class := class_tiger ;
14302: LD_ADDR_OWVAR 28
14306: PUSH
14307: LD_INT 14
14309: ST_TO_ADDR
// hc_gallery :=  ;
14310: LD_ADDR_OWVAR 33
14314: PUSH
14315: LD_STRING 
14317: ST_TO_ADDR
// hc_name :=  ;
14318: LD_ADDR_OWVAR 26
14322: PUSH
14323: LD_STRING 
14325: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
14326: CALL_OW 44
14330: PPUSH
14331: LD_INT 0
14333: PPUSH
14334: CALL_OW 51
// end ;
14338: GO 14260
14340: POP
14341: POP
// end ;
14342: PPOPN 1
14344: END
// every 0 0$1 trigger StreamModeActive and sBomb do
14345: LD_EXP 34
14349: PUSH
14350: LD_EXP 54
14354: AND
14355: IFFALSE 14364
14357: GO 14359
14359: DISABLE
// StreamSibBomb ;
14360: CALL 14365 0 0
14364: END
// export function StreamSibBomb ; var i , x , y ; begin
14365: LD_INT 0
14367: PPUSH
14368: PPUSH
14369: PPUSH
14370: PPUSH
// result := false ;
14371: LD_ADDR_VAR 0 1
14375: PUSH
14376: LD_INT 0
14378: ST_TO_ADDR
// for i := 1 to 16 do
14379: LD_ADDR_VAR 0 2
14383: PUSH
14384: DOUBLE
14385: LD_INT 1
14387: DEC
14388: ST_TO_ADDR
14389: LD_INT 16
14391: PUSH
14392: FOR_TO
14393: IFFALSE 14592
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
14395: LD_ADDR_VAR 0 3
14399: PUSH
14400: LD_INT 10
14402: PUSH
14403: LD_INT 20
14405: PUSH
14406: LD_INT 30
14408: PUSH
14409: LD_INT 40
14411: PUSH
14412: LD_INT 50
14414: PUSH
14415: LD_INT 60
14417: PUSH
14418: LD_INT 70
14420: PUSH
14421: LD_INT 80
14423: PUSH
14424: LD_INT 90
14426: PUSH
14427: LD_INT 100
14429: PUSH
14430: LD_INT 110
14432: PUSH
14433: LD_INT 120
14435: PUSH
14436: LD_INT 130
14438: PUSH
14439: LD_INT 140
14441: PUSH
14442: LD_INT 150
14444: PUSH
14445: EMPTY
14446: LIST
14447: LIST
14448: LIST
14449: LIST
14450: LIST
14451: LIST
14452: LIST
14453: LIST
14454: LIST
14455: LIST
14456: LIST
14457: LIST
14458: LIST
14459: LIST
14460: LIST
14461: PUSH
14462: LD_INT 1
14464: PPUSH
14465: LD_INT 15
14467: PPUSH
14468: CALL_OW 12
14472: ARRAY
14473: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
14474: LD_ADDR_VAR 0 4
14478: PUSH
14479: LD_INT 10
14481: PUSH
14482: LD_INT 20
14484: PUSH
14485: LD_INT 30
14487: PUSH
14488: LD_INT 40
14490: PUSH
14491: LD_INT 50
14493: PUSH
14494: LD_INT 60
14496: PUSH
14497: LD_INT 70
14499: PUSH
14500: LD_INT 80
14502: PUSH
14503: LD_INT 90
14505: PUSH
14506: LD_INT 100
14508: PUSH
14509: LD_INT 110
14511: PUSH
14512: LD_INT 120
14514: PUSH
14515: LD_INT 130
14517: PUSH
14518: LD_INT 140
14520: PUSH
14521: LD_INT 150
14523: PUSH
14524: EMPTY
14525: LIST
14526: LIST
14527: LIST
14528: LIST
14529: LIST
14530: LIST
14531: LIST
14532: LIST
14533: LIST
14534: LIST
14535: LIST
14536: LIST
14537: LIST
14538: LIST
14539: LIST
14540: PUSH
14541: LD_INT 1
14543: PPUSH
14544: LD_INT 15
14546: PPUSH
14547: CALL_OW 12
14551: ARRAY
14552: ST_TO_ADDR
// if ValidHex ( x , y ) then
14553: LD_VAR 0 3
14557: PPUSH
14558: LD_VAR 0 4
14562: PPUSH
14563: CALL_OW 488
14567: IFFALSE 14590
// begin result := [ x , y ] ;
14569: LD_ADDR_VAR 0 1
14573: PUSH
14574: LD_VAR 0 3
14578: PUSH
14579: LD_VAR 0 4
14583: PUSH
14584: EMPTY
14585: LIST
14586: LIST
14587: ST_TO_ADDR
// break ;
14588: GO 14592
// end ; end ;
14590: GO 14392
14592: POP
14593: POP
// if result then
14594: LD_VAR 0 1
14598: IFFALSE 14658
// begin ToLua ( playSibBomb() ) ;
14600: LD_STRING playSibBomb()
14602: PPUSH
14603: CALL_OW 559
// wait ( 0 0$14 ) ;
14607: LD_INT 490
14609: PPUSH
14610: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
14614: LD_VAR 0 1
14618: PUSH
14619: LD_INT 1
14621: ARRAY
14622: PPUSH
14623: LD_VAR 0 1
14627: PUSH
14628: LD_INT 2
14630: ARRAY
14631: PPUSH
14632: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
14636: LD_VAR 0 1
14640: PUSH
14641: LD_INT 1
14643: ARRAY
14644: PPUSH
14645: LD_VAR 0 1
14649: PUSH
14650: LD_INT 2
14652: ARRAY
14653: PPUSH
14654: CALL_OW 429
// end ; end ;
14658: LD_VAR 0 1
14662: RET
// every 0 0$1 trigger StreamModeActive and sReset do
14663: LD_EXP 34
14667: PUSH
14668: LD_EXP 56
14672: AND
14673: IFFALSE 14685
14675: GO 14677
14677: DISABLE
// YouLost (  ) ;
14678: LD_STRING 
14680: PPUSH
14681: CALL_OW 104
14685: END
// every 0 0$1 trigger StreamModeActive and sFog do
14686: LD_EXP 34
14690: PUSH
14691: LD_EXP 55
14695: AND
14696: IFFALSE 14710
14698: GO 14700
14700: DISABLE
// FogOff ( your_side ) ;
14701: LD_OWVAR 2
14705: PPUSH
14706: CALL_OW 344
14710: END
// every 0 0$1 trigger StreamModeActive and sSun do
14711: LD_EXP 34
14715: PUSH
14716: LD_EXP 57
14720: AND
14721: IFFALSE 14749
14723: GO 14725
14725: DISABLE
// begin solar_recharge_percent := 0 ;
14726: LD_ADDR_OWVAR 79
14730: PUSH
14731: LD_INT 0
14733: ST_TO_ADDR
// wait ( 5 5$00 ) ;
14734: LD_INT 10500
14736: PPUSH
14737: CALL_OW 67
// solar_recharge_percent := 100 ;
14741: LD_ADDR_OWVAR 79
14745: PUSH
14746: LD_INT 100
14748: ST_TO_ADDR
// end ;
14749: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
14750: LD_EXP 34
14754: PUSH
14755: LD_EXP 58
14759: AND
14760: IFFALSE 14999
14762: GO 14764
14764: DISABLE
14765: LD_INT 0
14767: PPUSH
14768: PPUSH
14769: PPUSH
// begin tmp := [ ] ;
14770: LD_ADDR_VAR 0 3
14774: PUSH
14775: EMPTY
14776: ST_TO_ADDR
// for i := 1 to 6 do
14777: LD_ADDR_VAR 0 1
14781: PUSH
14782: DOUBLE
14783: LD_INT 1
14785: DEC
14786: ST_TO_ADDR
14787: LD_INT 6
14789: PUSH
14790: FOR_TO
14791: IFFALSE 14896
// begin uc_nation := nation_nature ;
14793: LD_ADDR_OWVAR 21
14797: PUSH
14798: LD_INT 0
14800: ST_TO_ADDR
// uc_side := 0 ;
14801: LD_ADDR_OWVAR 20
14805: PUSH
14806: LD_INT 0
14808: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
14809: LD_ADDR_OWVAR 29
14813: PUSH
14814: LD_INT 12
14816: PUSH
14817: LD_INT 12
14819: PUSH
14820: EMPTY
14821: LIST
14822: LIST
14823: ST_TO_ADDR
// hc_agressivity := 20 ;
14824: LD_ADDR_OWVAR 35
14828: PUSH
14829: LD_INT 20
14831: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
14832: LD_ADDR_OWVAR 28
14836: PUSH
14837: LD_INT 17
14839: ST_TO_ADDR
// hc_gallery :=  ;
14840: LD_ADDR_OWVAR 33
14844: PUSH
14845: LD_STRING 
14847: ST_TO_ADDR
// hc_name :=  ;
14848: LD_ADDR_OWVAR 26
14852: PUSH
14853: LD_STRING 
14855: ST_TO_ADDR
// un := CreateHuman ;
14856: LD_ADDR_VAR 0 2
14860: PUSH
14861: CALL_OW 44
14865: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
14866: LD_VAR 0 2
14870: PPUSH
14871: LD_INT 1
14873: PPUSH
14874: CALL_OW 51
// tmp := tmp ^ un ;
14878: LD_ADDR_VAR 0 3
14882: PUSH
14883: LD_VAR 0 3
14887: PUSH
14888: LD_VAR 0 2
14892: ADD
14893: ST_TO_ADDR
// end ;
14894: GO 14790
14896: POP
14897: POP
// repeat wait ( 0 0$1 ) ;
14898: LD_INT 35
14900: PPUSH
14901: CALL_OW 67
// for un in tmp do
14905: LD_ADDR_VAR 0 2
14909: PUSH
14910: LD_VAR 0 3
14914: PUSH
14915: FOR_IN
14916: IFFALSE 14990
// begin if IsDead ( un ) then
14918: LD_VAR 0 2
14922: PPUSH
14923: CALL_OW 301
14927: IFFALSE 14947
// begin tmp := tmp diff un ;
14929: LD_ADDR_VAR 0 3
14933: PUSH
14934: LD_VAR 0 3
14938: PUSH
14939: LD_VAR 0 2
14943: DIFF
14944: ST_TO_ADDR
// continue ;
14945: GO 14915
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
14947: LD_VAR 0 2
14951: PPUSH
14952: LD_INT 3
14954: PUSH
14955: LD_INT 22
14957: PUSH
14958: LD_INT 0
14960: PUSH
14961: EMPTY
14962: LIST
14963: LIST
14964: PUSH
14965: EMPTY
14966: LIST
14967: LIST
14968: PPUSH
14969: CALL_OW 69
14973: PPUSH
14974: LD_VAR 0 2
14978: PPUSH
14979: CALL_OW 74
14983: PPUSH
14984: CALL_OW 115
// end ;
14988: GO 14915
14990: POP
14991: POP
// until not tmp ;
14992: LD_VAR 0 3
14996: NOT
14997: IFFALSE 14898
// end ;
14999: PPOPN 3
15001: END
// every 0 0$1 trigger StreamModeActive and sTroll do
15002: LD_EXP 34
15006: PUSH
15007: LD_EXP 59
15011: AND
15012: IFFALSE 15066
15014: GO 15016
15016: DISABLE
// begin ToLua ( displayTroll(); ) ;
15017: LD_STRING displayTroll();
15019: PPUSH
15020: CALL_OW 559
// wait ( 3 3$00 ) ;
15024: LD_INT 6300
15026: PPUSH
15027: CALL_OW 67
// ToLua ( hideTroll(); ) ;
15031: LD_STRING hideTroll();
15033: PPUSH
15034: CALL_OW 559
// wait ( 1 1$00 ) ;
15038: LD_INT 2100
15040: PPUSH
15041: CALL_OW 67
// ToLua ( displayTroll(); ) ;
15045: LD_STRING displayTroll();
15047: PPUSH
15048: CALL_OW 559
// wait ( 1 1$00 ) ;
15052: LD_INT 2100
15054: PPUSH
15055: CALL_OW 67
// ToLua ( hideTroll(); ) ;
15059: LD_STRING hideTroll();
15061: PPUSH
15062: CALL_OW 559
// end ;
15066: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
15067: LD_EXP 34
15071: PUSH
15072: LD_EXP 60
15076: AND
15077: IFFALSE 15140
15079: GO 15081
15081: DISABLE
15082: LD_INT 0
15084: PPUSH
// begin p := 0 ;
15085: LD_ADDR_VAR 0 1
15089: PUSH
15090: LD_INT 0
15092: ST_TO_ADDR
// repeat game_speed := 1 ;
15093: LD_ADDR_OWVAR 65
15097: PUSH
15098: LD_INT 1
15100: ST_TO_ADDR
// wait ( 0 0$1 ) ;
15101: LD_INT 35
15103: PPUSH
15104: CALL_OW 67
// p := p + 1 ;
15108: LD_ADDR_VAR 0 1
15112: PUSH
15113: LD_VAR 0 1
15117: PUSH
15118: LD_INT 1
15120: PLUS
15121: ST_TO_ADDR
// until p >= 60 ;
15122: LD_VAR 0 1
15126: PUSH
15127: LD_INT 60
15129: GREATEREQUAL
15130: IFFALSE 15093
// game_speed := 4 ;
15132: LD_ADDR_OWVAR 65
15136: PUSH
15137: LD_INT 4
15139: ST_TO_ADDR
// end ;
15140: PPOPN 1
15142: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
15143: LD_EXP 34
15147: PUSH
15148: LD_EXP 61
15152: AND
15153: IFFALSE 15299
15155: GO 15157
15157: DISABLE
15158: LD_INT 0
15160: PPUSH
15161: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
15162: LD_ADDR_VAR 0 1
15166: PUSH
15167: LD_INT 22
15169: PUSH
15170: LD_OWVAR 2
15174: PUSH
15175: EMPTY
15176: LIST
15177: LIST
15178: PUSH
15179: LD_INT 2
15181: PUSH
15182: LD_INT 30
15184: PUSH
15185: LD_INT 0
15187: PUSH
15188: EMPTY
15189: LIST
15190: LIST
15191: PUSH
15192: LD_INT 30
15194: PUSH
15195: LD_INT 1
15197: PUSH
15198: EMPTY
15199: LIST
15200: LIST
15201: PUSH
15202: EMPTY
15203: LIST
15204: LIST
15205: LIST
15206: PUSH
15207: EMPTY
15208: LIST
15209: LIST
15210: PPUSH
15211: CALL_OW 69
15215: ST_TO_ADDR
// if not depot then
15216: LD_VAR 0 1
15220: NOT
15221: IFFALSE 15225
// exit ;
15223: GO 15299
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
15225: LD_ADDR_VAR 0 2
15229: PUSH
15230: LD_VAR 0 1
15234: PUSH
15235: LD_INT 1
15237: PPUSH
15238: LD_VAR 0 1
15242: PPUSH
15243: CALL_OW 12
15247: ARRAY
15248: PPUSH
15249: CALL_OW 274
15253: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
15254: LD_VAR 0 2
15258: PPUSH
15259: LD_INT 1
15261: PPUSH
15262: LD_INT 0
15264: PPUSH
15265: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
15269: LD_VAR 0 2
15273: PPUSH
15274: LD_INT 2
15276: PPUSH
15277: LD_INT 0
15279: PPUSH
15280: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
15284: LD_VAR 0 2
15288: PPUSH
15289: LD_INT 3
15291: PPUSH
15292: LD_INT 0
15294: PPUSH
15295: CALL_OW 277
// end ;
15299: PPOPN 2
15301: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
15302: LD_EXP 34
15306: PUSH
15307: LD_EXP 62
15311: AND
15312: IFFALSE 15409
15314: GO 15316
15316: DISABLE
15317: LD_INT 0
15319: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
15320: LD_ADDR_VAR 0 1
15324: PUSH
15325: LD_INT 22
15327: PUSH
15328: LD_OWVAR 2
15332: PUSH
15333: EMPTY
15334: LIST
15335: LIST
15336: PUSH
15337: LD_INT 21
15339: PUSH
15340: LD_INT 1
15342: PUSH
15343: EMPTY
15344: LIST
15345: LIST
15346: PUSH
15347: LD_INT 3
15349: PUSH
15350: LD_INT 23
15352: PUSH
15353: LD_INT 0
15355: PUSH
15356: EMPTY
15357: LIST
15358: LIST
15359: PUSH
15360: EMPTY
15361: LIST
15362: LIST
15363: PUSH
15364: EMPTY
15365: LIST
15366: LIST
15367: LIST
15368: PPUSH
15369: CALL_OW 69
15373: ST_TO_ADDR
// if not tmp then
15374: LD_VAR 0 1
15378: NOT
15379: IFFALSE 15383
// exit ;
15381: GO 15409
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
15383: LD_VAR 0 1
15387: PUSH
15388: LD_INT 1
15390: PPUSH
15391: LD_VAR 0 1
15395: PPUSH
15396: CALL_OW 12
15400: ARRAY
15401: PPUSH
15402: LD_INT 200
15404: PPUSH
15405: CALL_OW 234
// end ;
15409: PPOPN 1
15411: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
15412: LD_EXP 34
15416: PUSH
15417: LD_EXP 63
15421: AND
15422: IFFALSE 15501
15424: GO 15426
15426: DISABLE
15427: LD_INT 0
15429: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
15430: LD_ADDR_VAR 0 1
15434: PUSH
15435: LD_INT 22
15437: PUSH
15438: LD_OWVAR 2
15442: PUSH
15443: EMPTY
15444: LIST
15445: LIST
15446: PUSH
15447: LD_INT 21
15449: PUSH
15450: LD_INT 2
15452: PUSH
15453: EMPTY
15454: LIST
15455: LIST
15456: PUSH
15457: EMPTY
15458: LIST
15459: LIST
15460: PPUSH
15461: CALL_OW 69
15465: ST_TO_ADDR
// if not tmp then
15466: LD_VAR 0 1
15470: NOT
15471: IFFALSE 15475
// exit ;
15473: GO 15501
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
15475: LD_VAR 0 1
15479: PUSH
15480: LD_INT 1
15482: PPUSH
15483: LD_VAR 0 1
15487: PPUSH
15488: CALL_OW 12
15492: ARRAY
15493: PPUSH
15494: LD_INT 60
15496: PPUSH
15497: CALL_OW 234
// end ;
15501: PPOPN 1
15503: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
15504: LD_EXP 34
15508: PUSH
15509: LD_EXP 64
15513: AND
15514: IFFALSE 15613
15516: GO 15518
15518: DISABLE
15519: LD_INT 0
15521: PPUSH
15522: PPUSH
// begin enable ;
15523: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
15524: LD_ADDR_VAR 0 1
15528: PUSH
15529: LD_INT 22
15531: PUSH
15532: LD_OWVAR 2
15536: PUSH
15537: EMPTY
15538: LIST
15539: LIST
15540: PUSH
15541: LD_INT 61
15543: PUSH
15544: EMPTY
15545: LIST
15546: PUSH
15547: LD_INT 33
15549: PUSH
15550: LD_INT 2
15552: PUSH
15553: EMPTY
15554: LIST
15555: LIST
15556: PUSH
15557: EMPTY
15558: LIST
15559: LIST
15560: LIST
15561: PPUSH
15562: CALL_OW 69
15566: ST_TO_ADDR
// if not tmp then
15567: LD_VAR 0 1
15571: NOT
15572: IFFALSE 15576
// exit ;
15574: GO 15613
// for i in tmp do
15576: LD_ADDR_VAR 0 2
15580: PUSH
15581: LD_VAR 0 1
15585: PUSH
15586: FOR_IN
15587: IFFALSE 15611
// if IsControledBy ( i ) then
15589: LD_VAR 0 2
15593: PPUSH
15594: CALL_OW 312
15598: IFFALSE 15609
// ComUnlink ( i ) ;
15600: LD_VAR 0 2
15604: PPUSH
15605: CALL_OW 136
15609: GO 15586
15611: POP
15612: POP
// end ;
15613: PPOPN 2
15615: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
15616: LD_EXP 34
15620: PUSH
15621: LD_EXP 65
15625: AND
15626: IFFALSE 15766
15628: GO 15630
15630: DISABLE
15631: LD_INT 0
15633: PPUSH
15634: PPUSH
// begin ToLua ( displayPowell(); ) ;
15635: LD_STRING displayPowell();
15637: PPUSH
15638: CALL_OW 559
// uc_side := 0 ;
15642: LD_ADDR_OWVAR 20
15646: PUSH
15647: LD_INT 0
15649: ST_TO_ADDR
// uc_nation := 2 ;
15650: LD_ADDR_OWVAR 21
15654: PUSH
15655: LD_INT 2
15657: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
15658: LD_ADDR_OWVAR 37
15662: PUSH
15663: LD_INT 14
15665: ST_TO_ADDR
// vc_engine := engine_siberite ;
15666: LD_ADDR_OWVAR 39
15670: PUSH
15671: LD_INT 3
15673: ST_TO_ADDR
// vc_control := control_apeman ;
15674: LD_ADDR_OWVAR 38
15678: PUSH
15679: LD_INT 5
15681: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
15682: LD_ADDR_OWVAR 40
15686: PUSH
15687: LD_INT 29
15689: ST_TO_ADDR
// un := CreateVehicle ;
15690: LD_ADDR_VAR 0 2
15694: PUSH
15695: CALL_OW 45
15699: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
15700: LD_VAR 0 2
15704: PPUSH
15705: LD_INT 1
15707: PPUSH
15708: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
15712: LD_INT 35
15714: PPUSH
15715: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
15719: LD_VAR 0 2
15723: PPUSH
15724: LD_INT 22
15726: PUSH
15727: LD_OWVAR 2
15731: PUSH
15732: EMPTY
15733: LIST
15734: LIST
15735: PPUSH
15736: CALL_OW 69
15740: PPUSH
15741: LD_VAR 0 2
15745: PPUSH
15746: CALL_OW 74
15750: PPUSH
15751: CALL_OW 115
// until IsDead ( un ) ;
15755: LD_VAR 0 2
15759: PPUSH
15760: CALL_OW 301
15764: IFFALSE 15712
// end ;
15766: PPOPN 2
15768: END
// every 0 0$1 trigger StreamModeActive and sStu do
15769: LD_EXP 34
15773: PUSH
15774: LD_EXP 73
15778: AND
15779: IFFALSE 15795
15781: GO 15783
15783: DISABLE
// begin ToLua ( displayStucuk(); ) ;
15784: LD_STRING displayStucuk();
15786: PPUSH
15787: CALL_OW 559
// ResetFog ;
15791: CALL_OW 335
// end ;
15795: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
15796: LD_EXP 34
15800: PUSH
15801: LD_EXP 66
15805: AND
15806: IFFALSE 15947
15808: GO 15810
15810: DISABLE
15811: LD_INT 0
15813: PPUSH
15814: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
15815: LD_ADDR_VAR 0 2
15819: PUSH
15820: LD_INT 22
15822: PUSH
15823: LD_OWVAR 2
15827: PUSH
15828: EMPTY
15829: LIST
15830: LIST
15831: PUSH
15832: LD_INT 21
15834: PUSH
15835: LD_INT 1
15837: PUSH
15838: EMPTY
15839: LIST
15840: LIST
15841: PUSH
15842: EMPTY
15843: LIST
15844: LIST
15845: PPUSH
15846: CALL_OW 69
15850: ST_TO_ADDR
// if not tmp then
15851: LD_VAR 0 2
15855: NOT
15856: IFFALSE 15860
// exit ;
15858: GO 15947
// un := tmp [ rand ( 1 , tmp ) ] ;
15860: LD_ADDR_VAR 0 1
15864: PUSH
15865: LD_VAR 0 2
15869: PUSH
15870: LD_INT 1
15872: PPUSH
15873: LD_VAR 0 2
15877: PPUSH
15878: CALL_OW 12
15882: ARRAY
15883: ST_TO_ADDR
// SetSide ( un , 0 ) ;
15884: LD_VAR 0 1
15888: PPUSH
15889: LD_INT 0
15891: PPUSH
15892: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
15896: LD_VAR 0 1
15900: PPUSH
15901: LD_OWVAR 3
15905: PUSH
15906: LD_VAR 0 1
15910: DIFF
15911: PPUSH
15912: LD_VAR 0 1
15916: PPUSH
15917: CALL_OW 74
15921: PPUSH
15922: CALL_OW 115
// wait ( 0 0$20 ) ;
15926: LD_INT 700
15928: PPUSH
15929: CALL_OW 67
// SetSide ( un , your_side ) ;
15933: LD_VAR 0 1
15937: PPUSH
15938: LD_OWVAR 2
15942: PPUSH
15943: CALL_OW 235
// end ;
15947: PPOPN 2
15949: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
15950: LD_EXP 34
15954: PUSH
15955: LD_EXP 67
15959: AND
15960: IFFALSE 16066
15962: GO 15964
15964: DISABLE
15965: LD_INT 0
15967: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
15968: LD_ADDR_VAR 0 1
15972: PUSH
15973: LD_INT 22
15975: PUSH
15976: LD_OWVAR 2
15980: PUSH
15981: EMPTY
15982: LIST
15983: LIST
15984: PUSH
15985: LD_INT 2
15987: PUSH
15988: LD_INT 30
15990: PUSH
15991: LD_INT 0
15993: PUSH
15994: EMPTY
15995: LIST
15996: LIST
15997: PUSH
15998: LD_INT 30
16000: PUSH
16001: LD_INT 1
16003: PUSH
16004: EMPTY
16005: LIST
16006: LIST
16007: PUSH
16008: EMPTY
16009: LIST
16010: LIST
16011: LIST
16012: PUSH
16013: EMPTY
16014: LIST
16015: LIST
16016: PPUSH
16017: CALL_OW 69
16021: ST_TO_ADDR
// if not depot then
16022: LD_VAR 0 1
16026: NOT
16027: IFFALSE 16031
// exit ;
16029: GO 16066
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
16031: LD_VAR 0 1
16035: PUSH
16036: LD_INT 1
16038: ARRAY
16039: PPUSH
16040: CALL_OW 250
16044: PPUSH
16045: LD_VAR 0 1
16049: PUSH
16050: LD_INT 1
16052: ARRAY
16053: PPUSH
16054: CALL_OW 251
16058: PPUSH
16059: LD_INT 70
16061: PPUSH
16062: CALL_OW 495
// end ;
16066: PPOPN 1
16068: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
16069: LD_EXP 34
16073: PUSH
16074: LD_EXP 68
16078: AND
16079: IFFALSE 16290
16081: GO 16083
16083: DISABLE
16084: LD_INT 0
16086: PPUSH
16087: PPUSH
16088: PPUSH
16089: PPUSH
16090: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
16091: LD_ADDR_VAR 0 5
16095: PUSH
16096: LD_INT 22
16098: PUSH
16099: LD_OWVAR 2
16103: PUSH
16104: EMPTY
16105: LIST
16106: LIST
16107: PUSH
16108: LD_INT 21
16110: PUSH
16111: LD_INT 1
16113: PUSH
16114: EMPTY
16115: LIST
16116: LIST
16117: PUSH
16118: EMPTY
16119: LIST
16120: LIST
16121: PPUSH
16122: CALL_OW 69
16126: ST_TO_ADDR
// if not tmp then
16127: LD_VAR 0 5
16131: NOT
16132: IFFALSE 16136
// exit ;
16134: GO 16290
// for i in tmp do
16136: LD_ADDR_VAR 0 1
16140: PUSH
16141: LD_VAR 0 5
16145: PUSH
16146: FOR_IN
16147: IFFALSE 16288
// begin d := rand ( 0 , 5 ) ;
16149: LD_ADDR_VAR 0 4
16153: PUSH
16154: LD_INT 0
16156: PPUSH
16157: LD_INT 5
16159: PPUSH
16160: CALL_OW 12
16164: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
16165: LD_ADDR_VAR 0 2
16169: PUSH
16170: LD_VAR 0 1
16174: PPUSH
16175: CALL_OW 250
16179: PPUSH
16180: LD_VAR 0 4
16184: PPUSH
16185: LD_INT 3
16187: PPUSH
16188: LD_INT 12
16190: PPUSH
16191: CALL_OW 12
16195: PPUSH
16196: CALL_OW 272
16200: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
16201: LD_ADDR_VAR 0 3
16205: PUSH
16206: LD_VAR 0 1
16210: PPUSH
16211: CALL_OW 251
16215: PPUSH
16216: LD_VAR 0 4
16220: PPUSH
16221: LD_INT 3
16223: PPUSH
16224: LD_INT 12
16226: PPUSH
16227: CALL_OW 12
16231: PPUSH
16232: CALL_OW 273
16236: ST_TO_ADDR
// if ValidHex ( x , y ) then
16237: LD_VAR 0 2
16241: PPUSH
16242: LD_VAR 0 3
16246: PPUSH
16247: CALL_OW 488
16251: IFFALSE 16286
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
16253: LD_VAR 0 1
16257: PPUSH
16258: LD_VAR 0 2
16262: PPUSH
16263: LD_VAR 0 3
16267: PPUSH
16268: LD_INT 3
16270: PPUSH
16271: LD_INT 6
16273: PPUSH
16274: CALL_OW 12
16278: PPUSH
16279: LD_INT 1
16281: PPUSH
16282: CALL_OW 483
// end ;
16286: GO 16146
16288: POP
16289: POP
// end ;
16290: PPOPN 5
16292: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
16293: LD_EXP 34
16297: PUSH
16298: LD_EXP 69
16302: AND
16303: IFFALSE 16397
16305: GO 16307
16307: DISABLE
16308: LD_INT 0
16310: PPUSH
16311: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
16312: LD_ADDR_VAR 0 2
16316: PUSH
16317: LD_INT 22
16319: PUSH
16320: LD_OWVAR 2
16324: PUSH
16325: EMPTY
16326: LIST
16327: LIST
16328: PUSH
16329: LD_INT 32
16331: PUSH
16332: LD_INT 1
16334: PUSH
16335: EMPTY
16336: LIST
16337: LIST
16338: PUSH
16339: LD_INT 21
16341: PUSH
16342: LD_INT 2
16344: PUSH
16345: EMPTY
16346: LIST
16347: LIST
16348: PUSH
16349: EMPTY
16350: LIST
16351: LIST
16352: LIST
16353: PPUSH
16354: CALL_OW 69
16358: ST_TO_ADDR
// if not tmp then
16359: LD_VAR 0 2
16363: NOT
16364: IFFALSE 16368
// exit ;
16366: GO 16397
// for i in tmp do
16368: LD_ADDR_VAR 0 1
16372: PUSH
16373: LD_VAR 0 2
16377: PUSH
16378: FOR_IN
16379: IFFALSE 16395
// SetFuel ( i , 0 ) ;
16381: LD_VAR 0 1
16385: PPUSH
16386: LD_INT 0
16388: PPUSH
16389: CALL_OW 240
16393: GO 16378
16395: POP
16396: POP
// end ;
16397: PPOPN 2
16399: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
16400: LD_EXP 34
16404: PUSH
16405: LD_EXP 70
16409: AND
16410: IFFALSE 16476
16412: GO 16414
16414: DISABLE
16415: LD_INT 0
16417: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
16418: LD_ADDR_VAR 0 1
16422: PUSH
16423: LD_INT 22
16425: PUSH
16426: LD_OWVAR 2
16430: PUSH
16431: EMPTY
16432: LIST
16433: LIST
16434: PUSH
16435: LD_INT 30
16437: PUSH
16438: LD_INT 29
16440: PUSH
16441: EMPTY
16442: LIST
16443: LIST
16444: PUSH
16445: EMPTY
16446: LIST
16447: LIST
16448: PPUSH
16449: CALL_OW 69
16453: ST_TO_ADDR
// if not tmp then
16454: LD_VAR 0 1
16458: NOT
16459: IFFALSE 16463
// exit ;
16461: GO 16476
// DestroyUnit ( tmp [ 1 ] ) ;
16463: LD_VAR 0 1
16467: PUSH
16468: LD_INT 1
16470: ARRAY
16471: PPUSH
16472: CALL_OW 65
// end ;
16476: PPOPN 1
16478: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
16479: LD_EXP 34
16483: PUSH
16484: LD_EXP 72
16488: AND
16489: IFFALSE 16618
16491: GO 16493
16493: DISABLE
16494: LD_INT 0
16496: PPUSH
// begin uc_side := 0 ;
16497: LD_ADDR_OWVAR 20
16501: PUSH
16502: LD_INT 0
16504: ST_TO_ADDR
// uc_nation := nation_arabian ;
16505: LD_ADDR_OWVAR 21
16509: PUSH
16510: LD_INT 2
16512: ST_TO_ADDR
// hc_gallery :=  ;
16513: LD_ADDR_OWVAR 33
16517: PUSH
16518: LD_STRING 
16520: ST_TO_ADDR
// hc_name :=  ;
16521: LD_ADDR_OWVAR 26
16525: PUSH
16526: LD_STRING 
16528: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
16529: LD_INT 1
16531: PPUSH
16532: LD_INT 11
16534: PPUSH
16535: LD_INT 10
16537: PPUSH
16538: CALL_OW 380
// un := CreateHuman ;
16542: LD_ADDR_VAR 0 1
16546: PUSH
16547: CALL_OW 44
16551: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
16552: LD_VAR 0 1
16556: PPUSH
16557: LD_INT 1
16559: PPUSH
16560: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
16564: LD_INT 35
16566: PPUSH
16567: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
16571: LD_VAR 0 1
16575: PPUSH
16576: LD_INT 22
16578: PUSH
16579: LD_OWVAR 2
16583: PUSH
16584: EMPTY
16585: LIST
16586: LIST
16587: PPUSH
16588: CALL_OW 69
16592: PPUSH
16593: LD_VAR 0 1
16597: PPUSH
16598: CALL_OW 74
16602: PPUSH
16603: CALL_OW 115
// until IsDead ( un ) ;
16607: LD_VAR 0 1
16611: PPUSH
16612: CALL_OW 301
16616: IFFALSE 16564
// end ;
16618: PPOPN 1
16620: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
16621: LD_EXP 34
16625: PUSH
16626: LD_EXP 74
16630: AND
16631: IFFALSE 16643
16633: GO 16635
16635: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
16636: LD_STRING earthquake(getX(game), 0, 32)
16638: PPUSH
16639: CALL_OW 559
16643: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
16644: LD_EXP 34
16648: PUSH
16649: LD_EXP 75
16653: AND
16654: IFFALSE 16745
16656: GO 16658
16658: DISABLE
16659: LD_INT 0
16661: PPUSH
// begin enable ;
16662: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
16663: LD_ADDR_VAR 0 1
16667: PUSH
16668: LD_INT 22
16670: PUSH
16671: LD_OWVAR 2
16675: PUSH
16676: EMPTY
16677: LIST
16678: LIST
16679: PUSH
16680: LD_INT 21
16682: PUSH
16683: LD_INT 2
16685: PUSH
16686: EMPTY
16687: LIST
16688: LIST
16689: PUSH
16690: LD_INT 33
16692: PUSH
16693: LD_INT 3
16695: PUSH
16696: EMPTY
16697: LIST
16698: LIST
16699: PUSH
16700: EMPTY
16701: LIST
16702: LIST
16703: LIST
16704: PPUSH
16705: CALL_OW 69
16709: ST_TO_ADDR
// if not tmp then
16710: LD_VAR 0 1
16714: NOT
16715: IFFALSE 16719
// exit ;
16717: GO 16745
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
16719: LD_VAR 0 1
16723: PUSH
16724: LD_INT 1
16726: PPUSH
16727: LD_VAR 0 1
16731: PPUSH
16732: CALL_OW 12
16736: ARRAY
16737: PPUSH
16738: LD_INT 1
16740: PPUSH
16741: CALL_OW 234
// end ;
16745: PPOPN 1
16747: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
16748: LD_EXP 34
16752: PUSH
16753: LD_EXP 76
16757: AND
16758: IFFALSE 16899
16760: GO 16762
16762: DISABLE
16763: LD_INT 0
16765: PPUSH
16766: PPUSH
16767: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
16768: LD_ADDR_VAR 0 3
16772: PUSH
16773: LD_INT 22
16775: PUSH
16776: LD_OWVAR 2
16780: PUSH
16781: EMPTY
16782: LIST
16783: LIST
16784: PUSH
16785: LD_INT 25
16787: PUSH
16788: LD_INT 1
16790: PUSH
16791: EMPTY
16792: LIST
16793: LIST
16794: PUSH
16795: EMPTY
16796: LIST
16797: LIST
16798: PPUSH
16799: CALL_OW 69
16803: ST_TO_ADDR
// if not tmp then
16804: LD_VAR 0 3
16808: NOT
16809: IFFALSE 16813
// exit ;
16811: GO 16899
// un := tmp [ rand ( 1 , tmp ) ] ;
16813: LD_ADDR_VAR 0 2
16817: PUSH
16818: LD_VAR 0 3
16822: PUSH
16823: LD_INT 1
16825: PPUSH
16826: LD_VAR 0 3
16830: PPUSH
16831: CALL_OW 12
16835: ARRAY
16836: ST_TO_ADDR
// if Crawls ( un ) then
16837: LD_VAR 0 2
16841: PPUSH
16842: CALL_OW 318
16846: IFFALSE 16857
// ComWalk ( un ) ;
16848: LD_VAR 0 2
16852: PPUSH
16853: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
16857: LD_VAR 0 2
16861: PPUSH
16862: LD_INT 9
16864: PPUSH
16865: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
16869: LD_INT 28
16871: PPUSH
16872: LD_OWVAR 2
16876: PPUSH
16877: LD_INT 2
16879: PPUSH
16880: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
16884: LD_INT 29
16886: PPUSH
16887: LD_OWVAR 2
16891: PPUSH
16892: LD_INT 2
16894: PPUSH
16895: CALL_OW 322
// end ;
16899: PPOPN 3
16901: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
16902: LD_EXP 34
16906: PUSH
16907: LD_EXP 77
16911: AND
16912: IFFALSE 17023
16914: GO 16916
16916: DISABLE
16917: LD_INT 0
16919: PPUSH
16920: PPUSH
16921: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
16922: LD_ADDR_VAR 0 3
16926: PUSH
16927: LD_INT 22
16929: PUSH
16930: LD_OWVAR 2
16934: PUSH
16935: EMPTY
16936: LIST
16937: LIST
16938: PUSH
16939: LD_INT 25
16941: PUSH
16942: LD_INT 1
16944: PUSH
16945: EMPTY
16946: LIST
16947: LIST
16948: PUSH
16949: EMPTY
16950: LIST
16951: LIST
16952: PPUSH
16953: CALL_OW 69
16957: ST_TO_ADDR
// if not tmp then
16958: LD_VAR 0 3
16962: NOT
16963: IFFALSE 16967
// exit ;
16965: GO 17023
// un := tmp [ rand ( 1 , tmp ) ] ;
16967: LD_ADDR_VAR 0 2
16971: PUSH
16972: LD_VAR 0 3
16976: PUSH
16977: LD_INT 1
16979: PPUSH
16980: LD_VAR 0 3
16984: PPUSH
16985: CALL_OW 12
16989: ARRAY
16990: ST_TO_ADDR
// if Crawls ( un ) then
16991: LD_VAR 0 2
16995: PPUSH
16996: CALL_OW 318
17000: IFFALSE 17011
// ComWalk ( un ) ;
17002: LD_VAR 0 2
17006: PPUSH
17007: CALL_OW 138
// SetClass ( un , class_mortar ) ;
17011: LD_VAR 0 2
17015: PPUSH
17016: LD_INT 8
17018: PPUSH
17019: CALL_OW 336
// end ;
17023: PPOPN 3
17025: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
17026: LD_EXP 34
17030: PUSH
17031: LD_EXP 78
17035: AND
17036: IFFALSE 17180
17038: GO 17040
17040: DISABLE
17041: LD_INT 0
17043: PPUSH
17044: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
17045: LD_ADDR_VAR 0 2
17049: PUSH
17050: LD_INT 22
17052: PUSH
17053: LD_OWVAR 2
17057: PUSH
17058: EMPTY
17059: LIST
17060: LIST
17061: PUSH
17062: LD_INT 21
17064: PUSH
17065: LD_INT 2
17067: PUSH
17068: EMPTY
17069: LIST
17070: LIST
17071: PUSH
17072: LD_INT 2
17074: PUSH
17075: LD_INT 34
17077: PUSH
17078: LD_INT 12
17080: PUSH
17081: EMPTY
17082: LIST
17083: LIST
17084: PUSH
17085: LD_INT 34
17087: PUSH
17088: LD_INT 51
17090: PUSH
17091: EMPTY
17092: LIST
17093: LIST
17094: PUSH
17095: LD_INT 34
17097: PUSH
17098: LD_INT 32
17100: PUSH
17101: EMPTY
17102: LIST
17103: LIST
17104: PUSH
17105: EMPTY
17106: LIST
17107: LIST
17108: LIST
17109: LIST
17110: PUSH
17111: EMPTY
17112: LIST
17113: LIST
17114: LIST
17115: PPUSH
17116: CALL_OW 69
17120: ST_TO_ADDR
// if not tmp then
17121: LD_VAR 0 2
17125: NOT
17126: IFFALSE 17130
// exit ;
17128: GO 17180
// for i in tmp do
17130: LD_ADDR_VAR 0 1
17134: PUSH
17135: LD_VAR 0 2
17139: PUSH
17140: FOR_IN
17141: IFFALSE 17178
// if GetCargo ( i , mat_artifact ) = 0 then
17143: LD_VAR 0 1
17147: PPUSH
17148: LD_INT 4
17150: PPUSH
17151: CALL_OW 289
17155: PUSH
17156: LD_INT 0
17158: EQUAL
17159: IFFALSE 17176
// SetCargo ( i , mat_siberit , 100 ) ;
17161: LD_VAR 0 1
17165: PPUSH
17166: LD_INT 3
17168: PPUSH
17169: LD_INT 100
17171: PPUSH
17172: CALL_OW 290
17176: GO 17140
17178: POP
17179: POP
// end ;
17180: PPOPN 2
17182: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
17183: LD_EXP 34
17187: PUSH
17188: LD_EXP 79
17192: AND
17193: IFFALSE 17346
17195: GO 17197
17197: DISABLE
17198: LD_INT 0
17200: PPUSH
17201: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
17202: LD_ADDR_VAR 0 2
17206: PUSH
17207: LD_INT 22
17209: PUSH
17210: LD_OWVAR 2
17214: PUSH
17215: EMPTY
17216: LIST
17217: LIST
17218: PPUSH
17219: CALL_OW 69
17223: ST_TO_ADDR
// if not tmp then
17224: LD_VAR 0 2
17228: NOT
17229: IFFALSE 17233
// exit ;
17231: GO 17346
// for i := 1 to 2 do
17233: LD_ADDR_VAR 0 1
17237: PUSH
17238: DOUBLE
17239: LD_INT 1
17241: DEC
17242: ST_TO_ADDR
17243: LD_INT 2
17245: PUSH
17246: FOR_TO
17247: IFFALSE 17344
// begin uc_side := your_side ;
17249: LD_ADDR_OWVAR 20
17253: PUSH
17254: LD_OWVAR 2
17258: ST_TO_ADDR
// uc_nation := nation_american ;
17259: LD_ADDR_OWVAR 21
17263: PUSH
17264: LD_INT 1
17266: ST_TO_ADDR
// vc_chassis := us_morphling ;
17267: LD_ADDR_OWVAR 37
17271: PUSH
17272: LD_INT 5
17274: ST_TO_ADDR
// vc_engine := engine_siberite ;
17275: LD_ADDR_OWVAR 39
17279: PUSH
17280: LD_INT 3
17282: ST_TO_ADDR
// vc_control := control_computer ;
17283: LD_ADDR_OWVAR 38
17287: PUSH
17288: LD_INT 3
17290: ST_TO_ADDR
// vc_weapon := us_double_laser ;
17291: LD_ADDR_OWVAR 40
17295: PUSH
17296: LD_INT 10
17298: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
17299: CALL_OW 45
17303: PPUSH
17304: LD_VAR 0 2
17308: PUSH
17309: LD_INT 1
17311: ARRAY
17312: PPUSH
17313: CALL_OW 250
17317: PPUSH
17318: LD_VAR 0 2
17322: PUSH
17323: LD_INT 1
17325: ARRAY
17326: PPUSH
17327: CALL_OW 251
17331: PPUSH
17332: LD_INT 12
17334: PPUSH
17335: LD_INT 1
17337: PPUSH
17338: CALL_OW 50
// end ;
17342: GO 17246
17344: POP
17345: POP
// end ;
17346: PPOPN 2
17348: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
17349: LD_EXP 34
17353: PUSH
17354: LD_EXP 80
17358: AND
17359: IFFALSE 17581
17361: GO 17363
17363: DISABLE
17364: LD_INT 0
17366: PPUSH
17367: PPUSH
17368: PPUSH
17369: PPUSH
17370: PPUSH
17371: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
17372: LD_ADDR_VAR 0 6
17376: PUSH
17377: LD_INT 22
17379: PUSH
17380: LD_OWVAR 2
17384: PUSH
17385: EMPTY
17386: LIST
17387: LIST
17388: PUSH
17389: LD_INT 21
17391: PUSH
17392: LD_INT 1
17394: PUSH
17395: EMPTY
17396: LIST
17397: LIST
17398: PUSH
17399: LD_INT 3
17401: PUSH
17402: LD_INT 23
17404: PUSH
17405: LD_INT 0
17407: PUSH
17408: EMPTY
17409: LIST
17410: LIST
17411: PUSH
17412: EMPTY
17413: LIST
17414: LIST
17415: PUSH
17416: EMPTY
17417: LIST
17418: LIST
17419: LIST
17420: PPUSH
17421: CALL_OW 69
17425: ST_TO_ADDR
// if not tmp then
17426: LD_VAR 0 6
17430: NOT
17431: IFFALSE 17435
// exit ;
17433: GO 17581
// s1 := rand ( 1 , 4 ) ;
17435: LD_ADDR_VAR 0 2
17439: PUSH
17440: LD_INT 1
17442: PPUSH
17443: LD_INT 4
17445: PPUSH
17446: CALL_OW 12
17450: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
17451: LD_ADDR_VAR 0 4
17455: PUSH
17456: LD_VAR 0 6
17460: PUSH
17461: LD_INT 1
17463: ARRAY
17464: PPUSH
17465: LD_VAR 0 2
17469: PPUSH
17470: CALL_OW 259
17474: ST_TO_ADDR
// if s1 = 1 then
17475: LD_VAR 0 2
17479: PUSH
17480: LD_INT 1
17482: EQUAL
17483: IFFALSE 17503
// s2 := rand ( 2 , 4 ) else
17485: LD_ADDR_VAR 0 3
17489: PUSH
17490: LD_INT 2
17492: PPUSH
17493: LD_INT 4
17495: PPUSH
17496: CALL_OW 12
17500: ST_TO_ADDR
17501: GO 17511
// s2 := 1 ;
17503: LD_ADDR_VAR 0 3
17507: PUSH
17508: LD_INT 1
17510: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
17511: LD_ADDR_VAR 0 5
17515: PUSH
17516: LD_VAR 0 6
17520: PUSH
17521: LD_INT 1
17523: ARRAY
17524: PPUSH
17525: LD_VAR 0 3
17529: PPUSH
17530: CALL_OW 259
17534: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
17535: LD_VAR 0 6
17539: PUSH
17540: LD_INT 1
17542: ARRAY
17543: PPUSH
17544: LD_VAR 0 2
17548: PPUSH
17549: LD_VAR 0 5
17553: PPUSH
17554: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
17558: LD_VAR 0 6
17562: PUSH
17563: LD_INT 1
17565: ARRAY
17566: PPUSH
17567: LD_VAR 0 3
17571: PPUSH
17572: LD_VAR 0 4
17576: PPUSH
17577: CALL_OW 237
// end ;
17581: PPOPN 6
17583: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
17584: LD_EXP 34
17588: PUSH
17589: LD_EXP 81
17593: AND
17594: IFFALSE 17673
17596: GO 17598
17598: DISABLE
17599: LD_INT 0
17601: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
17602: LD_ADDR_VAR 0 1
17606: PUSH
17607: LD_INT 22
17609: PUSH
17610: LD_OWVAR 2
17614: PUSH
17615: EMPTY
17616: LIST
17617: LIST
17618: PUSH
17619: LD_INT 30
17621: PUSH
17622: LD_INT 3
17624: PUSH
17625: EMPTY
17626: LIST
17627: LIST
17628: PUSH
17629: EMPTY
17630: LIST
17631: LIST
17632: PPUSH
17633: CALL_OW 69
17637: ST_TO_ADDR
// if not tmp then
17638: LD_VAR 0 1
17642: NOT
17643: IFFALSE 17647
// exit ;
17645: GO 17673
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
17647: LD_VAR 0 1
17651: PUSH
17652: LD_INT 1
17654: PPUSH
17655: LD_VAR 0 1
17659: PPUSH
17660: CALL_OW 12
17664: ARRAY
17665: PPUSH
17666: LD_INT 1
17668: PPUSH
17669: CALL_OW 234
// end ;
17673: PPOPN 1
17675: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
17676: LD_EXP 34
17680: PUSH
17681: LD_EXP 82
17685: AND
17686: IFFALSE 17798
17688: GO 17690
17690: DISABLE
17691: LD_INT 0
17693: PPUSH
17694: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
17695: LD_ADDR_VAR 0 2
17699: PUSH
17700: LD_INT 22
17702: PUSH
17703: LD_OWVAR 2
17707: PUSH
17708: EMPTY
17709: LIST
17710: LIST
17711: PUSH
17712: LD_INT 2
17714: PUSH
17715: LD_INT 30
17717: PUSH
17718: LD_INT 27
17720: PUSH
17721: EMPTY
17722: LIST
17723: LIST
17724: PUSH
17725: LD_INT 30
17727: PUSH
17728: LD_INT 26
17730: PUSH
17731: EMPTY
17732: LIST
17733: LIST
17734: PUSH
17735: LD_INT 30
17737: PUSH
17738: LD_INT 28
17740: PUSH
17741: EMPTY
17742: LIST
17743: LIST
17744: PUSH
17745: EMPTY
17746: LIST
17747: LIST
17748: LIST
17749: LIST
17750: PUSH
17751: EMPTY
17752: LIST
17753: LIST
17754: PPUSH
17755: CALL_OW 69
17759: ST_TO_ADDR
// if not tmp then
17760: LD_VAR 0 2
17764: NOT
17765: IFFALSE 17769
// exit ;
17767: GO 17798
// for i in tmp do
17769: LD_ADDR_VAR 0 1
17773: PUSH
17774: LD_VAR 0 2
17778: PUSH
17779: FOR_IN
17780: IFFALSE 17796
// SetLives ( i , 1 ) ;
17782: LD_VAR 0 1
17786: PPUSH
17787: LD_INT 1
17789: PPUSH
17790: CALL_OW 234
17794: GO 17779
17796: POP
17797: POP
// end ;
17798: PPOPN 2
17800: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
17801: LD_EXP 34
17805: PUSH
17806: LD_EXP 83
17810: AND
17811: IFFALSE 18085
17813: GO 17815
17815: DISABLE
17816: LD_INT 0
17818: PPUSH
17819: PPUSH
17820: PPUSH
// begin i := rand ( 1 , 7 ) ;
17821: LD_ADDR_VAR 0 1
17825: PUSH
17826: LD_INT 1
17828: PPUSH
17829: LD_INT 7
17831: PPUSH
17832: CALL_OW 12
17836: ST_TO_ADDR
// case i of 1 :
17837: LD_VAR 0 1
17841: PUSH
17842: LD_INT 1
17844: DOUBLE
17845: EQUAL
17846: IFTRUE 17850
17848: GO 17860
17850: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
17851: LD_STRING earthquake(getX(game), 0, 32)
17853: PPUSH
17854: CALL_OW 559
17858: GO 18085
17860: LD_INT 2
17862: DOUBLE
17863: EQUAL
17864: IFTRUE 17868
17866: GO 17882
17868: POP
// begin ToLua ( displayStucuk(); ) ;
17869: LD_STRING displayStucuk();
17871: PPUSH
17872: CALL_OW 559
// ResetFog ;
17876: CALL_OW 335
// end ; 3 :
17880: GO 18085
17882: LD_INT 3
17884: DOUBLE
17885: EQUAL
17886: IFTRUE 17890
17888: GO 17994
17890: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
17891: LD_ADDR_VAR 0 2
17895: PUSH
17896: LD_INT 22
17898: PUSH
17899: LD_OWVAR 2
17903: PUSH
17904: EMPTY
17905: LIST
17906: LIST
17907: PUSH
17908: LD_INT 25
17910: PUSH
17911: LD_INT 1
17913: PUSH
17914: EMPTY
17915: LIST
17916: LIST
17917: PUSH
17918: EMPTY
17919: LIST
17920: LIST
17921: PPUSH
17922: CALL_OW 69
17926: ST_TO_ADDR
// if not tmp then
17927: LD_VAR 0 2
17931: NOT
17932: IFFALSE 17936
// exit ;
17934: GO 18085
// un := tmp [ rand ( 1 , tmp ) ] ;
17936: LD_ADDR_VAR 0 3
17940: PUSH
17941: LD_VAR 0 2
17945: PUSH
17946: LD_INT 1
17948: PPUSH
17949: LD_VAR 0 2
17953: PPUSH
17954: CALL_OW 12
17958: ARRAY
17959: ST_TO_ADDR
// if Crawls ( un ) then
17960: LD_VAR 0 3
17964: PPUSH
17965: CALL_OW 318
17969: IFFALSE 17980
// ComWalk ( un ) ;
17971: LD_VAR 0 3
17975: PPUSH
17976: CALL_OW 138
// SetClass ( un , class_mortar ) ;
17980: LD_VAR 0 3
17984: PPUSH
17985: LD_INT 8
17987: PPUSH
17988: CALL_OW 336
// end ; 4 :
17992: GO 18085
17994: LD_INT 4
17996: DOUBLE
17997: EQUAL
17998: IFTRUE 18002
18000: GO 18063
18002: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
18003: LD_ADDR_VAR 0 2
18007: PUSH
18008: LD_INT 22
18010: PUSH
18011: LD_OWVAR 2
18015: PUSH
18016: EMPTY
18017: LIST
18018: LIST
18019: PUSH
18020: LD_INT 30
18022: PUSH
18023: LD_INT 29
18025: PUSH
18026: EMPTY
18027: LIST
18028: LIST
18029: PUSH
18030: EMPTY
18031: LIST
18032: LIST
18033: PPUSH
18034: CALL_OW 69
18038: ST_TO_ADDR
// if not tmp then
18039: LD_VAR 0 2
18043: NOT
18044: IFFALSE 18048
// exit ;
18046: GO 18085
// DestroyUnit ( tmp [ 1 ] ) ;
18048: LD_VAR 0 2
18052: PUSH
18053: LD_INT 1
18055: ARRAY
18056: PPUSH
18057: CALL_OW 65
// end ; 5 .. 7 :
18061: GO 18085
18063: LD_INT 5
18065: DOUBLE
18066: GREATEREQUAL
18067: IFFALSE 18075
18069: LD_INT 7
18071: DOUBLE
18072: LESSEQUAL
18073: IFTRUE 18077
18075: GO 18084
18077: POP
// StreamSibBomb ; end ;
18078: CALL 14365 0 0
18082: GO 18085
18084: POP
// end ;
18085: PPOPN 3
18087: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
18088: LD_EXP 34
18092: PUSH
18093: LD_EXP 84
18097: AND
18098: IFFALSE 18254
18100: GO 18102
18102: DISABLE
18103: LD_INT 0
18105: PPUSH
18106: PPUSH
18107: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
18108: LD_ADDR_VAR 0 2
18112: PUSH
18113: LD_INT 81
18115: PUSH
18116: LD_OWVAR 2
18120: PUSH
18121: EMPTY
18122: LIST
18123: LIST
18124: PUSH
18125: LD_INT 2
18127: PUSH
18128: LD_INT 21
18130: PUSH
18131: LD_INT 1
18133: PUSH
18134: EMPTY
18135: LIST
18136: LIST
18137: PUSH
18138: LD_INT 21
18140: PUSH
18141: LD_INT 2
18143: PUSH
18144: EMPTY
18145: LIST
18146: LIST
18147: PUSH
18148: EMPTY
18149: LIST
18150: LIST
18151: LIST
18152: PUSH
18153: EMPTY
18154: LIST
18155: LIST
18156: PPUSH
18157: CALL_OW 69
18161: ST_TO_ADDR
// if not tmp then
18162: LD_VAR 0 2
18166: NOT
18167: IFFALSE 18171
// exit ;
18169: GO 18254
// p := 0 ;
18171: LD_ADDR_VAR 0 3
18175: PUSH
18176: LD_INT 0
18178: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18179: LD_INT 35
18181: PPUSH
18182: CALL_OW 67
// p := p + 1 ;
18186: LD_ADDR_VAR 0 3
18190: PUSH
18191: LD_VAR 0 3
18195: PUSH
18196: LD_INT 1
18198: PLUS
18199: ST_TO_ADDR
// for i in tmp do
18200: LD_ADDR_VAR 0 1
18204: PUSH
18205: LD_VAR 0 2
18209: PUSH
18210: FOR_IN
18211: IFFALSE 18242
// if GetLives ( i ) < 1000 then
18213: LD_VAR 0 1
18217: PPUSH
18218: CALL_OW 256
18222: PUSH
18223: LD_INT 1000
18225: LESS
18226: IFFALSE 18240
// SetLives ( i , 1000 ) ;
18228: LD_VAR 0 1
18232: PPUSH
18233: LD_INT 1000
18235: PPUSH
18236: CALL_OW 234
18240: GO 18210
18242: POP
18243: POP
// until p > 20 ;
18244: LD_VAR 0 3
18248: PUSH
18249: LD_INT 20
18251: GREATER
18252: IFFALSE 18179
// end ;
18254: PPOPN 3
18256: END
// every 0 0$1 trigger StreamModeActive and sTime do
18257: LD_EXP 34
18261: PUSH
18262: LD_EXP 85
18266: AND
18267: IFFALSE 18302
18269: GO 18271
18271: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
18272: LD_INT 28
18274: PPUSH
18275: LD_OWVAR 2
18279: PPUSH
18280: LD_INT 2
18282: PPUSH
18283: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
18287: LD_INT 30
18289: PPUSH
18290: LD_OWVAR 2
18294: PPUSH
18295: LD_INT 2
18297: PPUSH
18298: CALL_OW 322
// end ;
18302: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
18303: LD_EXP 34
18307: PUSH
18308: LD_EXP 86
18312: AND
18313: IFFALSE 18434
18315: GO 18317
18317: DISABLE
18318: LD_INT 0
18320: PPUSH
18321: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
18322: LD_ADDR_VAR 0 2
18326: PUSH
18327: LD_INT 22
18329: PUSH
18330: LD_OWVAR 2
18334: PUSH
18335: EMPTY
18336: LIST
18337: LIST
18338: PUSH
18339: LD_INT 21
18341: PUSH
18342: LD_INT 1
18344: PUSH
18345: EMPTY
18346: LIST
18347: LIST
18348: PUSH
18349: LD_INT 3
18351: PUSH
18352: LD_INT 23
18354: PUSH
18355: LD_INT 0
18357: PUSH
18358: EMPTY
18359: LIST
18360: LIST
18361: PUSH
18362: EMPTY
18363: LIST
18364: LIST
18365: PUSH
18366: EMPTY
18367: LIST
18368: LIST
18369: LIST
18370: PPUSH
18371: CALL_OW 69
18375: ST_TO_ADDR
// if not tmp then
18376: LD_VAR 0 2
18380: NOT
18381: IFFALSE 18385
// exit ;
18383: GO 18434
// for i in tmp do
18385: LD_ADDR_VAR 0 1
18389: PUSH
18390: LD_VAR 0 2
18394: PUSH
18395: FOR_IN
18396: IFFALSE 18432
// begin if Crawls ( i ) then
18398: LD_VAR 0 1
18402: PPUSH
18403: CALL_OW 318
18407: IFFALSE 18418
// ComWalk ( i ) ;
18409: LD_VAR 0 1
18413: PPUSH
18414: CALL_OW 138
// SetClass ( i , 2 ) ;
18418: LD_VAR 0 1
18422: PPUSH
18423: LD_INT 2
18425: PPUSH
18426: CALL_OW 336
// end ;
18430: GO 18395
18432: POP
18433: POP
// end ;
18434: PPOPN 2
18436: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
18437: LD_EXP 34
18441: PUSH
18442: LD_EXP 87
18446: AND
18447: IFFALSE 18728
18449: GO 18451
18451: DISABLE
18452: LD_INT 0
18454: PPUSH
18455: PPUSH
18456: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
18457: LD_OWVAR 2
18461: PPUSH
18462: LD_INT 9
18464: PPUSH
18465: LD_INT 1
18467: PPUSH
18468: LD_INT 1
18470: PPUSH
18471: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
18475: LD_INT 9
18477: PPUSH
18478: LD_OWVAR 2
18482: PPUSH
18483: CALL_OW 343
// uc_side := 9 ;
18487: LD_ADDR_OWVAR 20
18491: PUSH
18492: LD_INT 9
18494: ST_TO_ADDR
// uc_nation := 2 ;
18495: LD_ADDR_OWVAR 21
18499: PUSH
18500: LD_INT 2
18502: ST_TO_ADDR
// hc_name := Dark Warrior ;
18503: LD_ADDR_OWVAR 26
18507: PUSH
18508: LD_STRING Dark Warrior
18510: ST_TO_ADDR
// hc_gallery :=  ;
18511: LD_ADDR_OWVAR 33
18515: PUSH
18516: LD_STRING 
18518: ST_TO_ADDR
// hc_noskilllimit := true ;
18519: LD_ADDR_OWVAR 76
18523: PUSH
18524: LD_INT 1
18526: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
18527: LD_ADDR_OWVAR 31
18531: PUSH
18532: LD_INT 30
18534: PUSH
18535: LD_INT 30
18537: PUSH
18538: LD_INT 30
18540: PUSH
18541: LD_INT 30
18543: PUSH
18544: EMPTY
18545: LIST
18546: LIST
18547: LIST
18548: LIST
18549: ST_TO_ADDR
// un := CreateHuman ;
18550: LD_ADDR_VAR 0 3
18554: PUSH
18555: CALL_OW 44
18559: ST_TO_ADDR
// hc_noskilllimit := false ;
18560: LD_ADDR_OWVAR 76
18564: PUSH
18565: LD_INT 0
18567: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
18568: LD_VAR 0 3
18572: PPUSH
18573: LD_INT 1
18575: PPUSH
18576: CALL_OW 51
// p := 0 ;
18580: LD_ADDR_VAR 0 2
18584: PUSH
18585: LD_INT 0
18587: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18588: LD_INT 35
18590: PPUSH
18591: CALL_OW 67
// p := p + 1 ;
18595: LD_ADDR_VAR 0 2
18599: PUSH
18600: LD_VAR 0 2
18604: PUSH
18605: LD_INT 1
18607: PLUS
18608: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
18609: LD_VAR 0 3
18613: PPUSH
18614: CALL_OW 256
18618: PUSH
18619: LD_INT 1000
18621: LESS
18622: IFFALSE 18636
// SetLives ( un , 1000 ) ;
18624: LD_VAR 0 3
18628: PPUSH
18629: LD_INT 1000
18631: PPUSH
18632: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
18636: LD_VAR 0 3
18640: PPUSH
18641: LD_INT 81
18643: PUSH
18644: LD_OWVAR 2
18648: PUSH
18649: EMPTY
18650: LIST
18651: LIST
18652: PUSH
18653: LD_INT 91
18655: PUSH
18656: LD_VAR 0 3
18660: PUSH
18661: LD_INT 30
18663: PUSH
18664: EMPTY
18665: LIST
18666: LIST
18667: LIST
18668: PUSH
18669: EMPTY
18670: LIST
18671: LIST
18672: PPUSH
18673: CALL_OW 69
18677: PPUSH
18678: LD_VAR 0 3
18682: PPUSH
18683: CALL_OW 74
18687: PPUSH
18688: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
18692: LD_VAR 0 2
18696: PUSH
18697: LD_INT 60
18699: GREATER
18700: PUSH
18701: LD_VAR 0 3
18705: PPUSH
18706: CALL_OW 301
18710: OR
18711: IFFALSE 18588
// if un then
18713: LD_VAR 0 3
18717: IFFALSE 18728
// RemoveUnit ( un ) ;
18719: LD_VAR 0 3
18723: PPUSH
18724: CALL_OW 64
// end ; end_of_file
18728: PPOPN 3
18730: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
18731: LD_INT 0
18733: PPUSH
18734: PPUSH
18735: PPUSH
18736: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
18737: LD_VAR 0 1
18741: PPUSH
18742: CALL_OW 264
18746: PUSH
18747: LD_EXP 33
18751: EQUAL
18752: IFFALSE 18824
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
18754: LD_INT 68
18756: PPUSH
18757: LD_VAR 0 1
18761: PPUSH
18762: CALL_OW 255
18766: PPUSH
18767: CALL_OW 321
18771: PUSH
18772: LD_INT 2
18774: EQUAL
18775: IFFALSE 18787
// eff := 70 else
18777: LD_ADDR_VAR 0 4
18781: PUSH
18782: LD_INT 70
18784: ST_TO_ADDR
18785: GO 18795
// eff := 30 ;
18787: LD_ADDR_VAR 0 4
18791: PUSH
18792: LD_INT 30
18794: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
18795: LD_VAR 0 1
18799: PPUSH
18800: CALL_OW 250
18804: PPUSH
18805: LD_VAR 0 1
18809: PPUSH
18810: CALL_OW 251
18814: PPUSH
18815: LD_VAR 0 4
18819: PPUSH
18820: CALL_OW 495
// end ; end ;
18824: LD_VAR 0 2
18828: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
18829: LD_INT 0
18831: PPUSH
// end ;
18832: LD_VAR 0 4
18836: RET
// export function SOS_Command ( cmd ) ; begin
18837: LD_INT 0
18839: PPUSH
// end ;
18840: LD_VAR 0 2
18844: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
18845: LD_VAR 0 1
18849: PUSH
18850: LD_INT 255
18852: EQUAL
18853: PUSH
18854: LD_VAR 0 2
18858: PPUSH
18859: CALL_OW 264
18863: PUSH
18864: LD_INT 14
18866: PUSH
18867: LD_INT 53
18869: PUSH
18870: EMPTY
18871: LIST
18872: LIST
18873: IN
18874: AND
18875: PUSH
18876: LD_VAR 0 4
18880: PPUSH
18881: LD_VAR 0 5
18885: PPUSH
18886: CALL_OW 488
18890: AND
18891: IFFALSE 18915
// CutTreeXYR ( unit , x , y , 12 ) ;
18893: LD_VAR 0 2
18897: PPUSH
18898: LD_VAR 0 4
18902: PPUSH
18903: LD_VAR 0 5
18907: PPUSH
18908: LD_INT 12
18910: PPUSH
18911: CALL 18918 0 4
// end ;
18915: PPOPN 5
18917: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
18918: LD_INT 0
18920: PPUSH
18921: PPUSH
18922: PPUSH
18923: PPUSH
18924: PPUSH
18925: PPUSH
18926: PPUSH
18927: PPUSH
18928: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
18929: LD_VAR 0 1
18933: NOT
18934: PUSH
18935: LD_VAR 0 2
18939: PPUSH
18940: LD_VAR 0 3
18944: PPUSH
18945: CALL_OW 488
18949: NOT
18950: OR
18951: PUSH
18952: LD_VAR 0 4
18956: NOT
18957: OR
18958: IFFALSE 18962
// exit ;
18960: GO 19302
// list := [ ] ;
18962: LD_ADDR_VAR 0 13
18966: PUSH
18967: EMPTY
18968: ST_TO_ADDR
// if x - r < 0 then
18969: LD_VAR 0 2
18973: PUSH
18974: LD_VAR 0 4
18978: MINUS
18979: PUSH
18980: LD_INT 0
18982: LESS
18983: IFFALSE 18995
// min_x := 0 else
18985: LD_ADDR_VAR 0 7
18989: PUSH
18990: LD_INT 0
18992: ST_TO_ADDR
18993: GO 19011
// min_x := x - r ;
18995: LD_ADDR_VAR 0 7
18999: PUSH
19000: LD_VAR 0 2
19004: PUSH
19005: LD_VAR 0 4
19009: MINUS
19010: ST_TO_ADDR
// if y - r < 0 then
19011: LD_VAR 0 3
19015: PUSH
19016: LD_VAR 0 4
19020: MINUS
19021: PUSH
19022: LD_INT 0
19024: LESS
19025: IFFALSE 19037
// min_y := 0 else
19027: LD_ADDR_VAR 0 8
19031: PUSH
19032: LD_INT 0
19034: ST_TO_ADDR
19035: GO 19053
// min_y := y - r ;
19037: LD_ADDR_VAR 0 8
19041: PUSH
19042: LD_VAR 0 3
19046: PUSH
19047: LD_VAR 0 4
19051: MINUS
19052: ST_TO_ADDR
// max_x := x + r ;
19053: LD_ADDR_VAR 0 9
19057: PUSH
19058: LD_VAR 0 2
19062: PUSH
19063: LD_VAR 0 4
19067: PLUS
19068: ST_TO_ADDR
// max_y := y + r ;
19069: LD_ADDR_VAR 0 10
19073: PUSH
19074: LD_VAR 0 3
19078: PUSH
19079: LD_VAR 0 4
19083: PLUS
19084: ST_TO_ADDR
// for _x = min_x to max_x do
19085: LD_ADDR_VAR 0 11
19089: PUSH
19090: DOUBLE
19091: LD_VAR 0 7
19095: DEC
19096: ST_TO_ADDR
19097: LD_VAR 0 9
19101: PUSH
19102: FOR_TO
19103: IFFALSE 19220
// for _y = min_y to max_y do
19105: LD_ADDR_VAR 0 12
19109: PUSH
19110: DOUBLE
19111: LD_VAR 0 8
19115: DEC
19116: ST_TO_ADDR
19117: LD_VAR 0 10
19121: PUSH
19122: FOR_TO
19123: IFFALSE 19216
// begin if not ValidHex ( _x , _y ) then
19125: LD_VAR 0 11
19129: PPUSH
19130: LD_VAR 0 12
19134: PPUSH
19135: CALL_OW 488
19139: NOT
19140: IFFALSE 19144
// continue ;
19142: GO 19122
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
19144: LD_VAR 0 11
19148: PPUSH
19149: LD_VAR 0 12
19153: PPUSH
19154: CALL_OW 351
19158: PUSH
19159: LD_VAR 0 11
19163: PPUSH
19164: LD_VAR 0 12
19168: PPUSH
19169: CALL_OW 554
19173: AND
19174: IFFALSE 19214
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
19176: LD_ADDR_VAR 0 13
19180: PUSH
19181: LD_VAR 0 13
19185: PPUSH
19186: LD_VAR 0 13
19190: PUSH
19191: LD_INT 1
19193: PLUS
19194: PPUSH
19195: LD_VAR 0 11
19199: PUSH
19200: LD_VAR 0 12
19204: PUSH
19205: EMPTY
19206: LIST
19207: LIST
19208: PPUSH
19209: CALL_OW 2
19213: ST_TO_ADDR
// end ;
19214: GO 19122
19216: POP
19217: POP
19218: GO 19102
19220: POP
19221: POP
// if not list then
19222: LD_VAR 0 13
19226: NOT
19227: IFFALSE 19231
// exit ;
19229: GO 19302
// for i in list do
19231: LD_ADDR_VAR 0 6
19235: PUSH
19236: LD_VAR 0 13
19240: PUSH
19241: FOR_IN
19242: IFFALSE 19300
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
19244: LD_VAR 0 1
19248: PPUSH
19249: LD_STRING M
19251: PUSH
19252: LD_VAR 0 6
19256: PUSH
19257: LD_INT 1
19259: ARRAY
19260: PUSH
19261: LD_VAR 0 6
19265: PUSH
19266: LD_INT 2
19268: ARRAY
19269: PUSH
19270: LD_INT 0
19272: PUSH
19273: LD_INT 0
19275: PUSH
19276: LD_INT 0
19278: PUSH
19279: LD_INT 0
19281: PUSH
19282: EMPTY
19283: LIST
19284: LIST
19285: LIST
19286: LIST
19287: LIST
19288: LIST
19289: LIST
19290: PUSH
19291: EMPTY
19292: LIST
19293: PPUSH
19294: CALL_OW 447
19298: GO 19241
19300: POP
19301: POP
// end ;
19302: LD_VAR 0 5
19306: RET
