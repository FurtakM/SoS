// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// Init ;
   8: CALL 72 0 0
// InitRestrictions ;
  12: CALL 192 0 0
// if debug then
  16: LD_EXP 1
  20: IFFALSE 26
// DebugMode ;
  22: CALL 273 0 0
// SpawnApeman ( apemanStartArea , 2 ) ;
  26: LD_INT 12
  28: PPUSH
  29: LD_INT 2
  31: PPUSH
  32: CALL 527 0 2
// SpawnApeman ( apemanArea , [ 10 , 8 , 6 ] [ Difficulty ] ) ;
  36: LD_INT 11
  38: PPUSH
  39: LD_INT 10
  41: PUSH
  42: LD_INT 8
  44: PUSH
  45: LD_INT 6
  47: PUSH
  48: EMPTY
  49: LIST
  50: LIST
  51: LIST
  52: PUSH
  53: LD_OWVAR 67
  57: ARRAY
  58: PPUSH
  59: CALL 527 0 2
// PrepareAmericans ;
  63: CALL 1126 0 0
// Action ;
  67: CALL 2016 0 0
// end ;
  71: END
// export debug ; export mission_prefix , mission_prefix_prev ; export deltaBuilded , denisArrives , Delta , radar_allowed , first_apeman_tamed , apeman_army , radar_researched , radar_builded ; export apeman_counter , arab_spotted , end_mission ; function Init ; begin
  72: LD_INT 0
  74: PPUSH
// debug := false ;
  75: LD_ADDR_EXP 1
  79: PUSH
  80: LD_INT 0
  82: ST_TO_ADDR
// mission_prefix := 05_ ;
  83: LD_ADDR_EXP 2
  87: PUSH
  88: LD_STRING 05_
  90: ST_TO_ADDR
// mission_prefix_prev := 05a_ ;
  91: LD_ADDR_EXP 3
  95: PUSH
  96: LD_STRING 05a_
  98: ST_TO_ADDR
// deltaBuilded := false ;
  99: LD_ADDR_EXP 4
 103: PUSH
 104: LD_INT 0
 106: ST_TO_ADDR
// denisArrives := false ;
 107: LD_ADDR_EXP 5
 111: PUSH
 112: LD_INT 0
 114: ST_TO_ADDR
// radar_allowed := false ;
 115: LD_ADDR_EXP 7
 119: PUSH
 120: LD_INT 0
 122: ST_TO_ADDR
// first_apeman_tamed := false ;
 123: LD_ADDR_EXP 8
 127: PUSH
 128: LD_INT 0
 130: ST_TO_ADDR
// arab_spotted := false ;
 131: LD_ADDR_EXP 13
 135: PUSH
 136: LD_INT 0
 138: ST_TO_ADDR
// end_mission := false ;
 139: LD_ADDR_EXP 14
 143: PUSH
 144: LD_INT 0
 146: ST_TO_ADDR
// apeman_army := false ;
 147: LD_ADDR_EXP 9
 151: PUSH
 152: LD_INT 0
 154: ST_TO_ADDR
// radar_researched := false ;
 155: LD_ADDR_EXP 10
 159: PUSH
 160: LD_INT 0
 162: ST_TO_ADDR
// radar_builded := false ;
 163: LD_ADDR_EXP 11
 167: PUSH
 168: LD_INT 0
 170: ST_TO_ADDR
// apeman_counter := 0 ;
 171: LD_ADDR_EXP 12
 175: PUSH
 176: LD_INT 0
 178: ST_TO_ADDR
// Delta := 0 ;
 179: LD_ADDR_EXP 6
 183: PUSH
 184: LD_INT 0
 186: ST_TO_ADDR
// end ;
 187: LD_VAR 0 1
 191: RET
// function InitRestrictions ; begin
 192: LD_INT 0
 194: PPUSH
// SetRestrict ( b_lab_half , 1 , state_enabled ) ;
 195: LD_INT 7
 197: PPUSH
 198: LD_INT 1
 200: PPUSH
 201: LD_INT 1
 203: PPUSH
 204: CALL_OW 324
// SetRestrict ( b_lab_full , 1 , state_enabled ) ;
 208: LD_INT 8
 210: PPUSH
 211: LD_INT 1
 213: PPUSH
 214: LD_INT 1
 216: PPUSH
 217: CALL_OW 324
// SetRestrict ( b_lab_weapon , 1 , state_enabled ) ;
 221: LD_INT 10
 223: PPUSH
 224: LD_INT 1
 226: PPUSH
 227: LD_INT 1
 229: PPUSH
 230: CALL_OW 324
// SetTech ( tech_gatling , 1 , LoadVariable ( GatlingInGamma , 1 ) ) ;
 234: LD_INT 69
 236: PPUSH
 237: LD_INT 1
 239: PPUSH
 240: LD_STRING GatlingInGamma
 242: PPUSH
 243: LD_INT 1
 245: PPUSH
 246: CALL_OW 30
 250: PPUSH
 251: CALL_OW 322
// SetTech ( tech_weap1 , 1 , state_enabled ) ;
 255: LD_INT 51
 257: PPUSH
 258: LD_INT 1
 260: PPUSH
 261: LD_INT 1
 263: PPUSH
 264: CALL_OW 322
// end ;
 268: LD_VAR 0 1
 272: RET
// function DebugMode ; begin
 273: LD_INT 0
 275: PPUSH
// FogOff ( 1 ) ;
 276: LD_INT 1
 278: PPUSH
 279: CALL_OW 344
// Difficulty := 2 ;
 283: LD_ADDR_OWVAR 67
 287: PUSH
 288: LD_INT 2
 290: ST_TO_ADDR
// end ; end_of_file
 291: LD_VAR 0 1
 295: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 296: LD_INT 0
 298: PPUSH
 299: PPUSH
// if exist_mode then
 300: LD_VAR 0 2
 304: IFFALSE 329
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 306: LD_ADDR_VAR 0 4
 310: PUSH
 311: LD_EXP 3
 315: PUSH
 316: LD_VAR 0 1
 320: STR
 321: PPUSH
 322: CALL_OW 34
 326: ST_TO_ADDR
 327: GO 344
// unit := NewCharacter ( ident ) ;
 329: LD_ADDR_VAR 0 4
 333: PUSH
 334: LD_VAR 0 1
 338: PPUSH
 339: CALL_OW 25
 343: ST_TO_ADDR
// result := unit ;
 344: LD_ADDR_VAR 0 3
 348: PUSH
 349: LD_VAR 0 4
 353: ST_TO_ADDR
// end ;
 354: LD_VAR 0 3
 358: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 359: LD_INT 0
 361: PPUSH
// uc_side := side ;
 362: LD_ADDR_OWVAR 20
 366: PUSH
 367: LD_VAR 0 1
 371: ST_TO_ADDR
// uc_nation := nation ;
 372: LD_ADDR_OWVAR 21
 376: PUSH
 377: LD_VAR 0 2
 381: ST_TO_ADDR
// vc_chassis := chassis ;
 382: LD_ADDR_OWVAR 37
 386: PUSH
 387: LD_VAR 0 3
 391: ST_TO_ADDR
// vc_engine := engine ;
 392: LD_ADDR_OWVAR 39
 396: PUSH
 397: LD_VAR 0 4
 401: ST_TO_ADDR
// vc_control := control ;
 402: LD_ADDR_OWVAR 38
 406: PUSH
 407: LD_VAR 0 5
 411: ST_TO_ADDR
// vc_weapon := weapon ;
 412: LD_ADDR_OWVAR 40
 416: PUSH
 417: LD_VAR 0 6
 421: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 422: LD_ADDR_OWVAR 41
 426: PUSH
 427: LD_VAR 0 7
 431: ST_TO_ADDR
// result := CreateVehicle ;
 432: LD_ADDR_VAR 0 8
 436: PUSH
 437: CALL_OW 45
 441: ST_TO_ADDR
// end ;
 442: LD_VAR 0 8
 446: RET
// export function SayX ( units , ident ) ; var i ; begin
 447: LD_INT 0
 449: PPUSH
 450: PPUSH
// result := false ;
 451: LD_ADDR_VAR 0 3
 455: PUSH
 456: LD_INT 0
 458: ST_TO_ADDR
// if not units then
 459: LD_VAR 0 1
 463: NOT
 464: IFFALSE 468
// exit ;
 466: GO 522
// for i in units do
 468: LD_ADDR_VAR 0 4
 472: PUSH
 473: LD_VAR 0 1
 477: PUSH
 478: FOR_IN
 479: IFFALSE 520
// if IsOk ( i ) then
 481: LD_VAR 0 4
 485: PPUSH
 486: CALL_OW 302
 490: IFFALSE 518
// begin Say ( i , ident ) ;
 492: LD_VAR 0 4
 496: PPUSH
 497: LD_VAR 0 2
 501: PPUSH
 502: CALL_OW 88
// result := i ;
 506: LD_ADDR_VAR 0 3
 510: PUSH
 511: LD_VAR 0 4
 515: ST_TO_ADDR
// break ;
 516: GO 520
// end ;
 518: GO 478
 520: POP
 521: POP
// end ;
 522: LD_VAR 0 3
 526: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 527: LD_INT 0
 529: PPUSH
 530: PPUSH
// InitUc ;
 531: CALL_OW 18
// InitHc ;
 535: CALL_OW 19
// uc_side := 0 ;
 539: LD_ADDR_OWVAR 20
 543: PUSH
 544: LD_INT 0
 546: ST_TO_ADDR
// uc_nation := 0 ;
 547: LD_ADDR_OWVAR 21
 551: PUSH
 552: LD_INT 0
 554: ST_TO_ADDR
// for i = 1 to amount do
 555: LD_ADDR_VAR 0 4
 559: PUSH
 560: DOUBLE
 561: LD_INT 1
 563: DEC
 564: ST_TO_ADDR
 565: LD_VAR 0 2
 569: PUSH
 570: FOR_TO
 571: IFFALSE 653
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 573: LD_ADDR_OWVAR 29
 577: PUSH
 578: LD_INT 9
 580: PPUSH
 581: LD_INT 12
 583: PPUSH
 584: CALL_OW 12
 588: PUSH
 589: LD_INT 9
 591: PPUSH
 592: LD_INT 12
 594: PPUSH
 595: CALL_OW 12
 599: PUSH
 600: EMPTY
 601: LIST
 602: LIST
 603: ST_TO_ADDR
// hc_agressivity := rand ( - 5 , 5 ) ;
 604: LD_ADDR_OWVAR 35
 608: PUSH
 609: LD_INT 5
 611: NEG
 612: PPUSH
 613: LD_INT 5
 615: PPUSH
 616: CALL_OW 12
 620: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 621: LD_INT 0
 623: PPUSH
 624: LD_INT 12
 626: PPUSH
 627: LD_INT 1
 629: PPUSH
 630: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 634: CALL_OW 44
 638: PPUSH
 639: LD_VAR 0 1
 643: PPUSH
 644: LD_INT 0
 646: PPUSH
 647: CALL_OW 49
// end ;
 651: GO 570
 653: POP
 654: POP
// InitHc ;
 655: CALL_OW 19
// end ;
 659: LD_VAR 0 3
 663: RET
// export function Attack ( unit , enemy_list ) ; var target , targets_list ; begin
 664: LD_INT 0
 666: PPUSH
 667: PPUSH
 668: PPUSH
// if not unit then
 669: LD_VAR 0 1
 673: NOT
 674: IFFALSE 678
// exit ;
 676: GO 1121
// if IsInUnit ( unit ) then
 678: LD_VAR 0 1
 682: PPUSH
 683: CALL_OW 310
 687: IFFALSE 704
// unit := IsDrivenBy ( unit ) ;
 689: LD_ADDR_VAR 0 1
 693: PUSH
 694: LD_VAR 0 1
 698: PPUSH
 699: CALL_OW 311
 703: ST_TO_ADDR
// targets_list := [ ] ;
 704: LD_ADDR_VAR 0 5
 708: PUSH
 709: EMPTY
 710: ST_TO_ADDR
// target := UnitFilter ( enemy_list , [ [ f_lives , 250 ] , [ f_not , [ f_weapon , us_cargo_bay ] ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
 711: LD_ADDR_VAR 0 4
 715: PUSH
 716: LD_VAR 0 2
 720: PPUSH
 721: LD_INT 24
 723: PUSH
 724: LD_INT 250
 726: PUSH
 727: EMPTY
 728: LIST
 729: LIST
 730: PUSH
 731: LD_INT 3
 733: PUSH
 734: LD_INT 34
 736: PUSH
 737: LD_INT 12
 739: PUSH
 740: EMPTY
 741: LIST
 742: LIST
 743: PUSH
 744: EMPTY
 745: LIST
 746: LIST
 747: PUSH
 748: LD_INT 21
 750: PUSH
 751: LD_INT 2
 753: PUSH
 754: EMPTY
 755: LIST
 756: LIST
 757: PUSH
 758: LD_INT 58
 760: PUSH
 761: EMPTY
 762: LIST
 763: PUSH
 764: EMPTY
 765: LIST
 766: LIST
 767: LIST
 768: LIST
 769: PPUSH
 770: CALL_OW 72
 774: ST_TO_ADDR
// if GetDistUnits ( NearestUnitToUnit ( target , unit ) , unit ) < 11 and not IsInUnit ( unit ) then
 775: LD_VAR 0 4
 779: PPUSH
 780: LD_VAR 0 1
 784: PPUSH
 785: CALL_OW 74
 789: PPUSH
 790: LD_VAR 0 1
 794: PPUSH
 795: CALL_OW 296
 799: PUSH
 800: LD_INT 11
 802: LESS
 803: PUSH
 804: LD_VAR 0 1
 808: PPUSH
 809: CALL_OW 310
 813: NOT
 814: AND
 815: IFFALSE 843
// begin ComEnterUnit ( unit , NearestUnitToUnit ( target , unit ) ) ;
 817: LD_VAR 0 1
 821: PPUSH
 822: LD_VAR 0 4
 826: PPUSH
 827: LD_VAR 0 1
 831: PPUSH
 832: CALL_OW 74
 836: PPUSH
 837: CALL_OW 120
// exit ;
 841: GO 1121
// end ; targets_list := [ UnitFilter ( enemy_list , [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] ] ) , UnitFilter ( enemy_list , [ f_type , unit_vehicle ] ) , UnitFilter ( enemy_list , [ [ f_type , unit_building ] , [ f_not , [ f_empty ] ] ] ) , enemy_list ] ;
 843: LD_ADDR_VAR 0 5
 847: PUSH
 848: LD_VAR 0 2
 852: PPUSH
 853: LD_INT 21
 855: PUSH
 856: LD_INT 1
 858: PUSH
 859: EMPTY
 860: LIST
 861: LIST
 862: PUSH
 863: LD_INT 3
 865: PUSH
 866: LD_INT 54
 868: PUSH
 869: EMPTY
 870: LIST
 871: PUSH
 872: EMPTY
 873: LIST
 874: LIST
 875: PUSH
 876: EMPTY
 877: LIST
 878: LIST
 879: PPUSH
 880: CALL_OW 72
 884: PUSH
 885: LD_VAR 0 2
 889: PPUSH
 890: LD_INT 21
 892: PUSH
 893: LD_INT 2
 895: PUSH
 896: EMPTY
 897: LIST
 898: LIST
 899: PPUSH
 900: CALL_OW 72
 904: PUSH
 905: LD_VAR 0 2
 909: PPUSH
 910: LD_INT 21
 912: PUSH
 913: LD_INT 3
 915: PUSH
 916: EMPTY
 917: LIST
 918: LIST
 919: PUSH
 920: LD_INT 3
 922: PUSH
 923: LD_INT 58
 925: PUSH
 926: EMPTY
 927: LIST
 928: PUSH
 929: EMPTY
 930: LIST
 931: LIST
 932: PUSH
 933: EMPTY
 934: LIST
 935: LIST
 936: PPUSH
 937: CALL_OW 72
 941: PUSH
 942: LD_VAR 0 2
 946: PUSH
 947: EMPTY
 948: LIST
 949: LIST
 950: LIST
 951: LIST
 952: ST_TO_ADDR
// for target in targets_list do
 953: LD_ADDR_VAR 0 4
 957: PUSH
 958: LD_VAR 0 5
 962: PUSH
 963: FOR_IN
 964: IFFALSE 1119
// begin if target then
 966: LD_VAR 0 4
 970: IFFALSE 1117
// if GetTag ( unit ) = 11 and ( GetType ( NearestUnitToUnit ( target , unit ) ) = unit_building or GetWeapon ( NearestUnitToUnit ( target , unit ) ) = us_cargo_bay ) then
 972: LD_VAR 0 1
 976: PPUSH
 977: CALL_OW 110
 981: PUSH
 982: LD_INT 11
 984: EQUAL
 985: PUSH
 986: LD_VAR 0 4
 990: PPUSH
 991: LD_VAR 0 1
 995: PPUSH
 996: CALL_OW 74
1000: PPUSH
1001: CALL_OW 247
1005: PUSH
1006: LD_INT 3
1008: EQUAL
1009: PUSH
1010: LD_VAR 0 4
1014: PPUSH
1015: LD_VAR 0 1
1019: PPUSH
1020: CALL_OW 74
1024: PPUSH
1025: CALL_OW 264
1029: PUSH
1030: LD_INT 12
1032: EQUAL
1033: OR
1034: AND
1035: IFFALSE 1081
// begin ComPlaceDelayedCharge ( unit , 0 , 0 , NearestUnitToUnit ( target , unit ) ) ;
1037: LD_VAR 0 1
1041: PPUSH
1042: LD_INT 0
1044: PPUSH
1045: LD_INT 0
1047: PPUSH
1048: LD_VAR 0 4
1052: PPUSH
1053: LD_VAR 0 1
1057: PPUSH
1058: CALL_OW 74
1062: PPUSH
1063: CALL_OW 132
// SetTag ( unit , 0 ) ;
1067: LD_VAR 0 1
1071: PPUSH
1072: LD_INT 0
1074: PPUSH
1075: CALL_OW 109
// end else
1079: GO 1117
// if not HasTask ( unit ) then
1081: LD_VAR 0 1
1085: PPUSH
1086: CALL_OW 314
1090: NOT
1091: IFFALSE 1117
// ComAttackUnit ( unit , NearestUnitToUnit ( target , unit ) ) ;
1093: LD_VAR 0 1
1097: PPUSH
1098: LD_VAR 0 4
1102: PPUSH
1103: LD_VAR 0 1
1107: PPUSH
1108: CALL_OW 74
1112: PPUSH
1113: CALL_OW 115
// end ;
1117: GO 963
1119: POP
1120: POP
// end ; end_of_file
1121: LD_VAR 0 3
1125: RET
// export JMM , Gladstone , Harrison , Denis , Brown , Donaldson , Lisa , Frank , Bobby , Cyrus ; export others ; export function PrepareAmericans ; var i , points , veh , tmp ; begin
1126: LD_INT 0
1128: PPUSH
1129: PPUSH
1130: PPUSH
1131: PPUSH
1132: PPUSH
// uc_nation := 1 ;
1133: LD_ADDR_OWVAR 21
1137: PUSH
1138: LD_INT 1
1140: ST_TO_ADDR
// uc_side := 4 ;
1141: LD_ADDR_OWVAR 20
1145: PUSH
1146: LD_INT 4
1148: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , false ) ;
1149: LD_ADDR_EXP 18
1153: PUSH
1154: LD_STRING Denis
1156: PPUSH
1157: LD_INT 0
1159: PPUSH
1160: CALL 296 0 2
1164: ST_TO_ADDR
// Harrison := PrepareUnit ( Harisson , false ) ;
1165: LD_ADDR_EXP 17
1169: PUSH
1170: LD_STRING Harisson
1172: PPUSH
1173: LD_INT 0
1175: PPUSH
1176: CALL 296 0 2
1180: ST_TO_ADDR
// uc_side := 1 ;
1181: LD_ADDR_OWVAR 20
1185: PUSH
1186: LD_INT 1
1188: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1189: LD_ADDR_EXP 15
1193: PUSH
1194: LD_STRING JMM
1196: PPUSH
1197: LD_EXP 1
1201: NOT
1202: PPUSH
1203: CALL 296 0 2
1207: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , false ) ;
1208: LD_ADDR_EXP 16
1212: PUSH
1213: LD_STRING Gladstone
1215: PPUSH
1216: LD_INT 0
1218: PPUSH
1219: CALL 296 0 2
1223: ST_TO_ADDR
// if LoadVariable ( BrownInDelta , debug ) then
1224: LD_STRING BrownInDelta
1226: PPUSH
1227: LD_EXP 1
1231: PPUSH
1232: CALL_OW 30
1236: IFFALSE 1273
// begin Brown := PrepareUnit ( Brown , ( not debug ) ) ;
1238: LD_ADDR_EXP 19
1242: PUSH
1243: LD_STRING Brown
1245: PPUSH
1246: LD_EXP 1
1250: NOT
1251: PPUSH
1252: CALL 296 0 2
1256: ST_TO_ADDR
// tmp := tmp ^ Brown ;
1257: LD_ADDR_VAR 0 5
1261: PUSH
1262: LD_VAR 0 5
1266: PUSH
1267: LD_EXP 19
1271: ADD
1272: ST_TO_ADDR
// end ; if LoadVariable ( DonaldsonInDelta , debug ) then
1273: LD_STRING DonaldsonInDelta
1275: PPUSH
1276: LD_EXP 1
1280: PPUSH
1281: CALL_OW 30
1285: IFFALSE 1322
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
1287: LD_ADDR_EXP 20
1291: PUSH
1292: LD_STRING Donaldson
1294: PPUSH
1295: LD_EXP 1
1299: NOT
1300: PPUSH
1301: CALL 296 0 2
1305: ST_TO_ADDR
// tmp := tmp ^ Donaldson ;
1306: LD_ADDR_VAR 0 5
1310: PUSH
1311: LD_VAR 0 5
1315: PUSH
1316: LD_EXP 20
1320: ADD
1321: ST_TO_ADDR
// end ; if LoadVariable ( LisaInDelta , debug ) then
1322: LD_STRING LisaInDelta
1324: PPUSH
1325: LD_EXP 1
1329: PPUSH
1330: CALL_OW 30
1334: IFFALSE 1371
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1336: LD_ADDR_EXP 21
1340: PUSH
1341: LD_STRING Lisa
1343: PPUSH
1344: LD_EXP 1
1348: NOT
1349: PPUSH
1350: CALL 296 0 2
1354: ST_TO_ADDR
// tmp := tmp ^ Lisa ;
1355: LD_ADDR_VAR 0 5
1359: PUSH
1360: LD_VAR 0 5
1364: PUSH
1365: LD_EXP 21
1369: ADD
1370: ST_TO_ADDR
// end ; if LoadVariable ( FrankInDelta , debug ) then
1371: LD_STRING FrankInDelta
1373: PPUSH
1374: LD_EXP 1
1378: PPUSH
1379: CALL_OW 30
1383: IFFALSE 1420
// begin Frank := PrepareUnit ( Frank , ( not debug ) ) ;
1385: LD_ADDR_EXP 22
1389: PUSH
1390: LD_STRING Frank
1392: PPUSH
1393: LD_EXP 1
1397: NOT
1398: PPUSH
1399: CALL 296 0 2
1403: ST_TO_ADDR
// tmp := tmp ^ Frank ;
1404: LD_ADDR_VAR 0 5
1408: PUSH
1409: LD_VAR 0 5
1413: PUSH
1414: LD_EXP 22
1418: ADD
1419: ST_TO_ADDR
// end ; if LoadVariable ( BobbyInDelta , 0 ) then
1420: LD_STRING BobbyInDelta
1422: PPUSH
1423: LD_INT 0
1425: PPUSH
1426: CALL_OW 30
1430: IFFALSE 1467
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1432: LD_ADDR_EXP 23
1436: PUSH
1437: LD_STRING Bobby
1439: PPUSH
1440: LD_EXP 1
1444: NOT
1445: PPUSH
1446: CALL 296 0 2
1450: ST_TO_ADDR
// tmp := tmp ^ Bobby ;
1451: LD_ADDR_VAR 0 5
1455: PUSH
1456: LD_VAR 0 5
1460: PUSH
1461: LD_EXP 23
1465: ADD
1466: ST_TO_ADDR
// end ; if LoadVariable ( CyrusInDelta , 0 ) then
1467: LD_STRING CyrusInDelta
1469: PPUSH
1470: LD_INT 0
1472: PPUSH
1473: CALL_OW 30
1477: IFFALSE 1514
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1479: LD_ADDR_EXP 24
1483: PUSH
1484: LD_STRING Cyrus
1486: PPUSH
1487: LD_EXP 1
1491: NOT
1492: PPUSH
1493: CALL 296 0 2
1497: ST_TO_ADDR
// tmp := tmp ^ Cyrus ;
1498: LD_ADDR_VAR 0 5
1502: PUSH
1503: LD_VAR 0 5
1507: PUSH
1508: LD_EXP 24
1512: ADD
1513: ST_TO_ADDR
// end ; others := CreateCharacterSet ( othersDelta ) ;
1514: LD_ADDR_EXP 25
1518: PUSH
1519: LD_STRING othersDelta
1521: PPUSH
1522: CALL_OW 31
1526: ST_TO_ADDR
// if not others and debug then
1527: LD_EXP 25
1531: NOT
1532: PUSH
1533: LD_EXP 1
1537: AND
1538: IFFALSE 1603
// begin InitHc ;
1540: CALL_OW 19
// for i = 1 to 2 do
1544: LD_ADDR_VAR 0 2
1548: PUSH
1549: DOUBLE
1550: LD_INT 1
1552: DEC
1553: ST_TO_ADDR
1554: LD_INT 2
1556: PUSH
1557: FOR_TO
1558: IFFALSE 1601
// begin PrepareHuman ( false , i mod 4 + 1 , 3 ) ;
1560: LD_INT 0
1562: PPUSH
1563: LD_VAR 0 2
1567: PUSH
1568: LD_INT 4
1570: MOD
1571: PUSH
1572: LD_INT 1
1574: PLUS
1575: PPUSH
1576: LD_INT 3
1578: PPUSH
1579: CALL_OW 380
// others := others ^ CreateHuman ;
1583: LD_ADDR_EXP 25
1587: PUSH
1588: LD_EXP 25
1592: PUSH
1593: CALL_OW 44
1597: ADD
1598: ST_TO_ADDR
// end ;
1599: GO 1557
1601: POP
1602: POP
// end ; if others then
1603: LD_EXP 25
1607: IFFALSE 1625
// tmp := tmp ^ others ;
1609: LD_ADDR_VAR 0 5
1613: PUSH
1614: LD_VAR 0 5
1618: PUSH
1619: LD_EXP 25
1623: ADD
1624: ST_TO_ADDR
// points := [ [ 28 , 49 ] , [ 33 , 54 ] , [ 38 , 56 ] ] ;
1625: LD_ADDR_VAR 0 3
1629: PUSH
1630: LD_INT 28
1632: PUSH
1633: LD_INT 49
1635: PUSH
1636: EMPTY
1637: LIST
1638: LIST
1639: PUSH
1640: LD_INT 33
1642: PUSH
1643: LD_INT 54
1645: PUSH
1646: EMPTY
1647: LIST
1648: LIST
1649: PUSH
1650: LD_INT 38
1652: PUSH
1653: LD_INT 56
1655: PUSH
1656: EMPTY
1657: LIST
1658: LIST
1659: PUSH
1660: EMPTY
1661: LIST
1662: LIST
1663: LIST
1664: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , us_cargo_bay , 80 ) ;
1665: LD_ADDR_VAR 0 4
1669: PUSH
1670: LD_INT 1
1672: PPUSH
1673: LD_INT 1
1675: PPUSH
1676: LD_INT 2
1678: PPUSH
1679: LD_INT 2
1681: PPUSH
1682: LD_INT 1
1684: PPUSH
1685: LD_INT 12
1687: PPUSH
1688: LD_INT 80
1690: PPUSH
1691: CALL 359 0 7
1695: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1696: LD_VAR 0 4
1700: PPUSH
1701: LD_INT 1
1703: PPUSH
1704: CALL_OW 233
// PlaceUnitXY ( veh , points [ 1 ] [ 1 ] , points [ 1 ] [ 2 ] , false ) ;
1708: LD_VAR 0 4
1712: PPUSH
1713: LD_VAR 0 3
1717: PUSH
1718: LD_INT 1
1720: ARRAY
1721: PUSH
1722: LD_INT 1
1724: ARRAY
1725: PPUSH
1726: LD_VAR 0 3
1730: PUSH
1731: LD_INT 1
1733: ARRAY
1734: PUSH
1735: LD_INT 2
1737: ARRAY
1738: PPUSH
1739: LD_INT 0
1741: PPUSH
1742: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
1746: LD_VAR 0 4
1750: PPUSH
1751: LD_INT 1
1753: PPUSH
1754: LD_INT 100
1756: PPUSH
1757: CALL_OW 290
// PlaceHumanInUnit ( others [ 1 ] , veh ) ;
1761: LD_EXP 25
1765: PUSH
1766: LD_INT 1
1768: ARRAY
1769: PPUSH
1770: LD_VAR 0 4
1774: PPUSH
1775: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_machine_gun , 80 ) ;
1779: LD_ADDR_VAR 0 4
1783: PUSH
1784: LD_INT 1
1786: PPUSH
1787: LD_INT 1
1789: PPUSH
1790: LD_INT 1
1792: PPUSH
1793: LD_INT 2
1795: PPUSH
1796: LD_INT 1
1798: PPUSH
1799: LD_INT 2
1801: PPUSH
1802: LD_INT 80
1804: PPUSH
1805: CALL 359 0 7
1809: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1810: LD_VAR 0 4
1814: PPUSH
1815: LD_INT 1
1817: PPUSH
1818: CALL_OW 233
// PlaceUnitXY ( veh , points [ 2 ] [ 1 ] , points [ 2 ] [ 2 ] , false ) ;
1822: LD_VAR 0 4
1826: PPUSH
1827: LD_VAR 0 3
1831: PUSH
1832: LD_INT 2
1834: ARRAY
1835: PUSH
1836: LD_INT 1
1838: ARRAY
1839: PPUSH
1840: LD_VAR 0 3
1844: PUSH
1845: LD_INT 2
1847: ARRAY
1848: PUSH
1849: LD_INT 2
1851: ARRAY
1852: PPUSH
1853: LD_INT 0
1855: PPUSH
1856: CALL_OW 48
// PlaceHumanInUnit ( Gladstone , veh ) ;
1860: LD_EXP 16
1864: PPUSH
1865: LD_VAR 0 4
1869: PPUSH
1870: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_light_gun , 80 ) ;
1874: LD_ADDR_VAR 0 4
1878: PUSH
1879: LD_INT 1
1881: PPUSH
1882: LD_INT 1
1884: PPUSH
1885: LD_INT 1
1887: PPUSH
1888: LD_INT 2
1890: PPUSH
1891: LD_INT 1
1893: PPUSH
1894: LD_INT 3
1896: PPUSH
1897: LD_INT 80
1899: PPUSH
1900: CALL 359 0 7
1904: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1905: LD_VAR 0 4
1909: PPUSH
1910: LD_INT 1
1912: PPUSH
1913: CALL_OW 233
// PlaceUnitXY ( veh , points [ 3 ] [ 1 ] , points [ 3 ] [ 2 ] , false ) ;
1917: LD_VAR 0 4
1921: PPUSH
1922: LD_VAR 0 3
1926: PUSH
1927: LD_INT 3
1929: ARRAY
1930: PUSH
1931: LD_INT 1
1933: ARRAY
1934: PPUSH
1935: LD_VAR 0 3
1939: PUSH
1940: LD_INT 3
1942: ARRAY
1943: PUSH
1944: LD_INT 2
1946: ARRAY
1947: PPUSH
1948: LD_INT 0
1950: PPUSH
1951: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1955: LD_EXP 15
1959: PPUSH
1960: LD_VAR 0 4
1964: PPUSH
1965: CALL_OW 52
// for i in tmp diff others [ 1 ] do
1969: LD_ADDR_VAR 0 2
1973: PUSH
1974: LD_VAR 0 5
1978: PUSH
1979: LD_EXP 25
1983: PUSH
1984: LD_INT 1
1986: ARRAY
1987: DIFF
1988: PUSH
1989: FOR_IN
1990: IFFALSE 2009
// PlaceUnitArea ( i , startArea , false ) ;
1992: LD_VAR 0 2
1996: PPUSH
1997: LD_INT 5
1999: PPUSH
2000: LD_INT 0
2002: PPUSH
2003: CALL_OW 49
2007: GO 1989
2009: POP
2010: POP
// end ; end_of_file
2011: LD_VAR 0 1
2015: RET
// export function Action ; var m ; begin
2016: LD_INT 0
2018: PPUSH
2019: PPUSH
// InGameOn ;
2020: CALL_OW 8
// CenterNowOnXY ( 28 , 51 ) ;
2024: LD_INT 28
2026: PPUSH
2027: LD_INT 51
2029: PPUSH
2030: CALL_OW 86
// Wait ( 3 ) ;
2034: LD_INT 3
2036: PPUSH
2037: CALL_OW 67
// Say ( JMM , D1d-JMM-1a ) ;
2041: LD_EXP 15
2045: PPUSH
2046: LD_STRING D1d-JMM-1a
2048: PPUSH
2049: CALL_OW 88
// SayRadio ( Harrison , D1d-Har-1 ) ;
2053: LD_EXP 17
2057: PPUSH
2058: LD_STRING D1d-Har-1
2060: PPUSH
2061: CALL_OW 94
// InGameOff ;
2065: CALL_OW 9
// SaveForQuickRestart ;
2069: CALL_OW 22
// ChangeMissionObjectives ( M1 ) ;
2073: LD_STRING M1
2075: PPUSH
2076: CALL_OW 337
// Wait ( 0 0$2 ) ;
2080: LD_INT 70
2082: PPUSH
2083: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
2087: LD_EXP 15
2091: PPUSH
2092: LD_STRING D2-JMM-1
2094: PPUSH
2095: CALL_OW 88
// Say ( Gladstone , D2-Glad-1 ) ;
2099: LD_EXP 16
2103: PPUSH
2104: LD_STRING D2-Glad-1
2106: PPUSH
2107: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
2111: LD_EXP 15
2115: PPUSH
2116: LD_STRING D2-JMM-2
2118: PPUSH
2119: CALL_OW 88
// Say ( Gladstone , D2-Glad-2 ) ;
2123: LD_EXP 16
2127: PPUSH
2128: LD_STRING D2-Glad-2
2130: PPUSH
2131: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
2135: LD_EXP 15
2139: PPUSH
2140: LD_STRING D2-JMM-3
2142: PPUSH
2143: CALL_OW 88
// Wait ( rand ( 0 0$30 , 1 1$00 ) ) ;
2147: LD_INT 1050
2149: PPUSH
2150: LD_INT 2100
2152: PPUSH
2153: CALL_OW 12
2157: PPUSH
2158: CALL_OW 67
// SetWeather ( 2 , 90 , 150 ) ;
2162: LD_INT 2
2164: PPUSH
2165: LD_INT 90
2167: PPUSH
2168: LD_INT 150
2170: PPUSH
2171: CALL_OW 550
// Wait ( rand ( 3 3$00 , 5 5$00 ) ) ;
2175: LD_INT 6300
2177: PPUSH
2178: LD_INT 10500
2180: PPUSH
2181: CALL_OW 12
2185: PPUSH
2186: CALL_OW 67
// SetWeather ( 0 , 90 , 150 ) ;
2190: LD_INT 0
2192: PPUSH
2193: LD_INT 90
2195: PPUSH
2196: LD_INT 150
2198: PPUSH
2199: CALL_OW 550
// end ;
2203: LD_VAR 0 1
2207: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) and not deltaBuilded do
2208: LD_INT 22
2210: PUSH
2211: LD_INT 1
2213: PUSH
2214: EMPTY
2215: LIST
2216: LIST
2217: PUSH
2218: LD_INT 3
2220: PUSH
2221: LD_INT 57
2223: PUSH
2224: EMPTY
2225: LIST
2226: PUSH
2227: EMPTY
2228: LIST
2229: LIST
2230: PUSH
2231: LD_INT 30
2233: PUSH
2234: LD_INT 0
2236: PUSH
2237: EMPTY
2238: LIST
2239: LIST
2240: PUSH
2241: EMPTY
2242: LIST
2243: LIST
2244: LIST
2245: PUSH
2246: EMPTY
2247: LIST
2248: PPUSH
2249: CALL_OW 69
2253: PUSH
2254: LD_EXP 4
2258: NOT
2259: AND
2260: IFFALSE 2273
2262: GO 2264
2264: DISABLE
// begin deltaBuilded := true ;
2265: LD_ADDR_EXP 4
2269: PUSH
2270: LD_INT 1
2272: ST_TO_ADDR
// end ;
2273: END
// every 0 0$01 trigger not Delta and deltaBuilded and FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) do
2274: LD_EXP 6
2278: NOT
2279: PUSH
2280: LD_EXP 4
2284: AND
2285: PUSH
2286: LD_INT 22
2288: PUSH
2289: LD_INT 1
2291: PUSH
2292: EMPTY
2293: LIST
2294: LIST
2295: PUSH
2296: LD_INT 3
2298: PUSH
2299: LD_INT 57
2301: PUSH
2302: EMPTY
2303: LIST
2304: PUSH
2305: EMPTY
2306: LIST
2307: LIST
2308: PUSH
2309: LD_INT 30
2311: PUSH
2312: LD_INT 0
2314: PUSH
2315: EMPTY
2316: LIST
2317: LIST
2318: PUSH
2319: EMPTY
2320: LIST
2321: LIST
2322: LIST
2323: PUSH
2324: EMPTY
2325: LIST
2326: PPUSH
2327: CALL_OW 69
2331: AND
2332: IFFALSE 2418
2334: GO 2336
2336: DISABLE
// begin enable ;
2337: ENABLE
// SetRestrict ( b_depot , 1 , state_disabled ) ;
2338: LD_INT 0
2340: PPUSH
2341: LD_INT 1
2343: PPUSH
2344: LD_INT 0
2346: PPUSH
2347: CALL_OW 324
// Delta := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) [ 1 ] ;
2351: LD_ADDR_EXP 6
2355: PUSH
2356: LD_INT 22
2358: PUSH
2359: LD_INT 1
2361: PUSH
2362: EMPTY
2363: LIST
2364: LIST
2365: PUSH
2366: LD_INT 3
2368: PUSH
2369: LD_INT 57
2371: PUSH
2372: EMPTY
2373: LIST
2374: PUSH
2375: EMPTY
2376: LIST
2377: LIST
2378: PUSH
2379: LD_INT 30
2381: PUSH
2382: LD_INT 0
2384: PUSH
2385: EMPTY
2386: LIST
2387: LIST
2388: PUSH
2389: EMPTY
2390: LIST
2391: LIST
2392: LIST
2393: PUSH
2394: EMPTY
2395: LIST
2396: PPUSH
2397: CALL_OW 69
2401: PUSH
2402: LD_INT 1
2404: ARRAY
2405: ST_TO_ADDR
// SetBName ( Delta , Delta ) ;
2406: LD_EXP 6
2410: PPUSH
2411: LD_STRING Delta
2413: PPUSH
2414: CALL_OW 500
// end ;
2418: END
// every 0 0$2 trigger GetTech ( tech_ApeLang , 1 ) = state_researched do
2419: LD_INT 1
2421: PPUSH
2422: LD_INT 1
2424: PPUSH
2425: CALL_OW 321
2429: PUSH
2430: LD_INT 2
2432: EQUAL
2433: IFFALSE 2494
2435: GO 2437
2437: DISABLE
// begin DialogueOn ;
2438: CALL_OW 6
// Say ( Gladstone , D3-Glad-1 ) ;
2442: LD_EXP 16
2446: PPUSH
2447: LD_STRING D3-Glad-1
2449: PPUSH
2450: CALL_OW 88
// Say ( JMM , D3-JMM-1 ) ;
2454: LD_EXP 15
2458: PPUSH
2459: LD_STRING D3-JMM-1
2461: PPUSH
2462: CALL_OW 88
// Say ( Gladstone , D3-Glad-2 ) ;
2466: LD_EXP 16
2470: PPUSH
2471: LD_STRING D3-Glad-2
2473: PPUSH
2474: CALL_OW 88
// Say ( JMM , D3-JMM-2 ) ;
2478: LD_EXP 15
2482: PPUSH
2483: LD_STRING D3-JMM-2
2485: PPUSH
2486: CALL_OW 88
// DialogueOff ;
2490: CALL_OW 7
// end ;
2494: END
// every 0 0$1 trigger GetTech ( tech_ApePsych , 1 ) = state_researched do var sol ;
2495: LD_INT 2
2497: PPUSH
2498: LD_INT 1
2500: PPUSH
2501: CALL_OW 321
2505: PUSH
2506: LD_INT 2
2508: EQUAL
2509: IFFALSE 2686
2511: GO 2513
2513: DISABLE
2514: LD_INT 0
2516: PPUSH
// begin DialogueOn ;
2517: CALL_OW 6
// if Frank then
2521: LD_EXP 22
2525: IFFALSE 2539
// Say ( Frank , D8a-Frank-1 ) ;
2527: LD_EXP 22
2531: PPUSH
2532: LD_STRING D8a-Frank-1
2534: PPUSH
2535: CALL_OW 88
// sol := SayX ( UnitFilter ( others , [ f_sex , sex_male ] ) , D8a-Sol1-1 ) ;
2539: LD_ADDR_VAR 0 1
2543: PUSH
2544: LD_EXP 25
2548: PPUSH
2549: LD_INT 26
2551: PUSH
2552: LD_INT 1
2554: PUSH
2555: EMPTY
2556: LIST
2557: LIST
2558: PPUSH
2559: CALL_OW 72
2563: PPUSH
2564: LD_STRING D8a-Sol1-1
2566: PPUSH
2567: CALL 447 0 2
2571: ST_TO_ADDR
// if Denis and GetSide ( Denis ) = 1 then
2572: LD_EXP 18
2576: PUSH
2577: LD_EXP 18
2581: PPUSH
2582: CALL_OW 255
2586: PUSH
2587: LD_INT 1
2589: EQUAL
2590: AND
2591: IFFALSE 2605
// Say ( Denis , D8a-Den-1 ) ;
2593: LD_EXP 18
2597: PPUSH
2598: LD_STRING D8a-Den-1
2600: PPUSH
2601: CALL_OW 88
// if sol or Denis or Frank then
2605: LD_VAR 0 1
2609: PUSH
2610: LD_EXP 18
2614: OR
2615: PUSH
2616: LD_EXP 22
2620: OR
2621: IFFALSE 2682
// begin SayX ( UnitFilter ( others , [ [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff sol , D8a-Sci1-1 ) ;
2623: LD_EXP 25
2627: PPUSH
2628: LD_INT 25
2630: PUSH
2631: LD_INT 4
2633: PUSH
2634: EMPTY
2635: LIST
2636: LIST
2637: PUSH
2638: LD_INT 26
2640: PUSH
2641: LD_INT 1
2643: PUSH
2644: EMPTY
2645: LIST
2646: LIST
2647: PUSH
2648: EMPTY
2649: LIST
2650: LIST
2651: PPUSH
2652: CALL_OW 72
2656: PUSH
2657: LD_VAR 0 1
2661: DIFF
2662: PPUSH
2663: LD_STRING D8a-Sci1-1
2665: PPUSH
2666: CALL 447 0 2
// Say ( JMM , D8a-JMM-1 ) ;
2670: LD_EXP 15
2674: PPUSH
2675: LD_STRING D8a-JMM-1
2677: PPUSH
2678: CALL_OW 88
// end ; DialogueOff ;
2682: CALL_OW 7
// end ;
2686: PPOPN 1
2688: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) do
2689: LD_INT 22
2691: PUSH
2692: LD_INT 1
2694: PUSH
2695: EMPTY
2696: LIST
2697: LIST
2698: PUSH
2699: LD_INT 25
2701: PUSH
2702: LD_INT 16
2704: PUSH
2705: EMPTY
2706: LIST
2707: LIST
2708: PUSH
2709: EMPTY
2710: LIST
2711: LIST
2712: PPUSH
2713: CALL_OW 69
2717: IFFALSE 2776
2719: GO 2721
2721: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
2722: LD_STRING M1a
2724: PPUSH
2725: CALL_OW 337
// case Query ( Q2 ) of 1 :
2729: LD_STRING Q2
2731: PPUSH
2732: CALL_OW 97
2736: PUSH
2737: LD_INT 1
2739: DOUBLE
2740: EQUAL
2741: IFTRUE 2745
2743: GO 2756
2745: POP
// end_mission := true ; 2 :
2746: LD_ADDR_EXP 14
2750: PUSH
2751: LD_INT 1
2753: ST_TO_ADDR
2754: GO 2776
2756: LD_INT 2
2758: DOUBLE
2759: EQUAL
2760: IFTRUE 2764
2762: GO 2775
2764: POP
// end_the_mission_allowed := true ; end ;
2765: LD_ADDR_OWVAR 57
2769: PUSH
2770: LD_INT 1
2772: ST_TO_ADDR
2773: GO 2776
2775: POP
// end ;
2776: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) and Delta do
2777: LD_INT 22
2779: PUSH
2780: LD_INT 1
2782: PUSH
2783: EMPTY
2784: LIST
2785: LIST
2786: PUSH
2787: LD_INT 2
2789: PUSH
2790: LD_INT 30
2792: PUSH
2793: LD_INT 6
2795: PUSH
2796: EMPTY
2797: LIST
2798: LIST
2799: PUSH
2800: LD_INT 30
2802: PUSH
2803: LD_INT 7
2805: PUSH
2806: EMPTY
2807: LIST
2808: LIST
2809: PUSH
2810: EMPTY
2811: LIST
2812: LIST
2813: LIST
2814: PUSH
2815: EMPTY
2816: LIST
2817: LIST
2818: PPUSH
2819: CALL_OW 69
2823: PUSH
2824: LD_INT 22
2826: PUSH
2827: LD_INT 1
2829: PUSH
2830: EMPTY
2831: LIST
2832: LIST
2833: PUSH
2834: LD_INT 2
2836: PUSH
2837: LD_INT 30
2839: PUSH
2840: LD_INT 2
2842: PUSH
2843: EMPTY
2844: LIST
2845: LIST
2846: PUSH
2847: LD_INT 30
2849: PUSH
2850: LD_INT 3
2852: PUSH
2853: EMPTY
2854: LIST
2855: LIST
2856: PUSH
2857: EMPTY
2858: LIST
2859: LIST
2860: LIST
2861: PUSH
2862: EMPTY
2863: LIST
2864: LIST
2865: PPUSH
2866: CALL_OW 69
2870: AND
2871: PUSH
2872: LD_EXP 6
2876: AND
2877: IFFALSE 3304
2879: GO 2881
2881: DISABLE
// begin Wait ( rand ( 0 0$20 , 0 0$40 ) ) ;
2882: LD_INT 700
2884: PPUSH
2885: LD_INT 1400
2887: PPUSH
2888: CALL_OW 12
2892: PPUSH
2893: CALL_OW 67
// PlaceUnitArea ( Denis , [ denisArea1 , denisArea2 , denisArea3 ] [ Difficulty ] , false ) ;
2897: LD_EXP 18
2901: PPUSH
2902: LD_INT 6
2904: PUSH
2905: LD_INT 9
2907: PUSH
2908: LD_INT 10
2910: PUSH
2911: EMPTY
2912: LIST
2913: LIST
2914: LIST
2915: PUSH
2916: LD_OWVAR 67
2920: ARRAY
2921: PPUSH
2922: LD_INT 0
2924: PPUSH
2925: CALL_OW 49
// ComHold ( Denis ) ;
2929: LD_EXP 18
2933: PPUSH
2934: CALL_OW 140
// InGameOn ;
2938: CALL_OW 8
// DialogueOn ;
2942: CALL_OW 6
// if Delta then
2946: LD_EXP 6
2950: IFFALSE 2963
// CenterNowOnUnits ( Delta ) else
2952: LD_EXP 6
2956: PPUSH
2957: CALL_OW 87
2961: GO 2972
// CenterNowOnUnits ( JMM ) ;
2963: LD_EXP 15
2967: PPUSH
2968: CALL_OW 87
// SayRadio ( Denis , DD-Den-1 ) ;
2972: LD_EXP 18
2976: PPUSH
2977: LD_STRING DD-Den-1
2979: PPUSH
2980: CALL_OW 94
// Say ( JMM , DD-JMM-1 ) ;
2984: LD_EXP 15
2988: PPUSH
2989: LD_STRING DD-JMM-1
2991: PPUSH
2992: CALL_OW 88
// SayRadio ( Denis , DD-Den-2 ) ;
2996: LD_EXP 18
3000: PPUSH
3001: LD_STRING DD-Den-2
3003: PPUSH
3004: CALL_OW 94
// Wait ( 3 ) ;
3008: LD_INT 3
3010: PPUSH
3011: CALL_OW 67
// DialogueOff ;
3015: CALL_OW 7
// InGameOff ;
3019: CALL_OW 9
// repeat wait ( 0 0$01 ) ;
3023: LD_INT 35
3025: PPUSH
3026: CALL_OW 67
// until See ( 1 , Denis ) or IsDead ( Denis ) ;
3030: LD_INT 1
3032: PPUSH
3033: LD_EXP 18
3037: PPUSH
3038: CALL_OW 292
3042: PUSH
3043: LD_EXP 18
3047: PPUSH
3048: CALL_OW 301
3052: OR
3053: IFFALSE 3023
// if IsDead ( Denis ) then
3055: LD_EXP 18
3059: PPUSH
3060: CALL_OW 301
3064: IFFALSE 3068
// exit ;
3066: GO 3304
// SetSide ( Denis , 1 ) ;
3068: LD_EXP 18
3072: PPUSH
3073: LD_INT 1
3075: PPUSH
3076: CALL_OW 235
// Say ( Denis , DD-Den-2a ) ;
3080: LD_EXP 18
3084: PPUSH
3085: LD_STRING DD-Den-2a
3087: PPUSH
3088: CALL_OW 88
// repeat wait ( 0 0$01 ) ;
3092: LD_INT 35
3094: PPUSH
3095: CALL_OW 67
// until GetBType ( IsInUnit ( Denis ) ) in [ b_lab , b_lab_half , b_lab_full ] or IsDead ( Denis ) ;
3099: LD_EXP 18
3103: PPUSH
3104: CALL_OW 310
3108: PPUSH
3109: CALL_OW 266
3113: PUSH
3114: LD_INT 6
3116: PUSH
3117: LD_INT 7
3119: PUSH
3120: LD_INT 8
3122: PUSH
3123: EMPTY
3124: LIST
3125: LIST
3126: LIST
3127: IN
3128: PUSH
3129: LD_EXP 18
3133: PPUSH
3134: CALL_OW 301
3138: OR
3139: IFFALSE 3092
// if IsDead ( Denis ) then
3141: LD_EXP 18
3145: PPUSH
3146: CALL_OW 301
3150: IFFALSE 3154
// exit ;
3152: GO 3304
// Say ( Denis , DD-Den-2b ) ;
3154: LD_EXP 18
3158: PPUSH
3159: LD_STRING DD-Den-2b
3161: PPUSH
3162: CALL_OW 88
// ComChangeProfession ( Denis , 4 ) ;
3166: LD_EXP 18
3170: PPUSH
3171: LD_INT 4
3173: PPUSH
3174: CALL_OW 123
// Wait ( 0 0$02 ) ;
3178: LD_INT 70
3180: PPUSH
3181: CALL_OW 67
// DialogueOn ;
3185: CALL_OW 6
// CenterNowOnUnits ( Denis ) ;
3189: LD_EXP 18
3193: PPUSH
3194: CALL_OW 87
// Say ( JMM , D4-JMM-1 ) ;
3198: LD_EXP 15
3202: PPUSH
3203: LD_STRING D4-JMM-1
3205: PPUSH
3206: CALL_OW 88
// Say ( Denis , D4-Den-1 ) ;
3210: LD_EXP 18
3214: PPUSH
3215: LD_STRING D4-Den-1
3217: PPUSH
3218: CALL_OW 88
// Say ( JMM , D4-JMM-2 ) ;
3222: LD_EXP 15
3226: PPUSH
3227: LD_STRING D4-JMM-2
3229: PPUSH
3230: CALL_OW 88
// Say ( Denis , D4-Den-2 ) ;
3234: LD_EXP 18
3238: PPUSH
3239: LD_STRING D4-Den-2
3241: PPUSH
3242: CALL_OW 88
// DialogueOff ;
3246: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
3250: LD_STRING M2
3252: PPUSH
3253: CALL_OW 337
// radar_allowed := true ;
3257: LD_ADDR_EXP 7
3261: PUSH
3262: LD_INT 1
3264: ST_TO_ADDR
// SetTech ( tech_radar , 1 , state_enabled ) ;
3265: LD_INT 6
3267: PPUSH
3268: LD_INT 1
3270: PPUSH
3271: LD_INT 1
3273: PPUSH
3274: CALL_OW 322
// SetRestrict ( b_lab_opto , 1 , state_enabled ) ;
3278: LD_INT 15
3280: PPUSH
3281: LD_INT 1
3283: PPUSH
3284: LD_INT 1
3286: PPUSH
3287: CALL_OW 324
// SetRestrict ( b_ext_radar , 1 , state_enabled ) ;
3291: LD_INT 20
3293: PPUSH
3294: LD_INT 1
3296: PPUSH
3297: LD_INT 1
3299: PPUSH
3300: CALL_OW 324
// end ;
3304: END
// every 0 0$1 trigger arab_spotted do var sol , sol2 ;
3305: LD_EXP 13
3309: IFFALSE 3932
3311: GO 3313
3313: DISABLE
3314: LD_INT 0
3316: PPUSH
3317: PPUSH
// begin sol := SayX ( UnitFilter ( others , [ f_sex , sex_male ] ) , D5-Sol1-1 ) ;
3318: LD_ADDR_VAR 0 1
3322: PUSH
3323: LD_EXP 25
3327: PPUSH
3328: LD_INT 26
3330: PUSH
3331: LD_INT 1
3333: PUSH
3334: EMPTY
3335: LIST
3336: LIST
3337: PPUSH
3338: CALL_OW 72
3342: PPUSH
3343: LD_STRING D5-Sol1-1
3345: PPUSH
3346: CALL 447 0 2
3350: ST_TO_ADDR
// if not sol then
3351: LD_VAR 0 1
3355: NOT
3356: IFFALSE 3360
// exit ;
3358: GO 3932
// repeat wait ( 0 0$01 ) ;
3360: LD_INT 35
3362: PPUSH
3363: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 ;
3367: LD_INT 22
3369: PUSH
3370: LD_INT 2
3372: PUSH
3373: EMPTY
3374: LIST
3375: LIST
3376: PUSH
3377: LD_INT 21
3379: PUSH
3380: LD_INT 1
3382: PUSH
3383: EMPTY
3384: LIST
3385: LIST
3386: PUSH
3387: EMPTY
3388: LIST
3389: LIST
3390: PPUSH
3391: CALL_OW 69
3395: PUSH
3396: LD_INT 0
3398: EQUAL
3399: IFFALSE 3360
// if IsOk ( sol ) then
3401: LD_VAR 0 1
3405: PPUSH
3406: CALL_OW 302
3410: IFFALSE 3430
// begin sol2 := others diff sol ;
3412: LD_ADDR_VAR 0 2
3416: PUSH
3417: LD_EXP 25
3421: PUSH
3422: LD_VAR 0 1
3426: DIFF
3427: ST_TO_ADDR
// end else
3428: GO 3432
// exit ;
3430: GO 3932
// if not Lisa and not sol2 then
3432: LD_EXP 21
3436: NOT
3437: PUSH
3438: LD_VAR 0 2
3442: NOT
3443: AND
3444: IFFALSE 3448
// exit ;
3446: GO 3932
// DialogueOn ;
3448: CALL_OW 6
// if Lisa then
3452: LD_EXP 21
3456: IFFALSE 3472
// Say ( Lisa , D5a-Lisa-1 ) else
3458: LD_EXP 21
3462: PPUSH
3463: LD_STRING D5a-Lisa-1
3465: PPUSH
3466: CALL_OW 88
3470: GO 3547
// if sol2 then
3472: LD_VAR 0 2
3476: IFFALSE 3547
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3478: LD_VAR 0 2
3482: PUSH
3483: LD_INT 1
3485: ARRAY
3486: PPUSH
3487: CALL_OW 258
3491: PUSH
3492: LD_INT 1
3494: DOUBLE
3495: EQUAL
3496: IFTRUE 3500
3498: GO 3519
3500: POP
// Say ( sol2 [ 1 ] , D5-Sol2-1 ) ; sex_female :
3501: LD_VAR 0 2
3505: PUSH
3506: LD_INT 1
3508: ARRAY
3509: PPUSH
3510: LD_STRING D5-Sol2-1
3512: PPUSH
3513: CALL_OW 88
3517: GO 3547
3519: LD_INT 2
3521: DOUBLE
3522: EQUAL
3523: IFTRUE 3527
3525: GO 3546
3527: POP
// Say ( sol2 [ 1 ] , D5-FSol2-1 ) ; end ;
3528: LD_VAR 0 2
3532: PUSH
3533: LD_INT 1
3535: ARRAY
3536: PPUSH
3537: LD_STRING D5-FSol2-1
3539: PPUSH
3540: CALL_OW 88
3544: GO 3547
3546: POP
// Say ( sol , D5-Sol1-2 ) ;
3547: LD_VAR 0 1
3551: PPUSH
3552: LD_STRING D5-Sol1-2
3554: PPUSH
3555: CALL_OW 88
// if Lisa then
3559: LD_EXP 21
3563: IFFALSE 3579
// Say ( Lisa , D5a-Lisa-2 ) else
3565: LD_EXP 21
3569: PPUSH
3570: LD_STRING D5a-Lisa-2
3572: PPUSH
3573: CALL_OW 88
3577: GO 3654
// if sol2 then
3579: LD_VAR 0 2
3583: IFFALSE 3654
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3585: LD_VAR 0 2
3589: PUSH
3590: LD_INT 1
3592: ARRAY
3593: PPUSH
3594: CALL_OW 258
3598: PUSH
3599: LD_INT 1
3601: DOUBLE
3602: EQUAL
3603: IFTRUE 3607
3605: GO 3626
3607: POP
// Say ( sol2 [ 1 ] , D5-Sol2-2 ) ; sex_female :
3608: LD_VAR 0 2
3612: PUSH
3613: LD_INT 1
3615: ARRAY
3616: PPUSH
3617: LD_STRING D5-Sol2-2
3619: PPUSH
3620: CALL_OW 88
3624: GO 3654
3626: LD_INT 2
3628: DOUBLE
3629: EQUAL
3630: IFTRUE 3634
3632: GO 3653
3634: POP
// Say ( sol2 [ 1 ] , D5-FSol2-2 ) ; end ;
3635: LD_VAR 0 2
3639: PUSH
3640: LD_INT 1
3642: ARRAY
3643: PPUSH
3644: LD_STRING D5-FSol2-2
3646: PPUSH
3647: CALL_OW 88
3651: GO 3654
3653: POP
// Say ( sol , D5a-Sol1-3 ) ;
3654: LD_VAR 0 1
3658: PPUSH
3659: LD_STRING D5a-Sol1-3
3661: PPUSH
3662: CALL_OW 88
// if Lisa then
3666: LD_EXP 21
3670: IFFALSE 3684
// Say ( Lisa , D5a-Lisa-3 ) ;
3672: LD_EXP 21
3676: PPUSH
3677: LD_STRING D5a-Lisa-3
3679: PPUSH
3680: CALL_OW 88
// if not sol2 then
3684: LD_VAR 0 2
3688: NOT
3689: IFFALSE 3697
// begin DialogueOff ;
3691: CALL_OW 7
// exit ;
3695: GO 3932
// end ; case GetSex ( sol2 [ 1 ] ) of sex_male :
3697: LD_VAR 0 2
3701: PUSH
3702: LD_INT 1
3704: ARRAY
3705: PPUSH
3706: CALL_OW 258
3710: PUSH
3711: LD_INT 1
3713: DOUBLE
3714: EQUAL
3715: IFTRUE 3719
3717: GO 3738
3719: POP
// Say ( sol2 [ 1 ] , D5-Sol2-3 ) ; sex_female :
3720: LD_VAR 0 2
3724: PUSH
3725: LD_INT 1
3727: ARRAY
3728: PPUSH
3729: LD_STRING D5-Sol2-3
3731: PPUSH
3732: CALL_OW 88
3736: GO 3766
3738: LD_INT 2
3740: DOUBLE
3741: EQUAL
3742: IFTRUE 3746
3744: GO 3765
3746: POP
// Say ( sol2 [ 1 ] , D5-FSol2-3 ) ; end ;
3747: LD_VAR 0 2
3751: PUSH
3752: LD_INT 1
3754: ARRAY
3755: PPUSH
3756: LD_STRING D5-FSol2-3
3758: PPUSH
3759: CALL_OW 88
3763: GO 3766
3765: POP
// Say ( sol , D5-Sol1-4 ) ;
3766: LD_VAR 0 1
3770: PPUSH
3771: LD_STRING D5-Sol1-4
3773: PPUSH
3774: CALL_OW 88
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3778: LD_VAR 0 2
3782: PUSH
3783: LD_INT 1
3785: ARRAY
3786: PPUSH
3787: CALL_OW 258
3791: PUSH
3792: LD_INT 1
3794: DOUBLE
3795: EQUAL
3796: IFTRUE 3800
3798: GO 3819
3800: POP
// Say ( sol2 [ 1 ] , D5-Sol2-4 ) ; sex_female :
3801: LD_VAR 0 2
3805: PUSH
3806: LD_INT 1
3808: ARRAY
3809: PPUSH
3810: LD_STRING D5-Sol2-4
3812: PPUSH
3813: CALL_OW 88
3817: GO 3847
3819: LD_INT 2
3821: DOUBLE
3822: EQUAL
3823: IFTRUE 3827
3825: GO 3846
3827: POP
// Say ( sol2 [ 1 ] , D5-FSol2-4 ) ; end ;
3828: LD_VAR 0 2
3832: PUSH
3833: LD_INT 1
3835: ARRAY
3836: PPUSH
3837: LD_STRING D5-FSol2-4
3839: PPUSH
3840: CALL_OW 88
3844: GO 3847
3846: POP
// Say ( sol , D5-Sol1-5 ) ;
3847: LD_VAR 0 1
3851: PPUSH
3852: LD_STRING D5-Sol1-5
3854: PPUSH
3855: CALL_OW 88
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3859: LD_VAR 0 2
3863: PUSH
3864: LD_INT 1
3866: ARRAY
3867: PPUSH
3868: CALL_OW 258
3872: PUSH
3873: LD_INT 1
3875: DOUBLE
3876: EQUAL
3877: IFTRUE 3881
3879: GO 3900
3881: POP
// Say ( sol2 [ 1 ] , D5-Sol2-5 ) ; sex_female :
3882: LD_VAR 0 2
3886: PUSH
3887: LD_INT 1
3889: ARRAY
3890: PPUSH
3891: LD_STRING D5-Sol2-5
3893: PPUSH
3894: CALL_OW 88
3898: GO 3928
3900: LD_INT 2
3902: DOUBLE
3903: EQUAL
3904: IFTRUE 3908
3906: GO 3927
3908: POP
// Say ( sol2 [ 1 ] , D5-FSol2-5 ) ; end ;
3909: LD_VAR 0 2
3913: PUSH
3914: LD_INT 1
3916: ARRAY
3917: PPUSH
3918: LD_STRING D5-FSol2-5
3920: PPUSH
3921: CALL_OW 88
3925: GO 3928
3927: POP
// DialogueOff ;
3928: CALL_OW 7
// end ;
3932: PPOPN 2
3934: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) >= 5 do
3935: LD_INT 22
3937: PUSH
3938: LD_INT 1
3940: PUSH
3941: EMPTY
3942: LIST
3943: LIST
3944: PUSH
3945: LD_INT 25
3947: PUSH
3948: LD_INT 16
3950: PUSH
3951: EMPTY
3952: LIST
3953: LIST
3954: PUSH
3955: EMPTY
3956: LIST
3957: LIST
3958: PPUSH
3959: CALL_OW 69
3963: PUSH
3964: LD_INT 5
3966: GREATEREQUAL
3967: IFFALSE 3987
3969: GO 3971
3971: DISABLE
// begin ChangeMissionObjectives ( M1b ) ;
3972: LD_STRING M1b
3974: PPUSH
3975: CALL_OW 337
// apeman_army := true ;
3979: LD_ADDR_EXP 9
3983: PUSH
3984: LD_INT 1
3986: ST_TO_ADDR
// end ;
3987: END
// every 0 0$1 trigger GetTech ( tech_radar , 1 ) = state_researched do
3988: LD_INT 6
3990: PPUSH
3991: LD_INT 1
3993: PPUSH
3994: CALL_OW 321
3998: PUSH
3999: LD_INT 2
4001: EQUAL
4002: IFFALSE 4022
4004: GO 4006
4006: DISABLE
// begin ChangeMissionObjectives ( M2a ) ;
4007: LD_STRING M2a
4009: PPUSH
4010: CALL_OW 337
// radar_researched := true ;
4014: LD_ADDR_EXP 10
4018: PUSH
4019: LD_INT 1
4021: ST_TO_ADDR
// end ;
4022: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_weapon , us_radar ] , [ f_bweapon , us_radar ] ] ] ) do
4023: LD_INT 22
4025: PUSH
4026: LD_INT 1
4028: PUSH
4029: EMPTY
4030: LIST
4031: LIST
4032: PUSH
4033: LD_INT 2
4035: PUSH
4036: LD_INT 34
4038: PUSH
4039: LD_INT 11
4041: PUSH
4042: EMPTY
4043: LIST
4044: LIST
4045: PUSH
4046: LD_INT 35
4048: PUSH
4049: LD_INT 11
4051: PUSH
4052: EMPTY
4053: LIST
4054: LIST
4055: PUSH
4056: EMPTY
4057: LIST
4058: LIST
4059: LIST
4060: PUSH
4061: EMPTY
4062: LIST
4063: LIST
4064: PPUSH
4065: CALL_OW 69
4069: IFFALSE 4089
4071: GO 4073
4073: DISABLE
// begin ChangeMissionObjectives ( M2b ) ;
4074: LD_STRING M2b
4076: PPUSH
4077: CALL_OW 337
// radar_builded := true ;
4081: LD_ADDR_EXP 11
4085: PUSH
4086: LD_INT 1
4088: ST_TO_ADDR
// end ;
4089: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) = 0 and not first_apeman_tamed do
4090: LD_INT 22
4092: PUSH
4093: LD_INT 0
4095: PUSH
4096: EMPTY
4097: LIST
4098: LIST
4099: PUSH
4100: LD_INT 25
4102: PUSH
4103: LD_INT 12
4105: PUSH
4106: EMPTY
4107: LIST
4108: LIST
4109: PUSH
4110: EMPTY
4111: LIST
4112: LIST
4113: PPUSH
4114: CALL_OW 69
4118: PUSH
4119: LD_INT 0
4121: EQUAL
4122: PUSH
4123: LD_EXP 8
4127: NOT
4128: AND
4129: IFFALSE 4141
4131: GO 4133
4133: DISABLE
// YouLost ( Apeman ) ;
4134: LD_STRING Apeman
4136: PPUSH
4137: CALL_OW 104
4141: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) >= 7 do var i , filter ;
4142: LD_INT 22
4144: PUSH
4145: LD_INT 1
4147: PUSH
4148: EMPTY
4149: LIST
4150: LIST
4151: PUSH
4152: LD_INT 25
4154: PUSH
4155: LD_INT 16
4157: PUSH
4158: EMPTY
4159: LIST
4160: LIST
4161: PUSH
4162: EMPTY
4163: LIST
4164: LIST
4165: PPUSH
4166: CALL_OW 69
4170: PUSH
4171: LD_INT 7
4173: GREATEREQUAL
4174: IFFALSE 4272
4176: GO 4178
4178: DISABLE
4179: LD_INT 0
4181: PPUSH
4182: PPUSH
// begin filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , 4 ] ] ) ^ JMM ;
4183: LD_ADDR_VAR 0 2
4187: PUSH
4188: LD_INT 22
4190: PUSH
4191: LD_INT 1
4193: PUSH
4194: EMPTY
4195: LIST
4196: LIST
4197: PUSH
4198: LD_INT 21
4200: PUSH
4201: LD_INT 1
4203: PUSH
4204: EMPTY
4205: LIST
4206: LIST
4207: PUSH
4208: LD_INT 25
4210: PUSH
4211: LD_INT 4
4213: PUSH
4214: EMPTY
4215: LIST
4216: LIST
4217: PUSH
4218: EMPTY
4219: LIST
4220: LIST
4221: LIST
4222: PPUSH
4223: CALL_OW 69
4227: PUSH
4228: LD_EXP 15
4232: ADD
4233: ST_TO_ADDR
// if filter then
4234: LD_VAR 0 2
4238: IFFALSE 4272
// for i in filter do
4240: LD_ADDR_VAR 0 1
4244: PUSH
4245: LD_VAR 0 2
4249: PUSH
4250: FOR_IN
4251: IFFALSE 4270
// AddExperience ( i , 4 , 3500 ) ;
4253: LD_VAR 0 1
4257: PPUSH
4258: LD_INT 4
4260: PPUSH
4261: LD_INT 3500
4263: PPUSH
4264: CALL_OW 492
4268: GO 4250
4270: POP
4271: POP
// end ;
4272: PPOPN 2
4274: END
// every 0 0$1 trigger end_mission do var i , tmp ;
4275: LD_EXP 14
4279: IFFALSE 5290
4281: GO 4283
4283: DISABLE
4284: LD_INT 0
4286: PPUSH
4287: PPUSH
// begin if FilterAllUnits ( [ f_side , 2 ] ) then
4288: LD_INT 22
4290: PUSH
4291: LD_INT 2
4293: PUSH
4294: EMPTY
4295: LIST
4296: LIST
4297: PPUSH
4298: CALL_OW 69
4302: IFFALSE 4340
// for i in FilterAllUnits ( [ f_side , 2 ] ) do
4304: LD_ADDR_VAR 0 1
4308: PUSH
4309: LD_INT 22
4311: PUSH
4312: LD_INT 2
4314: PUSH
4315: EMPTY
4316: LIST
4317: LIST
4318: PPUSH
4319: CALL_OW 69
4323: PUSH
4324: FOR_IN
4325: IFFALSE 4338
// RemoveUnit ( i ) ;
4327: LD_VAR 0 1
4331: PPUSH
4332: CALL_OW 64
4336: GO 4324
4338: POP
4339: POP
// if apeman_army then
4340: LD_EXP 9
4344: IFFALSE 4358
// AddMedal ( Tame , 1 ) else
4346: LD_STRING Tame
4348: PPUSH
4349: LD_INT 1
4351: PPUSH
4352: CALL_OW 101
4356: GO 4369
// AddMedal ( Tame , - 1 ) ;
4358: LD_STRING Tame
4360: PPUSH
4361: LD_INT 1
4363: NEG
4364: PPUSH
4365: CALL_OW 101
// if radar_researched then
4369: LD_EXP 10
4373: IFFALSE 4397
// begin SaveVariable ( true , radarResInDelta ) ;
4375: LD_INT 1
4377: PPUSH
4378: LD_STRING radarResInDelta
4380: PPUSH
4381: CALL_OW 39
// AddMedal ( Radar , 1 ) ;
4385: LD_STRING Radar
4387: PPUSH
4388: LD_INT 1
4390: PPUSH
4391: CALL_OW 101
// end else
4395: GO 4427
// if radar_allowed then
4397: LD_EXP 7
4401: IFFALSE 4416
// AddMedal ( Radar , - 2 ) else
4403: LD_STRING Radar
4405: PPUSH
4406: LD_INT 2
4408: NEG
4409: PPUSH
4410: CALL_OW 101
4414: GO 4427
// AddMedal ( Radar , - 1 ) ;
4416: LD_STRING Radar
4418: PPUSH
4419: LD_INT 1
4421: NEG
4422: PPUSH
4423: CALL_OW 101
// if radar_builded then
4427: LD_EXP 11
4431: IFFALSE 4445
// AddMedal ( BuildRadar , 1 ) else
4433: LD_STRING BuildRadar
4435: PPUSH
4436: LD_INT 1
4438: PPUSH
4439: CALL_OW 101
4443: GO 4456
// AddMedal ( BuildRadar , - 1 ) ;
4445: LD_STRING BuildRadar
4447: PPUSH
4448: LD_INT 1
4450: NEG
4451: PPUSH
4452: CALL_OW 101
// GiveMedals ( MAIN ) ;
4456: LD_STRING MAIN
4458: PPUSH
4459: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
4463: LD_ADDR_VAR 0 2
4467: PUSH
4468: LD_INT 22
4470: PUSH
4471: LD_INT 1
4473: PUSH
4474: EMPTY
4475: LIST
4476: LIST
4477: PUSH
4478: LD_INT 21
4480: PUSH
4481: LD_INT 1
4483: PUSH
4484: EMPTY
4485: LIST
4486: LIST
4487: PUSH
4488: LD_INT 2
4490: PUSH
4491: LD_INT 25
4493: PUSH
4494: LD_INT 1
4496: PUSH
4497: EMPTY
4498: LIST
4499: LIST
4500: PUSH
4501: LD_INT 25
4503: PUSH
4504: LD_INT 2
4506: PUSH
4507: EMPTY
4508: LIST
4509: LIST
4510: PUSH
4511: LD_INT 25
4513: PUSH
4514: LD_INT 3
4516: PUSH
4517: EMPTY
4518: LIST
4519: LIST
4520: PUSH
4521: LD_INT 25
4523: PUSH
4524: LD_INT 4
4526: PUSH
4527: EMPTY
4528: LIST
4529: LIST
4530: PUSH
4531: EMPTY
4532: LIST
4533: LIST
4534: LIST
4535: LIST
4536: LIST
4537: PUSH
4538: EMPTY
4539: LIST
4540: LIST
4541: LIST
4542: PPUSH
4543: CALL_OW 69
4547: ST_TO_ADDR
// RewardPeople ( tmp ) ;
4548: LD_VAR 0 2
4552: PPUSH
4553: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
4557: LD_EXP 15
4561: PPUSH
4562: LD_EXP 2
4566: PUSH
4567: LD_STRING JMM
4569: STR
4570: PPUSH
4571: CALL_OW 38
// if IsOk ( Gladstone ) then
4575: LD_EXP 16
4579: PPUSH
4580: CALL_OW 302
4584: IFFALSE 4604
// begin SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
4586: LD_EXP 16
4590: PPUSH
4591: LD_EXP 2
4595: PUSH
4596: LD_STRING Gladstone
4598: STR
4599: PPUSH
4600: CALL_OW 38
// end ; if IsOk ( Denis ) and GetSide ( Denis ) = 1 then
4604: LD_EXP 18
4608: PPUSH
4609: CALL_OW 302
4613: PUSH
4614: LD_EXP 18
4618: PPUSH
4619: CALL_OW 255
4623: PUSH
4624: LD_INT 1
4626: EQUAL
4627: AND
4628: IFFALSE 4658
// begin SaveCharacters ( Denis , mission_prefix & Denis ) ;
4630: LD_EXP 18
4634: PPUSH
4635: LD_EXP 2
4639: PUSH
4640: LD_STRING Denis
4642: STR
4643: PPUSH
4644: CALL_OW 38
// SaveVariable ( true , DenisInDelta ) ;
4648: LD_INT 1
4650: PPUSH
4651: LD_STRING DenisInDelta
4653: PPUSH
4654: CALL_OW 39
// end ; if IsOk ( Lisa ) then
4658: LD_EXP 21
4662: PPUSH
4663: CALL_OW 302
4667: IFFALSE 4687
// begin SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
4669: LD_EXP 21
4673: PPUSH
4674: LD_EXP 2
4678: PUSH
4679: LD_STRING Lisa
4681: STR
4682: PPUSH
4683: CALL_OW 38
// end ; if IsOk ( Frank ) then
4687: LD_EXP 22
4691: PPUSH
4692: CALL_OW 302
4696: IFFALSE 4716
// begin SaveCharacters ( Frank , mission_prefix & Frank ) ;
4698: LD_EXP 22
4702: PPUSH
4703: LD_EXP 2
4707: PUSH
4708: LD_STRING Frank
4710: STR
4711: PPUSH
4712: CALL_OW 38
// end ; if IsOk ( Bobby ) then
4716: LD_EXP 23
4720: PPUSH
4721: CALL_OW 302
4725: IFFALSE 4745
// begin SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
4727: LD_EXP 23
4731: PPUSH
4732: LD_EXP 2
4736: PUSH
4737: LD_STRING Bobby
4739: STR
4740: PPUSH
4741: CALL_OW 38
// end ; if IsOk ( Cyrus ) then
4745: LD_EXP 24
4749: PPUSH
4750: CALL_OW 302
4754: IFFALSE 4774
// begin SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
4756: LD_EXP 24
4760: PPUSH
4761: LD_EXP 2
4765: PUSH
4766: LD_STRING Cyrus
4768: STR
4769: PPUSH
4770: CALL_OW 38
// end ; if IsOk ( Brown ) then
4774: LD_EXP 19
4778: PPUSH
4779: CALL_OW 302
4783: IFFALSE 4803
// begin SaveCharacters ( Brown , mission_prefix & Brown ) ;
4785: LD_EXP 19
4789: PPUSH
4790: LD_EXP 2
4794: PUSH
4795: LD_STRING Brown
4797: STR
4798: PPUSH
4799: CALL_OW 38
// end ; if IsOk ( Donaldson ) then
4803: LD_EXP 20
4807: PPUSH
4808: CALL_OW 302
4812: IFFALSE 4832
// begin SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
4814: LD_EXP 20
4818: PPUSH
4819: LD_EXP 2
4823: PUSH
4824: LD_STRING Donaldson
4826: STR
4827: PPUSH
4828: CALL_OW 38
// end ; if others then
4832: LD_EXP 25
4836: IFFALSE 4850
// SaveCharacters ( others , othersInDelta ) ;
4838: LD_EXP 25
4842: PPUSH
4843: LD_STRING othersInDelta
4845: PPUSH
4846: CALL_OW 38
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) then
4850: LD_INT 22
4852: PUSH
4853: LD_INT 1
4855: PUSH
4856: EMPTY
4857: LIST
4858: LIST
4859: PUSH
4860: LD_INT 25
4862: PUSH
4863: LD_INT 16
4865: PUSH
4866: EMPTY
4867: LIST
4868: LIST
4869: PUSH
4870: EMPTY
4871: LIST
4872: LIST
4873: PPUSH
4874: CALL_OW 69
4878: IFFALSE 4916
// SaveCharacters ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) , apeInDelta ) ;
4880: LD_INT 22
4882: PUSH
4883: LD_INT 1
4885: PUSH
4886: EMPTY
4887: LIST
4888: LIST
4889: PUSH
4890: LD_INT 25
4892: PUSH
4893: LD_INT 16
4895: PUSH
4896: EMPTY
4897: LIST
4898: LIST
4899: PUSH
4900: EMPTY
4901: LIST
4902: LIST
4903: PPUSH
4904: CALL_OW 69
4908: PPUSH
4909: LD_STRING apeInDelta
4911: PPUSH
4912: CALL_OW 38
// tmp := [ ] ;
4916: LD_ADDR_VAR 0 2
4920: PUSH
4921: EMPTY
4922: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) then
4923: LD_INT 22
4925: PUSH
4926: LD_INT 1
4928: PUSH
4929: EMPTY
4930: LIST
4931: LIST
4932: PUSH
4933: LD_INT 21
4935: PUSH
4936: LD_INT 2
4938: PUSH
4939: EMPTY
4940: LIST
4941: LIST
4942: PUSH
4943: EMPTY
4944: LIST
4945: LIST
4946: PPUSH
4947: CALL_OW 69
4951: IFFALSE 5062
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) do
4953: LD_ADDR_VAR 0 1
4957: PUSH
4958: LD_INT 22
4960: PUSH
4961: LD_INT 1
4963: PUSH
4964: EMPTY
4965: LIST
4966: LIST
4967: PUSH
4968: LD_INT 21
4970: PUSH
4971: LD_INT 2
4973: PUSH
4974: EMPTY
4975: LIST
4976: LIST
4977: PUSH
4978: EMPTY
4979: LIST
4980: LIST
4981: PPUSH
4982: CALL_OW 69
4986: PUSH
4987: FOR_IN
4988: IFFALSE 5060
// tmp := tmp ^ [ GetNation ( i ) , GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) ] ;
4990: LD_ADDR_VAR 0 2
4994: PUSH
4995: LD_VAR 0 2
4999: PUSH
5000: LD_VAR 0 1
5004: PPUSH
5005: CALL_OW 248
5009: PUSH
5010: LD_VAR 0 1
5014: PPUSH
5015: CALL_OW 265
5019: PUSH
5020: LD_VAR 0 1
5024: PPUSH
5025: CALL_OW 262
5029: PUSH
5030: LD_VAR 0 1
5034: PPUSH
5035: CALL_OW 263
5039: PUSH
5040: LD_VAR 0 1
5044: PPUSH
5045: CALL_OW 264
5049: PUSH
5050: EMPTY
5051: LIST
5052: LIST
5053: LIST
5054: LIST
5055: LIST
5056: ADD
5057: ST_TO_ADDR
5058: GO 4987
5060: POP
5061: POP
// if tmp then
5062: LD_VAR 0 2
5066: IFFALSE 5080
// SaveVariable ( tmp , vehiclesInDelta ) ;
5068: LD_VAR 0 2
5072: PPUSH
5073: LD_STRING vehiclesInDelta
5075: PPUSH
5076: CALL_OW 39
// tmp := [ ] ;
5080: LD_ADDR_VAR 0 2
5084: PUSH
5085: EMPTY
5086: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) then
5087: LD_INT 22
5089: PUSH
5090: LD_INT 1
5092: PUSH
5093: EMPTY
5094: LIST
5095: LIST
5096: PUSH
5097: LD_INT 21
5099: PUSH
5100: LD_INT 3
5102: PUSH
5103: EMPTY
5104: LIST
5105: LIST
5106: PUSH
5107: EMPTY
5108: LIST
5109: LIST
5110: PPUSH
5111: CALL_OW 69
5115: IFFALSE 5268
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
5117: LD_ADDR_VAR 0 1
5121: PUSH
5122: LD_INT 22
5124: PUSH
5125: LD_INT 1
5127: PUSH
5128: EMPTY
5129: LIST
5130: LIST
5131: PUSH
5132: LD_INT 21
5134: PUSH
5135: LD_INT 3
5137: PUSH
5138: EMPTY
5139: LIST
5140: LIST
5141: PUSH
5142: EMPTY
5143: LIST
5144: LIST
5145: PPUSH
5146: CALL_OW 69
5150: PUSH
5151: FOR_IN
5152: IFFALSE 5266
// tmp := tmp ^ [ [ GetBType ( i ) , GetBLevel ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
5154: LD_ADDR_VAR 0 2
5158: PUSH
5159: LD_VAR 0 2
5163: PUSH
5164: LD_VAR 0 1
5168: PPUSH
5169: CALL_OW 266
5173: PUSH
5174: LD_VAR 0 1
5178: PPUSH
5179: CALL_OW 267
5183: PUSH
5184: LD_VAR 0 1
5188: PPUSH
5189: CALL_OW 250
5193: PUSH
5194: LD_VAR 0 1
5198: PPUSH
5199: CALL_OW 251
5203: PUSH
5204: LD_VAR 0 1
5208: PPUSH
5209: CALL_OW 254
5213: PUSH
5214: LD_VAR 0 1
5218: PPUSH
5219: LD_INT 1
5221: PPUSH
5222: CALL_OW 268
5226: PUSH
5227: LD_VAR 0 1
5231: PPUSH
5232: LD_INT 2
5234: PPUSH
5235: CALL_OW 268
5239: PUSH
5240: LD_VAR 0 1
5244: PPUSH
5245: CALL_OW 269
5249: PUSH
5250: EMPTY
5251: LIST
5252: LIST
5253: LIST
5254: LIST
5255: LIST
5256: LIST
5257: LIST
5258: LIST
5259: PUSH
5260: EMPTY
5261: LIST
5262: ADD
5263: ST_TO_ADDR
5264: GO 5151
5266: POP
5267: POP
// if tmp then
5268: LD_VAR 0 2
5272: IFFALSE 5286
// SaveVariable ( tmp , buildingsInDelta ) ;
5274: LD_VAR 0 2
5278: PPUSH
5279: LD_STRING buildingsInDelta
5281: PPUSH
5282: CALL_OW 39
// YouWin ;
5286: CALL_OW 103
// end ; end_of_file
5290: PPOPN 2
5292: END
// export function PrepareArabianTroops ( amount , skill , area ) ; var i , un , tmp ; begin
5293: LD_INT 0
5295: PPUSH
5296: PPUSH
5297: PPUSH
5298: PPUSH
// InitHc ;
5299: CALL_OW 19
// InitUc ;
5303: CALL_OW 18
// uc_side := 2 ;
5307: LD_ADDR_OWVAR 20
5311: PUSH
5312: LD_INT 2
5314: ST_TO_ADDR
// uc_nation := 2 ;
5315: LD_ADDR_OWVAR 21
5319: PUSH
5320: LD_INT 2
5322: ST_TO_ADDR
// if not amount then
5323: LD_VAR 0 1
5327: NOT
5328: IFFALSE 5332
// exit ;
5330: GO 5455
// for i = 1 to amount do
5332: LD_ADDR_VAR 0 5
5336: PUSH
5337: DOUBLE
5338: LD_INT 1
5340: DEC
5341: ST_TO_ADDR
5342: LD_VAR 0 1
5346: PUSH
5347: FOR_TO
5348: IFFALSE 5443
// begin PrepareHuman ( false , 1 , skill ) ;
5350: LD_INT 0
5352: PPUSH
5353: LD_INT 1
5355: PPUSH
5356: LD_VAR 0 2
5360: PPUSH
5361: CALL_OW 380
// un := CreateHuman ;
5365: LD_ADDR_VAR 0 6
5369: PUSH
5370: CALL_OW 44
5374: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
5375: LD_ADDR_VAR 0 7
5379: PUSH
5380: LD_VAR 0 7
5384: PPUSH
5385: LD_INT 1
5387: PPUSH
5388: LD_VAR 0 6
5392: PPUSH
5393: CALL_OW 2
5397: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5398: LD_VAR 0 6
5402: PPUSH
5403: LD_VAR 0 3
5407: PPUSH
5408: LD_INT 0
5410: PPUSH
5411: CALL_OW 49
// if i mod 2 = 0 then
5415: LD_VAR 0 5
5419: PUSH
5420: LD_INT 2
5422: MOD
5423: PUSH
5424: LD_INT 0
5426: EQUAL
5427: IFFALSE 5441
// SetTag ( un , 11 ) ;
5429: LD_VAR 0 6
5433: PPUSH
5434: LD_INT 11
5436: PPUSH
5437: CALL_OW 109
// end ;
5441: GO 5347
5443: POP
5444: POP
// result := tmp ;
5445: LD_ADDR_VAR 0 4
5449: PUSH
5450: LD_VAR 0 7
5454: ST_TO_ADDR
// end ;
5455: LD_VAR 0 4
5459: RET
// export ar_forces , ap_killers ; every 0 0$1 trigger Delta do var i , timer , more_troops , skill , eng , un , veh , force ;
5460: LD_EXP 6
5464: IFFALSE 6331
5466: GO 5468
5468: DISABLE
5469: LD_INT 0
5471: PPUSH
5472: PPUSH
5473: PPUSH
5474: PPUSH
5475: PPUSH
5476: PPUSH
5477: PPUSH
5478: PPUSH
// begin more_troops := false ;
5479: LD_ADDR_VAR 0 3
5483: PUSH
5484: LD_INT 0
5486: ST_TO_ADDR
// skill := [ 3 , 4 , 5 ] [ Difficulty ] ;
5487: LD_ADDR_VAR 0 4
5491: PUSH
5492: LD_INT 3
5494: PUSH
5495: LD_INT 4
5497: PUSH
5498: LD_INT 5
5500: PUSH
5501: EMPTY
5502: LIST
5503: LIST
5504: LIST
5505: PUSH
5506: LD_OWVAR 67
5510: ARRAY
5511: ST_TO_ADDR
// timer := [ 5 5$00 , 4 4$00 , 3 3$00 ] [ Difficulty ] ;
5512: LD_ADDR_VAR 0 2
5516: PUSH
5517: LD_INT 10500
5519: PUSH
5520: LD_INT 8400
5522: PUSH
5523: LD_INT 6300
5525: PUSH
5526: EMPTY
5527: LIST
5528: LIST
5529: LIST
5530: PUSH
5531: LD_OWVAR 67
5535: ARRAY
5536: ST_TO_ADDR
// force := [ ] ;
5537: LD_ADDR_VAR 0 8
5541: PUSH
5542: EMPTY
5543: ST_TO_ADDR
// ar_forces := [ ] ;
5544: LD_ADDR_EXP 26
5548: PUSH
5549: EMPTY
5550: ST_TO_ADDR
// ap_killers := [ ] ;
5551: LD_ADDR_EXP 27
5555: PUSH
5556: EMPTY
5557: ST_TO_ADDR
// Wait ( timer ) ;
5558: LD_VAR 0 2
5562: PPUSH
5563: CALL_OW 67
// if Denis and GetSide ( Denis ) = 4 then
5567: LD_EXP 18
5571: PUSH
5572: LD_EXP 18
5576: PPUSH
5577: CALL_OW 255
5581: PUSH
5582: LD_INT 4
5584: EQUAL
5585: AND
5586: IFFALSE 5595
// Wait ( 0 0$45 ) ;
5588: LD_INT 1575
5590: PPUSH
5591: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) then
5595: LD_INT 22
5597: PUSH
5598: LD_INT 1
5600: PUSH
5601: EMPTY
5602: LIST
5603: LIST
5604: PUSH
5605: LD_INT 30
5607: PUSH
5608: LD_INT 4
5610: PUSH
5611: EMPTY
5612: LIST
5613: LIST
5614: PUSH
5615: EMPTY
5616: LIST
5617: LIST
5618: PPUSH
5619: CALL_OW 69
5623: IFFALSE 5640
// begin Wait ( 1 1$25 ) ;
5625: LD_INT 2975
5627: PPUSH
5628: CALL_OW 67
// more_troops := true ;
5632: LD_ADDR_VAR 0 3
5636: PUSH
5637: LD_INT 1
5639: ST_TO_ADDR
// end ; if more_troops then
5640: LD_VAR 0 3
5644: IFFALSE 5832
// begin force := PrepareArabianTroops ( [ 4 , 5 , 6 ] [ Difficulty ] , skill , arArea2 ) ;
5646: LD_ADDR_VAR 0 8
5650: PUSH
5651: LD_INT 4
5653: PUSH
5654: LD_INT 5
5656: PUSH
5657: LD_INT 6
5659: PUSH
5660: EMPTY
5661: LIST
5662: LIST
5663: LIST
5664: PUSH
5665: LD_OWVAR 67
5669: ARRAY
5670: PPUSH
5671: LD_VAR 0 4
5675: PPUSH
5676: LD_INT 14
5678: PPUSH
5679: CALL 5293 0 3
5683: ST_TO_ADDR
// veh := PrepareTank ( 2 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_heavy_machine_gun , ru_gatling_gun ] [ Difficulty ] , 90 ) ;
5684: LD_ADDR_VAR 0 7
5688: PUSH
5689: LD_INT 2
5691: PPUSH
5692: LD_INT 3
5694: PPUSH
5695: LD_INT 22
5697: PPUSH
5698: LD_INT 1
5700: PPUSH
5701: LD_INT 1
5703: PPUSH
5704: LD_INT 42
5706: PUSH
5707: LD_INT 42
5709: PUSH
5710: LD_INT 43
5712: PUSH
5713: EMPTY
5714: LIST
5715: LIST
5716: LIST
5717: PUSH
5718: LD_OWVAR 67
5722: ARRAY
5723: PPUSH
5724: LD_INT 90
5726: PPUSH
5727: CALL 359 0 7
5731: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5732: LD_VAR 0 7
5736: PPUSH
5737: LD_INT 4
5739: PPUSH
5740: CALL_OW 233
// PlaceUnitArea ( veh , arArea1 , false ) ;
5744: LD_VAR 0 7
5748: PPUSH
5749: LD_INT 13
5751: PPUSH
5752: LD_INT 0
5754: PPUSH
5755: CALL_OW 49
// uc_side := 2 ;
5759: LD_ADDR_OWVAR 20
5763: PUSH
5764: LD_INT 2
5766: ST_TO_ADDR
// uc_nation := 2 ;
5767: LD_ADDR_OWVAR 21
5771: PUSH
5772: LD_INT 2
5774: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
5775: LD_INT 0
5777: PPUSH
5778: LD_INT 1
5780: PPUSH
5781: LD_VAR 0 4
5785: PPUSH
5786: CALL_OW 380
// un := CreateHuman ;
5790: LD_ADDR_VAR 0 6
5794: PUSH
5795: CALL_OW 44
5799: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
5800: LD_VAR 0 6
5804: PPUSH
5805: LD_VAR 0 7
5809: PPUSH
5810: CALL_OW 52
// force := force ^ un ;
5814: LD_ADDR_VAR 0 8
5818: PUSH
5819: LD_VAR 0 8
5823: PUSH
5824: LD_VAR 0 6
5828: ADD
5829: ST_TO_ADDR
// end else
5830: GO 5870
// begin force := PrepareArabianTroops ( [ 3 , 4 , 5 ] [ Difficulty ] , skill , arArea2 ) ;
5832: LD_ADDR_VAR 0 8
5836: PUSH
5837: LD_INT 3
5839: PUSH
5840: LD_INT 4
5842: PUSH
5843: LD_INT 5
5845: PUSH
5846: EMPTY
5847: LIST
5848: LIST
5849: LIST
5850: PUSH
5851: LD_OWVAR 67
5855: ARRAY
5856: PPUSH
5857: LD_VAR 0 4
5861: PPUSH
5862: LD_INT 14
5864: PPUSH
5865: CALL 5293 0 3
5869: ST_TO_ADDR
// end ; if force then
5870: LD_VAR 0 8
5874: IFFALSE 5886
// ar_forces := force ;
5876: LD_ADDR_EXP 26
5880: PUSH
5881: LD_VAR 0 8
5885: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5886: LD_INT 35
5888: PPUSH
5889: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 ;
5893: LD_INT 22
5895: PUSH
5896: LD_INT 2
5898: PUSH
5899: EMPTY
5900: LIST
5901: LIST
5902: PUSH
5903: LD_INT 21
5905: PUSH
5906: LD_INT 1
5908: PUSH
5909: EMPTY
5910: LIST
5911: LIST
5912: PUSH
5913: EMPTY
5914: LIST
5915: LIST
5916: PPUSH
5917: CALL_OW 69
5921: PUSH
5922: LD_INT 0
5924: EQUAL
5925: IFFALSE 5886
// Wait ( timer ) ;
5927: LD_VAR 0 2
5931: PPUSH
5932: CALL_OW 67
// force := PrepareArabianTroops ( [ 5 , 6 , 6 ] [ Difficulty ] , skill , [ arArea1 , arArea2 ] [ rand ( 1 , 2 ) ] ) ;
5936: LD_ADDR_VAR 0 8
5940: PUSH
5941: LD_INT 5
5943: PUSH
5944: LD_INT 6
5946: PUSH
5947: LD_INT 6
5949: PUSH
5950: EMPTY
5951: LIST
5952: LIST
5953: LIST
5954: PUSH
5955: LD_OWVAR 67
5959: ARRAY
5960: PPUSH
5961: LD_VAR 0 4
5965: PPUSH
5966: LD_INT 13
5968: PUSH
5969: LD_INT 14
5971: PUSH
5972: EMPTY
5973: LIST
5974: LIST
5975: PUSH
5976: LD_INT 1
5978: PPUSH
5979: LD_INT 2
5981: PPUSH
5982: CALL_OW 12
5986: ARRAY
5987: PPUSH
5988: CALL 5293 0 3
5992: ST_TO_ADDR
// if Difficulty > 1 and Delta then
5993: LD_OWVAR 67
5997: PUSH
5998: LD_INT 1
6000: GREATER
6001: PUSH
6002: LD_EXP 6
6006: AND
6007: IFFALSE 6086
// begin uc_side := 2 ;
6009: LD_ADDR_OWVAR 20
6013: PUSH
6014: LD_INT 2
6016: ST_TO_ADDR
// uc_nation := 2 ;
6017: LD_ADDR_OWVAR 21
6021: PUSH
6022: LD_INT 2
6024: ST_TO_ADDR
// PrepareHuman ( false , 2 , skill ) ;
6025: LD_INT 0
6027: PPUSH
6028: LD_INT 2
6030: PPUSH
6031: LD_VAR 0 4
6035: PPUSH
6036: CALL_OW 380
// eng := CreateHuman ;
6040: LD_ADDR_VAR 0 5
6044: PUSH
6045: CALL_OW 44
6049: ST_TO_ADDR
// PlaceUnitArea ( eng , arArea1 , false ) ;
6050: LD_VAR 0 5
6054: PPUSH
6055: LD_INT 13
6057: PPUSH
6058: LD_INT 0
6060: PPUSH
6061: CALL_OW 49
// Wait ( 3 ) ;
6065: LD_INT 3
6067: PPUSH
6068: CALL_OW 67
// AddComEnterUnit ( eng , Delta ) ;
6072: LD_VAR 0 5
6076: PPUSH
6077: LD_EXP 6
6081: PPUSH
6082: CALL_OW 180
// end ; if force then
6086: LD_VAR 0 8
6090: IFFALSE 6102
// ar_forces := force ;
6092: LD_ADDR_EXP 26
6096: PUSH
6097: LD_VAR 0 8
6101: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
6102: LD_INT 35
6104: PPUSH
6105: CALL_OW 67
// if eng then
6109: LD_VAR 0 5
6113: IFFALSE 6167
// if GetSide ( Delta ) = 2 and IsOk ( eng ) and not IsInUnit ( eng ) then
6115: LD_EXP 6
6119: PPUSH
6120: CALL_OW 255
6124: PUSH
6125: LD_INT 2
6127: EQUAL
6128: PUSH
6129: LD_VAR 0 5
6133: PPUSH
6134: CALL_OW 302
6138: AND
6139: PUSH
6140: LD_VAR 0 5
6144: PPUSH
6145: CALL_OW 310
6149: NOT
6150: AND
6151: IFFALSE 6167
// ComEnterUnit ( eng , Delta ) ;
6153: LD_VAR 0 5
6157: PPUSH
6158: LD_EXP 6
6162: PPUSH
6163: CALL_OW 120
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 ;
6167: LD_INT 22
6169: PUSH
6170: LD_INT 2
6172: PUSH
6173: EMPTY
6174: LIST
6175: LIST
6176: PUSH
6177: LD_INT 21
6179: PUSH
6180: LD_INT 1
6182: PUSH
6183: EMPTY
6184: LIST
6185: LIST
6186: PUSH
6187: EMPTY
6188: LIST
6189: LIST
6190: PPUSH
6191: CALL_OW 69
6195: PUSH
6196: LD_INT 0
6198: EQUAL
6199: IFFALSE 6102
// Wait ( 2 2$00 ) ;
6201: LD_INT 4200
6203: PPUSH
6204: CALL_OW 67
// ap_killers := PrepareArabianTroops ( [ 1 , 2 , 2 ] [ Difficulty ] , skill , arArea1 ) ;
6208: LD_ADDR_EXP 27
6212: PUSH
6213: LD_INT 1
6215: PUSH
6216: LD_INT 2
6218: PUSH
6219: LD_INT 2
6221: PUSH
6222: EMPTY
6223: LIST
6224: LIST
6225: LIST
6226: PUSH
6227: LD_OWVAR 67
6231: ARRAY
6232: PPUSH
6233: LD_VAR 0 4
6237: PPUSH
6238: LD_INT 13
6240: PPUSH
6241: CALL 5293 0 3
6245: ST_TO_ADDR
// Wait ( timer * 2 ) ;
6246: LD_VAR 0 2
6250: PUSH
6251: LD_INT 2
6253: MUL
6254: PPUSH
6255: CALL_OW 67
// ar_forces := PrepareArabianTroops ( [ 5 , 6 , 7 ] [ Difficulty ] , skill , arArea1 ) ^ PrepareArabianTroops ( [ 3 , 4 , 4 ] [ Difficulty ] , skill , arArea2 ) ;
6259: LD_ADDR_EXP 26
6263: PUSH
6264: LD_INT 5
6266: PUSH
6267: LD_INT 6
6269: PUSH
6270: LD_INT 7
6272: PUSH
6273: EMPTY
6274: LIST
6275: LIST
6276: LIST
6277: PUSH
6278: LD_OWVAR 67
6282: ARRAY
6283: PPUSH
6284: LD_VAR 0 4
6288: PPUSH
6289: LD_INT 13
6291: PPUSH
6292: CALL 5293 0 3
6296: PUSH
6297: LD_INT 3
6299: PUSH
6300: LD_INT 4
6302: PUSH
6303: LD_INT 4
6305: PUSH
6306: EMPTY
6307: LIST
6308: LIST
6309: LIST
6310: PUSH
6311: LD_OWVAR 67
6315: ARRAY
6316: PPUSH
6317: LD_VAR 0 4
6321: PPUSH
6322: LD_INT 14
6324: PPUSH
6325: CALL 5293 0 3
6329: ADD
6330: ST_TO_ADDR
// end ;
6331: PPOPN 8
6333: END
// every 0 0$03 trigger ar_forces do var i , target ;
6334: LD_EXP 26
6338: IFFALSE 6536
6340: GO 6342
6342: DISABLE
6343: LD_INT 0
6345: PPUSH
6346: PPUSH
// begin enable ;
6347: ENABLE
// if not ar_forces then
6348: LD_EXP 26
6352: NOT
6353: IFFALSE 6357
// exit ;
6355: GO 6536
// if Delta then
6357: LD_EXP 6
6361: IFFALSE 6375
// target := Delta else
6363: LD_ADDR_VAR 0 2
6367: PUSH
6368: LD_EXP 6
6372: ST_TO_ADDR
6373: GO 6385
// target := JMM ;
6375: LD_ADDR_VAR 0 2
6379: PUSH
6380: LD_EXP 15
6384: ST_TO_ADDR
// for i in ar_forces do
6385: LD_ADDR_VAR 0 1
6389: PUSH
6390: LD_EXP 26
6394: PUSH
6395: FOR_IN
6396: IFFALSE 6534
// begin if i in FilterAllUnits ( [ f_driving ] ) then
6398: LD_VAR 0 1
6402: PUSH
6403: LD_INT 55
6405: PUSH
6406: EMPTY
6407: LIST
6408: PPUSH
6409: CALL_OW 69
6413: IN
6414: IFFALSE 6457
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , IsInUnit ( i ) ) ) else
6416: LD_VAR 0 1
6420: PPUSH
6421: LD_INT 22
6423: PUSH
6424: LD_INT 1
6426: PUSH
6427: EMPTY
6428: LIST
6429: LIST
6430: PPUSH
6431: CALL_OW 69
6435: PPUSH
6436: LD_VAR 0 1
6440: PPUSH
6441: CALL_OW 310
6445: PPUSH
6446: CALL_OW 74
6450: PPUSH
6451: CALL_OW 115
6455: GO 6532
// if GetDistUnits ( i , target ) > 30 then
6457: LD_VAR 0 1
6461: PPUSH
6462: LD_VAR 0 2
6466: PPUSH
6467: CALL_OW 296
6471: PUSH
6472: LD_INT 30
6474: GREATER
6475: IFFALSE 6508
// ComAgressiveMove ( i , GetX ( target ) , GetY ( target ) ) else
6477: LD_VAR 0 1
6481: PPUSH
6482: LD_VAR 0 2
6486: PPUSH
6487: CALL_OW 250
6491: PPUSH
6492: LD_VAR 0 2
6496: PPUSH
6497: CALL_OW 251
6501: PPUSH
6502: CALL_OW 114
6506: GO 6532
// Attack ( i , FilterAllUnits ( [ f_enemy , 2 ] ) ) ;
6508: LD_VAR 0 1
6512: PPUSH
6513: LD_INT 81
6515: PUSH
6516: LD_INT 2
6518: PUSH
6519: EMPTY
6520: LIST
6521: LIST
6522: PPUSH
6523: CALL_OW 69
6527: PPUSH
6528: CALL 664 0 2
// end ;
6532: GO 6395
6534: POP
6535: POP
// end ;
6536: PPOPN 2
6538: END
// every 0 0$01 trigger ap_killers do var filter , i , target ;
6539: LD_EXP 27
6543: IFFALSE 6703
6545: GO 6547
6547: DISABLE
6548: LD_INT 0
6550: PPUSH
6551: PPUSH
6552: PPUSH
// begin enable ;
6553: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) ;
6554: LD_ADDR_VAR 0 1
6558: PUSH
6559: LD_INT 22
6561: PUSH
6562: LD_INT 0
6564: PUSH
6565: EMPTY
6566: LIST
6567: LIST
6568: PUSH
6569: LD_INT 25
6571: PUSH
6572: LD_INT 12
6574: PUSH
6575: EMPTY
6576: LIST
6577: LIST
6578: PUSH
6579: EMPTY
6580: LIST
6581: LIST
6582: PPUSH
6583: CALL_OW 69
6587: ST_TO_ADDR
// if not filter then
6588: LD_VAR 0 1
6592: NOT
6593: IFFALSE 6620
// begin ar_forces := ar_forces ^ ap_killers ;
6595: LD_ADDR_EXP 26
6599: PUSH
6600: LD_EXP 26
6604: PUSH
6605: LD_EXP 27
6609: ADD
6610: ST_TO_ADDR
// ap_killers := [ ] ;
6611: LD_ADDR_EXP 27
6615: PUSH
6616: EMPTY
6617: ST_TO_ADDR
// exit ;
6618: GO 6703
// end ; for i in ap_killers do
6620: LD_ADDR_VAR 0 2
6624: PUSH
6625: LD_EXP 27
6629: PUSH
6630: FOR_IN
6631: IFFALSE 6701
// begin if not IsOk ( i ) then
6633: LD_VAR 0 2
6637: PPUSH
6638: CALL_OW 302
6642: NOT
6643: IFFALSE 6647
// continue ;
6645: GO 6630
// if not HasTask ( i ) then
6647: LD_VAR 0 2
6651: PPUSH
6652: CALL_OW 314
6656: NOT
6657: IFFALSE 6679
// target := NearestUnitToUnit ( filter , i ) ;
6659: LD_ADDR_VAR 0 3
6663: PUSH
6664: LD_VAR 0 1
6668: PPUSH
6669: LD_VAR 0 2
6673: PPUSH
6674: CALL_OW 74
6678: ST_TO_ADDR
// if target then
6679: LD_VAR 0 3
6683: IFFALSE 6699
// ComAttackUnit ( i , target ) ;
6685: LD_VAR 0 2
6689: PPUSH
6690: LD_VAR 0 3
6694: PPUSH
6695: CALL_OW 115
// end ;
6699: GO 6630
6701: POP
6702: POP
// end ; end_of_file
6703: PPOPN 3
6705: END
// every 0 0$40 + 0 0$2 trigger Delta do var i , counter , cr ;
6706: LD_EXP 6
6710: IFFALSE 6842
6712: GO 6714
6714: DISABLE
6715: LD_INT 0
6717: PPUSH
6718: PPUSH
6719: PPUSH
// begin counter := [ 300 , 250 , 220 ] [ Difficulty ] ;
6720: LD_ADDR_VAR 0 2
6724: PUSH
6725: LD_INT 300
6727: PUSH
6728: LD_INT 250
6730: PUSH
6731: LD_INT 220
6733: PUSH
6734: EMPTY
6735: LIST
6736: LIST
6737: LIST
6738: PUSH
6739: LD_OWVAR 67
6743: ARRAY
6744: ST_TO_ADDR
// CreateCratesArea ( Rand ( 1 , 3 ) , cratesArea , true ) ;
6745: LD_INT 1
6747: PPUSH
6748: LD_INT 3
6750: PPUSH
6751: CALL_OW 12
6755: PPUSH
6756: LD_INT 7
6758: PPUSH
6759: LD_INT 1
6761: PPUSH
6762: CALL_OW 55
// repeat wait ( rand ( 1 1$30 , 2 2$20 ) ) ;
6766: LD_INT 3150
6768: PPUSH
6769: LD_INT 4900
6771: PPUSH
6772: CALL_OW 12
6776: PPUSH
6777: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
6781: LD_ADDR_VAR 0 3
6785: PUSH
6786: LD_INT 1
6788: PPUSH
6789: LD_INT 5
6791: PPUSH
6792: CALL_OW 12
6796: ST_TO_ADDR
// CreateCratesArea ( cr , cratesArea , true ) ;
6797: LD_VAR 0 3
6801: PPUSH
6802: LD_INT 7
6804: PPUSH
6805: LD_INT 1
6807: PPUSH
6808: CALL_OW 55
// counter := counter - cr * 10 ;
6812: LD_ADDR_VAR 0 2
6816: PUSH
6817: LD_VAR 0 2
6821: PUSH
6822: LD_VAR 0 3
6826: PUSH
6827: LD_INT 10
6829: MUL
6830: MINUS
6831: ST_TO_ADDR
// until counter <= 0 ;
6832: LD_VAR 0 2
6836: PUSH
6837: LD_INT 0
6839: LESSEQUAL
6840: IFFALSE 6766
// end ;
6842: PPOPN 3
6844: END
// every 0 0$03 trigger not Delta do var i ;
6845: LD_EXP 6
6849: NOT
6850: IFFALSE 6920
6852: GO 6854
6854: DISABLE
6855: LD_INT 0
6857: PPUSH
// begin for i = 1 to 4 - Difficulty do
6858: LD_ADDR_VAR 0 1
6862: PUSH
6863: DOUBLE
6864: LD_INT 1
6866: DEC
6867: ST_TO_ADDR
6868: LD_INT 4
6870: PUSH
6871: LD_OWVAR 67
6875: MINUS
6876: PUSH
6877: FOR_TO
6878: IFFALSE 6918
// begin CreateCratesArea ( rand ( 2 , 5 ) , deltaMainArea , true ) ;
6880: LD_INT 2
6882: PPUSH
6883: LD_INT 5
6885: PPUSH
6886: CALL_OW 12
6890: PPUSH
6891: LD_INT 8
6893: PPUSH
6894: LD_INT 1
6896: PPUSH
6897: CALL_OW 55
// Wait ( rand ( 0 0$16 , 0 0$39 ) ) ;
6901: LD_INT 560
6903: PPUSH
6904: LD_INT 1365
6906: PPUSH
6907: CALL_OW 12
6911: PPUSH
6912: CALL_OW 67
// end ;
6916: GO 6877
6918: POP
6919: POP
// end ;
6920: PPOPN 1
6922: END
// every 3 3$00 trigger tick < 15 15$00 do
6923: LD_OWVAR 1
6927: PUSH
6928: LD_INT 31500
6930: LESS
6931: IFFALSE 6991
6933: GO 6935
6935: DISABLE
// begin enable ;
6936: ENABLE
// CreateCratesAnyWhere ( rand ( 1 , 3 ) , true ) ;
6937: LD_INT 1
6939: PPUSH
6940: LD_INT 3
6942: PPUSH
6943: CALL_OW 12
6947: PPUSH
6948: LD_INT 1
6950: PPUSH
6951: CALL_OW 57
// Wait ( rand ( 0 0$38 , 0 0$59 ) ) ;
6955: LD_INT 1330
6957: PPUSH
6958: LD_INT 2065
6960: PPUSH
6961: CALL_OW 12
6965: PPUSH
6966: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 4 ) , riverArea , true ) ;
6970: LD_INT 1
6972: PPUSH
6973: LD_INT 4
6975: PPUSH
6976: CALL_OW 12
6980: PPUSH
6981: LD_INT 15
6983: PPUSH
6984: LD_INT 1
6986: PPUSH
6987: CALL_OW 55
// end ; end_of_file
6991: END
// on UnitDestroyed ( un ) do begin if un = JMM then
6992: LD_VAR 0 1
6996: PUSH
6997: LD_EXP 15
7001: EQUAL
7002: IFFALSE 7011
// YouLost ( JMM ) ;
7004: LD_STRING JMM
7006: PPUSH
7007: CALL_OW 104
// if un = Delta then
7011: LD_VAR 0 1
7015: PUSH
7016: LD_EXP 6
7020: EQUAL
7021: IFFALSE 7044
// begin Delta := 0 ;
7023: LD_ADDR_EXP 6
7027: PUSH
7028: LD_INT 0
7030: ST_TO_ADDR
// SetRestrict ( b_depot , 1 , true ) ;
7031: LD_INT 0
7033: PPUSH
7034: LD_INT 1
7036: PPUSH
7037: LD_INT 1
7039: PPUSH
7040: CALL_OW 324
// end ; if un in ar_forces then
7044: LD_VAR 0 1
7048: PUSH
7049: LD_EXP 26
7053: IN
7054: IFFALSE 7072
// ar_forces := ar_forces diff un ;
7056: LD_ADDR_EXP 26
7060: PUSH
7061: LD_EXP 26
7065: PUSH
7066: LD_VAR 0 1
7070: DIFF
7071: ST_TO_ADDR
// if un in ap_killers then
7072: LD_VAR 0 1
7076: PUSH
7077: LD_EXP 27
7081: IN
7082: IFFALSE 7100
// ap_killers := ap_killers diff un ;
7084: LD_ADDR_EXP 27
7088: PUSH
7089: LD_EXP 27
7093: PUSH
7094: LD_VAR 0 1
7098: DIFF
7099: ST_TO_ADDR
// end ;
7100: PPOPN 1
7102: END
// on Contact ( s1 , s2 ) do if s1 = 1 and s2 = 2 and not arab_spotted then
7103: LD_VAR 0 1
7107: PUSH
7108: LD_INT 1
7110: EQUAL
7111: PUSH
7112: LD_VAR 0 2
7116: PUSH
7117: LD_INT 2
7119: EQUAL
7120: AND
7121: PUSH
7122: LD_EXP 13
7126: NOT
7127: AND
7128: IFFALSE 7138
// arab_spotted := true ;
7130: LD_ADDR_EXP 13
7134: PUSH
7135: LD_INT 1
7137: ST_TO_ADDR
7138: PPOPN 2
7140: END
// on EndTheMissionRaised ( p ) do begin end_the_mission_allowed := false ;
7141: LD_ADDR_OWVAR 57
7145: PUSH
7146: LD_INT 0
7148: ST_TO_ADDR
// end_mission := true ;
7149: LD_ADDR_EXP 14
7153: PUSH
7154: LD_INT 1
7156: ST_TO_ADDR
// end ;
7157: PPOPN 1
7159: END
// on ApemanTamed ( apeman , sci ) do begin if GetSide ( sci ) = 1 then
7160: LD_VAR 0 2
7164: PPUSH
7165: CALL_OW 255
7169: PUSH
7170: LD_INT 1
7172: EQUAL
7173: IFFALSE 7189
// apeman_counter := apeman_counter + 1 ;
7175: LD_ADDR_EXP 12
7179: PUSH
7180: LD_EXP 12
7184: PUSH
7185: LD_INT 1
7187: PLUS
7188: ST_TO_ADDR
// if not first_apeman_tamed then
7189: LD_EXP 8
7193: NOT
7194: IFFALSE 7394
// begin first_apeman_tamed := true ;
7196: LD_ADDR_EXP 8
7200: PUSH
7201: LD_INT 1
7203: ST_TO_ADDR
// if sci = Gladstone then
7204: LD_VAR 0 2
7208: PUSH
7209: LD_EXP 16
7213: EQUAL
7214: IFFALSE 7228
// Say ( Gladstone , D7b-Glad-1 ) ;
7216: LD_EXP 16
7220: PPUSH
7221: LD_STRING D7b-Glad-1
7223: PPUSH
7224: CALL_OW 88
// if sci = Denis then
7228: LD_VAR 0 2
7232: PUSH
7233: LD_EXP 18
7237: EQUAL
7238: IFFALSE 7252
// Say ( Denis , D7a-Den-1 ) ;
7240: LD_EXP 18
7244: PPUSH
7245: LD_STRING D7a-Den-1
7247: PPUSH
7248: CALL_OW 88
// if not sci in [ JMM , Gladstone , Denis , Lisa , Frank , Bobby , Cyrus , Donaldson ] then
7252: LD_VAR 0 2
7256: PUSH
7257: LD_EXP 15
7261: PUSH
7262: LD_EXP 16
7266: PUSH
7267: LD_EXP 18
7271: PUSH
7272: LD_EXP 21
7276: PUSH
7277: LD_EXP 22
7281: PUSH
7282: LD_EXP 23
7286: PUSH
7287: LD_EXP 24
7291: PUSH
7292: LD_EXP 20
7296: PUSH
7297: EMPTY
7298: LIST
7299: LIST
7300: LIST
7301: LIST
7302: LIST
7303: LIST
7304: LIST
7305: LIST
7306: IN
7307: NOT
7308: IFFALSE 7351
// begin if GetSex ( sci ) = sex_male then
7310: LD_VAR 0 2
7314: PPUSH
7315: CALL_OW 258
7319: PUSH
7320: LD_INT 1
7322: EQUAL
7323: IFFALSE 7339
// Say ( sci , D7c-Sci1-1 ) else
7325: LD_VAR 0 2
7329: PPUSH
7330: LD_STRING D7c-Sci1-1
7332: PPUSH
7333: CALL_OW 88
7337: GO 7351
// Say ( sci , D7c-FSci1-1 ) ;
7339: LD_VAR 0 2
7343: PPUSH
7344: LD_STRING D7c-FSci1-1
7346: PPUSH
7347: CALL_OW 88
// end ; if not sci = Gladstone then
7351: LD_VAR 0 2
7355: PUSH
7356: LD_EXP 16
7360: EQUAL
7361: NOT
7362: IFFALSE 7376
// Say ( Gladstone , D7c-Glad-1 ) ;
7364: LD_EXP 16
7368: PPUSH
7369: LD_STRING D7c-Glad-1
7371: PPUSH
7372: CALL_OW 88
// if Lisa then
7376: LD_EXP 21
7380: IFFALSE 7394
// Say ( Lisa , D8-Lisa-1 ) ;
7382: LD_EXP 21
7386: PPUSH
7387: LD_STRING D8-Lisa-1
7389: PPUSH
7390: CALL_OW 88
// end ; end ;
7394: PPOPN 2
7396: END
