// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// Init ;
  15: CALL 79 0 0
// InitRestrictions ;
  19: CALL 199 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 33
// DebugMode ;
  29: CALL 280 0 0
// SpawnApeman ( apemanStartArea , 2 ) ;
  33: LD_INT 12
  35: PPUSH
  36: LD_INT 2
  38: PPUSH
  39: CALL 534 0 2
// SpawnApeman ( apemanArea , [ 10 , 8 , 6 ] [ Difficulty ] ) ;
  43: LD_INT 11
  45: PPUSH
  46: LD_INT 10
  48: PUSH
  49: LD_INT 8
  51: PUSH
  52: LD_INT 6
  54: PUSH
  55: EMPTY
  56: LIST
  57: LIST
  58: LIST
  59: PUSH
  60: LD_OWVAR 67
  64: ARRAY
  65: PPUSH
  66: CALL 534 0 2
// PrepareAmericans ;
  70: CALL 1133 0 0
// Action ;
  74: CALL 2023 0 0
// end ;
  78: END
// export debug ; export mission_prefix , mission_prefix_prev ; export deltaBuilded , denisArrives , Delta , radar_allowed , first_apeman_tamed , apeman_army , radar_researched , radar_builded ; export apeman_counter , arab_spotted , end_mission ; function Init ; begin
  79: LD_INT 0
  81: PPUSH
// debug := false ;
  82: LD_ADDR_EXP 1
  86: PUSH
  87: LD_INT 0
  89: ST_TO_ADDR
// mission_prefix := 05_ ;
  90: LD_ADDR_EXP 2
  94: PUSH
  95: LD_STRING 05_
  97: ST_TO_ADDR
// mission_prefix_prev := 05a_ ;
  98: LD_ADDR_EXP 3
 102: PUSH
 103: LD_STRING 05a_
 105: ST_TO_ADDR
// deltaBuilded := false ;
 106: LD_ADDR_EXP 4
 110: PUSH
 111: LD_INT 0
 113: ST_TO_ADDR
// denisArrives := false ;
 114: LD_ADDR_EXP 5
 118: PUSH
 119: LD_INT 0
 121: ST_TO_ADDR
// radar_allowed := false ;
 122: LD_ADDR_EXP 7
 126: PUSH
 127: LD_INT 0
 129: ST_TO_ADDR
// first_apeman_tamed := false ;
 130: LD_ADDR_EXP 8
 134: PUSH
 135: LD_INT 0
 137: ST_TO_ADDR
// arab_spotted := false ;
 138: LD_ADDR_EXP 13
 142: PUSH
 143: LD_INT 0
 145: ST_TO_ADDR
// end_mission := false ;
 146: LD_ADDR_EXP 14
 150: PUSH
 151: LD_INT 0
 153: ST_TO_ADDR
// apeman_army := false ;
 154: LD_ADDR_EXP 9
 158: PUSH
 159: LD_INT 0
 161: ST_TO_ADDR
// radar_researched := false ;
 162: LD_ADDR_EXP 10
 166: PUSH
 167: LD_INT 0
 169: ST_TO_ADDR
// radar_builded := false ;
 170: LD_ADDR_EXP 11
 174: PUSH
 175: LD_INT 0
 177: ST_TO_ADDR
// apeman_counter := 0 ;
 178: LD_ADDR_EXP 12
 182: PUSH
 183: LD_INT 0
 185: ST_TO_ADDR
// Delta := 0 ;
 186: LD_ADDR_EXP 6
 190: PUSH
 191: LD_INT 0
 193: ST_TO_ADDR
// end ;
 194: LD_VAR 0 1
 198: RET
// function InitRestrictions ; begin
 199: LD_INT 0
 201: PPUSH
// SetRestrict ( b_lab_half , 1 , state_enabled ) ;
 202: LD_INT 7
 204: PPUSH
 205: LD_INT 1
 207: PPUSH
 208: LD_INT 1
 210: PPUSH
 211: CALL_OW 324
// SetRestrict ( b_lab_full , 1 , state_enabled ) ;
 215: LD_INT 8
 217: PPUSH
 218: LD_INT 1
 220: PPUSH
 221: LD_INT 1
 223: PPUSH
 224: CALL_OW 324
// SetRestrict ( b_lab_weapon , 1 , state_enabled ) ;
 228: LD_INT 10
 230: PPUSH
 231: LD_INT 1
 233: PPUSH
 234: LD_INT 1
 236: PPUSH
 237: CALL_OW 324
// SetTech ( tech_gatling , 1 , LoadVariable ( GatlingInGamma , 1 ) ) ;
 241: LD_INT 69
 243: PPUSH
 244: LD_INT 1
 246: PPUSH
 247: LD_STRING GatlingInGamma
 249: PPUSH
 250: LD_INT 1
 252: PPUSH
 253: CALL_OW 30
 257: PPUSH
 258: CALL_OW 322
// SetTech ( tech_weap1 , 1 , state_enabled ) ;
 262: LD_INT 51
 264: PPUSH
 265: LD_INT 1
 267: PPUSH
 268: LD_INT 1
 270: PPUSH
 271: CALL_OW 322
// end ;
 275: LD_VAR 0 1
 279: RET
// function DebugMode ; begin
 280: LD_INT 0
 282: PPUSH
// FogOff ( 1 ) ;
 283: LD_INT 1
 285: PPUSH
 286: CALL_OW 344
// Difficulty := 2 ;
 290: LD_ADDR_OWVAR 67
 294: PUSH
 295: LD_INT 2
 297: ST_TO_ADDR
// end ; end_of_file
 298: LD_VAR 0 1
 302: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 303: LD_INT 0
 305: PPUSH
 306: PPUSH
// if exist_mode then
 307: LD_VAR 0 2
 311: IFFALSE 336
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 313: LD_ADDR_VAR 0 4
 317: PUSH
 318: LD_EXP 3
 322: PUSH
 323: LD_VAR 0 1
 327: STR
 328: PPUSH
 329: CALL_OW 34
 333: ST_TO_ADDR
 334: GO 351
// unit := NewCharacter ( ident ) ;
 336: LD_ADDR_VAR 0 4
 340: PUSH
 341: LD_VAR 0 1
 345: PPUSH
 346: CALL_OW 25
 350: ST_TO_ADDR
// result := unit ;
 351: LD_ADDR_VAR 0 3
 355: PUSH
 356: LD_VAR 0 4
 360: ST_TO_ADDR
// end ;
 361: LD_VAR 0 3
 365: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 366: LD_INT 0
 368: PPUSH
// uc_side := side ;
 369: LD_ADDR_OWVAR 20
 373: PUSH
 374: LD_VAR 0 1
 378: ST_TO_ADDR
// uc_nation := nation ;
 379: LD_ADDR_OWVAR 21
 383: PUSH
 384: LD_VAR 0 2
 388: ST_TO_ADDR
// vc_chassis := chassis ;
 389: LD_ADDR_OWVAR 37
 393: PUSH
 394: LD_VAR 0 3
 398: ST_TO_ADDR
// vc_engine := engine ;
 399: LD_ADDR_OWVAR 39
 403: PUSH
 404: LD_VAR 0 4
 408: ST_TO_ADDR
// vc_control := control ;
 409: LD_ADDR_OWVAR 38
 413: PUSH
 414: LD_VAR 0 5
 418: ST_TO_ADDR
// vc_weapon := weapon ;
 419: LD_ADDR_OWVAR 40
 423: PUSH
 424: LD_VAR 0 6
 428: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 429: LD_ADDR_OWVAR 41
 433: PUSH
 434: LD_VAR 0 7
 438: ST_TO_ADDR
// result := CreateVehicle ;
 439: LD_ADDR_VAR 0 8
 443: PUSH
 444: CALL_OW 45
 448: ST_TO_ADDR
// end ;
 449: LD_VAR 0 8
 453: RET
// export function SayX ( units , ident ) ; var i ; begin
 454: LD_INT 0
 456: PPUSH
 457: PPUSH
// result := false ;
 458: LD_ADDR_VAR 0 3
 462: PUSH
 463: LD_INT 0
 465: ST_TO_ADDR
// if not units then
 466: LD_VAR 0 1
 470: NOT
 471: IFFALSE 475
// exit ;
 473: GO 529
// for i in units do
 475: LD_ADDR_VAR 0 4
 479: PUSH
 480: LD_VAR 0 1
 484: PUSH
 485: FOR_IN
 486: IFFALSE 527
// if IsOk ( i ) then
 488: LD_VAR 0 4
 492: PPUSH
 493: CALL_OW 302
 497: IFFALSE 525
// begin Say ( i , ident ) ;
 499: LD_VAR 0 4
 503: PPUSH
 504: LD_VAR 0 2
 508: PPUSH
 509: CALL_OW 88
// result := i ;
 513: LD_ADDR_VAR 0 3
 517: PUSH
 518: LD_VAR 0 4
 522: ST_TO_ADDR
// break ;
 523: GO 527
// end ;
 525: GO 485
 527: POP
 528: POP
// end ;
 529: LD_VAR 0 3
 533: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 534: LD_INT 0
 536: PPUSH
 537: PPUSH
// InitUc ;
 538: CALL_OW 18
// InitHc ;
 542: CALL_OW 19
// uc_side := 0 ;
 546: LD_ADDR_OWVAR 20
 550: PUSH
 551: LD_INT 0
 553: ST_TO_ADDR
// uc_nation := 0 ;
 554: LD_ADDR_OWVAR 21
 558: PUSH
 559: LD_INT 0
 561: ST_TO_ADDR
// for i = 1 to amount do
 562: LD_ADDR_VAR 0 4
 566: PUSH
 567: DOUBLE
 568: LD_INT 1
 570: DEC
 571: ST_TO_ADDR
 572: LD_VAR 0 2
 576: PUSH
 577: FOR_TO
 578: IFFALSE 660
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 580: LD_ADDR_OWVAR 29
 584: PUSH
 585: LD_INT 9
 587: PPUSH
 588: LD_INT 12
 590: PPUSH
 591: CALL_OW 12
 595: PUSH
 596: LD_INT 9
 598: PPUSH
 599: LD_INT 12
 601: PPUSH
 602: CALL_OW 12
 606: PUSH
 607: EMPTY
 608: LIST
 609: LIST
 610: ST_TO_ADDR
// hc_agressivity := rand ( - 5 , 5 ) ;
 611: LD_ADDR_OWVAR 35
 615: PUSH
 616: LD_INT 5
 618: NEG
 619: PPUSH
 620: LD_INT 5
 622: PPUSH
 623: CALL_OW 12
 627: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 628: LD_INT 0
 630: PPUSH
 631: LD_INT 12
 633: PPUSH
 634: LD_INT 1
 636: PPUSH
 637: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 641: CALL_OW 44
 645: PPUSH
 646: LD_VAR 0 1
 650: PPUSH
 651: LD_INT 0
 653: PPUSH
 654: CALL_OW 49
// end ;
 658: GO 577
 660: POP
 661: POP
// InitHc ;
 662: CALL_OW 19
// end ;
 666: LD_VAR 0 3
 670: RET
// export function Attack ( unit , enemy_list ) ; var target , targets_list ; begin
 671: LD_INT 0
 673: PPUSH
 674: PPUSH
 675: PPUSH
// if not unit then
 676: LD_VAR 0 1
 680: NOT
 681: IFFALSE 685
// exit ;
 683: GO 1128
// if IsInUnit ( unit ) then
 685: LD_VAR 0 1
 689: PPUSH
 690: CALL_OW 310
 694: IFFALSE 711
// unit := IsDrivenBy ( unit ) ;
 696: LD_ADDR_VAR 0 1
 700: PUSH
 701: LD_VAR 0 1
 705: PPUSH
 706: CALL_OW 311
 710: ST_TO_ADDR
// targets_list := [ ] ;
 711: LD_ADDR_VAR 0 5
 715: PUSH
 716: EMPTY
 717: ST_TO_ADDR
// target := UnitFilter ( enemy_list , [ [ f_lives , 250 ] , [ f_not , [ f_weapon , us_cargo_bay ] ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
 718: LD_ADDR_VAR 0 4
 722: PUSH
 723: LD_VAR 0 2
 727: PPUSH
 728: LD_INT 24
 730: PUSH
 731: LD_INT 250
 733: PUSH
 734: EMPTY
 735: LIST
 736: LIST
 737: PUSH
 738: LD_INT 3
 740: PUSH
 741: LD_INT 34
 743: PUSH
 744: LD_INT 12
 746: PUSH
 747: EMPTY
 748: LIST
 749: LIST
 750: PUSH
 751: EMPTY
 752: LIST
 753: LIST
 754: PUSH
 755: LD_INT 21
 757: PUSH
 758: LD_INT 2
 760: PUSH
 761: EMPTY
 762: LIST
 763: LIST
 764: PUSH
 765: LD_INT 58
 767: PUSH
 768: EMPTY
 769: LIST
 770: PUSH
 771: EMPTY
 772: LIST
 773: LIST
 774: LIST
 775: LIST
 776: PPUSH
 777: CALL_OW 72
 781: ST_TO_ADDR
// if GetDistUnits ( NearestUnitToUnit ( target , unit ) , unit ) < 11 and not IsInUnit ( unit ) then
 782: LD_VAR 0 4
 786: PPUSH
 787: LD_VAR 0 1
 791: PPUSH
 792: CALL_OW 74
 796: PPUSH
 797: LD_VAR 0 1
 801: PPUSH
 802: CALL_OW 296
 806: PUSH
 807: LD_INT 11
 809: LESS
 810: PUSH
 811: LD_VAR 0 1
 815: PPUSH
 816: CALL_OW 310
 820: NOT
 821: AND
 822: IFFALSE 850
// begin ComEnterUnit ( unit , NearestUnitToUnit ( target , unit ) ) ;
 824: LD_VAR 0 1
 828: PPUSH
 829: LD_VAR 0 4
 833: PPUSH
 834: LD_VAR 0 1
 838: PPUSH
 839: CALL_OW 74
 843: PPUSH
 844: CALL_OW 120
// exit ;
 848: GO 1128
// end ; targets_list := [ UnitFilter ( enemy_list , [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] ] ) , UnitFilter ( enemy_list , [ f_type , unit_vehicle ] ) , UnitFilter ( enemy_list , [ [ f_type , unit_building ] , [ f_not , [ f_empty ] ] ] ) , enemy_list ] ;
 850: LD_ADDR_VAR 0 5
 854: PUSH
 855: LD_VAR 0 2
 859: PPUSH
 860: LD_INT 21
 862: PUSH
 863: LD_INT 1
 865: PUSH
 866: EMPTY
 867: LIST
 868: LIST
 869: PUSH
 870: LD_INT 3
 872: PUSH
 873: LD_INT 54
 875: PUSH
 876: EMPTY
 877: LIST
 878: PUSH
 879: EMPTY
 880: LIST
 881: LIST
 882: PUSH
 883: EMPTY
 884: LIST
 885: LIST
 886: PPUSH
 887: CALL_OW 72
 891: PUSH
 892: LD_VAR 0 2
 896: PPUSH
 897: LD_INT 21
 899: PUSH
 900: LD_INT 2
 902: PUSH
 903: EMPTY
 904: LIST
 905: LIST
 906: PPUSH
 907: CALL_OW 72
 911: PUSH
 912: LD_VAR 0 2
 916: PPUSH
 917: LD_INT 21
 919: PUSH
 920: LD_INT 3
 922: PUSH
 923: EMPTY
 924: LIST
 925: LIST
 926: PUSH
 927: LD_INT 3
 929: PUSH
 930: LD_INT 58
 932: PUSH
 933: EMPTY
 934: LIST
 935: PUSH
 936: EMPTY
 937: LIST
 938: LIST
 939: PUSH
 940: EMPTY
 941: LIST
 942: LIST
 943: PPUSH
 944: CALL_OW 72
 948: PUSH
 949: LD_VAR 0 2
 953: PUSH
 954: EMPTY
 955: LIST
 956: LIST
 957: LIST
 958: LIST
 959: ST_TO_ADDR
// for target in targets_list do
 960: LD_ADDR_VAR 0 4
 964: PUSH
 965: LD_VAR 0 5
 969: PUSH
 970: FOR_IN
 971: IFFALSE 1126
// begin if target then
 973: LD_VAR 0 4
 977: IFFALSE 1124
// if GetTag ( unit ) = 11 and ( GetType ( NearestUnitToUnit ( target , unit ) ) = unit_building or GetWeapon ( NearestUnitToUnit ( target , unit ) ) = us_cargo_bay ) then
 979: LD_VAR 0 1
 983: PPUSH
 984: CALL_OW 110
 988: PUSH
 989: LD_INT 11
 991: EQUAL
 992: PUSH
 993: LD_VAR 0 4
 997: PPUSH
 998: LD_VAR 0 1
1002: PPUSH
1003: CALL_OW 74
1007: PPUSH
1008: CALL_OW 247
1012: PUSH
1013: LD_INT 3
1015: EQUAL
1016: PUSH
1017: LD_VAR 0 4
1021: PPUSH
1022: LD_VAR 0 1
1026: PPUSH
1027: CALL_OW 74
1031: PPUSH
1032: CALL_OW 264
1036: PUSH
1037: LD_INT 12
1039: EQUAL
1040: OR
1041: AND
1042: IFFALSE 1088
// begin ComPlaceDelayedCharge ( unit , 0 , 0 , NearestUnitToUnit ( target , unit ) ) ;
1044: LD_VAR 0 1
1048: PPUSH
1049: LD_INT 0
1051: PPUSH
1052: LD_INT 0
1054: PPUSH
1055: LD_VAR 0 4
1059: PPUSH
1060: LD_VAR 0 1
1064: PPUSH
1065: CALL_OW 74
1069: PPUSH
1070: CALL_OW 132
// SetTag ( unit , 0 ) ;
1074: LD_VAR 0 1
1078: PPUSH
1079: LD_INT 0
1081: PPUSH
1082: CALL_OW 109
// end else
1086: GO 1124
// if not HasTask ( unit ) then
1088: LD_VAR 0 1
1092: PPUSH
1093: CALL_OW 314
1097: NOT
1098: IFFALSE 1124
// ComAttackUnit ( unit , NearestUnitToUnit ( target , unit ) ) ;
1100: LD_VAR 0 1
1104: PPUSH
1105: LD_VAR 0 4
1109: PPUSH
1110: LD_VAR 0 1
1114: PPUSH
1115: CALL_OW 74
1119: PPUSH
1120: CALL_OW 115
// end ;
1124: GO 970
1126: POP
1127: POP
// end ; end_of_file
1128: LD_VAR 0 3
1132: RET
// export JMM , Gladstone , Harrison , Denis , Brown , Donaldson , Lisa , Frank , Bobby , Cyrus ; export others ; export function PrepareAmericans ; var i , points , veh , tmp ; begin
1133: LD_INT 0
1135: PPUSH
1136: PPUSH
1137: PPUSH
1138: PPUSH
1139: PPUSH
// uc_nation := 1 ;
1140: LD_ADDR_OWVAR 21
1144: PUSH
1145: LD_INT 1
1147: ST_TO_ADDR
// uc_side := 4 ;
1148: LD_ADDR_OWVAR 20
1152: PUSH
1153: LD_INT 4
1155: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , false ) ;
1156: LD_ADDR_EXP 18
1160: PUSH
1161: LD_STRING Denis
1163: PPUSH
1164: LD_INT 0
1166: PPUSH
1167: CALL 303 0 2
1171: ST_TO_ADDR
// Harrison := PrepareUnit ( Harisson , false ) ;
1172: LD_ADDR_EXP 17
1176: PUSH
1177: LD_STRING Harisson
1179: PPUSH
1180: LD_INT 0
1182: PPUSH
1183: CALL 303 0 2
1187: ST_TO_ADDR
// uc_side := 1 ;
1188: LD_ADDR_OWVAR 20
1192: PUSH
1193: LD_INT 1
1195: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1196: LD_ADDR_EXP 15
1200: PUSH
1201: LD_STRING JMM
1203: PPUSH
1204: LD_EXP 1
1208: NOT
1209: PPUSH
1210: CALL 303 0 2
1214: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , false ) ;
1215: LD_ADDR_EXP 16
1219: PUSH
1220: LD_STRING Gladstone
1222: PPUSH
1223: LD_INT 0
1225: PPUSH
1226: CALL 303 0 2
1230: ST_TO_ADDR
// if LoadVariable ( BrownInDelta , debug ) then
1231: LD_STRING BrownInDelta
1233: PPUSH
1234: LD_EXP 1
1238: PPUSH
1239: CALL_OW 30
1243: IFFALSE 1280
// begin Brown := PrepareUnit ( Brown , ( not debug ) ) ;
1245: LD_ADDR_EXP 19
1249: PUSH
1250: LD_STRING Brown
1252: PPUSH
1253: LD_EXP 1
1257: NOT
1258: PPUSH
1259: CALL 303 0 2
1263: ST_TO_ADDR
// tmp := tmp ^ Brown ;
1264: LD_ADDR_VAR 0 5
1268: PUSH
1269: LD_VAR 0 5
1273: PUSH
1274: LD_EXP 19
1278: ADD
1279: ST_TO_ADDR
// end ; if LoadVariable ( DonaldsonInDelta , debug ) then
1280: LD_STRING DonaldsonInDelta
1282: PPUSH
1283: LD_EXP 1
1287: PPUSH
1288: CALL_OW 30
1292: IFFALSE 1329
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
1294: LD_ADDR_EXP 20
1298: PUSH
1299: LD_STRING Donaldson
1301: PPUSH
1302: LD_EXP 1
1306: NOT
1307: PPUSH
1308: CALL 303 0 2
1312: ST_TO_ADDR
// tmp := tmp ^ Donaldson ;
1313: LD_ADDR_VAR 0 5
1317: PUSH
1318: LD_VAR 0 5
1322: PUSH
1323: LD_EXP 20
1327: ADD
1328: ST_TO_ADDR
// end ; if LoadVariable ( LisaInDelta , debug ) then
1329: LD_STRING LisaInDelta
1331: PPUSH
1332: LD_EXP 1
1336: PPUSH
1337: CALL_OW 30
1341: IFFALSE 1378
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1343: LD_ADDR_EXP 21
1347: PUSH
1348: LD_STRING Lisa
1350: PPUSH
1351: LD_EXP 1
1355: NOT
1356: PPUSH
1357: CALL 303 0 2
1361: ST_TO_ADDR
// tmp := tmp ^ Lisa ;
1362: LD_ADDR_VAR 0 5
1366: PUSH
1367: LD_VAR 0 5
1371: PUSH
1372: LD_EXP 21
1376: ADD
1377: ST_TO_ADDR
// end ; if LoadVariable ( FrankInDelta , debug ) then
1378: LD_STRING FrankInDelta
1380: PPUSH
1381: LD_EXP 1
1385: PPUSH
1386: CALL_OW 30
1390: IFFALSE 1427
// begin Frank := PrepareUnit ( Frank , ( not debug ) ) ;
1392: LD_ADDR_EXP 22
1396: PUSH
1397: LD_STRING Frank
1399: PPUSH
1400: LD_EXP 1
1404: NOT
1405: PPUSH
1406: CALL 303 0 2
1410: ST_TO_ADDR
// tmp := tmp ^ Frank ;
1411: LD_ADDR_VAR 0 5
1415: PUSH
1416: LD_VAR 0 5
1420: PUSH
1421: LD_EXP 22
1425: ADD
1426: ST_TO_ADDR
// end ; if LoadVariable ( BobbyInDelta , 0 ) then
1427: LD_STRING BobbyInDelta
1429: PPUSH
1430: LD_INT 0
1432: PPUSH
1433: CALL_OW 30
1437: IFFALSE 1474
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1439: LD_ADDR_EXP 23
1443: PUSH
1444: LD_STRING Bobby
1446: PPUSH
1447: LD_EXP 1
1451: NOT
1452: PPUSH
1453: CALL 303 0 2
1457: ST_TO_ADDR
// tmp := tmp ^ Bobby ;
1458: LD_ADDR_VAR 0 5
1462: PUSH
1463: LD_VAR 0 5
1467: PUSH
1468: LD_EXP 23
1472: ADD
1473: ST_TO_ADDR
// end ; if LoadVariable ( CyrusInDelta , 0 ) then
1474: LD_STRING CyrusInDelta
1476: PPUSH
1477: LD_INT 0
1479: PPUSH
1480: CALL_OW 30
1484: IFFALSE 1521
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1486: LD_ADDR_EXP 24
1490: PUSH
1491: LD_STRING Cyrus
1493: PPUSH
1494: LD_EXP 1
1498: NOT
1499: PPUSH
1500: CALL 303 0 2
1504: ST_TO_ADDR
// tmp := tmp ^ Cyrus ;
1505: LD_ADDR_VAR 0 5
1509: PUSH
1510: LD_VAR 0 5
1514: PUSH
1515: LD_EXP 24
1519: ADD
1520: ST_TO_ADDR
// end ; others := CreateCharacterSet ( othersDelta ) ;
1521: LD_ADDR_EXP 25
1525: PUSH
1526: LD_STRING othersDelta
1528: PPUSH
1529: CALL_OW 31
1533: ST_TO_ADDR
// if not others and debug then
1534: LD_EXP 25
1538: NOT
1539: PUSH
1540: LD_EXP 1
1544: AND
1545: IFFALSE 1610
// begin InitHc ;
1547: CALL_OW 19
// for i = 1 to 2 do
1551: LD_ADDR_VAR 0 2
1555: PUSH
1556: DOUBLE
1557: LD_INT 1
1559: DEC
1560: ST_TO_ADDR
1561: LD_INT 2
1563: PUSH
1564: FOR_TO
1565: IFFALSE 1608
// begin PrepareHuman ( false , i mod 4 + 1 , 3 ) ;
1567: LD_INT 0
1569: PPUSH
1570: LD_VAR 0 2
1574: PUSH
1575: LD_INT 4
1577: MOD
1578: PUSH
1579: LD_INT 1
1581: PLUS
1582: PPUSH
1583: LD_INT 3
1585: PPUSH
1586: CALL_OW 380
// others := others ^ CreateHuman ;
1590: LD_ADDR_EXP 25
1594: PUSH
1595: LD_EXP 25
1599: PUSH
1600: CALL_OW 44
1604: ADD
1605: ST_TO_ADDR
// end ;
1606: GO 1564
1608: POP
1609: POP
// end ; if others then
1610: LD_EXP 25
1614: IFFALSE 1632
// tmp := tmp ^ others ;
1616: LD_ADDR_VAR 0 5
1620: PUSH
1621: LD_VAR 0 5
1625: PUSH
1626: LD_EXP 25
1630: ADD
1631: ST_TO_ADDR
// points := [ [ 28 , 49 ] , [ 33 , 54 ] , [ 38 , 56 ] ] ;
1632: LD_ADDR_VAR 0 3
1636: PUSH
1637: LD_INT 28
1639: PUSH
1640: LD_INT 49
1642: PUSH
1643: EMPTY
1644: LIST
1645: LIST
1646: PUSH
1647: LD_INT 33
1649: PUSH
1650: LD_INT 54
1652: PUSH
1653: EMPTY
1654: LIST
1655: LIST
1656: PUSH
1657: LD_INT 38
1659: PUSH
1660: LD_INT 56
1662: PUSH
1663: EMPTY
1664: LIST
1665: LIST
1666: PUSH
1667: EMPTY
1668: LIST
1669: LIST
1670: LIST
1671: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , us_cargo_bay , 80 ) ;
1672: LD_ADDR_VAR 0 4
1676: PUSH
1677: LD_INT 1
1679: PPUSH
1680: LD_INT 1
1682: PPUSH
1683: LD_INT 2
1685: PPUSH
1686: LD_INT 2
1688: PPUSH
1689: LD_INT 1
1691: PPUSH
1692: LD_INT 12
1694: PPUSH
1695: LD_INT 80
1697: PPUSH
1698: CALL 366 0 7
1702: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1703: LD_VAR 0 4
1707: PPUSH
1708: LD_INT 1
1710: PPUSH
1711: CALL_OW 233
// PlaceUnitXY ( veh , points [ 1 ] [ 1 ] , points [ 1 ] [ 2 ] , false ) ;
1715: LD_VAR 0 4
1719: PPUSH
1720: LD_VAR 0 3
1724: PUSH
1725: LD_INT 1
1727: ARRAY
1728: PUSH
1729: LD_INT 1
1731: ARRAY
1732: PPUSH
1733: LD_VAR 0 3
1737: PUSH
1738: LD_INT 1
1740: ARRAY
1741: PUSH
1742: LD_INT 2
1744: ARRAY
1745: PPUSH
1746: LD_INT 0
1748: PPUSH
1749: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
1753: LD_VAR 0 4
1757: PPUSH
1758: LD_INT 1
1760: PPUSH
1761: LD_INT 100
1763: PPUSH
1764: CALL_OW 290
// PlaceHumanInUnit ( others [ 1 ] , veh ) ;
1768: LD_EXP 25
1772: PUSH
1773: LD_INT 1
1775: ARRAY
1776: PPUSH
1777: LD_VAR 0 4
1781: PPUSH
1782: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_machine_gun , 80 ) ;
1786: LD_ADDR_VAR 0 4
1790: PUSH
1791: LD_INT 1
1793: PPUSH
1794: LD_INT 1
1796: PPUSH
1797: LD_INT 1
1799: PPUSH
1800: LD_INT 2
1802: PPUSH
1803: LD_INT 1
1805: PPUSH
1806: LD_INT 2
1808: PPUSH
1809: LD_INT 80
1811: PPUSH
1812: CALL 366 0 7
1816: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1817: LD_VAR 0 4
1821: PPUSH
1822: LD_INT 1
1824: PPUSH
1825: CALL_OW 233
// PlaceUnitXY ( veh , points [ 2 ] [ 1 ] , points [ 2 ] [ 2 ] , false ) ;
1829: LD_VAR 0 4
1833: PPUSH
1834: LD_VAR 0 3
1838: PUSH
1839: LD_INT 2
1841: ARRAY
1842: PUSH
1843: LD_INT 1
1845: ARRAY
1846: PPUSH
1847: LD_VAR 0 3
1851: PUSH
1852: LD_INT 2
1854: ARRAY
1855: PUSH
1856: LD_INT 2
1858: ARRAY
1859: PPUSH
1860: LD_INT 0
1862: PPUSH
1863: CALL_OW 48
// PlaceHumanInUnit ( Gladstone , veh ) ;
1867: LD_EXP 16
1871: PPUSH
1872: LD_VAR 0 4
1876: PPUSH
1877: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_light_gun , 80 ) ;
1881: LD_ADDR_VAR 0 4
1885: PUSH
1886: LD_INT 1
1888: PPUSH
1889: LD_INT 1
1891: PPUSH
1892: LD_INT 1
1894: PPUSH
1895: LD_INT 2
1897: PPUSH
1898: LD_INT 1
1900: PPUSH
1901: LD_INT 3
1903: PPUSH
1904: LD_INT 80
1906: PPUSH
1907: CALL 366 0 7
1911: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1912: LD_VAR 0 4
1916: PPUSH
1917: LD_INT 1
1919: PPUSH
1920: CALL_OW 233
// PlaceUnitXY ( veh , points [ 3 ] [ 1 ] , points [ 3 ] [ 2 ] , false ) ;
1924: LD_VAR 0 4
1928: PPUSH
1929: LD_VAR 0 3
1933: PUSH
1934: LD_INT 3
1936: ARRAY
1937: PUSH
1938: LD_INT 1
1940: ARRAY
1941: PPUSH
1942: LD_VAR 0 3
1946: PUSH
1947: LD_INT 3
1949: ARRAY
1950: PUSH
1951: LD_INT 2
1953: ARRAY
1954: PPUSH
1955: LD_INT 0
1957: PPUSH
1958: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1962: LD_EXP 15
1966: PPUSH
1967: LD_VAR 0 4
1971: PPUSH
1972: CALL_OW 52
// for i in tmp diff others [ 1 ] do
1976: LD_ADDR_VAR 0 2
1980: PUSH
1981: LD_VAR 0 5
1985: PUSH
1986: LD_EXP 25
1990: PUSH
1991: LD_INT 1
1993: ARRAY
1994: DIFF
1995: PUSH
1996: FOR_IN
1997: IFFALSE 2016
// PlaceUnitArea ( i , startArea , false ) ;
1999: LD_VAR 0 2
2003: PPUSH
2004: LD_INT 5
2006: PPUSH
2007: LD_INT 0
2009: PPUSH
2010: CALL_OW 49
2014: GO 1996
2016: POP
2017: POP
// end ; end_of_file
2018: LD_VAR 0 1
2022: RET
// export function Action ; var m ; begin
2023: LD_INT 0
2025: PPUSH
2026: PPUSH
// InGameOn ;
2027: CALL_OW 8
// CenterNowOnXY ( 28 , 51 ) ;
2031: LD_INT 28
2033: PPUSH
2034: LD_INT 51
2036: PPUSH
2037: CALL_OW 86
// Wait ( 3 ) ;
2041: LD_INT 3
2043: PPUSH
2044: CALL_OW 67
// Say ( JMM , D1d-JMM-1a ) ;
2048: LD_EXP 15
2052: PPUSH
2053: LD_STRING D1d-JMM-1a
2055: PPUSH
2056: CALL_OW 88
// SayRadio ( Harrison , D1d-Har-1 ) ;
2060: LD_EXP 17
2064: PPUSH
2065: LD_STRING D1d-Har-1
2067: PPUSH
2068: CALL_OW 94
// InGameOff ;
2072: CALL_OW 9
// SaveForQuickRestart ;
2076: CALL_OW 22
// ChangeMissionObjectives ( M1 ) ;
2080: LD_STRING M1
2082: PPUSH
2083: CALL_OW 337
// Wait ( 0 0$2 ) ;
2087: LD_INT 70
2089: PPUSH
2090: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
2094: LD_EXP 15
2098: PPUSH
2099: LD_STRING D2-JMM-1
2101: PPUSH
2102: CALL_OW 88
// Say ( Gladstone , D2-Glad-1 ) ;
2106: LD_EXP 16
2110: PPUSH
2111: LD_STRING D2-Glad-1
2113: PPUSH
2114: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
2118: LD_EXP 15
2122: PPUSH
2123: LD_STRING D2-JMM-2
2125: PPUSH
2126: CALL_OW 88
// Say ( Gladstone , D2-Glad-2 ) ;
2130: LD_EXP 16
2134: PPUSH
2135: LD_STRING D2-Glad-2
2137: PPUSH
2138: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
2142: LD_EXP 15
2146: PPUSH
2147: LD_STRING D2-JMM-3
2149: PPUSH
2150: CALL_OW 88
// Wait ( rand ( 0 0$30 , 1 1$00 ) ) ;
2154: LD_INT 1050
2156: PPUSH
2157: LD_INT 2100
2159: PPUSH
2160: CALL_OW 12
2164: PPUSH
2165: CALL_OW 67
// SetWeather ( 2 , 90 , 150 ) ;
2169: LD_INT 2
2171: PPUSH
2172: LD_INT 90
2174: PPUSH
2175: LD_INT 150
2177: PPUSH
2178: CALL_OW 550
// Wait ( rand ( 3 3$00 , 5 5$00 ) ) ;
2182: LD_INT 6300
2184: PPUSH
2185: LD_INT 10500
2187: PPUSH
2188: CALL_OW 12
2192: PPUSH
2193: CALL_OW 67
// SetWeather ( 0 , 90 , 150 ) ;
2197: LD_INT 0
2199: PPUSH
2200: LD_INT 90
2202: PPUSH
2203: LD_INT 150
2205: PPUSH
2206: CALL_OW 550
// end ;
2210: LD_VAR 0 1
2214: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) and not deltaBuilded do
2215: LD_INT 22
2217: PUSH
2218: LD_INT 1
2220: PUSH
2221: EMPTY
2222: LIST
2223: LIST
2224: PUSH
2225: LD_INT 3
2227: PUSH
2228: LD_INT 57
2230: PUSH
2231: EMPTY
2232: LIST
2233: PUSH
2234: EMPTY
2235: LIST
2236: LIST
2237: PUSH
2238: LD_INT 30
2240: PUSH
2241: LD_INT 0
2243: PUSH
2244: EMPTY
2245: LIST
2246: LIST
2247: PUSH
2248: EMPTY
2249: LIST
2250: LIST
2251: LIST
2252: PUSH
2253: EMPTY
2254: LIST
2255: PPUSH
2256: CALL_OW 69
2260: PUSH
2261: LD_EXP 4
2265: NOT
2266: AND
2267: IFFALSE 2280
2269: GO 2271
2271: DISABLE
// begin deltaBuilded := true ;
2272: LD_ADDR_EXP 4
2276: PUSH
2277: LD_INT 1
2279: ST_TO_ADDR
// end ;
2280: END
// every 0 0$01 trigger not Delta and deltaBuilded and FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) do
2281: LD_EXP 6
2285: NOT
2286: PUSH
2287: LD_EXP 4
2291: AND
2292: PUSH
2293: LD_INT 22
2295: PUSH
2296: LD_INT 1
2298: PUSH
2299: EMPTY
2300: LIST
2301: LIST
2302: PUSH
2303: LD_INT 3
2305: PUSH
2306: LD_INT 57
2308: PUSH
2309: EMPTY
2310: LIST
2311: PUSH
2312: EMPTY
2313: LIST
2314: LIST
2315: PUSH
2316: LD_INT 30
2318: PUSH
2319: LD_INT 0
2321: PUSH
2322: EMPTY
2323: LIST
2324: LIST
2325: PUSH
2326: EMPTY
2327: LIST
2328: LIST
2329: LIST
2330: PUSH
2331: EMPTY
2332: LIST
2333: PPUSH
2334: CALL_OW 69
2338: AND
2339: IFFALSE 2425
2341: GO 2343
2343: DISABLE
// begin enable ;
2344: ENABLE
// SetRestrict ( b_depot , 1 , state_disabled ) ;
2345: LD_INT 0
2347: PPUSH
2348: LD_INT 1
2350: PPUSH
2351: LD_INT 0
2353: PPUSH
2354: CALL_OW 324
// Delta := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) [ 1 ] ;
2358: LD_ADDR_EXP 6
2362: PUSH
2363: LD_INT 22
2365: PUSH
2366: LD_INT 1
2368: PUSH
2369: EMPTY
2370: LIST
2371: LIST
2372: PUSH
2373: LD_INT 3
2375: PUSH
2376: LD_INT 57
2378: PUSH
2379: EMPTY
2380: LIST
2381: PUSH
2382: EMPTY
2383: LIST
2384: LIST
2385: PUSH
2386: LD_INT 30
2388: PUSH
2389: LD_INT 0
2391: PUSH
2392: EMPTY
2393: LIST
2394: LIST
2395: PUSH
2396: EMPTY
2397: LIST
2398: LIST
2399: LIST
2400: PUSH
2401: EMPTY
2402: LIST
2403: PPUSH
2404: CALL_OW 69
2408: PUSH
2409: LD_INT 1
2411: ARRAY
2412: ST_TO_ADDR
// SetBName ( Delta , Delta ) ;
2413: LD_EXP 6
2417: PPUSH
2418: LD_STRING Delta
2420: PPUSH
2421: CALL_OW 500
// end ;
2425: END
// every 0 0$2 trigger GetTech ( tech_ApeLang , 1 ) = state_researched do
2426: LD_INT 1
2428: PPUSH
2429: LD_INT 1
2431: PPUSH
2432: CALL_OW 321
2436: PUSH
2437: LD_INT 2
2439: EQUAL
2440: IFFALSE 2501
2442: GO 2444
2444: DISABLE
// begin DialogueOn ;
2445: CALL_OW 6
// Say ( Gladstone , D3-Glad-1 ) ;
2449: LD_EXP 16
2453: PPUSH
2454: LD_STRING D3-Glad-1
2456: PPUSH
2457: CALL_OW 88
// Say ( JMM , D3-JMM-1 ) ;
2461: LD_EXP 15
2465: PPUSH
2466: LD_STRING D3-JMM-1
2468: PPUSH
2469: CALL_OW 88
// Say ( Gladstone , D3-Glad-2 ) ;
2473: LD_EXP 16
2477: PPUSH
2478: LD_STRING D3-Glad-2
2480: PPUSH
2481: CALL_OW 88
// Say ( JMM , D3-JMM-2 ) ;
2485: LD_EXP 15
2489: PPUSH
2490: LD_STRING D3-JMM-2
2492: PPUSH
2493: CALL_OW 88
// DialogueOff ;
2497: CALL_OW 7
// end ;
2501: END
// every 0 0$1 trigger GetTech ( tech_ApePsych , 1 ) = state_researched do var sol ;
2502: LD_INT 2
2504: PPUSH
2505: LD_INT 1
2507: PPUSH
2508: CALL_OW 321
2512: PUSH
2513: LD_INT 2
2515: EQUAL
2516: IFFALSE 2693
2518: GO 2520
2520: DISABLE
2521: LD_INT 0
2523: PPUSH
// begin DialogueOn ;
2524: CALL_OW 6
// if Frank then
2528: LD_EXP 22
2532: IFFALSE 2546
// Say ( Frank , D8a-Frank-1 ) ;
2534: LD_EXP 22
2538: PPUSH
2539: LD_STRING D8a-Frank-1
2541: PPUSH
2542: CALL_OW 88
// sol := SayX ( UnitFilter ( others , [ f_sex , sex_male ] ) , D8a-Sol1-1 ) ;
2546: LD_ADDR_VAR 0 1
2550: PUSH
2551: LD_EXP 25
2555: PPUSH
2556: LD_INT 26
2558: PUSH
2559: LD_INT 1
2561: PUSH
2562: EMPTY
2563: LIST
2564: LIST
2565: PPUSH
2566: CALL_OW 72
2570: PPUSH
2571: LD_STRING D8a-Sol1-1
2573: PPUSH
2574: CALL 454 0 2
2578: ST_TO_ADDR
// if Denis and GetSide ( Denis ) = 1 then
2579: LD_EXP 18
2583: PUSH
2584: LD_EXP 18
2588: PPUSH
2589: CALL_OW 255
2593: PUSH
2594: LD_INT 1
2596: EQUAL
2597: AND
2598: IFFALSE 2612
// Say ( Denis , D8a-Den-1 ) ;
2600: LD_EXP 18
2604: PPUSH
2605: LD_STRING D8a-Den-1
2607: PPUSH
2608: CALL_OW 88
// if sol or Denis or Frank then
2612: LD_VAR 0 1
2616: PUSH
2617: LD_EXP 18
2621: OR
2622: PUSH
2623: LD_EXP 22
2627: OR
2628: IFFALSE 2689
// begin SayX ( UnitFilter ( others , [ [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff sol , D8a-Sci1-1 ) ;
2630: LD_EXP 25
2634: PPUSH
2635: LD_INT 25
2637: PUSH
2638: LD_INT 4
2640: PUSH
2641: EMPTY
2642: LIST
2643: LIST
2644: PUSH
2645: LD_INT 26
2647: PUSH
2648: LD_INT 1
2650: PUSH
2651: EMPTY
2652: LIST
2653: LIST
2654: PUSH
2655: EMPTY
2656: LIST
2657: LIST
2658: PPUSH
2659: CALL_OW 72
2663: PUSH
2664: LD_VAR 0 1
2668: DIFF
2669: PPUSH
2670: LD_STRING D8a-Sci1-1
2672: PPUSH
2673: CALL 454 0 2
// Say ( JMM , D8a-JMM-1 ) ;
2677: LD_EXP 15
2681: PPUSH
2682: LD_STRING D8a-JMM-1
2684: PPUSH
2685: CALL_OW 88
// end ; DialogueOff ;
2689: CALL_OW 7
// end ;
2693: PPOPN 1
2695: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) do
2696: LD_INT 22
2698: PUSH
2699: LD_INT 1
2701: PUSH
2702: EMPTY
2703: LIST
2704: LIST
2705: PUSH
2706: LD_INT 25
2708: PUSH
2709: LD_INT 16
2711: PUSH
2712: EMPTY
2713: LIST
2714: LIST
2715: PUSH
2716: EMPTY
2717: LIST
2718: LIST
2719: PPUSH
2720: CALL_OW 69
2724: IFFALSE 2783
2726: GO 2728
2728: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
2729: LD_STRING M1a
2731: PPUSH
2732: CALL_OW 337
// case Query ( Q2 ) of 1 :
2736: LD_STRING Q2
2738: PPUSH
2739: CALL_OW 97
2743: PUSH
2744: LD_INT 1
2746: DOUBLE
2747: EQUAL
2748: IFTRUE 2752
2750: GO 2763
2752: POP
// end_mission := true ; 2 :
2753: LD_ADDR_EXP 14
2757: PUSH
2758: LD_INT 1
2760: ST_TO_ADDR
2761: GO 2783
2763: LD_INT 2
2765: DOUBLE
2766: EQUAL
2767: IFTRUE 2771
2769: GO 2782
2771: POP
// end_the_mission_allowed := true ; end ;
2772: LD_ADDR_OWVAR 57
2776: PUSH
2777: LD_INT 1
2779: ST_TO_ADDR
2780: GO 2783
2782: POP
// end ;
2783: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) and Delta do
2784: LD_INT 22
2786: PUSH
2787: LD_INT 1
2789: PUSH
2790: EMPTY
2791: LIST
2792: LIST
2793: PUSH
2794: LD_INT 2
2796: PUSH
2797: LD_INT 30
2799: PUSH
2800: LD_INT 6
2802: PUSH
2803: EMPTY
2804: LIST
2805: LIST
2806: PUSH
2807: LD_INT 30
2809: PUSH
2810: LD_INT 7
2812: PUSH
2813: EMPTY
2814: LIST
2815: LIST
2816: PUSH
2817: EMPTY
2818: LIST
2819: LIST
2820: LIST
2821: PUSH
2822: EMPTY
2823: LIST
2824: LIST
2825: PPUSH
2826: CALL_OW 69
2830: PUSH
2831: LD_INT 22
2833: PUSH
2834: LD_INT 1
2836: PUSH
2837: EMPTY
2838: LIST
2839: LIST
2840: PUSH
2841: LD_INT 2
2843: PUSH
2844: LD_INT 30
2846: PUSH
2847: LD_INT 2
2849: PUSH
2850: EMPTY
2851: LIST
2852: LIST
2853: PUSH
2854: LD_INT 30
2856: PUSH
2857: LD_INT 3
2859: PUSH
2860: EMPTY
2861: LIST
2862: LIST
2863: PUSH
2864: EMPTY
2865: LIST
2866: LIST
2867: LIST
2868: PUSH
2869: EMPTY
2870: LIST
2871: LIST
2872: PPUSH
2873: CALL_OW 69
2877: AND
2878: PUSH
2879: LD_EXP 6
2883: AND
2884: IFFALSE 3311
2886: GO 2888
2888: DISABLE
// begin Wait ( rand ( 0 0$20 , 0 0$40 ) ) ;
2889: LD_INT 700
2891: PPUSH
2892: LD_INT 1400
2894: PPUSH
2895: CALL_OW 12
2899: PPUSH
2900: CALL_OW 67
// PlaceUnitArea ( Denis , [ denisArea1 , denisArea2 , denisArea3 ] [ Difficulty ] , false ) ;
2904: LD_EXP 18
2908: PPUSH
2909: LD_INT 6
2911: PUSH
2912: LD_INT 9
2914: PUSH
2915: LD_INT 10
2917: PUSH
2918: EMPTY
2919: LIST
2920: LIST
2921: LIST
2922: PUSH
2923: LD_OWVAR 67
2927: ARRAY
2928: PPUSH
2929: LD_INT 0
2931: PPUSH
2932: CALL_OW 49
// ComHold ( Denis ) ;
2936: LD_EXP 18
2940: PPUSH
2941: CALL_OW 140
// InGameOn ;
2945: CALL_OW 8
// DialogueOn ;
2949: CALL_OW 6
// if Delta then
2953: LD_EXP 6
2957: IFFALSE 2970
// CenterNowOnUnits ( Delta ) else
2959: LD_EXP 6
2963: PPUSH
2964: CALL_OW 87
2968: GO 2979
// CenterNowOnUnits ( JMM ) ;
2970: LD_EXP 15
2974: PPUSH
2975: CALL_OW 87
// SayRadio ( Denis , DD-Den-1 ) ;
2979: LD_EXP 18
2983: PPUSH
2984: LD_STRING DD-Den-1
2986: PPUSH
2987: CALL_OW 94
// Say ( JMM , DD-JMM-1 ) ;
2991: LD_EXP 15
2995: PPUSH
2996: LD_STRING DD-JMM-1
2998: PPUSH
2999: CALL_OW 88
// SayRadio ( Denis , DD-Den-2 ) ;
3003: LD_EXP 18
3007: PPUSH
3008: LD_STRING DD-Den-2
3010: PPUSH
3011: CALL_OW 94
// Wait ( 3 ) ;
3015: LD_INT 3
3017: PPUSH
3018: CALL_OW 67
// DialogueOff ;
3022: CALL_OW 7
// InGameOff ;
3026: CALL_OW 9
// repeat wait ( 0 0$01 ) ;
3030: LD_INT 35
3032: PPUSH
3033: CALL_OW 67
// until See ( 1 , Denis ) or IsDead ( Denis ) ;
3037: LD_INT 1
3039: PPUSH
3040: LD_EXP 18
3044: PPUSH
3045: CALL_OW 292
3049: PUSH
3050: LD_EXP 18
3054: PPUSH
3055: CALL_OW 301
3059: OR
3060: IFFALSE 3030
// if IsDead ( Denis ) then
3062: LD_EXP 18
3066: PPUSH
3067: CALL_OW 301
3071: IFFALSE 3075
// exit ;
3073: GO 3311
// SetSide ( Denis , 1 ) ;
3075: LD_EXP 18
3079: PPUSH
3080: LD_INT 1
3082: PPUSH
3083: CALL_OW 235
// Say ( Denis , DD-Den-2a ) ;
3087: LD_EXP 18
3091: PPUSH
3092: LD_STRING DD-Den-2a
3094: PPUSH
3095: CALL_OW 88
// repeat wait ( 0 0$01 ) ;
3099: LD_INT 35
3101: PPUSH
3102: CALL_OW 67
// until GetBType ( IsInUnit ( Denis ) ) in [ b_lab , b_lab_half , b_lab_full ] or IsDead ( Denis ) ;
3106: LD_EXP 18
3110: PPUSH
3111: CALL_OW 310
3115: PPUSH
3116: CALL_OW 266
3120: PUSH
3121: LD_INT 6
3123: PUSH
3124: LD_INT 7
3126: PUSH
3127: LD_INT 8
3129: PUSH
3130: EMPTY
3131: LIST
3132: LIST
3133: LIST
3134: IN
3135: PUSH
3136: LD_EXP 18
3140: PPUSH
3141: CALL_OW 301
3145: OR
3146: IFFALSE 3099
// if IsDead ( Denis ) then
3148: LD_EXP 18
3152: PPUSH
3153: CALL_OW 301
3157: IFFALSE 3161
// exit ;
3159: GO 3311
// Say ( Denis , DD-Den-2b ) ;
3161: LD_EXP 18
3165: PPUSH
3166: LD_STRING DD-Den-2b
3168: PPUSH
3169: CALL_OW 88
// ComChangeProfession ( Denis , 4 ) ;
3173: LD_EXP 18
3177: PPUSH
3178: LD_INT 4
3180: PPUSH
3181: CALL_OW 123
// Wait ( 0 0$02 ) ;
3185: LD_INT 70
3187: PPUSH
3188: CALL_OW 67
// DialogueOn ;
3192: CALL_OW 6
// CenterNowOnUnits ( Denis ) ;
3196: LD_EXP 18
3200: PPUSH
3201: CALL_OW 87
// Say ( JMM , D4-JMM-1 ) ;
3205: LD_EXP 15
3209: PPUSH
3210: LD_STRING D4-JMM-1
3212: PPUSH
3213: CALL_OW 88
// Say ( Denis , D4-Den-1 ) ;
3217: LD_EXP 18
3221: PPUSH
3222: LD_STRING D4-Den-1
3224: PPUSH
3225: CALL_OW 88
// Say ( JMM , D4-JMM-2 ) ;
3229: LD_EXP 15
3233: PPUSH
3234: LD_STRING D4-JMM-2
3236: PPUSH
3237: CALL_OW 88
// Say ( Denis , D4-Den-2 ) ;
3241: LD_EXP 18
3245: PPUSH
3246: LD_STRING D4-Den-2
3248: PPUSH
3249: CALL_OW 88
// DialogueOff ;
3253: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
3257: LD_STRING M2
3259: PPUSH
3260: CALL_OW 337
// radar_allowed := true ;
3264: LD_ADDR_EXP 7
3268: PUSH
3269: LD_INT 1
3271: ST_TO_ADDR
// SetTech ( tech_radar , 1 , state_enabled ) ;
3272: LD_INT 6
3274: PPUSH
3275: LD_INT 1
3277: PPUSH
3278: LD_INT 1
3280: PPUSH
3281: CALL_OW 322
// SetRestrict ( b_lab_opto , 1 , state_enabled ) ;
3285: LD_INT 15
3287: PPUSH
3288: LD_INT 1
3290: PPUSH
3291: LD_INT 1
3293: PPUSH
3294: CALL_OW 324
// SetRestrict ( b_ext_radar , 1 , state_enabled ) ;
3298: LD_INT 20
3300: PPUSH
3301: LD_INT 1
3303: PPUSH
3304: LD_INT 1
3306: PPUSH
3307: CALL_OW 324
// end ;
3311: END
// every 0 0$1 trigger arab_spotted do var sol , sol2 ;
3312: LD_EXP 13
3316: IFFALSE 3939
3318: GO 3320
3320: DISABLE
3321: LD_INT 0
3323: PPUSH
3324: PPUSH
// begin sol := SayX ( UnitFilter ( others , [ f_sex , sex_male ] ) , D5-Sol1-1 ) ;
3325: LD_ADDR_VAR 0 1
3329: PUSH
3330: LD_EXP 25
3334: PPUSH
3335: LD_INT 26
3337: PUSH
3338: LD_INT 1
3340: PUSH
3341: EMPTY
3342: LIST
3343: LIST
3344: PPUSH
3345: CALL_OW 72
3349: PPUSH
3350: LD_STRING D5-Sol1-1
3352: PPUSH
3353: CALL 454 0 2
3357: ST_TO_ADDR
// if not sol then
3358: LD_VAR 0 1
3362: NOT
3363: IFFALSE 3367
// exit ;
3365: GO 3939
// repeat wait ( 0 0$01 ) ;
3367: LD_INT 35
3369: PPUSH
3370: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 ;
3374: LD_INT 22
3376: PUSH
3377: LD_INT 2
3379: PUSH
3380: EMPTY
3381: LIST
3382: LIST
3383: PUSH
3384: LD_INT 21
3386: PUSH
3387: LD_INT 1
3389: PUSH
3390: EMPTY
3391: LIST
3392: LIST
3393: PUSH
3394: EMPTY
3395: LIST
3396: LIST
3397: PPUSH
3398: CALL_OW 69
3402: PUSH
3403: LD_INT 0
3405: EQUAL
3406: IFFALSE 3367
// if IsOk ( sol ) then
3408: LD_VAR 0 1
3412: PPUSH
3413: CALL_OW 302
3417: IFFALSE 3437
// begin sol2 := others diff sol ;
3419: LD_ADDR_VAR 0 2
3423: PUSH
3424: LD_EXP 25
3428: PUSH
3429: LD_VAR 0 1
3433: DIFF
3434: ST_TO_ADDR
// end else
3435: GO 3439
// exit ;
3437: GO 3939
// if not Lisa and not sol2 then
3439: LD_EXP 21
3443: NOT
3444: PUSH
3445: LD_VAR 0 2
3449: NOT
3450: AND
3451: IFFALSE 3455
// exit ;
3453: GO 3939
// DialogueOn ;
3455: CALL_OW 6
// if Lisa then
3459: LD_EXP 21
3463: IFFALSE 3479
// Say ( Lisa , D5a-Lisa-1 ) else
3465: LD_EXP 21
3469: PPUSH
3470: LD_STRING D5a-Lisa-1
3472: PPUSH
3473: CALL_OW 88
3477: GO 3554
// if sol2 then
3479: LD_VAR 0 2
3483: IFFALSE 3554
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3485: LD_VAR 0 2
3489: PUSH
3490: LD_INT 1
3492: ARRAY
3493: PPUSH
3494: CALL_OW 258
3498: PUSH
3499: LD_INT 1
3501: DOUBLE
3502: EQUAL
3503: IFTRUE 3507
3505: GO 3526
3507: POP
// Say ( sol2 [ 1 ] , D5-Sol2-1 ) ; sex_female :
3508: LD_VAR 0 2
3512: PUSH
3513: LD_INT 1
3515: ARRAY
3516: PPUSH
3517: LD_STRING D5-Sol2-1
3519: PPUSH
3520: CALL_OW 88
3524: GO 3554
3526: LD_INT 2
3528: DOUBLE
3529: EQUAL
3530: IFTRUE 3534
3532: GO 3553
3534: POP
// Say ( sol2 [ 1 ] , D5-FSol2-1 ) ; end ;
3535: LD_VAR 0 2
3539: PUSH
3540: LD_INT 1
3542: ARRAY
3543: PPUSH
3544: LD_STRING D5-FSol2-1
3546: PPUSH
3547: CALL_OW 88
3551: GO 3554
3553: POP
// Say ( sol , D5-Sol1-2 ) ;
3554: LD_VAR 0 1
3558: PPUSH
3559: LD_STRING D5-Sol1-2
3561: PPUSH
3562: CALL_OW 88
// if Lisa then
3566: LD_EXP 21
3570: IFFALSE 3586
// Say ( Lisa , D5a-Lisa-2 ) else
3572: LD_EXP 21
3576: PPUSH
3577: LD_STRING D5a-Lisa-2
3579: PPUSH
3580: CALL_OW 88
3584: GO 3661
// if sol2 then
3586: LD_VAR 0 2
3590: IFFALSE 3661
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3592: LD_VAR 0 2
3596: PUSH
3597: LD_INT 1
3599: ARRAY
3600: PPUSH
3601: CALL_OW 258
3605: PUSH
3606: LD_INT 1
3608: DOUBLE
3609: EQUAL
3610: IFTRUE 3614
3612: GO 3633
3614: POP
// Say ( sol2 [ 1 ] , D5-Sol2-2 ) ; sex_female :
3615: LD_VAR 0 2
3619: PUSH
3620: LD_INT 1
3622: ARRAY
3623: PPUSH
3624: LD_STRING D5-Sol2-2
3626: PPUSH
3627: CALL_OW 88
3631: GO 3661
3633: LD_INT 2
3635: DOUBLE
3636: EQUAL
3637: IFTRUE 3641
3639: GO 3660
3641: POP
// Say ( sol2 [ 1 ] , D5-FSol2-2 ) ; end ;
3642: LD_VAR 0 2
3646: PUSH
3647: LD_INT 1
3649: ARRAY
3650: PPUSH
3651: LD_STRING D5-FSol2-2
3653: PPUSH
3654: CALL_OW 88
3658: GO 3661
3660: POP
// Say ( sol , D5a-Sol1-3 ) ;
3661: LD_VAR 0 1
3665: PPUSH
3666: LD_STRING D5a-Sol1-3
3668: PPUSH
3669: CALL_OW 88
// if Lisa then
3673: LD_EXP 21
3677: IFFALSE 3691
// Say ( Lisa , D5a-Lisa-3 ) ;
3679: LD_EXP 21
3683: PPUSH
3684: LD_STRING D5a-Lisa-3
3686: PPUSH
3687: CALL_OW 88
// if not sol2 then
3691: LD_VAR 0 2
3695: NOT
3696: IFFALSE 3704
// begin DialogueOff ;
3698: CALL_OW 7
// exit ;
3702: GO 3939
// end ; case GetSex ( sol2 [ 1 ] ) of sex_male :
3704: LD_VAR 0 2
3708: PUSH
3709: LD_INT 1
3711: ARRAY
3712: PPUSH
3713: CALL_OW 258
3717: PUSH
3718: LD_INT 1
3720: DOUBLE
3721: EQUAL
3722: IFTRUE 3726
3724: GO 3745
3726: POP
// Say ( sol2 [ 1 ] , D5-Sol2-3 ) ; sex_female :
3727: LD_VAR 0 2
3731: PUSH
3732: LD_INT 1
3734: ARRAY
3735: PPUSH
3736: LD_STRING D5-Sol2-3
3738: PPUSH
3739: CALL_OW 88
3743: GO 3773
3745: LD_INT 2
3747: DOUBLE
3748: EQUAL
3749: IFTRUE 3753
3751: GO 3772
3753: POP
// Say ( sol2 [ 1 ] , D5-FSol2-3 ) ; end ;
3754: LD_VAR 0 2
3758: PUSH
3759: LD_INT 1
3761: ARRAY
3762: PPUSH
3763: LD_STRING D5-FSol2-3
3765: PPUSH
3766: CALL_OW 88
3770: GO 3773
3772: POP
// Say ( sol , D5-Sol1-4 ) ;
3773: LD_VAR 0 1
3777: PPUSH
3778: LD_STRING D5-Sol1-4
3780: PPUSH
3781: CALL_OW 88
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3785: LD_VAR 0 2
3789: PUSH
3790: LD_INT 1
3792: ARRAY
3793: PPUSH
3794: CALL_OW 258
3798: PUSH
3799: LD_INT 1
3801: DOUBLE
3802: EQUAL
3803: IFTRUE 3807
3805: GO 3826
3807: POP
// Say ( sol2 [ 1 ] , D5-Sol2-4 ) ; sex_female :
3808: LD_VAR 0 2
3812: PUSH
3813: LD_INT 1
3815: ARRAY
3816: PPUSH
3817: LD_STRING D5-Sol2-4
3819: PPUSH
3820: CALL_OW 88
3824: GO 3854
3826: LD_INT 2
3828: DOUBLE
3829: EQUAL
3830: IFTRUE 3834
3832: GO 3853
3834: POP
// Say ( sol2 [ 1 ] , D5-FSol2-4 ) ; end ;
3835: LD_VAR 0 2
3839: PUSH
3840: LD_INT 1
3842: ARRAY
3843: PPUSH
3844: LD_STRING D5-FSol2-4
3846: PPUSH
3847: CALL_OW 88
3851: GO 3854
3853: POP
// Say ( sol , D5-Sol1-5 ) ;
3854: LD_VAR 0 1
3858: PPUSH
3859: LD_STRING D5-Sol1-5
3861: PPUSH
3862: CALL_OW 88
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3866: LD_VAR 0 2
3870: PUSH
3871: LD_INT 1
3873: ARRAY
3874: PPUSH
3875: CALL_OW 258
3879: PUSH
3880: LD_INT 1
3882: DOUBLE
3883: EQUAL
3884: IFTRUE 3888
3886: GO 3907
3888: POP
// Say ( sol2 [ 1 ] , D5-Sol2-5 ) ; sex_female :
3889: LD_VAR 0 2
3893: PUSH
3894: LD_INT 1
3896: ARRAY
3897: PPUSH
3898: LD_STRING D5-Sol2-5
3900: PPUSH
3901: CALL_OW 88
3905: GO 3935
3907: LD_INT 2
3909: DOUBLE
3910: EQUAL
3911: IFTRUE 3915
3913: GO 3934
3915: POP
// Say ( sol2 [ 1 ] , D5-FSol2-5 ) ; end ;
3916: LD_VAR 0 2
3920: PUSH
3921: LD_INT 1
3923: ARRAY
3924: PPUSH
3925: LD_STRING D5-FSol2-5
3927: PPUSH
3928: CALL_OW 88
3932: GO 3935
3934: POP
// DialogueOff ;
3935: CALL_OW 7
// end ;
3939: PPOPN 2
3941: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) >= 5 do
3942: LD_INT 22
3944: PUSH
3945: LD_INT 1
3947: PUSH
3948: EMPTY
3949: LIST
3950: LIST
3951: PUSH
3952: LD_INT 25
3954: PUSH
3955: LD_INT 16
3957: PUSH
3958: EMPTY
3959: LIST
3960: LIST
3961: PUSH
3962: EMPTY
3963: LIST
3964: LIST
3965: PPUSH
3966: CALL_OW 69
3970: PUSH
3971: LD_INT 5
3973: GREATEREQUAL
3974: IFFALSE 3994
3976: GO 3978
3978: DISABLE
// begin ChangeMissionObjectives ( M1b ) ;
3979: LD_STRING M1b
3981: PPUSH
3982: CALL_OW 337
// apeman_army := true ;
3986: LD_ADDR_EXP 9
3990: PUSH
3991: LD_INT 1
3993: ST_TO_ADDR
// end ;
3994: END
// every 0 0$1 trigger GetTech ( tech_radar , 1 ) = state_researched do
3995: LD_INT 6
3997: PPUSH
3998: LD_INT 1
4000: PPUSH
4001: CALL_OW 321
4005: PUSH
4006: LD_INT 2
4008: EQUAL
4009: IFFALSE 4029
4011: GO 4013
4013: DISABLE
// begin ChangeMissionObjectives ( M2a ) ;
4014: LD_STRING M2a
4016: PPUSH
4017: CALL_OW 337
// radar_researched := true ;
4021: LD_ADDR_EXP 10
4025: PUSH
4026: LD_INT 1
4028: ST_TO_ADDR
// end ;
4029: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_weapon , us_radar ] , [ f_bweapon , us_radar ] ] ] ) do
4030: LD_INT 22
4032: PUSH
4033: LD_INT 1
4035: PUSH
4036: EMPTY
4037: LIST
4038: LIST
4039: PUSH
4040: LD_INT 2
4042: PUSH
4043: LD_INT 34
4045: PUSH
4046: LD_INT 11
4048: PUSH
4049: EMPTY
4050: LIST
4051: LIST
4052: PUSH
4053: LD_INT 35
4055: PUSH
4056: LD_INT 11
4058: PUSH
4059: EMPTY
4060: LIST
4061: LIST
4062: PUSH
4063: EMPTY
4064: LIST
4065: LIST
4066: LIST
4067: PUSH
4068: EMPTY
4069: LIST
4070: LIST
4071: PPUSH
4072: CALL_OW 69
4076: IFFALSE 4096
4078: GO 4080
4080: DISABLE
// begin ChangeMissionObjectives ( M2b ) ;
4081: LD_STRING M2b
4083: PPUSH
4084: CALL_OW 337
// radar_builded := true ;
4088: LD_ADDR_EXP 11
4092: PUSH
4093: LD_INT 1
4095: ST_TO_ADDR
// end ;
4096: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) = 0 and not first_apeman_tamed do
4097: LD_INT 22
4099: PUSH
4100: LD_INT 0
4102: PUSH
4103: EMPTY
4104: LIST
4105: LIST
4106: PUSH
4107: LD_INT 25
4109: PUSH
4110: LD_INT 12
4112: PUSH
4113: EMPTY
4114: LIST
4115: LIST
4116: PUSH
4117: EMPTY
4118: LIST
4119: LIST
4120: PPUSH
4121: CALL_OW 69
4125: PUSH
4126: LD_INT 0
4128: EQUAL
4129: PUSH
4130: LD_EXP 8
4134: NOT
4135: AND
4136: IFFALSE 4148
4138: GO 4140
4140: DISABLE
// YouLost ( Apeman ) ;
4141: LD_STRING Apeman
4143: PPUSH
4144: CALL_OW 104
4148: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) >= 7 do var i , filter ;
4149: LD_INT 22
4151: PUSH
4152: LD_INT 1
4154: PUSH
4155: EMPTY
4156: LIST
4157: LIST
4158: PUSH
4159: LD_INT 25
4161: PUSH
4162: LD_INT 16
4164: PUSH
4165: EMPTY
4166: LIST
4167: LIST
4168: PUSH
4169: EMPTY
4170: LIST
4171: LIST
4172: PPUSH
4173: CALL_OW 69
4177: PUSH
4178: LD_INT 7
4180: GREATEREQUAL
4181: IFFALSE 4279
4183: GO 4185
4185: DISABLE
4186: LD_INT 0
4188: PPUSH
4189: PPUSH
// begin filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , 4 ] ] ) ^ JMM ;
4190: LD_ADDR_VAR 0 2
4194: PUSH
4195: LD_INT 22
4197: PUSH
4198: LD_INT 1
4200: PUSH
4201: EMPTY
4202: LIST
4203: LIST
4204: PUSH
4205: LD_INT 21
4207: PUSH
4208: LD_INT 1
4210: PUSH
4211: EMPTY
4212: LIST
4213: LIST
4214: PUSH
4215: LD_INT 25
4217: PUSH
4218: LD_INT 4
4220: PUSH
4221: EMPTY
4222: LIST
4223: LIST
4224: PUSH
4225: EMPTY
4226: LIST
4227: LIST
4228: LIST
4229: PPUSH
4230: CALL_OW 69
4234: PUSH
4235: LD_EXP 15
4239: ADD
4240: ST_TO_ADDR
// if filter then
4241: LD_VAR 0 2
4245: IFFALSE 4279
// for i in filter do
4247: LD_ADDR_VAR 0 1
4251: PUSH
4252: LD_VAR 0 2
4256: PUSH
4257: FOR_IN
4258: IFFALSE 4277
// AddExperience ( i , 4 , 3500 ) ;
4260: LD_VAR 0 1
4264: PPUSH
4265: LD_INT 4
4267: PPUSH
4268: LD_INT 3500
4270: PPUSH
4271: CALL_OW 492
4275: GO 4257
4277: POP
4278: POP
// end ;
4279: PPOPN 2
4281: END
// every 0 0$1 trigger end_mission do var i , tmp ;
4282: LD_EXP 14
4286: IFFALSE 5297
4288: GO 4290
4290: DISABLE
4291: LD_INT 0
4293: PPUSH
4294: PPUSH
// begin if FilterAllUnits ( [ f_side , 2 ] ) then
4295: LD_INT 22
4297: PUSH
4298: LD_INT 2
4300: PUSH
4301: EMPTY
4302: LIST
4303: LIST
4304: PPUSH
4305: CALL_OW 69
4309: IFFALSE 4347
// for i in FilterAllUnits ( [ f_side , 2 ] ) do
4311: LD_ADDR_VAR 0 1
4315: PUSH
4316: LD_INT 22
4318: PUSH
4319: LD_INT 2
4321: PUSH
4322: EMPTY
4323: LIST
4324: LIST
4325: PPUSH
4326: CALL_OW 69
4330: PUSH
4331: FOR_IN
4332: IFFALSE 4345
// RemoveUnit ( i ) ;
4334: LD_VAR 0 1
4338: PPUSH
4339: CALL_OW 64
4343: GO 4331
4345: POP
4346: POP
// if apeman_army then
4347: LD_EXP 9
4351: IFFALSE 4365
// AddMedal ( Tame , 1 ) else
4353: LD_STRING Tame
4355: PPUSH
4356: LD_INT 1
4358: PPUSH
4359: CALL_OW 101
4363: GO 4376
// AddMedal ( Tame , - 1 ) ;
4365: LD_STRING Tame
4367: PPUSH
4368: LD_INT 1
4370: NEG
4371: PPUSH
4372: CALL_OW 101
// if radar_researched then
4376: LD_EXP 10
4380: IFFALSE 4404
// begin SaveVariable ( true , radarResInDelta ) ;
4382: LD_INT 1
4384: PPUSH
4385: LD_STRING radarResInDelta
4387: PPUSH
4388: CALL_OW 39
// AddMedal ( Radar , 1 ) ;
4392: LD_STRING Radar
4394: PPUSH
4395: LD_INT 1
4397: PPUSH
4398: CALL_OW 101
// end else
4402: GO 4434
// if radar_allowed then
4404: LD_EXP 7
4408: IFFALSE 4423
// AddMedal ( Radar , - 2 ) else
4410: LD_STRING Radar
4412: PPUSH
4413: LD_INT 2
4415: NEG
4416: PPUSH
4417: CALL_OW 101
4421: GO 4434
// AddMedal ( Radar , - 1 ) ;
4423: LD_STRING Radar
4425: PPUSH
4426: LD_INT 1
4428: NEG
4429: PPUSH
4430: CALL_OW 101
// if radar_builded then
4434: LD_EXP 11
4438: IFFALSE 4452
// AddMedal ( BuildRadar , 1 ) else
4440: LD_STRING BuildRadar
4442: PPUSH
4443: LD_INT 1
4445: PPUSH
4446: CALL_OW 101
4450: GO 4463
// AddMedal ( BuildRadar , - 1 ) ;
4452: LD_STRING BuildRadar
4454: PPUSH
4455: LD_INT 1
4457: NEG
4458: PPUSH
4459: CALL_OW 101
// GiveMedals ( MAIN ) ;
4463: LD_STRING MAIN
4465: PPUSH
4466: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
4470: LD_ADDR_VAR 0 2
4474: PUSH
4475: LD_INT 22
4477: PUSH
4478: LD_INT 1
4480: PUSH
4481: EMPTY
4482: LIST
4483: LIST
4484: PUSH
4485: LD_INT 21
4487: PUSH
4488: LD_INT 1
4490: PUSH
4491: EMPTY
4492: LIST
4493: LIST
4494: PUSH
4495: LD_INT 2
4497: PUSH
4498: LD_INT 25
4500: PUSH
4501: LD_INT 1
4503: PUSH
4504: EMPTY
4505: LIST
4506: LIST
4507: PUSH
4508: LD_INT 25
4510: PUSH
4511: LD_INT 2
4513: PUSH
4514: EMPTY
4515: LIST
4516: LIST
4517: PUSH
4518: LD_INT 25
4520: PUSH
4521: LD_INT 3
4523: PUSH
4524: EMPTY
4525: LIST
4526: LIST
4527: PUSH
4528: LD_INT 25
4530: PUSH
4531: LD_INT 4
4533: PUSH
4534: EMPTY
4535: LIST
4536: LIST
4537: PUSH
4538: EMPTY
4539: LIST
4540: LIST
4541: LIST
4542: LIST
4543: LIST
4544: PUSH
4545: EMPTY
4546: LIST
4547: LIST
4548: LIST
4549: PPUSH
4550: CALL_OW 69
4554: ST_TO_ADDR
// RewardPeople ( tmp ) ;
4555: LD_VAR 0 2
4559: PPUSH
4560: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
4564: LD_EXP 15
4568: PPUSH
4569: LD_EXP 2
4573: PUSH
4574: LD_STRING JMM
4576: STR
4577: PPUSH
4578: CALL_OW 38
// if IsOk ( Gladstone ) then
4582: LD_EXP 16
4586: PPUSH
4587: CALL_OW 302
4591: IFFALSE 4611
// begin SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
4593: LD_EXP 16
4597: PPUSH
4598: LD_EXP 2
4602: PUSH
4603: LD_STRING Gladstone
4605: STR
4606: PPUSH
4607: CALL_OW 38
// end ; if IsOk ( Denis ) and GetSide ( Denis ) = 1 then
4611: LD_EXP 18
4615: PPUSH
4616: CALL_OW 302
4620: PUSH
4621: LD_EXP 18
4625: PPUSH
4626: CALL_OW 255
4630: PUSH
4631: LD_INT 1
4633: EQUAL
4634: AND
4635: IFFALSE 4665
// begin SaveCharacters ( Denis , mission_prefix & Denis ) ;
4637: LD_EXP 18
4641: PPUSH
4642: LD_EXP 2
4646: PUSH
4647: LD_STRING Denis
4649: STR
4650: PPUSH
4651: CALL_OW 38
// SaveVariable ( true , DenisInDelta ) ;
4655: LD_INT 1
4657: PPUSH
4658: LD_STRING DenisInDelta
4660: PPUSH
4661: CALL_OW 39
// end ; if IsOk ( Lisa ) then
4665: LD_EXP 21
4669: PPUSH
4670: CALL_OW 302
4674: IFFALSE 4694
// begin SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
4676: LD_EXP 21
4680: PPUSH
4681: LD_EXP 2
4685: PUSH
4686: LD_STRING Lisa
4688: STR
4689: PPUSH
4690: CALL_OW 38
// end ; if IsOk ( Frank ) then
4694: LD_EXP 22
4698: PPUSH
4699: CALL_OW 302
4703: IFFALSE 4723
// begin SaveCharacters ( Frank , mission_prefix & Frank ) ;
4705: LD_EXP 22
4709: PPUSH
4710: LD_EXP 2
4714: PUSH
4715: LD_STRING Frank
4717: STR
4718: PPUSH
4719: CALL_OW 38
// end ; if IsOk ( Bobby ) then
4723: LD_EXP 23
4727: PPUSH
4728: CALL_OW 302
4732: IFFALSE 4752
// begin SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
4734: LD_EXP 23
4738: PPUSH
4739: LD_EXP 2
4743: PUSH
4744: LD_STRING Bobby
4746: STR
4747: PPUSH
4748: CALL_OW 38
// end ; if IsOk ( Cyrus ) then
4752: LD_EXP 24
4756: PPUSH
4757: CALL_OW 302
4761: IFFALSE 4781
// begin SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
4763: LD_EXP 24
4767: PPUSH
4768: LD_EXP 2
4772: PUSH
4773: LD_STRING Cyrus
4775: STR
4776: PPUSH
4777: CALL_OW 38
// end ; if IsOk ( Brown ) then
4781: LD_EXP 19
4785: PPUSH
4786: CALL_OW 302
4790: IFFALSE 4810
// begin SaveCharacters ( Brown , mission_prefix & Brown ) ;
4792: LD_EXP 19
4796: PPUSH
4797: LD_EXP 2
4801: PUSH
4802: LD_STRING Brown
4804: STR
4805: PPUSH
4806: CALL_OW 38
// end ; if IsOk ( Donaldson ) then
4810: LD_EXP 20
4814: PPUSH
4815: CALL_OW 302
4819: IFFALSE 4839
// begin SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
4821: LD_EXP 20
4825: PPUSH
4826: LD_EXP 2
4830: PUSH
4831: LD_STRING Donaldson
4833: STR
4834: PPUSH
4835: CALL_OW 38
// end ; if others then
4839: LD_EXP 25
4843: IFFALSE 4857
// SaveCharacters ( others , othersInDelta ) ;
4845: LD_EXP 25
4849: PPUSH
4850: LD_STRING othersInDelta
4852: PPUSH
4853: CALL_OW 38
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) then
4857: LD_INT 22
4859: PUSH
4860: LD_INT 1
4862: PUSH
4863: EMPTY
4864: LIST
4865: LIST
4866: PUSH
4867: LD_INT 25
4869: PUSH
4870: LD_INT 16
4872: PUSH
4873: EMPTY
4874: LIST
4875: LIST
4876: PUSH
4877: EMPTY
4878: LIST
4879: LIST
4880: PPUSH
4881: CALL_OW 69
4885: IFFALSE 4923
// SaveCharacters ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) , apeInDelta ) ;
4887: LD_INT 22
4889: PUSH
4890: LD_INT 1
4892: PUSH
4893: EMPTY
4894: LIST
4895: LIST
4896: PUSH
4897: LD_INT 25
4899: PUSH
4900: LD_INT 16
4902: PUSH
4903: EMPTY
4904: LIST
4905: LIST
4906: PUSH
4907: EMPTY
4908: LIST
4909: LIST
4910: PPUSH
4911: CALL_OW 69
4915: PPUSH
4916: LD_STRING apeInDelta
4918: PPUSH
4919: CALL_OW 38
// tmp := [ ] ;
4923: LD_ADDR_VAR 0 2
4927: PUSH
4928: EMPTY
4929: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) then
4930: LD_INT 22
4932: PUSH
4933: LD_INT 1
4935: PUSH
4936: EMPTY
4937: LIST
4938: LIST
4939: PUSH
4940: LD_INT 21
4942: PUSH
4943: LD_INT 2
4945: PUSH
4946: EMPTY
4947: LIST
4948: LIST
4949: PUSH
4950: EMPTY
4951: LIST
4952: LIST
4953: PPUSH
4954: CALL_OW 69
4958: IFFALSE 5069
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) do
4960: LD_ADDR_VAR 0 1
4964: PUSH
4965: LD_INT 22
4967: PUSH
4968: LD_INT 1
4970: PUSH
4971: EMPTY
4972: LIST
4973: LIST
4974: PUSH
4975: LD_INT 21
4977: PUSH
4978: LD_INT 2
4980: PUSH
4981: EMPTY
4982: LIST
4983: LIST
4984: PUSH
4985: EMPTY
4986: LIST
4987: LIST
4988: PPUSH
4989: CALL_OW 69
4993: PUSH
4994: FOR_IN
4995: IFFALSE 5067
// tmp := tmp ^ [ GetNation ( i ) , GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) ] ;
4997: LD_ADDR_VAR 0 2
5001: PUSH
5002: LD_VAR 0 2
5006: PUSH
5007: LD_VAR 0 1
5011: PPUSH
5012: CALL_OW 248
5016: PUSH
5017: LD_VAR 0 1
5021: PPUSH
5022: CALL_OW 265
5026: PUSH
5027: LD_VAR 0 1
5031: PPUSH
5032: CALL_OW 262
5036: PUSH
5037: LD_VAR 0 1
5041: PPUSH
5042: CALL_OW 263
5046: PUSH
5047: LD_VAR 0 1
5051: PPUSH
5052: CALL_OW 264
5056: PUSH
5057: EMPTY
5058: LIST
5059: LIST
5060: LIST
5061: LIST
5062: LIST
5063: ADD
5064: ST_TO_ADDR
5065: GO 4994
5067: POP
5068: POP
// if tmp then
5069: LD_VAR 0 2
5073: IFFALSE 5087
// SaveVariable ( tmp , vehiclesInDelta ) ;
5075: LD_VAR 0 2
5079: PPUSH
5080: LD_STRING vehiclesInDelta
5082: PPUSH
5083: CALL_OW 39
// tmp := [ ] ;
5087: LD_ADDR_VAR 0 2
5091: PUSH
5092: EMPTY
5093: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) then
5094: LD_INT 22
5096: PUSH
5097: LD_INT 1
5099: PUSH
5100: EMPTY
5101: LIST
5102: LIST
5103: PUSH
5104: LD_INT 21
5106: PUSH
5107: LD_INT 3
5109: PUSH
5110: EMPTY
5111: LIST
5112: LIST
5113: PUSH
5114: EMPTY
5115: LIST
5116: LIST
5117: PPUSH
5118: CALL_OW 69
5122: IFFALSE 5275
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
5124: LD_ADDR_VAR 0 1
5128: PUSH
5129: LD_INT 22
5131: PUSH
5132: LD_INT 1
5134: PUSH
5135: EMPTY
5136: LIST
5137: LIST
5138: PUSH
5139: LD_INT 21
5141: PUSH
5142: LD_INT 3
5144: PUSH
5145: EMPTY
5146: LIST
5147: LIST
5148: PUSH
5149: EMPTY
5150: LIST
5151: LIST
5152: PPUSH
5153: CALL_OW 69
5157: PUSH
5158: FOR_IN
5159: IFFALSE 5273
// tmp := tmp ^ [ [ GetBType ( i ) , GetBLevel ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
5161: LD_ADDR_VAR 0 2
5165: PUSH
5166: LD_VAR 0 2
5170: PUSH
5171: LD_VAR 0 1
5175: PPUSH
5176: CALL_OW 266
5180: PUSH
5181: LD_VAR 0 1
5185: PPUSH
5186: CALL_OW 267
5190: PUSH
5191: LD_VAR 0 1
5195: PPUSH
5196: CALL_OW 250
5200: PUSH
5201: LD_VAR 0 1
5205: PPUSH
5206: CALL_OW 251
5210: PUSH
5211: LD_VAR 0 1
5215: PPUSH
5216: CALL_OW 254
5220: PUSH
5221: LD_VAR 0 1
5225: PPUSH
5226: LD_INT 1
5228: PPUSH
5229: CALL_OW 268
5233: PUSH
5234: LD_VAR 0 1
5238: PPUSH
5239: LD_INT 2
5241: PPUSH
5242: CALL_OW 268
5246: PUSH
5247: LD_VAR 0 1
5251: PPUSH
5252: CALL_OW 269
5256: PUSH
5257: EMPTY
5258: LIST
5259: LIST
5260: LIST
5261: LIST
5262: LIST
5263: LIST
5264: LIST
5265: LIST
5266: PUSH
5267: EMPTY
5268: LIST
5269: ADD
5270: ST_TO_ADDR
5271: GO 5158
5273: POP
5274: POP
// if tmp then
5275: LD_VAR 0 2
5279: IFFALSE 5293
// SaveVariable ( tmp , buildingsInDelta ) ;
5281: LD_VAR 0 2
5285: PPUSH
5286: LD_STRING buildingsInDelta
5288: PPUSH
5289: CALL_OW 39
// YouWin ;
5293: CALL_OW 103
// end ; end_of_file
5297: PPOPN 2
5299: END
// export function PrepareArabianTroops ( amount , skill , area ) ; var i , un , tmp ; begin
5300: LD_INT 0
5302: PPUSH
5303: PPUSH
5304: PPUSH
5305: PPUSH
// InitHc ;
5306: CALL_OW 19
// InitUc ;
5310: CALL_OW 18
// uc_side := 2 ;
5314: LD_ADDR_OWVAR 20
5318: PUSH
5319: LD_INT 2
5321: ST_TO_ADDR
// uc_nation := 2 ;
5322: LD_ADDR_OWVAR 21
5326: PUSH
5327: LD_INT 2
5329: ST_TO_ADDR
// if not amount then
5330: LD_VAR 0 1
5334: NOT
5335: IFFALSE 5339
// exit ;
5337: GO 5462
// for i = 1 to amount do
5339: LD_ADDR_VAR 0 5
5343: PUSH
5344: DOUBLE
5345: LD_INT 1
5347: DEC
5348: ST_TO_ADDR
5349: LD_VAR 0 1
5353: PUSH
5354: FOR_TO
5355: IFFALSE 5450
// begin PrepareHuman ( false , 1 , skill ) ;
5357: LD_INT 0
5359: PPUSH
5360: LD_INT 1
5362: PPUSH
5363: LD_VAR 0 2
5367: PPUSH
5368: CALL_OW 380
// un := CreateHuman ;
5372: LD_ADDR_VAR 0 6
5376: PUSH
5377: CALL_OW 44
5381: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
5382: LD_ADDR_VAR 0 7
5386: PUSH
5387: LD_VAR 0 7
5391: PPUSH
5392: LD_INT 1
5394: PPUSH
5395: LD_VAR 0 6
5399: PPUSH
5400: CALL_OW 2
5404: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5405: LD_VAR 0 6
5409: PPUSH
5410: LD_VAR 0 3
5414: PPUSH
5415: LD_INT 0
5417: PPUSH
5418: CALL_OW 49
// if i mod 2 = 0 then
5422: LD_VAR 0 5
5426: PUSH
5427: LD_INT 2
5429: MOD
5430: PUSH
5431: LD_INT 0
5433: EQUAL
5434: IFFALSE 5448
// SetTag ( un , 11 ) ;
5436: LD_VAR 0 6
5440: PPUSH
5441: LD_INT 11
5443: PPUSH
5444: CALL_OW 109
// end ;
5448: GO 5354
5450: POP
5451: POP
// result := tmp ;
5452: LD_ADDR_VAR 0 4
5456: PUSH
5457: LD_VAR 0 7
5461: ST_TO_ADDR
// end ;
5462: LD_VAR 0 4
5466: RET
// export ar_forces , ap_killers ; every 0 0$1 trigger Delta do var i , timer , more_troops , skill , eng , un , veh , force ;
5467: LD_EXP 6
5471: IFFALSE 6338
5473: GO 5475
5475: DISABLE
5476: LD_INT 0
5478: PPUSH
5479: PPUSH
5480: PPUSH
5481: PPUSH
5482: PPUSH
5483: PPUSH
5484: PPUSH
5485: PPUSH
// begin more_troops := false ;
5486: LD_ADDR_VAR 0 3
5490: PUSH
5491: LD_INT 0
5493: ST_TO_ADDR
// skill := [ 3 , 4 , 5 ] [ Difficulty ] ;
5494: LD_ADDR_VAR 0 4
5498: PUSH
5499: LD_INT 3
5501: PUSH
5502: LD_INT 4
5504: PUSH
5505: LD_INT 5
5507: PUSH
5508: EMPTY
5509: LIST
5510: LIST
5511: LIST
5512: PUSH
5513: LD_OWVAR 67
5517: ARRAY
5518: ST_TO_ADDR
// timer := [ 5 5$00 , 4 4$00 , 3 3$00 ] [ Difficulty ] ;
5519: LD_ADDR_VAR 0 2
5523: PUSH
5524: LD_INT 10500
5526: PUSH
5527: LD_INT 8400
5529: PUSH
5530: LD_INT 6300
5532: PUSH
5533: EMPTY
5534: LIST
5535: LIST
5536: LIST
5537: PUSH
5538: LD_OWVAR 67
5542: ARRAY
5543: ST_TO_ADDR
// force := [ ] ;
5544: LD_ADDR_VAR 0 8
5548: PUSH
5549: EMPTY
5550: ST_TO_ADDR
// ar_forces := [ ] ;
5551: LD_ADDR_EXP 26
5555: PUSH
5556: EMPTY
5557: ST_TO_ADDR
// ap_killers := [ ] ;
5558: LD_ADDR_EXP 27
5562: PUSH
5563: EMPTY
5564: ST_TO_ADDR
// Wait ( timer ) ;
5565: LD_VAR 0 2
5569: PPUSH
5570: CALL_OW 67
// if Denis and GetSide ( Denis ) = 4 then
5574: LD_EXP 18
5578: PUSH
5579: LD_EXP 18
5583: PPUSH
5584: CALL_OW 255
5588: PUSH
5589: LD_INT 4
5591: EQUAL
5592: AND
5593: IFFALSE 5602
// Wait ( 0 0$45 ) ;
5595: LD_INT 1575
5597: PPUSH
5598: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) then
5602: LD_INT 22
5604: PUSH
5605: LD_INT 1
5607: PUSH
5608: EMPTY
5609: LIST
5610: LIST
5611: PUSH
5612: LD_INT 30
5614: PUSH
5615: LD_INT 4
5617: PUSH
5618: EMPTY
5619: LIST
5620: LIST
5621: PUSH
5622: EMPTY
5623: LIST
5624: LIST
5625: PPUSH
5626: CALL_OW 69
5630: IFFALSE 5647
// begin Wait ( 1 1$25 ) ;
5632: LD_INT 2975
5634: PPUSH
5635: CALL_OW 67
// more_troops := true ;
5639: LD_ADDR_VAR 0 3
5643: PUSH
5644: LD_INT 1
5646: ST_TO_ADDR
// end ; if more_troops then
5647: LD_VAR 0 3
5651: IFFALSE 5839
// begin force := PrepareArabianTroops ( [ 4 , 5 , 6 ] [ Difficulty ] , skill , arArea2 ) ;
5653: LD_ADDR_VAR 0 8
5657: PUSH
5658: LD_INT 4
5660: PUSH
5661: LD_INT 5
5663: PUSH
5664: LD_INT 6
5666: PUSH
5667: EMPTY
5668: LIST
5669: LIST
5670: LIST
5671: PUSH
5672: LD_OWVAR 67
5676: ARRAY
5677: PPUSH
5678: LD_VAR 0 4
5682: PPUSH
5683: LD_INT 14
5685: PPUSH
5686: CALL 5300 0 3
5690: ST_TO_ADDR
// veh := PrepareTank ( 2 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_heavy_machine_gun , ru_gatling_gun ] [ Difficulty ] , 90 ) ;
5691: LD_ADDR_VAR 0 7
5695: PUSH
5696: LD_INT 2
5698: PPUSH
5699: LD_INT 3
5701: PPUSH
5702: LD_INT 22
5704: PPUSH
5705: LD_INT 1
5707: PPUSH
5708: LD_INT 1
5710: PPUSH
5711: LD_INT 42
5713: PUSH
5714: LD_INT 42
5716: PUSH
5717: LD_INT 43
5719: PUSH
5720: EMPTY
5721: LIST
5722: LIST
5723: LIST
5724: PUSH
5725: LD_OWVAR 67
5729: ARRAY
5730: PPUSH
5731: LD_INT 90
5733: PPUSH
5734: CALL 366 0 7
5738: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5739: LD_VAR 0 7
5743: PPUSH
5744: LD_INT 4
5746: PPUSH
5747: CALL_OW 233
// PlaceUnitArea ( veh , arArea1 , false ) ;
5751: LD_VAR 0 7
5755: PPUSH
5756: LD_INT 13
5758: PPUSH
5759: LD_INT 0
5761: PPUSH
5762: CALL_OW 49
// uc_side := 2 ;
5766: LD_ADDR_OWVAR 20
5770: PUSH
5771: LD_INT 2
5773: ST_TO_ADDR
// uc_nation := 2 ;
5774: LD_ADDR_OWVAR 21
5778: PUSH
5779: LD_INT 2
5781: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
5782: LD_INT 0
5784: PPUSH
5785: LD_INT 1
5787: PPUSH
5788: LD_VAR 0 4
5792: PPUSH
5793: CALL_OW 380
// un := CreateHuman ;
5797: LD_ADDR_VAR 0 6
5801: PUSH
5802: CALL_OW 44
5806: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
5807: LD_VAR 0 6
5811: PPUSH
5812: LD_VAR 0 7
5816: PPUSH
5817: CALL_OW 52
// force := force ^ un ;
5821: LD_ADDR_VAR 0 8
5825: PUSH
5826: LD_VAR 0 8
5830: PUSH
5831: LD_VAR 0 6
5835: ADD
5836: ST_TO_ADDR
// end else
5837: GO 5877
// begin force := PrepareArabianTroops ( [ 3 , 4 , 5 ] [ Difficulty ] , skill , arArea2 ) ;
5839: LD_ADDR_VAR 0 8
5843: PUSH
5844: LD_INT 3
5846: PUSH
5847: LD_INT 4
5849: PUSH
5850: LD_INT 5
5852: PUSH
5853: EMPTY
5854: LIST
5855: LIST
5856: LIST
5857: PUSH
5858: LD_OWVAR 67
5862: ARRAY
5863: PPUSH
5864: LD_VAR 0 4
5868: PPUSH
5869: LD_INT 14
5871: PPUSH
5872: CALL 5300 0 3
5876: ST_TO_ADDR
// end ; if force then
5877: LD_VAR 0 8
5881: IFFALSE 5893
// ar_forces := force ;
5883: LD_ADDR_EXP 26
5887: PUSH
5888: LD_VAR 0 8
5892: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5893: LD_INT 35
5895: PPUSH
5896: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 ;
5900: LD_INT 22
5902: PUSH
5903: LD_INT 2
5905: PUSH
5906: EMPTY
5907: LIST
5908: LIST
5909: PUSH
5910: LD_INT 21
5912: PUSH
5913: LD_INT 1
5915: PUSH
5916: EMPTY
5917: LIST
5918: LIST
5919: PUSH
5920: EMPTY
5921: LIST
5922: LIST
5923: PPUSH
5924: CALL_OW 69
5928: PUSH
5929: LD_INT 0
5931: EQUAL
5932: IFFALSE 5893
// Wait ( timer ) ;
5934: LD_VAR 0 2
5938: PPUSH
5939: CALL_OW 67
// force := PrepareArabianTroops ( [ 5 , 6 , 6 ] [ Difficulty ] , skill , [ arArea1 , arArea2 ] [ rand ( 1 , 2 ) ] ) ;
5943: LD_ADDR_VAR 0 8
5947: PUSH
5948: LD_INT 5
5950: PUSH
5951: LD_INT 6
5953: PUSH
5954: LD_INT 6
5956: PUSH
5957: EMPTY
5958: LIST
5959: LIST
5960: LIST
5961: PUSH
5962: LD_OWVAR 67
5966: ARRAY
5967: PPUSH
5968: LD_VAR 0 4
5972: PPUSH
5973: LD_INT 13
5975: PUSH
5976: LD_INT 14
5978: PUSH
5979: EMPTY
5980: LIST
5981: LIST
5982: PUSH
5983: LD_INT 1
5985: PPUSH
5986: LD_INT 2
5988: PPUSH
5989: CALL_OW 12
5993: ARRAY
5994: PPUSH
5995: CALL 5300 0 3
5999: ST_TO_ADDR
// if Difficulty > 1 and Delta then
6000: LD_OWVAR 67
6004: PUSH
6005: LD_INT 1
6007: GREATER
6008: PUSH
6009: LD_EXP 6
6013: AND
6014: IFFALSE 6093
// begin uc_side := 2 ;
6016: LD_ADDR_OWVAR 20
6020: PUSH
6021: LD_INT 2
6023: ST_TO_ADDR
// uc_nation := 2 ;
6024: LD_ADDR_OWVAR 21
6028: PUSH
6029: LD_INT 2
6031: ST_TO_ADDR
// PrepareHuman ( false , 2 , skill ) ;
6032: LD_INT 0
6034: PPUSH
6035: LD_INT 2
6037: PPUSH
6038: LD_VAR 0 4
6042: PPUSH
6043: CALL_OW 380
// eng := CreateHuman ;
6047: LD_ADDR_VAR 0 5
6051: PUSH
6052: CALL_OW 44
6056: ST_TO_ADDR
// PlaceUnitArea ( eng , arArea1 , false ) ;
6057: LD_VAR 0 5
6061: PPUSH
6062: LD_INT 13
6064: PPUSH
6065: LD_INT 0
6067: PPUSH
6068: CALL_OW 49
// Wait ( 3 ) ;
6072: LD_INT 3
6074: PPUSH
6075: CALL_OW 67
// AddComEnterUnit ( eng , Delta ) ;
6079: LD_VAR 0 5
6083: PPUSH
6084: LD_EXP 6
6088: PPUSH
6089: CALL_OW 180
// end ; if force then
6093: LD_VAR 0 8
6097: IFFALSE 6109
// ar_forces := force ;
6099: LD_ADDR_EXP 26
6103: PUSH
6104: LD_VAR 0 8
6108: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
6109: LD_INT 35
6111: PPUSH
6112: CALL_OW 67
// if eng then
6116: LD_VAR 0 5
6120: IFFALSE 6174
// if GetSide ( Delta ) = 2 and IsOk ( eng ) and not IsInUnit ( eng ) then
6122: LD_EXP 6
6126: PPUSH
6127: CALL_OW 255
6131: PUSH
6132: LD_INT 2
6134: EQUAL
6135: PUSH
6136: LD_VAR 0 5
6140: PPUSH
6141: CALL_OW 302
6145: AND
6146: PUSH
6147: LD_VAR 0 5
6151: PPUSH
6152: CALL_OW 310
6156: NOT
6157: AND
6158: IFFALSE 6174
// ComEnterUnit ( eng , Delta ) ;
6160: LD_VAR 0 5
6164: PPUSH
6165: LD_EXP 6
6169: PPUSH
6170: CALL_OW 120
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 ;
6174: LD_INT 22
6176: PUSH
6177: LD_INT 2
6179: PUSH
6180: EMPTY
6181: LIST
6182: LIST
6183: PUSH
6184: LD_INT 21
6186: PUSH
6187: LD_INT 1
6189: PUSH
6190: EMPTY
6191: LIST
6192: LIST
6193: PUSH
6194: EMPTY
6195: LIST
6196: LIST
6197: PPUSH
6198: CALL_OW 69
6202: PUSH
6203: LD_INT 0
6205: EQUAL
6206: IFFALSE 6109
// Wait ( 2 2$00 ) ;
6208: LD_INT 4200
6210: PPUSH
6211: CALL_OW 67
// ap_killers := PrepareArabianTroops ( [ 1 , 2 , 2 ] [ Difficulty ] , skill , arArea1 ) ;
6215: LD_ADDR_EXP 27
6219: PUSH
6220: LD_INT 1
6222: PUSH
6223: LD_INT 2
6225: PUSH
6226: LD_INT 2
6228: PUSH
6229: EMPTY
6230: LIST
6231: LIST
6232: LIST
6233: PUSH
6234: LD_OWVAR 67
6238: ARRAY
6239: PPUSH
6240: LD_VAR 0 4
6244: PPUSH
6245: LD_INT 13
6247: PPUSH
6248: CALL 5300 0 3
6252: ST_TO_ADDR
// Wait ( timer * 2 ) ;
6253: LD_VAR 0 2
6257: PUSH
6258: LD_INT 2
6260: MUL
6261: PPUSH
6262: CALL_OW 67
// ar_forces := PrepareArabianTroops ( [ 5 , 6 , 7 ] [ Difficulty ] , skill , arArea1 ) ^ PrepareArabianTroops ( [ 3 , 4 , 4 ] [ Difficulty ] , skill , arArea2 ) ;
6266: LD_ADDR_EXP 26
6270: PUSH
6271: LD_INT 5
6273: PUSH
6274: LD_INT 6
6276: PUSH
6277: LD_INT 7
6279: PUSH
6280: EMPTY
6281: LIST
6282: LIST
6283: LIST
6284: PUSH
6285: LD_OWVAR 67
6289: ARRAY
6290: PPUSH
6291: LD_VAR 0 4
6295: PPUSH
6296: LD_INT 13
6298: PPUSH
6299: CALL 5300 0 3
6303: PUSH
6304: LD_INT 3
6306: PUSH
6307: LD_INT 4
6309: PUSH
6310: LD_INT 4
6312: PUSH
6313: EMPTY
6314: LIST
6315: LIST
6316: LIST
6317: PUSH
6318: LD_OWVAR 67
6322: ARRAY
6323: PPUSH
6324: LD_VAR 0 4
6328: PPUSH
6329: LD_INT 14
6331: PPUSH
6332: CALL 5300 0 3
6336: ADD
6337: ST_TO_ADDR
// end ;
6338: PPOPN 8
6340: END
// every 0 0$03 trigger ar_forces do var i , target ;
6341: LD_EXP 26
6345: IFFALSE 6543
6347: GO 6349
6349: DISABLE
6350: LD_INT 0
6352: PPUSH
6353: PPUSH
// begin enable ;
6354: ENABLE
// if not ar_forces then
6355: LD_EXP 26
6359: NOT
6360: IFFALSE 6364
// exit ;
6362: GO 6543
// if Delta then
6364: LD_EXP 6
6368: IFFALSE 6382
// target := Delta else
6370: LD_ADDR_VAR 0 2
6374: PUSH
6375: LD_EXP 6
6379: ST_TO_ADDR
6380: GO 6392
// target := JMM ;
6382: LD_ADDR_VAR 0 2
6386: PUSH
6387: LD_EXP 15
6391: ST_TO_ADDR
// for i in ar_forces do
6392: LD_ADDR_VAR 0 1
6396: PUSH
6397: LD_EXP 26
6401: PUSH
6402: FOR_IN
6403: IFFALSE 6541
// begin if i in FilterAllUnits ( [ f_driving ] ) then
6405: LD_VAR 0 1
6409: PUSH
6410: LD_INT 55
6412: PUSH
6413: EMPTY
6414: LIST
6415: PPUSH
6416: CALL_OW 69
6420: IN
6421: IFFALSE 6464
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , IsInUnit ( i ) ) ) else
6423: LD_VAR 0 1
6427: PPUSH
6428: LD_INT 22
6430: PUSH
6431: LD_INT 1
6433: PUSH
6434: EMPTY
6435: LIST
6436: LIST
6437: PPUSH
6438: CALL_OW 69
6442: PPUSH
6443: LD_VAR 0 1
6447: PPUSH
6448: CALL_OW 310
6452: PPUSH
6453: CALL_OW 74
6457: PPUSH
6458: CALL_OW 115
6462: GO 6539
// if GetDistUnits ( i , target ) > 30 then
6464: LD_VAR 0 1
6468: PPUSH
6469: LD_VAR 0 2
6473: PPUSH
6474: CALL_OW 296
6478: PUSH
6479: LD_INT 30
6481: GREATER
6482: IFFALSE 6515
// ComAgressiveMove ( i , GetX ( target ) , GetY ( target ) ) else
6484: LD_VAR 0 1
6488: PPUSH
6489: LD_VAR 0 2
6493: PPUSH
6494: CALL_OW 250
6498: PPUSH
6499: LD_VAR 0 2
6503: PPUSH
6504: CALL_OW 251
6508: PPUSH
6509: CALL_OW 114
6513: GO 6539
// Attack ( i , FilterAllUnits ( [ f_enemy , 2 ] ) ) ;
6515: LD_VAR 0 1
6519: PPUSH
6520: LD_INT 81
6522: PUSH
6523: LD_INT 2
6525: PUSH
6526: EMPTY
6527: LIST
6528: LIST
6529: PPUSH
6530: CALL_OW 69
6534: PPUSH
6535: CALL 671 0 2
// end ;
6539: GO 6402
6541: POP
6542: POP
// end ;
6543: PPOPN 2
6545: END
// every 0 0$01 trigger ap_killers do var filter , i , target ;
6546: LD_EXP 27
6550: IFFALSE 6710
6552: GO 6554
6554: DISABLE
6555: LD_INT 0
6557: PPUSH
6558: PPUSH
6559: PPUSH
// begin enable ;
6560: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) ;
6561: LD_ADDR_VAR 0 1
6565: PUSH
6566: LD_INT 22
6568: PUSH
6569: LD_INT 0
6571: PUSH
6572: EMPTY
6573: LIST
6574: LIST
6575: PUSH
6576: LD_INT 25
6578: PUSH
6579: LD_INT 12
6581: PUSH
6582: EMPTY
6583: LIST
6584: LIST
6585: PUSH
6586: EMPTY
6587: LIST
6588: LIST
6589: PPUSH
6590: CALL_OW 69
6594: ST_TO_ADDR
// if not filter then
6595: LD_VAR 0 1
6599: NOT
6600: IFFALSE 6627
// begin ar_forces := ar_forces ^ ap_killers ;
6602: LD_ADDR_EXP 26
6606: PUSH
6607: LD_EXP 26
6611: PUSH
6612: LD_EXP 27
6616: ADD
6617: ST_TO_ADDR
// ap_killers := [ ] ;
6618: LD_ADDR_EXP 27
6622: PUSH
6623: EMPTY
6624: ST_TO_ADDR
// exit ;
6625: GO 6710
// end ; for i in ap_killers do
6627: LD_ADDR_VAR 0 2
6631: PUSH
6632: LD_EXP 27
6636: PUSH
6637: FOR_IN
6638: IFFALSE 6708
// begin if not IsOk ( i ) then
6640: LD_VAR 0 2
6644: PPUSH
6645: CALL_OW 302
6649: NOT
6650: IFFALSE 6654
// continue ;
6652: GO 6637
// if not HasTask ( i ) then
6654: LD_VAR 0 2
6658: PPUSH
6659: CALL_OW 314
6663: NOT
6664: IFFALSE 6686
// target := NearestUnitToUnit ( filter , i ) ;
6666: LD_ADDR_VAR 0 3
6670: PUSH
6671: LD_VAR 0 1
6675: PPUSH
6676: LD_VAR 0 2
6680: PPUSH
6681: CALL_OW 74
6685: ST_TO_ADDR
// if target then
6686: LD_VAR 0 3
6690: IFFALSE 6706
// ComAttackUnit ( i , target ) ;
6692: LD_VAR 0 2
6696: PPUSH
6697: LD_VAR 0 3
6701: PPUSH
6702: CALL_OW 115
// end ;
6706: GO 6637
6708: POP
6709: POP
// end ; end_of_file
6710: PPOPN 3
6712: END
// every 0 0$40 + 0 0$2 trigger Delta do var i , counter , cr ;
6713: LD_EXP 6
6717: IFFALSE 6849
6719: GO 6721
6721: DISABLE
6722: LD_INT 0
6724: PPUSH
6725: PPUSH
6726: PPUSH
// begin counter := [ 300 , 250 , 220 ] [ Difficulty ] ;
6727: LD_ADDR_VAR 0 2
6731: PUSH
6732: LD_INT 300
6734: PUSH
6735: LD_INT 250
6737: PUSH
6738: LD_INT 220
6740: PUSH
6741: EMPTY
6742: LIST
6743: LIST
6744: LIST
6745: PUSH
6746: LD_OWVAR 67
6750: ARRAY
6751: ST_TO_ADDR
// CreateCratesArea ( Rand ( 1 , 3 ) , cratesArea , true ) ;
6752: LD_INT 1
6754: PPUSH
6755: LD_INT 3
6757: PPUSH
6758: CALL_OW 12
6762: PPUSH
6763: LD_INT 7
6765: PPUSH
6766: LD_INT 1
6768: PPUSH
6769: CALL_OW 55
// repeat wait ( rand ( 1 1$30 , 2 2$20 ) ) ;
6773: LD_INT 3150
6775: PPUSH
6776: LD_INT 4900
6778: PPUSH
6779: CALL_OW 12
6783: PPUSH
6784: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
6788: LD_ADDR_VAR 0 3
6792: PUSH
6793: LD_INT 1
6795: PPUSH
6796: LD_INT 5
6798: PPUSH
6799: CALL_OW 12
6803: ST_TO_ADDR
// CreateCratesArea ( cr , cratesArea , true ) ;
6804: LD_VAR 0 3
6808: PPUSH
6809: LD_INT 7
6811: PPUSH
6812: LD_INT 1
6814: PPUSH
6815: CALL_OW 55
// counter := counter - cr * 10 ;
6819: LD_ADDR_VAR 0 2
6823: PUSH
6824: LD_VAR 0 2
6828: PUSH
6829: LD_VAR 0 3
6833: PUSH
6834: LD_INT 10
6836: MUL
6837: MINUS
6838: ST_TO_ADDR
// until counter <= 0 ;
6839: LD_VAR 0 2
6843: PUSH
6844: LD_INT 0
6846: LESSEQUAL
6847: IFFALSE 6773
// end ;
6849: PPOPN 3
6851: END
// every 0 0$03 trigger not Delta do var i ;
6852: LD_EXP 6
6856: NOT
6857: IFFALSE 6927
6859: GO 6861
6861: DISABLE
6862: LD_INT 0
6864: PPUSH
// begin for i = 1 to 4 - Difficulty do
6865: LD_ADDR_VAR 0 1
6869: PUSH
6870: DOUBLE
6871: LD_INT 1
6873: DEC
6874: ST_TO_ADDR
6875: LD_INT 4
6877: PUSH
6878: LD_OWVAR 67
6882: MINUS
6883: PUSH
6884: FOR_TO
6885: IFFALSE 6925
// begin CreateCratesArea ( rand ( 2 , 5 ) , deltaMainArea , true ) ;
6887: LD_INT 2
6889: PPUSH
6890: LD_INT 5
6892: PPUSH
6893: CALL_OW 12
6897: PPUSH
6898: LD_INT 8
6900: PPUSH
6901: LD_INT 1
6903: PPUSH
6904: CALL_OW 55
// Wait ( rand ( 0 0$16 , 0 0$39 ) ) ;
6908: LD_INT 560
6910: PPUSH
6911: LD_INT 1365
6913: PPUSH
6914: CALL_OW 12
6918: PPUSH
6919: CALL_OW 67
// end ;
6923: GO 6884
6925: POP
6926: POP
// end ;
6927: PPOPN 1
6929: END
// every 3 3$00 trigger tick < 15 15$00 do
6930: LD_OWVAR 1
6934: PUSH
6935: LD_INT 31500
6937: LESS
6938: IFFALSE 6998
6940: GO 6942
6942: DISABLE
// begin enable ;
6943: ENABLE
// CreateCratesAnyWhere ( rand ( 1 , 3 ) , true ) ;
6944: LD_INT 1
6946: PPUSH
6947: LD_INT 3
6949: PPUSH
6950: CALL_OW 12
6954: PPUSH
6955: LD_INT 1
6957: PPUSH
6958: CALL_OW 57
// Wait ( rand ( 0 0$38 , 0 0$59 ) ) ;
6962: LD_INT 1330
6964: PPUSH
6965: LD_INT 2065
6967: PPUSH
6968: CALL_OW 12
6972: PPUSH
6973: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 4 ) , riverArea , true ) ;
6977: LD_INT 1
6979: PPUSH
6980: LD_INT 4
6982: PPUSH
6983: CALL_OW 12
6987: PPUSH
6988: LD_INT 15
6990: PPUSH
6991: LD_INT 1
6993: PPUSH
6994: CALL_OW 55
// end ; end_of_file
6998: END
// on UnitDestroyed ( un ) do begin if un = JMM then
6999: LD_VAR 0 1
7003: PUSH
7004: LD_EXP 15
7008: EQUAL
7009: IFFALSE 7018
// YouLost ( JMM ) ;
7011: LD_STRING JMM
7013: PPUSH
7014: CALL_OW 104
// if un = Delta then
7018: LD_VAR 0 1
7022: PUSH
7023: LD_EXP 6
7027: EQUAL
7028: IFFALSE 7051
// begin Delta := 0 ;
7030: LD_ADDR_EXP 6
7034: PUSH
7035: LD_INT 0
7037: ST_TO_ADDR
// SetRestrict ( b_depot , 1 , true ) ;
7038: LD_INT 0
7040: PPUSH
7041: LD_INT 1
7043: PPUSH
7044: LD_INT 1
7046: PPUSH
7047: CALL_OW 324
// end ; if un in ar_forces then
7051: LD_VAR 0 1
7055: PUSH
7056: LD_EXP 26
7060: IN
7061: IFFALSE 7079
// ar_forces := ar_forces diff un ;
7063: LD_ADDR_EXP 26
7067: PUSH
7068: LD_EXP 26
7072: PUSH
7073: LD_VAR 0 1
7077: DIFF
7078: ST_TO_ADDR
// if un in ap_killers then
7079: LD_VAR 0 1
7083: PUSH
7084: LD_EXP 27
7088: IN
7089: IFFALSE 7107
// ap_killers := ap_killers diff un ;
7091: LD_ADDR_EXP 27
7095: PUSH
7096: LD_EXP 27
7100: PUSH
7101: LD_VAR 0 1
7105: DIFF
7106: ST_TO_ADDR
// end ;
7107: PPOPN 1
7109: END
// on Contact ( s1 , s2 ) do if s1 = 1 and s2 = 2 and not arab_spotted then
7110: LD_VAR 0 1
7114: PUSH
7115: LD_INT 1
7117: EQUAL
7118: PUSH
7119: LD_VAR 0 2
7123: PUSH
7124: LD_INT 2
7126: EQUAL
7127: AND
7128: PUSH
7129: LD_EXP 13
7133: NOT
7134: AND
7135: IFFALSE 7145
// arab_spotted := true ;
7137: LD_ADDR_EXP 13
7141: PUSH
7142: LD_INT 1
7144: ST_TO_ADDR
7145: PPOPN 2
7147: END
// on EndTheMissionRaised ( p ) do begin end_the_mission_allowed := false ;
7148: LD_ADDR_OWVAR 57
7152: PUSH
7153: LD_INT 0
7155: ST_TO_ADDR
// end_mission := true ;
7156: LD_ADDR_EXP 14
7160: PUSH
7161: LD_INT 1
7163: ST_TO_ADDR
// end ;
7164: PPOPN 1
7166: END
// on ApemanTamed ( apeman , sci ) do begin if GetSide ( sci ) = 1 then
7167: LD_VAR 0 2
7171: PPUSH
7172: CALL_OW 255
7176: PUSH
7177: LD_INT 1
7179: EQUAL
7180: IFFALSE 7196
// apeman_counter := apeman_counter + 1 ;
7182: LD_ADDR_EXP 12
7186: PUSH
7187: LD_EXP 12
7191: PUSH
7192: LD_INT 1
7194: PLUS
7195: ST_TO_ADDR
// if not first_apeman_tamed then
7196: LD_EXP 8
7200: NOT
7201: IFFALSE 7401
// begin first_apeman_tamed := true ;
7203: LD_ADDR_EXP 8
7207: PUSH
7208: LD_INT 1
7210: ST_TO_ADDR
// if sci = Gladstone then
7211: LD_VAR 0 2
7215: PUSH
7216: LD_EXP 16
7220: EQUAL
7221: IFFALSE 7235
// Say ( Gladstone , D7b-Glad-1 ) ;
7223: LD_EXP 16
7227: PPUSH
7228: LD_STRING D7b-Glad-1
7230: PPUSH
7231: CALL_OW 88
// if sci = Denis then
7235: LD_VAR 0 2
7239: PUSH
7240: LD_EXP 18
7244: EQUAL
7245: IFFALSE 7259
// Say ( Denis , D7a-Den-1 ) ;
7247: LD_EXP 18
7251: PPUSH
7252: LD_STRING D7a-Den-1
7254: PPUSH
7255: CALL_OW 88
// if not sci in [ JMM , Gladstone , Denis , Lisa , Frank , Bobby , Cyrus , Donaldson ] then
7259: LD_VAR 0 2
7263: PUSH
7264: LD_EXP 15
7268: PUSH
7269: LD_EXP 16
7273: PUSH
7274: LD_EXP 18
7278: PUSH
7279: LD_EXP 21
7283: PUSH
7284: LD_EXP 22
7288: PUSH
7289: LD_EXP 23
7293: PUSH
7294: LD_EXP 24
7298: PUSH
7299: LD_EXP 20
7303: PUSH
7304: EMPTY
7305: LIST
7306: LIST
7307: LIST
7308: LIST
7309: LIST
7310: LIST
7311: LIST
7312: LIST
7313: IN
7314: NOT
7315: IFFALSE 7358
// begin if GetSex ( sci ) = sex_male then
7317: LD_VAR 0 2
7321: PPUSH
7322: CALL_OW 258
7326: PUSH
7327: LD_INT 1
7329: EQUAL
7330: IFFALSE 7346
// Say ( sci , D7c-Sci1-1 ) else
7332: LD_VAR 0 2
7336: PPUSH
7337: LD_STRING D7c-Sci1-1
7339: PPUSH
7340: CALL_OW 88
7344: GO 7358
// Say ( sci , D7c-FSci1-1 ) ;
7346: LD_VAR 0 2
7350: PPUSH
7351: LD_STRING D7c-FSci1-1
7353: PPUSH
7354: CALL_OW 88
// end ; if not sci = Gladstone then
7358: LD_VAR 0 2
7362: PUSH
7363: LD_EXP 16
7367: EQUAL
7368: NOT
7369: IFFALSE 7383
// Say ( Gladstone , D7c-Glad-1 ) ;
7371: LD_EXP 16
7375: PPUSH
7376: LD_STRING D7c-Glad-1
7378: PPUSH
7379: CALL_OW 88
// if Lisa then
7383: LD_EXP 21
7387: IFFALSE 7401
// Say ( Lisa , D8-Lisa-1 ) ;
7389: LD_EXP 21
7393: PPUSH
7394: LD_STRING D8-Lisa-1
7396: PPUSH
7397: CALL_OW 88
// end ; end ;
7401: PPOPN 2
7403: END
