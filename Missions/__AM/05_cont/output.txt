// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// Init ;
  15: CALL 79 0 0
// InitRestrictions ;
  19: CALL 207 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 33
// DebugMode ;
  29: CALL 288 0 0
// SpawnApeman ( apemanStartArea , 2 ) ;
  33: LD_INT 12
  35: PPUSH
  36: LD_INT 2
  38: PPUSH
  39: CALL 658 0 2
// SpawnApeman ( apemanArea , [ 10 , 8 , 7 ] [ Difficulty ] ) ;
  43: LD_INT 11
  45: PPUSH
  46: LD_INT 10
  48: PUSH
  49: LD_INT 8
  51: PUSH
  52: LD_INT 7
  54: PUSH
  55: EMPTY
  56: LIST
  57: LIST
  58: LIST
  59: PUSH
  60: LD_OWVAR 67
  64: ARRAY
  65: PPUSH
  66: CALL 658 0 2
// PrepareAmericans ;
  70: CALL 1257 0 0
// Action ;
  74: CALL 2147 0 0
// end ;
  78: END
// export debug ; export mission_prefix , mission_prefix_prev ; export deltaBuilded , denisArrives , Delta , radar_allowed , first_apeman_tamed , apeman_army , radar_researched , radar_builded ; export apeman_counter , arab_spotted , end_mission , apeKillCounter ; function Init ; begin
  79: LD_INT 0
  81: PPUSH
// debug := false ;
  82: LD_ADDR_EXP 1
  86: PUSH
  87: LD_INT 0
  89: ST_TO_ADDR
// mission_prefix := 05_ ;
  90: LD_ADDR_EXP 2
  94: PUSH
  95: LD_STRING 05_
  97: ST_TO_ADDR
// mission_prefix_prev := 05a_ ;
  98: LD_ADDR_EXP 3
 102: PUSH
 103: LD_STRING 05a_
 105: ST_TO_ADDR
// deltaBuilded := false ;
 106: LD_ADDR_EXP 4
 110: PUSH
 111: LD_INT 0
 113: ST_TO_ADDR
// denisArrives := false ;
 114: LD_ADDR_EXP 5
 118: PUSH
 119: LD_INT 0
 121: ST_TO_ADDR
// radar_allowed := false ;
 122: LD_ADDR_EXP 7
 126: PUSH
 127: LD_INT 0
 129: ST_TO_ADDR
// first_apeman_tamed := false ;
 130: LD_ADDR_EXP 8
 134: PUSH
 135: LD_INT 0
 137: ST_TO_ADDR
// arab_spotted := false ;
 138: LD_ADDR_EXP 13
 142: PUSH
 143: LD_INT 0
 145: ST_TO_ADDR
// end_mission := false ;
 146: LD_ADDR_EXP 14
 150: PUSH
 151: LD_INT 0
 153: ST_TO_ADDR
// apeman_army := false ;
 154: LD_ADDR_EXP 9
 158: PUSH
 159: LD_INT 0
 161: ST_TO_ADDR
// radar_researched := false ;
 162: LD_ADDR_EXP 10
 166: PUSH
 167: LD_INT 0
 169: ST_TO_ADDR
// radar_builded := false ;
 170: LD_ADDR_EXP 11
 174: PUSH
 175: LD_INT 0
 177: ST_TO_ADDR
// apeman_counter := 0 ;
 178: LD_ADDR_EXP 12
 182: PUSH
 183: LD_INT 0
 185: ST_TO_ADDR
// Delta := 0 ;
 186: LD_ADDR_EXP 6
 190: PUSH
 191: LD_INT 0
 193: ST_TO_ADDR
// apeKillCounter := 0 ;
 194: LD_ADDR_EXP 15
 198: PUSH
 199: LD_INT 0
 201: ST_TO_ADDR
// end ;
 202: LD_VAR 0 1
 206: RET
// function InitRestrictions ; begin
 207: LD_INT 0
 209: PPUSH
// SetRestrict ( b_lab_half , 1 , state_enabled ) ;
 210: LD_INT 7
 212: PPUSH
 213: LD_INT 1
 215: PPUSH
 216: LD_INT 1
 218: PPUSH
 219: CALL_OW 324
// SetRestrict ( b_lab_full , 1 , state_enabled ) ;
 223: LD_INT 8
 225: PPUSH
 226: LD_INT 1
 228: PPUSH
 229: LD_INT 1
 231: PPUSH
 232: CALL_OW 324
// SetRestrict ( b_lab_weapon , 1 , state_enabled ) ;
 236: LD_INT 10
 238: PPUSH
 239: LD_INT 1
 241: PPUSH
 242: LD_INT 1
 244: PPUSH
 245: CALL_OW 324
// SetTech ( tech_gatling , 1 , LoadVariable ( GatlingInGamma , 1 ) ) ;
 249: LD_INT 69
 251: PPUSH
 252: LD_INT 1
 254: PPUSH
 255: LD_STRING GatlingInGamma
 257: PPUSH
 258: LD_INT 1
 260: PPUSH
 261: CALL_OW 30
 265: PPUSH
 266: CALL_OW 322
// SetTech ( tech_weap1 , 1 , state_enabled ) ;
 270: LD_INT 51
 272: PPUSH
 273: LD_INT 1
 275: PPUSH
 276: LD_INT 1
 278: PPUSH
 279: CALL_OW 322
// end ;
 283: LD_VAR 0 1
 287: RET
// function DebugMode ; begin
 288: LD_INT 0
 290: PPUSH
// FogOff ( 1 ) ;
 291: LD_INT 1
 293: PPUSH
 294: CALL_OW 344
// Difficulty := 2 ;
 298: LD_ADDR_OWVAR 67
 302: PUSH
 303: LD_INT 2
 305: ST_TO_ADDR
// end ;
 306: LD_VAR 0 1
 310: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 0 ] ] ) >= 7 do
 311: LD_INT 22
 313: PUSH
 314: LD_INT 1
 316: PUSH
 317: EMPTY
 318: LIST
 319: LIST
 320: PUSH
 321: LD_INT 23
 323: PUSH
 324: LD_INT 0
 326: PUSH
 327: EMPTY
 328: LIST
 329: LIST
 330: PUSH
 331: EMPTY
 332: LIST
 333: LIST
 334: PPUSH
 335: CALL_OW 69
 339: PUSH
 340: LD_INT 7
 342: GREATEREQUAL
 343: IFFALSE 355
 345: GO 347
 347: DISABLE
// SetAchievement ( ACH_TAME ) ;
 348: LD_STRING ACH_TAME
 350: PPUSH
 351: CALL_OW 543
 355: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_bweapon , us_radar ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) do
 356: LD_INT 22
 358: PUSH
 359: LD_INT 1
 361: PUSH
 362: EMPTY
 363: LIST
 364: LIST
 365: PUSH
 366: LD_INT 35
 368: PUSH
 369: LD_INT 11
 371: PUSH
 372: EMPTY
 373: LIST
 374: LIST
 375: PUSH
 376: EMPTY
 377: LIST
 378: LIST
 379: PPUSH
 380: CALL_OW 69
 384: PUSH
 385: LD_INT 22
 387: PUSH
 388: LD_INT 1
 390: PUSH
 391: EMPTY
 392: LIST
 393: LIST
 394: PUSH
 395: LD_INT 34
 397: PUSH
 398: LD_INT 11
 400: PUSH
 401: EMPTY
 402: LIST
 403: LIST
 404: PUSH
 405: EMPTY
 406: LIST
 407: LIST
 408: PPUSH
 409: CALL_OW 69
 413: AND
 414: IFFALSE 426
 416: GO 418
 418: DISABLE
// SetAchievement ( ACH_RADAR ) ; end_of_file
 419: LD_STRING ACH_RADAR
 421: PPUSH
 422: CALL_OW 543
 426: END
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 427: LD_INT 0
 429: PPUSH
 430: PPUSH
// if exist_mode then
 431: LD_VAR 0 2
 435: IFFALSE 460
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 437: LD_ADDR_VAR 0 4
 441: PUSH
 442: LD_EXP 3
 446: PUSH
 447: LD_VAR 0 1
 451: STR
 452: PPUSH
 453: CALL_OW 34
 457: ST_TO_ADDR
 458: GO 475
// unit := NewCharacter ( ident ) ;
 460: LD_ADDR_VAR 0 4
 464: PUSH
 465: LD_VAR 0 1
 469: PPUSH
 470: CALL_OW 25
 474: ST_TO_ADDR
// result := unit ;
 475: LD_ADDR_VAR 0 3
 479: PUSH
 480: LD_VAR 0 4
 484: ST_TO_ADDR
// end ;
 485: LD_VAR 0 3
 489: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 490: LD_INT 0
 492: PPUSH
// uc_side := side ;
 493: LD_ADDR_OWVAR 20
 497: PUSH
 498: LD_VAR 0 1
 502: ST_TO_ADDR
// uc_nation := nation ;
 503: LD_ADDR_OWVAR 21
 507: PUSH
 508: LD_VAR 0 2
 512: ST_TO_ADDR
// vc_chassis := chassis ;
 513: LD_ADDR_OWVAR 37
 517: PUSH
 518: LD_VAR 0 3
 522: ST_TO_ADDR
// vc_engine := engine ;
 523: LD_ADDR_OWVAR 39
 527: PUSH
 528: LD_VAR 0 4
 532: ST_TO_ADDR
// vc_control := control ;
 533: LD_ADDR_OWVAR 38
 537: PUSH
 538: LD_VAR 0 5
 542: ST_TO_ADDR
// vc_weapon := weapon ;
 543: LD_ADDR_OWVAR 40
 547: PUSH
 548: LD_VAR 0 6
 552: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 553: LD_ADDR_OWVAR 41
 557: PUSH
 558: LD_VAR 0 7
 562: ST_TO_ADDR
// result := CreateVehicle ;
 563: LD_ADDR_VAR 0 8
 567: PUSH
 568: CALL_OW 45
 572: ST_TO_ADDR
// end ;
 573: LD_VAR 0 8
 577: RET
// export function SayX ( units , ident ) ; var i ; begin
 578: LD_INT 0
 580: PPUSH
 581: PPUSH
// result := false ;
 582: LD_ADDR_VAR 0 3
 586: PUSH
 587: LD_INT 0
 589: ST_TO_ADDR
// if not units then
 590: LD_VAR 0 1
 594: NOT
 595: IFFALSE 599
// exit ;
 597: GO 653
// for i in units do
 599: LD_ADDR_VAR 0 4
 603: PUSH
 604: LD_VAR 0 1
 608: PUSH
 609: FOR_IN
 610: IFFALSE 651
// if IsOk ( i ) then
 612: LD_VAR 0 4
 616: PPUSH
 617: CALL_OW 302
 621: IFFALSE 649
// begin Say ( i , ident ) ;
 623: LD_VAR 0 4
 627: PPUSH
 628: LD_VAR 0 2
 632: PPUSH
 633: CALL_OW 88
// result := i ;
 637: LD_ADDR_VAR 0 3
 641: PUSH
 642: LD_VAR 0 4
 646: ST_TO_ADDR
// break ;
 647: GO 651
// end ;
 649: GO 609
 651: POP
 652: POP
// end ;
 653: LD_VAR 0 3
 657: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 658: LD_INT 0
 660: PPUSH
 661: PPUSH
// InitUc ;
 662: CALL_OW 18
// InitHc ;
 666: CALL_OW 19
// uc_side := 0 ;
 670: LD_ADDR_OWVAR 20
 674: PUSH
 675: LD_INT 0
 677: ST_TO_ADDR
// uc_nation := 0 ;
 678: LD_ADDR_OWVAR 21
 682: PUSH
 683: LD_INT 0
 685: ST_TO_ADDR
// for i = 1 to amount do
 686: LD_ADDR_VAR 0 4
 690: PUSH
 691: DOUBLE
 692: LD_INT 1
 694: DEC
 695: ST_TO_ADDR
 696: LD_VAR 0 2
 700: PUSH
 701: FOR_TO
 702: IFFALSE 784
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 704: LD_ADDR_OWVAR 29
 708: PUSH
 709: LD_INT 9
 711: PPUSH
 712: LD_INT 12
 714: PPUSH
 715: CALL_OW 12
 719: PUSH
 720: LD_INT 9
 722: PPUSH
 723: LD_INT 12
 725: PPUSH
 726: CALL_OW 12
 730: PUSH
 731: EMPTY
 732: LIST
 733: LIST
 734: ST_TO_ADDR
// hc_agressivity := rand ( - 5 , 5 ) ;
 735: LD_ADDR_OWVAR 35
 739: PUSH
 740: LD_INT 5
 742: NEG
 743: PPUSH
 744: LD_INT 5
 746: PPUSH
 747: CALL_OW 12
 751: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 752: LD_INT 0
 754: PPUSH
 755: LD_INT 12
 757: PPUSH
 758: LD_INT 1
 760: PPUSH
 761: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 765: CALL_OW 44
 769: PPUSH
 770: LD_VAR 0 1
 774: PPUSH
 775: LD_INT 0
 777: PPUSH
 778: CALL_OW 49
// end ;
 782: GO 701
 784: POP
 785: POP
// InitHc ;
 786: CALL_OW 19
// end ;
 790: LD_VAR 0 3
 794: RET
// export function Attack ( unit , enemy_list ) ; var target , targets_list ; begin
 795: LD_INT 0
 797: PPUSH
 798: PPUSH
 799: PPUSH
// if not unit then
 800: LD_VAR 0 1
 804: NOT
 805: IFFALSE 809
// exit ;
 807: GO 1252
// if IsInUnit ( unit ) then
 809: LD_VAR 0 1
 813: PPUSH
 814: CALL_OW 310
 818: IFFALSE 835
// unit := IsDrivenBy ( unit ) ;
 820: LD_ADDR_VAR 0 1
 824: PUSH
 825: LD_VAR 0 1
 829: PPUSH
 830: CALL_OW 311
 834: ST_TO_ADDR
// targets_list := [ ] ;
 835: LD_ADDR_VAR 0 5
 839: PUSH
 840: EMPTY
 841: ST_TO_ADDR
// target := UnitFilter ( enemy_list , [ [ f_lives , 250 ] , [ f_not , [ f_weapon , us_cargo_bay ] ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
 842: LD_ADDR_VAR 0 4
 846: PUSH
 847: LD_VAR 0 2
 851: PPUSH
 852: LD_INT 24
 854: PUSH
 855: LD_INT 250
 857: PUSH
 858: EMPTY
 859: LIST
 860: LIST
 861: PUSH
 862: LD_INT 3
 864: PUSH
 865: LD_INT 34
 867: PUSH
 868: LD_INT 12
 870: PUSH
 871: EMPTY
 872: LIST
 873: LIST
 874: PUSH
 875: EMPTY
 876: LIST
 877: LIST
 878: PUSH
 879: LD_INT 21
 881: PUSH
 882: LD_INT 2
 884: PUSH
 885: EMPTY
 886: LIST
 887: LIST
 888: PUSH
 889: LD_INT 58
 891: PUSH
 892: EMPTY
 893: LIST
 894: PUSH
 895: EMPTY
 896: LIST
 897: LIST
 898: LIST
 899: LIST
 900: PPUSH
 901: CALL_OW 72
 905: ST_TO_ADDR
// if GetDistUnits ( NearestUnitToUnit ( target , unit ) , unit ) < 11 and not IsInUnit ( unit ) then
 906: LD_VAR 0 4
 910: PPUSH
 911: LD_VAR 0 1
 915: PPUSH
 916: CALL_OW 74
 920: PPUSH
 921: LD_VAR 0 1
 925: PPUSH
 926: CALL_OW 296
 930: PUSH
 931: LD_INT 11
 933: LESS
 934: PUSH
 935: LD_VAR 0 1
 939: PPUSH
 940: CALL_OW 310
 944: NOT
 945: AND
 946: IFFALSE 974
// begin ComEnterUnit ( unit , NearestUnitToUnit ( target , unit ) ) ;
 948: LD_VAR 0 1
 952: PPUSH
 953: LD_VAR 0 4
 957: PPUSH
 958: LD_VAR 0 1
 962: PPUSH
 963: CALL_OW 74
 967: PPUSH
 968: CALL_OW 120
// exit ;
 972: GO 1252
// end ; targets_list := [ UnitFilter ( enemy_list , [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] ] ) , UnitFilter ( enemy_list , [ f_type , unit_vehicle ] ) , UnitFilter ( enemy_list , [ [ f_type , unit_building ] , [ f_not , [ f_empty ] ] ] ) , enemy_list ] ;
 974: LD_ADDR_VAR 0 5
 978: PUSH
 979: LD_VAR 0 2
 983: PPUSH
 984: LD_INT 21
 986: PUSH
 987: LD_INT 1
 989: PUSH
 990: EMPTY
 991: LIST
 992: LIST
 993: PUSH
 994: LD_INT 3
 996: PUSH
 997: LD_INT 54
 999: PUSH
1000: EMPTY
1001: LIST
1002: PUSH
1003: EMPTY
1004: LIST
1005: LIST
1006: PUSH
1007: EMPTY
1008: LIST
1009: LIST
1010: PPUSH
1011: CALL_OW 72
1015: PUSH
1016: LD_VAR 0 2
1020: PPUSH
1021: LD_INT 21
1023: PUSH
1024: LD_INT 2
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: PPUSH
1031: CALL_OW 72
1035: PUSH
1036: LD_VAR 0 2
1040: PPUSH
1041: LD_INT 21
1043: PUSH
1044: LD_INT 3
1046: PUSH
1047: EMPTY
1048: LIST
1049: LIST
1050: PUSH
1051: LD_INT 3
1053: PUSH
1054: LD_INT 58
1056: PUSH
1057: EMPTY
1058: LIST
1059: PUSH
1060: EMPTY
1061: LIST
1062: LIST
1063: PUSH
1064: EMPTY
1065: LIST
1066: LIST
1067: PPUSH
1068: CALL_OW 72
1072: PUSH
1073: LD_VAR 0 2
1077: PUSH
1078: EMPTY
1079: LIST
1080: LIST
1081: LIST
1082: LIST
1083: ST_TO_ADDR
// for target in targets_list do
1084: LD_ADDR_VAR 0 4
1088: PUSH
1089: LD_VAR 0 5
1093: PUSH
1094: FOR_IN
1095: IFFALSE 1250
// begin if target then
1097: LD_VAR 0 4
1101: IFFALSE 1248
// if GetTag ( unit ) = 11 and ( GetType ( NearestUnitToUnit ( target , unit ) ) = unit_building or GetWeapon ( NearestUnitToUnit ( target , unit ) ) = us_cargo_bay ) then
1103: LD_VAR 0 1
1107: PPUSH
1108: CALL_OW 110
1112: PUSH
1113: LD_INT 11
1115: EQUAL
1116: PUSH
1117: LD_VAR 0 4
1121: PPUSH
1122: LD_VAR 0 1
1126: PPUSH
1127: CALL_OW 74
1131: PPUSH
1132: CALL_OW 247
1136: PUSH
1137: LD_INT 3
1139: EQUAL
1140: PUSH
1141: LD_VAR 0 4
1145: PPUSH
1146: LD_VAR 0 1
1150: PPUSH
1151: CALL_OW 74
1155: PPUSH
1156: CALL_OW 264
1160: PUSH
1161: LD_INT 12
1163: EQUAL
1164: OR
1165: AND
1166: IFFALSE 1212
// begin ComPlaceDelayedCharge ( unit , 0 , 0 , NearestUnitToUnit ( target , unit ) ) ;
1168: LD_VAR 0 1
1172: PPUSH
1173: LD_INT 0
1175: PPUSH
1176: LD_INT 0
1178: PPUSH
1179: LD_VAR 0 4
1183: PPUSH
1184: LD_VAR 0 1
1188: PPUSH
1189: CALL_OW 74
1193: PPUSH
1194: CALL_OW 132
// SetTag ( unit , 0 ) ;
1198: LD_VAR 0 1
1202: PPUSH
1203: LD_INT 0
1205: PPUSH
1206: CALL_OW 109
// end else
1210: GO 1248
// if not HasTask ( unit ) then
1212: LD_VAR 0 1
1216: PPUSH
1217: CALL_OW 314
1221: NOT
1222: IFFALSE 1248
// ComAttackUnit ( unit , NearestUnitToUnit ( target , unit ) ) ;
1224: LD_VAR 0 1
1228: PPUSH
1229: LD_VAR 0 4
1233: PPUSH
1234: LD_VAR 0 1
1238: PPUSH
1239: CALL_OW 74
1243: PPUSH
1244: CALL_OW 115
// end ;
1248: GO 1094
1250: POP
1251: POP
// end ; end_of_file
1252: LD_VAR 0 3
1256: RET
// export JMM , Gladstone , Harrison , Denis , Brown , Donaldson , Lisa , Frank , Bobby , Cyrus ; export others ; export function PrepareAmericans ; var i , points , veh , tmp ; begin
1257: LD_INT 0
1259: PPUSH
1260: PPUSH
1261: PPUSH
1262: PPUSH
1263: PPUSH
// uc_nation := 1 ;
1264: LD_ADDR_OWVAR 21
1268: PUSH
1269: LD_INT 1
1271: ST_TO_ADDR
// uc_side := 4 ;
1272: LD_ADDR_OWVAR 20
1276: PUSH
1277: LD_INT 4
1279: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , false ) ;
1280: LD_ADDR_EXP 19
1284: PUSH
1285: LD_STRING Denis
1287: PPUSH
1288: LD_INT 0
1290: PPUSH
1291: CALL 427 0 2
1295: ST_TO_ADDR
// Harrison := PrepareUnit ( Harisson , false ) ;
1296: LD_ADDR_EXP 18
1300: PUSH
1301: LD_STRING Harisson
1303: PPUSH
1304: LD_INT 0
1306: PPUSH
1307: CALL 427 0 2
1311: ST_TO_ADDR
// uc_side := 1 ;
1312: LD_ADDR_OWVAR 20
1316: PUSH
1317: LD_INT 1
1319: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1320: LD_ADDR_EXP 16
1324: PUSH
1325: LD_STRING JMM
1327: PPUSH
1328: LD_EXP 1
1332: NOT
1333: PPUSH
1334: CALL 427 0 2
1338: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , false ) ;
1339: LD_ADDR_EXP 17
1343: PUSH
1344: LD_STRING Gladstone
1346: PPUSH
1347: LD_INT 0
1349: PPUSH
1350: CALL 427 0 2
1354: ST_TO_ADDR
// if LoadVariable ( BrownInDelta , debug ) then
1355: LD_STRING BrownInDelta
1357: PPUSH
1358: LD_EXP 1
1362: PPUSH
1363: CALL_OW 30
1367: IFFALSE 1404
// begin Brown := PrepareUnit ( Brown , ( not debug ) ) ;
1369: LD_ADDR_EXP 20
1373: PUSH
1374: LD_STRING Brown
1376: PPUSH
1377: LD_EXP 1
1381: NOT
1382: PPUSH
1383: CALL 427 0 2
1387: ST_TO_ADDR
// tmp := tmp ^ Brown ;
1388: LD_ADDR_VAR 0 5
1392: PUSH
1393: LD_VAR 0 5
1397: PUSH
1398: LD_EXP 20
1402: ADD
1403: ST_TO_ADDR
// end ; if LoadVariable ( DonaldsonInDelta , debug ) then
1404: LD_STRING DonaldsonInDelta
1406: PPUSH
1407: LD_EXP 1
1411: PPUSH
1412: CALL_OW 30
1416: IFFALSE 1453
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
1418: LD_ADDR_EXP 21
1422: PUSH
1423: LD_STRING Donaldson
1425: PPUSH
1426: LD_EXP 1
1430: NOT
1431: PPUSH
1432: CALL 427 0 2
1436: ST_TO_ADDR
// tmp := tmp ^ Donaldson ;
1437: LD_ADDR_VAR 0 5
1441: PUSH
1442: LD_VAR 0 5
1446: PUSH
1447: LD_EXP 21
1451: ADD
1452: ST_TO_ADDR
// end ; if LoadVariable ( LisaInDelta , debug ) then
1453: LD_STRING LisaInDelta
1455: PPUSH
1456: LD_EXP 1
1460: PPUSH
1461: CALL_OW 30
1465: IFFALSE 1502
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1467: LD_ADDR_EXP 22
1471: PUSH
1472: LD_STRING Lisa
1474: PPUSH
1475: LD_EXP 1
1479: NOT
1480: PPUSH
1481: CALL 427 0 2
1485: ST_TO_ADDR
// tmp := tmp ^ Lisa ;
1486: LD_ADDR_VAR 0 5
1490: PUSH
1491: LD_VAR 0 5
1495: PUSH
1496: LD_EXP 22
1500: ADD
1501: ST_TO_ADDR
// end ; if LoadVariable ( FrankInDelta , debug ) then
1502: LD_STRING FrankInDelta
1504: PPUSH
1505: LD_EXP 1
1509: PPUSH
1510: CALL_OW 30
1514: IFFALSE 1551
// begin Frank := PrepareUnit ( Frank , ( not debug ) ) ;
1516: LD_ADDR_EXP 23
1520: PUSH
1521: LD_STRING Frank
1523: PPUSH
1524: LD_EXP 1
1528: NOT
1529: PPUSH
1530: CALL 427 0 2
1534: ST_TO_ADDR
// tmp := tmp ^ Frank ;
1535: LD_ADDR_VAR 0 5
1539: PUSH
1540: LD_VAR 0 5
1544: PUSH
1545: LD_EXP 23
1549: ADD
1550: ST_TO_ADDR
// end ; if LoadVariable ( BobbyInDelta , 0 ) then
1551: LD_STRING BobbyInDelta
1553: PPUSH
1554: LD_INT 0
1556: PPUSH
1557: CALL_OW 30
1561: IFFALSE 1598
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1563: LD_ADDR_EXP 24
1567: PUSH
1568: LD_STRING Bobby
1570: PPUSH
1571: LD_EXP 1
1575: NOT
1576: PPUSH
1577: CALL 427 0 2
1581: ST_TO_ADDR
// tmp := tmp ^ Bobby ;
1582: LD_ADDR_VAR 0 5
1586: PUSH
1587: LD_VAR 0 5
1591: PUSH
1592: LD_EXP 24
1596: ADD
1597: ST_TO_ADDR
// end ; if LoadVariable ( CyrusInDelta , 0 ) then
1598: LD_STRING CyrusInDelta
1600: PPUSH
1601: LD_INT 0
1603: PPUSH
1604: CALL_OW 30
1608: IFFALSE 1645
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1610: LD_ADDR_EXP 25
1614: PUSH
1615: LD_STRING Cyrus
1617: PPUSH
1618: LD_EXP 1
1622: NOT
1623: PPUSH
1624: CALL 427 0 2
1628: ST_TO_ADDR
// tmp := tmp ^ Cyrus ;
1629: LD_ADDR_VAR 0 5
1633: PUSH
1634: LD_VAR 0 5
1638: PUSH
1639: LD_EXP 25
1643: ADD
1644: ST_TO_ADDR
// end ; others := CreateCharacterSet ( othersDelta ) ;
1645: LD_ADDR_EXP 26
1649: PUSH
1650: LD_STRING othersDelta
1652: PPUSH
1653: CALL_OW 31
1657: ST_TO_ADDR
// if not others and debug then
1658: LD_EXP 26
1662: NOT
1663: PUSH
1664: LD_EXP 1
1668: AND
1669: IFFALSE 1734
// begin InitHc ;
1671: CALL_OW 19
// for i = 1 to 2 do
1675: LD_ADDR_VAR 0 2
1679: PUSH
1680: DOUBLE
1681: LD_INT 1
1683: DEC
1684: ST_TO_ADDR
1685: LD_INT 2
1687: PUSH
1688: FOR_TO
1689: IFFALSE 1732
// begin PrepareHuman ( false , i mod 4 + 1 , 3 ) ;
1691: LD_INT 0
1693: PPUSH
1694: LD_VAR 0 2
1698: PUSH
1699: LD_INT 4
1701: MOD
1702: PUSH
1703: LD_INT 1
1705: PLUS
1706: PPUSH
1707: LD_INT 3
1709: PPUSH
1710: CALL_OW 380
// others := others ^ CreateHuman ;
1714: LD_ADDR_EXP 26
1718: PUSH
1719: LD_EXP 26
1723: PUSH
1724: CALL_OW 44
1728: ADD
1729: ST_TO_ADDR
// end ;
1730: GO 1688
1732: POP
1733: POP
// end ; if others then
1734: LD_EXP 26
1738: IFFALSE 1756
// tmp := tmp ^ others ;
1740: LD_ADDR_VAR 0 5
1744: PUSH
1745: LD_VAR 0 5
1749: PUSH
1750: LD_EXP 26
1754: ADD
1755: ST_TO_ADDR
// points := [ [ 28 , 49 ] , [ 33 , 54 ] , [ 38 , 56 ] ] ;
1756: LD_ADDR_VAR 0 3
1760: PUSH
1761: LD_INT 28
1763: PUSH
1764: LD_INT 49
1766: PUSH
1767: EMPTY
1768: LIST
1769: LIST
1770: PUSH
1771: LD_INT 33
1773: PUSH
1774: LD_INT 54
1776: PUSH
1777: EMPTY
1778: LIST
1779: LIST
1780: PUSH
1781: LD_INT 38
1783: PUSH
1784: LD_INT 56
1786: PUSH
1787: EMPTY
1788: LIST
1789: LIST
1790: PUSH
1791: EMPTY
1792: LIST
1793: LIST
1794: LIST
1795: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , us_cargo_bay , 80 ) ;
1796: LD_ADDR_VAR 0 4
1800: PUSH
1801: LD_INT 1
1803: PPUSH
1804: LD_INT 1
1806: PPUSH
1807: LD_INT 2
1809: PPUSH
1810: LD_INT 2
1812: PPUSH
1813: LD_INT 1
1815: PPUSH
1816: LD_INT 12
1818: PPUSH
1819: LD_INT 80
1821: PPUSH
1822: CALL 490 0 7
1826: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1827: LD_VAR 0 4
1831: PPUSH
1832: LD_INT 1
1834: PPUSH
1835: CALL_OW 233
// PlaceUnitXY ( veh , points [ 1 ] [ 1 ] , points [ 1 ] [ 2 ] , false ) ;
1839: LD_VAR 0 4
1843: PPUSH
1844: LD_VAR 0 3
1848: PUSH
1849: LD_INT 1
1851: ARRAY
1852: PUSH
1853: LD_INT 1
1855: ARRAY
1856: PPUSH
1857: LD_VAR 0 3
1861: PUSH
1862: LD_INT 1
1864: ARRAY
1865: PUSH
1866: LD_INT 2
1868: ARRAY
1869: PPUSH
1870: LD_INT 0
1872: PPUSH
1873: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
1877: LD_VAR 0 4
1881: PPUSH
1882: LD_INT 1
1884: PPUSH
1885: LD_INT 100
1887: PPUSH
1888: CALL_OW 290
// PlaceHumanInUnit ( others [ 1 ] , veh ) ;
1892: LD_EXP 26
1896: PUSH
1897: LD_INT 1
1899: ARRAY
1900: PPUSH
1901: LD_VAR 0 4
1905: PPUSH
1906: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_machine_gun , 80 ) ;
1910: LD_ADDR_VAR 0 4
1914: PUSH
1915: LD_INT 1
1917: PPUSH
1918: LD_INT 1
1920: PPUSH
1921: LD_INT 1
1923: PPUSH
1924: LD_INT 2
1926: PPUSH
1927: LD_INT 1
1929: PPUSH
1930: LD_INT 2
1932: PPUSH
1933: LD_INT 80
1935: PPUSH
1936: CALL 490 0 7
1940: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1941: LD_VAR 0 4
1945: PPUSH
1946: LD_INT 1
1948: PPUSH
1949: CALL_OW 233
// PlaceUnitXY ( veh , points [ 2 ] [ 1 ] , points [ 2 ] [ 2 ] , false ) ;
1953: LD_VAR 0 4
1957: PPUSH
1958: LD_VAR 0 3
1962: PUSH
1963: LD_INT 2
1965: ARRAY
1966: PUSH
1967: LD_INT 1
1969: ARRAY
1970: PPUSH
1971: LD_VAR 0 3
1975: PUSH
1976: LD_INT 2
1978: ARRAY
1979: PUSH
1980: LD_INT 2
1982: ARRAY
1983: PPUSH
1984: LD_INT 0
1986: PPUSH
1987: CALL_OW 48
// PlaceHumanInUnit ( Gladstone , veh ) ;
1991: LD_EXP 17
1995: PPUSH
1996: LD_VAR 0 4
2000: PPUSH
2001: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_light_gun , 80 ) ;
2005: LD_ADDR_VAR 0 4
2009: PUSH
2010: LD_INT 1
2012: PPUSH
2013: LD_INT 1
2015: PPUSH
2016: LD_INT 1
2018: PPUSH
2019: LD_INT 2
2021: PPUSH
2022: LD_INT 1
2024: PPUSH
2025: LD_INT 3
2027: PPUSH
2028: LD_INT 80
2030: PPUSH
2031: CALL 490 0 7
2035: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
2036: LD_VAR 0 4
2040: PPUSH
2041: LD_INT 1
2043: PPUSH
2044: CALL_OW 233
// PlaceUnitXY ( veh , points [ 3 ] [ 1 ] , points [ 3 ] [ 2 ] , false ) ;
2048: LD_VAR 0 4
2052: PPUSH
2053: LD_VAR 0 3
2057: PUSH
2058: LD_INT 3
2060: ARRAY
2061: PUSH
2062: LD_INT 1
2064: ARRAY
2065: PPUSH
2066: LD_VAR 0 3
2070: PUSH
2071: LD_INT 3
2073: ARRAY
2074: PUSH
2075: LD_INT 2
2077: ARRAY
2078: PPUSH
2079: LD_INT 0
2081: PPUSH
2082: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
2086: LD_EXP 16
2090: PPUSH
2091: LD_VAR 0 4
2095: PPUSH
2096: CALL_OW 52
// for i in tmp diff others [ 1 ] do
2100: LD_ADDR_VAR 0 2
2104: PUSH
2105: LD_VAR 0 5
2109: PUSH
2110: LD_EXP 26
2114: PUSH
2115: LD_INT 1
2117: ARRAY
2118: DIFF
2119: PUSH
2120: FOR_IN
2121: IFFALSE 2140
// PlaceUnitArea ( i , startArea , false ) ;
2123: LD_VAR 0 2
2127: PPUSH
2128: LD_INT 5
2130: PPUSH
2131: LD_INT 0
2133: PPUSH
2134: CALL_OW 49
2138: GO 2120
2140: POP
2141: POP
// end ; end_of_file
2142: LD_VAR 0 1
2146: RET
// export function Action ; var m ; begin
2147: LD_INT 0
2149: PPUSH
2150: PPUSH
// InGameOn ;
2151: CALL_OW 8
// CenterNowOnXY ( 28 , 51 ) ;
2155: LD_INT 28
2157: PPUSH
2158: LD_INT 51
2160: PPUSH
2161: CALL_OW 86
// Wait ( 3 ) ;
2165: LD_INT 3
2167: PPUSH
2168: CALL_OW 67
// Say ( JMM , D1d-JMM-1a ) ;
2172: LD_EXP 16
2176: PPUSH
2177: LD_STRING D1d-JMM-1a
2179: PPUSH
2180: CALL_OW 88
// SayRadio ( Harrison , D1d-Har-1 ) ;
2184: LD_EXP 18
2188: PPUSH
2189: LD_STRING D1d-Har-1
2191: PPUSH
2192: CALL_OW 94
// InGameOff ;
2196: CALL_OW 9
// SaveForQuickRestart ;
2200: CALL_OW 22
// ChangeMissionObjectives ( M1 ) ;
2204: LD_STRING M1
2206: PPUSH
2207: CALL_OW 337
// Wait ( 0 0$2 ) ;
2211: LD_INT 70
2213: PPUSH
2214: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
2218: LD_EXP 16
2222: PPUSH
2223: LD_STRING D2-JMM-1
2225: PPUSH
2226: CALL_OW 88
// Say ( Gladstone , D2-Glad-1 ) ;
2230: LD_EXP 17
2234: PPUSH
2235: LD_STRING D2-Glad-1
2237: PPUSH
2238: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
2242: LD_EXP 16
2246: PPUSH
2247: LD_STRING D2-JMM-2
2249: PPUSH
2250: CALL_OW 88
// Say ( Gladstone , D2-Glad-2 ) ;
2254: LD_EXP 17
2258: PPUSH
2259: LD_STRING D2-Glad-2
2261: PPUSH
2262: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
2266: LD_EXP 16
2270: PPUSH
2271: LD_STRING D2-JMM-3
2273: PPUSH
2274: CALL_OW 88
// Wait ( rand ( 0 0$30 , 1 1$00 ) ) ;
2278: LD_INT 1050
2280: PPUSH
2281: LD_INT 2100
2283: PPUSH
2284: CALL_OW 12
2288: PPUSH
2289: CALL_OW 67
// SetWeather ( 2 , 90 , 150 ) ;
2293: LD_INT 2
2295: PPUSH
2296: LD_INT 90
2298: PPUSH
2299: LD_INT 150
2301: PPUSH
2302: CALL_OW 550
// Wait ( rand ( 3 3$00 , 5 5$00 ) ) ;
2306: LD_INT 6300
2308: PPUSH
2309: LD_INT 10500
2311: PPUSH
2312: CALL_OW 12
2316: PPUSH
2317: CALL_OW 67
// SetWeather ( 0 , 90 , 150 ) ;
2321: LD_INT 0
2323: PPUSH
2324: LD_INT 90
2326: PPUSH
2327: LD_INT 150
2329: PPUSH
2330: CALL_OW 550
// end ;
2334: LD_VAR 0 1
2338: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) and not deltaBuilded do
2339: LD_INT 22
2341: PUSH
2342: LD_INT 1
2344: PUSH
2345: EMPTY
2346: LIST
2347: LIST
2348: PUSH
2349: LD_INT 3
2351: PUSH
2352: LD_INT 57
2354: PUSH
2355: EMPTY
2356: LIST
2357: PUSH
2358: EMPTY
2359: LIST
2360: LIST
2361: PUSH
2362: LD_INT 30
2364: PUSH
2365: LD_INT 0
2367: PUSH
2368: EMPTY
2369: LIST
2370: LIST
2371: PUSH
2372: EMPTY
2373: LIST
2374: LIST
2375: LIST
2376: PUSH
2377: EMPTY
2378: LIST
2379: PPUSH
2380: CALL_OW 69
2384: PUSH
2385: LD_EXP 4
2389: NOT
2390: AND
2391: IFFALSE 2404
2393: GO 2395
2395: DISABLE
// begin deltaBuilded := true ;
2396: LD_ADDR_EXP 4
2400: PUSH
2401: LD_INT 1
2403: ST_TO_ADDR
// end ;
2404: END
// every 0 0$01 trigger not Delta and deltaBuilded and FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) do
2405: LD_EXP 6
2409: NOT
2410: PUSH
2411: LD_EXP 4
2415: AND
2416: PUSH
2417: LD_INT 22
2419: PUSH
2420: LD_INT 1
2422: PUSH
2423: EMPTY
2424: LIST
2425: LIST
2426: PUSH
2427: LD_INT 3
2429: PUSH
2430: LD_INT 57
2432: PUSH
2433: EMPTY
2434: LIST
2435: PUSH
2436: EMPTY
2437: LIST
2438: LIST
2439: PUSH
2440: LD_INT 30
2442: PUSH
2443: LD_INT 0
2445: PUSH
2446: EMPTY
2447: LIST
2448: LIST
2449: PUSH
2450: EMPTY
2451: LIST
2452: LIST
2453: LIST
2454: PUSH
2455: EMPTY
2456: LIST
2457: PPUSH
2458: CALL_OW 69
2462: AND
2463: IFFALSE 2549
2465: GO 2467
2467: DISABLE
// begin enable ;
2468: ENABLE
// SetRestrict ( b_depot , 1 , state_disabled ) ;
2469: LD_INT 0
2471: PPUSH
2472: LD_INT 1
2474: PPUSH
2475: LD_INT 0
2477: PPUSH
2478: CALL_OW 324
// Delta := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) [ 1 ] ;
2482: LD_ADDR_EXP 6
2486: PUSH
2487: LD_INT 22
2489: PUSH
2490: LD_INT 1
2492: PUSH
2493: EMPTY
2494: LIST
2495: LIST
2496: PUSH
2497: LD_INT 3
2499: PUSH
2500: LD_INT 57
2502: PUSH
2503: EMPTY
2504: LIST
2505: PUSH
2506: EMPTY
2507: LIST
2508: LIST
2509: PUSH
2510: LD_INT 30
2512: PUSH
2513: LD_INT 0
2515: PUSH
2516: EMPTY
2517: LIST
2518: LIST
2519: PUSH
2520: EMPTY
2521: LIST
2522: LIST
2523: LIST
2524: PUSH
2525: EMPTY
2526: LIST
2527: PPUSH
2528: CALL_OW 69
2532: PUSH
2533: LD_INT 1
2535: ARRAY
2536: ST_TO_ADDR
// SetBName ( Delta , Delta ) ;
2537: LD_EXP 6
2541: PPUSH
2542: LD_STRING Delta
2544: PPUSH
2545: CALL_OW 500
// end ;
2549: END
// every 0 0$2 trigger GetTech ( tech_ApeLang , 1 ) = state_researched and IsOk ( Gladstone ) do
2550: LD_INT 1
2552: PPUSH
2553: LD_INT 1
2555: PPUSH
2556: CALL_OW 321
2560: PUSH
2561: LD_INT 2
2563: EQUAL
2564: PUSH
2565: LD_EXP 17
2569: PPUSH
2570: CALL_OW 302
2574: AND
2575: IFFALSE 2636
2577: GO 2579
2579: DISABLE
// begin DialogueOn ;
2580: CALL_OW 6
// Say ( Gladstone , D3-Glad-1 ) ;
2584: LD_EXP 17
2588: PPUSH
2589: LD_STRING D3-Glad-1
2591: PPUSH
2592: CALL_OW 88
// Say ( JMM , D3-JMM-1 ) ;
2596: LD_EXP 16
2600: PPUSH
2601: LD_STRING D3-JMM-1
2603: PPUSH
2604: CALL_OW 88
// Say ( Gladstone , D3-Glad-2 ) ;
2608: LD_EXP 17
2612: PPUSH
2613: LD_STRING D3-Glad-2
2615: PPUSH
2616: CALL_OW 88
// Say ( JMM , D3-JMM-2 ) ;
2620: LD_EXP 16
2624: PPUSH
2625: LD_STRING D3-JMM-2
2627: PPUSH
2628: CALL_OW 88
// DialogueOff ;
2632: CALL_OW 7
// end ;
2636: END
// every 0 0$1 trigger GetTech ( tech_ApePsych , 1 ) = state_researched do var sol ;
2637: LD_INT 2
2639: PPUSH
2640: LD_INT 1
2642: PPUSH
2643: CALL_OW 321
2647: PUSH
2648: LD_INT 2
2650: EQUAL
2651: IFFALSE 2828
2653: GO 2655
2655: DISABLE
2656: LD_INT 0
2658: PPUSH
// begin DialogueOn ;
2659: CALL_OW 6
// if Frank then
2663: LD_EXP 23
2667: IFFALSE 2681
// Say ( Frank , D8a-Frank-1 ) ;
2669: LD_EXP 23
2673: PPUSH
2674: LD_STRING D8a-Frank-1
2676: PPUSH
2677: CALL_OW 88
// sol := SayX ( UnitFilter ( others , [ f_sex , sex_male ] ) , D8a-Sol1-1 ) ;
2681: LD_ADDR_VAR 0 1
2685: PUSH
2686: LD_EXP 26
2690: PPUSH
2691: LD_INT 26
2693: PUSH
2694: LD_INT 1
2696: PUSH
2697: EMPTY
2698: LIST
2699: LIST
2700: PPUSH
2701: CALL_OW 72
2705: PPUSH
2706: LD_STRING D8a-Sol1-1
2708: PPUSH
2709: CALL 578 0 2
2713: ST_TO_ADDR
// if Denis and GetSide ( Denis ) = 1 then
2714: LD_EXP 19
2718: PUSH
2719: LD_EXP 19
2723: PPUSH
2724: CALL_OW 255
2728: PUSH
2729: LD_INT 1
2731: EQUAL
2732: AND
2733: IFFALSE 2747
// Say ( Denis , D8a-Den-1 ) ;
2735: LD_EXP 19
2739: PPUSH
2740: LD_STRING D8a-Den-1
2742: PPUSH
2743: CALL_OW 88
// if sol or Denis or Frank then
2747: LD_VAR 0 1
2751: PUSH
2752: LD_EXP 19
2756: OR
2757: PUSH
2758: LD_EXP 23
2762: OR
2763: IFFALSE 2824
// begin SayX ( UnitFilter ( others , [ [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff sol , D8a-Sci1-1 ) ;
2765: LD_EXP 26
2769: PPUSH
2770: LD_INT 25
2772: PUSH
2773: LD_INT 4
2775: PUSH
2776: EMPTY
2777: LIST
2778: LIST
2779: PUSH
2780: LD_INT 26
2782: PUSH
2783: LD_INT 1
2785: PUSH
2786: EMPTY
2787: LIST
2788: LIST
2789: PUSH
2790: EMPTY
2791: LIST
2792: LIST
2793: PPUSH
2794: CALL_OW 72
2798: PUSH
2799: LD_VAR 0 1
2803: DIFF
2804: PPUSH
2805: LD_STRING D8a-Sci1-1
2807: PPUSH
2808: CALL 578 0 2
// Say ( JMM , D8a-JMM-1 ) ;
2812: LD_EXP 16
2816: PPUSH
2817: LD_STRING D8a-JMM-1
2819: PPUSH
2820: CALL_OW 88
// end ; DialogueOff ;
2824: CALL_OW 7
// end ;
2828: PPOPN 1
2830: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) do
2831: LD_INT 22
2833: PUSH
2834: LD_INT 1
2836: PUSH
2837: EMPTY
2838: LIST
2839: LIST
2840: PUSH
2841: LD_INT 25
2843: PUSH
2844: LD_INT 16
2846: PUSH
2847: EMPTY
2848: LIST
2849: LIST
2850: PUSH
2851: EMPTY
2852: LIST
2853: LIST
2854: PPUSH
2855: CALL_OW 69
2859: IFFALSE 2918
2861: GO 2863
2863: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
2864: LD_STRING M1a
2866: PPUSH
2867: CALL_OW 337
// case Query ( Q2 ) of 1 :
2871: LD_STRING Q2
2873: PPUSH
2874: CALL_OW 97
2878: PUSH
2879: LD_INT 1
2881: DOUBLE
2882: EQUAL
2883: IFTRUE 2887
2885: GO 2898
2887: POP
// end_mission := true ; 2 :
2888: LD_ADDR_EXP 14
2892: PUSH
2893: LD_INT 1
2895: ST_TO_ADDR
2896: GO 2918
2898: LD_INT 2
2900: DOUBLE
2901: EQUAL
2902: IFTRUE 2906
2904: GO 2917
2906: POP
// end_the_mission_allowed := true ; end ;
2907: LD_ADDR_OWVAR 57
2911: PUSH
2912: LD_INT 1
2914: ST_TO_ADDR
2915: GO 2918
2917: POP
// end ;
2918: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) and Delta do
2919: LD_INT 22
2921: PUSH
2922: LD_INT 1
2924: PUSH
2925: EMPTY
2926: LIST
2927: LIST
2928: PUSH
2929: LD_INT 2
2931: PUSH
2932: LD_INT 30
2934: PUSH
2935: LD_INT 6
2937: PUSH
2938: EMPTY
2939: LIST
2940: LIST
2941: PUSH
2942: LD_INT 30
2944: PUSH
2945: LD_INT 7
2947: PUSH
2948: EMPTY
2949: LIST
2950: LIST
2951: PUSH
2952: EMPTY
2953: LIST
2954: LIST
2955: LIST
2956: PUSH
2957: EMPTY
2958: LIST
2959: LIST
2960: PPUSH
2961: CALL_OW 69
2965: PUSH
2966: LD_INT 22
2968: PUSH
2969: LD_INT 1
2971: PUSH
2972: EMPTY
2973: LIST
2974: LIST
2975: PUSH
2976: LD_INT 2
2978: PUSH
2979: LD_INT 30
2981: PUSH
2982: LD_INT 2
2984: PUSH
2985: EMPTY
2986: LIST
2987: LIST
2988: PUSH
2989: LD_INT 30
2991: PUSH
2992: LD_INT 3
2994: PUSH
2995: EMPTY
2996: LIST
2997: LIST
2998: PUSH
2999: EMPTY
3000: LIST
3001: LIST
3002: LIST
3003: PUSH
3004: EMPTY
3005: LIST
3006: LIST
3007: PPUSH
3008: CALL_OW 69
3012: AND
3013: PUSH
3014: LD_EXP 6
3018: AND
3019: IFFALSE 3446
3021: GO 3023
3023: DISABLE
// begin Wait ( rand ( 0 0$20 , 0 0$40 ) ) ;
3024: LD_INT 700
3026: PPUSH
3027: LD_INT 1400
3029: PPUSH
3030: CALL_OW 12
3034: PPUSH
3035: CALL_OW 67
// PlaceUnitArea ( Denis , [ denisArea1 , denisArea2 , denisArea3 ] [ Difficulty ] , false ) ;
3039: LD_EXP 19
3043: PPUSH
3044: LD_INT 6
3046: PUSH
3047: LD_INT 9
3049: PUSH
3050: LD_INT 10
3052: PUSH
3053: EMPTY
3054: LIST
3055: LIST
3056: LIST
3057: PUSH
3058: LD_OWVAR 67
3062: ARRAY
3063: PPUSH
3064: LD_INT 0
3066: PPUSH
3067: CALL_OW 49
// ComHold ( Denis ) ;
3071: LD_EXP 19
3075: PPUSH
3076: CALL_OW 140
// InGameOn ;
3080: CALL_OW 8
// DialogueOn ;
3084: CALL_OW 6
// if Delta then
3088: LD_EXP 6
3092: IFFALSE 3105
// CenterNowOnUnits ( Delta ) else
3094: LD_EXP 6
3098: PPUSH
3099: CALL_OW 87
3103: GO 3114
// CenterNowOnUnits ( JMM ) ;
3105: LD_EXP 16
3109: PPUSH
3110: CALL_OW 87
// SayRadio ( Denis , DD-Den-1 ) ;
3114: LD_EXP 19
3118: PPUSH
3119: LD_STRING DD-Den-1
3121: PPUSH
3122: CALL_OW 94
// Say ( JMM , DD-JMM-1 ) ;
3126: LD_EXP 16
3130: PPUSH
3131: LD_STRING DD-JMM-1
3133: PPUSH
3134: CALL_OW 88
// SayRadio ( Denis , DD-Den-2 ) ;
3138: LD_EXP 19
3142: PPUSH
3143: LD_STRING DD-Den-2
3145: PPUSH
3146: CALL_OW 94
// Wait ( 3 ) ;
3150: LD_INT 3
3152: PPUSH
3153: CALL_OW 67
// DialogueOff ;
3157: CALL_OW 7
// InGameOff ;
3161: CALL_OW 9
// repeat wait ( 0 0$01 ) ;
3165: LD_INT 35
3167: PPUSH
3168: CALL_OW 67
// until See ( 1 , Denis ) or IsDead ( Denis ) ;
3172: LD_INT 1
3174: PPUSH
3175: LD_EXP 19
3179: PPUSH
3180: CALL_OW 292
3184: PUSH
3185: LD_EXP 19
3189: PPUSH
3190: CALL_OW 301
3194: OR
3195: IFFALSE 3165
// if IsDead ( Denis ) then
3197: LD_EXP 19
3201: PPUSH
3202: CALL_OW 301
3206: IFFALSE 3210
// exit ;
3208: GO 3446
// SetSide ( Denis , 1 ) ;
3210: LD_EXP 19
3214: PPUSH
3215: LD_INT 1
3217: PPUSH
3218: CALL_OW 235
// Say ( Denis , DD-Den-2a ) ;
3222: LD_EXP 19
3226: PPUSH
3227: LD_STRING DD-Den-2a
3229: PPUSH
3230: CALL_OW 88
// repeat wait ( 0 0$01 ) ;
3234: LD_INT 35
3236: PPUSH
3237: CALL_OW 67
// until GetBType ( IsInUnit ( Denis ) ) in [ b_lab , b_lab_half , b_lab_full ] or IsDead ( Denis ) ;
3241: LD_EXP 19
3245: PPUSH
3246: CALL_OW 310
3250: PPUSH
3251: CALL_OW 266
3255: PUSH
3256: LD_INT 6
3258: PUSH
3259: LD_INT 7
3261: PUSH
3262: LD_INT 8
3264: PUSH
3265: EMPTY
3266: LIST
3267: LIST
3268: LIST
3269: IN
3270: PUSH
3271: LD_EXP 19
3275: PPUSH
3276: CALL_OW 301
3280: OR
3281: IFFALSE 3234
// if IsDead ( Denis ) then
3283: LD_EXP 19
3287: PPUSH
3288: CALL_OW 301
3292: IFFALSE 3296
// exit ;
3294: GO 3446
// Say ( Denis , DD-Den-2b ) ;
3296: LD_EXP 19
3300: PPUSH
3301: LD_STRING DD-Den-2b
3303: PPUSH
3304: CALL_OW 88
// ComChangeProfession ( Denis , 4 ) ;
3308: LD_EXP 19
3312: PPUSH
3313: LD_INT 4
3315: PPUSH
3316: CALL_OW 123
// Wait ( 0 0$02 ) ;
3320: LD_INT 70
3322: PPUSH
3323: CALL_OW 67
// DialogueOn ;
3327: CALL_OW 6
// CenterNowOnUnits ( Denis ) ;
3331: LD_EXP 19
3335: PPUSH
3336: CALL_OW 87
// Say ( JMM , D4-JMM-1 ) ;
3340: LD_EXP 16
3344: PPUSH
3345: LD_STRING D4-JMM-1
3347: PPUSH
3348: CALL_OW 88
// Say ( Denis , D4-Den-1 ) ;
3352: LD_EXP 19
3356: PPUSH
3357: LD_STRING D4-Den-1
3359: PPUSH
3360: CALL_OW 88
// Say ( JMM , D4-JMM-2 ) ;
3364: LD_EXP 16
3368: PPUSH
3369: LD_STRING D4-JMM-2
3371: PPUSH
3372: CALL_OW 88
// Say ( Denis , D4-Den-2 ) ;
3376: LD_EXP 19
3380: PPUSH
3381: LD_STRING D4-Den-2
3383: PPUSH
3384: CALL_OW 88
// DialogueOff ;
3388: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
3392: LD_STRING M2
3394: PPUSH
3395: CALL_OW 337
// radar_allowed := true ;
3399: LD_ADDR_EXP 7
3403: PUSH
3404: LD_INT 1
3406: ST_TO_ADDR
// SetTech ( tech_radar , 1 , state_enabled ) ;
3407: LD_INT 6
3409: PPUSH
3410: LD_INT 1
3412: PPUSH
3413: LD_INT 1
3415: PPUSH
3416: CALL_OW 322
// SetRestrict ( b_lab_opto , 1 , state_enabled ) ;
3420: LD_INT 15
3422: PPUSH
3423: LD_INT 1
3425: PPUSH
3426: LD_INT 1
3428: PPUSH
3429: CALL_OW 324
// SetRestrict ( b_ext_radar , 1 , state_enabled ) ;
3433: LD_INT 20
3435: PPUSH
3436: LD_INT 1
3438: PPUSH
3439: LD_INT 1
3441: PPUSH
3442: CALL_OW 324
// end ;
3446: END
// every 0 0$1 trigger arab_spotted do var sol , sol2 ;
3447: LD_EXP 13
3451: IFFALSE 4074
3453: GO 3455
3455: DISABLE
3456: LD_INT 0
3458: PPUSH
3459: PPUSH
// begin sol := SayX ( UnitFilter ( others , [ f_sex , sex_male ] ) , D5-Sol1-1 ) ;
3460: LD_ADDR_VAR 0 1
3464: PUSH
3465: LD_EXP 26
3469: PPUSH
3470: LD_INT 26
3472: PUSH
3473: LD_INT 1
3475: PUSH
3476: EMPTY
3477: LIST
3478: LIST
3479: PPUSH
3480: CALL_OW 72
3484: PPUSH
3485: LD_STRING D5-Sol1-1
3487: PPUSH
3488: CALL 578 0 2
3492: ST_TO_ADDR
// if not sol then
3493: LD_VAR 0 1
3497: NOT
3498: IFFALSE 3502
// exit ;
3500: GO 4074
// repeat wait ( 0 0$01 ) ;
3502: LD_INT 35
3504: PPUSH
3505: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 ;
3509: LD_INT 22
3511: PUSH
3512: LD_INT 2
3514: PUSH
3515: EMPTY
3516: LIST
3517: LIST
3518: PUSH
3519: LD_INT 21
3521: PUSH
3522: LD_INT 1
3524: PUSH
3525: EMPTY
3526: LIST
3527: LIST
3528: PUSH
3529: EMPTY
3530: LIST
3531: LIST
3532: PPUSH
3533: CALL_OW 69
3537: PUSH
3538: LD_INT 0
3540: EQUAL
3541: IFFALSE 3502
// if IsOk ( sol ) then
3543: LD_VAR 0 1
3547: PPUSH
3548: CALL_OW 302
3552: IFFALSE 3572
// begin sol2 := others diff sol ;
3554: LD_ADDR_VAR 0 2
3558: PUSH
3559: LD_EXP 26
3563: PUSH
3564: LD_VAR 0 1
3568: DIFF
3569: ST_TO_ADDR
// end else
3570: GO 3574
// exit ;
3572: GO 4074
// if not Lisa and not sol2 then
3574: LD_EXP 22
3578: NOT
3579: PUSH
3580: LD_VAR 0 2
3584: NOT
3585: AND
3586: IFFALSE 3590
// exit ;
3588: GO 4074
// DialogueOn ;
3590: CALL_OW 6
// if Lisa then
3594: LD_EXP 22
3598: IFFALSE 3614
// Say ( Lisa , D5a-Lisa-1 ) else
3600: LD_EXP 22
3604: PPUSH
3605: LD_STRING D5a-Lisa-1
3607: PPUSH
3608: CALL_OW 88
3612: GO 3689
// if sol2 then
3614: LD_VAR 0 2
3618: IFFALSE 3689
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3620: LD_VAR 0 2
3624: PUSH
3625: LD_INT 1
3627: ARRAY
3628: PPUSH
3629: CALL_OW 258
3633: PUSH
3634: LD_INT 1
3636: DOUBLE
3637: EQUAL
3638: IFTRUE 3642
3640: GO 3661
3642: POP
// Say ( sol2 [ 1 ] , D5-Sol2-1 ) ; sex_female :
3643: LD_VAR 0 2
3647: PUSH
3648: LD_INT 1
3650: ARRAY
3651: PPUSH
3652: LD_STRING D5-Sol2-1
3654: PPUSH
3655: CALL_OW 88
3659: GO 3689
3661: LD_INT 2
3663: DOUBLE
3664: EQUAL
3665: IFTRUE 3669
3667: GO 3688
3669: POP
// Say ( sol2 [ 1 ] , D5-FSol2-1 ) ; end ;
3670: LD_VAR 0 2
3674: PUSH
3675: LD_INT 1
3677: ARRAY
3678: PPUSH
3679: LD_STRING D5-FSol2-1
3681: PPUSH
3682: CALL_OW 88
3686: GO 3689
3688: POP
// Say ( sol , D5-Sol1-2 ) ;
3689: LD_VAR 0 1
3693: PPUSH
3694: LD_STRING D5-Sol1-2
3696: PPUSH
3697: CALL_OW 88
// if Lisa then
3701: LD_EXP 22
3705: IFFALSE 3721
// Say ( Lisa , D5a-Lisa-2 ) else
3707: LD_EXP 22
3711: PPUSH
3712: LD_STRING D5a-Lisa-2
3714: PPUSH
3715: CALL_OW 88
3719: GO 3796
// if sol2 then
3721: LD_VAR 0 2
3725: IFFALSE 3796
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3727: LD_VAR 0 2
3731: PUSH
3732: LD_INT 1
3734: ARRAY
3735: PPUSH
3736: CALL_OW 258
3740: PUSH
3741: LD_INT 1
3743: DOUBLE
3744: EQUAL
3745: IFTRUE 3749
3747: GO 3768
3749: POP
// Say ( sol2 [ 1 ] , D5-Sol2-2 ) ; sex_female :
3750: LD_VAR 0 2
3754: PUSH
3755: LD_INT 1
3757: ARRAY
3758: PPUSH
3759: LD_STRING D5-Sol2-2
3761: PPUSH
3762: CALL_OW 88
3766: GO 3796
3768: LD_INT 2
3770: DOUBLE
3771: EQUAL
3772: IFTRUE 3776
3774: GO 3795
3776: POP
// Say ( sol2 [ 1 ] , D5-FSol2-2 ) ; end ;
3777: LD_VAR 0 2
3781: PUSH
3782: LD_INT 1
3784: ARRAY
3785: PPUSH
3786: LD_STRING D5-FSol2-2
3788: PPUSH
3789: CALL_OW 88
3793: GO 3796
3795: POP
// Say ( sol , D5a-Sol1-3 ) ;
3796: LD_VAR 0 1
3800: PPUSH
3801: LD_STRING D5a-Sol1-3
3803: PPUSH
3804: CALL_OW 88
// if Lisa then
3808: LD_EXP 22
3812: IFFALSE 3826
// Say ( Lisa , D5a-Lisa-3 ) ;
3814: LD_EXP 22
3818: PPUSH
3819: LD_STRING D5a-Lisa-3
3821: PPUSH
3822: CALL_OW 88
// if not sol2 then
3826: LD_VAR 0 2
3830: NOT
3831: IFFALSE 3839
// begin DialogueOff ;
3833: CALL_OW 7
// exit ;
3837: GO 4074
// end ; case GetSex ( sol2 [ 1 ] ) of sex_male :
3839: LD_VAR 0 2
3843: PUSH
3844: LD_INT 1
3846: ARRAY
3847: PPUSH
3848: CALL_OW 258
3852: PUSH
3853: LD_INT 1
3855: DOUBLE
3856: EQUAL
3857: IFTRUE 3861
3859: GO 3880
3861: POP
// Say ( sol2 [ 1 ] , D5-Sol2-3 ) ; sex_female :
3862: LD_VAR 0 2
3866: PUSH
3867: LD_INT 1
3869: ARRAY
3870: PPUSH
3871: LD_STRING D5-Sol2-3
3873: PPUSH
3874: CALL_OW 88
3878: GO 3908
3880: LD_INT 2
3882: DOUBLE
3883: EQUAL
3884: IFTRUE 3888
3886: GO 3907
3888: POP
// Say ( sol2 [ 1 ] , D5-FSol2-3 ) ; end ;
3889: LD_VAR 0 2
3893: PUSH
3894: LD_INT 1
3896: ARRAY
3897: PPUSH
3898: LD_STRING D5-FSol2-3
3900: PPUSH
3901: CALL_OW 88
3905: GO 3908
3907: POP
// Say ( sol , D5-Sol1-4 ) ;
3908: LD_VAR 0 1
3912: PPUSH
3913: LD_STRING D5-Sol1-4
3915: PPUSH
3916: CALL_OW 88
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3920: LD_VAR 0 2
3924: PUSH
3925: LD_INT 1
3927: ARRAY
3928: PPUSH
3929: CALL_OW 258
3933: PUSH
3934: LD_INT 1
3936: DOUBLE
3937: EQUAL
3938: IFTRUE 3942
3940: GO 3961
3942: POP
// Say ( sol2 [ 1 ] , D5-Sol2-4 ) ; sex_female :
3943: LD_VAR 0 2
3947: PUSH
3948: LD_INT 1
3950: ARRAY
3951: PPUSH
3952: LD_STRING D5-Sol2-4
3954: PPUSH
3955: CALL_OW 88
3959: GO 3989
3961: LD_INT 2
3963: DOUBLE
3964: EQUAL
3965: IFTRUE 3969
3967: GO 3988
3969: POP
// Say ( sol2 [ 1 ] , D5-FSol2-4 ) ; end ;
3970: LD_VAR 0 2
3974: PUSH
3975: LD_INT 1
3977: ARRAY
3978: PPUSH
3979: LD_STRING D5-FSol2-4
3981: PPUSH
3982: CALL_OW 88
3986: GO 3989
3988: POP
// Say ( sol , D5-Sol1-5 ) ;
3989: LD_VAR 0 1
3993: PPUSH
3994: LD_STRING D5-Sol1-5
3996: PPUSH
3997: CALL_OW 88
// case GetSex ( sol2 [ 1 ] ) of sex_male :
4001: LD_VAR 0 2
4005: PUSH
4006: LD_INT 1
4008: ARRAY
4009: PPUSH
4010: CALL_OW 258
4014: PUSH
4015: LD_INT 1
4017: DOUBLE
4018: EQUAL
4019: IFTRUE 4023
4021: GO 4042
4023: POP
// Say ( sol2 [ 1 ] , D5-Sol2-5 ) ; sex_female :
4024: LD_VAR 0 2
4028: PUSH
4029: LD_INT 1
4031: ARRAY
4032: PPUSH
4033: LD_STRING D5-Sol2-5
4035: PPUSH
4036: CALL_OW 88
4040: GO 4070
4042: LD_INT 2
4044: DOUBLE
4045: EQUAL
4046: IFTRUE 4050
4048: GO 4069
4050: POP
// Say ( sol2 [ 1 ] , D5-FSol2-5 ) ; end ;
4051: LD_VAR 0 2
4055: PUSH
4056: LD_INT 1
4058: ARRAY
4059: PPUSH
4060: LD_STRING D5-FSol2-5
4062: PPUSH
4063: CALL_OW 88
4067: GO 4070
4069: POP
// DialogueOff ;
4070: CALL_OW 7
// end ;
4074: PPOPN 2
4076: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) >= 5 do
4077: LD_INT 22
4079: PUSH
4080: LD_INT 1
4082: PUSH
4083: EMPTY
4084: LIST
4085: LIST
4086: PUSH
4087: LD_INT 25
4089: PUSH
4090: LD_INT 16
4092: PUSH
4093: EMPTY
4094: LIST
4095: LIST
4096: PUSH
4097: EMPTY
4098: LIST
4099: LIST
4100: PPUSH
4101: CALL_OW 69
4105: PUSH
4106: LD_INT 5
4108: GREATEREQUAL
4109: IFFALSE 4129
4111: GO 4113
4113: DISABLE
// begin ChangeMissionObjectives ( M1b ) ;
4114: LD_STRING M1b
4116: PPUSH
4117: CALL_OW 337
// apeman_army := true ;
4121: LD_ADDR_EXP 9
4125: PUSH
4126: LD_INT 1
4128: ST_TO_ADDR
// end ;
4129: END
// every 0 0$1 trigger GetTech ( tech_radar , 1 ) = state_researched do
4130: LD_INT 6
4132: PPUSH
4133: LD_INT 1
4135: PPUSH
4136: CALL_OW 321
4140: PUSH
4141: LD_INT 2
4143: EQUAL
4144: IFFALSE 4164
4146: GO 4148
4148: DISABLE
// begin ChangeMissionObjectives ( M2a ) ;
4149: LD_STRING M2a
4151: PPUSH
4152: CALL_OW 337
// radar_researched := true ;
4156: LD_ADDR_EXP 10
4160: PUSH
4161: LD_INT 1
4163: ST_TO_ADDR
// end ;
4164: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_weapon , us_radar ] , [ f_bweapon , us_radar ] ] ] ) do
4165: LD_INT 22
4167: PUSH
4168: LD_INT 1
4170: PUSH
4171: EMPTY
4172: LIST
4173: LIST
4174: PUSH
4175: LD_INT 2
4177: PUSH
4178: LD_INT 34
4180: PUSH
4181: LD_INT 11
4183: PUSH
4184: EMPTY
4185: LIST
4186: LIST
4187: PUSH
4188: LD_INT 35
4190: PUSH
4191: LD_INT 11
4193: PUSH
4194: EMPTY
4195: LIST
4196: LIST
4197: PUSH
4198: EMPTY
4199: LIST
4200: LIST
4201: LIST
4202: PUSH
4203: EMPTY
4204: LIST
4205: LIST
4206: PPUSH
4207: CALL_OW 69
4211: IFFALSE 4231
4213: GO 4215
4215: DISABLE
// begin ChangeMissionObjectives ( M2b ) ;
4216: LD_STRING M2b
4218: PPUSH
4219: CALL_OW 337
// radar_builded := true ;
4223: LD_ADDR_EXP 11
4227: PUSH
4228: LD_INT 1
4230: ST_TO_ADDR
// end ;
4231: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) = 0 and not first_apeman_tamed do
4232: LD_INT 22
4234: PUSH
4235: LD_INT 0
4237: PUSH
4238: EMPTY
4239: LIST
4240: LIST
4241: PUSH
4242: LD_INT 25
4244: PUSH
4245: LD_INT 12
4247: PUSH
4248: EMPTY
4249: LIST
4250: LIST
4251: PUSH
4252: EMPTY
4253: LIST
4254: LIST
4255: PPUSH
4256: CALL_OW 69
4260: PUSH
4261: LD_INT 0
4263: EQUAL
4264: PUSH
4265: LD_EXP 8
4269: NOT
4270: AND
4271: IFFALSE 4283
4273: GO 4275
4275: DISABLE
// YouLost ( Apeman ) ;
4276: LD_STRING Apeman
4278: PPUSH
4279: CALL_OW 104
4283: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) >= 7 do var i , filter ;
4284: LD_INT 22
4286: PUSH
4287: LD_INT 1
4289: PUSH
4290: EMPTY
4291: LIST
4292: LIST
4293: PUSH
4294: LD_INT 25
4296: PUSH
4297: LD_INT 16
4299: PUSH
4300: EMPTY
4301: LIST
4302: LIST
4303: PUSH
4304: EMPTY
4305: LIST
4306: LIST
4307: PPUSH
4308: CALL_OW 69
4312: PUSH
4313: LD_INT 7
4315: GREATEREQUAL
4316: IFFALSE 4414
4318: GO 4320
4320: DISABLE
4321: LD_INT 0
4323: PPUSH
4324: PPUSH
// begin filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , 4 ] ] ) ^ JMM ;
4325: LD_ADDR_VAR 0 2
4329: PUSH
4330: LD_INT 22
4332: PUSH
4333: LD_INT 1
4335: PUSH
4336: EMPTY
4337: LIST
4338: LIST
4339: PUSH
4340: LD_INT 21
4342: PUSH
4343: LD_INT 1
4345: PUSH
4346: EMPTY
4347: LIST
4348: LIST
4349: PUSH
4350: LD_INT 25
4352: PUSH
4353: LD_INT 4
4355: PUSH
4356: EMPTY
4357: LIST
4358: LIST
4359: PUSH
4360: EMPTY
4361: LIST
4362: LIST
4363: LIST
4364: PPUSH
4365: CALL_OW 69
4369: PUSH
4370: LD_EXP 16
4374: ADD
4375: ST_TO_ADDR
// if filter then
4376: LD_VAR 0 2
4380: IFFALSE 4414
// for i in filter do
4382: LD_ADDR_VAR 0 1
4386: PUSH
4387: LD_VAR 0 2
4391: PUSH
4392: FOR_IN
4393: IFFALSE 4412
// AddExperience ( i , 4 , 3500 ) ;
4395: LD_VAR 0 1
4399: PPUSH
4400: LD_INT 4
4402: PPUSH
4403: LD_INT 3500
4405: PPUSH
4406: CALL_OW 492
4410: GO 4392
4412: POP
4413: POP
// end ;
4414: PPOPN 2
4416: END
// every 0 0$1 trigger end_mission do var i , tmp , m1 , m2 , m3 ;
4417: LD_EXP 14
4421: IFFALSE 5555
4423: GO 4425
4425: DISABLE
4426: LD_INT 0
4428: PPUSH
4429: PPUSH
4430: PPUSH
4431: PPUSH
4432: PPUSH
// begin if apeKillCounter = 0 then
4433: LD_EXP 15
4437: PUSH
4438: LD_INT 0
4440: EQUAL
4441: IFFALSE 4450
// SetAchievement ( ACH_APEKILLER ) ;
4443: LD_STRING ACH_APEKILLER
4445: PPUSH
4446: CALL_OW 543
// if FilterAllUnits ( [ f_side , 2 ] ) then
4450: LD_INT 22
4452: PUSH
4453: LD_INT 2
4455: PUSH
4456: EMPTY
4457: LIST
4458: LIST
4459: PPUSH
4460: CALL_OW 69
4464: IFFALSE 4502
// for i in FilterAllUnits ( [ f_side , 2 ] ) do
4466: LD_ADDR_VAR 0 1
4470: PUSH
4471: LD_INT 22
4473: PUSH
4474: LD_INT 2
4476: PUSH
4477: EMPTY
4478: LIST
4479: LIST
4480: PPUSH
4481: CALL_OW 69
4485: PUSH
4486: FOR_IN
4487: IFFALSE 4500
// RemoveUnit ( i ) ;
4489: LD_VAR 0 1
4493: PPUSH
4494: CALL_OW 64
4498: GO 4486
4500: POP
4501: POP
// m1 := false ;
4502: LD_ADDR_VAR 0 3
4506: PUSH
4507: LD_INT 0
4509: ST_TO_ADDR
// m2 := false ;
4510: LD_ADDR_VAR 0 4
4514: PUSH
4515: LD_INT 0
4517: ST_TO_ADDR
// m3 := false ;
4518: LD_ADDR_VAR 0 5
4522: PUSH
4523: LD_INT 0
4525: ST_TO_ADDR
// if apeman_army then
4526: LD_EXP 9
4530: IFFALSE 4552
// begin AddMedal ( Tame , 1 ) ;
4532: LD_STRING Tame
4534: PPUSH
4535: LD_INT 1
4537: PPUSH
4538: CALL_OW 101
// m1 := true ;
4542: LD_ADDR_VAR 0 3
4546: PUSH
4547: LD_INT 1
4549: ST_TO_ADDR
// end else
4550: GO 4563
// AddMedal ( Tame , - 1 ) ;
4552: LD_STRING Tame
4554: PPUSH
4555: LD_INT 1
4557: NEG
4558: PPUSH
4559: CALL_OW 101
// if radar_researched then
4563: LD_EXP 10
4567: IFFALSE 4599
// begin SaveVariable ( true , radarResInDelta ) ;
4569: LD_INT 1
4571: PPUSH
4572: LD_STRING radarResInDelta
4574: PPUSH
4575: CALL_OW 39
// AddMedal ( Radar , 1 ) ;
4579: LD_STRING Radar
4581: PPUSH
4582: LD_INT 1
4584: PPUSH
4585: CALL_OW 101
// m2 := true ;
4589: LD_ADDR_VAR 0 4
4593: PUSH
4594: LD_INT 1
4596: ST_TO_ADDR
// end else
4597: GO 4629
// if radar_allowed then
4599: LD_EXP 7
4603: IFFALSE 4618
// AddMedal ( Radar , - 2 ) else
4605: LD_STRING Radar
4607: PPUSH
4608: LD_INT 2
4610: NEG
4611: PPUSH
4612: CALL_OW 101
4616: GO 4629
// AddMedal ( Radar , - 1 ) ;
4618: LD_STRING Radar
4620: PPUSH
4621: LD_INT 1
4623: NEG
4624: PPUSH
4625: CALL_OW 101
// if radar_builded then
4629: LD_EXP 11
4633: IFFALSE 4655
// begin AddMedal ( BuildRadar , 1 ) ;
4635: LD_STRING BuildRadar
4637: PPUSH
4638: LD_INT 1
4640: PPUSH
4641: CALL_OW 101
// m3 := true ;
4645: LD_ADDR_VAR 0 5
4649: PUSH
4650: LD_INT 1
4652: ST_TO_ADDR
// end else
4653: GO 4666
// AddMedal ( BuildRadar , - 1 ) ;
4655: LD_STRING BuildRadar
4657: PPUSH
4658: LD_INT 1
4660: NEG
4661: PPUSH
4662: CALL_OW 101
// if tick <= 7 7$00 then
4666: LD_OWVAR 1
4670: PUSH
4671: LD_INT 14700
4673: LESSEQUAL
4674: IFFALSE 4683
// SetAchievement ( ACH_ASPEED_5 ) ;
4676: LD_STRING ACH_ASPEED_5
4678: PPUSH
4679: CALL_OW 543
// if m1 and m2 and m3 and Difficulty = 3 then
4683: LD_VAR 0 3
4687: PUSH
4688: LD_VAR 0 4
4692: AND
4693: PUSH
4694: LD_VAR 0 5
4698: AND
4699: PUSH
4700: LD_OWVAR 67
4704: PUSH
4705: LD_INT 3
4707: EQUAL
4708: AND
4709: IFFALSE 4721
// SetAchievementEX ( ACH_AMER , 5 ) ;
4711: LD_STRING ACH_AMER
4713: PPUSH
4714: LD_INT 5
4716: PPUSH
4717: CALL_OW 564
// GiveMedals ( MAIN ) ;
4721: LD_STRING MAIN
4723: PPUSH
4724: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
4728: LD_ADDR_VAR 0 2
4732: PUSH
4733: LD_INT 22
4735: PUSH
4736: LD_INT 1
4738: PUSH
4739: EMPTY
4740: LIST
4741: LIST
4742: PUSH
4743: LD_INT 21
4745: PUSH
4746: LD_INT 1
4748: PUSH
4749: EMPTY
4750: LIST
4751: LIST
4752: PUSH
4753: LD_INT 2
4755: PUSH
4756: LD_INT 25
4758: PUSH
4759: LD_INT 1
4761: PUSH
4762: EMPTY
4763: LIST
4764: LIST
4765: PUSH
4766: LD_INT 25
4768: PUSH
4769: LD_INT 2
4771: PUSH
4772: EMPTY
4773: LIST
4774: LIST
4775: PUSH
4776: LD_INT 25
4778: PUSH
4779: LD_INT 3
4781: PUSH
4782: EMPTY
4783: LIST
4784: LIST
4785: PUSH
4786: LD_INT 25
4788: PUSH
4789: LD_INT 4
4791: PUSH
4792: EMPTY
4793: LIST
4794: LIST
4795: PUSH
4796: EMPTY
4797: LIST
4798: LIST
4799: LIST
4800: LIST
4801: LIST
4802: PUSH
4803: EMPTY
4804: LIST
4805: LIST
4806: LIST
4807: PPUSH
4808: CALL_OW 69
4812: ST_TO_ADDR
// RewardPeople ( tmp ) ;
4813: LD_VAR 0 2
4817: PPUSH
4818: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
4822: LD_EXP 16
4826: PPUSH
4827: LD_EXP 2
4831: PUSH
4832: LD_STRING JMM
4834: STR
4835: PPUSH
4836: CALL_OW 38
// if IsOk ( Gladstone ) then
4840: LD_EXP 17
4844: PPUSH
4845: CALL_OW 302
4849: IFFALSE 4869
// begin SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
4851: LD_EXP 17
4855: PPUSH
4856: LD_EXP 2
4860: PUSH
4861: LD_STRING Gladstone
4863: STR
4864: PPUSH
4865: CALL_OW 38
// end ; if IsOk ( Denis ) and GetSide ( Denis ) = 1 then
4869: LD_EXP 19
4873: PPUSH
4874: CALL_OW 302
4878: PUSH
4879: LD_EXP 19
4883: PPUSH
4884: CALL_OW 255
4888: PUSH
4889: LD_INT 1
4891: EQUAL
4892: AND
4893: IFFALSE 4923
// begin SaveCharacters ( Denis , mission_prefix & Denis ) ;
4895: LD_EXP 19
4899: PPUSH
4900: LD_EXP 2
4904: PUSH
4905: LD_STRING Denis
4907: STR
4908: PPUSH
4909: CALL_OW 38
// SaveVariable ( true , DenisInDelta ) ;
4913: LD_INT 1
4915: PPUSH
4916: LD_STRING DenisInDelta
4918: PPUSH
4919: CALL_OW 39
// end ; if IsOk ( Lisa ) then
4923: LD_EXP 22
4927: PPUSH
4928: CALL_OW 302
4932: IFFALSE 4952
// begin SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
4934: LD_EXP 22
4938: PPUSH
4939: LD_EXP 2
4943: PUSH
4944: LD_STRING Lisa
4946: STR
4947: PPUSH
4948: CALL_OW 38
// end ; if IsOk ( Frank ) then
4952: LD_EXP 23
4956: PPUSH
4957: CALL_OW 302
4961: IFFALSE 4981
// begin SaveCharacters ( Frank , mission_prefix & Frank ) ;
4963: LD_EXP 23
4967: PPUSH
4968: LD_EXP 2
4972: PUSH
4973: LD_STRING Frank
4975: STR
4976: PPUSH
4977: CALL_OW 38
// end ; if IsOk ( Bobby ) then
4981: LD_EXP 24
4985: PPUSH
4986: CALL_OW 302
4990: IFFALSE 5010
// begin SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
4992: LD_EXP 24
4996: PPUSH
4997: LD_EXP 2
5001: PUSH
5002: LD_STRING Bobby
5004: STR
5005: PPUSH
5006: CALL_OW 38
// end ; if IsOk ( Cyrus ) then
5010: LD_EXP 25
5014: PPUSH
5015: CALL_OW 302
5019: IFFALSE 5039
// begin SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
5021: LD_EXP 25
5025: PPUSH
5026: LD_EXP 2
5030: PUSH
5031: LD_STRING Cyrus
5033: STR
5034: PPUSH
5035: CALL_OW 38
// end ; if IsOk ( Brown ) then
5039: LD_EXP 20
5043: PPUSH
5044: CALL_OW 302
5048: IFFALSE 5068
// begin SaveCharacters ( Brown , mission_prefix & Brown ) ;
5050: LD_EXP 20
5054: PPUSH
5055: LD_EXP 2
5059: PUSH
5060: LD_STRING Brown
5062: STR
5063: PPUSH
5064: CALL_OW 38
// end ; if IsOk ( Donaldson ) then
5068: LD_EXP 21
5072: PPUSH
5073: CALL_OW 302
5077: IFFALSE 5097
// begin SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
5079: LD_EXP 21
5083: PPUSH
5084: LD_EXP 2
5088: PUSH
5089: LD_STRING Donaldson
5091: STR
5092: PPUSH
5093: CALL_OW 38
// end ; if others then
5097: LD_EXP 26
5101: IFFALSE 5115
// SaveCharacters ( others , othersInDelta ) ;
5103: LD_EXP 26
5107: PPUSH
5108: LD_STRING othersInDelta
5110: PPUSH
5111: CALL_OW 38
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) then
5115: LD_INT 22
5117: PUSH
5118: LD_INT 1
5120: PUSH
5121: EMPTY
5122: LIST
5123: LIST
5124: PUSH
5125: LD_INT 25
5127: PUSH
5128: LD_INT 16
5130: PUSH
5131: EMPTY
5132: LIST
5133: LIST
5134: PUSH
5135: EMPTY
5136: LIST
5137: LIST
5138: PPUSH
5139: CALL_OW 69
5143: IFFALSE 5181
// SaveCharacters ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) , apeInDelta ) ;
5145: LD_INT 22
5147: PUSH
5148: LD_INT 1
5150: PUSH
5151: EMPTY
5152: LIST
5153: LIST
5154: PUSH
5155: LD_INT 25
5157: PUSH
5158: LD_INT 16
5160: PUSH
5161: EMPTY
5162: LIST
5163: LIST
5164: PUSH
5165: EMPTY
5166: LIST
5167: LIST
5168: PPUSH
5169: CALL_OW 69
5173: PPUSH
5174: LD_STRING apeInDelta
5176: PPUSH
5177: CALL_OW 38
// tmp := [ ] ;
5181: LD_ADDR_VAR 0 2
5185: PUSH
5186: EMPTY
5187: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) then
5188: LD_INT 22
5190: PUSH
5191: LD_INT 1
5193: PUSH
5194: EMPTY
5195: LIST
5196: LIST
5197: PUSH
5198: LD_INT 21
5200: PUSH
5201: LD_INT 2
5203: PUSH
5204: EMPTY
5205: LIST
5206: LIST
5207: PUSH
5208: EMPTY
5209: LIST
5210: LIST
5211: PPUSH
5212: CALL_OW 69
5216: IFFALSE 5327
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) do
5218: LD_ADDR_VAR 0 1
5222: PUSH
5223: LD_INT 22
5225: PUSH
5226: LD_INT 1
5228: PUSH
5229: EMPTY
5230: LIST
5231: LIST
5232: PUSH
5233: LD_INT 21
5235: PUSH
5236: LD_INT 2
5238: PUSH
5239: EMPTY
5240: LIST
5241: LIST
5242: PUSH
5243: EMPTY
5244: LIST
5245: LIST
5246: PPUSH
5247: CALL_OW 69
5251: PUSH
5252: FOR_IN
5253: IFFALSE 5325
// tmp := tmp ^ [ GetNation ( i ) , GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) ] ;
5255: LD_ADDR_VAR 0 2
5259: PUSH
5260: LD_VAR 0 2
5264: PUSH
5265: LD_VAR 0 1
5269: PPUSH
5270: CALL_OW 248
5274: PUSH
5275: LD_VAR 0 1
5279: PPUSH
5280: CALL_OW 265
5284: PUSH
5285: LD_VAR 0 1
5289: PPUSH
5290: CALL_OW 262
5294: PUSH
5295: LD_VAR 0 1
5299: PPUSH
5300: CALL_OW 263
5304: PUSH
5305: LD_VAR 0 1
5309: PPUSH
5310: CALL_OW 264
5314: PUSH
5315: EMPTY
5316: LIST
5317: LIST
5318: LIST
5319: LIST
5320: LIST
5321: ADD
5322: ST_TO_ADDR
5323: GO 5252
5325: POP
5326: POP
// if tmp then
5327: LD_VAR 0 2
5331: IFFALSE 5345
// SaveVariable ( tmp , vehiclesInDelta ) ;
5333: LD_VAR 0 2
5337: PPUSH
5338: LD_STRING vehiclesInDelta
5340: PPUSH
5341: CALL_OW 39
// tmp := [ ] ;
5345: LD_ADDR_VAR 0 2
5349: PUSH
5350: EMPTY
5351: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) then
5352: LD_INT 22
5354: PUSH
5355: LD_INT 1
5357: PUSH
5358: EMPTY
5359: LIST
5360: LIST
5361: PUSH
5362: LD_INT 21
5364: PUSH
5365: LD_INT 3
5367: PUSH
5368: EMPTY
5369: LIST
5370: LIST
5371: PUSH
5372: EMPTY
5373: LIST
5374: LIST
5375: PPUSH
5376: CALL_OW 69
5380: IFFALSE 5533
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
5382: LD_ADDR_VAR 0 1
5386: PUSH
5387: LD_INT 22
5389: PUSH
5390: LD_INT 1
5392: PUSH
5393: EMPTY
5394: LIST
5395: LIST
5396: PUSH
5397: LD_INT 21
5399: PUSH
5400: LD_INT 3
5402: PUSH
5403: EMPTY
5404: LIST
5405: LIST
5406: PUSH
5407: EMPTY
5408: LIST
5409: LIST
5410: PPUSH
5411: CALL_OW 69
5415: PUSH
5416: FOR_IN
5417: IFFALSE 5531
// tmp := tmp ^ [ [ GetBType ( i ) , GetBLevel ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
5419: LD_ADDR_VAR 0 2
5423: PUSH
5424: LD_VAR 0 2
5428: PUSH
5429: LD_VAR 0 1
5433: PPUSH
5434: CALL_OW 266
5438: PUSH
5439: LD_VAR 0 1
5443: PPUSH
5444: CALL_OW 267
5448: PUSH
5449: LD_VAR 0 1
5453: PPUSH
5454: CALL_OW 250
5458: PUSH
5459: LD_VAR 0 1
5463: PPUSH
5464: CALL_OW 251
5468: PUSH
5469: LD_VAR 0 1
5473: PPUSH
5474: CALL_OW 254
5478: PUSH
5479: LD_VAR 0 1
5483: PPUSH
5484: LD_INT 1
5486: PPUSH
5487: CALL_OW 268
5491: PUSH
5492: LD_VAR 0 1
5496: PPUSH
5497: LD_INT 2
5499: PPUSH
5500: CALL_OW 268
5504: PUSH
5505: LD_VAR 0 1
5509: PPUSH
5510: CALL_OW 269
5514: PUSH
5515: EMPTY
5516: LIST
5517: LIST
5518: LIST
5519: LIST
5520: LIST
5521: LIST
5522: LIST
5523: LIST
5524: PUSH
5525: EMPTY
5526: LIST
5527: ADD
5528: ST_TO_ADDR
5529: GO 5416
5531: POP
5532: POP
// if tmp then
5533: LD_VAR 0 2
5537: IFFALSE 5551
// SaveVariable ( tmp , buildingsInDelta ) ;
5539: LD_VAR 0 2
5543: PPUSH
5544: LD_STRING buildingsInDelta
5546: PPUSH
5547: CALL_OW 39
// YouWin ;
5551: CALL_OW 103
// end ; end_of_file
5555: PPOPN 5
5557: END
// export function PrepareArabianTroops ( amount , skill , area ) ; var i , un , tmp ; begin
5558: LD_INT 0
5560: PPUSH
5561: PPUSH
5562: PPUSH
5563: PPUSH
// InitHc ;
5564: CALL_OW 19
// InitUc ;
5568: CALL_OW 18
// uc_side := 2 ;
5572: LD_ADDR_OWVAR 20
5576: PUSH
5577: LD_INT 2
5579: ST_TO_ADDR
// uc_nation := 2 ;
5580: LD_ADDR_OWVAR 21
5584: PUSH
5585: LD_INT 2
5587: ST_TO_ADDR
// if not amount then
5588: LD_VAR 0 1
5592: NOT
5593: IFFALSE 5597
// exit ;
5595: GO 5720
// for i = 1 to amount do
5597: LD_ADDR_VAR 0 5
5601: PUSH
5602: DOUBLE
5603: LD_INT 1
5605: DEC
5606: ST_TO_ADDR
5607: LD_VAR 0 1
5611: PUSH
5612: FOR_TO
5613: IFFALSE 5708
// begin PrepareHuman ( false , 1 , skill ) ;
5615: LD_INT 0
5617: PPUSH
5618: LD_INT 1
5620: PPUSH
5621: LD_VAR 0 2
5625: PPUSH
5626: CALL_OW 380
// un := CreateHuman ;
5630: LD_ADDR_VAR 0 6
5634: PUSH
5635: CALL_OW 44
5639: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
5640: LD_ADDR_VAR 0 7
5644: PUSH
5645: LD_VAR 0 7
5649: PPUSH
5650: LD_INT 1
5652: PPUSH
5653: LD_VAR 0 6
5657: PPUSH
5658: CALL_OW 2
5662: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5663: LD_VAR 0 6
5667: PPUSH
5668: LD_VAR 0 3
5672: PPUSH
5673: LD_INT 0
5675: PPUSH
5676: CALL_OW 49
// if i mod 2 = 0 then
5680: LD_VAR 0 5
5684: PUSH
5685: LD_INT 2
5687: MOD
5688: PUSH
5689: LD_INT 0
5691: EQUAL
5692: IFFALSE 5706
// SetTag ( un , 11 ) ;
5694: LD_VAR 0 6
5698: PPUSH
5699: LD_INT 11
5701: PPUSH
5702: CALL_OW 109
// end ;
5706: GO 5612
5708: POP
5709: POP
// result := tmp ;
5710: LD_ADDR_VAR 0 4
5714: PUSH
5715: LD_VAR 0 7
5719: ST_TO_ADDR
// end ;
5720: LD_VAR 0 4
5724: RET
// export ar_forces , ap_killers ; every 0 0$1 trigger Delta do var i , timer , more_troops , skill , eng , un , veh , force ;
5725: LD_EXP 6
5729: IFFALSE 6596
5731: GO 5733
5733: DISABLE
5734: LD_INT 0
5736: PPUSH
5737: PPUSH
5738: PPUSH
5739: PPUSH
5740: PPUSH
5741: PPUSH
5742: PPUSH
5743: PPUSH
// begin more_troops := false ;
5744: LD_ADDR_VAR 0 3
5748: PUSH
5749: LD_INT 0
5751: ST_TO_ADDR
// skill := [ 3 , 4 , 5 ] [ Difficulty ] ;
5752: LD_ADDR_VAR 0 4
5756: PUSH
5757: LD_INT 3
5759: PUSH
5760: LD_INT 4
5762: PUSH
5763: LD_INT 5
5765: PUSH
5766: EMPTY
5767: LIST
5768: LIST
5769: LIST
5770: PUSH
5771: LD_OWVAR 67
5775: ARRAY
5776: ST_TO_ADDR
// timer := [ 5 5$00 , 4 4$00 , 3 3$00 ] [ Difficulty ] ;
5777: LD_ADDR_VAR 0 2
5781: PUSH
5782: LD_INT 10500
5784: PUSH
5785: LD_INT 8400
5787: PUSH
5788: LD_INT 6300
5790: PUSH
5791: EMPTY
5792: LIST
5793: LIST
5794: LIST
5795: PUSH
5796: LD_OWVAR 67
5800: ARRAY
5801: ST_TO_ADDR
// force := [ ] ;
5802: LD_ADDR_VAR 0 8
5806: PUSH
5807: EMPTY
5808: ST_TO_ADDR
// ar_forces := [ ] ;
5809: LD_ADDR_EXP 27
5813: PUSH
5814: EMPTY
5815: ST_TO_ADDR
// ap_killers := [ ] ;
5816: LD_ADDR_EXP 28
5820: PUSH
5821: EMPTY
5822: ST_TO_ADDR
// Wait ( timer ) ;
5823: LD_VAR 0 2
5827: PPUSH
5828: CALL_OW 67
// if Denis and GetSide ( Denis ) = 4 then
5832: LD_EXP 19
5836: PUSH
5837: LD_EXP 19
5841: PPUSH
5842: CALL_OW 255
5846: PUSH
5847: LD_INT 4
5849: EQUAL
5850: AND
5851: IFFALSE 5860
// Wait ( 0 0$45 ) ;
5853: LD_INT 1575
5855: PPUSH
5856: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) then
5860: LD_INT 22
5862: PUSH
5863: LD_INT 1
5865: PUSH
5866: EMPTY
5867: LIST
5868: LIST
5869: PUSH
5870: LD_INT 30
5872: PUSH
5873: LD_INT 4
5875: PUSH
5876: EMPTY
5877: LIST
5878: LIST
5879: PUSH
5880: EMPTY
5881: LIST
5882: LIST
5883: PPUSH
5884: CALL_OW 69
5888: IFFALSE 5905
// begin Wait ( 1 1$25 ) ;
5890: LD_INT 2975
5892: PPUSH
5893: CALL_OW 67
// more_troops := true ;
5897: LD_ADDR_VAR 0 3
5901: PUSH
5902: LD_INT 1
5904: ST_TO_ADDR
// end ; if more_troops then
5905: LD_VAR 0 3
5909: IFFALSE 6097
// begin force := PrepareArabianTroops ( [ 4 , 5 , 6 ] [ Difficulty ] , skill , arArea2 ) ;
5911: LD_ADDR_VAR 0 8
5915: PUSH
5916: LD_INT 4
5918: PUSH
5919: LD_INT 5
5921: PUSH
5922: LD_INT 6
5924: PUSH
5925: EMPTY
5926: LIST
5927: LIST
5928: LIST
5929: PUSH
5930: LD_OWVAR 67
5934: ARRAY
5935: PPUSH
5936: LD_VAR 0 4
5940: PPUSH
5941: LD_INT 14
5943: PPUSH
5944: CALL 5558 0 3
5948: ST_TO_ADDR
// veh := PrepareTank ( 2 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_heavy_machine_gun , ru_gatling_gun ] [ Difficulty ] , 90 ) ;
5949: LD_ADDR_VAR 0 7
5953: PUSH
5954: LD_INT 2
5956: PPUSH
5957: LD_INT 3
5959: PPUSH
5960: LD_INT 22
5962: PPUSH
5963: LD_INT 1
5965: PPUSH
5966: LD_INT 1
5968: PPUSH
5969: LD_INT 42
5971: PUSH
5972: LD_INT 42
5974: PUSH
5975: LD_INT 43
5977: PUSH
5978: EMPTY
5979: LIST
5980: LIST
5981: LIST
5982: PUSH
5983: LD_OWVAR 67
5987: ARRAY
5988: PPUSH
5989: LD_INT 90
5991: PPUSH
5992: CALL 490 0 7
5996: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5997: LD_VAR 0 7
6001: PPUSH
6002: LD_INT 4
6004: PPUSH
6005: CALL_OW 233
// PlaceUnitArea ( veh , arArea1 , false ) ;
6009: LD_VAR 0 7
6013: PPUSH
6014: LD_INT 13
6016: PPUSH
6017: LD_INT 0
6019: PPUSH
6020: CALL_OW 49
// uc_side := 2 ;
6024: LD_ADDR_OWVAR 20
6028: PUSH
6029: LD_INT 2
6031: ST_TO_ADDR
// uc_nation := 2 ;
6032: LD_ADDR_OWVAR 21
6036: PUSH
6037: LD_INT 2
6039: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
6040: LD_INT 0
6042: PPUSH
6043: LD_INT 1
6045: PPUSH
6046: LD_VAR 0 4
6050: PPUSH
6051: CALL_OW 380
// un := CreateHuman ;
6055: LD_ADDR_VAR 0 6
6059: PUSH
6060: CALL_OW 44
6064: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
6065: LD_VAR 0 6
6069: PPUSH
6070: LD_VAR 0 7
6074: PPUSH
6075: CALL_OW 52
// force := force ^ un ;
6079: LD_ADDR_VAR 0 8
6083: PUSH
6084: LD_VAR 0 8
6088: PUSH
6089: LD_VAR 0 6
6093: ADD
6094: ST_TO_ADDR
// end else
6095: GO 6135
// begin force := PrepareArabianTroops ( [ 3 , 4 , 5 ] [ Difficulty ] , skill , arArea2 ) ;
6097: LD_ADDR_VAR 0 8
6101: PUSH
6102: LD_INT 3
6104: PUSH
6105: LD_INT 4
6107: PUSH
6108: LD_INT 5
6110: PUSH
6111: EMPTY
6112: LIST
6113: LIST
6114: LIST
6115: PUSH
6116: LD_OWVAR 67
6120: ARRAY
6121: PPUSH
6122: LD_VAR 0 4
6126: PPUSH
6127: LD_INT 14
6129: PPUSH
6130: CALL 5558 0 3
6134: ST_TO_ADDR
// end ; if force then
6135: LD_VAR 0 8
6139: IFFALSE 6151
// ar_forces := force ;
6141: LD_ADDR_EXP 27
6145: PUSH
6146: LD_VAR 0 8
6150: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
6151: LD_INT 35
6153: PPUSH
6154: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 ;
6158: LD_INT 22
6160: PUSH
6161: LD_INT 2
6163: PUSH
6164: EMPTY
6165: LIST
6166: LIST
6167: PUSH
6168: LD_INT 21
6170: PUSH
6171: LD_INT 1
6173: PUSH
6174: EMPTY
6175: LIST
6176: LIST
6177: PUSH
6178: EMPTY
6179: LIST
6180: LIST
6181: PPUSH
6182: CALL_OW 69
6186: PUSH
6187: LD_INT 0
6189: EQUAL
6190: IFFALSE 6151
// Wait ( timer ) ;
6192: LD_VAR 0 2
6196: PPUSH
6197: CALL_OW 67
// force := PrepareArabianTroops ( [ 4 , 5 , 6 ] [ Difficulty ] , skill , [ arArea1 , arArea2 ] [ rand ( 1 , 2 ) ] ) ;
6201: LD_ADDR_VAR 0 8
6205: PUSH
6206: LD_INT 4
6208: PUSH
6209: LD_INT 5
6211: PUSH
6212: LD_INT 6
6214: PUSH
6215: EMPTY
6216: LIST
6217: LIST
6218: LIST
6219: PUSH
6220: LD_OWVAR 67
6224: ARRAY
6225: PPUSH
6226: LD_VAR 0 4
6230: PPUSH
6231: LD_INT 13
6233: PUSH
6234: LD_INT 14
6236: PUSH
6237: EMPTY
6238: LIST
6239: LIST
6240: PUSH
6241: LD_INT 1
6243: PPUSH
6244: LD_INT 2
6246: PPUSH
6247: CALL_OW 12
6251: ARRAY
6252: PPUSH
6253: CALL 5558 0 3
6257: ST_TO_ADDR
// if Difficulty > 1 and Delta then
6258: LD_OWVAR 67
6262: PUSH
6263: LD_INT 1
6265: GREATER
6266: PUSH
6267: LD_EXP 6
6271: AND
6272: IFFALSE 6351
// begin uc_side := 2 ;
6274: LD_ADDR_OWVAR 20
6278: PUSH
6279: LD_INT 2
6281: ST_TO_ADDR
// uc_nation := 2 ;
6282: LD_ADDR_OWVAR 21
6286: PUSH
6287: LD_INT 2
6289: ST_TO_ADDR
// PrepareHuman ( false , 2 , skill ) ;
6290: LD_INT 0
6292: PPUSH
6293: LD_INT 2
6295: PPUSH
6296: LD_VAR 0 4
6300: PPUSH
6301: CALL_OW 380
// eng := CreateHuman ;
6305: LD_ADDR_VAR 0 5
6309: PUSH
6310: CALL_OW 44
6314: ST_TO_ADDR
// PlaceUnitArea ( eng , arArea1 , false ) ;
6315: LD_VAR 0 5
6319: PPUSH
6320: LD_INT 13
6322: PPUSH
6323: LD_INT 0
6325: PPUSH
6326: CALL_OW 49
// Wait ( 3 ) ;
6330: LD_INT 3
6332: PPUSH
6333: CALL_OW 67
// AddComEnterUnit ( eng , Delta ) ;
6337: LD_VAR 0 5
6341: PPUSH
6342: LD_EXP 6
6346: PPUSH
6347: CALL_OW 180
// end ; if force then
6351: LD_VAR 0 8
6355: IFFALSE 6367
// ar_forces := force ;
6357: LD_ADDR_EXP 27
6361: PUSH
6362: LD_VAR 0 8
6366: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
6367: LD_INT 35
6369: PPUSH
6370: CALL_OW 67
// if eng then
6374: LD_VAR 0 5
6378: IFFALSE 6432
// if GetSide ( Delta ) = 2 and IsOk ( eng ) and not IsInUnit ( eng ) then
6380: LD_EXP 6
6384: PPUSH
6385: CALL_OW 255
6389: PUSH
6390: LD_INT 2
6392: EQUAL
6393: PUSH
6394: LD_VAR 0 5
6398: PPUSH
6399: CALL_OW 302
6403: AND
6404: PUSH
6405: LD_VAR 0 5
6409: PPUSH
6410: CALL_OW 310
6414: NOT
6415: AND
6416: IFFALSE 6432
// ComEnterUnit ( eng , Delta ) ;
6418: LD_VAR 0 5
6422: PPUSH
6423: LD_EXP 6
6427: PPUSH
6428: CALL_OW 120
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 ;
6432: LD_INT 22
6434: PUSH
6435: LD_INT 2
6437: PUSH
6438: EMPTY
6439: LIST
6440: LIST
6441: PUSH
6442: LD_INT 21
6444: PUSH
6445: LD_INT 1
6447: PUSH
6448: EMPTY
6449: LIST
6450: LIST
6451: PUSH
6452: EMPTY
6453: LIST
6454: LIST
6455: PPUSH
6456: CALL_OW 69
6460: PUSH
6461: LD_INT 0
6463: EQUAL
6464: IFFALSE 6367
// Wait ( 2 2$00 ) ;
6466: LD_INT 4200
6468: PPUSH
6469: CALL_OW 67
// ap_killers := PrepareArabianTroops ( [ 1 , 2 , 2 ] [ Difficulty ] , skill , arArea1 ) ;
6473: LD_ADDR_EXP 28
6477: PUSH
6478: LD_INT 1
6480: PUSH
6481: LD_INT 2
6483: PUSH
6484: LD_INT 2
6486: PUSH
6487: EMPTY
6488: LIST
6489: LIST
6490: LIST
6491: PUSH
6492: LD_OWVAR 67
6496: ARRAY
6497: PPUSH
6498: LD_VAR 0 4
6502: PPUSH
6503: LD_INT 13
6505: PPUSH
6506: CALL 5558 0 3
6510: ST_TO_ADDR
// Wait ( timer * 2 ) ;
6511: LD_VAR 0 2
6515: PUSH
6516: LD_INT 2
6518: MUL
6519: PPUSH
6520: CALL_OW 67
// ar_forces := PrepareArabianTroops ( [ 5 , 6 , 7 ] [ Difficulty ] , skill , arArea1 ) ^ PrepareArabianTroops ( [ 3 , 4 , 4 ] [ Difficulty ] , skill , arArea2 ) ;
6524: LD_ADDR_EXP 27
6528: PUSH
6529: LD_INT 5
6531: PUSH
6532: LD_INT 6
6534: PUSH
6535: LD_INT 7
6537: PUSH
6538: EMPTY
6539: LIST
6540: LIST
6541: LIST
6542: PUSH
6543: LD_OWVAR 67
6547: ARRAY
6548: PPUSH
6549: LD_VAR 0 4
6553: PPUSH
6554: LD_INT 13
6556: PPUSH
6557: CALL 5558 0 3
6561: PUSH
6562: LD_INT 3
6564: PUSH
6565: LD_INT 4
6567: PUSH
6568: LD_INT 4
6570: PUSH
6571: EMPTY
6572: LIST
6573: LIST
6574: LIST
6575: PUSH
6576: LD_OWVAR 67
6580: ARRAY
6581: PPUSH
6582: LD_VAR 0 4
6586: PPUSH
6587: LD_INT 14
6589: PPUSH
6590: CALL 5558 0 3
6594: ADD
6595: ST_TO_ADDR
// end ;
6596: PPOPN 8
6598: END
// every 0 0$03 trigger ar_forces do var i , target ;
6599: LD_EXP 27
6603: IFFALSE 6801
6605: GO 6607
6607: DISABLE
6608: LD_INT 0
6610: PPUSH
6611: PPUSH
// begin enable ;
6612: ENABLE
// if not ar_forces then
6613: LD_EXP 27
6617: NOT
6618: IFFALSE 6622
// exit ;
6620: GO 6801
// if Delta then
6622: LD_EXP 6
6626: IFFALSE 6640
// target := Delta else
6628: LD_ADDR_VAR 0 2
6632: PUSH
6633: LD_EXP 6
6637: ST_TO_ADDR
6638: GO 6650
// target := JMM ;
6640: LD_ADDR_VAR 0 2
6644: PUSH
6645: LD_EXP 16
6649: ST_TO_ADDR
// for i in ar_forces do
6650: LD_ADDR_VAR 0 1
6654: PUSH
6655: LD_EXP 27
6659: PUSH
6660: FOR_IN
6661: IFFALSE 6799
// begin if i in FilterAllUnits ( [ f_driving ] ) then
6663: LD_VAR 0 1
6667: PUSH
6668: LD_INT 55
6670: PUSH
6671: EMPTY
6672: LIST
6673: PPUSH
6674: CALL_OW 69
6678: IN
6679: IFFALSE 6722
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , IsInUnit ( i ) ) ) else
6681: LD_VAR 0 1
6685: PPUSH
6686: LD_INT 22
6688: PUSH
6689: LD_INT 1
6691: PUSH
6692: EMPTY
6693: LIST
6694: LIST
6695: PPUSH
6696: CALL_OW 69
6700: PPUSH
6701: LD_VAR 0 1
6705: PPUSH
6706: CALL_OW 310
6710: PPUSH
6711: CALL_OW 74
6715: PPUSH
6716: CALL_OW 115
6720: GO 6797
// if GetDistUnits ( i , target ) > 30 then
6722: LD_VAR 0 1
6726: PPUSH
6727: LD_VAR 0 2
6731: PPUSH
6732: CALL_OW 296
6736: PUSH
6737: LD_INT 30
6739: GREATER
6740: IFFALSE 6773
// ComAgressiveMove ( i , GetX ( target ) , GetY ( target ) ) else
6742: LD_VAR 0 1
6746: PPUSH
6747: LD_VAR 0 2
6751: PPUSH
6752: CALL_OW 250
6756: PPUSH
6757: LD_VAR 0 2
6761: PPUSH
6762: CALL_OW 251
6766: PPUSH
6767: CALL_OW 114
6771: GO 6797
// Attack ( i , FilterAllUnits ( [ f_enemy , 2 ] ) ) ;
6773: LD_VAR 0 1
6777: PPUSH
6778: LD_INT 81
6780: PUSH
6781: LD_INT 2
6783: PUSH
6784: EMPTY
6785: LIST
6786: LIST
6787: PPUSH
6788: CALL_OW 69
6792: PPUSH
6793: CALL 795 0 2
// end ;
6797: GO 6660
6799: POP
6800: POP
// end ;
6801: PPOPN 2
6803: END
// every 0 0$01 trigger ap_killers do var filter , i , target ;
6804: LD_EXP 28
6808: IFFALSE 6968
6810: GO 6812
6812: DISABLE
6813: LD_INT 0
6815: PPUSH
6816: PPUSH
6817: PPUSH
// begin enable ;
6818: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) ;
6819: LD_ADDR_VAR 0 1
6823: PUSH
6824: LD_INT 22
6826: PUSH
6827: LD_INT 0
6829: PUSH
6830: EMPTY
6831: LIST
6832: LIST
6833: PUSH
6834: LD_INT 25
6836: PUSH
6837: LD_INT 12
6839: PUSH
6840: EMPTY
6841: LIST
6842: LIST
6843: PUSH
6844: EMPTY
6845: LIST
6846: LIST
6847: PPUSH
6848: CALL_OW 69
6852: ST_TO_ADDR
// if not filter then
6853: LD_VAR 0 1
6857: NOT
6858: IFFALSE 6885
// begin ar_forces := ar_forces ^ ap_killers ;
6860: LD_ADDR_EXP 27
6864: PUSH
6865: LD_EXP 27
6869: PUSH
6870: LD_EXP 28
6874: ADD
6875: ST_TO_ADDR
// ap_killers := [ ] ;
6876: LD_ADDR_EXP 28
6880: PUSH
6881: EMPTY
6882: ST_TO_ADDR
// exit ;
6883: GO 6968
// end ; for i in ap_killers do
6885: LD_ADDR_VAR 0 2
6889: PUSH
6890: LD_EXP 28
6894: PUSH
6895: FOR_IN
6896: IFFALSE 6966
// begin if not IsOk ( i ) then
6898: LD_VAR 0 2
6902: PPUSH
6903: CALL_OW 302
6907: NOT
6908: IFFALSE 6912
// continue ;
6910: GO 6895
// if not HasTask ( i ) then
6912: LD_VAR 0 2
6916: PPUSH
6917: CALL_OW 314
6921: NOT
6922: IFFALSE 6944
// target := NearestUnitToUnit ( filter , i ) ;
6924: LD_ADDR_VAR 0 3
6928: PUSH
6929: LD_VAR 0 1
6933: PPUSH
6934: LD_VAR 0 2
6938: PPUSH
6939: CALL_OW 74
6943: ST_TO_ADDR
// if target then
6944: LD_VAR 0 3
6948: IFFALSE 6964
// ComAttackUnit ( i , target ) ;
6950: LD_VAR 0 2
6954: PPUSH
6955: LD_VAR 0 3
6959: PPUSH
6960: CALL_OW 115
// end ;
6964: GO 6895
6966: POP
6967: POP
// end ; end_of_file
6968: PPOPN 3
6970: END
// every 0 0$40 + 0 0$2 trigger Delta do var i , counter , cr ;
6971: LD_EXP 6
6975: IFFALSE 7107
6977: GO 6979
6979: DISABLE
6980: LD_INT 0
6982: PPUSH
6983: PPUSH
6984: PPUSH
// begin counter := [ 300 , 250 , 220 ] [ Difficulty ] ;
6985: LD_ADDR_VAR 0 2
6989: PUSH
6990: LD_INT 300
6992: PUSH
6993: LD_INT 250
6995: PUSH
6996: LD_INT 220
6998: PUSH
6999: EMPTY
7000: LIST
7001: LIST
7002: LIST
7003: PUSH
7004: LD_OWVAR 67
7008: ARRAY
7009: ST_TO_ADDR
// CreateCratesArea ( Rand ( 1 , 3 ) , cratesArea , true ) ;
7010: LD_INT 1
7012: PPUSH
7013: LD_INT 3
7015: PPUSH
7016: CALL_OW 12
7020: PPUSH
7021: LD_INT 7
7023: PPUSH
7024: LD_INT 1
7026: PPUSH
7027: CALL_OW 55
// repeat wait ( rand ( 1 1$30 , 2 2$20 ) ) ;
7031: LD_INT 3150
7033: PPUSH
7034: LD_INT 4900
7036: PPUSH
7037: CALL_OW 12
7041: PPUSH
7042: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
7046: LD_ADDR_VAR 0 3
7050: PUSH
7051: LD_INT 1
7053: PPUSH
7054: LD_INT 5
7056: PPUSH
7057: CALL_OW 12
7061: ST_TO_ADDR
// CreateCratesArea ( cr , cratesArea , true ) ;
7062: LD_VAR 0 3
7066: PPUSH
7067: LD_INT 7
7069: PPUSH
7070: LD_INT 1
7072: PPUSH
7073: CALL_OW 55
// counter := counter - cr * 10 ;
7077: LD_ADDR_VAR 0 2
7081: PUSH
7082: LD_VAR 0 2
7086: PUSH
7087: LD_VAR 0 3
7091: PUSH
7092: LD_INT 10
7094: MUL
7095: MINUS
7096: ST_TO_ADDR
// until counter <= 0 ;
7097: LD_VAR 0 2
7101: PUSH
7102: LD_INT 0
7104: LESSEQUAL
7105: IFFALSE 7031
// end ;
7107: PPOPN 3
7109: END
// every 0 0$03 trigger not Delta do var i ;
7110: LD_EXP 6
7114: NOT
7115: IFFALSE 7185
7117: GO 7119
7119: DISABLE
7120: LD_INT 0
7122: PPUSH
// begin for i = 1 to 4 - Difficulty do
7123: LD_ADDR_VAR 0 1
7127: PUSH
7128: DOUBLE
7129: LD_INT 1
7131: DEC
7132: ST_TO_ADDR
7133: LD_INT 4
7135: PUSH
7136: LD_OWVAR 67
7140: MINUS
7141: PUSH
7142: FOR_TO
7143: IFFALSE 7183
// begin CreateCratesArea ( rand ( 2 , 5 ) , deltaMainArea , true ) ;
7145: LD_INT 2
7147: PPUSH
7148: LD_INT 5
7150: PPUSH
7151: CALL_OW 12
7155: PPUSH
7156: LD_INT 8
7158: PPUSH
7159: LD_INT 1
7161: PPUSH
7162: CALL_OW 55
// Wait ( rand ( 0 0$16 , 0 0$39 ) ) ;
7166: LD_INT 560
7168: PPUSH
7169: LD_INT 1365
7171: PPUSH
7172: CALL_OW 12
7176: PPUSH
7177: CALL_OW 67
// end ;
7181: GO 7142
7183: POP
7184: POP
// end ;
7185: PPOPN 1
7187: END
// every 3 3$00 trigger tick < 15 15$00 do
7188: LD_OWVAR 1
7192: PUSH
7193: LD_INT 31500
7195: LESS
7196: IFFALSE 7256
7198: GO 7200
7200: DISABLE
// begin enable ;
7201: ENABLE
// CreateCratesAnyWhere ( rand ( 1 , 3 ) , true ) ;
7202: LD_INT 1
7204: PPUSH
7205: LD_INT 3
7207: PPUSH
7208: CALL_OW 12
7212: PPUSH
7213: LD_INT 1
7215: PPUSH
7216: CALL_OW 57
// Wait ( rand ( 0 0$38 , 0 0$59 ) ) ;
7220: LD_INT 1330
7222: PPUSH
7223: LD_INT 2065
7225: PPUSH
7226: CALL_OW 12
7230: PPUSH
7231: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 4 ) , riverArea , true ) ;
7235: LD_INT 1
7237: PPUSH
7238: LD_INT 4
7240: PPUSH
7241: CALL_OW 12
7245: PPUSH
7246: LD_INT 15
7248: PPUSH
7249: LD_INT 1
7251: PPUSH
7252: CALL_OW 55
// end ; end_of_file
7256: END
// on UnitDestroyed ( un ) do begin if un = JMM then
7257: LD_VAR 0 1
7261: PUSH
7262: LD_EXP 16
7266: EQUAL
7267: IFFALSE 7276
// YouLost ( JMM ) ;
7269: LD_STRING JMM
7271: PPUSH
7272: CALL_OW 104
// if un = Delta then
7276: LD_VAR 0 1
7280: PUSH
7281: LD_EXP 6
7285: EQUAL
7286: IFFALSE 7309
// begin Delta := 0 ;
7288: LD_ADDR_EXP 6
7292: PUSH
7293: LD_INT 0
7295: ST_TO_ADDR
// SetRestrict ( b_depot , 1 , true ) ;
7296: LD_INT 0
7298: PPUSH
7299: LD_INT 1
7301: PPUSH
7302: LD_INT 1
7304: PPUSH
7305: CALL_OW 324
// end ; if un in ar_forces then
7309: LD_VAR 0 1
7313: PUSH
7314: LD_EXP 27
7318: IN
7319: IFFALSE 7337
// ar_forces := ar_forces diff un ;
7321: LD_ADDR_EXP 27
7325: PUSH
7326: LD_EXP 27
7330: PUSH
7331: LD_VAR 0 1
7335: DIFF
7336: ST_TO_ADDR
// if un in ap_killers then
7337: LD_VAR 0 1
7341: PUSH
7342: LD_EXP 28
7346: IN
7347: IFFALSE 7365
// ap_killers := ap_killers diff un ;
7349: LD_ADDR_EXP 28
7353: PUSH
7354: LD_EXP 28
7358: PUSH
7359: LD_VAR 0 1
7363: DIFF
7364: ST_TO_ADDR
// if un in FilterAllUnits ( [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ) then
7365: LD_VAR 0 1
7369: PUSH
7370: LD_INT 2
7372: PUSH
7373: LD_INT 25
7375: PUSH
7376: LD_INT 12
7378: PUSH
7379: EMPTY
7380: LIST
7381: LIST
7382: PUSH
7383: LD_INT 25
7385: PUSH
7386: LD_INT 16
7388: PUSH
7389: EMPTY
7390: LIST
7391: LIST
7392: PUSH
7393: EMPTY
7394: LIST
7395: LIST
7396: LIST
7397: PPUSH
7398: CALL_OW 69
7402: IN
7403: IFFALSE 7419
// apeKillCounter := apeKillCounter + 1 ;
7405: LD_ADDR_EXP 15
7409: PUSH
7410: LD_EXP 15
7414: PUSH
7415: LD_INT 1
7417: PLUS
7418: ST_TO_ADDR
// end ;
7419: PPOPN 1
7421: END
// on Contact ( s1 , s2 ) do if s1 = 1 and s2 = 2 and not arab_spotted then
7422: LD_VAR 0 1
7426: PUSH
7427: LD_INT 1
7429: EQUAL
7430: PUSH
7431: LD_VAR 0 2
7435: PUSH
7436: LD_INT 2
7438: EQUAL
7439: AND
7440: PUSH
7441: LD_EXP 13
7445: NOT
7446: AND
7447: IFFALSE 7457
// arab_spotted := true ;
7449: LD_ADDR_EXP 13
7453: PUSH
7454: LD_INT 1
7456: ST_TO_ADDR
7457: PPOPN 2
7459: END
// on EndTheMissionRaised ( p ) do begin end_the_mission_allowed := false ;
7460: LD_ADDR_OWVAR 57
7464: PUSH
7465: LD_INT 0
7467: ST_TO_ADDR
// end_mission := true ;
7468: LD_ADDR_EXP 14
7472: PUSH
7473: LD_INT 1
7475: ST_TO_ADDR
// end ;
7476: PPOPN 1
7478: END
// on ApemanTamed ( apeman , sci ) do begin if GetSide ( sci ) = 1 then
7479: LD_VAR 0 2
7483: PPUSH
7484: CALL_OW 255
7488: PUSH
7489: LD_INT 1
7491: EQUAL
7492: IFFALSE 7508
// apeman_counter := apeman_counter + 1 ;
7494: LD_ADDR_EXP 12
7498: PUSH
7499: LD_EXP 12
7503: PUSH
7504: LD_INT 1
7506: PLUS
7507: ST_TO_ADDR
// if not first_apeman_tamed then
7508: LD_EXP 8
7512: NOT
7513: IFFALSE 7713
// begin first_apeman_tamed := true ;
7515: LD_ADDR_EXP 8
7519: PUSH
7520: LD_INT 1
7522: ST_TO_ADDR
// if sci = Gladstone then
7523: LD_VAR 0 2
7527: PUSH
7528: LD_EXP 17
7532: EQUAL
7533: IFFALSE 7547
// Say ( Gladstone , D7b-Glad-1 ) ;
7535: LD_EXP 17
7539: PPUSH
7540: LD_STRING D7b-Glad-1
7542: PPUSH
7543: CALL_OW 88
// if sci = Denis then
7547: LD_VAR 0 2
7551: PUSH
7552: LD_EXP 19
7556: EQUAL
7557: IFFALSE 7571
// Say ( Denis , D7a-Den-1 ) ;
7559: LD_EXP 19
7563: PPUSH
7564: LD_STRING D7a-Den-1
7566: PPUSH
7567: CALL_OW 88
// if not sci in [ JMM , Gladstone , Denis , Lisa , Frank , Bobby , Cyrus , Donaldson ] then
7571: LD_VAR 0 2
7575: PUSH
7576: LD_EXP 16
7580: PUSH
7581: LD_EXP 17
7585: PUSH
7586: LD_EXP 19
7590: PUSH
7591: LD_EXP 22
7595: PUSH
7596: LD_EXP 23
7600: PUSH
7601: LD_EXP 24
7605: PUSH
7606: LD_EXP 25
7610: PUSH
7611: LD_EXP 21
7615: PUSH
7616: EMPTY
7617: LIST
7618: LIST
7619: LIST
7620: LIST
7621: LIST
7622: LIST
7623: LIST
7624: LIST
7625: IN
7626: NOT
7627: IFFALSE 7670
// begin if GetSex ( sci ) = sex_male then
7629: LD_VAR 0 2
7633: PPUSH
7634: CALL_OW 258
7638: PUSH
7639: LD_INT 1
7641: EQUAL
7642: IFFALSE 7658
// Say ( sci , D7c-Sci1-1 ) else
7644: LD_VAR 0 2
7648: PPUSH
7649: LD_STRING D7c-Sci1-1
7651: PPUSH
7652: CALL_OW 88
7656: GO 7670
// Say ( sci , D7c-FSci1-1 ) ;
7658: LD_VAR 0 2
7662: PPUSH
7663: LD_STRING D7c-FSci1-1
7665: PPUSH
7666: CALL_OW 88
// end ; if not sci = Gladstone then
7670: LD_VAR 0 2
7674: PUSH
7675: LD_EXP 17
7679: EQUAL
7680: NOT
7681: IFFALSE 7695
// Say ( Gladstone , D7c-Glad-1 ) ;
7683: LD_EXP 17
7687: PPUSH
7688: LD_STRING D7c-Glad-1
7690: PPUSH
7691: CALL_OW 88
// if Lisa then
7695: LD_EXP 22
7699: IFFALSE 7713
// Say ( Lisa , D8-Lisa-1 ) ;
7701: LD_EXP 22
7705: PPUSH
7706: LD_STRING D8-Lisa-1
7708: PPUSH
7709: CALL_OW 88
// end ; end ; end_of_file
7713: PPOPN 2
7715: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
7716: GO 7718
7718: DISABLE
// begin ru_radar := 98 ;
7719: LD_ADDR_EXP 29
7723: PUSH
7724: LD_INT 98
7726: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
7727: LD_ADDR_EXP 30
7731: PUSH
7732: LD_INT 89
7734: ST_TO_ADDR
// us_hack := 99 ;
7735: LD_ADDR_EXP 31
7739: PUSH
7740: LD_INT 99
7742: ST_TO_ADDR
// us_artillery := 97 ;
7743: LD_ADDR_EXP 32
7747: PUSH
7748: LD_INT 97
7750: ST_TO_ADDR
// ar_bio_bomb := 91 ;
7751: LD_ADDR_EXP 33
7755: PUSH
7756: LD_INT 91
7758: ST_TO_ADDR
// end ; end_of_file end_of_file
7759: END
// export StreamModeActive , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu ; every 0 0$1 do
7760: GO 7762
7762: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
7763: LD_STRING initStreamRollete();
7765: PPUSH
7766: CALL_OW 559
// InitStreamMode ;
7770: CALL 7775 0 0
// end ;
7774: END
// function InitStreamMode ; begin
7775: LD_INT 0
7777: PPUSH
// streamModeActive := false ;
7778: LD_ADDR_EXP 34
7782: PUSH
7783: LD_INT 0
7785: ST_TO_ADDR
// sRocket := false ;
7786: LD_ADDR_EXP 37
7790: PUSH
7791: LD_INT 0
7793: ST_TO_ADDR
// sSpeed := false ;
7794: LD_ADDR_EXP 36
7798: PUSH
7799: LD_INT 0
7801: ST_TO_ADDR
// sEngine := false ;
7802: LD_ADDR_EXP 38
7806: PUSH
7807: LD_INT 0
7809: ST_TO_ADDR
// sSpec := false ;
7810: LD_ADDR_EXP 35
7814: PUSH
7815: LD_INT 0
7817: ST_TO_ADDR
// sLevel := false ;
7818: LD_ADDR_EXP 39
7822: PUSH
7823: LD_INT 0
7825: ST_TO_ADDR
// sArmoury := false ;
7826: LD_ADDR_EXP 40
7830: PUSH
7831: LD_INT 0
7833: ST_TO_ADDR
// sRadar := false ;
7834: LD_ADDR_EXP 41
7838: PUSH
7839: LD_INT 0
7841: ST_TO_ADDR
// sBunker := false ;
7842: LD_ADDR_EXP 42
7846: PUSH
7847: LD_INT 0
7849: ST_TO_ADDR
// sHack := false ;
7850: LD_ADDR_EXP 43
7854: PUSH
7855: LD_INT 0
7857: ST_TO_ADDR
// sFire := false ;
7858: LD_ADDR_EXP 44
7862: PUSH
7863: LD_INT 0
7865: ST_TO_ADDR
// sRefresh := false ;
7866: LD_ADDR_EXP 45
7870: PUSH
7871: LD_INT 0
7873: ST_TO_ADDR
// sExp := false ;
7874: LD_ADDR_EXP 46
7878: PUSH
7879: LD_INT 0
7881: ST_TO_ADDR
// sDepot := false ;
7882: LD_ADDR_EXP 47
7886: PUSH
7887: LD_INT 0
7889: ST_TO_ADDR
// sFlag := false ;
7890: LD_ADDR_EXP 48
7894: PUSH
7895: LD_INT 0
7897: ST_TO_ADDR
// sKamikadze := false ;
7898: LD_ADDR_EXP 56
7902: PUSH
7903: LD_INT 0
7905: ST_TO_ADDR
// sTroll := false ;
7906: LD_ADDR_EXP 57
7910: PUSH
7911: LD_INT 0
7913: ST_TO_ADDR
// sSlow := false ;
7914: LD_ADDR_EXP 58
7918: PUSH
7919: LD_INT 0
7921: ST_TO_ADDR
// sLack := false ;
7922: LD_ADDR_EXP 59
7926: PUSH
7927: LD_INT 0
7929: ST_TO_ADDR
// sTank := false ;
7930: LD_ADDR_EXP 61
7934: PUSH
7935: LD_INT 0
7937: ST_TO_ADDR
// sRemote := false ;
7938: LD_ADDR_EXP 62
7942: PUSH
7943: LD_INT 0
7945: ST_TO_ADDR
// sPowell := false ;
7946: LD_ADDR_EXP 63
7950: PUSH
7951: LD_INT 0
7953: ST_TO_ADDR
// sTeleport := false ;
7954: LD_ADDR_EXP 66
7958: PUSH
7959: LD_INT 0
7961: ST_TO_ADDR
// sOilTower := false ;
7962: LD_ADDR_EXP 68
7966: PUSH
7967: LD_INT 0
7969: ST_TO_ADDR
// sShovel := false ;
7970: LD_ADDR_EXP 69
7974: PUSH
7975: LD_INT 0
7977: ST_TO_ADDR
// sSheik := false ;
7978: LD_ADDR_EXP 70
7982: PUSH
7983: LD_INT 0
7985: ST_TO_ADDR
// sSold := false ;
7986: LD_ADDR_EXP 49
7990: PUSH
7991: LD_INT 0
7993: ST_TO_ADDR
// sDiff := false ;
7994: LD_ADDR_EXP 50
7998: PUSH
7999: LD_INT 0
8001: ST_TO_ADDR
// sFog := false ;
8002: LD_ADDR_EXP 53
8006: PUSH
8007: LD_INT 0
8009: ST_TO_ADDR
// sReset := false ;
8010: LD_ADDR_EXP 54
8014: PUSH
8015: LD_INT 0
8017: ST_TO_ADDR
// sSun := false ;
8018: LD_ADDR_EXP 55
8022: PUSH
8023: LD_INT 0
8025: ST_TO_ADDR
// sTiger := false ;
8026: LD_ADDR_EXP 51
8030: PUSH
8031: LD_INT 0
8033: ST_TO_ADDR
// sBomb := false ;
8034: LD_ADDR_EXP 52
8038: PUSH
8039: LD_INT 0
8041: ST_TO_ADDR
// sWound := false ;
8042: LD_ADDR_EXP 60
8046: PUSH
8047: LD_INT 0
8049: ST_TO_ADDR
// sBetray := false ;
8050: LD_ADDR_EXP 64
8054: PUSH
8055: LD_INT 0
8057: ST_TO_ADDR
// sContamin := false ;
8058: LD_ADDR_EXP 65
8062: PUSH
8063: LD_INT 0
8065: ST_TO_ADDR
// sOil := false ;
8066: LD_ADDR_EXP 67
8070: PUSH
8071: LD_INT 0
8073: ST_TO_ADDR
// sStu := false ;
8074: LD_ADDR_EXP 71
8078: PUSH
8079: LD_INT 0
8081: ST_TO_ADDR
// end ;
8082: LD_VAR 0 1
8086: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
8087: LD_VAR 0 2
8091: PUSH
8092: LD_INT 100
8094: EQUAL
8095: IFFALSE 8792
// begin if not StreamModeActive then
8097: LD_EXP 34
8101: NOT
8102: IFFALSE 8112
// StreamModeActive := true ;
8104: LD_ADDR_EXP 34
8108: PUSH
8109: LD_INT 1
8111: ST_TO_ADDR
// if p3 = 0 then
8112: LD_VAR 0 3
8116: PUSH
8117: LD_INT 0
8119: EQUAL
8120: IFFALSE 8126
// InitStreamMode ;
8122: CALL 7775 0 0
// if p3 = 1 then
8126: LD_VAR 0 3
8130: PUSH
8131: LD_INT 1
8133: EQUAL
8134: IFFALSE 8144
// sRocket := true ;
8136: LD_ADDR_EXP 37
8140: PUSH
8141: LD_INT 1
8143: ST_TO_ADDR
// if p3 = 2 then
8144: LD_VAR 0 3
8148: PUSH
8149: LD_INT 2
8151: EQUAL
8152: IFFALSE 8162
// sSpeed := true ;
8154: LD_ADDR_EXP 36
8158: PUSH
8159: LD_INT 1
8161: ST_TO_ADDR
// if p3 = 3 then
8162: LD_VAR 0 3
8166: PUSH
8167: LD_INT 3
8169: EQUAL
8170: IFFALSE 8180
// sEngine := true ;
8172: LD_ADDR_EXP 38
8176: PUSH
8177: LD_INT 1
8179: ST_TO_ADDR
// if p3 = 4 then
8180: LD_VAR 0 3
8184: PUSH
8185: LD_INT 4
8187: EQUAL
8188: IFFALSE 8198
// sSpec := true ;
8190: LD_ADDR_EXP 35
8194: PUSH
8195: LD_INT 1
8197: ST_TO_ADDR
// if p3 = 5 then
8198: LD_VAR 0 3
8202: PUSH
8203: LD_INT 5
8205: EQUAL
8206: IFFALSE 8216
// sLevel := true ;
8208: LD_ADDR_EXP 39
8212: PUSH
8213: LD_INT 1
8215: ST_TO_ADDR
// if p3 = 6 then
8216: LD_VAR 0 3
8220: PUSH
8221: LD_INT 6
8223: EQUAL
8224: IFFALSE 8234
// sArmoury := true ;
8226: LD_ADDR_EXP 40
8230: PUSH
8231: LD_INT 1
8233: ST_TO_ADDR
// if p3 = 7 then
8234: LD_VAR 0 3
8238: PUSH
8239: LD_INT 7
8241: EQUAL
8242: IFFALSE 8252
// sRadar := true ;
8244: LD_ADDR_EXP 41
8248: PUSH
8249: LD_INT 1
8251: ST_TO_ADDR
// if p3 = 8 then
8252: LD_VAR 0 3
8256: PUSH
8257: LD_INT 8
8259: EQUAL
8260: IFFALSE 8270
// sBunker := true ;
8262: LD_ADDR_EXP 42
8266: PUSH
8267: LD_INT 1
8269: ST_TO_ADDR
// if p3 = 9 then
8270: LD_VAR 0 3
8274: PUSH
8275: LD_INT 9
8277: EQUAL
8278: IFFALSE 8288
// sHack := true ;
8280: LD_ADDR_EXP 43
8284: PUSH
8285: LD_INT 1
8287: ST_TO_ADDR
// if p3 = 10 then
8288: LD_VAR 0 3
8292: PUSH
8293: LD_INT 10
8295: EQUAL
8296: IFFALSE 8306
// sFire := true ;
8298: LD_ADDR_EXP 44
8302: PUSH
8303: LD_INT 1
8305: ST_TO_ADDR
// if p3 = 11 then
8306: LD_VAR 0 3
8310: PUSH
8311: LD_INT 11
8313: EQUAL
8314: IFFALSE 8324
// sRefresh := true ;
8316: LD_ADDR_EXP 45
8320: PUSH
8321: LD_INT 1
8323: ST_TO_ADDR
// if p3 = 12 then
8324: LD_VAR 0 3
8328: PUSH
8329: LD_INT 12
8331: EQUAL
8332: IFFALSE 8342
// sExp := true ;
8334: LD_ADDR_EXP 46
8338: PUSH
8339: LD_INT 1
8341: ST_TO_ADDR
// if p3 = 13 then
8342: LD_VAR 0 3
8346: PUSH
8347: LD_INT 13
8349: EQUAL
8350: IFFALSE 8360
// sDepot := true ;
8352: LD_ADDR_EXP 47
8356: PUSH
8357: LD_INT 1
8359: ST_TO_ADDR
// if p3 = 14 then
8360: LD_VAR 0 3
8364: PUSH
8365: LD_INT 14
8367: EQUAL
8368: IFFALSE 8378
// sFlag := true ;
8370: LD_ADDR_EXP 48
8374: PUSH
8375: LD_INT 1
8377: ST_TO_ADDR
// if p3 = 15 then
8378: LD_VAR 0 3
8382: PUSH
8383: LD_INT 15
8385: EQUAL
8386: IFFALSE 8396
// sKamikadze := true ;
8388: LD_ADDR_EXP 56
8392: PUSH
8393: LD_INT 1
8395: ST_TO_ADDR
// if p3 = 16 then
8396: LD_VAR 0 3
8400: PUSH
8401: LD_INT 16
8403: EQUAL
8404: IFFALSE 8414
// sTroll := true ;
8406: LD_ADDR_EXP 57
8410: PUSH
8411: LD_INT 1
8413: ST_TO_ADDR
// if p3 = 17 then
8414: LD_VAR 0 3
8418: PUSH
8419: LD_INT 17
8421: EQUAL
8422: IFFALSE 8432
// sSlow := true ;
8424: LD_ADDR_EXP 58
8428: PUSH
8429: LD_INT 1
8431: ST_TO_ADDR
// if p3 = 18 then
8432: LD_VAR 0 3
8436: PUSH
8437: LD_INT 18
8439: EQUAL
8440: IFFALSE 8450
// sLack := true ;
8442: LD_ADDR_EXP 59
8446: PUSH
8447: LD_INT 1
8449: ST_TO_ADDR
// if p3 = 19 then
8450: LD_VAR 0 3
8454: PUSH
8455: LD_INT 19
8457: EQUAL
8458: IFFALSE 8468
// sTank := true ;
8460: LD_ADDR_EXP 61
8464: PUSH
8465: LD_INT 1
8467: ST_TO_ADDR
// if p3 = 20 then
8468: LD_VAR 0 3
8472: PUSH
8473: LD_INT 20
8475: EQUAL
8476: IFFALSE 8486
// sRemote := true ;
8478: LD_ADDR_EXP 62
8482: PUSH
8483: LD_INT 1
8485: ST_TO_ADDR
// if p3 = 21 then
8486: LD_VAR 0 3
8490: PUSH
8491: LD_INT 21
8493: EQUAL
8494: IFFALSE 8504
// sPowell := true ;
8496: LD_ADDR_EXP 63
8500: PUSH
8501: LD_INT 1
8503: ST_TO_ADDR
// if p3 = 22 then
8504: LD_VAR 0 3
8508: PUSH
8509: LD_INT 22
8511: EQUAL
8512: IFFALSE 8522
// sTeleport := true ;
8514: LD_ADDR_EXP 66
8518: PUSH
8519: LD_INT 1
8521: ST_TO_ADDR
// if p3 = 23 then
8522: LD_VAR 0 3
8526: PUSH
8527: LD_INT 23
8529: EQUAL
8530: IFFALSE 8540
// sOilTower := true ;
8532: LD_ADDR_EXP 68
8536: PUSH
8537: LD_INT 1
8539: ST_TO_ADDR
// if p3 = 24 then
8540: LD_VAR 0 3
8544: PUSH
8545: LD_INT 24
8547: EQUAL
8548: IFFALSE 8558
// sShovel := true ;
8550: LD_ADDR_EXP 69
8554: PUSH
8555: LD_INT 1
8557: ST_TO_ADDR
// if p3 = 25 then
8558: LD_VAR 0 3
8562: PUSH
8563: LD_INT 25
8565: EQUAL
8566: IFFALSE 8576
// sSheik := true ;
8568: LD_ADDR_EXP 70
8572: PUSH
8573: LD_INT 1
8575: ST_TO_ADDR
// if p3 = 101 then
8576: LD_VAR 0 3
8580: PUSH
8581: LD_INT 101
8583: EQUAL
8584: IFFALSE 8594
// sSold := true ;
8586: LD_ADDR_EXP 49
8590: PUSH
8591: LD_INT 1
8593: ST_TO_ADDR
// if p3 = 102 then
8594: LD_VAR 0 3
8598: PUSH
8599: LD_INT 102
8601: EQUAL
8602: IFFALSE 8612
// sDiff := true ;
8604: LD_ADDR_EXP 50
8608: PUSH
8609: LD_INT 1
8611: ST_TO_ADDR
// if p3 = 103 then
8612: LD_VAR 0 3
8616: PUSH
8617: LD_INT 103
8619: EQUAL
8620: IFFALSE 8630
// sFog := true ;
8622: LD_ADDR_EXP 53
8626: PUSH
8627: LD_INT 1
8629: ST_TO_ADDR
// if p3 = 104 then
8630: LD_VAR 0 3
8634: PUSH
8635: LD_INT 104
8637: EQUAL
8638: IFFALSE 8648
// sReset := true ;
8640: LD_ADDR_EXP 54
8644: PUSH
8645: LD_INT 1
8647: ST_TO_ADDR
// if p3 = 105 then
8648: LD_VAR 0 3
8652: PUSH
8653: LD_INT 105
8655: EQUAL
8656: IFFALSE 8666
// sSun := true ;
8658: LD_ADDR_EXP 55
8662: PUSH
8663: LD_INT 1
8665: ST_TO_ADDR
// if p3 = 106 then
8666: LD_VAR 0 3
8670: PUSH
8671: LD_INT 106
8673: EQUAL
8674: IFFALSE 8684
// sTiger := true ;
8676: LD_ADDR_EXP 51
8680: PUSH
8681: LD_INT 1
8683: ST_TO_ADDR
// if p3 = 107 then
8684: LD_VAR 0 3
8688: PUSH
8689: LD_INT 107
8691: EQUAL
8692: IFFALSE 8702
// sBomb := true ;
8694: LD_ADDR_EXP 52
8698: PUSH
8699: LD_INT 1
8701: ST_TO_ADDR
// if p3 = 108 then
8702: LD_VAR 0 3
8706: PUSH
8707: LD_INT 108
8709: EQUAL
8710: IFFALSE 8720
// sWound := true ;
8712: LD_ADDR_EXP 60
8716: PUSH
8717: LD_INT 1
8719: ST_TO_ADDR
// if p3 = 109 then
8720: LD_VAR 0 3
8724: PUSH
8725: LD_INT 109
8727: EQUAL
8728: IFFALSE 8738
// sBetray := true ;
8730: LD_ADDR_EXP 64
8734: PUSH
8735: LD_INT 1
8737: ST_TO_ADDR
// if p3 = 110 then
8738: LD_VAR 0 3
8742: PUSH
8743: LD_INT 110
8745: EQUAL
8746: IFFALSE 8756
// sContamin := true ;
8748: LD_ADDR_EXP 65
8752: PUSH
8753: LD_INT 1
8755: ST_TO_ADDR
// if p3 = 111 then
8756: LD_VAR 0 3
8760: PUSH
8761: LD_INT 111
8763: EQUAL
8764: IFFALSE 8774
// sOil := true ;
8766: LD_ADDR_EXP 67
8770: PUSH
8771: LD_INT 1
8773: ST_TO_ADDR
// if p3 = 112 then
8774: LD_VAR 0 3
8778: PUSH
8779: LD_INT 112
8781: EQUAL
8782: IFFALSE 8792
// sStu := true ;
8784: LD_ADDR_EXP 71
8788: PUSH
8789: LD_INT 1
8791: ST_TO_ADDR
// end ; end ;
8792: PPOPN 6
8794: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
8795: LD_EXP 34
8799: PUSH
8800: LD_EXP 37
8804: AND
8805: IFFALSE 8929
8807: GO 8809
8809: DISABLE
8810: LD_INT 0
8812: PPUSH
8813: PPUSH
// begin enable ;
8814: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
8815: LD_ADDR_VAR 0 2
8819: PUSH
8820: LD_INT 22
8822: PUSH
8823: LD_OWVAR 2
8827: PUSH
8828: EMPTY
8829: LIST
8830: LIST
8831: PUSH
8832: LD_INT 2
8834: PUSH
8835: LD_INT 34
8837: PUSH
8838: LD_INT 7
8840: PUSH
8841: EMPTY
8842: LIST
8843: LIST
8844: PUSH
8845: LD_INT 34
8847: PUSH
8848: LD_INT 45
8850: PUSH
8851: EMPTY
8852: LIST
8853: LIST
8854: PUSH
8855: LD_INT 34
8857: PUSH
8858: LD_INT 28
8860: PUSH
8861: EMPTY
8862: LIST
8863: LIST
8864: PUSH
8865: LD_INT 34
8867: PUSH
8868: LD_INT 47
8870: PUSH
8871: EMPTY
8872: LIST
8873: LIST
8874: PUSH
8875: EMPTY
8876: LIST
8877: LIST
8878: LIST
8879: LIST
8880: LIST
8881: PUSH
8882: EMPTY
8883: LIST
8884: LIST
8885: PPUSH
8886: CALL_OW 69
8890: ST_TO_ADDR
// if not tmp then
8891: LD_VAR 0 2
8895: NOT
8896: IFFALSE 8900
// exit ;
8898: GO 8929
// for i in tmp do
8900: LD_ADDR_VAR 0 1
8904: PUSH
8905: LD_VAR 0 2
8909: PUSH
8910: FOR_IN
8911: IFFALSE 8927
// begin SetLives ( i , 0 ) ;
8913: LD_VAR 0 1
8917: PPUSH
8918: LD_INT 0
8920: PPUSH
8921: CALL_OW 234
// end ;
8925: GO 8910
8927: POP
8928: POP
// end ;
8929: PPOPN 2
8931: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
8932: LD_EXP 34
8936: PUSH
8937: LD_EXP 38
8941: AND
8942: IFFALSE 9023
8944: GO 8946
8946: DISABLE
8947: LD_INT 0
8949: PPUSH
8950: PPUSH
// begin enable ;
8951: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
8952: LD_ADDR_VAR 0 2
8956: PUSH
8957: LD_INT 22
8959: PUSH
8960: LD_OWVAR 2
8964: PUSH
8965: EMPTY
8966: LIST
8967: LIST
8968: PUSH
8969: LD_INT 32
8971: PUSH
8972: LD_INT 3
8974: PUSH
8975: EMPTY
8976: LIST
8977: LIST
8978: PUSH
8979: EMPTY
8980: LIST
8981: LIST
8982: PPUSH
8983: CALL_OW 69
8987: ST_TO_ADDR
// if not tmp then
8988: LD_VAR 0 2
8992: NOT
8993: IFFALSE 8997
// exit ;
8995: GO 9023
// for i in tmp do
8997: LD_ADDR_VAR 0 1
9001: PUSH
9002: LD_VAR 0 2
9006: PUSH
9007: FOR_IN
9008: IFFALSE 9021
// begin DestroyUnit ( i ) ;
9010: LD_VAR 0 1
9014: PPUSH
9015: CALL_OW 65
// end ;
9019: GO 9007
9021: POP
9022: POP
// end ;
9023: PPOPN 2
9025: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
9026: LD_EXP 34
9030: PUSH
9031: LD_EXP 35
9035: AND
9036: IFFALSE 9129
9038: GO 9040
9040: DISABLE
9041: LD_INT 0
9043: PPUSH
// begin enable ;
9044: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
9045: LD_ADDR_VAR 0 1
9049: PUSH
9050: LD_INT 22
9052: PUSH
9053: LD_OWVAR 2
9057: PUSH
9058: EMPTY
9059: LIST
9060: LIST
9061: PUSH
9062: LD_INT 2
9064: PUSH
9065: LD_INT 25
9067: PUSH
9068: LD_INT 5
9070: PUSH
9071: EMPTY
9072: LIST
9073: LIST
9074: PUSH
9075: LD_INT 25
9077: PUSH
9078: LD_INT 9
9080: PUSH
9081: EMPTY
9082: LIST
9083: LIST
9084: PUSH
9085: LD_INT 25
9087: PUSH
9088: LD_INT 8
9090: PUSH
9091: EMPTY
9092: LIST
9093: LIST
9094: PUSH
9095: EMPTY
9096: LIST
9097: LIST
9098: LIST
9099: LIST
9100: PUSH
9101: EMPTY
9102: LIST
9103: LIST
9104: PPUSH
9105: CALL_OW 69
9109: PUSH
9110: FOR_IN
9111: IFFALSE 9127
// begin SetClass ( i , 1 ) ;
9113: LD_VAR 0 1
9117: PPUSH
9118: LD_INT 1
9120: PPUSH
9121: CALL_OW 336
// end ;
9125: GO 9110
9127: POP
9128: POP
// end ;
9129: PPOPN 1
9131: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
9132: LD_EXP 34
9136: PUSH
9137: LD_EXP 36
9141: AND
9142: PUSH
9143: LD_OWVAR 65
9147: PUSH
9148: LD_INT 7
9150: LESS
9151: AND
9152: IFFALSE 9166
9154: GO 9156
9156: DISABLE
// begin enable ;
9157: ENABLE
// game_speed := 7 ;
9158: LD_ADDR_OWVAR 65
9162: PUSH
9163: LD_INT 7
9165: ST_TO_ADDR
// end ;
9166: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
9167: LD_EXP 34
9171: PUSH
9172: LD_EXP 39
9176: AND
9177: IFFALSE 9379
9179: GO 9181
9181: DISABLE
9182: LD_INT 0
9184: PPUSH
9185: PPUSH
9186: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
9187: LD_ADDR_VAR 0 3
9191: PUSH
9192: LD_INT 81
9194: PUSH
9195: LD_OWVAR 2
9199: PUSH
9200: EMPTY
9201: LIST
9202: LIST
9203: PUSH
9204: LD_INT 21
9206: PUSH
9207: LD_INT 1
9209: PUSH
9210: EMPTY
9211: LIST
9212: LIST
9213: PUSH
9214: EMPTY
9215: LIST
9216: LIST
9217: PPUSH
9218: CALL_OW 69
9222: ST_TO_ADDR
// if not tmp then
9223: LD_VAR 0 3
9227: NOT
9228: IFFALSE 9232
// exit ;
9230: GO 9379
// if tmp > 5 then
9232: LD_VAR 0 3
9236: PUSH
9237: LD_INT 5
9239: GREATER
9240: IFFALSE 9252
// k := 5 else
9242: LD_ADDR_VAR 0 2
9246: PUSH
9247: LD_INT 5
9249: ST_TO_ADDR
9250: GO 9262
// k := tmp ;
9252: LD_ADDR_VAR 0 2
9256: PUSH
9257: LD_VAR 0 3
9261: ST_TO_ADDR
// for i := 1 to k do
9262: LD_ADDR_VAR 0 1
9266: PUSH
9267: DOUBLE
9268: LD_INT 1
9270: DEC
9271: ST_TO_ADDR
9272: LD_VAR 0 2
9276: PUSH
9277: FOR_TO
9278: IFFALSE 9377
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
9280: LD_VAR 0 3
9284: PUSH
9285: LD_VAR 0 1
9289: ARRAY
9290: PPUSH
9291: LD_VAR 0 1
9295: PUSH
9296: LD_INT 4
9298: MOD
9299: PUSH
9300: LD_INT 1
9302: PLUS
9303: PPUSH
9304: CALL_OW 259
9308: PUSH
9309: LD_INT 10
9311: LESS
9312: IFFALSE 9375
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
9314: LD_VAR 0 3
9318: PUSH
9319: LD_VAR 0 1
9323: ARRAY
9324: PPUSH
9325: LD_VAR 0 1
9329: PUSH
9330: LD_INT 4
9332: MOD
9333: PUSH
9334: LD_INT 1
9336: PLUS
9337: PPUSH
9338: LD_VAR 0 3
9342: PUSH
9343: LD_VAR 0 1
9347: ARRAY
9348: PPUSH
9349: LD_VAR 0 1
9353: PUSH
9354: LD_INT 4
9356: MOD
9357: PUSH
9358: LD_INT 1
9360: PLUS
9361: PPUSH
9362: CALL_OW 259
9366: PUSH
9367: LD_INT 1
9369: PLUS
9370: PPUSH
9371: CALL_OW 237
9375: GO 9277
9377: POP
9378: POP
// end ;
9379: PPOPN 3
9381: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
9382: LD_EXP 34
9386: PUSH
9387: LD_EXP 40
9391: AND
9392: IFFALSE 9412
9394: GO 9396
9396: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
9397: LD_INT 4
9399: PPUSH
9400: LD_OWVAR 2
9404: PPUSH
9405: LD_INT 0
9407: PPUSH
9408: CALL_OW 324
9412: END
// every 0 0$1 trigger StreamModeActive and sShovel do
9413: LD_EXP 34
9417: PUSH
9418: LD_EXP 69
9422: AND
9423: IFFALSE 9443
9425: GO 9427
9427: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
9428: LD_INT 19
9430: PPUSH
9431: LD_OWVAR 2
9435: PPUSH
9436: LD_INT 0
9438: PPUSH
9439: CALL_OW 324
9443: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
9444: LD_EXP 34
9448: PUSH
9449: LD_EXP 41
9453: AND
9454: IFFALSE 9553
9456: GO 9458
9458: DISABLE
9459: LD_INT 0
9461: PPUSH
9462: PPUSH
// begin enable ;
9463: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
9464: LD_ADDR_VAR 0 2
9468: PUSH
9469: LD_INT 22
9471: PUSH
9472: LD_OWVAR 2
9476: PUSH
9477: EMPTY
9478: LIST
9479: LIST
9480: PUSH
9481: LD_INT 2
9483: PUSH
9484: LD_INT 34
9486: PUSH
9487: LD_INT 11
9489: PUSH
9490: EMPTY
9491: LIST
9492: LIST
9493: PUSH
9494: LD_INT 34
9496: PUSH
9497: LD_INT 30
9499: PUSH
9500: EMPTY
9501: LIST
9502: LIST
9503: PUSH
9504: EMPTY
9505: LIST
9506: LIST
9507: LIST
9508: PUSH
9509: EMPTY
9510: LIST
9511: LIST
9512: PPUSH
9513: CALL_OW 69
9517: ST_TO_ADDR
// if not tmp then
9518: LD_VAR 0 2
9522: NOT
9523: IFFALSE 9527
// exit ;
9525: GO 9553
// for i in tmp do
9527: LD_ADDR_VAR 0 1
9531: PUSH
9532: LD_VAR 0 2
9536: PUSH
9537: FOR_IN
9538: IFFALSE 9551
// begin DestroyUnit ( i ) ;
9540: LD_VAR 0 1
9544: PPUSH
9545: CALL_OW 65
// end ;
9549: GO 9537
9551: POP
9552: POP
// end ;
9553: PPOPN 2
9555: END
// every 0 0$1 trigger StreamModeActive and sBunker do
9556: LD_EXP 34
9560: PUSH
9561: LD_EXP 42
9565: AND
9566: IFFALSE 9586
9568: GO 9570
9570: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
9571: LD_INT 32
9573: PPUSH
9574: LD_OWVAR 2
9578: PPUSH
9579: LD_INT 0
9581: PPUSH
9582: CALL_OW 324
9586: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
9587: LD_EXP 34
9591: PUSH
9592: LD_EXP 43
9596: AND
9597: IFFALSE 9778
9599: GO 9601
9601: DISABLE
9602: LD_INT 0
9604: PPUSH
9605: PPUSH
9606: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
9607: LD_ADDR_VAR 0 2
9611: PUSH
9612: LD_INT 22
9614: PUSH
9615: LD_OWVAR 2
9619: PUSH
9620: EMPTY
9621: LIST
9622: LIST
9623: PUSH
9624: LD_INT 33
9626: PUSH
9627: LD_INT 3
9629: PUSH
9630: EMPTY
9631: LIST
9632: LIST
9633: PUSH
9634: EMPTY
9635: LIST
9636: LIST
9637: PPUSH
9638: CALL_OW 69
9642: ST_TO_ADDR
// if not tmp then
9643: LD_VAR 0 2
9647: NOT
9648: IFFALSE 9652
// exit ;
9650: GO 9778
// side := 0 ;
9652: LD_ADDR_VAR 0 3
9656: PUSH
9657: LD_INT 0
9659: ST_TO_ADDR
// for i := 1 to 8 do
9660: LD_ADDR_VAR 0 1
9664: PUSH
9665: DOUBLE
9666: LD_INT 1
9668: DEC
9669: ST_TO_ADDR
9670: LD_INT 8
9672: PUSH
9673: FOR_TO
9674: IFFALSE 9722
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
9676: LD_OWVAR 2
9680: PUSH
9681: LD_VAR 0 1
9685: NONEQUAL
9686: PUSH
9687: LD_OWVAR 2
9691: PPUSH
9692: LD_VAR 0 1
9696: PPUSH
9697: CALL_OW 81
9701: PUSH
9702: LD_INT 2
9704: EQUAL
9705: AND
9706: IFFALSE 9720
// begin side := i ;
9708: LD_ADDR_VAR 0 3
9712: PUSH
9713: LD_VAR 0 1
9717: ST_TO_ADDR
// break ;
9718: GO 9722
// end ;
9720: GO 9673
9722: POP
9723: POP
// if not side then
9724: LD_VAR 0 3
9728: NOT
9729: IFFALSE 9733
// exit ;
9731: GO 9778
// for i := 1 to tmp do
9733: LD_ADDR_VAR 0 1
9737: PUSH
9738: DOUBLE
9739: LD_INT 1
9741: DEC
9742: ST_TO_ADDR
9743: LD_VAR 0 2
9747: PUSH
9748: FOR_TO
9749: IFFALSE 9776
// if Prob ( 30 ) then
9751: LD_INT 30
9753: PPUSH
9754: CALL_OW 13
9758: IFFALSE 9774
// SetSide ( i , side ) ;
9760: LD_VAR 0 1
9764: PPUSH
9765: LD_VAR 0 3
9769: PPUSH
9770: CALL_OW 235
9774: GO 9748
9776: POP
9777: POP
// end ;
9778: PPOPN 3
9780: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
9781: LD_EXP 34
9785: PUSH
9786: LD_EXP 45
9790: AND
9791: IFFALSE 9910
9793: GO 9795
9795: DISABLE
9796: LD_INT 0
9798: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
9799: LD_ADDR_VAR 0 1
9803: PUSH
9804: LD_INT 22
9806: PUSH
9807: LD_OWVAR 2
9811: PUSH
9812: EMPTY
9813: LIST
9814: LIST
9815: PUSH
9816: LD_INT 21
9818: PUSH
9819: LD_INT 1
9821: PUSH
9822: EMPTY
9823: LIST
9824: LIST
9825: PUSH
9826: LD_INT 3
9828: PUSH
9829: LD_INT 23
9831: PUSH
9832: LD_INT 0
9834: PUSH
9835: EMPTY
9836: LIST
9837: LIST
9838: PUSH
9839: EMPTY
9840: LIST
9841: LIST
9842: PUSH
9843: EMPTY
9844: LIST
9845: LIST
9846: LIST
9847: PPUSH
9848: CALL_OW 69
9852: PUSH
9853: FOR_IN
9854: IFFALSE 9908
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
9856: LD_VAR 0 1
9860: PPUSH
9861: CALL_OW 257
9865: PUSH
9866: LD_INT 1
9868: PUSH
9869: LD_INT 2
9871: PUSH
9872: LD_INT 3
9874: PUSH
9875: LD_INT 4
9877: PUSH
9878: EMPTY
9879: LIST
9880: LIST
9881: LIST
9882: LIST
9883: IN
9884: IFFALSE 9906
// SetClass ( un , rand ( 1 , 4 ) ) ;
9886: LD_VAR 0 1
9890: PPUSH
9891: LD_INT 1
9893: PPUSH
9894: LD_INT 4
9896: PPUSH
9897: CALL_OW 12
9901: PPUSH
9902: CALL_OW 336
9906: GO 9853
9908: POP
9909: POP
// end ;
9910: PPOPN 1
9912: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
9913: LD_EXP 34
9917: PUSH
9918: LD_EXP 44
9922: AND
9923: IFFALSE 10002
9925: GO 9927
9927: DISABLE
9928: LD_INT 0
9930: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
9931: LD_ADDR_VAR 0 1
9935: PUSH
9936: LD_INT 22
9938: PUSH
9939: LD_OWVAR 2
9943: PUSH
9944: EMPTY
9945: LIST
9946: LIST
9947: PUSH
9948: LD_INT 21
9950: PUSH
9951: LD_INT 3
9953: PUSH
9954: EMPTY
9955: LIST
9956: LIST
9957: PUSH
9958: EMPTY
9959: LIST
9960: LIST
9961: PPUSH
9962: CALL_OW 69
9966: ST_TO_ADDR
// if not tmp then
9967: LD_VAR 0 1
9971: NOT
9972: IFFALSE 9976
// exit ;
9974: GO 10002
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
9976: LD_VAR 0 1
9980: PUSH
9981: LD_INT 1
9983: PPUSH
9984: LD_VAR 0 1
9988: PPUSH
9989: CALL_OW 12
9993: ARRAY
9994: PPUSH
9995: LD_INT 100
9997: PPUSH
9998: CALL_OW 234
// end ;
10002: PPOPN 1
10004: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
10005: LD_EXP 34
10009: PUSH
10010: LD_EXP 46
10014: AND
10015: IFFALSE 10113
10017: GO 10019
10019: DISABLE
10020: LD_INT 0
10022: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
10023: LD_ADDR_VAR 0 1
10027: PUSH
10028: LD_INT 22
10030: PUSH
10031: LD_OWVAR 2
10035: PUSH
10036: EMPTY
10037: LIST
10038: LIST
10039: PUSH
10040: LD_INT 21
10042: PUSH
10043: LD_INT 1
10045: PUSH
10046: EMPTY
10047: LIST
10048: LIST
10049: PUSH
10050: EMPTY
10051: LIST
10052: LIST
10053: PPUSH
10054: CALL_OW 69
10058: ST_TO_ADDR
// if not tmp then
10059: LD_VAR 0 1
10063: NOT
10064: IFFALSE 10068
// exit ;
10066: GO 10113
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
10068: LD_VAR 0 1
10072: PUSH
10073: LD_INT 1
10075: PPUSH
10076: LD_VAR 0 1
10080: PPUSH
10081: CALL_OW 12
10085: ARRAY
10086: PPUSH
10087: LD_INT 1
10089: PPUSH
10090: LD_INT 4
10092: PPUSH
10093: CALL_OW 12
10097: PPUSH
10098: LD_INT 3000
10100: PPUSH
10101: LD_INT 9000
10103: PPUSH
10104: CALL_OW 12
10108: PPUSH
10109: CALL_OW 492
// end ;
10113: PPOPN 1
10115: END
// every 0 0$1 trigger StreamModeActive and sDepot do
10116: LD_EXP 34
10120: PUSH
10121: LD_EXP 47
10125: AND
10126: IFFALSE 10146
10128: GO 10130
10130: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
10131: LD_INT 1
10133: PPUSH
10134: LD_OWVAR 2
10138: PPUSH
10139: LD_INT 0
10141: PPUSH
10142: CALL_OW 324
10146: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
10147: LD_EXP 34
10151: PUSH
10152: LD_EXP 48
10156: AND
10157: IFFALSE 10240
10159: GO 10161
10161: DISABLE
10162: LD_INT 0
10164: PPUSH
10165: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
10166: LD_ADDR_VAR 0 2
10170: PUSH
10171: LD_INT 22
10173: PUSH
10174: LD_OWVAR 2
10178: PUSH
10179: EMPTY
10180: LIST
10181: LIST
10182: PUSH
10183: LD_INT 21
10185: PUSH
10186: LD_INT 3
10188: PUSH
10189: EMPTY
10190: LIST
10191: LIST
10192: PUSH
10193: EMPTY
10194: LIST
10195: LIST
10196: PPUSH
10197: CALL_OW 69
10201: ST_TO_ADDR
// if not tmp then
10202: LD_VAR 0 2
10206: NOT
10207: IFFALSE 10211
// exit ;
10209: GO 10240
// for i in tmp do
10211: LD_ADDR_VAR 0 1
10215: PUSH
10216: LD_VAR 0 2
10220: PUSH
10221: FOR_IN
10222: IFFALSE 10238
// SetBLevel ( i , 10 ) ;
10224: LD_VAR 0 1
10228: PPUSH
10229: LD_INT 10
10231: PPUSH
10232: CALL_OW 241
10236: GO 10221
10238: POP
10239: POP
// end ;
10240: PPOPN 2
10242: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
10243: LD_EXP 34
10247: PUSH
10248: LD_EXP 49
10252: AND
10253: IFFALSE 10364
10255: GO 10257
10257: DISABLE
10258: LD_INT 0
10260: PPUSH
10261: PPUSH
10262: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
10263: LD_ADDR_VAR 0 3
10267: PUSH
10268: LD_INT 22
10270: PUSH
10271: LD_OWVAR 2
10275: PUSH
10276: EMPTY
10277: LIST
10278: LIST
10279: PUSH
10280: LD_INT 25
10282: PUSH
10283: LD_INT 1
10285: PUSH
10286: EMPTY
10287: LIST
10288: LIST
10289: PUSH
10290: EMPTY
10291: LIST
10292: LIST
10293: PPUSH
10294: CALL_OW 69
10298: ST_TO_ADDR
// if not tmp then
10299: LD_VAR 0 3
10303: NOT
10304: IFFALSE 10308
// exit ;
10306: GO 10364
// un := tmp [ rand ( 1 , tmp ) ] ;
10308: LD_ADDR_VAR 0 2
10312: PUSH
10313: LD_VAR 0 3
10317: PUSH
10318: LD_INT 1
10320: PPUSH
10321: LD_VAR 0 3
10325: PPUSH
10326: CALL_OW 12
10330: ARRAY
10331: ST_TO_ADDR
// if Crawls ( un ) then
10332: LD_VAR 0 2
10336: PPUSH
10337: CALL_OW 318
10341: IFFALSE 10352
// ComWalk ( un ) ;
10343: LD_VAR 0 2
10347: PPUSH
10348: CALL_OW 138
// SetClass ( un , class_sniper ) ;
10352: LD_VAR 0 2
10356: PPUSH
10357: LD_INT 5
10359: PPUSH
10360: CALL_OW 336
// end ;
10364: PPOPN 3
10366: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
10367: LD_EXP 34
10371: PUSH
10372: LD_EXP 50
10376: AND
10377: PUSH
10378: LD_OWVAR 67
10382: PUSH
10383: LD_INT 3
10385: LESS
10386: AND
10387: IFFALSE 10406
10389: GO 10391
10391: DISABLE
// Difficulty := Difficulty + 1 ;
10392: LD_ADDR_OWVAR 67
10396: PUSH
10397: LD_OWVAR 67
10401: PUSH
10402: LD_INT 1
10404: PLUS
10405: ST_TO_ADDR
10406: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
10407: LD_EXP 34
10411: PUSH
10412: LD_EXP 51
10416: AND
10417: IFFALSE 10520
10419: GO 10421
10421: DISABLE
10422: LD_INT 0
10424: PPUSH
// begin for i := 1 to 5 do
10425: LD_ADDR_VAR 0 1
10429: PUSH
10430: DOUBLE
10431: LD_INT 1
10433: DEC
10434: ST_TO_ADDR
10435: LD_INT 5
10437: PUSH
10438: FOR_TO
10439: IFFALSE 10518
// begin uc_nation := nation_nature ;
10441: LD_ADDR_OWVAR 21
10445: PUSH
10446: LD_INT 0
10448: ST_TO_ADDR
// uc_side := 0 ;
10449: LD_ADDR_OWVAR 20
10453: PUSH
10454: LD_INT 0
10456: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
10457: LD_ADDR_OWVAR 29
10461: PUSH
10462: LD_INT 12
10464: PUSH
10465: LD_INT 12
10467: PUSH
10468: EMPTY
10469: LIST
10470: LIST
10471: ST_TO_ADDR
// hc_agressivity := 20 ;
10472: LD_ADDR_OWVAR 35
10476: PUSH
10477: LD_INT 20
10479: ST_TO_ADDR
// hc_class := class_tiger ;
10480: LD_ADDR_OWVAR 28
10484: PUSH
10485: LD_INT 14
10487: ST_TO_ADDR
// hc_gallery :=  ;
10488: LD_ADDR_OWVAR 33
10492: PUSH
10493: LD_STRING 
10495: ST_TO_ADDR
// hc_name :=  ;
10496: LD_ADDR_OWVAR 26
10500: PUSH
10501: LD_STRING 
10503: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
10504: CALL_OW 44
10508: PPUSH
10509: LD_INT 0
10511: PPUSH
10512: CALL_OW 51
// end ;
10516: GO 10438
10518: POP
10519: POP
// end ;
10520: PPOPN 1
10522: END
// every 0 0$1 trigger StreamModeActive and sBomb do var i , x , y , result ;
10523: LD_EXP 34
10527: PUSH
10528: LD_EXP 52
10532: AND
10533: IFFALSE 10707
10535: GO 10537
10537: DISABLE
10538: LD_INT 0
10540: PPUSH
10541: PPUSH
10542: PPUSH
10543: PPUSH
// begin result := false ;
10544: LD_ADDR_VAR 0 4
10548: PUSH
10549: LD_INT 0
10551: ST_TO_ADDR
// for i := 1 to 8 do
10552: LD_ADDR_VAR 0 1
10556: PUSH
10557: DOUBLE
10558: LD_INT 1
10560: DEC
10561: ST_TO_ADDR
10562: LD_INT 8
10564: PUSH
10565: FOR_TO
10566: IFFALSE 10677
// begin x := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
10568: LD_ADDR_VAR 0 2
10572: PUSH
10573: LD_INT 10
10575: PUSH
10576: LD_INT 50
10578: PUSH
10579: LD_INT 90
10581: PUSH
10582: LD_INT 140
10584: PUSH
10585: EMPTY
10586: LIST
10587: LIST
10588: LIST
10589: LIST
10590: PUSH
10591: LD_INT 1
10593: PPUSH
10594: LD_INT 4
10596: PPUSH
10597: CALL_OW 12
10601: ARRAY
10602: ST_TO_ADDR
// y := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
10603: LD_ADDR_VAR 0 3
10607: PUSH
10608: LD_INT 10
10610: PUSH
10611: LD_INT 50
10613: PUSH
10614: LD_INT 90
10616: PUSH
10617: LD_INT 140
10619: PUSH
10620: EMPTY
10621: LIST
10622: LIST
10623: LIST
10624: LIST
10625: PUSH
10626: LD_INT 1
10628: PPUSH
10629: LD_INT 4
10631: PPUSH
10632: CALL_OW 12
10636: ARRAY
10637: ST_TO_ADDR
// if ValidHex ( x , y ) then
10638: LD_VAR 0 2
10642: PPUSH
10643: LD_VAR 0 3
10647: PPUSH
10648: CALL_OW 488
10652: IFFALSE 10675
// begin result := [ x , y ] ;
10654: LD_ADDR_VAR 0 4
10658: PUSH
10659: LD_VAR 0 2
10663: PUSH
10664: LD_VAR 0 3
10668: PUSH
10669: EMPTY
10670: LIST
10671: LIST
10672: ST_TO_ADDR
// break ;
10673: GO 10677
// end ; end ;
10675: GO 10565
10677: POP
10678: POP
// if result then
10679: LD_VAR 0 4
10683: IFFALSE 10707
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
10685: LD_VAR 0 4
10689: PUSH
10690: LD_INT 1
10692: ARRAY
10693: PPUSH
10694: LD_VAR 0 4
10698: PUSH
10699: LD_INT 2
10701: ARRAY
10702: PPUSH
10703: CALL_OW 429
// end ;
10707: PPOPN 4
10709: END
// every 0 0$1 trigger StreamModeActive and sReset do
10710: LD_EXP 34
10714: PUSH
10715: LD_EXP 54
10719: AND
10720: IFFALSE 10732
10722: GO 10724
10724: DISABLE
// YouLost (  ) ;
10725: LD_STRING 
10727: PPUSH
10728: CALL_OW 104
10732: END
// every 0 0$1 trigger StreamModeActive and sFog do
10733: LD_EXP 34
10737: PUSH
10738: LD_EXP 53
10742: AND
10743: IFFALSE 10757
10745: GO 10747
10747: DISABLE
// FogOff ( your_side ) ;
10748: LD_OWVAR 2
10752: PPUSH
10753: CALL_OW 344
10757: END
// every 0 0$1 trigger StreamModeActive and sSun do
10758: LD_EXP 34
10762: PUSH
10763: LD_EXP 55
10767: AND
10768: IFFALSE 10796
10770: GO 10772
10772: DISABLE
// begin solar_recharge_percent := 0 ;
10773: LD_ADDR_OWVAR 79
10777: PUSH
10778: LD_INT 0
10780: ST_TO_ADDR
// wait ( 5 5$00 ) ;
10781: LD_INT 10500
10783: PPUSH
10784: CALL_OW 67
// solar_recharge_percent := 100 ;
10788: LD_ADDR_OWVAR 79
10792: PUSH
10793: LD_INT 100
10795: ST_TO_ADDR
// end ;
10796: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
10797: LD_EXP 34
10801: PUSH
10802: LD_EXP 56
10806: AND
10807: IFFALSE 11046
10809: GO 10811
10811: DISABLE
10812: LD_INT 0
10814: PPUSH
10815: PPUSH
10816: PPUSH
// begin tmp := [ ] ;
10817: LD_ADDR_VAR 0 3
10821: PUSH
10822: EMPTY
10823: ST_TO_ADDR
// for i := 1 to 6 do
10824: LD_ADDR_VAR 0 1
10828: PUSH
10829: DOUBLE
10830: LD_INT 1
10832: DEC
10833: ST_TO_ADDR
10834: LD_INT 6
10836: PUSH
10837: FOR_TO
10838: IFFALSE 10943
// begin uc_nation := nation_nature ;
10840: LD_ADDR_OWVAR 21
10844: PUSH
10845: LD_INT 0
10847: ST_TO_ADDR
// uc_side := 0 ;
10848: LD_ADDR_OWVAR 20
10852: PUSH
10853: LD_INT 0
10855: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
10856: LD_ADDR_OWVAR 29
10860: PUSH
10861: LD_INT 12
10863: PUSH
10864: LD_INT 12
10866: PUSH
10867: EMPTY
10868: LIST
10869: LIST
10870: ST_TO_ADDR
// hc_agressivity := 20 ;
10871: LD_ADDR_OWVAR 35
10875: PUSH
10876: LD_INT 20
10878: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
10879: LD_ADDR_OWVAR 28
10883: PUSH
10884: LD_INT 17
10886: ST_TO_ADDR
// hc_gallery :=  ;
10887: LD_ADDR_OWVAR 33
10891: PUSH
10892: LD_STRING 
10894: ST_TO_ADDR
// hc_name :=  ;
10895: LD_ADDR_OWVAR 26
10899: PUSH
10900: LD_STRING 
10902: ST_TO_ADDR
// un := CreateHuman ;
10903: LD_ADDR_VAR 0 2
10907: PUSH
10908: CALL_OW 44
10912: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
10913: LD_VAR 0 2
10917: PPUSH
10918: LD_INT 1
10920: PPUSH
10921: CALL_OW 51
// tmp := tmp * un ;
10925: LD_ADDR_VAR 0 3
10929: PUSH
10930: LD_VAR 0 3
10934: PUSH
10935: LD_VAR 0 2
10939: MUL
10940: ST_TO_ADDR
// end ;
10941: GO 10837
10943: POP
10944: POP
// repeat wait ( 0 0$1 ) ;
10945: LD_INT 35
10947: PPUSH
10948: CALL_OW 67
// for un in tmp do
10952: LD_ADDR_VAR 0 2
10956: PUSH
10957: LD_VAR 0 3
10961: PUSH
10962: FOR_IN
10963: IFFALSE 11037
// begin if IsDead ( un ) then
10965: LD_VAR 0 2
10969: PPUSH
10970: CALL_OW 301
10974: IFFALSE 10994
// begin tmp := tmp diff un ;
10976: LD_ADDR_VAR 0 3
10980: PUSH
10981: LD_VAR 0 3
10985: PUSH
10986: LD_VAR 0 2
10990: DIFF
10991: ST_TO_ADDR
// continue ;
10992: GO 10962
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
10994: LD_VAR 0 2
10998: PPUSH
10999: LD_INT 3
11001: PUSH
11002: LD_INT 22
11004: PUSH
11005: LD_INT 0
11007: PUSH
11008: EMPTY
11009: LIST
11010: LIST
11011: PUSH
11012: EMPTY
11013: LIST
11014: LIST
11015: PPUSH
11016: CALL_OW 69
11020: PPUSH
11021: LD_VAR 0 2
11025: PPUSH
11026: CALL_OW 74
11030: PPUSH
11031: CALL_OW 115
// end ;
11035: GO 10962
11037: POP
11038: POP
// until not tmp ;
11039: LD_VAR 0 3
11043: NOT
11044: IFFALSE 10945
// end ;
11046: PPOPN 3
11048: END
// every 0 0$1 trigger StreamModeActive and sTroll do
11049: LD_EXP 34
11053: PUSH
11054: LD_EXP 57
11058: AND
11059: IFFALSE 11085
11061: GO 11063
11063: DISABLE
// begin ToLua ( displayTroll(); ) ;
11064: LD_STRING displayTroll();
11066: PPUSH
11067: CALL_OW 559
// wait ( 3 3$00 ) ;
11071: LD_INT 6300
11073: PPUSH
11074: CALL_OW 67
// ToLua ( hideTroll(); ) ;
11078: LD_STRING hideTroll();
11080: PPUSH
11081: CALL_OW 559
// end ;
11085: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
11086: LD_EXP 34
11090: PUSH
11091: LD_EXP 58
11095: AND
11096: IFFALSE 11159
11098: GO 11100
11100: DISABLE
11101: LD_INT 0
11103: PPUSH
// begin p := 0 ;
11104: LD_ADDR_VAR 0 1
11108: PUSH
11109: LD_INT 0
11111: ST_TO_ADDR
// repeat game_speed := 1 ;
11112: LD_ADDR_OWVAR 65
11116: PUSH
11117: LD_INT 1
11119: ST_TO_ADDR
// wait ( 0 0$1 ) ;
11120: LD_INT 35
11122: PPUSH
11123: CALL_OW 67
// p := p + 1 ;
11127: LD_ADDR_VAR 0 1
11131: PUSH
11132: LD_VAR 0 1
11136: PUSH
11137: LD_INT 1
11139: PLUS
11140: ST_TO_ADDR
// until p >= 60 ;
11141: LD_VAR 0 1
11145: PUSH
11146: LD_INT 60
11148: GREATEREQUAL
11149: IFFALSE 11112
// game_speed := 4 ;
11151: LD_ADDR_OWVAR 65
11155: PUSH
11156: LD_INT 4
11158: ST_TO_ADDR
// end ;
11159: PPOPN 1
11161: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
11162: LD_EXP 34
11166: PUSH
11167: LD_EXP 59
11171: AND
11172: IFFALSE 11318
11174: GO 11176
11176: DISABLE
11177: LD_INT 0
11179: PPUSH
11180: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
11181: LD_ADDR_VAR 0 1
11185: PUSH
11186: LD_INT 22
11188: PUSH
11189: LD_OWVAR 2
11193: PUSH
11194: EMPTY
11195: LIST
11196: LIST
11197: PUSH
11198: LD_INT 2
11200: PUSH
11201: LD_INT 30
11203: PUSH
11204: LD_INT 0
11206: PUSH
11207: EMPTY
11208: LIST
11209: LIST
11210: PUSH
11211: LD_INT 30
11213: PUSH
11214: LD_INT 1
11216: PUSH
11217: EMPTY
11218: LIST
11219: LIST
11220: PUSH
11221: EMPTY
11222: LIST
11223: LIST
11224: LIST
11225: PUSH
11226: EMPTY
11227: LIST
11228: LIST
11229: PPUSH
11230: CALL_OW 69
11234: ST_TO_ADDR
// if not depot then
11235: LD_VAR 0 1
11239: NOT
11240: IFFALSE 11244
// exit ;
11242: GO 11318
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
11244: LD_ADDR_VAR 0 2
11248: PUSH
11249: LD_VAR 0 1
11253: PUSH
11254: LD_INT 1
11256: PPUSH
11257: LD_VAR 0 1
11261: PPUSH
11262: CALL_OW 12
11266: ARRAY
11267: PPUSH
11268: CALL_OW 274
11272: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
11273: LD_VAR 0 2
11277: PPUSH
11278: LD_INT 1
11280: PPUSH
11281: LD_INT 0
11283: PPUSH
11284: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
11288: LD_VAR 0 2
11292: PPUSH
11293: LD_INT 2
11295: PPUSH
11296: LD_INT 0
11298: PPUSH
11299: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
11303: LD_VAR 0 2
11307: PPUSH
11308: LD_INT 3
11310: PPUSH
11311: LD_INT 0
11313: PPUSH
11314: CALL_OW 277
// end ;
11318: PPOPN 2
11320: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
11321: LD_EXP 34
11325: PUSH
11326: LD_EXP 60
11330: AND
11331: IFFALSE 11428
11333: GO 11335
11335: DISABLE
11336: LD_INT 0
11338: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
11339: LD_ADDR_VAR 0 1
11343: PUSH
11344: LD_INT 22
11346: PUSH
11347: LD_OWVAR 2
11351: PUSH
11352: EMPTY
11353: LIST
11354: LIST
11355: PUSH
11356: LD_INT 21
11358: PUSH
11359: LD_INT 1
11361: PUSH
11362: EMPTY
11363: LIST
11364: LIST
11365: PUSH
11366: LD_INT 3
11368: PUSH
11369: LD_INT 23
11371: PUSH
11372: LD_INT 0
11374: PUSH
11375: EMPTY
11376: LIST
11377: LIST
11378: PUSH
11379: EMPTY
11380: LIST
11381: LIST
11382: PUSH
11383: EMPTY
11384: LIST
11385: LIST
11386: LIST
11387: PPUSH
11388: CALL_OW 69
11392: ST_TO_ADDR
// if not tmp then
11393: LD_VAR 0 1
11397: NOT
11398: IFFALSE 11402
// exit ;
11400: GO 11428
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
11402: LD_VAR 0 1
11406: PUSH
11407: LD_INT 1
11409: PPUSH
11410: LD_VAR 0 1
11414: PPUSH
11415: CALL_OW 12
11419: ARRAY
11420: PPUSH
11421: LD_INT 200
11423: PPUSH
11424: CALL_OW 234
// end ;
11428: PPOPN 1
11430: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
11431: LD_EXP 34
11435: PUSH
11436: LD_EXP 61
11440: AND
11441: IFFALSE 11520
11443: GO 11445
11445: DISABLE
11446: LD_INT 0
11448: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
11449: LD_ADDR_VAR 0 1
11453: PUSH
11454: LD_INT 22
11456: PUSH
11457: LD_OWVAR 2
11461: PUSH
11462: EMPTY
11463: LIST
11464: LIST
11465: PUSH
11466: LD_INT 21
11468: PUSH
11469: LD_INT 2
11471: PUSH
11472: EMPTY
11473: LIST
11474: LIST
11475: PUSH
11476: EMPTY
11477: LIST
11478: LIST
11479: PPUSH
11480: CALL_OW 69
11484: ST_TO_ADDR
// if not tmp then
11485: LD_VAR 0 1
11489: NOT
11490: IFFALSE 11494
// exit ;
11492: GO 11520
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
11494: LD_VAR 0 1
11498: PUSH
11499: LD_INT 1
11501: PPUSH
11502: LD_VAR 0 1
11506: PPUSH
11507: CALL_OW 12
11511: ARRAY
11512: PPUSH
11513: LD_INT 60
11515: PPUSH
11516: CALL_OW 234
// end ;
11520: PPOPN 1
11522: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
11523: LD_EXP 34
11527: PUSH
11528: LD_EXP 62
11532: AND
11533: IFFALSE 11632
11535: GO 11537
11537: DISABLE
11538: LD_INT 0
11540: PPUSH
11541: PPUSH
// begin enable ;
11542: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
11543: LD_ADDR_VAR 0 1
11547: PUSH
11548: LD_INT 22
11550: PUSH
11551: LD_OWVAR 2
11555: PUSH
11556: EMPTY
11557: LIST
11558: LIST
11559: PUSH
11560: LD_INT 61
11562: PUSH
11563: EMPTY
11564: LIST
11565: PUSH
11566: LD_INT 33
11568: PUSH
11569: LD_INT 2
11571: PUSH
11572: EMPTY
11573: LIST
11574: LIST
11575: PUSH
11576: EMPTY
11577: LIST
11578: LIST
11579: LIST
11580: PPUSH
11581: CALL_OW 69
11585: ST_TO_ADDR
// if not tmp then
11586: LD_VAR 0 1
11590: NOT
11591: IFFALSE 11595
// exit ;
11593: GO 11632
// for i in tmp do
11595: LD_ADDR_VAR 0 2
11599: PUSH
11600: LD_VAR 0 1
11604: PUSH
11605: FOR_IN
11606: IFFALSE 11630
// if IsControledBy ( i ) then
11608: LD_VAR 0 2
11612: PPUSH
11613: CALL_OW 312
11617: IFFALSE 11628
// ComUnlink ( i ) ;
11619: LD_VAR 0 2
11623: PPUSH
11624: CALL_OW 136
11628: GO 11605
11630: POP
11631: POP
// end ;
11632: PPOPN 2
11634: END
// every 0 0$1 trigger StreamModeActive and sPowell do
11635: LD_EXP 34
11639: PUSH
11640: LD_EXP 63
11644: AND
11645: IFFALSE 11685
11647: GO 11649
11649: DISABLE
// begin ToLua ( displayPowell(); ) ;
11650: LD_STRING displayPowell();
11652: PPUSH
11653: CALL_OW 559
// wait ( 0 0$20 ) ;
11657: LD_INT 700
11659: PPUSH
11660: CALL_OW 67
// ToLua ( displayPowell(); ) ;
11664: LD_STRING displayPowell();
11666: PPUSH
11667: CALL_OW 559
// wait ( 0 0$40 ) ;
11671: LD_INT 1400
11673: PPUSH
11674: CALL_OW 67
// ToLua ( displayPowell(); ) ;
11678: LD_STRING displayPowell();
11680: PPUSH
11681: CALL_OW 559
// end ;
11685: END
// every 0 0$1 trigger StreamModeActive and sStu do
11686: LD_EXP 34
11690: PUSH
11691: LD_EXP 71
11695: AND
11696: IFFALSE 11708
11698: GO 11700
11700: DISABLE
// begin ToLua ( displayStucuk(); ) ;
11701: LD_STRING displayStucuk();
11703: PPUSH
11704: CALL_OW 559
// end ;
11708: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
11709: LD_EXP 34
11713: PUSH
11714: LD_EXP 64
11718: AND
11719: IFFALSE 11860
11721: GO 11723
11723: DISABLE
11724: LD_INT 0
11726: PPUSH
11727: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
11728: LD_ADDR_VAR 0 2
11732: PUSH
11733: LD_INT 22
11735: PUSH
11736: LD_OWVAR 2
11740: PUSH
11741: EMPTY
11742: LIST
11743: LIST
11744: PUSH
11745: LD_INT 21
11747: PUSH
11748: LD_INT 1
11750: PUSH
11751: EMPTY
11752: LIST
11753: LIST
11754: PUSH
11755: EMPTY
11756: LIST
11757: LIST
11758: PPUSH
11759: CALL_OW 69
11763: ST_TO_ADDR
// if not tmp then
11764: LD_VAR 0 2
11768: NOT
11769: IFFALSE 11773
// exit ;
11771: GO 11860
// un := tmp [ rand ( 1 , tmp ) ] ;
11773: LD_ADDR_VAR 0 1
11777: PUSH
11778: LD_VAR 0 2
11782: PUSH
11783: LD_INT 1
11785: PPUSH
11786: LD_VAR 0 2
11790: PPUSH
11791: CALL_OW 12
11795: ARRAY
11796: ST_TO_ADDR
// SetSide ( un , 0 ) ;
11797: LD_VAR 0 1
11801: PPUSH
11802: LD_INT 0
11804: PPUSH
11805: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
11809: LD_VAR 0 1
11813: PPUSH
11814: LD_OWVAR 3
11818: PUSH
11819: LD_VAR 0 1
11823: DIFF
11824: PPUSH
11825: LD_VAR 0 1
11829: PPUSH
11830: CALL_OW 74
11834: PPUSH
11835: CALL_OW 115
// wait ( 0 0$20 ) ;
11839: LD_INT 700
11841: PPUSH
11842: CALL_OW 67
// SetSide ( un , your_side ) ;
11846: LD_VAR 0 1
11850: PPUSH
11851: LD_OWVAR 2
11855: PPUSH
11856: CALL_OW 235
// end ;
11860: PPOPN 2
11862: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
11863: LD_EXP 34
11867: PUSH
11868: LD_EXP 65
11872: AND
11873: IFFALSE 11979
11875: GO 11877
11877: DISABLE
11878: LD_INT 0
11880: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
11881: LD_ADDR_VAR 0 1
11885: PUSH
11886: LD_INT 22
11888: PUSH
11889: LD_OWVAR 2
11893: PUSH
11894: EMPTY
11895: LIST
11896: LIST
11897: PUSH
11898: LD_INT 2
11900: PUSH
11901: LD_INT 30
11903: PUSH
11904: LD_INT 0
11906: PUSH
11907: EMPTY
11908: LIST
11909: LIST
11910: PUSH
11911: LD_INT 30
11913: PUSH
11914: LD_INT 1
11916: PUSH
11917: EMPTY
11918: LIST
11919: LIST
11920: PUSH
11921: EMPTY
11922: LIST
11923: LIST
11924: LIST
11925: PUSH
11926: EMPTY
11927: LIST
11928: LIST
11929: PPUSH
11930: CALL_OW 69
11934: ST_TO_ADDR
// if not depot then
11935: LD_VAR 0 1
11939: NOT
11940: IFFALSE 11944
// exit ;
11942: GO 11979
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
11944: LD_VAR 0 1
11948: PUSH
11949: LD_INT 1
11951: ARRAY
11952: PPUSH
11953: CALL_OW 250
11957: PPUSH
11958: LD_VAR 0 1
11962: PUSH
11963: LD_INT 1
11965: ARRAY
11966: PPUSH
11967: CALL_OW 251
11971: PPUSH
11972: LD_INT 70
11974: PPUSH
11975: CALL_OW 495
// end ;
11979: PPOPN 1
11981: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
11982: LD_EXP 34
11986: PUSH
11987: LD_EXP 66
11991: AND
11992: IFFALSE 12203
11994: GO 11996
11996: DISABLE
11997: LD_INT 0
11999: PPUSH
12000: PPUSH
12001: PPUSH
12002: PPUSH
12003: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
12004: LD_ADDR_VAR 0 5
12008: PUSH
12009: LD_INT 22
12011: PUSH
12012: LD_OWVAR 2
12016: PUSH
12017: EMPTY
12018: LIST
12019: LIST
12020: PUSH
12021: LD_INT 21
12023: PUSH
12024: LD_INT 1
12026: PUSH
12027: EMPTY
12028: LIST
12029: LIST
12030: PUSH
12031: EMPTY
12032: LIST
12033: LIST
12034: PPUSH
12035: CALL_OW 69
12039: ST_TO_ADDR
// if not tmp then
12040: LD_VAR 0 5
12044: NOT
12045: IFFALSE 12049
// exit ;
12047: GO 12203
// for i in tmp do
12049: LD_ADDR_VAR 0 1
12053: PUSH
12054: LD_VAR 0 5
12058: PUSH
12059: FOR_IN
12060: IFFALSE 12201
// begin d := rand ( 0 , 5 ) ;
12062: LD_ADDR_VAR 0 4
12066: PUSH
12067: LD_INT 0
12069: PPUSH
12070: LD_INT 5
12072: PPUSH
12073: CALL_OW 12
12077: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
12078: LD_ADDR_VAR 0 2
12082: PUSH
12083: LD_VAR 0 1
12087: PPUSH
12088: CALL_OW 250
12092: PPUSH
12093: LD_VAR 0 4
12097: PPUSH
12098: LD_INT 3
12100: PPUSH
12101: LD_INT 12
12103: PPUSH
12104: CALL_OW 12
12108: PPUSH
12109: CALL_OW 272
12113: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
12114: LD_ADDR_VAR 0 3
12118: PUSH
12119: LD_VAR 0 1
12123: PPUSH
12124: CALL_OW 251
12128: PPUSH
12129: LD_VAR 0 4
12133: PPUSH
12134: LD_INT 3
12136: PPUSH
12137: LD_INT 12
12139: PPUSH
12140: CALL_OW 12
12144: PPUSH
12145: CALL_OW 273
12149: ST_TO_ADDR
// if ValidHex ( x , y ) then
12150: LD_VAR 0 2
12154: PPUSH
12155: LD_VAR 0 3
12159: PPUSH
12160: CALL_OW 488
12164: IFFALSE 12199
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
12166: LD_VAR 0 1
12170: PPUSH
12171: LD_VAR 0 2
12175: PPUSH
12176: LD_VAR 0 3
12180: PPUSH
12181: LD_INT 3
12183: PPUSH
12184: LD_INT 6
12186: PPUSH
12187: CALL_OW 12
12191: PPUSH
12192: LD_INT 1
12194: PPUSH
12195: CALL_OW 483
// end ;
12199: GO 12059
12201: POP
12202: POP
// end ;
12203: PPOPN 5
12205: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
12206: LD_EXP 34
12210: PUSH
12211: LD_EXP 67
12215: AND
12216: IFFALSE 12310
12218: GO 12220
12220: DISABLE
12221: LD_INT 0
12223: PPUSH
12224: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
12225: LD_ADDR_VAR 0 2
12229: PUSH
12230: LD_INT 22
12232: PUSH
12233: LD_OWVAR 2
12237: PUSH
12238: EMPTY
12239: LIST
12240: LIST
12241: PUSH
12242: LD_INT 32
12244: PUSH
12245: LD_INT 1
12247: PUSH
12248: EMPTY
12249: LIST
12250: LIST
12251: PUSH
12252: LD_INT 21
12254: PUSH
12255: LD_INT 2
12257: PUSH
12258: EMPTY
12259: LIST
12260: LIST
12261: PUSH
12262: EMPTY
12263: LIST
12264: LIST
12265: LIST
12266: PPUSH
12267: CALL_OW 69
12271: ST_TO_ADDR
// if not tmp then
12272: LD_VAR 0 2
12276: NOT
12277: IFFALSE 12281
// exit ;
12279: GO 12310
// for i in tmp do
12281: LD_ADDR_VAR 0 1
12285: PUSH
12286: LD_VAR 0 2
12290: PUSH
12291: FOR_IN
12292: IFFALSE 12308
// SetFuel ( i , 0 ) ;
12294: LD_VAR 0 1
12298: PPUSH
12299: LD_INT 0
12301: PPUSH
12302: CALL_OW 240
12306: GO 12291
12308: POP
12309: POP
// end ;
12310: PPOPN 2
12312: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
12313: LD_EXP 34
12317: PUSH
12318: LD_EXP 68
12322: AND
12323: IFFALSE 12389
12325: GO 12327
12327: DISABLE
12328: LD_INT 0
12330: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
12331: LD_ADDR_VAR 0 1
12335: PUSH
12336: LD_INT 22
12338: PUSH
12339: LD_OWVAR 2
12343: PUSH
12344: EMPTY
12345: LIST
12346: LIST
12347: PUSH
12348: LD_INT 30
12350: PUSH
12351: LD_INT 29
12353: PUSH
12354: EMPTY
12355: LIST
12356: LIST
12357: PUSH
12358: EMPTY
12359: LIST
12360: LIST
12361: PPUSH
12362: CALL_OW 69
12366: ST_TO_ADDR
// if not tmp then
12367: LD_VAR 0 1
12371: NOT
12372: IFFALSE 12376
// exit ;
12374: GO 12389
// DestroyUnit ( tmp [ 1 ] ) ;
12376: LD_VAR 0 1
12380: PUSH
12381: LD_INT 1
12383: ARRAY
12384: PPUSH
12385: CALL_OW 65
// end ;
12389: PPOPN 1
12391: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
12392: LD_EXP 34
12396: PUSH
12397: LD_EXP 70
12401: AND
12402: IFFALSE 12515
12404: GO 12406
12406: DISABLE
12407: LD_INT 0
12409: PPUSH
// begin uc_side := 0 ;
12410: LD_ADDR_OWVAR 20
12414: PUSH
12415: LD_INT 0
12417: ST_TO_ADDR
// uc_nation := nation_arabian ;
12418: LD_ADDR_OWVAR 21
12422: PUSH
12423: LD_INT 2
12425: ST_TO_ADDR
// PrepareHuman ( sex_male , 10 , class_desert_warior ) ;
12426: LD_INT 1
12428: PPUSH
12429: LD_INT 10
12431: PPUSH
12432: LD_INT 11
12434: PPUSH
12435: CALL_OW 380
// un := CreateHuman ;
12439: LD_ADDR_VAR 0 1
12443: PUSH
12444: CALL_OW 44
12448: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
12449: LD_VAR 0 1
12453: PPUSH
12454: LD_INT 1
12456: PPUSH
12457: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
12461: LD_INT 35
12463: PPUSH
12464: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
12468: LD_VAR 0 1
12472: PPUSH
12473: LD_INT 22
12475: PUSH
12476: LD_OWVAR 2
12480: PUSH
12481: EMPTY
12482: LIST
12483: LIST
12484: PPUSH
12485: CALL_OW 69
12489: PPUSH
12490: LD_VAR 0 1
12494: PPUSH
12495: CALL_OW 74
12499: PPUSH
12500: CALL_OW 115
// until IsDead ( un ) ;
12504: LD_VAR 0 1
12508: PPUSH
12509: CALL_OW 301
12513: IFFALSE 12461
// end ; end_of_file
12515: PPOPN 1
12517: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
12518: LD_INT 0
12520: PPUSH
12521: PPUSH
12522: PPUSH
12523: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
12524: LD_VAR 0 1
12528: PPUSH
12529: CALL_OW 264
12533: PUSH
12534: LD_EXP 33
12538: EQUAL
12539: IFFALSE 12611
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
12541: LD_INT 68
12543: PPUSH
12544: LD_VAR 0 1
12548: PPUSH
12549: CALL_OW 255
12553: PPUSH
12554: CALL_OW 321
12558: PUSH
12559: LD_INT 2
12561: EQUAL
12562: IFFALSE 12574
// eff := 70 else
12564: LD_ADDR_VAR 0 6
12568: PUSH
12569: LD_INT 70
12571: ST_TO_ADDR
12572: GO 12582
// eff := 30 ;
12574: LD_ADDR_VAR 0 6
12578: PUSH
12579: LD_INT 30
12581: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
12582: LD_VAR 0 1
12586: PPUSH
12587: CALL_OW 250
12591: PPUSH
12592: LD_VAR 0 1
12596: PPUSH
12597: CALL_OW 251
12601: PPUSH
12602: LD_VAR 0 6
12606: PPUSH
12607: CALL_OW 495
// end ; end ;
12611: LD_VAR 0 4
12615: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
12616: LD_INT 0
12618: PPUSH
12619: PPUSH
12620: PPUSH
12621: PPUSH
12622: PPUSH
12623: PPUSH
// if cmd = 124 then
12624: LD_VAR 0 1
12628: PUSH
12629: LD_INT 124
12631: EQUAL
12632: IFFALSE 12838
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
12634: LD_ADDR_VAR 0 5
12638: PUSH
12639: LD_INT 2
12641: PUSH
12642: LD_INT 34
12644: PUSH
12645: LD_INT 53
12647: PUSH
12648: EMPTY
12649: LIST
12650: LIST
12651: PUSH
12652: LD_INT 34
12654: PUSH
12655: LD_INT 14
12657: PUSH
12658: EMPTY
12659: LIST
12660: LIST
12661: PUSH
12662: EMPTY
12663: LIST
12664: LIST
12665: LIST
12666: PPUSH
12667: CALL_OW 69
12671: ST_TO_ADDR
// if not tmp then
12672: LD_VAR 0 5
12676: NOT
12677: IFFALSE 12681
// exit ;
12679: GO 12838
// for i in tmp do
12681: LD_ADDR_VAR 0 3
12685: PUSH
12686: LD_VAR 0 5
12690: PUSH
12691: FOR_IN
12692: IFFALSE 12836
// begin taskList := GetTaskList ( i ) ;
12694: LD_ADDR_VAR 0 6
12698: PUSH
12699: LD_VAR 0 3
12703: PPUSH
12704: CALL_OW 437
12708: ST_TO_ADDR
// if not taskList then
12709: LD_VAR 0 6
12713: NOT
12714: IFFALSE 12718
// continue ;
12716: GO 12691
// for j = 1 to taskList do
12718: LD_ADDR_VAR 0 4
12722: PUSH
12723: DOUBLE
12724: LD_INT 1
12726: DEC
12727: ST_TO_ADDR
12728: LD_VAR 0 6
12732: PUSH
12733: FOR_TO
12734: IFFALSE 12832
// if taskList [ j ] [ 1 ] = | then
12736: LD_VAR 0 6
12740: PUSH
12741: LD_VAR 0 4
12745: ARRAY
12746: PUSH
12747: LD_INT 1
12749: ARRAY
12750: PUSH
12751: LD_STRING |
12753: EQUAL
12754: IFFALSE 12830
// begin _taskList := Delete ( taskList , 1 ) ;
12756: LD_ADDR_VAR 0 7
12760: PUSH
12761: LD_VAR 0 6
12765: PPUSH
12766: LD_INT 1
12768: PPUSH
12769: CALL_OW 3
12773: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
12774: LD_VAR 0 3
12778: PPUSH
12779: LD_VAR 0 7
12783: PPUSH
12784: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
12788: LD_VAR 0 3
12792: PPUSH
12793: LD_VAR 0 6
12797: PUSH
12798: LD_VAR 0 4
12802: ARRAY
12803: PUSH
12804: LD_INT 2
12806: ARRAY
12807: PPUSH
12808: LD_VAR 0 6
12812: PUSH
12813: LD_VAR 0 4
12817: ARRAY
12818: PUSH
12819: LD_INT 3
12821: ARRAY
12822: PPUSH
12823: LD_INT 8
12825: PPUSH
12826: CALL 12843 0 4
// end ;
12830: GO 12733
12832: POP
12833: POP
// end ;
12834: GO 12691
12836: POP
12837: POP
// end ; end ;
12838: LD_VAR 0 2
12842: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
12843: LD_INT 0
12845: PPUSH
12846: PPUSH
12847: PPUSH
12848: PPUSH
12849: PPUSH
12850: PPUSH
12851: PPUSH
12852: PPUSH
12853: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
12854: LD_VAR 0 1
12858: NOT
12859: PUSH
12860: LD_VAR 0 2
12864: PPUSH
12865: LD_VAR 0 3
12869: PPUSH
12870: CALL_OW 488
12874: NOT
12875: OR
12876: PUSH
12877: LD_VAR 0 4
12881: NOT
12882: OR
12883: IFFALSE 12887
// exit ;
12885: GO 13227
// list := [ ] ;
12887: LD_ADDR_VAR 0 13
12891: PUSH
12892: EMPTY
12893: ST_TO_ADDR
// if x - r < 0 then
12894: LD_VAR 0 2
12898: PUSH
12899: LD_VAR 0 4
12903: MINUS
12904: PUSH
12905: LD_INT 0
12907: LESS
12908: IFFALSE 12920
// min_x := 0 else
12910: LD_ADDR_VAR 0 7
12914: PUSH
12915: LD_INT 0
12917: ST_TO_ADDR
12918: GO 12936
// min_x := x - r ;
12920: LD_ADDR_VAR 0 7
12924: PUSH
12925: LD_VAR 0 2
12929: PUSH
12930: LD_VAR 0 4
12934: MINUS
12935: ST_TO_ADDR
// if y - r < 0 then
12936: LD_VAR 0 3
12940: PUSH
12941: LD_VAR 0 4
12945: MINUS
12946: PUSH
12947: LD_INT 0
12949: LESS
12950: IFFALSE 12962
// min_y := 0 else
12952: LD_ADDR_VAR 0 8
12956: PUSH
12957: LD_INT 0
12959: ST_TO_ADDR
12960: GO 12978
// min_y := y - r ;
12962: LD_ADDR_VAR 0 8
12966: PUSH
12967: LD_VAR 0 3
12971: PUSH
12972: LD_VAR 0 4
12976: MINUS
12977: ST_TO_ADDR
// max_x := x + r ;
12978: LD_ADDR_VAR 0 9
12982: PUSH
12983: LD_VAR 0 2
12987: PUSH
12988: LD_VAR 0 4
12992: PLUS
12993: ST_TO_ADDR
// max_y := y + r ;
12994: LD_ADDR_VAR 0 10
12998: PUSH
12999: LD_VAR 0 3
13003: PUSH
13004: LD_VAR 0 4
13008: PLUS
13009: ST_TO_ADDR
// for _x = min_x to max_x do
13010: LD_ADDR_VAR 0 11
13014: PUSH
13015: DOUBLE
13016: LD_VAR 0 7
13020: DEC
13021: ST_TO_ADDR
13022: LD_VAR 0 9
13026: PUSH
13027: FOR_TO
13028: IFFALSE 13145
// for _y = min_y to max_y do
13030: LD_ADDR_VAR 0 12
13034: PUSH
13035: DOUBLE
13036: LD_VAR 0 8
13040: DEC
13041: ST_TO_ADDR
13042: LD_VAR 0 10
13046: PUSH
13047: FOR_TO
13048: IFFALSE 13141
// begin if not ValidHex ( _x , _y ) then
13050: LD_VAR 0 11
13054: PPUSH
13055: LD_VAR 0 12
13059: PPUSH
13060: CALL_OW 488
13064: NOT
13065: IFFALSE 13069
// continue ;
13067: GO 13047
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
13069: LD_VAR 0 11
13073: PPUSH
13074: LD_VAR 0 12
13078: PPUSH
13079: CALL_OW 351
13083: PUSH
13084: LD_VAR 0 11
13088: PPUSH
13089: LD_VAR 0 12
13093: PPUSH
13094: CALL_OW 554
13098: AND
13099: IFFALSE 13139
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
13101: LD_ADDR_VAR 0 13
13105: PUSH
13106: LD_VAR 0 13
13110: PPUSH
13111: LD_VAR 0 13
13115: PUSH
13116: LD_INT 1
13118: PLUS
13119: PPUSH
13120: LD_VAR 0 11
13124: PUSH
13125: LD_VAR 0 12
13129: PUSH
13130: EMPTY
13131: LIST
13132: LIST
13133: PPUSH
13134: CALL_OW 2
13138: ST_TO_ADDR
// end ;
13139: GO 13047
13141: POP
13142: POP
13143: GO 13027
13145: POP
13146: POP
// if not list then
13147: LD_VAR 0 13
13151: NOT
13152: IFFALSE 13156
// exit ;
13154: GO 13227
// for i in list do
13156: LD_ADDR_VAR 0 6
13160: PUSH
13161: LD_VAR 0 13
13165: PUSH
13166: FOR_IN
13167: IFFALSE 13225
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
13169: LD_VAR 0 1
13173: PPUSH
13174: LD_STRING M
13176: PUSH
13177: LD_VAR 0 6
13181: PUSH
13182: LD_INT 1
13184: ARRAY
13185: PUSH
13186: LD_VAR 0 6
13190: PUSH
13191: LD_INT 2
13193: ARRAY
13194: PUSH
13195: LD_INT 0
13197: PUSH
13198: LD_INT 0
13200: PUSH
13201: LD_INT 0
13203: PUSH
13204: LD_INT 0
13206: PUSH
13207: EMPTY
13208: LIST
13209: LIST
13210: LIST
13211: LIST
13212: LIST
13213: LIST
13214: LIST
13215: PUSH
13216: EMPTY
13217: LIST
13218: PPUSH
13219: CALL_OW 447
13223: GO 13166
13225: POP
13226: POP
// end ;
13227: LD_VAR 0 5
13231: RET
