// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// Init ;
  15: CALL 79 0 0
// InitRestrictions ;
  19: CALL 207 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 33
// DebugMode ;
  29: CALL 288 0 0
// SpawnApeman ( apemanStartArea , 2 ) ;
  33: LD_INT 12
  35: PPUSH
  36: LD_INT 2
  38: PPUSH
  39: CALL 658 0 2
// SpawnApeman ( apemanArea , [ 10 , 8 , 7 ] [ Difficulty ] ) ;
  43: LD_INT 11
  45: PPUSH
  46: LD_INT 10
  48: PUSH
  49: LD_INT 8
  51: PUSH
  52: LD_INT 7
  54: PUSH
  55: EMPTY
  56: LIST
  57: LIST
  58: LIST
  59: PUSH
  60: LD_OWVAR 67
  64: ARRAY
  65: PPUSH
  66: CALL 658 0 2
// PrepareAmericans ;
  70: CALL 1257 0 0
// Action ;
  74: CALL 2147 0 0
// end ;
  78: END
// export debug ; export mission_prefix , mission_prefix_prev ; export deltaBuilded , denisArrives , Delta , radar_allowed , first_apeman_tamed , apeman_army , radar_researched , radar_builded ; export apeman_counter , arab_spotted , end_mission , apeKillCounter ; function Init ; begin
  79: LD_INT 0
  81: PPUSH
// debug := false ;
  82: LD_ADDR_EXP 1
  86: PUSH
  87: LD_INT 0
  89: ST_TO_ADDR
// mission_prefix := 05_ ;
  90: LD_ADDR_EXP 2
  94: PUSH
  95: LD_STRING 05_
  97: ST_TO_ADDR
// mission_prefix_prev := 05a_ ;
  98: LD_ADDR_EXP 3
 102: PUSH
 103: LD_STRING 05a_
 105: ST_TO_ADDR
// deltaBuilded := false ;
 106: LD_ADDR_EXP 4
 110: PUSH
 111: LD_INT 0
 113: ST_TO_ADDR
// denisArrives := false ;
 114: LD_ADDR_EXP 5
 118: PUSH
 119: LD_INT 0
 121: ST_TO_ADDR
// radar_allowed := false ;
 122: LD_ADDR_EXP 7
 126: PUSH
 127: LD_INT 0
 129: ST_TO_ADDR
// first_apeman_tamed := false ;
 130: LD_ADDR_EXP 8
 134: PUSH
 135: LD_INT 0
 137: ST_TO_ADDR
// arab_spotted := false ;
 138: LD_ADDR_EXP 13
 142: PUSH
 143: LD_INT 0
 145: ST_TO_ADDR
// end_mission := false ;
 146: LD_ADDR_EXP 14
 150: PUSH
 151: LD_INT 0
 153: ST_TO_ADDR
// apeman_army := false ;
 154: LD_ADDR_EXP 9
 158: PUSH
 159: LD_INT 0
 161: ST_TO_ADDR
// radar_researched := false ;
 162: LD_ADDR_EXP 10
 166: PUSH
 167: LD_INT 0
 169: ST_TO_ADDR
// radar_builded := false ;
 170: LD_ADDR_EXP 11
 174: PUSH
 175: LD_INT 0
 177: ST_TO_ADDR
// apeman_counter := 0 ;
 178: LD_ADDR_EXP 12
 182: PUSH
 183: LD_INT 0
 185: ST_TO_ADDR
// Delta := 0 ;
 186: LD_ADDR_EXP 6
 190: PUSH
 191: LD_INT 0
 193: ST_TO_ADDR
// apeKillCounter := 0 ;
 194: LD_ADDR_EXP 15
 198: PUSH
 199: LD_INT 0
 201: ST_TO_ADDR
// end ;
 202: LD_VAR 0 1
 206: RET
// function InitRestrictions ; begin
 207: LD_INT 0
 209: PPUSH
// SetRestrict ( b_lab_half , 1 , state_enabled ) ;
 210: LD_INT 7
 212: PPUSH
 213: LD_INT 1
 215: PPUSH
 216: LD_INT 1
 218: PPUSH
 219: CALL_OW 324
// SetRestrict ( b_lab_full , 1 , state_enabled ) ;
 223: LD_INT 8
 225: PPUSH
 226: LD_INT 1
 228: PPUSH
 229: LD_INT 1
 231: PPUSH
 232: CALL_OW 324
// SetRestrict ( b_lab_weapon , 1 , state_enabled ) ;
 236: LD_INT 10
 238: PPUSH
 239: LD_INT 1
 241: PPUSH
 242: LD_INT 1
 244: PPUSH
 245: CALL_OW 324
// SetTech ( tech_gatling , 1 , LoadVariable ( GatlingInGamma , 1 ) ) ;
 249: LD_INT 69
 251: PPUSH
 252: LD_INT 1
 254: PPUSH
 255: LD_STRING GatlingInGamma
 257: PPUSH
 258: LD_INT 1
 260: PPUSH
 261: CALL_OW 30
 265: PPUSH
 266: CALL_OW 322
// SetTech ( tech_weap1 , 1 , state_enabled ) ;
 270: LD_INT 51
 272: PPUSH
 273: LD_INT 1
 275: PPUSH
 276: LD_INT 1
 278: PPUSH
 279: CALL_OW 322
// end ;
 283: LD_VAR 0 1
 287: RET
// function DebugMode ; begin
 288: LD_INT 0
 290: PPUSH
// FogOff ( 1 ) ;
 291: LD_INT 1
 293: PPUSH
 294: CALL_OW 344
// Difficulty := 2 ;
 298: LD_ADDR_OWVAR 67
 302: PUSH
 303: LD_INT 2
 305: ST_TO_ADDR
// end ;
 306: LD_VAR 0 1
 310: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 0 ] ] ) >= 7 do
 311: LD_INT 22
 313: PUSH
 314: LD_INT 1
 316: PUSH
 317: EMPTY
 318: LIST
 319: LIST
 320: PUSH
 321: LD_INT 23
 323: PUSH
 324: LD_INT 0
 326: PUSH
 327: EMPTY
 328: LIST
 329: LIST
 330: PUSH
 331: EMPTY
 332: LIST
 333: LIST
 334: PPUSH
 335: CALL_OW 69
 339: PUSH
 340: LD_INT 7
 342: GREATEREQUAL
 343: IFFALSE 355
 345: GO 347
 347: DISABLE
// SetAchievement ( ACH_TAME ) ;
 348: LD_STRING ACH_TAME
 350: PPUSH
 351: CALL_OW 543
 355: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_bweapon , us_radar ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) do
 356: LD_INT 22
 358: PUSH
 359: LD_INT 1
 361: PUSH
 362: EMPTY
 363: LIST
 364: LIST
 365: PUSH
 366: LD_INT 35
 368: PUSH
 369: LD_INT 11
 371: PUSH
 372: EMPTY
 373: LIST
 374: LIST
 375: PUSH
 376: EMPTY
 377: LIST
 378: LIST
 379: PPUSH
 380: CALL_OW 69
 384: PUSH
 385: LD_INT 22
 387: PUSH
 388: LD_INT 1
 390: PUSH
 391: EMPTY
 392: LIST
 393: LIST
 394: PUSH
 395: LD_INT 34
 397: PUSH
 398: LD_INT 11
 400: PUSH
 401: EMPTY
 402: LIST
 403: LIST
 404: PUSH
 405: EMPTY
 406: LIST
 407: LIST
 408: PPUSH
 409: CALL_OW 69
 413: AND
 414: IFFALSE 426
 416: GO 418
 418: DISABLE
// SetAchievement ( ACH_RADAR ) ; end_of_file
 419: LD_STRING ACH_RADAR
 421: PPUSH
 422: CALL_OW 543
 426: END
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 427: LD_INT 0
 429: PPUSH
 430: PPUSH
// if exist_mode then
 431: LD_VAR 0 2
 435: IFFALSE 460
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 437: LD_ADDR_VAR 0 4
 441: PUSH
 442: LD_EXP 3
 446: PUSH
 447: LD_VAR 0 1
 451: STR
 452: PPUSH
 453: CALL_OW 34
 457: ST_TO_ADDR
 458: GO 475
// unit := NewCharacter ( ident ) ;
 460: LD_ADDR_VAR 0 4
 464: PUSH
 465: LD_VAR 0 1
 469: PPUSH
 470: CALL_OW 25
 474: ST_TO_ADDR
// result := unit ;
 475: LD_ADDR_VAR 0 3
 479: PUSH
 480: LD_VAR 0 4
 484: ST_TO_ADDR
// end ;
 485: LD_VAR 0 3
 489: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 490: LD_INT 0
 492: PPUSH
// uc_side := side ;
 493: LD_ADDR_OWVAR 20
 497: PUSH
 498: LD_VAR 0 1
 502: ST_TO_ADDR
// uc_nation := nation ;
 503: LD_ADDR_OWVAR 21
 507: PUSH
 508: LD_VAR 0 2
 512: ST_TO_ADDR
// vc_chassis := chassis ;
 513: LD_ADDR_OWVAR 37
 517: PUSH
 518: LD_VAR 0 3
 522: ST_TO_ADDR
// vc_engine := engine ;
 523: LD_ADDR_OWVAR 39
 527: PUSH
 528: LD_VAR 0 4
 532: ST_TO_ADDR
// vc_control := control ;
 533: LD_ADDR_OWVAR 38
 537: PUSH
 538: LD_VAR 0 5
 542: ST_TO_ADDR
// vc_weapon := weapon ;
 543: LD_ADDR_OWVAR 40
 547: PUSH
 548: LD_VAR 0 6
 552: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 553: LD_ADDR_OWVAR 41
 557: PUSH
 558: LD_VAR 0 7
 562: ST_TO_ADDR
// result := CreateVehicle ;
 563: LD_ADDR_VAR 0 8
 567: PUSH
 568: CALL_OW 45
 572: ST_TO_ADDR
// end ;
 573: LD_VAR 0 8
 577: RET
// export function SayX ( units , ident ) ; var i ; begin
 578: LD_INT 0
 580: PPUSH
 581: PPUSH
// result := false ;
 582: LD_ADDR_VAR 0 3
 586: PUSH
 587: LD_INT 0
 589: ST_TO_ADDR
// if not units then
 590: LD_VAR 0 1
 594: NOT
 595: IFFALSE 599
// exit ;
 597: GO 653
// for i in units do
 599: LD_ADDR_VAR 0 4
 603: PUSH
 604: LD_VAR 0 1
 608: PUSH
 609: FOR_IN
 610: IFFALSE 651
// if IsOk ( i ) then
 612: LD_VAR 0 4
 616: PPUSH
 617: CALL_OW 302
 621: IFFALSE 649
// begin Say ( i , ident ) ;
 623: LD_VAR 0 4
 627: PPUSH
 628: LD_VAR 0 2
 632: PPUSH
 633: CALL_OW 88
// result := i ;
 637: LD_ADDR_VAR 0 3
 641: PUSH
 642: LD_VAR 0 4
 646: ST_TO_ADDR
// break ;
 647: GO 651
// end ;
 649: GO 609
 651: POP
 652: POP
// end ;
 653: LD_VAR 0 3
 657: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 658: LD_INT 0
 660: PPUSH
 661: PPUSH
// InitUc ;
 662: CALL_OW 18
// InitHc ;
 666: CALL_OW 19
// uc_side := 0 ;
 670: LD_ADDR_OWVAR 20
 674: PUSH
 675: LD_INT 0
 677: ST_TO_ADDR
// uc_nation := 0 ;
 678: LD_ADDR_OWVAR 21
 682: PUSH
 683: LD_INT 0
 685: ST_TO_ADDR
// for i = 1 to amount do
 686: LD_ADDR_VAR 0 4
 690: PUSH
 691: DOUBLE
 692: LD_INT 1
 694: DEC
 695: ST_TO_ADDR
 696: LD_VAR 0 2
 700: PUSH
 701: FOR_TO
 702: IFFALSE 784
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 704: LD_ADDR_OWVAR 29
 708: PUSH
 709: LD_INT 9
 711: PPUSH
 712: LD_INT 12
 714: PPUSH
 715: CALL_OW 12
 719: PUSH
 720: LD_INT 9
 722: PPUSH
 723: LD_INT 12
 725: PPUSH
 726: CALL_OW 12
 730: PUSH
 731: EMPTY
 732: LIST
 733: LIST
 734: ST_TO_ADDR
// hc_agressivity := rand ( - 5 , 5 ) ;
 735: LD_ADDR_OWVAR 35
 739: PUSH
 740: LD_INT 5
 742: NEG
 743: PPUSH
 744: LD_INT 5
 746: PPUSH
 747: CALL_OW 12
 751: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 752: LD_INT 0
 754: PPUSH
 755: LD_INT 12
 757: PPUSH
 758: LD_INT 1
 760: PPUSH
 761: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 765: CALL_OW 44
 769: PPUSH
 770: LD_VAR 0 1
 774: PPUSH
 775: LD_INT 0
 777: PPUSH
 778: CALL_OW 49
// end ;
 782: GO 701
 784: POP
 785: POP
// InitHc ;
 786: CALL_OW 19
// end ;
 790: LD_VAR 0 3
 794: RET
// export function Attack ( unit , enemy_list ) ; var target , targets_list ; begin
 795: LD_INT 0
 797: PPUSH
 798: PPUSH
 799: PPUSH
// if not unit then
 800: LD_VAR 0 1
 804: NOT
 805: IFFALSE 809
// exit ;
 807: GO 1252
// if IsInUnit ( unit ) then
 809: LD_VAR 0 1
 813: PPUSH
 814: CALL_OW 310
 818: IFFALSE 835
// unit := IsDrivenBy ( unit ) ;
 820: LD_ADDR_VAR 0 1
 824: PUSH
 825: LD_VAR 0 1
 829: PPUSH
 830: CALL_OW 311
 834: ST_TO_ADDR
// targets_list := [ ] ;
 835: LD_ADDR_VAR 0 5
 839: PUSH
 840: EMPTY
 841: ST_TO_ADDR
// target := UnitFilter ( enemy_list , [ [ f_lives , 250 ] , [ f_not , [ f_weapon , us_cargo_bay ] ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
 842: LD_ADDR_VAR 0 4
 846: PUSH
 847: LD_VAR 0 2
 851: PPUSH
 852: LD_INT 24
 854: PUSH
 855: LD_INT 250
 857: PUSH
 858: EMPTY
 859: LIST
 860: LIST
 861: PUSH
 862: LD_INT 3
 864: PUSH
 865: LD_INT 34
 867: PUSH
 868: LD_INT 12
 870: PUSH
 871: EMPTY
 872: LIST
 873: LIST
 874: PUSH
 875: EMPTY
 876: LIST
 877: LIST
 878: PUSH
 879: LD_INT 21
 881: PUSH
 882: LD_INT 2
 884: PUSH
 885: EMPTY
 886: LIST
 887: LIST
 888: PUSH
 889: LD_INT 58
 891: PUSH
 892: EMPTY
 893: LIST
 894: PUSH
 895: EMPTY
 896: LIST
 897: LIST
 898: LIST
 899: LIST
 900: PPUSH
 901: CALL_OW 72
 905: ST_TO_ADDR
// if GetDistUnits ( NearestUnitToUnit ( target , unit ) , unit ) < 11 and not IsInUnit ( unit ) then
 906: LD_VAR 0 4
 910: PPUSH
 911: LD_VAR 0 1
 915: PPUSH
 916: CALL_OW 74
 920: PPUSH
 921: LD_VAR 0 1
 925: PPUSH
 926: CALL_OW 296
 930: PUSH
 931: LD_INT 11
 933: LESS
 934: PUSH
 935: LD_VAR 0 1
 939: PPUSH
 940: CALL_OW 310
 944: NOT
 945: AND
 946: IFFALSE 974
// begin ComEnterUnit ( unit , NearestUnitToUnit ( target , unit ) ) ;
 948: LD_VAR 0 1
 952: PPUSH
 953: LD_VAR 0 4
 957: PPUSH
 958: LD_VAR 0 1
 962: PPUSH
 963: CALL_OW 74
 967: PPUSH
 968: CALL_OW 120
// exit ;
 972: GO 1252
// end ; targets_list := [ UnitFilter ( enemy_list , [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] ] ) , UnitFilter ( enemy_list , [ f_type , unit_vehicle ] ) , UnitFilter ( enemy_list , [ [ f_type , unit_building ] , [ f_not , [ f_empty ] ] ] ) , enemy_list ] ;
 974: LD_ADDR_VAR 0 5
 978: PUSH
 979: LD_VAR 0 2
 983: PPUSH
 984: LD_INT 21
 986: PUSH
 987: LD_INT 1
 989: PUSH
 990: EMPTY
 991: LIST
 992: LIST
 993: PUSH
 994: LD_INT 3
 996: PUSH
 997: LD_INT 54
 999: PUSH
1000: EMPTY
1001: LIST
1002: PUSH
1003: EMPTY
1004: LIST
1005: LIST
1006: PUSH
1007: EMPTY
1008: LIST
1009: LIST
1010: PPUSH
1011: CALL_OW 72
1015: PUSH
1016: LD_VAR 0 2
1020: PPUSH
1021: LD_INT 21
1023: PUSH
1024: LD_INT 2
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: PPUSH
1031: CALL_OW 72
1035: PUSH
1036: LD_VAR 0 2
1040: PPUSH
1041: LD_INT 21
1043: PUSH
1044: LD_INT 3
1046: PUSH
1047: EMPTY
1048: LIST
1049: LIST
1050: PUSH
1051: LD_INT 3
1053: PUSH
1054: LD_INT 58
1056: PUSH
1057: EMPTY
1058: LIST
1059: PUSH
1060: EMPTY
1061: LIST
1062: LIST
1063: PUSH
1064: EMPTY
1065: LIST
1066: LIST
1067: PPUSH
1068: CALL_OW 72
1072: PUSH
1073: LD_VAR 0 2
1077: PUSH
1078: EMPTY
1079: LIST
1080: LIST
1081: LIST
1082: LIST
1083: ST_TO_ADDR
// for target in targets_list do
1084: LD_ADDR_VAR 0 4
1088: PUSH
1089: LD_VAR 0 5
1093: PUSH
1094: FOR_IN
1095: IFFALSE 1250
// begin if target then
1097: LD_VAR 0 4
1101: IFFALSE 1248
// if GetTag ( unit ) = 11 and ( GetType ( NearestUnitToUnit ( target , unit ) ) = unit_building or GetWeapon ( NearestUnitToUnit ( target , unit ) ) = us_cargo_bay ) then
1103: LD_VAR 0 1
1107: PPUSH
1108: CALL_OW 110
1112: PUSH
1113: LD_INT 11
1115: EQUAL
1116: PUSH
1117: LD_VAR 0 4
1121: PPUSH
1122: LD_VAR 0 1
1126: PPUSH
1127: CALL_OW 74
1131: PPUSH
1132: CALL_OW 247
1136: PUSH
1137: LD_INT 3
1139: EQUAL
1140: PUSH
1141: LD_VAR 0 4
1145: PPUSH
1146: LD_VAR 0 1
1150: PPUSH
1151: CALL_OW 74
1155: PPUSH
1156: CALL_OW 264
1160: PUSH
1161: LD_INT 12
1163: EQUAL
1164: OR
1165: AND
1166: IFFALSE 1212
// begin ComPlaceDelayedCharge ( unit , 0 , 0 , NearestUnitToUnit ( target , unit ) ) ;
1168: LD_VAR 0 1
1172: PPUSH
1173: LD_INT 0
1175: PPUSH
1176: LD_INT 0
1178: PPUSH
1179: LD_VAR 0 4
1183: PPUSH
1184: LD_VAR 0 1
1188: PPUSH
1189: CALL_OW 74
1193: PPUSH
1194: CALL_OW 132
// SetTag ( unit , 0 ) ;
1198: LD_VAR 0 1
1202: PPUSH
1203: LD_INT 0
1205: PPUSH
1206: CALL_OW 109
// end else
1210: GO 1248
// if not HasTask ( unit ) then
1212: LD_VAR 0 1
1216: PPUSH
1217: CALL_OW 314
1221: NOT
1222: IFFALSE 1248
// ComAttackUnit ( unit , NearestUnitToUnit ( target , unit ) ) ;
1224: LD_VAR 0 1
1228: PPUSH
1229: LD_VAR 0 4
1233: PPUSH
1234: LD_VAR 0 1
1238: PPUSH
1239: CALL_OW 74
1243: PPUSH
1244: CALL_OW 115
// end ;
1248: GO 1094
1250: POP
1251: POP
// end ; end_of_file
1252: LD_VAR 0 3
1256: RET
// export JMM , Gladstone , Harrison , Denis , Brown , Donaldson , Lisa , Frank , Bobby , Cyrus ; export others ; export function PrepareAmericans ; var i , points , veh , tmp ; begin
1257: LD_INT 0
1259: PPUSH
1260: PPUSH
1261: PPUSH
1262: PPUSH
1263: PPUSH
// uc_nation := 1 ;
1264: LD_ADDR_OWVAR 21
1268: PUSH
1269: LD_INT 1
1271: ST_TO_ADDR
// uc_side := 4 ;
1272: LD_ADDR_OWVAR 20
1276: PUSH
1277: LD_INT 4
1279: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , false ) ;
1280: LD_ADDR_EXP 19
1284: PUSH
1285: LD_STRING Denis
1287: PPUSH
1288: LD_INT 0
1290: PPUSH
1291: CALL 427 0 2
1295: ST_TO_ADDR
// Harrison := PrepareUnit ( Harisson , false ) ;
1296: LD_ADDR_EXP 18
1300: PUSH
1301: LD_STRING Harisson
1303: PPUSH
1304: LD_INT 0
1306: PPUSH
1307: CALL 427 0 2
1311: ST_TO_ADDR
// uc_side := 1 ;
1312: LD_ADDR_OWVAR 20
1316: PUSH
1317: LD_INT 1
1319: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1320: LD_ADDR_EXP 16
1324: PUSH
1325: LD_STRING JMM
1327: PPUSH
1328: LD_EXP 1
1332: NOT
1333: PPUSH
1334: CALL 427 0 2
1338: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , false ) ;
1339: LD_ADDR_EXP 17
1343: PUSH
1344: LD_STRING Gladstone
1346: PPUSH
1347: LD_INT 0
1349: PPUSH
1350: CALL 427 0 2
1354: ST_TO_ADDR
// if LoadVariable ( BrownInDelta , debug ) then
1355: LD_STRING BrownInDelta
1357: PPUSH
1358: LD_EXP 1
1362: PPUSH
1363: CALL_OW 30
1367: IFFALSE 1404
// begin Brown := PrepareUnit ( Brown , ( not debug ) ) ;
1369: LD_ADDR_EXP 20
1373: PUSH
1374: LD_STRING Brown
1376: PPUSH
1377: LD_EXP 1
1381: NOT
1382: PPUSH
1383: CALL 427 0 2
1387: ST_TO_ADDR
// tmp := tmp ^ Brown ;
1388: LD_ADDR_VAR 0 5
1392: PUSH
1393: LD_VAR 0 5
1397: PUSH
1398: LD_EXP 20
1402: ADD
1403: ST_TO_ADDR
// end ; if LoadVariable ( DonaldsonInDelta , debug ) then
1404: LD_STRING DonaldsonInDelta
1406: PPUSH
1407: LD_EXP 1
1411: PPUSH
1412: CALL_OW 30
1416: IFFALSE 1453
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
1418: LD_ADDR_EXP 21
1422: PUSH
1423: LD_STRING Donaldson
1425: PPUSH
1426: LD_EXP 1
1430: NOT
1431: PPUSH
1432: CALL 427 0 2
1436: ST_TO_ADDR
// tmp := tmp ^ Donaldson ;
1437: LD_ADDR_VAR 0 5
1441: PUSH
1442: LD_VAR 0 5
1446: PUSH
1447: LD_EXP 21
1451: ADD
1452: ST_TO_ADDR
// end ; if LoadVariable ( LisaInDelta , debug ) then
1453: LD_STRING LisaInDelta
1455: PPUSH
1456: LD_EXP 1
1460: PPUSH
1461: CALL_OW 30
1465: IFFALSE 1502
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1467: LD_ADDR_EXP 22
1471: PUSH
1472: LD_STRING Lisa
1474: PPUSH
1475: LD_EXP 1
1479: NOT
1480: PPUSH
1481: CALL 427 0 2
1485: ST_TO_ADDR
// tmp := tmp ^ Lisa ;
1486: LD_ADDR_VAR 0 5
1490: PUSH
1491: LD_VAR 0 5
1495: PUSH
1496: LD_EXP 22
1500: ADD
1501: ST_TO_ADDR
// end ; if LoadVariable ( FrankInDelta , debug ) then
1502: LD_STRING FrankInDelta
1504: PPUSH
1505: LD_EXP 1
1509: PPUSH
1510: CALL_OW 30
1514: IFFALSE 1551
// begin Frank := PrepareUnit ( Frank , ( not debug ) ) ;
1516: LD_ADDR_EXP 23
1520: PUSH
1521: LD_STRING Frank
1523: PPUSH
1524: LD_EXP 1
1528: NOT
1529: PPUSH
1530: CALL 427 0 2
1534: ST_TO_ADDR
// tmp := tmp ^ Frank ;
1535: LD_ADDR_VAR 0 5
1539: PUSH
1540: LD_VAR 0 5
1544: PUSH
1545: LD_EXP 23
1549: ADD
1550: ST_TO_ADDR
// end ; if LoadVariable ( BobbyInDelta , 0 ) then
1551: LD_STRING BobbyInDelta
1553: PPUSH
1554: LD_INT 0
1556: PPUSH
1557: CALL_OW 30
1561: IFFALSE 1598
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1563: LD_ADDR_EXP 24
1567: PUSH
1568: LD_STRING Bobby
1570: PPUSH
1571: LD_EXP 1
1575: NOT
1576: PPUSH
1577: CALL 427 0 2
1581: ST_TO_ADDR
// tmp := tmp ^ Bobby ;
1582: LD_ADDR_VAR 0 5
1586: PUSH
1587: LD_VAR 0 5
1591: PUSH
1592: LD_EXP 24
1596: ADD
1597: ST_TO_ADDR
// end ; if LoadVariable ( CyrusInDelta , 0 ) then
1598: LD_STRING CyrusInDelta
1600: PPUSH
1601: LD_INT 0
1603: PPUSH
1604: CALL_OW 30
1608: IFFALSE 1645
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1610: LD_ADDR_EXP 25
1614: PUSH
1615: LD_STRING Cyrus
1617: PPUSH
1618: LD_EXP 1
1622: NOT
1623: PPUSH
1624: CALL 427 0 2
1628: ST_TO_ADDR
// tmp := tmp ^ Cyrus ;
1629: LD_ADDR_VAR 0 5
1633: PUSH
1634: LD_VAR 0 5
1638: PUSH
1639: LD_EXP 25
1643: ADD
1644: ST_TO_ADDR
// end ; others := CreateCharacterSet ( othersDelta ) ;
1645: LD_ADDR_EXP 26
1649: PUSH
1650: LD_STRING othersDelta
1652: PPUSH
1653: CALL_OW 31
1657: ST_TO_ADDR
// if not others and debug then
1658: LD_EXP 26
1662: NOT
1663: PUSH
1664: LD_EXP 1
1668: AND
1669: IFFALSE 1734
// begin InitHc ;
1671: CALL_OW 19
// for i = 1 to 2 do
1675: LD_ADDR_VAR 0 2
1679: PUSH
1680: DOUBLE
1681: LD_INT 1
1683: DEC
1684: ST_TO_ADDR
1685: LD_INT 2
1687: PUSH
1688: FOR_TO
1689: IFFALSE 1732
// begin PrepareHuman ( false , i mod 4 + 1 , 3 ) ;
1691: LD_INT 0
1693: PPUSH
1694: LD_VAR 0 2
1698: PUSH
1699: LD_INT 4
1701: MOD
1702: PUSH
1703: LD_INT 1
1705: PLUS
1706: PPUSH
1707: LD_INT 3
1709: PPUSH
1710: CALL_OW 380
// others := others ^ CreateHuman ;
1714: LD_ADDR_EXP 26
1718: PUSH
1719: LD_EXP 26
1723: PUSH
1724: CALL_OW 44
1728: ADD
1729: ST_TO_ADDR
// end ;
1730: GO 1688
1732: POP
1733: POP
// end ; if others then
1734: LD_EXP 26
1738: IFFALSE 1756
// tmp := tmp ^ others ;
1740: LD_ADDR_VAR 0 5
1744: PUSH
1745: LD_VAR 0 5
1749: PUSH
1750: LD_EXP 26
1754: ADD
1755: ST_TO_ADDR
// points := [ [ 28 , 49 ] , [ 33 , 54 ] , [ 38 , 56 ] ] ;
1756: LD_ADDR_VAR 0 3
1760: PUSH
1761: LD_INT 28
1763: PUSH
1764: LD_INT 49
1766: PUSH
1767: EMPTY
1768: LIST
1769: LIST
1770: PUSH
1771: LD_INT 33
1773: PUSH
1774: LD_INT 54
1776: PUSH
1777: EMPTY
1778: LIST
1779: LIST
1780: PUSH
1781: LD_INT 38
1783: PUSH
1784: LD_INT 56
1786: PUSH
1787: EMPTY
1788: LIST
1789: LIST
1790: PUSH
1791: EMPTY
1792: LIST
1793: LIST
1794: LIST
1795: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , us_cargo_bay , 80 ) ;
1796: LD_ADDR_VAR 0 4
1800: PUSH
1801: LD_INT 1
1803: PPUSH
1804: LD_INT 1
1806: PPUSH
1807: LD_INT 2
1809: PPUSH
1810: LD_INT 2
1812: PPUSH
1813: LD_INT 1
1815: PPUSH
1816: LD_INT 12
1818: PPUSH
1819: LD_INT 80
1821: PPUSH
1822: CALL 490 0 7
1826: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1827: LD_VAR 0 4
1831: PPUSH
1832: LD_INT 1
1834: PPUSH
1835: CALL_OW 233
// PlaceUnitXY ( veh , points [ 1 ] [ 1 ] , points [ 1 ] [ 2 ] , false ) ;
1839: LD_VAR 0 4
1843: PPUSH
1844: LD_VAR 0 3
1848: PUSH
1849: LD_INT 1
1851: ARRAY
1852: PUSH
1853: LD_INT 1
1855: ARRAY
1856: PPUSH
1857: LD_VAR 0 3
1861: PUSH
1862: LD_INT 1
1864: ARRAY
1865: PUSH
1866: LD_INT 2
1868: ARRAY
1869: PPUSH
1870: LD_INT 0
1872: PPUSH
1873: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
1877: LD_VAR 0 4
1881: PPUSH
1882: LD_INT 1
1884: PPUSH
1885: LD_INT 100
1887: PPUSH
1888: CALL_OW 290
// PlaceHumanInUnit ( others [ 1 ] , veh ) ;
1892: LD_EXP 26
1896: PUSH
1897: LD_INT 1
1899: ARRAY
1900: PPUSH
1901: LD_VAR 0 4
1905: PPUSH
1906: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_machine_gun , 80 ) ;
1910: LD_ADDR_VAR 0 4
1914: PUSH
1915: LD_INT 1
1917: PPUSH
1918: LD_INT 1
1920: PPUSH
1921: LD_INT 1
1923: PPUSH
1924: LD_INT 2
1926: PPUSH
1927: LD_INT 1
1929: PPUSH
1930: LD_INT 2
1932: PPUSH
1933: LD_INT 80
1935: PPUSH
1936: CALL 490 0 7
1940: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1941: LD_VAR 0 4
1945: PPUSH
1946: LD_INT 1
1948: PPUSH
1949: CALL_OW 233
// PlaceUnitXY ( veh , points [ 2 ] [ 1 ] , points [ 2 ] [ 2 ] , false ) ;
1953: LD_VAR 0 4
1957: PPUSH
1958: LD_VAR 0 3
1962: PUSH
1963: LD_INT 2
1965: ARRAY
1966: PUSH
1967: LD_INT 1
1969: ARRAY
1970: PPUSH
1971: LD_VAR 0 3
1975: PUSH
1976: LD_INT 2
1978: ARRAY
1979: PUSH
1980: LD_INT 2
1982: ARRAY
1983: PPUSH
1984: LD_INT 0
1986: PPUSH
1987: CALL_OW 48
// PlaceHumanInUnit ( Gladstone , veh ) ;
1991: LD_EXP 17
1995: PPUSH
1996: LD_VAR 0 4
2000: PPUSH
2001: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_light_gun , 80 ) ;
2005: LD_ADDR_VAR 0 4
2009: PUSH
2010: LD_INT 1
2012: PPUSH
2013: LD_INT 1
2015: PPUSH
2016: LD_INT 1
2018: PPUSH
2019: LD_INT 2
2021: PPUSH
2022: LD_INT 1
2024: PPUSH
2025: LD_INT 3
2027: PPUSH
2028: LD_INT 80
2030: PPUSH
2031: CALL 490 0 7
2035: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
2036: LD_VAR 0 4
2040: PPUSH
2041: LD_INT 1
2043: PPUSH
2044: CALL_OW 233
// PlaceUnitXY ( veh , points [ 3 ] [ 1 ] , points [ 3 ] [ 2 ] , false ) ;
2048: LD_VAR 0 4
2052: PPUSH
2053: LD_VAR 0 3
2057: PUSH
2058: LD_INT 3
2060: ARRAY
2061: PUSH
2062: LD_INT 1
2064: ARRAY
2065: PPUSH
2066: LD_VAR 0 3
2070: PUSH
2071: LD_INT 3
2073: ARRAY
2074: PUSH
2075: LD_INT 2
2077: ARRAY
2078: PPUSH
2079: LD_INT 0
2081: PPUSH
2082: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
2086: LD_EXP 16
2090: PPUSH
2091: LD_VAR 0 4
2095: PPUSH
2096: CALL_OW 52
// for i in tmp diff others [ 1 ] do
2100: LD_ADDR_VAR 0 2
2104: PUSH
2105: LD_VAR 0 5
2109: PUSH
2110: LD_EXP 26
2114: PUSH
2115: LD_INT 1
2117: ARRAY
2118: DIFF
2119: PUSH
2120: FOR_IN
2121: IFFALSE 2140
// PlaceUnitArea ( i , startArea , false ) ;
2123: LD_VAR 0 2
2127: PPUSH
2128: LD_INT 5
2130: PPUSH
2131: LD_INT 0
2133: PPUSH
2134: CALL_OW 49
2138: GO 2120
2140: POP
2141: POP
// end ; end_of_file
2142: LD_VAR 0 1
2146: RET
// export function Action ; var m ; begin
2147: LD_INT 0
2149: PPUSH
2150: PPUSH
// InGameOn ;
2151: CALL_OW 8
// CenterNowOnXY ( 28 , 51 ) ;
2155: LD_INT 28
2157: PPUSH
2158: LD_INT 51
2160: PPUSH
2161: CALL_OW 86
// Wait ( 3 ) ;
2165: LD_INT 3
2167: PPUSH
2168: CALL_OW 67
// Say ( JMM , D1d-JMM-1a ) ;
2172: LD_EXP 16
2176: PPUSH
2177: LD_STRING D1d-JMM-1a
2179: PPUSH
2180: CALL_OW 88
// SayRadio ( Harrison , D1d-Har-1 ) ;
2184: LD_EXP 18
2188: PPUSH
2189: LD_STRING D1d-Har-1
2191: PPUSH
2192: CALL_OW 94
// InGameOff ;
2196: CALL_OW 9
// SaveForQuickRestart ;
2200: CALL_OW 22
// ChangeMissionObjectives ( M1 ) ;
2204: LD_STRING M1
2206: PPUSH
2207: CALL_OW 337
// Wait ( 0 0$2 ) ;
2211: LD_INT 70
2213: PPUSH
2214: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
2218: LD_EXP 16
2222: PPUSH
2223: LD_STRING D2-JMM-1
2225: PPUSH
2226: CALL_OW 88
// Say ( Gladstone , D2-Glad-1 ) ;
2230: LD_EXP 17
2234: PPUSH
2235: LD_STRING D2-Glad-1
2237: PPUSH
2238: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
2242: LD_EXP 16
2246: PPUSH
2247: LD_STRING D2-JMM-2
2249: PPUSH
2250: CALL_OW 88
// Say ( Gladstone , D2-Glad-2 ) ;
2254: LD_EXP 17
2258: PPUSH
2259: LD_STRING D2-Glad-2
2261: PPUSH
2262: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
2266: LD_EXP 16
2270: PPUSH
2271: LD_STRING D2-JMM-3
2273: PPUSH
2274: CALL_OW 88
// Wait ( rand ( 0 0$30 , 1 1$00 ) ) ;
2278: LD_INT 1050
2280: PPUSH
2281: LD_INT 2100
2283: PPUSH
2284: CALL_OW 12
2288: PPUSH
2289: CALL_OW 67
// SetWeather ( 2 , 90 , 150 ) ;
2293: LD_INT 2
2295: PPUSH
2296: LD_INT 90
2298: PPUSH
2299: LD_INT 150
2301: PPUSH
2302: CALL_OW 550
// Wait ( rand ( 3 3$00 , 5 5$00 ) ) ;
2306: LD_INT 6300
2308: PPUSH
2309: LD_INT 10500
2311: PPUSH
2312: CALL_OW 12
2316: PPUSH
2317: CALL_OW 67
// SetWeather ( 0 , 90 , 150 ) ;
2321: LD_INT 0
2323: PPUSH
2324: LD_INT 90
2326: PPUSH
2327: LD_INT 150
2329: PPUSH
2330: CALL_OW 550
// end ;
2334: LD_VAR 0 1
2338: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) and not deltaBuilded do
2339: LD_INT 22
2341: PUSH
2342: LD_INT 1
2344: PUSH
2345: EMPTY
2346: LIST
2347: LIST
2348: PUSH
2349: LD_INT 3
2351: PUSH
2352: LD_INT 57
2354: PUSH
2355: EMPTY
2356: LIST
2357: PUSH
2358: EMPTY
2359: LIST
2360: LIST
2361: PUSH
2362: LD_INT 30
2364: PUSH
2365: LD_INT 0
2367: PUSH
2368: EMPTY
2369: LIST
2370: LIST
2371: PUSH
2372: EMPTY
2373: LIST
2374: LIST
2375: LIST
2376: PUSH
2377: EMPTY
2378: LIST
2379: PPUSH
2380: CALL_OW 69
2384: PUSH
2385: LD_EXP 4
2389: NOT
2390: AND
2391: IFFALSE 2404
2393: GO 2395
2395: DISABLE
// begin deltaBuilded := true ;
2396: LD_ADDR_EXP 4
2400: PUSH
2401: LD_INT 1
2403: ST_TO_ADDR
// end ;
2404: END
// every 0 0$01 trigger not Delta and deltaBuilded and FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) do
2405: LD_EXP 6
2409: NOT
2410: PUSH
2411: LD_EXP 4
2415: AND
2416: PUSH
2417: LD_INT 22
2419: PUSH
2420: LD_INT 1
2422: PUSH
2423: EMPTY
2424: LIST
2425: LIST
2426: PUSH
2427: LD_INT 3
2429: PUSH
2430: LD_INT 57
2432: PUSH
2433: EMPTY
2434: LIST
2435: PUSH
2436: EMPTY
2437: LIST
2438: LIST
2439: PUSH
2440: LD_INT 30
2442: PUSH
2443: LD_INT 0
2445: PUSH
2446: EMPTY
2447: LIST
2448: LIST
2449: PUSH
2450: EMPTY
2451: LIST
2452: LIST
2453: LIST
2454: PUSH
2455: EMPTY
2456: LIST
2457: PPUSH
2458: CALL_OW 69
2462: AND
2463: IFFALSE 2549
2465: GO 2467
2467: DISABLE
// begin enable ;
2468: ENABLE
// SetRestrict ( b_depot , 1 , state_disabled ) ;
2469: LD_INT 0
2471: PPUSH
2472: LD_INT 1
2474: PPUSH
2475: LD_INT 0
2477: PPUSH
2478: CALL_OW 324
// Delta := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) [ 1 ] ;
2482: LD_ADDR_EXP 6
2486: PUSH
2487: LD_INT 22
2489: PUSH
2490: LD_INT 1
2492: PUSH
2493: EMPTY
2494: LIST
2495: LIST
2496: PUSH
2497: LD_INT 3
2499: PUSH
2500: LD_INT 57
2502: PUSH
2503: EMPTY
2504: LIST
2505: PUSH
2506: EMPTY
2507: LIST
2508: LIST
2509: PUSH
2510: LD_INT 30
2512: PUSH
2513: LD_INT 0
2515: PUSH
2516: EMPTY
2517: LIST
2518: LIST
2519: PUSH
2520: EMPTY
2521: LIST
2522: LIST
2523: LIST
2524: PUSH
2525: EMPTY
2526: LIST
2527: PPUSH
2528: CALL_OW 69
2532: PUSH
2533: LD_INT 1
2535: ARRAY
2536: ST_TO_ADDR
// SetBName ( Delta , Delta ) ;
2537: LD_EXP 6
2541: PPUSH
2542: LD_STRING Delta
2544: PPUSH
2545: CALL_OW 500
// end ;
2549: END
// every 0 0$2 trigger GetTech ( tech_ApeLang , 1 ) = state_researched do
2550: LD_INT 1
2552: PPUSH
2553: LD_INT 1
2555: PPUSH
2556: CALL_OW 321
2560: PUSH
2561: LD_INT 2
2563: EQUAL
2564: IFFALSE 2625
2566: GO 2568
2568: DISABLE
// begin DialogueOn ;
2569: CALL_OW 6
// Say ( Gladstone , D3-Glad-1 ) ;
2573: LD_EXP 17
2577: PPUSH
2578: LD_STRING D3-Glad-1
2580: PPUSH
2581: CALL_OW 88
// Say ( JMM , D3-JMM-1 ) ;
2585: LD_EXP 16
2589: PPUSH
2590: LD_STRING D3-JMM-1
2592: PPUSH
2593: CALL_OW 88
// Say ( Gladstone , D3-Glad-2 ) ;
2597: LD_EXP 17
2601: PPUSH
2602: LD_STRING D3-Glad-2
2604: PPUSH
2605: CALL_OW 88
// Say ( JMM , D3-JMM-2 ) ;
2609: LD_EXP 16
2613: PPUSH
2614: LD_STRING D3-JMM-2
2616: PPUSH
2617: CALL_OW 88
// DialogueOff ;
2621: CALL_OW 7
// end ;
2625: END
// every 0 0$1 trigger GetTech ( tech_ApePsych , 1 ) = state_researched do var sol ;
2626: LD_INT 2
2628: PPUSH
2629: LD_INT 1
2631: PPUSH
2632: CALL_OW 321
2636: PUSH
2637: LD_INT 2
2639: EQUAL
2640: IFFALSE 2817
2642: GO 2644
2644: DISABLE
2645: LD_INT 0
2647: PPUSH
// begin DialogueOn ;
2648: CALL_OW 6
// if Frank then
2652: LD_EXP 23
2656: IFFALSE 2670
// Say ( Frank , D8a-Frank-1 ) ;
2658: LD_EXP 23
2662: PPUSH
2663: LD_STRING D8a-Frank-1
2665: PPUSH
2666: CALL_OW 88
// sol := SayX ( UnitFilter ( others , [ f_sex , sex_male ] ) , D8a-Sol1-1 ) ;
2670: LD_ADDR_VAR 0 1
2674: PUSH
2675: LD_EXP 26
2679: PPUSH
2680: LD_INT 26
2682: PUSH
2683: LD_INT 1
2685: PUSH
2686: EMPTY
2687: LIST
2688: LIST
2689: PPUSH
2690: CALL_OW 72
2694: PPUSH
2695: LD_STRING D8a-Sol1-1
2697: PPUSH
2698: CALL 578 0 2
2702: ST_TO_ADDR
// if Denis and GetSide ( Denis ) = 1 then
2703: LD_EXP 19
2707: PUSH
2708: LD_EXP 19
2712: PPUSH
2713: CALL_OW 255
2717: PUSH
2718: LD_INT 1
2720: EQUAL
2721: AND
2722: IFFALSE 2736
// Say ( Denis , D8a-Den-1 ) ;
2724: LD_EXP 19
2728: PPUSH
2729: LD_STRING D8a-Den-1
2731: PPUSH
2732: CALL_OW 88
// if sol or Denis or Frank then
2736: LD_VAR 0 1
2740: PUSH
2741: LD_EXP 19
2745: OR
2746: PUSH
2747: LD_EXP 23
2751: OR
2752: IFFALSE 2813
// begin SayX ( UnitFilter ( others , [ [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff sol , D8a-Sci1-1 ) ;
2754: LD_EXP 26
2758: PPUSH
2759: LD_INT 25
2761: PUSH
2762: LD_INT 4
2764: PUSH
2765: EMPTY
2766: LIST
2767: LIST
2768: PUSH
2769: LD_INT 26
2771: PUSH
2772: LD_INT 1
2774: PUSH
2775: EMPTY
2776: LIST
2777: LIST
2778: PUSH
2779: EMPTY
2780: LIST
2781: LIST
2782: PPUSH
2783: CALL_OW 72
2787: PUSH
2788: LD_VAR 0 1
2792: DIFF
2793: PPUSH
2794: LD_STRING D8a-Sci1-1
2796: PPUSH
2797: CALL 578 0 2
// Say ( JMM , D8a-JMM-1 ) ;
2801: LD_EXP 16
2805: PPUSH
2806: LD_STRING D8a-JMM-1
2808: PPUSH
2809: CALL_OW 88
// end ; DialogueOff ;
2813: CALL_OW 7
// end ;
2817: PPOPN 1
2819: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) do
2820: LD_INT 22
2822: PUSH
2823: LD_INT 1
2825: PUSH
2826: EMPTY
2827: LIST
2828: LIST
2829: PUSH
2830: LD_INT 25
2832: PUSH
2833: LD_INT 16
2835: PUSH
2836: EMPTY
2837: LIST
2838: LIST
2839: PUSH
2840: EMPTY
2841: LIST
2842: LIST
2843: PPUSH
2844: CALL_OW 69
2848: IFFALSE 2907
2850: GO 2852
2852: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
2853: LD_STRING M1a
2855: PPUSH
2856: CALL_OW 337
// case Query ( Q2 ) of 1 :
2860: LD_STRING Q2
2862: PPUSH
2863: CALL_OW 97
2867: PUSH
2868: LD_INT 1
2870: DOUBLE
2871: EQUAL
2872: IFTRUE 2876
2874: GO 2887
2876: POP
// end_mission := true ; 2 :
2877: LD_ADDR_EXP 14
2881: PUSH
2882: LD_INT 1
2884: ST_TO_ADDR
2885: GO 2907
2887: LD_INT 2
2889: DOUBLE
2890: EQUAL
2891: IFTRUE 2895
2893: GO 2906
2895: POP
// end_the_mission_allowed := true ; end ;
2896: LD_ADDR_OWVAR 57
2900: PUSH
2901: LD_INT 1
2903: ST_TO_ADDR
2904: GO 2907
2906: POP
// end ;
2907: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) and Delta do
2908: LD_INT 22
2910: PUSH
2911: LD_INT 1
2913: PUSH
2914: EMPTY
2915: LIST
2916: LIST
2917: PUSH
2918: LD_INT 2
2920: PUSH
2921: LD_INT 30
2923: PUSH
2924: LD_INT 6
2926: PUSH
2927: EMPTY
2928: LIST
2929: LIST
2930: PUSH
2931: LD_INT 30
2933: PUSH
2934: LD_INT 7
2936: PUSH
2937: EMPTY
2938: LIST
2939: LIST
2940: PUSH
2941: EMPTY
2942: LIST
2943: LIST
2944: LIST
2945: PUSH
2946: EMPTY
2947: LIST
2948: LIST
2949: PPUSH
2950: CALL_OW 69
2954: PUSH
2955: LD_INT 22
2957: PUSH
2958: LD_INT 1
2960: PUSH
2961: EMPTY
2962: LIST
2963: LIST
2964: PUSH
2965: LD_INT 2
2967: PUSH
2968: LD_INT 30
2970: PUSH
2971: LD_INT 2
2973: PUSH
2974: EMPTY
2975: LIST
2976: LIST
2977: PUSH
2978: LD_INT 30
2980: PUSH
2981: LD_INT 3
2983: PUSH
2984: EMPTY
2985: LIST
2986: LIST
2987: PUSH
2988: EMPTY
2989: LIST
2990: LIST
2991: LIST
2992: PUSH
2993: EMPTY
2994: LIST
2995: LIST
2996: PPUSH
2997: CALL_OW 69
3001: AND
3002: PUSH
3003: LD_EXP 6
3007: AND
3008: IFFALSE 3435
3010: GO 3012
3012: DISABLE
// begin Wait ( rand ( 0 0$20 , 0 0$40 ) ) ;
3013: LD_INT 700
3015: PPUSH
3016: LD_INT 1400
3018: PPUSH
3019: CALL_OW 12
3023: PPUSH
3024: CALL_OW 67
// PlaceUnitArea ( Denis , [ denisArea1 , denisArea2 , denisArea3 ] [ Difficulty ] , false ) ;
3028: LD_EXP 19
3032: PPUSH
3033: LD_INT 6
3035: PUSH
3036: LD_INT 9
3038: PUSH
3039: LD_INT 10
3041: PUSH
3042: EMPTY
3043: LIST
3044: LIST
3045: LIST
3046: PUSH
3047: LD_OWVAR 67
3051: ARRAY
3052: PPUSH
3053: LD_INT 0
3055: PPUSH
3056: CALL_OW 49
// ComHold ( Denis ) ;
3060: LD_EXP 19
3064: PPUSH
3065: CALL_OW 140
// InGameOn ;
3069: CALL_OW 8
// DialogueOn ;
3073: CALL_OW 6
// if Delta then
3077: LD_EXP 6
3081: IFFALSE 3094
// CenterNowOnUnits ( Delta ) else
3083: LD_EXP 6
3087: PPUSH
3088: CALL_OW 87
3092: GO 3103
// CenterNowOnUnits ( JMM ) ;
3094: LD_EXP 16
3098: PPUSH
3099: CALL_OW 87
// SayRadio ( Denis , DD-Den-1 ) ;
3103: LD_EXP 19
3107: PPUSH
3108: LD_STRING DD-Den-1
3110: PPUSH
3111: CALL_OW 94
// Say ( JMM , DD-JMM-1 ) ;
3115: LD_EXP 16
3119: PPUSH
3120: LD_STRING DD-JMM-1
3122: PPUSH
3123: CALL_OW 88
// SayRadio ( Denis , DD-Den-2 ) ;
3127: LD_EXP 19
3131: PPUSH
3132: LD_STRING DD-Den-2
3134: PPUSH
3135: CALL_OW 94
// Wait ( 3 ) ;
3139: LD_INT 3
3141: PPUSH
3142: CALL_OW 67
// DialogueOff ;
3146: CALL_OW 7
// InGameOff ;
3150: CALL_OW 9
// repeat wait ( 0 0$01 ) ;
3154: LD_INT 35
3156: PPUSH
3157: CALL_OW 67
// until See ( 1 , Denis ) or IsDead ( Denis ) ;
3161: LD_INT 1
3163: PPUSH
3164: LD_EXP 19
3168: PPUSH
3169: CALL_OW 292
3173: PUSH
3174: LD_EXP 19
3178: PPUSH
3179: CALL_OW 301
3183: OR
3184: IFFALSE 3154
// if IsDead ( Denis ) then
3186: LD_EXP 19
3190: PPUSH
3191: CALL_OW 301
3195: IFFALSE 3199
// exit ;
3197: GO 3435
// SetSide ( Denis , 1 ) ;
3199: LD_EXP 19
3203: PPUSH
3204: LD_INT 1
3206: PPUSH
3207: CALL_OW 235
// Say ( Denis , DD-Den-2a ) ;
3211: LD_EXP 19
3215: PPUSH
3216: LD_STRING DD-Den-2a
3218: PPUSH
3219: CALL_OW 88
// repeat wait ( 0 0$01 ) ;
3223: LD_INT 35
3225: PPUSH
3226: CALL_OW 67
// until GetBType ( IsInUnit ( Denis ) ) in [ b_lab , b_lab_half , b_lab_full ] or IsDead ( Denis ) ;
3230: LD_EXP 19
3234: PPUSH
3235: CALL_OW 310
3239: PPUSH
3240: CALL_OW 266
3244: PUSH
3245: LD_INT 6
3247: PUSH
3248: LD_INT 7
3250: PUSH
3251: LD_INT 8
3253: PUSH
3254: EMPTY
3255: LIST
3256: LIST
3257: LIST
3258: IN
3259: PUSH
3260: LD_EXP 19
3264: PPUSH
3265: CALL_OW 301
3269: OR
3270: IFFALSE 3223
// if IsDead ( Denis ) then
3272: LD_EXP 19
3276: PPUSH
3277: CALL_OW 301
3281: IFFALSE 3285
// exit ;
3283: GO 3435
// Say ( Denis , DD-Den-2b ) ;
3285: LD_EXP 19
3289: PPUSH
3290: LD_STRING DD-Den-2b
3292: PPUSH
3293: CALL_OW 88
// ComChangeProfession ( Denis , 4 ) ;
3297: LD_EXP 19
3301: PPUSH
3302: LD_INT 4
3304: PPUSH
3305: CALL_OW 123
// Wait ( 0 0$02 ) ;
3309: LD_INT 70
3311: PPUSH
3312: CALL_OW 67
// DialogueOn ;
3316: CALL_OW 6
// CenterNowOnUnits ( Denis ) ;
3320: LD_EXP 19
3324: PPUSH
3325: CALL_OW 87
// Say ( JMM , D4-JMM-1 ) ;
3329: LD_EXP 16
3333: PPUSH
3334: LD_STRING D4-JMM-1
3336: PPUSH
3337: CALL_OW 88
// Say ( Denis , D4-Den-1 ) ;
3341: LD_EXP 19
3345: PPUSH
3346: LD_STRING D4-Den-1
3348: PPUSH
3349: CALL_OW 88
// Say ( JMM , D4-JMM-2 ) ;
3353: LD_EXP 16
3357: PPUSH
3358: LD_STRING D4-JMM-2
3360: PPUSH
3361: CALL_OW 88
// Say ( Denis , D4-Den-2 ) ;
3365: LD_EXP 19
3369: PPUSH
3370: LD_STRING D4-Den-2
3372: PPUSH
3373: CALL_OW 88
// DialogueOff ;
3377: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
3381: LD_STRING M2
3383: PPUSH
3384: CALL_OW 337
// radar_allowed := true ;
3388: LD_ADDR_EXP 7
3392: PUSH
3393: LD_INT 1
3395: ST_TO_ADDR
// SetTech ( tech_radar , 1 , state_enabled ) ;
3396: LD_INT 6
3398: PPUSH
3399: LD_INT 1
3401: PPUSH
3402: LD_INT 1
3404: PPUSH
3405: CALL_OW 322
// SetRestrict ( b_lab_opto , 1 , state_enabled ) ;
3409: LD_INT 15
3411: PPUSH
3412: LD_INT 1
3414: PPUSH
3415: LD_INT 1
3417: PPUSH
3418: CALL_OW 324
// SetRestrict ( b_ext_radar , 1 , state_enabled ) ;
3422: LD_INT 20
3424: PPUSH
3425: LD_INT 1
3427: PPUSH
3428: LD_INT 1
3430: PPUSH
3431: CALL_OW 324
// end ;
3435: END
// every 0 0$1 trigger arab_spotted do var sol , sol2 ;
3436: LD_EXP 13
3440: IFFALSE 4063
3442: GO 3444
3444: DISABLE
3445: LD_INT 0
3447: PPUSH
3448: PPUSH
// begin sol := SayX ( UnitFilter ( others , [ f_sex , sex_male ] ) , D5-Sol1-1 ) ;
3449: LD_ADDR_VAR 0 1
3453: PUSH
3454: LD_EXP 26
3458: PPUSH
3459: LD_INT 26
3461: PUSH
3462: LD_INT 1
3464: PUSH
3465: EMPTY
3466: LIST
3467: LIST
3468: PPUSH
3469: CALL_OW 72
3473: PPUSH
3474: LD_STRING D5-Sol1-1
3476: PPUSH
3477: CALL 578 0 2
3481: ST_TO_ADDR
// if not sol then
3482: LD_VAR 0 1
3486: NOT
3487: IFFALSE 3491
// exit ;
3489: GO 4063
// repeat wait ( 0 0$01 ) ;
3491: LD_INT 35
3493: PPUSH
3494: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 ;
3498: LD_INT 22
3500: PUSH
3501: LD_INT 2
3503: PUSH
3504: EMPTY
3505: LIST
3506: LIST
3507: PUSH
3508: LD_INT 21
3510: PUSH
3511: LD_INT 1
3513: PUSH
3514: EMPTY
3515: LIST
3516: LIST
3517: PUSH
3518: EMPTY
3519: LIST
3520: LIST
3521: PPUSH
3522: CALL_OW 69
3526: PUSH
3527: LD_INT 0
3529: EQUAL
3530: IFFALSE 3491
// if IsOk ( sol ) then
3532: LD_VAR 0 1
3536: PPUSH
3537: CALL_OW 302
3541: IFFALSE 3561
// begin sol2 := others diff sol ;
3543: LD_ADDR_VAR 0 2
3547: PUSH
3548: LD_EXP 26
3552: PUSH
3553: LD_VAR 0 1
3557: DIFF
3558: ST_TO_ADDR
// end else
3559: GO 3563
// exit ;
3561: GO 4063
// if not Lisa and not sol2 then
3563: LD_EXP 22
3567: NOT
3568: PUSH
3569: LD_VAR 0 2
3573: NOT
3574: AND
3575: IFFALSE 3579
// exit ;
3577: GO 4063
// DialogueOn ;
3579: CALL_OW 6
// if Lisa then
3583: LD_EXP 22
3587: IFFALSE 3603
// Say ( Lisa , D5a-Lisa-1 ) else
3589: LD_EXP 22
3593: PPUSH
3594: LD_STRING D5a-Lisa-1
3596: PPUSH
3597: CALL_OW 88
3601: GO 3678
// if sol2 then
3603: LD_VAR 0 2
3607: IFFALSE 3678
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3609: LD_VAR 0 2
3613: PUSH
3614: LD_INT 1
3616: ARRAY
3617: PPUSH
3618: CALL_OW 258
3622: PUSH
3623: LD_INT 1
3625: DOUBLE
3626: EQUAL
3627: IFTRUE 3631
3629: GO 3650
3631: POP
// Say ( sol2 [ 1 ] , D5-Sol2-1 ) ; sex_female :
3632: LD_VAR 0 2
3636: PUSH
3637: LD_INT 1
3639: ARRAY
3640: PPUSH
3641: LD_STRING D5-Sol2-1
3643: PPUSH
3644: CALL_OW 88
3648: GO 3678
3650: LD_INT 2
3652: DOUBLE
3653: EQUAL
3654: IFTRUE 3658
3656: GO 3677
3658: POP
// Say ( sol2 [ 1 ] , D5-FSol2-1 ) ; end ;
3659: LD_VAR 0 2
3663: PUSH
3664: LD_INT 1
3666: ARRAY
3667: PPUSH
3668: LD_STRING D5-FSol2-1
3670: PPUSH
3671: CALL_OW 88
3675: GO 3678
3677: POP
// Say ( sol , D5-Sol1-2 ) ;
3678: LD_VAR 0 1
3682: PPUSH
3683: LD_STRING D5-Sol1-2
3685: PPUSH
3686: CALL_OW 88
// if Lisa then
3690: LD_EXP 22
3694: IFFALSE 3710
// Say ( Lisa , D5a-Lisa-2 ) else
3696: LD_EXP 22
3700: PPUSH
3701: LD_STRING D5a-Lisa-2
3703: PPUSH
3704: CALL_OW 88
3708: GO 3785
// if sol2 then
3710: LD_VAR 0 2
3714: IFFALSE 3785
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3716: LD_VAR 0 2
3720: PUSH
3721: LD_INT 1
3723: ARRAY
3724: PPUSH
3725: CALL_OW 258
3729: PUSH
3730: LD_INT 1
3732: DOUBLE
3733: EQUAL
3734: IFTRUE 3738
3736: GO 3757
3738: POP
// Say ( sol2 [ 1 ] , D5-Sol2-2 ) ; sex_female :
3739: LD_VAR 0 2
3743: PUSH
3744: LD_INT 1
3746: ARRAY
3747: PPUSH
3748: LD_STRING D5-Sol2-2
3750: PPUSH
3751: CALL_OW 88
3755: GO 3785
3757: LD_INT 2
3759: DOUBLE
3760: EQUAL
3761: IFTRUE 3765
3763: GO 3784
3765: POP
// Say ( sol2 [ 1 ] , D5-FSol2-2 ) ; end ;
3766: LD_VAR 0 2
3770: PUSH
3771: LD_INT 1
3773: ARRAY
3774: PPUSH
3775: LD_STRING D5-FSol2-2
3777: PPUSH
3778: CALL_OW 88
3782: GO 3785
3784: POP
// Say ( sol , D5a-Sol1-3 ) ;
3785: LD_VAR 0 1
3789: PPUSH
3790: LD_STRING D5a-Sol1-3
3792: PPUSH
3793: CALL_OW 88
// if Lisa then
3797: LD_EXP 22
3801: IFFALSE 3815
// Say ( Lisa , D5a-Lisa-3 ) ;
3803: LD_EXP 22
3807: PPUSH
3808: LD_STRING D5a-Lisa-3
3810: PPUSH
3811: CALL_OW 88
// if not sol2 then
3815: LD_VAR 0 2
3819: NOT
3820: IFFALSE 3828
// begin DialogueOff ;
3822: CALL_OW 7
// exit ;
3826: GO 4063
// end ; case GetSex ( sol2 [ 1 ] ) of sex_male :
3828: LD_VAR 0 2
3832: PUSH
3833: LD_INT 1
3835: ARRAY
3836: PPUSH
3837: CALL_OW 258
3841: PUSH
3842: LD_INT 1
3844: DOUBLE
3845: EQUAL
3846: IFTRUE 3850
3848: GO 3869
3850: POP
// Say ( sol2 [ 1 ] , D5-Sol2-3 ) ; sex_female :
3851: LD_VAR 0 2
3855: PUSH
3856: LD_INT 1
3858: ARRAY
3859: PPUSH
3860: LD_STRING D5-Sol2-3
3862: PPUSH
3863: CALL_OW 88
3867: GO 3897
3869: LD_INT 2
3871: DOUBLE
3872: EQUAL
3873: IFTRUE 3877
3875: GO 3896
3877: POP
// Say ( sol2 [ 1 ] , D5-FSol2-3 ) ; end ;
3878: LD_VAR 0 2
3882: PUSH
3883: LD_INT 1
3885: ARRAY
3886: PPUSH
3887: LD_STRING D5-FSol2-3
3889: PPUSH
3890: CALL_OW 88
3894: GO 3897
3896: POP
// Say ( sol , D5-Sol1-4 ) ;
3897: LD_VAR 0 1
3901: PPUSH
3902: LD_STRING D5-Sol1-4
3904: PPUSH
3905: CALL_OW 88
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3909: LD_VAR 0 2
3913: PUSH
3914: LD_INT 1
3916: ARRAY
3917: PPUSH
3918: CALL_OW 258
3922: PUSH
3923: LD_INT 1
3925: DOUBLE
3926: EQUAL
3927: IFTRUE 3931
3929: GO 3950
3931: POP
// Say ( sol2 [ 1 ] , D5-Sol2-4 ) ; sex_female :
3932: LD_VAR 0 2
3936: PUSH
3937: LD_INT 1
3939: ARRAY
3940: PPUSH
3941: LD_STRING D5-Sol2-4
3943: PPUSH
3944: CALL_OW 88
3948: GO 3978
3950: LD_INT 2
3952: DOUBLE
3953: EQUAL
3954: IFTRUE 3958
3956: GO 3977
3958: POP
// Say ( sol2 [ 1 ] , D5-FSol2-4 ) ; end ;
3959: LD_VAR 0 2
3963: PUSH
3964: LD_INT 1
3966: ARRAY
3967: PPUSH
3968: LD_STRING D5-FSol2-4
3970: PPUSH
3971: CALL_OW 88
3975: GO 3978
3977: POP
// Say ( sol , D5-Sol1-5 ) ;
3978: LD_VAR 0 1
3982: PPUSH
3983: LD_STRING D5-Sol1-5
3985: PPUSH
3986: CALL_OW 88
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3990: LD_VAR 0 2
3994: PUSH
3995: LD_INT 1
3997: ARRAY
3998: PPUSH
3999: CALL_OW 258
4003: PUSH
4004: LD_INT 1
4006: DOUBLE
4007: EQUAL
4008: IFTRUE 4012
4010: GO 4031
4012: POP
// Say ( sol2 [ 1 ] , D5-Sol2-5 ) ; sex_female :
4013: LD_VAR 0 2
4017: PUSH
4018: LD_INT 1
4020: ARRAY
4021: PPUSH
4022: LD_STRING D5-Sol2-5
4024: PPUSH
4025: CALL_OW 88
4029: GO 4059
4031: LD_INT 2
4033: DOUBLE
4034: EQUAL
4035: IFTRUE 4039
4037: GO 4058
4039: POP
// Say ( sol2 [ 1 ] , D5-FSol2-5 ) ; end ;
4040: LD_VAR 0 2
4044: PUSH
4045: LD_INT 1
4047: ARRAY
4048: PPUSH
4049: LD_STRING D5-FSol2-5
4051: PPUSH
4052: CALL_OW 88
4056: GO 4059
4058: POP
// DialogueOff ;
4059: CALL_OW 7
// end ;
4063: PPOPN 2
4065: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) >= 5 do
4066: LD_INT 22
4068: PUSH
4069: LD_INT 1
4071: PUSH
4072: EMPTY
4073: LIST
4074: LIST
4075: PUSH
4076: LD_INT 25
4078: PUSH
4079: LD_INT 16
4081: PUSH
4082: EMPTY
4083: LIST
4084: LIST
4085: PUSH
4086: EMPTY
4087: LIST
4088: LIST
4089: PPUSH
4090: CALL_OW 69
4094: PUSH
4095: LD_INT 5
4097: GREATEREQUAL
4098: IFFALSE 4118
4100: GO 4102
4102: DISABLE
// begin ChangeMissionObjectives ( M1b ) ;
4103: LD_STRING M1b
4105: PPUSH
4106: CALL_OW 337
// apeman_army := true ;
4110: LD_ADDR_EXP 9
4114: PUSH
4115: LD_INT 1
4117: ST_TO_ADDR
// end ;
4118: END
// every 0 0$1 trigger GetTech ( tech_radar , 1 ) = state_researched do
4119: LD_INT 6
4121: PPUSH
4122: LD_INT 1
4124: PPUSH
4125: CALL_OW 321
4129: PUSH
4130: LD_INT 2
4132: EQUAL
4133: IFFALSE 4153
4135: GO 4137
4137: DISABLE
// begin ChangeMissionObjectives ( M2a ) ;
4138: LD_STRING M2a
4140: PPUSH
4141: CALL_OW 337
// radar_researched := true ;
4145: LD_ADDR_EXP 10
4149: PUSH
4150: LD_INT 1
4152: ST_TO_ADDR
// end ;
4153: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_weapon , us_radar ] , [ f_bweapon , us_radar ] ] ] ) do
4154: LD_INT 22
4156: PUSH
4157: LD_INT 1
4159: PUSH
4160: EMPTY
4161: LIST
4162: LIST
4163: PUSH
4164: LD_INT 2
4166: PUSH
4167: LD_INT 34
4169: PUSH
4170: LD_INT 11
4172: PUSH
4173: EMPTY
4174: LIST
4175: LIST
4176: PUSH
4177: LD_INT 35
4179: PUSH
4180: LD_INT 11
4182: PUSH
4183: EMPTY
4184: LIST
4185: LIST
4186: PUSH
4187: EMPTY
4188: LIST
4189: LIST
4190: LIST
4191: PUSH
4192: EMPTY
4193: LIST
4194: LIST
4195: PPUSH
4196: CALL_OW 69
4200: IFFALSE 4220
4202: GO 4204
4204: DISABLE
// begin ChangeMissionObjectives ( M2b ) ;
4205: LD_STRING M2b
4207: PPUSH
4208: CALL_OW 337
// radar_builded := true ;
4212: LD_ADDR_EXP 11
4216: PUSH
4217: LD_INT 1
4219: ST_TO_ADDR
// end ;
4220: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) = 0 and not first_apeman_tamed do
4221: LD_INT 22
4223: PUSH
4224: LD_INT 0
4226: PUSH
4227: EMPTY
4228: LIST
4229: LIST
4230: PUSH
4231: LD_INT 25
4233: PUSH
4234: LD_INT 12
4236: PUSH
4237: EMPTY
4238: LIST
4239: LIST
4240: PUSH
4241: EMPTY
4242: LIST
4243: LIST
4244: PPUSH
4245: CALL_OW 69
4249: PUSH
4250: LD_INT 0
4252: EQUAL
4253: PUSH
4254: LD_EXP 8
4258: NOT
4259: AND
4260: IFFALSE 4272
4262: GO 4264
4264: DISABLE
// YouLost ( Apeman ) ;
4265: LD_STRING Apeman
4267: PPUSH
4268: CALL_OW 104
4272: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) >= 7 do var i , filter ;
4273: LD_INT 22
4275: PUSH
4276: LD_INT 1
4278: PUSH
4279: EMPTY
4280: LIST
4281: LIST
4282: PUSH
4283: LD_INT 25
4285: PUSH
4286: LD_INT 16
4288: PUSH
4289: EMPTY
4290: LIST
4291: LIST
4292: PUSH
4293: EMPTY
4294: LIST
4295: LIST
4296: PPUSH
4297: CALL_OW 69
4301: PUSH
4302: LD_INT 7
4304: GREATEREQUAL
4305: IFFALSE 4403
4307: GO 4309
4309: DISABLE
4310: LD_INT 0
4312: PPUSH
4313: PPUSH
// begin filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , 4 ] ] ) ^ JMM ;
4314: LD_ADDR_VAR 0 2
4318: PUSH
4319: LD_INT 22
4321: PUSH
4322: LD_INT 1
4324: PUSH
4325: EMPTY
4326: LIST
4327: LIST
4328: PUSH
4329: LD_INT 21
4331: PUSH
4332: LD_INT 1
4334: PUSH
4335: EMPTY
4336: LIST
4337: LIST
4338: PUSH
4339: LD_INT 25
4341: PUSH
4342: LD_INT 4
4344: PUSH
4345: EMPTY
4346: LIST
4347: LIST
4348: PUSH
4349: EMPTY
4350: LIST
4351: LIST
4352: LIST
4353: PPUSH
4354: CALL_OW 69
4358: PUSH
4359: LD_EXP 16
4363: ADD
4364: ST_TO_ADDR
// if filter then
4365: LD_VAR 0 2
4369: IFFALSE 4403
// for i in filter do
4371: LD_ADDR_VAR 0 1
4375: PUSH
4376: LD_VAR 0 2
4380: PUSH
4381: FOR_IN
4382: IFFALSE 4401
// AddExperience ( i , 4 , 3500 ) ;
4384: LD_VAR 0 1
4388: PPUSH
4389: LD_INT 4
4391: PPUSH
4392: LD_INT 3500
4394: PPUSH
4395: CALL_OW 492
4399: GO 4381
4401: POP
4402: POP
// end ;
4403: PPOPN 2
4405: END
// every 0 0$1 trigger end_mission do var i , tmp , m1 , m2 , m3 ;
4406: LD_EXP 14
4410: IFFALSE 5544
4412: GO 4414
4414: DISABLE
4415: LD_INT 0
4417: PPUSH
4418: PPUSH
4419: PPUSH
4420: PPUSH
4421: PPUSH
// begin if apeKillCounter = 0 then
4422: LD_EXP 15
4426: PUSH
4427: LD_INT 0
4429: EQUAL
4430: IFFALSE 4439
// SetAchievement ( ACH_APEKILLER ) ;
4432: LD_STRING ACH_APEKILLER
4434: PPUSH
4435: CALL_OW 543
// if FilterAllUnits ( [ f_side , 2 ] ) then
4439: LD_INT 22
4441: PUSH
4442: LD_INT 2
4444: PUSH
4445: EMPTY
4446: LIST
4447: LIST
4448: PPUSH
4449: CALL_OW 69
4453: IFFALSE 4491
// for i in FilterAllUnits ( [ f_side , 2 ] ) do
4455: LD_ADDR_VAR 0 1
4459: PUSH
4460: LD_INT 22
4462: PUSH
4463: LD_INT 2
4465: PUSH
4466: EMPTY
4467: LIST
4468: LIST
4469: PPUSH
4470: CALL_OW 69
4474: PUSH
4475: FOR_IN
4476: IFFALSE 4489
// RemoveUnit ( i ) ;
4478: LD_VAR 0 1
4482: PPUSH
4483: CALL_OW 64
4487: GO 4475
4489: POP
4490: POP
// m1 := false ;
4491: LD_ADDR_VAR 0 3
4495: PUSH
4496: LD_INT 0
4498: ST_TO_ADDR
// m2 := false ;
4499: LD_ADDR_VAR 0 4
4503: PUSH
4504: LD_INT 0
4506: ST_TO_ADDR
// m3 := false ;
4507: LD_ADDR_VAR 0 5
4511: PUSH
4512: LD_INT 0
4514: ST_TO_ADDR
// if apeman_army then
4515: LD_EXP 9
4519: IFFALSE 4541
// begin AddMedal ( Tame , 1 ) ;
4521: LD_STRING Tame
4523: PPUSH
4524: LD_INT 1
4526: PPUSH
4527: CALL_OW 101
// m1 := true ;
4531: LD_ADDR_VAR 0 3
4535: PUSH
4536: LD_INT 1
4538: ST_TO_ADDR
// end else
4539: GO 4552
// AddMedal ( Tame , - 1 ) ;
4541: LD_STRING Tame
4543: PPUSH
4544: LD_INT 1
4546: NEG
4547: PPUSH
4548: CALL_OW 101
// if radar_researched then
4552: LD_EXP 10
4556: IFFALSE 4588
// begin SaveVariable ( true , radarResInDelta ) ;
4558: LD_INT 1
4560: PPUSH
4561: LD_STRING radarResInDelta
4563: PPUSH
4564: CALL_OW 39
// AddMedal ( Radar , 1 ) ;
4568: LD_STRING Radar
4570: PPUSH
4571: LD_INT 1
4573: PPUSH
4574: CALL_OW 101
// m2 := true ;
4578: LD_ADDR_VAR 0 4
4582: PUSH
4583: LD_INT 1
4585: ST_TO_ADDR
// end else
4586: GO 4618
// if radar_allowed then
4588: LD_EXP 7
4592: IFFALSE 4607
// AddMedal ( Radar , - 2 ) else
4594: LD_STRING Radar
4596: PPUSH
4597: LD_INT 2
4599: NEG
4600: PPUSH
4601: CALL_OW 101
4605: GO 4618
// AddMedal ( Radar , - 1 ) ;
4607: LD_STRING Radar
4609: PPUSH
4610: LD_INT 1
4612: NEG
4613: PPUSH
4614: CALL_OW 101
// if radar_builded then
4618: LD_EXP 11
4622: IFFALSE 4644
// begin AddMedal ( BuildRadar , 1 ) ;
4624: LD_STRING BuildRadar
4626: PPUSH
4627: LD_INT 1
4629: PPUSH
4630: CALL_OW 101
// m3 := true ;
4634: LD_ADDR_VAR 0 5
4638: PUSH
4639: LD_INT 1
4641: ST_TO_ADDR
// end else
4642: GO 4655
// AddMedal ( BuildRadar , - 1 ) ;
4644: LD_STRING BuildRadar
4646: PPUSH
4647: LD_INT 1
4649: NEG
4650: PPUSH
4651: CALL_OW 101
// if tick <= 7 7$00 then
4655: LD_OWVAR 1
4659: PUSH
4660: LD_INT 14700
4662: LESSEQUAL
4663: IFFALSE 4672
// SetAchievement ( ACH_ASPEED_5 ) ;
4665: LD_STRING ACH_ASPEED_5
4667: PPUSH
4668: CALL_OW 543
// if m1 and m2 and m3 and Difficulty = 3 then
4672: LD_VAR 0 3
4676: PUSH
4677: LD_VAR 0 4
4681: AND
4682: PUSH
4683: LD_VAR 0 5
4687: AND
4688: PUSH
4689: LD_OWVAR 67
4693: PUSH
4694: LD_INT 3
4696: EQUAL
4697: AND
4698: IFFALSE 4710
// SetAchievementEX ( ACH_AMER , 5 ) ;
4700: LD_STRING ACH_AMER
4702: PPUSH
4703: LD_INT 5
4705: PPUSH
4706: CALL_OW 564
// GiveMedals ( MAIN ) ;
4710: LD_STRING MAIN
4712: PPUSH
4713: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
4717: LD_ADDR_VAR 0 2
4721: PUSH
4722: LD_INT 22
4724: PUSH
4725: LD_INT 1
4727: PUSH
4728: EMPTY
4729: LIST
4730: LIST
4731: PUSH
4732: LD_INT 21
4734: PUSH
4735: LD_INT 1
4737: PUSH
4738: EMPTY
4739: LIST
4740: LIST
4741: PUSH
4742: LD_INT 2
4744: PUSH
4745: LD_INT 25
4747: PUSH
4748: LD_INT 1
4750: PUSH
4751: EMPTY
4752: LIST
4753: LIST
4754: PUSH
4755: LD_INT 25
4757: PUSH
4758: LD_INT 2
4760: PUSH
4761: EMPTY
4762: LIST
4763: LIST
4764: PUSH
4765: LD_INT 25
4767: PUSH
4768: LD_INT 3
4770: PUSH
4771: EMPTY
4772: LIST
4773: LIST
4774: PUSH
4775: LD_INT 25
4777: PUSH
4778: LD_INT 4
4780: PUSH
4781: EMPTY
4782: LIST
4783: LIST
4784: PUSH
4785: EMPTY
4786: LIST
4787: LIST
4788: LIST
4789: LIST
4790: LIST
4791: PUSH
4792: EMPTY
4793: LIST
4794: LIST
4795: LIST
4796: PPUSH
4797: CALL_OW 69
4801: ST_TO_ADDR
// RewardPeople ( tmp ) ;
4802: LD_VAR 0 2
4806: PPUSH
4807: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
4811: LD_EXP 16
4815: PPUSH
4816: LD_EXP 2
4820: PUSH
4821: LD_STRING JMM
4823: STR
4824: PPUSH
4825: CALL_OW 38
// if IsOk ( Gladstone ) then
4829: LD_EXP 17
4833: PPUSH
4834: CALL_OW 302
4838: IFFALSE 4858
// begin SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
4840: LD_EXP 17
4844: PPUSH
4845: LD_EXP 2
4849: PUSH
4850: LD_STRING Gladstone
4852: STR
4853: PPUSH
4854: CALL_OW 38
// end ; if IsOk ( Denis ) and GetSide ( Denis ) = 1 then
4858: LD_EXP 19
4862: PPUSH
4863: CALL_OW 302
4867: PUSH
4868: LD_EXP 19
4872: PPUSH
4873: CALL_OW 255
4877: PUSH
4878: LD_INT 1
4880: EQUAL
4881: AND
4882: IFFALSE 4912
// begin SaveCharacters ( Denis , mission_prefix & Denis ) ;
4884: LD_EXP 19
4888: PPUSH
4889: LD_EXP 2
4893: PUSH
4894: LD_STRING Denis
4896: STR
4897: PPUSH
4898: CALL_OW 38
// SaveVariable ( true , DenisInDelta ) ;
4902: LD_INT 1
4904: PPUSH
4905: LD_STRING DenisInDelta
4907: PPUSH
4908: CALL_OW 39
// end ; if IsOk ( Lisa ) then
4912: LD_EXP 22
4916: PPUSH
4917: CALL_OW 302
4921: IFFALSE 4941
// begin SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
4923: LD_EXP 22
4927: PPUSH
4928: LD_EXP 2
4932: PUSH
4933: LD_STRING Lisa
4935: STR
4936: PPUSH
4937: CALL_OW 38
// end ; if IsOk ( Frank ) then
4941: LD_EXP 23
4945: PPUSH
4946: CALL_OW 302
4950: IFFALSE 4970
// begin SaveCharacters ( Frank , mission_prefix & Frank ) ;
4952: LD_EXP 23
4956: PPUSH
4957: LD_EXP 2
4961: PUSH
4962: LD_STRING Frank
4964: STR
4965: PPUSH
4966: CALL_OW 38
// end ; if IsOk ( Bobby ) then
4970: LD_EXP 24
4974: PPUSH
4975: CALL_OW 302
4979: IFFALSE 4999
// begin SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
4981: LD_EXP 24
4985: PPUSH
4986: LD_EXP 2
4990: PUSH
4991: LD_STRING Bobby
4993: STR
4994: PPUSH
4995: CALL_OW 38
// end ; if IsOk ( Cyrus ) then
4999: LD_EXP 25
5003: PPUSH
5004: CALL_OW 302
5008: IFFALSE 5028
// begin SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
5010: LD_EXP 25
5014: PPUSH
5015: LD_EXP 2
5019: PUSH
5020: LD_STRING Cyrus
5022: STR
5023: PPUSH
5024: CALL_OW 38
// end ; if IsOk ( Brown ) then
5028: LD_EXP 20
5032: PPUSH
5033: CALL_OW 302
5037: IFFALSE 5057
// begin SaveCharacters ( Brown , mission_prefix & Brown ) ;
5039: LD_EXP 20
5043: PPUSH
5044: LD_EXP 2
5048: PUSH
5049: LD_STRING Brown
5051: STR
5052: PPUSH
5053: CALL_OW 38
// end ; if IsOk ( Donaldson ) then
5057: LD_EXP 21
5061: PPUSH
5062: CALL_OW 302
5066: IFFALSE 5086
// begin SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
5068: LD_EXP 21
5072: PPUSH
5073: LD_EXP 2
5077: PUSH
5078: LD_STRING Donaldson
5080: STR
5081: PPUSH
5082: CALL_OW 38
// end ; if others then
5086: LD_EXP 26
5090: IFFALSE 5104
// SaveCharacters ( others , othersInDelta ) ;
5092: LD_EXP 26
5096: PPUSH
5097: LD_STRING othersInDelta
5099: PPUSH
5100: CALL_OW 38
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) then
5104: LD_INT 22
5106: PUSH
5107: LD_INT 1
5109: PUSH
5110: EMPTY
5111: LIST
5112: LIST
5113: PUSH
5114: LD_INT 25
5116: PUSH
5117: LD_INT 16
5119: PUSH
5120: EMPTY
5121: LIST
5122: LIST
5123: PUSH
5124: EMPTY
5125: LIST
5126: LIST
5127: PPUSH
5128: CALL_OW 69
5132: IFFALSE 5170
// SaveCharacters ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) , apeInDelta ) ;
5134: LD_INT 22
5136: PUSH
5137: LD_INT 1
5139: PUSH
5140: EMPTY
5141: LIST
5142: LIST
5143: PUSH
5144: LD_INT 25
5146: PUSH
5147: LD_INT 16
5149: PUSH
5150: EMPTY
5151: LIST
5152: LIST
5153: PUSH
5154: EMPTY
5155: LIST
5156: LIST
5157: PPUSH
5158: CALL_OW 69
5162: PPUSH
5163: LD_STRING apeInDelta
5165: PPUSH
5166: CALL_OW 38
// tmp := [ ] ;
5170: LD_ADDR_VAR 0 2
5174: PUSH
5175: EMPTY
5176: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) then
5177: LD_INT 22
5179: PUSH
5180: LD_INT 1
5182: PUSH
5183: EMPTY
5184: LIST
5185: LIST
5186: PUSH
5187: LD_INT 21
5189: PUSH
5190: LD_INT 2
5192: PUSH
5193: EMPTY
5194: LIST
5195: LIST
5196: PUSH
5197: EMPTY
5198: LIST
5199: LIST
5200: PPUSH
5201: CALL_OW 69
5205: IFFALSE 5316
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) do
5207: LD_ADDR_VAR 0 1
5211: PUSH
5212: LD_INT 22
5214: PUSH
5215: LD_INT 1
5217: PUSH
5218: EMPTY
5219: LIST
5220: LIST
5221: PUSH
5222: LD_INT 21
5224: PUSH
5225: LD_INT 2
5227: PUSH
5228: EMPTY
5229: LIST
5230: LIST
5231: PUSH
5232: EMPTY
5233: LIST
5234: LIST
5235: PPUSH
5236: CALL_OW 69
5240: PUSH
5241: FOR_IN
5242: IFFALSE 5314
// tmp := tmp ^ [ GetNation ( i ) , GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) ] ;
5244: LD_ADDR_VAR 0 2
5248: PUSH
5249: LD_VAR 0 2
5253: PUSH
5254: LD_VAR 0 1
5258: PPUSH
5259: CALL_OW 248
5263: PUSH
5264: LD_VAR 0 1
5268: PPUSH
5269: CALL_OW 265
5273: PUSH
5274: LD_VAR 0 1
5278: PPUSH
5279: CALL_OW 262
5283: PUSH
5284: LD_VAR 0 1
5288: PPUSH
5289: CALL_OW 263
5293: PUSH
5294: LD_VAR 0 1
5298: PPUSH
5299: CALL_OW 264
5303: PUSH
5304: EMPTY
5305: LIST
5306: LIST
5307: LIST
5308: LIST
5309: LIST
5310: ADD
5311: ST_TO_ADDR
5312: GO 5241
5314: POP
5315: POP
// if tmp then
5316: LD_VAR 0 2
5320: IFFALSE 5334
// SaveVariable ( tmp , vehiclesInDelta ) ;
5322: LD_VAR 0 2
5326: PPUSH
5327: LD_STRING vehiclesInDelta
5329: PPUSH
5330: CALL_OW 39
// tmp := [ ] ;
5334: LD_ADDR_VAR 0 2
5338: PUSH
5339: EMPTY
5340: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) then
5341: LD_INT 22
5343: PUSH
5344: LD_INT 1
5346: PUSH
5347: EMPTY
5348: LIST
5349: LIST
5350: PUSH
5351: LD_INT 21
5353: PUSH
5354: LD_INT 3
5356: PUSH
5357: EMPTY
5358: LIST
5359: LIST
5360: PUSH
5361: EMPTY
5362: LIST
5363: LIST
5364: PPUSH
5365: CALL_OW 69
5369: IFFALSE 5522
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
5371: LD_ADDR_VAR 0 1
5375: PUSH
5376: LD_INT 22
5378: PUSH
5379: LD_INT 1
5381: PUSH
5382: EMPTY
5383: LIST
5384: LIST
5385: PUSH
5386: LD_INT 21
5388: PUSH
5389: LD_INT 3
5391: PUSH
5392: EMPTY
5393: LIST
5394: LIST
5395: PUSH
5396: EMPTY
5397: LIST
5398: LIST
5399: PPUSH
5400: CALL_OW 69
5404: PUSH
5405: FOR_IN
5406: IFFALSE 5520
// tmp := tmp ^ [ [ GetBType ( i ) , GetBLevel ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
5408: LD_ADDR_VAR 0 2
5412: PUSH
5413: LD_VAR 0 2
5417: PUSH
5418: LD_VAR 0 1
5422: PPUSH
5423: CALL_OW 266
5427: PUSH
5428: LD_VAR 0 1
5432: PPUSH
5433: CALL_OW 267
5437: PUSH
5438: LD_VAR 0 1
5442: PPUSH
5443: CALL_OW 250
5447: PUSH
5448: LD_VAR 0 1
5452: PPUSH
5453: CALL_OW 251
5457: PUSH
5458: LD_VAR 0 1
5462: PPUSH
5463: CALL_OW 254
5467: PUSH
5468: LD_VAR 0 1
5472: PPUSH
5473: LD_INT 1
5475: PPUSH
5476: CALL_OW 268
5480: PUSH
5481: LD_VAR 0 1
5485: PPUSH
5486: LD_INT 2
5488: PPUSH
5489: CALL_OW 268
5493: PUSH
5494: LD_VAR 0 1
5498: PPUSH
5499: CALL_OW 269
5503: PUSH
5504: EMPTY
5505: LIST
5506: LIST
5507: LIST
5508: LIST
5509: LIST
5510: LIST
5511: LIST
5512: LIST
5513: PUSH
5514: EMPTY
5515: LIST
5516: ADD
5517: ST_TO_ADDR
5518: GO 5405
5520: POP
5521: POP
// if tmp then
5522: LD_VAR 0 2
5526: IFFALSE 5540
// SaveVariable ( tmp , buildingsInDelta ) ;
5528: LD_VAR 0 2
5532: PPUSH
5533: LD_STRING buildingsInDelta
5535: PPUSH
5536: CALL_OW 39
// YouWin ;
5540: CALL_OW 103
// end ; end_of_file
5544: PPOPN 5
5546: END
// export function PrepareArabianTroops ( amount , skill , area ) ; var i , un , tmp ; begin
5547: LD_INT 0
5549: PPUSH
5550: PPUSH
5551: PPUSH
5552: PPUSH
// InitHc ;
5553: CALL_OW 19
// InitUc ;
5557: CALL_OW 18
// uc_side := 2 ;
5561: LD_ADDR_OWVAR 20
5565: PUSH
5566: LD_INT 2
5568: ST_TO_ADDR
// uc_nation := 2 ;
5569: LD_ADDR_OWVAR 21
5573: PUSH
5574: LD_INT 2
5576: ST_TO_ADDR
// if not amount then
5577: LD_VAR 0 1
5581: NOT
5582: IFFALSE 5586
// exit ;
5584: GO 5709
// for i = 1 to amount do
5586: LD_ADDR_VAR 0 5
5590: PUSH
5591: DOUBLE
5592: LD_INT 1
5594: DEC
5595: ST_TO_ADDR
5596: LD_VAR 0 1
5600: PUSH
5601: FOR_TO
5602: IFFALSE 5697
// begin PrepareHuman ( false , 1 , skill ) ;
5604: LD_INT 0
5606: PPUSH
5607: LD_INT 1
5609: PPUSH
5610: LD_VAR 0 2
5614: PPUSH
5615: CALL_OW 380
// un := CreateHuman ;
5619: LD_ADDR_VAR 0 6
5623: PUSH
5624: CALL_OW 44
5628: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
5629: LD_ADDR_VAR 0 7
5633: PUSH
5634: LD_VAR 0 7
5638: PPUSH
5639: LD_INT 1
5641: PPUSH
5642: LD_VAR 0 6
5646: PPUSH
5647: CALL_OW 2
5651: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5652: LD_VAR 0 6
5656: PPUSH
5657: LD_VAR 0 3
5661: PPUSH
5662: LD_INT 0
5664: PPUSH
5665: CALL_OW 49
// if i mod 2 = 0 then
5669: LD_VAR 0 5
5673: PUSH
5674: LD_INT 2
5676: MOD
5677: PUSH
5678: LD_INT 0
5680: EQUAL
5681: IFFALSE 5695
// SetTag ( un , 11 ) ;
5683: LD_VAR 0 6
5687: PPUSH
5688: LD_INT 11
5690: PPUSH
5691: CALL_OW 109
// end ;
5695: GO 5601
5697: POP
5698: POP
// result := tmp ;
5699: LD_ADDR_VAR 0 4
5703: PUSH
5704: LD_VAR 0 7
5708: ST_TO_ADDR
// end ;
5709: LD_VAR 0 4
5713: RET
// export ar_forces , ap_killers ; every 0 0$1 trigger Delta do var i , timer , more_troops , skill , eng , un , veh , force ;
5714: LD_EXP 6
5718: IFFALSE 6585
5720: GO 5722
5722: DISABLE
5723: LD_INT 0
5725: PPUSH
5726: PPUSH
5727: PPUSH
5728: PPUSH
5729: PPUSH
5730: PPUSH
5731: PPUSH
5732: PPUSH
// begin more_troops := false ;
5733: LD_ADDR_VAR 0 3
5737: PUSH
5738: LD_INT 0
5740: ST_TO_ADDR
// skill := [ 3 , 4 , 5 ] [ Difficulty ] ;
5741: LD_ADDR_VAR 0 4
5745: PUSH
5746: LD_INT 3
5748: PUSH
5749: LD_INT 4
5751: PUSH
5752: LD_INT 5
5754: PUSH
5755: EMPTY
5756: LIST
5757: LIST
5758: LIST
5759: PUSH
5760: LD_OWVAR 67
5764: ARRAY
5765: ST_TO_ADDR
// timer := [ 5 5$00 , 4 4$00 , 3 3$00 ] [ Difficulty ] ;
5766: LD_ADDR_VAR 0 2
5770: PUSH
5771: LD_INT 10500
5773: PUSH
5774: LD_INT 8400
5776: PUSH
5777: LD_INT 6300
5779: PUSH
5780: EMPTY
5781: LIST
5782: LIST
5783: LIST
5784: PUSH
5785: LD_OWVAR 67
5789: ARRAY
5790: ST_TO_ADDR
// force := [ ] ;
5791: LD_ADDR_VAR 0 8
5795: PUSH
5796: EMPTY
5797: ST_TO_ADDR
// ar_forces := [ ] ;
5798: LD_ADDR_EXP 27
5802: PUSH
5803: EMPTY
5804: ST_TO_ADDR
// ap_killers := [ ] ;
5805: LD_ADDR_EXP 28
5809: PUSH
5810: EMPTY
5811: ST_TO_ADDR
// Wait ( timer ) ;
5812: LD_VAR 0 2
5816: PPUSH
5817: CALL_OW 67
// if Denis and GetSide ( Denis ) = 4 then
5821: LD_EXP 19
5825: PUSH
5826: LD_EXP 19
5830: PPUSH
5831: CALL_OW 255
5835: PUSH
5836: LD_INT 4
5838: EQUAL
5839: AND
5840: IFFALSE 5849
// Wait ( 0 0$45 ) ;
5842: LD_INT 1575
5844: PPUSH
5845: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) then
5849: LD_INT 22
5851: PUSH
5852: LD_INT 1
5854: PUSH
5855: EMPTY
5856: LIST
5857: LIST
5858: PUSH
5859: LD_INT 30
5861: PUSH
5862: LD_INT 4
5864: PUSH
5865: EMPTY
5866: LIST
5867: LIST
5868: PUSH
5869: EMPTY
5870: LIST
5871: LIST
5872: PPUSH
5873: CALL_OW 69
5877: IFFALSE 5894
// begin Wait ( 1 1$25 ) ;
5879: LD_INT 2975
5881: PPUSH
5882: CALL_OW 67
// more_troops := true ;
5886: LD_ADDR_VAR 0 3
5890: PUSH
5891: LD_INT 1
5893: ST_TO_ADDR
// end ; if more_troops then
5894: LD_VAR 0 3
5898: IFFALSE 6086
// begin force := PrepareArabianTroops ( [ 4 , 5 , 6 ] [ Difficulty ] , skill , arArea2 ) ;
5900: LD_ADDR_VAR 0 8
5904: PUSH
5905: LD_INT 4
5907: PUSH
5908: LD_INT 5
5910: PUSH
5911: LD_INT 6
5913: PUSH
5914: EMPTY
5915: LIST
5916: LIST
5917: LIST
5918: PUSH
5919: LD_OWVAR 67
5923: ARRAY
5924: PPUSH
5925: LD_VAR 0 4
5929: PPUSH
5930: LD_INT 14
5932: PPUSH
5933: CALL 5547 0 3
5937: ST_TO_ADDR
// veh := PrepareTank ( 2 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_heavy_machine_gun , ru_gatling_gun ] [ Difficulty ] , 90 ) ;
5938: LD_ADDR_VAR 0 7
5942: PUSH
5943: LD_INT 2
5945: PPUSH
5946: LD_INT 3
5948: PPUSH
5949: LD_INT 22
5951: PPUSH
5952: LD_INT 1
5954: PPUSH
5955: LD_INT 1
5957: PPUSH
5958: LD_INT 42
5960: PUSH
5961: LD_INT 42
5963: PUSH
5964: LD_INT 43
5966: PUSH
5967: EMPTY
5968: LIST
5969: LIST
5970: LIST
5971: PUSH
5972: LD_OWVAR 67
5976: ARRAY
5977: PPUSH
5978: LD_INT 90
5980: PPUSH
5981: CALL 490 0 7
5985: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5986: LD_VAR 0 7
5990: PPUSH
5991: LD_INT 4
5993: PPUSH
5994: CALL_OW 233
// PlaceUnitArea ( veh , arArea1 , false ) ;
5998: LD_VAR 0 7
6002: PPUSH
6003: LD_INT 13
6005: PPUSH
6006: LD_INT 0
6008: PPUSH
6009: CALL_OW 49
// uc_side := 2 ;
6013: LD_ADDR_OWVAR 20
6017: PUSH
6018: LD_INT 2
6020: ST_TO_ADDR
// uc_nation := 2 ;
6021: LD_ADDR_OWVAR 21
6025: PUSH
6026: LD_INT 2
6028: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
6029: LD_INT 0
6031: PPUSH
6032: LD_INT 1
6034: PPUSH
6035: LD_VAR 0 4
6039: PPUSH
6040: CALL_OW 380
// un := CreateHuman ;
6044: LD_ADDR_VAR 0 6
6048: PUSH
6049: CALL_OW 44
6053: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
6054: LD_VAR 0 6
6058: PPUSH
6059: LD_VAR 0 7
6063: PPUSH
6064: CALL_OW 52
// force := force ^ un ;
6068: LD_ADDR_VAR 0 8
6072: PUSH
6073: LD_VAR 0 8
6077: PUSH
6078: LD_VAR 0 6
6082: ADD
6083: ST_TO_ADDR
// end else
6084: GO 6124
// begin force := PrepareArabianTroops ( [ 3 , 4 , 5 ] [ Difficulty ] , skill , arArea2 ) ;
6086: LD_ADDR_VAR 0 8
6090: PUSH
6091: LD_INT 3
6093: PUSH
6094: LD_INT 4
6096: PUSH
6097: LD_INT 5
6099: PUSH
6100: EMPTY
6101: LIST
6102: LIST
6103: LIST
6104: PUSH
6105: LD_OWVAR 67
6109: ARRAY
6110: PPUSH
6111: LD_VAR 0 4
6115: PPUSH
6116: LD_INT 14
6118: PPUSH
6119: CALL 5547 0 3
6123: ST_TO_ADDR
// end ; if force then
6124: LD_VAR 0 8
6128: IFFALSE 6140
// ar_forces := force ;
6130: LD_ADDR_EXP 27
6134: PUSH
6135: LD_VAR 0 8
6139: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
6140: LD_INT 35
6142: PPUSH
6143: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 ;
6147: LD_INT 22
6149: PUSH
6150: LD_INT 2
6152: PUSH
6153: EMPTY
6154: LIST
6155: LIST
6156: PUSH
6157: LD_INT 21
6159: PUSH
6160: LD_INT 1
6162: PUSH
6163: EMPTY
6164: LIST
6165: LIST
6166: PUSH
6167: EMPTY
6168: LIST
6169: LIST
6170: PPUSH
6171: CALL_OW 69
6175: PUSH
6176: LD_INT 0
6178: EQUAL
6179: IFFALSE 6140
// Wait ( timer ) ;
6181: LD_VAR 0 2
6185: PPUSH
6186: CALL_OW 67
// force := PrepareArabianTroops ( [ 4 , 5 , 6 ] [ Difficulty ] , skill , [ arArea1 , arArea2 ] [ rand ( 1 , 2 ) ] ) ;
6190: LD_ADDR_VAR 0 8
6194: PUSH
6195: LD_INT 4
6197: PUSH
6198: LD_INT 5
6200: PUSH
6201: LD_INT 6
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: LIST
6208: PUSH
6209: LD_OWVAR 67
6213: ARRAY
6214: PPUSH
6215: LD_VAR 0 4
6219: PPUSH
6220: LD_INT 13
6222: PUSH
6223: LD_INT 14
6225: PUSH
6226: EMPTY
6227: LIST
6228: LIST
6229: PUSH
6230: LD_INT 1
6232: PPUSH
6233: LD_INT 2
6235: PPUSH
6236: CALL_OW 12
6240: ARRAY
6241: PPUSH
6242: CALL 5547 0 3
6246: ST_TO_ADDR
// if Difficulty > 1 and Delta then
6247: LD_OWVAR 67
6251: PUSH
6252: LD_INT 1
6254: GREATER
6255: PUSH
6256: LD_EXP 6
6260: AND
6261: IFFALSE 6340
// begin uc_side := 2 ;
6263: LD_ADDR_OWVAR 20
6267: PUSH
6268: LD_INT 2
6270: ST_TO_ADDR
// uc_nation := 2 ;
6271: LD_ADDR_OWVAR 21
6275: PUSH
6276: LD_INT 2
6278: ST_TO_ADDR
// PrepareHuman ( false , 2 , skill ) ;
6279: LD_INT 0
6281: PPUSH
6282: LD_INT 2
6284: PPUSH
6285: LD_VAR 0 4
6289: PPUSH
6290: CALL_OW 380
// eng := CreateHuman ;
6294: LD_ADDR_VAR 0 5
6298: PUSH
6299: CALL_OW 44
6303: ST_TO_ADDR
// PlaceUnitArea ( eng , arArea1 , false ) ;
6304: LD_VAR 0 5
6308: PPUSH
6309: LD_INT 13
6311: PPUSH
6312: LD_INT 0
6314: PPUSH
6315: CALL_OW 49
// Wait ( 3 ) ;
6319: LD_INT 3
6321: PPUSH
6322: CALL_OW 67
// AddComEnterUnit ( eng , Delta ) ;
6326: LD_VAR 0 5
6330: PPUSH
6331: LD_EXP 6
6335: PPUSH
6336: CALL_OW 180
// end ; if force then
6340: LD_VAR 0 8
6344: IFFALSE 6356
// ar_forces := force ;
6346: LD_ADDR_EXP 27
6350: PUSH
6351: LD_VAR 0 8
6355: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
6356: LD_INT 35
6358: PPUSH
6359: CALL_OW 67
// if eng then
6363: LD_VAR 0 5
6367: IFFALSE 6421
// if GetSide ( Delta ) = 2 and IsOk ( eng ) and not IsInUnit ( eng ) then
6369: LD_EXP 6
6373: PPUSH
6374: CALL_OW 255
6378: PUSH
6379: LD_INT 2
6381: EQUAL
6382: PUSH
6383: LD_VAR 0 5
6387: PPUSH
6388: CALL_OW 302
6392: AND
6393: PUSH
6394: LD_VAR 0 5
6398: PPUSH
6399: CALL_OW 310
6403: NOT
6404: AND
6405: IFFALSE 6421
// ComEnterUnit ( eng , Delta ) ;
6407: LD_VAR 0 5
6411: PPUSH
6412: LD_EXP 6
6416: PPUSH
6417: CALL_OW 120
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 ;
6421: LD_INT 22
6423: PUSH
6424: LD_INT 2
6426: PUSH
6427: EMPTY
6428: LIST
6429: LIST
6430: PUSH
6431: LD_INT 21
6433: PUSH
6434: LD_INT 1
6436: PUSH
6437: EMPTY
6438: LIST
6439: LIST
6440: PUSH
6441: EMPTY
6442: LIST
6443: LIST
6444: PPUSH
6445: CALL_OW 69
6449: PUSH
6450: LD_INT 0
6452: EQUAL
6453: IFFALSE 6356
// Wait ( 2 2$00 ) ;
6455: LD_INT 4200
6457: PPUSH
6458: CALL_OW 67
// ap_killers := PrepareArabianTroops ( [ 1 , 2 , 2 ] [ Difficulty ] , skill , arArea1 ) ;
6462: LD_ADDR_EXP 28
6466: PUSH
6467: LD_INT 1
6469: PUSH
6470: LD_INT 2
6472: PUSH
6473: LD_INT 2
6475: PUSH
6476: EMPTY
6477: LIST
6478: LIST
6479: LIST
6480: PUSH
6481: LD_OWVAR 67
6485: ARRAY
6486: PPUSH
6487: LD_VAR 0 4
6491: PPUSH
6492: LD_INT 13
6494: PPUSH
6495: CALL 5547 0 3
6499: ST_TO_ADDR
// Wait ( timer * 2 ) ;
6500: LD_VAR 0 2
6504: PUSH
6505: LD_INT 2
6507: MUL
6508: PPUSH
6509: CALL_OW 67
// ar_forces := PrepareArabianTroops ( [ 5 , 6 , 7 ] [ Difficulty ] , skill , arArea1 ) ^ PrepareArabianTroops ( [ 3 , 4 , 4 ] [ Difficulty ] , skill , arArea2 ) ;
6513: LD_ADDR_EXP 27
6517: PUSH
6518: LD_INT 5
6520: PUSH
6521: LD_INT 6
6523: PUSH
6524: LD_INT 7
6526: PUSH
6527: EMPTY
6528: LIST
6529: LIST
6530: LIST
6531: PUSH
6532: LD_OWVAR 67
6536: ARRAY
6537: PPUSH
6538: LD_VAR 0 4
6542: PPUSH
6543: LD_INT 13
6545: PPUSH
6546: CALL 5547 0 3
6550: PUSH
6551: LD_INT 3
6553: PUSH
6554: LD_INT 4
6556: PUSH
6557: LD_INT 4
6559: PUSH
6560: EMPTY
6561: LIST
6562: LIST
6563: LIST
6564: PUSH
6565: LD_OWVAR 67
6569: ARRAY
6570: PPUSH
6571: LD_VAR 0 4
6575: PPUSH
6576: LD_INT 14
6578: PPUSH
6579: CALL 5547 0 3
6583: ADD
6584: ST_TO_ADDR
// end ;
6585: PPOPN 8
6587: END
// every 0 0$03 trigger ar_forces do var i , target ;
6588: LD_EXP 27
6592: IFFALSE 6790
6594: GO 6596
6596: DISABLE
6597: LD_INT 0
6599: PPUSH
6600: PPUSH
// begin enable ;
6601: ENABLE
// if not ar_forces then
6602: LD_EXP 27
6606: NOT
6607: IFFALSE 6611
// exit ;
6609: GO 6790
// if Delta then
6611: LD_EXP 6
6615: IFFALSE 6629
// target := Delta else
6617: LD_ADDR_VAR 0 2
6621: PUSH
6622: LD_EXP 6
6626: ST_TO_ADDR
6627: GO 6639
// target := JMM ;
6629: LD_ADDR_VAR 0 2
6633: PUSH
6634: LD_EXP 16
6638: ST_TO_ADDR
// for i in ar_forces do
6639: LD_ADDR_VAR 0 1
6643: PUSH
6644: LD_EXP 27
6648: PUSH
6649: FOR_IN
6650: IFFALSE 6788
// begin if i in FilterAllUnits ( [ f_driving ] ) then
6652: LD_VAR 0 1
6656: PUSH
6657: LD_INT 55
6659: PUSH
6660: EMPTY
6661: LIST
6662: PPUSH
6663: CALL_OW 69
6667: IN
6668: IFFALSE 6711
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , IsInUnit ( i ) ) ) else
6670: LD_VAR 0 1
6674: PPUSH
6675: LD_INT 22
6677: PUSH
6678: LD_INT 1
6680: PUSH
6681: EMPTY
6682: LIST
6683: LIST
6684: PPUSH
6685: CALL_OW 69
6689: PPUSH
6690: LD_VAR 0 1
6694: PPUSH
6695: CALL_OW 310
6699: PPUSH
6700: CALL_OW 74
6704: PPUSH
6705: CALL_OW 115
6709: GO 6786
// if GetDistUnits ( i , target ) > 30 then
6711: LD_VAR 0 1
6715: PPUSH
6716: LD_VAR 0 2
6720: PPUSH
6721: CALL_OW 296
6725: PUSH
6726: LD_INT 30
6728: GREATER
6729: IFFALSE 6762
// ComAgressiveMove ( i , GetX ( target ) , GetY ( target ) ) else
6731: LD_VAR 0 1
6735: PPUSH
6736: LD_VAR 0 2
6740: PPUSH
6741: CALL_OW 250
6745: PPUSH
6746: LD_VAR 0 2
6750: PPUSH
6751: CALL_OW 251
6755: PPUSH
6756: CALL_OW 114
6760: GO 6786
// Attack ( i , FilterAllUnits ( [ f_enemy , 2 ] ) ) ;
6762: LD_VAR 0 1
6766: PPUSH
6767: LD_INT 81
6769: PUSH
6770: LD_INT 2
6772: PUSH
6773: EMPTY
6774: LIST
6775: LIST
6776: PPUSH
6777: CALL_OW 69
6781: PPUSH
6782: CALL 795 0 2
// end ;
6786: GO 6649
6788: POP
6789: POP
// end ;
6790: PPOPN 2
6792: END
// every 0 0$01 trigger ap_killers do var filter , i , target ;
6793: LD_EXP 28
6797: IFFALSE 6957
6799: GO 6801
6801: DISABLE
6802: LD_INT 0
6804: PPUSH
6805: PPUSH
6806: PPUSH
// begin enable ;
6807: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) ;
6808: LD_ADDR_VAR 0 1
6812: PUSH
6813: LD_INT 22
6815: PUSH
6816: LD_INT 0
6818: PUSH
6819: EMPTY
6820: LIST
6821: LIST
6822: PUSH
6823: LD_INT 25
6825: PUSH
6826: LD_INT 12
6828: PUSH
6829: EMPTY
6830: LIST
6831: LIST
6832: PUSH
6833: EMPTY
6834: LIST
6835: LIST
6836: PPUSH
6837: CALL_OW 69
6841: ST_TO_ADDR
// if not filter then
6842: LD_VAR 0 1
6846: NOT
6847: IFFALSE 6874
// begin ar_forces := ar_forces ^ ap_killers ;
6849: LD_ADDR_EXP 27
6853: PUSH
6854: LD_EXP 27
6858: PUSH
6859: LD_EXP 28
6863: ADD
6864: ST_TO_ADDR
// ap_killers := [ ] ;
6865: LD_ADDR_EXP 28
6869: PUSH
6870: EMPTY
6871: ST_TO_ADDR
// exit ;
6872: GO 6957
// end ; for i in ap_killers do
6874: LD_ADDR_VAR 0 2
6878: PUSH
6879: LD_EXP 28
6883: PUSH
6884: FOR_IN
6885: IFFALSE 6955
// begin if not IsOk ( i ) then
6887: LD_VAR 0 2
6891: PPUSH
6892: CALL_OW 302
6896: NOT
6897: IFFALSE 6901
// continue ;
6899: GO 6884
// if not HasTask ( i ) then
6901: LD_VAR 0 2
6905: PPUSH
6906: CALL_OW 314
6910: NOT
6911: IFFALSE 6933
// target := NearestUnitToUnit ( filter , i ) ;
6913: LD_ADDR_VAR 0 3
6917: PUSH
6918: LD_VAR 0 1
6922: PPUSH
6923: LD_VAR 0 2
6927: PPUSH
6928: CALL_OW 74
6932: ST_TO_ADDR
// if target then
6933: LD_VAR 0 3
6937: IFFALSE 6953
// ComAttackUnit ( i , target ) ;
6939: LD_VAR 0 2
6943: PPUSH
6944: LD_VAR 0 3
6948: PPUSH
6949: CALL_OW 115
// end ;
6953: GO 6884
6955: POP
6956: POP
// end ; end_of_file
6957: PPOPN 3
6959: END
// every 0 0$40 + 0 0$2 trigger Delta do var i , counter , cr ;
6960: LD_EXP 6
6964: IFFALSE 7096
6966: GO 6968
6968: DISABLE
6969: LD_INT 0
6971: PPUSH
6972: PPUSH
6973: PPUSH
// begin counter := [ 300 , 250 , 220 ] [ Difficulty ] ;
6974: LD_ADDR_VAR 0 2
6978: PUSH
6979: LD_INT 300
6981: PUSH
6982: LD_INT 250
6984: PUSH
6985: LD_INT 220
6987: PUSH
6988: EMPTY
6989: LIST
6990: LIST
6991: LIST
6992: PUSH
6993: LD_OWVAR 67
6997: ARRAY
6998: ST_TO_ADDR
// CreateCratesArea ( Rand ( 1 , 3 ) , cratesArea , true ) ;
6999: LD_INT 1
7001: PPUSH
7002: LD_INT 3
7004: PPUSH
7005: CALL_OW 12
7009: PPUSH
7010: LD_INT 7
7012: PPUSH
7013: LD_INT 1
7015: PPUSH
7016: CALL_OW 55
// repeat wait ( rand ( 1 1$30 , 2 2$20 ) ) ;
7020: LD_INT 3150
7022: PPUSH
7023: LD_INT 4900
7025: PPUSH
7026: CALL_OW 12
7030: PPUSH
7031: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
7035: LD_ADDR_VAR 0 3
7039: PUSH
7040: LD_INT 1
7042: PPUSH
7043: LD_INT 5
7045: PPUSH
7046: CALL_OW 12
7050: ST_TO_ADDR
// CreateCratesArea ( cr , cratesArea , true ) ;
7051: LD_VAR 0 3
7055: PPUSH
7056: LD_INT 7
7058: PPUSH
7059: LD_INT 1
7061: PPUSH
7062: CALL_OW 55
// counter := counter - cr * 10 ;
7066: LD_ADDR_VAR 0 2
7070: PUSH
7071: LD_VAR 0 2
7075: PUSH
7076: LD_VAR 0 3
7080: PUSH
7081: LD_INT 10
7083: MUL
7084: MINUS
7085: ST_TO_ADDR
// until counter <= 0 ;
7086: LD_VAR 0 2
7090: PUSH
7091: LD_INT 0
7093: LESSEQUAL
7094: IFFALSE 7020
// end ;
7096: PPOPN 3
7098: END
// every 0 0$03 trigger not Delta do var i ;
7099: LD_EXP 6
7103: NOT
7104: IFFALSE 7174
7106: GO 7108
7108: DISABLE
7109: LD_INT 0
7111: PPUSH
// begin for i = 1 to 4 - Difficulty do
7112: LD_ADDR_VAR 0 1
7116: PUSH
7117: DOUBLE
7118: LD_INT 1
7120: DEC
7121: ST_TO_ADDR
7122: LD_INT 4
7124: PUSH
7125: LD_OWVAR 67
7129: MINUS
7130: PUSH
7131: FOR_TO
7132: IFFALSE 7172
// begin CreateCratesArea ( rand ( 2 , 5 ) , deltaMainArea , true ) ;
7134: LD_INT 2
7136: PPUSH
7137: LD_INT 5
7139: PPUSH
7140: CALL_OW 12
7144: PPUSH
7145: LD_INT 8
7147: PPUSH
7148: LD_INT 1
7150: PPUSH
7151: CALL_OW 55
// Wait ( rand ( 0 0$16 , 0 0$39 ) ) ;
7155: LD_INT 560
7157: PPUSH
7158: LD_INT 1365
7160: PPUSH
7161: CALL_OW 12
7165: PPUSH
7166: CALL_OW 67
// end ;
7170: GO 7131
7172: POP
7173: POP
// end ;
7174: PPOPN 1
7176: END
// every 3 3$00 trigger tick < 15 15$00 do
7177: LD_OWVAR 1
7181: PUSH
7182: LD_INT 31500
7184: LESS
7185: IFFALSE 7245
7187: GO 7189
7189: DISABLE
// begin enable ;
7190: ENABLE
// CreateCratesAnyWhere ( rand ( 1 , 3 ) , true ) ;
7191: LD_INT 1
7193: PPUSH
7194: LD_INT 3
7196: PPUSH
7197: CALL_OW 12
7201: PPUSH
7202: LD_INT 1
7204: PPUSH
7205: CALL_OW 57
// Wait ( rand ( 0 0$38 , 0 0$59 ) ) ;
7209: LD_INT 1330
7211: PPUSH
7212: LD_INT 2065
7214: PPUSH
7215: CALL_OW 12
7219: PPUSH
7220: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 4 ) , riverArea , true ) ;
7224: LD_INT 1
7226: PPUSH
7227: LD_INT 4
7229: PPUSH
7230: CALL_OW 12
7234: PPUSH
7235: LD_INT 15
7237: PPUSH
7238: LD_INT 1
7240: PPUSH
7241: CALL_OW 55
// end ; end_of_file
7245: END
// on UnitDestroyed ( un ) do begin if un = JMM then
7246: LD_VAR 0 1
7250: PUSH
7251: LD_EXP 16
7255: EQUAL
7256: IFFALSE 7265
// YouLost ( JMM ) ;
7258: LD_STRING JMM
7260: PPUSH
7261: CALL_OW 104
// if un = Delta then
7265: LD_VAR 0 1
7269: PUSH
7270: LD_EXP 6
7274: EQUAL
7275: IFFALSE 7298
// begin Delta := 0 ;
7277: LD_ADDR_EXP 6
7281: PUSH
7282: LD_INT 0
7284: ST_TO_ADDR
// SetRestrict ( b_depot , 1 , true ) ;
7285: LD_INT 0
7287: PPUSH
7288: LD_INT 1
7290: PPUSH
7291: LD_INT 1
7293: PPUSH
7294: CALL_OW 324
// end ; if un in ar_forces then
7298: LD_VAR 0 1
7302: PUSH
7303: LD_EXP 27
7307: IN
7308: IFFALSE 7326
// ar_forces := ar_forces diff un ;
7310: LD_ADDR_EXP 27
7314: PUSH
7315: LD_EXP 27
7319: PUSH
7320: LD_VAR 0 1
7324: DIFF
7325: ST_TO_ADDR
// if un in ap_killers then
7326: LD_VAR 0 1
7330: PUSH
7331: LD_EXP 28
7335: IN
7336: IFFALSE 7354
// ap_killers := ap_killers diff un ;
7338: LD_ADDR_EXP 28
7342: PUSH
7343: LD_EXP 28
7347: PUSH
7348: LD_VAR 0 1
7352: DIFF
7353: ST_TO_ADDR
// if un in FilterAllUnits ( [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ) then
7354: LD_VAR 0 1
7358: PUSH
7359: LD_INT 2
7361: PUSH
7362: LD_INT 25
7364: PUSH
7365: LD_INT 12
7367: PUSH
7368: EMPTY
7369: LIST
7370: LIST
7371: PUSH
7372: LD_INT 25
7374: PUSH
7375: LD_INT 16
7377: PUSH
7378: EMPTY
7379: LIST
7380: LIST
7381: PUSH
7382: EMPTY
7383: LIST
7384: LIST
7385: LIST
7386: PPUSH
7387: CALL_OW 69
7391: IN
7392: IFFALSE 7408
// apeKillCounter := apeKillCounter + 1 ;
7394: LD_ADDR_EXP 15
7398: PUSH
7399: LD_EXP 15
7403: PUSH
7404: LD_INT 1
7406: PLUS
7407: ST_TO_ADDR
// end ;
7408: PPOPN 1
7410: END
// on Contact ( s1 , s2 ) do if s1 = 1 and s2 = 2 and not arab_spotted then
7411: LD_VAR 0 1
7415: PUSH
7416: LD_INT 1
7418: EQUAL
7419: PUSH
7420: LD_VAR 0 2
7424: PUSH
7425: LD_INT 2
7427: EQUAL
7428: AND
7429: PUSH
7430: LD_EXP 13
7434: NOT
7435: AND
7436: IFFALSE 7446
// arab_spotted := true ;
7438: LD_ADDR_EXP 13
7442: PUSH
7443: LD_INT 1
7445: ST_TO_ADDR
7446: PPOPN 2
7448: END
// on EndTheMissionRaised ( p ) do begin end_the_mission_allowed := false ;
7449: LD_ADDR_OWVAR 57
7453: PUSH
7454: LD_INT 0
7456: ST_TO_ADDR
// end_mission := true ;
7457: LD_ADDR_EXP 14
7461: PUSH
7462: LD_INT 1
7464: ST_TO_ADDR
// end ;
7465: PPOPN 1
7467: END
// on ApemanTamed ( apeman , sci ) do begin if GetSide ( sci ) = 1 then
7468: LD_VAR 0 2
7472: PPUSH
7473: CALL_OW 255
7477: PUSH
7478: LD_INT 1
7480: EQUAL
7481: IFFALSE 7497
// apeman_counter := apeman_counter + 1 ;
7483: LD_ADDR_EXP 12
7487: PUSH
7488: LD_EXP 12
7492: PUSH
7493: LD_INT 1
7495: PLUS
7496: ST_TO_ADDR
// if not first_apeman_tamed then
7497: LD_EXP 8
7501: NOT
7502: IFFALSE 7702
// begin first_apeman_tamed := true ;
7504: LD_ADDR_EXP 8
7508: PUSH
7509: LD_INT 1
7511: ST_TO_ADDR
// if sci = Gladstone then
7512: LD_VAR 0 2
7516: PUSH
7517: LD_EXP 17
7521: EQUAL
7522: IFFALSE 7536
// Say ( Gladstone , D7b-Glad-1 ) ;
7524: LD_EXP 17
7528: PPUSH
7529: LD_STRING D7b-Glad-1
7531: PPUSH
7532: CALL_OW 88
// if sci = Denis then
7536: LD_VAR 0 2
7540: PUSH
7541: LD_EXP 19
7545: EQUAL
7546: IFFALSE 7560
// Say ( Denis , D7a-Den-1 ) ;
7548: LD_EXP 19
7552: PPUSH
7553: LD_STRING D7a-Den-1
7555: PPUSH
7556: CALL_OW 88
// if not sci in [ JMM , Gladstone , Denis , Lisa , Frank , Bobby , Cyrus , Donaldson ] then
7560: LD_VAR 0 2
7564: PUSH
7565: LD_EXP 16
7569: PUSH
7570: LD_EXP 17
7574: PUSH
7575: LD_EXP 19
7579: PUSH
7580: LD_EXP 22
7584: PUSH
7585: LD_EXP 23
7589: PUSH
7590: LD_EXP 24
7594: PUSH
7595: LD_EXP 25
7599: PUSH
7600: LD_EXP 21
7604: PUSH
7605: EMPTY
7606: LIST
7607: LIST
7608: LIST
7609: LIST
7610: LIST
7611: LIST
7612: LIST
7613: LIST
7614: IN
7615: NOT
7616: IFFALSE 7659
// begin if GetSex ( sci ) = sex_male then
7618: LD_VAR 0 2
7622: PPUSH
7623: CALL_OW 258
7627: PUSH
7628: LD_INT 1
7630: EQUAL
7631: IFFALSE 7647
// Say ( sci , D7c-Sci1-1 ) else
7633: LD_VAR 0 2
7637: PPUSH
7638: LD_STRING D7c-Sci1-1
7640: PPUSH
7641: CALL_OW 88
7645: GO 7659
// Say ( sci , D7c-FSci1-1 ) ;
7647: LD_VAR 0 2
7651: PPUSH
7652: LD_STRING D7c-FSci1-1
7654: PPUSH
7655: CALL_OW 88
// end ; if not sci = Gladstone then
7659: LD_VAR 0 2
7663: PUSH
7664: LD_EXP 17
7668: EQUAL
7669: NOT
7670: IFFALSE 7684
// Say ( Gladstone , D7c-Glad-1 ) ;
7672: LD_EXP 17
7676: PPUSH
7677: LD_STRING D7c-Glad-1
7679: PPUSH
7680: CALL_OW 88
// if Lisa then
7684: LD_EXP 22
7688: IFFALSE 7702
// Say ( Lisa , D8-Lisa-1 ) ;
7690: LD_EXP 22
7694: PPUSH
7695: LD_STRING D8-Lisa-1
7697: PPUSH
7698: CALL_OW 88
// end ; end ; end_of_file
7702: PPOPN 2
7704: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
7705: GO 7707
7707: DISABLE
// begin ru_radar := 98 ;
7708: LD_ADDR_EXP 29
7712: PUSH
7713: LD_INT 98
7715: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
7716: LD_ADDR_EXP 30
7720: PUSH
7721: LD_INT 89
7723: ST_TO_ADDR
// us_hack := 99 ;
7724: LD_ADDR_EXP 31
7728: PUSH
7729: LD_INT 99
7731: ST_TO_ADDR
// us_artillery := 97 ;
7732: LD_ADDR_EXP 32
7736: PUSH
7737: LD_INT 97
7739: ST_TO_ADDR
// ar_bio_bomb := 91 ;
7740: LD_ADDR_EXP 33
7744: PUSH
7745: LD_INT 91
7747: ST_TO_ADDR
// end ; end_of_file end_of_file
7748: END
// export StreamModeActive , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote ; every 0 0$1 do
7749: GO 7751
7751: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
7752: LD_STRING initStreamRollete();
7754: PPUSH
7755: CALL_OW 559
// InitStreamMode ;
7759: CALL 7764 0 0
// end ;
7763: END
// function InitStreamMode ; begin
7764: LD_INT 0
7766: PPUSH
// streamModeActive := false ;
7767: LD_ADDR_EXP 34
7771: PUSH
7772: LD_INT 0
7774: ST_TO_ADDR
// sRocket := false ;
7775: LD_ADDR_EXP 37
7779: PUSH
7780: LD_INT 0
7782: ST_TO_ADDR
// sSpeed := false ;
7783: LD_ADDR_EXP 36
7787: PUSH
7788: LD_INT 0
7790: ST_TO_ADDR
// sEngine := false ;
7791: LD_ADDR_EXP 38
7795: PUSH
7796: LD_INT 0
7798: ST_TO_ADDR
// sSpec := false ;
7799: LD_ADDR_EXP 35
7803: PUSH
7804: LD_INT 0
7806: ST_TO_ADDR
// sLevel := false ;
7807: LD_ADDR_EXP 39
7811: PUSH
7812: LD_INT 0
7814: ST_TO_ADDR
// sArmoury := false ;
7815: LD_ADDR_EXP 40
7819: PUSH
7820: LD_INT 0
7822: ST_TO_ADDR
// sRadar := false ;
7823: LD_ADDR_EXP 41
7827: PUSH
7828: LD_INT 0
7830: ST_TO_ADDR
// sBunker := false ;
7831: LD_ADDR_EXP 42
7835: PUSH
7836: LD_INT 0
7838: ST_TO_ADDR
// sHack := false ;
7839: LD_ADDR_EXP 43
7843: PUSH
7844: LD_INT 0
7846: ST_TO_ADDR
// sFire := false ;
7847: LD_ADDR_EXP 44
7851: PUSH
7852: LD_INT 0
7854: ST_TO_ADDR
// sRefresh := false ;
7855: LD_ADDR_EXP 45
7859: PUSH
7860: LD_INT 0
7862: ST_TO_ADDR
// sExp := false ;
7863: LD_ADDR_EXP 46
7867: PUSH
7868: LD_INT 0
7870: ST_TO_ADDR
// sDepot := false ;
7871: LD_ADDR_EXP 47
7875: PUSH
7876: LD_INT 0
7878: ST_TO_ADDR
// sFlag := false ;
7879: LD_ADDR_EXP 48
7883: PUSH
7884: LD_INT 0
7886: ST_TO_ADDR
// sKamikadze := false ;
7887: LD_ADDR_EXP 56
7891: PUSH
7892: LD_INT 0
7894: ST_TO_ADDR
// sTroll := false ;
7895: LD_ADDR_EXP 57
7899: PUSH
7900: LD_INT 0
7902: ST_TO_ADDR
// sSlow := false ;
7903: LD_ADDR_EXP 58
7907: PUSH
7908: LD_INT 0
7910: ST_TO_ADDR
// sLack := false ;
7911: LD_ADDR_EXP 59
7915: PUSH
7916: LD_INT 0
7918: ST_TO_ADDR
// sTank := false ;
7919: LD_ADDR_EXP 61
7923: PUSH
7924: LD_INT 0
7926: ST_TO_ADDR
// sRemote := false ;
7927: LD_ADDR_EXP 62
7931: PUSH
7932: LD_INT 0
7934: ST_TO_ADDR
// sSold := false ;
7935: LD_ADDR_EXP 49
7939: PUSH
7940: LD_INT 0
7942: ST_TO_ADDR
// sDiff := false ;
7943: LD_ADDR_EXP 50
7947: PUSH
7948: LD_INT 0
7950: ST_TO_ADDR
// sFog := false ;
7951: LD_ADDR_EXP 53
7955: PUSH
7956: LD_INT 0
7958: ST_TO_ADDR
// sReset := false ;
7959: LD_ADDR_EXP 54
7963: PUSH
7964: LD_INT 0
7966: ST_TO_ADDR
// sSun := false ;
7967: LD_ADDR_EXP 55
7971: PUSH
7972: LD_INT 0
7974: ST_TO_ADDR
// sTiger := false ;
7975: LD_ADDR_EXP 51
7979: PUSH
7980: LD_INT 0
7982: ST_TO_ADDR
// sBomb := false ;
7983: LD_ADDR_EXP 52
7987: PUSH
7988: LD_INT 0
7990: ST_TO_ADDR
// sWound := false ;
7991: LD_ADDR_EXP 60
7995: PUSH
7996: LD_INT 0
7998: ST_TO_ADDR
// end ;
7999: LD_VAR 0 1
8003: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
8004: LD_VAR 0 2
8008: PUSH
8009: LD_INT 100
8011: EQUAL
8012: IFFALSE 8547
// begin if not StreamModeActive then
8014: LD_EXP 34
8018: NOT
8019: IFFALSE 8029
// StreamModeActive := true ;
8021: LD_ADDR_EXP 34
8025: PUSH
8026: LD_INT 1
8028: ST_TO_ADDR
// if p3 = 0 then
8029: LD_VAR 0 3
8033: PUSH
8034: LD_INT 0
8036: EQUAL
8037: IFFALSE 8043
// InitStreamMode ;
8039: CALL 7764 0 0
// if p3 = 1 then
8043: LD_VAR 0 3
8047: PUSH
8048: LD_INT 1
8050: EQUAL
8051: IFFALSE 8061
// sRocket := true ;
8053: LD_ADDR_EXP 37
8057: PUSH
8058: LD_INT 1
8060: ST_TO_ADDR
// if p3 = 2 then
8061: LD_VAR 0 3
8065: PUSH
8066: LD_INT 2
8068: EQUAL
8069: IFFALSE 8079
// sSpeed := true ;
8071: LD_ADDR_EXP 36
8075: PUSH
8076: LD_INT 1
8078: ST_TO_ADDR
// if p3 = 3 then
8079: LD_VAR 0 3
8083: PUSH
8084: LD_INT 3
8086: EQUAL
8087: IFFALSE 8097
// sEngine := true ;
8089: LD_ADDR_EXP 38
8093: PUSH
8094: LD_INT 1
8096: ST_TO_ADDR
// if p3 = 4 then
8097: LD_VAR 0 3
8101: PUSH
8102: LD_INT 4
8104: EQUAL
8105: IFFALSE 8115
// sSpec := true ;
8107: LD_ADDR_EXP 35
8111: PUSH
8112: LD_INT 1
8114: ST_TO_ADDR
// if p3 = 5 then
8115: LD_VAR 0 3
8119: PUSH
8120: LD_INT 5
8122: EQUAL
8123: IFFALSE 8133
// sLevel := true ;
8125: LD_ADDR_EXP 39
8129: PUSH
8130: LD_INT 1
8132: ST_TO_ADDR
// if p3 = 6 then
8133: LD_VAR 0 3
8137: PUSH
8138: LD_INT 6
8140: EQUAL
8141: IFFALSE 8151
// sArmoury := true ;
8143: LD_ADDR_EXP 40
8147: PUSH
8148: LD_INT 1
8150: ST_TO_ADDR
// if p3 = 7 then
8151: LD_VAR 0 3
8155: PUSH
8156: LD_INT 7
8158: EQUAL
8159: IFFALSE 8169
// sRadar := true ;
8161: LD_ADDR_EXP 41
8165: PUSH
8166: LD_INT 1
8168: ST_TO_ADDR
// if p3 = 8 then
8169: LD_VAR 0 3
8173: PUSH
8174: LD_INT 8
8176: EQUAL
8177: IFFALSE 8187
// sBunker := true ;
8179: LD_ADDR_EXP 42
8183: PUSH
8184: LD_INT 1
8186: ST_TO_ADDR
// if p3 = 9 then
8187: LD_VAR 0 3
8191: PUSH
8192: LD_INT 9
8194: EQUAL
8195: IFFALSE 8205
// sHack := true ;
8197: LD_ADDR_EXP 43
8201: PUSH
8202: LD_INT 1
8204: ST_TO_ADDR
// if p3 = 10 then
8205: LD_VAR 0 3
8209: PUSH
8210: LD_INT 10
8212: EQUAL
8213: IFFALSE 8223
// sFire := true ;
8215: LD_ADDR_EXP 44
8219: PUSH
8220: LD_INT 1
8222: ST_TO_ADDR
// if p3 = 11 then
8223: LD_VAR 0 3
8227: PUSH
8228: LD_INT 11
8230: EQUAL
8231: IFFALSE 8241
// sRefresh := true ;
8233: LD_ADDR_EXP 45
8237: PUSH
8238: LD_INT 1
8240: ST_TO_ADDR
// if p3 = 12 then
8241: LD_VAR 0 3
8245: PUSH
8246: LD_INT 12
8248: EQUAL
8249: IFFALSE 8259
// sExp := true ;
8251: LD_ADDR_EXP 46
8255: PUSH
8256: LD_INT 1
8258: ST_TO_ADDR
// if p3 = 13 then
8259: LD_VAR 0 3
8263: PUSH
8264: LD_INT 13
8266: EQUAL
8267: IFFALSE 8277
// sDepot := true ;
8269: LD_ADDR_EXP 47
8273: PUSH
8274: LD_INT 1
8276: ST_TO_ADDR
// if p3 = 14 then
8277: LD_VAR 0 3
8281: PUSH
8282: LD_INT 14
8284: EQUAL
8285: IFFALSE 8295
// sFlag := true ;
8287: LD_ADDR_EXP 48
8291: PUSH
8292: LD_INT 1
8294: ST_TO_ADDR
// if p3 = 15 then
8295: LD_VAR 0 3
8299: PUSH
8300: LD_INT 15
8302: EQUAL
8303: IFFALSE 8313
// sKamikadze := true ;
8305: LD_ADDR_EXP 56
8309: PUSH
8310: LD_INT 1
8312: ST_TO_ADDR
// if p3 = 16 then
8313: LD_VAR 0 3
8317: PUSH
8318: LD_INT 16
8320: EQUAL
8321: IFFALSE 8331
// sTroll := true ;
8323: LD_ADDR_EXP 57
8327: PUSH
8328: LD_INT 1
8330: ST_TO_ADDR
// if p3 = 17 then
8331: LD_VAR 0 3
8335: PUSH
8336: LD_INT 17
8338: EQUAL
8339: IFFALSE 8349
// sSlow := true ;
8341: LD_ADDR_EXP 58
8345: PUSH
8346: LD_INT 1
8348: ST_TO_ADDR
// if p3 = 18 then
8349: LD_VAR 0 3
8353: PUSH
8354: LD_INT 18
8356: EQUAL
8357: IFFALSE 8367
// sLack := true ;
8359: LD_ADDR_EXP 59
8363: PUSH
8364: LD_INT 1
8366: ST_TO_ADDR
// if p3 = 19 then
8367: LD_VAR 0 3
8371: PUSH
8372: LD_INT 19
8374: EQUAL
8375: IFFALSE 8385
// sTank := true ;
8377: LD_ADDR_EXP 61
8381: PUSH
8382: LD_INT 1
8384: ST_TO_ADDR
// if p3 = 20 then
8385: LD_VAR 0 3
8389: PUSH
8390: LD_INT 20
8392: EQUAL
8393: IFFALSE 8403
// sRemote := true ;
8395: LD_ADDR_EXP 62
8399: PUSH
8400: LD_INT 1
8402: ST_TO_ADDR
// if p3 = 101 then
8403: LD_VAR 0 3
8407: PUSH
8408: LD_INT 101
8410: EQUAL
8411: IFFALSE 8421
// sSold := true ;
8413: LD_ADDR_EXP 49
8417: PUSH
8418: LD_INT 1
8420: ST_TO_ADDR
// if p3 = 102 then
8421: LD_VAR 0 3
8425: PUSH
8426: LD_INT 102
8428: EQUAL
8429: IFFALSE 8439
// sDiff := true ;
8431: LD_ADDR_EXP 50
8435: PUSH
8436: LD_INT 1
8438: ST_TO_ADDR
// if p3 = 103 then
8439: LD_VAR 0 3
8443: PUSH
8444: LD_INT 103
8446: EQUAL
8447: IFFALSE 8457
// sFog := true ;
8449: LD_ADDR_EXP 53
8453: PUSH
8454: LD_INT 1
8456: ST_TO_ADDR
// if p3 = 104 then
8457: LD_VAR 0 3
8461: PUSH
8462: LD_INT 104
8464: EQUAL
8465: IFFALSE 8475
// sReset := true ;
8467: LD_ADDR_EXP 54
8471: PUSH
8472: LD_INT 1
8474: ST_TO_ADDR
// if p3 = 105 then
8475: LD_VAR 0 3
8479: PUSH
8480: LD_INT 105
8482: EQUAL
8483: IFFALSE 8493
// sSun := true ;
8485: LD_ADDR_EXP 55
8489: PUSH
8490: LD_INT 1
8492: ST_TO_ADDR
// if p3 = 106 then
8493: LD_VAR 0 3
8497: PUSH
8498: LD_INT 106
8500: EQUAL
8501: IFFALSE 8511
// sTiger := true ;
8503: LD_ADDR_EXP 51
8507: PUSH
8508: LD_INT 1
8510: ST_TO_ADDR
// if p3 = 107 then
8511: LD_VAR 0 3
8515: PUSH
8516: LD_INT 107
8518: EQUAL
8519: IFFALSE 8529
// sBomb := true ;
8521: LD_ADDR_EXP 52
8525: PUSH
8526: LD_INT 1
8528: ST_TO_ADDR
// if p3 = 108 then
8529: LD_VAR 0 3
8533: PUSH
8534: LD_INT 108
8536: EQUAL
8537: IFFALSE 8547
// sWound := true ;
8539: LD_ADDR_EXP 60
8543: PUSH
8544: LD_INT 1
8546: ST_TO_ADDR
// end ; end ;
8547: PPOPN 6
8549: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
8550: LD_EXP 34
8554: PUSH
8555: LD_EXP 37
8559: AND
8560: IFFALSE 8681
8562: GO 8564
8564: DISABLE
8565: LD_INT 0
8567: PPUSH
8568: PPUSH
// begin enable ;
8569: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
8570: LD_ADDR_VAR 0 2
8574: PUSH
8575: LD_INT 22
8577: PUSH
8578: LD_OWVAR 2
8582: PUSH
8583: EMPTY
8584: LIST
8585: LIST
8586: PUSH
8587: LD_INT 2
8589: PUSH
8590: LD_INT 34
8592: PUSH
8593: LD_INT 7
8595: PUSH
8596: EMPTY
8597: LIST
8598: LIST
8599: PUSH
8600: LD_INT 34
8602: PUSH
8603: LD_INT 45
8605: PUSH
8606: EMPTY
8607: LIST
8608: LIST
8609: PUSH
8610: LD_INT 34
8612: PUSH
8613: LD_INT 28
8615: PUSH
8616: EMPTY
8617: LIST
8618: LIST
8619: PUSH
8620: LD_INT 34
8622: PUSH
8623: LD_INT 47
8625: PUSH
8626: EMPTY
8627: LIST
8628: LIST
8629: PUSH
8630: EMPTY
8631: LIST
8632: LIST
8633: LIST
8634: LIST
8635: LIST
8636: PUSH
8637: EMPTY
8638: LIST
8639: LIST
8640: PPUSH
8641: CALL_OW 69
8645: ST_TO_ADDR
// if not tmp then
8646: LD_VAR 0 2
8650: NOT
8651: IFFALSE 8655
// exit ;
8653: GO 8681
// for i in tmp do
8655: LD_ADDR_VAR 0 1
8659: PUSH
8660: LD_VAR 0 2
8664: PUSH
8665: FOR_IN
8666: IFFALSE 8679
// begin DestroyUnit ( i ) ;
8668: LD_VAR 0 1
8672: PPUSH
8673: CALL_OW 65
// end ;
8677: GO 8665
8679: POP
8680: POP
// end ;
8681: PPOPN 2
8683: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
8684: LD_EXP 34
8688: PUSH
8689: LD_EXP 38
8693: AND
8694: IFFALSE 8775
8696: GO 8698
8698: DISABLE
8699: LD_INT 0
8701: PPUSH
8702: PPUSH
// begin enable ;
8703: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
8704: LD_ADDR_VAR 0 2
8708: PUSH
8709: LD_INT 22
8711: PUSH
8712: LD_OWVAR 2
8716: PUSH
8717: EMPTY
8718: LIST
8719: LIST
8720: PUSH
8721: LD_INT 32
8723: PUSH
8724: LD_INT 3
8726: PUSH
8727: EMPTY
8728: LIST
8729: LIST
8730: PUSH
8731: EMPTY
8732: LIST
8733: LIST
8734: PPUSH
8735: CALL_OW 69
8739: ST_TO_ADDR
// if not tmp then
8740: LD_VAR 0 2
8744: NOT
8745: IFFALSE 8749
// exit ;
8747: GO 8775
// for i in tmp do
8749: LD_ADDR_VAR 0 1
8753: PUSH
8754: LD_VAR 0 2
8758: PUSH
8759: FOR_IN
8760: IFFALSE 8773
// begin DestroyUnit ( i ) ;
8762: LD_VAR 0 1
8766: PPUSH
8767: CALL_OW 65
// end ;
8771: GO 8759
8773: POP
8774: POP
// end ;
8775: PPOPN 2
8777: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
8778: LD_EXP 34
8782: PUSH
8783: LD_EXP 35
8787: AND
8788: IFFALSE 8881
8790: GO 8792
8792: DISABLE
8793: LD_INT 0
8795: PPUSH
// begin enable ;
8796: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
8797: LD_ADDR_VAR 0 1
8801: PUSH
8802: LD_INT 22
8804: PUSH
8805: LD_OWVAR 2
8809: PUSH
8810: EMPTY
8811: LIST
8812: LIST
8813: PUSH
8814: LD_INT 2
8816: PUSH
8817: LD_INT 25
8819: PUSH
8820: LD_INT 5
8822: PUSH
8823: EMPTY
8824: LIST
8825: LIST
8826: PUSH
8827: LD_INT 25
8829: PUSH
8830: LD_INT 9
8832: PUSH
8833: EMPTY
8834: LIST
8835: LIST
8836: PUSH
8837: LD_INT 25
8839: PUSH
8840: LD_INT 8
8842: PUSH
8843: EMPTY
8844: LIST
8845: LIST
8846: PUSH
8847: EMPTY
8848: LIST
8849: LIST
8850: LIST
8851: LIST
8852: PUSH
8853: EMPTY
8854: LIST
8855: LIST
8856: PPUSH
8857: CALL_OW 69
8861: PUSH
8862: FOR_IN
8863: IFFALSE 8879
// begin SetClass ( i , 1 ) ;
8865: LD_VAR 0 1
8869: PPUSH
8870: LD_INT 1
8872: PPUSH
8873: CALL_OW 336
// end ;
8877: GO 8862
8879: POP
8880: POP
// end ;
8881: PPOPN 1
8883: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
8884: LD_EXP 34
8888: PUSH
8889: LD_EXP 36
8893: AND
8894: PUSH
8895: LD_OWVAR 65
8899: PUSH
8900: LD_INT 7
8902: LESS
8903: AND
8904: IFFALSE 8918
8906: GO 8908
8908: DISABLE
// begin enable ;
8909: ENABLE
// game_speed := 7 ;
8910: LD_ADDR_OWVAR 65
8914: PUSH
8915: LD_INT 7
8917: ST_TO_ADDR
// end ;
8918: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
8919: LD_EXP 34
8923: PUSH
8924: LD_EXP 39
8928: AND
8929: IFFALSE 9131
8931: GO 8933
8933: DISABLE
8934: LD_INT 0
8936: PPUSH
8937: PPUSH
8938: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
8939: LD_ADDR_VAR 0 3
8943: PUSH
8944: LD_INT 81
8946: PUSH
8947: LD_OWVAR 2
8951: PUSH
8952: EMPTY
8953: LIST
8954: LIST
8955: PUSH
8956: LD_INT 21
8958: PUSH
8959: LD_INT 1
8961: PUSH
8962: EMPTY
8963: LIST
8964: LIST
8965: PUSH
8966: EMPTY
8967: LIST
8968: LIST
8969: PPUSH
8970: CALL_OW 69
8974: ST_TO_ADDR
// if not tmp then
8975: LD_VAR 0 3
8979: NOT
8980: IFFALSE 8984
// exit ;
8982: GO 9131
// if tmp > 5 then
8984: LD_VAR 0 3
8988: PUSH
8989: LD_INT 5
8991: GREATER
8992: IFFALSE 9004
// k := 5 else
8994: LD_ADDR_VAR 0 2
8998: PUSH
8999: LD_INT 5
9001: ST_TO_ADDR
9002: GO 9014
// k := tmp ;
9004: LD_ADDR_VAR 0 2
9008: PUSH
9009: LD_VAR 0 3
9013: ST_TO_ADDR
// for i := 1 to k do
9014: LD_ADDR_VAR 0 1
9018: PUSH
9019: DOUBLE
9020: LD_INT 1
9022: DEC
9023: ST_TO_ADDR
9024: LD_VAR 0 2
9028: PUSH
9029: FOR_TO
9030: IFFALSE 9129
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
9032: LD_VAR 0 3
9036: PUSH
9037: LD_VAR 0 1
9041: ARRAY
9042: PPUSH
9043: LD_VAR 0 1
9047: PUSH
9048: LD_INT 4
9050: MOD
9051: PUSH
9052: LD_INT 1
9054: PLUS
9055: PPUSH
9056: CALL_OW 259
9060: PUSH
9061: LD_INT 10
9063: LESS
9064: IFFALSE 9127
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
9066: LD_VAR 0 3
9070: PUSH
9071: LD_VAR 0 1
9075: ARRAY
9076: PPUSH
9077: LD_VAR 0 1
9081: PUSH
9082: LD_INT 4
9084: MOD
9085: PUSH
9086: LD_INT 1
9088: PLUS
9089: PPUSH
9090: LD_VAR 0 3
9094: PUSH
9095: LD_VAR 0 1
9099: ARRAY
9100: PPUSH
9101: LD_VAR 0 1
9105: PUSH
9106: LD_INT 4
9108: MOD
9109: PUSH
9110: LD_INT 1
9112: PLUS
9113: PPUSH
9114: CALL_OW 259
9118: PUSH
9119: LD_INT 1
9121: PLUS
9122: PPUSH
9123: CALL_OW 237
9127: GO 9029
9129: POP
9130: POP
// end ;
9131: PPOPN 3
9133: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
9134: LD_EXP 34
9138: PUSH
9139: LD_EXP 40
9143: AND
9144: IFFALSE 9164
9146: GO 9148
9148: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
9149: LD_INT 4
9151: PPUSH
9152: LD_OWVAR 2
9156: PPUSH
9157: LD_INT 0
9159: PPUSH
9160: CALL_OW 324
9164: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
9165: LD_EXP 34
9169: PUSH
9170: LD_EXP 41
9174: AND
9175: IFFALSE 9274
9177: GO 9179
9179: DISABLE
9180: LD_INT 0
9182: PPUSH
9183: PPUSH
// begin enable ;
9184: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
9185: LD_ADDR_VAR 0 2
9189: PUSH
9190: LD_INT 22
9192: PUSH
9193: LD_OWVAR 2
9197: PUSH
9198: EMPTY
9199: LIST
9200: LIST
9201: PUSH
9202: LD_INT 2
9204: PUSH
9205: LD_INT 34
9207: PUSH
9208: LD_INT 11
9210: PUSH
9211: EMPTY
9212: LIST
9213: LIST
9214: PUSH
9215: LD_INT 34
9217: PUSH
9218: LD_INT 30
9220: PUSH
9221: EMPTY
9222: LIST
9223: LIST
9224: PUSH
9225: EMPTY
9226: LIST
9227: LIST
9228: LIST
9229: PUSH
9230: EMPTY
9231: LIST
9232: LIST
9233: PPUSH
9234: CALL_OW 69
9238: ST_TO_ADDR
// if not tmp then
9239: LD_VAR 0 2
9243: NOT
9244: IFFALSE 9248
// exit ;
9246: GO 9274
// for i in tmp do
9248: LD_ADDR_VAR 0 1
9252: PUSH
9253: LD_VAR 0 2
9257: PUSH
9258: FOR_IN
9259: IFFALSE 9272
// begin DestroyUnit ( i ) ;
9261: LD_VAR 0 1
9265: PPUSH
9266: CALL_OW 65
// end ;
9270: GO 9258
9272: POP
9273: POP
// end ;
9274: PPOPN 2
9276: END
// every 0 0$1 trigger StreamModeActive and sBunker do
9277: LD_EXP 34
9281: PUSH
9282: LD_EXP 42
9286: AND
9287: IFFALSE 9307
9289: GO 9291
9291: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
9292: LD_INT 32
9294: PPUSH
9295: LD_OWVAR 2
9299: PPUSH
9300: LD_INT 0
9302: PPUSH
9303: CALL_OW 324
9307: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
9308: LD_EXP 34
9312: PUSH
9313: LD_EXP 43
9317: AND
9318: IFFALSE 9499
9320: GO 9322
9322: DISABLE
9323: LD_INT 0
9325: PPUSH
9326: PPUSH
9327: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
9328: LD_ADDR_VAR 0 2
9332: PUSH
9333: LD_INT 22
9335: PUSH
9336: LD_OWVAR 2
9340: PUSH
9341: EMPTY
9342: LIST
9343: LIST
9344: PUSH
9345: LD_INT 33
9347: PUSH
9348: LD_INT 3
9350: PUSH
9351: EMPTY
9352: LIST
9353: LIST
9354: PUSH
9355: EMPTY
9356: LIST
9357: LIST
9358: PPUSH
9359: CALL_OW 69
9363: ST_TO_ADDR
// if not tmp then
9364: LD_VAR 0 2
9368: NOT
9369: IFFALSE 9373
// exit ;
9371: GO 9499
// side := 0 ;
9373: LD_ADDR_VAR 0 3
9377: PUSH
9378: LD_INT 0
9380: ST_TO_ADDR
// for i := 1 to 8 do
9381: LD_ADDR_VAR 0 1
9385: PUSH
9386: DOUBLE
9387: LD_INT 1
9389: DEC
9390: ST_TO_ADDR
9391: LD_INT 8
9393: PUSH
9394: FOR_TO
9395: IFFALSE 9443
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
9397: LD_OWVAR 2
9401: PUSH
9402: LD_VAR 0 1
9406: NONEQUAL
9407: PUSH
9408: LD_OWVAR 2
9412: PPUSH
9413: LD_VAR 0 1
9417: PPUSH
9418: CALL_OW 81
9422: PUSH
9423: LD_INT 2
9425: EQUAL
9426: AND
9427: IFFALSE 9441
// begin side := i ;
9429: LD_ADDR_VAR 0 3
9433: PUSH
9434: LD_VAR 0 1
9438: ST_TO_ADDR
// break ;
9439: GO 9443
// end ;
9441: GO 9394
9443: POP
9444: POP
// if not side then
9445: LD_VAR 0 3
9449: NOT
9450: IFFALSE 9454
// exit ;
9452: GO 9499
// for i := 1 to tmp do
9454: LD_ADDR_VAR 0 1
9458: PUSH
9459: DOUBLE
9460: LD_INT 1
9462: DEC
9463: ST_TO_ADDR
9464: LD_VAR 0 2
9468: PUSH
9469: FOR_TO
9470: IFFALSE 9497
// if Prob ( 30 ) then
9472: LD_INT 30
9474: PPUSH
9475: CALL_OW 13
9479: IFFALSE 9495
// SetSide ( i , side ) ;
9481: LD_VAR 0 1
9485: PPUSH
9486: LD_VAR 0 3
9490: PPUSH
9491: CALL_OW 235
9495: GO 9469
9497: POP
9498: POP
// end ;
9499: PPOPN 3
9501: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
9502: LD_EXP 34
9506: PUSH
9507: LD_EXP 45
9511: AND
9512: IFFALSE 9631
9514: GO 9516
9516: DISABLE
9517: LD_INT 0
9519: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
9520: LD_ADDR_VAR 0 1
9524: PUSH
9525: LD_INT 22
9527: PUSH
9528: LD_OWVAR 2
9532: PUSH
9533: EMPTY
9534: LIST
9535: LIST
9536: PUSH
9537: LD_INT 21
9539: PUSH
9540: LD_INT 1
9542: PUSH
9543: EMPTY
9544: LIST
9545: LIST
9546: PUSH
9547: LD_INT 3
9549: PUSH
9550: LD_INT 23
9552: PUSH
9553: LD_INT 0
9555: PUSH
9556: EMPTY
9557: LIST
9558: LIST
9559: PUSH
9560: EMPTY
9561: LIST
9562: LIST
9563: PUSH
9564: EMPTY
9565: LIST
9566: LIST
9567: LIST
9568: PPUSH
9569: CALL_OW 69
9573: PUSH
9574: FOR_IN
9575: IFFALSE 9629
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
9577: LD_VAR 0 1
9581: PPUSH
9582: CALL_OW 257
9586: PUSH
9587: LD_INT 1
9589: PUSH
9590: LD_INT 2
9592: PUSH
9593: LD_INT 3
9595: PUSH
9596: LD_INT 4
9598: PUSH
9599: EMPTY
9600: LIST
9601: LIST
9602: LIST
9603: LIST
9604: IN
9605: IFFALSE 9627
// SetClass ( un , rand ( 1 , 4 ) ) ;
9607: LD_VAR 0 1
9611: PPUSH
9612: LD_INT 1
9614: PPUSH
9615: LD_INT 4
9617: PPUSH
9618: CALL_OW 12
9622: PPUSH
9623: CALL_OW 336
9627: GO 9574
9629: POP
9630: POP
// end ;
9631: PPOPN 1
9633: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
9634: LD_EXP 34
9638: PUSH
9639: LD_EXP 44
9643: AND
9644: IFFALSE 9723
9646: GO 9648
9648: DISABLE
9649: LD_INT 0
9651: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
9652: LD_ADDR_VAR 0 1
9656: PUSH
9657: LD_INT 22
9659: PUSH
9660: LD_OWVAR 2
9664: PUSH
9665: EMPTY
9666: LIST
9667: LIST
9668: PUSH
9669: LD_INT 21
9671: PUSH
9672: LD_INT 3
9674: PUSH
9675: EMPTY
9676: LIST
9677: LIST
9678: PUSH
9679: EMPTY
9680: LIST
9681: LIST
9682: PPUSH
9683: CALL_OW 69
9687: ST_TO_ADDR
// if not tmp then
9688: LD_VAR 0 1
9692: NOT
9693: IFFALSE 9697
// exit ;
9695: GO 9723
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
9697: LD_VAR 0 1
9701: PUSH
9702: LD_INT 1
9704: PPUSH
9705: LD_VAR 0 1
9709: PPUSH
9710: CALL_OW 12
9714: ARRAY
9715: PPUSH
9716: LD_INT 100
9718: PPUSH
9719: CALL_OW 234
// end ;
9723: PPOPN 1
9725: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
9726: LD_EXP 34
9730: PUSH
9731: LD_EXP 46
9735: AND
9736: IFFALSE 9834
9738: GO 9740
9740: DISABLE
9741: LD_INT 0
9743: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
9744: LD_ADDR_VAR 0 1
9748: PUSH
9749: LD_INT 22
9751: PUSH
9752: LD_OWVAR 2
9756: PUSH
9757: EMPTY
9758: LIST
9759: LIST
9760: PUSH
9761: LD_INT 21
9763: PUSH
9764: LD_INT 1
9766: PUSH
9767: EMPTY
9768: LIST
9769: LIST
9770: PUSH
9771: EMPTY
9772: LIST
9773: LIST
9774: PPUSH
9775: CALL_OW 69
9779: ST_TO_ADDR
// if not tmp then
9780: LD_VAR 0 1
9784: NOT
9785: IFFALSE 9789
// exit ;
9787: GO 9834
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
9789: LD_VAR 0 1
9793: PUSH
9794: LD_INT 1
9796: PPUSH
9797: LD_VAR 0 1
9801: PPUSH
9802: CALL_OW 12
9806: ARRAY
9807: PPUSH
9808: LD_INT 1
9810: PPUSH
9811: LD_INT 4
9813: PPUSH
9814: CALL_OW 12
9818: PPUSH
9819: LD_INT 3000
9821: PPUSH
9822: LD_INT 9000
9824: PPUSH
9825: CALL_OW 12
9829: PPUSH
9830: CALL_OW 492
// end ;
9834: PPOPN 1
9836: END
// every 0 0$1 trigger StreamModeActive and sDepot do
9837: LD_EXP 34
9841: PUSH
9842: LD_EXP 47
9846: AND
9847: IFFALSE 9867
9849: GO 9851
9851: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
9852: LD_INT 1
9854: PPUSH
9855: LD_OWVAR 2
9859: PPUSH
9860: LD_INT 0
9862: PPUSH
9863: CALL_OW 324
9867: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
9868: LD_EXP 34
9872: PUSH
9873: LD_EXP 48
9877: AND
9878: IFFALSE 9961
9880: GO 9882
9882: DISABLE
9883: LD_INT 0
9885: PPUSH
9886: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
9887: LD_ADDR_VAR 0 2
9891: PUSH
9892: LD_INT 22
9894: PUSH
9895: LD_OWVAR 2
9899: PUSH
9900: EMPTY
9901: LIST
9902: LIST
9903: PUSH
9904: LD_INT 21
9906: PUSH
9907: LD_INT 3
9909: PUSH
9910: EMPTY
9911: LIST
9912: LIST
9913: PUSH
9914: EMPTY
9915: LIST
9916: LIST
9917: PPUSH
9918: CALL_OW 69
9922: ST_TO_ADDR
// if not tmp then
9923: LD_VAR 0 2
9927: NOT
9928: IFFALSE 9932
// exit ;
9930: GO 9961
// for i in tmp do
9932: LD_ADDR_VAR 0 1
9936: PUSH
9937: LD_VAR 0 2
9941: PUSH
9942: FOR_IN
9943: IFFALSE 9959
// SetBLevel ( i , 10 ) ;
9945: LD_VAR 0 1
9949: PPUSH
9950: LD_INT 10
9952: PPUSH
9953: CALL_OW 241
9957: GO 9942
9959: POP
9960: POP
// end ;
9961: PPOPN 2
9963: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , tmp ;
9964: LD_EXP 34
9968: PUSH
9969: LD_EXP 49
9973: AND
9974: IFFALSE 10077
9976: GO 9978
9978: DISABLE
9979: LD_INT 0
9981: PPUSH
9982: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
9983: LD_ADDR_VAR 0 2
9987: PUSH
9988: LD_INT 22
9990: PUSH
9991: LD_OWVAR 2
9995: PUSH
9996: EMPTY
9997: LIST
9998: LIST
9999: PUSH
10000: LD_INT 25
10002: PUSH
10003: LD_INT 1
10005: PUSH
10006: EMPTY
10007: LIST
10008: LIST
10009: PUSH
10010: EMPTY
10011: LIST
10012: LIST
10013: PPUSH
10014: CALL_OW 69
10018: ST_TO_ADDR
// if not tmp then
10019: LD_VAR 0 2
10023: NOT
10024: IFFALSE 10028
// exit ;
10026: GO 10077
// for i in tmp do
10028: LD_ADDR_VAR 0 1
10032: PUSH
10033: LD_VAR 0 2
10037: PUSH
10038: FOR_IN
10039: IFFALSE 10075
// begin if Crawls ( i ) then
10041: LD_VAR 0 1
10045: PPUSH
10046: CALL_OW 318
10050: IFFALSE 10061
// ComWalk ( i ) ;
10052: LD_VAR 0 1
10056: PPUSH
10057: CALL_OW 138
// SetClass ( i , 4 ) ;
10061: LD_VAR 0 1
10065: PPUSH
10066: LD_INT 4
10068: PPUSH
10069: CALL_OW 336
// end ;
10073: GO 10038
10075: POP
10076: POP
// end ;
10077: PPOPN 2
10079: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
10080: LD_EXP 34
10084: PUSH
10085: LD_EXP 50
10089: AND
10090: PUSH
10091: LD_OWVAR 67
10095: PUSH
10096: LD_INT 3
10098: LESS
10099: AND
10100: IFFALSE 10119
10102: GO 10104
10104: DISABLE
// Difficulty := Difficulty + 1 ;
10105: LD_ADDR_OWVAR 67
10109: PUSH
10110: LD_OWVAR 67
10114: PUSH
10115: LD_INT 1
10117: PLUS
10118: ST_TO_ADDR
10119: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
10120: LD_EXP 34
10124: PUSH
10125: LD_EXP 51
10129: AND
10130: IFFALSE 10233
10132: GO 10134
10134: DISABLE
10135: LD_INT 0
10137: PPUSH
// begin for i := 1 to 5 do
10138: LD_ADDR_VAR 0 1
10142: PUSH
10143: DOUBLE
10144: LD_INT 1
10146: DEC
10147: ST_TO_ADDR
10148: LD_INT 5
10150: PUSH
10151: FOR_TO
10152: IFFALSE 10231
// begin uc_nation := nation_nature ;
10154: LD_ADDR_OWVAR 21
10158: PUSH
10159: LD_INT 0
10161: ST_TO_ADDR
// uc_side := 0 ;
10162: LD_ADDR_OWVAR 20
10166: PUSH
10167: LD_INT 0
10169: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
10170: LD_ADDR_OWVAR 29
10174: PUSH
10175: LD_INT 12
10177: PUSH
10178: LD_INT 12
10180: PUSH
10181: EMPTY
10182: LIST
10183: LIST
10184: ST_TO_ADDR
// hc_agressivity := 20 ;
10185: LD_ADDR_OWVAR 35
10189: PUSH
10190: LD_INT 20
10192: ST_TO_ADDR
// hc_class := class_tiger ;
10193: LD_ADDR_OWVAR 28
10197: PUSH
10198: LD_INT 14
10200: ST_TO_ADDR
// hc_gallery :=  ;
10201: LD_ADDR_OWVAR 33
10205: PUSH
10206: LD_STRING 
10208: ST_TO_ADDR
// hc_name :=  ;
10209: LD_ADDR_OWVAR 26
10213: PUSH
10214: LD_STRING 
10216: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
10217: CALL_OW 44
10221: PPUSH
10222: LD_INT 0
10224: PPUSH
10225: CALL_OW 51
// end ;
10229: GO 10151
10231: POP
10232: POP
// end ;
10233: PPOPN 1
10235: END
// every 0 0$1 trigger StreamModeActive and sBomb do var i , x , y , result ;
10236: LD_EXP 34
10240: PUSH
10241: LD_EXP 52
10245: AND
10246: IFFALSE 10420
10248: GO 10250
10250: DISABLE
10251: LD_INT 0
10253: PPUSH
10254: PPUSH
10255: PPUSH
10256: PPUSH
// begin result := false ;
10257: LD_ADDR_VAR 0 4
10261: PUSH
10262: LD_INT 0
10264: ST_TO_ADDR
// for i := 1 to 8 do
10265: LD_ADDR_VAR 0 1
10269: PUSH
10270: DOUBLE
10271: LD_INT 1
10273: DEC
10274: ST_TO_ADDR
10275: LD_INT 8
10277: PUSH
10278: FOR_TO
10279: IFFALSE 10390
// begin x := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
10281: LD_ADDR_VAR 0 2
10285: PUSH
10286: LD_INT 10
10288: PUSH
10289: LD_INT 50
10291: PUSH
10292: LD_INT 90
10294: PUSH
10295: LD_INT 140
10297: PUSH
10298: EMPTY
10299: LIST
10300: LIST
10301: LIST
10302: LIST
10303: PUSH
10304: LD_INT 1
10306: PPUSH
10307: LD_INT 4
10309: PPUSH
10310: CALL_OW 12
10314: ARRAY
10315: ST_TO_ADDR
// y := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
10316: LD_ADDR_VAR 0 3
10320: PUSH
10321: LD_INT 10
10323: PUSH
10324: LD_INT 50
10326: PUSH
10327: LD_INT 90
10329: PUSH
10330: LD_INT 140
10332: PUSH
10333: EMPTY
10334: LIST
10335: LIST
10336: LIST
10337: LIST
10338: PUSH
10339: LD_INT 1
10341: PPUSH
10342: LD_INT 4
10344: PPUSH
10345: CALL_OW 12
10349: ARRAY
10350: ST_TO_ADDR
// if ValidHex ( x , y ) then
10351: LD_VAR 0 2
10355: PPUSH
10356: LD_VAR 0 3
10360: PPUSH
10361: CALL_OW 488
10365: IFFALSE 10388
// begin result := [ x , y ] ;
10367: LD_ADDR_VAR 0 4
10371: PUSH
10372: LD_VAR 0 2
10376: PUSH
10377: LD_VAR 0 3
10381: PUSH
10382: EMPTY
10383: LIST
10384: LIST
10385: ST_TO_ADDR
// break ;
10386: GO 10390
// end ; end ;
10388: GO 10278
10390: POP
10391: POP
// if result then
10392: LD_VAR 0 4
10396: IFFALSE 10420
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
10398: LD_VAR 0 4
10402: PUSH
10403: LD_INT 1
10405: ARRAY
10406: PPUSH
10407: LD_VAR 0 4
10411: PUSH
10412: LD_INT 2
10414: ARRAY
10415: PPUSH
10416: CALL_OW 429
// end ;
10420: PPOPN 4
10422: END
// every 0 0$1 trigger StreamModeActive and sReset do
10423: LD_EXP 34
10427: PUSH
10428: LD_EXP 54
10432: AND
10433: IFFALSE 10445
10435: GO 10437
10437: DISABLE
// YouLost (  ) ;
10438: LD_STRING 
10440: PPUSH
10441: CALL_OW 104
10445: END
// every 0 0$1 trigger StreamModeActive and sFog do
10446: LD_EXP 34
10450: PUSH
10451: LD_EXP 53
10455: AND
10456: IFFALSE 10470
10458: GO 10460
10460: DISABLE
// FogOff ( your_side ) ;
10461: LD_OWVAR 2
10465: PPUSH
10466: CALL_OW 344
10470: END
// every 0 0$1 trigger StreamModeActive and sSun do
10471: LD_EXP 34
10475: PUSH
10476: LD_EXP 55
10480: AND
10481: IFFALSE 10509
10483: GO 10485
10485: DISABLE
// begin solar_recharge_percent := 0 ;
10486: LD_ADDR_OWVAR 79
10490: PUSH
10491: LD_INT 0
10493: ST_TO_ADDR
// wait ( 5 5$00 ) ;
10494: LD_INT 10500
10496: PPUSH
10497: CALL_OW 67
// solar_recharge_percent := 100 ;
10501: LD_ADDR_OWVAR 79
10505: PUSH
10506: LD_INT 100
10508: ST_TO_ADDR
// end ;
10509: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un ;
10510: LD_EXP 34
10514: PUSH
10515: LD_EXP 56
10519: AND
10520: IFFALSE 10675
10522: GO 10524
10524: DISABLE
10525: LD_INT 0
10527: PPUSH
10528: PPUSH
// begin for i := 1 to 6 do
10529: LD_ADDR_VAR 0 1
10533: PUSH
10534: DOUBLE
10535: LD_INT 1
10537: DEC
10538: ST_TO_ADDR
10539: LD_INT 6
10541: PUSH
10542: FOR_TO
10543: IFFALSE 10673
// begin uc_nation := nation_nature ;
10545: LD_ADDR_OWVAR 21
10549: PUSH
10550: LD_INT 0
10552: ST_TO_ADDR
// uc_side := 0 ;
10553: LD_ADDR_OWVAR 20
10557: PUSH
10558: LD_INT 0
10560: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
10561: LD_ADDR_OWVAR 29
10565: PUSH
10566: LD_INT 12
10568: PUSH
10569: LD_INT 12
10571: PUSH
10572: EMPTY
10573: LIST
10574: LIST
10575: ST_TO_ADDR
// hc_agressivity := 20 ;
10576: LD_ADDR_OWVAR 35
10580: PUSH
10581: LD_INT 20
10583: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
10584: LD_ADDR_OWVAR 28
10588: PUSH
10589: LD_INT 17
10591: ST_TO_ADDR
// hc_gallery :=  ;
10592: LD_ADDR_OWVAR 33
10596: PUSH
10597: LD_STRING 
10599: ST_TO_ADDR
// hc_name :=  ;
10600: LD_ADDR_OWVAR 26
10604: PUSH
10605: LD_STRING 
10607: ST_TO_ADDR
// un := CreateHuman ;
10608: LD_ADDR_VAR 0 2
10612: PUSH
10613: CALL_OW 44
10617: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
10618: LD_VAR 0 2
10622: PPUSH
10623: LD_INT 1
10625: PPUSH
10626: CALL_OW 51
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
10630: LD_VAR 0 2
10634: PPUSH
10635: LD_INT 3
10637: PUSH
10638: LD_INT 22
10640: PUSH
10641: LD_INT 0
10643: PUSH
10644: EMPTY
10645: LIST
10646: LIST
10647: PUSH
10648: EMPTY
10649: LIST
10650: LIST
10651: PPUSH
10652: CALL_OW 69
10656: PPUSH
10657: LD_VAR 0 2
10661: PPUSH
10662: CALL_OW 74
10666: PPUSH
10667: CALL_OW 115
// end ;
10671: GO 10542
10673: POP
10674: POP
// end ;
10675: PPOPN 2
10677: END
// every 0 0$1 trigger StreamModeActive and sTroll do
10678: LD_EXP 34
10682: PUSH
10683: LD_EXP 57
10687: AND
10688: IFFALSE 10714
10690: GO 10692
10692: DISABLE
// begin ToLua ( displayTroll(); ) ;
10693: LD_STRING displayTroll();
10695: PPUSH
10696: CALL_OW 559
// wait ( 3 3$00 ) ;
10700: LD_INT 6300
10702: PPUSH
10703: CALL_OW 67
// ToLua ( hideTroll(); ) ;
10707: LD_STRING hideTroll();
10709: PPUSH
10710: CALL_OW 559
// end ;
10714: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
10715: LD_EXP 34
10719: PUSH
10720: LD_EXP 58
10724: AND
10725: IFFALSE 10788
10727: GO 10729
10729: DISABLE
10730: LD_INT 0
10732: PPUSH
// begin p := 0 ;
10733: LD_ADDR_VAR 0 1
10737: PUSH
10738: LD_INT 0
10740: ST_TO_ADDR
// repeat game_speed := 1 ;
10741: LD_ADDR_OWVAR 65
10745: PUSH
10746: LD_INT 1
10748: ST_TO_ADDR
// wait ( 0 0$1 ) ;
10749: LD_INT 35
10751: PPUSH
10752: CALL_OW 67
// p := p + 1 ;
10756: LD_ADDR_VAR 0 1
10760: PUSH
10761: LD_VAR 0 1
10765: PUSH
10766: LD_INT 1
10768: PLUS
10769: ST_TO_ADDR
// until p >= 60 ;
10770: LD_VAR 0 1
10774: PUSH
10775: LD_INT 60
10777: GREATEREQUAL
10778: IFFALSE 10741
// game_speed := 4 ;
10780: LD_ADDR_OWVAR 65
10784: PUSH
10785: LD_INT 4
10787: ST_TO_ADDR
// end ;
10788: PPOPN 1
10790: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
10791: LD_EXP 34
10795: PUSH
10796: LD_EXP 59
10800: AND
10801: IFFALSE 10947
10803: GO 10805
10805: DISABLE
10806: LD_INT 0
10808: PPUSH
10809: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
10810: LD_ADDR_VAR 0 1
10814: PUSH
10815: LD_INT 22
10817: PUSH
10818: LD_OWVAR 2
10822: PUSH
10823: EMPTY
10824: LIST
10825: LIST
10826: PUSH
10827: LD_INT 2
10829: PUSH
10830: LD_INT 30
10832: PUSH
10833: LD_INT 0
10835: PUSH
10836: EMPTY
10837: LIST
10838: LIST
10839: PUSH
10840: LD_INT 30
10842: PUSH
10843: LD_INT 1
10845: PUSH
10846: EMPTY
10847: LIST
10848: LIST
10849: PUSH
10850: EMPTY
10851: LIST
10852: LIST
10853: LIST
10854: PUSH
10855: EMPTY
10856: LIST
10857: LIST
10858: PPUSH
10859: CALL_OW 69
10863: ST_TO_ADDR
// if not depot then
10864: LD_VAR 0 1
10868: NOT
10869: IFFALSE 10873
// exit ;
10871: GO 10947
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
10873: LD_ADDR_VAR 0 2
10877: PUSH
10878: LD_VAR 0 1
10882: PUSH
10883: LD_INT 1
10885: PPUSH
10886: LD_VAR 0 1
10890: PPUSH
10891: CALL_OW 12
10895: ARRAY
10896: PPUSH
10897: CALL_OW 274
10901: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
10902: LD_VAR 0 2
10906: PPUSH
10907: LD_INT 1
10909: PPUSH
10910: LD_INT 0
10912: PPUSH
10913: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
10917: LD_VAR 0 2
10921: PPUSH
10922: LD_INT 2
10924: PPUSH
10925: LD_INT 0
10927: PPUSH
10928: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
10932: LD_VAR 0 2
10936: PPUSH
10937: LD_INT 3
10939: PPUSH
10940: LD_INT 0
10942: PPUSH
10943: CALL_OW 277
// end ;
10947: PPOPN 2
10949: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
10950: LD_EXP 34
10954: PUSH
10955: LD_EXP 60
10959: AND
10960: IFFALSE 11057
10962: GO 10964
10964: DISABLE
10965: LD_INT 0
10967: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
10968: LD_ADDR_VAR 0 1
10972: PUSH
10973: LD_INT 22
10975: PUSH
10976: LD_OWVAR 2
10980: PUSH
10981: EMPTY
10982: LIST
10983: LIST
10984: PUSH
10985: LD_INT 21
10987: PUSH
10988: LD_INT 1
10990: PUSH
10991: EMPTY
10992: LIST
10993: LIST
10994: PUSH
10995: LD_INT 3
10997: PUSH
10998: LD_INT 23
11000: PUSH
11001: LD_INT 0
11003: PUSH
11004: EMPTY
11005: LIST
11006: LIST
11007: PUSH
11008: EMPTY
11009: LIST
11010: LIST
11011: PUSH
11012: EMPTY
11013: LIST
11014: LIST
11015: LIST
11016: PPUSH
11017: CALL_OW 69
11021: ST_TO_ADDR
// if not tmp then
11022: LD_VAR 0 1
11026: NOT
11027: IFFALSE 11031
// exit ;
11029: GO 11057
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
11031: LD_VAR 0 1
11035: PUSH
11036: LD_INT 1
11038: PPUSH
11039: LD_VAR 0 1
11043: PPUSH
11044: CALL_OW 12
11048: ARRAY
11049: PPUSH
11050: LD_INT 200
11052: PPUSH
11053: CALL_OW 234
// end ;
11057: PPOPN 1
11059: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
11060: LD_EXP 34
11064: PUSH
11065: LD_EXP 61
11069: AND
11070: IFFALSE 11149
11072: GO 11074
11074: DISABLE
11075: LD_INT 0
11077: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
11078: LD_ADDR_VAR 0 1
11082: PUSH
11083: LD_INT 22
11085: PUSH
11086: LD_OWVAR 2
11090: PUSH
11091: EMPTY
11092: LIST
11093: LIST
11094: PUSH
11095: LD_INT 21
11097: PUSH
11098: LD_INT 2
11100: PUSH
11101: EMPTY
11102: LIST
11103: LIST
11104: PUSH
11105: EMPTY
11106: LIST
11107: LIST
11108: PPUSH
11109: CALL_OW 69
11113: ST_TO_ADDR
// if not tmp then
11114: LD_VAR 0 1
11118: NOT
11119: IFFALSE 11123
// exit ;
11121: GO 11149
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 10 ) ;
11123: LD_VAR 0 1
11127: PUSH
11128: LD_INT 1
11130: PPUSH
11131: LD_VAR 0 1
11135: PPUSH
11136: CALL_OW 12
11140: ARRAY
11141: PPUSH
11142: LD_INT 10
11144: PPUSH
11145: CALL_OW 234
// end ;
11149: PPOPN 1
11151: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
11152: LD_EXP 34
11156: PUSH
11157: LD_EXP 62
11161: AND
11162: IFFALSE 11261
11164: GO 11166
11166: DISABLE
11167: LD_INT 0
11169: PPUSH
11170: PPUSH
// begin enable ;
11171: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
11172: LD_ADDR_VAR 0 1
11176: PUSH
11177: LD_INT 22
11179: PUSH
11180: LD_OWVAR 2
11184: PUSH
11185: EMPTY
11186: LIST
11187: LIST
11188: PUSH
11189: LD_INT 61
11191: PUSH
11192: EMPTY
11193: LIST
11194: PUSH
11195: LD_INT 33
11197: PUSH
11198: LD_INT 2
11200: PUSH
11201: EMPTY
11202: LIST
11203: LIST
11204: PUSH
11205: EMPTY
11206: LIST
11207: LIST
11208: LIST
11209: PPUSH
11210: CALL_OW 69
11214: ST_TO_ADDR
// if not tmp then
11215: LD_VAR 0 1
11219: NOT
11220: IFFALSE 11224
// exit ;
11222: GO 11261
// for i in tmp do
11224: LD_ADDR_VAR 0 2
11228: PUSH
11229: LD_VAR 0 1
11233: PUSH
11234: FOR_IN
11235: IFFALSE 11259
// if IsControledBy ( i ) then
11237: LD_VAR 0 2
11241: PPUSH
11242: CALL_OW 312
11246: IFFALSE 11257
// ComUnlink ( i ) ;
11248: LD_VAR 0 2
11252: PPUSH
11253: CALL_OW 136
11257: GO 11234
11259: POP
11260: POP
// end ; end_of_file
11261: PPOPN 2
11263: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
11264: LD_INT 0
11266: PPUSH
11267: PPUSH
11268: PPUSH
11269: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
11270: LD_VAR 0 1
11274: PPUSH
11275: CALL_OW 264
11279: PUSH
11280: LD_EXP 33
11284: EQUAL
11285: IFFALSE 11357
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
11287: LD_INT 68
11289: PPUSH
11290: LD_VAR 0 1
11294: PPUSH
11295: CALL_OW 255
11299: PPUSH
11300: CALL_OW 321
11304: PUSH
11305: LD_INT 2
11307: EQUAL
11308: IFFALSE 11320
// eff := 70 else
11310: LD_ADDR_VAR 0 6
11314: PUSH
11315: LD_INT 70
11317: ST_TO_ADDR
11318: GO 11328
// eff := 30 ;
11320: LD_ADDR_VAR 0 6
11324: PUSH
11325: LD_INT 30
11327: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
11328: LD_VAR 0 1
11332: PPUSH
11333: CALL_OW 250
11337: PPUSH
11338: LD_VAR 0 1
11342: PPUSH
11343: CALL_OW 251
11347: PPUSH
11348: LD_VAR 0 6
11352: PPUSH
11353: CALL_OW 495
// end ; end ;
11357: LD_VAR 0 4
11361: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
11362: LD_INT 0
11364: PPUSH
11365: PPUSH
11366: PPUSH
11367: PPUSH
11368: PPUSH
11369: PPUSH
// if cmd = 124 then
11370: LD_VAR 0 1
11374: PUSH
11375: LD_INT 124
11377: EQUAL
11378: IFFALSE 11584
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
11380: LD_ADDR_VAR 0 5
11384: PUSH
11385: LD_INT 2
11387: PUSH
11388: LD_INT 34
11390: PUSH
11391: LD_INT 53
11393: PUSH
11394: EMPTY
11395: LIST
11396: LIST
11397: PUSH
11398: LD_INT 34
11400: PUSH
11401: LD_INT 14
11403: PUSH
11404: EMPTY
11405: LIST
11406: LIST
11407: PUSH
11408: EMPTY
11409: LIST
11410: LIST
11411: LIST
11412: PPUSH
11413: CALL_OW 69
11417: ST_TO_ADDR
// if not tmp then
11418: LD_VAR 0 5
11422: NOT
11423: IFFALSE 11427
// exit ;
11425: GO 11584
// for i in tmp do
11427: LD_ADDR_VAR 0 3
11431: PUSH
11432: LD_VAR 0 5
11436: PUSH
11437: FOR_IN
11438: IFFALSE 11582
// begin taskList := GetTaskList ( i ) ;
11440: LD_ADDR_VAR 0 6
11444: PUSH
11445: LD_VAR 0 3
11449: PPUSH
11450: CALL_OW 437
11454: ST_TO_ADDR
// if not taskList then
11455: LD_VAR 0 6
11459: NOT
11460: IFFALSE 11464
// continue ;
11462: GO 11437
// for j = 1 to taskList do
11464: LD_ADDR_VAR 0 4
11468: PUSH
11469: DOUBLE
11470: LD_INT 1
11472: DEC
11473: ST_TO_ADDR
11474: LD_VAR 0 6
11478: PUSH
11479: FOR_TO
11480: IFFALSE 11578
// if taskList [ j ] [ 1 ] = | then
11482: LD_VAR 0 6
11486: PUSH
11487: LD_VAR 0 4
11491: ARRAY
11492: PUSH
11493: LD_INT 1
11495: ARRAY
11496: PUSH
11497: LD_STRING |
11499: EQUAL
11500: IFFALSE 11576
// begin _taskList := Delete ( taskList , 1 ) ;
11502: LD_ADDR_VAR 0 7
11506: PUSH
11507: LD_VAR 0 6
11511: PPUSH
11512: LD_INT 1
11514: PPUSH
11515: CALL_OW 3
11519: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
11520: LD_VAR 0 3
11524: PPUSH
11525: LD_VAR 0 7
11529: PPUSH
11530: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
11534: LD_VAR 0 3
11538: PPUSH
11539: LD_VAR 0 6
11543: PUSH
11544: LD_VAR 0 4
11548: ARRAY
11549: PUSH
11550: LD_INT 2
11552: ARRAY
11553: PPUSH
11554: LD_VAR 0 6
11558: PUSH
11559: LD_VAR 0 4
11563: ARRAY
11564: PUSH
11565: LD_INT 3
11567: ARRAY
11568: PPUSH
11569: LD_INT 8
11571: PPUSH
11572: CALL 11589 0 4
// end ;
11576: GO 11479
11578: POP
11579: POP
// end ;
11580: GO 11437
11582: POP
11583: POP
// end ; end ;
11584: LD_VAR 0 2
11588: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
11589: LD_INT 0
11591: PPUSH
11592: PPUSH
11593: PPUSH
11594: PPUSH
11595: PPUSH
11596: PPUSH
11597: PPUSH
11598: PPUSH
11599: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
11600: LD_VAR 0 1
11604: NOT
11605: PUSH
11606: LD_VAR 0 2
11610: PPUSH
11611: LD_VAR 0 3
11615: PPUSH
11616: CALL_OW 488
11620: NOT
11621: OR
11622: PUSH
11623: LD_VAR 0 4
11627: NOT
11628: OR
11629: IFFALSE 11633
// exit ;
11631: GO 11973
// list := [ ] ;
11633: LD_ADDR_VAR 0 13
11637: PUSH
11638: EMPTY
11639: ST_TO_ADDR
// if x - r < 0 then
11640: LD_VAR 0 2
11644: PUSH
11645: LD_VAR 0 4
11649: MINUS
11650: PUSH
11651: LD_INT 0
11653: LESS
11654: IFFALSE 11666
// min_x := 0 else
11656: LD_ADDR_VAR 0 7
11660: PUSH
11661: LD_INT 0
11663: ST_TO_ADDR
11664: GO 11682
// min_x := x - r ;
11666: LD_ADDR_VAR 0 7
11670: PUSH
11671: LD_VAR 0 2
11675: PUSH
11676: LD_VAR 0 4
11680: MINUS
11681: ST_TO_ADDR
// if y - r < 0 then
11682: LD_VAR 0 3
11686: PUSH
11687: LD_VAR 0 4
11691: MINUS
11692: PUSH
11693: LD_INT 0
11695: LESS
11696: IFFALSE 11708
// min_y := 0 else
11698: LD_ADDR_VAR 0 8
11702: PUSH
11703: LD_INT 0
11705: ST_TO_ADDR
11706: GO 11724
// min_y := y - r ;
11708: LD_ADDR_VAR 0 8
11712: PUSH
11713: LD_VAR 0 3
11717: PUSH
11718: LD_VAR 0 4
11722: MINUS
11723: ST_TO_ADDR
// max_x := x + r ;
11724: LD_ADDR_VAR 0 9
11728: PUSH
11729: LD_VAR 0 2
11733: PUSH
11734: LD_VAR 0 4
11738: PLUS
11739: ST_TO_ADDR
// max_y := y + r ;
11740: LD_ADDR_VAR 0 10
11744: PUSH
11745: LD_VAR 0 3
11749: PUSH
11750: LD_VAR 0 4
11754: PLUS
11755: ST_TO_ADDR
// for _x = min_x to max_x do
11756: LD_ADDR_VAR 0 11
11760: PUSH
11761: DOUBLE
11762: LD_VAR 0 7
11766: DEC
11767: ST_TO_ADDR
11768: LD_VAR 0 9
11772: PUSH
11773: FOR_TO
11774: IFFALSE 11891
// for _y = min_y to max_y do
11776: LD_ADDR_VAR 0 12
11780: PUSH
11781: DOUBLE
11782: LD_VAR 0 8
11786: DEC
11787: ST_TO_ADDR
11788: LD_VAR 0 10
11792: PUSH
11793: FOR_TO
11794: IFFALSE 11887
// begin if not ValidHex ( _x , _y ) then
11796: LD_VAR 0 11
11800: PPUSH
11801: LD_VAR 0 12
11805: PPUSH
11806: CALL_OW 488
11810: NOT
11811: IFFALSE 11815
// continue ;
11813: GO 11793
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
11815: LD_VAR 0 11
11819: PPUSH
11820: LD_VAR 0 12
11824: PPUSH
11825: CALL_OW 351
11829: PUSH
11830: LD_VAR 0 11
11834: PPUSH
11835: LD_VAR 0 12
11839: PPUSH
11840: CALL_OW 554
11844: AND
11845: IFFALSE 11885
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
11847: LD_ADDR_VAR 0 13
11851: PUSH
11852: LD_VAR 0 13
11856: PPUSH
11857: LD_VAR 0 13
11861: PUSH
11862: LD_INT 1
11864: PLUS
11865: PPUSH
11866: LD_VAR 0 11
11870: PUSH
11871: LD_VAR 0 12
11875: PUSH
11876: EMPTY
11877: LIST
11878: LIST
11879: PPUSH
11880: CALL_OW 2
11884: ST_TO_ADDR
// end ;
11885: GO 11793
11887: POP
11888: POP
11889: GO 11773
11891: POP
11892: POP
// if not list then
11893: LD_VAR 0 13
11897: NOT
11898: IFFALSE 11902
// exit ;
11900: GO 11973
// for i in list do
11902: LD_ADDR_VAR 0 6
11906: PUSH
11907: LD_VAR 0 13
11911: PUSH
11912: FOR_IN
11913: IFFALSE 11971
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
11915: LD_VAR 0 1
11919: PPUSH
11920: LD_STRING M
11922: PUSH
11923: LD_VAR 0 6
11927: PUSH
11928: LD_INT 1
11930: ARRAY
11931: PUSH
11932: LD_VAR 0 6
11936: PUSH
11937: LD_INT 2
11939: ARRAY
11940: PUSH
11941: LD_INT 0
11943: PUSH
11944: LD_INT 0
11946: PUSH
11947: LD_INT 0
11949: PUSH
11950: LD_INT 0
11952: PUSH
11953: EMPTY
11954: LIST
11955: LIST
11956: LIST
11957: LIST
11958: LIST
11959: LIST
11960: LIST
11961: PUSH
11962: EMPTY
11963: LIST
11964: PPUSH
11965: CALL_OW 447
11969: GO 11912
11971: POP
11972: POP
// end ;
11973: LD_VAR 0 5
11977: RET
