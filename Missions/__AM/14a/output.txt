// starting begin ResetFog ;
   0: CALL_OW 335
// FogOff ( 7 ) ;
   4: LD_INT 7
   6: PPUSH
   7: CALL_OW 344
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 59 0 0
// LoadBuildings ;
  19: CALL 75 0 0
// PrepareAlliance ;
  23: CALL 592 0 0
// music_nat := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
  27: LD_ADDR_OWVAR 71
  31: PUSH
  32: LD_INT 1
  34: PUSH
  35: LD_INT 3
  37: PUSH
  38: EMPTY
  39: LIST
  40: LIST
  41: PUSH
  42: LD_INT 1
  44: PPUSH
  45: LD_INT 2
  47: PPUSH
  48: CALL_OW 12
  52: ARRAY
  53: ST_TO_ADDR
// Action ;
  54: CALL 3341 0 0
// end ;
  58: END
// export debug ; export function InitVariables ; begin
  59: LD_INT 0
  61: PPUSH
// debug := false ;
  62: LD_ADDR_EXP 1
  66: PUSH
  67: LD_INT 0
  69: ST_TO_ADDR
// end ; end_of_file
  70: LD_VAR 0 1
  74: RET
// export function LoadBuildings ; var i , tmp , b ; begin
  75: LD_INT 0
  77: PPUSH
  78: PPUSH
  79: PPUSH
  80: PPUSH
// tmp := LoadVariable ( 13a_buildings , [ [ 7 , 1 , b_warehouse , 70 , 46 , 3 , 10 , 0 , 0 , 0 ] ] ) ;
  81: LD_ADDR_VAR 0 3
  85: PUSH
  86: LD_STRING 13a_buildings
  88: PPUSH
  89: LD_INT 7
  91: PUSH
  92: LD_INT 1
  94: PUSH
  95: LD_INT 1
  97: PUSH
  98: LD_INT 70
 100: PUSH
 101: LD_INT 46
 103: PUSH
 104: LD_INT 3
 106: PUSH
 107: LD_INT 10
 109: PUSH
 110: LD_INT 0
 112: PUSH
 113: LD_INT 0
 115: PUSH
 116: LD_INT 0
 118: PUSH
 119: EMPTY
 120: LIST
 121: LIST
 122: LIST
 123: LIST
 124: LIST
 125: LIST
 126: LIST
 127: LIST
 128: LIST
 129: LIST
 130: PUSH
 131: EMPTY
 132: LIST
 133: PPUSH
 134: CALL_OW 30
 138: ST_TO_ADDR
// bc_kind1 := - 1 ;
 139: LD_ADDR_OWVAR 44
 143: PUSH
 144: LD_INT 1
 146: NEG
 147: ST_TO_ADDR
// bc_kind2 := - 1 ;
 148: LD_ADDR_OWVAR 45
 152: PUSH
 153: LD_INT 1
 155: NEG
 156: ST_TO_ADDR
// for i in tmp do
 157: LD_ADDR_VAR 0 2
 161: PUSH
 162: LD_VAR 0 3
 166: PUSH
 167: FOR_IN
 168: IFFALSE 413
// begin uc_side := 7 ;
 170: LD_ADDR_OWVAR 20
 174: PUSH
 175: LD_INT 7
 177: ST_TO_ADDR
// uc_nation := i [ 2 ] ;
 178: LD_ADDR_OWVAR 21
 182: PUSH
 183: LD_VAR 0 2
 187: PUSH
 188: LD_INT 2
 190: ARRAY
 191: ST_TO_ADDR
// if i [ 2 ] = 2 then
 192: LD_VAR 0 2
 196: PUSH
 197: LD_INT 2
 199: ARRAY
 200: PUSH
 201: LD_INT 2
 203: EQUAL
 204: IFFALSE 214
// uc_side := 4 ;
 206: LD_ADDR_OWVAR 20
 210: PUSH
 211: LD_INT 4
 213: ST_TO_ADDR
// bc_type := i [ 3 ] ;
 214: LD_ADDR_OWVAR 42
 218: PUSH
 219: LD_VAR 0 2
 223: PUSH
 224: LD_INT 3
 226: ARRAY
 227: ST_TO_ADDR
// if i [ 3 ] in [ b_oil_mine , b_siberite_mine ] then
 228: LD_VAR 0 2
 232: PUSH
 233: LD_INT 3
 235: ARRAY
 236: PUSH
 237: LD_INT 29
 239: PUSH
 240: LD_INT 30
 242: PUSH
 243: EMPTY
 244: LIST
 245: LIST
 246: IN
 247: IFFALSE 280
// SetResourceVisibility ( i [ 4 ] , i [ 5 ] , i [ 1 ] ) ;
 249: LD_VAR 0 2
 253: PUSH
 254: LD_INT 4
 256: ARRAY
 257: PPUSH
 258: LD_VAR 0 2
 262: PUSH
 263: LD_INT 5
 265: ARRAY
 266: PPUSH
 267: LD_VAR 0 2
 271: PUSH
 272: LD_INT 1
 274: ARRAY
 275: PPUSH
 276: CALL_OW 441
// if i [ 8 ] then
 280: LD_VAR 0 2
 284: PUSH
 285: LD_INT 8
 287: ARRAY
 288: IFFALSE 304
// bc_kind1 := i [ 8 ] ;
 290: LD_ADDR_OWVAR 44
 294: PUSH
 295: LD_VAR 0 2
 299: PUSH
 300: LD_INT 8
 302: ARRAY
 303: ST_TO_ADDR
// if i [ 9 ] then
 304: LD_VAR 0 2
 308: PUSH
 309: LD_INT 9
 311: ARRAY
 312: IFFALSE 328
// bc_kind2 := i [ 9 ] ;
 314: LD_ADDR_OWVAR 45
 318: PUSH
 319: LD_VAR 0 2
 323: PUSH
 324: LD_INT 9
 326: ARRAY
 327: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( i [ 4 ] , i [ 5 ] , i [ 6 ] ) ;
 328: LD_ADDR_VAR 0 4
 332: PUSH
 333: LD_VAR 0 2
 337: PUSH
 338: LD_INT 4
 340: ARRAY
 341: PPUSH
 342: LD_VAR 0 2
 346: PUSH
 347: LD_INT 5
 349: ARRAY
 350: PPUSH
 351: LD_VAR 0 2
 355: PUSH
 356: LD_INT 6
 358: ARRAY
 359: PPUSH
 360: CALL_OW 47
 364: ST_TO_ADDR
// SetBLevel ( b , i [ 7 ] ) ;
 365: LD_VAR 0 4
 369: PPUSH
 370: LD_VAR 0 2
 374: PUSH
 375: LD_INT 7
 377: ARRAY
 378: PPUSH
 379: CALL_OW 241
// if i [ 10 ] then
 383: LD_VAR 0 2
 387: PUSH
 388: LD_INT 10
 390: ARRAY
 391: IFFALSE 411
// PlaceWeaponTurret ( b , i [ 10 ] ) ;
 393: LD_VAR 0 4
 397: PPUSH
 398: LD_VAR 0 2
 402: PUSH
 403: LD_INT 10
 405: ARRAY
 406: PPUSH
 407: CALL_OW 431
// end ;
 411: GO 167
 413: POP
 414: POP
// if HexInfo ( 144 , 65 ) = 0 then
 415: LD_INT 144
 417: PPUSH
 418: LD_INT 65
 420: PPUSH
 421: CALL_OW 428
 425: PUSH
 426: LD_INT 0
 428: EQUAL
 429: IFFALSE 466
// begin uc_side := 4 ;
 431: LD_ADDR_OWVAR 20
 435: PUSH
 436: LD_INT 4
 438: ST_TO_ADDR
// bc_type := b_warehouse ;
 439: LD_ADDR_OWVAR 42
 443: PUSH
 444: LD_INT 1
 446: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 144 , 65 , 1 ) ;
 447: LD_ADDR_VAR 0 4
 451: PUSH
 452: LD_INT 144
 454: PPUSH
 455: LD_INT 65
 457: PPUSH
 458: LD_INT 1
 460: PPUSH
 461: CALL_OW 47
 465: ST_TO_ADDR
// end ; end ;
 466: LD_VAR 0 1
 470: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 471: LD_INT 0
 473: PPUSH
 474: PPUSH
// if exist_mode then
 475: LD_VAR 0 2
 479: IFFALSE 504
// unit := CreateCharacter ( prefix & ident ) else
 481: LD_ADDR_VAR 0 5
 485: PUSH
 486: LD_VAR 0 3
 490: PUSH
 491: LD_VAR 0 1
 495: STR
 496: PPUSH
 497: CALL_OW 34
 501: ST_TO_ADDR
 502: GO 519
// unit := NewCharacter ( ident ) ;
 504: LD_ADDR_VAR 0 5
 508: PUSH
 509: LD_VAR 0 1
 513: PPUSH
 514: CALL_OW 25
 518: ST_TO_ADDR
// result := unit ;
 519: LD_ADDR_VAR 0 4
 523: PUSH
 524: LD_VAR 0 5
 528: ST_TO_ADDR
// end ;
 529: LD_VAR 0 4
 533: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
 534: LD_INT 0
 536: PPUSH
// vc_chassis := chassis ;
 537: LD_ADDR_OWVAR 37
 541: PUSH
 542: LD_VAR 0 1
 546: ST_TO_ADDR
// vc_engine := engine ;
 547: LD_ADDR_OWVAR 39
 551: PUSH
 552: LD_VAR 0 2
 556: ST_TO_ADDR
// vc_control := control ;
 557: LD_ADDR_OWVAR 38
 561: PUSH
 562: LD_VAR 0 3
 566: ST_TO_ADDR
// vc_weapon := weapon ;
 567: LD_ADDR_OWVAR 40
 571: PUSH
 572: LD_VAR 0 4
 576: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 577: LD_ADDR_OWVAR 41
 581: PUSH
 582: LD_VAR 0 5
 586: ST_TO_ADDR
// end ; end_of_file
 587: LD_VAR 0 6
 591: RET
// export JMM , Burlak , freedom ; export Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Belkov , Gnyevko , Masha ; export squad1 , squad2 ; export function PrepareAlliance ; var tmp , i , veh ; begin
 592: LD_INT 0
 594: PPUSH
 595: PPUSH
 596: PPUSH
 597: PPUSH
// uc_side := 7 ;
 598: LD_ADDR_OWVAR 20
 602: PUSH
 603: LD_INT 7
 605: ST_TO_ADDR
// uc_nation := 1 ;
 606: LD_ADDR_OWVAR 21
 610: PUSH
 611: LD_INT 1
 613: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 13a_ ) ;
 614: LD_ADDR_EXP 2
 618: PUSH
 619: LD_STRING JMM
 621: PPUSH
 622: LD_EXP 1
 626: NOT
 627: PPUSH
 628: LD_STRING 13a_
 630: PPUSH
 631: CALL 471 0 3
 635: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 13a_ ) ;
 636: LD_ADDR_EXP 3
 640: PUSH
 641: LD_STRING Burlak
 643: PPUSH
 644: LD_EXP 1
 648: NOT
 649: PPUSH
 650: LD_STRING 13a_
 652: PPUSH
 653: CALL 471 0 3
 657: ST_TO_ADDR
// freedom := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_nation , 1 ] , [ f_nation , 3 ] ] , [ f_btype , b_warehouse ] ] ) ;
 658: LD_ADDR_EXP 4
 662: PUSH
 663: LD_INT 22
 665: PUSH
 666: LD_INT 7
 668: PUSH
 669: EMPTY
 670: LIST
 671: LIST
 672: PUSH
 673: LD_INT 2
 675: PUSH
 676: LD_INT 23
 678: PUSH
 679: LD_INT 1
 681: PUSH
 682: EMPTY
 683: LIST
 684: LIST
 685: PUSH
 686: LD_INT 23
 688: PUSH
 689: LD_INT 3
 691: PUSH
 692: EMPTY
 693: LIST
 694: LIST
 695: PUSH
 696: EMPTY
 697: LIST
 698: LIST
 699: LIST
 700: PUSH
 701: LD_INT 30
 703: PUSH
 704: LD_INT 1
 706: PUSH
 707: EMPTY
 708: LIST
 709: LIST
 710: PUSH
 711: EMPTY
 712: LIST
 713: LIST
 714: LIST
 715: PPUSH
 716: CALL_OW 69
 720: ST_TO_ADDR
// if freedom then
 721: LD_EXP 4
 725: IFFALSE 852
// begin freedom := freedom [ 1 ] ;
 727: LD_ADDR_EXP 4
 731: PUSH
 732: LD_EXP 4
 736: PUSH
 737: LD_INT 1
 739: ARRAY
 740: ST_TO_ADDR
// SetBName ( freedom , freedom ) ;
 741: LD_EXP 4
 745: PPUSH
 746: LD_STRING freedom
 748: PPUSH
 749: CALL_OW 500
// CenterNowOnUnits ( freedom ) ;
 753: LD_EXP 4
 757: PPUSH
 758: CALL_OW 87
// PlaceHumanInUnit ( JMM , freedom ) ;
 762: LD_EXP 2
 766: PPUSH
 767: LD_EXP 4
 771: PPUSH
 772: CALL_OW 52
// PlaceHumanInUnit ( Burlak , freedom ) ;
 776: LD_EXP 3
 780: PPUSH
 781: LD_EXP 4
 785: PPUSH
 786: CALL_OW 52
// SetResourceType ( GetBase ( freedom ) , mat_cans , 1000 ) ;
 790: LD_EXP 4
 794: PPUSH
 795: CALL_OW 274
 799: PPUSH
 800: LD_INT 1
 802: PPUSH
 803: LD_INT 1000
 805: PPUSH
 806: CALL_OW 277
// SetResourceType ( GetBase ( freedom ) , mat_oil , 400 ) ;
 810: LD_EXP 4
 814: PPUSH
 815: CALL_OW 274
 819: PPUSH
 820: LD_INT 2
 822: PPUSH
 823: LD_INT 400
 825: PPUSH
 826: CALL_OW 277
// SetResourceType ( GetBase ( freedom ) , mat_siberit , 30 ) ;
 830: LD_EXP 4
 834: PPUSH
 835: CALL_OW 274
 839: PPUSH
 840: LD_INT 3
 842: PPUSH
 843: LD_INT 30
 845: PPUSH
 846: CALL_OW 277
// end else
 850: GO 939
// begin PlaceUnitArea ( JMM , freedom_base , false ) ;
 852: LD_EXP 2
 856: PPUSH
 857: LD_INT 1
 859: PPUSH
 860: LD_INT 0
 862: PPUSH
 863: CALL_OW 49
// PlaceUnitXYR ( Burlak , GetX ( JMM ) , GetY ( JMM ) , 8 , false ) ;
 867: LD_EXP 3
 871: PPUSH
 872: LD_EXP 2
 876: PPUSH
 877: CALL_OW 250
 881: PPUSH
 882: LD_EXP 2
 886: PPUSH
 887: CALL_OW 251
 891: PPUSH
 892: LD_INT 8
 894: PPUSH
 895: LD_INT 0
 897: PPUSH
 898: CALL_OW 50
// ComTurnUnit ( JMM , Burlak ) ;
 902: LD_EXP 2
 906: PPUSH
 907: LD_EXP 3
 911: PPUSH
 912: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
 916: LD_EXP 3
 920: PPUSH
 921: LD_EXP 2
 925: PPUSH
 926: CALL_OW 119
// CenterNowOnUnits ( JMM ) ;
 930: LD_EXP 2
 934: PPUSH
 935: CALL_OW 87
// end ; SetClass ( JMM , 2 ) ;
 939: LD_EXP 2
 943: PPUSH
 944: LD_INT 2
 946: PPUSH
 947: CALL_OW 336
// tmp := [ [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] , [ us_double_gun , us_laser , us_rocket_launcher , us_gatling_gun , us_cargo_bay ] ] ;
 951: LD_ADDR_VAR 0 2
 955: PUSH
 956: LD_INT 2
 958: PUSH
 959: LD_INT 3
 961: PUSH
 962: LD_INT 4
 964: PUSH
 965: LD_INT 5
 967: PUSH
 968: EMPTY
 969: LIST
 970: LIST
 971: LIST
 972: LIST
 973: PUSH
 974: LD_INT 5
 976: PUSH
 977: LD_INT 9
 979: PUSH
 980: LD_INT 7
 982: PUSH
 983: LD_INT 4
 985: PUSH
 986: LD_INT 12
 988: PUSH
 989: EMPTY
 990: LIST
 991: LIST
 992: LIST
 993: LIST
 994: LIST
 995: PUSH
 996: EMPTY
 997: LIST
 998: LIST
 999: ST_TO_ADDR
// for i = 1 to 5 do
1000: LD_ADDR_VAR 0 3
1004: PUSH
1005: DOUBLE
1006: LD_INT 1
1008: DEC
1009: ST_TO_ADDR
1010: LD_INT 5
1012: PUSH
1013: FOR_TO
1014: IFFALSE 1198
// begin PrepareVehicle ( tmp [ 1 ] [ i mod 4 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , tmp [ 2 ] [ i mod 5 + 1 ] , 100 ) ;
1016: LD_VAR 0 2
1020: PUSH
1021: LD_INT 1
1023: ARRAY
1024: PUSH
1025: LD_VAR 0 3
1029: PUSH
1030: LD_INT 4
1032: MOD
1033: PUSH
1034: LD_INT 1
1036: PLUS
1037: ARRAY
1038: PPUSH
1039: LD_INT 1
1041: PUSH
1042: LD_INT 3
1044: PUSH
1045: EMPTY
1046: LIST
1047: LIST
1048: PUSH
1049: LD_INT 1
1051: PPUSH
1052: LD_INT 2
1054: PPUSH
1055: CALL_OW 12
1059: ARRAY
1060: PPUSH
1061: LD_INT 1
1063: PPUSH
1064: LD_VAR 0 2
1068: PUSH
1069: LD_INT 2
1071: ARRAY
1072: PUSH
1073: LD_VAR 0 3
1077: PUSH
1078: LD_INT 5
1080: MOD
1081: PUSH
1082: LD_INT 1
1084: PLUS
1085: ARRAY
1086: PPUSH
1087: LD_INT 100
1089: PPUSH
1090: CALL 534 0 5
// veh := CreateVehicle ;
1094: LD_ADDR_VAR 0 4
1098: PUSH
1099: CALL_OW 45
1103: ST_TO_ADDR
// SetDir ( veh , rand ( 0 , 5 ) ) ;
1104: LD_VAR 0 4
1108: PPUSH
1109: LD_INT 0
1111: PPUSH
1112: LD_INT 5
1114: PPUSH
1115: CALL_OW 12
1119: PPUSH
1120: CALL_OW 233
// if freedom then
1124: LD_EXP 4
1128: IFFALSE 1161
// begin if IsInArea ( freedom , freedom_base ) then
1130: LD_EXP 4
1134: PPUSH
1135: LD_INT 1
1137: PPUSH
1138: CALL_OW 308
1142: IFFALSE 1159
// PlaceUnitArea ( veh , freedom_base , false ) end else
1144: LD_VAR 0 4
1148: PPUSH
1149: LD_INT 1
1151: PPUSH
1152: LD_INT 0
1154: PPUSH
1155: CALL_OW 49
1159: GO 1196
// PlaceUnitXYR ( veh , GetX ( JMM ) , GetY ( JMM ) , 14 , false ) ;
1161: LD_VAR 0 4
1165: PPUSH
1166: LD_EXP 2
1170: PPUSH
1171: CALL_OW 250
1175: PPUSH
1176: LD_EXP 2
1180: PPUSH
1181: CALL_OW 251
1185: PPUSH
1186: LD_INT 14
1188: PPUSH
1189: LD_INT 0
1191: PPUSH
1192: CALL_OW 50
// end ;
1196: GO 1013
1198: POP
1199: POP
// uc_nation := 3 ;
1200: LD_ADDR_OWVAR 21
1204: PUSH
1205: LD_INT 3
1207: ST_TO_ADDR
// tmp := [ [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] ] ;
1208: LD_ADDR_VAR 0 2
1212: PUSH
1213: LD_INT 21
1215: PUSH
1216: LD_INT 22
1218: PUSH
1219: LD_INT 23
1221: PUSH
1222: LD_INT 24
1224: PUSH
1225: EMPTY
1226: LIST
1227: LIST
1228: LIST
1229: LIST
1230: PUSH
1231: LD_INT 43
1233: PUSH
1234: LD_INT 44
1236: PUSH
1237: LD_INT 45
1239: PUSH
1240: EMPTY
1241: LIST
1242: LIST
1243: LIST
1244: PUSH
1245: EMPTY
1246: LIST
1247: LIST
1248: ST_TO_ADDR
// for i = 1 to 5 do
1249: LD_ADDR_VAR 0 3
1253: PUSH
1254: DOUBLE
1255: LD_INT 1
1257: DEC
1258: ST_TO_ADDR
1259: LD_INT 5
1261: PUSH
1262: FOR_TO
1263: IFFALSE 1390
// begin PrepareVehicle ( tmp [ 1 ] [ i mod 4 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , tmp [ 2 ] [ i mod 3 + 1 ] , 100 ) ;
1265: LD_VAR 0 2
1269: PUSH
1270: LD_INT 1
1272: ARRAY
1273: PUSH
1274: LD_VAR 0 3
1278: PUSH
1279: LD_INT 4
1281: MOD
1282: PUSH
1283: LD_INT 1
1285: PLUS
1286: ARRAY
1287: PPUSH
1288: LD_INT 1
1290: PUSH
1291: LD_INT 3
1293: PUSH
1294: EMPTY
1295: LIST
1296: LIST
1297: PUSH
1298: LD_INT 1
1300: PPUSH
1301: LD_INT 2
1303: PPUSH
1304: CALL_OW 12
1308: ARRAY
1309: PPUSH
1310: LD_INT 1
1312: PPUSH
1313: LD_VAR 0 2
1317: PUSH
1318: LD_INT 2
1320: ARRAY
1321: PUSH
1322: LD_VAR 0 3
1326: PUSH
1327: LD_INT 3
1329: MOD
1330: PUSH
1331: LD_INT 1
1333: PLUS
1334: ARRAY
1335: PPUSH
1336: LD_INT 100
1338: PPUSH
1339: CALL 534 0 5
// veh := CreateVehicle ;
1343: LD_ADDR_VAR 0 4
1347: PUSH
1348: CALL_OW 45
1352: ST_TO_ADDR
// SetDir ( veh , rand ( 0 , 5 ) ) ;
1353: LD_VAR 0 4
1357: PPUSH
1358: LD_INT 0
1360: PPUSH
1361: LD_INT 5
1363: PPUSH
1364: CALL_OW 12
1368: PPUSH
1369: CALL_OW 233
// PlaceUnitArea ( veh , freedom_base , false ) ;
1373: LD_VAR 0 4
1377: PPUSH
1378: LD_INT 1
1380: PPUSH
1381: LD_INT 0
1383: PPUSH
1384: CALL_OW 49
// end ;
1388: GO 1262
1390: POP
1391: POP
// if not FilterAllUnits ( [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) then
1392: LD_INT 2
1394: PUSH
1395: LD_INT 34
1397: PUSH
1398: LD_INT 12
1400: PUSH
1401: EMPTY
1402: LIST
1403: LIST
1404: PUSH
1405: LD_INT 34
1407: PUSH
1408: LD_INT 51
1410: PUSH
1411: EMPTY
1412: LIST
1413: LIST
1414: PUSH
1415: EMPTY
1416: LIST
1417: LIST
1418: LIST
1419: PPUSH
1420: CALL_OW 69
1424: NOT
1425: IFFALSE 1491
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 0 ) ;
1427: LD_INT 22
1429: PPUSH
1430: LD_INT 3
1432: PPUSH
1433: LD_INT 1
1435: PPUSH
1436: LD_INT 51
1438: PPUSH
1439: LD_INT 0
1441: PPUSH
1442: CALL 534 0 5
// veh := CreateVehicle ;
1446: LD_ADDR_VAR 0 4
1450: PUSH
1451: CALL_OW 45
1455: ST_TO_ADDR
// SetDir ( veh , rand ( 0 , 5 ) ) ;
1456: LD_VAR 0 4
1460: PPUSH
1461: LD_INT 0
1463: PPUSH
1464: LD_INT 5
1466: PPUSH
1467: CALL_OW 12
1471: PPUSH
1472: CALL_OW 233
// PlaceUnitArea ( veh , freedom_base , false ) ;
1476: LD_VAR 0 4
1480: PPUSH
1481: LD_INT 1
1483: PPUSH
1484: LD_INT 0
1486: PPUSH
1487: CALL_OW 49
// end ; tmp := LoadVariable ( 13a_Masha , [ ] ) ;
1491: LD_ADDR_VAR 0 2
1495: PUSH
1496: LD_STRING 13a_Masha
1498: PPUSH
1499: EMPTY
1500: PPUSH
1501: CALL_OW 30
1505: ST_TO_ADDR
// if tmp then
1506: LD_VAR 0 2
1510: IFFALSE 1592
// begin PrepareVehicle ( tmp [ 1 ] , tmp [ 2 ] , tmp [ 3 ] , tmp [ 4 ] , 100 ) ;
1512: LD_VAR 0 2
1516: PUSH
1517: LD_INT 1
1519: ARRAY
1520: PPUSH
1521: LD_VAR 0 2
1525: PUSH
1526: LD_INT 2
1528: ARRAY
1529: PPUSH
1530: LD_VAR 0 2
1534: PUSH
1535: LD_INT 3
1537: ARRAY
1538: PPUSH
1539: LD_VAR 0 2
1543: PUSH
1544: LD_INT 4
1546: ARRAY
1547: PPUSH
1548: LD_INT 100
1550: PPUSH
1551: CALL 534 0 5
// Masha := CreateVehicle ;
1555: LD_ADDR_EXP 36
1559: PUSH
1560: CALL_OW 45
1564: ST_TO_ADDR
// PlaceUnitArea ( Masha , freedom_base , false ) ;
1565: LD_EXP 36
1569: PPUSH
1570: LD_INT 1
1572: PPUSH
1573: LD_INT 0
1575: PPUSH
1576: CALL_OW 49
// SetMark ( Masha , 1 ) ;
1580: LD_EXP 36
1584: PPUSH
1585: LD_INT 1
1587: PPUSH
1588: CALL_OW 242
// end ; uc_side := 4 ;
1592: LD_ADDR_OWVAR 20
1596: PUSH
1597: LD_INT 4
1599: ST_TO_ADDR
// tmp := [ ] ;
1600: LD_ADDR_VAR 0 2
1604: PUSH
1605: EMPTY
1606: ST_TO_ADDR
// squad1 := [ ] ;
1607: LD_ADDR_EXP 37
1611: PUSH
1612: EMPTY
1613: ST_TO_ADDR
// squad2 := [ ] ;
1614: LD_ADDR_EXP 38
1618: PUSH
1619: EMPTY
1620: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1621: LD_ADDR_EXP 19
1625: PUSH
1626: LD_STRING Joan
1628: PPUSH
1629: LD_EXP 1
1633: NOT
1634: PPUSH
1635: LD_STRING 13a_
1637: PPUSH
1638: CALL 471 0 3
1642: ST_TO_ADDR
// if Joan then
1643: LD_EXP 19
1647: IFFALSE 1665
// tmp := tmp ^ Joan ;
1649: LD_ADDR_VAR 0 2
1653: PUSH
1654: LD_VAR 0 2
1658: PUSH
1659: LD_EXP 19
1663: ADD
1664: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1665: LD_ADDR_EXP 5
1669: PUSH
1670: LD_STRING Roth
1672: PPUSH
1673: LD_EXP 1
1677: NOT
1678: PPUSH
1679: LD_STRING 13a_
1681: PPUSH
1682: CALL 471 0 3
1686: ST_TO_ADDR
// if Roth then
1687: LD_EXP 5
1691: IFFALSE 1709
// tmp := tmp ^ Roth ;
1693: LD_ADDR_VAR 0 2
1697: PUSH
1698: LD_VAR 0 2
1702: PUSH
1703: LD_EXP 5
1707: ADD
1708: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1709: LD_ADDR_EXP 10
1713: PUSH
1714: LD_STRING Denis
1716: PPUSH
1717: LD_EXP 1
1721: NOT
1722: PPUSH
1723: LD_STRING 13a_
1725: PPUSH
1726: CALL 471 0 3
1730: ST_TO_ADDR
// if Denis then
1731: LD_EXP 10
1735: IFFALSE 1753
// tmp := tmp ^ Denis ;
1737: LD_ADDR_VAR 0 2
1741: PUSH
1742: LD_VAR 0 2
1746: PUSH
1747: LD_EXP 10
1751: ADD
1752: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1753: LD_ADDR_EXP 20
1757: PUSH
1758: LD_STRING DeltaDoctor
1760: PPUSH
1761: LD_EXP 1
1765: NOT
1766: PPUSH
1767: LD_STRING 13a_
1769: PPUSH
1770: CALL 471 0 3
1774: ST_TO_ADDR
// if DeltaDoctor then
1775: LD_EXP 20
1779: IFFALSE 1797
// tmp := tmp ^ DeltaDoctor ;
1781: LD_ADDR_VAR 0 2
1785: PUSH
1786: LD_VAR 0 2
1790: PUSH
1791: LD_EXP 20
1795: ADD
1796: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1797: LD_ADDR_EXP 18
1801: PUSH
1802: LD_STRING Simms
1804: PPUSH
1805: LD_EXP 1
1809: NOT
1810: PPUSH
1811: LD_STRING 13a_
1813: PPUSH
1814: CALL 471 0 3
1818: ST_TO_ADDR
// if Simms then
1819: LD_EXP 18
1823: IFFALSE 1841
// tmp := tmp ^ Simms ;
1825: LD_ADDR_VAR 0 2
1829: PUSH
1830: LD_VAR 0 2
1834: PUSH
1835: LD_EXP 18
1839: ADD
1840: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1841: LD_ADDR_EXP 21
1845: PUSH
1846: LD_STRING Gossudarov
1848: PPUSH
1849: LD_EXP 1
1853: NOT
1854: PPUSH
1855: LD_STRING 13a_
1857: PPUSH
1858: CALL 471 0 3
1862: ST_TO_ADDR
// if Gossudarov then
1863: LD_EXP 21
1867: IFFALSE 1885
// tmp := tmp ^ Gossudarov ;
1869: LD_ADDR_VAR 0 2
1873: PUSH
1874: LD_VAR 0 2
1878: PUSH
1879: LD_EXP 21
1883: ADD
1884: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1885: LD_ADDR_EXP 22
1889: PUSH
1890: LD_STRING Kirilenkova
1892: PPUSH
1893: LD_EXP 1
1897: NOT
1898: PPUSH
1899: LD_STRING 13a_
1901: PPUSH
1902: CALL 471 0 3
1906: ST_TO_ADDR
// if Kirilenkova then
1907: LD_EXP 22
1911: IFFALSE 1929
// tmp := tmp ^ Kirilenkova ;
1913: LD_ADDR_VAR 0 2
1917: PUSH
1918: LD_VAR 0 2
1922: PUSH
1923: LD_EXP 22
1927: ADD
1928: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1929: LD_ADDR_EXP 25
1933: PUSH
1934: LD_STRING Petrosyan
1936: PPUSH
1937: LD_EXP 1
1941: NOT
1942: PPUSH
1943: LD_STRING 13a_
1945: PPUSH
1946: CALL 471 0 3
1950: ST_TO_ADDR
// if Petrosyan then
1951: LD_EXP 25
1955: IFFALSE 1973
// tmp := tmp ^ Petrosyan ;
1957: LD_ADDR_VAR 0 2
1961: PUSH
1962: LD_VAR 0 2
1966: PUSH
1967: LD_EXP 25
1971: ADD
1972: ST_TO_ADDR
// Scholtze := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1973: LD_ADDR_EXP 26
1977: PUSH
1978: LD_STRING Petrosyan
1980: PPUSH
1981: LD_EXP 1
1985: NOT
1986: PPUSH
1987: LD_STRING 13a_
1989: PPUSH
1990: CALL 471 0 3
1994: ST_TO_ADDR
// if Scholtze then
1995: LD_EXP 26
1999: IFFALSE 2017
// tmp := tmp ^ Scholtze ;
2001: LD_ADDR_VAR 0 2
2005: PUSH
2006: LD_VAR 0 2
2010: PUSH
2011: LD_EXP 26
2015: ADD
2016: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
2017: LD_ADDR_EXP 24
2021: PUSH
2022: LD_STRING Dolgov
2024: PPUSH
2025: LD_EXP 1
2029: NOT
2030: PPUSH
2031: LD_STRING 13a_
2033: PPUSH
2034: CALL 471 0 3
2038: ST_TO_ADDR
// if Dolgov then
2039: LD_EXP 24
2043: IFFALSE 2061
// tmp := tmp ^ Dolgov ;
2045: LD_ADDR_VAR 0 2
2049: PUSH
2050: LD_VAR 0 2
2054: PUSH
2055: LD_EXP 24
2059: ADD
2060: ST_TO_ADDR
// for i in tmp do
2061: LD_ADDR_VAR 0 3
2065: PUSH
2066: LD_VAR 0 2
2070: PUSH
2071: FOR_IN
2072: IFFALSE 2097
// PlaceUnitXYR ( i , 160 , 78 , 22 , false ) ;
2074: LD_VAR 0 3
2078: PPUSH
2079: LD_INT 160
2081: PPUSH
2082: LD_INT 78
2084: PPUSH
2085: LD_INT 22
2087: PPUSH
2088: LD_INT 0
2090: PPUSH
2091: CALL_OW 50
2095: GO 2071
2097: POP
2098: POP
// squad1 := tmp ;
2099: LD_ADDR_EXP 37
2103: PUSH
2104: LD_VAR 0 2
2108: ST_TO_ADDR
// tmp := [ ] ;
2109: LD_ADDR_VAR 0 2
2113: PUSH
2114: EMPTY
2115: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrova , ( not debug ) , 13a_ ) ;
2116: LD_ADDR_EXP 30
2120: PUSH
2121: LD_STRING Petrova
2123: PPUSH
2124: LD_EXP 1
2128: NOT
2129: PPUSH
2130: LD_STRING 13a_
2132: PPUSH
2133: CALL 471 0 3
2137: ST_TO_ADDR
// if Petrovova then
2138: LD_EXP 30
2142: IFFALSE 2160
// tmp := tmp ^ Petrovova ;
2144: LD_ADDR_VAR 0 2
2148: PUSH
2149: LD_VAR 0 2
2153: PUSH
2154: LD_EXP 30
2158: ADD
2159: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
2160: LD_ADDR_EXP 23
2164: PUSH
2165: LD_STRING Titov
2167: PPUSH
2168: LD_EXP 1
2172: NOT
2173: PPUSH
2174: LD_STRING 13a_
2176: PPUSH
2177: CALL 471 0 3
2181: ST_TO_ADDR
// if Titov then
2182: LD_EXP 23
2186: IFFALSE 2204
// tmp := tmp ^ Titov ;
2188: LD_ADDR_VAR 0 2
2192: PUSH
2193: LD_VAR 0 2
2197: PUSH
2198: LD_EXP 23
2202: ADD
2203: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2204: LD_ADDR_EXP 33
2208: PUSH
2209: LD_STRING Karamazov
2211: PPUSH
2212: LD_EXP 1
2216: NOT
2217: PPUSH
2218: LD_STRING 13a_
2220: PPUSH
2221: CALL 471 0 3
2225: ST_TO_ADDR
// if Karamazov then
2226: LD_EXP 33
2230: IFFALSE 2248
// tmp := tmp ^ Karamazov ;
2232: LD_ADDR_VAR 0 2
2236: PUSH
2237: LD_VAR 0 2
2241: PUSH
2242: LD_EXP 33
2246: ADD
2247: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
2248: LD_ADDR_EXP 16
2252: PUSH
2253: LD_STRING Frank
2255: PPUSH
2256: LD_EXP 1
2260: NOT
2261: PPUSH
2262: LD_STRING 13a_
2264: PPUSH
2265: CALL 471 0 3
2269: ST_TO_ADDR
// if Frank then
2270: LD_EXP 16
2274: IFFALSE 2292
// tmp := tmp ^ Frank ;
2276: LD_ADDR_VAR 0 2
2280: PUSH
2281: LD_VAR 0 2
2285: PUSH
2286: LD_EXP 16
2290: ADD
2291: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2292: LD_ADDR_EXP 7
2296: PUSH
2297: LD_STRING Donaldson
2299: PPUSH
2300: LD_EXP 1
2304: NOT
2305: PPUSH
2306: LD_STRING 13a_
2308: PPUSH
2309: CALL 471 0 3
2313: ST_TO_ADDR
// if Donaldson then
2314: LD_EXP 7
2318: IFFALSE 2336
// tmp := tmp ^ Donaldson ;
2320: LD_ADDR_VAR 0 2
2324: PUSH
2325: LD_VAR 0 2
2329: PUSH
2330: LD_EXP 7
2334: ADD
2335: ST_TO_ADDR
// for i in tmp do
2336: LD_ADDR_VAR 0 3
2340: PUSH
2341: LD_VAR 0 2
2345: PUSH
2346: FOR_IN
2347: IFFALSE 2387
// begin PlaceUnitXYR ( i , 117 , 8 , 6 , false ) ;
2349: LD_VAR 0 3
2353: PPUSH
2354: LD_INT 117
2356: PPUSH
2357: LD_INT 8
2359: PPUSH
2360: LD_INT 6
2362: PPUSH
2363: LD_INT 0
2365: PPUSH
2366: CALL_OW 50
// ComTurnXY ( i , 117 , 8 ) ;
2370: LD_VAR 0 3
2374: PPUSH
2375: LD_INT 117
2377: PPUSH
2378: LD_INT 8
2380: PPUSH
2381: CALL_OW 118
// end ;
2385: GO 2346
2387: POP
2388: POP
// squad2 := tmp ;
2389: LD_ADDR_EXP 38
2393: PUSH
2394: LD_VAR 0 2
2398: ST_TO_ADDR
// uc_side := 0 ;
2399: LD_ADDR_OWVAR 20
2403: PUSH
2404: LD_INT 0
2406: ST_TO_ADDR
// uc_nation := 0 ;
2407: LD_ADDR_OWVAR 21
2411: PUSH
2412: LD_INT 0
2414: ST_TO_ADDR
// InitHc ;
2415: CALL_OW 19
// hc_importance := 0 ;
2419: LD_ADDR_OWVAR 32
2423: PUSH
2424: LD_INT 0
2426: ST_TO_ADDR
// hc_name := Find some goods! ;
2427: LD_ADDR_OWVAR 26
2431: PUSH
2432: LD_STRING Find some goods!
2434: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
2435: LD_INT 0
2437: PPUSH
2438: LD_INT 12
2440: PPUSH
2441: LD_INT 1
2443: PPUSH
2444: CALL_OW 380
// PlaceUnitXY ( CreateHuman , 96 , 108 , false ) ;
2448: CALL_OW 44
2452: PPUSH
2453: LD_INT 96
2455: PPUSH
2456: LD_INT 108
2458: PPUSH
2459: LD_INT 0
2461: PPUSH
2462: CALL_OW 48
// InitHc ;
2466: CALL_OW 19
// end ;
2470: LD_VAR 0 1
2474: RET
// every 3 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 0 ] ] ) do var Louis , veh ;
2475: LD_INT 22
2477: PUSH
2478: LD_INT 7
2480: PUSH
2481: EMPTY
2482: LIST
2483: LIST
2484: PUSH
2485: LD_INT 23
2487: PUSH
2488: LD_INT 0
2490: PUSH
2491: EMPTY
2492: LIST
2493: LIST
2494: PUSH
2495: EMPTY
2496: LIST
2497: LIST
2498: PPUSH
2499: CALL_OW 69
2503: IFFALSE 2968
2505: GO 2507
2507: DISABLE
2508: LD_INT 0
2510: PPUSH
2511: PPUSH
// begin InGameOn ;
2512: CALL_OW 8
// RemoveUnit ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 0 ] ] ) [ 1 ] ) ;
2516: LD_INT 22
2518: PUSH
2519: LD_INT 7
2521: PUSH
2522: EMPTY
2523: LIST
2524: LIST
2525: PUSH
2526: LD_INT 23
2528: PUSH
2529: LD_INT 0
2531: PUSH
2532: EMPTY
2533: LIST
2534: LIST
2535: PUSH
2536: EMPTY
2537: LIST
2538: LIST
2539: PPUSH
2540: CALL_OW 69
2544: PUSH
2545: LD_INT 1
2547: ARRAY
2548: PPUSH
2549: CALL_OW 64
// game_speed := 4 ;
2553: LD_ADDR_OWVAR 65
2557: PUSH
2558: LD_INT 4
2560: ST_TO_ADDR
// ComMoveXY ( JMM , 93 , 100 ) ;
2561: LD_EXP 2
2565: PPUSH
2566: LD_INT 93
2568: PPUSH
2569: LD_INT 100
2571: PPUSH
2572: CALL_OW 111
// ComMoveXY ( Burlak , 93 , 99 ) ;
2576: LD_EXP 3
2580: PPUSH
2581: LD_INT 93
2583: PPUSH
2584: LD_INT 99
2586: PPUSH
2587: CALL_OW 111
// AddComTurnXY ( [ JMM , Burlak ] , 81 , 112 ) ;
2591: LD_EXP 2
2595: PUSH
2596: LD_EXP 3
2600: PUSH
2601: EMPTY
2602: LIST
2603: LIST
2604: PPUSH
2605: LD_INT 81
2607: PPUSH
2608: LD_INT 112
2610: PPUSH
2611: CALL_OW 178
// wait ( 0 0$5 ) ;
2615: LD_INT 175
2617: PPUSH
2618: CALL_OW 67
// music_nat := 2 ;
2622: LD_ADDR_OWVAR 71
2626: PUSH
2627: LD_INT 2
2629: ST_TO_ADDR
// music_class := 4 ;
2630: LD_ADDR_OWVAR 72
2634: PUSH
2635: LD_INT 4
2637: ST_TO_ADDR
// CenterNowOnXY ( 80 , 130 ) ;
2638: LD_INT 80
2640: PPUSH
2641: LD_INT 130
2643: PPUSH
2644: CALL_OW 86
// uc_nation := 2 ;
2648: LD_ADDR_OWVAR 21
2652: PUSH
2653: LD_INT 2
2655: ST_TO_ADDR
// uc_side := 2 ;
2656: LD_ADDR_OWVAR 20
2660: PUSH
2661: LD_INT 2
2663: ST_TO_ADDR
// hc_gallery = sandar ;
2664: LD_ADDR_OWVAR 33
2668: PUSH
2669: LD_STRING sandar
2671: ST_TO_ADDR
// hc_face_number = 1 ;
2672: LD_ADDR_OWVAR 34
2676: PUSH
2677: LD_INT 1
2679: ST_TO_ADDR
// hc_name = Louis Schulz ;
2680: LD_ADDR_OWVAR 26
2684: PUSH
2685: LD_STRING Louis Schulz
2687: ST_TO_ADDR
// hc_attr = [ 13 , 11 ] ;
2688: LD_ADDR_OWVAR 29
2692: PUSH
2693: LD_INT 13
2695: PUSH
2696: LD_INT 11
2698: PUSH
2699: EMPTY
2700: LIST
2701: LIST
2702: ST_TO_ADDR
// hc_basic_skills = [ 0 , 0 , 0 , 0 ] ;
2703: LD_ADDR_OWVAR 30
2707: PUSH
2708: LD_INT 0
2710: PUSH
2711: LD_INT 0
2713: PUSH
2714: LD_INT 0
2716: PUSH
2717: LD_INT 0
2719: PUSH
2720: EMPTY
2721: LIST
2722: LIST
2723: LIST
2724: LIST
2725: ST_TO_ADDR
// hc_skills = [ 10 , 6 , 7 , 7 ] ;
2726: LD_ADDR_OWVAR 31
2730: PUSH
2731: LD_INT 10
2733: PUSH
2734: LD_INT 6
2736: PUSH
2737: LD_INT 7
2739: PUSH
2740: LD_INT 7
2742: PUSH
2743: EMPTY
2744: LIST
2745: LIST
2746: LIST
2747: LIST
2748: ST_TO_ADDR
// hc_sex = sex_male ;
2749: LD_ADDR_OWVAR 27
2753: PUSH
2754: LD_INT 1
2756: ST_TO_ADDR
// hc_class = 1 ;
2757: LD_ADDR_OWVAR 28
2761: PUSH
2762: LD_INT 1
2764: ST_TO_ADDR
// hc_importance = 100 ;
2765: LD_ADDR_OWVAR 32
2769: PUSH
2770: LD_INT 100
2772: ST_TO_ADDR
// Louis = CreateHuman ;
2773: LD_ADDR_VAR 0 1
2777: PUSH
2778: CALL_OW 44
2782: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_flame_thrower , 100 ) ;
2783: LD_INT 14
2785: PPUSH
2786: LD_INT 3
2788: PPUSH
2789: LD_INT 1
2791: PPUSH
2792: LD_INT 26
2794: PPUSH
2795: LD_INT 100
2797: PPUSH
2798: CALL 534 0 5
// veh := CreateVehicle ;
2802: LD_ADDR_VAR 0 2
2806: PUSH
2807: CALL_OW 45
2811: ST_TO_ADDR
// SetMark ( veh , - 2 ) ;
2812: LD_VAR 0 2
2816: PPUSH
2817: LD_INT 2
2819: NEG
2820: PPUSH
2821: CALL_OW 242
// PlaceUnitXY ( veh , 80 , 130 , false ) ;
2825: LD_VAR 0 2
2829: PPUSH
2830: LD_INT 80
2832: PPUSH
2833: LD_INT 130
2835: PPUSH
2836: LD_INT 0
2838: PPUSH
2839: CALL_OW 48
// PlaceHumanInUnit ( Louis , veh ) ;
2843: LD_VAR 0 1
2847: PPUSH
2848: LD_VAR 0 2
2852: PPUSH
2853: CALL_OW 52
// ComMoveXY ( Louis , 80 , 109 ) ;
2857: LD_VAR 0 1
2861: PPUSH
2862: LD_INT 80
2864: PPUSH
2865: LD_INT 109
2867: PPUSH
2868: CALL_OW 111
// AddComExitVehicle ( Louis ) ;
2872: LD_VAR 0 1
2876: PPUSH
2877: CALL_OW 181
// AddComMoveXY ( Louis , 80 , 131 ) ;
2881: LD_VAR 0 1
2885: PPUSH
2886: LD_INT 80
2888: PPUSH
2889: LD_INT 131
2891: PPUSH
2892: CALL_OW 171
// wait ( 0 0$06 ) ;
2896: LD_INT 210
2898: PPUSH
2899: CALL_OW 67
// InGameOff ;
2903: CALL_OW 9
// repeat wait ( 0 0$1 ) ;
2907: LD_INT 35
2909: PPUSH
2910: CALL_OW 67
// until IsAt ( Louis , 80 , 131 ) ;
2914: LD_VAR 0 1
2918: PPUSH
2919: LD_INT 80
2921: PPUSH
2922: LD_INT 131
2924: PPUSH
2925: CALL_OW 307
2929: IFFALSE 2907
// SetSide ( veh , 7 ) ;
2931: LD_VAR 0 2
2935: PPUSH
2936: LD_INT 7
2938: PPUSH
2939: CALL_OW 235
// RemoveUnit ( Louis ) ;
2943: LD_VAR 0 1
2947: PPUSH
2948: CALL_OW 64
// music_nat := 3 ;
2952: LD_ADDR_OWVAR 71
2956: PUSH
2957: LD_INT 3
2959: ST_TO_ADDR
// music_class := 0 ;
2960: LD_ADDR_OWVAR 72
2964: PUSH
2965: LD_INT 0
2967: ST_TO_ADDR
// end ;
2968: PPOPN 2
2970: END
// every 0 0$10 trigger squad1 do var i , xy ;
2971: LD_EXP 37
2975: IFFALSE 3338
2977: GO 2979
2979: DISABLE
2980: LD_INT 0
2982: PPUSH
2983: PPUSH
// begin enable ;
2984: ENABLE
// i := squad1 [ rand ( 1 , squad1 ) ] ;
2985: LD_ADDR_VAR 0 1
2989: PUSH
2990: LD_EXP 37
2994: PUSH
2995: LD_INT 1
2997: PPUSH
2998: LD_EXP 37
3002: PPUSH
3003: CALL_OW 12
3007: ARRAY
3008: ST_TO_ADDR
// if IsInUnit ( i ) then
3009: LD_VAR 0 1
3013: PPUSH
3014: CALL_OW 310
3018: IFFALSE 3022
// exit ;
3020: GO 3338
// ComRemember ( i ) ;
3022: LD_VAR 0 1
3026: PPUSH
3027: CALL_OW 143
// xy := [ ShiftX ( GetX ( i ) , rand ( 0 , 5 ) , rand ( 2 , 7 ) ) , ShiftY ( GetY ( i ) , rand ( 0 , 5 ) , rand ( 2 , 7 ) ) ] ;
3031: LD_ADDR_VAR 0 2
3035: PUSH
3036: LD_VAR 0 1
3040: PPUSH
3041: CALL_OW 250
3045: PPUSH
3046: LD_INT 0
3048: PPUSH
3049: LD_INT 5
3051: PPUSH
3052: CALL_OW 12
3056: PPUSH
3057: LD_INT 2
3059: PPUSH
3060: LD_INT 7
3062: PPUSH
3063: CALL_OW 12
3067: PPUSH
3068: CALL_OW 272
3072: PUSH
3073: LD_VAR 0 1
3077: PPUSH
3078: CALL_OW 251
3082: PPUSH
3083: LD_INT 0
3085: PPUSH
3086: LD_INT 5
3088: PPUSH
3089: CALL_OW 12
3093: PPUSH
3094: LD_INT 2
3096: PPUSH
3097: LD_INT 7
3099: PPUSH
3100: CALL_OW 12
3104: PPUSH
3105: CALL_OW 273
3109: PUSH
3110: EMPTY
3111: LIST
3112: LIST
3113: ST_TO_ADDR
// if HexInfo ( xy [ 1 ] , xy [ 2 ] ) <> 0 or not ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
3114: LD_VAR 0 2
3118: PUSH
3119: LD_INT 1
3121: ARRAY
3122: PPUSH
3123: LD_VAR 0 2
3127: PUSH
3128: LD_INT 2
3130: ARRAY
3131: PPUSH
3132: CALL_OW 428
3136: PUSH
3137: LD_INT 0
3139: NONEQUAL
3140: PUSH
3141: LD_VAR 0 2
3145: PUSH
3146: LD_INT 1
3148: ARRAY
3149: PPUSH
3150: LD_VAR 0 2
3154: PUSH
3155: LD_INT 2
3157: ARRAY
3158: PPUSH
3159: CALL_OW 488
3163: NOT
3164: OR
3165: IFFALSE 3169
// exit ;
3167: GO 3338
// AddComMoveXY ( i , xy [ 1 ] , xy [ 2 ] ) ;
3169: LD_VAR 0 1
3173: PPUSH
3174: LD_VAR 0 2
3178: PUSH
3179: LD_INT 1
3181: ARRAY
3182: PPUSH
3183: LD_VAR 0 2
3187: PUSH
3188: LD_INT 2
3190: ARRAY
3191: PPUSH
3192: CALL_OW 171
// AddComWait ( i , 0 0$10 ) ;
3196: LD_VAR 0 1
3200: PPUSH
3201: LD_INT 350
3203: PPUSH
3204: CALL_OW 202
// if Prob ( 60 ) and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) then
3208: LD_INT 60
3210: PPUSH
3211: CALL_OW 13
3215: PUSH
3216: LD_INT 22
3218: PUSH
3219: LD_INT 4
3221: PUSH
3222: EMPTY
3223: LIST
3224: LIST
3225: PUSH
3226: LD_INT 21
3228: PUSH
3229: LD_INT 3
3231: PUSH
3232: EMPTY
3233: LIST
3234: LIST
3235: PUSH
3236: EMPTY
3237: LIST
3238: LIST
3239: PPUSH
3240: CALL_OW 69
3244: AND
3245: IFFALSE 3329
// begin AddComEnterUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , i ) ) ;
3247: LD_VAR 0 1
3251: PPUSH
3252: LD_INT 22
3254: PUSH
3255: LD_INT 4
3257: PUSH
3258: EMPTY
3259: LIST
3260: LIST
3261: PUSH
3262: LD_INT 21
3264: PUSH
3265: LD_INT 3
3267: PUSH
3268: EMPTY
3269: LIST
3270: LIST
3271: PUSH
3272: EMPTY
3273: LIST
3274: LIST
3275: PPUSH
3276: CALL_OW 69
3280: PPUSH
3281: LD_VAR 0 1
3285: PPUSH
3286: CALL_OW 74
3290: PPUSH
3291: CALL_OW 180
// repeat wait ( 0 0$30 ) ;
3295: LD_INT 1050
3297: PPUSH
3298: CALL_OW 67
// until IsInUnit ( i ) ;
3302: LD_VAR 0 1
3306: PPUSH
3307: CALL_OW 310
3311: IFFALSE 3295
// wait ( 0 0$30 ) ;
3313: LD_INT 1050
3315: PPUSH
3316: CALL_OW 67
// AddComExitBuilding ( i ) ;
3320: LD_VAR 0 1
3324: PPUSH
3325: CALL_OW 182
// end ; AddComReturn ( i ) ;
3329: LD_VAR 0 1
3333: PPUSH
3334: CALL_OW 204
// end ; end_of_file
3338: PPOPN 2
3340: END
// export function Action ; begin
3341: LD_INT 0
3343: PPUSH
// InGameOn ;
3344: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
3348: LD_EXP 2
3352: PPUSH
3353: CALL_OW 87
// Say ( JMM , D1-JMM-1 ) ;
3357: LD_EXP 2
3361: PPUSH
3362: LD_STRING D1-JMM-1
3364: PPUSH
3365: CALL_OW 88
// Say ( Burlak , D1-Bur-1 ) ;
3369: LD_EXP 3
3373: PPUSH
3374: LD_STRING D1-Bur-1
3376: PPUSH
3377: CALL_OW 88
// Say ( JMM , D1-JMM-2 ) ;
3381: LD_EXP 2
3385: PPUSH
3386: LD_STRING D1-JMM-2
3388: PPUSH
3389: CALL_OW 88
// Say ( Burlak , D1-Bur-2 ) ;
3393: LD_EXP 3
3397: PPUSH
3398: LD_STRING D1-Bur-2
3400: PPUSH
3401: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
3405: LD_EXP 2
3409: PPUSH
3410: LD_STRING D1-JMM-3
3412: PPUSH
3413: CALL_OW 88
// Say ( Burlak , D1-Bur-3 ) ;
3417: LD_EXP 3
3421: PPUSH
3422: LD_STRING D1-Bur-3
3424: PPUSH
3425: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
3429: LD_EXP 2
3433: PPUSH
3434: LD_STRING D1-JMM-4
3436: PPUSH
3437: CALL_OW 88
// Say ( Burlak , D1-Bur-4 ) ;
3441: LD_EXP 3
3445: PPUSH
3446: LD_STRING D1-Bur-4
3448: PPUSH
3449: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
3453: LD_EXP 2
3457: PPUSH
3458: LD_STRING D1-JMM-5
3460: PPUSH
3461: CALL_OW 88
// Say ( Burlak , D1-Bur-5 ) ;
3465: LD_EXP 3
3469: PPUSH
3470: LD_STRING D1-Bur-5
3472: PPUSH
3473: CALL_OW 88
// Say ( JMM , D1-JMM-6 ) ;
3477: LD_EXP 2
3481: PPUSH
3482: LD_STRING D1-JMM-6
3484: PPUSH
3485: CALL_OW 88
// Say ( Burlak , D1-Bur-6 ) ;
3489: LD_EXP 3
3493: PPUSH
3494: LD_STRING D1-Bur-6
3496: PPUSH
3497: CALL_OW 88
// Say ( JMM , D1-JMM-7 ) ;
3501: LD_EXP 2
3505: PPUSH
3506: LD_STRING D1-JMM-7
3508: PPUSH
3509: CALL_OW 88
// wait ( 20 ) ;
3513: LD_INT 20
3515: PPUSH
3516: CALL_OW 67
// Query ( QTruck ) ;
3520: LD_STRING QTruck
3522: PPUSH
3523: CALL_OW 97
// InGameOff ;
3527: CALL_OW 9
// ChangeMissionObjectives ( MArtPickup ) ;
3531: LD_STRING MArtPickup
3533: PPUSH
3534: CALL_OW 337
// SetAreaMapShow ( escape_area , 1 ) ;
3538: LD_INT 2
3540: PPUSH
3541: LD_INT 1
3543: PPUSH
3544: CALL_OW 424
// end ;
3548: LD_VAR 0 1
3552: RET
// every 0 0$3 trigger FilterUnitsInArea ( escape_area , [ [ f_type , unit_vehicle ] , [ f_control , control_manual ] , [ f_not , [ f_empty ] ] ] ) = 2 and IsInUnit ( JMM ) and IsInUnit ( Burlak ) and ( GetWeapon ( IsInUnit ( JMM ) ) in [ ru_cargo_bay , us_cargo_bay , ru_big_cargo_bay , ar_cargo_bay ] or GetWeapon ( IsInUnit ( Burlak ) ) in [ ru_cargo_bay , us_cargo_bay , ru_big_cargo_bay , ar_cargo_bay ] ) do var i , macmilanVeh , burlakVeh ;
3553: LD_INT 2
3555: PPUSH
3556: LD_INT 21
3558: PUSH
3559: LD_INT 2
3561: PUSH
3562: EMPTY
3563: LIST
3564: LIST
3565: PUSH
3566: LD_INT 33
3568: PUSH
3569: LD_INT 1
3571: PUSH
3572: EMPTY
3573: LIST
3574: LIST
3575: PUSH
3576: LD_INT 3
3578: PUSH
3579: LD_INT 58
3581: PUSH
3582: EMPTY
3583: LIST
3584: PUSH
3585: EMPTY
3586: LIST
3587: LIST
3588: PUSH
3589: EMPTY
3590: LIST
3591: LIST
3592: LIST
3593: PPUSH
3594: CALL_OW 70
3598: PUSH
3599: LD_INT 2
3601: EQUAL
3602: PUSH
3603: LD_EXP 2
3607: PPUSH
3608: CALL_OW 310
3612: AND
3613: PUSH
3614: LD_EXP 3
3618: PPUSH
3619: CALL_OW 310
3623: AND
3624: PUSH
3625: LD_EXP 2
3629: PPUSH
3630: CALL_OW 310
3634: PPUSH
3635: CALL_OW 264
3639: PUSH
3640: LD_INT 51
3642: PUSH
3643: LD_INT 12
3645: PUSH
3646: LD_EXP 40
3650: PUSH
3651: LD_INT 32
3653: PUSH
3654: EMPTY
3655: LIST
3656: LIST
3657: LIST
3658: LIST
3659: IN
3660: PUSH
3661: LD_EXP 3
3665: PPUSH
3666: CALL_OW 310
3670: PPUSH
3671: CALL_OW 264
3675: PUSH
3676: LD_INT 51
3678: PUSH
3679: LD_INT 12
3681: PUSH
3682: LD_EXP 40
3686: PUSH
3687: LD_INT 32
3689: PUSH
3690: EMPTY
3691: LIST
3692: LIST
3693: LIST
3694: LIST
3695: IN
3696: OR
3697: AND
3698: IFFALSE 3908
3700: GO 3702
3702: DISABLE
3703: LD_INT 0
3705: PPUSH
3706: PPUSH
3707: PPUSH
// begin macmilanVeh := IsInUnit ( JMM ) ;
3708: LD_ADDR_VAR 0 2
3712: PUSH
3713: LD_EXP 2
3717: PPUSH
3718: CALL_OW 310
3722: ST_TO_ADDR
// burlakVeh := IsInUnit ( Burlak ) ;
3723: LD_ADDR_VAR 0 3
3727: PUSH
3728: LD_EXP 3
3732: PPUSH
3733: CALL_OW 310
3737: ST_TO_ADDR
// SaveVariable ( [ GetChassis ( macmilanVeh ) , GetEngine ( macmilanVeh ) , control_manual , GetWeapon ( macmilanVeh ) , GetMark ( macmilanVeh ) , GetNation ( macmilanVeh ) ] , 14a_JMMVeh ) ;
3738: LD_VAR 0 2
3742: PPUSH
3743: CALL_OW 265
3747: PUSH
3748: LD_VAR 0 2
3752: PPUSH
3753: CALL_OW 262
3757: PUSH
3758: LD_INT 1
3760: PUSH
3761: LD_VAR 0 2
3765: PPUSH
3766: CALL_OW 264
3770: PUSH
3771: LD_VAR 0 2
3775: PPUSH
3776: CALL_OW 271
3780: PUSH
3781: LD_VAR 0 2
3785: PPUSH
3786: CALL_OW 248
3790: PUSH
3791: EMPTY
3792: LIST
3793: LIST
3794: LIST
3795: LIST
3796: LIST
3797: LIST
3798: PPUSH
3799: LD_STRING 14a_JMMVeh
3801: PPUSH
3802: CALL_OW 39
// SaveVariable ( [ GetChassis ( burlakVeh ) , GetEngine ( burlakVeh ) , control_manual , GetWeapon ( burlakVeh ) , GetMark ( burlakVeh ) , GetNation ( burlakVeh ) ] , 14a_BurlakVeh ) ;
3806: LD_VAR 0 3
3810: PPUSH
3811: CALL_OW 265
3815: PUSH
3816: LD_VAR 0 3
3820: PPUSH
3821: CALL_OW 262
3825: PUSH
3826: LD_INT 1
3828: PUSH
3829: LD_VAR 0 3
3833: PPUSH
3834: CALL_OW 264
3838: PUSH
3839: LD_VAR 0 3
3843: PPUSH
3844: CALL_OW 271
3848: PUSH
3849: LD_VAR 0 3
3853: PPUSH
3854: CALL_OW 248
3858: PUSH
3859: EMPTY
3860: LIST
3861: LIST
3862: LIST
3863: LIST
3864: LIST
3865: LIST
3866: PPUSH
3867: LD_STRING 14a_BurlakVeh
3869: PPUSH
3870: CALL_OW 39
// SaveCharacters ( JMM , 14a_JMM ) ;
3874: LD_EXP 2
3878: PPUSH
3879: LD_STRING 14a_JMM
3881: PPUSH
3882: CALL_OW 38
// SaveCharacters ( Burlak , 14a_Burlak ) ;
3886: LD_EXP 3
3890: PPUSH
3891: LD_STRING 14a_Burlak
3893: PPUSH
3894: CALL_OW 38
// ChangeMap ( 1 , %_cont ) ;
3898: LD_INT 1
3900: PPUSH
3901: LD_STRING %_cont
3903: PPUSH
3904: CALL_OW 340
// end ;
3908: PPOPN 3
3910: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_lives , 950 ] ] ] ) do
3911: LD_INT 22
3913: PUSH
3914: LD_INT 4
3916: PUSH
3917: EMPTY
3918: LIST
3919: LIST
3920: PUSH
3921: LD_INT 3
3923: PUSH
3924: LD_INT 24
3926: PUSH
3927: LD_INT 950
3929: PUSH
3930: EMPTY
3931: LIST
3932: LIST
3933: PUSH
3934: EMPTY
3935: LIST
3936: LIST
3937: PUSH
3938: EMPTY
3939: LIST
3940: LIST
3941: PPUSH
3942: CALL_OW 69
3946: IFFALSE 3958
3948: GO 3950
3950: DISABLE
// YouLost ( FriendlyFire ) ;
3951: LD_STRING FriendlyFire
3953: PPUSH
3954: CALL_OW 104
3958: END
// every 0 0$1 trigger IsDead ( Burlak ) do
3959: LD_EXP 3
3963: PPUSH
3964: CALL_OW 301
3968: IFFALSE 3980
3970: GO 3972
3972: DISABLE
// YouLost ( Burlak ) ;
3973: LD_STRING Burlak
3975: PPUSH
3976: CALL_OW 104
3980: END
// every 0 0$1 trigger IsDead ( JMM ) do
3981: LD_EXP 2
3985: PPUSH
3986: CALL_OW 301
3990: IFFALSE 4002
3992: GO 3994
3994: DISABLE
// YouLost ( JMM ) ; end_of_file
3995: LD_STRING JMM
3997: PPUSH
3998: CALL_OW 104
4002: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
4003: GO 4005
4005: DISABLE
// begin ru_radar := 98 ;
4006: LD_ADDR_EXP 39
4010: PUSH
4011: LD_INT 98
4013: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
4014: LD_ADDR_EXP 40
4018: PUSH
4019: LD_INT 89
4021: ST_TO_ADDR
// us_hack := 99 ;
4022: LD_ADDR_EXP 41
4026: PUSH
4027: LD_INT 99
4029: ST_TO_ADDR
// us_artillery := 97 ;
4030: LD_ADDR_EXP 42
4034: PUSH
4035: LD_INT 97
4037: ST_TO_ADDR
// ar_bio_bomb := 91 ;
4038: LD_ADDR_EXP 43
4042: PUSH
4043: LD_INT 91
4045: ST_TO_ADDR
// end ;
4046: END
