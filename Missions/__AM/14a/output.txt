// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// FogOff ( 7 ) ;
  11: LD_INT 7
  13: PPUSH
  14: CALL_OW 344
// RandomizeAll ;
  18: CALL_OW 11
// InitVariables ;
  22: CALL 66 0 0
// LoadBuildings ;
  26: CALL 94 0 0
// PrepareAlliance ;
  30: CALL 611 0 0
// music_nat := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
  34: LD_ADDR_OWVAR 71
  38: PUSH
  39: LD_INT 1
  41: PUSH
  42: LD_INT 3
  44: PUSH
  45: EMPTY
  46: LIST
  47: LIST
  48: PUSH
  49: LD_INT 1
  51: PPUSH
  52: LD_INT 2
  54: PPUSH
  55: CALL_OW 12
  59: ARRAY
  60: ST_TO_ADDR
// Action ;
  61: CALL 3399 0 0
// end ;
  65: END
// export debug ; export function InitVariables ; begin
  66: LD_INT 0
  68: PPUSH
// debug := false ;
  69: LD_ADDR_EXP 1
  73: PUSH
  74: LD_INT 0
  76: ST_TO_ADDR
// end ;
  77: LD_VAR 0 1
  81: RET
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
  82: LD_VAR 0 1
  86: PPUSH
  87: CALL 4203 0 1
// end ; end_of_file
  91: PPOPN 1
  93: END
// export function LoadBuildings ; var i , tmp , b ; begin
  94: LD_INT 0
  96: PPUSH
  97: PPUSH
  98: PPUSH
  99: PPUSH
// tmp := LoadVariable ( 13a_buildings , [ [ 7 , 1 , b_warehouse , 70 , 46 , 3 , 10 , 0 , 0 , 0 ] ] ) ;
 100: LD_ADDR_VAR 0 3
 104: PUSH
 105: LD_STRING 13a_buildings
 107: PPUSH
 108: LD_INT 7
 110: PUSH
 111: LD_INT 1
 113: PUSH
 114: LD_INT 1
 116: PUSH
 117: LD_INT 70
 119: PUSH
 120: LD_INT 46
 122: PUSH
 123: LD_INT 3
 125: PUSH
 126: LD_INT 10
 128: PUSH
 129: LD_INT 0
 131: PUSH
 132: LD_INT 0
 134: PUSH
 135: LD_INT 0
 137: PUSH
 138: EMPTY
 139: LIST
 140: LIST
 141: LIST
 142: LIST
 143: LIST
 144: LIST
 145: LIST
 146: LIST
 147: LIST
 148: LIST
 149: PUSH
 150: EMPTY
 151: LIST
 152: PPUSH
 153: CALL_OW 30
 157: ST_TO_ADDR
// bc_kind1 := - 1 ;
 158: LD_ADDR_OWVAR 44
 162: PUSH
 163: LD_INT 1
 165: NEG
 166: ST_TO_ADDR
// bc_kind2 := - 1 ;
 167: LD_ADDR_OWVAR 45
 171: PUSH
 172: LD_INT 1
 174: NEG
 175: ST_TO_ADDR
// for i in tmp do
 176: LD_ADDR_VAR 0 2
 180: PUSH
 181: LD_VAR 0 3
 185: PUSH
 186: FOR_IN
 187: IFFALSE 432
// begin uc_side := 7 ;
 189: LD_ADDR_OWVAR 20
 193: PUSH
 194: LD_INT 7
 196: ST_TO_ADDR
// uc_nation := i [ 2 ] ;
 197: LD_ADDR_OWVAR 21
 201: PUSH
 202: LD_VAR 0 2
 206: PUSH
 207: LD_INT 2
 209: ARRAY
 210: ST_TO_ADDR
// if i [ 2 ] = 2 then
 211: LD_VAR 0 2
 215: PUSH
 216: LD_INT 2
 218: ARRAY
 219: PUSH
 220: LD_INT 2
 222: EQUAL
 223: IFFALSE 233
// uc_side := 4 ;
 225: LD_ADDR_OWVAR 20
 229: PUSH
 230: LD_INT 4
 232: ST_TO_ADDR
// bc_type := i [ 3 ] ;
 233: LD_ADDR_OWVAR 42
 237: PUSH
 238: LD_VAR 0 2
 242: PUSH
 243: LD_INT 3
 245: ARRAY
 246: ST_TO_ADDR
// if i [ 3 ] in [ b_oil_mine , b_siberite_mine ] then
 247: LD_VAR 0 2
 251: PUSH
 252: LD_INT 3
 254: ARRAY
 255: PUSH
 256: LD_INT 29
 258: PUSH
 259: LD_INT 30
 261: PUSH
 262: EMPTY
 263: LIST
 264: LIST
 265: IN
 266: IFFALSE 299
// SetResourceVisibility ( i [ 4 ] , i [ 5 ] , i [ 1 ] ) ;
 268: LD_VAR 0 2
 272: PUSH
 273: LD_INT 4
 275: ARRAY
 276: PPUSH
 277: LD_VAR 0 2
 281: PUSH
 282: LD_INT 5
 284: ARRAY
 285: PPUSH
 286: LD_VAR 0 2
 290: PUSH
 291: LD_INT 1
 293: ARRAY
 294: PPUSH
 295: CALL_OW 441
// if i [ 8 ] then
 299: LD_VAR 0 2
 303: PUSH
 304: LD_INT 8
 306: ARRAY
 307: IFFALSE 323
// bc_kind1 := i [ 8 ] ;
 309: LD_ADDR_OWVAR 44
 313: PUSH
 314: LD_VAR 0 2
 318: PUSH
 319: LD_INT 8
 321: ARRAY
 322: ST_TO_ADDR
// if i [ 9 ] then
 323: LD_VAR 0 2
 327: PUSH
 328: LD_INT 9
 330: ARRAY
 331: IFFALSE 347
// bc_kind2 := i [ 9 ] ;
 333: LD_ADDR_OWVAR 45
 337: PUSH
 338: LD_VAR 0 2
 342: PUSH
 343: LD_INT 9
 345: ARRAY
 346: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( i [ 4 ] , i [ 5 ] , i [ 6 ] ) ;
 347: LD_ADDR_VAR 0 4
 351: PUSH
 352: LD_VAR 0 2
 356: PUSH
 357: LD_INT 4
 359: ARRAY
 360: PPUSH
 361: LD_VAR 0 2
 365: PUSH
 366: LD_INT 5
 368: ARRAY
 369: PPUSH
 370: LD_VAR 0 2
 374: PUSH
 375: LD_INT 6
 377: ARRAY
 378: PPUSH
 379: CALL_OW 47
 383: ST_TO_ADDR
// SetBLevel ( b , i [ 7 ] ) ;
 384: LD_VAR 0 4
 388: PPUSH
 389: LD_VAR 0 2
 393: PUSH
 394: LD_INT 7
 396: ARRAY
 397: PPUSH
 398: CALL_OW 241
// if i [ 10 ] then
 402: LD_VAR 0 2
 406: PUSH
 407: LD_INT 10
 409: ARRAY
 410: IFFALSE 430
// PlaceWeaponTurret ( b , i [ 10 ] ) ;
 412: LD_VAR 0 4
 416: PPUSH
 417: LD_VAR 0 2
 421: PUSH
 422: LD_INT 10
 424: ARRAY
 425: PPUSH
 426: CALL_OW 431
// end ;
 430: GO 186
 432: POP
 433: POP
// if HexInfo ( 144 , 65 ) = 0 then
 434: LD_INT 144
 436: PPUSH
 437: LD_INT 65
 439: PPUSH
 440: CALL_OW 428
 444: PUSH
 445: LD_INT 0
 447: EQUAL
 448: IFFALSE 485
// begin uc_side := 4 ;
 450: LD_ADDR_OWVAR 20
 454: PUSH
 455: LD_INT 4
 457: ST_TO_ADDR
// bc_type := b_warehouse ;
 458: LD_ADDR_OWVAR 42
 462: PUSH
 463: LD_INT 1
 465: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 144 , 65 , 1 ) ;
 466: LD_ADDR_VAR 0 4
 470: PUSH
 471: LD_INT 144
 473: PPUSH
 474: LD_INT 65
 476: PPUSH
 477: LD_INT 1
 479: PPUSH
 480: CALL_OW 47
 484: ST_TO_ADDR
// end ; end ;
 485: LD_VAR 0 1
 489: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 490: LD_INT 0
 492: PPUSH
 493: PPUSH
// if exist_mode then
 494: LD_VAR 0 2
 498: IFFALSE 523
// unit := CreateCharacter ( prefix & ident ) else
 500: LD_ADDR_VAR 0 5
 504: PUSH
 505: LD_VAR 0 3
 509: PUSH
 510: LD_VAR 0 1
 514: STR
 515: PPUSH
 516: CALL_OW 34
 520: ST_TO_ADDR
 521: GO 538
// unit := NewCharacter ( ident ) ;
 523: LD_ADDR_VAR 0 5
 527: PUSH
 528: LD_VAR 0 1
 532: PPUSH
 533: CALL_OW 25
 537: ST_TO_ADDR
// result := unit ;
 538: LD_ADDR_VAR 0 4
 542: PUSH
 543: LD_VAR 0 5
 547: ST_TO_ADDR
// end ;
 548: LD_VAR 0 4
 552: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
 553: LD_INT 0
 555: PPUSH
// vc_chassis := chassis ;
 556: LD_ADDR_OWVAR 37
 560: PUSH
 561: LD_VAR 0 1
 565: ST_TO_ADDR
// vc_engine := engine ;
 566: LD_ADDR_OWVAR 39
 570: PUSH
 571: LD_VAR 0 2
 575: ST_TO_ADDR
// vc_control := control ;
 576: LD_ADDR_OWVAR 38
 580: PUSH
 581: LD_VAR 0 3
 585: ST_TO_ADDR
// vc_weapon := weapon ;
 586: LD_ADDR_OWVAR 40
 590: PUSH
 591: LD_VAR 0 4
 595: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 596: LD_ADDR_OWVAR 41
 600: PUSH
 601: LD_VAR 0 5
 605: ST_TO_ADDR
// end ; end_of_file
 606: LD_VAR 0 6
 610: RET
// export JMM , Burlak , freedom ; export Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Belkov , Gnyevko , Masha ; export squad1 , squad2 ; export function PrepareAlliance ; var tmp , i , veh ; begin
 611: LD_INT 0
 613: PPUSH
 614: PPUSH
 615: PPUSH
 616: PPUSH
// uc_side := 7 ;
 617: LD_ADDR_OWVAR 20
 621: PUSH
 622: LD_INT 7
 624: ST_TO_ADDR
// uc_nation := 1 ;
 625: LD_ADDR_OWVAR 21
 629: PUSH
 630: LD_INT 1
 632: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 13a_ ) ;
 633: LD_ADDR_EXP 2
 637: PUSH
 638: LD_STRING JMM
 640: PPUSH
 641: LD_EXP 1
 645: NOT
 646: PPUSH
 647: LD_STRING 13a_
 649: PPUSH
 650: CALL 490 0 3
 654: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 13a_ ) ;
 655: LD_ADDR_EXP 3
 659: PUSH
 660: LD_STRING Burlak
 662: PPUSH
 663: LD_EXP 1
 667: NOT
 668: PPUSH
 669: LD_STRING 13a_
 671: PPUSH
 672: CALL 490 0 3
 676: ST_TO_ADDR
// if debug then
 677: LD_EXP 1
 681: IFFALSE 716
// begin PrepareHuman ( sex_male , 4 , 10 ) ;
 683: LD_INT 1
 685: PPUSH
 686: LD_INT 4
 688: PPUSH
 689: LD_INT 10
 691: PPUSH
 692: CALL_OW 380
// JMM := CreateHuman ;
 696: LD_ADDR_EXP 2
 700: PUSH
 701: CALL_OW 44
 705: ST_TO_ADDR
// Burlak := CreateHuman ;
 706: LD_ADDR_EXP 3
 710: PUSH
 711: CALL_OW 44
 715: ST_TO_ADDR
// end ; freedom := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_nation , 1 ] , [ f_nation , 3 ] ] , [ f_btype , b_warehouse ] ] ) ;
 716: LD_ADDR_EXP 4
 720: PUSH
 721: LD_INT 22
 723: PUSH
 724: LD_INT 7
 726: PUSH
 727: EMPTY
 728: LIST
 729: LIST
 730: PUSH
 731: LD_INT 2
 733: PUSH
 734: LD_INT 23
 736: PUSH
 737: LD_INT 1
 739: PUSH
 740: EMPTY
 741: LIST
 742: LIST
 743: PUSH
 744: LD_INT 23
 746: PUSH
 747: LD_INT 3
 749: PUSH
 750: EMPTY
 751: LIST
 752: LIST
 753: PUSH
 754: EMPTY
 755: LIST
 756: LIST
 757: LIST
 758: PUSH
 759: LD_INT 30
 761: PUSH
 762: LD_INT 1
 764: PUSH
 765: EMPTY
 766: LIST
 767: LIST
 768: PUSH
 769: EMPTY
 770: LIST
 771: LIST
 772: LIST
 773: PPUSH
 774: CALL_OW 69
 778: ST_TO_ADDR
// if freedom then
 779: LD_EXP 4
 783: IFFALSE 910
// begin freedom := freedom [ 1 ] ;
 785: LD_ADDR_EXP 4
 789: PUSH
 790: LD_EXP 4
 794: PUSH
 795: LD_INT 1
 797: ARRAY
 798: ST_TO_ADDR
// SetBName ( freedom , freedom ) ;
 799: LD_EXP 4
 803: PPUSH
 804: LD_STRING freedom
 806: PPUSH
 807: CALL_OW 500
// CenterNowOnUnits ( freedom ) ;
 811: LD_EXP 4
 815: PPUSH
 816: CALL_OW 87
// PlaceHumanInUnit ( JMM , freedom ) ;
 820: LD_EXP 2
 824: PPUSH
 825: LD_EXP 4
 829: PPUSH
 830: CALL_OW 52
// PlaceHumanInUnit ( Burlak , freedom ) ;
 834: LD_EXP 3
 838: PPUSH
 839: LD_EXP 4
 843: PPUSH
 844: CALL_OW 52
// SetResourceType ( GetBase ( freedom ) , mat_cans , 1000 ) ;
 848: LD_EXP 4
 852: PPUSH
 853: CALL_OW 274
 857: PPUSH
 858: LD_INT 1
 860: PPUSH
 861: LD_INT 1000
 863: PPUSH
 864: CALL_OW 277
// SetResourceType ( GetBase ( freedom ) , mat_oil , 400 ) ;
 868: LD_EXP 4
 872: PPUSH
 873: CALL_OW 274
 877: PPUSH
 878: LD_INT 2
 880: PPUSH
 881: LD_INT 400
 883: PPUSH
 884: CALL_OW 277
// SetResourceType ( GetBase ( freedom ) , mat_siberit , 30 ) ;
 888: LD_EXP 4
 892: PPUSH
 893: CALL_OW 274
 897: PPUSH
 898: LD_INT 3
 900: PPUSH
 901: LD_INT 30
 903: PPUSH
 904: CALL_OW 277
// end else
 908: GO 997
// begin PlaceUnitArea ( JMM , freedom_base , false ) ;
 910: LD_EXP 2
 914: PPUSH
 915: LD_INT 1
 917: PPUSH
 918: LD_INT 0
 920: PPUSH
 921: CALL_OW 49
// PlaceUnitXYR ( Burlak , GetX ( JMM ) , GetY ( JMM ) , 8 , false ) ;
 925: LD_EXP 3
 929: PPUSH
 930: LD_EXP 2
 934: PPUSH
 935: CALL_OW 250
 939: PPUSH
 940: LD_EXP 2
 944: PPUSH
 945: CALL_OW 251
 949: PPUSH
 950: LD_INT 8
 952: PPUSH
 953: LD_INT 0
 955: PPUSH
 956: CALL_OW 50
// ComTurnUnit ( JMM , Burlak ) ;
 960: LD_EXP 2
 964: PPUSH
 965: LD_EXP 3
 969: PPUSH
 970: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
 974: LD_EXP 3
 978: PPUSH
 979: LD_EXP 2
 983: PPUSH
 984: CALL_OW 119
// CenterNowOnUnits ( JMM ) ;
 988: LD_EXP 2
 992: PPUSH
 993: CALL_OW 87
// end ; SetClass ( JMM , 2 ) ;
 997: LD_EXP 2
1001: PPUSH
1002: LD_INT 2
1004: PPUSH
1005: CALL_OW 336
// tmp := [ [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] , [ us_double_gun , us_laser , us_rocket_launcher , us_gatling_gun , us_cargo_bay ] ] ;
1009: LD_ADDR_VAR 0 2
1013: PUSH
1014: LD_INT 2
1016: PUSH
1017: LD_INT 3
1019: PUSH
1020: LD_INT 4
1022: PUSH
1023: LD_INT 5
1025: PUSH
1026: EMPTY
1027: LIST
1028: LIST
1029: LIST
1030: LIST
1031: PUSH
1032: LD_INT 5
1034: PUSH
1035: LD_INT 9
1037: PUSH
1038: LD_INT 7
1040: PUSH
1041: LD_INT 4
1043: PUSH
1044: LD_INT 12
1046: PUSH
1047: EMPTY
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: LIST
1053: PUSH
1054: EMPTY
1055: LIST
1056: LIST
1057: ST_TO_ADDR
// for i = 1 to 5 do
1058: LD_ADDR_VAR 0 3
1062: PUSH
1063: DOUBLE
1064: LD_INT 1
1066: DEC
1067: ST_TO_ADDR
1068: LD_INT 5
1070: PUSH
1071: FOR_TO
1072: IFFALSE 1256
// begin PrepareVehicle ( tmp [ 1 ] [ i mod 4 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , tmp [ 2 ] [ i mod 5 + 1 ] , 100 ) ;
1074: LD_VAR 0 2
1078: PUSH
1079: LD_INT 1
1081: ARRAY
1082: PUSH
1083: LD_VAR 0 3
1087: PUSH
1088: LD_INT 4
1090: MOD
1091: PUSH
1092: LD_INT 1
1094: PLUS
1095: ARRAY
1096: PPUSH
1097: LD_INT 1
1099: PUSH
1100: LD_INT 3
1102: PUSH
1103: EMPTY
1104: LIST
1105: LIST
1106: PUSH
1107: LD_INT 1
1109: PPUSH
1110: LD_INT 2
1112: PPUSH
1113: CALL_OW 12
1117: ARRAY
1118: PPUSH
1119: LD_INT 1
1121: PPUSH
1122: LD_VAR 0 2
1126: PUSH
1127: LD_INT 2
1129: ARRAY
1130: PUSH
1131: LD_VAR 0 3
1135: PUSH
1136: LD_INT 5
1138: MOD
1139: PUSH
1140: LD_INT 1
1142: PLUS
1143: ARRAY
1144: PPUSH
1145: LD_INT 100
1147: PPUSH
1148: CALL 553 0 5
// veh := CreateVehicle ;
1152: LD_ADDR_VAR 0 4
1156: PUSH
1157: CALL_OW 45
1161: ST_TO_ADDR
// SetDir ( veh , rand ( 0 , 5 ) ) ;
1162: LD_VAR 0 4
1166: PPUSH
1167: LD_INT 0
1169: PPUSH
1170: LD_INT 5
1172: PPUSH
1173: CALL_OW 12
1177: PPUSH
1178: CALL_OW 233
// if freedom then
1182: LD_EXP 4
1186: IFFALSE 1219
// begin if IsInArea ( freedom , freedom_base ) then
1188: LD_EXP 4
1192: PPUSH
1193: LD_INT 1
1195: PPUSH
1196: CALL_OW 308
1200: IFFALSE 1217
// PlaceUnitArea ( veh , freedom_base , false ) end else
1202: LD_VAR 0 4
1206: PPUSH
1207: LD_INT 1
1209: PPUSH
1210: LD_INT 0
1212: PPUSH
1213: CALL_OW 49
1217: GO 1254
// PlaceUnitXYR ( veh , GetX ( JMM ) , GetY ( JMM ) , 14 , false ) ;
1219: LD_VAR 0 4
1223: PPUSH
1224: LD_EXP 2
1228: PPUSH
1229: CALL_OW 250
1233: PPUSH
1234: LD_EXP 2
1238: PPUSH
1239: CALL_OW 251
1243: PPUSH
1244: LD_INT 14
1246: PPUSH
1247: LD_INT 0
1249: PPUSH
1250: CALL_OW 50
// end ;
1254: GO 1071
1256: POP
1257: POP
// uc_nation := 3 ;
1258: LD_ADDR_OWVAR 21
1262: PUSH
1263: LD_INT 3
1265: ST_TO_ADDR
// tmp := [ [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] ] ;
1266: LD_ADDR_VAR 0 2
1270: PUSH
1271: LD_INT 21
1273: PUSH
1274: LD_INT 22
1276: PUSH
1277: LD_INT 23
1279: PUSH
1280: LD_INT 24
1282: PUSH
1283: EMPTY
1284: LIST
1285: LIST
1286: LIST
1287: LIST
1288: PUSH
1289: LD_INT 43
1291: PUSH
1292: LD_INT 44
1294: PUSH
1295: LD_INT 45
1297: PUSH
1298: EMPTY
1299: LIST
1300: LIST
1301: LIST
1302: PUSH
1303: EMPTY
1304: LIST
1305: LIST
1306: ST_TO_ADDR
// for i = 1 to 5 do
1307: LD_ADDR_VAR 0 3
1311: PUSH
1312: DOUBLE
1313: LD_INT 1
1315: DEC
1316: ST_TO_ADDR
1317: LD_INT 5
1319: PUSH
1320: FOR_TO
1321: IFFALSE 1448
// begin PrepareVehicle ( tmp [ 1 ] [ i mod 4 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , tmp [ 2 ] [ i mod 3 + 1 ] , 100 ) ;
1323: LD_VAR 0 2
1327: PUSH
1328: LD_INT 1
1330: ARRAY
1331: PUSH
1332: LD_VAR 0 3
1336: PUSH
1337: LD_INT 4
1339: MOD
1340: PUSH
1341: LD_INT 1
1343: PLUS
1344: ARRAY
1345: PPUSH
1346: LD_INT 1
1348: PUSH
1349: LD_INT 3
1351: PUSH
1352: EMPTY
1353: LIST
1354: LIST
1355: PUSH
1356: LD_INT 1
1358: PPUSH
1359: LD_INT 2
1361: PPUSH
1362: CALL_OW 12
1366: ARRAY
1367: PPUSH
1368: LD_INT 1
1370: PPUSH
1371: LD_VAR 0 2
1375: PUSH
1376: LD_INT 2
1378: ARRAY
1379: PUSH
1380: LD_VAR 0 3
1384: PUSH
1385: LD_INT 3
1387: MOD
1388: PUSH
1389: LD_INT 1
1391: PLUS
1392: ARRAY
1393: PPUSH
1394: LD_INT 100
1396: PPUSH
1397: CALL 553 0 5
// veh := CreateVehicle ;
1401: LD_ADDR_VAR 0 4
1405: PUSH
1406: CALL_OW 45
1410: ST_TO_ADDR
// SetDir ( veh , rand ( 0 , 5 ) ) ;
1411: LD_VAR 0 4
1415: PPUSH
1416: LD_INT 0
1418: PPUSH
1419: LD_INT 5
1421: PPUSH
1422: CALL_OW 12
1426: PPUSH
1427: CALL_OW 233
// PlaceUnitArea ( veh , freedom_base , false ) ;
1431: LD_VAR 0 4
1435: PPUSH
1436: LD_INT 1
1438: PPUSH
1439: LD_INT 0
1441: PPUSH
1442: CALL_OW 49
// end ;
1446: GO 1320
1448: POP
1449: POP
// if not FilterAllUnits ( [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) then
1450: LD_INT 2
1452: PUSH
1453: LD_INT 34
1455: PUSH
1456: LD_INT 12
1458: PUSH
1459: EMPTY
1460: LIST
1461: LIST
1462: PUSH
1463: LD_INT 34
1465: PUSH
1466: LD_INT 51
1468: PUSH
1469: EMPTY
1470: LIST
1471: LIST
1472: PUSH
1473: EMPTY
1474: LIST
1475: LIST
1476: LIST
1477: PPUSH
1478: CALL_OW 69
1482: NOT
1483: IFFALSE 1549
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 0 ) ;
1485: LD_INT 22
1487: PPUSH
1488: LD_INT 3
1490: PPUSH
1491: LD_INT 1
1493: PPUSH
1494: LD_INT 51
1496: PPUSH
1497: LD_INT 0
1499: PPUSH
1500: CALL 553 0 5
// veh := CreateVehicle ;
1504: LD_ADDR_VAR 0 4
1508: PUSH
1509: CALL_OW 45
1513: ST_TO_ADDR
// SetDir ( veh , rand ( 0 , 5 ) ) ;
1514: LD_VAR 0 4
1518: PPUSH
1519: LD_INT 0
1521: PPUSH
1522: LD_INT 5
1524: PPUSH
1525: CALL_OW 12
1529: PPUSH
1530: CALL_OW 233
// PlaceUnitArea ( veh , freedom_base , false ) ;
1534: LD_VAR 0 4
1538: PPUSH
1539: LD_INT 1
1541: PPUSH
1542: LD_INT 0
1544: PPUSH
1545: CALL_OW 49
// end ; tmp := LoadVariable ( 13a_Masha , [ ] ) ;
1549: LD_ADDR_VAR 0 2
1553: PUSH
1554: LD_STRING 13a_Masha
1556: PPUSH
1557: EMPTY
1558: PPUSH
1559: CALL_OW 30
1563: ST_TO_ADDR
// if tmp then
1564: LD_VAR 0 2
1568: IFFALSE 1650
// begin PrepareVehicle ( tmp [ 1 ] , tmp [ 2 ] , tmp [ 3 ] , tmp [ 4 ] , 100 ) ;
1570: LD_VAR 0 2
1574: PUSH
1575: LD_INT 1
1577: ARRAY
1578: PPUSH
1579: LD_VAR 0 2
1583: PUSH
1584: LD_INT 2
1586: ARRAY
1587: PPUSH
1588: LD_VAR 0 2
1592: PUSH
1593: LD_INT 3
1595: ARRAY
1596: PPUSH
1597: LD_VAR 0 2
1601: PUSH
1602: LD_INT 4
1604: ARRAY
1605: PPUSH
1606: LD_INT 100
1608: PPUSH
1609: CALL 553 0 5
// Masha := CreateVehicle ;
1613: LD_ADDR_EXP 36
1617: PUSH
1618: CALL_OW 45
1622: ST_TO_ADDR
// PlaceUnitArea ( Masha , freedom_base , false ) ;
1623: LD_EXP 36
1627: PPUSH
1628: LD_INT 1
1630: PPUSH
1631: LD_INT 0
1633: PPUSH
1634: CALL_OW 49
// SetMark ( Masha , 1 ) ;
1638: LD_EXP 36
1642: PPUSH
1643: LD_INT 1
1645: PPUSH
1646: CALL_OW 242
// end ; uc_side := 4 ;
1650: LD_ADDR_OWVAR 20
1654: PUSH
1655: LD_INT 4
1657: ST_TO_ADDR
// tmp := [ ] ;
1658: LD_ADDR_VAR 0 2
1662: PUSH
1663: EMPTY
1664: ST_TO_ADDR
// squad1 := [ ] ;
1665: LD_ADDR_EXP 37
1669: PUSH
1670: EMPTY
1671: ST_TO_ADDR
// squad2 := [ ] ;
1672: LD_ADDR_EXP 38
1676: PUSH
1677: EMPTY
1678: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1679: LD_ADDR_EXP 19
1683: PUSH
1684: LD_STRING Joan
1686: PPUSH
1687: LD_EXP 1
1691: NOT
1692: PPUSH
1693: LD_STRING 13a_
1695: PPUSH
1696: CALL 490 0 3
1700: ST_TO_ADDR
// if Joan then
1701: LD_EXP 19
1705: IFFALSE 1723
// tmp := tmp ^ Joan ;
1707: LD_ADDR_VAR 0 2
1711: PUSH
1712: LD_VAR 0 2
1716: PUSH
1717: LD_EXP 19
1721: ADD
1722: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1723: LD_ADDR_EXP 5
1727: PUSH
1728: LD_STRING Roth
1730: PPUSH
1731: LD_EXP 1
1735: NOT
1736: PPUSH
1737: LD_STRING 13a_
1739: PPUSH
1740: CALL 490 0 3
1744: ST_TO_ADDR
// if Roth then
1745: LD_EXP 5
1749: IFFALSE 1767
// tmp := tmp ^ Roth ;
1751: LD_ADDR_VAR 0 2
1755: PUSH
1756: LD_VAR 0 2
1760: PUSH
1761: LD_EXP 5
1765: ADD
1766: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1767: LD_ADDR_EXP 10
1771: PUSH
1772: LD_STRING Denis
1774: PPUSH
1775: LD_EXP 1
1779: NOT
1780: PPUSH
1781: LD_STRING 13a_
1783: PPUSH
1784: CALL 490 0 3
1788: ST_TO_ADDR
// if Denis then
1789: LD_EXP 10
1793: IFFALSE 1811
// tmp := tmp ^ Denis ;
1795: LD_ADDR_VAR 0 2
1799: PUSH
1800: LD_VAR 0 2
1804: PUSH
1805: LD_EXP 10
1809: ADD
1810: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1811: LD_ADDR_EXP 20
1815: PUSH
1816: LD_STRING DeltaDoctor
1818: PPUSH
1819: LD_EXP 1
1823: NOT
1824: PPUSH
1825: LD_STRING 13a_
1827: PPUSH
1828: CALL 490 0 3
1832: ST_TO_ADDR
// if DeltaDoctor then
1833: LD_EXP 20
1837: IFFALSE 1855
// tmp := tmp ^ DeltaDoctor ;
1839: LD_ADDR_VAR 0 2
1843: PUSH
1844: LD_VAR 0 2
1848: PUSH
1849: LD_EXP 20
1853: ADD
1854: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1855: LD_ADDR_EXP 18
1859: PUSH
1860: LD_STRING Simms
1862: PPUSH
1863: LD_EXP 1
1867: NOT
1868: PPUSH
1869: LD_STRING 13a_
1871: PPUSH
1872: CALL 490 0 3
1876: ST_TO_ADDR
// if Simms then
1877: LD_EXP 18
1881: IFFALSE 1899
// tmp := tmp ^ Simms ;
1883: LD_ADDR_VAR 0 2
1887: PUSH
1888: LD_VAR 0 2
1892: PUSH
1893: LD_EXP 18
1897: ADD
1898: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1899: LD_ADDR_EXP 21
1903: PUSH
1904: LD_STRING Gossudarov
1906: PPUSH
1907: LD_EXP 1
1911: NOT
1912: PPUSH
1913: LD_STRING 13a_
1915: PPUSH
1916: CALL 490 0 3
1920: ST_TO_ADDR
// if Gossudarov then
1921: LD_EXP 21
1925: IFFALSE 1943
// tmp := tmp ^ Gossudarov ;
1927: LD_ADDR_VAR 0 2
1931: PUSH
1932: LD_VAR 0 2
1936: PUSH
1937: LD_EXP 21
1941: ADD
1942: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1943: LD_ADDR_EXP 22
1947: PUSH
1948: LD_STRING Kirilenkova
1950: PPUSH
1951: LD_EXP 1
1955: NOT
1956: PPUSH
1957: LD_STRING 13a_
1959: PPUSH
1960: CALL 490 0 3
1964: ST_TO_ADDR
// if Kirilenkova then
1965: LD_EXP 22
1969: IFFALSE 1987
// tmp := tmp ^ Kirilenkova ;
1971: LD_ADDR_VAR 0 2
1975: PUSH
1976: LD_VAR 0 2
1980: PUSH
1981: LD_EXP 22
1985: ADD
1986: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1987: LD_ADDR_EXP 25
1991: PUSH
1992: LD_STRING Petrosyan
1994: PPUSH
1995: LD_EXP 1
1999: NOT
2000: PPUSH
2001: LD_STRING 13a_
2003: PPUSH
2004: CALL 490 0 3
2008: ST_TO_ADDR
// if Petrosyan then
2009: LD_EXP 25
2013: IFFALSE 2031
// tmp := tmp ^ Petrosyan ;
2015: LD_ADDR_VAR 0 2
2019: PUSH
2020: LD_VAR 0 2
2024: PUSH
2025: LD_EXP 25
2029: ADD
2030: ST_TO_ADDR
// Scholtze := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
2031: LD_ADDR_EXP 26
2035: PUSH
2036: LD_STRING Petrosyan
2038: PPUSH
2039: LD_EXP 1
2043: NOT
2044: PPUSH
2045: LD_STRING 13a_
2047: PPUSH
2048: CALL 490 0 3
2052: ST_TO_ADDR
// if Scholtze then
2053: LD_EXP 26
2057: IFFALSE 2075
// tmp := tmp ^ Scholtze ;
2059: LD_ADDR_VAR 0 2
2063: PUSH
2064: LD_VAR 0 2
2068: PUSH
2069: LD_EXP 26
2073: ADD
2074: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
2075: LD_ADDR_EXP 24
2079: PUSH
2080: LD_STRING Dolgov
2082: PPUSH
2083: LD_EXP 1
2087: NOT
2088: PPUSH
2089: LD_STRING 13a_
2091: PPUSH
2092: CALL 490 0 3
2096: ST_TO_ADDR
// if Dolgov then
2097: LD_EXP 24
2101: IFFALSE 2119
// tmp := tmp ^ Dolgov ;
2103: LD_ADDR_VAR 0 2
2107: PUSH
2108: LD_VAR 0 2
2112: PUSH
2113: LD_EXP 24
2117: ADD
2118: ST_TO_ADDR
// for i in tmp do
2119: LD_ADDR_VAR 0 3
2123: PUSH
2124: LD_VAR 0 2
2128: PUSH
2129: FOR_IN
2130: IFFALSE 2155
// PlaceUnitXYR ( i , 160 , 78 , 22 , false ) ;
2132: LD_VAR 0 3
2136: PPUSH
2137: LD_INT 160
2139: PPUSH
2140: LD_INT 78
2142: PPUSH
2143: LD_INT 22
2145: PPUSH
2146: LD_INT 0
2148: PPUSH
2149: CALL_OW 50
2153: GO 2129
2155: POP
2156: POP
// squad1 := tmp ;
2157: LD_ADDR_EXP 37
2161: PUSH
2162: LD_VAR 0 2
2166: ST_TO_ADDR
// tmp := [ ] ;
2167: LD_ADDR_VAR 0 2
2171: PUSH
2172: EMPTY
2173: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrova , ( not debug ) , 13a_ ) ;
2174: LD_ADDR_EXP 30
2178: PUSH
2179: LD_STRING Petrova
2181: PPUSH
2182: LD_EXP 1
2186: NOT
2187: PPUSH
2188: LD_STRING 13a_
2190: PPUSH
2191: CALL 490 0 3
2195: ST_TO_ADDR
// if Petrovova then
2196: LD_EXP 30
2200: IFFALSE 2218
// tmp := tmp ^ Petrovova ;
2202: LD_ADDR_VAR 0 2
2206: PUSH
2207: LD_VAR 0 2
2211: PUSH
2212: LD_EXP 30
2216: ADD
2217: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
2218: LD_ADDR_EXP 23
2222: PUSH
2223: LD_STRING Titov
2225: PPUSH
2226: LD_EXP 1
2230: NOT
2231: PPUSH
2232: LD_STRING 13a_
2234: PPUSH
2235: CALL 490 0 3
2239: ST_TO_ADDR
// if Titov then
2240: LD_EXP 23
2244: IFFALSE 2262
// tmp := tmp ^ Titov ;
2246: LD_ADDR_VAR 0 2
2250: PUSH
2251: LD_VAR 0 2
2255: PUSH
2256: LD_EXP 23
2260: ADD
2261: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2262: LD_ADDR_EXP 33
2266: PUSH
2267: LD_STRING Karamazov
2269: PPUSH
2270: LD_EXP 1
2274: NOT
2275: PPUSH
2276: LD_STRING 13a_
2278: PPUSH
2279: CALL 490 0 3
2283: ST_TO_ADDR
// if Karamazov then
2284: LD_EXP 33
2288: IFFALSE 2306
// tmp := tmp ^ Karamazov ;
2290: LD_ADDR_VAR 0 2
2294: PUSH
2295: LD_VAR 0 2
2299: PUSH
2300: LD_EXP 33
2304: ADD
2305: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
2306: LD_ADDR_EXP 16
2310: PUSH
2311: LD_STRING Frank
2313: PPUSH
2314: LD_EXP 1
2318: NOT
2319: PPUSH
2320: LD_STRING 13a_
2322: PPUSH
2323: CALL 490 0 3
2327: ST_TO_ADDR
// if Frank then
2328: LD_EXP 16
2332: IFFALSE 2350
// tmp := tmp ^ Frank ;
2334: LD_ADDR_VAR 0 2
2338: PUSH
2339: LD_VAR 0 2
2343: PUSH
2344: LD_EXP 16
2348: ADD
2349: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2350: LD_ADDR_EXP 7
2354: PUSH
2355: LD_STRING Donaldson
2357: PPUSH
2358: LD_EXP 1
2362: NOT
2363: PPUSH
2364: LD_STRING 13a_
2366: PPUSH
2367: CALL 490 0 3
2371: ST_TO_ADDR
// if Donaldson then
2372: LD_EXP 7
2376: IFFALSE 2394
// tmp := tmp ^ Donaldson ;
2378: LD_ADDR_VAR 0 2
2382: PUSH
2383: LD_VAR 0 2
2387: PUSH
2388: LD_EXP 7
2392: ADD
2393: ST_TO_ADDR
// for i in tmp do
2394: LD_ADDR_VAR 0 3
2398: PUSH
2399: LD_VAR 0 2
2403: PUSH
2404: FOR_IN
2405: IFFALSE 2445
// begin PlaceUnitXYR ( i , 117 , 8 , 6 , false ) ;
2407: LD_VAR 0 3
2411: PPUSH
2412: LD_INT 117
2414: PPUSH
2415: LD_INT 8
2417: PPUSH
2418: LD_INT 6
2420: PPUSH
2421: LD_INT 0
2423: PPUSH
2424: CALL_OW 50
// ComTurnXY ( i , 117 , 8 ) ;
2428: LD_VAR 0 3
2432: PPUSH
2433: LD_INT 117
2435: PPUSH
2436: LD_INT 8
2438: PPUSH
2439: CALL_OW 118
// end ;
2443: GO 2404
2445: POP
2446: POP
// squad2 := tmp ;
2447: LD_ADDR_EXP 38
2451: PUSH
2452: LD_VAR 0 2
2456: ST_TO_ADDR
// uc_side := 0 ;
2457: LD_ADDR_OWVAR 20
2461: PUSH
2462: LD_INT 0
2464: ST_TO_ADDR
// uc_nation := 0 ;
2465: LD_ADDR_OWVAR 21
2469: PUSH
2470: LD_INT 0
2472: ST_TO_ADDR
// InitHc ;
2473: CALL_OW 19
// hc_importance := 0 ;
2477: LD_ADDR_OWVAR 32
2481: PUSH
2482: LD_INT 0
2484: ST_TO_ADDR
// hc_name := Find some goods! ;
2485: LD_ADDR_OWVAR 26
2489: PUSH
2490: LD_STRING Find some goods!
2492: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
2493: LD_INT 0
2495: PPUSH
2496: LD_INT 12
2498: PPUSH
2499: LD_INT 1
2501: PPUSH
2502: CALL_OW 380
// PlaceUnitXY ( CreateHuman , 96 , 108 , false ) ;
2506: CALL_OW 44
2510: PPUSH
2511: LD_INT 96
2513: PPUSH
2514: LD_INT 108
2516: PPUSH
2517: LD_INT 0
2519: PPUSH
2520: CALL_OW 48
// InitHc ;
2524: CALL_OW 19
// end ;
2528: LD_VAR 0 1
2532: RET
// every 3 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 0 ] ] ) do var Louis , veh ;
2533: LD_INT 22
2535: PUSH
2536: LD_INT 7
2538: PUSH
2539: EMPTY
2540: LIST
2541: LIST
2542: PUSH
2543: LD_INT 23
2545: PUSH
2546: LD_INT 0
2548: PUSH
2549: EMPTY
2550: LIST
2551: LIST
2552: PUSH
2553: EMPTY
2554: LIST
2555: LIST
2556: PPUSH
2557: CALL_OW 69
2561: IFFALSE 3026
2563: GO 2565
2565: DISABLE
2566: LD_INT 0
2568: PPUSH
2569: PPUSH
// begin InGameOn ;
2570: CALL_OW 8
// RemoveUnit ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 0 ] ] ) [ 1 ] ) ;
2574: LD_INT 22
2576: PUSH
2577: LD_INT 7
2579: PUSH
2580: EMPTY
2581: LIST
2582: LIST
2583: PUSH
2584: LD_INT 23
2586: PUSH
2587: LD_INT 0
2589: PUSH
2590: EMPTY
2591: LIST
2592: LIST
2593: PUSH
2594: EMPTY
2595: LIST
2596: LIST
2597: PPUSH
2598: CALL_OW 69
2602: PUSH
2603: LD_INT 1
2605: ARRAY
2606: PPUSH
2607: CALL_OW 64
// game_speed := 4 ;
2611: LD_ADDR_OWVAR 65
2615: PUSH
2616: LD_INT 4
2618: ST_TO_ADDR
// ComMoveXY ( JMM , 93 , 100 ) ;
2619: LD_EXP 2
2623: PPUSH
2624: LD_INT 93
2626: PPUSH
2627: LD_INT 100
2629: PPUSH
2630: CALL_OW 111
// ComMoveXY ( Burlak , 93 , 99 ) ;
2634: LD_EXP 3
2638: PPUSH
2639: LD_INT 93
2641: PPUSH
2642: LD_INT 99
2644: PPUSH
2645: CALL_OW 111
// AddComTurnXY ( [ JMM , Burlak ] , 81 , 112 ) ;
2649: LD_EXP 2
2653: PUSH
2654: LD_EXP 3
2658: PUSH
2659: EMPTY
2660: LIST
2661: LIST
2662: PPUSH
2663: LD_INT 81
2665: PPUSH
2666: LD_INT 112
2668: PPUSH
2669: CALL_OW 178
// wait ( 0 0$5 ) ;
2673: LD_INT 175
2675: PPUSH
2676: CALL_OW 67
// music_nat := 2 ;
2680: LD_ADDR_OWVAR 71
2684: PUSH
2685: LD_INT 2
2687: ST_TO_ADDR
// music_class := 4 ;
2688: LD_ADDR_OWVAR 72
2692: PUSH
2693: LD_INT 4
2695: ST_TO_ADDR
// CenterNowOnXY ( 80 , 130 ) ;
2696: LD_INT 80
2698: PPUSH
2699: LD_INT 130
2701: PPUSH
2702: CALL_OW 86
// uc_nation := 2 ;
2706: LD_ADDR_OWVAR 21
2710: PUSH
2711: LD_INT 2
2713: ST_TO_ADDR
// uc_side := 2 ;
2714: LD_ADDR_OWVAR 20
2718: PUSH
2719: LD_INT 2
2721: ST_TO_ADDR
// hc_gallery = sandar ;
2722: LD_ADDR_OWVAR 33
2726: PUSH
2727: LD_STRING sandar
2729: ST_TO_ADDR
// hc_face_number = 1 ;
2730: LD_ADDR_OWVAR 34
2734: PUSH
2735: LD_INT 1
2737: ST_TO_ADDR
// hc_name = Louis Schulz ;
2738: LD_ADDR_OWVAR 26
2742: PUSH
2743: LD_STRING Louis Schulz
2745: ST_TO_ADDR
// hc_attr = [ 13 , 11 ] ;
2746: LD_ADDR_OWVAR 29
2750: PUSH
2751: LD_INT 13
2753: PUSH
2754: LD_INT 11
2756: PUSH
2757: EMPTY
2758: LIST
2759: LIST
2760: ST_TO_ADDR
// hc_basic_skills = [ 0 , 0 , 0 , 0 ] ;
2761: LD_ADDR_OWVAR 30
2765: PUSH
2766: LD_INT 0
2768: PUSH
2769: LD_INT 0
2771: PUSH
2772: LD_INT 0
2774: PUSH
2775: LD_INT 0
2777: PUSH
2778: EMPTY
2779: LIST
2780: LIST
2781: LIST
2782: LIST
2783: ST_TO_ADDR
// hc_skills = [ 10 , 6 , 7 , 7 ] ;
2784: LD_ADDR_OWVAR 31
2788: PUSH
2789: LD_INT 10
2791: PUSH
2792: LD_INT 6
2794: PUSH
2795: LD_INT 7
2797: PUSH
2798: LD_INT 7
2800: PUSH
2801: EMPTY
2802: LIST
2803: LIST
2804: LIST
2805: LIST
2806: ST_TO_ADDR
// hc_sex = sex_male ;
2807: LD_ADDR_OWVAR 27
2811: PUSH
2812: LD_INT 1
2814: ST_TO_ADDR
// hc_class = 1 ;
2815: LD_ADDR_OWVAR 28
2819: PUSH
2820: LD_INT 1
2822: ST_TO_ADDR
// hc_importance = 100 ;
2823: LD_ADDR_OWVAR 32
2827: PUSH
2828: LD_INT 100
2830: ST_TO_ADDR
// Louis = CreateHuman ;
2831: LD_ADDR_VAR 0 1
2835: PUSH
2836: CALL_OW 44
2840: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_flame_thrower , 100 ) ;
2841: LD_INT 14
2843: PPUSH
2844: LD_INT 3
2846: PPUSH
2847: LD_INT 1
2849: PPUSH
2850: LD_INT 26
2852: PPUSH
2853: LD_INT 100
2855: PPUSH
2856: CALL 553 0 5
// veh := CreateVehicle ;
2860: LD_ADDR_VAR 0 2
2864: PUSH
2865: CALL_OW 45
2869: ST_TO_ADDR
// SetMark ( veh , - 2 ) ;
2870: LD_VAR 0 2
2874: PPUSH
2875: LD_INT 2
2877: NEG
2878: PPUSH
2879: CALL_OW 242
// PlaceUnitXY ( veh , 80 , 130 , false ) ;
2883: LD_VAR 0 2
2887: PPUSH
2888: LD_INT 80
2890: PPUSH
2891: LD_INT 130
2893: PPUSH
2894: LD_INT 0
2896: PPUSH
2897: CALL_OW 48
// PlaceHumanInUnit ( Louis , veh ) ;
2901: LD_VAR 0 1
2905: PPUSH
2906: LD_VAR 0 2
2910: PPUSH
2911: CALL_OW 52
// ComMoveXY ( Louis , 80 , 109 ) ;
2915: LD_VAR 0 1
2919: PPUSH
2920: LD_INT 80
2922: PPUSH
2923: LD_INT 109
2925: PPUSH
2926: CALL_OW 111
// AddComExitVehicle ( Louis ) ;
2930: LD_VAR 0 1
2934: PPUSH
2935: CALL_OW 181
// AddComMoveXY ( Louis , 80 , 131 ) ;
2939: LD_VAR 0 1
2943: PPUSH
2944: LD_INT 80
2946: PPUSH
2947: LD_INT 131
2949: PPUSH
2950: CALL_OW 171
// wait ( 0 0$06 ) ;
2954: LD_INT 210
2956: PPUSH
2957: CALL_OW 67
// InGameOff ;
2961: CALL_OW 9
// repeat wait ( 0 0$1 ) ;
2965: LD_INT 35
2967: PPUSH
2968: CALL_OW 67
// until IsAt ( Louis , 80 , 131 ) ;
2972: LD_VAR 0 1
2976: PPUSH
2977: LD_INT 80
2979: PPUSH
2980: LD_INT 131
2982: PPUSH
2983: CALL_OW 307
2987: IFFALSE 2965
// SetSide ( veh , 7 ) ;
2989: LD_VAR 0 2
2993: PPUSH
2994: LD_INT 7
2996: PPUSH
2997: CALL_OW 235
// RemoveUnit ( Louis ) ;
3001: LD_VAR 0 1
3005: PPUSH
3006: CALL_OW 64
// music_nat := 3 ;
3010: LD_ADDR_OWVAR 71
3014: PUSH
3015: LD_INT 3
3017: ST_TO_ADDR
// music_class := 0 ;
3018: LD_ADDR_OWVAR 72
3022: PUSH
3023: LD_INT 0
3025: ST_TO_ADDR
// end ;
3026: PPOPN 2
3028: END
// every 0 0$10 trigger squad1 do var i , xy ;
3029: LD_EXP 37
3033: IFFALSE 3396
3035: GO 3037
3037: DISABLE
3038: LD_INT 0
3040: PPUSH
3041: PPUSH
// begin enable ;
3042: ENABLE
// i := squad1 [ rand ( 1 , squad1 ) ] ;
3043: LD_ADDR_VAR 0 1
3047: PUSH
3048: LD_EXP 37
3052: PUSH
3053: LD_INT 1
3055: PPUSH
3056: LD_EXP 37
3060: PPUSH
3061: CALL_OW 12
3065: ARRAY
3066: ST_TO_ADDR
// if IsInUnit ( i ) then
3067: LD_VAR 0 1
3071: PPUSH
3072: CALL_OW 310
3076: IFFALSE 3080
// exit ;
3078: GO 3396
// ComRemember ( i ) ;
3080: LD_VAR 0 1
3084: PPUSH
3085: CALL_OW 143
// xy := [ ShiftX ( GetX ( i ) , rand ( 0 , 5 ) , rand ( 2 , 7 ) ) , ShiftY ( GetY ( i ) , rand ( 0 , 5 ) , rand ( 2 , 7 ) ) ] ;
3089: LD_ADDR_VAR 0 2
3093: PUSH
3094: LD_VAR 0 1
3098: PPUSH
3099: CALL_OW 250
3103: PPUSH
3104: LD_INT 0
3106: PPUSH
3107: LD_INT 5
3109: PPUSH
3110: CALL_OW 12
3114: PPUSH
3115: LD_INT 2
3117: PPUSH
3118: LD_INT 7
3120: PPUSH
3121: CALL_OW 12
3125: PPUSH
3126: CALL_OW 272
3130: PUSH
3131: LD_VAR 0 1
3135: PPUSH
3136: CALL_OW 251
3140: PPUSH
3141: LD_INT 0
3143: PPUSH
3144: LD_INT 5
3146: PPUSH
3147: CALL_OW 12
3151: PPUSH
3152: LD_INT 2
3154: PPUSH
3155: LD_INT 7
3157: PPUSH
3158: CALL_OW 12
3162: PPUSH
3163: CALL_OW 273
3167: PUSH
3168: EMPTY
3169: LIST
3170: LIST
3171: ST_TO_ADDR
// if HexInfo ( xy [ 1 ] , xy [ 2 ] ) <> 0 or not ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
3172: LD_VAR 0 2
3176: PUSH
3177: LD_INT 1
3179: ARRAY
3180: PPUSH
3181: LD_VAR 0 2
3185: PUSH
3186: LD_INT 2
3188: ARRAY
3189: PPUSH
3190: CALL_OW 428
3194: PUSH
3195: LD_INT 0
3197: NONEQUAL
3198: PUSH
3199: LD_VAR 0 2
3203: PUSH
3204: LD_INT 1
3206: ARRAY
3207: PPUSH
3208: LD_VAR 0 2
3212: PUSH
3213: LD_INT 2
3215: ARRAY
3216: PPUSH
3217: CALL_OW 488
3221: NOT
3222: OR
3223: IFFALSE 3227
// exit ;
3225: GO 3396
// AddComMoveXY ( i , xy [ 1 ] , xy [ 2 ] ) ;
3227: LD_VAR 0 1
3231: PPUSH
3232: LD_VAR 0 2
3236: PUSH
3237: LD_INT 1
3239: ARRAY
3240: PPUSH
3241: LD_VAR 0 2
3245: PUSH
3246: LD_INT 2
3248: ARRAY
3249: PPUSH
3250: CALL_OW 171
// AddComWait ( i , 0 0$10 ) ;
3254: LD_VAR 0 1
3258: PPUSH
3259: LD_INT 350
3261: PPUSH
3262: CALL_OW 202
// if Prob ( 60 ) and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) then
3266: LD_INT 60
3268: PPUSH
3269: CALL_OW 13
3273: PUSH
3274: LD_INT 22
3276: PUSH
3277: LD_INT 4
3279: PUSH
3280: EMPTY
3281: LIST
3282: LIST
3283: PUSH
3284: LD_INT 21
3286: PUSH
3287: LD_INT 3
3289: PUSH
3290: EMPTY
3291: LIST
3292: LIST
3293: PUSH
3294: EMPTY
3295: LIST
3296: LIST
3297: PPUSH
3298: CALL_OW 69
3302: AND
3303: IFFALSE 3387
// begin AddComEnterUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , i ) ) ;
3305: LD_VAR 0 1
3309: PPUSH
3310: LD_INT 22
3312: PUSH
3313: LD_INT 4
3315: PUSH
3316: EMPTY
3317: LIST
3318: LIST
3319: PUSH
3320: LD_INT 21
3322: PUSH
3323: LD_INT 3
3325: PUSH
3326: EMPTY
3327: LIST
3328: LIST
3329: PUSH
3330: EMPTY
3331: LIST
3332: LIST
3333: PPUSH
3334: CALL_OW 69
3338: PPUSH
3339: LD_VAR 0 1
3343: PPUSH
3344: CALL_OW 74
3348: PPUSH
3349: CALL_OW 180
// repeat wait ( 0 0$30 ) ;
3353: LD_INT 1050
3355: PPUSH
3356: CALL_OW 67
// until IsInUnit ( i ) ;
3360: LD_VAR 0 1
3364: PPUSH
3365: CALL_OW 310
3369: IFFALSE 3353
// wait ( 0 0$30 ) ;
3371: LD_INT 1050
3373: PPUSH
3374: CALL_OW 67
// AddComExitBuilding ( i ) ;
3378: LD_VAR 0 1
3382: PPUSH
3383: CALL_OW 182
// end ; AddComReturn ( i ) ;
3387: LD_VAR 0 1
3391: PPUSH
3392: CALL_OW 204
// end ; end_of_file
3396: PPOPN 2
3398: END
// export function Action ; begin
3399: LD_INT 0
3401: PPUSH
// InGameOn ;
3402: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
3406: LD_EXP 2
3410: PPUSH
3411: CALL_OW 87
// Say ( JMM , D1-JMM-1 ) ;
3415: LD_EXP 2
3419: PPUSH
3420: LD_STRING D1-JMM-1
3422: PPUSH
3423: CALL_OW 88
// Say ( Burlak , D1-Bur-1 ) ;
3427: LD_EXP 3
3431: PPUSH
3432: LD_STRING D1-Bur-1
3434: PPUSH
3435: CALL_OW 88
// Say ( JMM , D1-JMM-2 ) ;
3439: LD_EXP 2
3443: PPUSH
3444: LD_STRING D1-JMM-2
3446: PPUSH
3447: CALL_OW 88
// Say ( Burlak , D1-Bur-2 ) ;
3451: LD_EXP 3
3455: PPUSH
3456: LD_STRING D1-Bur-2
3458: PPUSH
3459: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
3463: LD_EXP 2
3467: PPUSH
3468: LD_STRING D1-JMM-3
3470: PPUSH
3471: CALL_OW 88
// Say ( Burlak , D1-Bur-3 ) ;
3475: LD_EXP 3
3479: PPUSH
3480: LD_STRING D1-Bur-3
3482: PPUSH
3483: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
3487: LD_EXP 2
3491: PPUSH
3492: LD_STRING D1-JMM-4
3494: PPUSH
3495: CALL_OW 88
// Say ( Burlak , D1-Bur-4 ) ;
3499: LD_EXP 3
3503: PPUSH
3504: LD_STRING D1-Bur-4
3506: PPUSH
3507: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
3511: LD_EXP 2
3515: PPUSH
3516: LD_STRING D1-JMM-5
3518: PPUSH
3519: CALL_OW 88
// Say ( Burlak , D1-Bur-5 ) ;
3523: LD_EXP 3
3527: PPUSH
3528: LD_STRING D1-Bur-5
3530: PPUSH
3531: CALL_OW 88
// Say ( JMM , D1-JMM-6 ) ;
3535: LD_EXP 2
3539: PPUSH
3540: LD_STRING D1-JMM-6
3542: PPUSH
3543: CALL_OW 88
// Say ( Burlak , D1-Bur-6 ) ;
3547: LD_EXP 3
3551: PPUSH
3552: LD_STRING D1-Bur-6
3554: PPUSH
3555: CALL_OW 88
// Say ( JMM , D1-JMM-7 ) ;
3559: LD_EXP 2
3563: PPUSH
3564: LD_STRING D1-JMM-7
3566: PPUSH
3567: CALL_OW 88
// wait ( 20 ) ;
3571: LD_INT 20
3573: PPUSH
3574: CALL_OW 67
// Query ( QTruck ) ;
3578: LD_STRING QTruck
3580: PPUSH
3581: CALL_OW 97
// InGameOff ;
3585: CALL_OW 9
// ChangeMissionObjectives ( MArtPickup ) ;
3589: LD_STRING MArtPickup
3591: PPUSH
3592: CALL_OW 337
// SetAreaMapShow ( escape_area , 1 ) ;
3596: LD_INT 2
3598: PPUSH
3599: LD_INT 1
3601: PPUSH
3602: CALL_OW 424
// end ;
3606: LD_VAR 0 1
3610: RET
// every 0 0$3 trigger FilterUnitsInArea ( escape_area , [ [ f_type , unit_vehicle ] , [ f_control , control_manual ] , [ f_not , [ f_empty ] ] ] ) = 2 and IsInUnit ( JMM ) and IsInUnit ( Burlak ) and ( GetWeapon ( IsInUnit ( JMM ) ) in [ ru_cargo_bay , us_cargo_bay , ru_big_cargo_bay , ar_cargo_bay ] or GetWeapon ( IsInUnit ( Burlak ) ) in [ ru_cargo_bay , us_cargo_bay , ru_big_cargo_bay , ar_cargo_bay ] ) do var i , macmilanVeh , burlakVeh ;
3611: LD_INT 2
3613: PPUSH
3614: LD_INT 21
3616: PUSH
3617: LD_INT 2
3619: PUSH
3620: EMPTY
3621: LIST
3622: LIST
3623: PUSH
3624: LD_INT 33
3626: PUSH
3627: LD_INT 1
3629: PUSH
3630: EMPTY
3631: LIST
3632: LIST
3633: PUSH
3634: LD_INT 3
3636: PUSH
3637: LD_INT 58
3639: PUSH
3640: EMPTY
3641: LIST
3642: PUSH
3643: EMPTY
3644: LIST
3645: LIST
3646: PUSH
3647: EMPTY
3648: LIST
3649: LIST
3650: LIST
3651: PPUSH
3652: CALL_OW 70
3656: PUSH
3657: LD_INT 2
3659: EQUAL
3660: PUSH
3661: LD_EXP 2
3665: PPUSH
3666: CALL_OW 310
3670: AND
3671: PUSH
3672: LD_EXP 3
3676: PPUSH
3677: CALL_OW 310
3681: AND
3682: PUSH
3683: LD_EXP 2
3687: PPUSH
3688: CALL_OW 310
3692: PPUSH
3693: CALL_OW 264
3697: PUSH
3698: LD_INT 51
3700: PUSH
3701: LD_INT 12
3703: PUSH
3704: LD_EXP 40
3708: PUSH
3709: LD_INT 32
3711: PUSH
3712: EMPTY
3713: LIST
3714: LIST
3715: LIST
3716: LIST
3717: IN
3718: PUSH
3719: LD_EXP 3
3723: PPUSH
3724: CALL_OW 310
3728: PPUSH
3729: CALL_OW 264
3733: PUSH
3734: LD_INT 51
3736: PUSH
3737: LD_INT 12
3739: PUSH
3740: LD_EXP 40
3744: PUSH
3745: LD_INT 32
3747: PUSH
3748: EMPTY
3749: LIST
3750: LIST
3751: LIST
3752: LIST
3753: IN
3754: OR
3755: AND
3756: IFFALSE 3966
3758: GO 3760
3760: DISABLE
3761: LD_INT 0
3763: PPUSH
3764: PPUSH
3765: PPUSH
// begin macmilanVeh := IsInUnit ( JMM ) ;
3766: LD_ADDR_VAR 0 2
3770: PUSH
3771: LD_EXP 2
3775: PPUSH
3776: CALL_OW 310
3780: ST_TO_ADDR
// burlakVeh := IsInUnit ( Burlak ) ;
3781: LD_ADDR_VAR 0 3
3785: PUSH
3786: LD_EXP 3
3790: PPUSH
3791: CALL_OW 310
3795: ST_TO_ADDR
// SaveVariable ( [ GetChassis ( macmilanVeh ) , GetEngine ( macmilanVeh ) , control_manual , GetWeapon ( macmilanVeh ) , GetMark ( macmilanVeh ) , GetNation ( macmilanVeh ) ] , 14a_JMMVeh ) ;
3796: LD_VAR 0 2
3800: PPUSH
3801: CALL_OW 265
3805: PUSH
3806: LD_VAR 0 2
3810: PPUSH
3811: CALL_OW 262
3815: PUSH
3816: LD_INT 1
3818: PUSH
3819: LD_VAR 0 2
3823: PPUSH
3824: CALL_OW 264
3828: PUSH
3829: LD_VAR 0 2
3833: PPUSH
3834: CALL_OW 271
3838: PUSH
3839: LD_VAR 0 2
3843: PPUSH
3844: CALL_OW 248
3848: PUSH
3849: EMPTY
3850: LIST
3851: LIST
3852: LIST
3853: LIST
3854: LIST
3855: LIST
3856: PPUSH
3857: LD_STRING 14a_JMMVeh
3859: PPUSH
3860: CALL_OW 39
// SaveVariable ( [ GetChassis ( burlakVeh ) , GetEngine ( burlakVeh ) , control_manual , GetWeapon ( burlakVeh ) , GetMark ( burlakVeh ) , GetNation ( burlakVeh ) ] , 14a_BurlakVeh ) ;
3864: LD_VAR 0 3
3868: PPUSH
3869: CALL_OW 265
3873: PUSH
3874: LD_VAR 0 3
3878: PPUSH
3879: CALL_OW 262
3883: PUSH
3884: LD_INT 1
3886: PUSH
3887: LD_VAR 0 3
3891: PPUSH
3892: CALL_OW 264
3896: PUSH
3897: LD_VAR 0 3
3901: PPUSH
3902: CALL_OW 271
3906: PUSH
3907: LD_VAR 0 3
3911: PPUSH
3912: CALL_OW 248
3916: PUSH
3917: EMPTY
3918: LIST
3919: LIST
3920: LIST
3921: LIST
3922: LIST
3923: LIST
3924: PPUSH
3925: LD_STRING 14a_BurlakVeh
3927: PPUSH
3928: CALL_OW 39
// SaveCharacters ( JMM , 14a_JMM ) ;
3932: LD_EXP 2
3936: PPUSH
3937: LD_STRING 14a_JMM
3939: PPUSH
3940: CALL_OW 38
// SaveCharacters ( Burlak , 14a_Burlak ) ;
3944: LD_EXP 3
3948: PPUSH
3949: LD_STRING 14a_Burlak
3951: PPUSH
3952: CALL_OW 38
// ChangeMap ( 1 , %_cont ) ;
3956: LD_INT 1
3958: PPUSH
3959: LD_STRING %_cont
3961: PPUSH
3962: CALL_OW 340
// end ;
3966: PPOPN 3
3968: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_lives , 950 ] ] ] ) do
3969: LD_INT 22
3971: PUSH
3972: LD_INT 4
3974: PUSH
3975: EMPTY
3976: LIST
3977: LIST
3978: PUSH
3979: LD_INT 3
3981: PUSH
3982: LD_INT 24
3984: PUSH
3985: LD_INT 950
3987: PUSH
3988: EMPTY
3989: LIST
3990: LIST
3991: PUSH
3992: EMPTY
3993: LIST
3994: LIST
3995: PUSH
3996: EMPTY
3997: LIST
3998: LIST
3999: PPUSH
4000: CALL_OW 69
4004: IFFALSE 4016
4006: GO 4008
4008: DISABLE
// YouLost ( FriendlyFire ) ;
4009: LD_STRING FriendlyFire
4011: PPUSH
4012: CALL_OW 104
4016: END
// every 0 0$1 trigger IsDead ( Burlak ) do
4017: LD_EXP 3
4021: PPUSH
4022: CALL_OW 301
4026: IFFALSE 4038
4028: GO 4030
4030: DISABLE
// YouLost ( Burlak ) ;
4031: LD_STRING Burlak
4033: PPUSH
4034: CALL_OW 104
4038: END
// every 0 0$1 trigger IsDead ( JMM ) do
4039: LD_EXP 2
4043: PPUSH
4044: CALL_OW 301
4048: IFFALSE 4060
4050: GO 4052
4052: DISABLE
// YouLost ( JMM ) ; end_of_file
4053: LD_STRING JMM
4055: PPUSH
4056: CALL_OW 104
4060: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
4061: GO 4063
4063: DISABLE
// begin ru_radar := 98 ;
4064: LD_ADDR_EXP 39
4068: PUSH
4069: LD_INT 98
4071: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
4072: LD_ADDR_EXP 40
4076: PUSH
4077: LD_INT 89
4079: ST_TO_ADDR
// us_hack := 99 ;
4080: LD_ADDR_EXP 41
4084: PUSH
4085: LD_INT 99
4087: ST_TO_ADDR
// us_artillery := 97 ;
4088: LD_ADDR_EXP 42
4092: PUSH
4093: LD_INT 97
4095: ST_TO_ADDR
// ar_bio_bomb := 91 ;
4096: LD_ADDR_EXP 43
4100: PUSH
4101: LD_INT 91
4103: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
4104: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
4105: LD_INT 0
4107: PPUSH
4108: PPUSH
4109: PPUSH
4110: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
4111: LD_VAR 0 1
4115: PPUSH
4116: CALL_OW 264
4120: PUSH
4121: LD_EXP 43
4125: EQUAL
4126: IFFALSE 4198
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
4128: LD_INT 68
4130: PPUSH
4131: LD_VAR 0 1
4135: PPUSH
4136: CALL_OW 255
4140: PPUSH
4141: CALL_OW 321
4145: PUSH
4146: LD_INT 2
4148: EQUAL
4149: IFFALSE 4161
// eff := 70 else
4151: LD_ADDR_VAR 0 6
4155: PUSH
4156: LD_INT 70
4158: ST_TO_ADDR
4159: GO 4169
// eff := 30 ;
4161: LD_ADDR_VAR 0 6
4165: PUSH
4166: LD_INT 30
4168: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
4169: LD_VAR 0 1
4173: PPUSH
4174: CALL_OW 250
4178: PPUSH
4179: LD_VAR 0 1
4183: PPUSH
4184: CALL_OW 251
4188: PPUSH
4189: LD_VAR 0 6
4193: PPUSH
4194: CALL_OW 495
// end ; end ;
4198: LD_VAR 0 4
4202: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
4203: LD_INT 0
4205: PPUSH
4206: PPUSH
4207: PPUSH
4208: PPUSH
4209: PPUSH
4210: PPUSH
// if cmd = 124 then
4211: LD_VAR 0 1
4215: PUSH
4216: LD_INT 124
4218: EQUAL
4219: IFFALSE 4425
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
4221: LD_ADDR_VAR 0 5
4225: PUSH
4226: LD_INT 2
4228: PUSH
4229: LD_INT 34
4231: PUSH
4232: LD_INT 53
4234: PUSH
4235: EMPTY
4236: LIST
4237: LIST
4238: PUSH
4239: LD_INT 34
4241: PUSH
4242: LD_INT 14
4244: PUSH
4245: EMPTY
4246: LIST
4247: LIST
4248: PUSH
4249: EMPTY
4250: LIST
4251: LIST
4252: LIST
4253: PPUSH
4254: CALL_OW 69
4258: ST_TO_ADDR
// if not tmp then
4259: LD_VAR 0 5
4263: NOT
4264: IFFALSE 4268
// exit ;
4266: GO 4425
// for i in tmp do
4268: LD_ADDR_VAR 0 3
4272: PUSH
4273: LD_VAR 0 5
4277: PUSH
4278: FOR_IN
4279: IFFALSE 4423
// begin taskList := GetTaskList ( i ) ;
4281: LD_ADDR_VAR 0 6
4285: PUSH
4286: LD_VAR 0 3
4290: PPUSH
4291: CALL_OW 437
4295: ST_TO_ADDR
// if not taskList then
4296: LD_VAR 0 6
4300: NOT
4301: IFFALSE 4305
// continue ;
4303: GO 4278
// for j = 1 to taskList do
4305: LD_ADDR_VAR 0 4
4309: PUSH
4310: DOUBLE
4311: LD_INT 1
4313: DEC
4314: ST_TO_ADDR
4315: LD_VAR 0 6
4319: PUSH
4320: FOR_TO
4321: IFFALSE 4419
// if taskList [ j ] [ 1 ] = | then
4323: LD_VAR 0 6
4327: PUSH
4328: LD_VAR 0 4
4332: ARRAY
4333: PUSH
4334: LD_INT 1
4336: ARRAY
4337: PUSH
4338: LD_STRING |
4340: EQUAL
4341: IFFALSE 4417
// begin _taskList := Delete ( taskList , 1 ) ;
4343: LD_ADDR_VAR 0 7
4347: PUSH
4348: LD_VAR 0 6
4352: PPUSH
4353: LD_INT 1
4355: PPUSH
4356: CALL_OW 3
4360: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
4361: LD_VAR 0 3
4365: PPUSH
4366: LD_VAR 0 7
4370: PPUSH
4371: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
4375: LD_VAR 0 3
4379: PPUSH
4380: LD_VAR 0 6
4384: PUSH
4385: LD_VAR 0 4
4389: ARRAY
4390: PUSH
4391: LD_INT 2
4393: ARRAY
4394: PPUSH
4395: LD_VAR 0 6
4399: PUSH
4400: LD_VAR 0 4
4404: ARRAY
4405: PUSH
4406: LD_INT 3
4408: ARRAY
4409: PPUSH
4410: LD_INT 8
4412: PPUSH
4413: CALL 4430 0 4
// end ;
4417: GO 4320
4419: POP
4420: POP
// end ;
4421: GO 4278
4423: POP
4424: POP
// end ; end ;
4425: LD_VAR 0 2
4429: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
4430: LD_INT 0
4432: PPUSH
4433: PPUSH
4434: PPUSH
4435: PPUSH
4436: PPUSH
4437: PPUSH
4438: PPUSH
4439: PPUSH
4440: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
4441: LD_VAR 0 1
4445: NOT
4446: PUSH
4447: LD_VAR 0 2
4451: PPUSH
4452: LD_VAR 0 3
4456: PPUSH
4457: CALL_OW 488
4461: NOT
4462: OR
4463: PUSH
4464: LD_VAR 0 4
4468: NOT
4469: OR
4470: IFFALSE 4474
// exit ;
4472: GO 4814
// list := [ ] ;
4474: LD_ADDR_VAR 0 13
4478: PUSH
4479: EMPTY
4480: ST_TO_ADDR
// if x - r < 0 then
4481: LD_VAR 0 2
4485: PUSH
4486: LD_VAR 0 4
4490: MINUS
4491: PUSH
4492: LD_INT 0
4494: LESS
4495: IFFALSE 4507
// min_x := 0 else
4497: LD_ADDR_VAR 0 7
4501: PUSH
4502: LD_INT 0
4504: ST_TO_ADDR
4505: GO 4523
// min_x := x - r ;
4507: LD_ADDR_VAR 0 7
4511: PUSH
4512: LD_VAR 0 2
4516: PUSH
4517: LD_VAR 0 4
4521: MINUS
4522: ST_TO_ADDR
// if y - r < 0 then
4523: LD_VAR 0 3
4527: PUSH
4528: LD_VAR 0 4
4532: MINUS
4533: PUSH
4534: LD_INT 0
4536: LESS
4537: IFFALSE 4549
// min_y := 0 else
4539: LD_ADDR_VAR 0 8
4543: PUSH
4544: LD_INT 0
4546: ST_TO_ADDR
4547: GO 4565
// min_y := y - r ;
4549: LD_ADDR_VAR 0 8
4553: PUSH
4554: LD_VAR 0 3
4558: PUSH
4559: LD_VAR 0 4
4563: MINUS
4564: ST_TO_ADDR
// max_x := x + r ;
4565: LD_ADDR_VAR 0 9
4569: PUSH
4570: LD_VAR 0 2
4574: PUSH
4575: LD_VAR 0 4
4579: PLUS
4580: ST_TO_ADDR
// max_y := y + r ;
4581: LD_ADDR_VAR 0 10
4585: PUSH
4586: LD_VAR 0 3
4590: PUSH
4591: LD_VAR 0 4
4595: PLUS
4596: ST_TO_ADDR
// for _x = min_x to max_x do
4597: LD_ADDR_VAR 0 11
4601: PUSH
4602: DOUBLE
4603: LD_VAR 0 7
4607: DEC
4608: ST_TO_ADDR
4609: LD_VAR 0 9
4613: PUSH
4614: FOR_TO
4615: IFFALSE 4732
// for _y = min_y to max_y do
4617: LD_ADDR_VAR 0 12
4621: PUSH
4622: DOUBLE
4623: LD_VAR 0 8
4627: DEC
4628: ST_TO_ADDR
4629: LD_VAR 0 10
4633: PUSH
4634: FOR_TO
4635: IFFALSE 4728
// begin if not ValidHex ( _x , _y ) then
4637: LD_VAR 0 11
4641: PPUSH
4642: LD_VAR 0 12
4646: PPUSH
4647: CALL_OW 488
4651: NOT
4652: IFFALSE 4656
// continue ;
4654: GO 4634
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
4656: LD_VAR 0 11
4660: PPUSH
4661: LD_VAR 0 12
4665: PPUSH
4666: CALL_OW 351
4670: PUSH
4671: LD_VAR 0 11
4675: PPUSH
4676: LD_VAR 0 12
4680: PPUSH
4681: CALL_OW 554
4685: AND
4686: IFFALSE 4726
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
4688: LD_ADDR_VAR 0 13
4692: PUSH
4693: LD_VAR 0 13
4697: PPUSH
4698: LD_VAR 0 13
4702: PUSH
4703: LD_INT 1
4705: PLUS
4706: PPUSH
4707: LD_VAR 0 11
4711: PUSH
4712: LD_VAR 0 12
4716: PUSH
4717: EMPTY
4718: LIST
4719: LIST
4720: PPUSH
4721: CALL_OW 2
4725: ST_TO_ADDR
// end ;
4726: GO 4634
4728: POP
4729: POP
4730: GO 4614
4732: POP
4733: POP
// if not list then
4734: LD_VAR 0 13
4738: NOT
4739: IFFALSE 4743
// exit ;
4741: GO 4814
// for i in list do
4743: LD_ADDR_VAR 0 6
4747: PUSH
4748: LD_VAR 0 13
4752: PUSH
4753: FOR_IN
4754: IFFALSE 4812
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
4756: LD_VAR 0 1
4760: PPUSH
4761: LD_STRING M
4763: PUSH
4764: LD_VAR 0 6
4768: PUSH
4769: LD_INT 1
4771: ARRAY
4772: PUSH
4773: LD_VAR 0 6
4777: PUSH
4778: LD_INT 2
4780: ARRAY
4781: PUSH
4782: LD_INT 0
4784: PUSH
4785: LD_INT 0
4787: PUSH
4788: LD_INT 0
4790: PUSH
4791: LD_INT 0
4793: PUSH
4794: EMPTY
4795: LIST
4796: LIST
4797: LIST
4798: LIST
4799: LIST
4800: LIST
4801: LIST
4802: PUSH
4803: EMPTY
4804: LIST
4805: PPUSH
4806: CALL_OW 447
4810: GO 4753
4812: POP
4813: POP
// end ;
4814: LD_VAR 0 5
4818: RET
