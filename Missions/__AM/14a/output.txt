// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// FogOff ( 7 ) ;
  11: LD_INT 7
  13: PPUSH
  14: CALL_OW 344
// RandomizeAll ;
  18: CALL_OW 11
// InitVariables ;
  22: CALL 66 0 0
// LoadBuildings ;
  26: CALL 94 0 0
// PrepareAlliance ;
  30: CALL 611 0 0
// music_nat := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
  34: LD_ADDR_OWVAR 71
  38: PUSH
  39: LD_INT 1
  41: PUSH
  42: LD_INT 3
  44: PUSH
  45: EMPTY
  46: LIST
  47: LIST
  48: PUSH
  49: LD_INT 1
  51: PPUSH
  52: LD_INT 2
  54: PPUSH
  55: CALL_OW 12
  59: ARRAY
  60: ST_TO_ADDR
// Action ;
  61: CALL 3360 0 0
// end ;
  65: END
// export debug ; export function InitVariables ; begin
  66: LD_INT 0
  68: PPUSH
// debug := false ;
  69: LD_ADDR_EXP 1
  73: PUSH
  74: LD_INT 0
  76: ST_TO_ADDR
// end ;
  77: LD_VAR 0 1
  81: RET
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
  82: LD_VAR 0 1
  86: PPUSH
  87: CALL 4164 0 1
// end ; end_of_file
  91: PPOPN 1
  93: END
// export function LoadBuildings ; var i , tmp , b ; begin
  94: LD_INT 0
  96: PPUSH
  97: PPUSH
  98: PPUSH
  99: PPUSH
// tmp := LoadVariable ( 13a_buildings , [ [ 7 , 1 , b_warehouse , 70 , 46 , 3 , 10 , 0 , 0 , 0 ] ] ) ;
 100: LD_ADDR_VAR 0 3
 104: PUSH
 105: LD_STRING 13a_buildings
 107: PPUSH
 108: LD_INT 7
 110: PUSH
 111: LD_INT 1
 113: PUSH
 114: LD_INT 1
 116: PUSH
 117: LD_INT 70
 119: PUSH
 120: LD_INT 46
 122: PUSH
 123: LD_INT 3
 125: PUSH
 126: LD_INT 10
 128: PUSH
 129: LD_INT 0
 131: PUSH
 132: LD_INT 0
 134: PUSH
 135: LD_INT 0
 137: PUSH
 138: EMPTY
 139: LIST
 140: LIST
 141: LIST
 142: LIST
 143: LIST
 144: LIST
 145: LIST
 146: LIST
 147: LIST
 148: LIST
 149: PUSH
 150: EMPTY
 151: LIST
 152: PPUSH
 153: CALL_OW 30
 157: ST_TO_ADDR
// bc_kind1 := - 1 ;
 158: LD_ADDR_OWVAR 44
 162: PUSH
 163: LD_INT 1
 165: NEG
 166: ST_TO_ADDR
// bc_kind2 := - 1 ;
 167: LD_ADDR_OWVAR 45
 171: PUSH
 172: LD_INT 1
 174: NEG
 175: ST_TO_ADDR
// for i in tmp do
 176: LD_ADDR_VAR 0 2
 180: PUSH
 181: LD_VAR 0 3
 185: PUSH
 186: FOR_IN
 187: IFFALSE 432
// begin uc_side := 7 ;
 189: LD_ADDR_OWVAR 20
 193: PUSH
 194: LD_INT 7
 196: ST_TO_ADDR
// uc_nation := i [ 2 ] ;
 197: LD_ADDR_OWVAR 21
 201: PUSH
 202: LD_VAR 0 2
 206: PUSH
 207: LD_INT 2
 209: ARRAY
 210: ST_TO_ADDR
// if i [ 2 ] = 2 then
 211: LD_VAR 0 2
 215: PUSH
 216: LD_INT 2
 218: ARRAY
 219: PUSH
 220: LD_INT 2
 222: EQUAL
 223: IFFALSE 233
// uc_side := 4 ;
 225: LD_ADDR_OWVAR 20
 229: PUSH
 230: LD_INT 4
 232: ST_TO_ADDR
// bc_type := i [ 3 ] ;
 233: LD_ADDR_OWVAR 42
 237: PUSH
 238: LD_VAR 0 2
 242: PUSH
 243: LD_INT 3
 245: ARRAY
 246: ST_TO_ADDR
// if i [ 3 ] in [ b_oil_mine , b_siberite_mine ] then
 247: LD_VAR 0 2
 251: PUSH
 252: LD_INT 3
 254: ARRAY
 255: PUSH
 256: LD_INT 29
 258: PUSH
 259: LD_INT 30
 261: PUSH
 262: EMPTY
 263: LIST
 264: LIST
 265: IN
 266: IFFALSE 299
// SetResourceVisibility ( i [ 4 ] , i [ 5 ] , i [ 1 ] ) ;
 268: LD_VAR 0 2
 272: PUSH
 273: LD_INT 4
 275: ARRAY
 276: PPUSH
 277: LD_VAR 0 2
 281: PUSH
 282: LD_INT 5
 284: ARRAY
 285: PPUSH
 286: LD_VAR 0 2
 290: PUSH
 291: LD_INT 1
 293: ARRAY
 294: PPUSH
 295: CALL_OW 441
// if i [ 8 ] then
 299: LD_VAR 0 2
 303: PUSH
 304: LD_INT 8
 306: ARRAY
 307: IFFALSE 323
// bc_kind1 := i [ 8 ] ;
 309: LD_ADDR_OWVAR 44
 313: PUSH
 314: LD_VAR 0 2
 318: PUSH
 319: LD_INT 8
 321: ARRAY
 322: ST_TO_ADDR
// if i [ 9 ] then
 323: LD_VAR 0 2
 327: PUSH
 328: LD_INT 9
 330: ARRAY
 331: IFFALSE 347
// bc_kind2 := i [ 9 ] ;
 333: LD_ADDR_OWVAR 45
 337: PUSH
 338: LD_VAR 0 2
 342: PUSH
 343: LD_INT 9
 345: ARRAY
 346: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( i [ 4 ] , i [ 5 ] , i [ 6 ] ) ;
 347: LD_ADDR_VAR 0 4
 351: PUSH
 352: LD_VAR 0 2
 356: PUSH
 357: LD_INT 4
 359: ARRAY
 360: PPUSH
 361: LD_VAR 0 2
 365: PUSH
 366: LD_INT 5
 368: ARRAY
 369: PPUSH
 370: LD_VAR 0 2
 374: PUSH
 375: LD_INT 6
 377: ARRAY
 378: PPUSH
 379: CALL_OW 47
 383: ST_TO_ADDR
// SetBLevel ( b , i [ 7 ] ) ;
 384: LD_VAR 0 4
 388: PPUSH
 389: LD_VAR 0 2
 393: PUSH
 394: LD_INT 7
 396: ARRAY
 397: PPUSH
 398: CALL_OW 241
// if i [ 10 ] then
 402: LD_VAR 0 2
 406: PUSH
 407: LD_INT 10
 409: ARRAY
 410: IFFALSE 430
// PlaceWeaponTurret ( b , i [ 10 ] ) ;
 412: LD_VAR 0 4
 416: PPUSH
 417: LD_VAR 0 2
 421: PUSH
 422: LD_INT 10
 424: ARRAY
 425: PPUSH
 426: CALL_OW 431
// end ;
 430: GO 186
 432: POP
 433: POP
// if HexInfo ( 144 , 65 ) = 0 then
 434: LD_INT 144
 436: PPUSH
 437: LD_INT 65
 439: PPUSH
 440: CALL_OW 428
 444: PUSH
 445: LD_INT 0
 447: EQUAL
 448: IFFALSE 485
// begin uc_side := 4 ;
 450: LD_ADDR_OWVAR 20
 454: PUSH
 455: LD_INT 4
 457: ST_TO_ADDR
// bc_type := b_warehouse ;
 458: LD_ADDR_OWVAR 42
 462: PUSH
 463: LD_INT 1
 465: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 144 , 65 , 1 ) ;
 466: LD_ADDR_VAR 0 4
 470: PUSH
 471: LD_INT 144
 473: PPUSH
 474: LD_INT 65
 476: PPUSH
 477: LD_INT 1
 479: PPUSH
 480: CALL_OW 47
 484: ST_TO_ADDR
// end ; end ;
 485: LD_VAR 0 1
 489: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 490: LD_INT 0
 492: PPUSH
 493: PPUSH
// if exist_mode then
 494: LD_VAR 0 2
 498: IFFALSE 523
// unit := CreateCharacter ( prefix & ident ) else
 500: LD_ADDR_VAR 0 5
 504: PUSH
 505: LD_VAR 0 3
 509: PUSH
 510: LD_VAR 0 1
 514: STR
 515: PPUSH
 516: CALL_OW 34
 520: ST_TO_ADDR
 521: GO 538
// unit := NewCharacter ( ident ) ;
 523: LD_ADDR_VAR 0 5
 527: PUSH
 528: LD_VAR 0 1
 532: PPUSH
 533: CALL_OW 25
 537: ST_TO_ADDR
// result := unit ;
 538: LD_ADDR_VAR 0 4
 542: PUSH
 543: LD_VAR 0 5
 547: ST_TO_ADDR
// end ;
 548: LD_VAR 0 4
 552: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
 553: LD_INT 0
 555: PPUSH
// vc_chassis := chassis ;
 556: LD_ADDR_OWVAR 37
 560: PUSH
 561: LD_VAR 0 1
 565: ST_TO_ADDR
// vc_engine := engine ;
 566: LD_ADDR_OWVAR 39
 570: PUSH
 571: LD_VAR 0 2
 575: ST_TO_ADDR
// vc_control := control ;
 576: LD_ADDR_OWVAR 38
 580: PUSH
 581: LD_VAR 0 3
 585: ST_TO_ADDR
// vc_weapon := weapon ;
 586: LD_ADDR_OWVAR 40
 590: PUSH
 591: LD_VAR 0 4
 595: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 596: LD_ADDR_OWVAR 41
 600: PUSH
 601: LD_VAR 0 5
 605: ST_TO_ADDR
// end ; end_of_file
 606: LD_VAR 0 6
 610: RET
// export JMM , Burlak , freedom ; export Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Belkov , Gnyevko , Masha ; export squad1 , squad2 ; export function PrepareAlliance ; var tmp , i , veh ; begin
 611: LD_INT 0
 613: PPUSH
 614: PPUSH
 615: PPUSH
 616: PPUSH
// uc_side := 7 ;
 617: LD_ADDR_OWVAR 20
 621: PUSH
 622: LD_INT 7
 624: ST_TO_ADDR
// uc_nation := 1 ;
 625: LD_ADDR_OWVAR 21
 629: PUSH
 630: LD_INT 1
 632: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 13a_ ) ;
 633: LD_ADDR_EXP 2
 637: PUSH
 638: LD_STRING JMM
 640: PPUSH
 641: LD_EXP 1
 645: NOT
 646: PPUSH
 647: LD_STRING 13a_
 649: PPUSH
 650: CALL 490 0 3
 654: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 13a_ ) ;
 655: LD_ADDR_EXP 3
 659: PUSH
 660: LD_STRING Burlak
 662: PPUSH
 663: LD_EXP 1
 667: NOT
 668: PPUSH
 669: LD_STRING 13a_
 671: PPUSH
 672: CALL 490 0 3
 676: ST_TO_ADDR
// freedom := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_nation , 1 ] , [ f_nation , 3 ] ] , [ f_btype , b_warehouse ] ] ) ;
 677: LD_ADDR_EXP 4
 681: PUSH
 682: LD_INT 22
 684: PUSH
 685: LD_INT 7
 687: PUSH
 688: EMPTY
 689: LIST
 690: LIST
 691: PUSH
 692: LD_INT 2
 694: PUSH
 695: LD_INT 23
 697: PUSH
 698: LD_INT 1
 700: PUSH
 701: EMPTY
 702: LIST
 703: LIST
 704: PUSH
 705: LD_INT 23
 707: PUSH
 708: LD_INT 3
 710: PUSH
 711: EMPTY
 712: LIST
 713: LIST
 714: PUSH
 715: EMPTY
 716: LIST
 717: LIST
 718: LIST
 719: PUSH
 720: LD_INT 30
 722: PUSH
 723: LD_INT 1
 725: PUSH
 726: EMPTY
 727: LIST
 728: LIST
 729: PUSH
 730: EMPTY
 731: LIST
 732: LIST
 733: LIST
 734: PPUSH
 735: CALL_OW 69
 739: ST_TO_ADDR
// if freedom then
 740: LD_EXP 4
 744: IFFALSE 871
// begin freedom := freedom [ 1 ] ;
 746: LD_ADDR_EXP 4
 750: PUSH
 751: LD_EXP 4
 755: PUSH
 756: LD_INT 1
 758: ARRAY
 759: ST_TO_ADDR
// SetBName ( freedom , freedom ) ;
 760: LD_EXP 4
 764: PPUSH
 765: LD_STRING freedom
 767: PPUSH
 768: CALL_OW 500
// CenterNowOnUnits ( freedom ) ;
 772: LD_EXP 4
 776: PPUSH
 777: CALL_OW 87
// PlaceHumanInUnit ( JMM , freedom ) ;
 781: LD_EXP 2
 785: PPUSH
 786: LD_EXP 4
 790: PPUSH
 791: CALL_OW 52
// PlaceHumanInUnit ( Burlak , freedom ) ;
 795: LD_EXP 3
 799: PPUSH
 800: LD_EXP 4
 804: PPUSH
 805: CALL_OW 52
// SetResourceType ( GetBase ( freedom ) , mat_cans , 1000 ) ;
 809: LD_EXP 4
 813: PPUSH
 814: CALL_OW 274
 818: PPUSH
 819: LD_INT 1
 821: PPUSH
 822: LD_INT 1000
 824: PPUSH
 825: CALL_OW 277
// SetResourceType ( GetBase ( freedom ) , mat_oil , 400 ) ;
 829: LD_EXP 4
 833: PPUSH
 834: CALL_OW 274
 838: PPUSH
 839: LD_INT 2
 841: PPUSH
 842: LD_INT 400
 844: PPUSH
 845: CALL_OW 277
// SetResourceType ( GetBase ( freedom ) , mat_siberit , 30 ) ;
 849: LD_EXP 4
 853: PPUSH
 854: CALL_OW 274
 858: PPUSH
 859: LD_INT 3
 861: PPUSH
 862: LD_INT 30
 864: PPUSH
 865: CALL_OW 277
// end else
 869: GO 958
// begin PlaceUnitArea ( JMM , freedom_base , false ) ;
 871: LD_EXP 2
 875: PPUSH
 876: LD_INT 1
 878: PPUSH
 879: LD_INT 0
 881: PPUSH
 882: CALL_OW 49
// PlaceUnitXYR ( Burlak , GetX ( JMM ) , GetY ( JMM ) , 8 , false ) ;
 886: LD_EXP 3
 890: PPUSH
 891: LD_EXP 2
 895: PPUSH
 896: CALL_OW 250
 900: PPUSH
 901: LD_EXP 2
 905: PPUSH
 906: CALL_OW 251
 910: PPUSH
 911: LD_INT 8
 913: PPUSH
 914: LD_INT 0
 916: PPUSH
 917: CALL_OW 50
// ComTurnUnit ( JMM , Burlak ) ;
 921: LD_EXP 2
 925: PPUSH
 926: LD_EXP 3
 930: PPUSH
 931: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
 935: LD_EXP 3
 939: PPUSH
 940: LD_EXP 2
 944: PPUSH
 945: CALL_OW 119
// CenterNowOnUnits ( JMM ) ;
 949: LD_EXP 2
 953: PPUSH
 954: CALL_OW 87
// end ; SetClass ( JMM , 2 ) ;
 958: LD_EXP 2
 962: PPUSH
 963: LD_INT 2
 965: PPUSH
 966: CALL_OW 336
// tmp := [ [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] , [ us_double_gun , us_laser , us_rocket_launcher , us_gatling_gun , us_cargo_bay ] ] ;
 970: LD_ADDR_VAR 0 2
 974: PUSH
 975: LD_INT 2
 977: PUSH
 978: LD_INT 3
 980: PUSH
 981: LD_INT 4
 983: PUSH
 984: LD_INT 5
 986: PUSH
 987: EMPTY
 988: LIST
 989: LIST
 990: LIST
 991: LIST
 992: PUSH
 993: LD_INT 5
 995: PUSH
 996: LD_INT 9
 998: PUSH
 999: LD_INT 7
1001: PUSH
1002: LD_INT 4
1004: PUSH
1005: LD_INT 12
1007: PUSH
1008: EMPTY
1009: LIST
1010: LIST
1011: LIST
1012: LIST
1013: LIST
1014: PUSH
1015: EMPTY
1016: LIST
1017: LIST
1018: ST_TO_ADDR
// for i = 1 to 5 do
1019: LD_ADDR_VAR 0 3
1023: PUSH
1024: DOUBLE
1025: LD_INT 1
1027: DEC
1028: ST_TO_ADDR
1029: LD_INT 5
1031: PUSH
1032: FOR_TO
1033: IFFALSE 1217
// begin PrepareVehicle ( tmp [ 1 ] [ i mod 4 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , tmp [ 2 ] [ i mod 5 + 1 ] , 100 ) ;
1035: LD_VAR 0 2
1039: PUSH
1040: LD_INT 1
1042: ARRAY
1043: PUSH
1044: LD_VAR 0 3
1048: PUSH
1049: LD_INT 4
1051: MOD
1052: PUSH
1053: LD_INT 1
1055: PLUS
1056: ARRAY
1057: PPUSH
1058: LD_INT 1
1060: PUSH
1061: LD_INT 3
1063: PUSH
1064: EMPTY
1065: LIST
1066: LIST
1067: PUSH
1068: LD_INT 1
1070: PPUSH
1071: LD_INT 2
1073: PPUSH
1074: CALL_OW 12
1078: ARRAY
1079: PPUSH
1080: LD_INT 1
1082: PPUSH
1083: LD_VAR 0 2
1087: PUSH
1088: LD_INT 2
1090: ARRAY
1091: PUSH
1092: LD_VAR 0 3
1096: PUSH
1097: LD_INT 5
1099: MOD
1100: PUSH
1101: LD_INT 1
1103: PLUS
1104: ARRAY
1105: PPUSH
1106: LD_INT 100
1108: PPUSH
1109: CALL 553 0 5
// veh := CreateVehicle ;
1113: LD_ADDR_VAR 0 4
1117: PUSH
1118: CALL_OW 45
1122: ST_TO_ADDR
// SetDir ( veh , rand ( 0 , 5 ) ) ;
1123: LD_VAR 0 4
1127: PPUSH
1128: LD_INT 0
1130: PPUSH
1131: LD_INT 5
1133: PPUSH
1134: CALL_OW 12
1138: PPUSH
1139: CALL_OW 233
// if freedom then
1143: LD_EXP 4
1147: IFFALSE 1180
// begin if IsInArea ( freedom , freedom_base ) then
1149: LD_EXP 4
1153: PPUSH
1154: LD_INT 1
1156: PPUSH
1157: CALL_OW 308
1161: IFFALSE 1178
// PlaceUnitArea ( veh , freedom_base , false ) end else
1163: LD_VAR 0 4
1167: PPUSH
1168: LD_INT 1
1170: PPUSH
1171: LD_INT 0
1173: PPUSH
1174: CALL_OW 49
1178: GO 1215
// PlaceUnitXYR ( veh , GetX ( JMM ) , GetY ( JMM ) , 14 , false ) ;
1180: LD_VAR 0 4
1184: PPUSH
1185: LD_EXP 2
1189: PPUSH
1190: CALL_OW 250
1194: PPUSH
1195: LD_EXP 2
1199: PPUSH
1200: CALL_OW 251
1204: PPUSH
1205: LD_INT 14
1207: PPUSH
1208: LD_INT 0
1210: PPUSH
1211: CALL_OW 50
// end ;
1215: GO 1032
1217: POP
1218: POP
// uc_nation := 3 ;
1219: LD_ADDR_OWVAR 21
1223: PUSH
1224: LD_INT 3
1226: ST_TO_ADDR
// tmp := [ [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] ] ;
1227: LD_ADDR_VAR 0 2
1231: PUSH
1232: LD_INT 21
1234: PUSH
1235: LD_INT 22
1237: PUSH
1238: LD_INT 23
1240: PUSH
1241: LD_INT 24
1243: PUSH
1244: EMPTY
1245: LIST
1246: LIST
1247: LIST
1248: LIST
1249: PUSH
1250: LD_INT 43
1252: PUSH
1253: LD_INT 44
1255: PUSH
1256: LD_INT 45
1258: PUSH
1259: EMPTY
1260: LIST
1261: LIST
1262: LIST
1263: PUSH
1264: EMPTY
1265: LIST
1266: LIST
1267: ST_TO_ADDR
// for i = 1 to 5 do
1268: LD_ADDR_VAR 0 3
1272: PUSH
1273: DOUBLE
1274: LD_INT 1
1276: DEC
1277: ST_TO_ADDR
1278: LD_INT 5
1280: PUSH
1281: FOR_TO
1282: IFFALSE 1409
// begin PrepareVehicle ( tmp [ 1 ] [ i mod 4 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , tmp [ 2 ] [ i mod 3 + 1 ] , 100 ) ;
1284: LD_VAR 0 2
1288: PUSH
1289: LD_INT 1
1291: ARRAY
1292: PUSH
1293: LD_VAR 0 3
1297: PUSH
1298: LD_INT 4
1300: MOD
1301: PUSH
1302: LD_INT 1
1304: PLUS
1305: ARRAY
1306: PPUSH
1307: LD_INT 1
1309: PUSH
1310: LD_INT 3
1312: PUSH
1313: EMPTY
1314: LIST
1315: LIST
1316: PUSH
1317: LD_INT 1
1319: PPUSH
1320: LD_INT 2
1322: PPUSH
1323: CALL_OW 12
1327: ARRAY
1328: PPUSH
1329: LD_INT 1
1331: PPUSH
1332: LD_VAR 0 2
1336: PUSH
1337: LD_INT 2
1339: ARRAY
1340: PUSH
1341: LD_VAR 0 3
1345: PUSH
1346: LD_INT 3
1348: MOD
1349: PUSH
1350: LD_INT 1
1352: PLUS
1353: ARRAY
1354: PPUSH
1355: LD_INT 100
1357: PPUSH
1358: CALL 553 0 5
// veh := CreateVehicle ;
1362: LD_ADDR_VAR 0 4
1366: PUSH
1367: CALL_OW 45
1371: ST_TO_ADDR
// SetDir ( veh , rand ( 0 , 5 ) ) ;
1372: LD_VAR 0 4
1376: PPUSH
1377: LD_INT 0
1379: PPUSH
1380: LD_INT 5
1382: PPUSH
1383: CALL_OW 12
1387: PPUSH
1388: CALL_OW 233
// PlaceUnitArea ( veh , freedom_base , false ) ;
1392: LD_VAR 0 4
1396: PPUSH
1397: LD_INT 1
1399: PPUSH
1400: LD_INT 0
1402: PPUSH
1403: CALL_OW 49
// end ;
1407: GO 1281
1409: POP
1410: POP
// if not FilterAllUnits ( [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) then
1411: LD_INT 2
1413: PUSH
1414: LD_INT 34
1416: PUSH
1417: LD_INT 12
1419: PUSH
1420: EMPTY
1421: LIST
1422: LIST
1423: PUSH
1424: LD_INT 34
1426: PUSH
1427: LD_INT 51
1429: PUSH
1430: EMPTY
1431: LIST
1432: LIST
1433: PUSH
1434: EMPTY
1435: LIST
1436: LIST
1437: LIST
1438: PPUSH
1439: CALL_OW 69
1443: NOT
1444: IFFALSE 1510
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 0 ) ;
1446: LD_INT 22
1448: PPUSH
1449: LD_INT 3
1451: PPUSH
1452: LD_INT 1
1454: PPUSH
1455: LD_INT 51
1457: PPUSH
1458: LD_INT 0
1460: PPUSH
1461: CALL 553 0 5
// veh := CreateVehicle ;
1465: LD_ADDR_VAR 0 4
1469: PUSH
1470: CALL_OW 45
1474: ST_TO_ADDR
// SetDir ( veh , rand ( 0 , 5 ) ) ;
1475: LD_VAR 0 4
1479: PPUSH
1480: LD_INT 0
1482: PPUSH
1483: LD_INT 5
1485: PPUSH
1486: CALL_OW 12
1490: PPUSH
1491: CALL_OW 233
// PlaceUnitArea ( veh , freedom_base , false ) ;
1495: LD_VAR 0 4
1499: PPUSH
1500: LD_INT 1
1502: PPUSH
1503: LD_INT 0
1505: PPUSH
1506: CALL_OW 49
// end ; tmp := LoadVariable ( 13a_Masha , [ ] ) ;
1510: LD_ADDR_VAR 0 2
1514: PUSH
1515: LD_STRING 13a_Masha
1517: PPUSH
1518: EMPTY
1519: PPUSH
1520: CALL_OW 30
1524: ST_TO_ADDR
// if tmp then
1525: LD_VAR 0 2
1529: IFFALSE 1611
// begin PrepareVehicle ( tmp [ 1 ] , tmp [ 2 ] , tmp [ 3 ] , tmp [ 4 ] , 100 ) ;
1531: LD_VAR 0 2
1535: PUSH
1536: LD_INT 1
1538: ARRAY
1539: PPUSH
1540: LD_VAR 0 2
1544: PUSH
1545: LD_INT 2
1547: ARRAY
1548: PPUSH
1549: LD_VAR 0 2
1553: PUSH
1554: LD_INT 3
1556: ARRAY
1557: PPUSH
1558: LD_VAR 0 2
1562: PUSH
1563: LD_INT 4
1565: ARRAY
1566: PPUSH
1567: LD_INT 100
1569: PPUSH
1570: CALL 553 0 5
// Masha := CreateVehicle ;
1574: LD_ADDR_EXP 36
1578: PUSH
1579: CALL_OW 45
1583: ST_TO_ADDR
// PlaceUnitArea ( Masha , freedom_base , false ) ;
1584: LD_EXP 36
1588: PPUSH
1589: LD_INT 1
1591: PPUSH
1592: LD_INT 0
1594: PPUSH
1595: CALL_OW 49
// SetMark ( Masha , 1 ) ;
1599: LD_EXP 36
1603: PPUSH
1604: LD_INT 1
1606: PPUSH
1607: CALL_OW 242
// end ; uc_side := 4 ;
1611: LD_ADDR_OWVAR 20
1615: PUSH
1616: LD_INT 4
1618: ST_TO_ADDR
// tmp := [ ] ;
1619: LD_ADDR_VAR 0 2
1623: PUSH
1624: EMPTY
1625: ST_TO_ADDR
// squad1 := [ ] ;
1626: LD_ADDR_EXP 37
1630: PUSH
1631: EMPTY
1632: ST_TO_ADDR
// squad2 := [ ] ;
1633: LD_ADDR_EXP 38
1637: PUSH
1638: EMPTY
1639: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1640: LD_ADDR_EXP 19
1644: PUSH
1645: LD_STRING Joan
1647: PPUSH
1648: LD_EXP 1
1652: NOT
1653: PPUSH
1654: LD_STRING 13a_
1656: PPUSH
1657: CALL 490 0 3
1661: ST_TO_ADDR
// if Joan then
1662: LD_EXP 19
1666: IFFALSE 1684
// tmp := tmp ^ Joan ;
1668: LD_ADDR_VAR 0 2
1672: PUSH
1673: LD_VAR 0 2
1677: PUSH
1678: LD_EXP 19
1682: ADD
1683: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1684: LD_ADDR_EXP 5
1688: PUSH
1689: LD_STRING Roth
1691: PPUSH
1692: LD_EXP 1
1696: NOT
1697: PPUSH
1698: LD_STRING 13a_
1700: PPUSH
1701: CALL 490 0 3
1705: ST_TO_ADDR
// if Roth then
1706: LD_EXP 5
1710: IFFALSE 1728
// tmp := tmp ^ Roth ;
1712: LD_ADDR_VAR 0 2
1716: PUSH
1717: LD_VAR 0 2
1721: PUSH
1722: LD_EXP 5
1726: ADD
1727: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1728: LD_ADDR_EXP 10
1732: PUSH
1733: LD_STRING Denis
1735: PPUSH
1736: LD_EXP 1
1740: NOT
1741: PPUSH
1742: LD_STRING 13a_
1744: PPUSH
1745: CALL 490 0 3
1749: ST_TO_ADDR
// if Denis then
1750: LD_EXP 10
1754: IFFALSE 1772
// tmp := tmp ^ Denis ;
1756: LD_ADDR_VAR 0 2
1760: PUSH
1761: LD_VAR 0 2
1765: PUSH
1766: LD_EXP 10
1770: ADD
1771: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1772: LD_ADDR_EXP 20
1776: PUSH
1777: LD_STRING DeltaDoctor
1779: PPUSH
1780: LD_EXP 1
1784: NOT
1785: PPUSH
1786: LD_STRING 13a_
1788: PPUSH
1789: CALL 490 0 3
1793: ST_TO_ADDR
// if DeltaDoctor then
1794: LD_EXP 20
1798: IFFALSE 1816
// tmp := tmp ^ DeltaDoctor ;
1800: LD_ADDR_VAR 0 2
1804: PUSH
1805: LD_VAR 0 2
1809: PUSH
1810: LD_EXP 20
1814: ADD
1815: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1816: LD_ADDR_EXP 18
1820: PUSH
1821: LD_STRING Simms
1823: PPUSH
1824: LD_EXP 1
1828: NOT
1829: PPUSH
1830: LD_STRING 13a_
1832: PPUSH
1833: CALL 490 0 3
1837: ST_TO_ADDR
// if Simms then
1838: LD_EXP 18
1842: IFFALSE 1860
// tmp := tmp ^ Simms ;
1844: LD_ADDR_VAR 0 2
1848: PUSH
1849: LD_VAR 0 2
1853: PUSH
1854: LD_EXP 18
1858: ADD
1859: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1860: LD_ADDR_EXP 21
1864: PUSH
1865: LD_STRING Gossudarov
1867: PPUSH
1868: LD_EXP 1
1872: NOT
1873: PPUSH
1874: LD_STRING 13a_
1876: PPUSH
1877: CALL 490 0 3
1881: ST_TO_ADDR
// if Gossudarov then
1882: LD_EXP 21
1886: IFFALSE 1904
// tmp := tmp ^ Gossudarov ;
1888: LD_ADDR_VAR 0 2
1892: PUSH
1893: LD_VAR 0 2
1897: PUSH
1898: LD_EXP 21
1902: ADD
1903: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1904: LD_ADDR_EXP 22
1908: PUSH
1909: LD_STRING Kirilenkova
1911: PPUSH
1912: LD_EXP 1
1916: NOT
1917: PPUSH
1918: LD_STRING 13a_
1920: PPUSH
1921: CALL 490 0 3
1925: ST_TO_ADDR
// if Kirilenkova then
1926: LD_EXP 22
1930: IFFALSE 1948
// tmp := tmp ^ Kirilenkova ;
1932: LD_ADDR_VAR 0 2
1936: PUSH
1937: LD_VAR 0 2
1941: PUSH
1942: LD_EXP 22
1946: ADD
1947: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1948: LD_ADDR_EXP 25
1952: PUSH
1953: LD_STRING Petrosyan
1955: PPUSH
1956: LD_EXP 1
1960: NOT
1961: PPUSH
1962: LD_STRING 13a_
1964: PPUSH
1965: CALL 490 0 3
1969: ST_TO_ADDR
// if Petrosyan then
1970: LD_EXP 25
1974: IFFALSE 1992
// tmp := tmp ^ Petrosyan ;
1976: LD_ADDR_VAR 0 2
1980: PUSH
1981: LD_VAR 0 2
1985: PUSH
1986: LD_EXP 25
1990: ADD
1991: ST_TO_ADDR
// Scholtze := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1992: LD_ADDR_EXP 26
1996: PUSH
1997: LD_STRING Petrosyan
1999: PPUSH
2000: LD_EXP 1
2004: NOT
2005: PPUSH
2006: LD_STRING 13a_
2008: PPUSH
2009: CALL 490 0 3
2013: ST_TO_ADDR
// if Scholtze then
2014: LD_EXP 26
2018: IFFALSE 2036
// tmp := tmp ^ Scholtze ;
2020: LD_ADDR_VAR 0 2
2024: PUSH
2025: LD_VAR 0 2
2029: PUSH
2030: LD_EXP 26
2034: ADD
2035: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
2036: LD_ADDR_EXP 24
2040: PUSH
2041: LD_STRING Dolgov
2043: PPUSH
2044: LD_EXP 1
2048: NOT
2049: PPUSH
2050: LD_STRING 13a_
2052: PPUSH
2053: CALL 490 0 3
2057: ST_TO_ADDR
// if Dolgov then
2058: LD_EXP 24
2062: IFFALSE 2080
// tmp := tmp ^ Dolgov ;
2064: LD_ADDR_VAR 0 2
2068: PUSH
2069: LD_VAR 0 2
2073: PUSH
2074: LD_EXP 24
2078: ADD
2079: ST_TO_ADDR
// for i in tmp do
2080: LD_ADDR_VAR 0 3
2084: PUSH
2085: LD_VAR 0 2
2089: PUSH
2090: FOR_IN
2091: IFFALSE 2116
// PlaceUnitXYR ( i , 160 , 78 , 22 , false ) ;
2093: LD_VAR 0 3
2097: PPUSH
2098: LD_INT 160
2100: PPUSH
2101: LD_INT 78
2103: PPUSH
2104: LD_INT 22
2106: PPUSH
2107: LD_INT 0
2109: PPUSH
2110: CALL_OW 50
2114: GO 2090
2116: POP
2117: POP
// squad1 := tmp ;
2118: LD_ADDR_EXP 37
2122: PUSH
2123: LD_VAR 0 2
2127: ST_TO_ADDR
// tmp := [ ] ;
2128: LD_ADDR_VAR 0 2
2132: PUSH
2133: EMPTY
2134: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrova , ( not debug ) , 13a_ ) ;
2135: LD_ADDR_EXP 30
2139: PUSH
2140: LD_STRING Petrova
2142: PPUSH
2143: LD_EXP 1
2147: NOT
2148: PPUSH
2149: LD_STRING 13a_
2151: PPUSH
2152: CALL 490 0 3
2156: ST_TO_ADDR
// if Petrovova then
2157: LD_EXP 30
2161: IFFALSE 2179
// tmp := tmp ^ Petrovova ;
2163: LD_ADDR_VAR 0 2
2167: PUSH
2168: LD_VAR 0 2
2172: PUSH
2173: LD_EXP 30
2177: ADD
2178: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
2179: LD_ADDR_EXP 23
2183: PUSH
2184: LD_STRING Titov
2186: PPUSH
2187: LD_EXP 1
2191: NOT
2192: PPUSH
2193: LD_STRING 13a_
2195: PPUSH
2196: CALL 490 0 3
2200: ST_TO_ADDR
// if Titov then
2201: LD_EXP 23
2205: IFFALSE 2223
// tmp := tmp ^ Titov ;
2207: LD_ADDR_VAR 0 2
2211: PUSH
2212: LD_VAR 0 2
2216: PUSH
2217: LD_EXP 23
2221: ADD
2222: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2223: LD_ADDR_EXP 33
2227: PUSH
2228: LD_STRING Karamazov
2230: PPUSH
2231: LD_EXP 1
2235: NOT
2236: PPUSH
2237: LD_STRING 13a_
2239: PPUSH
2240: CALL 490 0 3
2244: ST_TO_ADDR
// if Karamazov then
2245: LD_EXP 33
2249: IFFALSE 2267
// tmp := tmp ^ Karamazov ;
2251: LD_ADDR_VAR 0 2
2255: PUSH
2256: LD_VAR 0 2
2260: PUSH
2261: LD_EXP 33
2265: ADD
2266: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
2267: LD_ADDR_EXP 16
2271: PUSH
2272: LD_STRING Frank
2274: PPUSH
2275: LD_EXP 1
2279: NOT
2280: PPUSH
2281: LD_STRING 13a_
2283: PPUSH
2284: CALL 490 0 3
2288: ST_TO_ADDR
// if Frank then
2289: LD_EXP 16
2293: IFFALSE 2311
// tmp := tmp ^ Frank ;
2295: LD_ADDR_VAR 0 2
2299: PUSH
2300: LD_VAR 0 2
2304: PUSH
2305: LD_EXP 16
2309: ADD
2310: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2311: LD_ADDR_EXP 7
2315: PUSH
2316: LD_STRING Donaldson
2318: PPUSH
2319: LD_EXP 1
2323: NOT
2324: PPUSH
2325: LD_STRING 13a_
2327: PPUSH
2328: CALL 490 0 3
2332: ST_TO_ADDR
// if Donaldson then
2333: LD_EXP 7
2337: IFFALSE 2355
// tmp := tmp ^ Donaldson ;
2339: LD_ADDR_VAR 0 2
2343: PUSH
2344: LD_VAR 0 2
2348: PUSH
2349: LD_EXP 7
2353: ADD
2354: ST_TO_ADDR
// for i in tmp do
2355: LD_ADDR_VAR 0 3
2359: PUSH
2360: LD_VAR 0 2
2364: PUSH
2365: FOR_IN
2366: IFFALSE 2406
// begin PlaceUnitXYR ( i , 117 , 8 , 6 , false ) ;
2368: LD_VAR 0 3
2372: PPUSH
2373: LD_INT 117
2375: PPUSH
2376: LD_INT 8
2378: PPUSH
2379: LD_INT 6
2381: PPUSH
2382: LD_INT 0
2384: PPUSH
2385: CALL_OW 50
// ComTurnXY ( i , 117 , 8 ) ;
2389: LD_VAR 0 3
2393: PPUSH
2394: LD_INT 117
2396: PPUSH
2397: LD_INT 8
2399: PPUSH
2400: CALL_OW 118
// end ;
2404: GO 2365
2406: POP
2407: POP
// squad2 := tmp ;
2408: LD_ADDR_EXP 38
2412: PUSH
2413: LD_VAR 0 2
2417: ST_TO_ADDR
// uc_side := 0 ;
2418: LD_ADDR_OWVAR 20
2422: PUSH
2423: LD_INT 0
2425: ST_TO_ADDR
// uc_nation := 0 ;
2426: LD_ADDR_OWVAR 21
2430: PUSH
2431: LD_INT 0
2433: ST_TO_ADDR
// InitHc ;
2434: CALL_OW 19
// hc_importance := 0 ;
2438: LD_ADDR_OWVAR 32
2442: PUSH
2443: LD_INT 0
2445: ST_TO_ADDR
// hc_name := Find some goods! ;
2446: LD_ADDR_OWVAR 26
2450: PUSH
2451: LD_STRING Find some goods!
2453: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
2454: LD_INT 0
2456: PPUSH
2457: LD_INT 12
2459: PPUSH
2460: LD_INT 1
2462: PPUSH
2463: CALL_OW 380
// PlaceUnitXY ( CreateHuman , 96 , 108 , false ) ;
2467: CALL_OW 44
2471: PPUSH
2472: LD_INT 96
2474: PPUSH
2475: LD_INT 108
2477: PPUSH
2478: LD_INT 0
2480: PPUSH
2481: CALL_OW 48
// InitHc ;
2485: CALL_OW 19
// end ;
2489: LD_VAR 0 1
2493: RET
// every 3 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 0 ] ] ) do var Louis , veh ;
2494: LD_INT 22
2496: PUSH
2497: LD_INT 7
2499: PUSH
2500: EMPTY
2501: LIST
2502: LIST
2503: PUSH
2504: LD_INT 23
2506: PUSH
2507: LD_INT 0
2509: PUSH
2510: EMPTY
2511: LIST
2512: LIST
2513: PUSH
2514: EMPTY
2515: LIST
2516: LIST
2517: PPUSH
2518: CALL_OW 69
2522: IFFALSE 2987
2524: GO 2526
2526: DISABLE
2527: LD_INT 0
2529: PPUSH
2530: PPUSH
// begin InGameOn ;
2531: CALL_OW 8
// RemoveUnit ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 0 ] ] ) [ 1 ] ) ;
2535: LD_INT 22
2537: PUSH
2538: LD_INT 7
2540: PUSH
2541: EMPTY
2542: LIST
2543: LIST
2544: PUSH
2545: LD_INT 23
2547: PUSH
2548: LD_INT 0
2550: PUSH
2551: EMPTY
2552: LIST
2553: LIST
2554: PUSH
2555: EMPTY
2556: LIST
2557: LIST
2558: PPUSH
2559: CALL_OW 69
2563: PUSH
2564: LD_INT 1
2566: ARRAY
2567: PPUSH
2568: CALL_OW 64
// game_speed := 4 ;
2572: LD_ADDR_OWVAR 65
2576: PUSH
2577: LD_INT 4
2579: ST_TO_ADDR
// ComMoveXY ( JMM , 93 , 100 ) ;
2580: LD_EXP 2
2584: PPUSH
2585: LD_INT 93
2587: PPUSH
2588: LD_INT 100
2590: PPUSH
2591: CALL_OW 111
// ComMoveXY ( Burlak , 93 , 99 ) ;
2595: LD_EXP 3
2599: PPUSH
2600: LD_INT 93
2602: PPUSH
2603: LD_INT 99
2605: PPUSH
2606: CALL_OW 111
// AddComTurnXY ( [ JMM , Burlak ] , 81 , 112 ) ;
2610: LD_EXP 2
2614: PUSH
2615: LD_EXP 3
2619: PUSH
2620: EMPTY
2621: LIST
2622: LIST
2623: PPUSH
2624: LD_INT 81
2626: PPUSH
2627: LD_INT 112
2629: PPUSH
2630: CALL_OW 178
// wait ( 0 0$5 ) ;
2634: LD_INT 175
2636: PPUSH
2637: CALL_OW 67
// music_nat := 2 ;
2641: LD_ADDR_OWVAR 71
2645: PUSH
2646: LD_INT 2
2648: ST_TO_ADDR
// music_class := 4 ;
2649: LD_ADDR_OWVAR 72
2653: PUSH
2654: LD_INT 4
2656: ST_TO_ADDR
// CenterNowOnXY ( 80 , 130 ) ;
2657: LD_INT 80
2659: PPUSH
2660: LD_INT 130
2662: PPUSH
2663: CALL_OW 86
// uc_nation := 2 ;
2667: LD_ADDR_OWVAR 21
2671: PUSH
2672: LD_INT 2
2674: ST_TO_ADDR
// uc_side := 2 ;
2675: LD_ADDR_OWVAR 20
2679: PUSH
2680: LD_INT 2
2682: ST_TO_ADDR
// hc_gallery = sandar ;
2683: LD_ADDR_OWVAR 33
2687: PUSH
2688: LD_STRING sandar
2690: ST_TO_ADDR
// hc_face_number = 1 ;
2691: LD_ADDR_OWVAR 34
2695: PUSH
2696: LD_INT 1
2698: ST_TO_ADDR
// hc_name = Louis Schulz ;
2699: LD_ADDR_OWVAR 26
2703: PUSH
2704: LD_STRING Louis Schulz
2706: ST_TO_ADDR
// hc_attr = [ 13 , 11 ] ;
2707: LD_ADDR_OWVAR 29
2711: PUSH
2712: LD_INT 13
2714: PUSH
2715: LD_INT 11
2717: PUSH
2718: EMPTY
2719: LIST
2720: LIST
2721: ST_TO_ADDR
// hc_basic_skills = [ 0 , 0 , 0 , 0 ] ;
2722: LD_ADDR_OWVAR 30
2726: PUSH
2727: LD_INT 0
2729: PUSH
2730: LD_INT 0
2732: PUSH
2733: LD_INT 0
2735: PUSH
2736: LD_INT 0
2738: PUSH
2739: EMPTY
2740: LIST
2741: LIST
2742: LIST
2743: LIST
2744: ST_TO_ADDR
// hc_skills = [ 10 , 6 , 7 , 7 ] ;
2745: LD_ADDR_OWVAR 31
2749: PUSH
2750: LD_INT 10
2752: PUSH
2753: LD_INT 6
2755: PUSH
2756: LD_INT 7
2758: PUSH
2759: LD_INT 7
2761: PUSH
2762: EMPTY
2763: LIST
2764: LIST
2765: LIST
2766: LIST
2767: ST_TO_ADDR
// hc_sex = sex_male ;
2768: LD_ADDR_OWVAR 27
2772: PUSH
2773: LD_INT 1
2775: ST_TO_ADDR
// hc_class = 1 ;
2776: LD_ADDR_OWVAR 28
2780: PUSH
2781: LD_INT 1
2783: ST_TO_ADDR
// hc_importance = 100 ;
2784: LD_ADDR_OWVAR 32
2788: PUSH
2789: LD_INT 100
2791: ST_TO_ADDR
// Louis = CreateHuman ;
2792: LD_ADDR_VAR 0 1
2796: PUSH
2797: CALL_OW 44
2801: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_flame_thrower , 100 ) ;
2802: LD_INT 14
2804: PPUSH
2805: LD_INT 3
2807: PPUSH
2808: LD_INT 1
2810: PPUSH
2811: LD_INT 26
2813: PPUSH
2814: LD_INT 100
2816: PPUSH
2817: CALL 553 0 5
// veh := CreateVehicle ;
2821: LD_ADDR_VAR 0 2
2825: PUSH
2826: CALL_OW 45
2830: ST_TO_ADDR
// SetMark ( veh , - 2 ) ;
2831: LD_VAR 0 2
2835: PPUSH
2836: LD_INT 2
2838: NEG
2839: PPUSH
2840: CALL_OW 242
// PlaceUnitXY ( veh , 80 , 130 , false ) ;
2844: LD_VAR 0 2
2848: PPUSH
2849: LD_INT 80
2851: PPUSH
2852: LD_INT 130
2854: PPUSH
2855: LD_INT 0
2857: PPUSH
2858: CALL_OW 48
// PlaceHumanInUnit ( Louis , veh ) ;
2862: LD_VAR 0 1
2866: PPUSH
2867: LD_VAR 0 2
2871: PPUSH
2872: CALL_OW 52
// ComMoveXY ( Louis , 80 , 109 ) ;
2876: LD_VAR 0 1
2880: PPUSH
2881: LD_INT 80
2883: PPUSH
2884: LD_INT 109
2886: PPUSH
2887: CALL_OW 111
// AddComExitVehicle ( Louis ) ;
2891: LD_VAR 0 1
2895: PPUSH
2896: CALL_OW 181
// AddComMoveXY ( Louis , 80 , 131 ) ;
2900: LD_VAR 0 1
2904: PPUSH
2905: LD_INT 80
2907: PPUSH
2908: LD_INT 131
2910: PPUSH
2911: CALL_OW 171
// wait ( 0 0$06 ) ;
2915: LD_INT 210
2917: PPUSH
2918: CALL_OW 67
// InGameOff ;
2922: CALL_OW 9
// repeat wait ( 0 0$1 ) ;
2926: LD_INT 35
2928: PPUSH
2929: CALL_OW 67
// until IsAt ( Louis , 80 , 131 ) ;
2933: LD_VAR 0 1
2937: PPUSH
2938: LD_INT 80
2940: PPUSH
2941: LD_INT 131
2943: PPUSH
2944: CALL_OW 307
2948: IFFALSE 2926
// SetSide ( veh , 7 ) ;
2950: LD_VAR 0 2
2954: PPUSH
2955: LD_INT 7
2957: PPUSH
2958: CALL_OW 235
// RemoveUnit ( Louis ) ;
2962: LD_VAR 0 1
2966: PPUSH
2967: CALL_OW 64
// music_nat := 3 ;
2971: LD_ADDR_OWVAR 71
2975: PUSH
2976: LD_INT 3
2978: ST_TO_ADDR
// music_class := 0 ;
2979: LD_ADDR_OWVAR 72
2983: PUSH
2984: LD_INT 0
2986: ST_TO_ADDR
// end ;
2987: PPOPN 2
2989: END
// every 0 0$10 trigger squad1 do var i , xy ;
2990: LD_EXP 37
2994: IFFALSE 3357
2996: GO 2998
2998: DISABLE
2999: LD_INT 0
3001: PPUSH
3002: PPUSH
// begin enable ;
3003: ENABLE
// i := squad1 [ rand ( 1 , squad1 ) ] ;
3004: LD_ADDR_VAR 0 1
3008: PUSH
3009: LD_EXP 37
3013: PUSH
3014: LD_INT 1
3016: PPUSH
3017: LD_EXP 37
3021: PPUSH
3022: CALL_OW 12
3026: ARRAY
3027: ST_TO_ADDR
// if IsInUnit ( i ) then
3028: LD_VAR 0 1
3032: PPUSH
3033: CALL_OW 310
3037: IFFALSE 3041
// exit ;
3039: GO 3357
// ComRemember ( i ) ;
3041: LD_VAR 0 1
3045: PPUSH
3046: CALL_OW 143
// xy := [ ShiftX ( GetX ( i ) , rand ( 0 , 5 ) , rand ( 2 , 7 ) ) , ShiftY ( GetY ( i ) , rand ( 0 , 5 ) , rand ( 2 , 7 ) ) ] ;
3050: LD_ADDR_VAR 0 2
3054: PUSH
3055: LD_VAR 0 1
3059: PPUSH
3060: CALL_OW 250
3064: PPUSH
3065: LD_INT 0
3067: PPUSH
3068: LD_INT 5
3070: PPUSH
3071: CALL_OW 12
3075: PPUSH
3076: LD_INT 2
3078: PPUSH
3079: LD_INT 7
3081: PPUSH
3082: CALL_OW 12
3086: PPUSH
3087: CALL_OW 272
3091: PUSH
3092: LD_VAR 0 1
3096: PPUSH
3097: CALL_OW 251
3101: PPUSH
3102: LD_INT 0
3104: PPUSH
3105: LD_INT 5
3107: PPUSH
3108: CALL_OW 12
3112: PPUSH
3113: LD_INT 2
3115: PPUSH
3116: LD_INT 7
3118: PPUSH
3119: CALL_OW 12
3123: PPUSH
3124: CALL_OW 273
3128: PUSH
3129: EMPTY
3130: LIST
3131: LIST
3132: ST_TO_ADDR
// if HexInfo ( xy [ 1 ] , xy [ 2 ] ) <> 0 or not ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
3133: LD_VAR 0 2
3137: PUSH
3138: LD_INT 1
3140: ARRAY
3141: PPUSH
3142: LD_VAR 0 2
3146: PUSH
3147: LD_INT 2
3149: ARRAY
3150: PPUSH
3151: CALL_OW 428
3155: PUSH
3156: LD_INT 0
3158: NONEQUAL
3159: PUSH
3160: LD_VAR 0 2
3164: PUSH
3165: LD_INT 1
3167: ARRAY
3168: PPUSH
3169: LD_VAR 0 2
3173: PUSH
3174: LD_INT 2
3176: ARRAY
3177: PPUSH
3178: CALL_OW 488
3182: NOT
3183: OR
3184: IFFALSE 3188
// exit ;
3186: GO 3357
// AddComMoveXY ( i , xy [ 1 ] , xy [ 2 ] ) ;
3188: LD_VAR 0 1
3192: PPUSH
3193: LD_VAR 0 2
3197: PUSH
3198: LD_INT 1
3200: ARRAY
3201: PPUSH
3202: LD_VAR 0 2
3206: PUSH
3207: LD_INT 2
3209: ARRAY
3210: PPUSH
3211: CALL_OW 171
// AddComWait ( i , 0 0$10 ) ;
3215: LD_VAR 0 1
3219: PPUSH
3220: LD_INT 350
3222: PPUSH
3223: CALL_OW 202
// if Prob ( 60 ) and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) then
3227: LD_INT 60
3229: PPUSH
3230: CALL_OW 13
3234: PUSH
3235: LD_INT 22
3237: PUSH
3238: LD_INT 4
3240: PUSH
3241: EMPTY
3242: LIST
3243: LIST
3244: PUSH
3245: LD_INT 21
3247: PUSH
3248: LD_INT 3
3250: PUSH
3251: EMPTY
3252: LIST
3253: LIST
3254: PUSH
3255: EMPTY
3256: LIST
3257: LIST
3258: PPUSH
3259: CALL_OW 69
3263: AND
3264: IFFALSE 3348
// begin AddComEnterUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , i ) ) ;
3266: LD_VAR 0 1
3270: PPUSH
3271: LD_INT 22
3273: PUSH
3274: LD_INT 4
3276: PUSH
3277: EMPTY
3278: LIST
3279: LIST
3280: PUSH
3281: LD_INT 21
3283: PUSH
3284: LD_INT 3
3286: PUSH
3287: EMPTY
3288: LIST
3289: LIST
3290: PUSH
3291: EMPTY
3292: LIST
3293: LIST
3294: PPUSH
3295: CALL_OW 69
3299: PPUSH
3300: LD_VAR 0 1
3304: PPUSH
3305: CALL_OW 74
3309: PPUSH
3310: CALL_OW 180
// repeat wait ( 0 0$30 ) ;
3314: LD_INT 1050
3316: PPUSH
3317: CALL_OW 67
// until IsInUnit ( i ) ;
3321: LD_VAR 0 1
3325: PPUSH
3326: CALL_OW 310
3330: IFFALSE 3314
// wait ( 0 0$30 ) ;
3332: LD_INT 1050
3334: PPUSH
3335: CALL_OW 67
// AddComExitBuilding ( i ) ;
3339: LD_VAR 0 1
3343: PPUSH
3344: CALL_OW 182
// end ; AddComReturn ( i ) ;
3348: LD_VAR 0 1
3352: PPUSH
3353: CALL_OW 204
// end ; end_of_file
3357: PPOPN 2
3359: END
// export function Action ; begin
3360: LD_INT 0
3362: PPUSH
// InGameOn ;
3363: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
3367: LD_EXP 2
3371: PPUSH
3372: CALL_OW 87
// Say ( JMM , D1-JMM-1 ) ;
3376: LD_EXP 2
3380: PPUSH
3381: LD_STRING D1-JMM-1
3383: PPUSH
3384: CALL_OW 88
// Say ( Burlak , D1-Bur-1 ) ;
3388: LD_EXP 3
3392: PPUSH
3393: LD_STRING D1-Bur-1
3395: PPUSH
3396: CALL_OW 88
// Say ( JMM , D1-JMM-2 ) ;
3400: LD_EXP 2
3404: PPUSH
3405: LD_STRING D1-JMM-2
3407: PPUSH
3408: CALL_OW 88
// Say ( Burlak , D1-Bur-2 ) ;
3412: LD_EXP 3
3416: PPUSH
3417: LD_STRING D1-Bur-2
3419: PPUSH
3420: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
3424: LD_EXP 2
3428: PPUSH
3429: LD_STRING D1-JMM-3
3431: PPUSH
3432: CALL_OW 88
// Say ( Burlak , D1-Bur-3 ) ;
3436: LD_EXP 3
3440: PPUSH
3441: LD_STRING D1-Bur-3
3443: PPUSH
3444: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
3448: LD_EXP 2
3452: PPUSH
3453: LD_STRING D1-JMM-4
3455: PPUSH
3456: CALL_OW 88
// Say ( Burlak , D1-Bur-4 ) ;
3460: LD_EXP 3
3464: PPUSH
3465: LD_STRING D1-Bur-4
3467: PPUSH
3468: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
3472: LD_EXP 2
3476: PPUSH
3477: LD_STRING D1-JMM-5
3479: PPUSH
3480: CALL_OW 88
// Say ( Burlak , D1-Bur-5 ) ;
3484: LD_EXP 3
3488: PPUSH
3489: LD_STRING D1-Bur-5
3491: PPUSH
3492: CALL_OW 88
// Say ( JMM , D1-JMM-6 ) ;
3496: LD_EXP 2
3500: PPUSH
3501: LD_STRING D1-JMM-6
3503: PPUSH
3504: CALL_OW 88
// Say ( Burlak , D1-Bur-6 ) ;
3508: LD_EXP 3
3512: PPUSH
3513: LD_STRING D1-Bur-6
3515: PPUSH
3516: CALL_OW 88
// Say ( JMM , D1-JMM-7 ) ;
3520: LD_EXP 2
3524: PPUSH
3525: LD_STRING D1-JMM-7
3527: PPUSH
3528: CALL_OW 88
// wait ( 20 ) ;
3532: LD_INT 20
3534: PPUSH
3535: CALL_OW 67
// Query ( QTruck ) ;
3539: LD_STRING QTruck
3541: PPUSH
3542: CALL_OW 97
// InGameOff ;
3546: CALL_OW 9
// ChangeMissionObjectives ( MArtPickup ) ;
3550: LD_STRING MArtPickup
3552: PPUSH
3553: CALL_OW 337
// SetAreaMapShow ( escape_area , 1 ) ;
3557: LD_INT 2
3559: PPUSH
3560: LD_INT 1
3562: PPUSH
3563: CALL_OW 424
// end ;
3567: LD_VAR 0 1
3571: RET
// every 0 0$3 trigger FilterUnitsInArea ( escape_area , [ [ f_type , unit_vehicle ] , [ f_control , control_manual ] , [ f_not , [ f_empty ] ] ] ) = 2 and IsInUnit ( JMM ) and IsInUnit ( Burlak ) and ( GetWeapon ( IsInUnit ( JMM ) ) in [ ru_cargo_bay , us_cargo_bay , ru_big_cargo_bay , ar_cargo_bay ] or GetWeapon ( IsInUnit ( Burlak ) ) in [ ru_cargo_bay , us_cargo_bay , ru_big_cargo_bay , ar_cargo_bay ] ) do var i , macmilanVeh , burlakVeh ;
3572: LD_INT 2
3574: PPUSH
3575: LD_INT 21
3577: PUSH
3578: LD_INT 2
3580: PUSH
3581: EMPTY
3582: LIST
3583: LIST
3584: PUSH
3585: LD_INT 33
3587: PUSH
3588: LD_INT 1
3590: PUSH
3591: EMPTY
3592: LIST
3593: LIST
3594: PUSH
3595: LD_INT 3
3597: PUSH
3598: LD_INT 58
3600: PUSH
3601: EMPTY
3602: LIST
3603: PUSH
3604: EMPTY
3605: LIST
3606: LIST
3607: PUSH
3608: EMPTY
3609: LIST
3610: LIST
3611: LIST
3612: PPUSH
3613: CALL_OW 70
3617: PUSH
3618: LD_INT 2
3620: EQUAL
3621: PUSH
3622: LD_EXP 2
3626: PPUSH
3627: CALL_OW 310
3631: AND
3632: PUSH
3633: LD_EXP 3
3637: PPUSH
3638: CALL_OW 310
3642: AND
3643: PUSH
3644: LD_EXP 2
3648: PPUSH
3649: CALL_OW 310
3653: PPUSH
3654: CALL_OW 264
3658: PUSH
3659: LD_INT 51
3661: PUSH
3662: LD_INT 12
3664: PUSH
3665: LD_EXP 40
3669: PUSH
3670: LD_INT 32
3672: PUSH
3673: EMPTY
3674: LIST
3675: LIST
3676: LIST
3677: LIST
3678: IN
3679: PUSH
3680: LD_EXP 3
3684: PPUSH
3685: CALL_OW 310
3689: PPUSH
3690: CALL_OW 264
3694: PUSH
3695: LD_INT 51
3697: PUSH
3698: LD_INT 12
3700: PUSH
3701: LD_EXP 40
3705: PUSH
3706: LD_INT 32
3708: PUSH
3709: EMPTY
3710: LIST
3711: LIST
3712: LIST
3713: LIST
3714: IN
3715: OR
3716: AND
3717: IFFALSE 3927
3719: GO 3721
3721: DISABLE
3722: LD_INT 0
3724: PPUSH
3725: PPUSH
3726: PPUSH
// begin macmilanVeh := IsInUnit ( JMM ) ;
3727: LD_ADDR_VAR 0 2
3731: PUSH
3732: LD_EXP 2
3736: PPUSH
3737: CALL_OW 310
3741: ST_TO_ADDR
// burlakVeh := IsInUnit ( Burlak ) ;
3742: LD_ADDR_VAR 0 3
3746: PUSH
3747: LD_EXP 3
3751: PPUSH
3752: CALL_OW 310
3756: ST_TO_ADDR
// SaveVariable ( [ GetChassis ( macmilanVeh ) , GetEngine ( macmilanVeh ) , control_manual , GetWeapon ( macmilanVeh ) , GetMark ( macmilanVeh ) , GetNation ( macmilanVeh ) ] , 14a_JMMVeh ) ;
3757: LD_VAR 0 2
3761: PPUSH
3762: CALL_OW 265
3766: PUSH
3767: LD_VAR 0 2
3771: PPUSH
3772: CALL_OW 262
3776: PUSH
3777: LD_INT 1
3779: PUSH
3780: LD_VAR 0 2
3784: PPUSH
3785: CALL_OW 264
3789: PUSH
3790: LD_VAR 0 2
3794: PPUSH
3795: CALL_OW 271
3799: PUSH
3800: LD_VAR 0 2
3804: PPUSH
3805: CALL_OW 248
3809: PUSH
3810: EMPTY
3811: LIST
3812: LIST
3813: LIST
3814: LIST
3815: LIST
3816: LIST
3817: PPUSH
3818: LD_STRING 14a_JMMVeh
3820: PPUSH
3821: CALL_OW 39
// SaveVariable ( [ GetChassis ( burlakVeh ) , GetEngine ( burlakVeh ) , control_manual , GetWeapon ( burlakVeh ) , GetMark ( burlakVeh ) , GetNation ( burlakVeh ) ] , 14a_BurlakVeh ) ;
3825: LD_VAR 0 3
3829: PPUSH
3830: CALL_OW 265
3834: PUSH
3835: LD_VAR 0 3
3839: PPUSH
3840: CALL_OW 262
3844: PUSH
3845: LD_INT 1
3847: PUSH
3848: LD_VAR 0 3
3852: PPUSH
3853: CALL_OW 264
3857: PUSH
3858: LD_VAR 0 3
3862: PPUSH
3863: CALL_OW 271
3867: PUSH
3868: LD_VAR 0 3
3872: PPUSH
3873: CALL_OW 248
3877: PUSH
3878: EMPTY
3879: LIST
3880: LIST
3881: LIST
3882: LIST
3883: LIST
3884: LIST
3885: PPUSH
3886: LD_STRING 14a_BurlakVeh
3888: PPUSH
3889: CALL_OW 39
// SaveCharacters ( JMM , 14a_JMM ) ;
3893: LD_EXP 2
3897: PPUSH
3898: LD_STRING 14a_JMM
3900: PPUSH
3901: CALL_OW 38
// SaveCharacters ( Burlak , 14a_Burlak ) ;
3905: LD_EXP 3
3909: PPUSH
3910: LD_STRING 14a_Burlak
3912: PPUSH
3913: CALL_OW 38
// ChangeMap ( 1 , %_cont ) ;
3917: LD_INT 1
3919: PPUSH
3920: LD_STRING %_cont
3922: PPUSH
3923: CALL_OW 340
// end ;
3927: PPOPN 3
3929: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_lives , 950 ] ] ] ) do
3930: LD_INT 22
3932: PUSH
3933: LD_INT 4
3935: PUSH
3936: EMPTY
3937: LIST
3938: LIST
3939: PUSH
3940: LD_INT 3
3942: PUSH
3943: LD_INT 24
3945: PUSH
3946: LD_INT 950
3948: PUSH
3949: EMPTY
3950: LIST
3951: LIST
3952: PUSH
3953: EMPTY
3954: LIST
3955: LIST
3956: PUSH
3957: EMPTY
3958: LIST
3959: LIST
3960: PPUSH
3961: CALL_OW 69
3965: IFFALSE 3977
3967: GO 3969
3969: DISABLE
// YouLost ( FriendlyFire ) ;
3970: LD_STRING FriendlyFire
3972: PPUSH
3973: CALL_OW 104
3977: END
// every 0 0$1 trigger IsDead ( Burlak ) do
3978: LD_EXP 3
3982: PPUSH
3983: CALL_OW 301
3987: IFFALSE 3999
3989: GO 3991
3991: DISABLE
// YouLost ( Burlak ) ;
3992: LD_STRING Burlak
3994: PPUSH
3995: CALL_OW 104
3999: END
// every 0 0$1 trigger IsDead ( JMM ) do
4000: LD_EXP 2
4004: PPUSH
4005: CALL_OW 301
4009: IFFALSE 4021
4011: GO 4013
4013: DISABLE
// YouLost ( JMM ) ; end_of_file
4014: LD_STRING JMM
4016: PPUSH
4017: CALL_OW 104
4021: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
4022: GO 4024
4024: DISABLE
// begin ru_radar := 98 ;
4025: LD_ADDR_EXP 39
4029: PUSH
4030: LD_INT 98
4032: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
4033: LD_ADDR_EXP 40
4037: PUSH
4038: LD_INT 89
4040: ST_TO_ADDR
// us_hack := 99 ;
4041: LD_ADDR_EXP 41
4045: PUSH
4046: LD_INT 99
4048: ST_TO_ADDR
// us_artillery := 97 ;
4049: LD_ADDR_EXP 42
4053: PUSH
4054: LD_INT 97
4056: ST_TO_ADDR
// ar_bio_bomb := 91 ;
4057: LD_ADDR_EXP 43
4061: PUSH
4062: LD_INT 91
4064: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
4065: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
4066: LD_INT 0
4068: PPUSH
4069: PPUSH
4070: PPUSH
4071: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
4072: LD_VAR 0 1
4076: PPUSH
4077: CALL_OW 264
4081: PUSH
4082: LD_EXP 43
4086: EQUAL
4087: IFFALSE 4159
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
4089: LD_INT 68
4091: PPUSH
4092: LD_VAR 0 1
4096: PPUSH
4097: CALL_OW 255
4101: PPUSH
4102: CALL_OW 321
4106: PUSH
4107: LD_INT 2
4109: EQUAL
4110: IFFALSE 4122
// eff := 70 else
4112: LD_ADDR_VAR 0 6
4116: PUSH
4117: LD_INT 70
4119: ST_TO_ADDR
4120: GO 4130
// eff := 30 ;
4122: LD_ADDR_VAR 0 6
4126: PUSH
4127: LD_INT 30
4129: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
4130: LD_VAR 0 1
4134: PPUSH
4135: CALL_OW 250
4139: PPUSH
4140: LD_VAR 0 1
4144: PPUSH
4145: CALL_OW 251
4149: PPUSH
4150: LD_VAR 0 6
4154: PPUSH
4155: CALL_OW 495
// end ; end ;
4159: LD_VAR 0 4
4163: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
4164: LD_INT 0
4166: PPUSH
4167: PPUSH
4168: PPUSH
4169: PPUSH
4170: PPUSH
4171: PPUSH
// if cmd = 124 then
4172: LD_VAR 0 1
4176: PUSH
4177: LD_INT 124
4179: EQUAL
4180: IFFALSE 4386
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
4182: LD_ADDR_VAR 0 5
4186: PUSH
4187: LD_INT 2
4189: PUSH
4190: LD_INT 34
4192: PUSH
4193: LD_INT 53
4195: PUSH
4196: EMPTY
4197: LIST
4198: LIST
4199: PUSH
4200: LD_INT 34
4202: PUSH
4203: LD_INT 14
4205: PUSH
4206: EMPTY
4207: LIST
4208: LIST
4209: PUSH
4210: EMPTY
4211: LIST
4212: LIST
4213: LIST
4214: PPUSH
4215: CALL_OW 69
4219: ST_TO_ADDR
// if not tmp then
4220: LD_VAR 0 5
4224: NOT
4225: IFFALSE 4229
// exit ;
4227: GO 4386
// for i in tmp do
4229: LD_ADDR_VAR 0 3
4233: PUSH
4234: LD_VAR 0 5
4238: PUSH
4239: FOR_IN
4240: IFFALSE 4384
// begin taskList := GetTaskList ( i ) ;
4242: LD_ADDR_VAR 0 6
4246: PUSH
4247: LD_VAR 0 3
4251: PPUSH
4252: CALL_OW 437
4256: ST_TO_ADDR
// if not taskList then
4257: LD_VAR 0 6
4261: NOT
4262: IFFALSE 4266
// continue ;
4264: GO 4239
// for j = 1 to taskList do
4266: LD_ADDR_VAR 0 4
4270: PUSH
4271: DOUBLE
4272: LD_INT 1
4274: DEC
4275: ST_TO_ADDR
4276: LD_VAR 0 6
4280: PUSH
4281: FOR_TO
4282: IFFALSE 4380
// if taskList [ j ] [ 1 ] = | then
4284: LD_VAR 0 6
4288: PUSH
4289: LD_VAR 0 4
4293: ARRAY
4294: PUSH
4295: LD_INT 1
4297: ARRAY
4298: PUSH
4299: LD_STRING |
4301: EQUAL
4302: IFFALSE 4378
// begin _taskList := Delete ( taskList , 1 ) ;
4304: LD_ADDR_VAR 0 7
4308: PUSH
4309: LD_VAR 0 6
4313: PPUSH
4314: LD_INT 1
4316: PPUSH
4317: CALL_OW 3
4321: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
4322: LD_VAR 0 3
4326: PPUSH
4327: LD_VAR 0 7
4331: PPUSH
4332: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
4336: LD_VAR 0 3
4340: PPUSH
4341: LD_VAR 0 6
4345: PUSH
4346: LD_VAR 0 4
4350: ARRAY
4351: PUSH
4352: LD_INT 2
4354: ARRAY
4355: PPUSH
4356: LD_VAR 0 6
4360: PUSH
4361: LD_VAR 0 4
4365: ARRAY
4366: PUSH
4367: LD_INT 3
4369: ARRAY
4370: PPUSH
4371: LD_INT 8
4373: PPUSH
4374: CALL 4391 0 4
// end ;
4378: GO 4281
4380: POP
4381: POP
// end ;
4382: GO 4239
4384: POP
4385: POP
// end ; end ;
4386: LD_VAR 0 2
4390: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
4391: LD_INT 0
4393: PPUSH
4394: PPUSH
4395: PPUSH
4396: PPUSH
4397: PPUSH
4398: PPUSH
4399: PPUSH
4400: PPUSH
4401: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
4402: LD_VAR 0 1
4406: NOT
4407: PUSH
4408: LD_VAR 0 2
4412: PPUSH
4413: LD_VAR 0 3
4417: PPUSH
4418: CALL_OW 488
4422: NOT
4423: OR
4424: PUSH
4425: LD_VAR 0 4
4429: NOT
4430: OR
4431: IFFALSE 4435
// exit ;
4433: GO 4775
// list := [ ] ;
4435: LD_ADDR_VAR 0 13
4439: PUSH
4440: EMPTY
4441: ST_TO_ADDR
// if x - r < 0 then
4442: LD_VAR 0 2
4446: PUSH
4447: LD_VAR 0 4
4451: MINUS
4452: PUSH
4453: LD_INT 0
4455: LESS
4456: IFFALSE 4468
// min_x := 0 else
4458: LD_ADDR_VAR 0 7
4462: PUSH
4463: LD_INT 0
4465: ST_TO_ADDR
4466: GO 4484
// min_x := x - r ;
4468: LD_ADDR_VAR 0 7
4472: PUSH
4473: LD_VAR 0 2
4477: PUSH
4478: LD_VAR 0 4
4482: MINUS
4483: ST_TO_ADDR
// if y - r < 0 then
4484: LD_VAR 0 3
4488: PUSH
4489: LD_VAR 0 4
4493: MINUS
4494: PUSH
4495: LD_INT 0
4497: LESS
4498: IFFALSE 4510
// min_y := 0 else
4500: LD_ADDR_VAR 0 8
4504: PUSH
4505: LD_INT 0
4507: ST_TO_ADDR
4508: GO 4526
// min_y := y - r ;
4510: LD_ADDR_VAR 0 8
4514: PUSH
4515: LD_VAR 0 3
4519: PUSH
4520: LD_VAR 0 4
4524: MINUS
4525: ST_TO_ADDR
// max_x := x + r ;
4526: LD_ADDR_VAR 0 9
4530: PUSH
4531: LD_VAR 0 2
4535: PUSH
4536: LD_VAR 0 4
4540: PLUS
4541: ST_TO_ADDR
// max_y := y + r ;
4542: LD_ADDR_VAR 0 10
4546: PUSH
4547: LD_VAR 0 3
4551: PUSH
4552: LD_VAR 0 4
4556: PLUS
4557: ST_TO_ADDR
// for _x = min_x to max_x do
4558: LD_ADDR_VAR 0 11
4562: PUSH
4563: DOUBLE
4564: LD_VAR 0 7
4568: DEC
4569: ST_TO_ADDR
4570: LD_VAR 0 9
4574: PUSH
4575: FOR_TO
4576: IFFALSE 4693
// for _y = min_y to max_y do
4578: LD_ADDR_VAR 0 12
4582: PUSH
4583: DOUBLE
4584: LD_VAR 0 8
4588: DEC
4589: ST_TO_ADDR
4590: LD_VAR 0 10
4594: PUSH
4595: FOR_TO
4596: IFFALSE 4689
// begin if not ValidHex ( _x , _y ) then
4598: LD_VAR 0 11
4602: PPUSH
4603: LD_VAR 0 12
4607: PPUSH
4608: CALL_OW 488
4612: NOT
4613: IFFALSE 4617
// continue ;
4615: GO 4595
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
4617: LD_VAR 0 11
4621: PPUSH
4622: LD_VAR 0 12
4626: PPUSH
4627: CALL_OW 351
4631: PUSH
4632: LD_VAR 0 11
4636: PPUSH
4637: LD_VAR 0 12
4641: PPUSH
4642: CALL_OW 554
4646: AND
4647: IFFALSE 4687
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
4649: LD_ADDR_VAR 0 13
4653: PUSH
4654: LD_VAR 0 13
4658: PPUSH
4659: LD_VAR 0 13
4663: PUSH
4664: LD_INT 1
4666: PLUS
4667: PPUSH
4668: LD_VAR 0 11
4672: PUSH
4673: LD_VAR 0 12
4677: PUSH
4678: EMPTY
4679: LIST
4680: LIST
4681: PPUSH
4682: CALL_OW 2
4686: ST_TO_ADDR
// end ;
4687: GO 4595
4689: POP
4690: POP
4691: GO 4575
4693: POP
4694: POP
// if not list then
4695: LD_VAR 0 13
4699: NOT
4700: IFFALSE 4704
// exit ;
4702: GO 4775
// for i in list do
4704: LD_ADDR_VAR 0 6
4708: PUSH
4709: LD_VAR 0 13
4713: PUSH
4714: FOR_IN
4715: IFFALSE 4773
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
4717: LD_VAR 0 1
4721: PPUSH
4722: LD_STRING M
4724: PUSH
4725: LD_VAR 0 6
4729: PUSH
4730: LD_INT 1
4732: ARRAY
4733: PUSH
4734: LD_VAR 0 6
4738: PUSH
4739: LD_INT 2
4741: ARRAY
4742: PUSH
4743: LD_INT 0
4745: PUSH
4746: LD_INT 0
4748: PUSH
4749: LD_INT 0
4751: PUSH
4752: LD_INT 0
4754: PUSH
4755: EMPTY
4756: LIST
4757: LIST
4758: LIST
4759: LIST
4760: LIST
4761: LIST
4762: LIST
4763: PUSH
4764: EMPTY
4765: LIST
4766: PPUSH
4767: CALL_OW 447
4771: GO 4714
4773: POP
4774: POP
// end ;
4775: LD_VAR 0 5
4779: RET
