// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// FogOff ( 7 ) ;
  11: LD_INT 7
  13: PPUSH
  14: CALL_OW 344
// RandomizeAll ;
  18: CALL_OW 11
// InitVariables ;
  22: CALL 66 0 0
// LoadBuildings ;
  26: CALL 94 0 0
// PrepareAlliance ;
  30: CALL 611 0 0
// music_nat := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
  34: LD_ADDR_OWVAR 71
  38: PUSH
  39: LD_INT 1
  41: PUSH
  42: LD_INT 3
  44: PUSH
  45: EMPTY
  46: LIST
  47: LIST
  48: PUSH
  49: LD_INT 1
  51: PPUSH
  52: LD_INT 2
  54: PPUSH
  55: CALL_OW 12
  59: ARRAY
  60: ST_TO_ADDR
// Action ;
  61: CALL 3403 0 0
// end ;
  65: END
// export debug ; export function InitVariables ; begin
  66: LD_INT 0
  68: PPUSH
// debug := false ;
  69: LD_ADDR_EXP 1
  73: PUSH
  74: LD_INT 0
  76: ST_TO_ADDR
// end ;
  77: LD_VAR 0 1
  81: RET
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
  82: LD_VAR 0 1
  86: PPUSH
  87: CALL 4207 0 1
// end ; end_of_file
  91: PPOPN 1
  93: END
// export function LoadBuildings ; var i , tmp , b ; begin
  94: LD_INT 0
  96: PPUSH
  97: PPUSH
  98: PPUSH
  99: PPUSH
// tmp := LoadVariable ( 13a_buildings , [ [ 7 , 1 , b_warehouse , 70 , 46 , 3 , 10 , 0 , 0 , 0 ] ] ) ;
 100: LD_ADDR_VAR 0 3
 104: PUSH
 105: LD_STRING 13a_buildings
 107: PPUSH
 108: LD_INT 7
 110: PUSH
 111: LD_INT 1
 113: PUSH
 114: LD_INT 1
 116: PUSH
 117: LD_INT 70
 119: PUSH
 120: LD_INT 46
 122: PUSH
 123: LD_INT 3
 125: PUSH
 126: LD_INT 10
 128: PUSH
 129: LD_INT 0
 131: PUSH
 132: LD_INT 0
 134: PUSH
 135: LD_INT 0
 137: PUSH
 138: EMPTY
 139: LIST
 140: LIST
 141: LIST
 142: LIST
 143: LIST
 144: LIST
 145: LIST
 146: LIST
 147: LIST
 148: LIST
 149: PUSH
 150: EMPTY
 151: LIST
 152: PPUSH
 153: CALL_OW 30
 157: ST_TO_ADDR
// bc_kind1 := - 1 ;
 158: LD_ADDR_OWVAR 44
 162: PUSH
 163: LD_INT 1
 165: NEG
 166: ST_TO_ADDR
// bc_kind2 := - 1 ;
 167: LD_ADDR_OWVAR 45
 171: PUSH
 172: LD_INT 1
 174: NEG
 175: ST_TO_ADDR
// for i in tmp do
 176: LD_ADDR_VAR 0 2
 180: PUSH
 181: LD_VAR 0 3
 185: PUSH
 186: FOR_IN
 187: IFFALSE 432
// begin uc_side := 7 ;
 189: LD_ADDR_OWVAR 20
 193: PUSH
 194: LD_INT 7
 196: ST_TO_ADDR
// uc_nation := i [ 2 ] ;
 197: LD_ADDR_OWVAR 21
 201: PUSH
 202: LD_VAR 0 2
 206: PUSH
 207: LD_INT 2
 209: ARRAY
 210: ST_TO_ADDR
// if i [ 2 ] = 2 then
 211: LD_VAR 0 2
 215: PUSH
 216: LD_INT 2
 218: ARRAY
 219: PUSH
 220: LD_INT 2
 222: EQUAL
 223: IFFALSE 233
// uc_side := 4 ;
 225: LD_ADDR_OWVAR 20
 229: PUSH
 230: LD_INT 4
 232: ST_TO_ADDR
// bc_type := i [ 3 ] ;
 233: LD_ADDR_OWVAR 42
 237: PUSH
 238: LD_VAR 0 2
 242: PUSH
 243: LD_INT 3
 245: ARRAY
 246: ST_TO_ADDR
// if i [ 3 ] in [ b_oil_mine , b_siberite_mine ] then
 247: LD_VAR 0 2
 251: PUSH
 252: LD_INT 3
 254: ARRAY
 255: PUSH
 256: LD_INT 29
 258: PUSH
 259: LD_INT 30
 261: PUSH
 262: EMPTY
 263: LIST
 264: LIST
 265: IN
 266: IFFALSE 299
// SetResourceVisibility ( i [ 4 ] , i [ 5 ] , i [ 1 ] ) ;
 268: LD_VAR 0 2
 272: PUSH
 273: LD_INT 4
 275: ARRAY
 276: PPUSH
 277: LD_VAR 0 2
 281: PUSH
 282: LD_INT 5
 284: ARRAY
 285: PPUSH
 286: LD_VAR 0 2
 290: PUSH
 291: LD_INT 1
 293: ARRAY
 294: PPUSH
 295: CALL_OW 441
// if i [ 8 ] then
 299: LD_VAR 0 2
 303: PUSH
 304: LD_INT 8
 306: ARRAY
 307: IFFALSE 323
// bc_kind1 := i [ 8 ] ;
 309: LD_ADDR_OWVAR 44
 313: PUSH
 314: LD_VAR 0 2
 318: PUSH
 319: LD_INT 8
 321: ARRAY
 322: ST_TO_ADDR
// if i [ 9 ] then
 323: LD_VAR 0 2
 327: PUSH
 328: LD_INT 9
 330: ARRAY
 331: IFFALSE 347
// bc_kind2 := i [ 9 ] ;
 333: LD_ADDR_OWVAR 45
 337: PUSH
 338: LD_VAR 0 2
 342: PUSH
 343: LD_INT 9
 345: ARRAY
 346: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( i [ 4 ] , i [ 5 ] , i [ 6 ] ) ;
 347: LD_ADDR_VAR 0 4
 351: PUSH
 352: LD_VAR 0 2
 356: PUSH
 357: LD_INT 4
 359: ARRAY
 360: PPUSH
 361: LD_VAR 0 2
 365: PUSH
 366: LD_INT 5
 368: ARRAY
 369: PPUSH
 370: LD_VAR 0 2
 374: PUSH
 375: LD_INT 6
 377: ARRAY
 378: PPUSH
 379: CALL_OW 47
 383: ST_TO_ADDR
// SetBLevel ( b , i [ 7 ] ) ;
 384: LD_VAR 0 4
 388: PPUSH
 389: LD_VAR 0 2
 393: PUSH
 394: LD_INT 7
 396: ARRAY
 397: PPUSH
 398: CALL_OW 241
// if i [ 10 ] then
 402: LD_VAR 0 2
 406: PUSH
 407: LD_INT 10
 409: ARRAY
 410: IFFALSE 430
// PlaceWeaponTurret ( b , i [ 10 ] ) ;
 412: LD_VAR 0 4
 416: PPUSH
 417: LD_VAR 0 2
 421: PUSH
 422: LD_INT 10
 424: ARRAY
 425: PPUSH
 426: CALL_OW 431
// end ;
 430: GO 186
 432: POP
 433: POP
// if HexInfo ( 144 , 65 ) = 0 then
 434: LD_INT 144
 436: PPUSH
 437: LD_INT 65
 439: PPUSH
 440: CALL_OW 428
 444: PUSH
 445: LD_INT 0
 447: EQUAL
 448: IFFALSE 485
// begin uc_side := 4 ;
 450: LD_ADDR_OWVAR 20
 454: PUSH
 455: LD_INT 4
 457: ST_TO_ADDR
// bc_type := b_warehouse ;
 458: LD_ADDR_OWVAR 42
 462: PUSH
 463: LD_INT 1
 465: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 144 , 65 , 1 ) ;
 466: LD_ADDR_VAR 0 4
 470: PUSH
 471: LD_INT 144
 473: PPUSH
 474: LD_INT 65
 476: PPUSH
 477: LD_INT 1
 479: PPUSH
 480: CALL_OW 47
 484: ST_TO_ADDR
// end ; end ;
 485: LD_VAR 0 1
 489: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 490: LD_INT 0
 492: PPUSH
 493: PPUSH
// if exist_mode then
 494: LD_VAR 0 2
 498: IFFALSE 523
// unit := CreateCharacter ( prefix & ident ) else
 500: LD_ADDR_VAR 0 5
 504: PUSH
 505: LD_VAR 0 3
 509: PUSH
 510: LD_VAR 0 1
 514: STR
 515: PPUSH
 516: CALL_OW 34
 520: ST_TO_ADDR
 521: GO 538
// unit := NewCharacter ( ident ) ;
 523: LD_ADDR_VAR 0 5
 527: PUSH
 528: LD_VAR 0 1
 532: PPUSH
 533: CALL_OW 25
 537: ST_TO_ADDR
// result := unit ;
 538: LD_ADDR_VAR 0 4
 542: PUSH
 543: LD_VAR 0 5
 547: ST_TO_ADDR
// end ;
 548: LD_VAR 0 4
 552: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
 553: LD_INT 0
 555: PPUSH
// vc_chassis := chassis ;
 556: LD_ADDR_OWVAR 37
 560: PUSH
 561: LD_VAR 0 1
 565: ST_TO_ADDR
// vc_engine := engine ;
 566: LD_ADDR_OWVAR 39
 570: PUSH
 571: LD_VAR 0 2
 575: ST_TO_ADDR
// vc_control := control ;
 576: LD_ADDR_OWVAR 38
 580: PUSH
 581: LD_VAR 0 3
 585: ST_TO_ADDR
// vc_weapon := weapon ;
 586: LD_ADDR_OWVAR 40
 590: PUSH
 591: LD_VAR 0 4
 595: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 596: LD_ADDR_OWVAR 41
 600: PUSH
 601: LD_VAR 0 5
 605: ST_TO_ADDR
// end ; end_of_file
 606: LD_VAR 0 6
 610: RET
// export JMM , Burlak , freedom ; export Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Belkov , Gnyevko , Masha ; export squad1 , squad2 ; export function PrepareAlliance ; var tmp , i , veh ; begin
 611: LD_INT 0
 613: PPUSH
 614: PPUSH
 615: PPUSH
 616: PPUSH
// uc_side := 7 ;
 617: LD_ADDR_OWVAR 20
 621: PUSH
 622: LD_INT 7
 624: ST_TO_ADDR
// uc_nation := 1 ;
 625: LD_ADDR_OWVAR 21
 629: PUSH
 630: LD_INT 1
 632: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 13a_ ) ;
 633: LD_ADDR_EXP 2
 637: PUSH
 638: LD_STRING JMM
 640: PPUSH
 641: LD_EXP 1
 645: NOT
 646: PPUSH
 647: LD_STRING 13a_
 649: PPUSH
 650: CALL 490 0 3
 654: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 13a_ ) ;
 655: LD_ADDR_EXP 3
 659: PUSH
 660: LD_STRING Burlak
 662: PPUSH
 663: LD_EXP 1
 667: NOT
 668: PPUSH
 669: LD_STRING 13a_
 671: PPUSH
 672: CALL 490 0 3
 676: ST_TO_ADDR
// if debug then
 677: LD_EXP 1
 681: IFFALSE 716
// begin PrepareHuman ( sex_male , 4 , 10 ) ;
 683: LD_INT 1
 685: PPUSH
 686: LD_INT 4
 688: PPUSH
 689: LD_INT 10
 691: PPUSH
 692: CALL_OW 380
// JMM := CreateHuman ;
 696: LD_ADDR_EXP 2
 700: PUSH
 701: CALL_OW 44
 705: ST_TO_ADDR
// Burlak := CreateHuman ;
 706: LD_ADDR_EXP 3
 710: PUSH
 711: CALL_OW 44
 715: ST_TO_ADDR
// end ; freedom := FilterUnitsInArea ( freedom_base , [ [ f_side , 7 ] , [ f_or , [ f_nation , 1 ] , [ f_nation , 3 ] ] , [ f_btype , b_warehouse ] ] ) ;
 716: LD_ADDR_EXP 4
 720: PUSH
 721: LD_INT 1
 723: PPUSH
 724: LD_INT 22
 726: PUSH
 727: LD_INT 7
 729: PUSH
 730: EMPTY
 731: LIST
 732: LIST
 733: PUSH
 734: LD_INT 2
 736: PUSH
 737: LD_INT 23
 739: PUSH
 740: LD_INT 1
 742: PUSH
 743: EMPTY
 744: LIST
 745: LIST
 746: PUSH
 747: LD_INT 23
 749: PUSH
 750: LD_INT 3
 752: PUSH
 753: EMPTY
 754: LIST
 755: LIST
 756: PUSH
 757: EMPTY
 758: LIST
 759: LIST
 760: LIST
 761: PUSH
 762: LD_INT 30
 764: PUSH
 765: LD_INT 1
 767: PUSH
 768: EMPTY
 769: LIST
 770: LIST
 771: PUSH
 772: EMPTY
 773: LIST
 774: LIST
 775: LIST
 776: PPUSH
 777: CALL_OW 70
 781: ST_TO_ADDR
// if freedom then
 782: LD_EXP 4
 786: IFFALSE 913
// begin freedom := freedom [ 1 ] ;
 788: LD_ADDR_EXP 4
 792: PUSH
 793: LD_EXP 4
 797: PUSH
 798: LD_INT 1
 800: ARRAY
 801: ST_TO_ADDR
// SetBName ( freedom , freedom ) ;
 802: LD_EXP 4
 806: PPUSH
 807: LD_STRING freedom
 809: PPUSH
 810: CALL_OW 500
// CenterNowOnUnits ( freedom ) ;
 814: LD_EXP 4
 818: PPUSH
 819: CALL_OW 87
// PlaceHumanInUnit ( JMM , freedom ) ;
 823: LD_EXP 2
 827: PPUSH
 828: LD_EXP 4
 832: PPUSH
 833: CALL_OW 52
// PlaceHumanInUnit ( Burlak , freedom ) ;
 837: LD_EXP 3
 841: PPUSH
 842: LD_EXP 4
 846: PPUSH
 847: CALL_OW 52
// SetResourceType ( GetBase ( freedom ) , mat_cans , 1000 ) ;
 851: LD_EXP 4
 855: PPUSH
 856: CALL_OW 274
 860: PPUSH
 861: LD_INT 1
 863: PPUSH
 864: LD_INT 1000
 866: PPUSH
 867: CALL_OW 277
// SetResourceType ( GetBase ( freedom ) , mat_oil , 400 ) ;
 871: LD_EXP 4
 875: PPUSH
 876: CALL_OW 274
 880: PPUSH
 881: LD_INT 2
 883: PPUSH
 884: LD_INT 400
 886: PPUSH
 887: CALL_OW 277
// SetResourceType ( GetBase ( freedom ) , mat_siberit , 30 ) ;
 891: LD_EXP 4
 895: PPUSH
 896: CALL_OW 274
 900: PPUSH
 901: LD_INT 3
 903: PPUSH
 904: LD_INT 30
 906: PPUSH
 907: CALL_OW 277
// end else
 911: GO 1000
// begin PlaceUnitArea ( JMM , freedom_base , false ) ;
 913: LD_EXP 2
 917: PPUSH
 918: LD_INT 1
 920: PPUSH
 921: LD_INT 0
 923: PPUSH
 924: CALL_OW 49
// PlaceUnitXYR ( Burlak , GetX ( JMM ) , GetY ( JMM ) , 8 , false ) ;
 928: LD_EXP 3
 932: PPUSH
 933: LD_EXP 2
 937: PPUSH
 938: CALL_OW 250
 942: PPUSH
 943: LD_EXP 2
 947: PPUSH
 948: CALL_OW 251
 952: PPUSH
 953: LD_INT 8
 955: PPUSH
 956: LD_INT 0
 958: PPUSH
 959: CALL_OW 50
// ComTurnUnit ( JMM , Burlak ) ;
 963: LD_EXP 2
 967: PPUSH
 968: LD_EXP 3
 972: PPUSH
 973: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
 977: LD_EXP 3
 981: PPUSH
 982: LD_EXP 2
 986: PPUSH
 987: CALL_OW 119
// CenterNowOnUnits ( JMM ) ;
 991: LD_EXP 2
 995: PPUSH
 996: CALL_OW 87
// end ; SetClass ( JMM , 2 ) ;
1000: LD_EXP 2
1004: PPUSH
1005: LD_INT 2
1007: PPUSH
1008: CALL_OW 336
// tmp := [ [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] , [ us_double_gun , us_laser , us_rocket_launcher , us_gatling_gun , us_cargo_bay ] ] ;
1012: LD_ADDR_VAR 0 2
1016: PUSH
1017: LD_INT 2
1019: PUSH
1020: LD_INT 3
1022: PUSH
1023: LD_INT 4
1025: PUSH
1026: LD_INT 5
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PUSH
1035: LD_INT 5
1037: PUSH
1038: LD_INT 9
1040: PUSH
1041: LD_INT 7
1043: PUSH
1044: LD_INT 4
1046: PUSH
1047: LD_INT 12
1049: PUSH
1050: EMPTY
1051: LIST
1052: LIST
1053: LIST
1054: LIST
1055: LIST
1056: PUSH
1057: EMPTY
1058: LIST
1059: LIST
1060: ST_TO_ADDR
// for i = 1 to 5 do
1061: LD_ADDR_VAR 0 3
1065: PUSH
1066: DOUBLE
1067: LD_INT 1
1069: DEC
1070: ST_TO_ADDR
1071: LD_INT 5
1073: PUSH
1074: FOR_TO
1075: IFFALSE 1259
// begin PrepareVehicle ( tmp [ 1 ] [ i mod 4 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , tmp [ 2 ] [ i mod 5 + 1 ] , 100 ) ;
1077: LD_VAR 0 2
1081: PUSH
1082: LD_INT 1
1084: ARRAY
1085: PUSH
1086: LD_VAR 0 3
1090: PUSH
1091: LD_INT 4
1093: MOD
1094: PUSH
1095: LD_INT 1
1097: PLUS
1098: ARRAY
1099: PPUSH
1100: LD_INT 1
1102: PUSH
1103: LD_INT 3
1105: PUSH
1106: EMPTY
1107: LIST
1108: LIST
1109: PUSH
1110: LD_INT 1
1112: PPUSH
1113: LD_INT 2
1115: PPUSH
1116: CALL_OW 12
1120: ARRAY
1121: PPUSH
1122: LD_INT 1
1124: PPUSH
1125: LD_VAR 0 2
1129: PUSH
1130: LD_INT 2
1132: ARRAY
1133: PUSH
1134: LD_VAR 0 3
1138: PUSH
1139: LD_INT 5
1141: MOD
1142: PUSH
1143: LD_INT 1
1145: PLUS
1146: ARRAY
1147: PPUSH
1148: LD_INT 100
1150: PPUSH
1151: CALL 553 0 5
// veh := CreateVehicle ;
1155: LD_ADDR_VAR 0 4
1159: PUSH
1160: CALL_OW 45
1164: ST_TO_ADDR
// SetDir ( veh , rand ( 0 , 5 ) ) ;
1165: LD_VAR 0 4
1169: PPUSH
1170: LD_INT 0
1172: PPUSH
1173: LD_INT 5
1175: PPUSH
1176: CALL_OW 12
1180: PPUSH
1181: CALL_OW 233
// if freedom then
1185: LD_EXP 4
1189: IFFALSE 1222
// begin if IsInArea ( freedom , freedom_base ) then
1191: LD_EXP 4
1195: PPUSH
1196: LD_INT 1
1198: PPUSH
1199: CALL_OW 308
1203: IFFALSE 1220
// PlaceUnitArea ( veh , freedom_base , false ) end else
1205: LD_VAR 0 4
1209: PPUSH
1210: LD_INT 1
1212: PPUSH
1213: LD_INT 0
1215: PPUSH
1216: CALL_OW 49
1220: GO 1257
// PlaceUnitXYR ( veh , GetX ( JMM ) , GetY ( JMM ) , 14 , false ) ;
1222: LD_VAR 0 4
1226: PPUSH
1227: LD_EXP 2
1231: PPUSH
1232: CALL_OW 250
1236: PPUSH
1237: LD_EXP 2
1241: PPUSH
1242: CALL_OW 251
1246: PPUSH
1247: LD_INT 14
1249: PPUSH
1250: LD_INT 0
1252: PPUSH
1253: CALL_OW 50
// end ;
1257: GO 1074
1259: POP
1260: POP
// uc_nation := 3 ;
1261: LD_ADDR_OWVAR 21
1265: PUSH
1266: LD_INT 3
1268: ST_TO_ADDR
// tmp := [ [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] ] ;
1269: LD_ADDR_VAR 0 2
1273: PUSH
1274: LD_INT 21
1276: PUSH
1277: LD_INT 22
1279: PUSH
1280: LD_INT 23
1282: PUSH
1283: LD_INT 24
1285: PUSH
1286: EMPTY
1287: LIST
1288: LIST
1289: LIST
1290: LIST
1291: PUSH
1292: LD_INT 43
1294: PUSH
1295: LD_INT 44
1297: PUSH
1298: LD_INT 45
1300: PUSH
1301: EMPTY
1302: LIST
1303: LIST
1304: LIST
1305: PUSH
1306: EMPTY
1307: LIST
1308: LIST
1309: ST_TO_ADDR
// for i = 1 to 5 do
1310: LD_ADDR_VAR 0 3
1314: PUSH
1315: DOUBLE
1316: LD_INT 1
1318: DEC
1319: ST_TO_ADDR
1320: LD_INT 5
1322: PUSH
1323: FOR_TO
1324: IFFALSE 1451
// begin PrepareVehicle ( tmp [ 1 ] [ i mod 4 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , tmp [ 2 ] [ i mod 3 + 1 ] , 100 ) ;
1326: LD_VAR 0 2
1330: PUSH
1331: LD_INT 1
1333: ARRAY
1334: PUSH
1335: LD_VAR 0 3
1339: PUSH
1340: LD_INT 4
1342: MOD
1343: PUSH
1344: LD_INT 1
1346: PLUS
1347: ARRAY
1348: PPUSH
1349: LD_INT 1
1351: PUSH
1352: LD_INT 3
1354: PUSH
1355: EMPTY
1356: LIST
1357: LIST
1358: PUSH
1359: LD_INT 1
1361: PPUSH
1362: LD_INT 2
1364: PPUSH
1365: CALL_OW 12
1369: ARRAY
1370: PPUSH
1371: LD_INT 1
1373: PPUSH
1374: LD_VAR 0 2
1378: PUSH
1379: LD_INT 2
1381: ARRAY
1382: PUSH
1383: LD_VAR 0 3
1387: PUSH
1388: LD_INT 3
1390: MOD
1391: PUSH
1392: LD_INT 1
1394: PLUS
1395: ARRAY
1396: PPUSH
1397: LD_INT 100
1399: PPUSH
1400: CALL 553 0 5
// veh := CreateVehicle ;
1404: LD_ADDR_VAR 0 4
1408: PUSH
1409: CALL_OW 45
1413: ST_TO_ADDR
// SetDir ( veh , rand ( 0 , 5 ) ) ;
1414: LD_VAR 0 4
1418: PPUSH
1419: LD_INT 0
1421: PPUSH
1422: LD_INT 5
1424: PPUSH
1425: CALL_OW 12
1429: PPUSH
1430: CALL_OW 233
// PlaceUnitArea ( veh , freedom_base , false ) ;
1434: LD_VAR 0 4
1438: PPUSH
1439: LD_INT 1
1441: PPUSH
1442: LD_INT 0
1444: PPUSH
1445: CALL_OW 49
// end ;
1449: GO 1323
1451: POP
1452: POP
// if not FilterAllUnits ( [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) then
1453: LD_INT 2
1455: PUSH
1456: LD_INT 34
1458: PUSH
1459: LD_INT 12
1461: PUSH
1462: EMPTY
1463: LIST
1464: LIST
1465: PUSH
1466: LD_INT 34
1468: PUSH
1469: LD_INT 51
1471: PUSH
1472: EMPTY
1473: LIST
1474: LIST
1475: PUSH
1476: EMPTY
1477: LIST
1478: LIST
1479: LIST
1480: PPUSH
1481: CALL_OW 69
1485: NOT
1486: IFFALSE 1552
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 0 ) ;
1488: LD_INT 22
1490: PPUSH
1491: LD_INT 3
1493: PPUSH
1494: LD_INT 1
1496: PPUSH
1497: LD_INT 51
1499: PPUSH
1500: LD_INT 0
1502: PPUSH
1503: CALL 553 0 5
// veh := CreateVehicle ;
1507: LD_ADDR_VAR 0 4
1511: PUSH
1512: CALL_OW 45
1516: ST_TO_ADDR
// SetDir ( veh , rand ( 0 , 5 ) ) ;
1517: LD_VAR 0 4
1521: PPUSH
1522: LD_INT 0
1524: PPUSH
1525: LD_INT 5
1527: PPUSH
1528: CALL_OW 12
1532: PPUSH
1533: CALL_OW 233
// PlaceUnitArea ( veh , freedom_base , false ) ;
1537: LD_VAR 0 4
1541: PPUSH
1542: LD_INT 1
1544: PPUSH
1545: LD_INT 0
1547: PPUSH
1548: CALL_OW 49
// end ; tmp := LoadVariable ( 13a_Masha , [ ] ) ;
1552: LD_ADDR_VAR 0 2
1556: PUSH
1557: LD_STRING 13a_Masha
1559: PPUSH
1560: EMPTY
1561: PPUSH
1562: CALL_OW 30
1566: ST_TO_ADDR
// if tmp then
1567: LD_VAR 0 2
1571: IFFALSE 1654
// begin PrepareVehicle ( tmp [ 1 ] , tmp [ 2 ] , tmp [ 3 ] , tmp [ 4 ] , 100 ) ;
1573: LD_VAR 0 2
1577: PUSH
1578: LD_INT 1
1580: ARRAY
1581: PPUSH
1582: LD_VAR 0 2
1586: PUSH
1587: LD_INT 2
1589: ARRAY
1590: PPUSH
1591: LD_VAR 0 2
1595: PUSH
1596: LD_INT 3
1598: ARRAY
1599: PPUSH
1600: LD_VAR 0 2
1604: PUSH
1605: LD_INT 4
1607: ARRAY
1608: PPUSH
1609: LD_INT 100
1611: PPUSH
1612: CALL 553 0 5
// Masha := CreateVehicle ;
1616: LD_ADDR_EXP 36
1620: PUSH
1621: CALL_OW 45
1625: ST_TO_ADDR
// PlaceUnitArea ( Masha , freedom_base , false ) ;
1626: LD_EXP 36
1630: PPUSH
1631: LD_INT 1
1633: PPUSH
1634: LD_INT 0
1636: PPUSH
1637: CALL_OW 49
// SetMark ( Masha , - 7 ) ;
1641: LD_EXP 36
1645: PPUSH
1646: LD_INT 7
1648: NEG
1649: PPUSH
1650: CALL_OW 242
// end ; uc_side := 4 ;
1654: LD_ADDR_OWVAR 20
1658: PUSH
1659: LD_INT 4
1661: ST_TO_ADDR
// tmp := [ ] ;
1662: LD_ADDR_VAR 0 2
1666: PUSH
1667: EMPTY
1668: ST_TO_ADDR
// squad1 := [ ] ;
1669: LD_ADDR_EXP 37
1673: PUSH
1674: EMPTY
1675: ST_TO_ADDR
// squad2 := [ ] ;
1676: LD_ADDR_EXP 38
1680: PUSH
1681: EMPTY
1682: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1683: LD_ADDR_EXP 19
1687: PUSH
1688: LD_STRING Joan
1690: PPUSH
1691: LD_EXP 1
1695: NOT
1696: PPUSH
1697: LD_STRING 13a_
1699: PPUSH
1700: CALL 490 0 3
1704: ST_TO_ADDR
// if Joan then
1705: LD_EXP 19
1709: IFFALSE 1727
// tmp := tmp ^ Joan ;
1711: LD_ADDR_VAR 0 2
1715: PUSH
1716: LD_VAR 0 2
1720: PUSH
1721: LD_EXP 19
1725: ADD
1726: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1727: LD_ADDR_EXP 5
1731: PUSH
1732: LD_STRING Roth
1734: PPUSH
1735: LD_EXP 1
1739: NOT
1740: PPUSH
1741: LD_STRING 13a_
1743: PPUSH
1744: CALL 490 0 3
1748: ST_TO_ADDR
// if Roth then
1749: LD_EXP 5
1753: IFFALSE 1771
// tmp := tmp ^ Roth ;
1755: LD_ADDR_VAR 0 2
1759: PUSH
1760: LD_VAR 0 2
1764: PUSH
1765: LD_EXP 5
1769: ADD
1770: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1771: LD_ADDR_EXP 10
1775: PUSH
1776: LD_STRING Denis
1778: PPUSH
1779: LD_EXP 1
1783: NOT
1784: PPUSH
1785: LD_STRING 13a_
1787: PPUSH
1788: CALL 490 0 3
1792: ST_TO_ADDR
// if Denis then
1793: LD_EXP 10
1797: IFFALSE 1815
// tmp := tmp ^ Denis ;
1799: LD_ADDR_VAR 0 2
1803: PUSH
1804: LD_VAR 0 2
1808: PUSH
1809: LD_EXP 10
1813: ADD
1814: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1815: LD_ADDR_EXP 20
1819: PUSH
1820: LD_STRING DeltaDoctor
1822: PPUSH
1823: LD_EXP 1
1827: NOT
1828: PPUSH
1829: LD_STRING 13a_
1831: PPUSH
1832: CALL 490 0 3
1836: ST_TO_ADDR
// if DeltaDoctor then
1837: LD_EXP 20
1841: IFFALSE 1859
// tmp := tmp ^ DeltaDoctor ;
1843: LD_ADDR_VAR 0 2
1847: PUSH
1848: LD_VAR 0 2
1852: PUSH
1853: LD_EXP 20
1857: ADD
1858: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1859: LD_ADDR_EXP 18
1863: PUSH
1864: LD_STRING Simms
1866: PPUSH
1867: LD_EXP 1
1871: NOT
1872: PPUSH
1873: LD_STRING 13a_
1875: PPUSH
1876: CALL 490 0 3
1880: ST_TO_ADDR
// if Simms then
1881: LD_EXP 18
1885: IFFALSE 1903
// tmp := tmp ^ Simms ;
1887: LD_ADDR_VAR 0 2
1891: PUSH
1892: LD_VAR 0 2
1896: PUSH
1897: LD_EXP 18
1901: ADD
1902: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1903: LD_ADDR_EXP 21
1907: PUSH
1908: LD_STRING Gossudarov
1910: PPUSH
1911: LD_EXP 1
1915: NOT
1916: PPUSH
1917: LD_STRING 13a_
1919: PPUSH
1920: CALL 490 0 3
1924: ST_TO_ADDR
// if Gossudarov then
1925: LD_EXP 21
1929: IFFALSE 1947
// tmp := tmp ^ Gossudarov ;
1931: LD_ADDR_VAR 0 2
1935: PUSH
1936: LD_VAR 0 2
1940: PUSH
1941: LD_EXP 21
1945: ADD
1946: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1947: LD_ADDR_EXP 22
1951: PUSH
1952: LD_STRING Kirilenkova
1954: PPUSH
1955: LD_EXP 1
1959: NOT
1960: PPUSH
1961: LD_STRING 13a_
1963: PPUSH
1964: CALL 490 0 3
1968: ST_TO_ADDR
// if Kirilenkova then
1969: LD_EXP 22
1973: IFFALSE 1991
// tmp := tmp ^ Kirilenkova ;
1975: LD_ADDR_VAR 0 2
1979: PUSH
1980: LD_VAR 0 2
1984: PUSH
1985: LD_EXP 22
1989: ADD
1990: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1991: LD_ADDR_EXP 25
1995: PUSH
1996: LD_STRING Petrosyan
1998: PPUSH
1999: LD_EXP 1
2003: NOT
2004: PPUSH
2005: LD_STRING 13a_
2007: PPUSH
2008: CALL 490 0 3
2012: ST_TO_ADDR
// if Petrosyan then
2013: LD_EXP 25
2017: IFFALSE 2035
// tmp := tmp ^ Petrosyan ;
2019: LD_ADDR_VAR 0 2
2023: PUSH
2024: LD_VAR 0 2
2028: PUSH
2029: LD_EXP 25
2033: ADD
2034: ST_TO_ADDR
// Scholtze := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
2035: LD_ADDR_EXP 26
2039: PUSH
2040: LD_STRING Petrosyan
2042: PPUSH
2043: LD_EXP 1
2047: NOT
2048: PPUSH
2049: LD_STRING 13a_
2051: PPUSH
2052: CALL 490 0 3
2056: ST_TO_ADDR
// if Scholtze then
2057: LD_EXP 26
2061: IFFALSE 2079
// tmp := tmp ^ Scholtze ;
2063: LD_ADDR_VAR 0 2
2067: PUSH
2068: LD_VAR 0 2
2072: PUSH
2073: LD_EXP 26
2077: ADD
2078: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
2079: LD_ADDR_EXP 24
2083: PUSH
2084: LD_STRING Dolgov
2086: PPUSH
2087: LD_EXP 1
2091: NOT
2092: PPUSH
2093: LD_STRING 13a_
2095: PPUSH
2096: CALL 490 0 3
2100: ST_TO_ADDR
// if Dolgov then
2101: LD_EXP 24
2105: IFFALSE 2123
// tmp := tmp ^ Dolgov ;
2107: LD_ADDR_VAR 0 2
2111: PUSH
2112: LD_VAR 0 2
2116: PUSH
2117: LD_EXP 24
2121: ADD
2122: ST_TO_ADDR
// for i in tmp do
2123: LD_ADDR_VAR 0 3
2127: PUSH
2128: LD_VAR 0 2
2132: PUSH
2133: FOR_IN
2134: IFFALSE 2159
// PlaceUnitXYR ( i , 160 , 78 , 22 , false ) ;
2136: LD_VAR 0 3
2140: PPUSH
2141: LD_INT 160
2143: PPUSH
2144: LD_INT 78
2146: PPUSH
2147: LD_INT 22
2149: PPUSH
2150: LD_INT 0
2152: PPUSH
2153: CALL_OW 50
2157: GO 2133
2159: POP
2160: POP
// squad1 := tmp ;
2161: LD_ADDR_EXP 37
2165: PUSH
2166: LD_VAR 0 2
2170: ST_TO_ADDR
// tmp := [ ] ;
2171: LD_ADDR_VAR 0 2
2175: PUSH
2176: EMPTY
2177: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrova , ( not debug ) , 13a_ ) ;
2178: LD_ADDR_EXP 30
2182: PUSH
2183: LD_STRING Petrova
2185: PPUSH
2186: LD_EXP 1
2190: NOT
2191: PPUSH
2192: LD_STRING 13a_
2194: PPUSH
2195: CALL 490 0 3
2199: ST_TO_ADDR
// if Petrovova then
2200: LD_EXP 30
2204: IFFALSE 2222
// tmp := tmp ^ Petrovova ;
2206: LD_ADDR_VAR 0 2
2210: PUSH
2211: LD_VAR 0 2
2215: PUSH
2216: LD_EXP 30
2220: ADD
2221: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
2222: LD_ADDR_EXP 23
2226: PUSH
2227: LD_STRING Titov
2229: PPUSH
2230: LD_EXP 1
2234: NOT
2235: PPUSH
2236: LD_STRING 13a_
2238: PPUSH
2239: CALL 490 0 3
2243: ST_TO_ADDR
// if Titov then
2244: LD_EXP 23
2248: IFFALSE 2266
// tmp := tmp ^ Titov ;
2250: LD_ADDR_VAR 0 2
2254: PUSH
2255: LD_VAR 0 2
2259: PUSH
2260: LD_EXP 23
2264: ADD
2265: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2266: LD_ADDR_EXP 33
2270: PUSH
2271: LD_STRING Karamazov
2273: PPUSH
2274: LD_EXP 1
2278: NOT
2279: PPUSH
2280: LD_STRING 13a_
2282: PPUSH
2283: CALL 490 0 3
2287: ST_TO_ADDR
// if Karamazov then
2288: LD_EXP 33
2292: IFFALSE 2310
// tmp := tmp ^ Karamazov ;
2294: LD_ADDR_VAR 0 2
2298: PUSH
2299: LD_VAR 0 2
2303: PUSH
2304: LD_EXP 33
2308: ADD
2309: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
2310: LD_ADDR_EXP 16
2314: PUSH
2315: LD_STRING Frank
2317: PPUSH
2318: LD_EXP 1
2322: NOT
2323: PPUSH
2324: LD_STRING 13a_
2326: PPUSH
2327: CALL 490 0 3
2331: ST_TO_ADDR
// if Frank then
2332: LD_EXP 16
2336: IFFALSE 2354
// tmp := tmp ^ Frank ;
2338: LD_ADDR_VAR 0 2
2342: PUSH
2343: LD_VAR 0 2
2347: PUSH
2348: LD_EXP 16
2352: ADD
2353: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2354: LD_ADDR_EXP 7
2358: PUSH
2359: LD_STRING Donaldson
2361: PPUSH
2362: LD_EXP 1
2366: NOT
2367: PPUSH
2368: LD_STRING 13a_
2370: PPUSH
2371: CALL 490 0 3
2375: ST_TO_ADDR
// if Donaldson then
2376: LD_EXP 7
2380: IFFALSE 2398
// tmp := tmp ^ Donaldson ;
2382: LD_ADDR_VAR 0 2
2386: PUSH
2387: LD_VAR 0 2
2391: PUSH
2392: LD_EXP 7
2396: ADD
2397: ST_TO_ADDR
// for i in tmp do
2398: LD_ADDR_VAR 0 3
2402: PUSH
2403: LD_VAR 0 2
2407: PUSH
2408: FOR_IN
2409: IFFALSE 2449
// begin PlaceUnitXYR ( i , 117 , 8 , 6 , false ) ;
2411: LD_VAR 0 3
2415: PPUSH
2416: LD_INT 117
2418: PPUSH
2419: LD_INT 8
2421: PPUSH
2422: LD_INT 6
2424: PPUSH
2425: LD_INT 0
2427: PPUSH
2428: CALL_OW 50
// ComTurnXY ( i , 117 , 8 ) ;
2432: LD_VAR 0 3
2436: PPUSH
2437: LD_INT 117
2439: PPUSH
2440: LD_INT 8
2442: PPUSH
2443: CALL_OW 118
// end ;
2447: GO 2408
2449: POP
2450: POP
// squad2 := tmp ;
2451: LD_ADDR_EXP 38
2455: PUSH
2456: LD_VAR 0 2
2460: ST_TO_ADDR
// uc_side := 0 ;
2461: LD_ADDR_OWVAR 20
2465: PUSH
2466: LD_INT 0
2468: ST_TO_ADDR
// uc_nation := 0 ;
2469: LD_ADDR_OWVAR 21
2473: PUSH
2474: LD_INT 0
2476: ST_TO_ADDR
// InitHc ;
2477: CALL_OW 19
// hc_importance := 0 ;
2481: LD_ADDR_OWVAR 32
2485: PUSH
2486: LD_INT 0
2488: ST_TO_ADDR
// hc_name := Find some goods! ;
2489: LD_ADDR_OWVAR 26
2493: PUSH
2494: LD_STRING Find some goods!
2496: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
2497: LD_INT 0
2499: PPUSH
2500: LD_INT 12
2502: PPUSH
2503: LD_INT 1
2505: PPUSH
2506: CALL_OW 380
// PlaceUnitXY ( CreateHuman , 96 , 108 , false ) ;
2510: CALL_OW 44
2514: PPUSH
2515: LD_INT 96
2517: PPUSH
2518: LD_INT 108
2520: PPUSH
2521: LD_INT 0
2523: PPUSH
2524: CALL_OW 48
// InitHc ;
2528: CALL_OW 19
// end ;
2532: LD_VAR 0 1
2536: RET
// every 3 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 0 ] ] ) do var Louis , veh ;
2537: LD_INT 22
2539: PUSH
2540: LD_INT 7
2542: PUSH
2543: EMPTY
2544: LIST
2545: LIST
2546: PUSH
2547: LD_INT 23
2549: PUSH
2550: LD_INT 0
2552: PUSH
2553: EMPTY
2554: LIST
2555: LIST
2556: PUSH
2557: EMPTY
2558: LIST
2559: LIST
2560: PPUSH
2561: CALL_OW 69
2565: IFFALSE 3030
2567: GO 2569
2569: DISABLE
2570: LD_INT 0
2572: PPUSH
2573: PPUSH
// begin InGameOn ;
2574: CALL_OW 8
// RemoveUnit ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 0 ] ] ) [ 1 ] ) ;
2578: LD_INT 22
2580: PUSH
2581: LD_INT 7
2583: PUSH
2584: EMPTY
2585: LIST
2586: LIST
2587: PUSH
2588: LD_INT 23
2590: PUSH
2591: LD_INT 0
2593: PUSH
2594: EMPTY
2595: LIST
2596: LIST
2597: PUSH
2598: EMPTY
2599: LIST
2600: LIST
2601: PPUSH
2602: CALL_OW 69
2606: PUSH
2607: LD_INT 1
2609: ARRAY
2610: PPUSH
2611: CALL_OW 64
// game_speed := 4 ;
2615: LD_ADDR_OWVAR 65
2619: PUSH
2620: LD_INT 4
2622: ST_TO_ADDR
// ComMoveXY ( JMM , 93 , 100 ) ;
2623: LD_EXP 2
2627: PPUSH
2628: LD_INT 93
2630: PPUSH
2631: LD_INT 100
2633: PPUSH
2634: CALL_OW 111
// ComMoveXY ( Burlak , 93 , 99 ) ;
2638: LD_EXP 3
2642: PPUSH
2643: LD_INT 93
2645: PPUSH
2646: LD_INT 99
2648: PPUSH
2649: CALL_OW 111
// AddComTurnXY ( [ JMM , Burlak ] , 81 , 112 ) ;
2653: LD_EXP 2
2657: PUSH
2658: LD_EXP 3
2662: PUSH
2663: EMPTY
2664: LIST
2665: LIST
2666: PPUSH
2667: LD_INT 81
2669: PPUSH
2670: LD_INT 112
2672: PPUSH
2673: CALL_OW 178
// wait ( 0 0$5 ) ;
2677: LD_INT 175
2679: PPUSH
2680: CALL_OW 67
// music_nat := 2 ;
2684: LD_ADDR_OWVAR 71
2688: PUSH
2689: LD_INT 2
2691: ST_TO_ADDR
// music_class := 4 ;
2692: LD_ADDR_OWVAR 72
2696: PUSH
2697: LD_INT 4
2699: ST_TO_ADDR
// CenterNowOnXY ( 80 , 130 ) ;
2700: LD_INT 80
2702: PPUSH
2703: LD_INT 130
2705: PPUSH
2706: CALL_OW 86
// uc_nation := 2 ;
2710: LD_ADDR_OWVAR 21
2714: PUSH
2715: LD_INT 2
2717: ST_TO_ADDR
// uc_side := 2 ;
2718: LD_ADDR_OWVAR 20
2722: PUSH
2723: LD_INT 2
2725: ST_TO_ADDR
// hc_gallery = sandar ;
2726: LD_ADDR_OWVAR 33
2730: PUSH
2731: LD_STRING sandar
2733: ST_TO_ADDR
// hc_face_number = 1 ;
2734: LD_ADDR_OWVAR 34
2738: PUSH
2739: LD_INT 1
2741: ST_TO_ADDR
// hc_name = Louis Schulz ;
2742: LD_ADDR_OWVAR 26
2746: PUSH
2747: LD_STRING Louis Schulz
2749: ST_TO_ADDR
// hc_attr = [ 13 , 11 ] ;
2750: LD_ADDR_OWVAR 29
2754: PUSH
2755: LD_INT 13
2757: PUSH
2758: LD_INT 11
2760: PUSH
2761: EMPTY
2762: LIST
2763: LIST
2764: ST_TO_ADDR
// hc_basic_skills = [ 0 , 0 , 0 , 0 ] ;
2765: LD_ADDR_OWVAR 30
2769: PUSH
2770: LD_INT 0
2772: PUSH
2773: LD_INT 0
2775: PUSH
2776: LD_INT 0
2778: PUSH
2779: LD_INT 0
2781: PUSH
2782: EMPTY
2783: LIST
2784: LIST
2785: LIST
2786: LIST
2787: ST_TO_ADDR
// hc_skills = [ 10 , 6 , 7 , 7 ] ;
2788: LD_ADDR_OWVAR 31
2792: PUSH
2793: LD_INT 10
2795: PUSH
2796: LD_INT 6
2798: PUSH
2799: LD_INT 7
2801: PUSH
2802: LD_INT 7
2804: PUSH
2805: EMPTY
2806: LIST
2807: LIST
2808: LIST
2809: LIST
2810: ST_TO_ADDR
// hc_sex = sex_male ;
2811: LD_ADDR_OWVAR 27
2815: PUSH
2816: LD_INT 1
2818: ST_TO_ADDR
// hc_class = 1 ;
2819: LD_ADDR_OWVAR 28
2823: PUSH
2824: LD_INT 1
2826: ST_TO_ADDR
// hc_importance = 100 ;
2827: LD_ADDR_OWVAR 32
2831: PUSH
2832: LD_INT 100
2834: ST_TO_ADDR
// Louis = CreateHuman ;
2835: LD_ADDR_VAR 0 1
2839: PUSH
2840: CALL_OW 44
2844: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_flame_thrower , 100 ) ;
2845: LD_INT 14
2847: PPUSH
2848: LD_INT 3
2850: PPUSH
2851: LD_INT 1
2853: PPUSH
2854: LD_INT 26
2856: PPUSH
2857: LD_INT 100
2859: PPUSH
2860: CALL 553 0 5
// veh := CreateVehicle ;
2864: LD_ADDR_VAR 0 2
2868: PUSH
2869: CALL_OW 45
2873: ST_TO_ADDR
// SetMark ( veh , - 2 ) ;
2874: LD_VAR 0 2
2878: PPUSH
2879: LD_INT 2
2881: NEG
2882: PPUSH
2883: CALL_OW 242
// PlaceUnitXY ( veh , 80 , 130 , false ) ;
2887: LD_VAR 0 2
2891: PPUSH
2892: LD_INT 80
2894: PPUSH
2895: LD_INT 130
2897: PPUSH
2898: LD_INT 0
2900: PPUSH
2901: CALL_OW 48
// PlaceHumanInUnit ( Louis , veh ) ;
2905: LD_VAR 0 1
2909: PPUSH
2910: LD_VAR 0 2
2914: PPUSH
2915: CALL_OW 52
// ComMoveXY ( Louis , 80 , 109 ) ;
2919: LD_VAR 0 1
2923: PPUSH
2924: LD_INT 80
2926: PPUSH
2927: LD_INT 109
2929: PPUSH
2930: CALL_OW 111
// AddComExitVehicle ( Louis ) ;
2934: LD_VAR 0 1
2938: PPUSH
2939: CALL_OW 181
// AddComMoveXY ( Louis , 80 , 131 ) ;
2943: LD_VAR 0 1
2947: PPUSH
2948: LD_INT 80
2950: PPUSH
2951: LD_INT 131
2953: PPUSH
2954: CALL_OW 171
// wait ( 0 0$06 ) ;
2958: LD_INT 210
2960: PPUSH
2961: CALL_OW 67
// InGameOff ;
2965: CALL_OW 9
// repeat wait ( 0 0$1 ) ;
2969: LD_INT 35
2971: PPUSH
2972: CALL_OW 67
// until IsAt ( Louis , 80 , 131 ) ;
2976: LD_VAR 0 1
2980: PPUSH
2981: LD_INT 80
2983: PPUSH
2984: LD_INT 131
2986: PPUSH
2987: CALL_OW 307
2991: IFFALSE 2969
// SetSide ( veh , 7 ) ;
2993: LD_VAR 0 2
2997: PPUSH
2998: LD_INT 7
3000: PPUSH
3001: CALL_OW 235
// RemoveUnit ( Louis ) ;
3005: LD_VAR 0 1
3009: PPUSH
3010: CALL_OW 64
// music_nat := 3 ;
3014: LD_ADDR_OWVAR 71
3018: PUSH
3019: LD_INT 3
3021: ST_TO_ADDR
// music_class := 0 ;
3022: LD_ADDR_OWVAR 72
3026: PUSH
3027: LD_INT 0
3029: ST_TO_ADDR
// end ;
3030: PPOPN 2
3032: END
// every 0 0$10 trigger squad1 do var i , xy ;
3033: LD_EXP 37
3037: IFFALSE 3400
3039: GO 3041
3041: DISABLE
3042: LD_INT 0
3044: PPUSH
3045: PPUSH
// begin enable ;
3046: ENABLE
// i := squad1 [ rand ( 1 , squad1 ) ] ;
3047: LD_ADDR_VAR 0 1
3051: PUSH
3052: LD_EXP 37
3056: PUSH
3057: LD_INT 1
3059: PPUSH
3060: LD_EXP 37
3064: PPUSH
3065: CALL_OW 12
3069: ARRAY
3070: ST_TO_ADDR
// if IsInUnit ( i ) then
3071: LD_VAR 0 1
3075: PPUSH
3076: CALL_OW 310
3080: IFFALSE 3084
// exit ;
3082: GO 3400
// ComRemember ( i ) ;
3084: LD_VAR 0 1
3088: PPUSH
3089: CALL_OW 143
// xy := [ ShiftX ( GetX ( i ) , rand ( 0 , 5 ) , rand ( 2 , 7 ) ) , ShiftY ( GetY ( i ) , rand ( 0 , 5 ) , rand ( 2 , 7 ) ) ] ;
3093: LD_ADDR_VAR 0 2
3097: PUSH
3098: LD_VAR 0 1
3102: PPUSH
3103: CALL_OW 250
3107: PPUSH
3108: LD_INT 0
3110: PPUSH
3111: LD_INT 5
3113: PPUSH
3114: CALL_OW 12
3118: PPUSH
3119: LD_INT 2
3121: PPUSH
3122: LD_INT 7
3124: PPUSH
3125: CALL_OW 12
3129: PPUSH
3130: CALL_OW 272
3134: PUSH
3135: LD_VAR 0 1
3139: PPUSH
3140: CALL_OW 251
3144: PPUSH
3145: LD_INT 0
3147: PPUSH
3148: LD_INT 5
3150: PPUSH
3151: CALL_OW 12
3155: PPUSH
3156: LD_INT 2
3158: PPUSH
3159: LD_INT 7
3161: PPUSH
3162: CALL_OW 12
3166: PPUSH
3167: CALL_OW 273
3171: PUSH
3172: EMPTY
3173: LIST
3174: LIST
3175: ST_TO_ADDR
// if HexInfo ( xy [ 1 ] , xy [ 2 ] ) <> 0 or not ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
3176: LD_VAR 0 2
3180: PUSH
3181: LD_INT 1
3183: ARRAY
3184: PPUSH
3185: LD_VAR 0 2
3189: PUSH
3190: LD_INT 2
3192: ARRAY
3193: PPUSH
3194: CALL_OW 428
3198: PUSH
3199: LD_INT 0
3201: NONEQUAL
3202: PUSH
3203: LD_VAR 0 2
3207: PUSH
3208: LD_INT 1
3210: ARRAY
3211: PPUSH
3212: LD_VAR 0 2
3216: PUSH
3217: LD_INT 2
3219: ARRAY
3220: PPUSH
3221: CALL_OW 488
3225: NOT
3226: OR
3227: IFFALSE 3231
// exit ;
3229: GO 3400
// AddComMoveXY ( i , xy [ 1 ] , xy [ 2 ] ) ;
3231: LD_VAR 0 1
3235: PPUSH
3236: LD_VAR 0 2
3240: PUSH
3241: LD_INT 1
3243: ARRAY
3244: PPUSH
3245: LD_VAR 0 2
3249: PUSH
3250: LD_INT 2
3252: ARRAY
3253: PPUSH
3254: CALL_OW 171
// AddComWait ( i , 0 0$10 ) ;
3258: LD_VAR 0 1
3262: PPUSH
3263: LD_INT 350
3265: PPUSH
3266: CALL_OW 202
// if Prob ( 60 ) and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) then
3270: LD_INT 60
3272: PPUSH
3273: CALL_OW 13
3277: PUSH
3278: LD_INT 22
3280: PUSH
3281: LD_INT 4
3283: PUSH
3284: EMPTY
3285: LIST
3286: LIST
3287: PUSH
3288: LD_INT 21
3290: PUSH
3291: LD_INT 3
3293: PUSH
3294: EMPTY
3295: LIST
3296: LIST
3297: PUSH
3298: EMPTY
3299: LIST
3300: LIST
3301: PPUSH
3302: CALL_OW 69
3306: AND
3307: IFFALSE 3391
// begin AddComEnterUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , i ) ) ;
3309: LD_VAR 0 1
3313: PPUSH
3314: LD_INT 22
3316: PUSH
3317: LD_INT 4
3319: PUSH
3320: EMPTY
3321: LIST
3322: LIST
3323: PUSH
3324: LD_INT 21
3326: PUSH
3327: LD_INT 3
3329: PUSH
3330: EMPTY
3331: LIST
3332: LIST
3333: PUSH
3334: EMPTY
3335: LIST
3336: LIST
3337: PPUSH
3338: CALL_OW 69
3342: PPUSH
3343: LD_VAR 0 1
3347: PPUSH
3348: CALL_OW 74
3352: PPUSH
3353: CALL_OW 180
// repeat wait ( 0 0$30 ) ;
3357: LD_INT 1050
3359: PPUSH
3360: CALL_OW 67
// until IsInUnit ( i ) ;
3364: LD_VAR 0 1
3368: PPUSH
3369: CALL_OW 310
3373: IFFALSE 3357
// wait ( 0 0$30 ) ;
3375: LD_INT 1050
3377: PPUSH
3378: CALL_OW 67
// AddComExitBuilding ( i ) ;
3382: LD_VAR 0 1
3386: PPUSH
3387: CALL_OW 182
// end ; AddComReturn ( i ) ;
3391: LD_VAR 0 1
3395: PPUSH
3396: CALL_OW 204
// end ; end_of_file
3400: PPOPN 2
3402: END
// export function Action ; begin
3403: LD_INT 0
3405: PPUSH
// InGameOn ;
3406: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
3410: LD_EXP 2
3414: PPUSH
3415: CALL_OW 87
// Say ( JMM , D1-JMM-1 ) ;
3419: LD_EXP 2
3423: PPUSH
3424: LD_STRING D1-JMM-1
3426: PPUSH
3427: CALL_OW 88
// Say ( Burlak , D1-Bur-1 ) ;
3431: LD_EXP 3
3435: PPUSH
3436: LD_STRING D1-Bur-1
3438: PPUSH
3439: CALL_OW 88
// Say ( JMM , D1-JMM-2 ) ;
3443: LD_EXP 2
3447: PPUSH
3448: LD_STRING D1-JMM-2
3450: PPUSH
3451: CALL_OW 88
// Say ( Burlak , D1-Bur-2 ) ;
3455: LD_EXP 3
3459: PPUSH
3460: LD_STRING D1-Bur-2
3462: PPUSH
3463: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
3467: LD_EXP 2
3471: PPUSH
3472: LD_STRING D1-JMM-3
3474: PPUSH
3475: CALL_OW 88
// Say ( Burlak , D1-Bur-3 ) ;
3479: LD_EXP 3
3483: PPUSH
3484: LD_STRING D1-Bur-3
3486: PPUSH
3487: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
3491: LD_EXP 2
3495: PPUSH
3496: LD_STRING D1-JMM-4
3498: PPUSH
3499: CALL_OW 88
// Say ( Burlak , D1-Bur-4 ) ;
3503: LD_EXP 3
3507: PPUSH
3508: LD_STRING D1-Bur-4
3510: PPUSH
3511: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
3515: LD_EXP 2
3519: PPUSH
3520: LD_STRING D1-JMM-5
3522: PPUSH
3523: CALL_OW 88
// Say ( Burlak , D1-Bur-5 ) ;
3527: LD_EXP 3
3531: PPUSH
3532: LD_STRING D1-Bur-5
3534: PPUSH
3535: CALL_OW 88
// Say ( JMM , D1-JMM-6 ) ;
3539: LD_EXP 2
3543: PPUSH
3544: LD_STRING D1-JMM-6
3546: PPUSH
3547: CALL_OW 88
// Say ( Burlak , D1-Bur-6 ) ;
3551: LD_EXP 3
3555: PPUSH
3556: LD_STRING D1-Bur-6
3558: PPUSH
3559: CALL_OW 88
// Say ( JMM , D1-JMM-7 ) ;
3563: LD_EXP 2
3567: PPUSH
3568: LD_STRING D1-JMM-7
3570: PPUSH
3571: CALL_OW 88
// wait ( 20 ) ;
3575: LD_INT 20
3577: PPUSH
3578: CALL_OW 67
// Query ( QTruck ) ;
3582: LD_STRING QTruck
3584: PPUSH
3585: CALL_OW 97
// InGameOff ;
3589: CALL_OW 9
// ChangeMissionObjectives ( MArtPickup ) ;
3593: LD_STRING MArtPickup
3595: PPUSH
3596: CALL_OW 337
// SetAreaMapShow ( escape_area , 1 ) ;
3600: LD_INT 2
3602: PPUSH
3603: LD_INT 1
3605: PPUSH
3606: CALL_OW 424
// end ;
3610: LD_VAR 0 1
3614: RET
// every 0 0$3 trigger FilterUnitsInArea ( escape_area , [ [ f_type , unit_vehicle ] , [ f_control , control_manual ] , [ f_not , [ f_empty ] ] ] ) = 2 and IsInUnit ( JMM ) and IsInUnit ( Burlak ) and ( GetWeapon ( IsInUnit ( JMM ) ) in [ ru_cargo_bay , us_cargo_bay , ru_big_cargo_bay , ar_cargo_bay ] or GetWeapon ( IsInUnit ( Burlak ) ) in [ ru_cargo_bay , us_cargo_bay , ru_big_cargo_bay , ar_cargo_bay ] ) do var i , macmilanVeh , burlakVeh ;
3615: LD_INT 2
3617: PPUSH
3618: LD_INT 21
3620: PUSH
3621: LD_INT 2
3623: PUSH
3624: EMPTY
3625: LIST
3626: LIST
3627: PUSH
3628: LD_INT 33
3630: PUSH
3631: LD_INT 1
3633: PUSH
3634: EMPTY
3635: LIST
3636: LIST
3637: PUSH
3638: LD_INT 3
3640: PUSH
3641: LD_INT 58
3643: PUSH
3644: EMPTY
3645: LIST
3646: PUSH
3647: EMPTY
3648: LIST
3649: LIST
3650: PUSH
3651: EMPTY
3652: LIST
3653: LIST
3654: LIST
3655: PPUSH
3656: CALL_OW 70
3660: PUSH
3661: LD_INT 2
3663: EQUAL
3664: PUSH
3665: LD_EXP 2
3669: PPUSH
3670: CALL_OW 310
3674: AND
3675: PUSH
3676: LD_EXP 3
3680: PPUSH
3681: CALL_OW 310
3685: AND
3686: PUSH
3687: LD_EXP 2
3691: PPUSH
3692: CALL_OW 310
3696: PPUSH
3697: CALL_OW 264
3701: PUSH
3702: LD_INT 51
3704: PUSH
3705: LD_INT 12
3707: PUSH
3708: LD_EXP 40
3712: PUSH
3713: LD_INT 32
3715: PUSH
3716: EMPTY
3717: LIST
3718: LIST
3719: LIST
3720: LIST
3721: IN
3722: PUSH
3723: LD_EXP 3
3727: PPUSH
3728: CALL_OW 310
3732: PPUSH
3733: CALL_OW 264
3737: PUSH
3738: LD_INT 51
3740: PUSH
3741: LD_INT 12
3743: PUSH
3744: LD_EXP 40
3748: PUSH
3749: LD_INT 32
3751: PUSH
3752: EMPTY
3753: LIST
3754: LIST
3755: LIST
3756: LIST
3757: IN
3758: OR
3759: AND
3760: IFFALSE 3970
3762: GO 3764
3764: DISABLE
3765: LD_INT 0
3767: PPUSH
3768: PPUSH
3769: PPUSH
// begin macmilanVeh := IsInUnit ( JMM ) ;
3770: LD_ADDR_VAR 0 2
3774: PUSH
3775: LD_EXP 2
3779: PPUSH
3780: CALL_OW 310
3784: ST_TO_ADDR
// burlakVeh := IsInUnit ( Burlak ) ;
3785: LD_ADDR_VAR 0 3
3789: PUSH
3790: LD_EXP 3
3794: PPUSH
3795: CALL_OW 310
3799: ST_TO_ADDR
// SaveVariable ( [ GetChassis ( macmilanVeh ) , GetEngine ( macmilanVeh ) , control_manual , GetWeapon ( macmilanVeh ) , GetMark ( macmilanVeh ) , GetNation ( macmilanVeh ) ] , 14a_JMMVeh ) ;
3800: LD_VAR 0 2
3804: PPUSH
3805: CALL_OW 265
3809: PUSH
3810: LD_VAR 0 2
3814: PPUSH
3815: CALL_OW 262
3819: PUSH
3820: LD_INT 1
3822: PUSH
3823: LD_VAR 0 2
3827: PPUSH
3828: CALL_OW 264
3832: PUSH
3833: LD_VAR 0 2
3837: PPUSH
3838: CALL_OW 271
3842: PUSH
3843: LD_VAR 0 2
3847: PPUSH
3848: CALL_OW 248
3852: PUSH
3853: EMPTY
3854: LIST
3855: LIST
3856: LIST
3857: LIST
3858: LIST
3859: LIST
3860: PPUSH
3861: LD_STRING 14a_JMMVeh
3863: PPUSH
3864: CALL_OW 39
// SaveVariable ( [ GetChassis ( burlakVeh ) , GetEngine ( burlakVeh ) , control_manual , GetWeapon ( burlakVeh ) , GetMark ( burlakVeh ) , GetNation ( burlakVeh ) ] , 14a_BurlakVeh ) ;
3868: LD_VAR 0 3
3872: PPUSH
3873: CALL_OW 265
3877: PUSH
3878: LD_VAR 0 3
3882: PPUSH
3883: CALL_OW 262
3887: PUSH
3888: LD_INT 1
3890: PUSH
3891: LD_VAR 0 3
3895: PPUSH
3896: CALL_OW 264
3900: PUSH
3901: LD_VAR 0 3
3905: PPUSH
3906: CALL_OW 271
3910: PUSH
3911: LD_VAR 0 3
3915: PPUSH
3916: CALL_OW 248
3920: PUSH
3921: EMPTY
3922: LIST
3923: LIST
3924: LIST
3925: LIST
3926: LIST
3927: LIST
3928: PPUSH
3929: LD_STRING 14a_BurlakVeh
3931: PPUSH
3932: CALL_OW 39
// SaveCharacters ( JMM , 14a_JMM ) ;
3936: LD_EXP 2
3940: PPUSH
3941: LD_STRING 14a_JMM
3943: PPUSH
3944: CALL_OW 38
// SaveCharacters ( Burlak , 14a_Burlak ) ;
3948: LD_EXP 3
3952: PPUSH
3953: LD_STRING 14a_Burlak
3955: PPUSH
3956: CALL_OW 38
// ChangeMap ( 1 , %_cont ) ;
3960: LD_INT 1
3962: PPUSH
3963: LD_STRING %_cont
3965: PPUSH
3966: CALL_OW 340
// end ;
3970: PPOPN 3
3972: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_lives , 950 ] ] ] ) do
3973: LD_INT 22
3975: PUSH
3976: LD_INT 4
3978: PUSH
3979: EMPTY
3980: LIST
3981: LIST
3982: PUSH
3983: LD_INT 3
3985: PUSH
3986: LD_INT 24
3988: PUSH
3989: LD_INT 950
3991: PUSH
3992: EMPTY
3993: LIST
3994: LIST
3995: PUSH
3996: EMPTY
3997: LIST
3998: LIST
3999: PUSH
4000: EMPTY
4001: LIST
4002: LIST
4003: PPUSH
4004: CALL_OW 69
4008: IFFALSE 4020
4010: GO 4012
4012: DISABLE
// YouLost ( FriendlyFire ) ;
4013: LD_STRING FriendlyFire
4015: PPUSH
4016: CALL_OW 104
4020: END
// every 0 0$1 trigger IsDead ( Burlak ) do
4021: LD_EXP 3
4025: PPUSH
4026: CALL_OW 301
4030: IFFALSE 4042
4032: GO 4034
4034: DISABLE
// YouLost ( Burlak ) ;
4035: LD_STRING Burlak
4037: PPUSH
4038: CALL_OW 104
4042: END
// every 0 0$1 trigger IsDead ( JMM ) do
4043: LD_EXP 2
4047: PPUSH
4048: CALL_OW 301
4052: IFFALSE 4064
4054: GO 4056
4056: DISABLE
// YouLost ( JMM ) ; end_of_file
4057: LD_STRING JMM
4059: PPUSH
4060: CALL_OW 104
4064: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
4065: GO 4067
4067: DISABLE
// begin ru_radar := 98 ;
4068: LD_ADDR_EXP 39
4072: PUSH
4073: LD_INT 98
4075: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
4076: LD_ADDR_EXP 40
4080: PUSH
4081: LD_INT 89
4083: ST_TO_ADDR
// us_hack := 99 ;
4084: LD_ADDR_EXP 41
4088: PUSH
4089: LD_INT 99
4091: ST_TO_ADDR
// us_artillery := 97 ;
4092: LD_ADDR_EXP 42
4096: PUSH
4097: LD_INT 97
4099: ST_TO_ADDR
// ar_bio_bomb := 91 ;
4100: LD_ADDR_EXP 43
4104: PUSH
4105: LD_INT 91
4107: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
4108: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
4109: LD_INT 0
4111: PPUSH
4112: PPUSH
4113: PPUSH
4114: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
4115: LD_VAR 0 1
4119: PPUSH
4120: CALL_OW 264
4124: PUSH
4125: LD_EXP 43
4129: EQUAL
4130: IFFALSE 4202
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
4132: LD_INT 68
4134: PPUSH
4135: LD_VAR 0 1
4139: PPUSH
4140: CALL_OW 255
4144: PPUSH
4145: CALL_OW 321
4149: PUSH
4150: LD_INT 2
4152: EQUAL
4153: IFFALSE 4165
// eff := 70 else
4155: LD_ADDR_VAR 0 6
4159: PUSH
4160: LD_INT 70
4162: ST_TO_ADDR
4163: GO 4173
// eff := 30 ;
4165: LD_ADDR_VAR 0 6
4169: PUSH
4170: LD_INT 30
4172: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
4173: LD_VAR 0 1
4177: PPUSH
4178: CALL_OW 250
4182: PPUSH
4183: LD_VAR 0 1
4187: PPUSH
4188: CALL_OW 251
4192: PPUSH
4193: LD_VAR 0 6
4197: PPUSH
4198: CALL_OW 495
// end ; end ;
4202: LD_VAR 0 4
4206: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
4207: LD_INT 0
4209: PPUSH
4210: PPUSH
4211: PPUSH
4212: PPUSH
4213: PPUSH
4214: PPUSH
// if cmd = 124 then
4215: LD_VAR 0 1
4219: PUSH
4220: LD_INT 124
4222: EQUAL
4223: IFFALSE 4429
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
4225: LD_ADDR_VAR 0 5
4229: PUSH
4230: LD_INT 2
4232: PUSH
4233: LD_INT 34
4235: PUSH
4236: LD_INT 53
4238: PUSH
4239: EMPTY
4240: LIST
4241: LIST
4242: PUSH
4243: LD_INT 34
4245: PUSH
4246: LD_INT 14
4248: PUSH
4249: EMPTY
4250: LIST
4251: LIST
4252: PUSH
4253: EMPTY
4254: LIST
4255: LIST
4256: LIST
4257: PPUSH
4258: CALL_OW 69
4262: ST_TO_ADDR
// if not tmp then
4263: LD_VAR 0 5
4267: NOT
4268: IFFALSE 4272
// exit ;
4270: GO 4429
// for i in tmp do
4272: LD_ADDR_VAR 0 3
4276: PUSH
4277: LD_VAR 0 5
4281: PUSH
4282: FOR_IN
4283: IFFALSE 4427
// begin taskList := GetTaskList ( i ) ;
4285: LD_ADDR_VAR 0 6
4289: PUSH
4290: LD_VAR 0 3
4294: PPUSH
4295: CALL_OW 437
4299: ST_TO_ADDR
// if not taskList then
4300: LD_VAR 0 6
4304: NOT
4305: IFFALSE 4309
// continue ;
4307: GO 4282
// for j = 1 to taskList do
4309: LD_ADDR_VAR 0 4
4313: PUSH
4314: DOUBLE
4315: LD_INT 1
4317: DEC
4318: ST_TO_ADDR
4319: LD_VAR 0 6
4323: PUSH
4324: FOR_TO
4325: IFFALSE 4423
// if taskList [ j ] [ 1 ] = | then
4327: LD_VAR 0 6
4331: PUSH
4332: LD_VAR 0 4
4336: ARRAY
4337: PUSH
4338: LD_INT 1
4340: ARRAY
4341: PUSH
4342: LD_STRING |
4344: EQUAL
4345: IFFALSE 4421
// begin _taskList := Delete ( taskList , 1 ) ;
4347: LD_ADDR_VAR 0 7
4351: PUSH
4352: LD_VAR 0 6
4356: PPUSH
4357: LD_INT 1
4359: PPUSH
4360: CALL_OW 3
4364: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
4365: LD_VAR 0 3
4369: PPUSH
4370: LD_VAR 0 7
4374: PPUSH
4375: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
4379: LD_VAR 0 3
4383: PPUSH
4384: LD_VAR 0 6
4388: PUSH
4389: LD_VAR 0 4
4393: ARRAY
4394: PUSH
4395: LD_INT 2
4397: ARRAY
4398: PPUSH
4399: LD_VAR 0 6
4403: PUSH
4404: LD_VAR 0 4
4408: ARRAY
4409: PUSH
4410: LD_INT 3
4412: ARRAY
4413: PPUSH
4414: LD_INT 8
4416: PPUSH
4417: CALL 4434 0 4
// end ;
4421: GO 4324
4423: POP
4424: POP
// end ;
4425: GO 4282
4427: POP
4428: POP
// end ; end ;
4429: LD_VAR 0 2
4433: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
4434: LD_INT 0
4436: PPUSH
4437: PPUSH
4438: PPUSH
4439: PPUSH
4440: PPUSH
4441: PPUSH
4442: PPUSH
4443: PPUSH
4444: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
4445: LD_VAR 0 1
4449: NOT
4450: PUSH
4451: LD_VAR 0 2
4455: PPUSH
4456: LD_VAR 0 3
4460: PPUSH
4461: CALL_OW 488
4465: NOT
4466: OR
4467: PUSH
4468: LD_VAR 0 4
4472: NOT
4473: OR
4474: IFFALSE 4478
// exit ;
4476: GO 4818
// list := [ ] ;
4478: LD_ADDR_VAR 0 13
4482: PUSH
4483: EMPTY
4484: ST_TO_ADDR
// if x - r < 0 then
4485: LD_VAR 0 2
4489: PUSH
4490: LD_VAR 0 4
4494: MINUS
4495: PUSH
4496: LD_INT 0
4498: LESS
4499: IFFALSE 4511
// min_x := 0 else
4501: LD_ADDR_VAR 0 7
4505: PUSH
4506: LD_INT 0
4508: ST_TO_ADDR
4509: GO 4527
// min_x := x - r ;
4511: LD_ADDR_VAR 0 7
4515: PUSH
4516: LD_VAR 0 2
4520: PUSH
4521: LD_VAR 0 4
4525: MINUS
4526: ST_TO_ADDR
// if y - r < 0 then
4527: LD_VAR 0 3
4531: PUSH
4532: LD_VAR 0 4
4536: MINUS
4537: PUSH
4538: LD_INT 0
4540: LESS
4541: IFFALSE 4553
// min_y := 0 else
4543: LD_ADDR_VAR 0 8
4547: PUSH
4548: LD_INT 0
4550: ST_TO_ADDR
4551: GO 4569
// min_y := y - r ;
4553: LD_ADDR_VAR 0 8
4557: PUSH
4558: LD_VAR 0 3
4562: PUSH
4563: LD_VAR 0 4
4567: MINUS
4568: ST_TO_ADDR
// max_x := x + r ;
4569: LD_ADDR_VAR 0 9
4573: PUSH
4574: LD_VAR 0 2
4578: PUSH
4579: LD_VAR 0 4
4583: PLUS
4584: ST_TO_ADDR
// max_y := y + r ;
4585: LD_ADDR_VAR 0 10
4589: PUSH
4590: LD_VAR 0 3
4594: PUSH
4595: LD_VAR 0 4
4599: PLUS
4600: ST_TO_ADDR
// for _x = min_x to max_x do
4601: LD_ADDR_VAR 0 11
4605: PUSH
4606: DOUBLE
4607: LD_VAR 0 7
4611: DEC
4612: ST_TO_ADDR
4613: LD_VAR 0 9
4617: PUSH
4618: FOR_TO
4619: IFFALSE 4736
// for _y = min_y to max_y do
4621: LD_ADDR_VAR 0 12
4625: PUSH
4626: DOUBLE
4627: LD_VAR 0 8
4631: DEC
4632: ST_TO_ADDR
4633: LD_VAR 0 10
4637: PUSH
4638: FOR_TO
4639: IFFALSE 4732
// begin if not ValidHex ( _x , _y ) then
4641: LD_VAR 0 11
4645: PPUSH
4646: LD_VAR 0 12
4650: PPUSH
4651: CALL_OW 488
4655: NOT
4656: IFFALSE 4660
// continue ;
4658: GO 4638
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
4660: LD_VAR 0 11
4664: PPUSH
4665: LD_VAR 0 12
4669: PPUSH
4670: CALL_OW 351
4674: PUSH
4675: LD_VAR 0 11
4679: PPUSH
4680: LD_VAR 0 12
4684: PPUSH
4685: CALL_OW 554
4689: AND
4690: IFFALSE 4730
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
4692: LD_ADDR_VAR 0 13
4696: PUSH
4697: LD_VAR 0 13
4701: PPUSH
4702: LD_VAR 0 13
4706: PUSH
4707: LD_INT 1
4709: PLUS
4710: PPUSH
4711: LD_VAR 0 11
4715: PUSH
4716: LD_VAR 0 12
4720: PUSH
4721: EMPTY
4722: LIST
4723: LIST
4724: PPUSH
4725: CALL_OW 2
4729: ST_TO_ADDR
// end ;
4730: GO 4638
4732: POP
4733: POP
4734: GO 4618
4736: POP
4737: POP
// if not list then
4738: LD_VAR 0 13
4742: NOT
4743: IFFALSE 4747
// exit ;
4745: GO 4818
// for i in list do
4747: LD_ADDR_VAR 0 6
4751: PUSH
4752: LD_VAR 0 13
4756: PUSH
4757: FOR_IN
4758: IFFALSE 4816
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
4760: LD_VAR 0 1
4764: PPUSH
4765: LD_STRING M
4767: PUSH
4768: LD_VAR 0 6
4772: PUSH
4773: LD_INT 1
4775: ARRAY
4776: PUSH
4777: LD_VAR 0 6
4781: PUSH
4782: LD_INT 2
4784: ARRAY
4785: PUSH
4786: LD_INT 0
4788: PUSH
4789: LD_INT 0
4791: PUSH
4792: LD_INT 0
4794: PUSH
4795: LD_INT 0
4797: PUSH
4798: EMPTY
4799: LIST
4800: LIST
4801: LIST
4802: LIST
4803: LIST
4804: LIST
4805: LIST
4806: PUSH
4807: EMPTY
4808: LIST
4809: PPUSH
4810: CALL_OW 447
4814: GO 4757
4816: POP
4817: POP
// end ;
4818: LD_VAR 0 5
4822: RET
