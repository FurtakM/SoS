// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// FogOff ( 7 ) ;
  11: LD_INT 7
  13: PPUSH
  14: CALL_OW 344
// RandomizeAll ;
  18: CALL_OW 11
// InitVariables ;
  22: CALL 66 0 0
// LoadBuildings ;
  26: CALL 82 0 0
// PrepareAlliance ;
  30: CALL 599 0 0
// music_nat := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
  34: LD_ADDR_OWVAR 71
  38: PUSH
  39: LD_INT 1
  41: PUSH
  42: LD_INT 3
  44: PUSH
  45: EMPTY
  46: LIST
  47: LIST
  48: PUSH
  49: LD_INT 1
  51: PPUSH
  52: LD_INT 2
  54: PPUSH
  55: CALL_OW 12
  59: ARRAY
  60: ST_TO_ADDR
// Action ;
  61: CALL 3348 0 0
// end ;
  65: END
// export debug ; export function InitVariables ; begin
  66: LD_INT 0
  68: PPUSH
// debug := false ;
  69: LD_ADDR_EXP 1
  73: PUSH
  74: LD_INT 0
  76: ST_TO_ADDR
// end ; end_of_file
  77: LD_VAR 0 1
  81: RET
// export function LoadBuildings ; var i , tmp , b ; begin
  82: LD_INT 0
  84: PPUSH
  85: PPUSH
  86: PPUSH
  87: PPUSH
// tmp := LoadVariable ( 13a_buildings , [ [ 7 , 1 , b_warehouse , 70 , 46 , 3 , 10 , 0 , 0 , 0 ] ] ) ;
  88: LD_ADDR_VAR 0 3
  92: PUSH
  93: LD_STRING 13a_buildings
  95: PPUSH
  96: LD_INT 7
  98: PUSH
  99: LD_INT 1
 101: PUSH
 102: LD_INT 1
 104: PUSH
 105: LD_INT 70
 107: PUSH
 108: LD_INT 46
 110: PUSH
 111: LD_INT 3
 113: PUSH
 114: LD_INT 10
 116: PUSH
 117: LD_INT 0
 119: PUSH
 120: LD_INT 0
 122: PUSH
 123: LD_INT 0
 125: PUSH
 126: EMPTY
 127: LIST
 128: LIST
 129: LIST
 130: LIST
 131: LIST
 132: LIST
 133: LIST
 134: LIST
 135: LIST
 136: LIST
 137: PUSH
 138: EMPTY
 139: LIST
 140: PPUSH
 141: CALL_OW 30
 145: ST_TO_ADDR
// bc_kind1 := - 1 ;
 146: LD_ADDR_OWVAR 44
 150: PUSH
 151: LD_INT 1
 153: NEG
 154: ST_TO_ADDR
// bc_kind2 := - 1 ;
 155: LD_ADDR_OWVAR 45
 159: PUSH
 160: LD_INT 1
 162: NEG
 163: ST_TO_ADDR
// for i in tmp do
 164: LD_ADDR_VAR 0 2
 168: PUSH
 169: LD_VAR 0 3
 173: PUSH
 174: FOR_IN
 175: IFFALSE 420
// begin uc_side := 7 ;
 177: LD_ADDR_OWVAR 20
 181: PUSH
 182: LD_INT 7
 184: ST_TO_ADDR
// uc_nation := i [ 2 ] ;
 185: LD_ADDR_OWVAR 21
 189: PUSH
 190: LD_VAR 0 2
 194: PUSH
 195: LD_INT 2
 197: ARRAY
 198: ST_TO_ADDR
// if i [ 2 ] = 2 then
 199: LD_VAR 0 2
 203: PUSH
 204: LD_INT 2
 206: ARRAY
 207: PUSH
 208: LD_INT 2
 210: EQUAL
 211: IFFALSE 221
// uc_side := 4 ;
 213: LD_ADDR_OWVAR 20
 217: PUSH
 218: LD_INT 4
 220: ST_TO_ADDR
// bc_type := i [ 3 ] ;
 221: LD_ADDR_OWVAR 42
 225: PUSH
 226: LD_VAR 0 2
 230: PUSH
 231: LD_INT 3
 233: ARRAY
 234: ST_TO_ADDR
// if i [ 3 ] in [ b_oil_mine , b_siberite_mine ] then
 235: LD_VAR 0 2
 239: PUSH
 240: LD_INT 3
 242: ARRAY
 243: PUSH
 244: LD_INT 29
 246: PUSH
 247: LD_INT 30
 249: PUSH
 250: EMPTY
 251: LIST
 252: LIST
 253: IN
 254: IFFALSE 287
// SetResourceVisibility ( i [ 4 ] , i [ 5 ] , i [ 1 ] ) ;
 256: LD_VAR 0 2
 260: PUSH
 261: LD_INT 4
 263: ARRAY
 264: PPUSH
 265: LD_VAR 0 2
 269: PUSH
 270: LD_INT 5
 272: ARRAY
 273: PPUSH
 274: LD_VAR 0 2
 278: PUSH
 279: LD_INT 1
 281: ARRAY
 282: PPUSH
 283: CALL_OW 441
// if i [ 8 ] then
 287: LD_VAR 0 2
 291: PUSH
 292: LD_INT 8
 294: ARRAY
 295: IFFALSE 311
// bc_kind1 := i [ 8 ] ;
 297: LD_ADDR_OWVAR 44
 301: PUSH
 302: LD_VAR 0 2
 306: PUSH
 307: LD_INT 8
 309: ARRAY
 310: ST_TO_ADDR
// if i [ 9 ] then
 311: LD_VAR 0 2
 315: PUSH
 316: LD_INT 9
 318: ARRAY
 319: IFFALSE 335
// bc_kind2 := i [ 9 ] ;
 321: LD_ADDR_OWVAR 45
 325: PUSH
 326: LD_VAR 0 2
 330: PUSH
 331: LD_INT 9
 333: ARRAY
 334: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( i [ 4 ] , i [ 5 ] , i [ 6 ] ) ;
 335: LD_ADDR_VAR 0 4
 339: PUSH
 340: LD_VAR 0 2
 344: PUSH
 345: LD_INT 4
 347: ARRAY
 348: PPUSH
 349: LD_VAR 0 2
 353: PUSH
 354: LD_INT 5
 356: ARRAY
 357: PPUSH
 358: LD_VAR 0 2
 362: PUSH
 363: LD_INT 6
 365: ARRAY
 366: PPUSH
 367: CALL_OW 47
 371: ST_TO_ADDR
// SetBLevel ( b , i [ 7 ] ) ;
 372: LD_VAR 0 4
 376: PPUSH
 377: LD_VAR 0 2
 381: PUSH
 382: LD_INT 7
 384: ARRAY
 385: PPUSH
 386: CALL_OW 241
// if i [ 10 ] then
 390: LD_VAR 0 2
 394: PUSH
 395: LD_INT 10
 397: ARRAY
 398: IFFALSE 418
// PlaceWeaponTurret ( b , i [ 10 ] ) ;
 400: LD_VAR 0 4
 404: PPUSH
 405: LD_VAR 0 2
 409: PUSH
 410: LD_INT 10
 412: ARRAY
 413: PPUSH
 414: CALL_OW 431
// end ;
 418: GO 174
 420: POP
 421: POP
// if HexInfo ( 144 , 65 ) = 0 then
 422: LD_INT 144
 424: PPUSH
 425: LD_INT 65
 427: PPUSH
 428: CALL_OW 428
 432: PUSH
 433: LD_INT 0
 435: EQUAL
 436: IFFALSE 473
// begin uc_side := 4 ;
 438: LD_ADDR_OWVAR 20
 442: PUSH
 443: LD_INT 4
 445: ST_TO_ADDR
// bc_type := b_warehouse ;
 446: LD_ADDR_OWVAR 42
 450: PUSH
 451: LD_INT 1
 453: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 144 , 65 , 1 ) ;
 454: LD_ADDR_VAR 0 4
 458: PUSH
 459: LD_INT 144
 461: PPUSH
 462: LD_INT 65
 464: PPUSH
 465: LD_INT 1
 467: PPUSH
 468: CALL_OW 47
 472: ST_TO_ADDR
// end ; end ;
 473: LD_VAR 0 1
 477: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 478: LD_INT 0
 480: PPUSH
 481: PPUSH
// if exist_mode then
 482: LD_VAR 0 2
 486: IFFALSE 511
// unit := CreateCharacter ( prefix & ident ) else
 488: LD_ADDR_VAR 0 5
 492: PUSH
 493: LD_VAR 0 3
 497: PUSH
 498: LD_VAR 0 1
 502: STR
 503: PPUSH
 504: CALL_OW 34
 508: ST_TO_ADDR
 509: GO 526
// unit := NewCharacter ( ident ) ;
 511: LD_ADDR_VAR 0 5
 515: PUSH
 516: LD_VAR 0 1
 520: PPUSH
 521: CALL_OW 25
 525: ST_TO_ADDR
// result := unit ;
 526: LD_ADDR_VAR 0 4
 530: PUSH
 531: LD_VAR 0 5
 535: ST_TO_ADDR
// end ;
 536: LD_VAR 0 4
 540: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
 541: LD_INT 0
 543: PPUSH
// vc_chassis := chassis ;
 544: LD_ADDR_OWVAR 37
 548: PUSH
 549: LD_VAR 0 1
 553: ST_TO_ADDR
// vc_engine := engine ;
 554: LD_ADDR_OWVAR 39
 558: PUSH
 559: LD_VAR 0 2
 563: ST_TO_ADDR
// vc_control := control ;
 564: LD_ADDR_OWVAR 38
 568: PUSH
 569: LD_VAR 0 3
 573: ST_TO_ADDR
// vc_weapon := weapon ;
 574: LD_ADDR_OWVAR 40
 578: PUSH
 579: LD_VAR 0 4
 583: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 584: LD_ADDR_OWVAR 41
 588: PUSH
 589: LD_VAR 0 5
 593: ST_TO_ADDR
// end ; end_of_file
 594: LD_VAR 0 6
 598: RET
// export JMM , Burlak , freedom ; export Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Belkov , Gnyevko , Masha ; export squad1 , squad2 ; export function PrepareAlliance ; var tmp , i , veh ; begin
 599: LD_INT 0
 601: PPUSH
 602: PPUSH
 603: PPUSH
 604: PPUSH
// uc_side := 7 ;
 605: LD_ADDR_OWVAR 20
 609: PUSH
 610: LD_INT 7
 612: ST_TO_ADDR
// uc_nation := 1 ;
 613: LD_ADDR_OWVAR 21
 617: PUSH
 618: LD_INT 1
 620: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 13a_ ) ;
 621: LD_ADDR_EXP 2
 625: PUSH
 626: LD_STRING JMM
 628: PPUSH
 629: LD_EXP 1
 633: NOT
 634: PPUSH
 635: LD_STRING 13a_
 637: PPUSH
 638: CALL 478 0 3
 642: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 13a_ ) ;
 643: LD_ADDR_EXP 3
 647: PUSH
 648: LD_STRING Burlak
 650: PPUSH
 651: LD_EXP 1
 655: NOT
 656: PPUSH
 657: LD_STRING 13a_
 659: PPUSH
 660: CALL 478 0 3
 664: ST_TO_ADDR
// freedom := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_nation , 1 ] , [ f_nation , 3 ] ] , [ f_btype , b_warehouse ] ] ) ;
 665: LD_ADDR_EXP 4
 669: PUSH
 670: LD_INT 22
 672: PUSH
 673: LD_INT 7
 675: PUSH
 676: EMPTY
 677: LIST
 678: LIST
 679: PUSH
 680: LD_INT 2
 682: PUSH
 683: LD_INT 23
 685: PUSH
 686: LD_INT 1
 688: PUSH
 689: EMPTY
 690: LIST
 691: LIST
 692: PUSH
 693: LD_INT 23
 695: PUSH
 696: LD_INT 3
 698: PUSH
 699: EMPTY
 700: LIST
 701: LIST
 702: PUSH
 703: EMPTY
 704: LIST
 705: LIST
 706: LIST
 707: PUSH
 708: LD_INT 30
 710: PUSH
 711: LD_INT 1
 713: PUSH
 714: EMPTY
 715: LIST
 716: LIST
 717: PUSH
 718: EMPTY
 719: LIST
 720: LIST
 721: LIST
 722: PPUSH
 723: CALL_OW 69
 727: ST_TO_ADDR
// if freedom then
 728: LD_EXP 4
 732: IFFALSE 859
// begin freedom := freedom [ 1 ] ;
 734: LD_ADDR_EXP 4
 738: PUSH
 739: LD_EXP 4
 743: PUSH
 744: LD_INT 1
 746: ARRAY
 747: ST_TO_ADDR
// SetBName ( freedom , freedom ) ;
 748: LD_EXP 4
 752: PPUSH
 753: LD_STRING freedom
 755: PPUSH
 756: CALL_OW 500
// CenterNowOnUnits ( freedom ) ;
 760: LD_EXP 4
 764: PPUSH
 765: CALL_OW 87
// PlaceHumanInUnit ( JMM , freedom ) ;
 769: LD_EXP 2
 773: PPUSH
 774: LD_EXP 4
 778: PPUSH
 779: CALL_OW 52
// PlaceHumanInUnit ( Burlak , freedom ) ;
 783: LD_EXP 3
 787: PPUSH
 788: LD_EXP 4
 792: PPUSH
 793: CALL_OW 52
// SetResourceType ( GetBase ( freedom ) , mat_cans , 1000 ) ;
 797: LD_EXP 4
 801: PPUSH
 802: CALL_OW 274
 806: PPUSH
 807: LD_INT 1
 809: PPUSH
 810: LD_INT 1000
 812: PPUSH
 813: CALL_OW 277
// SetResourceType ( GetBase ( freedom ) , mat_oil , 400 ) ;
 817: LD_EXP 4
 821: PPUSH
 822: CALL_OW 274
 826: PPUSH
 827: LD_INT 2
 829: PPUSH
 830: LD_INT 400
 832: PPUSH
 833: CALL_OW 277
// SetResourceType ( GetBase ( freedom ) , mat_siberit , 30 ) ;
 837: LD_EXP 4
 841: PPUSH
 842: CALL_OW 274
 846: PPUSH
 847: LD_INT 3
 849: PPUSH
 850: LD_INT 30
 852: PPUSH
 853: CALL_OW 277
// end else
 857: GO 946
// begin PlaceUnitArea ( JMM , freedom_base , false ) ;
 859: LD_EXP 2
 863: PPUSH
 864: LD_INT 1
 866: PPUSH
 867: LD_INT 0
 869: PPUSH
 870: CALL_OW 49
// PlaceUnitXYR ( Burlak , GetX ( JMM ) , GetY ( JMM ) , 8 , false ) ;
 874: LD_EXP 3
 878: PPUSH
 879: LD_EXP 2
 883: PPUSH
 884: CALL_OW 250
 888: PPUSH
 889: LD_EXP 2
 893: PPUSH
 894: CALL_OW 251
 898: PPUSH
 899: LD_INT 8
 901: PPUSH
 902: LD_INT 0
 904: PPUSH
 905: CALL_OW 50
// ComTurnUnit ( JMM , Burlak ) ;
 909: LD_EXP 2
 913: PPUSH
 914: LD_EXP 3
 918: PPUSH
 919: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
 923: LD_EXP 3
 927: PPUSH
 928: LD_EXP 2
 932: PPUSH
 933: CALL_OW 119
// CenterNowOnUnits ( JMM ) ;
 937: LD_EXP 2
 941: PPUSH
 942: CALL_OW 87
// end ; SetClass ( JMM , 2 ) ;
 946: LD_EXP 2
 950: PPUSH
 951: LD_INT 2
 953: PPUSH
 954: CALL_OW 336
// tmp := [ [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] , [ us_double_gun , us_laser , us_rocket_launcher , us_gatling_gun , us_cargo_bay ] ] ;
 958: LD_ADDR_VAR 0 2
 962: PUSH
 963: LD_INT 2
 965: PUSH
 966: LD_INT 3
 968: PUSH
 969: LD_INT 4
 971: PUSH
 972: LD_INT 5
 974: PUSH
 975: EMPTY
 976: LIST
 977: LIST
 978: LIST
 979: LIST
 980: PUSH
 981: LD_INT 5
 983: PUSH
 984: LD_INT 9
 986: PUSH
 987: LD_INT 7
 989: PUSH
 990: LD_INT 4
 992: PUSH
 993: LD_INT 12
 995: PUSH
 996: EMPTY
 997: LIST
 998: LIST
 999: LIST
1000: LIST
1001: LIST
1002: PUSH
1003: EMPTY
1004: LIST
1005: LIST
1006: ST_TO_ADDR
// for i = 1 to 5 do
1007: LD_ADDR_VAR 0 3
1011: PUSH
1012: DOUBLE
1013: LD_INT 1
1015: DEC
1016: ST_TO_ADDR
1017: LD_INT 5
1019: PUSH
1020: FOR_TO
1021: IFFALSE 1205
// begin PrepareVehicle ( tmp [ 1 ] [ i mod 4 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , tmp [ 2 ] [ i mod 5 + 1 ] , 100 ) ;
1023: LD_VAR 0 2
1027: PUSH
1028: LD_INT 1
1030: ARRAY
1031: PUSH
1032: LD_VAR 0 3
1036: PUSH
1037: LD_INT 4
1039: MOD
1040: PUSH
1041: LD_INT 1
1043: PLUS
1044: ARRAY
1045: PPUSH
1046: LD_INT 1
1048: PUSH
1049: LD_INT 3
1051: PUSH
1052: EMPTY
1053: LIST
1054: LIST
1055: PUSH
1056: LD_INT 1
1058: PPUSH
1059: LD_INT 2
1061: PPUSH
1062: CALL_OW 12
1066: ARRAY
1067: PPUSH
1068: LD_INT 1
1070: PPUSH
1071: LD_VAR 0 2
1075: PUSH
1076: LD_INT 2
1078: ARRAY
1079: PUSH
1080: LD_VAR 0 3
1084: PUSH
1085: LD_INT 5
1087: MOD
1088: PUSH
1089: LD_INT 1
1091: PLUS
1092: ARRAY
1093: PPUSH
1094: LD_INT 100
1096: PPUSH
1097: CALL 541 0 5
// veh := CreateVehicle ;
1101: LD_ADDR_VAR 0 4
1105: PUSH
1106: CALL_OW 45
1110: ST_TO_ADDR
// SetDir ( veh , rand ( 0 , 5 ) ) ;
1111: LD_VAR 0 4
1115: PPUSH
1116: LD_INT 0
1118: PPUSH
1119: LD_INT 5
1121: PPUSH
1122: CALL_OW 12
1126: PPUSH
1127: CALL_OW 233
// if freedom then
1131: LD_EXP 4
1135: IFFALSE 1168
// begin if IsInArea ( freedom , freedom_base ) then
1137: LD_EXP 4
1141: PPUSH
1142: LD_INT 1
1144: PPUSH
1145: CALL_OW 308
1149: IFFALSE 1166
// PlaceUnitArea ( veh , freedom_base , false ) end else
1151: LD_VAR 0 4
1155: PPUSH
1156: LD_INT 1
1158: PPUSH
1159: LD_INT 0
1161: PPUSH
1162: CALL_OW 49
1166: GO 1203
// PlaceUnitXYR ( veh , GetX ( JMM ) , GetY ( JMM ) , 14 , false ) ;
1168: LD_VAR 0 4
1172: PPUSH
1173: LD_EXP 2
1177: PPUSH
1178: CALL_OW 250
1182: PPUSH
1183: LD_EXP 2
1187: PPUSH
1188: CALL_OW 251
1192: PPUSH
1193: LD_INT 14
1195: PPUSH
1196: LD_INT 0
1198: PPUSH
1199: CALL_OW 50
// end ;
1203: GO 1020
1205: POP
1206: POP
// uc_nation := 3 ;
1207: LD_ADDR_OWVAR 21
1211: PUSH
1212: LD_INT 3
1214: ST_TO_ADDR
// tmp := [ [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] ] ;
1215: LD_ADDR_VAR 0 2
1219: PUSH
1220: LD_INT 21
1222: PUSH
1223: LD_INT 22
1225: PUSH
1226: LD_INT 23
1228: PUSH
1229: LD_INT 24
1231: PUSH
1232: EMPTY
1233: LIST
1234: LIST
1235: LIST
1236: LIST
1237: PUSH
1238: LD_INT 43
1240: PUSH
1241: LD_INT 44
1243: PUSH
1244: LD_INT 45
1246: PUSH
1247: EMPTY
1248: LIST
1249: LIST
1250: LIST
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: ST_TO_ADDR
// for i = 1 to 5 do
1256: LD_ADDR_VAR 0 3
1260: PUSH
1261: DOUBLE
1262: LD_INT 1
1264: DEC
1265: ST_TO_ADDR
1266: LD_INT 5
1268: PUSH
1269: FOR_TO
1270: IFFALSE 1397
// begin PrepareVehicle ( tmp [ 1 ] [ i mod 4 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , tmp [ 2 ] [ i mod 3 + 1 ] , 100 ) ;
1272: LD_VAR 0 2
1276: PUSH
1277: LD_INT 1
1279: ARRAY
1280: PUSH
1281: LD_VAR 0 3
1285: PUSH
1286: LD_INT 4
1288: MOD
1289: PUSH
1290: LD_INT 1
1292: PLUS
1293: ARRAY
1294: PPUSH
1295: LD_INT 1
1297: PUSH
1298: LD_INT 3
1300: PUSH
1301: EMPTY
1302: LIST
1303: LIST
1304: PUSH
1305: LD_INT 1
1307: PPUSH
1308: LD_INT 2
1310: PPUSH
1311: CALL_OW 12
1315: ARRAY
1316: PPUSH
1317: LD_INT 1
1319: PPUSH
1320: LD_VAR 0 2
1324: PUSH
1325: LD_INT 2
1327: ARRAY
1328: PUSH
1329: LD_VAR 0 3
1333: PUSH
1334: LD_INT 3
1336: MOD
1337: PUSH
1338: LD_INT 1
1340: PLUS
1341: ARRAY
1342: PPUSH
1343: LD_INT 100
1345: PPUSH
1346: CALL 541 0 5
// veh := CreateVehicle ;
1350: LD_ADDR_VAR 0 4
1354: PUSH
1355: CALL_OW 45
1359: ST_TO_ADDR
// SetDir ( veh , rand ( 0 , 5 ) ) ;
1360: LD_VAR 0 4
1364: PPUSH
1365: LD_INT 0
1367: PPUSH
1368: LD_INT 5
1370: PPUSH
1371: CALL_OW 12
1375: PPUSH
1376: CALL_OW 233
// PlaceUnitArea ( veh , freedom_base , false ) ;
1380: LD_VAR 0 4
1384: PPUSH
1385: LD_INT 1
1387: PPUSH
1388: LD_INT 0
1390: PPUSH
1391: CALL_OW 49
// end ;
1395: GO 1269
1397: POP
1398: POP
// if not FilterAllUnits ( [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) then
1399: LD_INT 2
1401: PUSH
1402: LD_INT 34
1404: PUSH
1405: LD_INT 12
1407: PUSH
1408: EMPTY
1409: LIST
1410: LIST
1411: PUSH
1412: LD_INT 34
1414: PUSH
1415: LD_INT 51
1417: PUSH
1418: EMPTY
1419: LIST
1420: LIST
1421: PUSH
1422: EMPTY
1423: LIST
1424: LIST
1425: LIST
1426: PPUSH
1427: CALL_OW 69
1431: NOT
1432: IFFALSE 1498
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 0 ) ;
1434: LD_INT 22
1436: PPUSH
1437: LD_INT 3
1439: PPUSH
1440: LD_INT 1
1442: PPUSH
1443: LD_INT 51
1445: PPUSH
1446: LD_INT 0
1448: PPUSH
1449: CALL 541 0 5
// veh := CreateVehicle ;
1453: LD_ADDR_VAR 0 4
1457: PUSH
1458: CALL_OW 45
1462: ST_TO_ADDR
// SetDir ( veh , rand ( 0 , 5 ) ) ;
1463: LD_VAR 0 4
1467: PPUSH
1468: LD_INT 0
1470: PPUSH
1471: LD_INT 5
1473: PPUSH
1474: CALL_OW 12
1478: PPUSH
1479: CALL_OW 233
// PlaceUnitArea ( veh , freedom_base , false ) ;
1483: LD_VAR 0 4
1487: PPUSH
1488: LD_INT 1
1490: PPUSH
1491: LD_INT 0
1493: PPUSH
1494: CALL_OW 49
// end ; tmp := LoadVariable ( 13a_Masha , [ ] ) ;
1498: LD_ADDR_VAR 0 2
1502: PUSH
1503: LD_STRING 13a_Masha
1505: PPUSH
1506: EMPTY
1507: PPUSH
1508: CALL_OW 30
1512: ST_TO_ADDR
// if tmp then
1513: LD_VAR 0 2
1517: IFFALSE 1599
// begin PrepareVehicle ( tmp [ 1 ] , tmp [ 2 ] , tmp [ 3 ] , tmp [ 4 ] , 100 ) ;
1519: LD_VAR 0 2
1523: PUSH
1524: LD_INT 1
1526: ARRAY
1527: PPUSH
1528: LD_VAR 0 2
1532: PUSH
1533: LD_INT 2
1535: ARRAY
1536: PPUSH
1537: LD_VAR 0 2
1541: PUSH
1542: LD_INT 3
1544: ARRAY
1545: PPUSH
1546: LD_VAR 0 2
1550: PUSH
1551: LD_INT 4
1553: ARRAY
1554: PPUSH
1555: LD_INT 100
1557: PPUSH
1558: CALL 541 0 5
// Masha := CreateVehicle ;
1562: LD_ADDR_EXP 36
1566: PUSH
1567: CALL_OW 45
1571: ST_TO_ADDR
// PlaceUnitArea ( Masha , freedom_base , false ) ;
1572: LD_EXP 36
1576: PPUSH
1577: LD_INT 1
1579: PPUSH
1580: LD_INT 0
1582: PPUSH
1583: CALL_OW 49
// SetMark ( Masha , 1 ) ;
1587: LD_EXP 36
1591: PPUSH
1592: LD_INT 1
1594: PPUSH
1595: CALL_OW 242
// end ; uc_side := 4 ;
1599: LD_ADDR_OWVAR 20
1603: PUSH
1604: LD_INT 4
1606: ST_TO_ADDR
// tmp := [ ] ;
1607: LD_ADDR_VAR 0 2
1611: PUSH
1612: EMPTY
1613: ST_TO_ADDR
// squad1 := [ ] ;
1614: LD_ADDR_EXP 37
1618: PUSH
1619: EMPTY
1620: ST_TO_ADDR
// squad2 := [ ] ;
1621: LD_ADDR_EXP 38
1625: PUSH
1626: EMPTY
1627: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1628: LD_ADDR_EXP 19
1632: PUSH
1633: LD_STRING Joan
1635: PPUSH
1636: LD_EXP 1
1640: NOT
1641: PPUSH
1642: LD_STRING 13a_
1644: PPUSH
1645: CALL 478 0 3
1649: ST_TO_ADDR
// if Joan then
1650: LD_EXP 19
1654: IFFALSE 1672
// tmp := tmp ^ Joan ;
1656: LD_ADDR_VAR 0 2
1660: PUSH
1661: LD_VAR 0 2
1665: PUSH
1666: LD_EXP 19
1670: ADD
1671: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1672: LD_ADDR_EXP 5
1676: PUSH
1677: LD_STRING Roth
1679: PPUSH
1680: LD_EXP 1
1684: NOT
1685: PPUSH
1686: LD_STRING 13a_
1688: PPUSH
1689: CALL 478 0 3
1693: ST_TO_ADDR
// if Roth then
1694: LD_EXP 5
1698: IFFALSE 1716
// tmp := tmp ^ Roth ;
1700: LD_ADDR_VAR 0 2
1704: PUSH
1705: LD_VAR 0 2
1709: PUSH
1710: LD_EXP 5
1714: ADD
1715: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1716: LD_ADDR_EXP 10
1720: PUSH
1721: LD_STRING Denis
1723: PPUSH
1724: LD_EXP 1
1728: NOT
1729: PPUSH
1730: LD_STRING 13a_
1732: PPUSH
1733: CALL 478 0 3
1737: ST_TO_ADDR
// if Denis then
1738: LD_EXP 10
1742: IFFALSE 1760
// tmp := tmp ^ Denis ;
1744: LD_ADDR_VAR 0 2
1748: PUSH
1749: LD_VAR 0 2
1753: PUSH
1754: LD_EXP 10
1758: ADD
1759: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1760: LD_ADDR_EXP 20
1764: PUSH
1765: LD_STRING DeltaDoctor
1767: PPUSH
1768: LD_EXP 1
1772: NOT
1773: PPUSH
1774: LD_STRING 13a_
1776: PPUSH
1777: CALL 478 0 3
1781: ST_TO_ADDR
// if DeltaDoctor then
1782: LD_EXP 20
1786: IFFALSE 1804
// tmp := tmp ^ DeltaDoctor ;
1788: LD_ADDR_VAR 0 2
1792: PUSH
1793: LD_VAR 0 2
1797: PUSH
1798: LD_EXP 20
1802: ADD
1803: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1804: LD_ADDR_EXP 18
1808: PUSH
1809: LD_STRING Simms
1811: PPUSH
1812: LD_EXP 1
1816: NOT
1817: PPUSH
1818: LD_STRING 13a_
1820: PPUSH
1821: CALL 478 0 3
1825: ST_TO_ADDR
// if Simms then
1826: LD_EXP 18
1830: IFFALSE 1848
// tmp := tmp ^ Simms ;
1832: LD_ADDR_VAR 0 2
1836: PUSH
1837: LD_VAR 0 2
1841: PUSH
1842: LD_EXP 18
1846: ADD
1847: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1848: LD_ADDR_EXP 21
1852: PUSH
1853: LD_STRING Gossudarov
1855: PPUSH
1856: LD_EXP 1
1860: NOT
1861: PPUSH
1862: LD_STRING 13a_
1864: PPUSH
1865: CALL 478 0 3
1869: ST_TO_ADDR
// if Gossudarov then
1870: LD_EXP 21
1874: IFFALSE 1892
// tmp := tmp ^ Gossudarov ;
1876: LD_ADDR_VAR 0 2
1880: PUSH
1881: LD_VAR 0 2
1885: PUSH
1886: LD_EXP 21
1890: ADD
1891: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1892: LD_ADDR_EXP 22
1896: PUSH
1897: LD_STRING Kirilenkova
1899: PPUSH
1900: LD_EXP 1
1904: NOT
1905: PPUSH
1906: LD_STRING 13a_
1908: PPUSH
1909: CALL 478 0 3
1913: ST_TO_ADDR
// if Kirilenkova then
1914: LD_EXP 22
1918: IFFALSE 1936
// tmp := tmp ^ Kirilenkova ;
1920: LD_ADDR_VAR 0 2
1924: PUSH
1925: LD_VAR 0 2
1929: PUSH
1930: LD_EXP 22
1934: ADD
1935: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1936: LD_ADDR_EXP 25
1940: PUSH
1941: LD_STRING Petrosyan
1943: PPUSH
1944: LD_EXP 1
1948: NOT
1949: PPUSH
1950: LD_STRING 13a_
1952: PPUSH
1953: CALL 478 0 3
1957: ST_TO_ADDR
// if Petrosyan then
1958: LD_EXP 25
1962: IFFALSE 1980
// tmp := tmp ^ Petrosyan ;
1964: LD_ADDR_VAR 0 2
1968: PUSH
1969: LD_VAR 0 2
1973: PUSH
1974: LD_EXP 25
1978: ADD
1979: ST_TO_ADDR
// Scholtze := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1980: LD_ADDR_EXP 26
1984: PUSH
1985: LD_STRING Petrosyan
1987: PPUSH
1988: LD_EXP 1
1992: NOT
1993: PPUSH
1994: LD_STRING 13a_
1996: PPUSH
1997: CALL 478 0 3
2001: ST_TO_ADDR
// if Scholtze then
2002: LD_EXP 26
2006: IFFALSE 2024
// tmp := tmp ^ Scholtze ;
2008: LD_ADDR_VAR 0 2
2012: PUSH
2013: LD_VAR 0 2
2017: PUSH
2018: LD_EXP 26
2022: ADD
2023: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
2024: LD_ADDR_EXP 24
2028: PUSH
2029: LD_STRING Dolgov
2031: PPUSH
2032: LD_EXP 1
2036: NOT
2037: PPUSH
2038: LD_STRING 13a_
2040: PPUSH
2041: CALL 478 0 3
2045: ST_TO_ADDR
// if Dolgov then
2046: LD_EXP 24
2050: IFFALSE 2068
// tmp := tmp ^ Dolgov ;
2052: LD_ADDR_VAR 0 2
2056: PUSH
2057: LD_VAR 0 2
2061: PUSH
2062: LD_EXP 24
2066: ADD
2067: ST_TO_ADDR
// for i in tmp do
2068: LD_ADDR_VAR 0 3
2072: PUSH
2073: LD_VAR 0 2
2077: PUSH
2078: FOR_IN
2079: IFFALSE 2104
// PlaceUnitXYR ( i , 160 , 78 , 22 , false ) ;
2081: LD_VAR 0 3
2085: PPUSH
2086: LD_INT 160
2088: PPUSH
2089: LD_INT 78
2091: PPUSH
2092: LD_INT 22
2094: PPUSH
2095: LD_INT 0
2097: PPUSH
2098: CALL_OW 50
2102: GO 2078
2104: POP
2105: POP
// squad1 := tmp ;
2106: LD_ADDR_EXP 37
2110: PUSH
2111: LD_VAR 0 2
2115: ST_TO_ADDR
// tmp := [ ] ;
2116: LD_ADDR_VAR 0 2
2120: PUSH
2121: EMPTY
2122: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrova , ( not debug ) , 13a_ ) ;
2123: LD_ADDR_EXP 30
2127: PUSH
2128: LD_STRING Petrova
2130: PPUSH
2131: LD_EXP 1
2135: NOT
2136: PPUSH
2137: LD_STRING 13a_
2139: PPUSH
2140: CALL 478 0 3
2144: ST_TO_ADDR
// if Petrovova then
2145: LD_EXP 30
2149: IFFALSE 2167
// tmp := tmp ^ Petrovova ;
2151: LD_ADDR_VAR 0 2
2155: PUSH
2156: LD_VAR 0 2
2160: PUSH
2161: LD_EXP 30
2165: ADD
2166: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
2167: LD_ADDR_EXP 23
2171: PUSH
2172: LD_STRING Titov
2174: PPUSH
2175: LD_EXP 1
2179: NOT
2180: PPUSH
2181: LD_STRING 13a_
2183: PPUSH
2184: CALL 478 0 3
2188: ST_TO_ADDR
// if Titov then
2189: LD_EXP 23
2193: IFFALSE 2211
// tmp := tmp ^ Titov ;
2195: LD_ADDR_VAR 0 2
2199: PUSH
2200: LD_VAR 0 2
2204: PUSH
2205: LD_EXP 23
2209: ADD
2210: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2211: LD_ADDR_EXP 33
2215: PUSH
2216: LD_STRING Karamazov
2218: PPUSH
2219: LD_EXP 1
2223: NOT
2224: PPUSH
2225: LD_STRING 13a_
2227: PPUSH
2228: CALL 478 0 3
2232: ST_TO_ADDR
// if Karamazov then
2233: LD_EXP 33
2237: IFFALSE 2255
// tmp := tmp ^ Karamazov ;
2239: LD_ADDR_VAR 0 2
2243: PUSH
2244: LD_VAR 0 2
2248: PUSH
2249: LD_EXP 33
2253: ADD
2254: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
2255: LD_ADDR_EXP 16
2259: PUSH
2260: LD_STRING Frank
2262: PPUSH
2263: LD_EXP 1
2267: NOT
2268: PPUSH
2269: LD_STRING 13a_
2271: PPUSH
2272: CALL 478 0 3
2276: ST_TO_ADDR
// if Frank then
2277: LD_EXP 16
2281: IFFALSE 2299
// tmp := tmp ^ Frank ;
2283: LD_ADDR_VAR 0 2
2287: PUSH
2288: LD_VAR 0 2
2292: PUSH
2293: LD_EXP 16
2297: ADD
2298: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2299: LD_ADDR_EXP 7
2303: PUSH
2304: LD_STRING Donaldson
2306: PPUSH
2307: LD_EXP 1
2311: NOT
2312: PPUSH
2313: LD_STRING 13a_
2315: PPUSH
2316: CALL 478 0 3
2320: ST_TO_ADDR
// if Donaldson then
2321: LD_EXP 7
2325: IFFALSE 2343
// tmp := tmp ^ Donaldson ;
2327: LD_ADDR_VAR 0 2
2331: PUSH
2332: LD_VAR 0 2
2336: PUSH
2337: LD_EXP 7
2341: ADD
2342: ST_TO_ADDR
// for i in tmp do
2343: LD_ADDR_VAR 0 3
2347: PUSH
2348: LD_VAR 0 2
2352: PUSH
2353: FOR_IN
2354: IFFALSE 2394
// begin PlaceUnitXYR ( i , 117 , 8 , 6 , false ) ;
2356: LD_VAR 0 3
2360: PPUSH
2361: LD_INT 117
2363: PPUSH
2364: LD_INT 8
2366: PPUSH
2367: LD_INT 6
2369: PPUSH
2370: LD_INT 0
2372: PPUSH
2373: CALL_OW 50
// ComTurnXY ( i , 117 , 8 ) ;
2377: LD_VAR 0 3
2381: PPUSH
2382: LD_INT 117
2384: PPUSH
2385: LD_INT 8
2387: PPUSH
2388: CALL_OW 118
// end ;
2392: GO 2353
2394: POP
2395: POP
// squad2 := tmp ;
2396: LD_ADDR_EXP 38
2400: PUSH
2401: LD_VAR 0 2
2405: ST_TO_ADDR
// uc_side := 0 ;
2406: LD_ADDR_OWVAR 20
2410: PUSH
2411: LD_INT 0
2413: ST_TO_ADDR
// uc_nation := 0 ;
2414: LD_ADDR_OWVAR 21
2418: PUSH
2419: LD_INT 0
2421: ST_TO_ADDR
// InitHc ;
2422: CALL_OW 19
// hc_importance := 0 ;
2426: LD_ADDR_OWVAR 32
2430: PUSH
2431: LD_INT 0
2433: ST_TO_ADDR
// hc_name := Find some goods! ;
2434: LD_ADDR_OWVAR 26
2438: PUSH
2439: LD_STRING Find some goods!
2441: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
2442: LD_INT 0
2444: PPUSH
2445: LD_INT 12
2447: PPUSH
2448: LD_INT 1
2450: PPUSH
2451: CALL_OW 380
// PlaceUnitXY ( CreateHuman , 96 , 108 , false ) ;
2455: CALL_OW 44
2459: PPUSH
2460: LD_INT 96
2462: PPUSH
2463: LD_INT 108
2465: PPUSH
2466: LD_INT 0
2468: PPUSH
2469: CALL_OW 48
// InitHc ;
2473: CALL_OW 19
// end ;
2477: LD_VAR 0 1
2481: RET
// every 3 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 0 ] ] ) do var Louis , veh ;
2482: LD_INT 22
2484: PUSH
2485: LD_INT 7
2487: PUSH
2488: EMPTY
2489: LIST
2490: LIST
2491: PUSH
2492: LD_INT 23
2494: PUSH
2495: LD_INT 0
2497: PUSH
2498: EMPTY
2499: LIST
2500: LIST
2501: PUSH
2502: EMPTY
2503: LIST
2504: LIST
2505: PPUSH
2506: CALL_OW 69
2510: IFFALSE 2975
2512: GO 2514
2514: DISABLE
2515: LD_INT 0
2517: PPUSH
2518: PPUSH
// begin InGameOn ;
2519: CALL_OW 8
// RemoveUnit ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 0 ] ] ) [ 1 ] ) ;
2523: LD_INT 22
2525: PUSH
2526: LD_INT 7
2528: PUSH
2529: EMPTY
2530: LIST
2531: LIST
2532: PUSH
2533: LD_INT 23
2535: PUSH
2536: LD_INT 0
2538: PUSH
2539: EMPTY
2540: LIST
2541: LIST
2542: PUSH
2543: EMPTY
2544: LIST
2545: LIST
2546: PPUSH
2547: CALL_OW 69
2551: PUSH
2552: LD_INT 1
2554: ARRAY
2555: PPUSH
2556: CALL_OW 64
// game_speed := 4 ;
2560: LD_ADDR_OWVAR 65
2564: PUSH
2565: LD_INT 4
2567: ST_TO_ADDR
// ComMoveXY ( JMM , 93 , 100 ) ;
2568: LD_EXP 2
2572: PPUSH
2573: LD_INT 93
2575: PPUSH
2576: LD_INT 100
2578: PPUSH
2579: CALL_OW 111
// ComMoveXY ( Burlak , 93 , 99 ) ;
2583: LD_EXP 3
2587: PPUSH
2588: LD_INT 93
2590: PPUSH
2591: LD_INT 99
2593: PPUSH
2594: CALL_OW 111
// AddComTurnXY ( [ JMM , Burlak ] , 81 , 112 ) ;
2598: LD_EXP 2
2602: PUSH
2603: LD_EXP 3
2607: PUSH
2608: EMPTY
2609: LIST
2610: LIST
2611: PPUSH
2612: LD_INT 81
2614: PPUSH
2615: LD_INT 112
2617: PPUSH
2618: CALL_OW 178
// wait ( 0 0$5 ) ;
2622: LD_INT 175
2624: PPUSH
2625: CALL_OW 67
// music_nat := 2 ;
2629: LD_ADDR_OWVAR 71
2633: PUSH
2634: LD_INT 2
2636: ST_TO_ADDR
// music_class := 4 ;
2637: LD_ADDR_OWVAR 72
2641: PUSH
2642: LD_INT 4
2644: ST_TO_ADDR
// CenterNowOnXY ( 80 , 130 ) ;
2645: LD_INT 80
2647: PPUSH
2648: LD_INT 130
2650: PPUSH
2651: CALL_OW 86
// uc_nation := 2 ;
2655: LD_ADDR_OWVAR 21
2659: PUSH
2660: LD_INT 2
2662: ST_TO_ADDR
// uc_side := 2 ;
2663: LD_ADDR_OWVAR 20
2667: PUSH
2668: LD_INT 2
2670: ST_TO_ADDR
// hc_gallery = sandar ;
2671: LD_ADDR_OWVAR 33
2675: PUSH
2676: LD_STRING sandar
2678: ST_TO_ADDR
// hc_face_number = 1 ;
2679: LD_ADDR_OWVAR 34
2683: PUSH
2684: LD_INT 1
2686: ST_TO_ADDR
// hc_name = Louis Schulz ;
2687: LD_ADDR_OWVAR 26
2691: PUSH
2692: LD_STRING Louis Schulz
2694: ST_TO_ADDR
// hc_attr = [ 13 , 11 ] ;
2695: LD_ADDR_OWVAR 29
2699: PUSH
2700: LD_INT 13
2702: PUSH
2703: LD_INT 11
2705: PUSH
2706: EMPTY
2707: LIST
2708: LIST
2709: ST_TO_ADDR
// hc_basic_skills = [ 0 , 0 , 0 , 0 ] ;
2710: LD_ADDR_OWVAR 30
2714: PUSH
2715: LD_INT 0
2717: PUSH
2718: LD_INT 0
2720: PUSH
2721: LD_INT 0
2723: PUSH
2724: LD_INT 0
2726: PUSH
2727: EMPTY
2728: LIST
2729: LIST
2730: LIST
2731: LIST
2732: ST_TO_ADDR
// hc_skills = [ 10 , 6 , 7 , 7 ] ;
2733: LD_ADDR_OWVAR 31
2737: PUSH
2738: LD_INT 10
2740: PUSH
2741: LD_INT 6
2743: PUSH
2744: LD_INT 7
2746: PUSH
2747: LD_INT 7
2749: PUSH
2750: EMPTY
2751: LIST
2752: LIST
2753: LIST
2754: LIST
2755: ST_TO_ADDR
// hc_sex = sex_male ;
2756: LD_ADDR_OWVAR 27
2760: PUSH
2761: LD_INT 1
2763: ST_TO_ADDR
// hc_class = 1 ;
2764: LD_ADDR_OWVAR 28
2768: PUSH
2769: LD_INT 1
2771: ST_TO_ADDR
// hc_importance = 100 ;
2772: LD_ADDR_OWVAR 32
2776: PUSH
2777: LD_INT 100
2779: ST_TO_ADDR
// Louis = CreateHuman ;
2780: LD_ADDR_VAR 0 1
2784: PUSH
2785: CALL_OW 44
2789: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_flame_thrower , 100 ) ;
2790: LD_INT 14
2792: PPUSH
2793: LD_INT 3
2795: PPUSH
2796: LD_INT 1
2798: PPUSH
2799: LD_INT 26
2801: PPUSH
2802: LD_INT 100
2804: PPUSH
2805: CALL 541 0 5
// veh := CreateVehicle ;
2809: LD_ADDR_VAR 0 2
2813: PUSH
2814: CALL_OW 45
2818: ST_TO_ADDR
// SetMark ( veh , - 2 ) ;
2819: LD_VAR 0 2
2823: PPUSH
2824: LD_INT 2
2826: NEG
2827: PPUSH
2828: CALL_OW 242
// PlaceUnitXY ( veh , 80 , 130 , false ) ;
2832: LD_VAR 0 2
2836: PPUSH
2837: LD_INT 80
2839: PPUSH
2840: LD_INT 130
2842: PPUSH
2843: LD_INT 0
2845: PPUSH
2846: CALL_OW 48
// PlaceHumanInUnit ( Louis , veh ) ;
2850: LD_VAR 0 1
2854: PPUSH
2855: LD_VAR 0 2
2859: PPUSH
2860: CALL_OW 52
// ComMoveXY ( Louis , 80 , 109 ) ;
2864: LD_VAR 0 1
2868: PPUSH
2869: LD_INT 80
2871: PPUSH
2872: LD_INT 109
2874: PPUSH
2875: CALL_OW 111
// AddComExitVehicle ( Louis ) ;
2879: LD_VAR 0 1
2883: PPUSH
2884: CALL_OW 181
// AddComMoveXY ( Louis , 80 , 131 ) ;
2888: LD_VAR 0 1
2892: PPUSH
2893: LD_INT 80
2895: PPUSH
2896: LD_INT 131
2898: PPUSH
2899: CALL_OW 171
// wait ( 0 0$06 ) ;
2903: LD_INT 210
2905: PPUSH
2906: CALL_OW 67
// InGameOff ;
2910: CALL_OW 9
// repeat wait ( 0 0$1 ) ;
2914: LD_INT 35
2916: PPUSH
2917: CALL_OW 67
// until IsAt ( Louis , 80 , 131 ) ;
2921: LD_VAR 0 1
2925: PPUSH
2926: LD_INT 80
2928: PPUSH
2929: LD_INT 131
2931: PPUSH
2932: CALL_OW 307
2936: IFFALSE 2914
// SetSide ( veh , 7 ) ;
2938: LD_VAR 0 2
2942: PPUSH
2943: LD_INT 7
2945: PPUSH
2946: CALL_OW 235
// RemoveUnit ( Louis ) ;
2950: LD_VAR 0 1
2954: PPUSH
2955: CALL_OW 64
// music_nat := 3 ;
2959: LD_ADDR_OWVAR 71
2963: PUSH
2964: LD_INT 3
2966: ST_TO_ADDR
// music_class := 0 ;
2967: LD_ADDR_OWVAR 72
2971: PUSH
2972: LD_INT 0
2974: ST_TO_ADDR
// end ;
2975: PPOPN 2
2977: END
// every 0 0$10 trigger squad1 do var i , xy ;
2978: LD_EXP 37
2982: IFFALSE 3345
2984: GO 2986
2986: DISABLE
2987: LD_INT 0
2989: PPUSH
2990: PPUSH
// begin enable ;
2991: ENABLE
// i := squad1 [ rand ( 1 , squad1 ) ] ;
2992: LD_ADDR_VAR 0 1
2996: PUSH
2997: LD_EXP 37
3001: PUSH
3002: LD_INT 1
3004: PPUSH
3005: LD_EXP 37
3009: PPUSH
3010: CALL_OW 12
3014: ARRAY
3015: ST_TO_ADDR
// if IsInUnit ( i ) then
3016: LD_VAR 0 1
3020: PPUSH
3021: CALL_OW 310
3025: IFFALSE 3029
// exit ;
3027: GO 3345
// ComRemember ( i ) ;
3029: LD_VAR 0 1
3033: PPUSH
3034: CALL_OW 143
// xy := [ ShiftX ( GetX ( i ) , rand ( 0 , 5 ) , rand ( 2 , 7 ) ) , ShiftY ( GetY ( i ) , rand ( 0 , 5 ) , rand ( 2 , 7 ) ) ] ;
3038: LD_ADDR_VAR 0 2
3042: PUSH
3043: LD_VAR 0 1
3047: PPUSH
3048: CALL_OW 250
3052: PPUSH
3053: LD_INT 0
3055: PPUSH
3056: LD_INT 5
3058: PPUSH
3059: CALL_OW 12
3063: PPUSH
3064: LD_INT 2
3066: PPUSH
3067: LD_INT 7
3069: PPUSH
3070: CALL_OW 12
3074: PPUSH
3075: CALL_OW 272
3079: PUSH
3080: LD_VAR 0 1
3084: PPUSH
3085: CALL_OW 251
3089: PPUSH
3090: LD_INT 0
3092: PPUSH
3093: LD_INT 5
3095: PPUSH
3096: CALL_OW 12
3100: PPUSH
3101: LD_INT 2
3103: PPUSH
3104: LD_INT 7
3106: PPUSH
3107: CALL_OW 12
3111: PPUSH
3112: CALL_OW 273
3116: PUSH
3117: EMPTY
3118: LIST
3119: LIST
3120: ST_TO_ADDR
// if HexInfo ( xy [ 1 ] , xy [ 2 ] ) <> 0 or not ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
3121: LD_VAR 0 2
3125: PUSH
3126: LD_INT 1
3128: ARRAY
3129: PPUSH
3130: LD_VAR 0 2
3134: PUSH
3135: LD_INT 2
3137: ARRAY
3138: PPUSH
3139: CALL_OW 428
3143: PUSH
3144: LD_INT 0
3146: NONEQUAL
3147: PUSH
3148: LD_VAR 0 2
3152: PUSH
3153: LD_INT 1
3155: ARRAY
3156: PPUSH
3157: LD_VAR 0 2
3161: PUSH
3162: LD_INT 2
3164: ARRAY
3165: PPUSH
3166: CALL_OW 488
3170: NOT
3171: OR
3172: IFFALSE 3176
// exit ;
3174: GO 3345
// AddComMoveXY ( i , xy [ 1 ] , xy [ 2 ] ) ;
3176: LD_VAR 0 1
3180: PPUSH
3181: LD_VAR 0 2
3185: PUSH
3186: LD_INT 1
3188: ARRAY
3189: PPUSH
3190: LD_VAR 0 2
3194: PUSH
3195: LD_INT 2
3197: ARRAY
3198: PPUSH
3199: CALL_OW 171
// AddComWait ( i , 0 0$10 ) ;
3203: LD_VAR 0 1
3207: PPUSH
3208: LD_INT 350
3210: PPUSH
3211: CALL_OW 202
// if Prob ( 60 ) and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) then
3215: LD_INT 60
3217: PPUSH
3218: CALL_OW 13
3222: PUSH
3223: LD_INT 22
3225: PUSH
3226: LD_INT 4
3228: PUSH
3229: EMPTY
3230: LIST
3231: LIST
3232: PUSH
3233: LD_INT 21
3235: PUSH
3236: LD_INT 3
3238: PUSH
3239: EMPTY
3240: LIST
3241: LIST
3242: PUSH
3243: EMPTY
3244: LIST
3245: LIST
3246: PPUSH
3247: CALL_OW 69
3251: AND
3252: IFFALSE 3336
// begin AddComEnterUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , i ) ) ;
3254: LD_VAR 0 1
3258: PPUSH
3259: LD_INT 22
3261: PUSH
3262: LD_INT 4
3264: PUSH
3265: EMPTY
3266: LIST
3267: LIST
3268: PUSH
3269: LD_INT 21
3271: PUSH
3272: LD_INT 3
3274: PUSH
3275: EMPTY
3276: LIST
3277: LIST
3278: PUSH
3279: EMPTY
3280: LIST
3281: LIST
3282: PPUSH
3283: CALL_OW 69
3287: PPUSH
3288: LD_VAR 0 1
3292: PPUSH
3293: CALL_OW 74
3297: PPUSH
3298: CALL_OW 180
// repeat wait ( 0 0$30 ) ;
3302: LD_INT 1050
3304: PPUSH
3305: CALL_OW 67
// until IsInUnit ( i ) ;
3309: LD_VAR 0 1
3313: PPUSH
3314: CALL_OW 310
3318: IFFALSE 3302
// wait ( 0 0$30 ) ;
3320: LD_INT 1050
3322: PPUSH
3323: CALL_OW 67
// AddComExitBuilding ( i ) ;
3327: LD_VAR 0 1
3331: PPUSH
3332: CALL_OW 182
// end ; AddComReturn ( i ) ;
3336: LD_VAR 0 1
3340: PPUSH
3341: CALL_OW 204
// end ; end_of_file
3345: PPOPN 2
3347: END
// export function Action ; begin
3348: LD_INT 0
3350: PPUSH
// InGameOn ;
3351: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
3355: LD_EXP 2
3359: PPUSH
3360: CALL_OW 87
// Say ( JMM , D1-JMM-1 ) ;
3364: LD_EXP 2
3368: PPUSH
3369: LD_STRING D1-JMM-1
3371: PPUSH
3372: CALL_OW 88
// Say ( Burlak , D1-Bur-1 ) ;
3376: LD_EXP 3
3380: PPUSH
3381: LD_STRING D1-Bur-1
3383: PPUSH
3384: CALL_OW 88
// Say ( JMM , D1-JMM-2 ) ;
3388: LD_EXP 2
3392: PPUSH
3393: LD_STRING D1-JMM-2
3395: PPUSH
3396: CALL_OW 88
// Say ( Burlak , D1-Bur-2 ) ;
3400: LD_EXP 3
3404: PPUSH
3405: LD_STRING D1-Bur-2
3407: PPUSH
3408: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
3412: LD_EXP 2
3416: PPUSH
3417: LD_STRING D1-JMM-3
3419: PPUSH
3420: CALL_OW 88
// Say ( Burlak , D1-Bur-3 ) ;
3424: LD_EXP 3
3428: PPUSH
3429: LD_STRING D1-Bur-3
3431: PPUSH
3432: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
3436: LD_EXP 2
3440: PPUSH
3441: LD_STRING D1-JMM-4
3443: PPUSH
3444: CALL_OW 88
// Say ( Burlak , D1-Bur-4 ) ;
3448: LD_EXP 3
3452: PPUSH
3453: LD_STRING D1-Bur-4
3455: PPUSH
3456: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
3460: LD_EXP 2
3464: PPUSH
3465: LD_STRING D1-JMM-5
3467: PPUSH
3468: CALL_OW 88
// Say ( Burlak , D1-Bur-5 ) ;
3472: LD_EXP 3
3476: PPUSH
3477: LD_STRING D1-Bur-5
3479: PPUSH
3480: CALL_OW 88
// Say ( JMM , D1-JMM-6 ) ;
3484: LD_EXP 2
3488: PPUSH
3489: LD_STRING D1-JMM-6
3491: PPUSH
3492: CALL_OW 88
// Say ( Burlak , D1-Bur-6 ) ;
3496: LD_EXP 3
3500: PPUSH
3501: LD_STRING D1-Bur-6
3503: PPUSH
3504: CALL_OW 88
// Say ( JMM , D1-JMM-7 ) ;
3508: LD_EXP 2
3512: PPUSH
3513: LD_STRING D1-JMM-7
3515: PPUSH
3516: CALL_OW 88
// wait ( 20 ) ;
3520: LD_INT 20
3522: PPUSH
3523: CALL_OW 67
// Query ( QTruck ) ;
3527: LD_STRING QTruck
3529: PPUSH
3530: CALL_OW 97
// InGameOff ;
3534: CALL_OW 9
// ChangeMissionObjectives ( MArtPickup ) ;
3538: LD_STRING MArtPickup
3540: PPUSH
3541: CALL_OW 337
// SetAreaMapShow ( escape_area , 1 ) ;
3545: LD_INT 2
3547: PPUSH
3548: LD_INT 1
3550: PPUSH
3551: CALL_OW 424
// end ;
3555: LD_VAR 0 1
3559: RET
// every 0 0$3 trigger FilterUnitsInArea ( escape_area , [ [ f_type , unit_vehicle ] , [ f_control , control_manual ] , [ f_not , [ f_empty ] ] ] ) = 2 and IsInUnit ( JMM ) and IsInUnit ( Burlak ) and ( GetWeapon ( IsInUnit ( JMM ) ) in [ ru_cargo_bay , us_cargo_bay , ru_big_cargo_bay , ar_cargo_bay ] or GetWeapon ( IsInUnit ( Burlak ) ) in [ ru_cargo_bay , us_cargo_bay , ru_big_cargo_bay , ar_cargo_bay ] ) do var i , macmilanVeh , burlakVeh ;
3560: LD_INT 2
3562: PPUSH
3563: LD_INT 21
3565: PUSH
3566: LD_INT 2
3568: PUSH
3569: EMPTY
3570: LIST
3571: LIST
3572: PUSH
3573: LD_INT 33
3575: PUSH
3576: LD_INT 1
3578: PUSH
3579: EMPTY
3580: LIST
3581: LIST
3582: PUSH
3583: LD_INT 3
3585: PUSH
3586: LD_INT 58
3588: PUSH
3589: EMPTY
3590: LIST
3591: PUSH
3592: EMPTY
3593: LIST
3594: LIST
3595: PUSH
3596: EMPTY
3597: LIST
3598: LIST
3599: LIST
3600: PPUSH
3601: CALL_OW 70
3605: PUSH
3606: LD_INT 2
3608: EQUAL
3609: PUSH
3610: LD_EXP 2
3614: PPUSH
3615: CALL_OW 310
3619: AND
3620: PUSH
3621: LD_EXP 3
3625: PPUSH
3626: CALL_OW 310
3630: AND
3631: PUSH
3632: LD_EXP 2
3636: PPUSH
3637: CALL_OW 310
3641: PPUSH
3642: CALL_OW 264
3646: PUSH
3647: LD_INT 51
3649: PUSH
3650: LD_INT 12
3652: PUSH
3653: LD_EXP 40
3657: PUSH
3658: LD_INT 32
3660: PUSH
3661: EMPTY
3662: LIST
3663: LIST
3664: LIST
3665: LIST
3666: IN
3667: PUSH
3668: LD_EXP 3
3672: PPUSH
3673: CALL_OW 310
3677: PPUSH
3678: CALL_OW 264
3682: PUSH
3683: LD_INT 51
3685: PUSH
3686: LD_INT 12
3688: PUSH
3689: LD_EXP 40
3693: PUSH
3694: LD_INT 32
3696: PUSH
3697: EMPTY
3698: LIST
3699: LIST
3700: LIST
3701: LIST
3702: IN
3703: OR
3704: AND
3705: IFFALSE 3915
3707: GO 3709
3709: DISABLE
3710: LD_INT 0
3712: PPUSH
3713: PPUSH
3714: PPUSH
// begin macmilanVeh := IsInUnit ( JMM ) ;
3715: LD_ADDR_VAR 0 2
3719: PUSH
3720: LD_EXP 2
3724: PPUSH
3725: CALL_OW 310
3729: ST_TO_ADDR
// burlakVeh := IsInUnit ( Burlak ) ;
3730: LD_ADDR_VAR 0 3
3734: PUSH
3735: LD_EXP 3
3739: PPUSH
3740: CALL_OW 310
3744: ST_TO_ADDR
// SaveVariable ( [ GetChassis ( macmilanVeh ) , GetEngine ( macmilanVeh ) , control_manual , GetWeapon ( macmilanVeh ) , GetMark ( macmilanVeh ) , GetNation ( macmilanVeh ) ] , 14a_JMMVeh ) ;
3745: LD_VAR 0 2
3749: PPUSH
3750: CALL_OW 265
3754: PUSH
3755: LD_VAR 0 2
3759: PPUSH
3760: CALL_OW 262
3764: PUSH
3765: LD_INT 1
3767: PUSH
3768: LD_VAR 0 2
3772: PPUSH
3773: CALL_OW 264
3777: PUSH
3778: LD_VAR 0 2
3782: PPUSH
3783: CALL_OW 271
3787: PUSH
3788: LD_VAR 0 2
3792: PPUSH
3793: CALL_OW 248
3797: PUSH
3798: EMPTY
3799: LIST
3800: LIST
3801: LIST
3802: LIST
3803: LIST
3804: LIST
3805: PPUSH
3806: LD_STRING 14a_JMMVeh
3808: PPUSH
3809: CALL_OW 39
// SaveVariable ( [ GetChassis ( burlakVeh ) , GetEngine ( burlakVeh ) , control_manual , GetWeapon ( burlakVeh ) , GetMark ( burlakVeh ) , GetNation ( burlakVeh ) ] , 14a_BurlakVeh ) ;
3813: LD_VAR 0 3
3817: PPUSH
3818: CALL_OW 265
3822: PUSH
3823: LD_VAR 0 3
3827: PPUSH
3828: CALL_OW 262
3832: PUSH
3833: LD_INT 1
3835: PUSH
3836: LD_VAR 0 3
3840: PPUSH
3841: CALL_OW 264
3845: PUSH
3846: LD_VAR 0 3
3850: PPUSH
3851: CALL_OW 271
3855: PUSH
3856: LD_VAR 0 3
3860: PPUSH
3861: CALL_OW 248
3865: PUSH
3866: EMPTY
3867: LIST
3868: LIST
3869: LIST
3870: LIST
3871: LIST
3872: LIST
3873: PPUSH
3874: LD_STRING 14a_BurlakVeh
3876: PPUSH
3877: CALL_OW 39
// SaveCharacters ( JMM , 14a_JMM ) ;
3881: LD_EXP 2
3885: PPUSH
3886: LD_STRING 14a_JMM
3888: PPUSH
3889: CALL_OW 38
// SaveCharacters ( Burlak , 14a_Burlak ) ;
3893: LD_EXP 3
3897: PPUSH
3898: LD_STRING 14a_Burlak
3900: PPUSH
3901: CALL_OW 38
// ChangeMap ( 1 , %_cont ) ;
3905: LD_INT 1
3907: PPUSH
3908: LD_STRING %_cont
3910: PPUSH
3911: CALL_OW 340
// end ;
3915: PPOPN 3
3917: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_lives , 950 ] ] ] ) do
3918: LD_INT 22
3920: PUSH
3921: LD_INT 4
3923: PUSH
3924: EMPTY
3925: LIST
3926: LIST
3927: PUSH
3928: LD_INT 3
3930: PUSH
3931: LD_INT 24
3933: PUSH
3934: LD_INT 950
3936: PUSH
3937: EMPTY
3938: LIST
3939: LIST
3940: PUSH
3941: EMPTY
3942: LIST
3943: LIST
3944: PUSH
3945: EMPTY
3946: LIST
3947: LIST
3948: PPUSH
3949: CALL_OW 69
3953: IFFALSE 3965
3955: GO 3957
3957: DISABLE
// YouLost ( FriendlyFire ) ;
3958: LD_STRING FriendlyFire
3960: PPUSH
3961: CALL_OW 104
3965: END
// every 0 0$1 trigger IsDead ( Burlak ) do
3966: LD_EXP 3
3970: PPUSH
3971: CALL_OW 301
3975: IFFALSE 3987
3977: GO 3979
3979: DISABLE
// YouLost ( Burlak ) ;
3980: LD_STRING Burlak
3982: PPUSH
3983: CALL_OW 104
3987: END
// every 0 0$1 trigger IsDead ( JMM ) do
3988: LD_EXP 2
3992: PPUSH
3993: CALL_OW 301
3997: IFFALSE 4009
3999: GO 4001
4001: DISABLE
// YouLost ( JMM ) ; end_of_file
4002: LD_STRING JMM
4004: PPUSH
4005: CALL_OW 104
4009: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
4010: GO 4012
4012: DISABLE
// begin ru_radar := 98 ;
4013: LD_ADDR_EXP 39
4017: PUSH
4018: LD_INT 98
4020: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
4021: LD_ADDR_EXP 40
4025: PUSH
4026: LD_INT 89
4028: ST_TO_ADDR
// us_hack := 99 ;
4029: LD_ADDR_EXP 41
4033: PUSH
4034: LD_INT 99
4036: ST_TO_ADDR
// us_artillery := 97 ;
4037: LD_ADDR_EXP 42
4041: PUSH
4042: LD_INT 97
4044: ST_TO_ADDR
// ar_bio_bomb := 91 ;
4045: LD_ADDR_EXP 43
4049: PUSH
4050: LD_INT 91
4052: ST_TO_ADDR
// end ;
4053: END
