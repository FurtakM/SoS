// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// FogOff ( 7 ) ;
  11: LD_INT 7
  13: PPUSH
  14: CALL_OW 344
// RandomizeAll ;
  18: CALL_OW 11
// InitVariables ;
  22: CALL 66 0 0
// LoadBuildings ;
  26: CALL 94 0 0
// PrepareAlliance ;
  30: CALL 758 0 0
// music_nat := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
  34: LD_ADDR_OWVAR 71
  38: PUSH
  39: LD_INT 1
  41: PUSH
  42: LD_INT 3
  44: PUSH
  45: EMPTY
  46: LIST
  47: LIST
  48: PUSH
  49: LD_INT 1
  51: PPUSH
  52: LD_INT 2
  54: PPUSH
  55: CALL_OW 12
  59: ARRAY
  60: ST_TO_ADDR
// Action ;
  61: CALL 3550 0 0
// end ;
  65: END
// export debug ; export function InitVariables ; begin
  66: LD_INT 0
  68: PPUSH
// debug := false ;
  69: LD_ADDR_EXP 1
  73: PUSH
  74: LD_INT 0
  76: ST_TO_ADDR
// end ;
  77: LD_VAR 0 1
  81: RET
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
  82: LD_VAR 0 1
  86: PPUSH
  87: CALL 15133 0 1
// end ; end_of_file
  91: PPOPN 1
  93: END
// export function LoadBuildings ; var i , tmp , b , j ; begin
  94: LD_INT 0
  96: PPUSH
  97: PPUSH
  98: PPUSH
  99: PPUSH
 100: PPUSH
// tmp := LoadVariable ( 13a_buildings , [ [ 7 , 1 , b_warehouse , 70 , 46 , 3 , 10 , 0 , 0 , 0 ] ] ) ;
 101: LD_ADDR_VAR 0 3
 105: PUSH
 106: LD_STRING 13a_buildings
 108: PPUSH
 109: LD_INT 7
 111: PUSH
 112: LD_INT 1
 114: PUSH
 115: LD_INT 1
 117: PUSH
 118: LD_INT 70
 120: PUSH
 121: LD_INT 46
 123: PUSH
 124: LD_INT 3
 126: PUSH
 127: LD_INT 10
 129: PUSH
 130: LD_INT 0
 132: PUSH
 133: LD_INT 0
 135: PUSH
 136: LD_INT 0
 138: PUSH
 139: EMPTY
 140: LIST
 141: LIST
 142: LIST
 143: LIST
 144: LIST
 145: LIST
 146: LIST
 147: LIST
 148: LIST
 149: LIST
 150: PUSH
 151: EMPTY
 152: LIST
 153: PPUSH
 154: CALL_OW 30
 158: ST_TO_ADDR
// bc_kind1 := - 1 ;
 159: LD_ADDR_OWVAR 44
 163: PUSH
 164: LD_INT 1
 166: NEG
 167: ST_TO_ADDR
// bc_kind2 := - 1 ;
 168: LD_ADDR_OWVAR 45
 172: PUSH
 173: LD_INT 1
 175: NEG
 176: ST_TO_ADDR
// for i in tmp do
 177: LD_ADDR_VAR 0 2
 181: PUSH
 182: LD_VAR 0 3
 186: PUSH
 187: FOR_IN
 188: IFFALSE 433
// begin uc_side := 7 ;
 190: LD_ADDR_OWVAR 20
 194: PUSH
 195: LD_INT 7
 197: ST_TO_ADDR
// uc_nation := i [ 2 ] ;
 198: LD_ADDR_OWVAR 21
 202: PUSH
 203: LD_VAR 0 2
 207: PUSH
 208: LD_INT 2
 210: ARRAY
 211: ST_TO_ADDR
// if i [ 2 ] = 2 then
 212: LD_VAR 0 2
 216: PUSH
 217: LD_INT 2
 219: ARRAY
 220: PUSH
 221: LD_INT 2
 223: EQUAL
 224: IFFALSE 234
// uc_side := 4 ;
 226: LD_ADDR_OWVAR 20
 230: PUSH
 231: LD_INT 4
 233: ST_TO_ADDR
// bc_type := i [ 3 ] ;
 234: LD_ADDR_OWVAR 42
 238: PUSH
 239: LD_VAR 0 2
 243: PUSH
 244: LD_INT 3
 246: ARRAY
 247: ST_TO_ADDR
// if i [ 3 ] in [ b_oil_mine , b_siberite_mine ] then
 248: LD_VAR 0 2
 252: PUSH
 253: LD_INT 3
 255: ARRAY
 256: PUSH
 257: LD_INT 29
 259: PUSH
 260: LD_INT 30
 262: PUSH
 263: EMPTY
 264: LIST
 265: LIST
 266: IN
 267: IFFALSE 300
// SetResourceVisibility ( i [ 4 ] , i [ 5 ] , i [ 1 ] ) ;
 269: LD_VAR 0 2
 273: PUSH
 274: LD_INT 4
 276: ARRAY
 277: PPUSH
 278: LD_VAR 0 2
 282: PUSH
 283: LD_INT 5
 285: ARRAY
 286: PPUSH
 287: LD_VAR 0 2
 291: PUSH
 292: LD_INT 1
 294: ARRAY
 295: PPUSH
 296: CALL_OW 441
// if i [ 8 ] then
 300: LD_VAR 0 2
 304: PUSH
 305: LD_INT 8
 307: ARRAY
 308: IFFALSE 324
// bc_kind1 := i [ 8 ] ;
 310: LD_ADDR_OWVAR 44
 314: PUSH
 315: LD_VAR 0 2
 319: PUSH
 320: LD_INT 8
 322: ARRAY
 323: ST_TO_ADDR
// if i [ 9 ] then
 324: LD_VAR 0 2
 328: PUSH
 329: LD_INT 9
 331: ARRAY
 332: IFFALSE 348
// bc_kind2 := i [ 9 ] ;
 334: LD_ADDR_OWVAR 45
 338: PUSH
 339: LD_VAR 0 2
 343: PUSH
 344: LD_INT 9
 346: ARRAY
 347: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( i [ 4 ] , i [ 5 ] , i [ 6 ] ) ;
 348: LD_ADDR_VAR 0 4
 352: PUSH
 353: LD_VAR 0 2
 357: PUSH
 358: LD_INT 4
 360: ARRAY
 361: PPUSH
 362: LD_VAR 0 2
 366: PUSH
 367: LD_INT 5
 369: ARRAY
 370: PPUSH
 371: LD_VAR 0 2
 375: PUSH
 376: LD_INT 6
 378: ARRAY
 379: PPUSH
 380: CALL_OW 47
 384: ST_TO_ADDR
// SetBLevel ( b , i [ 7 ] ) ;
 385: LD_VAR 0 4
 389: PPUSH
 390: LD_VAR 0 2
 394: PUSH
 395: LD_INT 7
 397: ARRAY
 398: PPUSH
 399: CALL_OW 241
// if i [ 10 ] then
 403: LD_VAR 0 2
 407: PUSH
 408: LD_INT 10
 410: ARRAY
 411: IFFALSE 431
// PlaceWeaponTurret ( b , i [ 10 ] ) ;
 413: LD_VAR 0 4
 417: PPUSH
 418: LD_VAR 0 2
 422: PUSH
 423: LD_INT 10
 425: ARRAY
 426: PPUSH
 427: CALL_OW 431
// end ;
 431: GO 187
 433: POP
 434: POP
// if HexInfo ( 144 , 65 ) = 0 then
 435: LD_INT 144
 437: PPUSH
 438: LD_INT 65
 440: PPUSH
 441: CALL_OW 428
 445: PUSH
 446: LD_INT 0
 448: EQUAL
 449: IFFALSE 486
// begin uc_side := 4 ;
 451: LD_ADDR_OWVAR 20
 455: PUSH
 456: LD_INT 4
 458: ST_TO_ADDR
// bc_type := b_warehouse ;
 459: LD_ADDR_OWVAR 42
 463: PUSH
 464: LD_INT 1
 466: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 144 , 65 , 1 ) ;
 467: LD_ADDR_VAR 0 4
 471: PUSH
 472: LD_INT 144
 474: PPUSH
 475: LD_INT 65
 477: PPUSH
 478: LD_INT 1
 480: PPUSH
 481: CALL_OW 47
 485: ST_TO_ADDR
// end ; for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) do
 486: LD_ADDR_VAR 0 2
 490: PUSH
 491: LD_INT 22
 493: PUSH
 494: LD_INT 7
 496: PUSH
 497: EMPTY
 498: LIST
 499: LIST
 500: PUSH
 501: LD_INT 2
 503: PUSH
 504: LD_INT 30
 506: PUSH
 507: LD_INT 0
 509: PUSH
 510: EMPTY
 511: LIST
 512: LIST
 513: PUSH
 514: LD_INT 30
 516: PUSH
 517: LD_INT 1
 519: PUSH
 520: EMPTY
 521: LIST
 522: LIST
 523: PUSH
 524: EMPTY
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: EMPTY
 530: LIST
 531: LIST
 532: PPUSH
 533: CALL_OW 69
 537: PUSH
 538: FOR_IN
 539: IFFALSE 591
// for j = 1 to 3 do
 541: LD_ADDR_VAR 0 5
 545: PUSH
 546: DOUBLE
 547: LD_INT 1
 549: DEC
 550: ST_TO_ADDR
 551: LD_INT 3
 553: PUSH
 554: FOR_TO
 555: IFFALSE 587
// SetResourceType ( GetBase ( i ) , j , 3000 / j ) ;
 557: LD_VAR 0 2
 561: PPUSH
 562: CALL_OW 274
 566: PPUSH
 567: LD_VAR 0 5
 571: PPUSH
 572: LD_INT 3000
 574: PUSH
 575: LD_VAR 0 5
 579: DIVREAL
 580: PPUSH
 581: CALL_OW 277
 585: GO 554
 587: POP
 588: POP
 589: GO 538
 591: POP
 592: POP
// for i in FilterUnitsInArea ( spot_area , [ f_side , 7 ] ) do
 593: LD_ADDR_VAR 0 2
 597: PUSH
 598: LD_INT 3
 600: PPUSH
 601: LD_INT 22
 603: PUSH
 604: LD_INT 7
 606: PUSH
 607: EMPTY
 608: LIST
 609: LIST
 610: PPUSH
 611: CALL_OW 70
 615: PUSH
 616: FOR_IN
 617: IFFALSE 630
// RemoveUnit ( i ) ;
 619: LD_VAR 0 2
 623: PPUSH
 624: CALL_OW 64
 628: GO 616
 630: POP
 631: POP
// end ;
 632: LD_VAR 0 1
 636: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 637: LD_INT 0
 639: PPUSH
 640: PPUSH
// if exist_mode then
 641: LD_VAR 0 2
 645: IFFALSE 670
// unit := CreateCharacter ( prefix & ident ) else
 647: LD_ADDR_VAR 0 5
 651: PUSH
 652: LD_VAR 0 3
 656: PUSH
 657: LD_VAR 0 1
 661: STR
 662: PPUSH
 663: CALL_OW 34
 667: ST_TO_ADDR
 668: GO 685
// unit := NewCharacter ( ident ) ;
 670: LD_ADDR_VAR 0 5
 674: PUSH
 675: LD_VAR 0 1
 679: PPUSH
 680: CALL_OW 25
 684: ST_TO_ADDR
// result := unit ;
 685: LD_ADDR_VAR 0 4
 689: PUSH
 690: LD_VAR 0 5
 694: ST_TO_ADDR
// end ;
 695: LD_VAR 0 4
 699: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
 700: LD_INT 0
 702: PPUSH
// vc_chassis := chassis ;
 703: LD_ADDR_OWVAR 37
 707: PUSH
 708: LD_VAR 0 1
 712: ST_TO_ADDR
// vc_engine := engine ;
 713: LD_ADDR_OWVAR 39
 717: PUSH
 718: LD_VAR 0 2
 722: ST_TO_ADDR
// vc_control := control ;
 723: LD_ADDR_OWVAR 38
 727: PUSH
 728: LD_VAR 0 3
 732: ST_TO_ADDR
// vc_weapon := weapon ;
 733: LD_ADDR_OWVAR 40
 737: PUSH
 738: LD_VAR 0 4
 742: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 743: LD_ADDR_OWVAR 41
 747: PUSH
 748: LD_VAR 0 5
 752: ST_TO_ADDR
// end ; end_of_file
 753: LD_VAR 0 6
 757: RET
// export JMM , Burlak , freedom ; export Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Belkov , Gnyevko , Masha ; export squad1 , squad2 ; export function PrepareAlliance ; var tmp , i , veh ; begin
 758: LD_INT 0
 760: PPUSH
 761: PPUSH
 762: PPUSH
 763: PPUSH
// uc_side := 7 ;
 764: LD_ADDR_OWVAR 20
 768: PUSH
 769: LD_INT 7
 771: ST_TO_ADDR
// uc_nation := 1 ;
 772: LD_ADDR_OWVAR 21
 776: PUSH
 777: LD_INT 1
 779: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 13a_ ) ;
 780: LD_ADDR_EXP 2
 784: PUSH
 785: LD_STRING JMM
 787: PPUSH
 788: LD_EXP 1
 792: NOT
 793: PPUSH
 794: LD_STRING 13a_
 796: PPUSH
 797: CALL 637 0 3
 801: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 13a_ ) ;
 802: LD_ADDR_EXP 3
 806: PUSH
 807: LD_STRING Burlak
 809: PPUSH
 810: LD_EXP 1
 814: NOT
 815: PPUSH
 816: LD_STRING 13a_
 818: PPUSH
 819: CALL 637 0 3
 823: ST_TO_ADDR
// if debug then
 824: LD_EXP 1
 828: IFFALSE 863
// begin PrepareHuman ( sex_male , 4 , 10 ) ;
 830: LD_INT 1
 832: PPUSH
 833: LD_INT 4
 835: PPUSH
 836: LD_INT 10
 838: PPUSH
 839: CALL_OW 380
// JMM := CreateHuman ;
 843: LD_ADDR_EXP 2
 847: PUSH
 848: CALL_OW 44
 852: ST_TO_ADDR
// Burlak := CreateHuman ;
 853: LD_ADDR_EXP 3
 857: PUSH
 858: CALL_OW 44
 862: ST_TO_ADDR
// end ; freedom := FilterUnitsInArea ( freedom_base , [ [ f_side , 7 ] , [ f_or , [ f_nation , 1 ] , [ f_nation , 3 ] ] , [ f_btype , b_warehouse ] ] ) ;
 863: LD_ADDR_EXP 4
 867: PUSH
 868: LD_INT 1
 870: PPUSH
 871: LD_INT 22
 873: PUSH
 874: LD_INT 7
 876: PUSH
 877: EMPTY
 878: LIST
 879: LIST
 880: PUSH
 881: LD_INT 2
 883: PUSH
 884: LD_INT 23
 886: PUSH
 887: LD_INT 1
 889: PUSH
 890: EMPTY
 891: LIST
 892: LIST
 893: PUSH
 894: LD_INT 23
 896: PUSH
 897: LD_INT 3
 899: PUSH
 900: EMPTY
 901: LIST
 902: LIST
 903: PUSH
 904: EMPTY
 905: LIST
 906: LIST
 907: LIST
 908: PUSH
 909: LD_INT 30
 911: PUSH
 912: LD_INT 1
 914: PUSH
 915: EMPTY
 916: LIST
 917: LIST
 918: PUSH
 919: EMPTY
 920: LIST
 921: LIST
 922: LIST
 923: PPUSH
 924: CALL_OW 70
 928: ST_TO_ADDR
// if freedom then
 929: LD_EXP 4
 933: IFFALSE 1060
// begin freedom := freedom [ 1 ] ;
 935: LD_ADDR_EXP 4
 939: PUSH
 940: LD_EXP 4
 944: PUSH
 945: LD_INT 1
 947: ARRAY
 948: ST_TO_ADDR
// SetBName ( freedom , freedom ) ;
 949: LD_EXP 4
 953: PPUSH
 954: LD_STRING freedom
 956: PPUSH
 957: CALL_OW 500
// CenterNowOnUnits ( freedom ) ;
 961: LD_EXP 4
 965: PPUSH
 966: CALL_OW 87
// PlaceHumanInUnit ( JMM , freedom ) ;
 970: LD_EXP 2
 974: PPUSH
 975: LD_EXP 4
 979: PPUSH
 980: CALL_OW 52
// PlaceHumanInUnit ( Burlak , freedom ) ;
 984: LD_EXP 3
 988: PPUSH
 989: LD_EXP 4
 993: PPUSH
 994: CALL_OW 52
// SetResourceType ( GetBase ( freedom ) , mat_cans , 1000 ) ;
 998: LD_EXP 4
1002: PPUSH
1003: CALL_OW 274
1007: PPUSH
1008: LD_INT 1
1010: PPUSH
1011: LD_INT 1000
1013: PPUSH
1014: CALL_OW 277
// SetResourceType ( GetBase ( freedom ) , mat_oil , 400 ) ;
1018: LD_EXP 4
1022: PPUSH
1023: CALL_OW 274
1027: PPUSH
1028: LD_INT 2
1030: PPUSH
1031: LD_INT 400
1033: PPUSH
1034: CALL_OW 277
// SetResourceType ( GetBase ( freedom ) , mat_siberit , 30 ) ;
1038: LD_EXP 4
1042: PPUSH
1043: CALL_OW 274
1047: PPUSH
1048: LD_INT 3
1050: PPUSH
1051: LD_INT 30
1053: PPUSH
1054: CALL_OW 277
// end else
1058: GO 1147
// begin PlaceUnitArea ( JMM , freedom_base , false ) ;
1060: LD_EXP 2
1064: PPUSH
1065: LD_INT 1
1067: PPUSH
1068: LD_INT 0
1070: PPUSH
1071: CALL_OW 49
// PlaceUnitXYR ( Burlak , GetX ( JMM ) , GetY ( JMM ) , 8 , false ) ;
1075: LD_EXP 3
1079: PPUSH
1080: LD_EXP 2
1084: PPUSH
1085: CALL_OW 250
1089: PPUSH
1090: LD_EXP 2
1094: PPUSH
1095: CALL_OW 251
1099: PPUSH
1100: LD_INT 8
1102: PPUSH
1103: LD_INT 0
1105: PPUSH
1106: CALL_OW 50
// ComTurnUnit ( JMM , Burlak ) ;
1110: LD_EXP 2
1114: PPUSH
1115: LD_EXP 3
1119: PPUSH
1120: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
1124: LD_EXP 3
1128: PPUSH
1129: LD_EXP 2
1133: PPUSH
1134: CALL_OW 119
// CenterNowOnUnits ( JMM ) ;
1138: LD_EXP 2
1142: PPUSH
1143: CALL_OW 87
// end ; SetClass ( JMM , 2 ) ;
1147: LD_EXP 2
1151: PPUSH
1152: LD_INT 2
1154: PPUSH
1155: CALL_OW 336
// tmp := [ [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] , [ us_double_gun , us_laser , us_rocket_launcher , us_gatling_gun , us_cargo_bay ] ] ;
1159: LD_ADDR_VAR 0 2
1163: PUSH
1164: LD_INT 2
1166: PUSH
1167: LD_INT 3
1169: PUSH
1170: LD_INT 4
1172: PUSH
1173: LD_INT 5
1175: PUSH
1176: EMPTY
1177: LIST
1178: LIST
1179: LIST
1180: LIST
1181: PUSH
1182: LD_INT 5
1184: PUSH
1185: LD_INT 9
1187: PUSH
1188: LD_INT 7
1190: PUSH
1191: LD_INT 4
1193: PUSH
1194: LD_INT 12
1196: PUSH
1197: EMPTY
1198: LIST
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: PUSH
1204: EMPTY
1205: LIST
1206: LIST
1207: ST_TO_ADDR
// for i = 1 to 5 do
1208: LD_ADDR_VAR 0 3
1212: PUSH
1213: DOUBLE
1214: LD_INT 1
1216: DEC
1217: ST_TO_ADDR
1218: LD_INT 5
1220: PUSH
1221: FOR_TO
1222: IFFALSE 1406
// begin PrepareVehicle ( tmp [ 1 ] [ i mod 4 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , tmp [ 2 ] [ i mod 5 + 1 ] , 100 ) ;
1224: LD_VAR 0 2
1228: PUSH
1229: LD_INT 1
1231: ARRAY
1232: PUSH
1233: LD_VAR 0 3
1237: PUSH
1238: LD_INT 4
1240: MOD
1241: PUSH
1242: LD_INT 1
1244: PLUS
1245: ARRAY
1246: PPUSH
1247: LD_INT 1
1249: PUSH
1250: LD_INT 3
1252: PUSH
1253: EMPTY
1254: LIST
1255: LIST
1256: PUSH
1257: LD_INT 1
1259: PPUSH
1260: LD_INT 2
1262: PPUSH
1263: CALL_OW 12
1267: ARRAY
1268: PPUSH
1269: LD_INT 1
1271: PPUSH
1272: LD_VAR 0 2
1276: PUSH
1277: LD_INT 2
1279: ARRAY
1280: PUSH
1281: LD_VAR 0 3
1285: PUSH
1286: LD_INT 5
1288: MOD
1289: PUSH
1290: LD_INT 1
1292: PLUS
1293: ARRAY
1294: PPUSH
1295: LD_INT 100
1297: PPUSH
1298: CALL 700 0 5
// veh := CreateVehicle ;
1302: LD_ADDR_VAR 0 4
1306: PUSH
1307: CALL_OW 45
1311: ST_TO_ADDR
// SetDir ( veh , rand ( 0 , 5 ) ) ;
1312: LD_VAR 0 4
1316: PPUSH
1317: LD_INT 0
1319: PPUSH
1320: LD_INT 5
1322: PPUSH
1323: CALL_OW 12
1327: PPUSH
1328: CALL_OW 233
// if freedom then
1332: LD_EXP 4
1336: IFFALSE 1369
// begin if IsInArea ( freedom , freedom_base ) then
1338: LD_EXP 4
1342: PPUSH
1343: LD_INT 1
1345: PPUSH
1346: CALL_OW 308
1350: IFFALSE 1367
// PlaceUnitArea ( veh , freedom_base , false ) end else
1352: LD_VAR 0 4
1356: PPUSH
1357: LD_INT 1
1359: PPUSH
1360: LD_INT 0
1362: PPUSH
1363: CALL_OW 49
1367: GO 1404
// PlaceUnitXYR ( veh , GetX ( JMM ) , GetY ( JMM ) , 14 , false ) ;
1369: LD_VAR 0 4
1373: PPUSH
1374: LD_EXP 2
1378: PPUSH
1379: CALL_OW 250
1383: PPUSH
1384: LD_EXP 2
1388: PPUSH
1389: CALL_OW 251
1393: PPUSH
1394: LD_INT 14
1396: PPUSH
1397: LD_INT 0
1399: PPUSH
1400: CALL_OW 50
// end ;
1404: GO 1221
1406: POP
1407: POP
// uc_nation := 3 ;
1408: LD_ADDR_OWVAR 21
1412: PUSH
1413: LD_INT 3
1415: ST_TO_ADDR
// tmp := [ [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] ] ;
1416: LD_ADDR_VAR 0 2
1420: PUSH
1421: LD_INT 21
1423: PUSH
1424: LD_INT 22
1426: PUSH
1427: LD_INT 23
1429: PUSH
1430: LD_INT 24
1432: PUSH
1433: EMPTY
1434: LIST
1435: LIST
1436: LIST
1437: LIST
1438: PUSH
1439: LD_INT 43
1441: PUSH
1442: LD_INT 44
1444: PUSH
1445: LD_INT 45
1447: PUSH
1448: EMPTY
1449: LIST
1450: LIST
1451: LIST
1452: PUSH
1453: EMPTY
1454: LIST
1455: LIST
1456: ST_TO_ADDR
// for i = 1 to 5 do
1457: LD_ADDR_VAR 0 3
1461: PUSH
1462: DOUBLE
1463: LD_INT 1
1465: DEC
1466: ST_TO_ADDR
1467: LD_INT 5
1469: PUSH
1470: FOR_TO
1471: IFFALSE 1598
// begin PrepareVehicle ( tmp [ 1 ] [ i mod 4 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , tmp [ 2 ] [ i mod 3 + 1 ] , 100 ) ;
1473: LD_VAR 0 2
1477: PUSH
1478: LD_INT 1
1480: ARRAY
1481: PUSH
1482: LD_VAR 0 3
1486: PUSH
1487: LD_INT 4
1489: MOD
1490: PUSH
1491: LD_INT 1
1493: PLUS
1494: ARRAY
1495: PPUSH
1496: LD_INT 1
1498: PUSH
1499: LD_INT 3
1501: PUSH
1502: EMPTY
1503: LIST
1504: LIST
1505: PUSH
1506: LD_INT 1
1508: PPUSH
1509: LD_INT 2
1511: PPUSH
1512: CALL_OW 12
1516: ARRAY
1517: PPUSH
1518: LD_INT 1
1520: PPUSH
1521: LD_VAR 0 2
1525: PUSH
1526: LD_INT 2
1528: ARRAY
1529: PUSH
1530: LD_VAR 0 3
1534: PUSH
1535: LD_INT 3
1537: MOD
1538: PUSH
1539: LD_INT 1
1541: PLUS
1542: ARRAY
1543: PPUSH
1544: LD_INT 100
1546: PPUSH
1547: CALL 700 0 5
// veh := CreateVehicle ;
1551: LD_ADDR_VAR 0 4
1555: PUSH
1556: CALL_OW 45
1560: ST_TO_ADDR
// SetDir ( veh , rand ( 0 , 5 ) ) ;
1561: LD_VAR 0 4
1565: PPUSH
1566: LD_INT 0
1568: PPUSH
1569: LD_INT 5
1571: PPUSH
1572: CALL_OW 12
1576: PPUSH
1577: CALL_OW 233
// PlaceUnitArea ( veh , freedom_base , false ) ;
1581: LD_VAR 0 4
1585: PPUSH
1586: LD_INT 1
1588: PPUSH
1589: LD_INT 0
1591: PPUSH
1592: CALL_OW 49
// end ;
1596: GO 1470
1598: POP
1599: POP
// if not FilterAllUnits ( [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) then
1600: LD_INT 2
1602: PUSH
1603: LD_INT 34
1605: PUSH
1606: LD_INT 12
1608: PUSH
1609: EMPTY
1610: LIST
1611: LIST
1612: PUSH
1613: LD_INT 34
1615: PUSH
1616: LD_INT 51
1618: PUSH
1619: EMPTY
1620: LIST
1621: LIST
1622: PUSH
1623: EMPTY
1624: LIST
1625: LIST
1626: LIST
1627: PPUSH
1628: CALL_OW 69
1632: NOT
1633: IFFALSE 1699
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 0 ) ;
1635: LD_INT 22
1637: PPUSH
1638: LD_INT 3
1640: PPUSH
1641: LD_INT 1
1643: PPUSH
1644: LD_INT 51
1646: PPUSH
1647: LD_INT 0
1649: PPUSH
1650: CALL 700 0 5
// veh := CreateVehicle ;
1654: LD_ADDR_VAR 0 4
1658: PUSH
1659: CALL_OW 45
1663: ST_TO_ADDR
// SetDir ( veh , rand ( 0 , 5 ) ) ;
1664: LD_VAR 0 4
1668: PPUSH
1669: LD_INT 0
1671: PPUSH
1672: LD_INT 5
1674: PPUSH
1675: CALL_OW 12
1679: PPUSH
1680: CALL_OW 233
// PlaceUnitArea ( veh , freedom_base , false ) ;
1684: LD_VAR 0 4
1688: PPUSH
1689: LD_INT 1
1691: PPUSH
1692: LD_INT 0
1694: PPUSH
1695: CALL_OW 49
// end ; tmp := LoadVariable ( 13a_Masha , [ ] ) ;
1699: LD_ADDR_VAR 0 2
1703: PUSH
1704: LD_STRING 13a_Masha
1706: PPUSH
1707: EMPTY
1708: PPUSH
1709: CALL_OW 30
1713: ST_TO_ADDR
// if tmp then
1714: LD_VAR 0 2
1718: IFFALSE 1801
// begin PrepareVehicle ( tmp [ 1 ] , tmp [ 2 ] , tmp [ 3 ] , tmp [ 4 ] , 100 ) ;
1720: LD_VAR 0 2
1724: PUSH
1725: LD_INT 1
1727: ARRAY
1728: PPUSH
1729: LD_VAR 0 2
1733: PUSH
1734: LD_INT 2
1736: ARRAY
1737: PPUSH
1738: LD_VAR 0 2
1742: PUSH
1743: LD_INT 3
1745: ARRAY
1746: PPUSH
1747: LD_VAR 0 2
1751: PUSH
1752: LD_INT 4
1754: ARRAY
1755: PPUSH
1756: LD_INT 100
1758: PPUSH
1759: CALL 700 0 5
// Masha := CreateVehicle ;
1763: LD_ADDR_EXP 36
1767: PUSH
1768: CALL_OW 45
1772: ST_TO_ADDR
// PlaceUnitArea ( Masha , freedom_base , false ) ;
1773: LD_EXP 36
1777: PPUSH
1778: LD_INT 1
1780: PPUSH
1781: LD_INT 0
1783: PPUSH
1784: CALL_OW 49
// SetMark ( Masha , - 7 ) ;
1788: LD_EXP 36
1792: PPUSH
1793: LD_INT 7
1795: NEG
1796: PPUSH
1797: CALL_OW 242
// end ; uc_side := 4 ;
1801: LD_ADDR_OWVAR 20
1805: PUSH
1806: LD_INT 4
1808: ST_TO_ADDR
// tmp := [ ] ;
1809: LD_ADDR_VAR 0 2
1813: PUSH
1814: EMPTY
1815: ST_TO_ADDR
// squad1 := [ ] ;
1816: LD_ADDR_EXP 37
1820: PUSH
1821: EMPTY
1822: ST_TO_ADDR
// squad2 := [ ] ;
1823: LD_ADDR_EXP 38
1827: PUSH
1828: EMPTY
1829: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1830: LD_ADDR_EXP 19
1834: PUSH
1835: LD_STRING Joan
1837: PPUSH
1838: LD_EXP 1
1842: NOT
1843: PPUSH
1844: LD_STRING 13a_
1846: PPUSH
1847: CALL 637 0 3
1851: ST_TO_ADDR
// if Joan then
1852: LD_EXP 19
1856: IFFALSE 1874
// tmp := tmp ^ Joan ;
1858: LD_ADDR_VAR 0 2
1862: PUSH
1863: LD_VAR 0 2
1867: PUSH
1868: LD_EXP 19
1872: ADD
1873: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1874: LD_ADDR_EXP 5
1878: PUSH
1879: LD_STRING Roth
1881: PPUSH
1882: LD_EXP 1
1886: NOT
1887: PPUSH
1888: LD_STRING 13a_
1890: PPUSH
1891: CALL 637 0 3
1895: ST_TO_ADDR
// if Roth then
1896: LD_EXP 5
1900: IFFALSE 1918
// tmp := tmp ^ Roth ;
1902: LD_ADDR_VAR 0 2
1906: PUSH
1907: LD_VAR 0 2
1911: PUSH
1912: LD_EXP 5
1916: ADD
1917: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1918: LD_ADDR_EXP 10
1922: PUSH
1923: LD_STRING Denis
1925: PPUSH
1926: LD_EXP 1
1930: NOT
1931: PPUSH
1932: LD_STRING 13a_
1934: PPUSH
1935: CALL 637 0 3
1939: ST_TO_ADDR
// if Denis then
1940: LD_EXP 10
1944: IFFALSE 1962
// tmp := tmp ^ Denis ;
1946: LD_ADDR_VAR 0 2
1950: PUSH
1951: LD_VAR 0 2
1955: PUSH
1956: LD_EXP 10
1960: ADD
1961: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1962: LD_ADDR_EXP 20
1966: PUSH
1967: LD_STRING DeltaDoctor
1969: PPUSH
1970: LD_EXP 1
1974: NOT
1975: PPUSH
1976: LD_STRING 13a_
1978: PPUSH
1979: CALL 637 0 3
1983: ST_TO_ADDR
// if DeltaDoctor then
1984: LD_EXP 20
1988: IFFALSE 2006
// tmp := tmp ^ DeltaDoctor ;
1990: LD_ADDR_VAR 0 2
1994: PUSH
1995: LD_VAR 0 2
1999: PUSH
2000: LD_EXP 20
2004: ADD
2005: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
2006: LD_ADDR_EXP 18
2010: PUSH
2011: LD_STRING Simms
2013: PPUSH
2014: LD_EXP 1
2018: NOT
2019: PPUSH
2020: LD_STRING 13a_
2022: PPUSH
2023: CALL 637 0 3
2027: ST_TO_ADDR
// if Simms then
2028: LD_EXP 18
2032: IFFALSE 2050
// tmp := tmp ^ Simms ;
2034: LD_ADDR_VAR 0 2
2038: PUSH
2039: LD_VAR 0 2
2043: PUSH
2044: LD_EXP 18
2048: ADD
2049: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
2050: LD_ADDR_EXP 21
2054: PUSH
2055: LD_STRING Gossudarov
2057: PPUSH
2058: LD_EXP 1
2062: NOT
2063: PPUSH
2064: LD_STRING 13a_
2066: PPUSH
2067: CALL 637 0 3
2071: ST_TO_ADDR
// if Gossudarov then
2072: LD_EXP 21
2076: IFFALSE 2094
// tmp := tmp ^ Gossudarov ;
2078: LD_ADDR_VAR 0 2
2082: PUSH
2083: LD_VAR 0 2
2087: PUSH
2088: LD_EXP 21
2092: ADD
2093: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
2094: LD_ADDR_EXP 22
2098: PUSH
2099: LD_STRING Kirilenkova
2101: PPUSH
2102: LD_EXP 1
2106: NOT
2107: PPUSH
2108: LD_STRING 13a_
2110: PPUSH
2111: CALL 637 0 3
2115: ST_TO_ADDR
// if Kirilenkova then
2116: LD_EXP 22
2120: IFFALSE 2138
// tmp := tmp ^ Kirilenkova ;
2122: LD_ADDR_VAR 0 2
2126: PUSH
2127: LD_VAR 0 2
2131: PUSH
2132: LD_EXP 22
2136: ADD
2137: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
2138: LD_ADDR_EXP 25
2142: PUSH
2143: LD_STRING Petrosyan
2145: PPUSH
2146: LD_EXP 1
2150: NOT
2151: PPUSH
2152: LD_STRING 13a_
2154: PPUSH
2155: CALL 637 0 3
2159: ST_TO_ADDR
// if Petrosyan then
2160: LD_EXP 25
2164: IFFALSE 2182
// tmp := tmp ^ Petrosyan ;
2166: LD_ADDR_VAR 0 2
2170: PUSH
2171: LD_VAR 0 2
2175: PUSH
2176: LD_EXP 25
2180: ADD
2181: ST_TO_ADDR
// Scholtze := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
2182: LD_ADDR_EXP 26
2186: PUSH
2187: LD_STRING Petrosyan
2189: PPUSH
2190: LD_EXP 1
2194: NOT
2195: PPUSH
2196: LD_STRING 13a_
2198: PPUSH
2199: CALL 637 0 3
2203: ST_TO_ADDR
// if Scholtze then
2204: LD_EXP 26
2208: IFFALSE 2226
// tmp := tmp ^ Scholtze ;
2210: LD_ADDR_VAR 0 2
2214: PUSH
2215: LD_VAR 0 2
2219: PUSH
2220: LD_EXP 26
2224: ADD
2225: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
2226: LD_ADDR_EXP 24
2230: PUSH
2231: LD_STRING Dolgov
2233: PPUSH
2234: LD_EXP 1
2238: NOT
2239: PPUSH
2240: LD_STRING 13a_
2242: PPUSH
2243: CALL 637 0 3
2247: ST_TO_ADDR
// if Dolgov then
2248: LD_EXP 24
2252: IFFALSE 2270
// tmp := tmp ^ Dolgov ;
2254: LD_ADDR_VAR 0 2
2258: PUSH
2259: LD_VAR 0 2
2263: PUSH
2264: LD_EXP 24
2268: ADD
2269: ST_TO_ADDR
// for i in tmp do
2270: LD_ADDR_VAR 0 3
2274: PUSH
2275: LD_VAR 0 2
2279: PUSH
2280: FOR_IN
2281: IFFALSE 2306
// PlaceUnitXYR ( i , 160 , 78 , 22 , false ) ;
2283: LD_VAR 0 3
2287: PPUSH
2288: LD_INT 160
2290: PPUSH
2291: LD_INT 78
2293: PPUSH
2294: LD_INT 22
2296: PPUSH
2297: LD_INT 0
2299: PPUSH
2300: CALL_OW 50
2304: GO 2280
2306: POP
2307: POP
// squad1 := tmp ;
2308: LD_ADDR_EXP 37
2312: PUSH
2313: LD_VAR 0 2
2317: ST_TO_ADDR
// tmp := [ ] ;
2318: LD_ADDR_VAR 0 2
2322: PUSH
2323: EMPTY
2324: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrova , ( not debug ) , 13a_ ) ;
2325: LD_ADDR_EXP 30
2329: PUSH
2330: LD_STRING Petrova
2332: PPUSH
2333: LD_EXP 1
2337: NOT
2338: PPUSH
2339: LD_STRING 13a_
2341: PPUSH
2342: CALL 637 0 3
2346: ST_TO_ADDR
// if Petrovova then
2347: LD_EXP 30
2351: IFFALSE 2369
// tmp := tmp ^ Petrovova ;
2353: LD_ADDR_VAR 0 2
2357: PUSH
2358: LD_VAR 0 2
2362: PUSH
2363: LD_EXP 30
2367: ADD
2368: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
2369: LD_ADDR_EXP 23
2373: PUSH
2374: LD_STRING Titov
2376: PPUSH
2377: LD_EXP 1
2381: NOT
2382: PPUSH
2383: LD_STRING 13a_
2385: PPUSH
2386: CALL 637 0 3
2390: ST_TO_ADDR
// if Titov then
2391: LD_EXP 23
2395: IFFALSE 2413
// tmp := tmp ^ Titov ;
2397: LD_ADDR_VAR 0 2
2401: PUSH
2402: LD_VAR 0 2
2406: PUSH
2407: LD_EXP 23
2411: ADD
2412: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2413: LD_ADDR_EXP 33
2417: PUSH
2418: LD_STRING Karamazov
2420: PPUSH
2421: LD_EXP 1
2425: NOT
2426: PPUSH
2427: LD_STRING 13a_
2429: PPUSH
2430: CALL 637 0 3
2434: ST_TO_ADDR
// if Karamazov then
2435: LD_EXP 33
2439: IFFALSE 2457
// tmp := tmp ^ Karamazov ;
2441: LD_ADDR_VAR 0 2
2445: PUSH
2446: LD_VAR 0 2
2450: PUSH
2451: LD_EXP 33
2455: ADD
2456: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
2457: LD_ADDR_EXP 16
2461: PUSH
2462: LD_STRING Frank
2464: PPUSH
2465: LD_EXP 1
2469: NOT
2470: PPUSH
2471: LD_STRING 13a_
2473: PPUSH
2474: CALL 637 0 3
2478: ST_TO_ADDR
// if Frank then
2479: LD_EXP 16
2483: IFFALSE 2501
// tmp := tmp ^ Frank ;
2485: LD_ADDR_VAR 0 2
2489: PUSH
2490: LD_VAR 0 2
2494: PUSH
2495: LD_EXP 16
2499: ADD
2500: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2501: LD_ADDR_EXP 7
2505: PUSH
2506: LD_STRING Donaldson
2508: PPUSH
2509: LD_EXP 1
2513: NOT
2514: PPUSH
2515: LD_STRING 13a_
2517: PPUSH
2518: CALL 637 0 3
2522: ST_TO_ADDR
// if Donaldson then
2523: LD_EXP 7
2527: IFFALSE 2545
// tmp := tmp ^ Donaldson ;
2529: LD_ADDR_VAR 0 2
2533: PUSH
2534: LD_VAR 0 2
2538: PUSH
2539: LD_EXP 7
2543: ADD
2544: ST_TO_ADDR
// for i in tmp do
2545: LD_ADDR_VAR 0 3
2549: PUSH
2550: LD_VAR 0 2
2554: PUSH
2555: FOR_IN
2556: IFFALSE 2596
// begin PlaceUnitXYR ( i , 117 , 8 , 6 , false ) ;
2558: LD_VAR 0 3
2562: PPUSH
2563: LD_INT 117
2565: PPUSH
2566: LD_INT 8
2568: PPUSH
2569: LD_INT 6
2571: PPUSH
2572: LD_INT 0
2574: PPUSH
2575: CALL_OW 50
// ComTurnXY ( i , 117 , 8 ) ;
2579: LD_VAR 0 3
2583: PPUSH
2584: LD_INT 117
2586: PPUSH
2587: LD_INT 8
2589: PPUSH
2590: CALL_OW 118
// end ;
2594: GO 2555
2596: POP
2597: POP
// squad2 := tmp ;
2598: LD_ADDR_EXP 38
2602: PUSH
2603: LD_VAR 0 2
2607: ST_TO_ADDR
// uc_side := 0 ;
2608: LD_ADDR_OWVAR 20
2612: PUSH
2613: LD_INT 0
2615: ST_TO_ADDR
// uc_nation := 0 ;
2616: LD_ADDR_OWVAR 21
2620: PUSH
2621: LD_INT 0
2623: ST_TO_ADDR
// InitHc ;
2624: CALL_OW 19
// hc_importance := 0 ;
2628: LD_ADDR_OWVAR 32
2632: PUSH
2633: LD_INT 0
2635: ST_TO_ADDR
// hc_name := Find some goods! ;
2636: LD_ADDR_OWVAR 26
2640: PUSH
2641: LD_STRING Find some goods!
2643: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
2644: LD_INT 0
2646: PPUSH
2647: LD_INT 12
2649: PPUSH
2650: LD_INT 1
2652: PPUSH
2653: CALL_OW 380
// PlaceUnitXY ( CreateHuman , 96 , 108 , false ) ;
2657: CALL_OW 44
2661: PPUSH
2662: LD_INT 96
2664: PPUSH
2665: LD_INT 108
2667: PPUSH
2668: LD_INT 0
2670: PPUSH
2671: CALL_OW 48
// InitHc ;
2675: CALL_OW 19
// end ;
2679: LD_VAR 0 1
2683: RET
// every 3 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 0 ] ] ) do var Louis , veh ;
2684: LD_INT 22
2686: PUSH
2687: LD_INT 7
2689: PUSH
2690: EMPTY
2691: LIST
2692: LIST
2693: PUSH
2694: LD_INT 23
2696: PUSH
2697: LD_INT 0
2699: PUSH
2700: EMPTY
2701: LIST
2702: LIST
2703: PUSH
2704: EMPTY
2705: LIST
2706: LIST
2707: PPUSH
2708: CALL_OW 69
2712: IFFALSE 3177
2714: GO 2716
2716: DISABLE
2717: LD_INT 0
2719: PPUSH
2720: PPUSH
// begin InGameOn ;
2721: CALL_OW 8
// RemoveUnit ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 0 ] ] ) [ 1 ] ) ;
2725: LD_INT 22
2727: PUSH
2728: LD_INT 7
2730: PUSH
2731: EMPTY
2732: LIST
2733: LIST
2734: PUSH
2735: LD_INT 23
2737: PUSH
2738: LD_INT 0
2740: PUSH
2741: EMPTY
2742: LIST
2743: LIST
2744: PUSH
2745: EMPTY
2746: LIST
2747: LIST
2748: PPUSH
2749: CALL_OW 69
2753: PUSH
2754: LD_INT 1
2756: ARRAY
2757: PPUSH
2758: CALL_OW 64
// game_speed := 4 ;
2762: LD_ADDR_OWVAR 65
2766: PUSH
2767: LD_INT 4
2769: ST_TO_ADDR
// ComMoveXY ( JMM , 93 , 100 ) ;
2770: LD_EXP 2
2774: PPUSH
2775: LD_INT 93
2777: PPUSH
2778: LD_INT 100
2780: PPUSH
2781: CALL_OW 111
// ComMoveXY ( Burlak , 93 , 99 ) ;
2785: LD_EXP 3
2789: PPUSH
2790: LD_INT 93
2792: PPUSH
2793: LD_INT 99
2795: PPUSH
2796: CALL_OW 111
// AddComTurnXY ( [ JMM , Burlak ] , 81 , 112 ) ;
2800: LD_EXP 2
2804: PUSH
2805: LD_EXP 3
2809: PUSH
2810: EMPTY
2811: LIST
2812: LIST
2813: PPUSH
2814: LD_INT 81
2816: PPUSH
2817: LD_INT 112
2819: PPUSH
2820: CALL_OW 178
// wait ( 0 0$5 ) ;
2824: LD_INT 175
2826: PPUSH
2827: CALL_OW 67
// music_nat := 2 ;
2831: LD_ADDR_OWVAR 71
2835: PUSH
2836: LD_INT 2
2838: ST_TO_ADDR
// music_class := 4 ;
2839: LD_ADDR_OWVAR 72
2843: PUSH
2844: LD_INT 4
2846: ST_TO_ADDR
// CenterNowOnXY ( 80 , 130 ) ;
2847: LD_INT 80
2849: PPUSH
2850: LD_INT 130
2852: PPUSH
2853: CALL_OW 86
// uc_nation := 2 ;
2857: LD_ADDR_OWVAR 21
2861: PUSH
2862: LD_INT 2
2864: ST_TO_ADDR
// uc_side := 2 ;
2865: LD_ADDR_OWVAR 20
2869: PUSH
2870: LD_INT 2
2872: ST_TO_ADDR
// hc_gallery = sandar ;
2873: LD_ADDR_OWVAR 33
2877: PUSH
2878: LD_STRING sandar
2880: ST_TO_ADDR
// hc_face_number = 1 ;
2881: LD_ADDR_OWVAR 34
2885: PUSH
2886: LD_INT 1
2888: ST_TO_ADDR
// hc_name = Louis Schulz ;
2889: LD_ADDR_OWVAR 26
2893: PUSH
2894: LD_STRING Louis Schulz
2896: ST_TO_ADDR
// hc_attr = [ 13 , 11 ] ;
2897: LD_ADDR_OWVAR 29
2901: PUSH
2902: LD_INT 13
2904: PUSH
2905: LD_INT 11
2907: PUSH
2908: EMPTY
2909: LIST
2910: LIST
2911: ST_TO_ADDR
// hc_basic_skills = [ 0 , 0 , 0 , 0 ] ;
2912: LD_ADDR_OWVAR 30
2916: PUSH
2917: LD_INT 0
2919: PUSH
2920: LD_INT 0
2922: PUSH
2923: LD_INT 0
2925: PUSH
2926: LD_INT 0
2928: PUSH
2929: EMPTY
2930: LIST
2931: LIST
2932: LIST
2933: LIST
2934: ST_TO_ADDR
// hc_skills = [ 10 , 6 , 7 , 7 ] ;
2935: LD_ADDR_OWVAR 31
2939: PUSH
2940: LD_INT 10
2942: PUSH
2943: LD_INT 6
2945: PUSH
2946: LD_INT 7
2948: PUSH
2949: LD_INT 7
2951: PUSH
2952: EMPTY
2953: LIST
2954: LIST
2955: LIST
2956: LIST
2957: ST_TO_ADDR
// hc_sex = sex_male ;
2958: LD_ADDR_OWVAR 27
2962: PUSH
2963: LD_INT 1
2965: ST_TO_ADDR
// hc_class = 1 ;
2966: LD_ADDR_OWVAR 28
2970: PUSH
2971: LD_INT 1
2973: ST_TO_ADDR
// hc_importance = 100 ;
2974: LD_ADDR_OWVAR 32
2978: PUSH
2979: LD_INT 100
2981: ST_TO_ADDR
// Louis = CreateHuman ;
2982: LD_ADDR_VAR 0 1
2986: PUSH
2987: CALL_OW 44
2991: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_flame_thrower , 100 ) ;
2992: LD_INT 14
2994: PPUSH
2995: LD_INT 3
2997: PPUSH
2998: LD_INT 1
3000: PPUSH
3001: LD_INT 26
3003: PPUSH
3004: LD_INT 100
3006: PPUSH
3007: CALL 700 0 5
// veh := CreateVehicle ;
3011: LD_ADDR_VAR 0 2
3015: PUSH
3016: CALL_OW 45
3020: ST_TO_ADDR
// SetMark ( veh , - 2 ) ;
3021: LD_VAR 0 2
3025: PPUSH
3026: LD_INT 2
3028: NEG
3029: PPUSH
3030: CALL_OW 242
// PlaceUnitXY ( veh , 80 , 130 , false ) ;
3034: LD_VAR 0 2
3038: PPUSH
3039: LD_INT 80
3041: PPUSH
3042: LD_INT 130
3044: PPUSH
3045: LD_INT 0
3047: PPUSH
3048: CALL_OW 48
// PlaceHumanInUnit ( Louis , veh ) ;
3052: LD_VAR 0 1
3056: PPUSH
3057: LD_VAR 0 2
3061: PPUSH
3062: CALL_OW 52
// ComMoveXY ( Louis , 80 , 109 ) ;
3066: LD_VAR 0 1
3070: PPUSH
3071: LD_INT 80
3073: PPUSH
3074: LD_INT 109
3076: PPUSH
3077: CALL_OW 111
// AddComExitVehicle ( Louis ) ;
3081: LD_VAR 0 1
3085: PPUSH
3086: CALL_OW 181
// AddComMoveXY ( Louis , 80 , 131 ) ;
3090: LD_VAR 0 1
3094: PPUSH
3095: LD_INT 80
3097: PPUSH
3098: LD_INT 131
3100: PPUSH
3101: CALL_OW 171
// wait ( 0 0$06 ) ;
3105: LD_INT 210
3107: PPUSH
3108: CALL_OW 67
// InGameOff ;
3112: CALL_OW 9
// repeat wait ( 0 0$1 ) ;
3116: LD_INT 35
3118: PPUSH
3119: CALL_OW 67
// until IsAt ( Louis , 80 , 131 ) ;
3123: LD_VAR 0 1
3127: PPUSH
3128: LD_INT 80
3130: PPUSH
3131: LD_INT 131
3133: PPUSH
3134: CALL_OW 307
3138: IFFALSE 3116
// SetSide ( veh , 7 ) ;
3140: LD_VAR 0 2
3144: PPUSH
3145: LD_INT 7
3147: PPUSH
3148: CALL_OW 235
// RemoveUnit ( Louis ) ;
3152: LD_VAR 0 1
3156: PPUSH
3157: CALL_OW 64
// music_nat := 3 ;
3161: LD_ADDR_OWVAR 71
3165: PUSH
3166: LD_INT 3
3168: ST_TO_ADDR
// music_class := 0 ;
3169: LD_ADDR_OWVAR 72
3173: PUSH
3174: LD_INT 0
3176: ST_TO_ADDR
// end ;
3177: PPOPN 2
3179: END
// every 0 0$10 trigger squad1 do var i , xy ;
3180: LD_EXP 37
3184: IFFALSE 3547
3186: GO 3188
3188: DISABLE
3189: LD_INT 0
3191: PPUSH
3192: PPUSH
// begin enable ;
3193: ENABLE
// i := squad1 [ rand ( 1 , squad1 ) ] ;
3194: LD_ADDR_VAR 0 1
3198: PUSH
3199: LD_EXP 37
3203: PUSH
3204: LD_INT 1
3206: PPUSH
3207: LD_EXP 37
3211: PPUSH
3212: CALL_OW 12
3216: ARRAY
3217: ST_TO_ADDR
// if IsInUnit ( i ) then
3218: LD_VAR 0 1
3222: PPUSH
3223: CALL_OW 310
3227: IFFALSE 3231
// exit ;
3229: GO 3547
// ComRemember ( i ) ;
3231: LD_VAR 0 1
3235: PPUSH
3236: CALL_OW 143
// xy := [ ShiftX ( GetX ( i ) , rand ( 0 , 5 ) , rand ( 2 , 7 ) ) , ShiftY ( GetY ( i ) , rand ( 0 , 5 ) , rand ( 2 , 7 ) ) ] ;
3240: LD_ADDR_VAR 0 2
3244: PUSH
3245: LD_VAR 0 1
3249: PPUSH
3250: CALL_OW 250
3254: PPUSH
3255: LD_INT 0
3257: PPUSH
3258: LD_INT 5
3260: PPUSH
3261: CALL_OW 12
3265: PPUSH
3266: LD_INT 2
3268: PPUSH
3269: LD_INT 7
3271: PPUSH
3272: CALL_OW 12
3276: PPUSH
3277: CALL_OW 272
3281: PUSH
3282: LD_VAR 0 1
3286: PPUSH
3287: CALL_OW 251
3291: PPUSH
3292: LD_INT 0
3294: PPUSH
3295: LD_INT 5
3297: PPUSH
3298: CALL_OW 12
3302: PPUSH
3303: LD_INT 2
3305: PPUSH
3306: LD_INT 7
3308: PPUSH
3309: CALL_OW 12
3313: PPUSH
3314: CALL_OW 273
3318: PUSH
3319: EMPTY
3320: LIST
3321: LIST
3322: ST_TO_ADDR
// if HexInfo ( xy [ 1 ] , xy [ 2 ] ) <> 0 or not ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
3323: LD_VAR 0 2
3327: PUSH
3328: LD_INT 1
3330: ARRAY
3331: PPUSH
3332: LD_VAR 0 2
3336: PUSH
3337: LD_INT 2
3339: ARRAY
3340: PPUSH
3341: CALL_OW 428
3345: PUSH
3346: LD_INT 0
3348: NONEQUAL
3349: PUSH
3350: LD_VAR 0 2
3354: PUSH
3355: LD_INT 1
3357: ARRAY
3358: PPUSH
3359: LD_VAR 0 2
3363: PUSH
3364: LD_INT 2
3366: ARRAY
3367: PPUSH
3368: CALL_OW 488
3372: NOT
3373: OR
3374: IFFALSE 3378
// exit ;
3376: GO 3547
// AddComMoveXY ( i , xy [ 1 ] , xy [ 2 ] ) ;
3378: LD_VAR 0 1
3382: PPUSH
3383: LD_VAR 0 2
3387: PUSH
3388: LD_INT 1
3390: ARRAY
3391: PPUSH
3392: LD_VAR 0 2
3396: PUSH
3397: LD_INT 2
3399: ARRAY
3400: PPUSH
3401: CALL_OW 171
// AddComWait ( i , 0 0$10 ) ;
3405: LD_VAR 0 1
3409: PPUSH
3410: LD_INT 350
3412: PPUSH
3413: CALL_OW 202
// if Prob ( 60 ) and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) then
3417: LD_INT 60
3419: PPUSH
3420: CALL_OW 13
3424: PUSH
3425: LD_INT 22
3427: PUSH
3428: LD_INT 4
3430: PUSH
3431: EMPTY
3432: LIST
3433: LIST
3434: PUSH
3435: LD_INT 21
3437: PUSH
3438: LD_INT 3
3440: PUSH
3441: EMPTY
3442: LIST
3443: LIST
3444: PUSH
3445: EMPTY
3446: LIST
3447: LIST
3448: PPUSH
3449: CALL_OW 69
3453: AND
3454: IFFALSE 3538
// begin AddComEnterUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , i ) ) ;
3456: LD_VAR 0 1
3460: PPUSH
3461: LD_INT 22
3463: PUSH
3464: LD_INT 4
3466: PUSH
3467: EMPTY
3468: LIST
3469: LIST
3470: PUSH
3471: LD_INT 21
3473: PUSH
3474: LD_INT 3
3476: PUSH
3477: EMPTY
3478: LIST
3479: LIST
3480: PUSH
3481: EMPTY
3482: LIST
3483: LIST
3484: PPUSH
3485: CALL_OW 69
3489: PPUSH
3490: LD_VAR 0 1
3494: PPUSH
3495: CALL_OW 74
3499: PPUSH
3500: CALL_OW 180
// repeat wait ( 0 0$30 ) ;
3504: LD_INT 1050
3506: PPUSH
3507: CALL_OW 67
// until IsInUnit ( i ) ;
3511: LD_VAR 0 1
3515: PPUSH
3516: CALL_OW 310
3520: IFFALSE 3504
// wait ( 0 0$30 ) ;
3522: LD_INT 1050
3524: PPUSH
3525: CALL_OW 67
// AddComExitBuilding ( i ) ;
3529: LD_VAR 0 1
3533: PPUSH
3534: CALL_OW 182
// end ; AddComReturn ( i ) ;
3538: LD_VAR 0 1
3542: PPUSH
3543: CALL_OW 204
// end ; end_of_file
3547: PPOPN 2
3549: END
// export function Action ; begin
3550: LD_INT 0
3552: PPUSH
// InGameOn ;
3553: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
3557: LD_EXP 2
3561: PPUSH
3562: CALL_OW 87
// Say ( JMM , D1-JMM-1 ) ;
3566: LD_EXP 2
3570: PPUSH
3571: LD_STRING D1-JMM-1
3573: PPUSH
3574: CALL_OW 88
// Say ( Burlak , D1-Bur-1 ) ;
3578: LD_EXP 3
3582: PPUSH
3583: LD_STRING D1-Bur-1
3585: PPUSH
3586: CALL_OW 88
// Say ( JMM , D1-JMM-2 ) ;
3590: LD_EXP 2
3594: PPUSH
3595: LD_STRING D1-JMM-2
3597: PPUSH
3598: CALL_OW 88
// Say ( Burlak , D1-Bur-2 ) ;
3602: LD_EXP 3
3606: PPUSH
3607: LD_STRING D1-Bur-2
3609: PPUSH
3610: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
3614: LD_EXP 2
3618: PPUSH
3619: LD_STRING D1-JMM-3
3621: PPUSH
3622: CALL_OW 88
// Say ( Burlak , D1-Bur-3 ) ;
3626: LD_EXP 3
3630: PPUSH
3631: LD_STRING D1-Bur-3
3633: PPUSH
3634: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
3638: LD_EXP 2
3642: PPUSH
3643: LD_STRING D1-JMM-4
3645: PPUSH
3646: CALL_OW 88
// Say ( Burlak , D1-Bur-4 ) ;
3650: LD_EXP 3
3654: PPUSH
3655: LD_STRING D1-Bur-4
3657: PPUSH
3658: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
3662: LD_EXP 2
3666: PPUSH
3667: LD_STRING D1-JMM-5
3669: PPUSH
3670: CALL_OW 88
// Say ( Burlak , D1-Bur-5 ) ;
3674: LD_EXP 3
3678: PPUSH
3679: LD_STRING D1-Bur-5
3681: PPUSH
3682: CALL_OW 88
// Say ( JMM , D1-JMM-6 ) ;
3686: LD_EXP 2
3690: PPUSH
3691: LD_STRING D1-JMM-6
3693: PPUSH
3694: CALL_OW 88
// Say ( Burlak , D1-Bur-6 ) ;
3698: LD_EXP 3
3702: PPUSH
3703: LD_STRING D1-Bur-6
3705: PPUSH
3706: CALL_OW 88
// Say ( JMM , D1-JMM-7 ) ;
3710: LD_EXP 2
3714: PPUSH
3715: LD_STRING D1-JMM-7
3717: PPUSH
3718: CALL_OW 88
// wait ( 20 ) ;
3722: LD_INT 20
3724: PPUSH
3725: CALL_OW 67
// Query ( QTruck ) ;
3729: LD_STRING QTruck
3731: PPUSH
3732: CALL_OW 97
// InGameOff ;
3736: CALL_OW 9
// ChangeMissionObjectives ( MArtPickup ) ;
3740: LD_STRING MArtPickup
3742: PPUSH
3743: CALL_OW 337
// SetAreaMapShow ( escape_area , 1 ) ;
3747: LD_INT 2
3749: PPUSH
3750: LD_INT 1
3752: PPUSH
3753: CALL_OW 424
// end ;
3757: LD_VAR 0 1
3761: RET
// every 0 0$3 trigger FilterUnitsInArea ( escape_area , [ [ f_type , unit_vehicle ] , [ f_control , control_manual ] , [ f_not , [ f_empty ] ] ] ) = 2 and IsInUnit ( JMM ) and IsInUnit ( Burlak ) and ( GetWeapon ( IsInUnit ( JMM ) ) in [ ru_cargo_bay , us_cargo_bay , ru_big_cargo_bay , ar_cargo_bay ] or GetWeapon ( IsInUnit ( Burlak ) ) in [ ru_cargo_bay , us_cargo_bay , ru_big_cargo_bay , ar_cargo_bay ] ) do var i , macmilanVeh , burlakVeh ;
3762: LD_INT 2
3764: PPUSH
3765: LD_INT 21
3767: PUSH
3768: LD_INT 2
3770: PUSH
3771: EMPTY
3772: LIST
3773: LIST
3774: PUSH
3775: LD_INT 33
3777: PUSH
3778: LD_INT 1
3780: PUSH
3781: EMPTY
3782: LIST
3783: LIST
3784: PUSH
3785: LD_INT 3
3787: PUSH
3788: LD_INT 58
3790: PUSH
3791: EMPTY
3792: LIST
3793: PUSH
3794: EMPTY
3795: LIST
3796: LIST
3797: PUSH
3798: EMPTY
3799: LIST
3800: LIST
3801: LIST
3802: PPUSH
3803: CALL_OW 70
3807: PUSH
3808: LD_INT 2
3810: EQUAL
3811: PUSH
3812: LD_EXP 2
3816: PPUSH
3817: CALL_OW 310
3821: AND
3822: PUSH
3823: LD_EXP 3
3827: PPUSH
3828: CALL_OW 310
3832: AND
3833: PUSH
3834: LD_EXP 2
3838: PPUSH
3839: CALL_OW 310
3843: PPUSH
3844: CALL_OW 264
3848: PUSH
3849: LD_INT 51
3851: PUSH
3852: LD_INT 12
3854: PUSH
3855: LD_EXP 40
3859: PUSH
3860: LD_INT 32
3862: PUSH
3863: EMPTY
3864: LIST
3865: LIST
3866: LIST
3867: LIST
3868: IN
3869: PUSH
3870: LD_EXP 3
3874: PPUSH
3875: CALL_OW 310
3879: PPUSH
3880: CALL_OW 264
3884: PUSH
3885: LD_INT 51
3887: PUSH
3888: LD_INT 12
3890: PUSH
3891: LD_EXP 40
3895: PUSH
3896: LD_INT 32
3898: PUSH
3899: EMPTY
3900: LIST
3901: LIST
3902: LIST
3903: LIST
3904: IN
3905: OR
3906: AND
3907: IFFALSE 4117
3909: GO 3911
3911: DISABLE
3912: LD_INT 0
3914: PPUSH
3915: PPUSH
3916: PPUSH
// begin macmilanVeh := IsInUnit ( JMM ) ;
3917: LD_ADDR_VAR 0 2
3921: PUSH
3922: LD_EXP 2
3926: PPUSH
3927: CALL_OW 310
3931: ST_TO_ADDR
// burlakVeh := IsInUnit ( Burlak ) ;
3932: LD_ADDR_VAR 0 3
3936: PUSH
3937: LD_EXP 3
3941: PPUSH
3942: CALL_OW 310
3946: ST_TO_ADDR
// SaveVariable ( [ GetChassis ( macmilanVeh ) , GetEngine ( macmilanVeh ) , control_manual , GetWeapon ( macmilanVeh ) , GetMark ( macmilanVeh ) , GetNation ( macmilanVeh ) ] , 14a_JMMVeh ) ;
3947: LD_VAR 0 2
3951: PPUSH
3952: CALL_OW 265
3956: PUSH
3957: LD_VAR 0 2
3961: PPUSH
3962: CALL_OW 262
3966: PUSH
3967: LD_INT 1
3969: PUSH
3970: LD_VAR 0 2
3974: PPUSH
3975: CALL_OW 264
3979: PUSH
3980: LD_VAR 0 2
3984: PPUSH
3985: CALL_OW 271
3989: PUSH
3990: LD_VAR 0 2
3994: PPUSH
3995: CALL_OW 248
3999: PUSH
4000: EMPTY
4001: LIST
4002: LIST
4003: LIST
4004: LIST
4005: LIST
4006: LIST
4007: PPUSH
4008: LD_STRING 14a_JMMVeh
4010: PPUSH
4011: CALL_OW 39
// SaveVariable ( [ GetChassis ( burlakVeh ) , GetEngine ( burlakVeh ) , control_manual , GetWeapon ( burlakVeh ) , GetMark ( burlakVeh ) , GetNation ( burlakVeh ) ] , 14a_BurlakVeh ) ;
4015: LD_VAR 0 3
4019: PPUSH
4020: CALL_OW 265
4024: PUSH
4025: LD_VAR 0 3
4029: PPUSH
4030: CALL_OW 262
4034: PUSH
4035: LD_INT 1
4037: PUSH
4038: LD_VAR 0 3
4042: PPUSH
4043: CALL_OW 264
4047: PUSH
4048: LD_VAR 0 3
4052: PPUSH
4053: CALL_OW 271
4057: PUSH
4058: LD_VAR 0 3
4062: PPUSH
4063: CALL_OW 248
4067: PUSH
4068: EMPTY
4069: LIST
4070: LIST
4071: LIST
4072: LIST
4073: LIST
4074: LIST
4075: PPUSH
4076: LD_STRING 14a_BurlakVeh
4078: PPUSH
4079: CALL_OW 39
// SaveCharacters ( JMM , 14a_JMM ) ;
4083: LD_EXP 2
4087: PPUSH
4088: LD_STRING 14a_JMM
4090: PPUSH
4091: CALL_OW 38
// SaveCharacters ( Burlak , 14a_Burlak ) ;
4095: LD_EXP 3
4099: PPUSH
4100: LD_STRING 14a_Burlak
4102: PPUSH
4103: CALL_OW 38
// ChangeMap ( 1 , %_cont ) ;
4107: LD_INT 1
4109: PPUSH
4110: LD_STRING %_cont
4112: PPUSH
4113: CALL_OW 340
// end ;
4117: PPOPN 3
4119: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_lives , 950 ] ] ] ) do
4120: LD_INT 22
4122: PUSH
4123: LD_INT 4
4125: PUSH
4126: EMPTY
4127: LIST
4128: LIST
4129: PUSH
4130: LD_INT 3
4132: PUSH
4133: LD_INT 24
4135: PUSH
4136: LD_INT 950
4138: PUSH
4139: EMPTY
4140: LIST
4141: LIST
4142: PUSH
4143: EMPTY
4144: LIST
4145: LIST
4146: PUSH
4147: EMPTY
4148: LIST
4149: LIST
4150: PPUSH
4151: CALL_OW 69
4155: IFFALSE 4167
4157: GO 4159
4159: DISABLE
// YouLost ( FriendlyFire ) ;
4160: LD_STRING FriendlyFire
4162: PPUSH
4163: CALL_OW 104
4167: END
// every 0 0$1 trigger IsDead ( Burlak ) do
4168: LD_EXP 3
4172: PPUSH
4173: CALL_OW 301
4177: IFFALSE 4189
4179: GO 4181
4181: DISABLE
// YouLost ( Burlak ) ;
4182: LD_STRING Burlak
4184: PPUSH
4185: CALL_OW 104
4189: END
// every 0 0$1 trigger IsDead ( JMM ) do
4190: LD_EXP 2
4194: PPUSH
4195: CALL_OW 301
4199: IFFALSE 4211
4201: GO 4203
4203: DISABLE
// YouLost ( JMM ) ; end_of_file
4204: LD_STRING JMM
4206: PPUSH
4207: CALL_OW 104
4211: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
4212: GO 4214
4214: DISABLE
// begin ru_radar := 98 ;
4215: LD_ADDR_EXP 39
4219: PUSH
4220: LD_INT 98
4222: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
4223: LD_ADDR_EXP 40
4227: PUSH
4228: LD_INT 89
4230: ST_TO_ADDR
// us_hack := 99 ;
4231: LD_ADDR_EXP 41
4235: PUSH
4236: LD_INT 99
4238: ST_TO_ADDR
// us_artillery := 97 ;
4239: LD_ADDR_EXP 42
4243: PUSH
4244: LD_INT 97
4246: ST_TO_ADDR
// ar_bio_bomb := 91 ;
4247: LD_ADDR_EXP 43
4251: PUSH
4252: LD_INT 91
4254: ST_TO_ADDR
// end ; end_of_file end_of_file
4255: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
4256: GO 4258
4258: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
4259: LD_STRING initStreamRollete();
4261: PPUSH
4262: CALL_OW 559
// InitStreamMode ;
4266: CALL 4275 0 0
// DefineStreamItems ( ) ;
4270: CALL 4715 0 0
// end ;
4274: END
// function InitStreamMode ; begin
4275: LD_INT 0
4277: PPUSH
// streamModeActive := false ;
4278: LD_ADDR_EXP 44
4282: PUSH
4283: LD_INT 0
4285: ST_TO_ADDR
// normalCounter := 26 ;
4286: LD_ADDR_EXP 45
4290: PUSH
4291: LD_INT 26
4293: ST_TO_ADDR
// hardcoreCounter := 12 ;
4294: LD_ADDR_EXP 46
4298: PUSH
4299: LD_INT 12
4301: ST_TO_ADDR
// sRocket := false ;
4302: LD_ADDR_EXP 49
4306: PUSH
4307: LD_INT 0
4309: ST_TO_ADDR
// sSpeed := false ;
4310: LD_ADDR_EXP 48
4314: PUSH
4315: LD_INT 0
4317: ST_TO_ADDR
// sEngine := false ;
4318: LD_ADDR_EXP 50
4322: PUSH
4323: LD_INT 0
4325: ST_TO_ADDR
// sSpec := false ;
4326: LD_ADDR_EXP 47
4330: PUSH
4331: LD_INT 0
4333: ST_TO_ADDR
// sLevel := false ;
4334: LD_ADDR_EXP 51
4338: PUSH
4339: LD_INT 0
4341: ST_TO_ADDR
// sArmoury := false ;
4342: LD_ADDR_EXP 52
4346: PUSH
4347: LD_INT 0
4349: ST_TO_ADDR
// sRadar := false ;
4350: LD_ADDR_EXP 53
4354: PUSH
4355: LD_INT 0
4357: ST_TO_ADDR
// sBunker := false ;
4358: LD_ADDR_EXP 54
4362: PUSH
4363: LD_INT 0
4365: ST_TO_ADDR
// sHack := false ;
4366: LD_ADDR_EXP 55
4370: PUSH
4371: LD_INT 0
4373: ST_TO_ADDR
// sFire := false ;
4374: LD_ADDR_EXP 56
4378: PUSH
4379: LD_INT 0
4381: ST_TO_ADDR
// sRefresh := false ;
4382: LD_ADDR_EXP 57
4386: PUSH
4387: LD_INT 0
4389: ST_TO_ADDR
// sExp := false ;
4390: LD_ADDR_EXP 58
4394: PUSH
4395: LD_INT 0
4397: ST_TO_ADDR
// sDepot := false ;
4398: LD_ADDR_EXP 59
4402: PUSH
4403: LD_INT 0
4405: ST_TO_ADDR
// sFlag := false ;
4406: LD_ADDR_EXP 60
4410: PUSH
4411: LD_INT 0
4413: ST_TO_ADDR
// sKamikadze := false ;
4414: LD_ADDR_EXP 68
4418: PUSH
4419: LD_INT 0
4421: ST_TO_ADDR
// sTroll := false ;
4422: LD_ADDR_EXP 69
4426: PUSH
4427: LD_INT 0
4429: ST_TO_ADDR
// sSlow := false ;
4430: LD_ADDR_EXP 70
4434: PUSH
4435: LD_INT 0
4437: ST_TO_ADDR
// sLack := false ;
4438: LD_ADDR_EXP 71
4442: PUSH
4443: LD_INT 0
4445: ST_TO_ADDR
// sTank := false ;
4446: LD_ADDR_EXP 73
4450: PUSH
4451: LD_INT 0
4453: ST_TO_ADDR
// sRemote := false ;
4454: LD_ADDR_EXP 74
4458: PUSH
4459: LD_INT 0
4461: ST_TO_ADDR
// sPowell := false ;
4462: LD_ADDR_EXP 75
4466: PUSH
4467: LD_INT 0
4469: ST_TO_ADDR
// sTeleport := false ;
4470: LD_ADDR_EXP 78
4474: PUSH
4475: LD_INT 0
4477: ST_TO_ADDR
// sOilTower := false ;
4478: LD_ADDR_EXP 80
4482: PUSH
4483: LD_INT 0
4485: ST_TO_ADDR
// sShovel := false ;
4486: LD_ADDR_EXP 81
4490: PUSH
4491: LD_INT 0
4493: ST_TO_ADDR
// sSheik := false ;
4494: LD_ADDR_EXP 82
4498: PUSH
4499: LD_INT 0
4501: ST_TO_ADDR
// sEarthquake := false ;
4502: LD_ADDR_EXP 84
4506: PUSH
4507: LD_INT 0
4509: ST_TO_ADDR
// sAI := false ;
4510: LD_ADDR_EXP 85
4514: PUSH
4515: LD_INT 0
4517: ST_TO_ADDR
// sCargo := false ;
4518: LD_ADDR_EXP 88
4522: PUSH
4523: LD_INT 0
4525: ST_TO_ADDR
// sDLaser := false ;
4526: LD_ADDR_EXP 89
4530: PUSH
4531: LD_INT 0
4533: ST_TO_ADDR
// sExchange := false ;
4534: LD_ADDR_EXP 90
4538: PUSH
4539: LD_INT 0
4541: ST_TO_ADDR
// sFac := false ;
4542: LD_ADDR_EXP 91
4546: PUSH
4547: LD_INT 0
4549: ST_TO_ADDR
// sPower := false ;
4550: LD_ADDR_EXP 92
4554: PUSH
4555: LD_INT 0
4557: ST_TO_ADDR
// sRandom := false ;
4558: LD_ADDR_EXP 93
4562: PUSH
4563: LD_INT 0
4565: ST_TO_ADDR
// sShield := false ;
4566: LD_ADDR_EXP 94
4570: PUSH
4571: LD_INT 0
4573: ST_TO_ADDR
// sTime := false ;
4574: LD_ADDR_EXP 95
4578: PUSH
4579: LD_INT 0
4581: ST_TO_ADDR
// sTools := false ;
4582: LD_ADDR_EXP 96
4586: PUSH
4587: LD_INT 0
4589: ST_TO_ADDR
// sSold := false ;
4590: LD_ADDR_EXP 61
4594: PUSH
4595: LD_INT 0
4597: ST_TO_ADDR
// sDiff := false ;
4598: LD_ADDR_EXP 62
4602: PUSH
4603: LD_INT 0
4605: ST_TO_ADDR
// sFog := false ;
4606: LD_ADDR_EXP 65
4610: PUSH
4611: LD_INT 0
4613: ST_TO_ADDR
// sReset := false ;
4614: LD_ADDR_EXP 66
4618: PUSH
4619: LD_INT 0
4621: ST_TO_ADDR
// sSun := false ;
4622: LD_ADDR_EXP 67
4626: PUSH
4627: LD_INT 0
4629: ST_TO_ADDR
// sTiger := false ;
4630: LD_ADDR_EXP 63
4634: PUSH
4635: LD_INT 0
4637: ST_TO_ADDR
// sBomb := false ;
4638: LD_ADDR_EXP 64
4642: PUSH
4643: LD_INT 0
4645: ST_TO_ADDR
// sWound := false ;
4646: LD_ADDR_EXP 72
4650: PUSH
4651: LD_INT 0
4653: ST_TO_ADDR
// sBetray := false ;
4654: LD_ADDR_EXP 76
4658: PUSH
4659: LD_INT 0
4661: ST_TO_ADDR
// sContamin := false ;
4662: LD_ADDR_EXP 77
4666: PUSH
4667: LD_INT 0
4669: ST_TO_ADDR
// sOil := false ;
4670: LD_ADDR_EXP 79
4674: PUSH
4675: LD_INT 0
4677: ST_TO_ADDR
// sStu := false ;
4678: LD_ADDR_EXP 83
4682: PUSH
4683: LD_INT 0
4685: ST_TO_ADDR
// sBazooka := false ;
4686: LD_ADDR_EXP 86
4690: PUSH
4691: LD_INT 0
4693: ST_TO_ADDR
// sMortar := false ;
4694: LD_ADDR_EXP 87
4698: PUSH
4699: LD_INT 0
4701: ST_TO_ADDR
// sRanger := false ;
4702: LD_ADDR_EXP 97
4706: PUSH
4707: LD_INT 0
4709: ST_TO_ADDR
// end ;
4710: LD_VAR 0 1
4714: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
4715: LD_INT 0
4717: PPUSH
4718: PPUSH
4719: PPUSH
4720: PPUSH
4721: PPUSH
// result := [ ] ;
4722: LD_ADDR_VAR 0 1
4726: PUSH
4727: EMPTY
4728: ST_TO_ADDR
// if campaign_id = 1 then
4729: LD_OWVAR 69
4733: PUSH
4734: LD_INT 1
4736: EQUAL
4737: IFFALSE 7675
// begin case mission_number of 1 :
4739: LD_OWVAR 70
4743: PUSH
4744: LD_INT 1
4746: DOUBLE
4747: EQUAL
4748: IFTRUE 4752
4750: GO 4816
4752: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
4753: LD_ADDR_VAR 0 1
4757: PUSH
4758: LD_INT 2
4760: PUSH
4761: LD_INT 4
4763: PUSH
4764: LD_INT 11
4766: PUSH
4767: LD_INT 12
4769: PUSH
4770: LD_INT 15
4772: PUSH
4773: LD_INT 16
4775: PUSH
4776: LD_INT 22
4778: PUSH
4779: LD_INT 23
4781: PUSH
4782: LD_INT 26
4784: PUSH
4785: EMPTY
4786: LIST
4787: LIST
4788: LIST
4789: LIST
4790: LIST
4791: LIST
4792: LIST
4793: LIST
4794: LIST
4795: PUSH
4796: LD_INT 101
4798: PUSH
4799: LD_INT 102
4801: PUSH
4802: LD_INT 106
4804: PUSH
4805: EMPTY
4806: LIST
4807: LIST
4808: LIST
4809: PUSH
4810: EMPTY
4811: LIST
4812: LIST
4813: ST_TO_ADDR
4814: GO 7673
4816: LD_INT 2
4818: DOUBLE
4819: EQUAL
4820: IFTRUE 4824
4822: GO 4896
4824: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
4825: LD_ADDR_VAR 0 1
4829: PUSH
4830: LD_INT 2
4832: PUSH
4833: LD_INT 4
4835: PUSH
4836: LD_INT 11
4838: PUSH
4839: LD_INT 12
4841: PUSH
4842: LD_INT 15
4844: PUSH
4845: LD_INT 16
4847: PUSH
4848: LD_INT 22
4850: PUSH
4851: LD_INT 23
4853: PUSH
4854: LD_INT 26
4856: PUSH
4857: EMPTY
4858: LIST
4859: LIST
4860: LIST
4861: LIST
4862: LIST
4863: LIST
4864: LIST
4865: LIST
4866: LIST
4867: PUSH
4868: LD_INT 101
4870: PUSH
4871: LD_INT 102
4873: PUSH
4874: LD_INT 105
4876: PUSH
4877: LD_INT 106
4879: PUSH
4880: LD_INT 108
4882: PUSH
4883: EMPTY
4884: LIST
4885: LIST
4886: LIST
4887: LIST
4888: LIST
4889: PUSH
4890: EMPTY
4891: LIST
4892: LIST
4893: ST_TO_ADDR
4894: GO 7673
4896: LD_INT 3
4898: DOUBLE
4899: EQUAL
4900: IFTRUE 4904
4902: GO 4980
4904: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
4905: LD_ADDR_VAR 0 1
4909: PUSH
4910: LD_INT 2
4912: PUSH
4913: LD_INT 4
4915: PUSH
4916: LD_INT 5
4918: PUSH
4919: LD_INT 11
4921: PUSH
4922: LD_INT 12
4924: PUSH
4925: LD_INT 15
4927: PUSH
4928: LD_INT 16
4930: PUSH
4931: LD_INT 22
4933: PUSH
4934: LD_INT 26
4936: PUSH
4937: LD_INT 36
4939: PUSH
4940: EMPTY
4941: LIST
4942: LIST
4943: LIST
4944: LIST
4945: LIST
4946: LIST
4947: LIST
4948: LIST
4949: LIST
4950: LIST
4951: PUSH
4952: LD_INT 101
4954: PUSH
4955: LD_INT 102
4957: PUSH
4958: LD_INT 105
4960: PUSH
4961: LD_INT 106
4963: PUSH
4964: LD_INT 108
4966: PUSH
4967: EMPTY
4968: LIST
4969: LIST
4970: LIST
4971: LIST
4972: LIST
4973: PUSH
4974: EMPTY
4975: LIST
4976: LIST
4977: ST_TO_ADDR
4978: GO 7673
4980: LD_INT 4
4982: DOUBLE
4983: EQUAL
4984: IFTRUE 4988
4986: GO 5072
4988: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
4989: LD_ADDR_VAR 0 1
4993: PUSH
4994: LD_INT 2
4996: PUSH
4997: LD_INT 4
4999: PUSH
5000: LD_INT 5
5002: PUSH
5003: LD_INT 8
5005: PUSH
5006: LD_INT 11
5008: PUSH
5009: LD_INT 12
5011: PUSH
5012: LD_INT 15
5014: PUSH
5015: LD_INT 16
5017: PUSH
5018: LD_INT 22
5020: PUSH
5021: LD_INT 23
5023: PUSH
5024: LD_INT 26
5026: PUSH
5027: LD_INT 36
5029: PUSH
5030: EMPTY
5031: LIST
5032: LIST
5033: LIST
5034: LIST
5035: LIST
5036: LIST
5037: LIST
5038: LIST
5039: LIST
5040: LIST
5041: LIST
5042: LIST
5043: PUSH
5044: LD_INT 101
5046: PUSH
5047: LD_INT 102
5049: PUSH
5050: LD_INT 105
5052: PUSH
5053: LD_INT 106
5055: PUSH
5056: LD_INT 108
5058: PUSH
5059: EMPTY
5060: LIST
5061: LIST
5062: LIST
5063: LIST
5064: LIST
5065: PUSH
5066: EMPTY
5067: LIST
5068: LIST
5069: ST_TO_ADDR
5070: GO 7673
5072: LD_INT 5
5074: DOUBLE
5075: EQUAL
5076: IFTRUE 5080
5078: GO 5180
5080: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
5081: LD_ADDR_VAR 0 1
5085: PUSH
5086: LD_INT 2
5088: PUSH
5089: LD_INT 4
5091: PUSH
5092: LD_INT 5
5094: PUSH
5095: LD_INT 6
5097: PUSH
5098: LD_INT 8
5100: PUSH
5101: LD_INT 11
5103: PUSH
5104: LD_INT 12
5106: PUSH
5107: LD_INT 15
5109: PUSH
5110: LD_INT 16
5112: PUSH
5113: LD_INT 22
5115: PUSH
5116: LD_INT 23
5118: PUSH
5119: LD_INT 25
5121: PUSH
5122: LD_INT 26
5124: PUSH
5125: LD_INT 36
5127: PUSH
5128: EMPTY
5129: LIST
5130: LIST
5131: LIST
5132: LIST
5133: LIST
5134: LIST
5135: LIST
5136: LIST
5137: LIST
5138: LIST
5139: LIST
5140: LIST
5141: LIST
5142: LIST
5143: PUSH
5144: LD_INT 101
5146: PUSH
5147: LD_INT 102
5149: PUSH
5150: LD_INT 105
5152: PUSH
5153: LD_INT 106
5155: PUSH
5156: LD_INT 108
5158: PUSH
5159: LD_INT 109
5161: PUSH
5162: LD_INT 112
5164: PUSH
5165: EMPTY
5166: LIST
5167: LIST
5168: LIST
5169: LIST
5170: LIST
5171: LIST
5172: LIST
5173: PUSH
5174: EMPTY
5175: LIST
5176: LIST
5177: ST_TO_ADDR
5178: GO 7673
5180: LD_INT 6
5182: DOUBLE
5183: EQUAL
5184: IFTRUE 5188
5186: GO 5308
5188: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
5189: LD_ADDR_VAR 0 1
5193: PUSH
5194: LD_INT 2
5196: PUSH
5197: LD_INT 4
5199: PUSH
5200: LD_INT 5
5202: PUSH
5203: LD_INT 6
5205: PUSH
5206: LD_INT 8
5208: PUSH
5209: LD_INT 11
5211: PUSH
5212: LD_INT 12
5214: PUSH
5215: LD_INT 15
5217: PUSH
5218: LD_INT 16
5220: PUSH
5221: LD_INT 20
5223: PUSH
5224: LD_INT 21
5226: PUSH
5227: LD_INT 22
5229: PUSH
5230: LD_INT 23
5232: PUSH
5233: LD_INT 25
5235: PUSH
5236: LD_INT 26
5238: PUSH
5239: LD_INT 30
5241: PUSH
5242: LD_INT 31
5244: PUSH
5245: LD_INT 32
5247: PUSH
5248: LD_INT 36
5250: PUSH
5251: EMPTY
5252: LIST
5253: LIST
5254: LIST
5255: LIST
5256: LIST
5257: LIST
5258: LIST
5259: LIST
5260: LIST
5261: LIST
5262: LIST
5263: LIST
5264: LIST
5265: LIST
5266: LIST
5267: LIST
5268: LIST
5269: LIST
5270: LIST
5271: PUSH
5272: LD_INT 101
5274: PUSH
5275: LD_INT 102
5277: PUSH
5278: LD_INT 105
5280: PUSH
5281: LD_INT 106
5283: PUSH
5284: LD_INT 108
5286: PUSH
5287: LD_INT 109
5289: PUSH
5290: LD_INT 112
5292: PUSH
5293: EMPTY
5294: LIST
5295: LIST
5296: LIST
5297: LIST
5298: LIST
5299: LIST
5300: LIST
5301: PUSH
5302: EMPTY
5303: LIST
5304: LIST
5305: ST_TO_ADDR
5306: GO 7673
5308: LD_INT 7
5310: DOUBLE
5311: EQUAL
5312: IFTRUE 5316
5314: GO 5416
5316: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
5317: LD_ADDR_VAR 0 1
5321: PUSH
5322: LD_INT 2
5324: PUSH
5325: LD_INT 4
5327: PUSH
5328: LD_INT 5
5330: PUSH
5331: LD_INT 7
5333: PUSH
5334: LD_INT 11
5336: PUSH
5337: LD_INT 12
5339: PUSH
5340: LD_INT 15
5342: PUSH
5343: LD_INT 16
5345: PUSH
5346: LD_INT 20
5348: PUSH
5349: LD_INT 21
5351: PUSH
5352: LD_INT 22
5354: PUSH
5355: LD_INT 23
5357: PUSH
5358: LD_INT 25
5360: PUSH
5361: LD_INT 26
5363: PUSH
5364: EMPTY
5365: LIST
5366: LIST
5367: LIST
5368: LIST
5369: LIST
5370: LIST
5371: LIST
5372: LIST
5373: LIST
5374: LIST
5375: LIST
5376: LIST
5377: LIST
5378: LIST
5379: PUSH
5380: LD_INT 101
5382: PUSH
5383: LD_INT 102
5385: PUSH
5386: LD_INT 103
5388: PUSH
5389: LD_INT 105
5391: PUSH
5392: LD_INT 106
5394: PUSH
5395: LD_INT 108
5397: PUSH
5398: LD_INT 112
5400: PUSH
5401: EMPTY
5402: LIST
5403: LIST
5404: LIST
5405: LIST
5406: LIST
5407: LIST
5408: LIST
5409: PUSH
5410: EMPTY
5411: LIST
5412: LIST
5413: ST_TO_ADDR
5414: GO 7673
5416: LD_INT 8
5418: DOUBLE
5419: EQUAL
5420: IFTRUE 5424
5422: GO 5552
5424: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
5425: LD_ADDR_VAR 0 1
5429: PUSH
5430: LD_INT 2
5432: PUSH
5433: LD_INT 4
5435: PUSH
5436: LD_INT 5
5438: PUSH
5439: LD_INT 6
5441: PUSH
5442: LD_INT 7
5444: PUSH
5445: LD_INT 8
5447: PUSH
5448: LD_INT 11
5450: PUSH
5451: LD_INT 12
5453: PUSH
5454: LD_INT 15
5456: PUSH
5457: LD_INT 16
5459: PUSH
5460: LD_INT 20
5462: PUSH
5463: LD_INT 21
5465: PUSH
5466: LD_INT 22
5468: PUSH
5469: LD_INT 23
5471: PUSH
5472: LD_INT 25
5474: PUSH
5475: LD_INT 26
5477: PUSH
5478: LD_INT 30
5480: PUSH
5481: LD_INT 31
5483: PUSH
5484: LD_INT 32
5486: PUSH
5487: LD_INT 36
5489: PUSH
5490: EMPTY
5491: LIST
5492: LIST
5493: LIST
5494: LIST
5495: LIST
5496: LIST
5497: LIST
5498: LIST
5499: LIST
5500: LIST
5501: LIST
5502: LIST
5503: LIST
5504: LIST
5505: LIST
5506: LIST
5507: LIST
5508: LIST
5509: LIST
5510: LIST
5511: PUSH
5512: LD_INT 101
5514: PUSH
5515: LD_INT 102
5517: PUSH
5518: LD_INT 103
5520: PUSH
5521: LD_INT 105
5523: PUSH
5524: LD_INT 106
5526: PUSH
5527: LD_INT 108
5529: PUSH
5530: LD_INT 109
5532: PUSH
5533: LD_INT 112
5535: PUSH
5536: EMPTY
5537: LIST
5538: LIST
5539: LIST
5540: LIST
5541: LIST
5542: LIST
5543: LIST
5544: LIST
5545: PUSH
5546: EMPTY
5547: LIST
5548: LIST
5549: ST_TO_ADDR
5550: GO 7673
5552: LD_INT 9
5554: DOUBLE
5555: EQUAL
5556: IFTRUE 5560
5558: GO 5696
5560: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
5561: LD_ADDR_VAR 0 1
5565: PUSH
5566: LD_INT 2
5568: PUSH
5569: LD_INT 4
5571: PUSH
5572: LD_INT 5
5574: PUSH
5575: LD_INT 6
5577: PUSH
5578: LD_INT 7
5580: PUSH
5581: LD_INT 8
5583: PUSH
5584: LD_INT 11
5586: PUSH
5587: LD_INT 12
5589: PUSH
5590: LD_INT 15
5592: PUSH
5593: LD_INT 16
5595: PUSH
5596: LD_INT 20
5598: PUSH
5599: LD_INT 21
5601: PUSH
5602: LD_INT 22
5604: PUSH
5605: LD_INT 23
5607: PUSH
5608: LD_INT 25
5610: PUSH
5611: LD_INT 26
5613: PUSH
5614: LD_INT 28
5616: PUSH
5617: LD_INT 30
5619: PUSH
5620: LD_INT 31
5622: PUSH
5623: LD_INT 32
5625: PUSH
5626: LD_INT 36
5628: PUSH
5629: EMPTY
5630: LIST
5631: LIST
5632: LIST
5633: LIST
5634: LIST
5635: LIST
5636: LIST
5637: LIST
5638: LIST
5639: LIST
5640: LIST
5641: LIST
5642: LIST
5643: LIST
5644: LIST
5645: LIST
5646: LIST
5647: LIST
5648: LIST
5649: LIST
5650: LIST
5651: PUSH
5652: LD_INT 101
5654: PUSH
5655: LD_INT 102
5657: PUSH
5658: LD_INT 103
5660: PUSH
5661: LD_INT 105
5663: PUSH
5664: LD_INT 106
5666: PUSH
5667: LD_INT 108
5669: PUSH
5670: LD_INT 109
5672: PUSH
5673: LD_INT 112
5675: PUSH
5676: LD_INT 114
5678: PUSH
5679: EMPTY
5680: LIST
5681: LIST
5682: LIST
5683: LIST
5684: LIST
5685: LIST
5686: LIST
5687: LIST
5688: LIST
5689: PUSH
5690: EMPTY
5691: LIST
5692: LIST
5693: ST_TO_ADDR
5694: GO 7673
5696: LD_INT 10
5698: DOUBLE
5699: EQUAL
5700: IFTRUE 5704
5702: GO 5888
5704: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
5705: LD_ADDR_VAR 0 1
5709: PUSH
5710: LD_INT 2
5712: PUSH
5713: LD_INT 4
5715: PUSH
5716: LD_INT 5
5718: PUSH
5719: LD_INT 6
5721: PUSH
5722: LD_INT 7
5724: PUSH
5725: LD_INT 8
5727: PUSH
5728: LD_INT 9
5730: PUSH
5731: LD_INT 10
5733: PUSH
5734: LD_INT 11
5736: PUSH
5737: LD_INT 12
5739: PUSH
5740: LD_INT 13
5742: PUSH
5743: LD_INT 14
5745: PUSH
5746: LD_INT 15
5748: PUSH
5749: LD_INT 16
5751: PUSH
5752: LD_INT 17
5754: PUSH
5755: LD_INT 18
5757: PUSH
5758: LD_INT 19
5760: PUSH
5761: LD_INT 20
5763: PUSH
5764: LD_INT 21
5766: PUSH
5767: LD_INT 22
5769: PUSH
5770: LD_INT 23
5772: PUSH
5773: LD_INT 24
5775: PUSH
5776: LD_INT 25
5778: PUSH
5779: LD_INT 26
5781: PUSH
5782: LD_INT 28
5784: PUSH
5785: LD_INT 30
5787: PUSH
5788: LD_INT 31
5790: PUSH
5791: LD_INT 32
5793: PUSH
5794: LD_INT 36
5796: PUSH
5797: EMPTY
5798: LIST
5799: LIST
5800: LIST
5801: LIST
5802: LIST
5803: LIST
5804: LIST
5805: LIST
5806: LIST
5807: LIST
5808: LIST
5809: LIST
5810: LIST
5811: LIST
5812: LIST
5813: LIST
5814: LIST
5815: LIST
5816: LIST
5817: LIST
5818: LIST
5819: LIST
5820: LIST
5821: LIST
5822: LIST
5823: LIST
5824: LIST
5825: LIST
5826: LIST
5827: PUSH
5828: LD_INT 101
5830: PUSH
5831: LD_INT 102
5833: PUSH
5834: LD_INT 103
5836: PUSH
5837: LD_INT 104
5839: PUSH
5840: LD_INT 105
5842: PUSH
5843: LD_INT 106
5845: PUSH
5846: LD_INT 107
5848: PUSH
5849: LD_INT 108
5851: PUSH
5852: LD_INT 109
5854: PUSH
5855: LD_INT 110
5857: PUSH
5858: LD_INT 111
5860: PUSH
5861: LD_INT 112
5863: PUSH
5864: LD_INT 114
5866: PUSH
5867: EMPTY
5868: LIST
5869: LIST
5870: LIST
5871: LIST
5872: LIST
5873: LIST
5874: LIST
5875: LIST
5876: LIST
5877: LIST
5878: LIST
5879: LIST
5880: LIST
5881: PUSH
5882: EMPTY
5883: LIST
5884: LIST
5885: ST_TO_ADDR
5886: GO 7673
5888: LD_INT 11
5890: DOUBLE
5891: EQUAL
5892: IFTRUE 5896
5894: GO 6088
5896: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
5897: LD_ADDR_VAR 0 1
5901: PUSH
5902: LD_INT 2
5904: PUSH
5905: LD_INT 3
5907: PUSH
5908: LD_INT 4
5910: PUSH
5911: LD_INT 5
5913: PUSH
5914: LD_INT 6
5916: PUSH
5917: LD_INT 7
5919: PUSH
5920: LD_INT 8
5922: PUSH
5923: LD_INT 9
5925: PUSH
5926: LD_INT 10
5928: PUSH
5929: LD_INT 11
5931: PUSH
5932: LD_INT 12
5934: PUSH
5935: LD_INT 13
5937: PUSH
5938: LD_INT 14
5940: PUSH
5941: LD_INT 15
5943: PUSH
5944: LD_INT 16
5946: PUSH
5947: LD_INT 17
5949: PUSH
5950: LD_INT 18
5952: PUSH
5953: LD_INT 19
5955: PUSH
5956: LD_INT 20
5958: PUSH
5959: LD_INT 21
5961: PUSH
5962: LD_INT 22
5964: PUSH
5965: LD_INT 23
5967: PUSH
5968: LD_INT 24
5970: PUSH
5971: LD_INT 25
5973: PUSH
5974: LD_INT 26
5976: PUSH
5977: LD_INT 28
5979: PUSH
5980: LD_INT 30
5982: PUSH
5983: LD_INT 31
5985: PUSH
5986: LD_INT 32
5988: PUSH
5989: LD_INT 34
5991: PUSH
5992: LD_INT 36
5994: PUSH
5995: EMPTY
5996: LIST
5997: LIST
5998: LIST
5999: LIST
6000: LIST
6001: LIST
6002: LIST
6003: LIST
6004: LIST
6005: LIST
6006: LIST
6007: LIST
6008: LIST
6009: LIST
6010: LIST
6011: LIST
6012: LIST
6013: LIST
6014: LIST
6015: LIST
6016: LIST
6017: LIST
6018: LIST
6019: LIST
6020: LIST
6021: LIST
6022: LIST
6023: LIST
6024: LIST
6025: LIST
6026: LIST
6027: PUSH
6028: LD_INT 101
6030: PUSH
6031: LD_INT 102
6033: PUSH
6034: LD_INT 103
6036: PUSH
6037: LD_INT 104
6039: PUSH
6040: LD_INT 105
6042: PUSH
6043: LD_INT 106
6045: PUSH
6046: LD_INT 107
6048: PUSH
6049: LD_INT 108
6051: PUSH
6052: LD_INT 109
6054: PUSH
6055: LD_INT 110
6057: PUSH
6058: LD_INT 111
6060: PUSH
6061: LD_INT 112
6063: PUSH
6064: LD_INT 114
6066: PUSH
6067: EMPTY
6068: LIST
6069: LIST
6070: LIST
6071: LIST
6072: LIST
6073: LIST
6074: LIST
6075: LIST
6076: LIST
6077: LIST
6078: LIST
6079: LIST
6080: LIST
6081: PUSH
6082: EMPTY
6083: LIST
6084: LIST
6085: ST_TO_ADDR
6086: GO 7673
6088: LD_INT 12
6090: DOUBLE
6091: EQUAL
6092: IFTRUE 6096
6094: GO 6304
6096: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
6097: LD_ADDR_VAR 0 1
6101: PUSH
6102: LD_INT 1
6104: PUSH
6105: LD_INT 2
6107: PUSH
6108: LD_INT 3
6110: PUSH
6111: LD_INT 4
6113: PUSH
6114: LD_INT 5
6116: PUSH
6117: LD_INT 6
6119: PUSH
6120: LD_INT 7
6122: PUSH
6123: LD_INT 8
6125: PUSH
6126: LD_INT 9
6128: PUSH
6129: LD_INT 10
6131: PUSH
6132: LD_INT 11
6134: PUSH
6135: LD_INT 12
6137: PUSH
6138: LD_INT 13
6140: PUSH
6141: LD_INT 14
6143: PUSH
6144: LD_INT 15
6146: PUSH
6147: LD_INT 16
6149: PUSH
6150: LD_INT 17
6152: PUSH
6153: LD_INT 18
6155: PUSH
6156: LD_INT 19
6158: PUSH
6159: LD_INT 20
6161: PUSH
6162: LD_INT 21
6164: PUSH
6165: LD_INT 22
6167: PUSH
6168: LD_INT 23
6170: PUSH
6171: LD_INT 24
6173: PUSH
6174: LD_INT 25
6176: PUSH
6177: LD_INT 26
6179: PUSH
6180: LD_INT 27
6182: PUSH
6183: LD_INT 28
6185: PUSH
6186: LD_INT 30
6188: PUSH
6189: LD_INT 31
6191: PUSH
6192: LD_INT 32
6194: PUSH
6195: LD_INT 33
6197: PUSH
6198: LD_INT 34
6200: PUSH
6201: LD_INT 36
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: LIST
6208: LIST
6209: LIST
6210: LIST
6211: LIST
6212: LIST
6213: LIST
6214: LIST
6215: LIST
6216: LIST
6217: LIST
6218: LIST
6219: LIST
6220: LIST
6221: LIST
6222: LIST
6223: LIST
6224: LIST
6225: LIST
6226: LIST
6227: LIST
6228: LIST
6229: LIST
6230: LIST
6231: LIST
6232: LIST
6233: LIST
6234: LIST
6235: LIST
6236: LIST
6237: LIST
6238: LIST
6239: PUSH
6240: LD_INT 101
6242: PUSH
6243: LD_INT 102
6245: PUSH
6246: LD_INT 103
6248: PUSH
6249: LD_INT 104
6251: PUSH
6252: LD_INT 105
6254: PUSH
6255: LD_INT 106
6257: PUSH
6258: LD_INT 107
6260: PUSH
6261: LD_INT 108
6263: PUSH
6264: LD_INT 109
6266: PUSH
6267: LD_INT 110
6269: PUSH
6270: LD_INT 111
6272: PUSH
6273: LD_INT 112
6275: PUSH
6276: LD_INT 113
6278: PUSH
6279: LD_INT 114
6281: PUSH
6282: EMPTY
6283: LIST
6284: LIST
6285: LIST
6286: LIST
6287: LIST
6288: LIST
6289: LIST
6290: LIST
6291: LIST
6292: LIST
6293: LIST
6294: LIST
6295: LIST
6296: LIST
6297: PUSH
6298: EMPTY
6299: LIST
6300: LIST
6301: ST_TO_ADDR
6302: GO 7673
6304: LD_INT 13
6306: DOUBLE
6307: EQUAL
6308: IFTRUE 6312
6310: GO 6508
6312: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
6313: LD_ADDR_VAR 0 1
6317: PUSH
6318: LD_INT 1
6320: PUSH
6321: LD_INT 2
6323: PUSH
6324: LD_INT 3
6326: PUSH
6327: LD_INT 4
6329: PUSH
6330: LD_INT 5
6332: PUSH
6333: LD_INT 8
6335: PUSH
6336: LD_INT 9
6338: PUSH
6339: LD_INT 10
6341: PUSH
6342: LD_INT 11
6344: PUSH
6345: LD_INT 12
6347: PUSH
6348: LD_INT 14
6350: PUSH
6351: LD_INT 15
6353: PUSH
6354: LD_INT 16
6356: PUSH
6357: LD_INT 17
6359: PUSH
6360: LD_INT 18
6362: PUSH
6363: LD_INT 19
6365: PUSH
6366: LD_INT 20
6368: PUSH
6369: LD_INT 21
6371: PUSH
6372: LD_INT 22
6374: PUSH
6375: LD_INT 23
6377: PUSH
6378: LD_INT 24
6380: PUSH
6381: LD_INT 25
6383: PUSH
6384: LD_INT 26
6386: PUSH
6387: LD_INT 27
6389: PUSH
6390: LD_INT 28
6392: PUSH
6393: LD_INT 30
6395: PUSH
6396: LD_INT 31
6398: PUSH
6399: LD_INT 32
6401: PUSH
6402: LD_INT 33
6404: PUSH
6405: LD_INT 34
6407: PUSH
6408: LD_INT 36
6410: PUSH
6411: EMPTY
6412: LIST
6413: LIST
6414: LIST
6415: LIST
6416: LIST
6417: LIST
6418: LIST
6419: LIST
6420: LIST
6421: LIST
6422: LIST
6423: LIST
6424: LIST
6425: LIST
6426: LIST
6427: LIST
6428: LIST
6429: LIST
6430: LIST
6431: LIST
6432: LIST
6433: LIST
6434: LIST
6435: LIST
6436: LIST
6437: LIST
6438: LIST
6439: LIST
6440: LIST
6441: LIST
6442: LIST
6443: PUSH
6444: LD_INT 101
6446: PUSH
6447: LD_INT 102
6449: PUSH
6450: LD_INT 103
6452: PUSH
6453: LD_INT 104
6455: PUSH
6456: LD_INT 105
6458: PUSH
6459: LD_INT 106
6461: PUSH
6462: LD_INT 107
6464: PUSH
6465: LD_INT 108
6467: PUSH
6468: LD_INT 109
6470: PUSH
6471: LD_INT 110
6473: PUSH
6474: LD_INT 111
6476: PUSH
6477: LD_INT 112
6479: PUSH
6480: LD_INT 113
6482: PUSH
6483: LD_INT 114
6485: PUSH
6486: EMPTY
6487: LIST
6488: LIST
6489: LIST
6490: LIST
6491: LIST
6492: LIST
6493: LIST
6494: LIST
6495: LIST
6496: LIST
6497: LIST
6498: LIST
6499: LIST
6500: LIST
6501: PUSH
6502: EMPTY
6503: LIST
6504: LIST
6505: ST_TO_ADDR
6506: GO 7673
6508: LD_INT 14
6510: DOUBLE
6511: EQUAL
6512: IFTRUE 6516
6514: GO 6728
6516: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
6517: LD_ADDR_VAR 0 1
6521: PUSH
6522: LD_INT 1
6524: PUSH
6525: LD_INT 2
6527: PUSH
6528: LD_INT 3
6530: PUSH
6531: LD_INT 4
6533: PUSH
6534: LD_INT 5
6536: PUSH
6537: LD_INT 6
6539: PUSH
6540: LD_INT 7
6542: PUSH
6543: LD_INT 8
6545: PUSH
6546: LD_INT 9
6548: PUSH
6549: LD_INT 10
6551: PUSH
6552: LD_INT 11
6554: PUSH
6555: LD_INT 12
6557: PUSH
6558: LD_INT 13
6560: PUSH
6561: LD_INT 14
6563: PUSH
6564: LD_INT 15
6566: PUSH
6567: LD_INT 16
6569: PUSH
6570: LD_INT 17
6572: PUSH
6573: LD_INT 18
6575: PUSH
6576: LD_INT 19
6578: PUSH
6579: LD_INT 20
6581: PUSH
6582: LD_INT 21
6584: PUSH
6585: LD_INT 22
6587: PUSH
6588: LD_INT 23
6590: PUSH
6591: LD_INT 24
6593: PUSH
6594: LD_INT 25
6596: PUSH
6597: LD_INT 26
6599: PUSH
6600: LD_INT 27
6602: PUSH
6603: LD_INT 28
6605: PUSH
6606: LD_INT 29
6608: PUSH
6609: LD_INT 30
6611: PUSH
6612: LD_INT 31
6614: PUSH
6615: LD_INT 32
6617: PUSH
6618: LD_INT 33
6620: PUSH
6621: LD_INT 34
6623: PUSH
6624: LD_INT 36
6626: PUSH
6627: EMPTY
6628: LIST
6629: LIST
6630: LIST
6631: LIST
6632: LIST
6633: LIST
6634: LIST
6635: LIST
6636: LIST
6637: LIST
6638: LIST
6639: LIST
6640: LIST
6641: LIST
6642: LIST
6643: LIST
6644: LIST
6645: LIST
6646: LIST
6647: LIST
6648: LIST
6649: LIST
6650: LIST
6651: LIST
6652: LIST
6653: LIST
6654: LIST
6655: LIST
6656: LIST
6657: LIST
6658: LIST
6659: LIST
6660: LIST
6661: LIST
6662: LIST
6663: PUSH
6664: LD_INT 101
6666: PUSH
6667: LD_INT 102
6669: PUSH
6670: LD_INT 103
6672: PUSH
6673: LD_INT 104
6675: PUSH
6676: LD_INT 105
6678: PUSH
6679: LD_INT 106
6681: PUSH
6682: LD_INT 107
6684: PUSH
6685: LD_INT 108
6687: PUSH
6688: LD_INT 109
6690: PUSH
6691: LD_INT 110
6693: PUSH
6694: LD_INT 111
6696: PUSH
6697: LD_INT 112
6699: PUSH
6700: LD_INT 113
6702: PUSH
6703: LD_INT 114
6705: PUSH
6706: EMPTY
6707: LIST
6708: LIST
6709: LIST
6710: LIST
6711: LIST
6712: LIST
6713: LIST
6714: LIST
6715: LIST
6716: LIST
6717: LIST
6718: LIST
6719: LIST
6720: LIST
6721: PUSH
6722: EMPTY
6723: LIST
6724: LIST
6725: ST_TO_ADDR
6726: GO 7673
6728: LD_INT 15
6730: DOUBLE
6731: EQUAL
6732: IFTRUE 6736
6734: GO 6948
6736: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
6737: LD_ADDR_VAR 0 1
6741: PUSH
6742: LD_INT 1
6744: PUSH
6745: LD_INT 2
6747: PUSH
6748: LD_INT 3
6750: PUSH
6751: LD_INT 4
6753: PUSH
6754: LD_INT 5
6756: PUSH
6757: LD_INT 6
6759: PUSH
6760: LD_INT 7
6762: PUSH
6763: LD_INT 8
6765: PUSH
6766: LD_INT 9
6768: PUSH
6769: LD_INT 10
6771: PUSH
6772: LD_INT 11
6774: PUSH
6775: LD_INT 12
6777: PUSH
6778: LD_INT 13
6780: PUSH
6781: LD_INT 14
6783: PUSH
6784: LD_INT 15
6786: PUSH
6787: LD_INT 16
6789: PUSH
6790: LD_INT 17
6792: PUSH
6793: LD_INT 18
6795: PUSH
6796: LD_INT 19
6798: PUSH
6799: LD_INT 20
6801: PUSH
6802: LD_INT 21
6804: PUSH
6805: LD_INT 22
6807: PUSH
6808: LD_INT 23
6810: PUSH
6811: LD_INT 24
6813: PUSH
6814: LD_INT 25
6816: PUSH
6817: LD_INT 26
6819: PUSH
6820: LD_INT 27
6822: PUSH
6823: LD_INT 28
6825: PUSH
6826: LD_INT 29
6828: PUSH
6829: LD_INT 30
6831: PUSH
6832: LD_INT 31
6834: PUSH
6835: LD_INT 32
6837: PUSH
6838: LD_INT 33
6840: PUSH
6841: LD_INT 34
6843: PUSH
6844: LD_INT 36
6846: PUSH
6847: EMPTY
6848: LIST
6849: LIST
6850: LIST
6851: LIST
6852: LIST
6853: LIST
6854: LIST
6855: LIST
6856: LIST
6857: LIST
6858: LIST
6859: LIST
6860: LIST
6861: LIST
6862: LIST
6863: LIST
6864: LIST
6865: LIST
6866: LIST
6867: LIST
6868: LIST
6869: LIST
6870: LIST
6871: LIST
6872: LIST
6873: LIST
6874: LIST
6875: LIST
6876: LIST
6877: LIST
6878: LIST
6879: LIST
6880: LIST
6881: LIST
6882: LIST
6883: PUSH
6884: LD_INT 101
6886: PUSH
6887: LD_INT 102
6889: PUSH
6890: LD_INT 103
6892: PUSH
6893: LD_INT 104
6895: PUSH
6896: LD_INT 105
6898: PUSH
6899: LD_INT 106
6901: PUSH
6902: LD_INT 107
6904: PUSH
6905: LD_INT 108
6907: PUSH
6908: LD_INT 109
6910: PUSH
6911: LD_INT 110
6913: PUSH
6914: LD_INT 111
6916: PUSH
6917: LD_INT 112
6919: PUSH
6920: LD_INT 113
6922: PUSH
6923: LD_INT 114
6925: PUSH
6926: EMPTY
6927: LIST
6928: LIST
6929: LIST
6930: LIST
6931: LIST
6932: LIST
6933: LIST
6934: LIST
6935: LIST
6936: LIST
6937: LIST
6938: LIST
6939: LIST
6940: LIST
6941: PUSH
6942: EMPTY
6943: LIST
6944: LIST
6945: ST_TO_ADDR
6946: GO 7673
6948: LD_INT 16
6950: DOUBLE
6951: EQUAL
6952: IFTRUE 6956
6954: GO 7080
6956: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
6957: LD_ADDR_VAR 0 1
6961: PUSH
6962: LD_INT 2
6964: PUSH
6965: LD_INT 4
6967: PUSH
6968: LD_INT 5
6970: PUSH
6971: LD_INT 7
6973: PUSH
6974: LD_INT 11
6976: PUSH
6977: LD_INT 12
6979: PUSH
6980: LD_INT 15
6982: PUSH
6983: LD_INT 16
6985: PUSH
6986: LD_INT 20
6988: PUSH
6989: LD_INT 21
6991: PUSH
6992: LD_INT 22
6994: PUSH
6995: LD_INT 23
6997: PUSH
6998: LD_INT 25
7000: PUSH
7001: LD_INT 26
7003: PUSH
7004: LD_INT 30
7006: PUSH
7007: LD_INT 31
7009: PUSH
7010: LD_INT 32
7012: PUSH
7013: LD_INT 33
7015: PUSH
7016: LD_INT 34
7018: PUSH
7019: EMPTY
7020: LIST
7021: LIST
7022: LIST
7023: LIST
7024: LIST
7025: LIST
7026: LIST
7027: LIST
7028: LIST
7029: LIST
7030: LIST
7031: LIST
7032: LIST
7033: LIST
7034: LIST
7035: LIST
7036: LIST
7037: LIST
7038: LIST
7039: PUSH
7040: LD_INT 101
7042: PUSH
7043: LD_INT 102
7045: PUSH
7046: LD_INT 103
7048: PUSH
7049: LD_INT 106
7051: PUSH
7052: LD_INT 108
7054: PUSH
7055: LD_INT 112
7057: PUSH
7058: LD_INT 113
7060: PUSH
7061: LD_INT 114
7063: PUSH
7064: EMPTY
7065: LIST
7066: LIST
7067: LIST
7068: LIST
7069: LIST
7070: LIST
7071: LIST
7072: LIST
7073: PUSH
7074: EMPTY
7075: LIST
7076: LIST
7077: ST_TO_ADDR
7078: GO 7673
7080: LD_INT 17
7082: DOUBLE
7083: EQUAL
7084: IFTRUE 7088
7086: GO 7300
7088: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
7089: LD_ADDR_VAR 0 1
7093: PUSH
7094: LD_INT 1
7096: PUSH
7097: LD_INT 2
7099: PUSH
7100: LD_INT 3
7102: PUSH
7103: LD_INT 4
7105: PUSH
7106: LD_INT 5
7108: PUSH
7109: LD_INT 6
7111: PUSH
7112: LD_INT 7
7114: PUSH
7115: LD_INT 8
7117: PUSH
7118: LD_INT 9
7120: PUSH
7121: LD_INT 10
7123: PUSH
7124: LD_INT 11
7126: PUSH
7127: LD_INT 12
7129: PUSH
7130: LD_INT 13
7132: PUSH
7133: LD_INT 14
7135: PUSH
7136: LD_INT 15
7138: PUSH
7139: LD_INT 16
7141: PUSH
7142: LD_INT 17
7144: PUSH
7145: LD_INT 18
7147: PUSH
7148: LD_INT 19
7150: PUSH
7151: LD_INT 20
7153: PUSH
7154: LD_INT 21
7156: PUSH
7157: LD_INT 22
7159: PUSH
7160: LD_INT 23
7162: PUSH
7163: LD_INT 24
7165: PUSH
7166: LD_INT 25
7168: PUSH
7169: LD_INT 26
7171: PUSH
7172: LD_INT 27
7174: PUSH
7175: LD_INT 28
7177: PUSH
7178: LD_INT 29
7180: PUSH
7181: LD_INT 30
7183: PUSH
7184: LD_INT 31
7186: PUSH
7187: LD_INT 32
7189: PUSH
7190: LD_INT 33
7192: PUSH
7193: LD_INT 34
7195: PUSH
7196: LD_INT 36
7198: PUSH
7199: EMPTY
7200: LIST
7201: LIST
7202: LIST
7203: LIST
7204: LIST
7205: LIST
7206: LIST
7207: LIST
7208: LIST
7209: LIST
7210: LIST
7211: LIST
7212: LIST
7213: LIST
7214: LIST
7215: LIST
7216: LIST
7217: LIST
7218: LIST
7219: LIST
7220: LIST
7221: LIST
7222: LIST
7223: LIST
7224: LIST
7225: LIST
7226: LIST
7227: LIST
7228: LIST
7229: LIST
7230: LIST
7231: LIST
7232: LIST
7233: LIST
7234: LIST
7235: PUSH
7236: LD_INT 101
7238: PUSH
7239: LD_INT 102
7241: PUSH
7242: LD_INT 103
7244: PUSH
7245: LD_INT 104
7247: PUSH
7248: LD_INT 105
7250: PUSH
7251: LD_INT 106
7253: PUSH
7254: LD_INT 107
7256: PUSH
7257: LD_INT 108
7259: PUSH
7260: LD_INT 109
7262: PUSH
7263: LD_INT 110
7265: PUSH
7266: LD_INT 111
7268: PUSH
7269: LD_INT 112
7271: PUSH
7272: LD_INT 113
7274: PUSH
7275: LD_INT 114
7277: PUSH
7278: EMPTY
7279: LIST
7280: LIST
7281: LIST
7282: LIST
7283: LIST
7284: LIST
7285: LIST
7286: LIST
7287: LIST
7288: LIST
7289: LIST
7290: LIST
7291: LIST
7292: LIST
7293: PUSH
7294: EMPTY
7295: LIST
7296: LIST
7297: ST_TO_ADDR
7298: GO 7673
7300: LD_INT 18
7302: DOUBLE
7303: EQUAL
7304: IFTRUE 7308
7306: GO 7444
7308: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
7309: LD_ADDR_VAR 0 1
7313: PUSH
7314: LD_INT 2
7316: PUSH
7317: LD_INT 4
7319: PUSH
7320: LD_INT 5
7322: PUSH
7323: LD_INT 7
7325: PUSH
7326: LD_INT 11
7328: PUSH
7329: LD_INT 12
7331: PUSH
7332: LD_INT 15
7334: PUSH
7335: LD_INT 16
7337: PUSH
7338: LD_INT 20
7340: PUSH
7341: LD_INT 21
7343: PUSH
7344: LD_INT 22
7346: PUSH
7347: LD_INT 23
7349: PUSH
7350: LD_INT 25
7352: PUSH
7353: LD_INT 26
7355: PUSH
7356: LD_INT 30
7358: PUSH
7359: LD_INT 31
7361: PUSH
7362: LD_INT 32
7364: PUSH
7365: LD_INT 33
7367: PUSH
7368: LD_INT 34
7370: PUSH
7371: LD_INT 35
7373: PUSH
7374: LD_INT 36
7376: PUSH
7377: EMPTY
7378: LIST
7379: LIST
7380: LIST
7381: LIST
7382: LIST
7383: LIST
7384: LIST
7385: LIST
7386: LIST
7387: LIST
7388: LIST
7389: LIST
7390: LIST
7391: LIST
7392: LIST
7393: LIST
7394: LIST
7395: LIST
7396: LIST
7397: LIST
7398: LIST
7399: PUSH
7400: LD_INT 101
7402: PUSH
7403: LD_INT 102
7405: PUSH
7406: LD_INT 103
7408: PUSH
7409: LD_INT 106
7411: PUSH
7412: LD_INT 108
7414: PUSH
7415: LD_INT 112
7417: PUSH
7418: LD_INT 113
7420: PUSH
7421: LD_INT 114
7423: PUSH
7424: LD_INT 115
7426: PUSH
7427: EMPTY
7428: LIST
7429: LIST
7430: LIST
7431: LIST
7432: LIST
7433: LIST
7434: LIST
7435: LIST
7436: LIST
7437: PUSH
7438: EMPTY
7439: LIST
7440: LIST
7441: ST_TO_ADDR
7442: GO 7673
7444: LD_INT 19
7446: DOUBLE
7447: EQUAL
7448: IFTRUE 7452
7450: GO 7672
7452: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
7453: LD_ADDR_VAR 0 1
7457: PUSH
7458: LD_INT 1
7460: PUSH
7461: LD_INT 2
7463: PUSH
7464: LD_INT 3
7466: PUSH
7467: LD_INT 4
7469: PUSH
7470: LD_INT 5
7472: PUSH
7473: LD_INT 6
7475: PUSH
7476: LD_INT 7
7478: PUSH
7479: LD_INT 8
7481: PUSH
7482: LD_INT 9
7484: PUSH
7485: LD_INT 10
7487: PUSH
7488: LD_INT 11
7490: PUSH
7491: LD_INT 12
7493: PUSH
7494: LD_INT 13
7496: PUSH
7497: LD_INT 14
7499: PUSH
7500: LD_INT 15
7502: PUSH
7503: LD_INT 16
7505: PUSH
7506: LD_INT 17
7508: PUSH
7509: LD_INT 18
7511: PUSH
7512: LD_INT 19
7514: PUSH
7515: LD_INT 20
7517: PUSH
7518: LD_INT 21
7520: PUSH
7521: LD_INT 22
7523: PUSH
7524: LD_INT 23
7526: PUSH
7527: LD_INT 24
7529: PUSH
7530: LD_INT 25
7532: PUSH
7533: LD_INT 26
7535: PUSH
7536: LD_INT 27
7538: PUSH
7539: LD_INT 28
7541: PUSH
7542: LD_INT 29
7544: PUSH
7545: LD_INT 30
7547: PUSH
7548: LD_INT 31
7550: PUSH
7551: LD_INT 32
7553: PUSH
7554: LD_INT 33
7556: PUSH
7557: LD_INT 34
7559: PUSH
7560: LD_INT 35
7562: PUSH
7563: LD_INT 36
7565: PUSH
7566: EMPTY
7567: LIST
7568: LIST
7569: LIST
7570: LIST
7571: LIST
7572: LIST
7573: LIST
7574: LIST
7575: LIST
7576: LIST
7577: LIST
7578: LIST
7579: LIST
7580: LIST
7581: LIST
7582: LIST
7583: LIST
7584: LIST
7585: LIST
7586: LIST
7587: LIST
7588: LIST
7589: LIST
7590: LIST
7591: LIST
7592: LIST
7593: LIST
7594: LIST
7595: LIST
7596: LIST
7597: LIST
7598: LIST
7599: LIST
7600: LIST
7601: LIST
7602: LIST
7603: PUSH
7604: LD_INT 101
7606: PUSH
7607: LD_INT 102
7609: PUSH
7610: LD_INT 103
7612: PUSH
7613: LD_INT 104
7615: PUSH
7616: LD_INT 105
7618: PUSH
7619: LD_INT 106
7621: PUSH
7622: LD_INT 107
7624: PUSH
7625: LD_INT 108
7627: PUSH
7628: LD_INT 109
7630: PUSH
7631: LD_INT 110
7633: PUSH
7634: LD_INT 111
7636: PUSH
7637: LD_INT 112
7639: PUSH
7640: LD_INT 113
7642: PUSH
7643: LD_INT 114
7645: PUSH
7646: LD_INT 115
7648: PUSH
7649: EMPTY
7650: LIST
7651: LIST
7652: LIST
7653: LIST
7654: LIST
7655: LIST
7656: LIST
7657: LIST
7658: LIST
7659: LIST
7660: LIST
7661: LIST
7662: LIST
7663: LIST
7664: LIST
7665: PUSH
7666: EMPTY
7667: LIST
7668: LIST
7669: ST_TO_ADDR
7670: GO 7673
7672: POP
// end else
7673: GO 7710
// if campaign_id = 5 then
7675: LD_OWVAR 69
7679: PUSH
7680: LD_INT 5
7682: EQUAL
7683: IFFALSE 7710
// begin result := [ [ 1 , 2 ] , [ 100 ] ] ;
7685: LD_ADDR_VAR 0 1
7689: PUSH
7690: LD_INT 1
7692: PUSH
7693: LD_INT 2
7695: PUSH
7696: EMPTY
7697: LIST
7698: LIST
7699: PUSH
7700: LD_INT 100
7702: PUSH
7703: EMPTY
7704: LIST
7705: PUSH
7706: EMPTY
7707: LIST
7708: LIST
7709: ST_TO_ADDR
// end ; if result then
7710: LD_VAR 0 1
7714: IFFALSE 8003
// begin normal :=  ;
7716: LD_ADDR_VAR 0 3
7720: PUSH
7721: LD_STRING 
7723: ST_TO_ADDR
// hardcore :=  ;
7724: LD_ADDR_VAR 0 4
7728: PUSH
7729: LD_STRING 
7731: ST_TO_ADDR
// for i = 1 to normalCounter do
7732: LD_ADDR_VAR 0 5
7736: PUSH
7737: DOUBLE
7738: LD_INT 1
7740: DEC
7741: ST_TO_ADDR
7742: LD_EXP 45
7746: PUSH
7747: FOR_TO
7748: IFFALSE 7849
// begin tmp := 0 ;
7750: LD_ADDR_VAR 0 2
7754: PUSH
7755: LD_STRING 0
7757: ST_TO_ADDR
// if result [ 1 ] then
7758: LD_VAR 0 1
7762: PUSH
7763: LD_INT 1
7765: ARRAY
7766: IFFALSE 7831
// if result [ 1 ] [ 1 ] = i then
7768: LD_VAR 0 1
7772: PUSH
7773: LD_INT 1
7775: ARRAY
7776: PUSH
7777: LD_INT 1
7779: ARRAY
7780: PUSH
7781: LD_VAR 0 5
7785: EQUAL
7786: IFFALSE 7831
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
7788: LD_ADDR_VAR 0 1
7792: PUSH
7793: LD_VAR 0 1
7797: PPUSH
7798: LD_INT 1
7800: PPUSH
7801: LD_VAR 0 1
7805: PUSH
7806: LD_INT 1
7808: ARRAY
7809: PPUSH
7810: LD_INT 1
7812: PPUSH
7813: CALL_OW 3
7817: PPUSH
7818: CALL_OW 1
7822: ST_TO_ADDR
// tmp := 1 ;
7823: LD_ADDR_VAR 0 2
7827: PUSH
7828: LD_STRING 1
7830: ST_TO_ADDR
// end ; normal := normal & tmp ;
7831: LD_ADDR_VAR 0 3
7835: PUSH
7836: LD_VAR 0 3
7840: PUSH
7841: LD_VAR 0 2
7845: STR
7846: ST_TO_ADDR
// end ;
7847: GO 7747
7849: POP
7850: POP
// for i = 1 to hardcoreCounter do
7851: LD_ADDR_VAR 0 5
7855: PUSH
7856: DOUBLE
7857: LD_INT 1
7859: DEC
7860: ST_TO_ADDR
7861: LD_EXP 46
7865: PUSH
7866: FOR_TO
7867: IFFALSE 7972
// begin tmp := 0 ;
7869: LD_ADDR_VAR 0 2
7873: PUSH
7874: LD_STRING 0
7876: ST_TO_ADDR
// if result [ 2 ] then
7877: LD_VAR 0 1
7881: PUSH
7882: LD_INT 2
7884: ARRAY
7885: IFFALSE 7954
// if result [ 2 ] [ 1 ] = 100 + i then
7887: LD_VAR 0 1
7891: PUSH
7892: LD_INT 2
7894: ARRAY
7895: PUSH
7896: LD_INT 1
7898: ARRAY
7899: PUSH
7900: LD_INT 100
7902: PUSH
7903: LD_VAR 0 5
7907: PLUS
7908: EQUAL
7909: IFFALSE 7954
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
7911: LD_ADDR_VAR 0 1
7915: PUSH
7916: LD_VAR 0 1
7920: PPUSH
7921: LD_INT 2
7923: PPUSH
7924: LD_VAR 0 1
7928: PUSH
7929: LD_INT 2
7931: ARRAY
7932: PPUSH
7933: LD_INT 1
7935: PPUSH
7936: CALL_OW 3
7940: PPUSH
7941: CALL_OW 1
7945: ST_TO_ADDR
// tmp := 1 ;
7946: LD_ADDR_VAR 0 2
7950: PUSH
7951: LD_STRING 1
7953: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
7954: LD_ADDR_VAR 0 4
7958: PUSH
7959: LD_VAR 0 4
7963: PUSH
7964: LD_VAR 0 2
7968: STR
7969: ST_TO_ADDR
// end ;
7970: GO 7866
7972: POP
7973: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
7974: LD_STRING getStreamItemsFromMission("
7976: PUSH
7977: LD_VAR 0 3
7981: STR
7982: PUSH
7983: LD_STRING ","
7985: STR
7986: PUSH
7987: LD_VAR 0 4
7991: STR
7992: PUSH
7993: LD_STRING ")
7995: STR
7996: PPUSH
7997: CALL_OW 559
// end else
8001: GO 8010
// ToLua ( getStreamItemsFromMission("","") ) ;
8003: LD_STRING getStreamItemsFromMission("","")
8005: PPUSH
8006: CALL_OW 559
// end ;
8010: LD_VAR 0 1
8014: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
8015: LD_VAR 0 2
8019: PUSH
8020: LD_INT 100
8022: EQUAL
8023: IFFALSE 8972
// begin if not StreamModeActive then
8025: LD_EXP 44
8029: NOT
8030: IFFALSE 8040
// StreamModeActive := true ;
8032: LD_ADDR_EXP 44
8036: PUSH
8037: LD_INT 1
8039: ST_TO_ADDR
// if p3 = 0 then
8040: LD_VAR 0 3
8044: PUSH
8045: LD_INT 0
8047: EQUAL
8048: IFFALSE 8054
// InitStreamMode ;
8050: CALL 4275 0 0
// if p3 = 1 then
8054: LD_VAR 0 3
8058: PUSH
8059: LD_INT 1
8061: EQUAL
8062: IFFALSE 8072
// sRocket := true ;
8064: LD_ADDR_EXP 49
8068: PUSH
8069: LD_INT 1
8071: ST_TO_ADDR
// if p3 = 2 then
8072: LD_VAR 0 3
8076: PUSH
8077: LD_INT 2
8079: EQUAL
8080: IFFALSE 8090
// sSpeed := true ;
8082: LD_ADDR_EXP 48
8086: PUSH
8087: LD_INT 1
8089: ST_TO_ADDR
// if p3 = 3 then
8090: LD_VAR 0 3
8094: PUSH
8095: LD_INT 3
8097: EQUAL
8098: IFFALSE 8108
// sEngine := true ;
8100: LD_ADDR_EXP 50
8104: PUSH
8105: LD_INT 1
8107: ST_TO_ADDR
// if p3 = 4 then
8108: LD_VAR 0 3
8112: PUSH
8113: LD_INT 4
8115: EQUAL
8116: IFFALSE 8126
// sSpec := true ;
8118: LD_ADDR_EXP 47
8122: PUSH
8123: LD_INT 1
8125: ST_TO_ADDR
// if p3 = 5 then
8126: LD_VAR 0 3
8130: PUSH
8131: LD_INT 5
8133: EQUAL
8134: IFFALSE 8144
// sLevel := true ;
8136: LD_ADDR_EXP 51
8140: PUSH
8141: LD_INT 1
8143: ST_TO_ADDR
// if p3 = 6 then
8144: LD_VAR 0 3
8148: PUSH
8149: LD_INT 6
8151: EQUAL
8152: IFFALSE 8162
// sArmoury := true ;
8154: LD_ADDR_EXP 52
8158: PUSH
8159: LD_INT 1
8161: ST_TO_ADDR
// if p3 = 7 then
8162: LD_VAR 0 3
8166: PUSH
8167: LD_INT 7
8169: EQUAL
8170: IFFALSE 8180
// sRadar := true ;
8172: LD_ADDR_EXP 53
8176: PUSH
8177: LD_INT 1
8179: ST_TO_ADDR
// if p3 = 8 then
8180: LD_VAR 0 3
8184: PUSH
8185: LD_INT 8
8187: EQUAL
8188: IFFALSE 8198
// sBunker := true ;
8190: LD_ADDR_EXP 54
8194: PUSH
8195: LD_INT 1
8197: ST_TO_ADDR
// if p3 = 9 then
8198: LD_VAR 0 3
8202: PUSH
8203: LD_INT 9
8205: EQUAL
8206: IFFALSE 8216
// sHack := true ;
8208: LD_ADDR_EXP 55
8212: PUSH
8213: LD_INT 1
8215: ST_TO_ADDR
// if p3 = 10 then
8216: LD_VAR 0 3
8220: PUSH
8221: LD_INT 10
8223: EQUAL
8224: IFFALSE 8234
// sFire := true ;
8226: LD_ADDR_EXP 56
8230: PUSH
8231: LD_INT 1
8233: ST_TO_ADDR
// if p3 = 11 then
8234: LD_VAR 0 3
8238: PUSH
8239: LD_INT 11
8241: EQUAL
8242: IFFALSE 8252
// sRefresh := true ;
8244: LD_ADDR_EXP 57
8248: PUSH
8249: LD_INT 1
8251: ST_TO_ADDR
// if p3 = 12 then
8252: LD_VAR 0 3
8256: PUSH
8257: LD_INT 12
8259: EQUAL
8260: IFFALSE 8270
// sExp := true ;
8262: LD_ADDR_EXP 58
8266: PUSH
8267: LD_INT 1
8269: ST_TO_ADDR
// if p3 = 13 then
8270: LD_VAR 0 3
8274: PUSH
8275: LD_INT 13
8277: EQUAL
8278: IFFALSE 8288
// sDepot := true ;
8280: LD_ADDR_EXP 59
8284: PUSH
8285: LD_INT 1
8287: ST_TO_ADDR
// if p3 = 14 then
8288: LD_VAR 0 3
8292: PUSH
8293: LD_INT 14
8295: EQUAL
8296: IFFALSE 8306
// sFlag := true ;
8298: LD_ADDR_EXP 60
8302: PUSH
8303: LD_INT 1
8305: ST_TO_ADDR
// if p3 = 15 then
8306: LD_VAR 0 3
8310: PUSH
8311: LD_INT 15
8313: EQUAL
8314: IFFALSE 8324
// sKamikadze := true ;
8316: LD_ADDR_EXP 68
8320: PUSH
8321: LD_INT 1
8323: ST_TO_ADDR
// if p3 = 16 then
8324: LD_VAR 0 3
8328: PUSH
8329: LD_INT 16
8331: EQUAL
8332: IFFALSE 8342
// sTroll := true ;
8334: LD_ADDR_EXP 69
8338: PUSH
8339: LD_INT 1
8341: ST_TO_ADDR
// if p3 = 17 then
8342: LD_VAR 0 3
8346: PUSH
8347: LD_INT 17
8349: EQUAL
8350: IFFALSE 8360
// sSlow := true ;
8352: LD_ADDR_EXP 70
8356: PUSH
8357: LD_INT 1
8359: ST_TO_ADDR
// if p3 = 18 then
8360: LD_VAR 0 3
8364: PUSH
8365: LD_INT 18
8367: EQUAL
8368: IFFALSE 8378
// sLack := true ;
8370: LD_ADDR_EXP 71
8374: PUSH
8375: LD_INT 1
8377: ST_TO_ADDR
// if p3 = 19 then
8378: LD_VAR 0 3
8382: PUSH
8383: LD_INT 19
8385: EQUAL
8386: IFFALSE 8396
// sTank := true ;
8388: LD_ADDR_EXP 73
8392: PUSH
8393: LD_INT 1
8395: ST_TO_ADDR
// if p3 = 20 then
8396: LD_VAR 0 3
8400: PUSH
8401: LD_INT 20
8403: EQUAL
8404: IFFALSE 8414
// sRemote := true ;
8406: LD_ADDR_EXP 74
8410: PUSH
8411: LD_INT 1
8413: ST_TO_ADDR
// if p3 = 21 then
8414: LD_VAR 0 3
8418: PUSH
8419: LD_INT 21
8421: EQUAL
8422: IFFALSE 8432
// sPowell := true ;
8424: LD_ADDR_EXP 75
8428: PUSH
8429: LD_INT 1
8431: ST_TO_ADDR
// if p3 = 22 then
8432: LD_VAR 0 3
8436: PUSH
8437: LD_INT 22
8439: EQUAL
8440: IFFALSE 8450
// sTeleport := true ;
8442: LD_ADDR_EXP 78
8446: PUSH
8447: LD_INT 1
8449: ST_TO_ADDR
// if p3 = 23 then
8450: LD_VAR 0 3
8454: PUSH
8455: LD_INT 23
8457: EQUAL
8458: IFFALSE 8468
// sOilTower := true ;
8460: LD_ADDR_EXP 80
8464: PUSH
8465: LD_INT 1
8467: ST_TO_ADDR
// if p3 = 24 then
8468: LD_VAR 0 3
8472: PUSH
8473: LD_INT 24
8475: EQUAL
8476: IFFALSE 8486
// sShovel := true ;
8478: LD_ADDR_EXP 81
8482: PUSH
8483: LD_INT 1
8485: ST_TO_ADDR
// if p3 = 25 then
8486: LD_VAR 0 3
8490: PUSH
8491: LD_INT 25
8493: EQUAL
8494: IFFALSE 8504
// sSheik := true ;
8496: LD_ADDR_EXP 82
8500: PUSH
8501: LD_INT 1
8503: ST_TO_ADDR
// if p3 = 26 then
8504: LD_VAR 0 3
8508: PUSH
8509: LD_INT 26
8511: EQUAL
8512: IFFALSE 8522
// sEarthquake := true ;
8514: LD_ADDR_EXP 84
8518: PUSH
8519: LD_INT 1
8521: ST_TO_ADDR
// if p3 = 27 then
8522: LD_VAR 0 3
8526: PUSH
8527: LD_INT 27
8529: EQUAL
8530: IFFALSE 8540
// sAI := true ;
8532: LD_ADDR_EXP 85
8536: PUSH
8537: LD_INT 1
8539: ST_TO_ADDR
// if p3 = 28 then
8540: LD_VAR 0 3
8544: PUSH
8545: LD_INT 28
8547: EQUAL
8548: IFFALSE 8558
// sCargo := true ;
8550: LD_ADDR_EXP 88
8554: PUSH
8555: LD_INT 1
8557: ST_TO_ADDR
// if p3 = 29 then
8558: LD_VAR 0 3
8562: PUSH
8563: LD_INT 29
8565: EQUAL
8566: IFFALSE 8576
// sDLaser := true ;
8568: LD_ADDR_EXP 89
8572: PUSH
8573: LD_INT 1
8575: ST_TO_ADDR
// if p3 = 30 then
8576: LD_VAR 0 3
8580: PUSH
8581: LD_INT 30
8583: EQUAL
8584: IFFALSE 8594
// sExchange := true ;
8586: LD_ADDR_EXP 90
8590: PUSH
8591: LD_INT 1
8593: ST_TO_ADDR
// if p3 = 31 then
8594: LD_VAR 0 3
8598: PUSH
8599: LD_INT 31
8601: EQUAL
8602: IFFALSE 8612
// sFac := true ;
8604: LD_ADDR_EXP 91
8608: PUSH
8609: LD_INT 1
8611: ST_TO_ADDR
// if p3 = 32 then
8612: LD_VAR 0 3
8616: PUSH
8617: LD_INT 32
8619: EQUAL
8620: IFFALSE 8630
// sPower := true ;
8622: LD_ADDR_EXP 92
8626: PUSH
8627: LD_INT 1
8629: ST_TO_ADDR
// if p3 = 33 then
8630: LD_VAR 0 3
8634: PUSH
8635: LD_INT 33
8637: EQUAL
8638: IFFALSE 8648
// sRandom := true ;
8640: LD_ADDR_EXP 93
8644: PUSH
8645: LD_INT 1
8647: ST_TO_ADDR
// if p3 = 34 then
8648: LD_VAR 0 3
8652: PUSH
8653: LD_INT 34
8655: EQUAL
8656: IFFALSE 8666
// sShield := true ;
8658: LD_ADDR_EXP 94
8662: PUSH
8663: LD_INT 1
8665: ST_TO_ADDR
// if p3 = 35 then
8666: LD_VAR 0 3
8670: PUSH
8671: LD_INT 35
8673: EQUAL
8674: IFFALSE 8684
// sTime := true ;
8676: LD_ADDR_EXP 95
8680: PUSH
8681: LD_INT 1
8683: ST_TO_ADDR
// if p3 = 36 then
8684: LD_VAR 0 3
8688: PUSH
8689: LD_INT 36
8691: EQUAL
8692: IFFALSE 8702
// sTools := true ;
8694: LD_ADDR_EXP 96
8698: PUSH
8699: LD_INT 1
8701: ST_TO_ADDR
// if p3 = 101 then
8702: LD_VAR 0 3
8706: PUSH
8707: LD_INT 101
8709: EQUAL
8710: IFFALSE 8720
// sSold := true ;
8712: LD_ADDR_EXP 61
8716: PUSH
8717: LD_INT 1
8719: ST_TO_ADDR
// if p3 = 102 then
8720: LD_VAR 0 3
8724: PUSH
8725: LD_INT 102
8727: EQUAL
8728: IFFALSE 8738
// sDiff := true ;
8730: LD_ADDR_EXP 62
8734: PUSH
8735: LD_INT 1
8737: ST_TO_ADDR
// if p3 = 103 then
8738: LD_VAR 0 3
8742: PUSH
8743: LD_INT 103
8745: EQUAL
8746: IFFALSE 8756
// sFog := true ;
8748: LD_ADDR_EXP 65
8752: PUSH
8753: LD_INT 1
8755: ST_TO_ADDR
// if p3 = 104 then
8756: LD_VAR 0 3
8760: PUSH
8761: LD_INT 104
8763: EQUAL
8764: IFFALSE 8774
// sReset := true ;
8766: LD_ADDR_EXP 66
8770: PUSH
8771: LD_INT 1
8773: ST_TO_ADDR
// if p3 = 105 then
8774: LD_VAR 0 3
8778: PUSH
8779: LD_INT 105
8781: EQUAL
8782: IFFALSE 8792
// sSun := true ;
8784: LD_ADDR_EXP 67
8788: PUSH
8789: LD_INT 1
8791: ST_TO_ADDR
// if p3 = 106 then
8792: LD_VAR 0 3
8796: PUSH
8797: LD_INT 106
8799: EQUAL
8800: IFFALSE 8810
// sTiger := true ;
8802: LD_ADDR_EXP 63
8806: PUSH
8807: LD_INT 1
8809: ST_TO_ADDR
// if p3 = 107 then
8810: LD_VAR 0 3
8814: PUSH
8815: LD_INT 107
8817: EQUAL
8818: IFFALSE 8828
// sBomb := true ;
8820: LD_ADDR_EXP 64
8824: PUSH
8825: LD_INT 1
8827: ST_TO_ADDR
// if p3 = 108 then
8828: LD_VAR 0 3
8832: PUSH
8833: LD_INT 108
8835: EQUAL
8836: IFFALSE 8846
// sWound := true ;
8838: LD_ADDR_EXP 72
8842: PUSH
8843: LD_INT 1
8845: ST_TO_ADDR
// if p3 = 109 then
8846: LD_VAR 0 3
8850: PUSH
8851: LD_INT 109
8853: EQUAL
8854: IFFALSE 8864
// sBetray := true ;
8856: LD_ADDR_EXP 76
8860: PUSH
8861: LD_INT 1
8863: ST_TO_ADDR
// if p3 = 110 then
8864: LD_VAR 0 3
8868: PUSH
8869: LD_INT 110
8871: EQUAL
8872: IFFALSE 8882
// sContamin := true ;
8874: LD_ADDR_EXP 77
8878: PUSH
8879: LD_INT 1
8881: ST_TO_ADDR
// if p3 = 111 then
8882: LD_VAR 0 3
8886: PUSH
8887: LD_INT 111
8889: EQUAL
8890: IFFALSE 8900
// sOil := true ;
8892: LD_ADDR_EXP 79
8896: PUSH
8897: LD_INT 1
8899: ST_TO_ADDR
// if p3 = 112 then
8900: LD_VAR 0 3
8904: PUSH
8905: LD_INT 112
8907: EQUAL
8908: IFFALSE 8918
// sStu := true ;
8910: LD_ADDR_EXP 83
8914: PUSH
8915: LD_INT 1
8917: ST_TO_ADDR
// if p3 = 113 then
8918: LD_VAR 0 3
8922: PUSH
8923: LD_INT 113
8925: EQUAL
8926: IFFALSE 8936
// sBazooka := true ;
8928: LD_ADDR_EXP 86
8932: PUSH
8933: LD_INT 1
8935: ST_TO_ADDR
// if p3 = 114 then
8936: LD_VAR 0 3
8940: PUSH
8941: LD_INT 114
8943: EQUAL
8944: IFFALSE 8954
// sMortar := true ;
8946: LD_ADDR_EXP 87
8950: PUSH
8951: LD_INT 1
8953: ST_TO_ADDR
// if p3 = 115 then
8954: LD_VAR 0 3
8958: PUSH
8959: LD_INT 115
8961: EQUAL
8962: IFFALSE 8972
// sRanger := true ;
8964: LD_ADDR_EXP 97
8968: PUSH
8969: LD_INT 1
8971: ST_TO_ADDR
// end ; end ;
8972: PPOPN 6
8974: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
8975: LD_EXP 44
8979: PUSH
8980: LD_EXP 49
8984: AND
8985: IFFALSE 9109
8987: GO 8989
8989: DISABLE
8990: LD_INT 0
8992: PPUSH
8993: PPUSH
// begin enable ;
8994: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
8995: LD_ADDR_VAR 0 2
8999: PUSH
9000: LD_INT 22
9002: PUSH
9003: LD_OWVAR 2
9007: PUSH
9008: EMPTY
9009: LIST
9010: LIST
9011: PUSH
9012: LD_INT 2
9014: PUSH
9015: LD_INT 34
9017: PUSH
9018: LD_INT 7
9020: PUSH
9021: EMPTY
9022: LIST
9023: LIST
9024: PUSH
9025: LD_INT 34
9027: PUSH
9028: LD_INT 45
9030: PUSH
9031: EMPTY
9032: LIST
9033: LIST
9034: PUSH
9035: LD_INT 34
9037: PUSH
9038: LD_INT 28
9040: PUSH
9041: EMPTY
9042: LIST
9043: LIST
9044: PUSH
9045: LD_INT 34
9047: PUSH
9048: LD_INT 47
9050: PUSH
9051: EMPTY
9052: LIST
9053: LIST
9054: PUSH
9055: EMPTY
9056: LIST
9057: LIST
9058: LIST
9059: LIST
9060: LIST
9061: PUSH
9062: EMPTY
9063: LIST
9064: LIST
9065: PPUSH
9066: CALL_OW 69
9070: ST_TO_ADDR
// if not tmp then
9071: LD_VAR 0 2
9075: NOT
9076: IFFALSE 9080
// exit ;
9078: GO 9109
// for i in tmp do
9080: LD_ADDR_VAR 0 1
9084: PUSH
9085: LD_VAR 0 2
9089: PUSH
9090: FOR_IN
9091: IFFALSE 9107
// begin SetLives ( i , 0 ) ;
9093: LD_VAR 0 1
9097: PPUSH
9098: LD_INT 0
9100: PPUSH
9101: CALL_OW 234
// end ;
9105: GO 9090
9107: POP
9108: POP
// end ;
9109: PPOPN 2
9111: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
9112: LD_EXP 44
9116: PUSH
9117: LD_EXP 50
9121: AND
9122: IFFALSE 9206
9124: GO 9126
9126: DISABLE
9127: LD_INT 0
9129: PPUSH
9130: PPUSH
// begin enable ;
9131: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
9132: LD_ADDR_VAR 0 2
9136: PUSH
9137: LD_INT 22
9139: PUSH
9140: LD_OWVAR 2
9144: PUSH
9145: EMPTY
9146: LIST
9147: LIST
9148: PUSH
9149: LD_INT 32
9151: PUSH
9152: LD_INT 3
9154: PUSH
9155: EMPTY
9156: LIST
9157: LIST
9158: PUSH
9159: EMPTY
9160: LIST
9161: LIST
9162: PPUSH
9163: CALL_OW 69
9167: ST_TO_ADDR
// if not tmp then
9168: LD_VAR 0 2
9172: NOT
9173: IFFALSE 9177
// exit ;
9175: GO 9206
// for i in tmp do
9177: LD_ADDR_VAR 0 1
9181: PUSH
9182: LD_VAR 0 2
9186: PUSH
9187: FOR_IN
9188: IFFALSE 9204
// begin SetLives ( i , 0 ) ;
9190: LD_VAR 0 1
9194: PPUSH
9195: LD_INT 0
9197: PPUSH
9198: CALL_OW 234
// end ;
9202: GO 9187
9204: POP
9205: POP
// end ;
9206: PPOPN 2
9208: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
9209: LD_EXP 44
9213: PUSH
9214: LD_EXP 47
9218: AND
9219: IFFALSE 9312
9221: GO 9223
9223: DISABLE
9224: LD_INT 0
9226: PPUSH
// begin enable ;
9227: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
9228: LD_ADDR_VAR 0 1
9232: PUSH
9233: LD_INT 22
9235: PUSH
9236: LD_OWVAR 2
9240: PUSH
9241: EMPTY
9242: LIST
9243: LIST
9244: PUSH
9245: LD_INT 2
9247: PUSH
9248: LD_INT 25
9250: PUSH
9251: LD_INT 5
9253: PUSH
9254: EMPTY
9255: LIST
9256: LIST
9257: PUSH
9258: LD_INT 25
9260: PUSH
9261: LD_INT 9
9263: PUSH
9264: EMPTY
9265: LIST
9266: LIST
9267: PUSH
9268: LD_INT 25
9270: PUSH
9271: LD_INT 8
9273: PUSH
9274: EMPTY
9275: LIST
9276: LIST
9277: PUSH
9278: EMPTY
9279: LIST
9280: LIST
9281: LIST
9282: LIST
9283: PUSH
9284: EMPTY
9285: LIST
9286: LIST
9287: PPUSH
9288: CALL_OW 69
9292: PUSH
9293: FOR_IN
9294: IFFALSE 9310
// begin SetClass ( i , 1 ) ;
9296: LD_VAR 0 1
9300: PPUSH
9301: LD_INT 1
9303: PPUSH
9304: CALL_OW 336
// end ;
9308: GO 9293
9310: POP
9311: POP
// end ;
9312: PPOPN 1
9314: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
9315: LD_EXP 44
9319: PUSH
9320: LD_EXP 48
9324: AND
9325: PUSH
9326: LD_OWVAR 65
9330: PUSH
9331: LD_INT 7
9333: LESS
9334: AND
9335: IFFALSE 9349
9337: GO 9339
9339: DISABLE
// begin enable ;
9340: ENABLE
// game_speed := 7 ;
9341: LD_ADDR_OWVAR 65
9345: PUSH
9346: LD_INT 7
9348: ST_TO_ADDR
// end ;
9349: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
9350: LD_EXP 44
9354: PUSH
9355: LD_EXP 51
9359: AND
9360: IFFALSE 9562
9362: GO 9364
9364: DISABLE
9365: LD_INT 0
9367: PPUSH
9368: PPUSH
9369: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
9370: LD_ADDR_VAR 0 3
9374: PUSH
9375: LD_INT 81
9377: PUSH
9378: LD_OWVAR 2
9382: PUSH
9383: EMPTY
9384: LIST
9385: LIST
9386: PUSH
9387: LD_INT 21
9389: PUSH
9390: LD_INT 1
9392: PUSH
9393: EMPTY
9394: LIST
9395: LIST
9396: PUSH
9397: EMPTY
9398: LIST
9399: LIST
9400: PPUSH
9401: CALL_OW 69
9405: ST_TO_ADDR
// if not tmp then
9406: LD_VAR 0 3
9410: NOT
9411: IFFALSE 9415
// exit ;
9413: GO 9562
// if tmp > 5 then
9415: LD_VAR 0 3
9419: PUSH
9420: LD_INT 5
9422: GREATER
9423: IFFALSE 9435
// k := 5 else
9425: LD_ADDR_VAR 0 2
9429: PUSH
9430: LD_INT 5
9432: ST_TO_ADDR
9433: GO 9445
// k := tmp ;
9435: LD_ADDR_VAR 0 2
9439: PUSH
9440: LD_VAR 0 3
9444: ST_TO_ADDR
// for i := 1 to k do
9445: LD_ADDR_VAR 0 1
9449: PUSH
9450: DOUBLE
9451: LD_INT 1
9453: DEC
9454: ST_TO_ADDR
9455: LD_VAR 0 2
9459: PUSH
9460: FOR_TO
9461: IFFALSE 9560
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
9463: LD_VAR 0 3
9467: PUSH
9468: LD_VAR 0 1
9472: ARRAY
9473: PPUSH
9474: LD_VAR 0 1
9478: PUSH
9479: LD_INT 4
9481: MOD
9482: PUSH
9483: LD_INT 1
9485: PLUS
9486: PPUSH
9487: CALL_OW 259
9491: PUSH
9492: LD_INT 10
9494: LESS
9495: IFFALSE 9558
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
9497: LD_VAR 0 3
9501: PUSH
9502: LD_VAR 0 1
9506: ARRAY
9507: PPUSH
9508: LD_VAR 0 1
9512: PUSH
9513: LD_INT 4
9515: MOD
9516: PUSH
9517: LD_INT 1
9519: PLUS
9520: PPUSH
9521: LD_VAR 0 3
9525: PUSH
9526: LD_VAR 0 1
9530: ARRAY
9531: PPUSH
9532: LD_VAR 0 1
9536: PUSH
9537: LD_INT 4
9539: MOD
9540: PUSH
9541: LD_INT 1
9543: PLUS
9544: PPUSH
9545: CALL_OW 259
9549: PUSH
9550: LD_INT 1
9552: PLUS
9553: PPUSH
9554: CALL_OW 237
9558: GO 9460
9560: POP
9561: POP
// end ;
9562: PPOPN 3
9564: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
9565: LD_EXP 44
9569: PUSH
9570: LD_EXP 52
9574: AND
9575: IFFALSE 9595
9577: GO 9579
9579: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
9580: LD_INT 4
9582: PPUSH
9583: LD_OWVAR 2
9587: PPUSH
9588: LD_INT 0
9590: PPUSH
9591: CALL_OW 324
9595: END
// every 0 0$1 trigger StreamModeActive and sShovel do
9596: LD_EXP 44
9600: PUSH
9601: LD_EXP 81
9605: AND
9606: IFFALSE 9626
9608: GO 9610
9610: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
9611: LD_INT 19
9613: PPUSH
9614: LD_OWVAR 2
9618: PPUSH
9619: LD_INT 0
9621: PPUSH
9622: CALL_OW 324
9626: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
9627: LD_EXP 44
9631: PUSH
9632: LD_EXP 53
9636: AND
9637: IFFALSE 9739
9639: GO 9641
9641: DISABLE
9642: LD_INT 0
9644: PPUSH
9645: PPUSH
// begin enable ;
9646: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
9647: LD_ADDR_VAR 0 2
9651: PUSH
9652: LD_INT 22
9654: PUSH
9655: LD_OWVAR 2
9659: PUSH
9660: EMPTY
9661: LIST
9662: LIST
9663: PUSH
9664: LD_INT 2
9666: PUSH
9667: LD_INT 34
9669: PUSH
9670: LD_INT 11
9672: PUSH
9673: EMPTY
9674: LIST
9675: LIST
9676: PUSH
9677: LD_INT 34
9679: PUSH
9680: LD_INT 30
9682: PUSH
9683: EMPTY
9684: LIST
9685: LIST
9686: PUSH
9687: EMPTY
9688: LIST
9689: LIST
9690: LIST
9691: PUSH
9692: EMPTY
9693: LIST
9694: LIST
9695: PPUSH
9696: CALL_OW 69
9700: ST_TO_ADDR
// if not tmp then
9701: LD_VAR 0 2
9705: NOT
9706: IFFALSE 9710
// exit ;
9708: GO 9739
// for i in tmp do
9710: LD_ADDR_VAR 0 1
9714: PUSH
9715: LD_VAR 0 2
9719: PUSH
9720: FOR_IN
9721: IFFALSE 9737
// begin SetLives ( i , 0 ) ;
9723: LD_VAR 0 1
9727: PPUSH
9728: LD_INT 0
9730: PPUSH
9731: CALL_OW 234
// end ;
9735: GO 9720
9737: POP
9738: POP
// end ;
9739: PPOPN 2
9741: END
// every 0 0$1 trigger StreamModeActive and sBunker do
9742: LD_EXP 44
9746: PUSH
9747: LD_EXP 54
9751: AND
9752: IFFALSE 9772
9754: GO 9756
9756: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
9757: LD_INT 32
9759: PPUSH
9760: LD_OWVAR 2
9764: PPUSH
9765: LD_INT 0
9767: PPUSH
9768: CALL_OW 324
9772: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
9773: LD_EXP 44
9777: PUSH
9778: LD_EXP 55
9782: AND
9783: IFFALSE 9964
9785: GO 9787
9787: DISABLE
9788: LD_INT 0
9790: PPUSH
9791: PPUSH
9792: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
9793: LD_ADDR_VAR 0 2
9797: PUSH
9798: LD_INT 22
9800: PUSH
9801: LD_OWVAR 2
9805: PUSH
9806: EMPTY
9807: LIST
9808: LIST
9809: PUSH
9810: LD_INT 33
9812: PUSH
9813: LD_INT 3
9815: PUSH
9816: EMPTY
9817: LIST
9818: LIST
9819: PUSH
9820: EMPTY
9821: LIST
9822: LIST
9823: PPUSH
9824: CALL_OW 69
9828: ST_TO_ADDR
// if not tmp then
9829: LD_VAR 0 2
9833: NOT
9834: IFFALSE 9838
// exit ;
9836: GO 9964
// side := 0 ;
9838: LD_ADDR_VAR 0 3
9842: PUSH
9843: LD_INT 0
9845: ST_TO_ADDR
// for i := 1 to 8 do
9846: LD_ADDR_VAR 0 1
9850: PUSH
9851: DOUBLE
9852: LD_INT 1
9854: DEC
9855: ST_TO_ADDR
9856: LD_INT 8
9858: PUSH
9859: FOR_TO
9860: IFFALSE 9908
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
9862: LD_OWVAR 2
9866: PUSH
9867: LD_VAR 0 1
9871: NONEQUAL
9872: PUSH
9873: LD_OWVAR 2
9877: PPUSH
9878: LD_VAR 0 1
9882: PPUSH
9883: CALL_OW 81
9887: PUSH
9888: LD_INT 2
9890: EQUAL
9891: AND
9892: IFFALSE 9906
// begin side := i ;
9894: LD_ADDR_VAR 0 3
9898: PUSH
9899: LD_VAR 0 1
9903: ST_TO_ADDR
// break ;
9904: GO 9908
// end ;
9906: GO 9859
9908: POP
9909: POP
// if not side then
9910: LD_VAR 0 3
9914: NOT
9915: IFFALSE 9919
// exit ;
9917: GO 9964
// for i := 1 to tmp do
9919: LD_ADDR_VAR 0 1
9923: PUSH
9924: DOUBLE
9925: LD_INT 1
9927: DEC
9928: ST_TO_ADDR
9929: LD_VAR 0 2
9933: PUSH
9934: FOR_TO
9935: IFFALSE 9962
// if Prob ( 60 ) then
9937: LD_INT 60
9939: PPUSH
9940: CALL_OW 13
9944: IFFALSE 9960
// SetSide ( i , side ) ;
9946: LD_VAR 0 1
9950: PPUSH
9951: LD_VAR 0 3
9955: PPUSH
9956: CALL_OW 235
9960: GO 9934
9962: POP
9963: POP
// end ;
9964: PPOPN 3
9966: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
9967: LD_EXP 44
9971: PUSH
9972: LD_EXP 57
9976: AND
9977: IFFALSE 10096
9979: GO 9981
9981: DISABLE
9982: LD_INT 0
9984: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
9985: LD_ADDR_VAR 0 1
9989: PUSH
9990: LD_INT 22
9992: PUSH
9993: LD_OWVAR 2
9997: PUSH
9998: EMPTY
9999: LIST
10000: LIST
10001: PUSH
10002: LD_INT 21
10004: PUSH
10005: LD_INT 1
10007: PUSH
10008: EMPTY
10009: LIST
10010: LIST
10011: PUSH
10012: LD_INT 3
10014: PUSH
10015: LD_INT 23
10017: PUSH
10018: LD_INT 0
10020: PUSH
10021: EMPTY
10022: LIST
10023: LIST
10024: PUSH
10025: EMPTY
10026: LIST
10027: LIST
10028: PUSH
10029: EMPTY
10030: LIST
10031: LIST
10032: LIST
10033: PPUSH
10034: CALL_OW 69
10038: PUSH
10039: FOR_IN
10040: IFFALSE 10094
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
10042: LD_VAR 0 1
10046: PPUSH
10047: CALL_OW 257
10051: PUSH
10052: LD_INT 1
10054: PUSH
10055: LD_INT 2
10057: PUSH
10058: LD_INT 3
10060: PUSH
10061: LD_INT 4
10063: PUSH
10064: EMPTY
10065: LIST
10066: LIST
10067: LIST
10068: LIST
10069: IN
10070: IFFALSE 10092
// SetClass ( un , rand ( 1 , 4 ) ) ;
10072: LD_VAR 0 1
10076: PPUSH
10077: LD_INT 1
10079: PPUSH
10080: LD_INT 4
10082: PPUSH
10083: CALL_OW 12
10087: PPUSH
10088: CALL_OW 336
10092: GO 10039
10094: POP
10095: POP
// end ;
10096: PPOPN 1
10098: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
10099: LD_EXP 44
10103: PUSH
10104: LD_EXP 56
10108: AND
10109: IFFALSE 10188
10111: GO 10113
10113: DISABLE
10114: LD_INT 0
10116: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
10117: LD_ADDR_VAR 0 1
10121: PUSH
10122: LD_INT 22
10124: PUSH
10125: LD_OWVAR 2
10129: PUSH
10130: EMPTY
10131: LIST
10132: LIST
10133: PUSH
10134: LD_INT 21
10136: PUSH
10137: LD_INT 3
10139: PUSH
10140: EMPTY
10141: LIST
10142: LIST
10143: PUSH
10144: EMPTY
10145: LIST
10146: LIST
10147: PPUSH
10148: CALL_OW 69
10152: ST_TO_ADDR
// if not tmp then
10153: LD_VAR 0 1
10157: NOT
10158: IFFALSE 10162
// exit ;
10160: GO 10188
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
10162: LD_VAR 0 1
10166: PUSH
10167: LD_INT 1
10169: PPUSH
10170: LD_VAR 0 1
10174: PPUSH
10175: CALL_OW 12
10179: ARRAY
10180: PPUSH
10181: LD_INT 100
10183: PPUSH
10184: CALL_OW 234
// end ;
10188: PPOPN 1
10190: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
10191: LD_EXP 44
10195: PUSH
10196: LD_EXP 58
10200: AND
10201: IFFALSE 10299
10203: GO 10205
10205: DISABLE
10206: LD_INT 0
10208: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
10209: LD_ADDR_VAR 0 1
10213: PUSH
10214: LD_INT 22
10216: PUSH
10217: LD_OWVAR 2
10221: PUSH
10222: EMPTY
10223: LIST
10224: LIST
10225: PUSH
10226: LD_INT 21
10228: PUSH
10229: LD_INT 1
10231: PUSH
10232: EMPTY
10233: LIST
10234: LIST
10235: PUSH
10236: EMPTY
10237: LIST
10238: LIST
10239: PPUSH
10240: CALL_OW 69
10244: ST_TO_ADDR
// if not tmp then
10245: LD_VAR 0 1
10249: NOT
10250: IFFALSE 10254
// exit ;
10252: GO 10299
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
10254: LD_VAR 0 1
10258: PUSH
10259: LD_INT 1
10261: PPUSH
10262: LD_VAR 0 1
10266: PPUSH
10267: CALL_OW 12
10271: ARRAY
10272: PPUSH
10273: LD_INT 1
10275: PPUSH
10276: LD_INT 4
10278: PPUSH
10279: CALL_OW 12
10283: PPUSH
10284: LD_INT 3000
10286: PPUSH
10287: LD_INT 9000
10289: PPUSH
10290: CALL_OW 12
10294: PPUSH
10295: CALL_OW 492
// end ;
10299: PPOPN 1
10301: END
// every 0 0$1 trigger StreamModeActive and sDepot do
10302: LD_EXP 44
10306: PUSH
10307: LD_EXP 59
10311: AND
10312: IFFALSE 10332
10314: GO 10316
10316: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
10317: LD_INT 1
10319: PPUSH
10320: LD_OWVAR 2
10324: PPUSH
10325: LD_INT 0
10327: PPUSH
10328: CALL_OW 324
10332: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
10333: LD_EXP 44
10337: PUSH
10338: LD_EXP 60
10342: AND
10343: IFFALSE 10426
10345: GO 10347
10347: DISABLE
10348: LD_INT 0
10350: PPUSH
10351: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
10352: LD_ADDR_VAR 0 2
10356: PUSH
10357: LD_INT 22
10359: PUSH
10360: LD_OWVAR 2
10364: PUSH
10365: EMPTY
10366: LIST
10367: LIST
10368: PUSH
10369: LD_INT 21
10371: PUSH
10372: LD_INT 3
10374: PUSH
10375: EMPTY
10376: LIST
10377: LIST
10378: PUSH
10379: EMPTY
10380: LIST
10381: LIST
10382: PPUSH
10383: CALL_OW 69
10387: ST_TO_ADDR
// if not tmp then
10388: LD_VAR 0 2
10392: NOT
10393: IFFALSE 10397
// exit ;
10395: GO 10426
// for i in tmp do
10397: LD_ADDR_VAR 0 1
10401: PUSH
10402: LD_VAR 0 2
10406: PUSH
10407: FOR_IN
10408: IFFALSE 10424
// SetBLevel ( i , 10 ) ;
10410: LD_VAR 0 1
10414: PPUSH
10415: LD_INT 10
10417: PPUSH
10418: CALL_OW 241
10422: GO 10407
10424: POP
10425: POP
// end ;
10426: PPOPN 2
10428: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
10429: LD_EXP 44
10433: PUSH
10434: LD_EXP 61
10438: AND
10439: IFFALSE 10550
10441: GO 10443
10443: DISABLE
10444: LD_INT 0
10446: PPUSH
10447: PPUSH
10448: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
10449: LD_ADDR_VAR 0 3
10453: PUSH
10454: LD_INT 22
10456: PUSH
10457: LD_OWVAR 2
10461: PUSH
10462: EMPTY
10463: LIST
10464: LIST
10465: PUSH
10466: LD_INT 25
10468: PUSH
10469: LD_INT 1
10471: PUSH
10472: EMPTY
10473: LIST
10474: LIST
10475: PUSH
10476: EMPTY
10477: LIST
10478: LIST
10479: PPUSH
10480: CALL_OW 69
10484: ST_TO_ADDR
// if not tmp then
10485: LD_VAR 0 3
10489: NOT
10490: IFFALSE 10494
// exit ;
10492: GO 10550
// un := tmp [ rand ( 1 , tmp ) ] ;
10494: LD_ADDR_VAR 0 2
10498: PUSH
10499: LD_VAR 0 3
10503: PUSH
10504: LD_INT 1
10506: PPUSH
10507: LD_VAR 0 3
10511: PPUSH
10512: CALL_OW 12
10516: ARRAY
10517: ST_TO_ADDR
// if Crawls ( un ) then
10518: LD_VAR 0 2
10522: PPUSH
10523: CALL_OW 318
10527: IFFALSE 10538
// ComWalk ( un ) ;
10529: LD_VAR 0 2
10533: PPUSH
10534: CALL_OW 138
// SetClass ( un , class_sniper ) ;
10538: LD_VAR 0 2
10542: PPUSH
10543: LD_INT 5
10545: PPUSH
10546: CALL_OW 336
// end ;
10550: PPOPN 3
10552: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
10553: LD_EXP 44
10557: PUSH
10558: LD_EXP 62
10562: AND
10563: PUSH
10564: LD_OWVAR 67
10568: PUSH
10569: LD_INT 3
10571: LESS
10572: AND
10573: IFFALSE 10592
10575: GO 10577
10577: DISABLE
// Difficulty := Difficulty + 1 ;
10578: LD_ADDR_OWVAR 67
10582: PUSH
10583: LD_OWVAR 67
10587: PUSH
10588: LD_INT 1
10590: PLUS
10591: ST_TO_ADDR
10592: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
10593: LD_EXP 44
10597: PUSH
10598: LD_EXP 63
10602: AND
10603: IFFALSE 10706
10605: GO 10607
10607: DISABLE
10608: LD_INT 0
10610: PPUSH
// begin for i := 1 to 5 do
10611: LD_ADDR_VAR 0 1
10615: PUSH
10616: DOUBLE
10617: LD_INT 1
10619: DEC
10620: ST_TO_ADDR
10621: LD_INT 5
10623: PUSH
10624: FOR_TO
10625: IFFALSE 10704
// begin uc_nation := nation_nature ;
10627: LD_ADDR_OWVAR 21
10631: PUSH
10632: LD_INT 0
10634: ST_TO_ADDR
// uc_side := 0 ;
10635: LD_ADDR_OWVAR 20
10639: PUSH
10640: LD_INT 0
10642: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
10643: LD_ADDR_OWVAR 29
10647: PUSH
10648: LD_INT 12
10650: PUSH
10651: LD_INT 12
10653: PUSH
10654: EMPTY
10655: LIST
10656: LIST
10657: ST_TO_ADDR
// hc_agressivity := 20 ;
10658: LD_ADDR_OWVAR 35
10662: PUSH
10663: LD_INT 20
10665: ST_TO_ADDR
// hc_class := class_tiger ;
10666: LD_ADDR_OWVAR 28
10670: PUSH
10671: LD_INT 14
10673: ST_TO_ADDR
// hc_gallery :=  ;
10674: LD_ADDR_OWVAR 33
10678: PUSH
10679: LD_STRING 
10681: ST_TO_ADDR
// hc_name :=  ;
10682: LD_ADDR_OWVAR 26
10686: PUSH
10687: LD_STRING 
10689: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
10690: CALL_OW 44
10694: PPUSH
10695: LD_INT 0
10697: PPUSH
10698: CALL_OW 51
// end ;
10702: GO 10624
10704: POP
10705: POP
// end ;
10706: PPOPN 1
10708: END
// every 0 0$1 trigger StreamModeActive and sBomb do
10709: LD_EXP 44
10713: PUSH
10714: LD_EXP 64
10718: AND
10719: IFFALSE 10728
10721: GO 10723
10723: DISABLE
// StreamSibBomb ;
10724: CALL 10729 0 0
10728: END
// export function StreamSibBomb ; var i , x , y ; begin
10729: LD_INT 0
10731: PPUSH
10732: PPUSH
10733: PPUSH
10734: PPUSH
// result := false ;
10735: LD_ADDR_VAR 0 1
10739: PUSH
10740: LD_INT 0
10742: ST_TO_ADDR
// for i := 1 to 16 do
10743: LD_ADDR_VAR 0 2
10747: PUSH
10748: DOUBLE
10749: LD_INT 1
10751: DEC
10752: ST_TO_ADDR
10753: LD_INT 16
10755: PUSH
10756: FOR_TO
10757: IFFALSE 10956
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
10759: LD_ADDR_VAR 0 3
10763: PUSH
10764: LD_INT 10
10766: PUSH
10767: LD_INT 20
10769: PUSH
10770: LD_INT 30
10772: PUSH
10773: LD_INT 40
10775: PUSH
10776: LD_INT 50
10778: PUSH
10779: LD_INT 60
10781: PUSH
10782: LD_INT 70
10784: PUSH
10785: LD_INT 80
10787: PUSH
10788: LD_INT 90
10790: PUSH
10791: LD_INT 100
10793: PUSH
10794: LD_INT 110
10796: PUSH
10797: LD_INT 120
10799: PUSH
10800: LD_INT 130
10802: PUSH
10803: LD_INT 140
10805: PUSH
10806: LD_INT 150
10808: PUSH
10809: EMPTY
10810: LIST
10811: LIST
10812: LIST
10813: LIST
10814: LIST
10815: LIST
10816: LIST
10817: LIST
10818: LIST
10819: LIST
10820: LIST
10821: LIST
10822: LIST
10823: LIST
10824: LIST
10825: PUSH
10826: LD_INT 1
10828: PPUSH
10829: LD_INT 15
10831: PPUSH
10832: CALL_OW 12
10836: ARRAY
10837: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
10838: LD_ADDR_VAR 0 4
10842: PUSH
10843: LD_INT 10
10845: PUSH
10846: LD_INT 20
10848: PUSH
10849: LD_INT 30
10851: PUSH
10852: LD_INT 40
10854: PUSH
10855: LD_INT 50
10857: PUSH
10858: LD_INT 60
10860: PUSH
10861: LD_INT 70
10863: PUSH
10864: LD_INT 80
10866: PUSH
10867: LD_INT 90
10869: PUSH
10870: LD_INT 100
10872: PUSH
10873: LD_INT 110
10875: PUSH
10876: LD_INT 120
10878: PUSH
10879: LD_INT 130
10881: PUSH
10882: LD_INT 140
10884: PUSH
10885: LD_INT 150
10887: PUSH
10888: EMPTY
10889: LIST
10890: LIST
10891: LIST
10892: LIST
10893: LIST
10894: LIST
10895: LIST
10896: LIST
10897: LIST
10898: LIST
10899: LIST
10900: LIST
10901: LIST
10902: LIST
10903: LIST
10904: PUSH
10905: LD_INT 1
10907: PPUSH
10908: LD_INT 15
10910: PPUSH
10911: CALL_OW 12
10915: ARRAY
10916: ST_TO_ADDR
// if ValidHex ( x , y ) then
10917: LD_VAR 0 3
10921: PPUSH
10922: LD_VAR 0 4
10926: PPUSH
10927: CALL_OW 488
10931: IFFALSE 10954
// begin result := [ x , y ] ;
10933: LD_ADDR_VAR 0 1
10937: PUSH
10938: LD_VAR 0 3
10942: PUSH
10943: LD_VAR 0 4
10947: PUSH
10948: EMPTY
10949: LIST
10950: LIST
10951: ST_TO_ADDR
// break ;
10952: GO 10956
// end ; end ;
10954: GO 10756
10956: POP
10957: POP
// if result then
10958: LD_VAR 0 1
10962: IFFALSE 11022
// begin ToLua ( playSibBomb() ) ;
10964: LD_STRING playSibBomb()
10966: PPUSH
10967: CALL_OW 559
// wait ( 0 0$14 ) ;
10971: LD_INT 490
10973: PPUSH
10974: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
10978: LD_VAR 0 1
10982: PUSH
10983: LD_INT 1
10985: ARRAY
10986: PPUSH
10987: LD_VAR 0 1
10991: PUSH
10992: LD_INT 2
10994: ARRAY
10995: PPUSH
10996: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
11000: LD_VAR 0 1
11004: PUSH
11005: LD_INT 1
11007: ARRAY
11008: PPUSH
11009: LD_VAR 0 1
11013: PUSH
11014: LD_INT 2
11016: ARRAY
11017: PPUSH
11018: CALL_OW 429
// end ; end ;
11022: LD_VAR 0 1
11026: RET
// every 0 0$1 trigger StreamModeActive and sReset do
11027: LD_EXP 44
11031: PUSH
11032: LD_EXP 66
11036: AND
11037: IFFALSE 11049
11039: GO 11041
11041: DISABLE
// YouLost (  ) ;
11042: LD_STRING 
11044: PPUSH
11045: CALL_OW 104
11049: END
// every 0 0$1 trigger StreamModeActive and sFog do
11050: LD_EXP 44
11054: PUSH
11055: LD_EXP 65
11059: AND
11060: IFFALSE 11074
11062: GO 11064
11064: DISABLE
// FogOff ( your_side ) ;
11065: LD_OWVAR 2
11069: PPUSH
11070: CALL_OW 344
11074: END
// every 0 0$1 trigger StreamModeActive and sSun do
11075: LD_EXP 44
11079: PUSH
11080: LD_EXP 67
11084: AND
11085: IFFALSE 11113
11087: GO 11089
11089: DISABLE
// begin solar_recharge_percent := 0 ;
11090: LD_ADDR_OWVAR 79
11094: PUSH
11095: LD_INT 0
11097: ST_TO_ADDR
// wait ( 5 5$00 ) ;
11098: LD_INT 10500
11100: PPUSH
11101: CALL_OW 67
// solar_recharge_percent := 100 ;
11105: LD_ADDR_OWVAR 79
11109: PUSH
11110: LD_INT 100
11112: ST_TO_ADDR
// end ;
11113: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
11114: LD_EXP 44
11118: PUSH
11119: LD_EXP 68
11123: AND
11124: IFFALSE 11363
11126: GO 11128
11128: DISABLE
11129: LD_INT 0
11131: PPUSH
11132: PPUSH
11133: PPUSH
// begin tmp := [ ] ;
11134: LD_ADDR_VAR 0 3
11138: PUSH
11139: EMPTY
11140: ST_TO_ADDR
// for i := 1 to 6 do
11141: LD_ADDR_VAR 0 1
11145: PUSH
11146: DOUBLE
11147: LD_INT 1
11149: DEC
11150: ST_TO_ADDR
11151: LD_INT 6
11153: PUSH
11154: FOR_TO
11155: IFFALSE 11260
// begin uc_nation := nation_nature ;
11157: LD_ADDR_OWVAR 21
11161: PUSH
11162: LD_INT 0
11164: ST_TO_ADDR
// uc_side := 0 ;
11165: LD_ADDR_OWVAR 20
11169: PUSH
11170: LD_INT 0
11172: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
11173: LD_ADDR_OWVAR 29
11177: PUSH
11178: LD_INT 12
11180: PUSH
11181: LD_INT 12
11183: PUSH
11184: EMPTY
11185: LIST
11186: LIST
11187: ST_TO_ADDR
// hc_agressivity := 20 ;
11188: LD_ADDR_OWVAR 35
11192: PUSH
11193: LD_INT 20
11195: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
11196: LD_ADDR_OWVAR 28
11200: PUSH
11201: LD_INT 17
11203: ST_TO_ADDR
// hc_gallery :=  ;
11204: LD_ADDR_OWVAR 33
11208: PUSH
11209: LD_STRING 
11211: ST_TO_ADDR
// hc_name :=  ;
11212: LD_ADDR_OWVAR 26
11216: PUSH
11217: LD_STRING 
11219: ST_TO_ADDR
// un := CreateHuman ;
11220: LD_ADDR_VAR 0 2
11224: PUSH
11225: CALL_OW 44
11229: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
11230: LD_VAR 0 2
11234: PPUSH
11235: LD_INT 1
11237: PPUSH
11238: CALL_OW 51
// tmp := tmp ^ un ;
11242: LD_ADDR_VAR 0 3
11246: PUSH
11247: LD_VAR 0 3
11251: PUSH
11252: LD_VAR 0 2
11256: ADD
11257: ST_TO_ADDR
// end ;
11258: GO 11154
11260: POP
11261: POP
// repeat wait ( 0 0$1 ) ;
11262: LD_INT 35
11264: PPUSH
11265: CALL_OW 67
// for un in tmp do
11269: LD_ADDR_VAR 0 2
11273: PUSH
11274: LD_VAR 0 3
11278: PUSH
11279: FOR_IN
11280: IFFALSE 11354
// begin if IsDead ( un ) then
11282: LD_VAR 0 2
11286: PPUSH
11287: CALL_OW 301
11291: IFFALSE 11311
// begin tmp := tmp diff un ;
11293: LD_ADDR_VAR 0 3
11297: PUSH
11298: LD_VAR 0 3
11302: PUSH
11303: LD_VAR 0 2
11307: DIFF
11308: ST_TO_ADDR
// continue ;
11309: GO 11279
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
11311: LD_VAR 0 2
11315: PPUSH
11316: LD_INT 3
11318: PUSH
11319: LD_INT 22
11321: PUSH
11322: LD_INT 0
11324: PUSH
11325: EMPTY
11326: LIST
11327: LIST
11328: PUSH
11329: EMPTY
11330: LIST
11331: LIST
11332: PPUSH
11333: CALL_OW 69
11337: PPUSH
11338: LD_VAR 0 2
11342: PPUSH
11343: CALL_OW 74
11347: PPUSH
11348: CALL_OW 115
// end ;
11352: GO 11279
11354: POP
11355: POP
// until not tmp ;
11356: LD_VAR 0 3
11360: NOT
11361: IFFALSE 11262
// end ;
11363: PPOPN 3
11365: END
// every 0 0$1 trigger StreamModeActive and sTroll do
11366: LD_EXP 44
11370: PUSH
11371: LD_EXP 69
11375: AND
11376: IFFALSE 11430
11378: GO 11380
11380: DISABLE
// begin ToLua ( displayTroll(); ) ;
11381: LD_STRING displayTroll();
11383: PPUSH
11384: CALL_OW 559
// wait ( 3 3$00 ) ;
11388: LD_INT 6300
11390: PPUSH
11391: CALL_OW 67
// ToLua ( hideTroll(); ) ;
11395: LD_STRING hideTroll();
11397: PPUSH
11398: CALL_OW 559
// wait ( 1 1$00 ) ;
11402: LD_INT 2100
11404: PPUSH
11405: CALL_OW 67
// ToLua ( displayTroll(); ) ;
11409: LD_STRING displayTroll();
11411: PPUSH
11412: CALL_OW 559
// wait ( 1 1$00 ) ;
11416: LD_INT 2100
11418: PPUSH
11419: CALL_OW 67
// ToLua ( hideTroll(); ) ;
11423: LD_STRING hideTroll();
11425: PPUSH
11426: CALL_OW 559
// end ;
11430: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
11431: LD_EXP 44
11435: PUSH
11436: LD_EXP 70
11440: AND
11441: IFFALSE 11504
11443: GO 11445
11445: DISABLE
11446: LD_INT 0
11448: PPUSH
// begin p := 0 ;
11449: LD_ADDR_VAR 0 1
11453: PUSH
11454: LD_INT 0
11456: ST_TO_ADDR
// repeat game_speed := 1 ;
11457: LD_ADDR_OWVAR 65
11461: PUSH
11462: LD_INT 1
11464: ST_TO_ADDR
// wait ( 0 0$1 ) ;
11465: LD_INT 35
11467: PPUSH
11468: CALL_OW 67
// p := p + 1 ;
11472: LD_ADDR_VAR 0 1
11476: PUSH
11477: LD_VAR 0 1
11481: PUSH
11482: LD_INT 1
11484: PLUS
11485: ST_TO_ADDR
// until p >= 60 ;
11486: LD_VAR 0 1
11490: PUSH
11491: LD_INT 60
11493: GREATEREQUAL
11494: IFFALSE 11457
// game_speed := 4 ;
11496: LD_ADDR_OWVAR 65
11500: PUSH
11501: LD_INT 4
11503: ST_TO_ADDR
// end ;
11504: PPOPN 1
11506: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
11507: LD_EXP 44
11511: PUSH
11512: LD_EXP 71
11516: AND
11517: IFFALSE 11663
11519: GO 11521
11521: DISABLE
11522: LD_INT 0
11524: PPUSH
11525: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
11526: LD_ADDR_VAR 0 1
11530: PUSH
11531: LD_INT 22
11533: PUSH
11534: LD_OWVAR 2
11538: PUSH
11539: EMPTY
11540: LIST
11541: LIST
11542: PUSH
11543: LD_INT 2
11545: PUSH
11546: LD_INT 30
11548: PUSH
11549: LD_INT 0
11551: PUSH
11552: EMPTY
11553: LIST
11554: LIST
11555: PUSH
11556: LD_INT 30
11558: PUSH
11559: LD_INT 1
11561: PUSH
11562: EMPTY
11563: LIST
11564: LIST
11565: PUSH
11566: EMPTY
11567: LIST
11568: LIST
11569: LIST
11570: PUSH
11571: EMPTY
11572: LIST
11573: LIST
11574: PPUSH
11575: CALL_OW 69
11579: ST_TO_ADDR
// if not depot then
11580: LD_VAR 0 1
11584: NOT
11585: IFFALSE 11589
// exit ;
11587: GO 11663
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
11589: LD_ADDR_VAR 0 2
11593: PUSH
11594: LD_VAR 0 1
11598: PUSH
11599: LD_INT 1
11601: PPUSH
11602: LD_VAR 0 1
11606: PPUSH
11607: CALL_OW 12
11611: ARRAY
11612: PPUSH
11613: CALL_OW 274
11617: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
11618: LD_VAR 0 2
11622: PPUSH
11623: LD_INT 1
11625: PPUSH
11626: LD_INT 0
11628: PPUSH
11629: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
11633: LD_VAR 0 2
11637: PPUSH
11638: LD_INT 2
11640: PPUSH
11641: LD_INT 0
11643: PPUSH
11644: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
11648: LD_VAR 0 2
11652: PPUSH
11653: LD_INT 3
11655: PPUSH
11656: LD_INT 0
11658: PPUSH
11659: CALL_OW 277
// end ;
11663: PPOPN 2
11665: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
11666: LD_EXP 44
11670: PUSH
11671: LD_EXP 72
11675: AND
11676: IFFALSE 11773
11678: GO 11680
11680: DISABLE
11681: LD_INT 0
11683: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
11684: LD_ADDR_VAR 0 1
11688: PUSH
11689: LD_INT 22
11691: PUSH
11692: LD_OWVAR 2
11696: PUSH
11697: EMPTY
11698: LIST
11699: LIST
11700: PUSH
11701: LD_INT 21
11703: PUSH
11704: LD_INT 1
11706: PUSH
11707: EMPTY
11708: LIST
11709: LIST
11710: PUSH
11711: LD_INT 3
11713: PUSH
11714: LD_INT 23
11716: PUSH
11717: LD_INT 0
11719: PUSH
11720: EMPTY
11721: LIST
11722: LIST
11723: PUSH
11724: EMPTY
11725: LIST
11726: LIST
11727: PUSH
11728: EMPTY
11729: LIST
11730: LIST
11731: LIST
11732: PPUSH
11733: CALL_OW 69
11737: ST_TO_ADDR
// if not tmp then
11738: LD_VAR 0 1
11742: NOT
11743: IFFALSE 11747
// exit ;
11745: GO 11773
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
11747: LD_VAR 0 1
11751: PUSH
11752: LD_INT 1
11754: PPUSH
11755: LD_VAR 0 1
11759: PPUSH
11760: CALL_OW 12
11764: ARRAY
11765: PPUSH
11766: LD_INT 200
11768: PPUSH
11769: CALL_OW 234
// end ;
11773: PPOPN 1
11775: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
11776: LD_EXP 44
11780: PUSH
11781: LD_EXP 73
11785: AND
11786: IFFALSE 11865
11788: GO 11790
11790: DISABLE
11791: LD_INT 0
11793: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
11794: LD_ADDR_VAR 0 1
11798: PUSH
11799: LD_INT 22
11801: PUSH
11802: LD_OWVAR 2
11806: PUSH
11807: EMPTY
11808: LIST
11809: LIST
11810: PUSH
11811: LD_INT 21
11813: PUSH
11814: LD_INT 2
11816: PUSH
11817: EMPTY
11818: LIST
11819: LIST
11820: PUSH
11821: EMPTY
11822: LIST
11823: LIST
11824: PPUSH
11825: CALL_OW 69
11829: ST_TO_ADDR
// if not tmp then
11830: LD_VAR 0 1
11834: NOT
11835: IFFALSE 11839
// exit ;
11837: GO 11865
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
11839: LD_VAR 0 1
11843: PUSH
11844: LD_INT 1
11846: PPUSH
11847: LD_VAR 0 1
11851: PPUSH
11852: CALL_OW 12
11856: ARRAY
11857: PPUSH
11858: LD_INT 60
11860: PPUSH
11861: CALL_OW 234
// end ;
11865: PPOPN 1
11867: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
11868: LD_EXP 44
11872: PUSH
11873: LD_EXP 74
11877: AND
11878: IFFALSE 11977
11880: GO 11882
11882: DISABLE
11883: LD_INT 0
11885: PPUSH
11886: PPUSH
// begin enable ;
11887: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
11888: LD_ADDR_VAR 0 1
11892: PUSH
11893: LD_INT 22
11895: PUSH
11896: LD_OWVAR 2
11900: PUSH
11901: EMPTY
11902: LIST
11903: LIST
11904: PUSH
11905: LD_INT 61
11907: PUSH
11908: EMPTY
11909: LIST
11910: PUSH
11911: LD_INT 33
11913: PUSH
11914: LD_INT 2
11916: PUSH
11917: EMPTY
11918: LIST
11919: LIST
11920: PUSH
11921: EMPTY
11922: LIST
11923: LIST
11924: LIST
11925: PPUSH
11926: CALL_OW 69
11930: ST_TO_ADDR
// if not tmp then
11931: LD_VAR 0 1
11935: NOT
11936: IFFALSE 11940
// exit ;
11938: GO 11977
// for i in tmp do
11940: LD_ADDR_VAR 0 2
11944: PUSH
11945: LD_VAR 0 1
11949: PUSH
11950: FOR_IN
11951: IFFALSE 11975
// if IsControledBy ( i ) then
11953: LD_VAR 0 2
11957: PPUSH
11958: CALL_OW 312
11962: IFFALSE 11973
// ComUnlink ( i ) ;
11964: LD_VAR 0 2
11968: PPUSH
11969: CALL_OW 136
11973: GO 11950
11975: POP
11976: POP
// end ;
11977: PPOPN 2
11979: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
11980: LD_EXP 44
11984: PUSH
11985: LD_EXP 75
11989: AND
11990: IFFALSE 12130
11992: GO 11994
11994: DISABLE
11995: LD_INT 0
11997: PPUSH
11998: PPUSH
// begin ToLua ( displayPowell(); ) ;
11999: LD_STRING displayPowell();
12001: PPUSH
12002: CALL_OW 559
// uc_side := 0 ;
12006: LD_ADDR_OWVAR 20
12010: PUSH
12011: LD_INT 0
12013: ST_TO_ADDR
// uc_nation := 2 ;
12014: LD_ADDR_OWVAR 21
12018: PUSH
12019: LD_INT 2
12021: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
12022: LD_ADDR_OWVAR 37
12026: PUSH
12027: LD_INT 14
12029: ST_TO_ADDR
// vc_engine := engine_siberite ;
12030: LD_ADDR_OWVAR 39
12034: PUSH
12035: LD_INT 3
12037: ST_TO_ADDR
// vc_control := control_apeman ;
12038: LD_ADDR_OWVAR 38
12042: PUSH
12043: LD_INT 5
12045: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
12046: LD_ADDR_OWVAR 40
12050: PUSH
12051: LD_INT 29
12053: ST_TO_ADDR
// un := CreateVehicle ;
12054: LD_ADDR_VAR 0 2
12058: PUSH
12059: CALL_OW 45
12063: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
12064: LD_VAR 0 2
12068: PPUSH
12069: LD_INT 1
12071: PPUSH
12072: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
12076: LD_INT 35
12078: PPUSH
12079: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
12083: LD_VAR 0 2
12087: PPUSH
12088: LD_INT 22
12090: PUSH
12091: LD_OWVAR 2
12095: PUSH
12096: EMPTY
12097: LIST
12098: LIST
12099: PPUSH
12100: CALL_OW 69
12104: PPUSH
12105: LD_VAR 0 2
12109: PPUSH
12110: CALL_OW 74
12114: PPUSH
12115: CALL_OW 115
// until IsDead ( un ) ;
12119: LD_VAR 0 2
12123: PPUSH
12124: CALL_OW 301
12128: IFFALSE 12076
// end ;
12130: PPOPN 2
12132: END
// every 0 0$1 trigger StreamModeActive and sStu do
12133: LD_EXP 44
12137: PUSH
12138: LD_EXP 83
12142: AND
12143: IFFALSE 12159
12145: GO 12147
12147: DISABLE
// begin ToLua ( displayStucuk(); ) ;
12148: LD_STRING displayStucuk();
12150: PPUSH
12151: CALL_OW 559
// ResetFog ;
12155: CALL_OW 335
// end ;
12159: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
12160: LD_EXP 44
12164: PUSH
12165: LD_EXP 76
12169: AND
12170: IFFALSE 12311
12172: GO 12174
12174: DISABLE
12175: LD_INT 0
12177: PPUSH
12178: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
12179: LD_ADDR_VAR 0 2
12183: PUSH
12184: LD_INT 22
12186: PUSH
12187: LD_OWVAR 2
12191: PUSH
12192: EMPTY
12193: LIST
12194: LIST
12195: PUSH
12196: LD_INT 21
12198: PUSH
12199: LD_INT 1
12201: PUSH
12202: EMPTY
12203: LIST
12204: LIST
12205: PUSH
12206: EMPTY
12207: LIST
12208: LIST
12209: PPUSH
12210: CALL_OW 69
12214: ST_TO_ADDR
// if not tmp then
12215: LD_VAR 0 2
12219: NOT
12220: IFFALSE 12224
// exit ;
12222: GO 12311
// un := tmp [ rand ( 1 , tmp ) ] ;
12224: LD_ADDR_VAR 0 1
12228: PUSH
12229: LD_VAR 0 2
12233: PUSH
12234: LD_INT 1
12236: PPUSH
12237: LD_VAR 0 2
12241: PPUSH
12242: CALL_OW 12
12246: ARRAY
12247: ST_TO_ADDR
// SetSide ( un , 0 ) ;
12248: LD_VAR 0 1
12252: PPUSH
12253: LD_INT 0
12255: PPUSH
12256: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
12260: LD_VAR 0 1
12264: PPUSH
12265: LD_OWVAR 3
12269: PUSH
12270: LD_VAR 0 1
12274: DIFF
12275: PPUSH
12276: LD_VAR 0 1
12280: PPUSH
12281: CALL_OW 74
12285: PPUSH
12286: CALL_OW 115
// wait ( 0 0$20 ) ;
12290: LD_INT 700
12292: PPUSH
12293: CALL_OW 67
// SetSide ( un , your_side ) ;
12297: LD_VAR 0 1
12301: PPUSH
12302: LD_OWVAR 2
12306: PPUSH
12307: CALL_OW 235
// end ;
12311: PPOPN 2
12313: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
12314: LD_EXP 44
12318: PUSH
12319: LD_EXP 77
12323: AND
12324: IFFALSE 12430
12326: GO 12328
12328: DISABLE
12329: LD_INT 0
12331: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
12332: LD_ADDR_VAR 0 1
12336: PUSH
12337: LD_INT 22
12339: PUSH
12340: LD_OWVAR 2
12344: PUSH
12345: EMPTY
12346: LIST
12347: LIST
12348: PUSH
12349: LD_INT 2
12351: PUSH
12352: LD_INT 30
12354: PUSH
12355: LD_INT 0
12357: PUSH
12358: EMPTY
12359: LIST
12360: LIST
12361: PUSH
12362: LD_INT 30
12364: PUSH
12365: LD_INT 1
12367: PUSH
12368: EMPTY
12369: LIST
12370: LIST
12371: PUSH
12372: EMPTY
12373: LIST
12374: LIST
12375: LIST
12376: PUSH
12377: EMPTY
12378: LIST
12379: LIST
12380: PPUSH
12381: CALL_OW 69
12385: ST_TO_ADDR
// if not depot then
12386: LD_VAR 0 1
12390: NOT
12391: IFFALSE 12395
// exit ;
12393: GO 12430
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
12395: LD_VAR 0 1
12399: PUSH
12400: LD_INT 1
12402: ARRAY
12403: PPUSH
12404: CALL_OW 250
12408: PPUSH
12409: LD_VAR 0 1
12413: PUSH
12414: LD_INT 1
12416: ARRAY
12417: PPUSH
12418: CALL_OW 251
12422: PPUSH
12423: LD_INT 70
12425: PPUSH
12426: CALL_OW 495
// end ;
12430: PPOPN 1
12432: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
12433: LD_EXP 44
12437: PUSH
12438: LD_EXP 78
12442: AND
12443: IFFALSE 12654
12445: GO 12447
12447: DISABLE
12448: LD_INT 0
12450: PPUSH
12451: PPUSH
12452: PPUSH
12453: PPUSH
12454: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
12455: LD_ADDR_VAR 0 5
12459: PUSH
12460: LD_INT 22
12462: PUSH
12463: LD_OWVAR 2
12467: PUSH
12468: EMPTY
12469: LIST
12470: LIST
12471: PUSH
12472: LD_INT 21
12474: PUSH
12475: LD_INT 1
12477: PUSH
12478: EMPTY
12479: LIST
12480: LIST
12481: PUSH
12482: EMPTY
12483: LIST
12484: LIST
12485: PPUSH
12486: CALL_OW 69
12490: ST_TO_ADDR
// if not tmp then
12491: LD_VAR 0 5
12495: NOT
12496: IFFALSE 12500
// exit ;
12498: GO 12654
// for i in tmp do
12500: LD_ADDR_VAR 0 1
12504: PUSH
12505: LD_VAR 0 5
12509: PUSH
12510: FOR_IN
12511: IFFALSE 12652
// begin d := rand ( 0 , 5 ) ;
12513: LD_ADDR_VAR 0 4
12517: PUSH
12518: LD_INT 0
12520: PPUSH
12521: LD_INT 5
12523: PPUSH
12524: CALL_OW 12
12528: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
12529: LD_ADDR_VAR 0 2
12533: PUSH
12534: LD_VAR 0 1
12538: PPUSH
12539: CALL_OW 250
12543: PPUSH
12544: LD_VAR 0 4
12548: PPUSH
12549: LD_INT 3
12551: PPUSH
12552: LD_INT 12
12554: PPUSH
12555: CALL_OW 12
12559: PPUSH
12560: CALL_OW 272
12564: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
12565: LD_ADDR_VAR 0 3
12569: PUSH
12570: LD_VAR 0 1
12574: PPUSH
12575: CALL_OW 251
12579: PPUSH
12580: LD_VAR 0 4
12584: PPUSH
12585: LD_INT 3
12587: PPUSH
12588: LD_INT 12
12590: PPUSH
12591: CALL_OW 12
12595: PPUSH
12596: CALL_OW 273
12600: ST_TO_ADDR
// if ValidHex ( x , y ) then
12601: LD_VAR 0 2
12605: PPUSH
12606: LD_VAR 0 3
12610: PPUSH
12611: CALL_OW 488
12615: IFFALSE 12650
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
12617: LD_VAR 0 1
12621: PPUSH
12622: LD_VAR 0 2
12626: PPUSH
12627: LD_VAR 0 3
12631: PPUSH
12632: LD_INT 3
12634: PPUSH
12635: LD_INT 6
12637: PPUSH
12638: CALL_OW 12
12642: PPUSH
12643: LD_INT 1
12645: PPUSH
12646: CALL_OW 483
// end ;
12650: GO 12510
12652: POP
12653: POP
// end ;
12654: PPOPN 5
12656: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
12657: LD_EXP 44
12661: PUSH
12662: LD_EXP 79
12666: AND
12667: IFFALSE 12761
12669: GO 12671
12671: DISABLE
12672: LD_INT 0
12674: PPUSH
12675: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
12676: LD_ADDR_VAR 0 2
12680: PUSH
12681: LD_INT 22
12683: PUSH
12684: LD_OWVAR 2
12688: PUSH
12689: EMPTY
12690: LIST
12691: LIST
12692: PUSH
12693: LD_INT 32
12695: PUSH
12696: LD_INT 1
12698: PUSH
12699: EMPTY
12700: LIST
12701: LIST
12702: PUSH
12703: LD_INT 21
12705: PUSH
12706: LD_INT 2
12708: PUSH
12709: EMPTY
12710: LIST
12711: LIST
12712: PUSH
12713: EMPTY
12714: LIST
12715: LIST
12716: LIST
12717: PPUSH
12718: CALL_OW 69
12722: ST_TO_ADDR
// if not tmp then
12723: LD_VAR 0 2
12727: NOT
12728: IFFALSE 12732
// exit ;
12730: GO 12761
// for i in tmp do
12732: LD_ADDR_VAR 0 1
12736: PUSH
12737: LD_VAR 0 2
12741: PUSH
12742: FOR_IN
12743: IFFALSE 12759
// SetFuel ( i , 0 ) ;
12745: LD_VAR 0 1
12749: PPUSH
12750: LD_INT 0
12752: PPUSH
12753: CALL_OW 240
12757: GO 12742
12759: POP
12760: POP
// end ;
12761: PPOPN 2
12763: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
12764: LD_EXP 44
12768: PUSH
12769: LD_EXP 80
12773: AND
12774: IFFALSE 12840
12776: GO 12778
12778: DISABLE
12779: LD_INT 0
12781: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
12782: LD_ADDR_VAR 0 1
12786: PUSH
12787: LD_INT 22
12789: PUSH
12790: LD_OWVAR 2
12794: PUSH
12795: EMPTY
12796: LIST
12797: LIST
12798: PUSH
12799: LD_INT 30
12801: PUSH
12802: LD_INT 29
12804: PUSH
12805: EMPTY
12806: LIST
12807: LIST
12808: PUSH
12809: EMPTY
12810: LIST
12811: LIST
12812: PPUSH
12813: CALL_OW 69
12817: ST_TO_ADDR
// if not tmp then
12818: LD_VAR 0 1
12822: NOT
12823: IFFALSE 12827
// exit ;
12825: GO 12840
// DestroyUnit ( tmp [ 1 ] ) ;
12827: LD_VAR 0 1
12831: PUSH
12832: LD_INT 1
12834: ARRAY
12835: PPUSH
12836: CALL_OW 65
// end ;
12840: PPOPN 1
12842: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
12843: LD_EXP 44
12847: PUSH
12848: LD_EXP 82
12852: AND
12853: IFFALSE 12982
12855: GO 12857
12857: DISABLE
12858: LD_INT 0
12860: PPUSH
// begin uc_side := 0 ;
12861: LD_ADDR_OWVAR 20
12865: PUSH
12866: LD_INT 0
12868: ST_TO_ADDR
// uc_nation := nation_arabian ;
12869: LD_ADDR_OWVAR 21
12873: PUSH
12874: LD_INT 2
12876: ST_TO_ADDR
// hc_gallery :=  ;
12877: LD_ADDR_OWVAR 33
12881: PUSH
12882: LD_STRING 
12884: ST_TO_ADDR
// hc_name :=  ;
12885: LD_ADDR_OWVAR 26
12889: PUSH
12890: LD_STRING 
12892: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
12893: LD_INT 1
12895: PPUSH
12896: LD_INT 11
12898: PPUSH
12899: LD_INT 10
12901: PPUSH
12902: CALL_OW 380
// un := CreateHuman ;
12906: LD_ADDR_VAR 0 1
12910: PUSH
12911: CALL_OW 44
12915: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
12916: LD_VAR 0 1
12920: PPUSH
12921: LD_INT 1
12923: PPUSH
12924: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
12928: LD_INT 35
12930: PPUSH
12931: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
12935: LD_VAR 0 1
12939: PPUSH
12940: LD_INT 22
12942: PUSH
12943: LD_OWVAR 2
12947: PUSH
12948: EMPTY
12949: LIST
12950: LIST
12951: PPUSH
12952: CALL_OW 69
12956: PPUSH
12957: LD_VAR 0 1
12961: PPUSH
12962: CALL_OW 74
12966: PPUSH
12967: CALL_OW 115
// until IsDead ( un ) ;
12971: LD_VAR 0 1
12975: PPUSH
12976: CALL_OW 301
12980: IFFALSE 12928
// end ;
12982: PPOPN 1
12984: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
12985: LD_EXP 44
12989: PUSH
12990: LD_EXP 84
12994: AND
12995: IFFALSE 13007
12997: GO 12999
12999: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
13000: LD_STRING earthquake(getX(game), 0, 32)
13002: PPUSH
13003: CALL_OW 559
13007: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
13008: LD_EXP 44
13012: PUSH
13013: LD_EXP 85
13017: AND
13018: IFFALSE 13109
13020: GO 13022
13022: DISABLE
13023: LD_INT 0
13025: PPUSH
// begin enable ;
13026: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
13027: LD_ADDR_VAR 0 1
13031: PUSH
13032: LD_INT 22
13034: PUSH
13035: LD_OWVAR 2
13039: PUSH
13040: EMPTY
13041: LIST
13042: LIST
13043: PUSH
13044: LD_INT 21
13046: PUSH
13047: LD_INT 2
13049: PUSH
13050: EMPTY
13051: LIST
13052: LIST
13053: PUSH
13054: LD_INT 33
13056: PUSH
13057: LD_INT 3
13059: PUSH
13060: EMPTY
13061: LIST
13062: LIST
13063: PUSH
13064: EMPTY
13065: LIST
13066: LIST
13067: LIST
13068: PPUSH
13069: CALL_OW 69
13073: ST_TO_ADDR
// if not tmp then
13074: LD_VAR 0 1
13078: NOT
13079: IFFALSE 13083
// exit ;
13081: GO 13109
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
13083: LD_VAR 0 1
13087: PUSH
13088: LD_INT 1
13090: PPUSH
13091: LD_VAR 0 1
13095: PPUSH
13096: CALL_OW 12
13100: ARRAY
13101: PPUSH
13102: LD_INT 1
13104: PPUSH
13105: CALL_OW 234
// end ;
13109: PPOPN 1
13111: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
13112: LD_EXP 44
13116: PUSH
13117: LD_EXP 86
13121: AND
13122: IFFALSE 13263
13124: GO 13126
13126: DISABLE
13127: LD_INT 0
13129: PPUSH
13130: PPUSH
13131: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
13132: LD_ADDR_VAR 0 3
13136: PUSH
13137: LD_INT 22
13139: PUSH
13140: LD_OWVAR 2
13144: PUSH
13145: EMPTY
13146: LIST
13147: LIST
13148: PUSH
13149: LD_INT 25
13151: PUSH
13152: LD_INT 1
13154: PUSH
13155: EMPTY
13156: LIST
13157: LIST
13158: PUSH
13159: EMPTY
13160: LIST
13161: LIST
13162: PPUSH
13163: CALL_OW 69
13167: ST_TO_ADDR
// if not tmp then
13168: LD_VAR 0 3
13172: NOT
13173: IFFALSE 13177
// exit ;
13175: GO 13263
// un := tmp [ rand ( 1 , tmp ) ] ;
13177: LD_ADDR_VAR 0 2
13181: PUSH
13182: LD_VAR 0 3
13186: PUSH
13187: LD_INT 1
13189: PPUSH
13190: LD_VAR 0 3
13194: PPUSH
13195: CALL_OW 12
13199: ARRAY
13200: ST_TO_ADDR
// if Crawls ( un ) then
13201: LD_VAR 0 2
13205: PPUSH
13206: CALL_OW 318
13210: IFFALSE 13221
// ComWalk ( un ) ;
13212: LD_VAR 0 2
13216: PPUSH
13217: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
13221: LD_VAR 0 2
13225: PPUSH
13226: LD_INT 9
13228: PPUSH
13229: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
13233: LD_INT 28
13235: PPUSH
13236: LD_OWVAR 2
13240: PPUSH
13241: LD_INT 2
13243: PPUSH
13244: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
13248: LD_INT 29
13250: PPUSH
13251: LD_OWVAR 2
13255: PPUSH
13256: LD_INT 2
13258: PPUSH
13259: CALL_OW 322
// end ;
13263: PPOPN 3
13265: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
13266: LD_EXP 44
13270: PUSH
13271: LD_EXP 87
13275: AND
13276: IFFALSE 13387
13278: GO 13280
13280: DISABLE
13281: LD_INT 0
13283: PPUSH
13284: PPUSH
13285: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
13286: LD_ADDR_VAR 0 3
13290: PUSH
13291: LD_INT 22
13293: PUSH
13294: LD_OWVAR 2
13298: PUSH
13299: EMPTY
13300: LIST
13301: LIST
13302: PUSH
13303: LD_INT 25
13305: PUSH
13306: LD_INT 1
13308: PUSH
13309: EMPTY
13310: LIST
13311: LIST
13312: PUSH
13313: EMPTY
13314: LIST
13315: LIST
13316: PPUSH
13317: CALL_OW 69
13321: ST_TO_ADDR
// if not tmp then
13322: LD_VAR 0 3
13326: NOT
13327: IFFALSE 13331
// exit ;
13329: GO 13387
// un := tmp [ rand ( 1 , tmp ) ] ;
13331: LD_ADDR_VAR 0 2
13335: PUSH
13336: LD_VAR 0 3
13340: PUSH
13341: LD_INT 1
13343: PPUSH
13344: LD_VAR 0 3
13348: PPUSH
13349: CALL_OW 12
13353: ARRAY
13354: ST_TO_ADDR
// if Crawls ( un ) then
13355: LD_VAR 0 2
13359: PPUSH
13360: CALL_OW 318
13364: IFFALSE 13375
// ComWalk ( un ) ;
13366: LD_VAR 0 2
13370: PPUSH
13371: CALL_OW 138
// SetClass ( un , class_mortar ) ;
13375: LD_VAR 0 2
13379: PPUSH
13380: LD_INT 8
13382: PPUSH
13383: CALL_OW 336
// end ;
13387: PPOPN 3
13389: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
13390: LD_EXP 44
13394: PUSH
13395: LD_EXP 88
13399: AND
13400: IFFALSE 13544
13402: GO 13404
13404: DISABLE
13405: LD_INT 0
13407: PPUSH
13408: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
13409: LD_ADDR_VAR 0 2
13413: PUSH
13414: LD_INT 22
13416: PUSH
13417: LD_OWVAR 2
13421: PUSH
13422: EMPTY
13423: LIST
13424: LIST
13425: PUSH
13426: LD_INT 21
13428: PUSH
13429: LD_INT 2
13431: PUSH
13432: EMPTY
13433: LIST
13434: LIST
13435: PUSH
13436: LD_INT 2
13438: PUSH
13439: LD_INT 34
13441: PUSH
13442: LD_INT 12
13444: PUSH
13445: EMPTY
13446: LIST
13447: LIST
13448: PUSH
13449: LD_INT 34
13451: PUSH
13452: LD_INT 51
13454: PUSH
13455: EMPTY
13456: LIST
13457: LIST
13458: PUSH
13459: LD_INT 34
13461: PUSH
13462: LD_INT 32
13464: PUSH
13465: EMPTY
13466: LIST
13467: LIST
13468: PUSH
13469: EMPTY
13470: LIST
13471: LIST
13472: LIST
13473: LIST
13474: PUSH
13475: EMPTY
13476: LIST
13477: LIST
13478: LIST
13479: PPUSH
13480: CALL_OW 69
13484: ST_TO_ADDR
// if not tmp then
13485: LD_VAR 0 2
13489: NOT
13490: IFFALSE 13494
// exit ;
13492: GO 13544
// for i in tmp do
13494: LD_ADDR_VAR 0 1
13498: PUSH
13499: LD_VAR 0 2
13503: PUSH
13504: FOR_IN
13505: IFFALSE 13542
// if GetCargo ( i , mat_artifact ) = 0 then
13507: LD_VAR 0 1
13511: PPUSH
13512: LD_INT 4
13514: PPUSH
13515: CALL_OW 289
13519: PUSH
13520: LD_INT 0
13522: EQUAL
13523: IFFALSE 13540
// SetCargo ( i , mat_siberit , 100 ) ;
13525: LD_VAR 0 1
13529: PPUSH
13530: LD_INT 3
13532: PPUSH
13533: LD_INT 100
13535: PPUSH
13536: CALL_OW 290
13540: GO 13504
13542: POP
13543: POP
// end ;
13544: PPOPN 2
13546: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
13547: LD_EXP 44
13551: PUSH
13552: LD_EXP 89
13556: AND
13557: IFFALSE 13710
13559: GO 13561
13561: DISABLE
13562: LD_INT 0
13564: PPUSH
13565: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
13566: LD_ADDR_VAR 0 2
13570: PUSH
13571: LD_INT 22
13573: PUSH
13574: LD_OWVAR 2
13578: PUSH
13579: EMPTY
13580: LIST
13581: LIST
13582: PPUSH
13583: CALL_OW 69
13587: ST_TO_ADDR
// if not tmp then
13588: LD_VAR 0 2
13592: NOT
13593: IFFALSE 13597
// exit ;
13595: GO 13710
// for i := 1 to 2 do
13597: LD_ADDR_VAR 0 1
13601: PUSH
13602: DOUBLE
13603: LD_INT 1
13605: DEC
13606: ST_TO_ADDR
13607: LD_INT 2
13609: PUSH
13610: FOR_TO
13611: IFFALSE 13708
// begin uc_side := your_side ;
13613: LD_ADDR_OWVAR 20
13617: PUSH
13618: LD_OWVAR 2
13622: ST_TO_ADDR
// uc_nation := nation_american ;
13623: LD_ADDR_OWVAR 21
13627: PUSH
13628: LD_INT 1
13630: ST_TO_ADDR
// vc_chassis := us_morphling ;
13631: LD_ADDR_OWVAR 37
13635: PUSH
13636: LD_INT 5
13638: ST_TO_ADDR
// vc_engine := engine_siberite ;
13639: LD_ADDR_OWVAR 39
13643: PUSH
13644: LD_INT 3
13646: ST_TO_ADDR
// vc_control := control_computer ;
13647: LD_ADDR_OWVAR 38
13651: PUSH
13652: LD_INT 3
13654: ST_TO_ADDR
// vc_weapon := us_double_laser ;
13655: LD_ADDR_OWVAR 40
13659: PUSH
13660: LD_INT 10
13662: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
13663: CALL_OW 45
13667: PPUSH
13668: LD_VAR 0 2
13672: PUSH
13673: LD_INT 1
13675: ARRAY
13676: PPUSH
13677: CALL_OW 250
13681: PPUSH
13682: LD_VAR 0 2
13686: PUSH
13687: LD_INT 1
13689: ARRAY
13690: PPUSH
13691: CALL_OW 251
13695: PPUSH
13696: LD_INT 12
13698: PPUSH
13699: LD_INT 1
13701: PPUSH
13702: CALL_OW 50
// end ;
13706: GO 13610
13708: POP
13709: POP
// end ;
13710: PPOPN 2
13712: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
13713: LD_EXP 44
13717: PUSH
13718: LD_EXP 90
13722: AND
13723: IFFALSE 13945
13725: GO 13727
13727: DISABLE
13728: LD_INT 0
13730: PPUSH
13731: PPUSH
13732: PPUSH
13733: PPUSH
13734: PPUSH
13735: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
13736: LD_ADDR_VAR 0 6
13740: PUSH
13741: LD_INT 22
13743: PUSH
13744: LD_OWVAR 2
13748: PUSH
13749: EMPTY
13750: LIST
13751: LIST
13752: PUSH
13753: LD_INT 21
13755: PUSH
13756: LD_INT 1
13758: PUSH
13759: EMPTY
13760: LIST
13761: LIST
13762: PUSH
13763: LD_INT 3
13765: PUSH
13766: LD_INT 23
13768: PUSH
13769: LD_INT 0
13771: PUSH
13772: EMPTY
13773: LIST
13774: LIST
13775: PUSH
13776: EMPTY
13777: LIST
13778: LIST
13779: PUSH
13780: EMPTY
13781: LIST
13782: LIST
13783: LIST
13784: PPUSH
13785: CALL_OW 69
13789: ST_TO_ADDR
// if not tmp then
13790: LD_VAR 0 6
13794: NOT
13795: IFFALSE 13799
// exit ;
13797: GO 13945
// s1 := rand ( 1 , 4 ) ;
13799: LD_ADDR_VAR 0 2
13803: PUSH
13804: LD_INT 1
13806: PPUSH
13807: LD_INT 4
13809: PPUSH
13810: CALL_OW 12
13814: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
13815: LD_ADDR_VAR 0 4
13819: PUSH
13820: LD_VAR 0 6
13824: PUSH
13825: LD_INT 1
13827: ARRAY
13828: PPUSH
13829: LD_VAR 0 2
13833: PPUSH
13834: CALL_OW 259
13838: ST_TO_ADDR
// if s1 = 1 then
13839: LD_VAR 0 2
13843: PUSH
13844: LD_INT 1
13846: EQUAL
13847: IFFALSE 13867
// s2 := rand ( 2 , 4 ) else
13849: LD_ADDR_VAR 0 3
13853: PUSH
13854: LD_INT 2
13856: PPUSH
13857: LD_INT 4
13859: PPUSH
13860: CALL_OW 12
13864: ST_TO_ADDR
13865: GO 13875
// s2 := 1 ;
13867: LD_ADDR_VAR 0 3
13871: PUSH
13872: LD_INT 1
13874: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
13875: LD_ADDR_VAR 0 5
13879: PUSH
13880: LD_VAR 0 6
13884: PUSH
13885: LD_INT 1
13887: ARRAY
13888: PPUSH
13889: LD_VAR 0 3
13893: PPUSH
13894: CALL_OW 259
13898: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
13899: LD_VAR 0 6
13903: PUSH
13904: LD_INT 1
13906: ARRAY
13907: PPUSH
13908: LD_VAR 0 2
13912: PPUSH
13913: LD_VAR 0 5
13917: PPUSH
13918: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
13922: LD_VAR 0 6
13926: PUSH
13927: LD_INT 1
13929: ARRAY
13930: PPUSH
13931: LD_VAR 0 3
13935: PPUSH
13936: LD_VAR 0 4
13940: PPUSH
13941: CALL_OW 237
// end ;
13945: PPOPN 6
13947: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
13948: LD_EXP 44
13952: PUSH
13953: LD_EXP 91
13957: AND
13958: IFFALSE 14037
13960: GO 13962
13962: DISABLE
13963: LD_INT 0
13965: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
13966: LD_ADDR_VAR 0 1
13970: PUSH
13971: LD_INT 22
13973: PUSH
13974: LD_OWVAR 2
13978: PUSH
13979: EMPTY
13980: LIST
13981: LIST
13982: PUSH
13983: LD_INT 30
13985: PUSH
13986: LD_INT 3
13988: PUSH
13989: EMPTY
13990: LIST
13991: LIST
13992: PUSH
13993: EMPTY
13994: LIST
13995: LIST
13996: PPUSH
13997: CALL_OW 69
14001: ST_TO_ADDR
// if not tmp then
14002: LD_VAR 0 1
14006: NOT
14007: IFFALSE 14011
// exit ;
14009: GO 14037
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
14011: LD_VAR 0 1
14015: PUSH
14016: LD_INT 1
14018: PPUSH
14019: LD_VAR 0 1
14023: PPUSH
14024: CALL_OW 12
14028: ARRAY
14029: PPUSH
14030: LD_INT 1
14032: PPUSH
14033: CALL_OW 234
// end ;
14037: PPOPN 1
14039: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
14040: LD_EXP 44
14044: PUSH
14045: LD_EXP 92
14049: AND
14050: IFFALSE 14162
14052: GO 14054
14054: DISABLE
14055: LD_INT 0
14057: PPUSH
14058: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
14059: LD_ADDR_VAR 0 2
14063: PUSH
14064: LD_INT 22
14066: PUSH
14067: LD_OWVAR 2
14071: PUSH
14072: EMPTY
14073: LIST
14074: LIST
14075: PUSH
14076: LD_INT 2
14078: PUSH
14079: LD_INT 30
14081: PUSH
14082: LD_INT 27
14084: PUSH
14085: EMPTY
14086: LIST
14087: LIST
14088: PUSH
14089: LD_INT 30
14091: PUSH
14092: LD_INT 26
14094: PUSH
14095: EMPTY
14096: LIST
14097: LIST
14098: PUSH
14099: LD_INT 30
14101: PUSH
14102: LD_INT 28
14104: PUSH
14105: EMPTY
14106: LIST
14107: LIST
14108: PUSH
14109: EMPTY
14110: LIST
14111: LIST
14112: LIST
14113: LIST
14114: PUSH
14115: EMPTY
14116: LIST
14117: LIST
14118: PPUSH
14119: CALL_OW 69
14123: ST_TO_ADDR
// if not tmp then
14124: LD_VAR 0 2
14128: NOT
14129: IFFALSE 14133
// exit ;
14131: GO 14162
// for i in tmp do
14133: LD_ADDR_VAR 0 1
14137: PUSH
14138: LD_VAR 0 2
14142: PUSH
14143: FOR_IN
14144: IFFALSE 14160
// SetLives ( i , 1 ) ;
14146: LD_VAR 0 1
14150: PPUSH
14151: LD_INT 1
14153: PPUSH
14154: CALL_OW 234
14158: GO 14143
14160: POP
14161: POP
// end ;
14162: PPOPN 2
14164: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
14165: LD_EXP 44
14169: PUSH
14170: LD_EXP 93
14174: AND
14175: IFFALSE 14449
14177: GO 14179
14179: DISABLE
14180: LD_INT 0
14182: PPUSH
14183: PPUSH
14184: PPUSH
// begin i := rand ( 1 , 7 ) ;
14185: LD_ADDR_VAR 0 1
14189: PUSH
14190: LD_INT 1
14192: PPUSH
14193: LD_INT 7
14195: PPUSH
14196: CALL_OW 12
14200: ST_TO_ADDR
// case i of 1 :
14201: LD_VAR 0 1
14205: PUSH
14206: LD_INT 1
14208: DOUBLE
14209: EQUAL
14210: IFTRUE 14214
14212: GO 14224
14214: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
14215: LD_STRING earthquake(getX(game), 0, 32)
14217: PPUSH
14218: CALL_OW 559
14222: GO 14449
14224: LD_INT 2
14226: DOUBLE
14227: EQUAL
14228: IFTRUE 14232
14230: GO 14246
14232: POP
// begin ToLua ( displayStucuk(); ) ;
14233: LD_STRING displayStucuk();
14235: PPUSH
14236: CALL_OW 559
// ResetFog ;
14240: CALL_OW 335
// end ; 3 :
14244: GO 14449
14246: LD_INT 3
14248: DOUBLE
14249: EQUAL
14250: IFTRUE 14254
14252: GO 14358
14254: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
14255: LD_ADDR_VAR 0 2
14259: PUSH
14260: LD_INT 22
14262: PUSH
14263: LD_OWVAR 2
14267: PUSH
14268: EMPTY
14269: LIST
14270: LIST
14271: PUSH
14272: LD_INT 25
14274: PUSH
14275: LD_INT 1
14277: PUSH
14278: EMPTY
14279: LIST
14280: LIST
14281: PUSH
14282: EMPTY
14283: LIST
14284: LIST
14285: PPUSH
14286: CALL_OW 69
14290: ST_TO_ADDR
// if not tmp then
14291: LD_VAR 0 2
14295: NOT
14296: IFFALSE 14300
// exit ;
14298: GO 14449
// un := tmp [ rand ( 1 , tmp ) ] ;
14300: LD_ADDR_VAR 0 3
14304: PUSH
14305: LD_VAR 0 2
14309: PUSH
14310: LD_INT 1
14312: PPUSH
14313: LD_VAR 0 2
14317: PPUSH
14318: CALL_OW 12
14322: ARRAY
14323: ST_TO_ADDR
// if Crawls ( un ) then
14324: LD_VAR 0 3
14328: PPUSH
14329: CALL_OW 318
14333: IFFALSE 14344
// ComWalk ( un ) ;
14335: LD_VAR 0 3
14339: PPUSH
14340: CALL_OW 138
// SetClass ( un , class_mortar ) ;
14344: LD_VAR 0 3
14348: PPUSH
14349: LD_INT 8
14351: PPUSH
14352: CALL_OW 336
// end ; 4 :
14356: GO 14449
14358: LD_INT 4
14360: DOUBLE
14361: EQUAL
14362: IFTRUE 14366
14364: GO 14427
14366: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
14367: LD_ADDR_VAR 0 2
14371: PUSH
14372: LD_INT 22
14374: PUSH
14375: LD_OWVAR 2
14379: PUSH
14380: EMPTY
14381: LIST
14382: LIST
14383: PUSH
14384: LD_INT 30
14386: PUSH
14387: LD_INT 29
14389: PUSH
14390: EMPTY
14391: LIST
14392: LIST
14393: PUSH
14394: EMPTY
14395: LIST
14396: LIST
14397: PPUSH
14398: CALL_OW 69
14402: ST_TO_ADDR
// if not tmp then
14403: LD_VAR 0 2
14407: NOT
14408: IFFALSE 14412
// exit ;
14410: GO 14449
// DestroyUnit ( tmp [ 1 ] ) ;
14412: LD_VAR 0 2
14416: PUSH
14417: LD_INT 1
14419: ARRAY
14420: PPUSH
14421: CALL_OW 65
// end ; 5 .. 7 :
14425: GO 14449
14427: LD_INT 5
14429: DOUBLE
14430: GREATEREQUAL
14431: IFFALSE 14439
14433: LD_INT 7
14435: DOUBLE
14436: LESSEQUAL
14437: IFTRUE 14441
14439: GO 14448
14441: POP
// StreamSibBomb ; end ;
14442: CALL 10729 0 0
14446: GO 14449
14448: POP
// end ;
14449: PPOPN 3
14451: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
14452: LD_EXP 44
14456: PUSH
14457: LD_EXP 94
14461: AND
14462: IFFALSE 14618
14464: GO 14466
14466: DISABLE
14467: LD_INT 0
14469: PPUSH
14470: PPUSH
14471: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
14472: LD_ADDR_VAR 0 2
14476: PUSH
14477: LD_INT 81
14479: PUSH
14480: LD_OWVAR 2
14484: PUSH
14485: EMPTY
14486: LIST
14487: LIST
14488: PUSH
14489: LD_INT 2
14491: PUSH
14492: LD_INT 21
14494: PUSH
14495: LD_INT 1
14497: PUSH
14498: EMPTY
14499: LIST
14500: LIST
14501: PUSH
14502: LD_INT 21
14504: PUSH
14505: LD_INT 2
14507: PUSH
14508: EMPTY
14509: LIST
14510: LIST
14511: PUSH
14512: EMPTY
14513: LIST
14514: LIST
14515: LIST
14516: PUSH
14517: EMPTY
14518: LIST
14519: LIST
14520: PPUSH
14521: CALL_OW 69
14525: ST_TO_ADDR
// if not tmp then
14526: LD_VAR 0 2
14530: NOT
14531: IFFALSE 14535
// exit ;
14533: GO 14618
// p := 0 ;
14535: LD_ADDR_VAR 0 3
14539: PUSH
14540: LD_INT 0
14542: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14543: LD_INT 35
14545: PPUSH
14546: CALL_OW 67
// p := p + 1 ;
14550: LD_ADDR_VAR 0 3
14554: PUSH
14555: LD_VAR 0 3
14559: PUSH
14560: LD_INT 1
14562: PLUS
14563: ST_TO_ADDR
// for i in tmp do
14564: LD_ADDR_VAR 0 1
14568: PUSH
14569: LD_VAR 0 2
14573: PUSH
14574: FOR_IN
14575: IFFALSE 14606
// if GetLives ( i ) < 1000 then
14577: LD_VAR 0 1
14581: PPUSH
14582: CALL_OW 256
14586: PUSH
14587: LD_INT 1000
14589: LESS
14590: IFFALSE 14604
// SetLives ( i , 1000 ) ;
14592: LD_VAR 0 1
14596: PPUSH
14597: LD_INT 1000
14599: PPUSH
14600: CALL_OW 234
14604: GO 14574
14606: POP
14607: POP
// until p > 20 ;
14608: LD_VAR 0 3
14612: PUSH
14613: LD_INT 20
14615: GREATER
14616: IFFALSE 14543
// end ;
14618: PPOPN 3
14620: END
// every 0 0$1 trigger StreamModeActive and sTime do
14621: LD_EXP 44
14625: PUSH
14626: LD_EXP 95
14630: AND
14631: IFFALSE 14666
14633: GO 14635
14635: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
14636: LD_INT 28
14638: PPUSH
14639: LD_OWVAR 2
14643: PPUSH
14644: LD_INT 2
14646: PPUSH
14647: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
14651: LD_INT 30
14653: PPUSH
14654: LD_OWVAR 2
14658: PPUSH
14659: LD_INT 2
14661: PPUSH
14662: CALL_OW 322
// end ;
14666: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
14667: LD_EXP 44
14671: PUSH
14672: LD_EXP 96
14676: AND
14677: IFFALSE 14798
14679: GO 14681
14681: DISABLE
14682: LD_INT 0
14684: PPUSH
14685: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
14686: LD_ADDR_VAR 0 2
14690: PUSH
14691: LD_INT 22
14693: PUSH
14694: LD_OWVAR 2
14698: PUSH
14699: EMPTY
14700: LIST
14701: LIST
14702: PUSH
14703: LD_INT 21
14705: PUSH
14706: LD_INT 1
14708: PUSH
14709: EMPTY
14710: LIST
14711: LIST
14712: PUSH
14713: LD_INT 3
14715: PUSH
14716: LD_INT 23
14718: PUSH
14719: LD_INT 0
14721: PUSH
14722: EMPTY
14723: LIST
14724: LIST
14725: PUSH
14726: EMPTY
14727: LIST
14728: LIST
14729: PUSH
14730: EMPTY
14731: LIST
14732: LIST
14733: LIST
14734: PPUSH
14735: CALL_OW 69
14739: ST_TO_ADDR
// if not tmp then
14740: LD_VAR 0 2
14744: NOT
14745: IFFALSE 14749
// exit ;
14747: GO 14798
// for i in tmp do
14749: LD_ADDR_VAR 0 1
14753: PUSH
14754: LD_VAR 0 2
14758: PUSH
14759: FOR_IN
14760: IFFALSE 14796
// begin if Crawls ( i ) then
14762: LD_VAR 0 1
14766: PPUSH
14767: CALL_OW 318
14771: IFFALSE 14782
// ComWalk ( i ) ;
14773: LD_VAR 0 1
14777: PPUSH
14778: CALL_OW 138
// SetClass ( i , 2 ) ;
14782: LD_VAR 0 1
14786: PPUSH
14787: LD_INT 2
14789: PPUSH
14790: CALL_OW 336
// end ;
14794: GO 14759
14796: POP
14797: POP
// end ;
14798: PPOPN 2
14800: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
14801: LD_EXP 44
14805: PUSH
14806: LD_EXP 97
14810: AND
14811: IFFALSE 15032
14813: GO 14815
14815: DISABLE
14816: LD_INT 0
14818: PPUSH
14819: PPUSH
14820: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
14821: LD_OWVAR 2
14825: PPUSH
14826: LD_INT 9
14828: PPUSH
14829: LD_INT 1
14831: PPUSH
14832: LD_INT 1
14834: PPUSH
14835: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
14839: LD_INT 9
14841: PPUSH
14842: LD_OWVAR 2
14846: PPUSH
14847: CALL_OW 343
// uc_side := 9 ;
14851: LD_ADDR_OWVAR 20
14855: PUSH
14856: LD_INT 9
14858: ST_TO_ADDR
// uc_nation := 2 ;
14859: LD_ADDR_OWVAR 21
14863: PUSH
14864: LD_INT 2
14866: ST_TO_ADDR
// hc_name := Dark Warrior ;
14867: LD_ADDR_OWVAR 26
14871: PUSH
14872: LD_STRING Dark Warrior
14874: ST_TO_ADDR
// hc_gallery :=  ;
14875: LD_ADDR_OWVAR 33
14879: PUSH
14880: LD_STRING 
14882: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 10 ) ;
14883: LD_INT 1
14885: PPUSH
14886: LD_INT 1
14888: PPUSH
14889: LD_INT 10
14891: PPUSH
14892: CALL_OW 380
// un := CreateHuman ;
14896: LD_ADDR_VAR 0 3
14900: PUSH
14901: CALL_OW 44
14905: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
14906: LD_VAR 0 3
14910: PPUSH
14911: LD_INT 1
14913: PPUSH
14914: CALL_OW 51
// p := 0 ;
14918: LD_ADDR_VAR 0 2
14922: PUSH
14923: LD_INT 0
14925: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14926: LD_INT 35
14928: PPUSH
14929: CALL_OW 67
// if GetLives ( un ) < 1000 then
14933: LD_VAR 0 3
14937: PPUSH
14938: CALL_OW 256
14942: PUSH
14943: LD_INT 1000
14945: LESS
14946: IFFALSE 14960
// SetLives ( un , 1000 ) ;
14948: LD_VAR 0 3
14952: PPUSH
14953: LD_INT 1000
14955: PPUSH
14956: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , your_side ] ) , un ) ) ;
14960: LD_VAR 0 3
14964: PPUSH
14965: LD_INT 81
14967: PUSH
14968: LD_OWVAR 2
14972: PUSH
14973: EMPTY
14974: LIST
14975: LIST
14976: PPUSH
14977: CALL_OW 69
14981: PPUSH
14982: LD_VAR 0 3
14986: PPUSH
14987: CALL_OW 74
14991: PPUSH
14992: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
14996: LD_VAR 0 2
15000: PUSH
15001: LD_INT 60
15003: GREATER
15004: PUSH
15005: LD_VAR 0 3
15009: PPUSH
15010: CALL_OW 301
15014: OR
15015: IFFALSE 14926
// if un then
15017: LD_VAR 0 3
15021: IFFALSE 15032
// RemoveUnit ( un ) ;
15023: LD_VAR 0 3
15027: PPUSH
15028: CALL_OW 64
// end ; end_of_file
15032: PPOPN 3
15034: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
15035: LD_INT 0
15037: PPUSH
15038: PPUSH
15039: PPUSH
15040: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
15041: LD_VAR 0 1
15045: PPUSH
15046: CALL_OW 264
15050: PUSH
15051: LD_EXP 43
15055: EQUAL
15056: IFFALSE 15128
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
15058: LD_INT 68
15060: PPUSH
15061: LD_VAR 0 1
15065: PPUSH
15066: CALL_OW 255
15070: PPUSH
15071: CALL_OW 321
15075: PUSH
15076: LD_INT 2
15078: EQUAL
15079: IFFALSE 15091
// eff := 70 else
15081: LD_ADDR_VAR 0 6
15085: PUSH
15086: LD_INT 70
15088: ST_TO_ADDR
15089: GO 15099
// eff := 30 ;
15091: LD_ADDR_VAR 0 6
15095: PUSH
15096: LD_INT 30
15098: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
15099: LD_VAR 0 1
15103: PPUSH
15104: CALL_OW 250
15108: PPUSH
15109: LD_VAR 0 1
15113: PPUSH
15114: CALL_OW 251
15118: PPUSH
15119: LD_VAR 0 6
15123: PPUSH
15124: CALL_OW 495
// end ; end ;
15128: LD_VAR 0 4
15132: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
15133: LD_INT 0
15135: PPUSH
15136: PPUSH
15137: PPUSH
15138: PPUSH
15139: PPUSH
15140: PPUSH
// if cmd = 124 then
15141: LD_VAR 0 1
15145: PUSH
15146: LD_INT 124
15148: EQUAL
15149: IFFALSE 15355
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
15151: LD_ADDR_VAR 0 5
15155: PUSH
15156: LD_INT 2
15158: PUSH
15159: LD_INT 34
15161: PUSH
15162: LD_INT 53
15164: PUSH
15165: EMPTY
15166: LIST
15167: LIST
15168: PUSH
15169: LD_INT 34
15171: PUSH
15172: LD_INT 14
15174: PUSH
15175: EMPTY
15176: LIST
15177: LIST
15178: PUSH
15179: EMPTY
15180: LIST
15181: LIST
15182: LIST
15183: PPUSH
15184: CALL_OW 69
15188: ST_TO_ADDR
// if not tmp then
15189: LD_VAR 0 5
15193: NOT
15194: IFFALSE 15198
// exit ;
15196: GO 15355
// for i in tmp do
15198: LD_ADDR_VAR 0 3
15202: PUSH
15203: LD_VAR 0 5
15207: PUSH
15208: FOR_IN
15209: IFFALSE 15353
// begin taskList := GetTaskList ( i ) ;
15211: LD_ADDR_VAR 0 6
15215: PUSH
15216: LD_VAR 0 3
15220: PPUSH
15221: CALL_OW 437
15225: ST_TO_ADDR
// if not taskList then
15226: LD_VAR 0 6
15230: NOT
15231: IFFALSE 15235
// continue ;
15233: GO 15208
// for j = 1 to taskList do
15235: LD_ADDR_VAR 0 4
15239: PUSH
15240: DOUBLE
15241: LD_INT 1
15243: DEC
15244: ST_TO_ADDR
15245: LD_VAR 0 6
15249: PUSH
15250: FOR_TO
15251: IFFALSE 15349
// if taskList [ j ] [ 1 ] = | then
15253: LD_VAR 0 6
15257: PUSH
15258: LD_VAR 0 4
15262: ARRAY
15263: PUSH
15264: LD_INT 1
15266: ARRAY
15267: PUSH
15268: LD_STRING |
15270: EQUAL
15271: IFFALSE 15347
// begin _taskList := Delete ( taskList , 1 ) ;
15273: LD_ADDR_VAR 0 7
15277: PUSH
15278: LD_VAR 0 6
15282: PPUSH
15283: LD_INT 1
15285: PPUSH
15286: CALL_OW 3
15290: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
15291: LD_VAR 0 3
15295: PPUSH
15296: LD_VAR 0 7
15300: PPUSH
15301: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
15305: LD_VAR 0 3
15309: PPUSH
15310: LD_VAR 0 6
15314: PUSH
15315: LD_VAR 0 4
15319: ARRAY
15320: PUSH
15321: LD_INT 2
15323: ARRAY
15324: PPUSH
15325: LD_VAR 0 6
15329: PUSH
15330: LD_VAR 0 4
15334: ARRAY
15335: PUSH
15336: LD_INT 3
15338: ARRAY
15339: PPUSH
15340: LD_INT 8
15342: PPUSH
15343: CALL 15360 0 4
// end ;
15347: GO 15250
15349: POP
15350: POP
// end ;
15351: GO 15208
15353: POP
15354: POP
// end ; end ;
15355: LD_VAR 0 2
15359: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
15360: LD_INT 0
15362: PPUSH
15363: PPUSH
15364: PPUSH
15365: PPUSH
15366: PPUSH
15367: PPUSH
15368: PPUSH
15369: PPUSH
15370: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
15371: LD_VAR 0 1
15375: NOT
15376: PUSH
15377: LD_VAR 0 2
15381: PPUSH
15382: LD_VAR 0 3
15386: PPUSH
15387: CALL_OW 488
15391: NOT
15392: OR
15393: PUSH
15394: LD_VAR 0 4
15398: NOT
15399: OR
15400: IFFALSE 15404
// exit ;
15402: GO 15744
// list := [ ] ;
15404: LD_ADDR_VAR 0 13
15408: PUSH
15409: EMPTY
15410: ST_TO_ADDR
// if x - r < 0 then
15411: LD_VAR 0 2
15415: PUSH
15416: LD_VAR 0 4
15420: MINUS
15421: PUSH
15422: LD_INT 0
15424: LESS
15425: IFFALSE 15437
// min_x := 0 else
15427: LD_ADDR_VAR 0 7
15431: PUSH
15432: LD_INT 0
15434: ST_TO_ADDR
15435: GO 15453
// min_x := x - r ;
15437: LD_ADDR_VAR 0 7
15441: PUSH
15442: LD_VAR 0 2
15446: PUSH
15447: LD_VAR 0 4
15451: MINUS
15452: ST_TO_ADDR
// if y - r < 0 then
15453: LD_VAR 0 3
15457: PUSH
15458: LD_VAR 0 4
15462: MINUS
15463: PUSH
15464: LD_INT 0
15466: LESS
15467: IFFALSE 15479
// min_y := 0 else
15469: LD_ADDR_VAR 0 8
15473: PUSH
15474: LD_INT 0
15476: ST_TO_ADDR
15477: GO 15495
// min_y := y - r ;
15479: LD_ADDR_VAR 0 8
15483: PUSH
15484: LD_VAR 0 3
15488: PUSH
15489: LD_VAR 0 4
15493: MINUS
15494: ST_TO_ADDR
// max_x := x + r ;
15495: LD_ADDR_VAR 0 9
15499: PUSH
15500: LD_VAR 0 2
15504: PUSH
15505: LD_VAR 0 4
15509: PLUS
15510: ST_TO_ADDR
// max_y := y + r ;
15511: LD_ADDR_VAR 0 10
15515: PUSH
15516: LD_VAR 0 3
15520: PUSH
15521: LD_VAR 0 4
15525: PLUS
15526: ST_TO_ADDR
// for _x = min_x to max_x do
15527: LD_ADDR_VAR 0 11
15531: PUSH
15532: DOUBLE
15533: LD_VAR 0 7
15537: DEC
15538: ST_TO_ADDR
15539: LD_VAR 0 9
15543: PUSH
15544: FOR_TO
15545: IFFALSE 15662
// for _y = min_y to max_y do
15547: LD_ADDR_VAR 0 12
15551: PUSH
15552: DOUBLE
15553: LD_VAR 0 8
15557: DEC
15558: ST_TO_ADDR
15559: LD_VAR 0 10
15563: PUSH
15564: FOR_TO
15565: IFFALSE 15658
// begin if not ValidHex ( _x , _y ) then
15567: LD_VAR 0 11
15571: PPUSH
15572: LD_VAR 0 12
15576: PPUSH
15577: CALL_OW 488
15581: NOT
15582: IFFALSE 15586
// continue ;
15584: GO 15564
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
15586: LD_VAR 0 11
15590: PPUSH
15591: LD_VAR 0 12
15595: PPUSH
15596: CALL_OW 351
15600: PUSH
15601: LD_VAR 0 11
15605: PPUSH
15606: LD_VAR 0 12
15610: PPUSH
15611: CALL_OW 554
15615: AND
15616: IFFALSE 15656
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
15618: LD_ADDR_VAR 0 13
15622: PUSH
15623: LD_VAR 0 13
15627: PPUSH
15628: LD_VAR 0 13
15632: PUSH
15633: LD_INT 1
15635: PLUS
15636: PPUSH
15637: LD_VAR 0 11
15641: PUSH
15642: LD_VAR 0 12
15646: PUSH
15647: EMPTY
15648: LIST
15649: LIST
15650: PPUSH
15651: CALL_OW 2
15655: ST_TO_ADDR
// end ;
15656: GO 15564
15658: POP
15659: POP
15660: GO 15544
15662: POP
15663: POP
// if not list then
15664: LD_VAR 0 13
15668: NOT
15669: IFFALSE 15673
// exit ;
15671: GO 15744
// for i in list do
15673: LD_ADDR_VAR 0 6
15677: PUSH
15678: LD_VAR 0 13
15682: PUSH
15683: FOR_IN
15684: IFFALSE 15742
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
15686: LD_VAR 0 1
15690: PPUSH
15691: LD_STRING M
15693: PUSH
15694: LD_VAR 0 6
15698: PUSH
15699: LD_INT 1
15701: ARRAY
15702: PUSH
15703: LD_VAR 0 6
15707: PUSH
15708: LD_INT 2
15710: ARRAY
15711: PUSH
15712: LD_INT 0
15714: PUSH
15715: LD_INT 0
15717: PUSH
15718: LD_INT 0
15720: PUSH
15721: LD_INT 0
15723: PUSH
15724: EMPTY
15725: LIST
15726: LIST
15727: LIST
15728: LIST
15729: LIST
15730: LIST
15731: LIST
15732: PUSH
15733: EMPTY
15734: LIST
15735: PPUSH
15736: CALL_OW 447
15740: GO 15683
15742: POP
15743: POP
// end ;
15744: LD_VAR 0 5
15748: RET
