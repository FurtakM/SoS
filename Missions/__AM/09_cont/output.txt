// starting begin ResetFog ;
   0: CALL_OW 335
// FogOff ( 1 ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 344
// Randomize ;
  11: CALL_OW 10
// Init ;
  15: CALL 32 0 0
// DebugMode ;
  19: CALL 56 0 0
// PrepareAmerican ;
  23: CALL 73 0 0
// Action ;
  27: CALL 2153 0 0
// end ;
  31: END
// export debug ; export mission_prefix , mission_prefix_prev ; function Init ; begin
  32: LD_INT 0
  34: PPUSH
// debug := false ;
  35: LD_ADDR_EXP 1
  39: PUSH
  40: LD_INT 0
  42: ST_TO_ADDR
// mission_prefix_prev := 08_ ;
  43: LD_ADDR_EXP 3
  47: PUSH
  48: LD_STRING 08_
  50: ST_TO_ADDR
// end ;
  51: LD_VAR 0 1
  55: RET
// function DebugMode ; begin
  56: LD_INT 0
  58: PPUSH
// if not debug then
  59: LD_EXP 1
  63: NOT
  64: IFFALSE 68
// exit ;
  66: GO 68
// end ; end_of_file
  68: LD_VAR 0 1
  72: RET
// export JMM , Gladstone , Frank , Lisa , Joan , Cyrus , Bobby , Donaldson , Brown , Houten , Khatam , Powell ; export function PrepareAmerican ; var team , veh , dep , bar , lab , fac , bun , filter , i , j ; begin
  73: LD_INT 0
  75: PPUSH
  76: PPUSH
  77: PPUSH
  78: PPUSH
  79: PPUSH
  80: PPUSH
  81: PPUSH
  82: PPUSH
  83: PPUSH
  84: PPUSH
  85: PPUSH
// PrepareBase ;
  86: CALL 1723 0 0
// uc_side := 1 ;
  90: LD_ADDR_OWVAR 20
  94: PUSH
  95: LD_INT 1
  97: ST_TO_ADDR
// uc_nation := 1 ;
  98: LD_ADDR_OWVAR 21
 102: PUSH
 103: LD_INT 1
 105: ST_TO_ADDR
// team := [ ] ;
 106: LD_ADDR_VAR 0 2
 110: PUSH
 111: EMPTY
 112: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
 113: LD_ADDR_EXP 4
 117: PUSH
 118: LD_STRING JMM
 120: PPUSH
 121: LD_EXP 1
 125: NOT
 126: PPUSH
 127: CALL 2002 0 2
 131: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) ) ;
 132: LD_ADDR_EXP 8
 136: PUSH
 137: LD_STRING Joan
 139: PPUSH
 140: LD_EXP 1
 144: NOT
 145: PPUSH
 146: CALL 2002 0 2
 150: ST_TO_ADDR
// if Joan then
 151: LD_EXP 8
 155: IFFALSE 173
// team := team ^ Joan ;
 157: LD_ADDR_VAR 0 2
 161: PUSH
 162: LD_VAR 0 2
 166: PUSH
 167: LD_EXP 8
 171: ADD
 172: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
 173: LD_ADDR_EXP 11
 177: PUSH
 178: LD_STRING Donaldson
 180: PPUSH
 181: LD_EXP 1
 185: NOT
 186: PPUSH
 187: CALL 2002 0 2
 191: ST_TO_ADDR
// if Donaldson then
 192: LD_EXP 11
 196: IFFALSE 214
// team := team ^ Donaldson ;
 198: LD_ADDR_VAR 0 2
 202: PUSH
 203: LD_VAR 0 2
 207: PUSH
 208: LD_EXP 11
 212: ADD
 213: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) ) ;
 214: LD_ADDR_EXP 12
 218: PUSH
 219: LD_STRING Brown
 221: PPUSH
 222: LD_EXP 1
 226: NOT
 227: PPUSH
 228: CALL 2002 0 2
 232: ST_TO_ADDR
// if Brown then
 233: LD_EXP 12
 237: IFFALSE 255
// team := team ^ Brown ;
 239: LD_ADDR_VAR 0 2
 243: PUSH
 244: LD_VAR 0 2
 248: PUSH
 249: LD_EXP 12
 253: ADD
 254: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) ) ;
 255: LD_ADDR_EXP 13
 259: PUSH
 260: LD_STRING Houten
 262: PPUSH
 263: LD_EXP 1
 267: NOT
 268: PPUSH
 269: CALL 2002 0 2
 273: ST_TO_ADDR
// if Houten then
 274: LD_EXP 13
 278: IFFALSE 296
// team := team ^ Houten ;
 280: LD_ADDR_VAR 0 2
 284: PUSH
 285: LD_VAR 0 2
 289: PUSH
 290: LD_EXP 13
 294: ADD
 295: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) ) ;
 296: LD_ADDR_EXP 5
 300: PUSH
 301: LD_STRING Gladstone
 303: PPUSH
 304: LD_EXP 1
 308: NOT
 309: PPUSH
 310: CALL 2002 0 2
 314: ST_TO_ADDR
// if Gladstone then
 315: LD_EXP 5
 319: IFFALSE 337
// team := team ^ Gladstone ;
 321: LD_ADDR_VAR 0 2
 325: PUSH
 326: LD_VAR 0 2
 330: PUSH
 331: LD_EXP 5
 335: ADD
 336: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) ) ;
 337: LD_ADDR_EXP 6
 341: PUSH
 342: LD_STRING Frank
 344: PPUSH
 345: LD_EXP 1
 349: NOT
 350: PPUSH
 351: CALL 2002 0 2
 355: ST_TO_ADDR
// if Frank then
 356: LD_EXP 6
 360: IFFALSE 378
// team := team ^ Frank ;
 362: LD_ADDR_VAR 0 2
 366: PUSH
 367: LD_VAR 0 2
 371: PUSH
 372: LD_EXP 6
 376: ADD
 377: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
 378: LD_ADDR_EXP 7
 382: PUSH
 383: LD_STRING Lisa
 385: PPUSH
 386: LD_EXP 1
 390: NOT
 391: PPUSH
 392: CALL 2002 0 2
 396: ST_TO_ADDR
// if Lisa then
 397: LD_EXP 7
 401: IFFALSE 419
// team := team ^ Lisa ;
 403: LD_ADDR_VAR 0 2
 407: PUSH
 408: LD_VAR 0 2
 412: PUSH
 413: LD_EXP 7
 417: ADD
 418: ST_TO_ADDR
// team := team ^ CreateCharacterSet ( 08_other_survivors ) ;
 419: LD_ADDR_VAR 0 2
 423: PUSH
 424: LD_VAR 0 2
 428: PUSH
 429: LD_STRING 08_other_survivors
 431: PPUSH
 432: CALL_OW 31
 436: ADD
 437: ST_TO_ADDR
// dep := FilterAllUnits ( [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
 438: LD_ADDR_VAR 0 4
 442: PUSH
 443: LD_INT 2
 445: PUSH
 446: LD_INT 30
 448: PUSH
 449: LD_INT 0
 451: PUSH
 452: EMPTY
 453: LIST
 454: LIST
 455: PUSH
 456: LD_INT 30
 458: PUSH
 459: LD_INT 1
 461: PUSH
 462: EMPTY
 463: LIST
 464: LIST
 465: PUSH
 466: EMPTY
 467: LIST
 468: LIST
 469: LIST
 470: PPUSH
 471: CALL_OW 69
 475: ST_TO_ADDR
// bar := FilterAllUnits ( [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
 476: LD_ADDR_VAR 0 5
 480: PUSH
 481: LD_INT 2
 483: PUSH
 484: LD_INT 30
 486: PUSH
 487: LD_INT 4
 489: PUSH
 490: EMPTY
 491: LIST
 492: LIST
 493: PUSH
 494: LD_INT 30
 496: PUSH
 497: LD_INT 5
 499: PUSH
 500: EMPTY
 501: LIST
 502: LIST
 503: PUSH
 504: EMPTY
 505: LIST
 506: LIST
 507: LIST
 508: PPUSH
 509: CALL_OW 69
 513: ST_TO_ADDR
// lab := FilterAllUnits ( [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab ] ] ) ;
 514: LD_ADDR_VAR 0 6
 518: PUSH
 519: LD_INT 2
 521: PUSH
 522: LD_INT 30
 524: PUSH
 525: LD_INT 8
 527: PUSH
 528: EMPTY
 529: LIST
 530: LIST
 531: PUSH
 532: LD_INT 30
 534: PUSH
 535: LD_INT 7
 537: PUSH
 538: EMPTY
 539: LIST
 540: LIST
 541: PUSH
 542: LD_INT 30
 544: PUSH
 545: LD_INT 6
 547: PUSH
 548: EMPTY
 549: LIST
 550: LIST
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PPUSH
 558: CALL_OW 69
 562: ST_TO_ADDR
// fac := FilterAllUnits ( [ f_btype , b_factory ] ) ;
 563: LD_ADDR_VAR 0 7
 567: PUSH
 568: LD_INT 30
 570: PUSH
 571: LD_INT 3
 573: PUSH
 574: EMPTY
 575: LIST
 576: LIST
 577: PPUSH
 578: CALL_OW 69
 582: ST_TO_ADDR
// bun := FilterAllUnits ( [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ;
 583: LD_ADDR_VAR 0 8
 587: PUSH
 588: LD_INT 2
 590: PUSH
 591: LD_INT 30
 593: PUSH
 594: LD_INT 32
 596: PUSH
 597: EMPTY
 598: LIST
 599: LIST
 600: PUSH
 601: LD_INT 30
 603: PUSH
 604: LD_INT 31
 606: PUSH
 607: EMPTY
 608: LIST
 609: LIST
 610: PUSH
 611: EMPTY
 612: LIST
 613: LIST
 614: LIST
 615: PPUSH
 616: CALL_OW 69
 620: ST_TO_ADDR
// SetBName ( dep [ 1 ] , Gamma ) ;
 621: LD_VAR 0 4
 625: PUSH
 626: LD_INT 1
 628: ARRAY
 629: PPUSH
 630: LD_STRING Gamma
 632: PPUSH
 633: CALL_OW 500
// SetResourceType ( GetBase ( dep [ 1 ] ) , mat_oil , 10000 ) ;
 637: LD_VAR 0 4
 641: PUSH
 642: LD_INT 1
 644: ARRAY
 645: PPUSH
 646: CALL_OW 274
 650: PPUSH
 651: LD_INT 2
 653: PPUSH
 654: LD_INT 10000
 656: PPUSH
 657: CALL_OW 277
// SetResourceType ( GetBase ( dep [ 1 ] ) , mat_cans , 10000 ) ;
 661: LD_VAR 0 4
 665: PUSH
 666: LD_INT 1
 668: ARRAY
 669: PPUSH
 670: CALL_OW 274
 674: PPUSH
 675: LD_INT 1
 677: PPUSH
 678: LD_INT 10000
 680: PPUSH
 681: CALL_OW 277
// if dep then
 685: LD_VAR 0 4
 689: IFFALSE 791
// begin PlaceHumanInUnit ( JMM , dep [ 1 ] ) ;
 691: LD_EXP 4
 695: PPUSH
 696: LD_VAR 0 4
 700: PUSH
 701: LD_INT 1
 703: ARRAY
 704: PPUSH
 705: CALL_OW 52
// if Brown then
 709: LD_EXP 12
 713: IFFALSE 749
// begin PlaceHumanInUnit ( Brown , dep [ 1 ] ) ;
 715: LD_EXP 12
 719: PPUSH
 720: LD_VAR 0 4
 724: PUSH
 725: LD_INT 1
 727: ARRAY
 728: PPUSH
 729: CALL_OW 52
// team := team diff Brown ;
 733: LD_ADDR_VAR 0 2
 737: PUSH
 738: LD_VAR 0 2
 742: PUSH
 743: LD_EXP 12
 747: DIFF
 748: ST_TO_ADDR
// end ; if Donaldson then
 749: LD_EXP 11
 753: IFFALSE 789
// begin PlaceHumanInUnit ( Donaldson , dep [ 1 ] ) ;
 755: LD_EXP 11
 759: PPUSH
 760: LD_VAR 0 4
 764: PUSH
 765: LD_INT 1
 767: ARRAY
 768: PPUSH
 769: CALL_OW 52
// team := team diff Donaldson ;
 773: LD_ADDR_VAR 0 2
 777: PUSH
 778: LD_VAR 0 2
 782: PUSH
 783: LD_EXP 11
 787: DIFF
 788: ST_TO_ADDR
// end ; end else
 789: GO 898
// begin PlaceUnitXYR ( JMM , 52 , 16 , 10 , false ) ;
 791: LD_EXP 4
 795: PPUSH
 796: LD_INT 52
 798: PPUSH
 799: LD_INT 16
 801: PPUSH
 802: LD_INT 10
 804: PPUSH
 805: LD_INT 0
 807: PPUSH
 808: CALL_OW 50
// if Brown then
 812: LD_EXP 12
 816: IFFALSE 855
// begin PlaceUnitXYR ( Brown , 52 , 16 , 10 , false ) ;
 818: LD_EXP 12
 822: PPUSH
 823: LD_INT 52
 825: PPUSH
 826: LD_INT 16
 828: PPUSH
 829: LD_INT 10
 831: PPUSH
 832: LD_INT 0
 834: PPUSH
 835: CALL_OW 50
// team := team diff Brown ;
 839: LD_ADDR_VAR 0 2
 843: PUSH
 844: LD_VAR 0 2
 848: PUSH
 849: LD_EXP 12
 853: DIFF
 854: ST_TO_ADDR
// end ; if Donaldson then
 855: LD_EXP 11
 859: IFFALSE 898
// begin PlaceUnitXYR ( Donaldson , 52 , 16 , 10 , false ) ;
 861: LD_EXP 11
 865: PPUSH
 866: LD_INT 52
 868: PPUSH
 869: LD_INT 16
 871: PPUSH
 872: LD_INT 10
 874: PPUSH
 875: LD_INT 0
 877: PPUSH
 878: CALL_OW 50
// team := team diff Donaldson ;
 882: LD_ADDR_VAR 0 2
 886: PUSH
 887: LD_VAR 0 2
 891: PUSH
 892: LD_EXP 11
 896: DIFF
 897: ST_TO_ADDR
// end ; end ; if bun and UnitFilter ( team , [ f_class , 1 ] ) then
 898: LD_VAR 0 8
 902: PUSH
 903: LD_VAR 0 2
 907: PPUSH
 908: LD_INT 25
 910: PUSH
 911: LD_INT 1
 913: PUSH
 914: EMPTY
 915: LIST
 916: LIST
 917: PPUSH
 918: CALL_OW 72
 922: AND
 923: IFFALSE 1032
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
 925: LD_ADDR_VAR 0 9
 929: PUSH
 930: LD_VAR 0 2
 934: PPUSH
 935: LD_INT 25
 937: PUSH
 938: LD_INT 1
 940: PUSH
 941: EMPTY
 942: LIST
 943: LIST
 944: PPUSH
 945: CALL_OW 72
 949: ST_TO_ADDR
// for i in bun do
 950: LD_ADDR_VAR 0 10
 954: PUSH
 955: LD_VAR 0 8
 959: PUSH
 960: FOR_IN
 961: IFFALSE 1030
// begin if not filter then
 963: LD_VAR 0 9
 967: NOT
 968: IFFALSE 972
// break ;
 970: GO 1030
// PlaceHumanInUnit ( filter [ 1 ] , i ) ;
 972: LD_VAR 0 9
 976: PUSH
 977: LD_INT 1
 979: ARRAY
 980: PPUSH
 981: LD_VAR 0 10
 985: PPUSH
 986: CALL_OW 52
// team := team diff filter [ 1 ] ;
 990: LD_ADDR_VAR 0 2
 994: PUSH
 995: LD_VAR 0 2
 999: PUSH
1000: LD_VAR 0 9
1004: PUSH
1005: LD_INT 1
1007: ARRAY
1008: DIFF
1009: ST_TO_ADDR
// filter := Delete ( filter , 1 ) ;
1010: LD_ADDR_VAR 0 9
1014: PUSH
1015: LD_VAR 0 9
1019: PPUSH
1020: LD_INT 1
1022: PPUSH
1023: CALL_OW 3
1027: ST_TO_ADDR
// end ;
1028: GO 960
1030: POP
1031: POP
// end ; if bar and UnitFilter ( team , [ f_class , 1 ] ) then
1032: LD_VAR 0 5
1036: PUSH
1037: LD_VAR 0 2
1041: PPUSH
1042: LD_INT 25
1044: PUSH
1045: LD_INT 1
1047: PUSH
1048: EMPTY
1049: LIST
1050: LIST
1051: PPUSH
1052: CALL_OW 72
1056: AND
1057: IFFALSE 1179
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
1059: LD_ADDR_VAR 0 9
1063: PUSH
1064: LD_VAR 0 2
1068: PPUSH
1069: LD_INT 25
1071: PUSH
1072: LD_INT 1
1074: PUSH
1075: EMPTY
1076: LIST
1077: LIST
1078: PPUSH
1079: CALL_OW 72
1083: ST_TO_ADDR
// for i = 1 to filter do
1084: LD_ADDR_VAR 0 10
1088: PUSH
1089: DOUBLE
1090: LD_INT 1
1092: DEC
1093: ST_TO_ADDR
1094: LD_VAR 0 9
1098: PUSH
1099: FOR_TO
1100: IFFALSE 1161
// begin if ( i <= 6 ) then
1102: LD_VAR 0 10
1106: PUSH
1107: LD_INT 6
1109: LESSEQUAL
1110: IFFALSE 1138
// PlaceHumanInUnit ( filter [ i ] , bar [ 1 ] ) else
1112: LD_VAR 0 9
1116: PUSH
1117: LD_VAR 0 10
1121: ARRAY
1122: PPUSH
1123: LD_VAR 0 5
1127: PUSH
1128: LD_INT 1
1130: ARRAY
1131: PPUSH
1132: CALL_OW 52
1136: GO 1159
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1138: LD_VAR 0 9
1142: PUSH
1143: LD_VAR 0 10
1147: ARRAY
1148: PPUSH
1149: LD_INT 1
1151: PPUSH
1152: LD_INT 0
1154: PPUSH
1155: CALL_OW 49
// end ;
1159: GO 1099
1161: POP
1162: POP
// team := team diff filter ;
1163: LD_ADDR_VAR 0 2
1167: PUSH
1168: LD_VAR 0 2
1172: PUSH
1173: LD_VAR 0 9
1177: DIFF
1178: ST_TO_ADDR
// end ; if lab and UnitFilter ( team , [ f_class , 4 ] ) then
1179: LD_VAR 0 6
1183: PUSH
1184: LD_VAR 0 2
1188: PPUSH
1189: LD_INT 25
1191: PUSH
1192: LD_INT 4
1194: PUSH
1195: EMPTY
1196: LIST
1197: LIST
1198: PPUSH
1199: CALL_OW 72
1203: AND
1204: IFFALSE 1326
// begin filter := UnitFilter ( team , [ f_class , 4 ] ) ;
1206: LD_ADDR_VAR 0 9
1210: PUSH
1211: LD_VAR 0 2
1215: PPUSH
1216: LD_INT 25
1218: PUSH
1219: LD_INT 4
1221: PUSH
1222: EMPTY
1223: LIST
1224: LIST
1225: PPUSH
1226: CALL_OW 72
1230: ST_TO_ADDR
// for i = 1 to filter do
1231: LD_ADDR_VAR 0 10
1235: PUSH
1236: DOUBLE
1237: LD_INT 1
1239: DEC
1240: ST_TO_ADDR
1241: LD_VAR 0 9
1245: PUSH
1246: FOR_TO
1247: IFFALSE 1308
// begin if ( i <= 6 ) then
1249: LD_VAR 0 10
1253: PUSH
1254: LD_INT 6
1256: LESSEQUAL
1257: IFFALSE 1285
// PlaceHumanInUnit ( filter [ i ] , lab [ 1 ] ) else
1259: LD_VAR 0 9
1263: PUSH
1264: LD_VAR 0 10
1268: ARRAY
1269: PPUSH
1270: LD_VAR 0 6
1274: PUSH
1275: LD_INT 1
1277: ARRAY
1278: PPUSH
1279: CALL_OW 52
1283: GO 1306
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1285: LD_VAR 0 9
1289: PUSH
1290: LD_VAR 0 10
1294: ARRAY
1295: PPUSH
1296: LD_INT 1
1298: PPUSH
1299: LD_INT 0
1301: PPUSH
1302: CALL_OW 49
// end ;
1306: GO 1246
1308: POP
1309: POP
// team := team diff filter ;
1310: LD_ADDR_VAR 0 2
1314: PUSH
1315: LD_VAR 0 2
1319: PUSH
1320: LD_VAR 0 9
1324: DIFF
1325: ST_TO_ADDR
// end ; if fac and UnitFilter ( team , [ f_class , 3 ] ) then
1326: LD_VAR 0 7
1330: PUSH
1331: LD_VAR 0 2
1335: PPUSH
1336: LD_INT 25
1338: PUSH
1339: LD_INT 3
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: PPUSH
1346: CALL_OW 72
1350: AND
1351: IFFALSE 1473
// begin filter := UnitFilter ( team , [ f_class , 3 ] ) ;
1353: LD_ADDR_VAR 0 9
1357: PUSH
1358: LD_VAR 0 2
1362: PPUSH
1363: LD_INT 25
1365: PUSH
1366: LD_INT 3
1368: PUSH
1369: EMPTY
1370: LIST
1371: LIST
1372: PPUSH
1373: CALL_OW 72
1377: ST_TO_ADDR
// for i = 1 to filter do
1378: LD_ADDR_VAR 0 10
1382: PUSH
1383: DOUBLE
1384: LD_INT 1
1386: DEC
1387: ST_TO_ADDR
1388: LD_VAR 0 9
1392: PUSH
1393: FOR_TO
1394: IFFALSE 1455
// begin if ( i <= 6 ) then
1396: LD_VAR 0 10
1400: PUSH
1401: LD_INT 6
1403: LESSEQUAL
1404: IFFALSE 1432
// PlaceHumanInUnit ( filter [ i ] , fac [ 1 ] ) else
1406: LD_VAR 0 9
1410: PUSH
1411: LD_VAR 0 10
1415: ARRAY
1416: PPUSH
1417: LD_VAR 0 7
1421: PUSH
1422: LD_INT 1
1424: ARRAY
1425: PPUSH
1426: CALL_OW 52
1430: GO 1453
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1432: LD_VAR 0 9
1436: PUSH
1437: LD_VAR 0 10
1441: ARRAY
1442: PPUSH
1443: LD_INT 1
1445: PPUSH
1446: LD_INT 0
1448: PPUSH
1449: CALL_OW 49
// end ;
1453: GO 1393
1455: POP
1456: POP
// team := team diff filter ;
1457: LD_ADDR_VAR 0 2
1461: PUSH
1462: LD_VAR 0 2
1466: PUSH
1467: LD_VAR 0 9
1471: DIFF
1472: ST_TO_ADDR
// end ; if team then
1473: LD_VAR 0 2
1477: IFFALSE 1520
// for i in team do
1479: LD_ADDR_VAR 0 10
1483: PUSH
1484: LD_VAR 0 2
1488: PUSH
1489: FOR_IN
1490: IFFALSE 1518
// begin PlaceUnitArea ( i , gammaBaseArea , false ) ;
1492: LD_VAR 0 10
1496: PPUSH
1497: LD_INT 1
1499: PPUSH
1500: LD_INT 0
1502: PPUSH
1503: CALL_OW 49
// ComHold ( i ) ;
1507: LD_VAR 0 10
1511: PPUSH
1512: CALL_OW 140
// end ;
1516: GO 1489
1518: POP
1519: POP
// if fac then
1520: LD_VAR 0 7
1524: IFFALSE 1560
// if UnitsInside ( fac [ 1 ] ) then
1526: LD_VAR 0 7
1530: PUSH
1531: LD_INT 1
1533: ARRAY
1534: PPUSH
1535: CALL_OW 313
1539: IFFALSE 1560
// SetSpecResearch ( fac [ 1 ] , 10 , false ) ;
1541: LD_VAR 0 7
1545: PUSH
1546: LD_INT 1
1548: ARRAY
1549: PPUSH
1550: LD_INT 10
1552: PPUSH
1553: LD_INT 0
1555: PPUSH
1556: CALL_OW 486
// if lab then
1560: LD_VAR 0 6
1564: IFFALSE 1600
// if UnitsInside ( lab [ 1 ] ) then
1566: LD_VAR 0 6
1570: PUSH
1571: LD_INT 1
1573: ARRAY
1574: PPUSH
1575: CALL_OW 313
1579: IFFALSE 1600
// SetSpecResearch ( lab [ 1 ] , 10 , false ) ;
1581: LD_VAR 0 6
1585: PUSH
1586: LD_INT 1
1588: ARRAY
1589: PPUSH
1590: LD_INT 10
1592: PPUSH
1593: LD_INT 0
1595: PPUSH
1596: CALL_OW 486
// veh := PrepareTank ( 1 , 1 , us_medium_tracked , engine_solar , control_manual , us_double_gun , 100 ) ;
1600: LD_ADDR_VAR 0 3
1604: PUSH
1605: LD_INT 1
1607: PPUSH
1608: LD_INT 1
1610: PPUSH
1611: LD_INT 3
1613: PPUSH
1614: LD_INT 2
1616: PPUSH
1617: LD_INT 1
1619: PPUSH
1620: LD_INT 5
1622: PPUSH
1623: LD_INT 100
1625: PPUSH
1626: CALL 2065 0 7
1630: ST_TO_ADDR
// SetDir ( veh , rand ( 0 , 5 ) ) ;
1631: LD_VAR 0 3
1635: PPUSH
1636: LD_INT 0
1638: PPUSH
1639: LD_INT 5
1641: PPUSH
1642: CALL_OW 12
1646: PPUSH
1647: CALL_OW 233
// PlaceUnitXYR ( veh , GetX ( dep [ 1 ] ) , GetY ( dep [ 1 ] ) , 15 , false ) ;
1651: LD_VAR 0 3
1655: PPUSH
1656: LD_VAR 0 4
1660: PUSH
1661: LD_INT 1
1663: ARRAY
1664: PPUSH
1665: CALL_OW 250
1669: PPUSH
1670: LD_VAR 0 4
1674: PUSH
1675: LD_INT 1
1677: ARRAY
1678: PPUSH
1679: CALL_OW 251
1683: PPUSH
1684: LD_INT 15
1686: PPUSH
1687: LD_INT 0
1689: PPUSH
1690: CALL_OW 50
// uc_side := 4 ;
1694: LD_ADDR_OWVAR 20
1698: PUSH
1699: LD_INT 4
1701: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
1702: LD_ADDR_EXP 15
1706: PUSH
1707: LD_STRING Powell
1709: PPUSH
1710: LD_INT 0
1712: PPUSH
1713: CALL 2002 0 2
1717: ST_TO_ADDR
// end ;
1718: LD_VAR 0 1
1722: RET
// function PrepareBase ; var blist , i , b ; begin
1723: LD_INT 0
1725: PPUSH
1726: PPUSH
1727: PPUSH
1728: PPUSH
// SetResourceVisibility ( 71 , 5 , 1 ) ;
1729: LD_INT 71
1731: PPUSH
1732: LD_INT 5
1734: PPUSH
1735: LD_INT 1
1737: PPUSH
1738: CALL_OW 441
// blist := LoadVariable ( 08_GammaBase , [ ] ) ;
1742: LD_ADDR_VAR 0 2
1746: PUSH
1747: LD_STRING 08_GammaBase
1749: PPUSH
1750: EMPTY
1751: PPUSH
1752: CALL_OW 30
1756: ST_TO_ADDR
// if not blist and debug then
1757: LD_VAR 0 2
1761: NOT
1762: PUSH
1763: LD_EXP 1
1767: AND
1768: IFFALSE 1808
// blist := [ [ b_depot , 51 , 10 , 3 , 3 , 0 , 0 ] ] ;
1770: LD_ADDR_VAR 0 2
1774: PUSH
1775: LD_INT 0
1777: PUSH
1778: LD_INT 51
1780: PUSH
1781: LD_INT 10
1783: PUSH
1784: LD_INT 3
1786: PUSH
1787: LD_INT 3
1789: PUSH
1790: LD_INT 0
1792: PUSH
1793: LD_INT 0
1795: PUSH
1796: EMPTY
1797: LIST
1798: LIST
1799: LIST
1800: LIST
1801: LIST
1802: LIST
1803: LIST
1804: PUSH
1805: EMPTY
1806: LIST
1807: ST_TO_ADDR
// if not blist then
1808: LD_VAR 0 2
1812: NOT
1813: IFFALSE 1817
// exit ;
1815: GO 1997
// uc_side := 1 ;
1817: LD_ADDR_OWVAR 20
1821: PUSH
1822: LD_INT 1
1824: ST_TO_ADDR
// uc_nation := 1 ;
1825: LD_ADDR_OWVAR 21
1829: PUSH
1830: LD_INT 1
1832: ST_TO_ADDR
// for i in blist do
1833: LD_ADDR_VAR 0 3
1837: PUSH
1838: LD_VAR 0 2
1842: PUSH
1843: FOR_IN
1844: IFFALSE 1995
// begin bc_type := i [ 1 ] ;
1846: LD_ADDR_OWVAR 42
1850: PUSH
1851: LD_VAR 0 3
1855: PUSH
1856: LD_INT 1
1858: ARRAY
1859: ST_TO_ADDR
// bc_level := i [ 5 ] ;
1860: LD_ADDR_OWVAR 43
1864: PUSH
1865: LD_VAR 0 3
1869: PUSH
1870: LD_INT 5
1872: ARRAY
1873: ST_TO_ADDR
// if i [ 1 ] in [ b_lab_half , b_lab_full ] then
1874: LD_VAR 0 3
1878: PUSH
1879: LD_INT 1
1881: ARRAY
1882: PUSH
1883: LD_INT 7
1885: PUSH
1886: LD_INT 8
1888: PUSH
1889: EMPTY
1890: LIST
1891: LIST
1892: IN
1893: IFFALSE 1923
// begin bc_kind1 := i [ 7 ] ;
1895: LD_ADDR_OWVAR 44
1899: PUSH
1900: LD_VAR 0 3
1904: PUSH
1905: LD_INT 7
1907: ARRAY
1908: ST_TO_ADDR
// bc_kind2 := i [ 8 ] ;
1909: LD_ADDR_OWVAR 45
1913: PUSH
1914: LD_VAR 0 3
1918: PUSH
1919: LD_INT 8
1921: ARRAY
1922: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1923: LD_ADDR_VAR 0 4
1927: PUSH
1928: LD_VAR 0 3
1932: PUSH
1933: LD_INT 2
1935: ARRAY
1936: PPUSH
1937: LD_VAR 0 3
1941: PUSH
1942: LD_INT 3
1944: ARRAY
1945: PPUSH
1946: LD_VAR 0 3
1950: PUSH
1951: LD_INT 4
1953: ARRAY
1954: PPUSH
1955: CALL_OW 47
1959: ST_TO_ADDR
// if GetBType ( b ) = b_bunker then
1960: LD_VAR 0 4
1964: PPUSH
1965: CALL_OW 266
1969: PUSH
1970: LD_INT 32
1972: EQUAL
1973: IFFALSE 1993
// begin PlaceWeaponTurret ( b , i [ 7 ] ) ;
1975: LD_VAR 0 4
1979: PPUSH
1980: LD_VAR 0 3
1984: PUSH
1985: LD_INT 7
1987: ARRAY
1988: PPUSH
1989: CALL_OW 431
// end ; end ;
1993: GO 1843
1995: POP
1996: POP
// end ; end_of_file
1997: LD_VAR 0 1
2001: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
2002: LD_INT 0
2004: PPUSH
2005: PPUSH
// if exist_mode then
2006: LD_VAR 0 2
2010: IFFALSE 2035
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
2012: LD_ADDR_VAR 0 4
2016: PUSH
2017: LD_EXP 3
2021: PUSH
2022: LD_VAR 0 1
2026: STR
2027: PPUSH
2028: CALL_OW 34
2032: ST_TO_ADDR
2033: GO 2050
// unit := NewCharacter ( ident ) ;
2035: LD_ADDR_VAR 0 4
2039: PUSH
2040: LD_VAR 0 1
2044: PPUSH
2045: CALL_OW 25
2049: ST_TO_ADDR
// result := unit ;
2050: LD_ADDR_VAR 0 3
2054: PUSH
2055: LD_VAR 0 4
2059: ST_TO_ADDR
// end ;
2060: LD_VAR 0 3
2064: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
2065: LD_INT 0
2067: PPUSH
// uc_side := side ;
2068: LD_ADDR_OWVAR 20
2072: PUSH
2073: LD_VAR 0 1
2077: ST_TO_ADDR
// uc_nation := nation ;
2078: LD_ADDR_OWVAR 21
2082: PUSH
2083: LD_VAR 0 2
2087: ST_TO_ADDR
// vc_chassis := chassis ;
2088: LD_ADDR_OWVAR 37
2092: PUSH
2093: LD_VAR 0 3
2097: ST_TO_ADDR
// vc_engine := engine ;
2098: LD_ADDR_OWVAR 39
2102: PUSH
2103: LD_VAR 0 4
2107: ST_TO_ADDR
// vc_control := control ;
2108: LD_ADDR_OWVAR 38
2112: PUSH
2113: LD_VAR 0 5
2117: ST_TO_ADDR
// vc_weapon := weapon ;
2118: LD_ADDR_OWVAR 40
2122: PUSH
2123: LD_VAR 0 6
2127: ST_TO_ADDR
// vc_fuel_battery := fuel ;
2128: LD_ADDR_OWVAR 41
2132: PUSH
2133: LD_VAR 0 7
2137: ST_TO_ADDR
// result := CreateVehicle ;
2138: LD_ADDR_VAR 0 8
2142: PUSH
2143: CALL_OW 45
2147: ST_TO_ADDR
// end ; end_of_file
2148: LD_VAR 0 8
2152: RET
// export function Action ; var i , tmp , fe , ma ; begin
2153: LD_INT 0
2155: PPUSH
2156: PPUSH
2157: PPUSH
2158: PPUSH
2159: PPUSH
// if Lisa then
2160: LD_EXP 7
2164: IFFALSE 2182
// tmp := tmp ^ Lisa ;
2166: LD_ADDR_VAR 0 3
2170: PUSH
2171: LD_VAR 0 3
2175: PUSH
2176: LD_EXP 7
2180: ADD
2181: ST_TO_ADDR
// if Frank then
2182: LD_EXP 6
2186: IFFALSE 2204
// tmp := tmp ^ Frank ;
2188: LD_ADDR_VAR 0 3
2192: PUSH
2193: LD_VAR 0 3
2197: PUSH
2198: LD_EXP 6
2202: ADD
2203: ST_TO_ADDR
// if Donaldson then
2204: LD_EXP 11
2208: IFFALSE 2226
// tmp := tmp ^ Donaldson ;
2210: LD_ADDR_VAR 0 3
2214: PUSH
2215: LD_VAR 0 3
2219: PUSH
2220: LD_EXP 11
2224: ADD
2225: ST_TO_ADDR
// if Joan then
2226: LD_EXP 8
2230: IFFALSE 2248
// tmp := tmp ^ Joan ;
2232: LD_ADDR_VAR 0 3
2236: PUSH
2237: LD_VAR 0 3
2241: PUSH
2242: LD_EXP 8
2246: ADD
2247: ST_TO_ADDR
// if Gladstone then
2248: LD_EXP 5
2252: IFFALSE 2270
// tmp := tmp ^ Gladstone ;
2254: LD_ADDR_VAR 0 3
2258: PUSH
2259: LD_VAR 0 3
2263: PUSH
2264: LD_EXP 5
2268: ADD
2269: ST_TO_ADDR
// tmp := tmp ^ FilterAllUnits ( [ [ f_type , unit_human ] , [ f_outside ] ] ) ;
2270: LD_ADDR_VAR 0 3
2274: PUSH
2275: LD_VAR 0 3
2279: PUSH
2280: LD_INT 21
2282: PUSH
2283: LD_INT 1
2285: PUSH
2286: EMPTY
2287: LIST
2288: LIST
2289: PUSH
2290: LD_INT 56
2292: PUSH
2293: EMPTY
2294: LIST
2295: PUSH
2296: EMPTY
2297: LIST
2298: LIST
2299: PPUSH
2300: CALL_OW 69
2304: ADD
2305: ST_TO_ADDR
// tmp := tmp diff 0 ;
2306: LD_ADDR_VAR 0 3
2310: PUSH
2311: LD_VAR 0 3
2315: PUSH
2316: LD_INT 0
2318: DIFF
2319: ST_TO_ADDR
// InGameOn ;
2320: CALL_OW 8
// CenterNowOnXY ( 50 , 14 ) ;
2324: LD_INT 50
2326: PPUSH
2327: LD_INT 14
2329: PPUSH
2330: CALL_OW 86
// SayRadio ( Powell , D1-Pow-1 ) ;
2334: LD_EXP 15
2338: PPUSH
2339: LD_STRING D1-Pow-1
2341: PPUSH
2342: CALL_OW 94
// ComExitBuilding ( JMM ) ;
2346: LD_EXP 4
2350: PPUSH
2351: CALL_OW 122
// AddComTurnXY ( JMM , 44 , 36 ) ;
2355: LD_EXP 4
2359: PPUSH
2360: LD_INT 44
2362: PPUSH
2363: LD_INT 36
2365: PPUSH
2366: CALL_OW 178
// Wait ( 0 0$0.3 ) ;
2370: LD_INT 10
2372: PPUSH
2373: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
2377: LD_EXP 4
2381: PPUSH
2382: LD_STRING D1-JMM-1
2384: PPUSH
2385: CALL_OW 88
// for i in tmp do
2389: LD_ADDR_VAR 0 2
2393: PUSH
2394: LD_VAR 0 3
2398: PUSH
2399: FOR_IN
2400: IFFALSE 2474
// begin if IsInUnit ( i ) then
2402: LD_VAR 0 2
2406: PPUSH
2407: CALL_OW 310
2411: IFFALSE 2422
// ComExitBuilding ( i ) ;
2413: LD_VAR 0 2
2417: PPUSH
2418: CALL_OW 122
// AddComMoveXY ( i , GetX ( JMM ) , GetY ( JMM ) ) ;
2422: LD_VAR 0 2
2426: PPUSH
2427: LD_EXP 4
2431: PPUSH
2432: CALL_OW 250
2436: PPUSH
2437: LD_EXP 4
2441: PPUSH
2442: CALL_OW 251
2446: PPUSH
2447: CALL_OW 171
// wait ( 3 ) ;
2451: LD_INT 3
2453: PPUSH
2454: CALL_OW 67
// ComTurnUnit ( i , JMM ) ;
2458: LD_VAR 0 2
2462: PPUSH
2463: LD_EXP 4
2467: PPUSH
2468: CALL_OW 119
// end ;
2472: GO 2399
2474: POP
2475: POP
// SayRadio ( Powell , D1-Pow-2 ) ;
2476: LD_EXP 15
2480: PPUSH
2481: LD_STRING D1-Pow-2
2483: PPUSH
2484: CALL_OW 94
// Say ( JMM , D1-JMM-2 ) ;
2488: LD_EXP 4
2492: PPUSH
2493: LD_STRING D1-JMM-2
2495: PPUSH
2496: CALL_OW 88
// SayRadio ( Powell , D1-Pow-3 ) ;
2500: LD_EXP 15
2504: PPUSH
2505: LD_STRING D1-Pow-3
2507: PPUSH
2508: CALL_OW 94
// Say ( JMM , D1-JMM-3 ) ;
2512: LD_EXP 4
2516: PPUSH
2517: LD_STRING D1-JMM-3
2519: PPUSH
2520: CALL_OW 88
// SayRadio ( Powell , D1-Pow-4 ) ;
2524: LD_EXP 15
2528: PPUSH
2529: LD_STRING D1-Pow-4
2531: PPUSH
2532: CALL_OW 94
// Say ( JMM , D1-JMM-4 ) ;
2536: LD_EXP 4
2540: PPUSH
2541: LD_STRING D1-JMM-4
2543: PPUSH
2544: CALL_OW 88
// SayRadio ( Powell , D1-Pow-5 ) ;
2548: LD_EXP 15
2552: PPUSH
2553: LD_STRING D1-Pow-5
2555: PPUSH
2556: CALL_OW 94
// Say ( JMM , D1-JMM-5 ) ;
2560: LD_EXP 4
2564: PPUSH
2565: LD_STRING D1-JMM-5
2567: PPUSH
2568: CALL_OW 88
// SayRadio ( Powell , D1-Pow-6 ) ;
2572: LD_EXP 15
2576: PPUSH
2577: LD_STRING D1-Pow-6
2579: PPUSH
2580: CALL_OW 94
// SayRadio ( Powell , D1-Pow-6a ) ;
2584: LD_EXP 15
2588: PPUSH
2589: LD_STRING D1-Pow-6a
2591: PPUSH
2592: CALL_OW 94
// SayRadio ( Powell , D1-Pow-6b ) ;
2596: LD_EXP 15
2600: PPUSH
2601: LD_STRING D1-Pow-6b
2603: PPUSH
2604: CALL_OW 94
// Say ( JMM , D1-JMM-6 ) ;
2608: LD_EXP 4
2612: PPUSH
2613: LD_STRING D1-JMM-6
2615: PPUSH
2616: CALL_OW 88
// Say ( JMM , D1-JMM-6a ) ;
2620: LD_EXP 4
2624: PPUSH
2625: LD_STRING D1-JMM-6a
2627: PPUSH
2628: CALL_OW 88
// SayRadio ( Powell , D1-Pow-7 ) ;
2632: LD_EXP 15
2636: PPUSH
2637: LD_STRING D1-Pow-7
2639: PPUSH
2640: CALL_OW 94
// Say ( JMM , D1-JMM-7 ) ;
2644: LD_EXP 4
2648: PPUSH
2649: LD_STRING D1-JMM-7
2651: PPUSH
2652: CALL_OW 88
// SayRadio ( Powell , D1-Pow-8 ) ;
2656: LD_EXP 15
2660: PPUSH
2661: LD_STRING D1-Pow-8
2663: PPUSH
2664: CALL_OW 94
// Say ( JMM , D1-JMM-8 ) ;
2668: LD_EXP 4
2672: PPUSH
2673: LD_STRING D1-JMM-8
2675: PPUSH
2676: CALL_OW 88
// SayRadio ( Powell , D1-Pow-9 ) ;
2680: LD_EXP 15
2684: PPUSH
2685: LD_STRING D1-Pow-9
2687: PPUSH
2688: CALL_OW 94
// fe := UnitFilter ( FilterAllUnits ( [ f_side , 1 ] ) , [ f_sex , sex_female ] ) diff [ Joan , Lisa , Donaldson ] ;
2692: LD_ADDR_VAR 0 4
2696: PUSH
2697: LD_INT 22
2699: PUSH
2700: LD_INT 1
2702: PUSH
2703: EMPTY
2704: LIST
2705: LIST
2706: PPUSH
2707: CALL_OW 69
2711: PPUSH
2712: LD_INT 26
2714: PUSH
2715: LD_INT 2
2717: PUSH
2718: EMPTY
2719: LIST
2720: LIST
2721: PPUSH
2722: CALL_OW 72
2726: PUSH
2727: LD_EXP 8
2731: PUSH
2732: LD_EXP 7
2736: PUSH
2737: LD_EXP 11
2741: PUSH
2742: EMPTY
2743: LIST
2744: LIST
2745: LIST
2746: DIFF
2747: ST_TO_ADDR
// ma := UnitFilter ( FilterAllUnits ( [ f_side , 1 ] ) , [ f_sex , sex_male ] ) diff [ JMM , Bobby , Cyrus , Gladstone , Khatam , Houten , Brown , Frank , Powell ] ;
2748: LD_ADDR_VAR 0 5
2752: PUSH
2753: LD_INT 22
2755: PUSH
2756: LD_INT 1
2758: PUSH
2759: EMPTY
2760: LIST
2761: LIST
2762: PPUSH
2763: CALL_OW 69
2767: PPUSH
2768: LD_INT 26
2770: PUSH
2771: LD_INT 1
2773: PUSH
2774: EMPTY
2775: LIST
2776: LIST
2777: PPUSH
2778: CALL_OW 72
2782: PUSH
2783: LD_EXP 4
2787: PUSH
2788: LD_EXP 10
2792: PUSH
2793: LD_EXP 9
2797: PUSH
2798: LD_EXP 5
2802: PUSH
2803: LD_EXP 14
2807: PUSH
2808: LD_EXP 13
2812: PUSH
2813: LD_EXP 12
2817: PUSH
2818: LD_EXP 6
2822: PUSH
2823: LD_EXP 15
2827: PUSH
2828: EMPTY
2829: LIST
2830: LIST
2831: LIST
2832: LIST
2833: LIST
2834: LIST
2835: LIST
2836: LIST
2837: LIST
2838: DIFF
2839: ST_TO_ADDR
// if Lisa then
2840: LD_EXP 7
2844: IFFALSE 2860
// Say ( Lisa , D1a-Lisa-1 ) else
2846: LD_EXP 7
2850: PPUSH
2851: LD_STRING D1a-Lisa-1
2853: PPUSH
2854: CALL_OW 88
2858: GO 2882
// if fe then
2860: LD_VAR 0 4
2864: IFFALSE 2882
// Say ( fe [ 1 ] , D1a-FSol1-1 ) ;
2866: LD_VAR 0 4
2870: PUSH
2871: LD_INT 1
2873: ARRAY
2874: PPUSH
2875: LD_STRING D1a-FSol1-1
2877: PPUSH
2878: CALL_OW 88
// if Lisa or fe then
2882: LD_EXP 7
2886: PUSH
2887: LD_VAR 0 4
2891: OR
2892: IFFALSE 2928
// begin if Frank then
2894: LD_EXP 6
2898: IFFALSE 2912
// Say ( Frank , D1a-Frank-1 ) ;
2900: LD_EXP 6
2904: PPUSH
2905: LD_STRING D1a-Frank-1
2907: PPUSH
2908: CALL_OW 88
// Say ( ma [ 1 ] , D1a-Sol1-1 ) ;
2912: LD_VAR 0 5
2916: PUSH
2917: LD_INT 1
2919: ARRAY
2920: PPUSH
2921: LD_STRING D1a-Sol1-1
2923: PPUSH
2924: CALL_OW 88
// end ; if Lisa then
2928: LD_EXP 7
2932: IFFALSE 2948
// Say ( Lisa , D1a-Lisa-2 ) else
2934: LD_EXP 7
2938: PPUSH
2939: LD_STRING D1a-Lisa-2
2941: PPUSH
2942: CALL_OW 88
2946: GO 2970
// if fe then
2948: LD_VAR 0 4
2952: IFFALSE 2970
// Say ( fe [ 1 ] , D1a-FSol1-2 ) ;
2954: LD_VAR 0 4
2958: PUSH
2959: LD_INT 1
2961: ARRAY
2962: PPUSH
2963: LD_STRING D1a-FSol1-2
2965: PPUSH
2966: CALL_OW 88
// if Lisa or fe then
2970: LD_EXP 7
2974: PUSH
2975: LD_VAR 0 4
2979: OR
2980: IFFALSE 3018
// begin if Frank then
2982: LD_EXP 6
2986: IFFALSE 3002
// Say ( Frank , D1a-Frank-2 ) else
2988: LD_EXP 6
2992: PPUSH
2993: LD_STRING D1a-Frank-2
2995: PPUSH
2996: CALL_OW 88
3000: GO 3018
// Say ( ma [ 1 ] , D1a-Sol1-2 ) ;
3002: LD_VAR 0 5
3006: PUSH
3007: LD_INT 1
3009: ARRAY
3010: PPUSH
3011: LD_STRING D1a-Sol1-2
3013: PPUSH
3014: CALL_OW 88
// end ; if Lisa then
3018: LD_EXP 7
3022: IFFALSE 3036
// Say ( Lisa , D1a-Lisa-3 ) ;
3024: LD_EXP 7
3028: PPUSH
3029: LD_STRING D1a-Lisa-3
3031: PPUSH
3032: CALL_OW 88
// if fe then
3036: LD_VAR 0 4
3040: IFFALSE 3058
// Say ( fe [ 1 ] , D1a-FSol1-3 ) ;
3042: LD_VAR 0 4
3046: PUSH
3047: LD_INT 1
3049: ARRAY
3050: PPUSH
3051: LD_STRING D1a-FSol1-3
3053: PPUSH
3054: CALL_OW 88
// if Lisa or fe then
3058: LD_EXP 7
3062: PUSH
3063: LD_VAR 0 4
3067: OR
3068: IFFALSE 3082
// Say ( JMM , D1a-JMM-3 ) ;
3070: LD_EXP 4
3074: PPUSH
3075: LD_STRING D1a-JMM-3
3077: PPUSH
3078: CALL_OW 88
// if Lisa then
3082: LD_EXP 7
3086: IFFALSE 3114
// begin ComTurnUnit ( JMM , Lisa ) ;
3088: LD_EXP 4
3092: PPUSH
3093: LD_EXP 7
3097: PPUSH
3098: CALL_OW 119
// Say ( Lisa , D1b-Lisa-1 ) ;
3102: LD_EXP 7
3106: PPUSH
3107: LD_STRING D1b-Lisa-1
3109: PPUSH
3110: CALL_OW 88
// end ; if Gladstone then
3114: LD_EXP 5
3118: IFFALSE 3146
// begin ComTurnUnit ( JMM , Gladstone ) ;
3120: LD_EXP 4
3124: PPUSH
3125: LD_EXP 5
3129: PPUSH
3130: CALL_OW 119
// Say ( Gladstone , D1b-Glad-1 ) ;
3134: LD_EXP 5
3138: PPUSH
3139: LD_STRING D1b-Glad-1
3141: PPUSH
3142: CALL_OW 88
// end ; if Joan then
3146: LD_EXP 8
3150: IFFALSE 3178
// begin ComTurnUnit ( JMM , Joan ) ;
3152: LD_EXP 4
3156: PPUSH
3157: LD_EXP 8
3161: PPUSH
3162: CALL_OW 119
// Say ( Joan , D1b-Joan-1 ) ;
3166: LD_EXP 8
3170: PPUSH
3171: LD_STRING D1b-Joan-1
3173: PPUSH
3174: CALL_OW 88
// end ; if Donaldson then
3178: LD_EXP 11
3182: IFFALSE 3210
// begin ComTurnUnit ( JMM , Donaldson ) ;
3184: LD_EXP 4
3188: PPUSH
3189: LD_EXP 11
3193: PPUSH
3194: CALL_OW 119
// Say ( Donaldson , D1b-Don-1 ) ;
3198: LD_EXP 11
3202: PPUSH
3203: LD_STRING D1b-Don-1
3205: PPUSH
3206: CALL_OW 88
// end ; ComEnterUnit ( JMM , FilterAllUnits ( [ f_type , unit_vehicle ] ) [ 1 ] ) ;
3210: LD_EXP 4
3214: PPUSH
3215: LD_INT 21
3217: PUSH
3218: LD_INT 2
3220: PUSH
3221: EMPTY
3222: LIST
3223: LIST
3224: PPUSH
3225: CALL_OW 69
3229: PUSH
3230: LD_INT 1
3232: ARRAY
3233: PPUSH
3234: CALL_OW 120
// AddComMoveXY ( JMM , 37 , 29 ) ;
3238: LD_EXP 4
3242: PPUSH
3243: LD_INT 37
3245: PPUSH
3246: LD_INT 29
3248: PPUSH
3249: CALL_OW 171
// Wait ( 0 0$04 ) ;
3253: LD_INT 140
3255: PPUSH
3256: CALL_OW 67
// ChangeMap ( 1 , __am\09_cont2 ) ;
3260: LD_INT 1
3262: PPUSH
3263: LD_STRING __am\09_cont2
3265: PPUSH
3266: CALL_OW 340
// end ;
3270: LD_VAR 0 1
3274: RET
