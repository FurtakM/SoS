// export JMM ; export Joan , Lisa , Connie ; export Powell ; export Eisenstein ; export JMMGirl , JMMGirlStaus ; export amLaserCounter ; export ruDestroyedBuildings , russianTanks , russianTimeLapsers ; export russianAI ; export russianRocketsAvalaible ; export fastEnd ; export debugMode , destroyCounter ; starting begin Resetfog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// SetBName ( ru_depot , vasilev ) ;
   8: LD_INT 22
  10: PPUSH
  11: LD_STRING vasilev
  13: PPUSH
  14: CALL_OW 500
// fastEnd = 0 ;
  18: LD_ADDR_EXP 15
  22: PUSH
  23: LD_INT 0
  25: ST_TO_ADDR
// JMMGirl = 0 ;
  26: LD_ADDR_EXP 7
  30: PUSH
  31: LD_INT 0
  33: ST_TO_ADDR
// JMMGirlStaus = 0 ;
  34: LD_ADDR_EXP 8
  38: PUSH
  39: LD_INT 0
  41: ST_TO_ADDR
// amLaserCounter = 0 ;
  42: LD_ADDR_EXP 9
  46: PUSH
  47: LD_INT 0
  49: ST_TO_ADDR
// destroyCounter := 0 ;
  50: LD_ADDR_EXP 17
  54: PUSH
  55: LD_INT 0
  57: ST_TO_ADDR
// ruDestroyedBuildings = [ ] ;
  58: LD_ADDR_EXP 10
  62: PUSH
  63: EMPTY
  64: ST_TO_ADDR
// russianTanks = [ ] ;
  65: LD_ADDR_EXP 11
  69: PUSH
  70: EMPTY
  71: ST_TO_ADDR
// russianTimeLapsers = [ ] ;
  72: LD_ADDR_EXP 12
  76: PUSH
  77: EMPTY
  78: ST_TO_ADDR
// russianRocketsAvalaible = LoadVariable ( 12_SciDed_1 , 1 ) ;
  79: LD_ADDR_EXP 14
  83: PUSH
  84: LD_STRING 12_SciDed_1
  86: PPUSH
  87: LD_INT 1
  89: PPUSH
  90: CALL_OW 30
  94: ST_TO_ADDR
// russianAI = 0 ;
  95: LD_ADDR_EXP 13
  99: PUSH
 100: LD_INT 0
 102: ST_TO_ADDR
// debugMode = 0 ;
 103: LD_ADDR_EXP 16
 107: PUSH
 108: LD_INT 0
 110: ST_TO_ADDR
// PrepareNature ;
 111: CALL 1350 0 0
// PrepareDifficulty ;
 115: CALL 1703 0 0
// PrepareHero ;
 119: CALL 564 0 0
// PrepareRemoteVehs ;
 123: CALL 873 0 0
// PrepareRussianBase ;
 127: CALL 1113 0 0
// PrepareCommander ;
 131: CALL 1058 0 0
// end ;
 135: END
// every 0 0$1 trigger debugMode = 1 do var i ;
 136: LD_EXP 16
 140: PUSH
 141: LD_INT 1
 143: EQUAL
 144: IFFALSE 450
 146: GO 148
 148: DISABLE
 149: LD_INT 0
 151: PPUSH
// begin enable ;
 152: ENABLE
// fogoff ( true ) ;
 153: LD_INT 1
 155: PPUSH
 156: CALL_OW 344
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) do
 160: LD_ADDR_VAR 0 1
 164: PUSH
 165: LD_INT 22
 167: PUSH
 168: LD_INT 1
 170: PUSH
 171: EMPTY
 172: LIST
 173: LIST
 174: PUSH
 175: LD_INT 21
 177: PUSH
 178: LD_INT 1
 180: PUSH
 181: EMPTY
 182: LIST
 183: LIST
 184: PUSH
 185: EMPTY
 186: LIST
 187: LIST
 188: PPUSH
 189: CALL_OW 69
 193: PUSH
 194: FOR_IN
 195: IFFALSE 211
// SetLives ( i , 1000 ) ;
 197: LD_VAR 0 1
 201: PPUSH
 202: LD_INT 1000
 204: PPUSH
 205: CALL_OW 234
 209: GO 194
 211: POP
 212: POP
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , 0 ] , [ f_btype , 1 ] ] ] ) do
 213: LD_ADDR_VAR 0 1
 217: PUSH
 218: LD_INT 22
 220: PUSH
 221: LD_INT 1
 223: PUSH
 224: EMPTY
 225: LIST
 226: LIST
 227: PUSH
 228: LD_INT 2
 230: PUSH
 231: LD_INT 30
 233: PUSH
 234: LD_INT 0
 236: PUSH
 237: EMPTY
 238: LIST
 239: LIST
 240: PUSH
 241: LD_INT 30
 243: PUSH
 244: LD_INT 1
 246: PUSH
 247: EMPTY
 248: LIST
 249: LIST
 250: PUSH
 251: EMPTY
 252: LIST
 253: LIST
 254: LIST
 255: PUSH
 256: EMPTY
 257: LIST
 258: LIST
 259: PPUSH
 260: CALL_OW 69
 264: PUSH
 265: FOR_IN
 266: IFFALSE 290
// SetResourceType ( GetBase ( i ) , 1 , 9999 ) ;
 268: LD_VAR 0 1
 272: PPUSH
 273: CALL_OW 274
 277: PPUSH
 278: LD_INT 1
 280: PPUSH
 281: LD_INT 9999
 283: PPUSH
 284: CALL_OW 277
 288: GO 265
 290: POP
 291: POP
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , 0 ] , [ f_btype , 1 ] ] ] ) do
 292: LD_ADDR_VAR 0 1
 296: PUSH
 297: LD_INT 22
 299: PUSH
 300: LD_INT 1
 302: PUSH
 303: EMPTY
 304: LIST
 305: LIST
 306: PUSH
 307: LD_INT 2
 309: PUSH
 310: LD_INT 30
 312: PUSH
 313: LD_INT 0
 315: PUSH
 316: EMPTY
 317: LIST
 318: LIST
 319: PUSH
 320: LD_INT 30
 322: PUSH
 323: LD_INT 1
 325: PUSH
 326: EMPTY
 327: LIST
 328: LIST
 329: PUSH
 330: EMPTY
 331: LIST
 332: LIST
 333: LIST
 334: PUSH
 335: EMPTY
 336: LIST
 337: LIST
 338: PPUSH
 339: CALL_OW 69
 343: PUSH
 344: FOR_IN
 345: IFFALSE 369
// SetResourceType ( GetBase ( i ) , 2 , 9999 ) ;
 347: LD_VAR 0 1
 351: PPUSH
 352: CALL_OW 274
 356: PPUSH
 357: LD_INT 2
 359: PPUSH
 360: LD_INT 9999
 362: PPUSH
 363: CALL_OW 277
 367: GO 344
 369: POP
 370: POP
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , 0 ] , [ f_btype , 1 ] ] ] ) do
 371: LD_ADDR_VAR 0 1
 375: PUSH
 376: LD_INT 22
 378: PUSH
 379: LD_INT 1
 381: PUSH
 382: EMPTY
 383: LIST
 384: LIST
 385: PUSH
 386: LD_INT 2
 388: PUSH
 389: LD_INT 30
 391: PUSH
 392: LD_INT 0
 394: PUSH
 395: EMPTY
 396: LIST
 397: LIST
 398: PUSH
 399: LD_INT 30
 401: PUSH
 402: LD_INT 1
 404: PUSH
 405: EMPTY
 406: LIST
 407: LIST
 408: PUSH
 409: EMPTY
 410: LIST
 411: LIST
 412: LIST
 413: PUSH
 414: EMPTY
 415: LIST
 416: LIST
 417: PPUSH
 418: CALL_OW 69
 422: PUSH
 423: FOR_IN
 424: IFFALSE 448
// SetResourceType ( GetBase ( i ) , 3 , 9999 ) ;
 426: LD_VAR 0 1
 430: PPUSH
 431: CALL_OW 274
 435: PPUSH
 436: LD_INT 3
 438: PPUSH
 439: LD_INT 9999
 441: PPUSH
 442: CALL_OW 277
 446: GO 423
 448: POP
 449: POP
// end ;
 450: PPOPN 1
 452: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_turret ] ] ) >= 15 do
 453: LD_INT 22
 455: PUSH
 456: LD_INT 1
 458: PUSH
 459: EMPTY
 460: LIST
 461: LIST
 462: PUSH
 463: LD_INT 30
 465: PUSH
 466: LD_INT 33
 468: PUSH
 469: EMPTY
 470: LIST
 471: LIST
 472: PUSH
 473: EMPTY
 474: LIST
 475: LIST
 476: PPUSH
 477: CALL_OW 69
 481: PUSH
 482: LD_INT 15
 484: GREATEREQUAL
 485: IFFALSE 497
 487: GO 489
 489: DISABLE
// SetAchievement ( ACH_FORT ) ;
 490: LD_STRING ACH_FORT
 492: PPUSH
 493: CALL_OW 543
 497: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) = 0 do
 498: LD_INT 22
 500: PUSH
 501: LD_INT 0
 503: PUSH
 504: EMPTY
 505: LIST
 506: LIST
 507: PUSH
 508: LD_INT 25
 510: PUSH
 511: LD_INT 12
 513: PUSH
 514: EMPTY
 515: LIST
 516: LIST
 517: PUSH
 518: EMPTY
 519: LIST
 520: LIST
 521: PPUSH
 522: CALL_OW 69
 526: PUSH
 527: LD_INT 0
 529: EQUAL
 530: IFFALSE 542
 532: GO 534
 534: DISABLE
// SetAchievement ( ACH_APE ) ;
 535: LD_STRING ACH_APE
 537: PPUSH
 538: CALL_OW 543
 542: END
// every 0 0$1 trigger destroyCounter >= 20 do
 543: LD_EXP 17
 547: PUSH
 548: LD_INT 20
 550: GREATEREQUAL
 551: IFFALSE 563
 553: GO 555
 555: DISABLE
// SetAchievement ( ACH_DOUBLE ) ; end_of_file
 556: LD_STRING ACH_DOUBLE
 558: PPUSH
 559: CALL_OW 543
 563: END
// export function PrepareHero ; begin
 564: LD_INT 0
 566: PPUSH
// uc_side = 1 ;
 567: LD_ADDR_OWVAR 20
 571: PUSH
 572: LD_INT 1
 574: ST_TO_ADDR
// uc_nation = 1 ;
 575: LD_ADDR_OWVAR 21
 579: PUSH
 580: LD_INT 1
 582: ST_TO_ADDR
// JMM = PrepareUnit ( 13f_JMM , true ) ;
 583: LD_ADDR_EXP 1
 587: PUSH
 588: LD_STRING 13f_JMM
 590: PPUSH
 591: LD_INT 1
 593: PPUSH
 594: CALL 1496 0 2
 598: ST_TO_ADDR
// if debugMode then
 599: LD_EXP 16
 603: IFFALSE 618
// JMM := NewCharacter ( JMM ) ;
 605: LD_ADDR_EXP 1
 609: PUSH
 610: LD_STRING JMM
 612: PPUSH
 613: CALL_OW 25
 617: ST_TO_ADDR
// PlaceHumanInUnit ( JMM , JMMveh ) ;
 618: LD_EXP 1
 622: PPUSH
 623: LD_INT 95
 625: PPUSH
 626: CALL_OW 52
// SetClass ( JMM , 1 ) ;
 630: LD_EXP 1
 634: PPUSH
 635: LD_INT 1
 637: PPUSH
 638: CALL_OW 336
// Powell = PrepareUnit ( Powell , false ) ;
 642: LD_ADDR_EXP 5
 646: PUSH
 647: LD_STRING Powell
 649: PPUSH
 650: LD_INT 0
 652: PPUSH
 653: CALL 1496 0 2
 657: ST_TO_ADDR
// uc_side = 4 ;
 658: LD_ADDR_OWVAR 20
 662: PUSH
 663: LD_INT 4
 665: ST_TO_ADDR
// Joan = PrepareUnit ( 10c_Joan , true ) ;
 666: LD_ADDR_EXP 2
 670: PUSH
 671: LD_STRING 10c_Joan
 673: PPUSH
 674: LD_INT 1
 676: PPUSH
 677: CALL 1496 0 2
 681: ST_TO_ADDR
// if Joan then
 682: LD_EXP 2
 686: IFFALSE 725
// begin PlaceUnitArea ( Joan , JoanSpawn , false ) ;
 688: LD_EXP 2
 692: PPUSH
 693: LD_INT 4
 695: PPUSH
 696: LD_INT 0
 698: PPUSH
 699: CALL_OW 49
// SetClass ( Joan , 4 ) ;
 703: LD_EXP 2
 707: PPUSH
 708: LD_INT 4
 710: PPUSH
 711: CALL_OW 336
// JMMGirl = 1 ;
 715: LD_ADDR_EXP 7
 719: PUSH
 720: LD_INT 1
 722: ST_TO_ADDR
// end else
 723: GO 782
// begin Lisa = PrepareUnit ( 13s_Lisa , true ) ;
 725: LD_ADDR_EXP 3
 729: PUSH
 730: LD_STRING 13s_Lisa
 732: PPUSH
 733: LD_INT 1
 735: PPUSH
 736: CALL 1496 0 2
 740: ST_TO_ADDR
// if Lisa then
 741: LD_EXP 3
 745: IFFALSE 782
// begin PlaceUnitArea ( Lisa , JoanSpawn , false ) ;
 747: LD_EXP 3
 751: PPUSH
 752: LD_INT 4
 754: PPUSH
 755: LD_INT 0
 757: PPUSH
 758: CALL_OW 49
// SetClass ( Lisa , 1 ) ;
 762: LD_EXP 3
 766: PPUSH
 767: LD_INT 1
 769: PPUSH
 770: CALL_OW 336
// JMMGirl = 2 ;
 774: LD_ADDR_EXP 7
 778: PUSH
 779: LD_INT 2
 781: ST_TO_ADDR
// end ; end ; if not Joan and not Lisa then
 782: LD_EXP 2
 786: NOT
 787: PUSH
 788: LD_EXP 3
 792: NOT
 793: AND
 794: IFFALSE 844
// begin Connie = NewCharacter ( Coonie ) ;
 796: LD_ADDR_EXP 4
 800: PUSH
 801: LD_STRING Coonie
 803: PPUSH
 804: CALL_OW 25
 808: ST_TO_ADDR
// PlaceUnitArea ( Connie , JoanSpawn , false ) ;
 809: LD_EXP 4
 813: PPUSH
 814: LD_INT 4
 816: PPUSH
 817: LD_INT 0
 819: PPUSH
 820: CALL_OW 49
// SetClass ( Connie , 3 ) ;
 824: LD_EXP 4
 828: PPUSH
 829: LD_INT 3
 831: PPUSH
 832: CALL_OW 336
// JMMGirl = 3 ;
 836: LD_ADDR_EXP 7
 840: PUSH
 841: LD_INT 3
 843: ST_TO_ADDR
// end ; ComHold ( [ Joan , Lisa , Connie ] ) ;
 844: LD_EXP 2
 848: PUSH
 849: LD_EXP 3
 853: PUSH
 854: LD_EXP 4
 858: PUSH
 859: EMPTY
 860: LIST
 861: LIST
 862: LIST
 863: PPUSH
 864: CALL_OW 140
// end ;
 868: LD_VAR 0 1
 872: RET
// export function PrepareRemoteVehs ; var i , veh ; begin
 873: LD_INT 0
 875: PPUSH
 876: PPUSH
 877: PPUSH
// for i = 1 to 5 do
 878: LD_ADDR_VAR 0 2
 882: PUSH
 883: DOUBLE
 884: LD_INT 1
 886: DEC
 887: ST_TO_ADDR
 888: LD_INT 5
 890: PUSH
 891: FOR_TO
 892: IFFALSE 1051
// begin vc_engine = rand ( 1 , 3 ) ;
 894: LD_ADDR_OWVAR 39
 898: PUSH
 899: LD_INT 1
 901: PPUSH
 902: LD_INT 3
 904: PPUSH
 905: CALL_OW 12
 909: ST_TO_ADDR
// vc_control = control_remote ;
 910: LD_ADDR_OWVAR 38
 914: PUSH
 915: LD_INT 2
 917: ST_TO_ADDR
// vc_weapon = [ us_double_gun , us_cargo_bay , us_crane , us_rocket_launcher ] [ i mod 4 + 1 ] ;
 918: LD_ADDR_OWVAR 40
 922: PUSH
 923: LD_INT 5
 925: PUSH
 926: LD_INT 12
 928: PUSH
 929: LD_INT 13
 931: PUSH
 932: LD_INT 7
 934: PUSH
 935: EMPTY
 936: LIST
 937: LIST
 938: LIST
 939: LIST
 940: PUSH
 941: LD_VAR 0 2
 945: PUSH
 946: LD_INT 4
 948: MOD
 949: PUSH
 950: LD_INT 1
 952: PLUS
 953: ARRAY
 954: ST_TO_ADDR
// vc_chassis = [ us_medium_tracked , us_medium_wheeled ] [ i mod 2 + 1 ] ;
 955: LD_ADDR_OWVAR 37
 959: PUSH
 960: LD_INT 3
 962: PUSH
 963: LD_INT 2
 965: PUSH
 966: EMPTY
 967: LIST
 968: LIST
 969: PUSH
 970: LD_VAR 0 2
 974: PUSH
 975: LD_INT 2
 977: MOD
 978: PUSH
 979: LD_INT 1
 981: PLUS
 982: ARRAY
 983: ST_TO_ADDR
// veh = CreateVehicle ;
 984: LD_ADDR_VAR 0 3
 988: PUSH
 989: CALL_OW 45
 993: ST_TO_ADDR
// SetDir ( veh , rand ( 0 , 5 ) ) ;
 994: LD_VAR 0 3
 998: PPUSH
 999: LD_INT 0
1001: PPUSH
1002: LD_INT 5
1004: PPUSH
1005: CALL_OW 12
1009: PPUSH
1010: CALL_OW 233
// SetLives ( veh , rand ( 500 , 1000 ) ) ;
1014: LD_VAR 0 3
1018: PPUSH
1019: LD_INT 500
1021: PPUSH
1022: LD_INT 1000
1024: PPUSH
1025: CALL_OW 12
1029: PPUSH
1030: CALL_OW 234
// PlaceUnitArea ( veh , AmRemoteVehSpawn , false ) ;
1034: LD_VAR 0 3
1038: PPUSH
1039: LD_INT 15
1041: PPUSH
1042: LD_INT 0
1044: PPUSH
1045: CALL_OW 49
// end ;
1049: GO 891
1051: POP
1052: POP
// end ; end_of_file
1053: LD_VAR 0 1
1057: RET
// export function PrepareCommander ; begin
1058: LD_INT 0
1060: PPUSH
// uc_side = 3 ;
1061: LD_ADDR_OWVAR 20
1065: PUSH
1066: LD_INT 3
1068: ST_TO_ADDR
// uc_nation = 3 ;
1069: LD_ADDR_OWVAR 21
1073: PUSH
1074: LD_INT 3
1076: ST_TO_ADDR
// Eisenstein = PrepareUnit ( Eisenstein , false ) ;
1077: LD_ADDR_EXP 6
1081: PUSH
1082: LD_STRING Eisenstein
1084: PPUSH
1085: LD_INT 0
1087: PPUSH
1088: CALL 1496 0 2
1092: ST_TO_ADDR
// PlaceUnitArea ( Eisenstein , CommanderSpawn , false ) ;
1093: LD_EXP 6
1097: PPUSH
1098: LD_INT 11
1100: PPUSH
1101: LD_INT 0
1103: PPUSH
1104: CALL_OW 49
// end ;
1108: LD_VAR 0 1
1112: RET
// export baseGuard ; export function PrepareRussianBase ; begin
1113: LD_INT 0
1115: PPUSH
// uc_nation := 3 ;
1116: LD_ADDR_OWVAR 21
1120: PUSH
1121: LD_INT 3
1123: ST_TO_ADDR
// uc_side := 3 ;
1124: LD_ADDR_OWVAR 20
1128: PUSH
1129: LD_INT 3
1131: ST_TO_ADDR
// if Difficulty > 1 then
1132: LD_OWVAR 67
1136: PUSH
1137: LD_INT 1
1139: GREATER
1140: IFFALSE 1200
// begin PrepareHuman ( sex_male , 1 , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
1142: LD_INT 1
1144: PPUSH
1145: LD_INT 1
1147: PPUSH
1148: LD_INT 8
1150: PUSH
1151: LD_INT 8
1153: PUSH
1154: LD_INT 9
1156: PUSH
1157: EMPTY
1158: LIST
1159: LIST
1160: LIST
1161: PUSH
1162: LD_OWVAR 67
1166: ARRAY
1167: PPUSH
1168: CALL_OW 380
// baseGuard := CreateHuman ;
1172: LD_ADDR_EXP 18
1176: PUSH
1177: CALL_OW 44
1181: ST_TO_ADDR
// PlaceUnitXY ( baseGuard , 39 , 67 , false ) ;
1182: LD_EXP 18
1186: PPUSH
1187: LD_INT 39
1189: PPUSH
1190: LD_INT 67
1192: PPUSH
1193: LD_INT 0
1195: PPUSH
1196: CALL_OW 48
// end ; TeleportExit ( ruTeleport , 50 , 74 ) ;
1200: LD_INT 116
1202: PPUSH
1203: LD_INT 50
1205: PPUSH
1206: LD_INT 74
1208: PPUSH
1209: CALL_OW 243
// RespawnInside ( 3 , 3 , ru_barac , 10 , 9 , 2 ) ;
1213: LD_INT 3
1215: PPUSH
1216: LD_INT 3
1218: PPUSH
1219: LD_INT 45
1221: PPUSH
1222: LD_INT 10
1224: PPUSH
1225: LD_INT 9
1227: PPUSH
1228: LD_INT 2
1230: PPUSH
1231: CALL 1593 0 6
// RespawnInside ( 3 , 3 , ru_depot , 10 , 2 , 2 ) ;
1235: LD_INT 3
1237: PPUSH
1238: LD_INT 3
1240: PPUSH
1241: LD_INT 22
1243: PPUSH
1244: LD_INT 10
1246: PPUSH
1247: LD_INT 2
1249: PPUSH
1250: LD_INT 2
1252: PPUSH
1253: CALL 1593 0 6
// RespawnInside ( 3 , 3 , ru_fact1 , 10 , 3 , 3 ) ;
1257: LD_INT 3
1259: PPUSH
1260: LD_INT 3
1262: PPUSH
1263: LD_INT 1
1265: PPUSH
1266: LD_INT 10
1268: PPUSH
1269: LD_INT 3
1271: PPUSH
1272: LD_INT 3
1274: PPUSH
1275: CALL 1593 0 6
// RespawnInside ( 3 , 3 , ru_fact2 , 10 , 3 , 3 ) ;
1279: LD_INT 3
1281: PPUSH
1282: LD_INT 3
1284: PPUSH
1285: LD_INT 40
1287: PPUSH
1288: LD_INT 10
1290: PPUSH
1291: LD_INT 3
1293: PPUSH
1294: LD_INT 3
1296: PPUSH
1297: CALL 1593 0 6
// RespawnInside ( 3 , 3 , ru_lab1 , 10 , 4 , 1 ) ;
1301: LD_INT 3
1303: PPUSH
1304: LD_INT 3
1306: PPUSH
1307: LD_INT 14
1309: PPUSH
1310: LD_INT 10
1312: PPUSH
1313: LD_INT 4
1315: PPUSH
1316: LD_INT 1
1318: PPUSH
1319: CALL 1593 0 6
// RespawnInside ( 3 , 3 , ru_lab2 , 10 , 4 , 2 ) ;
1323: LD_INT 3
1325: PPUSH
1326: LD_INT 3
1328: PPUSH
1329: LD_INT 15
1331: PPUSH
1332: LD_INT 10
1334: PPUSH
1335: LD_INT 4
1337: PPUSH
1338: LD_INT 2
1340: PPUSH
1341: CALL 1593 0 6
// end ; end_of_file
1345: LD_VAR 0 1
1349: RET
// export function PrepareNature ; var i ; begin
1350: LD_INT 0
1352: PPUSH
1353: PPUSH
// uc_side := 0 ;
1354: LD_ADDR_OWVAR 20
1358: PUSH
1359: LD_INT 0
1361: ST_TO_ADDR
// uc_nation := 0 ;
1362: LD_ADDR_OWVAR 21
1366: PUSH
1367: LD_INT 0
1369: ST_TO_ADDR
// hc_class := class_apeman ;
1370: LD_ADDR_OWVAR 28
1374: PUSH
1375: LD_INT 12
1377: ST_TO_ADDR
// hc_gallery :=  ;
1378: LD_ADDR_OWVAR 33
1382: PUSH
1383: LD_STRING 
1385: ST_TO_ADDR
// hc_name :=  ;
1386: LD_ADDR_OWVAR 26
1390: PUSH
1391: LD_STRING 
1393: ST_TO_ADDR
// for i = 1 to 7 do
1394: LD_ADDR_VAR 0 2
1398: PUSH
1399: DOUBLE
1400: LD_INT 1
1402: DEC
1403: ST_TO_ADDR
1404: LD_INT 7
1406: PUSH
1407: FOR_TO
1408: IFFALSE 1489
// begin hc_class := class_apeman ;
1410: LD_ADDR_OWVAR 28
1414: PUSH
1415: LD_INT 12
1417: ST_TO_ADDR
// hc_gallery :=  ;
1418: LD_ADDR_OWVAR 33
1422: PUSH
1423: LD_STRING 
1425: ST_TO_ADDR
// hc_name :=  ;
1426: LD_ADDR_OWVAR 26
1430: PUSH
1431: LD_STRING 
1433: ST_TO_ADDR
// hc_skills := [ 1 , 0 , 0 , 0 ] ;
1434: LD_ADDR_OWVAR 31
1438: PUSH
1439: LD_INT 1
1441: PUSH
1442: LD_INT 0
1444: PUSH
1445: LD_INT 0
1447: PUSH
1448: LD_INT 0
1450: PUSH
1451: EMPTY
1452: LIST
1453: LIST
1454: LIST
1455: LIST
1456: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
1457: LD_ADDR_OWVAR 29
1461: PUSH
1462: LD_INT 11
1464: PUSH
1465: LD_INT 10
1467: PUSH
1468: EMPTY
1469: LIST
1470: LIST
1471: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , apeSpawn , false ) ;
1472: CALL_OW 44
1476: PPUSH
1477: LD_INT 16
1479: PPUSH
1480: LD_INT 0
1482: PPUSH
1483: CALL_OW 49
// end ;
1487: GO 1407
1489: POP
1490: POP
// end ;
1491: LD_VAR 0 1
1495: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
1496: LD_INT 0
1498: PPUSH
1499: PPUSH
// if exist_mode then
1500: LD_VAR 0 2
1504: IFFALSE 1523
// begin unit := CreateCharacter ( ident ) ;
1506: LD_ADDR_VAR 0 4
1510: PUSH
1511: LD_VAR 0 1
1515: PPUSH
1516: CALL_OW 34
1520: ST_TO_ADDR
// end else
1521: GO 1538
// begin unit := NewCharacter ( ident ) ;
1523: LD_ADDR_VAR 0 4
1527: PUSH
1528: LD_VAR 0 1
1532: PPUSH
1533: CALL_OW 25
1537: ST_TO_ADDR
// end ; result := unit ;
1538: LD_ADDR_VAR 0 3
1542: PUSH
1543: LD_VAR 0 4
1547: ST_TO_ADDR
// end ;
1548: LD_VAR 0 3
1552: RET
// export function EnchancedSaveCharacters ( charactersList , ident ) ; var i ; begin
1553: LD_INT 0
1555: PPUSH
1556: PPUSH
// for i in charactersList do
1557: LD_ADDR_VAR 0 4
1561: PUSH
1562: LD_VAR 0 1
1566: PUSH
1567: FOR_IN
1568: IFFALSE 1586
// SaveCharacters ( i , ident ) ;
1570: LD_VAR 0 4
1574: PPUSH
1575: LD_VAR 0 2
1579: PPUSH
1580: CALL_OW 38
1584: GO 1567
1586: POP
1587: POP
// end ;
1588: LD_VAR 0 3
1592: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
1593: LD_INT 0
1595: PPUSH
1596: PPUSH
1597: PPUSH
1598: PPUSH
// for i = 1 to count do
1599: LD_ADDR_VAR 0 8
1603: PUSH
1604: DOUBLE
1605: LD_INT 1
1607: DEC
1608: ST_TO_ADDR
1609: LD_VAR 0 6
1613: PUSH
1614: FOR_TO
1615: IFFALSE 1696
// begin uc_side = side ;
1617: LD_ADDR_OWVAR 20
1621: PUSH
1622: LD_VAR 0 1
1626: ST_TO_ADDR
// uc_nation = nation ;
1627: LD_ADDR_OWVAR 21
1631: PUSH
1632: LD_VAR 0 2
1636: ST_TO_ADDR
// hc_gallery =  ;
1637: LD_ADDR_OWVAR 33
1641: PUSH
1642: LD_STRING 
1644: ST_TO_ADDR
// hc_name =  ;
1645: LD_ADDR_OWVAR 26
1649: PUSH
1650: LD_STRING 
1652: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
1653: LD_INT 0
1655: PPUSH
1656: LD_VAR 0 5
1660: PPUSH
1661: LD_VAR 0 4
1665: PPUSH
1666: CALL_OW 380
// un = CreateHuman ;
1670: LD_ADDR_VAR 0 10
1674: PUSH
1675: CALL_OW 44
1679: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
1680: LD_VAR 0 10
1684: PPUSH
1685: LD_VAR 0 3
1689: PPUSH
1690: CALL_OW 52
// end ;
1694: GO 1614
1696: POP
1697: POP
// end ;
1698: LD_VAR 0 7
1702: RET
// export function PrepareDifficulty ; begin
1703: LD_INT 0
1705: PPUSH
// if difficulty = 1 then
1706: LD_OWVAR 67
1710: PUSH
1711: LD_INT 1
1713: EQUAL
1714: IFFALSE 1794
// begin SetTech ( 57 , 3 , state_disabled ) ;
1716: LD_INT 57
1718: PPUSH
1719: LD_INT 3
1721: PPUSH
1722: LD_INT 0
1724: PPUSH
1725: CALL_OW 322
// SetTech ( 58 , 3 , state_disabled ) ;
1729: LD_INT 58
1731: PPUSH
1732: LD_INT 3
1734: PPUSH
1735: LD_INT 0
1737: PPUSH
1738: CALL_OW 322
// SetTech ( 59 , 3 , state_disabled ) ;
1742: LD_INT 59
1744: PPUSH
1745: LD_INT 3
1747: PPUSH
1748: LD_INT 0
1750: PPUSH
1751: CALL_OW 322
// SetTech ( 51 , 3 , state_disabled ) ;
1755: LD_INT 51
1757: PPUSH
1758: LD_INT 3
1760: PPUSH
1761: LD_INT 0
1763: PPUSH
1764: CALL_OW 322
// SetTech ( 52 , 3 , state_disabled ) ;
1768: LD_INT 52
1770: PPUSH
1771: LD_INT 3
1773: PPUSH
1774: LD_INT 0
1776: PPUSH
1777: CALL_OW 322
// SetTech ( 53 , 3 , state_disabled ) ;
1781: LD_INT 53
1783: PPUSH
1784: LD_INT 3
1786: PPUSH
1787: LD_INT 0
1789: PPUSH
1790: CALL_OW 322
// end ; if difficulty = 2 then
1794: LD_OWVAR 67
1798: PUSH
1799: LD_INT 2
1801: EQUAL
1802: IFFALSE 1882
// begin SetTech ( 57 , 3 , state_enabled ) ;
1804: LD_INT 57
1806: PPUSH
1807: LD_INT 3
1809: PPUSH
1810: LD_INT 1
1812: PPUSH
1813: CALL_OW 322
// SetTech ( 58 , 3 , state_disabled ) ;
1817: LD_INT 58
1819: PPUSH
1820: LD_INT 3
1822: PPUSH
1823: LD_INT 0
1825: PPUSH
1826: CALL_OW 322
// SetTech ( 59 , 3 , state_disabled ) ;
1830: LD_INT 59
1832: PPUSH
1833: LD_INT 3
1835: PPUSH
1836: LD_INT 0
1838: PPUSH
1839: CALL_OW 322
// SetTech ( 51 , 3 , state_enabled ) ;
1843: LD_INT 51
1845: PPUSH
1846: LD_INT 3
1848: PPUSH
1849: LD_INT 1
1851: PPUSH
1852: CALL_OW 322
// SetTech ( 52 , 3 , state_disabled ) ;
1856: LD_INT 52
1858: PPUSH
1859: LD_INT 3
1861: PPUSH
1862: LD_INT 0
1864: PPUSH
1865: CALL_OW 322
// SetTech ( 53 , 3 , state_disabled ) ;
1869: LD_INT 53
1871: PPUSH
1872: LD_INT 3
1874: PPUSH
1875: LD_INT 0
1877: PPUSH
1878: CALL_OW 322
// end ; if difficulty = 3 then
1882: LD_OWVAR 67
1886: PUSH
1887: LD_INT 3
1889: EQUAL
1890: IFFALSE 1970
// begin SetTech ( 57 , 3 , state_enabled ) ;
1892: LD_INT 57
1894: PPUSH
1895: LD_INT 3
1897: PPUSH
1898: LD_INT 1
1900: PPUSH
1901: CALL_OW 322
// SetTech ( 58 , 3 , state_enabled ) ;
1905: LD_INT 58
1907: PPUSH
1908: LD_INT 3
1910: PPUSH
1911: LD_INT 1
1913: PPUSH
1914: CALL_OW 322
// SetTech ( 59 , 3 , state_enabled ) ;
1918: LD_INT 59
1920: PPUSH
1921: LD_INT 3
1923: PPUSH
1924: LD_INT 1
1926: PPUSH
1927: CALL_OW 322
// SetTech ( 51 , 3 , state_enabled ) ;
1931: LD_INT 51
1933: PPUSH
1934: LD_INT 3
1936: PPUSH
1937: LD_INT 1
1939: PPUSH
1940: CALL_OW 322
// SetTech ( 52 , 3 , state_enabled ) ;
1944: LD_INT 52
1946: PPUSH
1947: LD_INT 3
1949: PPUSH
1950: LD_INT 1
1952: PPUSH
1953: CALL_OW 322
// SetTech ( 53 , 3 , state_enabled ) ;
1957: LD_INT 53
1959: PPUSH
1960: LD_INT 3
1962: PPUSH
1963: LD_INT 1
1965: PPUSH
1966: CALL_OW 322
// end ; end ;
1970: LD_VAR 0 1
1974: RET
// export function ResAllTechs ( side , lab , nation ) ; var i , tech , cout , ru_tech_list ; begin
1975: LD_INT 0
1977: PPUSH
1978: PPUSH
1979: PPUSH
1980: PPUSH
1981: PPUSH
// ru_tech_list := [ 48 , 49 , 50 , 20 , 1 , 69 , 39 , 34 , 40 , 71 , 57 , 58 , 44 , 32 , 27 , 23 , 33 , 54 , 55 , 56 , 63 , 64 , 65 , 30 , 31 , 21 , 22 , 25 , 51 , 52 , 59 , 53 ] ;
1982: LD_ADDR_VAR 0 8
1986: PUSH
1987: LD_INT 48
1989: PUSH
1990: LD_INT 49
1992: PUSH
1993: LD_INT 50
1995: PUSH
1996: LD_INT 20
1998: PUSH
1999: LD_INT 1
2001: PUSH
2002: LD_INT 69
2004: PUSH
2005: LD_INT 39
2007: PUSH
2008: LD_INT 34
2010: PUSH
2011: LD_INT 40
2013: PUSH
2014: LD_INT 71
2016: PUSH
2017: LD_INT 57
2019: PUSH
2020: LD_INT 58
2022: PUSH
2023: LD_INT 44
2025: PUSH
2026: LD_INT 32
2028: PUSH
2029: LD_INT 27
2031: PUSH
2032: LD_INT 23
2034: PUSH
2035: LD_INT 33
2037: PUSH
2038: LD_INT 54
2040: PUSH
2041: LD_INT 55
2043: PUSH
2044: LD_INT 56
2046: PUSH
2047: LD_INT 63
2049: PUSH
2050: LD_INT 64
2052: PUSH
2053: LD_INT 65
2055: PUSH
2056: LD_INT 30
2058: PUSH
2059: LD_INT 31
2061: PUSH
2062: LD_INT 21
2064: PUSH
2065: LD_INT 22
2067: PUSH
2068: LD_INT 25
2070: PUSH
2071: LD_INT 51
2073: PUSH
2074: LD_INT 52
2076: PUSH
2077: LD_INT 59
2079: PUSH
2080: LD_INT 53
2082: PUSH
2083: EMPTY
2084: LIST
2085: LIST
2086: LIST
2087: LIST
2088: LIST
2089: LIST
2090: LIST
2091: LIST
2092: LIST
2093: LIST
2094: LIST
2095: LIST
2096: LIST
2097: LIST
2098: LIST
2099: LIST
2100: LIST
2101: LIST
2102: LIST
2103: LIST
2104: LIST
2105: LIST
2106: LIST
2107: LIST
2108: LIST
2109: LIST
2110: LIST
2111: LIST
2112: LIST
2113: LIST
2114: LIST
2115: LIST
2116: ST_TO_ADDR
// for i = 1 to ru_tech_list do
2117: LD_ADDR_VAR 0 5
2121: PUSH
2122: DOUBLE
2123: LD_INT 1
2125: DEC
2126: ST_TO_ADDR
2127: LD_VAR 0 8
2131: PUSH
2132: FOR_TO
2133: IFFALSE 2209
// if GetTech ( ru_tech_list [ i ] , side ) = state_enabled and TechNationAvailable ( ru_tech_list [ i ] , nation ) = true then
2135: LD_VAR 0 8
2139: PUSH
2140: LD_VAR 0 5
2144: ARRAY
2145: PPUSH
2146: LD_VAR 0 1
2150: PPUSH
2151: CALL_OW 321
2155: PUSH
2156: LD_INT 1
2158: EQUAL
2159: PUSH
2160: LD_VAR 0 8
2164: PUSH
2165: LD_VAR 0 5
2169: ARRAY
2170: PPUSH
2171: LD_VAR 0 3
2175: PPUSH
2176: CALL_OW 482
2180: PUSH
2181: LD_INT 1
2183: EQUAL
2184: AND
2185: IFFALSE 2207
// AddComResearch ( lab , ru_tech_list [ i ] ) ;
2187: LD_VAR 0 2
2191: PPUSH
2192: LD_VAR 0 8
2196: PUSH
2197: LD_VAR 0 5
2201: ARRAY
2202: PPUSH
2203: CALL_OW 184
2207: GO 2132
2209: POP
2210: POP
// end ;
2211: LD_VAR 0 4
2215: RET
// export function RepairAndRebuildBase ( side , building , area , destroyedBuildings ) ; var buildings_list , i , engineerOkInside , engineerOkOutside , j ; begin
2216: LD_INT 0
2218: PPUSH
2219: PPUSH
2220: PPUSH
2221: PPUSH
2222: PPUSH
2223: PPUSH
// engineerOkInside = UnitsInside ( building ) ;
2224: LD_ADDR_VAR 0 8
2228: PUSH
2229: LD_VAR 0 2
2233: PPUSH
2234: CALL_OW 313
2238: ST_TO_ADDR
// engineerOkOutside = FilterUnitsInArea ( area , [ [ f_side , side ] , [ f_class , 2 ] , [ f_lives , 750 ] , [ f_not , [ f_inside ] ] ] ) ;
2239: LD_ADDR_VAR 0 9
2243: PUSH
2244: LD_VAR 0 3
2248: PPUSH
2249: LD_INT 22
2251: PUSH
2252: LD_VAR 0 1
2256: PUSH
2257: EMPTY
2258: LIST
2259: LIST
2260: PUSH
2261: LD_INT 25
2263: PUSH
2264: LD_INT 2
2266: PUSH
2267: EMPTY
2268: LIST
2269: LIST
2270: PUSH
2271: LD_INT 24
2273: PUSH
2274: LD_INT 750
2276: PUSH
2277: EMPTY
2278: LIST
2279: LIST
2280: PUSH
2281: LD_INT 3
2283: PUSH
2284: LD_INT 54
2286: PUSH
2287: EMPTY
2288: LIST
2289: PUSH
2290: EMPTY
2291: LIST
2292: LIST
2293: PUSH
2294: EMPTY
2295: LIST
2296: LIST
2297: LIST
2298: LIST
2299: PPUSH
2300: CALL_OW 70
2304: ST_TO_ADDR
// buildings_list = FilterUnitsInArea ( area , [ [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
2305: LD_ADDR_VAR 0 6
2309: PUSH
2310: LD_VAR 0 3
2314: PPUSH
2315: LD_INT 22
2317: PUSH
2318: LD_VAR 0 1
2322: PUSH
2323: EMPTY
2324: LIST
2325: LIST
2326: PUSH
2327: LD_INT 21
2329: PUSH
2330: LD_INT 3
2332: PUSH
2333: EMPTY
2334: LIST
2335: LIST
2336: PUSH
2337: LD_INT 3
2339: PUSH
2340: LD_INT 24
2342: PUSH
2343: LD_INT 1000
2345: PUSH
2346: EMPTY
2347: LIST
2348: LIST
2349: PUSH
2350: EMPTY
2351: LIST
2352: LIST
2353: PUSH
2354: EMPTY
2355: LIST
2356: LIST
2357: LIST
2358: PUSH
2359: EMPTY
2360: LIST
2361: PPUSH
2362: CALL_OW 70
2366: ST_TO_ADDR
// if not buildings_list and not FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] , [ f_lives , 250 ] ] ) then
2367: LD_VAR 0 6
2371: NOT
2372: PUSH
2373: LD_INT 22
2375: PUSH
2376: LD_VAR 0 1
2380: PUSH
2381: EMPTY
2382: LIST
2383: LIST
2384: PUSH
2385: LD_INT 25
2387: PUSH
2388: LD_INT 2
2390: PUSH
2391: EMPTY
2392: LIST
2393: LIST
2394: PUSH
2395: LD_INT 24
2397: PUSH
2398: LD_INT 250
2400: PUSH
2401: EMPTY
2402: LIST
2403: LIST
2404: PUSH
2405: EMPTY
2406: LIST
2407: LIST
2408: LIST
2409: PPUSH
2410: CALL_OW 69
2414: NOT
2415: AND
2416: IFFALSE 2420
// exit ;
2418: GO 2602
// if buildings_list > 0 and engineerOkInside then
2420: LD_VAR 0 6
2424: PUSH
2425: LD_INT 0
2427: GREATER
2428: PUSH
2429: LD_VAR 0 8
2433: AND
2434: IFFALSE 2445
// ComExitBuilding ( engineerOkInside ) ;
2436: LD_VAR 0 8
2440: PPUSH
2441: CALL_OW 122
// if buildings_list > 0 and engineerOkOutside > 0 then
2445: LD_VAR 0 6
2449: PUSH
2450: LD_INT 0
2452: GREATER
2453: PUSH
2454: LD_VAR 0 9
2458: PUSH
2459: LD_INT 0
2461: GREATER
2462: AND
2463: IFFALSE 2483
// ComRepairBuilding ( engineerOkOutside , buildings_list [ 1 ] ) ;
2465: LD_VAR 0 9
2469: PPUSH
2470: LD_VAR 0 6
2474: PUSH
2475: LD_INT 1
2477: ARRAY
2478: PPUSH
2479: CALL_OW 130
// if buildings_list = 0 and destroyedBuildings = 0 and engineerOkOutside > 0 then
2483: LD_VAR 0 6
2487: PUSH
2488: LD_INT 0
2490: EQUAL
2491: PUSH
2492: LD_VAR 0 4
2496: PUSH
2497: LD_INT 0
2499: EQUAL
2500: AND
2501: PUSH
2502: LD_VAR 0 9
2506: PUSH
2507: LD_INT 0
2509: GREATER
2510: AND
2511: IFFALSE 2527
// ComEnterUnit ( engineerOkOutside , building ) ;
2513: LD_VAR 0 9
2517: PPUSH
2518: LD_VAR 0 2
2522: PPUSH
2523: CALL_OW 120
// if engineerOkOutside > 0 and buildings_list = 0 and destroyedBuildings > 0 then
2527: LD_VAR 0 9
2531: PUSH
2532: LD_INT 0
2534: GREATER
2535: PUSH
2536: LD_VAR 0 6
2540: PUSH
2541: LD_INT 0
2543: EQUAL
2544: AND
2545: PUSH
2546: LD_VAR 0 4
2550: PUSH
2551: LD_INT 0
2553: GREATER
2554: AND
2555: IFFALSE 2602
// ComBuild ( engineerOkOutside , destroyedBuildings [ 1 ] , destroyedBuildings [ 2 ] , destroyedBuildings [ 3 ] , destroyedBuildings [ 4 ] ) ;
2557: LD_VAR 0 9
2561: PPUSH
2562: LD_VAR 0 4
2566: PUSH
2567: LD_INT 1
2569: ARRAY
2570: PPUSH
2571: LD_VAR 0 4
2575: PUSH
2576: LD_INT 2
2578: ARRAY
2579: PPUSH
2580: LD_VAR 0 4
2584: PUSH
2585: LD_INT 3
2587: ARRAY
2588: PPUSH
2589: LD_VAR 0 4
2593: PUSH
2594: LD_INT 4
2596: ARRAY
2597: PPUSH
2598: CALL_OW 145
// end ;
2602: LD_VAR 0 5
2606: RET
// export function HealUnitInBase ( side , healArea , baseArea , build ) ; var sci_list , sci_listOutside , i , j , damageUnits , unitsToHeal , tmp , rnd ; begin
2607: LD_INT 0
2609: PPUSH
2610: PPUSH
2611: PPUSH
2612: PPUSH
2613: PPUSH
2614: PPUSH
2615: PPUSH
2616: PPUSH
2617: PPUSH
// sci_list = FilterAllUnits ( [ [ f_side , side ] , [ f_class , 4 ] , [ f_nation , 2 ] , [ f_lives , 251 ] ] ) ;
2618: LD_ADDR_VAR 0 6
2622: PUSH
2623: LD_INT 22
2625: PUSH
2626: LD_VAR 0 1
2630: PUSH
2631: EMPTY
2632: LIST
2633: LIST
2634: PUSH
2635: LD_INT 25
2637: PUSH
2638: LD_INT 4
2640: PUSH
2641: EMPTY
2642: LIST
2643: LIST
2644: PUSH
2645: LD_INT 23
2647: PUSH
2648: LD_INT 2
2650: PUSH
2651: EMPTY
2652: LIST
2653: LIST
2654: PUSH
2655: LD_INT 24
2657: PUSH
2658: LD_INT 251
2660: PUSH
2661: EMPTY
2662: LIST
2663: LIST
2664: PUSH
2665: EMPTY
2666: LIST
2667: LIST
2668: LIST
2669: LIST
2670: PPUSH
2671: CALL_OW 69
2675: ST_TO_ADDR
// sci_listOutside = FilterUnitsInArea ( baseArea , [ [ f_side , side ] , [ f_nation , 2 ] , [ f_class , 4 ] , [ f_ok ] ] ) ;
2676: LD_ADDR_VAR 0 7
2680: PUSH
2681: LD_VAR 0 3
2685: PPUSH
2686: LD_INT 22
2688: PUSH
2689: LD_VAR 0 1
2693: PUSH
2694: EMPTY
2695: LIST
2696: LIST
2697: PUSH
2698: LD_INT 23
2700: PUSH
2701: LD_INT 2
2703: PUSH
2704: EMPTY
2705: LIST
2706: LIST
2707: PUSH
2708: LD_INT 25
2710: PUSH
2711: LD_INT 4
2713: PUSH
2714: EMPTY
2715: LIST
2716: LIST
2717: PUSH
2718: LD_INT 50
2720: PUSH
2721: EMPTY
2722: LIST
2723: PUSH
2724: EMPTY
2725: LIST
2726: LIST
2727: LIST
2728: LIST
2729: PPUSH
2730: CALL_OW 70
2734: ST_TO_ADDR
// damageUnits = FilterUnitsInArea ( baseArea , [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_class , 3 ] ] , [ f_not , [ f_lives , 750 ] ] ] ) ;
2735: LD_ADDR_VAR 0 10
2739: PUSH
2740: LD_VAR 0 3
2744: PPUSH
2745: LD_INT 22
2747: PUSH
2748: LD_VAR 0 1
2752: PUSH
2753: EMPTY
2754: LIST
2755: LIST
2756: PUSH
2757: LD_INT 21
2759: PUSH
2760: LD_INT 1
2762: PUSH
2763: EMPTY
2764: LIST
2765: LIST
2766: PUSH
2767: LD_INT 3
2769: PUSH
2770: LD_INT 25
2772: PUSH
2773: LD_INT 3
2775: PUSH
2776: EMPTY
2777: LIST
2778: LIST
2779: PUSH
2780: EMPTY
2781: LIST
2782: LIST
2783: PUSH
2784: LD_INT 3
2786: PUSH
2787: LD_INT 24
2789: PUSH
2790: LD_INT 750
2792: PUSH
2793: EMPTY
2794: LIST
2795: LIST
2796: PUSH
2797: EMPTY
2798: LIST
2799: LIST
2800: PUSH
2801: EMPTY
2802: LIST
2803: LIST
2804: LIST
2805: LIST
2806: PPUSH
2807: CALL_OW 70
2811: ST_TO_ADDR
// unitsToHeal = FilterUnitsInArea ( healArea , [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_class , 3 ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
2812: LD_ADDR_VAR 0 11
2816: PUSH
2817: LD_VAR 0 2
2821: PPUSH
2822: LD_INT 22
2824: PUSH
2825: LD_VAR 0 1
2829: PUSH
2830: EMPTY
2831: LIST
2832: LIST
2833: PUSH
2834: LD_INT 21
2836: PUSH
2837: LD_INT 1
2839: PUSH
2840: EMPTY
2841: LIST
2842: LIST
2843: PUSH
2844: LD_INT 3
2846: PUSH
2847: LD_INT 25
2849: PUSH
2850: LD_INT 3
2852: PUSH
2853: EMPTY
2854: LIST
2855: LIST
2856: PUSH
2857: EMPTY
2858: LIST
2859: LIST
2860: PUSH
2861: LD_INT 3
2863: PUSH
2864: LD_INT 24
2866: PUSH
2867: LD_INT 1000
2869: PUSH
2870: EMPTY
2871: LIST
2872: LIST
2873: PUSH
2874: EMPTY
2875: LIST
2876: LIST
2877: PUSH
2878: EMPTY
2879: LIST
2880: LIST
2881: LIST
2882: LIST
2883: PPUSH
2884: CALL_OW 70
2888: ST_TO_ADDR
// if not damageUnits and not unitsToHeal and not sci_list then
2889: LD_VAR 0 10
2893: NOT
2894: PUSH
2895: LD_VAR 0 11
2899: NOT
2900: AND
2901: PUSH
2902: LD_VAR 0 6
2906: NOT
2907: AND
2908: IFFALSE 2912
// exit ;
2910: GO 3146
// if damageUnits > 0 and sci_list > 0 then
2912: LD_VAR 0 10
2916: PUSH
2917: LD_INT 0
2919: GREATER
2920: PUSH
2921: LD_VAR 0 6
2925: PUSH
2926: LD_INT 0
2928: GREATER
2929: AND
2930: IFFALSE 2946
// ComMoveToArea ( damageUnits , healArea ) ;
2932: LD_VAR 0 10
2936: PPUSH
2937: LD_VAR 0 2
2941: PPUSH
2942: CALL_OW 113
// if unitsToHeal > 0 and sci_list > 0 then
2946: LD_VAR 0 11
2950: PUSH
2951: LD_INT 0
2953: GREATER
2954: PUSH
2955: LD_VAR 0 6
2959: PUSH
2960: LD_INT 0
2962: GREATER
2963: AND
2964: IFFALSE 2975
// ComExitBuilding ( sci_list ) ;
2966: LD_VAR 0 6
2970: PPUSH
2971: CALL_OW 122
// if unitsToHeal > 0 and sci_listOutside > 0 then
2975: LD_VAR 0 11
2979: PUSH
2980: LD_INT 0
2982: GREATER
2983: PUSH
2984: LD_VAR 0 7
2988: PUSH
2989: LD_INT 0
2991: GREATER
2992: AND
2993: IFFALSE 3013
// ComHeal ( sci_listOutside , unitsToHeal [ 1 ] ) ;
2995: LD_VAR 0 7
2999: PPUSH
3000: LD_VAR 0 11
3004: PUSH
3005: LD_INT 1
3007: ARRAY
3008: PPUSH
3009: CALL_OW 128
// if damageUnits = 0 and unitsToHeal = 0 and sci_listOutside > 0 then
3013: LD_VAR 0 10
3017: PUSH
3018: LD_INT 0
3020: EQUAL
3021: PUSH
3022: LD_VAR 0 11
3026: PUSH
3027: LD_INT 0
3029: EQUAL
3030: AND
3031: PUSH
3032: LD_VAR 0 7
3036: PUSH
3037: LD_INT 0
3039: GREATER
3040: AND
3041: IFFALSE 3146
// begin tmp = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_btype , b_lab_full ] ] ) ;
3043: LD_ADDR_VAR 0 12
3047: PUSH
3048: LD_INT 22
3050: PUSH
3051: LD_VAR 0 1
3055: PUSH
3056: EMPTY
3057: LIST
3058: LIST
3059: PUSH
3060: LD_INT 21
3062: PUSH
3063: LD_INT 3
3065: PUSH
3066: EMPTY
3067: LIST
3068: LIST
3069: PUSH
3070: LD_INT 30
3072: PUSH
3073: LD_INT 8
3075: PUSH
3076: EMPTY
3077: LIST
3078: LIST
3079: PUSH
3080: EMPTY
3081: LIST
3082: LIST
3083: LIST
3084: PPUSH
3085: CALL_OW 69
3089: ST_TO_ADDR
// rnd = rand ( 1 , tmp ) ;
3090: LD_ADDR_VAR 0 13
3094: PUSH
3095: LD_INT 1
3097: PPUSH
3098: LD_VAR 0 12
3102: PPUSH
3103: CALL_OW 12
3107: ST_TO_ADDR
// ComEnterUnit ( UnitFilter ( sci_listOutside , [ f_not , [ f_hastask ] ] ) , tmp [ rnd ] ) ;
3108: LD_VAR 0 7
3112: PPUSH
3113: LD_INT 3
3115: PUSH
3116: LD_INT 60
3118: PUSH
3119: EMPTY
3120: LIST
3121: PUSH
3122: EMPTY
3123: LIST
3124: LIST
3125: PPUSH
3126: CALL_OW 72
3130: PPUSH
3131: LD_VAR 0 12
3135: PUSH
3136: LD_VAR 0 13
3140: ARRAY
3141: PPUSH
3142: CALL_OW 120
// end ; end ;
3146: LD_VAR 0 5
3150: RET
// export function DefendDepot ( side , build ) ; var i , j , tmpTab ; begin
3151: LD_INT 0
3153: PPUSH
3154: PPUSH
3155: PPUSH
3156: PPUSH
// tmpTab = [ ] ;
3157: LD_ADDR_VAR 0 6
3161: PUSH
3162: EMPTY
3163: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) > 0 then
3164: LD_INT 22
3166: PUSH
3167: LD_VAR 0 1
3171: PUSH
3172: EMPTY
3173: LIST
3174: LIST
3175: PUSH
3176: LD_INT 30
3178: PUSH
3179: LD_INT 32
3181: PUSH
3182: EMPTY
3183: LIST
3184: LIST
3185: PUSH
3186: EMPTY
3187: LIST
3188: LIST
3189: PPUSH
3190: CALL_OW 69
3194: PUSH
3195: LD_INT 0
3197: GREATER
3198: IFFALSE 3281
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) do
3200: LD_ADDR_VAR 0 4
3204: PUSH
3205: LD_INT 22
3207: PUSH
3208: LD_VAR 0 1
3212: PUSH
3213: EMPTY
3214: LIST
3215: LIST
3216: PUSH
3217: LD_INT 30
3219: PUSH
3220: LD_INT 32
3222: PUSH
3223: EMPTY
3224: LIST
3225: LIST
3226: PUSH
3227: EMPTY
3228: LIST
3229: LIST
3230: PPUSH
3231: CALL_OW 69
3235: PUSH
3236: FOR_IN
3237: IFFALSE 3279
// begin for j in UnitsInside ( i ) do
3239: LD_ADDR_VAR 0 5
3243: PUSH
3244: LD_VAR 0 4
3248: PPUSH
3249: CALL_OW 313
3253: PUSH
3254: FOR_IN
3255: IFFALSE 3275
// tmpTab = tmpTab ^ j ;
3257: LD_ADDR_VAR 0 6
3261: PUSH
3262: LD_VAR 0 6
3266: PUSH
3267: LD_VAR 0 5
3271: ADD
3272: ST_TO_ADDR
3273: GO 3254
3275: POP
3276: POP
// end ;
3277: GO 3236
3279: POP
3280: POP
// end ; ComAgressiveMove ( tmpTab , GetX ( build ) , GetY ( build ) ) ;
3281: LD_VAR 0 6
3285: PPUSH
3286: LD_VAR 0 2
3290: PPUSH
3291: CALL_OW 250
3295: PPUSH
3296: LD_VAR 0 2
3300: PPUSH
3301: CALL_OW 251
3305: PPUSH
3306: CALL_OW 114
// end ;
3310: LD_VAR 0 3
3314: RET
// export function CollectCrates ( side , cargoNation , enemyCratesArea ) ; var clear_crates , cargo_list , crate_list ; begin
3315: LD_INT 0
3317: PPUSH
3318: PPUSH
3319: PPUSH
3320: PPUSH
// enable ;
3321: ENABLE
// crate_list = GetListOfCratesInArea ( enemyCratesArea ) ;
3322: LD_ADDR_VAR 0 7
3326: PUSH
3327: LD_VAR 0 3
3331: PPUSH
3332: CALL_OW 435
3336: ST_TO_ADDR
// cargo_list = FilterAllUnits ( [ [ f_side , side ] , [ f_weapon , cargoNation ] ] ) ;
3337: LD_ADDR_VAR 0 6
3341: PUSH
3342: LD_INT 22
3344: PUSH
3345: LD_VAR 0 1
3349: PUSH
3350: EMPTY
3351: LIST
3352: LIST
3353: PUSH
3354: LD_INT 34
3356: PUSH
3357: LD_VAR 0 2
3361: PUSH
3362: EMPTY
3363: LIST
3364: LIST
3365: PUSH
3366: EMPTY
3367: LIST
3368: LIST
3369: PPUSH
3370: CALL_OW 69
3374: ST_TO_ADDR
// if cargo_list > 0 and GetListOfCratesInArea ( enemyCratesArea ) and crate_list > 0 then
3375: LD_VAR 0 6
3379: PUSH
3380: LD_INT 0
3382: GREATER
3383: PUSH
3384: LD_VAR 0 3
3388: PPUSH
3389: CALL_OW 435
3393: AND
3394: PUSH
3395: LD_VAR 0 7
3399: PUSH
3400: LD_INT 0
3402: GREATER
3403: AND
3404: IFFALSE 3453
// begin AddComCollect ( cargo_list [ 1 ] , crate_list [ 1 ] , crate_list [ 2 ] ) ;
3406: LD_VAR 0 6
3410: PUSH
3411: LD_INT 1
3413: ARRAY
3414: PPUSH
3415: LD_VAR 0 7
3419: PUSH
3420: LD_INT 1
3422: ARRAY
3423: PPUSH
3424: LD_VAR 0 7
3428: PUSH
3429: LD_INT 2
3431: ARRAY
3432: PPUSH
3433: CALL_OW 177
// SetFuel ( cargo_list [ 1 ] , 100 ) ;
3437: LD_VAR 0 6
3441: PUSH
3442: LD_INT 1
3444: ARRAY
3445: PPUSH
3446: LD_INT 100
3448: PPUSH
3449: CALL_OW 240
// end ; end ;
3453: LD_VAR 0 4
3457: RET
// export function AttackNearBuildings ( side , enemySide ) ; var i , j , turretsList , enemyBuildings ; begin
3458: LD_INT 0
3460: PPUSH
3461: PPUSH
3462: PPUSH
3463: PPUSH
3464: PPUSH
// turretsList = FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , 31 ] , [ f_btype , 32 ] , [ f_btype , 33 ] , [ f_btype , 4 ] , [ f_btype , 5 ] ] ] ) ;
3465: LD_ADDR_VAR 0 6
3469: PUSH
3470: LD_INT 22
3472: PUSH
3473: LD_VAR 0 1
3477: PUSH
3478: EMPTY
3479: LIST
3480: LIST
3481: PUSH
3482: LD_INT 2
3484: PUSH
3485: LD_INT 30
3487: PUSH
3488: LD_INT 31
3490: PUSH
3491: EMPTY
3492: LIST
3493: LIST
3494: PUSH
3495: LD_INT 30
3497: PUSH
3498: LD_INT 32
3500: PUSH
3501: EMPTY
3502: LIST
3503: LIST
3504: PUSH
3505: LD_INT 30
3507: PUSH
3508: LD_INT 33
3510: PUSH
3511: EMPTY
3512: LIST
3513: LIST
3514: PUSH
3515: LD_INT 30
3517: PUSH
3518: LD_INT 4
3520: PUSH
3521: EMPTY
3522: LIST
3523: LIST
3524: PUSH
3525: LD_INT 30
3527: PUSH
3528: LD_INT 5
3530: PUSH
3531: EMPTY
3532: LIST
3533: LIST
3534: PUSH
3535: EMPTY
3536: LIST
3537: LIST
3538: LIST
3539: LIST
3540: LIST
3541: LIST
3542: PUSH
3543: EMPTY
3544: LIST
3545: LIST
3546: PPUSH
3547: CALL_OW 69
3551: ST_TO_ADDR
// enemyBuildings = FilterAllUnits ( [ [ f_side , enemySide ] , [ f_type , unit_building ] , [ f_empty ] ] ) ;
3552: LD_ADDR_VAR 0 7
3556: PUSH
3557: LD_INT 22
3559: PUSH
3560: LD_VAR 0 2
3564: PUSH
3565: EMPTY
3566: LIST
3567: LIST
3568: PUSH
3569: LD_INT 21
3571: PUSH
3572: LD_INT 3
3574: PUSH
3575: EMPTY
3576: LIST
3577: LIST
3578: PUSH
3579: LD_INT 58
3581: PUSH
3582: EMPTY
3583: LIST
3584: PUSH
3585: EMPTY
3586: LIST
3587: LIST
3588: LIST
3589: PPUSH
3590: CALL_OW 69
3594: ST_TO_ADDR
// if turretsList > 0 and enemyBuildings > 0 then
3595: LD_VAR 0 6
3599: PUSH
3600: LD_INT 0
3602: GREATER
3603: PUSH
3604: LD_VAR 0 7
3608: PUSH
3609: LD_INT 0
3611: GREATER
3612: AND
3613: IFFALSE 3683
// begin for i in turretsList do
3615: LD_ADDR_VAR 0 4
3619: PUSH
3620: LD_VAR 0 6
3624: PUSH
3625: FOR_IN
3626: IFFALSE 3681
// begin for j in enemyBuildings do
3628: LD_ADDR_VAR 0 5
3632: PUSH
3633: LD_VAR 0 7
3637: PUSH
3638: FOR_IN
3639: IFFALSE 3677
// begin if GetDistUnits ( i , j ) < 20 then
3641: LD_VAR 0 4
3645: PPUSH
3646: LD_VAR 0 5
3650: PPUSH
3651: CALL_OW 296
3655: PUSH
3656: LD_INT 20
3658: LESS
3659: IFFALSE 3675
// begin ComAttackUnit ( i , j ) ;
3661: LD_VAR 0 4
3665: PPUSH
3666: LD_VAR 0 5
3670: PPUSH
3671: CALL_OW 115
// end ; end ;
3675: GO 3638
3677: POP
3678: POP
// end ;
3679: GO 3625
3681: POP
3682: POP
// end ; end ;
3683: LD_VAR 0 3
3687: RET
// export function BuildingVehicle ( side , fabric , vehCount , weaponTab , engine , control , chassis ) ; var i ; begin
3688: LD_INT 0
3690: PPUSH
3691: PPUSH
// for i = 1 to vehCount do
3692: LD_ADDR_VAR 0 9
3696: PUSH
3697: DOUBLE
3698: LD_INT 1
3700: DEC
3701: ST_TO_ADDR
3702: LD_VAR 0 3
3706: PUSH
3707: FOR_TO
3708: IFFALSE 3755
// AddComConstruct ( fabric , chassis , engine , control , weaponTab [ Rand ( 1 , weaponTab ) ] ) ;
3710: LD_VAR 0 2
3714: PPUSH
3715: LD_VAR 0 7
3719: PPUSH
3720: LD_VAR 0 5
3724: PPUSH
3725: LD_VAR 0 6
3729: PPUSH
3730: LD_VAR 0 4
3734: PUSH
3735: LD_INT 1
3737: PPUSH
3738: LD_VAR 0 4
3742: PPUSH
3743: CALL_OW 12
3747: ARRAY
3748: PPUSH
3749: CALL_OW 185
3753: GO 3707
3755: POP
3756: POP
// end ;
3757: LD_VAR 0 8
3761: RET
// export function AttackVehicles ( side ) ; var i , j , tmp , vehiclesOK , target1 , target2 ; begin
3762: LD_INT 0
3764: PPUSH
3765: PPUSH
3766: PPUSH
3767: PPUSH
3768: PPUSH
3769: PPUSH
3770: PPUSH
// if russianTanks >= [ 3 , 4 , 5 ] [ Difficulty ] and russianTimeLapsers >= [ 1 , 2 , 3 ] [ Difficulty ] then
3771: LD_EXP 11
3775: PUSH
3776: LD_INT 3
3778: PUSH
3779: LD_INT 4
3781: PUSH
3782: LD_INT 5
3784: PUSH
3785: EMPTY
3786: LIST
3787: LIST
3788: LIST
3789: PUSH
3790: LD_OWVAR 67
3794: ARRAY
3795: GREATEREQUAL
3796: PUSH
3797: LD_EXP 12
3801: PUSH
3802: LD_INT 1
3804: PUSH
3805: LD_INT 2
3807: PUSH
3808: LD_INT 3
3810: PUSH
3811: EMPTY
3812: LIST
3813: LIST
3814: LIST
3815: PUSH
3816: LD_OWVAR 67
3820: ARRAY
3821: GREATEREQUAL
3822: AND
3823: IFFALSE 4191
// begin if IsOk ( ruTeleport ) then
3825: LD_INT 116
3827: PPUSH
3828: CALL_OW 302
3832: IFFALSE 3884
// begin for j in russianTanks do
3834: LD_ADDR_VAR 0 4
3838: PUSH
3839: LD_EXP 11
3843: PUSH
3844: FOR_IN
3845: IFFALSE 3875
// if j mod 3 = 0 then
3847: LD_VAR 0 4
3851: PUSH
3852: LD_INT 3
3854: MOD
3855: PUSH
3856: LD_INT 0
3858: EQUAL
3859: IFFALSE 3873
// ComEnterUnit ( j , ruTeleport ) ;
3861: LD_VAR 0 4
3865: PPUSH
3866: LD_INT 116
3868: PPUSH
3869: CALL_OW 120
3873: GO 3844
3875: POP
3876: POP
// wait ( 0 0$5 ) ;
3877: LD_INT 175
3879: PPUSH
3880: CALL_OW 67
// end ; repeat wait ( 0 0$1 ) ;
3884: LD_INT 35
3886: PPUSH
3887: CALL_OW 67
// for j in russianTanks do
3891: LD_ADDR_VAR 0 4
3895: PUSH
3896: LD_EXP 11
3900: PUSH
3901: FOR_IN
3902: IFFALSE 4179
// begin tmp := UnitFilter ( russianTimeLapsers , [ f_not , [ f_hastask ] ] ) ;
3904: LD_ADDR_VAR 0 5
3908: PUSH
3909: LD_EXP 12
3913: PPUSH
3914: LD_INT 3
3916: PUSH
3917: LD_INT 60
3919: PUSH
3920: EMPTY
3921: LIST
3922: PUSH
3923: EMPTY
3924: LIST
3925: LIST
3926: PPUSH
3927: CALL_OW 72
3931: ST_TO_ADDR
// if tmp then
3932: LD_VAR 0 5
3936: IFFALSE 3952
// ComMoveUnit ( tmp , j ) ;
3938: LD_VAR 0 5
3942: PPUSH
3943: LD_VAR 0 4
3947: PPUSH
3948: CALL_OW 112
// if GetSide ( j ) <> side then
3952: LD_VAR 0 4
3956: PPUSH
3957: CALL_OW 255
3961: PUSH
3962: LD_VAR 0 1
3966: NONEQUAL
3967: IFFALSE 3980
// begin ComStop ( j ) ;
3969: LD_VAR 0 4
3973: PPUSH
3974: CALL_OW 141
// continue ;
3978: GO 3901
// end ; target1 := NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , side ] , [ f_see , 1 ] ] ) , j ) ;
3980: LD_ADDR_VAR 0 7
3984: PUSH
3985: LD_INT 81
3987: PUSH
3988: LD_VAR 0 1
3992: PUSH
3993: EMPTY
3994: LIST
3995: LIST
3996: PUSH
3997: LD_INT 101
3999: PUSH
4000: LD_INT 1
4002: PUSH
4003: EMPTY
4004: LIST
4005: LIST
4006: PUSH
4007: EMPTY
4008: LIST
4009: LIST
4010: PPUSH
4011: CALL_OW 69
4015: PPUSH
4016: LD_VAR 0 4
4020: PPUSH
4021: CALL_OW 74
4025: ST_TO_ADDR
// target2 := NearestUnitToUnit ( FilterAllUnits ( [ [ [ f_enemy , side ] , [ f_see , 1 ] , [ f_or , [ f_occupied ] , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ] ) , j ) ;
4026: LD_ADDR_VAR 0 8
4030: PUSH
4031: LD_INT 81
4033: PUSH
4034: LD_VAR 0 1
4038: PUSH
4039: EMPTY
4040: LIST
4041: LIST
4042: PUSH
4043: LD_INT 101
4045: PUSH
4046: LD_INT 1
4048: PUSH
4049: EMPTY
4050: LIST
4051: LIST
4052: PUSH
4053: LD_INT 2
4055: PUSH
4056: LD_INT 59
4058: PUSH
4059: EMPTY
4060: LIST
4061: PUSH
4062: LD_INT 21
4064: PUSH
4065: LD_INT 1
4067: PUSH
4068: EMPTY
4069: LIST
4070: LIST
4071: PUSH
4072: LD_INT 21
4074: PUSH
4075: LD_INT 2
4077: PUSH
4078: EMPTY
4079: LIST
4080: LIST
4081: PUSH
4082: EMPTY
4083: LIST
4084: LIST
4085: LIST
4086: LIST
4087: PUSH
4088: EMPTY
4089: LIST
4090: LIST
4091: LIST
4092: PUSH
4093: EMPTY
4094: LIST
4095: PPUSH
4096: CALL_OW 69
4100: PPUSH
4101: LD_VAR 0 4
4105: PPUSH
4106: CALL_OW 74
4110: ST_TO_ADDR
// if GetDistUnits ( j , target1 ) + 8 < GetDistUnits ( j , target2 ) then
4111: LD_VAR 0 4
4115: PPUSH
4116: LD_VAR 0 7
4120: PPUSH
4121: CALL_OW 296
4125: PUSH
4126: LD_INT 8
4128: PLUS
4129: PUSH
4130: LD_VAR 0 4
4134: PPUSH
4135: LD_VAR 0 8
4139: PPUSH
4140: CALL_OW 296
4144: LESS
4145: IFFALSE 4163
// ComAttackUnit ( j , target1 ) else
4147: LD_VAR 0 4
4151: PPUSH
4152: LD_VAR 0 7
4156: PPUSH
4157: CALL_OW 115
4161: GO 4177
// ComAttackUnit ( j , target2 ) ;
4163: LD_VAR 0 4
4167: PPUSH
4168: LD_VAR 0 8
4172: PPUSH
4173: CALL_OW 115
// end ;
4177: GO 3901
4179: POP
4180: POP
// until russianTanks = 0 ;
4181: LD_EXP 11
4185: PUSH
4186: LD_INT 0
4188: EQUAL
4189: IFFALSE 3884
// end ; end ;
4191: LD_VAR 0 2
4195: RET
// export function IntBazooka ( side ) ; var ta , c , i , list , filter ; begin
4196: LD_INT 0
4198: PPUSH
4199: PPUSH
4200: PPUSH
4201: PPUSH
4202: PPUSH
4203: PPUSH
// list := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class_bazooker ] ] ) ;
4204: LD_ADDR_VAR 0 6
4208: PUSH
4209: LD_INT 22
4211: PUSH
4212: LD_VAR 0 1
4216: PUSH
4217: EMPTY
4218: LIST
4219: LIST
4220: PUSH
4221: LD_INT 25
4223: PUSH
4224: LD_INT 9
4226: PUSH
4227: EMPTY
4228: LIST
4229: LIST
4230: PUSH
4231: EMPTY
4232: LIST
4233: LIST
4234: PPUSH
4235: CALL_OW 69
4239: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
4240: LD_ADDR_VAR 0 7
4244: PUSH
4245: LD_INT 81
4247: PUSH
4248: LD_VAR 0 1
4252: PUSH
4253: EMPTY
4254: LIST
4255: LIST
4256: PUSH
4257: LD_INT 3
4259: PUSH
4260: LD_INT 21
4262: PUSH
4263: LD_INT 3
4265: PUSH
4266: EMPTY
4267: LIST
4268: LIST
4269: PUSH
4270: EMPTY
4271: LIST
4272: LIST
4273: PUSH
4274: EMPTY
4275: LIST
4276: LIST
4277: PPUSH
4278: CALL_OW 69
4282: ST_TO_ADDR
// c := Rand ( 1 , 3 ) ;
4283: LD_ADDR_VAR 0 4
4287: PUSH
4288: LD_INT 1
4290: PPUSH
4291: LD_INT 3
4293: PPUSH
4294: CALL_OW 12
4298: ST_TO_ADDR
// for i = 1 to list do
4299: LD_ADDR_VAR 0 5
4303: PUSH
4304: DOUBLE
4305: LD_INT 1
4307: DEC
4308: ST_TO_ADDR
4309: LD_VAR 0 6
4313: PUSH
4314: FOR_TO
4315: IFFALSE 4517
// for ta in filter do
4317: LD_ADDR_VAR 0 3
4321: PUSH
4322: LD_VAR 0 7
4326: PUSH
4327: FOR_IN
4328: IFFALSE 4513
// begin if GetDistUnits ( list [ i ] , ta ) <= 15 then
4330: LD_VAR 0 6
4334: PUSH
4335: LD_VAR 0 5
4339: ARRAY
4340: PPUSH
4341: LD_VAR 0 3
4345: PPUSH
4346: CALL_OW 296
4350: PUSH
4351: LD_INT 15
4353: LESSEQUAL
4354: IFFALSE 4511
// begin case c of 1 :
4356: LD_VAR 0 4
4360: PUSH
4361: LD_INT 1
4363: DOUBLE
4364: EQUAL
4365: IFTRUE 4369
4367: GO 4407
4369: POP
// ComTimeShift ( list [ i ] , GetX ( ta ) , GetY ( ta ) ) ; 2 :
4370: LD_VAR 0 6
4374: PUSH
4375: LD_VAR 0 5
4379: ARRAY
4380: PPUSH
4381: LD_VAR 0 3
4385: PPUSH
4386: CALL_OW 250
4390: PPUSH
4391: LD_VAR 0 3
4395: PPUSH
4396: CALL_OW 251
4400: PPUSH
4401: CALL_OW 154
4405: GO 4511
4407: LD_INT 2
4409: DOUBLE
4410: EQUAL
4411: IFTRUE 4415
4413: GO 4479
4415: POP
// ComSpaceShift ( list [ i ] , GetX ( ta ) + Rand ( - 1 , 1 ) , GetY ( ta ) + Rand ( - 1 , 1 ) ) ; 3 :
4416: LD_VAR 0 6
4420: PUSH
4421: LD_VAR 0 5
4425: ARRAY
4426: PPUSH
4427: LD_VAR 0 3
4431: PPUSH
4432: CALL_OW 250
4436: PUSH
4437: LD_INT 1
4439: NEG
4440: PPUSH
4441: LD_INT 1
4443: PPUSH
4444: CALL_OW 12
4448: PLUS
4449: PPUSH
4450: LD_VAR 0 3
4454: PPUSH
4455: CALL_OW 251
4459: PUSH
4460: LD_INT 1
4462: NEG
4463: PPUSH
4464: LD_INT 1
4466: PPUSH
4467: CALL_OW 12
4471: PLUS
4472: PPUSH
4473: CALL_OW 153
4477: GO 4511
4479: LD_INT 3
4481: DOUBLE
4482: EQUAL
4483: IFTRUE 4487
4485: GO 4510
4487: POP
// ComAttackUnit ( list [ i ] , ta ) ; end ;
4488: LD_VAR 0 6
4492: PUSH
4493: LD_VAR 0 5
4497: ARRAY
4498: PPUSH
4499: LD_VAR 0 3
4503: PPUSH
4504: CALL_OW 115
4508: GO 4511
4510: POP
// end ; end ;
4511: GO 4327
4513: POP
4514: POP
4515: GO 4314
4517: POP
4518: POP
// end ;
4519: LD_VAR 0 2
4523: RET
// export function CraneRepairBuild ( side , baseArea ) ; var i , mechTmp , vehicleTmp , crane_list , buildings_list ; begin
4524: LD_INT 0
4526: PPUSH
4527: PPUSH
4528: PPUSH
4529: PPUSH
4530: PPUSH
4531: PPUSH
// crane_list = FilterUnitsInArea ( baseArea , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_weapon , ru_crane ] ] ) ;
4532: LD_ADDR_VAR 0 7
4536: PUSH
4537: LD_VAR 0 2
4541: PPUSH
4542: LD_INT 22
4544: PUSH
4545: LD_VAR 0 1
4549: PUSH
4550: EMPTY
4551: LIST
4552: LIST
4553: PUSH
4554: LD_INT 21
4556: PUSH
4557: LD_INT 2
4559: PUSH
4560: EMPTY
4561: LIST
4562: LIST
4563: PUSH
4564: LD_INT 34
4566: PUSH
4567: LD_INT 52
4569: PUSH
4570: EMPTY
4571: LIST
4572: LIST
4573: PUSH
4574: EMPTY
4575: LIST
4576: LIST
4577: LIST
4578: PPUSH
4579: CALL_OW 70
4583: ST_TO_ADDR
// buildings_list = FilterUnitsInArea ( baseArea , [ [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
4584: LD_ADDR_VAR 0 8
4588: PUSH
4589: LD_VAR 0 2
4593: PPUSH
4594: LD_INT 22
4596: PUSH
4597: LD_VAR 0 1
4601: PUSH
4602: EMPTY
4603: LIST
4604: LIST
4605: PUSH
4606: LD_INT 21
4608: PUSH
4609: LD_INT 3
4611: PUSH
4612: EMPTY
4613: LIST
4614: LIST
4615: PUSH
4616: LD_INT 3
4618: PUSH
4619: LD_INT 24
4621: PUSH
4622: LD_INT 1000
4624: PUSH
4625: EMPTY
4626: LIST
4627: LIST
4628: PUSH
4629: EMPTY
4630: LIST
4631: LIST
4632: PUSH
4633: EMPTY
4634: LIST
4635: LIST
4636: LIST
4637: PUSH
4638: EMPTY
4639: LIST
4640: PPUSH
4641: CALL_OW 70
4645: ST_TO_ADDR
// if buildings_list > 0 and UnitFilter ( crane_list , [ f_lives , 750 ] ) > 0 then
4646: LD_VAR 0 8
4650: PUSH
4651: LD_INT 0
4653: GREATER
4654: PUSH
4655: LD_VAR 0 7
4659: PPUSH
4660: LD_INT 24
4662: PUSH
4663: LD_INT 750
4665: PUSH
4666: EMPTY
4667: LIST
4668: LIST
4669: PPUSH
4670: CALL_OW 72
4674: PUSH
4675: LD_INT 0
4677: GREATER
4678: AND
4679: IFFALSE 4699
// ComRepairBuilding ( crane_list , buildings_list [ 1 ] ) ;
4681: LD_VAR 0 7
4685: PPUSH
4686: LD_VAR 0 8
4690: PUSH
4691: LD_INT 1
4693: ARRAY
4694: PPUSH
4695: CALL_OW 130
// if crane_list > 0 and buildings_list = 0 and rudestroyedBuildings > 0 then
4699: LD_VAR 0 7
4703: PUSH
4704: LD_INT 0
4706: GREATER
4707: PUSH
4708: LD_VAR 0 8
4712: PUSH
4713: LD_INT 0
4715: EQUAL
4716: AND
4717: PUSH
4718: LD_EXP 10
4722: PUSH
4723: LD_INT 0
4725: GREATER
4726: AND
4727: IFFALSE 4774
// AddComCraneBuild ( crane_list , rudestroyedBuildings [ 1 ] , rudestroyedBuildings [ 2 ] , rudestroyedBuildings [ 3 ] , rudestroyedBuildings [ 4 ] ) ;
4729: LD_VAR 0 7
4733: PPUSH
4734: LD_EXP 10
4738: PUSH
4739: LD_INT 1
4741: ARRAY
4742: PPUSH
4743: LD_EXP 10
4747: PUSH
4748: LD_INT 2
4750: ARRAY
4751: PPUSH
4752: LD_EXP 10
4756: PUSH
4757: LD_INT 3
4759: ARRAY
4760: PPUSH
4761: LD_EXP 10
4765: PUSH
4766: LD_INT 4
4768: ARRAY
4769: PPUSH
4770: CALL_OW 567
// end ; end_of_file
4774: LD_VAR 0 3
4778: RET
// every 0 0$1 do
4779: GO 4781
4781: DISABLE
// begin ResAllTechs ( 3 , ru_lab1 , 3 ) ;
4782: LD_INT 3
4784: PPUSH
4785: LD_INT 14
4787: PPUSH
4788: LD_INT 3
4790: PPUSH
4791: CALL 1975 0 3
// ResAllTechs ( 3 , ru_lab2 , 3 ) ;
4795: LD_INT 3
4797: PPUSH
4798: LD_INT 15
4800: PPUSH
4801: LD_INT 3
4803: PPUSH
4804: CALL 1975 0 3
// end ;
4808: END
// every 0 0$1 trigger russianAI = 1 do
4809: LD_EXP 13
4813: PUSH
4814: LD_INT 1
4816: EQUAL
4817: IFFALSE 4923
4819: GO 4821
4821: DISABLE
// begin enable ;
4822: ENABLE
// RepairAndRebuildBase ( 3 , ru_depot , RussianBase , ruDestroyedBuildings ) ;
4823: LD_INT 3
4825: PPUSH
4826: LD_INT 22
4828: PPUSH
4829: LD_INT 7
4831: PPUSH
4832: LD_EXP 10
4836: PPUSH
4837: CALL 2216 0 4
// HealUnitInBase ( 3 , RussianHealArea , RussianBase , [ ru_lab1 , ru_lab2 ] [ Rand ( 1 , 2 ) ] ) ;
4841: LD_INT 3
4843: PPUSH
4844: LD_INT 8
4846: PPUSH
4847: LD_INT 7
4849: PPUSH
4850: LD_INT 14
4852: PUSH
4853: LD_INT 15
4855: PUSH
4856: EMPTY
4857: LIST
4858: LIST
4859: PUSH
4860: LD_INT 1
4862: PPUSH
4863: LD_INT 2
4865: PPUSH
4866: CALL_OW 12
4870: ARRAY
4871: PPUSH
4872: CALL 2607 0 4
// AttackVehicles ( 3 ) ;
4876: LD_INT 3
4878: PPUSH
4879: CALL 3762 0 1
// AttackNearBuildings ( 3 , 1 ) ;
4883: LD_INT 3
4885: PPUSH
4886: LD_INT 1
4888: PPUSH
4889: CALL 3458 0 2
// IntBazooka ( 3 ) ;
4893: LD_INT 3
4895: PPUSH
4896: CALL 4196 0 1
// CollectCrates ( 3 , ru_cargo_bay , russianCrates ) ;
4900: LD_INT 3
4902: PPUSH
4903: LD_INT 51
4905: PPUSH
4906: LD_INT 14
4908: PPUSH
4909: CALL 3315 0 3
// CraneRepairBuild ( 3 , RussianBase ) ;
4913: LD_INT 3
4915: PPUSH
4916: LD_INT 7
4918: PPUSH
4919: CALL 4524 0 2
// end ;
4923: END
// every 0 0$1 trigger IsDying ( ru_depot ) or GetSide ( ru_depot ) = 1 do
4924: LD_INT 22
4926: PPUSH
4927: CALL_OW 303
4931: PUSH
4932: LD_INT 22
4934: PPUSH
4935: CALL_OW 255
4939: PUSH
4940: LD_INT 1
4942: EQUAL
4943: OR
4944: IFFALSE 4959
4946: GO 4948
4948: DISABLE
// DefendDepot ( 3 , ru_depot ) ;
4949: LD_INT 3
4951: PPUSH
4952: LD_INT 22
4954: PPUSH
4955: CALL 3151 0 2
4959: END
// every 6 6$0 + 7 7$0 trigger russianAI = 1 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_ok ] , [ f_control , 3 ] , [ f_or , [ f_weapon , 46 ] , [ f_weapon , 45 ] , [ f_weapon , 44 ] , [ f_weapon , 49 ] , [ f_weapon , 47 ] ] ] ) < 3 do
4960: LD_EXP 13
4964: PUSH
4965: LD_INT 1
4967: EQUAL
4968: PUSH
4969: LD_INT 22
4971: PUSH
4972: LD_INT 3
4974: PUSH
4975: EMPTY
4976: LIST
4977: LIST
4978: PUSH
4979: LD_INT 21
4981: PUSH
4982: LD_INT 2
4984: PUSH
4985: EMPTY
4986: LIST
4987: LIST
4988: PUSH
4989: LD_INT 50
4991: PUSH
4992: EMPTY
4993: LIST
4994: PUSH
4995: LD_INT 33
4997: PUSH
4998: LD_INT 3
5000: PUSH
5001: EMPTY
5002: LIST
5003: LIST
5004: PUSH
5005: LD_INT 2
5007: PUSH
5008: LD_INT 34
5010: PUSH
5011: LD_INT 46
5013: PUSH
5014: EMPTY
5015: LIST
5016: LIST
5017: PUSH
5018: LD_INT 34
5020: PUSH
5021: LD_INT 45
5023: PUSH
5024: EMPTY
5025: LIST
5026: LIST
5027: PUSH
5028: LD_INT 34
5030: PUSH
5031: LD_INT 44
5033: PUSH
5034: EMPTY
5035: LIST
5036: LIST
5037: PUSH
5038: LD_INT 34
5040: PUSH
5041: LD_INT 49
5043: PUSH
5044: EMPTY
5045: LIST
5046: LIST
5047: PUSH
5048: LD_INT 34
5050: PUSH
5051: LD_INT 47
5053: PUSH
5054: EMPTY
5055: LIST
5056: LIST
5057: PUSH
5058: EMPTY
5059: LIST
5060: LIST
5061: LIST
5062: LIST
5063: LIST
5064: LIST
5065: PUSH
5066: EMPTY
5067: LIST
5068: LIST
5069: LIST
5070: LIST
5071: LIST
5072: PPUSH
5073: CALL_OW 69
5077: PUSH
5078: LD_INT 3
5080: LESS
5081: AND
5082: IFFALSE 5269
5084: GO 5086
5086: DISABLE
// begin enable ;
5087: ENABLE
// if russianRocketsAvalaible = 1 then
5088: LD_EXP 14
5092: PUSH
5093: LD_INT 1
5095: EQUAL
5096: IFFALSE 5153
// BuildingVehicle ( 3 , ru_fact1 , [ 3 , 4 , 5 ] [ Difficulty ] , [ 46 , 45 , 44 ] , 3 , 3 , 24 ) else
5098: LD_INT 3
5100: PPUSH
5101: LD_INT 1
5103: PPUSH
5104: LD_INT 3
5106: PUSH
5107: LD_INT 4
5109: PUSH
5110: LD_INT 5
5112: PUSH
5113: EMPTY
5114: LIST
5115: LIST
5116: LIST
5117: PUSH
5118: LD_OWVAR 67
5122: ARRAY
5123: PPUSH
5124: LD_INT 46
5126: PUSH
5127: LD_INT 45
5129: PUSH
5130: LD_INT 44
5132: PUSH
5133: EMPTY
5134: LIST
5135: LIST
5136: LIST
5137: PPUSH
5138: LD_INT 3
5140: PPUSH
5141: LD_INT 3
5143: PPUSH
5144: LD_INT 24
5146: PPUSH
5147: CALL 3688 0 7
5151: GO 5210
// BuildingVehicle ( 3 , ru_fact1 , [ 3 , 4 , 5 ] [ Difficulty ] , [ 46 , 45 , 44 , 47 ] , 3 , 3 , 24 ) ;
5153: LD_INT 3
5155: PPUSH
5156: LD_INT 1
5158: PPUSH
5159: LD_INT 3
5161: PUSH
5162: LD_INT 4
5164: PUSH
5165: LD_INT 5
5167: PUSH
5168: EMPTY
5169: LIST
5170: LIST
5171: LIST
5172: PUSH
5173: LD_OWVAR 67
5177: ARRAY
5178: PPUSH
5179: LD_INT 46
5181: PUSH
5182: LD_INT 45
5184: PUSH
5185: LD_INT 44
5187: PUSH
5188: LD_INT 47
5190: PUSH
5191: EMPTY
5192: LIST
5193: LIST
5194: LIST
5195: LIST
5196: PPUSH
5197: LD_INT 3
5199: PPUSH
5200: LD_INT 3
5202: PPUSH
5203: LD_INT 24
5205: PPUSH
5206: CALL 3688 0 7
// if russianTimeLapsers = 0 then
5210: LD_EXP 12
5214: PUSH
5215: LD_INT 0
5217: EQUAL
5218: IFFALSE 5269
// BuildingVehicle ( 3 , ru_fact2 , [ 1 , 2 , 3 ] [ Difficulty ] , [ 49 , 49 ] , 3 , 3 , 24 ) ;
5220: LD_INT 3
5222: PPUSH
5223: LD_INT 40
5225: PPUSH
5226: LD_INT 1
5228: PUSH
5229: LD_INT 2
5231: PUSH
5232: LD_INT 3
5234: PUSH
5235: EMPTY
5236: LIST
5237: LIST
5238: LIST
5239: PUSH
5240: LD_OWVAR 67
5244: ARRAY
5245: PPUSH
5246: LD_INT 49
5248: PUSH
5249: LD_INT 49
5251: PUSH
5252: EMPTY
5253: LIST
5254: LIST
5255: PPUSH
5256: LD_INT 3
5258: PPUSH
5259: LD_INT 3
5261: PPUSH
5262: LD_INT 24
5264: PPUSH
5265: CALL 3688 0 7
// end ;
5269: END
// every 0 0$10 + 0 0$30 trigger baseGuard and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] , [ f_control , control_manual ] , [ f_dist , baseGuard , 45 ] ] ) do
5270: LD_EXP 18
5274: PUSH
5275: LD_INT 22
5277: PUSH
5278: LD_INT 1
5280: PUSH
5281: EMPTY
5282: LIST
5283: LIST
5284: PUSH
5285: LD_INT 21
5287: PUSH
5288: LD_INT 2
5290: PUSH
5291: EMPTY
5292: LIST
5293: LIST
5294: PUSH
5295: LD_INT 58
5297: PUSH
5298: EMPTY
5299: LIST
5300: PUSH
5301: LD_INT 33
5303: PUSH
5304: LD_INT 1
5306: PUSH
5307: EMPTY
5308: LIST
5309: LIST
5310: PUSH
5311: LD_INT 91
5313: PUSH
5314: LD_EXP 18
5318: PUSH
5319: LD_INT 45
5321: PUSH
5322: EMPTY
5323: LIST
5324: LIST
5325: LIST
5326: PUSH
5327: EMPTY
5328: LIST
5329: LIST
5330: LIST
5331: LIST
5332: LIST
5333: PPUSH
5334: CALL_OW 69
5338: AND
5339: IFFALSE 5443
5341: GO 5343
5343: DISABLE
// begin wait ( 0 0$5 ) ;
5344: LD_INT 175
5346: PPUSH
5347: CALL_OW 67
// ComEnterUnit ( baseGuard , FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] , [ f_control , control_manual ] , [ f_dist , baseGuard , 45 ] ] ) [ 1 ] ) ;
5351: LD_EXP 18
5355: PPUSH
5356: LD_INT 22
5358: PUSH
5359: LD_INT 1
5361: PUSH
5362: EMPTY
5363: LIST
5364: LIST
5365: PUSH
5366: LD_INT 21
5368: PUSH
5369: LD_INT 2
5371: PUSH
5372: EMPTY
5373: LIST
5374: LIST
5375: PUSH
5376: LD_INT 58
5378: PUSH
5379: EMPTY
5380: LIST
5381: PUSH
5382: LD_INT 33
5384: PUSH
5385: LD_INT 1
5387: PUSH
5388: EMPTY
5389: LIST
5390: LIST
5391: PUSH
5392: LD_INT 91
5394: PUSH
5395: LD_EXP 18
5399: PUSH
5400: LD_INT 45
5402: PUSH
5403: EMPTY
5404: LIST
5405: LIST
5406: LIST
5407: PUSH
5408: EMPTY
5409: LIST
5410: LIST
5411: LIST
5412: LIST
5413: LIST
5414: PPUSH
5415: CALL_OW 69
5419: PUSH
5420: LD_INT 1
5422: ARRAY
5423: PPUSH
5424: CALL_OW 120
// AddComMoveXY ( baseGuard , 127 , 63 ) ;
5428: LD_EXP 18
5432: PPUSH
5433: LD_INT 127
5435: PPUSH
5436: LD_INT 63
5438: PPUSH
5439: CALL_OW 171
// end ; end_of_file
5443: END
// every 1 do var dec1 , dec2 ;
5444: GO 5446
5446: DISABLE
5447: LD_INT 0
5449: PPUSH
5450: PPUSH
// begin InGameOn ;
5451: CALL_OW 8
// SetBName ( us_depot , deltakappa ) ;
5455: LD_INT 48
5457: PPUSH
5458: LD_STRING deltakappa
5460: PPUSH
5461: CALL_OW 500
// CenterNowOnUnits ( JMMveh ) ;
5465: LD_INT 95
5467: PPUSH
5468: CALL_OW 87
// ComMoveXY ( JMMveh , 30 , 11 ) ;
5472: LD_INT 95
5474: PPUSH
5475: LD_INT 30
5477: PPUSH
5478: LD_INT 11
5480: PPUSH
5481: CALL_OW 111
// CenterOnXY ( 30 , 11 ) ;
5485: LD_INT 30
5487: PPUSH
5488: LD_INT 11
5490: PPUSH
5491: CALL_OW 84
// SayRadio ( Powell , D1-Pow-1 ) ;
5495: LD_EXP 5
5499: PPUSH
5500: LD_STRING D1-Pow-1
5502: PPUSH
5503: CALL_OW 94
// ComExitVehicle ( JMM ) ;
5507: LD_EXP 1
5511: PPUSH
5512: CALL_OW 121
// CenterNowOnUnits ( JMM ) ;
5516: LD_EXP 1
5520: PPUSH
5521: CALL_OW 87
// Say ( JMM , D1-JMM-1 ) ;
5525: LD_EXP 1
5529: PPUSH
5530: LD_STRING D1-JMM-1
5532: PPUSH
5533: CALL_OW 88
// SayRadio ( Powell , D1-Pow-2 ) ;
5537: LD_EXP 5
5541: PPUSH
5542: LD_STRING D1-Pow-2
5544: PPUSH
5545: CALL_OW 94
// Say ( JMM , D1-JMM-2 ) ;
5549: LD_EXP 1
5553: PPUSH
5554: LD_STRING D1-JMM-2
5556: PPUSH
5557: CALL_OW 88
// ComEnterUnit ( JMM , JMMveh ) ;
5561: LD_EXP 1
5565: PPUSH
5566: LD_INT 95
5568: PPUSH
5569: CALL_OW 120
// ChangeMissionObjectives ( M1 ) ;
5573: LD_STRING M1
5575: PPUSH
5576: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
5580: LD_INT 35
5582: PPUSH
5583: CALL_OW 67
// ComEnterUnit ( JMM , JMMveh ) ;
5587: LD_EXP 1
5591: PPUSH
5592: LD_INT 95
5594: PPUSH
5595: CALL_OW 120
// ComMoveXY ( JMMveh , 51 , 21 ) ;
5599: LD_INT 95
5601: PPUSH
5602: LD_INT 51
5604: PPUSH
5605: LD_INT 21
5607: PPUSH
5608: CALL_OW 111
// CenterNowOnUnits ( JMMveh ) ;
5612: LD_INT 95
5614: PPUSH
5615: CALL_OW 87
// until IsInArea ( JMMveh , Dialog1Area ) ;
5619: LD_INT 95
5621: PPUSH
5622: LD_INT 5
5624: PPUSH
5625: CALL_OW 308
5629: IFFALSE 5580
// if JMMGirl = 1 then
5631: LD_EXP 7
5635: PUSH
5636: LD_INT 1
5638: EQUAL
5639: IFFALSE 5952
// begin SayRadio ( Joan , D2J-Joan-1 ) ;
5641: LD_EXP 2
5645: PPUSH
5646: LD_STRING D2J-Joan-1
5648: PPUSH
5649: CALL_OW 94
// dec1 = query ( Q1 ) ;
5653: LD_ADDR_VAR 0 1
5657: PUSH
5658: LD_STRING Q1
5660: PPUSH
5661: CALL_OW 97
5665: ST_TO_ADDR
// if dec1 = 1 then
5666: LD_VAR 0 1
5670: PUSH
5671: LD_INT 1
5673: EQUAL
5674: IFFALSE 5928
// begin ComExitVehicle ( JMM ) ;
5676: LD_EXP 1
5680: PPUSH
5681: CALL_OW 121
// Say ( JMM , D2J-JMM-1 ) ;
5685: LD_EXP 1
5689: PPUSH
5690: LD_STRING D2J-JMM-1
5692: PPUSH
5693: CALL_OW 88
// SayRadio ( Joan , D2J-Joan-2 ) ;
5697: LD_EXP 2
5701: PPUSH
5702: LD_STRING D2J-Joan-2
5704: PPUSH
5705: CALL_OW 94
// Say ( JMM , D2J-JMM-2 ) ;
5709: LD_EXP 1
5713: PPUSH
5714: LD_STRING D2J-JMM-2
5716: PPUSH
5717: CALL_OW 88
// SayRadio ( Joan , D2J-Joan-3 ) ;
5721: LD_EXP 2
5725: PPUSH
5726: LD_STRING D2J-Joan-3
5728: PPUSH
5729: CALL_OW 94
// SayRadio ( Powell , DPowell-Pow-1 ) ;
5733: LD_EXP 5
5737: PPUSH
5738: LD_STRING DPowell-Pow-1
5740: PPUSH
5741: CALL_OW 94
// dec2 = query ( Q2J ) ;
5745: LD_ADDR_VAR 0 2
5749: PUSH
5750: LD_STRING Q2J
5752: PPUSH
5753: CALL_OW 97
5757: ST_TO_ADDR
// if dec2 = 1 then
5758: LD_VAR 0 2
5762: PUSH
5763: LD_INT 1
5765: EQUAL
5766: IFFALSE 5808
// begin Say ( JMM , D2Ja-JMM-1 ) ;
5768: LD_EXP 1
5772: PPUSH
5773: LD_STRING D2Ja-JMM-1
5775: PPUSH
5776: CALL_OW 88
// SayRadio ( Joan , D2Ja-Joan-1 ) ;
5780: LD_EXP 2
5784: PPUSH
5785: LD_STRING D2Ja-Joan-1
5787: PPUSH
5788: CALL_OW 94
// Say ( JMM , D2Ja-JMM-2 ) ;
5792: LD_EXP 1
5796: PPUSH
5797: LD_STRING D2Ja-JMM-2
5799: PPUSH
5800: CALL_OW 88
// InGameOff ;
5804: CALL_OW 9
// end ; if dec2 = 2 then
5808: LD_VAR 0 2
5812: PUSH
5813: LD_INT 2
5815: EQUAL
5816: IFFALSE 5892
// begin Say ( JMM , D2Jb-JMM-1 ) ;
5818: LD_EXP 1
5822: PPUSH
5823: LD_STRING D2Jb-JMM-1
5825: PPUSH
5826: CALL_OW 88
// SayRadio ( Joan , D2Jb-Joan-1 ) ;
5830: LD_EXP 2
5834: PPUSH
5835: LD_STRING D2Jb-Joan-1
5837: PPUSH
5838: CALL_OW 94
// Say ( JMM , D2Jb-JMM-2 ) ;
5842: LD_EXP 1
5846: PPUSH
5847: LD_STRING D2Jb-JMM-2
5849: PPUSH
5850: CALL_OW 88
// SayRadio ( Joan , D2Jb-Joan-2 ) ;
5854: LD_EXP 2
5858: PPUSH
5859: LD_STRING D2Jb-Joan-2
5861: PPUSH
5862: CALL_OW 94
// Say ( JMM , D2Jb-JMM-3 ) ;
5866: LD_EXP 1
5870: PPUSH
5871: LD_STRING D2Jb-JMM-3
5873: PPUSH
5874: CALL_OW 88
// fastEnd = 1 ;
5878: LD_ADDR_EXP 15
5882: PUSH
5883: LD_INT 1
5885: ST_TO_ADDR
// FinishMission ;
5886: CALL 9826 0 0
// exit ;
5890: GO 6522
// end ; if dec2 = 3 then
5892: LD_VAR 0 2
5896: PUSH
5897: LD_INT 3
5899: EQUAL
5900: IFFALSE 5928
// begin SayRadio ( Joan , D2Jc-Joan-1 ) ;
5902: LD_EXP 2
5906: PPUSH
5907: LD_STRING D2Jc-Joan-1
5909: PPUSH
5910: CALL_OW 94
// fastEnd = 1 ;
5914: LD_ADDR_EXP 15
5918: PUSH
5919: LD_INT 1
5921: ST_TO_ADDR
// FinishMission ;
5922: CALL 9826 0 0
// exit ;
5926: GO 6522
// end ; end ; if dec1 = 2 then
5928: LD_VAR 0 1
5932: PUSH
5933: LD_INT 2
5935: EQUAL
5936: IFFALSE 5952
// begin fastEnd = 1 ;
5938: LD_ADDR_EXP 15
5942: PUSH
5943: LD_INT 1
5945: ST_TO_ADDR
// FinishMission ;
5946: CALL 9826 0 0
// exit ;
5950: GO 6522
// end ; end ; if JMMGirl = 2 then
5952: LD_EXP 7
5956: PUSH
5957: LD_INT 2
5959: EQUAL
5960: IFFALSE 6285
// begin SayRadio ( Lisa , D2L-Lisa-1 ) ;
5962: LD_EXP 3
5966: PPUSH
5967: LD_STRING D2L-Lisa-1
5969: PPUSH
5970: CALL_OW 94
// dec1 = query ( Q1 ) ;
5974: LD_ADDR_VAR 0 1
5978: PUSH
5979: LD_STRING Q1
5981: PPUSH
5982: CALL_OW 97
5986: ST_TO_ADDR
// if dec1 = 1 then
5987: LD_VAR 0 1
5991: PUSH
5992: LD_INT 1
5994: EQUAL
5995: IFFALSE 6261
// begin ComExitVehicle ( JMM ) ;
5997: LD_EXP 1
6001: PPUSH
6002: CALL_OW 121
// Say ( JMM , D2L-JMM-1 ) ;
6006: LD_EXP 1
6010: PPUSH
6011: LD_STRING D2L-JMM-1
6013: PPUSH
6014: CALL_OW 88
// SayRadio ( Lisa , D2L-Lisa-2 ) ;
6018: LD_EXP 3
6022: PPUSH
6023: LD_STRING D2L-Lisa-2
6025: PPUSH
6026: CALL_OW 94
// Say ( JMM , D2L-JMM-2 ) ;
6030: LD_EXP 1
6034: PPUSH
6035: LD_STRING D2L-JMM-2
6037: PPUSH
6038: CALL_OW 88
// SayRadio ( Lisa , D2L-Lisa-3 ) ;
6042: LD_EXP 3
6046: PPUSH
6047: LD_STRING D2L-Lisa-3
6049: PPUSH
6050: CALL_OW 94
// SayRadio ( Powell , DPowell-Pow-1 ) ;
6054: LD_EXP 5
6058: PPUSH
6059: LD_STRING DPowell-Pow-1
6061: PPUSH
6062: CALL_OW 94
// dec2 = query ( Q2L ) ;
6066: LD_ADDR_VAR 0 2
6070: PUSH
6071: LD_STRING Q2L
6073: PPUSH
6074: CALL_OW 97
6078: ST_TO_ADDR
// if dec2 = 1 then
6079: LD_VAR 0 2
6083: PUSH
6084: LD_INT 1
6086: EQUAL
6087: IFFALSE 6153
// begin Say ( JMM , D2La-JMM-1 ) ;
6089: LD_EXP 1
6093: PPUSH
6094: LD_STRING D2La-JMM-1
6096: PPUSH
6097: CALL_OW 88
// SayRadio ( Lisa , D2La-Lisa-1 ) ;
6101: LD_EXP 3
6105: PPUSH
6106: LD_STRING D2La-Lisa-1
6108: PPUSH
6109: CALL_OW 94
// Say ( JMM , D2La-JMM-2 ) ;
6113: LD_EXP 1
6117: PPUSH
6118: LD_STRING D2La-JMM-2
6120: PPUSH
6121: CALL_OW 88
// SayRadio ( Lisa , D2La-Lisa-2 ) ;
6125: LD_EXP 3
6129: PPUSH
6130: LD_STRING D2La-Lisa-2
6132: PPUSH
6133: CALL_OW 94
// Say ( JMM , D2La-JMM-3 ) ;
6137: LD_EXP 1
6141: PPUSH
6142: LD_STRING D2La-JMM-3
6144: PPUSH
6145: CALL_OW 88
// InGameOff ;
6149: CALL_OW 9
// end ; if dec2 = 2 then
6153: LD_VAR 0 2
6157: PUSH
6158: LD_INT 2
6160: EQUAL
6161: IFFALSE 6225
// begin Say ( JMM , D2Lb-JMM-1 ) ;
6163: LD_EXP 1
6167: PPUSH
6168: LD_STRING D2Lb-JMM-1
6170: PPUSH
6171: CALL_OW 88
// SayRadio ( Lisa , D2Lb-Lisa-1 ) ;
6175: LD_EXP 3
6179: PPUSH
6180: LD_STRING D2Lb-Lisa-1
6182: PPUSH
6183: CALL_OW 94
// Say ( JMM , D2Lb-JMM-2 ) ;
6187: LD_EXP 1
6191: PPUSH
6192: LD_STRING D2Lb-JMM-2
6194: PPUSH
6195: CALL_OW 88
// SayRadio ( Lisa , D2Lb-Lisa-2 ) ;
6199: LD_EXP 3
6203: PPUSH
6204: LD_STRING D2Lb-Lisa-2
6206: PPUSH
6207: CALL_OW 94
// fastEnd = 1 ;
6211: LD_ADDR_EXP 15
6215: PUSH
6216: LD_INT 1
6218: ST_TO_ADDR
// FinishMission ;
6219: CALL 9826 0 0
// exit ;
6223: GO 6522
// end ; if dec2 = 3 then
6225: LD_VAR 0 2
6229: PUSH
6230: LD_INT 3
6232: EQUAL
6233: IFFALSE 6261
// begin SayRadio ( Lisa , D2Lc-Lisa-1 ) ;
6235: LD_EXP 3
6239: PPUSH
6240: LD_STRING D2Lc-Lisa-1
6242: PPUSH
6243: CALL_OW 94
// fastEnd = 1 ;
6247: LD_ADDR_EXP 15
6251: PUSH
6252: LD_INT 1
6254: ST_TO_ADDR
// FinishMission ;
6255: CALL 9826 0 0
// exit ;
6259: GO 6522
// end ; end ; if dec1 = 2 then
6261: LD_VAR 0 1
6265: PUSH
6266: LD_INT 2
6268: EQUAL
6269: IFFALSE 6285
// begin fastEnd = 1 ;
6271: LD_ADDR_EXP 15
6275: PUSH
6276: LD_INT 1
6278: ST_TO_ADDR
// FinishMission ;
6279: CALL 9826 0 0
// exit ;
6283: GO 6522
// end ; end ; if JMMGirl = 3 then
6285: LD_EXP 7
6289: PUSH
6290: LD_INT 3
6292: EQUAL
6293: IFFALSE 6522
// begin SayRadio ( Connie , D2X-Con-1 ) ;
6295: LD_EXP 4
6299: PPUSH
6300: LD_STRING D2X-Con-1
6302: PPUSH
6303: CALL_OW 94
// dec1 = query ( Q1 ) ;
6307: LD_ADDR_VAR 0 1
6311: PUSH
6312: LD_STRING Q1
6314: PPUSH
6315: CALL_OW 97
6319: ST_TO_ADDR
// if dec1 = 1 then
6320: LD_VAR 0 1
6324: PUSH
6325: LD_INT 1
6327: EQUAL
6328: IFFALSE 6498
// begin ComExitVehicle ( JMM ) ;
6330: LD_EXP 1
6334: PPUSH
6335: CALL_OW 121
// Say ( JMM , D2X-JMM-1 ) ;
6339: LD_EXP 1
6343: PPUSH
6344: LD_STRING D2X-JMM-1
6346: PPUSH
6347: CALL_OW 88
// SayRadio ( Connie , D2X-Con-2 ) ;
6351: LD_EXP 4
6355: PPUSH
6356: LD_STRING D2X-Con-2
6358: PPUSH
6359: CALL_OW 94
// SayRadio ( Powell , DPowell-Pow-1 ) ;
6363: LD_EXP 5
6367: PPUSH
6368: LD_STRING DPowell-Pow-1
6370: PPUSH
6371: CALL_OW 94
// dec2 = query ( Q2X ) ;
6375: LD_ADDR_VAR 0 2
6379: PUSH
6380: LD_STRING Q2X
6382: PPUSH
6383: CALL_OW 97
6387: ST_TO_ADDR
// if dec2 = 1 then
6388: LD_VAR 0 2
6392: PUSH
6393: LD_INT 1
6395: EQUAL
6396: IFFALSE 6414
// begin Say ( JMM , D2Xa-JMM-1 ) ;
6398: LD_EXP 1
6402: PPUSH
6403: LD_STRING D2Xa-JMM-1
6405: PPUSH
6406: CALL_OW 88
// InGameOff ;
6410: CALL_OW 9
// end ; if dec2 = 2 then
6414: LD_VAR 0 2
6418: PUSH
6419: LD_INT 2
6421: EQUAL
6422: IFFALSE 6462
// begin Say ( JMM , D2Xb-JMM-1 ) ;
6424: LD_EXP 1
6428: PPUSH
6429: LD_STRING D2Xb-JMM-1
6431: PPUSH
6432: CALL_OW 88
// SayRadio ( Connie , D2Xb-Con-1 ) ;
6436: LD_EXP 4
6440: PPUSH
6441: LD_STRING D2Xb-Con-1
6443: PPUSH
6444: CALL_OW 94
// fastEnd = 1 ;
6448: LD_ADDR_EXP 15
6452: PUSH
6453: LD_INT 1
6455: ST_TO_ADDR
// FinishMission ;
6456: CALL 9826 0 0
// exit ;
6460: GO 6522
// end ; if dec2 = 3 then
6462: LD_VAR 0 2
6466: PUSH
6467: LD_INT 3
6469: EQUAL
6470: IFFALSE 6498
// begin SayRadio ( Connie , D2Xc-Con-1 ) ;
6472: LD_EXP 4
6476: PPUSH
6477: LD_STRING D2Xc-Con-1
6479: PPUSH
6480: CALL_OW 94
// fastEnd = 1 ;
6484: LD_ADDR_EXP 15
6488: PUSH
6489: LD_INT 1
6491: ST_TO_ADDR
// FinishMission ;
6492: CALL 9826 0 0
// exit ;
6496: GO 6522
// end ; end ; if dec1 = 2 then
6498: LD_VAR 0 1
6502: PUSH
6503: LD_INT 2
6505: EQUAL
6506: IFFALSE 6522
// begin fastEnd = 1 ;
6508: LD_ADDR_EXP 15
6512: PUSH
6513: LD_INT 1
6515: ST_TO_ADDR
// FinishMission ;
6516: CALL 9826 0 0
// exit ;
6520: GO 6522
// end ; end ; end ;
6522: PPOPN 2
6524: END
// every 0 0$1 trigger IsInArea ( JMM , Dialog2Area ) do
6525: LD_EXP 1
6529: PPUSH
6530: LD_INT 6
6532: PPUSH
6533: CALL_OW 308
6537: IFFALSE 7279
6539: GO 6541
6541: DISABLE
// begin InGameOn ;
6542: CALL_OW 8
// repeat wait ( 0 0$1 ) ;
6546: LD_INT 35
6548: PPUSH
6549: CALL_OW 67
// CenterNowOnUnits ( JMM ) ;
6553: LD_EXP 1
6557: PPUSH
6558: CALL_OW 87
// ComMoveXY ( JMM , 62 , 104 ) ;
6562: LD_EXP 1
6566: PPUSH
6567: LD_INT 62
6569: PPUSH
6570: LD_INT 104
6572: PPUSH
6573: CALL_OW 111
// until GetDistUnits ( JMM , Joan ) < 4 or GetDistUnits ( JMM , Lisa ) < 4 or GetDistUnits ( JMM , Connie ) < 4 ;
6577: LD_EXP 1
6581: PPUSH
6582: LD_EXP 2
6586: PPUSH
6587: CALL_OW 296
6591: PUSH
6592: LD_INT 4
6594: LESS
6595: PUSH
6596: LD_EXP 1
6600: PPUSH
6601: LD_EXP 3
6605: PPUSH
6606: CALL_OW 296
6610: PUSH
6611: LD_INT 4
6613: LESS
6614: OR
6615: PUSH
6616: LD_EXP 1
6620: PPUSH
6621: LD_EXP 4
6625: PPUSH
6626: CALL_OW 296
6630: PUSH
6631: LD_INT 4
6633: LESS
6634: OR
6635: IFFALSE 6546
// case JMMGirl of 1 :
6637: LD_EXP 7
6641: PUSH
6642: LD_INT 1
6644: DOUBLE
6645: EQUAL
6646: IFTRUE 6650
6648: GO 6862
6650: POP
// begin SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
6651: LD_INT 22
6653: PUSH
6654: LD_INT 4
6656: PUSH
6657: EMPTY
6658: LIST
6659: LIST
6660: PPUSH
6661: CALL_OW 69
6665: PPUSH
6666: LD_INT 1
6668: PPUSH
6669: CALL_OW 235
// ComTurnUnit ( Joan , JMM ) ;
6673: LD_EXP 2
6677: PPUSH
6678: LD_EXP 1
6682: PPUSH
6683: CALL_OW 119
// ComTurnUnit ( JMM , Joan ) ;
6687: LD_EXP 1
6691: PPUSH
6692: LD_EXP 2
6696: PPUSH
6697: CALL_OW 119
// CenterNowOnUnits ( [ Joan , JMM ] ) ;
6701: LD_EXP 2
6705: PUSH
6706: LD_EXP 1
6710: PUSH
6711: EMPTY
6712: LIST
6713: LIST
6714: PPUSH
6715: CALL_OW 87
// wait ( 0 0$1 ) ;
6719: LD_INT 35
6721: PPUSH
6722: CALL_OW 67
// DialogueOn ;
6726: CALL_OW 6
// Say ( Joan , D3J-Joan-1 ) ;
6730: LD_EXP 2
6734: PPUSH
6735: LD_STRING D3J-Joan-1
6737: PPUSH
6738: CALL_OW 88
// Say ( JMM , D3J-JMM-1 ) ;
6742: LD_EXP 1
6746: PPUSH
6747: LD_STRING D3J-JMM-1
6749: PPUSH
6750: CALL_OW 88
// Say ( Joan , D3J-Joan-2 ) ;
6754: LD_EXP 2
6758: PPUSH
6759: LD_STRING D3J-Joan-2
6761: PPUSH
6762: CALL_OW 88
// Say ( JMM , D3J-JMM-2 ) ;
6766: LD_EXP 1
6770: PPUSH
6771: LD_STRING D3J-JMM-2
6773: PPUSH
6774: CALL_OW 88
// wait ( 0 0$1 ) ;
6778: LD_INT 35
6780: PPUSH
6781: CALL_OW 67
// Say ( JMM , D4-JMM-1 ) ;
6785: LD_EXP 1
6789: PPUSH
6790: LD_STRING D4-JMM-1
6792: PPUSH
6793: CALL_OW 88
// Say ( Joan , D4-Joan-1 ) ;
6797: LD_EXP 2
6801: PPUSH
6802: LD_STRING D4-Joan-1
6804: PPUSH
6805: CALL_OW 88
// Say ( JMM , D4-JMM-2 ) ;
6809: LD_EXP 1
6813: PPUSH
6814: LD_STRING D4-JMM-2
6816: PPUSH
6817: CALL_OW 88
// Say ( Joan , D4-Joan-2 ) ;
6821: LD_EXP 2
6825: PPUSH
6826: LD_STRING D4-Joan-2
6828: PPUSH
6829: CALL_OW 88
// DialogueOff ;
6833: CALL_OW 7
// InGameOff ;
6837: CALL_OW 9
// ChangeMissionObjectives ( M2J ) ;
6841: LD_STRING M2J
6843: PPUSH
6844: CALL_OW 337
// SaveForQuickRestart ;
6848: CALL_OW 22
// russianAI = 1 ;
6852: LD_ADDR_EXP 13
6856: PUSH
6857: LD_INT 1
6859: ST_TO_ADDR
// end ; 2 :
6860: GO 7279
6862: LD_INT 2
6864: DOUBLE
6865: EQUAL
6866: IFTRUE 6870
6868: GO 7082
6870: POP
// begin SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
6871: LD_INT 22
6873: PUSH
6874: LD_INT 4
6876: PUSH
6877: EMPTY
6878: LIST
6879: LIST
6880: PPUSH
6881: CALL_OW 69
6885: PPUSH
6886: LD_INT 1
6888: PPUSH
6889: CALL_OW 235
// ComTurnUnit ( Lisa , JMM ) ;
6893: LD_EXP 3
6897: PPUSH
6898: LD_EXP 1
6902: PPUSH
6903: CALL_OW 119
// ComTurnUnit ( JMM , Lisa ) ;
6907: LD_EXP 1
6911: PPUSH
6912: LD_EXP 3
6916: PPUSH
6917: CALL_OW 119
// CenterNowOnUnits ( [ Lisa , JMM ] ) ;
6921: LD_EXP 3
6925: PUSH
6926: LD_EXP 1
6930: PUSH
6931: EMPTY
6932: LIST
6933: LIST
6934: PPUSH
6935: CALL_OW 87
// wait ( 0 0$1 ) ;
6939: LD_INT 35
6941: PPUSH
6942: CALL_OW 67
// DialogueOn ;
6946: CALL_OW 6
// Say ( Lisa , D3L-Lisa-1 ) ;
6950: LD_EXP 3
6954: PPUSH
6955: LD_STRING D3L-Lisa-1
6957: PPUSH
6958: CALL_OW 88
// Say ( JMM , D3L-JMM-1 ) ;
6962: LD_EXP 1
6966: PPUSH
6967: LD_STRING D3L-JMM-1
6969: PPUSH
6970: CALL_OW 88
// Say ( Lisa , D3L-Lisa-2 ) ;
6974: LD_EXP 3
6978: PPUSH
6979: LD_STRING D3L-Lisa-2
6981: PPUSH
6982: CALL_OW 88
// Say ( JMM , D3L-JMM-2 ) ;
6986: LD_EXP 1
6990: PPUSH
6991: LD_STRING D3L-JMM-2
6993: PPUSH
6994: CALL_OW 88
// wait ( 0 0$1 ) ;
6998: LD_INT 35
7000: PPUSH
7001: CALL_OW 67
// Say ( JMM , D4-JMM-1 ) ;
7005: LD_EXP 1
7009: PPUSH
7010: LD_STRING D4-JMM-1
7012: PPUSH
7013: CALL_OW 88
// Say ( Lisa , D4-Lisa-1 ) ;
7017: LD_EXP 3
7021: PPUSH
7022: LD_STRING D4-Lisa-1
7024: PPUSH
7025: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
7029: LD_EXP 1
7033: PPUSH
7034: LD_STRING D4-JMM-1
7036: PPUSH
7037: CALL_OW 88
// Say ( Lisa , D4-Lisa-2 ) ;
7041: LD_EXP 3
7045: PPUSH
7046: LD_STRING D4-Lisa-2
7048: PPUSH
7049: CALL_OW 88
// DialogueOff ;
7053: CALL_OW 7
// InGameOff ;
7057: CALL_OW 9
// ChangeMissionObjectives ( M2L ) ;
7061: LD_STRING M2L
7063: PPUSH
7064: CALL_OW 337
// SaveForQuickRestart ;
7068: CALL_OW 22
// russianAI = 1 ;
7072: LD_ADDR_EXP 13
7076: PUSH
7077: LD_INT 1
7079: ST_TO_ADDR
// end ; 3 :
7080: GO 7279
7082: LD_INT 3
7084: DOUBLE
7085: EQUAL
7086: IFTRUE 7090
7088: GO 7278
7090: POP
// begin SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
7091: LD_INT 22
7093: PUSH
7094: LD_INT 4
7096: PUSH
7097: EMPTY
7098: LIST
7099: LIST
7100: PPUSH
7101: CALL_OW 69
7105: PPUSH
7106: LD_INT 1
7108: PPUSH
7109: CALL_OW 235
// ComTurnUnit ( Connie , JMM ) ;
7113: LD_EXP 4
7117: PPUSH
7118: LD_EXP 1
7122: PPUSH
7123: CALL_OW 119
// ComTurnUnit ( JMM , Connie ) ;
7127: LD_EXP 1
7131: PPUSH
7132: LD_EXP 4
7136: PPUSH
7137: CALL_OW 119
// CenterNowOnUnits ( [ Joan , JMM ] ) ;
7141: LD_EXP 2
7145: PUSH
7146: LD_EXP 1
7150: PUSH
7151: EMPTY
7152: LIST
7153: LIST
7154: PPUSH
7155: CALL_OW 87
// wait ( 0 0$1 ) ;
7159: LD_INT 35
7161: PPUSH
7162: CALL_OW 67
// DialogueOn ;
7166: CALL_OW 6
// Say ( Connie , D3X-Con-1 ) ;
7170: LD_EXP 4
7174: PPUSH
7175: LD_STRING D3X-Con-1
7177: PPUSH
7178: CALL_OW 88
// Say ( JMM , D3J-JMM-1 ) ;
7182: LD_EXP 1
7186: PPUSH
7187: LD_STRING D3J-JMM-1
7189: PPUSH
7190: CALL_OW 88
// wait ( 0 0$1 ) ;
7194: LD_INT 35
7196: PPUSH
7197: CALL_OW 67
// Say ( JMM , D4-JMM-1 ) ;
7201: LD_EXP 1
7205: PPUSH
7206: LD_STRING D4-JMM-1
7208: PPUSH
7209: CALL_OW 88
// Say ( Connie , D4-Con-1 ) ;
7213: LD_EXP 4
7217: PPUSH
7218: LD_STRING D4-Con-1
7220: PPUSH
7221: CALL_OW 88
// Say ( JMM , D4-JMM-2 ) ;
7225: LD_EXP 1
7229: PPUSH
7230: LD_STRING D4-JMM-2
7232: PPUSH
7233: CALL_OW 88
// Say ( Connie , D4-Con-2 ) ;
7237: LD_EXP 4
7241: PPUSH
7242: LD_STRING D4-Con-2
7244: PPUSH
7245: CALL_OW 88
// DialogueOff ;
7249: CALL_OW 7
// InGameOff ;
7253: CALL_OW 9
// ChangeMissionObjectives ( M2X ) ;
7257: LD_STRING M2X
7259: PPUSH
7260: CALL_OW 337
// SaveForQuickRestart ;
7264: CALL_OW 22
// russianAI = 1 ;
7268: LD_ADDR_EXP 13
7272: PUSH
7273: LD_INT 1
7275: ST_TO_ADDR
// end ; end ;
7276: GO 7279
7278: POP
// end ;
7279: END
// every 0 0$1 trigger IsSelected ( us_lab1 ) do
7280: LD_INT 32
7282: PPUSH
7283: CALL_OW 306
7287: IFFALSE 7620
7289: GO 7291
7291: DISABLE
// begin case JMMGirl of 1 :
7292: LD_EXP 7
7296: PUSH
7297: LD_INT 1
7299: DOUBLE
7300: EQUAL
7301: IFTRUE 7305
7303: GO 7427
7305: POP
// begin Say ( JMM , D6J-JMM-1 ) ;
7306: LD_EXP 1
7310: PPUSH
7311: LD_STRING D6J-JMM-1
7313: PPUSH
7314: CALL_OW 88
// if TestCharacters ( 13f_Denis ) = true or TestCharacters ( 13s_Denis ) = true then
7318: LD_STRING 13f_Denis
7320: PPUSH
7321: CALL_OW 28
7325: PUSH
7326: LD_INT 1
7328: EQUAL
7329: PUSH
7330: LD_STRING 13s_Denis
7332: PPUSH
7333: CALL_OW 28
7337: PUSH
7338: LD_INT 1
7340: EQUAL
7341: OR
7342: IFFALSE 7382
// begin Say ( Joan , D6J-Joan-1 ) ;
7344: LD_EXP 2
7348: PPUSH
7349: LD_STRING D6J-Joan-1
7351: PPUSH
7352: CALL_OW 88
// Say ( JMM , D6J-JMM-2 ) ;
7356: LD_EXP 1
7360: PPUSH
7361: LD_STRING D6J-JMM-2
7363: PPUSH
7364: CALL_OW 88
// Say ( Joan , D6J-Joan-2 ) ;
7368: LD_EXP 2
7372: PPUSH
7373: LD_STRING D6J-Joan-2
7375: PPUSH
7376: CALL_OW 88
// end else
7380: GO 7394
// begin Say ( Joan , D6J-Joan-2a ) ;
7382: LD_EXP 2
7386: PPUSH
7387: LD_STRING D6J-Joan-2a
7389: PPUSH
7390: CALL_OW 88
// end ; Say ( JMM , D6J-JMM-3 ) ;
7394: LD_EXP 1
7398: PPUSH
7399: LD_STRING D6J-JMM-3
7401: PPUSH
7402: CALL_OW 88
// Say ( Joan , D6J-Joan-3 ) ;
7406: LD_EXP 2
7410: PPUSH
7411: LD_STRING D6J-Joan-3
7413: PPUSH
7414: CALL_OW 88
// ChangeMissionObjectives ( M3 ) ;
7418: LD_STRING M3
7420: PPUSH
7421: CALL_OW 337
// end ; 2 :
7425: GO 7620
7427: LD_INT 2
7429: DOUBLE
7430: EQUAL
7431: IFTRUE 7435
7433: GO 7493
7435: POP
// begin Say ( JMM , D6L-JMM-1 ) ;
7436: LD_EXP 1
7440: PPUSH
7441: LD_STRING D6L-JMM-1
7443: PPUSH
7444: CALL_OW 88
// Say ( Lisa , D6L-Lisa-1 ) ;
7448: LD_EXP 3
7452: PPUSH
7453: LD_STRING D6L-Lisa-1
7455: PPUSH
7456: CALL_OW 88
// Say ( JMM , D6L-JMM-2 ) ;
7460: LD_EXP 1
7464: PPUSH
7465: LD_STRING D6L-JMM-2
7467: PPUSH
7468: CALL_OW 88
// Say ( Lisa , D6L-Lisa-2 ) ;
7472: LD_EXP 3
7476: PPUSH
7477: LD_STRING D6L-Lisa-2
7479: PPUSH
7480: CALL_OW 88
// ChangeMissionObjectives ( M3 ) ;
7484: LD_STRING M3
7486: PPUSH
7487: CALL_OW 337
// end ; 3 :
7491: GO 7620
7493: LD_INT 3
7495: DOUBLE
7496: EQUAL
7497: IFTRUE 7501
7499: GO 7619
7501: POP
// begin Say ( JMM , D6X-JMM-1 ) ;
7502: LD_EXP 1
7506: PPUSH
7507: LD_STRING D6X-JMM-1
7509: PPUSH
7510: CALL_OW 88
// Say ( Connie , D6X-Con-1 ) ;
7514: LD_EXP 4
7518: PPUSH
7519: LD_STRING D6X-Con-1
7521: PPUSH
7522: CALL_OW 88
// Say ( JMM , D6X-JMM-2 ) ;
7526: LD_EXP 1
7530: PPUSH
7531: LD_STRING D6X-JMM-2
7533: PPUSH
7534: CALL_OW 88
// Say ( Connie , D6X-Con-2 ) ;
7538: LD_EXP 4
7542: PPUSH
7543: LD_STRING D6X-Con-2
7545: PPUSH
7546: CALL_OW 88
// Say ( JMM , D6X-JMM-3 ) ;
7550: LD_EXP 1
7554: PPUSH
7555: LD_STRING D6X-JMM-3
7557: PPUSH
7558: CALL_OW 88
// Say ( Connie , D6X-Con-3 ) ;
7562: LD_EXP 4
7566: PPUSH
7567: LD_STRING D6X-Con-3
7569: PPUSH
7570: CALL_OW 88
// Say ( JMM , D6X-JMM-4 ) ;
7574: LD_EXP 1
7578: PPUSH
7579: LD_STRING D6X-JMM-4
7581: PPUSH
7582: CALL_OW 88
// Say ( Connie , D6X-Con-4 ) ;
7586: LD_EXP 4
7590: PPUSH
7591: LD_STRING D6X-Con-4
7593: PPUSH
7594: CALL_OW 88
// Say ( JMM , D6X-JMM-5 ) ;
7598: LD_EXP 1
7602: PPUSH
7603: LD_STRING D6X-JMM-5
7605: PPUSH
7606: CALL_OW 88
// ChangeMissionObjectives ( M3 ) ;
7610: LD_STRING M3
7612: PPUSH
7613: CALL_OW 337
// end ; end ;
7617: GO 7620
7619: POP
// end ;
7620: END
// every 0 0$1 trigger IsSelected ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_control , control_remote ] ] ) ) do
7621: LD_INT 22
7623: PUSH
7624: LD_INT 1
7626: PUSH
7627: EMPTY
7628: LIST
7629: LIST
7630: PUSH
7631: LD_INT 33
7633: PUSH
7634: LD_INT 2
7636: PUSH
7637: EMPTY
7638: LIST
7639: LIST
7640: PUSH
7641: EMPTY
7642: LIST
7643: LIST
7644: PPUSH
7645: CALL_OW 69
7649: PPUSH
7650: CALL_OW 306
7654: IFFALSE 7800
7656: GO 7658
7658: DISABLE
// begin case JMMGirl of 1 :
7659: LD_EXP 7
7663: PUSH
7664: LD_INT 1
7666: DOUBLE
7667: EQUAL
7668: IFTRUE 7672
7670: GO 7709
7672: POP
// begin Say ( JMM , D5-JMM-1 ) ;
7673: LD_EXP 1
7677: PPUSH
7678: LD_STRING D5-JMM-1
7680: PPUSH
7681: CALL_OW 88
// CenterOnXY ( 77 , 87 ) ;
7685: LD_INT 77
7687: PPUSH
7688: LD_INT 87
7690: PPUSH
7691: CALL_OW 84
// Say ( Joan , D5-Joan-1 ) ;
7695: LD_EXP 2
7699: PPUSH
7700: LD_STRING D5-Joan-1
7702: PPUSH
7703: CALL_OW 88
// end ; 2 :
7707: GO 7800
7709: LD_INT 2
7711: DOUBLE
7712: EQUAL
7713: IFTRUE 7717
7715: GO 7754
7717: POP
// begin Say ( JMM , D5-JMM-1 ) ;
7718: LD_EXP 1
7722: PPUSH
7723: LD_STRING D5-JMM-1
7725: PPUSH
7726: CALL_OW 88
// CenterOnXY ( 77 , 87 ) ;
7730: LD_INT 77
7732: PPUSH
7733: LD_INT 87
7735: PPUSH
7736: CALL_OW 84
// Say ( Lisa , D5-Lisa-1 ) ;
7740: LD_EXP 3
7744: PPUSH
7745: LD_STRING D5-Lisa-1
7747: PPUSH
7748: CALL_OW 88
// end ; 3 :
7752: GO 7800
7754: LD_INT 3
7756: DOUBLE
7757: EQUAL
7758: IFTRUE 7762
7760: GO 7799
7762: POP
// begin Say ( JMM , D5-JMM-1 ) ;
7763: LD_EXP 1
7767: PPUSH
7768: LD_STRING D5-JMM-1
7770: PPUSH
7771: CALL_OW 88
// CenterOnXY ( 77 , 87 ) ;
7775: LD_INT 77
7777: PPUSH
7778: LD_INT 87
7780: PPUSH
7781: CALL_OW 84
// Say ( Connie , D5-Con-1 ) ;
7785: LD_EXP 4
7789: PPUSH
7790: LD_STRING D5-Con-1
7792: PPUSH
7793: CALL_OW 88
// end ; end ;
7797: GO 7800
7799: POP
// end ;
7800: END
// every 15 15$0 trigger GetSide ( us_depot ) = 1 do
7801: LD_INT 48
7803: PPUSH
7804: CALL_OW 255
7808: PUSH
7809: LD_INT 1
7811: EQUAL
7812: IFFALSE 7909
7814: GO 7816
7816: DISABLE
// begin DialogueOn ;
7817: CALL_OW 6
// SayRadio ( Powell , D7-Pow-1 ) ;
7821: LD_EXP 5
7825: PPUSH
7826: LD_STRING D7-Pow-1
7828: PPUSH
7829: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
7833: LD_EXP 1
7837: PPUSH
7838: LD_STRING D7-JMM-1
7840: PPUSH
7841: CALL_OW 88
// SayRadio ( Powell , D7-Pow-2 ) ;
7845: LD_EXP 5
7849: PPUSH
7850: LD_STRING D7-Pow-2
7852: PPUSH
7853: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
7857: LD_EXP 1
7861: PPUSH
7862: LD_STRING D7-JMM-2
7864: PPUSH
7865: CALL_OW 88
// SayRadio ( Powell , D7-Pow-3 ) ;
7869: LD_EXP 5
7873: PPUSH
7874: LD_STRING D7-Pow-3
7876: PPUSH
7877: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
7881: LD_EXP 1
7885: PPUSH
7886: LD_STRING D7-JMM-3
7888: PPUSH
7889: CALL_OW 88
// SayRadio ( Powell , D7-Pow-4 ) ;
7893: LD_EXP 5
7897: PPUSH
7898: LD_STRING D7-Pow-4
7900: PPUSH
7901: CALL_OW 94
// DialogueOff ;
7905: CALL_OW 7
// end ; end_of_file
7909: END
// on BuildingComplete ( building ) do begin if GetSide ( building ) = 3 then
7910: LD_VAR 0 1
7914: PPUSH
7915: CALL_OW 255
7919: PUSH
7920: LD_INT 3
7922: EQUAL
7923: IFFALSE 7997
// begin ruDestroyedBuildings := Delete ( ruDestroyedBuildings , 1 ) ;
7925: LD_ADDR_EXP 10
7929: PUSH
7930: LD_EXP 10
7934: PPUSH
7935: LD_INT 1
7937: PPUSH
7938: CALL_OW 3
7942: ST_TO_ADDR
// ruDestroyedBuildings := Delete ( ruDestroyedBuildings , 1 ) ;
7943: LD_ADDR_EXP 10
7947: PUSH
7948: LD_EXP 10
7952: PPUSH
7953: LD_INT 1
7955: PPUSH
7956: CALL_OW 3
7960: ST_TO_ADDR
// ruDestroyedBuildings := Delete ( ruDestroyedBuildings , 1 ) ;
7961: LD_ADDR_EXP 10
7965: PUSH
7966: LD_EXP 10
7970: PPUSH
7971: LD_INT 1
7973: PPUSH
7974: CALL_OW 3
7978: ST_TO_ADDR
// ruDestroyedBuildings := Delete ( ruDestroyedBuildings , 1 ) ;
7979: LD_ADDR_EXP 10
7983: PUSH
7984: LD_EXP 10
7988: PPUSH
7989: LD_INT 1
7991: PPUSH
7992: CALL_OW 3
7996: ST_TO_ADDR
// end ; if GetSide ( building ) = 3 and [ GetBType ( building ) = 0 or GetBType ( building ) = 2 or GetBType ( building ) = 4 ] then
7997: LD_VAR 0 1
8001: PPUSH
8002: CALL_OW 255
8006: PUSH
8007: LD_INT 3
8009: EQUAL
8010: PUSH
8011: LD_VAR 0 1
8015: PPUSH
8016: CALL_OW 266
8020: PUSH
8021: LD_INT 0
8023: EQUAL
8024: PUSH
8025: LD_VAR 0 1
8029: PPUSH
8030: CALL_OW 266
8034: PUSH
8035: LD_INT 2
8037: EQUAL
8038: OR
8039: PUSH
8040: LD_VAR 0 1
8044: PPUSH
8045: CALL_OW 266
8049: PUSH
8050: LD_INT 4
8052: EQUAL
8053: OR
8054: PUSH
8055: EMPTY
8056: LIST
8057: AND
8058: IFFALSE 8069
// ComUpgrade ( building ) ;
8060: LD_VAR 0 1
8064: PPUSH
8065: CALL_OW 146
// if GetSide ( building ) = 3 and GetBType ( building ) = b_bunker then
8069: LD_VAR 0 1
8073: PPUSH
8074: CALL_OW 255
8078: PUSH
8079: LD_INT 3
8081: EQUAL
8082: PUSH
8083: LD_VAR 0 1
8087: PPUSH
8088: CALL_OW 266
8092: PUSH
8093: LD_INT 32
8095: EQUAL
8096: AND
8097: IFFALSE 8138
// AddComPlaceWeapon ( building , [ 42 , 43 , 44 , 46 ] [ Rand ( 1 , 4 ) ] ) ;
8099: LD_VAR 0 1
8103: PPUSH
8104: LD_INT 42
8106: PUSH
8107: LD_INT 43
8109: PUSH
8110: LD_INT 44
8112: PUSH
8113: LD_INT 46
8115: PUSH
8116: EMPTY
8117: LIST
8118: LIST
8119: LIST
8120: LIST
8121: PUSH
8122: LD_INT 1
8124: PPUSH
8125: LD_INT 4
8127: PPUSH
8128: CALL_OW 12
8132: ARRAY
8133: PPUSH
8134: CALL_OW 208
// if GetSide ( building ) = 3 and GetBType ( building ) = b_turret then
8138: LD_VAR 0 1
8142: PPUSH
8143: CALL_OW 255
8147: PUSH
8148: LD_INT 3
8150: EQUAL
8151: PUSH
8152: LD_VAR 0 1
8156: PPUSH
8157: CALL_OW 266
8161: PUSH
8162: LD_INT 33
8164: EQUAL
8165: AND
8166: IFFALSE 8207
// AddComPlaceWeapon ( building , [ 42 , 43 , 44 , 46 ] [ Rand ( 1 , 4 ) ] ) ;
8168: LD_VAR 0 1
8172: PPUSH
8173: LD_INT 42
8175: PUSH
8176: LD_INT 43
8178: PUSH
8179: LD_INT 44
8181: PUSH
8182: LD_INT 46
8184: PUSH
8185: EMPTY
8186: LIST
8187: LIST
8188: LIST
8189: LIST
8190: PUSH
8191: LD_INT 1
8193: PPUSH
8194: LD_INT 4
8196: PPUSH
8197: CALL_OW 12
8201: ARRAY
8202: PPUSH
8203: CALL_OW 208
// end ;
8207: PPOPN 1
8209: END
// on UnitDestroyed ( unit ) do begin if GetSide ( unit ) = 3 and GetType ( unit ) = unit_building then
8210: LD_VAR 0 1
8214: PPUSH
8215: CALL_OW 255
8219: PUSH
8220: LD_INT 3
8222: EQUAL
8223: PUSH
8224: LD_VAR 0 1
8228: PPUSH
8229: CALL_OW 247
8233: PUSH
8234: LD_INT 3
8236: EQUAL
8237: AND
8238: IFFALSE 8930
// begin if GetBType ( unit ) = 31 or GetBType ( unit ) = 32 or GetBType ( unit ) = 36 or GetBType ( unit ) = 0 or GetBType ( unit ) = 24 or GetBType ( unit ) = 17 or GetBType ( unit ) = 25 or GetBType ( unit ) = 19 or GetBType ( unit ) = 20 or GetBType ( unit ) = 18 or GetBType ( unit ) = 21 or GetBType ( unit ) = 23 or GetBType ( unit ) = 16 or GetBType ( unit ) = 6 or GetBType ( unit ) = 29 or GetBType ( unit ) = 26 or GetBType ( unit ) = 30 or GetBType ( unit ) = 28 or GetBType ( unit ) = 27 or GetBType ( unit ) = 33 or GetBType ( unit ) = 2 or GetBType ( unit ) = 4 then
8240: LD_VAR 0 1
8244: PPUSH
8245: CALL_OW 266
8249: PUSH
8250: LD_INT 31
8252: EQUAL
8253: PUSH
8254: LD_VAR 0 1
8258: PPUSH
8259: CALL_OW 266
8263: PUSH
8264: LD_INT 32
8266: EQUAL
8267: OR
8268: PUSH
8269: LD_VAR 0 1
8273: PPUSH
8274: CALL_OW 266
8278: PUSH
8279: LD_INT 36
8281: EQUAL
8282: OR
8283: PUSH
8284: LD_VAR 0 1
8288: PPUSH
8289: CALL_OW 266
8293: PUSH
8294: LD_INT 0
8296: EQUAL
8297: OR
8298: PUSH
8299: LD_VAR 0 1
8303: PPUSH
8304: CALL_OW 266
8308: PUSH
8309: LD_INT 24
8311: EQUAL
8312: OR
8313: PUSH
8314: LD_VAR 0 1
8318: PPUSH
8319: CALL_OW 266
8323: PUSH
8324: LD_INT 17
8326: EQUAL
8327: OR
8328: PUSH
8329: LD_VAR 0 1
8333: PPUSH
8334: CALL_OW 266
8338: PUSH
8339: LD_INT 25
8341: EQUAL
8342: OR
8343: PUSH
8344: LD_VAR 0 1
8348: PPUSH
8349: CALL_OW 266
8353: PUSH
8354: LD_INT 19
8356: EQUAL
8357: OR
8358: PUSH
8359: LD_VAR 0 1
8363: PPUSH
8364: CALL_OW 266
8368: PUSH
8369: LD_INT 20
8371: EQUAL
8372: OR
8373: PUSH
8374: LD_VAR 0 1
8378: PPUSH
8379: CALL_OW 266
8383: PUSH
8384: LD_INT 18
8386: EQUAL
8387: OR
8388: PUSH
8389: LD_VAR 0 1
8393: PPUSH
8394: CALL_OW 266
8398: PUSH
8399: LD_INT 21
8401: EQUAL
8402: OR
8403: PUSH
8404: LD_VAR 0 1
8408: PPUSH
8409: CALL_OW 266
8413: PUSH
8414: LD_INT 23
8416: EQUAL
8417: OR
8418: PUSH
8419: LD_VAR 0 1
8423: PPUSH
8424: CALL_OW 266
8428: PUSH
8429: LD_INT 16
8431: EQUAL
8432: OR
8433: PUSH
8434: LD_VAR 0 1
8438: PPUSH
8439: CALL_OW 266
8443: PUSH
8444: LD_INT 6
8446: EQUAL
8447: OR
8448: PUSH
8449: LD_VAR 0 1
8453: PPUSH
8454: CALL_OW 266
8458: PUSH
8459: LD_INT 29
8461: EQUAL
8462: OR
8463: PUSH
8464: LD_VAR 0 1
8468: PPUSH
8469: CALL_OW 266
8473: PUSH
8474: LD_INT 26
8476: EQUAL
8477: OR
8478: PUSH
8479: LD_VAR 0 1
8483: PPUSH
8484: CALL_OW 266
8488: PUSH
8489: LD_INT 30
8491: EQUAL
8492: OR
8493: PUSH
8494: LD_VAR 0 1
8498: PPUSH
8499: CALL_OW 266
8503: PUSH
8504: LD_INT 28
8506: EQUAL
8507: OR
8508: PUSH
8509: LD_VAR 0 1
8513: PPUSH
8514: CALL_OW 266
8518: PUSH
8519: LD_INT 27
8521: EQUAL
8522: OR
8523: PUSH
8524: LD_VAR 0 1
8528: PPUSH
8529: CALL_OW 266
8533: PUSH
8534: LD_INT 33
8536: EQUAL
8537: OR
8538: PUSH
8539: LD_VAR 0 1
8543: PPUSH
8544: CALL_OW 266
8548: PUSH
8549: LD_INT 2
8551: EQUAL
8552: OR
8553: PUSH
8554: LD_VAR 0 1
8558: PPUSH
8559: CALL_OW 266
8563: PUSH
8564: LD_INT 4
8566: EQUAL
8567: OR
8568: IFFALSE 8654
// begin ruDestroyedBuildings = ruDestroyedBuildings ^ GetBType ( unit ) ;
8570: LD_ADDR_EXP 10
8574: PUSH
8575: LD_EXP 10
8579: PUSH
8580: LD_VAR 0 1
8584: PPUSH
8585: CALL_OW 266
8589: ADD
8590: ST_TO_ADDR
// ruDestroyedBuildings = ruDestroyedBuildings ^ GetX ( unit ) ;
8591: LD_ADDR_EXP 10
8595: PUSH
8596: LD_EXP 10
8600: PUSH
8601: LD_VAR 0 1
8605: PPUSH
8606: CALL_OW 250
8610: ADD
8611: ST_TO_ADDR
// ruDestroyedBuildings = ruDestroyedBuildings ^ GetY ( unit ) ;
8612: LD_ADDR_EXP 10
8616: PUSH
8617: LD_EXP 10
8621: PUSH
8622: LD_VAR 0 1
8626: PPUSH
8627: CALL_OW 251
8631: ADD
8632: ST_TO_ADDR
// ruDestroyedBuildings = ruDestroyedBuildings ^ GetDir ( unit ) ;
8633: LD_ADDR_EXP 10
8637: PUSH
8638: LD_EXP 10
8642: PUSH
8643: LD_VAR 0 1
8647: PPUSH
8648: CALL_OW 254
8652: ADD
8653: ST_TO_ADDR
// end ; if GetBType ( unit ) = 1 then
8654: LD_VAR 0 1
8658: PPUSH
8659: CALL_OW 266
8663: PUSH
8664: LD_INT 1
8666: EQUAL
8667: IFFALSE 8746
// begin ruDestroyedBuildings = ruDestroyedBuildings ^ 0 ;
8669: LD_ADDR_EXP 10
8673: PUSH
8674: LD_EXP 10
8678: PUSH
8679: LD_INT 0
8681: ADD
8682: ST_TO_ADDR
// ruDestroyedBuildings = ruDestroyedBuildings ^ GetX ( unit ) ;
8683: LD_ADDR_EXP 10
8687: PUSH
8688: LD_EXP 10
8692: PUSH
8693: LD_VAR 0 1
8697: PPUSH
8698: CALL_OW 250
8702: ADD
8703: ST_TO_ADDR
// ruDestroyedBuildings = ruDestroyedBuildings ^ GetY ( unit ) ;
8704: LD_ADDR_EXP 10
8708: PUSH
8709: LD_EXP 10
8713: PUSH
8714: LD_VAR 0 1
8718: PPUSH
8719: CALL_OW 251
8723: ADD
8724: ST_TO_ADDR
// ruDestroyedBuildings = ruDestroyedBuildings ^ GetDir ( unit ) ;
8725: LD_ADDR_EXP 10
8729: PUSH
8730: LD_EXP 10
8734: PUSH
8735: LD_VAR 0 1
8739: PPUSH
8740: CALL_OW 254
8744: ADD
8745: ST_TO_ADDR
// end ; if GetBType ( unit ) = 3 then
8746: LD_VAR 0 1
8750: PPUSH
8751: CALL_OW 266
8755: PUSH
8756: LD_INT 3
8758: EQUAL
8759: IFFALSE 8838
// begin ruDestroyedBuildings = ruDestroyedBuildings ^ 2 ;
8761: LD_ADDR_EXP 10
8765: PUSH
8766: LD_EXP 10
8770: PUSH
8771: LD_INT 2
8773: ADD
8774: ST_TO_ADDR
// ruDestroyedBuildings = ruDestroyedBuildings ^ GetX ( unit ) ;
8775: LD_ADDR_EXP 10
8779: PUSH
8780: LD_EXP 10
8784: PUSH
8785: LD_VAR 0 1
8789: PPUSH
8790: CALL_OW 250
8794: ADD
8795: ST_TO_ADDR
// ruDestroyedBuildings = ruDestroyedBuildings ^ GetY ( unit ) ;
8796: LD_ADDR_EXP 10
8800: PUSH
8801: LD_EXP 10
8805: PUSH
8806: LD_VAR 0 1
8810: PPUSH
8811: CALL_OW 251
8815: ADD
8816: ST_TO_ADDR
// ruDestroyedBuildings = ruDestroyedBuildings ^ GetDir ( unit ) ;
8817: LD_ADDR_EXP 10
8821: PUSH
8822: LD_EXP 10
8826: PUSH
8827: LD_VAR 0 1
8831: PPUSH
8832: CALL_OW 254
8836: ADD
8837: ST_TO_ADDR
// end ; if GetBType ( unit ) = 5 then
8838: LD_VAR 0 1
8842: PPUSH
8843: CALL_OW 266
8847: PUSH
8848: LD_INT 5
8850: EQUAL
8851: IFFALSE 8930
// begin ruDestroyedBuildings = ruDestroyedBuildings ^ 4 ;
8853: LD_ADDR_EXP 10
8857: PUSH
8858: LD_EXP 10
8862: PUSH
8863: LD_INT 4
8865: ADD
8866: ST_TO_ADDR
// ruDestroyedBuildings = ruDestroyedBuildings ^ GetX ( unit ) ;
8867: LD_ADDR_EXP 10
8871: PUSH
8872: LD_EXP 10
8876: PUSH
8877: LD_VAR 0 1
8881: PPUSH
8882: CALL_OW 250
8886: ADD
8887: ST_TO_ADDR
// ruDestroyedBuildings = ruDestroyedBuildings ^ GetY ( unit ) ;
8888: LD_ADDR_EXP 10
8892: PUSH
8893: LD_EXP 10
8897: PUSH
8898: LD_VAR 0 1
8902: PPUSH
8903: CALL_OW 251
8907: ADD
8908: ST_TO_ADDR
// ruDestroyedBuildings = ruDestroyedBuildings ^ GetDir ( unit ) ;
8909: LD_ADDR_EXP 10
8913: PUSH
8914: LD_EXP 10
8918: PUSH
8919: LD_VAR 0 1
8923: PPUSH
8924: CALL_OW 254
8928: ADD
8929: ST_TO_ADDR
// end ; end ; end ;
8930: PPOPN 1
8932: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin if GetWeapon ( killerUnit ) = us_double_laser then
8933: LD_VAR 0 3
8937: PPUSH
8938: CALL_OW 264
8942: PUSH
8943: LD_INT 10
8945: EQUAL
8946: IFFALSE 8962
// destroyCounter := destroyCounter + 1 ;
8948: LD_ADDR_EXP 17
8952: PUSH
8953: LD_EXP 17
8957: PUSH
8958: LD_INT 1
8960: PLUS
8961: ST_TO_ADDR
// end ;
8962: PPOPN 3
8964: END
// on VehicleConstructed ( vehicle , factory ) do begin if factory = ru_fact1 or factory = ru_fact2 then
8965: LD_VAR 0 2
8969: PUSH
8970: LD_INT 1
8972: EQUAL
8973: PUSH
8974: LD_VAR 0 2
8978: PUSH
8979: LD_INT 40
8981: EQUAL
8982: OR
8983: IFFALSE 9107
// if GetSide ( vehicle ) = 3 then
8985: LD_VAR 0 1
8989: PPUSH
8990: CALL_OW 255
8994: PUSH
8995: LD_INT 3
8997: EQUAL
8998: IFFALSE 9107
// begin if GetWeapon ( vehicle ) = 47 or GetWeapon ( vehicle ) = 46 or GetWeapon ( vehicle ) = 45 or GetWeapon ( vehicle ) = 44 then
9000: LD_VAR 0 1
9004: PPUSH
9005: CALL_OW 264
9009: PUSH
9010: LD_INT 47
9012: EQUAL
9013: PUSH
9014: LD_VAR 0 1
9018: PPUSH
9019: CALL_OW 264
9023: PUSH
9024: LD_INT 46
9026: EQUAL
9027: OR
9028: PUSH
9029: LD_VAR 0 1
9033: PPUSH
9034: CALL_OW 264
9038: PUSH
9039: LD_INT 45
9041: EQUAL
9042: OR
9043: PUSH
9044: LD_VAR 0 1
9048: PPUSH
9049: CALL_OW 264
9053: PUSH
9054: LD_INT 44
9056: EQUAL
9057: OR
9058: IFFALSE 9076
// russianTanks = russianTanks ^ vehicle ;
9060: LD_ADDR_EXP 11
9064: PUSH
9065: LD_EXP 11
9069: PUSH
9070: LD_VAR 0 1
9074: ADD
9075: ST_TO_ADDR
// if GetWeapon ( vehicle ) = 49 then
9076: LD_VAR 0 1
9080: PPUSH
9081: CALL_OW 264
9085: PUSH
9086: LD_INT 49
9088: EQUAL
9089: IFFALSE 9107
// russianTimeLapsers = russianTimeLapsers ^ vehicle ;
9091: LD_ADDR_EXP 12
9095: PUSH
9096: LD_EXP 12
9100: PUSH
9101: LD_VAR 0 1
9105: ADD
9106: ST_TO_ADDR
// end ; if GetSide ( vehicle ) = 1 and GetWeapon ( vehicle ) = 10 then
9107: LD_VAR 0 1
9111: PPUSH
9112: CALL_OW 255
9116: PUSH
9117: LD_INT 1
9119: EQUAL
9120: PUSH
9121: LD_VAR 0 1
9125: PPUSH
9126: CALL_OW 264
9130: PUSH
9131: LD_INT 10
9133: EQUAL
9134: AND
9135: IFFALSE 9151
// amLaserCounter = amLaserCounter + 1 ;
9137: LD_ADDR_EXP 9
9141: PUSH
9142: LD_EXP 9
9146: PUSH
9147: LD_INT 1
9149: PLUS
9150: ST_TO_ADDR
// end ;
9151: PPOPN 2
9153: END
// on UnitGoesToRed ( unit ) do var i ;
9154: LD_INT 0
9156: PPUSH
// begin if GetSide ( unit ) = 3 and GetType ( unit ) = unit_vehicle then
9157: LD_VAR 0 1
9161: PPUSH
9162: CALL_OW 255
9166: PUSH
9167: LD_INT 3
9169: EQUAL
9170: PUSH
9171: LD_VAR 0 1
9175: PPUSH
9176: CALL_OW 247
9180: PUSH
9181: LD_INT 2
9183: EQUAL
9184: AND
9185: IFFALSE 9297
// begin if russianTanks > 0 then
9187: LD_EXP 11
9191: PUSH
9192: LD_INT 0
9194: GREATER
9195: IFFALSE 9242
// for i in russianTanks do
9197: LD_ADDR_VAR 0 2
9201: PUSH
9202: LD_EXP 11
9206: PUSH
9207: FOR_IN
9208: IFFALSE 9240
// if i = unit then
9210: LD_VAR 0 2
9214: PUSH
9215: LD_VAR 0 1
9219: EQUAL
9220: IFFALSE 9238
// russianTanks = russianTanks diff unit ;
9222: LD_ADDR_EXP 11
9226: PUSH
9227: LD_EXP 11
9231: PUSH
9232: LD_VAR 0 1
9236: DIFF
9237: ST_TO_ADDR
9238: GO 9207
9240: POP
9241: POP
// if russianTimeLapsers > 0 then
9242: LD_EXP 12
9246: PUSH
9247: LD_INT 0
9249: GREATER
9250: IFFALSE 9297
// for i in russianTimeLapsers do
9252: LD_ADDR_VAR 0 2
9256: PUSH
9257: LD_EXP 12
9261: PUSH
9262: FOR_IN
9263: IFFALSE 9295
// if i = unit then
9265: LD_VAR 0 2
9269: PUSH
9270: LD_VAR 0 1
9274: EQUAL
9275: IFFALSE 9293
// russianTimeLapsers = russianTimeLapsers diff unit ;
9277: LD_ADDR_EXP 12
9281: PUSH
9282: LD_EXP 12
9286: PUSH
9287: LD_VAR 0 1
9291: DIFF
9292: ST_TO_ADDR
9293: GO 9262
9295: POP
9296: POP
// end ; end ;
9297: PPOPN 2
9299: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
9300: LD_VAR 0 1
9304: PPUSH
9305: CALL 14629 0 1
// end ; end_of_file
9309: PPOPN 1
9311: END
// every 0 0$5 trigger IsInArea ( IsInUnit ( JMM ) , ExitArea ) and fastEnd = 0 do var JMMGirlVeh , dec ;
9312: LD_EXP 1
9316: PPUSH
9317: CALL_OW 310
9321: PPUSH
9322: LD_INT 12
9324: PPUSH
9325: CALL_OW 308
9329: PUSH
9330: LD_EXP 15
9334: PUSH
9335: LD_INT 0
9337: EQUAL
9338: AND
9339: IFFALSE 9685
9341: GO 9343
9343: DISABLE
9344: LD_INT 0
9346: PPUSH
9347: PPUSH
// begin enable ;
9348: ENABLE
// if JMMGirl = 1 then
9349: LD_EXP 7
9353: PUSH
9354: LD_INT 1
9356: EQUAL
9357: IFFALSE 9374
// JMMGirlVeh = IsInUnit ( Joan ) ;
9359: LD_ADDR_VAR 0 1
9363: PUSH
9364: LD_EXP 2
9368: PPUSH
9369: CALL_OW 310
9373: ST_TO_ADDR
// if JMMGirl = 2 then
9374: LD_EXP 7
9378: PUSH
9379: LD_INT 2
9381: EQUAL
9382: IFFALSE 9399
// JMMGirlVeh = IsInUnit ( Lisa ) ;
9384: LD_ADDR_VAR 0 1
9388: PUSH
9389: LD_EXP 3
9393: PPUSH
9394: CALL_OW 310
9398: ST_TO_ADDR
// if JMMGirl = 3 then
9399: LD_EXP 7
9403: PUSH
9404: LD_INT 3
9406: EQUAL
9407: IFFALSE 9424
// JMMGirlVeh = IsInUnit ( Connie ) ;
9409: LD_ADDR_VAR 0 1
9413: PUSH
9414: LD_EXP 4
9418: PPUSH
9419: CALL_OW 310
9423: ST_TO_ADDR
// if GetDistUnits ( IsInUnit ( JMM ) , IsInUnit ( Joan ) ) < 10 or GetDistUnits ( IsInUnit ( JMM ) , IsInUnit ( Lisa ) ) < 10 or GetDistUnits ( IsInUnit ( JMM ) , IsInUnit ( Connie ) ) < 10 then
9424: LD_EXP 1
9428: PPUSH
9429: CALL_OW 310
9433: PPUSH
9434: LD_EXP 2
9438: PPUSH
9439: CALL_OW 310
9443: PPUSH
9444: CALL_OW 296
9448: PUSH
9449: LD_INT 10
9451: LESS
9452: PUSH
9453: LD_EXP 1
9457: PPUSH
9458: CALL_OW 310
9462: PPUSH
9463: LD_EXP 3
9467: PPUSH
9468: CALL_OW 310
9472: PPUSH
9473: CALL_OW 296
9477: PUSH
9478: LD_INT 10
9480: LESS
9481: OR
9482: PUSH
9483: LD_EXP 1
9487: PPUSH
9488: CALL_OW 310
9492: PPUSH
9493: LD_EXP 4
9497: PPUSH
9498: CALL_OW 310
9502: PPUSH
9503: CALL_OW 296
9507: PUSH
9508: LD_INT 10
9510: LESS
9511: OR
9512: IFFALSE 9606
// begin case Query ( Q3b ) of 1 :
9514: LD_STRING Q3b
9516: PPUSH
9517: CALL_OW 97
9521: PUSH
9522: LD_INT 1
9524: DOUBLE
9525: EQUAL
9526: IFTRUE 9530
9528: GO 9603
9530: POP
// begin SaveVariable ( [ [ GetChassis ( JMMGirlVeh ) ] , [ GetEngine ( JMMGirlVeh ) ] , [ GetControl ( JMMGirlVeh ) ] , [ GetWeapon ( JMMGirlVeh ) ] ] , 14_JMMGirlVeh_1 ) ;
9531: LD_VAR 0 1
9535: PPUSH
9536: CALL_OW 265
9540: PUSH
9541: EMPTY
9542: LIST
9543: PUSH
9544: LD_VAR 0 1
9548: PPUSH
9549: CALL_OW 262
9553: PUSH
9554: EMPTY
9555: LIST
9556: PUSH
9557: LD_VAR 0 1
9561: PPUSH
9562: CALL_OW 263
9566: PUSH
9567: EMPTY
9568: LIST
9569: PUSH
9570: LD_VAR 0 1
9574: PPUSH
9575: CALL_OW 264
9579: PUSH
9580: EMPTY
9581: LIST
9582: PUSH
9583: EMPTY
9584: LIST
9585: LIST
9586: LIST
9587: LIST
9588: PPUSH
9589: LD_STRING 14_JMMGirlVeh_1
9591: PPUSH
9592: CALL_OW 39
// FinishMission ;
9596: CALL 9826 0 0
// disable ;
9600: DISABLE
// end ; end ;
9601: GO 9604
9603: POP
// end else
9604: GO 9685
// begin if JMMGirl = 1 then
9606: LD_EXP 7
9610: PUSH
9611: LD_INT 1
9613: EQUAL
9614: IFFALSE 9631
// dec := Query ( Q3bJ ) else
9616: LD_ADDR_VAR 0 2
9620: PUSH
9621: LD_STRING Q3bJ
9623: PPUSH
9624: CALL_OW 97
9628: ST_TO_ADDR
9629: GO 9669
// if JMMGirl = 2 then
9631: LD_EXP 7
9635: PUSH
9636: LD_INT 2
9638: EQUAL
9639: IFFALSE 9656
// dec := Query ( Q3bL ) else
9641: LD_ADDR_VAR 0 2
9645: PUSH
9646: LD_STRING Q3bL
9648: PPUSH
9649: CALL_OW 97
9653: ST_TO_ADDR
9654: GO 9669
// dec := Query ( Q3bX ) ;
9656: LD_ADDR_VAR 0 2
9660: PUSH
9661: LD_STRING Q3bX
9663: PPUSH
9664: CALL_OW 97
9668: ST_TO_ADDR
// if dec = 1 then
9669: LD_VAR 0 2
9673: PUSH
9674: LD_INT 1
9676: EQUAL
9677: IFFALSE 9685
// begin FinishMission ;
9679: CALL 9826 0 0
// exit ;
9683: GO 9685
// end ; end ; end ;
9685: PPOPN 2
9687: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and fastEnd = 0 do
9688: LD_INT 22
9690: PUSH
9691: LD_INT 3
9693: PUSH
9694: EMPTY
9695: LIST
9696: LIST
9697: PUSH
9698: LD_INT 21
9700: PUSH
9701: LD_INT 1
9703: PUSH
9704: EMPTY
9705: LIST
9706: LIST
9707: PUSH
9708: EMPTY
9709: LIST
9710: LIST
9711: PPUSH
9712: CALL_OW 69
9716: PUSH
9717: LD_INT 0
9719: EQUAL
9720: PUSH
9721: LD_EXP 15
9725: PUSH
9726: LD_INT 0
9728: EQUAL
9729: AND
9730: IFFALSE 9825
9732: GO 9734
9734: DISABLE
// begin DialogueOn ;
9735: CALL_OW 6
// Say ( JMM , DEnd-JMM-1 ) ;
9739: LD_EXP 1
9743: PPUSH
9744: LD_STRING DEnd-JMM-1
9746: PPUSH
9747: CALL_OW 88
// if JMMGirl = 1 then
9751: LD_EXP 7
9755: PUSH
9756: LD_INT 1
9758: EQUAL
9759: IFFALSE 9773
// Say ( Joan , DEnd-Joan-1 ) ;
9761: LD_EXP 2
9765: PPUSH
9766: LD_STRING DEnd-Joan-1
9768: PPUSH
9769: CALL_OW 88
// if JMMGirl = 2 then
9773: LD_EXP 7
9777: PUSH
9778: LD_INT 2
9780: EQUAL
9781: IFFALSE 9795
// Say ( Lisa , DEnd-Lisa-1 ) ;
9783: LD_EXP 3
9787: PPUSH
9788: LD_STRING DEnd-Lisa-1
9790: PPUSH
9791: CALL_OW 88
// if JMMGirl = 3 then
9795: LD_EXP 7
9799: PUSH
9800: LD_INT 3
9802: EQUAL
9803: IFFALSE 9817
// Say ( Connie , DEnd-Con-1 ) ;
9805: LD_EXP 4
9809: PPUSH
9810: LD_STRING DEnd-Con-1
9812: PPUSH
9813: CALL_OW 88
// DialogueOff ;
9817: CALL_OW 7
// FinishMission ;
9821: CALL 9826 0 0
// end ;
9825: END
// export function FinishMission ; var JMMNewVeh , m1 , m2 , m3 ; begin
9826: LD_INT 0
9828: PPUSH
9829: PPUSH
9830: PPUSH
9831: PPUSH
9832: PPUSH
// m1 := false ;
9833: LD_ADDR_VAR 0 3
9837: PUSH
9838: LD_INT 0
9840: ST_TO_ADDR
// m2 := false ;
9841: LD_ADDR_VAR 0 4
9845: PUSH
9846: LD_INT 0
9848: ST_TO_ADDR
// m3 := false ;
9849: LD_ADDR_VAR 0 5
9853: PUSH
9854: LD_INT 0
9856: ST_TO_ADDR
// SaveCharacters ( JMM , 14_JMM ) ;
9857: LD_EXP 1
9861: PPUSH
9862: LD_STRING 14_JMM
9864: PPUSH
9865: CALL_OW 38
// if tick <= 50 50$00 then
9869: LD_OWVAR 1
9873: PUSH
9874: LD_INT 105000
9876: LESSEQUAL
9877: IFFALSE 9886
// SetAchievement ( ACH_ASPEED_14 ) ;
9879: LD_STRING ACH_ASPEED_14
9881: PPUSH
9882: CALL_OW 543
// if IsInUnit ( JMM ) and GetType ( IsInUnit ( JMM ) ) = unit_vehicle then
9886: LD_EXP 1
9890: PPUSH
9891: CALL_OW 310
9895: PUSH
9896: LD_EXP 1
9900: PPUSH
9901: CALL_OW 310
9905: PPUSH
9906: CALL_OW 247
9910: PUSH
9911: LD_INT 2
9913: EQUAL
9914: AND
9915: IFFALSE 9997
// begin JMMNewVeh = IsInUnit ( JMM ) ;
9917: LD_ADDR_VAR 0 2
9921: PUSH
9922: LD_EXP 1
9926: PPUSH
9927: CALL_OW 310
9931: ST_TO_ADDR
// SaveVariable ( [ [ GetChassis ( JMMNewVeh ) ] , [ GetEngine ( JMMNewVeh ) ] , [ GetControl ( JMMNewVeh ) ] , [ GetWeapon ( JMMNewVeh ) ] ] , 14_JMMVeh_1 ) ;
9932: LD_VAR 0 2
9936: PPUSH
9937: CALL_OW 265
9941: PUSH
9942: EMPTY
9943: LIST
9944: PUSH
9945: LD_VAR 0 2
9949: PPUSH
9950: CALL_OW 262
9954: PUSH
9955: EMPTY
9956: LIST
9957: PUSH
9958: LD_VAR 0 2
9962: PPUSH
9963: CALL_OW 263
9967: PUSH
9968: EMPTY
9969: LIST
9970: PUSH
9971: LD_VAR 0 2
9975: PPUSH
9976: CALL_OW 264
9980: PUSH
9981: EMPTY
9982: LIST
9983: PUSH
9984: EMPTY
9985: LIST
9986: LIST
9987: LIST
9988: LIST
9989: PPUSH
9990: LD_STRING 14_JMMVeh_1
9992: PPUSH
9993: CALL_OW 39
// end ; if fastEnd = 1 then
9997: LD_EXP 15
10001: PUSH
10002: LD_INT 1
10004: EQUAL
10005: IFFALSE 10094
// begin AddMedal ( fastend , - 1 ) ;
10007: LD_STRING fastend
10009: PPUSH
10010: LD_INT 1
10012: NEG
10013: PPUSH
10014: CALL_OW 101
// AddMedal ( fastend , - 1 ) ;
10018: LD_STRING fastend
10020: PPUSH
10021: LD_INT 1
10023: NEG
10024: PPUSH
10025: CALL_OW 101
// AddMedal ( fastend , - 1 ) ;
10029: LD_STRING fastend
10031: PPUSH
10032: LD_INT 1
10034: NEG
10035: PPUSH
10036: CALL_OW 101
// SaveVariable ( JMMGirl , 14_JMMGirl_1 ) ;
10040: LD_EXP 7
10044: PPUSH
10045: LD_STRING 14_JMMGirl_1
10047: PPUSH
10048: CALL_OW 39
// SaveVariable ( 0 , 14_JMMGirlStatus_1 ) ;
10052: LD_INT 0
10054: PPUSH
10055: LD_STRING 14_JMMGirlStatus_1
10057: PPUSH
10058: CALL_OW 39
// SaveVariable ( 0 , 14_KappaStatus_1 ) ;
10062: LD_INT 0
10064: PPUSH
10065: LD_STRING 14_KappaStatus_1
10067: PPUSH
10068: CALL_OW 39
// GiveMedals ( Eliminate ) ;
10072: LD_STRING Eliminate
10074: PPUSH
10075: CALL_OW 102
// RewardPeople ( JMM ) ;
10079: LD_EXP 1
10083: PPUSH
10084: CALL_OW 43
// YouWin ;
10088: CALL_OW 103
// exit ;
10092: GO 10919
// end ; if fastEnd = 0 then
10094: LD_EXP 15
10098: PUSH
10099: LD_INT 0
10101: EQUAL
10102: IFFALSE 10812
// begin SaveVariable ( JMMGirl , 14_JMMGirl_1 ) ;
10104: LD_EXP 7
10108: PPUSH
10109: LD_STRING 14_JMMGirl_1
10111: PPUSH
10112: CALL_OW 39
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and GetSide ( us_depot ) = 1 then
10116: LD_INT 22
10118: PUSH
10119: LD_INT 3
10121: PUSH
10122: EMPTY
10123: LIST
10124: LIST
10125: PUSH
10126: LD_INT 21
10128: PUSH
10129: LD_INT 1
10131: PUSH
10132: EMPTY
10133: LIST
10134: LIST
10135: PUSH
10136: EMPTY
10137: LIST
10138: LIST
10139: PPUSH
10140: CALL_OW 69
10144: PUSH
10145: LD_INT 0
10147: EQUAL
10148: PUSH
10149: LD_INT 48
10151: PPUSH
10152: CALL_OW 255
10156: PUSH
10157: LD_INT 1
10159: EQUAL
10160: AND
10161: IFFALSE 10175
// SaveVariable ( 1 , 14_KappaStatus_1 ) else
10163: LD_INT 1
10165: PPUSH
10166: LD_STRING 14_KappaStatus_1
10168: PPUSH
10169: CALL_OW 39
10173: GO 10185
// SaveVariable ( 0 , 14_KappaStatus_1 ) ;
10175: LD_INT 0
10177: PPUSH
10178: LD_STRING 14_KappaStatus_1
10180: PPUSH
10181: CALL_OW 39
// case JMMGirl of 1 :
10185: LD_EXP 7
10189: PUSH
10190: LD_INT 1
10192: DOUBLE
10193: EQUAL
10194: IFTRUE 10198
10196: GO 10354
10198: POP
// begin if IsOk ( Joan ) and GetSide ( Joan ) = 1 and ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 or GetDistUnits ( IsInUnit ( JMM ) , IsInUnit ( Joan ) ) < 10 ) then
10199: LD_EXP 2
10203: PPUSH
10204: CALL_OW 302
10208: PUSH
10209: LD_EXP 2
10213: PPUSH
10214: CALL_OW 255
10218: PUSH
10219: LD_INT 1
10221: EQUAL
10222: AND
10223: PUSH
10224: LD_INT 22
10226: PUSH
10227: LD_INT 3
10229: PUSH
10230: EMPTY
10231: LIST
10232: LIST
10233: PUSH
10234: LD_INT 21
10236: PUSH
10237: LD_INT 1
10239: PUSH
10240: EMPTY
10241: LIST
10242: LIST
10243: PUSH
10244: EMPTY
10245: LIST
10246: LIST
10247: PPUSH
10248: CALL_OW 69
10252: PUSH
10253: LD_INT 0
10255: EQUAL
10256: PUSH
10257: LD_EXP 1
10261: PPUSH
10262: CALL_OW 310
10266: PPUSH
10267: LD_EXP 2
10271: PPUSH
10272: CALL_OW 310
10276: PPUSH
10277: CALL_OW 296
10281: PUSH
10282: LD_INT 10
10284: LESS
10285: OR
10286: AND
10287: IFFALSE 10331
// begin SaveVariable ( 1 , 14_JMMGirlStatus_1 ) ;
10289: LD_INT 1
10291: PPUSH
10292: LD_STRING 14_JMMGirlStatus_1
10294: PPUSH
10295: CALL_OW 39
// SaveCharacters ( Joan , 14_Joan ) ;
10299: LD_EXP 2
10303: PPUSH
10304: LD_STRING 14_Joan
10306: PPUSH
10307: CALL_OW 38
// AddMedal ( protect , 1 ) ;
10311: LD_STRING protect
10313: PPUSH
10314: LD_INT 1
10316: PPUSH
10317: CALL_OW 101
// m1 := true ;
10321: LD_ADDR_VAR 0 3
10325: PUSH
10326: LD_INT 1
10328: ST_TO_ADDR
// end else
10329: GO 10352
// begin SaveVariable ( 0 , 14_JMMGirlStatus_1 ) ;
10331: LD_INT 0
10333: PPUSH
10334: LD_STRING 14_JMMGirlStatus_1
10336: PPUSH
10337: CALL_OW 39
// AddMedal ( protect , - 1 ) ;
10341: LD_STRING protect
10343: PPUSH
10344: LD_INT 1
10346: NEG
10347: PPUSH
10348: CALL_OW 101
// end ; end ; 2 :
10352: GO 10683
10354: LD_INT 2
10356: DOUBLE
10357: EQUAL
10358: IFTRUE 10362
10360: GO 10518
10362: POP
// begin if IsOk ( Lisa ) and GetSide ( Lisa ) = 1 and ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 or GetDistUnits ( IsInUnit ( JMM ) , IsInUnit ( Lisa ) ) < 10 ) then
10363: LD_EXP 3
10367: PPUSH
10368: CALL_OW 302
10372: PUSH
10373: LD_EXP 3
10377: PPUSH
10378: CALL_OW 255
10382: PUSH
10383: LD_INT 1
10385: EQUAL
10386: AND
10387: PUSH
10388: LD_INT 22
10390: PUSH
10391: LD_INT 3
10393: PUSH
10394: EMPTY
10395: LIST
10396: LIST
10397: PUSH
10398: LD_INT 21
10400: PUSH
10401: LD_INT 1
10403: PUSH
10404: EMPTY
10405: LIST
10406: LIST
10407: PUSH
10408: EMPTY
10409: LIST
10410: LIST
10411: PPUSH
10412: CALL_OW 69
10416: PUSH
10417: LD_INT 0
10419: EQUAL
10420: PUSH
10421: LD_EXP 1
10425: PPUSH
10426: CALL_OW 310
10430: PPUSH
10431: LD_EXP 3
10435: PPUSH
10436: CALL_OW 310
10440: PPUSH
10441: CALL_OW 296
10445: PUSH
10446: LD_INT 10
10448: LESS
10449: OR
10450: AND
10451: IFFALSE 10495
// begin SaveVariable ( 1 , 14_JMMGirlStatus_1 ) ;
10453: LD_INT 1
10455: PPUSH
10456: LD_STRING 14_JMMGirlStatus_1
10458: PPUSH
10459: CALL_OW 39
// SaveCharacters ( Lisa , 14_Lisa ) ;
10463: LD_EXP 3
10467: PPUSH
10468: LD_STRING 14_Lisa
10470: PPUSH
10471: CALL_OW 38
// AddMedal ( protect , 1 ) ;
10475: LD_STRING protect
10477: PPUSH
10478: LD_INT 1
10480: PPUSH
10481: CALL_OW 101
// m1 := true ;
10485: LD_ADDR_VAR 0 3
10489: PUSH
10490: LD_INT 1
10492: ST_TO_ADDR
// end else
10493: GO 10516
// begin SaveVariable ( 0 , 14_JMMGirlStatus_1 ) ;
10495: LD_INT 0
10497: PPUSH
10498: LD_STRING 14_JMMGirlStatus_1
10500: PPUSH
10501: CALL_OW 39
// AddMedal ( protect , - 2 ) ;
10505: LD_STRING protect
10507: PPUSH
10508: LD_INT 2
10510: NEG
10511: PPUSH
10512: CALL_OW 101
// end ; end ; 3 :
10516: GO 10683
10518: LD_INT 3
10520: DOUBLE
10521: EQUAL
10522: IFTRUE 10526
10524: GO 10682
10526: POP
// begin if IsOk ( Connie ) and GetSide ( Connie ) = 1 and ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 or GetDistUnits ( IsInUnit ( JMM ) , IsInUnit ( Connie ) ) < 10 ) then
10527: LD_EXP 4
10531: PPUSH
10532: CALL_OW 302
10536: PUSH
10537: LD_EXP 4
10541: PPUSH
10542: CALL_OW 255
10546: PUSH
10547: LD_INT 1
10549: EQUAL
10550: AND
10551: PUSH
10552: LD_INT 22
10554: PUSH
10555: LD_INT 3
10557: PUSH
10558: EMPTY
10559: LIST
10560: LIST
10561: PUSH
10562: LD_INT 21
10564: PUSH
10565: LD_INT 1
10567: PUSH
10568: EMPTY
10569: LIST
10570: LIST
10571: PUSH
10572: EMPTY
10573: LIST
10574: LIST
10575: PPUSH
10576: CALL_OW 69
10580: PUSH
10581: LD_INT 0
10583: EQUAL
10584: PUSH
10585: LD_EXP 1
10589: PPUSH
10590: CALL_OW 310
10594: PPUSH
10595: LD_EXP 4
10599: PPUSH
10600: CALL_OW 310
10604: PPUSH
10605: CALL_OW 296
10609: PUSH
10610: LD_INT 10
10612: LESS
10613: OR
10614: AND
10615: IFFALSE 10659
// begin SaveVariable ( 1 , 14_JMMGirlStatus_1 ) ;
10617: LD_INT 1
10619: PPUSH
10620: LD_STRING 14_JMMGirlStatus_1
10622: PPUSH
10623: CALL_OW 39
// SaveCharacters ( Connie , 14_Connie ) ;
10627: LD_EXP 4
10631: PPUSH
10632: LD_STRING 14_Connie
10634: PPUSH
10635: CALL_OW 38
// AddMedal ( protect , 1 ) ;
10639: LD_STRING protect
10641: PPUSH
10642: LD_INT 1
10644: PPUSH
10645: CALL_OW 101
// m1 := true ;
10649: LD_ADDR_VAR 0 3
10653: PUSH
10654: LD_INT 1
10656: ST_TO_ADDR
// end else
10657: GO 10680
// begin SaveVariable ( 0 , 14_JMMGirlStatus_1 ) ;
10659: LD_INT 0
10661: PPUSH
10662: LD_STRING 14_JMMGirlStatus_1
10664: PPUSH
10665: CALL_OW 39
// AddMedal ( protect , - 3 ) ;
10669: LD_STRING protect
10671: PPUSH
10672: LD_INT 3
10674: NEG
10675: PPUSH
10676: CALL_OW 101
// end ; end ; end ;
10680: GO 10683
10682: POP
// if amLaserCounter >= 2 then
10683: LD_EXP 9
10687: PUSH
10688: LD_INT 2
10690: GREATEREQUAL
10691: IFFALSE 10713
// begin AddMedal ( double , 1 ) ;
10693: LD_STRING double
10695: PPUSH
10696: LD_INT 1
10698: PPUSH
10699: CALL_OW 101
// m2 := true ;
10703: LD_ADDR_VAR 0 4
10707: PUSH
10708: LD_INT 1
10710: ST_TO_ADDR
// end else
10711: GO 10747
// begin if amLaserCounter = 1 then
10713: LD_EXP 9
10717: PUSH
10718: LD_INT 1
10720: EQUAL
10721: IFFALSE 10736
// AddMedal ( double , - 2 ) else
10723: LD_STRING double
10725: PPUSH
10726: LD_INT 2
10728: NEG
10729: PPUSH
10730: CALL_OW 101
10734: GO 10747
// AddMedal ( double , - 1 ) ;
10736: LD_STRING double
10738: PPUSH
10739: LD_INT 1
10741: NEG
10742: PPUSH
10743: CALL_OW 101
// end ; if FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 then
10747: LD_INT 22
10749: PUSH
10750: LD_INT 3
10752: PUSH
10753: EMPTY
10754: LIST
10755: LIST
10756: PUSH
10757: LD_INT 21
10759: PUSH
10760: LD_INT 1
10762: PUSH
10763: EMPTY
10764: LIST
10765: LIST
10766: PUSH
10767: EMPTY
10768: LIST
10769: LIST
10770: PPUSH
10771: CALL_OW 69
10775: PUSH
10776: LD_INT 0
10778: EQUAL
10779: IFFALSE 10801
// begin AddMedal ( base , 1 ) ;
10781: LD_STRING base
10783: PPUSH
10784: LD_INT 1
10786: PPUSH
10787: CALL_OW 101
// m3 := true ;
10791: LD_ADDR_VAR 0 5
10795: PUSH
10796: LD_INT 1
10798: ST_TO_ADDR
// end else
10799: GO 10812
// AddMedal ( base , - 1 ) ;
10801: LD_STRING base
10803: PPUSH
10804: LD_INT 1
10806: NEG
10807: PPUSH
10808: CALL_OW 101
// end ; if m1 and m2 and m3 and Difficulty = 3 then
10812: LD_VAR 0 3
10816: PUSH
10817: LD_VAR 0 4
10821: AND
10822: PUSH
10823: LD_VAR 0 5
10827: AND
10828: PUSH
10829: LD_OWVAR 67
10833: PUSH
10834: LD_INT 3
10836: EQUAL
10837: AND
10838: IFFALSE 10850
// SetAchievementEX ( ACH_AMER , 14 ) ;
10840: LD_STRING ACH_AMER
10842: PPUSH
10843: LD_INT 14
10845: PPUSH
10846: CALL_OW 564
// GiveMedals ( Eliminate ) ;
10850: LD_STRING Eliminate
10852: PPUSH
10853: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) ) ;
10857: LD_INT 22
10859: PUSH
10860: LD_INT 1
10862: PUSH
10863: EMPTY
10864: LIST
10865: LIST
10866: PUSH
10867: LD_INT 3
10869: PUSH
10870: LD_INT 25
10872: PUSH
10873: LD_INT 12
10875: PUSH
10876: EMPTY
10877: LIST
10878: LIST
10879: PUSH
10880: EMPTY
10881: LIST
10882: LIST
10883: PUSH
10884: LD_INT 3
10886: PUSH
10887: LD_INT 25
10889: PUSH
10890: LD_INT 16
10892: PUSH
10893: EMPTY
10894: LIST
10895: LIST
10896: PUSH
10897: EMPTY
10898: LIST
10899: LIST
10900: PUSH
10901: EMPTY
10902: LIST
10903: LIST
10904: LIST
10905: PPUSH
10906: CALL_OW 69
10910: PPUSH
10911: CALL_OW 43
// YouWin ;
10915: CALL_OW 103
// end ; end_of_file
10919: LD_VAR 0 1
10923: RET
// every 0 0$1 trigger IsDead ( JMM ) do
10924: LD_EXP 1
10928: PPUSH
10929: CALL_OW 301
10933: IFFALSE 10945
10935: GO 10937
10937: DISABLE
// YouLost ( JMM ) ; end_of_file
10938: LD_STRING JMM
10940: PPUSH
10941: CALL_OW 104
10945: END
// every 1 1$0 do
10946: GO 10948
10948: DISABLE
// begin enable ;
10949: ENABLE
// CreateCratesArea ( rand ( 3 , 5 ) , CratesArea , true ) ;
10950: LD_INT 3
10952: PPUSH
10953: LD_INT 5
10955: PPUSH
10956: CALL_OW 12
10960: PPUSH
10961: LD_INT 13
10963: PPUSH
10964: LD_INT 1
10966: PPUSH
10967: CALL_OW 55
// end ; end_of_file
10971: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
10972: GO 10974
10974: DISABLE
// begin ru_radar := 98 ;
10975: LD_ADDR_EXP 19
10979: PUSH
10980: LD_INT 98
10982: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
10983: LD_ADDR_EXP 20
10987: PUSH
10988: LD_INT 89
10990: ST_TO_ADDR
// us_hack := 99 ;
10991: LD_ADDR_EXP 21
10995: PUSH
10996: LD_INT 99
10998: ST_TO_ADDR
// us_artillery := 97 ;
10999: LD_ADDR_EXP 22
11003: PUSH
11004: LD_INT 97
11006: ST_TO_ADDR
// ar_bio_bomb := 91 ;
11007: LD_ADDR_EXP 23
11011: PUSH
11012: LD_INT 91
11014: ST_TO_ADDR
// end ; end_of_file end_of_file
11015: END
// export StreamModeActive , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote ; every 0 0$1 do
11016: GO 11018
11018: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
11019: LD_STRING initStreamRollete();
11021: PPUSH
11022: CALL_OW 559
// InitStreamMode ;
11026: CALL 11031 0 0
// end ;
11030: END
// function InitStreamMode ; begin
11031: LD_INT 0
11033: PPUSH
// streamModeActive := false ;
11034: LD_ADDR_EXP 24
11038: PUSH
11039: LD_INT 0
11041: ST_TO_ADDR
// sRocket := false ;
11042: LD_ADDR_EXP 27
11046: PUSH
11047: LD_INT 0
11049: ST_TO_ADDR
// sSpeed := false ;
11050: LD_ADDR_EXP 26
11054: PUSH
11055: LD_INT 0
11057: ST_TO_ADDR
// sEngine := false ;
11058: LD_ADDR_EXP 28
11062: PUSH
11063: LD_INT 0
11065: ST_TO_ADDR
// sSpec := false ;
11066: LD_ADDR_EXP 25
11070: PUSH
11071: LD_INT 0
11073: ST_TO_ADDR
// sLevel := false ;
11074: LD_ADDR_EXP 29
11078: PUSH
11079: LD_INT 0
11081: ST_TO_ADDR
// sArmoury := false ;
11082: LD_ADDR_EXP 30
11086: PUSH
11087: LD_INT 0
11089: ST_TO_ADDR
// sRadar := false ;
11090: LD_ADDR_EXP 31
11094: PUSH
11095: LD_INT 0
11097: ST_TO_ADDR
// sBunker := false ;
11098: LD_ADDR_EXP 32
11102: PUSH
11103: LD_INT 0
11105: ST_TO_ADDR
// sHack := false ;
11106: LD_ADDR_EXP 33
11110: PUSH
11111: LD_INT 0
11113: ST_TO_ADDR
// sFire := false ;
11114: LD_ADDR_EXP 34
11118: PUSH
11119: LD_INT 0
11121: ST_TO_ADDR
// sRefresh := false ;
11122: LD_ADDR_EXP 35
11126: PUSH
11127: LD_INT 0
11129: ST_TO_ADDR
// sExp := false ;
11130: LD_ADDR_EXP 36
11134: PUSH
11135: LD_INT 0
11137: ST_TO_ADDR
// sDepot := false ;
11138: LD_ADDR_EXP 37
11142: PUSH
11143: LD_INT 0
11145: ST_TO_ADDR
// sFlag := false ;
11146: LD_ADDR_EXP 38
11150: PUSH
11151: LD_INT 0
11153: ST_TO_ADDR
// sKamikadze := false ;
11154: LD_ADDR_EXP 46
11158: PUSH
11159: LD_INT 0
11161: ST_TO_ADDR
// sTroll := false ;
11162: LD_ADDR_EXP 47
11166: PUSH
11167: LD_INT 0
11169: ST_TO_ADDR
// sSlow := false ;
11170: LD_ADDR_EXP 48
11174: PUSH
11175: LD_INT 0
11177: ST_TO_ADDR
// sLack := false ;
11178: LD_ADDR_EXP 49
11182: PUSH
11183: LD_INT 0
11185: ST_TO_ADDR
// sTank := false ;
11186: LD_ADDR_EXP 51
11190: PUSH
11191: LD_INT 0
11193: ST_TO_ADDR
// sRemote := false ;
11194: LD_ADDR_EXP 52
11198: PUSH
11199: LD_INT 0
11201: ST_TO_ADDR
// sSold := false ;
11202: LD_ADDR_EXP 39
11206: PUSH
11207: LD_INT 0
11209: ST_TO_ADDR
// sDiff := false ;
11210: LD_ADDR_EXP 40
11214: PUSH
11215: LD_INT 0
11217: ST_TO_ADDR
// sFog := false ;
11218: LD_ADDR_EXP 43
11222: PUSH
11223: LD_INT 0
11225: ST_TO_ADDR
// sReset := false ;
11226: LD_ADDR_EXP 44
11230: PUSH
11231: LD_INT 0
11233: ST_TO_ADDR
// sSun := false ;
11234: LD_ADDR_EXP 45
11238: PUSH
11239: LD_INT 0
11241: ST_TO_ADDR
// sTiger := false ;
11242: LD_ADDR_EXP 41
11246: PUSH
11247: LD_INT 0
11249: ST_TO_ADDR
// sBomb := false ;
11250: LD_ADDR_EXP 42
11254: PUSH
11255: LD_INT 0
11257: ST_TO_ADDR
// sWound := false ;
11258: LD_ADDR_EXP 50
11262: PUSH
11263: LD_INT 0
11265: ST_TO_ADDR
// end ;
11266: LD_VAR 0 1
11270: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
11271: LD_VAR 0 2
11275: PUSH
11276: LD_INT 100
11278: EQUAL
11279: IFFALSE 11814
// begin if not StreamModeActive then
11281: LD_EXP 24
11285: NOT
11286: IFFALSE 11296
// StreamModeActive := true ;
11288: LD_ADDR_EXP 24
11292: PUSH
11293: LD_INT 1
11295: ST_TO_ADDR
// if p3 = 0 then
11296: LD_VAR 0 3
11300: PUSH
11301: LD_INT 0
11303: EQUAL
11304: IFFALSE 11310
// InitStreamMode ;
11306: CALL 11031 0 0
// if p3 = 1 then
11310: LD_VAR 0 3
11314: PUSH
11315: LD_INT 1
11317: EQUAL
11318: IFFALSE 11328
// sRocket := true ;
11320: LD_ADDR_EXP 27
11324: PUSH
11325: LD_INT 1
11327: ST_TO_ADDR
// if p3 = 2 then
11328: LD_VAR 0 3
11332: PUSH
11333: LD_INT 2
11335: EQUAL
11336: IFFALSE 11346
// sSpeed := true ;
11338: LD_ADDR_EXP 26
11342: PUSH
11343: LD_INT 1
11345: ST_TO_ADDR
// if p3 = 3 then
11346: LD_VAR 0 3
11350: PUSH
11351: LD_INT 3
11353: EQUAL
11354: IFFALSE 11364
// sEngine := true ;
11356: LD_ADDR_EXP 28
11360: PUSH
11361: LD_INT 1
11363: ST_TO_ADDR
// if p3 = 4 then
11364: LD_VAR 0 3
11368: PUSH
11369: LD_INT 4
11371: EQUAL
11372: IFFALSE 11382
// sSpec := true ;
11374: LD_ADDR_EXP 25
11378: PUSH
11379: LD_INT 1
11381: ST_TO_ADDR
// if p3 = 5 then
11382: LD_VAR 0 3
11386: PUSH
11387: LD_INT 5
11389: EQUAL
11390: IFFALSE 11400
// sLevel := true ;
11392: LD_ADDR_EXP 29
11396: PUSH
11397: LD_INT 1
11399: ST_TO_ADDR
// if p3 = 6 then
11400: LD_VAR 0 3
11404: PUSH
11405: LD_INT 6
11407: EQUAL
11408: IFFALSE 11418
// sArmoury := true ;
11410: LD_ADDR_EXP 30
11414: PUSH
11415: LD_INT 1
11417: ST_TO_ADDR
// if p3 = 7 then
11418: LD_VAR 0 3
11422: PUSH
11423: LD_INT 7
11425: EQUAL
11426: IFFALSE 11436
// sRadar := true ;
11428: LD_ADDR_EXP 31
11432: PUSH
11433: LD_INT 1
11435: ST_TO_ADDR
// if p3 = 8 then
11436: LD_VAR 0 3
11440: PUSH
11441: LD_INT 8
11443: EQUAL
11444: IFFALSE 11454
// sBunker := true ;
11446: LD_ADDR_EXP 32
11450: PUSH
11451: LD_INT 1
11453: ST_TO_ADDR
// if p3 = 9 then
11454: LD_VAR 0 3
11458: PUSH
11459: LD_INT 9
11461: EQUAL
11462: IFFALSE 11472
// sHack := true ;
11464: LD_ADDR_EXP 33
11468: PUSH
11469: LD_INT 1
11471: ST_TO_ADDR
// if p3 = 10 then
11472: LD_VAR 0 3
11476: PUSH
11477: LD_INT 10
11479: EQUAL
11480: IFFALSE 11490
// sFire := true ;
11482: LD_ADDR_EXP 34
11486: PUSH
11487: LD_INT 1
11489: ST_TO_ADDR
// if p3 = 11 then
11490: LD_VAR 0 3
11494: PUSH
11495: LD_INT 11
11497: EQUAL
11498: IFFALSE 11508
// sRefresh := true ;
11500: LD_ADDR_EXP 35
11504: PUSH
11505: LD_INT 1
11507: ST_TO_ADDR
// if p3 = 12 then
11508: LD_VAR 0 3
11512: PUSH
11513: LD_INT 12
11515: EQUAL
11516: IFFALSE 11526
// sExp := true ;
11518: LD_ADDR_EXP 36
11522: PUSH
11523: LD_INT 1
11525: ST_TO_ADDR
// if p3 = 13 then
11526: LD_VAR 0 3
11530: PUSH
11531: LD_INT 13
11533: EQUAL
11534: IFFALSE 11544
// sDepot := true ;
11536: LD_ADDR_EXP 37
11540: PUSH
11541: LD_INT 1
11543: ST_TO_ADDR
// if p3 = 14 then
11544: LD_VAR 0 3
11548: PUSH
11549: LD_INT 14
11551: EQUAL
11552: IFFALSE 11562
// sFlag := true ;
11554: LD_ADDR_EXP 38
11558: PUSH
11559: LD_INT 1
11561: ST_TO_ADDR
// if p3 = 15 then
11562: LD_VAR 0 3
11566: PUSH
11567: LD_INT 15
11569: EQUAL
11570: IFFALSE 11580
// sKamikadze := true ;
11572: LD_ADDR_EXP 46
11576: PUSH
11577: LD_INT 1
11579: ST_TO_ADDR
// if p3 = 16 then
11580: LD_VAR 0 3
11584: PUSH
11585: LD_INT 16
11587: EQUAL
11588: IFFALSE 11598
// sTroll := true ;
11590: LD_ADDR_EXP 47
11594: PUSH
11595: LD_INT 1
11597: ST_TO_ADDR
// if p3 = 17 then
11598: LD_VAR 0 3
11602: PUSH
11603: LD_INT 17
11605: EQUAL
11606: IFFALSE 11616
// sSlow := true ;
11608: LD_ADDR_EXP 48
11612: PUSH
11613: LD_INT 1
11615: ST_TO_ADDR
// if p3 = 18 then
11616: LD_VAR 0 3
11620: PUSH
11621: LD_INT 18
11623: EQUAL
11624: IFFALSE 11634
// sLack := true ;
11626: LD_ADDR_EXP 49
11630: PUSH
11631: LD_INT 1
11633: ST_TO_ADDR
// if p3 = 19 then
11634: LD_VAR 0 3
11638: PUSH
11639: LD_INT 19
11641: EQUAL
11642: IFFALSE 11652
// sTank := true ;
11644: LD_ADDR_EXP 51
11648: PUSH
11649: LD_INT 1
11651: ST_TO_ADDR
// if p3 = 20 then
11652: LD_VAR 0 3
11656: PUSH
11657: LD_INT 20
11659: EQUAL
11660: IFFALSE 11670
// sRemote := true ;
11662: LD_ADDR_EXP 52
11666: PUSH
11667: LD_INT 1
11669: ST_TO_ADDR
// if p3 = 101 then
11670: LD_VAR 0 3
11674: PUSH
11675: LD_INT 101
11677: EQUAL
11678: IFFALSE 11688
// sSold := true ;
11680: LD_ADDR_EXP 39
11684: PUSH
11685: LD_INT 1
11687: ST_TO_ADDR
// if p3 = 102 then
11688: LD_VAR 0 3
11692: PUSH
11693: LD_INT 102
11695: EQUAL
11696: IFFALSE 11706
// sDiff := true ;
11698: LD_ADDR_EXP 40
11702: PUSH
11703: LD_INT 1
11705: ST_TO_ADDR
// if p3 = 103 then
11706: LD_VAR 0 3
11710: PUSH
11711: LD_INT 103
11713: EQUAL
11714: IFFALSE 11724
// sFog := true ;
11716: LD_ADDR_EXP 43
11720: PUSH
11721: LD_INT 1
11723: ST_TO_ADDR
// if p3 = 104 then
11724: LD_VAR 0 3
11728: PUSH
11729: LD_INT 104
11731: EQUAL
11732: IFFALSE 11742
// sReset := true ;
11734: LD_ADDR_EXP 44
11738: PUSH
11739: LD_INT 1
11741: ST_TO_ADDR
// if p3 = 105 then
11742: LD_VAR 0 3
11746: PUSH
11747: LD_INT 105
11749: EQUAL
11750: IFFALSE 11760
// sSun := true ;
11752: LD_ADDR_EXP 45
11756: PUSH
11757: LD_INT 1
11759: ST_TO_ADDR
// if p3 = 106 then
11760: LD_VAR 0 3
11764: PUSH
11765: LD_INT 106
11767: EQUAL
11768: IFFALSE 11778
// sTiger := true ;
11770: LD_ADDR_EXP 41
11774: PUSH
11775: LD_INT 1
11777: ST_TO_ADDR
// if p3 = 107 then
11778: LD_VAR 0 3
11782: PUSH
11783: LD_INT 107
11785: EQUAL
11786: IFFALSE 11796
// sBomb := true ;
11788: LD_ADDR_EXP 42
11792: PUSH
11793: LD_INT 1
11795: ST_TO_ADDR
// if p3 = 108 then
11796: LD_VAR 0 3
11800: PUSH
11801: LD_INT 108
11803: EQUAL
11804: IFFALSE 11814
// sWound := true ;
11806: LD_ADDR_EXP 50
11810: PUSH
11811: LD_INT 1
11813: ST_TO_ADDR
// end ; end ;
11814: PPOPN 6
11816: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
11817: LD_EXP 24
11821: PUSH
11822: LD_EXP 27
11826: AND
11827: IFFALSE 11948
11829: GO 11831
11831: DISABLE
11832: LD_INT 0
11834: PPUSH
11835: PPUSH
// begin enable ;
11836: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
11837: LD_ADDR_VAR 0 2
11841: PUSH
11842: LD_INT 22
11844: PUSH
11845: LD_OWVAR 2
11849: PUSH
11850: EMPTY
11851: LIST
11852: LIST
11853: PUSH
11854: LD_INT 2
11856: PUSH
11857: LD_INT 34
11859: PUSH
11860: LD_INT 7
11862: PUSH
11863: EMPTY
11864: LIST
11865: LIST
11866: PUSH
11867: LD_INT 34
11869: PUSH
11870: LD_INT 45
11872: PUSH
11873: EMPTY
11874: LIST
11875: LIST
11876: PUSH
11877: LD_INT 34
11879: PUSH
11880: LD_INT 28
11882: PUSH
11883: EMPTY
11884: LIST
11885: LIST
11886: PUSH
11887: LD_INT 34
11889: PUSH
11890: LD_INT 47
11892: PUSH
11893: EMPTY
11894: LIST
11895: LIST
11896: PUSH
11897: EMPTY
11898: LIST
11899: LIST
11900: LIST
11901: LIST
11902: LIST
11903: PUSH
11904: EMPTY
11905: LIST
11906: LIST
11907: PPUSH
11908: CALL_OW 69
11912: ST_TO_ADDR
// if not tmp then
11913: LD_VAR 0 2
11917: NOT
11918: IFFALSE 11922
// exit ;
11920: GO 11948
// for i in tmp do
11922: LD_ADDR_VAR 0 1
11926: PUSH
11927: LD_VAR 0 2
11931: PUSH
11932: FOR_IN
11933: IFFALSE 11946
// begin DestroyUnit ( i ) ;
11935: LD_VAR 0 1
11939: PPUSH
11940: CALL_OW 65
// end ;
11944: GO 11932
11946: POP
11947: POP
// end ;
11948: PPOPN 2
11950: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
11951: LD_EXP 24
11955: PUSH
11956: LD_EXP 28
11960: AND
11961: IFFALSE 12042
11963: GO 11965
11965: DISABLE
11966: LD_INT 0
11968: PPUSH
11969: PPUSH
// begin enable ;
11970: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
11971: LD_ADDR_VAR 0 2
11975: PUSH
11976: LD_INT 22
11978: PUSH
11979: LD_OWVAR 2
11983: PUSH
11984: EMPTY
11985: LIST
11986: LIST
11987: PUSH
11988: LD_INT 32
11990: PUSH
11991: LD_INT 3
11993: PUSH
11994: EMPTY
11995: LIST
11996: LIST
11997: PUSH
11998: EMPTY
11999: LIST
12000: LIST
12001: PPUSH
12002: CALL_OW 69
12006: ST_TO_ADDR
// if not tmp then
12007: LD_VAR 0 2
12011: NOT
12012: IFFALSE 12016
// exit ;
12014: GO 12042
// for i in tmp do
12016: LD_ADDR_VAR 0 1
12020: PUSH
12021: LD_VAR 0 2
12025: PUSH
12026: FOR_IN
12027: IFFALSE 12040
// begin DestroyUnit ( i ) ;
12029: LD_VAR 0 1
12033: PPUSH
12034: CALL_OW 65
// end ;
12038: GO 12026
12040: POP
12041: POP
// end ;
12042: PPOPN 2
12044: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
12045: LD_EXP 24
12049: PUSH
12050: LD_EXP 25
12054: AND
12055: IFFALSE 12148
12057: GO 12059
12059: DISABLE
12060: LD_INT 0
12062: PPUSH
// begin enable ;
12063: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
12064: LD_ADDR_VAR 0 1
12068: PUSH
12069: LD_INT 22
12071: PUSH
12072: LD_OWVAR 2
12076: PUSH
12077: EMPTY
12078: LIST
12079: LIST
12080: PUSH
12081: LD_INT 2
12083: PUSH
12084: LD_INT 25
12086: PUSH
12087: LD_INT 5
12089: PUSH
12090: EMPTY
12091: LIST
12092: LIST
12093: PUSH
12094: LD_INT 25
12096: PUSH
12097: LD_INT 9
12099: PUSH
12100: EMPTY
12101: LIST
12102: LIST
12103: PUSH
12104: LD_INT 25
12106: PUSH
12107: LD_INT 8
12109: PUSH
12110: EMPTY
12111: LIST
12112: LIST
12113: PUSH
12114: EMPTY
12115: LIST
12116: LIST
12117: LIST
12118: LIST
12119: PUSH
12120: EMPTY
12121: LIST
12122: LIST
12123: PPUSH
12124: CALL_OW 69
12128: PUSH
12129: FOR_IN
12130: IFFALSE 12146
// begin SetClass ( i , 1 ) ;
12132: LD_VAR 0 1
12136: PPUSH
12137: LD_INT 1
12139: PPUSH
12140: CALL_OW 336
// end ;
12144: GO 12129
12146: POP
12147: POP
// end ;
12148: PPOPN 1
12150: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
12151: LD_EXP 24
12155: PUSH
12156: LD_EXP 26
12160: AND
12161: PUSH
12162: LD_OWVAR 65
12166: PUSH
12167: LD_INT 7
12169: LESS
12170: AND
12171: IFFALSE 12185
12173: GO 12175
12175: DISABLE
// begin enable ;
12176: ENABLE
// game_speed := 7 ;
12177: LD_ADDR_OWVAR 65
12181: PUSH
12182: LD_INT 7
12184: ST_TO_ADDR
// end ;
12185: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
12186: LD_EXP 24
12190: PUSH
12191: LD_EXP 29
12195: AND
12196: IFFALSE 12398
12198: GO 12200
12200: DISABLE
12201: LD_INT 0
12203: PPUSH
12204: PPUSH
12205: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
12206: LD_ADDR_VAR 0 3
12210: PUSH
12211: LD_INT 81
12213: PUSH
12214: LD_OWVAR 2
12218: PUSH
12219: EMPTY
12220: LIST
12221: LIST
12222: PUSH
12223: LD_INT 21
12225: PUSH
12226: LD_INT 1
12228: PUSH
12229: EMPTY
12230: LIST
12231: LIST
12232: PUSH
12233: EMPTY
12234: LIST
12235: LIST
12236: PPUSH
12237: CALL_OW 69
12241: ST_TO_ADDR
// if not tmp then
12242: LD_VAR 0 3
12246: NOT
12247: IFFALSE 12251
// exit ;
12249: GO 12398
// if tmp > 5 then
12251: LD_VAR 0 3
12255: PUSH
12256: LD_INT 5
12258: GREATER
12259: IFFALSE 12271
// k := 5 else
12261: LD_ADDR_VAR 0 2
12265: PUSH
12266: LD_INT 5
12268: ST_TO_ADDR
12269: GO 12281
// k := tmp ;
12271: LD_ADDR_VAR 0 2
12275: PUSH
12276: LD_VAR 0 3
12280: ST_TO_ADDR
// for i := 1 to k do
12281: LD_ADDR_VAR 0 1
12285: PUSH
12286: DOUBLE
12287: LD_INT 1
12289: DEC
12290: ST_TO_ADDR
12291: LD_VAR 0 2
12295: PUSH
12296: FOR_TO
12297: IFFALSE 12396
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
12299: LD_VAR 0 3
12303: PUSH
12304: LD_VAR 0 1
12308: ARRAY
12309: PPUSH
12310: LD_VAR 0 1
12314: PUSH
12315: LD_INT 4
12317: MOD
12318: PUSH
12319: LD_INT 1
12321: PLUS
12322: PPUSH
12323: CALL_OW 259
12327: PUSH
12328: LD_INT 10
12330: LESS
12331: IFFALSE 12394
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
12333: LD_VAR 0 3
12337: PUSH
12338: LD_VAR 0 1
12342: ARRAY
12343: PPUSH
12344: LD_VAR 0 1
12348: PUSH
12349: LD_INT 4
12351: MOD
12352: PUSH
12353: LD_INT 1
12355: PLUS
12356: PPUSH
12357: LD_VAR 0 3
12361: PUSH
12362: LD_VAR 0 1
12366: ARRAY
12367: PPUSH
12368: LD_VAR 0 1
12372: PUSH
12373: LD_INT 4
12375: MOD
12376: PUSH
12377: LD_INT 1
12379: PLUS
12380: PPUSH
12381: CALL_OW 259
12385: PUSH
12386: LD_INT 1
12388: PLUS
12389: PPUSH
12390: CALL_OW 237
12394: GO 12296
12396: POP
12397: POP
// end ;
12398: PPOPN 3
12400: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
12401: LD_EXP 24
12405: PUSH
12406: LD_EXP 30
12410: AND
12411: IFFALSE 12431
12413: GO 12415
12415: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
12416: LD_INT 4
12418: PPUSH
12419: LD_OWVAR 2
12423: PPUSH
12424: LD_INT 0
12426: PPUSH
12427: CALL_OW 324
12431: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
12432: LD_EXP 24
12436: PUSH
12437: LD_EXP 31
12441: AND
12442: IFFALSE 12541
12444: GO 12446
12446: DISABLE
12447: LD_INT 0
12449: PPUSH
12450: PPUSH
// begin enable ;
12451: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
12452: LD_ADDR_VAR 0 2
12456: PUSH
12457: LD_INT 22
12459: PUSH
12460: LD_OWVAR 2
12464: PUSH
12465: EMPTY
12466: LIST
12467: LIST
12468: PUSH
12469: LD_INT 2
12471: PUSH
12472: LD_INT 34
12474: PUSH
12475: LD_INT 11
12477: PUSH
12478: EMPTY
12479: LIST
12480: LIST
12481: PUSH
12482: LD_INT 34
12484: PUSH
12485: LD_INT 30
12487: PUSH
12488: EMPTY
12489: LIST
12490: LIST
12491: PUSH
12492: EMPTY
12493: LIST
12494: LIST
12495: LIST
12496: PUSH
12497: EMPTY
12498: LIST
12499: LIST
12500: PPUSH
12501: CALL_OW 69
12505: ST_TO_ADDR
// if not tmp then
12506: LD_VAR 0 2
12510: NOT
12511: IFFALSE 12515
// exit ;
12513: GO 12541
// for i in tmp do
12515: LD_ADDR_VAR 0 1
12519: PUSH
12520: LD_VAR 0 2
12524: PUSH
12525: FOR_IN
12526: IFFALSE 12539
// begin DestroyUnit ( i ) ;
12528: LD_VAR 0 1
12532: PPUSH
12533: CALL_OW 65
// end ;
12537: GO 12525
12539: POP
12540: POP
// end ;
12541: PPOPN 2
12543: END
// every 0 0$1 trigger StreamModeActive and sBunker do
12544: LD_EXP 24
12548: PUSH
12549: LD_EXP 32
12553: AND
12554: IFFALSE 12574
12556: GO 12558
12558: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
12559: LD_INT 32
12561: PPUSH
12562: LD_OWVAR 2
12566: PPUSH
12567: LD_INT 0
12569: PPUSH
12570: CALL_OW 324
12574: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
12575: LD_EXP 24
12579: PUSH
12580: LD_EXP 33
12584: AND
12585: IFFALSE 12766
12587: GO 12589
12589: DISABLE
12590: LD_INT 0
12592: PPUSH
12593: PPUSH
12594: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
12595: LD_ADDR_VAR 0 2
12599: PUSH
12600: LD_INT 22
12602: PUSH
12603: LD_OWVAR 2
12607: PUSH
12608: EMPTY
12609: LIST
12610: LIST
12611: PUSH
12612: LD_INT 33
12614: PUSH
12615: LD_INT 3
12617: PUSH
12618: EMPTY
12619: LIST
12620: LIST
12621: PUSH
12622: EMPTY
12623: LIST
12624: LIST
12625: PPUSH
12626: CALL_OW 69
12630: ST_TO_ADDR
// if not tmp then
12631: LD_VAR 0 2
12635: NOT
12636: IFFALSE 12640
// exit ;
12638: GO 12766
// side := 0 ;
12640: LD_ADDR_VAR 0 3
12644: PUSH
12645: LD_INT 0
12647: ST_TO_ADDR
// for i := 1 to 8 do
12648: LD_ADDR_VAR 0 1
12652: PUSH
12653: DOUBLE
12654: LD_INT 1
12656: DEC
12657: ST_TO_ADDR
12658: LD_INT 8
12660: PUSH
12661: FOR_TO
12662: IFFALSE 12710
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
12664: LD_OWVAR 2
12668: PUSH
12669: LD_VAR 0 1
12673: NONEQUAL
12674: PUSH
12675: LD_OWVAR 2
12679: PPUSH
12680: LD_VAR 0 1
12684: PPUSH
12685: CALL_OW 81
12689: PUSH
12690: LD_INT 2
12692: EQUAL
12693: AND
12694: IFFALSE 12708
// begin side := i ;
12696: LD_ADDR_VAR 0 3
12700: PUSH
12701: LD_VAR 0 1
12705: ST_TO_ADDR
// break ;
12706: GO 12710
// end ;
12708: GO 12661
12710: POP
12711: POP
// if not side then
12712: LD_VAR 0 3
12716: NOT
12717: IFFALSE 12721
// exit ;
12719: GO 12766
// for i := 1 to tmp do
12721: LD_ADDR_VAR 0 1
12725: PUSH
12726: DOUBLE
12727: LD_INT 1
12729: DEC
12730: ST_TO_ADDR
12731: LD_VAR 0 2
12735: PUSH
12736: FOR_TO
12737: IFFALSE 12764
// if Prob ( 30 ) then
12739: LD_INT 30
12741: PPUSH
12742: CALL_OW 13
12746: IFFALSE 12762
// SetSide ( i , side ) ;
12748: LD_VAR 0 1
12752: PPUSH
12753: LD_VAR 0 3
12757: PPUSH
12758: CALL_OW 235
12762: GO 12736
12764: POP
12765: POP
// end ;
12766: PPOPN 3
12768: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
12769: LD_EXP 24
12773: PUSH
12774: LD_EXP 35
12778: AND
12779: IFFALSE 12898
12781: GO 12783
12783: DISABLE
12784: LD_INT 0
12786: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
12787: LD_ADDR_VAR 0 1
12791: PUSH
12792: LD_INT 22
12794: PUSH
12795: LD_OWVAR 2
12799: PUSH
12800: EMPTY
12801: LIST
12802: LIST
12803: PUSH
12804: LD_INT 21
12806: PUSH
12807: LD_INT 1
12809: PUSH
12810: EMPTY
12811: LIST
12812: LIST
12813: PUSH
12814: LD_INT 3
12816: PUSH
12817: LD_INT 23
12819: PUSH
12820: LD_INT 0
12822: PUSH
12823: EMPTY
12824: LIST
12825: LIST
12826: PUSH
12827: EMPTY
12828: LIST
12829: LIST
12830: PUSH
12831: EMPTY
12832: LIST
12833: LIST
12834: LIST
12835: PPUSH
12836: CALL_OW 69
12840: PUSH
12841: FOR_IN
12842: IFFALSE 12896
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
12844: LD_VAR 0 1
12848: PPUSH
12849: CALL_OW 257
12853: PUSH
12854: LD_INT 1
12856: PUSH
12857: LD_INT 2
12859: PUSH
12860: LD_INT 3
12862: PUSH
12863: LD_INT 4
12865: PUSH
12866: EMPTY
12867: LIST
12868: LIST
12869: LIST
12870: LIST
12871: IN
12872: IFFALSE 12894
// SetClass ( un , rand ( 1 , 4 ) ) ;
12874: LD_VAR 0 1
12878: PPUSH
12879: LD_INT 1
12881: PPUSH
12882: LD_INT 4
12884: PPUSH
12885: CALL_OW 12
12889: PPUSH
12890: CALL_OW 336
12894: GO 12841
12896: POP
12897: POP
// end ;
12898: PPOPN 1
12900: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
12901: LD_EXP 24
12905: PUSH
12906: LD_EXP 34
12910: AND
12911: IFFALSE 12990
12913: GO 12915
12915: DISABLE
12916: LD_INT 0
12918: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
12919: LD_ADDR_VAR 0 1
12923: PUSH
12924: LD_INT 22
12926: PUSH
12927: LD_OWVAR 2
12931: PUSH
12932: EMPTY
12933: LIST
12934: LIST
12935: PUSH
12936: LD_INT 21
12938: PUSH
12939: LD_INT 3
12941: PUSH
12942: EMPTY
12943: LIST
12944: LIST
12945: PUSH
12946: EMPTY
12947: LIST
12948: LIST
12949: PPUSH
12950: CALL_OW 69
12954: ST_TO_ADDR
// if not tmp then
12955: LD_VAR 0 1
12959: NOT
12960: IFFALSE 12964
// exit ;
12962: GO 12990
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
12964: LD_VAR 0 1
12968: PUSH
12969: LD_INT 1
12971: PPUSH
12972: LD_VAR 0 1
12976: PPUSH
12977: CALL_OW 12
12981: ARRAY
12982: PPUSH
12983: LD_INT 100
12985: PPUSH
12986: CALL_OW 234
// end ;
12990: PPOPN 1
12992: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
12993: LD_EXP 24
12997: PUSH
12998: LD_EXP 36
13002: AND
13003: IFFALSE 13101
13005: GO 13007
13007: DISABLE
13008: LD_INT 0
13010: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
13011: LD_ADDR_VAR 0 1
13015: PUSH
13016: LD_INT 22
13018: PUSH
13019: LD_OWVAR 2
13023: PUSH
13024: EMPTY
13025: LIST
13026: LIST
13027: PUSH
13028: LD_INT 21
13030: PUSH
13031: LD_INT 1
13033: PUSH
13034: EMPTY
13035: LIST
13036: LIST
13037: PUSH
13038: EMPTY
13039: LIST
13040: LIST
13041: PPUSH
13042: CALL_OW 69
13046: ST_TO_ADDR
// if not tmp then
13047: LD_VAR 0 1
13051: NOT
13052: IFFALSE 13056
// exit ;
13054: GO 13101
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
13056: LD_VAR 0 1
13060: PUSH
13061: LD_INT 1
13063: PPUSH
13064: LD_VAR 0 1
13068: PPUSH
13069: CALL_OW 12
13073: ARRAY
13074: PPUSH
13075: LD_INT 1
13077: PPUSH
13078: LD_INT 4
13080: PPUSH
13081: CALL_OW 12
13085: PPUSH
13086: LD_INT 3000
13088: PPUSH
13089: LD_INT 9000
13091: PPUSH
13092: CALL_OW 12
13096: PPUSH
13097: CALL_OW 492
// end ;
13101: PPOPN 1
13103: END
// every 0 0$1 trigger StreamModeActive and sDepot do
13104: LD_EXP 24
13108: PUSH
13109: LD_EXP 37
13113: AND
13114: IFFALSE 13134
13116: GO 13118
13118: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
13119: LD_INT 1
13121: PPUSH
13122: LD_OWVAR 2
13126: PPUSH
13127: LD_INT 0
13129: PPUSH
13130: CALL_OW 324
13134: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
13135: LD_EXP 24
13139: PUSH
13140: LD_EXP 38
13144: AND
13145: IFFALSE 13228
13147: GO 13149
13149: DISABLE
13150: LD_INT 0
13152: PPUSH
13153: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
13154: LD_ADDR_VAR 0 2
13158: PUSH
13159: LD_INT 22
13161: PUSH
13162: LD_OWVAR 2
13166: PUSH
13167: EMPTY
13168: LIST
13169: LIST
13170: PUSH
13171: LD_INT 21
13173: PUSH
13174: LD_INT 3
13176: PUSH
13177: EMPTY
13178: LIST
13179: LIST
13180: PUSH
13181: EMPTY
13182: LIST
13183: LIST
13184: PPUSH
13185: CALL_OW 69
13189: ST_TO_ADDR
// if not tmp then
13190: LD_VAR 0 2
13194: NOT
13195: IFFALSE 13199
// exit ;
13197: GO 13228
// for i in tmp do
13199: LD_ADDR_VAR 0 1
13203: PUSH
13204: LD_VAR 0 2
13208: PUSH
13209: FOR_IN
13210: IFFALSE 13226
// SetBLevel ( i , 10 ) ;
13212: LD_VAR 0 1
13216: PPUSH
13217: LD_INT 10
13219: PPUSH
13220: CALL_OW 241
13224: GO 13209
13226: POP
13227: POP
// end ;
13228: PPOPN 2
13230: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , tmp ;
13231: LD_EXP 24
13235: PUSH
13236: LD_EXP 39
13240: AND
13241: IFFALSE 13344
13243: GO 13245
13245: DISABLE
13246: LD_INT 0
13248: PPUSH
13249: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
13250: LD_ADDR_VAR 0 2
13254: PUSH
13255: LD_INT 22
13257: PUSH
13258: LD_OWVAR 2
13262: PUSH
13263: EMPTY
13264: LIST
13265: LIST
13266: PUSH
13267: LD_INT 25
13269: PUSH
13270: LD_INT 1
13272: PUSH
13273: EMPTY
13274: LIST
13275: LIST
13276: PUSH
13277: EMPTY
13278: LIST
13279: LIST
13280: PPUSH
13281: CALL_OW 69
13285: ST_TO_ADDR
// if not tmp then
13286: LD_VAR 0 2
13290: NOT
13291: IFFALSE 13295
// exit ;
13293: GO 13344
// for i in tmp do
13295: LD_ADDR_VAR 0 1
13299: PUSH
13300: LD_VAR 0 2
13304: PUSH
13305: FOR_IN
13306: IFFALSE 13342
// begin if Crawls ( i ) then
13308: LD_VAR 0 1
13312: PPUSH
13313: CALL_OW 318
13317: IFFALSE 13328
// ComWalk ( i ) ;
13319: LD_VAR 0 1
13323: PPUSH
13324: CALL_OW 138
// SetClass ( i , 4 ) ;
13328: LD_VAR 0 1
13332: PPUSH
13333: LD_INT 4
13335: PPUSH
13336: CALL_OW 336
// end ;
13340: GO 13305
13342: POP
13343: POP
// end ;
13344: PPOPN 2
13346: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
13347: LD_EXP 24
13351: PUSH
13352: LD_EXP 40
13356: AND
13357: PUSH
13358: LD_OWVAR 67
13362: PUSH
13363: LD_INT 3
13365: LESS
13366: AND
13367: IFFALSE 13386
13369: GO 13371
13371: DISABLE
// Difficulty := Difficulty + 1 ;
13372: LD_ADDR_OWVAR 67
13376: PUSH
13377: LD_OWVAR 67
13381: PUSH
13382: LD_INT 1
13384: PLUS
13385: ST_TO_ADDR
13386: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
13387: LD_EXP 24
13391: PUSH
13392: LD_EXP 41
13396: AND
13397: IFFALSE 13500
13399: GO 13401
13401: DISABLE
13402: LD_INT 0
13404: PPUSH
// begin for i := 1 to 5 do
13405: LD_ADDR_VAR 0 1
13409: PUSH
13410: DOUBLE
13411: LD_INT 1
13413: DEC
13414: ST_TO_ADDR
13415: LD_INT 5
13417: PUSH
13418: FOR_TO
13419: IFFALSE 13498
// begin uc_nation := nation_nature ;
13421: LD_ADDR_OWVAR 21
13425: PUSH
13426: LD_INT 0
13428: ST_TO_ADDR
// uc_side := 0 ;
13429: LD_ADDR_OWVAR 20
13433: PUSH
13434: LD_INT 0
13436: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
13437: LD_ADDR_OWVAR 29
13441: PUSH
13442: LD_INT 12
13444: PUSH
13445: LD_INT 12
13447: PUSH
13448: EMPTY
13449: LIST
13450: LIST
13451: ST_TO_ADDR
// hc_agressivity := 20 ;
13452: LD_ADDR_OWVAR 35
13456: PUSH
13457: LD_INT 20
13459: ST_TO_ADDR
// hc_class := class_tiger ;
13460: LD_ADDR_OWVAR 28
13464: PUSH
13465: LD_INT 14
13467: ST_TO_ADDR
// hc_gallery :=  ;
13468: LD_ADDR_OWVAR 33
13472: PUSH
13473: LD_STRING 
13475: ST_TO_ADDR
// hc_name :=  ;
13476: LD_ADDR_OWVAR 26
13480: PUSH
13481: LD_STRING 
13483: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
13484: CALL_OW 44
13488: PPUSH
13489: LD_INT 0
13491: PPUSH
13492: CALL_OW 51
// end ;
13496: GO 13418
13498: POP
13499: POP
// end ;
13500: PPOPN 1
13502: END
// every 0 0$1 trigger StreamModeActive and sBomb do var i , x , y , result ;
13503: LD_EXP 24
13507: PUSH
13508: LD_EXP 42
13512: AND
13513: IFFALSE 13687
13515: GO 13517
13517: DISABLE
13518: LD_INT 0
13520: PPUSH
13521: PPUSH
13522: PPUSH
13523: PPUSH
// begin result := false ;
13524: LD_ADDR_VAR 0 4
13528: PUSH
13529: LD_INT 0
13531: ST_TO_ADDR
// for i := 1 to 8 do
13532: LD_ADDR_VAR 0 1
13536: PUSH
13537: DOUBLE
13538: LD_INT 1
13540: DEC
13541: ST_TO_ADDR
13542: LD_INT 8
13544: PUSH
13545: FOR_TO
13546: IFFALSE 13657
// begin x := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
13548: LD_ADDR_VAR 0 2
13552: PUSH
13553: LD_INT 10
13555: PUSH
13556: LD_INT 50
13558: PUSH
13559: LD_INT 90
13561: PUSH
13562: LD_INT 140
13564: PUSH
13565: EMPTY
13566: LIST
13567: LIST
13568: LIST
13569: LIST
13570: PUSH
13571: LD_INT 1
13573: PPUSH
13574: LD_INT 4
13576: PPUSH
13577: CALL_OW 12
13581: ARRAY
13582: ST_TO_ADDR
// y := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
13583: LD_ADDR_VAR 0 3
13587: PUSH
13588: LD_INT 10
13590: PUSH
13591: LD_INT 50
13593: PUSH
13594: LD_INT 90
13596: PUSH
13597: LD_INT 140
13599: PUSH
13600: EMPTY
13601: LIST
13602: LIST
13603: LIST
13604: LIST
13605: PUSH
13606: LD_INT 1
13608: PPUSH
13609: LD_INT 4
13611: PPUSH
13612: CALL_OW 12
13616: ARRAY
13617: ST_TO_ADDR
// if ValidHex ( x , y ) then
13618: LD_VAR 0 2
13622: PPUSH
13623: LD_VAR 0 3
13627: PPUSH
13628: CALL_OW 488
13632: IFFALSE 13655
// begin result := [ x , y ] ;
13634: LD_ADDR_VAR 0 4
13638: PUSH
13639: LD_VAR 0 2
13643: PUSH
13644: LD_VAR 0 3
13648: PUSH
13649: EMPTY
13650: LIST
13651: LIST
13652: ST_TO_ADDR
// break ;
13653: GO 13657
// end ; end ;
13655: GO 13545
13657: POP
13658: POP
// if result then
13659: LD_VAR 0 4
13663: IFFALSE 13687
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
13665: LD_VAR 0 4
13669: PUSH
13670: LD_INT 1
13672: ARRAY
13673: PPUSH
13674: LD_VAR 0 4
13678: PUSH
13679: LD_INT 2
13681: ARRAY
13682: PPUSH
13683: CALL_OW 429
// end ;
13687: PPOPN 4
13689: END
// every 0 0$1 trigger StreamModeActive and sReset do
13690: LD_EXP 24
13694: PUSH
13695: LD_EXP 44
13699: AND
13700: IFFALSE 13712
13702: GO 13704
13704: DISABLE
// YouLost (  ) ;
13705: LD_STRING 
13707: PPUSH
13708: CALL_OW 104
13712: END
// every 0 0$1 trigger StreamModeActive and sFog do
13713: LD_EXP 24
13717: PUSH
13718: LD_EXP 43
13722: AND
13723: IFFALSE 13737
13725: GO 13727
13727: DISABLE
// FogOff ( your_side ) ;
13728: LD_OWVAR 2
13732: PPUSH
13733: CALL_OW 344
13737: END
// every 0 0$1 trigger StreamModeActive and sSun do
13738: LD_EXP 24
13742: PUSH
13743: LD_EXP 45
13747: AND
13748: IFFALSE 13776
13750: GO 13752
13752: DISABLE
// begin solar_recharge_percent := 0 ;
13753: LD_ADDR_OWVAR 79
13757: PUSH
13758: LD_INT 0
13760: ST_TO_ADDR
// wait ( 5 5$00 ) ;
13761: LD_INT 10500
13763: PPUSH
13764: CALL_OW 67
// solar_recharge_percent := 100 ;
13768: LD_ADDR_OWVAR 79
13772: PUSH
13773: LD_INT 100
13775: ST_TO_ADDR
// end ;
13776: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un ;
13777: LD_EXP 24
13781: PUSH
13782: LD_EXP 46
13786: AND
13787: IFFALSE 13942
13789: GO 13791
13791: DISABLE
13792: LD_INT 0
13794: PPUSH
13795: PPUSH
// begin for i := 1 to 6 do
13796: LD_ADDR_VAR 0 1
13800: PUSH
13801: DOUBLE
13802: LD_INT 1
13804: DEC
13805: ST_TO_ADDR
13806: LD_INT 6
13808: PUSH
13809: FOR_TO
13810: IFFALSE 13940
// begin uc_nation := nation_nature ;
13812: LD_ADDR_OWVAR 21
13816: PUSH
13817: LD_INT 0
13819: ST_TO_ADDR
// uc_side := 0 ;
13820: LD_ADDR_OWVAR 20
13824: PUSH
13825: LD_INT 0
13827: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
13828: LD_ADDR_OWVAR 29
13832: PUSH
13833: LD_INT 12
13835: PUSH
13836: LD_INT 12
13838: PUSH
13839: EMPTY
13840: LIST
13841: LIST
13842: ST_TO_ADDR
// hc_agressivity := 20 ;
13843: LD_ADDR_OWVAR 35
13847: PUSH
13848: LD_INT 20
13850: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
13851: LD_ADDR_OWVAR 28
13855: PUSH
13856: LD_INT 17
13858: ST_TO_ADDR
// hc_gallery :=  ;
13859: LD_ADDR_OWVAR 33
13863: PUSH
13864: LD_STRING 
13866: ST_TO_ADDR
// hc_name :=  ;
13867: LD_ADDR_OWVAR 26
13871: PUSH
13872: LD_STRING 
13874: ST_TO_ADDR
// un := CreateHuman ;
13875: LD_ADDR_VAR 0 2
13879: PUSH
13880: CALL_OW 44
13884: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
13885: LD_VAR 0 2
13889: PPUSH
13890: LD_INT 1
13892: PPUSH
13893: CALL_OW 51
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
13897: LD_VAR 0 2
13901: PPUSH
13902: LD_INT 3
13904: PUSH
13905: LD_INT 22
13907: PUSH
13908: LD_INT 0
13910: PUSH
13911: EMPTY
13912: LIST
13913: LIST
13914: PUSH
13915: EMPTY
13916: LIST
13917: LIST
13918: PPUSH
13919: CALL_OW 69
13923: PPUSH
13924: LD_VAR 0 2
13928: PPUSH
13929: CALL_OW 74
13933: PPUSH
13934: CALL_OW 115
// end ;
13938: GO 13809
13940: POP
13941: POP
// end ;
13942: PPOPN 2
13944: END
// every 0 0$1 trigger StreamModeActive and sTroll do
13945: LD_EXP 24
13949: PUSH
13950: LD_EXP 47
13954: AND
13955: IFFALSE 13981
13957: GO 13959
13959: DISABLE
// begin ToLua ( displayTroll(); ) ;
13960: LD_STRING displayTroll();
13962: PPUSH
13963: CALL_OW 559
// wait ( 3 3$00 ) ;
13967: LD_INT 6300
13969: PPUSH
13970: CALL_OW 67
// ToLua ( hideTroll(); ) ;
13974: LD_STRING hideTroll();
13976: PPUSH
13977: CALL_OW 559
// end ;
13981: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
13982: LD_EXP 24
13986: PUSH
13987: LD_EXP 48
13991: AND
13992: IFFALSE 14055
13994: GO 13996
13996: DISABLE
13997: LD_INT 0
13999: PPUSH
// begin p := 0 ;
14000: LD_ADDR_VAR 0 1
14004: PUSH
14005: LD_INT 0
14007: ST_TO_ADDR
// repeat game_speed := 1 ;
14008: LD_ADDR_OWVAR 65
14012: PUSH
14013: LD_INT 1
14015: ST_TO_ADDR
// wait ( 0 0$1 ) ;
14016: LD_INT 35
14018: PPUSH
14019: CALL_OW 67
// p := p + 1 ;
14023: LD_ADDR_VAR 0 1
14027: PUSH
14028: LD_VAR 0 1
14032: PUSH
14033: LD_INT 1
14035: PLUS
14036: ST_TO_ADDR
// until p >= 60 ;
14037: LD_VAR 0 1
14041: PUSH
14042: LD_INT 60
14044: GREATEREQUAL
14045: IFFALSE 14008
// game_speed := 4 ;
14047: LD_ADDR_OWVAR 65
14051: PUSH
14052: LD_INT 4
14054: ST_TO_ADDR
// end ;
14055: PPOPN 1
14057: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
14058: LD_EXP 24
14062: PUSH
14063: LD_EXP 49
14067: AND
14068: IFFALSE 14214
14070: GO 14072
14072: DISABLE
14073: LD_INT 0
14075: PPUSH
14076: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
14077: LD_ADDR_VAR 0 1
14081: PUSH
14082: LD_INT 22
14084: PUSH
14085: LD_OWVAR 2
14089: PUSH
14090: EMPTY
14091: LIST
14092: LIST
14093: PUSH
14094: LD_INT 2
14096: PUSH
14097: LD_INT 30
14099: PUSH
14100: LD_INT 0
14102: PUSH
14103: EMPTY
14104: LIST
14105: LIST
14106: PUSH
14107: LD_INT 30
14109: PUSH
14110: LD_INT 1
14112: PUSH
14113: EMPTY
14114: LIST
14115: LIST
14116: PUSH
14117: EMPTY
14118: LIST
14119: LIST
14120: LIST
14121: PUSH
14122: EMPTY
14123: LIST
14124: LIST
14125: PPUSH
14126: CALL_OW 69
14130: ST_TO_ADDR
// if not depot then
14131: LD_VAR 0 1
14135: NOT
14136: IFFALSE 14140
// exit ;
14138: GO 14214
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
14140: LD_ADDR_VAR 0 2
14144: PUSH
14145: LD_VAR 0 1
14149: PUSH
14150: LD_INT 1
14152: PPUSH
14153: LD_VAR 0 1
14157: PPUSH
14158: CALL_OW 12
14162: ARRAY
14163: PPUSH
14164: CALL_OW 274
14168: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
14169: LD_VAR 0 2
14173: PPUSH
14174: LD_INT 1
14176: PPUSH
14177: LD_INT 0
14179: PPUSH
14180: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
14184: LD_VAR 0 2
14188: PPUSH
14189: LD_INT 2
14191: PPUSH
14192: LD_INT 0
14194: PPUSH
14195: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
14199: LD_VAR 0 2
14203: PPUSH
14204: LD_INT 3
14206: PPUSH
14207: LD_INT 0
14209: PPUSH
14210: CALL_OW 277
// end ;
14214: PPOPN 2
14216: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
14217: LD_EXP 24
14221: PUSH
14222: LD_EXP 50
14226: AND
14227: IFFALSE 14324
14229: GO 14231
14231: DISABLE
14232: LD_INT 0
14234: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
14235: LD_ADDR_VAR 0 1
14239: PUSH
14240: LD_INT 22
14242: PUSH
14243: LD_OWVAR 2
14247: PUSH
14248: EMPTY
14249: LIST
14250: LIST
14251: PUSH
14252: LD_INT 21
14254: PUSH
14255: LD_INT 1
14257: PUSH
14258: EMPTY
14259: LIST
14260: LIST
14261: PUSH
14262: LD_INT 3
14264: PUSH
14265: LD_INT 23
14267: PUSH
14268: LD_INT 0
14270: PUSH
14271: EMPTY
14272: LIST
14273: LIST
14274: PUSH
14275: EMPTY
14276: LIST
14277: LIST
14278: PUSH
14279: EMPTY
14280: LIST
14281: LIST
14282: LIST
14283: PPUSH
14284: CALL_OW 69
14288: ST_TO_ADDR
// if not tmp then
14289: LD_VAR 0 1
14293: NOT
14294: IFFALSE 14298
// exit ;
14296: GO 14324
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
14298: LD_VAR 0 1
14302: PUSH
14303: LD_INT 1
14305: PPUSH
14306: LD_VAR 0 1
14310: PPUSH
14311: CALL_OW 12
14315: ARRAY
14316: PPUSH
14317: LD_INT 200
14319: PPUSH
14320: CALL_OW 234
// end ;
14324: PPOPN 1
14326: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
14327: LD_EXP 24
14331: PUSH
14332: LD_EXP 51
14336: AND
14337: IFFALSE 14416
14339: GO 14341
14341: DISABLE
14342: LD_INT 0
14344: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
14345: LD_ADDR_VAR 0 1
14349: PUSH
14350: LD_INT 22
14352: PUSH
14353: LD_OWVAR 2
14357: PUSH
14358: EMPTY
14359: LIST
14360: LIST
14361: PUSH
14362: LD_INT 21
14364: PUSH
14365: LD_INT 2
14367: PUSH
14368: EMPTY
14369: LIST
14370: LIST
14371: PUSH
14372: EMPTY
14373: LIST
14374: LIST
14375: PPUSH
14376: CALL_OW 69
14380: ST_TO_ADDR
// if not tmp then
14381: LD_VAR 0 1
14385: NOT
14386: IFFALSE 14390
// exit ;
14388: GO 14416
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 10 ) ;
14390: LD_VAR 0 1
14394: PUSH
14395: LD_INT 1
14397: PPUSH
14398: LD_VAR 0 1
14402: PPUSH
14403: CALL_OW 12
14407: ARRAY
14408: PPUSH
14409: LD_INT 10
14411: PPUSH
14412: CALL_OW 234
// end ;
14416: PPOPN 1
14418: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
14419: LD_EXP 24
14423: PUSH
14424: LD_EXP 52
14428: AND
14429: IFFALSE 14528
14431: GO 14433
14433: DISABLE
14434: LD_INT 0
14436: PPUSH
14437: PPUSH
// begin enable ;
14438: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
14439: LD_ADDR_VAR 0 1
14443: PUSH
14444: LD_INT 22
14446: PUSH
14447: LD_OWVAR 2
14451: PUSH
14452: EMPTY
14453: LIST
14454: LIST
14455: PUSH
14456: LD_INT 61
14458: PUSH
14459: EMPTY
14460: LIST
14461: PUSH
14462: LD_INT 33
14464: PUSH
14465: LD_INT 2
14467: PUSH
14468: EMPTY
14469: LIST
14470: LIST
14471: PUSH
14472: EMPTY
14473: LIST
14474: LIST
14475: LIST
14476: PPUSH
14477: CALL_OW 69
14481: ST_TO_ADDR
// if not tmp then
14482: LD_VAR 0 1
14486: NOT
14487: IFFALSE 14491
// exit ;
14489: GO 14528
// for i in tmp do
14491: LD_ADDR_VAR 0 2
14495: PUSH
14496: LD_VAR 0 1
14500: PUSH
14501: FOR_IN
14502: IFFALSE 14526
// if IsControledBy ( i ) then
14504: LD_VAR 0 2
14508: PPUSH
14509: CALL_OW 312
14513: IFFALSE 14524
// ComUnlink ( i ) ;
14515: LD_VAR 0 2
14519: PPUSH
14520: CALL_OW 136
14524: GO 14501
14526: POP
14527: POP
// end ; end_of_file
14528: PPOPN 2
14530: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
14531: LD_INT 0
14533: PPUSH
14534: PPUSH
14535: PPUSH
14536: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
14537: LD_VAR 0 1
14541: PPUSH
14542: CALL_OW 264
14546: PUSH
14547: LD_EXP 23
14551: EQUAL
14552: IFFALSE 14624
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
14554: LD_INT 68
14556: PPUSH
14557: LD_VAR 0 1
14561: PPUSH
14562: CALL_OW 255
14566: PPUSH
14567: CALL_OW 321
14571: PUSH
14572: LD_INT 2
14574: EQUAL
14575: IFFALSE 14587
// eff := 70 else
14577: LD_ADDR_VAR 0 6
14581: PUSH
14582: LD_INT 70
14584: ST_TO_ADDR
14585: GO 14595
// eff := 30 ;
14587: LD_ADDR_VAR 0 6
14591: PUSH
14592: LD_INT 30
14594: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
14595: LD_VAR 0 1
14599: PPUSH
14600: CALL_OW 250
14604: PPUSH
14605: LD_VAR 0 1
14609: PPUSH
14610: CALL_OW 251
14614: PPUSH
14615: LD_VAR 0 6
14619: PPUSH
14620: CALL_OW 495
// end ; end ;
14624: LD_VAR 0 4
14628: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
14629: LD_INT 0
14631: PPUSH
14632: PPUSH
14633: PPUSH
14634: PPUSH
14635: PPUSH
14636: PPUSH
// if cmd = 124 then
14637: LD_VAR 0 1
14641: PUSH
14642: LD_INT 124
14644: EQUAL
14645: IFFALSE 14851
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
14647: LD_ADDR_VAR 0 5
14651: PUSH
14652: LD_INT 2
14654: PUSH
14655: LD_INT 34
14657: PUSH
14658: LD_INT 53
14660: PUSH
14661: EMPTY
14662: LIST
14663: LIST
14664: PUSH
14665: LD_INT 34
14667: PUSH
14668: LD_INT 14
14670: PUSH
14671: EMPTY
14672: LIST
14673: LIST
14674: PUSH
14675: EMPTY
14676: LIST
14677: LIST
14678: LIST
14679: PPUSH
14680: CALL_OW 69
14684: ST_TO_ADDR
// if not tmp then
14685: LD_VAR 0 5
14689: NOT
14690: IFFALSE 14694
// exit ;
14692: GO 14851
// for i in tmp do
14694: LD_ADDR_VAR 0 3
14698: PUSH
14699: LD_VAR 0 5
14703: PUSH
14704: FOR_IN
14705: IFFALSE 14849
// begin taskList := GetTaskList ( i ) ;
14707: LD_ADDR_VAR 0 6
14711: PUSH
14712: LD_VAR 0 3
14716: PPUSH
14717: CALL_OW 437
14721: ST_TO_ADDR
// if not taskList then
14722: LD_VAR 0 6
14726: NOT
14727: IFFALSE 14731
// continue ;
14729: GO 14704
// for j = 1 to taskList do
14731: LD_ADDR_VAR 0 4
14735: PUSH
14736: DOUBLE
14737: LD_INT 1
14739: DEC
14740: ST_TO_ADDR
14741: LD_VAR 0 6
14745: PUSH
14746: FOR_TO
14747: IFFALSE 14845
// if taskList [ j ] [ 1 ] = | then
14749: LD_VAR 0 6
14753: PUSH
14754: LD_VAR 0 4
14758: ARRAY
14759: PUSH
14760: LD_INT 1
14762: ARRAY
14763: PUSH
14764: LD_STRING |
14766: EQUAL
14767: IFFALSE 14843
// begin _taskList := Delete ( taskList , 1 ) ;
14769: LD_ADDR_VAR 0 7
14773: PUSH
14774: LD_VAR 0 6
14778: PPUSH
14779: LD_INT 1
14781: PPUSH
14782: CALL_OW 3
14786: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
14787: LD_VAR 0 3
14791: PPUSH
14792: LD_VAR 0 7
14796: PPUSH
14797: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
14801: LD_VAR 0 3
14805: PPUSH
14806: LD_VAR 0 6
14810: PUSH
14811: LD_VAR 0 4
14815: ARRAY
14816: PUSH
14817: LD_INT 2
14819: ARRAY
14820: PPUSH
14821: LD_VAR 0 6
14825: PUSH
14826: LD_VAR 0 4
14830: ARRAY
14831: PUSH
14832: LD_INT 3
14834: ARRAY
14835: PPUSH
14836: LD_INT 8
14838: PPUSH
14839: CALL 14856 0 4
// end ;
14843: GO 14746
14845: POP
14846: POP
// end ;
14847: GO 14704
14849: POP
14850: POP
// end ; end ;
14851: LD_VAR 0 2
14855: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
14856: LD_INT 0
14858: PPUSH
14859: PPUSH
14860: PPUSH
14861: PPUSH
14862: PPUSH
14863: PPUSH
14864: PPUSH
14865: PPUSH
14866: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
14867: LD_VAR 0 1
14871: NOT
14872: PUSH
14873: LD_VAR 0 2
14877: PPUSH
14878: LD_VAR 0 3
14882: PPUSH
14883: CALL_OW 488
14887: NOT
14888: OR
14889: PUSH
14890: LD_VAR 0 4
14894: NOT
14895: OR
14896: IFFALSE 14900
// exit ;
14898: GO 15240
// list := [ ] ;
14900: LD_ADDR_VAR 0 13
14904: PUSH
14905: EMPTY
14906: ST_TO_ADDR
// if x - r < 0 then
14907: LD_VAR 0 2
14911: PUSH
14912: LD_VAR 0 4
14916: MINUS
14917: PUSH
14918: LD_INT 0
14920: LESS
14921: IFFALSE 14933
// min_x := 0 else
14923: LD_ADDR_VAR 0 7
14927: PUSH
14928: LD_INT 0
14930: ST_TO_ADDR
14931: GO 14949
// min_x := x - r ;
14933: LD_ADDR_VAR 0 7
14937: PUSH
14938: LD_VAR 0 2
14942: PUSH
14943: LD_VAR 0 4
14947: MINUS
14948: ST_TO_ADDR
// if y - r < 0 then
14949: LD_VAR 0 3
14953: PUSH
14954: LD_VAR 0 4
14958: MINUS
14959: PUSH
14960: LD_INT 0
14962: LESS
14963: IFFALSE 14975
// min_y := 0 else
14965: LD_ADDR_VAR 0 8
14969: PUSH
14970: LD_INT 0
14972: ST_TO_ADDR
14973: GO 14991
// min_y := y - r ;
14975: LD_ADDR_VAR 0 8
14979: PUSH
14980: LD_VAR 0 3
14984: PUSH
14985: LD_VAR 0 4
14989: MINUS
14990: ST_TO_ADDR
// max_x := x + r ;
14991: LD_ADDR_VAR 0 9
14995: PUSH
14996: LD_VAR 0 2
15000: PUSH
15001: LD_VAR 0 4
15005: PLUS
15006: ST_TO_ADDR
// max_y := y + r ;
15007: LD_ADDR_VAR 0 10
15011: PUSH
15012: LD_VAR 0 3
15016: PUSH
15017: LD_VAR 0 4
15021: PLUS
15022: ST_TO_ADDR
// for _x = min_x to max_x do
15023: LD_ADDR_VAR 0 11
15027: PUSH
15028: DOUBLE
15029: LD_VAR 0 7
15033: DEC
15034: ST_TO_ADDR
15035: LD_VAR 0 9
15039: PUSH
15040: FOR_TO
15041: IFFALSE 15158
// for _y = min_y to max_y do
15043: LD_ADDR_VAR 0 12
15047: PUSH
15048: DOUBLE
15049: LD_VAR 0 8
15053: DEC
15054: ST_TO_ADDR
15055: LD_VAR 0 10
15059: PUSH
15060: FOR_TO
15061: IFFALSE 15154
// begin if not ValidHex ( _x , _y ) then
15063: LD_VAR 0 11
15067: PPUSH
15068: LD_VAR 0 12
15072: PPUSH
15073: CALL_OW 488
15077: NOT
15078: IFFALSE 15082
// continue ;
15080: GO 15060
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
15082: LD_VAR 0 11
15086: PPUSH
15087: LD_VAR 0 12
15091: PPUSH
15092: CALL_OW 351
15096: PUSH
15097: LD_VAR 0 11
15101: PPUSH
15102: LD_VAR 0 12
15106: PPUSH
15107: CALL_OW 554
15111: AND
15112: IFFALSE 15152
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
15114: LD_ADDR_VAR 0 13
15118: PUSH
15119: LD_VAR 0 13
15123: PPUSH
15124: LD_VAR 0 13
15128: PUSH
15129: LD_INT 1
15131: PLUS
15132: PPUSH
15133: LD_VAR 0 11
15137: PUSH
15138: LD_VAR 0 12
15142: PUSH
15143: EMPTY
15144: LIST
15145: LIST
15146: PPUSH
15147: CALL_OW 2
15151: ST_TO_ADDR
// end ;
15152: GO 15060
15154: POP
15155: POP
15156: GO 15040
15158: POP
15159: POP
// if not list then
15160: LD_VAR 0 13
15164: NOT
15165: IFFALSE 15169
// exit ;
15167: GO 15240
// for i in list do
15169: LD_ADDR_VAR 0 6
15173: PUSH
15174: LD_VAR 0 13
15178: PUSH
15179: FOR_IN
15180: IFFALSE 15238
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
15182: LD_VAR 0 1
15186: PPUSH
15187: LD_STRING M
15189: PUSH
15190: LD_VAR 0 6
15194: PUSH
15195: LD_INT 1
15197: ARRAY
15198: PUSH
15199: LD_VAR 0 6
15203: PUSH
15204: LD_INT 2
15206: ARRAY
15207: PUSH
15208: LD_INT 0
15210: PUSH
15211: LD_INT 0
15213: PUSH
15214: LD_INT 0
15216: PUSH
15217: LD_INT 0
15219: PUSH
15220: EMPTY
15221: LIST
15222: LIST
15223: LIST
15224: LIST
15225: LIST
15226: LIST
15227: LIST
15228: PUSH
15229: EMPTY
15230: LIST
15231: PPUSH
15232: CALL_OW 447
15236: GO 15179
15238: POP
15239: POP
// end ;
15240: LD_VAR 0 5
15244: RET
