// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitMacro ;
  15: CALL 21352 0 0
// InitNature ;
  19: CALL 18018 0 0
// InitArtifact ;
  23: CALL 18635 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAmerican ;
  40: CALL 5102 0 0
// PrepareAlliance ;
  44: CALL 1436 0 0
// PrepareArabian ;
  48: CALL 6874 0 0
// PrepareRussian ;
  52: CALL 8948 0 0
// PrepareLegion ;
  56: CALL 7371 0 0
// Action ;
  60: CALL 11581 0 0
// MC_Start ( ) ;
  64: CALL 23532 0 0
// end ;
  68: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export allianceTeam , arabianAttacked ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  80: LD_ADDR_EXP 9
  84: PUSH
  85: LD_STRING 11_artifact_captured
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// russianDestroyed := false ;
  96: LD_ADDR_EXP 2
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// legionDestroyed := false ;
 104: LD_ADDR_EXP 3
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// americanDestroyed := false ;
 112: LD_ADDR_EXP 4
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// arabianDestroyed := false ;
 120: LD_ADDR_EXP 5
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// americanCapitulated := false ;
 128: LD_ADDR_EXP 6
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// russianCapitulated := false ;
 136: LD_ADDR_EXP 7
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// legionCapitulated := false ;
 144: LD_ADDR_EXP 8
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// artifactIResearched := false ;
 152: LD_ADDR_EXP 12
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// artifactIIResearched := false ;
 160: LD_ADDR_EXP 13
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// artifactIIIResearched := false ;
 168: LD_ADDR_EXP 14
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// alienSpotted := false ;
 176: LD_ADDR_EXP 10
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// spawnOmar := false ;
 184: LD_ADDR_EXP 11
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 192: LD_ADDR_EXP 15
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 200: LD_ADDR_EXP 16
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// allianceTeam := [ ] ;
 208: LD_ADDR_EXP 17
 212: PUSH
 213: EMPTY
 214: ST_TO_ADDR
// arabianAttacked := false ;
 215: LD_ADDR_EXP 18
 219: PUSH
 220: LD_INT 0
 222: ST_TO_ADDR
// end ;
 223: LD_VAR 0 1
 227: RET
// export function CustomInitMacro ( ) ; begin
 228: LD_INT 0
 230: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 231: LD_ADDR_EXP 101
 235: PUSH
 236: LD_INT 26
 238: PUSH
 239: LD_INT 1
 241: PUSH
 242: LD_INT 4
 244: PUSH
 245: LD_INT 8
 247: PUSH
 248: EMPTY
 249: LIST
 250: LIST
 251: LIST
 252: LIST
 253: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 254: LD_ADDR_EXP 102
 258: PUSH
 259: LD_INT 27
 261: PUSH
 262: LD_INT 2
 264: PUSH
 265: LD_INT 3
 267: PUSH
 268: LD_INT 7
 270: PUSH
 271: EMPTY
 272: LIST
 273: LIST
 274: LIST
 275: LIST
 276: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 , 10 ] [ Difficulty ] , arabianMinefield ) ;
 277: LD_INT 1
 279: PPUSH
 280: LD_INT 6
 282: PUSH
 283: LD_INT 7
 285: PUSH
 286: LD_INT 9
 288: PUSH
 289: LD_INT 10
 291: PUSH
 292: EMPTY
 293: LIST
 294: LIST
 295: LIST
 296: LIST
 297: PUSH
 298: LD_OWVAR 67
 302: ARRAY
 303: PPUSH
 304: LD_INT 28
 306: PPUSH
 307: CALL 45270 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 311: LD_INT 1
 313: PPUSH
 314: LD_INT 10
 316: PUSH
 317: LD_INT 11
 319: PUSH
 320: LD_INT 13
 322: PUSH
 323: LD_INT 15
 325: PUSH
 326: EMPTY
 327: LIST
 328: LIST
 329: LIST
 330: LIST
 331: PPUSH
 332: CALL 46330 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 336: LD_INT 1
 338: PPUSH
 339: LD_INT 29
 341: PUSH
 342: EMPTY
 343: LIST
 344: PPUSH
 345: CALL 46423 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 349: LD_ADDR_EXP 106
 353: PUSH
 354: LD_EXP 106
 358: PPUSH
 359: LD_INT 1
 361: PPUSH
 362: LD_INT 22
 364: PUSH
 365: LD_INT 2
 367: PUSH
 368: EMPTY
 369: LIST
 370: LIST
 371: PUSH
 372: LD_INT 25
 374: PUSH
 375: LD_INT 15
 377: PUSH
 378: EMPTY
 379: LIST
 380: LIST
 381: PUSH
 382: EMPTY
 383: LIST
 384: LIST
 385: PPUSH
 386: CALL_OW 69
 390: PPUSH
 391: CALL_OW 1
 395: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 396: LD_INT 1
 398: PPUSH
 399: LD_INT 13
 401: PUSH
 402: LD_INT 2
 404: PUSH
 405: LD_INT 1
 407: PUSH
 408: LD_INT 31
 410: PUSH
 411: EMPTY
 412: LIST
 413: LIST
 414: LIST
 415: LIST
 416: PUSH
 417: LD_INT 13
 419: PUSH
 420: LD_INT 2
 422: PUSH
 423: LD_INT 1
 425: PUSH
 426: LD_INT 31
 428: PUSH
 429: EMPTY
 430: LIST
 431: LIST
 432: LIST
 433: LIST
 434: PUSH
 435: LD_INT 13
 437: PUSH
 438: LD_INT 1
 440: PUSH
 441: LD_INT 1
 443: PUSH
 444: LD_INT 28
 446: PUSH
 447: EMPTY
 448: LIST
 449: LIST
 450: LIST
 451: LIST
 452: PUSH
 453: LD_INT 13
 455: PUSH
 456: LD_INT 1
 458: PUSH
 459: LD_INT 1
 461: PUSH
 462: LD_INT 28
 464: PUSH
 465: EMPTY
 466: LIST
 467: LIST
 468: LIST
 469: LIST
 470: PUSH
 471: LD_INT 13
 473: PUSH
 474: LD_INT 1
 476: PUSH
 477: LD_INT 1
 479: PUSH
 480: LD_INT 28
 482: PUSH
 483: EMPTY
 484: LIST
 485: LIST
 486: LIST
 487: LIST
 488: PUSH
 489: LD_INT 13
 491: PUSH
 492: LD_INT 1
 494: PUSH
 495: LD_INT 1
 497: PUSH
 498: LD_INT 28
 500: PUSH
 501: EMPTY
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: PUSH
 507: LD_INT 13
 509: PUSH
 510: LD_INT 1
 512: PUSH
 513: LD_INT 2
 515: PUSH
 516: LD_INT 88
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: LIST
 523: LIST
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: LIST
 529: LIST
 530: LIST
 531: LIST
 532: LIST
 533: PPUSH
 534: CALL 45588 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 538: LD_INT 1
 540: PPUSH
 541: LD_INT 4
 543: PPUSH
 544: CALL 45773 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 548: LD_INT 2
 550: PPUSH
 551: LD_INT 10
 553: PUSH
 554: LD_INT 11
 556: PUSH
 557: LD_INT 12
 559: PUSH
 560: LD_INT 14
 562: PUSH
 563: EMPTY
 564: LIST
 565: LIST
 566: LIST
 567: LIST
 568: PPUSH
 569: CALL 46330 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 573: LD_INT 2
 575: PPUSH
 576: LD_INT 14
 578: PUSH
 579: EMPTY
 580: LIST
 581: PPUSH
 582: CALL 46423 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 586: LD_INT 2
 588: PPUSH
 589: LD_INT 21
 591: PUSH
 592: LD_INT 3
 594: PUSH
 595: LD_INT 3
 597: PUSH
 598: LD_INT 51
 600: PUSH
 601: EMPTY
 602: LIST
 603: LIST
 604: LIST
 605: LIST
 606: PUSH
 607: LD_INT 22
 609: PUSH
 610: LD_INT 3
 612: PUSH
 613: LD_INT 3
 615: PUSH
 616: LD_INT 52
 618: PUSH
 619: EMPTY
 620: LIST
 621: LIST
 622: LIST
 623: LIST
 624: PUSH
 625: LD_INT 22
 627: PUSH
 628: LD_INT 3
 630: PUSH
 631: LD_INT 3
 633: PUSH
 634: LD_INT 52
 636: PUSH
 637: EMPTY
 638: LIST
 639: LIST
 640: LIST
 641: LIST
 642: PUSH
 643: LD_INT 24
 645: PUSH
 646: LD_INT 3
 648: PUSH
 649: LD_INT 3
 651: PUSH
 652: LD_INT 47
 654: PUSH
 655: EMPTY
 656: LIST
 657: LIST
 658: LIST
 659: LIST
 660: PUSH
 661: LD_INT 24
 663: PUSH
 664: LD_INT 3
 666: PUSH
 667: LD_INT 3
 669: PUSH
 670: LD_INT 47
 672: PUSH
 673: EMPTY
 674: LIST
 675: LIST
 676: LIST
 677: LIST
 678: PUSH
 679: LD_INT 24
 681: PUSH
 682: LD_INT 3
 684: PUSH
 685: LD_INT 3
 687: PUSH
 688: LD_INT 47
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PUSH
 697: LD_INT 24
 699: PUSH
 700: LD_INT 3
 702: PUSH
 703: LD_INT 3
 705: PUSH
 706: LD_INT 47
 708: PUSH
 709: EMPTY
 710: LIST
 711: LIST
 712: LIST
 713: LIST
 714: PUSH
 715: LD_INT 24
 717: PUSH
 718: LD_INT 3
 720: PUSH
 721: LD_INT 3
 723: PUSH
 724: LD_INT 47
 726: PUSH
 727: EMPTY
 728: LIST
 729: LIST
 730: LIST
 731: LIST
 732: PUSH
 733: EMPTY
 734: LIST
 735: LIST
 736: LIST
 737: LIST
 738: LIST
 739: LIST
 740: LIST
 741: LIST
 742: PPUSH
 743: CALL 45588 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 747: LD_INT 2
 749: PPUSH
 750: LD_INT 5
 752: PPUSH
 753: CALL 45773 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 757: LD_INT 2
 759: PPUSH
 760: LD_INT 0
 762: PPUSH
 763: CALL 46203 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 767: LD_INT 3
 769: PPUSH
 770: LD_INT 10
 772: PUSH
 773: LD_INT 12
 775: PUSH
 776: LD_INT 14
 778: PUSH
 779: LD_INT 15
 781: PUSH
 782: EMPTY
 783: LIST
 784: LIST
 785: LIST
 786: LIST
 787: PUSH
 788: LD_OWVAR 67
 792: ARRAY
 793: PPUSH
 794: LD_INT 24
 796: PPUSH
 797: CALL 45270 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 801: LD_INT 3
 803: PPUSH
 804: LD_INT 10
 806: PUSH
 807: LD_INT 11
 809: PUSH
 810: LD_INT 13
 812: PUSH
 813: LD_INT 15
 815: PUSH
 816: EMPTY
 817: LIST
 818: LIST
 819: LIST
 820: LIST
 821: PPUSH
 822: CALL 46330 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 826: LD_INT 3
 828: PPUSH
 829: LD_INT 13
 831: PUSH
 832: EMPTY
 833: LIST
 834: PPUSH
 835: CALL 46423 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 839: LD_ADDR_EXP 106
 843: PUSH
 844: LD_EXP 106
 848: PPUSH
 849: LD_INT 3
 851: PPUSH
 852: LD_INT 22
 854: PUSH
 855: LD_INT 8
 857: PUSH
 858: EMPTY
 859: LIST
 860: LIST
 861: PUSH
 862: LD_INT 25
 864: PUSH
 865: LD_INT 15
 867: PUSH
 868: EMPTY
 869: LIST
 870: LIST
 871: PUSH
 872: EMPTY
 873: LIST
 874: LIST
 875: PPUSH
 876: CALL_OW 69
 880: PPUSH
 881: CALL_OW 1
 885: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 886: LD_INT 3
 888: PPUSH
 889: LD_INT 13
 891: PUSH
 892: LD_INT 2
 894: PUSH
 895: LD_INT 1
 897: PUSH
 898: LD_INT 31
 900: PUSH
 901: EMPTY
 902: LIST
 903: LIST
 904: LIST
 905: LIST
 906: PUSH
 907: LD_INT 13
 909: PUSH
 910: LD_INT 2
 912: PUSH
 913: LD_INT 1
 915: PUSH
 916: LD_INT 31
 918: PUSH
 919: EMPTY
 920: LIST
 921: LIST
 922: LIST
 923: LIST
 924: PUSH
 925: LD_INT 13
 927: PUSH
 928: LD_INT 3
 930: PUSH
 931: LD_INT 2
 933: PUSH
 934: LD_INT 32
 936: PUSH
 937: EMPTY
 938: LIST
 939: LIST
 940: LIST
 941: LIST
 942: PUSH
 943: LD_INT 14
 945: PUSH
 946: LD_INT 1
 948: PUSH
 949: LD_INT 1
 951: PUSH
 952: LD_INT 28
 954: PUSH
 955: EMPTY
 956: LIST
 957: LIST
 958: LIST
 959: LIST
 960: PUSH
 961: LD_INT 14
 963: PUSH
 964: LD_INT 1
 966: PUSH
 967: LD_INT 1
 969: PUSH
 970: LD_INT 28
 972: PUSH
 973: EMPTY
 974: LIST
 975: LIST
 976: LIST
 977: LIST
 978: PUSH
 979: LD_INT 14
 981: PUSH
 982: LD_INT 1
 984: PUSH
 985: LD_INT 1
 987: PUSH
 988: LD_INT 28
 990: PUSH
 991: EMPTY
 992: LIST
 993: LIST
 994: LIST
 995: LIST
 996: PUSH
 997: LD_INT 14
 999: PUSH
1000: LD_INT 1
1002: PUSH
1003: LD_INT 1
1005: PUSH
1006: LD_INT 28
1008: PUSH
1009: EMPTY
1010: LIST
1011: LIST
1012: LIST
1013: LIST
1014: PUSH
1015: LD_INT 14
1017: PUSH
1018: LD_INT 1
1020: PUSH
1021: LD_INT 2
1023: PUSH
1024: LD_INT 88
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: LIST
1031: LIST
1032: PUSH
1033: EMPTY
1034: LIST
1035: LIST
1036: LIST
1037: LIST
1038: LIST
1039: LIST
1040: LIST
1041: LIST
1042: PPUSH
1043: CALL 45588 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
1047: LD_INT 3
1049: PPUSH
1050: LD_INT 4
1052: PPUSH
1053: CALL 45773 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
1057: LD_INT 4
1059: PPUSH
1060: LD_INT 10
1062: PUSH
1063: LD_INT 12
1065: PUSH
1066: LD_INT 11
1068: PUSH
1069: LD_INT 15
1071: PUSH
1072: EMPTY
1073: LIST
1074: LIST
1075: LIST
1076: LIST
1077: PPUSH
1078: CALL 46330 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1082: LD_INT 4
1084: PPUSH
1085: LD_INT 33
1087: PUSH
1088: EMPTY
1089: LIST
1090: PPUSH
1091: CALL 46423 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1095: LD_INT 4
1097: PPUSH
1098: LD_INT 5
1100: PUSH
1101: LD_INT 6
1103: PUSH
1104: LD_INT 7
1106: PUSH
1107: LD_INT 9
1109: PUSH
1110: LD_INT 10
1112: PUSH
1113: EMPTY
1114: LIST
1115: LIST
1116: LIST
1117: LIST
1118: LIST
1119: PPUSH
1120: CALL 46741 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1124: LD_INT 4
1126: PPUSH
1127: LD_INT 54
1129: PPUSH
1130: LD_INT 85
1132: PPUSH
1133: LD_INT 2
1135: PPUSH
1136: LD_INT 25
1138: PUSH
1139: LD_INT 16
1141: PUSH
1142: LD_INT 17
1144: PUSH
1145: LD_INT 18
1147: PUSH
1148: LD_INT 22
1150: PUSH
1151: EMPTY
1152: LIST
1153: LIST
1154: LIST
1155: LIST
1156: LIST
1157: PPUSH
1158: CALL 46535 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1162: LD_INT 4
1164: PPUSH
1165: LD_INT 5
1167: PUSH
1168: LD_INT 1
1170: PUSH
1171: LD_INT 1
1173: PUSH
1174: LD_INT 7
1176: PUSH
1177: EMPTY
1178: LIST
1179: LIST
1180: LIST
1181: LIST
1182: PUSH
1183: LD_INT 5
1185: PUSH
1186: LD_INT 1
1188: PUSH
1189: LD_INT 1
1191: PUSH
1192: LD_INT 6
1194: PUSH
1195: EMPTY
1196: LIST
1197: LIST
1198: LIST
1199: LIST
1200: PUSH
1201: LD_INT 5
1203: PUSH
1204: LD_INT 1
1206: PUSH
1207: LD_INT 1
1209: PUSH
1210: LD_INT 7
1212: PUSH
1213: EMPTY
1214: LIST
1215: LIST
1216: LIST
1217: LIST
1218: PUSH
1219: LD_INT 5
1221: PUSH
1222: LD_INT 1
1224: PUSH
1225: LD_INT 1
1227: PUSH
1228: LD_INT 6
1230: PUSH
1231: EMPTY
1232: LIST
1233: LIST
1234: LIST
1235: LIST
1236: PUSH
1237: LD_INT 5
1239: PUSH
1240: LD_INT 1
1242: PUSH
1243: LD_INT 3
1245: PUSH
1246: LD_INT 12
1248: PUSH
1249: EMPTY
1250: LIST
1251: LIST
1252: LIST
1253: LIST
1254: PUSH
1255: LD_INT 3
1257: PUSH
1258: LD_INT 1
1260: PUSH
1261: LD_INT 3
1263: PUSH
1264: LD_INT 13
1266: PUSH
1267: EMPTY
1268: LIST
1269: LIST
1270: LIST
1271: LIST
1272: PUSH
1273: EMPTY
1274: LIST
1275: LIST
1276: LIST
1277: LIST
1278: LIST
1279: LIST
1280: PPUSH
1281: CALL 45588 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1285: LD_INT 4
1287: PPUSH
1288: LD_INT 4
1290: PPUSH
1291: CALL 45773 0 2
// MC_SetTame ( 4 , powellApe ) ;
1295: LD_INT 4
1297: PPUSH
1298: LD_INT 11
1300: PPUSH
1301: CALL 46154 0 2
// end ;
1305: LD_VAR 0 1
1309: RET
// every 0 0$1 trigger debug do var i ;
1310: LD_EXP 1
1314: IFFALSE 1412
1316: GO 1318
1318: DISABLE
1319: LD_INT 0
1321: PPUSH
// begin enable ;
1322: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1323: LD_ADDR_VAR 0 1
1327: PUSH
1328: LD_INT 22
1330: PUSH
1331: LD_INT 7
1333: PUSH
1334: EMPTY
1335: LIST
1336: LIST
1337: PUSH
1338: LD_INT 2
1340: PUSH
1341: LD_INT 21
1343: PUSH
1344: LD_INT 1
1346: PUSH
1347: EMPTY
1348: LIST
1349: LIST
1350: PUSH
1351: LD_INT 21
1353: PUSH
1354: LD_INT 2
1356: PUSH
1357: EMPTY
1358: LIST
1359: LIST
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 3
1368: PUSH
1369: LD_INT 24
1371: PUSH
1372: LD_INT 1000
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: PUSH
1379: EMPTY
1380: LIST
1381: LIST
1382: PUSH
1383: EMPTY
1384: LIST
1385: LIST
1386: LIST
1387: PPUSH
1388: CALL_OW 69
1392: PUSH
1393: FOR_IN
1394: IFFALSE 1410
// SetLives ( i , 1000 ) ;
1396: LD_VAR 0 1
1400: PPUSH
1401: LD_INT 1000
1403: PPUSH
1404: CALL_OW 234
1408: GO 1393
1410: POP
1411: POP
// end ;
1412: PPOPN 1
1414: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1415: LD_EXP 16
1419: PUSH
1420: LD_INT 5
1422: GREATEREQUAL
1423: IFFALSE 1435
1425: GO 1427
1427: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1428: LD_STRING ACH_ARTIFACT
1430: PPUSH
1431: CALL_OW 543
1435: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie , Mike ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1436: LD_INT 0
1438: PPUSH
1439: PPUSH
1440: PPUSH
1441: PPUSH
1442: PPUSH
// uc_side := 7 ;
1443: LD_ADDR_OWVAR 20
1447: PUSH
1448: LD_INT 7
1450: ST_TO_ADDR
// tmp := [ ] ;
1451: LD_ADDR_VAR 0 5
1455: PUSH
1456: EMPTY
1457: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1458: LD_ADDR_EXP 19
1462: PUSH
1463: LD_STRING JMM
1465: PPUSH
1466: LD_EXP 1
1470: NOT
1471: PPUSH
1472: LD_STRING 14a_
1474: PPUSH
1475: CALL 52062 0 3
1479: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1480: LD_ADDR_EXP 52
1484: PUSH
1485: LD_STRING Burlak
1487: PPUSH
1488: LD_EXP 1
1492: NOT
1493: PPUSH
1494: LD_STRING 14a_
1496: PPUSH
1497: CALL 52062 0 3
1501: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1502: LD_ADDR_EXP 34
1506: PUSH
1507: LD_STRING Joan
1509: PPUSH
1510: LD_EXP 1
1514: NOT
1515: PPUSH
1516: LD_STRING 13a_
1518: PPUSH
1519: CALL 52062 0 3
1523: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1524: LD_ADDR_EXP 20
1528: PUSH
1529: LD_STRING Roth
1531: PPUSH
1532: LD_EXP 1
1536: NOT
1537: PPUSH
1538: LD_STRING 13a_
1540: PPUSH
1541: CALL 52062 0 3
1545: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1546: LD_ADDR_EXP 38
1550: PUSH
1551: LD_STRING Gossudarov
1553: PPUSH
1554: LD_EXP 1
1558: NOT
1559: PPUSH
1560: LD_STRING 13a_
1562: PPUSH
1563: CALL 52062 0 3
1567: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1568: LD_ADDR_EXP 25
1572: PUSH
1573: LD_STRING Denis
1575: PPUSH
1576: LD_EXP 1
1580: NOT
1581: PPUSH
1582: LD_STRING 13a_
1584: PPUSH
1585: CALL 52062 0 3
1589: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1590: LD_ADDR_EXP 35
1594: PUSH
1595: LD_STRING DeltaDoctor
1597: PPUSH
1598: LD_EXP 1
1602: NOT
1603: PPUSH
1604: LD_STRING 13a_
1606: PPUSH
1607: CALL 52062 0 3
1611: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , 13a_ ) ;
1612: LD_ADDR_EXP 37
1616: PUSH
1617: LD_STRING Mike
1619: PPUSH
1620: LD_EXP 1
1624: NOT
1625: PPUSH
1626: LD_STRING 13a_
1628: PPUSH
1629: CALL 52062 0 3
1633: ST_TO_ADDR
// if DeltaDoctor then
1634: LD_EXP 35
1638: IFFALSE 1656
// tmp := tmp ^ DeltaDoctor ;
1640: LD_ADDR_VAR 0 5
1644: PUSH
1645: LD_VAR 0 5
1649: PUSH
1650: LD_EXP 35
1654: ADD
1655: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1656: LD_ADDR_EXP 33
1660: PUSH
1661: LD_STRING Simms
1663: PPUSH
1664: LD_EXP 1
1668: NOT
1669: PPUSH
1670: LD_STRING 13a_
1672: PPUSH
1673: CALL 52062 0 3
1677: ST_TO_ADDR
// if Simms then
1678: LD_EXP 33
1682: IFFALSE 1700
// tmp := tmp ^ Simms ;
1684: LD_ADDR_VAR 0 5
1688: PUSH
1689: LD_VAR 0 5
1693: PUSH
1694: LD_EXP 33
1698: ADD
1699: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1700: LD_ADDR_EXP 31
1704: PUSH
1705: LD_STRING Frank
1707: PPUSH
1708: LD_EXP 1
1712: NOT
1713: PPUSH
1714: LD_STRING 13a_
1716: PPUSH
1717: CALL 52062 0 3
1721: ST_TO_ADDR
// if Frank then
1722: LD_EXP 31
1726: IFFALSE 1744
// tmp := tmp ^ Frank ;
1728: LD_ADDR_VAR 0 5
1732: PUSH
1733: LD_VAR 0 5
1737: PUSH
1738: LD_EXP 31
1742: ADD
1743: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1744: LD_ADDR_EXP 39
1748: PUSH
1749: LD_STRING Kirilenkova
1751: PPUSH
1752: LD_EXP 1
1756: NOT
1757: PPUSH
1758: LD_STRING 13a_
1760: PPUSH
1761: CALL 52062 0 3
1765: ST_TO_ADDR
// if Kirilenkova then
1766: LD_EXP 39
1770: IFFALSE 1788
// tmp := tmp ^ Kirilenkova ;
1772: LD_ADDR_VAR 0 5
1776: PUSH
1777: LD_VAR 0 5
1781: PUSH
1782: LD_EXP 39
1786: ADD
1787: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1788: LD_ADDR_EXP 40
1792: PUSH
1793: LD_STRING Titov
1795: PPUSH
1796: LD_EXP 1
1800: NOT
1801: PPUSH
1802: LD_STRING 13a_
1804: PPUSH
1805: CALL 52062 0 3
1809: ST_TO_ADDR
// if Titov then
1810: LD_EXP 40
1814: IFFALSE 1832
// tmp := tmp ^ Titov ;
1816: LD_ADDR_VAR 0 5
1820: PUSH
1821: LD_VAR 0 5
1825: PUSH
1826: LD_EXP 40
1830: ADD
1831: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1832: LD_ADDR_EXP 41
1836: PUSH
1837: LD_STRING Fadeev
1839: PPUSH
1840: LD_EXP 1
1844: NOT
1845: PPUSH
1846: LD_STRING 13a_
1848: PPUSH
1849: CALL 52062 0 3
1853: ST_TO_ADDR
// if Fadeev then
1854: LD_EXP 41
1858: IFFALSE 1876
// tmp := tmp ^ Fadeev ;
1860: LD_ADDR_VAR 0 5
1864: PUSH
1865: LD_VAR 0 5
1869: PUSH
1870: LD_EXP 41
1874: ADD
1875: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1876: LD_ADDR_EXP 42
1880: PUSH
1881: LD_STRING Dolgov
1883: PPUSH
1884: LD_EXP 1
1888: NOT
1889: PPUSH
1890: LD_STRING 13a_
1892: PPUSH
1893: CALL 52062 0 3
1897: ST_TO_ADDR
// if Dolgov then
1898: LD_EXP 42
1902: IFFALSE 1920
// tmp := tmp ^ Dolgov ;
1904: LD_ADDR_VAR 0 5
1908: PUSH
1909: LD_VAR 0 5
1913: PUSH
1914: LD_EXP 42
1918: ADD
1919: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1920: LD_ADDR_EXP 43
1924: PUSH
1925: LD_STRING Petrosyan
1927: PPUSH
1928: LD_EXP 1
1932: NOT
1933: PPUSH
1934: LD_STRING 13a_
1936: PPUSH
1937: CALL 52062 0 3
1941: ST_TO_ADDR
// if Petrosyan then
1942: LD_EXP 43
1946: IFFALSE 1964
// tmp := tmp ^ Petrosyan ;
1948: LD_ADDR_VAR 0 5
1952: PUSH
1953: LD_VAR 0 5
1957: PUSH
1958: LD_EXP 43
1962: ADD
1963: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1964: LD_ADDR_EXP 44
1968: PUSH
1969: LD_STRING Scholtze
1971: PPUSH
1972: LD_EXP 1
1976: NOT
1977: PPUSH
1978: LD_STRING 13a_
1980: PPUSH
1981: CALL 52062 0 3
1985: ST_TO_ADDR
// if Scholtze then
1986: LD_EXP 44
1990: IFFALSE 2008
// tmp := tmp ^ Scholtze ;
1992: LD_ADDR_VAR 0 5
1996: PUSH
1997: LD_VAR 0 5
2001: PUSH
2002: LD_EXP 44
2006: ADD
2007: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
2008: LD_ADDR_EXP 45
2012: PUSH
2013: LD_STRING Oblukov
2015: PPUSH
2016: LD_EXP 1
2020: NOT
2021: PPUSH
2022: LD_STRING 13a_
2024: PPUSH
2025: CALL 52062 0 3
2029: ST_TO_ADDR
// if Oblukov then
2030: LD_EXP 45
2034: IFFALSE 2052
// tmp := tmp ^ Oblukov ;
2036: LD_ADDR_VAR 0 5
2040: PUSH
2041: LD_VAR 0 5
2045: PUSH
2046: LD_EXP 45
2050: ADD
2051: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
2052: LD_ADDR_EXP 46
2056: PUSH
2057: LD_STRING Kapitsova
2059: PPUSH
2060: LD_EXP 1
2064: NOT
2065: PPUSH
2066: LD_STRING 13a_
2068: PPUSH
2069: CALL 52062 0 3
2073: ST_TO_ADDR
// if Kapitsova then
2074: LD_EXP 46
2078: IFFALSE 2096
// tmp := tmp ^ Kapitsova ;
2080: LD_ADDR_VAR 0 5
2084: PUSH
2085: LD_VAR 0 5
2089: PUSH
2090: LD_EXP 46
2094: ADD
2095: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2096: LD_ADDR_EXP 47
2100: PUSH
2101: LD_STRING Lipshchin
2103: PPUSH
2104: LD_EXP 1
2108: NOT
2109: PPUSH
2110: LD_STRING 13a_
2112: PPUSH
2113: CALL 52062 0 3
2117: ST_TO_ADDR
// if Lipshchin then
2118: LD_EXP 47
2122: IFFALSE 2140
// tmp := tmp ^ Lipshchin ;
2124: LD_ADDR_VAR 0 5
2128: PUSH
2129: LD_VAR 0 5
2133: PUSH
2134: LD_EXP 47
2138: ADD
2139: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2140: LD_ADDR_EXP 48
2144: PUSH
2145: LD_STRING Petrovova
2147: PPUSH
2148: LD_EXP 1
2152: NOT
2153: PPUSH
2154: LD_STRING 13a_
2156: PPUSH
2157: CALL 52062 0 3
2161: ST_TO_ADDR
// if Petrovova then
2162: LD_EXP 48
2166: IFFALSE 2184
// tmp := tmp ^ Petrovova ;
2168: LD_ADDR_VAR 0 5
2172: PUSH
2173: LD_VAR 0 5
2177: PUSH
2178: LD_EXP 48
2182: ADD
2183: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2184: LD_ADDR_EXP 49
2188: PUSH
2189: LD_STRING Kovalyuk
2191: PPUSH
2192: LD_EXP 1
2196: NOT
2197: PPUSH
2198: LD_STRING 13a_
2200: PPUSH
2201: CALL 52062 0 3
2205: ST_TO_ADDR
// if Kovalyuk then
2206: LD_EXP 49
2210: IFFALSE 2228
// tmp := tmp ^ Kovalyuk ;
2212: LD_ADDR_VAR 0 5
2216: PUSH
2217: LD_VAR 0 5
2221: PUSH
2222: LD_EXP 49
2226: ADD
2227: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2228: LD_ADDR_EXP 50
2232: PUSH
2233: LD_STRING Kuzmov
2235: PPUSH
2236: LD_EXP 1
2240: NOT
2241: PPUSH
2242: LD_STRING 13a_
2244: PPUSH
2245: CALL 52062 0 3
2249: ST_TO_ADDR
// if Kuzmov then
2250: LD_EXP 50
2254: IFFALSE 2272
// tmp := tmp ^ Kuzmov ;
2256: LD_ADDR_VAR 0 5
2260: PUSH
2261: LD_VAR 0 5
2265: PUSH
2266: LD_EXP 50
2270: ADD
2271: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2272: LD_ADDR_EXP 51
2276: PUSH
2277: LD_STRING Karamazov
2279: PPUSH
2280: LD_EXP 1
2284: NOT
2285: PPUSH
2286: LD_STRING 13a_
2288: PPUSH
2289: CALL 52062 0 3
2293: ST_TO_ADDR
// if Karamazov then
2294: LD_EXP 51
2298: IFFALSE 2316
// tmp := tmp ^ Karamazov ;
2300: LD_ADDR_VAR 0 5
2304: PUSH
2305: LD_VAR 0 5
2309: PUSH
2310: LD_EXP 51
2314: ADD
2315: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2316: LD_ADDR_EXP 53
2320: PUSH
2321: LD_STRING Belkov
2323: PPUSH
2324: LD_EXP 1
2328: NOT
2329: PPUSH
2330: LD_STRING 13a_
2332: PPUSH
2333: CALL 52062 0 3
2337: ST_TO_ADDR
// if Belkov then
2338: LD_EXP 53
2342: IFFALSE 2360
// tmp := tmp ^ Belkov ;
2344: LD_ADDR_VAR 0 5
2348: PUSH
2349: LD_VAR 0 5
2353: PUSH
2354: LD_EXP 53
2358: ADD
2359: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2360: LD_ADDR_EXP 54
2364: PUSH
2365: LD_STRING Gnyevko
2367: PPUSH
2368: LD_EXP 1
2372: NOT
2373: PPUSH
2374: LD_STRING 13a_
2376: PPUSH
2377: CALL 52062 0 3
2381: ST_TO_ADDR
// if Gnyevko then
2382: LD_EXP 54
2386: IFFALSE 2404
// tmp := tmp ^ Gnyevko ;
2388: LD_ADDR_VAR 0 5
2392: PUSH
2393: LD_VAR 0 5
2397: PUSH
2398: LD_EXP 54
2402: ADD
2403: ST_TO_ADDR
// Connie = NewCharacter ( Coonie ) ;
2404: LD_ADDR_EXP 36
2408: PUSH
2409: LD_STRING Coonie
2411: PPUSH
2412: CALL_OW 25
2416: ST_TO_ADDR
// if not Lisa then
2417: LD_EXP 21
2421: NOT
2422: IFFALSE 2468
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2424: LD_ADDR_EXP 21
2428: PUSH
2429: LD_STRING Lisa
2431: PPUSH
2432: LD_EXP 1
2436: NOT
2437: PPUSH
2438: LD_STRING 13a_
2440: PPUSH
2441: CALL 52062 0 3
2445: ST_TO_ADDR
// if Lisa then
2446: LD_EXP 21
2450: IFFALSE 2468
// tmp := tmp ^ Lisa ;
2452: LD_ADDR_VAR 0 5
2456: PUSH
2457: LD_VAR 0 5
2461: PUSH
2462: LD_EXP 21
2466: ADD
2467: ST_TO_ADDR
// end ; if not Donaldson then
2468: LD_EXP 22
2472: NOT
2473: IFFALSE 2519
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2475: LD_ADDR_EXP 22
2479: PUSH
2480: LD_STRING Donaldson
2482: PPUSH
2483: LD_EXP 1
2487: NOT
2488: PPUSH
2489: LD_STRING 13a_
2491: PPUSH
2492: CALL 52062 0 3
2496: ST_TO_ADDR
// if Donaldson then
2497: LD_EXP 22
2501: IFFALSE 2519
// tmp := tmp ^ Donaldson ;
2503: LD_ADDR_VAR 0 5
2507: PUSH
2508: LD_VAR 0 5
2512: PUSH
2513: LD_EXP 22
2517: ADD
2518: ST_TO_ADDR
// end ; if not Bobby then
2519: LD_EXP 23
2523: NOT
2524: IFFALSE 2570
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2526: LD_ADDR_EXP 23
2530: PUSH
2531: LD_STRING Bobby
2533: PPUSH
2534: LD_EXP 1
2538: NOT
2539: PPUSH
2540: LD_STRING 13a_
2542: PPUSH
2543: CALL 52062 0 3
2547: ST_TO_ADDR
// if Bobby then
2548: LD_EXP 23
2552: IFFALSE 2570
// tmp := tmp ^ Bobby ;
2554: LD_ADDR_VAR 0 5
2558: PUSH
2559: LD_VAR 0 5
2563: PUSH
2564: LD_EXP 23
2568: ADD
2569: ST_TO_ADDR
// end ; if not Cyrus then
2570: LD_EXP 24
2574: NOT
2575: IFFALSE 2621
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2577: LD_ADDR_EXP 24
2581: PUSH
2582: LD_STRING Cyrus
2584: PPUSH
2585: LD_EXP 1
2589: NOT
2590: PPUSH
2591: LD_STRING 13a_
2593: PPUSH
2594: CALL 52062 0 3
2598: ST_TO_ADDR
// if Cyrus then
2599: LD_EXP 24
2603: IFFALSE 2621
// tmp := tmp ^ Cyrus ;
2605: LD_ADDR_VAR 0 5
2609: PUSH
2610: LD_VAR 0 5
2614: PUSH
2615: LD_EXP 24
2619: ADD
2620: ST_TO_ADDR
// end ; if not Brown then
2621: LD_EXP 26
2625: NOT
2626: IFFALSE 2672
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2628: LD_ADDR_EXP 26
2632: PUSH
2633: LD_STRING Brown
2635: PPUSH
2636: LD_EXP 1
2640: NOT
2641: PPUSH
2642: LD_STRING 13a_
2644: PPUSH
2645: CALL 52062 0 3
2649: ST_TO_ADDR
// if Brown then
2650: LD_EXP 26
2654: IFFALSE 2672
// tmp := tmp ^ Brown ;
2656: LD_ADDR_VAR 0 5
2660: PUSH
2661: LD_VAR 0 5
2665: PUSH
2666: LD_EXP 26
2670: ADD
2671: ST_TO_ADDR
// end ; if not Gladstone then
2672: LD_EXP 27
2676: NOT
2677: IFFALSE 2723
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2679: LD_ADDR_EXP 27
2683: PUSH
2684: LD_STRING Gladstone
2686: PPUSH
2687: LD_EXP 1
2691: NOT
2692: PPUSH
2693: LD_STRING 13a_
2695: PPUSH
2696: CALL 52062 0 3
2700: ST_TO_ADDR
// if Gladstone then
2701: LD_EXP 27
2705: IFFALSE 2723
// tmp := tmp ^ Gladstone ;
2707: LD_ADDR_VAR 0 5
2711: PUSH
2712: LD_VAR 0 5
2716: PUSH
2717: LD_EXP 27
2721: ADD
2722: ST_TO_ADDR
// end ; if not Cornel then
2723: LD_EXP 29
2727: NOT
2728: IFFALSE 2774
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2730: LD_ADDR_EXP 29
2734: PUSH
2735: LD_STRING Cornel
2737: PPUSH
2738: LD_EXP 1
2742: NOT
2743: PPUSH
2744: LD_STRING 13a_
2746: PPUSH
2747: CALL 52062 0 3
2751: ST_TO_ADDR
// if Cornel then
2752: LD_EXP 29
2756: IFFALSE 2774
// tmp := tmp ^ Cornel ;
2758: LD_ADDR_VAR 0 5
2762: PUSH
2763: LD_VAR 0 5
2767: PUSH
2768: LD_EXP 29
2772: ADD
2773: ST_TO_ADDR
// end ; if not Houten then
2774: LD_EXP 28
2778: NOT
2779: IFFALSE 2825
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2781: LD_ADDR_EXP 28
2785: PUSH
2786: LD_STRING Houten
2788: PPUSH
2789: LD_EXP 1
2793: NOT
2794: PPUSH
2795: LD_STRING 13a_
2797: PPUSH
2798: CALL 52062 0 3
2802: ST_TO_ADDR
// if Houten then
2803: LD_EXP 28
2807: IFFALSE 2825
// tmp := tmp ^ Houten ;
2809: LD_ADDR_VAR 0 5
2813: PUSH
2814: LD_VAR 0 5
2818: PUSH
2819: LD_EXP 28
2823: ADD
2824: ST_TO_ADDR
// end ; if not Gary then
2825: LD_EXP 30
2829: NOT
2830: IFFALSE 2876
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2832: LD_ADDR_EXP 30
2836: PUSH
2837: LD_STRING Gary
2839: PPUSH
2840: LD_EXP 1
2844: NOT
2845: PPUSH
2846: LD_STRING 13a_
2848: PPUSH
2849: CALL 52062 0 3
2853: ST_TO_ADDR
// if Gary then
2854: LD_EXP 30
2858: IFFALSE 2876
// tmp := tmp ^ Gary ;
2860: LD_ADDR_VAR 0 5
2864: PUSH
2865: LD_VAR 0 5
2869: PUSH
2870: LD_EXP 30
2874: ADD
2875: ST_TO_ADDR
// end ; if not Kikuchi then
2876: LD_EXP 32
2880: NOT
2881: IFFALSE 2927
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2883: LD_ADDR_EXP 32
2887: PUSH
2888: LD_STRING Kikuchi
2890: PPUSH
2891: LD_EXP 1
2895: NOT
2896: PPUSH
2897: LD_STRING 13a_
2899: PPUSH
2900: CALL 52062 0 3
2904: ST_TO_ADDR
// if Kikuchi then
2905: LD_EXP 32
2909: IFFALSE 2927
// tmp := tmp ^ Kikuchi ;
2911: LD_ADDR_VAR 0 5
2915: PUSH
2916: LD_VAR 0 5
2920: PUSH
2921: LD_EXP 32
2925: ADD
2926: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2927: LD_ADDR_VAR 0 5
2931: PUSH
2932: LD_VAR 0 5
2936: PUSH
2937: LD_STRING 13a_others
2939: PPUSH
2940: CALL_OW 31
2944: UNION
2945: ST_TO_ADDR
// tmp := tmp diff 0 ;
2946: LD_ADDR_VAR 0 5
2950: PUSH
2951: LD_VAR 0 5
2955: PUSH
2956: LD_INT 0
2958: DIFF
2959: ST_TO_ADDR
// if tmp < 15 then
2960: LD_VAR 0 5
2964: PUSH
2965: LD_INT 15
2967: LESS
2968: IFFALSE 3056
// for i = 15 downto tmp do
2970: LD_ADDR_VAR 0 2
2974: PUSH
2975: DOUBLE
2976: LD_INT 15
2978: INC
2979: ST_TO_ADDR
2980: LD_VAR 0 5
2984: PUSH
2985: FOR_DOWNTO
2986: IFFALSE 3054
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2988: LD_ADDR_OWVAR 21
2992: PUSH
2993: LD_INT 1
2995: PUSH
2996: LD_INT 3
2998: PUSH
2999: EMPTY
3000: LIST
3001: LIST
3002: PUSH
3003: LD_INT 1
3005: PPUSH
3006: LD_INT 2
3008: PPUSH
3009: CALL_OW 12
3013: ARRAY
3014: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
3015: LD_INT 0
3017: PPUSH
3018: LD_INT 1
3020: PPUSH
3021: LD_INT 4
3023: PPUSH
3024: CALL_OW 12
3028: PPUSH
3029: LD_INT 8
3031: PPUSH
3032: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3036: LD_ADDR_VAR 0 5
3040: PUSH
3041: LD_VAR 0 5
3045: PUSH
3046: CALL_OW 44
3050: ADD
3051: ST_TO_ADDR
// end ;
3052: GO 2985
3054: POP
3055: POP
// if not debug then
3056: LD_EXP 1
3060: NOT
3061: IFFALSE 3241
// selected = CharacterSelection (  , [ 14 , 13 , 12 , 11 ] [ Difficulty ] , [ 14 , 13 , 12 , 11 ] [ Difficulty ] , [ sel_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
3063: LD_ADDR_VAR 0 4
3067: PUSH
3068: LD_STRING 
3070: PPUSH
3071: LD_INT 14
3073: PUSH
3074: LD_INT 13
3076: PUSH
3077: LD_INT 12
3079: PUSH
3080: LD_INT 11
3082: PUSH
3083: EMPTY
3084: LIST
3085: LIST
3086: LIST
3087: LIST
3088: PUSH
3089: LD_OWVAR 67
3093: ARRAY
3094: PPUSH
3095: LD_INT 14
3097: PUSH
3098: LD_INT 13
3100: PUSH
3101: LD_INT 12
3103: PUSH
3104: LD_INT 11
3106: PUSH
3107: EMPTY
3108: LIST
3109: LIST
3110: LIST
3111: LIST
3112: PUSH
3113: LD_OWVAR 67
3117: ARRAY
3118: PPUSH
3119: LD_INT -5
3121: PUSH
3122: LD_EXP 19
3126: PUSH
3127: LD_EXP 52
3131: PUSH
3132: LD_EXP 20
3136: PUSH
3137: LD_EXP 34
3141: PUSH
3142: LD_EXP 25
3146: PUSH
3147: LD_EXP 38
3151: PUSH
3152: LD_INT -2
3154: PUSH
3155: LD_INT -3
3157: PUSH
3158: LD_INT -5
3160: PUSH
3161: EMPTY
3162: LIST
3163: LIST
3164: LIST
3165: LIST
3166: LIST
3167: LIST
3168: LIST
3169: LIST
3170: LIST
3171: LIST
3172: PUSH
3173: LD_VAR 0 5
3177: ADD
3178: PPUSH
3179: LD_INT 1
3181: PUSH
3182: LD_INT 4
3184: PUSH
3185: LD_INT 2
3187: PUSH
3188: LD_INT 1
3190: PUSH
3191: EMPTY
3192: LIST
3193: LIST
3194: PUSH
3195: LD_INT 3
3197: PUSH
3198: LD_INT 5
3200: PUSH
3201: LD_INT 0
3203: PUSH
3204: LD_INT 3
3206: PUSH
3207: EMPTY
3208: LIST
3209: LIST
3210: LIST
3211: PUSH
3212: LD_INT 9
3214: PUSH
3215: LD_INT 0
3217: PUSH
3218: LD_INT 3
3220: PUSH
3221: EMPTY
3222: LIST
3223: LIST
3224: LIST
3225: PUSH
3226: EMPTY
3227: LIST
3228: LIST
3229: LIST
3230: LIST
3231: LIST
3232: LIST
3233: PPUSH
3234: CALL_OW 42
3238: ST_TO_ADDR
3239: GO 3290
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova ] ;
3241: LD_ADDR_VAR 0 4
3245: PUSH
3246: LD_EXP 40
3250: PUSH
3251: LD_EXP 41
3255: PUSH
3256: LD_EXP 42
3260: PUSH
3261: LD_EXP 43
3265: PUSH
3266: LD_EXP 44
3270: PUSH
3271: LD_EXP 45
3275: PUSH
3276: LD_EXP 46
3280: PUSH
3281: EMPTY
3282: LIST
3283: LIST
3284: LIST
3285: LIST
3286: LIST
3287: LIST
3288: LIST
3289: ST_TO_ADDR
// allianceTeam := tmp diff selected ;
3290: LD_ADDR_EXP 17
3294: PUSH
3295: LD_VAR 0 5
3299: PUSH
3300: LD_VAR 0 4
3304: DIFF
3305: ST_TO_ADDR
// uc_nation := 1 ;
3306: LD_ADDR_OWVAR 21
3310: PUSH
3311: LD_INT 1
3313: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3314: LD_INT 5
3316: PPUSH
3317: LD_INT 3
3319: PPUSH
3320: LD_INT 1
3322: PPUSH
3323: LD_INT 6
3325: PPUSH
3326: LD_INT 100
3328: PPUSH
3329: CALL 57077 0 5
// veh := CreateVehicle ;
3333: LD_ADDR_VAR 0 3
3337: PUSH
3338: CALL_OW 45
3342: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3343: LD_VAR 0 3
3347: PPUSH
3348: LD_INT 7
3350: NEG
3351: PPUSH
3352: CALL_OW 242
// SetDir ( veh , 3 ) ;
3356: LD_VAR 0 3
3360: PPUSH
3361: LD_INT 3
3363: PPUSH
3364: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3368: LD_VAR 0 3
3372: PPUSH
3373: LD_INT 31
3375: PPUSH
3376: LD_INT 0
3378: PPUSH
3379: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3383: LD_EXP 19
3387: PPUSH
3388: LD_VAR 0 3
3392: PPUSH
3393: CALL_OW 52
// if Joan then
3397: LD_EXP 34
3401: IFFALSE 3473
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3403: LD_INT 3
3405: PPUSH
3406: LD_INT 3
3408: PPUSH
3409: LD_INT 1
3411: PPUSH
3412: LD_INT 11
3414: PPUSH
3415: LD_INT 100
3417: PPUSH
3418: CALL 57077 0 5
// veh := CreateVehicle ;
3422: LD_ADDR_VAR 0 3
3426: PUSH
3427: CALL_OW 45
3431: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3432: LD_VAR 0 3
3436: PPUSH
3437: LD_INT 3
3439: PPUSH
3440: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3444: LD_VAR 0 3
3448: PPUSH
3449: LD_INT 30
3451: PPUSH
3452: LD_INT 0
3454: PPUSH
3455: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3459: LD_EXP 34
3463: PPUSH
3464: LD_VAR 0 3
3468: PPUSH
3469: CALL_OW 52
// end ; if Roth then
3473: LD_EXP 20
3477: IFFALSE 3549
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3479: LD_INT 3
3481: PPUSH
3482: LD_INT 3
3484: PPUSH
3485: LD_INT 1
3487: PPUSH
3488: LD_INT 11
3490: PPUSH
3491: LD_INT 100
3493: PPUSH
3494: CALL 57077 0 5
// veh := CreateVehicle ;
3498: LD_ADDR_VAR 0 3
3502: PUSH
3503: CALL_OW 45
3507: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3508: LD_VAR 0 3
3512: PPUSH
3513: LD_INT 3
3515: PPUSH
3516: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3520: LD_VAR 0 3
3524: PPUSH
3525: LD_INT 30
3527: PPUSH
3528: LD_INT 0
3530: PPUSH
3531: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3535: LD_EXP 20
3539: PPUSH
3540: LD_VAR 0 3
3544: PPUSH
3545: CALL_OW 52
// end ; if Denis then
3549: LD_EXP 25
3553: IFFALSE 3625
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3555: LD_INT 5
3557: PPUSH
3558: LD_INT 3
3560: PPUSH
3561: LD_INT 1
3563: PPUSH
3564: LD_INT 9
3566: PPUSH
3567: LD_INT 100
3569: PPUSH
3570: CALL 57077 0 5
// veh := CreateVehicle ;
3574: LD_ADDR_VAR 0 3
3578: PUSH
3579: CALL_OW 45
3583: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3584: LD_VAR 0 3
3588: PPUSH
3589: LD_INT 3
3591: PPUSH
3592: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3596: LD_VAR 0 3
3600: PPUSH
3601: LD_INT 30
3603: PPUSH
3604: LD_INT 0
3606: PPUSH
3607: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3611: LD_EXP 25
3615: PPUSH
3616: LD_VAR 0 3
3620: PPUSH
3621: CALL_OW 52
// end ; uc_nation := 3 ;
3625: LD_ADDR_OWVAR 21
3629: PUSH
3630: LD_INT 3
3632: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3633: LD_INT 22
3635: PPUSH
3636: LD_INT 3
3638: PPUSH
3639: LD_INT 1
3641: PPUSH
3642: LD_INT 45
3644: PPUSH
3645: LD_INT 100
3647: PPUSH
3648: CALL 57077 0 5
// veh := CreateVehicle ;
3652: LD_ADDR_VAR 0 3
3656: PUSH
3657: CALL_OW 45
3661: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3662: LD_VAR 0 3
3666: PPUSH
3667: LD_INT 7
3669: NEG
3670: PPUSH
3671: CALL_OW 242
// SetDir ( veh , 3 ) ;
3675: LD_VAR 0 3
3679: PPUSH
3680: LD_INT 3
3682: PPUSH
3683: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3687: LD_VAR 0 3
3691: PPUSH
3692: LD_INT 31
3694: PPUSH
3695: LD_INT 0
3697: PPUSH
3698: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3702: LD_EXP 52
3706: PPUSH
3707: LD_VAR 0 3
3711: PPUSH
3712: CALL_OW 52
// if Gossudarov then
3716: LD_EXP 38
3720: IFFALSE 3807
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3722: LD_INT 22
3724: PPUSH
3725: LD_INT 3
3727: PPUSH
3728: LD_INT 1
3730: PPUSH
3731: LD_INT 51
3733: PPUSH
3734: LD_INT 100
3736: PPUSH
3737: CALL 57077 0 5
// veh := CreateVehicle ;
3741: LD_ADDR_VAR 0 3
3745: PUSH
3746: CALL_OW 45
3750: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3751: LD_VAR 0 3
3755: PPUSH
3756: LD_INT 3
3758: PPUSH
3759: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3763: LD_VAR 0 3
3767: PPUSH
3768: LD_INT 30
3770: PPUSH
3771: LD_INT 0
3773: PPUSH
3774: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3778: LD_EXP 38
3782: PPUSH
3783: LD_VAR 0 3
3787: PPUSH
3788: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3792: LD_VAR 0 3
3796: PPUSH
3797: LD_INT 1
3799: PPUSH
3800: LD_INT 100
3802: PPUSH
3803: CALL_OW 290
// end ; if Mike then
3807: LD_EXP 37
3811: IFFALSE 3828
// PlaceUnitArea ( Mike , allianceSpawnArea , false ) ;
3813: LD_EXP 37
3817: PPUSH
3818: LD_INT 30
3820: PPUSH
3821: LD_INT 0
3823: PPUSH
3824: CALL_OW 49
// for i in selected do
3828: LD_ADDR_VAR 0 2
3832: PUSH
3833: LD_VAR 0 4
3837: PUSH
3838: FOR_IN
3839: IFFALSE 4397
// begin uc_nation := GetNation ( i ) ;
3841: LD_ADDR_OWVAR 21
3845: PUSH
3846: LD_VAR 0 2
3850: PPUSH
3851: CALL_OW 248
3855: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3856: LD_VAR 0 2
3860: PUSH
3861: LD_EXP 21
3865: PUSH
3866: LD_EXP 22
3870: PUSH
3871: LD_EXP 24
3875: PUSH
3876: LD_EXP 23
3880: PUSH
3881: EMPTY
3882: LIST
3883: LIST
3884: LIST
3885: LIST
3886: IN
3887: IFFALSE 3910
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3889: LD_INT 5
3891: PPUSH
3892: LD_INT 3
3894: PPUSH
3895: LD_INT 1
3897: PPUSH
3898: LD_INT 6
3900: PPUSH
3901: LD_INT 100
3903: PPUSH
3904: CALL 57077 0 5
3908: GO 4344
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3910: LD_VAR 0 2
3914: PUSH
3915: LD_EXP 45
3919: PUSH
3920: LD_EXP 50
3924: PUSH
3925: LD_EXP 48
3929: PUSH
3930: LD_EXP 40
3934: PUSH
3935: EMPTY
3936: LIST
3937: LIST
3938: LIST
3939: LIST
3940: IN
3941: IFFALSE 3972
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3943: LD_INT 24
3945: PPUSH
3946: LD_INT 1
3948: PPUSH
3949: LD_INT 1
3951: PPUSH
3952: LD_INT 46
3954: PPUSH
3955: LD_INT 65
3957: PPUSH
3958: LD_INT 75
3960: PPUSH
3961: CALL_OW 12
3965: PPUSH
3966: CALL 57077 0 5
3970: GO 4344
// if i = Karamazov then
3972: LD_VAR 0 2
3976: PUSH
3977: LD_EXP 51
3981: EQUAL
3982: IFFALSE 4005
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3984: LD_INT 22
3986: PPUSH
3987: LD_INT 3
3989: PPUSH
3990: LD_INT 1
3992: PPUSH
3993: LD_INT 52
3995: PPUSH
3996: LD_INT 100
3998: PPUSH
3999: CALL 57077 0 5
4003: GO 4344
// if i = Brown then
4005: LD_VAR 0 2
4009: PUSH
4010: LD_EXP 26
4014: EQUAL
4015: IFFALSE 4038
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
4017: LD_INT 3
4019: PPUSH
4020: LD_INT 3
4022: PPUSH
4023: LD_INT 1
4025: PPUSH
4026: LD_INT 13
4028: PPUSH
4029: LD_INT 100
4031: PPUSH
4032: CALL 57077 0 5
4036: GO 4344
// if uc_nation = nation_american then
4038: LD_OWVAR 21
4042: PUSH
4043: LD_INT 1
4045: EQUAL
4046: IFFALSE 4197
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4048: LD_INT 3
4050: PUSH
4051: LD_INT 5
4053: PUSH
4054: LD_INT 5
4056: PUSH
4057: EMPTY
4058: LIST
4059: LIST
4060: LIST
4061: PUSH
4062: LD_OWVAR 21
4066: PUSH
4067: LD_INT 3
4069: MOD
4070: PUSH
4071: LD_INT 1
4073: PLUS
4074: ARRAY
4075: PPUSH
4076: LD_INT 1
4078: PUSH
4079: LD_INT 3
4081: PUSH
4082: LD_INT 1
4084: PUSH
4085: EMPTY
4086: LIST
4087: LIST
4088: LIST
4089: PUSH
4090: LD_OWVAR 21
4094: PUSH
4095: LD_INT 3
4097: MOD
4098: PUSH
4099: LD_INT 1
4101: PLUS
4102: ARRAY
4103: PPUSH
4104: LD_INT 1
4106: PPUSH
4107: LD_INT 11
4109: PUSH
4110: LD_INT 4
4112: PUSH
4113: LD_INT 5
4115: PUSH
4116: EMPTY
4117: LIST
4118: LIST
4119: LIST
4120: PUSH
4121: LD_INT 6
4123: PUSH
4124: LD_INT 7
4126: PUSH
4127: LD_INT 9
4129: PUSH
4130: EMPTY
4131: LIST
4132: LIST
4133: LIST
4134: PUSH
4135: LD_INT 6
4137: PUSH
4138: LD_INT 9
4140: PUSH
4141: LD_INT 12
4143: PUSH
4144: EMPTY
4145: LIST
4146: LIST
4147: LIST
4148: PUSH
4149: EMPTY
4150: LIST
4151: LIST
4152: LIST
4153: PUSH
4154: LD_OWVAR 21
4158: PUSH
4159: LD_INT 3
4161: MOD
4162: PUSH
4163: LD_INT 1
4165: PLUS
4166: ARRAY
4167: PUSH
4168: LD_INT 1
4170: PPUSH
4171: LD_INT 3
4173: PPUSH
4174: CALL_OW 12
4178: ARRAY
4179: PPUSH
4180: LD_INT 65
4182: PPUSH
4183: LD_INT 75
4185: PPUSH
4186: CALL_OW 12
4190: PPUSH
4191: CALL 57077 0 5
// end else
4195: GO 4344
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4197: LD_INT 22
4199: PUSH
4200: LD_INT 23
4202: PUSH
4203: LD_INT 23
4205: PUSH
4206: EMPTY
4207: LIST
4208: LIST
4209: LIST
4210: PUSH
4211: LD_OWVAR 21
4215: PUSH
4216: LD_INT 3
4218: MOD
4219: PUSH
4220: LD_INT 1
4222: PLUS
4223: ARRAY
4224: PPUSH
4225: LD_INT 1
4227: PUSH
4228: LD_INT 3
4230: PUSH
4231: LD_INT 1
4233: PUSH
4234: EMPTY
4235: LIST
4236: LIST
4237: LIST
4238: PUSH
4239: LD_OWVAR 21
4243: PUSH
4244: LD_INT 3
4246: MOD
4247: PUSH
4248: LD_INT 1
4250: PLUS
4251: ARRAY
4252: PPUSH
4253: LD_INT 1
4255: PPUSH
4256: LD_INT 45
4258: PUSH
4259: LD_INT 43
4261: PUSH
4262: LD_INT 44
4264: PUSH
4265: EMPTY
4266: LIST
4267: LIST
4268: LIST
4269: PUSH
4270: LD_INT 46
4272: PUSH
4273: LD_INT 45
4275: PUSH
4276: LD_INT 44
4278: PUSH
4279: EMPTY
4280: LIST
4281: LIST
4282: LIST
4283: PUSH
4284: LD_INT 46
4286: PUSH
4287: LD_INT 43
4289: PUSH
4290: LD_INT 45
4292: PUSH
4293: EMPTY
4294: LIST
4295: LIST
4296: LIST
4297: PUSH
4298: EMPTY
4299: LIST
4300: LIST
4301: LIST
4302: PUSH
4303: LD_OWVAR 21
4307: PUSH
4308: LD_INT 3
4310: MOD
4311: PUSH
4312: LD_INT 1
4314: PLUS
4315: ARRAY
4316: PUSH
4317: LD_INT 1
4319: PPUSH
4320: LD_INT 3
4322: PPUSH
4323: CALL_OW 12
4327: ARRAY
4328: PPUSH
4329: LD_INT 65
4331: PPUSH
4332: LD_INT 75
4334: PPUSH
4335: CALL_OW 12
4339: PPUSH
4340: CALL 57077 0 5
// end ; veh := CreateVehicle ;
4344: LD_ADDR_VAR 0 3
4348: PUSH
4349: CALL_OW 45
4353: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4354: LD_VAR 0 3
4358: PPUSH
4359: LD_INT 3
4361: PPUSH
4362: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4366: LD_VAR 0 3
4370: PPUSH
4371: LD_INT 30
4373: PPUSH
4374: LD_INT 0
4376: PPUSH
4377: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4381: LD_VAR 0 2
4385: PPUSH
4386: LD_VAR 0 3
4390: PPUSH
4391: CALL_OW 52
// end ;
4395: GO 3838
4397: POP
4398: POP
// if artifactArCaptured then
4399: LD_EXP 9
4403: IFFALSE 4489
// begin uc_nation := nation_american ;
4405: LD_ADDR_OWVAR 21
4409: PUSH
4410: LD_INT 1
4412: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4413: LD_INT 3
4415: PPUSH
4416: LD_INT 3
4418: PPUSH
4419: LD_INT 3
4421: PPUSH
4422: LD_INT 12
4424: PPUSH
4425: LD_INT 100
4427: PPUSH
4428: CALL 57077 0 5
// veh := CreateVehicle ;
4432: LD_ADDR_VAR 0 3
4436: PUSH
4437: CALL_OW 45
4441: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4442: LD_VAR 0 3
4446: PPUSH
4447: LD_INT 3
4449: PPUSH
4450: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4454: LD_VAR 0 3
4458: PPUSH
4459: LD_INT 198
4461: PPUSH
4462: LD_INT 22
4464: PPUSH
4465: LD_INT 0
4467: PPUSH
4468: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4472: LD_VAR 0 3
4476: PPUSH
4477: LD_INT 4
4479: PPUSH
4480: LD_INT 50
4482: PPUSH
4483: CALL_OW 290
// end else
4487: GO 4508
// begin CreateResourcesXY ( mat_artifact , 5 , 267 , 226 , false ) ;
4489: LD_INT 4
4491: PPUSH
4492: LD_INT 5
4494: PPUSH
4495: LD_INT 267
4497: PPUSH
4498: LD_INT 226
4500: PPUSH
4501: LD_INT 0
4503: PPUSH
4504: CALL_OW 58
// end ; uc_nation := nation_american ;
4508: LD_ADDR_OWVAR 21
4512: PUSH
4513: LD_INT 1
4515: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4516: LD_INT 3
4518: PPUSH
4519: LD_INT 3
4521: PPUSH
4522: LD_INT 3
4524: PPUSH
4525: LD_INT 12
4527: PPUSH
4528: LD_INT 100
4530: PPUSH
4531: CALL 57077 0 5
// veh := CreateVehicle ;
4535: LD_ADDR_VAR 0 3
4539: PUSH
4540: CALL_OW 45
4544: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4545: LD_VAR 0 3
4549: PPUSH
4550: LD_INT 3
4552: PPUSH
4553: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4557: LD_VAR 0 3
4561: PPUSH
4562: LD_INT 218
4564: PPUSH
4565: LD_INT 23
4567: PPUSH
4568: LD_INT 0
4570: PPUSH
4571: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4575: LD_VAR 0 3
4579: PPUSH
4580: LD_INT 4
4582: PPUSH
4583: LD_INT 30
4585: PPUSH
4586: CALL_OW 290
// uc_nation := nation_russian ;
4590: LD_ADDR_OWVAR 21
4594: PUSH
4595: LD_INT 3
4597: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4598: LD_INT 22
4600: PPUSH
4601: LD_INT 3
4603: PPUSH
4604: LD_INT 3
4606: PPUSH
4607: LD_INT 51
4609: PPUSH
4610: LD_INT 100
4612: PPUSH
4613: CALL 57077 0 5
// veh := CreateVehicle ;
4617: LD_ADDR_VAR 0 3
4621: PUSH
4622: CALL_OW 45
4626: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4627: LD_VAR 0 3
4631: PPUSH
4632: LD_INT 3
4634: PPUSH
4635: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4639: LD_VAR 0 3
4643: PPUSH
4644: LD_INT 214
4646: PPUSH
4647: LD_INT 20
4649: PPUSH
4650: LD_INT 0
4652: PPUSH
4653: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4657: LD_VAR 0 3
4661: PPUSH
4662: LD_INT 4
4664: PPUSH
4665: LD_INT 40
4667: PPUSH
4668: CALL_OW 290
// end ;
4672: LD_VAR 0 1
4676: RET
// export function AllianceSupport ; var i , veh ; begin
4677: LD_INT 0
4679: PPUSH
4680: PPUSH
4681: PPUSH
// if not allianceTeam then
4682: LD_EXP 17
4686: NOT
4687: IFFALSE 4691
// exit ;
4689: GO 5097
// for i := 1 to 6 do
4691: LD_ADDR_VAR 0 2
4695: PUSH
4696: DOUBLE
4697: LD_INT 1
4699: DEC
4700: ST_TO_ADDR
4701: LD_INT 6
4703: PUSH
4704: FOR_TO
4705: IFFALSE 5001
// begin uc_side := 7 ;
4707: LD_ADDR_OWVAR 20
4711: PUSH
4712: LD_INT 7
4714: ST_TO_ADDR
// uc_nation := [ 1 , 3 ] [ i mod 2 + 1 ] ;
4715: LD_ADDR_OWVAR 21
4719: PUSH
4720: LD_INT 1
4722: PUSH
4723: LD_INT 3
4725: PUSH
4726: EMPTY
4727: LIST
4728: LIST
4729: PUSH
4730: LD_VAR 0 2
4734: PUSH
4735: LD_INT 2
4737: MOD
4738: PUSH
4739: LD_INT 1
4741: PLUS
4742: ARRAY
4743: ST_TO_ADDR
// if uc_nation = 1 then
4744: LD_OWVAR 21
4748: PUSH
4749: LD_INT 1
4751: EQUAL
4752: IFFALSE 4794
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , [ us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) else
4754: LD_INT 5
4756: PPUSH
4757: LD_INT 3
4759: PPUSH
4760: LD_INT 1
4762: PPUSH
4763: LD_INT 6
4765: PUSH
4766: LD_INT 7
4768: PUSH
4769: EMPTY
4770: LIST
4771: LIST
4772: PUSH
4773: LD_INT 1
4775: PPUSH
4776: LD_INT 2
4778: PPUSH
4779: CALL_OW 12
4783: ARRAY
4784: PPUSH
4785: LD_INT 100
4787: PPUSH
4788: CALL 57077 0 5
4792: GO 4832
// PrepareVehicle ( ru_heavy_wheeled , engine_siberite , control_manual , [ ru_heavy_gun , ru_rocket ] [ rand ( 1 , 2 ) ] , 100 ) ;
4794: LD_INT 23
4796: PPUSH
4797: LD_INT 3
4799: PPUSH
4800: LD_INT 1
4802: PPUSH
4803: LD_INT 46
4805: PUSH
4806: LD_INT 47
4808: PUSH
4809: EMPTY
4810: LIST
4811: LIST
4812: PUSH
4813: LD_INT 1
4815: PPUSH
4816: LD_INT 2
4818: PPUSH
4819: CALL_OW 12
4823: ARRAY
4824: PPUSH
4825: LD_INT 100
4827: PPUSH
4828: CALL 57077 0 5
// if not allianceTeam then
4832: LD_EXP 17
4836: NOT
4837: IFFALSE 4841
// break ;
4839: GO 5001
// veh := CreateVehicle ;
4841: LD_ADDR_VAR 0 3
4845: PUSH
4846: CALL_OW 45
4850: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4851: LD_VAR 0 3
4855: PPUSH
4856: LD_INT 4
4858: PPUSH
4859: CALL_OW 233
// PlaceUnitArea ( veh , allianceSouthSupp , false ) ;
4863: LD_VAR 0 3
4867: PPUSH
4868: LD_INT 38
4870: PPUSH
4871: LD_INT 0
4873: PPUSH
4874: CALL_OW 49
// if GetSkill ( allianceTeam [ 1 ] , class_mechanic ) > 4 then
4878: LD_EXP 17
4882: PUSH
4883: LD_INT 1
4885: ARRAY
4886: PPUSH
4887: LD_INT 3
4889: PPUSH
4890: CALL_OW 259
4894: PUSH
4895: LD_INT 4
4897: GREATER
4898: IFFALSE 4916
// SetClass ( allianceTeam [ 1 ] , class_mechanic ) ;
4900: LD_EXP 17
4904: PUSH
4905: LD_INT 1
4907: ARRAY
4908: PPUSH
4909: LD_INT 3
4911: PPUSH
4912: CALL_OW 336
// if GetSkill ( allianceTeam [ 1 ] , class_scientistic ) > 8 then
4916: LD_EXP 17
4920: PUSH
4921: LD_INT 1
4923: ARRAY
4924: PPUSH
4925: LD_INT 4
4927: PPUSH
4928: CALL_OW 259
4932: PUSH
4933: LD_INT 8
4935: GREATER
4936: IFFALSE 4954
// SetClass ( allianceTeam [ 1 ] , class_scientistic ) ;
4938: LD_EXP 17
4942: PUSH
4943: LD_INT 1
4945: ARRAY
4946: PPUSH
4947: LD_INT 4
4949: PPUSH
4950: CALL_OW 336
// PlaceHumanInUnit ( allianceTeam [ 1 ] , veh ) ;
4954: LD_EXP 17
4958: PUSH
4959: LD_INT 1
4961: ARRAY
4962: PPUSH
4963: LD_VAR 0 3
4967: PPUSH
4968: CALL_OW 52
// allianceTeam := Delete ( allianceTeam , 1 ) ;
4972: LD_ADDR_EXP 17
4976: PUSH
4977: LD_EXP 17
4981: PPUSH
4982: LD_INT 1
4984: PPUSH
4985: CALL_OW 3
4989: ST_TO_ADDR
// ComHold ( veh ) ;
4990: LD_VAR 0 3
4994: PPUSH
4995: CALL_OW 140
// end ;
4999: GO 4704
5001: POP
5002: POP
// uc_side := 7 ;
5003: LD_ADDR_OWVAR 20
5007: PUSH
5008: LD_INT 7
5010: ST_TO_ADDR
// uc_nation := 1 ;
5011: LD_ADDR_OWVAR 21
5015: PUSH
5016: LD_INT 1
5018: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_computer , us_radar , 100 ) ;
5019: LD_INT 5
5021: PPUSH
5022: LD_INT 3
5024: PPUSH
5025: LD_INT 3
5027: PPUSH
5028: LD_INT 11
5030: PPUSH
5031: LD_INT 100
5033: PPUSH
5034: CALL 57077 0 5
// veh := CreateVehicle ;
5038: LD_ADDR_VAR 0 3
5042: PUSH
5043: CALL_OW 45
5047: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5048: LD_VAR 0 3
5052: PPUSH
5053: LD_INT 4
5055: PPUSH
5056: CALL_OW 233
// PlaceUnitXY ( veh , 305 , 218 , false ) ;
5060: LD_VAR 0 3
5064: PPUSH
5065: LD_INT 305
5067: PPUSH
5068: LD_INT 218
5070: PPUSH
5071: LD_INT 0
5073: PPUSH
5074: CALL_OW 48
// ComHold ( veh ) ;
5078: LD_VAR 0 3
5082: PPUSH
5083: CALL_OW 140
// CenterNowOnXY ( 313 , 220 ) ;
5087: LD_INT 313
5089: PPUSH
5090: LD_INT 220
5092: PPUSH
5093: CALL_OW 86
// end ; end_of_file
5097: LD_VAR 0 1
5101: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
5102: LD_INT 0
5104: PPUSH
5105: PPUSH
5106: PPUSH
5107: PPUSH
5108: PPUSH
5109: PPUSH
5110: PPUSH
5111: PPUSH
5112: PPUSH
5113: PPUSH
// InitHc ;
5114: CALL_OW 19
// uc_side := 1 ;
5118: LD_ADDR_OWVAR 20
5122: PUSH
5123: LD_INT 1
5125: ST_TO_ADDR
// uc_nation := 1 ;
5126: LD_ADDR_OWVAR 21
5130: PUSH
5131: LD_INT 1
5133: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
5134: LD_ADDR_VAR 0 2
5138: PUSH
5139: LD_INT 22
5141: PUSH
5142: LD_INT 1
5144: PUSH
5145: EMPTY
5146: LIST
5147: LIST
5148: PUSH
5149: LD_INT 21
5151: PUSH
5152: LD_INT 3
5154: PUSH
5155: EMPTY
5156: LIST
5157: LIST
5158: PUSH
5159: EMPTY
5160: LIST
5161: LIST
5162: PPUSH
5163: CALL_OW 69
5167: PUSH
5168: FOR_IN
5169: IFFALSE 5185
// SetBLevel ( i , 10 ) ;
5171: LD_VAR 0 2
5175: PPUSH
5176: LD_INT 10
5178: PPUSH
5179: CALL_OW 241
5183: GO 5168
5185: POP
5186: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 7500 ) ;
5187: LD_INT 387
5189: PPUSH
5190: CALL_OW 274
5194: PPUSH
5195: LD_INT 1
5197: PPUSH
5198: LD_INT 7500
5200: PPUSH
5201: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
5205: LD_INT 387
5207: PPUSH
5208: CALL_OW 274
5212: PPUSH
5213: LD_INT 2
5215: PPUSH
5216: LD_INT 4000
5218: PPUSH
5219: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
5223: LD_INT 387
5225: PPUSH
5226: CALL_OW 274
5230: PPUSH
5231: LD_INT 3
5233: PPUSH
5234: LD_INT 50
5236: PPUSH
5237: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 5500 ) ;
5241: LD_INT 476
5243: PPUSH
5244: CALL_OW 274
5248: PPUSH
5249: LD_INT 1
5251: PPUSH
5252: LD_INT 5500
5254: PPUSH
5255: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
5259: LD_INT 476
5261: PPUSH
5262: CALL_OW 274
5266: PPUSH
5267: LD_INT 2
5269: PPUSH
5270: LD_INT 4000
5272: PPUSH
5273: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
5277: LD_INT 476
5279: PPUSH
5280: CALL_OW 274
5284: PPUSH
5285: LD_INT 3
5287: PPUSH
5288: LD_INT 10
5290: PPUSH
5291: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
5295: LD_ADDR_EXP 55
5299: PUSH
5300: LD_STRING Powell
5302: PPUSH
5303: CALL_OW 25
5307: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
5308: LD_EXP 55
5312: PPUSH
5313: LD_INT 387
5315: PPUSH
5316: CALL_OW 52
// tmp := [ ] ;
5320: LD_ADDR_VAR 0 6
5324: PUSH
5325: EMPTY
5326: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
5327: LD_ADDR_EXP 21
5331: PUSH
5332: LD_STRING Lisa
5334: PPUSH
5335: LD_EXP 1
5339: NOT
5340: PPUSH
5341: LD_STRING 12p_
5343: PPUSH
5344: CALL 52062 0 3
5348: ST_TO_ADDR
// if Lisa then
5349: LD_EXP 21
5353: IFFALSE 5371
// tmp := tmp ^ Lisa ;
5355: LD_ADDR_VAR 0 6
5359: PUSH
5360: LD_VAR 0 6
5364: PUSH
5365: LD_EXP 21
5369: ADD
5370: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
5371: LD_ADDR_EXP 22
5375: PUSH
5376: LD_STRING Donaldson
5378: PPUSH
5379: LD_EXP 1
5383: NOT
5384: PPUSH
5385: LD_STRING 12p_
5387: PPUSH
5388: CALL 52062 0 3
5392: ST_TO_ADDR
// if Donaldson then
5393: LD_EXP 22
5397: IFFALSE 5415
// tmp := tmp ^ Donaldson ;
5399: LD_ADDR_VAR 0 6
5403: PUSH
5404: LD_VAR 0 6
5408: PUSH
5409: LD_EXP 22
5413: ADD
5414: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
5415: LD_ADDR_EXP 23
5419: PUSH
5420: LD_STRING Bobby
5422: PPUSH
5423: LD_EXP 1
5427: NOT
5428: PPUSH
5429: LD_STRING 12p_
5431: PPUSH
5432: CALL 52062 0 3
5436: ST_TO_ADDR
// if Bobby then
5437: LD_EXP 23
5441: IFFALSE 5459
// tmp := tmp ^ Bobby ;
5443: LD_ADDR_VAR 0 6
5447: PUSH
5448: LD_VAR 0 6
5452: PUSH
5453: LD_EXP 23
5457: ADD
5458: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
5459: LD_ADDR_EXP 24
5463: PUSH
5464: LD_STRING Cyrus
5466: PPUSH
5467: LD_EXP 1
5471: NOT
5472: PPUSH
5473: LD_STRING 12p_
5475: PPUSH
5476: CALL 52062 0 3
5480: ST_TO_ADDR
// if Cyrus then
5481: LD_EXP 24
5485: IFFALSE 5503
// tmp := tmp ^ Cyrus ;
5487: LD_ADDR_VAR 0 6
5491: PUSH
5492: LD_VAR 0 6
5496: PUSH
5497: LD_EXP 24
5501: ADD
5502: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
5503: LD_ADDR_EXP 26
5507: PUSH
5508: LD_STRING Brown
5510: PPUSH
5511: LD_EXP 1
5515: NOT
5516: PPUSH
5517: LD_STRING 12p_
5519: PPUSH
5520: CALL 52062 0 3
5524: ST_TO_ADDR
// if Brown then
5525: LD_EXP 26
5529: IFFALSE 5547
// tmp := tmp ^ Brown ;
5531: LD_ADDR_VAR 0 6
5535: PUSH
5536: LD_VAR 0 6
5540: PUSH
5541: LD_EXP 26
5545: ADD
5546: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5547: LD_ADDR_EXP 27
5551: PUSH
5552: LD_STRING Gladstone
5554: PPUSH
5555: LD_EXP 1
5559: NOT
5560: PPUSH
5561: LD_STRING 12p_
5563: PPUSH
5564: CALL 52062 0 3
5568: ST_TO_ADDR
// if Gladstone then
5569: LD_EXP 27
5573: IFFALSE 5591
// tmp := tmp ^ Gladstone ;
5575: LD_ADDR_VAR 0 6
5579: PUSH
5580: LD_VAR 0 6
5584: PUSH
5585: LD_EXP 27
5589: ADD
5590: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5591: LD_ADDR_EXP 28
5595: PUSH
5596: LD_STRING Houten
5598: PPUSH
5599: LD_EXP 1
5603: NOT
5604: PPUSH
5605: LD_STRING 12p_
5607: PPUSH
5608: CALL 52062 0 3
5612: ST_TO_ADDR
// if Houten then
5613: LD_EXP 28
5617: IFFALSE 5635
// tmp := tmp ^ Houten ;
5619: LD_ADDR_VAR 0 6
5623: PUSH
5624: LD_VAR 0 6
5628: PUSH
5629: LD_EXP 28
5633: ADD
5634: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5635: LD_ADDR_EXP 29
5639: PUSH
5640: LD_STRING Cornel
5642: PPUSH
5643: LD_EXP 1
5647: NOT
5648: PPUSH
5649: LD_STRING 12p_
5651: PPUSH
5652: CALL 52062 0 3
5656: ST_TO_ADDR
// if Cornel then
5657: LD_EXP 29
5661: IFFALSE 5679
// tmp := tmp ^ Cornel ;
5663: LD_ADDR_VAR 0 6
5667: PUSH
5668: LD_VAR 0 6
5672: PUSH
5673: LD_EXP 29
5677: ADD
5678: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5679: LD_ADDR_EXP 30
5683: PUSH
5684: LD_STRING Gary
5686: PPUSH
5687: LD_EXP 1
5691: NOT
5692: PPUSH
5693: LD_STRING 12p_
5695: PPUSH
5696: CALL 52062 0 3
5700: ST_TO_ADDR
// if Gary then
5701: LD_EXP 30
5705: IFFALSE 5723
// tmp := tmp ^ Gary ;
5707: LD_ADDR_VAR 0 6
5711: PUSH
5712: LD_VAR 0 6
5716: PUSH
5717: LD_EXP 30
5721: ADD
5722: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5723: LD_ADDR_EXP 32
5727: PUSH
5728: LD_STRING Kikuchi
5730: PPUSH
5731: LD_EXP 1
5735: NOT
5736: PPUSH
5737: LD_STRING 12p_
5739: PPUSH
5740: CALL 52062 0 3
5744: ST_TO_ADDR
// if Kikuchi then
5745: LD_EXP 32
5749: IFFALSE 5767
// tmp := tmp ^ Kikuchi ;
5751: LD_ADDR_VAR 0 6
5755: PUSH
5756: LD_VAR 0 6
5760: PUSH
5761: LD_EXP 32
5765: ADD
5766: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5767: LD_ADDR_VAR 0 6
5771: PUSH
5772: LD_VAR 0 6
5776: PUSH
5777: LD_STRING 12p_others
5779: PPUSH
5780: CALL_OW 31
5784: UNION
5785: ST_TO_ADDR
// if tmp < 36 then
5786: LD_VAR 0 6
5790: PUSH
5791: LD_INT 36
5793: LESS
5794: IFFALSE 5861
// for i = 1 to 36 - tmp do
5796: LD_ADDR_VAR 0 2
5800: PUSH
5801: DOUBLE
5802: LD_INT 1
5804: DEC
5805: ST_TO_ADDR
5806: LD_INT 36
5808: PUSH
5809: LD_VAR 0 6
5813: MINUS
5814: PUSH
5815: FOR_TO
5816: IFFALSE 5859
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5818: LD_INT 1
5820: PPUSH
5821: LD_VAR 0 2
5825: PUSH
5826: LD_INT 4
5828: MOD
5829: PUSH
5830: LD_INT 1
5832: PLUS
5833: PPUSH
5834: LD_INT 10
5836: PPUSH
5837: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5841: LD_ADDR_VAR 0 6
5845: PUSH
5846: LD_VAR 0 6
5850: PUSH
5851: CALL_OW 44
5855: ADD
5856: ST_TO_ADDR
// end ;
5857: GO 5815
5859: POP
5860: POP
// for i in tmp do
5861: LD_ADDR_VAR 0 2
5865: PUSH
5866: LD_VAR 0 6
5870: PUSH
5871: FOR_IN
5872: IFFALSE 5897
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5874: LD_VAR 0 2
5878: PPUSH
5879: LD_INT 62
5881: PPUSH
5882: LD_INT 93
5884: PPUSH
5885: LD_INT 9
5887: PPUSH
5888: LD_INT 0
5890: PPUSH
5891: CALL_OW 50
5895: GO 5871
5897: POP
5898: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
5899: LD_ADDR_EXP 77
5903: PUSH
5904: LD_EXP 77
5908: PPUSH
5909: LD_INT 4
5911: PPUSH
5912: LD_INT 22
5914: PUSH
5915: LD_INT 1
5917: PUSH
5918: EMPTY
5919: LIST
5920: LIST
5921: PPUSH
5922: CALL_OW 69
5926: PUSH
5927: LD_EXP 55
5931: DIFF
5932: PPUSH
5933: CALL_OW 1
5937: ST_TO_ADDR
// uc_side := 0 ;
5938: LD_ADDR_OWVAR 20
5942: PUSH
5943: LD_INT 0
5945: ST_TO_ADDR
// uc_nation := 0 ;
5946: LD_ADDR_OWVAR 21
5950: PUSH
5951: LD_INT 0
5953: ST_TO_ADDR
// for i = 1 to 4 do
5954: LD_ADDR_VAR 0 2
5958: PUSH
5959: DOUBLE
5960: LD_INT 1
5962: DEC
5963: ST_TO_ADDR
5964: LD_INT 4
5966: PUSH
5967: FOR_TO
5968: IFFALSE 5999
// begin InitHc ;
5970: CALL_OW 19
// hc_class := class_apeman ;
5974: LD_ADDR_OWVAR 28
5978: PUSH
5979: LD_INT 12
5981: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
5982: CALL_OW 44
5986: PPUSH
5987: LD_INT 11
5989: PPUSH
5990: LD_INT 0
5992: PPUSH
5993: CALL_OW 49
// end ;
5997: GO 5967
5999: POP
6000: POP
// end ;
6001: LD_VAR 0 1
6005: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
6006: LD_EXP 4
6010: NOT
6011: PUSH
6012: LD_INT 4
6014: PPUSH
6015: LD_INT 1
6017: PPUSH
6018: CALL 47054 0 2
6022: NOT
6023: AND
6024: IFFALSE 6796
6026: GO 6028
6028: DISABLE
6029: LD_INT 0
6031: PPUSH
6032: PPUSH
6033: PPUSH
// begin enable ;
6034: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
6035: LD_INT 22
6037: PUSH
6038: LD_INT 1
6040: PUSH
6041: EMPTY
6042: LIST
6043: LIST
6044: PUSH
6045: LD_INT 23
6047: PUSH
6048: LD_INT 1
6050: PUSH
6051: EMPTY
6052: LIST
6053: LIST
6054: PUSH
6055: LD_INT 30
6057: PUSH
6058: LD_INT 3
6060: PUSH
6061: EMPTY
6062: LIST
6063: LIST
6064: PUSH
6065: EMPTY
6066: LIST
6067: LIST
6068: LIST
6069: PPUSH
6070: CALL_OW 69
6074: NOT
6075: IFFALSE 6079
// exit ;
6077: GO 6796
// if Prob ( 40 ) then
6079: LD_INT 40
6081: PPUSH
6082: CALL_OW 13
6086: IFFALSE 6213
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6088: LD_INT 4
6090: PPUSH
6091: LD_INT 5
6093: PUSH
6094: LD_INT 1
6096: PUSH
6097: LD_INT 2
6099: PUSH
6100: LD_INT 7
6102: PUSH
6103: EMPTY
6104: LIST
6105: LIST
6106: LIST
6107: LIST
6108: PUSH
6109: LD_INT 5
6111: PUSH
6112: LD_INT 1
6114: PUSH
6115: LD_INT 2
6117: PUSH
6118: LD_INT 7
6120: PUSH
6121: EMPTY
6122: LIST
6123: LIST
6124: LIST
6125: LIST
6126: PUSH
6127: LD_INT 5
6129: PUSH
6130: LD_INT 1
6132: PUSH
6133: LD_INT 2
6135: PUSH
6136: LD_INT 7
6138: PUSH
6139: EMPTY
6140: LIST
6141: LIST
6142: LIST
6143: LIST
6144: PUSH
6145: LD_INT 5
6147: PUSH
6148: LD_INT 1
6150: PUSH
6151: LD_INT 2
6153: PUSH
6154: LD_INT 6
6156: PUSH
6157: EMPTY
6158: LIST
6159: LIST
6160: LIST
6161: LIST
6162: PUSH
6163: LD_INT 5
6165: PUSH
6166: LD_INT 1
6168: PUSH
6169: LD_INT 2
6171: PUSH
6172: LD_INT 6
6174: PUSH
6175: EMPTY
6176: LIST
6177: LIST
6178: LIST
6179: LIST
6180: PUSH
6181: LD_INT 5
6183: PUSH
6184: LD_INT 1
6186: PUSH
6187: LD_INT 2
6189: PUSH
6190: LD_INT 6
6192: PUSH
6193: EMPTY
6194: LIST
6195: LIST
6196: LIST
6197: LIST
6198: PUSH
6199: EMPTY
6200: LIST
6201: LIST
6202: LIST
6203: LIST
6204: LIST
6205: LIST
6206: PPUSH
6207: CALL 45636 0 2
// end else
6211: GO 6336
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6213: LD_INT 4
6215: PPUSH
6216: LD_INT 5
6218: PUSH
6219: LD_INT 1
6221: PUSH
6222: LD_INT 2
6224: PUSH
6225: LD_INT 7
6227: PUSH
6228: EMPTY
6229: LIST
6230: LIST
6231: LIST
6232: LIST
6233: PUSH
6234: LD_INT 5
6236: PUSH
6237: LD_INT 1
6239: PUSH
6240: LD_INT 2
6242: PUSH
6243: LD_INT 9
6245: PUSH
6246: EMPTY
6247: LIST
6248: LIST
6249: LIST
6250: LIST
6251: PUSH
6252: LD_INT 5
6254: PUSH
6255: LD_INT 1
6257: PUSH
6258: LD_INT 2
6260: PUSH
6261: LD_INT 9
6263: PUSH
6264: EMPTY
6265: LIST
6266: LIST
6267: LIST
6268: LIST
6269: PUSH
6270: LD_INT 5
6272: PUSH
6273: LD_INT 1
6275: PUSH
6276: LD_INT 2
6278: PUSH
6279: LD_INT 6
6281: PUSH
6282: EMPTY
6283: LIST
6284: LIST
6285: LIST
6286: LIST
6287: PUSH
6288: LD_INT 5
6290: PUSH
6291: LD_INT 1
6293: PUSH
6294: LD_INT 2
6296: PUSH
6297: LD_INT 6
6299: PUSH
6300: EMPTY
6301: LIST
6302: LIST
6303: LIST
6304: LIST
6305: PUSH
6306: LD_INT 5
6308: PUSH
6309: LD_INT 1
6311: PUSH
6312: LD_INT 2
6314: PUSH
6315: LD_INT 6
6317: PUSH
6318: EMPTY
6319: LIST
6320: LIST
6321: LIST
6322: LIST
6323: PUSH
6324: EMPTY
6325: LIST
6326: LIST
6327: LIST
6328: LIST
6329: LIST
6330: LIST
6331: PPUSH
6332: CALL 45636 0 2
// end ; repeat wait ( 0 0$1 ) ;
6336: LD_INT 35
6338: PPUSH
6339: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
6343: LD_INT 4
6345: PPUSH
6346: LD_INT 1
6348: PPUSH
6349: CALL 47054 0 2
6353: PUSH
6354: LD_INT 6
6356: GREATEREQUAL
6357: IFFALSE 6336
// wait ( 0 0$30 ) ;
6359: LD_INT 1050
6361: PPUSH
6362: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
6366: LD_ADDR_VAR 0 2
6370: PUSH
6371: LD_INT 4
6373: PPUSH
6374: LD_INT 1
6376: PPUSH
6377: CALL 47054 0 2
6381: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
6382: LD_ADDR_EXP 96
6386: PUSH
6387: LD_EXP 96
6391: PPUSH
6392: LD_INT 4
6394: PPUSH
6395: LD_EXP 96
6399: PUSH
6400: LD_INT 4
6402: ARRAY
6403: PUSH
6404: LD_VAR 0 2
6408: DIFF
6409: PPUSH
6410: CALL_OW 1
6414: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6415: LD_ADDR_VAR 0 3
6419: PUSH
6420: LD_INT 0
6422: PPUSH
6423: LD_INT 2
6425: PPUSH
6426: CALL_OW 12
6430: ST_TO_ADDR
// if target then
6431: LD_VAR 0 3
6435: IFFALSE 6563
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6437: LD_ADDR_VAR 0 2
6441: PUSH
6442: LD_VAR 0 2
6446: PPUSH
6447: LD_INT 24
6449: PUSH
6450: LD_INT 250
6452: PUSH
6453: EMPTY
6454: LIST
6455: LIST
6456: PPUSH
6457: CALL_OW 72
6461: ST_TO_ADDR
// for i in tmp do
6462: LD_ADDR_VAR 0 1
6466: PUSH
6467: LD_VAR 0 2
6471: PUSH
6472: FOR_IN
6473: IFFALSE 6513
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
6475: LD_VAR 0 1
6479: PPUSH
6480: LD_INT 114
6482: PPUSH
6483: LD_INT 108
6485: PPUSH
6486: CALL_OW 297
6490: PUSH
6491: LD_INT 9
6493: GREATER
6494: IFFALSE 6511
// ComMoveXY ( i , 114 , 108 ) ;
6496: LD_VAR 0 1
6500: PPUSH
6501: LD_INT 114
6503: PPUSH
6504: LD_INT 108
6506: PPUSH
6507: CALL_OW 111
6511: GO 6472
6513: POP
6514: POP
// wait ( 0 0$1 ) ;
6515: LD_INT 35
6517: PPUSH
6518: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
6522: LD_VAR 0 2
6526: PPUSH
6527: LD_INT 92
6529: PUSH
6530: LD_INT 114
6532: PUSH
6533: LD_INT 108
6535: PUSH
6536: LD_INT 9
6538: PUSH
6539: EMPTY
6540: LIST
6541: LIST
6542: LIST
6543: LIST
6544: PPUSH
6545: CALL_OW 72
6549: PUSH
6550: LD_VAR 0 2
6554: PUSH
6555: LD_INT 1
6557: MINUS
6558: GREATEREQUAL
6559: IFFALSE 6437
// end else
6561: GO 6687
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6563: LD_ADDR_VAR 0 2
6567: PUSH
6568: LD_VAR 0 2
6572: PPUSH
6573: LD_INT 24
6575: PUSH
6576: LD_INT 250
6578: PUSH
6579: EMPTY
6580: LIST
6581: LIST
6582: PPUSH
6583: CALL_OW 72
6587: ST_TO_ADDR
// for i in tmp do
6588: LD_ADDR_VAR 0 1
6592: PUSH
6593: LD_VAR 0 2
6597: PUSH
6598: FOR_IN
6599: IFFALSE 6639
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6601: LD_VAR 0 1
6605: PPUSH
6606: LD_INT 129
6608: PPUSH
6609: LD_INT 139
6611: PPUSH
6612: CALL_OW 297
6616: PUSH
6617: LD_INT 9
6619: GREATER
6620: IFFALSE 6637
// ComMoveXY ( i , 129 , 139 ) ;
6622: LD_VAR 0 1
6626: PPUSH
6627: LD_INT 129
6629: PPUSH
6630: LD_INT 139
6632: PPUSH
6633: CALL_OW 111
6637: GO 6598
6639: POP
6640: POP
// wait ( 0 0$1 ) ;
6641: LD_INT 35
6643: PPUSH
6644: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
6648: LD_VAR 0 2
6652: PPUSH
6653: LD_INT 92
6655: PUSH
6656: LD_INT 129
6658: PUSH
6659: LD_INT 139
6661: PUSH
6662: LD_INT 9
6664: PUSH
6665: EMPTY
6666: LIST
6667: LIST
6668: LIST
6669: LIST
6670: PPUSH
6671: CALL_OW 72
6675: PUSH
6676: LD_VAR 0 2
6680: PUSH
6681: LD_INT 1
6683: MINUS
6684: GREATEREQUAL
6685: IFFALSE 6563
// end ; repeat wait ( 0 0$1 ) ;
6687: LD_INT 35
6689: PPUSH
6690: CALL_OW 67
// for i in tmp do
6694: LD_ADDR_VAR 0 1
6698: PUSH
6699: LD_VAR 0 2
6703: PUSH
6704: FOR_IN
6705: IFFALSE 6787
// begin if GetLives ( i ) > 251 then
6707: LD_VAR 0 1
6711: PPUSH
6712: CALL_OW 256
6716: PUSH
6717: LD_INT 251
6719: GREATER
6720: IFFALSE 6758
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6722: LD_VAR 0 1
6726: PPUSH
6727: LD_INT 81
6729: PUSH
6730: LD_INT 1
6732: PUSH
6733: EMPTY
6734: LIST
6735: LIST
6736: PPUSH
6737: CALL_OW 69
6741: PPUSH
6742: LD_VAR 0 1
6746: PPUSH
6747: CALL_OW 74
6751: PPUSH
6752: CALL_OW 115
6756: GO 6785
// if IsDead ( i ) then
6758: LD_VAR 0 1
6762: PPUSH
6763: CALL_OW 301
6767: IFFALSE 6785
// tmp := tmp diff i ;
6769: LD_ADDR_VAR 0 2
6773: PUSH
6774: LD_VAR 0 2
6778: PUSH
6779: LD_VAR 0 1
6783: DIFF
6784: ST_TO_ADDR
// end ;
6785: GO 6704
6787: POP
6788: POP
// until not tmp ;
6789: LD_VAR 0 2
6793: NOT
6794: IFFALSE 6687
// end ;
6796: PPOPN 3
6798: END
// every 30 30$00 trigger not americanDestroyed do
6799: LD_EXP 4
6803: NOT
6804: IFFALSE 6873
6806: GO 6808
6808: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 15 15$00 , 10 10$00 ] [ Difficulty ] ) ;
6809: LD_INT 63000
6811: PUSH
6812: LD_INT 42000
6814: PUSH
6815: LD_INT 31500
6817: PUSH
6818: LD_INT 21000
6820: PUSH
6821: EMPTY
6822: LIST
6823: LIST
6824: LIST
6825: LIST
6826: PUSH
6827: LD_OWVAR 67
6831: ARRAY
6832: PPUSH
6833: CALL_OW 67
// if americanDestroyed then
6837: LD_EXP 4
6841: IFFALSE 6845
// exit ;
6843: GO 6873
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6845: LD_INT 4
6847: PPUSH
6848: LD_INT 5
6850: PUSH
6851: LD_INT 3
6853: PUSH
6854: LD_INT 1
6856: PUSH
6857: LD_INT 8
6859: PUSH
6860: EMPTY
6861: LIST
6862: LIST
6863: LIST
6864: LIST
6865: PUSH
6866: EMPTY
6867: LIST
6868: PPUSH
6869: CALL 45636 0 2
// end ; end_of_file
6873: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6874: LD_INT 0
6876: PPUSH
6877: PPUSH
6878: PPUSH
6879: PPUSH
6880: PPUSH
// side := 2 ;
6881: LD_ADDR_VAR 0 5
6885: PUSH
6886: LD_INT 2
6888: ST_TO_ADDR
// InitHc ;
6889: CALL_OW 19
// uc_side := side ;
6893: LD_ADDR_OWVAR 20
6897: PUSH
6898: LD_VAR 0 5
6902: ST_TO_ADDR
// uc_nation := 2 ;
6903: LD_ADDR_OWVAR 21
6907: PUSH
6908: LD_INT 2
6910: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
6911: LD_ADDR_VAR 0 2
6915: PUSH
6916: LD_INT 22
6918: PUSH
6919: LD_INT 2
6921: PUSH
6922: EMPTY
6923: LIST
6924: LIST
6925: PUSH
6926: LD_INT 21
6928: PUSH
6929: LD_INT 3
6931: PUSH
6932: EMPTY
6933: LIST
6934: LIST
6935: PUSH
6936: EMPTY
6937: LIST
6938: LIST
6939: PPUSH
6940: CALL_OW 69
6944: PUSH
6945: FOR_IN
6946: IFFALSE 6962
// SetBLevel ( i , 10 ) ;
6948: LD_VAR 0 2
6952: PPUSH
6953: LD_INT 10
6955: PPUSH
6956: CALL_OW 241
6960: GO 6945
6962: POP
6963: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6964: LD_ADDR_VAR 0 4
6968: PUSH
6969: LD_INT 22
6971: PUSH
6972: LD_VAR 0 5
6976: PUSH
6977: EMPTY
6978: LIST
6979: LIST
6980: PUSH
6981: LD_INT 30
6983: PUSH
6984: LD_INT 32
6986: PUSH
6987: EMPTY
6988: LIST
6989: LIST
6990: PUSH
6991: LD_INT 58
6993: PUSH
6994: EMPTY
6995: LIST
6996: PUSH
6997: EMPTY
6998: LIST
6999: LIST
7000: LIST
7001: PPUSH
7002: CALL_OW 69
7006: ST_TO_ADDR
// for i = 1 to 10 do
7007: LD_ADDR_VAR 0 2
7011: PUSH
7012: DOUBLE
7013: LD_INT 1
7015: DEC
7016: ST_TO_ADDR
7017: LD_INT 10
7019: PUSH
7020: FOR_TO
7021: IFFALSE 7093
// begin uc_nation := nation_nature ;
7023: LD_ADDR_OWVAR 21
7027: PUSH
7028: LD_INT 0
7030: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7031: LD_ADDR_OWVAR 28
7035: PUSH
7036: LD_INT 15
7038: ST_TO_ADDR
// hc_gallery :=  ;
7039: LD_ADDR_OWVAR 33
7043: PUSH
7044: LD_STRING 
7046: ST_TO_ADDR
// hc_name :=  ;
7047: LD_ADDR_OWVAR 26
7051: PUSH
7052: LD_STRING 
7054: ST_TO_ADDR
// un := CreateHuman ;
7055: LD_ADDR_VAR 0 3
7059: PUSH
7060: CALL_OW 44
7064: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7065: LD_VAR 0 3
7069: PPUSH
7070: LD_VAR 0 4
7074: PUSH
7075: LD_VAR 0 4
7079: PUSH
7080: LD_VAR 0 2
7084: MINUS
7085: ARRAY
7086: PPUSH
7087: CALL_OW 52
// end ;
7091: GO 7020
7093: POP
7094: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
7095: LD_INT 503
7097: PPUSH
7098: LD_INT 27
7100: PPUSH
7101: LD_STRING 
7103: PPUSH
7104: LD_INT 8
7106: PUSH
7107: LD_INT 9
7109: PUSH
7110: LD_INT 10
7112: PUSH
7113: LD_INT 10
7115: PUSH
7116: EMPTY
7117: LIST
7118: LIST
7119: LIST
7120: LIST
7121: PUSH
7122: LD_OWVAR 67
7126: ARRAY
7127: PPUSH
7128: LD_INT 3000
7130: PUSH
7131: LD_INT 500
7133: PUSH
7134: LD_INT 150
7136: PUSH
7137: EMPTY
7138: LIST
7139: LIST
7140: LIST
7141: PPUSH
7142: LD_INT 16
7144: PUSH
7145: LD_INT 6
7147: PUSH
7148: LD_INT 6
7150: PUSH
7151: LD_INT 6
7153: PUSH
7154: EMPTY
7155: LIST
7156: LIST
7157: LIST
7158: LIST
7159: PPUSH
7160: CALL 60521 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
7164: LD_ADDR_EXP 77
7168: PUSH
7169: LD_EXP 77
7173: PPUSH
7174: LD_INT 1
7176: PPUSH
7177: LD_INT 22
7179: PUSH
7180: LD_VAR 0 5
7184: PUSH
7185: EMPTY
7186: LIST
7187: LIST
7188: PUSH
7189: LD_INT 23
7191: PUSH
7192: LD_INT 2
7194: PUSH
7195: EMPTY
7196: LIST
7197: LIST
7198: PUSH
7199: LD_INT 3
7201: PUSH
7202: LD_INT 21
7204: PUSH
7205: LD_INT 2
7207: PUSH
7208: EMPTY
7209: LIST
7210: LIST
7211: PUSH
7212: EMPTY
7213: LIST
7214: LIST
7215: PUSH
7216: EMPTY
7217: LIST
7218: LIST
7219: LIST
7220: PPUSH
7221: CALL_OW 69
7225: PPUSH
7226: CALL_OW 1
7230: ST_TO_ADDR
// HiddenCamera ( 216 , 228 , 2 ) ;
7231: LD_INT 216
7233: PPUSH
7234: LD_INT 228
7236: PPUSH
7237: LD_INT 2
7239: PPUSH
7240: CALL_OW 244
// HiddenCamera ( 223 , 241 , 2 ) ;
7244: LD_INT 223
7246: PPUSH
7247: LD_INT 241
7249: PPUSH
7250: LD_INT 2
7252: PPUSH
7253: CALL_OW 244
// HiddenCamera ( 216 , 217 , 2 ) ;
7257: LD_INT 216
7259: PPUSH
7260: LD_INT 217
7262: PPUSH
7263: LD_INT 2
7265: PPUSH
7266: CALL_OW 244
// HiddenCamera ( 233 , 257 , 2 ) ;
7270: LD_INT 233
7272: PPUSH
7273: LD_INT 257
7275: PPUSH
7276: LD_INT 2
7278: PPUSH
7279: CALL_OW 244
// HiddenCamera ( 230 , 199 , 2 ) ;
7283: LD_INT 230
7285: PPUSH
7286: LD_INT 199
7288: PPUSH
7289: LD_INT 2
7291: PPUSH
7292: CALL_OW 244
// end ;
7296: LD_VAR 0 1
7300: RET
// export Omar ; export function PrepareOmarAli ; begin
7301: LD_INT 0
7303: PPUSH
// uc_side := 5 ;
7304: LD_ADDR_OWVAR 20
7308: PUSH
7309: LD_INT 5
7311: ST_TO_ADDR
// uc_nation := 2 ;
7312: LD_ADDR_OWVAR 21
7316: PUSH
7317: LD_INT 2
7319: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
7320: LD_ADDR_EXP 56
7324: PUSH
7325: LD_STRING Omar
7327: PPUSH
7328: CALL_OW 25
7332: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
7333: LD_EXP 56
7337: PPUSH
7338: LD_INT 330
7340: PPUSH
7341: LD_INT 244
7343: PPUSH
7344: LD_INT 0
7346: PPUSH
7347: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
7351: LD_EXP 56
7355: PPUSH
7356: LD_INT 252
7358: PPUSH
7359: LD_INT 220
7361: PPUSH
7362: CALL_OW 111
// end ; end_of_file
7366: LD_VAR 0 1
7370: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
7371: LD_INT 0
7373: PPUSH
7374: PPUSH
7375: PPUSH
7376: PPUSH
7377: PPUSH
// side := 8 ;
7378: LD_ADDR_VAR 0 3
7382: PUSH
7383: LD_INT 8
7385: ST_TO_ADDR
// InitHc ;
7386: CALL_OW 19
// uc_side := side ;
7390: LD_ADDR_OWVAR 20
7394: PUSH
7395: LD_VAR 0 3
7399: ST_TO_ADDR
// uc_nation := 2 ;
7400: LD_ADDR_OWVAR 21
7404: PUSH
7405: LD_INT 2
7407: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7408: LD_ADDR_VAR 0 2
7412: PUSH
7413: LD_INT 22
7415: PUSH
7416: LD_VAR 0 3
7420: PUSH
7421: EMPTY
7422: LIST
7423: LIST
7424: PUSH
7425: LD_INT 21
7427: PUSH
7428: LD_INT 3
7430: PUSH
7431: EMPTY
7432: LIST
7433: LIST
7434: PUSH
7435: EMPTY
7436: LIST
7437: LIST
7438: PPUSH
7439: CALL_OW 69
7443: PUSH
7444: FOR_IN
7445: IFFALSE 7461
// SetBLevel ( i , 10 ) ;
7447: LD_VAR 0 2
7451: PPUSH
7452: LD_INT 10
7454: PPUSH
7455: CALL_OW 241
7459: GO 7444
7461: POP
7462: POP
// Schulz := NewCharacter ( Schulz ) ;
7463: LD_ADDR_EXP 57
7467: PUSH
7468: LD_STRING Schulz
7470: PPUSH
7471: CALL_OW 25
7475: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
7476: LD_ADDR_EXP 58
7480: PUSH
7481: LD_STRING Kozlov
7483: PPUSH
7484: LD_INT 0
7486: PPUSH
7487: LD_STRING 
7489: PPUSH
7490: CALL 52062 0 3
7494: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
7495: LD_EXP 58
7499: PPUSH
7500: LD_INT 22
7502: PUSH
7503: LD_INT 8
7505: PUSH
7506: EMPTY
7507: LIST
7508: LIST
7509: PUSH
7510: LD_INT 23
7512: PUSH
7513: LD_INT 3
7515: PUSH
7516: EMPTY
7517: LIST
7518: LIST
7519: PUSH
7520: LD_INT 30
7522: PUSH
7523: LD_INT 8
7525: PUSH
7526: EMPTY
7527: LIST
7528: LIST
7529: PUSH
7530: EMPTY
7531: LIST
7532: LIST
7533: LIST
7534: PPUSH
7535: CALL_OW 69
7539: PUSH
7540: LD_INT 1
7542: ARRAY
7543: PPUSH
7544: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
7548: LD_EXP 58
7552: PPUSH
7553: LD_INT 3
7555: PPUSH
7556: LD_INT 10
7558: PPUSH
7559: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7563: LD_ADDR_VAR 0 5
7567: PUSH
7568: LD_INT 22
7570: PUSH
7571: LD_VAR 0 3
7575: PUSH
7576: EMPTY
7577: LIST
7578: LIST
7579: PUSH
7580: LD_INT 30
7582: PUSH
7583: LD_INT 32
7585: PUSH
7586: EMPTY
7587: LIST
7588: LIST
7589: PUSH
7590: LD_INT 58
7592: PUSH
7593: EMPTY
7594: LIST
7595: PUSH
7596: EMPTY
7597: LIST
7598: LIST
7599: LIST
7600: PPUSH
7601: CALL_OW 69
7605: ST_TO_ADDR
// for i = 1 to 10 do
7606: LD_ADDR_VAR 0 2
7610: PUSH
7611: DOUBLE
7612: LD_INT 1
7614: DEC
7615: ST_TO_ADDR
7616: LD_INT 10
7618: PUSH
7619: FOR_TO
7620: IFFALSE 7692
// begin uc_nation := nation_nature ;
7622: LD_ADDR_OWVAR 21
7626: PUSH
7627: LD_INT 0
7629: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7630: LD_ADDR_OWVAR 28
7634: PUSH
7635: LD_INT 15
7637: ST_TO_ADDR
// hc_gallery :=  ;
7638: LD_ADDR_OWVAR 33
7642: PUSH
7643: LD_STRING 
7645: ST_TO_ADDR
// hc_name :=  ;
7646: LD_ADDR_OWVAR 26
7650: PUSH
7651: LD_STRING 
7653: ST_TO_ADDR
// un := CreateHuman ;
7654: LD_ADDR_VAR 0 4
7658: PUSH
7659: CALL_OW 44
7663: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7664: LD_VAR 0 4
7668: PPUSH
7669: LD_VAR 0 5
7673: PUSH
7674: LD_VAR 0 5
7678: PUSH
7679: LD_VAR 0 2
7683: MINUS
7684: ARRAY
7685: PPUSH
7686: CALL_OW 52
// end ;
7690: GO 7619
7692: POP
7693: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
7694: LD_INT 324
7696: PPUSH
7697: LD_INT 3
7699: PPUSH
7700: LD_STRING 
7702: PPUSH
7703: LD_INT 8
7705: PUSH
7706: LD_INT 9
7708: PUSH
7709: LD_INT 10
7711: PUSH
7712: LD_INT 10
7714: PUSH
7715: EMPTY
7716: LIST
7717: LIST
7718: LIST
7719: LIST
7720: PUSH
7721: LD_OWVAR 67
7725: ARRAY
7726: PPUSH
7727: LD_INT 3000
7729: PUSH
7730: LD_INT 500
7732: PUSH
7733: LD_INT 150
7735: PUSH
7736: EMPTY
7737: LIST
7738: LIST
7739: LIST
7740: PPUSH
7741: LD_INT 16
7743: PUSH
7744: LD_INT 6
7746: PUSH
7747: LD_INT 6
7749: PUSH
7750: LD_INT 8
7752: PUSH
7753: EMPTY
7754: LIST
7755: LIST
7756: LIST
7757: LIST
7758: PPUSH
7759: CALL 60521 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
7763: LD_ADDR_EXP 77
7767: PUSH
7768: LD_EXP 77
7772: PPUSH
7773: LD_INT 3
7775: PPUSH
7776: LD_INT 22
7778: PUSH
7779: LD_VAR 0 3
7783: PUSH
7784: EMPTY
7785: LIST
7786: LIST
7787: PUSH
7788: LD_INT 23
7790: PUSH
7791: LD_INT 2
7793: PUSH
7794: EMPTY
7795: LIST
7796: LIST
7797: PUSH
7798: LD_INT 3
7800: PUSH
7801: LD_INT 21
7803: PUSH
7804: LD_INT 2
7806: PUSH
7807: EMPTY
7808: LIST
7809: LIST
7810: PUSH
7811: EMPTY
7812: LIST
7813: LIST
7814: PUSH
7815: EMPTY
7816: LIST
7817: LIST
7818: LIST
7819: PPUSH
7820: CALL_OW 69
7824: PUSH
7825: LD_EXP 57
7829: DIFF
7830: PPUSH
7831: CALL_OW 1
7835: ST_TO_ADDR
// end ;
7836: LD_VAR 0 1
7840: RET
// export function BuildKozlovBomb ; begin
7841: LD_INT 0
7843: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7844: LD_INT 332
7846: PPUSH
7847: CALL_OW 302
7851: NOT
7852: PUSH
7853: LD_INT 336
7855: PPUSH
7856: CALL_OW 302
7860: NOT
7861: OR
7862: IFFALSE 7866
// exit ;
7864: GO 7963
// ComChangeProfession ( Kozlov , 4 ) ;
7866: LD_EXP 58
7870: PPUSH
7871: LD_INT 4
7873: PPUSH
7874: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7878: LD_INT 336
7880: PPUSH
7881: LD_INT 25
7883: PPUSH
7884: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7888: LD_INT 35
7890: PPUSH
7891: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7895: LD_INT 25
7897: PPUSH
7898: LD_INT 8
7900: PPUSH
7901: CALL_OW 321
7905: PUSH
7906: LD_INT 2
7908: EQUAL
7909: IFFALSE 7888
// ComExitBuilding ( Kozlov ) ;
7911: LD_EXP 58
7915: PPUSH
7916: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
7920: LD_EXP 58
7924: PPUSH
7925: LD_INT 332
7927: PPUSH
7928: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
7932: LD_EXP 58
7936: PPUSH
7937: LD_INT 3
7939: PPUSH
7940: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
7944: LD_INT 332
7946: PPUSH
7947: LD_INT 23
7949: PPUSH
7950: LD_INT 3
7952: PPUSH
7953: LD_INT 1
7955: PPUSH
7956: LD_INT 48
7958: PPUSH
7959: CALL_OW 125
// end ;
7963: LD_VAR 0 1
7967: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
7968: LD_EXP 3
7972: NOT
7973: PUSH
7974: LD_INT 3
7976: PPUSH
7977: LD_INT 1
7979: PPUSH
7980: CALL 47054 0 2
7984: NOT
7985: AND
7986: IFFALSE 8842
7988: GO 7990
7990: DISABLE
7991: LD_INT 0
7993: PPUSH
7994: PPUSH
7995: PPUSH
// begin enable ;
7996: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
7997: LD_INT 22
7999: PUSH
8000: LD_INT 8
8002: PUSH
8003: EMPTY
8004: LIST
8005: LIST
8006: PUSH
8007: LD_INT 23
8009: PUSH
8010: LD_INT 2
8012: PUSH
8013: EMPTY
8014: LIST
8015: LIST
8016: PUSH
8017: LD_INT 30
8019: PUSH
8020: LD_INT 3
8022: PUSH
8023: EMPTY
8024: LIST
8025: LIST
8026: PUSH
8027: EMPTY
8028: LIST
8029: LIST
8030: LIST
8031: PPUSH
8032: CALL_OW 69
8036: NOT
8037: IFFALSE 8041
// exit ;
8039: GO 8842
// if Prob ( 40 ) then
8041: LD_INT 40
8043: PPUSH
8044: CALL_OW 13
8048: IFFALSE 8175
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
8050: LD_INT 3
8052: PPUSH
8053: LD_INT 14
8055: PUSH
8056: LD_INT 1
8058: PUSH
8059: LD_INT 2
8061: PUSH
8062: LD_INT 28
8064: PUSH
8065: EMPTY
8066: LIST
8067: LIST
8068: LIST
8069: LIST
8070: PUSH
8071: LD_INT 14
8073: PUSH
8074: LD_INT 1
8076: PUSH
8077: LD_INT 2
8079: PUSH
8080: LD_INT 28
8082: PUSH
8083: EMPTY
8084: LIST
8085: LIST
8086: LIST
8087: LIST
8088: PUSH
8089: LD_INT 14
8091: PUSH
8092: LD_INT 1
8094: PUSH
8095: LD_INT 2
8097: PUSH
8098: LD_INT 28
8100: PUSH
8101: EMPTY
8102: LIST
8103: LIST
8104: LIST
8105: LIST
8106: PUSH
8107: LD_INT 14
8109: PUSH
8110: LD_INT 1
8112: PUSH
8113: LD_INT 2
8115: PUSH
8116: LD_INT 28
8118: PUSH
8119: EMPTY
8120: LIST
8121: LIST
8122: LIST
8123: LIST
8124: PUSH
8125: LD_INT 14
8127: PUSH
8128: LD_INT 1
8130: PUSH
8131: LD_INT 2
8133: PUSH
8134: LD_INT 28
8136: PUSH
8137: EMPTY
8138: LIST
8139: LIST
8140: LIST
8141: LIST
8142: PUSH
8143: LD_INT 14
8145: PUSH
8146: LD_INT 1
8148: PUSH
8149: LD_INT 2
8151: PUSH
8152: LD_INT 26
8154: PUSH
8155: EMPTY
8156: LIST
8157: LIST
8158: LIST
8159: LIST
8160: PUSH
8161: EMPTY
8162: LIST
8163: LIST
8164: LIST
8165: LIST
8166: LIST
8167: LIST
8168: PPUSH
8169: CALL 45636 0 2
// end else
8173: GO 8382
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
8175: LD_INT 3
8177: PPUSH
8178: LD_INT 14
8180: PUSH
8181: LD_INT 1
8183: PUSH
8184: LD_INT 2
8186: PUSH
8187: LD_INT 27
8189: PUSH
8190: LD_INT 26
8192: PUSH
8193: LD_INT 26
8195: PUSH
8196: LD_INT 28
8198: PUSH
8199: EMPTY
8200: LIST
8201: LIST
8202: LIST
8203: LIST
8204: PUSH
8205: LD_OWVAR 67
8209: ARRAY
8210: PUSH
8211: EMPTY
8212: LIST
8213: LIST
8214: LIST
8215: LIST
8216: PUSH
8217: LD_INT 14
8219: PUSH
8220: LD_INT 1
8222: PUSH
8223: LD_INT 2
8225: PUSH
8226: LD_INT 27
8228: PUSH
8229: LD_INT 26
8231: PUSH
8232: LD_INT 26
8234: PUSH
8235: LD_INT 26
8237: PUSH
8238: EMPTY
8239: LIST
8240: LIST
8241: LIST
8242: LIST
8243: PUSH
8244: LD_OWVAR 67
8248: ARRAY
8249: PUSH
8250: EMPTY
8251: LIST
8252: LIST
8253: LIST
8254: LIST
8255: PUSH
8256: LD_INT 14
8258: PUSH
8259: LD_INT 1
8261: PUSH
8262: LD_INT 2
8264: PUSH
8265: LD_INT 26
8267: PUSH
8268: LD_INT 26
8270: PUSH
8271: LD_INT 29
8273: PUSH
8274: LD_INT 29
8276: PUSH
8277: EMPTY
8278: LIST
8279: LIST
8280: LIST
8281: LIST
8282: PUSH
8283: LD_OWVAR 67
8287: ARRAY
8288: PUSH
8289: EMPTY
8290: LIST
8291: LIST
8292: LIST
8293: LIST
8294: PUSH
8295: LD_INT 13
8297: PUSH
8298: LD_INT 1
8300: PUSH
8301: LD_INT 2
8303: PUSH
8304: LD_INT 26
8306: PUSH
8307: LD_INT 29
8309: PUSH
8310: LD_INT 29
8312: PUSH
8313: LD_INT 29
8315: PUSH
8316: EMPTY
8317: LIST
8318: LIST
8319: LIST
8320: LIST
8321: PUSH
8322: LD_OWVAR 67
8326: ARRAY
8327: PUSH
8328: EMPTY
8329: LIST
8330: LIST
8331: LIST
8332: LIST
8333: PUSH
8334: LD_INT 13
8336: PUSH
8337: LD_INT 1
8339: PUSH
8340: LD_INT 2
8342: PUSH
8343: LD_INT 29
8345: PUSH
8346: EMPTY
8347: LIST
8348: LIST
8349: LIST
8350: LIST
8351: PUSH
8352: LD_INT 14
8354: PUSH
8355: LD_INT 1
8357: PUSH
8358: LD_INT 2
8360: PUSH
8361: LD_INT 26
8363: PUSH
8364: EMPTY
8365: LIST
8366: LIST
8367: LIST
8368: LIST
8369: PUSH
8370: EMPTY
8371: LIST
8372: LIST
8373: LIST
8374: LIST
8375: LIST
8376: LIST
8377: PPUSH
8378: CALL 45636 0 2
// end ; repeat wait ( 0 0$1 ) ;
8382: LD_INT 35
8384: PPUSH
8385: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
8389: LD_INT 3
8391: PPUSH
8392: LD_INT 1
8394: PPUSH
8395: CALL 47054 0 2
8399: PUSH
8400: LD_INT 6
8402: GREATEREQUAL
8403: IFFALSE 8382
// wait ( 0 0$30 ) ;
8405: LD_INT 1050
8407: PPUSH
8408: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
8412: LD_ADDR_VAR 0 2
8416: PUSH
8417: LD_INT 3
8419: PPUSH
8420: LD_INT 1
8422: PPUSH
8423: CALL 47054 0 2
8427: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
8428: LD_ADDR_EXP 96
8432: PUSH
8433: LD_EXP 96
8437: PPUSH
8438: LD_INT 3
8440: PPUSH
8441: LD_EXP 96
8445: PUSH
8446: LD_INT 3
8448: ARRAY
8449: PUSH
8450: LD_VAR 0 2
8454: DIFF
8455: PPUSH
8456: CALL_OW 1
8460: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
8461: LD_ADDR_VAR 0 3
8465: PUSH
8466: LD_INT 0
8468: PPUSH
8469: LD_INT 2
8471: PPUSH
8472: CALL_OW 12
8476: ST_TO_ADDR
// if target then
8477: LD_VAR 0 3
8481: IFFALSE 8609
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8483: LD_ADDR_VAR 0 2
8487: PUSH
8488: LD_VAR 0 2
8492: PPUSH
8493: LD_INT 24
8495: PUSH
8496: LD_INT 250
8498: PUSH
8499: EMPTY
8500: LIST
8501: LIST
8502: PPUSH
8503: CALL_OW 72
8507: ST_TO_ADDR
// for i in tmp do
8508: LD_ADDR_VAR 0 1
8512: PUSH
8513: LD_VAR 0 2
8517: PUSH
8518: FOR_IN
8519: IFFALSE 8559
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
8521: LD_VAR 0 1
8525: PPUSH
8526: LD_INT 89
8528: PPUSH
8529: LD_INT 71
8531: PPUSH
8532: CALL_OW 297
8536: PUSH
8537: LD_INT 9
8539: GREATER
8540: IFFALSE 8557
// ComMoveXY ( i , 89 , 71 ) ;
8542: LD_VAR 0 1
8546: PPUSH
8547: LD_INT 89
8549: PPUSH
8550: LD_INT 71
8552: PPUSH
8553: CALL_OW 111
8557: GO 8518
8559: POP
8560: POP
// wait ( 0 0$1 ) ;
8561: LD_INT 35
8563: PPUSH
8564: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
8568: LD_VAR 0 2
8572: PPUSH
8573: LD_INT 92
8575: PUSH
8576: LD_INT 89
8578: PUSH
8579: LD_INT 71
8581: PUSH
8582: LD_INT 9
8584: PUSH
8585: EMPTY
8586: LIST
8587: LIST
8588: LIST
8589: LIST
8590: PPUSH
8591: CALL_OW 72
8595: PUSH
8596: LD_VAR 0 2
8600: PUSH
8601: LD_INT 1
8603: MINUS
8604: GREATEREQUAL
8605: IFFALSE 8483
// end else
8607: GO 8733
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8609: LD_ADDR_VAR 0 2
8613: PUSH
8614: LD_VAR 0 2
8618: PPUSH
8619: LD_INT 24
8621: PUSH
8622: LD_INT 250
8624: PUSH
8625: EMPTY
8626: LIST
8627: LIST
8628: PPUSH
8629: CALL_OW 72
8633: ST_TO_ADDR
// for i in tmp do
8634: LD_ADDR_VAR 0 1
8638: PUSH
8639: LD_VAR 0 2
8643: PUSH
8644: FOR_IN
8645: IFFALSE 8685
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
8647: LD_VAR 0 1
8651: PPUSH
8652: LD_INT 147
8654: PPUSH
8655: LD_INT 4
8657: PPUSH
8658: CALL_OW 297
8662: PUSH
8663: LD_INT 9
8665: GREATER
8666: IFFALSE 8683
// ComMoveXY ( i , 147 , 4 ) ;
8668: LD_VAR 0 1
8672: PPUSH
8673: LD_INT 147
8675: PPUSH
8676: LD_INT 4
8678: PPUSH
8679: CALL_OW 111
8683: GO 8644
8685: POP
8686: POP
// wait ( 0 0$1 ) ;
8687: LD_INT 35
8689: PPUSH
8690: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
8694: LD_VAR 0 2
8698: PPUSH
8699: LD_INT 92
8701: PUSH
8702: LD_INT 147
8704: PUSH
8705: LD_INT 4
8707: PUSH
8708: LD_INT 9
8710: PUSH
8711: EMPTY
8712: LIST
8713: LIST
8714: LIST
8715: LIST
8716: PPUSH
8717: CALL_OW 72
8721: PUSH
8722: LD_VAR 0 2
8726: PUSH
8727: LD_INT 1
8729: MINUS
8730: GREATEREQUAL
8731: IFFALSE 8609
// end ; repeat wait ( 0 0$1 ) ;
8733: LD_INT 35
8735: PPUSH
8736: CALL_OW 67
// for i in tmp do
8740: LD_ADDR_VAR 0 1
8744: PUSH
8745: LD_VAR 0 2
8749: PUSH
8750: FOR_IN
8751: IFFALSE 8833
// begin if GetLives ( i ) > 251 then
8753: LD_VAR 0 1
8757: PPUSH
8758: CALL_OW 256
8762: PUSH
8763: LD_INT 251
8765: GREATER
8766: IFFALSE 8804
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
8768: LD_VAR 0 1
8772: PPUSH
8773: LD_INT 81
8775: PUSH
8776: LD_INT 8
8778: PUSH
8779: EMPTY
8780: LIST
8781: LIST
8782: PPUSH
8783: CALL_OW 69
8787: PPUSH
8788: LD_VAR 0 1
8792: PPUSH
8793: CALL_OW 74
8797: PPUSH
8798: CALL_OW 115
8802: GO 8831
// if IsDead ( i ) then
8804: LD_VAR 0 1
8808: PPUSH
8809: CALL_OW 301
8813: IFFALSE 8831
// tmp := tmp diff i ;
8815: LD_ADDR_VAR 0 2
8819: PUSH
8820: LD_VAR 0 2
8824: PUSH
8825: LD_VAR 0 1
8829: DIFF
8830: ST_TO_ADDR
// end ;
8831: GO 8750
8833: POP
8834: POP
// until not tmp ;
8835: LD_VAR 0 2
8839: NOT
8840: IFFALSE 8733
// end ;
8842: PPOPN 3
8844: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8845: LD_EXP 58
8849: PPUSH
8850: CALL_OW 302
8854: PUSH
8855: LD_EXP 3
8859: NOT
8860: AND
8861: IFFALSE 8870
8863: GO 8865
8865: DISABLE
// BuildKozlovBomb ;
8866: CALL 7841 0 0
8870: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8871: LD_INT 22
8873: PUSH
8874: LD_INT 8
8876: PUSH
8877: EMPTY
8878: LIST
8879: LIST
8880: PUSH
8881: LD_INT 34
8883: PUSH
8884: LD_INT 48
8886: PUSH
8887: EMPTY
8888: LIST
8889: LIST
8890: PUSH
8891: EMPTY
8892: LIST
8893: LIST
8894: PPUSH
8895: CALL_OW 69
8899: IFFALSE 8947
8901: GO 8903
8903: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
8904: LD_INT 22
8906: PUSH
8907: LD_INT 8
8909: PUSH
8910: EMPTY
8911: LIST
8912: LIST
8913: PUSH
8914: LD_INT 34
8916: PUSH
8917: LD_INT 48
8919: PUSH
8920: EMPTY
8921: LIST
8922: LIST
8923: PUSH
8924: EMPTY
8925: LIST
8926: LIST
8927: PPUSH
8928: CALL_OW 69
8932: PUSH
8933: LD_INT 1
8935: ARRAY
8936: PPUSH
8937: LD_INT 173
8939: PPUSH
8940: LD_INT 96
8942: PPUSH
8943: CALL_OW 116
// end ; end_of_file
8947: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
8948: LD_INT 0
8950: PPUSH
8951: PPUSH
8952: PPUSH
8953: PPUSH
8954: PPUSH
8955: PPUSH
8956: PPUSH
8957: PPUSH
8958: PPUSH
// side := 3 ;
8959: LD_ADDR_VAR 0 6
8963: PUSH
8964: LD_INT 3
8966: ST_TO_ADDR
// InitHc ;
8967: CALL_OW 19
// uc_side := side ;
8971: LD_ADDR_OWVAR 20
8975: PUSH
8976: LD_VAR 0 6
8980: ST_TO_ADDR
// uc_nation := 3 ;
8981: LD_ADDR_OWVAR 21
8985: PUSH
8986: LD_INT 3
8988: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
8989: LD_ADDR_VAR 0 2
8993: PUSH
8994: LD_INT 22
8996: PUSH
8997: LD_VAR 0 6
9001: PUSH
9002: EMPTY
9003: LIST
9004: LIST
9005: PUSH
9006: LD_INT 21
9008: PUSH
9009: LD_INT 3
9011: PUSH
9012: EMPTY
9013: LIST
9014: LIST
9015: PUSH
9016: EMPTY
9017: LIST
9018: LIST
9019: PPUSH
9020: CALL_OW 69
9024: PUSH
9025: FOR_IN
9026: IFFALSE 9042
// SetBLevel ( i , 10 ) ;
9028: LD_VAR 0 2
9032: PPUSH
9033: LD_INT 10
9035: PPUSH
9036: CALL_OW 241
9040: GO 9025
9042: POP
9043: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
9044: LD_ADDR_VAR 0 9
9048: PUSH
9049: LD_INT 22
9051: PUSH
9052: LD_VAR 0 6
9056: PUSH
9057: EMPTY
9058: LIST
9059: LIST
9060: PUSH
9061: LD_INT 30
9063: PUSH
9064: LD_INT 34
9066: PUSH
9067: EMPTY
9068: LIST
9069: LIST
9070: PUSH
9071: EMPTY
9072: LIST
9073: LIST
9074: PPUSH
9075: CALL_OW 69
9079: ST_TO_ADDR
// if teleport then
9080: LD_VAR 0 9
9084: IFFALSE 9105
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
9086: LD_VAR 0 9
9090: PUSH
9091: LD_INT 1
9093: ARRAY
9094: PPUSH
9095: LD_INT 123
9097: PPUSH
9098: LD_INT 122
9100: PPUSH
9101: CALL_OW 243
// hc_importance := 0 ;
9105: LD_ADDR_OWVAR 32
9109: PUSH
9110: LD_INT 0
9112: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
9113: LD_ADDR_EXP 59
9117: PUSH
9118: LD_STRING Platonov
9120: PPUSH
9121: CALL_OW 25
9125: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
9126: LD_ADDR_EXP 60
9130: PUSH
9131: LD_STRING Yakotich
9133: PPUSH
9134: LD_EXP 1
9138: NOT
9139: PPUSH
9140: LD_STRING 09_
9142: PPUSH
9143: CALL 52062 0 3
9147: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
9148: LD_ADDR_EXP 61
9152: PUSH
9153: LD_STRING Gleb
9155: PPUSH
9156: CALL_OW 25
9160: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
9161: LD_STRING 03_Cornel
9163: PPUSH
9164: CALL_OW 28
9168: IFFALSE 9216
// begin Bierezov := NewCharacter ( Mikhail ) ;
9170: LD_ADDR_EXP 62
9174: PUSH
9175: LD_STRING Mikhail
9177: PPUSH
9178: CALL_OW 25
9182: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
9183: LD_EXP 62
9187: PPUSH
9188: LD_INT 197
9190: PPUSH
9191: LD_INT 111
9193: PPUSH
9194: LD_INT 9
9196: PPUSH
9197: LD_INT 0
9199: PPUSH
9200: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
9204: LD_EXP 62
9208: PPUSH
9209: LD_INT 3
9211: PPUSH
9212: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
9216: LD_EXP 59
9220: PPUSH
9221: LD_INT 126
9223: PPUSH
9224: CALL_OW 52
// if Yakotich then
9228: LD_EXP 60
9232: IFFALSE 9255
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
9234: LD_EXP 60
9238: PPUSH
9239: LD_INT 197
9241: PPUSH
9242: LD_INT 111
9244: PPUSH
9245: LD_INT 9
9247: PPUSH
9248: LD_INT 0
9250: PPUSH
9251: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
9255: LD_EXP 61
9259: PPUSH
9260: LD_INT 197
9262: PPUSH
9263: LD_INT 111
9265: PPUSH
9266: LD_INT 9
9268: PPUSH
9269: LD_INT 0
9271: PPUSH
9272: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 9000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
9276: LD_ADDR_VAR 0 5
9280: PUSH
9281: LD_INT 126
9283: PPUSH
9284: LD_INT 2
9286: PPUSH
9287: LD_STRING zhukov
9289: PPUSH
9290: LD_INT 9
9292: PUSH
9293: LD_INT 10
9295: PUSH
9296: LD_INT 10
9298: PUSH
9299: LD_INT 10
9301: PUSH
9302: EMPTY
9303: LIST
9304: LIST
9305: LIST
9306: LIST
9307: PUSH
9308: LD_OWVAR 67
9312: ARRAY
9313: PPUSH
9314: LD_INT 9000
9316: PUSH
9317: LD_INT 1000
9319: PUSH
9320: LD_INT 300
9322: PUSH
9323: EMPTY
9324: LIST
9325: LIST
9326: LIST
9327: PPUSH
9328: LD_INT 21
9330: PUSH
9331: LD_INT 8
9333: PUSH
9334: LD_INT 13
9336: PUSH
9337: LD_INT 8
9339: PUSH
9340: EMPTY
9341: LIST
9342: LIST
9343: LIST
9344: LIST
9345: PPUSH
9346: CALL 60521 0 6
9350: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
9351: LD_ADDR_VAR 0 4
9355: PUSH
9356: LD_INT 267
9358: PPUSH
9359: CALL_OW 274
9363: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
9364: LD_VAR 0 4
9368: PPUSH
9369: LD_INT 1
9371: PPUSH
9372: LD_INT 5000
9374: PPUSH
9375: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
9379: LD_VAR 0 4
9383: PPUSH
9384: LD_INT 2
9386: PPUSH
9387: LD_INT 200
9389: PPUSH
9390: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
9394: LD_VAR 0 4
9398: PPUSH
9399: LD_INT 3
9401: PPUSH
9402: LD_INT 200
9404: PPUSH
9405: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
9409: LD_ADDR_EXP 77
9413: PUSH
9414: LD_EXP 77
9418: PPUSH
9419: LD_INT 2
9421: PPUSH
9422: LD_VAR 0 5
9426: PUSH
9427: LD_INT 22
9429: PUSH
9430: LD_VAR 0 6
9434: PUSH
9435: EMPTY
9436: LIST
9437: LIST
9438: PUSH
9439: LD_INT 3
9441: PUSH
9442: LD_INT 21
9444: PUSH
9445: LD_INT 2
9447: PUSH
9448: EMPTY
9449: LIST
9450: LIST
9451: PUSH
9452: EMPTY
9453: LIST
9454: LIST
9455: PUSH
9456: EMPTY
9457: LIST
9458: LIST
9459: PPUSH
9460: CALL_OW 69
9464: UNION
9465: PUSH
9466: LD_EXP 59
9470: DIFF
9471: PPUSH
9472: CALL_OW 1
9476: ST_TO_ADDR
// behemoths := [ ] ;
9477: LD_ADDR_EXP 63
9481: PUSH
9482: EMPTY
9483: ST_TO_ADDR
// behemothBuilders := [ ] ;
9484: LD_ADDR_EXP 64
9488: PUSH
9489: EMPTY
9490: ST_TO_ADDR
// j := 3 ;
9491: LD_ADDR_VAR 0 3
9495: PUSH
9496: LD_INT 3
9498: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
9499: LD_ADDR_VAR 0 2
9503: PUSH
9504: LD_INT 22
9506: PUSH
9507: LD_INT 3
9509: PUSH
9510: EMPTY
9511: LIST
9512: LIST
9513: PUSH
9514: LD_INT 25
9516: PUSH
9517: LD_INT 3
9519: PUSH
9520: EMPTY
9521: LIST
9522: LIST
9523: PUSH
9524: EMPTY
9525: LIST
9526: LIST
9527: PPUSH
9528: CALL_OW 69
9532: PUSH
9533: FOR_IN
9534: IFFALSE 9584
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
9536: LD_ADDR_EXP 64
9540: PUSH
9541: LD_EXP 64
9545: PPUSH
9546: LD_VAR 0 2
9550: PPUSH
9551: CALL 89530 0 2
9555: ST_TO_ADDR
// j := j - 1 ;
9556: LD_ADDR_VAR 0 3
9560: PUSH
9561: LD_VAR 0 3
9565: PUSH
9566: LD_INT 1
9568: MINUS
9569: ST_TO_ADDR
// if j = 0 then
9570: LD_VAR 0 3
9574: PUSH
9575: LD_INT 0
9577: EQUAL
9578: IFFALSE 9582
// break ;
9580: GO 9584
// end ;
9582: GO 9533
9584: POP
9585: POP
// end ;
9586: LD_VAR 0 1
9590: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
9591: LD_INT 0
9593: PPUSH
9594: PPUSH
9595: PPUSH
9596: PPUSH
9597: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
9598: LD_ADDR_VAR 0 4
9602: PUSH
9603: LD_INT 209
9605: PUSH
9606: LD_INT 149
9608: PUSH
9609: EMPTY
9610: LIST
9611: LIST
9612: PUSH
9613: LD_INT 219
9615: PUSH
9616: LD_INT 154
9618: PUSH
9619: EMPTY
9620: LIST
9621: LIST
9622: PUSH
9623: LD_INT 223
9625: PUSH
9626: LD_INT 149
9628: PUSH
9629: EMPTY
9630: LIST
9631: LIST
9632: PUSH
9633: LD_INT 232
9635: PUSH
9636: LD_INT 155
9638: PUSH
9639: EMPTY
9640: LIST
9641: LIST
9642: PUSH
9643: EMPTY
9644: LIST
9645: LIST
9646: LIST
9647: LIST
9648: ST_TO_ADDR
// if not behemothBuilders then
9649: LD_EXP 64
9653: NOT
9654: IFFALSE 9658
// exit ;
9656: GO 9762
// j := 1 ;
9658: LD_ADDR_VAR 0 3
9662: PUSH
9663: LD_INT 1
9665: ST_TO_ADDR
// for i in behemothBuilders do
9666: LD_ADDR_VAR 0 2
9670: PUSH
9671: LD_EXP 64
9675: PUSH
9676: FOR_IN
9677: IFFALSE 9760
// begin if IsInUnit ( i ) then
9679: LD_VAR 0 2
9683: PPUSH
9684: CALL_OW 310
9688: IFFALSE 9699
// ComExitBuilding ( i ) ;
9690: LD_VAR 0 2
9694: PPUSH
9695: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
9699: LD_VAR 0 2
9703: PPUSH
9704: LD_INT 37
9706: PPUSH
9707: LD_VAR 0 4
9711: PUSH
9712: LD_VAR 0 3
9716: ARRAY
9717: PUSH
9718: LD_INT 1
9720: ARRAY
9721: PPUSH
9722: LD_VAR 0 4
9726: PUSH
9727: LD_VAR 0 3
9731: ARRAY
9732: PUSH
9733: LD_INT 2
9735: ARRAY
9736: PPUSH
9737: LD_INT 0
9739: PPUSH
9740: CALL_OW 230
// j := j + 1 ;
9744: LD_ADDR_VAR 0 3
9748: PUSH
9749: LD_VAR 0 3
9753: PUSH
9754: LD_INT 1
9756: PLUS
9757: ST_TO_ADDR
// end ;
9758: GO 9676
9760: POP
9761: POP
// end ;
9762: LD_VAR 0 1
9766: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
9767: LD_INT 3
9769: PPUSH
9770: CALL 89591 0 1
9774: PUSH
9775: LD_INT 22
9777: PUSH
9778: LD_INT 3
9780: PUSH
9781: EMPTY
9782: LIST
9783: LIST
9784: PUSH
9785: LD_INT 30
9787: PUSH
9788: LD_INT 37
9790: PUSH
9791: EMPTY
9792: LIST
9793: LIST
9794: PUSH
9795: EMPTY
9796: LIST
9797: LIST
9798: PPUSH
9799: CALL_OW 69
9803: NOT
9804: AND
9805: IFFALSE 9991
9807: GO 9809
9809: DISABLE
9810: LD_INT 0
9812: PPUSH
9813: PPUSH
// begin enable ;
9814: ENABLE
// tmp := GetBehemoths ( 3 ) ;
9815: LD_ADDR_VAR 0 2
9819: PUSH
9820: LD_INT 3
9822: PPUSH
9823: CALL 89591 0 1
9827: ST_TO_ADDR
// for i in tmp do
9828: LD_ADDR_VAR 0 1
9832: PUSH
9833: LD_VAR 0 2
9837: PUSH
9838: FOR_IN
9839: IFFALSE 9989
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
9841: LD_VAR 0 1
9845: PPUSH
9846: LD_INT 7
9848: PPUSH
9849: CALL_OW 308
9853: PUSH
9854: LD_VAR 0 1
9858: PPUSH
9859: CALL_OW 110
9863: PUSH
9864: LD_INT 2
9866: EQUAL
9867: NOT
9868: AND
9869: IFFALSE 9883
// SetTag ( i , 2 ) ;
9871: LD_VAR 0 1
9875: PPUSH
9876: LD_INT 2
9878: PPUSH
9879: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
9883: LD_INT 81
9885: PUSH
9886: LD_INT 3
9888: PUSH
9889: EMPTY
9890: LIST
9891: LIST
9892: PUSH
9893: LD_INT 91
9895: PUSH
9896: LD_VAR 0 1
9900: PUSH
9901: LD_INT 12
9903: PUSH
9904: EMPTY
9905: LIST
9906: LIST
9907: LIST
9908: PUSH
9909: EMPTY
9910: LIST
9911: LIST
9912: PPUSH
9913: CALL_OW 69
9917: NOT
9918: PUSH
9919: LD_VAR 0 1
9923: PPUSH
9924: CALL_OW 110
9928: PUSH
9929: LD_INT 2
9931: EQUAL
9932: NOT
9933: AND
9934: IFFALSE 9953
// ComAgressiveMove ( i , 64 , 93 ) else
9936: LD_VAR 0 1
9940: PPUSH
9941: LD_INT 64
9943: PPUSH
9944: LD_INT 93
9946: PPUSH
9947: CALL_OW 114
9951: GO 9987
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9953: LD_VAR 0 1
9957: PPUSH
9958: LD_INT 81
9960: PUSH
9961: LD_INT 3
9963: PUSH
9964: EMPTY
9965: LIST
9966: LIST
9967: PPUSH
9968: CALL_OW 69
9972: PPUSH
9973: LD_VAR 0 1
9977: PPUSH
9978: CALL_OW 74
9982: PPUSH
9983: CALL_OW 115
// end ;
9987: GO 9838
9989: POP
9990: POP
// end ;
9991: PPOPN 2
9993: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9994: LD_EXP 2
9998: NOT
9999: PUSH
10000: LD_INT 2
10002: PPUSH
10003: LD_INT 1
10005: PPUSH
10006: CALL 47054 0 2
10010: NOT
10011: AND
10012: IFFALSE 10936
10014: GO 10016
10016: DISABLE
10017: LD_INT 0
10019: PPUSH
10020: PPUSH
10021: PPUSH
10022: PPUSH
// begin enable ;
10023: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10024: LD_INT 22
10026: PUSH
10027: LD_INT 3
10029: PUSH
10030: EMPTY
10031: LIST
10032: LIST
10033: PUSH
10034: LD_INT 30
10036: PUSH
10037: LD_INT 3
10039: PUSH
10040: EMPTY
10041: LIST
10042: LIST
10043: PUSH
10044: EMPTY
10045: LIST
10046: LIST
10047: PPUSH
10048: CALL_OW 69
10052: NOT
10053: IFFALSE 10057
// exit ;
10055: GO 10936
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10057: LD_ADDR_VAR 0 4
10061: PUSH
10062: LD_INT 22
10064: PUSH
10065: LD_INT 3
10067: PUSH
10068: EMPTY
10069: LIST
10070: LIST
10071: PUSH
10072: LD_INT 30
10074: PUSH
10075: LD_INT 34
10077: PUSH
10078: EMPTY
10079: LIST
10080: LIST
10081: PUSH
10082: EMPTY
10083: LIST
10084: LIST
10085: PPUSH
10086: CALL_OW 69
10090: ST_TO_ADDR
// if Prob ( 40 ) then
10091: LD_INT 40
10093: PPUSH
10094: CALL_OW 13
10098: IFFALSE 10225
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10100: LD_INT 2
10102: PPUSH
10103: LD_INT 22
10105: PUSH
10106: LD_INT 3
10108: PUSH
10109: LD_INT 3
10111: PUSH
10112: LD_INT 49
10114: PUSH
10115: EMPTY
10116: LIST
10117: LIST
10118: LIST
10119: LIST
10120: PUSH
10121: LD_INT 22
10123: PUSH
10124: LD_INT 3
10126: PUSH
10127: LD_INT 3
10129: PUSH
10130: LD_INT 49
10132: PUSH
10133: EMPTY
10134: LIST
10135: LIST
10136: LIST
10137: LIST
10138: PUSH
10139: LD_INT 22
10141: PUSH
10142: LD_INT 3
10144: PUSH
10145: LD_INT 3
10147: PUSH
10148: LD_INT 49
10150: PUSH
10151: EMPTY
10152: LIST
10153: LIST
10154: LIST
10155: LIST
10156: PUSH
10157: LD_INT 24
10159: PUSH
10160: LD_INT 3
10162: PUSH
10163: LD_INT 3
10165: PUSH
10166: LD_INT 46
10168: PUSH
10169: EMPTY
10170: LIST
10171: LIST
10172: LIST
10173: LIST
10174: PUSH
10175: LD_INT 24
10177: PUSH
10178: LD_INT 3
10180: PUSH
10181: LD_INT 3
10183: PUSH
10184: LD_INT 46
10186: PUSH
10187: EMPTY
10188: LIST
10189: LIST
10190: LIST
10191: LIST
10192: PUSH
10193: LD_INT 24
10195: PUSH
10196: LD_INT 3
10198: PUSH
10199: LD_INT 3
10201: PUSH
10202: LD_INT 46
10204: PUSH
10205: EMPTY
10206: LIST
10207: LIST
10208: LIST
10209: LIST
10210: PUSH
10211: EMPTY
10212: LIST
10213: LIST
10214: LIST
10215: LIST
10216: LIST
10217: LIST
10218: PPUSH
10219: CALL 45636 0 2
// end else
10223: GO 10348
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10225: LD_INT 2
10227: PPUSH
10228: LD_INT 24
10230: PUSH
10231: LD_INT 3
10233: PUSH
10234: LD_INT 3
10236: PUSH
10237: LD_INT 47
10239: PUSH
10240: EMPTY
10241: LIST
10242: LIST
10243: LIST
10244: LIST
10245: PUSH
10246: LD_INT 24
10248: PUSH
10249: LD_INT 3
10251: PUSH
10252: LD_INT 3
10254: PUSH
10255: LD_INT 47
10257: PUSH
10258: EMPTY
10259: LIST
10260: LIST
10261: LIST
10262: LIST
10263: PUSH
10264: LD_INT 24
10266: PUSH
10267: LD_INT 3
10269: PUSH
10270: LD_INT 3
10272: PUSH
10273: LD_INT 47
10275: PUSH
10276: EMPTY
10277: LIST
10278: LIST
10279: LIST
10280: LIST
10281: PUSH
10282: LD_INT 24
10284: PUSH
10285: LD_INT 3
10287: PUSH
10288: LD_INT 3
10290: PUSH
10291: LD_INT 46
10293: PUSH
10294: EMPTY
10295: LIST
10296: LIST
10297: LIST
10298: LIST
10299: PUSH
10300: LD_INT 24
10302: PUSH
10303: LD_INT 3
10305: PUSH
10306: LD_INT 3
10308: PUSH
10309: LD_INT 46
10311: PUSH
10312: EMPTY
10313: LIST
10314: LIST
10315: LIST
10316: LIST
10317: PUSH
10318: LD_INT 24
10320: PUSH
10321: LD_INT 3
10323: PUSH
10324: LD_INT 3
10326: PUSH
10327: LD_INT 46
10329: PUSH
10330: EMPTY
10331: LIST
10332: LIST
10333: LIST
10334: LIST
10335: PUSH
10336: EMPTY
10337: LIST
10338: LIST
10339: LIST
10340: LIST
10341: LIST
10342: LIST
10343: PPUSH
10344: CALL 45636 0 2
// end ; if Difficulty > 1 then
10348: LD_OWVAR 67
10352: PUSH
10353: LD_INT 1
10355: GREATER
10356: IFFALSE 10386
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10358: LD_INT 2
10360: PPUSH
10361: LD_INT 24
10363: PUSH
10364: LD_INT 3
10366: PUSH
10367: LD_INT 3
10369: PUSH
10370: LD_INT 47
10372: PUSH
10373: EMPTY
10374: LIST
10375: LIST
10376: LIST
10377: LIST
10378: PUSH
10379: EMPTY
10380: LIST
10381: PPUSH
10382: CALL 45636 0 2
// repeat wait ( 0 0$1 ) ;
10386: LD_INT 35
10388: PPUSH
10389: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] ;
10393: LD_INT 2
10395: PPUSH
10396: LD_INT 1
10398: PPUSH
10399: CALL 47054 0 2
10403: PUSH
10404: LD_INT 6
10406: PUSH
10407: LD_INT 7
10409: PUSH
10410: LD_INT 7
10412: PUSH
10413: LD_INT 7
10415: PUSH
10416: EMPTY
10417: LIST
10418: LIST
10419: LIST
10420: LIST
10421: PUSH
10422: LD_OWVAR 67
10426: ARRAY
10427: GREATEREQUAL
10428: IFFALSE 10386
// wait ( 0 0$30 ) ;
10430: LD_INT 1050
10432: PPUSH
10433: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10437: LD_ADDR_VAR 0 2
10441: PUSH
10442: LD_INT 2
10444: PPUSH
10445: LD_INT 1
10447: PPUSH
10448: CALL 47054 0 2
10452: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10453: LD_ADDR_EXP 96
10457: PUSH
10458: LD_EXP 96
10462: PPUSH
10463: LD_INT 2
10465: PPUSH
10466: LD_EXP 96
10470: PUSH
10471: LD_INT 2
10473: ARRAY
10474: PUSH
10475: LD_VAR 0 2
10479: DIFF
10480: PPUSH
10481: CALL_OW 1
10485: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10486: LD_ADDR_VAR 0 3
10490: PUSH
10491: LD_INT 0
10493: PPUSH
10494: LD_INT 1
10496: PPUSH
10497: CALL_OW 12
10501: ST_TO_ADDR
// if target then
10502: LD_VAR 0 3
10506: IFFALSE 10634
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10508: LD_ADDR_VAR 0 2
10512: PUSH
10513: LD_VAR 0 2
10517: PPUSH
10518: LD_INT 24
10520: PUSH
10521: LD_INT 250
10523: PUSH
10524: EMPTY
10525: LIST
10526: LIST
10527: PPUSH
10528: CALL_OW 72
10532: ST_TO_ADDR
// for i in tmp do
10533: LD_ADDR_VAR 0 1
10537: PUSH
10538: LD_VAR 0 2
10542: PUSH
10543: FOR_IN
10544: IFFALSE 10584
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10546: LD_VAR 0 1
10550: PPUSH
10551: LD_INT 139
10553: PPUSH
10554: LD_INT 89
10556: PPUSH
10557: CALL_OW 297
10561: PUSH
10562: LD_INT 9
10564: GREATER
10565: IFFALSE 10582
// ComMoveXY ( i , 139 , 89 ) ;
10567: LD_VAR 0 1
10571: PPUSH
10572: LD_INT 139
10574: PPUSH
10575: LD_INT 89
10577: PPUSH
10578: CALL_OW 111
10582: GO 10543
10584: POP
10585: POP
// wait ( 0 0$1 ) ;
10586: LD_INT 35
10588: PPUSH
10589: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10593: LD_VAR 0 2
10597: PPUSH
10598: LD_INT 92
10600: PUSH
10601: LD_INT 139
10603: PUSH
10604: LD_INT 89
10606: PUSH
10607: LD_INT 9
10609: PUSH
10610: EMPTY
10611: LIST
10612: LIST
10613: LIST
10614: LIST
10615: PPUSH
10616: CALL_OW 72
10620: PUSH
10621: LD_VAR 0 2
10625: PUSH
10626: LD_INT 1
10628: MINUS
10629: GREATEREQUAL
10630: IFFALSE 10508
// end else
10632: GO 10776
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10634: LD_VAR 0 2
10638: PPUSH
10639: LD_VAR 0 4
10643: PUSH
10644: LD_INT 1
10646: ARRAY
10647: PPUSH
10648: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10652: LD_ADDR_VAR 0 2
10656: PUSH
10657: LD_VAR 0 2
10661: PPUSH
10662: LD_INT 24
10664: PUSH
10665: LD_INT 250
10667: PUSH
10668: EMPTY
10669: LIST
10670: LIST
10671: PPUSH
10672: CALL_OW 72
10676: ST_TO_ADDR
// for i in tmp do
10677: LD_ADDR_VAR 0 1
10681: PUSH
10682: LD_VAR 0 2
10686: PUSH
10687: FOR_IN
10688: IFFALSE 10728
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10690: LD_VAR 0 1
10694: PPUSH
10695: LD_INT 124
10697: PPUSH
10698: LD_INT 139
10700: PPUSH
10701: CALL_OW 297
10705: PUSH
10706: LD_INT 9
10708: GREATER
10709: IFFALSE 10726
// ComMoveXY ( i , 124 , 139 ) ;
10711: LD_VAR 0 1
10715: PPUSH
10716: LD_INT 124
10718: PPUSH
10719: LD_INT 139
10721: PPUSH
10722: CALL_OW 111
10726: GO 10687
10728: POP
10729: POP
// wait ( 0 0$1 ) ;
10730: LD_INT 35
10732: PPUSH
10733: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10737: LD_VAR 0 2
10741: PPUSH
10742: LD_INT 92
10744: PUSH
10745: LD_INT 124
10747: PUSH
10748: LD_INT 139
10750: PUSH
10751: LD_INT 9
10753: PUSH
10754: EMPTY
10755: LIST
10756: LIST
10757: LIST
10758: LIST
10759: PPUSH
10760: CALL_OW 72
10764: PUSH
10765: LD_VAR 0 2
10769: PUSH
10770: LD_INT 1
10772: MINUS
10773: GREATEREQUAL
10774: IFFALSE 10652
// end ; repeat wait ( 0 0$1 ) ;
10776: LD_INT 35
10778: PPUSH
10779: CALL_OW 67
// for i in tmp do
10783: LD_ADDR_VAR 0 1
10787: PUSH
10788: LD_VAR 0 2
10792: PUSH
10793: FOR_IN
10794: IFFALSE 10927
// begin if GetLives ( i ) > 251 then
10796: LD_VAR 0 1
10800: PPUSH
10801: CALL_OW 256
10805: PUSH
10806: LD_INT 251
10808: GREATER
10809: IFFALSE 10898
// begin if GetWeapon ( i ) = ru_time_lapser then
10811: LD_VAR 0 1
10815: PPUSH
10816: CALL_OW 264
10820: PUSH
10821: LD_INT 49
10823: EQUAL
10824: IFFALSE 10862
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
10826: LD_VAR 0 1
10830: PPUSH
10831: LD_INT 81
10833: PUSH
10834: LD_INT 3
10836: PUSH
10837: EMPTY
10838: LIST
10839: LIST
10840: PPUSH
10841: CALL_OW 69
10845: PPUSH
10846: LD_VAR 0 1
10850: PPUSH
10851: CALL_OW 74
10855: PPUSH
10856: CALL_OW 112
10860: GO 10896
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10862: LD_VAR 0 1
10866: PPUSH
10867: LD_INT 81
10869: PUSH
10870: LD_INT 3
10872: PUSH
10873: EMPTY
10874: LIST
10875: LIST
10876: PPUSH
10877: CALL_OW 69
10881: PPUSH
10882: LD_VAR 0 1
10886: PPUSH
10887: CALL_OW 74
10891: PPUSH
10892: CALL_OW 115
// end else
10896: GO 10925
// if IsDead ( i ) then
10898: LD_VAR 0 1
10902: PPUSH
10903: CALL_OW 301
10907: IFFALSE 10925
// tmp := tmp diff i ;
10909: LD_ADDR_VAR 0 2
10913: PUSH
10914: LD_VAR 0 2
10918: PUSH
10919: LD_VAR 0 1
10923: DIFF
10924: ST_TO_ADDR
// end ;
10925: GO 10793
10927: POP
10928: POP
// until not tmp ;
10929: LD_VAR 0 2
10933: NOT
10934: IFFALSE 10776
// end ;
10936: PPOPN 4
10938: END
// every 30 30$00 trigger not russianDestroyed do
10939: LD_EXP 2
10943: NOT
10944: IFFALSE 11013
10946: GO 10948
10948: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] ) ;
10949: LD_INT 105000
10951: PUSH
10952: LD_INT 84000
10954: PUSH
10955: LD_INT 63000
10957: PUSH
10958: LD_INT 52500
10960: PUSH
10961: EMPTY
10962: LIST
10963: LIST
10964: LIST
10965: LIST
10966: PUSH
10967: LD_OWVAR 67
10971: ARRAY
10972: PPUSH
10973: CALL_OW 67
// if russianDestroyed then
10977: LD_EXP 2
10981: IFFALSE 10985
// exit ;
10983: GO 11013
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
10985: LD_INT 2
10987: PPUSH
10988: LD_INT 23
10990: PUSH
10991: LD_INT 3
10993: PUSH
10994: LD_INT 1
10996: PUSH
10997: LD_INT 48
10999: PUSH
11000: EMPTY
11001: LIST
11002: LIST
11003: LIST
11004: LIST
11005: PUSH
11006: EMPTY
11007: LIST
11008: PPUSH
11009: CALL 45636 0 2
// end ; end_of_file
11013: END
// export function CustomEvent ( event ) ; begin
11014: LD_INT 0
11016: PPUSH
// end ;
11017: LD_VAR 0 2
11021: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
11022: LD_VAR 0 2
11026: PPUSH
11027: LD_VAR 0 3
11031: PPUSH
11032: LD_INT 15
11034: PPUSH
11035: CALL_OW 309
11039: IFFALSE 11048
// YouLost ( MothContaminate ) ;
11041: LD_STRING MothContaminate
11043: PPUSH
11044: CALL_OW 104
// end ;
11048: PPOPN 3
11050: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
11051: LD_VAR 0 2
11055: PPUSH
11056: LD_VAR 0 3
11060: PPUSH
11061: LD_INT 15
11063: PPUSH
11064: CALL_OW 309
11068: IFFALSE 11084
// begin wait ( 0 0$6 ) ;
11070: LD_INT 210
11072: PPUSH
11073: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
11077: LD_STRING MothContaminateBomb
11079: PPUSH
11080: CALL_OW 104
// end ; end ;
11084: PPOPN 3
11086: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
11087: LD_VAR 0 1
11091: PPUSH
11092: CALL 109277 0 1
// if un = JMM then
11096: LD_VAR 0 1
11100: PUSH
11101: LD_EXP 19
11105: EQUAL
11106: IFFALSE 11117
// begin YouLost ( JMM ) ;
11108: LD_STRING JMM
11110: PPUSH
11111: CALL_OW 104
// exit ;
11115: GO 11246
// end ; if GetSide ( un ) = 2 and not arabianAttacked then
11117: LD_VAR 0 1
11121: PPUSH
11122: CALL_OW 255
11126: PUSH
11127: LD_INT 2
11129: EQUAL
11130: PUSH
11131: LD_EXP 18
11135: NOT
11136: AND
11137: IFFALSE 11147
// arabianAttacked := true ;
11139: LD_ADDR_EXP 18
11143: PUSH
11144: LD_INT 1
11146: ST_TO_ADDR
// if un = Powell then
11147: LD_VAR 0 1
11151: PUSH
11152: LD_EXP 55
11156: EQUAL
11157: IFFALSE 11167
// americanDestroyed := true ;
11159: LD_ADDR_EXP 4
11163: PUSH
11164: LD_INT 1
11166: ST_TO_ADDR
// if un = Platonov then
11167: LD_VAR 0 1
11171: PUSH
11172: LD_EXP 59
11176: EQUAL
11177: IFFALSE 11187
// russianDestroyed := true ;
11179: LD_ADDR_EXP 2
11183: PUSH
11184: LD_INT 1
11186: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
11187: LD_VAR 0 1
11191: PUSH
11192: LD_INT 22
11194: PUSH
11195: LD_INT 7
11197: PUSH
11198: EMPTY
11199: LIST
11200: LIST
11201: PUSH
11202: LD_INT 21
11204: PUSH
11205: LD_INT 2
11207: PUSH
11208: EMPTY
11209: LIST
11210: LIST
11211: PUSH
11212: EMPTY
11213: LIST
11214: LIST
11215: PPUSH
11216: CALL_OW 69
11220: IN
11221: IFFALSE 11237
// vehicleLostCounter := vehicleLostCounter + 1 ;
11223: LD_ADDR_EXP 15
11227: PUSH
11228: LD_EXP 15
11232: PUSH
11233: LD_INT 1
11235: PLUS
11236: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
11237: LD_VAR 0 1
11241: PPUSH
11242: CALL 49078 0 1
// end ;
11246: PPOPN 1
11248: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
11249: LD_VAR 0 1
11253: PPUSH
11254: LD_VAR 0 2
11258: PPUSH
11259: CALL 51410 0 2
// end ;
11263: PPOPN 2
11265: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
11266: LD_VAR 0 1
11270: PPUSH
11271: CALL 50478 0 1
// end ;
11275: PPOPN 1
11277: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
11278: LD_VAR 0 1
11282: PUSH
11283: LD_INT 22
11285: PUSH
11286: LD_INT 8
11288: PUSH
11289: EMPTY
11290: LIST
11291: LIST
11292: PUSH
11293: LD_INT 30
11295: PUSH
11296: LD_INT 2
11298: PUSH
11299: EMPTY
11300: LIST
11301: LIST
11302: PUSH
11303: LD_INT 23
11305: PUSH
11306: LD_INT 3
11308: PUSH
11309: EMPTY
11310: LIST
11311: LIST
11312: PUSH
11313: EMPTY
11314: LIST
11315: LIST
11316: LIST
11317: PPUSH
11318: CALL_OW 69
11322: IN
11323: IFFALSE 11350
// begin ComUpgrade ( building ) ;
11325: LD_VAR 0 1
11329: PPUSH
11330: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
11334: LD_EXP 58
11338: PPUSH
11339: LD_VAR 0 1
11343: PPUSH
11344: CALL 60060 0 2
// exit ;
11348: GO 11359
// end ; MCE_BuildingComplete ( building ) ;
11350: LD_VAR 0 1
11354: PPUSH
11355: CALL 50719 0 1
// end ;
11359: PPOPN 1
11361: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
11362: LD_VAR 0 1
11366: PPUSH
11367: LD_VAR 0 2
11371: PPUSH
11372: CALL 48774 0 2
// end ;
11376: PPOPN 2
11378: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
11379: LD_VAR 0 1
11383: PPUSH
11384: LD_VAR 0 2
11388: PPUSH
11389: LD_VAR 0 3
11393: PPUSH
11394: LD_VAR 0 4
11398: PPUSH
11399: LD_VAR 0 5
11403: PPUSH
11404: CALL 48394 0 5
// end ;
11408: PPOPN 5
11410: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
11411: LD_VAR 0 1
11415: PPUSH
11416: LD_VAR 0 2
11420: PPUSH
11421: CALL 109397 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
11425: LD_VAR 0 1
11429: PPUSH
11430: LD_VAR 0 2
11434: PPUSH
11435: CALL 47947 0 2
// end ;
11439: PPOPN 2
11441: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
11442: LD_VAR 0 1
11446: PPUSH
11447: LD_VAR 0 2
11451: PPUSH
11452: LD_VAR 0 3
11456: PPUSH
11457: LD_VAR 0 4
11461: PPUSH
11462: CALL 47785 0 4
// end ;
11466: PPOPN 4
11468: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
11469: LD_VAR 0 1
11473: PPUSH
11474: LD_VAR 0 2
11478: PPUSH
11479: LD_VAR 0 3
11483: PPUSH
11484: CALL 47560 0 3
// end ;
11488: PPOPN 3
11490: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
11491: LD_VAR 0 1
11495: PPUSH
11496: LD_VAR 0 2
11500: PPUSH
11501: CALL 47445 0 2
// end ;
11505: PPOPN 2
11507: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
11508: LD_VAR 0 1
11512: PPUSH
11513: LD_VAR 0 2
11517: PPUSH
11518: CALL 51705 0 2
// end ;
11522: PPOPN 2
11524: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
11525: LD_VAR 0 1
11529: PPUSH
11530: LD_VAR 0 2
11534: PPUSH
11535: LD_VAR 0 3
11539: PPUSH
11540: LD_VAR 0 4
11544: PPUSH
11545: CALL 51921 0 4
// end ;
11549: PPOPN 4
11551: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
11552: LD_VAR 0 1
11556: PPUSH
11557: LD_VAR 0 2
11561: PPUSH
11562: CALL 47254 0 2
// end ;
11566: PPOPN 2
11568: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
11569: LD_VAR 0 1
11573: PPUSH
11574: CALL 109381 0 1
// end ; end_of_file
11578: PPOPN 1
11580: END
// export function Action ; begin
11581: LD_INT 0
11583: PPUSH
// InGameOn ;
11584: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
11588: LD_INT 206
11590: PPUSH
11591: LD_INT 11
11593: PPUSH
11594: CALL_OW 86
// wait ( 0 0$1 ) ;
11598: LD_INT 35
11600: PPUSH
11601: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
11605: LD_EXP 19
11609: PPUSH
11610: LD_STRING DStart-JMM-JMM-1
11612: PPUSH
11613: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
11617: LD_EXP 52
11621: PPUSH
11622: LD_STRING DStart-JMM-Bur-1
11624: PPUSH
11625: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
11629: LD_EXP 19
11633: PPUSH
11634: LD_STRING DStart-JMM-JMM-2
11636: PPUSH
11637: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
11641: LD_EXP 52
11645: PPUSH
11646: LD_STRING DStart-JMM-Bur-2
11648: PPUSH
11649: CALL_OW 88
// InGameOff ;
11653: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
11657: LD_STRING MStart
11659: PPUSH
11660: CALL_OW 337
// SaveForQuickRestart ;
11664: CALL_OW 22
// end ;
11668: LD_VAR 0 1
11672: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
11673: LD_INT 7
11675: PPUSH
11676: LD_INT 255
11678: PPUSH
11679: LD_INT 219
11681: PPUSH
11682: CALL_OW 293
11686: IFFALSE 12295
11688: GO 11690
11690: DISABLE
11691: LD_INT 0
11693: PPUSH
// begin wait ( 0 0$3 ) ;
11694: LD_INT 105
11696: PPUSH
11697: CALL_OW 67
// alienSpotted := true ;
11701: LD_ADDR_EXP 10
11705: PUSH
11706: LD_INT 1
11708: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
11709: LD_ADDR_VAR 0 1
11713: PUSH
11714: LD_INT 22
11716: PUSH
11717: LD_INT 7
11719: PUSH
11720: EMPTY
11721: LIST
11722: LIST
11723: PUSH
11724: LD_INT 23
11726: PUSH
11727: LD_INT 3
11729: PUSH
11730: EMPTY
11731: LIST
11732: LIST
11733: PUSH
11734: LD_INT 21
11736: PUSH
11737: LD_INT 1
11739: PUSH
11740: EMPTY
11741: LIST
11742: LIST
11743: PUSH
11744: LD_INT 26
11746: PUSH
11747: LD_INT 1
11749: PUSH
11750: EMPTY
11751: LIST
11752: LIST
11753: PUSH
11754: EMPTY
11755: LIST
11756: LIST
11757: LIST
11758: LIST
11759: PPUSH
11760: CALL_OW 69
11764: PUSH
11765: LD_EXP 52
11769: PUSH
11770: LD_EXP 40
11774: PUSH
11775: LD_EXP 42
11779: PUSH
11780: LD_EXP 43
11784: PUSH
11785: LD_EXP 50
11789: PUSH
11790: LD_EXP 49
11794: PUSH
11795: LD_EXP 44
11799: PUSH
11800: EMPTY
11801: LIST
11802: LIST
11803: LIST
11804: LIST
11805: LIST
11806: LIST
11807: LIST
11808: DIFF
11809: ST_TO_ADDR
// DialogueOn ;
11810: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
11814: LD_INT 255
11816: PPUSH
11817: LD_INT 219
11819: PPUSH
11820: LD_INT 7
11822: PPUSH
11823: LD_INT 20
11825: NEG
11826: PPUSH
11827: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
11831: LD_INT 255
11833: PPUSH
11834: LD_INT 219
11836: PPUSH
11837: CALL_OW 86
// if speaker then
11841: LD_VAR 0 1
11845: IFFALSE 11863
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
11847: LD_VAR 0 1
11851: PUSH
11852: LD_INT 1
11854: ARRAY
11855: PPUSH
11856: LD_STRING DAlienBase-RSol1-1
11858: PPUSH
11859: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
11863: LD_EXP 19
11867: PPUSH
11868: LD_STRING DAlienBase-JMM-1
11870: PPUSH
11871: CALL_OW 88
// if IsOk ( Burlak ) then
11875: LD_EXP 52
11879: PPUSH
11880: CALL_OW 302
11884: IFFALSE 11905
// begin dwait ( 0 0$1 ) ;
11886: LD_INT 35
11888: PPUSH
11889: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
11893: LD_EXP 52
11897: PPUSH
11898: LD_STRING DAlienBase-Bur-1
11900: PPUSH
11901: CALL_OW 88
// end ; if IsOk ( Roth ) then
11905: LD_EXP 20
11909: PPUSH
11910: CALL_OW 302
11914: IFFALSE 11928
// Say ( Roth , DAlienBase-Roth-1 ) ;
11916: LD_EXP 20
11920: PPUSH
11921: LD_STRING DAlienBase-Roth-1
11923: PPUSH
11924: CALL_OW 88
// if IsOk ( Gossudarov ) then
11928: LD_EXP 38
11932: PPUSH
11933: CALL_OW 302
11937: IFFALSE 11953
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
11939: LD_EXP 38
11943: PPUSH
11944: LD_STRING DAlienBase-Gos-1
11946: PPUSH
11947: CALL_OW 88
11951: GO 12070
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11953: LD_ADDR_VAR 0 1
11957: PUSH
11958: LD_INT 22
11960: PUSH
11961: LD_INT 7
11963: PUSH
11964: EMPTY
11965: LIST
11966: LIST
11967: PUSH
11968: LD_INT 25
11970: PUSH
11971: LD_INT 4
11973: PUSH
11974: EMPTY
11975: LIST
11976: LIST
11977: PUSH
11978: LD_INT 21
11980: PUSH
11981: LD_INT 1
11983: PUSH
11984: EMPTY
11985: LIST
11986: LIST
11987: PUSH
11988: LD_INT 26
11990: PUSH
11991: LD_INT 1
11993: PUSH
11994: EMPTY
11995: LIST
11996: LIST
11997: PUSH
11998: EMPTY
11999: LIST
12000: LIST
12001: LIST
12002: LIST
12003: PPUSH
12004: CALL_OW 69
12008: PUSH
12009: LD_EXP 20
12013: PUSH
12014: LD_EXP 19
12018: PUSH
12019: LD_EXP 52
12023: PUSH
12024: LD_EXP 40
12028: PUSH
12029: LD_EXP 50
12033: PUSH
12034: LD_EXP 49
12038: PUSH
12039: EMPTY
12040: LIST
12041: LIST
12042: LIST
12043: LIST
12044: LIST
12045: LIST
12046: DIFF
12047: ST_TO_ADDR
// if speaker then
12048: LD_VAR 0 1
12052: IFFALSE 12070
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
12054: LD_VAR 0 1
12058: PUSH
12059: LD_INT 1
12061: ARRAY
12062: PPUSH
12063: LD_STRING DAlienBase-Sci1-1
12065: PPUSH
12066: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
12070: LD_INT 255
12072: PPUSH
12073: LD_INT 219
12075: PPUSH
12076: LD_INT 7
12078: PPUSH
12079: CALL_OW 331
// DialogueOff ;
12083: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
12087: LD_INT 35
12089: PPUSH
12090: CALL_OW 67
// until IsSelected ( alien ) ;
12094: LD_INT 1
12096: PPUSH
12097: CALL_OW 306
12101: IFFALSE 12087
// if not artifactIResearched or not artifactIIResearched then
12103: LD_EXP 12
12107: NOT
12108: PUSH
12109: LD_EXP 13
12113: NOT
12114: OR
12115: IFFALSE 12295
// begin if IsOk ( Roth ) then
12117: LD_EXP 20
12121: PPUSH
12122: CALL_OW 302
12126: IFFALSE 12142
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
12128: LD_EXP 20
12132: PPUSH
12133: LD_STRING DAlieBaseNotReady-Roth-1
12135: PPUSH
12136: CALL_OW 88
12140: GO 12295
// if IsOk ( Gossudarov ) then
12142: LD_EXP 38
12146: PPUSH
12147: CALL_OW 302
12151: IFFALSE 12167
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
12153: LD_EXP 38
12157: PPUSH
12158: LD_STRING DAlieBaseNotReady-Gos-1
12160: PPUSH
12161: CALL_OW 88
12165: GO 12295
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12167: LD_ADDR_VAR 0 1
12171: PUSH
12172: LD_INT 22
12174: PUSH
12175: LD_INT 7
12177: PUSH
12178: EMPTY
12179: LIST
12180: LIST
12181: PUSH
12182: LD_INT 23
12184: PUSH
12185: LD_INT 3
12187: PUSH
12188: EMPTY
12189: LIST
12190: LIST
12191: PUSH
12192: LD_INT 25
12194: PUSH
12195: LD_INT 4
12197: PUSH
12198: EMPTY
12199: LIST
12200: LIST
12201: PUSH
12202: LD_INT 21
12204: PUSH
12205: LD_INT 1
12207: PUSH
12208: EMPTY
12209: LIST
12210: LIST
12211: PUSH
12212: LD_INT 26
12214: PUSH
12215: LD_INT 1
12217: PUSH
12218: EMPTY
12219: LIST
12220: LIST
12221: PUSH
12222: EMPTY
12223: LIST
12224: LIST
12225: LIST
12226: LIST
12227: LIST
12228: PPUSH
12229: CALL_OW 69
12233: PUSH
12234: LD_EXP 20
12238: PUSH
12239: LD_EXP 19
12243: PUSH
12244: LD_EXP 52
12248: PUSH
12249: LD_EXP 40
12253: PUSH
12254: LD_EXP 50
12258: PUSH
12259: LD_EXP 49
12263: PUSH
12264: EMPTY
12265: LIST
12266: LIST
12267: LIST
12268: LIST
12269: LIST
12270: LIST
12271: DIFF
12272: ST_TO_ADDR
// if speaker then
12273: LD_VAR 0 1
12277: IFFALSE 12295
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
12279: LD_VAR 0 1
12283: PUSH
12284: LD_INT 1
12286: ARRAY
12287: PPUSH
12288: LD_STRING DAlieBaseNotReady-RSci1-1
12290: PPUSH
12291: CALL_OW 88
// end ; end ; end ;
12295: PPOPN 1
12297: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
12298: LD_INT 24
12300: PPUSH
12301: LD_INT 7
12303: PPUSH
12304: CALL_OW 321
12308: PUSH
12309: LD_INT 2
12311: EQUAL
12312: IFFALSE 13003
12314: GO 12316
12316: DISABLE
12317: LD_INT 0
12319: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12320: LD_ADDR_VAR 0 1
12324: PUSH
12325: LD_INT 22
12327: PUSH
12328: LD_INT 7
12330: PUSH
12331: EMPTY
12332: LIST
12333: LIST
12334: PUSH
12335: LD_INT 23
12337: PUSH
12338: LD_INT 3
12340: PUSH
12341: EMPTY
12342: LIST
12343: LIST
12344: PUSH
12345: LD_INT 25
12347: PUSH
12348: LD_INT 4
12350: PUSH
12351: EMPTY
12352: LIST
12353: LIST
12354: PUSH
12355: LD_INT 21
12357: PUSH
12358: LD_INT 1
12360: PUSH
12361: EMPTY
12362: LIST
12363: LIST
12364: PUSH
12365: LD_INT 26
12367: PUSH
12368: LD_INT 1
12370: PUSH
12371: EMPTY
12372: LIST
12373: LIST
12374: PUSH
12375: EMPTY
12376: LIST
12377: LIST
12378: LIST
12379: LIST
12380: LIST
12381: PPUSH
12382: CALL_OW 69
12386: PUSH
12387: LD_EXP 20
12391: PUSH
12392: LD_EXP 19
12396: PUSH
12397: LD_EXP 52
12401: PUSH
12402: LD_EXP 40
12406: PUSH
12407: LD_EXP 50
12411: PUSH
12412: LD_EXP 49
12416: PUSH
12417: EMPTY
12418: LIST
12419: LIST
12420: LIST
12421: LIST
12422: LIST
12423: LIST
12424: DIFF
12425: ST_TO_ADDR
// if not speaker then
12426: LD_VAR 0 1
12430: NOT
12431: IFFALSE 12435
// exit ;
12433: GO 13003
// DialogueOn ;
12435: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
12439: LD_VAR 0 1
12443: PUSH
12444: LD_INT 1
12446: ARRAY
12447: PPUSH
12448: LD_STRING DArtefTechnology-RSci1-1
12450: PPUSH
12451: CALL_OW 88
// if IsOk ( Burlak ) then
12455: LD_EXP 52
12459: PPUSH
12460: CALL_OW 302
12464: IFFALSE 12478
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
12466: LD_EXP 52
12470: PPUSH
12471: LD_STRING DArtefTechnology-Bur-1
12473: PPUSH
12474: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
12478: LD_VAR 0 1
12482: PUSH
12483: LD_INT 1
12485: ARRAY
12486: PPUSH
12487: LD_STRING DArtefTechnology-RSci1-2
12489: PPUSH
12490: CALL_OW 88
// if Denis then
12494: LD_EXP 25
12498: IFFALSE 12515
// speaker := [ Denis ] else
12500: LD_ADDR_VAR 0 1
12504: PUSH
12505: LD_EXP 25
12509: PUSH
12510: EMPTY
12511: LIST
12512: ST_TO_ADDR
12513: GO 12621
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12515: LD_ADDR_VAR 0 1
12519: PUSH
12520: LD_INT 22
12522: PUSH
12523: LD_INT 7
12525: PUSH
12526: EMPTY
12527: LIST
12528: LIST
12529: PUSH
12530: LD_INT 23
12532: PUSH
12533: LD_INT 1
12535: PUSH
12536: EMPTY
12537: LIST
12538: LIST
12539: PUSH
12540: LD_INT 25
12542: PUSH
12543: LD_INT 4
12545: PUSH
12546: EMPTY
12547: LIST
12548: LIST
12549: PUSH
12550: LD_INT 21
12552: PUSH
12553: LD_INT 1
12555: PUSH
12556: EMPTY
12557: LIST
12558: LIST
12559: PUSH
12560: LD_INT 26
12562: PUSH
12563: LD_INT 1
12565: PUSH
12566: EMPTY
12567: LIST
12568: LIST
12569: PUSH
12570: EMPTY
12571: LIST
12572: LIST
12573: LIST
12574: LIST
12575: LIST
12576: PPUSH
12577: CALL_OW 69
12581: PUSH
12582: LD_EXP 20
12586: PUSH
12587: LD_EXP 19
12591: PUSH
12592: LD_EXP 52
12596: PUSH
12597: LD_EXP 40
12601: PUSH
12602: LD_EXP 50
12606: PUSH
12607: LD_EXP 49
12611: PUSH
12612: EMPTY
12613: LIST
12614: LIST
12615: LIST
12616: LIST
12617: LIST
12618: LIST
12619: DIFF
12620: ST_TO_ADDR
// if speaker then
12621: LD_VAR 0 1
12625: IFFALSE 12643
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
12627: LD_VAR 0 1
12631: PUSH
12632: LD_INT 1
12634: ARRAY
12635: PPUSH
12636: LD_STRING DArtefTechnology-Sci1-2
12638: PPUSH
12639: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12643: LD_ADDR_VAR 0 1
12647: PUSH
12648: LD_INT 22
12650: PUSH
12651: LD_INT 7
12653: PUSH
12654: EMPTY
12655: LIST
12656: LIST
12657: PUSH
12658: LD_INT 23
12660: PUSH
12661: LD_INT 3
12663: PUSH
12664: EMPTY
12665: LIST
12666: LIST
12667: PUSH
12668: LD_INT 25
12670: PUSH
12671: LD_INT 4
12673: PUSH
12674: EMPTY
12675: LIST
12676: LIST
12677: PUSH
12678: LD_INT 21
12680: PUSH
12681: LD_INT 1
12683: PUSH
12684: EMPTY
12685: LIST
12686: LIST
12687: PUSH
12688: LD_INT 26
12690: PUSH
12691: LD_INT 1
12693: PUSH
12694: EMPTY
12695: LIST
12696: LIST
12697: PUSH
12698: EMPTY
12699: LIST
12700: LIST
12701: LIST
12702: LIST
12703: LIST
12704: PPUSH
12705: CALL_OW 69
12709: PUSH
12710: LD_EXP 20
12714: PUSH
12715: LD_EXP 19
12719: PUSH
12720: LD_EXP 52
12724: PUSH
12725: LD_EXP 40
12729: PUSH
12730: LD_EXP 50
12734: PUSH
12735: LD_EXP 49
12739: PUSH
12740: EMPTY
12741: LIST
12742: LIST
12743: LIST
12744: LIST
12745: LIST
12746: LIST
12747: DIFF
12748: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
12749: LD_VAR 0 1
12753: PUSH
12754: LD_EXP 9
12758: PUSH
12759: LD_EXP 5
12763: OR
12764: AND
12765: IFFALSE 12999
// begin if arabianDestroyed and IsOk ( Burlak ) then
12767: LD_EXP 5
12771: PUSH
12772: LD_EXP 52
12776: PPUSH
12777: CALL_OW 302
12781: AND
12782: IFFALSE 12798
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
12784: LD_EXP 52
12788: PPUSH
12789: LD_STRING DArtefTechnology-Bur-2
12791: PPUSH
12792: CALL_OW 88
12796: GO 12810
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
12798: LD_EXP 19
12802: PPUSH
12803: LD_STRING DArtefTechnology-JMM-2
12805: PPUSH
12806: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
12810: LD_VAR 0 1
12814: PUSH
12815: LD_INT 1
12817: ARRAY
12818: PPUSH
12819: LD_STRING DArtefTechnology-RSci1-3
12821: PPUSH
12822: CALL_OW 88
// if Denis then
12826: LD_EXP 25
12830: IFFALSE 12847
// speaker := [ Denis ] else
12832: LD_ADDR_VAR 0 1
12836: PUSH
12837: LD_EXP 25
12841: PUSH
12842: EMPTY
12843: LIST
12844: ST_TO_ADDR
12845: GO 12953
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12847: LD_ADDR_VAR 0 1
12851: PUSH
12852: LD_INT 22
12854: PUSH
12855: LD_INT 7
12857: PUSH
12858: EMPTY
12859: LIST
12860: LIST
12861: PUSH
12862: LD_INT 23
12864: PUSH
12865: LD_INT 1
12867: PUSH
12868: EMPTY
12869: LIST
12870: LIST
12871: PUSH
12872: LD_INT 25
12874: PUSH
12875: LD_INT 4
12877: PUSH
12878: EMPTY
12879: LIST
12880: LIST
12881: PUSH
12882: LD_INT 21
12884: PUSH
12885: LD_INT 1
12887: PUSH
12888: EMPTY
12889: LIST
12890: LIST
12891: PUSH
12892: LD_INT 26
12894: PUSH
12895: LD_INT 1
12897: PUSH
12898: EMPTY
12899: LIST
12900: LIST
12901: PUSH
12902: EMPTY
12903: LIST
12904: LIST
12905: LIST
12906: LIST
12907: LIST
12908: PPUSH
12909: CALL_OW 69
12913: PUSH
12914: LD_EXP 20
12918: PUSH
12919: LD_EXP 19
12923: PUSH
12924: LD_EXP 52
12928: PUSH
12929: LD_EXP 40
12933: PUSH
12934: LD_EXP 50
12938: PUSH
12939: LD_EXP 49
12943: PUSH
12944: EMPTY
12945: LIST
12946: LIST
12947: LIST
12948: LIST
12949: LIST
12950: LIST
12951: DIFF
12952: ST_TO_ADDR
// if speaker then
12953: LD_VAR 0 1
12957: IFFALSE 12999
// if alienSpotted then
12959: LD_EXP 10
12963: IFFALSE 12983
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
12965: LD_VAR 0 1
12969: PUSH
12970: LD_INT 1
12972: ARRAY
12973: PPUSH
12974: LD_STRING DArtefTechnology-Sci1-3
12976: PPUSH
12977: CALL_OW 88
12981: GO 12999
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
12983: LD_VAR 0 1
12987: PUSH
12988: LD_INT 1
12990: ARRAY
12991: PPUSH
12992: LD_STRING DArtefTechnology-Sci1-3a
12994: PPUSH
12995: CALL_OW 88
// end ; DialogueOff ;
12999: CALL_OW 7
// end ;
13003: PPOPN 1
13005: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
13006: LD_EXP 12
13010: IFFALSE 13213
13012: GO 13014
13014: DISABLE
13015: LD_INT 0
13017: PPUSH
// begin if Denis then
13018: LD_EXP 25
13022: IFFALSE 13039
// speaker := [ Denis ] else
13024: LD_ADDR_VAR 0 1
13028: PUSH
13029: LD_EXP 25
13033: PUSH
13034: EMPTY
13035: LIST
13036: ST_TO_ADDR
13037: GO 13145
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13039: LD_ADDR_VAR 0 1
13043: PUSH
13044: LD_INT 22
13046: PUSH
13047: LD_INT 7
13049: PUSH
13050: EMPTY
13051: LIST
13052: LIST
13053: PUSH
13054: LD_INT 23
13056: PUSH
13057: LD_INT 1
13059: PUSH
13060: EMPTY
13061: LIST
13062: LIST
13063: PUSH
13064: LD_INT 25
13066: PUSH
13067: LD_INT 4
13069: PUSH
13070: EMPTY
13071: LIST
13072: LIST
13073: PUSH
13074: LD_INT 21
13076: PUSH
13077: LD_INT 1
13079: PUSH
13080: EMPTY
13081: LIST
13082: LIST
13083: PUSH
13084: LD_INT 26
13086: PUSH
13087: LD_INT 1
13089: PUSH
13090: EMPTY
13091: LIST
13092: LIST
13093: PUSH
13094: EMPTY
13095: LIST
13096: LIST
13097: LIST
13098: LIST
13099: LIST
13100: PPUSH
13101: CALL_OW 69
13105: PUSH
13106: LD_EXP 20
13110: PUSH
13111: LD_EXP 19
13115: PUSH
13116: LD_EXP 52
13120: PUSH
13121: LD_EXP 40
13125: PUSH
13126: LD_EXP 50
13130: PUSH
13131: LD_EXP 49
13135: PUSH
13136: EMPTY
13137: LIST
13138: LIST
13139: LIST
13140: LIST
13141: LIST
13142: LIST
13143: DIFF
13144: ST_TO_ADDR
// if not speaker then
13145: LD_VAR 0 1
13149: NOT
13150: IFFALSE 13154
// exit ;
13152: GO 13213
// DialogueOn ;
13154: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
13158: LD_VAR 0 1
13162: PUSH
13163: LD_INT 1
13165: ARRAY
13166: PPUSH
13167: LD_STRING DArtefTechnologyAm-Sci1-1
13169: PPUSH
13170: CALL_OW 88
// if IsOk ( Burlak ) then
13174: LD_EXP 52
13178: PPUSH
13179: CALL_OW 302
13183: IFFALSE 13197
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
13185: LD_EXP 52
13189: PPUSH
13190: LD_STRING DArtefTechnologyAm-Bur-1
13192: PPUSH
13193: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
13197: LD_EXP 19
13201: PPUSH
13202: LD_STRING DArtefTechnologyAm-JMM-1
13204: PPUSH
13205: CALL_OW 88
// DialogueOff ;
13209: CALL_OW 7
// end ;
13213: PPOPN 1
13215: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
13216: LD_EXP 13
13220: IFFALSE 13422
13222: GO 13224
13224: DISABLE
13225: LD_INT 0
13227: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13228: LD_ADDR_VAR 0 1
13232: PUSH
13233: LD_INT 22
13235: PUSH
13236: LD_INT 7
13238: PUSH
13239: EMPTY
13240: LIST
13241: LIST
13242: PUSH
13243: LD_INT 23
13245: PUSH
13246: LD_INT 3
13248: PUSH
13249: EMPTY
13250: LIST
13251: LIST
13252: PUSH
13253: LD_INT 25
13255: PUSH
13256: LD_INT 4
13258: PUSH
13259: EMPTY
13260: LIST
13261: LIST
13262: PUSH
13263: LD_INT 21
13265: PUSH
13266: LD_INT 1
13268: PUSH
13269: EMPTY
13270: LIST
13271: LIST
13272: PUSH
13273: LD_INT 26
13275: PUSH
13276: LD_INT 1
13278: PUSH
13279: EMPTY
13280: LIST
13281: LIST
13282: PUSH
13283: EMPTY
13284: LIST
13285: LIST
13286: LIST
13287: LIST
13288: LIST
13289: PPUSH
13290: CALL_OW 69
13294: PUSH
13295: LD_EXP 20
13299: PUSH
13300: LD_EXP 19
13304: PUSH
13305: LD_EXP 52
13309: PUSH
13310: LD_EXP 40
13314: PUSH
13315: LD_EXP 50
13319: PUSH
13320: LD_EXP 49
13324: PUSH
13325: EMPTY
13326: LIST
13327: LIST
13328: LIST
13329: LIST
13330: LIST
13331: LIST
13332: DIFF
13333: ST_TO_ADDR
// if not speaker then
13334: LD_VAR 0 1
13338: NOT
13339: IFFALSE 13343
// exit ;
13341: GO 13422
// DialogueOn ;
13343: CALL_OW 6
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-1 ) ;
13347: LD_VAR 0 1
13351: PUSH
13352: LD_VAR 0 1
13356: ARRAY
13357: PPUSH
13358: LD_STRING DArtefTechnologyRu-RSci1-1
13360: PPUSH
13361: CALL_OW 88
// if IsOk ( Burlak ) then
13365: LD_EXP 52
13369: PPUSH
13370: CALL_OW 302
13374: IFFALSE 13388
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
13376: LD_EXP 52
13380: PPUSH
13381: LD_STRING DArtefTechnologyRu-Bur-1
13383: PPUSH
13384: CALL_OW 88
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-2 ) ;
13388: LD_VAR 0 1
13392: PUSH
13393: LD_VAR 0 1
13397: ARRAY
13398: PPUSH
13399: LD_STRING DArtefTechnologyRu-RSci1-2
13401: PPUSH
13402: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
13406: LD_EXP 19
13410: PPUSH
13411: LD_STRING DArtefTechnologyRu-JMM-1
13413: PPUSH
13414: CALL_OW 88
// DialogueOff ;
13418: CALL_OW 7
// end ;
13422: PPOPN 1
13424: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
13425: LD_INT 24
13427: PPUSH
13428: LD_INT 7
13430: PPUSH
13431: CALL_OW 321
13435: PUSH
13436: LD_INT 2
13438: EQUAL
13439: PUSH
13440: LD_INT 1
13442: PPUSH
13443: CALL_OW 255
13447: PUSH
13448: LD_INT 7
13450: EQUAL
13451: AND
13452: IFFALSE 13620
13454: GO 13456
13456: DISABLE
13457: LD_INT 0
13459: PPUSH
// begin if Denis then
13460: LD_EXP 25
13464: IFFALSE 13481
// speaker := [ Denis ] else
13466: LD_ADDR_VAR 0 1
13470: PUSH
13471: LD_EXP 25
13475: PUSH
13476: EMPTY
13477: LIST
13478: ST_TO_ADDR
13479: GO 13587
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13481: LD_ADDR_VAR 0 1
13485: PUSH
13486: LD_INT 22
13488: PUSH
13489: LD_INT 7
13491: PUSH
13492: EMPTY
13493: LIST
13494: LIST
13495: PUSH
13496: LD_INT 23
13498: PUSH
13499: LD_INT 1
13501: PUSH
13502: EMPTY
13503: LIST
13504: LIST
13505: PUSH
13506: LD_INT 25
13508: PUSH
13509: LD_INT 4
13511: PUSH
13512: EMPTY
13513: LIST
13514: LIST
13515: PUSH
13516: LD_INT 21
13518: PUSH
13519: LD_INT 1
13521: PUSH
13522: EMPTY
13523: LIST
13524: LIST
13525: PUSH
13526: LD_INT 26
13528: PUSH
13529: LD_INT 1
13531: PUSH
13532: EMPTY
13533: LIST
13534: LIST
13535: PUSH
13536: EMPTY
13537: LIST
13538: LIST
13539: LIST
13540: LIST
13541: LIST
13542: PPUSH
13543: CALL_OW 69
13547: PUSH
13548: LD_EXP 20
13552: PUSH
13553: LD_EXP 19
13557: PUSH
13558: LD_EXP 52
13562: PUSH
13563: LD_EXP 40
13567: PUSH
13568: LD_EXP 50
13572: PUSH
13573: LD_EXP 49
13577: PUSH
13578: EMPTY
13579: LIST
13580: LIST
13581: LIST
13582: LIST
13583: LIST
13584: LIST
13585: DIFF
13586: ST_TO_ADDR
// if not speaker then
13587: LD_VAR 0 1
13591: NOT
13592: IFFALSE 13596
// exit ;
13594: GO 13620
// DialogueOn ;
13596: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
13600: LD_VAR 0 1
13604: PUSH
13605: LD_INT 1
13607: ARRAY
13608: PPUSH
13609: LD_STRING DArtefTechnologyArStart-Sci1-1
13611: PPUSH
13612: CALL_OW 88
// DialogueOff ;
13616: CALL_OW 7
// end ;
13620: PPOPN 1
13622: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
13623: LD_EXP 14
13627: IFFALSE 13908
13629: GO 13631
13631: DISABLE
13632: LD_INT 0
13634: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13635: LD_ADDR_VAR 0 1
13639: PUSH
13640: LD_INT 22
13642: PUSH
13643: LD_INT 7
13645: PUSH
13646: EMPTY
13647: LIST
13648: LIST
13649: PUSH
13650: LD_INT 23
13652: PUSH
13653: LD_INT 3
13655: PUSH
13656: EMPTY
13657: LIST
13658: LIST
13659: PUSH
13660: LD_INT 25
13662: PUSH
13663: LD_INT 4
13665: PUSH
13666: EMPTY
13667: LIST
13668: LIST
13669: PUSH
13670: LD_INT 21
13672: PUSH
13673: LD_INT 1
13675: PUSH
13676: EMPTY
13677: LIST
13678: LIST
13679: PUSH
13680: LD_INT 26
13682: PUSH
13683: LD_INT 1
13685: PUSH
13686: EMPTY
13687: LIST
13688: LIST
13689: PUSH
13690: EMPTY
13691: LIST
13692: LIST
13693: LIST
13694: LIST
13695: LIST
13696: PPUSH
13697: CALL_OW 69
13701: PUSH
13702: LD_EXP 20
13706: PUSH
13707: LD_EXP 19
13711: PUSH
13712: LD_EXP 52
13716: PUSH
13717: LD_EXP 40
13721: PUSH
13722: LD_EXP 50
13726: PUSH
13727: LD_EXP 49
13731: PUSH
13732: EMPTY
13733: LIST
13734: LIST
13735: LIST
13736: LIST
13737: LIST
13738: LIST
13739: DIFF
13740: ST_TO_ADDR
// if not speaker then
13741: LD_VAR 0 1
13745: NOT
13746: IFFALSE 13750
// exit ;
13748: GO 13908
// DialogueOn ;
13750: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
13754: LD_VAR 0 1
13758: PUSH
13759: LD_INT 1
13761: ARRAY
13762: PPUSH
13763: LD_STRING DArtefTechnologyAr-RSci1-1
13765: PPUSH
13766: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
13770: LD_EXP 19
13774: PPUSH
13775: LD_STRING DArtefTechnologyAr-JMM-1
13777: PPUSH
13778: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
13782: LD_VAR 0 1
13786: PUSH
13787: LD_INT 1
13789: ARRAY
13790: PPUSH
13791: LD_STRING DArtefTechnologyAr-RSci1-2
13793: PPUSH
13794: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
13798: LD_EXP 19
13802: PPUSH
13803: LD_STRING DArtefTechnologyAr-JMM-2
13805: PPUSH
13806: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
13810: LD_VAR 0 1
13814: PUSH
13815: LD_INT 1
13817: ARRAY
13818: PPUSH
13819: LD_STRING DArtefTechnologyAr-RSci1-3
13821: PPUSH
13822: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
13826: LD_EXP 19
13830: PPUSH
13831: LD_STRING DArtefTechnologyAr-JMM-3
13833: PPUSH
13834: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
13838: LD_VAR 0 1
13842: PUSH
13843: LD_INT 1
13845: ARRAY
13846: PPUSH
13847: LD_STRING DArtefTechnologyAr-RSci1-4
13849: PPUSH
13850: CALL_OW 88
// if IsOk ( Burlak ) then
13854: LD_EXP 52
13858: PPUSH
13859: CALL_OW 302
13863: IFFALSE 13877
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
13865: LD_EXP 52
13869: PPUSH
13870: LD_STRING DArtefTechnologyAr-Bur-4
13872: PPUSH
13873: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
13877: LD_EXP 19
13881: PPUSH
13882: LD_STRING DArtefTechnologyAr-JMM-4
13884: PPUSH
13885: CALL_OW 88
// DialogueOff ;
13889: CALL_OW 7
// wait ( 0 0$45 ) ;
13893: LD_INT 1575
13895: PPUSH
13896: CALL_OW 67
// spawnOmar := true ;
13900: LD_ADDR_EXP 11
13904: PUSH
13905: LD_INT 1
13907: ST_TO_ADDR
// end ;
13908: PPOPN 1
13910: END
// every 0 0$1 trigger spawnOmar do
13911: LD_EXP 11
13915: IFFALSE 14295
13917: GO 13919
13919: DISABLE
// begin PrepareOmarAli ;
13920: CALL 7301 0 0
// if not HasTask ( Omar ) then
13924: LD_EXP 56
13928: PPUSH
13929: CALL_OW 314
13933: NOT
13934: IFFALSE 13951
// ComMoveXY ( Omar , 252 , 220 ) ;
13936: LD_EXP 56
13940: PPUSH
13941: LD_INT 252
13943: PPUSH
13944: LD_INT 220
13946: PPUSH
13947: CALL_OW 111
// if not Omar then
13951: LD_EXP 56
13955: NOT
13956: IFFALSE 13960
// exit ;
13958: GO 14295
// repeat wait ( 0 0$1 ) ;
13960: LD_INT 35
13962: PPUSH
13963: CALL_OW 67
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
13967: LD_EXP 56
13971: PPUSH
13972: CALL_OW 314
13976: NOT
13977: PUSH
13978: LD_EXP 56
13982: PPUSH
13983: LD_INT 252
13985: PPUSH
13986: LD_INT 220
13988: PPUSH
13989: CALL_OW 297
13993: PUSH
13994: LD_INT 6
13996: GREATER
13997: AND
13998: IFFALSE 14015
// ComMoveXY ( Omar , 252 , 220 ) ;
14000: LD_EXP 56
14004: PPUSH
14005: LD_INT 252
14007: PPUSH
14008: LD_INT 220
14010: PPUSH
14011: CALL_OW 111
// until See ( 7 , Omar ) ;
14015: LD_INT 7
14017: PPUSH
14018: LD_EXP 56
14022: PPUSH
14023: CALL_OW 292
14027: IFFALSE 13960
// CenterNowOnUnits ( Omar ) ;
14029: LD_EXP 56
14033: PPUSH
14034: CALL_OW 87
// DialogueOn ;
14038: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
14042: LD_EXP 56
14046: PPUSH
14047: LD_STRING DOmar-Omar-1
14049: PPUSH
14050: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
14054: LD_EXP 19
14058: PPUSH
14059: LD_STRING DOmar-JMM-1
14061: PPUSH
14062: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
14066: LD_EXP 56
14070: PPUSH
14071: LD_STRING DOmar-Omar-2
14073: PPUSH
14074: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
14078: LD_EXP 19
14082: PPUSH
14083: LD_STRING DOmar-JMM-2
14085: PPUSH
14086: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
14090: LD_EXP 56
14094: PPUSH
14095: LD_STRING DOmar-Omar-3
14097: PPUSH
14098: CALL_OW 88
// if IsOk ( Burlak ) then
14102: LD_EXP 52
14106: PPUSH
14107: CALL_OW 302
14111: IFFALSE 14127
// Say ( Burlak , DOmar-Bur-3 ) else
14113: LD_EXP 52
14117: PPUSH
14118: LD_STRING DOmar-Bur-3
14120: PPUSH
14121: CALL_OW 88
14125: GO 14139
// Say ( JMM , DOmar-JMM-3 ) ;
14127: LD_EXP 19
14131: PPUSH
14132: LD_STRING DOmar-JMM-3
14134: PPUSH
14135: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
14139: LD_EXP 56
14143: PPUSH
14144: LD_STRING DOmar-Omar-4
14146: PPUSH
14147: CALL_OW 88
// case Query ( QAccept ) of 1 :
14151: LD_STRING QAccept
14153: PPUSH
14154: CALL_OW 97
14158: PUSH
14159: LD_INT 1
14161: DOUBLE
14162: EQUAL
14163: IFTRUE 14167
14165: GO 14203
14167: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
14168: LD_EXP 19
14172: PPUSH
14173: LD_STRING DQrAccept#1-JMM-1
14175: PPUSH
14176: CALL_OW 88
// SetSide ( Omar , 7 ) ;
14180: LD_EXP 56
14184: PPUSH
14185: LD_INT 7
14187: PPUSH
14188: CALL_OW 235
// ComStop ( Omar ) ;
14192: LD_EXP 56
14196: PPUSH
14197: CALL_OW 141
// end ; 2 :
14201: GO 14252
14203: LD_INT 2
14205: DOUBLE
14206: EQUAL
14207: IFTRUE 14211
14209: GO 14251
14211: POP
// begin if IsOk ( Burlak ) then
14212: LD_EXP 52
14216: PPUSH
14217: CALL_OW 302
14221: IFFALSE 14237
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
14223: LD_EXP 52
14227: PPUSH
14228: LD_STRING DQrAccept#2-Bur-1
14230: PPUSH
14231: CALL_OW 88
14235: GO 14249
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
14237: LD_EXP 19
14241: PPUSH
14242: LD_STRING DQrAccept#2-JMM-1
14244: PPUSH
14245: CALL_OW 88
// end ; end ;
14249: GO 14252
14251: POP
// DialogueOff ;
14252: CALL_OW 7
// if GetSide ( Omar ) = 7 then
14256: LD_EXP 56
14260: PPUSH
14261: CALL_OW 255
14265: PUSH
14266: LD_INT 7
14268: EQUAL
14269: IFFALSE 14280
// begin SetAchievement ( ACH_OMAR ) ;
14271: LD_STRING ACH_OMAR
14273: PPUSH
14274: CALL_OW 543
// exit ;
14278: GO 14295
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
14280: LD_EXP 56
14284: PPUSH
14285: LD_INT 202
14287: PPUSH
14288: LD_INT 115
14290: PPUSH
14291: CALL_OW 111
// end ;
14295: END
// every 0 0$1 trigger GetDistUnitXY ( Omar , 200 , 98 ) < 40 and russianDestroyed do
14296: LD_EXP 56
14300: PPUSH
14301: LD_INT 200
14303: PPUSH
14304: LD_INT 98
14306: PPUSH
14307: CALL_OW 297
14311: PUSH
14312: LD_INT 40
14314: LESS
14315: PUSH
14316: LD_EXP 2
14320: AND
14321: IFFALSE 14539
14323: GO 14325
14325: DISABLE
// begin SetSide ( Omar , 5 ) ;
14326: LD_EXP 56
14330: PPUSH
14331: LD_INT 5
14333: PPUSH
14334: CALL_OW 235
// if IsInUnit ( Omar ) then
14338: LD_EXP 56
14342: PPUSH
14343: CALL_OW 310
14347: IFFALSE 14358
// ComExitVehicle ( Omar ) ;
14349: LD_EXP 56
14353: PPUSH
14354: CALL_OW 121
// if IsInUnit ( Omar ) then
14358: LD_EXP 56
14362: PPUSH
14363: CALL_OW 310
14367: IFFALSE 14378
// ComExitBuilding ( Omar ) ;
14369: LD_EXP 56
14373: PPUSH
14374: CALL_OW 122
// wait ( 0 0$1 ) ;
14378: LD_INT 35
14380: PPUSH
14381: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
14385: LD_EXP 56
14389: PPUSH
14390: LD_INT 203
14392: PPUSH
14393: LD_INT 120
14395: PPUSH
14396: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
14400: LD_INT 35
14402: PPUSH
14403: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 6 ;
14407: LD_EXP 56
14411: PPUSH
14412: CALL_OW 306
14416: PUSH
14417: LD_EXP 56
14421: PPUSH
14422: LD_INT 203
14424: PPUSH
14425: LD_INT 120
14427: PPUSH
14428: CALL_OW 297
14432: PUSH
14433: LD_INT 6
14435: LESS
14436: OR
14437: IFFALSE 14400
// CenterNowOnUnits ( Omar ) ;
14439: LD_EXP 56
14443: PPUSH
14444: CALL_OW 87
// DialogueOn ;
14448: CALL_OW 6
// Say ( JMM , DOmarContam-JMM-1 ) ;
14452: LD_EXP 19
14456: PPUSH
14457: LD_STRING DOmarContam-JMM-1
14459: PPUSH
14460: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
14464: LD_EXP 56
14468: PPUSH
14469: LD_STRING DOmarContam-Omar-1
14471: PPUSH
14472: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
14476: LD_EXP 19
14480: PPUSH
14481: LD_STRING DOmarContam-JMM-2
14483: PPUSH
14484: CALL_OW 88
// DialogueOff ;
14488: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
14492: LD_INT 5
14494: PPUSH
14495: LD_INT 7
14497: PPUSH
14498: LD_INT 2
14500: PPUSH
14501: LD_INT 1
14503: PPUSH
14504: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
14508: LD_INT 105
14510: PPUSH
14511: CALL_OW 67
// until IsAt ( Omar , 203 , 120 ) ;
14515: LD_EXP 56
14519: PPUSH
14520: LD_INT 203
14522: PPUSH
14523: LD_INT 120
14525: PPUSH
14526: CALL_OW 307
14530: IFFALSE 14508
// YouLost ( MothContaminate ) ;
14532: LD_STRING MothContaminate
14534: PPUSH
14535: CALL_OW 104
// end ;
14539: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
14540: LD_EXP 4
14544: NOT
14545: PUSH
14546: LD_INT 22
14548: PUSH
14549: LD_INT 1
14551: PUSH
14552: EMPTY
14553: LIST
14554: LIST
14555: PUSH
14556: LD_INT 34
14558: PUSH
14559: LD_INT 8
14561: PUSH
14562: EMPTY
14563: LIST
14564: LIST
14565: PUSH
14566: EMPTY
14567: LIST
14568: LIST
14569: PPUSH
14570: CALL_OW 69
14574: AND
14575: IFFALSE 14694
14577: GO 14579
14579: DISABLE
// begin wait ( 0 0$5 ) ;
14580: LD_INT 175
14582: PPUSH
14583: CALL_OW 67
// if not IsOk ( Powell ) or not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
14587: LD_EXP 55
14591: PPUSH
14592: CALL_OW 302
14596: NOT
14597: PUSH
14598: LD_INT 22
14600: PUSH
14601: LD_INT 1
14603: PUSH
14604: EMPTY
14605: LIST
14606: LIST
14607: PUSH
14608: LD_INT 34
14610: PUSH
14611: LD_INT 8
14613: PUSH
14614: EMPTY
14615: LIST
14616: LIST
14617: PUSH
14618: EMPTY
14619: LIST
14620: LIST
14621: PPUSH
14622: CALL_OW 69
14626: NOT
14627: OR
14628: IFFALSE 14632
// exit ;
14630: GO 14694
// DialogueOn ;
14632: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
14636: LD_EXP 55
14640: PPUSH
14641: LD_STRING DWinAmericans-Pow-1
14643: PPUSH
14644: CALL_OW 94
// if IsOk ( Burlak ) then
14648: LD_EXP 52
14652: PPUSH
14653: CALL_OW 302
14657: IFFALSE 14671
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
14659: LD_EXP 52
14663: PPUSH
14664: LD_STRING DWinAmericans-Bur-1
14666: PPUSH
14667: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
14671: LD_EXP 19
14675: PPUSH
14676: LD_STRING DWinAmericans-JMM-1
14678: PPUSH
14679: CALL_OW 88
// DialogueOff ;
14683: CALL_OW 7
// YouLost ( AmBomb ) ;
14687: LD_STRING AmBomb
14689: PPUSH
14690: CALL_OW 104
// end ;
14694: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
14695: LD_EXP 2
14699: NOT
14700: PUSH
14701: LD_INT 22
14703: PUSH
14704: LD_INT 3
14706: PUSH
14707: EMPTY
14708: LIST
14709: LIST
14710: PUSH
14711: LD_INT 34
14713: PUSH
14714: LD_INT 48
14716: PUSH
14717: EMPTY
14718: LIST
14719: LIST
14720: PUSH
14721: EMPTY
14722: LIST
14723: LIST
14724: PPUSH
14725: CALL_OW 69
14729: AND
14730: IFFALSE 14849
14732: GO 14734
14734: DISABLE
// begin wait ( 0 0$5 ) ;
14735: LD_INT 175
14737: PPUSH
14738: CALL_OW 67
// if not IsOk ( Platonov ) or not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
14742: LD_EXP 59
14746: PPUSH
14747: CALL_OW 302
14751: NOT
14752: PUSH
14753: LD_INT 22
14755: PUSH
14756: LD_INT 3
14758: PUSH
14759: EMPTY
14760: LIST
14761: LIST
14762: PUSH
14763: LD_INT 34
14765: PUSH
14766: LD_INT 48
14768: PUSH
14769: EMPTY
14770: LIST
14771: LIST
14772: PUSH
14773: EMPTY
14774: LIST
14775: LIST
14776: PPUSH
14777: CALL_OW 69
14781: NOT
14782: OR
14783: IFFALSE 14787
// exit ;
14785: GO 14849
// DialogueOn ;
14787: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
14791: LD_EXP 59
14795: PPUSH
14796: LD_STRING DWinRussians-Pla-1
14798: PPUSH
14799: CALL_OW 94
// if IsOk ( Burlak ) then
14803: LD_EXP 52
14807: PPUSH
14808: CALL_OW 302
14812: IFFALSE 14826
// Say ( Burlak , DWinRussians-Bur-1 ) ;
14814: LD_EXP 52
14818: PPUSH
14819: LD_STRING DWinRussians-Bur-1
14821: PPUSH
14822: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
14826: LD_EXP 19
14830: PPUSH
14831: LD_STRING DWinRussians-JMM-1
14833: PPUSH
14834: CALL_OW 88
// DialogueOff ;
14838: CALL_OW 7
// YouLost ( RuBomb ) ;
14842: LD_STRING RuBomb
14844: PPUSH
14845: CALL_OW 104
// end ;
14849: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
14850: LD_INT 7
14852: PPUSH
14853: LD_INT 22
14855: PUSH
14856: LD_INT 7
14858: PUSH
14859: EMPTY
14860: LIST
14861: LIST
14862: PPUSH
14863: CALL_OW 70
14867: PUSH
14868: LD_EXP 4
14872: NOT
14873: AND
14874: IFFALSE 14903
14876: GO 14878
14878: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
14879: LD_EXP 55
14883: PPUSH
14884: LD_STRING DSurrenderAmericans-Pow-1
14886: PPUSH
14887: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
14891: LD_EXP 19
14895: PPUSH
14896: LD_STRING DSurrenderAmericans-JMM-1
14898: PPUSH
14899: CALL_OW 88
// end ;
14903: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
14904: LD_INT 2
14906: PPUSH
14907: LD_INT 22
14909: PUSH
14910: LD_INT 7
14912: PUSH
14913: EMPTY
14914: LIST
14915: LIST
14916: PPUSH
14917: CALL_OW 70
14921: PUSH
14922: LD_EXP 2
14926: NOT
14927: AND
14928: PUSH
14929: LD_EXP 52
14933: AND
14934: IFFALSE 14963
14936: GO 14938
14938: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
14939: LD_EXP 59
14943: PPUSH
14944: LD_STRING DSurrenderRussians-Pla-1
14946: PPUSH
14947: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
14951: LD_EXP 52
14955: PPUSH
14956: LD_STRING DSurrenderRussians-Bur-1
14958: PPUSH
14959: CALL_OW 88
// end ;
14963: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
14964: LD_EXP 4
14968: IFFALSE 15351
14970: GO 14972
14972: DISABLE
14973: LD_INT 0
14975: PPUSH
14976: PPUSH
14977: PPUSH
// begin MC_Kill ( 4 ) ;
14978: LD_INT 4
14980: PPUSH
14981: CALL 21609 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
14985: LD_INT 1
14987: PPUSH
14988: LD_INT 7
14990: PPUSH
14991: LD_INT 1
14993: PPUSH
14994: LD_INT 1
14996: PPUSH
14997: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
15001: LD_ADDR_VAR 0 3
15005: PUSH
15006: LD_INT 22
15008: PUSH
15009: LD_INT 1
15011: PUSH
15012: EMPTY
15013: LIST
15014: LIST
15015: PUSH
15016: LD_INT 26
15018: PUSH
15019: LD_INT 1
15021: PUSH
15022: EMPTY
15023: LIST
15024: LIST
15025: PUSH
15026: LD_INT 23
15028: PUSH
15029: LD_INT 1
15031: PUSH
15032: EMPTY
15033: LIST
15034: LIST
15035: PUSH
15036: EMPTY
15037: LIST
15038: LIST
15039: LIST
15040: PPUSH
15041: CALL_OW 69
15045: PUSH
15046: LD_EXP 55
15050: PUSH
15051: LD_EXP 27
15055: PUSH
15056: LD_EXP 24
15060: PUSH
15061: LD_EXP 23
15065: PUSH
15066: LD_EXP 30
15070: PUSH
15071: LD_EXP 28
15075: PUSH
15076: EMPTY
15077: LIST
15078: LIST
15079: LIST
15080: LIST
15081: LIST
15082: LIST
15083: DIFF
15084: ST_TO_ADDR
// if speaker then
15085: LD_VAR 0 3
15089: IFFALSE 15115
// begin DialogueOn ;
15091: CALL_OW 6
// SayRadio ( speaker [ 1 ] , DSurrenderAmericans-Sol1-1a ) ;
15095: LD_VAR 0 3
15099: PUSH
15100: LD_INT 1
15102: ARRAY
15103: PPUSH
15104: LD_STRING DSurrenderAmericans-Sol1-1a
15106: PPUSH
15107: CALL_OW 94
// DialogueOff ;
15111: CALL_OW 7
// end ; americanCapitulated := true ;
15115: LD_ADDR_EXP 6
15119: PUSH
15120: LD_INT 1
15122: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15123: LD_ADDR_VAR 0 2
15127: PUSH
15128: LD_INT 22
15130: PUSH
15131: LD_INT 1
15133: PUSH
15134: EMPTY
15135: LIST
15136: LIST
15137: PUSH
15138: LD_INT 21
15140: PUSH
15141: LD_INT 1
15143: PUSH
15144: EMPTY
15145: LIST
15146: LIST
15147: PUSH
15148: EMPTY
15149: LIST
15150: LIST
15151: PPUSH
15152: CALL_OW 69
15156: PUSH
15157: LD_INT 22
15159: PUSH
15160: LD_INT 1
15162: PUSH
15163: EMPTY
15164: LIST
15165: LIST
15166: PUSH
15167: LD_INT 21
15169: PUSH
15170: LD_INT 2
15172: PUSH
15173: EMPTY
15174: LIST
15175: LIST
15176: PUSH
15177: LD_INT 1
15179: PUSH
15180: EMPTY
15181: LIST
15182: PUSH
15183: EMPTY
15184: LIST
15185: LIST
15186: LIST
15187: PPUSH
15188: CALL_OW 69
15192: ADD
15193: ST_TO_ADDR
// if tmp then
15194: LD_VAR 0 2
15198: IFFALSE 15351
// repeat wait ( 0 0$1 ) ;
15200: LD_INT 35
15202: PPUSH
15203: CALL_OW 67
// for i in tmp do
15207: LD_ADDR_VAR 0 1
15211: PUSH
15212: LD_VAR 0 2
15216: PUSH
15217: FOR_IN
15218: IFFALSE 15300
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15220: LD_VAR 0 1
15224: PPUSH
15225: CALL_OW 310
15229: PUSH
15230: LD_VAR 0 1
15234: PPUSH
15235: CALL_OW 310
15239: PPUSH
15240: CALL_OW 247
15244: PUSH
15245: LD_INT 3
15247: EQUAL
15248: AND
15249: IFFALSE 15260
// ComExitBuilding ( i ) ;
15251: LD_VAR 0 1
15255: PPUSH
15256: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
15260: LD_VAR 0 1
15264: PPUSH
15265: LD_INT 122
15267: PPUSH
15268: LD_INT 242
15270: PPUSH
15271: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
15275: LD_VAR 0 1
15279: PPUSH
15280: LD_INT 35
15282: PPUSH
15283: CALL_OW 308
15287: IFFALSE 15298
// RemoveUnit ( i ) ;
15289: LD_VAR 0 1
15293: PPUSH
15294: CALL_OW 64
// end ;
15298: GO 15217
15300: POP
15301: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15302: LD_INT 22
15304: PUSH
15305: LD_INT 1
15307: PUSH
15308: EMPTY
15309: LIST
15310: LIST
15311: PUSH
15312: LD_INT 2
15314: PUSH
15315: LD_INT 21
15317: PUSH
15318: LD_INT 1
15320: PUSH
15321: EMPTY
15322: LIST
15323: LIST
15324: PUSH
15325: LD_INT 33
15327: PUSH
15328: LD_INT 1
15330: PUSH
15331: EMPTY
15332: LIST
15333: LIST
15334: PUSH
15335: EMPTY
15336: LIST
15337: LIST
15338: LIST
15339: PUSH
15340: EMPTY
15341: LIST
15342: LIST
15343: PPUSH
15344: CALL_OW 69
15348: NOT
15349: IFFALSE 15200
// end ;
15351: PPOPN 3
15353: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
15354: LD_EXP 2
15358: IFFALSE 15759
15360: GO 15362
15362: DISABLE
15363: LD_INT 0
15365: PPUSH
15366: PPUSH
15367: PPUSH
// begin repeat wait ( 0 0$1 ) ;
15368: LD_INT 35
15370: PPUSH
15371: CALL_OW 67
// until IsDead ( Yakotich ) ;
15375: LD_EXP 60
15379: PPUSH
15380: CALL_OW 301
15384: IFFALSE 15368
// MC_Kill ( 2 ) ;
15386: LD_INT 2
15388: PPUSH
15389: CALL 21609 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
15393: LD_INT 3
15395: PPUSH
15396: LD_INT 7
15398: PPUSH
15399: LD_INT 1
15401: PPUSH
15402: LD_INT 1
15404: PPUSH
15405: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff [ Platonov , Yakotich ] ;
15409: LD_ADDR_VAR 0 3
15413: PUSH
15414: LD_INT 22
15416: PUSH
15417: LD_INT 3
15419: PUSH
15420: EMPTY
15421: LIST
15422: LIST
15423: PUSH
15424: LD_INT 26
15426: PUSH
15427: LD_INT 1
15429: PUSH
15430: EMPTY
15431: LIST
15432: LIST
15433: PUSH
15434: LD_INT 23
15436: PUSH
15437: LD_INT 3
15439: PUSH
15440: EMPTY
15441: LIST
15442: LIST
15443: PUSH
15444: EMPTY
15445: LIST
15446: LIST
15447: LIST
15448: PPUSH
15449: CALL_OW 69
15453: PUSH
15454: LD_EXP 59
15458: PUSH
15459: LD_EXP 60
15463: PUSH
15464: EMPTY
15465: LIST
15466: LIST
15467: DIFF
15468: ST_TO_ADDR
// if speaker then
15469: LD_VAR 0 3
15473: IFFALSE 15523
// begin DialogueOn ;
15475: CALL_OW 6
// if Burlak then
15479: LD_EXP 52
15483: IFFALSE 15503
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1 ) else
15485: LD_VAR 0 3
15489: PUSH
15490: LD_INT 1
15492: ARRAY
15493: PPUSH
15494: LD_STRING DSurrenderRussians-RSol1-1
15496: PPUSH
15497: CALL_OW 94
15501: GO 15519
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1a ) ;
15503: LD_VAR 0 3
15507: PUSH
15508: LD_INT 1
15510: ARRAY
15511: PPUSH
15512: LD_STRING DSurrenderRussians-RSol1-1a
15514: PPUSH
15515: CALL_OW 94
// DialogueOff ;
15519: CALL_OW 7
// end ; russianCapitulated := true ;
15523: LD_ADDR_EXP 7
15527: PUSH
15528: LD_INT 1
15530: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15531: LD_ADDR_VAR 0 2
15535: PUSH
15536: LD_INT 22
15538: PUSH
15539: LD_INT 3
15541: PUSH
15542: EMPTY
15543: LIST
15544: LIST
15545: PUSH
15546: LD_INT 21
15548: PUSH
15549: LD_INT 1
15551: PUSH
15552: EMPTY
15553: LIST
15554: LIST
15555: PUSH
15556: EMPTY
15557: LIST
15558: LIST
15559: PPUSH
15560: CALL_OW 69
15564: PUSH
15565: LD_INT 22
15567: PUSH
15568: LD_INT 3
15570: PUSH
15571: EMPTY
15572: LIST
15573: LIST
15574: PUSH
15575: LD_INT 21
15577: PUSH
15578: LD_INT 2
15580: PUSH
15581: EMPTY
15582: LIST
15583: LIST
15584: PUSH
15585: LD_INT 1
15587: PUSH
15588: EMPTY
15589: LIST
15590: PUSH
15591: EMPTY
15592: LIST
15593: LIST
15594: LIST
15595: PPUSH
15596: CALL_OW 69
15600: ADD
15601: ST_TO_ADDR
// if tmp then
15602: LD_VAR 0 2
15606: IFFALSE 15759
// repeat wait ( 0 0$1 ) ;
15608: LD_INT 35
15610: PPUSH
15611: CALL_OW 67
// for i in tmp do
15615: LD_ADDR_VAR 0 1
15619: PUSH
15620: LD_VAR 0 2
15624: PUSH
15625: FOR_IN
15626: IFFALSE 15708
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15628: LD_VAR 0 1
15632: PPUSH
15633: CALL_OW 310
15637: PUSH
15638: LD_VAR 0 1
15642: PPUSH
15643: CALL_OW 310
15647: PPUSH
15648: CALL_OW 247
15652: PUSH
15653: LD_INT 3
15655: EQUAL
15656: AND
15657: IFFALSE 15668
// ComExitBuilding ( i ) ;
15659: LD_VAR 0 1
15663: PPUSH
15664: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
15668: LD_VAR 0 1
15672: PPUSH
15673: LD_INT 154
15675: PPUSH
15676: LD_INT 1
15678: PPUSH
15679: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
15683: LD_VAR 0 1
15687: PPUSH
15688: LD_INT 36
15690: PPUSH
15691: CALL_OW 308
15695: IFFALSE 15706
// RemoveUnit ( i ) ;
15697: LD_VAR 0 1
15701: PPUSH
15702: CALL_OW 64
// end ;
15706: GO 15625
15708: POP
15709: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15710: LD_INT 22
15712: PUSH
15713: LD_INT 3
15715: PUSH
15716: EMPTY
15717: LIST
15718: LIST
15719: PUSH
15720: LD_INT 2
15722: PUSH
15723: LD_INT 21
15725: PUSH
15726: LD_INT 1
15728: PUSH
15729: EMPTY
15730: LIST
15731: LIST
15732: PUSH
15733: LD_INT 33
15735: PUSH
15736: LD_INT 1
15738: PUSH
15739: EMPTY
15740: LIST
15741: LIST
15742: PUSH
15743: EMPTY
15744: LIST
15745: LIST
15746: LIST
15747: PUSH
15748: EMPTY
15749: LIST
15750: LIST
15751: PPUSH
15752: CALL_OW 69
15756: NOT
15757: IFFALSE 15608
// end ;
15759: PPOPN 3
15761: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
15762: LD_INT 22
15764: PUSH
15765: LD_INT 8
15767: PUSH
15768: EMPTY
15769: LIST
15770: LIST
15771: PUSH
15772: LD_INT 21
15774: PUSH
15775: LD_INT 1
15777: PUSH
15778: EMPTY
15779: LIST
15780: LIST
15781: PUSH
15782: LD_INT 23
15784: PUSH
15785: LD_INT 2
15787: PUSH
15788: EMPTY
15789: LIST
15790: LIST
15791: PUSH
15792: EMPTY
15793: LIST
15794: LIST
15795: LIST
15796: PPUSH
15797: CALL_OW 69
15801: PUSH
15802: LD_INT 18
15804: LESS
15805: PUSH
15806: LD_EXP 58
15810: PPUSH
15811: CALL_OW 301
15815: OR
15816: PUSH
15817: LD_INT 324
15819: PPUSH
15820: CALL_OW 255
15824: PUSH
15825: LD_INT 7
15827: EQUAL
15828: OR
15829: IFFALSE 15842
15831: GO 15833
15833: DISABLE
// legionDestroyed := true ;
15834: LD_ADDR_EXP 3
15838: PUSH
15839: LD_INT 1
15841: ST_TO_ADDR
15842: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 do
15843: LD_INT 22
15845: PUSH
15846: LD_INT 2
15848: PUSH
15849: EMPTY
15850: LIST
15851: LIST
15852: PUSH
15853: LD_INT 21
15855: PUSH
15856: LD_INT 1
15858: PUSH
15859: EMPTY
15860: LIST
15861: LIST
15862: PUSH
15863: LD_INT 23
15865: PUSH
15866: LD_INT 2
15868: PUSH
15869: EMPTY
15870: LIST
15871: LIST
15872: PUSH
15873: EMPTY
15874: LIST
15875: LIST
15876: LIST
15877: PPUSH
15878: CALL_OW 69
15882: PUSH
15883: LD_INT 9
15885: LESS
15886: IFFALSE 15899
15888: GO 15890
15890: DISABLE
// arabianDestroyed := true ;
15891: LD_ADDR_EXP 5
15895: PUSH
15896: LD_INT 1
15898: ST_TO_ADDR
15899: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
15900: LD_EXP 5
15904: IFFALSE 16148
15906: GO 15908
15908: DISABLE
15909: LD_INT 0
15911: PPUSH
15912: PPUSH
// begin MC_Kill ( 1 ) ;
15913: LD_INT 1
15915: PPUSH
15916: CALL 21609 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15920: LD_ADDR_VAR 0 2
15924: PUSH
15925: LD_INT 22
15927: PUSH
15928: LD_INT 2
15930: PUSH
15931: EMPTY
15932: LIST
15933: LIST
15934: PUSH
15935: LD_INT 21
15937: PUSH
15938: LD_INT 1
15940: PUSH
15941: EMPTY
15942: LIST
15943: LIST
15944: PUSH
15945: EMPTY
15946: LIST
15947: LIST
15948: PPUSH
15949: CALL_OW 69
15953: PUSH
15954: LD_INT 22
15956: PUSH
15957: LD_INT 8
15959: PUSH
15960: EMPTY
15961: LIST
15962: LIST
15963: PUSH
15964: LD_INT 21
15966: PUSH
15967: LD_INT 2
15969: PUSH
15970: EMPTY
15971: LIST
15972: LIST
15973: PUSH
15974: LD_INT 1
15976: PUSH
15977: EMPTY
15978: LIST
15979: PUSH
15980: EMPTY
15981: LIST
15982: LIST
15983: LIST
15984: PPUSH
15985: CALL_OW 69
15989: ADD
15990: ST_TO_ADDR
// if tmp then
15991: LD_VAR 0 2
15995: IFFALSE 16148
// repeat wait ( 0 0$1 ) ;
15997: LD_INT 35
15999: PPUSH
16000: CALL_OW 67
// for i in tmp do
16004: LD_ADDR_VAR 0 1
16008: PUSH
16009: LD_VAR 0 2
16013: PUSH
16014: FOR_IN
16015: IFFALSE 16097
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
16017: LD_VAR 0 1
16021: PPUSH
16022: CALL_OW 310
16026: PUSH
16027: LD_VAR 0 1
16031: PPUSH
16032: CALL_OW 310
16036: PPUSH
16037: CALL_OW 247
16041: PUSH
16042: LD_INT 3
16044: EQUAL
16045: AND
16046: IFFALSE 16057
// ComExitBuilding ( i ) ;
16048: LD_VAR 0 1
16052: PPUSH
16053: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
16057: LD_VAR 0 1
16061: PPUSH
16062: LD_INT 254
16064: PPUSH
16065: LD_INT 268
16067: PPUSH
16068: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
16072: LD_VAR 0 1
16076: PPUSH
16077: LD_INT 34
16079: PPUSH
16080: CALL_OW 308
16084: IFFALSE 16095
// RemoveUnit ( i ) ;
16086: LD_VAR 0 1
16090: PPUSH
16091: CALL_OW 64
// end ;
16095: GO 16014
16097: POP
16098: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
16099: LD_INT 22
16101: PUSH
16102: LD_INT 2
16104: PUSH
16105: EMPTY
16106: LIST
16107: LIST
16108: PUSH
16109: LD_INT 2
16111: PUSH
16112: LD_INT 21
16114: PUSH
16115: LD_INT 1
16117: PUSH
16118: EMPTY
16119: LIST
16120: LIST
16121: PUSH
16122: LD_INT 33
16124: PUSH
16125: LD_INT 1
16127: PUSH
16128: EMPTY
16129: LIST
16130: LIST
16131: PUSH
16132: EMPTY
16133: LIST
16134: LIST
16135: LIST
16136: PUSH
16137: EMPTY
16138: LIST
16139: LIST
16140: PPUSH
16141: CALL_OW 69
16145: NOT
16146: IFFALSE 15997
// end ;
16148: PPOPN 2
16150: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
16151: LD_EXP 3
16155: IFFALSE 16507
16157: GO 16159
16159: DISABLE
16160: LD_INT 0
16162: PPUSH
16163: PPUSH
// begin MC_Kill ( 3 ) ;
16164: LD_INT 3
16166: PPUSH
16167: CALL 21609 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
16171: LD_INT 8
16173: PPUSH
16174: LD_INT 7
16176: PPUSH
16177: LD_INT 1
16179: PPUSH
16180: LD_INT 1
16182: PPUSH
16183: CALL_OW 80
// DialogueOn ;
16187: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
16191: LD_EXP 57
16195: PPUSH
16196: LD_STRING D15-Szulc-1
16198: PPUSH
16199: CALL_OW 94
// DialogueOff ;
16203: CALL_OW 7
// legionCapitulated := true ;
16207: LD_ADDR_EXP 8
16211: PUSH
16212: LD_INT 1
16214: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
16215: LD_ADDR_VAR 0 1
16219: PUSH
16220: LD_INT 22
16222: PUSH
16223: LD_INT 8
16225: PUSH
16226: EMPTY
16227: LIST
16228: LIST
16229: PUSH
16230: LD_INT 21
16232: PUSH
16233: LD_INT 3
16235: PUSH
16236: EMPTY
16237: LIST
16238: LIST
16239: PUSH
16240: LD_INT 23
16242: PUSH
16243: LD_INT 3
16245: PUSH
16246: EMPTY
16247: LIST
16248: LIST
16249: PUSH
16250: EMPTY
16251: LIST
16252: LIST
16253: LIST
16254: PPUSH
16255: CALL_OW 69
16259: PUSH
16260: FOR_IN
16261: IFFALSE 16277
// SetLives ( i , 3 ) ;
16263: LD_VAR 0 1
16267: PPUSH
16268: LD_INT 3
16270: PPUSH
16271: CALL_OW 234
16275: GO 16260
16277: POP
16278: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16279: LD_ADDR_VAR 0 2
16283: PUSH
16284: LD_INT 22
16286: PUSH
16287: LD_INT 8
16289: PUSH
16290: EMPTY
16291: LIST
16292: LIST
16293: PUSH
16294: LD_INT 21
16296: PUSH
16297: LD_INT 1
16299: PUSH
16300: EMPTY
16301: LIST
16302: LIST
16303: PUSH
16304: EMPTY
16305: LIST
16306: LIST
16307: PPUSH
16308: CALL_OW 69
16312: PUSH
16313: LD_INT 22
16315: PUSH
16316: LD_INT 8
16318: PUSH
16319: EMPTY
16320: LIST
16321: LIST
16322: PUSH
16323: LD_INT 21
16325: PUSH
16326: LD_INT 2
16328: PUSH
16329: EMPTY
16330: LIST
16331: LIST
16332: PUSH
16333: LD_INT 1
16335: PUSH
16336: EMPTY
16337: LIST
16338: PUSH
16339: EMPTY
16340: LIST
16341: LIST
16342: LIST
16343: PPUSH
16344: CALL_OW 69
16348: ADD
16349: ST_TO_ADDR
// if tmp then
16350: LD_VAR 0 2
16354: IFFALSE 16507
// repeat wait ( 0 0$1 ) ;
16356: LD_INT 35
16358: PPUSH
16359: CALL_OW 67
// for i in tmp do
16363: LD_ADDR_VAR 0 1
16367: PUSH
16368: LD_VAR 0 2
16372: PUSH
16373: FOR_IN
16374: IFFALSE 16456
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
16376: LD_VAR 0 1
16380: PPUSH
16381: CALL_OW 310
16385: PUSH
16386: LD_VAR 0 1
16390: PPUSH
16391: CALL_OW 310
16395: PPUSH
16396: CALL_OW 247
16400: PUSH
16401: LD_INT 3
16403: EQUAL
16404: AND
16405: IFFALSE 16416
// ComExitBuilding ( i ) ;
16407: LD_VAR 0 1
16411: PPUSH
16412: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
16416: LD_VAR 0 1
16420: PPUSH
16421: LD_INT 10
16423: PPUSH
16424: LD_INT 1
16426: PPUSH
16427: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
16431: LD_VAR 0 1
16435: PPUSH
16436: LD_INT 32
16438: PPUSH
16439: CALL_OW 308
16443: IFFALSE 16454
// RemoveUnit ( i ) ;
16445: LD_VAR 0 1
16449: PPUSH
16450: CALL_OW 64
// end ;
16454: GO 16373
16456: POP
16457: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
16458: LD_INT 22
16460: PUSH
16461: LD_INT 8
16463: PUSH
16464: EMPTY
16465: LIST
16466: LIST
16467: PUSH
16468: LD_INT 2
16470: PUSH
16471: LD_INT 21
16473: PUSH
16474: LD_INT 1
16476: PUSH
16477: EMPTY
16478: LIST
16479: LIST
16480: PUSH
16481: LD_INT 33
16483: PUSH
16484: LD_INT 1
16486: PUSH
16487: EMPTY
16488: LIST
16489: LIST
16490: PUSH
16491: EMPTY
16492: LIST
16493: LIST
16494: LIST
16495: PUSH
16496: EMPTY
16497: LIST
16498: LIST
16499: PPUSH
16500: CALL_OW 69
16504: NOT
16505: IFFALSE 16356
// end ;
16507: PPOPN 2
16509: END
// every 0 0$10 trigger not arabianDestroyed and tick >= 30 30$00 do
16510: LD_EXP 5
16514: NOT
16515: PUSH
16516: LD_OWVAR 1
16520: PUSH
16521: LD_INT 63000
16523: GREATEREQUAL
16524: AND
16525: IFFALSE 16534
16527: GO 16529
16529: DISABLE
// AllianceSupport ;
16530: CALL 4677 0 0
16534: END
// every 0 0$5 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated and ( GetSide ( Omar ) <> 5 or IsDead ( Omar ) or not IsPlaced ( Omar ) ) do var med1 , med2 ;
16535: LD_EXP 4
16539: PUSH
16540: LD_EXP 2
16544: AND
16545: PUSH
16546: LD_EXP 3
16550: AND
16551: PUSH
16552: LD_EXP 5
16556: AND
16557: PUSH
16558: LD_EXP 6
16562: AND
16563: PUSH
16564: LD_EXP 7
16568: AND
16569: PUSH
16570: LD_EXP 8
16574: AND
16575: PUSH
16576: LD_EXP 56
16580: PPUSH
16581: CALL_OW 255
16585: PUSH
16586: LD_INT 5
16588: NONEQUAL
16589: PUSH
16590: LD_EXP 56
16594: PPUSH
16595: CALL_OW 301
16599: OR
16600: PUSH
16601: LD_EXP 56
16605: PPUSH
16606: CALL_OW 305
16610: NOT
16611: OR
16612: AND
16613: IFFALSE 18015
16615: GO 16617
16617: DISABLE
16618: LD_INT 0
16620: PPUSH
16621: PPUSH
// begin wait ( 0 0$5 ) ;
16622: LD_INT 175
16624: PPUSH
16625: CALL_OW 67
// music_class := 5 ;
16629: LD_ADDR_OWVAR 72
16633: PUSH
16634: LD_INT 5
16636: ST_TO_ADDR
// music_nat := 5 ;
16637: LD_ADDR_OWVAR 71
16641: PUSH
16642: LD_INT 5
16644: ST_TO_ADDR
// if vehicleLostCounter < 3 then
16645: LD_EXP 15
16649: PUSH
16650: LD_INT 3
16652: LESS
16653: IFFALSE 16662
// SetAchievement ( ACH_ECONOMY ) ;
16655: LD_STRING ACH_ECONOMY
16657: PPUSH
16658: CALL_OW 543
// if tick < 60 60$00 then
16662: LD_OWVAR 1
16666: PUSH
16667: LD_INT 126000
16669: LESS
16670: IFFALSE 16686
// begin wait ( 3 ) ;
16672: LD_INT 3
16674: PPUSH
16675: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
16679: LD_STRING ACH_ASPEED_19
16681: PPUSH
16682: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
16686: LD_EXP 19
16690: PPUSH
16691: CALL_OW 87
// InGameOn ;
16695: CALL_OW 8
// DialogueOn ;
16699: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
16703: LD_EXP 19
16707: PPUSH
16708: LD_STRING DEnd-JMM-JMM-1
16710: PPUSH
16711: CALL_OW 88
// if Joan then
16715: LD_EXP 34
16719: IFFALSE 16735
// Say ( Joan , DEnd-JMM-Joan-1 ) else
16721: LD_EXP 34
16725: PPUSH
16726: LD_STRING DEnd-JMM-Joan-1
16728: PPUSH
16729: CALL_OW 88
16733: GO 16779
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
16735: LD_EXP 21
16739: PUSH
16740: LD_EXP 21
16744: PPUSH
16745: CALL_OW 255
16749: PUSH
16750: LD_INT 7
16752: EQUAL
16753: AND
16754: PUSH
16755: LD_EXP 21
16759: PPUSH
16760: CALL_OW 305
16764: AND
16765: IFFALSE 16779
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
16767: LD_EXP 21
16771: PPUSH
16772: LD_STRING DEnd-JMM-Lisa-1
16774: PPUSH
16775: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
16779: LD_EXP 31
16783: PUSH
16784: LD_EXP 31
16788: PPUSH
16789: CALL_OW 305
16793: AND
16794: IFFALSE 16808
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
16796: LD_EXP 31
16800: PPUSH
16801: LD_STRING DEnd-JMM-Frank-1
16803: PPUSH
16804: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
16808: LD_EXP 24
16812: PUSH
16813: LD_EXP 24
16817: PPUSH
16818: CALL_OW 255
16822: PUSH
16823: LD_INT 7
16825: EQUAL
16826: AND
16827: PUSH
16828: LD_EXP 24
16832: PPUSH
16833: CALL_OW 305
16837: AND
16838: IFFALSE 16852
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
16840: LD_EXP 24
16844: PPUSH
16845: LD_STRING DEnd-JMM-Cyrus-1
16847: PPUSH
16848: CALL_OW 88
// if Burlak then
16852: LD_EXP 52
16856: IFFALSE 16870
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
16858: LD_EXP 52
16862: PPUSH
16863: LD_STRING DEnd-JMM-Bur-1
16865: PPUSH
16866: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) and IsOk ( Burlak ) then
16870: LD_EXP 34
16874: PUSH
16875: LD_EXP 21
16879: AND
16880: PUSH
16881: LD_EXP 21
16885: PPUSH
16886: CALL_OW 255
16890: PUSH
16891: LD_INT 7
16893: EQUAL
16894: AND
16895: PUSH
16896: LD_EXP 21
16900: PPUSH
16901: CALL_OW 305
16905: AND
16906: PUSH
16907: LD_EXP 52
16911: PPUSH
16912: CALL_OW 302
16916: AND
16917: IFFALSE 16931
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
16919: LD_EXP 21
16923: PPUSH
16924: LD_STRING DEnd-Burlak-Lisa-1
16926: PPUSH
16927: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
16931: LD_EXP 53
16935: PUSH
16936: LD_EXP 53
16940: PPUSH
16941: CALL_OW 305
16945: AND
16946: IFFALSE 16960
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
16948: LD_EXP 53
16952: PPUSH
16953: LD_STRING DEnd-JMM-Bel-1
16955: PPUSH
16956: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
16960: LD_EXP 54
16964: PUSH
16965: LD_EXP 54
16969: PPUSH
16970: CALL_OW 305
16974: AND
16975: IFFALSE 16989
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
16977: LD_EXP 54
16981: PPUSH
16982: LD_STRING DEnd-JMM-Gny-1
16984: PPUSH
16985: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
16989: LD_EXP 29
16993: PUSH
16994: LD_EXP 29
16998: PPUSH
16999: CALL_OW 255
17003: PUSH
17004: LD_INT 7
17006: EQUAL
17007: AND
17008: PUSH
17009: LD_EXP 29
17013: PPUSH
17014: CALL_OW 305
17018: AND
17019: IFFALSE 17033
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
17021: LD_EXP 29
17025: PPUSH
17026: LD_STRING DEnd-JMM-Corn-1
17028: PPUSH
17029: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
17033: LD_EXP 22
17037: PUSH
17038: LD_EXP 22
17042: PPUSH
17043: CALL_OW 255
17047: PUSH
17048: LD_INT 7
17050: EQUAL
17051: AND
17052: PUSH
17053: LD_EXP 22
17057: PPUSH
17058: CALL_OW 305
17062: AND
17063: IFFALSE 17077
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
17065: LD_EXP 22
17069: PPUSH
17070: LD_STRING DEnd-JMM-Don-1
17072: PPUSH
17073: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
17077: LD_EXP 23
17081: PUSH
17082: LD_EXP 23
17086: PPUSH
17087: CALL_OW 255
17091: PUSH
17092: LD_INT 7
17094: EQUAL
17095: AND
17096: PUSH
17097: LD_EXP 23
17101: PPUSH
17102: CALL_OW 305
17106: AND
17107: IFFALSE 17121
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
17109: LD_EXP 23
17113: PPUSH
17114: LD_STRING DEnd-JMM-Bobby-1
17116: PPUSH
17117: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
17121: LD_EXP 25
17125: PUSH
17126: LD_EXP 25
17130: PPUSH
17131: CALL_OW 255
17135: PUSH
17136: LD_INT 7
17138: EQUAL
17139: AND
17140: PUSH
17141: LD_EXP 25
17145: PPUSH
17146: CALL_OW 305
17150: AND
17151: IFFALSE 17165
// Say ( Denis , DEnd-JMM-Den-1 ) ;
17153: LD_EXP 25
17157: PPUSH
17158: LD_STRING DEnd-JMM-Den-1
17160: PPUSH
17161: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
17165: LD_EXP 27
17169: PUSH
17170: LD_EXP 27
17174: PPUSH
17175: CALL_OW 255
17179: PUSH
17180: LD_INT 7
17182: EQUAL
17183: AND
17184: PUSH
17185: LD_EXP 27
17189: PPUSH
17190: CALL_OW 305
17194: AND
17195: IFFALSE 17209
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
17197: LD_EXP 27
17201: PPUSH
17202: LD_STRING DEnd-JMM-Glad-1
17204: PPUSH
17205: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
17209: LD_EXP 32
17213: PUSH
17214: LD_EXP 32
17218: PPUSH
17219: CALL_OW 255
17223: PUSH
17224: LD_INT 7
17226: EQUAL
17227: AND
17228: PUSH
17229: LD_EXP 32
17233: PPUSH
17234: CALL_OW 305
17238: AND
17239: IFFALSE 17253
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
17241: LD_EXP 32
17245: PPUSH
17246: LD_STRING DEnd-JMM-Yam-1
17248: PPUSH
17249: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
17253: LD_EXP 26
17257: PUSH
17258: LD_EXP 26
17262: PPUSH
17263: CALL_OW 255
17267: PUSH
17268: LD_INT 7
17270: EQUAL
17271: AND
17272: PUSH
17273: LD_EXP 26
17277: PPUSH
17278: CALL_OW 305
17282: AND
17283: IFFALSE 17297
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
17285: LD_EXP 26
17289: PPUSH
17290: LD_STRING DEnd-JMM-Brown-1
17292: PPUSH
17293: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
17297: LD_EXP 36
17301: PUSH
17302: LD_EXP 36
17306: PPUSH
17307: CALL_OW 255
17311: PUSH
17312: LD_INT 7
17314: EQUAL
17315: AND
17316: PUSH
17317: LD_EXP 36
17321: PPUSH
17322: CALL_OW 305
17326: AND
17327: IFFALSE 17341
// Say ( Connie , DEnd-JMM-Con-1 ) ;
17329: LD_EXP 36
17333: PPUSH
17334: LD_STRING DEnd-JMM-Con-1
17336: PPUSH
17337: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
17341: LD_EXP 30
17345: PUSH
17346: LD_EXP 30
17350: PPUSH
17351: CALL_OW 255
17355: PUSH
17356: LD_INT 7
17358: EQUAL
17359: AND
17360: PUSH
17361: LD_EXP 30
17365: PPUSH
17366: CALL_OW 305
17370: AND
17371: IFFALSE 17385
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
17373: LD_EXP 30
17377: PPUSH
17378: LD_STRING DEnd-JMM-Gary-1
17380: PPUSH
17381: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
17385: LD_EXP 33
17389: PUSH
17390: LD_EXP 20
17394: AND
17395: PUSH
17396: LD_EXP 33
17400: PPUSH
17401: CALL_OW 305
17405: AND
17406: IFFALSE 17420
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
17408: LD_EXP 33
17412: PPUSH
17413: LD_STRING DEnd-JMM-Sim-1
17415: PPUSH
17416: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
17420: LD_EXP 28
17424: PUSH
17425: LD_EXP 28
17429: PPUSH
17430: CALL_OW 255
17434: PUSH
17435: LD_INT 7
17437: EQUAL
17438: AND
17439: PUSH
17440: LD_EXP 28
17444: PPUSH
17445: CALL_OW 305
17449: AND
17450: IFFALSE 17464
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
17452: LD_EXP 28
17456: PPUSH
17457: LD_STRING DEnd-JMM-VanH-1
17459: PPUSH
17460: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
17464: LD_EXP 42
17468: PUSH
17469: LD_EXP 42
17473: PPUSH
17474: CALL_OW 305
17478: AND
17479: IFFALSE 17493
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
17481: LD_EXP 42
17485: PPUSH
17486: LD_STRING DEnd-JMM-Dol-1
17488: PPUSH
17489: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
17493: LD_EXP 46
17497: PUSH
17498: LD_EXP 46
17502: PPUSH
17503: CALL_OW 305
17507: AND
17508: IFFALSE 17522
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
17510: LD_EXP 46
17514: PPUSH
17515: LD_STRING DEnd-JMM-Kap-1
17517: PPUSH
17518: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
17522: LD_EXP 49
17526: PUSH
17527: LD_EXP 49
17531: PPUSH
17532: CALL_OW 305
17536: AND
17537: IFFALSE 17551
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
17539: LD_EXP 49
17543: PPUSH
17544: LD_STRING DEnd-JMM-Kov-1
17546: PPUSH
17547: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
17551: LD_EXP 44
17555: PUSH
17556: LD_EXP 44
17560: PPUSH
17561: CALL_OW 305
17565: AND
17566: IFFALSE 17580
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
17568: LD_EXP 44
17572: PPUSH
17573: LD_STRING DEnd-JMM-Sch-1
17575: PPUSH
17576: CALL_OW 88
// if Titov and IsPlaced ( Titov ) then
17580: LD_EXP 40
17584: PUSH
17585: LD_EXP 40
17589: PPUSH
17590: CALL_OW 305
17594: AND
17595: IFFALSE 17609
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
17597: LD_EXP 40
17601: PPUSH
17602: LD_STRING DEnd-JMM-Tit-1
17604: PPUSH
17605: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
17609: LD_EXP 45
17613: PUSH
17614: LD_EXP 45
17618: PPUSH
17619: CALL_OW 305
17623: AND
17624: IFFALSE 17638
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
17626: LD_EXP 45
17630: PPUSH
17631: LD_STRING DEnd-JMM-Obl-1
17633: PPUSH
17634: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
17638: LD_EXP 47
17642: PUSH
17643: LD_EXP 47
17647: PPUSH
17648: CALL_OW 305
17652: AND
17653: IFFALSE 17667
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
17655: LD_EXP 47
17659: PPUSH
17660: LD_STRING DEnd-JMM-Lip-1
17662: PPUSH
17663: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and Burlak then
17667: LD_EXP 41
17671: PUSH
17672: LD_EXP 41
17676: PPUSH
17677: CALL_OW 305
17681: AND
17682: PUSH
17683: LD_EXP 52
17687: AND
17688: IFFALSE 17702
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
17690: LD_EXP 41
17694: PPUSH
17695: LD_STRING DEnd-Burlak-Fad-1
17697: PPUSH
17698: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
17702: LD_EXP 48
17706: PUSH
17707: LD_EXP 48
17711: PPUSH
17712: CALL_OW 305
17716: AND
17717: IFFALSE 17731
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
17719: LD_EXP 48
17723: PPUSH
17724: LD_STRING DEnd-Burlak-Ptr-1
17726: PPUSH
17727: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
17731: LD_EXP 50
17735: PUSH
17736: LD_EXP 50
17740: PPUSH
17741: CALL_OW 305
17745: AND
17746: IFFALSE 17760
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
17748: LD_EXP 50
17752: PPUSH
17753: LD_STRING DEnd-Burlak-Kuz-1
17755: PPUSH
17756: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and Burlak then
17760: LD_EXP 39
17764: PUSH
17765: LD_EXP 39
17769: PPUSH
17770: CALL_OW 305
17774: AND
17775: PUSH
17776: LD_EXP 52
17780: AND
17781: IFFALSE 17795
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
17783: LD_EXP 39
17787: PPUSH
17788: LD_STRING DEnd-Burlak-Kir-1
17790: PPUSH
17791: CALL_OW 88
// if Burlak then
17795: LD_EXP 52
17799: IFFALSE 17813
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
17801: LD_EXP 19
17805: PPUSH
17806: LD_STRING DEnd-Burlak-JMM-1
17808: PPUSH
17809: CALL_OW 88
// dwait ( 0 0$2 ) ;
17813: LD_INT 70
17815: PPUSH
17816: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
17820: LD_EXP 57
17824: PPUSH
17825: LD_STRING DEnd-Szulc
17827: PPUSH
17828: CALL_OW 94
// dwait ( 0 0$1 ) ;
17832: LD_INT 35
17834: PPUSH
17835: CALL_OW 68
// if IsLive ( Burlak ) then
17839: LD_EXP 52
17843: PPUSH
17844: CALL_OW 300
17848: IFFALSE 17860
// med1 := 1 else
17850: LD_ADDR_VAR 0 1
17854: PUSH
17855: LD_INT 1
17857: ST_TO_ADDR
17858: GO 17869
// med1 := - 1 ;
17860: LD_ADDR_VAR 0 1
17864: PUSH
17865: LD_INT 1
17867: NEG
17868: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
17869: LD_EXP 12
17873: PUSH
17874: LD_EXP 13
17878: AND
17879: PUSH
17880: LD_EXP 14
17884: AND
17885: IFFALSE 17897
// med2 := 1 else
17887: LD_ADDR_VAR 0 2
17891: PUSH
17892: LD_INT 1
17894: ST_TO_ADDR
17895: GO 17906
// med2 := - 1 ;
17897: LD_ADDR_VAR 0 2
17901: PUSH
17902: LD_INT 1
17904: NEG
17905: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
17906: LD_STRING Hero
17908: PPUSH
17909: LD_INT 1
17911: PPUSH
17912: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
17916: LD_STRING Artefact
17918: PPUSH
17919: LD_VAR 0 2
17923: PPUSH
17924: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
17928: LD_STRING ReconcileBurlak
17930: PPUSH
17931: LD_VAR 0 1
17935: PPUSH
17936: CALL_OW 101
// if Difficulty >= 3 and med1 = 1 and med2 = 1 then
17940: LD_OWVAR 67
17944: PUSH
17945: LD_INT 3
17947: GREATEREQUAL
17948: PUSH
17949: LD_VAR 0 1
17953: PUSH
17954: LD_INT 1
17956: EQUAL
17957: AND
17958: PUSH
17959: LD_VAR 0 2
17963: PUSH
17964: LD_INT 1
17966: EQUAL
17967: AND
17968: IFFALSE 17980
// SetAchievementEX ( ACH_AMER , 19 ) ;
17970: LD_STRING ACH_AMER
17972: PPUSH
17973: LD_INT 19
17975: PPUSH
17976: CALL_OW 564
// GiveMedals ( MAIN ) ;
17980: LD_STRING MAIN
17982: PPUSH
17983: CALL_OW 102
// InGameOff ;
17987: CALL_OW 9
// DialogueOff ;
17991: CALL_OW 7
// music_nat := 1 ;
17995: LD_ADDR_OWVAR 71
17999: PUSH
18000: LD_INT 1
18002: ST_TO_ADDR
// music_class := 4 ;
18003: LD_ADDR_OWVAR 72
18007: PUSH
18008: LD_INT 4
18010: ST_TO_ADDR
// YouWin ;
18011: CALL_OW 103
// end ; end_of_file
18015: PPOPN 2
18017: END
// export function InitNature ; begin
18018: LD_INT 0
18020: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
18021: LD_INT 3
18023: PPUSH
18024: LD_INT 3
18026: PPUSH
18027: LD_INT 2
18029: PPUSH
18030: LD_INT 1
18032: PPUSH
18033: LD_INT 1
18035: PPUSH
18036: LD_INT 0
18038: PPUSH
18039: LD_INT 0
18041: PPUSH
18042: LD_INT 17
18044: PPUSH
18045: LD_INT 0
18047: PPUSH
18048: CALL 86219 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
18052: LD_INT 2
18054: PPUSH
18055: LD_INT 1
18057: PPUSH
18058: LD_INT 1
18060: PPUSH
18061: LD_INT 1
18063: PPUSH
18064: LD_INT 1
18066: PPUSH
18067: LD_INT 0
18069: PPUSH
18070: LD_INT 0
18072: PPUSH
18073: LD_INT 18
18075: PPUSH
18076: LD_INT 0
18078: PPUSH
18079: CALL 86219 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
18083: LD_INT 4
18085: PPUSH
18086: LD_INT 1
18088: PPUSH
18089: LD_INT 2
18091: PPUSH
18092: LD_INT 4
18094: PPUSH
18095: LD_INT 2
18097: PPUSH
18098: LD_INT 1
18100: PPUSH
18101: LD_INT 0
18103: PPUSH
18104: LD_INT 19
18106: PPUSH
18107: LD_INT 0
18109: PPUSH
18110: CALL 86219 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
18114: LD_INT 0
18116: PPUSH
18117: LD_INT 0
18119: PPUSH
18120: LD_INT 0
18122: PPUSH
18123: LD_INT 0
18125: PPUSH
18126: LD_INT 0
18128: PPUSH
18129: LD_INT 0
18131: PPUSH
18132: LD_INT 9
18134: PPUSH
18135: LD_INT 0
18137: PPUSH
18138: LD_INT 20
18140: PPUSH
18141: CALL 86219 0 9
// end ; end_of_file
18145: LD_VAR 0 1
18149: RET
// every 0 0$30 do var time ;
18150: GO 18152
18152: DISABLE
18153: LD_INT 0
18155: PPUSH
// begin time := 0 0$30 ;
18156: LD_ADDR_VAR 0 1
18160: PUSH
18161: LD_INT 1050
18163: ST_TO_ADDR
// repeat wait ( time ) ;
18164: LD_VAR 0 1
18168: PPUSH
18169: CALL_OW 67
// if Prob ( 50 ) then
18173: LD_INT 50
18175: PPUSH
18176: CALL_OW 13
18180: IFFALSE 18209
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
18182: LD_INT 1
18184: PPUSH
18185: LD_INT 5
18187: PPUSH
18188: CALL_OW 12
18192: PPUSH
18193: LD_INT 106
18195: PPUSH
18196: LD_INT 89
18198: PPUSH
18199: LD_INT 45
18201: PPUSH
18202: LD_INT 1
18204: PPUSH
18205: CALL_OW 56
// time := time + 0 0$3 ;
18209: LD_ADDR_VAR 0 1
18213: PUSH
18214: LD_VAR 0 1
18218: PUSH
18219: LD_INT 105
18221: PLUS
18222: ST_TO_ADDR
// if Prob ( 30 ) then
18223: LD_INT 30
18225: PPUSH
18226: CALL_OW 13
18230: IFFALSE 18276
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
18232: LD_INT 525
18234: PPUSH
18235: LD_INT 735
18237: PPUSH
18238: CALL_OW 12
18242: PPUSH
18243: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
18247: LD_INT 1
18249: PPUSH
18250: LD_INT 5
18252: PPUSH
18253: CALL_OW 12
18257: PPUSH
18258: LD_INT 21
18260: PPUSH
18261: LD_INT 26
18263: PPUSH
18264: LD_INT 12
18266: PPUSH
18267: LD_INT 1
18269: PPUSH
18270: CALL_OW 56
// end else
18274: GO 18312
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
18276: LD_INT 700
18278: PPUSH
18279: LD_INT 1225
18281: PPUSH
18282: CALL_OW 12
18286: PPUSH
18287: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
18291: LD_INT 1
18293: PPUSH
18294: LD_INT 5
18296: PPUSH
18297: CALL_OW 12
18301: PPUSH
18302: LD_INT 14
18304: PPUSH
18305: LD_INT 1
18307: PPUSH
18308: CALL_OW 55
// end ; if Prob ( 50 ) then
18312: LD_INT 50
18314: PPUSH
18315: CALL_OW 13
18319: IFFALSE 18365
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
18321: LD_INT 700
18323: PPUSH
18324: LD_INT 1050
18326: PPUSH
18327: CALL_OW 12
18331: PPUSH
18332: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
18336: LD_INT 1
18338: PPUSH
18339: LD_INT 5
18341: PPUSH
18342: CALL_OW 12
18346: PPUSH
18347: LD_INT 181
18349: PPUSH
18350: LD_INT 218
18352: PPUSH
18353: LD_INT 16
18355: PPUSH
18356: LD_INT 1
18358: PPUSH
18359: CALL_OW 56
// end else
18363: GO 18437
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
18365: LD_INT 350
18367: PPUSH
18368: LD_INT 525
18370: PPUSH
18371: CALL_OW 12
18375: PPUSH
18376: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
18380: LD_INT 1
18382: PPUSH
18383: LD_INT 5
18385: PPUSH
18386: CALL_OW 12
18390: PPUSH
18391: LD_INT 13
18393: PPUSH
18394: LD_INT 1
18396: PPUSH
18397: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
18401: LD_INT 350
18403: PPUSH
18404: LD_INT 700
18406: PPUSH
18407: CALL_OW 12
18411: PPUSH
18412: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
18416: LD_INT 1
18418: PPUSH
18419: LD_INT 5
18421: PPUSH
18422: CALL_OW 12
18426: PPUSH
18427: LD_INT 33
18429: PPUSH
18430: LD_INT 1
18432: PPUSH
18433: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 , 50 ] [ Difficulty ] ) then
18437: LD_INT 65
18439: PUSH
18440: LD_INT 62
18442: PUSH
18443: LD_INT 55
18445: PUSH
18446: LD_INT 50
18448: PUSH
18449: EMPTY
18450: LIST
18451: LIST
18452: LIST
18453: LIST
18454: PUSH
18455: LD_OWVAR 67
18459: ARRAY
18460: PPUSH
18461: CALL_OW 13
18465: IFFALSE 18511
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
18467: LD_INT 525
18469: PPUSH
18470: LD_INT 875
18472: PPUSH
18473: CALL_OW 12
18477: PPUSH
18478: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
18482: LD_INT 1
18484: PPUSH
18485: LD_INT 5
18487: PPUSH
18488: CALL_OW 12
18492: PPUSH
18493: LD_INT 294
18495: PPUSH
18496: LD_INT 211
18498: PPUSH
18499: LD_INT 30
18501: PPUSH
18502: LD_INT 1
18504: PPUSH
18505: CALL_OW 56
// end else
18509: GO 18553
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
18511: LD_INT 420
18513: PPUSH
18514: LD_INT 770
18516: PPUSH
18517: CALL_OW 12
18521: PPUSH
18522: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
18526: LD_INT 1
18528: PPUSH
18529: LD_INT 5
18531: PPUSH
18532: CALL_OW 12
18536: PPUSH
18537: LD_INT 294
18539: PPUSH
18540: LD_INT 211
18542: PPUSH
18543: LD_INT 30
18545: PPUSH
18546: LD_INT 1
18548: PPUSH
18549: CALL_OW 56
// end ; if time > 2 2$20 then
18553: LD_VAR 0 1
18557: PUSH
18558: LD_INT 4900
18560: GREATER
18561: IFFALSE 18571
// time := 0 0$50 ;
18563: LD_ADDR_VAR 0 1
18567: PUSH
18568: LD_INT 1750
18570: ST_TO_ADDR
// until false ;
18571: LD_INT 0
18573: IFFALSE 18164
// end ;
18575: PPOPN 1
18577: END
// every 0 0$45 trigger tick < 10 10$00 do
18578: LD_OWVAR 1
18582: PUSH
18583: LD_INT 21000
18585: LESS
18586: IFFALSE 18634
18588: GO 18590
18590: DISABLE
// begin enable ;
18591: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
18592: LD_INT 350
18594: PPUSH
18595: LD_INT 700
18597: PPUSH
18598: CALL_OW 12
18602: PPUSH
18603: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
18607: LD_INT 3
18609: PPUSH
18610: LD_INT 5
18612: PPUSH
18613: CALL_OW 12
18617: PPUSH
18618: LD_INT 181
18620: PPUSH
18621: LD_INT 13
18623: PPUSH
18624: LD_INT 20
18626: PPUSH
18627: LD_INT 1
18629: PPUSH
18630: CALL_OW 56
// end ; end_of_file
18634: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
18635: LD_INT 0
18637: PPUSH
// SetArtifactRes ( 7 , true ) ;
18638: LD_INT 7
18640: PPUSH
18641: LD_INT 1
18643: PPUSH
18644: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
18648: LD_ADDR_EXP 65
18652: PUSH
18653: EMPTY
18654: PUSH
18655: EMPTY
18656: PUSH
18657: EMPTY
18658: PUSH
18659: EMPTY
18660: LIST
18661: LIST
18662: LIST
18663: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
18664: LD_ADDR_EXP 66
18668: PUSH
18669: LD_INT 1050
18671: PUSH
18672: LD_OWVAR 67
18676: MUL
18677: PUSH
18678: LD_INT 2800
18680: PUSH
18681: LD_OWVAR 67
18685: MUL
18686: PUSH
18687: LD_INT 1
18689: NEG
18690: PUSH
18691: EMPTY
18692: LIST
18693: LIST
18694: LIST
18695: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
18696: LD_ADDR_EXP 67
18700: PUSH
18701: LD_INT 10
18703: PUSH
18704: LD_INT 35
18706: PUSH
18707: LD_INT 100
18709: PUSH
18710: EMPTY
18711: LIST
18712: LIST
18713: LIST
18714: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
18715: LD_ADDR_EXP 68
18719: PUSH
18720: LD_INT 0
18722: PUSH
18723: LD_INT 0
18725: PUSH
18726: LD_INT 0
18728: PUSH
18729: EMPTY
18730: LIST
18731: LIST
18732: LIST
18733: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
18734: LD_ADDR_EXP 70
18738: PUSH
18739: LD_INT 300
18741: PUSH
18742: LD_INT 500
18744: PUSH
18745: LD_INT 800
18747: PUSH
18748: EMPTY
18749: LIST
18750: LIST
18751: LIST
18752: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
18753: LD_ADDR_EXP 71
18757: PUSH
18758: LD_INT 0
18760: PUSH
18761: LD_INT 0
18763: PUSH
18764: LD_INT 0
18766: PUSH
18767: EMPTY
18768: LIST
18769: LIST
18770: LIST
18771: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
18772: LD_ADDR_EXP 72
18776: PUSH
18777: LD_INT 0
18779: PUSH
18780: LD_INT 0
18782: PUSH
18783: LD_INT 0
18785: PUSH
18786: EMPTY
18787: LIST
18788: LIST
18789: LIST
18790: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
18791: LD_ADDR_EXP 69
18795: PUSH
18796: LD_INT 0
18798: PUSH
18799: LD_INT 0
18801: PUSH
18802: LD_INT 0
18804: PUSH
18805: EMPTY
18806: LIST
18807: LIST
18808: LIST
18809: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
18810: LD_ADDR_EXP 73
18814: PUSH
18815: LD_INT 4
18817: PUSH
18818: LD_INT 3
18820: PUSH
18821: LD_INT 1
18823: PUSH
18824: EMPTY
18825: LIST
18826: LIST
18827: LIST
18828: PUSH
18829: LD_INT 5
18831: PUSH
18832: LD_INT 4
18834: PUSH
18835: LD_INT 2
18837: PUSH
18838: EMPTY
18839: LIST
18840: LIST
18841: LIST
18842: PUSH
18843: LD_INT 6
18845: PUSH
18846: LD_INT 3
18848: PUSH
18849: LD_INT 3
18851: PUSH
18852: EMPTY
18853: LIST
18854: LIST
18855: LIST
18856: PUSH
18857: EMPTY
18858: LIST
18859: LIST
18860: LIST
18861: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
18862: LD_ADDR_EXP 74
18866: PUSH
18867: LD_INT 0
18869: PUSH
18870: LD_INT 0
18872: PUSH
18873: LD_INT 0
18875: PUSH
18876: EMPTY
18877: LIST
18878: LIST
18879: LIST
18880: ST_TO_ADDR
// end ;
18881: LD_VAR 0 1
18885: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
18886: LD_INT 24
18888: PPUSH
18889: LD_INT 7
18891: PPUSH
18892: CALL_OW 321
18896: PUSH
18897: LD_INT 2
18899: EQUAL
18900: IFFALSE 19826
18902: GO 18904
18904: DISABLE
18905: LD_INT 0
18907: PPUSH
18908: PPUSH
18909: PPUSH
18910: PPUSH
18911: PPUSH
// begin enable ;
18912: ENABLE
// for i = 1 to 3 do
18913: LD_ADDR_VAR 0 1
18917: PUSH
18918: DOUBLE
18919: LD_INT 1
18921: DEC
18922: ST_TO_ADDR
18923: LD_INT 3
18925: PUSH
18926: FOR_TO
18927: IFFALSE 19824
// begin pos := FindArtifact ( i + 2 ) ;
18929: LD_ADDR_VAR 0 2
18933: PUSH
18934: LD_VAR 0 1
18938: PUSH
18939: LD_INT 2
18941: PLUS
18942: PPUSH
18943: CALL_OW 469
18947: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
18948: LD_ADDR_EXP 65
18952: PUSH
18953: LD_EXP 65
18957: PPUSH
18958: LD_VAR 0 1
18962: PPUSH
18963: LD_VAR 0 2
18967: PPUSH
18968: CALL_OW 1
18972: ST_TO_ADDR
// if pos then
18973: LD_VAR 0 2
18977: IFFALSE 19685
// begin case i of 1 :
18979: LD_VAR 0 1
18983: PUSH
18984: LD_INT 1
18986: DOUBLE
18987: EQUAL
18988: IFTRUE 18992
18990: GO 19069
18992: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
18993: LD_ADDR_VAR 0 4
18997: PUSH
18998: LD_INT 22
19000: PUSH
19001: LD_INT 7
19003: PUSH
19004: EMPTY
19005: LIST
19006: LIST
19007: PUSH
19008: LD_INT 23
19010: PUSH
19011: LD_INT 1
19013: PUSH
19014: EMPTY
19015: LIST
19016: LIST
19017: PUSH
19018: LD_INT 2
19020: PUSH
19021: LD_INT 30
19023: PUSH
19024: LD_INT 8
19026: PUSH
19027: EMPTY
19028: LIST
19029: LIST
19030: PUSH
19031: LD_INT 30
19033: PUSH
19034: LD_INT 7
19036: PUSH
19037: EMPTY
19038: LIST
19039: LIST
19040: PUSH
19041: LD_INT 30
19043: PUSH
19044: LD_INT 11
19046: PUSH
19047: EMPTY
19048: LIST
19049: LIST
19050: PUSH
19051: EMPTY
19052: LIST
19053: LIST
19054: LIST
19055: LIST
19056: PUSH
19057: EMPTY
19058: LIST
19059: LIST
19060: LIST
19061: PPUSH
19062: CALL_OW 69
19066: ST_TO_ADDR
19067: GO 19177
19069: LD_INT 2
19071: DOUBLE
19072: EQUAL
19073: IFTRUE 19077
19075: GO 19154
19077: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
19078: LD_ADDR_VAR 0 4
19082: PUSH
19083: LD_INT 22
19085: PUSH
19086: LD_INT 7
19088: PUSH
19089: EMPTY
19090: LIST
19091: LIST
19092: PUSH
19093: LD_INT 23
19095: PUSH
19096: LD_INT 3
19098: PUSH
19099: EMPTY
19100: LIST
19101: LIST
19102: PUSH
19103: LD_INT 2
19105: PUSH
19106: LD_INT 30
19108: PUSH
19109: LD_INT 8
19111: PUSH
19112: EMPTY
19113: LIST
19114: LIST
19115: PUSH
19116: LD_INT 30
19118: PUSH
19119: LD_INT 7
19121: PUSH
19122: EMPTY
19123: LIST
19124: LIST
19125: PUSH
19126: LD_INT 30
19128: PUSH
19129: LD_INT 11
19131: PUSH
19132: EMPTY
19133: LIST
19134: LIST
19135: PUSH
19136: EMPTY
19137: LIST
19138: LIST
19139: LIST
19140: LIST
19141: PUSH
19142: EMPTY
19143: LIST
19144: LIST
19145: LIST
19146: PPUSH
19147: CALL_OW 69
19151: ST_TO_ADDR
19152: GO 19177
19154: LD_INT 3
19156: DOUBLE
19157: EQUAL
19158: IFTRUE 19162
19160: GO 19176
19162: POP
// labs := [ alien ] ; end ;
19163: LD_ADDR_VAR 0 4
19167: PUSH
19168: LD_INT 1
19170: PUSH
19171: EMPTY
19172: LIST
19173: ST_TO_ADDR
19174: GO 19177
19176: POP
// if not labs then
19177: LD_VAR 0 4
19181: NOT
19182: IFFALSE 19186
// continue ;
19184: GO 18926
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
19186: LD_ADDR_VAR 0 5
19190: PUSH
19191: LD_VAR 0 4
19195: PPUSH
19196: LD_EXP 65
19200: PUSH
19201: LD_VAR 0 1
19205: ARRAY
19206: PUSH
19207: LD_INT 1
19209: ARRAY
19210: PPUSH
19211: LD_EXP 65
19215: PUSH
19216: LD_VAR 0 1
19220: ARRAY
19221: PUSH
19222: LD_INT 2
19224: ARRAY
19225: PPUSH
19226: CALL_OW 73
19230: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
19231: LD_VAR 0 5
19235: NOT
19236: PUSH
19237: LD_VAR 0 5
19241: PUSH
19242: LD_EXP 72
19246: PUSH
19247: LD_VAR 0 1
19251: ARRAY
19252: NONEQUAL
19253: OR
19254: IFFALSE 19359
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
19256: LD_INT 7
19258: PPUSH
19259: LD_EXP 73
19263: PUSH
19264: LD_VAR 0 1
19268: ARRAY
19269: PUSH
19270: LD_INT 3
19272: ARRAY
19273: PPUSH
19274: LD_INT 0
19276: PPUSH
19277: LD_EXP 72
19281: PUSH
19282: LD_VAR 0 1
19286: ARRAY
19287: PPUSH
19288: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
19292: LD_INT 7
19294: PPUSH
19295: LD_EXP 73
19299: PUSH
19300: LD_VAR 0 1
19304: ARRAY
19305: PUSH
19306: LD_INT 1
19308: ARRAY
19309: PPUSH
19310: LD_INT 0
19312: PPUSH
19313: LD_EXP 72
19317: PUSH
19318: LD_VAR 0 1
19322: ARRAY
19323: PPUSH
19324: CALL_OW 468
// if nearestLab then
19328: LD_VAR 0 5
19332: IFFALSE 19359
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
19334: LD_ADDR_EXP 72
19338: PUSH
19339: LD_EXP 72
19343: PPUSH
19344: LD_VAR 0 1
19348: PPUSH
19349: LD_VAR 0 5
19353: PPUSH
19354: CALL_OW 1
19358: ST_TO_ADDR
// end ; if not nearestLab then
19359: LD_VAR 0 5
19363: NOT
19364: IFFALSE 19368
// continue ;
19366: GO 18926
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
19368: LD_VAR 0 5
19372: PPUSH
19373: LD_EXP 65
19377: PUSH
19378: LD_VAR 0 1
19382: ARRAY
19383: PUSH
19384: LD_INT 1
19386: ARRAY
19387: PPUSH
19388: LD_EXP 65
19392: PUSH
19393: LD_VAR 0 1
19397: ARRAY
19398: PUSH
19399: LD_INT 2
19401: ARRAY
19402: PPUSH
19403: CALL_OW 297
19407: PUSH
19408: LD_INT 8
19410: LESS
19411: IFFALSE 19608
// begin if not artifactsResearched [ i ] then
19413: LD_EXP 68
19417: PUSH
19418: LD_VAR 0 1
19422: ARRAY
19423: NOT
19424: IFFALSE 19505
// begin if BuildingStatus ( nearestLab ) = bs_idle then
19426: LD_VAR 0 5
19430: PPUSH
19431: CALL_OW 461
19435: PUSH
19436: LD_INT 2
19438: EQUAL
19439: IFFALSE 19473
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
19441: LD_INT 7
19443: PPUSH
19444: LD_EXP 73
19448: PUSH
19449: LD_VAR 0 1
19453: ARRAY
19454: PUSH
19455: LD_INT 3
19457: ARRAY
19458: PPUSH
19459: LD_INT 2
19461: PPUSH
19462: LD_VAR 0 5
19466: PPUSH
19467: CALL_OW 468
19471: GO 19503
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
19473: LD_INT 7
19475: PPUSH
19476: LD_EXP 73
19480: PUSH
19481: LD_VAR 0 1
19485: ARRAY
19486: PUSH
19487: LD_INT 3
19489: ARRAY
19490: PPUSH
19491: LD_INT 1
19493: PPUSH
19494: LD_VAR 0 5
19498: PPUSH
19499: CALL_OW 468
// end else
19503: GO 19606
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
19505: LD_VAR 0 5
19509: PPUSH
19510: CALL_OW 461
19514: PUSH
19515: LD_INT 2
19517: EQUAL
19518: PUSH
19519: LD_EXP 74
19523: PUSH
19524: LD_VAR 0 1
19528: ARRAY
19529: AND
19530: IFFALSE 19576
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
19532: LD_INT 7
19534: PPUSH
19535: LD_EXP 73
19539: PUSH
19540: LD_VAR 0 1
19544: ARRAY
19545: PUSH
19546: LD_INT 1
19548: ARRAY
19549: PPUSH
19550: LD_EXP 73
19554: PUSH
19555: LD_VAR 0 1
19559: ARRAY
19560: PUSH
19561: LD_INT 2
19563: ARRAY
19564: PPUSH
19565: LD_VAR 0 5
19569: PPUSH
19570: CALL_OW 468
19574: GO 19606
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
19576: LD_INT 7
19578: PPUSH
19579: LD_EXP 73
19583: PUSH
19584: LD_VAR 0 1
19588: ARRAY
19589: PUSH
19590: LD_INT 1
19592: ARRAY
19593: PPUSH
19594: LD_INT 1
19596: PPUSH
19597: LD_VAR 0 5
19601: PPUSH
19602: CALL_OW 468
// end else
19606: GO 19683
// begin if not artifactsResearched [ i ] then
19608: LD_EXP 68
19612: PUSH
19613: LD_VAR 0 1
19617: ARRAY
19618: NOT
19619: IFFALSE 19653
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
19621: LD_INT 7
19623: PPUSH
19624: LD_EXP 73
19628: PUSH
19629: LD_VAR 0 1
19633: ARRAY
19634: PUSH
19635: LD_INT 3
19637: ARRAY
19638: PPUSH
19639: LD_INT 0
19641: PPUSH
19642: LD_VAR 0 5
19646: PPUSH
19647: CALL_OW 468
19651: GO 19683
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
19653: LD_INT 7
19655: PPUSH
19656: LD_EXP 73
19660: PUSH
19661: LD_VAR 0 1
19665: ARRAY
19666: PUSH
19667: LD_INT 1
19669: ARRAY
19670: PPUSH
19671: LD_INT 0
19673: PPUSH
19674: LD_VAR 0 5
19678: PPUSH
19679: CALL_OW 468
// end ; end else
19683: GO 19822
// begin if not artifactsLabs [ i ] then
19685: LD_EXP 72
19689: PUSH
19690: LD_VAR 0 1
19694: ARRAY
19695: NOT
19696: IFFALSE 19700
// continue ;
19698: GO 18926
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
19700: LD_INT 7
19702: PPUSH
19703: LD_EXP 73
19707: PUSH
19708: LD_VAR 0 1
19712: ARRAY
19713: PUSH
19714: LD_INT 3
19716: ARRAY
19717: PPUSH
19718: LD_INT 0
19720: PPUSH
19721: LD_EXP 72
19725: PUSH
19726: LD_VAR 0 1
19730: ARRAY
19731: PPUSH
19732: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
19736: LD_INT 7
19738: PPUSH
19739: LD_EXP 73
19743: PUSH
19744: LD_VAR 0 1
19748: ARRAY
19749: PUSH
19750: LD_INT 1
19752: ARRAY
19753: PPUSH
19754: LD_INT 0
19756: PPUSH
19757: LD_EXP 72
19761: PUSH
19762: LD_VAR 0 1
19766: ARRAY
19767: PPUSH
19768: CALL_OW 468
// if artifactsLabsWorking [ i ] then
19772: LD_EXP 69
19776: PUSH
19777: LD_VAR 0 1
19781: ARRAY
19782: IFFALSE 19822
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
19784: LD_ADDR_EXP 69
19788: PUSH
19789: LD_EXP 69
19793: PPUSH
19794: LD_VAR 0 1
19798: PPUSH
19799: LD_INT 0
19801: PPUSH
19802: CALL_OW 1
19806: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
19807: LD_EXP 72
19811: PUSH
19812: LD_VAR 0 1
19816: ARRAY
19817: PPUSH
19818: CALL_OW 127
// end ; end ; end ;
19822: GO 18926
19824: POP
19825: POP
// end ;
19826: PPOPN 5
19828: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
19829: LD_INT 0
19831: PPUSH
19832: PPUSH
19833: PPUSH
19834: PPUSH
19835: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
19836: LD_VAR 0 2
19840: PUSH
19841: LD_EXP 73
19845: PUSH
19846: LD_INT 1
19848: ARRAY
19849: PUSH
19850: LD_INT 3
19852: ARRAY
19853: EQUAL
19854: IFFALSE 19977
// begin lab := artifactsLabs [ 1 ] ;
19856: LD_ADDR_VAR 0 6
19860: PUSH
19861: LD_EXP 72
19865: PUSH
19866: LD_INT 1
19868: ARRAY
19869: ST_TO_ADDR
// if not lab then
19870: LD_VAR 0 6
19874: NOT
19875: IFFALSE 19879
// exit ;
19877: GO 20957
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
19879: LD_VAR 0 6
19883: PPUSH
19884: LD_EXP 70
19888: PUSH
19889: LD_INT 1
19891: ARRAY
19892: PPUSH
19893: LD_INT 1
19895: PPUSH
19896: CALL_OW 486
// if artifactsResProgress [ 1 ] then
19900: LD_EXP 71
19904: PUSH
19905: LD_INT 1
19907: ARRAY
19908: IFFALSE 19928
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
19910: LD_VAR 0 6
19914: PPUSH
19915: LD_EXP 71
19919: PUSH
19920: LD_INT 1
19922: ARRAY
19923: PPUSH
19924: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
19928: LD_ADDR_EXP 69
19932: PUSH
19933: LD_EXP 69
19937: PPUSH
19938: LD_INT 1
19940: PPUSH
19941: LD_INT 1
19943: PPUSH
19944: CALL_OW 1
19948: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
19949: LD_INT 7
19951: PPUSH
19952: LD_EXP 73
19956: PUSH
19957: LD_INT 1
19959: ARRAY
19960: PUSH
19961: LD_INT 3
19963: ARRAY
19964: PPUSH
19965: LD_INT 0
19967: PPUSH
19968: LD_VAR 0 6
19972: PPUSH
19973: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
19977: LD_VAR 0 2
19981: PUSH
19982: LD_EXP 73
19986: PUSH
19987: LD_INT 2
19989: ARRAY
19990: PUSH
19991: LD_INT 3
19993: ARRAY
19994: EQUAL
19995: IFFALSE 20118
// begin lab := artifactsLabs [ 2 ] ;
19997: LD_ADDR_VAR 0 6
20001: PUSH
20002: LD_EXP 72
20006: PUSH
20007: LD_INT 2
20009: ARRAY
20010: ST_TO_ADDR
// if not lab then
20011: LD_VAR 0 6
20015: NOT
20016: IFFALSE 20020
// exit ;
20018: GO 20957
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
20020: LD_VAR 0 6
20024: PPUSH
20025: LD_EXP 70
20029: PUSH
20030: LD_INT 2
20032: ARRAY
20033: PPUSH
20034: LD_INT 1
20036: PPUSH
20037: CALL_OW 486
// if artifactsResProgress [ 2 ] then
20041: LD_EXP 71
20045: PUSH
20046: LD_INT 2
20048: ARRAY
20049: IFFALSE 20069
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
20051: LD_VAR 0 6
20055: PPUSH
20056: LD_EXP 71
20060: PUSH
20061: LD_INT 2
20063: ARRAY
20064: PPUSH
20065: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
20069: LD_ADDR_EXP 69
20073: PUSH
20074: LD_EXP 69
20078: PPUSH
20079: LD_INT 2
20081: PPUSH
20082: LD_INT 1
20084: PPUSH
20085: CALL_OW 1
20089: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
20090: LD_INT 7
20092: PPUSH
20093: LD_EXP 73
20097: PUSH
20098: LD_INT 2
20100: ARRAY
20101: PUSH
20102: LD_INT 3
20104: ARRAY
20105: PPUSH
20106: LD_INT 0
20108: PPUSH
20109: LD_VAR 0 6
20113: PPUSH
20114: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
20118: LD_VAR 0 2
20122: PUSH
20123: LD_EXP 73
20127: PUSH
20128: LD_INT 3
20130: ARRAY
20131: PUSH
20132: LD_INT 3
20134: ARRAY
20135: EQUAL
20136: IFFALSE 20259
// begin lab := artifactsLabs [ 3 ] ;
20138: LD_ADDR_VAR 0 6
20142: PUSH
20143: LD_EXP 72
20147: PUSH
20148: LD_INT 3
20150: ARRAY
20151: ST_TO_ADDR
// if not lab then
20152: LD_VAR 0 6
20156: NOT
20157: IFFALSE 20161
// exit ;
20159: GO 20957
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
20161: LD_VAR 0 6
20165: PPUSH
20166: LD_EXP 70
20170: PUSH
20171: LD_INT 3
20173: ARRAY
20174: PPUSH
20175: LD_INT 1
20177: PPUSH
20178: CALL_OW 486
// if artifactsResProgress [ 3 ] then
20182: LD_EXP 71
20186: PUSH
20187: LD_INT 3
20189: ARRAY
20190: IFFALSE 20210
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
20192: LD_VAR 0 6
20196: PPUSH
20197: LD_EXP 71
20201: PUSH
20202: LD_INT 3
20204: ARRAY
20205: PPUSH
20206: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
20210: LD_ADDR_EXP 69
20214: PUSH
20215: LD_EXP 69
20219: PPUSH
20220: LD_INT 3
20222: PPUSH
20223: LD_INT 1
20225: PPUSH
20226: CALL_OW 1
20230: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
20231: LD_INT 7
20233: PPUSH
20234: LD_EXP 73
20238: PUSH
20239: LD_INT 3
20241: ARRAY
20242: PUSH
20243: LD_INT 3
20245: ARRAY
20246: PPUSH
20247: LD_INT 0
20249: PPUSH
20250: LD_VAR 0 6
20254: PPUSH
20255: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
20259: LD_VAR 0 2
20263: PUSH
20264: LD_EXP 73
20268: PUSH
20269: LD_INT 1
20271: ARRAY
20272: PUSH
20273: LD_INT 1
20275: ARRAY
20276: EQUAL
20277: IFFALSE 20435
// begin lab := artifactsLabs [ 1 ] ;
20279: LD_ADDR_VAR 0 6
20283: PUSH
20284: LD_EXP 72
20288: PUSH
20289: LD_INT 1
20291: ARRAY
20292: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
20293: LD_VAR 0 6
20297: PPUSH
20298: CALL_OW 274
20302: PPUSH
20303: CALL 89760 0 1
20307: PUSH
20308: LD_INT 3
20310: ARRAY
20311: PUSH
20312: LD_EXP 67
20316: PUSH
20317: LD_INT 1
20319: ARRAY
20320: LESS
20321: IFFALSE 20335
// begin HintSpec ( ArtifactCost , 2 ) ;
20323: LD_STRING ArtifactCost
20325: PPUSH
20326: LD_INT 2
20328: PPUSH
20329: CALL_OW 338
// exit ;
20333: GO 20957
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
20335: LD_ADDR_EXP 74
20339: PUSH
20340: LD_EXP 74
20344: PPUSH
20345: LD_INT 1
20347: PPUSH
20348: LD_INT 0
20350: PPUSH
20351: CALL_OW 1
20355: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
20356: LD_VAR 0 3
20360: PPUSH
20361: LD_VAR 0 4
20365: PPUSH
20366: LD_INT 7
20368: PPUSH
20369: LD_INT 12
20371: NEG
20372: PPUSH
20373: CALL_OW 330
// wait ( 0 0$30 ) ;
20377: LD_INT 1050
20379: PPUSH
20380: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
20384: LD_VAR 0 3
20388: PPUSH
20389: LD_VAR 0 4
20393: PPUSH
20394: LD_INT 7
20396: PPUSH
20397: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
20401: LD_EXP 66
20405: PUSH
20406: LD_INT 1
20408: ARRAY
20409: PPUSH
20410: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
20414: LD_ADDR_EXP 74
20418: PUSH
20419: LD_EXP 74
20423: PPUSH
20424: LD_INT 1
20426: PPUSH
20427: LD_INT 1
20429: PPUSH
20430: CALL_OW 1
20434: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
20435: LD_VAR 0 2
20439: PUSH
20440: LD_EXP 73
20444: PUSH
20445: LD_INT 2
20447: ARRAY
20448: PUSH
20449: LD_INT 1
20451: ARRAY
20452: EQUAL
20453: IFFALSE 20690
// begin lab := artifactsLabs [ 2 ] ;
20455: LD_ADDR_VAR 0 6
20459: PUSH
20460: LD_EXP 72
20464: PUSH
20465: LD_INT 2
20467: ARRAY
20468: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] , [ f_btype , b_ext_siberium ] ] ] ) then
20469: LD_VAR 0 3
20473: PUSH
20474: LD_INT 81
20476: PUSH
20477: LD_INT 7
20479: PUSH
20480: EMPTY
20481: LIST
20482: LIST
20483: PUSH
20484: LD_INT 2
20486: PUSH
20487: LD_INT 32
20489: PUSH
20490: LD_INT 3
20492: PUSH
20493: EMPTY
20494: LIST
20495: LIST
20496: PUSH
20497: LD_INT 30
20499: PUSH
20500: LD_INT 28
20502: PUSH
20503: EMPTY
20504: LIST
20505: LIST
20506: PUSH
20507: LD_INT 30
20509: PUSH
20510: LD_INT 30
20512: PUSH
20513: EMPTY
20514: LIST
20515: LIST
20516: PUSH
20517: LD_INT 35
20519: PUSH
20520: LD_INT 49
20522: PUSH
20523: EMPTY
20524: LIST
20525: LIST
20526: PUSH
20527: LD_INT 34
20529: PUSH
20530: LD_INT 49
20532: PUSH
20533: EMPTY
20534: LIST
20535: LIST
20536: PUSH
20537: LD_INT 30
20539: PUSH
20540: LD_INT 21
20542: PUSH
20543: EMPTY
20544: LIST
20545: LIST
20546: PUSH
20547: EMPTY
20548: LIST
20549: LIST
20550: LIST
20551: LIST
20552: LIST
20553: LIST
20554: LIST
20555: PUSH
20556: EMPTY
20557: LIST
20558: LIST
20559: PPUSH
20560: CALL_OW 69
20564: IN
20565: NOT
20566: IFFALSE 20570
// exit ;
20568: GO 20957
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
20570: LD_VAR 0 6
20574: PPUSH
20575: CALL_OW 274
20579: PPUSH
20580: CALL 89760 0 1
20584: PUSH
20585: LD_INT 3
20587: ARRAY
20588: PUSH
20589: LD_EXP 67
20593: PUSH
20594: LD_INT 2
20596: ARRAY
20597: LESS
20598: IFFALSE 20612
// begin HintSpec ( ArtifactCost , 2 ) ;
20600: LD_STRING ArtifactCost
20602: PPUSH
20603: LD_INT 2
20605: PPUSH
20606: CALL_OW 338
// exit ;
20610: GO 20957
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
20612: LD_ADDR_EXP 74
20616: PUSH
20617: LD_EXP 74
20621: PPUSH
20622: LD_INT 2
20624: PPUSH
20625: LD_INT 0
20627: PPUSH
20628: CALL_OW 1
20632: ST_TO_ADDR
// KillUnit ( x ) ;
20633: LD_VAR 0 3
20637: PPUSH
20638: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
20642: LD_ADDR_EXP 16
20646: PUSH
20647: LD_EXP 16
20651: PUSH
20652: LD_INT 1
20654: PLUS
20655: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
20656: LD_EXP 66
20660: PUSH
20661: LD_INT 2
20663: ARRAY
20664: PPUSH
20665: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
20669: LD_ADDR_EXP 74
20673: PUSH
20674: LD_EXP 74
20678: PPUSH
20679: LD_INT 2
20681: PPUSH
20682: LD_INT 1
20684: PPUSH
20685: CALL_OW 1
20689: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
20690: LD_VAR 0 2
20694: PUSH
20695: LD_EXP 73
20699: PUSH
20700: LD_INT 3
20702: ARRAY
20703: PUSH
20704: LD_INT 1
20706: ARRAY
20707: EQUAL
20708: IFFALSE 20957
// begin lab := artifactsLabs [ 3 ] ;
20710: LD_ADDR_VAR 0 6
20714: PUSH
20715: LD_EXP 72
20719: PUSH
20720: LD_INT 3
20722: ARRAY
20723: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
20724: LD_VAR 0 6
20728: PPUSH
20729: CALL_OW 274
20733: PPUSH
20734: CALL 89760 0 1
20738: PUSH
20739: LD_INT 3
20741: ARRAY
20742: PUSH
20743: LD_EXP 67
20747: PUSH
20748: LD_INT 3
20750: ARRAY
20751: LESS
20752: IFFALSE 20766
// begin HintSpec ( ArtifactCost , 2 ) ;
20754: LD_STRING ArtifactCost
20756: PPUSH
20757: LD_INT 2
20759: PPUSH
20760: CALL_OW 338
// exit ;
20764: GO 20957
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
20766: LD_INT 37
20768: PPUSH
20769: LD_INT 1
20771: PPUSH
20772: CALL_OW 424
// time := 0 0$30 ;
20776: LD_ADDR_VAR 0 7
20780: PUSH
20781: LD_INT 1050
20783: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
20784: LD_ADDR_EXP 74
20788: PUSH
20789: LD_EXP 74
20793: PPUSH
20794: LD_INT 3
20796: PPUSH
20797: LD_INT 0
20799: PPUSH
20800: CALL_OW 1
20804: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
20805: LD_ADDR_OWVAR 47
20809: PUSH
20810: LD_STRING #Am15a-1
20812: PUSH
20813: LD_VAR 0 7
20817: PUSH
20818: EMPTY
20819: LIST
20820: LIST
20821: ST_TO_ADDR
// wait ( 0 0$1 ) ;
20822: LD_INT 35
20824: PPUSH
20825: CALL_OW 67
// time := time - 0 0$1 ;
20829: LD_ADDR_VAR 0 7
20833: PUSH
20834: LD_VAR 0 7
20838: PUSH
20839: LD_INT 35
20841: MINUS
20842: ST_TO_ADDR
// until time = 0 0$00 ;
20843: LD_VAR 0 7
20847: PUSH
20848: LD_INT 0
20850: EQUAL
20851: IFFALSE 20805
// display_strings :=  ;
20853: LD_ADDR_OWVAR 47
20857: PUSH
20858: LD_STRING 
20860: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
20861: LD_INT 37
20863: PPUSH
20864: LD_INT 0
20866: PPUSH
20867: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
20871: LD_ADDR_VAR 0 8
20875: PUSH
20876: LD_INT 37
20878: PPUSH
20879: LD_INT 3
20881: PUSH
20882: LD_INT 21
20884: PUSH
20885: LD_INT 3
20887: PUSH
20888: EMPTY
20889: LIST
20890: LIST
20891: PUSH
20892: EMPTY
20893: LIST
20894: LIST
20895: PPUSH
20896: CALL_OW 70
20900: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
20901: LD_VAR 0 3
20905: PPUSH
20906: LD_VAR 0 4
20910: PPUSH
20911: CALL_OW 84
// for un in list do
20915: LD_ADDR_VAR 0 9
20919: PUSH
20920: LD_VAR 0 8
20924: PUSH
20925: FOR_IN
20926: IFFALSE 20955
// TeleportUnit ( un , x , y , 12 , true ) ;
20928: LD_VAR 0 9
20932: PPUSH
20933: LD_VAR 0 3
20937: PPUSH
20938: LD_VAR 0 4
20942: PPUSH
20943: LD_INT 12
20945: PPUSH
20946: LD_INT 1
20948: PPUSH
20949: CALL_OW 483
20953: GO 20925
20955: POP
20956: POP
// end ; end ;
20957: PPOPN 9
20959: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
20960: LD_INT 0
20962: PPUSH
20963: PPUSH
// begin labNum := 0 ;
20964: LD_ADDR_VAR 0 4
20968: PUSH
20969: LD_INT 0
20971: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20972: LD_ADDR_VAR 0 3
20976: PUSH
20977: DOUBLE
20978: LD_INT 1
20980: DEC
20981: ST_TO_ADDR
20982: LD_EXP 72
20986: PUSH
20987: FOR_TO
20988: IFFALSE 21022
// if artifactsLabs [ i ] = lab then
20990: LD_EXP 72
20994: PUSH
20995: LD_VAR 0 3
20999: ARRAY
21000: PUSH
21001: LD_VAR 0 1
21005: EQUAL
21006: IFFALSE 21020
// begin labNum := i ;
21008: LD_ADDR_VAR 0 4
21012: PUSH
21013: LD_VAR 0 3
21017: ST_TO_ADDR
// break ;
21018: GO 21022
// end ;
21020: GO 20987
21022: POP
21023: POP
// if not labNum then
21024: LD_VAR 0 4
21028: NOT
21029: IFFALSE 21033
// exit ;
21031: GO 21111
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
21033: LD_INT 7
21035: PPUSH
21036: LD_EXP 73
21040: PUSH
21041: LD_VAR 0 4
21045: ARRAY
21046: PUSH
21047: LD_INT 3
21049: ARRAY
21050: PPUSH
21051: LD_INT 2
21053: PPUSH
21054: LD_VAR 0 1
21058: PPUSH
21059: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
21063: LD_ADDR_EXP 71
21067: PUSH
21068: LD_EXP 71
21072: PPUSH
21073: LD_VAR 0 4
21077: PPUSH
21078: LD_VAR 0 2
21082: PPUSH
21083: CALL_OW 1
21087: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
21088: LD_ADDR_EXP 69
21092: PUSH
21093: LD_EXP 69
21097: PPUSH
21098: LD_VAR 0 4
21102: PPUSH
21103: LD_INT 0
21105: PPUSH
21106: CALL_OW 1
21110: ST_TO_ADDR
// end ;
21111: PPOPN 4
21113: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
21114: LD_INT 0
21116: PPUSH
21117: PPUSH
// begin labNum := 0 ;
21118: LD_ADDR_VAR 0 3
21122: PUSH
21123: LD_INT 0
21125: ST_TO_ADDR
// for i = 1 to artifactsLabs do
21126: LD_ADDR_VAR 0 2
21130: PUSH
21131: DOUBLE
21132: LD_INT 1
21134: DEC
21135: ST_TO_ADDR
21136: LD_EXP 72
21140: PUSH
21141: FOR_TO
21142: IFFALSE 21176
// if artifactsLabs [ i ] = lab then
21144: LD_EXP 72
21148: PUSH
21149: LD_VAR 0 2
21153: ARRAY
21154: PUSH
21155: LD_VAR 0 1
21159: EQUAL
21160: IFFALSE 21174
// begin labNum := i ;
21162: LD_ADDR_VAR 0 3
21166: PUSH
21167: LD_VAR 0 2
21171: ST_TO_ADDR
// break ;
21172: GO 21176
// end ;
21174: GO 21141
21176: POP
21177: POP
// if not labNum then
21178: LD_VAR 0 3
21182: NOT
21183: IFFALSE 21187
// exit ;
21185: GO 21349
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
21187: LD_INT 7
21189: PPUSH
21190: LD_EXP 73
21194: PUSH
21195: LD_VAR 0 3
21199: ARRAY
21200: PUSH
21201: LD_INT 3
21203: ARRAY
21204: PPUSH
21205: LD_INT 0
21207: PPUSH
21208: LD_VAR 0 1
21212: PPUSH
21213: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
21217: LD_ADDR_EXP 68
21221: PUSH
21222: LD_EXP 68
21226: PPUSH
21227: LD_VAR 0 3
21231: PPUSH
21232: LD_INT 1
21234: PPUSH
21235: CALL_OW 1
21239: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
21240: LD_ADDR_EXP 74
21244: PUSH
21245: LD_EXP 74
21249: PPUSH
21250: LD_VAR 0 3
21254: PPUSH
21255: LD_INT 1
21257: PPUSH
21258: CALL_OW 1
21262: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
21263: LD_ADDR_EXP 69
21267: PUSH
21268: LD_EXP 69
21272: PPUSH
21273: LD_VAR 0 3
21277: PPUSH
21278: LD_INT 0
21280: PPUSH
21281: CALL_OW 1
21285: ST_TO_ADDR
// case labNum of 1 :
21286: LD_VAR 0 3
21290: PUSH
21291: LD_INT 1
21293: DOUBLE
21294: EQUAL
21295: IFTRUE 21299
21297: GO 21310
21299: POP
// artifactIResearched := true ; 2 :
21300: LD_ADDR_EXP 12
21304: PUSH
21305: LD_INT 1
21307: ST_TO_ADDR
21308: GO 21349
21310: LD_INT 2
21312: DOUBLE
21313: EQUAL
21314: IFTRUE 21318
21316: GO 21329
21318: POP
// artifactIIResearched := true ; 3 :
21319: LD_ADDR_EXP 13
21323: PUSH
21324: LD_INT 1
21326: ST_TO_ADDR
21327: GO 21349
21329: LD_INT 3
21331: DOUBLE
21332: EQUAL
21333: IFTRUE 21337
21335: GO 21348
21337: POP
// artifactIIIResearched := true ; end ;
21338: LD_ADDR_EXP 14
21342: PUSH
21343: LD_INT 1
21345: ST_TO_ADDR
21346: GO 21349
21348: POP
// end ; end_of_file
21349: PPOPN 3
21351: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
21352: LD_INT 0
21354: PPUSH
21355: PPUSH
// skirmish := false ;
21356: LD_ADDR_EXP 75
21360: PUSH
21361: LD_INT 0
21363: ST_TO_ADDR
// debug_mc := false ;
21364: LD_ADDR_EXP 76
21368: PUSH
21369: LD_INT 0
21371: ST_TO_ADDR
// mc_bases := [ ] ;
21372: LD_ADDR_EXP 77
21376: PUSH
21377: EMPTY
21378: ST_TO_ADDR
// mc_sides := [ ] ;
21379: LD_ADDR_EXP 103
21383: PUSH
21384: EMPTY
21385: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
21386: LD_ADDR_EXP 78
21390: PUSH
21391: EMPTY
21392: ST_TO_ADDR
// mc_building_repairs := [ ] ;
21393: LD_ADDR_EXP 79
21397: PUSH
21398: EMPTY
21399: ST_TO_ADDR
// mc_need_heal := [ ] ;
21400: LD_ADDR_EXP 80
21404: PUSH
21405: EMPTY
21406: ST_TO_ADDR
// mc_healers := [ ] ;
21407: LD_ADDR_EXP 81
21411: PUSH
21412: EMPTY
21413: ST_TO_ADDR
// mc_build_list := [ ] ;
21414: LD_ADDR_EXP 82
21418: PUSH
21419: EMPTY
21420: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
21421: LD_ADDR_EXP 109
21425: PUSH
21426: EMPTY
21427: ST_TO_ADDR
// mc_builders := [ ] ;
21428: LD_ADDR_EXP 83
21432: PUSH
21433: EMPTY
21434: ST_TO_ADDR
// mc_construct_list := [ ] ;
21435: LD_ADDR_EXP 84
21439: PUSH
21440: EMPTY
21441: ST_TO_ADDR
// mc_turret_list := [ ] ;
21442: LD_ADDR_EXP 85
21446: PUSH
21447: EMPTY
21448: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
21449: LD_ADDR_EXP 86
21453: PUSH
21454: EMPTY
21455: ST_TO_ADDR
// mc_miners := [ ] ;
21456: LD_ADDR_EXP 91
21460: PUSH
21461: EMPTY
21462: ST_TO_ADDR
// mc_mines := [ ] ;
21463: LD_ADDR_EXP 90
21467: PUSH
21468: EMPTY
21469: ST_TO_ADDR
// mc_minefields := [ ] ;
21470: LD_ADDR_EXP 92
21474: PUSH
21475: EMPTY
21476: ST_TO_ADDR
// mc_crates := [ ] ;
21477: LD_ADDR_EXP 93
21481: PUSH
21482: EMPTY
21483: ST_TO_ADDR
// mc_crates_collector := [ ] ;
21484: LD_ADDR_EXP 94
21488: PUSH
21489: EMPTY
21490: ST_TO_ADDR
// mc_crates_area := [ ] ;
21491: LD_ADDR_EXP 95
21495: PUSH
21496: EMPTY
21497: ST_TO_ADDR
// mc_vehicles := [ ] ;
21498: LD_ADDR_EXP 96
21502: PUSH
21503: EMPTY
21504: ST_TO_ADDR
// mc_attack := [ ] ;
21505: LD_ADDR_EXP 97
21509: PUSH
21510: EMPTY
21511: ST_TO_ADDR
// mc_produce := [ ] ;
21512: LD_ADDR_EXP 98
21516: PUSH
21517: EMPTY
21518: ST_TO_ADDR
// mc_defender := [ ] ;
21519: LD_ADDR_EXP 99
21523: PUSH
21524: EMPTY
21525: ST_TO_ADDR
// mc_parking := [ ] ;
21526: LD_ADDR_EXP 101
21530: PUSH
21531: EMPTY
21532: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
21533: LD_ADDR_EXP 87
21537: PUSH
21538: EMPTY
21539: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
21540: LD_ADDR_EXP 89
21544: PUSH
21545: EMPTY
21546: ST_TO_ADDR
// mc_scan := [ ] ;
21547: LD_ADDR_EXP 100
21551: PUSH
21552: EMPTY
21553: ST_TO_ADDR
// mc_scan_area := [ ] ;
21554: LD_ADDR_EXP 102
21558: PUSH
21559: EMPTY
21560: ST_TO_ADDR
// mc_tech := [ ] ;
21561: LD_ADDR_EXP 104
21565: PUSH
21566: EMPTY
21567: ST_TO_ADDR
// mc_class := [ ] ;
21568: LD_ADDR_EXP 118
21572: PUSH
21573: EMPTY
21574: ST_TO_ADDR
// mc_class_case_use := [ ] ;
21575: LD_ADDR_EXP 119
21579: PUSH
21580: EMPTY
21581: ST_TO_ADDR
// mc_is_defending := [ ] ;
21582: LD_ADDR_EXP 120
21586: PUSH
21587: EMPTY
21588: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
21589: LD_ADDR_EXP 111
21593: PUSH
21594: EMPTY
21595: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
21596: LD_ADDR_EXP 121
21600: PUSH
21601: LD_INT 0
21603: ST_TO_ADDR
// end ;
21604: LD_VAR 0 1
21608: RET
// export function MC_Kill ( base ) ; begin
21609: LD_INT 0
21611: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
21612: LD_ADDR_EXP 77
21616: PUSH
21617: LD_EXP 77
21621: PPUSH
21622: LD_VAR 0 1
21626: PPUSH
21627: EMPTY
21628: PPUSH
21629: CALL_OW 1
21633: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
21634: LD_ADDR_EXP 78
21638: PUSH
21639: LD_EXP 78
21643: PPUSH
21644: LD_VAR 0 1
21648: PPUSH
21649: EMPTY
21650: PPUSH
21651: CALL_OW 1
21655: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
21656: LD_ADDR_EXP 79
21660: PUSH
21661: LD_EXP 79
21665: PPUSH
21666: LD_VAR 0 1
21670: PPUSH
21671: EMPTY
21672: PPUSH
21673: CALL_OW 1
21677: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
21678: LD_ADDR_EXP 80
21682: PUSH
21683: LD_EXP 80
21687: PPUSH
21688: LD_VAR 0 1
21692: PPUSH
21693: EMPTY
21694: PPUSH
21695: CALL_OW 1
21699: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
21700: LD_ADDR_EXP 81
21704: PUSH
21705: LD_EXP 81
21709: PPUSH
21710: LD_VAR 0 1
21714: PPUSH
21715: EMPTY
21716: PPUSH
21717: CALL_OW 1
21721: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
21722: LD_ADDR_EXP 82
21726: PUSH
21727: LD_EXP 82
21731: PPUSH
21732: LD_VAR 0 1
21736: PPUSH
21737: EMPTY
21738: PPUSH
21739: CALL_OW 1
21743: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
21744: LD_ADDR_EXP 83
21748: PUSH
21749: LD_EXP 83
21753: PPUSH
21754: LD_VAR 0 1
21758: PPUSH
21759: EMPTY
21760: PPUSH
21761: CALL_OW 1
21765: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
21766: LD_ADDR_EXP 84
21770: PUSH
21771: LD_EXP 84
21775: PPUSH
21776: LD_VAR 0 1
21780: PPUSH
21781: EMPTY
21782: PPUSH
21783: CALL_OW 1
21787: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
21788: LD_ADDR_EXP 85
21792: PUSH
21793: LD_EXP 85
21797: PPUSH
21798: LD_VAR 0 1
21802: PPUSH
21803: EMPTY
21804: PPUSH
21805: CALL_OW 1
21809: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
21810: LD_ADDR_EXP 86
21814: PUSH
21815: LD_EXP 86
21819: PPUSH
21820: LD_VAR 0 1
21824: PPUSH
21825: EMPTY
21826: PPUSH
21827: CALL_OW 1
21831: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
21832: LD_ADDR_EXP 87
21836: PUSH
21837: LD_EXP 87
21841: PPUSH
21842: LD_VAR 0 1
21846: PPUSH
21847: EMPTY
21848: PPUSH
21849: CALL_OW 1
21853: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
21854: LD_ADDR_EXP 88
21858: PUSH
21859: LD_EXP 88
21863: PPUSH
21864: LD_VAR 0 1
21868: PPUSH
21869: LD_INT 0
21871: PPUSH
21872: CALL_OW 1
21876: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21877: LD_ADDR_EXP 89
21881: PUSH
21882: LD_EXP 89
21886: PPUSH
21887: LD_VAR 0 1
21891: PPUSH
21892: EMPTY
21893: PPUSH
21894: CALL_OW 1
21898: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21899: LD_ADDR_EXP 90
21903: PUSH
21904: LD_EXP 90
21908: PPUSH
21909: LD_VAR 0 1
21913: PPUSH
21914: EMPTY
21915: PPUSH
21916: CALL_OW 1
21920: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
21921: LD_ADDR_EXP 91
21925: PUSH
21926: LD_EXP 91
21930: PPUSH
21931: LD_VAR 0 1
21935: PPUSH
21936: EMPTY
21937: PPUSH
21938: CALL_OW 1
21942: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
21943: LD_ADDR_EXP 92
21947: PUSH
21948: LD_EXP 92
21952: PPUSH
21953: LD_VAR 0 1
21957: PPUSH
21958: EMPTY
21959: PPUSH
21960: CALL_OW 1
21964: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
21965: LD_ADDR_EXP 93
21969: PUSH
21970: LD_EXP 93
21974: PPUSH
21975: LD_VAR 0 1
21979: PPUSH
21980: EMPTY
21981: PPUSH
21982: CALL_OW 1
21986: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
21987: LD_ADDR_EXP 94
21991: PUSH
21992: LD_EXP 94
21996: PPUSH
21997: LD_VAR 0 1
22001: PPUSH
22002: EMPTY
22003: PPUSH
22004: CALL_OW 1
22008: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
22009: LD_ADDR_EXP 95
22013: PUSH
22014: LD_EXP 95
22018: PPUSH
22019: LD_VAR 0 1
22023: PPUSH
22024: EMPTY
22025: PPUSH
22026: CALL_OW 1
22030: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
22031: LD_ADDR_EXP 96
22035: PUSH
22036: LD_EXP 96
22040: PPUSH
22041: LD_VAR 0 1
22045: PPUSH
22046: EMPTY
22047: PPUSH
22048: CALL_OW 1
22052: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
22053: LD_ADDR_EXP 97
22057: PUSH
22058: LD_EXP 97
22062: PPUSH
22063: LD_VAR 0 1
22067: PPUSH
22068: EMPTY
22069: PPUSH
22070: CALL_OW 1
22074: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
22075: LD_ADDR_EXP 98
22079: PUSH
22080: LD_EXP 98
22084: PPUSH
22085: LD_VAR 0 1
22089: PPUSH
22090: EMPTY
22091: PPUSH
22092: CALL_OW 1
22096: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
22097: LD_ADDR_EXP 99
22101: PUSH
22102: LD_EXP 99
22106: PPUSH
22107: LD_VAR 0 1
22111: PPUSH
22112: EMPTY
22113: PPUSH
22114: CALL_OW 1
22118: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
22119: LD_ADDR_EXP 100
22123: PUSH
22124: LD_EXP 100
22128: PPUSH
22129: LD_VAR 0 1
22133: PPUSH
22134: EMPTY
22135: PPUSH
22136: CALL_OW 1
22140: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
22141: LD_ADDR_EXP 101
22145: PUSH
22146: LD_EXP 101
22150: PPUSH
22151: LD_VAR 0 1
22155: PPUSH
22156: EMPTY
22157: PPUSH
22158: CALL_OW 1
22162: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
22163: LD_ADDR_EXP 102
22167: PUSH
22168: LD_EXP 102
22172: PPUSH
22173: LD_VAR 0 1
22177: PPUSH
22178: EMPTY
22179: PPUSH
22180: CALL_OW 1
22184: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
22185: LD_ADDR_EXP 104
22189: PUSH
22190: LD_EXP 104
22194: PPUSH
22195: LD_VAR 0 1
22199: PPUSH
22200: EMPTY
22201: PPUSH
22202: CALL_OW 1
22206: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
22207: LD_ADDR_EXP 106
22211: PUSH
22212: LD_EXP 106
22216: PPUSH
22217: LD_VAR 0 1
22221: PPUSH
22222: EMPTY
22223: PPUSH
22224: CALL_OW 1
22228: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
22229: LD_ADDR_EXP 107
22233: PUSH
22234: LD_EXP 107
22238: PPUSH
22239: LD_VAR 0 1
22243: PPUSH
22244: EMPTY
22245: PPUSH
22246: CALL_OW 1
22250: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
22251: LD_ADDR_EXP 108
22255: PUSH
22256: LD_EXP 108
22260: PPUSH
22261: LD_VAR 0 1
22265: PPUSH
22266: EMPTY
22267: PPUSH
22268: CALL_OW 1
22272: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
22273: LD_ADDR_EXP 109
22277: PUSH
22278: LD_EXP 109
22282: PPUSH
22283: LD_VAR 0 1
22287: PPUSH
22288: EMPTY
22289: PPUSH
22290: CALL_OW 1
22294: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
22295: LD_ADDR_EXP 110
22299: PUSH
22300: LD_EXP 110
22304: PPUSH
22305: LD_VAR 0 1
22309: PPUSH
22310: EMPTY
22311: PPUSH
22312: CALL_OW 1
22316: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
22317: LD_ADDR_EXP 111
22321: PUSH
22322: LD_EXP 111
22326: PPUSH
22327: LD_VAR 0 1
22331: PPUSH
22332: EMPTY
22333: PPUSH
22334: CALL_OW 1
22338: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
22339: LD_ADDR_EXP 112
22343: PUSH
22344: LD_EXP 112
22348: PPUSH
22349: LD_VAR 0 1
22353: PPUSH
22354: EMPTY
22355: PPUSH
22356: CALL_OW 1
22360: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
22361: LD_ADDR_EXP 113
22365: PUSH
22366: LD_EXP 113
22370: PPUSH
22371: LD_VAR 0 1
22375: PPUSH
22376: EMPTY
22377: PPUSH
22378: CALL_OW 1
22382: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
22383: LD_ADDR_EXP 114
22387: PUSH
22388: LD_EXP 114
22392: PPUSH
22393: LD_VAR 0 1
22397: PPUSH
22398: EMPTY
22399: PPUSH
22400: CALL_OW 1
22404: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
22405: LD_ADDR_EXP 115
22409: PUSH
22410: LD_EXP 115
22414: PPUSH
22415: LD_VAR 0 1
22419: PPUSH
22420: EMPTY
22421: PPUSH
22422: CALL_OW 1
22426: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
22427: LD_ADDR_EXP 116
22431: PUSH
22432: LD_EXP 116
22436: PPUSH
22437: LD_VAR 0 1
22441: PPUSH
22442: EMPTY
22443: PPUSH
22444: CALL_OW 1
22448: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
22449: LD_ADDR_EXP 117
22453: PUSH
22454: LD_EXP 117
22458: PPUSH
22459: LD_VAR 0 1
22463: PPUSH
22464: EMPTY
22465: PPUSH
22466: CALL_OW 1
22470: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
22471: LD_ADDR_EXP 118
22475: PUSH
22476: LD_EXP 118
22480: PPUSH
22481: LD_VAR 0 1
22485: PPUSH
22486: EMPTY
22487: PPUSH
22488: CALL_OW 1
22492: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
22493: LD_ADDR_EXP 119
22497: PUSH
22498: LD_EXP 119
22502: PPUSH
22503: LD_VAR 0 1
22507: PPUSH
22508: LD_INT 0
22510: PPUSH
22511: CALL_OW 1
22515: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
22516: LD_ADDR_EXP 120
22520: PUSH
22521: LD_EXP 120
22525: PPUSH
22526: LD_VAR 0 1
22530: PPUSH
22531: LD_INT 0
22533: PPUSH
22534: CALL_OW 1
22538: ST_TO_ADDR
// end ;
22539: LD_VAR 0 2
22543: RET
// export function MC_Add ( side , units ) ; var base ; begin
22544: LD_INT 0
22546: PPUSH
22547: PPUSH
// base := mc_bases + 1 ;
22548: LD_ADDR_VAR 0 4
22552: PUSH
22553: LD_EXP 77
22557: PUSH
22558: LD_INT 1
22560: PLUS
22561: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
22562: LD_ADDR_EXP 103
22566: PUSH
22567: LD_EXP 103
22571: PPUSH
22572: LD_VAR 0 4
22576: PPUSH
22577: LD_VAR 0 1
22581: PPUSH
22582: CALL_OW 1
22586: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
22587: LD_ADDR_EXP 77
22591: PUSH
22592: LD_EXP 77
22596: PPUSH
22597: LD_VAR 0 4
22601: PPUSH
22602: LD_VAR 0 2
22606: PPUSH
22607: CALL_OW 1
22611: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
22612: LD_ADDR_EXP 78
22616: PUSH
22617: LD_EXP 78
22621: PPUSH
22622: LD_VAR 0 4
22626: PPUSH
22627: EMPTY
22628: PPUSH
22629: CALL_OW 1
22633: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
22634: LD_ADDR_EXP 79
22638: PUSH
22639: LD_EXP 79
22643: PPUSH
22644: LD_VAR 0 4
22648: PPUSH
22649: EMPTY
22650: PPUSH
22651: CALL_OW 1
22655: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
22656: LD_ADDR_EXP 80
22660: PUSH
22661: LD_EXP 80
22665: PPUSH
22666: LD_VAR 0 4
22670: PPUSH
22671: EMPTY
22672: PPUSH
22673: CALL_OW 1
22677: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
22678: LD_ADDR_EXP 81
22682: PUSH
22683: LD_EXP 81
22687: PPUSH
22688: LD_VAR 0 4
22692: PPUSH
22693: EMPTY
22694: PPUSH
22695: CALL_OW 1
22699: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
22700: LD_ADDR_EXP 82
22704: PUSH
22705: LD_EXP 82
22709: PPUSH
22710: LD_VAR 0 4
22714: PPUSH
22715: EMPTY
22716: PPUSH
22717: CALL_OW 1
22721: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
22722: LD_ADDR_EXP 83
22726: PUSH
22727: LD_EXP 83
22731: PPUSH
22732: LD_VAR 0 4
22736: PPUSH
22737: EMPTY
22738: PPUSH
22739: CALL_OW 1
22743: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
22744: LD_ADDR_EXP 84
22748: PUSH
22749: LD_EXP 84
22753: PPUSH
22754: LD_VAR 0 4
22758: PPUSH
22759: EMPTY
22760: PPUSH
22761: CALL_OW 1
22765: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
22766: LD_ADDR_EXP 85
22770: PUSH
22771: LD_EXP 85
22775: PPUSH
22776: LD_VAR 0 4
22780: PPUSH
22781: EMPTY
22782: PPUSH
22783: CALL_OW 1
22787: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
22788: LD_ADDR_EXP 86
22792: PUSH
22793: LD_EXP 86
22797: PPUSH
22798: LD_VAR 0 4
22802: PPUSH
22803: EMPTY
22804: PPUSH
22805: CALL_OW 1
22809: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
22810: LD_ADDR_EXP 87
22814: PUSH
22815: LD_EXP 87
22819: PPUSH
22820: LD_VAR 0 4
22824: PPUSH
22825: EMPTY
22826: PPUSH
22827: CALL_OW 1
22831: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
22832: LD_ADDR_EXP 88
22836: PUSH
22837: LD_EXP 88
22841: PPUSH
22842: LD_VAR 0 4
22846: PPUSH
22847: LD_INT 0
22849: PPUSH
22850: CALL_OW 1
22854: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
22855: LD_ADDR_EXP 89
22859: PUSH
22860: LD_EXP 89
22864: PPUSH
22865: LD_VAR 0 4
22869: PPUSH
22870: EMPTY
22871: PPUSH
22872: CALL_OW 1
22876: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
22877: LD_ADDR_EXP 90
22881: PUSH
22882: LD_EXP 90
22886: PPUSH
22887: LD_VAR 0 4
22891: PPUSH
22892: EMPTY
22893: PPUSH
22894: CALL_OW 1
22898: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
22899: LD_ADDR_EXP 91
22903: PUSH
22904: LD_EXP 91
22908: PPUSH
22909: LD_VAR 0 4
22913: PPUSH
22914: EMPTY
22915: PPUSH
22916: CALL_OW 1
22920: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
22921: LD_ADDR_EXP 92
22925: PUSH
22926: LD_EXP 92
22930: PPUSH
22931: LD_VAR 0 4
22935: PPUSH
22936: EMPTY
22937: PPUSH
22938: CALL_OW 1
22942: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
22943: LD_ADDR_EXP 93
22947: PUSH
22948: LD_EXP 93
22952: PPUSH
22953: LD_VAR 0 4
22957: PPUSH
22958: EMPTY
22959: PPUSH
22960: CALL_OW 1
22964: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
22965: LD_ADDR_EXP 94
22969: PUSH
22970: LD_EXP 94
22974: PPUSH
22975: LD_VAR 0 4
22979: PPUSH
22980: EMPTY
22981: PPUSH
22982: CALL_OW 1
22986: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
22987: LD_ADDR_EXP 95
22991: PUSH
22992: LD_EXP 95
22996: PPUSH
22997: LD_VAR 0 4
23001: PPUSH
23002: EMPTY
23003: PPUSH
23004: CALL_OW 1
23008: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
23009: LD_ADDR_EXP 96
23013: PUSH
23014: LD_EXP 96
23018: PPUSH
23019: LD_VAR 0 4
23023: PPUSH
23024: EMPTY
23025: PPUSH
23026: CALL_OW 1
23030: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
23031: LD_ADDR_EXP 97
23035: PUSH
23036: LD_EXP 97
23040: PPUSH
23041: LD_VAR 0 4
23045: PPUSH
23046: EMPTY
23047: PPUSH
23048: CALL_OW 1
23052: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
23053: LD_ADDR_EXP 98
23057: PUSH
23058: LD_EXP 98
23062: PPUSH
23063: LD_VAR 0 4
23067: PPUSH
23068: EMPTY
23069: PPUSH
23070: CALL_OW 1
23074: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
23075: LD_ADDR_EXP 99
23079: PUSH
23080: LD_EXP 99
23084: PPUSH
23085: LD_VAR 0 4
23089: PPUSH
23090: EMPTY
23091: PPUSH
23092: CALL_OW 1
23096: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
23097: LD_ADDR_EXP 100
23101: PUSH
23102: LD_EXP 100
23106: PPUSH
23107: LD_VAR 0 4
23111: PPUSH
23112: EMPTY
23113: PPUSH
23114: CALL_OW 1
23118: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
23119: LD_ADDR_EXP 101
23123: PUSH
23124: LD_EXP 101
23128: PPUSH
23129: LD_VAR 0 4
23133: PPUSH
23134: EMPTY
23135: PPUSH
23136: CALL_OW 1
23140: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
23141: LD_ADDR_EXP 102
23145: PUSH
23146: LD_EXP 102
23150: PPUSH
23151: LD_VAR 0 4
23155: PPUSH
23156: EMPTY
23157: PPUSH
23158: CALL_OW 1
23162: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
23163: LD_ADDR_EXP 104
23167: PUSH
23168: LD_EXP 104
23172: PPUSH
23173: LD_VAR 0 4
23177: PPUSH
23178: EMPTY
23179: PPUSH
23180: CALL_OW 1
23184: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
23185: LD_ADDR_EXP 106
23189: PUSH
23190: LD_EXP 106
23194: PPUSH
23195: LD_VAR 0 4
23199: PPUSH
23200: EMPTY
23201: PPUSH
23202: CALL_OW 1
23206: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
23207: LD_ADDR_EXP 107
23211: PUSH
23212: LD_EXP 107
23216: PPUSH
23217: LD_VAR 0 4
23221: PPUSH
23222: EMPTY
23223: PPUSH
23224: CALL_OW 1
23228: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
23229: LD_ADDR_EXP 108
23233: PUSH
23234: LD_EXP 108
23238: PPUSH
23239: LD_VAR 0 4
23243: PPUSH
23244: EMPTY
23245: PPUSH
23246: CALL_OW 1
23250: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
23251: LD_ADDR_EXP 109
23255: PUSH
23256: LD_EXP 109
23260: PPUSH
23261: LD_VAR 0 4
23265: PPUSH
23266: EMPTY
23267: PPUSH
23268: CALL_OW 1
23272: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
23273: LD_ADDR_EXP 110
23277: PUSH
23278: LD_EXP 110
23282: PPUSH
23283: LD_VAR 0 4
23287: PPUSH
23288: EMPTY
23289: PPUSH
23290: CALL_OW 1
23294: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
23295: LD_ADDR_EXP 111
23299: PUSH
23300: LD_EXP 111
23304: PPUSH
23305: LD_VAR 0 4
23309: PPUSH
23310: EMPTY
23311: PPUSH
23312: CALL_OW 1
23316: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
23317: LD_ADDR_EXP 112
23321: PUSH
23322: LD_EXP 112
23326: PPUSH
23327: LD_VAR 0 4
23331: PPUSH
23332: EMPTY
23333: PPUSH
23334: CALL_OW 1
23338: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
23339: LD_ADDR_EXP 113
23343: PUSH
23344: LD_EXP 113
23348: PPUSH
23349: LD_VAR 0 4
23353: PPUSH
23354: EMPTY
23355: PPUSH
23356: CALL_OW 1
23360: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
23361: LD_ADDR_EXP 114
23365: PUSH
23366: LD_EXP 114
23370: PPUSH
23371: LD_VAR 0 4
23375: PPUSH
23376: EMPTY
23377: PPUSH
23378: CALL_OW 1
23382: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
23383: LD_ADDR_EXP 115
23387: PUSH
23388: LD_EXP 115
23392: PPUSH
23393: LD_VAR 0 4
23397: PPUSH
23398: EMPTY
23399: PPUSH
23400: CALL_OW 1
23404: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
23405: LD_ADDR_EXP 116
23409: PUSH
23410: LD_EXP 116
23414: PPUSH
23415: LD_VAR 0 4
23419: PPUSH
23420: EMPTY
23421: PPUSH
23422: CALL_OW 1
23426: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
23427: LD_ADDR_EXP 117
23431: PUSH
23432: LD_EXP 117
23436: PPUSH
23437: LD_VAR 0 4
23441: PPUSH
23442: EMPTY
23443: PPUSH
23444: CALL_OW 1
23448: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
23449: LD_ADDR_EXP 118
23453: PUSH
23454: LD_EXP 118
23458: PPUSH
23459: LD_VAR 0 4
23463: PPUSH
23464: EMPTY
23465: PPUSH
23466: CALL_OW 1
23470: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
23471: LD_ADDR_EXP 119
23475: PUSH
23476: LD_EXP 119
23480: PPUSH
23481: LD_VAR 0 4
23485: PPUSH
23486: LD_INT 0
23488: PPUSH
23489: CALL_OW 1
23493: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
23494: LD_ADDR_EXP 120
23498: PUSH
23499: LD_EXP 120
23503: PPUSH
23504: LD_VAR 0 4
23508: PPUSH
23509: LD_INT 0
23511: PPUSH
23512: CALL_OW 1
23516: ST_TO_ADDR
// result := base ;
23517: LD_ADDR_VAR 0 3
23521: PUSH
23522: LD_VAR 0 4
23526: ST_TO_ADDR
// end ;
23527: LD_VAR 0 3
23531: RET
// export function MC_Start ( ) ; var i ; begin
23532: LD_INT 0
23534: PPUSH
23535: PPUSH
// for i = 1 to mc_bases do
23536: LD_ADDR_VAR 0 2
23540: PUSH
23541: DOUBLE
23542: LD_INT 1
23544: DEC
23545: ST_TO_ADDR
23546: LD_EXP 77
23550: PUSH
23551: FOR_TO
23552: IFFALSE 24652
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
23554: LD_ADDR_EXP 77
23558: PUSH
23559: LD_EXP 77
23563: PPUSH
23564: LD_VAR 0 2
23568: PPUSH
23569: LD_EXP 77
23573: PUSH
23574: LD_VAR 0 2
23578: ARRAY
23579: PUSH
23580: LD_INT 0
23582: DIFF
23583: PPUSH
23584: CALL_OW 1
23588: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
23589: LD_ADDR_EXP 78
23593: PUSH
23594: LD_EXP 78
23598: PPUSH
23599: LD_VAR 0 2
23603: PPUSH
23604: EMPTY
23605: PPUSH
23606: CALL_OW 1
23610: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
23611: LD_ADDR_EXP 79
23615: PUSH
23616: LD_EXP 79
23620: PPUSH
23621: LD_VAR 0 2
23625: PPUSH
23626: EMPTY
23627: PPUSH
23628: CALL_OW 1
23632: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
23633: LD_ADDR_EXP 80
23637: PUSH
23638: LD_EXP 80
23642: PPUSH
23643: LD_VAR 0 2
23647: PPUSH
23648: EMPTY
23649: PPUSH
23650: CALL_OW 1
23654: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
23655: LD_ADDR_EXP 81
23659: PUSH
23660: LD_EXP 81
23664: PPUSH
23665: LD_VAR 0 2
23669: PPUSH
23670: EMPTY
23671: PUSH
23672: EMPTY
23673: PUSH
23674: EMPTY
23675: LIST
23676: LIST
23677: PPUSH
23678: CALL_OW 1
23682: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
23683: LD_ADDR_EXP 82
23687: PUSH
23688: LD_EXP 82
23692: PPUSH
23693: LD_VAR 0 2
23697: PPUSH
23698: EMPTY
23699: PPUSH
23700: CALL_OW 1
23704: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
23705: LD_ADDR_EXP 109
23709: PUSH
23710: LD_EXP 109
23714: PPUSH
23715: LD_VAR 0 2
23719: PPUSH
23720: EMPTY
23721: PPUSH
23722: CALL_OW 1
23726: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
23727: LD_ADDR_EXP 83
23731: PUSH
23732: LD_EXP 83
23736: PPUSH
23737: LD_VAR 0 2
23741: PPUSH
23742: EMPTY
23743: PPUSH
23744: CALL_OW 1
23748: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
23749: LD_ADDR_EXP 84
23753: PUSH
23754: LD_EXP 84
23758: PPUSH
23759: LD_VAR 0 2
23763: PPUSH
23764: EMPTY
23765: PPUSH
23766: CALL_OW 1
23770: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
23771: LD_ADDR_EXP 85
23775: PUSH
23776: LD_EXP 85
23780: PPUSH
23781: LD_VAR 0 2
23785: PPUSH
23786: LD_EXP 77
23790: PUSH
23791: LD_VAR 0 2
23795: ARRAY
23796: PPUSH
23797: LD_INT 2
23799: PUSH
23800: LD_INT 30
23802: PUSH
23803: LD_INT 32
23805: PUSH
23806: EMPTY
23807: LIST
23808: LIST
23809: PUSH
23810: LD_INT 30
23812: PUSH
23813: LD_INT 33
23815: PUSH
23816: EMPTY
23817: LIST
23818: LIST
23819: PUSH
23820: EMPTY
23821: LIST
23822: LIST
23823: LIST
23824: PPUSH
23825: CALL_OW 72
23829: PPUSH
23830: CALL_OW 1
23834: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
23835: LD_ADDR_EXP 86
23839: PUSH
23840: LD_EXP 86
23844: PPUSH
23845: LD_VAR 0 2
23849: PPUSH
23850: LD_EXP 77
23854: PUSH
23855: LD_VAR 0 2
23859: ARRAY
23860: PPUSH
23861: LD_INT 2
23863: PUSH
23864: LD_INT 30
23866: PUSH
23867: LD_INT 32
23869: PUSH
23870: EMPTY
23871: LIST
23872: LIST
23873: PUSH
23874: LD_INT 30
23876: PUSH
23877: LD_INT 31
23879: PUSH
23880: EMPTY
23881: LIST
23882: LIST
23883: PUSH
23884: EMPTY
23885: LIST
23886: LIST
23887: LIST
23888: PUSH
23889: LD_INT 58
23891: PUSH
23892: EMPTY
23893: LIST
23894: PUSH
23895: EMPTY
23896: LIST
23897: LIST
23898: PPUSH
23899: CALL_OW 72
23903: PPUSH
23904: CALL_OW 1
23908: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
23909: LD_ADDR_EXP 87
23913: PUSH
23914: LD_EXP 87
23918: PPUSH
23919: LD_VAR 0 2
23923: PPUSH
23924: EMPTY
23925: PPUSH
23926: CALL_OW 1
23930: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
23931: LD_ADDR_EXP 91
23935: PUSH
23936: LD_EXP 91
23940: PPUSH
23941: LD_VAR 0 2
23945: PPUSH
23946: EMPTY
23947: PPUSH
23948: CALL_OW 1
23952: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
23953: LD_ADDR_EXP 90
23957: PUSH
23958: LD_EXP 90
23962: PPUSH
23963: LD_VAR 0 2
23967: PPUSH
23968: EMPTY
23969: PPUSH
23970: CALL_OW 1
23974: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
23975: LD_ADDR_EXP 92
23979: PUSH
23980: LD_EXP 92
23984: PPUSH
23985: LD_VAR 0 2
23989: PPUSH
23990: EMPTY
23991: PPUSH
23992: CALL_OW 1
23996: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
23997: LD_ADDR_EXP 93
24001: PUSH
24002: LD_EXP 93
24006: PPUSH
24007: LD_VAR 0 2
24011: PPUSH
24012: EMPTY
24013: PPUSH
24014: CALL_OW 1
24018: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
24019: LD_ADDR_EXP 94
24023: PUSH
24024: LD_EXP 94
24028: PPUSH
24029: LD_VAR 0 2
24033: PPUSH
24034: EMPTY
24035: PPUSH
24036: CALL_OW 1
24040: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
24041: LD_ADDR_EXP 95
24045: PUSH
24046: LD_EXP 95
24050: PPUSH
24051: LD_VAR 0 2
24055: PPUSH
24056: EMPTY
24057: PPUSH
24058: CALL_OW 1
24062: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
24063: LD_ADDR_EXP 96
24067: PUSH
24068: LD_EXP 96
24072: PPUSH
24073: LD_VAR 0 2
24077: PPUSH
24078: EMPTY
24079: PPUSH
24080: CALL_OW 1
24084: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
24085: LD_ADDR_EXP 97
24089: PUSH
24090: LD_EXP 97
24094: PPUSH
24095: LD_VAR 0 2
24099: PPUSH
24100: EMPTY
24101: PPUSH
24102: CALL_OW 1
24106: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
24107: LD_ADDR_EXP 98
24111: PUSH
24112: LD_EXP 98
24116: PPUSH
24117: LD_VAR 0 2
24121: PPUSH
24122: EMPTY
24123: PPUSH
24124: CALL_OW 1
24128: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
24129: LD_ADDR_EXP 99
24133: PUSH
24134: LD_EXP 99
24138: PPUSH
24139: LD_VAR 0 2
24143: PPUSH
24144: EMPTY
24145: PPUSH
24146: CALL_OW 1
24150: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
24151: LD_ADDR_EXP 88
24155: PUSH
24156: LD_EXP 88
24160: PPUSH
24161: LD_VAR 0 2
24165: PPUSH
24166: LD_INT 0
24168: PPUSH
24169: CALL_OW 1
24173: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
24174: LD_ADDR_EXP 101
24178: PUSH
24179: LD_EXP 101
24183: PPUSH
24184: LD_VAR 0 2
24188: PPUSH
24189: LD_INT 0
24191: PPUSH
24192: CALL_OW 1
24196: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
24197: LD_ADDR_EXP 89
24201: PUSH
24202: LD_EXP 89
24206: PPUSH
24207: LD_VAR 0 2
24211: PPUSH
24212: EMPTY
24213: PPUSH
24214: CALL_OW 1
24218: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
24219: LD_ADDR_EXP 100
24223: PUSH
24224: LD_EXP 100
24228: PPUSH
24229: LD_VAR 0 2
24233: PPUSH
24234: LD_INT 0
24236: PPUSH
24237: CALL_OW 1
24241: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
24242: LD_ADDR_EXP 102
24246: PUSH
24247: LD_EXP 102
24251: PPUSH
24252: LD_VAR 0 2
24256: PPUSH
24257: EMPTY
24258: PPUSH
24259: CALL_OW 1
24263: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
24264: LD_ADDR_EXP 105
24268: PUSH
24269: LD_EXP 105
24273: PPUSH
24274: LD_VAR 0 2
24278: PPUSH
24279: LD_INT 0
24281: PPUSH
24282: CALL_OW 1
24286: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
24287: LD_ADDR_EXP 106
24291: PUSH
24292: LD_EXP 106
24296: PPUSH
24297: LD_VAR 0 2
24301: PPUSH
24302: EMPTY
24303: PPUSH
24304: CALL_OW 1
24308: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
24309: LD_ADDR_EXP 107
24313: PUSH
24314: LD_EXP 107
24318: PPUSH
24319: LD_VAR 0 2
24323: PPUSH
24324: EMPTY
24325: PPUSH
24326: CALL_OW 1
24330: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
24331: LD_ADDR_EXP 108
24335: PUSH
24336: LD_EXP 108
24340: PPUSH
24341: LD_VAR 0 2
24345: PPUSH
24346: EMPTY
24347: PPUSH
24348: CALL_OW 1
24352: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
24353: LD_ADDR_EXP 110
24357: PUSH
24358: LD_EXP 110
24362: PPUSH
24363: LD_VAR 0 2
24367: PPUSH
24368: LD_EXP 77
24372: PUSH
24373: LD_VAR 0 2
24377: ARRAY
24378: PPUSH
24379: LD_INT 2
24381: PUSH
24382: LD_INT 30
24384: PUSH
24385: LD_INT 6
24387: PUSH
24388: EMPTY
24389: LIST
24390: LIST
24391: PUSH
24392: LD_INT 30
24394: PUSH
24395: LD_INT 7
24397: PUSH
24398: EMPTY
24399: LIST
24400: LIST
24401: PUSH
24402: LD_INT 30
24404: PUSH
24405: LD_INT 8
24407: PUSH
24408: EMPTY
24409: LIST
24410: LIST
24411: PUSH
24412: EMPTY
24413: LIST
24414: LIST
24415: LIST
24416: LIST
24417: PPUSH
24418: CALL_OW 72
24422: PPUSH
24423: CALL_OW 1
24427: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
24428: LD_ADDR_EXP 111
24432: PUSH
24433: LD_EXP 111
24437: PPUSH
24438: LD_VAR 0 2
24442: PPUSH
24443: EMPTY
24444: PPUSH
24445: CALL_OW 1
24449: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
24450: LD_ADDR_EXP 112
24454: PUSH
24455: LD_EXP 112
24459: PPUSH
24460: LD_VAR 0 2
24464: PPUSH
24465: EMPTY
24466: PPUSH
24467: CALL_OW 1
24471: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
24472: LD_ADDR_EXP 113
24476: PUSH
24477: LD_EXP 113
24481: PPUSH
24482: LD_VAR 0 2
24486: PPUSH
24487: EMPTY
24488: PPUSH
24489: CALL_OW 1
24493: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
24494: LD_ADDR_EXP 114
24498: PUSH
24499: LD_EXP 114
24503: PPUSH
24504: LD_VAR 0 2
24508: PPUSH
24509: EMPTY
24510: PPUSH
24511: CALL_OW 1
24515: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
24516: LD_ADDR_EXP 115
24520: PUSH
24521: LD_EXP 115
24525: PPUSH
24526: LD_VAR 0 2
24530: PPUSH
24531: EMPTY
24532: PPUSH
24533: CALL_OW 1
24537: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
24538: LD_ADDR_EXP 116
24542: PUSH
24543: LD_EXP 116
24547: PPUSH
24548: LD_VAR 0 2
24552: PPUSH
24553: EMPTY
24554: PPUSH
24555: CALL_OW 1
24559: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
24560: LD_ADDR_EXP 117
24564: PUSH
24565: LD_EXP 117
24569: PPUSH
24570: LD_VAR 0 2
24574: PPUSH
24575: EMPTY
24576: PPUSH
24577: CALL_OW 1
24581: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
24582: LD_ADDR_EXP 118
24586: PUSH
24587: LD_EXP 118
24591: PPUSH
24592: LD_VAR 0 2
24596: PPUSH
24597: EMPTY
24598: PPUSH
24599: CALL_OW 1
24603: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
24604: LD_ADDR_EXP 119
24608: PUSH
24609: LD_EXP 119
24613: PPUSH
24614: LD_VAR 0 2
24618: PPUSH
24619: LD_INT 0
24621: PPUSH
24622: CALL_OW 1
24626: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
24627: LD_ADDR_EXP 120
24631: PUSH
24632: LD_EXP 120
24636: PPUSH
24637: LD_VAR 0 2
24641: PPUSH
24642: LD_INT 0
24644: PPUSH
24645: CALL_OW 1
24649: ST_TO_ADDR
// end ;
24650: GO 23551
24652: POP
24653: POP
// MC_InitSides ( ) ;
24654: CALL 24940 0 0
// MC_InitResearch ( ) ;
24658: CALL 24679 0 0
// CustomInitMacro ( ) ;
24662: CALL 228 0 0
// skirmish := true ;
24666: LD_ADDR_EXP 75
24670: PUSH
24671: LD_INT 1
24673: ST_TO_ADDR
// end ;
24674: LD_VAR 0 1
24678: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
24679: LD_INT 0
24681: PPUSH
24682: PPUSH
24683: PPUSH
24684: PPUSH
24685: PPUSH
24686: PPUSH
// if not mc_bases then
24687: LD_EXP 77
24691: NOT
24692: IFFALSE 24696
// exit ;
24694: GO 24935
// for i = 1 to 8 do
24696: LD_ADDR_VAR 0 2
24700: PUSH
24701: DOUBLE
24702: LD_INT 1
24704: DEC
24705: ST_TO_ADDR
24706: LD_INT 8
24708: PUSH
24709: FOR_TO
24710: IFFALSE 24736
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
24712: LD_ADDR_EXP 104
24716: PUSH
24717: LD_EXP 104
24721: PPUSH
24722: LD_VAR 0 2
24726: PPUSH
24727: EMPTY
24728: PPUSH
24729: CALL_OW 1
24733: ST_TO_ADDR
24734: GO 24709
24736: POP
24737: POP
// tmp := [ ] ;
24738: LD_ADDR_VAR 0 5
24742: PUSH
24743: EMPTY
24744: ST_TO_ADDR
// for i = 1 to mc_sides do
24745: LD_ADDR_VAR 0 2
24749: PUSH
24750: DOUBLE
24751: LD_INT 1
24753: DEC
24754: ST_TO_ADDR
24755: LD_EXP 103
24759: PUSH
24760: FOR_TO
24761: IFFALSE 24819
// if not mc_sides [ i ] in tmp then
24763: LD_EXP 103
24767: PUSH
24768: LD_VAR 0 2
24772: ARRAY
24773: PUSH
24774: LD_VAR 0 5
24778: IN
24779: NOT
24780: IFFALSE 24817
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
24782: LD_ADDR_VAR 0 5
24786: PUSH
24787: LD_VAR 0 5
24791: PPUSH
24792: LD_VAR 0 5
24796: PUSH
24797: LD_INT 1
24799: PLUS
24800: PPUSH
24801: LD_EXP 103
24805: PUSH
24806: LD_VAR 0 2
24810: ARRAY
24811: PPUSH
24812: CALL_OW 2
24816: ST_TO_ADDR
24817: GO 24760
24819: POP
24820: POP
// if not tmp then
24821: LD_VAR 0 5
24825: NOT
24826: IFFALSE 24830
// exit ;
24828: GO 24935
// for j in tmp do
24830: LD_ADDR_VAR 0 3
24834: PUSH
24835: LD_VAR 0 5
24839: PUSH
24840: FOR_IN
24841: IFFALSE 24933
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
24843: LD_ADDR_VAR 0 6
24847: PUSH
24848: LD_INT 22
24850: PUSH
24851: LD_VAR 0 3
24855: PUSH
24856: EMPTY
24857: LIST
24858: LIST
24859: PPUSH
24860: CALL_OW 69
24864: ST_TO_ADDR
// if not un then
24865: LD_VAR 0 6
24869: NOT
24870: IFFALSE 24874
// continue ;
24872: GO 24840
// nation := GetNation ( un [ 1 ] ) ;
24874: LD_ADDR_VAR 0 4
24878: PUSH
24879: LD_VAR 0 6
24883: PUSH
24884: LD_INT 1
24886: ARRAY
24887: PPUSH
24888: CALL_OW 248
24892: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
24893: LD_ADDR_EXP 104
24897: PUSH
24898: LD_EXP 104
24902: PPUSH
24903: LD_VAR 0 3
24907: PPUSH
24908: LD_VAR 0 3
24912: PPUSH
24913: LD_VAR 0 4
24917: PPUSH
24918: LD_INT 1
24920: PPUSH
24921: CALL 52125 0 3
24925: PPUSH
24926: CALL_OW 1
24930: ST_TO_ADDR
// end ;
24931: GO 24840
24933: POP
24934: POP
// end ;
24935: LD_VAR 0 1
24939: RET
// export function MC_InitSides ( ) ; var i ; begin
24940: LD_INT 0
24942: PPUSH
24943: PPUSH
// if not mc_bases then
24944: LD_EXP 77
24948: NOT
24949: IFFALSE 24953
// exit ;
24951: GO 25027
// for i = 1 to mc_bases do
24953: LD_ADDR_VAR 0 2
24957: PUSH
24958: DOUBLE
24959: LD_INT 1
24961: DEC
24962: ST_TO_ADDR
24963: LD_EXP 77
24967: PUSH
24968: FOR_TO
24969: IFFALSE 25025
// if mc_bases [ i ] then
24971: LD_EXP 77
24975: PUSH
24976: LD_VAR 0 2
24980: ARRAY
24981: IFFALSE 25023
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
24983: LD_ADDR_EXP 103
24987: PUSH
24988: LD_EXP 103
24992: PPUSH
24993: LD_VAR 0 2
24997: PPUSH
24998: LD_EXP 77
25002: PUSH
25003: LD_VAR 0 2
25007: ARRAY
25008: PUSH
25009: LD_INT 1
25011: ARRAY
25012: PPUSH
25013: CALL_OW 255
25017: PPUSH
25018: CALL_OW 1
25022: ST_TO_ADDR
25023: GO 24968
25025: POP
25026: POP
// end ;
25027: LD_VAR 0 1
25031: RET
// every 0 0$03 trigger skirmish do
25032: LD_EXP 75
25036: IFFALSE 25190
25038: GO 25040
25040: DISABLE
// begin enable ;
25041: ENABLE
// MC_CheckBuildings ( ) ;
25042: CALL 29688 0 0
// MC_CheckPeopleLife ( ) ;
25046: CALL 29849 0 0
// RaiseSailEvent ( 100 ) ;
25050: LD_INT 100
25052: PPUSH
25053: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
25057: LD_INT 103
25059: PPUSH
25060: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
25064: LD_INT 104
25066: PPUSH
25067: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
25071: LD_INT 105
25073: PPUSH
25074: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
25078: LD_INT 106
25080: PPUSH
25081: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
25085: LD_INT 107
25087: PPUSH
25088: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
25092: LD_INT 108
25094: PPUSH
25095: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
25099: LD_INT 109
25101: PPUSH
25102: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
25106: LD_INT 110
25108: PPUSH
25109: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
25113: LD_INT 111
25115: PPUSH
25116: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
25120: LD_INT 112
25122: PPUSH
25123: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
25127: LD_INT 113
25129: PPUSH
25130: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
25134: LD_INT 120
25136: PPUSH
25137: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
25141: LD_INT 121
25143: PPUSH
25144: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
25148: LD_INT 122
25150: PPUSH
25151: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
25155: LD_INT 123
25157: PPUSH
25158: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
25162: LD_INT 124
25164: PPUSH
25165: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
25169: LD_INT 125
25171: PPUSH
25172: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
25176: LD_INT 126
25178: PPUSH
25179: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
25183: LD_INT 200
25185: PPUSH
25186: CALL_OW 427
// end ;
25190: END
// on SailEvent ( event ) do begin if event < 100 then
25191: LD_VAR 0 1
25195: PUSH
25196: LD_INT 100
25198: LESS
25199: IFFALSE 25210
// CustomEvent ( event ) ;
25201: LD_VAR 0 1
25205: PPUSH
25206: CALL 11014 0 1
// if event = 100 then
25210: LD_VAR 0 1
25214: PUSH
25215: LD_INT 100
25217: EQUAL
25218: IFFALSE 25224
// MC_ClassManager ( ) ;
25220: CALL 25616 0 0
// if event = 101 then
25224: LD_VAR 0 1
25228: PUSH
25229: LD_INT 101
25231: EQUAL
25232: IFFALSE 25238
// MC_RepairBuildings ( ) ;
25234: CALL 30434 0 0
// if event = 102 then
25238: LD_VAR 0 1
25242: PUSH
25243: LD_INT 102
25245: EQUAL
25246: IFFALSE 25252
// MC_Heal ( ) ;
25248: CALL 31369 0 0
// if event = 103 then
25252: LD_VAR 0 1
25256: PUSH
25257: LD_INT 103
25259: EQUAL
25260: IFFALSE 25266
// MC_Build ( ) ;
25262: CALL 31791 0 0
// if event = 104 then
25266: LD_VAR 0 1
25270: PUSH
25271: LD_INT 104
25273: EQUAL
25274: IFFALSE 25280
// MC_TurretWeapon ( ) ;
25276: CALL 33425 0 0
// if event = 105 then
25280: LD_VAR 0 1
25284: PUSH
25285: LD_INT 105
25287: EQUAL
25288: IFFALSE 25294
// MC_BuildUpgrade ( ) ;
25290: CALL 32976 0 0
// if event = 106 then
25294: LD_VAR 0 1
25298: PUSH
25299: LD_INT 106
25301: EQUAL
25302: IFFALSE 25308
// MC_PlantMines ( ) ;
25304: CALL 33855 0 0
// if event = 107 then
25308: LD_VAR 0 1
25312: PUSH
25313: LD_INT 107
25315: EQUAL
25316: IFFALSE 25322
// MC_CollectCrates ( ) ;
25318: CALL 34646 0 0
// if event = 108 then
25322: LD_VAR 0 1
25326: PUSH
25327: LD_INT 108
25329: EQUAL
25330: IFFALSE 25336
// MC_LinkRemoteControl ( ) ;
25332: CALL 36496 0 0
// if event = 109 then
25336: LD_VAR 0 1
25340: PUSH
25341: LD_INT 109
25343: EQUAL
25344: IFFALSE 25350
// MC_ProduceVehicle ( ) ;
25346: CALL 36677 0 0
// if event = 110 then
25350: LD_VAR 0 1
25354: PUSH
25355: LD_INT 110
25357: EQUAL
25358: IFFALSE 25364
// MC_SendAttack ( ) ;
25360: CALL 37143 0 0
// if event = 111 then
25364: LD_VAR 0 1
25368: PUSH
25369: LD_INT 111
25371: EQUAL
25372: IFFALSE 25378
// MC_Defend ( ) ;
25374: CALL 37251 0 0
// if event = 112 then
25378: LD_VAR 0 1
25382: PUSH
25383: LD_INT 112
25385: EQUAL
25386: IFFALSE 25392
// MC_Research ( ) ;
25388: CALL 38131 0 0
// if event = 113 then
25392: LD_VAR 0 1
25396: PUSH
25397: LD_INT 113
25399: EQUAL
25400: IFFALSE 25406
// MC_MinesTrigger ( ) ;
25402: CALL 39245 0 0
// if event = 120 then
25406: LD_VAR 0 1
25410: PUSH
25411: LD_INT 120
25413: EQUAL
25414: IFFALSE 25420
// MC_RepairVehicle ( ) ;
25416: CALL 39344 0 0
// if event = 121 then
25420: LD_VAR 0 1
25424: PUSH
25425: LD_INT 121
25427: EQUAL
25428: IFFALSE 25434
// MC_TameApe ( ) ;
25430: CALL 40113 0 0
// if event = 122 then
25434: LD_VAR 0 1
25438: PUSH
25439: LD_INT 122
25441: EQUAL
25442: IFFALSE 25448
// MC_ChangeApeClass ( ) ;
25444: CALL 40942 0 0
// if event = 123 then
25448: LD_VAR 0 1
25452: PUSH
25453: LD_INT 123
25455: EQUAL
25456: IFFALSE 25462
// MC_Bazooka ( ) ;
25458: CALL 41592 0 0
// if event = 124 then
25462: LD_VAR 0 1
25466: PUSH
25467: LD_INT 124
25469: EQUAL
25470: IFFALSE 25476
// MC_TeleportExit ( ) ;
25472: CALL 41790 0 0
// if event = 125 then
25476: LD_VAR 0 1
25480: PUSH
25481: LD_INT 125
25483: EQUAL
25484: IFFALSE 25490
// MC_Deposits ( ) ;
25486: CALL 42437 0 0
// if event = 126 then
25490: LD_VAR 0 1
25494: PUSH
25495: LD_INT 126
25497: EQUAL
25498: IFFALSE 25504
// MC_RemoteDriver ( ) ;
25500: CALL 43062 0 0
// if event = 200 then
25504: LD_VAR 0 1
25508: PUSH
25509: LD_INT 200
25511: EQUAL
25512: IFFALSE 25518
// MC_Idle ( ) ;
25514: CALL 45011 0 0
// end ;
25518: PPOPN 1
25520: END
// export function MC_Reset ( base , tag ) ; var i ; begin
25521: LD_INT 0
25523: PPUSH
25524: PPUSH
// if not mc_bases [ base ] or not tag then
25525: LD_EXP 77
25529: PUSH
25530: LD_VAR 0 1
25534: ARRAY
25535: NOT
25536: PUSH
25537: LD_VAR 0 2
25541: NOT
25542: OR
25543: IFFALSE 25547
// exit ;
25545: GO 25611
// for i in mc_bases [ base ] union mc_ape [ base ] do
25547: LD_ADDR_VAR 0 4
25551: PUSH
25552: LD_EXP 77
25556: PUSH
25557: LD_VAR 0 1
25561: ARRAY
25562: PUSH
25563: LD_EXP 106
25567: PUSH
25568: LD_VAR 0 1
25572: ARRAY
25573: UNION
25574: PUSH
25575: FOR_IN
25576: IFFALSE 25609
// if GetTag ( i ) = tag then
25578: LD_VAR 0 4
25582: PPUSH
25583: CALL_OW 110
25587: PUSH
25588: LD_VAR 0 2
25592: EQUAL
25593: IFFALSE 25607
// SetTag ( i , 0 ) ;
25595: LD_VAR 0 4
25599: PPUSH
25600: LD_INT 0
25602: PPUSH
25603: CALL_OW 109
25607: GO 25575
25609: POP
25610: POP
// end ;
25611: LD_VAR 0 3
25615: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
25616: LD_INT 0
25618: PPUSH
25619: PPUSH
25620: PPUSH
25621: PPUSH
25622: PPUSH
25623: PPUSH
25624: PPUSH
25625: PPUSH
// if not mc_bases then
25626: LD_EXP 77
25630: NOT
25631: IFFALSE 25635
// exit ;
25633: GO 26093
// for i = 1 to mc_bases do
25635: LD_ADDR_VAR 0 2
25639: PUSH
25640: DOUBLE
25641: LD_INT 1
25643: DEC
25644: ST_TO_ADDR
25645: LD_EXP 77
25649: PUSH
25650: FOR_TO
25651: IFFALSE 26091
// begin tmp := MC_ClassCheckReq ( i ) ;
25653: LD_ADDR_VAR 0 4
25657: PUSH
25658: LD_VAR 0 2
25662: PPUSH
25663: CALL 26098 0 1
25667: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
25668: LD_ADDR_EXP 118
25672: PUSH
25673: LD_EXP 118
25677: PPUSH
25678: LD_VAR 0 2
25682: PPUSH
25683: LD_VAR 0 4
25687: PPUSH
25688: CALL_OW 1
25692: ST_TO_ADDR
// if not tmp then
25693: LD_VAR 0 4
25697: NOT
25698: IFFALSE 25702
// continue ;
25700: GO 25650
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
25702: LD_ADDR_VAR 0 6
25706: PUSH
25707: LD_EXP 77
25711: PUSH
25712: LD_VAR 0 2
25716: ARRAY
25717: PPUSH
25718: LD_INT 2
25720: PUSH
25721: LD_INT 30
25723: PUSH
25724: LD_INT 4
25726: PUSH
25727: EMPTY
25728: LIST
25729: LIST
25730: PUSH
25731: LD_INT 30
25733: PUSH
25734: LD_INT 5
25736: PUSH
25737: EMPTY
25738: LIST
25739: LIST
25740: PUSH
25741: EMPTY
25742: LIST
25743: LIST
25744: LIST
25745: PPUSH
25746: CALL_OW 72
25750: PUSH
25751: LD_EXP 77
25755: PUSH
25756: LD_VAR 0 2
25760: ARRAY
25761: PPUSH
25762: LD_INT 2
25764: PUSH
25765: LD_INT 30
25767: PUSH
25768: LD_INT 0
25770: PUSH
25771: EMPTY
25772: LIST
25773: LIST
25774: PUSH
25775: LD_INT 30
25777: PUSH
25778: LD_INT 1
25780: PUSH
25781: EMPTY
25782: LIST
25783: LIST
25784: PUSH
25785: EMPTY
25786: LIST
25787: LIST
25788: LIST
25789: PPUSH
25790: CALL_OW 72
25794: PUSH
25795: LD_EXP 77
25799: PUSH
25800: LD_VAR 0 2
25804: ARRAY
25805: PPUSH
25806: LD_INT 30
25808: PUSH
25809: LD_INT 3
25811: PUSH
25812: EMPTY
25813: LIST
25814: LIST
25815: PPUSH
25816: CALL_OW 72
25820: PUSH
25821: LD_EXP 77
25825: PUSH
25826: LD_VAR 0 2
25830: ARRAY
25831: PPUSH
25832: LD_INT 2
25834: PUSH
25835: LD_INT 30
25837: PUSH
25838: LD_INT 6
25840: PUSH
25841: EMPTY
25842: LIST
25843: LIST
25844: PUSH
25845: LD_INT 30
25847: PUSH
25848: LD_INT 7
25850: PUSH
25851: EMPTY
25852: LIST
25853: LIST
25854: PUSH
25855: LD_INT 30
25857: PUSH
25858: LD_INT 8
25860: PUSH
25861: EMPTY
25862: LIST
25863: LIST
25864: PUSH
25865: EMPTY
25866: LIST
25867: LIST
25868: LIST
25869: LIST
25870: PPUSH
25871: CALL_OW 72
25875: PUSH
25876: EMPTY
25877: LIST
25878: LIST
25879: LIST
25880: LIST
25881: ST_TO_ADDR
// for j = 1 to 4 do
25882: LD_ADDR_VAR 0 3
25886: PUSH
25887: DOUBLE
25888: LD_INT 1
25890: DEC
25891: ST_TO_ADDR
25892: LD_INT 4
25894: PUSH
25895: FOR_TO
25896: IFFALSE 26087
// begin if not tmp [ j ] then
25898: LD_VAR 0 4
25902: PUSH
25903: LD_VAR 0 3
25907: ARRAY
25908: NOT
25909: IFFALSE 25913
// continue ;
25911: GO 25895
// for p in tmp [ j ] do
25913: LD_ADDR_VAR 0 5
25917: PUSH
25918: LD_VAR 0 4
25922: PUSH
25923: LD_VAR 0 3
25927: ARRAY
25928: PUSH
25929: FOR_IN
25930: IFFALSE 26083
// begin if not b [ j ] then
25932: LD_VAR 0 6
25936: PUSH
25937: LD_VAR 0 3
25941: ARRAY
25942: NOT
25943: IFFALSE 25947
// break ;
25945: GO 26083
// e := 0 ;
25947: LD_ADDR_VAR 0 7
25951: PUSH
25952: LD_INT 0
25954: ST_TO_ADDR
// for k in b [ j ] do
25955: LD_ADDR_VAR 0 8
25959: PUSH
25960: LD_VAR 0 6
25964: PUSH
25965: LD_VAR 0 3
25969: ARRAY
25970: PUSH
25971: FOR_IN
25972: IFFALSE 25999
// if IsNotFull ( k ) then
25974: LD_VAR 0 8
25978: PPUSH
25979: CALL 54278 0 1
25983: IFFALSE 25997
// begin e := k ;
25985: LD_ADDR_VAR 0 7
25989: PUSH
25990: LD_VAR 0 8
25994: ST_TO_ADDR
// break ;
25995: GO 25999
// end ;
25997: GO 25971
25999: POP
26000: POP
// if e and not UnitGoingToBuilding ( p , e ) then
26001: LD_VAR 0 7
26005: PUSH
26006: LD_VAR 0 5
26010: PPUSH
26011: LD_VAR 0 7
26015: PPUSH
26016: CALL 88174 0 2
26020: NOT
26021: AND
26022: IFFALSE 26081
// begin if IsInUnit ( p ) then
26024: LD_VAR 0 5
26028: PPUSH
26029: CALL_OW 310
26033: IFFALSE 26044
// ComExitBuilding ( p ) ;
26035: LD_VAR 0 5
26039: PPUSH
26040: CALL_OW 122
// ComEnterUnit ( p , e ) ;
26044: LD_VAR 0 5
26048: PPUSH
26049: LD_VAR 0 7
26053: PPUSH
26054: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
26058: LD_VAR 0 5
26062: PPUSH
26063: LD_VAR 0 3
26067: PPUSH
26068: CALL_OW 183
// AddComExitBuilding ( p ) ;
26072: LD_VAR 0 5
26076: PPUSH
26077: CALL_OW 182
// end ; end ;
26081: GO 25929
26083: POP
26084: POP
// end ;
26085: GO 25895
26087: POP
26088: POP
// end ;
26089: GO 25650
26091: POP
26092: POP
// end ;
26093: LD_VAR 0 1
26097: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
26098: LD_INT 0
26100: PPUSH
26101: PPUSH
26102: PPUSH
26103: PPUSH
26104: PPUSH
26105: PPUSH
26106: PPUSH
26107: PPUSH
26108: PPUSH
26109: PPUSH
26110: PPUSH
26111: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
26112: LD_VAR 0 1
26116: NOT
26117: PUSH
26118: LD_EXP 77
26122: PUSH
26123: LD_VAR 0 1
26127: ARRAY
26128: NOT
26129: OR
26130: PUSH
26131: LD_EXP 77
26135: PUSH
26136: LD_VAR 0 1
26140: ARRAY
26141: PPUSH
26142: LD_INT 2
26144: PUSH
26145: LD_INT 30
26147: PUSH
26148: LD_INT 0
26150: PUSH
26151: EMPTY
26152: LIST
26153: LIST
26154: PUSH
26155: LD_INT 30
26157: PUSH
26158: LD_INT 1
26160: PUSH
26161: EMPTY
26162: LIST
26163: LIST
26164: PUSH
26165: EMPTY
26166: LIST
26167: LIST
26168: LIST
26169: PPUSH
26170: CALL_OW 72
26174: NOT
26175: OR
26176: IFFALSE 26180
// exit ;
26178: GO 29683
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
26180: LD_ADDR_VAR 0 4
26184: PUSH
26185: LD_EXP 77
26189: PUSH
26190: LD_VAR 0 1
26194: ARRAY
26195: PPUSH
26196: LD_INT 2
26198: PUSH
26199: LD_INT 25
26201: PUSH
26202: LD_INT 1
26204: PUSH
26205: EMPTY
26206: LIST
26207: LIST
26208: PUSH
26209: LD_INT 25
26211: PUSH
26212: LD_INT 2
26214: PUSH
26215: EMPTY
26216: LIST
26217: LIST
26218: PUSH
26219: LD_INT 25
26221: PUSH
26222: LD_INT 3
26224: PUSH
26225: EMPTY
26226: LIST
26227: LIST
26228: PUSH
26229: LD_INT 25
26231: PUSH
26232: LD_INT 4
26234: PUSH
26235: EMPTY
26236: LIST
26237: LIST
26238: PUSH
26239: LD_INT 25
26241: PUSH
26242: LD_INT 5
26244: PUSH
26245: EMPTY
26246: LIST
26247: LIST
26248: PUSH
26249: LD_INT 25
26251: PUSH
26252: LD_INT 8
26254: PUSH
26255: EMPTY
26256: LIST
26257: LIST
26258: PUSH
26259: LD_INT 25
26261: PUSH
26262: LD_INT 9
26264: PUSH
26265: EMPTY
26266: LIST
26267: LIST
26268: PUSH
26269: EMPTY
26270: LIST
26271: LIST
26272: LIST
26273: LIST
26274: LIST
26275: LIST
26276: LIST
26277: LIST
26278: PPUSH
26279: CALL_OW 72
26283: ST_TO_ADDR
// if not tmp then
26284: LD_VAR 0 4
26288: NOT
26289: IFFALSE 26293
// exit ;
26291: GO 29683
// for i in tmp do
26293: LD_ADDR_VAR 0 3
26297: PUSH
26298: LD_VAR 0 4
26302: PUSH
26303: FOR_IN
26304: IFFALSE 26335
// if GetTag ( i ) then
26306: LD_VAR 0 3
26310: PPUSH
26311: CALL_OW 110
26315: IFFALSE 26333
// tmp := tmp diff i ;
26317: LD_ADDR_VAR 0 4
26321: PUSH
26322: LD_VAR 0 4
26326: PUSH
26327: LD_VAR 0 3
26331: DIFF
26332: ST_TO_ADDR
26333: GO 26303
26335: POP
26336: POP
// if not tmp then
26337: LD_VAR 0 4
26341: NOT
26342: IFFALSE 26346
// exit ;
26344: GO 29683
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
26346: LD_ADDR_VAR 0 5
26350: PUSH
26351: LD_EXP 77
26355: PUSH
26356: LD_VAR 0 1
26360: ARRAY
26361: PPUSH
26362: LD_INT 2
26364: PUSH
26365: LD_INT 25
26367: PUSH
26368: LD_INT 1
26370: PUSH
26371: EMPTY
26372: LIST
26373: LIST
26374: PUSH
26375: LD_INT 25
26377: PUSH
26378: LD_INT 5
26380: PUSH
26381: EMPTY
26382: LIST
26383: LIST
26384: PUSH
26385: LD_INT 25
26387: PUSH
26388: LD_INT 8
26390: PUSH
26391: EMPTY
26392: LIST
26393: LIST
26394: PUSH
26395: LD_INT 25
26397: PUSH
26398: LD_INT 9
26400: PUSH
26401: EMPTY
26402: LIST
26403: LIST
26404: PUSH
26405: EMPTY
26406: LIST
26407: LIST
26408: LIST
26409: LIST
26410: LIST
26411: PPUSH
26412: CALL_OW 72
26416: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
26417: LD_ADDR_VAR 0 6
26421: PUSH
26422: LD_EXP 77
26426: PUSH
26427: LD_VAR 0 1
26431: ARRAY
26432: PPUSH
26433: LD_INT 25
26435: PUSH
26436: LD_INT 2
26438: PUSH
26439: EMPTY
26440: LIST
26441: LIST
26442: PPUSH
26443: CALL_OW 72
26447: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
26448: LD_ADDR_VAR 0 7
26452: PUSH
26453: LD_EXP 77
26457: PUSH
26458: LD_VAR 0 1
26462: ARRAY
26463: PPUSH
26464: LD_INT 25
26466: PUSH
26467: LD_INT 3
26469: PUSH
26470: EMPTY
26471: LIST
26472: LIST
26473: PPUSH
26474: CALL_OW 72
26478: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
26479: LD_ADDR_VAR 0 8
26483: PUSH
26484: LD_EXP 77
26488: PUSH
26489: LD_VAR 0 1
26493: ARRAY
26494: PPUSH
26495: LD_INT 25
26497: PUSH
26498: LD_INT 4
26500: PUSH
26501: EMPTY
26502: LIST
26503: LIST
26504: PUSH
26505: LD_INT 24
26507: PUSH
26508: LD_INT 251
26510: PUSH
26511: EMPTY
26512: LIST
26513: LIST
26514: PUSH
26515: EMPTY
26516: LIST
26517: LIST
26518: PPUSH
26519: CALL_OW 72
26523: ST_TO_ADDR
// if mc_is_defending [ base ] then
26524: LD_EXP 120
26528: PUSH
26529: LD_VAR 0 1
26533: ARRAY
26534: IFFALSE 26995
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
26536: LD_ADDR_EXP 119
26540: PUSH
26541: LD_EXP 119
26545: PPUSH
26546: LD_VAR 0 1
26550: PPUSH
26551: LD_INT 4
26553: PPUSH
26554: CALL_OW 1
26558: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
26559: LD_ADDR_VAR 0 12
26563: PUSH
26564: LD_EXP 77
26568: PUSH
26569: LD_VAR 0 1
26573: ARRAY
26574: PPUSH
26575: LD_INT 2
26577: PUSH
26578: LD_INT 30
26580: PUSH
26581: LD_INT 4
26583: PUSH
26584: EMPTY
26585: LIST
26586: LIST
26587: PUSH
26588: LD_INT 30
26590: PUSH
26591: LD_INT 5
26593: PUSH
26594: EMPTY
26595: LIST
26596: LIST
26597: PUSH
26598: EMPTY
26599: LIST
26600: LIST
26601: LIST
26602: PPUSH
26603: CALL_OW 72
26607: ST_TO_ADDR
// if not b then
26608: LD_VAR 0 12
26612: NOT
26613: IFFALSE 26617
// exit ;
26615: GO 29683
// p := [ ] ;
26617: LD_ADDR_VAR 0 11
26621: PUSH
26622: EMPTY
26623: ST_TO_ADDR
// if sci >= 2 then
26624: LD_VAR 0 8
26628: PUSH
26629: LD_INT 2
26631: GREATEREQUAL
26632: IFFALSE 26663
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
26634: LD_ADDR_VAR 0 8
26638: PUSH
26639: LD_VAR 0 8
26643: PUSH
26644: LD_INT 1
26646: ARRAY
26647: PUSH
26648: LD_VAR 0 8
26652: PUSH
26653: LD_INT 2
26655: ARRAY
26656: PUSH
26657: EMPTY
26658: LIST
26659: LIST
26660: ST_TO_ADDR
26661: GO 26724
// if sci = 1 then
26663: LD_VAR 0 8
26667: PUSH
26668: LD_INT 1
26670: EQUAL
26671: IFFALSE 26692
// sci := [ sci [ 1 ] ] else
26673: LD_ADDR_VAR 0 8
26677: PUSH
26678: LD_VAR 0 8
26682: PUSH
26683: LD_INT 1
26685: ARRAY
26686: PUSH
26687: EMPTY
26688: LIST
26689: ST_TO_ADDR
26690: GO 26724
// if sci = 0 then
26692: LD_VAR 0 8
26696: PUSH
26697: LD_INT 0
26699: EQUAL
26700: IFFALSE 26724
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
26702: LD_ADDR_VAR 0 11
26706: PUSH
26707: LD_VAR 0 4
26711: PPUSH
26712: LD_INT 4
26714: PPUSH
26715: CALL 88046 0 2
26719: PUSH
26720: LD_INT 1
26722: ARRAY
26723: ST_TO_ADDR
// if eng > 4 then
26724: LD_VAR 0 6
26728: PUSH
26729: LD_INT 4
26731: GREATER
26732: IFFALSE 26778
// for i = eng downto 4 do
26734: LD_ADDR_VAR 0 3
26738: PUSH
26739: DOUBLE
26740: LD_VAR 0 6
26744: INC
26745: ST_TO_ADDR
26746: LD_INT 4
26748: PUSH
26749: FOR_DOWNTO
26750: IFFALSE 26776
// eng := eng diff eng [ i ] ;
26752: LD_ADDR_VAR 0 6
26756: PUSH
26757: LD_VAR 0 6
26761: PUSH
26762: LD_VAR 0 6
26766: PUSH
26767: LD_VAR 0 3
26771: ARRAY
26772: DIFF
26773: ST_TO_ADDR
26774: GO 26749
26776: POP
26777: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
26778: LD_ADDR_VAR 0 4
26782: PUSH
26783: LD_VAR 0 4
26787: PUSH
26788: LD_VAR 0 5
26792: PUSH
26793: LD_VAR 0 6
26797: UNION
26798: PUSH
26799: LD_VAR 0 7
26803: UNION
26804: PUSH
26805: LD_VAR 0 8
26809: UNION
26810: DIFF
26811: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
26812: LD_ADDR_VAR 0 13
26816: PUSH
26817: LD_EXP 77
26821: PUSH
26822: LD_VAR 0 1
26826: ARRAY
26827: PPUSH
26828: LD_INT 2
26830: PUSH
26831: LD_INT 30
26833: PUSH
26834: LD_INT 32
26836: PUSH
26837: EMPTY
26838: LIST
26839: LIST
26840: PUSH
26841: LD_INT 30
26843: PUSH
26844: LD_INT 31
26846: PUSH
26847: EMPTY
26848: LIST
26849: LIST
26850: PUSH
26851: EMPTY
26852: LIST
26853: LIST
26854: LIST
26855: PPUSH
26856: CALL_OW 72
26860: PUSH
26861: LD_EXP 77
26865: PUSH
26866: LD_VAR 0 1
26870: ARRAY
26871: PPUSH
26872: LD_INT 2
26874: PUSH
26875: LD_INT 30
26877: PUSH
26878: LD_INT 4
26880: PUSH
26881: EMPTY
26882: LIST
26883: LIST
26884: PUSH
26885: LD_INT 30
26887: PUSH
26888: LD_INT 5
26890: PUSH
26891: EMPTY
26892: LIST
26893: LIST
26894: PUSH
26895: EMPTY
26896: LIST
26897: LIST
26898: LIST
26899: PPUSH
26900: CALL_OW 72
26904: PUSH
26905: LD_INT 6
26907: MUL
26908: PLUS
26909: ST_TO_ADDR
// if bcount < tmp then
26910: LD_VAR 0 13
26914: PUSH
26915: LD_VAR 0 4
26919: LESS
26920: IFFALSE 26966
// for i = tmp downto bcount do
26922: LD_ADDR_VAR 0 3
26926: PUSH
26927: DOUBLE
26928: LD_VAR 0 4
26932: INC
26933: ST_TO_ADDR
26934: LD_VAR 0 13
26938: PUSH
26939: FOR_DOWNTO
26940: IFFALSE 26964
// tmp := Delete ( tmp , tmp ) ;
26942: LD_ADDR_VAR 0 4
26946: PUSH
26947: LD_VAR 0 4
26951: PPUSH
26952: LD_VAR 0 4
26956: PPUSH
26957: CALL_OW 3
26961: ST_TO_ADDR
26962: GO 26939
26964: POP
26965: POP
// result := [ tmp , 0 , 0 , p ] ;
26966: LD_ADDR_VAR 0 2
26970: PUSH
26971: LD_VAR 0 4
26975: PUSH
26976: LD_INT 0
26978: PUSH
26979: LD_INT 0
26981: PUSH
26982: LD_VAR 0 11
26986: PUSH
26987: EMPTY
26988: LIST
26989: LIST
26990: LIST
26991: LIST
26992: ST_TO_ADDR
// exit ;
26993: GO 29683
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26995: LD_EXP 77
26999: PUSH
27000: LD_VAR 0 1
27004: ARRAY
27005: PPUSH
27006: LD_INT 2
27008: PUSH
27009: LD_INT 30
27011: PUSH
27012: LD_INT 6
27014: PUSH
27015: EMPTY
27016: LIST
27017: LIST
27018: PUSH
27019: LD_INT 30
27021: PUSH
27022: LD_INT 7
27024: PUSH
27025: EMPTY
27026: LIST
27027: LIST
27028: PUSH
27029: LD_INT 30
27031: PUSH
27032: LD_INT 8
27034: PUSH
27035: EMPTY
27036: LIST
27037: LIST
27038: PUSH
27039: EMPTY
27040: LIST
27041: LIST
27042: LIST
27043: LIST
27044: PPUSH
27045: CALL_OW 72
27049: NOT
27050: PUSH
27051: LD_EXP 77
27055: PUSH
27056: LD_VAR 0 1
27060: ARRAY
27061: PPUSH
27062: LD_INT 30
27064: PUSH
27065: LD_INT 3
27067: PUSH
27068: EMPTY
27069: LIST
27070: LIST
27071: PPUSH
27072: CALL_OW 72
27076: NOT
27077: AND
27078: IFFALSE 27150
// begin if eng = tmp then
27080: LD_VAR 0 6
27084: PUSH
27085: LD_VAR 0 4
27089: EQUAL
27090: IFFALSE 27094
// exit ;
27092: GO 29683
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
27094: LD_ADDR_EXP 119
27098: PUSH
27099: LD_EXP 119
27103: PPUSH
27104: LD_VAR 0 1
27108: PPUSH
27109: LD_INT 1
27111: PPUSH
27112: CALL_OW 1
27116: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
27117: LD_ADDR_VAR 0 2
27121: PUSH
27122: LD_INT 0
27124: PUSH
27125: LD_VAR 0 4
27129: PUSH
27130: LD_VAR 0 6
27134: DIFF
27135: PUSH
27136: LD_INT 0
27138: PUSH
27139: LD_INT 0
27141: PUSH
27142: EMPTY
27143: LIST
27144: LIST
27145: LIST
27146: LIST
27147: ST_TO_ADDR
// exit ;
27148: GO 29683
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
27150: LD_EXP 104
27154: PUSH
27155: LD_EXP 103
27159: PUSH
27160: LD_VAR 0 1
27164: ARRAY
27165: ARRAY
27166: PUSH
27167: LD_EXP 77
27171: PUSH
27172: LD_VAR 0 1
27176: ARRAY
27177: PPUSH
27178: LD_INT 2
27180: PUSH
27181: LD_INT 30
27183: PUSH
27184: LD_INT 6
27186: PUSH
27187: EMPTY
27188: LIST
27189: LIST
27190: PUSH
27191: LD_INT 30
27193: PUSH
27194: LD_INT 7
27196: PUSH
27197: EMPTY
27198: LIST
27199: LIST
27200: PUSH
27201: LD_INT 30
27203: PUSH
27204: LD_INT 8
27206: PUSH
27207: EMPTY
27208: LIST
27209: LIST
27210: PUSH
27211: EMPTY
27212: LIST
27213: LIST
27214: LIST
27215: LIST
27216: PPUSH
27217: CALL_OW 72
27221: AND
27222: PUSH
27223: LD_EXP 77
27227: PUSH
27228: LD_VAR 0 1
27232: ARRAY
27233: PPUSH
27234: LD_INT 30
27236: PUSH
27237: LD_INT 3
27239: PUSH
27240: EMPTY
27241: LIST
27242: LIST
27243: PPUSH
27244: CALL_OW 72
27248: NOT
27249: AND
27250: IFFALSE 27464
// begin if sci >= 6 then
27252: LD_VAR 0 8
27256: PUSH
27257: LD_INT 6
27259: GREATEREQUAL
27260: IFFALSE 27264
// exit ;
27262: GO 29683
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
27264: LD_ADDR_EXP 119
27268: PUSH
27269: LD_EXP 119
27273: PPUSH
27274: LD_VAR 0 1
27278: PPUSH
27279: LD_INT 2
27281: PPUSH
27282: CALL_OW 1
27286: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
27287: LD_ADDR_VAR 0 9
27291: PUSH
27292: LD_VAR 0 4
27296: PUSH
27297: LD_VAR 0 8
27301: DIFF
27302: PPUSH
27303: LD_INT 4
27305: PPUSH
27306: CALL 88046 0 2
27310: ST_TO_ADDR
// p := [ ] ;
27311: LD_ADDR_VAR 0 11
27315: PUSH
27316: EMPTY
27317: ST_TO_ADDR
// if sci < 6 and sort > 6 then
27318: LD_VAR 0 8
27322: PUSH
27323: LD_INT 6
27325: LESS
27326: PUSH
27327: LD_VAR 0 9
27331: PUSH
27332: LD_INT 6
27334: GREATER
27335: AND
27336: IFFALSE 27417
// begin for i = 1 to 6 - sci do
27338: LD_ADDR_VAR 0 3
27342: PUSH
27343: DOUBLE
27344: LD_INT 1
27346: DEC
27347: ST_TO_ADDR
27348: LD_INT 6
27350: PUSH
27351: LD_VAR 0 8
27355: MINUS
27356: PUSH
27357: FOR_TO
27358: IFFALSE 27413
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
27360: LD_ADDR_VAR 0 11
27364: PUSH
27365: LD_VAR 0 11
27369: PPUSH
27370: LD_VAR 0 11
27374: PUSH
27375: LD_INT 1
27377: PLUS
27378: PPUSH
27379: LD_VAR 0 9
27383: PUSH
27384: LD_INT 1
27386: ARRAY
27387: PPUSH
27388: CALL_OW 2
27392: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
27393: LD_ADDR_VAR 0 9
27397: PUSH
27398: LD_VAR 0 9
27402: PPUSH
27403: LD_INT 1
27405: PPUSH
27406: CALL_OW 3
27410: ST_TO_ADDR
// end ;
27411: GO 27357
27413: POP
27414: POP
// end else
27415: GO 27437
// if sort then
27417: LD_VAR 0 9
27421: IFFALSE 27437
// p := sort [ 1 ] ;
27423: LD_ADDR_VAR 0 11
27427: PUSH
27428: LD_VAR 0 9
27432: PUSH
27433: LD_INT 1
27435: ARRAY
27436: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
27437: LD_ADDR_VAR 0 2
27441: PUSH
27442: LD_INT 0
27444: PUSH
27445: LD_INT 0
27447: PUSH
27448: LD_INT 0
27450: PUSH
27451: LD_VAR 0 11
27455: PUSH
27456: EMPTY
27457: LIST
27458: LIST
27459: LIST
27460: LIST
27461: ST_TO_ADDR
// exit ;
27462: GO 29683
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
27464: LD_EXP 104
27468: PUSH
27469: LD_EXP 103
27473: PUSH
27474: LD_VAR 0 1
27478: ARRAY
27479: ARRAY
27480: PUSH
27481: LD_EXP 77
27485: PUSH
27486: LD_VAR 0 1
27490: ARRAY
27491: PPUSH
27492: LD_INT 2
27494: PUSH
27495: LD_INT 30
27497: PUSH
27498: LD_INT 6
27500: PUSH
27501: EMPTY
27502: LIST
27503: LIST
27504: PUSH
27505: LD_INT 30
27507: PUSH
27508: LD_INT 7
27510: PUSH
27511: EMPTY
27512: LIST
27513: LIST
27514: PUSH
27515: LD_INT 30
27517: PUSH
27518: LD_INT 8
27520: PUSH
27521: EMPTY
27522: LIST
27523: LIST
27524: PUSH
27525: EMPTY
27526: LIST
27527: LIST
27528: LIST
27529: LIST
27530: PPUSH
27531: CALL_OW 72
27535: AND
27536: PUSH
27537: LD_EXP 77
27541: PUSH
27542: LD_VAR 0 1
27546: ARRAY
27547: PPUSH
27548: LD_INT 30
27550: PUSH
27551: LD_INT 3
27553: PUSH
27554: EMPTY
27555: LIST
27556: LIST
27557: PPUSH
27558: CALL_OW 72
27562: AND
27563: IFFALSE 28297
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
27565: LD_ADDR_EXP 119
27569: PUSH
27570: LD_EXP 119
27574: PPUSH
27575: LD_VAR 0 1
27579: PPUSH
27580: LD_INT 3
27582: PPUSH
27583: CALL_OW 1
27587: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27588: LD_ADDR_VAR 0 2
27592: PUSH
27593: LD_INT 0
27595: PUSH
27596: LD_INT 0
27598: PUSH
27599: LD_INT 0
27601: PUSH
27602: LD_INT 0
27604: PUSH
27605: EMPTY
27606: LIST
27607: LIST
27608: LIST
27609: LIST
27610: ST_TO_ADDR
// if not eng then
27611: LD_VAR 0 6
27615: NOT
27616: IFFALSE 27679
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
27618: LD_ADDR_VAR 0 11
27622: PUSH
27623: LD_VAR 0 4
27627: PPUSH
27628: LD_INT 2
27630: PPUSH
27631: CALL 88046 0 2
27635: PUSH
27636: LD_INT 1
27638: ARRAY
27639: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
27640: LD_ADDR_VAR 0 2
27644: PUSH
27645: LD_VAR 0 2
27649: PPUSH
27650: LD_INT 2
27652: PPUSH
27653: LD_VAR 0 11
27657: PPUSH
27658: CALL_OW 1
27662: ST_TO_ADDR
// tmp := tmp diff p ;
27663: LD_ADDR_VAR 0 4
27667: PUSH
27668: LD_VAR 0 4
27672: PUSH
27673: LD_VAR 0 11
27677: DIFF
27678: ST_TO_ADDR
// end ; if tmp and sci < 6 then
27679: LD_VAR 0 4
27683: PUSH
27684: LD_VAR 0 8
27688: PUSH
27689: LD_INT 6
27691: LESS
27692: AND
27693: IFFALSE 27881
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
27695: LD_ADDR_VAR 0 9
27699: PUSH
27700: LD_VAR 0 4
27704: PUSH
27705: LD_VAR 0 8
27709: PUSH
27710: LD_VAR 0 7
27714: UNION
27715: DIFF
27716: PPUSH
27717: LD_INT 4
27719: PPUSH
27720: CALL 88046 0 2
27724: ST_TO_ADDR
// p := [ ] ;
27725: LD_ADDR_VAR 0 11
27729: PUSH
27730: EMPTY
27731: ST_TO_ADDR
// if sort then
27732: LD_VAR 0 9
27736: IFFALSE 27852
// for i = 1 to 6 - sci do
27738: LD_ADDR_VAR 0 3
27742: PUSH
27743: DOUBLE
27744: LD_INT 1
27746: DEC
27747: ST_TO_ADDR
27748: LD_INT 6
27750: PUSH
27751: LD_VAR 0 8
27755: MINUS
27756: PUSH
27757: FOR_TO
27758: IFFALSE 27850
// begin if i = sort then
27760: LD_VAR 0 3
27764: PUSH
27765: LD_VAR 0 9
27769: EQUAL
27770: IFFALSE 27774
// break ;
27772: GO 27850
// if GetClass ( i ) = 4 then
27774: LD_VAR 0 3
27778: PPUSH
27779: CALL_OW 257
27783: PUSH
27784: LD_INT 4
27786: EQUAL
27787: IFFALSE 27791
// continue ;
27789: GO 27757
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27791: LD_ADDR_VAR 0 11
27795: PUSH
27796: LD_VAR 0 11
27800: PPUSH
27801: LD_VAR 0 11
27805: PUSH
27806: LD_INT 1
27808: PLUS
27809: PPUSH
27810: LD_VAR 0 9
27814: PUSH
27815: LD_VAR 0 3
27819: ARRAY
27820: PPUSH
27821: CALL_OW 2
27825: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27826: LD_ADDR_VAR 0 4
27830: PUSH
27831: LD_VAR 0 4
27835: PUSH
27836: LD_VAR 0 9
27840: PUSH
27841: LD_VAR 0 3
27845: ARRAY
27846: DIFF
27847: ST_TO_ADDR
// end ;
27848: GO 27757
27850: POP
27851: POP
// if p then
27852: LD_VAR 0 11
27856: IFFALSE 27881
// result := Replace ( result , 4 , p ) ;
27858: LD_ADDR_VAR 0 2
27862: PUSH
27863: LD_VAR 0 2
27867: PPUSH
27868: LD_INT 4
27870: PPUSH
27871: LD_VAR 0 11
27875: PPUSH
27876: CALL_OW 1
27880: ST_TO_ADDR
// end ; if tmp and mech < 6 then
27881: LD_VAR 0 4
27885: PUSH
27886: LD_VAR 0 7
27890: PUSH
27891: LD_INT 6
27893: LESS
27894: AND
27895: IFFALSE 28083
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27897: LD_ADDR_VAR 0 9
27901: PUSH
27902: LD_VAR 0 4
27906: PUSH
27907: LD_VAR 0 8
27911: PUSH
27912: LD_VAR 0 7
27916: UNION
27917: DIFF
27918: PPUSH
27919: LD_INT 3
27921: PPUSH
27922: CALL 88046 0 2
27926: ST_TO_ADDR
// p := [ ] ;
27927: LD_ADDR_VAR 0 11
27931: PUSH
27932: EMPTY
27933: ST_TO_ADDR
// if sort then
27934: LD_VAR 0 9
27938: IFFALSE 28054
// for i = 1 to 6 - mech do
27940: LD_ADDR_VAR 0 3
27944: PUSH
27945: DOUBLE
27946: LD_INT 1
27948: DEC
27949: ST_TO_ADDR
27950: LD_INT 6
27952: PUSH
27953: LD_VAR 0 7
27957: MINUS
27958: PUSH
27959: FOR_TO
27960: IFFALSE 28052
// begin if i = sort then
27962: LD_VAR 0 3
27966: PUSH
27967: LD_VAR 0 9
27971: EQUAL
27972: IFFALSE 27976
// break ;
27974: GO 28052
// if GetClass ( i ) = 3 then
27976: LD_VAR 0 3
27980: PPUSH
27981: CALL_OW 257
27985: PUSH
27986: LD_INT 3
27988: EQUAL
27989: IFFALSE 27993
// continue ;
27991: GO 27959
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27993: LD_ADDR_VAR 0 11
27997: PUSH
27998: LD_VAR 0 11
28002: PPUSH
28003: LD_VAR 0 11
28007: PUSH
28008: LD_INT 1
28010: PLUS
28011: PPUSH
28012: LD_VAR 0 9
28016: PUSH
28017: LD_VAR 0 3
28021: ARRAY
28022: PPUSH
28023: CALL_OW 2
28027: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28028: LD_ADDR_VAR 0 4
28032: PUSH
28033: LD_VAR 0 4
28037: PUSH
28038: LD_VAR 0 9
28042: PUSH
28043: LD_VAR 0 3
28047: ARRAY
28048: DIFF
28049: ST_TO_ADDR
// end ;
28050: GO 27959
28052: POP
28053: POP
// if p then
28054: LD_VAR 0 11
28058: IFFALSE 28083
// result := Replace ( result , 3 , p ) ;
28060: LD_ADDR_VAR 0 2
28064: PUSH
28065: LD_VAR 0 2
28069: PPUSH
28070: LD_INT 3
28072: PPUSH
28073: LD_VAR 0 11
28077: PPUSH
28078: CALL_OW 1
28082: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
28083: LD_VAR 0 4
28087: PUSH
28088: LD_INT 6
28090: GREATER
28091: PUSH
28092: LD_VAR 0 6
28096: PUSH
28097: LD_INT 6
28099: LESS
28100: AND
28101: IFFALSE 28295
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
28103: LD_ADDR_VAR 0 9
28107: PUSH
28108: LD_VAR 0 4
28112: PUSH
28113: LD_VAR 0 8
28117: PUSH
28118: LD_VAR 0 7
28122: UNION
28123: PUSH
28124: LD_VAR 0 6
28128: UNION
28129: DIFF
28130: PPUSH
28131: LD_INT 2
28133: PPUSH
28134: CALL 88046 0 2
28138: ST_TO_ADDR
// p := [ ] ;
28139: LD_ADDR_VAR 0 11
28143: PUSH
28144: EMPTY
28145: ST_TO_ADDR
// if sort then
28146: LD_VAR 0 9
28150: IFFALSE 28266
// for i = 1 to 6 - eng do
28152: LD_ADDR_VAR 0 3
28156: PUSH
28157: DOUBLE
28158: LD_INT 1
28160: DEC
28161: ST_TO_ADDR
28162: LD_INT 6
28164: PUSH
28165: LD_VAR 0 6
28169: MINUS
28170: PUSH
28171: FOR_TO
28172: IFFALSE 28264
// begin if i = sort then
28174: LD_VAR 0 3
28178: PUSH
28179: LD_VAR 0 9
28183: EQUAL
28184: IFFALSE 28188
// break ;
28186: GO 28264
// if GetClass ( i ) = 2 then
28188: LD_VAR 0 3
28192: PPUSH
28193: CALL_OW 257
28197: PUSH
28198: LD_INT 2
28200: EQUAL
28201: IFFALSE 28205
// continue ;
28203: GO 28171
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28205: LD_ADDR_VAR 0 11
28209: PUSH
28210: LD_VAR 0 11
28214: PPUSH
28215: LD_VAR 0 11
28219: PUSH
28220: LD_INT 1
28222: PLUS
28223: PPUSH
28224: LD_VAR 0 9
28228: PUSH
28229: LD_VAR 0 3
28233: ARRAY
28234: PPUSH
28235: CALL_OW 2
28239: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28240: LD_ADDR_VAR 0 4
28244: PUSH
28245: LD_VAR 0 4
28249: PUSH
28250: LD_VAR 0 9
28254: PUSH
28255: LD_VAR 0 3
28259: ARRAY
28260: DIFF
28261: ST_TO_ADDR
// end ;
28262: GO 28171
28264: POP
28265: POP
// if p then
28266: LD_VAR 0 11
28270: IFFALSE 28295
// result := Replace ( result , 2 , p ) ;
28272: LD_ADDR_VAR 0 2
28276: PUSH
28277: LD_VAR 0 2
28281: PPUSH
28282: LD_INT 2
28284: PPUSH
28285: LD_VAR 0 11
28289: PPUSH
28290: CALL_OW 1
28294: ST_TO_ADDR
// end ; exit ;
28295: GO 29683
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
28297: LD_EXP 104
28301: PUSH
28302: LD_EXP 103
28306: PUSH
28307: LD_VAR 0 1
28311: ARRAY
28312: ARRAY
28313: NOT
28314: PUSH
28315: LD_EXP 77
28319: PUSH
28320: LD_VAR 0 1
28324: ARRAY
28325: PPUSH
28326: LD_INT 30
28328: PUSH
28329: LD_INT 3
28331: PUSH
28332: EMPTY
28333: LIST
28334: LIST
28335: PPUSH
28336: CALL_OW 72
28340: AND
28341: PUSH
28342: LD_EXP 82
28346: PUSH
28347: LD_VAR 0 1
28351: ARRAY
28352: AND
28353: IFFALSE 28961
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
28355: LD_ADDR_EXP 119
28359: PUSH
28360: LD_EXP 119
28364: PPUSH
28365: LD_VAR 0 1
28369: PPUSH
28370: LD_INT 5
28372: PPUSH
28373: CALL_OW 1
28377: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
28378: LD_ADDR_VAR 0 2
28382: PUSH
28383: LD_INT 0
28385: PUSH
28386: LD_INT 0
28388: PUSH
28389: LD_INT 0
28391: PUSH
28392: LD_INT 0
28394: PUSH
28395: EMPTY
28396: LIST
28397: LIST
28398: LIST
28399: LIST
28400: ST_TO_ADDR
// if sci > 1 then
28401: LD_VAR 0 8
28405: PUSH
28406: LD_INT 1
28408: GREATER
28409: IFFALSE 28437
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
28411: LD_ADDR_VAR 0 4
28415: PUSH
28416: LD_VAR 0 4
28420: PUSH
28421: LD_VAR 0 8
28425: PUSH
28426: LD_VAR 0 8
28430: PUSH
28431: LD_INT 1
28433: ARRAY
28434: DIFF
28435: DIFF
28436: ST_TO_ADDR
// if tmp and not sci then
28437: LD_VAR 0 4
28441: PUSH
28442: LD_VAR 0 8
28446: NOT
28447: AND
28448: IFFALSE 28517
// begin sort := SortBySkill ( tmp , 4 ) ;
28450: LD_ADDR_VAR 0 9
28454: PUSH
28455: LD_VAR 0 4
28459: PPUSH
28460: LD_INT 4
28462: PPUSH
28463: CALL 88046 0 2
28467: ST_TO_ADDR
// if sort then
28468: LD_VAR 0 9
28472: IFFALSE 28488
// p := sort [ 1 ] ;
28474: LD_ADDR_VAR 0 11
28478: PUSH
28479: LD_VAR 0 9
28483: PUSH
28484: LD_INT 1
28486: ARRAY
28487: ST_TO_ADDR
// if p then
28488: LD_VAR 0 11
28492: IFFALSE 28517
// result := Replace ( result , 4 , p ) ;
28494: LD_ADDR_VAR 0 2
28498: PUSH
28499: LD_VAR 0 2
28503: PPUSH
28504: LD_INT 4
28506: PPUSH
28507: LD_VAR 0 11
28511: PPUSH
28512: CALL_OW 1
28516: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
28517: LD_ADDR_VAR 0 4
28521: PUSH
28522: LD_VAR 0 4
28526: PUSH
28527: LD_VAR 0 7
28531: DIFF
28532: ST_TO_ADDR
// if tmp and mech < 6 then
28533: LD_VAR 0 4
28537: PUSH
28538: LD_VAR 0 7
28542: PUSH
28543: LD_INT 6
28545: LESS
28546: AND
28547: IFFALSE 28735
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
28549: LD_ADDR_VAR 0 9
28553: PUSH
28554: LD_VAR 0 4
28558: PUSH
28559: LD_VAR 0 8
28563: PUSH
28564: LD_VAR 0 7
28568: UNION
28569: DIFF
28570: PPUSH
28571: LD_INT 3
28573: PPUSH
28574: CALL 88046 0 2
28578: ST_TO_ADDR
// p := [ ] ;
28579: LD_ADDR_VAR 0 11
28583: PUSH
28584: EMPTY
28585: ST_TO_ADDR
// if sort then
28586: LD_VAR 0 9
28590: IFFALSE 28706
// for i = 1 to 6 - mech do
28592: LD_ADDR_VAR 0 3
28596: PUSH
28597: DOUBLE
28598: LD_INT 1
28600: DEC
28601: ST_TO_ADDR
28602: LD_INT 6
28604: PUSH
28605: LD_VAR 0 7
28609: MINUS
28610: PUSH
28611: FOR_TO
28612: IFFALSE 28704
// begin if i = sort then
28614: LD_VAR 0 3
28618: PUSH
28619: LD_VAR 0 9
28623: EQUAL
28624: IFFALSE 28628
// break ;
28626: GO 28704
// if GetClass ( i ) = 3 then
28628: LD_VAR 0 3
28632: PPUSH
28633: CALL_OW 257
28637: PUSH
28638: LD_INT 3
28640: EQUAL
28641: IFFALSE 28645
// continue ;
28643: GO 28611
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28645: LD_ADDR_VAR 0 11
28649: PUSH
28650: LD_VAR 0 11
28654: PPUSH
28655: LD_VAR 0 11
28659: PUSH
28660: LD_INT 1
28662: PLUS
28663: PPUSH
28664: LD_VAR 0 9
28668: PUSH
28669: LD_VAR 0 3
28673: ARRAY
28674: PPUSH
28675: CALL_OW 2
28679: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28680: LD_ADDR_VAR 0 4
28684: PUSH
28685: LD_VAR 0 4
28689: PUSH
28690: LD_VAR 0 9
28694: PUSH
28695: LD_VAR 0 3
28699: ARRAY
28700: DIFF
28701: ST_TO_ADDR
// end ;
28702: GO 28611
28704: POP
28705: POP
// if p then
28706: LD_VAR 0 11
28710: IFFALSE 28735
// result := Replace ( result , 3 , p ) ;
28712: LD_ADDR_VAR 0 2
28716: PUSH
28717: LD_VAR 0 2
28721: PPUSH
28722: LD_INT 3
28724: PPUSH
28725: LD_VAR 0 11
28729: PPUSH
28730: CALL_OW 1
28734: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28735: LD_ADDR_VAR 0 4
28739: PUSH
28740: LD_VAR 0 4
28744: PUSH
28745: LD_VAR 0 6
28749: DIFF
28750: ST_TO_ADDR
// if tmp and eng < 6 then
28751: LD_VAR 0 4
28755: PUSH
28756: LD_VAR 0 6
28760: PUSH
28761: LD_INT 6
28763: LESS
28764: AND
28765: IFFALSE 28959
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
28767: LD_ADDR_VAR 0 9
28771: PUSH
28772: LD_VAR 0 4
28776: PUSH
28777: LD_VAR 0 8
28781: PUSH
28782: LD_VAR 0 7
28786: UNION
28787: PUSH
28788: LD_VAR 0 6
28792: UNION
28793: DIFF
28794: PPUSH
28795: LD_INT 2
28797: PPUSH
28798: CALL 88046 0 2
28802: ST_TO_ADDR
// p := [ ] ;
28803: LD_ADDR_VAR 0 11
28807: PUSH
28808: EMPTY
28809: ST_TO_ADDR
// if sort then
28810: LD_VAR 0 9
28814: IFFALSE 28930
// for i = 1 to 6 - eng do
28816: LD_ADDR_VAR 0 3
28820: PUSH
28821: DOUBLE
28822: LD_INT 1
28824: DEC
28825: ST_TO_ADDR
28826: LD_INT 6
28828: PUSH
28829: LD_VAR 0 6
28833: MINUS
28834: PUSH
28835: FOR_TO
28836: IFFALSE 28928
// begin if i = sort then
28838: LD_VAR 0 3
28842: PUSH
28843: LD_VAR 0 9
28847: EQUAL
28848: IFFALSE 28852
// break ;
28850: GO 28928
// if GetClass ( i ) = 2 then
28852: LD_VAR 0 3
28856: PPUSH
28857: CALL_OW 257
28861: PUSH
28862: LD_INT 2
28864: EQUAL
28865: IFFALSE 28869
// continue ;
28867: GO 28835
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28869: LD_ADDR_VAR 0 11
28873: PUSH
28874: LD_VAR 0 11
28878: PPUSH
28879: LD_VAR 0 11
28883: PUSH
28884: LD_INT 1
28886: PLUS
28887: PPUSH
28888: LD_VAR 0 9
28892: PUSH
28893: LD_VAR 0 3
28897: ARRAY
28898: PPUSH
28899: CALL_OW 2
28903: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28904: LD_ADDR_VAR 0 4
28908: PUSH
28909: LD_VAR 0 4
28913: PUSH
28914: LD_VAR 0 9
28918: PUSH
28919: LD_VAR 0 3
28923: ARRAY
28924: DIFF
28925: ST_TO_ADDR
// end ;
28926: GO 28835
28928: POP
28929: POP
// if p then
28930: LD_VAR 0 11
28934: IFFALSE 28959
// result := Replace ( result , 2 , p ) ;
28936: LD_ADDR_VAR 0 2
28940: PUSH
28941: LD_VAR 0 2
28945: PPUSH
28946: LD_INT 2
28948: PPUSH
28949: LD_VAR 0 11
28953: PPUSH
28954: CALL_OW 1
28958: ST_TO_ADDR
// end ; exit ;
28959: GO 29683
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
28961: LD_EXP 104
28965: PUSH
28966: LD_EXP 103
28970: PUSH
28971: LD_VAR 0 1
28975: ARRAY
28976: ARRAY
28977: NOT
28978: PUSH
28979: LD_EXP 77
28983: PUSH
28984: LD_VAR 0 1
28988: ARRAY
28989: PPUSH
28990: LD_INT 30
28992: PUSH
28993: LD_INT 3
28995: PUSH
28996: EMPTY
28997: LIST
28998: LIST
28999: PPUSH
29000: CALL_OW 72
29004: AND
29005: PUSH
29006: LD_EXP 82
29010: PUSH
29011: LD_VAR 0 1
29015: ARRAY
29016: NOT
29017: AND
29018: IFFALSE 29683
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
29020: LD_ADDR_EXP 119
29024: PUSH
29025: LD_EXP 119
29029: PPUSH
29030: LD_VAR 0 1
29034: PPUSH
29035: LD_INT 6
29037: PPUSH
29038: CALL_OW 1
29042: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
29043: LD_ADDR_VAR 0 2
29047: PUSH
29048: LD_INT 0
29050: PUSH
29051: LD_INT 0
29053: PUSH
29054: LD_INT 0
29056: PUSH
29057: LD_INT 0
29059: PUSH
29060: EMPTY
29061: LIST
29062: LIST
29063: LIST
29064: LIST
29065: ST_TO_ADDR
// if sci >= 1 then
29066: LD_VAR 0 8
29070: PUSH
29071: LD_INT 1
29073: GREATEREQUAL
29074: IFFALSE 29096
// tmp := tmp diff sci [ 1 ] ;
29076: LD_ADDR_VAR 0 4
29080: PUSH
29081: LD_VAR 0 4
29085: PUSH
29086: LD_VAR 0 8
29090: PUSH
29091: LD_INT 1
29093: ARRAY
29094: DIFF
29095: ST_TO_ADDR
// if tmp and not sci then
29096: LD_VAR 0 4
29100: PUSH
29101: LD_VAR 0 8
29105: NOT
29106: AND
29107: IFFALSE 29176
// begin sort := SortBySkill ( tmp , 4 ) ;
29109: LD_ADDR_VAR 0 9
29113: PUSH
29114: LD_VAR 0 4
29118: PPUSH
29119: LD_INT 4
29121: PPUSH
29122: CALL 88046 0 2
29126: ST_TO_ADDR
// if sort then
29127: LD_VAR 0 9
29131: IFFALSE 29147
// p := sort [ 1 ] ;
29133: LD_ADDR_VAR 0 11
29137: PUSH
29138: LD_VAR 0 9
29142: PUSH
29143: LD_INT 1
29145: ARRAY
29146: ST_TO_ADDR
// if p then
29147: LD_VAR 0 11
29151: IFFALSE 29176
// result := Replace ( result , 4 , p ) ;
29153: LD_ADDR_VAR 0 2
29157: PUSH
29158: LD_VAR 0 2
29162: PPUSH
29163: LD_INT 4
29165: PPUSH
29166: LD_VAR 0 11
29170: PPUSH
29171: CALL_OW 1
29175: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
29176: LD_ADDR_VAR 0 4
29180: PUSH
29181: LD_VAR 0 4
29185: PUSH
29186: LD_VAR 0 7
29190: DIFF
29191: ST_TO_ADDR
// if tmp and mech < 6 then
29192: LD_VAR 0 4
29196: PUSH
29197: LD_VAR 0 7
29201: PUSH
29202: LD_INT 6
29204: LESS
29205: AND
29206: IFFALSE 29388
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
29208: LD_ADDR_VAR 0 9
29212: PUSH
29213: LD_VAR 0 4
29217: PUSH
29218: LD_VAR 0 7
29222: DIFF
29223: PPUSH
29224: LD_INT 3
29226: PPUSH
29227: CALL 88046 0 2
29231: ST_TO_ADDR
// p := [ ] ;
29232: LD_ADDR_VAR 0 11
29236: PUSH
29237: EMPTY
29238: ST_TO_ADDR
// if sort then
29239: LD_VAR 0 9
29243: IFFALSE 29359
// for i = 1 to 6 - mech do
29245: LD_ADDR_VAR 0 3
29249: PUSH
29250: DOUBLE
29251: LD_INT 1
29253: DEC
29254: ST_TO_ADDR
29255: LD_INT 6
29257: PUSH
29258: LD_VAR 0 7
29262: MINUS
29263: PUSH
29264: FOR_TO
29265: IFFALSE 29357
// begin if i = sort then
29267: LD_VAR 0 3
29271: PUSH
29272: LD_VAR 0 9
29276: EQUAL
29277: IFFALSE 29281
// break ;
29279: GO 29357
// if GetClass ( i ) = 3 then
29281: LD_VAR 0 3
29285: PPUSH
29286: CALL_OW 257
29290: PUSH
29291: LD_INT 3
29293: EQUAL
29294: IFFALSE 29298
// continue ;
29296: GO 29264
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29298: LD_ADDR_VAR 0 11
29302: PUSH
29303: LD_VAR 0 11
29307: PPUSH
29308: LD_VAR 0 11
29312: PUSH
29313: LD_INT 1
29315: PLUS
29316: PPUSH
29317: LD_VAR 0 9
29321: PUSH
29322: LD_VAR 0 3
29326: ARRAY
29327: PPUSH
29328: CALL_OW 2
29332: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29333: LD_ADDR_VAR 0 4
29337: PUSH
29338: LD_VAR 0 4
29342: PUSH
29343: LD_VAR 0 9
29347: PUSH
29348: LD_VAR 0 3
29352: ARRAY
29353: DIFF
29354: ST_TO_ADDR
// end ;
29355: GO 29264
29357: POP
29358: POP
// if p then
29359: LD_VAR 0 11
29363: IFFALSE 29388
// result := Replace ( result , 3 , p ) ;
29365: LD_ADDR_VAR 0 2
29369: PUSH
29370: LD_VAR 0 2
29374: PPUSH
29375: LD_INT 3
29377: PPUSH
29378: LD_VAR 0 11
29382: PPUSH
29383: CALL_OW 1
29387: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
29388: LD_ADDR_VAR 0 4
29392: PUSH
29393: LD_VAR 0 4
29397: PUSH
29398: LD_VAR 0 6
29402: DIFF
29403: ST_TO_ADDR
// if tmp and eng < 4 then
29404: LD_VAR 0 4
29408: PUSH
29409: LD_VAR 0 6
29413: PUSH
29414: LD_INT 4
29416: LESS
29417: AND
29418: IFFALSE 29608
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
29420: LD_ADDR_VAR 0 9
29424: PUSH
29425: LD_VAR 0 4
29429: PUSH
29430: LD_VAR 0 7
29434: PUSH
29435: LD_VAR 0 6
29439: UNION
29440: DIFF
29441: PPUSH
29442: LD_INT 2
29444: PPUSH
29445: CALL 88046 0 2
29449: ST_TO_ADDR
// p := [ ] ;
29450: LD_ADDR_VAR 0 11
29454: PUSH
29455: EMPTY
29456: ST_TO_ADDR
// if sort then
29457: LD_VAR 0 9
29461: IFFALSE 29577
// for i = 1 to 4 - eng do
29463: LD_ADDR_VAR 0 3
29467: PUSH
29468: DOUBLE
29469: LD_INT 1
29471: DEC
29472: ST_TO_ADDR
29473: LD_INT 4
29475: PUSH
29476: LD_VAR 0 6
29480: MINUS
29481: PUSH
29482: FOR_TO
29483: IFFALSE 29575
// begin if i = sort then
29485: LD_VAR 0 3
29489: PUSH
29490: LD_VAR 0 9
29494: EQUAL
29495: IFFALSE 29499
// break ;
29497: GO 29575
// if GetClass ( i ) = 2 then
29499: LD_VAR 0 3
29503: PPUSH
29504: CALL_OW 257
29508: PUSH
29509: LD_INT 2
29511: EQUAL
29512: IFFALSE 29516
// continue ;
29514: GO 29482
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29516: LD_ADDR_VAR 0 11
29520: PUSH
29521: LD_VAR 0 11
29525: PPUSH
29526: LD_VAR 0 11
29530: PUSH
29531: LD_INT 1
29533: PLUS
29534: PPUSH
29535: LD_VAR 0 9
29539: PUSH
29540: LD_VAR 0 3
29544: ARRAY
29545: PPUSH
29546: CALL_OW 2
29550: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29551: LD_ADDR_VAR 0 4
29555: PUSH
29556: LD_VAR 0 4
29560: PUSH
29561: LD_VAR 0 9
29565: PUSH
29566: LD_VAR 0 3
29570: ARRAY
29571: DIFF
29572: ST_TO_ADDR
// end ;
29573: GO 29482
29575: POP
29576: POP
// if p then
29577: LD_VAR 0 11
29581: IFFALSE 29606
// result := Replace ( result , 2 , p ) ;
29583: LD_ADDR_VAR 0 2
29587: PUSH
29588: LD_VAR 0 2
29592: PPUSH
29593: LD_INT 2
29595: PPUSH
29596: LD_VAR 0 11
29600: PPUSH
29601: CALL_OW 1
29605: ST_TO_ADDR
// end else
29606: GO 29652
// for i = eng downto 5 do
29608: LD_ADDR_VAR 0 3
29612: PUSH
29613: DOUBLE
29614: LD_VAR 0 6
29618: INC
29619: ST_TO_ADDR
29620: LD_INT 5
29622: PUSH
29623: FOR_DOWNTO
29624: IFFALSE 29650
// tmp := tmp union eng [ i ] ;
29626: LD_ADDR_VAR 0 4
29630: PUSH
29631: LD_VAR 0 4
29635: PUSH
29636: LD_VAR 0 6
29640: PUSH
29641: LD_VAR 0 3
29645: ARRAY
29646: UNION
29647: ST_TO_ADDR
29648: GO 29623
29650: POP
29651: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
29652: LD_ADDR_VAR 0 2
29656: PUSH
29657: LD_VAR 0 2
29661: PPUSH
29662: LD_INT 1
29664: PPUSH
29665: LD_VAR 0 4
29669: PUSH
29670: LD_VAR 0 5
29674: DIFF
29675: PPUSH
29676: CALL_OW 1
29680: ST_TO_ADDR
// exit ;
29681: GO 29683
// end ; end ;
29683: LD_VAR 0 2
29687: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
29688: LD_INT 0
29690: PPUSH
29691: PPUSH
29692: PPUSH
// if not mc_bases then
29693: LD_EXP 77
29697: NOT
29698: IFFALSE 29702
// exit ;
29700: GO 29844
// for i = 1 to mc_bases do
29702: LD_ADDR_VAR 0 2
29706: PUSH
29707: DOUBLE
29708: LD_INT 1
29710: DEC
29711: ST_TO_ADDR
29712: LD_EXP 77
29716: PUSH
29717: FOR_TO
29718: IFFALSE 29835
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
29720: LD_ADDR_VAR 0 3
29724: PUSH
29725: LD_EXP 77
29729: PUSH
29730: LD_VAR 0 2
29734: ARRAY
29735: PPUSH
29736: LD_INT 21
29738: PUSH
29739: LD_INT 3
29741: PUSH
29742: EMPTY
29743: LIST
29744: LIST
29745: PUSH
29746: LD_INT 3
29748: PUSH
29749: LD_INT 2
29751: PUSH
29752: LD_INT 30
29754: PUSH
29755: LD_INT 29
29757: PUSH
29758: EMPTY
29759: LIST
29760: LIST
29761: PUSH
29762: LD_INT 30
29764: PUSH
29765: LD_INT 30
29767: PUSH
29768: EMPTY
29769: LIST
29770: LIST
29771: PUSH
29772: EMPTY
29773: LIST
29774: LIST
29775: LIST
29776: PUSH
29777: EMPTY
29778: LIST
29779: LIST
29780: PUSH
29781: LD_INT 3
29783: PUSH
29784: LD_INT 24
29786: PUSH
29787: LD_INT 1000
29789: PUSH
29790: EMPTY
29791: LIST
29792: LIST
29793: PUSH
29794: EMPTY
29795: LIST
29796: LIST
29797: PUSH
29798: EMPTY
29799: LIST
29800: LIST
29801: LIST
29802: PPUSH
29803: CALL_OW 72
29807: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
29808: LD_ADDR_EXP 78
29812: PUSH
29813: LD_EXP 78
29817: PPUSH
29818: LD_VAR 0 2
29822: PPUSH
29823: LD_VAR 0 3
29827: PPUSH
29828: CALL_OW 1
29832: ST_TO_ADDR
// end ;
29833: GO 29717
29835: POP
29836: POP
// RaiseSailEvent ( 101 ) ;
29837: LD_INT 101
29839: PPUSH
29840: CALL_OW 427
// end ;
29844: LD_VAR 0 1
29848: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
29849: LD_INT 0
29851: PPUSH
29852: PPUSH
29853: PPUSH
29854: PPUSH
29855: PPUSH
29856: PPUSH
29857: PPUSH
// if not mc_bases then
29858: LD_EXP 77
29862: NOT
29863: IFFALSE 29867
// exit ;
29865: GO 30429
// for i = 1 to mc_bases do
29867: LD_ADDR_VAR 0 2
29871: PUSH
29872: DOUBLE
29873: LD_INT 1
29875: DEC
29876: ST_TO_ADDR
29877: LD_EXP 77
29881: PUSH
29882: FOR_TO
29883: IFFALSE 30420
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
29885: LD_ADDR_VAR 0 5
29889: PUSH
29890: LD_EXP 77
29894: PUSH
29895: LD_VAR 0 2
29899: ARRAY
29900: PUSH
29901: LD_EXP 106
29905: PUSH
29906: LD_VAR 0 2
29910: ARRAY
29911: UNION
29912: PPUSH
29913: LD_INT 21
29915: PUSH
29916: LD_INT 1
29918: PUSH
29919: EMPTY
29920: LIST
29921: LIST
29922: PUSH
29923: LD_INT 1
29925: PUSH
29926: LD_INT 3
29928: PUSH
29929: LD_INT 54
29931: PUSH
29932: EMPTY
29933: LIST
29934: PUSH
29935: EMPTY
29936: LIST
29937: LIST
29938: PUSH
29939: LD_INT 3
29941: PUSH
29942: LD_INT 24
29944: PUSH
29945: LD_INT 1000
29947: PUSH
29948: EMPTY
29949: LIST
29950: LIST
29951: PUSH
29952: EMPTY
29953: LIST
29954: LIST
29955: PUSH
29956: EMPTY
29957: LIST
29958: LIST
29959: LIST
29960: PUSH
29961: EMPTY
29962: LIST
29963: LIST
29964: PPUSH
29965: CALL_OW 72
29969: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
29970: LD_ADDR_VAR 0 6
29974: PUSH
29975: LD_EXP 77
29979: PUSH
29980: LD_VAR 0 2
29984: ARRAY
29985: PPUSH
29986: LD_INT 21
29988: PUSH
29989: LD_INT 1
29991: PUSH
29992: EMPTY
29993: LIST
29994: LIST
29995: PUSH
29996: LD_INT 1
29998: PUSH
29999: LD_INT 3
30001: PUSH
30002: LD_INT 54
30004: PUSH
30005: EMPTY
30006: LIST
30007: PUSH
30008: EMPTY
30009: LIST
30010: LIST
30011: PUSH
30012: LD_INT 3
30014: PUSH
30015: LD_INT 24
30017: PUSH
30018: LD_INT 250
30020: PUSH
30021: EMPTY
30022: LIST
30023: LIST
30024: PUSH
30025: EMPTY
30026: LIST
30027: LIST
30028: PUSH
30029: EMPTY
30030: LIST
30031: LIST
30032: LIST
30033: PUSH
30034: EMPTY
30035: LIST
30036: LIST
30037: PPUSH
30038: CALL_OW 72
30042: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
30043: LD_ADDR_VAR 0 7
30047: PUSH
30048: LD_VAR 0 5
30052: PUSH
30053: LD_VAR 0 6
30057: DIFF
30058: ST_TO_ADDR
// if not need_heal_1 then
30059: LD_VAR 0 6
30063: NOT
30064: IFFALSE 30097
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
30066: LD_ADDR_EXP 80
30070: PUSH
30071: LD_EXP 80
30075: PPUSH
30076: LD_VAR 0 2
30080: PUSH
30081: LD_INT 1
30083: PUSH
30084: EMPTY
30085: LIST
30086: LIST
30087: PPUSH
30088: EMPTY
30089: PPUSH
30090: CALL 57199 0 3
30094: ST_TO_ADDR
30095: GO 30167
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
30097: LD_ADDR_EXP 80
30101: PUSH
30102: LD_EXP 80
30106: PPUSH
30107: LD_VAR 0 2
30111: PUSH
30112: LD_INT 1
30114: PUSH
30115: EMPTY
30116: LIST
30117: LIST
30118: PPUSH
30119: LD_EXP 80
30123: PUSH
30124: LD_VAR 0 2
30128: ARRAY
30129: PUSH
30130: LD_INT 1
30132: ARRAY
30133: PPUSH
30134: LD_INT 3
30136: PUSH
30137: LD_INT 24
30139: PUSH
30140: LD_INT 1000
30142: PUSH
30143: EMPTY
30144: LIST
30145: LIST
30146: PUSH
30147: EMPTY
30148: LIST
30149: LIST
30150: PPUSH
30151: CALL_OW 72
30155: PUSH
30156: LD_VAR 0 6
30160: UNION
30161: PPUSH
30162: CALL 57199 0 3
30166: ST_TO_ADDR
// if not need_heal_2 then
30167: LD_VAR 0 7
30171: NOT
30172: IFFALSE 30205
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
30174: LD_ADDR_EXP 80
30178: PUSH
30179: LD_EXP 80
30183: PPUSH
30184: LD_VAR 0 2
30188: PUSH
30189: LD_INT 2
30191: PUSH
30192: EMPTY
30193: LIST
30194: LIST
30195: PPUSH
30196: EMPTY
30197: PPUSH
30198: CALL 57199 0 3
30202: ST_TO_ADDR
30203: GO 30237
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
30205: LD_ADDR_EXP 80
30209: PUSH
30210: LD_EXP 80
30214: PPUSH
30215: LD_VAR 0 2
30219: PUSH
30220: LD_INT 2
30222: PUSH
30223: EMPTY
30224: LIST
30225: LIST
30226: PPUSH
30227: LD_VAR 0 7
30231: PPUSH
30232: CALL 57199 0 3
30236: ST_TO_ADDR
// if need_heal_2 then
30237: LD_VAR 0 7
30241: IFFALSE 30402
// for j in need_heal_2 do
30243: LD_ADDR_VAR 0 3
30247: PUSH
30248: LD_VAR 0 7
30252: PUSH
30253: FOR_IN
30254: IFFALSE 30400
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
30256: LD_ADDR_VAR 0 5
30260: PUSH
30261: LD_EXP 77
30265: PUSH
30266: LD_VAR 0 2
30270: ARRAY
30271: PPUSH
30272: LD_INT 2
30274: PUSH
30275: LD_INT 30
30277: PUSH
30278: LD_INT 6
30280: PUSH
30281: EMPTY
30282: LIST
30283: LIST
30284: PUSH
30285: LD_INT 30
30287: PUSH
30288: LD_INT 7
30290: PUSH
30291: EMPTY
30292: LIST
30293: LIST
30294: PUSH
30295: LD_INT 30
30297: PUSH
30298: LD_INT 8
30300: PUSH
30301: EMPTY
30302: LIST
30303: LIST
30304: PUSH
30305: LD_INT 30
30307: PUSH
30308: LD_INT 0
30310: PUSH
30311: EMPTY
30312: LIST
30313: LIST
30314: PUSH
30315: LD_INT 30
30317: PUSH
30318: LD_INT 1
30320: PUSH
30321: EMPTY
30322: LIST
30323: LIST
30324: PUSH
30325: EMPTY
30326: LIST
30327: LIST
30328: LIST
30329: LIST
30330: LIST
30331: LIST
30332: PPUSH
30333: CALL_OW 72
30337: ST_TO_ADDR
// if tmp then
30338: LD_VAR 0 5
30342: IFFALSE 30398
// begin k := NearestUnitToUnit ( tmp , j ) ;
30344: LD_ADDR_VAR 0 4
30348: PUSH
30349: LD_VAR 0 5
30353: PPUSH
30354: LD_VAR 0 3
30358: PPUSH
30359: CALL_OW 74
30363: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
30364: LD_VAR 0 3
30368: PPUSH
30369: LD_VAR 0 4
30373: PPUSH
30374: CALL_OW 296
30378: PUSH
30379: LD_INT 5
30381: GREATER
30382: IFFALSE 30398
// ComMoveToNearbyEntrance ( j , k ) ;
30384: LD_VAR 0 3
30388: PPUSH
30389: LD_VAR 0 4
30393: PPUSH
30394: CALL 90407 0 2
// end ; end ;
30398: GO 30253
30400: POP
30401: POP
// if not need_heal_1 and not need_heal_2 then
30402: LD_VAR 0 6
30406: NOT
30407: PUSH
30408: LD_VAR 0 7
30412: NOT
30413: AND
30414: IFFALSE 30418
// continue ;
30416: GO 29882
// end ;
30418: GO 29882
30420: POP
30421: POP
// RaiseSailEvent ( 102 ) ;
30422: LD_INT 102
30424: PPUSH
30425: CALL_OW 427
// end ;
30429: LD_VAR 0 1
30433: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
30434: LD_INT 0
30436: PPUSH
30437: PPUSH
30438: PPUSH
30439: PPUSH
30440: PPUSH
30441: PPUSH
30442: PPUSH
30443: PPUSH
// if not mc_bases then
30444: LD_EXP 77
30448: NOT
30449: IFFALSE 30453
// exit ;
30451: GO 31364
// for i = 1 to mc_bases do
30453: LD_ADDR_VAR 0 2
30457: PUSH
30458: DOUBLE
30459: LD_INT 1
30461: DEC
30462: ST_TO_ADDR
30463: LD_EXP 77
30467: PUSH
30468: FOR_TO
30469: IFFALSE 31362
// begin if not mc_building_need_repair [ i ] then
30471: LD_EXP 78
30475: PUSH
30476: LD_VAR 0 2
30480: ARRAY
30481: NOT
30482: IFFALSE 30667
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
30484: LD_ADDR_VAR 0 6
30488: PUSH
30489: LD_EXP 96
30493: PUSH
30494: LD_VAR 0 2
30498: ARRAY
30499: PPUSH
30500: LD_INT 3
30502: PUSH
30503: LD_INT 24
30505: PUSH
30506: LD_INT 1000
30508: PUSH
30509: EMPTY
30510: LIST
30511: LIST
30512: PUSH
30513: EMPTY
30514: LIST
30515: LIST
30516: PUSH
30517: LD_INT 2
30519: PUSH
30520: LD_INT 34
30522: PUSH
30523: LD_INT 13
30525: PUSH
30526: EMPTY
30527: LIST
30528: LIST
30529: PUSH
30530: LD_INT 34
30532: PUSH
30533: LD_INT 52
30535: PUSH
30536: EMPTY
30537: LIST
30538: LIST
30539: PUSH
30540: LD_INT 34
30542: PUSH
30543: LD_INT 88
30545: PUSH
30546: EMPTY
30547: LIST
30548: LIST
30549: PUSH
30550: EMPTY
30551: LIST
30552: LIST
30553: LIST
30554: LIST
30555: PUSH
30556: EMPTY
30557: LIST
30558: LIST
30559: PPUSH
30560: CALL_OW 72
30564: ST_TO_ADDR
// if cranes then
30565: LD_VAR 0 6
30569: IFFALSE 30631
// for j in cranes do
30571: LD_ADDR_VAR 0 3
30575: PUSH
30576: LD_VAR 0 6
30580: PUSH
30581: FOR_IN
30582: IFFALSE 30629
// if not IsInArea ( j , mc_parking [ i ] ) then
30584: LD_VAR 0 3
30588: PPUSH
30589: LD_EXP 101
30593: PUSH
30594: LD_VAR 0 2
30598: ARRAY
30599: PPUSH
30600: CALL_OW 308
30604: NOT
30605: IFFALSE 30627
// ComMoveToArea ( j , mc_parking [ i ] ) ;
30607: LD_VAR 0 3
30611: PPUSH
30612: LD_EXP 101
30616: PUSH
30617: LD_VAR 0 2
30621: ARRAY
30622: PPUSH
30623: CALL_OW 113
30627: GO 30581
30629: POP
30630: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
30631: LD_ADDR_EXP 79
30635: PUSH
30636: LD_EXP 79
30640: PPUSH
30641: LD_VAR 0 2
30645: PPUSH
30646: EMPTY
30647: PPUSH
30648: CALL_OW 1
30652: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
30653: LD_VAR 0 2
30657: PPUSH
30658: LD_INT 101
30660: PPUSH
30661: CALL 25521 0 2
// continue ;
30665: GO 30468
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
30667: LD_ADDR_EXP 83
30671: PUSH
30672: LD_EXP 83
30676: PPUSH
30677: LD_VAR 0 2
30681: PPUSH
30682: EMPTY
30683: PPUSH
30684: CALL_OW 1
30688: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
30689: LD_VAR 0 2
30693: PPUSH
30694: LD_INT 103
30696: PPUSH
30697: CALL 25521 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
30701: LD_ADDR_VAR 0 5
30705: PUSH
30706: LD_EXP 77
30710: PUSH
30711: LD_VAR 0 2
30715: ARRAY
30716: PUSH
30717: LD_EXP 106
30721: PUSH
30722: LD_VAR 0 2
30726: ARRAY
30727: UNION
30728: PPUSH
30729: LD_INT 2
30731: PUSH
30732: LD_INT 25
30734: PUSH
30735: LD_INT 2
30737: PUSH
30738: EMPTY
30739: LIST
30740: LIST
30741: PUSH
30742: LD_INT 25
30744: PUSH
30745: LD_INT 16
30747: PUSH
30748: EMPTY
30749: LIST
30750: LIST
30751: PUSH
30752: EMPTY
30753: LIST
30754: LIST
30755: LIST
30756: PUSH
30757: EMPTY
30758: LIST
30759: PPUSH
30760: CALL_OW 72
30764: ST_TO_ADDR
// if mc_need_heal [ i ] then
30765: LD_EXP 80
30769: PUSH
30770: LD_VAR 0 2
30774: ARRAY
30775: IFFALSE 30819
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
30777: LD_ADDR_VAR 0 5
30781: PUSH
30782: LD_VAR 0 5
30786: PUSH
30787: LD_EXP 80
30791: PUSH
30792: LD_VAR 0 2
30796: ARRAY
30797: PUSH
30798: LD_INT 1
30800: ARRAY
30801: PUSH
30802: LD_EXP 80
30806: PUSH
30807: LD_VAR 0 2
30811: ARRAY
30812: PUSH
30813: LD_INT 2
30815: ARRAY
30816: UNION
30817: DIFF
30818: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
30819: LD_ADDR_VAR 0 6
30823: PUSH
30824: LD_EXP 96
30828: PUSH
30829: LD_VAR 0 2
30833: ARRAY
30834: PPUSH
30835: LD_INT 2
30837: PUSH
30838: LD_INT 34
30840: PUSH
30841: LD_INT 13
30843: PUSH
30844: EMPTY
30845: LIST
30846: LIST
30847: PUSH
30848: LD_INT 34
30850: PUSH
30851: LD_INT 52
30853: PUSH
30854: EMPTY
30855: LIST
30856: LIST
30857: PUSH
30858: LD_INT 34
30860: PUSH
30861: LD_INT 88
30863: PUSH
30864: EMPTY
30865: LIST
30866: LIST
30867: PUSH
30868: EMPTY
30869: LIST
30870: LIST
30871: LIST
30872: LIST
30873: PPUSH
30874: CALL_OW 72
30878: ST_TO_ADDR
// if cranes then
30879: LD_VAR 0 6
30883: IFFALSE 31051
// begin for j in cranes do
30885: LD_ADDR_VAR 0 3
30889: PUSH
30890: LD_VAR 0 6
30894: PUSH
30895: FOR_IN
30896: IFFALSE 31049
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
30898: LD_VAR 0 3
30902: PPUSH
30903: CALL_OW 256
30907: PUSH
30908: LD_INT 1000
30910: EQUAL
30911: PUSH
30912: LD_VAR 0 3
30916: PPUSH
30917: CALL_OW 314
30921: NOT
30922: AND
30923: IFFALSE 30989
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
30925: LD_ADDR_VAR 0 8
30929: PUSH
30930: LD_EXP 78
30934: PUSH
30935: LD_VAR 0 2
30939: ARRAY
30940: PPUSH
30941: LD_VAR 0 3
30945: PPUSH
30946: CALL_OW 74
30950: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
30951: LD_VAR 0 8
30955: PPUSH
30956: LD_INT 16
30958: PPUSH
30959: CALL 59796 0 2
30963: PUSH
30964: LD_INT 4
30966: ARRAY
30967: PUSH
30968: LD_INT 10
30970: LESS
30971: IFFALSE 30987
// ComRepairBuilding ( j , to_repair ) ;
30973: LD_VAR 0 3
30977: PPUSH
30978: LD_VAR 0 8
30982: PPUSH
30983: CALL_OW 130
// end else
30987: GO 31047
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
30989: LD_VAR 0 3
30993: PPUSH
30994: CALL_OW 256
30998: PUSH
30999: LD_INT 500
31001: LESS
31002: PUSH
31003: LD_VAR 0 3
31007: PPUSH
31008: LD_EXP 101
31012: PUSH
31013: LD_VAR 0 2
31017: ARRAY
31018: PPUSH
31019: CALL_OW 308
31023: NOT
31024: AND
31025: IFFALSE 31047
// ComMoveToArea ( j , mc_parking [ i ] ) ;
31027: LD_VAR 0 3
31031: PPUSH
31032: LD_EXP 101
31036: PUSH
31037: LD_VAR 0 2
31041: ARRAY
31042: PPUSH
31043: CALL_OW 113
// end ;
31047: GO 30895
31049: POP
31050: POP
// end ; if tmp > 3 then
31051: LD_VAR 0 5
31055: PUSH
31056: LD_INT 3
31058: GREATER
31059: IFFALSE 31079
// tmp := ShrinkArray ( tmp , 4 ) ;
31061: LD_ADDR_VAR 0 5
31065: PUSH
31066: LD_VAR 0 5
31070: PPUSH
31071: LD_INT 4
31073: PPUSH
31074: CALL 89845 0 2
31078: ST_TO_ADDR
// if not tmp then
31079: LD_VAR 0 5
31083: NOT
31084: IFFALSE 31088
// continue ;
31086: GO 30468
// for j in tmp do
31088: LD_ADDR_VAR 0 3
31092: PUSH
31093: LD_VAR 0 5
31097: PUSH
31098: FOR_IN
31099: IFFALSE 31358
// begin if IsInUnit ( j ) then
31101: LD_VAR 0 3
31105: PPUSH
31106: CALL_OW 310
31110: IFFALSE 31121
// ComExitBuilding ( j ) ;
31112: LD_VAR 0 3
31116: PPUSH
31117: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
31121: LD_VAR 0 3
31125: PUSH
31126: LD_EXP 79
31130: PUSH
31131: LD_VAR 0 2
31135: ARRAY
31136: IN
31137: NOT
31138: IFFALSE 31196
// begin SetTag ( j , 101 ) ;
31140: LD_VAR 0 3
31144: PPUSH
31145: LD_INT 101
31147: PPUSH
31148: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
31152: LD_ADDR_EXP 79
31156: PUSH
31157: LD_EXP 79
31161: PPUSH
31162: LD_VAR 0 2
31166: PUSH
31167: LD_EXP 79
31171: PUSH
31172: LD_VAR 0 2
31176: ARRAY
31177: PUSH
31178: LD_INT 1
31180: PLUS
31181: PUSH
31182: EMPTY
31183: LIST
31184: LIST
31185: PPUSH
31186: LD_VAR 0 3
31190: PPUSH
31191: CALL 57199 0 3
31195: ST_TO_ADDR
// end ; wait ( 1 ) ;
31196: LD_INT 1
31198: PPUSH
31199: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
31203: LD_ADDR_VAR 0 7
31207: PUSH
31208: LD_EXP 78
31212: PUSH
31213: LD_VAR 0 2
31217: ARRAY
31218: ST_TO_ADDR
// if mc_scan [ i ] then
31219: LD_EXP 100
31223: PUSH
31224: LD_VAR 0 2
31228: ARRAY
31229: IFFALSE 31291
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
31231: LD_ADDR_VAR 0 7
31235: PUSH
31236: LD_EXP 78
31240: PUSH
31241: LD_VAR 0 2
31245: ARRAY
31246: PPUSH
31247: LD_INT 3
31249: PUSH
31250: LD_INT 30
31252: PUSH
31253: LD_INT 32
31255: PUSH
31256: EMPTY
31257: LIST
31258: LIST
31259: PUSH
31260: LD_INT 30
31262: PUSH
31263: LD_INT 33
31265: PUSH
31266: EMPTY
31267: LIST
31268: LIST
31269: PUSH
31270: LD_INT 30
31272: PUSH
31273: LD_INT 31
31275: PUSH
31276: EMPTY
31277: LIST
31278: LIST
31279: PUSH
31280: EMPTY
31281: LIST
31282: LIST
31283: LIST
31284: LIST
31285: PPUSH
31286: CALL_OW 72
31290: ST_TO_ADDR
// if not to_repair_tmp then
31291: LD_VAR 0 7
31295: NOT
31296: IFFALSE 31300
// continue ;
31298: GO 31098
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
31300: LD_ADDR_VAR 0 8
31304: PUSH
31305: LD_VAR 0 7
31309: PPUSH
31310: LD_VAR 0 3
31314: PPUSH
31315: CALL_OW 74
31319: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
31320: LD_VAR 0 8
31324: PPUSH
31325: LD_INT 16
31327: PPUSH
31328: CALL 59796 0 2
31332: PUSH
31333: LD_INT 4
31335: ARRAY
31336: PUSH
31337: LD_INT 14
31339: LESS
31340: IFFALSE 31356
// ComRepairBuilding ( j , to_repair ) ;
31342: LD_VAR 0 3
31346: PPUSH
31347: LD_VAR 0 8
31351: PPUSH
31352: CALL_OW 130
// end ;
31356: GO 31098
31358: POP
31359: POP
// end ;
31360: GO 30468
31362: POP
31363: POP
// end ;
31364: LD_VAR 0 1
31368: RET
// export function MC_Heal ; var i , j , tmp ; begin
31369: LD_INT 0
31371: PPUSH
31372: PPUSH
31373: PPUSH
31374: PPUSH
// if not mc_bases then
31375: LD_EXP 77
31379: NOT
31380: IFFALSE 31384
// exit ;
31382: GO 31786
// for i = 1 to mc_bases do
31384: LD_ADDR_VAR 0 2
31388: PUSH
31389: DOUBLE
31390: LD_INT 1
31392: DEC
31393: ST_TO_ADDR
31394: LD_EXP 77
31398: PUSH
31399: FOR_TO
31400: IFFALSE 31784
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
31402: LD_EXP 80
31406: PUSH
31407: LD_VAR 0 2
31411: ARRAY
31412: PUSH
31413: LD_INT 1
31415: ARRAY
31416: NOT
31417: PUSH
31418: LD_EXP 80
31422: PUSH
31423: LD_VAR 0 2
31427: ARRAY
31428: PUSH
31429: LD_INT 2
31431: ARRAY
31432: NOT
31433: AND
31434: IFFALSE 31472
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
31436: LD_ADDR_EXP 81
31440: PUSH
31441: LD_EXP 81
31445: PPUSH
31446: LD_VAR 0 2
31450: PPUSH
31451: EMPTY
31452: PPUSH
31453: CALL_OW 1
31457: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
31458: LD_VAR 0 2
31462: PPUSH
31463: LD_INT 102
31465: PPUSH
31466: CALL 25521 0 2
// continue ;
31470: GO 31399
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
31472: LD_ADDR_VAR 0 4
31476: PUSH
31477: LD_EXP 77
31481: PUSH
31482: LD_VAR 0 2
31486: ARRAY
31487: PPUSH
31488: LD_INT 25
31490: PUSH
31491: LD_INT 4
31493: PUSH
31494: EMPTY
31495: LIST
31496: LIST
31497: PPUSH
31498: CALL_OW 72
31502: ST_TO_ADDR
// if not tmp then
31503: LD_VAR 0 4
31507: NOT
31508: IFFALSE 31512
// continue ;
31510: GO 31399
// if mc_taming [ i ] then
31512: LD_EXP 108
31516: PUSH
31517: LD_VAR 0 2
31521: ARRAY
31522: IFFALSE 31546
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
31524: LD_ADDR_EXP 108
31528: PUSH
31529: LD_EXP 108
31533: PPUSH
31534: LD_VAR 0 2
31538: PPUSH
31539: EMPTY
31540: PPUSH
31541: CALL_OW 1
31545: ST_TO_ADDR
// for j in tmp do
31546: LD_ADDR_VAR 0 3
31550: PUSH
31551: LD_VAR 0 4
31555: PUSH
31556: FOR_IN
31557: IFFALSE 31780
// begin if IsInUnit ( j ) then
31559: LD_VAR 0 3
31563: PPUSH
31564: CALL_OW 310
31568: IFFALSE 31579
// ComExitBuilding ( j ) ;
31570: LD_VAR 0 3
31574: PPUSH
31575: CALL_OW 122
// if not j in mc_healers [ i ] then
31579: LD_VAR 0 3
31583: PUSH
31584: LD_EXP 81
31588: PUSH
31589: LD_VAR 0 2
31593: ARRAY
31594: IN
31595: NOT
31596: IFFALSE 31642
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
31598: LD_ADDR_EXP 81
31602: PUSH
31603: LD_EXP 81
31607: PPUSH
31608: LD_VAR 0 2
31612: PUSH
31613: LD_EXP 81
31617: PUSH
31618: LD_VAR 0 2
31622: ARRAY
31623: PUSH
31624: LD_INT 1
31626: PLUS
31627: PUSH
31628: EMPTY
31629: LIST
31630: LIST
31631: PPUSH
31632: LD_VAR 0 3
31636: PPUSH
31637: CALL 57199 0 3
31641: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
31642: LD_VAR 0 3
31646: PPUSH
31647: CALL_OW 110
31651: PUSH
31652: LD_INT 102
31654: NONEQUAL
31655: IFFALSE 31669
// SetTag ( j , 102 ) ;
31657: LD_VAR 0 3
31661: PPUSH
31662: LD_INT 102
31664: PPUSH
31665: CALL_OW 109
// Wait ( 3 ) ;
31669: LD_INT 3
31671: PPUSH
31672: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
31676: LD_EXP 80
31680: PUSH
31681: LD_VAR 0 2
31685: ARRAY
31686: PUSH
31687: LD_INT 1
31689: ARRAY
31690: IFFALSE 31722
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
31692: LD_VAR 0 3
31696: PPUSH
31697: LD_EXP 80
31701: PUSH
31702: LD_VAR 0 2
31706: ARRAY
31707: PUSH
31708: LD_INT 1
31710: ARRAY
31711: PUSH
31712: LD_INT 1
31714: ARRAY
31715: PPUSH
31716: CALL_OW 128
31720: GO 31778
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
31722: LD_VAR 0 3
31726: PPUSH
31727: CALL_OW 314
31731: NOT
31732: PUSH
31733: LD_EXP 80
31737: PUSH
31738: LD_VAR 0 2
31742: ARRAY
31743: PUSH
31744: LD_INT 2
31746: ARRAY
31747: AND
31748: IFFALSE 31778
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
31750: LD_VAR 0 3
31754: PPUSH
31755: LD_EXP 80
31759: PUSH
31760: LD_VAR 0 2
31764: ARRAY
31765: PUSH
31766: LD_INT 2
31768: ARRAY
31769: PUSH
31770: LD_INT 1
31772: ARRAY
31773: PPUSH
31774: CALL_OW 128
// end ;
31778: GO 31556
31780: POP
31781: POP
// end ;
31782: GO 31399
31784: POP
31785: POP
// end ;
31786: LD_VAR 0 1
31790: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
31791: LD_INT 0
31793: PPUSH
31794: PPUSH
31795: PPUSH
31796: PPUSH
31797: PPUSH
31798: PPUSH
// if not mc_bases then
31799: LD_EXP 77
31803: NOT
31804: IFFALSE 31808
// exit ;
31806: GO 32971
// for i = 1 to mc_bases do
31808: LD_ADDR_VAR 0 2
31812: PUSH
31813: DOUBLE
31814: LD_INT 1
31816: DEC
31817: ST_TO_ADDR
31818: LD_EXP 77
31822: PUSH
31823: FOR_TO
31824: IFFALSE 32969
// begin if mc_scan [ i ] then
31826: LD_EXP 100
31830: PUSH
31831: LD_VAR 0 2
31835: ARRAY
31836: IFFALSE 31840
// continue ;
31838: GO 31823
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
31840: LD_EXP 82
31844: PUSH
31845: LD_VAR 0 2
31849: ARRAY
31850: NOT
31851: PUSH
31852: LD_EXP 84
31856: PUSH
31857: LD_VAR 0 2
31861: ARRAY
31862: NOT
31863: AND
31864: PUSH
31865: LD_EXP 83
31869: PUSH
31870: LD_VAR 0 2
31874: ARRAY
31875: AND
31876: IFFALSE 31914
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
31878: LD_ADDR_EXP 83
31882: PUSH
31883: LD_EXP 83
31887: PPUSH
31888: LD_VAR 0 2
31892: PPUSH
31893: EMPTY
31894: PPUSH
31895: CALL_OW 1
31899: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
31900: LD_VAR 0 2
31904: PPUSH
31905: LD_INT 103
31907: PPUSH
31908: CALL 25521 0 2
// continue ;
31912: GO 31823
// end ; if mc_construct_list [ i ] then
31914: LD_EXP 84
31918: PUSH
31919: LD_VAR 0 2
31923: ARRAY
31924: IFFALSE 32144
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31926: LD_ADDR_VAR 0 5
31930: PUSH
31931: LD_EXP 77
31935: PUSH
31936: LD_VAR 0 2
31940: ARRAY
31941: PPUSH
31942: LD_INT 25
31944: PUSH
31945: LD_INT 2
31947: PUSH
31948: EMPTY
31949: LIST
31950: LIST
31951: PPUSH
31952: CALL_OW 72
31956: PUSH
31957: LD_EXP 79
31961: PUSH
31962: LD_VAR 0 2
31966: ARRAY
31967: DIFF
31968: ST_TO_ADDR
// if not tmp then
31969: LD_VAR 0 5
31973: NOT
31974: IFFALSE 31978
// continue ;
31976: GO 31823
// for j in tmp do
31978: LD_ADDR_VAR 0 3
31982: PUSH
31983: LD_VAR 0 5
31987: PUSH
31988: FOR_IN
31989: IFFALSE 32140
// begin if not mc_builders [ i ] then
31991: LD_EXP 83
31995: PUSH
31996: LD_VAR 0 2
32000: ARRAY
32001: NOT
32002: IFFALSE 32060
// begin SetTag ( j , 103 ) ;
32004: LD_VAR 0 3
32008: PPUSH
32009: LD_INT 103
32011: PPUSH
32012: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
32016: LD_ADDR_EXP 83
32020: PUSH
32021: LD_EXP 83
32025: PPUSH
32026: LD_VAR 0 2
32030: PUSH
32031: LD_EXP 83
32035: PUSH
32036: LD_VAR 0 2
32040: ARRAY
32041: PUSH
32042: LD_INT 1
32044: PLUS
32045: PUSH
32046: EMPTY
32047: LIST
32048: LIST
32049: PPUSH
32050: LD_VAR 0 3
32054: PPUSH
32055: CALL 57199 0 3
32059: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
32060: LD_VAR 0 3
32064: PPUSH
32065: CALL_OW 310
32069: IFFALSE 32080
// ComExitBuilding ( j ) ;
32071: LD_VAR 0 3
32075: PPUSH
32076: CALL_OW 122
// wait ( 3 ) ;
32080: LD_INT 3
32082: PPUSH
32083: CALL_OW 67
// if not mc_construct_list [ i ] then
32087: LD_EXP 84
32091: PUSH
32092: LD_VAR 0 2
32096: ARRAY
32097: NOT
32098: IFFALSE 32102
// break ;
32100: GO 32140
// if not HasTask ( j ) then
32102: LD_VAR 0 3
32106: PPUSH
32107: CALL_OW 314
32111: NOT
32112: IFFALSE 32138
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
32114: LD_VAR 0 3
32118: PPUSH
32119: LD_EXP 84
32123: PUSH
32124: LD_VAR 0 2
32128: ARRAY
32129: PUSH
32130: LD_INT 1
32132: ARRAY
32133: PPUSH
32134: CALL 60060 0 2
// end ;
32138: GO 31988
32140: POP
32141: POP
// end else
32142: GO 32967
// if mc_build_list [ i ] then
32144: LD_EXP 82
32148: PUSH
32149: LD_VAR 0 2
32153: ARRAY
32154: IFFALSE 32967
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
32156: LD_EXP 82
32160: PUSH
32161: LD_VAR 0 2
32165: ARRAY
32166: PUSH
32167: LD_INT 1
32169: ARRAY
32170: PUSH
32171: LD_INT 1
32173: ARRAY
32174: PPUSH
32175: CALL 59884 0 1
32179: PUSH
32180: LD_EXP 77
32184: PUSH
32185: LD_VAR 0 2
32189: ARRAY
32190: PPUSH
32191: LD_INT 2
32193: PUSH
32194: LD_INT 30
32196: PUSH
32197: LD_INT 2
32199: PUSH
32200: EMPTY
32201: LIST
32202: LIST
32203: PUSH
32204: LD_INT 30
32206: PUSH
32207: LD_INT 3
32209: PUSH
32210: EMPTY
32211: LIST
32212: LIST
32213: PUSH
32214: EMPTY
32215: LIST
32216: LIST
32217: LIST
32218: PPUSH
32219: CALL_OW 72
32223: NOT
32224: AND
32225: IFFALSE 32330
// begin for j = 1 to mc_build_list [ i ] do
32227: LD_ADDR_VAR 0 3
32231: PUSH
32232: DOUBLE
32233: LD_INT 1
32235: DEC
32236: ST_TO_ADDR
32237: LD_EXP 82
32241: PUSH
32242: LD_VAR 0 2
32246: ARRAY
32247: PUSH
32248: FOR_TO
32249: IFFALSE 32328
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
32251: LD_EXP 82
32255: PUSH
32256: LD_VAR 0 2
32260: ARRAY
32261: PUSH
32262: LD_VAR 0 3
32266: ARRAY
32267: PUSH
32268: LD_INT 1
32270: ARRAY
32271: PUSH
32272: LD_INT 2
32274: EQUAL
32275: IFFALSE 32326
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
32277: LD_ADDR_EXP 82
32281: PUSH
32282: LD_EXP 82
32286: PPUSH
32287: LD_VAR 0 2
32291: PPUSH
32292: LD_EXP 82
32296: PUSH
32297: LD_VAR 0 2
32301: ARRAY
32302: PPUSH
32303: LD_VAR 0 3
32307: PPUSH
32308: LD_INT 1
32310: PPUSH
32311: LD_INT 0
32313: PPUSH
32314: CALL 56617 0 4
32318: PPUSH
32319: CALL_OW 1
32323: ST_TO_ADDR
// break ;
32324: GO 32328
// end ;
32326: GO 32248
32328: POP
32329: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
32330: LD_ADDR_VAR 0 6
32334: PUSH
32335: LD_EXP 77
32339: PUSH
32340: LD_VAR 0 2
32344: ARRAY
32345: PPUSH
32346: LD_INT 2
32348: PUSH
32349: LD_INT 30
32351: PUSH
32352: LD_INT 0
32354: PUSH
32355: EMPTY
32356: LIST
32357: LIST
32358: PUSH
32359: LD_INT 30
32361: PUSH
32362: LD_INT 1
32364: PUSH
32365: EMPTY
32366: LIST
32367: LIST
32368: PUSH
32369: EMPTY
32370: LIST
32371: LIST
32372: LIST
32373: PPUSH
32374: CALL_OW 72
32378: ST_TO_ADDR
// for k := 1 to depot do
32379: LD_ADDR_VAR 0 4
32383: PUSH
32384: DOUBLE
32385: LD_INT 1
32387: DEC
32388: ST_TO_ADDR
32389: LD_VAR 0 6
32393: PUSH
32394: FOR_TO
32395: IFFALSE 32965
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
32397: LD_EXP 82
32401: PUSH
32402: LD_VAR 0 2
32406: ARRAY
32407: PUSH
32408: LD_INT 1
32410: ARRAY
32411: PUSH
32412: LD_INT 1
32414: ARRAY
32415: PUSH
32416: LD_INT 0
32418: EQUAL
32419: PUSH
32420: LD_VAR 0 6
32424: PUSH
32425: LD_VAR 0 4
32429: ARRAY
32430: PPUSH
32431: LD_EXP 82
32435: PUSH
32436: LD_VAR 0 2
32440: ARRAY
32441: PUSH
32442: LD_INT 1
32444: ARRAY
32445: PUSH
32446: LD_INT 1
32448: ARRAY
32449: PPUSH
32450: LD_EXP 82
32454: PUSH
32455: LD_VAR 0 2
32459: ARRAY
32460: PUSH
32461: LD_INT 1
32463: ARRAY
32464: PUSH
32465: LD_INT 2
32467: ARRAY
32468: PPUSH
32469: LD_EXP 82
32473: PUSH
32474: LD_VAR 0 2
32478: ARRAY
32479: PUSH
32480: LD_INT 1
32482: ARRAY
32483: PUSH
32484: LD_INT 3
32486: ARRAY
32487: PPUSH
32488: LD_EXP 82
32492: PUSH
32493: LD_VAR 0 2
32497: ARRAY
32498: PUSH
32499: LD_INT 1
32501: ARRAY
32502: PUSH
32503: LD_INT 4
32505: ARRAY
32506: PPUSH
32507: CALL 65296 0 5
32511: OR
32512: IFFALSE 32793
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
32514: LD_ADDR_VAR 0 5
32518: PUSH
32519: LD_EXP 77
32523: PUSH
32524: LD_VAR 0 2
32528: ARRAY
32529: PPUSH
32530: LD_INT 25
32532: PUSH
32533: LD_INT 2
32535: PUSH
32536: EMPTY
32537: LIST
32538: LIST
32539: PPUSH
32540: CALL_OW 72
32544: PUSH
32545: LD_EXP 79
32549: PUSH
32550: LD_VAR 0 2
32554: ARRAY
32555: DIFF
32556: ST_TO_ADDR
// if not tmp then
32557: LD_VAR 0 5
32561: NOT
32562: IFFALSE 32566
// continue ;
32564: GO 32394
// for j in tmp do
32566: LD_ADDR_VAR 0 3
32570: PUSH
32571: LD_VAR 0 5
32575: PUSH
32576: FOR_IN
32577: IFFALSE 32789
// begin if not mc_builders [ i ] then
32579: LD_EXP 83
32583: PUSH
32584: LD_VAR 0 2
32588: ARRAY
32589: NOT
32590: IFFALSE 32648
// begin SetTag ( j , 103 ) ;
32592: LD_VAR 0 3
32596: PPUSH
32597: LD_INT 103
32599: PPUSH
32600: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
32604: LD_ADDR_EXP 83
32608: PUSH
32609: LD_EXP 83
32613: PPUSH
32614: LD_VAR 0 2
32618: PUSH
32619: LD_EXP 83
32623: PUSH
32624: LD_VAR 0 2
32628: ARRAY
32629: PUSH
32630: LD_INT 1
32632: PLUS
32633: PUSH
32634: EMPTY
32635: LIST
32636: LIST
32637: PPUSH
32638: LD_VAR 0 3
32642: PPUSH
32643: CALL 57199 0 3
32647: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
32648: LD_VAR 0 3
32652: PPUSH
32653: CALL_OW 310
32657: IFFALSE 32668
// ComExitBuilding ( j ) ;
32659: LD_VAR 0 3
32663: PPUSH
32664: CALL_OW 122
// wait ( 3 ) ;
32668: LD_INT 3
32670: PPUSH
32671: CALL_OW 67
// if not mc_build_list [ i ] then
32675: LD_EXP 82
32679: PUSH
32680: LD_VAR 0 2
32684: ARRAY
32685: NOT
32686: IFFALSE 32690
// break ;
32688: GO 32789
// if not HasTask ( j ) then
32690: LD_VAR 0 3
32694: PPUSH
32695: CALL_OW 314
32699: NOT
32700: IFFALSE 32787
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
32702: LD_VAR 0 3
32706: PPUSH
32707: LD_EXP 82
32711: PUSH
32712: LD_VAR 0 2
32716: ARRAY
32717: PUSH
32718: LD_INT 1
32720: ARRAY
32721: PUSH
32722: LD_INT 1
32724: ARRAY
32725: PPUSH
32726: LD_EXP 82
32730: PUSH
32731: LD_VAR 0 2
32735: ARRAY
32736: PUSH
32737: LD_INT 1
32739: ARRAY
32740: PUSH
32741: LD_INT 2
32743: ARRAY
32744: PPUSH
32745: LD_EXP 82
32749: PUSH
32750: LD_VAR 0 2
32754: ARRAY
32755: PUSH
32756: LD_INT 1
32758: ARRAY
32759: PUSH
32760: LD_INT 3
32762: ARRAY
32763: PPUSH
32764: LD_EXP 82
32768: PUSH
32769: LD_VAR 0 2
32773: ARRAY
32774: PUSH
32775: LD_INT 1
32777: ARRAY
32778: PUSH
32779: LD_INT 4
32781: ARRAY
32782: PPUSH
32783: CALL_OW 145
// end ;
32787: GO 32576
32789: POP
32790: POP
// end else
32791: GO 32963
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
32793: LD_EXP 77
32797: PUSH
32798: LD_VAR 0 2
32802: ARRAY
32803: PPUSH
32804: LD_EXP 82
32808: PUSH
32809: LD_VAR 0 2
32813: ARRAY
32814: PUSH
32815: LD_INT 1
32817: ARRAY
32818: PUSH
32819: LD_INT 1
32821: ARRAY
32822: PPUSH
32823: LD_EXP 82
32827: PUSH
32828: LD_VAR 0 2
32832: ARRAY
32833: PUSH
32834: LD_INT 1
32836: ARRAY
32837: PUSH
32838: LD_INT 2
32840: ARRAY
32841: PPUSH
32842: LD_EXP 82
32846: PUSH
32847: LD_VAR 0 2
32851: ARRAY
32852: PUSH
32853: LD_INT 1
32855: ARRAY
32856: PUSH
32857: LD_INT 3
32859: ARRAY
32860: PPUSH
32861: LD_EXP 82
32865: PUSH
32866: LD_VAR 0 2
32870: ARRAY
32871: PUSH
32872: LD_INT 1
32874: ARRAY
32875: PUSH
32876: LD_INT 4
32878: ARRAY
32879: PPUSH
32880: LD_EXP 77
32884: PUSH
32885: LD_VAR 0 2
32889: ARRAY
32890: PPUSH
32891: LD_INT 21
32893: PUSH
32894: LD_INT 3
32896: PUSH
32897: EMPTY
32898: LIST
32899: LIST
32900: PPUSH
32901: CALL_OW 72
32905: PPUSH
32906: EMPTY
32907: PPUSH
32908: CALL 64050 0 7
32912: NOT
32913: IFFALSE 32963
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
32915: LD_ADDR_EXP 82
32919: PUSH
32920: LD_EXP 82
32924: PPUSH
32925: LD_VAR 0 2
32929: PPUSH
32930: LD_EXP 82
32934: PUSH
32935: LD_VAR 0 2
32939: ARRAY
32940: PPUSH
32941: LD_INT 1
32943: PPUSH
32944: LD_INT 1
32946: NEG
32947: PPUSH
32948: LD_INT 0
32950: PPUSH
32951: CALL 56617 0 4
32955: PPUSH
32956: CALL_OW 1
32960: ST_TO_ADDR
// continue ;
32961: GO 32394
// end ; end ;
32963: GO 32394
32965: POP
32966: POP
// end ; end ;
32967: GO 31823
32969: POP
32970: POP
// end ;
32971: LD_VAR 0 1
32975: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
32976: LD_INT 0
32978: PPUSH
32979: PPUSH
32980: PPUSH
32981: PPUSH
32982: PPUSH
32983: PPUSH
// if not mc_bases then
32984: LD_EXP 77
32988: NOT
32989: IFFALSE 32993
// exit ;
32991: GO 33420
// for i = 1 to mc_bases do
32993: LD_ADDR_VAR 0 2
32997: PUSH
32998: DOUBLE
32999: LD_INT 1
33001: DEC
33002: ST_TO_ADDR
33003: LD_EXP 77
33007: PUSH
33008: FOR_TO
33009: IFFALSE 33418
// begin tmp := mc_build_upgrade [ i ] ;
33011: LD_ADDR_VAR 0 4
33015: PUSH
33016: LD_EXP 109
33020: PUSH
33021: LD_VAR 0 2
33025: ARRAY
33026: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
33027: LD_ADDR_VAR 0 6
33031: PUSH
33032: LD_EXP 110
33036: PUSH
33037: LD_VAR 0 2
33041: ARRAY
33042: PPUSH
33043: LD_INT 2
33045: PUSH
33046: LD_INT 30
33048: PUSH
33049: LD_INT 6
33051: PUSH
33052: EMPTY
33053: LIST
33054: LIST
33055: PUSH
33056: LD_INT 30
33058: PUSH
33059: LD_INT 7
33061: PUSH
33062: EMPTY
33063: LIST
33064: LIST
33065: PUSH
33066: EMPTY
33067: LIST
33068: LIST
33069: LIST
33070: PPUSH
33071: CALL_OW 72
33075: ST_TO_ADDR
// if not tmp and not lab then
33076: LD_VAR 0 4
33080: NOT
33081: PUSH
33082: LD_VAR 0 6
33086: NOT
33087: AND
33088: IFFALSE 33092
// continue ;
33090: GO 33008
// if tmp then
33092: LD_VAR 0 4
33096: IFFALSE 33216
// for j in tmp do
33098: LD_ADDR_VAR 0 3
33102: PUSH
33103: LD_VAR 0 4
33107: PUSH
33108: FOR_IN
33109: IFFALSE 33214
// begin if UpgradeCost ( j ) then
33111: LD_VAR 0 3
33115: PPUSH
33116: CALL 63710 0 1
33120: IFFALSE 33212
// begin ComUpgrade ( j ) ;
33122: LD_VAR 0 3
33126: PPUSH
33127: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
33131: LD_ADDR_EXP 109
33135: PUSH
33136: LD_EXP 109
33140: PPUSH
33141: LD_VAR 0 2
33145: PPUSH
33146: LD_EXP 109
33150: PUSH
33151: LD_VAR 0 2
33155: ARRAY
33156: PUSH
33157: LD_VAR 0 3
33161: DIFF
33162: PPUSH
33163: CALL_OW 1
33167: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
33168: LD_ADDR_EXP 84
33172: PUSH
33173: LD_EXP 84
33177: PPUSH
33178: LD_VAR 0 2
33182: PUSH
33183: LD_EXP 84
33187: PUSH
33188: LD_VAR 0 2
33192: ARRAY
33193: PUSH
33194: LD_INT 1
33196: PLUS
33197: PUSH
33198: EMPTY
33199: LIST
33200: LIST
33201: PPUSH
33202: LD_VAR 0 3
33206: PPUSH
33207: CALL 57199 0 3
33211: ST_TO_ADDR
// end ; end ;
33212: GO 33108
33214: POP
33215: POP
// if not lab or not mc_lab_upgrade [ i ] then
33216: LD_VAR 0 6
33220: NOT
33221: PUSH
33222: LD_EXP 111
33226: PUSH
33227: LD_VAR 0 2
33231: ARRAY
33232: NOT
33233: OR
33234: IFFALSE 33238
// continue ;
33236: GO 33008
// for j in lab do
33238: LD_ADDR_VAR 0 3
33242: PUSH
33243: LD_VAR 0 6
33247: PUSH
33248: FOR_IN
33249: IFFALSE 33414
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
33251: LD_VAR 0 3
33255: PPUSH
33256: CALL_OW 266
33260: PUSH
33261: LD_INT 6
33263: PUSH
33264: LD_INT 7
33266: PUSH
33267: EMPTY
33268: LIST
33269: LIST
33270: IN
33271: PUSH
33272: LD_VAR 0 3
33276: PPUSH
33277: CALL_OW 461
33281: PUSH
33282: LD_INT 1
33284: NONEQUAL
33285: AND
33286: IFFALSE 33412
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
33288: LD_VAR 0 3
33292: PPUSH
33293: LD_EXP 111
33297: PUSH
33298: LD_VAR 0 2
33302: ARRAY
33303: PUSH
33304: LD_INT 1
33306: ARRAY
33307: PPUSH
33308: CALL 63915 0 2
33312: IFFALSE 33412
// begin ComCancel ( j ) ;
33314: LD_VAR 0 3
33318: PPUSH
33319: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
33323: LD_VAR 0 3
33327: PPUSH
33328: LD_EXP 111
33332: PUSH
33333: LD_VAR 0 2
33337: ARRAY
33338: PUSH
33339: LD_INT 1
33341: ARRAY
33342: PPUSH
33343: CALL_OW 207
// if not j in mc_construct_list [ i ] then
33347: LD_VAR 0 3
33351: PUSH
33352: LD_EXP 84
33356: PUSH
33357: LD_VAR 0 2
33361: ARRAY
33362: IN
33363: NOT
33364: IFFALSE 33410
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
33366: LD_ADDR_EXP 84
33370: PUSH
33371: LD_EXP 84
33375: PPUSH
33376: LD_VAR 0 2
33380: PUSH
33381: LD_EXP 84
33385: PUSH
33386: LD_VAR 0 2
33390: ARRAY
33391: PUSH
33392: LD_INT 1
33394: PLUS
33395: PUSH
33396: EMPTY
33397: LIST
33398: LIST
33399: PPUSH
33400: LD_VAR 0 3
33404: PPUSH
33405: CALL 57199 0 3
33409: ST_TO_ADDR
// break ;
33410: GO 33414
// end ; end ; end ;
33412: GO 33248
33414: POP
33415: POP
// end ;
33416: GO 33008
33418: POP
33419: POP
// end ;
33420: LD_VAR 0 1
33424: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
33425: LD_INT 0
33427: PPUSH
33428: PPUSH
33429: PPUSH
33430: PPUSH
33431: PPUSH
33432: PPUSH
33433: PPUSH
33434: PPUSH
33435: PPUSH
// if not mc_bases then
33436: LD_EXP 77
33440: NOT
33441: IFFALSE 33445
// exit ;
33443: GO 33850
// for i = 1 to mc_bases do
33445: LD_ADDR_VAR 0 2
33449: PUSH
33450: DOUBLE
33451: LD_INT 1
33453: DEC
33454: ST_TO_ADDR
33455: LD_EXP 77
33459: PUSH
33460: FOR_TO
33461: IFFALSE 33848
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
33463: LD_EXP 85
33467: PUSH
33468: LD_VAR 0 2
33472: ARRAY
33473: NOT
33474: PUSH
33475: LD_EXP 77
33479: PUSH
33480: LD_VAR 0 2
33484: ARRAY
33485: PPUSH
33486: LD_INT 30
33488: PUSH
33489: LD_INT 3
33491: PUSH
33492: EMPTY
33493: LIST
33494: LIST
33495: PPUSH
33496: CALL_OW 72
33500: NOT
33501: OR
33502: IFFALSE 33506
// continue ;
33504: GO 33460
// busy := false ;
33506: LD_ADDR_VAR 0 8
33510: PUSH
33511: LD_INT 0
33513: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
33514: LD_ADDR_VAR 0 4
33518: PUSH
33519: LD_EXP 77
33523: PUSH
33524: LD_VAR 0 2
33528: ARRAY
33529: PPUSH
33530: LD_INT 30
33532: PUSH
33533: LD_INT 3
33535: PUSH
33536: EMPTY
33537: LIST
33538: LIST
33539: PPUSH
33540: CALL_OW 72
33544: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
33545: LD_ADDR_VAR 0 6
33549: PUSH
33550: LD_EXP 85
33554: PUSH
33555: LD_VAR 0 2
33559: ARRAY
33560: PPUSH
33561: LD_INT 2
33563: PUSH
33564: LD_INT 30
33566: PUSH
33567: LD_INT 32
33569: PUSH
33570: EMPTY
33571: LIST
33572: LIST
33573: PUSH
33574: LD_INT 30
33576: PUSH
33577: LD_INT 33
33579: PUSH
33580: EMPTY
33581: LIST
33582: LIST
33583: PUSH
33584: EMPTY
33585: LIST
33586: LIST
33587: LIST
33588: PPUSH
33589: CALL_OW 72
33593: ST_TO_ADDR
// if not t then
33594: LD_VAR 0 6
33598: NOT
33599: IFFALSE 33603
// continue ;
33601: GO 33460
// for j in tmp do
33603: LD_ADDR_VAR 0 3
33607: PUSH
33608: LD_VAR 0 4
33612: PUSH
33613: FOR_IN
33614: IFFALSE 33644
// if not BuildingStatus ( j ) = bs_idle then
33616: LD_VAR 0 3
33620: PPUSH
33621: CALL_OW 461
33625: PUSH
33626: LD_INT 2
33628: EQUAL
33629: NOT
33630: IFFALSE 33642
// begin busy := true ;
33632: LD_ADDR_VAR 0 8
33636: PUSH
33637: LD_INT 1
33639: ST_TO_ADDR
// break ;
33640: GO 33644
// end ;
33642: GO 33613
33644: POP
33645: POP
// if busy then
33646: LD_VAR 0 8
33650: IFFALSE 33654
// continue ;
33652: GO 33460
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
33654: LD_ADDR_VAR 0 7
33658: PUSH
33659: LD_VAR 0 6
33663: PPUSH
33664: LD_INT 35
33666: PUSH
33667: LD_INT 0
33669: PUSH
33670: EMPTY
33671: LIST
33672: LIST
33673: PPUSH
33674: CALL_OW 72
33678: ST_TO_ADDR
// if tw then
33679: LD_VAR 0 7
33683: IFFALSE 33760
// begin tw := tw [ 1 ] ;
33685: LD_ADDR_VAR 0 7
33689: PUSH
33690: LD_VAR 0 7
33694: PUSH
33695: LD_INT 1
33697: ARRAY
33698: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
33699: LD_ADDR_VAR 0 9
33703: PUSH
33704: LD_VAR 0 7
33708: PPUSH
33709: LD_EXP 102
33713: PUSH
33714: LD_VAR 0 2
33718: ARRAY
33719: PPUSH
33720: CALL 62207 0 2
33724: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
33725: LD_EXP 116
33729: PUSH
33730: LD_VAR 0 2
33734: ARRAY
33735: IFFALSE 33758
// if not weapon in mc_allowed_tower_weapons [ i ] then
33737: LD_VAR 0 9
33741: PUSH
33742: LD_EXP 116
33746: PUSH
33747: LD_VAR 0 2
33751: ARRAY
33752: IN
33753: NOT
33754: IFFALSE 33758
// continue ;
33756: GO 33460
// end else
33758: GO 33823
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
33760: LD_ADDR_VAR 0 5
33764: PUSH
33765: LD_EXP 85
33769: PUSH
33770: LD_VAR 0 2
33774: ARRAY
33775: PPUSH
33776: LD_VAR 0 4
33780: PPUSH
33781: CALL 89078 0 2
33785: ST_TO_ADDR
// if not tmp2 then
33786: LD_VAR 0 5
33790: NOT
33791: IFFALSE 33795
// continue ;
33793: GO 33460
// tw := tmp2 [ 1 ] ;
33795: LD_ADDR_VAR 0 7
33799: PUSH
33800: LD_VAR 0 5
33804: PUSH
33805: LD_INT 1
33807: ARRAY
33808: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
33809: LD_ADDR_VAR 0 9
33813: PUSH
33814: LD_VAR 0 5
33818: PUSH
33819: LD_INT 2
33821: ARRAY
33822: ST_TO_ADDR
// end ; if not weapon then
33823: LD_VAR 0 9
33827: NOT
33828: IFFALSE 33832
// continue ;
33830: GO 33460
// ComPlaceWeapon ( tw , weapon ) ;
33832: LD_VAR 0 7
33836: PPUSH
33837: LD_VAR 0 9
33841: PPUSH
33842: CALL_OW 148
// end ;
33846: GO 33460
33848: POP
33849: POP
// end ;
33850: LD_VAR 0 1
33854: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
33855: LD_INT 0
33857: PPUSH
33858: PPUSH
33859: PPUSH
33860: PPUSH
33861: PPUSH
33862: PPUSH
33863: PPUSH
// if not mc_bases then
33864: LD_EXP 77
33868: NOT
33869: IFFALSE 33873
// exit ;
33871: GO 34641
// for i = 1 to mc_bases do
33873: LD_ADDR_VAR 0 2
33877: PUSH
33878: DOUBLE
33879: LD_INT 1
33881: DEC
33882: ST_TO_ADDR
33883: LD_EXP 77
33887: PUSH
33888: FOR_TO
33889: IFFALSE 34639
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
33891: LD_EXP 90
33895: PUSH
33896: LD_VAR 0 2
33900: ARRAY
33901: NOT
33902: PUSH
33903: LD_EXP 90
33907: PUSH
33908: LD_VAR 0 2
33912: ARRAY
33913: PUSH
33914: LD_EXP 91
33918: PUSH
33919: LD_VAR 0 2
33923: ARRAY
33924: EQUAL
33925: OR
33926: PUSH
33927: LD_EXP 100
33931: PUSH
33932: LD_VAR 0 2
33936: ARRAY
33937: OR
33938: IFFALSE 33942
// continue ;
33940: GO 33888
// if mc_miners [ i ] then
33942: LD_EXP 91
33946: PUSH
33947: LD_VAR 0 2
33951: ARRAY
33952: IFFALSE 34326
// begin for j = mc_miners [ i ] downto 1 do
33954: LD_ADDR_VAR 0 3
33958: PUSH
33959: DOUBLE
33960: LD_EXP 91
33964: PUSH
33965: LD_VAR 0 2
33969: ARRAY
33970: INC
33971: ST_TO_ADDR
33972: LD_INT 1
33974: PUSH
33975: FOR_DOWNTO
33976: IFFALSE 34324
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
33978: LD_EXP 91
33982: PUSH
33983: LD_VAR 0 2
33987: ARRAY
33988: PUSH
33989: LD_VAR 0 3
33993: ARRAY
33994: PPUSH
33995: CALL_OW 301
33999: PUSH
34000: LD_EXP 91
34004: PUSH
34005: LD_VAR 0 2
34009: ARRAY
34010: PUSH
34011: LD_VAR 0 3
34015: ARRAY
34016: PPUSH
34017: CALL_OW 257
34021: PUSH
34022: LD_INT 1
34024: NONEQUAL
34025: OR
34026: IFFALSE 34089
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
34028: LD_ADDR_VAR 0 5
34032: PUSH
34033: LD_EXP 91
34037: PUSH
34038: LD_VAR 0 2
34042: ARRAY
34043: PUSH
34044: LD_EXP 91
34048: PUSH
34049: LD_VAR 0 2
34053: ARRAY
34054: PUSH
34055: LD_VAR 0 3
34059: ARRAY
34060: DIFF
34061: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
34062: LD_ADDR_EXP 91
34066: PUSH
34067: LD_EXP 91
34071: PPUSH
34072: LD_VAR 0 2
34076: PPUSH
34077: LD_VAR 0 5
34081: PPUSH
34082: CALL_OW 1
34086: ST_TO_ADDR
// continue ;
34087: GO 33975
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
34089: LD_EXP 91
34093: PUSH
34094: LD_VAR 0 2
34098: ARRAY
34099: PUSH
34100: LD_VAR 0 3
34104: ARRAY
34105: PPUSH
34106: CALL_OW 257
34110: PUSH
34111: LD_INT 1
34113: EQUAL
34114: PUSH
34115: LD_EXP 91
34119: PUSH
34120: LD_VAR 0 2
34124: ARRAY
34125: PUSH
34126: LD_VAR 0 3
34130: ARRAY
34131: PPUSH
34132: CALL_OW 459
34136: NOT
34137: AND
34138: PUSH
34139: LD_EXP 91
34143: PUSH
34144: LD_VAR 0 2
34148: ARRAY
34149: PUSH
34150: LD_VAR 0 3
34154: ARRAY
34155: PPUSH
34156: CALL_OW 314
34160: NOT
34161: AND
34162: IFFALSE 34322
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
34164: LD_EXP 91
34168: PUSH
34169: LD_VAR 0 2
34173: ARRAY
34174: PUSH
34175: LD_VAR 0 3
34179: ARRAY
34180: PPUSH
34181: CALL_OW 310
34185: IFFALSE 34208
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
34187: LD_EXP 91
34191: PUSH
34192: LD_VAR 0 2
34196: ARRAY
34197: PUSH
34198: LD_VAR 0 3
34202: ARRAY
34203: PPUSH
34204: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
34208: LD_EXP 91
34212: PUSH
34213: LD_VAR 0 2
34217: ARRAY
34218: PUSH
34219: LD_VAR 0 3
34223: ARRAY
34224: PPUSH
34225: CALL_OW 314
34229: NOT
34230: IFFALSE 34322
// begin r := rand ( 1 , mc_mines [ i ] ) ;
34232: LD_ADDR_VAR 0 7
34236: PUSH
34237: LD_INT 1
34239: PPUSH
34240: LD_EXP 90
34244: PUSH
34245: LD_VAR 0 2
34249: ARRAY
34250: PPUSH
34251: CALL_OW 12
34255: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
34256: LD_EXP 91
34260: PUSH
34261: LD_VAR 0 2
34265: ARRAY
34266: PUSH
34267: LD_VAR 0 3
34271: ARRAY
34272: PPUSH
34273: LD_EXP 90
34277: PUSH
34278: LD_VAR 0 2
34282: ARRAY
34283: PUSH
34284: LD_VAR 0 7
34288: ARRAY
34289: PUSH
34290: LD_INT 1
34292: ARRAY
34293: PPUSH
34294: LD_EXP 90
34298: PUSH
34299: LD_VAR 0 2
34303: ARRAY
34304: PUSH
34305: LD_VAR 0 7
34309: ARRAY
34310: PUSH
34311: LD_INT 2
34313: ARRAY
34314: PPUSH
34315: LD_INT 0
34317: PPUSH
34318: CALL_OW 193
// end ; end ; end ;
34322: GO 33975
34324: POP
34325: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
34326: LD_ADDR_VAR 0 5
34330: PUSH
34331: LD_EXP 77
34335: PUSH
34336: LD_VAR 0 2
34340: ARRAY
34341: PPUSH
34342: LD_INT 2
34344: PUSH
34345: LD_INT 30
34347: PUSH
34348: LD_INT 4
34350: PUSH
34351: EMPTY
34352: LIST
34353: LIST
34354: PUSH
34355: LD_INT 30
34357: PUSH
34358: LD_INT 5
34360: PUSH
34361: EMPTY
34362: LIST
34363: LIST
34364: PUSH
34365: LD_INT 30
34367: PUSH
34368: LD_INT 32
34370: PUSH
34371: EMPTY
34372: LIST
34373: LIST
34374: PUSH
34375: EMPTY
34376: LIST
34377: LIST
34378: LIST
34379: LIST
34380: PPUSH
34381: CALL_OW 72
34385: ST_TO_ADDR
// if not tmp then
34386: LD_VAR 0 5
34390: NOT
34391: IFFALSE 34395
// continue ;
34393: GO 33888
// list := [ ] ;
34395: LD_ADDR_VAR 0 6
34399: PUSH
34400: EMPTY
34401: ST_TO_ADDR
// for j in tmp do
34402: LD_ADDR_VAR 0 3
34406: PUSH
34407: LD_VAR 0 5
34411: PUSH
34412: FOR_IN
34413: IFFALSE 34482
// begin for k in UnitsInside ( j ) do
34415: LD_ADDR_VAR 0 4
34419: PUSH
34420: LD_VAR 0 3
34424: PPUSH
34425: CALL_OW 313
34429: PUSH
34430: FOR_IN
34431: IFFALSE 34478
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
34433: LD_VAR 0 4
34437: PPUSH
34438: CALL_OW 257
34442: PUSH
34443: LD_INT 1
34445: EQUAL
34446: PUSH
34447: LD_VAR 0 4
34451: PPUSH
34452: CALL_OW 459
34456: NOT
34457: AND
34458: IFFALSE 34476
// list := list ^ k ;
34460: LD_ADDR_VAR 0 6
34464: PUSH
34465: LD_VAR 0 6
34469: PUSH
34470: LD_VAR 0 4
34474: ADD
34475: ST_TO_ADDR
34476: GO 34430
34478: POP
34479: POP
// end ;
34480: GO 34412
34482: POP
34483: POP
// list := list diff mc_miners [ i ] ;
34484: LD_ADDR_VAR 0 6
34488: PUSH
34489: LD_VAR 0 6
34493: PUSH
34494: LD_EXP 91
34498: PUSH
34499: LD_VAR 0 2
34503: ARRAY
34504: DIFF
34505: ST_TO_ADDR
// if not list then
34506: LD_VAR 0 6
34510: NOT
34511: IFFALSE 34515
// continue ;
34513: GO 33888
// k := mc_mines [ i ] - mc_miners [ i ] ;
34515: LD_ADDR_VAR 0 4
34519: PUSH
34520: LD_EXP 90
34524: PUSH
34525: LD_VAR 0 2
34529: ARRAY
34530: PUSH
34531: LD_EXP 91
34535: PUSH
34536: LD_VAR 0 2
34540: ARRAY
34541: MINUS
34542: ST_TO_ADDR
// if k > list then
34543: LD_VAR 0 4
34547: PUSH
34548: LD_VAR 0 6
34552: GREATER
34553: IFFALSE 34565
// k := list ;
34555: LD_ADDR_VAR 0 4
34559: PUSH
34560: LD_VAR 0 6
34564: ST_TO_ADDR
// for j = 1 to k do
34565: LD_ADDR_VAR 0 3
34569: PUSH
34570: DOUBLE
34571: LD_INT 1
34573: DEC
34574: ST_TO_ADDR
34575: LD_VAR 0 4
34579: PUSH
34580: FOR_TO
34581: IFFALSE 34635
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
34583: LD_ADDR_EXP 91
34587: PUSH
34588: LD_EXP 91
34592: PPUSH
34593: LD_VAR 0 2
34597: PUSH
34598: LD_EXP 91
34602: PUSH
34603: LD_VAR 0 2
34607: ARRAY
34608: PUSH
34609: LD_INT 1
34611: PLUS
34612: PUSH
34613: EMPTY
34614: LIST
34615: LIST
34616: PPUSH
34617: LD_VAR 0 6
34621: PUSH
34622: LD_VAR 0 3
34626: ARRAY
34627: PPUSH
34628: CALL 57199 0 3
34632: ST_TO_ADDR
34633: GO 34580
34635: POP
34636: POP
// end ;
34637: GO 33888
34639: POP
34640: POP
// end ;
34641: LD_VAR 0 1
34645: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
34646: LD_INT 0
34648: PPUSH
34649: PPUSH
34650: PPUSH
34651: PPUSH
34652: PPUSH
34653: PPUSH
34654: PPUSH
34655: PPUSH
34656: PPUSH
34657: PPUSH
34658: PPUSH
// if not mc_bases then
34659: LD_EXP 77
34663: NOT
34664: IFFALSE 34668
// exit ;
34666: GO 36491
// for i = 1 to mc_bases do
34668: LD_ADDR_VAR 0 2
34672: PUSH
34673: DOUBLE
34674: LD_INT 1
34676: DEC
34677: ST_TO_ADDR
34678: LD_EXP 77
34682: PUSH
34683: FOR_TO
34684: IFFALSE 36489
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
34686: LD_EXP 77
34690: PUSH
34691: LD_VAR 0 2
34695: ARRAY
34696: NOT
34697: PUSH
34698: LD_EXP 84
34702: PUSH
34703: LD_VAR 0 2
34707: ARRAY
34708: OR
34709: IFFALSE 34713
// continue ;
34711: GO 34683
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
34713: LD_EXP 93
34717: PUSH
34718: LD_VAR 0 2
34722: ARRAY
34723: NOT
34724: PUSH
34725: LD_EXP 94
34729: PUSH
34730: LD_VAR 0 2
34734: ARRAY
34735: AND
34736: IFFALSE 34774
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
34738: LD_ADDR_EXP 94
34742: PUSH
34743: LD_EXP 94
34747: PPUSH
34748: LD_VAR 0 2
34752: PPUSH
34753: EMPTY
34754: PPUSH
34755: CALL_OW 1
34759: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
34760: LD_VAR 0 2
34764: PPUSH
34765: LD_INT 107
34767: PPUSH
34768: CALL 25521 0 2
// continue ;
34772: GO 34683
// end ; target := [ ] ;
34774: LD_ADDR_VAR 0 7
34778: PUSH
34779: EMPTY
34780: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
34781: LD_ADDR_VAR 0 6
34785: PUSH
34786: LD_EXP 77
34790: PUSH
34791: LD_VAR 0 2
34795: ARRAY
34796: PUSH
34797: LD_INT 1
34799: ARRAY
34800: PPUSH
34801: CALL_OW 255
34805: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34806: LD_ADDR_VAR 0 9
34810: PUSH
34811: LD_EXP 77
34815: PUSH
34816: LD_VAR 0 2
34820: ARRAY
34821: PPUSH
34822: LD_INT 2
34824: PUSH
34825: LD_INT 30
34827: PUSH
34828: LD_INT 0
34830: PUSH
34831: EMPTY
34832: LIST
34833: LIST
34834: PUSH
34835: LD_INT 30
34837: PUSH
34838: LD_INT 1
34840: PUSH
34841: EMPTY
34842: LIST
34843: LIST
34844: PUSH
34845: EMPTY
34846: LIST
34847: LIST
34848: LIST
34849: PPUSH
34850: CALL_OW 72
34854: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
34855: LD_ADDR_VAR 0 3
34859: PUSH
34860: DOUBLE
34861: LD_EXP 93
34865: PUSH
34866: LD_VAR 0 2
34870: ARRAY
34871: INC
34872: ST_TO_ADDR
34873: LD_INT 1
34875: PUSH
34876: FOR_DOWNTO
34877: IFFALSE 35122
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
34879: LD_EXP 93
34883: PUSH
34884: LD_VAR 0 2
34888: ARRAY
34889: PUSH
34890: LD_VAR 0 3
34894: ARRAY
34895: PUSH
34896: LD_INT 2
34898: ARRAY
34899: PPUSH
34900: LD_EXP 93
34904: PUSH
34905: LD_VAR 0 2
34909: ARRAY
34910: PUSH
34911: LD_VAR 0 3
34915: ARRAY
34916: PUSH
34917: LD_INT 3
34919: ARRAY
34920: PPUSH
34921: CALL_OW 488
34925: PUSH
34926: LD_EXP 93
34930: PUSH
34931: LD_VAR 0 2
34935: ARRAY
34936: PUSH
34937: LD_VAR 0 3
34941: ARRAY
34942: PUSH
34943: LD_INT 2
34945: ARRAY
34946: PPUSH
34947: LD_EXP 93
34951: PUSH
34952: LD_VAR 0 2
34956: ARRAY
34957: PUSH
34958: LD_VAR 0 3
34962: ARRAY
34963: PUSH
34964: LD_INT 3
34966: ARRAY
34967: PPUSH
34968: CALL_OW 284
34972: PUSH
34973: LD_INT 0
34975: EQUAL
34976: AND
34977: IFFALSE 35032
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
34979: LD_ADDR_VAR 0 5
34983: PUSH
34984: LD_EXP 93
34988: PUSH
34989: LD_VAR 0 2
34993: ARRAY
34994: PPUSH
34995: LD_VAR 0 3
34999: PPUSH
35000: CALL_OW 3
35004: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
35005: LD_ADDR_EXP 93
35009: PUSH
35010: LD_EXP 93
35014: PPUSH
35015: LD_VAR 0 2
35019: PPUSH
35020: LD_VAR 0 5
35024: PPUSH
35025: CALL_OW 1
35029: ST_TO_ADDR
// continue ;
35030: GO 34876
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
35032: LD_VAR 0 6
35036: PPUSH
35037: LD_EXP 93
35041: PUSH
35042: LD_VAR 0 2
35046: ARRAY
35047: PUSH
35048: LD_VAR 0 3
35052: ARRAY
35053: PUSH
35054: LD_INT 2
35056: ARRAY
35057: PPUSH
35058: LD_EXP 93
35062: PUSH
35063: LD_VAR 0 2
35067: ARRAY
35068: PUSH
35069: LD_VAR 0 3
35073: ARRAY
35074: PUSH
35075: LD_INT 3
35077: ARRAY
35078: PPUSH
35079: LD_INT 30
35081: PPUSH
35082: CALL 58095 0 4
35086: PUSH
35087: LD_INT 4
35089: ARRAY
35090: PUSH
35091: LD_INT 0
35093: EQUAL
35094: IFFALSE 35120
// begin target := mc_crates [ i ] [ j ] ;
35096: LD_ADDR_VAR 0 7
35100: PUSH
35101: LD_EXP 93
35105: PUSH
35106: LD_VAR 0 2
35110: ARRAY
35111: PUSH
35112: LD_VAR 0 3
35116: ARRAY
35117: ST_TO_ADDR
// break ;
35118: GO 35122
// end ; end ;
35120: GO 34876
35122: POP
35123: POP
// if not target then
35124: LD_VAR 0 7
35128: NOT
35129: IFFALSE 35133
// continue ;
35131: GO 34683
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
35133: LD_ADDR_VAR 0 8
35137: PUSH
35138: LD_EXP 96
35142: PUSH
35143: LD_VAR 0 2
35147: ARRAY
35148: PPUSH
35149: LD_INT 2
35151: PUSH
35152: LD_INT 3
35154: PUSH
35155: LD_INT 58
35157: PUSH
35158: EMPTY
35159: LIST
35160: PUSH
35161: EMPTY
35162: LIST
35163: LIST
35164: PUSH
35165: LD_INT 61
35167: PUSH
35168: EMPTY
35169: LIST
35170: PUSH
35171: LD_INT 33
35173: PUSH
35174: LD_INT 5
35176: PUSH
35177: EMPTY
35178: LIST
35179: LIST
35180: PUSH
35181: LD_INT 33
35183: PUSH
35184: LD_INT 3
35186: PUSH
35187: EMPTY
35188: LIST
35189: LIST
35190: PUSH
35191: EMPTY
35192: LIST
35193: LIST
35194: LIST
35195: LIST
35196: LIST
35197: PUSH
35198: LD_INT 2
35200: PUSH
35201: LD_INT 34
35203: PUSH
35204: LD_INT 32
35206: PUSH
35207: EMPTY
35208: LIST
35209: LIST
35210: PUSH
35211: LD_INT 34
35213: PUSH
35214: LD_INT 51
35216: PUSH
35217: EMPTY
35218: LIST
35219: LIST
35220: PUSH
35221: LD_INT 34
35223: PUSH
35224: LD_INT 12
35226: PUSH
35227: EMPTY
35228: LIST
35229: LIST
35230: PUSH
35231: EMPTY
35232: LIST
35233: LIST
35234: LIST
35235: LIST
35236: PUSH
35237: EMPTY
35238: LIST
35239: LIST
35240: PPUSH
35241: CALL_OW 72
35245: ST_TO_ADDR
// if not cargo then
35246: LD_VAR 0 8
35250: NOT
35251: IFFALSE 35957
// begin if mc_crates_collector [ i ] < 5 then
35253: LD_EXP 94
35257: PUSH
35258: LD_VAR 0 2
35262: ARRAY
35263: PUSH
35264: LD_INT 5
35266: LESS
35267: IFFALSE 35633
// begin if mc_ape [ i ] then
35269: LD_EXP 106
35273: PUSH
35274: LD_VAR 0 2
35278: ARRAY
35279: IFFALSE 35326
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
35281: LD_ADDR_VAR 0 5
35285: PUSH
35286: LD_EXP 106
35290: PUSH
35291: LD_VAR 0 2
35295: ARRAY
35296: PPUSH
35297: LD_INT 25
35299: PUSH
35300: LD_INT 16
35302: PUSH
35303: EMPTY
35304: LIST
35305: LIST
35306: PUSH
35307: LD_INT 24
35309: PUSH
35310: LD_INT 750
35312: PUSH
35313: EMPTY
35314: LIST
35315: LIST
35316: PUSH
35317: EMPTY
35318: LIST
35319: LIST
35320: PPUSH
35321: CALL_OW 72
35325: ST_TO_ADDR
// if not tmp then
35326: LD_VAR 0 5
35330: NOT
35331: IFFALSE 35378
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
35333: LD_ADDR_VAR 0 5
35337: PUSH
35338: LD_EXP 77
35342: PUSH
35343: LD_VAR 0 2
35347: ARRAY
35348: PPUSH
35349: LD_INT 25
35351: PUSH
35352: LD_INT 2
35354: PUSH
35355: EMPTY
35356: LIST
35357: LIST
35358: PUSH
35359: LD_INT 24
35361: PUSH
35362: LD_INT 750
35364: PUSH
35365: EMPTY
35366: LIST
35367: LIST
35368: PUSH
35369: EMPTY
35370: LIST
35371: LIST
35372: PPUSH
35373: CALL_OW 72
35377: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
35378: LD_EXP 106
35382: PUSH
35383: LD_VAR 0 2
35387: ARRAY
35388: PUSH
35389: LD_EXP 77
35393: PUSH
35394: LD_VAR 0 2
35398: ARRAY
35399: PPUSH
35400: LD_INT 25
35402: PUSH
35403: LD_INT 2
35405: PUSH
35406: EMPTY
35407: LIST
35408: LIST
35409: PUSH
35410: LD_INT 24
35412: PUSH
35413: LD_INT 750
35415: PUSH
35416: EMPTY
35417: LIST
35418: LIST
35419: PUSH
35420: EMPTY
35421: LIST
35422: LIST
35423: PPUSH
35424: CALL_OW 72
35428: AND
35429: PUSH
35430: LD_VAR 0 5
35434: PUSH
35435: LD_INT 5
35437: LESS
35438: AND
35439: IFFALSE 35521
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
35441: LD_ADDR_VAR 0 3
35445: PUSH
35446: LD_EXP 77
35450: PUSH
35451: LD_VAR 0 2
35455: ARRAY
35456: PPUSH
35457: LD_INT 25
35459: PUSH
35460: LD_INT 2
35462: PUSH
35463: EMPTY
35464: LIST
35465: LIST
35466: PUSH
35467: LD_INT 24
35469: PUSH
35470: LD_INT 750
35472: PUSH
35473: EMPTY
35474: LIST
35475: LIST
35476: PUSH
35477: EMPTY
35478: LIST
35479: LIST
35480: PPUSH
35481: CALL_OW 72
35485: PUSH
35486: FOR_IN
35487: IFFALSE 35519
// begin tmp := tmp union j ;
35489: LD_ADDR_VAR 0 5
35493: PUSH
35494: LD_VAR 0 5
35498: PUSH
35499: LD_VAR 0 3
35503: UNION
35504: ST_TO_ADDR
// if tmp >= 5 then
35505: LD_VAR 0 5
35509: PUSH
35510: LD_INT 5
35512: GREATEREQUAL
35513: IFFALSE 35517
// break ;
35515: GO 35519
// end ;
35517: GO 35486
35519: POP
35520: POP
// end ; if not tmp then
35521: LD_VAR 0 5
35525: NOT
35526: IFFALSE 35530
// continue ;
35528: GO 34683
// for j in tmp do
35530: LD_ADDR_VAR 0 3
35534: PUSH
35535: LD_VAR 0 5
35539: PUSH
35540: FOR_IN
35541: IFFALSE 35631
// if not GetTag ( j ) then
35543: LD_VAR 0 3
35547: PPUSH
35548: CALL_OW 110
35552: NOT
35553: IFFALSE 35629
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
35555: LD_ADDR_EXP 94
35559: PUSH
35560: LD_EXP 94
35564: PPUSH
35565: LD_VAR 0 2
35569: PUSH
35570: LD_EXP 94
35574: PUSH
35575: LD_VAR 0 2
35579: ARRAY
35580: PUSH
35581: LD_INT 1
35583: PLUS
35584: PUSH
35585: EMPTY
35586: LIST
35587: LIST
35588: PPUSH
35589: LD_VAR 0 3
35593: PPUSH
35594: CALL 57199 0 3
35598: ST_TO_ADDR
// SetTag ( j , 107 ) ;
35599: LD_VAR 0 3
35603: PPUSH
35604: LD_INT 107
35606: PPUSH
35607: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
35611: LD_EXP 94
35615: PUSH
35616: LD_VAR 0 2
35620: ARRAY
35621: PUSH
35622: LD_INT 5
35624: GREATEREQUAL
35625: IFFALSE 35629
// break ;
35627: GO 35631
// end ;
35629: GO 35540
35631: POP
35632: POP
// end ; if mc_crates_collector [ i ] and target then
35633: LD_EXP 94
35637: PUSH
35638: LD_VAR 0 2
35642: ARRAY
35643: PUSH
35644: LD_VAR 0 7
35648: AND
35649: IFFALSE 35955
// begin if mc_crates_collector [ i ] < target [ 1 ] then
35651: LD_EXP 94
35655: PUSH
35656: LD_VAR 0 2
35660: ARRAY
35661: PUSH
35662: LD_VAR 0 7
35666: PUSH
35667: LD_INT 1
35669: ARRAY
35670: LESS
35671: IFFALSE 35691
// tmp := mc_crates_collector [ i ] else
35673: LD_ADDR_VAR 0 5
35677: PUSH
35678: LD_EXP 94
35682: PUSH
35683: LD_VAR 0 2
35687: ARRAY
35688: ST_TO_ADDR
35689: GO 35705
// tmp := target [ 1 ] ;
35691: LD_ADDR_VAR 0 5
35695: PUSH
35696: LD_VAR 0 7
35700: PUSH
35701: LD_INT 1
35703: ARRAY
35704: ST_TO_ADDR
// k := 0 ;
35705: LD_ADDR_VAR 0 4
35709: PUSH
35710: LD_INT 0
35712: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
35713: LD_ADDR_VAR 0 3
35717: PUSH
35718: LD_EXP 94
35722: PUSH
35723: LD_VAR 0 2
35727: ARRAY
35728: PUSH
35729: FOR_IN
35730: IFFALSE 35953
// begin k := k + 1 ;
35732: LD_ADDR_VAR 0 4
35736: PUSH
35737: LD_VAR 0 4
35741: PUSH
35742: LD_INT 1
35744: PLUS
35745: ST_TO_ADDR
// if k > tmp then
35746: LD_VAR 0 4
35750: PUSH
35751: LD_VAR 0 5
35755: GREATER
35756: IFFALSE 35760
// break ;
35758: GO 35953
// if not GetClass ( j ) in [ 2 , 16 ] then
35760: LD_VAR 0 3
35764: PPUSH
35765: CALL_OW 257
35769: PUSH
35770: LD_INT 2
35772: PUSH
35773: LD_INT 16
35775: PUSH
35776: EMPTY
35777: LIST
35778: LIST
35779: IN
35780: NOT
35781: IFFALSE 35834
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
35783: LD_ADDR_EXP 94
35787: PUSH
35788: LD_EXP 94
35792: PPUSH
35793: LD_VAR 0 2
35797: PPUSH
35798: LD_EXP 94
35802: PUSH
35803: LD_VAR 0 2
35807: ARRAY
35808: PUSH
35809: LD_VAR 0 3
35813: DIFF
35814: PPUSH
35815: CALL_OW 1
35819: ST_TO_ADDR
// SetTag ( j , 0 ) ;
35820: LD_VAR 0 3
35824: PPUSH
35825: LD_INT 0
35827: PPUSH
35828: CALL_OW 109
// continue ;
35832: GO 35729
// end ; if IsInUnit ( j ) then
35834: LD_VAR 0 3
35838: PPUSH
35839: CALL_OW 310
35843: IFFALSE 35854
// ComExitBuilding ( j ) ;
35845: LD_VAR 0 3
35849: PPUSH
35850: CALL_OW 122
// wait ( 3 ) ;
35854: LD_INT 3
35856: PPUSH
35857: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
35861: LD_VAR 0 3
35865: PPUSH
35866: CALL_OW 314
35870: PUSH
35871: LD_VAR 0 6
35875: PPUSH
35876: LD_VAR 0 7
35880: PUSH
35881: LD_INT 2
35883: ARRAY
35884: PPUSH
35885: LD_VAR 0 7
35889: PUSH
35890: LD_INT 3
35892: ARRAY
35893: PPUSH
35894: LD_INT 30
35896: PPUSH
35897: CALL 58095 0 4
35901: PUSH
35902: LD_INT 4
35904: ARRAY
35905: AND
35906: IFFALSE 35924
// ComStandNearbyBuilding ( j , depot ) else
35908: LD_VAR 0 3
35912: PPUSH
35913: LD_VAR 0 9
35917: PPUSH
35918: CALL 53626 0 2
35922: GO 35951
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35924: LD_VAR 0 3
35928: PPUSH
35929: LD_VAR 0 7
35933: PUSH
35934: LD_INT 2
35936: ARRAY
35937: PPUSH
35938: LD_VAR 0 7
35942: PUSH
35943: LD_INT 3
35945: ARRAY
35946: PPUSH
35947: CALL_OW 117
// end ;
35951: GO 35729
35953: POP
35954: POP
// end ; end else
35955: GO 36487
// begin for j in cargo do
35957: LD_ADDR_VAR 0 3
35961: PUSH
35962: LD_VAR 0 8
35966: PUSH
35967: FOR_IN
35968: IFFALSE 36485
// begin if GetTag ( j ) <> 0 then
35970: LD_VAR 0 3
35974: PPUSH
35975: CALL_OW 110
35979: PUSH
35980: LD_INT 0
35982: NONEQUAL
35983: IFFALSE 35987
// continue ;
35985: GO 35967
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
35987: LD_VAR 0 3
35991: PPUSH
35992: CALL_OW 256
35996: PUSH
35997: LD_INT 1000
35999: LESS
36000: PUSH
36001: LD_VAR 0 3
36005: PPUSH
36006: LD_EXP 101
36010: PUSH
36011: LD_VAR 0 2
36015: ARRAY
36016: PPUSH
36017: CALL_OW 308
36021: NOT
36022: AND
36023: IFFALSE 36045
// ComMoveToArea ( j , mc_parking [ i ] ) ;
36025: LD_VAR 0 3
36029: PPUSH
36030: LD_EXP 101
36034: PUSH
36035: LD_VAR 0 2
36039: ARRAY
36040: PPUSH
36041: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
36045: LD_VAR 0 3
36049: PPUSH
36050: CALL_OW 256
36054: PUSH
36055: LD_INT 1000
36057: LESS
36058: PUSH
36059: LD_VAR 0 3
36063: PPUSH
36064: LD_EXP 101
36068: PUSH
36069: LD_VAR 0 2
36073: ARRAY
36074: PPUSH
36075: CALL_OW 308
36079: AND
36080: IFFALSE 36084
// continue ;
36082: GO 35967
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
36084: LD_VAR 0 3
36088: PPUSH
36089: CALL_OW 262
36093: PUSH
36094: LD_INT 2
36096: EQUAL
36097: PUSH
36098: LD_VAR 0 3
36102: PPUSH
36103: CALL_OW 261
36107: PUSH
36108: LD_INT 15
36110: LESS
36111: AND
36112: IFFALSE 36116
// continue ;
36114: GO 35967
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
36116: LD_VAR 0 3
36120: PPUSH
36121: CALL_OW 262
36125: PUSH
36126: LD_INT 1
36128: EQUAL
36129: PUSH
36130: LD_VAR 0 3
36134: PPUSH
36135: CALL_OW 261
36139: PUSH
36140: LD_INT 10
36142: LESS
36143: AND
36144: IFFALSE 36424
// begin if not depot then
36146: LD_VAR 0 9
36150: NOT
36151: IFFALSE 36155
// continue ;
36153: GO 35967
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
36155: LD_VAR 0 3
36159: PPUSH
36160: LD_VAR 0 9
36164: PPUSH
36165: LD_VAR 0 3
36169: PPUSH
36170: CALL_OW 74
36174: PPUSH
36175: CALL_OW 296
36179: PUSH
36180: LD_INT 6
36182: LESS
36183: IFFALSE 36199
// SetFuel ( j , 100 ) else
36185: LD_VAR 0 3
36189: PPUSH
36190: LD_INT 100
36192: PPUSH
36193: CALL_OW 240
36197: GO 36424
// if GetFuel ( j ) = 0 then
36199: LD_VAR 0 3
36203: PPUSH
36204: CALL_OW 261
36208: PUSH
36209: LD_INT 0
36211: EQUAL
36212: IFFALSE 36424
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
36214: LD_ADDR_EXP 96
36218: PUSH
36219: LD_EXP 96
36223: PPUSH
36224: LD_VAR 0 2
36228: PPUSH
36229: LD_EXP 96
36233: PUSH
36234: LD_VAR 0 2
36238: ARRAY
36239: PUSH
36240: LD_VAR 0 3
36244: DIFF
36245: PPUSH
36246: CALL_OW 1
36250: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
36251: LD_VAR 0 3
36255: PPUSH
36256: CALL_OW 263
36260: PUSH
36261: LD_INT 1
36263: EQUAL
36264: IFFALSE 36280
// ComExitVehicle ( IsInUnit ( j ) ) ;
36266: LD_VAR 0 3
36270: PPUSH
36271: CALL_OW 310
36275: PPUSH
36276: CALL_OW 121
// if GetControl ( j ) = control_remote then
36280: LD_VAR 0 3
36284: PPUSH
36285: CALL_OW 263
36289: PUSH
36290: LD_INT 2
36292: EQUAL
36293: IFFALSE 36304
// ComUnlink ( j ) ;
36295: LD_VAR 0 3
36299: PPUSH
36300: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
36304: LD_ADDR_VAR 0 10
36308: PUSH
36309: LD_VAR 0 2
36313: PPUSH
36314: LD_INT 3
36316: PPUSH
36317: CALL 46091 0 2
36321: ST_TO_ADDR
// if fac then
36322: LD_VAR 0 10
36326: IFFALSE 36422
// begin for k in fac do
36328: LD_ADDR_VAR 0 4
36332: PUSH
36333: LD_VAR 0 10
36337: PUSH
36338: FOR_IN
36339: IFFALSE 36420
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
36341: LD_ADDR_VAR 0 11
36345: PUSH
36346: LD_VAR 0 10
36350: PPUSH
36351: LD_VAR 0 3
36355: PPUSH
36356: CALL_OW 265
36360: PPUSH
36361: LD_VAR 0 3
36365: PPUSH
36366: CALL_OW 262
36370: PPUSH
36371: LD_VAR 0 3
36375: PPUSH
36376: CALL_OW 263
36380: PPUSH
36381: LD_VAR 0 3
36385: PPUSH
36386: CALL_OW 264
36390: PPUSH
36391: CALL 54697 0 5
36395: ST_TO_ADDR
// if components then
36396: LD_VAR 0 11
36400: IFFALSE 36418
// begin MC_InsertProduceList ( i , components ) ;
36402: LD_VAR 0 2
36406: PPUSH
36407: LD_VAR 0 11
36411: PPUSH
36412: CALL 45636 0 2
// break ;
36416: GO 36420
// end ; end ;
36418: GO 36338
36420: POP
36421: POP
// end ; continue ;
36422: GO 35967
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
36424: LD_VAR 0 3
36428: PPUSH
36429: LD_INT 1
36431: PPUSH
36432: CALL_OW 289
36436: PUSH
36437: LD_INT 100
36439: LESS
36440: PUSH
36441: LD_VAR 0 3
36445: PPUSH
36446: CALL_OW 314
36450: NOT
36451: AND
36452: IFFALSE 36481
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
36454: LD_VAR 0 3
36458: PPUSH
36459: LD_VAR 0 7
36463: PUSH
36464: LD_INT 2
36466: ARRAY
36467: PPUSH
36468: LD_VAR 0 7
36472: PUSH
36473: LD_INT 3
36475: ARRAY
36476: PPUSH
36477: CALL_OW 117
// break ;
36481: GO 36485
// end ;
36483: GO 35967
36485: POP
36486: POP
// end ; end ;
36487: GO 34683
36489: POP
36490: POP
// end ;
36491: LD_VAR 0 1
36495: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
36496: LD_INT 0
36498: PPUSH
36499: PPUSH
36500: PPUSH
36501: PPUSH
// if not mc_bases then
36502: LD_EXP 77
36506: NOT
36507: IFFALSE 36511
// exit ;
36509: GO 36672
// for i = 1 to mc_bases do
36511: LD_ADDR_VAR 0 2
36515: PUSH
36516: DOUBLE
36517: LD_INT 1
36519: DEC
36520: ST_TO_ADDR
36521: LD_EXP 77
36525: PUSH
36526: FOR_TO
36527: IFFALSE 36670
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
36529: LD_ADDR_VAR 0 4
36533: PUSH
36534: LD_EXP 96
36538: PUSH
36539: LD_VAR 0 2
36543: ARRAY
36544: PUSH
36545: LD_EXP 99
36549: PUSH
36550: LD_VAR 0 2
36554: ARRAY
36555: UNION
36556: PPUSH
36557: LD_INT 33
36559: PUSH
36560: LD_INT 2
36562: PUSH
36563: EMPTY
36564: LIST
36565: LIST
36566: PPUSH
36567: CALL_OW 72
36571: ST_TO_ADDR
// if tmp then
36572: LD_VAR 0 4
36576: IFFALSE 36668
// for j in tmp do
36578: LD_ADDR_VAR 0 3
36582: PUSH
36583: LD_VAR 0 4
36587: PUSH
36588: FOR_IN
36589: IFFALSE 36666
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
36591: LD_VAR 0 3
36595: PPUSH
36596: CALL_OW 312
36600: NOT
36601: PUSH
36602: LD_VAR 0 3
36606: PPUSH
36607: CALL_OW 256
36611: PUSH
36612: LD_INT 250
36614: GREATEREQUAL
36615: AND
36616: IFFALSE 36629
// Connect ( j ) else
36618: LD_VAR 0 3
36622: PPUSH
36623: CALL 60168 0 1
36627: GO 36664
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
36629: LD_VAR 0 3
36633: PPUSH
36634: CALL_OW 256
36638: PUSH
36639: LD_INT 250
36641: LESS
36642: PUSH
36643: LD_VAR 0 3
36647: PPUSH
36648: CALL_OW 312
36652: AND
36653: IFFALSE 36664
// ComUnlink ( j ) ;
36655: LD_VAR 0 3
36659: PPUSH
36660: CALL_OW 136
36664: GO 36588
36666: POP
36667: POP
// end ;
36668: GO 36526
36670: POP
36671: POP
// end ;
36672: LD_VAR 0 1
36676: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
36677: LD_INT 0
36679: PPUSH
36680: PPUSH
36681: PPUSH
36682: PPUSH
36683: PPUSH
// if not mc_bases then
36684: LD_EXP 77
36688: NOT
36689: IFFALSE 36693
// exit ;
36691: GO 37138
// for i = 1 to mc_bases do
36693: LD_ADDR_VAR 0 2
36697: PUSH
36698: DOUBLE
36699: LD_INT 1
36701: DEC
36702: ST_TO_ADDR
36703: LD_EXP 77
36707: PUSH
36708: FOR_TO
36709: IFFALSE 37136
// begin if not mc_produce [ i ] then
36711: LD_EXP 98
36715: PUSH
36716: LD_VAR 0 2
36720: ARRAY
36721: NOT
36722: IFFALSE 36726
// continue ;
36724: GO 36708
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36726: LD_ADDR_VAR 0 5
36730: PUSH
36731: LD_EXP 77
36735: PUSH
36736: LD_VAR 0 2
36740: ARRAY
36741: PPUSH
36742: LD_INT 30
36744: PUSH
36745: LD_INT 3
36747: PUSH
36748: EMPTY
36749: LIST
36750: LIST
36751: PPUSH
36752: CALL_OW 72
36756: ST_TO_ADDR
// if not fac then
36757: LD_VAR 0 5
36761: NOT
36762: IFFALSE 36766
// continue ;
36764: GO 36708
// for j in fac do
36766: LD_ADDR_VAR 0 3
36770: PUSH
36771: LD_VAR 0 5
36775: PUSH
36776: FOR_IN
36777: IFFALSE 37132
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
36779: LD_VAR 0 3
36783: PPUSH
36784: CALL_OW 461
36788: PUSH
36789: LD_INT 2
36791: NONEQUAL
36792: PUSH
36793: LD_VAR 0 3
36797: PPUSH
36798: LD_INT 15
36800: PPUSH
36801: CALL 59796 0 2
36805: PUSH
36806: LD_INT 4
36808: ARRAY
36809: OR
36810: IFFALSE 36814
// continue ;
36812: GO 36776
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
36814: LD_VAR 0 3
36818: PPUSH
36819: LD_EXP 98
36823: PUSH
36824: LD_VAR 0 2
36828: ARRAY
36829: PUSH
36830: LD_INT 1
36832: ARRAY
36833: PUSH
36834: LD_INT 1
36836: ARRAY
36837: PPUSH
36838: LD_EXP 98
36842: PUSH
36843: LD_VAR 0 2
36847: ARRAY
36848: PUSH
36849: LD_INT 1
36851: ARRAY
36852: PUSH
36853: LD_INT 2
36855: ARRAY
36856: PPUSH
36857: LD_EXP 98
36861: PUSH
36862: LD_VAR 0 2
36866: ARRAY
36867: PUSH
36868: LD_INT 1
36870: ARRAY
36871: PUSH
36872: LD_INT 3
36874: ARRAY
36875: PPUSH
36876: LD_EXP 98
36880: PUSH
36881: LD_VAR 0 2
36885: ARRAY
36886: PUSH
36887: LD_INT 1
36889: ARRAY
36890: PUSH
36891: LD_INT 4
36893: ARRAY
36894: PPUSH
36895: CALL_OW 448
36899: PUSH
36900: LD_VAR 0 3
36904: PPUSH
36905: LD_EXP 98
36909: PUSH
36910: LD_VAR 0 2
36914: ARRAY
36915: PUSH
36916: LD_INT 1
36918: ARRAY
36919: PUSH
36920: LD_INT 1
36922: ARRAY
36923: PUSH
36924: LD_EXP 98
36928: PUSH
36929: LD_VAR 0 2
36933: ARRAY
36934: PUSH
36935: LD_INT 1
36937: ARRAY
36938: PUSH
36939: LD_INT 2
36941: ARRAY
36942: PUSH
36943: LD_EXP 98
36947: PUSH
36948: LD_VAR 0 2
36952: ARRAY
36953: PUSH
36954: LD_INT 1
36956: ARRAY
36957: PUSH
36958: LD_INT 3
36960: ARRAY
36961: PUSH
36962: LD_EXP 98
36966: PUSH
36967: LD_VAR 0 2
36971: ARRAY
36972: PUSH
36973: LD_INT 1
36975: ARRAY
36976: PUSH
36977: LD_INT 4
36979: ARRAY
36980: PUSH
36981: EMPTY
36982: LIST
36983: LIST
36984: LIST
36985: LIST
36986: PPUSH
36987: CALL 63563 0 2
36991: AND
36992: IFFALSE 37130
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
36994: LD_VAR 0 3
36998: PPUSH
36999: LD_EXP 98
37003: PUSH
37004: LD_VAR 0 2
37008: ARRAY
37009: PUSH
37010: LD_INT 1
37012: ARRAY
37013: PUSH
37014: LD_INT 1
37016: ARRAY
37017: PPUSH
37018: LD_EXP 98
37022: PUSH
37023: LD_VAR 0 2
37027: ARRAY
37028: PUSH
37029: LD_INT 1
37031: ARRAY
37032: PUSH
37033: LD_INT 2
37035: ARRAY
37036: PPUSH
37037: LD_EXP 98
37041: PUSH
37042: LD_VAR 0 2
37046: ARRAY
37047: PUSH
37048: LD_INT 1
37050: ARRAY
37051: PUSH
37052: LD_INT 3
37054: ARRAY
37055: PPUSH
37056: LD_EXP 98
37060: PUSH
37061: LD_VAR 0 2
37065: ARRAY
37066: PUSH
37067: LD_INT 1
37069: ARRAY
37070: PUSH
37071: LD_INT 4
37073: ARRAY
37074: PPUSH
37075: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
37079: LD_ADDR_VAR 0 4
37083: PUSH
37084: LD_EXP 98
37088: PUSH
37089: LD_VAR 0 2
37093: ARRAY
37094: PPUSH
37095: LD_INT 1
37097: PPUSH
37098: CALL_OW 3
37102: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
37103: LD_ADDR_EXP 98
37107: PUSH
37108: LD_EXP 98
37112: PPUSH
37113: LD_VAR 0 2
37117: PPUSH
37118: LD_VAR 0 4
37122: PPUSH
37123: CALL_OW 1
37127: ST_TO_ADDR
// break ;
37128: GO 37132
// end ; end ;
37130: GO 36776
37132: POP
37133: POP
// end ;
37134: GO 36708
37136: POP
37137: POP
// end ;
37138: LD_VAR 0 1
37142: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
37143: LD_INT 0
37145: PPUSH
37146: PPUSH
37147: PPUSH
// if not mc_bases then
37148: LD_EXP 77
37152: NOT
37153: IFFALSE 37157
// exit ;
37155: GO 37246
// for i = 1 to mc_bases do
37157: LD_ADDR_VAR 0 2
37161: PUSH
37162: DOUBLE
37163: LD_INT 1
37165: DEC
37166: ST_TO_ADDR
37167: LD_EXP 77
37171: PUSH
37172: FOR_TO
37173: IFFALSE 37244
// begin if mc_attack [ i ] then
37175: LD_EXP 97
37179: PUSH
37180: LD_VAR 0 2
37184: ARRAY
37185: IFFALSE 37242
// begin tmp := mc_attack [ i ] [ 1 ] ;
37187: LD_ADDR_VAR 0 3
37191: PUSH
37192: LD_EXP 97
37196: PUSH
37197: LD_VAR 0 2
37201: ARRAY
37202: PUSH
37203: LD_INT 1
37205: ARRAY
37206: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
37207: LD_ADDR_EXP 97
37211: PUSH
37212: LD_EXP 97
37216: PPUSH
37217: LD_VAR 0 2
37221: PPUSH
37222: EMPTY
37223: PPUSH
37224: CALL_OW 1
37228: ST_TO_ADDR
// Attack ( tmp ) ;
37229: LD_VAR 0 3
37233: PPUSH
37234: CALL 113566 0 1
// exit ;
37238: POP
37239: POP
37240: GO 37246
// end ; end ;
37242: GO 37172
37244: POP
37245: POP
// end ;
37246: LD_VAR 0 1
37250: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
37251: LD_INT 0
37253: PPUSH
37254: PPUSH
37255: PPUSH
37256: PPUSH
37257: PPUSH
37258: PPUSH
37259: PPUSH
// if not mc_bases then
37260: LD_EXP 77
37264: NOT
37265: IFFALSE 37269
// exit ;
37267: GO 38126
// for i = 1 to mc_bases do
37269: LD_ADDR_VAR 0 2
37273: PUSH
37274: DOUBLE
37275: LD_INT 1
37277: DEC
37278: ST_TO_ADDR
37279: LD_EXP 77
37283: PUSH
37284: FOR_TO
37285: IFFALSE 38124
// begin if not mc_bases [ i ] then
37287: LD_EXP 77
37291: PUSH
37292: LD_VAR 0 2
37296: ARRAY
37297: NOT
37298: IFFALSE 37302
// continue ;
37300: GO 37284
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
37302: LD_ADDR_VAR 0 7
37306: PUSH
37307: LD_EXP 77
37311: PUSH
37312: LD_VAR 0 2
37316: ARRAY
37317: PUSH
37318: LD_INT 1
37320: ARRAY
37321: PPUSH
37322: CALL 53848 0 1
37326: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
37327: LD_ADDR_EXP 100
37331: PUSH
37332: LD_EXP 100
37336: PPUSH
37337: LD_VAR 0 2
37341: PPUSH
37342: LD_EXP 77
37346: PUSH
37347: LD_VAR 0 2
37351: ARRAY
37352: PUSH
37353: LD_INT 1
37355: ARRAY
37356: PPUSH
37357: CALL_OW 255
37361: PPUSH
37362: LD_EXP 102
37366: PUSH
37367: LD_VAR 0 2
37371: ARRAY
37372: PPUSH
37373: CALL 53813 0 2
37377: PPUSH
37378: CALL_OW 1
37382: ST_TO_ADDR
// if not mc_scan [ i ] then
37383: LD_EXP 100
37387: PUSH
37388: LD_VAR 0 2
37392: ARRAY
37393: NOT
37394: IFFALSE 37572
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
37396: LD_ADDR_EXP 120
37400: PUSH
37401: LD_EXP 120
37405: PPUSH
37406: LD_VAR 0 2
37410: PPUSH
37411: LD_INT 0
37413: PPUSH
37414: CALL_OW 1
37418: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
37419: LD_ADDR_VAR 0 4
37423: PUSH
37424: LD_EXP 77
37428: PUSH
37429: LD_VAR 0 2
37433: ARRAY
37434: PPUSH
37435: LD_INT 2
37437: PUSH
37438: LD_INT 25
37440: PUSH
37441: LD_INT 5
37443: PUSH
37444: EMPTY
37445: LIST
37446: LIST
37447: PUSH
37448: LD_INT 25
37450: PUSH
37451: LD_INT 8
37453: PUSH
37454: EMPTY
37455: LIST
37456: LIST
37457: PUSH
37458: LD_INT 25
37460: PUSH
37461: LD_INT 9
37463: PUSH
37464: EMPTY
37465: LIST
37466: LIST
37467: PUSH
37468: EMPTY
37469: LIST
37470: LIST
37471: LIST
37472: LIST
37473: PPUSH
37474: CALL_OW 72
37478: ST_TO_ADDR
// if not tmp then
37479: LD_VAR 0 4
37483: NOT
37484: IFFALSE 37488
// continue ;
37486: GO 37284
// for j in tmp do
37488: LD_ADDR_VAR 0 3
37492: PUSH
37493: LD_VAR 0 4
37497: PUSH
37498: FOR_IN
37499: IFFALSE 37570
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
37501: LD_VAR 0 3
37505: PPUSH
37506: CALL_OW 310
37510: PPUSH
37511: CALL_OW 266
37515: PUSH
37516: LD_INT 5
37518: EQUAL
37519: PUSH
37520: LD_VAR 0 3
37524: PPUSH
37525: CALL_OW 257
37529: PUSH
37530: LD_INT 1
37532: EQUAL
37533: AND
37534: PUSH
37535: LD_VAR 0 3
37539: PPUSH
37540: CALL_OW 459
37544: NOT
37545: AND
37546: PUSH
37547: LD_VAR 0 7
37551: AND
37552: IFFALSE 37568
// ComChangeProfession ( j , class ) ;
37554: LD_VAR 0 3
37558: PPUSH
37559: LD_VAR 0 7
37563: PPUSH
37564: CALL_OW 123
37568: GO 37498
37570: POP
37571: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
37572: LD_EXP 100
37576: PUSH
37577: LD_VAR 0 2
37581: ARRAY
37582: PUSH
37583: LD_EXP 120
37587: PUSH
37588: LD_VAR 0 2
37592: ARRAY
37593: NOT
37594: AND
37595: PUSH
37596: LD_EXP 99
37600: PUSH
37601: LD_VAR 0 2
37605: ARRAY
37606: NOT
37607: AND
37608: PUSH
37609: LD_EXP 77
37613: PUSH
37614: LD_VAR 0 2
37618: ARRAY
37619: PPUSH
37620: LD_INT 50
37622: PUSH
37623: EMPTY
37624: LIST
37625: PUSH
37626: LD_INT 2
37628: PUSH
37629: LD_INT 30
37631: PUSH
37632: LD_INT 32
37634: PUSH
37635: EMPTY
37636: LIST
37637: LIST
37638: PUSH
37639: LD_INT 30
37641: PUSH
37642: LD_INT 33
37644: PUSH
37645: EMPTY
37646: LIST
37647: LIST
37648: PUSH
37649: LD_INT 30
37651: PUSH
37652: LD_INT 4
37654: PUSH
37655: EMPTY
37656: LIST
37657: LIST
37658: PUSH
37659: LD_INT 30
37661: PUSH
37662: LD_INT 5
37664: PUSH
37665: EMPTY
37666: LIST
37667: LIST
37668: PUSH
37669: EMPTY
37670: LIST
37671: LIST
37672: LIST
37673: LIST
37674: LIST
37675: PUSH
37676: EMPTY
37677: LIST
37678: LIST
37679: PPUSH
37680: CALL_OW 72
37684: PUSH
37685: LD_INT 4
37687: LESS
37688: PUSH
37689: LD_EXP 77
37693: PUSH
37694: LD_VAR 0 2
37698: ARRAY
37699: PPUSH
37700: LD_INT 3
37702: PUSH
37703: LD_INT 24
37705: PUSH
37706: LD_INT 1000
37708: PUSH
37709: EMPTY
37710: LIST
37711: LIST
37712: PUSH
37713: EMPTY
37714: LIST
37715: LIST
37716: PUSH
37717: LD_INT 2
37719: PUSH
37720: LD_INT 30
37722: PUSH
37723: LD_INT 0
37725: PUSH
37726: EMPTY
37727: LIST
37728: LIST
37729: PUSH
37730: LD_INT 30
37732: PUSH
37733: LD_INT 1
37735: PUSH
37736: EMPTY
37737: LIST
37738: LIST
37739: PUSH
37740: EMPTY
37741: LIST
37742: LIST
37743: LIST
37744: PUSH
37745: EMPTY
37746: LIST
37747: LIST
37748: PPUSH
37749: CALL_OW 72
37753: OR
37754: AND
37755: IFFALSE 38006
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
37757: LD_ADDR_EXP 120
37761: PUSH
37762: LD_EXP 120
37766: PPUSH
37767: LD_VAR 0 2
37771: PPUSH
37772: LD_INT 1
37774: PPUSH
37775: CALL_OW 1
37779: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
37780: LD_ADDR_VAR 0 4
37784: PUSH
37785: LD_EXP 77
37789: PUSH
37790: LD_VAR 0 2
37794: ARRAY
37795: PPUSH
37796: LD_INT 2
37798: PUSH
37799: LD_INT 25
37801: PUSH
37802: LD_INT 1
37804: PUSH
37805: EMPTY
37806: LIST
37807: LIST
37808: PUSH
37809: LD_INT 25
37811: PUSH
37812: LD_INT 5
37814: PUSH
37815: EMPTY
37816: LIST
37817: LIST
37818: PUSH
37819: LD_INT 25
37821: PUSH
37822: LD_INT 8
37824: PUSH
37825: EMPTY
37826: LIST
37827: LIST
37828: PUSH
37829: LD_INT 25
37831: PUSH
37832: LD_INT 9
37834: PUSH
37835: EMPTY
37836: LIST
37837: LIST
37838: PUSH
37839: EMPTY
37840: LIST
37841: LIST
37842: LIST
37843: LIST
37844: LIST
37845: PPUSH
37846: CALL_OW 72
37850: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
37851: LD_ADDR_VAR 0 4
37855: PUSH
37856: LD_VAR 0 4
37860: PUSH
37861: LD_VAR 0 4
37865: PPUSH
37866: LD_INT 18
37868: PPUSH
37869: CALL 87111 0 2
37873: DIFF
37874: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
37875: LD_VAR 0 4
37879: NOT
37880: PUSH
37881: LD_EXP 77
37885: PUSH
37886: LD_VAR 0 2
37890: ARRAY
37891: PPUSH
37892: LD_INT 2
37894: PUSH
37895: LD_INT 30
37897: PUSH
37898: LD_INT 4
37900: PUSH
37901: EMPTY
37902: LIST
37903: LIST
37904: PUSH
37905: LD_INT 30
37907: PUSH
37908: LD_INT 5
37910: PUSH
37911: EMPTY
37912: LIST
37913: LIST
37914: PUSH
37915: EMPTY
37916: LIST
37917: LIST
37918: LIST
37919: PPUSH
37920: CALL_OW 72
37924: NOT
37925: AND
37926: IFFALSE 37988
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
37928: LD_ADDR_VAR 0 4
37932: PUSH
37933: LD_EXP 77
37937: PUSH
37938: LD_VAR 0 2
37942: ARRAY
37943: PPUSH
37944: LD_INT 2
37946: PUSH
37947: LD_INT 25
37949: PUSH
37950: LD_INT 2
37952: PUSH
37953: EMPTY
37954: LIST
37955: LIST
37956: PUSH
37957: LD_INT 25
37959: PUSH
37960: LD_INT 3
37962: PUSH
37963: EMPTY
37964: LIST
37965: LIST
37966: PUSH
37967: LD_INT 25
37969: PUSH
37970: LD_INT 4
37972: PUSH
37973: EMPTY
37974: LIST
37975: LIST
37976: PUSH
37977: EMPTY
37978: LIST
37979: LIST
37980: LIST
37981: LIST
37982: PPUSH
37983: CALL_OW 72
37987: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
37988: LD_VAR 0 2
37992: PPUSH
37993: LD_VAR 0 4
37997: PPUSH
37998: CALL 118275 0 2
// exit ;
38002: POP
38003: POP
38004: GO 38126
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
38006: LD_EXP 100
38010: PUSH
38011: LD_VAR 0 2
38015: ARRAY
38016: PUSH
38017: LD_EXP 120
38021: PUSH
38022: LD_VAR 0 2
38026: ARRAY
38027: NOT
38028: AND
38029: PUSH
38030: LD_EXP 99
38034: PUSH
38035: LD_VAR 0 2
38039: ARRAY
38040: AND
38041: IFFALSE 38122
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
38043: LD_ADDR_EXP 120
38047: PUSH
38048: LD_EXP 120
38052: PPUSH
38053: LD_VAR 0 2
38057: PPUSH
38058: LD_INT 1
38060: PPUSH
38061: CALL_OW 1
38065: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
38066: LD_ADDR_VAR 0 4
38070: PUSH
38071: LD_EXP 99
38075: PUSH
38076: LD_VAR 0 2
38080: ARRAY
38081: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
38082: LD_ADDR_EXP 99
38086: PUSH
38087: LD_EXP 99
38091: PPUSH
38092: LD_VAR 0 2
38096: PPUSH
38097: EMPTY
38098: PPUSH
38099: CALL_OW 1
38103: ST_TO_ADDR
// Defend ( i , tmp ) ;
38104: LD_VAR 0 2
38108: PPUSH
38109: LD_VAR 0 4
38113: PPUSH
38114: CALL 118871 0 2
// exit ;
38118: POP
38119: POP
38120: GO 38126
// end ; end ;
38122: GO 37284
38124: POP
38125: POP
// end ;
38126: LD_VAR 0 1
38130: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
38131: LD_INT 0
38133: PPUSH
38134: PPUSH
38135: PPUSH
38136: PPUSH
38137: PPUSH
38138: PPUSH
38139: PPUSH
38140: PPUSH
38141: PPUSH
38142: PPUSH
38143: PPUSH
// if not mc_bases then
38144: LD_EXP 77
38148: NOT
38149: IFFALSE 38153
// exit ;
38151: GO 39240
// for i = 1 to mc_bases do
38153: LD_ADDR_VAR 0 2
38157: PUSH
38158: DOUBLE
38159: LD_INT 1
38161: DEC
38162: ST_TO_ADDR
38163: LD_EXP 77
38167: PUSH
38168: FOR_TO
38169: IFFALSE 39238
// begin tmp := mc_lab [ i ] ;
38171: LD_ADDR_VAR 0 6
38175: PUSH
38176: LD_EXP 110
38180: PUSH
38181: LD_VAR 0 2
38185: ARRAY
38186: ST_TO_ADDR
// if not tmp then
38187: LD_VAR 0 6
38191: NOT
38192: IFFALSE 38196
// continue ;
38194: GO 38168
// idle_lab := 0 ;
38196: LD_ADDR_VAR 0 11
38200: PUSH
38201: LD_INT 0
38203: ST_TO_ADDR
// for j in tmp do
38204: LD_ADDR_VAR 0 3
38208: PUSH
38209: LD_VAR 0 6
38213: PUSH
38214: FOR_IN
38215: IFFALSE 39234
// begin researching := false ;
38217: LD_ADDR_VAR 0 10
38221: PUSH
38222: LD_INT 0
38224: ST_TO_ADDR
// side := GetSide ( j ) ;
38225: LD_ADDR_VAR 0 4
38229: PUSH
38230: LD_VAR 0 3
38234: PPUSH
38235: CALL_OW 255
38239: ST_TO_ADDR
// if not mc_tech [ side ] then
38240: LD_EXP 104
38244: PUSH
38245: LD_VAR 0 4
38249: ARRAY
38250: NOT
38251: IFFALSE 38255
// continue ;
38253: GO 38214
// if BuildingStatus ( j ) = bs_idle then
38255: LD_VAR 0 3
38259: PPUSH
38260: CALL_OW 461
38264: PUSH
38265: LD_INT 2
38267: EQUAL
38268: IFFALSE 38456
// begin if idle_lab and UnitsInside ( j ) < 6 then
38270: LD_VAR 0 11
38274: PUSH
38275: LD_VAR 0 3
38279: PPUSH
38280: CALL_OW 313
38284: PUSH
38285: LD_INT 6
38287: LESS
38288: AND
38289: IFFALSE 38360
// begin tmp2 := UnitsInside ( idle_lab ) ;
38291: LD_ADDR_VAR 0 9
38295: PUSH
38296: LD_VAR 0 11
38300: PPUSH
38301: CALL_OW 313
38305: ST_TO_ADDR
// if tmp2 then
38306: LD_VAR 0 9
38310: IFFALSE 38352
// for x in tmp2 do
38312: LD_ADDR_VAR 0 7
38316: PUSH
38317: LD_VAR 0 9
38321: PUSH
38322: FOR_IN
38323: IFFALSE 38350
// begin ComExitBuilding ( x ) ;
38325: LD_VAR 0 7
38329: PPUSH
38330: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
38334: LD_VAR 0 7
38338: PPUSH
38339: LD_VAR 0 3
38343: PPUSH
38344: CALL_OW 180
// end ;
38348: GO 38322
38350: POP
38351: POP
// idle_lab := 0 ;
38352: LD_ADDR_VAR 0 11
38356: PUSH
38357: LD_INT 0
38359: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
38360: LD_ADDR_VAR 0 5
38364: PUSH
38365: LD_EXP 104
38369: PUSH
38370: LD_VAR 0 4
38374: ARRAY
38375: PUSH
38376: FOR_IN
38377: IFFALSE 38437
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
38379: LD_VAR 0 3
38383: PPUSH
38384: LD_VAR 0 5
38388: PPUSH
38389: CALL_OW 430
38393: PUSH
38394: LD_VAR 0 4
38398: PPUSH
38399: LD_VAR 0 5
38403: PPUSH
38404: CALL 52918 0 2
38408: AND
38409: IFFALSE 38435
// begin researching := true ;
38411: LD_ADDR_VAR 0 10
38415: PUSH
38416: LD_INT 1
38418: ST_TO_ADDR
// ComResearch ( j , t ) ;
38419: LD_VAR 0 3
38423: PPUSH
38424: LD_VAR 0 5
38428: PPUSH
38429: CALL_OW 124
// break ;
38433: GO 38437
// end ;
38435: GO 38376
38437: POP
38438: POP
// if not researching then
38439: LD_VAR 0 10
38443: NOT
38444: IFFALSE 38456
// idle_lab := j ;
38446: LD_ADDR_VAR 0 11
38450: PUSH
38451: LD_VAR 0 3
38455: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
38456: LD_VAR 0 3
38460: PPUSH
38461: CALL_OW 461
38465: PUSH
38466: LD_INT 10
38468: EQUAL
38469: IFFALSE 39057
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
38471: LD_EXP 106
38475: PUSH
38476: LD_VAR 0 2
38480: ARRAY
38481: NOT
38482: PUSH
38483: LD_EXP 107
38487: PUSH
38488: LD_VAR 0 2
38492: ARRAY
38493: NOT
38494: AND
38495: PUSH
38496: LD_EXP 104
38500: PUSH
38501: LD_VAR 0 4
38505: ARRAY
38506: PUSH
38507: LD_INT 1
38509: GREATER
38510: AND
38511: IFFALSE 38642
// begin ComCancel ( j ) ;
38513: LD_VAR 0 3
38517: PPUSH
38518: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
38522: LD_ADDR_EXP 104
38526: PUSH
38527: LD_EXP 104
38531: PPUSH
38532: LD_VAR 0 4
38536: PPUSH
38537: LD_EXP 104
38541: PUSH
38542: LD_VAR 0 4
38546: ARRAY
38547: PPUSH
38548: LD_EXP 104
38552: PUSH
38553: LD_VAR 0 4
38557: ARRAY
38558: PUSH
38559: LD_INT 1
38561: MINUS
38562: PPUSH
38563: LD_EXP 104
38567: PUSH
38568: LD_VAR 0 4
38572: ARRAY
38573: PPUSH
38574: LD_INT 0
38576: PPUSH
38577: CALL 56617 0 4
38581: PPUSH
38582: CALL_OW 1
38586: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
38587: LD_ADDR_EXP 104
38591: PUSH
38592: LD_EXP 104
38596: PPUSH
38597: LD_VAR 0 4
38601: PPUSH
38602: LD_EXP 104
38606: PUSH
38607: LD_VAR 0 4
38611: ARRAY
38612: PPUSH
38613: LD_EXP 104
38617: PUSH
38618: LD_VAR 0 4
38622: ARRAY
38623: PPUSH
38624: LD_INT 1
38626: PPUSH
38627: LD_INT 0
38629: PPUSH
38630: CALL 56617 0 4
38634: PPUSH
38635: CALL_OW 1
38639: ST_TO_ADDR
// continue ;
38640: GO 38214
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
38642: LD_EXP 106
38646: PUSH
38647: LD_VAR 0 2
38651: ARRAY
38652: PUSH
38653: LD_EXP 107
38657: PUSH
38658: LD_VAR 0 2
38662: ARRAY
38663: NOT
38664: AND
38665: IFFALSE 38792
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
38667: LD_ADDR_EXP 107
38671: PUSH
38672: LD_EXP 107
38676: PPUSH
38677: LD_VAR 0 2
38681: PUSH
38682: LD_EXP 107
38686: PUSH
38687: LD_VAR 0 2
38691: ARRAY
38692: PUSH
38693: LD_INT 1
38695: PLUS
38696: PUSH
38697: EMPTY
38698: LIST
38699: LIST
38700: PPUSH
38701: LD_EXP 106
38705: PUSH
38706: LD_VAR 0 2
38710: ARRAY
38711: PUSH
38712: LD_INT 1
38714: ARRAY
38715: PPUSH
38716: CALL 57199 0 3
38720: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
38721: LD_EXP 106
38725: PUSH
38726: LD_VAR 0 2
38730: ARRAY
38731: PUSH
38732: LD_INT 1
38734: ARRAY
38735: PPUSH
38736: LD_INT 112
38738: PPUSH
38739: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
38743: LD_ADDR_VAR 0 9
38747: PUSH
38748: LD_EXP 106
38752: PUSH
38753: LD_VAR 0 2
38757: ARRAY
38758: PPUSH
38759: LD_INT 1
38761: PPUSH
38762: CALL_OW 3
38766: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
38767: LD_ADDR_EXP 106
38771: PUSH
38772: LD_EXP 106
38776: PPUSH
38777: LD_VAR 0 2
38781: PPUSH
38782: LD_VAR 0 9
38786: PPUSH
38787: CALL_OW 1
38791: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
38792: LD_EXP 106
38796: PUSH
38797: LD_VAR 0 2
38801: ARRAY
38802: PUSH
38803: LD_EXP 107
38807: PUSH
38808: LD_VAR 0 2
38812: ARRAY
38813: AND
38814: PUSH
38815: LD_EXP 107
38819: PUSH
38820: LD_VAR 0 2
38824: ARRAY
38825: PUSH
38826: LD_INT 1
38828: ARRAY
38829: PPUSH
38830: CALL_OW 310
38834: NOT
38835: AND
38836: PUSH
38837: LD_VAR 0 3
38841: PPUSH
38842: CALL_OW 313
38846: PUSH
38847: LD_INT 6
38849: EQUAL
38850: AND
38851: IFFALSE 38907
// begin tmp2 := UnitsInside ( j ) ;
38853: LD_ADDR_VAR 0 9
38857: PUSH
38858: LD_VAR 0 3
38862: PPUSH
38863: CALL_OW 313
38867: ST_TO_ADDR
// if tmp2 = 6 then
38868: LD_VAR 0 9
38872: PUSH
38873: LD_INT 6
38875: EQUAL
38876: IFFALSE 38907
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
38878: LD_VAR 0 9
38882: PUSH
38883: LD_INT 1
38885: ARRAY
38886: PPUSH
38887: LD_INT 112
38889: PPUSH
38890: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
38894: LD_VAR 0 9
38898: PUSH
38899: LD_INT 1
38901: ARRAY
38902: PPUSH
38903: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
38907: LD_EXP 107
38911: PUSH
38912: LD_VAR 0 2
38916: ARRAY
38917: PUSH
38918: LD_EXP 107
38922: PUSH
38923: LD_VAR 0 2
38927: ARRAY
38928: PUSH
38929: LD_INT 1
38931: ARRAY
38932: PPUSH
38933: CALL_OW 314
38937: NOT
38938: AND
38939: PUSH
38940: LD_EXP 107
38944: PUSH
38945: LD_VAR 0 2
38949: ARRAY
38950: PUSH
38951: LD_INT 1
38953: ARRAY
38954: PPUSH
38955: CALL_OW 310
38959: NOT
38960: AND
38961: IFFALSE 38987
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
38963: LD_EXP 107
38967: PUSH
38968: LD_VAR 0 2
38972: ARRAY
38973: PUSH
38974: LD_INT 1
38976: ARRAY
38977: PPUSH
38978: LD_VAR 0 3
38982: PPUSH
38983: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
38987: LD_EXP 107
38991: PUSH
38992: LD_VAR 0 2
38996: ARRAY
38997: PUSH
38998: LD_INT 1
39000: ARRAY
39001: PPUSH
39002: CALL_OW 310
39006: PUSH
39007: LD_EXP 107
39011: PUSH
39012: LD_VAR 0 2
39016: ARRAY
39017: PUSH
39018: LD_INT 1
39020: ARRAY
39021: PPUSH
39022: CALL_OW 310
39026: PPUSH
39027: CALL_OW 461
39031: PUSH
39032: LD_INT 3
39034: NONEQUAL
39035: AND
39036: IFFALSE 39057
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
39038: LD_EXP 107
39042: PUSH
39043: LD_VAR 0 2
39047: ARRAY
39048: PUSH
39049: LD_INT 1
39051: ARRAY
39052: PPUSH
39053: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
39057: LD_VAR 0 3
39061: PPUSH
39062: CALL_OW 461
39066: PUSH
39067: LD_INT 6
39069: EQUAL
39070: PUSH
39071: LD_VAR 0 6
39075: PUSH
39076: LD_INT 1
39078: GREATER
39079: AND
39080: IFFALSE 39232
// begin sci := [ ] ;
39082: LD_ADDR_VAR 0 8
39086: PUSH
39087: EMPTY
39088: ST_TO_ADDR
// for x in ( tmp diff j ) do
39089: LD_ADDR_VAR 0 7
39093: PUSH
39094: LD_VAR 0 6
39098: PUSH
39099: LD_VAR 0 3
39103: DIFF
39104: PUSH
39105: FOR_IN
39106: IFFALSE 39158
// begin if sci = 6 then
39108: LD_VAR 0 8
39112: PUSH
39113: LD_INT 6
39115: EQUAL
39116: IFFALSE 39120
// break ;
39118: GO 39158
// if BuildingStatus ( x ) = bs_idle then
39120: LD_VAR 0 7
39124: PPUSH
39125: CALL_OW 461
39129: PUSH
39130: LD_INT 2
39132: EQUAL
39133: IFFALSE 39156
// sci := sci ^ UnitsInside ( x ) ;
39135: LD_ADDR_VAR 0 8
39139: PUSH
39140: LD_VAR 0 8
39144: PUSH
39145: LD_VAR 0 7
39149: PPUSH
39150: CALL_OW 313
39154: ADD
39155: ST_TO_ADDR
// end ;
39156: GO 39105
39158: POP
39159: POP
// if not sci then
39160: LD_VAR 0 8
39164: NOT
39165: IFFALSE 39169
// continue ;
39167: GO 38214
// for x in sci do
39169: LD_ADDR_VAR 0 7
39173: PUSH
39174: LD_VAR 0 8
39178: PUSH
39179: FOR_IN
39180: IFFALSE 39230
// if IsInUnit ( x ) and not HasTask ( x ) then
39182: LD_VAR 0 7
39186: PPUSH
39187: CALL_OW 310
39191: PUSH
39192: LD_VAR 0 7
39196: PPUSH
39197: CALL_OW 314
39201: NOT
39202: AND
39203: IFFALSE 39228
// begin ComExitBuilding ( x ) ;
39205: LD_VAR 0 7
39209: PPUSH
39210: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
39214: LD_VAR 0 7
39218: PPUSH
39219: LD_VAR 0 3
39223: PPUSH
39224: CALL_OW 180
// end ;
39228: GO 39179
39230: POP
39231: POP
// end ; end ;
39232: GO 38214
39234: POP
39235: POP
// end ;
39236: GO 38168
39238: POP
39239: POP
// end ;
39240: LD_VAR 0 1
39244: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
39245: LD_INT 0
39247: PPUSH
39248: PPUSH
// if not mc_bases then
39249: LD_EXP 77
39253: NOT
39254: IFFALSE 39258
// exit ;
39256: GO 39339
// for i = 1 to mc_bases do
39258: LD_ADDR_VAR 0 2
39262: PUSH
39263: DOUBLE
39264: LD_INT 1
39266: DEC
39267: ST_TO_ADDR
39268: LD_EXP 77
39272: PUSH
39273: FOR_TO
39274: IFFALSE 39337
// if mc_mines [ i ] and mc_miners [ i ] then
39276: LD_EXP 90
39280: PUSH
39281: LD_VAR 0 2
39285: ARRAY
39286: PUSH
39287: LD_EXP 91
39291: PUSH
39292: LD_VAR 0 2
39296: ARRAY
39297: AND
39298: IFFALSE 39335
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
39300: LD_EXP 91
39304: PUSH
39305: LD_VAR 0 2
39309: ARRAY
39310: PUSH
39311: LD_INT 1
39313: ARRAY
39314: PPUSH
39315: CALL_OW 255
39319: PPUSH
39320: LD_EXP 90
39324: PUSH
39325: LD_VAR 0 2
39329: ARRAY
39330: PPUSH
39331: CALL 54001 0 2
39335: GO 39273
39337: POP
39338: POP
// end ;
39339: LD_VAR 0 1
39343: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
39344: LD_INT 0
39346: PPUSH
39347: PPUSH
39348: PPUSH
39349: PPUSH
39350: PPUSH
39351: PPUSH
39352: PPUSH
39353: PPUSH
// if not mc_bases or not mc_parking then
39354: LD_EXP 77
39358: NOT
39359: PUSH
39360: LD_EXP 101
39364: NOT
39365: OR
39366: IFFALSE 39370
// exit ;
39368: GO 40108
// for i = 1 to mc_bases do
39370: LD_ADDR_VAR 0 2
39374: PUSH
39375: DOUBLE
39376: LD_INT 1
39378: DEC
39379: ST_TO_ADDR
39380: LD_EXP 77
39384: PUSH
39385: FOR_TO
39386: IFFALSE 40106
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
39388: LD_EXP 77
39392: PUSH
39393: LD_VAR 0 2
39397: ARRAY
39398: NOT
39399: PUSH
39400: LD_EXP 101
39404: PUSH
39405: LD_VAR 0 2
39409: ARRAY
39410: NOT
39411: OR
39412: IFFALSE 39416
// continue ;
39414: GO 39385
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
39416: LD_ADDR_VAR 0 5
39420: PUSH
39421: LD_EXP 77
39425: PUSH
39426: LD_VAR 0 2
39430: ARRAY
39431: PUSH
39432: LD_INT 1
39434: ARRAY
39435: PPUSH
39436: CALL_OW 255
39440: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
39441: LD_ADDR_VAR 0 6
39445: PUSH
39446: LD_EXP 77
39450: PUSH
39451: LD_VAR 0 2
39455: ARRAY
39456: PPUSH
39457: LD_INT 30
39459: PUSH
39460: LD_INT 3
39462: PUSH
39463: EMPTY
39464: LIST
39465: LIST
39466: PPUSH
39467: CALL_OW 72
39471: ST_TO_ADDR
// if not fac then
39472: LD_VAR 0 6
39476: NOT
39477: IFFALSE 39528
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39479: LD_ADDR_VAR 0 6
39483: PUSH
39484: LD_EXP 77
39488: PUSH
39489: LD_VAR 0 2
39493: ARRAY
39494: PPUSH
39495: LD_INT 2
39497: PUSH
39498: LD_INT 30
39500: PUSH
39501: LD_INT 0
39503: PUSH
39504: EMPTY
39505: LIST
39506: LIST
39507: PUSH
39508: LD_INT 30
39510: PUSH
39511: LD_INT 1
39513: PUSH
39514: EMPTY
39515: LIST
39516: LIST
39517: PUSH
39518: EMPTY
39519: LIST
39520: LIST
39521: LIST
39522: PPUSH
39523: CALL_OW 72
39527: ST_TO_ADDR
// if not fac then
39528: LD_VAR 0 6
39532: NOT
39533: IFFALSE 39537
// continue ;
39535: GO 39385
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
39537: LD_ADDR_VAR 0 7
39541: PUSH
39542: LD_EXP 101
39546: PUSH
39547: LD_VAR 0 2
39551: ARRAY
39552: PPUSH
39553: LD_INT 22
39555: PUSH
39556: LD_VAR 0 5
39560: PUSH
39561: EMPTY
39562: LIST
39563: LIST
39564: PUSH
39565: LD_INT 21
39567: PUSH
39568: LD_INT 2
39570: PUSH
39571: EMPTY
39572: LIST
39573: LIST
39574: PUSH
39575: LD_INT 3
39577: PUSH
39578: LD_INT 60
39580: PUSH
39581: EMPTY
39582: LIST
39583: PUSH
39584: EMPTY
39585: LIST
39586: LIST
39587: PUSH
39588: LD_INT 3
39590: PUSH
39591: LD_INT 24
39593: PUSH
39594: LD_INT 1000
39596: PUSH
39597: EMPTY
39598: LIST
39599: LIST
39600: PUSH
39601: EMPTY
39602: LIST
39603: LIST
39604: PUSH
39605: EMPTY
39606: LIST
39607: LIST
39608: LIST
39609: LIST
39610: PPUSH
39611: CALL_OW 70
39615: ST_TO_ADDR
// for j in fac do
39616: LD_ADDR_VAR 0 3
39620: PUSH
39621: LD_VAR 0 6
39625: PUSH
39626: FOR_IN
39627: IFFALSE 39722
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
39629: LD_ADDR_VAR 0 7
39633: PUSH
39634: LD_VAR 0 7
39638: PUSH
39639: LD_INT 22
39641: PUSH
39642: LD_VAR 0 5
39646: PUSH
39647: EMPTY
39648: LIST
39649: LIST
39650: PUSH
39651: LD_INT 91
39653: PUSH
39654: LD_VAR 0 3
39658: PUSH
39659: LD_INT 15
39661: PUSH
39662: EMPTY
39663: LIST
39664: LIST
39665: LIST
39666: PUSH
39667: LD_INT 21
39669: PUSH
39670: LD_INT 2
39672: PUSH
39673: EMPTY
39674: LIST
39675: LIST
39676: PUSH
39677: LD_INT 3
39679: PUSH
39680: LD_INT 60
39682: PUSH
39683: EMPTY
39684: LIST
39685: PUSH
39686: EMPTY
39687: LIST
39688: LIST
39689: PUSH
39690: LD_INT 3
39692: PUSH
39693: LD_INT 24
39695: PUSH
39696: LD_INT 1000
39698: PUSH
39699: EMPTY
39700: LIST
39701: LIST
39702: PUSH
39703: EMPTY
39704: LIST
39705: LIST
39706: PUSH
39707: EMPTY
39708: LIST
39709: LIST
39710: LIST
39711: LIST
39712: LIST
39713: PPUSH
39714: CALL_OW 69
39718: UNION
39719: ST_TO_ADDR
39720: GO 39626
39722: POP
39723: POP
// if not vehs then
39724: LD_VAR 0 7
39728: NOT
39729: IFFALSE 39755
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
39731: LD_ADDR_EXP 89
39735: PUSH
39736: LD_EXP 89
39740: PPUSH
39741: LD_VAR 0 2
39745: PPUSH
39746: EMPTY
39747: PPUSH
39748: CALL_OW 1
39752: ST_TO_ADDR
// continue ;
39753: GO 39385
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
39755: LD_ADDR_VAR 0 8
39759: PUSH
39760: LD_EXP 77
39764: PUSH
39765: LD_VAR 0 2
39769: ARRAY
39770: PPUSH
39771: LD_INT 30
39773: PUSH
39774: LD_INT 3
39776: PUSH
39777: EMPTY
39778: LIST
39779: LIST
39780: PPUSH
39781: CALL_OW 72
39785: ST_TO_ADDR
// if tmp then
39786: LD_VAR 0 8
39790: IFFALSE 39893
// begin for j in tmp do
39792: LD_ADDR_VAR 0 3
39796: PUSH
39797: LD_VAR 0 8
39801: PUSH
39802: FOR_IN
39803: IFFALSE 39891
// for k in UnitsInside ( j ) do
39805: LD_ADDR_VAR 0 4
39809: PUSH
39810: LD_VAR 0 3
39814: PPUSH
39815: CALL_OW 313
39819: PUSH
39820: FOR_IN
39821: IFFALSE 39887
// if k then
39823: LD_VAR 0 4
39827: IFFALSE 39885
// if not k in mc_repair_vehicle [ i ] then
39829: LD_VAR 0 4
39833: PUSH
39834: LD_EXP 89
39838: PUSH
39839: LD_VAR 0 2
39843: ARRAY
39844: IN
39845: NOT
39846: IFFALSE 39885
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
39848: LD_ADDR_EXP 89
39852: PUSH
39853: LD_EXP 89
39857: PPUSH
39858: LD_VAR 0 2
39862: PPUSH
39863: LD_EXP 89
39867: PUSH
39868: LD_VAR 0 2
39872: ARRAY
39873: PUSH
39874: LD_VAR 0 4
39878: UNION
39879: PPUSH
39880: CALL_OW 1
39884: ST_TO_ADDR
39885: GO 39820
39887: POP
39888: POP
39889: GO 39802
39891: POP
39892: POP
// end ; if not mc_repair_vehicle [ i ] then
39893: LD_EXP 89
39897: PUSH
39898: LD_VAR 0 2
39902: ARRAY
39903: NOT
39904: IFFALSE 39908
// continue ;
39906: GO 39385
// for j in mc_repair_vehicle [ i ] do
39908: LD_ADDR_VAR 0 3
39912: PUSH
39913: LD_EXP 89
39917: PUSH
39918: LD_VAR 0 2
39922: ARRAY
39923: PUSH
39924: FOR_IN
39925: IFFALSE 40102
// begin if GetClass ( j ) <> 3 then
39927: LD_VAR 0 3
39931: PPUSH
39932: CALL_OW 257
39936: PUSH
39937: LD_INT 3
39939: NONEQUAL
39940: IFFALSE 39981
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
39942: LD_ADDR_EXP 89
39946: PUSH
39947: LD_EXP 89
39951: PPUSH
39952: LD_VAR 0 2
39956: PPUSH
39957: LD_EXP 89
39961: PUSH
39962: LD_VAR 0 2
39966: ARRAY
39967: PUSH
39968: LD_VAR 0 3
39972: DIFF
39973: PPUSH
39974: CALL_OW 1
39978: ST_TO_ADDR
// continue ;
39979: GO 39924
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
39981: LD_VAR 0 3
39985: PPUSH
39986: CALL_OW 311
39990: NOT
39991: PUSH
39992: LD_VAR 0 3
39996: PUSH
39997: LD_EXP 80
40001: PUSH
40002: LD_VAR 0 2
40006: ARRAY
40007: PUSH
40008: LD_INT 1
40010: ARRAY
40011: IN
40012: NOT
40013: AND
40014: PUSH
40015: LD_VAR 0 3
40019: PUSH
40020: LD_EXP 80
40024: PUSH
40025: LD_VAR 0 2
40029: ARRAY
40030: PUSH
40031: LD_INT 2
40033: ARRAY
40034: IN
40035: NOT
40036: AND
40037: IFFALSE 40100
// begin if IsInUnit ( j ) then
40039: LD_VAR 0 3
40043: PPUSH
40044: CALL_OW 310
40048: IFFALSE 40061
// ComExitBuilding ( j ) else
40050: LD_VAR 0 3
40054: PPUSH
40055: CALL_OW 122
40059: GO 40100
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
40061: LD_VAR 0 3
40065: PPUSH
40066: LD_VAR 0 7
40070: PUSH
40071: LD_INT 1
40073: ARRAY
40074: PPUSH
40075: CALL 91595 0 2
40079: NOT
40080: IFFALSE 40100
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
40082: LD_VAR 0 3
40086: PPUSH
40087: LD_VAR 0 7
40091: PUSH
40092: LD_INT 1
40094: ARRAY
40095: PPUSH
40096: CALL_OW 129
// end ; end ;
40100: GO 39924
40102: POP
40103: POP
// end ;
40104: GO 39385
40106: POP
40107: POP
// end ;
40108: LD_VAR 0 1
40112: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
40113: LD_INT 0
40115: PPUSH
40116: PPUSH
40117: PPUSH
40118: PPUSH
40119: PPUSH
40120: PPUSH
40121: PPUSH
40122: PPUSH
40123: PPUSH
40124: PPUSH
40125: PPUSH
// if not mc_bases then
40126: LD_EXP 77
40130: NOT
40131: IFFALSE 40135
// exit ;
40133: GO 40937
// for i = 1 to mc_bases do
40135: LD_ADDR_VAR 0 2
40139: PUSH
40140: DOUBLE
40141: LD_INT 1
40143: DEC
40144: ST_TO_ADDR
40145: LD_EXP 77
40149: PUSH
40150: FOR_TO
40151: IFFALSE 40935
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
40153: LD_EXP 105
40157: PUSH
40158: LD_VAR 0 2
40162: ARRAY
40163: NOT
40164: PUSH
40165: LD_EXP 80
40169: PUSH
40170: LD_VAR 0 2
40174: ARRAY
40175: PUSH
40176: LD_INT 1
40178: ARRAY
40179: OR
40180: PUSH
40181: LD_EXP 80
40185: PUSH
40186: LD_VAR 0 2
40190: ARRAY
40191: PUSH
40192: LD_INT 2
40194: ARRAY
40195: OR
40196: PUSH
40197: LD_EXP 103
40201: PUSH
40202: LD_VAR 0 2
40206: ARRAY
40207: PPUSH
40208: LD_INT 1
40210: PPUSH
40211: CALL_OW 325
40215: NOT
40216: OR
40217: PUSH
40218: LD_EXP 100
40222: PUSH
40223: LD_VAR 0 2
40227: ARRAY
40228: OR
40229: IFFALSE 40233
// continue ;
40231: GO 40150
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
40233: LD_ADDR_VAR 0 8
40237: PUSH
40238: LD_EXP 77
40242: PUSH
40243: LD_VAR 0 2
40247: ARRAY
40248: PPUSH
40249: LD_INT 25
40251: PUSH
40252: LD_INT 4
40254: PUSH
40255: EMPTY
40256: LIST
40257: LIST
40258: PUSH
40259: LD_INT 50
40261: PUSH
40262: EMPTY
40263: LIST
40264: PUSH
40265: LD_INT 3
40267: PUSH
40268: LD_INT 60
40270: PUSH
40271: EMPTY
40272: LIST
40273: PUSH
40274: EMPTY
40275: LIST
40276: LIST
40277: PUSH
40278: EMPTY
40279: LIST
40280: LIST
40281: LIST
40282: PPUSH
40283: CALL_OW 72
40287: PUSH
40288: LD_EXP 81
40292: PUSH
40293: LD_VAR 0 2
40297: ARRAY
40298: DIFF
40299: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40300: LD_ADDR_VAR 0 9
40304: PUSH
40305: LD_EXP 77
40309: PUSH
40310: LD_VAR 0 2
40314: ARRAY
40315: PPUSH
40316: LD_INT 2
40318: PUSH
40319: LD_INT 30
40321: PUSH
40322: LD_INT 0
40324: PUSH
40325: EMPTY
40326: LIST
40327: LIST
40328: PUSH
40329: LD_INT 30
40331: PUSH
40332: LD_INT 1
40334: PUSH
40335: EMPTY
40336: LIST
40337: LIST
40338: PUSH
40339: EMPTY
40340: LIST
40341: LIST
40342: LIST
40343: PPUSH
40344: CALL_OW 72
40348: ST_TO_ADDR
// if not tmp or not dep then
40349: LD_VAR 0 8
40353: NOT
40354: PUSH
40355: LD_VAR 0 9
40359: NOT
40360: OR
40361: IFFALSE 40365
// continue ;
40363: GO 40150
// side := GetSide ( tmp [ 1 ] ) ;
40365: LD_ADDR_VAR 0 11
40369: PUSH
40370: LD_VAR 0 8
40374: PUSH
40375: LD_INT 1
40377: ARRAY
40378: PPUSH
40379: CALL_OW 255
40383: ST_TO_ADDR
// dep := dep [ 1 ] ;
40384: LD_ADDR_VAR 0 9
40388: PUSH
40389: LD_VAR 0 9
40393: PUSH
40394: LD_INT 1
40396: ARRAY
40397: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
40398: LD_ADDR_VAR 0 7
40402: PUSH
40403: LD_EXP 105
40407: PUSH
40408: LD_VAR 0 2
40412: ARRAY
40413: PPUSH
40414: LD_INT 22
40416: PUSH
40417: LD_INT 0
40419: PUSH
40420: EMPTY
40421: LIST
40422: LIST
40423: PUSH
40424: LD_INT 25
40426: PUSH
40427: LD_INT 12
40429: PUSH
40430: EMPTY
40431: LIST
40432: LIST
40433: PUSH
40434: EMPTY
40435: LIST
40436: LIST
40437: PPUSH
40438: CALL_OW 70
40442: PUSH
40443: LD_INT 22
40445: PUSH
40446: LD_INT 0
40448: PUSH
40449: EMPTY
40450: LIST
40451: LIST
40452: PUSH
40453: LD_INT 25
40455: PUSH
40456: LD_INT 12
40458: PUSH
40459: EMPTY
40460: LIST
40461: LIST
40462: PUSH
40463: LD_INT 91
40465: PUSH
40466: LD_VAR 0 9
40470: PUSH
40471: LD_INT 20
40473: PUSH
40474: EMPTY
40475: LIST
40476: LIST
40477: LIST
40478: PUSH
40479: EMPTY
40480: LIST
40481: LIST
40482: LIST
40483: PPUSH
40484: CALL_OW 69
40488: UNION
40489: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
40490: LD_ADDR_VAR 0 10
40494: PUSH
40495: LD_EXP 105
40499: PUSH
40500: LD_VAR 0 2
40504: ARRAY
40505: PPUSH
40506: LD_INT 81
40508: PUSH
40509: LD_VAR 0 11
40513: PUSH
40514: EMPTY
40515: LIST
40516: LIST
40517: PPUSH
40518: CALL_OW 70
40522: ST_TO_ADDR
// if not apes or danger_at_area then
40523: LD_VAR 0 7
40527: NOT
40528: PUSH
40529: LD_VAR 0 10
40533: OR
40534: IFFALSE 40584
// begin if mc_taming [ i ] then
40536: LD_EXP 108
40540: PUSH
40541: LD_VAR 0 2
40545: ARRAY
40546: IFFALSE 40582
// begin MC_Reset ( i , 121 ) ;
40548: LD_VAR 0 2
40552: PPUSH
40553: LD_INT 121
40555: PPUSH
40556: CALL 25521 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
40560: LD_ADDR_EXP 108
40564: PUSH
40565: LD_EXP 108
40569: PPUSH
40570: LD_VAR 0 2
40574: PPUSH
40575: EMPTY
40576: PPUSH
40577: CALL_OW 1
40581: ST_TO_ADDR
// end ; continue ;
40582: GO 40150
// end ; for j in tmp do
40584: LD_ADDR_VAR 0 3
40588: PUSH
40589: LD_VAR 0 8
40593: PUSH
40594: FOR_IN
40595: IFFALSE 40931
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
40597: LD_VAR 0 3
40601: PUSH
40602: LD_EXP 108
40606: PUSH
40607: LD_VAR 0 2
40611: ARRAY
40612: IN
40613: NOT
40614: PUSH
40615: LD_EXP 108
40619: PUSH
40620: LD_VAR 0 2
40624: ARRAY
40625: PUSH
40626: LD_INT 3
40628: LESS
40629: AND
40630: IFFALSE 40688
// begin SetTag ( j , 121 ) ;
40632: LD_VAR 0 3
40636: PPUSH
40637: LD_INT 121
40639: PPUSH
40640: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
40644: LD_ADDR_EXP 108
40648: PUSH
40649: LD_EXP 108
40653: PPUSH
40654: LD_VAR 0 2
40658: PUSH
40659: LD_EXP 108
40663: PUSH
40664: LD_VAR 0 2
40668: ARRAY
40669: PUSH
40670: LD_INT 1
40672: PLUS
40673: PUSH
40674: EMPTY
40675: LIST
40676: LIST
40677: PPUSH
40678: LD_VAR 0 3
40682: PPUSH
40683: CALL 57199 0 3
40687: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
40688: LD_VAR 0 3
40692: PUSH
40693: LD_EXP 108
40697: PUSH
40698: LD_VAR 0 2
40702: ARRAY
40703: IN
40704: IFFALSE 40929
// begin if GetClass ( j ) <> 4 then
40706: LD_VAR 0 3
40710: PPUSH
40711: CALL_OW 257
40715: PUSH
40716: LD_INT 4
40718: NONEQUAL
40719: IFFALSE 40772
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
40721: LD_ADDR_EXP 108
40725: PUSH
40726: LD_EXP 108
40730: PPUSH
40731: LD_VAR 0 2
40735: PPUSH
40736: LD_EXP 108
40740: PUSH
40741: LD_VAR 0 2
40745: ARRAY
40746: PUSH
40747: LD_VAR 0 3
40751: DIFF
40752: PPUSH
40753: CALL_OW 1
40757: ST_TO_ADDR
// SetTag ( j , 0 ) ;
40758: LD_VAR 0 3
40762: PPUSH
40763: LD_INT 0
40765: PPUSH
40766: CALL_OW 109
// continue ;
40770: GO 40594
// end ; if IsInUnit ( j ) then
40772: LD_VAR 0 3
40776: PPUSH
40777: CALL_OW 310
40781: IFFALSE 40792
// ComExitBuilding ( j ) ;
40783: LD_VAR 0 3
40787: PPUSH
40788: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
40792: LD_ADDR_VAR 0 6
40796: PUSH
40797: LD_VAR 0 7
40801: PPUSH
40802: LD_VAR 0 3
40806: PPUSH
40807: CALL_OW 74
40811: ST_TO_ADDR
// if not ape then
40812: LD_VAR 0 6
40816: NOT
40817: IFFALSE 40821
// break ;
40819: GO 40931
// x := GetX ( ape ) ;
40821: LD_ADDR_VAR 0 4
40825: PUSH
40826: LD_VAR 0 6
40830: PPUSH
40831: CALL_OW 250
40835: ST_TO_ADDR
// y := GetY ( ape ) ;
40836: LD_ADDR_VAR 0 5
40840: PUSH
40841: LD_VAR 0 6
40845: PPUSH
40846: CALL_OW 251
40850: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
40851: LD_VAR 0 4
40855: PPUSH
40856: LD_VAR 0 5
40860: PPUSH
40861: CALL_OW 488
40865: NOT
40866: PUSH
40867: LD_VAR 0 11
40871: PPUSH
40872: LD_VAR 0 4
40876: PPUSH
40877: LD_VAR 0 5
40881: PPUSH
40882: LD_INT 20
40884: PPUSH
40885: CALL 58095 0 4
40889: PUSH
40890: LD_INT 4
40892: ARRAY
40893: OR
40894: IFFALSE 40898
// break ;
40896: GO 40931
// if not HasTask ( j ) then
40898: LD_VAR 0 3
40902: PPUSH
40903: CALL_OW 314
40907: NOT
40908: IFFALSE 40929
// ComTameXY ( j , x , y ) ;
40910: LD_VAR 0 3
40914: PPUSH
40915: LD_VAR 0 4
40919: PPUSH
40920: LD_VAR 0 5
40924: PPUSH
40925: CALL_OW 131
// end ; end ;
40929: GO 40594
40931: POP
40932: POP
// end ;
40933: GO 40150
40935: POP
40936: POP
// end ;
40937: LD_VAR 0 1
40941: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
40942: LD_INT 0
40944: PPUSH
40945: PPUSH
40946: PPUSH
40947: PPUSH
40948: PPUSH
40949: PPUSH
40950: PPUSH
40951: PPUSH
// if not mc_bases then
40952: LD_EXP 77
40956: NOT
40957: IFFALSE 40961
// exit ;
40959: GO 41587
// for i = 1 to mc_bases do
40961: LD_ADDR_VAR 0 2
40965: PUSH
40966: DOUBLE
40967: LD_INT 1
40969: DEC
40970: ST_TO_ADDR
40971: LD_EXP 77
40975: PUSH
40976: FOR_TO
40977: IFFALSE 41585
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
40979: LD_EXP 106
40983: PUSH
40984: LD_VAR 0 2
40988: ARRAY
40989: NOT
40990: PUSH
40991: LD_EXP 106
40995: PUSH
40996: LD_VAR 0 2
41000: ARRAY
41001: PPUSH
41002: LD_INT 25
41004: PUSH
41005: LD_INT 12
41007: PUSH
41008: EMPTY
41009: LIST
41010: LIST
41011: PPUSH
41012: CALL_OW 72
41016: NOT
41017: OR
41018: IFFALSE 41022
// continue ;
41020: GO 40976
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
41022: LD_ADDR_VAR 0 5
41026: PUSH
41027: LD_EXP 106
41031: PUSH
41032: LD_VAR 0 2
41036: ARRAY
41037: PUSH
41038: LD_INT 1
41040: ARRAY
41041: PPUSH
41042: CALL_OW 255
41046: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
41047: LD_VAR 0 5
41051: PPUSH
41052: LD_INT 2
41054: PPUSH
41055: CALL_OW 325
41059: IFFALSE 41312
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
41061: LD_ADDR_VAR 0 4
41065: PUSH
41066: LD_EXP 106
41070: PUSH
41071: LD_VAR 0 2
41075: ARRAY
41076: PPUSH
41077: LD_INT 25
41079: PUSH
41080: LD_INT 16
41082: PUSH
41083: EMPTY
41084: LIST
41085: LIST
41086: PPUSH
41087: CALL_OW 72
41091: ST_TO_ADDR
// if tmp < 6 then
41092: LD_VAR 0 4
41096: PUSH
41097: LD_INT 6
41099: LESS
41100: IFFALSE 41312
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41102: LD_ADDR_VAR 0 6
41106: PUSH
41107: LD_EXP 77
41111: PUSH
41112: LD_VAR 0 2
41116: ARRAY
41117: PPUSH
41118: LD_INT 2
41120: PUSH
41121: LD_INT 30
41123: PUSH
41124: LD_INT 0
41126: PUSH
41127: EMPTY
41128: LIST
41129: LIST
41130: PUSH
41131: LD_INT 30
41133: PUSH
41134: LD_INT 1
41136: PUSH
41137: EMPTY
41138: LIST
41139: LIST
41140: PUSH
41141: EMPTY
41142: LIST
41143: LIST
41144: LIST
41145: PPUSH
41146: CALL_OW 72
41150: ST_TO_ADDR
// if depot then
41151: LD_VAR 0 6
41155: IFFALSE 41312
// begin selected := 0 ;
41157: LD_ADDR_VAR 0 7
41161: PUSH
41162: LD_INT 0
41164: ST_TO_ADDR
// for j in depot do
41165: LD_ADDR_VAR 0 3
41169: PUSH
41170: LD_VAR 0 6
41174: PUSH
41175: FOR_IN
41176: IFFALSE 41207
// begin if UnitsInside ( j ) < 6 then
41178: LD_VAR 0 3
41182: PPUSH
41183: CALL_OW 313
41187: PUSH
41188: LD_INT 6
41190: LESS
41191: IFFALSE 41205
// begin selected := j ;
41193: LD_ADDR_VAR 0 7
41197: PUSH
41198: LD_VAR 0 3
41202: ST_TO_ADDR
// break ;
41203: GO 41207
// end ; end ;
41205: GO 41175
41207: POP
41208: POP
// if selected then
41209: LD_VAR 0 7
41213: IFFALSE 41312
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
41215: LD_ADDR_VAR 0 3
41219: PUSH
41220: LD_EXP 106
41224: PUSH
41225: LD_VAR 0 2
41229: ARRAY
41230: PPUSH
41231: LD_INT 25
41233: PUSH
41234: LD_INT 12
41236: PUSH
41237: EMPTY
41238: LIST
41239: LIST
41240: PPUSH
41241: CALL_OW 72
41245: PUSH
41246: FOR_IN
41247: IFFALSE 41310
// if not HasTask ( j ) then
41249: LD_VAR 0 3
41253: PPUSH
41254: CALL_OW 314
41258: NOT
41259: IFFALSE 41308
// begin if not IsInUnit ( j ) then
41261: LD_VAR 0 3
41265: PPUSH
41266: CALL_OW 310
41270: NOT
41271: IFFALSE 41287
// ComEnterUnit ( j , selected ) ;
41273: LD_VAR 0 3
41277: PPUSH
41278: LD_VAR 0 7
41282: PPUSH
41283: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
41287: LD_VAR 0 3
41291: PPUSH
41292: LD_INT 16
41294: PPUSH
41295: CALL_OW 183
// AddComExitBuilding ( j ) ;
41299: LD_VAR 0 3
41303: PPUSH
41304: CALL_OW 182
// end ;
41308: GO 41246
41310: POP
41311: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
41312: LD_VAR 0 5
41316: PPUSH
41317: LD_INT 11
41319: PPUSH
41320: CALL_OW 325
41324: IFFALSE 41583
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
41326: LD_ADDR_VAR 0 4
41330: PUSH
41331: LD_EXP 106
41335: PUSH
41336: LD_VAR 0 2
41340: ARRAY
41341: PPUSH
41342: LD_INT 25
41344: PUSH
41345: LD_INT 16
41347: PUSH
41348: EMPTY
41349: LIST
41350: LIST
41351: PPUSH
41352: CALL_OW 72
41356: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
41357: LD_VAR 0 4
41361: PUSH
41362: LD_INT 6
41364: GREATEREQUAL
41365: PUSH
41366: LD_VAR 0 5
41370: PPUSH
41371: LD_INT 2
41373: PPUSH
41374: CALL_OW 325
41378: NOT
41379: OR
41380: IFFALSE 41583
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
41382: LD_ADDR_VAR 0 8
41386: PUSH
41387: LD_EXP 77
41391: PUSH
41392: LD_VAR 0 2
41396: ARRAY
41397: PPUSH
41398: LD_INT 2
41400: PUSH
41401: LD_INT 30
41403: PUSH
41404: LD_INT 4
41406: PUSH
41407: EMPTY
41408: LIST
41409: LIST
41410: PUSH
41411: LD_INT 30
41413: PUSH
41414: LD_INT 5
41416: PUSH
41417: EMPTY
41418: LIST
41419: LIST
41420: PUSH
41421: EMPTY
41422: LIST
41423: LIST
41424: LIST
41425: PPUSH
41426: CALL_OW 72
41430: ST_TO_ADDR
// if barracks then
41431: LD_VAR 0 8
41435: IFFALSE 41583
// begin selected := 0 ;
41437: LD_ADDR_VAR 0 7
41441: PUSH
41442: LD_INT 0
41444: ST_TO_ADDR
// for j in barracks do
41445: LD_ADDR_VAR 0 3
41449: PUSH
41450: LD_VAR 0 8
41454: PUSH
41455: FOR_IN
41456: IFFALSE 41487
// begin if UnitsInside ( j ) < 6 then
41458: LD_VAR 0 3
41462: PPUSH
41463: CALL_OW 313
41467: PUSH
41468: LD_INT 6
41470: LESS
41471: IFFALSE 41485
// begin selected := j ;
41473: LD_ADDR_VAR 0 7
41477: PUSH
41478: LD_VAR 0 3
41482: ST_TO_ADDR
// break ;
41483: GO 41487
// end ; end ;
41485: GO 41455
41487: POP
41488: POP
// if selected then
41489: LD_VAR 0 7
41493: IFFALSE 41583
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
41495: LD_ADDR_VAR 0 3
41499: PUSH
41500: LD_EXP 106
41504: PUSH
41505: LD_VAR 0 2
41509: ARRAY
41510: PPUSH
41511: LD_INT 25
41513: PUSH
41514: LD_INT 12
41516: PUSH
41517: EMPTY
41518: LIST
41519: LIST
41520: PPUSH
41521: CALL_OW 72
41525: PUSH
41526: FOR_IN
41527: IFFALSE 41581
// if not IsInUnit ( j ) and not HasTask ( j ) then
41529: LD_VAR 0 3
41533: PPUSH
41534: CALL_OW 310
41538: NOT
41539: PUSH
41540: LD_VAR 0 3
41544: PPUSH
41545: CALL_OW 314
41549: NOT
41550: AND
41551: IFFALSE 41579
// begin ComEnterUnit ( j , selected ) ;
41553: LD_VAR 0 3
41557: PPUSH
41558: LD_VAR 0 7
41562: PPUSH
41563: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
41567: LD_VAR 0 3
41571: PPUSH
41572: LD_INT 15
41574: PPUSH
41575: CALL_OW 183
// end ;
41579: GO 41526
41581: POP
41582: POP
// end ; end ; end ; end ; end ;
41583: GO 40976
41585: POP
41586: POP
// end ;
41587: LD_VAR 0 1
41591: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
41592: LD_INT 0
41594: PPUSH
41595: PPUSH
41596: PPUSH
41597: PPUSH
// if not mc_bases then
41598: LD_EXP 77
41602: NOT
41603: IFFALSE 41607
// exit ;
41605: GO 41785
// for i = 1 to mc_bases do
41607: LD_ADDR_VAR 0 2
41611: PUSH
41612: DOUBLE
41613: LD_INT 1
41615: DEC
41616: ST_TO_ADDR
41617: LD_EXP 77
41621: PUSH
41622: FOR_TO
41623: IFFALSE 41783
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
41625: LD_ADDR_VAR 0 4
41629: PUSH
41630: LD_EXP 77
41634: PUSH
41635: LD_VAR 0 2
41639: ARRAY
41640: PPUSH
41641: LD_INT 25
41643: PUSH
41644: LD_INT 9
41646: PUSH
41647: EMPTY
41648: LIST
41649: LIST
41650: PPUSH
41651: CALL_OW 72
41655: ST_TO_ADDR
// if not tmp then
41656: LD_VAR 0 4
41660: NOT
41661: IFFALSE 41665
// continue ;
41663: GO 41622
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
41665: LD_EXP 103
41669: PUSH
41670: LD_VAR 0 2
41674: ARRAY
41675: PPUSH
41676: LD_INT 29
41678: PPUSH
41679: CALL_OW 325
41683: NOT
41684: PUSH
41685: LD_EXP 103
41689: PUSH
41690: LD_VAR 0 2
41694: ARRAY
41695: PPUSH
41696: LD_INT 28
41698: PPUSH
41699: CALL_OW 325
41703: NOT
41704: AND
41705: IFFALSE 41709
// continue ;
41707: GO 41622
// for j in tmp do
41709: LD_ADDR_VAR 0 3
41713: PUSH
41714: LD_VAR 0 4
41718: PUSH
41719: FOR_IN
41720: IFFALSE 41779
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
41722: LD_VAR 0 3
41726: PUSH
41727: LD_EXP 80
41731: PUSH
41732: LD_VAR 0 2
41736: ARRAY
41737: PUSH
41738: LD_INT 1
41740: ARRAY
41741: IN
41742: NOT
41743: PUSH
41744: LD_VAR 0 3
41748: PUSH
41749: LD_EXP 80
41753: PUSH
41754: LD_VAR 0 2
41758: ARRAY
41759: PUSH
41760: LD_INT 2
41762: ARRAY
41763: IN
41764: NOT
41765: AND
41766: IFFALSE 41777
// ComSpaceTimeShoot ( j ) ;
41768: LD_VAR 0 3
41772: PPUSH
41773: CALL 53009 0 1
41777: GO 41719
41779: POP
41780: POP
// end ;
41781: GO 41622
41783: POP
41784: POP
// end ;
41785: LD_VAR 0 1
41789: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
41790: LD_INT 0
41792: PPUSH
41793: PPUSH
41794: PPUSH
41795: PPUSH
41796: PPUSH
41797: PPUSH
41798: PPUSH
41799: PPUSH
41800: PPUSH
// if not mc_bases then
41801: LD_EXP 77
41805: NOT
41806: IFFALSE 41810
// exit ;
41808: GO 42432
// for i = 1 to mc_bases do
41810: LD_ADDR_VAR 0 2
41814: PUSH
41815: DOUBLE
41816: LD_INT 1
41818: DEC
41819: ST_TO_ADDR
41820: LD_EXP 77
41824: PUSH
41825: FOR_TO
41826: IFFALSE 42430
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
41828: LD_EXP 112
41832: PUSH
41833: LD_VAR 0 2
41837: ARRAY
41838: NOT
41839: PUSH
41840: LD_INT 38
41842: PPUSH
41843: LD_EXP 103
41847: PUSH
41848: LD_VAR 0 2
41852: ARRAY
41853: PPUSH
41854: CALL_OW 321
41858: PUSH
41859: LD_INT 2
41861: NONEQUAL
41862: OR
41863: IFFALSE 41867
// continue ;
41865: GO 41825
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
41867: LD_ADDR_VAR 0 8
41871: PUSH
41872: LD_EXP 77
41876: PUSH
41877: LD_VAR 0 2
41881: ARRAY
41882: PPUSH
41883: LD_INT 30
41885: PUSH
41886: LD_INT 34
41888: PUSH
41889: EMPTY
41890: LIST
41891: LIST
41892: PPUSH
41893: CALL_OW 72
41897: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
41898: LD_ADDR_VAR 0 9
41902: PUSH
41903: LD_EXP 77
41907: PUSH
41908: LD_VAR 0 2
41912: ARRAY
41913: PPUSH
41914: LD_INT 25
41916: PUSH
41917: LD_INT 4
41919: PUSH
41920: EMPTY
41921: LIST
41922: LIST
41923: PPUSH
41924: CALL_OW 72
41928: PPUSH
41929: LD_INT 0
41931: PPUSH
41932: CALL 87111 0 2
41936: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
41937: LD_VAR 0 9
41941: NOT
41942: PUSH
41943: LD_VAR 0 8
41947: NOT
41948: OR
41949: PUSH
41950: LD_EXP 77
41954: PUSH
41955: LD_VAR 0 2
41959: ARRAY
41960: PPUSH
41961: LD_INT 124
41963: PPUSH
41964: CALL 87111 0 2
41968: OR
41969: IFFALSE 41973
// continue ;
41971: GO 41825
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
41973: LD_EXP 113
41977: PUSH
41978: LD_VAR 0 2
41982: ARRAY
41983: PUSH
41984: LD_EXP 112
41988: PUSH
41989: LD_VAR 0 2
41993: ARRAY
41994: LESS
41995: PUSH
41996: LD_EXP 113
42000: PUSH
42001: LD_VAR 0 2
42005: ARRAY
42006: PUSH
42007: LD_VAR 0 8
42011: LESS
42012: AND
42013: IFFALSE 42428
// begin tmp := sci [ 1 ] ;
42015: LD_ADDR_VAR 0 7
42019: PUSH
42020: LD_VAR 0 9
42024: PUSH
42025: LD_INT 1
42027: ARRAY
42028: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
42029: LD_VAR 0 7
42033: PPUSH
42034: LD_INT 124
42036: PPUSH
42037: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
42041: LD_ADDR_VAR 0 3
42045: PUSH
42046: DOUBLE
42047: LD_EXP 112
42051: PUSH
42052: LD_VAR 0 2
42056: ARRAY
42057: INC
42058: ST_TO_ADDR
42059: LD_EXP 112
42063: PUSH
42064: LD_VAR 0 2
42068: ARRAY
42069: PUSH
42070: FOR_DOWNTO
42071: IFFALSE 42414
// begin if IsInUnit ( tmp ) then
42073: LD_VAR 0 7
42077: PPUSH
42078: CALL_OW 310
42082: IFFALSE 42093
// ComExitBuilding ( tmp ) ;
42084: LD_VAR 0 7
42088: PPUSH
42089: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
42093: LD_INT 35
42095: PPUSH
42096: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
42100: LD_VAR 0 7
42104: PPUSH
42105: CALL_OW 310
42109: NOT
42110: PUSH
42111: LD_VAR 0 7
42115: PPUSH
42116: CALL_OW 314
42120: NOT
42121: AND
42122: IFFALSE 42093
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
42124: LD_ADDR_VAR 0 6
42128: PUSH
42129: LD_VAR 0 7
42133: PPUSH
42134: CALL_OW 250
42138: PUSH
42139: LD_VAR 0 7
42143: PPUSH
42144: CALL_OW 251
42148: PUSH
42149: EMPTY
42150: LIST
42151: LIST
42152: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
42153: LD_INT 35
42155: PPUSH
42156: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
42160: LD_ADDR_VAR 0 4
42164: PUSH
42165: LD_EXP 112
42169: PUSH
42170: LD_VAR 0 2
42174: ARRAY
42175: PUSH
42176: LD_VAR 0 3
42180: ARRAY
42181: PUSH
42182: LD_INT 1
42184: ARRAY
42185: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
42186: LD_ADDR_VAR 0 5
42190: PUSH
42191: LD_EXP 112
42195: PUSH
42196: LD_VAR 0 2
42200: ARRAY
42201: PUSH
42202: LD_VAR 0 3
42206: ARRAY
42207: PUSH
42208: LD_INT 2
42210: ARRAY
42211: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
42212: LD_VAR 0 7
42216: PPUSH
42217: LD_INT 10
42219: PPUSH
42220: CALL 59796 0 2
42224: PUSH
42225: LD_INT 4
42227: ARRAY
42228: IFFALSE 42266
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
42230: LD_VAR 0 7
42234: PPUSH
42235: LD_VAR 0 6
42239: PUSH
42240: LD_INT 1
42242: ARRAY
42243: PPUSH
42244: LD_VAR 0 6
42248: PUSH
42249: LD_INT 2
42251: ARRAY
42252: PPUSH
42253: CALL_OW 111
// wait ( 0 0$10 ) ;
42257: LD_INT 350
42259: PPUSH
42260: CALL_OW 67
// end else
42264: GO 42292
// begin ComMoveXY ( tmp , x , y ) ;
42266: LD_VAR 0 7
42270: PPUSH
42271: LD_VAR 0 4
42275: PPUSH
42276: LD_VAR 0 5
42280: PPUSH
42281: CALL_OW 111
// wait ( 0 0$3 ) ;
42285: LD_INT 105
42287: PPUSH
42288: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
42292: LD_VAR 0 7
42296: PPUSH
42297: LD_VAR 0 4
42301: PPUSH
42302: LD_VAR 0 5
42306: PPUSH
42307: CALL_OW 307
42311: IFFALSE 42153
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
42313: LD_VAR 0 7
42317: PPUSH
42318: LD_VAR 0 4
42322: PPUSH
42323: LD_VAR 0 5
42327: PPUSH
42328: LD_VAR 0 8
42332: PUSH
42333: LD_VAR 0 3
42337: ARRAY
42338: PPUSH
42339: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
42343: LD_INT 35
42345: PPUSH
42346: CALL_OW 67
// until not HasTask ( tmp ) ;
42350: LD_VAR 0 7
42354: PPUSH
42355: CALL_OW 314
42359: NOT
42360: IFFALSE 42343
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
42362: LD_ADDR_EXP 113
42366: PUSH
42367: LD_EXP 113
42371: PPUSH
42372: LD_VAR 0 2
42376: PUSH
42377: LD_EXP 113
42381: PUSH
42382: LD_VAR 0 2
42386: ARRAY
42387: PUSH
42388: LD_INT 1
42390: PLUS
42391: PUSH
42392: EMPTY
42393: LIST
42394: LIST
42395: PPUSH
42396: LD_VAR 0 8
42400: PUSH
42401: LD_VAR 0 3
42405: ARRAY
42406: PPUSH
42407: CALL 57199 0 3
42411: ST_TO_ADDR
// end ;
42412: GO 42070
42414: POP
42415: POP
// MC_Reset ( i , 124 ) ;
42416: LD_VAR 0 2
42420: PPUSH
42421: LD_INT 124
42423: PPUSH
42424: CALL 25521 0 2
// end ; end ;
42428: GO 41825
42430: POP
42431: POP
// end ;
42432: LD_VAR 0 1
42436: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
42437: LD_INT 0
42439: PPUSH
42440: PPUSH
42441: PPUSH
// if not mc_bases then
42442: LD_EXP 77
42446: NOT
42447: IFFALSE 42451
// exit ;
42449: GO 43057
// for i = 1 to mc_bases do
42451: LD_ADDR_VAR 0 2
42455: PUSH
42456: DOUBLE
42457: LD_INT 1
42459: DEC
42460: ST_TO_ADDR
42461: LD_EXP 77
42465: PUSH
42466: FOR_TO
42467: IFFALSE 43055
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
42469: LD_ADDR_VAR 0 3
42473: PUSH
42474: LD_EXP 77
42478: PUSH
42479: LD_VAR 0 2
42483: ARRAY
42484: PPUSH
42485: LD_INT 25
42487: PUSH
42488: LD_INT 4
42490: PUSH
42491: EMPTY
42492: LIST
42493: LIST
42494: PPUSH
42495: CALL_OW 72
42499: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
42500: LD_VAR 0 3
42504: NOT
42505: PUSH
42506: LD_EXP 114
42510: PUSH
42511: LD_VAR 0 2
42515: ARRAY
42516: NOT
42517: OR
42518: PUSH
42519: LD_EXP 77
42523: PUSH
42524: LD_VAR 0 2
42528: ARRAY
42529: PPUSH
42530: LD_INT 2
42532: PUSH
42533: LD_INT 30
42535: PUSH
42536: LD_INT 0
42538: PUSH
42539: EMPTY
42540: LIST
42541: LIST
42542: PUSH
42543: LD_INT 30
42545: PUSH
42546: LD_INT 1
42548: PUSH
42549: EMPTY
42550: LIST
42551: LIST
42552: PUSH
42553: EMPTY
42554: LIST
42555: LIST
42556: LIST
42557: PPUSH
42558: CALL_OW 72
42562: NOT
42563: OR
42564: IFFALSE 42614
// begin if mc_deposits_finder [ i ] then
42566: LD_EXP 115
42570: PUSH
42571: LD_VAR 0 2
42575: ARRAY
42576: IFFALSE 42612
// begin MC_Reset ( i , 125 ) ;
42578: LD_VAR 0 2
42582: PPUSH
42583: LD_INT 125
42585: PPUSH
42586: CALL 25521 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
42590: LD_ADDR_EXP 115
42594: PUSH
42595: LD_EXP 115
42599: PPUSH
42600: LD_VAR 0 2
42604: PPUSH
42605: EMPTY
42606: PPUSH
42607: CALL_OW 1
42611: ST_TO_ADDR
// end ; continue ;
42612: GO 42466
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
42614: LD_EXP 114
42618: PUSH
42619: LD_VAR 0 2
42623: ARRAY
42624: PUSH
42625: LD_INT 1
42627: ARRAY
42628: PUSH
42629: LD_INT 3
42631: ARRAY
42632: PUSH
42633: LD_INT 1
42635: EQUAL
42636: PUSH
42637: LD_INT 20
42639: PPUSH
42640: LD_EXP 103
42644: PUSH
42645: LD_VAR 0 2
42649: ARRAY
42650: PPUSH
42651: CALL_OW 321
42655: PUSH
42656: LD_INT 2
42658: NONEQUAL
42659: AND
42660: IFFALSE 42710
// begin if mc_deposits_finder [ i ] then
42662: LD_EXP 115
42666: PUSH
42667: LD_VAR 0 2
42671: ARRAY
42672: IFFALSE 42708
// begin MC_Reset ( i , 125 ) ;
42674: LD_VAR 0 2
42678: PPUSH
42679: LD_INT 125
42681: PPUSH
42682: CALL 25521 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
42686: LD_ADDR_EXP 115
42690: PUSH
42691: LD_EXP 115
42695: PPUSH
42696: LD_VAR 0 2
42700: PPUSH
42701: EMPTY
42702: PPUSH
42703: CALL_OW 1
42707: ST_TO_ADDR
// end ; continue ;
42708: GO 42466
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
42710: LD_EXP 114
42714: PUSH
42715: LD_VAR 0 2
42719: ARRAY
42720: PUSH
42721: LD_INT 1
42723: ARRAY
42724: PUSH
42725: LD_INT 1
42727: ARRAY
42728: PPUSH
42729: LD_EXP 114
42733: PUSH
42734: LD_VAR 0 2
42738: ARRAY
42739: PUSH
42740: LD_INT 1
42742: ARRAY
42743: PUSH
42744: LD_INT 2
42746: ARRAY
42747: PPUSH
42748: LD_EXP 103
42752: PUSH
42753: LD_VAR 0 2
42757: ARRAY
42758: PPUSH
42759: CALL_OW 440
42763: IFFALSE 42806
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
42765: LD_ADDR_EXP 114
42769: PUSH
42770: LD_EXP 114
42774: PPUSH
42775: LD_VAR 0 2
42779: PPUSH
42780: LD_EXP 114
42784: PUSH
42785: LD_VAR 0 2
42789: ARRAY
42790: PPUSH
42791: LD_INT 1
42793: PPUSH
42794: CALL_OW 3
42798: PPUSH
42799: CALL_OW 1
42803: ST_TO_ADDR
42804: GO 43053
// begin if not mc_deposits_finder [ i ] then
42806: LD_EXP 115
42810: PUSH
42811: LD_VAR 0 2
42815: ARRAY
42816: NOT
42817: IFFALSE 42869
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
42819: LD_ADDR_EXP 115
42823: PUSH
42824: LD_EXP 115
42828: PPUSH
42829: LD_VAR 0 2
42833: PPUSH
42834: LD_VAR 0 3
42838: PUSH
42839: LD_INT 1
42841: ARRAY
42842: PUSH
42843: EMPTY
42844: LIST
42845: PPUSH
42846: CALL_OW 1
42850: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
42851: LD_VAR 0 3
42855: PUSH
42856: LD_INT 1
42858: ARRAY
42859: PPUSH
42860: LD_INT 125
42862: PPUSH
42863: CALL_OW 109
// end else
42867: GO 43053
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
42869: LD_EXP 115
42873: PUSH
42874: LD_VAR 0 2
42878: ARRAY
42879: PUSH
42880: LD_INT 1
42882: ARRAY
42883: PPUSH
42884: CALL_OW 310
42888: IFFALSE 42911
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
42890: LD_EXP 115
42894: PUSH
42895: LD_VAR 0 2
42899: ARRAY
42900: PUSH
42901: LD_INT 1
42903: ARRAY
42904: PPUSH
42905: CALL_OW 122
42909: GO 43053
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
42911: LD_EXP 115
42915: PUSH
42916: LD_VAR 0 2
42920: ARRAY
42921: PUSH
42922: LD_INT 1
42924: ARRAY
42925: PPUSH
42926: CALL_OW 314
42930: NOT
42931: PUSH
42932: LD_EXP 115
42936: PUSH
42937: LD_VAR 0 2
42941: ARRAY
42942: PUSH
42943: LD_INT 1
42945: ARRAY
42946: PPUSH
42947: LD_EXP 114
42951: PUSH
42952: LD_VAR 0 2
42956: ARRAY
42957: PUSH
42958: LD_INT 1
42960: ARRAY
42961: PUSH
42962: LD_INT 1
42964: ARRAY
42965: PPUSH
42966: LD_EXP 114
42970: PUSH
42971: LD_VAR 0 2
42975: ARRAY
42976: PUSH
42977: LD_INT 1
42979: ARRAY
42980: PUSH
42981: LD_INT 2
42983: ARRAY
42984: PPUSH
42985: CALL_OW 297
42989: PUSH
42990: LD_INT 6
42992: GREATER
42993: AND
42994: IFFALSE 43053
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
42996: LD_EXP 115
43000: PUSH
43001: LD_VAR 0 2
43005: ARRAY
43006: PUSH
43007: LD_INT 1
43009: ARRAY
43010: PPUSH
43011: LD_EXP 114
43015: PUSH
43016: LD_VAR 0 2
43020: ARRAY
43021: PUSH
43022: LD_INT 1
43024: ARRAY
43025: PUSH
43026: LD_INT 1
43028: ARRAY
43029: PPUSH
43030: LD_EXP 114
43034: PUSH
43035: LD_VAR 0 2
43039: ARRAY
43040: PUSH
43041: LD_INT 1
43043: ARRAY
43044: PUSH
43045: LD_INT 2
43047: ARRAY
43048: PPUSH
43049: CALL_OW 111
// end ; end ; end ;
43053: GO 42466
43055: POP
43056: POP
// end ;
43057: LD_VAR 0 1
43061: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
43062: LD_INT 0
43064: PPUSH
43065: PPUSH
43066: PPUSH
43067: PPUSH
43068: PPUSH
43069: PPUSH
43070: PPUSH
43071: PPUSH
43072: PPUSH
43073: PPUSH
43074: PPUSH
// if not mc_bases then
43075: LD_EXP 77
43079: NOT
43080: IFFALSE 43084
// exit ;
43082: GO 44024
// for i = 1 to mc_bases do
43084: LD_ADDR_VAR 0 2
43088: PUSH
43089: DOUBLE
43090: LD_INT 1
43092: DEC
43093: ST_TO_ADDR
43094: LD_EXP 77
43098: PUSH
43099: FOR_TO
43100: IFFALSE 44022
// begin if not mc_bases [ i ] or mc_scan [ i ] then
43102: LD_EXP 77
43106: PUSH
43107: LD_VAR 0 2
43111: ARRAY
43112: NOT
43113: PUSH
43114: LD_EXP 100
43118: PUSH
43119: LD_VAR 0 2
43123: ARRAY
43124: OR
43125: IFFALSE 43129
// continue ;
43127: GO 43099
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
43129: LD_ADDR_VAR 0 7
43133: PUSH
43134: LD_EXP 77
43138: PUSH
43139: LD_VAR 0 2
43143: ARRAY
43144: PUSH
43145: LD_INT 1
43147: ARRAY
43148: PPUSH
43149: CALL_OW 248
43153: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
43154: LD_VAR 0 7
43158: PUSH
43159: LD_INT 3
43161: EQUAL
43162: PUSH
43163: LD_EXP 96
43167: PUSH
43168: LD_VAR 0 2
43172: ARRAY
43173: PUSH
43174: LD_EXP 99
43178: PUSH
43179: LD_VAR 0 2
43183: ARRAY
43184: UNION
43185: PPUSH
43186: LD_INT 33
43188: PUSH
43189: LD_INT 2
43191: PUSH
43192: EMPTY
43193: LIST
43194: LIST
43195: PPUSH
43196: CALL_OW 72
43200: NOT
43201: OR
43202: IFFALSE 43206
// continue ;
43204: GO 43099
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
43206: LD_ADDR_VAR 0 9
43210: PUSH
43211: LD_EXP 77
43215: PUSH
43216: LD_VAR 0 2
43220: ARRAY
43221: PPUSH
43222: LD_INT 30
43224: PUSH
43225: LD_INT 36
43227: PUSH
43228: EMPTY
43229: LIST
43230: LIST
43231: PPUSH
43232: CALL_OW 72
43236: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
43237: LD_ADDR_VAR 0 10
43241: PUSH
43242: LD_EXP 96
43246: PUSH
43247: LD_VAR 0 2
43251: ARRAY
43252: PPUSH
43253: LD_INT 34
43255: PUSH
43256: LD_INT 31
43258: PUSH
43259: EMPTY
43260: LIST
43261: LIST
43262: PPUSH
43263: CALL_OW 72
43267: ST_TO_ADDR
// if not cts and not mcts then
43268: LD_VAR 0 9
43272: NOT
43273: PUSH
43274: LD_VAR 0 10
43278: NOT
43279: AND
43280: IFFALSE 43284
// continue ;
43282: GO 43099
// x := cts ;
43284: LD_ADDR_VAR 0 11
43288: PUSH
43289: LD_VAR 0 9
43293: ST_TO_ADDR
// if not x then
43294: LD_VAR 0 11
43298: NOT
43299: IFFALSE 43311
// x := mcts ;
43301: LD_ADDR_VAR 0 11
43305: PUSH
43306: LD_VAR 0 10
43310: ST_TO_ADDR
// if not x then
43311: LD_VAR 0 11
43315: NOT
43316: IFFALSE 43320
// continue ;
43318: GO 43099
// if mc_remote_driver [ i ] then
43320: LD_EXP 117
43324: PUSH
43325: LD_VAR 0 2
43329: ARRAY
43330: IFFALSE 43717
// for j in mc_remote_driver [ i ] do
43332: LD_ADDR_VAR 0 3
43336: PUSH
43337: LD_EXP 117
43341: PUSH
43342: LD_VAR 0 2
43346: ARRAY
43347: PUSH
43348: FOR_IN
43349: IFFALSE 43715
// begin if GetClass ( j ) <> 3 then
43351: LD_VAR 0 3
43355: PPUSH
43356: CALL_OW 257
43360: PUSH
43361: LD_INT 3
43363: NONEQUAL
43364: IFFALSE 43417
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
43366: LD_ADDR_EXP 117
43370: PUSH
43371: LD_EXP 117
43375: PPUSH
43376: LD_VAR 0 2
43380: PPUSH
43381: LD_EXP 117
43385: PUSH
43386: LD_VAR 0 2
43390: ARRAY
43391: PUSH
43392: LD_VAR 0 3
43396: DIFF
43397: PPUSH
43398: CALL_OW 1
43402: ST_TO_ADDR
// SetTag ( j , 0 ) ;
43403: LD_VAR 0 3
43407: PPUSH
43408: LD_INT 0
43410: PPUSH
43411: CALL_OW 109
// continue ;
43415: GO 43348
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
43417: LD_EXP 96
43421: PUSH
43422: LD_VAR 0 2
43426: ARRAY
43427: PPUSH
43428: LD_INT 34
43430: PUSH
43431: LD_INT 31
43433: PUSH
43434: EMPTY
43435: LIST
43436: LIST
43437: PUSH
43438: LD_INT 58
43440: PUSH
43441: EMPTY
43442: LIST
43443: PUSH
43444: EMPTY
43445: LIST
43446: LIST
43447: PPUSH
43448: CALL_OW 72
43452: PUSH
43453: LD_VAR 0 3
43457: PPUSH
43458: CALL 87146 0 1
43462: NOT
43463: AND
43464: IFFALSE 43535
// begin if IsInUnit ( j ) then
43466: LD_VAR 0 3
43470: PPUSH
43471: CALL_OW 310
43475: IFFALSE 43486
// ComExitBuilding ( j ) ;
43477: LD_VAR 0 3
43481: PPUSH
43482: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
43486: LD_VAR 0 3
43490: PPUSH
43491: LD_EXP 96
43495: PUSH
43496: LD_VAR 0 2
43500: ARRAY
43501: PPUSH
43502: LD_INT 34
43504: PUSH
43505: LD_INT 31
43507: PUSH
43508: EMPTY
43509: LIST
43510: LIST
43511: PUSH
43512: LD_INT 58
43514: PUSH
43515: EMPTY
43516: LIST
43517: PUSH
43518: EMPTY
43519: LIST
43520: LIST
43521: PPUSH
43522: CALL_OW 72
43526: PUSH
43527: LD_INT 1
43529: ARRAY
43530: PPUSH
43531: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
43535: LD_VAR 0 3
43539: PPUSH
43540: CALL_OW 310
43544: NOT
43545: PUSH
43546: LD_VAR 0 3
43550: PPUSH
43551: CALL_OW 310
43555: PPUSH
43556: CALL_OW 266
43560: PUSH
43561: LD_INT 36
43563: NONEQUAL
43564: PUSH
43565: LD_VAR 0 3
43569: PPUSH
43570: CALL 87146 0 1
43574: NOT
43575: AND
43576: OR
43577: IFFALSE 43713
// begin if IsInUnit ( j ) then
43579: LD_VAR 0 3
43583: PPUSH
43584: CALL_OW 310
43588: IFFALSE 43599
// ComExitBuilding ( j ) ;
43590: LD_VAR 0 3
43594: PPUSH
43595: CALL_OW 122
// ct := 0 ;
43599: LD_ADDR_VAR 0 8
43603: PUSH
43604: LD_INT 0
43606: ST_TO_ADDR
// for k in x do
43607: LD_ADDR_VAR 0 4
43611: PUSH
43612: LD_VAR 0 11
43616: PUSH
43617: FOR_IN
43618: IFFALSE 43691
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
43620: LD_VAR 0 4
43624: PPUSH
43625: CALL_OW 264
43629: PUSH
43630: LD_INT 31
43632: EQUAL
43633: PUSH
43634: LD_VAR 0 4
43638: PPUSH
43639: CALL_OW 311
43643: NOT
43644: AND
43645: PUSH
43646: LD_VAR 0 4
43650: PPUSH
43651: CALL_OW 266
43655: PUSH
43656: LD_INT 36
43658: EQUAL
43659: PUSH
43660: LD_VAR 0 4
43664: PPUSH
43665: CALL_OW 313
43669: PUSH
43670: LD_INT 3
43672: LESS
43673: AND
43674: OR
43675: IFFALSE 43689
// begin ct := k ;
43677: LD_ADDR_VAR 0 8
43681: PUSH
43682: LD_VAR 0 4
43686: ST_TO_ADDR
// break ;
43687: GO 43691
// end ;
43689: GO 43617
43691: POP
43692: POP
// if ct then
43693: LD_VAR 0 8
43697: IFFALSE 43713
// ComEnterUnit ( j , ct ) ;
43699: LD_VAR 0 3
43703: PPUSH
43704: LD_VAR 0 8
43708: PPUSH
43709: CALL_OW 120
// end ; end ;
43713: GO 43348
43715: POP
43716: POP
// places := 0 ;
43717: LD_ADDR_VAR 0 5
43721: PUSH
43722: LD_INT 0
43724: ST_TO_ADDR
// for j = 1 to x do
43725: LD_ADDR_VAR 0 3
43729: PUSH
43730: DOUBLE
43731: LD_INT 1
43733: DEC
43734: ST_TO_ADDR
43735: LD_VAR 0 11
43739: PUSH
43740: FOR_TO
43741: IFFALSE 43817
// if GetWeapon ( x [ j ] ) = ar_control_tower then
43743: LD_VAR 0 11
43747: PUSH
43748: LD_VAR 0 3
43752: ARRAY
43753: PPUSH
43754: CALL_OW 264
43758: PUSH
43759: LD_INT 31
43761: EQUAL
43762: IFFALSE 43780
// places := places + 1 else
43764: LD_ADDR_VAR 0 5
43768: PUSH
43769: LD_VAR 0 5
43773: PUSH
43774: LD_INT 1
43776: PLUS
43777: ST_TO_ADDR
43778: GO 43815
// if GetBType ( x [ j ] ) = b_control_tower then
43780: LD_VAR 0 11
43784: PUSH
43785: LD_VAR 0 3
43789: ARRAY
43790: PPUSH
43791: CALL_OW 266
43795: PUSH
43796: LD_INT 36
43798: EQUAL
43799: IFFALSE 43815
// places := places + 3 ;
43801: LD_ADDR_VAR 0 5
43805: PUSH
43806: LD_VAR 0 5
43810: PUSH
43811: LD_INT 3
43813: PLUS
43814: ST_TO_ADDR
43815: GO 43740
43817: POP
43818: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
43819: LD_VAR 0 5
43823: PUSH
43824: LD_INT 0
43826: EQUAL
43827: PUSH
43828: LD_VAR 0 5
43832: PUSH
43833: LD_EXP 117
43837: PUSH
43838: LD_VAR 0 2
43842: ARRAY
43843: LESSEQUAL
43844: OR
43845: IFFALSE 43849
// continue ;
43847: GO 43099
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
43849: LD_ADDR_VAR 0 6
43853: PUSH
43854: LD_EXP 77
43858: PUSH
43859: LD_VAR 0 2
43863: ARRAY
43864: PPUSH
43865: LD_INT 25
43867: PUSH
43868: LD_INT 3
43870: PUSH
43871: EMPTY
43872: LIST
43873: LIST
43874: PPUSH
43875: CALL_OW 72
43879: PUSH
43880: LD_EXP 117
43884: PUSH
43885: LD_VAR 0 2
43889: ARRAY
43890: DIFF
43891: PPUSH
43892: LD_INT 3
43894: PPUSH
43895: CALL 88046 0 2
43899: ST_TO_ADDR
// for j in tmp do
43900: LD_ADDR_VAR 0 3
43904: PUSH
43905: LD_VAR 0 6
43909: PUSH
43910: FOR_IN
43911: IFFALSE 43946
// if GetTag ( j ) > 0 then
43913: LD_VAR 0 3
43917: PPUSH
43918: CALL_OW 110
43922: PUSH
43923: LD_INT 0
43925: GREATER
43926: IFFALSE 43944
// tmp := tmp diff j ;
43928: LD_ADDR_VAR 0 6
43932: PUSH
43933: LD_VAR 0 6
43937: PUSH
43938: LD_VAR 0 3
43942: DIFF
43943: ST_TO_ADDR
43944: GO 43910
43946: POP
43947: POP
// if not tmp then
43948: LD_VAR 0 6
43952: NOT
43953: IFFALSE 43957
// continue ;
43955: GO 43099
// if places then
43957: LD_VAR 0 5
43961: IFFALSE 44020
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
43963: LD_ADDR_EXP 117
43967: PUSH
43968: LD_EXP 117
43972: PPUSH
43973: LD_VAR 0 2
43977: PPUSH
43978: LD_EXP 117
43982: PUSH
43983: LD_VAR 0 2
43987: ARRAY
43988: PUSH
43989: LD_VAR 0 6
43993: PUSH
43994: LD_INT 1
43996: ARRAY
43997: UNION
43998: PPUSH
43999: CALL_OW 1
44003: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
44004: LD_VAR 0 6
44008: PUSH
44009: LD_INT 1
44011: ARRAY
44012: PPUSH
44013: LD_INT 126
44015: PPUSH
44016: CALL_OW 109
// end ; end ;
44020: GO 43099
44022: POP
44023: POP
// end ;
44024: LD_VAR 0 1
44028: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
44029: LD_INT 0
44031: PPUSH
44032: PPUSH
44033: PPUSH
44034: PPUSH
44035: PPUSH
44036: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
44037: LD_VAR 0 1
44041: NOT
44042: PUSH
44043: LD_VAR 0 2
44047: NOT
44048: OR
44049: PUSH
44050: LD_VAR 0 3
44054: NOT
44055: OR
44056: PUSH
44057: LD_VAR 0 4
44061: PUSH
44062: LD_INT 1
44064: PUSH
44065: LD_INT 2
44067: PUSH
44068: LD_INT 3
44070: PUSH
44071: LD_INT 4
44073: PUSH
44074: LD_INT 5
44076: PUSH
44077: LD_INT 8
44079: PUSH
44080: LD_INT 9
44082: PUSH
44083: LD_INT 15
44085: PUSH
44086: LD_INT 16
44088: PUSH
44089: EMPTY
44090: LIST
44091: LIST
44092: LIST
44093: LIST
44094: LIST
44095: LIST
44096: LIST
44097: LIST
44098: LIST
44099: IN
44100: NOT
44101: OR
44102: IFFALSE 44106
// exit ;
44104: GO 45006
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
44106: LD_ADDR_VAR 0 2
44110: PUSH
44111: LD_VAR 0 2
44115: PPUSH
44116: LD_INT 21
44118: PUSH
44119: LD_INT 3
44121: PUSH
44122: EMPTY
44123: LIST
44124: LIST
44125: PUSH
44126: LD_INT 24
44128: PUSH
44129: LD_INT 250
44131: PUSH
44132: EMPTY
44133: LIST
44134: LIST
44135: PUSH
44136: EMPTY
44137: LIST
44138: LIST
44139: PPUSH
44140: CALL_OW 72
44144: ST_TO_ADDR
// case class of 1 , 15 :
44145: LD_VAR 0 4
44149: PUSH
44150: LD_INT 1
44152: DOUBLE
44153: EQUAL
44154: IFTRUE 44164
44156: LD_INT 15
44158: DOUBLE
44159: EQUAL
44160: IFTRUE 44164
44162: GO 44249
44164: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
44165: LD_ADDR_VAR 0 8
44169: PUSH
44170: LD_VAR 0 2
44174: PPUSH
44175: LD_INT 2
44177: PUSH
44178: LD_INT 30
44180: PUSH
44181: LD_INT 32
44183: PUSH
44184: EMPTY
44185: LIST
44186: LIST
44187: PUSH
44188: LD_INT 30
44190: PUSH
44191: LD_INT 31
44193: PUSH
44194: EMPTY
44195: LIST
44196: LIST
44197: PUSH
44198: EMPTY
44199: LIST
44200: LIST
44201: LIST
44202: PPUSH
44203: CALL_OW 72
44207: PUSH
44208: LD_VAR 0 2
44212: PPUSH
44213: LD_INT 2
44215: PUSH
44216: LD_INT 30
44218: PUSH
44219: LD_INT 4
44221: PUSH
44222: EMPTY
44223: LIST
44224: LIST
44225: PUSH
44226: LD_INT 30
44228: PUSH
44229: LD_INT 5
44231: PUSH
44232: EMPTY
44233: LIST
44234: LIST
44235: PUSH
44236: EMPTY
44237: LIST
44238: LIST
44239: LIST
44240: PPUSH
44241: CALL_OW 72
44245: ADD
44246: ST_TO_ADDR
44247: GO 44495
44249: LD_INT 2
44251: DOUBLE
44252: EQUAL
44253: IFTRUE 44263
44255: LD_INT 16
44257: DOUBLE
44258: EQUAL
44259: IFTRUE 44263
44261: GO 44309
44263: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
44264: LD_ADDR_VAR 0 8
44268: PUSH
44269: LD_VAR 0 2
44273: PPUSH
44274: LD_INT 2
44276: PUSH
44277: LD_INT 30
44279: PUSH
44280: LD_INT 0
44282: PUSH
44283: EMPTY
44284: LIST
44285: LIST
44286: PUSH
44287: LD_INT 30
44289: PUSH
44290: LD_INT 1
44292: PUSH
44293: EMPTY
44294: LIST
44295: LIST
44296: PUSH
44297: EMPTY
44298: LIST
44299: LIST
44300: LIST
44301: PPUSH
44302: CALL_OW 72
44306: ST_TO_ADDR
44307: GO 44495
44309: LD_INT 3
44311: DOUBLE
44312: EQUAL
44313: IFTRUE 44317
44315: GO 44363
44317: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
44318: LD_ADDR_VAR 0 8
44322: PUSH
44323: LD_VAR 0 2
44327: PPUSH
44328: LD_INT 2
44330: PUSH
44331: LD_INT 30
44333: PUSH
44334: LD_INT 2
44336: PUSH
44337: EMPTY
44338: LIST
44339: LIST
44340: PUSH
44341: LD_INT 30
44343: PUSH
44344: LD_INT 3
44346: PUSH
44347: EMPTY
44348: LIST
44349: LIST
44350: PUSH
44351: EMPTY
44352: LIST
44353: LIST
44354: LIST
44355: PPUSH
44356: CALL_OW 72
44360: ST_TO_ADDR
44361: GO 44495
44363: LD_INT 4
44365: DOUBLE
44366: EQUAL
44367: IFTRUE 44371
44369: GO 44428
44371: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
44372: LD_ADDR_VAR 0 8
44376: PUSH
44377: LD_VAR 0 2
44381: PPUSH
44382: LD_INT 2
44384: PUSH
44385: LD_INT 30
44387: PUSH
44388: LD_INT 6
44390: PUSH
44391: EMPTY
44392: LIST
44393: LIST
44394: PUSH
44395: LD_INT 30
44397: PUSH
44398: LD_INT 7
44400: PUSH
44401: EMPTY
44402: LIST
44403: LIST
44404: PUSH
44405: LD_INT 30
44407: PUSH
44408: LD_INT 8
44410: PUSH
44411: EMPTY
44412: LIST
44413: LIST
44414: PUSH
44415: EMPTY
44416: LIST
44417: LIST
44418: LIST
44419: LIST
44420: PPUSH
44421: CALL_OW 72
44425: ST_TO_ADDR
44426: GO 44495
44428: LD_INT 5
44430: DOUBLE
44431: EQUAL
44432: IFTRUE 44448
44434: LD_INT 8
44436: DOUBLE
44437: EQUAL
44438: IFTRUE 44448
44440: LD_INT 9
44442: DOUBLE
44443: EQUAL
44444: IFTRUE 44448
44446: GO 44494
44448: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
44449: LD_ADDR_VAR 0 8
44453: PUSH
44454: LD_VAR 0 2
44458: PPUSH
44459: LD_INT 2
44461: PUSH
44462: LD_INT 30
44464: PUSH
44465: LD_INT 4
44467: PUSH
44468: EMPTY
44469: LIST
44470: LIST
44471: PUSH
44472: LD_INT 30
44474: PUSH
44475: LD_INT 5
44477: PUSH
44478: EMPTY
44479: LIST
44480: LIST
44481: PUSH
44482: EMPTY
44483: LIST
44484: LIST
44485: LIST
44486: PPUSH
44487: CALL_OW 72
44491: ST_TO_ADDR
44492: GO 44495
44494: POP
// if not tmp then
44495: LD_VAR 0 8
44499: NOT
44500: IFFALSE 44504
// exit ;
44502: GO 45006
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
44504: LD_VAR 0 4
44508: PUSH
44509: LD_INT 1
44511: PUSH
44512: LD_INT 15
44514: PUSH
44515: EMPTY
44516: LIST
44517: LIST
44518: IN
44519: PUSH
44520: LD_EXP 86
44524: PUSH
44525: LD_VAR 0 1
44529: ARRAY
44530: AND
44531: IFFALSE 44687
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
44533: LD_ADDR_VAR 0 9
44537: PUSH
44538: LD_EXP 86
44542: PUSH
44543: LD_VAR 0 1
44547: ARRAY
44548: PUSH
44549: LD_INT 1
44551: ARRAY
44552: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
44553: LD_VAR 0 9
44557: PUSH
44558: LD_EXP 87
44562: PUSH
44563: LD_VAR 0 1
44567: ARRAY
44568: IN
44569: NOT
44570: IFFALSE 44685
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
44572: LD_ADDR_EXP 87
44576: PUSH
44577: LD_EXP 87
44581: PPUSH
44582: LD_VAR 0 1
44586: PUSH
44587: LD_EXP 87
44591: PUSH
44592: LD_VAR 0 1
44596: ARRAY
44597: PUSH
44598: LD_INT 1
44600: PLUS
44601: PUSH
44602: EMPTY
44603: LIST
44604: LIST
44605: PPUSH
44606: LD_VAR 0 9
44610: PPUSH
44611: CALL 57199 0 3
44615: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
44616: LD_ADDR_EXP 86
44620: PUSH
44621: LD_EXP 86
44625: PPUSH
44626: LD_VAR 0 1
44630: PPUSH
44631: LD_EXP 86
44635: PUSH
44636: LD_VAR 0 1
44640: ARRAY
44641: PUSH
44642: LD_VAR 0 9
44646: DIFF
44647: PPUSH
44648: CALL_OW 1
44652: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
44653: LD_VAR 0 3
44657: PPUSH
44658: LD_EXP 87
44662: PUSH
44663: LD_VAR 0 1
44667: ARRAY
44668: PUSH
44669: LD_EXP 87
44673: PUSH
44674: LD_VAR 0 1
44678: ARRAY
44679: ARRAY
44680: PPUSH
44681: CALL_OW 120
// end ; exit ;
44685: GO 45006
// end ; if tmp > 1 then
44687: LD_VAR 0 8
44691: PUSH
44692: LD_INT 1
44694: GREATER
44695: IFFALSE 44799
// for i = 2 to tmp do
44697: LD_ADDR_VAR 0 6
44701: PUSH
44702: DOUBLE
44703: LD_INT 2
44705: DEC
44706: ST_TO_ADDR
44707: LD_VAR 0 8
44711: PUSH
44712: FOR_TO
44713: IFFALSE 44797
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
44715: LD_VAR 0 8
44719: PUSH
44720: LD_VAR 0 6
44724: ARRAY
44725: PPUSH
44726: CALL_OW 461
44730: PUSH
44731: LD_INT 6
44733: EQUAL
44734: IFFALSE 44795
// begin x := tmp [ i ] ;
44736: LD_ADDR_VAR 0 9
44740: PUSH
44741: LD_VAR 0 8
44745: PUSH
44746: LD_VAR 0 6
44750: ARRAY
44751: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
44752: LD_ADDR_VAR 0 8
44756: PUSH
44757: LD_VAR 0 8
44761: PPUSH
44762: LD_VAR 0 6
44766: PPUSH
44767: CALL_OW 3
44771: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
44772: LD_ADDR_VAR 0 8
44776: PUSH
44777: LD_VAR 0 8
44781: PPUSH
44782: LD_INT 1
44784: PPUSH
44785: LD_VAR 0 9
44789: PPUSH
44790: CALL_OW 2
44794: ST_TO_ADDR
// end ;
44795: GO 44712
44797: POP
44798: POP
// for i in tmp do
44799: LD_ADDR_VAR 0 6
44803: PUSH
44804: LD_VAR 0 8
44808: PUSH
44809: FOR_IN
44810: IFFALSE 44879
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
44812: LD_VAR 0 6
44816: PPUSH
44817: CALL_OW 313
44821: PUSH
44822: LD_INT 6
44824: LESS
44825: PUSH
44826: LD_VAR 0 6
44830: PPUSH
44831: CALL_OW 266
44835: PUSH
44836: LD_INT 31
44838: PUSH
44839: LD_INT 32
44841: PUSH
44842: EMPTY
44843: LIST
44844: LIST
44845: IN
44846: NOT
44847: AND
44848: PUSH
44849: LD_VAR 0 6
44853: PPUSH
44854: CALL_OW 313
44858: PUSH
44859: LD_INT 0
44861: EQUAL
44862: OR
44863: IFFALSE 44877
// begin j := i ;
44865: LD_ADDR_VAR 0 7
44869: PUSH
44870: LD_VAR 0 6
44874: ST_TO_ADDR
// break ;
44875: GO 44879
// end ; end ;
44877: GO 44809
44879: POP
44880: POP
// if j then
44881: LD_VAR 0 7
44885: IFFALSE 44903
// ComEnterUnit ( unit , j ) else
44887: LD_VAR 0 3
44891: PPUSH
44892: LD_VAR 0 7
44896: PPUSH
44897: CALL_OW 120
44901: GO 45006
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44903: LD_ADDR_VAR 0 10
44907: PUSH
44908: LD_VAR 0 2
44912: PPUSH
44913: LD_INT 2
44915: PUSH
44916: LD_INT 30
44918: PUSH
44919: LD_INT 0
44921: PUSH
44922: EMPTY
44923: LIST
44924: LIST
44925: PUSH
44926: LD_INT 30
44928: PUSH
44929: LD_INT 1
44931: PUSH
44932: EMPTY
44933: LIST
44934: LIST
44935: PUSH
44936: EMPTY
44937: LIST
44938: LIST
44939: LIST
44940: PPUSH
44941: CALL_OW 72
44945: ST_TO_ADDR
// if depot then
44946: LD_VAR 0 10
44950: IFFALSE 45006
// begin depot := NearestUnitToUnit ( depot , unit ) ;
44952: LD_ADDR_VAR 0 10
44956: PUSH
44957: LD_VAR 0 10
44961: PPUSH
44962: LD_VAR 0 3
44966: PPUSH
44967: CALL_OW 74
44971: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
44972: LD_VAR 0 3
44976: PPUSH
44977: LD_VAR 0 10
44981: PPUSH
44982: CALL_OW 296
44986: PUSH
44987: LD_INT 10
44989: GREATER
44990: IFFALSE 45006
// ComStandNearbyBuilding ( unit , depot ) ;
44992: LD_VAR 0 3
44996: PPUSH
44997: LD_VAR 0 10
45001: PPUSH
45002: CALL 53626 0 2
// end ; end ; end ;
45006: LD_VAR 0 5
45010: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
45011: LD_INT 0
45013: PPUSH
45014: PPUSH
45015: PPUSH
45016: PPUSH
// if not mc_bases then
45017: LD_EXP 77
45021: NOT
45022: IFFALSE 45026
// exit ;
45024: GO 45265
// for i = 1 to mc_bases do
45026: LD_ADDR_VAR 0 2
45030: PUSH
45031: DOUBLE
45032: LD_INT 1
45034: DEC
45035: ST_TO_ADDR
45036: LD_EXP 77
45040: PUSH
45041: FOR_TO
45042: IFFALSE 45263
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
45044: LD_ADDR_VAR 0 4
45048: PUSH
45049: LD_EXP 77
45053: PUSH
45054: LD_VAR 0 2
45058: ARRAY
45059: PPUSH
45060: LD_INT 21
45062: PUSH
45063: LD_INT 1
45065: PUSH
45066: EMPTY
45067: LIST
45068: LIST
45069: PPUSH
45070: CALL_OW 72
45074: PUSH
45075: LD_EXP 106
45079: PUSH
45080: LD_VAR 0 2
45084: ARRAY
45085: UNION
45086: ST_TO_ADDR
// if not tmp then
45087: LD_VAR 0 4
45091: NOT
45092: IFFALSE 45096
// continue ;
45094: GO 45041
// for j in tmp do
45096: LD_ADDR_VAR 0 3
45100: PUSH
45101: LD_VAR 0 4
45105: PUSH
45106: FOR_IN
45107: IFFALSE 45259
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
45109: LD_VAR 0 3
45113: PPUSH
45114: CALL_OW 110
45118: NOT
45119: PUSH
45120: LD_VAR 0 3
45124: PPUSH
45125: CALL_OW 314
45129: NOT
45130: AND
45131: PUSH
45132: LD_VAR 0 3
45136: PPUSH
45137: CALL_OW 311
45141: NOT
45142: AND
45143: PUSH
45144: LD_VAR 0 3
45148: PPUSH
45149: CALL_OW 310
45153: NOT
45154: AND
45155: PUSH
45156: LD_VAR 0 3
45160: PUSH
45161: LD_EXP 80
45165: PUSH
45166: LD_VAR 0 2
45170: ARRAY
45171: PUSH
45172: LD_INT 1
45174: ARRAY
45175: IN
45176: NOT
45177: AND
45178: PUSH
45179: LD_VAR 0 3
45183: PUSH
45184: LD_EXP 80
45188: PUSH
45189: LD_VAR 0 2
45193: ARRAY
45194: PUSH
45195: LD_INT 2
45197: ARRAY
45198: IN
45199: NOT
45200: AND
45201: PUSH
45202: LD_VAR 0 3
45206: PUSH
45207: LD_EXP 89
45211: PUSH
45212: LD_VAR 0 2
45216: ARRAY
45217: IN
45218: NOT
45219: AND
45220: IFFALSE 45257
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
45222: LD_VAR 0 2
45226: PPUSH
45227: LD_EXP 77
45231: PUSH
45232: LD_VAR 0 2
45236: ARRAY
45237: PPUSH
45238: LD_VAR 0 3
45242: PPUSH
45243: LD_VAR 0 3
45247: PPUSH
45248: CALL_OW 257
45252: PPUSH
45253: CALL 44029 0 4
// end ;
45257: GO 45106
45259: POP
45260: POP
// end ;
45261: GO 45041
45263: POP
45264: POP
// end ;
45265: LD_VAR 0 1
45269: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
45270: LD_INT 0
45272: PPUSH
45273: PPUSH
45274: PPUSH
45275: PPUSH
45276: PPUSH
45277: PPUSH
// if not mc_bases [ base ] then
45278: LD_EXP 77
45282: PUSH
45283: LD_VAR 0 1
45287: ARRAY
45288: NOT
45289: IFFALSE 45293
// exit ;
45291: GO 45475
// tmp := [ ] ;
45293: LD_ADDR_VAR 0 6
45297: PUSH
45298: EMPTY
45299: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
45300: LD_ADDR_VAR 0 7
45304: PUSH
45305: LD_VAR 0 3
45309: PPUSH
45310: LD_INT 0
45312: PPUSH
45313: CALL_OW 517
45317: ST_TO_ADDR
// if not list then
45318: LD_VAR 0 7
45322: NOT
45323: IFFALSE 45327
// exit ;
45325: GO 45475
// for i = 1 to amount do
45327: LD_ADDR_VAR 0 5
45331: PUSH
45332: DOUBLE
45333: LD_INT 1
45335: DEC
45336: ST_TO_ADDR
45337: LD_VAR 0 2
45341: PUSH
45342: FOR_TO
45343: IFFALSE 45423
// begin x := rand ( 1 , list [ 1 ] ) ;
45345: LD_ADDR_VAR 0 8
45349: PUSH
45350: LD_INT 1
45352: PPUSH
45353: LD_VAR 0 7
45357: PUSH
45358: LD_INT 1
45360: ARRAY
45361: PPUSH
45362: CALL_OW 12
45366: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
45367: LD_ADDR_VAR 0 6
45371: PUSH
45372: LD_VAR 0 6
45376: PPUSH
45377: LD_VAR 0 5
45381: PPUSH
45382: LD_VAR 0 7
45386: PUSH
45387: LD_INT 1
45389: ARRAY
45390: PUSH
45391: LD_VAR 0 8
45395: ARRAY
45396: PUSH
45397: LD_VAR 0 7
45401: PUSH
45402: LD_INT 2
45404: ARRAY
45405: PUSH
45406: LD_VAR 0 8
45410: ARRAY
45411: PUSH
45412: EMPTY
45413: LIST
45414: LIST
45415: PPUSH
45416: CALL_OW 1
45420: ST_TO_ADDR
// end ;
45421: GO 45342
45423: POP
45424: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
45425: LD_ADDR_EXP 90
45429: PUSH
45430: LD_EXP 90
45434: PPUSH
45435: LD_VAR 0 1
45439: PPUSH
45440: LD_VAR 0 6
45444: PPUSH
45445: CALL_OW 1
45449: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
45450: LD_ADDR_EXP 92
45454: PUSH
45455: LD_EXP 92
45459: PPUSH
45460: LD_VAR 0 1
45464: PPUSH
45465: LD_VAR 0 3
45469: PPUSH
45470: CALL_OW 1
45474: ST_TO_ADDR
// end ;
45475: LD_VAR 0 4
45479: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
45480: LD_INT 0
45482: PPUSH
// if not mc_bases [ base ] then
45483: LD_EXP 77
45487: PUSH
45488: LD_VAR 0 1
45492: ARRAY
45493: NOT
45494: IFFALSE 45498
// exit ;
45496: GO 45523
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
45498: LD_ADDR_EXP 82
45502: PUSH
45503: LD_EXP 82
45507: PPUSH
45508: LD_VAR 0 1
45512: PPUSH
45513: LD_VAR 0 2
45517: PPUSH
45518: CALL_OW 1
45522: ST_TO_ADDR
// end ;
45523: LD_VAR 0 3
45527: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
45528: LD_INT 0
45530: PPUSH
// if not mc_bases [ base ] then
45531: LD_EXP 77
45535: PUSH
45536: LD_VAR 0 1
45540: ARRAY
45541: NOT
45542: IFFALSE 45546
// exit ;
45544: GO 45583
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
45546: LD_ADDR_EXP 82
45550: PUSH
45551: LD_EXP 82
45555: PPUSH
45556: LD_VAR 0 1
45560: PPUSH
45561: LD_EXP 82
45565: PUSH
45566: LD_VAR 0 1
45570: ARRAY
45571: PUSH
45572: LD_VAR 0 2
45576: UNION
45577: PPUSH
45578: CALL_OW 1
45582: ST_TO_ADDR
// end ;
45583: LD_VAR 0 3
45587: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
45588: LD_INT 0
45590: PPUSH
// if not mc_bases [ base ] then
45591: LD_EXP 77
45595: PUSH
45596: LD_VAR 0 1
45600: ARRAY
45601: NOT
45602: IFFALSE 45606
// exit ;
45604: GO 45631
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
45606: LD_ADDR_EXP 98
45610: PUSH
45611: LD_EXP 98
45615: PPUSH
45616: LD_VAR 0 1
45620: PPUSH
45621: LD_VAR 0 2
45625: PPUSH
45626: CALL_OW 1
45630: ST_TO_ADDR
// end ;
45631: LD_VAR 0 3
45635: RET
// export function MC_InsertProduceList ( base , components ) ; begin
45636: LD_INT 0
45638: PPUSH
// if not mc_bases [ base ] then
45639: LD_EXP 77
45643: PUSH
45644: LD_VAR 0 1
45648: ARRAY
45649: NOT
45650: IFFALSE 45654
// exit ;
45652: GO 45691
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
45654: LD_ADDR_EXP 98
45658: PUSH
45659: LD_EXP 98
45663: PPUSH
45664: LD_VAR 0 1
45668: PPUSH
45669: LD_EXP 98
45673: PUSH
45674: LD_VAR 0 1
45678: ARRAY
45679: PUSH
45680: LD_VAR 0 2
45684: ADD
45685: PPUSH
45686: CALL_OW 1
45690: ST_TO_ADDR
// end ;
45691: LD_VAR 0 3
45695: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
45696: LD_INT 0
45698: PPUSH
// if not mc_bases [ base ] then
45699: LD_EXP 77
45703: PUSH
45704: LD_VAR 0 1
45708: ARRAY
45709: NOT
45710: IFFALSE 45714
// exit ;
45712: GO 45768
// mc_defender := Replace ( mc_defender , base , deflist ) ;
45714: LD_ADDR_EXP 99
45718: PUSH
45719: LD_EXP 99
45723: PPUSH
45724: LD_VAR 0 1
45728: PPUSH
45729: LD_VAR 0 2
45733: PPUSH
45734: CALL_OW 1
45738: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
45739: LD_ADDR_EXP 88
45743: PUSH
45744: LD_EXP 88
45748: PPUSH
45749: LD_VAR 0 1
45753: PPUSH
45754: LD_VAR 0 2
45758: PUSH
45759: LD_INT 0
45761: PLUS
45762: PPUSH
45763: CALL_OW 1
45767: ST_TO_ADDR
// end ;
45768: LD_VAR 0 3
45772: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
45773: LD_INT 0
45775: PPUSH
// if not mc_bases [ base ] then
45776: LD_EXP 77
45780: PUSH
45781: LD_VAR 0 1
45785: ARRAY
45786: NOT
45787: IFFALSE 45791
// exit ;
45789: GO 45816
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
45791: LD_ADDR_EXP 88
45795: PUSH
45796: LD_EXP 88
45800: PPUSH
45801: LD_VAR 0 1
45805: PPUSH
45806: LD_VAR 0 2
45810: PPUSH
45811: CALL_OW 1
45815: ST_TO_ADDR
// end ;
45816: LD_VAR 0 3
45820: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
45821: LD_INT 0
45823: PPUSH
45824: PPUSH
45825: PPUSH
45826: PPUSH
// if not mc_bases [ base ] then
45827: LD_EXP 77
45831: PUSH
45832: LD_VAR 0 1
45836: ARRAY
45837: NOT
45838: IFFALSE 45842
// exit ;
45840: GO 45907
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
45842: LD_ADDR_EXP 97
45846: PUSH
45847: LD_EXP 97
45851: PPUSH
45852: LD_VAR 0 1
45856: PUSH
45857: LD_EXP 97
45861: PUSH
45862: LD_VAR 0 1
45866: ARRAY
45867: PUSH
45868: LD_INT 1
45870: PLUS
45871: PUSH
45872: EMPTY
45873: LIST
45874: LIST
45875: PPUSH
45876: LD_VAR 0 1
45880: PUSH
45881: LD_VAR 0 2
45885: PUSH
45886: LD_VAR 0 3
45890: PUSH
45891: LD_VAR 0 4
45895: PUSH
45896: EMPTY
45897: LIST
45898: LIST
45899: LIST
45900: LIST
45901: PPUSH
45902: CALL 57199 0 3
45906: ST_TO_ADDR
// end ;
45907: LD_VAR 0 5
45911: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
45912: LD_INT 0
45914: PPUSH
// if not mc_bases [ base ] then
45915: LD_EXP 77
45919: PUSH
45920: LD_VAR 0 1
45924: ARRAY
45925: NOT
45926: IFFALSE 45930
// exit ;
45928: GO 45955
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
45930: LD_ADDR_EXP 114
45934: PUSH
45935: LD_EXP 114
45939: PPUSH
45940: LD_VAR 0 1
45944: PPUSH
45945: LD_VAR 0 2
45949: PPUSH
45950: CALL_OW 1
45954: ST_TO_ADDR
// end ;
45955: LD_VAR 0 3
45959: RET
// export function MC_GetMinesField ( base ) ; begin
45960: LD_INT 0
45962: PPUSH
// result := mc_mines [ base ] ;
45963: LD_ADDR_VAR 0 2
45967: PUSH
45968: LD_EXP 90
45972: PUSH
45973: LD_VAR 0 1
45977: ARRAY
45978: ST_TO_ADDR
// end ;
45979: LD_VAR 0 2
45983: RET
// export function MC_GetProduceList ( base ) ; begin
45984: LD_INT 0
45986: PPUSH
// result := mc_produce [ base ] ;
45987: LD_ADDR_VAR 0 2
45991: PUSH
45992: LD_EXP 98
45996: PUSH
45997: LD_VAR 0 1
46001: ARRAY
46002: ST_TO_ADDR
// end ;
46003: LD_VAR 0 2
46007: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
46008: LD_INT 0
46010: PPUSH
46011: PPUSH
// if not mc_bases then
46012: LD_EXP 77
46016: NOT
46017: IFFALSE 46021
// exit ;
46019: GO 46086
// if mc_bases [ base ] then
46021: LD_EXP 77
46025: PUSH
46026: LD_VAR 0 1
46030: ARRAY
46031: IFFALSE 46086
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
46033: LD_ADDR_VAR 0 3
46037: PUSH
46038: LD_EXP 77
46042: PUSH
46043: LD_VAR 0 1
46047: ARRAY
46048: PPUSH
46049: LD_INT 30
46051: PUSH
46052: LD_VAR 0 2
46056: PUSH
46057: EMPTY
46058: LIST
46059: LIST
46060: PPUSH
46061: CALL_OW 72
46065: ST_TO_ADDR
// if result then
46066: LD_VAR 0 3
46070: IFFALSE 46086
// result := result [ 1 ] ;
46072: LD_ADDR_VAR 0 3
46076: PUSH
46077: LD_VAR 0 3
46081: PUSH
46082: LD_INT 1
46084: ARRAY
46085: ST_TO_ADDR
// end ; end ;
46086: LD_VAR 0 3
46090: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
46091: LD_INT 0
46093: PPUSH
46094: PPUSH
// if not mc_bases then
46095: LD_EXP 77
46099: NOT
46100: IFFALSE 46104
// exit ;
46102: GO 46149
// if mc_bases [ base ] then
46104: LD_EXP 77
46108: PUSH
46109: LD_VAR 0 1
46113: ARRAY
46114: IFFALSE 46149
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
46116: LD_ADDR_VAR 0 3
46120: PUSH
46121: LD_EXP 77
46125: PUSH
46126: LD_VAR 0 1
46130: ARRAY
46131: PPUSH
46132: LD_INT 30
46134: PUSH
46135: LD_VAR 0 2
46139: PUSH
46140: EMPTY
46141: LIST
46142: LIST
46143: PPUSH
46144: CALL_OW 72
46148: ST_TO_ADDR
// end ;
46149: LD_VAR 0 3
46153: RET
// export function MC_SetTame ( base , area ) ; begin
46154: LD_INT 0
46156: PPUSH
// if not mc_bases or not base then
46157: LD_EXP 77
46161: NOT
46162: PUSH
46163: LD_VAR 0 1
46167: NOT
46168: OR
46169: IFFALSE 46173
// exit ;
46171: GO 46198
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
46173: LD_ADDR_EXP 105
46177: PUSH
46178: LD_EXP 105
46182: PPUSH
46183: LD_VAR 0 1
46187: PPUSH
46188: LD_VAR 0 2
46192: PPUSH
46193: CALL_OW 1
46197: ST_TO_ADDR
// end ;
46198: LD_VAR 0 3
46202: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
46203: LD_INT 0
46205: PPUSH
46206: PPUSH
// if not mc_bases or not base then
46207: LD_EXP 77
46211: NOT
46212: PUSH
46213: LD_VAR 0 1
46217: NOT
46218: OR
46219: IFFALSE 46223
// exit ;
46221: GO 46325
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
46223: LD_ADDR_VAR 0 4
46227: PUSH
46228: LD_EXP 77
46232: PUSH
46233: LD_VAR 0 1
46237: ARRAY
46238: PPUSH
46239: LD_INT 30
46241: PUSH
46242: LD_VAR 0 2
46246: PUSH
46247: EMPTY
46248: LIST
46249: LIST
46250: PPUSH
46251: CALL_OW 72
46255: ST_TO_ADDR
// if not tmp then
46256: LD_VAR 0 4
46260: NOT
46261: IFFALSE 46265
// exit ;
46263: GO 46325
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
46265: LD_ADDR_EXP 109
46269: PUSH
46270: LD_EXP 109
46274: PPUSH
46275: LD_VAR 0 1
46279: PPUSH
46280: LD_EXP 109
46284: PUSH
46285: LD_VAR 0 1
46289: ARRAY
46290: PPUSH
46291: LD_EXP 109
46295: PUSH
46296: LD_VAR 0 1
46300: ARRAY
46301: PUSH
46302: LD_INT 1
46304: PLUS
46305: PPUSH
46306: LD_VAR 0 4
46310: PUSH
46311: LD_INT 1
46313: ARRAY
46314: PPUSH
46315: CALL_OW 2
46319: PPUSH
46320: CALL_OW 1
46324: ST_TO_ADDR
// end ;
46325: LD_VAR 0 3
46329: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
46330: LD_INT 0
46332: PPUSH
46333: PPUSH
// if not mc_bases or not base or not kinds then
46334: LD_EXP 77
46338: NOT
46339: PUSH
46340: LD_VAR 0 1
46344: NOT
46345: OR
46346: PUSH
46347: LD_VAR 0 2
46351: NOT
46352: OR
46353: IFFALSE 46357
// exit ;
46355: GO 46418
// for i in kinds do
46357: LD_ADDR_VAR 0 4
46361: PUSH
46362: LD_VAR 0 2
46366: PUSH
46367: FOR_IN
46368: IFFALSE 46416
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
46370: LD_ADDR_EXP 111
46374: PUSH
46375: LD_EXP 111
46379: PPUSH
46380: LD_VAR 0 1
46384: PUSH
46385: LD_EXP 111
46389: PUSH
46390: LD_VAR 0 1
46394: ARRAY
46395: PUSH
46396: LD_INT 1
46398: PLUS
46399: PUSH
46400: EMPTY
46401: LIST
46402: LIST
46403: PPUSH
46404: LD_VAR 0 4
46408: PPUSH
46409: CALL 57199 0 3
46413: ST_TO_ADDR
46414: GO 46367
46416: POP
46417: POP
// end ;
46418: LD_VAR 0 3
46422: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
46423: LD_INT 0
46425: PPUSH
// if not mc_bases or not base or not areas then
46426: LD_EXP 77
46430: NOT
46431: PUSH
46432: LD_VAR 0 1
46436: NOT
46437: OR
46438: PUSH
46439: LD_VAR 0 2
46443: NOT
46444: OR
46445: IFFALSE 46449
// exit ;
46447: GO 46474
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
46449: LD_ADDR_EXP 95
46453: PUSH
46454: LD_EXP 95
46458: PPUSH
46459: LD_VAR 0 1
46463: PPUSH
46464: LD_VAR 0 2
46468: PPUSH
46469: CALL_OW 1
46473: ST_TO_ADDR
// end ;
46474: LD_VAR 0 3
46478: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
46479: LD_INT 0
46481: PPUSH
// if not mc_bases or not base or not teleports_exit then
46482: LD_EXP 77
46486: NOT
46487: PUSH
46488: LD_VAR 0 1
46492: NOT
46493: OR
46494: PUSH
46495: LD_VAR 0 2
46499: NOT
46500: OR
46501: IFFALSE 46505
// exit ;
46503: GO 46530
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
46505: LD_ADDR_EXP 112
46509: PUSH
46510: LD_EXP 112
46514: PPUSH
46515: LD_VAR 0 1
46519: PPUSH
46520: LD_VAR 0 2
46524: PPUSH
46525: CALL_OW 1
46529: ST_TO_ADDR
// end ;
46530: LD_VAR 0 3
46534: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
46535: LD_INT 0
46537: PPUSH
46538: PPUSH
46539: PPUSH
// if not mc_bases or not base or not ext_list then
46540: LD_EXP 77
46544: NOT
46545: PUSH
46546: LD_VAR 0 1
46550: NOT
46551: OR
46552: PUSH
46553: LD_VAR 0 5
46557: NOT
46558: OR
46559: IFFALSE 46563
// exit ;
46561: GO 46736
// tmp := GetFacExtXYD ( x , y , d ) ;
46563: LD_ADDR_VAR 0 8
46567: PUSH
46568: LD_VAR 0 2
46572: PPUSH
46573: LD_VAR 0 3
46577: PPUSH
46578: LD_VAR 0 4
46582: PPUSH
46583: CALL 87176 0 3
46587: ST_TO_ADDR
// if not tmp then
46588: LD_VAR 0 8
46592: NOT
46593: IFFALSE 46597
// exit ;
46595: GO 46736
// for i in tmp do
46597: LD_ADDR_VAR 0 7
46601: PUSH
46602: LD_VAR 0 8
46606: PUSH
46607: FOR_IN
46608: IFFALSE 46734
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
46610: LD_ADDR_EXP 82
46614: PUSH
46615: LD_EXP 82
46619: PPUSH
46620: LD_VAR 0 1
46624: PPUSH
46625: LD_EXP 82
46629: PUSH
46630: LD_VAR 0 1
46634: ARRAY
46635: PPUSH
46636: LD_EXP 82
46640: PUSH
46641: LD_VAR 0 1
46645: ARRAY
46646: PUSH
46647: LD_INT 1
46649: PLUS
46650: PPUSH
46651: LD_VAR 0 5
46655: PUSH
46656: LD_INT 1
46658: ARRAY
46659: PUSH
46660: LD_VAR 0 7
46664: PUSH
46665: LD_INT 1
46667: ARRAY
46668: PUSH
46669: LD_VAR 0 7
46673: PUSH
46674: LD_INT 2
46676: ARRAY
46677: PUSH
46678: LD_VAR 0 7
46682: PUSH
46683: LD_INT 3
46685: ARRAY
46686: PUSH
46687: EMPTY
46688: LIST
46689: LIST
46690: LIST
46691: LIST
46692: PPUSH
46693: CALL_OW 2
46697: PPUSH
46698: CALL_OW 1
46702: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
46703: LD_ADDR_VAR 0 5
46707: PUSH
46708: LD_VAR 0 5
46712: PPUSH
46713: LD_INT 1
46715: PPUSH
46716: CALL_OW 3
46720: ST_TO_ADDR
// if not ext_list then
46721: LD_VAR 0 5
46725: NOT
46726: IFFALSE 46732
// exit ;
46728: POP
46729: POP
46730: GO 46736
// end ;
46732: GO 46607
46734: POP
46735: POP
// end ;
46736: LD_VAR 0 6
46740: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
46741: LD_INT 0
46743: PPUSH
// if not mc_bases or not base or not weapon_list then
46744: LD_EXP 77
46748: NOT
46749: PUSH
46750: LD_VAR 0 1
46754: NOT
46755: OR
46756: PUSH
46757: LD_VAR 0 2
46761: NOT
46762: OR
46763: IFFALSE 46767
// exit ;
46765: GO 46792
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
46767: LD_ADDR_EXP 116
46771: PUSH
46772: LD_EXP 116
46776: PPUSH
46777: LD_VAR 0 1
46781: PPUSH
46782: LD_VAR 0 2
46786: PPUSH
46787: CALL_OW 1
46791: ST_TO_ADDR
// end ;
46792: LD_VAR 0 3
46796: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
46797: LD_INT 0
46799: PPUSH
// if not mc_bases or not base or not tech_list then
46800: LD_EXP 77
46804: NOT
46805: PUSH
46806: LD_VAR 0 1
46810: NOT
46811: OR
46812: PUSH
46813: LD_VAR 0 2
46817: NOT
46818: OR
46819: IFFALSE 46823
// exit ;
46821: GO 46848
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
46823: LD_ADDR_EXP 104
46827: PUSH
46828: LD_EXP 104
46832: PPUSH
46833: LD_VAR 0 1
46837: PPUSH
46838: LD_VAR 0 2
46842: PPUSH
46843: CALL_OW 1
46847: ST_TO_ADDR
// end ;
46848: LD_VAR 0 3
46852: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
46853: LD_INT 0
46855: PPUSH
// if not mc_bases or not parking_area or not base then
46856: LD_EXP 77
46860: NOT
46861: PUSH
46862: LD_VAR 0 2
46866: NOT
46867: OR
46868: PUSH
46869: LD_VAR 0 1
46873: NOT
46874: OR
46875: IFFALSE 46879
// exit ;
46877: GO 46904
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
46879: LD_ADDR_EXP 101
46883: PUSH
46884: LD_EXP 101
46888: PPUSH
46889: LD_VAR 0 1
46893: PPUSH
46894: LD_VAR 0 2
46898: PPUSH
46899: CALL_OW 1
46903: ST_TO_ADDR
// end ;
46904: LD_VAR 0 3
46908: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
46909: LD_INT 0
46911: PPUSH
// if not mc_bases or not base or not scan_area then
46912: LD_EXP 77
46916: NOT
46917: PUSH
46918: LD_VAR 0 1
46922: NOT
46923: OR
46924: PUSH
46925: LD_VAR 0 2
46929: NOT
46930: OR
46931: IFFALSE 46935
// exit ;
46933: GO 46960
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
46935: LD_ADDR_EXP 102
46939: PUSH
46940: LD_EXP 102
46944: PPUSH
46945: LD_VAR 0 1
46949: PPUSH
46950: LD_VAR 0 2
46954: PPUSH
46955: CALL_OW 1
46959: ST_TO_ADDR
// end ;
46960: LD_VAR 0 3
46964: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
46965: LD_INT 0
46967: PPUSH
46968: PPUSH
// if not mc_bases or not base then
46969: LD_EXP 77
46973: NOT
46974: PUSH
46975: LD_VAR 0 1
46979: NOT
46980: OR
46981: IFFALSE 46985
// exit ;
46983: GO 47049
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
46985: LD_ADDR_VAR 0 3
46989: PUSH
46990: LD_INT 1
46992: PUSH
46993: LD_INT 2
46995: PUSH
46996: LD_INT 3
46998: PUSH
46999: LD_INT 4
47001: PUSH
47002: LD_INT 11
47004: PUSH
47005: EMPTY
47006: LIST
47007: LIST
47008: LIST
47009: LIST
47010: LIST
47011: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
47012: LD_ADDR_EXP 104
47016: PUSH
47017: LD_EXP 104
47021: PPUSH
47022: LD_VAR 0 1
47026: PPUSH
47027: LD_EXP 104
47031: PUSH
47032: LD_VAR 0 1
47036: ARRAY
47037: PUSH
47038: LD_VAR 0 3
47042: DIFF
47043: PPUSH
47044: CALL_OW 1
47048: ST_TO_ADDR
// end ;
47049: LD_VAR 0 2
47053: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
47054: LD_INT 0
47056: PPUSH
// result := mc_vehicles [ base ] ;
47057: LD_ADDR_VAR 0 3
47061: PUSH
47062: LD_EXP 96
47066: PUSH
47067: LD_VAR 0 1
47071: ARRAY
47072: ST_TO_ADDR
// if onlyCombat then
47073: LD_VAR 0 2
47077: IFFALSE 47249
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
47079: LD_ADDR_VAR 0 3
47083: PUSH
47084: LD_VAR 0 3
47088: PUSH
47089: LD_VAR 0 3
47093: PPUSH
47094: LD_INT 2
47096: PUSH
47097: LD_INT 34
47099: PUSH
47100: LD_INT 12
47102: PUSH
47103: EMPTY
47104: LIST
47105: LIST
47106: PUSH
47107: LD_INT 34
47109: PUSH
47110: LD_INT 51
47112: PUSH
47113: EMPTY
47114: LIST
47115: LIST
47116: PUSH
47117: LD_INT 34
47119: PUSH
47120: LD_INT 89
47122: PUSH
47123: EMPTY
47124: LIST
47125: LIST
47126: PUSH
47127: LD_INT 34
47129: PUSH
47130: LD_INT 32
47132: PUSH
47133: EMPTY
47134: LIST
47135: LIST
47136: PUSH
47137: LD_INT 34
47139: PUSH
47140: LD_INT 13
47142: PUSH
47143: EMPTY
47144: LIST
47145: LIST
47146: PUSH
47147: LD_INT 34
47149: PUSH
47150: LD_INT 52
47152: PUSH
47153: EMPTY
47154: LIST
47155: LIST
47156: PUSH
47157: LD_INT 34
47159: PUSH
47160: LD_INT 88
47162: PUSH
47163: EMPTY
47164: LIST
47165: LIST
47166: PUSH
47167: LD_INT 34
47169: PUSH
47170: LD_INT 14
47172: PUSH
47173: EMPTY
47174: LIST
47175: LIST
47176: PUSH
47177: LD_INT 34
47179: PUSH
47180: LD_INT 53
47182: PUSH
47183: EMPTY
47184: LIST
47185: LIST
47186: PUSH
47187: LD_INT 34
47189: PUSH
47190: LD_INT 98
47192: PUSH
47193: EMPTY
47194: LIST
47195: LIST
47196: PUSH
47197: LD_INT 34
47199: PUSH
47200: LD_INT 31
47202: PUSH
47203: EMPTY
47204: LIST
47205: LIST
47206: PUSH
47207: LD_INT 34
47209: PUSH
47210: LD_INT 48
47212: PUSH
47213: EMPTY
47214: LIST
47215: LIST
47216: PUSH
47217: LD_INT 34
47219: PUSH
47220: LD_INT 8
47222: PUSH
47223: EMPTY
47224: LIST
47225: LIST
47226: PUSH
47227: EMPTY
47228: LIST
47229: LIST
47230: LIST
47231: LIST
47232: LIST
47233: LIST
47234: LIST
47235: LIST
47236: LIST
47237: LIST
47238: LIST
47239: LIST
47240: LIST
47241: LIST
47242: PPUSH
47243: CALL_OW 72
47247: DIFF
47248: ST_TO_ADDR
// end ; end_of_file
47249: LD_VAR 0 3
47253: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
47254: LD_INT 0
47256: PPUSH
47257: PPUSH
47258: PPUSH
// if not mc_bases or not skirmish then
47259: LD_EXP 77
47263: NOT
47264: PUSH
47265: LD_EXP 75
47269: NOT
47270: OR
47271: IFFALSE 47275
// exit ;
47273: GO 47440
// for i = 1 to mc_bases do
47275: LD_ADDR_VAR 0 4
47279: PUSH
47280: DOUBLE
47281: LD_INT 1
47283: DEC
47284: ST_TO_ADDR
47285: LD_EXP 77
47289: PUSH
47290: FOR_TO
47291: IFFALSE 47438
// begin if sci in mc_bases [ i ] then
47293: LD_VAR 0 2
47297: PUSH
47298: LD_EXP 77
47302: PUSH
47303: LD_VAR 0 4
47307: ARRAY
47308: IN
47309: IFFALSE 47436
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
47311: LD_ADDR_EXP 106
47315: PUSH
47316: LD_EXP 106
47320: PPUSH
47321: LD_VAR 0 4
47325: PUSH
47326: LD_EXP 106
47330: PUSH
47331: LD_VAR 0 4
47335: ARRAY
47336: PUSH
47337: LD_INT 1
47339: PLUS
47340: PUSH
47341: EMPTY
47342: LIST
47343: LIST
47344: PPUSH
47345: LD_VAR 0 1
47349: PPUSH
47350: CALL 57199 0 3
47354: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
47355: LD_ADDR_VAR 0 5
47359: PUSH
47360: LD_EXP 77
47364: PUSH
47365: LD_VAR 0 4
47369: ARRAY
47370: PPUSH
47371: LD_INT 2
47373: PUSH
47374: LD_INT 30
47376: PUSH
47377: LD_INT 0
47379: PUSH
47380: EMPTY
47381: LIST
47382: LIST
47383: PUSH
47384: LD_INT 30
47386: PUSH
47387: LD_INT 1
47389: PUSH
47390: EMPTY
47391: LIST
47392: LIST
47393: PUSH
47394: EMPTY
47395: LIST
47396: LIST
47397: LIST
47398: PPUSH
47399: CALL_OW 72
47403: PPUSH
47404: LD_VAR 0 1
47408: PPUSH
47409: CALL_OW 74
47413: ST_TO_ADDR
// if tmp then
47414: LD_VAR 0 5
47418: IFFALSE 47434
// ComStandNearbyBuilding ( ape , tmp ) ;
47420: LD_VAR 0 1
47424: PPUSH
47425: LD_VAR 0 5
47429: PPUSH
47430: CALL 53626 0 2
// break ;
47434: GO 47438
// end ; end ;
47436: GO 47290
47438: POP
47439: POP
// end ;
47440: LD_VAR 0 3
47444: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
47445: LD_INT 0
47447: PPUSH
47448: PPUSH
47449: PPUSH
// if not mc_bases or not skirmish then
47450: LD_EXP 77
47454: NOT
47455: PUSH
47456: LD_EXP 75
47460: NOT
47461: OR
47462: IFFALSE 47466
// exit ;
47464: GO 47555
// for i = 1 to mc_bases do
47466: LD_ADDR_VAR 0 4
47470: PUSH
47471: DOUBLE
47472: LD_INT 1
47474: DEC
47475: ST_TO_ADDR
47476: LD_EXP 77
47480: PUSH
47481: FOR_TO
47482: IFFALSE 47553
// begin if building in mc_busy_turret_list [ i ] then
47484: LD_VAR 0 1
47488: PUSH
47489: LD_EXP 87
47493: PUSH
47494: LD_VAR 0 4
47498: ARRAY
47499: IN
47500: IFFALSE 47551
// begin tmp := mc_busy_turret_list [ i ] diff building ;
47502: LD_ADDR_VAR 0 5
47506: PUSH
47507: LD_EXP 87
47511: PUSH
47512: LD_VAR 0 4
47516: ARRAY
47517: PUSH
47518: LD_VAR 0 1
47522: DIFF
47523: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
47524: LD_ADDR_EXP 87
47528: PUSH
47529: LD_EXP 87
47533: PPUSH
47534: LD_VAR 0 4
47538: PPUSH
47539: LD_VAR 0 5
47543: PPUSH
47544: CALL_OW 1
47548: ST_TO_ADDR
// break ;
47549: GO 47553
// end ; end ;
47551: GO 47481
47553: POP
47554: POP
// end ;
47555: LD_VAR 0 3
47559: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
47560: LD_INT 0
47562: PPUSH
47563: PPUSH
47564: PPUSH
// if not mc_bases or not skirmish then
47565: LD_EXP 77
47569: NOT
47570: PUSH
47571: LD_EXP 75
47575: NOT
47576: OR
47577: IFFALSE 47581
// exit ;
47579: GO 47780
// for i = 1 to mc_bases do
47581: LD_ADDR_VAR 0 5
47585: PUSH
47586: DOUBLE
47587: LD_INT 1
47589: DEC
47590: ST_TO_ADDR
47591: LD_EXP 77
47595: PUSH
47596: FOR_TO
47597: IFFALSE 47778
// if building in mc_bases [ i ] then
47599: LD_VAR 0 1
47603: PUSH
47604: LD_EXP 77
47608: PUSH
47609: LD_VAR 0 5
47613: ARRAY
47614: IN
47615: IFFALSE 47776
// begin tmp := mc_bases [ i ] diff building ;
47617: LD_ADDR_VAR 0 6
47621: PUSH
47622: LD_EXP 77
47626: PUSH
47627: LD_VAR 0 5
47631: ARRAY
47632: PUSH
47633: LD_VAR 0 1
47637: DIFF
47638: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
47639: LD_ADDR_EXP 77
47643: PUSH
47644: LD_EXP 77
47648: PPUSH
47649: LD_VAR 0 5
47653: PPUSH
47654: LD_VAR 0 6
47658: PPUSH
47659: CALL_OW 1
47663: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
47664: LD_VAR 0 1
47668: PUSH
47669: LD_EXP 85
47673: PUSH
47674: LD_VAR 0 5
47678: ARRAY
47679: IN
47680: IFFALSE 47719
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
47682: LD_ADDR_EXP 85
47686: PUSH
47687: LD_EXP 85
47691: PPUSH
47692: LD_VAR 0 5
47696: PPUSH
47697: LD_EXP 85
47701: PUSH
47702: LD_VAR 0 5
47706: ARRAY
47707: PUSH
47708: LD_VAR 0 1
47712: DIFF
47713: PPUSH
47714: CALL_OW 1
47718: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
47719: LD_VAR 0 1
47723: PUSH
47724: LD_EXP 86
47728: PUSH
47729: LD_VAR 0 5
47733: ARRAY
47734: IN
47735: IFFALSE 47774
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
47737: LD_ADDR_EXP 86
47741: PUSH
47742: LD_EXP 86
47746: PPUSH
47747: LD_VAR 0 5
47751: PPUSH
47752: LD_EXP 86
47756: PUSH
47757: LD_VAR 0 5
47761: ARRAY
47762: PUSH
47763: LD_VAR 0 1
47767: DIFF
47768: PPUSH
47769: CALL_OW 1
47773: ST_TO_ADDR
// break ;
47774: GO 47778
// end ;
47776: GO 47596
47778: POP
47779: POP
// end ;
47780: LD_VAR 0 4
47784: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
47785: LD_INT 0
47787: PPUSH
47788: PPUSH
47789: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
47790: LD_EXP 77
47794: NOT
47795: PUSH
47796: LD_EXP 75
47800: NOT
47801: OR
47802: PUSH
47803: LD_VAR 0 3
47807: PUSH
47808: LD_EXP 103
47812: IN
47813: NOT
47814: OR
47815: IFFALSE 47819
// exit ;
47817: GO 47942
// for i = 1 to mc_vehicles do
47819: LD_ADDR_VAR 0 6
47823: PUSH
47824: DOUBLE
47825: LD_INT 1
47827: DEC
47828: ST_TO_ADDR
47829: LD_EXP 96
47833: PUSH
47834: FOR_TO
47835: IFFALSE 47940
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
47837: LD_VAR 0 2
47841: PUSH
47842: LD_EXP 96
47846: PUSH
47847: LD_VAR 0 6
47851: ARRAY
47852: IN
47853: PUSH
47854: LD_VAR 0 1
47858: PUSH
47859: LD_EXP 96
47863: PUSH
47864: LD_VAR 0 6
47868: ARRAY
47869: IN
47870: OR
47871: IFFALSE 47938
// begin tmp := mc_vehicles [ i ] diff old ;
47873: LD_ADDR_VAR 0 7
47877: PUSH
47878: LD_EXP 96
47882: PUSH
47883: LD_VAR 0 6
47887: ARRAY
47888: PUSH
47889: LD_VAR 0 2
47893: DIFF
47894: ST_TO_ADDR
// tmp := tmp diff new ;
47895: LD_ADDR_VAR 0 7
47899: PUSH
47900: LD_VAR 0 7
47904: PUSH
47905: LD_VAR 0 1
47909: DIFF
47910: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
47911: LD_ADDR_EXP 96
47915: PUSH
47916: LD_EXP 96
47920: PPUSH
47921: LD_VAR 0 6
47925: PPUSH
47926: LD_VAR 0 7
47930: PPUSH
47931: CALL_OW 1
47935: ST_TO_ADDR
// break ;
47936: GO 47940
// end ;
47938: GO 47834
47940: POP
47941: POP
// end ;
47942: LD_VAR 0 5
47946: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
47947: LD_INT 0
47949: PPUSH
47950: PPUSH
47951: PPUSH
47952: PPUSH
// if not mc_bases or not skirmish then
47953: LD_EXP 77
47957: NOT
47958: PUSH
47959: LD_EXP 75
47963: NOT
47964: OR
47965: IFFALSE 47969
// exit ;
47967: GO 48389
// repeat wait ( 0 0$1 ) ;
47969: LD_INT 35
47971: PPUSH
47972: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
47976: LD_EXP 121
47980: NOT
47981: IFFALSE 47969
// mc_block_vehicle_constructed_thread := true ;
47983: LD_ADDR_EXP 121
47987: PUSH
47988: LD_INT 1
47990: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
47991: LD_ADDR_VAR 0 5
47995: PUSH
47996: LD_VAR 0 1
48000: PPUSH
48001: CALL_OW 255
48005: ST_TO_ADDR
// for i = 1 to mc_bases do
48006: LD_ADDR_VAR 0 4
48010: PUSH
48011: DOUBLE
48012: LD_INT 1
48014: DEC
48015: ST_TO_ADDR
48016: LD_EXP 77
48020: PUSH
48021: FOR_TO
48022: IFFALSE 48379
// begin if factory in mc_bases [ i ] then
48024: LD_VAR 0 2
48028: PUSH
48029: LD_EXP 77
48033: PUSH
48034: LD_VAR 0 4
48038: ARRAY
48039: IN
48040: IFFALSE 48377
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
48042: LD_EXP 99
48046: PUSH
48047: LD_VAR 0 4
48051: ARRAY
48052: PUSH
48053: LD_EXP 88
48057: PUSH
48058: LD_VAR 0 4
48062: ARRAY
48063: LESS
48064: PUSH
48065: LD_VAR 0 1
48069: PPUSH
48070: CALL_OW 264
48074: PUSH
48075: LD_INT 31
48077: PUSH
48078: LD_INT 32
48080: PUSH
48081: LD_INT 51
48083: PUSH
48084: LD_INT 89
48086: PUSH
48087: LD_INT 12
48089: PUSH
48090: LD_INT 30
48092: PUSH
48093: LD_INT 98
48095: PUSH
48096: LD_INT 11
48098: PUSH
48099: LD_INT 53
48101: PUSH
48102: LD_INT 14
48104: PUSH
48105: LD_INT 91
48107: PUSH
48108: LD_INT 29
48110: PUSH
48111: LD_INT 99
48113: PUSH
48114: LD_INT 13
48116: PUSH
48117: LD_INT 52
48119: PUSH
48120: LD_INT 88
48122: PUSH
48123: LD_INT 48
48125: PUSH
48126: LD_INT 8
48128: PUSH
48129: EMPTY
48130: LIST
48131: LIST
48132: LIST
48133: LIST
48134: LIST
48135: LIST
48136: LIST
48137: LIST
48138: LIST
48139: LIST
48140: LIST
48141: LIST
48142: LIST
48143: LIST
48144: LIST
48145: LIST
48146: LIST
48147: LIST
48148: IN
48149: NOT
48150: AND
48151: IFFALSE 48199
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
48153: LD_ADDR_EXP 99
48157: PUSH
48158: LD_EXP 99
48162: PPUSH
48163: LD_VAR 0 4
48167: PUSH
48168: LD_EXP 99
48172: PUSH
48173: LD_VAR 0 4
48177: ARRAY
48178: PUSH
48179: LD_INT 1
48181: PLUS
48182: PUSH
48183: EMPTY
48184: LIST
48185: LIST
48186: PPUSH
48187: LD_VAR 0 1
48191: PPUSH
48192: CALL 57199 0 3
48196: ST_TO_ADDR
48197: GO 48243
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
48199: LD_ADDR_EXP 96
48203: PUSH
48204: LD_EXP 96
48208: PPUSH
48209: LD_VAR 0 4
48213: PUSH
48214: LD_EXP 96
48218: PUSH
48219: LD_VAR 0 4
48223: ARRAY
48224: PUSH
48225: LD_INT 1
48227: PLUS
48228: PUSH
48229: EMPTY
48230: LIST
48231: LIST
48232: PPUSH
48233: LD_VAR 0 1
48237: PPUSH
48238: CALL 57199 0 3
48242: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
48243: LD_ADDR_EXP 121
48247: PUSH
48248: LD_INT 0
48250: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
48251: LD_VAR 0 1
48255: PPUSH
48256: CALL_OW 263
48260: PUSH
48261: LD_INT 2
48263: EQUAL
48264: IFFALSE 48293
// begin repeat wait ( 0 0$3 ) ;
48266: LD_INT 105
48268: PPUSH
48269: CALL_OW 67
// Connect ( vehicle ) ;
48273: LD_VAR 0 1
48277: PPUSH
48278: CALL 60168 0 1
// until IsControledBy ( vehicle ) ;
48282: LD_VAR 0 1
48286: PPUSH
48287: CALL_OW 312
48291: IFFALSE 48266
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
48293: LD_VAR 0 1
48297: PPUSH
48298: LD_EXP 101
48302: PUSH
48303: LD_VAR 0 4
48307: ARRAY
48308: PPUSH
48309: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
48313: LD_VAR 0 1
48317: PPUSH
48318: CALL_OW 263
48322: PUSH
48323: LD_INT 1
48325: NONEQUAL
48326: IFFALSE 48330
// break ;
48328: GO 48379
// repeat wait ( 0 0$1 ) ;
48330: LD_INT 35
48332: PPUSH
48333: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
48337: LD_VAR 0 1
48341: PPUSH
48342: LD_EXP 101
48346: PUSH
48347: LD_VAR 0 4
48351: ARRAY
48352: PPUSH
48353: CALL_OW 308
48357: IFFALSE 48330
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
48359: LD_VAR 0 1
48363: PPUSH
48364: CALL_OW 311
48368: PPUSH
48369: CALL_OW 121
// exit ;
48373: POP
48374: POP
48375: GO 48389
// end ; end ;
48377: GO 48021
48379: POP
48380: POP
// mc_block_vehicle_constructed_thread := false ;
48381: LD_ADDR_EXP 121
48385: PUSH
48386: LD_INT 0
48388: ST_TO_ADDR
// end ;
48389: LD_VAR 0 3
48393: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
48394: LD_INT 0
48396: PPUSH
48397: PPUSH
48398: PPUSH
48399: PPUSH
// if not mc_bases or not skirmish then
48400: LD_EXP 77
48404: NOT
48405: PUSH
48406: LD_EXP 75
48410: NOT
48411: OR
48412: IFFALSE 48416
// exit ;
48414: GO 48769
// repeat wait ( 0 0$1 ) ;
48416: LD_INT 35
48418: PPUSH
48419: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
48423: LD_VAR 0 2
48427: PPUSH
48428: LD_VAR 0 3
48432: PPUSH
48433: CALL_OW 284
48437: IFFALSE 48416
// if GetResourceTypeXY ( x , y ) = mat_artefact then
48439: LD_VAR 0 2
48443: PPUSH
48444: LD_VAR 0 3
48448: PPUSH
48449: CALL_OW 283
48453: PUSH
48454: LD_INT 4
48456: EQUAL
48457: IFFALSE 48461
// exit ;
48459: GO 48769
// for i = 1 to mc_bases do
48461: LD_ADDR_VAR 0 7
48465: PUSH
48466: DOUBLE
48467: LD_INT 1
48469: DEC
48470: ST_TO_ADDR
48471: LD_EXP 77
48475: PUSH
48476: FOR_TO
48477: IFFALSE 48767
// begin if mc_crates_area [ i ] then
48479: LD_EXP 95
48483: PUSH
48484: LD_VAR 0 7
48488: ARRAY
48489: IFFALSE 48600
// for j in mc_crates_area [ i ] do
48491: LD_ADDR_VAR 0 8
48495: PUSH
48496: LD_EXP 95
48500: PUSH
48501: LD_VAR 0 7
48505: ARRAY
48506: PUSH
48507: FOR_IN
48508: IFFALSE 48598
// if InArea ( x , y , j ) then
48510: LD_VAR 0 2
48514: PPUSH
48515: LD_VAR 0 3
48519: PPUSH
48520: LD_VAR 0 8
48524: PPUSH
48525: CALL_OW 309
48529: IFFALSE 48596
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
48531: LD_ADDR_EXP 93
48535: PUSH
48536: LD_EXP 93
48540: PPUSH
48541: LD_VAR 0 7
48545: PUSH
48546: LD_EXP 93
48550: PUSH
48551: LD_VAR 0 7
48555: ARRAY
48556: PUSH
48557: LD_INT 1
48559: PLUS
48560: PUSH
48561: EMPTY
48562: LIST
48563: LIST
48564: PPUSH
48565: LD_VAR 0 4
48569: PUSH
48570: LD_VAR 0 2
48574: PUSH
48575: LD_VAR 0 3
48579: PUSH
48580: EMPTY
48581: LIST
48582: LIST
48583: LIST
48584: PPUSH
48585: CALL 57199 0 3
48589: ST_TO_ADDR
// exit ;
48590: POP
48591: POP
48592: POP
48593: POP
48594: GO 48769
// end ;
48596: GO 48507
48598: POP
48599: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48600: LD_ADDR_VAR 0 9
48604: PUSH
48605: LD_EXP 77
48609: PUSH
48610: LD_VAR 0 7
48614: ARRAY
48615: PPUSH
48616: LD_INT 2
48618: PUSH
48619: LD_INT 30
48621: PUSH
48622: LD_INT 0
48624: PUSH
48625: EMPTY
48626: LIST
48627: LIST
48628: PUSH
48629: LD_INT 30
48631: PUSH
48632: LD_INT 1
48634: PUSH
48635: EMPTY
48636: LIST
48637: LIST
48638: PUSH
48639: EMPTY
48640: LIST
48641: LIST
48642: LIST
48643: PPUSH
48644: CALL_OW 72
48648: ST_TO_ADDR
// if not depot then
48649: LD_VAR 0 9
48653: NOT
48654: IFFALSE 48658
// continue ;
48656: GO 48476
// for j in depot do
48658: LD_ADDR_VAR 0 8
48662: PUSH
48663: LD_VAR 0 9
48667: PUSH
48668: FOR_IN
48669: IFFALSE 48763
// if GetDistUnitXY ( j , x , y ) < 30 then
48671: LD_VAR 0 8
48675: PPUSH
48676: LD_VAR 0 2
48680: PPUSH
48681: LD_VAR 0 3
48685: PPUSH
48686: CALL_OW 297
48690: PUSH
48691: LD_INT 30
48693: LESS
48694: IFFALSE 48761
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
48696: LD_ADDR_EXP 93
48700: PUSH
48701: LD_EXP 93
48705: PPUSH
48706: LD_VAR 0 7
48710: PUSH
48711: LD_EXP 93
48715: PUSH
48716: LD_VAR 0 7
48720: ARRAY
48721: PUSH
48722: LD_INT 1
48724: PLUS
48725: PUSH
48726: EMPTY
48727: LIST
48728: LIST
48729: PPUSH
48730: LD_VAR 0 4
48734: PUSH
48735: LD_VAR 0 2
48739: PUSH
48740: LD_VAR 0 3
48744: PUSH
48745: EMPTY
48746: LIST
48747: LIST
48748: LIST
48749: PPUSH
48750: CALL 57199 0 3
48754: ST_TO_ADDR
// exit ;
48755: POP
48756: POP
48757: POP
48758: POP
48759: GO 48769
// end ;
48761: GO 48668
48763: POP
48764: POP
// end ;
48765: GO 48476
48767: POP
48768: POP
// end ;
48769: LD_VAR 0 6
48773: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
48774: LD_INT 0
48776: PPUSH
48777: PPUSH
48778: PPUSH
48779: PPUSH
// if not mc_bases or not skirmish then
48780: LD_EXP 77
48784: NOT
48785: PUSH
48786: LD_EXP 75
48790: NOT
48791: OR
48792: IFFALSE 48796
// exit ;
48794: GO 49073
// side := GetSide ( lab ) ;
48796: LD_ADDR_VAR 0 4
48800: PUSH
48801: LD_VAR 0 2
48805: PPUSH
48806: CALL_OW 255
48810: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
48811: LD_VAR 0 4
48815: PUSH
48816: LD_EXP 103
48820: IN
48821: NOT
48822: PUSH
48823: LD_EXP 104
48827: NOT
48828: OR
48829: PUSH
48830: LD_EXP 77
48834: NOT
48835: OR
48836: IFFALSE 48840
// exit ;
48838: GO 49073
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
48840: LD_ADDR_EXP 104
48844: PUSH
48845: LD_EXP 104
48849: PPUSH
48850: LD_VAR 0 4
48854: PPUSH
48855: LD_EXP 104
48859: PUSH
48860: LD_VAR 0 4
48864: ARRAY
48865: PUSH
48866: LD_VAR 0 1
48870: DIFF
48871: PPUSH
48872: CALL_OW 1
48876: ST_TO_ADDR
// for i = 1 to mc_bases do
48877: LD_ADDR_VAR 0 5
48881: PUSH
48882: DOUBLE
48883: LD_INT 1
48885: DEC
48886: ST_TO_ADDR
48887: LD_EXP 77
48891: PUSH
48892: FOR_TO
48893: IFFALSE 49071
// begin if lab in mc_bases [ i ] then
48895: LD_VAR 0 2
48899: PUSH
48900: LD_EXP 77
48904: PUSH
48905: LD_VAR 0 5
48909: ARRAY
48910: IN
48911: IFFALSE 49069
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
48913: LD_VAR 0 1
48917: PUSH
48918: LD_INT 11
48920: PUSH
48921: LD_INT 4
48923: PUSH
48924: LD_INT 3
48926: PUSH
48927: LD_INT 2
48929: PUSH
48930: EMPTY
48931: LIST
48932: LIST
48933: LIST
48934: LIST
48935: IN
48936: PUSH
48937: LD_EXP 107
48941: PUSH
48942: LD_VAR 0 5
48946: ARRAY
48947: AND
48948: IFFALSE 49069
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
48950: LD_ADDR_VAR 0 6
48954: PUSH
48955: LD_EXP 107
48959: PUSH
48960: LD_VAR 0 5
48964: ARRAY
48965: PUSH
48966: LD_INT 1
48968: ARRAY
48969: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
48970: LD_ADDR_EXP 107
48974: PUSH
48975: LD_EXP 107
48979: PPUSH
48980: LD_VAR 0 5
48984: PPUSH
48985: EMPTY
48986: PPUSH
48987: CALL_OW 1
48991: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
48992: LD_VAR 0 6
48996: PPUSH
48997: LD_INT 0
48999: PPUSH
49000: CALL_OW 109
// ComExitBuilding ( tmp ) ;
49004: LD_VAR 0 6
49008: PPUSH
49009: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
49013: LD_ADDR_EXP 106
49017: PUSH
49018: LD_EXP 106
49022: PPUSH
49023: LD_VAR 0 5
49027: PPUSH
49028: LD_EXP 106
49032: PUSH
49033: LD_VAR 0 5
49037: ARRAY
49038: PPUSH
49039: LD_INT 1
49041: PPUSH
49042: LD_VAR 0 6
49046: PPUSH
49047: CALL_OW 2
49051: PPUSH
49052: CALL_OW 1
49056: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
49057: LD_VAR 0 5
49061: PPUSH
49062: LD_INT 112
49064: PPUSH
49065: CALL 25521 0 2
// end ; end ; end ;
49069: GO 48892
49071: POP
49072: POP
// end ;
49073: LD_VAR 0 3
49077: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
49078: LD_INT 0
49080: PPUSH
49081: PPUSH
49082: PPUSH
49083: PPUSH
49084: PPUSH
49085: PPUSH
49086: PPUSH
49087: PPUSH
// if not mc_bases or not skirmish then
49088: LD_EXP 77
49092: NOT
49093: PUSH
49094: LD_EXP 75
49098: NOT
49099: OR
49100: IFFALSE 49104
// exit ;
49102: GO 50473
// for i = 1 to mc_bases do
49104: LD_ADDR_VAR 0 3
49108: PUSH
49109: DOUBLE
49110: LD_INT 1
49112: DEC
49113: ST_TO_ADDR
49114: LD_EXP 77
49118: PUSH
49119: FOR_TO
49120: IFFALSE 50471
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
49122: LD_VAR 0 1
49126: PUSH
49127: LD_EXP 77
49131: PUSH
49132: LD_VAR 0 3
49136: ARRAY
49137: IN
49138: PUSH
49139: LD_VAR 0 1
49143: PUSH
49144: LD_EXP 84
49148: PUSH
49149: LD_VAR 0 3
49153: ARRAY
49154: IN
49155: OR
49156: PUSH
49157: LD_VAR 0 1
49161: PUSH
49162: LD_EXP 99
49166: PUSH
49167: LD_VAR 0 3
49171: ARRAY
49172: IN
49173: OR
49174: PUSH
49175: LD_VAR 0 1
49179: PUSH
49180: LD_EXP 96
49184: PUSH
49185: LD_VAR 0 3
49189: ARRAY
49190: IN
49191: OR
49192: PUSH
49193: LD_VAR 0 1
49197: PUSH
49198: LD_EXP 106
49202: PUSH
49203: LD_VAR 0 3
49207: ARRAY
49208: IN
49209: OR
49210: PUSH
49211: LD_VAR 0 1
49215: PUSH
49216: LD_EXP 107
49220: PUSH
49221: LD_VAR 0 3
49225: ARRAY
49226: IN
49227: OR
49228: IFFALSE 50469
// begin if un in mc_ape [ i ] then
49230: LD_VAR 0 1
49234: PUSH
49235: LD_EXP 106
49239: PUSH
49240: LD_VAR 0 3
49244: ARRAY
49245: IN
49246: IFFALSE 49285
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
49248: LD_ADDR_EXP 106
49252: PUSH
49253: LD_EXP 106
49257: PPUSH
49258: LD_VAR 0 3
49262: PPUSH
49263: LD_EXP 106
49267: PUSH
49268: LD_VAR 0 3
49272: ARRAY
49273: PUSH
49274: LD_VAR 0 1
49278: DIFF
49279: PPUSH
49280: CALL_OW 1
49284: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
49285: LD_VAR 0 1
49289: PUSH
49290: LD_EXP 107
49294: PUSH
49295: LD_VAR 0 3
49299: ARRAY
49300: IN
49301: IFFALSE 49325
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
49303: LD_ADDR_EXP 107
49307: PUSH
49308: LD_EXP 107
49312: PPUSH
49313: LD_VAR 0 3
49317: PPUSH
49318: EMPTY
49319: PPUSH
49320: CALL_OW 1
49324: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
49325: LD_VAR 0 1
49329: PPUSH
49330: CALL_OW 247
49334: PUSH
49335: LD_INT 2
49337: EQUAL
49338: PUSH
49339: LD_VAR 0 1
49343: PPUSH
49344: CALL_OW 110
49348: PUSH
49349: LD_INT 20
49351: EQUAL
49352: PUSH
49353: LD_VAR 0 1
49357: PUSH
49358: LD_EXP 99
49362: PUSH
49363: LD_VAR 0 3
49367: ARRAY
49368: IN
49369: OR
49370: PUSH
49371: LD_VAR 0 1
49375: PPUSH
49376: CALL_OW 264
49380: PUSH
49381: LD_INT 12
49383: PUSH
49384: LD_INT 51
49386: PUSH
49387: LD_INT 89
49389: PUSH
49390: LD_INT 32
49392: PUSH
49393: LD_INT 13
49395: PUSH
49396: LD_INT 52
49398: PUSH
49399: LD_INT 31
49401: PUSH
49402: EMPTY
49403: LIST
49404: LIST
49405: LIST
49406: LIST
49407: LIST
49408: LIST
49409: LIST
49410: IN
49411: OR
49412: AND
49413: IFFALSE 49721
// begin if un in mc_defender [ i ] then
49415: LD_VAR 0 1
49419: PUSH
49420: LD_EXP 99
49424: PUSH
49425: LD_VAR 0 3
49429: ARRAY
49430: IN
49431: IFFALSE 49470
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
49433: LD_ADDR_EXP 99
49437: PUSH
49438: LD_EXP 99
49442: PPUSH
49443: LD_VAR 0 3
49447: PPUSH
49448: LD_EXP 99
49452: PUSH
49453: LD_VAR 0 3
49457: ARRAY
49458: PUSH
49459: LD_VAR 0 1
49463: DIFF
49464: PPUSH
49465: CALL_OW 1
49469: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
49470: LD_ADDR_VAR 0 8
49474: PUSH
49475: LD_VAR 0 3
49479: PPUSH
49480: LD_INT 3
49482: PPUSH
49483: CALL 46091 0 2
49487: ST_TO_ADDR
// if fac then
49488: LD_VAR 0 8
49492: IFFALSE 49721
// begin for j in fac do
49494: LD_ADDR_VAR 0 4
49498: PUSH
49499: LD_VAR 0 8
49503: PUSH
49504: FOR_IN
49505: IFFALSE 49719
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
49507: LD_ADDR_VAR 0 9
49511: PUSH
49512: LD_VAR 0 8
49516: PPUSH
49517: LD_VAR 0 1
49521: PPUSH
49522: CALL_OW 265
49526: PPUSH
49527: LD_VAR 0 1
49531: PPUSH
49532: CALL_OW 262
49536: PPUSH
49537: LD_VAR 0 1
49541: PPUSH
49542: CALL_OW 263
49546: PPUSH
49547: LD_VAR 0 1
49551: PPUSH
49552: CALL_OW 264
49556: PPUSH
49557: CALL 54697 0 5
49561: ST_TO_ADDR
// if components then
49562: LD_VAR 0 9
49566: IFFALSE 49717
// begin if GetWeapon ( un ) = ar_control_tower then
49568: LD_VAR 0 1
49572: PPUSH
49573: CALL_OW 264
49577: PUSH
49578: LD_INT 31
49580: EQUAL
49581: IFFALSE 49698
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
49583: LD_VAR 0 1
49587: PPUSH
49588: CALL_OW 311
49592: PPUSH
49593: LD_INT 0
49595: PPUSH
49596: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
49600: LD_ADDR_EXP 117
49604: PUSH
49605: LD_EXP 117
49609: PPUSH
49610: LD_VAR 0 3
49614: PPUSH
49615: LD_EXP 117
49619: PUSH
49620: LD_VAR 0 3
49624: ARRAY
49625: PUSH
49626: LD_VAR 0 1
49630: PPUSH
49631: CALL_OW 311
49635: DIFF
49636: PPUSH
49637: CALL_OW 1
49641: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
49642: LD_ADDR_VAR 0 7
49646: PUSH
49647: LD_EXP 98
49651: PUSH
49652: LD_VAR 0 3
49656: ARRAY
49657: PPUSH
49658: LD_INT 1
49660: PPUSH
49661: LD_VAR 0 9
49665: PPUSH
49666: CALL_OW 2
49670: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
49671: LD_ADDR_EXP 98
49675: PUSH
49676: LD_EXP 98
49680: PPUSH
49681: LD_VAR 0 3
49685: PPUSH
49686: LD_VAR 0 7
49690: PPUSH
49691: CALL_OW 1
49695: ST_TO_ADDR
// end else
49696: GO 49715
// MC_InsertProduceList ( i , [ components ] ) ;
49698: LD_VAR 0 3
49702: PPUSH
49703: LD_VAR 0 9
49707: PUSH
49708: EMPTY
49709: LIST
49710: PPUSH
49711: CALL 45636 0 2
// break ;
49715: GO 49719
// end ; end ;
49717: GO 49504
49719: POP
49720: POP
// end ; end ; if GetType ( un ) = unit_building then
49721: LD_VAR 0 1
49725: PPUSH
49726: CALL_OW 247
49730: PUSH
49731: LD_INT 3
49733: EQUAL
49734: IFFALSE 50137
// begin btype := GetBType ( un ) ;
49736: LD_ADDR_VAR 0 5
49740: PUSH
49741: LD_VAR 0 1
49745: PPUSH
49746: CALL_OW 266
49750: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
49751: LD_VAR 0 5
49755: PUSH
49756: LD_INT 29
49758: PUSH
49759: LD_INT 30
49761: PUSH
49762: EMPTY
49763: LIST
49764: LIST
49765: IN
49766: IFFALSE 49839
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
49768: LD_VAR 0 1
49772: PPUSH
49773: CALL_OW 250
49777: PPUSH
49778: LD_VAR 0 1
49782: PPUSH
49783: CALL_OW 251
49787: PPUSH
49788: LD_VAR 0 1
49792: PPUSH
49793: CALL_OW 255
49797: PPUSH
49798: CALL_OW 440
49802: NOT
49803: IFFALSE 49839
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
49805: LD_VAR 0 1
49809: PPUSH
49810: CALL_OW 250
49814: PPUSH
49815: LD_VAR 0 1
49819: PPUSH
49820: CALL_OW 251
49824: PPUSH
49825: LD_VAR 0 1
49829: PPUSH
49830: CALL_OW 255
49834: PPUSH
49835: CALL_OW 441
// end ; if btype = b_warehouse then
49839: LD_VAR 0 5
49843: PUSH
49844: LD_INT 1
49846: EQUAL
49847: IFFALSE 49865
// begin btype := b_depot ;
49849: LD_ADDR_VAR 0 5
49853: PUSH
49854: LD_INT 0
49856: ST_TO_ADDR
// pos := 1 ;
49857: LD_ADDR_VAR 0 6
49861: PUSH
49862: LD_INT 1
49864: ST_TO_ADDR
// end ; if btype = b_factory then
49865: LD_VAR 0 5
49869: PUSH
49870: LD_INT 3
49872: EQUAL
49873: IFFALSE 49891
// begin btype := b_workshop ;
49875: LD_ADDR_VAR 0 5
49879: PUSH
49880: LD_INT 2
49882: ST_TO_ADDR
// pos := 1 ;
49883: LD_ADDR_VAR 0 6
49887: PUSH
49888: LD_INT 1
49890: ST_TO_ADDR
// end ; if btype = b_barracks then
49891: LD_VAR 0 5
49895: PUSH
49896: LD_INT 5
49898: EQUAL
49899: IFFALSE 49909
// btype := b_armoury ;
49901: LD_ADDR_VAR 0 5
49905: PUSH
49906: LD_INT 4
49908: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
49909: LD_VAR 0 5
49913: PUSH
49914: LD_INT 7
49916: PUSH
49917: LD_INT 8
49919: PUSH
49920: EMPTY
49921: LIST
49922: LIST
49923: IN
49924: IFFALSE 49934
// btype := b_lab ;
49926: LD_ADDR_VAR 0 5
49930: PUSH
49931: LD_INT 6
49933: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
49934: LD_ADDR_EXP 82
49938: PUSH
49939: LD_EXP 82
49943: PPUSH
49944: LD_VAR 0 3
49948: PUSH
49949: LD_EXP 82
49953: PUSH
49954: LD_VAR 0 3
49958: ARRAY
49959: PUSH
49960: LD_INT 1
49962: PLUS
49963: PUSH
49964: EMPTY
49965: LIST
49966: LIST
49967: PPUSH
49968: LD_VAR 0 5
49972: PUSH
49973: LD_VAR 0 1
49977: PPUSH
49978: CALL_OW 250
49982: PUSH
49983: LD_VAR 0 1
49987: PPUSH
49988: CALL_OW 251
49992: PUSH
49993: LD_VAR 0 1
49997: PPUSH
49998: CALL_OW 254
50002: PUSH
50003: EMPTY
50004: LIST
50005: LIST
50006: LIST
50007: LIST
50008: PPUSH
50009: CALL 57199 0 3
50013: ST_TO_ADDR
// if pos = 1 then
50014: LD_VAR 0 6
50018: PUSH
50019: LD_INT 1
50021: EQUAL
50022: IFFALSE 50137
// begin tmp := mc_build_list [ i ] ;
50024: LD_ADDR_VAR 0 7
50028: PUSH
50029: LD_EXP 82
50033: PUSH
50034: LD_VAR 0 3
50038: ARRAY
50039: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
50040: LD_VAR 0 7
50044: PPUSH
50045: LD_INT 2
50047: PUSH
50048: LD_INT 30
50050: PUSH
50051: LD_INT 0
50053: PUSH
50054: EMPTY
50055: LIST
50056: LIST
50057: PUSH
50058: LD_INT 30
50060: PUSH
50061: LD_INT 1
50063: PUSH
50064: EMPTY
50065: LIST
50066: LIST
50067: PUSH
50068: EMPTY
50069: LIST
50070: LIST
50071: LIST
50072: PPUSH
50073: CALL_OW 72
50077: IFFALSE 50087
// pos := 2 ;
50079: LD_ADDR_VAR 0 6
50083: PUSH
50084: LD_INT 2
50086: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
50087: LD_ADDR_VAR 0 7
50091: PUSH
50092: LD_VAR 0 7
50096: PPUSH
50097: LD_VAR 0 6
50101: PPUSH
50102: LD_VAR 0 7
50106: PPUSH
50107: CALL 57525 0 3
50111: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
50112: LD_ADDR_EXP 82
50116: PUSH
50117: LD_EXP 82
50121: PPUSH
50122: LD_VAR 0 3
50126: PPUSH
50127: LD_VAR 0 7
50131: PPUSH
50132: CALL_OW 1
50136: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
50137: LD_VAR 0 1
50141: PUSH
50142: LD_EXP 77
50146: PUSH
50147: LD_VAR 0 3
50151: ARRAY
50152: IN
50153: IFFALSE 50192
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
50155: LD_ADDR_EXP 77
50159: PUSH
50160: LD_EXP 77
50164: PPUSH
50165: LD_VAR 0 3
50169: PPUSH
50170: LD_EXP 77
50174: PUSH
50175: LD_VAR 0 3
50179: ARRAY
50180: PUSH
50181: LD_VAR 0 1
50185: DIFF
50186: PPUSH
50187: CALL_OW 1
50191: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
50192: LD_VAR 0 1
50196: PUSH
50197: LD_EXP 84
50201: PUSH
50202: LD_VAR 0 3
50206: ARRAY
50207: IN
50208: IFFALSE 50247
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
50210: LD_ADDR_EXP 84
50214: PUSH
50215: LD_EXP 84
50219: PPUSH
50220: LD_VAR 0 3
50224: PPUSH
50225: LD_EXP 84
50229: PUSH
50230: LD_VAR 0 3
50234: ARRAY
50235: PUSH
50236: LD_VAR 0 1
50240: DIFF
50241: PPUSH
50242: CALL_OW 1
50246: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
50247: LD_VAR 0 1
50251: PUSH
50252: LD_EXP 96
50256: PUSH
50257: LD_VAR 0 3
50261: ARRAY
50262: IN
50263: IFFALSE 50302
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
50265: LD_ADDR_EXP 96
50269: PUSH
50270: LD_EXP 96
50274: PPUSH
50275: LD_VAR 0 3
50279: PPUSH
50280: LD_EXP 96
50284: PUSH
50285: LD_VAR 0 3
50289: ARRAY
50290: PUSH
50291: LD_VAR 0 1
50295: DIFF
50296: PPUSH
50297: CALL_OW 1
50301: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
50302: LD_VAR 0 1
50306: PUSH
50307: LD_EXP 99
50311: PUSH
50312: LD_VAR 0 3
50316: ARRAY
50317: IN
50318: IFFALSE 50357
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
50320: LD_ADDR_EXP 99
50324: PUSH
50325: LD_EXP 99
50329: PPUSH
50330: LD_VAR 0 3
50334: PPUSH
50335: LD_EXP 99
50339: PUSH
50340: LD_VAR 0 3
50344: ARRAY
50345: PUSH
50346: LD_VAR 0 1
50350: DIFF
50351: PPUSH
50352: CALL_OW 1
50356: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
50357: LD_VAR 0 1
50361: PUSH
50362: LD_EXP 86
50366: PUSH
50367: LD_VAR 0 3
50371: ARRAY
50372: IN
50373: IFFALSE 50412
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
50375: LD_ADDR_EXP 86
50379: PUSH
50380: LD_EXP 86
50384: PPUSH
50385: LD_VAR 0 3
50389: PPUSH
50390: LD_EXP 86
50394: PUSH
50395: LD_VAR 0 3
50399: ARRAY
50400: PUSH
50401: LD_VAR 0 1
50405: DIFF
50406: PPUSH
50407: CALL_OW 1
50411: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
50412: LD_VAR 0 1
50416: PUSH
50417: LD_EXP 85
50421: PUSH
50422: LD_VAR 0 3
50426: ARRAY
50427: IN
50428: IFFALSE 50467
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
50430: LD_ADDR_EXP 85
50434: PUSH
50435: LD_EXP 85
50439: PPUSH
50440: LD_VAR 0 3
50444: PPUSH
50445: LD_EXP 85
50449: PUSH
50450: LD_VAR 0 3
50454: ARRAY
50455: PUSH
50456: LD_VAR 0 1
50460: DIFF
50461: PPUSH
50462: CALL_OW 1
50466: ST_TO_ADDR
// end ; break ;
50467: GO 50471
// end ;
50469: GO 49119
50471: POP
50472: POP
// end ;
50473: LD_VAR 0 2
50477: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
50478: LD_INT 0
50480: PPUSH
50481: PPUSH
50482: PPUSH
// if not mc_bases or not skirmish then
50483: LD_EXP 77
50487: NOT
50488: PUSH
50489: LD_EXP 75
50493: NOT
50494: OR
50495: IFFALSE 50499
// exit ;
50497: GO 50714
// for i = 1 to mc_bases do
50499: LD_ADDR_VAR 0 3
50503: PUSH
50504: DOUBLE
50505: LD_INT 1
50507: DEC
50508: ST_TO_ADDR
50509: LD_EXP 77
50513: PUSH
50514: FOR_TO
50515: IFFALSE 50712
// begin if building in mc_construct_list [ i ] then
50517: LD_VAR 0 1
50521: PUSH
50522: LD_EXP 84
50526: PUSH
50527: LD_VAR 0 3
50531: ARRAY
50532: IN
50533: IFFALSE 50710
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
50535: LD_ADDR_EXP 84
50539: PUSH
50540: LD_EXP 84
50544: PPUSH
50545: LD_VAR 0 3
50549: PPUSH
50550: LD_EXP 84
50554: PUSH
50555: LD_VAR 0 3
50559: ARRAY
50560: PUSH
50561: LD_VAR 0 1
50565: DIFF
50566: PPUSH
50567: CALL_OW 1
50571: ST_TO_ADDR
// if building in mc_lab [ i ] then
50572: LD_VAR 0 1
50576: PUSH
50577: LD_EXP 110
50581: PUSH
50582: LD_VAR 0 3
50586: ARRAY
50587: IN
50588: IFFALSE 50643
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
50590: LD_ADDR_EXP 111
50594: PUSH
50595: LD_EXP 111
50599: PPUSH
50600: LD_VAR 0 3
50604: PPUSH
50605: LD_EXP 111
50609: PUSH
50610: LD_VAR 0 3
50614: ARRAY
50615: PPUSH
50616: LD_INT 1
50618: PPUSH
50619: LD_EXP 111
50623: PUSH
50624: LD_VAR 0 3
50628: ARRAY
50629: PPUSH
50630: LD_INT 0
50632: PPUSH
50633: CALL 56617 0 4
50637: PPUSH
50638: CALL_OW 1
50642: ST_TO_ADDR
// if not building in mc_bases [ i ] then
50643: LD_VAR 0 1
50647: PUSH
50648: LD_EXP 77
50652: PUSH
50653: LD_VAR 0 3
50657: ARRAY
50658: IN
50659: NOT
50660: IFFALSE 50706
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
50662: LD_ADDR_EXP 77
50666: PUSH
50667: LD_EXP 77
50671: PPUSH
50672: LD_VAR 0 3
50676: PUSH
50677: LD_EXP 77
50681: PUSH
50682: LD_VAR 0 3
50686: ARRAY
50687: PUSH
50688: LD_INT 1
50690: PLUS
50691: PUSH
50692: EMPTY
50693: LIST
50694: LIST
50695: PPUSH
50696: LD_VAR 0 1
50700: PPUSH
50701: CALL 57199 0 3
50705: ST_TO_ADDR
// exit ;
50706: POP
50707: POP
50708: GO 50714
// end ; end ;
50710: GO 50514
50712: POP
50713: POP
// end ;
50714: LD_VAR 0 2
50718: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
50719: LD_INT 0
50721: PPUSH
50722: PPUSH
50723: PPUSH
50724: PPUSH
50725: PPUSH
50726: PPUSH
50727: PPUSH
// if not mc_bases or not skirmish then
50728: LD_EXP 77
50732: NOT
50733: PUSH
50734: LD_EXP 75
50738: NOT
50739: OR
50740: IFFALSE 50744
// exit ;
50742: GO 51405
// for i = 1 to mc_bases do
50744: LD_ADDR_VAR 0 3
50748: PUSH
50749: DOUBLE
50750: LD_INT 1
50752: DEC
50753: ST_TO_ADDR
50754: LD_EXP 77
50758: PUSH
50759: FOR_TO
50760: IFFALSE 51403
// begin if building in mc_construct_list [ i ] then
50762: LD_VAR 0 1
50766: PUSH
50767: LD_EXP 84
50771: PUSH
50772: LD_VAR 0 3
50776: ARRAY
50777: IN
50778: IFFALSE 51401
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
50780: LD_ADDR_EXP 84
50784: PUSH
50785: LD_EXP 84
50789: PPUSH
50790: LD_VAR 0 3
50794: PPUSH
50795: LD_EXP 84
50799: PUSH
50800: LD_VAR 0 3
50804: ARRAY
50805: PUSH
50806: LD_VAR 0 1
50810: DIFF
50811: PPUSH
50812: CALL_OW 1
50816: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
50817: LD_ADDR_EXP 77
50821: PUSH
50822: LD_EXP 77
50826: PPUSH
50827: LD_VAR 0 3
50831: PUSH
50832: LD_EXP 77
50836: PUSH
50837: LD_VAR 0 3
50841: ARRAY
50842: PUSH
50843: LD_INT 1
50845: PLUS
50846: PUSH
50847: EMPTY
50848: LIST
50849: LIST
50850: PPUSH
50851: LD_VAR 0 1
50855: PPUSH
50856: CALL 57199 0 3
50860: ST_TO_ADDR
// btype := GetBType ( building ) ;
50861: LD_ADDR_VAR 0 5
50865: PUSH
50866: LD_VAR 0 1
50870: PPUSH
50871: CALL_OW 266
50875: ST_TO_ADDR
// side := GetSide ( building ) ;
50876: LD_ADDR_VAR 0 8
50880: PUSH
50881: LD_VAR 0 1
50885: PPUSH
50886: CALL_OW 255
50890: ST_TO_ADDR
// if btype = b_lab then
50891: LD_VAR 0 5
50895: PUSH
50896: LD_INT 6
50898: EQUAL
50899: IFFALSE 50949
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
50901: LD_ADDR_EXP 110
50905: PUSH
50906: LD_EXP 110
50910: PPUSH
50911: LD_VAR 0 3
50915: PUSH
50916: LD_EXP 110
50920: PUSH
50921: LD_VAR 0 3
50925: ARRAY
50926: PUSH
50927: LD_INT 1
50929: PLUS
50930: PUSH
50931: EMPTY
50932: LIST
50933: LIST
50934: PPUSH
50935: LD_VAR 0 1
50939: PPUSH
50940: CALL 57199 0 3
50944: ST_TO_ADDR
// exit ;
50945: POP
50946: POP
50947: GO 51405
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
50949: LD_VAR 0 5
50953: PUSH
50954: LD_INT 0
50956: PUSH
50957: LD_INT 2
50959: PUSH
50960: LD_INT 4
50962: PUSH
50963: EMPTY
50964: LIST
50965: LIST
50966: LIST
50967: IN
50968: IFFALSE 51092
// begin if btype = b_armoury then
50970: LD_VAR 0 5
50974: PUSH
50975: LD_INT 4
50977: EQUAL
50978: IFFALSE 50988
// btype := b_barracks ;
50980: LD_ADDR_VAR 0 5
50984: PUSH
50985: LD_INT 5
50987: ST_TO_ADDR
// if btype = b_depot then
50988: LD_VAR 0 5
50992: PUSH
50993: LD_INT 0
50995: EQUAL
50996: IFFALSE 51006
// btype := b_warehouse ;
50998: LD_ADDR_VAR 0 5
51002: PUSH
51003: LD_INT 1
51005: ST_TO_ADDR
// if btype = b_workshop then
51006: LD_VAR 0 5
51010: PUSH
51011: LD_INT 2
51013: EQUAL
51014: IFFALSE 51024
// btype := b_factory ;
51016: LD_ADDR_VAR 0 5
51020: PUSH
51021: LD_INT 3
51023: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
51024: LD_VAR 0 5
51028: PPUSH
51029: LD_VAR 0 8
51033: PPUSH
51034: CALL_OW 323
51038: PUSH
51039: LD_INT 1
51041: EQUAL
51042: IFFALSE 51088
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
51044: LD_ADDR_EXP 109
51048: PUSH
51049: LD_EXP 109
51053: PPUSH
51054: LD_VAR 0 3
51058: PUSH
51059: LD_EXP 109
51063: PUSH
51064: LD_VAR 0 3
51068: ARRAY
51069: PUSH
51070: LD_INT 1
51072: PLUS
51073: PUSH
51074: EMPTY
51075: LIST
51076: LIST
51077: PPUSH
51078: LD_VAR 0 1
51082: PPUSH
51083: CALL 57199 0 3
51087: ST_TO_ADDR
// exit ;
51088: POP
51089: POP
51090: GO 51405
// end ; if btype in [ b_bunker , b_turret ] then
51092: LD_VAR 0 5
51096: PUSH
51097: LD_INT 32
51099: PUSH
51100: LD_INT 33
51102: PUSH
51103: EMPTY
51104: LIST
51105: LIST
51106: IN
51107: IFFALSE 51397
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
51109: LD_ADDR_EXP 85
51113: PUSH
51114: LD_EXP 85
51118: PPUSH
51119: LD_VAR 0 3
51123: PUSH
51124: LD_EXP 85
51128: PUSH
51129: LD_VAR 0 3
51133: ARRAY
51134: PUSH
51135: LD_INT 1
51137: PLUS
51138: PUSH
51139: EMPTY
51140: LIST
51141: LIST
51142: PPUSH
51143: LD_VAR 0 1
51147: PPUSH
51148: CALL 57199 0 3
51152: ST_TO_ADDR
// if btype = b_bunker then
51153: LD_VAR 0 5
51157: PUSH
51158: LD_INT 32
51160: EQUAL
51161: IFFALSE 51397
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
51163: LD_ADDR_EXP 86
51167: PUSH
51168: LD_EXP 86
51172: PPUSH
51173: LD_VAR 0 3
51177: PUSH
51178: LD_EXP 86
51182: PUSH
51183: LD_VAR 0 3
51187: ARRAY
51188: PUSH
51189: LD_INT 1
51191: PLUS
51192: PUSH
51193: EMPTY
51194: LIST
51195: LIST
51196: PPUSH
51197: LD_VAR 0 1
51201: PPUSH
51202: CALL 57199 0 3
51206: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
51207: LD_ADDR_VAR 0 6
51211: PUSH
51212: LD_EXP 77
51216: PUSH
51217: LD_VAR 0 3
51221: ARRAY
51222: PPUSH
51223: LD_INT 25
51225: PUSH
51226: LD_INT 1
51228: PUSH
51229: EMPTY
51230: LIST
51231: LIST
51232: PUSH
51233: LD_INT 3
51235: PUSH
51236: LD_INT 54
51238: PUSH
51239: EMPTY
51240: LIST
51241: PUSH
51242: EMPTY
51243: LIST
51244: LIST
51245: PUSH
51246: EMPTY
51247: LIST
51248: LIST
51249: PPUSH
51250: CALL_OW 72
51254: ST_TO_ADDR
// if tmp then
51255: LD_VAR 0 6
51259: IFFALSE 51265
// exit ;
51261: POP
51262: POP
51263: GO 51405
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
51265: LD_ADDR_VAR 0 6
51269: PUSH
51270: LD_EXP 77
51274: PUSH
51275: LD_VAR 0 3
51279: ARRAY
51280: PPUSH
51281: LD_INT 2
51283: PUSH
51284: LD_INT 30
51286: PUSH
51287: LD_INT 4
51289: PUSH
51290: EMPTY
51291: LIST
51292: LIST
51293: PUSH
51294: LD_INT 30
51296: PUSH
51297: LD_INT 5
51299: PUSH
51300: EMPTY
51301: LIST
51302: LIST
51303: PUSH
51304: EMPTY
51305: LIST
51306: LIST
51307: LIST
51308: PPUSH
51309: CALL_OW 72
51313: ST_TO_ADDR
// if not tmp then
51314: LD_VAR 0 6
51318: NOT
51319: IFFALSE 51325
// exit ;
51321: POP
51322: POP
51323: GO 51405
// for j in tmp do
51325: LD_ADDR_VAR 0 4
51329: PUSH
51330: LD_VAR 0 6
51334: PUSH
51335: FOR_IN
51336: IFFALSE 51395
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
51338: LD_ADDR_VAR 0 7
51342: PUSH
51343: LD_VAR 0 4
51347: PPUSH
51348: CALL_OW 313
51352: PPUSH
51353: LD_INT 25
51355: PUSH
51356: LD_INT 1
51358: PUSH
51359: EMPTY
51360: LIST
51361: LIST
51362: PPUSH
51363: CALL_OW 72
51367: ST_TO_ADDR
// if units then
51368: LD_VAR 0 7
51372: IFFALSE 51393
// begin ComExitBuilding ( units [ 1 ] ) ;
51374: LD_VAR 0 7
51378: PUSH
51379: LD_INT 1
51381: ARRAY
51382: PPUSH
51383: CALL_OW 122
// exit ;
51387: POP
51388: POP
51389: POP
51390: POP
51391: GO 51405
// end ; end ;
51393: GO 51335
51395: POP
51396: POP
// end ; end ; exit ;
51397: POP
51398: POP
51399: GO 51405
// end ; end ;
51401: GO 50759
51403: POP
51404: POP
// end ;
51405: LD_VAR 0 2
51409: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
51410: LD_INT 0
51412: PPUSH
51413: PPUSH
51414: PPUSH
51415: PPUSH
51416: PPUSH
51417: PPUSH
51418: PPUSH
// if not mc_bases or not skirmish then
51419: LD_EXP 77
51423: NOT
51424: PUSH
51425: LD_EXP 75
51429: NOT
51430: OR
51431: IFFALSE 51435
// exit ;
51433: GO 51700
// btype := GetBType ( building ) ;
51435: LD_ADDR_VAR 0 6
51439: PUSH
51440: LD_VAR 0 1
51444: PPUSH
51445: CALL_OW 266
51449: ST_TO_ADDR
// x := GetX ( building ) ;
51450: LD_ADDR_VAR 0 7
51454: PUSH
51455: LD_VAR 0 1
51459: PPUSH
51460: CALL_OW 250
51464: ST_TO_ADDR
// y := GetY ( building ) ;
51465: LD_ADDR_VAR 0 8
51469: PUSH
51470: LD_VAR 0 1
51474: PPUSH
51475: CALL_OW 251
51479: ST_TO_ADDR
// d := GetDir ( building ) ;
51480: LD_ADDR_VAR 0 9
51484: PUSH
51485: LD_VAR 0 1
51489: PPUSH
51490: CALL_OW 254
51494: ST_TO_ADDR
// for i = 1 to mc_bases do
51495: LD_ADDR_VAR 0 4
51499: PUSH
51500: DOUBLE
51501: LD_INT 1
51503: DEC
51504: ST_TO_ADDR
51505: LD_EXP 77
51509: PUSH
51510: FOR_TO
51511: IFFALSE 51698
// begin if not mc_build_list [ i ] then
51513: LD_EXP 82
51517: PUSH
51518: LD_VAR 0 4
51522: ARRAY
51523: NOT
51524: IFFALSE 51528
// continue ;
51526: GO 51510
// for j := 1 to mc_build_list [ i ] do
51528: LD_ADDR_VAR 0 5
51532: PUSH
51533: DOUBLE
51534: LD_INT 1
51536: DEC
51537: ST_TO_ADDR
51538: LD_EXP 82
51542: PUSH
51543: LD_VAR 0 4
51547: ARRAY
51548: PUSH
51549: FOR_TO
51550: IFFALSE 51694
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
51552: LD_VAR 0 6
51556: PUSH
51557: LD_VAR 0 7
51561: PUSH
51562: LD_VAR 0 8
51566: PUSH
51567: LD_VAR 0 9
51571: PUSH
51572: EMPTY
51573: LIST
51574: LIST
51575: LIST
51576: LIST
51577: PPUSH
51578: LD_EXP 82
51582: PUSH
51583: LD_VAR 0 4
51587: ARRAY
51588: PUSH
51589: LD_VAR 0 5
51593: ARRAY
51594: PPUSH
51595: CALL 63379 0 2
51599: IFFALSE 51692
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
51601: LD_ADDR_EXP 82
51605: PUSH
51606: LD_EXP 82
51610: PPUSH
51611: LD_VAR 0 4
51615: PPUSH
51616: LD_EXP 82
51620: PUSH
51621: LD_VAR 0 4
51625: ARRAY
51626: PPUSH
51627: LD_VAR 0 5
51631: PPUSH
51632: CALL_OW 3
51636: PPUSH
51637: CALL_OW 1
51641: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
51642: LD_ADDR_EXP 84
51646: PUSH
51647: LD_EXP 84
51651: PPUSH
51652: LD_VAR 0 4
51656: PUSH
51657: LD_EXP 84
51661: PUSH
51662: LD_VAR 0 4
51666: ARRAY
51667: PUSH
51668: LD_INT 1
51670: PLUS
51671: PUSH
51672: EMPTY
51673: LIST
51674: LIST
51675: PPUSH
51676: LD_VAR 0 1
51680: PPUSH
51681: CALL 57199 0 3
51685: ST_TO_ADDR
// exit ;
51686: POP
51687: POP
51688: POP
51689: POP
51690: GO 51700
// end ;
51692: GO 51549
51694: POP
51695: POP
// end ;
51696: GO 51510
51698: POP
51699: POP
// end ;
51700: LD_VAR 0 3
51704: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
51705: LD_INT 0
51707: PPUSH
51708: PPUSH
51709: PPUSH
// if not mc_bases or not skirmish then
51710: LD_EXP 77
51714: NOT
51715: PUSH
51716: LD_EXP 75
51720: NOT
51721: OR
51722: IFFALSE 51726
// exit ;
51724: GO 51916
// for i = 1 to mc_bases do
51726: LD_ADDR_VAR 0 4
51730: PUSH
51731: DOUBLE
51732: LD_INT 1
51734: DEC
51735: ST_TO_ADDR
51736: LD_EXP 77
51740: PUSH
51741: FOR_TO
51742: IFFALSE 51829
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
51744: LD_VAR 0 1
51748: PUSH
51749: LD_EXP 85
51753: PUSH
51754: LD_VAR 0 4
51758: ARRAY
51759: IN
51760: PUSH
51761: LD_VAR 0 1
51765: PUSH
51766: LD_EXP 86
51770: PUSH
51771: LD_VAR 0 4
51775: ARRAY
51776: IN
51777: NOT
51778: AND
51779: IFFALSE 51827
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
51781: LD_ADDR_EXP 86
51785: PUSH
51786: LD_EXP 86
51790: PPUSH
51791: LD_VAR 0 4
51795: PUSH
51796: LD_EXP 86
51800: PUSH
51801: LD_VAR 0 4
51805: ARRAY
51806: PUSH
51807: LD_INT 1
51809: PLUS
51810: PUSH
51811: EMPTY
51812: LIST
51813: LIST
51814: PPUSH
51815: LD_VAR 0 1
51819: PPUSH
51820: CALL 57199 0 3
51824: ST_TO_ADDR
// break ;
51825: GO 51829
// end ; end ;
51827: GO 51741
51829: POP
51830: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
51831: LD_VAR 0 1
51835: PPUSH
51836: CALL_OW 257
51840: PUSH
51841: LD_EXP 103
51845: IN
51846: PUSH
51847: LD_VAR 0 1
51851: PPUSH
51852: CALL_OW 266
51856: PUSH
51857: LD_INT 5
51859: EQUAL
51860: AND
51861: PUSH
51862: LD_VAR 0 2
51866: PPUSH
51867: CALL_OW 110
51871: PUSH
51872: LD_INT 18
51874: NONEQUAL
51875: AND
51876: IFFALSE 51916
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
51878: LD_VAR 0 2
51882: PPUSH
51883: CALL_OW 257
51887: PUSH
51888: LD_INT 5
51890: PUSH
51891: LD_INT 8
51893: PUSH
51894: LD_INT 9
51896: PUSH
51897: EMPTY
51898: LIST
51899: LIST
51900: LIST
51901: IN
51902: IFFALSE 51916
// SetClass ( unit , 1 ) ;
51904: LD_VAR 0 2
51908: PPUSH
51909: LD_INT 1
51911: PPUSH
51912: CALL_OW 336
// end ;
51916: LD_VAR 0 3
51920: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
51921: LD_INT 0
51923: PPUSH
51924: PPUSH
// if not mc_bases or not skirmish then
51925: LD_EXP 77
51929: NOT
51930: PUSH
51931: LD_EXP 75
51935: NOT
51936: OR
51937: IFFALSE 51941
// exit ;
51939: GO 52057
// if GetLives ( abandoned_vehicle ) > 250 then
51941: LD_VAR 0 2
51945: PPUSH
51946: CALL_OW 256
51950: PUSH
51951: LD_INT 250
51953: GREATER
51954: IFFALSE 51958
// exit ;
51956: GO 52057
// for i = 1 to mc_bases do
51958: LD_ADDR_VAR 0 6
51962: PUSH
51963: DOUBLE
51964: LD_INT 1
51966: DEC
51967: ST_TO_ADDR
51968: LD_EXP 77
51972: PUSH
51973: FOR_TO
51974: IFFALSE 52055
// begin if driver in mc_bases [ i ] then
51976: LD_VAR 0 1
51980: PUSH
51981: LD_EXP 77
51985: PUSH
51986: LD_VAR 0 6
51990: ARRAY
51991: IN
51992: IFFALSE 52053
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
51994: LD_VAR 0 1
51998: PPUSH
51999: LD_EXP 77
52003: PUSH
52004: LD_VAR 0 6
52008: ARRAY
52009: PPUSH
52010: LD_INT 2
52012: PUSH
52013: LD_INT 30
52015: PUSH
52016: LD_INT 0
52018: PUSH
52019: EMPTY
52020: LIST
52021: LIST
52022: PUSH
52023: LD_INT 30
52025: PUSH
52026: LD_INT 1
52028: PUSH
52029: EMPTY
52030: LIST
52031: LIST
52032: PUSH
52033: EMPTY
52034: LIST
52035: LIST
52036: LIST
52037: PPUSH
52038: CALL_OW 72
52042: PUSH
52043: LD_INT 1
52045: ARRAY
52046: PPUSH
52047: CALL 90407 0 2
// break ;
52051: GO 52055
// end ; end ;
52053: GO 51973
52055: POP
52056: POP
// end ; end_of_file
52057: LD_VAR 0 5
52061: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
52062: LD_INT 0
52064: PPUSH
52065: PPUSH
// if exist_mode then
52066: LD_VAR 0 2
52070: IFFALSE 52095
// unit := CreateCharacter ( prefix & ident ) else
52072: LD_ADDR_VAR 0 5
52076: PUSH
52077: LD_VAR 0 3
52081: PUSH
52082: LD_VAR 0 1
52086: STR
52087: PPUSH
52088: CALL_OW 34
52092: ST_TO_ADDR
52093: GO 52110
// unit := NewCharacter ( ident ) ;
52095: LD_ADDR_VAR 0 5
52099: PUSH
52100: LD_VAR 0 1
52104: PPUSH
52105: CALL_OW 25
52109: ST_TO_ADDR
// result := unit ;
52110: LD_ADDR_VAR 0 4
52114: PUSH
52115: LD_VAR 0 5
52119: ST_TO_ADDR
// end ;
52120: LD_VAR 0 4
52124: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
52125: LD_INT 0
52127: PPUSH
52128: PPUSH
// if not side or not nation then
52129: LD_VAR 0 1
52133: NOT
52134: PUSH
52135: LD_VAR 0 2
52139: NOT
52140: OR
52141: IFFALSE 52145
// exit ;
52143: GO 52913
// case nation of nation_american :
52145: LD_VAR 0 2
52149: PUSH
52150: LD_INT 1
52152: DOUBLE
52153: EQUAL
52154: IFTRUE 52158
52156: GO 52372
52158: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
52159: LD_ADDR_VAR 0 4
52163: PUSH
52164: LD_INT 35
52166: PUSH
52167: LD_INT 45
52169: PUSH
52170: LD_INT 46
52172: PUSH
52173: LD_INT 47
52175: PUSH
52176: LD_INT 82
52178: PUSH
52179: LD_INT 83
52181: PUSH
52182: LD_INT 84
52184: PUSH
52185: LD_INT 85
52187: PUSH
52188: LD_INT 86
52190: PUSH
52191: LD_INT 1
52193: PUSH
52194: LD_INT 2
52196: PUSH
52197: LD_INT 6
52199: PUSH
52200: LD_INT 15
52202: PUSH
52203: LD_INT 16
52205: PUSH
52206: LD_INT 7
52208: PUSH
52209: LD_INT 12
52211: PUSH
52212: LD_INT 13
52214: PUSH
52215: LD_INT 10
52217: PUSH
52218: LD_INT 14
52220: PUSH
52221: LD_INT 20
52223: PUSH
52224: LD_INT 21
52226: PUSH
52227: LD_INT 22
52229: PUSH
52230: LD_INT 25
52232: PUSH
52233: LD_INT 32
52235: PUSH
52236: LD_INT 27
52238: PUSH
52239: LD_INT 36
52241: PUSH
52242: LD_INT 69
52244: PUSH
52245: LD_INT 39
52247: PUSH
52248: LD_INT 34
52250: PUSH
52251: LD_INT 40
52253: PUSH
52254: LD_INT 48
52256: PUSH
52257: LD_INT 49
52259: PUSH
52260: LD_INT 50
52262: PUSH
52263: LD_INT 51
52265: PUSH
52266: LD_INT 52
52268: PUSH
52269: LD_INT 53
52271: PUSH
52272: LD_INT 54
52274: PUSH
52275: LD_INT 55
52277: PUSH
52278: LD_INT 56
52280: PUSH
52281: LD_INT 57
52283: PUSH
52284: LD_INT 58
52286: PUSH
52287: LD_INT 59
52289: PUSH
52290: LD_INT 60
52292: PUSH
52293: LD_INT 61
52295: PUSH
52296: LD_INT 62
52298: PUSH
52299: LD_INT 80
52301: PUSH
52302: LD_INT 82
52304: PUSH
52305: LD_INT 83
52307: PUSH
52308: LD_INT 84
52310: PUSH
52311: LD_INT 85
52313: PUSH
52314: LD_INT 86
52316: PUSH
52317: EMPTY
52318: LIST
52319: LIST
52320: LIST
52321: LIST
52322: LIST
52323: LIST
52324: LIST
52325: LIST
52326: LIST
52327: LIST
52328: LIST
52329: LIST
52330: LIST
52331: LIST
52332: LIST
52333: LIST
52334: LIST
52335: LIST
52336: LIST
52337: LIST
52338: LIST
52339: LIST
52340: LIST
52341: LIST
52342: LIST
52343: LIST
52344: LIST
52345: LIST
52346: LIST
52347: LIST
52348: LIST
52349: LIST
52350: LIST
52351: LIST
52352: LIST
52353: LIST
52354: LIST
52355: LIST
52356: LIST
52357: LIST
52358: LIST
52359: LIST
52360: LIST
52361: LIST
52362: LIST
52363: LIST
52364: LIST
52365: LIST
52366: LIST
52367: LIST
52368: LIST
52369: ST_TO_ADDR
52370: GO 52837
52372: LD_INT 2
52374: DOUBLE
52375: EQUAL
52376: IFTRUE 52380
52378: GO 52606
52380: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
52381: LD_ADDR_VAR 0 4
52385: PUSH
52386: LD_INT 35
52388: PUSH
52389: LD_INT 45
52391: PUSH
52392: LD_INT 46
52394: PUSH
52395: LD_INT 47
52397: PUSH
52398: LD_INT 82
52400: PUSH
52401: LD_INT 83
52403: PUSH
52404: LD_INT 84
52406: PUSH
52407: LD_INT 85
52409: PUSH
52410: LD_INT 87
52412: PUSH
52413: LD_INT 70
52415: PUSH
52416: LD_INT 1
52418: PUSH
52419: LD_INT 11
52421: PUSH
52422: LD_INT 3
52424: PUSH
52425: LD_INT 4
52427: PUSH
52428: LD_INT 5
52430: PUSH
52431: LD_INT 6
52433: PUSH
52434: LD_INT 15
52436: PUSH
52437: LD_INT 18
52439: PUSH
52440: LD_INT 7
52442: PUSH
52443: LD_INT 17
52445: PUSH
52446: LD_INT 8
52448: PUSH
52449: LD_INT 20
52451: PUSH
52452: LD_INT 21
52454: PUSH
52455: LD_INT 22
52457: PUSH
52458: LD_INT 72
52460: PUSH
52461: LD_INT 26
52463: PUSH
52464: LD_INT 69
52466: PUSH
52467: LD_INT 39
52469: PUSH
52470: LD_INT 40
52472: PUSH
52473: LD_INT 41
52475: PUSH
52476: LD_INT 42
52478: PUSH
52479: LD_INT 43
52481: PUSH
52482: LD_INT 48
52484: PUSH
52485: LD_INT 49
52487: PUSH
52488: LD_INT 50
52490: PUSH
52491: LD_INT 51
52493: PUSH
52494: LD_INT 52
52496: PUSH
52497: LD_INT 53
52499: PUSH
52500: LD_INT 54
52502: PUSH
52503: LD_INT 55
52505: PUSH
52506: LD_INT 56
52508: PUSH
52509: LD_INT 60
52511: PUSH
52512: LD_INT 61
52514: PUSH
52515: LD_INT 62
52517: PUSH
52518: LD_INT 66
52520: PUSH
52521: LD_INT 67
52523: PUSH
52524: LD_INT 68
52526: PUSH
52527: LD_INT 81
52529: PUSH
52530: LD_INT 82
52532: PUSH
52533: LD_INT 83
52535: PUSH
52536: LD_INT 84
52538: PUSH
52539: LD_INT 85
52541: PUSH
52542: LD_INT 87
52544: PUSH
52545: LD_INT 88
52547: PUSH
52548: EMPTY
52549: LIST
52550: LIST
52551: LIST
52552: LIST
52553: LIST
52554: LIST
52555: LIST
52556: LIST
52557: LIST
52558: LIST
52559: LIST
52560: LIST
52561: LIST
52562: LIST
52563: LIST
52564: LIST
52565: LIST
52566: LIST
52567: LIST
52568: LIST
52569: LIST
52570: LIST
52571: LIST
52572: LIST
52573: LIST
52574: LIST
52575: LIST
52576: LIST
52577: LIST
52578: LIST
52579: LIST
52580: LIST
52581: LIST
52582: LIST
52583: LIST
52584: LIST
52585: LIST
52586: LIST
52587: LIST
52588: LIST
52589: LIST
52590: LIST
52591: LIST
52592: LIST
52593: LIST
52594: LIST
52595: LIST
52596: LIST
52597: LIST
52598: LIST
52599: LIST
52600: LIST
52601: LIST
52602: LIST
52603: ST_TO_ADDR
52604: GO 52837
52606: LD_INT 3
52608: DOUBLE
52609: EQUAL
52610: IFTRUE 52614
52612: GO 52836
52614: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
52615: LD_ADDR_VAR 0 4
52619: PUSH
52620: LD_INT 46
52622: PUSH
52623: LD_INT 47
52625: PUSH
52626: LD_INT 1
52628: PUSH
52629: LD_INT 2
52631: PUSH
52632: LD_INT 82
52634: PUSH
52635: LD_INT 83
52637: PUSH
52638: LD_INT 84
52640: PUSH
52641: LD_INT 85
52643: PUSH
52644: LD_INT 86
52646: PUSH
52647: LD_INT 11
52649: PUSH
52650: LD_INT 9
52652: PUSH
52653: LD_INT 20
52655: PUSH
52656: LD_INT 19
52658: PUSH
52659: LD_INT 21
52661: PUSH
52662: LD_INT 24
52664: PUSH
52665: LD_INT 22
52667: PUSH
52668: LD_INT 25
52670: PUSH
52671: LD_INT 28
52673: PUSH
52674: LD_INT 29
52676: PUSH
52677: LD_INT 30
52679: PUSH
52680: LD_INT 31
52682: PUSH
52683: LD_INT 37
52685: PUSH
52686: LD_INT 38
52688: PUSH
52689: LD_INT 32
52691: PUSH
52692: LD_INT 27
52694: PUSH
52695: LD_INT 33
52697: PUSH
52698: LD_INT 69
52700: PUSH
52701: LD_INT 39
52703: PUSH
52704: LD_INT 34
52706: PUSH
52707: LD_INT 40
52709: PUSH
52710: LD_INT 71
52712: PUSH
52713: LD_INT 23
52715: PUSH
52716: LD_INT 44
52718: PUSH
52719: LD_INT 48
52721: PUSH
52722: LD_INT 49
52724: PUSH
52725: LD_INT 50
52727: PUSH
52728: LD_INT 51
52730: PUSH
52731: LD_INT 52
52733: PUSH
52734: LD_INT 53
52736: PUSH
52737: LD_INT 54
52739: PUSH
52740: LD_INT 55
52742: PUSH
52743: LD_INT 56
52745: PUSH
52746: LD_INT 57
52748: PUSH
52749: LD_INT 58
52751: PUSH
52752: LD_INT 59
52754: PUSH
52755: LD_INT 63
52757: PUSH
52758: LD_INT 64
52760: PUSH
52761: LD_INT 65
52763: PUSH
52764: LD_INT 82
52766: PUSH
52767: LD_INT 83
52769: PUSH
52770: LD_INT 84
52772: PUSH
52773: LD_INT 85
52775: PUSH
52776: LD_INT 86
52778: PUSH
52779: EMPTY
52780: LIST
52781: LIST
52782: LIST
52783: LIST
52784: LIST
52785: LIST
52786: LIST
52787: LIST
52788: LIST
52789: LIST
52790: LIST
52791: LIST
52792: LIST
52793: LIST
52794: LIST
52795: LIST
52796: LIST
52797: LIST
52798: LIST
52799: LIST
52800: LIST
52801: LIST
52802: LIST
52803: LIST
52804: LIST
52805: LIST
52806: LIST
52807: LIST
52808: LIST
52809: LIST
52810: LIST
52811: LIST
52812: LIST
52813: LIST
52814: LIST
52815: LIST
52816: LIST
52817: LIST
52818: LIST
52819: LIST
52820: LIST
52821: LIST
52822: LIST
52823: LIST
52824: LIST
52825: LIST
52826: LIST
52827: LIST
52828: LIST
52829: LIST
52830: LIST
52831: LIST
52832: LIST
52833: ST_TO_ADDR
52834: GO 52837
52836: POP
// if state > - 1 and state < 3 then
52837: LD_VAR 0 3
52841: PUSH
52842: LD_INT 1
52844: NEG
52845: GREATER
52846: PUSH
52847: LD_VAR 0 3
52851: PUSH
52852: LD_INT 3
52854: LESS
52855: AND
52856: IFFALSE 52913
// for i in result do
52858: LD_ADDR_VAR 0 5
52862: PUSH
52863: LD_VAR 0 4
52867: PUSH
52868: FOR_IN
52869: IFFALSE 52911
// if GetTech ( i , side ) <> state then
52871: LD_VAR 0 5
52875: PPUSH
52876: LD_VAR 0 1
52880: PPUSH
52881: CALL_OW 321
52885: PUSH
52886: LD_VAR 0 3
52890: NONEQUAL
52891: IFFALSE 52909
// result := result diff i ;
52893: LD_ADDR_VAR 0 4
52897: PUSH
52898: LD_VAR 0 4
52902: PUSH
52903: LD_VAR 0 5
52907: DIFF
52908: ST_TO_ADDR
52909: GO 52868
52911: POP
52912: POP
// end ;
52913: LD_VAR 0 4
52917: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
52918: LD_INT 0
52920: PPUSH
52921: PPUSH
52922: PPUSH
// result := true ;
52923: LD_ADDR_VAR 0 3
52927: PUSH
52928: LD_INT 1
52930: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
52931: LD_ADDR_VAR 0 5
52935: PUSH
52936: LD_VAR 0 2
52940: PPUSH
52941: CALL_OW 480
52945: ST_TO_ADDR
// if not tmp then
52946: LD_VAR 0 5
52950: NOT
52951: IFFALSE 52955
// exit ;
52953: GO 53004
// for i in tmp do
52955: LD_ADDR_VAR 0 4
52959: PUSH
52960: LD_VAR 0 5
52964: PUSH
52965: FOR_IN
52966: IFFALSE 53002
// if GetTech ( i , side ) <> state_researched then
52968: LD_VAR 0 4
52972: PPUSH
52973: LD_VAR 0 1
52977: PPUSH
52978: CALL_OW 321
52982: PUSH
52983: LD_INT 2
52985: NONEQUAL
52986: IFFALSE 53000
// begin result := false ;
52988: LD_ADDR_VAR 0 3
52992: PUSH
52993: LD_INT 0
52995: ST_TO_ADDR
// exit ;
52996: POP
52997: POP
52998: GO 53004
// end ;
53000: GO 52965
53002: POP
53003: POP
// end ;
53004: LD_VAR 0 3
53008: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
53009: LD_INT 0
53011: PPUSH
53012: PPUSH
53013: PPUSH
53014: PPUSH
53015: PPUSH
53016: PPUSH
53017: PPUSH
53018: PPUSH
53019: PPUSH
53020: PPUSH
53021: PPUSH
53022: PPUSH
53023: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
53024: LD_VAR 0 1
53028: NOT
53029: PUSH
53030: LD_VAR 0 1
53034: PPUSH
53035: CALL_OW 257
53039: PUSH
53040: LD_INT 9
53042: NONEQUAL
53043: OR
53044: IFFALSE 53048
// exit ;
53046: GO 53621
// side := GetSide ( unit ) ;
53048: LD_ADDR_VAR 0 9
53052: PUSH
53053: LD_VAR 0 1
53057: PPUSH
53058: CALL_OW 255
53062: ST_TO_ADDR
// tech_space := tech_spacanom ;
53063: LD_ADDR_VAR 0 12
53067: PUSH
53068: LD_INT 29
53070: ST_TO_ADDR
// tech_time := tech_taurad ;
53071: LD_ADDR_VAR 0 13
53075: PUSH
53076: LD_INT 28
53078: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
53079: LD_ADDR_VAR 0 11
53083: PUSH
53084: LD_VAR 0 1
53088: PPUSH
53089: CALL_OW 310
53093: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
53094: LD_VAR 0 11
53098: PPUSH
53099: CALL_OW 247
53103: PUSH
53104: LD_INT 2
53106: EQUAL
53107: IFFALSE 53111
// exit ;
53109: GO 53621
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
53111: LD_ADDR_VAR 0 8
53115: PUSH
53116: LD_INT 81
53118: PUSH
53119: LD_VAR 0 9
53123: PUSH
53124: EMPTY
53125: LIST
53126: LIST
53127: PUSH
53128: LD_INT 3
53130: PUSH
53131: LD_INT 21
53133: PUSH
53134: LD_INT 3
53136: PUSH
53137: EMPTY
53138: LIST
53139: LIST
53140: PUSH
53141: EMPTY
53142: LIST
53143: LIST
53144: PUSH
53145: EMPTY
53146: LIST
53147: LIST
53148: PPUSH
53149: CALL_OW 69
53153: ST_TO_ADDR
// if not tmp then
53154: LD_VAR 0 8
53158: NOT
53159: IFFALSE 53163
// exit ;
53161: GO 53621
// if in_unit then
53163: LD_VAR 0 11
53167: IFFALSE 53191
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
53169: LD_ADDR_VAR 0 10
53173: PUSH
53174: LD_VAR 0 8
53178: PPUSH
53179: LD_VAR 0 11
53183: PPUSH
53184: CALL_OW 74
53188: ST_TO_ADDR
53189: GO 53211
// enemy := NearestUnitToUnit ( tmp , unit ) ;
53191: LD_ADDR_VAR 0 10
53195: PUSH
53196: LD_VAR 0 8
53200: PPUSH
53201: LD_VAR 0 1
53205: PPUSH
53206: CALL_OW 74
53210: ST_TO_ADDR
// if not enemy then
53211: LD_VAR 0 10
53215: NOT
53216: IFFALSE 53220
// exit ;
53218: GO 53621
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
53220: LD_VAR 0 11
53224: PUSH
53225: LD_VAR 0 11
53229: PPUSH
53230: LD_VAR 0 10
53234: PPUSH
53235: CALL_OW 296
53239: PUSH
53240: LD_INT 13
53242: GREATER
53243: AND
53244: PUSH
53245: LD_VAR 0 1
53249: PPUSH
53250: LD_VAR 0 10
53254: PPUSH
53255: CALL_OW 296
53259: PUSH
53260: LD_INT 12
53262: GREATER
53263: OR
53264: IFFALSE 53268
// exit ;
53266: GO 53621
// missile := [ 1 ] ;
53268: LD_ADDR_VAR 0 14
53272: PUSH
53273: LD_INT 1
53275: PUSH
53276: EMPTY
53277: LIST
53278: ST_TO_ADDR
// if Researched ( side , tech_space ) then
53279: LD_VAR 0 9
53283: PPUSH
53284: LD_VAR 0 12
53288: PPUSH
53289: CALL_OW 325
53293: IFFALSE 53322
// missile := Replace ( missile , missile + 1 , 2 ) ;
53295: LD_ADDR_VAR 0 14
53299: PUSH
53300: LD_VAR 0 14
53304: PPUSH
53305: LD_VAR 0 14
53309: PUSH
53310: LD_INT 1
53312: PLUS
53313: PPUSH
53314: LD_INT 2
53316: PPUSH
53317: CALL_OW 1
53321: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
53322: LD_VAR 0 9
53326: PPUSH
53327: LD_VAR 0 13
53331: PPUSH
53332: CALL_OW 325
53336: PUSH
53337: LD_VAR 0 10
53341: PPUSH
53342: CALL_OW 255
53346: PPUSH
53347: LD_VAR 0 13
53351: PPUSH
53352: CALL_OW 325
53356: NOT
53357: AND
53358: IFFALSE 53387
// missile := Replace ( missile , missile + 1 , 3 ) ;
53360: LD_ADDR_VAR 0 14
53364: PUSH
53365: LD_VAR 0 14
53369: PPUSH
53370: LD_VAR 0 14
53374: PUSH
53375: LD_INT 1
53377: PLUS
53378: PPUSH
53379: LD_INT 3
53381: PPUSH
53382: CALL_OW 1
53386: ST_TO_ADDR
// if missile < 2 then
53387: LD_VAR 0 14
53391: PUSH
53392: LD_INT 2
53394: LESS
53395: IFFALSE 53399
// exit ;
53397: GO 53621
// x := GetX ( enemy ) ;
53399: LD_ADDR_VAR 0 4
53403: PUSH
53404: LD_VAR 0 10
53408: PPUSH
53409: CALL_OW 250
53413: ST_TO_ADDR
// y := GetY ( enemy ) ;
53414: LD_ADDR_VAR 0 5
53418: PUSH
53419: LD_VAR 0 10
53423: PPUSH
53424: CALL_OW 251
53428: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
53429: LD_ADDR_VAR 0 6
53433: PUSH
53434: LD_VAR 0 4
53438: PUSH
53439: LD_INT 1
53441: NEG
53442: PPUSH
53443: LD_INT 1
53445: PPUSH
53446: CALL_OW 12
53450: PLUS
53451: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
53452: LD_ADDR_VAR 0 7
53456: PUSH
53457: LD_VAR 0 5
53461: PUSH
53462: LD_INT 1
53464: NEG
53465: PPUSH
53466: LD_INT 1
53468: PPUSH
53469: CALL_OW 12
53473: PLUS
53474: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
53475: LD_VAR 0 6
53479: PPUSH
53480: LD_VAR 0 7
53484: PPUSH
53485: CALL_OW 488
53489: NOT
53490: IFFALSE 53512
// begin _x := x ;
53492: LD_ADDR_VAR 0 6
53496: PUSH
53497: LD_VAR 0 4
53501: ST_TO_ADDR
// _y := y ;
53502: LD_ADDR_VAR 0 7
53506: PUSH
53507: LD_VAR 0 5
53511: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
53512: LD_ADDR_VAR 0 3
53516: PUSH
53517: LD_INT 1
53519: PPUSH
53520: LD_VAR 0 14
53524: PPUSH
53525: CALL_OW 12
53529: ST_TO_ADDR
// case i of 1 :
53530: LD_VAR 0 3
53534: PUSH
53535: LD_INT 1
53537: DOUBLE
53538: EQUAL
53539: IFTRUE 53543
53541: GO 53560
53543: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
53544: LD_VAR 0 1
53548: PPUSH
53549: LD_VAR 0 10
53553: PPUSH
53554: CALL_OW 115
53558: GO 53621
53560: LD_INT 2
53562: DOUBLE
53563: EQUAL
53564: IFTRUE 53568
53566: GO 53590
53568: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
53569: LD_VAR 0 1
53573: PPUSH
53574: LD_VAR 0 6
53578: PPUSH
53579: LD_VAR 0 7
53583: PPUSH
53584: CALL_OW 153
53588: GO 53621
53590: LD_INT 3
53592: DOUBLE
53593: EQUAL
53594: IFTRUE 53598
53596: GO 53620
53598: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
53599: LD_VAR 0 1
53603: PPUSH
53604: LD_VAR 0 6
53608: PPUSH
53609: LD_VAR 0 7
53613: PPUSH
53614: CALL_OW 154
53618: GO 53621
53620: POP
// end ;
53621: LD_VAR 0 2
53625: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
53626: LD_INT 0
53628: PPUSH
53629: PPUSH
53630: PPUSH
53631: PPUSH
53632: PPUSH
53633: PPUSH
// if not unit or not building then
53634: LD_VAR 0 1
53638: NOT
53639: PUSH
53640: LD_VAR 0 2
53644: NOT
53645: OR
53646: IFFALSE 53650
// exit ;
53648: GO 53808
// x := GetX ( building ) ;
53650: LD_ADDR_VAR 0 5
53654: PUSH
53655: LD_VAR 0 2
53659: PPUSH
53660: CALL_OW 250
53664: ST_TO_ADDR
// y := GetY ( building ) ;
53665: LD_ADDR_VAR 0 6
53669: PUSH
53670: LD_VAR 0 2
53674: PPUSH
53675: CALL_OW 251
53679: ST_TO_ADDR
// for i = 0 to 5 do
53680: LD_ADDR_VAR 0 4
53684: PUSH
53685: DOUBLE
53686: LD_INT 0
53688: DEC
53689: ST_TO_ADDR
53690: LD_INT 5
53692: PUSH
53693: FOR_TO
53694: IFFALSE 53806
// begin _x := ShiftX ( x , i , 3 ) ;
53696: LD_ADDR_VAR 0 7
53700: PUSH
53701: LD_VAR 0 5
53705: PPUSH
53706: LD_VAR 0 4
53710: PPUSH
53711: LD_INT 3
53713: PPUSH
53714: CALL_OW 272
53718: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
53719: LD_ADDR_VAR 0 8
53723: PUSH
53724: LD_VAR 0 6
53728: PPUSH
53729: LD_VAR 0 4
53733: PPUSH
53734: LD_INT 3
53736: PPUSH
53737: CALL_OW 273
53741: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
53742: LD_VAR 0 7
53746: PPUSH
53747: LD_VAR 0 8
53751: PPUSH
53752: CALL_OW 488
53756: NOT
53757: IFFALSE 53761
// continue ;
53759: GO 53693
// if HexInfo ( _x , _y ) = 0 then
53761: LD_VAR 0 7
53765: PPUSH
53766: LD_VAR 0 8
53770: PPUSH
53771: CALL_OW 428
53775: PUSH
53776: LD_INT 0
53778: EQUAL
53779: IFFALSE 53804
// begin ComMoveXY ( unit , _x , _y ) ;
53781: LD_VAR 0 1
53785: PPUSH
53786: LD_VAR 0 7
53790: PPUSH
53791: LD_VAR 0 8
53795: PPUSH
53796: CALL_OW 111
// exit ;
53800: POP
53801: POP
53802: GO 53808
// end ; end ;
53804: GO 53693
53806: POP
53807: POP
// end ;
53808: LD_VAR 0 3
53812: RET
// export function ScanBase ( side , base_area ) ; begin
53813: LD_INT 0
53815: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
53816: LD_ADDR_VAR 0 3
53820: PUSH
53821: LD_VAR 0 2
53825: PPUSH
53826: LD_INT 81
53828: PUSH
53829: LD_VAR 0 1
53833: PUSH
53834: EMPTY
53835: LIST
53836: LIST
53837: PPUSH
53838: CALL_OW 70
53842: ST_TO_ADDR
// end ;
53843: LD_VAR 0 3
53847: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
53848: LD_INT 0
53850: PPUSH
53851: PPUSH
53852: PPUSH
53853: PPUSH
// result := false ;
53854: LD_ADDR_VAR 0 2
53858: PUSH
53859: LD_INT 0
53861: ST_TO_ADDR
// side := GetSide ( unit ) ;
53862: LD_ADDR_VAR 0 3
53866: PUSH
53867: LD_VAR 0 1
53871: PPUSH
53872: CALL_OW 255
53876: ST_TO_ADDR
// nat := GetNation ( unit ) ;
53877: LD_ADDR_VAR 0 4
53881: PUSH
53882: LD_VAR 0 1
53886: PPUSH
53887: CALL_OW 248
53891: ST_TO_ADDR
// case nat of 1 :
53892: LD_VAR 0 4
53896: PUSH
53897: LD_INT 1
53899: DOUBLE
53900: EQUAL
53901: IFTRUE 53905
53903: GO 53916
53905: POP
// tech := tech_lassight ; 2 :
53906: LD_ADDR_VAR 0 5
53910: PUSH
53911: LD_INT 12
53913: ST_TO_ADDR
53914: GO 53955
53916: LD_INT 2
53918: DOUBLE
53919: EQUAL
53920: IFTRUE 53924
53922: GO 53935
53924: POP
// tech := tech_mortar ; 3 :
53925: LD_ADDR_VAR 0 5
53929: PUSH
53930: LD_INT 41
53932: ST_TO_ADDR
53933: GO 53955
53935: LD_INT 3
53937: DOUBLE
53938: EQUAL
53939: IFTRUE 53943
53941: GO 53954
53943: POP
// tech := tech_bazooka ; end ;
53944: LD_ADDR_VAR 0 5
53948: PUSH
53949: LD_INT 44
53951: ST_TO_ADDR
53952: GO 53955
53954: POP
// if Researched ( side , tech ) then
53955: LD_VAR 0 3
53959: PPUSH
53960: LD_VAR 0 5
53964: PPUSH
53965: CALL_OW 325
53969: IFFALSE 53996
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
53971: LD_ADDR_VAR 0 2
53975: PUSH
53976: LD_INT 5
53978: PUSH
53979: LD_INT 8
53981: PUSH
53982: LD_INT 9
53984: PUSH
53985: EMPTY
53986: LIST
53987: LIST
53988: LIST
53989: PUSH
53990: LD_VAR 0 4
53994: ARRAY
53995: ST_TO_ADDR
// end ;
53996: LD_VAR 0 2
54000: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
54001: LD_INT 0
54003: PPUSH
54004: PPUSH
54005: PPUSH
// if not mines then
54006: LD_VAR 0 2
54010: NOT
54011: IFFALSE 54015
// exit ;
54013: GO 54159
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54015: LD_ADDR_VAR 0 5
54019: PUSH
54020: LD_INT 81
54022: PUSH
54023: LD_VAR 0 1
54027: PUSH
54028: EMPTY
54029: LIST
54030: LIST
54031: PUSH
54032: LD_INT 3
54034: PUSH
54035: LD_INT 21
54037: PUSH
54038: LD_INT 3
54040: PUSH
54041: EMPTY
54042: LIST
54043: LIST
54044: PUSH
54045: EMPTY
54046: LIST
54047: LIST
54048: PUSH
54049: EMPTY
54050: LIST
54051: LIST
54052: PPUSH
54053: CALL_OW 69
54057: ST_TO_ADDR
// for i in mines do
54058: LD_ADDR_VAR 0 4
54062: PUSH
54063: LD_VAR 0 2
54067: PUSH
54068: FOR_IN
54069: IFFALSE 54157
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
54071: LD_VAR 0 4
54075: PUSH
54076: LD_INT 1
54078: ARRAY
54079: PPUSH
54080: LD_VAR 0 4
54084: PUSH
54085: LD_INT 2
54087: ARRAY
54088: PPUSH
54089: CALL_OW 458
54093: NOT
54094: IFFALSE 54098
// continue ;
54096: GO 54068
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
54098: LD_VAR 0 4
54102: PUSH
54103: LD_INT 1
54105: ARRAY
54106: PPUSH
54107: LD_VAR 0 4
54111: PUSH
54112: LD_INT 2
54114: ARRAY
54115: PPUSH
54116: CALL_OW 428
54120: PUSH
54121: LD_VAR 0 5
54125: IN
54126: IFFALSE 54155
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
54128: LD_VAR 0 4
54132: PUSH
54133: LD_INT 1
54135: ARRAY
54136: PPUSH
54137: LD_VAR 0 4
54141: PUSH
54142: LD_INT 2
54144: ARRAY
54145: PPUSH
54146: LD_VAR 0 1
54150: PPUSH
54151: CALL_OW 456
// end ;
54155: GO 54068
54157: POP
54158: POP
// end ;
54159: LD_VAR 0 3
54163: RET
// export function Count ( array ) ; var i ; begin
54164: LD_INT 0
54166: PPUSH
54167: PPUSH
// result := 0 ;
54168: LD_ADDR_VAR 0 2
54172: PUSH
54173: LD_INT 0
54175: ST_TO_ADDR
// for i in array do
54176: LD_ADDR_VAR 0 3
54180: PUSH
54181: LD_VAR 0 1
54185: PUSH
54186: FOR_IN
54187: IFFALSE 54211
// if i then
54189: LD_VAR 0 3
54193: IFFALSE 54209
// result := result + 1 ;
54195: LD_ADDR_VAR 0 2
54199: PUSH
54200: LD_VAR 0 2
54204: PUSH
54205: LD_INT 1
54207: PLUS
54208: ST_TO_ADDR
54209: GO 54186
54211: POP
54212: POP
// end ;
54213: LD_VAR 0 2
54217: RET
// export function IsEmpty ( building ) ; begin
54218: LD_INT 0
54220: PPUSH
// if not building then
54221: LD_VAR 0 1
54225: NOT
54226: IFFALSE 54230
// exit ;
54228: GO 54273
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
54230: LD_ADDR_VAR 0 2
54234: PUSH
54235: LD_VAR 0 1
54239: PUSH
54240: LD_INT 22
54242: PUSH
54243: LD_VAR 0 1
54247: PPUSH
54248: CALL_OW 255
54252: PUSH
54253: EMPTY
54254: LIST
54255: LIST
54256: PUSH
54257: LD_INT 58
54259: PUSH
54260: EMPTY
54261: LIST
54262: PUSH
54263: EMPTY
54264: LIST
54265: LIST
54266: PPUSH
54267: CALL_OW 69
54271: IN
54272: ST_TO_ADDR
// end ;
54273: LD_VAR 0 2
54277: RET
// export function IsNotFull ( building ) ; var places ; begin
54278: LD_INT 0
54280: PPUSH
54281: PPUSH
// if not building then
54282: LD_VAR 0 1
54286: NOT
54287: IFFALSE 54291
// exit ;
54289: GO 54462
// result := false ;
54291: LD_ADDR_VAR 0 2
54295: PUSH
54296: LD_INT 0
54298: ST_TO_ADDR
// places := 0 ;
54299: LD_ADDR_VAR 0 3
54303: PUSH
54304: LD_INT 0
54306: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
54307: LD_VAR 0 1
54311: PPUSH
54312: CALL_OW 266
54316: PUSH
54317: LD_INT 0
54319: DOUBLE
54320: EQUAL
54321: IFTRUE 54379
54323: LD_INT 1
54325: DOUBLE
54326: EQUAL
54327: IFTRUE 54379
54329: LD_INT 6
54331: DOUBLE
54332: EQUAL
54333: IFTRUE 54379
54335: LD_INT 7
54337: DOUBLE
54338: EQUAL
54339: IFTRUE 54379
54341: LD_INT 8
54343: DOUBLE
54344: EQUAL
54345: IFTRUE 54379
54347: LD_INT 4
54349: DOUBLE
54350: EQUAL
54351: IFTRUE 54379
54353: LD_INT 5
54355: DOUBLE
54356: EQUAL
54357: IFTRUE 54379
54359: LD_INT 2
54361: DOUBLE
54362: EQUAL
54363: IFTRUE 54379
54365: LD_INT 3
54367: DOUBLE
54368: EQUAL
54369: IFTRUE 54379
54371: LD_INT 35
54373: DOUBLE
54374: EQUAL
54375: IFTRUE 54379
54377: GO 54390
54379: POP
// places := 6 ; b_bunker , b_breastwork :
54380: LD_ADDR_VAR 0 3
54384: PUSH
54385: LD_INT 6
54387: ST_TO_ADDR
54388: GO 54435
54390: LD_INT 32
54392: DOUBLE
54393: EQUAL
54394: IFTRUE 54404
54396: LD_INT 31
54398: DOUBLE
54399: EQUAL
54400: IFTRUE 54404
54402: GO 54415
54404: POP
// places := 1 ; b_control_tower :
54405: LD_ADDR_VAR 0 3
54409: PUSH
54410: LD_INT 1
54412: ST_TO_ADDR
54413: GO 54435
54415: LD_INT 36
54417: DOUBLE
54418: EQUAL
54419: IFTRUE 54423
54421: GO 54434
54423: POP
// places := 3 ; end ;
54424: LD_ADDR_VAR 0 3
54428: PUSH
54429: LD_INT 3
54431: ST_TO_ADDR
54432: GO 54435
54434: POP
// if places then
54435: LD_VAR 0 3
54439: IFFALSE 54462
// result := UnitsInside ( building ) < places ;
54441: LD_ADDR_VAR 0 2
54445: PUSH
54446: LD_VAR 0 1
54450: PPUSH
54451: CALL_OW 313
54455: PUSH
54456: LD_VAR 0 3
54460: LESS
54461: ST_TO_ADDR
// end ;
54462: LD_VAR 0 2
54466: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
54467: LD_INT 0
54469: PPUSH
54470: PPUSH
54471: PPUSH
54472: PPUSH
// tmp := [ ] ;
54473: LD_ADDR_VAR 0 3
54477: PUSH
54478: EMPTY
54479: ST_TO_ADDR
// list := [ ] ;
54480: LD_ADDR_VAR 0 5
54484: PUSH
54485: EMPTY
54486: ST_TO_ADDR
// for i = 16 to 25 do
54487: LD_ADDR_VAR 0 4
54491: PUSH
54492: DOUBLE
54493: LD_INT 16
54495: DEC
54496: ST_TO_ADDR
54497: LD_INT 25
54499: PUSH
54500: FOR_TO
54501: IFFALSE 54574
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
54503: LD_ADDR_VAR 0 3
54507: PUSH
54508: LD_VAR 0 3
54512: PUSH
54513: LD_INT 22
54515: PUSH
54516: LD_VAR 0 1
54520: PPUSH
54521: CALL_OW 255
54525: PUSH
54526: EMPTY
54527: LIST
54528: LIST
54529: PUSH
54530: LD_INT 91
54532: PUSH
54533: LD_VAR 0 1
54537: PUSH
54538: LD_INT 6
54540: PUSH
54541: EMPTY
54542: LIST
54543: LIST
54544: LIST
54545: PUSH
54546: LD_INT 30
54548: PUSH
54549: LD_VAR 0 4
54553: PUSH
54554: EMPTY
54555: LIST
54556: LIST
54557: PUSH
54558: EMPTY
54559: LIST
54560: LIST
54561: LIST
54562: PUSH
54563: EMPTY
54564: LIST
54565: PPUSH
54566: CALL_OW 69
54570: ADD
54571: ST_TO_ADDR
54572: GO 54500
54574: POP
54575: POP
// for i = 1 to tmp do
54576: LD_ADDR_VAR 0 4
54580: PUSH
54581: DOUBLE
54582: LD_INT 1
54584: DEC
54585: ST_TO_ADDR
54586: LD_VAR 0 3
54590: PUSH
54591: FOR_TO
54592: IFFALSE 54680
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
54594: LD_ADDR_VAR 0 5
54598: PUSH
54599: LD_VAR 0 5
54603: PUSH
54604: LD_VAR 0 3
54608: PUSH
54609: LD_VAR 0 4
54613: ARRAY
54614: PPUSH
54615: CALL_OW 266
54619: PUSH
54620: LD_VAR 0 3
54624: PUSH
54625: LD_VAR 0 4
54629: ARRAY
54630: PPUSH
54631: CALL_OW 250
54635: PUSH
54636: LD_VAR 0 3
54640: PUSH
54641: LD_VAR 0 4
54645: ARRAY
54646: PPUSH
54647: CALL_OW 251
54651: PUSH
54652: LD_VAR 0 3
54656: PUSH
54657: LD_VAR 0 4
54661: ARRAY
54662: PPUSH
54663: CALL_OW 254
54667: PUSH
54668: EMPTY
54669: LIST
54670: LIST
54671: LIST
54672: LIST
54673: PUSH
54674: EMPTY
54675: LIST
54676: ADD
54677: ST_TO_ADDR
54678: GO 54591
54680: POP
54681: POP
// result := list ;
54682: LD_ADDR_VAR 0 2
54686: PUSH
54687: LD_VAR 0 5
54691: ST_TO_ADDR
// end ;
54692: LD_VAR 0 2
54696: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
54697: LD_INT 0
54699: PPUSH
54700: PPUSH
54701: PPUSH
54702: PPUSH
54703: PPUSH
54704: PPUSH
54705: PPUSH
// if not factory then
54706: LD_VAR 0 1
54710: NOT
54711: IFFALSE 54715
// exit ;
54713: GO 55308
// if control = control_apeman then
54715: LD_VAR 0 4
54719: PUSH
54720: LD_INT 5
54722: EQUAL
54723: IFFALSE 54832
// begin tmp := UnitsInside ( factory ) ;
54725: LD_ADDR_VAR 0 8
54729: PUSH
54730: LD_VAR 0 1
54734: PPUSH
54735: CALL_OW 313
54739: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
54740: LD_VAR 0 8
54744: PPUSH
54745: LD_INT 25
54747: PUSH
54748: LD_INT 12
54750: PUSH
54751: EMPTY
54752: LIST
54753: LIST
54754: PPUSH
54755: CALL_OW 72
54759: NOT
54760: IFFALSE 54770
// control := control_manual ;
54762: LD_ADDR_VAR 0 4
54766: PUSH
54767: LD_INT 1
54769: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
54770: LD_ADDR_VAR 0 8
54774: PUSH
54775: LD_VAR 0 1
54779: PPUSH
54780: CALL 54467 0 1
54784: ST_TO_ADDR
// if tmp then
54785: LD_VAR 0 8
54789: IFFALSE 54832
// begin for i in tmp do
54791: LD_ADDR_VAR 0 7
54795: PUSH
54796: LD_VAR 0 8
54800: PUSH
54801: FOR_IN
54802: IFFALSE 54830
// if i [ 1 ] = b_ext_radio then
54804: LD_VAR 0 7
54808: PUSH
54809: LD_INT 1
54811: ARRAY
54812: PUSH
54813: LD_INT 22
54815: EQUAL
54816: IFFALSE 54828
// begin control := control_remote ;
54818: LD_ADDR_VAR 0 4
54822: PUSH
54823: LD_INT 2
54825: ST_TO_ADDR
// break ;
54826: GO 54830
// end ;
54828: GO 54801
54830: POP
54831: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
54832: LD_VAR 0 1
54836: PPUSH
54837: LD_VAR 0 2
54841: PPUSH
54842: LD_VAR 0 3
54846: PPUSH
54847: LD_VAR 0 4
54851: PPUSH
54852: LD_VAR 0 5
54856: PPUSH
54857: CALL_OW 448
54861: IFFALSE 54896
// begin result := [ chassis , engine , control , weapon ] ;
54863: LD_ADDR_VAR 0 6
54867: PUSH
54868: LD_VAR 0 2
54872: PUSH
54873: LD_VAR 0 3
54877: PUSH
54878: LD_VAR 0 4
54882: PUSH
54883: LD_VAR 0 5
54887: PUSH
54888: EMPTY
54889: LIST
54890: LIST
54891: LIST
54892: LIST
54893: ST_TO_ADDR
// exit ;
54894: GO 55308
// end ; _chassis := AvailableChassisList ( factory ) ;
54896: LD_ADDR_VAR 0 9
54900: PUSH
54901: LD_VAR 0 1
54905: PPUSH
54906: CALL_OW 475
54910: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
54911: LD_ADDR_VAR 0 11
54915: PUSH
54916: LD_VAR 0 1
54920: PPUSH
54921: CALL_OW 476
54925: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
54926: LD_ADDR_VAR 0 12
54930: PUSH
54931: LD_VAR 0 1
54935: PPUSH
54936: CALL_OW 477
54940: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
54941: LD_ADDR_VAR 0 10
54945: PUSH
54946: LD_VAR 0 1
54950: PPUSH
54951: CALL_OW 478
54955: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
54956: LD_VAR 0 9
54960: NOT
54961: PUSH
54962: LD_VAR 0 11
54966: NOT
54967: OR
54968: PUSH
54969: LD_VAR 0 12
54973: NOT
54974: OR
54975: PUSH
54976: LD_VAR 0 10
54980: NOT
54981: OR
54982: IFFALSE 55017
// begin result := [ chassis , engine , control , weapon ] ;
54984: LD_ADDR_VAR 0 6
54988: PUSH
54989: LD_VAR 0 2
54993: PUSH
54994: LD_VAR 0 3
54998: PUSH
54999: LD_VAR 0 4
55003: PUSH
55004: LD_VAR 0 5
55008: PUSH
55009: EMPTY
55010: LIST
55011: LIST
55012: LIST
55013: LIST
55014: ST_TO_ADDR
// exit ;
55015: GO 55308
// end ; if not chassis in _chassis then
55017: LD_VAR 0 2
55021: PUSH
55022: LD_VAR 0 9
55026: IN
55027: NOT
55028: IFFALSE 55054
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
55030: LD_ADDR_VAR 0 2
55034: PUSH
55035: LD_VAR 0 9
55039: PUSH
55040: LD_INT 1
55042: PPUSH
55043: LD_VAR 0 9
55047: PPUSH
55048: CALL_OW 12
55052: ARRAY
55053: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
55054: LD_VAR 0 2
55058: PPUSH
55059: LD_VAR 0 3
55063: PPUSH
55064: CALL 55313 0 2
55068: NOT
55069: IFFALSE 55128
// repeat engine := _engine [ 1 ] ;
55071: LD_ADDR_VAR 0 3
55075: PUSH
55076: LD_VAR 0 11
55080: PUSH
55081: LD_INT 1
55083: ARRAY
55084: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
55085: LD_ADDR_VAR 0 11
55089: PUSH
55090: LD_VAR 0 11
55094: PPUSH
55095: LD_INT 1
55097: PPUSH
55098: CALL_OW 3
55102: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
55103: LD_VAR 0 2
55107: PPUSH
55108: LD_VAR 0 3
55112: PPUSH
55113: CALL 55313 0 2
55117: PUSH
55118: LD_VAR 0 11
55122: PUSH
55123: EMPTY
55124: EQUAL
55125: OR
55126: IFFALSE 55071
// if not control in _control then
55128: LD_VAR 0 4
55132: PUSH
55133: LD_VAR 0 12
55137: IN
55138: NOT
55139: IFFALSE 55165
// control := _control [ rand ( 1 , _control ) ] ;
55141: LD_ADDR_VAR 0 4
55145: PUSH
55146: LD_VAR 0 12
55150: PUSH
55151: LD_INT 1
55153: PPUSH
55154: LD_VAR 0 12
55158: PPUSH
55159: CALL_OW 12
55163: ARRAY
55164: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
55165: LD_VAR 0 2
55169: PPUSH
55170: LD_VAR 0 5
55174: PPUSH
55175: CALL 55533 0 2
55179: NOT
55180: IFFALSE 55239
// repeat weapon := _weapon [ 1 ] ;
55182: LD_ADDR_VAR 0 5
55186: PUSH
55187: LD_VAR 0 10
55191: PUSH
55192: LD_INT 1
55194: ARRAY
55195: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
55196: LD_ADDR_VAR 0 10
55200: PUSH
55201: LD_VAR 0 10
55205: PPUSH
55206: LD_INT 1
55208: PPUSH
55209: CALL_OW 3
55213: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
55214: LD_VAR 0 2
55218: PPUSH
55219: LD_VAR 0 5
55223: PPUSH
55224: CALL 55533 0 2
55228: PUSH
55229: LD_VAR 0 10
55233: PUSH
55234: EMPTY
55235: EQUAL
55236: OR
55237: IFFALSE 55182
// result := [ ] ;
55239: LD_ADDR_VAR 0 6
55243: PUSH
55244: EMPTY
55245: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55246: LD_VAR 0 1
55250: PPUSH
55251: LD_VAR 0 2
55255: PPUSH
55256: LD_VAR 0 3
55260: PPUSH
55261: LD_VAR 0 4
55265: PPUSH
55266: LD_VAR 0 5
55270: PPUSH
55271: CALL_OW 448
55275: IFFALSE 55308
// result := [ chassis , engine , control , weapon ] ;
55277: LD_ADDR_VAR 0 6
55281: PUSH
55282: LD_VAR 0 2
55286: PUSH
55287: LD_VAR 0 3
55291: PUSH
55292: LD_VAR 0 4
55296: PUSH
55297: LD_VAR 0 5
55301: PUSH
55302: EMPTY
55303: LIST
55304: LIST
55305: LIST
55306: LIST
55307: ST_TO_ADDR
// end ;
55308: LD_VAR 0 6
55312: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
55313: LD_INT 0
55315: PPUSH
// if not chassis or not engine then
55316: LD_VAR 0 1
55320: NOT
55321: PUSH
55322: LD_VAR 0 2
55326: NOT
55327: OR
55328: IFFALSE 55332
// exit ;
55330: GO 55528
// case engine of engine_solar :
55332: LD_VAR 0 2
55336: PUSH
55337: LD_INT 2
55339: DOUBLE
55340: EQUAL
55341: IFTRUE 55345
55343: GO 55383
55345: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
55346: LD_ADDR_VAR 0 3
55350: PUSH
55351: LD_INT 11
55353: PUSH
55354: LD_INT 12
55356: PUSH
55357: LD_INT 13
55359: PUSH
55360: LD_INT 14
55362: PUSH
55363: LD_INT 1
55365: PUSH
55366: LD_INT 2
55368: PUSH
55369: LD_INT 3
55371: PUSH
55372: EMPTY
55373: LIST
55374: LIST
55375: LIST
55376: LIST
55377: LIST
55378: LIST
55379: LIST
55380: ST_TO_ADDR
55381: GO 55512
55383: LD_INT 1
55385: DOUBLE
55386: EQUAL
55387: IFTRUE 55391
55389: GO 55453
55391: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
55392: LD_ADDR_VAR 0 3
55396: PUSH
55397: LD_INT 11
55399: PUSH
55400: LD_INT 12
55402: PUSH
55403: LD_INT 13
55405: PUSH
55406: LD_INT 14
55408: PUSH
55409: LD_INT 1
55411: PUSH
55412: LD_INT 2
55414: PUSH
55415: LD_INT 3
55417: PUSH
55418: LD_INT 4
55420: PUSH
55421: LD_INT 5
55423: PUSH
55424: LD_INT 21
55426: PUSH
55427: LD_INT 23
55429: PUSH
55430: LD_INT 22
55432: PUSH
55433: LD_INT 24
55435: PUSH
55436: EMPTY
55437: LIST
55438: LIST
55439: LIST
55440: LIST
55441: LIST
55442: LIST
55443: LIST
55444: LIST
55445: LIST
55446: LIST
55447: LIST
55448: LIST
55449: LIST
55450: ST_TO_ADDR
55451: GO 55512
55453: LD_INT 3
55455: DOUBLE
55456: EQUAL
55457: IFTRUE 55461
55459: GO 55511
55461: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
55462: LD_ADDR_VAR 0 3
55466: PUSH
55467: LD_INT 13
55469: PUSH
55470: LD_INT 14
55472: PUSH
55473: LD_INT 2
55475: PUSH
55476: LD_INT 3
55478: PUSH
55479: LD_INT 4
55481: PUSH
55482: LD_INT 5
55484: PUSH
55485: LD_INT 21
55487: PUSH
55488: LD_INT 22
55490: PUSH
55491: LD_INT 23
55493: PUSH
55494: LD_INT 24
55496: PUSH
55497: EMPTY
55498: LIST
55499: LIST
55500: LIST
55501: LIST
55502: LIST
55503: LIST
55504: LIST
55505: LIST
55506: LIST
55507: LIST
55508: ST_TO_ADDR
55509: GO 55512
55511: POP
// result := ( chassis in result ) ;
55512: LD_ADDR_VAR 0 3
55516: PUSH
55517: LD_VAR 0 1
55521: PUSH
55522: LD_VAR 0 3
55526: IN
55527: ST_TO_ADDR
// end ;
55528: LD_VAR 0 3
55532: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
55533: LD_INT 0
55535: PPUSH
// if not chassis or not weapon then
55536: LD_VAR 0 1
55540: NOT
55541: PUSH
55542: LD_VAR 0 2
55546: NOT
55547: OR
55548: IFFALSE 55552
// exit ;
55550: GO 56612
// case weapon of us_machine_gun :
55552: LD_VAR 0 2
55556: PUSH
55557: LD_INT 2
55559: DOUBLE
55560: EQUAL
55561: IFTRUE 55565
55563: GO 55595
55565: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
55566: LD_ADDR_VAR 0 3
55570: PUSH
55571: LD_INT 1
55573: PUSH
55574: LD_INT 2
55576: PUSH
55577: LD_INT 3
55579: PUSH
55580: LD_INT 4
55582: PUSH
55583: LD_INT 5
55585: PUSH
55586: EMPTY
55587: LIST
55588: LIST
55589: LIST
55590: LIST
55591: LIST
55592: ST_TO_ADDR
55593: GO 56596
55595: LD_INT 3
55597: DOUBLE
55598: EQUAL
55599: IFTRUE 55603
55601: GO 55633
55603: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
55604: LD_ADDR_VAR 0 3
55608: PUSH
55609: LD_INT 1
55611: PUSH
55612: LD_INT 2
55614: PUSH
55615: LD_INT 3
55617: PUSH
55618: LD_INT 4
55620: PUSH
55621: LD_INT 5
55623: PUSH
55624: EMPTY
55625: LIST
55626: LIST
55627: LIST
55628: LIST
55629: LIST
55630: ST_TO_ADDR
55631: GO 56596
55633: LD_INT 11
55635: DOUBLE
55636: EQUAL
55637: IFTRUE 55641
55639: GO 55671
55641: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
55642: LD_ADDR_VAR 0 3
55646: PUSH
55647: LD_INT 1
55649: PUSH
55650: LD_INT 2
55652: PUSH
55653: LD_INT 3
55655: PUSH
55656: LD_INT 4
55658: PUSH
55659: LD_INT 5
55661: PUSH
55662: EMPTY
55663: LIST
55664: LIST
55665: LIST
55666: LIST
55667: LIST
55668: ST_TO_ADDR
55669: GO 56596
55671: LD_INT 4
55673: DOUBLE
55674: EQUAL
55675: IFTRUE 55679
55677: GO 55705
55679: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
55680: LD_ADDR_VAR 0 3
55684: PUSH
55685: LD_INT 2
55687: PUSH
55688: LD_INT 3
55690: PUSH
55691: LD_INT 4
55693: PUSH
55694: LD_INT 5
55696: PUSH
55697: EMPTY
55698: LIST
55699: LIST
55700: LIST
55701: LIST
55702: ST_TO_ADDR
55703: GO 56596
55705: LD_INT 5
55707: DOUBLE
55708: EQUAL
55709: IFTRUE 55713
55711: GO 55739
55713: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
55714: LD_ADDR_VAR 0 3
55718: PUSH
55719: LD_INT 2
55721: PUSH
55722: LD_INT 3
55724: PUSH
55725: LD_INT 4
55727: PUSH
55728: LD_INT 5
55730: PUSH
55731: EMPTY
55732: LIST
55733: LIST
55734: LIST
55735: LIST
55736: ST_TO_ADDR
55737: GO 56596
55739: LD_INT 9
55741: DOUBLE
55742: EQUAL
55743: IFTRUE 55747
55745: GO 55773
55747: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
55748: LD_ADDR_VAR 0 3
55752: PUSH
55753: LD_INT 2
55755: PUSH
55756: LD_INT 3
55758: PUSH
55759: LD_INT 4
55761: PUSH
55762: LD_INT 5
55764: PUSH
55765: EMPTY
55766: LIST
55767: LIST
55768: LIST
55769: LIST
55770: ST_TO_ADDR
55771: GO 56596
55773: LD_INT 7
55775: DOUBLE
55776: EQUAL
55777: IFTRUE 55781
55779: GO 55807
55781: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
55782: LD_ADDR_VAR 0 3
55786: PUSH
55787: LD_INT 2
55789: PUSH
55790: LD_INT 3
55792: PUSH
55793: LD_INT 4
55795: PUSH
55796: LD_INT 5
55798: PUSH
55799: EMPTY
55800: LIST
55801: LIST
55802: LIST
55803: LIST
55804: ST_TO_ADDR
55805: GO 56596
55807: LD_INT 12
55809: DOUBLE
55810: EQUAL
55811: IFTRUE 55815
55813: GO 55841
55815: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
55816: LD_ADDR_VAR 0 3
55820: PUSH
55821: LD_INT 2
55823: PUSH
55824: LD_INT 3
55826: PUSH
55827: LD_INT 4
55829: PUSH
55830: LD_INT 5
55832: PUSH
55833: EMPTY
55834: LIST
55835: LIST
55836: LIST
55837: LIST
55838: ST_TO_ADDR
55839: GO 56596
55841: LD_INT 13
55843: DOUBLE
55844: EQUAL
55845: IFTRUE 55849
55847: GO 55875
55849: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
55850: LD_ADDR_VAR 0 3
55854: PUSH
55855: LD_INT 2
55857: PUSH
55858: LD_INT 3
55860: PUSH
55861: LD_INT 4
55863: PUSH
55864: LD_INT 5
55866: PUSH
55867: EMPTY
55868: LIST
55869: LIST
55870: LIST
55871: LIST
55872: ST_TO_ADDR
55873: GO 56596
55875: LD_INT 14
55877: DOUBLE
55878: EQUAL
55879: IFTRUE 55883
55881: GO 55901
55883: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
55884: LD_ADDR_VAR 0 3
55888: PUSH
55889: LD_INT 4
55891: PUSH
55892: LD_INT 5
55894: PUSH
55895: EMPTY
55896: LIST
55897: LIST
55898: ST_TO_ADDR
55899: GO 56596
55901: LD_INT 6
55903: DOUBLE
55904: EQUAL
55905: IFTRUE 55909
55907: GO 55927
55909: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
55910: LD_ADDR_VAR 0 3
55914: PUSH
55915: LD_INT 4
55917: PUSH
55918: LD_INT 5
55920: PUSH
55921: EMPTY
55922: LIST
55923: LIST
55924: ST_TO_ADDR
55925: GO 56596
55927: LD_INT 10
55929: DOUBLE
55930: EQUAL
55931: IFTRUE 55935
55933: GO 55953
55935: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
55936: LD_ADDR_VAR 0 3
55940: PUSH
55941: LD_INT 4
55943: PUSH
55944: LD_INT 5
55946: PUSH
55947: EMPTY
55948: LIST
55949: LIST
55950: ST_TO_ADDR
55951: GO 56596
55953: LD_INT 22
55955: DOUBLE
55956: EQUAL
55957: IFTRUE 55961
55959: GO 55987
55961: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
55962: LD_ADDR_VAR 0 3
55966: PUSH
55967: LD_INT 11
55969: PUSH
55970: LD_INT 12
55972: PUSH
55973: LD_INT 13
55975: PUSH
55976: LD_INT 14
55978: PUSH
55979: EMPTY
55980: LIST
55981: LIST
55982: LIST
55983: LIST
55984: ST_TO_ADDR
55985: GO 56596
55987: LD_INT 23
55989: DOUBLE
55990: EQUAL
55991: IFTRUE 55995
55993: GO 56021
55995: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
55996: LD_ADDR_VAR 0 3
56000: PUSH
56001: LD_INT 11
56003: PUSH
56004: LD_INT 12
56006: PUSH
56007: LD_INT 13
56009: PUSH
56010: LD_INT 14
56012: PUSH
56013: EMPTY
56014: LIST
56015: LIST
56016: LIST
56017: LIST
56018: ST_TO_ADDR
56019: GO 56596
56021: LD_INT 24
56023: DOUBLE
56024: EQUAL
56025: IFTRUE 56029
56027: GO 56055
56029: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
56030: LD_ADDR_VAR 0 3
56034: PUSH
56035: LD_INT 11
56037: PUSH
56038: LD_INT 12
56040: PUSH
56041: LD_INT 13
56043: PUSH
56044: LD_INT 14
56046: PUSH
56047: EMPTY
56048: LIST
56049: LIST
56050: LIST
56051: LIST
56052: ST_TO_ADDR
56053: GO 56596
56055: LD_INT 30
56057: DOUBLE
56058: EQUAL
56059: IFTRUE 56063
56061: GO 56089
56063: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
56064: LD_ADDR_VAR 0 3
56068: PUSH
56069: LD_INT 11
56071: PUSH
56072: LD_INT 12
56074: PUSH
56075: LD_INT 13
56077: PUSH
56078: LD_INT 14
56080: PUSH
56081: EMPTY
56082: LIST
56083: LIST
56084: LIST
56085: LIST
56086: ST_TO_ADDR
56087: GO 56596
56089: LD_INT 25
56091: DOUBLE
56092: EQUAL
56093: IFTRUE 56097
56095: GO 56115
56097: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
56098: LD_ADDR_VAR 0 3
56102: PUSH
56103: LD_INT 13
56105: PUSH
56106: LD_INT 14
56108: PUSH
56109: EMPTY
56110: LIST
56111: LIST
56112: ST_TO_ADDR
56113: GO 56596
56115: LD_INT 27
56117: DOUBLE
56118: EQUAL
56119: IFTRUE 56123
56121: GO 56141
56123: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
56124: LD_ADDR_VAR 0 3
56128: PUSH
56129: LD_INT 13
56131: PUSH
56132: LD_INT 14
56134: PUSH
56135: EMPTY
56136: LIST
56137: LIST
56138: ST_TO_ADDR
56139: GO 56596
56141: LD_INT 92
56143: DOUBLE
56144: EQUAL
56145: IFTRUE 56149
56147: GO 56175
56149: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
56150: LD_ADDR_VAR 0 3
56154: PUSH
56155: LD_INT 11
56157: PUSH
56158: LD_INT 12
56160: PUSH
56161: LD_INT 13
56163: PUSH
56164: LD_INT 14
56166: PUSH
56167: EMPTY
56168: LIST
56169: LIST
56170: LIST
56171: LIST
56172: ST_TO_ADDR
56173: GO 56596
56175: LD_INT 28
56177: DOUBLE
56178: EQUAL
56179: IFTRUE 56183
56181: GO 56201
56183: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
56184: LD_ADDR_VAR 0 3
56188: PUSH
56189: LD_INT 13
56191: PUSH
56192: LD_INT 14
56194: PUSH
56195: EMPTY
56196: LIST
56197: LIST
56198: ST_TO_ADDR
56199: GO 56596
56201: LD_INT 29
56203: DOUBLE
56204: EQUAL
56205: IFTRUE 56209
56207: GO 56227
56209: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
56210: LD_ADDR_VAR 0 3
56214: PUSH
56215: LD_INT 13
56217: PUSH
56218: LD_INT 14
56220: PUSH
56221: EMPTY
56222: LIST
56223: LIST
56224: ST_TO_ADDR
56225: GO 56596
56227: LD_INT 31
56229: DOUBLE
56230: EQUAL
56231: IFTRUE 56235
56233: GO 56253
56235: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
56236: LD_ADDR_VAR 0 3
56240: PUSH
56241: LD_INT 13
56243: PUSH
56244: LD_INT 14
56246: PUSH
56247: EMPTY
56248: LIST
56249: LIST
56250: ST_TO_ADDR
56251: GO 56596
56253: LD_INT 26
56255: DOUBLE
56256: EQUAL
56257: IFTRUE 56261
56259: GO 56279
56261: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
56262: LD_ADDR_VAR 0 3
56266: PUSH
56267: LD_INT 13
56269: PUSH
56270: LD_INT 14
56272: PUSH
56273: EMPTY
56274: LIST
56275: LIST
56276: ST_TO_ADDR
56277: GO 56596
56279: LD_INT 42
56281: DOUBLE
56282: EQUAL
56283: IFTRUE 56287
56285: GO 56313
56287: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
56288: LD_ADDR_VAR 0 3
56292: PUSH
56293: LD_INT 21
56295: PUSH
56296: LD_INT 22
56298: PUSH
56299: LD_INT 23
56301: PUSH
56302: LD_INT 24
56304: PUSH
56305: EMPTY
56306: LIST
56307: LIST
56308: LIST
56309: LIST
56310: ST_TO_ADDR
56311: GO 56596
56313: LD_INT 43
56315: DOUBLE
56316: EQUAL
56317: IFTRUE 56321
56319: GO 56347
56321: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
56322: LD_ADDR_VAR 0 3
56326: PUSH
56327: LD_INT 21
56329: PUSH
56330: LD_INT 22
56332: PUSH
56333: LD_INT 23
56335: PUSH
56336: LD_INT 24
56338: PUSH
56339: EMPTY
56340: LIST
56341: LIST
56342: LIST
56343: LIST
56344: ST_TO_ADDR
56345: GO 56596
56347: LD_INT 44
56349: DOUBLE
56350: EQUAL
56351: IFTRUE 56355
56353: GO 56381
56355: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
56356: LD_ADDR_VAR 0 3
56360: PUSH
56361: LD_INT 21
56363: PUSH
56364: LD_INT 22
56366: PUSH
56367: LD_INT 23
56369: PUSH
56370: LD_INT 24
56372: PUSH
56373: EMPTY
56374: LIST
56375: LIST
56376: LIST
56377: LIST
56378: ST_TO_ADDR
56379: GO 56596
56381: LD_INT 45
56383: DOUBLE
56384: EQUAL
56385: IFTRUE 56389
56387: GO 56415
56389: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
56390: LD_ADDR_VAR 0 3
56394: PUSH
56395: LD_INT 21
56397: PUSH
56398: LD_INT 22
56400: PUSH
56401: LD_INT 23
56403: PUSH
56404: LD_INT 24
56406: PUSH
56407: EMPTY
56408: LIST
56409: LIST
56410: LIST
56411: LIST
56412: ST_TO_ADDR
56413: GO 56596
56415: LD_INT 49
56417: DOUBLE
56418: EQUAL
56419: IFTRUE 56423
56421: GO 56449
56423: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
56424: LD_ADDR_VAR 0 3
56428: PUSH
56429: LD_INT 21
56431: PUSH
56432: LD_INT 22
56434: PUSH
56435: LD_INT 23
56437: PUSH
56438: LD_INT 24
56440: PUSH
56441: EMPTY
56442: LIST
56443: LIST
56444: LIST
56445: LIST
56446: ST_TO_ADDR
56447: GO 56596
56449: LD_INT 51
56451: DOUBLE
56452: EQUAL
56453: IFTRUE 56457
56455: GO 56483
56457: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
56458: LD_ADDR_VAR 0 3
56462: PUSH
56463: LD_INT 21
56465: PUSH
56466: LD_INT 22
56468: PUSH
56469: LD_INT 23
56471: PUSH
56472: LD_INT 24
56474: PUSH
56475: EMPTY
56476: LIST
56477: LIST
56478: LIST
56479: LIST
56480: ST_TO_ADDR
56481: GO 56596
56483: LD_INT 52
56485: DOUBLE
56486: EQUAL
56487: IFTRUE 56491
56489: GO 56517
56491: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
56492: LD_ADDR_VAR 0 3
56496: PUSH
56497: LD_INT 21
56499: PUSH
56500: LD_INT 22
56502: PUSH
56503: LD_INT 23
56505: PUSH
56506: LD_INT 24
56508: PUSH
56509: EMPTY
56510: LIST
56511: LIST
56512: LIST
56513: LIST
56514: ST_TO_ADDR
56515: GO 56596
56517: LD_INT 53
56519: DOUBLE
56520: EQUAL
56521: IFTRUE 56525
56523: GO 56543
56525: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
56526: LD_ADDR_VAR 0 3
56530: PUSH
56531: LD_INT 23
56533: PUSH
56534: LD_INT 24
56536: PUSH
56537: EMPTY
56538: LIST
56539: LIST
56540: ST_TO_ADDR
56541: GO 56596
56543: LD_INT 46
56545: DOUBLE
56546: EQUAL
56547: IFTRUE 56551
56549: GO 56569
56551: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
56552: LD_ADDR_VAR 0 3
56556: PUSH
56557: LD_INT 23
56559: PUSH
56560: LD_INT 24
56562: PUSH
56563: EMPTY
56564: LIST
56565: LIST
56566: ST_TO_ADDR
56567: GO 56596
56569: LD_INT 47
56571: DOUBLE
56572: EQUAL
56573: IFTRUE 56577
56575: GO 56595
56577: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
56578: LD_ADDR_VAR 0 3
56582: PUSH
56583: LD_INT 23
56585: PUSH
56586: LD_INT 24
56588: PUSH
56589: EMPTY
56590: LIST
56591: LIST
56592: ST_TO_ADDR
56593: GO 56596
56595: POP
// result := ( chassis in result ) ;
56596: LD_ADDR_VAR 0 3
56600: PUSH
56601: LD_VAR 0 1
56605: PUSH
56606: LD_VAR 0 3
56610: IN
56611: ST_TO_ADDR
// end ;
56612: LD_VAR 0 3
56616: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
56617: LD_INT 0
56619: PPUSH
56620: PPUSH
56621: PPUSH
56622: PPUSH
56623: PPUSH
56624: PPUSH
56625: PPUSH
// result := array ;
56626: LD_ADDR_VAR 0 5
56630: PUSH
56631: LD_VAR 0 1
56635: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
56636: LD_VAR 0 1
56640: NOT
56641: PUSH
56642: LD_VAR 0 2
56646: NOT
56647: OR
56648: PUSH
56649: LD_VAR 0 3
56653: NOT
56654: OR
56655: PUSH
56656: LD_VAR 0 2
56660: PUSH
56661: LD_VAR 0 1
56665: GREATER
56666: OR
56667: PUSH
56668: LD_VAR 0 3
56672: PUSH
56673: LD_VAR 0 1
56677: GREATER
56678: OR
56679: IFFALSE 56683
// exit ;
56681: GO 56979
// if direction then
56683: LD_VAR 0 4
56687: IFFALSE 56751
// begin d := 1 ;
56689: LD_ADDR_VAR 0 9
56693: PUSH
56694: LD_INT 1
56696: ST_TO_ADDR
// if i_from > i_to then
56697: LD_VAR 0 2
56701: PUSH
56702: LD_VAR 0 3
56706: GREATER
56707: IFFALSE 56733
// length := ( array - i_from ) + i_to else
56709: LD_ADDR_VAR 0 11
56713: PUSH
56714: LD_VAR 0 1
56718: PUSH
56719: LD_VAR 0 2
56723: MINUS
56724: PUSH
56725: LD_VAR 0 3
56729: PLUS
56730: ST_TO_ADDR
56731: GO 56749
// length := i_to - i_from ;
56733: LD_ADDR_VAR 0 11
56737: PUSH
56738: LD_VAR 0 3
56742: PUSH
56743: LD_VAR 0 2
56747: MINUS
56748: ST_TO_ADDR
// end else
56749: GO 56812
// begin d := - 1 ;
56751: LD_ADDR_VAR 0 9
56755: PUSH
56756: LD_INT 1
56758: NEG
56759: ST_TO_ADDR
// if i_from > i_to then
56760: LD_VAR 0 2
56764: PUSH
56765: LD_VAR 0 3
56769: GREATER
56770: IFFALSE 56790
// length := i_from - i_to else
56772: LD_ADDR_VAR 0 11
56776: PUSH
56777: LD_VAR 0 2
56781: PUSH
56782: LD_VAR 0 3
56786: MINUS
56787: ST_TO_ADDR
56788: GO 56812
// length := ( array - i_to ) + i_from ;
56790: LD_ADDR_VAR 0 11
56794: PUSH
56795: LD_VAR 0 1
56799: PUSH
56800: LD_VAR 0 3
56804: MINUS
56805: PUSH
56806: LD_VAR 0 2
56810: PLUS
56811: ST_TO_ADDR
// end ; if not length then
56812: LD_VAR 0 11
56816: NOT
56817: IFFALSE 56821
// exit ;
56819: GO 56979
// tmp := array ;
56821: LD_ADDR_VAR 0 10
56825: PUSH
56826: LD_VAR 0 1
56830: ST_TO_ADDR
// for i = 1 to length do
56831: LD_ADDR_VAR 0 6
56835: PUSH
56836: DOUBLE
56837: LD_INT 1
56839: DEC
56840: ST_TO_ADDR
56841: LD_VAR 0 11
56845: PUSH
56846: FOR_TO
56847: IFFALSE 56967
// begin for j = 1 to array do
56849: LD_ADDR_VAR 0 7
56853: PUSH
56854: DOUBLE
56855: LD_INT 1
56857: DEC
56858: ST_TO_ADDR
56859: LD_VAR 0 1
56863: PUSH
56864: FOR_TO
56865: IFFALSE 56953
// begin k := j + d ;
56867: LD_ADDR_VAR 0 8
56871: PUSH
56872: LD_VAR 0 7
56876: PUSH
56877: LD_VAR 0 9
56881: PLUS
56882: ST_TO_ADDR
// if k > array then
56883: LD_VAR 0 8
56887: PUSH
56888: LD_VAR 0 1
56892: GREATER
56893: IFFALSE 56903
// k := 1 ;
56895: LD_ADDR_VAR 0 8
56899: PUSH
56900: LD_INT 1
56902: ST_TO_ADDR
// if not k then
56903: LD_VAR 0 8
56907: NOT
56908: IFFALSE 56920
// k := array ;
56910: LD_ADDR_VAR 0 8
56914: PUSH
56915: LD_VAR 0 1
56919: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
56920: LD_ADDR_VAR 0 10
56924: PUSH
56925: LD_VAR 0 10
56929: PPUSH
56930: LD_VAR 0 8
56934: PPUSH
56935: LD_VAR 0 1
56939: PUSH
56940: LD_VAR 0 7
56944: ARRAY
56945: PPUSH
56946: CALL_OW 1
56950: ST_TO_ADDR
// end ;
56951: GO 56864
56953: POP
56954: POP
// array := tmp ;
56955: LD_ADDR_VAR 0 1
56959: PUSH
56960: LD_VAR 0 10
56964: ST_TO_ADDR
// end ;
56965: GO 56846
56967: POP
56968: POP
// result := array ;
56969: LD_ADDR_VAR 0 5
56973: PUSH
56974: LD_VAR 0 1
56978: ST_TO_ADDR
// end ;
56979: LD_VAR 0 5
56983: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
56984: LD_INT 0
56986: PPUSH
56987: PPUSH
// result := 0 ;
56988: LD_ADDR_VAR 0 3
56992: PUSH
56993: LD_INT 0
56995: ST_TO_ADDR
// if not array or not value in array then
56996: LD_VAR 0 1
57000: NOT
57001: PUSH
57002: LD_VAR 0 2
57006: PUSH
57007: LD_VAR 0 1
57011: IN
57012: NOT
57013: OR
57014: IFFALSE 57018
// exit ;
57016: GO 57072
// for i = 1 to array do
57018: LD_ADDR_VAR 0 4
57022: PUSH
57023: DOUBLE
57024: LD_INT 1
57026: DEC
57027: ST_TO_ADDR
57028: LD_VAR 0 1
57032: PUSH
57033: FOR_TO
57034: IFFALSE 57070
// if value = array [ i ] then
57036: LD_VAR 0 2
57040: PUSH
57041: LD_VAR 0 1
57045: PUSH
57046: LD_VAR 0 4
57050: ARRAY
57051: EQUAL
57052: IFFALSE 57068
// begin result := i ;
57054: LD_ADDR_VAR 0 3
57058: PUSH
57059: LD_VAR 0 4
57063: ST_TO_ADDR
// exit ;
57064: POP
57065: POP
57066: GO 57072
// end ;
57068: GO 57033
57070: POP
57071: POP
// end ;
57072: LD_VAR 0 3
57076: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
57077: LD_INT 0
57079: PPUSH
// vc_chassis := chassis ;
57080: LD_ADDR_OWVAR 37
57084: PUSH
57085: LD_VAR 0 1
57089: ST_TO_ADDR
// vc_engine := engine ;
57090: LD_ADDR_OWVAR 39
57094: PUSH
57095: LD_VAR 0 2
57099: ST_TO_ADDR
// vc_control := control ;
57100: LD_ADDR_OWVAR 38
57104: PUSH
57105: LD_VAR 0 3
57109: ST_TO_ADDR
// vc_weapon := weapon ;
57110: LD_ADDR_OWVAR 40
57114: PUSH
57115: LD_VAR 0 4
57119: ST_TO_ADDR
// vc_fuel_battery := fuel ;
57120: LD_ADDR_OWVAR 41
57124: PUSH
57125: LD_VAR 0 5
57129: ST_TO_ADDR
// end ;
57130: LD_VAR 0 6
57134: RET
// export function WantPlant ( unit ) ; var task ; begin
57135: LD_INT 0
57137: PPUSH
57138: PPUSH
// result := false ;
57139: LD_ADDR_VAR 0 2
57143: PUSH
57144: LD_INT 0
57146: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
57147: LD_ADDR_VAR 0 3
57151: PUSH
57152: LD_VAR 0 1
57156: PPUSH
57157: CALL_OW 437
57161: ST_TO_ADDR
// if task then
57162: LD_VAR 0 3
57166: IFFALSE 57194
// if task [ 1 ] [ 1 ] = p then
57168: LD_VAR 0 3
57172: PUSH
57173: LD_INT 1
57175: ARRAY
57176: PUSH
57177: LD_INT 1
57179: ARRAY
57180: PUSH
57181: LD_STRING p
57183: EQUAL
57184: IFFALSE 57194
// result := true ;
57186: LD_ADDR_VAR 0 2
57190: PUSH
57191: LD_INT 1
57193: ST_TO_ADDR
// end ;
57194: LD_VAR 0 2
57198: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
57199: LD_INT 0
57201: PPUSH
57202: PPUSH
57203: PPUSH
57204: PPUSH
// if pos < 1 then
57205: LD_VAR 0 2
57209: PUSH
57210: LD_INT 1
57212: LESS
57213: IFFALSE 57217
// exit ;
57215: GO 57520
// if pos = 1 then
57217: LD_VAR 0 2
57221: PUSH
57222: LD_INT 1
57224: EQUAL
57225: IFFALSE 57258
// result := Replace ( arr , pos [ 1 ] , value ) else
57227: LD_ADDR_VAR 0 4
57231: PUSH
57232: LD_VAR 0 1
57236: PPUSH
57237: LD_VAR 0 2
57241: PUSH
57242: LD_INT 1
57244: ARRAY
57245: PPUSH
57246: LD_VAR 0 3
57250: PPUSH
57251: CALL_OW 1
57255: ST_TO_ADDR
57256: GO 57520
// begin tmp := arr ;
57258: LD_ADDR_VAR 0 6
57262: PUSH
57263: LD_VAR 0 1
57267: ST_TO_ADDR
// s_arr := [ tmp ] ;
57268: LD_ADDR_VAR 0 7
57272: PUSH
57273: LD_VAR 0 6
57277: PUSH
57278: EMPTY
57279: LIST
57280: ST_TO_ADDR
// for i = 1 to pos - 1 do
57281: LD_ADDR_VAR 0 5
57285: PUSH
57286: DOUBLE
57287: LD_INT 1
57289: DEC
57290: ST_TO_ADDR
57291: LD_VAR 0 2
57295: PUSH
57296: LD_INT 1
57298: MINUS
57299: PUSH
57300: FOR_TO
57301: IFFALSE 57346
// begin tmp := tmp [ pos [ i ] ] ;
57303: LD_ADDR_VAR 0 6
57307: PUSH
57308: LD_VAR 0 6
57312: PUSH
57313: LD_VAR 0 2
57317: PUSH
57318: LD_VAR 0 5
57322: ARRAY
57323: ARRAY
57324: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
57325: LD_ADDR_VAR 0 7
57329: PUSH
57330: LD_VAR 0 7
57334: PUSH
57335: LD_VAR 0 6
57339: PUSH
57340: EMPTY
57341: LIST
57342: ADD
57343: ST_TO_ADDR
// end ;
57344: GO 57300
57346: POP
57347: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
57348: LD_ADDR_VAR 0 6
57352: PUSH
57353: LD_VAR 0 6
57357: PPUSH
57358: LD_VAR 0 2
57362: PUSH
57363: LD_VAR 0 2
57367: ARRAY
57368: PPUSH
57369: LD_VAR 0 3
57373: PPUSH
57374: CALL_OW 1
57378: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
57379: LD_ADDR_VAR 0 7
57383: PUSH
57384: LD_VAR 0 7
57388: PPUSH
57389: LD_VAR 0 7
57393: PPUSH
57394: LD_VAR 0 6
57398: PPUSH
57399: CALL_OW 1
57403: ST_TO_ADDR
// for i = s_arr downto 2 do
57404: LD_ADDR_VAR 0 5
57408: PUSH
57409: DOUBLE
57410: LD_VAR 0 7
57414: INC
57415: ST_TO_ADDR
57416: LD_INT 2
57418: PUSH
57419: FOR_DOWNTO
57420: IFFALSE 57504
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
57422: LD_ADDR_VAR 0 6
57426: PUSH
57427: LD_VAR 0 7
57431: PUSH
57432: LD_VAR 0 5
57436: PUSH
57437: LD_INT 1
57439: MINUS
57440: ARRAY
57441: PPUSH
57442: LD_VAR 0 2
57446: PUSH
57447: LD_VAR 0 5
57451: PUSH
57452: LD_INT 1
57454: MINUS
57455: ARRAY
57456: PPUSH
57457: LD_VAR 0 7
57461: PUSH
57462: LD_VAR 0 5
57466: ARRAY
57467: PPUSH
57468: CALL_OW 1
57472: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
57473: LD_ADDR_VAR 0 7
57477: PUSH
57478: LD_VAR 0 7
57482: PPUSH
57483: LD_VAR 0 5
57487: PUSH
57488: LD_INT 1
57490: MINUS
57491: PPUSH
57492: LD_VAR 0 6
57496: PPUSH
57497: CALL_OW 1
57501: ST_TO_ADDR
// end ;
57502: GO 57419
57504: POP
57505: POP
// result := s_arr [ 1 ] ;
57506: LD_ADDR_VAR 0 4
57510: PUSH
57511: LD_VAR 0 7
57515: PUSH
57516: LD_INT 1
57518: ARRAY
57519: ST_TO_ADDR
// end ; end ;
57520: LD_VAR 0 4
57524: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
57525: LD_INT 0
57527: PPUSH
57528: PPUSH
// if not list then
57529: LD_VAR 0 1
57533: NOT
57534: IFFALSE 57538
// exit ;
57536: GO 57629
// i := list [ pos1 ] ;
57538: LD_ADDR_VAR 0 5
57542: PUSH
57543: LD_VAR 0 1
57547: PUSH
57548: LD_VAR 0 2
57552: ARRAY
57553: ST_TO_ADDR
// if not i then
57554: LD_VAR 0 5
57558: NOT
57559: IFFALSE 57563
// exit ;
57561: GO 57629
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
57563: LD_ADDR_VAR 0 1
57567: PUSH
57568: LD_VAR 0 1
57572: PPUSH
57573: LD_VAR 0 2
57577: PPUSH
57578: LD_VAR 0 1
57582: PUSH
57583: LD_VAR 0 3
57587: ARRAY
57588: PPUSH
57589: CALL_OW 1
57593: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
57594: LD_ADDR_VAR 0 1
57598: PUSH
57599: LD_VAR 0 1
57603: PPUSH
57604: LD_VAR 0 3
57608: PPUSH
57609: LD_VAR 0 5
57613: PPUSH
57614: CALL_OW 1
57618: ST_TO_ADDR
// result := list ;
57619: LD_ADDR_VAR 0 4
57623: PUSH
57624: LD_VAR 0 1
57628: ST_TO_ADDR
// end ;
57629: LD_VAR 0 4
57633: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
57634: LD_INT 0
57636: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
57637: LD_ADDR_VAR 0 5
57641: PUSH
57642: LD_VAR 0 1
57646: PPUSH
57647: CALL_OW 250
57651: PPUSH
57652: LD_VAR 0 1
57656: PPUSH
57657: CALL_OW 251
57661: PPUSH
57662: LD_VAR 0 2
57666: PPUSH
57667: LD_VAR 0 3
57671: PPUSH
57672: LD_VAR 0 4
57676: PPUSH
57677: CALL 57687 0 5
57681: ST_TO_ADDR
// end ;
57682: LD_VAR 0 5
57686: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
57687: LD_INT 0
57689: PPUSH
57690: PPUSH
57691: PPUSH
57692: PPUSH
// if not list then
57693: LD_VAR 0 3
57697: NOT
57698: IFFALSE 57702
// exit ;
57700: GO 58090
// result := [ ] ;
57702: LD_ADDR_VAR 0 6
57706: PUSH
57707: EMPTY
57708: ST_TO_ADDR
// for i in list do
57709: LD_ADDR_VAR 0 7
57713: PUSH
57714: LD_VAR 0 3
57718: PUSH
57719: FOR_IN
57720: IFFALSE 57922
// begin tmp := GetDistUnitXY ( i , x , y ) ;
57722: LD_ADDR_VAR 0 9
57726: PUSH
57727: LD_VAR 0 7
57731: PPUSH
57732: LD_VAR 0 1
57736: PPUSH
57737: LD_VAR 0 2
57741: PPUSH
57742: CALL_OW 297
57746: ST_TO_ADDR
// if not result then
57747: LD_VAR 0 6
57751: NOT
57752: IFFALSE 57778
// result := [ [ i , tmp ] ] else
57754: LD_ADDR_VAR 0 6
57758: PUSH
57759: LD_VAR 0 7
57763: PUSH
57764: LD_VAR 0 9
57768: PUSH
57769: EMPTY
57770: LIST
57771: LIST
57772: PUSH
57773: EMPTY
57774: LIST
57775: ST_TO_ADDR
57776: GO 57920
// begin if result [ result ] [ 2 ] < tmp then
57778: LD_VAR 0 6
57782: PUSH
57783: LD_VAR 0 6
57787: ARRAY
57788: PUSH
57789: LD_INT 2
57791: ARRAY
57792: PUSH
57793: LD_VAR 0 9
57797: LESS
57798: IFFALSE 57840
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
57800: LD_ADDR_VAR 0 6
57804: PUSH
57805: LD_VAR 0 6
57809: PPUSH
57810: LD_VAR 0 6
57814: PUSH
57815: LD_INT 1
57817: PLUS
57818: PPUSH
57819: LD_VAR 0 7
57823: PUSH
57824: LD_VAR 0 9
57828: PUSH
57829: EMPTY
57830: LIST
57831: LIST
57832: PPUSH
57833: CALL_OW 2
57837: ST_TO_ADDR
57838: GO 57920
// for j = 1 to result do
57840: LD_ADDR_VAR 0 8
57844: PUSH
57845: DOUBLE
57846: LD_INT 1
57848: DEC
57849: ST_TO_ADDR
57850: LD_VAR 0 6
57854: PUSH
57855: FOR_TO
57856: IFFALSE 57918
// begin if tmp < result [ j ] [ 2 ] then
57858: LD_VAR 0 9
57862: PUSH
57863: LD_VAR 0 6
57867: PUSH
57868: LD_VAR 0 8
57872: ARRAY
57873: PUSH
57874: LD_INT 2
57876: ARRAY
57877: LESS
57878: IFFALSE 57916
// begin result := Insert ( result , j , [ i , tmp ] ) ;
57880: LD_ADDR_VAR 0 6
57884: PUSH
57885: LD_VAR 0 6
57889: PPUSH
57890: LD_VAR 0 8
57894: PPUSH
57895: LD_VAR 0 7
57899: PUSH
57900: LD_VAR 0 9
57904: PUSH
57905: EMPTY
57906: LIST
57907: LIST
57908: PPUSH
57909: CALL_OW 2
57913: ST_TO_ADDR
// break ;
57914: GO 57918
// end ; end ;
57916: GO 57855
57918: POP
57919: POP
// end ; end ;
57920: GO 57719
57922: POP
57923: POP
// if result and not asc then
57924: LD_VAR 0 6
57928: PUSH
57929: LD_VAR 0 4
57933: NOT
57934: AND
57935: IFFALSE 58010
// begin tmp := result ;
57937: LD_ADDR_VAR 0 9
57941: PUSH
57942: LD_VAR 0 6
57946: ST_TO_ADDR
// for i = tmp downto 1 do
57947: LD_ADDR_VAR 0 7
57951: PUSH
57952: DOUBLE
57953: LD_VAR 0 9
57957: INC
57958: ST_TO_ADDR
57959: LD_INT 1
57961: PUSH
57962: FOR_DOWNTO
57963: IFFALSE 58008
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
57965: LD_ADDR_VAR 0 6
57969: PUSH
57970: LD_VAR 0 6
57974: PPUSH
57975: LD_VAR 0 9
57979: PUSH
57980: LD_VAR 0 7
57984: MINUS
57985: PUSH
57986: LD_INT 1
57988: PLUS
57989: PPUSH
57990: LD_VAR 0 9
57994: PUSH
57995: LD_VAR 0 7
57999: ARRAY
58000: PPUSH
58001: CALL_OW 1
58005: ST_TO_ADDR
58006: GO 57962
58008: POP
58009: POP
// end ; tmp := [ ] ;
58010: LD_ADDR_VAR 0 9
58014: PUSH
58015: EMPTY
58016: ST_TO_ADDR
// if mode then
58017: LD_VAR 0 5
58021: IFFALSE 58090
// begin for i = 1 to result do
58023: LD_ADDR_VAR 0 7
58027: PUSH
58028: DOUBLE
58029: LD_INT 1
58031: DEC
58032: ST_TO_ADDR
58033: LD_VAR 0 6
58037: PUSH
58038: FOR_TO
58039: IFFALSE 58078
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
58041: LD_ADDR_VAR 0 9
58045: PUSH
58046: LD_VAR 0 9
58050: PPUSH
58051: LD_VAR 0 7
58055: PPUSH
58056: LD_VAR 0 6
58060: PUSH
58061: LD_VAR 0 7
58065: ARRAY
58066: PUSH
58067: LD_INT 1
58069: ARRAY
58070: PPUSH
58071: CALL_OW 1
58075: ST_TO_ADDR
58076: GO 58038
58078: POP
58079: POP
// result := tmp ;
58080: LD_ADDR_VAR 0 6
58084: PUSH
58085: LD_VAR 0 9
58089: ST_TO_ADDR
// end ; end ;
58090: LD_VAR 0 6
58094: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
58095: LD_INT 0
58097: PPUSH
58098: PPUSH
58099: PPUSH
58100: PPUSH
58101: PPUSH
58102: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
58103: LD_ADDR_VAR 0 5
58107: PUSH
58108: LD_INT 0
58110: PUSH
58111: LD_INT 0
58113: PUSH
58114: LD_INT 0
58116: PUSH
58117: EMPTY
58118: PUSH
58119: EMPTY
58120: LIST
58121: LIST
58122: LIST
58123: LIST
58124: ST_TO_ADDR
// if not x or not y then
58125: LD_VAR 0 2
58129: NOT
58130: PUSH
58131: LD_VAR 0 3
58135: NOT
58136: OR
58137: IFFALSE 58141
// exit ;
58139: GO 59791
// if not range then
58141: LD_VAR 0 4
58145: NOT
58146: IFFALSE 58156
// range := 10 ;
58148: LD_ADDR_VAR 0 4
58152: PUSH
58153: LD_INT 10
58155: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
58156: LD_ADDR_VAR 0 8
58160: PUSH
58161: LD_INT 81
58163: PUSH
58164: LD_VAR 0 1
58168: PUSH
58169: EMPTY
58170: LIST
58171: LIST
58172: PUSH
58173: LD_INT 92
58175: PUSH
58176: LD_VAR 0 2
58180: PUSH
58181: LD_VAR 0 3
58185: PUSH
58186: LD_VAR 0 4
58190: PUSH
58191: EMPTY
58192: LIST
58193: LIST
58194: LIST
58195: LIST
58196: PUSH
58197: LD_INT 3
58199: PUSH
58200: LD_INT 21
58202: PUSH
58203: LD_INT 3
58205: PUSH
58206: EMPTY
58207: LIST
58208: LIST
58209: PUSH
58210: EMPTY
58211: LIST
58212: LIST
58213: PUSH
58214: EMPTY
58215: LIST
58216: LIST
58217: LIST
58218: PPUSH
58219: CALL_OW 69
58223: ST_TO_ADDR
// if not tmp then
58224: LD_VAR 0 8
58228: NOT
58229: IFFALSE 58233
// exit ;
58231: GO 59791
// for i in tmp do
58233: LD_ADDR_VAR 0 6
58237: PUSH
58238: LD_VAR 0 8
58242: PUSH
58243: FOR_IN
58244: IFFALSE 59766
// begin points := [ 0 , 0 , 0 ] ;
58246: LD_ADDR_VAR 0 9
58250: PUSH
58251: LD_INT 0
58253: PUSH
58254: LD_INT 0
58256: PUSH
58257: LD_INT 0
58259: PUSH
58260: EMPTY
58261: LIST
58262: LIST
58263: LIST
58264: ST_TO_ADDR
// bpoints := 1 ;
58265: LD_ADDR_VAR 0 10
58269: PUSH
58270: LD_INT 1
58272: ST_TO_ADDR
// case GetType ( i ) of unit_human :
58273: LD_VAR 0 6
58277: PPUSH
58278: CALL_OW 247
58282: PUSH
58283: LD_INT 1
58285: DOUBLE
58286: EQUAL
58287: IFTRUE 58291
58289: GO 58869
58291: POP
// begin if GetClass ( i ) = 1 then
58292: LD_VAR 0 6
58296: PPUSH
58297: CALL_OW 257
58301: PUSH
58302: LD_INT 1
58304: EQUAL
58305: IFFALSE 58326
// points := [ 10 , 5 , 3 ] ;
58307: LD_ADDR_VAR 0 9
58311: PUSH
58312: LD_INT 10
58314: PUSH
58315: LD_INT 5
58317: PUSH
58318: LD_INT 3
58320: PUSH
58321: EMPTY
58322: LIST
58323: LIST
58324: LIST
58325: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
58326: LD_VAR 0 6
58330: PPUSH
58331: CALL_OW 257
58335: PUSH
58336: LD_INT 2
58338: PUSH
58339: LD_INT 3
58341: PUSH
58342: LD_INT 4
58344: PUSH
58345: EMPTY
58346: LIST
58347: LIST
58348: LIST
58349: IN
58350: IFFALSE 58371
// points := [ 3 , 2 , 1 ] ;
58352: LD_ADDR_VAR 0 9
58356: PUSH
58357: LD_INT 3
58359: PUSH
58360: LD_INT 2
58362: PUSH
58363: LD_INT 1
58365: PUSH
58366: EMPTY
58367: LIST
58368: LIST
58369: LIST
58370: ST_TO_ADDR
// if GetClass ( i ) = 5 then
58371: LD_VAR 0 6
58375: PPUSH
58376: CALL_OW 257
58380: PUSH
58381: LD_INT 5
58383: EQUAL
58384: IFFALSE 58405
// points := [ 130 , 5 , 2 ] ;
58386: LD_ADDR_VAR 0 9
58390: PUSH
58391: LD_INT 130
58393: PUSH
58394: LD_INT 5
58396: PUSH
58397: LD_INT 2
58399: PUSH
58400: EMPTY
58401: LIST
58402: LIST
58403: LIST
58404: ST_TO_ADDR
// if GetClass ( i ) = 8 then
58405: LD_VAR 0 6
58409: PPUSH
58410: CALL_OW 257
58414: PUSH
58415: LD_INT 8
58417: EQUAL
58418: IFFALSE 58439
// points := [ 35 , 35 , 30 ] ;
58420: LD_ADDR_VAR 0 9
58424: PUSH
58425: LD_INT 35
58427: PUSH
58428: LD_INT 35
58430: PUSH
58431: LD_INT 30
58433: PUSH
58434: EMPTY
58435: LIST
58436: LIST
58437: LIST
58438: ST_TO_ADDR
// if GetClass ( i ) = 9 then
58439: LD_VAR 0 6
58443: PPUSH
58444: CALL_OW 257
58448: PUSH
58449: LD_INT 9
58451: EQUAL
58452: IFFALSE 58473
// points := [ 20 , 55 , 40 ] ;
58454: LD_ADDR_VAR 0 9
58458: PUSH
58459: LD_INT 20
58461: PUSH
58462: LD_INT 55
58464: PUSH
58465: LD_INT 40
58467: PUSH
58468: EMPTY
58469: LIST
58470: LIST
58471: LIST
58472: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
58473: LD_VAR 0 6
58477: PPUSH
58478: CALL_OW 257
58482: PUSH
58483: LD_INT 12
58485: PUSH
58486: LD_INT 16
58488: PUSH
58489: EMPTY
58490: LIST
58491: LIST
58492: IN
58493: IFFALSE 58514
// points := [ 5 , 3 , 2 ] ;
58495: LD_ADDR_VAR 0 9
58499: PUSH
58500: LD_INT 5
58502: PUSH
58503: LD_INT 3
58505: PUSH
58506: LD_INT 2
58508: PUSH
58509: EMPTY
58510: LIST
58511: LIST
58512: LIST
58513: ST_TO_ADDR
// if GetClass ( i ) = 17 then
58514: LD_VAR 0 6
58518: PPUSH
58519: CALL_OW 257
58523: PUSH
58524: LD_INT 17
58526: EQUAL
58527: IFFALSE 58548
// points := [ 100 , 50 , 75 ] ;
58529: LD_ADDR_VAR 0 9
58533: PUSH
58534: LD_INT 100
58536: PUSH
58537: LD_INT 50
58539: PUSH
58540: LD_INT 75
58542: PUSH
58543: EMPTY
58544: LIST
58545: LIST
58546: LIST
58547: ST_TO_ADDR
// if GetClass ( i ) = 15 then
58548: LD_VAR 0 6
58552: PPUSH
58553: CALL_OW 257
58557: PUSH
58558: LD_INT 15
58560: EQUAL
58561: IFFALSE 58582
// points := [ 10 , 5 , 3 ] ;
58563: LD_ADDR_VAR 0 9
58567: PUSH
58568: LD_INT 10
58570: PUSH
58571: LD_INT 5
58573: PUSH
58574: LD_INT 3
58576: PUSH
58577: EMPTY
58578: LIST
58579: LIST
58580: LIST
58581: ST_TO_ADDR
// if GetClass ( i ) = 14 then
58582: LD_VAR 0 6
58586: PPUSH
58587: CALL_OW 257
58591: PUSH
58592: LD_INT 14
58594: EQUAL
58595: IFFALSE 58616
// points := [ 10 , 0 , 0 ] ;
58597: LD_ADDR_VAR 0 9
58601: PUSH
58602: LD_INT 10
58604: PUSH
58605: LD_INT 0
58607: PUSH
58608: LD_INT 0
58610: PUSH
58611: EMPTY
58612: LIST
58613: LIST
58614: LIST
58615: ST_TO_ADDR
// if GetClass ( i ) = 11 then
58616: LD_VAR 0 6
58620: PPUSH
58621: CALL_OW 257
58625: PUSH
58626: LD_INT 11
58628: EQUAL
58629: IFFALSE 58650
// points := [ 30 , 10 , 5 ] ;
58631: LD_ADDR_VAR 0 9
58635: PUSH
58636: LD_INT 30
58638: PUSH
58639: LD_INT 10
58641: PUSH
58642: LD_INT 5
58644: PUSH
58645: EMPTY
58646: LIST
58647: LIST
58648: LIST
58649: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
58650: LD_VAR 0 1
58654: PPUSH
58655: LD_INT 5
58657: PPUSH
58658: CALL_OW 321
58662: PUSH
58663: LD_INT 2
58665: EQUAL
58666: IFFALSE 58683
// bpoints := bpoints * 1.8 ;
58668: LD_ADDR_VAR 0 10
58672: PUSH
58673: LD_VAR 0 10
58677: PUSH
58678: LD_REAL  1.80000000000000E+0000
58681: MUL
58682: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
58683: LD_VAR 0 6
58687: PPUSH
58688: CALL_OW 257
58692: PUSH
58693: LD_INT 1
58695: PUSH
58696: LD_INT 2
58698: PUSH
58699: LD_INT 3
58701: PUSH
58702: LD_INT 4
58704: PUSH
58705: EMPTY
58706: LIST
58707: LIST
58708: LIST
58709: LIST
58710: IN
58711: PUSH
58712: LD_VAR 0 1
58716: PPUSH
58717: LD_INT 51
58719: PPUSH
58720: CALL_OW 321
58724: PUSH
58725: LD_INT 2
58727: EQUAL
58728: AND
58729: IFFALSE 58746
// bpoints := bpoints * 1.2 ;
58731: LD_ADDR_VAR 0 10
58735: PUSH
58736: LD_VAR 0 10
58740: PUSH
58741: LD_REAL  1.20000000000000E+0000
58744: MUL
58745: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
58746: LD_VAR 0 6
58750: PPUSH
58751: CALL_OW 257
58755: PUSH
58756: LD_INT 5
58758: PUSH
58759: LD_INT 7
58761: PUSH
58762: LD_INT 9
58764: PUSH
58765: EMPTY
58766: LIST
58767: LIST
58768: LIST
58769: IN
58770: PUSH
58771: LD_VAR 0 1
58775: PPUSH
58776: LD_INT 52
58778: PPUSH
58779: CALL_OW 321
58783: PUSH
58784: LD_INT 2
58786: EQUAL
58787: AND
58788: IFFALSE 58805
// bpoints := bpoints * 1.5 ;
58790: LD_ADDR_VAR 0 10
58794: PUSH
58795: LD_VAR 0 10
58799: PUSH
58800: LD_REAL  1.50000000000000E+0000
58803: MUL
58804: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
58805: LD_VAR 0 1
58809: PPUSH
58810: LD_INT 66
58812: PPUSH
58813: CALL_OW 321
58817: PUSH
58818: LD_INT 2
58820: EQUAL
58821: IFFALSE 58838
// bpoints := bpoints * 1.1 ;
58823: LD_ADDR_VAR 0 10
58827: PUSH
58828: LD_VAR 0 10
58832: PUSH
58833: LD_REAL  1.10000000000000E+0000
58836: MUL
58837: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
58838: LD_ADDR_VAR 0 10
58842: PUSH
58843: LD_VAR 0 10
58847: PUSH
58848: LD_VAR 0 6
58852: PPUSH
58853: LD_INT 1
58855: PPUSH
58856: CALL_OW 259
58860: PUSH
58861: LD_REAL  1.15000000000000E+0000
58864: MUL
58865: MUL
58866: ST_TO_ADDR
// end ; unit_vehicle :
58867: GO 59695
58869: LD_INT 2
58871: DOUBLE
58872: EQUAL
58873: IFTRUE 58877
58875: GO 59683
58877: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
58878: LD_VAR 0 6
58882: PPUSH
58883: CALL_OW 264
58887: PUSH
58888: LD_INT 2
58890: PUSH
58891: LD_INT 42
58893: PUSH
58894: LD_INT 24
58896: PUSH
58897: EMPTY
58898: LIST
58899: LIST
58900: LIST
58901: IN
58902: IFFALSE 58923
// points := [ 25 , 5 , 3 ] ;
58904: LD_ADDR_VAR 0 9
58908: PUSH
58909: LD_INT 25
58911: PUSH
58912: LD_INT 5
58914: PUSH
58915: LD_INT 3
58917: PUSH
58918: EMPTY
58919: LIST
58920: LIST
58921: LIST
58922: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
58923: LD_VAR 0 6
58927: PPUSH
58928: CALL_OW 264
58932: PUSH
58933: LD_INT 4
58935: PUSH
58936: LD_INT 43
58938: PUSH
58939: LD_INT 25
58941: PUSH
58942: EMPTY
58943: LIST
58944: LIST
58945: LIST
58946: IN
58947: IFFALSE 58968
// points := [ 40 , 15 , 5 ] ;
58949: LD_ADDR_VAR 0 9
58953: PUSH
58954: LD_INT 40
58956: PUSH
58957: LD_INT 15
58959: PUSH
58960: LD_INT 5
58962: PUSH
58963: EMPTY
58964: LIST
58965: LIST
58966: LIST
58967: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
58968: LD_VAR 0 6
58972: PPUSH
58973: CALL_OW 264
58977: PUSH
58978: LD_INT 3
58980: PUSH
58981: LD_INT 23
58983: PUSH
58984: EMPTY
58985: LIST
58986: LIST
58987: IN
58988: IFFALSE 59009
// points := [ 7 , 25 , 8 ] ;
58990: LD_ADDR_VAR 0 9
58994: PUSH
58995: LD_INT 7
58997: PUSH
58998: LD_INT 25
59000: PUSH
59001: LD_INT 8
59003: PUSH
59004: EMPTY
59005: LIST
59006: LIST
59007: LIST
59008: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
59009: LD_VAR 0 6
59013: PPUSH
59014: CALL_OW 264
59018: PUSH
59019: LD_INT 5
59021: PUSH
59022: LD_INT 27
59024: PUSH
59025: LD_INT 44
59027: PUSH
59028: EMPTY
59029: LIST
59030: LIST
59031: LIST
59032: IN
59033: IFFALSE 59054
// points := [ 14 , 50 , 16 ] ;
59035: LD_ADDR_VAR 0 9
59039: PUSH
59040: LD_INT 14
59042: PUSH
59043: LD_INT 50
59045: PUSH
59046: LD_INT 16
59048: PUSH
59049: EMPTY
59050: LIST
59051: LIST
59052: LIST
59053: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
59054: LD_VAR 0 6
59058: PPUSH
59059: CALL_OW 264
59063: PUSH
59064: LD_INT 6
59066: PUSH
59067: LD_INT 46
59069: PUSH
59070: EMPTY
59071: LIST
59072: LIST
59073: IN
59074: IFFALSE 59095
// points := [ 32 , 120 , 70 ] ;
59076: LD_ADDR_VAR 0 9
59080: PUSH
59081: LD_INT 32
59083: PUSH
59084: LD_INT 120
59086: PUSH
59087: LD_INT 70
59089: PUSH
59090: EMPTY
59091: LIST
59092: LIST
59093: LIST
59094: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
59095: LD_VAR 0 6
59099: PPUSH
59100: CALL_OW 264
59104: PUSH
59105: LD_INT 7
59107: PUSH
59108: LD_INT 28
59110: PUSH
59111: LD_INT 45
59113: PUSH
59114: LD_INT 92
59116: PUSH
59117: EMPTY
59118: LIST
59119: LIST
59120: LIST
59121: LIST
59122: IN
59123: IFFALSE 59144
// points := [ 35 , 20 , 45 ] ;
59125: LD_ADDR_VAR 0 9
59129: PUSH
59130: LD_INT 35
59132: PUSH
59133: LD_INT 20
59135: PUSH
59136: LD_INT 45
59138: PUSH
59139: EMPTY
59140: LIST
59141: LIST
59142: LIST
59143: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
59144: LD_VAR 0 6
59148: PPUSH
59149: CALL_OW 264
59153: PUSH
59154: LD_INT 47
59156: PUSH
59157: EMPTY
59158: LIST
59159: IN
59160: IFFALSE 59181
// points := [ 67 , 45 , 75 ] ;
59162: LD_ADDR_VAR 0 9
59166: PUSH
59167: LD_INT 67
59169: PUSH
59170: LD_INT 45
59172: PUSH
59173: LD_INT 75
59175: PUSH
59176: EMPTY
59177: LIST
59178: LIST
59179: LIST
59180: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
59181: LD_VAR 0 6
59185: PPUSH
59186: CALL_OW 264
59190: PUSH
59191: LD_INT 26
59193: PUSH
59194: EMPTY
59195: LIST
59196: IN
59197: IFFALSE 59218
// points := [ 120 , 30 , 80 ] ;
59199: LD_ADDR_VAR 0 9
59203: PUSH
59204: LD_INT 120
59206: PUSH
59207: LD_INT 30
59209: PUSH
59210: LD_INT 80
59212: PUSH
59213: EMPTY
59214: LIST
59215: LIST
59216: LIST
59217: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
59218: LD_VAR 0 6
59222: PPUSH
59223: CALL_OW 264
59227: PUSH
59228: LD_INT 22
59230: PUSH
59231: EMPTY
59232: LIST
59233: IN
59234: IFFALSE 59255
// points := [ 40 , 1 , 1 ] ;
59236: LD_ADDR_VAR 0 9
59240: PUSH
59241: LD_INT 40
59243: PUSH
59244: LD_INT 1
59246: PUSH
59247: LD_INT 1
59249: PUSH
59250: EMPTY
59251: LIST
59252: LIST
59253: LIST
59254: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
59255: LD_VAR 0 6
59259: PPUSH
59260: CALL_OW 264
59264: PUSH
59265: LD_INT 29
59267: PUSH
59268: EMPTY
59269: LIST
59270: IN
59271: IFFALSE 59292
// points := [ 70 , 200 , 400 ] ;
59273: LD_ADDR_VAR 0 9
59277: PUSH
59278: LD_INT 70
59280: PUSH
59281: LD_INT 200
59283: PUSH
59284: LD_INT 400
59286: PUSH
59287: EMPTY
59288: LIST
59289: LIST
59290: LIST
59291: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
59292: LD_VAR 0 6
59296: PPUSH
59297: CALL_OW 264
59301: PUSH
59302: LD_INT 14
59304: PUSH
59305: LD_INT 53
59307: PUSH
59308: EMPTY
59309: LIST
59310: LIST
59311: IN
59312: IFFALSE 59333
// points := [ 40 , 10 , 20 ] ;
59314: LD_ADDR_VAR 0 9
59318: PUSH
59319: LD_INT 40
59321: PUSH
59322: LD_INT 10
59324: PUSH
59325: LD_INT 20
59327: PUSH
59328: EMPTY
59329: LIST
59330: LIST
59331: LIST
59332: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
59333: LD_VAR 0 6
59337: PPUSH
59338: CALL_OW 264
59342: PUSH
59343: LD_INT 9
59345: PUSH
59346: EMPTY
59347: LIST
59348: IN
59349: IFFALSE 59370
// points := [ 5 , 70 , 20 ] ;
59351: LD_ADDR_VAR 0 9
59355: PUSH
59356: LD_INT 5
59358: PUSH
59359: LD_INT 70
59361: PUSH
59362: LD_INT 20
59364: PUSH
59365: EMPTY
59366: LIST
59367: LIST
59368: LIST
59369: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
59370: LD_VAR 0 6
59374: PPUSH
59375: CALL_OW 264
59379: PUSH
59380: LD_INT 10
59382: PUSH
59383: EMPTY
59384: LIST
59385: IN
59386: IFFALSE 59407
// points := [ 35 , 110 , 70 ] ;
59388: LD_ADDR_VAR 0 9
59392: PUSH
59393: LD_INT 35
59395: PUSH
59396: LD_INT 110
59398: PUSH
59399: LD_INT 70
59401: PUSH
59402: EMPTY
59403: LIST
59404: LIST
59405: LIST
59406: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
59407: LD_VAR 0 6
59411: PPUSH
59412: CALL_OW 265
59416: PUSH
59417: LD_INT 25
59419: EQUAL
59420: IFFALSE 59441
// points := [ 80 , 65 , 100 ] ;
59422: LD_ADDR_VAR 0 9
59426: PUSH
59427: LD_INT 80
59429: PUSH
59430: LD_INT 65
59432: PUSH
59433: LD_INT 100
59435: PUSH
59436: EMPTY
59437: LIST
59438: LIST
59439: LIST
59440: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
59441: LD_VAR 0 6
59445: PPUSH
59446: CALL_OW 263
59450: PUSH
59451: LD_INT 1
59453: EQUAL
59454: IFFALSE 59489
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
59456: LD_ADDR_VAR 0 10
59460: PUSH
59461: LD_VAR 0 10
59465: PUSH
59466: LD_VAR 0 6
59470: PPUSH
59471: CALL_OW 311
59475: PPUSH
59476: LD_INT 3
59478: PPUSH
59479: CALL_OW 259
59483: PUSH
59484: LD_INT 4
59486: MUL
59487: MUL
59488: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
59489: LD_VAR 0 6
59493: PPUSH
59494: CALL_OW 263
59498: PUSH
59499: LD_INT 2
59501: EQUAL
59502: IFFALSE 59553
// begin j := IsControledBy ( i ) ;
59504: LD_ADDR_VAR 0 7
59508: PUSH
59509: LD_VAR 0 6
59513: PPUSH
59514: CALL_OW 312
59518: ST_TO_ADDR
// if j then
59519: LD_VAR 0 7
59523: IFFALSE 59553
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
59525: LD_ADDR_VAR 0 10
59529: PUSH
59530: LD_VAR 0 10
59534: PUSH
59535: LD_VAR 0 7
59539: PPUSH
59540: LD_INT 3
59542: PPUSH
59543: CALL_OW 259
59547: PUSH
59548: LD_INT 3
59550: MUL
59551: MUL
59552: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
59553: LD_VAR 0 6
59557: PPUSH
59558: CALL_OW 264
59562: PUSH
59563: LD_INT 5
59565: PUSH
59566: LD_INT 6
59568: PUSH
59569: LD_INT 46
59571: PUSH
59572: LD_INT 44
59574: PUSH
59575: LD_INT 47
59577: PUSH
59578: LD_INT 45
59580: PUSH
59581: LD_INT 28
59583: PUSH
59584: LD_INT 7
59586: PUSH
59587: LD_INT 27
59589: PUSH
59590: LD_INT 29
59592: PUSH
59593: EMPTY
59594: LIST
59595: LIST
59596: LIST
59597: LIST
59598: LIST
59599: LIST
59600: LIST
59601: LIST
59602: LIST
59603: LIST
59604: IN
59605: PUSH
59606: LD_VAR 0 1
59610: PPUSH
59611: LD_INT 52
59613: PPUSH
59614: CALL_OW 321
59618: PUSH
59619: LD_INT 2
59621: EQUAL
59622: AND
59623: IFFALSE 59640
// bpoints := bpoints * 1.2 ;
59625: LD_ADDR_VAR 0 10
59629: PUSH
59630: LD_VAR 0 10
59634: PUSH
59635: LD_REAL  1.20000000000000E+0000
59638: MUL
59639: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
59640: LD_VAR 0 6
59644: PPUSH
59645: CALL_OW 264
59649: PUSH
59650: LD_INT 6
59652: PUSH
59653: LD_INT 46
59655: PUSH
59656: LD_INT 47
59658: PUSH
59659: EMPTY
59660: LIST
59661: LIST
59662: LIST
59663: IN
59664: IFFALSE 59681
// bpoints := bpoints * 1.2 ;
59666: LD_ADDR_VAR 0 10
59670: PUSH
59671: LD_VAR 0 10
59675: PUSH
59676: LD_REAL  1.20000000000000E+0000
59679: MUL
59680: ST_TO_ADDR
// end ; unit_building :
59681: GO 59695
59683: LD_INT 3
59685: DOUBLE
59686: EQUAL
59687: IFTRUE 59691
59689: GO 59694
59691: POP
// ; end ;
59692: GO 59695
59694: POP
// for j = 1 to 3 do
59695: LD_ADDR_VAR 0 7
59699: PUSH
59700: DOUBLE
59701: LD_INT 1
59703: DEC
59704: ST_TO_ADDR
59705: LD_INT 3
59707: PUSH
59708: FOR_TO
59709: IFFALSE 59762
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
59711: LD_ADDR_VAR 0 5
59715: PUSH
59716: LD_VAR 0 5
59720: PPUSH
59721: LD_VAR 0 7
59725: PPUSH
59726: LD_VAR 0 5
59730: PUSH
59731: LD_VAR 0 7
59735: ARRAY
59736: PUSH
59737: LD_VAR 0 9
59741: PUSH
59742: LD_VAR 0 7
59746: ARRAY
59747: PUSH
59748: LD_VAR 0 10
59752: MUL
59753: PLUS
59754: PPUSH
59755: CALL_OW 1
59759: ST_TO_ADDR
59760: GO 59708
59762: POP
59763: POP
// end ;
59764: GO 58243
59766: POP
59767: POP
// result := Replace ( result , 4 , tmp ) ;
59768: LD_ADDR_VAR 0 5
59772: PUSH
59773: LD_VAR 0 5
59777: PPUSH
59778: LD_INT 4
59780: PPUSH
59781: LD_VAR 0 8
59785: PPUSH
59786: CALL_OW 1
59790: ST_TO_ADDR
// end ;
59791: LD_VAR 0 5
59795: RET
// export function DangerAtRange ( unit , range ) ; begin
59796: LD_INT 0
59798: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
59799: LD_ADDR_VAR 0 3
59803: PUSH
59804: LD_VAR 0 1
59808: PPUSH
59809: CALL_OW 255
59813: PPUSH
59814: LD_VAR 0 1
59818: PPUSH
59819: CALL_OW 250
59823: PPUSH
59824: LD_VAR 0 1
59828: PPUSH
59829: CALL_OW 251
59833: PPUSH
59834: LD_VAR 0 2
59838: PPUSH
59839: CALL 58095 0 4
59843: ST_TO_ADDR
// end ;
59844: LD_VAR 0 3
59848: RET
// export function DangerInArea ( side , area ) ; begin
59849: LD_INT 0
59851: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
59852: LD_ADDR_VAR 0 3
59856: PUSH
59857: LD_VAR 0 2
59861: PPUSH
59862: LD_INT 81
59864: PUSH
59865: LD_VAR 0 1
59869: PUSH
59870: EMPTY
59871: LIST
59872: LIST
59873: PPUSH
59874: CALL_OW 70
59878: ST_TO_ADDR
// end ;
59879: LD_VAR 0 3
59883: RET
// export function IsExtension ( b ) ; begin
59884: LD_INT 0
59886: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
59887: LD_ADDR_VAR 0 2
59891: PUSH
59892: LD_VAR 0 1
59896: PUSH
59897: LD_INT 23
59899: PUSH
59900: LD_INT 20
59902: PUSH
59903: LD_INT 22
59905: PUSH
59906: LD_INT 17
59908: PUSH
59909: LD_INT 24
59911: PUSH
59912: LD_INT 21
59914: PUSH
59915: LD_INT 19
59917: PUSH
59918: LD_INT 16
59920: PUSH
59921: LD_INT 25
59923: PUSH
59924: LD_INT 18
59926: PUSH
59927: EMPTY
59928: LIST
59929: LIST
59930: LIST
59931: LIST
59932: LIST
59933: LIST
59934: LIST
59935: LIST
59936: LIST
59937: LIST
59938: IN
59939: ST_TO_ADDR
// end ;
59940: LD_VAR 0 2
59944: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
59945: LD_INT 0
59947: PPUSH
59948: PPUSH
59949: PPUSH
// result := [ ] ;
59950: LD_ADDR_VAR 0 4
59954: PUSH
59955: EMPTY
59956: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
59957: LD_ADDR_VAR 0 5
59961: PUSH
59962: LD_VAR 0 2
59966: PPUSH
59967: LD_INT 21
59969: PUSH
59970: LD_INT 3
59972: PUSH
59973: EMPTY
59974: LIST
59975: LIST
59976: PPUSH
59977: CALL_OW 70
59981: ST_TO_ADDR
// if not tmp then
59982: LD_VAR 0 5
59986: NOT
59987: IFFALSE 59991
// exit ;
59989: GO 60055
// if checkLink then
59991: LD_VAR 0 3
59995: IFFALSE 60045
// begin for i in tmp do
59997: LD_ADDR_VAR 0 6
60001: PUSH
60002: LD_VAR 0 5
60006: PUSH
60007: FOR_IN
60008: IFFALSE 60043
// if GetBase ( i ) <> base then
60010: LD_VAR 0 6
60014: PPUSH
60015: CALL_OW 274
60019: PUSH
60020: LD_VAR 0 1
60024: NONEQUAL
60025: IFFALSE 60041
// ComLinkToBase ( base , i ) ;
60027: LD_VAR 0 1
60031: PPUSH
60032: LD_VAR 0 6
60036: PPUSH
60037: CALL_OW 169
60041: GO 60007
60043: POP
60044: POP
// end ; result := tmp ;
60045: LD_ADDR_VAR 0 4
60049: PUSH
60050: LD_VAR 0 5
60054: ST_TO_ADDR
// end ;
60055: LD_VAR 0 4
60059: RET
// export function ComComplete ( units , b ) ; var i ; begin
60060: LD_INT 0
60062: PPUSH
60063: PPUSH
// if not units then
60064: LD_VAR 0 1
60068: NOT
60069: IFFALSE 60073
// exit ;
60071: GO 60163
// for i in units do
60073: LD_ADDR_VAR 0 4
60077: PUSH
60078: LD_VAR 0 1
60082: PUSH
60083: FOR_IN
60084: IFFALSE 60161
// if BuildingStatus ( b ) = bs_build then
60086: LD_VAR 0 2
60090: PPUSH
60091: CALL_OW 461
60095: PUSH
60096: LD_INT 1
60098: EQUAL
60099: IFFALSE 60159
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
60101: LD_VAR 0 4
60105: PPUSH
60106: LD_STRING h
60108: PUSH
60109: LD_VAR 0 2
60113: PPUSH
60114: CALL_OW 250
60118: PUSH
60119: LD_VAR 0 2
60123: PPUSH
60124: CALL_OW 251
60128: PUSH
60129: LD_VAR 0 2
60133: PUSH
60134: LD_INT 0
60136: PUSH
60137: LD_INT 0
60139: PUSH
60140: LD_INT 0
60142: PUSH
60143: EMPTY
60144: LIST
60145: LIST
60146: LIST
60147: LIST
60148: LIST
60149: LIST
60150: LIST
60151: PUSH
60152: EMPTY
60153: LIST
60154: PPUSH
60155: CALL_OW 446
60159: GO 60083
60161: POP
60162: POP
// end ;
60163: LD_VAR 0 3
60167: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
60168: LD_INT 0
60170: PPUSH
60171: PPUSH
60172: PPUSH
60173: PPUSH
60174: PPUSH
60175: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
60176: LD_VAR 0 1
60180: NOT
60181: PUSH
60182: LD_VAR 0 1
60186: PPUSH
60187: CALL_OW 263
60191: PUSH
60192: LD_INT 2
60194: NONEQUAL
60195: OR
60196: IFFALSE 60200
// exit ;
60198: GO 60516
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
60200: LD_ADDR_VAR 0 6
60204: PUSH
60205: LD_INT 22
60207: PUSH
60208: LD_VAR 0 1
60212: PPUSH
60213: CALL_OW 255
60217: PUSH
60218: EMPTY
60219: LIST
60220: LIST
60221: PUSH
60222: LD_INT 2
60224: PUSH
60225: LD_INT 30
60227: PUSH
60228: LD_INT 36
60230: PUSH
60231: EMPTY
60232: LIST
60233: LIST
60234: PUSH
60235: LD_INT 34
60237: PUSH
60238: LD_INT 31
60240: PUSH
60241: EMPTY
60242: LIST
60243: LIST
60244: PUSH
60245: EMPTY
60246: LIST
60247: LIST
60248: LIST
60249: PUSH
60250: EMPTY
60251: LIST
60252: LIST
60253: PPUSH
60254: CALL_OW 69
60258: ST_TO_ADDR
// if not tmp then
60259: LD_VAR 0 6
60263: NOT
60264: IFFALSE 60268
// exit ;
60266: GO 60516
// result := [ ] ;
60268: LD_ADDR_VAR 0 2
60272: PUSH
60273: EMPTY
60274: ST_TO_ADDR
// for i in tmp do
60275: LD_ADDR_VAR 0 3
60279: PUSH
60280: LD_VAR 0 6
60284: PUSH
60285: FOR_IN
60286: IFFALSE 60357
// begin t := UnitsInside ( i ) ;
60288: LD_ADDR_VAR 0 4
60292: PUSH
60293: LD_VAR 0 3
60297: PPUSH
60298: CALL_OW 313
60302: ST_TO_ADDR
// if t then
60303: LD_VAR 0 4
60307: IFFALSE 60355
// for j in t do
60309: LD_ADDR_VAR 0 7
60313: PUSH
60314: LD_VAR 0 4
60318: PUSH
60319: FOR_IN
60320: IFFALSE 60353
// result := Replace ( result , result + 1 , j ) ;
60322: LD_ADDR_VAR 0 2
60326: PUSH
60327: LD_VAR 0 2
60331: PPUSH
60332: LD_VAR 0 2
60336: PUSH
60337: LD_INT 1
60339: PLUS
60340: PPUSH
60341: LD_VAR 0 7
60345: PPUSH
60346: CALL_OW 1
60350: ST_TO_ADDR
60351: GO 60319
60353: POP
60354: POP
// end ;
60355: GO 60285
60357: POP
60358: POP
// if not result then
60359: LD_VAR 0 2
60363: NOT
60364: IFFALSE 60368
// exit ;
60366: GO 60516
// mech := result [ 1 ] ;
60368: LD_ADDR_VAR 0 5
60372: PUSH
60373: LD_VAR 0 2
60377: PUSH
60378: LD_INT 1
60380: ARRAY
60381: ST_TO_ADDR
// if result > 1 then
60382: LD_VAR 0 2
60386: PUSH
60387: LD_INT 1
60389: GREATER
60390: IFFALSE 60502
// begin for i = 2 to result do
60392: LD_ADDR_VAR 0 3
60396: PUSH
60397: DOUBLE
60398: LD_INT 2
60400: DEC
60401: ST_TO_ADDR
60402: LD_VAR 0 2
60406: PUSH
60407: FOR_TO
60408: IFFALSE 60500
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
60410: LD_ADDR_VAR 0 4
60414: PUSH
60415: LD_VAR 0 2
60419: PUSH
60420: LD_VAR 0 3
60424: ARRAY
60425: PPUSH
60426: LD_INT 3
60428: PPUSH
60429: CALL_OW 259
60433: PUSH
60434: LD_VAR 0 2
60438: PUSH
60439: LD_VAR 0 3
60443: ARRAY
60444: PPUSH
60445: CALL_OW 432
60449: MINUS
60450: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
60451: LD_VAR 0 4
60455: PUSH
60456: LD_VAR 0 5
60460: PPUSH
60461: LD_INT 3
60463: PPUSH
60464: CALL_OW 259
60468: PUSH
60469: LD_VAR 0 5
60473: PPUSH
60474: CALL_OW 432
60478: MINUS
60479: GREATEREQUAL
60480: IFFALSE 60498
// mech := result [ i ] ;
60482: LD_ADDR_VAR 0 5
60486: PUSH
60487: LD_VAR 0 2
60491: PUSH
60492: LD_VAR 0 3
60496: ARRAY
60497: ST_TO_ADDR
// end ;
60498: GO 60407
60500: POP
60501: POP
// end ; ComLinkTo ( vehicle , mech ) ;
60502: LD_VAR 0 1
60506: PPUSH
60507: LD_VAR 0 5
60511: PPUSH
60512: CALL_OW 135
// end ;
60516: LD_VAR 0 2
60520: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
60521: LD_INT 0
60523: PPUSH
60524: PPUSH
60525: PPUSH
60526: PPUSH
60527: PPUSH
60528: PPUSH
60529: PPUSH
60530: PPUSH
60531: PPUSH
60532: PPUSH
60533: PPUSH
60534: PPUSH
60535: PPUSH
// result := [ ] ;
60536: LD_ADDR_VAR 0 7
60540: PUSH
60541: EMPTY
60542: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
60543: LD_VAR 0 1
60547: PPUSH
60548: CALL_OW 266
60552: PUSH
60553: LD_INT 0
60555: PUSH
60556: LD_INT 1
60558: PUSH
60559: EMPTY
60560: LIST
60561: LIST
60562: IN
60563: NOT
60564: IFFALSE 60568
// exit ;
60566: GO 62202
// if name then
60568: LD_VAR 0 3
60572: IFFALSE 60588
// SetBName ( base_dep , name ) ;
60574: LD_VAR 0 1
60578: PPUSH
60579: LD_VAR 0 3
60583: PPUSH
60584: CALL_OW 500
// base := GetBase ( base_dep ) ;
60588: LD_ADDR_VAR 0 15
60592: PUSH
60593: LD_VAR 0 1
60597: PPUSH
60598: CALL_OW 274
60602: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
60603: LD_ADDR_VAR 0 16
60607: PUSH
60608: LD_VAR 0 1
60612: PPUSH
60613: CALL_OW 255
60617: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
60618: LD_ADDR_VAR 0 17
60622: PUSH
60623: LD_VAR 0 1
60627: PPUSH
60628: CALL_OW 248
60632: ST_TO_ADDR
// if sources then
60633: LD_VAR 0 5
60637: IFFALSE 60684
// for i = 1 to 3 do
60639: LD_ADDR_VAR 0 8
60643: PUSH
60644: DOUBLE
60645: LD_INT 1
60647: DEC
60648: ST_TO_ADDR
60649: LD_INT 3
60651: PUSH
60652: FOR_TO
60653: IFFALSE 60682
// AddResourceType ( base , i , sources [ i ] ) ;
60655: LD_VAR 0 15
60659: PPUSH
60660: LD_VAR 0 8
60664: PPUSH
60665: LD_VAR 0 5
60669: PUSH
60670: LD_VAR 0 8
60674: ARRAY
60675: PPUSH
60676: CALL_OW 276
60680: GO 60652
60682: POP
60683: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
60684: LD_ADDR_VAR 0 18
60688: PUSH
60689: LD_VAR 0 15
60693: PPUSH
60694: LD_VAR 0 2
60698: PPUSH
60699: LD_INT 1
60701: PPUSH
60702: CALL 59945 0 3
60706: ST_TO_ADDR
// InitHc ;
60707: CALL_OW 19
// InitUc ;
60711: CALL_OW 18
// uc_side := side ;
60715: LD_ADDR_OWVAR 20
60719: PUSH
60720: LD_VAR 0 16
60724: ST_TO_ADDR
// uc_nation := nation ;
60725: LD_ADDR_OWVAR 21
60729: PUSH
60730: LD_VAR 0 17
60734: ST_TO_ADDR
// if buildings then
60735: LD_VAR 0 18
60739: IFFALSE 62061
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
60741: LD_ADDR_VAR 0 19
60745: PUSH
60746: LD_VAR 0 18
60750: PPUSH
60751: LD_INT 2
60753: PUSH
60754: LD_INT 30
60756: PUSH
60757: LD_INT 29
60759: PUSH
60760: EMPTY
60761: LIST
60762: LIST
60763: PUSH
60764: LD_INT 30
60766: PUSH
60767: LD_INT 30
60769: PUSH
60770: EMPTY
60771: LIST
60772: LIST
60773: PUSH
60774: EMPTY
60775: LIST
60776: LIST
60777: LIST
60778: PPUSH
60779: CALL_OW 72
60783: ST_TO_ADDR
// if tmp then
60784: LD_VAR 0 19
60788: IFFALSE 60836
// for i in tmp do
60790: LD_ADDR_VAR 0 8
60794: PUSH
60795: LD_VAR 0 19
60799: PUSH
60800: FOR_IN
60801: IFFALSE 60834
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
60803: LD_VAR 0 8
60807: PPUSH
60808: CALL_OW 250
60812: PPUSH
60813: LD_VAR 0 8
60817: PPUSH
60818: CALL_OW 251
60822: PPUSH
60823: LD_VAR 0 16
60827: PPUSH
60828: CALL_OW 441
60832: GO 60800
60834: POP
60835: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
60836: LD_VAR 0 18
60840: PPUSH
60841: LD_INT 2
60843: PUSH
60844: LD_INT 30
60846: PUSH
60847: LD_INT 32
60849: PUSH
60850: EMPTY
60851: LIST
60852: LIST
60853: PUSH
60854: LD_INT 30
60856: PUSH
60857: LD_INT 33
60859: PUSH
60860: EMPTY
60861: LIST
60862: LIST
60863: PUSH
60864: EMPTY
60865: LIST
60866: LIST
60867: LIST
60868: PPUSH
60869: CALL_OW 72
60873: IFFALSE 60961
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
60875: LD_ADDR_VAR 0 8
60879: PUSH
60880: LD_VAR 0 18
60884: PPUSH
60885: LD_INT 2
60887: PUSH
60888: LD_INT 30
60890: PUSH
60891: LD_INT 32
60893: PUSH
60894: EMPTY
60895: LIST
60896: LIST
60897: PUSH
60898: LD_INT 30
60900: PUSH
60901: LD_INT 33
60903: PUSH
60904: EMPTY
60905: LIST
60906: LIST
60907: PUSH
60908: EMPTY
60909: LIST
60910: LIST
60911: LIST
60912: PPUSH
60913: CALL_OW 72
60917: PUSH
60918: FOR_IN
60919: IFFALSE 60959
// begin if not GetBWeapon ( i ) then
60921: LD_VAR 0 8
60925: PPUSH
60926: CALL_OW 269
60930: NOT
60931: IFFALSE 60957
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
60933: LD_VAR 0 8
60937: PPUSH
60938: LD_VAR 0 8
60942: PPUSH
60943: LD_VAR 0 2
60947: PPUSH
60948: CALL 62207 0 2
60952: PPUSH
60953: CALL_OW 431
// end ;
60957: GO 60918
60959: POP
60960: POP
// end ; for i = 1 to personel do
60961: LD_ADDR_VAR 0 8
60965: PUSH
60966: DOUBLE
60967: LD_INT 1
60969: DEC
60970: ST_TO_ADDR
60971: LD_VAR 0 6
60975: PUSH
60976: FOR_TO
60977: IFFALSE 62041
// begin if i > 4 then
60979: LD_VAR 0 8
60983: PUSH
60984: LD_INT 4
60986: GREATER
60987: IFFALSE 60991
// break ;
60989: GO 62041
// case i of 1 :
60991: LD_VAR 0 8
60995: PUSH
60996: LD_INT 1
60998: DOUBLE
60999: EQUAL
61000: IFTRUE 61004
61002: GO 61084
61004: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
61005: LD_ADDR_VAR 0 12
61009: PUSH
61010: LD_VAR 0 18
61014: PPUSH
61015: LD_INT 22
61017: PUSH
61018: LD_VAR 0 16
61022: PUSH
61023: EMPTY
61024: LIST
61025: LIST
61026: PUSH
61027: LD_INT 58
61029: PUSH
61030: EMPTY
61031: LIST
61032: PUSH
61033: LD_INT 2
61035: PUSH
61036: LD_INT 30
61038: PUSH
61039: LD_INT 32
61041: PUSH
61042: EMPTY
61043: LIST
61044: LIST
61045: PUSH
61046: LD_INT 30
61048: PUSH
61049: LD_INT 4
61051: PUSH
61052: EMPTY
61053: LIST
61054: LIST
61055: PUSH
61056: LD_INT 30
61058: PUSH
61059: LD_INT 5
61061: PUSH
61062: EMPTY
61063: LIST
61064: LIST
61065: PUSH
61066: EMPTY
61067: LIST
61068: LIST
61069: LIST
61070: LIST
61071: PUSH
61072: EMPTY
61073: LIST
61074: LIST
61075: LIST
61076: PPUSH
61077: CALL_OW 72
61081: ST_TO_ADDR
61082: GO 61306
61084: LD_INT 2
61086: DOUBLE
61087: EQUAL
61088: IFTRUE 61092
61090: GO 61154
61092: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
61093: LD_ADDR_VAR 0 12
61097: PUSH
61098: LD_VAR 0 18
61102: PPUSH
61103: LD_INT 22
61105: PUSH
61106: LD_VAR 0 16
61110: PUSH
61111: EMPTY
61112: LIST
61113: LIST
61114: PUSH
61115: LD_INT 2
61117: PUSH
61118: LD_INT 30
61120: PUSH
61121: LD_INT 0
61123: PUSH
61124: EMPTY
61125: LIST
61126: LIST
61127: PUSH
61128: LD_INT 30
61130: PUSH
61131: LD_INT 1
61133: PUSH
61134: EMPTY
61135: LIST
61136: LIST
61137: PUSH
61138: EMPTY
61139: LIST
61140: LIST
61141: LIST
61142: PUSH
61143: EMPTY
61144: LIST
61145: LIST
61146: PPUSH
61147: CALL_OW 72
61151: ST_TO_ADDR
61152: GO 61306
61154: LD_INT 3
61156: DOUBLE
61157: EQUAL
61158: IFTRUE 61162
61160: GO 61224
61162: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
61163: LD_ADDR_VAR 0 12
61167: PUSH
61168: LD_VAR 0 18
61172: PPUSH
61173: LD_INT 22
61175: PUSH
61176: LD_VAR 0 16
61180: PUSH
61181: EMPTY
61182: LIST
61183: LIST
61184: PUSH
61185: LD_INT 2
61187: PUSH
61188: LD_INT 30
61190: PUSH
61191: LD_INT 2
61193: PUSH
61194: EMPTY
61195: LIST
61196: LIST
61197: PUSH
61198: LD_INT 30
61200: PUSH
61201: LD_INT 3
61203: PUSH
61204: EMPTY
61205: LIST
61206: LIST
61207: PUSH
61208: EMPTY
61209: LIST
61210: LIST
61211: LIST
61212: PUSH
61213: EMPTY
61214: LIST
61215: LIST
61216: PPUSH
61217: CALL_OW 72
61221: ST_TO_ADDR
61222: GO 61306
61224: LD_INT 4
61226: DOUBLE
61227: EQUAL
61228: IFTRUE 61232
61230: GO 61305
61232: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
61233: LD_ADDR_VAR 0 12
61237: PUSH
61238: LD_VAR 0 18
61242: PPUSH
61243: LD_INT 22
61245: PUSH
61246: LD_VAR 0 16
61250: PUSH
61251: EMPTY
61252: LIST
61253: LIST
61254: PUSH
61255: LD_INT 2
61257: PUSH
61258: LD_INT 30
61260: PUSH
61261: LD_INT 6
61263: PUSH
61264: EMPTY
61265: LIST
61266: LIST
61267: PUSH
61268: LD_INT 30
61270: PUSH
61271: LD_INT 7
61273: PUSH
61274: EMPTY
61275: LIST
61276: LIST
61277: PUSH
61278: LD_INT 30
61280: PUSH
61281: LD_INT 8
61283: PUSH
61284: EMPTY
61285: LIST
61286: LIST
61287: PUSH
61288: EMPTY
61289: LIST
61290: LIST
61291: LIST
61292: LIST
61293: PUSH
61294: EMPTY
61295: LIST
61296: LIST
61297: PPUSH
61298: CALL_OW 72
61302: ST_TO_ADDR
61303: GO 61306
61305: POP
// if i = 1 then
61306: LD_VAR 0 8
61310: PUSH
61311: LD_INT 1
61313: EQUAL
61314: IFFALSE 61425
// begin tmp := [ ] ;
61316: LD_ADDR_VAR 0 19
61320: PUSH
61321: EMPTY
61322: ST_TO_ADDR
// for j in f do
61323: LD_ADDR_VAR 0 9
61327: PUSH
61328: LD_VAR 0 12
61332: PUSH
61333: FOR_IN
61334: IFFALSE 61407
// if GetBType ( j ) = b_bunker then
61336: LD_VAR 0 9
61340: PPUSH
61341: CALL_OW 266
61345: PUSH
61346: LD_INT 32
61348: EQUAL
61349: IFFALSE 61376
// tmp := Insert ( tmp , 1 , j ) else
61351: LD_ADDR_VAR 0 19
61355: PUSH
61356: LD_VAR 0 19
61360: PPUSH
61361: LD_INT 1
61363: PPUSH
61364: LD_VAR 0 9
61368: PPUSH
61369: CALL_OW 2
61373: ST_TO_ADDR
61374: GO 61405
// tmp := Insert ( tmp , tmp + 1 , j ) ;
61376: LD_ADDR_VAR 0 19
61380: PUSH
61381: LD_VAR 0 19
61385: PPUSH
61386: LD_VAR 0 19
61390: PUSH
61391: LD_INT 1
61393: PLUS
61394: PPUSH
61395: LD_VAR 0 9
61399: PPUSH
61400: CALL_OW 2
61404: ST_TO_ADDR
61405: GO 61333
61407: POP
61408: POP
// if tmp then
61409: LD_VAR 0 19
61413: IFFALSE 61425
// f := tmp ;
61415: LD_ADDR_VAR 0 12
61419: PUSH
61420: LD_VAR 0 19
61424: ST_TO_ADDR
// end ; x := personel [ i ] ;
61425: LD_ADDR_VAR 0 13
61429: PUSH
61430: LD_VAR 0 6
61434: PUSH
61435: LD_VAR 0 8
61439: ARRAY
61440: ST_TO_ADDR
// if x = - 1 then
61441: LD_VAR 0 13
61445: PUSH
61446: LD_INT 1
61448: NEG
61449: EQUAL
61450: IFFALSE 61659
// begin for j in f do
61452: LD_ADDR_VAR 0 9
61456: PUSH
61457: LD_VAR 0 12
61461: PUSH
61462: FOR_IN
61463: IFFALSE 61655
// repeat InitHc ;
61465: CALL_OW 19
// if GetBType ( j ) = b_barracks then
61469: LD_VAR 0 9
61473: PPUSH
61474: CALL_OW 266
61478: PUSH
61479: LD_INT 5
61481: EQUAL
61482: IFFALSE 61552
// begin if UnitsInside ( j ) < 3 then
61484: LD_VAR 0 9
61488: PPUSH
61489: CALL_OW 313
61493: PUSH
61494: LD_INT 3
61496: LESS
61497: IFFALSE 61533
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
61499: LD_INT 0
61501: PPUSH
61502: LD_INT 5
61504: PUSH
61505: LD_INT 8
61507: PUSH
61508: LD_INT 9
61510: PUSH
61511: EMPTY
61512: LIST
61513: LIST
61514: LIST
61515: PUSH
61516: LD_VAR 0 17
61520: ARRAY
61521: PPUSH
61522: LD_VAR 0 4
61526: PPUSH
61527: CALL_OW 380
61531: GO 61550
// PrepareHuman ( false , i , skill ) ;
61533: LD_INT 0
61535: PPUSH
61536: LD_VAR 0 8
61540: PPUSH
61541: LD_VAR 0 4
61545: PPUSH
61546: CALL_OW 380
// end else
61550: GO 61569
// PrepareHuman ( false , i , skill ) ;
61552: LD_INT 0
61554: PPUSH
61555: LD_VAR 0 8
61559: PPUSH
61560: LD_VAR 0 4
61564: PPUSH
61565: CALL_OW 380
// un := CreateHuman ;
61569: LD_ADDR_VAR 0 14
61573: PUSH
61574: CALL_OW 44
61578: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61579: LD_ADDR_VAR 0 7
61583: PUSH
61584: LD_VAR 0 7
61588: PPUSH
61589: LD_INT 1
61591: PPUSH
61592: LD_VAR 0 14
61596: PPUSH
61597: CALL_OW 2
61601: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
61602: LD_VAR 0 14
61606: PPUSH
61607: LD_VAR 0 9
61611: PPUSH
61612: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
61616: LD_VAR 0 9
61620: PPUSH
61621: CALL_OW 313
61625: PUSH
61626: LD_INT 6
61628: EQUAL
61629: PUSH
61630: LD_VAR 0 9
61634: PPUSH
61635: CALL_OW 266
61639: PUSH
61640: LD_INT 32
61642: PUSH
61643: LD_INT 31
61645: PUSH
61646: EMPTY
61647: LIST
61648: LIST
61649: IN
61650: OR
61651: IFFALSE 61465
61653: GO 61462
61655: POP
61656: POP
// end else
61657: GO 62039
// for j = 1 to x do
61659: LD_ADDR_VAR 0 9
61663: PUSH
61664: DOUBLE
61665: LD_INT 1
61667: DEC
61668: ST_TO_ADDR
61669: LD_VAR 0 13
61673: PUSH
61674: FOR_TO
61675: IFFALSE 62037
// begin InitHc ;
61677: CALL_OW 19
// if not f then
61681: LD_VAR 0 12
61685: NOT
61686: IFFALSE 61775
// begin PrepareHuman ( false , i , skill ) ;
61688: LD_INT 0
61690: PPUSH
61691: LD_VAR 0 8
61695: PPUSH
61696: LD_VAR 0 4
61700: PPUSH
61701: CALL_OW 380
// un := CreateHuman ;
61705: LD_ADDR_VAR 0 14
61709: PUSH
61710: CALL_OW 44
61714: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61715: LD_ADDR_VAR 0 7
61719: PUSH
61720: LD_VAR 0 7
61724: PPUSH
61725: LD_INT 1
61727: PPUSH
61728: LD_VAR 0 14
61732: PPUSH
61733: CALL_OW 2
61737: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
61738: LD_VAR 0 14
61742: PPUSH
61743: LD_VAR 0 1
61747: PPUSH
61748: CALL_OW 250
61752: PPUSH
61753: LD_VAR 0 1
61757: PPUSH
61758: CALL_OW 251
61762: PPUSH
61763: LD_INT 10
61765: PPUSH
61766: LD_INT 0
61768: PPUSH
61769: CALL_OW 50
// continue ;
61773: GO 61674
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
61775: LD_VAR 0 12
61779: PUSH
61780: LD_INT 1
61782: ARRAY
61783: PPUSH
61784: CALL_OW 313
61788: PUSH
61789: LD_VAR 0 12
61793: PUSH
61794: LD_INT 1
61796: ARRAY
61797: PPUSH
61798: CALL_OW 266
61802: PUSH
61803: LD_INT 32
61805: PUSH
61806: LD_INT 31
61808: PUSH
61809: EMPTY
61810: LIST
61811: LIST
61812: IN
61813: AND
61814: PUSH
61815: LD_VAR 0 12
61819: PUSH
61820: LD_INT 1
61822: ARRAY
61823: PPUSH
61824: CALL_OW 313
61828: PUSH
61829: LD_INT 6
61831: EQUAL
61832: OR
61833: IFFALSE 61853
// f := Delete ( f , 1 ) ;
61835: LD_ADDR_VAR 0 12
61839: PUSH
61840: LD_VAR 0 12
61844: PPUSH
61845: LD_INT 1
61847: PPUSH
61848: CALL_OW 3
61852: ST_TO_ADDR
// if not f then
61853: LD_VAR 0 12
61857: NOT
61858: IFFALSE 61876
// begin x := x + 2 ;
61860: LD_ADDR_VAR 0 13
61864: PUSH
61865: LD_VAR 0 13
61869: PUSH
61870: LD_INT 2
61872: PLUS
61873: ST_TO_ADDR
// continue ;
61874: GO 61674
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
61876: LD_VAR 0 12
61880: PUSH
61881: LD_INT 1
61883: ARRAY
61884: PPUSH
61885: CALL_OW 266
61889: PUSH
61890: LD_INT 5
61892: EQUAL
61893: IFFALSE 61967
// begin if UnitsInside ( f [ 1 ] ) < 3 then
61895: LD_VAR 0 12
61899: PUSH
61900: LD_INT 1
61902: ARRAY
61903: PPUSH
61904: CALL_OW 313
61908: PUSH
61909: LD_INT 3
61911: LESS
61912: IFFALSE 61948
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
61914: LD_INT 0
61916: PPUSH
61917: LD_INT 5
61919: PUSH
61920: LD_INT 8
61922: PUSH
61923: LD_INT 9
61925: PUSH
61926: EMPTY
61927: LIST
61928: LIST
61929: LIST
61930: PUSH
61931: LD_VAR 0 17
61935: ARRAY
61936: PPUSH
61937: LD_VAR 0 4
61941: PPUSH
61942: CALL_OW 380
61946: GO 61965
// PrepareHuman ( false , i , skill ) ;
61948: LD_INT 0
61950: PPUSH
61951: LD_VAR 0 8
61955: PPUSH
61956: LD_VAR 0 4
61960: PPUSH
61961: CALL_OW 380
// end else
61965: GO 61984
// PrepareHuman ( false , i , skill ) ;
61967: LD_INT 0
61969: PPUSH
61970: LD_VAR 0 8
61974: PPUSH
61975: LD_VAR 0 4
61979: PPUSH
61980: CALL_OW 380
// un := CreateHuman ;
61984: LD_ADDR_VAR 0 14
61988: PUSH
61989: CALL_OW 44
61993: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61994: LD_ADDR_VAR 0 7
61998: PUSH
61999: LD_VAR 0 7
62003: PPUSH
62004: LD_INT 1
62006: PPUSH
62007: LD_VAR 0 14
62011: PPUSH
62012: CALL_OW 2
62016: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
62017: LD_VAR 0 14
62021: PPUSH
62022: LD_VAR 0 12
62026: PUSH
62027: LD_INT 1
62029: ARRAY
62030: PPUSH
62031: CALL_OW 52
// end ;
62035: GO 61674
62037: POP
62038: POP
// end ;
62039: GO 60976
62041: POP
62042: POP
// result := result ^ buildings ;
62043: LD_ADDR_VAR 0 7
62047: PUSH
62048: LD_VAR 0 7
62052: PUSH
62053: LD_VAR 0 18
62057: ADD
62058: ST_TO_ADDR
// end else
62059: GO 62202
// begin for i = 1 to personel do
62061: LD_ADDR_VAR 0 8
62065: PUSH
62066: DOUBLE
62067: LD_INT 1
62069: DEC
62070: ST_TO_ADDR
62071: LD_VAR 0 6
62075: PUSH
62076: FOR_TO
62077: IFFALSE 62200
// begin if i > 4 then
62079: LD_VAR 0 8
62083: PUSH
62084: LD_INT 4
62086: GREATER
62087: IFFALSE 62091
// break ;
62089: GO 62200
// x := personel [ i ] ;
62091: LD_ADDR_VAR 0 13
62095: PUSH
62096: LD_VAR 0 6
62100: PUSH
62101: LD_VAR 0 8
62105: ARRAY
62106: ST_TO_ADDR
// if x = - 1 then
62107: LD_VAR 0 13
62111: PUSH
62112: LD_INT 1
62114: NEG
62115: EQUAL
62116: IFFALSE 62120
// continue ;
62118: GO 62076
// PrepareHuman ( false , i , skill ) ;
62120: LD_INT 0
62122: PPUSH
62123: LD_VAR 0 8
62127: PPUSH
62128: LD_VAR 0 4
62132: PPUSH
62133: CALL_OW 380
// un := CreateHuman ;
62137: LD_ADDR_VAR 0 14
62141: PUSH
62142: CALL_OW 44
62146: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
62147: LD_VAR 0 14
62151: PPUSH
62152: LD_VAR 0 1
62156: PPUSH
62157: CALL_OW 250
62161: PPUSH
62162: LD_VAR 0 1
62166: PPUSH
62167: CALL_OW 251
62171: PPUSH
62172: LD_INT 10
62174: PPUSH
62175: LD_INT 0
62177: PPUSH
62178: CALL_OW 50
// result := result ^ un ;
62182: LD_ADDR_VAR 0 7
62186: PUSH
62187: LD_VAR 0 7
62191: PUSH
62192: LD_VAR 0 14
62196: ADD
62197: ST_TO_ADDR
// end ;
62198: GO 62076
62200: POP
62201: POP
// end ; end ;
62202: LD_VAR 0 7
62206: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
62207: LD_INT 0
62209: PPUSH
62210: PPUSH
62211: PPUSH
62212: PPUSH
62213: PPUSH
62214: PPUSH
62215: PPUSH
62216: PPUSH
62217: PPUSH
62218: PPUSH
62219: PPUSH
62220: PPUSH
62221: PPUSH
62222: PPUSH
62223: PPUSH
62224: PPUSH
// result := false ;
62225: LD_ADDR_VAR 0 3
62229: PUSH
62230: LD_INT 0
62232: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
62233: LD_VAR 0 1
62237: NOT
62238: PUSH
62239: LD_VAR 0 1
62243: PPUSH
62244: CALL_OW 266
62248: PUSH
62249: LD_INT 32
62251: PUSH
62252: LD_INT 33
62254: PUSH
62255: EMPTY
62256: LIST
62257: LIST
62258: IN
62259: NOT
62260: OR
62261: IFFALSE 62265
// exit ;
62263: GO 63374
// nat := GetNation ( tower ) ;
62265: LD_ADDR_VAR 0 12
62269: PUSH
62270: LD_VAR 0 1
62274: PPUSH
62275: CALL_OW 248
62279: ST_TO_ADDR
// side := GetSide ( tower ) ;
62280: LD_ADDR_VAR 0 16
62284: PUSH
62285: LD_VAR 0 1
62289: PPUSH
62290: CALL_OW 255
62294: ST_TO_ADDR
// x := GetX ( tower ) ;
62295: LD_ADDR_VAR 0 10
62299: PUSH
62300: LD_VAR 0 1
62304: PPUSH
62305: CALL_OW 250
62309: ST_TO_ADDR
// y := GetY ( tower ) ;
62310: LD_ADDR_VAR 0 11
62314: PUSH
62315: LD_VAR 0 1
62319: PPUSH
62320: CALL_OW 251
62324: ST_TO_ADDR
// if not x or not y then
62325: LD_VAR 0 10
62329: NOT
62330: PUSH
62331: LD_VAR 0 11
62335: NOT
62336: OR
62337: IFFALSE 62341
// exit ;
62339: GO 63374
// weapon := 0 ;
62341: LD_ADDR_VAR 0 18
62345: PUSH
62346: LD_INT 0
62348: ST_TO_ADDR
// fac_list := [ ] ;
62349: LD_ADDR_VAR 0 17
62353: PUSH
62354: EMPTY
62355: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
62356: LD_ADDR_VAR 0 6
62360: PUSH
62361: LD_VAR 0 1
62365: PPUSH
62366: CALL_OW 274
62370: PPUSH
62371: LD_VAR 0 2
62375: PPUSH
62376: LD_INT 0
62378: PPUSH
62379: CALL 59945 0 3
62383: PPUSH
62384: LD_INT 30
62386: PUSH
62387: LD_INT 3
62389: PUSH
62390: EMPTY
62391: LIST
62392: LIST
62393: PPUSH
62394: CALL_OW 72
62398: ST_TO_ADDR
// if not factories then
62399: LD_VAR 0 6
62403: NOT
62404: IFFALSE 62408
// exit ;
62406: GO 63374
// for i in factories do
62408: LD_ADDR_VAR 0 8
62412: PUSH
62413: LD_VAR 0 6
62417: PUSH
62418: FOR_IN
62419: IFFALSE 62444
// fac_list := fac_list union AvailableWeaponList ( i ) ;
62421: LD_ADDR_VAR 0 17
62425: PUSH
62426: LD_VAR 0 17
62430: PUSH
62431: LD_VAR 0 8
62435: PPUSH
62436: CALL_OW 478
62440: UNION
62441: ST_TO_ADDR
62442: GO 62418
62444: POP
62445: POP
// if not fac_list then
62446: LD_VAR 0 17
62450: NOT
62451: IFFALSE 62455
// exit ;
62453: GO 63374
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
62455: LD_ADDR_VAR 0 5
62459: PUSH
62460: LD_INT 4
62462: PUSH
62463: LD_INT 5
62465: PUSH
62466: LD_INT 9
62468: PUSH
62469: LD_INT 10
62471: PUSH
62472: LD_INT 6
62474: PUSH
62475: LD_INT 7
62477: PUSH
62478: LD_INT 11
62480: PUSH
62481: EMPTY
62482: LIST
62483: LIST
62484: LIST
62485: LIST
62486: LIST
62487: LIST
62488: LIST
62489: PUSH
62490: LD_INT 27
62492: PUSH
62493: LD_INT 28
62495: PUSH
62496: LD_INT 26
62498: PUSH
62499: LD_INT 30
62501: PUSH
62502: EMPTY
62503: LIST
62504: LIST
62505: LIST
62506: LIST
62507: PUSH
62508: LD_INT 43
62510: PUSH
62511: LD_INT 44
62513: PUSH
62514: LD_INT 46
62516: PUSH
62517: LD_INT 45
62519: PUSH
62520: LD_INT 47
62522: PUSH
62523: LD_INT 49
62525: PUSH
62526: EMPTY
62527: LIST
62528: LIST
62529: LIST
62530: LIST
62531: LIST
62532: LIST
62533: PUSH
62534: EMPTY
62535: LIST
62536: LIST
62537: LIST
62538: PUSH
62539: LD_VAR 0 12
62543: ARRAY
62544: ST_TO_ADDR
// list := list isect fac_list ;
62545: LD_ADDR_VAR 0 5
62549: PUSH
62550: LD_VAR 0 5
62554: PUSH
62555: LD_VAR 0 17
62559: ISECT
62560: ST_TO_ADDR
// if not list then
62561: LD_VAR 0 5
62565: NOT
62566: IFFALSE 62570
// exit ;
62568: GO 63374
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
62570: LD_VAR 0 12
62574: PUSH
62575: LD_INT 3
62577: EQUAL
62578: PUSH
62579: LD_INT 49
62581: PUSH
62582: LD_VAR 0 5
62586: IN
62587: AND
62588: PUSH
62589: LD_INT 31
62591: PPUSH
62592: LD_VAR 0 16
62596: PPUSH
62597: CALL_OW 321
62601: PUSH
62602: LD_INT 2
62604: EQUAL
62605: AND
62606: IFFALSE 62666
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
62608: LD_INT 22
62610: PUSH
62611: LD_VAR 0 16
62615: PUSH
62616: EMPTY
62617: LIST
62618: LIST
62619: PUSH
62620: LD_INT 35
62622: PUSH
62623: LD_INT 49
62625: PUSH
62626: EMPTY
62627: LIST
62628: LIST
62629: PUSH
62630: LD_INT 91
62632: PUSH
62633: LD_VAR 0 1
62637: PUSH
62638: LD_INT 10
62640: PUSH
62641: EMPTY
62642: LIST
62643: LIST
62644: LIST
62645: PUSH
62646: EMPTY
62647: LIST
62648: LIST
62649: LIST
62650: PPUSH
62651: CALL_OW 69
62655: NOT
62656: IFFALSE 62666
// weapon := ru_time_lapser ;
62658: LD_ADDR_VAR 0 18
62662: PUSH
62663: LD_INT 49
62665: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
62666: LD_VAR 0 12
62670: PUSH
62671: LD_INT 1
62673: PUSH
62674: LD_INT 2
62676: PUSH
62677: EMPTY
62678: LIST
62679: LIST
62680: IN
62681: PUSH
62682: LD_INT 11
62684: PUSH
62685: LD_VAR 0 5
62689: IN
62690: PUSH
62691: LD_INT 30
62693: PUSH
62694: LD_VAR 0 5
62698: IN
62699: OR
62700: AND
62701: PUSH
62702: LD_INT 6
62704: PPUSH
62705: LD_VAR 0 16
62709: PPUSH
62710: CALL_OW 321
62714: PUSH
62715: LD_INT 2
62717: EQUAL
62718: AND
62719: IFFALSE 62884
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
62721: LD_INT 22
62723: PUSH
62724: LD_VAR 0 16
62728: PUSH
62729: EMPTY
62730: LIST
62731: LIST
62732: PUSH
62733: LD_INT 2
62735: PUSH
62736: LD_INT 35
62738: PUSH
62739: LD_INT 11
62741: PUSH
62742: EMPTY
62743: LIST
62744: LIST
62745: PUSH
62746: LD_INT 35
62748: PUSH
62749: LD_INT 30
62751: PUSH
62752: EMPTY
62753: LIST
62754: LIST
62755: PUSH
62756: EMPTY
62757: LIST
62758: LIST
62759: LIST
62760: PUSH
62761: LD_INT 91
62763: PUSH
62764: LD_VAR 0 1
62768: PUSH
62769: LD_INT 18
62771: PUSH
62772: EMPTY
62773: LIST
62774: LIST
62775: LIST
62776: PUSH
62777: EMPTY
62778: LIST
62779: LIST
62780: LIST
62781: PPUSH
62782: CALL_OW 69
62786: NOT
62787: PUSH
62788: LD_INT 22
62790: PUSH
62791: LD_VAR 0 16
62795: PUSH
62796: EMPTY
62797: LIST
62798: LIST
62799: PUSH
62800: LD_INT 2
62802: PUSH
62803: LD_INT 30
62805: PUSH
62806: LD_INT 32
62808: PUSH
62809: EMPTY
62810: LIST
62811: LIST
62812: PUSH
62813: LD_INT 30
62815: PUSH
62816: LD_INT 33
62818: PUSH
62819: EMPTY
62820: LIST
62821: LIST
62822: PUSH
62823: EMPTY
62824: LIST
62825: LIST
62826: LIST
62827: PUSH
62828: LD_INT 91
62830: PUSH
62831: LD_VAR 0 1
62835: PUSH
62836: LD_INT 12
62838: PUSH
62839: EMPTY
62840: LIST
62841: LIST
62842: LIST
62843: PUSH
62844: EMPTY
62845: LIST
62846: LIST
62847: LIST
62848: PUSH
62849: EMPTY
62850: LIST
62851: PPUSH
62852: CALL_OW 69
62856: PUSH
62857: LD_INT 2
62859: GREATER
62860: AND
62861: IFFALSE 62884
// weapon := [ us_radar , ar_radar ] [ nat ] ;
62863: LD_ADDR_VAR 0 18
62867: PUSH
62868: LD_INT 11
62870: PUSH
62871: LD_INT 30
62873: PUSH
62874: EMPTY
62875: LIST
62876: LIST
62877: PUSH
62878: LD_VAR 0 12
62882: ARRAY
62883: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
62884: LD_VAR 0 18
62888: NOT
62889: PUSH
62890: LD_INT 40
62892: PPUSH
62893: LD_VAR 0 16
62897: PPUSH
62898: CALL_OW 321
62902: PUSH
62903: LD_INT 2
62905: EQUAL
62906: AND
62907: PUSH
62908: LD_INT 7
62910: PUSH
62911: LD_VAR 0 5
62915: IN
62916: PUSH
62917: LD_INT 28
62919: PUSH
62920: LD_VAR 0 5
62924: IN
62925: OR
62926: PUSH
62927: LD_INT 45
62929: PUSH
62930: LD_VAR 0 5
62934: IN
62935: OR
62936: AND
62937: IFFALSE 63191
// begin hex := GetHexInfo ( x , y ) ;
62939: LD_ADDR_VAR 0 4
62943: PUSH
62944: LD_VAR 0 10
62948: PPUSH
62949: LD_VAR 0 11
62953: PPUSH
62954: CALL_OW 546
62958: ST_TO_ADDR
// if hex [ 1 ] then
62959: LD_VAR 0 4
62963: PUSH
62964: LD_INT 1
62966: ARRAY
62967: IFFALSE 62971
// exit ;
62969: GO 63374
// height := hex [ 2 ] ;
62971: LD_ADDR_VAR 0 15
62975: PUSH
62976: LD_VAR 0 4
62980: PUSH
62981: LD_INT 2
62983: ARRAY
62984: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
62985: LD_ADDR_VAR 0 14
62989: PUSH
62990: LD_INT 0
62992: PUSH
62993: LD_INT 2
62995: PUSH
62996: LD_INT 3
62998: PUSH
62999: LD_INT 5
63001: PUSH
63002: EMPTY
63003: LIST
63004: LIST
63005: LIST
63006: LIST
63007: ST_TO_ADDR
// for i in tmp do
63008: LD_ADDR_VAR 0 8
63012: PUSH
63013: LD_VAR 0 14
63017: PUSH
63018: FOR_IN
63019: IFFALSE 63189
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
63021: LD_ADDR_VAR 0 9
63025: PUSH
63026: LD_VAR 0 10
63030: PPUSH
63031: LD_VAR 0 8
63035: PPUSH
63036: LD_INT 5
63038: PPUSH
63039: CALL_OW 272
63043: PUSH
63044: LD_VAR 0 11
63048: PPUSH
63049: LD_VAR 0 8
63053: PPUSH
63054: LD_INT 5
63056: PPUSH
63057: CALL_OW 273
63061: PUSH
63062: EMPTY
63063: LIST
63064: LIST
63065: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
63066: LD_VAR 0 9
63070: PUSH
63071: LD_INT 1
63073: ARRAY
63074: PPUSH
63075: LD_VAR 0 9
63079: PUSH
63080: LD_INT 2
63082: ARRAY
63083: PPUSH
63084: CALL_OW 488
63088: IFFALSE 63187
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
63090: LD_ADDR_VAR 0 4
63094: PUSH
63095: LD_VAR 0 9
63099: PUSH
63100: LD_INT 1
63102: ARRAY
63103: PPUSH
63104: LD_VAR 0 9
63108: PUSH
63109: LD_INT 2
63111: ARRAY
63112: PPUSH
63113: CALL_OW 546
63117: ST_TO_ADDR
// if hex [ 1 ] then
63118: LD_VAR 0 4
63122: PUSH
63123: LD_INT 1
63125: ARRAY
63126: IFFALSE 63130
// continue ;
63128: GO 63018
// h := hex [ 2 ] ;
63130: LD_ADDR_VAR 0 13
63134: PUSH
63135: LD_VAR 0 4
63139: PUSH
63140: LD_INT 2
63142: ARRAY
63143: ST_TO_ADDR
// if h + 7 < height then
63144: LD_VAR 0 13
63148: PUSH
63149: LD_INT 7
63151: PLUS
63152: PUSH
63153: LD_VAR 0 15
63157: LESS
63158: IFFALSE 63187
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
63160: LD_ADDR_VAR 0 18
63164: PUSH
63165: LD_INT 7
63167: PUSH
63168: LD_INT 28
63170: PUSH
63171: LD_INT 45
63173: PUSH
63174: EMPTY
63175: LIST
63176: LIST
63177: LIST
63178: PUSH
63179: LD_VAR 0 12
63183: ARRAY
63184: ST_TO_ADDR
// break ;
63185: GO 63189
// end ; end ; end ;
63187: GO 63018
63189: POP
63190: POP
// end ; if not weapon then
63191: LD_VAR 0 18
63195: NOT
63196: IFFALSE 63256
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
63198: LD_ADDR_VAR 0 5
63202: PUSH
63203: LD_VAR 0 5
63207: PUSH
63208: LD_INT 11
63210: PUSH
63211: LD_INT 30
63213: PUSH
63214: LD_INT 49
63216: PUSH
63217: EMPTY
63218: LIST
63219: LIST
63220: LIST
63221: DIFF
63222: ST_TO_ADDR
// if not list then
63223: LD_VAR 0 5
63227: NOT
63228: IFFALSE 63232
// exit ;
63230: GO 63374
// weapon := list [ rand ( 1 , list ) ] ;
63232: LD_ADDR_VAR 0 18
63236: PUSH
63237: LD_VAR 0 5
63241: PUSH
63242: LD_INT 1
63244: PPUSH
63245: LD_VAR 0 5
63249: PPUSH
63250: CALL_OW 12
63254: ARRAY
63255: ST_TO_ADDR
// end ; if weapon then
63256: LD_VAR 0 18
63260: IFFALSE 63374
// begin tmp := CostOfWeapon ( weapon ) ;
63262: LD_ADDR_VAR 0 14
63266: PUSH
63267: LD_VAR 0 18
63271: PPUSH
63272: CALL_OW 451
63276: ST_TO_ADDR
// j := GetBase ( tower ) ;
63277: LD_ADDR_VAR 0 9
63281: PUSH
63282: LD_VAR 0 1
63286: PPUSH
63287: CALL_OW 274
63291: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
63292: LD_VAR 0 9
63296: PPUSH
63297: LD_INT 1
63299: PPUSH
63300: CALL_OW 275
63304: PUSH
63305: LD_VAR 0 14
63309: PUSH
63310: LD_INT 1
63312: ARRAY
63313: GREATEREQUAL
63314: PUSH
63315: LD_VAR 0 9
63319: PPUSH
63320: LD_INT 2
63322: PPUSH
63323: CALL_OW 275
63327: PUSH
63328: LD_VAR 0 14
63332: PUSH
63333: LD_INT 2
63335: ARRAY
63336: GREATEREQUAL
63337: AND
63338: PUSH
63339: LD_VAR 0 9
63343: PPUSH
63344: LD_INT 3
63346: PPUSH
63347: CALL_OW 275
63351: PUSH
63352: LD_VAR 0 14
63356: PUSH
63357: LD_INT 3
63359: ARRAY
63360: GREATEREQUAL
63361: AND
63362: IFFALSE 63374
// result := weapon ;
63364: LD_ADDR_VAR 0 3
63368: PUSH
63369: LD_VAR 0 18
63373: ST_TO_ADDR
// end ; end ;
63374: LD_VAR 0 3
63378: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
63379: LD_INT 0
63381: PPUSH
63382: PPUSH
// result := true ;
63383: LD_ADDR_VAR 0 3
63387: PUSH
63388: LD_INT 1
63390: ST_TO_ADDR
// if array1 = array2 then
63391: LD_VAR 0 1
63395: PUSH
63396: LD_VAR 0 2
63400: EQUAL
63401: IFFALSE 63461
// begin for i = 1 to array1 do
63403: LD_ADDR_VAR 0 4
63407: PUSH
63408: DOUBLE
63409: LD_INT 1
63411: DEC
63412: ST_TO_ADDR
63413: LD_VAR 0 1
63417: PUSH
63418: FOR_TO
63419: IFFALSE 63457
// if array1 [ i ] <> array2 [ i ] then
63421: LD_VAR 0 1
63425: PUSH
63426: LD_VAR 0 4
63430: ARRAY
63431: PUSH
63432: LD_VAR 0 2
63436: PUSH
63437: LD_VAR 0 4
63441: ARRAY
63442: NONEQUAL
63443: IFFALSE 63455
// begin result := false ;
63445: LD_ADDR_VAR 0 3
63449: PUSH
63450: LD_INT 0
63452: ST_TO_ADDR
// break ;
63453: GO 63457
// end ;
63455: GO 63418
63457: POP
63458: POP
// end else
63459: GO 63469
// result := false ;
63461: LD_ADDR_VAR 0 3
63465: PUSH
63466: LD_INT 0
63468: ST_TO_ADDR
// end ;
63469: LD_VAR 0 3
63473: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
63474: LD_INT 0
63476: PPUSH
63477: PPUSH
// if not array1 or not array2 then
63478: LD_VAR 0 1
63482: NOT
63483: PUSH
63484: LD_VAR 0 2
63488: NOT
63489: OR
63490: IFFALSE 63494
// exit ;
63492: GO 63558
// result := true ;
63494: LD_ADDR_VAR 0 3
63498: PUSH
63499: LD_INT 1
63501: ST_TO_ADDR
// for i = 1 to array1 do
63502: LD_ADDR_VAR 0 4
63506: PUSH
63507: DOUBLE
63508: LD_INT 1
63510: DEC
63511: ST_TO_ADDR
63512: LD_VAR 0 1
63516: PUSH
63517: FOR_TO
63518: IFFALSE 63556
// if array1 [ i ] <> array2 [ i ] then
63520: LD_VAR 0 1
63524: PUSH
63525: LD_VAR 0 4
63529: ARRAY
63530: PUSH
63531: LD_VAR 0 2
63535: PUSH
63536: LD_VAR 0 4
63540: ARRAY
63541: NONEQUAL
63542: IFFALSE 63554
// begin result := false ;
63544: LD_ADDR_VAR 0 3
63548: PUSH
63549: LD_INT 0
63551: ST_TO_ADDR
// break ;
63552: GO 63556
// end ;
63554: GO 63517
63556: POP
63557: POP
// end ;
63558: LD_VAR 0 3
63562: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
63563: LD_INT 0
63565: PPUSH
63566: PPUSH
63567: PPUSH
// pom := GetBase ( fac ) ;
63568: LD_ADDR_VAR 0 5
63572: PUSH
63573: LD_VAR 0 1
63577: PPUSH
63578: CALL_OW 274
63582: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
63583: LD_ADDR_VAR 0 4
63587: PUSH
63588: LD_VAR 0 2
63592: PUSH
63593: LD_INT 1
63595: ARRAY
63596: PPUSH
63597: LD_VAR 0 2
63601: PUSH
63602: LD_INT 2
63604: ARRAY
63605: PPUSH
63606: LD_VAR 0 2
63610: PUSH
63611: LD_INT 3
63613: ARRAY
63614: PPUSH
63615: LD_VAR 0 2
63619: PUSH
63620: LD_INT 4
63622: ARRAY
63623: PPUSH
63624: CALL_OW 449
63628: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63629: LD_ADDR_VAR 0 3
63633: PUSH
63634: LD_VAR 0 5
63638: PPUSH
63639: LD_INT 1
63641: PPUSH
63642: CALL_OW 275
63646: PUSH
63647: LD_VAR 0 4
63651: PUSH
63652: LD_INT 1
63654: ARRAY
63655: GREATEREQUAL
63656: PUSH
63657: LD_VAR 0 5
63661: PPUSH
63662: LD_INT 2
63664: PPUSH
63665: CALL_OW 275
63669: PUSH
63670: LD_VAR 0 4
63674: PUSH
63675: LD_INT 2
63677: ARRAY
63678: GREATEREQUAL
63679: AND
63680: PUSH
63681: LD_VAR 0 5
63685: PPUSH
63686: LD_INT 3
63688: PPUSH
63689: CALL_OW 275
63693: PUSH
63694: LD_VAR 0 4
63698: PUSH
63699: LD_INT 3
63701: ARRAY
63702: GREATEREQUAL
63703: AND
63704: ST_TO_ADDR
// end ;
63705: LD_VAR 0 3
63709: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
63710: LD_INT 0
63712: PPUSH
63713: PPUSH
63714: PPUSH
63715: PPUSH
// pom := GetBase ( building ) ;
63716: LD_ADDR_VAR 0 3
63720: PUSH
63721: LD_VAR 0 1
63725: PPUSH
63726: CALL_OW 274
63730: ST_TO_ADDR
// if not pom then
63731: LD_VAR 0 3
63735: NOT
63736: IFFALSE 63740
// exit ;
63738: GO 63910
// btype := GetBType ( building ) ;
63740: LD_ADDR_VAR 0 5
63744: PUSH
63745: LD_VAR 0 1
63749: PPUSH
63750: CALL_OW 266
63754: ST_TO_ADDR
// if btype = b_armoury then
63755: LD_VAR 0 5
63759: PUSH
63760: LD_INT 4
63762: EQUAL
63763: IFFALSE 63773
// btype := b_barracks ;
63765: LD_ADDR_VAR 0 5
63769: PUSH
63770: LD_INT 5
63772: ST_TO_ADDR
// if btype = b_depot then
63773: LD_VAR 0 5
63777: PUSH
63778: LD_INT 0
63780: EQUAL
63781: IFFALSE 63791
// btype := b_warehouse ;
63783: LD_ADDR_VAR 0 5
63787: PUSH
63788: LD_INT 1
63790: ST_TO_ADDR
// if btype = b_workshop then
63791: LD_VAR 0 5
63795: PUSH
63796: LD_INT 2
63798: EQUAL
63799: IFFALSE 63809
// btype := b_factory ;
63801: LD_ADDR_VAR 0 5
63805: PUSH
63806: LD_INT 3
63808: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
63809: LD_ADDR_VAR 0 4
63813: PUSH
63814: LD_VAR 0 5
63818: PPUSH
63819: LD_VAR 0 1
63823: PPUSH
63824: CALL_OW 248
63828: PPUSH
63829: CALL_OW 450
63833: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63834: LD_ADDR_VAR 0 2
63838: PUSH
63839: LD_VAR 0 3
63843: PPUSH
63844: LD_INT 1
63846: PPUSH
63847: CALL_OW 275
63851: PUSH
63852: LD_VAR 0 4
63856: PUSH
63857: LD_INT 1
63859: ARRAY
63860: GREATEREQUAL
63861: PUSH
63862: LD_VAR 0 3
63866: PPUSH
63867: LD_INT 2
63869: PPUSH
63870: CALL_OW 275
63874: PUSH
63875: LD_VAR 0 4
63879: PUSH
63880: LD_INT 2
63882: ARRAY
63883: GREATEREQUAL
63884: AND
63885: PUSH
63886: LD_VAR 0 3
63890: PPUSH
63891: LD_INT 3
63893: PPUSH
63894: CALL_OW 275
63898: PUSH
63899: LD_VAR 0 4
63903: PUSH
63904: LD_INT 3
63906: ARRAY
63907: GREATEREQUAL
63908: AND
63909: ST_TO_ADDR
// end ;
63910: LD_VAR 0 2
63914: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
63915: LD_INT 0
63917: PPUSH
63918: PPUSH
63919: PPUSH
// pom := GetBase ( building ) ;
63920: LD_ADDR_VAR 0 4
63924: PUSH
63925: LD_VAR 0 1
63929: PPUSH
63930: CALL_OW 274
63934: ST_TO_ADDR
// if not pom then
63935: LD_VAR 0 4
63939: NOT
63940: IFFALSE 63944
// exit ;
63942: GO 64045
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
63944: LD_ADDR_VAR 0 5
63948: PUSH
63949: LD_VAR 0 2
63953: PPUSH
63954: LD_VAR 0 1
63958: PPUSH
63959: CALL_OW 248
63963: PPUSH
63964: CALL_OW 450
63968: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63969: LD_ADDR_VAR 0 3
63973: PUSH
63974: LD_VAR 0 4
63978: PPUSH
63979: LD_INT 1
63981: PPUSH
63982: CALL_OW 275
63986: PUSH
63987: LD_VAR 0 5
63991: PUSH
63992: LD_INT 1
63994: ARRAY
63995: GREATEREQUAL
63996: PUSH
63997: LD_VAR 0 4
64001: PPUSH
64002: LD_INT 2
64004: PPUSH
64005: CALL_OW 275
64009: PUSH
64010: LD_VAR 0 5
64014: PUSH
64015: LD_INT 2
64017: ARRAY
64018: GREATEREQUAL
64019: AND
64020: PUSH
64021: LD_VAR 0 4
64025: PPUSH
64026: LD_INT 3
64028: PPUSH
64029: CALL_OW 275
64033: PUSH
64034: LD_VAR 0 5
64038: PUSH
64039: LD_INT 3
64041: ARRAY
64042: GREATEREQUAL
64043: AND
64044: ST_TO_ADDR
// end ;
64045: LD_VAR 0 3
64049: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
64050: LD_INT 0
64052: PPUSH
64053: PPUSH
64054: PPUSH
64055: PPUSH
64056: PPUSH
64057: PPUSH
64058: PPUSH
64059: PPUSH
64060: PPUSH
64061: PPUSH
64062: PPUSH
// result := false ;
64063: LD_ADDR_VAR 0 8
64067: PUSH
64068: LD_INT 0
64070: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
64071: LD_VAR 0 5
64075: NOT
64076: PUSH
64077: LD_VAR 0 1
64081: NOT
64082: OR
64083: PUSH
64084: LD_VAR 0 2
64088: NOT
64089: OR
64090: PUSH
64091: LD_VAR 0 3
64095: NOT
64096: OR
64097: IFFALSE 64101
// exit ;
64099: GO 64915
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
64101: LD_ADDR_VAR 0 14
64105: PUSH
64106: LD_VAR 0 1
64110: PPUSH
64111: LD_VAR 0 2
64115: PPUSH
64116: LD_VAR 0 3
64120: PPUSH
64121: LD_VAR 0 4
64125: PPUSH
64126: LD_VAR 0 5
64130: PUSH
64131: LD_INT 1
64133: ARRAY
64134: PPUSH
64135: CALL_OW 248
64139: PPUSH
64140: LD_INT 0
64142: PPUSH
64143: CALL 66148 0 6
64147: ST_TO_ADDR
// if not hexes then
64148: LD_VAR 0 14
64152: NOT
64153: IFFALSE 64157
// exit ;
64155: GO 64915
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
64157: LD_ADDR_VAR 0 17
64161: PUSH
64162: LD_VAR 0 5
64166: PPUSH
64167: LD_INT 22
64169: PUSH
64170: LD_VAR 0 13
64174: PPUSH
64175: CALL_OW 255
64179: PUSH
64180: EMPTY
64181: LIST
64182: LIST
64183: PUSH
64184: LD_INT 2
64186: PUSH
64187: LD_INT 30
64189: PUSH
64190: LD_INT 0
64192: PUSH
64193: EMPTY
64194: LIST
64195: LIST
64196: PUSH
64197: LD_INT 30
64199: PUSH
64200: LD_INT 1
64202: PUSH
64203: EMPTY
64204: LIST
64205: LIST
64206: PUSH
64207: EMPTY
64208: LIST
64209: LIST
64210: LIST
64211: PUSH
64212: EMPTY
64213: LIST
64214: LIST
64215: PPUSH
64216: CALL_OW 72
64220: ST_TO_ADDR
// for i = 1 to hexes do
64221: LD_ADDR_VAR 0 9
64225: PUSH
64226: DOUBLE
64227: LD_INT 1
64229: DEC
64230: ST_TO_ADDR
64231: LD_VAR 0 14
64235: PUSH
64236: FOR_TO
64237: IFFALSE 64913
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
64239: LD_ADDR_VAR 0 13
64243: PUSH
64244: LD_VAR 0 14
64248: PUSH
64249: LD_VAR 0 9
64253: ARRAY
64254: PUSH
64255: LD_INT 1
64257: ARRAY
64258: PPUSH
64259: LD_VAR 0 14
64263: PUSH
64264: LD_VAR 0 9
64268: ARRAY
64269: PUSH
64270: LD_INT 2
64272: ARRAY
64273: PPUSH
64274: CALL_OW 428
64278: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
64279: LD_VAR 0 14
64283: PUSH
64284: LD_VAR 0 9
64288: ARRAY
64289: PUSH
64290: LD_INT 1
64292: ARRAY
64293: PPUSH
64294: LD_VAR 0 14
64298: PUSH
64299: LD_VAR 0 9
64303: ARRAY
64304: PUSH
64305: LD_INT 2
64307: ARRAY
64308: PPUSH
64309: CALL_OW 351
64313: PUSH
64314: LD_VAR 0 14
64318: PUSH
64319: LD_VAR 0 9
64323: ARRAY
64324: PUSH
64325: LD_INT 1
64327: ARRAY
64328: PPUSH
64329: LD_VAR 0 14
64333: PUSH
64334: LD_VAR 0 9
64338: ARRAY
64339: PUSH
64340: LD_INT 2
64342: ARRAY
64343: PPUSH
64344: CALL_OW 488
64348: NOT
64349: OR
64350: PUSH
64351: LD_VAR 0 13
64355: PPUSH
64356: CALL_OW 247
64360: PUSH
64361: LD_INT 3
64363: EQUAL
64364: OR
64365: IFFALSE 64371
// exit ;
64367: POP
64368: POP
64369: GO 64915
// if not tmp then
64371: LD_VAR 0 13
64375: NOT
64376: IFFALSE 64380
// continue ;
64378: GO 64236
// result := true ;
64380: LD_ADDR_VAR 0 8
64384: PUSH
64385: LD_INT 1
64387: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
64388: LD_VAR 0 6
64392: PUSH
64393: LD_VAR 0 13
64397: PPUSH
64398: CALL_OW 247
64402: PUSH
64403: LD_INT 2
64405: EQUAL
64406: AND
64407: PUSH
64408: LD_VAR 0 13
64412: PPUSH
64413: CALL_OW 263
64417: PUSH
64418: LD_INT 1
64420: EQUAL
64421: AND
64422: IFFALSE 64586
// begin if IsDrivenBy ( tmp ) then
64424: LD_VAR 0 13
64428: PPUSH
64429: CALL_OW 311
64433: IFFALSE 64437
// continue ;
64435: GO 64236
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
64437: LD_VAR 0 6
64441: PPUSH
64442: LD_INT 3
64444: PUSH
64445: LD_INT 60
64447: PUSH
64448: EMPTY
64449: LIST
64450: PUSH
64451: EMPTY
64452: LIST
64453: LIST
64454: PUSH
64455: LD_INT 3
64457: PUSH
64458: LD_INT 55
64460: PUSH
64461: EMPTY
64462: LIST
64463: PUSH
64464: EMPTY
64465: LIST
64466: LIST
64467: PUSH
64468: EMPTY
64469: LIST
64470: LIST
64471: PPUSH
64472: CALL_OW 72
64476: IFFALSE 64584
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
64478: LD_ADDR_VAR 0 18
64482: PUSH
64483: LD_VAR 0 6
64487: PPUSH
64488: LD_INT 3
64490: PUSH
64491: LD_INT 60
64493: PUSH
64494: EMPTY
64495: LIST
64496: PUSH
64497: EMPTY
64498: LIST
64499: LIST
64500: PUSH
64501: LD_INT 3
64503: PUSH
64504: LD_INT 55
64506: PUSH
64507: EMPTY
64508: LIST
64509: PUSH
64510: EMPTY
64511: LIST
64512: LIST
64513: PUSH
64514: EMPTY
64515: LIST
64516: LIST
64517: PPUSH
64518: CALL_OW 72
64522: PUSH
64523: LD_INT 1
64525: ARRAY
64526: ST_TO_ADDR
// if IsInUnit ( driver ) then
64527: LD_VAR 0 18
64531: PPUSH
64532: CALL_OW 310
64536: IFFALSE 64547
// ComExit ( driver ) ;
64538: LD_VAR 0 18
64542: PPUSH
64543: CALL 89928 0 1
// AddComEnterUnit ( driver , tmp ) ;
64547: LD_VAR 0 18
64551: PPUSH
64552: LD_VAR 0 13
64556: PPUSH
64557: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
64561: LD_VAR 0 18
64565: PPUSH
64566: LD_VAR 0 7
64570: PPUSH
64571: CALL_OW 173
// AddComExitVehicle ( driver ) ;
64575: LD_VAR 0 18
64579: PPUSH
64580: CALL_OW 181
// end ; continue ;
64584: GO 64236
// end ; if not cleaners or not tmp in cleaners then
64586: LD_VAR 0 6
64590: NOT
64591: PUSH
64592: LD_VAR 0 13
64596: PUSH
64597: LD_VAR 0 6
64601: IN
64602: NOT
64603: OR
64604: IFFALSE 64911
// begin if dep then
64606: LD_VAR 0 17
64610: IFFALSE 64746
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
64612: LD_ADDR_VAR 0 16
64616: PUSH
64617: LD_VAR 0 17
64621: PUSH
64622: LD_INT 1
64624: ARRAY
64625: PPUSH
64626: CALL_OW 250
64630: PPUSH
64631: LD_VAR 0 17
64635: PUSH
64636: LD_INT 1
64638: ARRAY
64639: PPUSH
64640: CALL_OW 254
64644: PPUSH
64645: LD_INT 5
64647: PPUSH
64648: CALL_OW 272
64652: PUSH
64653: LD_VAR 0 17
64657: PUSH
64658: LD_INT 1
64660: ARRAY
64661: PPUSH
64662: CALL_OW 251
64666: PPUSH
64667: LD_VAR 0 17
64671: PUSH
64672: LD_INT 1
64674: ARRAY
64675: PPUSH
64676: CALL_OW 254
64680: PPUSH
64681: LD_INT 5
64683: PPUSH
64684: CALL_OW 273
64688: PUSH
64689: EMPTY
64690: LIST
64691: LIST
64692: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
64693: LD_VAR 0 16
64697: PUSH
64698: LD_INT 1
64700: ARRAY
64701: PPUSH
64702: LD_VAR 0 16
64706: PUSH
64707: LD_INT 2
64709: ARRAY
64710: PPUSH
64711: CALL_OW 488
64715: IFFALSE 64746
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
64717: LD_VAR 0 13
64721: PPUSH
64722: LD_VAR 0 16
64726: PUSH
64727: LD_INT 1
64729: ARRAY
64730: PPUSH
64731: LD_VAR 0 16
64735: PUSH
64736: LD_INT 2
64738: ARRAY
64739: PPUSH
64740: CALL_OW 111
// continue ;
64744: GO 64236
// end ; end ; r := GetDir ( tmp ) ;
64746: LD_ADDR_VAR 0 15
64750: PUSH
64751: LD_VAR 0 13
64755: PPUSH
64756: CALL_OW 254
64760: ST_TO_ADDR
// if r = 5 then
64761: LD_VAR 0 15
64765: PUSH
64766: LD_INT 5
64768: EQUAL
64769: IFFALSE 64779
// r := 0 ;
64771: LD_ADDR_VAR 0 15
64775: PUSH
64776: LD_INT 0
64778: ST_TO_ADDR
// for j = r to 5 do
64779: LD_ADDR_VAR 0 10
64783: PUSH
64784: DOUBLE
64785: LD_VAR 0 15
64789: DEC
64790: ST_TO_ADDR
64791: LD_INT 5
64793: PUSH
64794: FOR_TO
64795: IFFALSE 64909
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
64797: LD_ADDR_VAR 0 11
64801: PUSH
64802: LD_VAR 0 13
64806: PPUSH
64807: CALL_OW 250
64811: PPUSH
64812: LD_VAR 0 10
64816: PPUSH
64817: LD_INT 2
64819: PPUSH
64820: CALL_OW 272
64824: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
64825: LD_ADDR_VAR 0 12
64829: PUSH
64830: LD_VAR 0 13
64834: PPUSH
64835: CALL_OW 251
64839: PPUSH
64840: LD_VAR 0 10
64844: PPUSH
64845: LD_INT 2
64847: PPUSH
64848: CALL_OW 273
64852: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
64853: LD_VAR 0 11
64857: PPUSH
64858: LD_VAR 0 12
64862: PPUSH
64863: CALL_OW 488
64867: PUSH
64868: LD_VAR 0 11
64872: PPUSH
64873: LD_VAR 0 12
64877: PPUSH
64878: CALL_OW 428
64882: NOT
64883: AND
64884: IFFALSE 64907
// begin ComMoveXY ( tmp , _x , _y ) ;
64886: LD_VAR 0 13
64890: PPUSH
64891: LD_VAR 0 11
64895: PPUSH
64896: LD_VAR 0 12
64900: PPUSH
64901: CALL_OW 111
// break ;
64905: GO 64909
// end ; end ;
64907: GO 64794
64909: POP
64910: POP
// end ; end ;
64911: GO 64236
64913: POP
64914: POP
// end ;
64915: LD_VAR 0 8
64919: RET
// export function BuildingTechInvented ( side , btype ) ; begin
64920: LD_INT 0
64922: PPUSH
// result := true ;
64923: LD_ADDR_VAR 0 3
64927: PUSH
64928: LD_INT 1
64930: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
64931: LD_VAR 0 2
64935: PUSH
64936: LD_INT 24
64938: DOUBLE
64939: EQUAL
64940: IFTRUE 64950
64942: LD_INT 33
64944: DOUBLE
64945: EQUAL
64946: IFTRUE 64950
64948: GO 64975
64950: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
64951: LD_ADDR_VAR 0 3
64955: PUSH
64956: LD_INT 32
64958: PPUSH
64959: LD_VAR 0 1
64963: PPUSH
64964: CALL_OW 321
64968: PUSH
64969: LD_INT 2
64971: EQUAL
64972: ST_TO_ADDR
64973: GO 65291
64975: LD_INT 20
64977: DOUBLE
64978: EQUAL
64979: IFTRUE 64983
64981: GO 65008
64983: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
64984: LD_ADDR_VAR 0 3
64988: PUSH
64989: LD_INT 6
64991: PPUSH
64992: LD_VAR 0 1
64996: PPUSH
64997: CALL_OW 321
65001: PUSH
65002: LD_INT 2
65004: EQUAL
65005: ST_TO_ADDR
65006: GO 65291
65008: LD_INT 22
65010: DOUBLE
65011: EQUAL
65012: IFTRUE 65022
65014: LD_INT 36
65016: DOUBLE
65017: EQUAL
65018: IFTRUE 65022
65020: GO 65047
65022: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
65023: LD_ADDR_VAR 0 3
65027: PUSH
65028: LD_INT 15
65030: PPUSH
65031: LD_VAR 0 1
65035: PPUSH
65036: CALL_OW 321
65040: PUSH
65041: LD_INT 2
65043: EQUAL
65044: ST_TO_ADDR
65045: GO 65291
65047: LD_INT 30
65049: DOUBLE
65050: EQUAL
65051: IFTRUE 65055
65053: GO 65080
65055: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
65056: LD_ADDR_VAR 0 3
65060: PUSH
65061: LD_INT 20
65063: PPUSH
65064: LD_VAR 0 1
65068: PPUSH
65069: CALL_OW 321
65073: PUSH
65074: LD_INT 2
65076: EQUAL
65077: ST_TO_ADDR
65078: GO 65291
65080: LD_INT 28
65082: DOUBLE
65083: EQUAL
65084: IFTRUE 65094
65086: LD_INT 21
65088: DOUBLE
65089: EQUAL
65090: IFTRUE 65094
65092: GO 65119
65094: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
65095: LD_ADDR_VAR 0 3
65099: PUSH
65100: LD_INT 21
65102: PPUSH
65103: LD_VAR 0 1
65107: PPUSH
65108: CALL_OW 321
65112: PUSH
65113: LD_INT 2
65115: EQUAL
65116: ST_TO_ADDR
65117: GO 65291
65119: LD_INT 16
65121: DOUBLE
65122: EQUAL
65123: IFTRUE 65127
65125: GO 65152
65127: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
65128: LD_ADDR_VAR 0 3
65132: PUSH
65133: LD_INT 84
65135: PPUSH
65136: LD_VAR 0 1
65140: PPUSH
65141: CALL_OW 321
65145: PUSH
65146: LD_INT 2
65148: EQUAL
65149: ST_TO_ADDR
65150: GO 65291
65152: LD_INT 19
65154: DOUBLE
65155: EQUAL
65156: IFTRUE 65166
65158: LD_INT 23
65160: DOUBLE
65161: EQUAL
65162: IFTRUE 65166
65164: GO 65191
65166: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
65167: LD_ADDR_VAR 0 3
65171: PUSH
65172: LD_INT 83
65174: PPUSH
65175: LD_VAR 0 1
65179: PPUSH
65180: CALL_OW 321
65184: PUSH
65185: LD_INT 2
65187: EQUAL
65188: ST_TO_ADDR
65189: GO 65291
65191: LD_INT 17
65193: DOUBLE
65194: EQUAL
65195: IFTRUE 65199
65197: GO 65224
65199: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
65200: LD_ADDR_VAR 0 3
65204: PUSH
65205: LD_INT 39
65207: PPUSH
65208: LD_VAR 0 1
65212: PPUSH
65213: CALL_OW 321
65217: PUSH
65218: LD_INT 2
65220: EQUAL
65221: ST_TO_ADDR
65222: GO 65291
65224: LD_INT 18
65226: DOUBLE
65227: EQUAL
65228: IFTRUE 65232
65230: GO 65257
65232: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
65233: LD_ADDR_VAR 0 3
65237: PUSH
65238: LD_INT 40
65240: PPUSH
65241: LD_VAR 0 1
65245: PPUSH
65246: CALL_OW 321
65250: PUSH
65251: LD_INT 2
65253: EQUAL
65254: ST_TO_ADDR
65255: GO 65291
65257: LD_INT 27
65259: DOUBLE
65260: EQUAL
65261: IFTRUE 65265
65263: GO 65290
65265: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
65266: LD_ADDR_VAR 0 3
65270: PUSH
65271: LD_INT 35
65273: PPUSH
65274: LD_VAR 0 1
65278: PPUSH
65279: CALL_OW 321
65283: PUSH
65284: LD_INT 2
65286: EQUAL
65287: ST_TO_ADDR
65288: GO 65291
65290: POP
// end ;
65291: LD_VAR 0 3
65295: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
65296: LD_INT 0
65298: PPUSH
65299: PPUSH
65300: PPUSH
65301: PPUSH
65302: PPUSH
65303: PPUSH
65304: PPUSH
65305: PPUSH
65306: PPUSH
65307: PPUSH
65308: PPUSH
// result := false ;
65309: LD_ADDR_VAR 0 6
65313: PUSH
65314: LD_INT 0
65316: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
65317: LD_VAR 0 1
65321: NOT
65322: PUSH
65323: LD_VAR 0 1
65327: PPUSH
65328: CALL_OW 266
65332: PUSH
65333: LD_INT 0
65335: PUSH
65336: LD_INT 1
65338: PUSH
65339: EMPTY
65340: LIST
65341: LIST
65342: IN
65343: NOT
65344: OR
65345: PUSH
65346: LD_VAR 0 2
65350: NOT
65351: OR
65352: PUSH
65353: LD_VAR 0 5
65357: PUSH
65358: LD_INT 0
65360: PUSH
65361: LD_INT 1
65363: PUSH
65364: LD_INT 2
65366: PUSH
65367: LD_INT 3
65369: PUSH
65370: LD_INT 4
65372: PUSH
65373: LD_INT 5
65375: PUSH
65376: EMPTY
65377: LIST
65378: LIST
65379: LIST
65380: LIST
65381: LIST
65382: LIST
65383: IN
65384: NOT
65385: OR
65386: PUSH
65387: LD_VAR 0 3
65391: PPUSH
65392: LD_VAR 0 4
65396: PPUSH
65397: CALL_OW 488
65401: NOT
65402: OR
65403: IFFALSE 65407
// exit ;
65405: GO 66143
// side := GetSide ( depot ) ;
65407: LD_ADDR_VAR 0 9
65411: PUSH
65412: LD_VAR 0 1
65416: PPUSH
65417: CALL_OW 255
65421: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
65422: LD_VAR 0 9
65426: PPUSH
65427: LD_VAR 0 2
65431: PPUSH
65432: CALL 64920 0 2
65436: NOT
65437: IFFALSE 65441
// exit ;
65439: GO 66143
// pom := GetBase ( depot ) ;
65441: LD_ADDR_VAR 0 10
65445: PUSH
65446: LD_VAR 0 1
65450: PPUSH
65451: CALL_OW 274
65455: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
65456: LD_ADDR_VAR 0 11
65460: PUSH
65461: LD_VAR 0 2
65465: PPUSH
65466: LD_VAR 0 1
65470: PPUSH
65471: CALL_OW 248
65475: PPUSH
65476: CALL_OW 450
65480: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
65481: LD_VAR 0 10
65485: PPUSH
65486: LD_INT 1
65488: PPUSH
65489: CALL_OW 275
65493: PUSH
65494: LD_VAR 0 11
65498: PUSH
65499: LD_INT 1
65501: ARRAY
65502: GREATEREQUAL
65503: PUSH
65504: LD_VAR 0 10
65508: PPUSH
65509: LD_INT 2
65511: PPUSH
65512: CALL_OW 275
65516: PUSH
65517: LD_VAR 0 11
65521: PUSH
65522: LD_INT 2
65524: ARRAY
65525: GREATEREQUAL
65526: AND
65527: PUSH
65528: LD_VAR 0 10
65532: PPUSH
65533: LD_INT 3
65535: PPUSH
65536: CALL_OW 275
65540: PUSH
65541: LD_VAR 0 11
65545: PUSH
65546: LD_INT 3
65548: ARRAY
65549: GREATEREQUAL
65550: AND
65551: NOT
65552: IFFALSE 65556
// exit ;
65554: GO 66143
// if GetBType ( depot ) = b_depot then
65556: LD_VAR 0 1
65560: PPUSH
65561: CALL_OW 266
65565: PUSH
65566: LD_INT 0
65568: EQUAL
65569: IFFALSE 65581
// dist := 28 else
65571: LD_ADDR_VAR 0 14
65575: PUSH
65576: LD_INT 28
65578: ST_TO_ADDR
65579: GO 65589
// dist := 36 ;
65581: LD_ADDR_VAR 0 14
65585: PUSH
65586: LD_INT 36
65588: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
65589: LD_VAR 0 1
65593: PPUSH
65594: LD_VAR 0 3
65598: PPUSH
65599: LD_VAR 0 4
65603: PPUSH
65604: CALL_OW 297
65608: PUSH
65609: LD_VAR 0 14
65613: GREATER
65614: IFFALSE 65618
// exit ;
65616: GO 66143
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
65618: LD_ADDR_VAR 0 12
65622: PUSH
65623: LD_VAR 0 2
65627: PPUSH
65628: LD_VAR 0 3
65632: PPUSH
65633: LD_VAR 0 4
65637: PPUSH
65638: LD_VAR 0 5
65642: PPUSH
65643: LD_VAR 0 1
65647: PPUSH
65648: CALL_OW 248
65652: PPUSH
65653: LD_INT 0
65655: PPUSH
65656: CALL 66148 0 6
65660: ST_TO_ADDR
// if not hexes then
65661: LD_VAR 0 12
65665: NOT
65666: IFFALSE 65670
// exit ;
65668: GO 66143
// hex := GetHexInfo ( x , y ) ;
65670: LD_ADDR_VAR 0 15
65674: PUSH
65675: LD_VAR 0 3
65679: PPUSH
65680: LD_VAR 0 4
65684: PPUSH
65685: CALL_OW 546
65689: ST_TO_ADDR
// if hex [ 1 ] then
65690: LD_VAR 0 15
65694: PUSH
65695: LD_INT 1
65697: ARRAY
65698: IFFALSE 65702
// exit ;
65700: GO 66143
// height := hex [ 2 ] ;
65702: LD_ADDR_VAR 0 13
65706: PUSH
65707: LD_VAR 0 15
65711: PUSH
65712: LD_INT 2
65714: ARRAY
65715: ST_TO_ADDR
// for i = 1 to hexes do
65716: LD_ADDR_VAR 0 7
65720: PUSH
65721: DOUBLE
65722: LD_INT 1
65724: DEC
65725: ST_TO_ADDR
65726: LD_VAR 0 12
65730: PUSH
65731: FOR_TO
65732: IFFALSE 66062
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
65734: LD_VAR 0 12
65738: PUSH
65739: LD_VAR 0 7
65743: ARRAY
65744: PUSH
65745: LD_INT 1
65747: ARRAY
65748: PPUSH
65749: LD_VAR 0 12
65753: PUSH
65754: LD_VAR 0 7
65758: ARRAY
65759: PUSH
65760: LD_INT 2
65762: ARRAY
65763: PPUSH
65764: CALL_OW 488
65768: NOT
65769: PUSH
65770: LD_VAR 0 12
65774: PUSH
65775: LD_VAR 0 7
65779: ARRAY
65780: PUSH
65781: LD_INT 1
65783: ARRAY
65784: PPUSH
65785: LD_VAR 0 12
65789: PUSH
65790: LD_VAR 0 7
65794: ARRAY
65795: PUSH
65796: LD_INT 2
65798: ARRAY
65799: PPUSH
65800: CALL_OW 428
65804: PUSH
65805: LD_INT 0
65807: GREATER
65808: OR
65809: PUSH
65810: LD_VAR 0 12
65814: PUSH
65815: LD_VAR 0 7
65819: ARRAY
65820: PUSH
65821: LD_INT 1
65823: ARRAY
65824: PPUSH
65825: LD_VAR 0 12
65829: PUSH
65830: LD_VAR 0 7
65834: ARRAY
65835: PUSH
65836: LD_INT 2
65838: ARRAY
65839: PPUSH
65840: CALL_OW 351
65844: OR
65845: IFFALSE 65851
// exit ;
65847: POP
65848: POP
65849: GO 66143
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
65851: LD_ADDR_VAR 0 8
65855: PUSH
65856: LD_VAR 0 12
65860: PUSH
65861: LD_VAR 0 7
65865: ARRAY
65866: PUSH
65867: LD_INT 1
65869: ARRAY
65870: PPUSH
65871: LD_VAR 0 12
65875: PUSH
65876: LD_VAR 0 7
65880: ARRAY
65881: PUSH
65882: LD_INT 2
65884: ARRAY
65885: PPUSH
65886: CALL_OW 546
65890: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
65891: LD_VAR 0 8
65895: PUSH
65896: LD_INT 1
65898: ARRAY
65899: PUSH
65900: LD_VAR 0 8
65904: PUSH
65905: LD_INT 2
65907: ARRAY
65908: PUSH
65909: LD_VAR 0 13
65913: PUSH
65914: LD_INT 2
65916: PLUS
65917: GREATER
65918: OR
65919: PUSH
65920: LD_VAR 0 8
65924: PUSH
65925: LD_INT 2
65927: ARRAY
65928: PUSH
65929: LD_VAR 0 13
65933: PUSH
65934: LD_INT 2
65936: MINUS
65937: LESS
65938: OR
65939: PUSH
65940: LD_VAR 0 8
65944: PUSH
65945: LD_INT 3
65947: ARRAY
65948: PUSH
65949: LD_INT 0
65951: PUSH
65952: LD_INT 8
65954: PUSH
65955: LD_INT 9
65957: PUSH
65958: LD_INT 10
65960: PUSH
65961: LD_INT 11
65963: PUSH
65964: LD_INT 12
65966: PUSH
65967: LD_INT 13
65969: PUSH
65970: LD_INT 16
65972: PUSH
65973: LD_INT 17
65975: PUSH
65976: LD_INT 18
65978: PUSH
65979: LD_INT 19
65981: PUSH
65982: LD_INT 20
65984: PUSH
65985: LD_INT 21
65987: PUSH
65988: EMPTY
65989: LIST
65990: LIST
65991: LIST
65992: LIST
65993: LIST
65994: LIST
65995: LIST
65996: LIST
65997: LIST
65998: LIST
65999: LIST
66000: LIST
66001: LIST
66002: IN
66003: NOT
66004: OR
66005: PUSH
66006: LD_VAR 0 8
66010: PUSH
66011: LD_INT 5
66013: ARRAY
66014: NOT
66015: OR
66016: PUSH
66017: LD_VAR 0 8
66021: PUSH
66022: LD_INT 6
66024: ARRAY
66025: PUSH
66026: LD_INT 1
66028: PUSH
66029: LD_INT 2
66031: PUSH
66032: LD_INT 7
66034: PUSH
66035: LD_INT 9
66037: PUSH
66038: LD_INT 10
66040: PUSH
66041: LD_INT 11
66043: PUSH
66044: EMPTY
66045: LIST
66046: LIST
66047: LIST
66048: LIST
66049: LIST
66050: LIST
66051: IN
66052: NOT
66053: OR
66054: IFFALSE 66060
// exit ;
66056: POP
66057: POP
66058: GO 66143
// end ;
66060: GO 65731
66062: POP
66063: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
66064: LD_VAR 0 9
66068: PPUSH
66069: LD_VAR 0 3
66073: PPUSH
66074: LD_VAR 0 4
66078: PPUSH
66079: LD_INT 20
66081: PPUSH
66082: CALL 58095 0 4
66086: PUSH
66087: LD_INT 4
66089: ARRAY
66090: IFFALSE 66094
// exit ;
66092: GO 66143
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
66094: LD_VAR 0 2
66098: PUSH
66099: LD_INT 29
66101: PUSH
66102: LD_INT 30
66104: PUSH
66105: EMPTY
66106: LIST
66107: LIST
66108: IN
66109: PUSH
66110: LD_VAR 0 3
66114: PPUSH
66115: LD_VAR 0 4
66119: PPUSH
66120: LD_VAR 0 9
66124: PPUSH
66125: CALL_OW 440
66129: NOT
66130: AND
66131: IFFALSE 66135
// exit ;
66133: GO 66143
// result := true ;
66135: LD_ADDR_VAR 0 6
66139: PUSH
66140: LD_INT 1
66142: ST_TO_ADDR
// end ;
66143: LD_VAR 0 6
66147: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
66148: LD_INT 0
66150: PPUSH
66151: PPUSH
66152: PPUSH
66153: PPUSH
66154: PPUSH
66155: PPUSH
66156: PPUSH
66157: PPUSH
66158: PPUSH
66159: PPUSH
66160: PPUSH
66161: PPUSH
66162: PPUSH
66163: PPUSH
66164: PPUSH
66165: PPUSH
66166: PPUSH
66167: PPUSH
66168: PPUSH
66169: PPUSH
66170: PPUSH
66171: PPUSH
66172: PPUSH
66173: PPUSH
66174: PPUSH
66175: PPUSH
66176: PPUSH
66177: PPUSH
66178: PPUSH
66179: PPUSH
66180: PPUSH
66181: PPUSH
66182: PPUSH
66183: PPUSH
66184: PPUSH
66185: PPUSH
66186: PPUSH
66187: PPUSH
66188: PPUSH
66189: PPUSH
66190: PPUSH
66191: PPUSH
66192: PPUSH
66193: PPUSH
66194: PPUSH
66195: PPUSH
66196: PPUSH
66197: PPUSH
66198: PPUSH
66199: PPUSH
66200: PPUSH
66201: PPUSH
66202: PPUSH
66203: PPUSH
66204: PPUSH
66205: PPUSH
66206: PPUSH
66207: PPUSH
// result = [ ] ;
66208: LD_ADDR_VAR 0 7
66212: PUSH
66213: EMPTY
66214: ST_TO_ADDR
// temp_list = [ ] ;
66215: LD_ADDR_VAR 0 9
66219: PUSH
66220: EMPTY
66221: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
66222: LD_VAR 0 4
66226: PUSH
66227: LD_INT 0
66229: PUSH
66230: LD_INT 1
66232: PUSH
66233: LD_INT 2
66235: PUSH
66236: LD_INT 3
66238: PUSH
66239: LD_INT 4
66241: PUSH
66242: LD_INT 5
66244: PUSH
66245: EMPTY
66246: LIST
66247: LIST
66248: LIST
66249: LIST
66250: LIST
66251: LIST
66252: IN
66253: NOT
66254: PUSH
66255: LD_VAR 0 1
66259: PUSH
66260: LD_INT 0
66262: PUSH
66263: LD_INT 1
66265: PUSH
66266: EMPTY
66267: LIST
66268: LIST
66269: IN
66270: PUSH
66271: LD_VAR 0 5
66275: PUSH
66276: LD_INT 1
66278: PUSH
66279: LD_INT 2
66281: PUSH
66282: LD_INT 3
66284: PUSH
66285: EMPTY
66286: LIST
66287: LIST
66288: LIST
66289: IN
66290: NOT
66291: AND
66292: OR
66293: IFFALSE 66297
// exit ;
66295: GO 84688
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
66297: LD_VAR 0 1
66301: PUSH
66302: LD_INT 6
66304: PUSH
66305: LD_INT 7
66307: PUSH
66308: LD_INT 8
66310: PUSH
66311: LD_INT 13
66313: PUSH
66314: LD_INT 12
66316: PUSH
66317: LD_INT 15
66319: PUSH
66320: LD_INT 11
66322: PUSH
66323: LD_INT 14
66325: PUSH
66326: LD_INT 10
66328: PUSH
66329: EMPTY
66330: LIST
66331: LIST
66332: LIST
66333: LIST
66334: LIST
66335: LIST
66336: LIST
66337: LIST
66338: LIST
66339: IN
66340: IFFALSE 66350
// btype = b_lab ;
66342: LD_ADDR_VAR 0 1
66346: PUSH
66347: LD_INT 6
66349: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
66350: LD_VAR 0 6
66354: PUSH
66355: LD_INT 0
66357: PUSH
66358: LD_INT 1
66360: PUSH
66361: LD_INT 2
66363: PUSH
66364: EMPTY
66365: LIST
66366: LIST
66367: LIST
66368: IN
66369: NOT
66370: PUSH
66371: LD_VAR 0 1
66375: PUSH
66376: LD_INT 0
66378: PUSH
66379: LD_INT 1
66381: PUSH
66382: LD_INT 2
66384: PUSH
66385: LD_INT 3
66387: PUSH
66388: LD_INT 6
66390: PUSH
66391: LD_INT 36
66393: PUSH
66394: LD_INT 4
66396: PUSH
66397: LD_INT 5
66399: PUSH
66400: LD_INT 31
66402: PUSH
66403: LD_INT 32
66405: PUSH
66406: LD_INT 33
66408: PUSH
66409: EMPTY
66410: LIST
66411: LIST
66412: LIST
66413: LIST
66414: LIST
66415: LIST
66416: LIST
66417: LIST
66418: LIST
66419: LIST
66420: LIST
66421: IN
66422: NOT
66423: PUSH
66424: LD_VAR 0 6
66428: PUSH
66429: LD_INT 1
66431: EQUAL
66432: AND
66433: OR
66434: PUSH
66435: LD_VAR 0 1
66439: PUSH
66440: LD_INT 2
66442: PUSH
66443: LD_INT 3
66445: PUSH
66446: EMPTY
66447: LIST
66448: LIST
66449: IN
66450: NOT
66451: PUSH
66452: LD_VAR 0 6
66456: PUSH
66457: LD_INT 2
66459: EQUAL
66460: AND
66461: OR
66462: IFFALSE 66472
// mode = 0 ;
66464: LD_ADDR_VAR 0 6
66468: PUSH
66469: LD_INT 0
66471: ST_TO_ADDR
// case mode of 0 :
66472: LD_VAR 0 6
66476: PUSH
66477: LD_INT 0
66479: DOUBLE
66480: EQUAL
66481: IFTRUE 66485
66483: GO 77938
66485: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
66486: LD_ADDR_VAR 0 11
66490: PUSH
66491: LD_INT 0
66493: PUSH
66494: LD_INT 0
66496: PUSH
66497: EMPTY
66498: LIST
66499: LIST
66500: PUSH
66501: LD_INT 0
66503: PUSH
66504: LD_INT 1
66506: NEG
66507: PUSH
66508: EMPTY
66509: LIST
66510: LIST
66511: PUSH
66512: LD_INT 1
66514: PUSH
66515: LD_INT 0
66517: PUSH
66518: EMPTY
66519: LIST
66520: LIST
66521: PUSH
66522: LD_INT 1
66524: PUSH
66525: LD_INT 1
66527: PUSH
66528: EMPTY
66529: LIST
66530: LIST
66531: PUSH
66532: LD_INT 0
66534: PUSH
66535: LD_INT 1
66537: PUSH
66538: EMPTY
66539: LIST
66540: LIST
66541: PUSH
66542: LD_INT 1
66544: NEG
66545: PUSH
66546: LD_INT 0
66548: PUSH
66549: EMPTY
66550: LIST
66551: LIST
66552: PUSH
66553: LD_INT 1
66555: NEG
66556: PUSH
66557: LD_INT 1
66559: NEG
66560: PUSH
66561: EMPTY
66562: LIST
66563: LIST
66564: PUSH
66565: LD_INT 1
66567: NEG
66568: PUSH
66569: LD_INT 2
66571: NEG
66572: PUSH
66573: EMPTY
66574: LIST
66575: LIST
66576: PUSH
66577: LD_INT 0
66579: PUSH
66580: LD_INT 2
66582: NEG
66583: PUSH
66584: EMPTY
66585: LIST
66586: LIST
66587: PUSH
66588: LD_INT 1
66590: PUSH
66591: LD_INT 1
66593: NEG
66594: PUSH
66595: EMPTY
66596: LIST
66597: LIST
66598: PUSH
66599: LD_INT 1
66601: PUSH
66602: LD_INT 2
66604: PUSH
66605: EMPTY
66606: LIST
66607: LIST
66608: PUSH
66609: LD_INT 0
66611: PUSH
66612: LD_INT 2
66614: PUSH
66615: EMPTY
66616: LIST
66617: LIST
66618: PUSH
66619: LD_INT 1
66621: NEG
66622: PUSH
66623: LD_INT 1
66625: PUSH
66626: EMPTY
66627: LIST
66628: LIST
66629: PUSH
66630: LD_INT 1
66632: PUSH
66633: LD_INT 3
66635: PUSH
66636: EMPTY
66637: LIST
66638: LIST
66639: PUSH
66640: LD_INT 0
66642: PUSH
66643: LD_INT 3
66645: PUSH
66646: EMPTY
66647: LIST
66648: LIST
66649: PUSH
66650: LD_INT 1
66652: NEG
66653: PUSH
66654: LD_INT 2
66656: PUSH
66657: EMPTY
66658: LIST
66659: LIST
66660: PUSH
66661: EMPTY
66662: LIST
66663: LIST
66664: LIST
66665: LIST
66666: LIST
66667: LIST
66668: LIST
66669: LIST
66670: LIST
66671: LIST
66672: LIST
66673: LIST
66674: LIST
66675: LIST
66676: LIST
66677: LIST
66678: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
66679: LD_ADDR_VAR 0 12
66683: PUSH
66684: LD_INT 0
66686: PUSH
66687: LD_INT 0
66689: PUSH
66690: EMPTY
66691: LIST
66692: LIST
66693: PUSH
66694: LD_INT 0
66696: PUSH
66697: LD_INT 1
66699: NEG
66700: PUSH
66701: EMPTY
66702: LIST
66703: LIST
66704: PUSH
66705: LD_INT 1
66707: PUSH
66708: LD_INT 0
66710: PUSH
66711: EMPTY
66712: LIST
66713: LIST
66714: PUSH
66715: LD_INT 1
66717: PUSH
66718: LD_INT 1
66720: PUSH
66721: EMPTY
66722: LIST
66723: LIST
66724: PUSH
66725: LD_INT 0
66727: PUSH
66728: LD_INT 1
66730: PUSH
66731: EMPTY
66732: LIST
66733: LIST
66734: PUSH
66735: LD_INT 1
66737: NEG
66738: PUSH
66739: LD_INT 0
66741: PUSH
66742: EMPTY
66743: LIST
66744: LIST
66745: PUSH
66746: LD_INT 1
66748: NEG
66749: PUSH
66750: LD_INT 1
66752: NEG
66753: PUSH
66754: EMPTY
66755: LIST
66756: LIST
66757: PUSH
66758: LD_INT 1
66760: PUSH
66761: LD_INT 1
66763: NEG
66764: PUSH
66765: EMPTY
66766: LIST
66767: LIST
66768: PUSH
66769: LD_INT 2
66771: PUSH
66772: LD_INT 0
66774: PUSH
66775: EMPTY
66776: LIST
66777: LIST
66778: PUSH
66779: LD_INT 2
66781: PUSH
66782: LD_INT 1
66784: PUSH
66785: EMPTY
66786: LIST
66787: LIST
66788: PUSH
66789: LD_INT 1
66791: NEG
66792: PUSH
66793: LD_INT 1
66795: PUSH
66796: EMPTY
66797: LIST
66798: LIST
66799: PUSH
66800: LD_INT 2
66802: NEG
66803: PUSH
66804: LD_INT 0
66806: PUSH
66807: EMPTY
66808: LIST
66809: LIST
66810: PUSH
66811: LD_INT 2
66813: NEG
66814: PUSH
66815: LD_INT 1
66817: NEG
66818: PUSH
66819: EMPTY
66820: LIST
66821: LIST
66822: PUSH
66823: LD_INT 2
66825: NEG
66826: PUSH
66827: LD_INT 1
66829: PUSH
66830: EMPTY
66831: LIST
66832: LIST
66833: PUSH
66834: LD_INT 3
66836: NEG
66837: PUSH
66838: LD_INT 0
66840: PUSH
66841: EMPTY
66842: LIST
66843: LIST
66844: PUSH
66845: LD_INT 3
66847: NEG
66848: PUSH
66849: LD_INT 1
66851: NEG
66852: PUSH
66853: EMPTY
66854: LIST
66855: LIST
66856: PUSH
66857: EMPTY
66858: LIST
66859: LIST
66860: LIST
66861: LIST
66862: LIST
66863: LIST
66864: LIST
66865: LIST
66866: LIST
66867: LIST
66868: LIST
66869: LIST
66870: LIST
66871: LIST
66872: LIST
66873: LIST
66874: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
66875: LD_ADDR_VAR 0 13
66879: PUSH
66880: LD_INT 0
66882: PUSH
66883: LD_INT 0
66885: PUSH
66886: EMPTY
66887: LIST
66888: LIST
66889: PUSH
66890: LD_INT 0
66892: PUSH
66893: LD_INT 1
66895: NEG
66896: PUSH
66897: EMPTY
66898: LIST
66899: LIST
66900: PUSH
66901: LD_INT 1
66903: PUSH
66904: LD_INT 0
66906: PUSH
66907: EMPTY
66908: LIST
66909: LIST
66910: PUSH
66911: LD_INT 1
66913: PUSH
66914: LD_INT 1
66916: PUSH
66917: EMPTY
66918: LIST
66919: LIST
66920: PUSH
66921: LD_INT 0
66923: PUSH
66924: LD_INT 1
66926: PUSH
66927: EMPTY
66928: LIST
66929: LIST
66930: PUSH
66931: LD_INT 1
66933: NEG
66934: PUSH
66935: LD_INT 0
66937: PUSH
66938: EMPTY
66939: LIST
66940: LIST
66941: PUSH
66942: LD_INT 1
66944: NEG
66945: PUSH
66946: LD_INT 1
66948: NEG
66949: PUSH
66950: EMPTY
66951: LIST
66952: LIST
66953: PUSH
66954: LD_INT 1
66956: NEG
66957: PUSH
66958: LD_INT 2
66960: NEG
66961: PUSH
66962: EMPTY
66963: LIST
66964: LIST
66965: PUSH
66966: LD_INT 2
66968: PUSH
66969: LD_INT 1
66971: PUSH
66972: EMPTY
66973: LIST
66974: LIST
66975: PUSH
66976: LD_INT 2
66978: PUSH
66979: LD_INT 2
66981: PUSH
66982: EMPTY
66983: LIST
66984: LIST
66985: PUSH
66986: LD_INT 1
66988: PUSH
66989: LD_INT 2
66991: PUSH
66992: EMPTY
66993: LIST
66994: LIST
66995: PUSH
66996: LD_INT 2
66998: NEG
66999: PUSH
67000: LD_INT 1
67002: NEG
67003: PUSH
67004: EMPTY
67005: LIST
67006: LIST
67007: PUSH
67008: LD_INT 2
67010: NEG
67011: PUSH
67012: LD_INT 2
67014: NEG
67015: PUSH
67016: EMPTY
67017: LIST
67018: LIST
67019: PUSH
67020: LD_INT 2
67022: NEG
67023: PUSH
67024: LD_INT 3
67026: NEG
67027: PUSH
67028: EMPTY
67029: LIST
67030: LIST
67031: PUSH
67032: LD_INT 3
67034: NEG
67035: PUSH
67036: LD_INT 2
67038: NEG
67039: PUSH
67040: EMPTY
67041: LIST
67042: LIST
67043: PUSH
67044: LD_INT 3
67046: NEG
67047: PUSH
67048: LD_INT 3
67050: NEG
67051: PUSH
67052: EMPTY
67053: LIST
67054: LIST
67055: PUSH
67056: EMPTY
67057: LIST
67058: LIST
67059: LIST
67060: LIST
67061: LIST
67062: LIST
67063: LIST
67064: LIST
67065: LIST
67066: LIST
67067: LIST
67068: LIST
67069: LIST
67070: LIST
67071: LIST
67072: LIST
67073: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
67074: LD_ADDR_VAR 0 14
67078: PUSH
67079: LD_INT 0
67081: PUSH
67082: LD_INT 0
67084: PUSH
67085: EMPTY
67086: LIST
67087: LIST
67088: PUSH
67089: LD_INT 0
67091: PUSH
67092: LD_INT 1
67094: NEG
67095: PUSH
67096: EMPTY
67097: LIST
67098: LIST
67099: PUSH
67100: LD_INT 1
67102: PUSH
67103: LD_INT 0
67105: PUSH
67106: EMPTY
67107: LIST
67108: LIST
67109: PUSH
67110: LD_INT 1
67112: PUSH
67113: LD_INT 1
67115: PUSH
67116: EMPTY
67117: LIST
67118: LIST
67119: PUSH
67120: LD_INT 0
67122: PUSH
67123: LD_INT 1
67125: PUSH
67126: EMPTY
67127: LIST
67128: LIST
67129: PUSH
67130: LD_INT 1
67132: NEG
67133: PUSH
67134: LD_INT 0
67136: PUSH
67137: EMPTY
67138: LIST
67139: LIST
67140: PUSH
67141: LD_INT 1
67143: NEG
67144: PUSH
67145: LD_INT 1
67147: NEG
67148: PUSH
67149: EMPTY
67150: LIST
67151: LIST
67152: PUSH
67153: LD_INT 1
67155: NEG
67156: PUSH
67157: LD_INT 2
67159: NEG
67160: PUSH
67161: EMPTY
67162: LIST
67163: LIST
67164: PUSH
67165: LD_INT 0
67167: PUSH
67168: LD_INT 2
67170: NEG
67171: PUSH
67172: EMPTY
67173: LIST
67174: LIST
67175: PUSH
67176: LD_INT 1
67178: PUSH
67179: LD_INT 1
67181: NEG
67182: PUSH
67183: EMPTY
67184: LIST
67185: LIST
67186: PUSH
67187: LD_INT 1
67189: PUSH
67190: LD_INT 2
67192: PUSH
67193: EMPTY
67194: LIST
67195: LIST
67196: PUSH
67197: LD_INT 0
67199: PUSH
67200: LD_INT 2
67202: PUSH
67203: EMPTY
67204: LIST
67205: LIST
67206: PUSH
67207: LD_INT 1
67209: NEG
67210: PUSH
67211: LD_INT 1
67213: PUSH
67214: EMPTY
67215: LIST
67216: LIST
67217: PUSH
67218: LD_INT 1
67220: NEG
67221: PUSH
67222: LD_INT 3
67224: NEG
67225: PUSH
67226: EMPTY
67227: LIST
67228: LIST
67229: PUSH
67230: LD_INT 0
67232: PUSH
67233: LD_INT 3
67235: NEG
67236: PUSH
67237: EMPTY
67238: LIST
67239: LIST
67240: PUSH
67241: LD_INT 1
67243: PUSH
67244: LD_INT 2
67246: NEG
67247: PUSH
67248: EMPTY
67249: LIST
67250: LIST
67251: PUSH
67252: EMPTY
67253: LIST
67254: LIST
67255: LIST
67256: LIST
67257: LIST
67258: LIST
67259: LIST
67260: LIST
67261: LIST
67262: LIST
67263: LIST
67264: LIST
67265: LIST
67266: LIST
67267: LIST
67268: LIST
67269: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
67270: LD_ADDR_VAR 0 15
67274: PUSH
67275: LD_INT 0
67277: PUSH
67278: LD_INT 0
67280: PUSH
67281: EMPTY
67282: LIST
67283: LIST
67284: PUSH
67285: LD_INT 0
67287: PUSH
67288: LD_INT 1
67290: NEG
67291: PUSH
67292: EMPTY
67293: LIST
67294: LIST
67295: PUSH
67296: LD_INT 1
67298: PUSH
67299: LD_INT 0
67301: PUSH
67302: EMPTY
67303: LIST
67304: LIST
67305: PUSH
67306: LD_INT 1
67308: PUSH
67309: LD_INT 1
67311: PUSH
67312: EMPTY
67313: LIST
67314: LIST
67315: PUSH
67316: LD_INT 0
67318: PUSH
67319: LD_INT 1
67321: PUSH
67322: EMPTY
67323: LIST
67324: LIST
67325: PUSH
67326: LD_INT 1
67328: NEG
67329: PUSH
67330: LD_INT 0
67332: PUSH
67333: EMPTY
67334: LIST
67335: LIST
67336: PUSH
67337: LD_INT 1
67339: NEG
67340: PUSH
67341: LD_INT 1
67343: NEG
67344: PUSH
67345: EMPTY
67346: LIST
67347: LIST
67348: PUSH
67349: LD_INT 1
67351: PUSH
67352: LD_INT 1
67354: NEG
67355: PUSH
67356: EMPTY
67357: LIST
67358: LIST
67359: PUSH
67360: LD_INT 2
67362: PUSH
67363: LD_INT 0
67365: PUSH
67366: EMPTY
67367: LIST
67368: LIST
67369: PUSH
67370: LD_INT 2
67372: PUSH
67373: LD_INT 1
67375: PUSH
67376: EMPTY
67377: LIST
67378: LIST
67379: PUSH
67380: LD_INT 1
67382: NEG
67383: PUSH
67384: LD_INT 1
67386: PUSH
67387: EMPTY
67388: LIST
67389: LIST
67390: PUSH
67391: LD_INT 2
67393: NEG
67394: PUSH
67395: LD_INT 0
67397: PUSH
67398: EMPTY
67399: LIST
67400: LIST
67401: PUSH
67402: LD_INT 2
67404: NEG
67405: PUSH
67406: LD_INT 1
67408: NEG
67409: PUSH
67410: EMPTY
67411: LIST
67412: LIST
67413: PUSH
67414: LD_INT 2
67416: PUSH
67417: LD_INT 1
67419: NEG
67420: PUSH
67421: EMPTY
67422: LIST
67423: LIST
67424: PUSH
67425: LD_INT 3
67427: PUSH
67428: LD_INT 0
67430: PUSH
67431: EMPTY
67432: LIST
67433: LIST
67434: PUSH
67435: LD_INT 3
67437: PUSH
67438: LD_INT 1
67440: PUSH
67441: EMPTY
67442: LIST
67443: LIST
67444: PUSH
67445: EMPTY
67446: LIST
67447: LIST
67448: LIST
67449: LIST
67450: LIST
67451: LIST
67452: LIST
67453: LIST
67454: LIST
67455: LIST
67456: LIST
67457: LIST
67458: LIST
67459: LIST
67460: LIST
67461: LIST
67462: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
67463: LD_ADDR_VAR 0 16
67467: PUSH
67468: LD_INT 0
67470: PUSH
67471: LD_INT 0
67473: PUSH
67474: EMPTY
67475: LIST
67476: LIST
67477: PUSH
67478: LD_INT 0
67480: PUSH
67481: LD_INT 1
67483: NEG
67484: PUSH
67485: EMPTY
67486: LIST
67487: LIST
67488: PUSH
67489: LD_INT 1
67491: PUSH
67492: LD_INT 0
67494: PUSH
67495: EMPTY
67496: LIST
67497: LIST
67498: PUSH
67499: LD_INT 1
67501: PUSH
67502: LD_INT 1
67504: PUSH
67505: EMPTY
67506: LIST
67507: LIST
67508: PUSH
67509: LD_INT 0
67511: PUSH
67512: LD_INT 1
67514: PUSH
67515: EMPTY
67516: LIST
67517: LIST
67518: PUSH
67519: LD_INT 1
67521: NEG
67522: PUSH
67523: LD_INT 0
67525: PUSH
67526: EMPTY
67527: LIST
67528: LIST
67529: PUSH
67530: LD_INT 1
67532: NEG
67533: PUSH
67534: LD_INT 1
67536: NEG
67537: PUSH
67538: EMPTY
67539: LIST
67540: LIST
67541: PUSH
67542: LD_INT 1
67544: NEG
67545: PUSH
67546: LD_INT 2
67548: NEG
67549: PUSH
67550: EMPTY
67551: LIST
67552: LIST
67553: PUSH
67554: LD_INT 2
67556: PUSH
67557: LD_INT 1
67559: PUSH
67560: EMPTY
67561: LIST
67562: LIST
67563: PUSH
67564: LD_INT 2
67566: PUSH
67567: LD_INT 2
67569: PUSH
67570: EMPTY
67571: LIST
67572: LIST
67573: PUSH
67574: LD_INT 1
67576: PUSH
67577: LD_INT 2
67579: PUSH
67580: EMPTY
67581: LIST
67582: LIST
67583: PUSH
67584: LD_INT 2
67586: NEG
67587: PUSH
67588: LD_INT 1
67590: NEG
67591: PUSH
67592: EMPTY
67593: LIST
67594: LIST
67595: PUSH
67596: LD_INT 2
67598: NEG
67599: PUSH
67600: LD_INT 2
67602: NEG
67603: PUSH
67604: EMPTY
67605: LIST
67606: LIST
67607: PUSH
67608: LD_INT 3
67610: PUSH
67611: LD_INT 2
67613: PUSH
67614: EMPTY
67615: LIST
67616: LIST
67617: PUSH
67618: LD_INT 3
67620: PUSH
67621: LD_INT 3
67623: PUSH
67624: EMPTY
67625: LIST
67626: LIST
67627: PUSH
67628: LD_INT 2
67630: PUSH
67631: LD_INT 3
67633: PUSH
67634: EMPTY
67635: LIST
67636: LIST
67637: PUSH
67638: EMPTY
67639: LIST
67640: LIST
67641: LIST
67642: LIST
67643: LIST
67644: LIST
67645: LIST
67646: LIST
67647: LIST
67648: LIST
67649: LIST
67650: LIST
67651: LIST
67652: LIST
67653: LIST
67654: LIST
67655: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67656: LD_ADDR_VAR 0 17
67660: PUSH
67661: LD_INT 0
67663: PUSH
67664: LD_INT 0
67666: PUSH
67667: EMPTY
67668: LIST
67669: LIST
67670: PUSH
67671: LD_INT 0
67673: PUSH
67674: LD_INT 1
67676: NEG
67677: PUSH
67678: EMPTY
67679: LIST
67680: LIST
67681: PUSH
67682: LD_INT 1
67684: PUSH
67685: LD_INT 0
67687: PUSH
67688: EMPTY
67689: LIST
67690: LIST
67691: PUSH
67692: LD_INT 1
67694: PUSH
67695: LD_INT 1
67697: PUSH
67698: EMPTY
67699: LIST
67700: LIST
67701: PUSH
67702: LD_INT 0
67704: PUSH
67705: LD_INT 1
67707: PUSH
67708: EMPTY
67709: LIST
67710: LIST
67711: PUSH
67712: LD_INT 1
67714: NEG
67715: PUSH
67716: LD_INT 0
67718: PUSH
67719: EMPTY
67720: LIST
67721: LIST
67722: PUSH
67723: LD_INT 1
67725: NEG
67726: PUSH
67727: LD_INT 1
67729: NEG
67730: PUSH
67731: EMPTY
67732: LIST
67733: LIST
67734: PUSH
67735: LD_INT 1
67737: NEG
67738: PUSH
67739: LD_INT 2
67741: NEG
67742: PUSH
67743: EMPTY
67744: LIST
67745: LIST
67746: PUSH
67747: LD_INT 0
67749: PUSH
67750: LD_INT 2
67752: NEG
67753: PUSH
67754: EMPTY
67755: LIST
67756: LIST
67757: PUSH
67758: LD_INT 1
67760: PUSH
67761: LD_INT 1
67763: NEG
67764: PUSH
67765: EMPTY
67766: LIST
67767: LIST
67768: PUSH
67769: LD_INT 2
67771: PUSH
67772: LD_INT 0
67774: PUSH
67775: EMPTY
67776: LIST
67777: LIST
67778: PUSH
67779: LD_INT 2
67781: PUSH
67782: LD_INT 1
67784: PUSH
67785: EMPTY
67786: LIST
67787: LIST
67788: PUSH
67789: LD_INT 2
67791: PUSH
67792: LD_INT 2
67794: PUSH
67795: EMPTY
67796: LIST
67797: LIST
67798: PUSH
67799: LD_INT 1
67801: PUSH
67802: LD_INT 2
67804: PUSH
67805: EMPTY
67806: LIST
67807: LIST
67808: PUSH
67809: LD_INT 0
67811: PUSH
67812: LD_INT 2
67814: PUSH
67815: EMPTY
67816: LIST
67817: LIST
67818: PUSH
67819: LD_INT 1
67821: NEG
67822: PUSH
67823: LD_INT 1
67825: PUSH
67826: EMPTY
67827: LIST
67828: LIST
67829: PUSH
67830: LD_INT 2
67832: NEG
67833: PUSH
67834: LD_INT 0
67836: PUSH
67837: EMPTY
67838: LIST
67839: LIST
67840: PUSH
67841: LD_INT 2
67843: NEG
67844: PUSH
67845: LD_INT 1
67847: NEG
67848: PUSH
67849: EMPTY
67850: LIST
67851: LIST
67852: PUSH
67853: LD_INT 2
67855: NEG
67856: PUSH
67857: LD_INT 2
67859: NEG
67860: PUSH
67861: EMPTY
67862: LIST
67863: LIST
67864: PUSH
67865: EMPTY
67866: LIST
67867: LIST
67868: LIST
67869: LIST
67870: LIST
67871: LIST
67872: LIST
67873: LIST
67874: LIST
67875: LIST
67876: LIST
67877: LIST
67878: LIST
67879: LIST
67880: LIST
67881: LIST
67882: LIST
67883: LIST
67884: LIST
67885: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67886: LD_ADDR_VAR 0 18
67890: PUSH
67891: LD_INT 0
67893: PUSH
67894: LD_INT 0
67896: PUSH
67897: EMPTY
67898: LIST
67899: LIST
67900: PUSH
67901: LD_INT 0
67903: PUSH
67904: LD_INT 1
67906: NEG
67907: PUSH
67908: EMPTY
67909: LIST
67910: LIST
67911: PUSH
67912: LD_INT 1
67914: PUSH
67915: LD_INT 0
67917: PUSH
67918: EMPTY
67919: LIST
67920: LIST
67921: PUSH
67922: LD_INT 1
67924: PUSH
67925: LD_INT 1
67927: PUSH
67928: EMPTY
67929: LIST
67930: LIST
67931: PUSH
67932: LD_INT 0
67934: PUSH
67935: LD_INT 1
67937: PUSH
67938: EMPTY
67939: LIST
67940: LIST
67941: PUSH
67942: LD_INT 1
67944: NEG
67945: PUSH
67946: LD_INT 0
67948: PUSH
67949: EMPTY
67950: LIST
67951: LIST
67952: PUSH
67953: LD_INT 1
67955: NEG
67956: PUSH
67957: LD_INT 1
67959: NEG
67960: PUSH
67961: EMPTY
67962: LIST
67963: LIST
67964: PUSH
67965: LD_INT 1
67967: NEG
67968: PUSH
67969: LD_INT 2
67971: NEG
67972: PUSH
67973: EMPTY
67974: LIST
67975: LIST
67976: PUSH
67977: LD_INT 0
67979: PUSH
67980: LD_INT 2
67982: NEG
67983: PUSH
67984: EMPTY
67985: LIST
67986: LIST
67987: PUSH
67988: LD_INT 1
67990: PUSH
67991: LD_INT 1
67993: NEG
67994: PUSH
67995: EMPTY
67996: LIST
67997: LIST
67998: PUSH
67999: LD_INT 2
68001: PUSH
68002: LD_INT 0
68004: PUSH
68005: EMPTY
68006: LIST
68007: LIST
68008: PUSH
68009: LD_INT 2
68011: PUSH
68012: LD_INT 1
68014: PUSH
68015: EMPTY
68016: LIST
68017: LIST
68018: PUSH
68019: LD_INT 2
68021: PUSH
68022: LD_INT 2
68024: PUSH
68025: EMPTY
68026: LIST
68027: LIST
68028: PUSH
68029: LD_INT 1
68031: PUSH
68032: LD_INT 2
68034: PUSH
68035: EMPTY
68036: LIST
68037: LIST
68038: PUSH
68039: LD_INT 0
68041: PUSH
68042: LD_INT 2
68044: PUSH
68045: EMPTY
68046: LIST
68047: LIST
68048: PUSH
68049: LD_INT 1
68051: NEG
68052: PUSH
68053: LD_INT 1
68055: PUSH
68056: EMPTY
68057: LIST
68058: LIST
68059: PUSH
68060: LD_INT 2
68062: NEG
68063: PUSH
68064: LD_INT 0
68066: PUSH
68067: EMPTY
68068: LIST
68069: LIST
68070: PUSH
68071: LD_INT 2
68073: NEG
68074: PUSH
68075: LD_INT 1
68077: NEG
68078: PUSH
68079: EMPTY
68080: LIST
68081: LIST
68082: PUSH
68083: LD_INT 2
68085: NEG
68086: PUSH
68087: LD_INT 2
68089: NEG
68090: PUSH
68091: EMPTY
68092: LIST
68093: LIST
68094: PUSH
68095: EMPTY
68096: LIST
68097: LIST
68098: LIST
68099: LIST
68100: LIST
68101: LIST
68102: LIST
68103: LIST
68104: LIST
68105: LIST
68106: LIST
68107: LIST
68108: LIST
68109: LIST
68110: LIST
68111: LIST
68112: LIST
68113: LIST
68114: LIST
68115: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68116: LD_ADDR_VAR 0 19
68120: PUSH
68121: LD_INT 0
68123: PUSH
68124: LD_INT 0
68126: PUSH
68127: EMPTY
68128: LIST
68129: LIST
68130: PUSH
68131: LD_INT 0
68133: PUSH
68134: LD_INT 1
68136: NEG
68137: PUSH
68138: EMPTY
68139: LIST
68140: LIST
68141: PUSH
68142: LD_INT 1
68144: PUSH
68145: LD_INT 0
68147: PUSH
68148: EMPTY
68149: LIST
68150: LIST
68151: PUSH
68152: LD_INT 1
68154: PUSH
68155: LD_INT 1
68157: PUSH
68158: EMPTY
68159: LIST
68160: LIST
68161: PUSH
68162: LD_INT 0
68164: PUSH
68165: LD_INT 1
68167: PUSH
68168: EMPTY
68169: LIST
68170: LIST
68171: PUSH
68172: LD_INT 1
68174: NEG
68175: PUSH
68176: LD_INT 0
68178: PUSH
68179: EMPTY
68180: LIST
68181: LIST
68182: PUSH
68183: LD_INT 1
68185: NEG
68186: PUSH
68187: LD_INT 1
68189: NEG
68190: PUSH
68191: EMPTY
68192: LIST
68193: LIST
68194: PUSH
68195: LD_INT 1
68197: NEG
68198: PUSH
68199: LD_INT 2
68201: NEG
68202: PUSH
68203: EMPTY
68204: LIST
68205: LIST
68206: PUSH
68207: LD_INT 0
68209: PUSH
68210: LD_INT 2
68212: NEG
68213: PUSH
68214: EMPTY
68215: LIST
68216: LIST
68217: PUSH
68218: LD_INT 1
68220: PUSH
68221: LD_INT 1
68223: NEG
68224: PUSH
68225: EMPTY
68226: LIST
68227: LIST
68228: PUSH
68229: LD_INT 2
68231: PUSH
68232: LD_INT 0
68234: PUSH
68235: EMPTY
68236: LIST
68237: LIST
68238: PUSH
68239: LD_INT 2
68241: PUSH
68242: LD_INT 1
68244: PUSH
68245: EMPTY
68246: LIST
68247: LIST
68248: PUSH
68249: LD_INT 2
68251: PUSH
68252: LD_INT 2
68254: PUSH
68255: EMPTY
68256: LIST
68257: LIST
68258: PUSH
68259: LD_INT 1
68261: PUSH
68262: LD_INT 2
68264: PUSH
68265: EMPTY
68266: LIST
68267: LIST
68268: PUSH
68269: LD_INT 0
68271: PUSH
68272: LD_INT 2
68274: PUSH
68275: EMPTY
68276: LIST
68277: LIST
68278: PUSH
68279: LD_INT 1
68281: NEG
68282: PUSH
68283: LD_INT 1
68285: PUSH
68286: EMPTY
68287: LIST
68288: LIST
68289: PUSH
68290: LD_INT 2
68292: NEG
68293: PUSH
68294: LD_INT 0
68296: PUSH
68297: EMPTY
68298: LIST
68299: LIST
68300: PUSH
68301: LD_INT 2
68303: NEG
68304: PUSH
68305: LD_INT 1
68307: NEG
68308: PUSH
68309: EMPTY
68310: LIST
68311: LIST
68312: PUSH
68313: LD_INT 2
68315: NEG
68316: PUSH
68317: LD_INT 2
68319: NEG
68320: PUSH
68321: EMPTY
68322: LIST
68323: LIST
68324: PUSH
68325: EMPTY
68326: LIST
68327: LIST
68328: LIST
68329: LIST
68330: LIST
68331: LIST
68332: LIST
68333: LIST
68334: LIST
68335: LIST
68336: LIST
68337: LIST
68338: LIST
68339: LIST
68340: LIST
68341: LIST
68342: LIST
68343: LIST
68344: LIST
68345: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68346: LD_ADDR_VAR 0 20
68350: PUSH
68351: LD_INT 0
68353: PUSH
68354: LD_INT 0
68356: PUSH
68357: EMPTY
68358: LIST
68359: LIST
68360: PUSH
68361: LD_INT 0
68363: PUSH
68364: LD_INT 1
68366: NEG
68367: PUSH
68368: EMPTY
68369: LIST
68370: LIST
68371: PUSH
68372: LD_INT 1
68374: PUSH
68375: LD_INT 0
68377: PUSH
68378: EMPTY
68379: LIST
68380: LIST
68381: PUSH
68382: LD_INT 1
68384: PUSH
68385: LD_INT 1
68387: PUSH
68388: EMPTY
68389: LIST
68390: LIST
68391: PUSH
68392: LD_INT 0
68394: PUSH
68395: LD_INT 1
68397: PUSH
68398: EMPTY
68399: LIST
68400: LIST
68401: PUSH
68402: LD_INT 1
68404: NEG
68405: PUSH
68406: LD_INT 0
68408: PUSH
68409: EMPTY
68410: LIST
68411: LIST
68412: PUSH
68413: LD_INT 1
68415: NEG
68416: PUSH
68417: LD_INT 1
68419: NEG
68420: PUSH
68421: EMPTY
68422: LIST
68423: LIST
68424: PUSH
68425: LD_INT 1
68427: NEG
68428: PUSH
68429: LD_INT 2
68431: NEG
68432: PUSH
68433: EMPTY
68434: LIST
68435: LIST
68436: PUSH
68437: LD_INT 0
68439: PUSH
68440: LD_INT 2
68442: NEG
68443: PUSH
68444: EMPTY
68445: LIST
68446: LIST
68447: PUSH
68448: LD_INT 1
68450: PUSH
68451: LD_INT 1
68453: NEG
68454: PUSH
68455: EMPTY
68456: LIST
68457: LIST
68458: PUSH
68459: LD_INT 2
68461: PUSH
68462: LD_INT 0
68464: PUSH
68465: EMPTY
68466: LIST
68467: LIST
68468: PUSH
68469: LD_INT 2
68471: PUSH
68472: LD_INT 1
68474: PUSH
68475: EMPTY
68476: LIST
68477: LIST
68478: PUSH
68479: LD_INT 2
68481: PUSH
68482: LD_INT 2
68484: PUSH
68485: EMPTY
68486: LIST
68487: LIST
68488: PUSH
68489: LD_INT 1
68491: PUSH
68492: LD_INT 2
68494: PUSH
68495: EMPTY
68496: LIST
68497: LIST
68498: PUSH
68499: LD_INT 0
68501: PUSH
68502: LD_INT 2
68504: PUSH
68505: EMPTY
68506: LIST
68507: LIST
68508: PUSH
68509: LD_INT 1
68511: NEG
68512: PUSH
68513: LD_INT 1
68515: PUSH
68516: EMPTY
68517: LIST
68518: LIST
68519: PUSH
68520: LD_INT 2
68522: NEG
68523: PUSH
68524: LD_INT 0
68526: PUSH
68527: EMPTY
68528: LIST
68529: LIST
68530: PUSH
68531: LD_INT 2
68533: NEG
68534: PUSH
68535: LD_INT 1
68537: NEG
68538: PUSH
68539: EMPTY
68540: LIST
68541: LIST
68542: PUSH
68543: LD_INT 2
68545: NEG
68546: PUSH
68547: LD_INT 2
68549: NEG
68550: PUSH
68551: EMPTY
68552: LIST
68553: LIST
68554: PUSH
68555: EMPTY
68556: LIST
68557: LIST
68558: LIST
68559: LIST
68560: LIST
68561: LIST
68562: LIST
68563: LIST
68564: LIST
68565: LIST
68566: LIST
68567: LIST
68568: LIST
68569: LIST
68570: LIST
68571: LIST
68572: LIST
68573: LIST
68574: LIST
68575: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68576: LD_ADDR_VAR 0 21
68580: PUSH
68581: LD_INT 0
68583: PUSH
68584: LD_INT 0
68586: PUSH
68587: EMPTY
68588: LIST
68589: LIST
68590: PUSH
68591: LD_INT 0
68593: PUSH
68594: LD_INT 1
68596: NEG
68597: PUSH
68598: EMPTY
68599: LIST
68600: LIST
68601: PUSH
68602: LD_INT 1
68604: PUSH
68605: LD_INT 0
68607: PUSH
68608: EMPTY
68609: LIST
68610: LIST
68611: PUSH
68612: LD_INT 1
68614: PUSH
68615: LD_INT 1
68617: PUSH
68618: EMPTY
68619: LIST
68620: LIST
68621: PUSH
68622: LD_INT 0
68624: PUSH
68625: LD_INT 1
68627: PUSH
68628: EMPTY
68629: LIST
68630: LIST
68631: PUSH
68632: LD_INT 1
68634: NEG
68635: PUSH
68636: LD_INT 0
68638: PUSH
68639: EMPTY
68640: LIST
68641: LIST
68642: PUSH
68643: LD_INT 1
68645: NEG
68646: PUSH
68647: LD_INT 1
68649: NEG
68650: PUSH
68651: EMPTY
68652: LIST
68653: LIST
68654: PUSH
68655: LD_INT 1
68657: NEG
68658: PUSH
68659: LD_INT 2
68661: NEG
68662: PUSH
68663: EMPTY
68664: LIST
68665: LIST
68666: PUSH
68667: LD_INT 0
68669: PUSH
68670: LD_INT 2
68672: NEG
68673: PUSH
68674: EMPTY
68675: LIST
68676: LIST
68677: PUSH
68678: LD_INT 1
68680: PUSH
68681: LD_INT 1
68683: NEG
68684: PUSH
68685: EMPTY
68686: LIST
68687: LIST
68688: PUSH
68689: LD_INT 2
68691: PUSH
68692: LD_INT 0
68694: PUSH
68695: EMPTY
68696: LIST
68697: LIST
68698: PUSH
68699: LD_INT 2
68701: PUSH
68702: LD_INT 1
68704: PUSH
68705: EMPTY
68706: LIST
68707: LIST
68708: PUSH
68709: LD_INT 2
68711: PUSH
68712: LD_INT 2
68714: PUSH
68715: EMPTY
68716: LIST
68717: LIST
68718: PUSH
68719: LD_INT 1
68721: PUSH
68722: LD_INT 2
68724: PUSH
68725: EMPTY
68726: LIST
68727: LIST
68728: PUSH
68729: LD_INT 0
68731: PUSH
68732: LD_INT 2
68734: PUSH
68735: EMPTY
68736: LIST
68737: LIST
68738: PUSH
68739: LD_INT 1
68741: NEG
68742: PUSH
68743: LD_INT 1
68745: PUSH
68746: EMPTY
68747: LIST
68748: LIST
68749: PUSH
68750: LD_INT 2
68752: NEG
68753: PUSH
68754: LD_INT 0
68756: PUSH
68757: EMPTY
68758: LIST
68759: LIST
68760: PUSH
68761: LD_INT 2
68763: NEG
68764: PUSH
68765: LD_INT 1
68767: NEG
68768: PUSH
68769: EMPTY
68770: LIST
68771: LIST
68772: PUSH
68773: LD_INT 2
68775: NEG
68776: PUSH
68777: LD_INT 2
68779: NEG
68780: PUSH
68781: EMPTY
68782: LIST
68783: LIST
68784: PUSH
68785: EMPTY
68786: LIST
68787: LIST
68788: LIST
68789: LIST
68790: LIST
68791: LIST
68792: LIST
68793: LIST
68794: LIST
68795: LIST
68796: LIST
68797: LIST
68798: LIST
68799: LIST
68800: LIST
68801: LIST
68802: LIST
68803: LIST
68804: LIST
68805: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68806: LD_ADDR_VAR 0 22
68810: PUSH
68811: LD_INT 0
68813: PUSH
68814: LD_INT 0
68816: PUSH
68817: EMPTY
68818: LIST
68819: LIST
68820: PUSH
68821: LD_INT 0
68823: PUSH
68824: LD_INT 1
68826: NEG
68827: PUSH
68828: EMPTY
68829: LIST
68830: LIST
68831: PUSH
68832: LD_INT 1
68834: PUSH
68835: LD_INT 0
68837: PUSH
68838: EMPTY
68839: LIST
68840: LIST
68841: PUSH
68842: LD_INT 1
68844: PUSH
68845: LD_INT 1
68847: PUSH
68848: EMPTY
68849: LIST
68850: LIST
68851: PUSH
68852: LD_INT 0
68854: PUSH
68855: LD_INT 1
68857: PUSH
68858: EMPTY
68859: LIST
68860: LIST
68861: PUSH
68862: LD_INT 1
68864: NEG
68865: PUSH
68866: LD_INT 0
68868: PUSH
68869: EMPTY
68870: LIST
68871: LIST
68872: PUSH
68873: LD_INT 1
68875: NEG
68876: PUSH
68877: LD_INT 1
68879: NEG
68880: PUSH
68881: EMPTY
68882: LIST
68883: LIST
68884: PUSH
68885: LD_INT 1
68887: NEG
68888: PUSH
68889: LD_INT 2
68891: NEG
68892: PUSH
68893: EMPTY
68894: LIST
68895: LIST
68896: PUSH
68897: LD_INT 0
68899: PUSH
68900: LD_INT 2
68902: NEG
68903: PUSH
68904: EMPTY
68905: LIST
68906: LIST
68907: PUSH
68908: LD_INT 1
68910: PUSH
68911: LD_INT 1
68913: NEG
68914: PUSH
68915: EMPTY
68916: LIST
68917: LIST
68918: PUSH
68919: LD_INT 2
68921: PUSH
68922: LD_INT 0
68924: PUSH
68925: EMPTY
68926: LIST
68927: LIST
68928: PUSH
68929: LD_INT 2
68931: PUSH
68932: LD_INT 1
68934: PUSH
68935: EMPTY
68936: LIST
68937: LIST
68938: PUSH
68939: LD_INT 2
68941: PUSH
68942: LD_INT 2
68944: PUSH
68945: EMPTY
68946: LIST
68947: LIST
68948: PUSH
68949: LD_INT 1
68951: PUSH
68952: LD_INT 2
68954: PUSH
68955: EMPTY
68956: LIST
68957: LIST
68958: PUSH
68959: LD_INT 0
68961: PUSH
68962: LD_INT 2
68964: PUSH
68965: EMPTY
68966: LIST
68967: LIST
68968: PUSH
68969: LD_INT 1
68971: NEG
68972: PUSH
68973: LD_INT 1
68975: PUSH
68976: EMPTY
68977: LIST
68978: LIST
68979: PUSH
68980: LD_INT 2
68982: NEG
68983: PUSH
68984: LD_INT 0
68986: PUSH
68987: EMPTY
68988: LIST
68989: LIST
68990: PUSH
68991: LD_INT 2
68993: NEG
68994: PUSH
68995: LD_INT 1
68997: NEG
68998: PUSH
68999: EMPTY
69000: LIST
69001: LIST
69002: PUSH
69003: LD_INT 2
69005: NEG
69006: PUSH
69007: LD_INT 2
69009: NEG
69010: PUSH
69011: EMPTY
69012: LIST
69013: LIST
69014: PUSH
69015: EMPTY
69016: LIST
69017: LIST
69018: LIST
69019: LIST
69020: LIST
69021: LIST
69022: LIST
69023: LIST
69024: LIST
69025: LIST
69026: LIST
69027: LIST
69028: LIST
69029: LIST
69030: LIST
69031: LIST
69032: LIST
69033: LIST
69034: LIST
69035: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
69036: LD_ADDR_VAR 0 23
69040: PUSH
69041: LD_INT 0
69043: PUSH
69044: LD_INT 0
69046: PUSH
69047: EMPTY
69048: LIST
69049: LIST
69050: PUSH
69051: LD_INT 0
69053: PUSH
69054: LD_INT 1
69056: NEG
69057: PUSH
69058: EMPTY
69059: LIST
69060: LIST
69061: PUSH
69062: LD_INT 1
69064: PUSH
69065: LD_INT 0
69067: PUSH
69068: EMPTY
69069: LIST
69070: LIST
69071: PUSH
69072: LD_INT 1
69074: PUSH
69075: LD_INT 1
69077: PUSH
69078: EMPTY
69079: LIST
69080: LIST
69081: PUSH
69082: LD_INT 0
69084: PUSH
69085: LD_INT 1
69087: PUSH
69088: EMPTY
69089: LIST
69090: LIST
69091: PUSH
69092: LD_INT 1
69094: NEG
69095: PUSH
69096: LD_INT 0
69098: PUSH
69099: EMPTY
69100: LIST
69101: LIST
69102: PUSH
69103: LD_INT 1
69105: NEG
69106: PUSH
69107: LD_INT 1
69109: NEG
69110: PUSH
69111: EMPTY
69112: LIST
69113: LIST
69114: PUSH
69115: LD_INT 1
69117: NEG
69118: PUSH
69119: LD_INT 2
69121: NEG
69122: PUSH
69123: EMPTY
69124: LIST
69125: LIST
69126: PUSH
69127: LD_INT 0
69129: PUSH
69130: LD_INT 2
69132: NEG
69133: PUSH
69134: EMPTY
69135: LIST
69136: LIST
69137: PUSH
69138: LD_INT 1
69140: PUSH
69141: LD_INT 1
69143: NEG
69144: PUSH
69145: EMPTY
69146: LIST
69147: LIST
69148: PUSH
69149: LD_INT 2
69151: PUSH
69152: LD_INT 0
69154: PUSH
69155: EMPTY
69156: LIST
69157: LIST
69158: PUSH
69159: LD_INT 2
69161: PUSH
69162: LD_INT 1
69164: PUSH
69165: EMPTY
69166: LIST
69167: LIST
69168: PUSH
69169: LD_INT 2
69171: PUSH
69172: LD_INT 2
69174: PUSH
69175: EMPTY
69176: LIST
69177: LIST
69178: PUSH
69179: LD_INT 1
69181: PUSH
69182: LD_INT 2
69184: PUSH
69185: EMPTY
69186: LIST
69187: LIST
69188: PUSH
69189: LD_INT 0
69191: PUSH
69192: LD_INT 2
69194: PUSH
69195: EMPTY
69196: LIST
69197: LIST
69198: PUSH
69199: LD_INT 1
69201: NEG
69202: PUSH
69203: LD_INT 1
69205: PUSH
69206: EMPTY
69207: LIST
69208: LIST
69209: PUSH
69210: LD_INT 2
69212: NEG
69213: PUSH
69214: LD_INT 0
69216: PUSH
69217: EMPTY
69218: LIST
69219: LIST
69220: PUSH
69221: LD_INT 2
69223: NEG
69224: PUSH
69225: LD_INT 1
69227: NEG
69228: PUSH
69229: EMPTY
69230: LIST
69231: LIST
69232: PUSH
69233: LD_INT 2
69235: NEG
69236: PUSH
69237: LD_INT 2
69239: NEG
69240: PUSH
69241: EMPTY
69242: LIST
69243: LIST
69244: PUSH
69245: LD_INT 2
69247: NEG
69248: PUSH
69249: LD_INT 3
69251: NEG
69252: PUSH
69253: EMPTY
69254: LIST
69255: LIST
69256: PUSH
69257: LD_INT 1
69259: NEG
69260: PUSH
69261: LD_INT 3
69263: NEG
69264: PUSH
69265: EMPTY
69266: LIST
69267: LIST
69268: PUSH
69269: LD_INT 1
69271: PUSH
69272: LD_INT 2
69274: NEG
69275: PUSH
69276: EMPTY
69277: LIST
69278: LIST
69279: PUSH
69280: LD_INT 2
69282: PUSH
69283: LD_INT 1
69285: NEG
69286: PUSH
69287: EMPTY
69288: LIST
69289: LIST
69290: PUSH
69291: EMPTY
69292: LIST
69293: LIST
69294: LIST
69295: LIST
69296: LIST
69297: LIST
69298: LIST
69299: LIST
69300: LIST
69301: LIST
69302: LIST
69303: LIST
69304: LIST
69305: LIST
69306: LIST
69307: LIST
69308: LIST
69309: LIST
69310: LIST
69311: LIST
69312: LIST
69313: LIST
69314: LIST
69315: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
69316: LD_ADDR_VAR 0 24
69320: PUSH
69321: LD_INT 0
69323: PUSH
69324: LD_INT 0
69326: PUSH
69327: EMPTY
69328: LIST
69329: LIST
69330: PUSH
69331: LD_INT 0
69333: PUSH
69334: LD_INT 1
69336: NEG
69337: PUSH
69338: EMPTY
69339: LIST
69340: LIST
69341: PUSH
69342: LD_INT 1
69344: PUSH
69345: LD_INT 0
69347: PUSH
69348: EMPTY
69349: LIST
69350: LIST
69351: PUSH
69352: LD_INT 1
69354: PUSH
69355: LD_INT 1
69357: PUSH
69358: EMPTY
69359: LIST
69360: LIST
69361: PUSH
69362: LD_INT 0
69364: PUSH
69365: LD_INT 1
69367: PUSH
69368: EMPTY
69369: LIST
69370: LIST
69371: PUSH
69372: LD_INT 1
69374: NEG
69375: PUSH
69376: LD_INT 0
69378: PUSH
69379: EMPTY
69380: LIST
69381: LIST
69382: PUSH
69383: LD_INT 1
69385: NEG
69386: PUSH
69387: LD_INT 1
69389: NEG
69390: PUSH
69391: EMPTY
69392: LIST
69393: LIST
69394: PUSH
69395: LD_INT 1
69397: NEG
69398: PUSH
69399: LD_INT 2
69401: NEG
69402: PUSH
69403: EMPTY
69404: LIST
69405: LIST
69406: PUSH
69407: LD_INT 0
69409: PUSH
69410: LD_INT 2
69412: NEG
69413: PUSH
69414: EMPTY
69415: LIST
69416: LIST
69417: PUSH
69418: LD_INT 1
69420: PUSH
69421: LD_INT 1
69423: NEG
69424: PUSH
69425: EMPTY
69426: LIST
69427: LIST
69428: PUSH
69429: LD_INT 2
69431: PUSH
69432: LD_INT 0
69434: PUSH
69435: EMPTY
69436: LIST
69437: LIST
69438: PUSH
69439: LD_INT 2
69441: PUSH
69442: LD_INT 1
69444: PUSH
69445: EMPTY
69446: LIST
69447: LIST
69448: PUSH
69449: LD_INT 2
69451: PUSH
69452: LD_INT 2
69454: PUSH
69455: EMPTY
69456: LIST
69457: LIST
69458: PUSH
69459: LD_INT 1
69461: PUSH
69462: LD_INT 2
69464: PUSH
69465: EMPTY
69466: LIST
69467: LIST
69468: PUSH
69469: LD_INT 0
69471: PUSH
69472: LD_INT 2
69474: PUSH
69475: EMPTY
69476: LIST
69477: LIST
69478: PUSH
69479: LD_INT 1
69481: NEG
69482: PUSH
69483: LD_INT 1
69485: PUSH
69486: EMPTY
69487: LIST
69488: LIST
69489: PUSH
69490: LD_INT 2
69492: NEG
69493: PUSH
69494: LD_INT 0
69496: PUSH
69497: EMPTY
69498: LIST
69499: LIST
69500: PUSH
69501: LD_INT 2
69503: NEG
69504: PUSH
69505: LD_INT 1
69507: NEG
69508: PUSH
69509: EMPTY
69510: LIST
69511: LIST
69512: PUSH
69513: LD_INT 2
69515: NEG
69516: PUSH
69517: LD_INT 2
69519: NEG
69520: PUSH
69521: EMPTY
69522: LIST
69523: LIST
69524: PUSH
69525: LD_INT 1
69527: PUSH
69528: LD_INT 2
69530: NEG
69531: PUSH
69532: EMPTY
69533: LIST
69534: LIST
69535: PUSH
69536: LD_INT 2
69538: PUSH
69539: LD_INT 1
69541: NEG
69542: PUSH
69543: EMPTY
69544: LIST
69545: LIST
69546: PUSH
69547: LD_INT 3
69549: PUSH
69550: LD_INT 1
69552: PUSH
69553: EMPTY
69554: LIST
69555: LIST
69556: PUSH
69557: LD_INT 3
69559: PUSH
69560: LD_INT 2
69562: PUSH
69563: EMPTY
69564: LIST
69565: LIST
69566: PUSH
69567: EMPTY
69568: LIST
69569: LIST
69570: LIST
69571: LIST
69572: LIST
69573: LIST
69574: LIST
69575: LIST
69576: LIST
69577: LIST
69578: LIST
69579: LIST
69580: LIST
69581: LIST
69582: LIST
69583: LIST
69584: LIST
69585: LIST
69586: LIST
69587: LIST
69588: LIST
69589: LIST
69590: LIST
69591: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
69592: LD_ADDR_VAR 0 25
69596: PUSH
69597: LD_INT 0
69599: PUSH
69600: LD_INT 0
69602: PUSH
69603: EMPTY
69604: LIST
69605: LIST
69606: PUSH
69607: LD_INT 0
69609: PUSH
69610: LD_INT 1
69612: NEG
69613: PUSH
69614: EMPTY
69615: LIST
69616: LIST
69617: PUSH
69618: LD_INT 1
69620: PUSH
69621: LD_INT 0
69623: PUSH
69624: EMPTY
69625: LIST
69626: LIST
69627: PUSH
69628: LD_INT 1
69630: PUSH
69631: LD_INT 1
69633: PUSH
69634: EMPTY
69635: LIST
69636: LIST
69637: PUSH
69638: LD_INT 0
69640: PUSH
69641: LD_INT 1
69643: PUSH
69644: EMPTY
69645: LIST
69646: LIST
69647: PUSH
69648: LD_INT 1
69650: NEG
69651: PUSH
69652: LD_INT 0
69654: PUSH
69655: EMPTY
69656: LIST
69657: LIST
69658: PUSH
69659: LD_INT 1
69661: NEG
69662: PUSH
69663: LD_INT 1
69665: NEG
69666: PUSH
69667: EMPTY
69668: LIST
69669: LIST
69670: PUSH
69671: LD_INT 1
69673: NEG
69674: PUSH
69675: LD_INT 2
69677: NEG
69678: PUSH
69679: EMPTY
69680: LIST
69681: LIST
69682: PUSH
69683: LD_INT 0
69685: PUSH
69686: LD_INT 2
69688: NEG
69689: PUSH
69690: EMPTY
69691: LIST
69692: LIST
69693: PUSH
69694: LD_INT 1
69696: PUSH
69697: LD_INT 1
69699: NEG
69700: PUSH
69701: EMPTY
69702: LIST
69703: LIST
69704: PUSH
69705: LD_INT 2
69707: PUSH
69708: LD_INT 0
69710: PUSH
69711: EMPTY
69712: LIST
69713: LIST
69714: PUSH
69715: LD_INT 2
69717: PUSH
69718: LD_INT 1
69720: PUSH
69721: EMPTY
69722: LIST
69723: LIST
69724: PUSH
69725: LD_INT 2
69727: PUSH
69728: LD_INT 2
69730: PUSH
69731: EMPTY
69732: LIST
69733: LIST
69734: PUSH
69735: LD_INT 1
69737: PUSH
69738: LD_INT 2
69740: PUSH
69741: EMPTY
69742: LIST
69743: LIST
69744: PUSH
69745: LD_INT 0
69747: PUSH
69748: LD_INT 2
69750: PUSH
69751: EMPTY
69752: LIST
69753: LIST
69754: PUSH
69755: LD_INT 1
69757: NEG
69758: PUSH
69759: LD_INT 1
69761: PUSH
69762: EMPTY
69763: LIST
69764: LIST
69765: PUSH
69766: LD_INT 2
69768: NEG
69769: PUSH
69770: LD_INT 0
69772: PUSH
69773: EMPTY
69774: LIST
69775: LIST
69776: PUSH
69777: LD_INT 2
69779: NEG
69780: PUSH
69781: LD_INT 1
69783: NEG
69784: PUSH
69785: EMPTY
69786: LIST
69787: LIST
69788: PUSH
69789: LD_INT 2
69791: NEG
69792: PUSH
69793: LD_INT 2
69795: NEG
69796: PUSH
69797: EMPTY
69798: LIST
69799: LIST
69800: PUSH
69801: LD_INT 3
69803: PUSH
69804: LD_INT 1
69806: PUSH
69807: EMPTY
69808: LIST
69809: LIST
69810: PUSH
69811: LD_INT 3
69813: PUSH
69814: LD_INT 2
69816: PUSH
69817: EMPTY
69818: LIST
69819: LIST
69820: PUSH
69821: LD_INT 2
69823: PUSH
69824: LD_INT 3
69826: PUSH
69827: EMPTY
69828: LIST
69829: LIST
69830: PUSH
69831: LD_INT 1
69833: PUSH
69834: LD_INT 3
69836: PUSH
69837: EMPTY
69838: LIST
69839: LIST
69840: PUSH
69841: EMPTY
69842: LIST
69843: LIST
69844: LIST
69845: LIST
69846: LIST
69847: LIST
69848: LIST
69849: LIST
69850: LIST
69851: LIST
69852: LIST
69853: LIST
69854: LIST
69855: LIST
69856: LIST
69857: LIST
69858: LIST
69859: LIST
69860: LIST
69861: LIST
69862: LIST
69863: LIST
69864: LIST
69865: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
69866: LD_ADDR_VAR 0 26
69870: PUSH
69871: LD_INT 0
69873: PUSH
69874: LD_INT 0
69876: PUSH
69877: EMPTY
69878: LIST
69879: LIST
69880: PUSH
69881: LD_INT 0
69883: PUSH
69884: LD_INT 1
69886: NEG
69887: PUSH
69888: EMPTY
69889: LIST
69890: LIST
69891: PUSH
69892: LD_INT 1
69894: PUSH
69895: LD_INT 0
69897: PUSH
69898: EMPTY
69899: LIST
69900: LIST
69901: PUSH
69902: LD_INT 1
69904: PUSH
69905: LD_INT 1
69907: PUSH
69908: EMPTY
69909: LIST
69910: LIST
69911: PUSH
69912: LD_INT 0
69914: PUSH
69915: LD_INT 1
69917: PUSH
69918: EMPTY
69919: LIST
69920: LIST
69921: PUSH
69922: LD_INT 1
69924: NEG
69925: PUSH
69926: LD_INT 0
69928: PUSH
69929: EMPTY
69930: LIST
69931: LIST
69932: PUSH
69933: LD_INT 1
69935: NEG
69936: PUSH
69937: LD_INT 1
69939: NEG
69940: PUSH
69941: EMPTY
69942: LIST
69943: LIST
69944: PUSH
69945: LD_INT 1
69947: NEG
69948: PUSH
69949: LD_INT 2
69951: NEG
69952: PUSH
69953: EMPTY
69954: LIST
69955: LIST
69956: PUSH
69957: LD_INT 0
69959: PUSH
69960: LD_INT 2
69962: NEG
69963: PUSH
69964: EMPTY
69965: LIST
69966: LIST
69967: PUSH
69968: LD_INT 1
69970: PUSH
69971: LD_INT 1
69973: NEG
69974: PUSH
69975: EMPTY
69976: LIST
69977: LIST
69978: PUSH
69979: LD_INT 2
69981: PUSH
69982: LD_INT 0
69984: PUSH
69985: EMPTY
69986: LIST
69987: LIST
69988: PUSH
69989: LD_INT 2
69991: PUSH
69992: LD_INT 1
69994: PUSH
69995: EMPTY
69996: LIST
69997: LIST
69998: PUSH
69999: LD_INT 2
70001: PUSH
70002: LD_INT 2
70004: PUSH
70005: EMPTY
70006: LIST
70007: LIST
70008: PUSH
70009: LD_INT 1
70011: PUSH
70012: LD_INT 2
70014: PUSH
70015: EMPTY
70016: LIST
70017: LIST
70018: PUSH
70019: LD_INT 0
70021: PUSH
70022: LD_INT 2
70024: PUSH
70025: EMPTY
70026: LIST
70027: LIST
70028: PUSH
70029: LD_INT 1
70031: NEG
70032: PUSH
70033: LD_INT 1
70035: PUSH
70036: EMPTY
70037: LIST
70038: LIST
70039: PUSH
70040: LD_INT 2
70042: NEG
70043: PUSH
70044: LD_INT 0
70046: PUSH
70047: EMPTY
70048: LIST
70049: LIST
70050: PUSH
70051: LD_INT 2
70053: NEG
70054: PUSH
70055: LD_INT 1
70057: NEG
70058: PUSH
70059: EMPTY
70060: LIST
70061: LIST
70062: PUSH
70063: LD_INT 2
70065: NEG
70066: PUSH
70067: LD_INT 2
70069: NEG
70070: PUSH
70071: EMPTY
70072: LIST
70073: LIST
70074: PUSH
70075: LD_INT 2
70077: PUSH
70078: LD_INT 3
70080: PUSH
70081: EMPTY
70082: LIST
70083: LIST
70084: PUSH
70085: LD_INT 1
70087: PUSH
70088: LD_INT 3
70090: PUSH
70091: EMPTY
70092: LIST
70093: LIST
70094: PUSH
70095: LD_INT 1
70097: NEG
70098: PUSH
70099: LD_INT 2
70101: PUSH
70102: EMPTY
70103: LIST
70104: LIST
70105: PUSH
70106: LD_INT 2
70108: NEG
70109: PUSH
70110: LD_INT 1
70112: PUSH
70113: EMPTY
70114: LIST
70115: LIST
70116: PUSH
70117: EMPTY
70118: LIST
70119: LIST
70120: LIST
70121: LIST
70122: LIST
70123: LIST
70124: LIST
70125: LIST
70126: LIST
70127: LIST
70128: LIST
70129: LIST
70130: LIST
70131: LIST
70132: LIST
70133: LIST
70134: LIST
70135: LIST
70136: LIST
70137: LIST
70138: LIST
70139: LIST
70140: LIST
70141: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
70142: LD_ADDR_VAR 0 27
70146: PUSH
70147: LD_INT 0
70149: PUSH
70150: LD_INT 0
70152: PUSH
70153: EMPTY
70154: LIST
70155: LIST
70156: PUSH
70157: LD_INT 0
70159: PUSH
70160: LD_INT 1
70162: NEG
70163: PUSH
70164: EMPTY
70165: LIST
70166: LIST
70167: PUSH
70168: LD_INT 1
70170: PUSH
70171: LD_INT 0
70173: PUSH
70174: EMPTY
70175: LIST
70176: LIST
70177: PUSH
70178: LD_INT 1
70180: PUSH
70181: LD_INT 1
70183: PUSH
70184: EMPTY
70185: LIST
70186: LIST
70187: PUSH
70188: LD_INT 0
70190: PUSH
70191: LD_INT 1
70193: PUSH
70194: EMPTY
70195: LIST
70196: LIST
70197: PUSH
70198: LD_INT 1
70200: NEG
70201: PUSH
70202: LD_INT 0
70204: PUSH
70205: EMPTY
70206: LIST
70207: LIST
70208: PUSH
70209: LD_INT 1
70211: NEG
70212: PUSH
70213: LD_INT 1
70215: NEG
70216: PUSH
70217: EMPTY
70218: LIST
70219: LIST
70220: PUSH
70221: LD_INT 1
70223: NEG
70224: PUSH
70225: LD_INT 2
70227: NEG
70228: PUSH
70229: EMPTY
70230: LIST
70231: LIST
70232: PUSH
70233: LD_INT 0
70235: PUSH
70236: LD_INT 2
70238: NEG
70239: PUSH
70240: EMPTY
70241: LIST
70242: LIST
70243: PUSH
70244: LD_INT 1
70246: PUSH
70247: LD_INT 1
70249: NEG
70250: PUSH
70251: EMPTY
70252: LIST
70253: LIST
70254: PUSH
70255: LD_INT 2
70257: PUSH
70258: LD_INT 0
70260: PUSH
70261: EMPTY
70262: LIST
70263: LIST
70264: PUSH
70265: LD_INT 2
70267: PUSH
70268: LD_INT 1
70270: PUSH
70271: EMPTY
70272: LIST
70273: LIST
70274: PUSH
70275: LD_INT 2
70277: PUSH
70278: LD_INT 2
70280: PUSH
70281: EMPTY
70282: LIST
70283: LIST
70284: PUSH
70285: LD_INT 1
70287: PUSH
70288: LD_INT 2
70290: PUSH
70291: EMPTY
70292: LIST
70293: LIST
70294: PUSH
70295: LD_INT 0
70297: PUSH
70298: LD_INT 2
70300: PUSH
70301: EMPTY
70302: LIST
70303: LIST
70304: PUSH
70305: LD_INT 1
70307: NEG
70308: PUSH
70309: LD_INT 1
70311: PUSH
70312: EMPTY
70313: LIST
70314: LIST
70315: PUSH
70316: LD_INT 2
70318: NEG
70319: PUSH
70320: LD_INT 0
70322: PUSH
70323: EMPTY
70324: LIST
70325: LIST
70326: PUSH
70327: LD_INT 2
70329: NEG
70330: PUSH
70331: LD_INT 1
70333: NEG
70334: PUSH
70335: EMPTY
70336: LIST
70337: LIST
70338: PUSH
70339: LD_INT 2
70341: NEG
70342: PUSH
70343: LD_INT 2
70345: NEG
70346: PUSH
70347: EMPTY
70348: LIST
70349: LIST
70350: PUSH
70351: LD_INT 1
70353: NEG
70354: PUSH
70355: LD_INT 2
70357: PUSH
70358: EMPTY
70359: LIST
70360: LIST
70361: PUSH
70362: LD_INT 2
70364: NEG
70365: PUSH
70366: LD_INT 1
70368: PUSH
70369: EMPTY
70370: LIST
70371: LIST
70372: PUSH
70373: LD_INT 3
70375: NEG
70376: PUSH
70377: LD_INT 1
70379: NEG
70380: PUSH
70381: EMPTY
70382: LIST
70383: LIST
70384: PUSH
70385: LD_INT 3
70387: NEG
70388: PUSH
70389: LD_INT 2
70391: NEG
70392: PUSH
70393: EMPTY
70394: LIST
70395: LIST
70396: PUSH
70397: EMPTY
70398: LIST
70399: LIST
70400: LIST
70401: LIST
70402: LIST
70403: LIST
70404: LIST
70405: LIST
70406: LIST
70407: LIST
70408: LIST
70409: LIST
70410: LIST
70411: LIST
70412: LIST
70413: LIST
70414: LIST
70415: LIST
70416: LIST
70417: LIST
70418: LIST
70419: LIST
70420: LIST
70421: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
70422: LD_ADDR_VAR 0 28
70426: PUSH
70427: LD_INT 0
70429: PUSH
70430: LD_INT 0
70432: PUSH
70433: EMPTY
70434: LIST
70435: LIST
70436: PUSH
70437: LD_INT 0
70439: PUSH
70440: LD_INT 1
70442: NEG
70443: PUSH
70444: EMPTY
70445: LIST
70446: LIST
70447: PUSH
70448: LD_INT 1
70450: PUSH
70451: LD_INT 0
70453: PUSH
70454: EMPTY
70455: LIST
70456: LIST
70457: PUSH
70458: LD_INT 1
70460: PUSH
70461: LD_INT 1
70463: PUSH
70464: EMPTY
70465: LIST
70466: LIST
70467: PUSH
70468: LD_INT 0
70470: PUSH
70471: LD_INT 1
70473: PUSH
70474: EMPTY
70475: LIST
70476: LIST
70477: PUSH
70478: LD_INT 1
70480: NEG
70481: PUSH
70482: LD_INT 0
70484: PUSH
70485: EMPTY
70486: LIST
70487: LIST
70488: PUSH
70489: LD_INT 1
70491: NEG
70492: PUSH
70493: LD_INT 1
70495: NEG
70496: PUSH
70497: EMPTY
70498: LIST
70499: LIST
70500: PUSH
70501: LD_INT 1
70503: NEG
70504: PUSH
70505: LD_INT 2
70507: NEG
70508: PUSH
70509: EMPTY
70510: LIST
70511: LIST
70512: PUSH
70513: LD_INT 0
70515: PUSH
70516: LD_INT 2
70518: NEG
70519: PUSH
70520: EMPTY
70521: LIST
70522: LIST
70523: PUSH
70524: LD_INT 1
70526: PUSH
70527: LD_INT 1
70529: NEG
70530: PUSH
70531: EMPTY
70532: LIST
70533: LIST
70534: PUSH
70535: LD_INT 2
70537: PUSH
70538: LD_INT 0
70540: PUSH
70541: EMPTY
70542: LIST
70543: LIST
70544: PUSH
70545: LD_INT 2
70547: PUSH
70548: LD_INT 1
70550: PUSH
70551: EMPTY
70552: LIST
70553: LIST
70554: PUSH
70555: LD_INT 2
70557: PUSH
70558: LD_INT 2
70560: PUSH
70561: EMPTY
70562: LIST
70563: LIST
70564: PUSH
70565: LD_INT 1
70567: PUSH
70568: LD_INT 2
70570: PUSH
70571: EMPTY
70572: LIST
70573: LIST
70574: PUSH
70575: LD_INT 0
70577: PUSH
70578: LD_INT 2
70580: PUSH
70581: EMPTY
70582: LIST
70583: LIST
70584: PUSH
70585: LD_INT 1
70587: NEG
70588: PUSH
70589: LD_INT 1
70591: PUSH
70592: EMPTY
70593: LIST
70594: LIST
70595: PUSH
70596: LD_INT 2
70598: NEG
70599: PUSH
70600: LD_INT 0
70602: PUSH
70603: EMPTY
70604: LIST
70605: LIST
70606: PUSH
70607: LD_INT 2
70609: NEG
70610: PUSH
70611: LD_INT 1
70613: NEG
70614: PUSH
70615: EMPTY
70616: LIST
70617: LIST
70618: PUSH
70619: LD_INT 2
70621: NEG
70622: PUSH
70623: LD_INT 2
70625: NEG
70626: PUSH
70627: EMPTY
70628: LIST
70629: LIST
70630: PUSH
70631: LD_INT 2
70633: NEG
70634: PUSH
70635: LD_INT 3
70637: NEG
70638: PUSH
70639: EMPTY
70640: LIST
70641: LIST
70642: PUSH
70643: LD_INT 1
70645: NEG
70646: PUSH
70647: LD_INT 3
70649: NEG
70650: PUSH
70651: EMPTY
70652: LIST
70653: LIST
70654: PUSH
70655: LD_INT 3
70657: NEG
70658: PUSH
70659: LD_INT 1
70661: NEG
70662: PUSH
70663: EMPTY
70664: LIST
70665: LIST
70666: PUSH
70667: LD_INT 3
70669: NEG
70670: PUSH
70671: LD_INT 2
70673: NEG
70674: PUSH
70675: EMPTY
70676: LIST
70677: LIST
70678: PUSH
70679: EMPTY
70680: LIST
70681: LIST
70682: LIST
70683: LIST
70684: LIST
70685: LIST
70686: LIST
70687: LIST
70688: LIST
70689: LIST
70690: LIST
70691: LIST
70692: LIST
70693: LIST
70694: LIST
70695: LIST
70696: LIST
70697: LIST
70698: LIST
70699: LIST
70700: LIST
70701: LIST
70702: LIST
70703: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70704: LD_ADDR_VAR 0 29
70708: PUSH
70709: LD_INT 0
70711: PUSH
70712: LD_INT 0
70714: PUSH
70715: EMPTY
70716: LIST
70717: LIST
70718: PUSH
70719: LD_INT 0
70721: PUSH
70722: LD_INT 1
70724: NEG
70725: PUSH
70726: EMPTY
70727: LIST
70728: LIST
70729: PUSH
70730: LD_INT 1
70732: PUSH
70733: LD_INT 0
70735: PUSH
70736: EMPTY
70737: LIST
70738: LIST
70739: PUSH
70740: LD_INT 1
70742: PUSH
70743: LD_INT 1
70745: PUSH
70746: EMPTY
70747: LIST
70748: LIST
70749: PUSH
70750: LD_INT 0
70752: PUSH
70753: LD_INT 1
70755: PUSH
70756: EMPTY
70757: LIST
70758: LIST
70759: PUSH
70760: LD_INT 1
70762: NEG
70763: PUSH
70764: LD_INT 0
70766: PUSH
70767: EMPTY
70768: LIST
70769: LIST
70770: PUSH
70771: LD_INT 1
70773: NEG
70774: PUSH
70775: LD_INT 1
70777: NEG
70778: PUSH
70779: EMPTY
70780: LIST
70781: LIST
70782: PUSH
70783: LD_INT 1
70785: NEG
70786: PUSH
70787: LD_INT 2
70789: NEG
70790: PUSH
70791: EMPTY
70792: LIST
70793: LIST
70794: PUSH
70795: LD_INT 0
70797: PUSH
70798: LD_INT 2
70800: NEG
70801: PUSH
70802: EMPTY
70803: LIST
70804: LIST
70805: PUSH
70806: LD_INT 1
70808: PUSH
70809: LD_INT 1
70811: NEG
70812: PUSH
70813: EMPTY
70814: LIST
70815: LIST
70816: PUSH
70817: LD_INT 2
70819: PUSH
70820: LD_INT 0
70822: PUSH
70823: EMPTY
70824: LIST
70825: LIST
70826: PUSH
70827: LD_INT 2
70829: PUSH
70830: LD_INT 1
70832: PUSH
70833: EMPTY
70834: LIST
70835: LIST
70836: PUSH
70837: LD_INT 1
70839: PUSH
70840: LD_INT 2
70842: PUSH
70843: EMPTY
70844: LIST
70845: LIST
70846: PUSH
70847: LD_INT 0
70849: PUSH
70850: LD_INT 2
70852: PUSH
70853: EMPTY
70854: LIST
70855: LIST
70856: PUSH
70857: LD_INT 1
70859: NEG
70860: PUSH
70861: LD_INT 1
70863: PUSH
70864: EMPTY
70865: LIST
70866: LIST
70867: PUSH
70868: LD_INT 2
70870: NEG
70871: PUSH
70872: LD_INT 1
70874: NEG
70875: PUSH
70876: EMPTY
70877: LIST
70878: LIST
70879: PUSH
70880: LD_INT 2
70882: NEG
70883: PUSH
70884: LD_INT 2
70886: NEG
70887: PUSH
70888: EMPTY
70889: LIST
70890: LIST
70891: PUSH
70892: LD_INT 2
70894: NEG
70895: PUSH
70896: LD_INT 3
70898: NEG
70899: PUSH
70900: EMPTY
70901: LIST
70902: LIST
70903: PUSH
70904: LD_INT 2
70906: PUSH
70907: LD_INT 1
70909: NEG
70910: PUSH
70911: EMPTY
70912: LIST
70913: LIST
70914: PUSH
70915: LD_INT 3
70917: PUSH
70918: LD_INT 1
70920: PUSH
70921: EMPTY
70922: LIST
70923: LIST
70924: PUSH
70925: LD_INT 1
70927: PUSH
70928: LD_INT 3
70930: PUSH
70931: EMPTY
70932: LIST
70933: LIST
70934: PUSH
70935: LD_INT 1
70937: NEG
70938: PUSH
70939: LD_INT 2
70941: PUSH
70942: EMPTY
70943: LIST
70944: LIST
70945: PUSH
70946: LD_INT 3
70948: NEG
70949: PUSH
70950: LD_INT 2
70952: NEG
70953: PUSH
70954: EMPTY
70955: LIST
70956: LIST
70957: PUSH
70958: EMPTY
70959: LIST
70960: LIST
70961: LIST
70962: LIST
70963: LIST
70964: LIST
70965: LIST
70966: LIST
70967: LIST
70968: LIST
70969: LIST
70970: LIST
70971: LIST
70972: LIST
70973: LIST
70974: LIST
70975: LIST
70976: LIST
70977: LIST
70978: LIST
70979: LIST
70980: LIST
70981: LIST
70982: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70983: LD_ADDR_VAR 0 30
70987: PUSH
70988: LD_INT 0
70990: PUSH
70991: LD_INT 0
70993: PUSH
70994: EMPTY
70995: LIST
70996: LIST
70997: PUSH
70998: LD_INT 0
71000: PUSH
71001: LD_INT 1
71003: NEG
71004: PUSH
71005: EMPTY
71006: LIST
71007: LIST
71008: PUSH
71009: LD_INT 1
71011: PUSH
71012: LD_INT 0
71014: PUSH
71015: EMPTY
71016: LIST
71017: LIST
71018: PUSH
71019: LD_INT 1
71021: PUSH
71022: LD_INT 1
71024: PUSH
71025: EMPTY
71026: LIST
71027: LIST
71028: PUSH
71029: LD_INT 0
71031: PUSH
71032: LD_INT 1
71034: PUSH
71035: EMPTY
71036: LIST
71037: LIST
71038: PUSH
71039: LD_INT 1
71041: NEG
71042: PUSH
71043: LD_INT 0
71045: PUSH
71046: EMPTY
71047: LIST
71048: LIST
71049: PUSH
71050: LD_INT 1
71052: NEG
71053: PUSH
71054: LD_INT 1
71056: NEG
71057: PUSH
71058: EMPTY
71059: LIST
71060: LIST
71061: PUSH
71062: LD_INT 1
71064: NEG
71065: PUSH
71066: LD_INT 2
71068: NEG
71069: PUSH
71070: EMPTY
71071: LIST
71072: LIST
71073: PUSH
71074: LD_INT 0
71076: PUSH
71077: LD_INT 2
71079: NEG
71080: PUSH
71081: EMPTY
71082: LIST
71083: LIST
71084: PUSH
71085: LD_INT 1
71087: PUSH
71088: LD_INT 1
71090: NEG
71091: PUSH
71092: EMPTY
71093: LIST
71094: LIST
71095: PUSH
71096: LD_INT 2
71098: PUSH
71099: LD_INT 0
71101: PUSH
71102: EMPTY
71103: LIST
71104: LIST
71105: PUSH
71106: LD_INT 2
71108: PUSH
71109: LD_INT 1
71111: PUSH
71112: EMPTY
71113: LIST
71114: LIST
71115: PUSH
71116: LD_INT 2
71118: PUSH
71119: LD_INT 2
71121: PUSH
71122: EMPTY
71123: LIST
71124: LIST
71125: PUSH
71126: LD_INT 1
71128: PUSH
71129: LD_INT 2
71131: PUSH
71132: EMPTY
71133: LIST
71134: LIST
71135: PUSH
71136: LD_INT 1
71138: NEG
71139: PUSH
71140: LD_INT 1
71142: PUSH
71143: EMPTY
71144: LIST
71145: LIST
71146: PUSH
71147: LD_INT 2
71149: NEG
71150: PUSH
71151: LD_INT 0
71153: PUSH
71154: EMPTY
71155: LIST
71156: LIST
71157: PUSH
71158: LD_INT 2
71160: NEG
71161: PUSH
71162: LD_INT 1
71164: NEG
71165: PUSH
71166: EMPTY
71167: LIST
71168: LIST
71169: PUSH
71170: LD_INT 1
71172: NEG
71173: PUSH
71174: LD_INT 3
71176: NEG
71177: PUSH
71178: EMPTY
71179: LIST
71180: LIST
71181: PUSH
71182: LD_INT 1
71184: PUSH
71185: LD_INT 2
71187: NEG
71188: PUSH
71189: EMPTY
71190: LIST
71191: LIST
71192: PUSH
71193: LD_INT 3
71195: PUSH
71196: LD_INT 2
71198: PUSH
71199: EMPTY
71200: LIST
71201: LIST
71202: PUSH
71203: LD_INT 2
71205: PUSH
71206: LD_INT 3
71208: PUSH
71209: EMPTY
71210: LIST
71211: LIST
71212: PUSH
71213: LD_INT 2
71215: NEG
71216: PUSH
71217: LD_INT 1
71219: PUSH
71220: EMPTY
71221: LIST
71222: LIST
71223: PUSH
71224: LD_INT 3
71226: NEG
71227: PUSH
71228: LD_INT 1
71230: NEG
71231: PUSH
71232: EMPTY
71233: LIST
71234: LIST
71235: PUSH
71236: EMPTY
71237: LIST
71238: LIST
71239: LIST
71240: LIST
71241: LIST
71242: LIST
71243: LIST
71244: LIST
71245: LIST
71246: LIST
71247: LIST
71248: LIST
71249: LIST
71250: LIST
71251: LIST
71252: LIST
71253: LIST
71254: LIST
71255: LIST
71256: LIST
71257: LIST
71258: LIST
71259: LIST
71260: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71261: LD_ADDR_VAR 0 31
71265: PUSH
71266: LD_INT 0
71268: PUSH
71269: LD_INT 0
71271: PUSH
71272: EMPTY
71273: LIST
71274: LIST
71275: PUSH
71276: LD_INT 0
71278: PUSH
71279: LD_INT 1
71281: NEG
71282: PUSH
71283: EMPTY
71284: LIST
71285: LIST
71286: PUSH
71287: LD_INT 1
71289: PUSH
71290: LD_INT 0
71292: PUSH
71293: EMPTY
71294: LIST
71295: LIST
71296: PUSH
71297: LD_INT 1
71299: PUSH
71300: LD_INT 1
71302: PUSH
71303: EMPTY
71304: LIST
71305: LIST
71306: PUSH
71307: LD_INT 0
71309: PUSH
71310: LD_INT 1
71312: PUSH
71313: EMPTY
71314: LIST
71315: LIST
71316: PUSH
71317: LD_INT 1
71319: NEG
71320: PUSH
71321: LD_INT 0
71323: PUSH
71324: EMPTY
71325: LIST
71326: LIST
71327: PUSH
71328: LD_INT 1
71330: NEG
71331: PUSH
71332: LD_INT 1
71334: NEG
71335: PUSH
71336: EMPTY
71337: LIST
71338: LIST
71339: PUSH
71340: LD_INT 1
71342: NEG
71343: PUSH
71344: LD_INT 2
71346: NEG
71347: PUSH
71348: EMPTY
71349: LIST
71350: LIST
71351: PUSH
71352: LD_INT 1
71354: PUSH
71355: LD_INT 1
71357: NEG
71358: PUSH
71359: EMPTY
71360: LIST
71361: LIST
71362: PUSH
71363: LD_INT 2
71365: PUSH
71366: LD_INT 0
71368: PUSH
71369: EMPTY
71370: LIST
71371: LIST
71372: PUSH
71373: LD_INT 2
71375: PUSH
71376: LD_INT 1
71378: PUSH
71379: EMPTY
71380: LIST
71381: LIST
71382: PUSH
71383: LD_INT 2
71385: PUSH
71386: LD_INT 2
71388: PUSH
71389: EMPTY
71390: LIST
71391: LIST
71392: PUSH
71393: LD_INT 1
71395: PUSH
71396: LD_INT 2
71398: PUSH
71399: EMPTY
71400: LIST
71401: LIST
71402: PUSH
71403: LD_INT 0
71405: PUSH
71406: LD_INT 2
71408: PUSH
71409: EMPTY
71410: LIST
71411: LIST
71412: PUSH
71413: LD_INT 1
71415: NEG
71416: PUSH
71417: LD_INT 1
71419: PUSH
71420: EMPTY
71421: LIST
71422: LIST
71423: PUSH
71424: LD_INT 2
71426: NEG
71427: PUSH
71428: LD_INT 1
71430: NEG
71431: PUSH
71432: EMPTY
71433: LIST
71434: LIST
71435: PUSH
71436: LD_INT 2
71438: NEG
71439: PUSH
71440: LD_INT 2
71442: NEG
71443: PUSH
71444: EMPTY
71445: LIST
71446: LIST
71447: PUSH
71448: LD_INT 2
71450: NEG
71451: PUSH
71452: LD_INT 3
71454: NEG
71455: PUSH
71456: EMPTY
71457: LIST
71458: LIST
71459: PUSH
71460: LD_INT 2
71462: PUSH
71463: LD_INT 1
71465: NEG
71466: PUSH
71467: EMPTY
71468: LIST
71469: LIST
71470: PUSH
71471: LD_INT 3
71473: PUSH
71474: LD_INT 1
71476: PUSH
71477: EMPTY
71478: LIST
71479: LIST
71480: PUSH
71481: LD_INT 1
71483: PUSH
71484: LD_INT 3
71486: PUSH
71487: EMPTY
71488: LIST
71489: LIST
71490: PUSH
71491: LD_INT 1
71493: NEG
71494: PUSH
71495: LD_INT 2
71497: PUSH
71498: EMPTY
71499: LIST
71500: LIST
71501: PUSH
71502: LD_INT 3
71504: NEG
71505: PUSH
71506: LD_INT 2
71508: NEG
71509: PUSH
71510: EMPTY
71511: LIST
71512: LIST
71513: PUSH
71514: EMPTY
71515: LIST
71516: LIST
71517: LIST
71518: LIST
71519: LIST
71520: LIST
71521: LIST
71522: LIST
71523: LIST
71524: LIST
71525: LIST
71526: LIST
71527: LIST
71528: LIST
71529: LIST
71530: LIST
71531: LIST
71532: LIST
71533: LIST
71534: LIST
71535: LIST
71536: LIST
71537: LIST
71538: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71539: LD_ADDR_VAR 0 32
71543: PUSH
71544: LD_INT 0
71546: PUSH
71547: LD_INT 0
71549: PUSH
71550: EMPTY
71551: LIST
71552: LIST
71553: PUSH
71554: LD_INT 0
71556: PUSH
71557: LD_INT 1
71559: NEG
71560: PUSH
71561: EMPTY
71562: LIST
71563: LIST
71564: PUSH
71565: LD_INT 1
71567: PUSH
71568: LD_INT 0
71570: PUSH
71571: EMPTY
71572: LIST
71573: LIST
71574: PUSH
71575: LD_INT 1
71577: PUSH
71578: LD_INT 1
71580: PUSH
71581: EMPTY
71582: LIST
71583: LIST
71584: PUSH
71585: LD_INT 0
71587: PUSH
71588: LD_INT 1
71590: PUSH
71591: EMPTY
71592: LIST
71593: LIST
71594: PUSH
71595: LD_INT 1
71597: NEG
71598: PUSH
71599: LD_INT 0
71601: PUSH
71602: EMPTY
71603: LIST
71604: LIST
71605: PUSH
71606: LD_INT 1
71608: NEG
71609: PUSH
71610: LD_INT 1
71612: NEG
71613: PUSH
71614: EMPTY
71615: LIST
71616: LIST
71617: PUSH
71618: LD_INT 1
71620: NEG
71621: PUSH
71622: LD_INT 2
71624: NEG
71625: PUSH
71626: EMPTY
71627: LIST
71628: LIST
71629: PUSH
71630: LD_INT 0
71632: PUSH
71633: LD_INT 2
71635: NEG
71636: PUSH
71637: EMPTY
71638: LIST
71639: LIST
71640: PUSH
71641: LD_INT 1
71643: PUSH
71644: LD_INT 1
71646: NEG
71647: PUSH
71648: EMPTY
71649: LIST
71650: LIST
71651: PUSH
71652: LD_INT 2
71654: PUSH
71655: LD_INT 1
71657: PUSH
71658: EMPTY
71659: LIST
71660: LIST
71661: PUSH
71662: LD_INT 2
71664: PUSH
71665: LD_INT 2
71667: PUSH
71668: EMPTY
71669: LIST
71670: LIST
71671: PUSH
71672: LD_INT 1
71674: PUSH
71675: LD_INT 2
71677: PUSH
71678: EMPTY
71679: LIST
71680: LIST
71681: PUSH
71682: LD_INT 0
71684: PUSH
71685: LD_INT 2
71687: PUSH
71688: EMPTY
71689: LIST
71690: LIST
71691: PUSH
71692: LD_INT 1
71694: NEG
71695: PUSH
71696: LD_INT 1
71698: PUSH
71699: EMPTY
71700: LIST
71701: LIST
71702: PUSH
71703: LD_INT 2
71705: NEG
71706: PUSH
71707: LD_INT 0
71709: PUSH
71710: EMPTY
71711: LIST
71712: LIST
71713: PUSH
71714: LD_INT 2
71716: NEG
71717: PUSH
71718: LD_INT 1
71720: NEG
71721: PUSH
71722: EMPTY
71723: LIST
71724: LIST
71725: PUSH
71726: LD_INT 1
71728: NEG
71729: PUSH
71730: LD_INT 3
71732: NEG
71733: PUSH
71734: EMPTY
71735: LIST
71736: LIST
71737: PUSH
71738: LD_INT 1
71740: PUSH
71741: LD_INT 2
71743: NEG
71744: PUSH
71745: EMPTY
71746: LIST
71747: LIST
71748: PUSH
71749: LD_INT 3
71751: PUSH
71752: LD_INT 2
71754: PUSH
71755: EMPTY
71756: LIST
71757: LIST
71758: PUSH
71759: LD_INT 2
71761: PUSH
71762: LD_INT 3
71764: PUSH
71765: EMPTY
71766: LIST
71767: LIST
71768: PUSH
71769: LD_INT 2
71771: NEG
71772: PUSH
71773: LD_INT 1
71775: PUSH
71776: EMPTY
71777: LIST
71778: LIST
71779: PUSH
71780: LD_INT 3
71782: NEG
71783: PUSH
71784: LD_INT 1
71786: NEG
71787: PUSH
71788: EMPTY
71789: LIST
71790: LIST
71791: PUSH
71792: EMPTY
71793: LIST
71794: LIST
71795: LIST
71796: LIST
71797: LIST
71798: LIST
71799: LIST
71800: LIST
71801: LIST
71802: LIST
71803: LIST
71804: LIST
71805: LIST
71806: LIST
71807: LIST
71808: LIST
71809: LIST
71810: LIST
71811: LIST
71812: LIST
71813: LIST
71814: LIST
71815: LIST
71816: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71817: LD_ADDR_VAR 0 33
71821: PUSH
71822: LD_INT 0
71824: PUSH
71825: LD_INT 0
71827: PUSH
71828: EMPTY
71829: LIST
71830: LIST
71831: PUSH
71832: LD_INT 0
71834: PUSH
71835: LD_INT 1
71837: NEG
71838: PUSH
71839: EMPTY
71840: LIST
71841: LIST
71842: PUSH
71843: LD_INT 1
71845: PUSH
71846: LD_INT 0
71848: PUSH
71849: EMPTY
71850: LIST
71851: LIST
71852: PUSH
71853: LD_INT 1
71855: PUSH
71856: LD_INT 1
71858: PUSH
71859: EMPTY
71860: LIST
71861: LIST
71862: PUSH
71863: LD_INT 0
71865: PUSH
71866: LD_INT 1
71868: PUSH
71869: EMPTY
71870: LIST
71871: LIST
71872: PUSH
71873: LD_INT 1
71875: NEG
71876: PUSH
71877: LD_INT 0
71879: PUSH
71880: EMPTY
71881: LIST
71882: LIST
71883: PUSH
71884: LD_INT 1
71886: NEG
71887: PUSH
71888: LD_INT 1
71890: NEG
71891: PUSH
71892: EMPTY
71893: LIST
71894: LIST
71895: PUSH
71896: LD_INT 1
71898: NEG
71899: PUSH
71900: LD_INT 2
71902: NEG
71903: PUSH
71904: EMPTY
71905: LIST
71906: LIST
71907: PUSH
71908: LD_INT 1
71910: PUSH
71911: LD_INT 1
71913: NEG
71914: PUSH
71915: EMPTY
71916: LIST
71917: LIST
71918: PUSH
71919: LD_INT 2
71921: PUSH
71922: LD_INT 0
71924: PUSH
71925: EMPTY
71926: LIST
71927: LIST
71928: PUSH
71929: LD_INT 2
71931: PUSH
71932: LD_INT 1
71934: PUSH
71935: EMPTY
71936: LIST
71937: LIST
71938: PUSH
71939: LD_INT 1
71941: PUSH
71942: LD_INT 2
71944: PUSH
71945: EMPTY
71946: LIST
71947: LIST
71948: PUSH
71949: LD_INT 0
71951: PUSH
71952: LD_INT 2
71954: PUSH
71955: EMPTY
71956: LIST
71957: LIST
71958: PUSH
71959: LD_INT 1
71961: NEG
71962: PUSH
71963: LD_INT 1
71965: PUSH
71966: EMPTY
71967: LIST
71968: LIST
71969: PUSH
71970: LD_INT 2
71972: NEG
71973: PUSH
71974: LD_INT 0
71976: PUSH
71977: EMPTY
71978: LIST
71979: LIST
71980: PUSH
71981: LD_INT 2
71983: NEG
71984: PUSH
71985: LD_INT 1
71987: NEG
71988: PUSH
71989: EMPTY
71990: LIST
71991: LIST
71992: PUSH
71993: LD_INT 2
71995: NEG
71996: PUSH
71997: LD_INT 2
71999: NEG
72000: PUSH
72001: EMPTY
72002: LIST
72003: LIST
72004: PUSH
72005: LD_INT 2
72007: NEG
72008: PUSH
72009: LD_INT 3
72011: NEG
72012: PUSH
72013: EMPTY
72014: LIST
72015: LIST
72016: PUSH
72017: LD_INT 2
72019: PUSH
72020: LD_INT 1
72022: NEG
72023: PUSH
72024: EMPTY
72025: LIST
72026: LIST
72027: PUSH
72028: LD_INT 3
72030: PUSH
72031: LD_INT 1
72033: PUSH
72034: EMPTY
72035: LIST
72036: LIST
72037: PUSH
72038: LD_INT 1
72040: PUSH
72041: LD_INT 3
72043: PUSH
72044: EMPTY
72045: LIST
72046: LIST
72047: PUSH
72048: LD_INT 1
72050: NEG
72051: PUSH
72052: LD_INT 2
72054: PUSH
72055: EMPTY
72056: LIST
72057: LIST
72058: PUSH
72059: LD_INT 3
72061: NEG
72062: PUSH
72063: LD_INT 2
72065: NEG
72066: PUSH
72067: EMPTY
72068: LIST
72069: LIST
72070: PUSH
72071: EMPTY
72072: LIST
72073: LIST
72074: LIST
72075: LIST
72076: LIST
72077: LIST
72078: LIST
72079: LIST
72080: LIST
72081: LIST
72082: LIST
72083: LIST
72084: LIST
72085: LIST
72086: LIST
72087: LIST
72088: LIST
72089: LIST
72090: LIST
72091: LIST
72092: LIST
72093: LIST
72094: LIST
72095: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
72096: LD_ADDR_VAR 0 34
72100: PUSH
72101: LD_INT 0
72103: PUSH
72104: LD_INT 0
72106: PUSH
72107: EMPTY
72108: LIST
72109: LIST
72110: PUSH
72111: LD_INT 0
72113: PUSH
72114: LD_INT 1
72116: NEG
72117: PUSH
72118: EMPTY
72119: LIST
72120: LIST
72121: PUSH
72122: LD_INT 1
72124: PUSH
72125: LD_INT 0
72127: PUSH
72128: EMPTY
72129: LIST
72130: LIST
72131: PUSH
72132: LD_INT 1
72134: PUSH
72135: LD_INT 1
72137: PUSH
72138: EMPTY
72139: LIST
72140: LIST
72141: PUSH
72142: LD_INT 0
72144: PUSH
72145: LD_INT 1
72147: PUSH
72148: EMPTY
72149: LIST
72150: LIST
72151: PUSH
72152: LD_INT 1
72154: NEG
72155: PUSH
72156: LD_INT 0
72158: PUSH
72159: EMPTY
72160: LIST
72161: LIST
72162: PUSH
72163: LD_INT 1
72165: NEG
72166: PUSH
72167: LD_INT 1
72169: NEG
72170: PUSH
72171: EMPTY
72172: LIST
72173: LIST
72174: PUSH
72175: LD_INT 1
72177: NEG
72178: PUSH
72179: LD_INT 2
72181: NEG
72182: PUSH
72183: EMPTY
72184: LIST
72185: LIST
72186: PUSH
72187: LD_INT 0
72189: PUSH
72190: LD_INT 2
72192: NEG
72193: PUSH
72194: EMPTY
72195: LIST
72196: LIST
72197: PUSH
72198: LD_INT 1
72200: PUSH
72201: LD_INT 1
72203: NEG
72204: PUSH
72205: EMPTY
72206: LIST
72207: LIST
72208: PUSH
72209: LD_INT 2
72211: PUSH
72212: LD_INT 1
72214: PUSH
72215: EMPTY
72216: LIST
72217: LIST
72218: PUSH
72219: LD_INT 2
72221: PUSH
72222: LD_INT 2
72224: PUSH
72225: EMPTY
72226: LIST
72227: LIST
72228: PUSH
72229: LD_INT 1
72231: PUSH
72232: LD_INT 2
72234: PUSH
72235: EMPTY
72236: LIST
72237: LIST
72238: PUSH
72239: LD_INT 1
72241: NEG
72242: PUSH
72243: LD_INT 1
72245: PUSH
72246: EMPTY
72247: LIST
72248: LIST
72249: PUSH
72250: LD_INT 2
72252: NEG
72253: PUSH
72254: LD_INT 0
72256: PUSH
72257: EMPTY
72258: LIST
72259: LIST
72260: PUSH
72261: LD_INT 2
72263: NEG
72264: PUSH
72265: LD_INT 1
72267: NEG
72268: PUSH
72269: EMPTY
72270: LIST
72271: LIST
72272: PUSH
72273: LD_INT 2
72275: NEG
72276: PUSH
72277: LD_INT 2
72279: NEG
72280: PUSH
72281: EMPTY
72282: LIST
72283: LIST
72284: PUSH
72285: LD_INT 1
72287: NEG
72288: PUSH
72289: LD_INT 3
72291: NEG
72292: PUSH
72293: EMPTY
72294: LIST
72295: LIST
72296: PUSH
72297: LD_INT 1
72299: PUSH
72300: LD_INT 2
72302: NEG
72303: PUSH
72304: EMPTY
72305: LIST
72306: LIST
72307: PUSH
72308: LD_INT 3
72310: PUSH
72311: LD_INT 2
72313: PUSH
72314: EMPTY
72315: LIST
72316: LIST
72317: PUSH
72318: LD_INT 2
72320: PUSH
72321: LD_INT 3
72323: PUSH
72324: EMPTY
72325: LIST
72326: LIST
72327: PUSH
72328: LD_INT 2
72330: NEG
72331: PUSH
72332: LD_INT 1
72334: PUSH
72335: EMPTY
72336: LIST
72337: LIST
72338: PUSH
72339: LD_INT 3
72341: NEG
72342: PUSH
72343: LD_INT 1
72345: NEG
72346: PUSH
72347: EMPTY
72348: LIST
72349: LIST
72350: PUSH
72351: EMPTY
72352: LIST
72353: LIST
72354: LIST
72355: LIST
72356: LIST
72357: LIST
72358: LIST
72359: LIST
72360: LIST
72361: LIST
72362: LIST
72363: LIST
72364: LIST
72365: LIST
72366: LIST
72367: LIST
72368: LIST
72369: LIST
72370: LIST
72371: LIST
72372: LIST
72373: LIST
72374: LIST
72375: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
72376: LD_ADDR_VAR 0 35
72380: PUSH
72381: LD_INT 0
72383: PUSH
72384: LD_INT 0
72386: PUSH
72387: EMPTY
72388: LIST
72389: LIST
72390: PUSH
72391: LD_INT 0
72393: PUSH
72394: LD_INT 1
72396: NEG
72397: PUSH
72398: EMPTY
72399: LIST
72400: LIST
72401: PUSH
72402: LD_INT 1
72404: PUSH
72405: LD_INT 0
72407: PUSH
72408: EMPTY
72409: LIST
72410: LIST
72411: PUSH
72412: LD_INT 1
72414: PUSH
72415: LD_INT 1
72417: PUSH
72418: EMPTY
72419: LIST
72420: LIST
72421: PUSH
72422: LD_INT 0
72424: PUSH
72425: LD_INT 1
72427: PUSH
72428: EMPTY
72429: LIST
72430: LIST
72431: PUSH
72432: LD_INT 1
72434: NEG
72435: PUSH
72436: LD_INT 0
72438: PUSH
72439: EMPTY
72440: LIST
72441: LIST
72442: PUSH
72443: LD_INT 1
72445: NEG
72446: PUSH
72447: LD_INT 1
72449: NEG
72450: PUSH
72451: EMPTY
72452: LIST
72453: LIST
72454: PUSH
72455: LD_INT 2
72457: PUSH
72458: LD_INT 1
72460: PUSH
72461: EMPTY
72462: LIST
72463: LIST
72464: PUSH
72465: LD_INT 2
72467: NEG
72468: PUSH
72469: LD_INT 1
72471: NEG
72472: PUSH
72473: EMPTY
72474: LIST
72475: LIST
72476: PUSH
72477: EMPTY
72478: LIST
72479: LIST
72480: LIST
72481: LIST
72482: LIST
72483: LIST
72484: LIST
72485: LIST
72486: LIST
72487: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72488: LD_ADDR_VAR 0 36
72492: PUSH
72493: LD_INT 0
72495: PUSH
72496: LD_INT 0
72498: PUSH
72499: EMPTY
72500: LIST
72501: LIST
72502: PUSH
72503: LD_INT 0
72505: PUSH
72506: LD_INT 1
72508: NEG
72509: PUSH
72510: EMPTY
72511: LIST
72512: LIST
72513: PUSH
72514: LD_INT 1
72516: PUSH
72517: LD_INT 0
72519: PUSH
72520: EMPTY
72521: LIST
72522: LIST
72523: PUSH
72524: LD_INT 1
72526: PUSH
72527: LD_INT 1
72529: PUSH
72530: EMPTY
72531: LIST
72532: LIST
72533: PUSH
72534: LD_INT 0
72536: PUSH
72537: LD_INT 1
72539: PUSH
72540: EMPTY
72541: LIST
72542: LIST
72543: PUSH
72544: LD_INT 1
72546: NEG
72547: PUSH
72548: LD_INT 0
72550: PUSH
72551: EMPTY
72552: LIST
72553: LIST
72554: PUSH
72555: LD_INT 1
72557: NEG
72558: PUSH
72559: LD_INT 1
72561: NEG
72562: PUSH
72563: EMPTY
72564: LIST
72565: LIST
72566: PUSH
72567: LD_INT 1
72569: NEG
72570: PUSH
72571: LD_INT 2
72573: NEG
72574: PUSH
72575: EMPTY
72576: LIST
72577: LIST
72578: PUSH
72579: LD_INT 1
72581: PUSH
72582: LD_INT 2
72584: PUSH
72585: EMPTY
72586: LIST
72587: LIST
72588: PUSH
72589: EMPTY
72590: LIST
72591: LIST
72592: LIST
72593: LIST
72594: LIST
72595: LIST
72596: LIST
72597: LIST
72598: LIST
72599: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72600: LD_ADDR_VAR 0 37
72604: PUSH
72605: LD_INT 0
72607: PUSH
72608: LD_INT 0
72610: PUSH
72611: EMPTY
72612: LIST
72613: LIST
72614: PUSH
72615: LD_INT 0
72617: PUSH
72618: LD_INT 1
72620: NEG
72621: PUSH
72622: EMPTY
72623: LIST
72624: LIST
72625: PUSH
72626: LD_INT 1
72628: PUSH
72629: LD_INT 0
72631: PUSH
72632: EMPTY
72633: LIST
72634: LIST
72635: PUSH
72636: LD_INT 1
72638: PUSH
72639: LD_INT 1
72641: PUSH
72642: EMPTY
72643: LIST
72644: LIST
72645: PUSH
72646: LD_INT 0
72648: PUSH
72649: LD_INT 1
72651: PUSH
72652: EMPTY
72653: LIST
72654: LIST
72655: PUSH
72656: LD_INT 1
72658: NEG
72659: PUSH
72660: LD_INT 0
72662: PUSH
72663: EMPTY
72664: LIST
72665: LIST
72666: PUSH
72667: LD_INT 1
72669: NEG
72670: PUSH
72671: LD_INT 1
72673: NEG
72674: PUSH
72675: EMPTY
72676: LIST
72677: LIST
72678: PUSH
72679: LD_INT 1
72681: PUSH
72682: LD_INT 1
72684: NEG
72685: PUSH
72686: EMPTY
72687: LIST
72688: LIST
72689: PUSH
72690: LD_INT 1
72692: NEG
72693: PUSH
72694: LD_INT 1
72696: PUSH
72697: EMPTY
72698: LIST
72699: LIST
72700: PUSH
72701: EMPTY
72702: LIST
72703: LIST
72704: LIST
72705: LIST
72706: LIST
72707: LIST
72708: LIST
72709: LIST
72710: LIST
72711: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
72712: LD_ADDR_VAR 0 38
72716: PUSH
72717: LD_INT 0
72719: PUSH
72720: LD_INT 0
72722: PUSH
72723: EMPTY
72724: LIST
72725: LIST
72726: PUSH
72727: LD_INT 0
72729: PUSH
72730: LD_INT 1
72732: NEG
72733: PUSH
72734: EMPTY
72735: LIST
72736: LIST
72737: PUSH
72738: LD_INT 1
72740: PUSH
72741: LD_INT 0
72743: PUSH
72744: EMPTY
72745: LIST
72746: LIST
72747: PUSH
72748: LD_INT 1
72750: PUSH
72751: LD_INT 1
72753: PUSH
72754: EMPTY
72755: LIST
72756: LIST
72757: PUSH
72758: LD_INT 0
72760: PUSH
72761: LD_INT 1
72763: PUSH
72764: EMPTY
72765: LIST
72766: LIST
72767: PUSH
72768: LD_INT 1
72770: NEG
72771: PUSH
72772: LD_INT 0
72774: PUSH
72775: EMPTY
72776: LIST
72777: LIST
72778: PUSH
72779: LD_INT 1
72781: NEG
72782: PUSH
72783: LD_INT 1
72785: NEG
72786: PUSH
72787: EMPTY
72788: LIST
72789: LIST
72790: PUSH
72791: LD_INT 2
72793: PUSH
72794: LD_INT 1
72796: PUSH
72797: EMPTY
72798: LIST
72799: LIST
72800: PUSH
72801: LD_INT 2
72803: NEG
72804: PUSH
72805: LD_INT 1
72807: NEG
72808: PUSH
72809: EMPTY
72810: LIST
72811: LIST
72812: PUSH
72813: EMPTY
72814: LIST
72815: LIST
72816: LIST
72817: LIST
72818: LIST
72819: LIST
72820: LIST
72821: LIST
72822: LIST
72823: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72824: LD_ADDR_VAR 0 39
72828: PUSH
72829: LD_INT 0
72831: PUSH
72832: LD_INT 0
72834: PUSH
72835: EMPTY
72836: LIST
72837: LIST
72838: PUSH
72839: LD_INT 0
72841: PUSH
72842: LD_INT 1
72844: NEG
72845: PUSH
72846: EMPTY
72847: LIST
72848: LIST
72849: PUSH
72850: LD_INT 1
72852: PUSH
72853: LD_INT 0
72855: PUSH
72856: EMPTY
72857: LIST
72858: LIST
72859: PUSH
72860: LD_INT 1
72862: PUSH
72863: LD_INT 1
72865: PUSH
72866: EMPTY
72867: LIST
72868: LIST
72869: PUSH
72870: LD_INT 0
72872: PUSH
72873: LD_INT 1
72875: PUSH
72876: EMPTY
72877: LIST
72878: LIST
72879: PUSH
72880: LD_INT 1
72882: NEG
72883: PUSH
72884: LD_INT 0
72886: PUSH
72887: EMPTY
72888: LIST
72889: LIST
72890: PUSH
72891: LD_INT 1
72893: NEG
72894: PUSH
72895: LD_INT 1
72897: NEG
72898: PUSH
72899: EMPTY
72900: LIST
72901: LIST
72902: PUSH
72903: LD_INT 1
72905: NEG
72906: PUSH
72907: LD_INT 2
72909: NEG
72910: PUSH
72911: EMPTY
72912: LIST
72913: LIST
72914: PUSH
72915: LD_INT 1
72917: PUSH
72918: LD_INT 2
72920: PUSH
72921: EMPTY
72922: LIST
72923: LIST
72924: PUSH
72925: EMPTY
72926: LIST
72927: LIST
72928: LIST
72929: LIST
72930: LIST
72931: LIST
72932: LIST
72933: LIST
72934: LIST
72935: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72936: LD_ADDR_VAR 0 40
72940: PUSH
72941: LD_INT 0
72943: PUSH
72944: LD_INT 0
72946: PUSH
72947: EMPTY
72948: LIST
72949: LIST
72950: PUSH
72951: LD_INT 0
72953: PUSH
72954: LD_INT 1
72956: NEG
72957: PUSH
72958: EMPTY
72959: LIST
72960: LIST
72961: PUSH
72962: LD_INT 1
72964: PUSH
72965: LD_INT 0
72967: PUSH
72968: EMPTY
72969: LIST
72970: LIST
72971: PUSH
72972: LD_INT 1
72974: PUSH
72975: LD_INT 1
72977: PUSH
72978: EMPTY
72979: LIST
72980: LIST
72981: PUSH
72982: LD_INT 0
72984: PUSH
72985: LD_INT 1
72987: PUSH
72988: EMPTY
72989: LIST
72990: LIST
72991: PUSH
72992: LD_INT 1
72994: NEG
72995: PUSH
72996: LD_INT 0
72998: PUSH
72999: EMPTY
73000: LIST
73001: LIST
73002: PUSH
73003: LD_INT 1
73005: NEG
73006: PUSH
73007: LD_INT 1
73009: NEG
73010: PUSH
73011: EMPTY
73012: LIST
73013: LIST
73014: PUSH
73015: LD_INT 1
73017: PUSH
73018: LD_INT 1
73020: NEG
73021: PUSH
73022: EMPTY
73023: LIST
73024: LIST
73025: PUSH
73026: LD_INT 1
73028: NEG
73029: PUSH
73030: LD_INT 1
73032: PUSH
73033: EMPTY
73034: LIST
73035: LIST
73036: PUSH
73037: EMPTY
73038: LIST
73039: LIST
73040: LIST
73041: LIST
73042: LIST
73043: LIST
73044: LIST
73045: LIST
73046: LIST
73047: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73048: LD_ADDR_VAR 0 41
73052: PUSH
73053: LD_INT 0
73055: PUSH
73056: LD_INT 0
73058: PUSH
73059: EMPTY
73060: LIST
73061: LIST
73062: PUSH
73063: LD_INT 0
73065: PUSH
73066: LD_INT 1
73068: NEG
73069: PUSH
73070: EMPTY
73071: LIST
73072: LIST
73073: PUSH
73074: LD_INT 1
73076: PUSH
73077: LD_INT 0
73079: PUSH
73080: EMPTY
73081: LIST
73082: LIST
73083: PUSH
73084: LD_INT 1
73086: PUSH
73087: LD_INT 1
73089: PUSH
73090: EMPTY
73091: LIST
73092: LIST
73093: PUSH
73094: LD_INT 0
73096: PUSH
73097: LD_INT 1
73099: PUSH
73100: EMPTY
73101: LIST
73102: LIST
73103: PUSH
73104: LD_INT 1
73106: NEG
73107: PUSH
73108: LD_INT 0
73110: PUSH
73111: EMPTY
73112: LIST
73113: LIST
73114: PUSH
73115: LD_INT 1
73117: NEG
73118: PUSH
73119: LD_INT 1
73121: NEG
73122: PUSH
73123: EMPTY
73124: LIST
73125: LIST
73126: PUSH
73127: LD_INT 1
73129: NEG
73130: PUSH
73131: LD_INT 2
73133: NEG
73134: PUSH
73135: EMPTY
73136: LIST
73137: LIST
73138: PUSH
73139: LD_INT 1
73141: PUSH
73142: LD_INT 1
73144: NEG
73145: PUSH
73146: EMPTY
73147: LIST
73148: LIST
73149: PUSH
73150: LD_INT 2
73152: PUSH
73153: LD_INT 0
73155: PUSH
73156: EMPTY
73157: LIST
73158: LIST
73159: PUSH
73160: LD_INT 2
73162: PUSH
73163: LD_INT 1
73165: PUSH
73166: EMPTY
73167: LIST
73168: LIST
73169: PUSH
73170: LD_INT 2
73172: PUSH
73173: LD_INT 2
73175: PUSH
73176: EMPTY
73177: LIST
73178: LIST
73179: PUSH
73180: LD_INT 1
73182: PUSH
73183: LD_INT 2
73185: PUSH
73186: EMPTY
73187: LIST
73188: LIST
73189: PUSH
73190: LD_INT 1
73192: NEG
73193: PUSH
73194: LD_INT 1
73196: PUSH
73197: EMPTY
73198: LIST
73199: LIST
73200: PUSH
73201: LD_INT 2
73203: NEG
73204: PUSH
73205: LD_INT 0
73207: PUSH
73208: EMPTY
73209: LIST
73210: LIST
73211: PUSH
73212: LD_INT 2
73214: NEG
73215: PUSH
73216: LD_INT 1
73218: NEG
73219: PUSH
73220: EMPTY
73221: LIST
73222: LIST
73223: PUSH
73224: LD_INT 2
73226: NEG
73227: PUSH
73228: LD_INT 2
73230: NEG
73231: PUSH
73232: EMPTY
73233: LIST
73234: LIST
73235: PUSH
73236: LD_INT 2
73238: NEG
73239: PUSH
73240: LD_INT 3
73242: NEG
73243: PUSH
73244: EMPTY
73245: LIST
73246: LIST
73247: PUSH
73248: LD_INT 2
73250: PUSH
73251: LD_INT 1
73253: NEG
73254: PUSH
73255: EMPTY
73256: LIST
73257: LIST
73258: PUSH
73259: LD_INT 3
73261: PUSH
73262: LD_INT 0
73264: PUSH
73265: EMPTY
73266: LIST
73267: LIST
73268: PUSH
73269: LD_INT 3
73271: PUSH
73272: LD_INT 1
73274: PUSH
73275: EMPTY
73276: LIST
73277: LIST
73278: PUSH
73279: LD_INT 3
73281: PUSH
73282: LD_INT 2
73284: PUSH
73285: EMPTY
73286: LIST
73287: LIST
73288: PUSH
73289: LD_INT 3
73291: PUSH
73292: LD_INT 3
73294: PUSH
73295: EMPTY
73296: LIST
73297: LIST
73298: PUSH
73299: LD_INT 2
73301: PUSH
73302: LD_INT 3
73304: PUSH
73305: EMPTY
73306: LIST
73307: LIST
73308: PUSH
73309: LD_INT 2
73311: NEG
73312: PUSH
73313: LD_INT 1
73315: PUSH
73316: EMPTY
73317: LIST
73318: LIST
73319: PUSH
73320: LD_INT 3
73322: NEG
73323: PUSH
73324: LD_INT 0
73326: PUSH
73327: EMPTY
73328: LIST
73329: LIST
73330: PUSH
73331: LD_INT 3
73333: NEG
73334: PUSH
73335: LD_INT 1
73337: NEG
73338: PUSH
73339: EMPTY
73340: LIST
73341: LIST
73342: PUSH
73343: LD_INT 3
73345: NEG
73346: PUSH
73347: LD_INT 2
73349: NEG
73350: PUSH
73351: EMPTY
73352: LIST
73353: LIST
73354: PUSH
73355: LD_INT 3
73357: NEG
73358: PUSH
73359: LD_INT 3
73361: NEG
73362: PUSH
73363: EMPTY
73364: LIST
73365: LIST
73366: PUSH
73367: EMPTY
73368: LIST
73369: LIST
73370: LIST
73371: LIST
73372: LIST
73373: LIST
73374: LIST
73375: LIST
73376: LIST
73377: LIST
73378: LIST
73379: LIST
73380: LIST
73381: LIST
73382: LIST
73383: LIST
73384: LIST
73385: LIST
73386: LIST
73387: LIST
73388: LIST
73389: LIST
73390: LIST
73391: LIST
73392: LIST
73393: LIST
73394: LIST
73395: LIST
73396: LIST
73397: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73398: LD_ADDR_VAR 0 42
73402: PUSH
73403: LD_INT 0
73405: PUSH
73406: LD_INT 0
73408: PUSH
73409: EMPTY
73410: LIST
73411: LIST
73412: PUSH
73413: LD_INT 0
73415: PUSH
73416: LD_INT 1
73418: NEG
73419: PUSH
73420: EMPTY
73421: LIST
73422: LIST
73423: PUSH
73424: LD_INT 1
73426: PUSH
73427: LD_INT 0
73429: PUSH
73430: EMPTY
73431: LIST
73432: LIST
73433: PUSH
73434: LD_INT 1
73436: PUSH
73437: LD_INT 1
73439: PUSH
73440: EMPTY
73441: LIST
73442: LIST
73443: PUSH
73444: LD_INT 0
73446: PUSH
73447: LD_INT 1
73449: PUSH
73450: EMPTY
73451: LIST
73452: LIST
73453: PUSH
73454: LD_INT 1
73456: NEG
73457: PUSH
73458: LD_INT 0
73460: PUSH
73461: EMPTY
73462: LIST
73463: LIST
73464: PUSH
73465: LD_INT 1
73467: NEG
73468: PUSH
73469: LD_INT 1
73471: NEG
73472: PUSH
73473: EMPTY
73474: LIST
73475: LIST
73476: PUSH
73477: LD_INT 1
73479: NEG
73480: PUSH
73481: LD_INT 2
73483: NEG
73484: PUSH
73485: EMPTY
73486: LIST
73487: LIST
73488: PUSH
73489: LD_INT 0
73491: PUSH
73492: LD_INT 2
73494: NEG
73495: PUSH
73496: EMPTY
73497: LIST
73498: LIST
73499: PUSH
73500: LD_INT 1
73502: PUSH
73503: LD_INT 1
73505: NEG
73506: PUSH
73507: EMPTY
73508: LIST
73509: LIST
73510: PUSH
73511: LD_INT 2
73513: PUSH
73514: LD_INT 1
73516: PUSH
73517: EMPTY
73518: LIST
73519: LIST
73520: PUSH
73521: LD_INT 2
73523: PUSH
73524: LD_INT 2
73526: PUSH
73527: EMPTY
73528: LIST
73529: LIST
73530: PUSH
73531: LD_INT 1
73533: PUSH
73534: LD_INT 2
73536: PUSH
73537: EMPTY
73538: LIST
73539: LIST
73540: PUSH
73541: LD_INT 0
73543: PUSH
73544: LD_INT 2
73546: PUSH
73547: EMPTY
73548: LIST
73549: LIST
73550: PUSH
73551: LD_INT 1
73553: NEG
73554: PUSH
73555: LD_INT 1
73557: PUSH
73558: EMPTY
73559: LIST
73560: LIST
73561: PUSH
73562: LD_INT 2
73564: NEG
73565: PUSH
73566: LD_INT 1
73568: NEG
73569: PUSH
73570: EMPTY
73571: LIST
73572: LIST
73573: PUSH
73574: LD_INT 2
73576: NEG
73577: PUSH
73578: LD_INT 2
73580: NEG
73581: PUSH
73582: EMPTY
73583: LIST
73584: LIST
73585: PUSH
73586: LD_INT 2
73588: NEG
73589: PUSH
73590: LD_INT 3
73592: NEG
73593: PUSH
73594: EMPTY
73595: LIST
73596: LIST
73597: PUSH
73598: LD_INT 1
73600: NEG
73601: PUSH
73602: LD_INT 3
73604: NEG
73605: PUSH
73606: EMPTY
73607: LIST
73608: LIST
73609: PUSH
73610: LD_INT 0
73612: PUSH
73613: LD_INT 3
73615: NEG
73616: PUSH
73617: EMPTY
73618: LIST
73619: LIST
73620: PUSH
73621: LD_INT 1
73623: PUSH
73624: LD_INT 2
73626: NEG
73627: PUSH
73628: EMPTY
73629: LIST
73630: LIST
73631: PUSH
73632: LD_INT 3
73634: PUSH
73635: LD_INT 2
73637: PUSH
73638: EMPTY
73639: LIST
73640: LIST
73641: PUSH
73642: LD_INT 3
73644: PUSH
73645: LD_INT 3
73647: PUSH
73648: EMPTY
73649: LIST
73650: LIST
73651: PUSH
73652: LD_INT 2
73654: PUSH
73655: LD_INT 3
73657: PUSH
73658: EMPTY
73659: LIST
73660: LIST
73661: PUSH
73662: LD_INT 1
73664: PUSH
73665: LD_INT 3
73667: PUSH
73668: EMPTY
73669: LIST
73670: LIST
73671: PUSH
73672: LD_INT 0
73674: PUSH
73675: LD_INT 3
73677: PUSH
73678: EMPTY
73679: LIST
73680: LIST
73681: PUSH
73682: LD_INT 1
73684: NEG
73685: PUSH
73686: LD_INT 2
73688: PUSH
73689: EMPTY
73690: LIST
73691: LIST
73692: PUSH
73693: LD_INT 3
73695: NEG
73696: PUSH
73697: LD_INT 2
73699: NEG
73700: PUSH
73701: EMPTY
73702: LIST
73703: LIST
73704: PUSH
73705: LD_INT 3
73707: NEG
73708: PUSH
73709: LD_INT 3
73711: NEG
73712: PUSH
73713: EMPTY
73714: LIST
73715: LIST
73716: PUSH
73717: EMPTY
73718: LIST
73719: LIST
73720: LIST
73721: LIST
73722: LIST
73723: LIST
73724: LIST
73725: LIST
73726: LIST
73727: LIST
73728: LIST
73729: LIST
73730: LIST
73731: LIST
73732: LIST
73733: LIST
73734: LIST
73735: LIST
73736: LIST
73737: LIST
73738: LIST
73739: LIST
73740: LIST
73741: LIST
73742: LIST
73743: LIST
73744: LIST
73745: LIST
73746: LIST
73747: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73748: LD_ADDR_VAR 0 43
73752: PUSH
73753: LD_INT 0
73755: PUSH
73756: LD_INT 0
73758: PUSH
73759: EMPTY
73760: LIST
73761: LIST
73762: PUSH
73763: LD_INT 0
73765: PUSH
73766: LD_INT 1
73768: NEG
73769: PUSH
73770: EMPTY
73771: LIST
73772: LIST
73773: PUSH
73774: LD_INT 1
73776: PUSH
73777: LD_INT 0
73779: PUSH
73780: EMPTY
73781: LIST
73782: LIST
73783: PUSH
73784: LD_INT 1
73786: PUSH
73787: LD_INT 1
73789: PUSH
73790: EMPTY
73791: LIST
73792: LIST
73793: PUSH
73794: LD_INT 0
73796: PUSH
73797: LD_INT 1
73799: PUSH
73800: EMPTY
73801: LIST
73802: LIST
73803: PUSH
73804: LD_INT 1
73806: NEG
73807: PUSH
73808: LD_INT 0
73810: PUSH
73811: EMPTY
73812: LIST
73813: LIST
73814: PUSH
73815: LD_INT 1
73817: NEG
73818: PUSH
73819: LD_INT 1
73821: NEG
73822: PUSH
73823: EMPTY
73824: LIST
73825: LIST
73826: PUSH
73827: LD_INT 1
73829: NEG
73830: PUSH
73831: LD_INT 2
73833: NEG
73834: PUSH
73835: EMPTY
73836: LIST
73837: LIST
73838: PUSH
73839: LD_INT 0
73841: PUSH
73842: LD_INT 2
73844: NEG
73845: PUSH
73846: EMPTY
73847: LIST
73848: LIST
73849: PUSH
73850: LD_INT 1
73852: PUSH
73853: LD_INT 1
73855: NEG
73856: PUSH
73857: EMPTY
73858: LIST
73859: LIST
73860: PUSH
73861: LD_INT 2
73863: PUSH
73864: LD_INT 0
73866: PUSH
73867: EMPTY
73868: LIST
73869: LIST
73870: PUSH
73871: LD_INT 2
73873: PUSH
73874: LD_INT 1
73876: PUSH
73877: EMPTY
73878: LIST
73879: LIST
73880: PUSH
73881: LD_INT 1
73883: PUSH
73884: LD_INT 2
73886: PUSH
73887: EMPTY
73888: LIST
73889: LIST
73890: PUSH
73891: LD_INT 0
73893: PUSH
73894: LD_INT 2
73896: PUSH
73897: EMPTY
73898: LIST
73899: LIST
73900: PUSH
73901: LD_INT 1
73903: NEG
73904: PUSH
73905: LD_INT 1
73907: PUSH
73908: EMPTY
73909: LIST
73910: LIST
73911: PUSH
73912: LD_INT 2
73914: NEG
73915: PUSH
73916: LD_INT 0
73918: PUSH
73919: EMPTY
73920: LIST
73921: LIST
73922: PUSH
73923: LD_INT 2
73925: NEG
73926: PUSH
73927: LD_INT 1
73929: NEG
73930: PUSH
73931: EMPTY
73932: LIST
73933: LIST
73934: PUSH
73935: LD_INT 1
73937: NEG
73938: PUSH
73939: LD_INT 3
73941: NEG
73942: PUSH
73943: EMPTY
73944: LIST
73945: LIST
73946: PUSH
73947: LD_INT 0
73949: PUSH
73950: LD_INT 3
73952: NEG
73953: PUSH
73954: EMPTY
73955: LIST
73956: LIST
73957: PUSH
73958: LD_INT 1
73960: PUSH
73961: LD_INT 2
73963: NEG
73964: PUSH
73965: EMPTY
73966: LIST
73967: LIST
73968: PUSH
73969: LD_INT 2
73971: PUSH
73972: LD_INT 1
73974: NEG
73975: PUSH
73976: EMPTY
73977: LIST
73978: LIST
73979: PUSH
73980: LD_INT 3
73982: PUSH
73983: LD_INT 0
73985: PUSH
73986: EMPTY
73987: LIST
73988: LIST
73989: PUSH
73990: LD_INT 3
73992: PUSH
73993: LD_INT 1
73995: PUSH
73996: EMPTY
73997: LIST
73998: LIST
73999: PUSH
74000: LD_INT 1
74002: PUSH
74003: LD_INT 3
74005: PUSH
74006: EMPTY
74007: LIST
74008: LIST
74009: PUSH
74010: LD_INT 0
74012: PUSH
74013: LD_INT 3
74015: PUSH
74016: EMPTY
74017: LIST
74018: LIST
74019: PUSH
74020: LD_INT 1
74022: NEG
74023: PUSH
74024: LD_INT 2
74026: PUSH
74027: EMPTY
74028: LIST
74029: LIST
74030: PUSH
74031: LD_INT 2
74033: NEG
74034: PUSH
74035: LD_INT 1
74037: PUSH
74038: EMPTY
74039: LIST
74040: LIST
74041: PUSH
74042: LD_INT 3
74044: NEG
74045: PUSH
74046: LD_INT 0
74048: PUSH
74049: EMPTY
74050: LIST
74051: LIST
74052: PUSH
74053: LD_INT 3
74055: NEG
74056: PUSH
74057: LD_INT 1
74059: NEG
74060: PUSH
74061: EMPTY
74062: LIST
74063: LIST
74064: PUSH
74065: EMPTY
74066: LIST
74067: LIST
74068: LIST
74069: LIST
74070: LIST
74071: LIST
74072: LIST
74073: LIST
74074: LIST
74075: LIST
74076: LIST
74077: LIST
74078: LIST
74079: LIST
74080: LIST
74081: LIST
74082: LIST
74083: LIST
74084: LIST
74085: LIST
74086: LIST
74087: LIST
74088: LIST
74089: LIST
74090: LIST
74091: LIST
74092: LIST
74093: LIST
74094: LIST
74095: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74096: LD_ADDR_VAR 0 44
74100: PUSH
74101: LD_INT 0
74103: PUSH
74104: LD_INT 0
74106: PUSH
74107: EMPTY
74108: LIST
74109: LIST
74110: PUSH
74111: LD_INT 0
74113: PUSH
74114: LD_INT 1
74116: NEG
74117: PUSH
74118: EMPTY
74119: LIST
74120: LIST
74121: PUSH
74122: LD_INT 1
74124: PUSH
74125: LD_INT 0
74127: PUSH
74128: EMPTY
74129: LIST
74130: LIST
74131: PUSH
74132: LD_INT 1
74134: PUSH
74135: LD_INT 1
74137: PUSH
74138: EMPTY
74139: LIST
74140: LIST
74141: PUSH
74142: LD_INT 0
74144: PUSH
74145: LD_INT 1
74147: PUSH
74148: EMPTY
74149: LIST
74150: LIST
74151: PUSH
74152: LD_INT 1
74154: NEG
74155: PUSH
74156: LD_INT 0
74158: PUSH
74159: EMPTY
74160: LIST
74161: LIST
74162: PUSH
74163: LD_INT 1
74165: NEG
74166: PUSH
74167: LD_INT 1
74169: NEG
74170: PUSH
74171: EMPTY
74172: LIST
74173: LIST
74174: PUSH
74175: LD_INT 1
74177: NEG
74178: PUSH
74179: LD_INT 2
74181: NEG
74182: PUSH
74183: EMPTY
74184: LIST
74185: LIST
74186: PUSH
74187: LD_INT 1
74189: PUSH
74190: LD_INT 1
74192: NEG
74193: PUSH
74194: EMPTY
74195: LIST
74196: LIST
74197: PUSH
74198: LD_INT 2
74200: PUSH
74201: LD_INT 0
74203: PUSH
74204: EMPTY
74205: LIST
74206: LIST
74207: PUSH
74208: LD_INT 2
74210: PUSH
74211: LD_INT 1
74213: PUSH
74214: EMPTY
74215: LIST
74216: LIST
74217: PUSH
74218: LD_INT 2
74220: PUSH
74221: LD_INT 2
74223: PUSH
74224: EMPTY
74225: LIST
74226: LIST
74227: PUSH
74228: LD_INT 1
74230: PUSH
74231: LD_INT 2
74233: PUSH
74234: EMPTY
74235: LIST
74236: LIST
74237: PUSH
74238: LD_INT 1
74240: NEG
74241: PUSH
74242: LD_INT 1
74244: PUSH
74245: EMPTY
74246: LIST
74247: LIST
74248: PUSH
74249: LD_INT 2
74251: NEG
74252: PUSH
74253: LD_INT 0
74255: PUSH
74256: EMPTY
74257: LIST
74258: LIST
74259: PUSH
74260: LD_INT 2
74262: NEG
74263: PUSH
74264: LD_INT 1
74266: NEG
74267: PUSH
74268: EMPTY
74269: LIST
74270: LIST
74271: PUSH
74272: LD_INT 2
74274: NEG
74275: PUSH
74276: LD_INT 2
74278: NEG
74279: PUSH
74280: EMPTY
74281: LIST
74282: LIST
74283: PUSH
74284: LD_INT 2
74286: NEG
74287: PUSH
74288: LD_INT 3
74290: NEG
74291: PUSH
74292: EMPTY
74293: LIST
74294: LIST
74295: PUSH
74296: LD_INT 2
74298: PUSH
74299: LD_INT 1
74301: NEG
74302: PUSH
74303: EMPTY
74304: LIST
74305: LIST
74306: PUSH
74307: LD_INT 3
74309: PUSH
74310: LD_INT 0
74312: PUSH
74313: EMPTY
74314: LIST
74315: LIST
74316: PUSH
74317: LD_INT 3
74319: PUSH
74320: LD_INT 1
74322: PUSH
74323: EMPTY
74324: LIST
74325: LIST
74326: PUSH
74327: LD_INT 3
74329: PUSH
74330: LD_INT 2
74332: PUSH
74333: EMPTY
74334: LIST
74335: LIST
74336: PUSH
74337: LD_INT 3
74339: PUSH
74340: LD_INT 3
74342: PUSH
74343: EMPTY
74344: LIST
74345: LIST
74346: PUSH
74347: LD_INT 2
74349: PUSH
74350: LD_INT 3
74352: PUSH
74353: EMPTY
74354: LIST
74355: LIST
74356: PUSH
74357: LD_INT 2
74359: NEG
74360: PUSH
74361: LD_INT 1
74363: PUSH
74364: EMPTY
74365: LIST
74366: LIST
74367: PUSH
74368: LD_INT 3
74370: NEG
74371: PUSH
74372: LD_INT 0
74374: PUSH
74375: EMPTY
74376: LIST
74377: LIST
74378: PUSH
74379: LD_INT 3
74381: NEG
74382: PUSH
74383: LD_INT 1
74385: NEG
74386: PUSH
74387: EMPTY
74388: LIST
74389: LIST
74390: PUSH
74391: LD_INT 3
74393: NEG
74394: PUSH
74395: LD_INT 2
74397: NEG
74398: PUSH
74399: EMPTY
74400: LIST
74401: LIST
74402: PUSH
74403: LD_INT 3
74405: NEG
74406: PUSH
74407: LD_INT 3
74409: NEG
74410: PUSH
74411: EMPTY
74412: LIST
74413: LIST
74414: PUSH
74415: EMPTY
74416: LIST
74417: LIST
74418: LIST
74419: LIST
74420: LIST
74421: LIST
74422: LIST
74423: LIST
74424: LIST
74425: LIST
74426: LIST
74427: LIST
74428: LIST
74429: LIST
74430: LIST
74431: LIST
74432: LIST
74433: LIST
74434: LIST
74435: LIST
74436: LIST
74437: LIST
74438: LIST
74439: LIST
74440: LIST
74441: LIST
74442: LIST
74443: LIST
74444: LIST
74445: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74446: LD_ADDR_VAR 0 45
74450: PUSH
74451: LD_INT 0
74453: PUSH
74454: LD_INT 0
74456: PUSH
74457: EMPTY
74458: LIST
74459: LIST
74460: PUSH
74461: LD_INT 0
74463: PUSH
74464: LD_INT 1
74466: NEG
74467: PUSH
74468: EMPTY
74469: LIST
74470: LIST
74471: PUSH
74472: LD_INT 1
74474: PUSH
74475: LD_INT 0
74477: PUSH
74478: EMPTY
74479: LIST
74480: LIST
74481: PUSH
74482: LD_INT 1
74484: PUSH
74485: LD_INT 1
74487: PUSH
74488: EMPTY
74489: LIST
74490: LIST
74491: PUSH
74492: LD_INT 0
74494: PUSH
74495: LD_INT 1
74497: PUSH
74498: EMPTY
74499: LIST
74500: LIST
74501: PUSH
74502: LD_INT 1
74504: NEG
74505: PUSH
74506: LD_INT 0
74508: PUSH
74509: EMPTY
74510: LIST
74511: LIST
74512: PUSH
74513: LD_INT 1
74515: NEG
74516: PUSH
74517: LD_INT 1
74519: NEG
74520: PUSH
74521: EMPTY
74522: LIST
74523: LIST
74524: PUSH
74525: LD_INT 1
74527: NEG
74528: PUSH
74529: LD_INT 2
74531: NEG
74532: PUSH
74533: EMPTY
74534: LIST
74535: LIST
74536: PUSH
74537: LD_INT 0
74539: PUSH
74540: LD_INT 2
74542: NEG
74543: PUSH
74544: EMPTY
74545: LIST
74546: LIST
74547: PUSH
74548: LD_INT 1
74550: PUSH
74551: LD_INT 1
74553: NEG
74554: PUSH
74555: EMPTY
74556: LIST
74557: LIST
74558: PUSH
74559: LD_INT 2
74561: PUSH
74562: LD_INT 1
74564: PUSH
74565: EMPTY
74566: LIST
74567: LIST
74568: PUSH
74569: LD_INT 2
74571: PUSH
74572: LD_INT 2
74574: PUSH
74575: EMPTY
74576: LIST
74577: LIST
74578: PUSH
74579: LD_INT 1
74581: PUSH
74582: LD_INT 2
74584: PUSH
74585: EMPTY
74586: LIST
74587: LIST
74588: PUSH
74589: LD_INT 0
74591: PUSH
74592: LD_INT 2
74594: PUSH
74595: EMPTY
74596: LIST
74597: LIST
74598: PUSH
74599: LD_INT 1
74601: NEG
74602: PUSH
74603: LD_INT 1
74605: PUSH
74606: EMPTY
74607: LIST
74608: LIST
74609: PUSH
74610: LD_INT 2
74612: NEG
74613: PUSH
74614: LD_INT 1
74616: NEG
74617: PUSH
74618: EMPTY
74619: LIST
74620: LIST
74621: PUSH
74622: LD_INT 2
74624: NEG
74625: PUSH
74626: LD_INT 2
74628: NEG
74629: PUSH
74630: EMPTY
74631: LIST
74632: LIST
74633: PUSH
74634: LD_INT 2
74636: NEG
74637: PUSH
74638: LD_INT 3
74640: NEG
74641: PUSH
74642: EMPTY
74643: LIST
74644: LIST
74645: PUSH
74646: LD_INT 1
74648: NEG
74649: PUSH
74650: LD_INT 3
74652: NEG
74653: PUSH
74654: EMPTY
74655: LIST
74656: LIST
74657: PUSH
74658: LD_INT 0
74660: PUSH
74661: LD_INT 3
74663: NEG
74664: PUSH
74665: EMPTY
74666: LIST
74667: LIST
74668: PUSH
74669: LD_INT 1
74671: PUSH
74672: LD_INT 2
74674: NEG
74675: PUSH
74676: EMPTY
74677: LIST
74678: LIST
74679: PUSH
74680: LD_INT 3
74682: PUSH
74683: LD_INT 2
74685: PUSH
74686: EMPTY
74687: LIST
74688: LIST
74689: PUSH
74690: LD_INT 3
74692: PUSH
74693: LD_INT 3
74695: PUSH
74696: EMPTY
74697: LIST
74698: LIST
74699: PUSH
74700: LD_INT 2
74702: PUSH
74703: LD_INT 3
74705: PUSH
74706: EMPTY
74707: LIST
74708: LIST
74709: PUSH
74710: LD_INT 1
74712: PUSH
74713: LD_INT 3
74715: PUSH
74716: EMPTY
74717: LIST
74718: LIST
74719: PUSH
74720: LD_INT 0
74722: PUSH
74723: LD_INT 3
74725: PUSH
74726: EMPTY
74727: LIST
74728: LIST
74729: PUSH
74730: LD_INT 1
74732: NEG
74733: PUSH
74734: LD_INT 2
74736: PUSH
74737: EMPTY
74738: LIST
74739: LIST
74740: PUSH
74741: LD_INT 3
74743: NEG
74744: PUSH
74745: LD_INT 2
74747: NEG
74748: PUSH
74749: EMPTY
74750: LIST
74751: LIST
74752: PUSH
74753: LD_INT 3
74755: NEG
74756: PUSH
74757: LD_INT 3
74759: NEG
74760: PUSH
74761: EMPTY
74762: LIST
74763: LIST
74764: PUSH
74765: EMPTY
74766: LIST
74767: LIST
74768: LIST
74769: LIST
74770: LIST
74771: LIST
74772: LIST
74773: LIST
74774: LIST
74775: LIST
74776: LIST
74777: LIST
74778: LIST
74779: LIST
74780: LIST
74781: LIST
74782: LIST
74783: LIST
74784: LIST
74785: LIST
74786: LIST
74787: LIST
74788: LIST
74789: LIST
74790: LIST
74791: LIST
74792: LIST
74793: LIST
74794: LIST
74795: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74796: LD_ADDR_VAR 0 46
74800: PUSH
74801: LD_INT 0
74803: PUSH
74804: LD_INT 0
74806: PUSH
74807: EMPTY
74808: LIST
74809: LIST
74810: PUSH
74811: LD_INT 0
74813: PUSH
74814: LD_INT 1
74816: NEG
74817: PUSH
74818: EMPTY
74819: LIST
74820: LIST
74821: PUSH
74822: LD_INT 1
74824: PUSH
74825: LD_INT 0
74827: PUSH
74828: EMPTY
74829: LIST
74830: LIST
74831: PUSH
74832: LD_INT 1
74834: PUSH
74835: LD_INT 1
74837: PUSH
74838: EMPTY
74839: LIST
74840: LIST
74841: PUSH
74842: LD_INT 0
74844: PUSH
74845: LD_INT 1
74847: PUSH
74848: EMPTY
74849: LIST
74850: LIST
74851: PUSH
74852: LD_INT 1
74854: NEG
74855: PUSH
74856: LD_INT 0
74858: PUSH
74859: EMPTY
74860: LIST
74861: LIST
74862: PUSH
74863: LD_INT 1
74865: NEG
74866: PUSH
74867: LD_INT 1
74869: NEG
74870: PUSH
74871: EMPTY
74872: LIST
74873: LIST
74874: PUSH
74875: LD_INT 1
74877: NEG
74878: PUSH
74879: LD_INT 2
74881: NEG
74882: PUSH
74883: EMPTY
74884: LIST
74885: LIST
74886: PUSH
74887: LD_INT 0
74889: PUSH
74890: LD_INT 2
74892: NEG
74893: PUSH
74894: EMPTY
74895: LIST
74896: LIST
74897: PUSH
74898: LD_INT 1
74900: PUSH
74901: LD_INT 1
74903: NEG
74904: PUSH
74905: EMPTY
74906: LIST
74907: LIST
74908: PUSH
74909: LD_INT 2
74911: PUSH
74912: LD_INT 0
74914: PUSH
74915: EMPTY
74916: LIST
74917: LIST
74918: PUSH
74919: LD_INT 2
74921: PUSH
74922: LD_INT 1
74924: PUSH
74925: EMPTY
74926: LIST
74927: LIST
74928: PUSH
74929: LD_INT 1
74931: PUSH
74932: LD_INT 2
74934: PUSH
74935: EMPTY
74936: LIST
74937: LIST
74938: PUSH
74939: LD_INT 0
74941: PUSH
74942: LD_INT 2
74944: PUSH
74945: EMPTY
74946: LIST
74947: LIST
74948: PUSH
74949: LD_INT 1
74951: NEG
74952: PUSH
74953: LD_INT 1
74955: PUSH
74956: EMPTY
74957: LIST
74958: LIST
74959: PUSH
74960: LD_INT 2
74962: NEG
74963: PUSH
74964: LD_INT 0
74966: PUSH
74967: EMPTY
74968: LIST
74969: LIST
74970: PUSH
74971: LD_INT 2
74973: NEG
74974: PUSH
74975: LD_INT 1
74977: NEG
74978: PUSH
74979: EMPTY
74980: LIST
74981: LIST
74982: PUSH
74983: LD_INT 1
74985: NEG
74986: PUSH
74987: LD_INT 3
74989: NEG
74990: PUSH
74991: EMPTY
74992: LIST
74993: LIST
74994: PUSH
74995: LD_INT 0
74997: PUSH
74998: LD_INT 3
75000: NEG
75001: PUSH
75002: EMPTY
75003: LIST
75004: LIST
75005: PUSH
75006: LD_INT 1
75008: PUSH
75009: LD_INT 2
75011: NEG
75012: PUSH
75013: EMPTY
75014: LIST
75015: LIST
75016: PUSH
75017: LD_INT 2
75019: PUSH
75020: LD_INT 1
75022: NEG
75023: PUSH
75024: EMPTY
75025: LIST
75026: LIST
75027: PUSH
75028: LD_INT 3
75030: PUSH
75031: LD_INT 0
75033: PUSH
75034: EMPTY
75035: LIST
75036: LIST
75037: PUSH
75038: LD_INT 3
75040: PUSH
75041: LD_INT 1
75043: PUSH
75044: EMPTY
75045: LIST
75046: LIST
75047: PUSH
75048: LD_INT 1
75050: PUSH
75051: LD_INT 3
75053: PUSH
75054: EMPTY
75055: LIST
75056: LIST
75057: PUSH
75058: LD_INT 0
75060: PUSH
75061: LD_INT 3
75063: PUSH
75064: EMPTY
75065: LIST
75066: LIST
75067: PUSH
75068: LD_INT 1
75070: NEG
75071: PUSH
75072: LD_INT 2
75074: PUSH
75075: EMPTY
75076: LIST
75077: LIST
75078: PUSH
75079: LD_INT 2
75081: NEG
75082: PUSH
75083: LD_INT 1
75085: PUSH
75086: EMPTY
75087: LIST
75088: LIST
75089: PUSH
75090: LD_INT 3
75092: NEG
75093: PUSH
75094: LD_INT 0
75096: PUSH
75097: EMPTY
75098: LIST
75099: LIST
75100: PUSH
75101: LD_INT 3
75103: NEG
75104: PUSH
75105: LD_INT 1
75107: NEG
75108: PUSH
75109: EMPTY
75110: LIST
75111: LIST
75112: PUSH
75113: EMPTY
75114: LIST
75115: LIST
75116: LIST
75117: LIST
75118: LIST
75119: LIST
75120: LIST
75121: LIST
75122: LIST
75123: LIST
75124: LIST
75125: LIST
75126: LIST
75127: LIST
75128: LIST
75129: LIST
75130: LIST
75131: LIST
75132: LIST
75133: LIST
75134: LIST
75135: LIST
75136: LIST
75137: LIST
75138: LIST
75139: LIST
75140: LIST
75141: LIST
75142: LIST
75143: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75144: LD_ADDR_VAR 0 47
75148: PUSH
75149: LD_INT 0
75151: PUSH
75152: LD_INT 0
75154: PUSH
75155: EMPTY
75156: LIST
75157: LIST
75158: PUSH
75159: LD_INT 0
75161: PUSH
75162: LD_INT 1
75164: NEG
75165: PUSH
75166: EMPTY
75167: LIST
75168: LIST
75169: PUSH
75170: LD_INT 1
75172: PUSH
75173: LD_INT 0
75175: PUSH
75176: EMPTY
75177: LIST
75178: LIST
75179: PUSH
75180: LD_INT 1
75182: PUSH
75183: LD_INT 1
75185: PUSH
75186: EMPTY
75187: LIST
75188: LIST
75189: PUSH
75190: LD_INT 0
75192: PUSH
75193: LD_INT 1
75195: PUSH
75196: EMPTY
75197: LIST
75198: LIST
75199: PUSH
75200: LD_INT 1
75202: NEG
75203: PUSH
75204: LD_INT 0
75206: PUSH
75207: EMPTY
75208: LIST
75209: LIST
75210: PUSH
75211: LD_INT 1
75213: NEG
75214: PUSH
75215: LD_INT 1
75217: NEG
75218: PUSH
75219: EMPTY
75220: LIST
75221: LIST
75222: PUSH
75223: LD_INT 1
75225: NEG
75226: PUSH
75227: LD_INT 2
75229: NEG
75230: PUSH
75231: EMPTY
75232: LIST
75233: LIST
75234: PUSH
75235: LD_INT 0
75237: PUSH
75238: LD_INT 2
75240: NEG
75241: PUSH
75242: EMPTY
75243: LIST
75244: LIST
75245: PUSH
75246: LD_INT 1
75248: PUSH
75249: LD_INT 1
75251: NEG
75252: PUSH
75253: EMPTY
75254: LIST
75255: LIST
75256: PUSH
75257: LD_INT 2
75259: NEG
75260: PUSH
75261: LD_INT 1
75263: NEG
75264: PUSH
75265: EMPTY
75266: LIST
75267: LIST
75268: PUSH
75269: LD_INT 2
75271: NEG
75272: PUSH
75273: LD_INT 2
75275: NEG
75276: PUSH
75277: EMPTY
75278: LIST
75279: LIST
75280: PUSH
75281: EMPTY
75282: LIST
75283: LIST
75284: LIST
75285: LIST
75286: LIST
75287: LIST
75288: LIST
75289: LIST
75290: LIST
75291: LIST
75292: LIST
75293: LIST
75294: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
75295: LD_ADDR_VAR 0 48
75299: PUSH
75300: LD_INT 0
75302: PUSH
75303: LD_INT 0
75305: PUSH
75306: EMPTY
75307: LIST
75308: LIST
75309: PUSH
75310: LD_INT 0
75312: PUSH
75313: LD_INT 1
75315: NEG
75316: PUSH
75317: EMPTY
75318: LIST
75319: LIST
75320: PUSH
75321: LD_INT 1
75323: PUSH
75324: LD_INT 0
75326: PUSH
75327: EMPTY
75328: LIST
75329: LIST
75330: PUSH
75331: LD_INT 1
75333: PUSH
75334: LD_INT 1
75336: PUSH
75337: EMPTY
75338: LIST
75339: LIST
75340: PUSH
75341: LD_INT 0
75343: PUSH
75344: LD_INT 1
75346: PUSH
75347: EMPTY
75348: LIST
75349: LIST
75350: PUSH
75351: LD_INT 1
75353: NEG
75354: PUSH
75355: LD_INT 0
75357: PUSH
75358: EMPTY
75359: LIST
75360: LIST
75361: PUSH
75362: LD_INT 1
75364: NEG
75365: PUSH
75366: LD_INT 1
75368: NEG
75369: PUSH
75370: EMPTY
75371: LIST
75372: LIST
75373: PUSH
75374: LD_INT 1
75376: NEG
75377: PUSH
75378: LD_INT 2
75380: NEG
75381: PUSH
75382: EMPTY
75383: LIST
75384: LIST
75385: PUSH
75386: LD_INT 0
75388: PUSH
75389: LD_INT 2
75391: NEG
75392: PUSH
75393: EMPTY
75394: LIST
75395: LIST
75396: PUSH
75397: LD_INT 1
75399: PUSH
75400: LD_INT 1
75402: NEG
75403: PUSH
75404: EMPTY
75405: LIST
75406: LIST
75407: PUSH
75408: LD_INT 2
75410: PUSH
75411: LD_INT 0
75413: PUSH
75414: EMPTY
75415: LIST
75416: LIST
75417: PUSH
75418: LD_INT 2
75420: PUSH
75421: LD_INT 1
75423: PUSH
75424: EMPTY
75425: LIST
75426: LIST
75427: PUSH
75428: EMPTY
75429: LIST
75430: LIST
75431: LIST
75432: LIST
75433: LIST
75434: LIST
75435: LIST
75436: LIST
75437: LIST
75438: LIST
75439: LIST
75440: LIST
75441: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
75442: LD_ADDR_VAR 0 49
75446: PUSH
75447: LD_INT 0
75449: PUSH
75450: LD_INT 0
75452: PUSH
75453: EMPTY
75454: LIST
75455: LIST
75456: PUSH
75457: LD_INT 0
75459: PUSH
75460: LD_INT 1
75462: NEG
75463: PUSH
75464: EMPTY
75465: LIST
75466: LIST
75467: PUSH
75468: LD_INT 1
75470: PUSH
75471: LD_INT 0
75473: PUSH
75474: EMPTY
75475: LIST
75476: LIST
75477: PUSH
75478: LD_INT 1
75480: PUSH
75481: LD_INT 1
75483: PUSH
75484: EMPTY
75485: LIST
75486: LIST
75487: PUSH
75488: LD_INT 0
75490: PUSH
75491: LD_INT 1
75493: PUSH
75494: EMPTY
75495: LIST
75496: LIST
75497: PUSH
75498: LD_INT 1
75500: NEG
75501: PUSH
75502: LD_INT 0
75504: PUSH
75505: EMPTY
75506: LIST
75507: LIST
75508: PUSH
75509: LD_INT 1
75511: NEG
75512: PUSH
75513: LD_INT 1
75515: NEG
75516: PUSH
75517: EMPTY
75518: LIST
75519: LIST
75520: PUSH
75521: LD_INT 1
75523: PUSH
75524: LD_INT 1
75526: NEG
75527: PUSH
75528: EMPTY
75529: LIST
75530: LIST
75531: PUSH
75532: LD_INT 2
75534: PUSH
75535: LD_INT 0
75537: PUSH
75538: EMPTY
75539: LIST
75540: LIST
75541: PUSH
75542: LD_INT 2
75544: PUSH
75545: LD_INT 1
75547: PUSH
75548: EMPTY
75549: LIST
75550: LIST
75551: PUSH
75552: LD_INT 2
75554: PUSH
75555: LD_INT 2
75557: PUSH
75558: EMPTY
75559: LIST
75560: LIST
75561: PUSH
75562: LD_INT 1
75564: PUSH
75565: LD_INT 2
75567: PUSH
75568: EMPTY
75569: LIST
75570: LIST
75571: PUSH
75572: EMPTY
75573: LIST
75574: LIST
75575: LIST
75576: LIST
75577: LIST
75578: LIST
75579: LIST
75580: LIST
75581: LIST
75582: LIST
75583: LIST
75584: LIST
75585: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
75586: LD_ADDR_VAR 0 50
75590: PUSH
75591: LD_INT 0
75593: PUSH
75594: LD_INT 0
75596: PUSH
75597: EMPTY
75598: LIST
75599: LIST
75600: PUSH
75601: LD_INT 0
75603: PUSH
75604: LD_INT 1
75606: NEG
75607: PUSH
75608: EMPTY
75609: LIST
75610: LIST
75611: PUSH
75612: LD_INT 1
75614: PUSH
75615: LD_INT 0
75617: PUSH
75618: EMPTY
75619: LIST
75620: LIST
75621: PUSH
75622: LD_INT 1
75624: PUSH
75625: LD_INT 1
75627: PUSH
75628: EMPTY
75629: LIST
75630: LIST
75631: PUSH
75632: LD_INT 0
75634: PUSH
75635: LD_INT 1
75637: PUSH
75638: EMPTY
75639: LIST
75640: LIST
75641: PUSH
75642: LD_INT 1
75644: NEG
75645: PUSH
75646: LD_INT 0
75648: PUSH
75649: EMPTY
75650: LIST
75651: LIST
75652: PUSH
75653: LD_INT 1
75655: NEG
75656: PUSH
75657: LD_INT 1
75659: NEG
75660: PUSH
75661: EMPTY
75662: LIST
75663: LIST
75664: PUSH
75665: LD_INT 2
75667: PUSH
75668: LD_INT 1
75670: PUSH
75671: EMPTY
75672: LIST
75673: LIST
75674: PUSH
75675: LD_INT 2
75677: PUSH
75678: LD_INT 2
75680: PUSH
75681: EMPTY
75682: LIST
75683: LIST
75684: PUSH
75685: LD_INT 1
75687: PUSH
75688: LD_INT 2
75690: PUSH
75691: EMPTY
75692: LIST
75693: LIST
75694: PUSH
75695: LD_INT 0
75697: PUSH
75698: LD_INT 2
75700: PUSH
75701: EMPTY
75702: LIST
75703: LIST
75704: PUSH
75705: LD_INT 1
75707: NEG
75708: PUSH
75709: LD_INT 1
75711: PUSH
75712: EMPTY
75713: LIST
75714: LIST
75715: PUSH
75716: EMPTY
75717: LIST
75718: LIST
75719: LIST
75720: LIST
75721: LIST
75722: LIST
75723: LIST
75724: LIST
75725: LIST
75726: LIST
75727: LIST
75728: LIST
75729: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
75730: LD_ADDR_VAR 0 51
75734: PUSH
75735: LD_INT 0
75737: PUSH
75738: LD_INT 0
75740: PUSH
75741: EMPTY
75742: LIST
75743: LIST
75744: PUSH
75745: LD_INT 0
75747: PUSH
75748: LD_INT 1
75750: NEG
75751: PUSH
75752: EMPTY
75753: LIST
75754: LIST
75755: PUSH
75756: LD_INT 1
75758: PUSH
75759: LD_INT 0
75761: PUSH
75762: EMPTY
75763: LIST
75764: LIST
75765: PUSH
75766: LD_INT 1
75768: PUSH
75769: LD_INT 1
75771: PUSH
75772: EMPTY
75773: LIST
75774: LIST
75775: PUSH
75776: LD_INT 0
75778: PUSH
75779: LD_INT 1
75781: PUSH
75782: EMPTY
75783: LIST
75784: LIST
75785: PUSH
75786: LD_INT 1
75788: NEG
75789: PUSH
75790: LD_INT 0
75792: PUSH
75793: EMPTY
75794: LIST
75795: LIST
75796: PUSH
75797: LD_INT 1
75799: NEG
75800: PUSH
75801: LD_INT 1
75803: NEG
75804: PUSH
75805: EMPTY
75806: LIST
75807: LIST
75808: PUSH
75809: LD_INT 1
75811: PUSH
75812: LD_INT 2
75814: PUSH
75815: EMPTY
75816: LIST
75817: LIST
75818: PUSH
75819: LD_INT 0
75821: PUSH
75822: LD_INT 2
75824: PUSH
75825: EMPTY
75826: LIST
75827: LIST
75828: PUSH
75829: LD_INT 1
75831: NEG
75832: PUSH
75833: LD_INT 1
75835: PUSH
75836: EMPTY
75837: LIST
75838: LIST
75839: PUSH
75840: LD_INT 2
75842: NEG
75843: PUSH
75844: LD_INT 0
75846: PUSH
75847: EMPTY
75848: LIST
75849: LIST
75850: PUSH
75851: LD_INT 2
75853: NEG
75854: PUSH
75855: LD_INT 1
75857: NEG
75858: PUSH
75859: EMPTY
75860: LIST
75861: LIST
75862: PUSH
75863: EMPTY
75864: LIST
75865: LIST
75866: LIST
75867: LIST
75868: LIST
75869: LIST
75870: LIST
75871: LIST
75872: LIST
75873: LIST
75874: LIST
75875: LIST
75876: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75877: LD_ADDR_VAR 0 52
75881: PUSH
75882: LD_INT 0
75884: PUSH
75885: LD_INT 0
75887: PUSH
75888: EMPTY
75889: LIST
75890: LIST
75891: PUSH
75892: LD_INT 0
75894: PUSH
75895: LD_INT 1
75897: NEG
75898: PUSH
75899: EMPTY
75900: LIST
75901: LIST
75902: PUSH
75903: LD_INT 1
75905: PUSH
75906: LD_INT 0
75908: PUSH
75909: EMPTY
75910: LIST
75911: LIST
75912: PUSH
75913: LD_INT 1
75915: PUSH
75916: LD_INT 1
75918: PUSH
75919: EMPTY
75920: LIST
75921: LIST
75922: PUSH
75923: LD_INT 0
75925: PUSH
75926: LD_INT 1
75928: PUSH
75929: EMPTY
75930: LIST
75931: LIST
75932: PUSH
75933: LD_INT 1
75935: NEG
75936: PUSH
75937: LD_INT 0
75939: PUSH
75940: EMPTY
75941: LIST
75942: LIST
75943: PUSH
75944: LD_INT 1
75946: NEG
75947: PUSH
75948: LD_INT 1
75950: NEG
75951: PUSH
75952: EMPTY
75953: LIST
75954: LIST
75955: PUSH
75956: LD_INT 1
75958: NEG
75959: PUSH
75960: LD_INT 2
75962: NEG
75963: PUSH
75964: EMPTY
75965: LIST
75966: LIST
75967: PUSH
75968: LD_INT 1
75970: NEG
75971: PUSH
75972: LD_INT 1
75974: PUSH
75975: EMPTY
75976: LIST
75977: LIST
75978: PUSH
75979: LD_INT 2
75981: NEG
75982: PUSH
75983: LD_INT 0
75985: PUSH
75986: EMPTY
75987: LIST
75988: LIST
75989: PUSH
75990: LD_INT 2
75992: NEG
75993: PUSH
75994: LD_INT 1
75996: NEG
75997: PUSH
75998: EMPTY
75999: LIST
76000: LIST
76001: PUSH
76002: LD_INT 2
76004: NEG
76005: PUSH
76006: LD_INT 2
76008: NEG
76009: PUSH
76010: EMPTY
76011: LIST
76012: LIST
76013: PUSH
76014: EMPTY
76015: LIST
76016: LIST
76017: LIST
76018: LIST
76019: LIST
76020: LIST
76021: LIST
76022: LIST
76023: LIST
76024: LIST
76025: LIST
76026: LIST
76027: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76028: LD_ADDR_VAR 0 53
76032: PUSH
76033: LD_INT 0
76035: PUSH
76036: LD_INT 0
76038: PUSH
76039: EMPTY
76040: LIST
76041: LIST
76042: PUSH
76043: LD_INT 0
76045: PUSH
76046: LD_INT 1
76048: NEG
76049: PUSH
76050: EMPTY
76051: LIST
76052: LIST
76053: PUSH
76054: LD_INT 1
76056: PUSH
76057: LD_INT 0
76059: PUSH
76060: EMPTY
76061: LIST
76062: LIST
76063: PUSH
76064: LD_INT 1
76066: PUSH
76067: LD_INT 1
76069: PUSH
76070: EMPTY
76071: LIST
76072: LIST
76073: PUSH
76074: LD_INT 0
76076: PUSH
76077: LD_INT 1
76079: PUSH
76080: EMPTY
76081: LIST
76082: LIST
76083: PUSH
76084: LD_INT 1
76086: NEG
76087: PUSH
76088: LD_INT 0
76090: PUSH
76091: EMPTY
76092: LIST
76093: LIST
76094: PUSH
76095: LD_INT 1
76097: NEG
76098: PUSH
76099: LD_INT 1
76101: NEG
76102: PUSH
76103: EMPTY
76104: LIST
76105: LIST
76106: PUSH
76107: LD_INT 1
76109: NEG
76110: PUSH
76111: LD_INT 2
76113: NEG
76114: PUSH
76115: EMPTY
76116: LIST
76117: LIST
76118: PUSH
76119: LD_INT 0
76121: PUSH
76122: LD_INT 2
76124: NEG
76125: PUSH
76126: EMPTY
76127: LIST
76128: LIST
76129: PUSH
76130: LD_INT 1
76132: PUSH
76133: LD_INT 1
76135: NEG
76136: PUSH
76137: EMPTY
76138: LIST
76139: LIST
76140: PUSH
76141: LD_INT 2
76143: PUSH
76144: LD_INT 0
76146: PUSH
76147: EMPTY
76148: LIST
76149: LIST
76150: PUSH
76151: LD_INT 2
76153: PUSH
76154: LD_INT 1
76156: PUSH
76157: EMPTY
76158: LIST
76159: LIST
76160: PUSH
76161: LD_INT 2
76163: PUSH
76164: LD_INT 2
76166: PUSH
76167: EMPTY
76168: LIST
76169: LIST
76170: PUSH
76171: LD_INT 1
76173: PUSH
76174: LD_INT 2
76176: PUSH
76177: EMPTY
76178: LIST
76179: LIST
76180: PUSH
76181: LD_INT 0
76183: PUSH
76184: LD_INT 2
76186: PUSH
76187: EMPTY
76188: LIST
76189: LIST
76190: PUSH
76191: LD_INT 1
76193: NEG
76194: PUSH
76195: LD_INT 1
76197: PUSH
76198: EMPTY
76199: LIST
76200: LIST
76201: PUSH
76202: LD_INT 2
76204: NEG
76205: PUSH
76206: LD_INT 0
76208: PUSH
76209: EMPTY
76210: LIST
76211: LIST
76212: PUSH
76213: LD_INT 2
76215: NEG
76216: PUSH
76217: LD_INT 1
76219: NEG
76220: PUSH
76221: EMPTY
76222: LIST
76223: LIST
76224: PUSH
76225: LD_INT 2
76227: NEG
76228: PUSH
76229: LD_INT 2
76231: NEG
76232: PUSH
76233: EMPTY
76234: LIST
76235: LIST
76236: PUSH
76237: EMPTY
76238: LIST
76239: LIST
76240: LIST
76241: LIST
76242: LIST
76243: LIST
76244: LIST
76245: LIST
76246: LIST
76247: LIST
76248: LIST
76249: LIST
76250: LIST
76251: LIST
76252: LIST
76253: LIST
76254: LIST
76255: LIST
76256: LIST
76257: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76258: LD_ADDR_VAR 0 54
76262: PUSH
76263: LD_INT 0
76265: PUSH
76266: LD_INT 0
76268: PUSH
76269: EMPTY
76270: LIST
76271: LIST
76272: PUSH
76273: LD_INT 0
76275: PUSH
76276: LD_INT 1
76278: NEG
76279: PUSH
76280: EMPTY
76281: LIST
76282: LIST
76283: PUSH
76284: LD_INT 1
76286: PUSH
76287: LD_INT 0
76289: PUSH
76290: EMPTY
76291: LIST
76292: LIST
76293: PUSH
76294: LD_INT 1
76296: PUSH
76297: LD_INT 1
76299: PUSH
76300: EMPTY
76301: LIST
76302: LIST
76303: PUSH
76304: LD_INT 0
76306: PUSH
76307: LD_INT 1
76309: PUSH
76310: EMPTY
76311: LIST
76312: LIST
76313: PUSH
76314: LD_INT 1
76316: NEG
76317: PUSH
76318: LD_INT 0
76320: PUSH
76321: EMPTY
76322: LIST
76323: LIST
76324: PUSH
76325: LD_INT 1
76327: NEG
76328: PUSH
76329: LD_INT 1
76331: NEG
76332: PUSH
76333: EMPTY
76334: LIST
76335: LIST
76336: PUSH
76337: LD_INT 1
76339: NEG
76340: PUSH
76341: LD_INT 2
76343: NEG
76344: PUSH
76345: EMPTY
76346: LIST
76347: LIST
76348: PUSH
76349: LD_INT 0
76351: PUSH
76352: LD_INT 2
76354: NEG
76355: PUSH
76356: EMPTY
76357: LIST
76358: LIST
76359: PUSH
76360: LD_INT 1
76362: PUSH
76363: LD_INT 1
76365: NEG
76366: PUSH
76367: EMPTY
76368: LIST
76369: LIST
76370: PUSH
76371: LD_INT 2
76373: PUSH
76374: LD_INT 0
76376: PUSH
76377: EMPTY
76378: LIST
76379: LIST
76380: PUSH
76381: LD_INT 2
76383: PUSH
76384: LD_INT 1
76386: PUSH
76387: EMPTY
76388: LIST
76389: LIST
76390: PUSH
76391: LD_INT 2
76393: PUSH
76394: LD_INT 2
76396: PUSH
76397: EMPTY
76398: LIST
76399: LIST
76400: PUSH
76401: LD_INT 1
76403: PUSH
76404: LD_INT 2
76406: PUSH
76407: EMPTY
76408: LIST
76409: LIST
76410: PUSH
76411: LD_INT 0
76413: PUSH
76414: LD_INT 2
76416: PUSH
76417: EMPTY
76418: LIST
76419: LIST
76420: PUSH
76421: LD_INT 1
76423: NEG
76424: PUSH
76425: LD_INT 1
76427: PUSH
76428: EMPTY
76429: LIST
76430: LIST
76431: PUSH
76432: LD_INT 2
76434: NEG
76435: PUSH
76436: LD_INT 0
76438: PUSH
76439: EMPTY
76440: LIST
76441: LIST
76442: PUSH
76443: LD_INT 2
76445: NEG
76446: PUSH
76447: LD_INT 1
76449: NEG
76450: PUSH
76451: EMPTY
76452: LIST
76453: LIST
76454: PUSH
76455: LD_INT 2
76457: NEG
76458: PUSH
76459: LD_INT 2
76461: NEG
76462: PUSH
76463: EMPTY
76464: LIST
76465: LIST
76466: PUSH
76467: EMPTY
76468: LIST
76469: LIST
76470: LIST
76471: LIST
76472: LIST
76473: LIST
76474: LIST
76475: LIST
76476: LIST
76477: LIST
76478: LIST
76479: LIST
76480: LIST
76481: LIST
76482: LIST
76483: LIST
76484: LIST
76485: LIST
76486: LIST
76487: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76488: LD_ADDR_VAR 0 55
76492: PUSH
76493: LD_INT 0
76495: PUSH
76496: LD_INT 0
76498: PUSH
76499: EMPTY
76500: LIST
76501: LIST
76502: PUSH
76503: LD_INT 0
76505: PUSH
76506: LD_INT 1
76508: NEG
76509: PUSH
76510: EMPTY
76511: LIST
76512: LIST
76513: PUSH
76514: LD_INT 1
76516: PUSH
76517: LD_INT 0
76519: PUSH
76520: EMPTY
76521: LIST
76522: LIST
76523: PUSH
76524: LD_INT 1
76526: PUSH
76527: LD_INT 1
76529: PUSH
76530: EMPTY
76531: LIST
76532: LIST
76533: PUSH
76534: LD_INT 0
76536: PUSH
76537: LD_INT 1
76539: PUSH
76540: EMPTY
76541: LIST
76542: LIST
76543: PUSH
76544: LD_INT 1
76546: NEG
76547: PUSH
76548: LD_INT 0
76550: PUSH
76551: EMPTY
76552: LIST
76553: LIST
76554: PUSH
76555: LD_INT 1
76557: NEG
76558: PUSH
76559: LD_INT 1
76561: NEG
76562: PUSH
76563: EMPTY
76564: LIST
76565: LIST
76566: PUSH
76567: LD_INT 1
76569: NEG
76570: PUSH
76571: LD_INT 2
76573: NEG
76574: PUSH
76575: EMPTY
76576: LIST
76577: LIST
76578: PUSH
76579: LD_INT 0
76581: PUSH
76582: LD_INT 2
76584: NEG
76585: PUSH
76586: EMPTY
76587: LIST
76588: LIST
76589: PUSH
76590: LD_INT 1
76592: PUSH
76593: LD_INT 1
76595: NEG
76596: PUSH
76597: EMPTY
76598: LIST
76599: LIST
76600: PUSH
76601: LD_INT 2
76603: PUSH
76604: LD_INT 0
76606: PUSH
76607: EMPTY
76608: LIST
76609: LIST
76610: PUSH
76611: LD_INT 2
76613: PUSH
76614: LD_INT 1
76616: PUSH
76617: EMPTY
76618: LIST
76619: LIST
76620: PUSH
76621: LD_INT 2
76623: PUSH
76624: LD_INT 2
76626: PUSH
76627: EMPTY
76628: LIST
76629: LIST
76630: PUSH
76631: LD_INT 1
76633: PUSH
76634: LD_INT 2
76636: PUSH
76637: EMPTY
76638: LIST
76639: LIST
76640: PUSH
76641: LD_INT 0
76643: PUSH
76644: LD_INT 2
76646: PUSH
76647: EMPTY
76648: LIST
76649: LIST
76650: PUSH
76651: LD_INT 1
76653: NEG
76654: PUSH
76655: LD_INT 1
76657: PUSH
76658: EMPTY
76659: LIST
76660: LIST
76661: PUSH
76662: LD_INT 2
76664: NEG
76665: PUSH
76666: LD_INT 0
76668: PUSH
76669: EMPTY
76670: LIST
76671: LIST
76672: PUSH
76673: LD_INT 2
76675: NEG
76676: PUSH
76677: LD_INT 1
76679: NEG
76680: PUSH
76681: EMPTY
76682: LIST
76683: LIST
76684: PUSH
76685: LD_INT 2
76687: NEG
76688: PUSH
76689: LD_INT 2
76691: NEG
76692: PUSH
76693: EMPTY
76694: LIST
76695: LIST
76696: PUSH
76697: EMPTY
76698: LIST
76699: LIST
76700: LIST
76701: LIST
76702: LIST
76703: LIST
76704: LIST
76705: LIST
76706: LIST
76707: LIST
76708: LIST
76709: LIST
76710: LIST
76711: LIST
76712: LIST
76713: LIST
76714: LIST
76715: LIST
76716: LIST
76717: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76718: LD_ADDR_VAR 0 56
76722: PUSH
76723: LD_INT 0
76725: PUSH
76726: LD_INT 0
76728: PUSH
76729: EMPTY
76730: LIST
76731: LIST
76732: PUSH
76733: LD_INT 0
76735: PUSH
76736: LD_INT 1
76738: NEG
76739: PUSH
76740: EMPTY
76741: LIST
76742: LIST
76743: PUSH
76744: LD_INT 1
76746: PUSH
76747: LD_INT 0
76749: PUSH
76750: EMPTY
76751: LIST
76752: LIST
76753: PUSH
76754: LD_INT 1
76756: PUSH
76757: LD_INT 1
76759: PUSH
76760: EMPTY
76761: LIST
76762: LIST
76763: PUSH
76764: LD_INT 0
76766: PUSH
76767: LD_INT 1
76769: PUSH
76770: EMPTY
76771: LIST
76772: LIST
76773: PUSH
76774: LD_INT 1
76776: NEG
76777: PUSH
76778: LD_INT 0
76780: PUSH
76781: EMPTY
76782: LIST
76783: LIST
76784: PUSH
76785: LD_INT 1
76787: NEG
76788: PUSH
76789: LD_INT 1
76791: NEG
76792: PUSH
76793: EMPTY
76794: LIST
76795: LIST
76796: PUSH
76797: LD_INT 1
76799: NEG
76800: PUSH
76801: LD_INT 2
76803: NEG
76804: PUSH
76805: EMPTY
76806: LIST
76807: LIST
76808: PUSH
76809: LD_INT 0
76811: PUSH
76812: LD_INT 2
76814: NEG
76815: PUSH
76816: EMPTY
76817: LIST
76818: LIST
76819: PUSH
76820: LD_INT 1
76822: PUSH
76823: LD_INT 1
76825: NEG
76826: PUSH
76827: EMPTY
76828: LIST
76829: LIST
76830: PUSH
76831: LD_INT 2
76833: PUSH
76834: LD_INT 0
76836: PUSH
76837: EMPTY
76838: LIST
76839: LIST
76840: PUSH
76841: LD_INT 2
76843: PUSH
76844: LD_INT 1
76846: PUSH
76847: EMPTY
76848: LIST
76849: LIST
76850: PUSH
76851: LD_INT 2
76853: PUSH
76854: LD_INT 2
76856: PUSH
76857: EMPTY
76858: LIST
76859: LIST
76860: PUSH
76861: LD_INT 1
76863: PUSH
76864: LD_INT 2
76866: PUSH
76867: EMPTY
76868: LIST
76869: LIST
76870: PUSH
76871: LD_INT 0
76873: PUSH
76874: LD_INT 2
76876: PUSH
76877: EMPTY
76878: LIST
76879: LIST
76880: PUSH
76881: LD_INT 1
76883: NEG
76884: PUSH
76885: LD_INT 1
76887: PUSH
76888: EMPTY
76889: LIST
76890: LIST
76891: PUSH
76892: LD_INT 2
76894: NEG
76895: PUSH
76896: LD_INT 0
76898: PUSH
76899: EMPTY
76900: LIST
76901: LIST
76902: PUSH
76903: LD_INT 2
76905: NEG
76906: PUSH
76907: LD_INT 1
76909: NEG
76910: PUSH
76911: EMPTY
76912: LIST
76913: LIST
76914: PUSH
76915: LD_INT 2
76917: NEG
76918: PUSH
76919: LD_INT 2
76921: NEG
76922: PUSH
76923: EMPTY
76924: LIST
76925: LIST
76926: PUSH
76927: EMPTY
76928: LIST
76929: LIST
76930: LIST
76931: LIST
76932: LIST
76933: LIST
76934: LIST
76935: LIST
76936: LIST
76937: LIST
76938: LIST
76939: LIST
76940: LIST
76941: LIST
76942: LIST
76943: LIST
76944: LIST
76945: LIST
76946: LIST
76947: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76948: LD_ADDR_VAR 0 57
76952: PUSH
76953: LD_INT 0
76955: PUSH
76956: LD_INT 0
76958: PUSH
76959: EMPTY
76960: LIST
76961: LIST
76962: PUSH
76963: LD_INT 0
76965: PUSH
76966: LD_INT 1
76968: NEG
76969: PUSH
76970: EMPTY
76971: LIST
76972: LIST
76973: PUSH
76974: LD_INT 1
76976: PUSH
76977: LD_INT 0
76979: PUSH
76980: EMPTY
76981: LIST
76982: LIST
76983: PUSH
76984: LD_INT 1
76986: PUSH
76987: LD_INT 1
76989: PUSH
76990: EMPTY
76991: LIST
76992: LIST
76993: PUSH
76994: LD_INT 0
76996: PUSH
76997: LD_INT 1
76999: PUSH
77000: EMPTY
77001: LIST
77002: LIST
77003: PUSH
77004: LD_INT 1
77006: NEG
77007: PUSH
77008: LD_INT 0
77010: PUSH
77011: EMPTY
77012: LIST
77013: LIST
77014: PUSH
77015: LD_INT 1
77017: NEG
77018: PUSH
77019: LD_INT 1
77021: NEG
77022: PUSH
77023: EMPTY
77024: LIST
77025: LIST
77026: PUSH
77027: LD_INT 1
77029: NEG
77030: PUSH
77031: LD_INT 2
77033: NEG
77034: PUSH
77035: EMPTY
77036: LIST
77037: LIST
77038: PUSH
77039: LD_INT 0
77041: PUSH
77042: LD_INT 2
77044: NEG
77045: PUSH
77046: EMPTY
77047: LIST
77048: LIST
77049: PUSH
77050: LD_INT 1
77052: PUSH
77053: LD_INT 1
77055: NEG
77056: PUSH
77057: EMPTY
77058: LIST
77059: LIST
77060: PUSH
77061: LD_INT 2
77063: PUSH
77064: LD_INT 0
77066: PUSH
77067: EMPTY
77068: LIST
77069: LIST
77070: PUSH
77071: LD_INT 2
77073: PUSH
77074: LD_INT 1
77076: PUSH
77077: EMPTY
77078: LIST
77079: LIST
77080: PUSH
77081: LD_INT 2
77083: PUSH
77084: LD_INT 2
77086: PUSH
77087: EMPTY
77088: LIST
77089: LIST
77090: PUSH
77091: LD_INT 1
77093: PUSH
77094: LD_INT 2
77096: PUSH
77097: EMPTY
77098: LIST
77099: LIST
77100: PUSH
77101: LD_INT 0
77103: PUSH
77104: LD_INT 2
77106: PUSH
77107: EMPTY
77108: LIST
77109: LIST
77110: PUSH
77111: LD_INT 1
77113: NEG
77114: PUSH
77115: LD_INT 1
77117: PUSH
77118: EMPTY
77119: LIST
77120: LIST
77121: PUSH
77122: LD_INT 2
77124: NEG
77125: PUSH
77126: LD_INT 0
77128: PUSH
77129: EMPTY
77130: LIST
77131: LIST
77132: PUSH
77133: LD_INT 2
77135: NEG
77136: PUSH
77137: LD_INT 1
77139: NEG
77140: PUSH
77141: EMPTY
77142: LIST
77143: LIST
77144: PUSH
77145: LD_INT 2
77147: NEG
77148: PUSH
77149: LD_INT 2
77151: NEG
77152: PUSH
77153: EMPTY
77154: LIST
77155: LIST
77156: PUSH
77157: EMPTY
77158: LIST
77159: LIST
77160: LIST
77161: LIST
77162: LIST
77163: LIST
77164: LIST
77165: LIST
77166: LIST
77167: LIST
77168: LIST
77169: LIST
77170: LIST
77171: LIST
77172: LIST
77173: LIST
77174: LIST
77175: LIST
77176: LIST
77177: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77178: LD_ADDR_VAR 0 58
77182: PUSH
77183: LD_INT 0
77185: PUSH
77186: LD_INT 0
77188: PUSH
77189: EMPTY
77190: LIST
77191: LIST
77192: PUSH
77193: LD_INT 0
77195: PUSH
77196: LD_INT 1
77198: NEG
77199: PUSH
77200: EMPTY
77201: LIST
77202: LIST
77203: PUSH
77204: LD_INT 1
77206: PUSH
77207: LD_INT 0
77209: PUSH
77210: EMPTY
77211: LIST
77212: LIST
77213: PUSH
77214: LD_INT 1
77216: PUSH
77217: LD_INT 1
77219: PUSH
77220: EMPTY
77221: LIST
77222: LIST
77223: PUSH
77224: LD_INT 0
77226: PUSH
77227: LD_INT 1
77229: PUSH
77230: EMPTY
77231: LIST
77232: LIST
77233: PUSH
77234: LD_INT 1
77236: NEG
77237: PUSH
77238: LD_INT 0
77240: PUSH
77241: EMPTY
77242: LIST
77243: LIST
77244: PUSH
77245: LD_INT 1
77247: NEG
77248: PUSH
77249: LD_INT 1
77251: NEG
77252: PUSH
77253: EMPTY
77254: LIST
77255: LIST
77256: PUSH
77257: LD_INT 1
77259: NEG
77260: PUSH
77261: LD_INT 2
77263: NEG
77264: PUSH
77265: EMPTY
77266: LIST
77267: LIST
77268: PUSH
77269: LD_INT 0
77271: PUSH
77272: LD_INT 2
77274: NEG
77275: PUSH
77276: EMPTY
77277: LIST
77278: LIST
77279: PUSH
77280: LD_INT 1
77282: PUSH
77283: LD_INT 1
77285: NEG
77286: PUSH
77287: EMPTY
77288: LIST
77289: LIST
77290: PUSH
77291: LD_INT 2
77293: PUSH
77294: LD_INT 0
77296: PUSH
77297: EMPTY
77298: LIST
77299: LIST
77300: PUSH
77301: LD_INT 2
77303: PUSH
77304: LD_INT 1
77306: PUSH
77307: EMPTY
77308: LIST
77309: LIST
77310: PUSH
77311: LD_INT 2
77313: PUSH
77314: LD_INT 2
77316: PUSH
77317: EMPTY
77318: LIST
77319: LIST
77320: PUSH
77321: LD_INT 1
77323: PUSH
77324: LD_INT 2
77326: PUSH
77327: EMPTY
77328: LIST
77329: LIST
77330: PUSH
77331: LD_INT 0
77333: PUSH
77334: LD_INT 2
77336: PUSH
77337: EMPTY
77338: LIST
77339: LIST
77340: PUSH
77341: LD_INT 1
77343: NEG
77344: PUSH
77345: LD_INT 1
77347: PUSH
77348: EMPTY
77349: LIST
77350: LIST
77351: PUSH
77352: LD_INT 2
77354: NEG
77355: PUSH
77356: LD_INT 0
77358: PUSH
77359: EMPTY
77360: LIST
77361: LIST
77362: PUSH
77363: LD_INT 2
77365: NEG
77366: PUSH
77367: LD_INT 1
77369: NEG
77370: PUSH
77371: EMPTY
77372: LIST
77373: LIST
77374: PUSH
77375: LD_INT 2
77377: NEG
77378: PUSH
77379: LD_INT 2
77381: NEG
77382: PUSH
77383: EMPTY
77384: LIST
77385: LIST
77386: PUSH
77387: EMPTY
77388: LIST
77389: LIST
77390: LIST
77391: LIST
77392: LIST
77393: LIST
77394: LIST
77395: LIST
77396: LIST
77397: LIST
77398: LIST
77399: LIST
77400: LIST
77401: LIST
77402: LIST
77403: LIST
77404: LIST
77405: LIST
77406: LIST
77407: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77408: LD_ADDR_VAR 0 59
77412: PUSH
77413: LD_INT 0
77415: PUSH
77416: LD_INT 0
77418: PUSH
77419: EMPTY
77420: LIST
77421: LIST
77422: PUSH
77423: LD_INT 0
77425: PUSH
77426: LD_INT 1
77428: NEG
77429: PUSH
77430: EMPTY
77431: LIST
77432: LIST
77433: PUSH
77434: LD_INT 1
77436: PUSH
77437: LD_INT 0
77439: PUSH
77440: EMPTY
77441: LIST
77442: LIST
77443: PUSH
77444: LD_INT 1
77446: PUSH
77447: LD_INT 1
77449: PUSH
77450: EMPTY
77451: LIST
77452: LIST
77453: PUSH
77454: LD_INT 0
77456: PUSH
77457: LD_INT 1
77459: PUSH
77460: EMPTY
77461: LIST
77462: LIST
77463: PUSH
77464: LD_INT 1
77466: NEG
77467: PUSH
77468: LD_INT 0
77470: PUSH
77471: EMPTY
77472: LIST
77473: LIST
77474: PUSH
77475: LD_INT 1
77477: NEG
77478: PUSH
77479: LD_INT 1
77481: NEG
77482: PUSH
77483: EMPTY
77484: LIST
77485: LIST
77486: PUSH
77487: EMPTY
77488: LIST
77489: LIST
77490: LIST
77491: LIST
77492: LIST
77493: LIST
77494: LIST
77495: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77496: LD_ADDR_VAR 0 60
77500: PUSH
77501: LD_INT 0
77503: PUSH
77504: LD_INT 0
77506: PUSH
77507: EMPTY
77508: LIST
77509: LIST
77510: PUSH
77511: LD_INT 0
77513: PUSH
77514: LD_INT 1
77516: NEG
77517: PUSH
77518: EMPTY
77519: LIST
77520: LIST
77521: PUSH
77522: LD_INT 1
77524: PUSH
77525: LD_INT 0
77527: PUSH
77528: EMPTY
77529: LIST
77530: LIST
77531: PUSH
77532: LD_INT 1
77534: PUSH
77535: LD_INT 1
77537: PUSH
77538: EMPTY
77539: LIST
77540: LIST
77541: PUSH
77542: LD_INT 0
77544: PUSH
77545: LD_INT 1
77547: PUSH
77548: EMPTY
77549: LIST
77550: LIST
77551: PUSH
77552: LD_INT 1
77554: NEG
77555: PUSH
77556: LD_INT 0
77558: PUSH
77559: EMPTY
77560: LIST
77561: LIST
77562: PUSH
77563: LD_INT 1
77565: NEG
77566: PUSH
77567: LD_INT 1
77569: NEG
77570: PUSH
77571: EMPTY
77572: LIST
77573: LIST
77574: PUSH
77575: EMPTY
77576: LIST
77577: LIST
77578: LIST
77579: LIST
77580: LIST
77581: LIST
77582: LIST
77583: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77584: LD_ADDR_VAR 0 61
77588: PUSH
77589: LD_INT 0
77591: PUSH
77592: LD_INT 0
77594: PUSH
77595: EMPTY
77596: LIST
77597: LIST
77598: PUSH
77599: LD_INT 0
77601: PUSH
77602: LD_INT 1
77604: NEG
77605: PUSH
77606: EMPTY
77607: LIST
77608: LIST
77609: PUSH
77610: LD_INT 1
77612: PUSH
77613: LD_INT 0
77615: PUSH
77616: EMPTY
77617: LIST
77618: LIST
77619: PUSH
77620: LD_INT 1
77622: PUSH
77623: LD_INT 1
77625: PUSH
77626: EMPTY
77627: LIST
77628: LIST
77629: PUSH
77630: LD_INT 0
77632: PUSH
77633: LD_INT 1
77635: PUSH
77636: EMPTY
77637: LIST
77638: LIST
77639: PUSH
77640: LD_INT 1
77642: NEG
77643: PUSH
77644: LD_INT 0
77646: PUSH
77647: EMPTY
77648: LIST
77649: LIST
77650: PUSH
77651: LD_INT 1
77653: NEG
77654: PUSH
77655: LD_INT 1
77657: NEG
77658: PUSH
77659: EMPTY
77660: LIST
77661: LIST
77662: PUSH
77663: EMPTY
77664: LIST
77665: LIST
77666: LIST
77667: LIST
77668: LIST
77669: LIST
77670: LIST
77671: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77672: LD_ADDR_VAR 0 62
77676: PUSH
77677: LD_INT 0
77679: PUSH
77680: LD_INT 0
77682: PUSH
77683: EMPTY
77684: LIST
77685: LIST
77686: PUSH
77687: LD_INT 0
77689: PUSH
77690: LD_INT 1
77692: NEG
77693: PUSH
77694: EMPTY
77695: LIST
77696: LIST
77697: PUSH
77698: LD_INT 1
77700: PUSH
77701: LD_INT 0
77703: PUSH
77704: EMPTY
77705: LIST
77706: LIST
77707: PUSH
77708: LD_INT 1
77710: PUSH
77711: LD_INT 1
77713: PUSH
77714: EMPTY
77715: LIST
77716: LIST
77717: PUSH
77718: LD_INT 0
77720: PUSH
77721: LD_INT 1
77723: PUSH
77724: EMPTY
77725: LIST
77726: LIST
77727: PUSH
77728: LD_INT 1
77730: NEG
77731: PUSH
77732: LD_INT 0
77734: PUSH
77735: EMPTY
77736: LIST
77737: LIST
77738: PUSH
77739: LD_INT 1
77741: NEG
77742: PUSH
77743: LD_INT 1
77745: NEG
77746: PUSH
77747: EMPTY
77748: LIST
77749: LIST
77750: PUSH
77751: EMPTY
77752: LIST
77753: LIST
77754: LIST
77755: LIST
77756: LIST
77757: LIST
77758: LIST
77759: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77760: LD_ADDR_VAR 0 63
77764: PUSH
77765: LD_INT 0
77767: PUSH
77768: LD_INT 0
77770: PUSH
77771: EMPTY
77772: LIST
77773: LIST
77774: PUSH
77775: LD_INT 0
77777: PUSH
77778: LD_INT 1
77780: NEG
77781: PUSH
77782: EMPTY
77783: LIST
77784: LIST
77785: PUSH
77786: LD_INT 1
77788: PUSH
77789: LD_INT 0
77791: PUSH
77792: EMPTY
77793: LIST
77794: LIST
77795: PUSH
77796: LD_INT 1
77798: PUSH
77799: LD_INT 1
77801: PUSH
77802: EMPTY
77803: LIST
77804: LIST
77805: PUSH
77806: LD_INT 0
77808: PUSH
77809: LD_INT 1
77811: PUSH
77812: EMPTY
77813: LIST
77814: LIST
77815: PUSH
77816: LD_INT 1
77818: NEG
77819: PUSH
77820: LD_INT 0
77822: PUSH
77823: EMPTY
77824: LIST
77825: LIST
77826: PUSH
77827: LD_INT 1
77829: NEG
77830: PUSH
77831: LD_INT 1
77833: NEG
77834: PUSH
77835: EMPTY
77836: LIST
77837: LIST
77838: PUSH
77839: EMPTY
77840: LIST
77841: LIST
77842: LIST
77843: LIST
77844: LIST
77845: LIST
77846: LIST
77847: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77848: LD_ADDR_VAR 0 64
77852: PUSH
77853: LD_INT 0
77855: PUSH
77856: LD_INT 0
77858: PUSH
77859: EMPTY
77860: LIST
77861: LIST
77862: PUSH
77863: LD_INT 0
77865: PUSH
77866: LD_INT 1
77868: NEG
77869: PUSH
77870: EMPTY
77871: LIST
77872: LIST
77873: PUSH
77874: LD_INT 1
77876: PUSH
77877: LD_INT 0
77879: PUSH
77880: EMPTY
77881: LIST
77882: LIST
77883: PUSH
77884: LD_INT 1
77886: PUSH
77887: LD_INT 1
77889: PUSH
77890: EMPTY
77891: LIST
77892: LIST
77893: PUSH
77894: LD_INT 0
77896: PUSH
77897: LD_INT 1
77899: PUSH
77900: EMPTY
77901: LIST
77902: LIST
77903: PUSH
77904: LD_INT 1
77906: NEG
77907: PUSH
77908: LD_INT 0
77910: PUSH
77911: EMPTY
77912: LIST
77913: LIST
77914: PUSH
77915: LD_INT 1
77917: NEG
77918: PUSH
77919: LD_INT 1
77921: NEG
77922: PUSH
77923: EMPTY
77924: LIST
77925: LIST
77926: PUSH
77927: EMPTY
77928: LIST
77929: LIST
77930: LIST
77931: LIST
77932: LIST
77933: LIST
77934: LIST
77935: ST_TO_ADDR
// end ; 1 :
77936: GO 83833
77938: LD_INT 1
77940: DOUBLE
77941: EQUAL
77942: IFTRUE 77946
77944: GO 80569
77946: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77947: LD_ADDR_VAR 0 11
77951: PUSH
77952: LD_INT 1
77954: NEG
77955: PUSH
77956: LD_INT 3
77958: NEG
77959: PUSH
77960: EMPTY
77961: LIST
77962: LIST
77963: PUSH
77964: LD_INT 0
77966: PUSH
77967: LD_INT 3
77969: NEG
77970: PUSH
77971: EMPTY
77972: LIST
77973: LIST
77974: PUSH
77975: LD_INT 1
77977: PUSH
77978: LD_INT 2
77980: NEG
77981: PUSH
77982: EMPTY
77983: LIST
77984: LIST
77985: PUSH
77986: EMPTY
77987: LIST
77988: LIST
77989: LIST
77990: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77991: LD_ADDR_VAR 0 12
77995: PUSH
77996: LD_INT 2
77998: PUSH
77999: LD_INT 1
78001: NEG
78002: PUSH
78003: EMPTY
78004: LIST
78005: LIST
78006: PUSH
78007: LD_INT 3
78009: PUSH
78010: LD_INT 0
78012: PUSH
78013: EMPTY
78014: LIST
78015: LIST
78016: PUSH
78017: LD_INT 3
78019: PUSH
78020: LD_INT 1
78022: PUSH
78023: EMPTY
78024: LIST
78025: LIST
78026: PUSH
78027: EMPTY
78028: LIST
78029: LIST
78030: LIST
78031: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78032: LD_ADDR_VAR 0 13
78036: PUSH
78037: LD_INT 3
78039: PUSH
78040: LD_INT 2
78042: PUSH
78043: EMPTY
78044: LIST
78045: LIST
78046: PUSH
78047: LD_INT 3
78049: PUSH
78050: LD_INT 3
78052: PUSH
78053: EMPTY
78054: LIST
78055: LIST
78056: PUSH
78057: LD_INT 2
78059: PUSH
78060: LD_INT 3
78062: PUSH
78063: EMPTY
78064: LIST
78065: LIST
78066: PUSH
78067: EMPTY
78068: LIST
78069: LIST
78070: LIST
78071: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78072: LD_ADDR_VAR 0 14
78076: PUSH
78077: LD_INT 1
78079: PUSH
78080: LD_INT 3
78082: PUSH
78083: EMPTY
78084: LIST
78085: LIST
78086: PUSH
78087: LD_INT 0
78089: PUSH
78090: LD_INT 3
78092: PUSH
78093: EMPTY
78094: LIST
78095: LIST
78096: PUSH
78097: LD_INT 1
78099: NEG
78100: PUSH
78101: LD_INT 2
78103: PUSH
78104: EMPTY
78105: LIST
78106: LIST
78107: PUSH
78108: EMPTY
78109: LIST
78110: LIST
78111: LIST
78112: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78113: LD_ADDR_VAR 0 15
78117: PUSH
78118: LD_INT 2
78120: NEG
78121: PUSH
78122: LD_INT 1
78124: PUSH
78125: EMPTY
78126: LIST
78127: LIST
78128: PUSH
78129: LD_INT 3
78131: NEG
78132: PUSH
78133: LD_INT 0
78135: PUSH
78136: EMPTY
78137: LIST
78138: LIST
78139: PUSH
78140: LD_INT 3
78142: NEG
78143: PUSH
78144: LD_INT 1
78146: NEG
78147: PUSH
78148: EMPTY
78149: LIST
78150: LIST
78151: PUSH
78152: EMPTY
78153: LIST
78154: LIST
78155: LIST
78156: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78157: LD_ADDR_VAR 0 16
78161: PUSH
78162: LD_INT 2
78164: NEG
78165: PUSH
78166: LD_INT 3
78168: NEG
78169: PUSH
78170: EMPTY
78171: LIST
78172: LIST
78173: PUSH
78174: LD_INT 3
78176: NEG
78177: PUSH
78178: LD_INT 2
78180: NEG
78181: PUSH
78182: EMPTY
78183: LIST
78184: LIST
78185: PUSH
78186: LD_INT 3
78188: NEG
78189: PUSH
78190: LD_INT 3
78192: NEG
78193: PUSH
78194: EMPTY
78195: LIST
78196: LIST
78197: PUSH
78198: EMPTY
78199: LIST
78200: LIST
78201: LIST
78202: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
78203: LD_ADDR_VAR 0 17
78207: PUSH
78208: LD_INT 1
78210: NEG
78211: PUSH
78212: LD_INT 3
78214: NEG
78215: PUSH
78216: EMPTY
78217: LIST
78218: LIST
78219: PUSH
78220: LD_INT 0
78222: PUSH
78223: LD_INT 3
78225: NEG
78226: PUSH
78227: EMPTY
78228: LIST
78229: LIST
78230: PUSH
78231: LD_INT 1
78233: PUSH
78234: LD_INT 2
78236: NEG
78237: PUSH
78238: EMPTY
78239: LIST
78240: LIST
78241: PUSH
78242: EMPTY
78243: LIST
78244: LIST
78245: LIST
78246: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
78247: LD_ADDR_VAR 0 18
78251: PUSH
78252: LD_INT 2
78254: PUSH
78255: LD_INT 1
78257: NEG
78258: PUSH
78259: EMPTY
78260: LIST
78261: LIST
78262: PUSH
78263: LD_INT 3
78265: PUSH
78266: LD_INT 0
78268: PUSH
78269: EMPTY
78270: LIST
78271: LIST
78272: PUSH
78273: LD_INT 3
78275: PUSH
78276: LD_INT 1
78278: PUSH
78279: EMPTY
78280: LIST
78281: LIST
78282: PUSH
78283: EMPTY
78284: LIST
78285: LIST
78286: LIST
78287: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78288: LD_ADDR_VAR 0 19
78292: PUSH
78293: LD_INT 3
78295: PUSH
78296: LD_INT 2
78298: PUSH
78299: EMPTY
78300: LIST
78301: LIST
78302: PUSH
78303: LD_INT 3
78305: PUSH
78306: LD_INT 3
78308: PUSH
78309: EMPTY
78310: LIST
78311: LIST
78312: PUSH
78313: LD_INT 2
78315: PUSH
78316: LD_INT 3
78318: PUSH
78319: EMPTY
78320: LIST
78321: LIST
78322: PUSH
78323: EMPTY
78324: LIST
78325: LIST
78326: LIST
78327: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78328: LD_ADDR_VAR 0 20
78332: PUSH
78333: LD_INT 1
78335: PUSH
78336: LD_INT 3
78338: PUSH
78339: EMPTY
78340: LIST
78341: LIST
78342: PUSH
78343: LD_INT 0
78345: PUSH
78346: LD_INT 3
78348: PUSH
78349: EMPTY
78350: LIST
78351: LIST
78352: PUSH
78353: LD_INT 1
78355: NEG
78356: PUSH
78357: LD_INT 2
78359: PUSH
78360: EMPTY
78361: LIST
78362: LIST
78363: PUSH
78364: EMPTY
78365: LIST
78366: LIST
78367: LIST
78368: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78369: LD_ADDR_VAR 0 21
78373: PUSH
78374: LD_INT 2
78376: NEG
78377: PUSH
78378: LD_INT 1
78380: PUSH
78381: EMPTY
78382: LIST
78383: LIST
78384: PUSH
78385: LD_INT 3
78387: NEG
78388: PUSH
78389: LD_INT 0
78391: PUSH
78392: EMPTY
78393: LIST
78394: LIST
78395: PUSH
78396: LD_INT 3
78398: NEG
78399: PUSH
78400: LD_INT 1
78402: NEG
78403: PUSH
78404: EMPTY
78405: LIST
78406: LIST
78407: PUSH
78408: EMPTY
78409: LIST
78410: LIST
78411: LIST
78412: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78413: LD_ADDR_VAR 0 22
78417: PUSH
78418: LD_INT 2
78420: NEG
78421: PUSH
78422: LD_INT 3
78424: NEG
78425: PUSH
78426: EMPTY
78427: LIST
78428: LIST
78429: PUSH
78430: LD_INT 3
78432: NEG
78433: PUSH
78434: LD_INT 2
78436: NEG
78437: PUSH
78438: EMPTY
78439: LIST
78440: LIST
78441: PUSH
78442: LD_INT 3
78444: NEG
78445: PUSH
78446: LD_INT 3
78448: NEG
78449: PUSH
78450: EMPTY
78451: LIST
78452: LIST
78453: PUSH
78454: EMPTY
78455: LIST
78456: LIST
78457: LIST
78458: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
78459: LD_ADDR_VAR 0 23
78463: PUSH
78464: LD_INT 0
78466: PUSH
78467: LD_INT 3
78469: NEG
78470: PUSH
78471: EMPTY
78472: LIST
78473: LIST
78474: PUSH
78475: LD_INT 1
78477: NEG
78478: PUSH
78479: LD_INT 4
78481: NEG
78482: PUSH
78483: EMPTY
78484: LIST
78485: LIST
78486: PUSH
78487: LD_INT 1
78489: PUSH
78490: LD_INT 3
78492: NEG
78493: PUSH
78494: EMPTY
78495: LIST
78496: LIST
78497: PUSH
78498: EMPTY
78499: LIST
78500: LIST
78501: LIST
78502: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
78503: LD_ADDR_VAR 0 24
78507: PUSH
78508: LD_INT 3
78510: PUSH
78511: LD_INT 0
78513: PUSH
78514: EMPTY
78515: LIST
78516: LIST
78517: PUSH
78518: LD_INT 3
78520: PUSH
78521: LD_INT 1
78523: NEG
78524: PUSH
78525: EMPTY
78526: LIST
78527: LIST
78528: PUSH
78529: LD_INT 4
78531: PUSH
78532: LD_INT 1
78534: PUSH
78535: EMPTY
78536: LIST
78537: LIST
78538: PUSH
78539: EMPTY
78540: LIST
78541: LIST
78542: LIST
78543: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
78544: LD_ADDR_VAR 0 25
78548: PUSH
78549: LD_INT 3
78551: PUSH
78552: LD_INT 3
78554: PUSH
78555: EMPTY
78556: LIST
78557: LIST
78558: PUSH
78559: LD_INT 4
78561: PUSH
78562: LD_INT 3
78564: PUSH
78565: EMPTY
78566: LIST
78567: LIST
78568: PUSH
78569: LD_INT 3
78571: PUSH
78572: LD_INT 4
78574: PUSH
78575: EMPTY
78576: LIST
78577: LIST
78578: PUSH
78579: EMPTY
78580: LIST
78581: LIST
78582: LIST
78583: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
78584: LD_ADDR_VAR 0 26
78588: PUSH
78589: LD_INT 0
78591: PUSH
78592: LD_INT 3
78594: PUSH
78595: EMPTY
78596: LIST
78597: LIST
78598: PUSH
78599: LD_INT 1
78601: PUSH
78602: LD_INT 4
78604: PUSH
78605: EMPTY
78606: LIST
78607: LIST
78608: PUSH
78609: LD_INT 1
78611: NEG
78612: PUSH
78613: LD_INT 3
78615: PUSH
78616: EMPTY
78617: LIST
78618: LIST
78619: PUSH
78620: EMPTY
78621: LIST
78622: LIST
78623: LIST
78624: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
78625: LD_ADDR_VAR 0 27
78629: PUSH
78630: LD_INT 3
78632: NEG
78633: PUSH
78634: LD_INT 0
78636: PUSH
78637: EMPTY
78638: LIST
78639: LIST
78640: PUSH
78641: LD_INT 3
78643: NEG
78644: PUSH
78645: LD_INT 1
78647: PUSH
78648: EMPTY
78649: LIST
78650: LIST
78651: PUSH
78652: LD_INT 4
78654: NEG
78655: PUSH
78656: LD_INT 1
78658: NEG
78659: PUSH
78660: EMPTY
78661: LIST
78662: LIST
78663: PUSH
78664: EMPTY
78665: LIST
78666: LIST
78667: LIST
78668: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
78669: LD_ADDR_VAR 0 28
78673: PUSH
78674: LD_INT 3
78676: NEG
78677: PUSH
78678: LD_INT 3
78680: NEG
78681: PUSH
78682: EMPTY
78683: LIST
78684: LIST
78685: PUSH
78686: LD_INT 3
78688: NEG
78689: PUSH
78690: LD_INT 4
78692: NEG
78693: PUSH
78694: EMPTY
78695: LIST
78696: LIST
78697: PUSH
78698: LD_INT 4
78700: NEG
78701: PUSH
78702: LD_INT 3
78704: NEG
78705: PUSH
78706: EMPTY
78707: LIST
78708: LIST
78709: PUSH
78710: EMPTY
78711: LIST
78712: LIST
78713: LIST
78714: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
78715: LD_ADDR_VAR 0 29
78719: PUSH
78720: LD_INT 1
78722: NEG
78723: PUSH
78724: LD_INT 3
78726: NEG
78727: PUSH
78728: EMPTY
78729: LIST
78730: LIST
78731: PUSH
78732: LD_INT 0
78734: PUSH
78735: LD_INT 3
78737: NEG
78738: PUSH
78739: EMPTY
78740: LIST
78741: LIST
78742: PUSH
78743: LD_INT 1
78745: PUSH
78746: LD_INT 2
78748: NEG
78749: PUSH
78750: EMPTY
78751: LIST
78752: LIST
78753: PUSH
78754: LD_INT 1
78756: NEG
78757: PUSH
78758: LD_INT 4
78760: NEG
78761: PUSH
78762: EMPTY
78763: LIST
78764: LIST
78765: PUSH
78766: LD_INT 0
78768: PUSH
78769: LD_INT 4
78771: NEG
78772: PUSH
78773: EMPTY
78774: LIST
78775: LIST
78776: PUSH
78777: LD_INT 1
78779: PUSH
78780: LD_INT 3
78782: NEG
78783: PUSH
78784: EMPTY
78785: LIST
78786: LIST
78787: PUSH
78788: LD_INT 1
78790: NEG
78791: PUSH
78792: LD_INT 5
78794: NEG
78795: PUSH
78796: EMPTY
78797: LIST
78798: LIST
78799: PUSH
78800: LD_INT 0
78802: PUSH
78803: LD_INT 5
78805: NEG
78806: PUSH
78807: EMPTY
78808: LIST
78809: LIST
78810: PUSH
78811: LD_INT 1
78813: PUSH
78814: LD_INT 4
78816: NEG
78817: PUSH
78818: EMPTY
78819: LIST
78820: LIST
78821: PUSH
78822: LD_INT 1
78824: NEG
78825: PUSH
78826: LD_INT 6
78828: NEG
78829: PUSH
78830: EMPTY
78831: LIST
78832: LIST
78833: PUSH
78834: LD_INT 0
78836: PUSH
78837: LD_INT 6
78839: NEG
78840: PUSH
78841: EMPTY
78842: LIST
78843: LIST
78844: PUSH
78845: LD_INT 1
78847: PUSH
78848: LD_INT 5
78850: NEG
78851: PUSH
78852: EMPTY
78853: LIST
78854: LIST
78855: PUSH
78856: EMPTY
78857: LIST
78858: LIST
78859: LIST
78860: LIST
78861: LIST
78862: LIST
78863: LIST
78864: LIST
78865: LIST
78866: LIST
78867: LIST
78868: LIST
78869: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
78870: LD_ADDR_VAR 0 30
78874: PUSH
78875: LD_INT 2
78877: PUSH
78878: LD_INT 1
78880: NEG
78881: PUSH
78882: EMPTY
78883: LIST
78884: LIST
78885: PUSH
78886: LD_INT 3
78888: PUSH
78889: LD_INT 0
78891: PUSH
78892: EMPTY
78893: LIST
78894: LIST
78895: PUSH
78896: LD_INT 3
78898: PUSH
78899: LD_INT 1
78901: PUSH
78902: EMPTY
78903: LIST
78904: LIST
78905: PUSH
78906: LD_INT 3
78908: PUSH
78909: LD_INT 1
78911: NEG
78912: PUSH
78913: EMPTY
78914: LIST
78915: LIST
78916: PUSH
78917: LD_INT 4
78919: PUSH
78920: LD_INT 0
78922: PUSH
78923: EMPTY
78924: LIST
78925: LIST
78926: PUSH
78927: LD_INT 4
78929: PUSH
78930: LD_INT 1
78932: PUSH
78933: EMPTY
78934: LIST
78935: LIST
78936: PUSH
78937: LD_INT 4
78939: PUSH
78940: LD_INT 1
78942: NEG
78943: PUSH
78944: EMPTY
78945: LIST
78946: LIST
78947: PUSH
78948: LD_INT 5
78950: PUSH
78951: LD_INT 0
78953: PUSH
78954: EMPTY
78955: LIST
78956: LIST
78957: PUSH
78958: LD_INT 5
78960: PUSH
78961: LD_INT 1
78963: PUSH
78964: EMPTY
78965: LIST
78966: LIST
78967: PUSH
78968: LD_INT 5
78970: PUSH
78971: LD_INT 1
78973: NEG
78974: PUSH
78975: EMPTY
78976: LIST
78977: LIST
78978: PUSH
78979: LD_INT 6
78981: PUSH
78982: LD_INT 0
78984: PUSH
78985: EMPTY
78986: LIST
78987: LIST
78988: PUSH
78989: LD_INT 6
78991: PUSH
78992: LD_INT 1
78994: PUSH
78995: EMPTY
78996: LIST
78997: LIST
78998: PUSH
78999: EMPTY
79000: LIST
79001: LIST
79002: LIST
79003: LIST
79004: LIST
79005: LIST
79006: LIST
79007: LIST
79008: LIST
79009: LIST
79010: LIST
79011: LIST
79012: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
79013: LD_ADDR_VAR 0 31
79017: PUSH
79018: LD_INT 3
79020: PUSH
79021: LD_INT 2
79023: PUSH
79024: EMPTY
79025: LIST
79026: LIST
79027: PUSH
79028: LD_INT 3
79030: PUSH
79031: LD_INT 3
79033: PUSH
79034: EMPTY
79035: LIST
79036: LIST
79037: PUSH
79038: LD_INT 2
79040: PUSH
79041: LD_INT 3
79043: PUSH
79044: EMPTY
79045: LIST
79046: LIST
79047: PUSH
79048: LD_INT 4
79050: PUSH
79051: LD_INT 3
79053: PUSH
79054: EMPTY
79055: LIST
79056: LIST
79057: PUSH
79058: LD_INT 4
79060: PUSH
79061: LD_INT 4
79063: PUSH
79064: EMPTY
79065: LIST
79066: LIST
79067: PUSH
79068: LD_INT 3
79070: PUSH
79071: LD_INT 4
79073: PUSH
79074: EMPTY
79075: LIST
79076: LIST
79077: PUSH
79078: LD_INT 5
79080: PUSH
79081: LD_INT 4
79083: PUSH
79084: EMPTY
79085: LIST
79086: LIST
79087: PUSH
79088: LD_INT 5
79090: PUSH
79091: LD_INT 5
79093: PUSH
79094: EMPTY
79095: LIST
79096: LIST
79097: PUSH
79098: LD_INT 4
79100: PUSH
79101: LD_INT 5
79103: PUSH
79104: EMPTY
79105: LIST
79106: LIST
79107: PUSH
79108: LD_INT 6
79110: PUSH
79111: LD_INT 5
79113: PUSH
79114: EMPTY
79115: LIST
79116: LIST
79117: PUSH
79118: LD_INT 6
79120: PUSH
79121: LD_INT 6
79123: PUSH
79124: EMPTY
79125: LIST
79126: LIST
79127: PUSH
79128: LD_INT 5
79130: PUSH
79131: LD_INT 6
79133: PUSH
79134: EMPTY
79135: LIST
79136: LIST
79137: PUSH
79138: EMPTY
79139: LIST
79140: LIST
79141: LIST
79142: LIST
79143: LIST
79144: LIST
79145: LIST
79146: LIST
79147: LIST
79148: LIST
79149: LIST
79150: LIST
79151: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
79152: LD_ADDR_VAR 0 32
79156: PUSH
79157: LD_INT 1
79159: PUSH
79160: LD_INT 3
79162: PUSH
79163: EMPTY
79164: LIST
79165: LIST
79166: PUSH
79167: LD_INT 0
79169: PUSH
79170: LD_INT 3
79172: PUSH
79173: EMPTY
79174: LIST
79175: LIST
79176: PUSH
79177: LD_INT 1
79179: NEG
79180: PUSH
79181: LD_INT 2
79183: PUSH
79184: EMPTY
79185: LIST
79186: LIST
79187: PUSH
79188: LD_INT 1
79190: PUSH
79191: LD_INT 4
79193: PUSH
79194: EMPTY
79195: LIST
79196: LIST
79197: PUSH
79198: LD_INT 0
79200: PUSH
79201: LD_INT 4
79203: PUSH
79204: EMPTY
79205: LIST
79206: LIST
79207: PUSH
79208: LD_INT 1
79210: NEG
79211: PUSH
79212: LD_INT 3
79214: PUSH
79215: EMPTY
79216: LIST
79217: LIST
79218: PUSH
79219: LD_INT 1
79221: PUSH
79222: LD_INT 5
79224: PUSH
79225: EMPTY
79226: LIST
79227: LIST
79228: PUSH
79229: LD_INT 0
79231: PUSH
79232: LD_INT 5
79234: PUSH
79235: EMPTY
79236: LIST
79237: LIST
79238: PUSH
79239: LD_INT 1
79241: NEG
79242: PUSH
79243: LD_INT 4
79245: PUSH
79246: EMPTY
79247: LIST
79248: LIST
79249: PUSH
79250: LD_INT 1
79252: PUSH
79253: LD_INT 6
79255: PUSH
79256: EMPTY
79257: LIST
79258: LIST
79259: PUSH
79260: LD_INT 0
79262: PUSH
79263: LD_INT 6
79265: PUSH
79266: EMPTY
79267: LIST
79268: LIST
79269: PUSH
79270: LD_INT 1
79272: NEG
79273: PUSH
79274: LD_INT 5
79276: PUSH
79277: EMPTY
79278: LIST
79279: LIST
79280: PUSH
79281: EMPTY
79282: LIST
79283: LIST
79284: LIST
79285: LIST
79286: LIST
79287: LIST
79288: LIST
79289: LIST
79290: LIST
79291: LIST
79292: LIST
79293: LIST
79294: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
79295: LD_ADDR_VAR 0 33
79299: PUSH
79300: LD_INT 2
79302: NEG
79303: PUSH
79304: LD_INT 1
79306: PUSH
79307: EMPTY
79308: LIST
79309: LIST
79310: PUSH
79311: LD_INT 3
79313: NEG
79314: PUSH
79315: LD_INT 0
79317: PUSH
79318: EMPTY
79319: LIST
79320: LIST
79321: PUSH
79322: LD_INT 3
79324: NEG
79325: PUSH
79326: LD_INT 1
79328: NEG
79329: PUSH
79330: EMPTY
79331: LIST
79332: LIST
79333: PUSH
79334: LD_INT 3
79336: NEG
79337: PUSH
79338: LD_INT 1
79340: PUSH
79341: EMPTY
79342: LIST
79343: LIST
79344: PUSH
79345: LD_INT 4
79347: NEG
79348: PUSH
79349: LD_INT 0
79351: PUSH
79352: EMPTY
79353: LIST
79354: LIST
79355: PUSH
79356: LD_INT 4
79358: NEG
79359: PUSH
79360: LD_INT 1
79362: NEG
79363: PUSH
79364: EMPTY
79365: LIST
79366: LIST
79367: PUSH
79368: LD_INT 4
79370: NEG
79371: PUSH
79372: LD_INT 1
79374: PUSH
79375: EMPTY
79376: LIST
79377: LIST
79378: PUSH
79379: LD_INT 5
79381: NEG
79382: PUSH
79383: LD_INT 0
79385: PUSH
79386: EMPTY
79387: LIST
79388: LIST
79389: PUSH
79390: LD_INT 5
79392: NEG
79393: PUSH
79394: LD_INT 1
79396: NEG
79397: PUSH
79398: EMPTY
79399: LIST
79400: LIST
79401: PUSH
79402: LD_INT 5
79404: NEG
79405: PUSH
79406: LD_INT 1
79408: PUSH
79409: EMPTY
79410: LIST
79411: LIST
79412: PUSH
79413: LD_INT 6
79415: NEG
79416: PUSH
79417: LD_INT 0
79419: PUSH
79420: EMPTY
79421: LIST
79422: LIST
79423: PUSH
79424: LD_INT 6
79426: NEG
79427: PUSH
79428: LD_INT 1
79430: NEG
79431: PUSH
79432: EMPTY
79433: LIST
79434: LIST
79435: PUSH
79436: EMPTY
79437: LIST
79438: LIST
79439: LIST
79440: LIST
79441: LIST
79442: LIST
79443: LIST
79444: LIST
79445: LIST
79446: LIST
79447: LIST
79448: LIST
79449: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
79450: LD_ADDR_VAR 0 34
79454: PUSH
79455: LD_INT 2
79457: NEG
79458: PUSH
79459: LD_INT 3
79461: NEG
79462: PUSH
79463: EMPTY
79464: LIST
79465: LIST
79466: PUSH
79467: LD_INT 3
79469: NEG
79470: PUSH
79471: LD_INT 2
79473: NEG
79474: PUSH
79475: EMPTY
79476: LIST
79477: LIST
79478: PUSH
79479: LD_INT 3
79481: NEG
79482: PUSH
79483: LD_INT 3
79485: NEG
79486: PUSH
79487: EMPTY
79488: LIST
79489: LIST
79490: PUSH
79491: LD_INT 3
79493: NEG
79494: PUSH
79495: LD_INT 4
79497: NEG
79498: PUSH
79499: EMPTY
79500: LIST
79501: LIST
79502: PUSH
79503: LD_INT 4
79505: NEG
79506: PUSH
79507: LD_INT 3
79509: NEG
79510: PUSH
79511: EMPTY
79512: LIST
79513: LIST
79514: PUSH
79515: LD_INT 4
79517: NEG
79518: PUSH
79519: LD_INT 4
79521: NEG
79522: PUSH
79523: EMPTY
79524: LIST
79525: LIST
79526: PUSH
79527: LD_INT 4
79529: NEG
79530: PUSH
79531: LD_INT 5
79533: NEG
79534: PUSH
79535: EMPTY
79536: LIST
79537: LIST
79538: PUSH
79539: LD_INT 5
79541: NEG
79542: PUSH
79543: LD_INT 4
79545: NEG
79546: PUSH
79547: EMPTY
79548: LIST
79549: LIST
79550: PUSH
79551: LD_INT 5
79553: NEG
79554: PUSH
79555: LD_INT 5
79557: NEG
79558: PUSH
79559: EMPTY
79560: LIST
79561: LIST
79562: PUSH
79563: LD_INT 5
79565: NEG
79566: PUSH
79567: LD_INT 6
79569: NEG
79570: PUSH
79571: EMPTY
79572: LIST
79573: LIST
79574: PUSH
79575: LD_INT 6
79577: NEG
79578: PUSH
79579: LD_INT 5
79581: NEG
79582: PUSH
79583: EMPTY
79584: LIST
79585: LIST
79586: PUSH
79587: LD_INT 6
79589: NEG
79590: PUSH
79591: LD_INT 6
79593: NEG
79594: PUSH
79595: EMPTY
79596: LIST
79597: LIST
79598: PUSH
79599: EMPTY
79600: LIST
79601: LIST
79602: LIST
79603: LIST
79604: LIST
79605: LIST
79606: LIST
79607: LIST
79608: LIST
79609: LIST
79610: LIST
79611: LIST
79612: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
79613: LD_ADDR_VAR 0 41
79617: PUSH
79618: LD_INT 0
79620: PUSH
79621: LD_INT 2
79623: NEG
79624: PUSH
79625: EMPTY
79626: LIST
79627: LIST
79628: PUSH
79629: LD_INT 1
79631: NEG
79632: PUSH
79633: LD_INT 3
79635: NEG
79636: PUSH
79637: EMPTY
79638: LIST
79639: LIST
79640: PUSH
79641: LD_INT 1
79643: PUSH
79644: LD_INT 2
79646: NEG
79647: PUSH
79648: EMPTY
79649: LIST
79650: LIST
79651: PUSH
79652: EMPTY
79653: LIST
79654: LIST
79655: LIST
79656: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
79657: LD_ADDR_VAR 0 42
79661: PUSH
79662: LD_INT 2
79664: PUSH
79665: LD_INT 0
79667: PUSH
79668: EMPTY
79669: LIST
79670: LIST
79671: PUSH
79672: LD_INT 2
79674: PUSH
79675: LD_INT 1
79677: NEG
79678: PUSH
79679: EMPTY
79680: LIST
79681: LIST
79682: PUSH
79683: LD_INT 3
79685: PUSH
79686: LD_INT 1
79688: PUSH
79689: EMPTY
79690: LIST
79691: LIST
79692: PUSH
79693: EMPTY
79694: LIST
79695: LIST
79696: LIST
79697: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
79698: LD_ADDR_VAR 0 43
79702: PUSH
79703: LD_INT 2
79705: PUSH
79706: LD_INT 2
79708: PUSH
79709: EMPTY
79710: LIST
79711: LIST
79712: PUSH
79713: LD_INT 3
79715: PUSH
79716: LD_INT 2
79718: PUSH
79719: EMPTY
79720: LIST
79721: LIST
79722: PUSH
79723: LD_INT 2
79725: PUSH
79726: LD_INT 3
79728: PUSH
79729: EMPTY
79730: LIST
79731: LIST
79732: PUSH
79733: EMPTY
79734: LIST
79735: LIST
79736: LIST
79737: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
79738: LD_ADDR_VAR 0 44
79742: PUSH
79743: LD_INT 0
79745: PUSH
79746: LD_INT 2
79748: PUSH
79749: EMPTY
79750: LIST
79751: LIST
79752: PUSH
79753: LD_INT 1
79755: PUSH
79756: LD_INT 3
79758: PUSH
79759: EMPTY
79760: LIST
79761: LIST
79762: PUSH
79763: LD_INT 1
79765: NEG
79766: PUSH
79767: LD_INT 2
79769: PUSH
79770: EMPTY
79771: LIST
79772: LIST
79773: PUSH
79774: EMPTY
79775: LIST
79776: LIST
79777: LIST
79778: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
79779: LD_ADDR_VAR 0 45
79783: PUSH
79784: LD_INT 2
79786: NEG
79787: PUSH
79788: LD_INT 0
79790: PUSH
79791: EMPTY
79792: LIST
79793: LIST
79794: PUSH
79795: LD_INT 2
79797: NEG
79798: PUSH
79799: LD_INT 1
79801: PUSH
79802: EMPTY
79803: LIST
79804: LIST
79805: PUSH
79806: LD_INT 3
79808: NEG
79809: PUSH
79810: LD_INT 1
79812: NEG
79813: PUSH
79814: EMPTY
79815: LIST
79816: LIST
79817: PUSH
79818: EMPTY
79819: LIST
79820: LIST
79821: LIST
79822: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
79823: LD_ADDR_VAR 0 46
79827: PUSH
79828: LD_INT 2
79830: NEG
79831: PUSH
79832: LD_INT 2
79834: NEG
79835: PUSH
79836: EMPTY
79837: LIST
79838: LIST
79839: PUSH
79840: LD_INT 2
79842: NEG
79843: PUSH
79844: LD_INT 3
79846: NEG
79847: PUSH
79848: EMPTY
79849: LIST
79850: LIST
79851: PUSH
79852: LD_INT 3
79854: NEG
79855: PUSH
79856: LD_INT 2
79858: NEG
79859: PUSH
79860: EMPTY
79861: LIST
79862: LIST
79863: PUSH
79864: EMPTY
79865: LIST
79866: LIST
79867: LIST
79868: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
79869: LD_ADDR_VAR 0 47
79873: PUSH
79874: LD_INT 2
79876: NEG
79877: PUSH
79878: LD_INT 3
79880: NEG
79881: PUSH
79882: EMPTY
79883: LIST
79884: LIST
79885: PUSH
79886: LD_INT 1
79888: NEG
79889: PUSH
79890: LD_INT 3
79892: NEG
79893: PUSH
79894: EMPTY
79895: LIST
79896: LIST
79897: PUSH
79898: EMPTY
79899: LIST
79900: LIST
79901: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
79902: LD_ADDR_VAR 0 48
79906: PUSH
79907: LD_INT 1
79909: PUSH
79910: LD_INT 2
79912: NEG
79913: PUSH
79914: EMPTY
79915: LIST
79916: LIST
79917: PUSH
79918: LD_INT 2
79920: PUSH
79921: LD_INT 1
79923: NEG
79924: PUSH
79925: EMPTY
79926: LIST
79927: LIST
79928: PUSH
79929: EMPTY
79930: LIST
79931: LIST
79932: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
79933: LD_ADDR_VAR 0 49
79937: PUSH
79938: LD_INT 3
79940: PUSH
79941: LD_INT 1
79943: PUSH
79944: EMPTY
79945: LIST
79946: LIST
79947: PUSH
79948: LD_INT 3
79950: PUSH
79951: LD_INT 2
79953: PUSH
79954: EMPTY
79955: LIST
79956: LIST
79957: PUSH
79958: EMPTY
79959: LIST
79960: LIST
79961: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
79962: LD_ADDR_VAR 0 50
79966: PUSH
79967: LD_INT 2
79969: PUSH
79970: LD_INT 3
79972: PUSH
79973: EMPTY
79974: LIST
79975: LIST
79976: PUSH
79977: LD_INT 1
79979: PUSH
79980: LD_INT 3
79982: PUSH
79983: EMPTY
79984: LIST
79985: LIST
79986: PUSH
79987: EMPTY
79988: LIST
79989: LIST
79990: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
79991: LD_ADDR_VAR 0 51
79995: PUSH
79996: LD_INT 1
79998: NEG
79999: PUSH
80000: LD_INT 2
80002: PUSH
80003: EMPTY
80004: LIST
80005: LIST
80006: PUSH
80007: LD_INT 2
80009: NEG
80010: PUSH
80011: LD_INT 1
80013: PUSH
80014: EMPTY
80015: LIST
80016: LIST
80017: PUSH
80018: EMPTY
80019: LIST
80020: LIST
80021: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
80022: LD_ADDR_VAR 0 52
80026: PUSH
80027: LD_INT 3
80029: NEG
80030: PUSH
80031: LD_INT 1
80033: NEG
80034: PUSH
80035: EMPTY
80036: LIST
80037: LIST
80038: PUSH
80039: LD_INT 3
80041: NEG
80042: PUSH
80043: LD_INT 2
80045: NEG
80046: PUSH
80047: EMPTY
80048: LIST
80049: LIST
80050: PUSH
80051: EMPTY
80052: LIST
80053: LIST
80054: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
80055: LD_ADDR_VAR 0 53
80059: PUSH
80060: LD_INT 1
80062: NEG
80063: PUSH
80064: LD_INT 3
80066: NEG
80067: PUSH
80068: EMPTY
80069: LIST
80070: LIST
80071: PUSH
80072: LD_INT 0
80074: PUSH
80075: LD_INT 3
80077: NEG
80078: PUSH
80079: EMPTY
80080: LIST
80081: LIST
80082: PUSH
80083: LD_INT 1
80085: PUSH
80086: LD_INT 2
80088: NEG
80089: PUSH
80090: EMPTY
80091: LIST
80092: LIST
80093: PUSH
80094: EMPTY
80095: LIST
80096: LIST
80097: LIST
80098: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
80099: LD_ADDR_VAR 0 54
80103: PUSH
80104: LD_INT 2
80106: PUSH
80107: LD_INT 1
80109: NEG
80110: PUSH
80111: EMPTY
80112: LIST
80113: LIST
80114: PUSH
80115: LD_INT 3
80117: PUSH
80118: LD_INT 0
80120: PUSH
80121: EMPTY
80122: LIST
80123: LIST
80124: PUSH
80125: LD_INT 3
80127: PUSH
80128: LD_INT 1
80130: PUSH
80131: EMPTY
80132: LIST
80133: LIST
80134: PUSH
80135: EMPTY
80136: LIST
80137: LIST
80138: LIST
80139: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
80140: LD_ADDR_VAR 0 55
80144: PUSH
80145: LD_INT 3
80147: PUSH
80148: LD_INT 2
80150: PUSH
80151: EMPTY
80152: LIST
80153: LIST
80154: PUSH
80155: LD_INT 3
80157: PUSH
80158: LD_INT 3
80160: PUSH
80161: EMPTY
80162: LIST
80163: LIST
80164: PUSH
80165: LD_INT 2
80167: PUSH
80168: LD_INT 3
80170: PUSH
80171: EMPTY
80172: LIST
80173: LIST
80174: PUSH
80175: EMPTY
80176: LIST
80177: LIST
80178: LIST
80179: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
80180: LD_ADDR_VAR 0 56
80184: PUSH
80185: LD_INT 1
80187: PUSH
80188: LD_INT 3
80190: PUSH
80191: EMPTY
80192: LIST
80193: LIST
80194: PUSH
80195: LD_INT 0
80197: PUSH
80198: LD_INT 3
80200: PUSH
80201: EMPTY
80202: LIST
80203: LIST
80204: PUSH
80205: LD_INT 1
80207: NEG
80208: PUSH
80209: LD_INT 2
80211: PUSH
80212: EMPTY
80213: LIST
80214: LIST
80215: PUSH
80216: EMPTY
80217: LIST
80218: LIST
80219: LIST
80220: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80221: LD_ADDR_VAR 0 57
80225: PUSH
80226: LD_INT 2
80228: NEG
80229: PUSH
80230: LD_INT 1
80232: PUSH
80233: EMPTY
80234: LIST
80235: LIST
80236: PUSH
80237: LD_INT 3
80239: NEG
80240: PUSH
80241: LD_INT 0
80243: PUSH
80244: EMPTY
80245: LIST
80246: LIST
80247: PUSH
80248: LD_INT 3
80250: NEG
80251: PUSH
80252: LD_INT 1
80254: NEG
80255: PUSH
80256: EMPTY
80257: LIST
80258: LIST
80259: PUSH
80260: EMPTY
80261: LIST
80262: LIST
80263: LIST
80264: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80265: LD_ADDR_VAR 0 58
80269: PUSH
80270: LD_INT 2
80272: NEG
80273: PUSH
80274: LD_INT 3
80276: NEG
80277: PUSH
80278: EMPTY
80279: LIST
80280: LIST
80281: PUSH
80282: LD_INT 3
80284: NEG
80285: PUSH
80286: LD_INT 2
80288: NEG
80289: PUSH
80290: EMPTY
80291: LIST
80292: LIST
80293: PUSH
80294: LD_INT 3
80296: NEG
80297: PUSH
80298: LD_INT 3
80300: NEG
80301: PUSH
80302: EMPTY
80303: LIST
80304: LIST
80305: PUSH
80306: EMPTY
80307: LIST
80308: LIST
80309: LIST
80310: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
80311: LD_ADDR_VAR 0 59
80315: PUSH
80316: LD_INT 1
80318: NEG
80319: PUSH
80320: LD_INT 2
80322: NEG
80323: PUSH
80324: EMPTY
80325: LIST
80326: LIST
80327: PUSH
80328: LD_INT 0
80330: PUSH
80331: LD_INT 2
80333: NEG
80334: PUSH
80335: EMPTY
80336: LIST
80337: LIST
80338: PUSH
80339: LD_INT 1
80341: PUSH
80342: LD_INT 1
80344: NEG
80345: PUSH
80346: EMPTY
80347: LIST
80348: LIST
80349: PUSH
80350: EMPTY
80351: LIST
80352: LIST
80353: LIST
80354: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
80355: LD_ADDR_VAR 0 60
80359: PUSH
80360: LD_INT 1
80362: PUSH
80363: LD_INT 1
80365: NEG
80366: PUSH
80367: EMPTY
80368: LIST
80369: LIST
80370: PUSH
80371: LD_INT 2
80373: PUSH
80374: LD_INT 0
80376: PUSH
80377: EMPTY
80378: LIST
80379: LIST
80380: PUSH
80381: LD_INT 2
80383: PUSH
80384: LD_INT 1
80386: PUSH
80387: EMPTY
80388: LIST
80389: LIST
80390: PUSH
80391: EMPTY
80392: LIST
80393: LIST
80394: LIST
80395: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
80396: LD_ADDR_VAR 0 61
80400: PUSH
80401: LD_INT 2
80403: PUSH
80404: LD_INT 1
80406: PUSH
80407: EMPTY
80408: LIST
80409: LIST
80410: PUSH
80411: LD_INT 2
80413: PUSH
80414: LD_INT 2
80416: PUSH
80417: EMPTY
80418: LIST
80419: LIST
80420: PUSH
80421: LD_INT 1
80423: PUSH
80424: LD_INT 2
80426: PUSH
80427: EMPTY
80428: LIST
80429: LIST
80430: PUSH
80431: EMPTY
80432: LIST
80433: LIST
80434: LIST
80435: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
80436: LD_ADDR_VAR 0 62
80440: PUSH
80441: LD_INT 1
80443: PUSH
80444: LD_INT 2
80446: PUSH
80447: EMPTY
80448: LIST
80449: LIST
80450: PUSH
80451: LD_INT 0
80453: PUSH
80454: LD_INT 2
80456: PUSH
80457: EMPTY
80458: LIST
80459: LIST
80460: PUSH
80461: LD_INT 1
80463: NEG
80464: PUSH
80465: LD_INT 1
80467: PUSH
80468: EMPTY
80469: LIST
80470: LIST
80471: PUSH
80472: EMPTY
80473: LIST
80474: LIST
80475: LIST
80476: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
80477: LD_ADDR_VAR 0 63
80481: PUSH
80482: LD_INT 1
80484: NEG
80485: PUSH
80486: LD_INT 1
80488: PUSH
80489: EMPTY
80490: LIST
80491: LIST
80492: PUSH
80493: LD_INT 2
80495: NEG
80496: PUSH
80497: LD_INT 0
80499: PUSH
80500: EMPTY
80501: LIST
80502: LIST
80503: PUSH
80504: LD_INT 2
80506: NEG
80507: PUSH
80508: LD_INT 1
80510: NEG
80511: PUSH
80512: EMPTY
80513: LIST
80514: LIST
80515: PUSH
80516: EMPTY
80517: LIST
80518: LIST
80519: LIST
80520: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80521: LD_ADDR_VAR 0 64
80525: PUSH
80526: LD_INT 1
80528: NEG
80529: PUSH
80530: LD_INT 2
80532: NEG
80533: PUSH
80534: EMPTY
80535: LIST
80536: LIST
80537: PUSH
80538: LD_INT 2
80540: NEG
80541: PUSH
80542: LD_INT 1
80544: NEG
80545: PUSH
80546: EMPTY
80547: LIST
80548: LIST
80549: PUSH
80550: LD_INT 2
80552: NEG
80553: PUSH
80554: LD_INT 2
80556: NEG
80557: PUSH
80558: EMPTY
80559: LIST
80560: LIST
80561: PUSH
80562: EMPTY
80563: LIST
80564: LIST
80565: LIST
80566: ST_TO_ADDR
// end ; 2 :
80567: GO 83833
80569: LD_INT 2
80571: DOUBLE
80572: EQUAL
80573: IFTRUE 80577
80575: GO 83832
80577: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
80578: LD_ADDR_VAR 0 29
80582: PUSH
80583: LD_INT 4
80585: PUSH
80586: LD_INT 0
80588: PUSH
80589: EMPTY
80590: LIST
80591: LIST
80592: PUSH
80593: LD_INT 4
80595: PUSH
80596: LD_INT 1
80598: NEG
80599: PUSH
80600: EMPTY
80601: LIST
80602: LIST
80603: PUSH
80604: LD_INT 5
80606: PUSH
80607: LD_INT 0
80609: PUSH
80610: EMPTY
80611: LIST
80612: LIST
80613: PUSH
80614: LD_INT 5
80616: PUSH
80617: LD_INT 1
80619: PUSH
80620: EMPTY
80621: LIST
80622: LIST
80623: PUSH
80624: LD_INT 4
80626: PUSH
80627: LD_INT 1
80629: PUSH
80630: EMPTY
80631: LIST
80632: LIST
80633: PUSH
80634: LD_INT 3
80636: PUSH
80637: LD_INT 0
80639: PUSH
80640: EMPTY
80641: LIST
80642: LIST
80643: PUSH
80644: LD_INT 3
80646: PUSH
80647: LD_INT 1
80649: NEG
80650: PUSH
80651: EMPTY
80652: LIST
80653: LIST
80654: PUSH
80655: LD_INT 3
80657: PUSH
80658: LD_INT 2
80660: NEG
80661: PUSH
80662: EMPTY
80663: LIST
80664: LIST
80665: PUSH
80666: LD_INT 5
80668: PUSH
80669: LD_INT 2
80671: PUSH
80672: EMPTY
80673: LIST
80674: LIST
80675: PUSH
80676: LD_INT 3
80678: PUSH
80679: LD_INT 3
80681: PUSH
80682: EMPTY
80683: LIST
80684: LIST
80685: PUSH
80686: LD_INT 3
80688: PUSH
80689: LD_INT 2
80691: PUSH
80692: EMPTY
80693: LIST
80694: LIST
80695: PUSH
80696: LD_INT 4
80698: PUSH
80699: LD_INT 3
80701: PUSH
80702: EMPTY
80703: LIST
80704: LIST
80705: PUSH
80706: LD_INT 4
80708: PUSH
80709: LD_INT 4
80711: PUSH
80712: EMPTY
80713: LIST
80714: LIST
80715: PUSH
80716: LD_INT 3
80718: PUSH
80719: LD_INT 4
80721: PUSH
80722: EMPTY
80723: LIST
80724: LIST
80725: PUSH
80726: LD_INT 2
80728: PUSH
80729: LD_INT 3
80731: PUSH
80732: EMPTY
80733: LIST
80734: LIST
80735: PUSH
80736: LD_INT 2
80738: PUSH
80739: LD_INT 2
80741: PUSH
80742: EMPTY
80743: LIST
80744: LIST
80745: PUSH
80746: LD_INT 4
80748: PUSH
80749: LD_INT 2
80751: PUSH
80752: EMPTY
80753: LIST
80754: LIST
80755: PUSH
80756: LD_INT 2
80758: PUSH
80759: LD_INT 4
80761: PUSH
80762: EMPTY
80763: LIST
80764: LIST
80765: PUSH
80766: LD_INT 0
80768: PUSH
80769: LD_INT 4
80771: PUSH
80772: EMPTY
80773: LIST
80774: LIST
80775: PUSH
80776: LD_INT 0
80778: PUSH
80779: LD_INT 3
80781: PUSH
80782: EMPTY
80783: LIST
80784: LIST
80785: PUSH
80786: LD_INT 1
80788: PUSH
80789: LD_INT 4
80791: PUSH
80792: EMPTY
80793: LIST
80794: LIST
80795: PUSH
80796: LD_INT 1
80798: PUSH
80799: LD_INT 5
80801: PUSH
80802: EMPTY
80803: LIST
80804: LIST
80805: PUSH
80806: LD_INT 0
80808: PUSH
80809: LD_INT 5
80811: PUSH
80812: EMPTY
80813: LIST
80814: LIST
80815: PUSH
80816: LD_INT 1
80818: NEG
80819: PUSH
80820: LD_INT 4
80822: PUSH
80823: EMPTY
80824: LIST
80825: LIST
80826: PUSH
80827: LD_INT 1
80829: NEG
80830: PUSH
80831: LD_INT 3
80833: PUSH
80834: EMPTY
80835: LIST
80836: LIST
80837: PUSH
80838: LD_INT 2
80840: PUSH
80841: LD_INT 5
80843: PUSH
80844: EMPTY
80845: LIST
80846: LIST
80847: PUSH
80848: LD_INT 2
80850: NEG
80851: PUSH
80852: LD_INT 3
80854: PUSH
80855: EMPTY
80856: LIST
80857: LIST
80858: PUSH
80859: LD_INT 3
80861: NEG
80862: PUSH
80863: LD_INT 0
80865: PUSH
80866: EMPTY
80867: LIST
80868: LIST
80869: PUSH
80870: LD_INT 3
80872: NEG
80873: PUSH
80874: LD_INT 1
80876: NEG
80877: PUSH
80878: EMPTY
80879: LIST
80880: LIST
80881: PUSH
80882: LD_INT 2
80884: NEG
80885: PUSH
80886: LD_INT 0
80888: PUSH
80889: EMPTY
80890: LIST
80891: LIST
80892: PUSH
80893: LD_INT 2
80895: NEG
80896: PUSH
80897: LD_INT 1
80899: PUSH
80900: EMPTY
80901: LIST
80902: LIST
80903: PUSH
80904: LD_INT 3
80906: NEG
80907: PUSH
80908: LD_INT 1
80910: PUSH
80911: EMPTY
80912: LIST
80913: LIST
80914: PUSH
80915: LD_INT 4
80917: NEG
80918: PUSH
80919: LD_INT 0
80921: PUSH
80922: EMPTY
80923: LIST
80924: LIST
80925: PUSH
80926: LD_INT 4
80928: NEG
80929: PUSH
80930: LD_INT 1
80932: NEG
80933: PUSH
80934: EMPTY
80935: LIST
80936: LIST
80937: PUSH
80938: LD_INT 4
80940: NEG
80941: PUSH
80942: LD_INT 2
80944: NEG
80945: PUSH
80946: EMPTY
80947: LIST
80948: LIST
80949: PUSH
80950: LD_INT 2
80952: NEG
80953: PUSH
80954: LD_INT 2
80956: PUSH
80957: EMPTY
80958: LIST
80959: LIST
80960: PUSH
80961: LD_INT 4
80963: NEG
80964: PUSH
80965: LD_INT 4
80967: NEG
80968: PUSH
80969: EMPTY
80970: LIST
80971: LIST
80972: PUSH
80973: LD_INT 4
80975: NEG
80976: PUSH
80977: LD_INT 5
80979: NEG
80980: PUSH
80981: EMPTY
80982: LIST
80983: LIST
80984: PUSH
80985: LD_INT 3
80987: NEG
80988: PUSH
80989: LD_INT 4
80991: NEG
80992: PUSH
80993: EMPTY
80994: LIST
80995: LIST
80996: PUSH
80997: LD_INT 3
80999: NEG
81000: PUSH
81001: LD_INT 3
81003: NEG
81004: PUSH
81005: EMPTY
81006: LIST
81007: LIST
81008: PUSH
81009: LD_INT 4
81011: NEG
81012: PUSH
81013: LD_INT 3
81015: NEG
81016: PUSH
81017: EMPTY
81018: LIST
81019: LIST
81020: PUSH
81021: LD_INT 5
81023: NEG
81024: PUSH
81025: LD_INT 4
81027: NEG
81028: PUSH
81029: EMPTY
81030: LIST
81031: LIST
81032: PUSH
81033: LD_INT 5
81035: NEG
81036: PUSH
81037: LD_INT 5
81039: NEG
81040: PUSH
81041: EMPTY
81042: LIST
81043: LIST
81044: PUSH
81045: LD_INT 3
81047: NEG
81048: PUSH
81049: LD_INT 5
81051: NEG
81052: PUSH
81053: EMPTY
81054: LIST
81055: LIST
81056: PUSH
81057: LD_INT 5
81059: NEG
81060: PUSH
81061: LD_INT 3
81063: NEG
81064: PUSH
81065: EMPTY
81066: LIST
81067: LIST
81068: PUSH
81069: EMPTY
81070: LIST
81071: LIST
81072: LIST
81073: LIST
81074: LIST
81075: LIST
81076: LIST
81077: LIST
81078: LIST
81079: LIST
81080: LIST
81081: LIST
81082: LIST
81083: LIST
81084: LIST
81085: LIST
81086: LIST
81087: LIST
81088: LIST
81089: LIST
81090: LIST
81091: LIST
81092: LIST
81093: LIST
81094: LIST
81095: LIST
81096: LIST
81097: LIST
81098: LIST
81099: LIST
81100: LIST
81101: LIST
81102: LIST
81103: LIST
81104: LIST
81105: LIST
81106: LIST
81107: LIST
81108: LIST
81109: LIST
81110: LIST
81111: LIST
81112: LIST
81113: LIST
81114: LIST
81115: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
81116: LD_ADDR_VAR 0 30
81120: PUSH
81121: LD_INT 4
81123: PUSH
81124: LD_INT 4
81126: PUSH
81127: EMPTY
81128: LIST
81129: LIST
81130: PUSH
81131: LD_INT 4
81133: PUSH
81134: LD_INT 3
81136: PUSH
81137: EMPTY
81138: LIST
81139: LIST
81140: PUSH
81141: LD_INT 5
81143: PUSH
81144: LD_INT 4
81146: PUSH
81147: EMPTY
81148: LIST
81149: LIST
81150: PUSH
81151: LD_INT 5
81153: PUSH
81154: LD_INT 5
81156: PUSH
81157: EMPTY
81158: LIST
81159: LIST
81160: PUSH
81161: LD_INT 4
81163: PUSH
81164: LD_INT 5
81166: PUSH
81167: EMPTY
81168: LIST
81169: LIST
81170: PUSH
81171: LD_INT 3
81173: PUSH
81174: LD_INT 4
81176: PUSH
81177: EMPTY
81178: LIST
81179: LIST
81180: PUSH
81181: LD_INT 3
81183: PUSH
81184: LD_INT 3
81186: PUSH
81187: EMPTY
81188: LIST
81189: LIST
81190: PUSH
81191: LD_INT 5
81193: PUSH
81194: LD_INT 3
81196: PUSH
81197: EMPTY
81198: LIST
81199: LIST
81200: PUSH
81201: LD_INT 3
81203: PUSH
81204: LD_INT 5
81206: PUSH
81207: EMPTY
81208: LIST
81209: LIST
81210: PUSH
81211: LD_INT 0
81213: PUSH
81214: LD_INT 3
81216: PUSH
81217: EMPTY
81218: LIST
81219: LIST
81220: PUSH
81221: LD_INT 0
81223: PUSH
81224: LD_INT 2
81226: PUSH
81227: EMPTY
81228: LIST
81229: LIST
81230: PUSH
81231: LD_INT 1
81233: PUSH
81234: LD_INT 3
81236: PUSH
81237: EMPTY
81238: LIST
81239: LIST
81240: PUSH
81241: LD_INT 1
81243: PUSH
81244: LD_INT 4
81246: PUSH
81247: EMPTY
81248: LIST
81249: LIST
81250: PUSH
81251: LD_INT 0
81253: PUSH
81254: LD_INT 4
81256: PUSH
81257: EMPTY
81258: LIST
81259: LIST
81260: PUSH
81261: LD_INT 1
81263: NEG
81264: PUSH
81265: LD_INT 3
81267: PUSH
81268: EMPTY
81269: LIST
81270: LIST
81271: PUSH
81272: LD_INT 1
81274: NEG
81275: PUSH
81276: LD_INT 2
81278: PUSH
81279: EMPTY
81280: LIST
81281: LIST
81282: PUSH
81283: LD_INT 2
81285: PUSH
81286: LD_INT 4
81288: PUSH
81289: EMPTY
81290: LIST
81291: LIST
81292: PUSH
81293: LD_INT 2
81295: NEG
81296: PUSH
81297: LD_INT 2
81299: PUSH
81300: EMPTY
81301: LIST
81302: LIST
81303: PUSH
81304: LD_INT 4
81306: NEG
81307: PUSH
81308: LD_INT 0
81310: PUSH
81311: EMPTY
81312: LIST
81313: LIST
81314: PUSH
81315: LD_INT 4
81317: NEG
81318: PUSH
81319: LD_INT 1
81321: NEG
81322: PUSH
81323: EMPTY
81324: LIST
81325: LIST
81326: PUSH
81327: LD_INT 3
81329: NEG
81330: PUSH
81331: LD_INT 0
81333: PUSH
81334: EMPTY
81335: LIST
81336: LIST
81337: PUSH
81338: LD_INT 3
81340: NEG
81341: PUSH
81342: LD_INT 1
81344: PUSH
81345: EMPTY
81346: LIST
81347: LIST
81348: PUSH
81349: LD_INT 4
81351: NEG
81352: PUSH
81353: LD_INT 1
81355: PUSH
81356: EMPTY
81357: LIST
81358: LIST
81359: PUSH
81360: LD_INT 5
81362: NEG
81363: PUSH
81364: LD_INT 0
81366: PUSH
81367: EMPTY
81368: LIST
81369: LIST
81370: PUSH
81371: LD_INT 5
81373: NEG
81374: PUSH
81375: LD_INT 1
81377: NEG
81378: PUSH
81379: EMPTY
81380: LIST
81381: LIST
81382: PUSH
81383: LD_INT 5
81385: NEG
81386: PUSH
81387: LD_INT 2
81389: NEG
81390: PUSH
81391: EMPTY
81392: LIST
81393: LIST
81394: PUSH
81395: LD_INT 3
81397: NEG
81398: PUSH
81399: LD_INT 2
81401: PUSH
81402: EMPTY
81403: LIST
81404: LIST
81405: PUSH
81406: LD_INT 3
81408: NEG
81409: PUSH
81410: LD_INT 3
81412: NEG
81413: PUSH
81414: EMPTY
81415: LIST
81416: LIST
81417: PUSH
81418: LD_INT 3
81420: NEG
81421: PUSH
81422: LD_INT 4
81424: NEG
81425: PUSH
81426: EMPTY
81427: LIST
81428: LIST
81429: PUSH
81430: LD_INT 2
81432: NEG
81433: PUSH
81434: LD_INT 3
81436: NEG
81437: PUSH
81438: EMPTY
81439: LIST
81440: LIST
81441: PUSH
81442: LD_INT 2
81444: NEG
81445: PUSH
81446: LD_INT 2
81448: NEG
81449: PUSH
81450: EMPTY
81451: LIST
81452: LIST
81453: PUSH
81454: LD_INT 3
81456: NEG
81457: PUSH
81458: LD_INT 2
81460: NEG
81461: PUSH
81462: EMPTY
81463: LIST
81464: LIST
81465: PUSH
81466: LD_INT 4
81468: NEG
81469: PUSH
81470: LD_INT 3
81472: NEG
81473: PUSH
81474: EMPTY
81475: LIST
81476: LIST
81477: PUSH
81478: LD_INT 4
81480: NEG
81481: PUSH
81482: LD_INT 4
81484: NEG
81485: PUSH
81486: EMPTY
81487: LIST
81488: LIST
81489: PUSH
81490: LD_INT 2
81492: NEG
81493: PUSH
81494: LD_INT 4
81496: NEG
81497: PUSH
81498: EMPTY
81499: LIST
81500: LIST
81501: PUSH
81502: LD_INT 4
81504: NEG
81505: PUSH
81506: LD_INT 2
81508: NEG
81509: PUSH
81510: EMPTY
81511: LIST
81512: LIST
81513: PUSH
81514: LD_INT 0
81516: PUSH
81517: LD_INT 4
81519: NEG
81520: PUSH
81521: EMPTY
81522: LIST
81523: LIST
81524: PUSH
81525: LD_INT 0
81527: PUSH
81528: LD_INT 5
81530: NEG
81531: PUSH
81532: EMPTY
81533: LIST
81534: LIST
81535: PUSH
81536: LD_INT 1
81538: PUSH
81539: LD_INT 4
81541: NEG
81542: PUSH
81543: EMPTY
81544: LIST
81545: LIST
81546: PUSH
81547: LD_INT 1
81549: PUSH
81550: LD_INT 3
81552: NEG
81553: PUSH
81554: EMPTY
81555: LIST
81556: LIST
81557: PUSH
81558: LD_INT 0
81560: PUSH
81561: LD_INT 3
81563: NEG
81564: PUSH
81565: EMPTY
81566: LIST
81567: LIST
81568: PUSH
81569: LD_INT 1
81571: NEG
81572: PUSH
81573: LD_INT 4
81575: NEG
81576: PUSH
81577: EMPTY
81578: LIST
81579: LIST
81580: PUSH
81581: LD_INT 1
81583: NEG
81584: PUSH
81585: LD_INT 5
81587: NEG
81588: PUSH
81589: EMPTY
81590: LIST
81591: LIST
81592: PUSH
81593: LD_INT 2
81595: PUSH
81596: LD_INT 3
81598: NEG
81599: PUSH
81600: EMPTY
81601: LIST
81602: LIST
81603: PUSH
81604: LD_INT 2
81606: NEG
81607: PUSH
81608: LD_INT 5
81610: NEG
81611: PUSH
81612: EMPTY
81613: LIST
81614: LIST
81615: PUSH
81616: EMPTY
81617: LIST
81618: LIST
81619: LIST
81620: LIST
81621: LIST
81622: LIST
81623: LIST
81624: LIST
81625: LIST
81626: LIST
81627: LIST
81628: LIST
81629: LIST
81630: LIST
81631: LIST
81632: LIST
81633: LIST
81634: LIST
81635: LIST
81636: LIST
81637: LIST
81638: LIST
81639: LIST
81640: LIST
81641: LIST
81642: LIST
81643: LIST
81644: LIST
81645: LIST
81646: LIST
81647: LIST
81648: LIST
81649: LIST
81650: LIST
81651: LIST
81652: LIST
81653: LIST
81654: LIST
81655: LIST
81656: LIST
81657: LIST
81658: LIST
81659: LIST
81660: LIST
81661: LIST
81662: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
81663: LD_ADDR_VAR 0 31
81667: PUSH
81668: LD_INT 0
81670: PUSH
81671: LD_INT 4
81673: PUSH
81674: EMPTY
81675: LIST
81676: LIST
81677: PUSH
81678: LD_INT 0
81680: PUSH
81681: LD_INT 3
81683: PUSH
81684: EMPTY
81685: LIST
81686: LIST
81687: PUSH
81688: LD_INT 1
81690: PUSH
81691: LD_INT 4
81693: PUSH
81694: EMPTY
81695: LIST
81696: LIST
81697: PUSH
81698: LD_INT 1
81700: PUSH
81701: LD_INT 5
81703: PUSH
81704: EMPTY
81705: LIST
81706: LIST
81707: PUSH
81708: LD_INT 0
81710: PUSH
81711: LD_INT 5
81713: PUSH
81714: EMPTY
81715: LIST
81716: LIST
81717: PUSH
81718: LD_INT 1
81720: NEG
81721: PUSH
81722: LD_INT 4
81724: PUSH
81725: EMPTY
81726: LIST
81727: LIST
81728: PUSH
81729: LD_INT 1
81731: NEG
81732: PUSH
81733: LD_INT 3
81735: PUSH
81736: EMPTY
81737: LIST
81738: LIST
81739: PUSH
81740: LD_INT 2
81742: PUSH
81743: LD_INT 5
81745: PUSH
81746: EMPTY
81747: LIST
81748: LIST
81749: PUSH
81750: LD_INT 2
81752: NEG
81753: PUSH
81754: LD_INT 3
81756: PUSH
81757: EMPTY
81758: LIST
81759: LIST
81760: PUSH
81761: LD_INT 3
81763: NEG
81764: PUSH
81765: LD_INT 0
81767: PUSH
81768: EMPTY
81769: LIST
81770: LIST
81771: PUSH
81772: LD_INT 3
81774: NEG
81775: PUSH
81776: LD_INT 1
81778: NEG
81779: PUSH
81780: EMPTY
81781: LIST
81782: LIST
81783: PUSH
81784: LD_INT 2
81786: NEG
81787: PUSH
81788: LD_INT 0
81790: PUSH
81791: EMPTY
81792: LIST
81793: LIST
81794: PUSH
81795: LD_INT 2
81797: NEG
81798: PUSH
81799: LD_INT 1
81801: PUSH
81802: EMPTY
81803: LIST
81804: LIST
81805: PUSH
81806: LD_INT 3
81808: NEG
81809: PUSH
81810: LD_INT 1
81812: PUSH
81813: EMPTY
81814: LIST
81815: LIST
81816: PUSH
81817: LD_INT 4
81819: NEG
81820: PUSH
81821: LD_INT 0
81823: PUSH
81824: EMPTY
81825: LIST
81826: LIST
81827: PUSH
81828: LD_INT 4
81830: NEG
81831: PUSH
81832: LD_INT 1
81834: NEG
81835: PUSH
81836: EMPTY
81837: LIST
81838: LIST
81839: PUSH
81840: LD_INT 4
81842: NEG
81843: PUSH
81844: LD_INT 2
81846: NEG
81847: PUSH
81848: EMPTY
81849: LIST
81850: LIST
81851: PUSH
81852: LD_INT 2
81854: NEG
81855: PUSH
81856: LD_INT 2
81858: PUSH
81859: EMPTY
81860: LIST
81861: LIST
81862: PUSH
81863: LD_INT 4
81865: NEG
81866: PUSH
81867: LD_INT 4
81869: NEG
81870: PUSH
81871: EMPTY
81872: LIST
81873: LIST
81874: PUSH
81875: LD_INT 4
81877: NEG
81878: PUSH
81879: LD_INT 5
81881: NEG
81882: PUSH
81883: EMPTY
81884: LIST
81885: LIST
81886: PUSH
81887: LD_INT 3
81889: NEG
81890: PUSH
81891: LD_INT 4
81893: NEG
81894: PUSH
81895: EMPTY
81896: LIST
81897: LIST
81898: PUSH
81899: LD_INT 3
81901: NEG
81902: PUSH
81903: LD_INT 3
81905: NEG
81906: PUSH
81907: EMPTY
81908: LIST
81909: LIST
81910: PUSH
81911: LD_INT 4
81913: NEG
81914: PUSH
81915: LD_INT 3
81917: NEG
81918: PUSH
81919: EMPTY
81920: LIST
81921: LIST
81922: PUSH
81923: LD_INT 5
81925: NEG
81926: PUSH
81927: LD_INT 4
81929: NEG
81930: PUSH
81931: EMPTY
81932: LIST
81933: LIST
81934: PUSH
81935: LD_INT 5
81937: NEG
81938: PUSH
81939: LD_INT 5
81941: NEG
81942: PUSH
81943: EMPTY
81944: LIST
81945: LIST
81946: PUSH
81947: LD_INT 3
81949: NEG
81950: PUSH
81951: LD_INT 5
81953: NEG
81954: PUSH
81955: EMPTY
81956: LIST
81957: LIST
81958: PUSH
81959: LD_INT 5
81961: NEG
81962: PUSH
81963: LD_INT 3
81965: NEG
81966: PUSH
81967: EMPTY
81968: LIST
81969: LIST
81970: PUSH
81971: LD_INT 0
81973: PUSH
81974: LD_INT 3
81976: NEG
81977: PUSH
81978: EMPTY
81979: LIST
81980: LIST
81981: PUSH
81982: LD_INT 0
81984: PUSH
81985: LD_INT 4
81987: NEG
81988: PUSH
81989: EMPTY
81990: LIST
81991: LIST
81992: PUSH
81993: LD_INT 1
81995: PUSH
81996: LD_INT 3
81998: NEG
81999: PUSH
82000: EMPTY
82001: LIST
82002: LIST
82003: PUSH
82004: LD_INT 1
82006: PUSH
82007: LD_INT 2
82009: NEG
82010: PUSH
82011: EMPTY
82012: LIST
82013: LIST
82014: PUSH
82015: LD_INT 0
82017: PUSH
82018: LD_INT 2
82020: NEG
82021: PUSH
82022: EMPTY
82023: LIST
82024: LIST
82025: PUSH
82026: LD_INT 1
82028: NEG
82029: PUSH
82030: LD_INT 3
82032: NEG
82033: PUSH
82034: EMPTY
82035: LIST
82036: LIST
82037: PUSH
82038: LD_INT 1
82040: NEG
82041: PUSH
82042: LD_INT 4
82044: NEG
82045: PUSH
82046: EMPTY
82047: LIST
82048: LIST
82049: PUSH
82050: LD_INT 2
82052: PUSH
82053: LD_INT 2
82055: NEG
82056: PUSH
82057: EMPTY
82058: LIST
82059: LIST
82060: PUSH
82061: LD_INT 2
82063: NEG
82064: PUSH
82065: LD_INT 4
82067: NEG
82068: PUSH
82069: EMPTY
82070: LIST
82071: LIST
82072: PUSH
82073: LD_INT 4
82075: PUSH
82076: LD_INT 0
82078: PUSH
82079: EMPTY
82080: LIST
82081: LIST
82082: PUSH
82083: LD_INT 4
82085: PUSH
82086: LD_INT 1
82088: NEG
82089: PUSH
82090: EMPTY
82091: LIST
82092: LIST
82093: PUSH
82094: LD_INT 5
82096: PUSH
82097: LD_INT 0
82099: PUSH
82100: EMPTY
82101: LIST
82102: LIST
82103: PUSH
82104: LD_INT 5
82106: PUSH
82107: LD_INT 1
82109: PUSH
82110: EMPTY
82111: LIST
82112: LIST
82113: PUSH
82114: LD_INT 4
82116: PUSH
82117: LD_INT 1
82119: PUSH
82120: EMPTY
82121: LIST
82122: LIST
82123: PUSH
82124: LD_INT 3
82126: PUSH
82127: LD_INT 0
82129: PUSH
82130: EMPTY
82131: LIST
82132: LIST
82133: PUSH
82134: LD_INT 3
82136: PUSH
82137: LD_INT 1
82139: NEG
82140: PUSH
82141: EMPTY
82142: LIST
82143: LIST
82144: PUSH
82145: LD_INT 3
82147: PUSH
82148: LD_INT 2
82150: NEG
82151: PUSH
82152: EMPTY
82153: LIST
82154: LIST
82155: PUSH
82156: LD_INT 5
82158: PUSH
82159: LD_INT 2
82161: PUSH
82162: EMPTY
82163: LIST
82164: LIST
82165: PUSH
82166: EMPTY
82167: LIST
82168: LIST
82169: LIST
82170: LIST
82171: LIST
82172: LIST
82173: LIST
82174: LIST
82175: LIST
82176: LIST
82177: LIST
82178: LIST
82179: LIST
82180: LIST
82181: LIST
82182: LIST
82183: LIST
82184: LIST
82185: LIST
82186: LIST
82187: LIST
82188: LIST
82189: LIST
82190: LIST
82191: LIST
82192: LIST
82193: LIST
82194: LIST
82195: LIST
82196: LIST
82197: LIST
82198: LIST
82199: LIST
82200: LIST
82201: LIST
82202: LIST
82203: LIST
82204: LIST
82205: LIST
82206: LIST
82207: LIST
82208: LIST
82209: LIST
82210: LIST
82211: LIST
82212: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
82213: LD_ADDR_VAR 0 32
82217: PUSH
82218: LD_INT 4
82220: NEG
82221: PUSH
82222: LD_INT 0
82224: PUSH
82225: EMPTY
82226: LIST
82227: LIST
82228: PUSH
82229: LD_INT 4
82231: NEG
82232: PUSH
82233: LD_INT 1
82235: NEG
82236: PUSH
82237: EMPTY
82238: LIST
82239: LIST
82240: PUSH
82241: LD_INT 3
82243: NEG
82244: PUSH
82245: LD_INT 0
82247: PUSH
82248: EMPTY
82249: LIST
82250: LIST
82251: PUSH
82252: LD_INT 3
82254: NEG
82255: PUSH
82256: LD_INT 1
82258: PUSH
82259: EMPTY
82260: LIST
82261: LIST
82262: PUSH
82263: LD_INT 4
82265: NEG
82266: PUSH
82267: LD_INT 1
82269: PUSH
82270: EMPTY
82271: LIST
82272: LIST
82273: PUSH
82274: LD_INT 5
82276: NEG
82277: PUSH
82278: LD_INT 0
82280: PUSH
82281: EMPTY
82282: LIST
82283: LIST
82284: PUSH
82285: LD_INT 5
82287: NEG
82288: PUSH
82289: LD_INT 1
82291: NEG
82292: PUSH
82293: EMPTY
82294: LIST
82295: LIST
82296: PUSH
82297: LD_INT 5
82299: NEG
82300: PUSH
82301: LD_INT 2
82303: NEG
82304: PUSH
82305: EMPTY
82306: LIST
82307: LIST
82308: PUSH
82309: LD_INT 3
82311: NEG
82312: PUSH
82313: LD_INT 2
82315: PUSH
82316: EMPTY
82317: LIST
82318: LIST
82319: PUSH
82320: LD_INT 3
82322: NEG
82323: PUSH
82324: LD_INT 3
82326: NEG
82327: PUSH
82328: EMPTY
82329: LIST
82330: LIST
82331: PUSH
82332: LD_INT 3
82334: NEG
82335: PUSH
82336: LD_INT 4
82338: NEG
82339: PUSH
82340: EMPTY
82341: LIST
82342: LIST
82343: PUSH
82344: LD_INT 2
82346: NEG
82347: PUSH
82348: LD_INT 3
82350: NEG
82351: PUSH
82352: EMPTY
82353: LIST
82354: LIST
82355: PUSH
82356: LD_INT 2
82358: NEG
82359: PUSH
82360: LD_INT 2
82362: NEG
82363: PUSH
82364: EMPTY
82365: LIST
82366: LIST
82367: PUSH
82368: LD_INT 3
82370: NEG
82371: PUSH
82372: LD_INT 2
82374: NEG
82375: PUSH
82376: EMPTY
82377: LIST
82378: LIST
82379: PUSH
82380: LD_INT 4
82382: NEG
82383: PUSH
82384: LD_INT 3
82386: NEG
82387: PUSH
82388: EMPTY
82389: LIST
82390: LIST
82391: PUSH
82392: LD_INT 4
82394: NEG
82395: PUSH
82396: LD_INT 4
82398: NEG
82399: PUSH
82400: EMPTY
82401: LIST
82402: LIST
82403: PUSH
82404: LD_INT 2
82406: NEG
82407: PUSH
82408: LD_INT 4
82410: NEG
82411: PUSH
82412: EMPTY
82413: LIST
82414: LIST
82415: PUSH
82416: LD_INT 4
82418: NEG
82419: PUSH
82420: LD_INT 2
82422: NEG
82423: PUSH
82424: EMPTY
82425: LIST
82426: LIST
82427: PUSH
82428: LD_INT 0
82430: PUSH
82431: LD_INT 4
82433: NEG
82434: PUSH
82435: EMPTY
82436: LIST
82437: LIST
82438: PUSH
82439: LD_INT 0
82441: PUSH
82442: LD_INT 5
82444: NEG
82445: PUSH
82446: EMPTY
82447: LIST
82448: LIST
82449: PUSH
82450: LD_INT 1
82452: PUSH
82453: LD_INT 4
82455: NEG
82456: PUSH
82457: EMPTY
82458: LIST
82459: LIST
82460: PUSH
82461: LD_INT 1
82463: PUSH
82464: LD_INT 3
82466: NEG
82467: PUSH
82468: EMPTY
82469: LIST
82470: LIST
82471: PUSH
82472: LD_INT 0
82474: PUSH
82475: LD_INT 3
82477: NEG
82478: PUSH
82479: EMPTY
82480: LIST
82481: LIST
82482: PUSH
82483: LD_INT 1
82485: NEG
82486: PUSH
82487: LD_INT 4
82489: NEG
82490: PUSH
82491: EMPTY
82492: LIST
82493: LIST
82494: PUSH
82495: LD_INT 1
82497: NEG
82498: PUSH
82499: LD_INT 5
82501: NEG
82502: PUSH
82503: EMPTY
82504: LIST
82505: LIST
82506: PUSH
82507: LD_INT 2
82509: PUSH
82510: LD_INT 3
82512: NEG
82513: PUSH
82514: EMPTY
82515: LIST
82516: LIST
82517: PUSH
82518: LD_INT 2
82520: NEG
82521: PUSH
82522: LD_INT 5
82524: NEG
82525: PUSH
82526: EMPTY
82527: LIST
82528: LIST
82529: PUSH
82530: LD_INT 3
82532: PUSH
82533: LD_INT 0
82535: PUSH
82536: EMPTY
82537: LIST
82538: LIST
82539: PUSH
82540: LD_INT 3
82542: PUSH
82543: LD_INT 1
82545: NEG
82546: PUSH
82547: EMPTY
82548: LIST
82549: LIST
82550: PUSH
82551: LD_INT 4
82553: PUSH
82554: LD_INT 0
82556: PUSH
82557: EMPTY
82558: LIST
82559: LIST
82560: PUSH
82561: LD_INT 4
82563: PUSH
82564: LD_INT 1
82566: PUSH
82567: EMPTY
82568: LIST
82569: LIST
82570: PUSH
82571: LD_INT 3
82573: PUSH
82574: LD_INT 1
82576: PUSH
82577: EMPTY
82578: LIST
82579: LIST
82580: PUSH
82581: LD_INT 2
82583: PUSH
82584: LD_INT 0
82586: PUSH
82587: EMPTY
82588: LIST
82589: LIST
82590: PUSH
82591: LD_INT 2
82593: PUSH
82594: LD_INT 1
82596: NEG
82597: PUSH
82598: EMPTY
82599: LIST
82600: LIST
82601: PUSH
82602: LD_INT 2
82604: PUSH
82605: LD_INT 2
82607: NEG
82608: PUSH
82609: EMPTY
82610: LIST
82611: LIST
82612: PUSH
82613: LD_INT 4
82615: PUSH
82616: LD_INT 2
82618: PUSH
82619: EMPTY
82620: LIST
82621: LIST
82622: PUSH
82623: LD_INT 4
82625: PUSH
82626: LD_INT 4
82628: PUSH
82629: EMPTY
82630: LIST
82631: LIST
82632: PUSH
82633: LD_INT 4
82635: PUSH
82636: LD_INT 3
82638: PUSH
82639: EMPTY
82640: LIST
82641: LIST
82642: PUSH
82643: LD_INT 5
82645: PUSH
82646: LD_INT 4
82648: PUSH
82649: EMPTY
82650: LIST
82651: LIST
82652: PUSH
82653: LD_INT 5
82655: PUSH
82656: LD_INT 5
82658: PUSH
82659: EMPTY
82660: LIST
82661: LIST
82662: PUSH
82663: LD_INT 4
82665: PUSH
82666: LD_INT 5
82668: PUSH
82669: EMPTY
82670: LIST
82671: LIST
82672: PUSH
82673: LD_INT 3
82675: PUSH
82676: LD_INT 4
82678: PUSH
82679: EMPTY
82680: LIST
82681: LIST
82682: PUSH
82683: LD_INT 3
82685: PUSH
82686: LD_INT 3
82688: PUSH
82689: EMPTY
82690: LIST
82691: LIST
82692: PUSH
82693: LD_INT 5
82695: PUSH
82696: LD_INT 3
82698: PUSH
82699: EMPTY
82700: LIST
82701: LIST
82702: PUSH
82703: LD_INT 3
82705: PUSH
82706: LD_INT 5
82708: PUSH
82709: EMPTY
82710: LIST
82711: LIST
82712: PUSH
82713: EMPTY
82714: LIST
82715: LIST
82716: LIST
82717: LIST
82718: LIST
82719: LIST
82720: LIST
82721: LIST
82722: LIST
82723: LIST
82724: LIST
82725: LIST
82726: LIST
82727: LIST
82728: LIST
82729: LIST
82730: LIST
82731: LIST
82732: LIST
82733: LIST
82734: LIST
82735: LIST
82736: LIST
82737: LIST
82738: LIST
82739: LIST
82740: LIST
82741: LIST
82742: LIST
82743: LIST
82744: LIST
82745: LIST
82746: LIST
82747: LIST
82748: LIST
82749: LIST
82750: LIST
82751: LIST
82752: LIST
82753: LIST
82754: LIST
82755: LIST
82756: LIST
82757: LIST
82758: LIST
82759: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
82760: LD_ADDR_VAR 0 33
82764: PUSH
82765: LD_INT 4
82767: NEG
82768: PUSH
82769: LD_INT 4
82771: NEG
82772: PUSH
82773: EMPTY
82774: LIST
82775: LIST
82776: PUSH
82777: LD_INT 4
82779: NEG
82780: PUSH
82781: LD_INT 5
82783: NEG
82784: PUSH
82785: EMPTY
82786: LIST
82787: LIST
82788: PUSH
82789: LD_INT 3
82791: NEG
82792: PUSH
82793: LD_INT 4
82795: NEG
82796: PUSH
82797: EMPTY
82798: LIST
82799: LIST
82800: PUSH
82801: LD_INT 3
82803: NEG
82804: PUSH
82805: LD_INT 3
82807: NEG
82808: PUSH
82809: EMPTY
82810: LIST
82811: LIST
82812: PUSH
82813: LD_INT 4
82815: NEG
82816: PUSH
82817: LD_INT 3
82819: NEG
82820: PUSH
82821: EMPTY
82822: LIST
82823: LIST
82824: PUSH
82825: LD_INT 5
82827: NEG
82828: PUSH
82829: LD_INT 4
82831: NEG
82832: PUSH
82833: EMPTY
82834: LIST
82835: LIST
82836: PUSH
82837: LD_INT 5
82839: NEG
82840: PUSH
82841: LD_INT 5
82843: NEG
82844: PUSH
82845: EMPTY
82846: LIST
82847: LIST
82848: PUSH
82849: LD_INT 3
82851: NEG
82852: PUSH
82853: LD_INT 5
82855: NEG
82856: PUSH
82857: EMPTY
82858: LIST
82859: LIST
82860: PUSH
82861: LD_INT 5
82863: NEG
82864: PUSH
82865: LD_INT 3
82867: NEG
82868: PUSH
82869: EMPTY
82870: LIST
82871: LIST
82872: PUSH
82873: LD_INT 0
82875: PUSH
82876: LD_INT 3
82878: NEG
82879: PUSH
82880: EMPTY
82881: LIST
82882: LIST
82883: PUSH
82884: LD_INT 0
82886: PUSH
82887: LD_INT 4
82889: NEG
82890: PUSH
82891: EMPTY
82892: LIST
82893: LIST
82894: PUSH
82895: LD_INT 1
82897: PUSH
82898: LD_INT 3
82900: NEG
82901: PUSH
82902: EMPTY
82903: LIST
82904: LIST
82905: PUSH
82906: LD_INT 1
82908: PUSH
82909: LD_INT 2
82911: NEG
82912: PUSH
82913: EMPTY
82914: LIST
82915: LIST
82916: PUSH
82917: LD_INT 0
82919: PUSH
82920: LD_INT 2
82922: NEG
82923: PUSH
82924: EMPTY
82925: LIST
82926: LIST
82927: PUSH
82928: LD_INT 1
82930: NEG
82931: PUSH
82932: LD_INT 3
82934: NEG
82935: PUSH
82936: EMPTY
82937: LIST
82938: LIST
82939: PUSH
82940: LD_INT 1
82942: NEG
82943: PUSH
82944: LD_INT 4
82946: NEG
82947: PUSH
82948: EMPTY
82949: LIST
82950: LIST
82951: PUSH
82952: LD_INT 2
82954: PUSH
82955: LD_INT 2
82957: NEG
82958: PUSH
82959: EMPTY
82960: LIST
82961: LIST
82962: PUSH
82963: LD_INT 2
82965: NEG
82966: PUSH
82967: LD_INT 4
82969: NEG
82970: PUSH
82971: EMPTY
82972: LIST
82973: LIST
82974: PUSH
82975: LD_INT 4
82977: PUSH
82978: LD_INT 0
82980: PUSH
82981: EMPTY
82982: LIST
82983: LIST
82984: PUSH
82985: LD_INT 4
82987: PUSH
82988: LD_INT 1
82990: NEG
82991: PUSH
82992: EMPTY
82993: LIST
82994: LIST
82995: PUSH
82996: LD_INT 5
82998: PUSH
82999: LD_INT 0
83001: PUSH
83002: EMPTY
83003: LIST
83004: LIST
83005: PUSH
83006: LD_INT 5
83008: PUSH
83009: LD_INT 1
83011: PUSH
83012: EMPTY
83013: LIST
83014: LIST
83015: PUSH
83016: LD_INT 4
83018: PUSH
83019: LD_INT 1
83021: PUSH
83022: EMPTY
83023: LIST
83024: LIST
83025: PUSH
83026: LD_INT 3
83028: PUSH
83029: LD_INT 0
83031: PUSH
83032: EMPTY
83033: LIST
83034: LIST
83035: PUSH
83036: LD_INT 3
83038: PUSH
83039: LD_INT 1
83041: NEG
83042: PUSH
83043: EMPTY
83044: LIST
83045: LIST
83046: PUSH
83047: LD_INT 3
83049: PUSH
83050: LD_INT 2
83052: NEG
83053: PUSH
83054: EMPTY
83055: LIST
83056: LIST
83057: PUSH
83058: LD_INT 5
83060: PUSH
83061: LD_INT 2
83063: PUSH
83064: EMPTY
83065: LIST
83066: LIST
83067: PUSH
83068: LD_INT 3
83070: PUSH
83071: LD_INT 3
83073: PUSH
83074: EMPTY
83075: LIST
83076: LIST
83077: PUSH
83078: LD_INT 3
83080: PUSH
83081: LD_INT 2
83083: PUSH
83084: EMPTY
83085: LIST
83086: LIST
83087: PUSH
83088: LD_INT 4
83090: PUSH
83091: LD_INT 3
83093: PUSH
83094: EMPTY
83095: LIST
83096: LIST
83097: PUSH
83098: LD_INT 4
83100: PUSH
83101: LD_INT 4
83103: PUSH
83104: EMPTY
83105: LIST
83106: LIST
83107: PUSH
83108: LD_INT 3
83110: PUSH
83111: LD_INT 4
83113: PUSH
83114: EMPTY
83115: LIST
83116: LIST
83117: PUSH
83118: LD_INT 2
83120: PUSH
83121: LD_INT 3
83123: PUSH
83124: EMPTY
83125: LIST
83126: LIST
83127: PUSH
83128: LD_INT 2
83130: PUSH
83131: LD_INT 2
83133: PUSH
83134: EMPTY
83135: LIST
83136: LIST
83137: PUSH
83138: LD_INT 4
83140: PUSH
83141: LD_INT 2
83143: PUSH
83144: EMPTY
83145: LIST
83146: LIST
83147: PUSH
83148: LD_INT 2
83150: PUSH
83151: LD_INT 4
83153: PUSH
83154: EMPTY
83155: LIST
83156: LIST
83157: PUSH
83158: LD_INT 0
83160: PUSH
83161: LD_INT 4
83163: PUSH
83164: EMPTY
83165: LIST
83166: LIST
83167: PUSH
83168: LD_INT 0
83170: PUSH
83171: LD_INT 3
83173: PUSH
83174: EMPTY
83175: LIST
83176: LIST
83177: PUSH
83178: LD_INT 1
83180: PUSH
83181: LD_INT 4
83183: PUSH
83184: EMPTY
83185: LIST
83186: LIST
83187: PUSH
83188: LD_INT 1
83190: PUSH
83191: LD_INT 5
83193: PUSH
83194: EMPTY
83195: LIST
83196: LIST
83197: PUSH
83198: LD_INT 0
83200: PUSH
83201: LD_INT 5
83203: PUSH
83204: EMPTY
83205: LIST
83206: LIST
83207: PUSH
83208: LD_INT 1
83210: NEG
83211: PUSH
83212: LD_INT 4
83214: PUSH
83215: EMPTY
83216: LIST
83217: LIST
83218: PUSH
83219: LD_INT 1
83221: NEG
83222: PUSH
83223: LD_INT 3
83225: PUSH
83226: EMPTY
83227: LIST
83228: LIST
83229: PUSH
83230: LD_INT 2
83232: PUSH
83233: LD_INT 5
83235: PUSH
83236: EMPTY
83237: LIST
83238: LIST
83239: PUSH
83240: LD_INT 2
83242: NEG
83243: PUSH
83244: LD_INT 3
83246: PUSH
83247: EMPTY
83248: LIST
83249: LIST
83250: PUSH
83251: EMPTY
83252: LIST
83253: LIST
83254: LIST
83255: LIST
83256: LIST
83257: LIST
83258: LIST
83259: LIST
83260: LIST
83261: LIST
83262: LIST
83263: LIST
83264: LIST
83265: LIST
83266: LIST
83267: LIST
83268: LIST
83269: LIST
83270: LIST
83271: LIST
83272: LIST
83273: LIST
83274: LIST
83275: LIST
83276: LIST
83277: LIST
83278: LIST
83279: LIST
83280: LIST
83281: LIST
83282: LIST
83283: LIST
83284: LIST
83285: LIST
83286: LIST
83287: LIST
83288: LIST
83289: LIST
83290: LIST
83291: LIST
83292: LIST
83293: LIST
83294: LIST
83295: LIST
83296: LIST
83297: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
83298: LD_ADDR_VAR 0 34
83302: PUSH
83303: LD_INT 0
83305: PUSH
83306: LD_INT 4
83308: NEG
83309: PUSH
83310: EMPTY
83311: LIST
83312: LIST
83313: PUSH
83314: LD_INT 0
83316: PUSH
83317: LD_INT 5
83319: NEG
83320: PUSH
83321: EMPTY
83322: LIST
83323: LIST
83324: PUSH
83325: LD_INT 1
83327: PUSH
83328: LD_INT 4
83330: NEG
83331: PUSH
83332: EMPTY
83333: LIST
83334: LIST
83335: PUSH
83336: LD_INT 1
83338: PUSH
83339: LD_INT 3
83341: NEG
83342: PUSH
83343: EMPTY
83344: LIST
83345: LIST
83346: PUSH
83347: LD_INT 0
83349: PUSH
83350: LD_INT 3
83352: NEG
83353: PUSH
83354: EMPTY
83355: LIST
83356: LIST
83357: PUSH
83358: LD_INT 1
83360: NEG
83361: PUSH
83362: LD_INT 4
83364: NEG
83365: PUSH
83366: EMPTY
83367: LIST
83368: LIST
83369: PUSH
83370: LD_INT 1
83372: NEG
83373: PUSH
83374: LD_INT 5
83376: NEG
83377: PUSH
83378: EMPTY
83379: LIST
83380: LIST
83381: PUSH
83382: LD_INT 2
83384: PUSH
83385: LD_INT 3
83387: NEG
83388: PUSH
83389: EMPTY
83390: LIST
83391: LIST
83392: PUSH
83393: LD_INT 2
83395: NEG
83396: PUSH
83397: LD_INT 5
83399: NEG
83400: PUSH
83401: EMPTY
83402: LIST
83403: LIST
83404: PUSH
83405: LD_INT 3
83407: PUSH
83408: LD_INT 0
83410: PUSH
83411: EMPTY
83412: LIST
83413: LIST
83414: PUSH
83415: LD_INT 3
83417: PUSH
83418: LD_INT 1
83420: NEG
83421: PUSH
83422: EMPTY
83423: LIST
83424: LIST
83425: PUSH
83426: LD_INT 4
83428: PUSH
83429: LD_INT 0
83431: PUSH
83432: EMPTY
83433: LIST
83434: LIST
83435: PUSH
83436: LD_INT 4
83438: PUSH
83439: LD_INT 1
83441: PUSH
83442: EMPTY
83443: LIST
83444: LIST
83445: PUSH
83446: LD_INT 3
83448: PUSH
83449: LD_INT 1
83451: PUSH
83452: EMPTY
83453: LIST
83454: LIST
83455: PUSH
83456: LD_INT 2
83458: PUSH
83459: LD_INT 0
83461: PUSH
83462: EMPTY
83463: LIST
83464: LIST
83465: PUSH
83466: LD_INT 2
83468: PUSH
83469: LD_INT 1
83471: NEG
83472: PUSH
83473: EMPTY
83474: LIST
83475: LIST
83476: PUSH
83477: LD_INT 2
83479: PUSH
83480: LD_INT 2
83482: NEG
83483: PUSH
83484: EMPTY
83485: LIST
83486: LIST
83487: PUSH
83488: LD_INT 4
83490: PUSH
83491: LD_INT 2
83493: PUSH
83494: EMPTY
83495: LIST
83496: LIST
83497: PUSH
83498: LD_INT 4
83500: PUSH
83501: LD_INT 4
83503: PUSH
83504: EMPTY
83505: LIST
83506: LIST
83507: PUSH
83508: LD_INT 4
83510: PUSH
83511: LD_INT 3
83513: PUSH
83514: EMPTY
83515: LIST
83516: LIST
83517: PUSH
83518: LD_INT 5
83520: PUSH
83521: LD_INT 4
83523: PUSH
83524: EMPTY
83525: LIST
83526: LIST
83527: PUSH
83528: LD_INT 5
83530: PUSH
83531: LD_INT 5
83533: PUSH
83534: EMPTY
83535: LIST
83536: LIST
83537: PUSH
83538: LD_INT 4
83540: PUSH
83541: LD_INT 5
83543: PUSH
83544: EMPTY
83545: LIST
83546: LIST
83547: PUSH
83548: LD_INT 3
83550: PUSH
83551: LD_INT 4
83553: PUSH
83554: EMPTY
83555: LIST
83556: LIST
83557: PUSH
83558: LD_INT 3
83560: PUSH
83561: LD_INT 3
83563: PUSH
83564: EMPTY
83565: LIST
83566: LIST
83567: PUSH
83568: LD_INT 5
83570: PUSH
83571: LD_INT 3
83573: PUSH
83574: EMPTY
83575: LIST
83576: LIST
83577: PUSH
83578: LD_INT 3
83580: PUSH
83581: LD_INT 5
83583: PUSH
83584: EMPTY
83585: LIST
83586: LIST
83587: PUSH
83588: LD_INT 0
83590: PUSH
83591: LD_INT 3
83593: PUSH
83594: EMPTY
83595: LIST
83596: LIST
83597: PUSH
83598: LD_INT 0
83600: PUSH
83601: LD_INT 2
83603: PUSH
83604: EMPTY
83605: LIST
83606: LIST
83607: PUSH
83608: LD_INT 1
83610: PUSH
83611: LD_INT 3
83613: PUSH
83614: EMPTY
83615: LIST
83616: LIST
83617: PUSH
83618: LD_INT 1
83620: PUSH
83621: LD_INT 4
83623: PUSH
83624: EMPTY
83625: LIST
83626: LIST
83627: PUSH
83628: LD_INT 0
83630: PUSH
83631: LD_INT 4
83633: PUSH
83634: EMPTY
83635: LIST
83636: LIST
83637: PUSH
83638: LD_INT 1
83640: NEG
83641: PUSH
83642: LD_INT 3
83644: PUSH
83645: EMPTY
83646: LIST
83647: LIST
83648: PUSH
83649: LD_INT 1
83651: NEG
83652: PUSH
83653: LD_INT 2
83655: PUSH
83656: EMPTY
83657: LIST
83658: LIST
83659: PUSH
83660: LD_INT 2
83662: PUSH
83663: LD_INT 4
83665: PUSH
83666: EMPTY
83667: LIST
83668: LIST
83669: PUSH
83670: LD_INT 2
83672: NEG
83673: PUSH
83674: LD_INT 2
83676: PUSH
83677: EMPTY
83678: LIST
83679: LIST
83680: PUSH
83681: LD_INT 4
83683: NEG
83684: PUSH
83685: LD_INT 0
83687: PUSH
83688: EMPTY
83689: LIST
83690: LIST
83691: PUSH
83692: LD_INT 4
83694: NEG
83695: PUSH
83696: LD_INT 1
83698: NEG
83699: PUSH
83700: EMPTY
83701: LIST
83702: LIST
83703: PUSH
83704: LD_INT 3
83706: NEG
83707: PUSH
83708: LD_INT 0
83710: PUSH
83711: EMPTY
83712: LIST
83713: LIST
83714: PUSH
83715: LD_INT 3
83717: NEG
83718: PUSH
83719: LD_INT 1
83721: PUSH
83722: EMPTY
83723: LIST
83724: LIST
83725: PUSH
83726: LD_INT 4
83728: NEG
83729: PUSH
83730: LD_INT 1
83732: PUSH
83733: EMPTY
83734: LIST
83735: LIST
83736: PUSH
83737: LD_INT 5
83739: NEG
83740: PUSH
83741: LD_INT 0
83743: PUSH
83744: EMPTY
83745: LIST
83746: LIST
83747: PUSH
83748: LD_INT 5
83750: NEG
83751: PUSH
83752: LD_INT 1
83754: NEG
83755: PUSH
83756: EMPTY
83757: LIST
83758: LIST
83759: PUSH
83760: LD_INT 5
83762: NEG
83763: PUSH
83764: LD_INT 2
83766: NEG
83767: PUSH
83768: EMPTY
83769: LIST
83770: LIST
83771: PUSH
83772: LD_INT 3
83774: NEG
83775: PUSH
83776: LD_INT 2
83778: PUSH
83779: EMPTY
83780: LIST
83781: LIST
83782: PUSH
83783: EMPTY
83784: LIST
83785: LIST
83786: LIST
83787: LIST
83788: LIST
83789: LIST
83790: LIST
83791: LIST
83792: LIST
83793: LIST
83794: LIST
83795: LIST
83796: LIST
83797: LIST
83798: LIST
83799: LIST
83800: LIST
83801: LIST
83802: LIST
83803: LIST
83804: LIST
83805: LIST
83806: LIST
83807: LIST
83808: LIST
83809: LIST
83810: LIST
83811: LIST
83812: LIST
83813: LIST
83814: LIST
83815: LIST
83816: LIST
83817: LIST
83818: LIST
83819: LIST
83820: LIST
83821: LIST
83822: LIST
83823: LIST
83824: LIST
83825: LIST
83826: LIST
83827: LIST
83828: LIST
83829: ST_TO_ADDR
// end ; end ;
83830: GO 83833
83832: POP
// case btype of b_depot , b_warehouse :
83833: LD_VAR 0 1
83837: PUSH
83838: LD_INT 0
83840: DOUBLE
83841: EQUAL
83842: IFTRUE 83852
83844: LD_INT 1
83846: DOUBLE
83847: EQUAL
83848: IFTRUE 83852
83850: GO 84053
83852: POP
// case nation of nation_american :
83853: LD_VAR 0 5
83857: PUSH
83858: LD_INT 1
83860: DOUBLE
83861: EQUAL
83862: IFTRUE 83866
83864: GO 83922
83866: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
83867: LD_ADDR_VAR 0 9
83871: PUSH
83872: LD_VAR 0 11
83876: PUSH
83877: LD_VAR 0 12
83881: PUSH
83882: LD_VAR 0 13
83886: PUSH
83887: LD_VAR 0 14
83891: PUSH
83892: LD_VAR 0 15
83896: PUSH
83897: LD_VAR 0 16
83901: PUSH
83902: EMPTY
83903: LIST
83904: LIST
83905: LIST
83906: LIST
83907: LIST
83908: LIST
83909: PUSH
83910: LD_VAR 0 4
83914: PUSH
83915: LD_INT 1
83917: PLUS
83918: ARRAY
83919: ST_TO_ADDR
83920: GO 84051
83922: LD_INT 2
83924: DOUBLE
83925: EQUAL
83926: IFTRUE 83930
83928: GO 83986
83930: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
83931: LD_ADDR_VAR 0 9
83935: PUSH
83936: LD_VAR 0 17
83940: PUSH
83941: LD_VAR 0 18
83945: PUSH
83946: LD_VAR 0 19
83950: PUSH
83951: LD_VAR 0 20
83955: PUSH
83956: LD_VAR 0 21
83960: PUSH
83961: LD_VAR 0 22
83965: PUSH
83966: EMPTY
83967: LIST
83968: LIST
83969: LIST
83970: LIST
83971: LIST
83972: LIST
83973: PUSH
83974: LD_VAR 0 4
83978: PUSH
83979: LD_INT 1
83981: PLUS
83982: ARRAY
83983: ST_TO_ADDR
83984: GO 84051
83986: LD_INT 3
83988: DOUBLE
83989: EQUAL
83990: IFTRUE 83994
83992: GO 84050
83994: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
83995: LD_ADDR_VAR 0 9
83999: PUSH
84000: LD_VAR 0 23
84004: PUSH
84005: LD_VAR 0 24
84009: PUSH
84010: LD_VAR 0 25
84014: PUSH
84015: LD_VAR 0 26
84019: PUSH
84020: LD_VAR 0 27
84024: PUSH
84025: LD_VAR 0 28
84029: PUSH
84030: EMPTY
84031: LIST
84032: LIST
84033: LIST
84034: LIST
84035: LIST
84036: LIST
84037: PUSH
84038: LD_VAR 0 4
84042: PUSH
84043: LD_INT 1
84045: PLUS
84046: ARRAY
84047: ST_TO_ADDR
84048: GO 84051
84050: POP
84051: GO 84606
84053: LD_INT 2
84055: DOUBLE
84056: EQUAL
84057: IFTRUE 84067
84059: LD_INT 3
84061: DOUBLE
84062: EQUAL
84063: IFTRUE 84067
84065: GO 84123
84067: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
84068: LD_ADDR_VAR 0 9
84072: PUSH
84073: LD_VAR 0 29
84077: PUSH
84078: LD_VAR 0 30
84082: PUSH
84083: LD_VAR 0 31
84087: PUSH
84088: LD_VAR 0 32
84092: PUSH
84093: LD_VAR 0 33
84097: PUSH
84098: LD_VAR 0 34
84102: PUSH
84103: EMPTY
84104: LIST
84105: LIST
84106: LIST
84107: LIST
84108: LIST
84109: LIST
84110: PUSH
84111: LD_VAR 0 4
84115: PUSH
84116: LD_INT 1
84118: PLUS
84119: ARRAY
84120: ST_TO_ADDR
84121: GO 84606
84123: LD_INT 16
84125: DOUBLE
84126: EQUAL
84127: IFTRUE 84185
84129: LD_INT 17
84131: DOUBLE
84132: EQUAL
84133: IFTRUE 84185
84135: LD_INT 18
84137: DOUBLE
84138: EQUAL
84139: IFTRUE 84185
84141: LD_INT 19
84143: DOUBLE
84144: EQUAL
84145: IFTRUE 84185
84147: LD_INT 22
84149: DOUBLE
84150: EQUAL
84151: IFTRUE 84185
84153: LD_INT 20
84155: DOUBLE
84156: EQUAL
84157: IFTRUE 84185
84159: LD_INT 21
84161: DOUBLE
84162: EQUAL
84163: IFTRUE 84185
84165: LD_INT 23
84167: DOUBLE
84168: EQUAL
84169: IFTRUE 84185
84171: LD_INT 24
84173: DOUBLE
84174: EQUAL
84175: IFTRUE 84185
84177: LD_INT 25
84179: DOUBLE
84180: EQUAL
84181: IFTRUE 84185
84183: GO 84241
84185: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
84186: LD_ADDR_VAR 0 9
84190: PUSH
84191: LD_VAR 0 35
84195: PUSH
84196: LD_VAR 0 36
84200: PUSH
84201: LD_VAR 0 37
84205: PUSH
84206: LD_VAR 0 38
84210: PUSH
84211: LD_VAR 0 39
84215: PUSH
84216: LD_VAR 0 40
84220: PUSH
84221: EMPTY
84222: LIST
84223: LIST
84224: LIST
84225: LIST
84226: LIST
84227: LIST
84228: PUSH
84229: LD_VAR 0 4
84233: PUSH
84234: LD_INT 1
84236: PLUS
84237: ARRAY
84238: ST_TO_ADDR
84239: GO 84606
84241: LD_INT 6
84243: DOUBLE
84244: EQUAL
84245: IFTRUE 84297
84247: LD_INT 7
84249: DOUBLE
84250: EQUAL
84251: IFTRUE 84297
84253: LD_INT 8
84255: DOUBLE
84256: EQUAL
84257: IFTRUE 84297
84259: LD_INT 13
84261: DOUBLE
84262: EQUAL
84263: IFTRUE 84297
84265: LD_INT 12
84267: DOUBLE
84268: EQUAL
84269: IFTRUE 84297
84271: LD_INT 15
84273: DOUBLE
84274: EQUAL
84275: IFTRUE 84297
84277: LD_INT 11
84279: DOUBLE
84280: EQUAL
84281: IFTRUE 84297
84283: LD_INT 14
84285: DOUBLE
84286: EQUAL
84287: IFTRUE 84297
84289: LD_INT 10
84291: DOUBLE
84292: EQUAL
84293: IFTRUE 84297
84295: GO 84353
84297: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
84298: LD_ADDR_VAR 0 9
84302: PUSH
84303: LD_VAR 0 41
84307: PUSH
84308: LD_VAR 0 42
84312: PUSH
84313: LD_VAR 0 43
84317: PUSH
84318: LD_VAR 0 44
84322: PUSH
84323: LD_VAR 0 45
84327: PUSH
84328: LD_VAR 0 46
84332: PUSH
84333: EMPTY
84334: LIST
84335: LIST
84336: LIST
84337: LIST
84338: LIST
84339: LIST
84340: PUSH
84341: LD_VAR 0 4
84345: PUSH
84346: LD_INT 1
84348: PLUS
84349: ARRAY
84350: ST_TO_ADDR
84351: GO 84606
84353: LD_INT 36
84355: DOUBLE
84356: EQUAL
84357: IFTRUE 84361
84359: GO 84417
84361: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
84362: LD_ADDR_VAR 0 9
84366: PUSH
84367: LD_VAR 0 47
84371: PUSH
84372: LD_VAR 0 48
84376: PUSH
84377: LD_VAR 0 49
84381: PUSH
84382: LD_VAR 0 50
84386: PUSH
84387: LD_VAR 0 51
84391: PUSH
84392: LD_VAR 0 52
84396: PUSH
84397: EMPTY
84398: LIST
84399: LIST
84400: LIST
84401: LIST
84402: LIST
84403: LIST
84404: PUSH
84405: LD_VAR 0 4
84409: PUSH
84410: LD_INT 1
84412: PLUS
84413: ARRAY
84414: ST_TO_ADDR
84415: GO 84606
84417: LD_INT 4
84419: DOUBLE
84420: EQUAL
84421: IFTRUE 84443
84423: LD_INT 5
84425: DOUBLE
84426: EQUAL
84427: IFTRUE 84443
84429: LD_INT 34
84431: DOUBLE
84432: EQUAL
84433: IFTRUE 84443
84435: LD_INT 37
84437: DOUBLE
84438: EQUAL
84439: IFTRUE 84443
84441: GO 84499
84443: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
84444: LD_ADDR_VAR 0 9
84448: PUSH
84449: LD_VAR 0 53
84453: PUSH
84454: LD_VAR 0 54
84458: PUSH
84459: LD_VAR 0 55
84463: PUSH
84464: LD_VAR 0 56
84468: PUSH
84469: LD_VAR 0 57
84473: PUSH
84474: LD_VAR 0 58
84478: PUSH
84479: EMPTY
84480: LIST
84481: LIST
84482: LIST
84483: LIST
84484: LIST
84485: LIST
84486: PUSH
84487: LD_VAR 0 4
84491: PUSH
84492: LD_INT 1
84494: PLUS
84495: ARRAY
84496: ST_TO_ADDR
84497: GO 84606
84499: LD_INT 31
84501: DOUBLE
84502: EQUAL
84503: IFTRUE 84549
84505: LD_INT 32
84507: DOUBLE
84508: EQUAL
84509: IFTRUE 84549
84511: LD_INT 33
84513: DOUBLE
84514: EQUAL
84515: IFTRUE 84549
84517: LD_INT 27
84519: DOUBLE
84520: EQUAL
84521: IFTRUE 84549
84523: LD_INT 26
84525: DOUBLE
84526: EQUAL
84527: IFTRUE 84549
84529: LD_INT 28
84531: DOUBLE
84532: EQUAL
84533: IFTRUE 84549
84535: LD_INT 29
84537: DOUBLE
84538: EQUAL
84539: IFTRUE 84549
84541: LD_INT 30
84543: DOUBLE
84544: EQUAL
84545: IFTRUE 84549
84547: GO 84605
84549: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
84550: LD_ADDR_VAR 0 9
84554: PUSH
84555: LD_VAR 0 59
84559: PUSH
84560: LD_VAR 0 60
84564: PUSH
84565: LD_VAR 0 61
84569: PUSH
84570: LD_VAR 0 62
84574: PUSH
84575: LD_VAR 0 63
84579: PUSH
84580: LD_VAR 0 64
84584: PUSH
84585: EMPTY
84586: LIST
84587: LIST
84588: LIST
84589: LIST
84590: LIST
84591: LIST
84592: PUSH
84593: LD_VAR 0 4
84597: PUSH
84598: LD_INT 1
84600: PLUS
84601: ARRAY
84602: ST_TO_ADDR
84603: GO 84606
84605: POP
// temp_list2 = [ ] ;
84606: LD_ADDR_VAR 0 10
84610: PUSH
84611: EMPTY
84612: ST_TO_ADDR
// for i in temp_list do
84613: LD_ADDR_VAR 0 8
84617: PUSH
84618: LD_VAR 0 9
84622: PUSH
84623: FOR_IN
84624: IFFALSE 84676
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
84626: LD_ADDR_VAR 0 10
84630: PUSH
84631: LD_VAR 0 10
84635: PUSH
84636: LD_VAR 0 8
84640: PUSH
84641: LD_INT 1
84643: ARRAY
84644: PUSH
84645: LD_VAR 0 2
84649: PLUS
84650: PUSH
84651: LD_VAR 0 8
84655: PUSH
84656: LD_INT 2
84658: ARRAY
84659: PUSH
84660: LD_VAR 0 3
84664: PLUS
84665: PUSH
84666: EMPTY
84667: LIST
84668: LIST
84669: PUSH
84670: EMPTY
84671: LIST
84672: ADD
84673: ST_TO_ADDR
84674: GO 84623
84676: POP
84677: POP
// result = temp_list2 ;
84678: LD_ADDR_VAR 0 7
84682: PUSH
84683: LD_VAR 0 10
84687: ST_TO_ADDR
// end ;
84688: LD_VAR 0 7
84692: RET
// export function EnemyInRange ( unit , dist ) ; begin
84693: LD_INT 0
84695: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
84696: LD_ADDR_VAR 0 3
84700: PUSH
84701: LD_VAR 0 1
84705: PPUSH
84706: CALL_OW 255
84710: PPUSH
84711: LD_VAR 0 1
84715: PPUSH
84716: CALL_OW 250
84720: PPUSH
84721: LD_VAR 0 1
84725: PPUSH
84726: CALL_OW 251
84730: PPUSH
84731: LD_VAR 0 2
84735: PPUSH
84736: CALL 58095 0 4
84740: PUSH
84741: LD_INT 4
84743: ARRAY
84744: ST_TO_ADDR
// end ;
84745: LD_VAR 0 3
84749: RET
// export function PlayerSeeMe ( unit ) ; begin
84750: LD_INT 0
84752: PPUSH
// result := See ( your_side , unit ) ;
84753: LD_ADDR_VAR 0 2
84757: PUSH
84758: LD_OWVAR 2
84762: PPUSH
84763: LD_VAR 0 1
84767: PPUSH
84768: CALL_OW 292
84772: ST_TO_ADDR
// end ;
84773: LD_VAR 0 2
84777: RET
// export function ReverseDir ( unit ) ; begin
84778: LD_INT 0
84780: PPUSH
// if not unit then
84781: LD_VAR 0 1
84785: NOT
84786: IFFALSE 84790
// exit ;
84788: GO 84813
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
84790: LD_ADDR_VAR 0 2
84794: PUSH
84795: LD_VAR 0 1
84799: PPUSH
84800: CALL_OW 254
84804: PUSH
84805: LD_INT 3
84807: PLUS
84808: PUSH
84809: LD_INT 6
84811: MOD
84812: ST_TO_ADDR
// end ;
84813: LD_VAR 0 2
84817: RET
// export function ReverseArray ( array ) ; var i ; begin
84818: LD_INT 0
84820: PPUSH
84821: PPUSH
// if not array then
84822: LD_VAR 0 1
84826: NOT
84827: IFFALSE 84831
// exit ;
84829: GO 84886
// result := [ ] ;
84831: LD_ADDR_VAR 0 2
84835: PUSH
84836: EMPTY
84837: ST_TO_ADDR
// for i := array downto 1 do
84838: LD_ADDR_VAR 0 3
84842: PUSH
84843: DOUBLE
84844: LD_VAR 0 1
84848: INC
84849: ST_TO_ADDR
84850: LD_INT 1
84852: PUSH
84853: FOR_DOWNTO
84854: IFFALSE 84884
// result := Join ( result , array [ i ] ) ;
84856: LD_ADDR_VAR 0 2
84860: PUSH
84861: LD_VAR 0 2
84865: PPUSH
84866: LD_VAR 0 1
84870: PUSH
84871: LD_VAR 0 3
84875: ARRAY
84876: PPUSH
84877: CALL 89530 0 2
84881: ST_TO_ADDR
84882: GO 84853
84884: POP
84885: POP
// end ;
84886: LD_VAR 0 2
84890: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
84891: LD_INT 0
84893: PPUSH
84894: PPUSH
84895: PPUSH
84896: PPUSH
84897: PPUSH
84898: PPUSH
// if not unit or not hexes then
84899: LD_VAR 0 1
84903: NOT
84904: PUSH
84905: LD_VAR 0 2
84909: NOT
84910: OR
84911: IFFALSE 84915
// exit ;
84913: GO 85038
// dist := 9999 ;
84915: LD_ADDR_VAR 0 5
84919: PUSH
84920: LD_INT 9999
84922: ST_TO_ADDR
// for i = 1 to hexes do
84923: LD_ADDR_VAR 0 4
84927: PUSH
84928: DOUBLE
84929: LD_INT 1
84931: DEC
84932: ST_TO_ADDR
84933: LD_VAR 0 2
84937: PUSH
84938: FOR_TO
84939: IFFALSE 85026
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
84941: LD_ADDR_VAR 0 6
84945: PUSH
84946: LD_VAR 0 1
84950: PPUSH
84951: LD_VAR 0 2
84955: PUSH
84956: LD_VAR 0 4
84960: ARRAY
84961: PUSH
84962: LD_INT 1
84964: ARRAY
84965: PPUSH
84966: LD_VAR 0 2
84970: PUSH
84971: LD_VAR 0 4
84975: ARRAY
84976: PUSH
84977: LD_INT 2
84979: ARRAY
84980: PPUSH
84981: CALL_OW 297
84985: ST_TO_ADDR
// if tdist < dist then
84986: LD_VAR 0 6
84990: PUSH
84991: LD_VAR 0 5
84995: LESS
84996: IFFALSE 85024
// begin hex := hexes [ i ] ;
84998: LD_ADDR_VAR 0 8
85002: PUSH
85003: LD_VAR 0 2
85007: PUSH
85008: LD_VAR 0 4
85012: ARRAY
85013: ST_TO_ADDR
// dist := tdist ;
85014: LD_ADDR_VAR 0 5
85018: PUSH
85019: LD_VAR 0 6
85023: ST_TO_ADDR
// end ; end ;
85024: GO 84938
85026: POP
85027: POP
// result := hex ;
85028: LD_ADDR_VAR 0 3
85032: PUSH
85033: LD_VAR 0 8
85037: ST_TO_ADDR
// end ;
85038: LD_VAR 0 3
85042: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
85043: LD_INT 0
85045: PPUSH
85046: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
85047: LD_VAR 0 1
85051: NOT
85052: PUSH
85053: LD_VAR 0 1
85057: PUSH
85058: LD_INT 21
85060: PUSH
85061: LD_INT 2
85063: PUSH
85064: EMPTY
85065: LIST
85066: LIST
85067: PUSH
85068: LD_INT 23
85070: PUSH
85071: LD_INT 2
85073: PUSH
85074: EMPTY
85075: LIST
85076: LIST
85077: PUSH
85078: EMPTY
85079: LIST
85080: LIST
85081: PPUSH
85082: CALL_OW 69
85086: IN
85087: NOT
85088: OR
85089: IFFALSE 85093
// exit ;
85091: GO 85140
// for i = 1 to 3 do
85093: LD_ADDR_VAR 0 3
85097: PUSH
85098: DOUBLE
85099: LD_INT 1
85101: DEC
85102: ST_TO_ADDR
85103: LD_INT 3
85105: PUSH
85106: FOR_TO
85107: IFFALSE 85138
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
85109: LD_VAR 0 1
85113: PPUSH
85114: CALL_OW 250
85118: PPUSH
85119: LD_VAR 0 1
85123: PPUSH
85124: CALL_OW 251
85128: PPUSH
85129: LD_INT 1
85131: PPUSH
85132: CALL_OW 453
85136: GO 85106
85138: POP
85139: POP
// end ;
85140: LD_VAR 0 2
85144: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
85145: LD_INT 0
85147: PPUSH
85148: PPUSH
85149: PPUSH
85150: PPUSH
85151: PPUSH
85152: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
85153: LD_VAR 0 1
85157: NOT
85158: PUSH
85159: LD_VAR 0 2
85163: NOT
85164: OR
85165: PUSH
85166: LD_VAR 0 1
85170: PPUSH
85171: CALL_OW 314
85175: OR
85176: IFFALSE 85180
// exit ;
85178: GO 85647
// if GetLives ( i ) < 250 then
85180: LD_VAR 0 4
85184: PPUSH
85185: CALL_OW 256
85189: PUSH
85190: LD_INT 250
85192: LESS
85193: IFFALSE 85206
// begin ComAutodestruct ( i ) ;
85195: LD_VAR 0 4
85199: PPUSH
85200: CALL 85043 0 1
// exit ;
85204: GO 85647
// end ; x := GetX ( enemy_unit ) ;
85206: LD_ADDR_VAR 0 7
85210: PUSH
85211: LD_VAR 0 2
85215: PPUSH
85216: CALL_OW 250
85220: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
85221: LD_ADDR_VAR 0 8
85225: PUSH
85226: LD_VAR 0 2
85230: PPUSH
85231: CALL_OW 251
85235: ST_TO_ADDR
// if not x or not y then
85236: LD_VAR 0 7
85240: NOT
85241: PUSH
85242: LD_VAR 0 8
85246: NOT
85247: OR
85248: IFFALSE 85252
// exit ;
85250: GO 85647
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
85252: LD_ADDR_VAR 0 6
85256: PUSH
85257: LD_VAR 0 7
85261: PPUSH
85262: LD_INT 0
85264: PPUSH
85265: LD_INT 4
85267: PPUSH
85268: CALL_OW 272
85272: PUSH
85273: LD_VAR 0 8
85277: PPUSH
85278: LD_INT 0
85280: PPUSH
85281: LD_INT 4
85283: PPUSH
85284: CALL_OW 273
85288: PUSH
85289: EMPTY
85290: LIST
85291: LIST
85292: PUSH
85293: LD_VAR 0 7
85297: PPUSH
85298: LD_INT 1
85300: PPUSH
85301: LD_INT 4
85303: PPUSH
85304: CALL_OW 272
85308: PUSH
85309: LD_VAR 0 8
85313: PPUSH
85314: LD_INT 1
85316: PPUSH
85317: LD_INT 4
85319: PPUSH
85320: CALL_OW 273
85324: PUSH
85325: EMPTY
85326: LIST
85327: LIST
85328: PUSH
85329: LD_VAR 0 7
85333: PPUSH
85334: LD_INT 2
85336: PPUSH
85337: LD_INT 4
85339: PPUSH
85340: CALL_OW 272
85344: PUSH
85345: LD_VAR 0 8
85349: PPUSH
85350: LD_INT 2
85352: PPUSH
85353: LD_INT 4
85355: PPUSH
85356: CALL_OW 273
85360: PUSH
85361: EMPTY
85362: LIST
85363: LIST
85364: PUSH
85365: LD_VAR 0 7
85369: PPUSH
85370: LD_INT 3
85372: PPUSH
85373: LD_INT 4
85375: PPUSH
85376: CALL_OW 272
85380: PUSH
85381: LD_VAR 0 8
85385: PPUSH
85386: LD_INT 3
85388: PPUSH
85389: LD_INT 4
85391: PPUSH
85392: CALL_OW 273
85396: PUSH
85397: EMPTY
85398: LIST
85399: LIST
85400: PUSH
85401: LD_VAR 0 7
85405: PPUSH
85406: LD_INT 4
85408: PPUSH
85409: LD_INT 4
85411: PPUSH
85412: CALL_OW 272
85416: PUSH
85417: LD_VAR 0 8
85421: PPUSH
85422: LD_INT 4
85424: PPUSH
85425: LD_INT 4
85427: PPUSH
85428: CALL_OW 273
85432: PUSH
85433: EMPTY
85434: LIST
85435: LIST
85436: PUSH
85437: LD_VAR 0 7
85441: PPUSH
85442: LD_INT 5
85444: PPUSH
85445: LD_INT 4
85447: PPUSH
85448: CALL_OW 272
85452: PUSH
85453: LD_VAR 0 8
85457: PPUSH
85458: LD_INT 5
85460: PPUSH
85461: LD_INT 4
85463: PPUSH
85464: CALL_OW 273
85468: PUSH
85469: EMPTY
85470: LIST
85471: LIST
85472: PUSH
85473: EMPTY
85474: LIST
85475: LIST
85476: LIST
85477: LIST
85478: LIST
85479: LIST
85480: ST_TO_ADDR
// for i = tmp downto 1 do
85481: LD_ADDR_VAR 0 4
85485: PUSH
85486: DOUBLE
85487: LD_VAR 0 6
85491: INC
85492: ST_TO_ADDR
85493: LD_INT 1
85495: PUSH
85496: FOR_DOWNTO
85497: IFFALSE 85598
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
85499: LD_VAR 0 6
85503: PUSH
85504: LD_VAR 0 4
85508: ARRAY
85509: PUSH
85510: LD_INT 1
85512: ARRAY
85513: PPUSH
85514: LD_VAR 0 6
85518: PUSH
85519: LD_VAR 0 4
85523: ARRAY
85524: PUSH
85525: LD_INT 2
85527: ARRAY
85528: PPUSH
85529: CALL_OW 488
85533: NOT
85534: PUSH
85535: LD_VAR 0 6
85539: PUSH
85540: LD_VAR 0 4
85544: ARRAY
85545: PUSH
85546: LD_INT 1
85548: ARRAY
85549: PPUSH
85550: LD_VAR 0 6
85554: PUSH
85555: LD_VAR 0 4
85559: ARRAY
85560: PUSH
85561: LD_INT 2
85563: ARRAY
85564: PPUSH
85565: CALL_OW 428
85569: PUSH
85570: LD_INT 0
85572: NONEQUAL
85573: OR
85574: IFFALSE 85596
// tmp := Delete ( tmp , i ) ;
85576: LD_ADDR_VAR 0 6
85580: PUSH
85581: LD_VAR 0 6
85585: PPUSH
85586: LD_VAR 0 4
85590: PPUSH
85591: CALL_OW 3
85595: ST_TO_ADDR
85596: GO 85496
85598: POP
85599: POP
// j := GetClosestHex ( unit , tmp ) ;
85600: LD_ADDR_VAR 0 5
85604: PUSH
85605: LD_VAR 0 1
85609: PPUSH
85610: LD_VAR 0 6
85614: PPUSH
85615: CALL 84891 0 2
85619: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
85620: LD_VAR 0 1
85624: PPUSH
85625: LD_VAR 0 5
85629: PUSH
85630: LD_INT 1
85632: ARRAY
85633: PPUSH
85634: LD_VAR 0 5
85638: PUSH
85639: LD_INT 2
85641: ARRAY
85642: PPUSH
85643: CALL_OW 111
// end ;
85647: LD_VAR 0 3
85651: RET
// export function PrepareApemanSoldier ( ) ; begin
85652: LD_INT 0
85654: PPUSH
// uc_nation := 0 ;
85655: LD_ADDR_OWVAR 21
85659: PUSH
85660: LD_INT 0
85662: ST_TO_ADDR
// hc_sex := sex_male ;
85663: LD_ADDR_OWVAR 27
85667: PUSH
85668: LD_INT 1
85670: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
85671: LD_ADDR_OWVAR 28
85675: PUSH
85676: LD_INT 15
85678: ST_TO_ADDR
// hc_gallery :=  ;
85679: LD_ADDR_OWVAR 33
85683: PUSH
85684: LD_STRING 
85686: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
85687: LD_ADDR_OWVAR 31
85691: PUSH
85692: LD_INT 0
85694: PPUSH
85695: LD_INT 3
85697: PPUSH
85698: CALL_OW 12
85702: PUSH
85703: LD_INT 0
85705: PPUSH
85706: LD_INT 3
85708: PPUSH
85709: CALL_OW 12
85713: PUSH
85714: LD_INT 0
85716: PUSH
85717: LD_INT 0
85719: PUSH
85720: EMPTY
85721: LIST
85722: LIST
85723: LIST
85724: LIST
85725: ST_TO_ADDR
// end ;
85726: LD_VAR 0 1
85730: RET
// export function PrepareApemanEngineer ( ) ; begin
85731: LD_INT 0
85733: PPUSH
// uc_nation := 0 ;
85734: LD_ADDR_OWVAR 21
85738: PUSH
85739: LD_INT 0
85741: ST_TO_ADDR
// hc_sex := sex_male ;
85742: LD_ADDR_OWVAR 27
85746: PUSH
85747: LD_INT 1
85749: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
85750: LD_ADDR_OWVAR 28
85754: PUSH
85755: LD_INT 16
85757: ST_TO_ADDR
// hc_gallery :=  ;
85758: LD_ADDR_OWVAR 33
85762: PUSH
85763: LD_STRING 
85765: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
85766: LD_ADDR_OWVAR 31
85770: PUSH
85771: LD_INT 0
85773: PPUSH
85774: LD_INT 3
85776: PPUSH
85777: CALL_OW 12
85781: PUSH
85782: LD_INT 0
85784: PPUSH
85785: LD_INT 3
85787: PPUSH
85788: CALL_OW 12
85792: PUSH
85793: LD_INT 0
85795: PUSH
85796: LD_INT 0
85798: PUSH
85799: EMPTY
85800: LIST
85801: LIST
85802: LIST
85803: LIST
85804: ST_TO_ADDR
// end ;
85805: LD_VAR 0 1
85809: RET
// export function PrepareApeman ( agressivity ) ; begin
85810: LD_INT 0
85812: PPUSH
// uc_side := 0 ;
85813: LD_ADDR_OWVAR 20
85817: PUSH
85818: LD_INT 0
85820: ST_TO_ADDR
// uc_nation := 0 ;
85821: LD_ADDR_OWVAR 21
85825: PUSH
85826: LD_INT 0
85828: ST_TO_ADDR
// hc_sex := sex_male ;
85829: LD_ADDR_OWVAR 27
85833: PUSH
85834: LD_INT 1
85836: ST_TO_ADDR
// hc_class := class_apeman ;
85837: LD_ADDR_OWVAR 28
85841: PUSH
85842: LD_INT 12
85844: ST_TO_ADDR
// hc_gallery :=  ;
85845: LD_ADDR_OWVAR 33
85849: PUSH
85850: LD_STRING 
85852: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
85853: LD_ADDR_OWVAR 35
85857: PUSH
85858: LD_VAR 0 1
85862: NEG
85863: PPUSH
85864: LD_VAR 0 1
85868: PPUSH
85869: CALL_OW 12
85873: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
85874: LD_ADDR_OWVAR 31
85878: PUSH
85879: LD_INT 0
85881: PPUSH
85882: LD_INT 3
85884: PPUSH
85885: CALL_OW 12
85889: PUSH
85890: LD_INT 0
85892: PPUSH
85893: LD_INT 3
85895: PPUSH
85896: CALL_OW 12
85900: PUSH
85901: LD_INT 0
85903: PUSH
85904: LD_INT 0
85906: PUSH
85907: EMPTY
85908: LIST
85909: LIST
85910: LIST
85911: LIST
85912: ST_TO_ADDR
// end ;
85913: LD_VAR 0 2
85917: RET
// export function PrepareTiger ( agressivity ) ; begin
85918: LD_INT 0
85920: PPUSH
// uc_side := 0 ;
85921: LD_ADDR_OWVAR 20
85925: PUSH
85926: LD_INT 0
85928: ST_TO_ADDR
// uc_nation := 0 ;
85929: LD_ADDR_OWVAR 21
85933: PUSH
85934: LD_INT 0
85936: ST_TO_ADDR
// hc_class := class_tiger ;
85937: LD_ADDR_OWVAR 28
85941: PUSH
85942: LD_INT 14
85944: ST_TO_ADDR
// hc_gallery :=  ;
85945: LD_ADDR_OWVAR 33
85949: PUSH
85950: LD_STRING 
85952: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
85953: LD_ADDR_OWVAR 35
85957: PUSH
85958: LD_VAR 0 1
85962: NEG
85963: PPUSH
85964: LD_VAR 0 1
85968: PPUSH
85969: CALL_OW 12
85973: ST_TO_ADDR
// end ;
85974: LD_VAR 0 2
85978: RET
// export function PrepareEnchidna ( ) ; begin
85979: LD_INT 0
85981: PPUSH
// uc_side := 0 ;
85982: LD_ADDR_OWVAR 20
85986: PUSH
85987: LD_INT 0
85989: ST_TO_ADDR
// uc_nation := 0 ;
85990: LD_ADDR_OWVAR 21
85994: PUSH
85995: LD_INT 0
85997: ST_TO_ADDR
// hc_class := class_baggie ;
85998: LD_ADDR_OWVAR 28
86002: PUSH
86003: LD_INT 13
86005: ST_TO_ADDR
// hc_gallery :=  ;
86006: LD_ADDR_OWVAR 33
86010: PUSH
86011: LD_STRING 
86013: ST_TO_ADDR
// end ;
86014: LD_VAR 0 1
86018: RET
// export function PrepareFrog ( ) ; begin
86019: LD_INT 0
86021: PPUSH
// uc_side := 0 ;
86022: LD_ADDR_OWVAR 20
86026: PUSH
86027: LD_INT 0
86029: ST_TO_ADDR
// uc_nation := 0 ;
86030: LD_ADDR_OWVAR 21
86034: PUSH
86035: LD_INT 0
86037: ST_TO_ADDR
// hc_class := class_frog ;
86038: LD_ADDR_OWVAR 28
86042: PUSH
86043: LD_INT 19
86045: ST_TO_ADDR
// hc_gallery :=  ;
86046: LD_ADDR_OWVAR 33
86050: PUSH
86051: LD_STRING 
86053: ST_TO_ADDR
// end ;
86054: LD_VAR 0 1
86058: RET
// export function PrepareFish ( ) ; begin
86059: LD_INT 0
86061: PPUSH
// uc_side := 0 ;
86062: LD_ADDR_OWVAR 20
86066: PUSH
86067: LD_INT 0
86069: ST_TO_ADDR
// uc_nation := 0 ;
86070: LD_ADDR_OWVAR 21
86074: PUSH
86075: LD_INT 0
86077: ST_TO_ADDR
// hc_class := class_fish ;
86078: LD_ADDR_OWVAR 28
86082: PUSH
86083: LD_INT 20
86085: ST_TO_ADDR
// hc_gallery :=  ;
86086: LD_ADDR_OWVAR 33
86090: PUSH
86091: LD_STRING 
86093: ST_TO_ADDR
// end ;
86094: LD_VAR 0 1
86098: RET
// export function PrepareBird ( ) ; begin
86099: LD_INT 0
86101: PPUSH
// uc_side := 0 ;
86102: LD_ADDR_OWVAR 20
86106: PUSH
86107: LD_INT 0
86109: ST_TO_ADDR
// uc_nation := 0 ;
86110: LD_ADDR_OWVAR 21
86114: PUSH
86115: LD_INT 0
86117: ST_TO_ADDR
// hc_class := class_phororhacos ;
86118: LD_ADDR_OWVAR 28
86122: PUSH
86123: LD_INT 18
86125: ST_TO_ADDR
// hc_gallery :=  ;
86126: LD_ADDR_OWVAR 33
86130: PUSH
86131: LD_STRING 
86133: ST_TO_ADDR
// end ;
86134: LD_VAR 0 1
86138: RET
// export function PrepareHorse ( ) ; begin
86139: LD_INT 0
86141: PPUSH
// uc_side := 0 ;
86142: LD_ADDR_OWVAR 20
86146: PUSH
86147: LD_INT 0
86149: ST_TO_ADDR
// uc_nation := 0 ;
86150: LD_ADDR_OWVAR 21
86154: PUSH
86155: LD_INT 0
86157: ST_TO_ADDR
// hc_class := class_horse ;
86158: LD_ADDR_OWVAR 28
86162: PUSH
86163: LD_INT 21
86165: ST_TO_ADDR
// hc_gallery :=  ;
86166: LD_ADDR_OWVAR 33
86170: PUSH
86171: LD_STRING 
86173: ST_TO_ADDR
// end ;
86174: LD_VAR 0 1
86178: RET
// export function PrepareMastodont ( ) ; begin
86179: LD_INT 0
86181: PPUSH
// uc_side := 0 ;
86182: LD_ADDR_OWVAR 20
86186: PUSH
86187: LD_INT 0
86189: ST_TO_ADDR
// uc_nation := 0 ;
86190: LD_ADDR_OWVAR 21
86194: PUSH
86195: LD_INT 0
86197: ST_TO_ADDR
// vc_chassis := class_mastodont ;
86198: LD_ADDR_OWVAR 37
86202: PUSH
86203: LD_INT 31
86205: ST_TO_ADDR
// vc_control := control_rider ;
86206: LD_ADDR_OWVAR 38
86210: PUSH
86211: LD_INT 4
86213: ST_TO_ADDR
// end ;
86214: LD_VAR 0 1
86218: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
86219: LD_INT 0
86221: PPUSH
86222: PPUSH
86223: PPUSH
// uc_side = 0 ;
86224: LD_ADDR_OWVAR 20
86228: PUSH
86229: LD_INT 0
86231: ST_TO_ADDR
// uc_nation = 0 ;
86232: LD_ADDR_OWVAR 21
86236: PUSH
86237: LD_INT 0
86239: ST_TO_ADDR
// InitHc_All ( ) ;
86240: CALL_OW 584
// InitVc ;
86244: CALL_OW 20
// if mastodonts then
86248: LD_VAR 0 6
86252: IFFALSE 86319
// for i = 1 to mastodonts do
86254: LD_ADDR_VAR 0 11
86258: PUSH
86259: DOUBLE
86260: LD_INT 1
86262: DEC
86263: ST_TO_ADDR
86264: LD_VAR 0 6
86268: PUSH
86269: FOR_TO
86270: IFFALSE 86317
// begin vc_chassis := 31 ;
86272: LD_ADDR_OWVAR 37
86276: PUSH
86277: LD_INT 31
86279: ST_TO_ADDR
// vc_control := control_rider ;
86280: LD_ADDR_OWVAR 38
86284: PUSH
86285: LD_INT 4
86287: ST_TO_ADDR
// animal := CreateVehicle ;
86288: LD_ADDR_VAR 0 12
86292: PUSH
86293: CALL_OW 45
86297: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86298: LD_VAR 0 12
86302: PPUSH
86303: LD_VAR 0 8
86307: PPUSH
86308: LD_INT 0
86310: PPUSH
86311: CALL 88447 0 3
// end ;
86315: GO 86269
86317: POP
86318: POP
// if horses then
86319: LD_VAR 0 5
86323: IFFALSE 86390
// for i = 1 to horses do
86325: LD_ADDR_VAR 0 11
86329: PUSH
86330: DOUBLE
86331: LD_INT 1
86333: DEC
86334: ST_TO_ADDR
86335: LD_VAR 0 5
86339: PUSH
86340: FOR_TO
86341: IFFALSE 86388
// begin hc_class := 21 ;
86343: LD_ADDR_OWVAR 28
86347: PUSH
86348: LD_INT 21
86350: ST_TO_ADDR
// hc_gallery :=  ;
86351: LD_ADDR_OWVAR 33
86355: PUSH
86356: LD_STRING 
86358: ST_TO_ADDR
// animal := CreateHuman ;
86359: LD_ADDR_VAR 0 12
86363: PUSH
86364: CALL_OW 44
86368: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86369: LD_VAR 0 12
86373: PPUSH
86374: LD_VAR 0 8
86378: PPUSH
86379: LD_INT 0
86381: PPUSH
86382: CALL 88447 0 3
// end ;
86386: GO 86340
86388: POP
86389: POP
// if birds then
86390: LD_VAR 0 1
86394: IFFALSE 86461
// for i = 1 to birds do
86396: LD_ADDR_VAR 0 11
86400: PUSH
86401: DOUBLE
86402: LD_INT 1
86404: DEC
86405: ST_TO_ADDR
86406: LD_VAR 0 1
86410: PUSH
86411: FOR_TO
86412: IFFALSE 86459
// begin hc_class = 18 ;
86414: LD_ADDR_OWVAR 28
86418: PUSH
86419: LD_INT 18
86421: ST_TO_ADDR
// hc_gallery =  ;
86422: LD_ADDR_OWVAR 33
86426: PUSH
86427: LD_STRING 
86429: ST_TO_ADDR
// animal := CreateHuman ;
86430: LD_ADDR_VAR 0 12
86434: PUSH
86435: CALL_OW 44
86439: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86440: LD_VAR 0 12
86444: PPUSH
86445: LD_VAR 0 8
86449: PPUSH
86450: LD_INT 0
86452: PPUSH
86453: CALL 88447 0 3
// end ;
86457: GO 86411
86459: POP
86460: POP
// if tigers then
86461: LD_VAR 0 2
86465: IFFALSE 86549
// for i = 1 to tigers do
86467: LD_ADDR_VAR 0 11
86471: PUSH
86472: DOUBLE
86473: LD_INT 1
86475: DEC
86476: ST_TO_ADDR
86477: LD_VAR 0 2
86481: PUSH
86482: FOR_TO
86483: IFFALSE 86547
// begin hc_class = class_tiger ;
86485: LD_ADDR_OWVAR 28
86489: PUSH
86490: LD_INT 14
86492: ST_TO_ADDR
// hc_gallery =  ;
86493: LD_ADDR_OWVAR 33
86497: PUSH
86498: LD_STRING 
86500: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
86501: LD_ADDR_OWVAR 35
86505: PUSH
86506: LD_INT 7
86508: NEG
86509: PPUSH
86510: LD_INT 7
86512: PPUSH
86513: CALL_OW 12
86517: ST_TO_ADDR
// animal := CreateHuman ;
86518: LD_ADDR_VAR 0 12
86522: PUSH
86523: CALL_OW 44
86527: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86528: LD_VAR 0 12
86532: PPUSH
86533: LD_VAR 0 8
86537: PPUSH
86538: LD_INT 0
86540: PPUSH
86541: CALL 88447 0 3
// end ;
86545: GO 86482
86547: POP
86548: POP
// if apemans then
86549: LD_VAR 0 3
86553: IFFALSE 86676
// for i = 1 to apemans do
86555: LD_ADDR_VAR 0 11
86559: PUSH
86560: DOUBLE
86561: LD_INT 1
86563: DEC
86564: ST_TO_ADDR
86565: LD_VAR 0 3
86569: PUSH
86570: FOR_TO
86571: IFFALSE 86674
// begin hc_class = class_apeman ;
86573: LD_ADDR_OWVAR 28
86577: PUSH
86578: LD_INT 12
86580: ST_TO_ADDR
// hc_gallery =  ;
86581: LD_ADDR_OWVAR 33
86585: PUSH
86586: LD_STRING 
86588: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
86589: LD_ADDR_OWVAR 35
86593: PUSH
86594: LD_INT 2
86596: NEG
86597: PPUSH
86598: LD_INT 2
86600: PPUSH
86601: CALL_OW 12
86605: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
86606: LD_ADDR_OWVAR 31
86610: PUSH
86611: LD_INT 1
86613: PPUSH
86614: LD_INT 3
86616: PPUSH
86617: CALL_OW 12
86621: PUSH
86622: LD_INT 1
86624: PPUSH
86625: LD_INT 3
86627: PPUSH
86628: CALL_OW 12
86632: PUSH
86633: LD_INT 0
86635: PUSH
86636: LD_INT 0
86638: PUSH
86639: EMPTY
86640: LIST
86641: LIST
86642: LIST
86643: LIST
86644: ST_TO_ADDR
// animal := CreateHuman ;
86645: LD_ADDR_VAR 0 12
86649: PUSH
86650: CALL_OW 44
86654: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86655: LD_VAR 0 12
86659: PPUSH
86660: LD_VAR 0 8
86664: PPUSH
86665: LD_INT 0
86667: PPUSH
86668: CALL 88447 0 3
// end ;
86672: GO 86570
86674: POP
86675: POP
// if enchidnas then
86676: LD_VAR 0 4
86680: IFFALSE 86747
// for i = 1 to enchidnas do
86682: LD_ADDR_VAR 0 11
86686: PUSH
86687: DOUBLE
86688: LD_INT 1
86690: DEC
86691: ST_TO_ADDR
86692: LD_VAR 0 4
86696: PUSH
86697: FOR_TO
86698: IFFALSE 86745
// begin hc_class = 13 ;
86700: LD_ADDR_OWVAR 28
86704: PUSH
86705: LD_INT 13
86707: ST_TO_ADDR
// hc_gallery =  ;
86708: LD_ADDR_OWVAR 33
86712: PUSH
86713: LD_STRING 
86715: ST_TO_ADDR
// animal := CreateHuman ;
86716: LD_ADDR_VAR 0 12
86720: PUSH
86721: CALL_OW 44
86725: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86726: LD_VAR 0 12
86730: PPUSH
86731: LD_VAR 0 8
86735: PPUSH
86736: LD_INT 0
86738: PPUSH
86739: CALL 88447 0 3
// end ;
86743: GO 86697
86745: POP
86746: POP
// if fishes then
86747: LD_VAR 0 7
86751: IFFALSE 86818
// for i = 1 to fishes do
86753: LD_ADDR_VAR 0 11
86757: PUSH
86758: DOUBLE
86759: LD_INT 1
86761: DEC
86762: ST_TO_ADDR
86763: LD_VAR 0 7
86767: PUSH
86768: FOR_TO
86769: IFFALSE 86816
// begin hc_class = 20 ;
86771: LD_ADDR_OWVAR 28
86775: PUSH
86776: LD_INT 20
86778: ST_TO_ADDR
// hc_gallery =  ;
86779: LD_ADDR_OWVAR 33
86783: PUSH
86784: LD_STRING 
86786: ST_TO_ADDR
// animal := CreateHuman ;
86787: LD_ADDR_VAR 0 12
86791: PUSH
86792: CALL_OW 44
86796: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
86797: LD_VAR 0 12
86801: PPUSH
86802: LD_VAR 0 9
86806: PPUSH
86807: LD_INT 0
86809: PPUSH
86810: CALL 88447 0 3
// end ;
86814: GO 86768
86816: POP
86817: POP
// end ;
86818: LD_VAR 0 10
86822: RET
// export function WantHeal ( sci , unit ) ; begin
86823: LD_INT 0
86825: PPUSH
// if GetTaskList ( sci ) > 0 then
86826: LD_VAR 0 1
86830: PPUSH
86831: CALL_OW 437
86835: PUSH
86836: LD_INT 0
86838: GREATER
86839: IFFALSE 86909
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
86841: LD_VAR 0 1
86845: PPUSH
86846: CALL_OW 437
86850: PUSH
86851: LD_INT 1
86853: ARRAY
86854: PUSH
86855: LD_INT 1
86857: ARRAY
86858: PUSH
86859: LD_STRING l
86861: EQUAL
86862: PUSH
86863: LD_VAR 0 1
86867: PPUSH
86868: CALL_OW 437
86872: PUSH
86873: LD_INT 1
86875: ARRAY
86876: PUSH
86877: LD_INT 4
86879: ARRAY
86880: PUSH
86881: LD_VAR 0 2
86885: EQUAL
86886: AND
86887: IFFALSE 86899
// result := true else
86889: LD_ADDR_VAR 0 3
86893: PUSH
86894: LD_INT 1
86896: ST_TO_ADDR
86897: GO 86907
// result := false ;
86899: LD_ADDR_VAR 0 3
86903: PUSH
86904: LD_INT 0
86906: ST_TO_ADDR
// end else
86907: GO 86917
// result := false ;
86909: LD_ADDR_VAR 0 3
86913: PUSH
86914: LD_INT 0
86916: ST_TO_ADDR
// end ;
86917: LD_VAR 0 3
86921: RET
// export function HealTarget ( sci ) ; begin
86922: LD_INT 0
86924: PPUSH
// if not sci then
86925: LD_VAR 0 1
86929: NOT
86930: IFFALSE 86934
// exit ;
86932: GO 86999
// result := 0 ;
86934: LD_ADDR_VAR 0 2
86938: PUSH
86939: LD_INT 0
86941: ST_TO_ADDR
// if GetTaskList ( sci ) then
86942: LD_VAR 0 1
86946: PPUSH
86947: CALL_OW 437
86951: IFFALSE 86999
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
86953: LD_VAR 0 1
86957: PPUSH
86958: CALL_OW 437
86962: PUSH
86963: LD_INT 1
86965: ARRAY
86966: PUSH
86967: LD_INT 1
86969: ARRAY
86970: PUSH
86971: LD_STRING l
86973: EQUAL
86974: IFFALSE 86999
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
86976: LD_ADDR_VAR 0 2
86980: PUSH
86981: LD_VAR 0 1
86985: PPUSH
86986: CALL_OW 437
86990: PUSH
86991: LD_INT 1
86993: ARRAY
86994: PUSH
86995: LD_INT 4
86997: ARRAY
86998: ST_TO_ADDR
// end ;
86999: LD_VAR 0 2
87003: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
87004: LD_INT 0
87006: PPUSH
87007: PPUSH
87008: PPUSH
87009: PPUSH
// if not base_units then
87010: LD_VAR 0 1
87014: NOT
87015: IFFALSE 87019
// exit ;
87017: GO 87106
// result := false ;
87019: LD_ADDR_VAR 0 2
87023: PUSH
87024: LD_INT 0
87026: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
87027: LD_ADDR_VAR 0 5
87031: PUSH
87032: LD_VAR 0 1
87036: PPUSH
87037: LD_INT 21
87039: PUSH
87040: LD_INT 3
87042: PUSH
87043: EMPTY
87044: LIST
87045: LIST
87046: PPUSH
87047: CALL_OW 72
87051: ST_TO_ADDR
// if not tmp then
87052: LD_VAR 0 5
87056: NOT
87057: IFFALSE 87061
// exit ;
87059: GO 87106
// for i in tmp do
87061: LD_ADDR_VAR 0 3
87065: PUSH
87066: LD_VAR 0 5
87070: PUSH
87071: FOR_IN
87072: IFFALSE 87104
// begin result := EnemyInRange ( i , 22 ) ;
87074: LD_ADDR_VAR 0 2
87078: PUSH
87079: LD_VAR 0 3
87083: PPUSH
87084: LD_INT 22
87086: PPUSH
87087: CALL 84693 0 2
87091: ST_TO_ADDR
// if result then
87092: LD_VAR 0 2
87096: IFFALSE 87102
// exit ;
87098: POP
87099: POP
87100: GO 87106
// end ;
87102: GO 87071
87104: POP
87105: POP
// end ;
87106: LD_VAR 0 2
87110: RET
// export function FilterByTag ( units , tag ) ; begin
87111: LD_INT 0
87113: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
87114: LD_ADDR_VAR 0 3
87118: PUSH
87119: LD_VAR 0 1
87123: PPUSH
87124: LD_INT 120
87126: PUSH
87127: LD_VAR 0 2
87131: PUSH
87132: EMPTY
87133: LIST
87134: LIST
87135: PPUSH
87136: CALL_OW 72
87140: ST_TO_ADDR
// end ;
87141: LD_VAR 0 3
87145: RET
// export function IsDriver ( un ) ; begin
87146: LD_INT 0
87148: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
87149: LD_ADDR_VAR 0 2
87153: PUSH
87154: LD_VAR 0 1
87158: PUSH
87159: LD_INT 55
87161: PUSH
87162: EMPTY
87163: LIST
87164: PPUSH
87165: CALL_OW 69
87169: IN
87170: ST_TO_ADDR
// end ;
87171: LD_VAR 0 2
87175: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
87176: LD_INT 0
87178: PPUSH
87179: PPUSH
// list := [ ] ;
87180: LD_ADDR_VAR 0 5
87184: PUSH
87185: EMPTY
87186: ST_TO_ADDR
// case d of 0 :
87187: LD_VAR 0 3
87191: PUSH
87192: LD_INT 0
87194: DOUBLE
87195: EQUAL
87196: IFTRUE 87200
87198: GO 87333
87200: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
87201: LD_ADDR_VAR 0 5
87205: PUSH
87206: LD_VAR 0 1
87210: PUSH
87211: LD_INT 4
87213: MINUS
87214: PUSH
87215: LD_VAR 0 2
87219: PUSH
87220: LD_INT 4
87222: MINUS
87223: PUSH
87224: LD_INT 2
87226: PUSH
87227: EMPTY
87228: LIST
87229: LIST
87230: LIST
87231: PUSH
87232: LD_VAR 0 1
87236: PUSH
87237: LD_INT 3
87239: MINUS
87240: PUSH
87241: LD_VAR 0 2
87245: PUSH
87246: LD_INT 1
87248: PUSH
87249: EMPTY
87250: LIST
87251: LIST
87252: LIST
87253: PUSH
87254: LD_VAR 0 1
87258: PUSH
87259: LD_INT 4
87261: PLUS
87262: PUSH
87263: LD_VAR 0 2
87267: PUSH
87268: LD_INT 4
87270: PUSH
87271: EMPTY
87272: LIST
87273: LIST
87274: LIST
87275: PUSH
87276: LD_VAR 0 1
87280: PUSH
87281: LD_INT 3
87283: PLUS
87284: PUSH
87285: LD_VAR 0 2
87289: PUSH
87290: LD_INT 3
87292: PLUS
87293: PUSH
87294: LD_INT 5
87296: PUSH
87297: EMPTY
87298: LIST
87299: LIST
87300: LIST
87301: PUSH
87302: LD_VAR 0 1
87306: PUSH
87307: LD_VAR 0 2
87311: PUSH
87312: LD_INT 4
87314: PLUS
87315: PUSH
87316: LD_INT 0
87318: PUSH
87319: EMPTY
87320: LIST
87321: LIST
87322: LIST
87323: PUSH
87324: EMPTY
87325: LIST
87326: LIST
87327: LIST
87328: LIST
87329: LIST
87330: ST_TO_ADDR
// end ; 1 :
87331: GO 88031
87333: LD_INT 1
87335: DOUBLE
87336: EQUAL
87337: IFTRUE 87341
87339: GO 87474
87341: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
87342: LD_ADDR_VAR 0 5
87346: PUSH
87347: LD_VAR 0 1
87351: PUSH
87352: LD_VAR 0 2
87356: PUSH
87357: LD_INT 4
87359: MINUS
87360: PUSH
87361: LD_INT 3
87363: PUSH
87364: EMPTY
87365: LIST
87366: LIST
87367: LIST
87368: PUSH
87369: LD_VAR 0 1
87373: PUSH
87374: LD_INT 3
87376: MINUS
87377: PUSH
87378: LD_VAR 0 2
87382: PUSH
87383: LD_INT 3
87385: MINUS
87386: PUSH
87387: LD_INT 2
87389: PUSH
87390: EMPTY
87391: LIST
87392: LIST
87393: LIST
87394: PUSH
87395: LD_VAR 0 1
87399: PUSH
87400: LD_INT 4
87402: MINUS
87403: PUSH
87404: LD_VAR 0 2
87408: PUSH
87409: LD_INT 1
87411: PUSH
87412: EMPTY
87413: LIST
87414: LIST
87415: LIST
87416: PUSH
87417: LD_VAR 0 1
87421: PUSH
87422: LD_VAR 0 2
87426: PUSH
87427: LD_INT 3
87429: PLUS
87430: PUSH
87431: LD_INT 0
87433: PUSH
87434: EMPTY
87435: LIST
87436: LIST
87437: LIST
87438: PUSH
87439: LD_VAR 0 1
87443: PUSH
87444: LD_INT 4
87446: PLUS
87447: PUSH
87448: LD_VAR 0 2
87452: PUSH
87453: LD_INT 4
87455: PLUS
87456: PUSH
87457: LD_INT 5
87459: PUSH
87460: EMPTY
87461: LIST
87462: LIST
87463: LIST
87464: PUSH
87465: EMPTY
87466: LIST
87467: LIST
87468: LIST
87469: LIST
87470: LIST
87471: ST_TO_ADDR
// end ; 2 :
87472: GO 88031
87474: LD_INT 2
87476: DOUBLE
87477: EQUAL
87478: IFTRUE 87482
87480: GO 87611
87482: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
87483: LD_ADDR_VAR 0 5
87487: PUSH
87488: LD_VAR 0 1
87492: PUSH
87493: LD_VAR 0 2
87497: PUSH
87498: LD_INT 3
87500: MINUS
87501: PUSH
87502: LD_INT 3
87504: PUSH
87505: EMPTY
87506: LIST
87507: LIST
87508: LIST
87509: PUSH
87510: LD_VAR 0 1
87514: PUSH
87515: LD_INT 4
87517: PLUS
87518: PUSH
87519: LD_VAR 0 2
87523: PUSH
87524: LD_INT 4
87526: PUSH
87527: EMPTY
87528: LIST
87529: LIST
87530: LIST
87531: PUSH
87532: LD_VAR 0 1
87536: PUSH
87537: LD_VAR 0 2
87541: PUSH
87542: LD_INT 4
87544: PLUS
87545: PUSH
87546: LD_INT 0
87548: PUSH
87549: EMPTY
87550: LIST
87551: LIST
87552: LIST
87553: PUSH
87554: LD_VAR 0 1
87558: PUSH
87559: LD_INT 3
87561: MINUS
87562: PUSH
87563: LD_VAR 0 2
87567: PUSH
87568: LD_INT 1
87570: PUSH
87571: EMPTY
87572: LIST
87573: LIST
87574: LIST
87575: PUSH
87576: LD_VAR 0 1
87580: PUSH
87581: LD_INT 4
87583: MINUS
87584: PUSH
87585: LD_VAR 0 2
87589: PUSH
87590: LD_INT 4
87592: MINUS
87593: PUSH
87594: LD_INT 2
87596: PUSH
87597: EMPTY
87598: LIST
87599: LIST
87600: LIST
87601: PUSH
87602: EMPTY
87603: LIST
87604: LIST
87605: LIST
87606: LIST
87607: LIST
87608: ST_TO_ADDR
// end ; 3 :
87609: GO 88031
87611: LD_INT 3
87613: DOUBLE
87614: EQUAL
87615: IFTRUE 87619
87617: GO 87752
87619: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
87620: LD_ADDR_VAR 0 5
87624: PUSH
87625: LD_VAR 0 1
87629: PUSH
87630: LD_INT 3
87632: PLUS
87633: PUSH
87634: LD_VAR 0 2
87638: PUSH
87639: LD_INT 4
87641: PUSH
87642: EMPTY
87643: LIST
87644: LIST
87645: LIST
87646: PUSH
87647: LD_VAR 0 1
87651: PUSH
87652: LD_INT 4
87654: PLUS
87655: PUSH
87656: LD_VAR 0 2
87660: PUSH
87661: LD_INT 4
87663: PLUS
87664: PUSH
87665: LD_INT 5
87667: PUSH
87668: EMPTY
87669: LIST
87670: LIST
87671: LIST
87672: PUSH
87673: LD_VAR 0 1
87677: PUSH
87678: LD_INT 4
87680: MINUS
87681: PUSH
87682: LD_VAR 0 2
87686: PUSH
87687: LD_INT 1
87689: PUSH
87690: EMPTY
87691: LIST
87692: LIST
87693: LIST
87694: PUSH
87695: LD_VAR 0 1
87699: PUSH
87700: LD_VAR 0 2
87704: PUSH
87705: LD_INT 4
87707: MINUS
87708: PUSH
87709: LD_INT 3
87711: PUSH
87712: EMPTY
87713: LIST
87714: LIST
87715: LIST
87716: PUSH
87717: LD_VAR 0 1
87721: PUSH
87722: LD_INT 3
87724: MINUS
87725: PUSH
87726: LD_VAR 0 2
87730: PUSH
87731: LD_INT 3
87733: MINUS
87734: PUSH
87735: LD_INT 2
87737: PUSH
87738: EMPTY
87739: LIST
87740: LIST
87741: LIST
87742: PUSH
87743: EMPTY
87744: LIST
87745: LIST
87746: LIST
87747: LIST
87748: LIST
87749: ST_TO_ADDR
// end ; 4 :
87750: GO 88031
87752: LD_INT 4
87754: DOUBLE
87755: EQUAL
87756: IFTRUE 87760
87758: GO 87893
87760: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
87761: LD_ADDR_VAR 0 5
87765: PUSH
87766: LD_VAR 0 1
87770: PUSH
87771: LD_VAR 0 2
87775: PUSH
87776: LD_INT 4
87778: PLUS
87779: PUSH
87780: LD_INT 0
87782: PUSH
87783: EMPTY
87784: LIST
87785: LIST
87786: LIST
87787: PUSH
87788: LD_VAR 0 1
87792: PUSH
87793: LD_INT 3
87795: PLUS
87796: PUSH
87797: LD_VAR 0 2
87801: PUSH
87802: LD_INT 3
87804: PLUS
87805: PUSH
87806: LD_INT 5
87808: PUSH
87809: EMPTY
87810: LIST
87811: LIST
87812: LIST
87813: PUSH
87814: LD_VAR 0 1
87818: PUSH
87819: LD_INT 4
87821: PLUS
87822: PUSH
87823: LD_VAR 0 2
87827: PUSH
87828: LD_INT 4
87830: PUSH
87831: EMPTY
87832: LIST
87833: LIST
87834: LIST
87835: PUSH
87836: LD_VAR 0 1
87840: PUSH
87841: LD_VAR 0 2
87845: PUSH
87846: LD_INT 3
87848: MINUS
87849: PUSH
87850: LD_INT 3
87852: PUSH
87853: EMPTY
87854: LIST
87855: LIST
87856: LIST
87857: PUSH
87858: LD_VAR 0 1
87862: PUSH
87863: LD_INT 4
87865: MINUS
87866: PUSH
87867: LD_VAR 0 2
87871: PUSH
87872: LD_INT 4
87874: MINUS
87875: PUSH
87876: LD_INT 2
87878: PUSH
87879: EMPTY
87880: LIST
87881: LIST
87882: LIST
87883: PUSH
87884: EMPTY
87885: LIST
87886: LIST
87887: LIST
87888: LIST
87889: LIST
87890: ST_TO_ADDR
// end ; 5 :
87891: GO 88031
87893: LD_INT 5
87895: DOUBLE
87896: EQUAL
87897: IFTRUE 87901
87899: GO 88030
87901: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
87902: LD_ADDR_VAR 0 5
87906: PUSH
87907: LD_VAR 0 1
87911: PUSH
87912: LD_INT 4
87914: MINUS
87915: PUSH
87916: LD_VAR 0 2
87920: PUSH
87921: LD_INT 1
87923: PUSH
87924: EMPTY
87925: LIST
87926: LIST
87927: LIST
87928: PUSH
87929: LD_VAR 0 1
87933: PUSH
87934: LD_VAR 0 2
87938: PUSH
87939: LD_INT 4
87941: MINUS
87942: PUSH
87943: LD_INT 3
87945: PUSH
87946: EMPTY
87947: LIST
87948: LIST
87949: LIST
87950: PUSH
87951: LD_VAR 0 1
87955: PUSH
87956: LD_INT 4
87958: PLUS
87959: PUSH
87960: LD_VAR 0 2
87964: PUSH
87965: LD_INT 4
87967: PLUS
87968: PUSH
87969: LD_INT 5
87971: PUSH
87972: EMPTY
87973: LIST
87974: LIST
87975: LIST
87976: PUSH
87977: LD_VAR 0 1
87981: PUSH
87982: LD_INT 3
87984: PLUS
87985: PUSH
87986: LD_VAR 0 2
87990: PUSH
87991: LD_INT 4
87993: PUSH
87994: EMPTY
87995: LIST
87996: LIST
87997: LIST
87998: PUSH
87999: LD_VAR 0 1
88003: PUSH
88004: LD_VAR 0 2
88008: PUSH
88009: LD_INT 3
88011: PLUS
88012: PUSH
88013: LD_INT 0
88015: PUSH
88016: EMPTY
88017: LIST
88018: LIST
88019: LIST
88020: PUSH
88021: EMPTY
88022: LIST
88023: LIST
88024: LIST
88025: LIST
88026: LIST
88027: ST_TO_ADDR
// end ; end ;
88028: GO 88031
88030: POP
// result := list ;
88031: LD_ADDR_VAR 0 4
88035: PUSH
88036: LD_VAR 0 5
88040: ST_TO_ADDR
// end ;
88041: LD_VAR 0 4
88045: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
88046: LD_INT 0
88048: PPUSH
88049: PPUSH
88050: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
88051: LD_VAR 0 1
88055: NOT
88056: PUSH
88057: LD_VAR 0 2
88061: PUSH
88062: LD_INT 1
88064: PUSH
88065: LD_INT 2
88067: PUSH
88068: LD_INT 3
88070: PUSH
88071: LD_INT 4
88073: PUSH
88074: EMPTY
88075: LIST
88076: LIST
88077: LIST
88078: LIST
88079: IN
88080: NOT
88081: OR
88082: IFFALSE 88086
// exit ;
88084: GO 88169
// tmp := [ ] ;
88086: LD_ADDR_VAR 0 5
88090: PUSH
88091: EMPTY
88092: ST_TO_ADDR
// for i in units do
88093: LD_ADDR_VAR 0 4
88097: PUSH
88098: LD_VAR 0 1
88102: PUSH
88103: FOR_IN
88104: IFFALSE 88138
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
88106: LD_ADDR_VAR 0 5
88110: PUSH
88111: LD_VAR 0 5
88115: PPUSH
88116: LD_VAR 0 4
88120: PPUSH
88121: LD_VAR 0 2
88125: PPUSH
88126: CALL_OW 259
88130: PPUSH
88131: CALL 89530 0 2
88135: ST_TO_ADDR
88136: GO 88103
88138: POP
88139: POP
// if not tmp then
88140: LD_VAR 0 5
88144: NOT
88145: IFFALSE 88149
// exit ;
88147: GO 88169
// result := SortListByListDesc ( units , tmp ) ;
88149: LD_ADDR_VAR 0 3
88153: PUSH
88154: LD_VAR 0 1
88158: PPUSH
88159: LD_VAR 0 5
88163: PPUSH
88164: CALL_OW 77
88168: ST_TO_ADDR
// end ;
88169: LD_VAR 0 3
88173: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
88174: LD_INT 0
88176: PPUSH
88177: PPUSH
88178: PPUSH
// result := false ;
88179: LD_ADDR_VAR 0 3
88183: PUSH
88184: LD_INT 0
88186: ST_TO_ADDR
// if not building then
88187: LD_VAR 0 2
88191: NOT
88192: IFFALSE 88196
// exit ;
88194: GO 88334
// x := GetX ( building ) ;
88196: LD_ADDR_VAR 0 4
88200: PUSH
88201: LD_VAR 0 2
88205: PPUSH
88206: CALL_OW 250
88210: ST_TO_ADDR
// y := GetY ( building ) ;
88211: LD_ADDR_VAR 0 5
88215: PUSH
88216: LD_VAR 0 2
88220: PPUSH
88221: CALL_OW 251
88225: ST_TO_ADDR
// if not x or not y then
88226: LD_VAR 0 4
88230: NOT
88231: PUSH
88232: LD_VAR 0 5
88236: NOT
88237: OR
88238: IFFALSE 88242
// exit ;
88240: GO 88334
// if GetTaskList ( unit ) then
88242: LD_VAR 0 1
88246: PPUSH
88247: CALL_OW 437
88251: IFFALSE 88334
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
88253: LD_STRING e
88255: PUSH
88256: LD_VAR 0 1
88260: PPUSH
88261: CALL_OW 437
88265: PUSH
88266: LD_INT 1
88268: ARRAY
88269: PUSH
88270: LD_INT 1
88272: ARRAY
88273: EQUAL
88274: PUSH
88275: LD_VAR 0 4
88279: PUSH
88280: LD_VAR 0 1
88284: PPUSH
88285: CALL_OW 437
88289: PUSH
88290: LD_INT 1
88292: ARRAY
88293: PUSH
88294: LD_INT 2
88296: ARRAY
88297: EQUAL
88298: AND
88299: PUSH
88300: LD_VAR 0 5
88304: PUSH
88305: LD_VAR 0 1
88309: PPUSH
88310: CALL_OW 437
88314: PUSH
88315: LD_INT 1
88317: ARRAY
88318: PUSH
88319: LD_INT 3
88321: ARRAY
88322: EQUAL
88323: AND
88324: IFFALSE 88334
// result := true end ;
88326: LD_ADDR_VAR 0 3
88330: PUSH
88331: LD_INT 1
88333: ST_TO_ADDR
// end ;
88334: LD_VAR 0 3
88338: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
88339: LD_INT 0
88341: PPUSH
// result := false ;
88342: LD_ADDR_VAR 0 4
88346: PUSH
88347: LD_INT 0
88349: ST_TO_ADDR
// if GetTaskList ( unit ) then
88350: LD_VAR 0 1
88354: PPUSH
88355: CALL_OW 437
88359: IFFALSE 88442
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
88361: LD_STRING M
88363: PUSH
88364: LD_VAR 0 1
88368: PPUSH
88369: CALL_OW 437
88373: PUSH
88374: LD_INT 1
88376: ARRAY
88377: PUSH
88378: LD_INT 1
88380: ARRAY
88381: EQUAL
88382: PUSH
88383: LD_VAR 0 2
88387: PUSH
88388: LD_VAR 0 1
88392: PPUSH
88393: CALL_OW 437
88397: PUSH
88398: LD_INT 1
88400: ARRAY
88401: PUSH
88402: LD_INT 2
88404: ARRAY
88405: EQUAL
88406: AND
88407: PUSH
88408: LD_VAR 0 3
88412: PUSH
88413: LD_VAR 0 1
88417: PPUSH
88418: CALL_OW 437
88422: PUSH
88423: LD_INT 1
88425: ARRAY
88426: PUSH
88427: LD_INT 3
88429: ARRAY
88430: EQUAL
88431: AND
88432: IFFALSE 88442
// result := true ;
88434: LD_ADDR_VAR 0 4
88438: PUSH
88439: LD_INT 1
88441: ST_TO_ADDR
// end ; end ;
88442: LD_VAR 0 4
88446: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
88447: LD_INT 0
88449: PPUSH
88450: PPUSH
88451: PPUSH
88452: PPUSH
// if not unit or not area then
88453: LD_VAR 0 1
88457: NOT
88458: PUSH
88459: LD_VAR 0 2
88463: NOT
88464: OR
88465: IFFALSE 88469
// exit ;
88467: GO 88633
// tmp := AreaToList ( area , i ) ;
88469: LD_ADDR_VAR 0 6
88473: PUSH
88474: LD_VAR 0 2
88478: PPUSH
88479: LD_VAR 0 5
88483: PPUSH
88484: CALL_OW 517
88488: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
88489: LD_ADDR_VAR 0 5
88493: PUSH
88494: DOUBLE
88495: LD_INT 1
88497: DEC
88498: ST_TO_ADDR
88499: LD_VAR 0 6
88503: PUSH
88504: LD_INT 1
88506: ARRAY
88507: PUSH
88508: FOR_TO
88509: IFFALSE 88631
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
88511: LD_ADDR_VAR 0 7
88515: PUSH
88516: LD_VAR 0 6
88520: PUSH
88521: LD_INT 1
88523: ARRAY
88524: PUSH
88525: LD_VAR 0 5
88529: ARRAY
88530: PUSH
88531: LD_VAR 0 6
88535: PUSH
88536: LD_INT 2
88538: ARRAY
88539: PUSH
88540: LD_VAR 0 5
88544: ARRAY
88545: PUSH
88546: EMPTY
88547: LIST
88548: LIST
88549: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
88550: LD_VAR 0 7
88554: PUSH
88555: LD_INT 1
88557: ARRAY
88558: PPUSH
88559: LD_VAR 0 7
88563: PUSH
88564: LD_INT 2
88566: ARRAY
88567: PPUSH
88568: CALL_OW 428
88572: PUSH
88573: LD_INT 0
88575: EQUAL
88576: IFFALSE 88629
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
88578: LD_VAR 0 1
88582: PPUSH
88583: LD_VAR 0 7
88587: PUSH
88588: LD_INT 1
88590: ARRAY
88591: PPUSH
88592: LD_VAR 0 7
88596: PUSH
88597: LD_INT 2
88599: ARRAY
88600: PPUSH
88601: LD_VAR 0 3
88605: PPUSH
88606: CALL_OW 48
// result := IsPlaced ( unit ) ;
88610: LD_ADDR_VAR 0 4
88614: PUSH
88615: LD_VAR 0 1
88619: PPUSH
88620: CALL_OW 305
88624: ST_TO_ADDR
// exit ;
88625: POP
88626: POP
88627: GO 88633
// end ; end ;
88629: GO 88508
88631: POP
88632: POP
// end ;
88633: LD_VAR 0 4
88637: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
88638: LD_INT 0
88640: PPUSH
88641: PPUSH
88642: PPUSH
// if not side or side > 8 then
88643: LD_VAR 0 1
88647: NOT
88648: PUSH
88649: LD_VAR 0 1
88653: PUSH
88654: LD_INT 8
88656: GREATER
88657: OR
88658: IFFALSE 88662
// exit ;
88660: GO 88849
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
88662: LD_ADDR_VAR 0 4
88666: PUSH
88667: LD_INT 22
88669: PUSH
88670: LD_VAR 0 1
88674: PUSH
88675: EMPTY
88676: LIST
88677: LIST
88678: PUSH
88679: LD_INT 21
88681: PUSH
88682: LD_INT 3
88684: PUSH
88685: EMPTY
88686: LIST
88687: LIST
88688: PUSH
88689: EMPTY
88690: LIST
88691: LIST
88692: PPUSH
88693: CALL_OW 69
88697: ST_TO_ADDR
// if not tmp then
88698: LD_VAR 0 4
88702: NOT
88703: IFFALSE 88707
// exit ;
88705: GO 88849
// enable_addtolog := true ;
88707: LD_ADDR_OWVAR 81
88711: PUSH
88712: LD_INT 1
88714: ST_TO_ADDR
// AddToLog ( [ ) ;
88715: LD_STRING [
88717: PPUSH
88718: CALL_OW 561
// for i in tmp do
88722: LD_ADDR_VAR 0 3
88726: PUSH
88727: LD_VAR 0 4
88731: PUSH
88732: FOR_IN
88733: IFFALSE 88840
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
88735: LD_STRING [
88737: PUSH
88738: LD_VAR 0 3
88742: PPUSH
88743: CALL_OW 266
88747: STR
88748: PUSH
88749: LD_STRING , 
88751: STR
88752: PUSH
88753: LD_VAR 0 3
88757: PPUSH
88758: CALL_OW 250
88762: STR
88763: PUSH
88764: LD_STRING , 
88766: STR
88767: PUSH
88768: LD_VAR 0 3
88772: PPUSH
88773: CALL_OW 251
88777: STR
88778: PUSH
88779: LD_STRING , 
88781: STR
88782: PUSH
88783: LD_VAR 0 3
88787: PPUSH
88788: CALL_OW 254
88792: STR
88793: PUSH
88794: LD_STRING , 
88796: STR
88797: PUSH
88798: LD_VAR 0 3
88802: PPUSH
88803: LD_INT 1
88805: PPUSH
88806: CALL_OW 268
88810: STR
88811: PUSH
88812: LD_STRING , 
88814: STR
88815: PUSH
88816: LD_VAR 0 3
88820: PPUSH
88821: LD_INT 2
88823: PPUSH
88824: CALL_OW 268
88828: STR
88829: PUSH
88830: LD_STRING ],
88832: STR
88833: PPUSH
88834: CALL_OW 561
// end ;
88838: GO 88732
88840: POP
88841: POP
// AddToLog ( ]; ) ;
88842: LD_STRING ];
88844: PPUSH
88845: CALL_OW 561
// end ;
88849: LD_VAR 0 2
88853: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
88854: LD_INT 0
88856: PPUSH
88857: PPUSH
88858: PPUSH
88859: PPUSH
88860: PPUSH
// if not area or not rate or not max then
88861: LD_VAR 0 1
88865: NOT
88866: PUSH
88867: LD_VAR 0 2
88871: NOT
88872: OR
88873: PUSH
88874: LD_VAR 0 4
88878: NOT
88879: OR
88880: IFFALSE 88884
// exit ;
88882: GO 89073
// while 1 do
88884: LD_INT 1
88886: IFFALSE 89073
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
88888: LD_ADDR_VAR 0 9
88892: PUSH
88893: LD_VAR 0 1
88897: PPUSH
88898: LD_INT 1
88900: PPUSH
88901: CALL_OW 287
88905: PUSH
88906: LD_INT 10
88908: MUL
88909: ST_TO_ADDR
// r := rate / 10 ;
88910: LD_ADDR_VAR 0 7
88914: PUSH
88915: LD_VAR 0 2
88919: PUSH
88920: LD_INT 10
88922: DIVREAL
88923: ST_TO_ADDR
// time := 1 1$00 ;
88924: LD_ADDR_VAR 0 8
88928: PUSH
88929: LD_INT 2100
88931: ST_TO_ADDR
// if amount < min then
88932: LD_VAR 0 9
88936: PUSH
88937: LD_VAR 0 3
88941: LESS
88942: IFFALSE 88960
// r := r * 2 else
88944: LD_ADDR_VAR 0 7
88948: PUSH
88949: LD_VAR 0 7
88953: PUSH
88954: LD_INT 2
88956: MUL
88957: ST_TO_ADDR
88958: GO 88986
// if amount > max then
88960: LD_VAR 0 9
88964: PUSH
88965: LD_VAR 0 4
88969: GREATER
88970: IFFALSE 88986
// r := r / 2 ;
88972: LD_ADDR_VAR 0 7
88976: PUSH
88977: LD_VAR 0 7
88981: PUSH
88982: LD_INT 2
88984: DIVREAL
88985: ST_TO_ADDR
// time := time / r ;
88986: LD_ADDR_VAR 0 8
88990: PUSH
88991: LD_VAR 0 8
88995: PUSH
88996: LD_VAR 0 7
89000: DIVREAL
89001: ST_TO_ADDR
// if time < 0 then
89002: LD_VAR 0 8
89006: PUSH
89007: LD_INT 0
89009: LESS
89010: IFFALSE 89027
// time := time * - 1 ;
89012: LD_ADDR_VAR 0 8
89016: PUSH
89017: LD_VAR 0 8
89021: PUSH
89022: LD_INT 1
89024: NEG
89025: MUL
89026: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
89027: LD_VAR 0 8
89031: PUSH
89032: LD_INT 35
89034: PPUSH
89035: LD_INT 875
89037: PPUSH
89038: CALL_OW 12
89042: PLUS
89043: PPUSH
89044: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
89048: LD_INT 1
89050: PPUSH
89051: LD_INT 5
89053: PPUSH
89054: CALL_OW 12
89058: PPUSH
89059: LD_VAR 0 1
89063: PPUSH
89064: LD_INT 1
89066: PPUSH
89067: CALL_OW 55
// end ;
89071: GO 88884
// end ;
89073: LD_VAR 0 5
89077: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
89078: LD_INT 0
89080: PPUSH
89081: PPUSH
89082: PPUSH
89083: PPUSH
89084: PPUSH
89085: PPUSH
89086: PPUSH
89087: PPUSH
// if not turrets or not factories then
89088: LD_VAR 0 1
89092: NOT
89093: PUSH
89094: LD_VAR 0 2
89098: NOT
89099: OR
89100: IFFALSE 89104
// exit ;
89102: GO 89411
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
89104: LD_ADDR_VAR 0 10
89108: PUSH
89109: LD_INT 5
89111: PUSH
89112: LD_INT 6
89114: PUSH
89115: EMPTY
89116: LIST
89117: LIST
89118: PUSH
89119: LD_INT 2
89121: PUSH
89122: LD_INT 4
89124: PUSH
89125: EMPTY
89126: LIST
89127: LIST
89128: PUSH
89129: LD_INT 3
89131: PUSH
89132: LD_INT 5
89134: PUSH
89135: EMPTY
89136: LIST
89137: LIST
89138: PUSH
89139: EMPTY
89140: LIST
89141: LIST
89142: LIST
89143: PUSH
89144: LD_INT 24
89146: PUSH
89147: LD_INT 25
89149: PUSH
89150: EMPTY
89151: LIST
89152: LIST
89153: PUSH
89154: LD_INT 23
89156: PUSH
89157: LD_INT 27
89159: PUSH
89160: EMPTY
89161: LIST
89162: LIST
89163: PUSH
89164: EMPTY
89165: LIST
89166: LIST
89167: PUSH
89168: LD_INT 42
89170: PUSH
89171: LD_INT 43
89173: PUSH
89174: EMPTY
89175: LIST
89176: LIST
89177: PUSH
89178: LD_INT 44
89180: PUSH
89181: LD_INT 46
89183: PUSH
89184: EMPTY
89185: LIST
89186: LIST
89187: PUSH
89188: LD_INT 45
89190: PUSH
89191: LD_INT 47
89193: PUSH
89194: EMPTY
89195: LIST
89196: LIST
89197: PUSH
89198: EMPTY
89199: LIST
89200: LIST
89201: LIST
89202: PUSH
89203: EMPTY
89204: LIST
89205: LIST
89206: LIST
89207: ST_TO_ADDR
// result := [ ] ;
89208: LD_ADDR_VAR 0 3
89212: PUSH
89213: EMPTY
89214: ST_TO_ADDR
// for i in turrets do
89215: LD_ADDR_VAR 0 4
89219: PUSH
89220: LD_VAR 0 1
89224: PUSH
89225: FOR_IN
89226: IFFALSE 89409
// begin nat := GetNation ( i ) ;
89228: LD_ADDR_VAR 0 7
89232: PUSH
89233: LD_VAR 0 4
89237: PPUSH
89238: CALL_OW 248
89242: ST_TO_ADDR
// weapon := 0 ;
89243: LD_ADDR_VAR 0 8
89247: PUSH
89248: LD_INT 0
89250: ST_TO_ADDR
// if not nat then
89251: LD_VAR 0 7
89255: NOT
89256: IFFALSE 89260
// continue ;
89258: GO 89225
// for j in list [ nat ] do
89260: LD_ADDR_VAR 0 5
89264: PUSH
89265: LD_VAR 0 10
89269: PUSH
89270: LD_VAR 0 7
89274: ARRAY
89275: PUSH
89276: FOR_IN
89277: IFFALSE 89318
// if GetBWeapon ( i ) = j [ 1 ] then
89279: LD_VAR 0 4
89283: PPUSH
89284: CALL_OW 269
89288: PUSH
89289: LD_VAR 0 5
89293: PUSH
89294: LD_INT 1
89296: ARRAY
89297: EQUAL
89298: IFFALSE 89316
// begin weapon := j [ 2 ] ;
89300: LD_ADDR_VAR 0 8
89304: PUSH
89305: LD_VAR 0 5
89309: PUSH
89310: LD_INT 2
89312: ARRAY
89313: ST_TO_ADDR
// break ;
89314: GO 89318
// end ;
89316: GO 89276
89318: POP
89319: POP
// if not weapon then
89320: LD_VAR 0 8
89324: NOT
89325: IFFALSE 89329
// continue ;
89327: GO 89225
// for k in factories do
89329: LD_ADDR_VAR 0 6
89333: PUSH
89334: LD_VAR 0 2
89338: PUSH
89339: FOR_IN
89340: IFFALSE 89405
// begin weapons := AvailableWeaponList ( k ) ;
89342: LD_ADDR_VAR 0 9
89346: PUSH
89347: LD_VAR 0 6
89351: PPUSH
89352: CALL_OW 478
89356: ST_TO_ADDR
// if not weapons then
89357: LD_VAR 0 9
89361: NOT
89362: IFFALSE 89366
// continue ;
89364: GO 89339
// if weapon in weapons then
89366: LD_VAR 0 8
89370: PUSH
89371: LD_VAR 0 9
89375: IN
89376: IFFALSE 89403
// begin result := [ i , weapon ] ;
89378: LD_ADDR_VAR 0 3
89382: PUSH
89383: LD_VAR 0 4
89387: PUSH
89388: LD_VAR 0 8
89392: PUSH
89393: EMPTY
89394: LIST
89395: LIST
89396: ST_TO_ADDR
// exit ;
89397: POP
89398: POP
89399: POP
89400: POP
89401: GO 89411
// end ; end ;
89403: GO 89339
89405: POP
89406: POP
// end ;
89407: GO 89225
89409: POP
89410: POP
// end ;
89411: LD_VAR 0 3
89415: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
89416: LD_INT 0
89418: PPUSH
// if not side or side > 8 then
89419: LD_VAR 0 3
89423: NOT
89424: PUSH
89425: LD_VAR 0 3
89429: PUSH
89430: LD_INT 8
89432: GREATER
89433: OR
89434: IFFALSE 89438
// exit ;
89436: GO 89497
// if not range then
89438: LD_VAR 0 4
89442: NOT
89443: IFFALSE 89454
// range := - 12 ;
89445: LD_ADDR_VAR 0 4
89449: PUSH
89450: LD_INT 12
89452: NEG
89453: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
89454: LD_VAR 0 1
89458: PPUSH
89459: LD_VAR 0 2
89463: PPUSH
89464: LD_VAR 0 3
89468: PPUSH
89469: LD_VAR 0 4
89473: PPUSH
89474: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
89478: LD_VAR 0 1
89482: PPUSH
89483: LD_VAR 0 2
89487: PPUSH
89488: LD_VAR 0 3
89492: PPUSH
89493: CALL_OW 331
// end ;
89497: LD_VAR 0 5
89501: RET
// export function Video ( mode ) ; begin
89502: LD_INT 0
89504: PPUSH
// ingame_video = mode ;
89505: LD_ADDR_OWVAR 52
89509: PUSH
89510: LD_VAR 0 1
89514: ST_TO_ADDR
// interface_hidden = mode ;
89515: LD_ADDR_OWVAR 54
89519: PUSH
89520: LD_VAR 0 1
89524: ST_TO_ADDR
// end ;
89525: LD_VAR 0 2
89529: RET
// export function Join ( array , element ) ; begin
89530: LD_INT 0
89532: PPUSH
// result := Replace ( array , array + 1 , element ) ;
89533: LD_ADDR_VAR 0 3
89537: PUSH
89538: LD_VAR 0 1
89542: PPUSH
89543: LD_VAR 0 1
89547: PUSH
89548: LD_INT 1
89550: PLUS
89551: PPUSH
89552: LD_VAR 0 2
89556: PPUSH
89557: CALL_OW 1
89561: ST_TO_ADDR
// end ;
89562: LD_VAR 0 3
89566: RET
// export function JoinUnion ( array , element ) ; begin
89567: LD_INT 0
89569: PPUSH
// result := array union element ;
89570: LD_ADDR_VAR 0 3
89574: PUSH
89575: LD_VAR 0 1
89579: PUSH
89580: LD_VAR 0 2
89584: UNION
89585: ST_TO_ADDR
// end ;
89586: LD_VAR 0 3
89590: RET
// export function GetBehemoths ( side ) ; begin
89591: LD_INT 0
89593: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
89594: LD_ADDR_VAR 0 2
89598: PUSH
89599: LD_INT 22
89601: PUSH
89602: LD_VAR 0 1
89606: PUSH
89607: EMPTY
89608: LIST
89609: LIST
89610: PUSH
89611: LD_INT 31
89613: PUSH
89614: LD_INT 25
89616: PUSH
89617: EMPTY
89618: LIST
89619: LIST
89620: PUSH
89621: EMPTY
89622: LIST
89623: LIST
89624: PPUSH
89625: CALL_OW 69
89629: ST_TO_ADDR
// end ;
89630: LD_VAR 0 2
89634: RET
// export function Shuffle ( array ) ; var i , index ; begin
89635: LD_INT 0
89637: PPUSH
89638: PPUSH
89639: PPUSH
// result := [ ] ;
89640: LD_ADDR_VAR 0 2
89644: PUSH
89645: EMPTY
89646: ST_TO_ADDR
// if not array then
89647: LD_VAR 0 1
89651: NOT
89652: IFFALSE 89656
// exit ;
89654: GO 89755
// Randomize ;
89656: CALL_OW 10
// for i = array downto 1 do
89660: LD_ADDR_VAR 0 3
89664: PUSH
89665: DOUBLE
89666: LD_VAR 0 1
89670: INC
89671: ST_TO_ADDR
89672: LD_INT 1
89674: PUSH
89675: FOR_DOWNTO
89676: IFFALSE 89753
// begin index := rand ( 1 , array ) ;
89678: LD_ADDR_VAR 0 4
89682: PUSH
89683: LD_INT 1
89685: PPUSH
89686: LD_VAR 0 1
89690: PPUSH
89691: CALL_OW 12
89695: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
89696: LD_ADDR_VAR 0 2
89700: PUSH
89701: LD_VAR 0 2
89705: PPUSH
89706: LD_VAR 0 2
89710: PUSH
89711: LD_INT 1
89713: PLUS
89714: PPUSH
89715: LD_VAR 0 1
89719: PUSH
89720: LD_VAR 0 4
89724: ARRAY
89725: PPUSH
89726: CALL_OW 2
89730: ST_TO_ADDR
// array := Delete ( array , index ) ;
89731: LD_ADDR_VAR 0 1
89735: PUSH
89736: LD_VAR 0 1
89740: PPUSH
89741: LD_VAR 0 4
89745: PPUSH
89746: CALL_OW 3
89750: ST_TO_ADDR
// end ;
89751: GO 89675
89753: POP
89754: POP
// end ;
89755: LD_VAR 0 2
89759: RET
// export function GetBaseMaterials ( base ) ; begin
89760: LD_INT 0
89762: PPUSH
// result := [ 0 , 0 , 0 ] ;
89763: LD_ADDR_VAR 0 2
89767: PUSH
89768: LD_INT 0
89770: PUSH
89771: LD_INT 0
89773: PUSH
89774: LD_INT 0
89776: PUSH
89777: EMPTY
89778: LIST
89779: LIST
89780: LIST
89781: ST_TO_ADDR
// if not base then
89782: LD_VAR 0 1
89786: NOT
89787: IFFALSE 89791
// exit ;
89789: GO 89840
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
89791: LD_ADDR_VAR 0 2
89795: PUSH
89796: LD_VAR 0 1
89800: PPUSH
89801: LD_INT 1
89803: PPUSH
89804: CALL_OW 275
89808: PUSH
89809: LD_VAR 0 1
89813: PPUSH
89814: LD_INT 2
89816: PPUSH
89817: CALL_OW 275
89821: PUSH
89822: LD_VAR 0 1
89826: PPUSH
89827: LD_INT 3
89829: PPUSH
89830: CALL_OW 275
89834: PUSH
89835: EMPTY
89836: LIST
89837: LIST
89838: LIST
89839: ST_TO_ADDR
// end ;
89840: LD_VAR 0 2
89844: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
89845: LD_INT 0
89847: PPUSH
89848: PPUSH
// result := array ;
89849: LD_ADDR_VAR 0 3
89853: PUSH
89854: LD_VAR 0 1
89858: ST_TO_ADDR
// if size >= result then
89859: LD_VAR 0 2
89863: PUSH
89864: LD_VAR 0 3
89868: GREATEREQUAL
89869: IFFALSE 89873
// exit ;
89871: GO 89923
// if size then
89873: LD_VAR 0 2
89877: IFFALSE 89923
// for i := array downto size do
89879: LD_ADDR_VAR 0 4
89883: PUSH
89884: DOUBLE
89885: LD_VAR 0 1
89889: INC
89890: ST_TO_ADDR
89891: LD_VAR 0 2
89895: PUSH
89896: FOR_DOWNTO
89897: IFFALSE 89921
// result := Delete ( result , result ) ;
89899: LD_ADDR_VAR 0 3
89903: PUSH
89904: LD_VAR 0 3
89908: PPUSH
89909: LD_VAR 0 3
89913: PPUSH
89914: CALL_OW 3
89918: ST_TO_ADDR
89919: GO 89896
89921: POP
89922: POP
// end ;
89923: LD_VAR 0 3
89927: RET
// export function ComExit ( unit ) ; var tmp ; begin
89928: LD_INT 0
89930: PPUSH
89931: PPUSH
// if not IsInUnit ( unit ) then
89932: LD_VAR 0 1
89936: PPUSH
89937: CALL_OW 310
89941: NOT
89942: IFFALSE 89946
// exit ;
89944: GO 90006
// tmp := IsInUnit ( unit ) ;
89946: LD_ADDR_VAR 0 3
89950: PUSH
89951: LD_VAR 0 1
89955: PPUSH
89956: CALL_OW 310
89960: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
89961: LD_VAR 0 3
89965: PPUSH
89966: CALL_OW 247
89970: PUSH
89971: LD_INT 2
89973: EQUAL
89974: IFFALSE 89987
// ComExitVehicle ( unit ) else
89976: LD_VAR 0 1
89980: PPUSH
89981: CALL_OW 121
89985: GO 89996
// ComExitBuilding ( unit ) ;
89987: LD_VAR 0 1
89991: PPUSH
89992: CALL_OW 122
// result := tmp ;
89996: LD_ADDR_VAR 0 2
90000: PUSH
90001: LD_VAR 0 3
90005: ST_TO_ADDR
// end ;
90006: LD_VAR 0 2
90010: RET
// export function ComExitAll ( units ) ; var i ; begin
90011: LD_INT 0
90013: PPUSH
90014: PPUSH
// if not units then
90015: LD_VAR 0 1
90019: NOT
90020: IFFALSE 90024
// exit ;
90022: GO 90050
// for i in units do
90024: LD_ADDR_VAR 0 3
90028: PUSH
90029: LD_VAR 0 1
90033: PUSH
90034: FOR_IN
90035: IFFALSE 90048
// ComExit ( i ) ;
90037: LD_VAR 0 3
90041: PPUSH
90042: CALL 89928 0 1
90046: GO 90034
90048: POP
90049: POP
// end ;
90050: LD_VAR 0 2
90054: RET
// export function ResetHc ; begin
90055: LD_INT 0
90057: PPUSH
// InitHc ;
90058: CALL_OW 19
// hc_importance := 0 ;
90062: LD_ADDR_OWVAR 32
90066: PUSH
90067: LD_INT 0
90069: ST_TO_ADDR
// end ;
90070: LD_VAR 0 1
90074: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
90075: LD_INT 0
90077: PPUSH
90078: PPUSH
90079: PPUSH
// _x := ( x1 + x2 ) div 2 ;
90080: LD_ADDR_VAR 0 6
90084: PUSH
90085: LD_VAR 0 1
90089: PUSH
90090: LD_VAR 0 3
90094: PLUS
90095: PUSH
90096: LD_INT 2
90098: DIV
90099: ST_TO_ADDR
// if _x < 0 then
90100: LD_VAR 0 6
90104: PUSH
90105: LD_INT 0
90107: LESS
90108: IFFALSE 90125
// _x := _x * - 1 ;
90110: LD_ADDR_VAR 0 6
90114: PUSH
90115: LD_VAR 0 6
90119: PUSH
90120: LD_INT 1
90122: NEG
90123: MUL
90124: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
90125: LD_ADDR_VAR 0 7
90129: PUSH
90130: LD_VAR 0 2
90134: PUSH
90135: LD_VAR 0 4
90139: PLUS
90140: PUSH
90141: LD_INT 2
90143: DIV
90144: ST_TO_ADDR
// if _y < 0 then
90145: LD_VAR 0 7
90149: PUSH
90150: LD_INT 0
90152: LESS
90153: IFFALSE 90170
// _y := _y * - 1 ;
90155: LD_ADDR_VAR 0 7
90159: PUSH
90160: LD_VAR 0 7
90164: PUSH
90165: LD_INT 1
90167: NEG
90168: MUL
90169: ST_TO_ADDR
// result := [ _x , _y ] ;
90170: LD_ADDR_VAR 0 5
90174: PUSH
90175: LD_VAR 0 6
90179: PUSH
90180: LD_VAR 0 7
90184: PUSH
90185: EMPTY
90186: LIST
90187: LIST
90188: ST_TO_ADDR
// end ;
90189: LD_VAR 0 5
90193: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
90194: LD_INT 0
90196: PPUSH
90197: PPUSH
90198: PPUSH
90199: PPUSH
// task := GetTaskList ( unit ) ;
90200: LD_ADDR_VAR 0 7
90204: PUSH
90205: LD_VAR 0 1
90209: PPUSH
90210: CALL_OW 437
90214: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
90215: LD_VAR 0 7
90219: NOT
90220: PUSH
90221: LD_VAR 0 1
90225: PPUSH
90226: LD_VAR 0 2
90230: PPUSH
90231: CALL_OW 308
90235: NOT
90236: AND
90237: IFFALSE 90241
// exit ;
90239: GO 90359
// if IsInArea ( unit , area ) then
90241: LD_VAR 0 1
90245: PPUSH
90246: LD_VAR 0 2
90250: PPUSH
90251: CALL_OW 308
90255: IFFALSE 90273
// begin ComMoveToArea ( unit , goAway ) ;
90257: LD_VAR 0 1
90261: PPUSH
90262: LD_VAR 0 3
90266: PPUSH
90267: CALL_OW 113
// exit ;
90271: GO 90359
// end ; if task [ 1 ] [ 1 ] <> M then
90273: LD_VAR 0 7
90277: PUSH
90278: LD_INT 1
90280: ARRAY
90281: PUSH
90282: LD_INT 1
90284: ARRAY
90285: PUSH
90286: LD_STRING M
90288: NONEQUAL
90289: IFFALSE 90293
// exit ;
90291: GO 90359
// x := task [ 1 ] [ 2 ] ;
90293: LD_ADDR_VAR 0 5
90297: PUSH
90298: LD_VAR 0 7
90302: PUSH
90303: LD_INT 1
90305: ARRAY
90306: PUSH
90307: LD_INT 2
90309: ARRAY
90310: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
90311: LD_ADDR_VAR 0 6
90315: PUSH
90316: LD_VAR 0 7
90320: PUSH
90321: LD_INT 1
90323: ARRAY
90324: PUSH
90325: LD_INT 3
90327: ARRAY
90328: ST_TO_ADDR
// if InArea ( x , y , area ) then
90329: LD_VAR 0 5
90333: PPUSH
90334: LD_VAR 0 6
90338: PPUSH
90339: LD_VAR 0 2
90343: PPUSH
90344: CALL_OW 309
90348: IFFALSE 90359
// ComStop ( unit ) ;
90350: LD_VAR 0 1
90354: PPUSH
90355: CALL_OW 141
// end ;
90359: LD_VAR 0 4
90363: RET
// export function Abs ( value ) ; begin
90364: LD_INT 0
90366: PPUSH
// result := value ;
90367: LD_ADDR_VAR 0 2
90371: PUSH
90372: LD_VAR 0 1
90376: ST_TO_ADDR
// if value < 0 then
90377: LD_VAR 0 1
90381: PUSH
90382: LD_INT 0
90384: LESS
90385: IFFALSE 90402
// result := value * - 1 ;
90387: LD_ADDR_VAR 0 2
90391: PUSH
90392: LD_VAR 0 1
90396: PUSH
90397: LD_INT 1
90399: NEG
90400: MUL
90401: ST_TO_ADDR
// end ;
90402: LD_VAR 0 2
90406: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
90407: LD_INT 0
90409: PPUSH
90410: PPUSH
90411: PPUSH
90412: PPUSH
90413: PPUSH
90414: PPUSH
90415: PPUSH
90416: PPUSH
// if not unit or not building then
90417: LD_VAR 0 1
90421: NOT
90422: PUSH
90423: LD_VAR 0 2
90427: NOT
90428: OR
90429: IFFALSE 90433
// exit ;
90431: GO 90659
// x := GetX ( building ) ;
90433: LD_ADDR_VAR 0 4
90437: PUSH
90438: LD_VAR 0 2
90442: PPUSH
90443: CALL_OW 250
90447: ST_TO_ADDR
// y := GetY ( building ) ;
90448: LD_ADDR_VAR 0 6
90452: PUSH
90453: LD_VAR 0 2
90457: PPUSH
90458: CALL_OW 251
90462: ST_TO_ADDR
// d := GetDir ( building ) ;
90463: LD_ADDR_VAR 0 8
90467: PUSH
90468: LD_VAR 0 2
90472: PPUSH
90473: CALL_OW 254
90477: ST_TO_ADDR
// r := 4 ;
90478: LD_ADDR_VAR 0 9
90482: PUSH
90483: LD_INT 4
90485: ST_TO_ADDR
// for i := 1 to 5 do
90486: LD_ADDR_VAR 0 10
90490: PUSH
90491: DOUBLE
90492: LD_INT 1
90494: DEC
90495: ST_TO_ADDR
90496: LD_INT 5
90498: PUSH
90499: FOR_TO
90500: IFFALSE 90657
// begin _x := ShiftX ( x , d , r + i ) ;
90502: LD_ADDR_VAR 0 5
90506: PUSH
90507: LD_VAR 0 4
90511: PPUSH
90512: LD_VAR 0 8
90516: PPUSH
90517: LD_VAR 0 9
90521: PUSH
90522: LD_VAR 0 10
90526: PLUS
90527: PPUSH
90528: CALL_OW 272
90532: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
90533: LD_ADDR_VAR 0 7
90537: PUSH
90538: LD_VAR 0 6
90542: PPUSH
90543: LD_VAR 0 8
90547: PPUSH
90548: LD_VAR 0 9
90552: PUSH
90553: LD_VAR 0 10
90557: PLUS
90558: PPUSH
90559: CALL_OW 273
90563: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
90564: LD_VAR 0 5
90568: PPUSH
90569: LD_VAR 0 7
90573: PPUSH
90574: CALL_OW 488
90578: PUSH
90579: LD_VAR 0 5
90583: PPUSH
90584: LD_VAR 0 7
90588: PPUSH
90589: CALL_OW 428
90593: PPUSH
90594: CALL_OW 247
90598: PUSH
90599: LD_INT 3
90601: PUSH
90602: LD_INT 2
90604: PUSH
90605: EMPTY
90606: LIST
90607: LIST
90608: IN
90609: NOT
90610: AND
90611: IFFALSE 90655
// begin ComMoveXY ( unit , _x , _y ) ;
90613: LD_VAR 0 1
90617: PPUSH
90618: LD_VAR 0 5
90622: PPUSH
90623: LD_VAR 0 7
90627: PPUSH
90628: CALL_OW 111
// result := [ _x , _y ] ;
90632: LD_ADDR_VAR 0 3
90636: PUSH
90637: LD_VAR 0 5
90641: PUSH
90642: LD_VAR 0 7
90646: PUSH
90647: EMPTY
90648: LIST
90649: LIST
90650: ST_TO_ADDR
// exit ;
90651: POP
90652: POP
90653: GO 90659
// end ; end ;
90655: GO 90499
90657: POP
90658: POP
// end ;
90659: LD_VAR 0 3
90663: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
90664: LD_INT 0
90666: PPUSH
90667: PPUSH
90668: PPUSH
// result := 0 ;
90669: LD_ADDR_VAR 0 3
90673: PUSH
90674: LD_INT 0
90676: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
90677: LD_VAR 0 1
90681: PUSH
90682: LD_INT 0
90684: LESS
90685: PUSH
90686: LD_VAR 0 1
90690: PUSH
90691: LD_INT 8
90693: GREATER
90694: OR
90695: PUSH
90696: LD_VAR 0 2
90700: PUSH
90701: LD_INT 0
90703: LESS
90704: OR
90705: PUSH
90706: LD_VAR 0 2
90710: PUSH
90711: LD_INT 8
90713: GREATER
90714: OR
90715: IFFALSE 90719
// exit ;
90717: GO 90794
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
90719: LD_ADDR_VAR 0 4
90723: PUSH
90724: LD_INT 22
90726: PUSH
90727: LD_VAR 0 2
90731: PUSH
90732: EMPTY
90733: LIST
90734: LIST
90735: PPUSH
90736: CALL_OW 69
90740: PUSH
90741: FOR_IN
90742: IFFALSE 90792
// begin un := UnitShoot ( i ) ;
90744: LD_ADDR_VAR 0 5
90748: PUSH
90749: LD_VAR 0 4
90753: PPUSH
90754: CALL_OW 504
90758: ST_TO_ADDR
// if GetSide ( un ) = side1 then
90759: LD_VAR 0 5
90763: PPUSH
90764: CALL_OW 255
90768: PUSH
90769: LD_VAR 0 1
90773: EQUAL
90774: IFFALSE 90790
// begin result := un ;
90776: LD_ADDR_VAR 0 3
90780: PUSH
90781: LD_VAR 0 5
90785: ST_TO_ADDR
// exit ;
90786: POP
90787: POP
90788: GO 90794
// end ; end ;
90790: GO 90741
90792: POP
90793: POP
// end ;
90794: LD_VAR 0 3
90798: RET
// export function GetCargoBay ( units ) ; begin
90799: LD_INT 0
90801: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
90802: LD_ADDR_VAR 0 2
90806: PUSH
90807: LD_VAR 0 1
90811: PPUSH
90812: LD_INT 2
90814: PUSH
90815: LD_INT 34
90817: PUSH
90818: LD_INT 12
90820: PUSH
90821: EMPTY
90822: LIST
90823: LIST
90824: PUSH
90825: LD_INT 34
90827: PUSH
90828: LD_INT 51
90830: PUSH
90831: EMPTY
90832: LIST
90833: LIST
90834: PUSH
90835: LD_INT 34
90837: PUSH
90838: LD_INT 32
90840: PUSH
90841: EMPTY
90842: LIST
90843: LIST
90844: PUSH
90845: LD_INT 34
90847: PUSH
90848: LD_INT 89
90850: PUSH
90851: EMPTY
90852: LIST
90853: LIST
90854: PUSH
90855: EMPTY
90856: LIST
90857: LIST
90858: LIST
90859: LIST
90860: LIST
90861: PPUSH
90862: CALL_OW 72
90866: ST_TO_ADDR
// end ;
90867: LD_VAR 0 2
90871: RET
// export function Negate ( value ) ; begin
90872: LD_INT 0
90874: PPUSH
// result := not value ;
90875: LD_ADDR_VAR 0 2
90879: PUSH
90880: LD_VAR 0 1
90884: NOT
90885: ST_TO_ADDR
// end ;
90886: LD_VAR 0 2
90890: RET
// export function Inc ( value ) ; begin
90891: LD_INT 0
90893: PPUSH
// result := value + 1 ;
90894: LD_ADDR_VAR 0 2
90898: PUSH
90899: LD_VAR 0 1
90903: PUSH
90904: LD_INT 1
90906: PLUS
90907: ST_TO_ADDR
// end ;
90908: LD_VAR 0 2
90912: RET
// export function Dec ( value ) ; begin
90913: LD_INT 0
90915: PPUSH
// result := value - 1 ;
90916: LD_ADDR_VAR 0 2
90920: PUSH
90921: LD_VAR 0 1
90925: PUSH
90926: LD_INT 1
90928: MINUS
90929: ST_TO_ADDR
// end ;
90930: LD_VAR 0 2
90934: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
90935: LD_INT 0
90937: PPUSH
90938: PPUSH
90939: PPUSH
90940: PPUSH
90941: PPUSH
90942: PPUSH
90943: PPUSH
90944: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
90945: LD_VAR 0 1
90949: PPUSH
90950: LD_VAR 0 2
90954: PPUSH
90955: CALL_OW 488
90959: NOT
90960: PUSH
90961: LD_VAR 0 3
90965: PPUSH
90966: LD_VAR 0 4
90970: PPUSH
90971: CALL_OW 488
90975: NOT
90976: OR
90977: IFFALSE 90990
// begin result := - 1 ;
90979: LD_ADDR_VAR 0 5
90983: PUSH
90984: LD_INT 1
90986: NEG
90987: ST_TO_ADDR
// exit ;
90988: GO 91225
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
90990: LD_ADDR_VAR 0 12
90994: PUSH
90995: LD_VAR 0 1
90999: PPUSH
91000: LD_VAR 0 2
91004: PPUSH
91005: LD_VAR 0 3
91009: PPUSH
91010: LD_VAR 0 4
91014: PPUSH
91015: CALL 90075 0 4
91019: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
91020: LD_ADDR_VAR 0 11
91024: PUSH
91025: LD_VAR 0 1
91029: PPUSH
91030: LD_VAR 0 2
91034: PPUSH
91035: LD_VAR 0 12
91039: PUSH
91040: LD_INT 1
91042: ARRAY
91043: PPUSH
91044: LD_VAR 0 12
91048: PUSH
91049: LD_INT 2
91051: ARRAY
91052: PPUSH
91053: CALL_OW 298
91057: ST_TO_ADDR
// distance := 9999 ;
91058: LD_ADDR_VAR 0 10
91062: PUSH
91063: LD_INT 9999
91065: ST_TO_ADDR
// for i := 0 to 5 do
91066: LD_ADDR_VAR 0 6
91070: PUSH
91071: DOUBLE
91072: LD_INT 0
91074: DEC
91075: ST_TO_ADDR
91076: LD_INT 5
91078: PUSH
91079: FOR_TO
91080: IFFALSE 91223
// begin _x := ShiftX ( x1 , i , centerDist ) ;
91082: LD_ADDR_VAR 0 7
91086: PUSH
91087: LD_VAR 0 1
91091: PPUSH
91092: LD_VAR 0 6
91096: PPUSH
91097: LD_VAR 0 11
91101: PPUSH
91102: CALL_OW 272
91106: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
91107: LD_ADDR_VAR 0 8
91111: PUSH
91112: LD_VAR 0 2
91116: PPUSH
91117: LD_VAR 0 6
91121: PPUSH
91122: LD_VAR 0 11
91126: PPUSH
91127: CALL_OW 273
91131: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
91132: LD_VAR 0 7
91136: PPUSH
91137: LD_VAR 0 8
91141: PPUSH
91142: CALL_OW 488
91146: NOT
91147: IFFALSE 91151
// continue ;
91149: GO 91079
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
91151: LD_ADDR_VAR 0 9
91155: PUSH
91156: LD_VAR 0 12
91160: PUSH
91161: LD_INT 1
91163: ARRAY
91164: PPUSH
91165: LD_VAR 0 12
91169: PUSH
91170: LD_INT 2
91172: ARRAY
91173: PPUSH
91174: LD_VAR 0 7
91178: PPUSH
91179: LD_VAR 0 8
91183: PPUSH
91184: CALL_OW 298
91188: ST_TO_ADDR
// if tmp < distance then
91189: LD_VAR 0 9
91193: PUSH
91194: LD_VAR 0 10
91198: LESS
91199: IFFALSE 91221
// begin result := i ;
91201: LD_ADDR_VAR 0 5
91205: PUSH
91206: LD_VAR 0 6
91210: ST_TO_ADDR
// distance := tmp ;
91211: LD_ADDR_VAR 0 10
91215: PUSH
91216: LD_VAR 0 9
91220: ST_TO_ADDR
// end ; end ;
91221: GO 91079
91223: POP
91224: POP
// end ;
91225: LD_VAR 0 5
91229: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
91230: LD_INT 0
91232: PPUSH
91233: PPUSH
// if not driver or not IsInUnit ( driver ) then
91234: LD_VAR 0 1
91238: NOT
91239: PUSH
91240: LD_VAR 0 1
91244: PPUSH
91245: CALL_OW 310
91249: NOT
91250: OR
91251: IFFALSE 91255
// exit ;
91253: GO 91345
// vehicle := IsInUnit ( driver ) ;
91255: LD_ADDR_VAR 0 3
91259: PUSH
91260: LD_VAR 0 1
91264: PPUSH
91265: CALL_OW 310
91269: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
91270: LD_VAR 0 1
91274: PPUSH
91275: LD_STRING \
91277: PUSH
91278: LD_INT 0
91280: PUSH
91281: LD_INT 0
91283: PUSH
91284: LD_INT 0
91286: PUSH
91287: LD_INT 0
91289: PUSH
91290: LD_INT 0
91292: PUSH
91293: LD_INT 0
91295: PUSH
91296: EMPTY
91297: LIST
91298: LIST
91299: LIST
91300: LIST
91301: LIST
91302: LIST
91303: LIST
91304: PUSH
91305: LD_STRING E
91307: PUSH
91308: LD_INT 0
91310: PUSH
91311: LD_INT 0
91313: PUSH
91314: LD_VAR 0 3
91318: PUSH
91319: LD_INT 0
91321: PUSH
91322: LD_INT 0
91324: PUSH
91325: LD_INT 0
91327: PUSH
91328: EMPTY
91329: LIST
91330: LIST
91331: LIST
91332: LIST
91333: LIST
91334: LIST
91335: LIST
91336: PUSH
91337: EMPTY
91338: LIST
91339: LIST
91340: PPUSH
91341: CALL_OW 446
// end ;
91345: LD_VAR 0 2
91349: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
91350: LD_INT 0
91352: PPUSH
91353: PPUSH
// if not driver or not IsInUnit ( driver ) then
91354: LD_VAR 0 1
91358: NOT
91359: PUSH
91360: LD_VAR 0 1
91364: PPUSH
91365: CALL_OW 310
91369: NOT
91370: OR
91371: IFFALSE 91375
// exit ;
91373: GO 91465
// vehicle := IsInUnit ( driver ) ;
91375: LD_ADDR_VAR 0 3
91379: PUSH
91380: LD_VAR 0 1
91384: PPUSH
91385: CALL_OW 310
91389: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
91390: LD_VAR 0 1
91394: PPUSH
91395: LD_STRING \
91397: PUSH
91398: LD_INT 0
91400: PUSH
91401: LD_INT 0
91403: PUSH
91404: LD_INT 0
91406: PUSH
91407: LD_INT 0
91409: PUSH
91410: LD_INT 0
91412: PUSH
91413: LD_INT 0
91415: PUSH
91416: EMPTY
91417: LIST
91418: LIST
91419: LIST
91420: LIST
91421: LIST
91422: LIST
91423: LIST
91424: PUSH
91425: LD_STRING E
91427: PUSH
91428: LD_INT 0
91430: PUSH
91431: LD_INT 0
91433: PUSH
91434: LD_VAR 0 3
91438: PUSH
91439: LD_INT 0
91441: PUSH
91442: LD_INT 0
91444: PUSH
91445: LD_INT 0
91447: PUSH
91448: EMPTY
91449: LIST
91450: LIST
91451: LIST
91452: LIST
91453: LIST
91454: LIST
91455: LIST
91456: PUSH
91457: EMPTY
91458: LIST
91459: LIST
91460: PPUSH
91461: CALL_OW 447
// end ;
91465: LD_VAR 0 2
91469: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
91470: LD_INT 0
91472: PPUSH
91473: PPUSH
91474: PPUSH
// tmp := [ ] ;
91475: LD_ADDR_VAR 0 5
91479: PUSH
91480: EMPTY
91481: ST_TO_ADDR
// for i in units do
91482: LD_ADDR_VAR 0 4
91486: PUSH
91487: LD_VAR 0 1
91491: PUSH
91492: FOR_IN
91493: IFFALSE 91531
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
91495: LD_ADDR_VAR 0 5
91499: PUSH
91500: LD_VAR 0 5
91504: PPUSH
91505: LD_VAR 0 5
91509: PUSH
91510: LD_INT 1
91512: PLUS
91513: PPUSH
91514: LD_VAR 0 4
91518: PPUSH
91519: CALL_OW 256
91523: PPUSH
91524: CALL_OW 2
91528: ST_TO_ADDR
91529: GO 91492
91531: POP
91532: POP
// if not tmp then
91533: LD_VAR 0 5
91537: NOT
91538: IFFALSE 91542
// exit ;
91540: GO 91590
// if asc then
91542: LD_VAR 0 2
91546: IFFALSE 91570
// result := SortListByListAsc ( units , tmp ) else
91548: LD_ADDR_VAR 0 3
91552: PUSH
91553: LD_VAR 0 1
91557: PPUSH
91558: LD_VAR 0 5
91562: PPUSH
91563: CALL_OW 76
91567: ST_TO_ADDR
91568: GO 91590
// result := SortListByListDesc ( units , tmp ) ;
91570: LD_ADDR_VAR 0 3
91574: PUSH
91575: LD_VAR 0 1
91579: PPUSH
91580: LD_VAR 0 5
91584: PPUSH
91585: CALL_OW 77
91589: ST_TO_ADDR
// end ;
91590: LD_VAR 0 3
91594: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
91595: LD_INT 0
91597: PPUSH
91598: PPUSH
// task := GetTaskList ( mech ) ;
91599: LD_ADDR_VAR 0 4
91603: PUSH
91604: LD_VAR 0 1
91608: PPUSH
91609: CALL_OW 437
91613: ST_TO_ADDR
// if not task then
91614: LD_VAR 0 4
91618: NOT
91619: IFFALSE 91623
// exit ;
91621: GO 91665
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
91623: LD_ADDR_VAR 0 3
91627: PUSH
91628: LD_VAR 0 4
91632: PUSH
91633: LD_INT 1
91635: ARRAY
91636: PUSH
91637: LD_INT 1
91639: ARRAY
91640: PUSH
91641: LD_STRING r
91643: EQUAL
91644: PUSH
91645: LD_VAR 0 4
91649: PUSH
91650: LD_INT 1
91652: ARRAY
91653: PUSH
91654: LD_INT 4
91656: ARRAY
91657: PUSH
91658: LD_VAR 0 2
91662: EQUAL
91663: AND
91664: ST_TO_ADDR
// end ;
91665: LD_VAR 0 3
91669: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
91670: LD_INT 0
91672: PPUSH
// SetDir ( unit , d ) ;
91673: LD_VAR 0 1
91677: PPUSH
91678: LD_VAR 0 4
91682: PPUSH
91683: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
91687: LD_VAR 0 1
91691: PPUSH
91692: LD_VAR 0 2
91696: PPUSH
91697: LD_VAR 0 3
91701: PPUSH
91702: LD_VAR 0 5
91706: PPUSH
91707: CALL_OW 48
// end ;
91711: LD_VAR 0 6
91715: RET
// export function ToNaturalNumber ( number ) ; begin
91716: LD_INT 0
91718: PPUSH
// result := number div 1 ;
91719: LD_ADDR_VAR 0 2
91723: PUSH
91724: LD_VAR 0 1
91728: PUSH
91729: LD_INT 1
91731: DIV
91732: ST_TO_ADDR
// if number < 0 then
91733: LD_VAR 0 1
91737: PUSH
91738: LD_INT 0
91740: LESS
91741: IFFALSE 91751
// result := 0 ;
91743: LD_ADDR_VAR 0 2
91747: PUSH
91748: LD_INT 0
91750: ST_TO_ADDR
// end ;
91751: LD_VAR 0 2
91755: RET
// export function SortByClass ( units , class ) ; var un ; begin
91756: LD_INT 0
91758: PPUSH
91759: PPUSH
// if not units or not class then
91760: LD_VAR 0 1
91764: NOT
91765: PUSH
91766: LD_VAR 0 2
91770: NOT
91771: OR
91772: IFFALSE 91776
// exit ;
91774: GO 91871
// result := [ ] ;
91776: LD_ADDR_VAR 0 3
91780: PUSH
91781: EMPTY
91782: ST_TO_ADDR
// for un in units do
91783: LD_ADDR_VAR 0 4
91787: PUSH
91788: LD_VAR 0 1
91792: PUSH
91793: FOR_IN
91794: IFFALSE 91869
// if GetClass ( un ) = class then
91796: LD_VAR 0 4
91800: PPUSH
91801: CALL_OW 257
91805: PUSH
91806: LD_VAR 0 2
91810: EQUAL
91811: IFFALSE 91838
// result := Insert ( result , 1 , un ) else
91813: LD_ADDR_VAR 0 3
91817: PUSH
91818: LD_VAR 0 3
91822: PPUSH
91823: LD_INT 1
91825: PPUSH
91826: LD_VAR 0 4
91830: PPUSH
91831: CALL_OW 2
91835: ST_TO_ADDR
91836: GO 91867
// result := Replace ( result , result + 1 , un ) ;
91838: LD_ADDR_VAR 0 3
91842: PUSH
91843: LD_VAR 0 3
91847: PPUSH
91848: LD_VAR 0 3
91852: PUSH
91853: LD_INT 1
91855: PLUS
91856: PPUSH
91857: LD_VAR 0 4
91861: PPUSH
91862: CALL_OW 1
91866: ST_TO_ADDR
91867: GO 91793
91869: POP
91870: POP
// end ;
91871: LD_VAR 0 3
91875: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
91876: LD_INT 0
91878: PPUSH
91879: PPUSH
91880: PPUSH
91881: PPUSH
91882: PPUSH
91883: PPUSH
91884: PPUSH
// result := [ ] ;
91885: LD_ADDR_VAR 0 4
91889: PUSH
91890: EMPTY
91891: ST_TO_ADDR
// if x - r < 0 then
91892: LD_VAR 0 1
91896: PUSH
91897: LD_VAR 0 3
91901: MINUS
91902: PUSH
91903: LD_INT 0
91905: LESS
91906: IFFALSE 91918
// min_x := 0 else
91908: LD_ADDR_VAR 0 8
91912: PUSH
91913: LD_INT 0
91915: ST_TO_ADDR
91916: GO 91934
// min_x := x - r ;
91918: LD_ADDR_VAR 0 8
91922: PUSH
91923: LD_VAR 0 1
91927: PUSH
91928: LD_VAR 0 3
91932: MINUS
91933: ST_TO_ADDR
// if y - r < 0 then
91934: LD_VAR 0 2
91938: PUSH
91939: LD_VAR 0 3
91943: MINUS
91944: PUSH
91945: LD_INT 0
91947: LESS
91948: IFFALSE 91960
// min_y := 0 else
91950: LD_ADDR_VAR 0 7
91954: PUSH
91955: LD_INT 0
91957: ST_TO_ADDR
91958: GO 91976
// min_y := y - r ;
91960: LD_ADDR_VAR 0 7
91964: PUSH
91965: LD_VAR 0 2
91969: PUSH
91970: LD_VAR 0 3
91974: MINUS
91975: ST_TO_ADDR
// max_x := x + r ;
91976: LD_ADDR_VAR 0 9
91980: PUSH
91981: LD_VAR 0 1
91985: PUSH
91986: LD_VAR 0 3
91990: PLUS
91991: ST_TO_ADDR
// max_y := y + r ;
91992: LD_ADDR_VAR 0 10
91996: PUSH
91997: LD_VAR 0 2
92001: PUSH
92002: LD_VAR 0 3
92006: PLUS
92007: ST_TO_ADDR
// for _x = min_x to max_x do
92008: LD_ADDR_VAR 0 5
92012: PUSH
92013: DOUBLE
92014: LD_VAR 0 8
92018: DEC
92019: ST_TO_ADDR
92020: LD_VAR 0 9
92024: PUSH
92025: FOR_TO
92026: IFFALSE 92127
// for _y = min_y to max_y do
92028: LD_ADDR_VAR 0 6
92032: PUSH
92033: DOUBLE
92034: LD_VAR 0 7
92038: DEC
92039: ST_TO_ADDR
92040: LD_VAR 0 10
92044: PUSH
92045: FOR_TO
92046: IFFALSE 92123
// begin if not ValidHex ( _x , _y ) then
92048: LD_VAR 0 5
92052: PPUSH
92053: LD_VAR 0 6
92057: PPUSH
92058: CALL_OW 488
92062: NOT
92063: IFFALSE 92067
// continue ;
92065: GO 92045
// if GetResourceTypeXY ( _x , _y ) then
92067: LD_VAR 0 5
92071: PPUSH
92072: LD_VAR 0 6
92076: PPUSH
92077: CALL_OW 283
92081: IFFALSE 92121
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
92083: LD_ADDR_VAR 0 4
92087: PUSH
92088: LD_VAR 0 4
92092: PPUSH
92093: LD_VAR 0 4
92097: PUSH
92098: LD_INT 1
92100: PLUS
92101: PPUSH
92102: LD_VAR 0 5
92106: PUSH
92107: LD_VAR 0 6
92111: PUSH
92112: EMPTY
92113: LIST
92114: LIST
92115: PPUSH
92116: CALL_OW 1
92120: ST_TO_ADDR
// end ;
92121: GO 92045
92123: POP
92124: POP
92125: GO 92025
92127: POP
92128: POP
// end ;
92129: LD_VAR 0 4
92133: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
92134: LD_INT 0
92136: PPUSH
92137: PPUSH
92138: PPUSH
92139: PPUSH
92140: PPUSH
92141: PPUSH
92142: PPUSH
92143: PPUSH
// if not units then
92144: LD_VAR 0 1
92148: NOT
92149: IFFALSE 92153
// exit ;
92151: GO 92677
// result := UnitFilter ( units , [ f_ok ] ) ;
92153: LD_ADDR_VAR 0 3
92157: PUSH
92158: LD_VAR 0 1
92162: PPUSH
92163: LD_INT 50
92165: PUSH
92166: EMPTY
92167: LIST
92168: PPUSH
92169: CALL_OW 72
92173: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
92174: LD_ADDR_VAR 0 8
92178: PUSH
92179: LD_VAR 0 1
92183: PUSH
92184: LD_INT 1
92186: ARRAY
92187: PPUSH
92188: CALL_OW 255
92192: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
92193: LD_ADDR_VAR 0 10
92197: PUSH
92198: LD_INT 29
92200: PUSH
92201: LD_INT 91
92203: PUSH
92204: LD_INT 49
92206: PUSH
92207: EMPTY
92208: LIST
92209: LIST
92210: LIST
92211: ST_TO_ADDR
// if not result then
92212: LD_VAR 0 3
92216: NOT
92217: IFFALSE 92221
// exit ;
92219: GO 92677
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
92221: LD_ADDR_VAR 0 5
92225: PUSH
92226: LD_INT 81
92228: PUSH
92229: LD_VAR 0 8
92233: PUSH
92234: EMPTY
92235: LIST
92236: LIST
92237: PPUSH
92238: CALL_OW 69
92242: ST_TO_ADDR
// for i in result do
92243: LD_ADDR_VAR 0 4
92247: PUSH
92248: LD_VAR 0 3
92252: PUSH
92253: FOR_IN
92254: IFFALSE 92675
// begin tag := GetTag ( i ) + 1 ;
92256: LD_ADDR_VAR 0 9
92260: PUSH
92261: LD_VAR 0 4
92265: PPUSH
92266: CALL_OW 110
92270: PUSH
92271: LD_INT 1
92273: PLUS
92274: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
92275: LD_ADDR_VAR 0 7
92279: PUSH
92280: LD_VAR 0 4
92284: PPUSH
92285: CALL_OW 250
92289: PPUSH
92290: LD_VAR 0 4
92294: PPUSH
92295: CALL_OW 251
92299: PPUSH
92300: LD_INT 6
92302: PPUSH
92303: CALL 91876 0 3
92307: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
92308: LD_VAR 0 4
92312: PPUSH
92313: CALL_OW 247
92317: PUSH
92318: LD_INT 2
92320: EQUAL
92321: PUSH
92322: LD_VAR 0 7
92326: AND
92327: PUSH
92328: LD_VAR 0 4
92332: PPUSH
92333: CALL_OW 264
92337: PUSH
92338: LD_VAR 0 10
92342: IN
92343: NOT
92344: AND
92345: IFFALSE 92384
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
92347: LD_VAR 0 4
92351: PPUSH
92352: LD_VAR 0 7
92356: PUSH
92357: LD_INT 1
92359: ARRAY
92360: PUSH
92361: LD_INT 1
92363: ARRAY
92364: PPUSH
92365: LD_VAR 0 7
92369: PUSH
92370: LD_INT 1
92372: ARRAY
92373: PUSH
92374: LD_INT 2
92376: ARRAY
92377: PPUSH
92378: CALL_OW 116
92382: GO 92673
// if path > tag then
92384: LD_VAR 0 2
92388: PUSH
92389: LD_VAR 0 9
92393: GREATER
92394: IFFALSE 92602
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
92396: LD_ADDR_VAR 0 6
92400: PUSH
92401: LD_VAR 0 5
92405: PPUSH
92406: LD_INT 91
92408: PUSH
92409: LD_VAR 0 4
92413: PUSH
92414: LD_INT 8
92416: PUSH
92417: EMPTY
92418: LIST
92419: LIST
92420: LIST
92421: PPUSH
92422: CALL_OW 72
92426: ST_TO_ADDR
// if nearEnemy then
92427: LD_VAR 0 6
92431: IFFALSE 92500
// begin if GetWeapon ( i ) = ru_time_lapser then
92433: LD_VAR 0 4
92437: PPUSH
92438: CALL_OW 264
92442: PUSH
92443: LD_INT 49
92445: EQUAL
92446: IFFALSE 92474
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
92448: LD_VAR 0 4
92452: PPUSH
92453: LD_VAR 0 6
92457: PPUSH
92458: LD_VAR 0 4
92462: PPUSH
92463: CALL_OW 74
92467: PPUSH
92468: CALL_OW 112
92472: GO 92498
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
92474: LD_VAR 0 4
92478: PPUSH
92479: LD_VAR 0 6
92483: PPUSH
92484: LD_VAR 0 4
92488: PPUSH
92489: CALL_OW 74
92493: PPUSH
92494: CALL_OW 115
// end else
92498: GO 92600
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
92500: LD_VAR 0 4
92504: PPUSH
92505: LD_VAR 0 2
92509: PUSH
92510: LD_VAR 0 9
92514: ARRAY
92515: PUSH
92516: LD_INT 1
92518: ARRAY
92519: PPUSH
92520: LD_VAR 0 2
92524: PUSH
92525: LD_VAR 0 9
92529: ARRAY
92530: PUSH
92531: LD_INT 2
92533: ARRAY
92534: PPUSH
92535: CALL_OW 297
92539: PUSH
92540: LD_INT 6
92542: GREATER
92543: IFFALSE 92586
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
92545: LD_VAR 0 4
92549: PPUSH
92550: LD_VAR 0 2
92554: PUSH
92555: LD_VAR 0 9
92559: ARRAY
92560: PUSH
92561: LD_INT 1
92563: ARRAY
92564: PPUSH
92565: LD_VAR 0 2
92569: PUSH
92570: LD_VAR 0 9
92574: ARRAY
92575: PUSH
92576: LD_INT 2
92578: ARRAY
92579: PPUSH
92580: CALL_OW 114
92584: GO 92600
// SetTag ( i , tag ) ;
92586: LD_VAR 0 4
92590: PPUSH
92591: LD_VAR 0 9
92595: PPUSH
92596: CALL_OW 109
// end else
92600: GO 92673
// if enemy then
92602: LD_VAR 0 5
92606: IFFALSE 92673
// begin if GetWeapon ( i ) = ru_time_lapser then
92608: LD_VAR 0 4
92612: PPUSH
92613: CALL_OW 264
92617: PUSH
92618: LD_INT 49
92620: EQUAL
92621: IFFALSE 92649
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
92623: LD_VAR 0 4
92627: PPUSH
92628: LD_VAR 0 5
92632: PPUSH
92633: LD_VAR 0 4
92637: PPUSH
92638: CALL_OW 74
92642: PPUSH
92643: CALL_OW 112
92647: GO 92673
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
92649: LD_VAR 0 4
92653: PPUSH
92654: LD_VAR 0 5
92658: PPUSH
92659: LD_VAR 0 4
92663: PPUSH
92664: CALL_OW 74
92668: PPUSH
92669: CALL_OW 115
// end ; end ;
92673: GO 92253
92675: POP
92676: POP
// end ;
92677: LD_VAR 0 3
92681: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
92682: LD_INT 0
92684: PPUSH
92685: PPUSH
92686: PPUSH
// if not unit or IsInUnit ( unit ) then
92687: LD_VAR 0 1
92691: NOT
92692: PUSH
92693: LD_VAR 0 1
92697: PPUSH
92698: CALL_OW 310
92702: OR
92703: IFFALSE 92707
// exit ;
92705: GO 92798
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
92707: LD_ADDR_VAR 0 4
92711: PUSH
92712: LD_VAR 0 1
92716: PPUSH
92717: CALL_OW 250
92721: PPUSH
92722: LD_VAR 0 2
92726: PPUSH
92727: LD_INT 1
92729: PPUSH
92730: CALL_OW 272
92734: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
92735: LD_ADDR_VAR 0 5
92739: PUSH
92740: LD_VAR 0 1
92744: PPUSH
92745: CALL_OW 251
92749: PPUSH
92750: LD_VAR 0 2
92754: PPUSH
92755: LD_INT 1
92757: PPUSH
92758: CALL_OW 273
92762: ST_TO_ADDR
// if ValidHex ( x , y ) then
92763: LD_VAR 0 4
92767: PPUSH
92768: LD_VAR 0 5
92772: PPUSH
92773: CALL_OW 488
92777: IFFALSE 92798
// ComTurnXY ( unit , x , y ) ;
92779: LD_VAR 0 1
92783: PPUSH
92784: LD_VAR 0 4
92788: PPUSH
92789: LD_VAR 0 5
92793: PPUSH
92794: CALL_OW 118
// end ;
92798: LD_VAR 0 3
92802: RET
// export function SeeUnits ( side , units ) ; var i ; begin
92803: LD_INT 0
92805: PPUSH
92806: PPUSH
// result := false ;
92807: LD_ADDR_VAR 0 3
92811: PUSH
92812: LD_INT 0
92814: ST_TO_ADDR
// if not units then
92815: LD_VAR 0 2
92819: NOT
92820: IFFALSE 92824
// exit ;
92822: GO 92869
// for i in units do
92824: LD_ADDR_VAR 0 4
92828: PUSH
92829: LD_VAR 0 2
92833: PUSH
92834: FOR_IN
92835: IFFALSE 92867
// if See ( side , i ) then
92837: LD_VAR 0 1
92841: PPUSH
92842: LD_VAR 0 4
92846: PPUSH
92847: CALL_OW 292
92851: IFFALSE 92865
// begin result := true ;
92853: LD_ADDR_VAR 0 3
92857: PUSH
92858: LD_INT 1
92860: ST_TO_ADDR
// exit ;
92861: POP
92862: POP
92863: GO 92869
// end ;
92865: GO 92834
92867: POP
92868: POP
// end ;
92869: LD_VAR 0 3
92873: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
92874: LD_INT 0
92876: PPUSH
92877: PPUSH
92878: PPUSH
92879: PPUSH
// if not unit or not points then
92880: LD_VAR 0 1
92884: NOT
92885: PUSH
92886: LD_VAR 0 2
92890: NOT
92891: OR
92892: IFFALSE 92896
// exit ;
92894: GO 92986
// dist := 99999 ;
92896: LD_ADDR_VAR 0 5
92900: PUSH
92901: LD_INT 99999
92903: ST_TO_ADDR
// for i in points do
92904: LD_ADDR_VAR 0 4
92908: PUSH
92909: LD_VAR 0 2
92913: PUSH
92914: FOR_IN
92915: IFFALSE 92984
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
92917: LD_ADDR_VAR 0 6
92921: PUSH
92922: LD_VAR 0 1
92926: PPUSH
92927: LD_VAR 0 4
92931: PUSH
92932: LD_INT 1
92934: ARRAY
92935: PPUSH
92936: LD_VAR 0 4
92940: PUSH
92941: LD_INT 2
92943: ARRAY
92944: PPUSH
92945: CALL_OW 297
92949: ST_TO_ADDR
// if tmpDist < dist then
92950: LD_VAR 0 6
92954: PUSH
92955: LD_VAR 0 5
92959: LESS
92960: IFFALSE 92982
// begin result := i ;
92962: LD_ADDR_VAR 0 3
92966: PUSH
92967: LD_VAR 0 4
92971: ST_TO_ADDR
// dist := tmpDist ;
92972: LD_ADDR_VAR 0 5
92976: PUSH
92977: LD_VAR 0 6
92981: ST_TO_ADDR
// end ; end ;
92982: GO 92914
92984: POP
92985: POP
// end ;
92986: LD_VAR 0 3
92990: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
92991: LD_INT 0
92993: PPUSH
// uc_side := side ;
92994: LD_ADDR_OWVAR 20
92998: PUSH
92999: LD_VAR 0 1
93003: ST_TO_ADDR
// uc_nation := 3 ;
93004: LD_ADDR_OWVAR 21
93008: PUSH
93009: LD_INT 3
93011: ST_TO_ADDR
// vc_chassis := 25 ;
93012: LD_ADDR_OWVAR 37
93016: PUSH
93017: LD_INT 25
93019: ST_TO_ADDR
// vc_engine := engine_siberite ;
93020: LD_ADDR_OWVAR 39
93024: PUSH
93025: LD_INT 3
93027: ST_TO_ADDR
// vc_control := control_computer ;
93028: LD_ADDR_OWVAR 38
93032: PUSH
93033: LD_INT 3
93035: ST_TO_ADDR
// vc_weapon := 59 ;
93036: LD_ADDR_OWVAR 40
93040: PUSH
93041: LD_INT 59
93043: ST_TO_ADDR
// result := CreateVehicle ;
93044: LD_ADDR_VAR 0 5
93048: PUSH
93049: CALL_OW 45
93053: ST_TO_ADDR
// SetDir ( result , d ) ;
93054: LD_VAR 0 5
93058: PPUSH
93059: LD_VAR 0 4
93063: PPUSH
93064: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
93068: LD_VAR 0 5
93072: PPUSH
93073: LD_VAR 0 2
93077: PPUSH
93078: LD_VAR 0 3
93082: PPUSH
93083: LD_INT 0
93085: PPUSH
93086: CALL_OW 48
// end ;
93090: LD_VAR 0 5
93094: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
93095: LD_INT 0
93097: PPUSH
93098: PPUSH
93099: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
93100: LD_ADDR_VAR 0 2
93104: PUSH
93105: LD_INT 0
93107: PUSH
93108: LD_INT 0
93110: PUSH
93111: LD_INT 0
93113: PUSH
93114: LD_INT 0
93116: PUSH
93117: EMPTY
93118: LIST
93119: LIST
93120: LIST
93121: LIST
93122: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
93123: LD_VAR 0 1
93127: NOT
93128: PUSH
93129: LD_VAR 0 1
93133: PPUSH
93134: CALL_OW 264
93138: PUSH
93139: LD_INT 12
93141: PUSH
93142: LD_INT 51
93144: PUSH
93145: LD_INT 32
93147: PUSH
93148: LD_INT 89
93150: PUSH
93151: EMPTY
93152: LIST
93153: LIST
93154: LIST
93155: LIST
93156: IN
93157: NOT
93158: OR
93159: IFFALSE 93163
// exit ;
93161: GO 93261
// for i := 1 to 3 do
93163: LD_ADDR_VAR 0 3
93167: PUSH
93168: DOUBLE
93169: LD_INT 1
93171: DEC
93172: ST_TO_ADDR
93173: LD_INT 3
93175: PUSH
93176: FOR_TO
93177: IFFALSE 93259
// begin tmp := GetCargo ( cargo , i ) ;
93179: LD_ADDR_VAR 0 4
93183: PUSH
93184: LD_VAR 0 1
93188: PPUSH
93189: LD_VAR 0 3
93193: PPUSH
93194: CALL_OW 289
93198: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
93199: LD_ADDR_VAR 0 2
93203: PUSH
93204: LD_VAR 0 2
93208: PPUSH
93209: LD_VAR 0 3
93213: PPUSH
93214: LD_VAR 0 4
93218: PPUSH
93219: CALL_OW 1
93223: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
93224: LD_ADDR_VAR 0 2
93228: PUSH
93229: LD_VAR 0 2
93233: PPUSH
93234: LD_INT 4
93236: PPUSH
93237: LD_VAR 0 2
93241: PUSH
93242: LD_INT 4
93244: ARRAY
93245: PUSH
93246: LD_VAR 0 4
93250: PLUS
93251: PPUSH
93252: CALL_OW 1
93256: ST_TO_ADDR
// end ;
93257: GO 93176
93259: POP
93260: POP
// end ;
93261: LD_VAR 0 2
93265: RET
// export function Length ( array ) ; begin
93266: LD_INT 0
93268: PPUSH
// result := array + 0 ;
93269: LD_ADDR_VAR 0 2
93273: PUSH
93274: LD_VAR 0 1
93278: PUSH
93279: LD_INT 0
93281: PLUS
93282: ST_TO_ADDR
// end ;
93283: LD_VAR 0 2
93287: RET
// export function PrepareArray ( array ) ; begin
93288: LD_INT 0
93290: PPUSH
// result := array diff 0 ;
93291: LD_ADDR_VAR 0 2
93295: PUSH
93296: LD_VAR 0 1
93300: PUSH
93301: LD_INT 0
93303: DIFF
93304: ST_TO_ADDR
// if not result [ 1 ] then
93305: LD_VAR 0 2
93309: PUSH
93310: LD_INT 1
93312: ARRAY
93313: NOT
93314: IFFALSE 93334
// result := Delete ( result , 1 ) ;
93316: LD_ADDR_VAR 0 2
93320: PUSH
93321: LD_VAR 0 2
93325: PPUSH
93326: LD_INT 1
93328: PPUSH
93329: CALL_OW 3
93333: ST_TO_ADDR
// end ;
93334: LD_VAR 0 2
93338: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
93339: LD_INT 0
93341: PPUSH
93342: PPUSH
93343: PPUSH
93344: PPUSH
// sibRocketRange := 25 ;
93345: LD_ADDR_VAR 0 6
93349: PUSH
93350: LD_INT 25
93352: ST_TO_ADDR
// result := false ;
93353: LD_ADDR_VAR 0 4
93357: PUSH
93358: LD_INT 0
93360: ST_TO_ADDR
// for i := 0 to 5 do
93361: LD_ADDR_VAR 0 5
93365: PUSH
93366: DOUBLE
93367: LD_INT 0
93369: DEC
93370: ST_TO_ADDR
93371: LD_INT 5
93373: PUSH
93374: FOR_TO
93375: IFFALSE 93442
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
93377: LD_VAR 0 1
93381: PPUSH
93382: LD_VAR 0 5
93386: PPUSH
93387: LD_VAR 0 6
93391: PPUSH
93392: CALL_OW 272
93396: PPUSH
93397: LD_VAR 0 2
93401: PPUSH
93402: LD_VAR 0 5
93406: PPUSH
93407: LD_VAR 0 6
93411: PPUSH
93412: CALL_OW 273
93416: PPUSH
93417: LD_VAR 0 3
93421: PPUSH
93422: CALL_OW 309
93426: IFFALSE 93440
// begin result := true ;
93428: LD_ADDR_VAR 0 4
93432: PUSH
93433: LD_INT 1
93435: ST_TO_ADDR
// exit ;
93436: POP
93437: POP
93438: GO 93444
// end ;
93440: GO 93374
93442: POP
93443: POP
// end ;
93444: LD_VAR 0 4
93448: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
93449: LD_INT 0
93451: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
93452: LD_VAR 0 1
93456: PPUSH
93457: LD_VAR 0 2
93461: PPUSH
93462: LD_INT 0
93464: PPUSH
93465: LD_INT 0
93467: PPUSH
93468: LD_INT 1
93470: PPUSH
93471: LD_INT 0
93473: PPUSH
93474: CALL_OW 587
// end ; end_of_file end_of_file
93478: LD_VAR 0 3
93482: RET
// export globalGameSaveCounter ; every 0 0$1 do
93483: GO 93485
93485: DISABLE
// begin enable ;
93486: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
93487: LD_STRING updateTimer(
93489: PUSH
93490: LD_OWVAR 1
93494: STR
93495: PUSH
93496: LD_STRING );
93498: STR
93499: PPUSH
93500: CALL_OW 559
// end ;
93504: END
// every 0 0$1 do
93505: GO 93507
93507: DISABLE
// begin globalGameSaveCounter := 0 ;
93508: LD_ADDR_EXP 122
93512: PUSH
93513: LD_INT 0
93515: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
93516: LD_STRING setGameSaveCounter(0)
93518: PPUSH
93519: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
93523: LD_STRING initStreamRollete();
93525: PPUSH
93526: CALL_OW 559
// InitStreamMode ;
93530: CALL 94856 0 0
// DefineStreamItems ( false ) ;
93534: LD_INT 0
93536: PPUSH
93537: CALL 95320 0 1
// end ;
93541: END
// export function SOS_MapStart ( ) ; begin
93542: LD_INT 0
93544: PPUSH
// if streamModeActive then
93545: LD_EXP 123
93549: IFFALSE 93558
// DefineStreamItems ( true ) ;
93551: LD_INT 1
93553: PPUSH
93554: CALL 95320 0 1
// UpdateLuaVariables ( ) ;
93558: CALL 93575 0 0
// UpdateFactoryWaypoints ( ) ;
93562: CALL 108181 0 0
// UpdateWarehouseGatheringPoints ( ) ;
93566: CALL 108438 0 0
// end ;
93570: LD_VAR 0 1
93574: RET
// function UpdateLuaVariables ( ) ; begin
93575: LD_INT 0
93577: PPUSH
// if globalGameSaveCounter then
93578: LD_EXP 122
93582: IFFALSE 93616
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
93584: LD_ADDR_EXP 122
93588: PUSH
93589: LD_EXP 122
93593: PPUSH
93594: CALL 90891 0 1
93598: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
93599: LD_STRING setGameSaveCounter(
93601: PUSH
93602: LD_EXP 122
93606: STR
93607: PUSH
93608: LD_STRING )
93610: STR
93611: PPUSH
93612: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
93616: LD_STRING setGameDifficulty(
93618: PUSH
93619: LD_OWVAR 67
93623: STR
93624: PUSH
93625: LD_STRING )
93627: STR
93628: PPUSH
93629: CALL_OW 559
// end ;
93633: LD_VAR 0 1
93637: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
93638: LD_INT 0
93640: PPUSH
// if p2 = stream_mode then
93641: LD_VAR 0 2
93645: PUSH
93646: LD_INT 100
93648: EQUAL
93649: IFFALSE 94652
// begin if not StreamModeActive then
93651: LD_EXP 123
93655: NOT
93656: IFFALSE 93666
// StreamModeActive := true ;
93658: LD_ADDR_EXP 123
93662: PUSH
93663: LD_INT 1
93665: ST_TO_ADDR
// if p3 = 0 then
93666: LD_VAR 0 3
93670: PUSH
93671: LD_INT 0
93673: EQUAL
93674: IFFALSE 93680
// InitStreamMode ;
93676: CALL 94856 0 0
// if p3 = 1 then
93680: LD_VAR 0 3
93684: PUSH
93685: LD_INT 1
93687: EQUAL
93688: IFFALSE 93698
// sRocket := true ;
93690: LD_ADDR_EXP 128
93694: PUSH
93695: LD_INT 1
93697: ST_TO_ADDR
// if p3 = 2 then
93698: LD_VAR 0 3
93702: PUSH
93703: LD_INT 2
93705: EQUAL
93706: IFFALSE 93716
// sSpeed := true ;
93708: LD_ADDR_EXP 127
93712: PUSH
93713: LD_INT 1
93715: ST_TO_ADDR
// if p3 = 3 then
93716: LD_VAR 0 3
93720: PUSH
93721: LD_INT 3
93723: EQUAL
93724: IFFALSE 93734
// sEngine := true ;
93726: LD_ADDR_EXP 129
93730: PUSH
93731: LD_INT 1
93733: ST_TO_ADDR
// if p3 = 4 then
93734: LD_VAR 0 3
93738: PUSH
93739: LD_INT 4
93741: EQUAL
93742: IFFALSE 93752
// sSpec := true ;
93744: LD_ADDR_EXP 126
93748: PUSH
93749: LD_INT 1
93751: ST_TO_ADDR
// if p3 = 5 then
93752: LD_VAR 0 3
93756: PUSH
93757: LD_INT 5
93759: EQUAL
93760: IFFALSE 93770
// sLevel := true ;
93762: LD_ADDR_EXP 130
93766: PUSH
93767: LD_INT 1
93769: ST_TO_ADDR
// if p3 = 6 then
93770: LD_VAR 0 3
93774: PUSH
93775: LD_INT 6
93777: EQUAL
93778: IFFALSE 93788
// sArmoury := true ;
93780: LD_ADDR_EXP 131
93784: PUSH
93785: LD_INT 1
93787: ST_TO_ADDR
// if p3 = 7 then
93788: LD_VAR 0 3
93792: PUSH
93793: LD_INT 7
93795: EQUAL
93796: IFFALSE 93806
// sRadar := true ;
93798: LD_ADDR_EXP 132
93802: PUSH
93803: LD_INT 1
93805: ST_TO_ADDR
// if p3 = 8 then
93806: LD_VAR 0 3
93810: PUSH
93811: LD_INT 8
93813: EQUAL
93814: IFFALSE 93824
// sBunker := true ;
93816: LD_ADDR_EXP 133
93820: PUSH
93821: LD_INT 1
93823: ST_TO_ADDR
// if p3 = 9 then
93824: LD_VAR 0 3
93828: PUSH
93829: LD_INT 9
93831: EQUAL
93832: IFFALSE 93842
// sHack := true ;
93834: LD_ADDR_EXP 134
93838: PUSH
93839: LD_INT 1
93841: ST_TO_ADDR
// if p3 = 10 then
93842: LD_VAR 0 3
93846: PUSH
93847: LD_INT 10
93849: EQUAL
93850: IFFALSE 93860
// sFire := true ;
93852: LD_ADDR_EXP 135
93856: PUSH
93857: LD_INT 1
93859: ST_TO_ADDR
// if p3 = 11 then
93860: LD_VAR 0 3
93864: PUSH
93865: LD_INT 11
93867: EQUAL
93868: IFFALSE 93878
// sRefresh := true ;
93870: LD_ADDR_EXP 136
93874: PUSH
93875: LD_INT 1
93877: ST_TO_ADDR
// if p3 = 12 then
93878: LD_VAR 0 3
93882: PUSH
93883: LD_INT 12
93885: EQUAL
93886: IFFALSE 93896
// sExp := true ;
93888: LD_ADDR_EXP 137
93892: PUSH
93893: LD_INT 1
93895: ST_TO_ADDR
// if p3 = 13 then
93896: LD_VAR 0 3
93900: PUSH
93901: LD_INT 13
93903: EQUAL
93904: IFFALSE 93914
// sDepot := true ;
93906: LD_ADDR_EXP 138
93910: PUSH
93911: LD_INT 1
93913: ST_TO_ADDR
// if p3 = 14 then
93914: LD_VAR 0 3
93918: PUSH
93919: LD_INT 14
93921: EQUAL
93922: IFFALSE 93932
// sFlag := true ;
93924: LD_ADDR_EXP 139
93928: PUSH
93929: LD_INT 1
93931: ST_TO_ADDR
// if p3 = 15 then
93932: LD_VAR 0 3
93936: PUSH
93937: LD_INT 15
93939: EQUAL
93940: IFFALSE 93950
// sKamikadze := true ;
93942: LD_ADDR_EXP 147
93946: PUSH
93947: LD_INT 1
93949: ST_TO_ADDR
// if p3 = 16 then
93950: LD_VAR 0 3
93954: PUSH
93955: LD_INT 16
93957: EQUAL
93958: IFFALSE 93968
// sTroll := true ;
93960: LD_ADDR_EXP 148
93964: PUSH
93965: LD_INT 1
93967: ST_TO_ADDR
// if p3 = 17 then
93968: LD_VAR 0 3
93972: PUSH
93973: LD_INT 17
93975: EQUAL
93976: IFFALSE 93986
// sSlow := true ;
93978: LD_ADDR_EXP 149
93982: PUSH
93983: LD_INT 1
93985: ST_TO_ADDR
// if p3 = 18 then
93986: LD_VAR 0 3
93990: PUSH
93991: LD_INT 18
93993: EQUAL
93994: IFFALSE 94004
// sLack := true ;
93996: LD_ADDR_EXP 150
94000: PUSH
94001: LD_INT 1
94003: ST_TO_ADDR
// if p3 = 19 then
94004: LD_VAR 0 3
94008: PUSH
94009: LD_INT 19
94011: EQUAL
94012: IFFALSE 94022
// sTank := true ;
94014: LD_ADDR_EXP 152
94018: PUSH
94019: LD_INT 1
94021: ST_TO_ADDR
// if p3 = 20 then
94022: LD_VAR 0 3
94026: PUSH
94027: LD_INT 20
94029: EQUAL
94030: IFFALSE 94040
// sRemote := true ;
94032: LD_ADDR_EXP 153
94036: PUSH
94037: LD_INT 1
94039: ST_TO_ADDR
// if p3 = 21 then
94040: LD_VAR 0 3
94044: PUSH
94045: LD_INT 21
94047: EQUAL
94048: IFFALSE 94058
// sPowell := true ;
94050: LD_ADDR_EXP 154
94054: PUSH
94055: LD_INT 1
94057: ST_TO_ADDR
// if p3 = 22 then
94058: LD_VAR 0 3
94062: PUSH
94063: LD_INT 22
94065: EQUAL
94066: IFFALSE 94076
// sTeleport := true ;
94068: LD_ADDR_EXP 157
94072: PUSH
94073: LD_INT 1
94075: ST_TO_ADDR
// if p3 = 23 then
94076: LD_VAR 0 3
94080: PUSH
94081: LD_INT 23
94083: EQUAL
94084: IFFALSE 94094
// sOilTower := true ;
94086: LD_ADDR_EXP 159
94090: PUSH
94091: LD_INT 1
94093: ST_TO_ADDR
// if p3 = 24 then
94094: LD_VAR 0 3
94098: PUSH
94099: LD_INT 24
94101: EQUAL
94102: IFFALSE 94112
// sShovel := true ;
94104: LD_ADDR_EXP 160
94108: PUSH
94109: LD_INT 1
94111: ST_TO_ADDR
// if p3 = 25 then
94112: LD_VAR 0 3
94116: PUSH
94117: LD_INT 25
94119: EQUAL
94120: IFFALSE 94130
// sSheik := true ;
94122: LD_ADDR_EXP 161
94126: PUSH
94127: LD_INT 1
94129: ST_TO_ADDR
// if p3 = 26 then
94130: LD_VAR 0 3
94134: PUSH
94135: LD_INT 26
94137: EQUAL
94138: IFFALSE 94148
// sEarthquake := true ;
94140: LD_ADDR_EXP 163
94144: PUSH
94145: LD_INT 1
94147: ST_TO_ADDR
// if p3 = 27 then
94148: LD_VAR 0 3
94152: PUSH
94153: LD_INT 27
94155: EQUAL
94156: IFFALSE 94166
// sAI := true ;
94158: LD_ADDR_EXP 164
94162: PUSH
94163: LD_INT 1
94165: ST_TO_ADDR
// if p3 = 28 then
94166: LD_VAR 0 3
94170: PUSH
94171: LD_INT 28
94173: EQUAL
94174: IFFALSE 94184
// sCargo := true ;
94176: LD_ADDR_EXP 167
94180: PUSH
94181: LD_INT 1
94183: ST_TO_ADDR
// if p3 = 29 then
94184: LD_VAR 0 3
94188: PUSH
94189: LD_INT 29
94191: EQUAL
94192: IFFALSE 94202
// sDLaser := true ;
94194: LD_ADDR_EXP 168
94198: PUSH
94199: LD_INT 1
94201: ST_TO_ADDR
// if p3 = 30 then
94202: LD_VAR 0 3
94206: PUSH
94207: LD_INT 30
94209: EQUAL
94210: IFFALSE 94220
// sExchange := true ;
94212: LD_ADDR_EXP 169
94216: PUSH
94217: LD_INT 1
94219: ST_TO_ADDR
// if p3 = 31 then
94220: LD_VAR 0 3
94224: PUSH
94225: LD_INT 31
94227: EQUAL
94228: IFFALSE 94238
// sFac := true ;
94230: LD_ADDR_EXP 170
94234: PUSH
94235: LD_INT 1
94237: ST_TO_ADDR
// if p3 = 32 then
94238: LD_VAR 0 3
94242: PUSH
94243: LD_INT 32
94245: EQUAL
94246: IFFALSE 94256
// sPower := true ;
94248: LD_ADDR_EXP 171
94252: PUSH
94253: LD_INT 1
94255: ST_TO_ADDR
// if p3 = 33 then
94256: LD_VAR 0 3
94260: PUSH
94261: LD_INT 33
94263: EQUAL
94264: IFFALSE 94274
// sRandom := true ;
94266: LD_ADDR_EXP 172
94270: PUSH
94271: LD_INT 1
94273: ST_TO_ADDR
// if p3 = 34 then
94274: LD_VAR 0 3
94278: PUSH
94279: LD_INT 34
94281: EQUAL
94282: IFFALSE 94292
// sShield := true ;
94284: LD_ADDR_EXP 173
94288: PUSH
94289: LD_INT 1
94291: ST_TO_ADDR
// if p3 = 35 then
94292: LD_VAR 0 3
94296: PUSH
94297: LD_INT 35
94299: EQUAL
94300: IFFALSE 94310
// sTime := true ;
94302: LD_ADDR_EXP 174
94306: PUSH
94307: LD_INT 1
94309: ST_TO_ADDR
// if p3 = 36 then
94310: LD_VAR 0 3
94314: PUSH
94315: LD_INT 36
94317: EQUAL
94318: IFFALSE 94328
// sTools := true ;
94320: LD_ADDR_EXP 175
94324: PUSH
94325: LD_INT 1
94327: ST_TO_ADDR
// if p3 = 101 then
94328: LD_VAR 0 3
94332: PUSH
94333: LD_INT 101
94335: EQUAL
94336: IFFALSE 94346
// sSold := true ;
94338: LD_ADDR_EXP 140
94342: PUSH
94343: LD_INT 1
94345: ST_TO_ADDR
// if p3 = 102 then
94346: LD_VAR 0 3
94350: PUSH
94351: LD_INT 102
94353: EQUAL
94354: IFFALSE 94364
// sDiff := true ;
94356: LD_ADDR_EXP 141
94360: PUSH
94361: LD_INT 1
94363: ST_TO_ADDR
// if p3 = 103 then
94364: LD_VAR 0 3
94368: PUSH
94369: LD_INT 103
94371: EQUAL
94372: IFFALSE 94382
// sFog := true ;
94374: LD_ADDR_EXP 144
94378: PUSH
94379: LD_INT 1
94381: ST_TO_ADDR
// if p3 = 104 then
94382: LD_VAR 0 3
94386: PUSH
94387: LD_INT 104
94389: EQUAL
94390: IFFALSE 94400
// sReset := true ;
94392: LD_ADDR_EXP 145
94396: PUSH
94397: LD_INT 1
94399: ST_TO_ADDR
// if p3 = 105 then
94400: LD_VAR 0 3
94404: PUSH
94405: LD_INT 105
94407: EQUAL
94408: IFFALSE 94418
// sSun := true ;
94410: LD_ADDR_EXP 146
94414: PUSH
94415: LD_INT 1
94417: ST_TO_ADDR
// if p3 = 106 then
94418: LD_VAR 0 3
94422: PUSH
94423: LD_INT 106
94425: EQUAL
94426: IFFALSE 94436
// sTiger := true ;
94428: LD_ADDR_EXP 142
94432: PUSH
94433: LD_INT 1
94435: ST_TO_ADDR
// if p3 = 107 then
94436: LD_VAR 0 3
94440: PUSH
94441: LD_INT 107
94443: EQUAL
94444: IFFALSE 94454
// sBomb := true ;
94446: LD_ADDR_EXP 143
94450: PUSH
94451: LD_INT 1
94453: ST_TO_ADDR
// if p3 = 108 then
94454: LD_VAR 0 3
94458: PUSH
94459: LD_INT 108
94461: EQUAL
94462: IFFALSE 94472
// sWound := true ;
94464: LD_ADDR_EXP 151
94468: PUSH
94469: LD_INT 1
94471: ST_TO_ADDR
// if p3 = 109 then
94472: LD_VAR 0 3
94476: PUSH
94477: LD_INT 109
94479: EQUAL
94480: IFFALSE 94490
// sBetray := true ;
94482: LD_ADDR_EXP 155
94486: PUSH
94487: LD_INT 1
94489: ST_TO_ADDR
// if p3 = 110 then
94490: LD_VAR 0 3
94494: PUSH
94495: LD_INT 110
94497: EQUAL
94498: IFFALSE 94508
// sContamin := true ;
94500: LD_ADDR_EXP 156
94504: PUSH
94505: LD_INT 1
94507: ST_TO_ADDR
// if p3 = 111 then
94508: LD_VAR 0 3
94512: PUSH
94513: LD_INT 111
94515: EQUAL
94516: IFFALSE 94526
// sOil := true ;
94518: LD_ADDR_EXP 158
94522: PUSH
94523: LD_INT 1
94525: ST_TO_ADDR
// if p3 = 112 then
94526: LD_VAR 0 3
94530: PUSH
94531: LD_INT 112
94533: EQUAL
94534: IFFALSE 94544
// sStu := true ;
94536: LD_ADDR_EXP 162
94540: PUSH
94541: LD_INT 1
94543: ST_TO_ADDR
// if p3 = 113 then
94544: LD_VAR 0 3
94548: PUSH
94549: LD_INT 113
94551: EQUAL
94552: IFFALSE 94562
// sBazooka := true ;
94554: LD_ADDR_EXP 165
94558: PUSH
94559: LD_INT 1
94561: ST_TO_ADDR
// if p3 = 114 then
94562: LD_VAR 0 3
94566: PUSH
94567: LD_INT 114
94569: EQUAL
94570: IFFALSE 94580
// sMortar := true ;
94572: LD_ADDR_EXP 166
94576: PUSH
94577: LD_INT 1
94579: ST_TO_ADDR
// if p3 = 115 then
94580: LD_VAR 0 3
94584: PUSH
94585: LD_INT 115
94587: EQUAL
94588: IFFALSE 94598
// sRanger := true ;
94590: LD_ADDR_EXP 176
94594: PUSH
94595: LD_INT 1
94597: ST_TO_ADDR
// if p3 = 116 then
94598: LD_VAR 0 3
94602: PUSH
94603: LD_INT 116
94605: EQUAL
94606: IFFALSE 94616
// sComputer := true ;
94608: LD_ADDR_EXP 177
94612: PUSH
94613: LD_INT 1
94615: ST_TO_ADDR
// if p3 = 117 then
94616: LD_VAR 0 3
94620: PUSH
94621: LD_INT 117
94623: EQUAL
94624: IFFALSE 94634
// s30 := true ;
94626: LD_ADDR_EXP 178
94630: PUSH
94631: LD_INT 1
94633: ST_TO_ADDR
// if p3 = 118 then
94634: LD_VAR 0 3
94638: PUSH
94639: LD_INT 118
94641: EQUAL
94642: IFFALSE 94652
// s60 := true ;
94644: LD_ADDR_EXP 179
94648: PUSH
94649: LD_INT 1
94651: ST_TO_ADDR
// end ; if p2 = hack_mode then
94652: LD_VAR 0 2
94656: PUSH
94657: LD_INT 101
94659: EQUAL
94660: IFFALSE 94788
// begin case p3 of 1 :
94662: LD_VAR 0 3
94666: PUSH
94667: LD_INT 1
94669: DOUBLE
94670: EQUAL
94671: IFTRUE 94675
94673: GO 94682
94675: POP
// hHackUnlimitedResources ; 2 :
94676: CALL 106927 0 0
94680: GO 94788
94682: LD_INT 2
94684: DOUBLE
94685: EQUAL
94686: IFTRUE 94690
94688: GO 94697
94690: POP
// hHackSetLevel10 ; 3 :
94691: CALL 107060 0 0
94695: GO 94788
94697: LD_INT 3
94699: DOUBLE
94700: EQUAL
94701: IFTRUE 94705
94703: GO 94712
94705: POP
// hHackSetLevel10YourUnits ; 4 :
94706: CALL 107145 0 0
94710: GO 94788
94712: LD_INT 4
94714: DOUBLE
94715: EQUAL
94716: IFTRUE 94720
94718: GO 94727
94720: POP
// hHackInvincible ; 5 :
94721: CALL 107593 0 0
94725: GO 94788
94727: LD_INT 5
94729: DOUBLE
94730: EQUAL
94731: IFTRUE 94735
94733: GO 94742
94735: POP
// hHackInvisible ; 6 :
94736: CALL 107704 0 0
94740: GO 94788
94742: LD_INT 6
94744: DOUBLE
94745: EQUAL
94746: IFTRUE 94750
94748: GO 94757
94750: POP
// hHackChangeYourSide ; 7 :
94751: CALL 107761 0 0
94755: GO 94788
94757: LD_INT 7
94759: DOUBLE
94760: EQUAL
94761: IFTRUE 94765
94763: GO 94772
94765: POP
// hHackChangeUnitSide ; 8 :
94766: CALL 107803 0 0
94770: GO 94788
94772: LD_INT 8
94774: DOUBLE
94775: EQUAL
94776: IFTRUE 94780
94778: GO 94787
94780: POP
// hHackFog ; end ;
94781: CALL 107904 0 0
94785: GO 94788
94787: POP
// end ; if p2 = game_save_mode then
94788: LD_VAR 0 2
94792: PUSH
94793: LD_INT 102
94795: EQUAL
94796: IFFALSE 94851
// begin if p3 = 1 then
94798: LD_VAR 0 3
94802: PUSH
94803: LD_INT 1
94805: EQUAL
94806: IFFALSE 94818
// globalGameSaveCounter := p4 ;
94808: LD_ADDR_EXP 122
94812: PUSH
94813: LD_VAR 0 4
94817: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
94818: LD_VAR 0 3
94822: PUSH
94823: LD_INT 2
94825: EQUAL
94826: PUSH
94827: LD_EXP 122
94831: AND
94832: IFFALSE 94851
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
94834: LD_STRING setGameSaveCounter(
94836: PUSH
94837: LD_EXP 122
94841: STR
94842: PUSH
94843: LD_STRING )
94845: STR
94846: PPUSH
94847: CALL_OW 559
// end ; end ;
94851: LD_VAR 0 7
94855: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
94856: LD_INT 0
94858: PPUSH
// streamModeActive := false ;
94859: LD_ADDR_EXP 123
94863: PUSH
94864: LD_INT 0
94866: ST_TO_ADDR
// normalCounter := 36 ;
94867: LD_ADDR_EXP 124
94871: PUSH
94872: LD_INT 36
94874: ST_TO_ADDR
// hardcoreCounter := 18 ;
94875: LD_ADDR_EXP 125
94879: PUSH
94880: LD_INT 18
94882: ST_TO_ADDR
// sRocket := false ;
94883: LD_ADDR_EXP 128
94887: PUSH
94888: LD_INT 0
94890: ST_TO_ADDR
// sSpeed := false ;
94891: LD_ADDR_EXP 127
94895: PUSH
94896: LD_INT 0
94898: ST_TO_ADDR
// sEngine := false ;
94899: LD_ADDR_EXP 129
94903: PUSH
94904: LD_INT 0
94906: ST_TO_ADDR
// sSpec := false ;
94907: LD_ADDR_EXP 126
94911: PUSH
94912: LD_INT 0
94914: ST_TO_ADDR
// sLevel := false ;
94915: LD_ADDR_EXP 130
94919: PUSH
94920: LD_INT 0
94922: ST_TO_ADDR
// sArmoury := false ;
94923: LD_ADDR_EXP 131
94927: PUSH
94928: LD_INT 0
94930: ST_TO_ADDR
// sRadar := false ;
94931: LD_ADDR_EXP 132
94935: PUSH
94936: LD_INT 0
94938: ST_TO_ADDR
// sBunker := false ;
94939: LD_ADDR_EXP 133
94943: PUSH
94944: LD_INT 0
94946: ST_TO_ADDR
// sHack := false ;
94947: LD_ADDR_EXP 134
94951: PUSH
94952: LD_INT 0
94954: ST_TO_ADDR
// sFire := false ;
94955: LD_ADDR_EXP 135
94959: PUSH
94960: LD_INT 0
94962: ST_TO_ADDR
// sRefresh := false ;
94963: LD_ADDR_EXP 136
94967: PUSH
94968: LD_INT 0
94970: ST_TO_ADDR
// sExp := false ;
94971: LD_ADDR_EXP 137
94975: PUSH
94976: LD_INT 0
94978: ST_TO_ADDR
// sDepot := false ;
94979: LD_ADDR_EXP 138
94983: PUSH
94984: LD_INT 0
94986: ST_TO_ADDR
// sFlag := false ;
94987: LD_ADDR_EXP 139
94991: PUSH
94992: LD_INT 0
94994: ST_TO_ADDR
// sKamikadze := false ;
94995: LD_ADDR_EXP 147
94999: PUSH
95000: LD_INT 0
95002: ST_TO_ADDR
// sTroll := false ;
95003: LD_ADDR_EXP 148
95007: PUSH
95008: LD_INT 0
95010: ST_TO_ADDR
// sSlow := false ;
95011: LD_ADDR_EXP 149
95015: PUSH
95016: LD_INT 0
95018: ST_TO_ADDR
// sLack := false ;
95019: LD_ADDR_EXP 150
95023: PUSH
95024: LD_INT 0
95026: ST_TO_ADDR
// sTank := false ;
95027: LD_ADDR_EXP 152
95031: PUSH
95032: LD_INT 0
95034: ST_TO_ADDR
// sRemote := false ;
95035: LD_ADDR_EXP 153
95039: PUSH
95040: LD_INT 0
95042: ST_TO_ADDR
// sPowell := false ;
95043: LD_ADDR_EXP 154
95047: PUSH
95048: LD_INT 0
95050: ST_TO_ADDR
// sTeleport := false ;
95051: LD_ADDR_EXP 157
95055: PUSH
95056: LD_INT 0
95058: ST_TO_ADDR
// sOilTower := false ;
95059: LD_ADDR_EXP 159
95063: PUSH
95064: LD_INT 0
95066: ST_TO_ADDR
// sShovel := false ;
95067: LD_ADDR_EXP 160
95071: PUSH
95072: LD_INT 0
95074: ST_TO_ADDR
// sSheik := false ;
95075: LD_ADDR_EXP 161
95079: PUSH
95080: LD_INT 0
95082: ST_TO_ADDR
// sEarthquake := false ;
95083: LD_ADDR_EXP 163
95087: PUSH
95088: LD_INT 0
95090: ST_TO_ADDR
// sAI := false ;
95091: LD_ADDR_EXP 164
95095: PUSH
95096: LD_INT 0
95098: ST_TO_ADDR
// sCargo := false ;
95099: LD_ADDR_EXP 167
95103: PUSH
95104: LD_INT 0
95106: ST_TO_ADDR
// sDLaser := false ;
95107: LD_ADDR_EXP 168
95111: PUSH
95112: LD_INT 0
95114: ST_TO_ADDR
// sExchange := false ;
95115: LD_ADDR_EXP 169
95119: PUSH
95120: LD_INT 0
95122: ST_TO_ADDR
// sFac := false ;
95123: LD_ADDR_EXP 170
95127: PUSH
95128: LD_INT 0
95130: ST_TO_ADDR
// sPower := false ;
95131: LD_ADDR_EXP 171
95135: PUSH
95136: LD_INT 0
95138: ST_TO_ADDR
// sRandom := false ;
95139: LD_ADDR_EXP 172
95143: PUSH
95144: LD_INT 0
95146: ST_TO_ADDR
// sShield := false ;
95147: LD_ADDR_EXP 173
95151: PUSH
95152: LD_INT 0
95154: ST_TO_ADDR
// sTime := false ;
95155: LD_ADDR_EXP 174
95159: PUSH
95160: LD_INT 0
95162: ST_TO_ADDR
// sTools := false ;
95163: LD_ADDR_EXP 175
95167: PUSH
95168: LD_INT 0
95170: ST_TO_ADDR
// sSold := false ;
95171: LD_ADDR_EXP 140
95175: PUSH
95176: LD_INT 0
95178: ST_TO_ADDR
// sDiff := false ;
95179: LD_ADDR_EXP 141
95183: PUSH
95184: LD_INT 0
95186: ST_TO_ADDR
// sFog := false ;
95187: LD_ADDR_EXP 144
95191: PUSH
95192: LD_INT 0
95194: ST_TO_ADDR
// sReset := false ;
95195: LD_ADDR_EXP 145
95199: PUSH
95200: LD_INT 0
95202: ST_TO_ADDR
// sSun := false ;
95203: LD_ADDR_EXP 146
95207: PUSH
95208: LD_INT 0
95210: ST_TO_ADDR
// sTiger := false ;
95211: LD_ADDR_EXP 142
95215: PUSH
95216: LD_INT 0
95218: ST_TO_ADDR
// sBomb := false ;
95219: LD_ADDR_EXP 143
95223: PUSH
95224: LD_INT 0
95226: ST_TO_ADDR
// sWound := false ;
95227: LD_ADDR_EXP 151
95231: PUSH
95232: LD_INT 0
95234: ST_TO_ADDR
// sBetray := false ;
95235: LD_ADDR_EXP 155
95239: PUSH
95240: LD_INT 0
95242: ST_TO_ADDR
// sContamin := false ;
95243: LD_ADDR_EXP 156
95247: PUSH
95248: LD_INT 0
95250: ST_TO_ADDR
// sOil := false ;
95251: LD_ADDR_EXP 158
95255: PUSH
95256: LD_INT 0
95258: ST_TO_ADDR
// sStu := false ;
95259: LD_ADDR_EXP 162
95263: PUSH
95264: LD_INT 0
95266: ST_TO_ADDR
// sBazooka := false ;
95267: LD_ADDR_EXP 165
95271: PUSH
95272: LD_INT 0
95274: ST_TO_ADDR
// sMortar := false ;
95275: LD_ADDR_EXP 166
95279: PUSH
95280: LD_INT 0
95282: ST_TO_ADDR
// sRanger := false ;
95283: LD_ADDR_EXP 176
95287: PUSH
95288: LD_INT 0
95290: ST_TO_ADDR
// sComputer := false ;
95291: LD_ADDR_EXP 177
95295: PUSH
95296: LD_INT 0
95298: ST_TO_ADDR
// s30 := false ;
95299: LD_ADDR_EXP 178
95303: PUSH
95304: LD_INT 0
95306: ST_TO_ADDR
// s60 := false ;
95307: LD_ADDR_EXP 179
95311: PUSH
95312: LD_INT 0
95314: ST_TO_ADDR
// end ;
95315: LD_VAR 0 1
95319: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
95320: LD_INT 0
95322: PPUSH
95323: PPUSH
95324: PPUSH
95325: PPUSH
95326: PPUSH
95327: PPUSH
95328: PPUSH
// result := [ ] ;
95329: LD_ADDR_VAR 0 2
95333: PUSH
95334: EMPTY
95335: ST_TO_ADDR
// if campaign_id = 1 then
95336: LD_OWVAR 69
95340: PUSH
95341: LD_INT 1
95343: EQUAL
95344: IFFALSE 98510
// begin case mission_number of 1 :
95346: LD_OWVAR 70
95350: PUSH
95351: LD_INT 1
95353: DOUBLE
95354: EQUAL
95355: IFTRUE 95359
95357: GO 95435
95359: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
95360: LD_ADDR_VAR 0 2
95364: PUSH
95365: LD_INT 2
95367: PUSH
95368: LD_INT 4
95370: PUSH
95371: LD_INT 11
95373: PUSH
95374: LD_INT 12
95376: PUSH
95377: LD_INT 15
95379: PUSH
95380: LD_INT 16
95382: PUSH
95383: LD_INT 22
95385: PUSH
95386: LD_INT 23
95388: PUSH
95389: LD_INT 26
95391: PUSH
95392: EMPTY
95393: LIST
95394: LIST
95395: LIST
95396: LIST
95397: LIST
95398: LIST
95399: LIST
95400: LIST
95401: LIST
95402: PUSH
95403: LD_INT 101
95405: PUSH
95406: LD_INT 102
95408: PUSH
95409: LD_INT 106
95411: PUSH
95412: LD_INT 116
95414: PUSH
95415: LD_INT 117
95417: PUSH
95418: LD_INT 118
95420: PUSH
95421: EMPTY
95422: LIST
95423: LIST
95424: LIST
95425: LIST
95426: LIST
95427: LIST
95428: PUSH
95429: EMPTY
95430: LIST
95431: LIST
95432: ST_TO_ADDR
95433: GO 98508
95435: LD_INT 2
95437: DOUBLE
95438: EQUAL
95439: IFTRUE 95443
95441: GO 95527
95443: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
95444: LD_ADDR_VAR 0 2
95448: PUSH
95449: LD_INT 2
95451: PUSH
95452: LD_INT 4
95454: PUSH
95455: LD_INT 11
95457: PUSH
95458: LD_INT 12
95460: PUSH
95461: LD_INT 15
95463: PUSH
95464: LD_INT 16
95466: PUSH
95467: LD_INT 22
95469: PUSH
95470: LD_INT 23
95472: PUSH
95473: LD_INT 26
95475: PUSH
95476: EMPTY
95477: LIST
95478: LIST
95479: LIST
95480: LIST
95481: LIST
95482: LIST
95483: LIST
95484: LIST
95485: LIST
95486: PUSH
95487: LD_INT 101
95489: PUSH
95490: LD_INT 102
95492: PUSH
95493: LD_INT 105
95495: PUSH
95496: LD_INT 106
95498: PUSH
95499: LD_INT 108
95501: PUSH
95502: LD_INT 116
95504: PUSH
95505: LD_INT 117
95507: PUSH
95508: LD_INT 118
95510: PUSH
95511: EMPTY
95512: LIST
95513: LIST
95514: LIST
95515: LIST
95516: LIST
95517: LIST
95518: LIST
95519: LIST
95520: PUSH
95521: EMPTY
95522: LIST
95523: LIST
95524: ST_TO_ADDR
95525: GO 98508
95527: LD_INT 3
95529: DOUBLE
95530: EQUAL
95531: IFTRUE 95535
95533: GO 95623
95535: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
95536: LD_ADDR_VAR 0 2
95540: PUSH
95541: LD_INT 2
95543: PUSH
95544: LD_INT 4
95546: PUSH
95547: LD_INT 5
95549: PUSH
95550: LD_INT 11
95552: PUSH
95553: LD_INT 12
95555: PUSH
95556: LD_INT 15
95558: PUSH
95559: LD_INT 16
95561: PUSH
95562: LD_INT 22
95564: PUSH
95565: LD_INT 26
95567: PUSH
95568: LD_INT 36
95570: PUSH
95571: EMPTY
95572: LIST
95573: LIST
95574: LIST
95575: LIST
95576: LIST
95577: LIST
95578: LIST
95579: LIST
95580: LIST
95581: LIST
95582: PUSH
95583: LD_INT 101
95585: PUSH
95586: LD_INT 102
95588: PUSH
95589: LD_INT 105
95591: PUSH
95592: LD_INT 106
95594: PUSH
95595: LD_INT 108
95597: PUSH
95598: LD_INT 116
95600: PUSH
95601: LD_INT 117
95603: PUSH
95604: LD_INT 118
95606: PUSH
95607: EMPTY
95608: LIST
95609: LIST
95610: LIST
95611: LIST
95612: LIST
95613: LIST
95614: LIST
95615: LIST
95616: PUSH
95617: EMPTY
95618: LIST
95619: LIST
95620: ST_TO_ADDR
95621: GO 98508
95623: LD_INT 4
95625: DOUBLE
95626: EQUAL
95627: IFTRUE 95631
95629: GO 95727
95631: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
95632: LD_ADDR_VAR 0 2
95636: PUSH
95637: LD_INT 2
95639: PUSH
95640: LD_INT 4
95642: PUSH
95643: LD_INT 5
95645: PUSH
95646: LD_INT 8
95648: PUSH
95649: LD_INT 11
95651: PUSH
95652: LD_INT 12
95654: PUSH
95655: LD_INT 15
95657: PUSH
95658: LD_INT 16
95660: PUSH
95661: LD_INT 22
95663: PUSH
95664: LD_INT 23
95666: PUSH
95667: LD_INT 26
95669: PUSH
95670: LD_INT 36
95672: PUSH
95673: EMPTY
95674: LIST
95675: LIST
95676: LIST
95677: LIST
95678: LIST
95679: LIST
95680: LIST
95681: LIST
95682: LIST
95683: LIST
95684: LIST
95685: LIST
95686: PUSH
95687: LD_INT 101
95689: PUSH
95690: LD_INT 102
95692: PUSH
95693: LD_INT 105
95695: PUSH
95696: LD_INT 106
95698: PUSH
95699: LD_INT 108
95701: PUSH
95702: LD_INT 116
95704: PUSH
95705: LD_INT 117
95707: PUSH
95708: LD_INT 118
95710: PUSH
95711: EMPTY
95712: LIST
95713: LIST
95714: LIST
95715: LIST
95716: LIST
95717: LIST
95718: LIST
95719: LIST
95720: PUSH
95721: EMPTY
95722: LIST
95723: LIST
95724: ST_TO_ADDR
95725: GO 98508
95727: LD_INT 5
95729: DOUBLE
95730: EQUAL
95731: IFTRUE 95735
95733: GO 95847
95735: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
95736: LD_ADDR_VAR 0 2
95740: PUSH
95741: LD_INT 2
95743: PUSH
95744: LD_INT 4
95746: PUSH
95747: LD_INT 5
95749: PUSH
95750: LD_INT 6
95752: PUSH
95753: LD_INT 8
95755: PUSH
95756: LD_INT 11
95758: PUSH
95759: LD_INT 12
95761: PUSH
95762: LD_INT 15
95764: PUSH
95765: LD_INT 16
95767: PUSH
95768: LD_INT 22
95770: PUSH
95771: LD_INT 23
95773: PUSH
95774: LD_INT 25
95776: PUSH
95777: LD_INT 26
95779: PUSH
95780: LD_INT 36
95782: PUSH
95783: EMPTY
95784: LIST
95785: LIST
95786: LIST
95787: LIST
95788: LIST
95789: LIST
95790: LIST
95791: LIST
95792: LIST
95793: LIST
95794: LIST
95795: LIST
95796: LIST
95797: LIST
95798: PUSH
95799: LD_INT 101
95801: PUSH
95802: LD_INT 102
95804: PUSH
95805: LD_INT 105
95807: PUSH
95808: LD_INT 106
95810: PUSH
95811: LD_INT 108
95813: PUSH
95814: LD_INT 109
95816: PUSH
95817: LD_INT 112
95819: PUSH
95820: LD_INT 116
95822: PUSH
95823: LD_INT 117
95825: PUSH
95826: LD_INT 118
95828: PUSH
95829: EMPTY
95830: LIST
95831: LIST
95832: LIST
95833: LIST
95834: LIST
95835: LIST
95836: LIST
95837: LIST
95838: LIST
95839: LIST
95840: PUSH
95841: EMPTY
95842: LIST
95843: LIST
95844: ST_TO_ADDR
95845: GO 98508
95847: LD_INT 6
95849: DOUBLE
95850: EQUAL
95851: IFTRUE 95855
95853: GO 95987
95855: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
95856: LD_ADDR_VAR 0 2
95860: PUSH
95861: LD_INT 2
95863: PUSH
95864: LD_INT 4
95866: PUSH
95867: LD_INT 5
95869: PUSH
95870: LD_INT 6
95872: PUSH
95873: LD_INT 8
95875: PUSH
95876: LD_INT 11
95878: PUSH
95879: LD_INT 12
95881: PUSH
95882: LD_INT 15
95884: PUSH
95885: LD_INT 16
95887: PUSH
95888: LD_INT 20
95890: PUSH
95891: LD_INT 21
95893: PUSH
95894: LD_INT 22
95896: PUSH
95897: LD_INT 23
95899: PUSH
95900: LD_INT 25
95902: PUSH
95903: LD_INT 26
95905: PUSH
95906: LD_INT 30
95908: PUSH
95909: LD_INT 31
95911: PUSH
95912: LD_INT 32
95914: PUSH
95915: LD_INT 36
95917: PUSH
95918: EMPTY
95919: LIST
95920: LIST
95921: LIST
95922: LIST
95923: LIST
95924: LIST
95925: LIST
95926: LIST
95927: LIST
95928: LIST
95929: LIST
95930: LIST
95931: LIST
95932: LIST
95933: LIST
95934: LIST
95935: LIST
95936: LIST
95937: LIST
95938: PUSH
95939: LD_INT 101
95941: PUSH
95942: LD_INT 102
95944: PUSH
95945: LD_INT 105
95947: PUSH
95948: LD_INT 106
95950: PUSH
95951: LD_INT 108
95953: PUSH
95954: LD_INT 109
95956: PUSH
95957: LD_INT 112
95959: PUSH
95960: LD_INT 116
95962: PUSH
95963: LD_INT 117
95965: PUSH
95966: LD_INT 118
95968: PUSH
95969: EMPTY
95970: LIST
95971: LIST
95972: LIST
95973: LIST
95974: LIST
95975: LIST
95976: LIST
95977: LIST
95978: LIST
95979: LIST
95980: PUSH
95981: EMPTY
95982: LIST
95983: LIST
95984: ST_TO_ADDR
95985: GO 98508
95987: LD_INT 7
95989: DOUBLE
95990: EQUAL
95991: IFTRUE 95995
95993: GO 96107
95995: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
95996: LD_ADDR_VAR 0 2
96000: PUSH
96001: LD_INT 2
96003: PUSH
96004: LD_INT 4
96006: PUSH
96007: LD_INT 5
96009: PUSH
96010: LD_INT 7
96012: PUSH
96013: LD_INT 11
96015: PUSH
96016: LD_INT 12
96018: PUSH
96019: LD_INT 15
96021: PUSH
96022: LD_INT 16
96024: PUSH
96025: LD_INT 20
96027: PUSH
96028: LD_INT 21
96030: PUSH
96031: LD_INT 22
96033: PUSH
96034: LD_INT 23
96036: PUSH
96037: LD_INT 25
96039: PUSH
96040: LD_INT 26
96042: PUSH
96043: EMPTY
96044: LIST
96045: LIST
96046: LIST
96047: LIST
96048: LIST
96049: LIST
96050: LIST
96051: LIST
96052: LIST
96053: LIST
96054: LIST
96055: LIST
96056: LIST
96057: LIST
96058: PUSH
96059: LD_INT 101
96061: PUSH
96062: LD_INT 102
96064: PUSH
96065: LD_INT 103
96067: PUSH
96068: LD_INT 105
96070: PUSH
96071: LD_INT 106
96073: PUSH
96074: LD_INT 108
96076: PUSH
96077: LD_INT 112
96079: PUSH
96080: LD_INT 116
96082: PUSH
96083: LD_INT 117
96085: PUSH
96086: LD_INT 118
96088: PUSH
96089: EMPTY
96090: LIST
96091: LIST
96092: LIST
96093: LIST
96094: LIST
96095: LIST
96096: LIST
96097: LIST
96098: LIST
96099: LIST
96100: PUSH
96101: EMPTY
96102: LIST
96103: LIST
96104: ST_TO_ADDR
96105: GO 98508
96107: LD_INT 8
96109: DOUBLE
96110: EQUAL
96111: IFTRUE 96115
96113: GO 96255
96115: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
96116: LD_ADDR_VAR 0 2
96120: PUSH
96121: LD_INT 2
96123: PUSH
96124: LD_INT 4
96126: PUSH
96127: LD_INT 5
96129: PUSH
96130: LD_INT 6
96132: PUSH
96133: LD_INT 7
96135: PUSH
96136: LD_INT 8
96138: PUSH
96139: LD_INT 11
96141: PUSH
96142: LD_INT 12
96144: PUSH
96145: LD_INT 15
96147: PUSH
96148: LD_INT 16
96150: PUSH
96151: LD_INT 20
96153: PUSH
96154: LD_INT 21
96156: PUSH
96157: LD_INT 22
96159: PUSH
96160: LD_INT 23
96162: PUSH
96163: LD_INT 25
96165: PUSH
96166: LD_INT 26
96168: PUSH
96169: LD_INT 30
96171: PUSH
96172: LD_INT 31
96174: PUSH
96175: LD_INT 32
96177: PUSH
96178: LD_INT 36
96180: PUSH
96181: EMPTY
96182: LIST
96183: LIST
96184: LIST
96185: LIST
96186: LIST
96187: LIST
96188: LIST
96189: LIST
96190: LIST
96191: LIST
96192: LIST
96193: LIST
96194: LIST
96195: LIST
96196: LIST
96197: LIST
96198: LIST
96199: LIST
96200: LIST
96201: LIST
96202: PUSH
96203: LD_INT 101
96205: PUSH
96206: LD_INT 102
96208: PUSH
96209: LD_INT 103
96211: PUSH
96212: LD_INT 105
96214: PUSH
96215: LD_INT 106
96217: PUSH
96218: LD_INT 108
96220: PUSH
96221: LD_INT 109
96223: PUSH
96224: LD_INT 112
96226: PUSH
96227: LD_INT 116
96229: PUSH
96230: LD_INT 117
96232: PUSH
96233: LD_INT 118
96235: PUSH
96236: EMPTY
96237: LIST
96238: LIST
96239: LIST
96240: LIST
96241: LIST
96242: LIST
96243: LIST
96244: LIST
96245: LIST
96246: LIST
96247: LIST
96248: PUSH
96249: EMPTY
96250: LIST
96251: LIST
96252: ST_TO_ADDR
96253: GO 98508
96255: LD_INT 9
96257: DOUBLE
96258: EQUAL
96259: IFTRUE 96263
96261: GO 96411
96263: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
96264: LD_ADDR_VAR 0 2
96268: PUSH
96269: LD_INT 2
96271: PUSH
96272: LD_INT 4
96274: PUSH
96275: LD_INT 5
96277: PUSH
96278: LD_INT 6
96280: PUSH
96281: LD_INT 7
96283: PUSH
96284: LD_INT 8
96286: PUSH
96287: LD_INT 11
96289: PUSH
96290: LD_INT 12
96292: PUSH
96293: LD_INT 15
96295: PUSH
96296: LD_INT 16
96298: PUSH
96299: LD_INT 20
96301: PUSH
96302: LD_INT 21
96304: PUSH
96305: LD_INT 22
96307: PUSH
96308: LD_INT 23
96310: PUSH
96311: LD_INT 25
96313: PUSH
96314: LD_INT 26
96316: PUSH
96317: LD_INT 28
96319: PUSH
96320: LD_INT 30
96322: PUSH
96323: LD_INT 31
96325: PUSH
96326: LD_INT 32
96328: PUSH
96329: LD_INT 36
96331: PUSH
96332: EMPTY
96333: LIST
96334: LIST
96335: LIST
96336: LIST
96337: LIST
96338: LIST
96339: LIST
96340: LIST
96341: LIST
96342: LIST
96343: LIST
96344: LIST
96345: LIST
96346: LIST
96347: LIST
96348: LIST
96349: LIST
96350: LIST
96351: LIST
96352: LIST
96353: LIST
96354: PUSH
96355: LD_INT 101
96357: PUSH
96358: LD_INT 102
96360: PUSH
96361: LD_INT 103
96363: PUSH
96364: LD_INT 105
96366: PUSH
96367: LD_INT 106
96369: PUSH
96370: LD_INT 108
96372: PUSH
96373: LD_INT 109
96375: PUSH
96376: LD_INT 112
96378: PUSH
96379: LD_INT 114
96381: PUSH
96382: LD_INT 116
96384: PUSH
96385: LD_INT 117
96387: PUSH
96388: LD_INT 118
96390: PUSH
96391: EMPTY
96392: LIST
96393: LIST
96394: LIST
96395: LIST
96396: LIST
96397: LIST
96398: LIST
96399: LIST
96400: LIST
96401: LIST
96402: LIST
96403: LIST
96404: PUSH
96405: EMPTY
96406: LIST
96407: LIST
96408: ST_TO_ADDR
96409: GO 98508
96411: LD_INT 10
96413: DOUBLE
96414: EQUAL
96415: IFTRUE 96419
96417: GO 96615
96419: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
96420: LD_ADDR_VAR 0 2
96424: PUSH
96425: LD_INT 2
96427: PUSH
96428: LD_INT 4
96430: PUSH
96431: LD_INT 5
96433: PUSH
96434: LD_INT 6
96436: PUSH
96437: LD_INT 7
96439: PUSH
96440: LD_INT 8
96442: PUSH
96443: LD_INT 9
96445: PUSH
96446: LD_INT 10
96448: PUSH
96449: LD_INT 11
96451: PUSH
96452: LD_INT 12
96454: PUSH
96455: LD_INT 13
96457: PUSH
96458: LD_INT 14
96460: PUSH
96461: LD_INT 15
96463: PUSH
96464: LD_INT 16
96466: PUSH
96467: LD_INT 17
96469: PUSH
96470: LD_INT 18
96472: PUSH
96473: LD_INT 19
96475: PUSH
96476: LD_INT 20
96478: PUSH
96479: LD_INT 21
96481: PUSH
96482: LD_INT 22
96484: PUSH
96485: LD_INT 23
96487: PUSH
96488: LD_INT 24
96490: PUSH
96491: LD_INT 25
96493: PUSH
96494: LD_INT 26
96496: PUSH
96497: LD_INT 28
96499: PUSH
96500: LD_INT 30
96502: PUSH
96503: LD_INT 31
96505: PUSH
96506: LD_INT 32
96508: PUSH
96509: LD_INT 36
96511: PUSH
96512: EMPTY
96513: LIST
96514: LIST
96515: LIST
96516: LIST
96517: LIST
96518: LIST
96519: LIST
96520: LIST
96521: LIST
96522: LIST
96523: LIST
96524: LIST
96525: LIST
96526: LIST
96527: LIST
96528: LIST
96529: LIST
96530: LIST
96531: LIST
96532: LIST
96533: LIST
96534: LIST
96535: LIST
96536: LIST
96537: LIST
96538: LIST
96539: LIST
96540: LIST
96541: LIST
96542: PUSH
96543: LD_INT 101
96545: PUSH
96546: LD_INT 102
96548: PUSH
96549: LD_INT 103
96551: PUSH
96552: LD_INT 104
96554: PUSH
96555: LD_INT 105
96557: PUSH
96558: LD_INT 106
96560: PUSH
96561: LD_INT 107
96563: PUSH
96564: LD_INT 108
96566: PUSH
96567: LD_INT 109
96569: PUSH
96570: LD_INT 110
96572: PUSH
96573: LD_INT 111
96575: PUSH
96576: LD_INT 112
96578: PUSH
96579: LD_INT 114
96581: PUSH
96582: LD_INT 116
96584: PUSH
96585: LD_INT 117
96587: PUSH
96588: LD_INT 118
96590: PUSH
96591: EMPTY
96592: LIST
96593: LIST
96594: LIST
96595: LIST
96596: LIST
96597: LIST
96598: LIST
96599: LIST
96600: LIST
96601: LIST
96602: LIST
96603: LIST
96604: LIST
96605: LIST
96606: LIST
96607: LIST
96608: PUSH
96609: EMPTY
96610: LIST
96611: LIST
96612: ST_TO_ADDR
96613: GO 98508
96615: LD_INT 11
96617: DOUBLE
96618: EQUAL
96619: IFTRUE 96623
96621: GO 96827
96623: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
96624: LD_ADDR_VAR 0 2
96628: PUSH
96629: LD_INT 2
96631: PUSH
96632: LD_INT 3
96634: PUSH
96635: LD_INT 4
96637: PUSH
96638: LD_INT 5
96640: PUSH
96641: LD_INT 6
96643: PUSH
96644: LD_INT 7
96646: PUSH
96647: LD_INT 8
96649: PUSH
96650: LD_INT 9
96652: PUSH
96653: LD_INT 10
96655: PUSH
96656: LD_INT 11
96658: PUSH
96659: LD_INT 12
96661: PUSH
96662: LD_INT 13
96664: PUSH
96665: LD_INT 14
96667: PUSH
96668: LD_INT 15
96670: PUSH
96671: LD_INT 16
96673: PUSH
96674: LD_INT 17
96676: PUSH
96677: LD_INT 18
96679: PUSH
96680: LD_INT 19
96682: PUSH
96683: LD_INT 20
96685: PUSH
96686: LD_INT 21
96688: PUSH
96689: LD_INT 22
96691: PUSH
96692: LD_INT 23
96694: PUSH
96695: LD_INT 24
96697: PUSH
96698: LD_INT 25
96700: PUSH
96701: LD_INT 26
96703: PUSH
96704: LD_INT 28
96706: PUSH
96707: LD_INT 30
96709: PUSH
96710: LD_INT 31
96712: PUSH
96713: LD_INT 32
96715: PUSH
96716: LD_INT 34
96718: PUSH
96719: LD_INT 36
96721: PUSH
96722: EMPTY
96723: LIST
96724: LIST
96725: LIST
96726: LIST
96727: LIST
96728: LIST
96729: LIST
96730: LIST
96731: LIST
96732: LIST
96733: LIST
96734: LIST
96735: LIST
96736: LIST
96737: LIST
96738: LIST
96739: LIST
96740: LIST
96741: LIST
96742: LIST
96743: LIST
96744: LIST
96745: LIST
96746: LIST
96747: LIST
96748: LIST
96749: LIST
96750: LIST
96751: LIST
96752: LIST
96753: LIST
96754: PUSH
96755: LD_INT 101
96757: PUSH
96758: LD_INT 102
96760: PUSH
96761: LD_INT 103
96763: PUSH
96764: LD_INT 104
96766: PUSH
96767: LD_INT 105
96769: PUSH
96770: LD_INT 106
96772: PUSH
96773: LD_INT 107
96775: PUSH
96776: LD_INT 108
96778: PUSH
96779: LD_INT 109
96781: PUSH
96782: LD_INT 110
96784: PUSH
96785: LD_INT 111
96787: PUSH
96788: LD_INT 112
96790: PUSH
96791: LD_INT 114
96793: PUSH
96794: LD_INT 116
96796: PUSH
96797: LD_INT 117
96799: PUSH
96800: LD_INT 118
96802: PUSH
96803: EMPTY
96804: LIST
96805: LIST
96806: LIST
96807: LIST
96808: LIST
96809: LIST
96810: LIST
96811: LIST
96812: LIST
96813: LIST
96814: LIST
96815: LIST
96816: LIST
96817: LIST
96818: LIST
96819: LIST
96820: PUSH
96821: EMPTY
96822: LIST
96823: LIST
96824: ST_TO_ADDR
96825: GO 98508
96827: LD_INT 12
96829: DOUBLE
96830: EQUAL
96831: IFTRUE 96835
96833: GO 97055
96835: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
96836: LD_ADDR_VAR 0 2
96840: PUSH
96841: LD_INT 1
96843: PUSH
96844: LD_INT 2
96846: PUSH
96847: LD_INT 3
96849: PUSH
96850: LD_INT 4
96852: PUSH
96853: LD_INT 5
96855: PUSH
96856: LD_INT 6
96858: PUSH
96859: LD_INT 7
96861: PUSH
96862: LD_INT 8
96864: PUSH
96865: LD_INT 9
96867: PUSH
96868: LD_INT 10
96870: PUSH
96871: LD_INT 11
96873: PUSH
96874: LD_INT 12
96876: PUSH
96877: LD_INT 13
96879: PUSH
96880: LD_INT 14
96882: PUSH
96883: LD_INT 15
96885: PUSH
96886: LD_INT 16
96888: PUSH
96889: LD_INT 17
96891: PUSH
96892: LD_INT 18
96894: PUSH
96895: LD_INT 19
96897: PUSH
96898: LD_INT 20
96900: PUSH
96901: LD_INT 21
96903: PUSH
96904: LD_INT 22
96906: PUSH
96907: LD_INT 23
96909: PUSH
96910: LD_INT 24
96912: PUSH
96913: LD_INT 25
96915: PUSH
96916: LD_INT 26
96918: PUSH
96919: LD_INT 27
96921: PUSH
96922: LD_INT 28
96924: PUSH
96925: LD_INT 30
96927: PUSH
96928: LD_INT 31
96930: PUSH
96931: LD_INT 32
96933: PUSH
96934: LD_INT 33
96936: PUSH
96937: LD_INT 34
96939: PUSH
96940: LD_INT 36
96942: PUSH
96943: EMPTY
96944: LIST
96945: LIST
96946: LIST
96947: LIST
96948: LIST
96949: LIST
96950: LIST
96951: LIST
96952: LIST
96953: LIST
96954: LIST
96955: LIST
96956: LIST
96957: LIST
96958: LIST
96959: LIST
96960: LIST
96961: LIST
96962: LIST
96963: LIST
96964: LIST
96965: LIST
96966: LIST
96967: LIST
96968: LIST
96969: LIST
96970: LIST
96971: LIST
96972: LIST
96973: LIST
96974: LIST
96975: LIST
96976: LIST
96977: LIST
96978: PUSH
96979: LD_INT 101
96981: PUSH
96982: LD_INT 102
96984: PUSH
96985: LD_INT 103
96987: PUSH
96988: LD_INT 104
96990: PUSH
96991: LD_INT 105
96993: PUSH
96994: LD_INT 106
96996: PUSH
96997: LD_INT 107
96999: PUSH
97000: LD_INT 108
97002: PUSH
97003: LD_INT 109
97005: PUSH
97006: LD_INT 110
97008: PUSH
97009: LD_INT 111
97011: PUSH
97012: LD_INT 112
97014: PUSH
97015: LD_INT 113
97017: PUSH
97018: LD_INT 114
97020: PUSH
97021: LD_INT 116
97023: PUSH
97024: LD_INT 117
97026: PUSH
97027: LD_INT 118
97029: PUSH
97030: EMPTY
97031: LIST
97032: LIST
97033: LIST
97034: LIST
97035: LIST
97036: LIST
97037: LIST
97038: LIST
97039: LIST
97040: LIST
97041: LIST
97042: LIST
97043: LIST
97044: LIST
97045: LIST
97046: LIST
97047: LIST
97048: PUSH
97049: EMPTY
97050: LIST
97051: LIST
97052: ST_TO_ADDR
97053: GO 98508
97055: LD_INT 13
97057: DOUBLE
97058: EQUAL
97059: IFTRUE 97063
97061: GO 97271
97063: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
97064: LD_ADDR_VAR 0 2
97068: PUSH
97069: LD_INT 1
97071: PUSH
97072: LD_INT 2
97074: PUSH
97075: LD_INT 3
97077: PUSH
97078: LD_INT 4
97080: PUSH
97081: LD_INT 5
97083: PUSH
97084: LD_INT 8
97086: PUSH
97087: LD_INT 9
97089: PUSH
97090: LD_INT 10
97092: PUSH
97093: LD_INT 11
97095: PUSH
97096: LD_INT 12
97098: PUSH
97099: LD_INT 14
97101: PUSH
97102: LD_INT 15
97104: PUSH
97105: LD_INT 16
97107: PUSH
97108: LD_INT 17
97110: PUSH
97111: LD_INT 18
97113: PUSH
97114: LD_INT 19
97116: PUSH
97117: LD_INT 20
97119: PUSH
97120: LD_INT 21
97122: PUSH
97123: LD_INT 22
97125: PUSH
97126: LD_INT 23
97128: PUSH
97129: LD_INT 24
97131: PUSH
97132: LD_INT 25
97134: PUSH
97135: LD_INT 26
97137: PUSH
97138: LD_INT 27
97140: PUSH
97141: LD_INT 28
97143: PUSH
97144: LD_INT 30
97146: PUSH
97147: LD_INT 31
97149: PUSH
97150: LD_INT 32
97152: PUSH
97153: LD_INT 33
97155: PUSH
97156: LD_INT 34
97158: PUSH
97159: LD_INT 36
97161: PUSH
97162: EMPTY
97163: LIST
97164: LIST
97165: LIST
97166: LIST
97167: LIST
97168: LIST
97169: LIST
97170: LIST
97171: LIST
97172: LIST
97173: LIST
97174: LIST
97175: LIST
97176: LIST
97177: LIST
97178: LIST
97179: LIST
97180: LIST
97181: LIST
97182: LIST
97183: LIST
97184: LIST
97185: LIST
97186: LIST
97187: LIST
97188: LIST
97189: LIST
97190: LIST
97191: LIST
97192: LIST
97193: LIST
97194: PUSH
97195: LD_INT 101
97197: PUSH
97198: LD_INT 102
97200: PUSH
97201: LD_INT 103
97203: PUSH
97204: LD_INT 104
97206: PUSH
97207: LD_INT 105
97209: PUSH
97210: LD_INT 106
97212: PUSH
97213: LD_INT 107
97215: PUSH
97216: LD_INT 108
97218: PUSH
97219: LD_INT 109
97221: PUSH
97222: LD_INT 110
97224: PUSH
97225: LD_INT 111
97227: PUSH
97228: LD_INT 112
97230: PUSH
97231: LD_INT 113
97233: PUSH
97234: LD_INT 114
97236: PUSH
97237: LD_INT 116
97239: PUSH
97240: LD_INT 117
97242: PUSH
97243: LD_INT 118
97245: PUSH
97246: EMPTY
97247: LIST
97248: LIST
97249: LIST
97250: LIST
97251: LIST
97252: LIST
97253: LIST
97254: LIST
97255: LIST
97256: LIST
97257: LIST
97258: LIST
97259: LIST
97260: LIST
97261: LIST
97262: LIST
97263: LIST
97264: PUSH
97265: EMPTY
97266: LIST
97267: LIST
97268: ST_TO_ADDR
97269: GO 98508
97271: LD_INT 14
97273: DOUBLE
97274: EQUAL
97275: IFTRUE 97279
97277: GO 97503
97279: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
97280: LD_ADDR_VAR 0 2
97284: PUSH
97285: LD_INT 1
97287: PUSH
97288: LD_INT 2
97290: PUSH
97291: LD_INT 3
97293: PUSH
97294: LD_INT 4
97296: PUSH
97297: LD_INT 5
97299: PUSH
97300: LD_INT 6
97302: PUSH
97303: LD_INT 7
97305: PUSH
97306: LD_INT 8
97308: PUSH
97309: LD_INT 9
97311: PUSH
97312: LD_INT 10
97314: PUSH
97315: LD_INT 11
97317: PUSH
97318: LD_INT 12
97320: PUSH
97321: LD_INT 13
97323: PUSH
97324: LD_INT 14
97326: PUSH
97327: LD_INT 15
97329: PUSH
97330: LD_INT 16
97332: PUSH
97333: LD_INT 17
97335: PUSH
97336: LD_INT 18
97338: PUSH
97339: LD_INT 19
97341: PUSH
97342: LD_INT 20
97344: PUSH
97345: LD_INT 21
97347: PUSH
97348: LD_INT 22
97350: PUSH
97351: LD_INT 23
97353: PUSH
97354: LD_INT 24
97356: PUSH
97357: LD_INT 25
97359: PUSH
97360: LD_INT 26
97362: PUSH
97363: LD_INT 27
97365: PUSH
97366: LD_INT 28
97368: PUSH
97369: LD_INT 29
97371: PUSH
97372: LD_INT 30
97374: PUSH
97375: LD_INT 31
97377: PUSH
97378: LD_INT 32
97380: PUSH
97381: LD_INT 33
97383: PUSH
97384: LD_INT 34
97386: PUSH
97387: LD_INT 36
97389: PUSH
97390: EMPTY
97391: LIST
97392: LIST
97393: LIST
97394: LIST
97395: LIST
97396: LIST
97397: LIST
97398: LIST
97399: LIST
97400: LIST
97401: LIST
97402: LIST
97403: LIST
97404: LIST
97405: LIST
97406: LIST
97407: LIST
97408: LIST
97409: LIST
97410: LIST
97411: LIST
97412: LIST
97413: LIST
97414: LIST
97415: LIST
97416: LIST
97417: LIST
97418: LIST
97419: LIST
97420: LIST
97421: LIST
97422: LIST
97423: LIST
97424: LIST
97425: LIST
97426: PUSH
97427: LD_INT 101
97429: PUSH
97430: LD_INT 102
97432: PUSH
97433: LD_INT 103
97435: PUSH
97436: LD_INT 104
97438: PUSH
97439: LD_INT 105
97441: PUSH
97442: LD_INT 106
97444: PUSH
97445: LD_INT 107
97447: PUSH
97448: LD_INT 108
97450: PUSH
97451: LD_INT 109
97453: PUSH
97454: LD_INT 110
97456: PUSH
97457: LD_INT 111
97459: PUSH
97460: LD_INT 112
97462: PUSH
97463: LD_INT 113
97465: PUSH
97466: LD_INT 114
97468: PUSH
97469: LD_INT 116
97471: PUSH
97472: LD_INT 117
97474: PUSH
97475: LD_INT 118
97477: PUSH
97478: EMPTY
97479: LIST
97480: LIST
97481: LIST
97482: LIST
97483: LIST
97484: LIST
97485: LIST
97486: LIST
97487: LIST
97488: LIST
97489: LIST
97490: LIST
97491: LIST
97492: LIST
97493: LIST
97494: LIST
97495: LIST
97496: PUSH
97497: EMPTY
97498: LIST
97499: LIST
97500: ST_TO_ADDR
97501: GO 98508
97503: LD_INT 15
97505: DOUBLE
97506: EQUAL
97507: IFTRUE 97511
97509: GO 97735
97511: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
97512: LD_ADDR_VAR 0 2
97516: PUSH
97517: LD_INT 1
97519: PUSH
97520: LD_INT 2
97522: PUSH
97523: LD_INT 3
97525: PUSH
97526: LD_INT 4
97528: PUSH
97529: LD_INT 5
97531: PUSH
97532: LD_INT 6
97534: PUSH
97535: LD_INT 7
97537: PUSH
97538: LD_INT 8
97540: PUSH
97541: LD_INT 9
97543: PUSH
97544: LD_INT 10
97546: PUSH
97547: LD_INT 11
97549: PUSH
97550: LD_INT 12
97552: PUSH
97553: LD_INT 13
97555: PUSH
97556: LD_INT 14
97558: PUSH
97559: LD_INT 15
97561: PUSH
97562: LD_INT 16
97564: PUSH
97565: LD_INT 17
97567: PUSH
97568: LD_INT 18
97570: PUSH
97571: LD_INT 19
97573: PUSH
97574: LD_INT 20
97576: PUSH
97577: LD_INT 21
97579: PUSH
97580: LD_INT 22
97582: PUSH
97583: LD_INT 23
97585: PUSH
97586: LD_INT 24
97588: PUSH
97589: LD_INT 25
97591: PUSH
97592: LD_INT 26
97594: PUSH
97595: LD_INT 27
97597: PUSH
97598: LD_INT 28
97600: PUSH
97601: LD_INT 29
97603: PUSH
97604: LD_INT 30
97606: PUSH
97607: LD_INT 31
97609: PUSH
97610: LD_INT 32
97612: PUSH
97613: LD_INT 33
97615: PUSH
97616: LD_INT 34
97618: PUSH
97619: LD_INT 36
97621: PUSH
97622: EMPTY
97623: LIST
97624: LIST
97625: LIST
97626: LIST
97627: LIST
97628: LIST
97629: LIST
97630: LIST
97631: LIST
97632: LIST
97633: LIST
97634: LIST
97635: LIST
97636: LIST
97637: LIST
97638: LIST
97639: LIST
97640: LIST
97641: LIST
97642: LIST
97643: LIST
97644: LIST
97645: LIST
97646: LIST
97647: LIST
97648: LIST
97649: LIST
97650: LIST
97651: LIST
97652: LIST
97653: LIST
97654: LIST
97655: LIST
97656: LIST
97657: LIST
97658: PUSH
97659: LD_INT 101
97661: PUSH
97662: LD_INT 102
97664: PUSH
97665: LD_INT 103
97667: PUSH
97668: LD_INT 104
97670: PUSH
97671: LD_INT 105
97673: PUSH
97674: LD_INT 106
97676: PUSH
97677: LD_INT 107
97679: PUSH
97680: LD_INT 108
97682: PUSH
97683: LD_INT 109
97685: PUSH
97686: LD_INT 110
97688: PUSH
97689: LD_INT 111
97691: PUSH
97692: LD_INT 112
97694: PUSH
97695: LD_INT 113
97697: PUSH
97698: LD_INT 114
97700: PUSH
97701: LD_INT 116
97703: PUSH
97704: LD_INT 117
97706: PUSH
97707: LD_INT 118
97709: PUSH
97710: EMPTY
97711: LIST
97712: LIST
97713: LIST
97714: LIST
97715: LIST
97716: LIST
97717: LIST
97718: LIST
97719: LIST
97720: LIST
97721: LIST
97722: LIST
97723: LIST
97724: LIST
97725: LIST
97726: LIST
97727: LIST
97728: PUSH
97729: EMPTY
97730: LIST
97731: LIST
97732: ST_TO_ADDR
97733: GO 98508
97735: LD_INT 16
97737: DOUBLE
97738: EQUAL
97739: IFTRUE 97743
97741: GO 97879
97743: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
97744: LD_ADDR_VAR 0 2
97748: PUSH
97749: LD_INT 2
97751: PUSH
97752: LD_INT 4
97754: PUSH
97755: LD_INT 5
97757: PUSH
97758: LD_INT 7
97760: PUSH
97761: LD_INT 11
97763: PUSH
97764: LD_INT 12
97766: PUSH
97767: LD_INT 15
97769: PUSH
97770: LD_INT 16
97772: PUSH
97773: LD_INT 20
97775: PUSH
97776: LD_INT 21
97778: PUSH
97779: LD_INT 22
97781: PUSH
97782: LD_INT 23
97784: PUSH
97785: LD_INT 25
97787: PUSH
97788: LD_INT 26
97790: PUSH
97791: LD_INT 30
97793: PUSH
97794: LD_INT 31
97796: PUSH
97797: LD_INT 32
97799: PUSH
97800: LD_INT 33
97802: PUSH
97803: LD_INT 34
97805: PUSH
97806: EMPTY
97807: LIST
97808: LIST
97809: LIST
97810: LIST
97811: LIST
97812: LIST
97813: LIST
97814: LIST
97815: LIST
97816: LIST
97817: LIST
97818: LIST
97819: LIST
97820: LIST
97821: LIST
97822: LIST
97823: LIST
97824: LIST
97825: LIST
97826: PUSH
97827: LD_INT 101
97829: PUSH
97830: LD_INT 102
97832: PUSH
97833: LD_INT 103
97835: PUSH
97836: LD_INT 106
97838: PUSH
97839: LD_INT 108
97841: PUSH
97842: LD_INT 112
97844: PUSH
97845: LD_INT 113
97847: PUSH
97848: LD_INT 114
97850: PUSH
97851: LD_INT 116
97853: PUSH
97854: LD_INT 117
97856: PUSH
97857: LD_INT 118
97859: PUSH
97860: EMPTY
97861: LIST
97862: LIST
97863: LIST
97864: LIST
97865: LIST
97866: LIST
97867: LIST
97868: LIST
97869: LIST
97870: LIST
97871: LIST
97872: PUSH
97873: EMPTY
97874: LIST
97875: LIST
97876: ST_TO_ADDR
97877: GO 98508
97879: LD_INT 17
97881: DOUBLE
97882: EQUAL
97883: IFTRUE 97887
97885: GO 98111
97887: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
97888: LD_ADDR_VAR 0 2
97892: PUSH
97893: LD_INT 1
97895: PUSH
97896: LD_INT 2
97898: PUSH
97899: LD_INT 3
97901: PUSH
97902: LD_INT 4
97904: PUSH
97905: LD_INT 5
97907: PUSH
97908: LD_INT 6
97910: PUSH
97911: LD_INT 7
97913: PUSH
97914: LD_INT 8
97916: PUSH
97917: LD_INT 9
97919: PUSH
97920: LD_INT 10
97922: PUSH
97923: LD_INT 11
97925: PUSH
97926: LD_INT 12
97928: PUSH
97929: LD_INT 13
97931: PUSH
97932: LD_INT 14
97934: PUSH
97935: LD_INT 15
97937: PUSH
97938: LD_INT 16
97940: PUSH
97941: LD_INT 17
97943: PUSH
97944: LD_INT 18
97946: PUSH
97947: LD_INT 19
97949: PUSH
97950: LD_INT 20
97952: PUSH
97953: LD_INT 21
97955: PUSH
97956: LD_INT 22
97958: PUSH
97959: LD_INT 23
97961: PUSH
97962: LD_INT 24
97964: PUSH
97965: LD_INT 25
97967: PUSH
97968: LD_INT 26
97970: PUSH
97971: LD_INT 27
97973: PUSH
97974: LD_INT 28
97976: PUSH
97977: LD_INT 29
97979: PUSH
97980: LD_INT 30
97982: PUSH
97983: LD_INT 31
97985: PUSH
97986: LD_INT 32
97988: PUSH
97989: LD_INT 33
97991: PUSH
97992: LD_INT 34
97994: PUSH
97995: LD_INT 36
97997: PUSH
97998: EMPTY
97999: LIST
98000: LIST
98001: LIST
98002: LIST
98003: LIST
98004: LIST
98005: LIST
98006: LIST
98007: LIST
98008: LIST
98009: LIST
98010: LIST
98011: LIST
98012: LIST
98013: LIST
98014: LIST
98015: LIST
98016: LIST
98017: LIST
98018: LIST
98019: LIST
98020: LIST
98021: LIST
98022: LIST
98023: LIST
98024: LIST
98025: LIST
98026: LIST
98027: LIST
98028: LIST
98029: LIST
98030: LIST
98031: LIST
98032: LIST
98033: LIST
98034: PUSH
98035: LD_INT 101
98037: PUSH
98038: LD_INT 102
98040: PUSH
98041: LD_INT 103
98043: PUSH
98044: LD_INT 104
98046: PUSH
98047: LD_INT 105
98049: PUSH
98050: LD_INT 106
98052: PUSH
98053: LD_INT 107
98055: PUSH
98056: LD_INT 108
98058: PUSH
98059: LD_INT 109
98061: PUSH
98062: LD_INT 110
98064: PUSH
98065: LD_INT 111
98067: PUSH
98068: LD_INT 112
98070: PUSH
98071: LD_INT 113
98073: PUSH
98074: LD_INT 114
98076: PUSH
98077: LD_INT 116
98079: PUSH
98080: LD_INT 117
98082: PUSH
98083: LD_INT 118
98085: PUSH
98086: EMPTY
98087: LIST
98088: LIST
98089: LIST
98090: LIST
98091: LIST
98092: LIST
98093: LIST
98094: LIST
98095: LIST
98096: LIST
98097: LIST
98098: LIST
98099: LIST
98100: LIST
98101: LIST
98102: LIST
98103: LIST
98104: PUSH
98105: EMPTY
98106: LIST
98107: LIST
98108: ST_TO_ADDR
98109: GO 98508
98111: LD_INT 18
98113: DOUBLE
98114: EQUAL
98115: IFTRUE 98119
98117: GO 98267
98119: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
98120: LD_ADDR_VAR 0 2
98124: PUSH
98125: LD_INT 2
98127: PUSH
98128: LD_INT 4
98130: PUSH
98131: LD_INT 5
98133: PUSH
98134: LD_INT 7
98136: PUSH
98137: LD_INT 11
98139: PUSH
98140: LD_INT 12
98142: PUSH
98143: LD_INT 15
98145: PUSH
98146: LD_INT 16
98148: PUSH
98149: LD_INT 20
98151: PUSH
98152: LD_INT 21
98154: PUSH
98155: LD_INT 22
98157: PUSH
98158: LD_INT 23
98160: PUSH
98161: LD_INT 25
98163: PUSH
98164: LD_INT 26
98166: PUSH
98167: LD_INT 30
98169: PUSH
98170: LD_INT 31
98172: PUSH
98173: LD_INT 32
98175: PUSH
98176: LD_INT 33
98178: PUSH
98179: LD_INT 34
98181: PUSH
98182: LD_INT 35
98184: PUSH
98185: LD_INT 36
98187: PUSH
98188: EMPTY
98189: LIST
98190: LIST
98191: LIST
98192: LIST
98193: LIST
98194: LIST
98195: LIST
98196: LIST
98197: LIST
98198: LIST
98199: LIST
98200: LIST
98201: LIST
98202: LIST
98203: LIST
98204: LIST
98205: LIST
98206: LIST
98207: LIST
98208: LIST
98209: LIST
98210: PUSH
98211: LD_INT 101
98213: PUSH
98214: LD_INT 102
98216: PUSH
98217: LD_INT 103
98219: PUSH
98220: LD_INT 106
98222: PUSH
98223: LD_INT 108
98225: PUSH
98226: LD_INT 112
98228: PUSH
98229: LD_INT 113
98231: PUSH
98232: LD_INT 114
98234: PUSH
98235: LD_INT 115
98237: PUSH
98238: LD_INT 116
98240: PUSH
98241: LD_INT 117
98243: PUSH
98244: LD_INT 118
98246: PUSH
98247: EMPTY
98248: LIST
98249: LIST
98250: LIST
98251: LIST
98252: LIST
98253: LIST
98254: LIST
98255: LIST
98256: LIST
98257: LIST
98258: LIST
98259: LIST
98260: PUSH
98261: EMPTY
98262: LIST
98263: LIST
98264: ST_TO_ADDR
98265: GO 98508
98267: LD_INT 19
98269: DOUBLE
98270: EQUAL
98271: IFTRUE 98275
98273: GO 98507
98275: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
98276: LD_ADDR_VAR 0 2
98280: PUSH
98281: LD_INT 1
98283: PUSH
98284: LD_INT 2
98286: PUSH
98287: LD_INT 3
98289: PUSH
98290: LD_INT 4
98292: PUSH
98293: LD_INT 5
98295: PUSH
98296: LD_INT 6
98298: PUSH
98299: LD_INT 7
98301: PUSH
98302: LD_INT 8
98304: PUSH
98305: LD_INT 9
98307: PUSH
98308: LD_INT 10
98310: PUSH
98311: LD_INT 11
98313: PUSH
98314: LD_INT 12
98316: PUSH
98317: LD_INT 13
98319: PUSH
98320: LD_INT 14
98322: PUSH
98323: LD_INT 15
98325: PUSH
98326: LD_INT 16
98328: PUSH
98329: LD_INT 17
98331: PUSH
98332: LD_INT 18
98334: PUSH
98335: LD_INT 19
98337: PUSH
98338: LD_INT 20
98340: PUSH
98341: LD_INT 21
98343: PUSH
98344: LD_INT 22
98346: PUSH
98347: LD_INT 23
98349: PUSH
98350: LD_INT 24
98352: PUSH
98353: LD_INT 25
98355: PUSH
98356: LD_INT 26
98358: PUSH
98359: LD_INT 27
98361: PUSH
98362: LD_INT 28
98364: PUSH
98365: LD_INT 29
98367: PUSH
98368: LD_INT 30
98370: PUSH
98371: LD_INT 31
98373: PUSH
98374: LD_INT 32
98376: PUSH
98377: LD_INT 33
98379: PUSH
98380: LD_INT 34
98382: PUSH
98383: LD_INT 35
98385: PUSH
98386: LD_INT 36
98388: PUSH
98389: EMPTY
98390: LIST
98391: LIST
98392: LIST
98393: LIST
98394: LIST
98395: LIST
98396: LIST
98397: LIST
98398: LIST
98399: LIST
98400: LIST
98401: LIST
98402: LIST
98403: LIST
98404: LIST
98405: LIST
98406: LIST
98407: LIST
98408: LIST
98409: LIST
98410: LIST
98411: LIST
98412: LIST
98413: LIST
98414: LIST
98415: LIST
98416: LIST
98417: LIST
98418: LIST
98419: LIST
98420: LIST
98421: LIST
98422: LIST
98423: LIST
98424: LIST
98425: LIST
98426: PUSH
98427: LD_INT 101
98429: PUSH
98430: LD_INT 102
98432: PUSH
98433: LD_INT 103
98435: PUSH
98436: LD_INT 104
98438: PUSH
98439: LD_INT 105
98441: PUSH
98442: LD_INT 106
98444: PUSH
98445: LD_INT 107
98447: PUSH
98448: LD_INT 108
98450: PUSH
98451: LD_INT 109
98453: PUSH
98454: LD_INT 110
98456: PUSH
98457: LD_INT 111
98459: PUSH
98460: LD_INT 112
98462: PUSH
98463: LD_INT 113
98465: PUSH
98466: LD_INT 114
98468: PUSH
98469: LD_INT 115
98471: PUSH
98472: LD_INT 116
98474: PUSH
98475: LD_INT 117
98477: PUSH
98478: LD_INT 118
98480: PUSH
98481: EMPTY
98482: LIST
98483: LIST
98484: LIST
98485: LIST
98486: LIST
98487: LIST
98488: LIST
98489: LIST
98490: LIST
98491: LIST
98492: LIST
98493: LIST
98494: LIST
98495: LIST
98496: LIST
98497: LIST
98498: LIST
98499: LIST
98500: PUSH
98501: EMPTY
98502: LIST
98503: LIST
98504: ST_TO_ADDR
98505: GO 98508
98507: POP
// end else
98508: GO 98739
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
98510: LD_ADDR_VAR 0 2
98514: PUSH
98515: LD_INT 1
98517: PUSH
98518: LD_INT 2
98520: PUSH
98521: LD_INT 3
98523: PUSH
98524: LD_INT 4
98526: PUSH
98527: LD_INT 5
98529: PUSH
98530: LD_INT 6
98532: PUSH
98533: LD_INT 7
98535: PUSH
98536: LD_INT 8
98538: PUSH
98539: LD_INT 9
98541: PUSH
98542: LD_INT 10
98544: PUSH
98545: LD_INT 11
98547: PUSH
98548: LD_INT 12
98550: PUSH
98551: LD_INT 13
98553: PUSH
98554: LD_INT 14
98556: PUSH
98557: LD_INT 15
98559: PUSH
98560: LD_INT 16
98562: PUSH
98563: LD_INT 17
98565: PUSH
98566: LD_INT 18
98568: PUSH
98569: LD_INT 19
98571: PUSH
98572: LD_INT 20
98574: PUSH
98575: LD_INT 21
98577: PUSH
98578: LD_INT 22
98580: PUSH
98581: LD_INT 23
98583: PUSH
98584: LD_INT 24
98586: PUSH
98587: LD_INT 25
98589: PUSH
98590: LD_INT 26
98592: PUSH
98593: LD_INT 27
98595: PUSH
98596: LD_INT 28
98598: PUSH
98599: LD_INT 29
98601: PUSH
98602: LD_INT 30
98604: PUSH
98605: LD_INT 31
98607: PUSH
98608: LD_INT 32
98610: PUSH
98611: LD_INT 33
98613: PUSH
98614: LD_INT 34
98616: PUSH
98617: LD_INT 35
98619: PUSH
98620: LD_INT 36
98622: PUSH
98623: EMPTY
98624: LIST
98625: LIST
98626: LIST
98627: LIST
98628: LIST
98629: LIST
98630: LIST
98631: LIST
98632: LIST
98633: LIST
98634: LIST
98635: LIST
98636: LIST
98637: LIST
98638: LIST
98639: LIST
98640: LIST
98641: LIST
98642: LIST
98643: LIST
98644: LIST
98645: LIST
98646: LIST
98647: LIST
98648: LIST
98649: LIST
98650: LIST
98651: LIST
98652: LIST
98653: LIST
98654: LIST
98655: LIST
98656: LIST
98657: LIST
98658: LIST
98659: LIST
98660: PUSH
98661: LD_INT 101
98663: PUSH
98664: LD_INT 102
98666: PUSH
98667: LD_INT 103
98669: PUSH
98670: LD_INT 104
98672: PUSH
98673: LD_INT 105
98675: PUSH
98676: LD_INT 106
98678: PUSH
98679: LD_INT 107
98681: PUSH
98682: LD_INT 108
98684: PUSH
98685: LD_INT 109
98687: PUSH
98688: LD_INT 110
98690: PUSH
98691: LD_INT 111
98693: PUSH
98694: LD_INT 112
98696: PUSH
98697: LD_INT 113
98699: PUSH
98700: LD_INT 114
98702: PUSH
98703: LD_INT 115
98705: PUSH
98706: LD_INT 116
98708: PUSH
98709: LD_INT 117
98711: PUSH
98712: LD_INT 118
98714: PUSH
98715: EMPTY
98716: LIST
98717: LIST
98718: LIST
98719: LIST
98720: LIST
98721: LIST
98722: LIST
98723: LIST
98724: LIST
98725: LIST
98726: LIST
98727: LIST
98728: LIST
98729: LIST
98730: LIST
98731: LIST
98732: LIST
98733: LIST
98734: PUSH
98735: EMPTY
98736: LIST
98737: LIST
98738: ST_TO_ADDR
// if result then
98739: LD_VAR 0 2
98743: IFFALSE 99529
// begin normal :=  ;
98745: LD_ADDR_VAR 0 5
98749: PUSH
98750: LD_STRING 
98752: ST_TO_ADDR
// hardcore :=  ;
98753: LD_ADDR_VAR 0 6
98757: PUSH
98758: LD_STRING 
98760: ST_TO_ADDR
// active :=  ;
98761: LD_ADDR_VAR 0 7
98765: PUSH
98766: LD_STRING 
98768: ST_TO_ADDR
// for i = 1 to normalCounter do
98769: LD_ADDR_VAR 0 8
98773: PUSH
98774: DOUBLE
98775: LD_INT 1
98777: DEC
98778: ST_TO_ADDR
98779: LD_EXP 124
98783: PUSH
98784: FOR_TO
98785: IFFALSE 98886
// begin tmp := 0 ;
98787: LD_ADDR_VAR 0 3
98791: PUSH
98792: LD_STRING 0
98794: ST_TO_ADDR
// if result [ 1 ] then
98795: LD_VAR 0 2
98799: PUSH
98800: LD_INT 1
98802: ARRAY
98803: IFFALSE 98868
// if result [ 1 ] [ 1 ] = i then
98805: LD_VAR 0 2
98809: PUSH
98810: LD_INT 1
98812: ARRAY
98813: PUSH
98814: LD_INT 1
98816: ARRAY
98817: PUSH
98818: LD_VAR 0 8
98822: EQUAL
98823: IFFALSE 98868
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
98825: LD_ADDR_VAR 0 2
98829: PUSH
98830: LD_VAR 0 2
98834: PPUSH
98835: LD_INT 1
98837: PPUSH
98838: LD_VAR 0 2
98842: PUSH
98843: LD_INT 1
98845: ARRAY
98846: PPUSH
98847: LD_INT 1
98849: PPUSH
98850: CALL_OW 3
98854: PPUSH
98855: CALL_OW 1
98859: ST_TO_ADDR
// tmp := 1 ;
98860: LD_ADDR_VAR 0 3
98864: PUSH
98865: LD_STRING 1
98867: ST_TO_ADDR
// end ; normal := normal & tmp ;
98868: LD_ADDR_VAR 0 5
98872: PUSH
98873: LD_VAR 0 5
98877: PUSH
98878: LD_VAR 0 3
98882: STR
98883: ST_TO_ADDR
// end ;
98884: GO 98784
98886: POP
98887: POP
// for i = 1 to hardcoreCounter do
98888: LD_ADDR_VAR 0 8
98892: PUSH
98893: DOUBLE
98894: LD_INT 1
98896: DEC
98897: ST_TO_ADDR
98898: LD_EXP 125
98902: PUSH
98903: FOR_TO
98904: IFFALSE 99009
// begin tmp := 0 ;
98906: LD_ADDR_VAR 0 3
98910: PUSH
98911: LD_STRING 0
98913: ST_TO_ADDR
// if result [ 2 ] then
98914: LD_VAR 0 2
98918: PUSH
98919: LD_INT 2
98921: ARRAY
98922: IFFALSE 98991
// if result [ 2 ] [ 1 ] = 100 + i then
98924: LD_VAR 0 2
98928: PUSH
98929: LD_INT 2
98931: ARRAY
98932: PUSH
98933: LD_INT 1
98935: ARRAY
98936: PUSH
98937: LD_INT 100
98939: PUSH
98940: LD_VAR 0 8
98944: PLUS
98945: EQUAL
98946: IFFALSE 98991
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
98948: LD_ADDR_VAR 0 2
98952: PUSH
98953: LD_VAR 0 2
98957: PPUSH
98958: LD_INT 2
98960: PPUSH
98961: LD_VAR 0 2
98965: PUSH
98966: LD_INT 2
98968: ARRAY
98969: PPUSH
98970: LD_INT 1
98972: PPUSH
98973: CALL_OW 3
98977: PPUSH
98978: CALL_OW 1
98982: ST_TO_ADDR
// tmp := 1 ;
98983: LD_ADDR_VAR 0 3
98987: PUSH
98988: LD_STRING 1
98990: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
98991: LD_ADDR_VAR 0 6
98995: PUSH
98996: LD_VAR 0 6
99000: PUSH
99001: LD_VAR 0 3
99005: STR
99006: ST_TO_ADDR
// end ;
99007: GO 98903
99009: POP
99010: POP
// if isGameLoad then
99011: LD_VAR 0 1
99015: IFFALSE 99490
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
99017: LD_ADDR_VAR 0 4
99021: PUSH
99022: LD_EXP 128
99026: PUSH
99027: LD_EXP 127
99031: PUSH
99032: LD_EXP 129
99036: PUSH
99037: LD_EXP 126
99041: PUSH
99042: LD_EXP 130
99046: PUSH
99047: LD_EXP 131
99051: PUSH
99052: LD_EXP 132
99056: PUSH
99057: LD_EXP 133
99061: PUSH
99062: LD_EXP 134
99066: PUSH
99067: LD_EXP 135
99071: PUSH
99072: LD_EXP 136
99076: PUSH
99077: LD_EXP 137
99081: PUSH
99082: LD_EXP 138
99086: PUSH
99087: LD_EXP 139
99091: PUSH
99092: LD_EXP 147
99096: PUSH
99097: LD_EXP 148
99101: PUSH
99102: LD_EXP 149
99106: PUSH
99107: LD_EXP 150
99111: PUSH
99112: LD_EXP 152
99116: PUSH
99117: LD_EXP 153
99121: PUSH
99122: LD_EXP 154
99126: PUSH
99127: LD_EXP 157
99131: PUSH
99132: LD_EXP 159
99136: PUSH
99137: LD_EXP 160
99141: PUSH
99142: LD_EXP 161
99146: PUSH
99147: LD_EXP 163
99151: PUSH
99152: LD_EXP 164
99156: PUSH
99157: LD_EXP 167
99161: PUSH
99162: LD_EXP 168
99166: PUSH
99167: LD_EXP 169
99171: PUSH
99172: LD_EXP 170
99176: PUSH
99177: LD_EXP 171
99181: PUSH
99182: LD_EXP 172
99186: PUSH
99187: LD_EXP 173
99191: PUSH
99192: LD_EXP 174
99196: PUSH
99197: LD_EXP 175
99201: PUSH
99202: LD_EXP 140
99206: PUSH
99207: LD_EXP 141
99211: PUSH
99212: LD_EXP 144
99216: PUSH
99217: LD_EXP 145
99221: PUSH
99222: LD_EXP 146
99226: PUSH
99227: LD_EXP 142
99231: PUSH
99232: LD_EXP 143
99236: PUSH
99237: LD_EXP 151
99241: PUSH
99242: LD_EXP 155
99246: PUSH
99247: LD_EXP 156
99251: PUSH
99252: LD_EXP 158
99256: PUSH
99257: LD_EXP 162
99261: PUSH
99262: LD_EXP 165
99266: PUSH
99267: LD_EXP 166
99271: PUSH
99272: LD_EXP 176
99276: PUSH
99277: LD_EXP 177
99281: PUSH
99282: LD_EXP 178
99286: PUSH
99287: LD_EXP 179
99291: PUSH
99292: EMPTY
99293: LIST
99294: LIST
99295: LIST
99296: LIST
99297: LIST
99298: LIST
99299: LIST
99300: LIST
99301: LIST
99302: LIST
99303: LIST
99304: LIST
99305: LIST
99306: LIST
99307: LIST
99308: LIST
99309: LIST
99310: LIST
99311: LIST
99312: LIST
99313: LIST
99314: LIST
99315: LIST
99316: LIST
99317: LIST
99318: LIST
99319: LIST
99320: LIST
99321: LIST
99322: LIST
99323: LIST
99324: LIST
99325: LIST
99326: LIST
99327: LIST
99328: LIST
99329: LIST
99330: LIST
99331: LIST
99332: LIST
99333: LIST
99334: LIST
99335: LIST
99336: LIST
99337: LIST
99338: LIST
99339: LIST
99340: LIST
99341: LIST
99342: LIST
99343: LIST
99344: LIST
99345: LIST
99346: LIST
99347: ST_TO_ADDR
// tmp :=  ;
99348: LD_ADDR_VAR 0 3
99352: PUSH
99353: LD_STRING 
99355: ST_TO_ADDR
// for i = 1 to normalCounter do
99356: LD_ADDR_VAR 0 8
99360: PUSH
99361: DOUBLE
99362: LD_INT 1
99364: DEC
99365: ST_TO_ADDR
99366: LD_EXP 124
99370: PUSH
99371: FOR_TO
99372: IFFALSE 99408
// begin if flags [ i ] then
99374: LD_VAR 0 4
99378: PUSH
99379: LD_VAR 0 8
99383: ARRAY
99384: IFFALSE 99406
// tmp := tmp & i & ; ;
99386: LD_ADDR_VAR 0 3
99390: PUSH
99391: LD_VAR 0 3
99395: PUSH
99396: LD_VAR 0 8
99400: STR
99401: PUSH
99402: LD_STRING ;
99404: STR
99405: ST_TO_ADDR
// end ;
99406: GO 99371
99408: POP
99409: POP
// for i = 1 to hardcoreCounter do
99410: LD_ADDR_VAR 0 8
99414: PUSH
99415: DOUBLE
99416: LD_INT 1
99418: DEC
99419: ST_TO_ADDR
99420: LD_EXP 125
99424: PUSH
99425: FOR_TO
99426: IFFALSE 99472
// begin if flags [ normalCounter + i ] then
99428: LD_VAR 0 4
99432: PUSH
99433: LD_EXP 124
99437: PUSH
99438: LD_VAR 0 8
99442: PLUS
99443: ARRAY
99444: IFFALSE 99470
// tmp := tmp & ( 100 + i ) & ; ;
99446: LD_ADDR_VAR 0 3
99450: PUSH
99451: LD_VAR 0 3
99455: PUSH
99456: LD_INT 100
99458: PUSH
99459: LD_VAR 0 8
99463: PLUS
99464: STR
99465: PUSH
99466: LD_STRING ;
99468: STR
99469: ST_TO_ADDR
// end ;
99470: GO 99425
99472: POP
99473: POP
// if tmp then
99474: LD_VAR 0 3
99478: IFFALSE 99490
// active := tmp ;
99480: LD_ADDR_VAR 0 7
99484: PUSH
99485: LD_VAR 0 3
99489: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
99490: LD_STRING getStreamItemsFromMission("
99492: PUSH
99493: LD_VAR 0 5
99497: STR
99498: PUSH
99499: LD_STRING ","
99501: STR
99502: PUSH
99503: LD_VAR 0 6
99507: STR
99508: PUSH
99509: LD_STRING ","
99511: STR
99512: PUSH
99513: LD_VAR 0 7
99517: STR
99518: PUSH
99519: LD_STRING ")
99521: STR
99522: PPUSH
99523: CALL_OW 559
// end else
99527: GO 99536
// ToLua ( getStreamItemsFromMission("","","") ) ;
99529: LD_STRING getStreamItemsFromMission("","","")
99531: PPUSH
99532: CALL_OW 559
// end ;
99536: LD_VAR 0 2
99540: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
99541: LD_EXP 123
99545: PUSH
99546: LD_EXP 128
99550: AND
99551: IFFALSE 99675
99553: GO 99555
99555: DISABLE
99556: LD_INT 0
99558: PPUSH
99559: PPUSH
// begin enable ;
99560: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
99561: LD_ADDR_VAR 0 2
99565: PUSH
99566: LD_INT 22
99568: PUSH
99569: LD_OWVAR 2
99573: PUSH
99574: EMPTY
99575: LIST
99576: LIST
99577: PUSH
99578: LD_INT 2
99580: PUSH
99581: LD_INT 34
99583: PUSH
99584: LD_INT 7
99586: PUSH
99587: EMPTY
99588: LIST
99589: LIST
99590: PUSH
99591: LD_INT 34
99593: PUSH
99594: LD_INT 45
99596: PUSH
99597: EMPTY
99598: LIST
99599: LIST
99600: PUSH
99601: LD_INT 34
99603: PUSH
99604: LD_INT 28
99606: PUSH
99607: EMPTY
99608: LIST
99609: LIST
99610: PUSH
99611: LD_INT 34
99613: PUSH
99614: LD_INT 47
99616: PUSH
99617: EMPTY
99618: LIST
99619: LIST
99620: PUSH
99621: EMPTY
99622: LIST
99623: LIST
99624: LIST
99625: LIST
99626: LIST
99627: PUSH
99628: EMPTY
99629: LIST
99630: LIST
99631: PPUSH
99632: CALL_OW 69
99636: ST_TO_ADDR
// if not tmp then
99637: LD_VAR 0 2
99641: NOT
99642: IFFALSE 99646
// exit ;
99644: GO 99675
// for i in tmp do
99646: LD_ADDR_VAR 0 1
99650: PUSH
99651: LD_VAR 0 2
99655: PUSH
99656: FOR_IN
99657: IFFALSE 99673
// begin SetLives ( i , 0 ) ;
99659: LD_VAR 0 1
99663: PPUSH
99664: LD_INT 0
99666: PPUSH
99667: CALL_OW 234
// end ;
99671: GO 99656
99673: POP
99674: POP
// end ;
99675: PPOPN 2
99677: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
99678: LD_EXP 123
99682: PUSH
99683: LD_EXP 129
99687: AND
99688: IFFALSE 99772
99690: GO 99692
99692: DISABLE
99693: LD_INT 0
99695: PPUSH
99696: PPUSH
// begin enable ;
99697: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
99698: LD_ADDR_VAR 0 2
99702: PUSH
99703: LD_INT 22
99705: PUSH
99706: LD_OWVAR 2
99710: PUSH
99711: EMPTY
99712: LIST
99713: LIST
99714: PUSH
99715: LD_INT 32
99717: PUSH
99718: LD_INT 3
99720: PUSH
99721: EMPTY
99722: LIST
99723: LIST
99724: PUSH
99725: EMPTY
99726: LIST
99727: LIST
99728: PPUSH
99729: CALL_OW 69
99733: ST_TO_ADDR
// if not tmp then
99734: LD_VAR 0 2
99738: NOT
99739: IFFALSE 99743
// exit ;
99741: GO 99772
// for i in tmp do
99743: LD_ADDR_VAR 0 1
99747: PUSH
99748: LD_VAR 0 2
99752: PUSH
99753: FOR_IN
99754: IFFALSE 99770
// begin SetLives ( i , 0 ) ;
99756: LD_VAR 0 1
99760: PPUSH
99761: LD_INT 0
99763: PPUSH
99764: CALL_OW 234
// end ;
99768: GO 99753
99770: POP
99771: POP
// end ;
99772: PPOPN 2
99774: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
99775: LD_EXP 123
99779: PUSH
99780: LD_EXP 126
99784: AND
99785: IFFALSE 99878
99787: GO 99789
99789: DISABLE
99790: LD_INT 0
99792: PPUSH
// begin enable ;
99793: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
99794: LD_ADDR_VAR 0 1
99798: PUSH
99799: LD_INT 22
99801: PUSH
99802: LD_OWVAR 2
99806: PUSH
99807: EMPTY
99808: LIST
99809: LIST
99810: PUSH
99811: LD_INT 2
99813: PUSH
99814: LD_INT 25
99816: PUSH
99817: LD_INT 5
99819: PUSH
99820: EMPTY
99821: LIST
99822: LIST
99823: PUSH
99824: LD_INT 25
99826: PUSH
99827: LD_INT 9
99829: PUSH
99830: EMPTY
99831: LIST
99832: LIST
99833: PUSH
99834: LD_INT 25
99836: PUSH
99837: LD_INT 8
99839: PUSH
99840: EMPTY
99841: LIST
99842: LIST
99843: PUSH
99844: EMPTY
99845: LIST
99846: LIST
99847: LIST
99848: LIST
99849: PUSH
99850: EMPTY
99851: LIST
99852: LIST
99853: PPUSH
99854: CALL_OW 69
99858: PUSH
99859: FOR_IN
99860: IFFALSE 99876
// begin SetClass ( i , 1 ) ;
99862: LD_VAR 0 1
99866: PPUSH
99867: LD_INT 1
99869: PPUSH
99870: CALL_OW 336
// end ;
99874: GO 99859
99876: POP
99877: POP
// end ;
99878: PPOPN 1
99880: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
99881: LD_EXP 123
99885: PUSH
99886: LD_EXP 127
99890: AND
99891: PUSH
99892: LD_OWVAR 65
99896: PUSH
99897: LD_INT 7
99899: LESS
99900: AND
99901: IFFALSE 99915
99903: GO 99905
99905: DISABLE
// begin enable ;
99906: ENABLE
// game_speed := 7 ;
99907: LD_ADDR_OWVAR 65
99911: PUSH
99912: LD_INT 7
99914: ST_TO_ADDR
// end ;
99915: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
99916: LD_EXP 123
99920: PUSH
99921: LD_EXP 130
99925: AND
99926: IFFALSE 100128
99928: GO 99930
99930: DISABLE
99931: LD_INT 0
99933: PPUSH
99934: PPUSH
99935: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
99936: LD_ADDR_VAR 0 3
99940: PUSH
99941: LD_INT 81
99943: PUSH
99944: LD_OWVAR 2
99948: PUSH
99949: EMPTY
99950: LIST
99951: LIST
99952: PUSH
99953: LD_INT 21
99955: PUSH
99956: LD_INT 1
99958: PUSH
99959: EMPTY
99960: LIST
99961: LIST
99962: PUSH
99963: EMPTY
99964: LIST
99965: LIST
99966: PPUSH
99967: CALL_OW 69
99971: ST_TO_ADDR
// if not tmp then
99972: LD_VAR 0 3
99976: NOT
99977: IFFALSE 99981
// exit ;
99979: GO 100128
// if tmp > 5 then
99981: LD_VAR 0 3
99985: PUSH
99986: LD_INT 5
99988: GREATER
99989: IFFALSE 100001
// k := 5 else
99991: LD_ADDR_VAR 0 2
99995: PUSH
99996: LD_INT 5
99998: ST_TO_ADDR
99999: GO 100011
// k := tmp ;
100001: LD_ADDR_VAR 0 2
100005: PUSH
100006: LD_VAR 0 3
100010: ST_TO_ADDR
// for i := 1 to k do
100011: LD_ADDR_VAR 0 1
100015: PUSH
100016: DOUBLE
100017: LD_INT 1
100019: DEC
100020: ST_TO_ADDR
100021: LD_VAR 0 2
100025: PUSH
100026: FOR_TO
100027: IFFALSE 100126
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
100029: LD_VAR 0 3
100033: PUSH
100034: LD_VAR 0 1
100038: ARRAY
100039: PPUSH
100040: LD_VAR 0 1
100044: PUSH
100045: LD_INT 4
100047: MOD
100048: PUSH
100049: LD_INT 1
100051: PLUS
100052: PPUSH
100053: CALL_OW 259
100057: PUSH
100058: LD_INT 10
100060: LESS
100061: IFFALSE 100124
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
100063: LD_VAR 0 3
100067: PUSH
100068: LD_VAR 0 1
100072: ARRAY
100073: PPUSH
100074: LD_VAR 0 1
100078: PUSH
100079: LD_INT 4
100081: MOD
100082: PUSH
100083: LD_INT 1
100085: PLUS
100086: PPUSH
100087: LD_VAR 0 3
100091: PUSH
100092: LD_VAR 0 1
100096: ARRAY
100097: PPUSH
100098: LD_VAR 0 1
100102: PUSH
100103: LD_INT 4
100105: MOD
100106: PUSH
100107: LD_INT 1
100109: PLUS
100110: PPUSH
100111: CALL_OW 259
100115: PUSH
100116: LD_INT 1
100118: PLUS
100119: PPUSH
100120: CALL_OW 237
100124: GO 100026
100126: POP
100127: POP
// end ;
100128: PPOPN 3
100130: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
100131: LD_EXP 123
100135: PUSH
100136: LD_EXP 131
100140: AND
100141: IFFALSE 100161
100143: GO 100145
100145: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
100146: LD_INT 4
100148: PPUSH
100149: LD_OWVAR 2
100153: PPUSH
100154: LD_INT 0
100156: PPUSH
100157: CALL_OW 324
100161: END
// every 0 0$1 trigger StreamModeActive and sShovel do
100162: LD_EXP 123
100166: PUSH
100167: LD_EXP 160
100171: AND
100172: IFFALSE 100192
100174: GO 100176
100176: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
100177: LD_INT 19
100179: PPUSH
100180: LD_OWVAR 2
100184: PPUSH
100185: LD_INT 0
100187: PPUSH
100188: CALL_OW 324
100192: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
100193: LD_EXP 123
100197: PUSH
100198: LD_EXP 132
100202: AND
100203: IFFALSE 100305
100205: GO 100207
100207: DISABLE
100208: LD_INT 0
100210: PPUSH
100211: PPUSH
// begin enable ;
100212: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
100213: LD_ADDR_VAR 0 2
100217: PUSH
100218: LD_INT 22
100220: PUSH
100221: LD_OWVAR 2
100225: PUSH
100226: EMPTY
100227: LIST
100228: LIST
100229: PUSH
100230: LD_INT 2
100232: PUSH
100233: LD_INT 34
100235: PUSH
100236: LD_INT 11
100238: PUSH
100239: EMPTY
100240: LIST
100241: LIST
100242: PUSH
100243: LD_INT 34
100245: PUSH
100246: LD_INT 30
100248: PUSH
100249: EMPTY
100250: LIST
100251: LIST
100252: PUSH
100253: EMPTY
100254: LIST
100255: LIST
100256: LIST
100257: PUSH
100258: EMPTY
100259: LIST
100260: LIST
100261: PPUSH
100262: CALL_OW 69
100266: ST_TO_ADDR
// if not tmp then
100267: LD_VAR 0 2
100271: NOT
100272: IFFALSE 100276
// exit ;
100274: GO 100305
// for i in tmp do
100276: LD_ADDR_VAR 0 1
100280: PUSH
100281: LD_VAR 0 2
100285: PUSH
100286: FOR_IN
100287: IFFALSE 100303
// begin SetLives ( i , 0 ) ;
100289: LD_VAR 0 1
100293: PPUSH
100294: LD_INT 0
100296: PPUSH
100297: CALL_OW 234
// end ;
100301: GO 100286
100303: POP
100304: POP
// end ;
100305: PPOPN 2
100307: END
// every 0 0$1 trigger StreamModeActive and sBunker do
100308: LD_EXP 123
100312: PUSH
100313: LD_EXP 133
100317: AND
100318: IFFALSE 100338
100320: GO 100322
100322: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
100323: LD_INT 32
100325: PPUSH
100326: LD_OWVAR 2
100330: PPUSH
100331: LD_INT 0
100333: PPUSH
100334: CALL_OW 324
100338: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
100339: LD_EXP 123
100343: PUSH
100344: LD_EXP 134
100348: AND
100349: IFFALSE 100530
100351: GO 100353
100353: DISABLE
100354: LD_INT 0
100356: PPUSH
100357: PPUSH
100358: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
100359: LD_ADDR_VAR 0 2
100363: PUSH
100364: LD_INT 22
100366: PUSH
100367: LD_OWVAR 2
100371: PUSH
100372: EMPTY
100373: LIST
100374: LIST
100375: PUSH
100376: LD_INT 33
100378: PUSH
100379: LD_INT 3
100381: PUSH
100382: EMPTY
100383: LIST
100384: LIST
100385: PUSH
100386: EMPTY
100387: LIST
100388: LIST
100389: PPUSH
100390: CALL_OW 69
100394: ST_TO_ADDR
// if not tmp then
100395: LD_VAR 0 2
100399: NOT
100400: IFFALSE 100404
// exit ;
100402: GO 100530
// side := 0 ;
100404: LD_ADDR_VAR 0 3
100408: PUSH
100409: LD_INT 0
100411: ST_TO_ADDR
// for i := 1 to 8 do
100412: LD_ADDR_VAR 0 1
100416: PUSH
100417: DOUBLE
100418: LD_INT 1
100420: DEC
100421: ST_TO_ADDR
100422: LD_INT 8
100424: PUSH
100425: FOR_TO
100426: IFFALSE 100474
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
100428: LD_OWVAR 2
100432: PUSH
100433: LD_VAR 0 1
100437: NONEQUAL
100438: PUSH
100439: LD_OWVAR 2
100443: PPUSH
100444: LD_VAR 0 1
100448: PPUSH
100449: CALL_OW 81
100453: PUSH
100454: LD_INT 2
100456: EQUAL
100457: AND
100458: IFFALSE 100472
// begin side := i ;
100460: LD_ADDR_VAR 0 3
100464: PUSH
100465: LD_VAR 0 1
100469: ST_TO_ADDR
// break ;
100470: GO 100474
// end ;
100472: GO 100425
100474: POP
100475: POP
// if not side then
100476: LD_VAR 0 3
100480: NOT
100481: IFFALSE 100485
// exit ;
100483: GO 100530
// for i := 1 to tmp do
100485: LD_ADDR_VAR 0 1
100489: PUSH
100490: DOUBLE
100491: LD_INT 1
100493: DEC
100494: ST_TO_ADDR
100495: LD_VAR 0 2
100499: PUSH
100500: FOR_TO
100501: IFFALSE 100528
// if Prob ( 60 ) then
100503: LD_INT 60
100505: PPUSH
100506: CALL_OW 13
100510: IFFALSE 100526
// SetSide ( i , side ) ;
100512: LD_VAR 0 1
100516: PPUSH
100517: LD_VAR 0 3
100521: PPUSH
100522: CALL_OW 235
100526: GO 100500
100528: POP
100529: POP
// end ;
100530: PPOPN 3
100532: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
100533: LD_EXP 123
100537: PUSH
100538: LD_EXP 136
100542: AND
100543: IFFALSE 100662
100545: GO 100547
100547: DISABLE
100548: LD_INT 0
100550: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
100551: LD_ADDR_VAR 0 1
100555: PUSH
100556: LD_INT 22
100558: PUSH
100559: LD_OWVAR 2
100563: PUSH
100564: EMPTY
100565: LIST
100566: LIST
100567: PUSH
100568: LD_INT 21
100570: PUSH
100571: LD_INT 1
100573: PUSH
100574: EMPTY
100575: LIST
100576: LIST
100577: PUSH
100578: LD_INT 3
100580: PUSH
100581: LD_INT 23
100583: PUSH
100584: LD_INT 0
100586: PUSH
100587: EMPTY
100588: LIST
100589: LIST
100590: PUSH
100591: EMPTY
100592: LIST
100593: LIST
100594: PUSH
100595: EMPTY
100596: LIST
100597: LIST
100598: LIST
100599: PPUSH
100600: CALL_OW 69
100604: PUSH
100605: FOR_IN
100606: IFFALSE 100660
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
100608: LD_VAR 0 1
100612: PPUSH
100613: CALL_OW 257
100617: PUSH
100618: LD_INT 1
100620: PUSH
100621: LD_INT 2
100623: PUSH
100624: LD_INT 3
100626: PUSH
100627: LD_INT 4
100629: PUSH
100630: EMPTY
100631: LIST
100632: LIST
100633: LIST
100634: LIST
100635: IN
100636: IFFALSE 100658
// SetClass ( un , rand ( 1 , 4 ) ) ;
100638: LD_VAR 0 1
100642: PPUSH
100643: LD_INT 1
100645: PPUSH
100646: LD_INT 4
100648: PPUSH
100649: CALL_OW 12
100653: PPUSH
100654: CALL_OW 336
100658: GO 100605
100660: POP
100661: POP
// end ;
100662: PPOPN 1
100664: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
100665: LD_EXP 123
100669: PUSH
100670: LD_EXP 135
100674: AND
100675: IFFALSE 100754
100677: GO 100679
100679: DISABLE
100680: LD_INT 0
100682: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
100683: LD_ADDR_VAR 0 1
100687: PUSH
100688: LD_INT 22
100690: PUSH
100691: LD_OWVAR 2
100695: PUSH
100696: EMPTY
100697: LIST
100698: LIST
100699: PUSH
100700: LD_INT 21
100702: PUSH
100703: LD_INT 3
100705: PUSH
100706: EMPTY
100707: LIST
100708: LIST
100709: PUSH
100710: EMPTY
100711: LIST
100712: LIST
100713: PPUSH
100714: CALL_OW 69
100718: ST_TO_ADDR
// if not tmp then
100719: LD_VAR 0 1
100723: NOT
100724: IFFALSE 100728
// exit ;
100726: GO 100754
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
100728: LD_VAR 0 1
100732: PUSH
100733: LD_INT 1
100735: PPUSH
100736: LD_VAR 0 1
100740: PPUSH
100741: CALL_OW 12
100745: ARRAY
100746: PPUSH
100747: LD_INT 100
100749: PPUSH
100750: CALL_OW 234
// end ;
100754: PPOPN 1
100756: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
100757: LD_EXP 123
100761: PUSH
100762: LD_EXP 137
100766: AND
100767: IFFALSE 100865
100769: GO 100771
100771: DISABLE
100772: LD_INT 0
100774: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
100775: LD_ADDR_VAR 0 1
100779: PUSH
100780: LD_INT 22
100782: PUSH
100783: LD_OWVAR 2
100787: PUSH
100788: EMPTY
100789: LIST
100790: LIST
100791: PUSH
100792: LD_INT 21
100794: PUSH
100795: LD_INT 1
100797: PUSH
100798: EMPTY
100799: LIST
100800: LIST
100801: PUSH
100802: EMPTY
100803: LIST
100804: LIST
100805: PPUSH
100806: CALL_OW 69
100810: ST_TO_ADDR
// if not tmp then
100811: LD_VAR 0 1
100815: NOT
100816: IFFALSE 100820
// exit ;
100818: GO 100865
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
100820: LD_VAR 0 1
100824: PUSH
100825: LD_INT 1
100827: PPUSH
100828: LD_VAR 0 1
100832: PPUSH
100833: CALL_OW 12
100837: ARRAY
100838: PPUSH
100839: LD_INT 1
100841: PPUSH
100842: LD_INT 4
100844: PPUSH
100845: CALL_OW 12
100849: PPUSH
100850: LD_INT 3000
100852: PPUSH
100853: LD_INT 9000
100855: PPUSH
100856: CALL_OW 12
100860: PPUSH
100861: CALL_OW 492
// end ;
100865: PPOPN 1
100867: END
// every 0 0$1 trigger StreamModeActive and sDepot do
100868: LD_EXP 123
100872: PUSH
100873: LD_EXP 138
100877: AND
100878: IFFALSE 100898
100880: GO 100882
100882: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
100883: LD_INT 1
100885: PPUSH
100886: LD_OWVAR 2
100890: PPUSH
100891: LD_INT 0
100893: PPUSH
100894: CALL_OW 324
100898: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
100899: LD_EXP 123
100903: PUSH
100904: LD_EXP 139
100908: AND
100909: IFFALSE 100992
100911: GO 100913
100913: DISABLE
100914: LD_INT 0
100916: PPUSH
100917: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
100918: LD_ADDR_VAR 0 2
100922: PUSH
100923: LD_INT 22
100925: PUSH
100926: LD_OWVAR 2
100930: PUSH
100931: EMPTY
100932: LIST
100933: LIST
100934: PUSH
100935: LD_INT 21
100937: PUSH
100938: LD_INT 3
100940: PUSH
100941: EMPTY
100942: LIST
100943: LIST
100944: PUSH
100945: EMPTY
100946: LIST
100947: LIST
100948: PPUSH
100949: CALL_OW 69
100953: ST_TO_ADDR
// if not tmp then
100954: LD_VAR 0 2
100958: NOT
100959: IFFALSE 100963
// exit ;
100961: GO 100992
// for i in tmp do
100963: LD_ADDR_VAR 0 1
100967: PUSH
100968: LD_VAR 0 2
100972: PUSH
100973: FOR_IN
100974: IFFALSE 100990
// SetBLevel ( i , 10 ) ;
100976: LD_VAR 0 1
100980: PPUSH
100981: LD_INT 10
100983: PPUSH
100984: CALL_OW 241
100988: GO 100973
100990: POP
100991: POP
// end ;
100992: PPOPN 2
100994: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
100995: LD_EXP 123
100999: PUSH
101000: LD_EXP 140
101004: AND
101005: IFFALSE 101116
101007: GO 101009
101009: DISABLE
101010: LD_INT 0
101012: PPUSH
101013: PPUSH
101014: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101015: LD_ADDR_VAR 0 3
101019: PUSH
101020: LD_INT 22
101022: PUSH
101023: LD_OWVAR 2
101027: PUSH
101028: EMPTY
101029: LIST
101030: LIST
101031: PUSH
101032: LD_INT 25
101034: PUSH
101035: LD_INT 1
101037: PUSH
101038: EMPTY
101039: LIST
101040: LIST
101041: PUSH
101042: EMPTY
101043: LIST
101044: LIST
101045: PPUSH
101046: CALL_OW 69
101050: ST_TO_ADDR
// if not tmp then
101051: LD_VAR 0 3
101055: NOT
101056: IFFALSE 101060
// exit ;
101058: GO 101116
// un := tmp [ rand ( 1 , tmp ) ] ;
101060: LD_ADDR_VAR 0 2
101064: PUSH
101065: LD_VAR 0 3
101069: PUSH
101070: LD_INT 1
101072: PPUSH
101073: LD_VAR 0 3
101077: PPUSH
101078: CALL_OW 12
101082: ARRAY
101083: ST_TO_ADDR
// if Crawls ( un ) then
101084: LD_VAR 0 2
101088: PPUSH
101089: CALL_OW 318
101093: IFFALSE 101104
// ComWalk ( un ) ;
101095: LD_VAR 0 2
101099: PPUSH
101100: CALL_OW 138
// SetClass ( un , class_sniper ) ;
101104: LD_VAR 0 2
101108: PPUSH
101109: LD_INT 5
101111: PPUSH
101112: CALL_OW 336
// end ;
101116: PPOPN 3
101118: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
101119: LD_EXP 123
101123: PUSH
101124: LD_EXP 141
101128: AND
101129: PUSH
101130: LD_OWVAR 67
101134: PUSH
101135: LD_INT 4
101137: LESS
101138: AND
101139: IFFALSE 101158
101141: GO 101143
101143: DISABLE
// begin Difficulty := Difficulty + 1 ;
101144: LD_ADDR_OWVAR 67
101148: PUSH
101149: LD_OWVAR 67
101153: PUSH
101154: LD_INT 1
101156: PLUS
101157: ST_TO_ADDR
// end ;
101158: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
101159: LD_EXP 123
101163: PUSH
101164: LD_EXP 142
101168: AND
101169: IFFALSE 101272
101171: GO 101173
101173: DISABLE
101174: LD_INT 0
101176: PPUSH
// begin for i := 1 to 5 do
101177: LD_ADDR_VAR 0 1
101181: PUSH
101182: DOUBLE
101183: LD_INT 1
101185: DEC
101186: ST_TO_ADDR
101187: LD_INT 5
101189: PUSH
101190: FOR_TO
101191: IFFALSE 101270
// begin uc_nation := nation_nature ;
101193: LD_ADDR_OWVAR 21
101197: PUSH
101198: LD_INT 0
101200: ST_TO_ADDR
// uc_side := 0 ;
101201: LD_ADDR_OWVAR 20
101205: PUSH
101206: LD_INT 0
101208: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
101209: LD_ADDR_OWVAR 29
101213: PUSH
101214: LD_INT 12
101216: PUSH
101217: LD_INT 12
101219: PUSH
101220: EMPTY
101221: LIST
101222: LIST
101223: ST_TO_ADDR
// hc_agressivity := 20 ;
101224: LD_ADDR_OWVAR 35
101228: PUSH
101229: LD_INT 20
101231: ST_TO_ADDR
// hc_class := class_tiger ;
101232: LD_ADDR_OWVAR 28
101236: PUSH
101237: LD_INT 14
101239: ST_TO_ADDR
// hc_gallery :=  ;
101240: LD_ADDR_OWVAR 33
101244: PUSH
101245: LD_STRING 
101247: ST_TO_ADDR
// hc_name :=  ;
101248: LD_ADDR_OWVAR 26
101252: PUSH
101253: LD_STRING 
101255: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
101256: CALL_OW 44
101260: PPUSH
101261: LD_INT 0
101263: PPUSH
101264: CALL_OW 51
// end ;
101268: GO 101190
101270: POP
101271: POP
// end ;
101272: PPOPN 1
101274: END
// every 0 0$1 trigger StreamModeActive and sBomb do
101275: LD_EXP 123
101279: PUSH
101280: LD_EXP 143
101284: AND
101285: IFFALSE 101294
101287: GO 101289
101289: DISABLE
// StreamSibBomb ;
101290: CALL 101295 0 0
101294: END
// export function StreamSibBomb ; var i , x , y ; begin
101295: LD_INT 0
101297: PPUSH
101298: PPUSH
101299: PPUSH
101300: PPUSH
// result := false ;
101301: LD_ADDR_VAR 0 1
101305: PUSH
101306: LD_INT 0
101308: ST_TO_ADDR
// for i := 1 to 16 do
101309: LD_ADDR_VAR 0 2
101313: PUSH
101314: DOUBLE
101315: LD_INT 1
101317: DEC
101318: ST_TO_ADDR
101319: LD_INT 16
101321: PUSH
101322: FOR_TO
101323: IFFALSE 101522
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
101325: LD_ADDR_VAR 0 3
101329: PUSH
101330: LD_INT 10
101332: PUSH
101333: LD_INT 20
101335: PUSH
101336: LD_INT 30
101338: PUSH
101339: LD_INT 40
101341: PUSH
101342: LD_INT 50
101344: PUSH
101345: LD_INT 60
101347: PUSH
101348: LD_INT 70
101350: PUSH
101351: LD_INT 80
101353: PUSH
101354: LD_INT 90
101356: PUSH
101357: LD_INT 100
101359: PUSH
101360: LD_INT 110
101362: PUSH
101363: LD_INT 120
101365: PUSH
101366: LD_INT 130
101368: PUSH
101369: LD_INT 140
101371: PUSH
101372: LD_INT 150
101374: PUSH
101375: EMPTY
101376: LIST
101377: LIST
101378: LIST
101379: LIST
101380: LIST
101381: LIST
101382: LIST
101383: LIST
101384: LIST
101385: LIST
101386: LIST
101387: LIST
101388: LIST
101389: LIST
101390: LIST
101391: PUSH
101392: LD_INT 1
101394: PPUSH
101395: LD_INT 15
101397: PPUSH
101398: CALL_OW 12
101402: ARRAY
101403: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
101404: LD_ADDR_VAR 0 4
101408: PUSH
101409: LD_INT 10
101411: PUSH
101412: LD_INT 20
101414: PUSH
101415: LD_INT 30
101417: PUSH
101418: LD_INT 40
101420: PUSH
101421: LD_INT 50
101423: PUSH
101424: LD_INT 60
101426: PUSH
101427: LD_INT 70
101429: PUSH
101430: LD_INT 80
101432: PUSH
101433: LD_INT 90
101435: PUSH
101436: LD_INT 100
101438: PUSH
101439: LD_INT 110
101441: PUSH
101442: LD_INT 120
101444: PUSH
101445: LD_INT 130
101447: PUSH
101448: LD_INT 140
101450: PUSH
101451: LD_INT 150
101453: PUSH
101454: EMPTY
101455: LIST
101456: LIST
101457: LIST
101458: LIST
101459: LIST
101460: LIST
101461: LIST
101462: LIST
101463: LIST
101464: LIST
101465: LIST
101466: LIST
101467: LIST
101468: LIST
101469: LIST
101470: PUSH
101471: LD_INT 1
101473: PPUSH
101474: LD_INT 15
101476: PPUSH
101477: CALL_OW 12
101481: ARRAY
101482: ST_TO_ADDR
// if ValidHex ( x , y ) then
101483: LD_VAR 0 3
101487: PPUSH
101488: LD_VAR 0 4
101492: PPUSH
101493: CALL_OW 488
101497: IFFALSE 101520
// begin result := [ x , y ] ;
101499: LD_ADDR_VAR 0 1
101503: PUSH
101504: LD_VAR 0 3
101508: PUSH
101509: LD_VAR 0 4
101513: PUSH
101514: EMPTY
101515: LIST
101516: LIST
101517: ST_TO_ADDR
// break ;
101518: GO 101522
// end ; end ;
101520: GO 101322
101522: POP
101523: POP
// if result then
101524: LD_VAR 0 1
101528: IFFALSE 101588
// begin ToLua ( playSibBomb() ) ;
101530: LD_STRING playSibBomb()
101532: PPUSH
101533: CALL_OW 559
// wait ( 0 0$14 ) ;
101537: LD_INT 490
101539: PPUSH
101540: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
101544: LD_VAR 0 1
101548: PUSH
101549: LD_INT 1
101551: ARRAY
101552: PPUSH
101553: LD_VAR 0 1
101557: PUSH
101558: LD_INT 2
101560: ARRAY
101561: PPUSH
101562: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
101566: LD_VAR 0 1
101570: PUSH
101571: LD_INT 1
101573: ARRAY
101574: PPUSH
101575: LD_VAR 0 1
101579: PUSH
101580: LD_INT 2
101582: ARRAY
101583: PPUSH
101584: CALL_OW 429
// end ; end ;
101588: LD_VAR 0 1
101592: RET
// every 0 0$1 trigger StreamModeActive and sReset do
101593: LD_EXP 123
101597: PUSH
101598: LD_EXP 145
101602: AND
101603: IFFALSE 101615
101605: GO 101607
101607: DISABLE
// YouLost (  ) ;
101608: LD_STRING 
101610: PPUSH
101611: CALL_OW 104
101615: END
// every 0 0$1 trigger StreamModeActive and sFog do
101616: LD_EXP 123
101620: PUSH
101621: LD_EXP 144
101625: AND
101626: IFFALSE 101640
101628: GO 101630
101630: DISABLE
// FogOff ( your_side ) ;
101631: LD_OWVAR 2
101635: PPUSH
101636: CALL_OW 344
101640: END
// every 0 0$1 trigger StreamModeActive and sSun do
101641: LD_EXP 123
101645: PUSH
101646: LD_EXP 146
101650: AND
101651: IFFALSE 101679
101653: GO 101655
101655: DISABLE
// begin solar_recharge_percent := 0 ;
101656: LD_ADDR_OWVAR 79
101660: PUSH
101661: LD_INT 0
101663: ST_TO_ADDR
// wait ( 5 5$00 ) ;
101664: LD_INT 10500
101666: PPUSH
101667: CALL_OW 67
// solar_recharge_percent := 100 ;
101671: LD_ADDR_OWVAR 79
101675: PUSH
101676: LD_INT 100
101678: ST_TO_ADDR
// end ;
101679: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
101680: LD_EXP 123
101684: PUSH
101685: LD_EXP 147
101689: AND
101690: IFFALSE 101929
101692: GO 101694
101694: DISABLE
101695: LD_INT 0
101697: PPUSH
101698: PPUSH
101699: PPUSH
// begin tmp := [ ] ;
101700: LD_ADDR_VAR 0 3
101704: PUSH
101705: EMPTY
101706: ST_TO_ADDR
// for i := 1 to 6 do
101707: LD_ADDR_VAR 0 1
101711: PUSH
101712: DOUBLE
101713: LD_INT 1
101715: DEC
101716: ST_TO_ADDR
101717: LD_INT 6
101719: PUSH
101720: FOR_TO
101721: IFFALSE 101826
// begin uc_nation := nation_nature ;
101723: LD_ADDR_OWVAR 21
101727: PUSH
101728: LD_INT 0
101730: ST_TO_ADDR
// uc_side := 0 ;
101731: LD_ADDR_OWVAR 20
101735: PUSH
101736: LD_INT 0
101738: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
101739: LD_ADDR_OWVAR 29
101743: PUSH
101744: LD_INT 12
101746: PUSH
101747: LD_INT 12
101749: PUSH
101750: EMPTY
101751: LIST
101752: LIST
101753: ST_TO_ADDR
// hc_agressivity := 20 ;
101754: LD_ADDR_OWVAR 35
101758: PUSH
101759: LD_INT 20
101761: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
101762: LD_ADDR_OWVAR 28
101766: PUSH
101767: LD_INT 17
101769: ST_TO_ADDR
// hc_gallery :=  ;
101770: LD_ADDR_OWVAR 33
101774: PUSH
101775: LD_STRING 
101777: ST_TO_ADDR
// hc_name :=  ;
101778: LD_ADDR_OWVAR 26
101782: PUSH
101783: LD_STRING 
101785: ST_TO_ADDR
// un := CreateHuman ;
101786: LD_ADDR_VAR 0 2
101790: PUSH
101791: CALL_OW 44
101795: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
101796: LD_VAR 0 2
101800: PPUSH
101801: LD_INT 1
101803: PPUSH
101804: CALL_OW 51
// tmp := tmp ^ un ;
101808: LD_ADDR_VAR 0 3
101812: PUSH
101813: LD_VAR 0 3
101817: PUSH
101818: LD_VAR 0 2
101822: ADD
101823: ST_TO_ADDR
// end ;
101824: GO 101720
101826: POP
101827: POP
// repeat wait ( 0 0$1 ) ;
101828: LD_INT 35
101830: PPUSH
101831: CALL_OW 67
// for un in tmp do
101835: LD_ADDR_VAR 0 2
101839: PUSH
101840: LD_VAR 0 3
101844: PUSH
101845: FOR_IN
101846: IFFALSE 101920
// begin if IsDead ( un ) then
101848: LD_VAR 0 2
101852: PPUSH
101853: CALL_OW 301
101857: IFFALSE 101877
// begin tmp := tmp diff un ;
101859: LD_ADDR_VAR 0 3
101863: PUSH
101864: LD_VAR 0 3
101868: PUSH
101869: LD_VAR 0 2
101873: DIFF
101874: ST_TO_ADDR
// continue ;
101875: GO 101845
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
101877: LD_VAR 0 2
101881: PPUSH
101882: LD_INT 3
101884: PUSH
101885: LD_INT 22
101887: PUSH
101888: LD_INT 0
101890: PUSH
101891: EMPTY
101892: LIST
101893: LIST
101894: PUSH
101895: EMPTY
101896: LIST
101897: LIST
101898: PPUSH
101899: CALL_OW 69
101903: PPUSH
101904: LD_VAR 0 2
101908: PPUSH
101909: CALL_OW 74
101913: PPUSH
101914: CALL_OW 115
// end ;
101918: GO 101845
101920: POP
101921: POP
// until not tmp ;
101922: LD_VAR 0 3
101926: NOT
101927: IFFALSE 101828
// end ;
101929: PPOPN 3
101931: END
// every 0 0$1 trigger StreamModeActive and sTroll do
101932: LD_EXP 123
101936: PUSH
101937: LD_EXP 148
101941: AND
101942: IFFALSE 101996
101944: GO 101946
101946: DISABLE
// begin ToLua ( displayTroll(); ) ;
101947: LD_STRING displayTroll();
101949: PPUSH
101950: CALL_OW 559
// wait ( 3 3$00 ) ;
101954: LD_INT 6300
101956: PPUSH
101957: CALL_OW 67
// ToLua ( hideTroll(); ) ;
101961: LD_STRING hideTroll();
101963: PPUSH
101964: CALL_OW 559
// wait ( 1 1$00 ) ;
101968: LD_INT 2100
101970: PPUSH
101971: CALL_OW 67
// ToLua ( displayTroll(); ) ;
101975: LD_STRING displayTroll();
101977: PPUSH
101978: CALL_OW 559
// wait ( 1 1$00 ) ;
101982: LD_INT 2100
101984: PPUSH
101985: CALL_OW 67
// ToLua ( hideTroll(); ) ;
101989: LD_STRING hideTroll();
101991: PPUSH
101992: CALL_OW 559
// end ;
101996: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
101997: LD_EXP 123
102001: PUSH
102002: LD_EXP 149
102006: AND
102007: IFFALSE 102070
102009: GO 102011
102011: DISABLE
102012: LD_INT 0
102014: PPUSH
// begin p := 0 ;
102015: LD_ADDR_VAR 0 1
102019: PUSH
102020: LD_INT 0
102022: ST_TO_ADDR
// repeat game_speed := 1 ;
102023: LD_ADDR_OWVAR 65
102027: PUSH
102028: LD_INT 1
102030: ST_TO_ADDR
// wait ( 0 0$1 ) ;
102031: LD_INT 35
102033: PPUSH
102034: CALL_OW 67
// p := p + 1 ;
102038: LD_ADDR_VAR 0 1
102042: PUSH
102043: LD_VAR 0 1
102047: PUSH
102048: LD_INT 1
102050: PLUS
102051: ST_TO_ADDR
// until p >= 60 ;
102052: LD_VAR 0 1
102056: PUSH
102057: LD_INT 60
102059: GREATEREQUAL
102060: IFFALSE 102023
// game_speed := 4 ;
102062: LD_ADDR_OWVAR 65
102066: PUSH
102067: LD_INT 4
102069: ST_TO_ADDR
// end ;
102070: PPOPN 1
102072: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
102073: LD_EXP 123
102077: PUSH
102078: LD_EXP 150
102082: AND
102083: IFFALSE 102229
102085: GO 102087
102087: DISABLE
102088: LD_INT 0
102090: PPUSH
102091: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
102092: LD_ADDR_VAR 0 1
102096: PUSH
102097: LD_INT 22
102099: PUSH
102100: LD_OWVAR 2
102104: PUSH
102105: EMPTY
102106: LIST
102107: LIST
102108: PUSH
102109: LD_INT 2
102111: PUSH
102112: LD_INT 30
102114: PUSH
102115: LD_INT 0
102117: PUSH
102118: EMPTY
102119: LIST
102120: LIST
102121: PUSH
102122: LD_INT 30
102124: PUSH
102125: LD_INT 1
102127: PUSH
102128: EMPTY
102129: LIST
102130: LIST
102131: PUSH
102132: EMPTY
102133: LIST
102134: LIST
102135: LIST
102136: PUSH
102137: EMPTY
102138: LIST
102139: LIST
102140: PPUSH
102141: CALL_OW 69
102145: ST_TO_ADDR
// if not depot then
102146: LD_VAR 0 1
102150: NOT
102151: IFFALSE 102155
// exit ;
102153: GO 102229
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
102155: LD_ADDR_VAR 0 2
102159: PUSH
102160: LD_VAR 0 1
102164: PUSH
102165: LD_INT 1
102167: PPUSH
102168: LD_VAR 0 1
102172: PPUSH
102173: CALL_OW 12
102177: ARRAY
102178: PPUSH
102179: CALL_OW 274
102183: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
102184: LD_VAR 0 2
102188: PPUSH
102189: LD_INT 1
102191: PPUSH
102192: LD_INT 0
102194: PPUSH
102195: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
102199: LD_VAR 0 2
102203: PPUSH
102204: LD_INT 2
102206: PPUSH
102207: LD_INT 0
102209: PPUSH
102210: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
102214: LD_VAR 0 2
102218: PPUSH
102219: LD_INT 3
102221: PPUSH
102222: LD_INT 0
102224: PPUSH
102225: CALL_OW 277
// end ;
102229: PPOPN 2
102231: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
102232: LD_EXP 123
102236: PUSH
102237: LD_EXP 151
102241: AND
102242: IFFALSE 102339
102244: GO 102246
102246: DISABLE
102247: LD_INT 0
102249: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102250: LD_ADDR_VAR 0 1
102254: PUSH
102255: LD_INT 22
102257: PUSH
102258: LD_OWVAR 2
102262: PUSH
102263: EMPTY
102264: LIST
102265: LIST
102266: PUSH
102267: LD_INT 21
102269: PUSH
102270: LD_INT 1
102272: PUSH
102273: EMPTY
102274: LIST
102275: LIST
102276: PUSH
102277: LD_INT 3
102279: PUSH
102280: LD_INT 23
102282: PUSH
102283: LD_INT 0
102285: PUSH
102286: EMPTY
102287: LIST
102288: LIST
102289: PUSH
102290: EMPTY
102291: LIST
102292: LIST
102293: PUSH
102294: EMPTY
102295: LIST
102296: LIST
102297: LIST
102298: PPUSH
102299: CALL_OW 69
102303: ST_TO_ADDR
// if not tmp then
102304: LD_VAR 0 1
102308: NOT
102309: IFFALSE 102313
// exit ;
102311: GO 102339
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
102313: LD_VAR 0 1
102317: PUSH
102318: LD_INT 1
102320: PPUSH
102321: LD_VAR 0 1
102325: PPUSH
102326: CALL_OW 12
102330: ARRAY
102331: PPUSH
102332: LD_INT 200
102334: PPUSH
102335: CALL_OW 234
// end ;
102339: PPOPN 1
102341: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
102342: LD_EXP 123
102346: PUSH
102347: LD_EXP 152
102351: AND
102352: IFFALSE 102431
102354: GO 102356
102356: DISABLE
102357: LD_INT 0
102359: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
102360: LD_ADDR_VAR 0 1
102364: PUSH
102365: LD_INT 22
102367: PUSH
102368: LD_OWVAR 2
102372: PUSH
102373: EMPTY
102374: LIST
102375: LIST
102376: PUSH
102377: LD_INT 21
102379: PUSH
102380: LD_INT 2
102382: PUSH
102383: EMPTY
102384: LIST
102385: LIST
102386: PUSH
102387: EMPTY
102388: LIST
102389: LIST
102390: PPUSH
102391: CALL_OW 69
102395: ST_TO_ADDR
// if not tmp then
102396: LD_VAR 0 1
102400: NOT
102401: IFFALSE 102405
// exit ;
102403: GO 102431
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
102405: LD_VAR 0 1
102409: PUSH
102410: LD_INT 1
102412: PPUSH
102413: LD_VAR 0 1
102417: PPUSH
102418: CALL_OW 12
102422: ARRAY
102423: PPUSH
102424: LD_INT 60
102426: PPUSH
102427: CALL_OW 234
// end ;
102431: PPOPN 1
102433: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
102434: LD_EXP 123
102438: PUSH
102439: LD_EXP 153
102443: AND
102444: IFFALSE 102543
102446: GO 102448
102448: DISABLE
102449: LD_INT 0
102451: PPUSH
102452: PPUSH
// begin enable ;
102453: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
102454: LD_ADDR_VAR 0 1
102458: PUSH
102459: LD_INT 22
102461: PUSH
102462: LD_OWVAR 2
102466: PUSH
102467: EMPTY
102468: LIST
102469: LIST
102470: PUSH
102471: LD_INT 61
102473: PUSH
102474: EMPTY
102475: LIST
102476: PUSH
102477: LD_INT 33
102479: PUSH
102480: LD_INT 2
102482: PUSH
102483: EMPTY
102484: LIST
102485: LIST
102486: PUSH
102487: EMPTY
102488: LIST
102489: LIST
102490: LIST
102491: PPUSH
102492: CALL_OW 69
102496: ST_TO_ADDR
// if not tmp then
102497: LD_VAR 0 1
102501: NOT
102502: IFFALSE 102506
// exit ;
102504: GO 102543
// for i in tmp do
102506: LD_ADDR_VAR 0 2
102510: PUSH
102511: LD_VAR 0 1
102515: PUSH
102516: FOR_IN
102517: IFFALSE 102541
// if IsControledBy ( i ) then
102519: LD_VAR 0 2
102523: PPUSH
102524: CALL_OW 312
102528: IFFALSE 102539
// ComUnlink ( i ) ;
102530: LD_VAR 0 2
102534: PPUSH
102535: CALL_OW 136
102539: GO 102516
102541: POP
102542: POP
// end ;
102543: PPOPN 2
102545: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
102546: LD_EXP 123
102550: PUSH
102551: LD_EXP 154
102555: AND
102556: IFFALSE 102696
102558: GO 102560
102560: DISABLE
102561: LD_INT 0
102563: PPUSH
102564: PPUSH
// begin ToLua ( displayPowell(); ) ;
102565: LD_STRING displayPowell();
102567: PPUSH
102568: CALL_OW 559
// uc_side := 0 ;
102572: LD_ADDR_OWVAR 20
102576: PUSH
102577: LD_INT 0
102579: ST_TO_ADDR
// uc_nation := 2 ;
102580: LD_ADDR_OWVAR 21
102584: PUSH
102585: LD_INT 2
102587: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
102588: LD_ADDR_OWVAR 37
102592: PUSH
102593: LD_INT 14
102595: ST_TO_ADDR
// vc_engine := engine_siberite ;
102596: LD_ADDR_OWVAR 39
102600: PUSH
102601: LD_INT 3
102603: ST_TO_ADDR
// vc_control := control_apeman ;
102604: LD_ADDR_OWVAR 38
102608: PUSH
102609: LD_INT 5
102611: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
102612: LD_ADDR_OWVAR 40
102616: PUSH
102617: LD_INT 29
102619: ST_TO_ADDR
// un := CreateVehicle ;
102620: LD_ADDR_VAR 0 2
102624: PUSH
102625: CALL_OW 45
102629: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102630: LD_VAR 0 2
102634: PPUSH
102635: LD_INT 1
102637: PPUSH
102638: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
102642: LD_INT 35
102644: PPUSH
102645: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
102649: LD_VAR 0 2
102653: PPUSH
102654: LD_INT 22
102656: PUSH
102657: LD_OWVAR 2
102661: PUSH
102662: EMPTY
102663: LIST
102664: LIST
102665: PPUSH
102666: CALL_OW 69
102670: PPUSH
102671: LD_VAR 0 2
102675: PPUSH
102676: CALL_OW 74
102680: PPUSH
102681: CALL_OW 115
// until IsDead ( un ) ;
102685: LD_VAR 0 2
102689: PPUSH
102690: CALL_OW 301
102694: IFFALSE 102642
// end ;
102696: PPOPN 2
102698: END
// every 0 0$1 trigger StreamModeActive and sStu do
102699: LD_EXP 123
102703: PUSH
102704: LD_EXP 162
102708: AND
102709: IFFALSE 102725
102711: GO 102713
102713: DISABLE
// begin ToLua ( displayStucuk(); ) ;
102714: LD_STRING displayStucuk();
102716: PPUSH
102717: CALL_OW 559
// ResetFog ;
102721: CALL_OW 335
// end ;
102725: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
102726: LD_EXP 123
102730: PUSH
102731: LD_EXP 155
102735: AND
102736: IFFALSE 102877
102738: GO 102740
102740: DISABLE
102741: LD_INT 0
102743: PPUSH
102744: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
102745: LD_ADDR_VAR 0 2
102749: PUSH
102750: LD_INT 22
102752: PUSH
102753: LD_OWVAR 2
102757: PUSH
102758: EMPTY
102759: LIST
102760: LIST
102761: PUSH
102762: LD_INT 21
102764: PUSH
102765: LD_INT 1
102767: PUSH
102768: EMPTY
102769: LIST
102770: LIST
102771: PUSH
102772: EMPTY
102773: LIST
102774: LIST
102775: PPUSH
102776: CALL_OW 69
102780: ST_TO_ADDR
// if not tmp then
102781: LD_VAR 0 2
102785: NOT
102786: IFFALSE 102790
// exit ;
102788: GO 102877
// un := tmp [ rand ( 1 , tmp ) ] ;
102790: LD_ADDR_VAR 0 1
102794: PUSH
102795: LD_VAR 0 2
102799: PUSH
102800: LD_INT 1
102802: PPUSH
102803: LD_VAR 0 2
102807: PPUSH
102808: CALL_OW 12
102812: ARRAY
102813: ST_TO_ADDR
// SetSide ( un , 0 ) ;
102814: LD_VAR 0 1
102818: PPUSH
102819: LD_INT 0
102821: PPUSH
102822: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
102826: LD_VAR 0 1
102830: PPUSH
102831: LD_OWVAR 3
102835: PUSH
102836: LD_VAR 0 1
102840: DIFF
102841: PPUSH
102842: LD_VAR 0 1
102846: PPUSH
102847: CALL_OW 74
102851: PPUSH
102852: CALL_OW 115
// wait ( 0 0$20 ) ;
102856: LD_INT 700
102858: PPUSH
102859: CALL_OW 67
// SetSide ( un , your_side ) ;
102863: LD_VAR 0 1
102867: PPUSH
102868: LD_OWVAR 2
102872: PPUSH
102873: CALL_OW 235
// end ;
102877: PPOPN 2
102879: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
102880: LD_EXP 123
102884: PUSH
102885: LD_EXP 156
102889: AND
102890: IFFALSE 102996
102892: GO 102894
102894: DISABLE
102895: LD_INT 0
102897: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
102898: LD_ADDR_VAR 0 1
102902: PUSH
102903: LD_INT 22
102905: PUSH
102906: LD_OWVAR 2
102910: PUSH
102911: EMPTY
102912: LIST
102913: LIST
102914: PUSH
102915: LD_INT 2
102917: PUSH
102918: LD_INT 30
102920: PUSH
102921: LD_INT 0
102923: PUSH
102924: EMPTY
102925: LIST
102926: LIST
102927: PUSH
102928: LD_INT 30
102930: PUSH
102931: LD_INT 1
102933: PUSH
102934: EMPTY
102935: LIST
102936: LIST
102937: PUSH
102938: EMPTY
102939: LIST
102940: LIST
102941: LIST
102942: PUSH
102943: EMPTY
102944: LIST
102945: LIST
102946: PPUSH
102947: CALL_OW 69
102951: ST_TO_ADDR
// if not depot then
102952: LD_VAR 0 1
102956: NOT
102957: IFFALSE 102961
// exit ;
102959: GO 102996
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
102961: LD_VAR 0 1
102965: PUSH
102966: LD_INT 1
102968: ARRAY
102969: PPUSH
102970: CALL_OW 250
102974: PPUSH
102975: LD_VAR 0 1
102979: PUSH
102980: LD_INT 1
102982: ARRAY
102983: PPUSH
102984: CALL_OW 251
102988: PPUSH
102989: LD_INT 70
102991: PPUSH
102992: CALL_OW 495
// end ;
102996: PPOPN 1
102998: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
102999: LD_EXP 123
103003: PUSH
103004: LD_EXP 157
103008: AND
103009: IFFALSE 103220
103011: GO 103013
103013: DISABLE
103014: LD_INT 0
103016: PPUSH
103017: PPUSH
103018: PPUSH
103019: PPUSH
103020: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
103021: LD_ADDR_VAR 0 5
103025: PUSH
103026: LD_INT 22
103028: PUSH
103029: LD_OWVAR 2
103033: PUSH
103034: EMPTY
103035: LIST
103036: LIST
103037: PUSH
103038: LD_INT 21
103040: PUSH
103041: LD_INT 1
103043: PUSH
103044: EMPTY
103045: LIST
103046: LIST
103047: PUSH
103048: EMPTY
103049: LIST
103050: LIST
103051: PPUSH
103052: CALL_OW 69
103056: ST_TO_ADDR
// if not tmp then
103057: LD_VAR 0 5
103061: NOT
103062: IFFALSE 103066
// exit ;
103064: GO 103220
// for i in tmp do
103066: LD_ADDR_VAR 0 1
103070: PUSH
103071: LD_VAR 0 5
103075: PUSH
103076: FOR_IN
103077: IFFALSE 103218
// begin d := rand ( 0 , 5 ) ;
103079: LD_ADDR_VAR 0 4
103083: PUSH
103084: LD_INT 0
103086: PPUSH
103087: LD_INT 5
103089: PPUSH
103090: CALL_OW 12
103094: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
103095: LD_ADDR_VAR 0 2
103099: PUSH
103100: LD_VAR 0 1
103104: PPUSH
103105: CALL_OW 250
103109: PPUSH
103110: LD_VAR 0 4
103114: PPUSH
103115: LD_INT 3
103117: PPUSH
103118: LD_INT 12
103120: PPUSH
103121: CALL_OW 12
103125: PPUSH
103126: CALL_OW 272
103130: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
103131: LD_ADDR_VAR 0 3
103135: PUSH
103136: LD_VAR 0 1
103140: PPUSH
103141: CALL_OW 251
103145: PPUSH
103146: LD_VAR 0 4
103150: PPUSH
103151: LD_INT 3
103153: PPUSH
103154: LD_INT 12
103156: PPUSH
103157: CALL_OW 12
103161: PPUSH
103162: CALL_OW 273
103166: ST_TO_ADDR
// if ValidHex ( x , y ) then
103167: LD_VAR 0 2
103171: PPUSH
103172: LD_VAR 0 3
103176: PPUSH
103177: CALL_OW 488
103181: IFFALSE 103216
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
103183: LD_VAR 0 1
103187: PPUSH
103188: LD_VAR 0 2
103192: PPUSH
103193: LD_VAR 0 3
103197: PPUSH
103198: LD_INT 3
103200: PPUSH
103201: LD_INT 6
103203: PPUSH
103204: CALL_OW 12
103208: PPUSH
103209: LD_INT 1
103211: PPUSH
103212: CALL_OW 483
// end ;
103216: GO 103076
103218: POP
103219: POP
// end ;
103220: PPOPN 5
103222: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
103223: LD_EXP 123
103227: PUSH
103228: LD_EXP 158
103232: AND
103233: IFFALSE 103327
103235: GO 103237
103237: DISABLE
103238: LD_INT 0
103240: PPUSH
103241: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
103242: LD_ADDR_VAR 0 2
103246: PUSH
103247: LD_INT 22
103249: PUSH
103250: LD_OWVAR 2
103254: PUSH
103255: EMPTY
103256: LIST
103257: LIST
103258: PUSH
103259: LD_INT 32
103261: PUSH
103262: LD_INT 1
103264: PUSH
103265: EMPTY
103266: LIST
103267: LIST
103268: PUSH
103269: LD_INT 21
103271: PUSH
103272: LD_INT 2
103274: PUSH
103275: EMPTY
103276: LIST
103277: LIST
103278: PUSH
103279: EMPTY
103280: LIST
103281: LIST
103282: LIST
103283: PPUSH
103284: CALL_OW 69
103288: ST_TO_ADDR
// if not tmp then
103289: LD_VAR 0 2
103293: NOT
103294: IFFALSE 103298
// exit ;
103296: GO 103327
// for i in tmp do
103298: LD_ADDR_VAR 0 1
103302: PUSH
103303: LD_VAR 0 2
103307: PUSH
103308: FOR_IN
103309: IFFALSE 103325
// SetFuel ( i , 0 ) ;
103311: LD_VAR 0 1
103315: PPUSH
103316: LD_INT 0
103318: PPUSH
103319: CALL_OW 240
103323: GO 103308
103325: POP
103326: POP
// end ;
103327: PPOPN 2
103329: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
103330: LD_EXP 123
103334: PUSH
103335: LD_EXP 159
103339: AND
103340: IFFALSE 103406
103342: GO 103344
103344: DISABLE
103345: LD_INT 0
103347: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
103348: LD_ADDR_VAR 0 1
103352: PUSH
103353: LD_INT 22
103355: PUSH
103356: LD_OWVAR 2
103360: PUSH
103361: EMPTY
103362: LIST
103363: LIST
103364: PUSH
103365: LD_INT 30
103367: PUSH
103368: LD_INT 29
103370: PUSH
103371: EMPTY
103372: LIST
103373: LIST
103374: PUSH
103375: EMPTY
103376: LIST
103377: LIST
103378: PPUSH
103379: CALL_OW 69
103383: ST_TO_ADDR
// if not tmp then
103384: LD_VAR 0 1
103388: NOT
103389: IFFALSE 103393
// exit ;
103391: GO 103406
// DestroyUnit ( tmp [ 1 ] ) ;
103393: LD_VAR 0 1
103397: PUSH
103398: LD_INT 1
103400: ARRAY
103401: PPUSH
103402: CALL_OW 65
// end ;
103406: PPOPN 1
103408: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
103409: LD_EXP 123
103413: PUSH
103414: LD_EXP 161
103418: AND
103419: IFFALSE 103548
103421: GO 103423
103423: DISABLE
103424: LD_INT 0
103426: PPUSH
// begin uc_side := 0 ;
103427: LD_ADDR_OWVAR 20
103431: PUSH
103432: LD_INT 0
103434: ST_TO_ADDR
// uc_nation := nation_arabian ;
103435: LD_ADDR_OWVAR 21
103439: PUSH
103440: LD_INT 2
103442: ST_TO_ADDR
// hc_gallery :=  ;
103443: LD_ADDR_OWVAR 33
103447: PUSH
103448: LD_STRING 
103450: ST_TO_ADDR
// hc_name :=  ;
103451: LD_ADDR_OWVAR 26
103455: PUSH
103456: LD_STRING 
103458: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
103459: LD_INT 1
103461: PPUSH
103462: LD_INT 11
103464: PPUSH
103465: LD_INT 10
103467: PPUSH
103468: CALL_OW 380
// un := CreateHuman ;
103472: LD_ADDR_VAR 0 1
103476: PUSH
103477: CALL_OW 44
103481: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
103482: LD_VAR 0 1
103486: PPUSH
103487: LD_INT 1
103489: PPUSH
103490: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
103494: LD_INT 35
103496: PPUSH
103497: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
103501: LD_VAR 0 1
103505: PPUSH
103506: LD_INT 22
103508: PUSH
103509: LD_OWVAR 2
103513: PUSH
103514: EMPTY
103515: LIST
103516: LIST
103517: PPUSH
103518: CALL_OW 69
103522: PPUSH
103523: LD_VAR 0 1
103527: PPUSH
103528: CALL_OW 74
103532: PPUSH
103533: CALL_OW 115
// until IsDead ( un ) ;
103537: LD_VAR 0 1
103541: PPUSH
103542: CALL_OW 301
103546: IFFALSE 103494
// end ;
103548: PPOPN 1
103550: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
103551: LD_EXP 123
103555: PUSH
103556: LD_EXP 163
103560: AND
103561: IFFALSE 103573
103563: GO 103565
103565: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
103566: LD_STRING earthquake(getX(game), 0, 32)
103568: PPUSH
103569: CALL_OW 559
103573: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
103574: LD_EXP 123
103578: PUSH
103579: LD_EXP 164
103583: AND
103584: IFFALSE 103675
103586: GO 103588
103588: DISABLE
103589: LD_INT 0
103591: PPUSH
// begin enable ;
103592: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
103593: LD_ADDR_VAR 0 1
103597: PUSH
103598: LD_INT 22
103600: PUSH
103601: LD_OWVAR 2
103605: PUSH
103606: EMPTY
103607: LIST
103608: LIST
103609: PUSH
103610: LD_INT 21
103612: PUSH
103613: LD_INT 2
103615: PUSH
103616: EMPTY
103617: LIST
103618: LIST
103619: PUSH
103620: LD_INT 33
103622: PUSH
103623: LD_INT 3
103625: PUSH
103626: EMPTY
103627: LIST
103628: LIST
103629: PUSH
103630: EMPTY
103631: LIST
103632: LIST
103633: LIST
103634: PPUSH
103635: CALL_OW 69
103639: ST_TO_ADDR
// if not tmp then
103640: LD_VAR 0 1
103644: NOT
103645: IFFALSE 103649
// exit ;
103647: GO 103675
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
103649: LD_VAR 0 1
103653: PUSH
103654: LD_INT 1
103656: PPUSH
103657: LD_VAR 0 1
103661: PPUSH
103662: CALL_OW 12
103666: ARRAY
103667: PPUSH
103668: LD_INT 1
103670: PPUSH
103671: CALL_OW 234
// end ;
103675: PPOPN 1
103677: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
103678: LD_EXP 123
103682: PUSH
103683: LD_EXP 165
103687: AND
103688: IFFALSE 103829
103690: GO 103692
103692: DISABLE
103693: LD_INT 0
103695: PPUSH
103696: PPUSH
103697: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103698: LD_ADDR_VAR 0 3
103702: PUSH
103703: LD_INT 22
103705: PUSH
103706: LD_OWVAR 2
103710: PUSH
103711: EMPTY
103712: LIST
103713: LIST
103714: PUSH
103715: LD_INT 25
103717: PUSH
103718: LD_INT 1
103720: PUSH
103721: EMPTY
103722: LIST
103723: LIST
103724: PUSH
103725: EMPTY
103726: LIST
103727: LIST
103728: PPUSH
103729: CALL_OW 69
103733: ST_TO_ADDR
// if not tmp then
103734: LD_VAR 0 3
103738: NOT
103739: IFFALSE 103743
// exit ;
103741: GO 103829
// un := tmp [ rand ( 1 , tmp ) ] ;
103743: LD_ADDR_VAR 0 2
103747: PUSH
103748: LD_VAR 0 3
103752: PUSH
103753: LD_INT 1
103755: PPUSH
103756: LD_VAR 0 3
103760: PPUSH
103761: CALL_OW 12
103765: ARRAY
103766: ST_TO_ADDR
// if Crawls ( un ) then
103767: LD_VAR 0 2
103771: PPUSH
103772: CALL_OW 318
103776: IFFALSE 103787
// ComWalk ( un ) ;
103778: LD_VAR 0 2
103782: PPUSH
103783: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
103787: LD_VAR 0 2
103791: PPUSH
103792: LD_INT 9
103794: PPUSH
103795: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
103799: LD_INT 28
103801: PPUSH
103802: LD_OWVAR 2
103806: PPUSH
103807: LD_INT 2
103809: PPUSH
103810: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
103814: LD_INT 29
103816: PPUSH
103817: LD_OWVAR 2
103821: PPUSH
103822: LD_INT 2
103824: PPUSH
103825: CALL_OW 322
// end ;
103829: PPOPN 3
103831: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
103832: LD_EXP 123
103836: PUSH
103837: LD_EXP 166
103841: AND
103842: IFFALSE 103953
103844: GO 103846
103846: DISABLE
103847: LD_INT 0
103849: PPUSH
103850: PPUSH
103851: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103852: LD_ADDR_VAR 0 3
103856: PUSH
103857: LD_INT 22
103859: PUSH
103860: LD_OWVAR 2
103864: PUSH
103865: EMPTY
103866: LIST
103867: LIST
103868: PUSH
103869: LD_INT 25
103871: PUSH
103872: LD_INT 1
103874: PUSH
103875: EMPTY
103876: LIST
103877: LIST
103878: PUSH
103879: EMPTY
103880: LIST
103881: LIST
103882: PPUSH
103883: CALL_OW 69
103887: ST_TO_ADDR
// if not tmp then
103888: LD_VAR 0 3
103892: NOT
103893: IFFALSE 103897
// exit ;
103895: GO 103953
// un := tmp [ rand ( 1 , tmp ) ] ;
103897: LD_ADDR_VAR 0 2
103901: PUSH
103902: LD_VAR 0 3
103906: PUSH
103907: LD_INT 1
103909: PPUSH
103910: LD_VAR 0 3
103914: PPUSH
103915: CALL_OW 12
103919: ARRAY
103920: ST_TO_ADDR
// if Crawls ( un ) then
103921: LD_VAR 0 2
103925: PPUSH
103926: CALL_OW 318
103930: IFFALSE 103941
// ComWalk ( un ) ;
103932: LD_VAR 0 2
103936: PPUSH
103937: CALL_OW 138
// SetClass ( un , class_mortar ) ;
103941: LD_VAR 0 2
103945: PPUSH
103946: LD_INT 8
103948: PPUSH
103949: CALL_OW 336
// end ;
103953: PPOPN 3
103955: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
103956: LD_EXP 123
103960: PUSH
103961: LD_EXP 167
103965: AND
103966: IFFALSE 104110
103968: GO 103970
103970: DISABLE
103971: LD_INT 0
103973: PPUSH
103974: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
103975: LD_ADDR_VAR 0 2
103979: PUSH
103980: LD_INT 22
103982: PUSH
103983: LD_OWVAR 2
103987: PUSH
103988: EMPTY
103989: LIST
103990: LIST
103991: PUSH
103992: LD_INT 21
103994: PUSH
103995: LD_INT 2
103997: PUSH
103998: EMPTY
103999: LIST
104000: LIST
104001: PUSH
104002: LD_INT 2
104004: PUSH
104005: LD_INT 34
104007: PUSH
104008: LD_INT 12
104010: PUSH
104011: EMPTY
104012: LIST
104013: LIST
104014: PUSH
104015: LD_INT 34
104017: PUSH
104018: LD_INT 51
104020: PUSH
104021: EMPTY
104022: LIST
104023: LIST
104024: PUSH
104025: LD_INT 34
104027: PUSH
104028: LD_INT 32
104030: PUSH
104031: EMPTY
104032: LIST
104033: LIST
104034: PUSH
104035: EMPTY
104036: LIST
104037: LIST
104038: LIST
104039: LIST
104040: PUSH
104041: EMPTY
104042: LIST
104043: LIST
104044: LIST
104045: PPUSH
104046: CALL_OW 69
104050: ST_TO_ADDR
// if not tmp then
104051: LD_VAR 0 2
104055: NOT
104056: IFFALSE 104060
// exit ;
104058: GO 104110
// for i in tmp do
104060: LD_ADDR_VAR 0 1
104064: PUSH
104065: LD_VAR 0 2
104069: PUSH
104070: FOR_IN
104071: IFFALSE 104108
// if GetCargo ( i , mat_artifact ) = 0 then
104073: LD_VAR 0 1
104077: PPUSH
104078: LD_INT 4
104080: PPUSH
104081: CALL_OW 289
104085: PUSH
104086: LD_INT 0
104088: EQUAL
104089: IFFALSE 104106
// SetCargo ( i , mat_siberit , 100 ) ;
104091: LD_VAR 0 1
104095: PPUSH
104096: LD_INT 3
104098: PPUSH
104099: LD_INT 100
104101: PPUSH
104102: CALL_OW 290
104106: GO 104070
104108: POP
104109: POP
// end ;
104110: PPOPN 2
104112: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
104113: LD_EXP 123
104117: PUSH
104118: LD_EXP 168
104122: AND
104123: IFFALSE 104306
104125: GO 104127
104127: DISABLE
104128: LD_INT 0
104130: PPUSH
104131: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104132: LD_ADDR_VAR 0 2
104136: PUSH
104137: LD_INT 22
104139: PUSH
104140: LD_OWVAR 2
104144: PUSH
104145: EMPTY
104146: LIST
104147: LIST
104148: PPUSH
104149: CALL_OW 69
104153: ST_TO_ADDR
// if not tmp then
104154: LD_VAR 0 2
104158: NOT
104159: IFFALSE 104163
// exit ;
104161: GO 104306
// for i := 1 to 2 do
104163: LD_ADDR_VAR 0 1
104167: PUSH
104168: DOUBLE
104169: LD_INT 1
104171: DEC
104172: ST_TO_ADDR
104173: LD_INT 2
104175: PUSH
104176: FOR_TO
104177: IFFALSE 104304
// begin uc_side := your_side ;
104179: LD_ADDR_OWVAR 20
104183: PUSH
104184: LD_OWVAR 2
104188: ST_TO_ADDR
// uc_nation := nation_american ;
104189: LD_ADDR_OWVAR 21
104193: PUSH
104194: LD_INT 1
104196: ST_TO_ADDR
// vc_chassis := us_morphling ;
104197: LD_ADDR_OWVAR 37
104201: PUSH
104202: LD_INT 5
104204: ST_TO_ADDR
// vc_engine := engine_siberite ;
104205: LD_ADDR_OWVAR 39
104209: PUSH
104210: LD_INT 3
104212: ST_TO_ADDR
// vc_control := control_computer ;
104213: LD_ADDR_OWVAR 38
104217: PUSH
104218: LD_INT 3
104220: ST_TO_ADDR
// vc_weapon := us_double_laser ;
104221: LD_ADDR_OWVAR 40
104225: PUSH
104226: LD_INT 10
104228: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
104229: LD_VAR 0 2
104233: PUSH
104234: LD_INT 1
104236: ARRAY
104237: PPUSH
104238: CALL_OW 310
104242: NOT
104243: IFFALSE 104290
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
104245: CALL_OW 45
104249: PPUSH
104250: LD_VAR 0 2
104254: PUSH
104255: LD_INT 1
104257: ARRAY
104258: PPUSH
104259: CALL_OW 250
104263: PPUSH
104264: LD_VAR 0 2
104268: PUSH
104269: LD_INT 1
104271: ARRAY
104272: PPUSH
104273: CALL_OW 251
104277: PPUSH
104278: LD_INT 12
104280: PPUSH
104281: LD_INT 1
104283: PPUSH
104284: CALL_OW 50
104288: GO 104302
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
104290: CALL_OW 45
104294: PPUSH
104295: LD_INT 1
104297: PPUSH
104298: CALL_OW 51
// end ;
104302: GO 104176
104304: POP
104305: POP
// end ;
104306: PPOPN 2
104308: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
104309: LD_EXP 123
104313: PUSH
104314: LD_EXP 169
104318: AND
104319: IFFALSE 104541
104321: GO 104323
104323: DISABLE
104324: LD_INT 0
104326: PPUSH
104327: PPUSH
104328: PPUSH
104329: PPUSH
104330: PPUSH
104331: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
104332: LD_ADDR_VAR 0 6
104336: PUSH
104337: LD_INT 22
104339: PUSH
104340: LD_OWVAR 2
104344: PUSH
104345: EMPTY
104346: LIST
104347: LIST
104348: PUSH
104349: LD_INT 21
104351: PUSH
104352: LD_INT 1
104354: PUSH
104355: EMPTY
104356: LIST
104357: LIST
104358: PUSH
104359: LD_INT 3
104361: PUSH
104362: LD_INT 23
104364: PUSH
104365: LD_INT 0
104367: PUSH
104368: EMPTY
104369: LIST
104370: LIST
104371: PUSH
104372: EMPTY
104373: LIST
104374: LIST
104375: PUSH
104376: EMPTY
104377: LIST
104378: LIST
104379: LIST
104380: PPUSH
104381: CALL_OW 69
104385: ST_TO_ADDR
// if not tmp then
104386: LD_VAR 0 6
104390: NOT
104391: IFFALSE 104395
// exit ;
104393: GO 104541
// s1 := rand ( 1 , 4 ) ;
104395: LD_ADDR_VAR 0 2
104399: PUSH
104400: LD_INT 1
104402: PPUSH
104403: LD_INT 4
104405: PPUSH
104406: CALL_OW 12
104410: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
104411: LD_ADDR_VAR 0 4
104415: PUSH
104416: LD_VAR 0 6
104420: PUSH
104421: LD_INT 1
104423: ARRAY
104424: PPUSH
104425: LD_VAR 0 2
104429: PPUSH
104430: CALL_OW 259
104434: ST_TO_ADDR
// if s1 = 1 then
104435: LD_VAR 0 2
104439: PUSH
104440: LD_INT 1
104442: EQUAL
104443: IFFALSE 104463
// s2 := rand ( 2 , 4 ) else
104445: LD_ADDR_VAR 0 3
104449: PUSH
104450: LD_INT 2
104452: PPUSH
104453: LD_INT 4
104455: PPUSH
104456: CALL_OW 12
104460: ST_TO_ADDR
104461: GO 104471
// s2 := 1 ;
104463: LD_ADDR_VAR 0 3
104467: PUSH
104468: LD_INT 1
104470: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
104471: LD_ADDR_VAR 0 5
104475: PUSH
104476: LD_VAR 0 6
104480: PUSH
104481: LD_INT 1
104483: ARRAY
104484: PPUSH
104485: LD_VAR 0 3
104489: PPUSH
104490: CALL_OW 259
104494: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
104495: LD_VAR 0 6
104499: PUSH
104500: LD_INT 1
104502: ARRAY
104503: PPUSH
104504: LD_VAR 0 2
104508: PPUSH
104509: LD_VAR 0 5
104513: PPUSH
104514: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
104518: LD_VAR 0 6
104522: PUSH
104523: LD_INT 1
104525: ARRAY
104526: PPUSH
104527: LD_VAR 0 3
104531: PPUSH
104532: LD_VAR 0 4
104536: PPUSH
104537: CALL_OW 237
// end ;
104541: PPOPN 6
104543: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
104544: LD_EXP 123
104548: PUSH
104549: LD_EXP 170
104553: AND
104554: IFFALSE 104633
104556: GO 104558
104558: DISABLE
104559: LD_INT 0
104561: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
104562: LD_ADDR_VAR 0 1
104566: PUSH
104567: LD_INT 22
104569: PUSH
104570: LD_OWVAR 2
104574: PUSH
104575: EMPTY
104576: LIST
104577: LIST
104578: PUSH
104579: LD_INT 30
104581: PUSH
104582: LD_INT 3
104584: PUSH
104585: EMPTY
104586: LIST
104587: LIST
104588: PUSH
104589: EMPTY
104590: LIST
104591: LIST
104592: PPUSH
104593: CALL_OW 69
104597: ST_TO_ADDR
// if not tmp then
104598: LD_VAR 0 1
104602: NOT
104603: IFFALSE 104607
// exit ;
104605: GO 104633
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
104607: LD_VAR 0 1
104611: PUSH
104612: LD_INT 1
104614: PPUSH
104615: LD_VAR 0 1
104619: PPUSH
104620: CALL_OW 12
104624: ARRAY
104625: PPUSH
104626: LD_INT 1
104628: PPUSH
104629: CALL_OW 234
// end ;
104633: PPOPN 1
104635: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
104636: LD_EXP 123
104640: PUSH
104641: LD_EXP 171
104645: AND
104646: IFFALSE 104758
104648: GO 104650
104650: DISABLE
104651: LD_INT 0
104653: PPUSH
104654: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
104655: LD_ADDR_VAR 0 2
104659: PUSH
104660: LD_INT 22
104662: PUSH
104663: LD_OWVAR 2
104667: PUSH
104668: EMPTY
104669: LIST
104670: LIST
104671: PUSH
104672: LD_INT 2
104674: PUSH
104675: LD_INT 30
104677: PUSH
104678: LD_INT 27
104680: PUSH
104681: EMPTY
104682: LIST
104683: LIST
104684: PUSH
104685: LD_INT 30
104687: PUSH
104688: LD_INT 26
104690: PUSH
104691: EMPTY
104692: LIST
104693: LIST
104694: PUSH
104695: LD_INT 30
104697: PUSH
104698: LD_INT 28
104700: PUSH
104701: EMPTY
104702: LIST
104703: LIST
104704: PUSH
104705: EMPTY
104706: LIST
104707: LIST
104708: LIST
104709: LIST
104710: PUSH
104711: EMPTY
104712: LIST
104713: LIST
104714: PPUSH
104715: CALL_OW 69
104719: ST_TO_ADDR
// if not tmp then
104720: LD_VAR 0 2
104724: NOT
104725: IFFALSE 104729
// exit ;
104727: GO 104758
// for i in tmp do
104729: LD_ADDR_VAR 0 1
104733: PUSH
104734: LD_VAR 0 2
104738: PUSH
104739: FOR_IN
104740: IFFALSE 104756
// SetLives ( i , 1 ) ;
104742: LD_VAR 0 1
104746: PPUSH
104747: LD_INT 1
104749: PPUSH
104750: CALL_OW 234
104754: GO 104739
104756: POP
104757: POP
// end ;
104758: PPOPN 2
104760: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
104761: LD_EXP 123
104765: PUSH
104766: LD_EXP 172
104770: AND
104771: IFFALSE 105058
104773: GO 104775
104775: DISABLE
104776: LD_INT 0
104778: PPUSH
104779: PPUSH
104780: PPUSH
// begin i := rand ( 1 , 7 ) ;
104781: LD_ADDR_VAR 0 1
104785: PUSH
104786: LD_INT 1
104788: PPUSH
104789: LD_INT 7
104791: PPUSH
104792: CALL_OW 12
104796: ST_TO_ADDR
// case i of 1 :
104797: LD_VAR 0 1
104801: PUSH
104802: LD_INT 1
104804: DOUBLE
104805: EQUAL
104806: IFTRUE 104810
104808: GO 104820
104810: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
104811: LD_STRING earthquake(getX(game), 0, 32)
104813: PPUSH
104814: CALL_OW 559
104818: GO 105058
104820: LD_INT 2
104822: DOUBLE
104823: EQUAL
104824: IFTRUE 104828
104826: GO 104842
104828: POP
// begin ToLua ( displayStucuk(); ) ;
104829: LD_STRING displayStucuk();
104831: PPUSH
104832: CALL_OW 559
// ResetFog ;
104836: CALL_OW 335
// end ; 3 :
104840: GO 105058
104842: LD_INT 3
104844: DOUBLE
104845: EQUAL
104846: IFTRUE 104850
104848: GO 104954
104850: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
104851: LD_ADDR_VAR 0 2
104855: PUSH
104856: LD_INT 22
104858: PUSH
104859: LD_OWVAR 2
104863: PUSH
104864: EMPTY
104865: LIST
104866: LIST
104867: PUSH
104868: LD_INT 25
104870: PUSH
104871: LD_INT 1
104873: PUSH
104874: EMPTY
104875: LIST
104876: LIST
104877: PUSH
104878: EMPTY
104879: LIST
104880: LIST
104881: PPUSH
104882: CALL_OW 69
104886: ST_TO_ADDR
// if not tmp then
104887: LD_VAR 0 2
104891: NOT
104892: IFFALSE 104896
// exit ;
104894: GO 105058
// un := tmp [ rand ( 1 , tmp ) ] ;
104896: LD_ADDR_VAR 0 3
104900: PUSH
104901: LD_VAR 0 2
104905: PUSH
104906: LD_INT 1
104908: PPUSH
104909: LD_VAR 0 2
104913: PPUSH
104914: CALL_OW 12
104918: ARRAY
104919: ST_TO_ADDR
// if Crawls ( un ) then
104920: LD_VAR 0 3
104924: PPUSH
104925: CALL_OW 318
104929: IFFALSE 104940
// ComWalk ( un ) ;
104931: LD_VAR 0 3
104935: PPUSH
104936: CALL_OW 138
// SetClass ( un , class_mortar ) ;
104940: LD_VAR 0 3
104944: PPUSH
104945: LD_INT 8
104947: PPUSH
104948: CALL_OW 336
// end ; 4 :
104952: GO 105058
104954: LD_INT 4
104956: DOUBLE
104957: EQUAL
104958: IFTRUE 104962
104960: GO 105036
104962: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
104963: LD_ADDR_VAR 0 2
104967: PUSH
104968: LD_INT 22
104970: PUSH
104971: LD_OWVAR 2
104975: PUSH
104976: EMPTY
104977: LIST
104978: LIST
104979: PUSH
104980: LD_INT 30
104982: PUSH
104983: LD_INT 29
104985: PUSH
104986: EMPTY
104987: LIST
104988: LIST
104989: PUSH
104990: EMPTY
104991: LIST
104992: LIST
104993: PPUSH
104994: CALL_OW 69
104998: ST_TO_ADDR
// if not tmp then
104999: LD_VAR 0 2
105003: NOT
105004: IFFALSE 105008
// exit ;
105006: GO 105058
// CenterNowOnUnits ( tmp [ 1 ] ) ;
105008: LD_VAR 0 2
105012: PUSH
105013: LD_INT 1
105015: ARRAY
105016: PPUSH
105017: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
105021: LD_VAR 0 2
105025: PUSH
105026: LD_INT 1
105028: ARRAY
105029: PPUSH
105030: CALL_OW 65
// end ; 5 .. 7 :
105034: GO 105058
105036: LD_INT 5
105038: DOUBLE
105039: GREATEREQUAL
105040: IFFALSE 105048
105042: LD_INT 7
105044: DOUBLE
105045: LESSEQUAL
105046: IFTRUE 105050
105048: GO 105057
105050: POP
// StreamSibBomb ; end ;
105051: CALL 101295 0 0
105055: GO 105058
105057: POP
// end ;
105058: PPOPN 3
105060: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
105061: LD_EXP 123
105065: PUSH
105066: LD_EXP 173
105070: AND
105071: IFFALSE 105227
105073: GO 105075
105075: DISABLE
105076: LD_INT 0
105078: PPUSH
105079: PPUSH
105080: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
105081: LD_ADDR_VAR 0 2
105085: PUSH
105086: LD_INT 81
105088: PUSH
105089: LD_OWVAR 2
105093: PUSH
105094: EMPTY
105095: LIST
105096: LIST
105097: PUSH
105098: LD_INT 2
105100: PUSH
105101: LD_INT 21
105103: PUSH
105104: LD_INT 1
105106: PUSH
105107: EMPTY
105108: LIST
105109: LIST
105110: PUSH
105111: LD_INT 21
105113: PUSH
105114: LD_INT 2
105116: PUSH
105117: EMPTY
105118: LIST
105119: LIST
105120: PUSH
105121: EMPTY
105122: LIST
105123: LIST
105124: LIST
105125: PUSH
105126: EMPTY
105127: LIST
105128: LIST
105129: PPUSH
105130: CALL_OW 69
105134: ST_TO_ADDR
// if not tmp then
105135: LD_VAR 0 2
105139: NOT
105140: IFFALSE 105144
// exit ;
105142: GO 105227
// p := 0 ;
105144: LD_ADDR_VAR 0 3
105148: PUSH
105149: LD_INT 0
105151: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
105152: LD_INT 35
105154: PPUSH
105155: CALL_OW 67
// p := p + 1 ;
105159: LD_ADDR_VAR 0 3
105163: PUSH
105164: LD_VAR 0 3
105168: PUSH
105169: LD_INT 1
105171: PLUS
105172: ST_TO_ADDR
// for i in tmp do
105173: LD_ADDR_VAR 0 1
105177: PUSH
105178: LD_VAR 0 2
105182: PUSH
105183: FOR_IN
105184: IFFALSE 105215
// if GetLives ( i ) < 1000 then
105186: LD_VAR 0 1
105190: PPUSH
105191: CALL_OW 256
105195: PUSH
105196: LD_INT 1000
105198: LESS
105199: IFFALSE 105213
// SetLives ( i , 1000 ) ;
105201: LD_VAR 0 1
105205: PPUSH
105206: LD_INT 1000
105208: PPUSH
105209: CALL_OW 234
105213: GO 105183
105215: POP
105216: POP
// until p > 20 ;
105217: LD_VAR 0 3
105221: PUSH
105222: LD_INT 20
105224: GREATER
105225: IFFALSE 105152
// end ;
105227: PPOPN 3
105229: END
// every 0 0$1 trigger StreamModeActive and sTime do
105230: LD_EXP 123
105234: PUSH
105235: LD_EXP 174
105239: AND
105240: IFFALSE 105275
105242: GO 105244
105244: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
105245: LD_INT 28
105247: PPUSH
105248: LD_OWVAR 2
105252: PPUSH
105253: LD_INT 2
105255: PPUSH
105256: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
105260: LD_INT 30
105262: PPUSH
105263: LD_OWVAR 2
105267: PPUSH
105268: LD_INT 2
105270: PPUSH
105271: CALL_OW 322
// end ;
105275: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
105276: LD_EXP 123
105280: PUSH
105281: LD_EXP 175
105285: AND
105286: IFFALSE 105407
105288: GO 105290
105290: DISABLE
105291: LD_INT 0
105293: PPUSH
105294: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
105295: LD_ADDR_VAR 0 2
105299: PUSH
105300: LD_INT 22
105302: PUSH
105303: LD_OWVAR 2
105307: PUSH
105308: EMPTY
105309: LIST
105310: LIST
105311: PUSH
105312: LD_INT 21
105314: PUSH
105315: LD_INT 1
105317: PUSH
105318: EMPTY
105319: LIST
105320: LIST
105321: PUSH
105322: LD_INT 3
105324: PUSH
105325: LD_INT 23
105327: PUSH
105328: LD_INT 0
105330: PUSH
105331: EMPTY
105332: LIST
105333: LIST
105334: PUSH
105335: EMPTY
105336: LIST
105337: LIST
105338: PUSH
105339: EMPTY
105340: LIST
105341: LIST
105342: LIST
105343: PPUSH
105344: CALL_OW 69
105348: ST_TO_ADDR
// if not tmp then
105349: LD_VAR 0 2
105353: NOT
105354: IFFALSE 105358
// exit ;
105356: GO 105407
// for i in tmp do
105358: LD_ADDR_VAR 0 1
105362: PUSH
105363: LD_VAR 0 2
105367: PUSH
105368: FOR_IN
105369: IFFALSE 105405
// begin if Crawls ( i ) then
105371: LD_VAR 0 1
105375: PPUSH
105376: CALL_OW 318
105380: IFFALSE 105391
// ComWalk ( i ) ;
105382: LD_VAR 0 1
105386: PPUSH
105387: CALL_OW 138
// SetClass ( i , 2 ) ;
105391: LD_VAR 0 1
105395: PPUSH
105396: LD_INT 2
105398: PPUSH
105399: CALL_OW 336
// end ;
105403: GO 105368
105405: POP
105406: POP
// end ;
105407: PPOPN 2
105409: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
105410: LD_EXP 123
105414: PUSH
105415: LD_EXP 176
105419: AND
105420: IFFALSE 105708
105422: GO 105424
105424: DISABLE
105425: LD_INT 0
105427: PPUSH
105428: PPUSH
105429: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
105430: LD_OWVAR 2
105434: PPUSH
105435: LD_INT 9
105437: PPUSH
105438: LD_INT 1
105440: PPUSH
105441: LD_INT 1
105443: PPUSH
105444: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
105448: LD_INT 9
105450: PPUSH
105451: LD_OWVAR 2
105455: PPUSH
105456: CALL_OW 343
// uc_side := 9 ;
105460: LD_ADDR_OWVAR 20
105464: PUSH
105465: LD_INT 9
105467: ST_TO_ADDR
// uc_nation := 2 ;
105468: LD_ADDR_OWVAR 21
105472: PUSH
105473: LD_INT 2
105475: ST_TO_ADDR
// hc_name := Dark Warrior ;
105476: LD_ADDR_OWVAR 26
105480: PUSH
105481: LD_STRING Dark Warrior
105483: ST_TO_ADDR
// hc_gallery :=  ;
105484: LD_ADDR_OWVAR 33
105488: PUSH
105489: LD_STRING 
105491: ST_TO_ADDR
// hc_noskilllimit := true ;
105492: LD_ADDR_OWVAR 76
105496: PUSH
105497: LD_INT 1
105499: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
105500: LD_ADDR_OWVAR 31
105504: PUSH
105505: LD_INT 30
105507: PUSH
105508: LD_INT 30
105510: PUSH
105511: LD_INT 30
105513: PUSH
105514: LD_INT 30
105516: PUSH
105517: EMPTY
105518: LIST
105519: LIST
105520: LIST
105521: LIST
105522: ST_TO_ADDR
// un := CreateHuman ;
105523: LD_ADDR_VAR 0 3
105527: PUSH
105528: CALL_OW 44
105532: ST_TO_ADDR
// hc_noskilllimit := false ;
105533: LD_ADDR_OWVAR 76
105537: PUSH
105538: LD_INT 0
105540: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
105541: LD_VAR 0 3
105545: PPUSH
105546: LD_INT 1
105548: PPUSH
105549: CALL_OW 51
// ToLua ( playRanger() ) ;
105553: LD_STRING playRanger()
105555: PPUSH
105556: CALL_OW 559
// p := 0 ;
105560: LD_ADDR_VAR 0 2
105564: PUSH
105565: LD_INT 0
105567: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
105568: LD_INT 35
105570: PPUSH
105571: CALL_OW 67
// p := p + 1 ;
105575: LD_ADDR_VAR 0 2
105579: PUSH
105580: LD_VAR 0 2
105584: PUSH
105585: LD_INT 1
105587: PLUS
105588: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
105589: LD_VAR 0 3
105593: PPUSH
105594: CALL_OW 256
105598: PUSH
105599: LD_INT 1000
105601: LESS
105602: IFFALSE 105616
// SetLives ( un , 1000 ) ;
105604: LD_VAR 0 3
105608: PPUSH
105609: LD_INT 1000
105611: PPUSH
105612: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
105616: LD_VAR 0 3
105620: PPUSH
105621: LD_INT 81
105623: PUSH
105624: LD_OWVAR 2
105628: PUSH
105629: EMPTY
105630: LIST
105631: LIST
105632: PUSH
105633: LD_INT 91
105635: PUSH
105636: LD_VAR 0 3
105640: PUSH
105641: LD_INT 30
105643: PUSH
105644: EMPTY
105645: LIST
105646: LIST
105647: LIST
105648: PUSH
105649: EMPTY
105650: LIST
105651: LIST
105652: PPUSH
105653: CALL_OW 69
105657: PPUSH
105658: LD_VAR 0 3
105662: PPUSH
105663: CALL_OW 74
105667: PPUSH
105668: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
105672: LD_VAR 0 2
105676: PUSH
105677: LD_INT 80
105679: GREATER
105680: PUSH
105681: LD_VAR 0 3
105685: PPUSH
105686: CALL_OW 301
105690: OR
105691: IFFALSE 105568
// if un then
105693: LD_VAR 0 3
105697: IFFALSE 105708
// RemoveUnit ( un ) ;
105699: LD_VAR 0 3
105703: PPUSH
105704: CALL_OW 64
// end ;
105708: PPOPN 3
105710: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
105711: LD_EXP 177
105715: IFFALSE 105831
105717: GO 105719
105719: DISABLE
105720: LD_INT 0
105722: PPUSH
105723: PPUSH
105724: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
105725: LD_ADDR_VAR 0 2
105729: PUSH
105730: LD_INT 81
105732: PUSH
105733: LD_OWVAR 2
105737: PUSH
105738: EMPTY
105739: LIST
105740: LIST
105741: PUSH
105742: LD_INT 21
105744: PUSH
105745: LD_INT 1
105747: PUSH
105748: EMPTY
105749: LIST
105750: LIST
105751: PUSH
105752: EMPTY
105753: LIST
105754: LIST
105755: PPUSH
105756: CALL_OW 69
105760: ST_TO_ADDR
// ToLua ( playComputer() ) ;
105761: LD_STRING playComputer()
105763: PPUSH
105764: CALL_OW 559
// if not tmp then
105768: LD_VAR 0 2
105772: NOT
105773: IFFALSE 105777
// exit ;
105775: GO 105831
// for i in tmp do
105777: LD_ADDR_VAR 0 1
105781: PUSH
105782: LD_VAR 0 2
105786: PUSH
105787: FOR_IN
105788: IFFALSE 105829
// for j := 1 to 4 do
105790: LD_ADDR_VAR 0 3
105794: PUSH
105795: DOUBLE
105796: LD_INT 1
105798: DEC
105799: ST_TO_ADDR
105800: LD_INT 4
105802: PUSH
105803: FOR_TO
105804: IFFALSE 105825
// SetSkill ( i , j , 10 ) ;
105806: LD_VAR 0 1
105810: PPUSH
105811: LD_VAR 0 3
105815: PPUSH
105816: LD_INT 10
105818: PPUSH
105819: CALL_OW 237
105823: GO 105803
105825: POP
105826: POP
105827: GO 105787
105829: POP
105830: POP
// end ;
105831: PPOPN 3
105833: END
// every 0 0$1 trigger s30 do var i , tmp ;
105834: LD_EXP 178
105838: IFFALSE 105907
105840: GO 105842
105842: DISABLE
105843: LD_INT 0
105845: PPUSH
105846: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
105847: LD_ADDR_VAR 0 2
105851: PUSH
105852: LD_INT 22
105854: PUSH
105855: LD_OWVAR 2
105859: PUSH
105860: EMPTY
105861: LIST
105862: LIST
105863: PPUSH
105864: CALL_OW 69
105868: ST_TO_ADDR
// if not tmp then
105869: LD_VAR 0 2
105873: NOT
105874: IFFALSE 105878
// exit ;
105876: GO 105907
// for i in tmp do
105878: LD_ADDR_VAR 0 1
105882: PUSH
105883: LD_VAR 0 2
105887: PUSH
105888: FOR_IN
105889: IFFALSE 105905
// SetLives ( i , 300 ) ;
105891: LD_VAR 0 1
105895: PPUSH
105896: LD_INT 300
105898: PPUSH
105899: CALL_OW 234
105903: GO 105888
105905: POP
105906: POP
// end ;
105907: PPOPN 2
105909: END
// every 0 0$1 trigger s60 do var i , tmp ;
105910: LD_EXP 179
105914: IFFALSE 105983
105916: GO 105918
105918: DISABLE
105919: LD_INT 0
105921: PPUSH
105922: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
105923: LD_ADDR_VAR 0 2
105927: PUSH
105928: LD_INT 22
105930: PUSH
105931: LD_OWVAR 2
105935: PUSH
105936: EMPTY
105937: LIST
105938: LIST
105939: PPUSH
105940: CALL_OW 69
105944: ST_TO_ADDR
// if not tmp then
105945: LD_VAR 0 2
105949: NOT
105950: IFFALSE 105954
// exit ;
105952: GO 105983
// for i in tmp do
105954: LD_ADDR_VAR 0 1
105958: PUSH
105959: LD_VAR 0 2
105963: PUSH
105964: FOR_IN
105965: IFFALSE 105981
// SetLives ( i , 600 ) ;
105967: LD_VAR 0 1
105971: PPUSH
105972: LD_INT 600
105974: PPUSH
105975: CALL_OW 234
105979: GO 105964
105981: POP
105982: POP
// end ;
105983: PPOPN 2
105985: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
105986: LD_INT 0
105988: PPUSH
// case cmd of 301 :
105989: LD_VAR 0 1
105993: PUSH
105994: LD_INT 301
105996: DOUBLE
105997: EQUAL
105998: IFTRUE 106002
106000: GO 106034
106002: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
106003: LD_VAR 0 6
106007: PPUSH
106008: LD_VAR 0 7
106012: PPUSH
106013: LD_VAR 0 8
106017: PPUSH
106018: LD_VAR 0 4
106022: PPUSH
106023: LD_VAR 0 5
106027: PPUSH
106028: CALL 107235 0 5
106032: GO 106155
106034: LD_INT 302
106036: DOUBLE
106037: EQUAL
106038: IFTRUE 106042
106040: GO 106079
106042: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
106043: LD_VAR 0 6
106047: PPUSH
106048: LD_VAR 0 7
106052: PPUSH
106053: LD_VAR 0 8
106057: PPUSH
106058: LD_VAR 0 9
106062: PPUSH
106063: LD_VAR 0 4
106067: PPUSH
106068: LD_VAR 0 5
106072: PPUSH
106073: CALL 107326 0 6
106077: GO 106155
106079: LD_INT 303
106081: DOUBLE
106082: EQUAL
106083: IFTRUE 106087
106085: GO 106124
106087: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
106088: LD_VAR 0 6
106092: PPUSH
106093: LD_VAR 0 7
106097: PPUSH
106098: LD_VAR 0 8
106102: PPUSH
106103: LD_VAR 0 9
106107: PPUSH
106108: LD_VAR 0 4
106112: PPUSH
106113: LD_VAR 0 5
106117: PPUSH
106118: CALL 106160 0 6
106122: GO 106155
106124: LD_INT 304
106126: DOUBLE
106127: EQUAL
106128: IFTRUE 106132
106130: GO 106154
106132: POP
// hHackTeleport ( unit , x , y ) ; end ;
106133: LD_VAR 0 2
106137: PPUSH
106138: LD_VAR 0 4
106142: PPUSH
106143: LD_VAR 0 5
106147: PPUSH
106148: CALL 107919 0 3
106152: GO 106155
106154: POP
// end ;
106155: LD_VAR 0 12
106159: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
106160: LD_INT 0
106162: PPUSH
106163: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
106164: LD_VAR 0 1
106168: PUSH
106169: LD_INT 1
106171: LESS
106172: PUSH
106173: LD_VAR 0 1
106177: PUSH
106178: LD_INT 3
106180: GREATER
106181: OR
106182: PUSH
106183: LD_VAR 0 5
106187: PPUSH
106188: LD_VAR 0 6
106192: PPUSH
106193: CALL_OW 428
106197: OR
106198: IFFALSE 106202
// exit ;
106200: GO 106922
// uc_side := your_side ;
106202: LD_ADDR_OWVAR 20
106206: PUSH
106207: LD_OWVAR 2
106211: ST_TO_ADDR
// uc_nation := nation ;
106212: LD_ADDR_OWVAR 21
106216: PUSH
106217: LD_VAR 0 1
106221: ST_TO_ADDR
// bc_level = 1 ;
106222: LD_ADDR_OWVAR 43
106226: PUSH
106227: LD_INT 1
106229: ST_TO_ADDR
// case btype of 1 :
106230: LD_VAR 0 2
106234: PUSH
106235: LD_INT 1
106237: DOUBLE
106238: EQUAL
106239: IFTRUE 106243
106241: GO 106254
106243: POP
// bc_type := b_depot ; 2 :
106244: LD_ADDR_OWVAR 42
106248: PUSH
106249: LD_INT 0
106251: ST_TO_ADDR
106252: GO 106866
106254: LD_INT 2
106256: DOUBLE
106257: EQUAL
106258: IFTRUE 106262
106260: GO 106273
106262: POP
// bc_type := b_warehouse ; 3 :
106263: LD_ADDR_OWVAR 42
106267: PUSH
106268: LD_INT 1
106270: ST_TO_ADDR
106271: GO 106866
106273: LD_INT 3
106275: DOUBLE
106276: EQUAL
106277: IFTRUE 106281
106279: GO 106292
106281: POP
// bc_type := b_lab ; 4 .. 9 :
106282: LD_ADDR_OWVAR 42
106286: PUSH
106287: LD_INT 6
106289: ST_TO_ADDR
106290: GO 106866
106292: LD_INT 4
106294: DOUBLE
106295: GREATEREQUAL
106296: IFFALSE 106304
106298: LD_INT 9
106300: DOUBLE
106301: LESSEQUAL
106302: IFTRUE 106306
106304: GO 106358
106306: POP
// begin bc_type := b_lab_half ;
106307: LD_ADDR_OWVAR 42
106311: PUSH
106312: LD_INT 7
106314: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
106315: LD_ADDR_OWVAR 44
106319: PUSH
106320: LD_INT 10
106322: PUSH
106323: LD_INT 11
106325: PUSH
106326: LD_INT 12
106328: PUSH
106329: LD_INT 15
106331: PUSH
106332: LD_INT 14
106334: PUSH
106335: LD_INT 13
106337: PUSH
106338: EMPTY
106339: LIST
106340: LIST
106341: LIST
106342: LIST
106343: LIST
106344: LIST
106345: PUSH
106346: LD_VAR 0 2
106350: PUSH
106351: LD_INT 3
106353: MINUS
106354: ARRAY
106355: ST_TO_ADDR
// end ; 10 .. 13 :
106356: GO 106866
106358: LD_INT 10
106360: DOUBLE
106361: GREATEREQUAL
106362: IFFALSE 106370
106364: LD_INT 13
106366: DOUBLE
106367: LESSEQUAL
106368: IFTRUE 106372
106370: GO 106449
106372: POP
// begin bc_type := b_lab_full ;
106373: LD_ADDR_OWVAR 42
106377: PUSH
106378: LD_INT 8
106380: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
106381: LD_ADDR_OWVAR 44
106385: PUSH
106386: LD_INT 10
106388: PUSH
106389: LD_INT 12
106391: PUSH
106392: LD_INT 14
106394: PUSH
106395: LD_INT 13
106397: PUSH
106398: EMPTY
106399: LIST
106400: LIST
106401: LIST
106402: LIST
106403: PUSH
106404: LD_VAR 0 2
106408: PUSH
106409: LD_INT 9
106411: MINUS
106412: ARRAY
106413: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
106414: LD_ADDR_OWVAR 45
106418: PUSH
106419: LD_INT 11
106421: PUSH
106422: LD_INT 15
106424: PUSH
106425: LD_INT 12
106427: PUSH
106428: LD_INT 15
106430: PUSH
106431: EMPTY
106432: LIST
106433: LIST
106434: LIST
106435: LIST
106436: PUSH
106437: LD_VAR 0 2
106441: PUSH
106442: LD_INT 9
106444: MINUS
106445: ARRAY
106446: ST_TO_ADDR
// end ; 14 :
106447: GO 106866
106449: LD_INT 14
106451: DOUBLE
106452: EQUAL
106453: IFTRUE 106457
106455: GO 106468
106457: POP
// bc_type := b_workshop ; 15 :
106458: LD_ADDR_OWVAR 42
106462: PUSH
106463: LD_INT 2
106465: ST_TO_ADDR
106466: GO 106866
106468: LD_INT 15
106470: DOUBLE
106471: EQUAL
106472: IFTRUE 106476
106474: GO 106487
106476: POP
// bc_type := b_factory ; 16 :
106477: LD_ADDR_OWVAR 42
106481: PUSH
106482: LD_INT 3
106484: ST_TO_ADDR
106485: GO 106866
106487: LD_INT 16
106489: DOUBLE
106490: EQUAL
106491: IFTRUE 106495
106493: GO 106506
106495: POP
// bc_type := b_ext_gun ; 17 :
106496: LD_ADDR_OWVAR 42
106500: PUSH
106501: LD_INT 17
106503: ST_TO_ADDR
106504: GO 106866
106506: LD_INT 17
106508: DOUBLE
106509: EQUAL
106510: IFTRUE 106514
106512: GO 106542
106514: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
106515: LD_ADDR_OWVAR 42
106519: PUSH
106520: LD_INT 19
106522: PUSH
106523: LD_INT 23
106525: PUSH
106526: LD_INT 19
106528: PUSH
106529: EMPTY
106530: LIST
106531: LIST
106532: LIST
106533: PUSH
106534: LD_VAR 0 1
106538: ARRAY
106539: ST_TO_ADDR
106540: GO 106866
106542: LD_INT 18
106544: DOUBLE
106545: EQUAL
106546: IFTRUE 106550
106548: GO 106561
106550: POP
// bc_type := b_ext_radar ; 19 :
106551: LD_ADDR_OWVAR 42
106555: PUSH
106556: LD_INT 20
106558: ST_TO_ADDR
106559: GO 106866
106561: LD_INT 19
106563: DOUBLE
106564: EQUAL
106565: IFTRUE 106569
106567: GO 106580
106569: POP
// bc_type := b_ext_radio ; 20 :
106570: LD_ADDR_OWVAR 42
106574: PUSH
106575: LD_INT 22
106577: ST_TO_ADDR
106578: GO 106866
106580: LD_INT 20
106582: DOUBLE
106583: EQUAL
106584: IFTRUE 106588
106586: GO 106599
106588: POP
// bc_type := b_ext_siberium ; 21 :
106589: LD_ADDR_OWVAR 42
106593: PUSH
106594: LD_INT 21
106596: ST_TO_ADDR
106597: GO 106866
106599: LD_INT 21
106601: DOUBLE
106602: EQUAL
106603: IFTRUE 106607
106605: GO 106618
106607: POP
// bc_type := b_ext_computer ; 22 :
106608: LD_ADDR_OWVAR 42
106612: PUSH
106613: LD_INT 24
106615: ST_TO_ADDR
106616: GO 106866
106618: LD_INT 22
106620: DOUBLE
106621: EQUAL
106622: IFTRUE 106626
106624: GO 106637
106626: POP
// bc_type := b_ext_track ; 23 :
106627: LD_ADDR_OWVAR 42
106631: PUSH
106632: LD_INT 16
106634: ST_TO_ADDR
106635: GO 106866
106637: LD_INT 23
106639: DOUBLE
106640: EQUAL
106641: IFTRUE 106645
106643: GO 106656
106645: POP
// bc_type := b_ext_laser ; 24 :
106646: LD_ADDR_OWVAR 42
106650: PUSH
106651: LD_INT 25
106653: ST_TO_ADDR
106654: GO 106866
106656: LD_INT 24
106658: DOUBLE
106659: EQUAL
106660: IFTRUE 106664
106662: GO 106675
106664: POP
// bc_type := b_control_tower ; 25 :
106665: LD_ADDR_OWVAR 42
106669: PUSH
106670: LD_INT 36
106672: ST_TO_ADDR
106673: GO 106866
106675: LD_INT 25
106677: DOUBLE
106678: EQUAL
106679: IFTRUE 106683
106681: GO 106694
106683: POP
// bc_type := b_breastwork ; 26 :
106684: LD_ADDR_OWVAR 42
106688: PUSH
106689: LD_INT 31
106691: ST_TO_ADDR
106692: GO 106866
106694: LD_INT 26
106696: DOUBLE
106697: EQUAL
106698: IFTRUE 106702
106700: GO 106713
106702: POP
// bc_type := b_bunker ; 27 :
106703: LD_ADDR_OWVAR 42
106707: PUSH
106708: LD_INT 32
106710: ST_TO_ADDR
106711: GO 106866
106713: LD_INT 27
106715: DOUBLE
106716: EQUAL
106717: IFTRUE 106721
106719: GO 106732
106721: POP
// bc_type := b_turret ; 28 :
106722: LD_ADDR_OWVAR 42
106726: PUSH
106727: LD_INT 33
106729: ST_TO_ADDR
106730: GO 106866
106732: LD_INT 28
106734: DOUBLE
106735: EQUAL
106736: IFTRUE 106740
106738: GO 106751
106740: POP
// bc_type := b_armoury ; 29 :
106741: LD_ADDR_OWVAR 42
106745: PUSH
106746: LD_INT 4
106748: ST_TO_ADDR
106749: GO 106866
106751: LD_INT 29
106753: DOUBLE
106754: EQUAL
106755: IFTRUE 106759
106757: GO 106770
106759: POP
// bc_type := b_barracks ; 30 :
106760: LD_ADDR_OWVAR 42
106764: PUSH
106765: LD_INT 5
106767: ST_TO_ADDR
106768: GO 106866
106770: LD_INT 30
106772: DOUBLE
106773: EQUAL
106774: IFTRUE 106778
106776: GO 106789
106778: POP
// bc_type := b_solar_power ; 31 :
106779: LD_ADDR_OWVAR 42
106783: PUSH
106784: LD_INT 27
106786: ST_TO_ADDR
106787: GO 106866
106789: LD_INT 31
106791: DOUBLE
106792: EQUAL
106793: IFTRUE 106797
106795: GO 106808
106797: POP
// bc_type := b_oil_power ; 32 :
106798: LD_ADDR_OWVAR 42
106802: PUSH
106803: LD_INT 26
106805: ST_TO_ADDR
106806: GO 106866
106808: LD_INT 32
106810: DOUBLE
106811: EQUAL
106812: IFTRUE 106816
106814: GO 106827
106816: POP
// bc_type := b_siberite_power ; 33 :
106817: LD_ADDR_OWVAR 42
106821: PUSH
106822: LD_INT 28
106824: ST_TO_ADDR
106825: GO 106866
106827: LD_INT 33
106829: DOUBLE
106830: EQUAL
106831: IFTRUE 106835
106833: GO 106846
106835: POP
// bc_type := b_oil_mine ; 34 :
106836: LD_ADDR_OWVAR 42
106840: PUSH
106841: LD_INT 29
106843: ST_TO_ADDR
106844: GO 106866
106846: LD_INT 34
106848: DOUBLE
106849: EQUAL
106850: IFTRUE 106854
106852: GO 106865
106854: POP
// bc_type := b_siberite_mine ; end ;
106855: LD_ADDR_OWVAR 42
106859: PUSH
106860: LD_INT 30
106862: ST_TO_ADDR
106863: GO 106866
106865: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
106866: LD_ADDR_VAR 0 8
106870: PUSH
106871: LD_VAR 0 5
106875: PPUSH
106876: LD_VAR 0 6
106880: PPUSH
106881: LD_VAR 0 3
106885: PPUSH
106886: CALL_OW 47
106890: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
106891: LD_OWVAR 42
106895: PUSH
106896: LD_INT 32
106898: PUSH
106899: LD_INT 33
106901: PUSH
106902: EMPTY
106903: LIST
106904: LIST
106905: IN
106906: IFFALSE 106922
// PlaceWeaponTurret ( b , weapon ) ;
106908: LD_VAR 0 8
106912: PPUSH
106913: LD_VAR 0 4
106917: PPUSH
106918: CALL_OW 431
// end ;
106922: LD_VAR 0 7
106926: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
106927: LD_INT 0
106929: PPUSH
106930: PPUSH
106931: PPUSH
106932: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
106933: LD_ADDR_VAR 0 4
106937: PUSH
106938: LD_INT 22
106940: PUSH
106941: LD_OWVAR 2
106945: PUSH
106946: EMPTY
106947: LIST
106948: LIST
106949: PUSH
106950: LD_INT 2
106952: PUSH
106953: LD_INT 30
106955: PUSH
106956: LD_INT 0
106958: PUSH
106959: EMPTY
106960: LIST
106961: LIST
106962: PUSH
106963: LD_INT 30
106965: PUSH
106966: LD_INT 1
106968: PUSH
106969: EMPTY
106970: LIST
106971: LIST
106972: PUSH
106973: EMPTY
106974: LIST
106975: LIST
106976: LIST
106977: PUSH
106978: EMPTY
106979: LIST
106980: LIST
106981: PPUSH
106982: CALL_OW 69
106986: ST_TO_ADDR
// if not tmp then
106987: LD_VAR 0 4
106991: NOT
106992: IFFALSE 106996
// exit ;
106994: GO 107055
// for i in tmp do
106996: LD_ADDR_VAR 0 2
107000: PUSH
107001: LD_VAR 0 4
107005: PUSH
107006: FOR_IN
107007: IFFALSE 107053
// for j = 1 to 3 do
107009: LD_ADDR_VAR 0 3
107013: PUSH
107014: DOUBLE
107015: LD_INT 1
107017: DEC
107018: ST_TO_ADDR
107019: LD_INT 3
107021: PUSH
107022: FOR_TO
107023: IFFALSE 107049
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
107025: LD_VAR 0 2
107029: PPUSH
107030: CALL_OW 274
107034: PPUSH
107035: LD_VAR 0 3
107039: PPUSH
107040: LD_INT 99999
107042: PPUSH
107043: CALL_OW 277
107047: GO 107022
107049: POP
107050: POP
107051: GO 107006
107053: POP
107054: POP
// end ;
107055: LD_VAR 0 1
107059: RET
// export function hHackSetLevel10 ; var i , j ; begin
107060: LD_INT 0
107062: PPUSH
107063: PPUSH
107064: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
107065: LD_ADDR_VAR 0 2
107069: PUSH
107070: LD_INT 21
107072: PUSH
107073: LD_INT 1
107075: PUSH
107076: EMPTY
107077: LIST
107078: LIST
107079: PPUSH
107080: CALL_OW 69
107084: PUSH
107085: FOR_IN
107086: IFFALSE 107138
// if IsSelected ( i ) then
107088: LD_VAR 0 2
107092: PPUSH
107093: CALL_OW 306
107097: IFFALSE 107136
// begin for j := 1 to 4 do
107099: LD_ADDR_VAR 0 3
107103: PUSH
107104: DOUBLE
107105: LD_INT 1
107107: DEC
107108: ST_TO_ADDR
107109: LD_INT 4
107111: PUSH
107112: FOR_TO
107113: IFFALSE 107134
// SetSkill ( i , j , 10 ) ;
107115: LD_VAR 0 2
107119: PPUSH
107120: LD_VAR 0 3
107124: PPUSH
107125: LD_INT 10
107127: PPUSH
107128: CALL_OW 237
107132: GO 107112
107134: POP
107135: POP
// end ;
107136: GO 107085
107138: POP
107139: POP
// end ;
107140: LD_VAR 0 1
107144: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
107145: LD_INT 0
107147: PPUSH
107148: PPUSH
107149: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
107150: LD_ADDR_VAR 0 2
107154: PUSH
107155: LD_INT 22
107157: PUSH
107158: LD_OWVAR 2
107162: PUSH
107163: EMPTY
107164: LIST
107165: LIST
107166: PUSH
107167: LD_INT 21
107169: PUSH
107170: LD_INT 1
107172: PUSH
107173: EMPTY
107174: LIST
107175: LIST
107176: PUSH
107177: EMPTY
107178: LIST
107179: LIST
107180: PPUSH
107181: CALL_OW 69
107185: PUSH
107186: FOR_IN
107187: IFFALSE 107228
// begin for j := 1 to 4 do
107189: LD_ADDR_VAR 0 3
107193: PUSH
107194: DOUBLE
107195: LD_INT 1
107197: DEC
107198: ST_TO_ADDR
107199: LD_INT 4
107201: PUSH
107202: FOR_TO
107203: IFFALSE 107224
// SetSkill ( i , j , 10 ) ;
107205: LD_VAR 0 2
107209: PPUSH
107210: LD_VAR 0 3
107214: PPUSH
107215: LD_INT 10
107217: PPUSH
107218: CALL_OW 237
107222: GO 107202
107224: POP
107225: POP
// end ;
107226: GO 107186
107228: POP
107229: POP
// end ;
107230: LD_VAR 0 1
107234: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
107235: LD_INT 0
107237: PPUSH
// uc_side := your_side ;
107238: LD_ADDR_OWVAR 20
107242: PUSH
107243: LD_OWVAR 2
107247: ST_TO_ADDR
// uc_nation := nation ;
107248: LD_ADDR_OWVAR 21
107252: PUSH
107253: LD_VAR 0 1
107257: ST_TO_ADDR
// InitHc ;
107258: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
107262: LD_INT 0
107264: PPUSH
107265: LD_VAR 0 2
107269: PPUSH
107270: LD_VAR 0 3
107274: PPUSH
107275: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
107279: LD_VAR 0 4
107283: PPUSH
107284: LD_VAR 0 5
107288: PPUSH
107289: CALL_OW 428
107293: PUSH
107294: LD_INT 0
107296: EQUAL
107297: IFFALSE 107321
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
107299: CALL_OW 44
107303: PPUSH
107304: LD_VAR 0 4
107308: PPUSH
107309: LD_VAR 0 5
107313: PPUSH
107314: LD_INT 1
107316: PPUSH
107317: CALL_OW 48
// end ;
107321: LD_VAR 0 6
107325: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
107326: LD_INT 0
107328: PPUSH
107329: PPUSH
// uc_side := your_side ;
107330: LD_ADDR_OWVAR 20
107334: PUSH
107335: LD_OWVAR 2
107339: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
107340: LD_VAR 0 1
107344: PUSH
107345: LD_INT 1
107347: PUSH
107348: LD_INT 2
107350: PUSH
107351: LD_INT 3
107353: PUSH
107354: LD_INT 4
107356: PUSH
107357: LD_INT 5
107359: PUSH
107360: EMPTY
107361: LIST
107362: LIST
107363: LIST
107364: LIST
107365: LIST
107366: IN
107367: IFFALSE 107379
// uc_nation := nation_american else
107369: LD_ADDR_OWVAR 21
107373: PUSH
107374: LD_INT 1
107376: ST_TO_ADDR
107377: GO 107422
// if chassis in [ 11 , 12 , 13 , 14 ] then
107379: LD_VAR 0 1
107383: PUSH
107384: LD_INT 11
107386: PUSH
107387: LD_INT 12
107389: PUSH
107390: LD_INT 13
107392: PUSH
107393: LD_INT 14
107395: PUSH
107396: EMPTY
107397: LIST
107398: LIST
107399: LIST
107400: LIST
107401: IN
107402: IFFALSE 107414
// uc_nation := nation_arabian else
107404: LD_ADDR_OWVAR 21
107408: PUSH
107409: LD_INT 2
107411: ST_TO_ADDR
107412: GO 107422
// uc_nation := nation_russian ;
107414: LD_ADDR_OWVAR 21
107418: PUSH
107419: LD_INT 3
107421: ST_TO_ADDR
// vc_chassis := chassis ;
107422: LD_ADDR_OWVAR 37
107426: PUSH
107427: LD_VAR 0 1
107431: ST_TO_ADDR
// vc_engine := engine ;
107432: LD_ADDR_OWVAR 39
107436: PUSH
107437: LD_VAR 0 2
107441: ST_TO_ADDR
// vc_control := control ;
107442: LD_ADDR_OWVAR 38
107446: PUSH
107447: LD_VAR 0 3
107451: ST_TO_ADDR
// vc_weapon := weapon ;
107452: LD_ADDR_OWVAR 40
107456: PUSH
107457: LD_VAR 0 4
107461: ST_TO_ADDR
// un := CreateVehicle ;
107462: LD_ADDR_VAR 0 8
107466: PUSH
107467: CALL_OW 45
107471: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
107472: LD_VAR 0 8
107476: PPUSH
107477: LD_INT 0
107479: PPUSH
107480: LD_INT 5
107482: PPUSH
107483: CALL_OW 12
107487: PPUSH
107488: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
107492: LD_VAR 0 8
107496: PPUSH
107497: LD_VAR 0 5
107501: PPUSH
107502: LD_VAR 0 6
107506: PPUSH
107507: LD_INT 1
107509: PPUSH
107510: CALL_OW 48
// end ;
107514: LD_VAR 0 7
107518: RET
// export hInvincible ; every 1 do
107519: GO 107521
107521: DISABLE
// hInvincible := [ ] ;
107522: LD_ADDR_EXP 180
107526: PUSH
107527: EMPTY
107528: ST_TO_ADDR
107529: END
// every 10 do var i ;
107530: GO 107532
107532: DISABLE
107533: LD_INT 0
107535: PPUSH
// begin enable ;
107536: ENABLE
// if not hInvincible then
107537: LD_EXP 180
107541: NOT
107542: IFFALSE 107546
// exit ;
107544: GO 107590
// for i in hInvincible do
107546: LD_ADDR_VAR 0 1
107550: PUSH
107551: LD_EXP 180
107555: PUSH
107556: FOR_IN
107557: IFFALSE 107588
// if GetLives ( i ) < 1000 then
107559: LD_VAR 0 1
107563: PPUSH
107564: CALL_OW 256
107568: PUSH
107569: LD_INT 1000
107571: LESS
107572: IFFALSE 107586
// SetLives ( i , 1000 ) ;
107574: LD_VAR 0 1
107578: PPUSH
107579: LD_INT 1000
107581: PPUSH
107582: CALL_OW 234
107586: GO 107556
107588: POP
107589: POP
// end ;
107590: PPOPN 1
107592: END
// export function hHackInvincible ; var i ; begin
107593: LD_INT 0
107595: PPUSH
107596: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
107597: LD_ADDR_VAR 0 2
107601: PUSH
107602: LD_INT 2
107604: PUSH
107605: LD_INT 21
107607: PUSH
107608: LD_INT 1
107610: PUSH
107611: EMPTY
107612: LIST
107613: LIST
107614: PUSH
107615: LD_INT 21
107617: PUSH
107618: LD_INT 2
107620: PUSH
107621: EMPTY
107622: LIST
107623: LIST
107624: PUSH
107625: EMPTY
107626: LIST
107627: LIST
107628: LIST
107629: PPUSH
107630: CALL_OW 69
107634: PUSH
107635: FOR_IN
107636: IFFALSE 107697
// if IsSelected ( i ) then
107638: LD_VAR 0 2
107642: PPUSH
107643: CALL_OW 306
107647: IFFALSE 107695
// begin if i in hInvincible then
107649: LD_VAR 0 2
107653: PUSH
107654: LD_EXP 180
107658: IN
107659: IFFALSE 107679
// hInvincible := hInvincible diff i else
107661: LD_ADDR_EXP 180
107665: PUSH
107666: LD_EXP 180
107670: PUSH
107671: LD_VAR 0 2
107675: DIFF
107676: ST_TO_ADDR
107677: GO 107695
// hInvincible := hInvincible union i ;
107679: LD_ADDR_EXP 180
107683: PUSH
107684: LD_EXP 180
107688: PUSH
107689: LD_VAR 0 2
107693: UNION
107694: ST_TO_ADDR
// end ;
107695: GO 107635
107697: POP
107698: POP
// end ;
107699: LD_VAR 0 1
107703: RET
// export function hHackInvisible ; var i , j ; begin
107704: LD_INT 0
107706: PPUSH
107707: PPUSH
107708: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
107709: LD_ADDR_VAR 0 2
107713: PUSH
107714: LD_INT 21
107716: PUSH
107717: LD_INT 1
107719: PUSH
107720: EMPTY
107721: LIST
107722: LIST
107723: PPUSH
107724: CALL_OW 69
107728: PUSH
107729: FOR_IN
107730: IFFALSE 107754
// if IsSelected ( i ) then
107732: LD_VAR 0 2
107736: PPUSH
107737: CALL_OW 306
107741: IFFALSE 107752
// ComForceInvisible ( i ) ;
107743: LD_VAR 0 2
107747: PPUSH
107748: CALL_OW 496
107752: GO 107729
107754: POP
107755: POP
// end ;
107756: LD_VAR 0 1
107760: RET
// export function hHackChangeYourSide ; begin
107761: LD_INT 0
107763: PPUSH
// if your_side = 8 then
107764: LD_OWVAR 2
107768: PUSH
107769: LD_INT 8
107771: EQUAL
107772: IFFALSE 107784
// your_side := 0 else
107774: LD_ADDR_OWVAR 2
107778: PUSH
107779: LD_INT 0
107781: ST_TO_ADDR
107782: GO 107798
// your_side := your_side + 1 ;
107784: LD_ADDR_OWVAR 2
107788: PUSH
107789: LD_OWVAR 2
107793: PUSH
107794: LD_INT 1
107796: PLUS
107797: ST_TO_ADDR
// end ;
107798: LD_VAR 0 1
107802: RET
// export function hHackChangeUnitSide ; var i , j ; begin
107803: LD_INT 0
107805: PPUSH
107806: PPUSH
107807: PPUSH
// for i in all_units do
107808: LD_ADDR_VAR 0 2
107812: PUSH
107813: LD_OWVAR 3
107817: PUSH
107818: FOR_IN
107819: IFFALSE 107897
// if IsSelected ( i ) then
107821: LD_VAR 0 2
107825: PPUSH
107826: CALL_OW 306
107830: IFFALSE 107895
// begin j := GetSide ( i ) ;
107832: LD_ADDR_VAR 0 3
107836: PUSH
107837: LD_VAR 0 2
107841: PPUSH
107842: CALL_OW 255
107846: ST_TO_ADDR
// if j = 8 then
107847: LD_VAR 0 3
107851: PUSH
107852: LD_INT 8
107854: EQUAL
107855: IFFALSE 107867
// j := 0 else
107857: LD_ADDR_VAR 0 3
107861: PUSH
107862: LD_INT 0
107864: ST_TO_ADDR
107865: GO 107881
// j := j + 1 ;
107867: LD_ADDR_VAR 0 3
107871: PUSH
107872: LD_VAR 0 3
107876: PUSH
107877: LD_INT 1
107879: PLUS
107880: ST_TO_ADDR
// SetSide ( i , j ) ;
107881: LD_VAR 0 2
107885: PPUSH
107886: LD_VAR 0 3
107890: PPUSH
107891: CALL_OW 235
// end ;
107895: GO 107818
107897: POP
107898: POP
// end ;
107899: LD_VAR 0 1
107903: RET
// export function hHackFog ; begin
107904: LD_INT 0
107906: PPUSH
// FogOff ( true ) ;
107907: LD_INT 1
107909: PPUSH
107910: CALL_OW 344
// end ;
107914: LD_VAR 0 1
107918: RET
// export function hHackTeleport ( unit , x , y ) ; begin
107919: LD_INT 0
107921: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
107922: LD_VAR 0 1
107926: PPUSH
107927: LD_VAR 0 2
107931: PPUSH
107932: LD_VAR 0 3
107936: PPUSH
107937: LD_INT 1
107939: PPUSH
107940: LD_INT 1
107942: PPUSH
107943: CALL_OW 483
// CenterOnXY ( x , y ) ;
107947: LD_VAR 0 2
107951: PPUSH
107952: LD_VAR 0 3
107956: PPUSH
107957: CALL_OW 84
// end ;
107961: LD_VAR 0 4
107965: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
107966: LD_INT 0
107968: PPUSH
107969: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
107970: LD_VAR 0 1
107974: NOT
107975: PUSH
107976: LD_VAR 0 2
107980: PPUSH
107981: LD_VAR 0 3
107985: PPUSH
107986: CALL_OW 488
107990: NOT
107991: OR
107992: PUSH
107993: LD_VAR 0 1
107997: PPUSH
107998: CALL_OW 266
108002: PUSH
108003: LD_INT 3
108005: NONEQUAL
108006: PUSH
108007: LD_VAR 0 1
108011: PPUSH
108012: CALL_OW 247
108016: PUSH
108017: LD_INT 1
108019: EQUAL
108020: NOT
108021: AND
108022: OR
108023: IFFALSE 108027
// exit ;
108025: GO 108176
// if GetType ( factory ) = unit_human then
108027: LD_VAR 0 1
108031: PPUSH
108032: CALL_OW 247
108036: PUSH
108037: LD_INT 1
108039: EQUAL
108040: IFFALSE 108057
// factory := IsInUnit ( factory ) ;
108042: LD_ADDR_VAR 0 1
108046: PUSH
108047: LD_VAR 0 1
108051: PPUSH
108052: CALL_OW 310
108056: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
108057: LD_VAR 0 1
108061: PPUSH
108062: CALL_OW 266
108066: PUSH
108067: LD_INT 3
108069: NONEQUAL
108070: IFFALSE 108074
// exit ;
108072: GO 108176
// if HexInfo ( x , y ) = factory then
108074: LD_VAR 0 2
108078: PPUSH
108079: LD_VAR 0 3
108083: PPUSH
108084: CALL_OW 428
108088: PUSH
108089: LD_VAR 0 1
108093: EQUAL
108094: IFFALSE 108121
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
108096: LD_ADDR_EXP 181
108100: PUSH
108101: LD_EXP 181
108105: PPUSH
108106: LD_VAR 0 1
108110: PPUSH
108111: LD_INT 0
108113: PPUSH
108114: CALL_OW 1
108118: ST_TO_ADDR
108119: GO 108172
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
108121: LD_ADDR_EXP 181
108125: PUSH
108126: LD_EXP 181
108130: PPUSH
108131: LD_VAR 0 1
108135: PPUSH
108136: LD_VAR 0 1
108140: PPUSH
108141: CALL_OW 255
108145: PUSH
108146: LD_VAR 0 1
108150: PUSH
108151: LD_VAR 0 2
108155: PUSH
108156: LD_VAR 0 3
108160: PUSH
108161: EMPTY
108162: LIST
108163: LIST
108164: LIST
108165: LIST
108166: PPUSH
108167: CALL_OW 1
108171: ST_TO_ADDR
// UpdateFactoryWaypoints ;
108172: CALL 108181 0 0
// end ;
108176: LD_VAR 0 4
108180: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
108181: LD_INT 0
108183: PPUSH
108184: PPUSH
108185: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
108186: LD_STRING resetFactoryWaypoint();
108188: PPUSH
108189: CALL_OW 559
// if factoryWaypoints then
108193: LD_EXP 181
108197: IFFALSE 108323
// begin list := PrepareArray ( factoryWaypoints ) ;
108199: LD_ADDR_VAR 0 3
108203: PUSH
108204: LD_EXP 181
108208: PPUSH
108209: CALL 93288 0 1
108213: ST_TO_ADDR
// for i := 1 to list do
108214: LD_ADDR_VAR 0 2
108218: PUSH
108219: DOUBLE
108220: LD_INT 1
108222: DEC
108223: ST_TO_ADDR
108224: LD_VAR 0 3
108228: PUSH
108229: FOR_TO
108230: IFFALSE 108321
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
108232: LD_STRING setFactoryWaypointXY(
108234: PUSH
108235: LD_VAR 0 3
108239: PUSH
108240: LD_VAR 0 2
108244: ARRAY
108245: PUSH
108246: LD_INT 1
108248: ARRAY
108249: STR
108250: PUSH
108251: LD_STRING ,
108253: STR
108254: PUSH
108255: LD_VAR 0 3
108259: PUSH
108260: LD_VAR 0 2
108264: ARRAY
108265: PUSH
108266: LD_INT 2
108268: ARRAY
108269: STR
108270: PUSH
108271: LD_STRING ,
108273: STR
108274: PUSH
108275: LD_VAR 0 3
108279: PUSH
108280: LD_VAR 0 2
108284: ARRAY
108285: PUSH
108286: LD_INT 3
108288: ARRAY
108289: STR
108290: PUSH
108291: LD_STRING ,
108293: STR
108294: PUSH
108295: LD_VAR 0 3
108299: PUSH
108300: LD_VAR 0 2
108304: ARRAY
108305: PUSH
108306: LD_INT 4
108308: ARRAY
108309: STR
108310: PUSH
108311: LD_STRING )
108313: STR
108314: PPUSH
108315: CALL_OW 559
108319: GO 108229
108321: POP
108322: POP
// end ; end ;
108323: LD_VAR 0 1
108327: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
108328: LD_INT 0
108330: PPUSH
// if HexInfo ( x , y ) = warehouse then
108331: LD_VAR 0 2
108335: PPUSH
108336: LD_VAR 0 3
108340: PPUSH
108341: CALL_OW 428
108345: PUSH
108346: LD_VAR 0 1
108350: EQUAL
108351: IFFALSE 108378
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
108353: LD_ADDR_EXP 182
108357: PUSH
108358: LD_EXP 182
108362: PPUSH
108363: LD_VAR 0 1
108367: PPUSH
108368: LD_INT 0
108370: PPUSH
108371: CALL_OW 1
108375: ST_TO_ADDR
108376: GO 108429
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
108378: LD_ADDR_EXP 182
108382: PUSH
108383: LD_EXP 182
108387: PPUSH
108388: LD_VAR 0 1
108392: PPUSH
108393: LD_VAR 0 1
108397: PPUSH
108398: CALL_OW 255
108402: PUSH
108403: LD_VAR 0 1
108407: PUSH
108408: LD_VAR 0 2
108412: PUSH
108413: LD_VAR 0 3
108417: PUSH
108418: EMPTY
108419: LIST
108420: LIST
108421: LIST
108422: LIST
108423: PPUSH
108424: CALL_OW 1
108428: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
108429: CALL 108438 0 0
// end ;
108433: LD_VAR 0 4
108437: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
108438: LD_INT 0
108440: PPUSH
108441: PPUSH
108442: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
108443: LD_STRING resetWarehouseGatheringPoints();
108445: PPUSH
108446: CALL_OW 559
// if warehouseGatheringPoints then
108450: LD_EXP 182
108454: IFFALSE 108580
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
108456: LD_ADDR_VAR 0 3
108460: PUSH
108461: LD_EXP 182
108465: PPUSH
108466: CALL 93288 0 1
108470: ST_TO_ADDR
// for i := 1 to list do
108471: LD_ADDR_VAR 0 2
108475: PUSH
108476: DOUBLE
108477: LD_INT 1
108479: DEC
108480: ST_TO_ADDR
108481: LD_VAR 0 3
108485: PUSH
108486: FOR_TO
108487: IFFALSE 108578
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
108489: LD_STRING setWarehouseGatheringPointXY(
108491: PUSH
108492: LD_VAR 0 3
108496: PUSH
108497: LD_VAR 0 2
108501: ARRAY
108502: PUSH
108503: LD_INT 1
108505: ARRAY
108506: STR
108507: PUSH
108508: LD_STRING ,
108510: STR
108511: PUSH
108512: LD_VAR 0 3
108516: PUSH
108517: LD_VAR 0 2
108521: ARRAY
108522: PUSH
108523: LD_INT 2
108525: ARRAY
108526: STR
108527: PUSH
108528: LD_STRING ,
108530: STR
108531: PUSH
108532: LD_VAR 0 3
108536: PUSH
108537: LD_VAR 0 2
108541: ARRAY
108542: PUSH
108543: LD_INT 3
108545: ARRAY
108546: STR
108547: PUSH
108548: LD_STRING ,
108550: STR
108551: PUSH
108552: LD_VAR 0 3
108556: PUSH
108557: LD_VAR 0 2
108561: ARRAY
108562: PUSH
108563: LD_INT 4
108565: ARRAY
108566: STR
108567: PUSH
108568: LD_STRING )
108570: STR
108571: PPUSH
108572: CALL_OW 559
108576: GO 108486
108578: POP
108579: POP
// end ; end ;
108580: LD_VAR 0 1
108584: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
108585: LD_EXP 182
108589: IFFALSE 109274
108591: GO 108593
108593: DISABLE
108594: LD_INT 0
108596: PPUSH
108597: PPUSH
108598: PPUSH
108599: PPUSH
108600: PPUSH
108601: PPUSH
108602: PPUSH
108603: PPUSH
108604: PPUSH
// begin enable ;
108605: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
108606: LD_ADDR_VAR 0 3
108610: PUSH
108611: LD_EXP 182
108615: PPUSH
108616: CALL 93288 0 1
108620: ST_TO_ADDR
// if not list then
108621: LD_VAR 0 3
108625: NOT
108626: IFFALSE 108630
// exit ;
108628: GO 109274
// for i := 1 to list do
108630: LD_ADDR_VAR 0 1
108634: PUSH
108635: DOUBLE
108636: LD_INT 1
108638: DEC
108639: ST_TO_ADDR
108640: LD_VAR 0 3
108644: PUSH
108645: FOR_TO
108646: IFFALSE 109272
// begin depot := list [ i ] [ 2 ] ;
108648: LD_ADDR_VAR 0 8
108652: PUSH
108653: LD_VAR 0 3
108657: PUSH
108658: LD_VAR 0 1
108662: ARRAY
108663: PUSH
108664: LD_INT 2
108666: ARRAY
108667: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
108668: LD_ADDR_VAR 0 5
108672: PUSH
108673: LD_VAR 0 3
108677: PUSH
108678: LD_VAR 0 1
108682: ARRAY
108683: PUSH
108684: LD_INT 1
108686: ARRAY
108687: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
108688: LD_VAR 0 8
108692: PPUSH
108693: CALL_OW 301
108697: PUSH
108698: LD_VAR 0 5
108702: PUSH
108703: LD_VAR 0 8
108707: PPUSH
108708: CALL_OW 255
108712: NONEQUAL
108713: OR
108714: IFFALSE 108743
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
108716: LD_ADDR_EXP 182
108720: PUSH
108721: LD_EXP 182
108725: PPUSH
108726: LD_VAR 0 8
108730: PPUSH
108731: LD_INT 0
108733: PPUSH
108734: CALL_OW 1
108738: ST_TO_ADDR
// exit ;
108739: POP
108740: POP
108741: GO 109274
// end ; x := list [ i ] [ 3 ] ;
108743: LD_ADDR_VAR 0 6
108747: PUSH
108748: LD_VAR 0 3
108752: PUSH
108753: LD_VAR 0 1
108757: ARRAY
108758: PUSH
108759: LD_INT 3
108761: ARRAY
108762: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
108763: LD_ADDR_VAR 0 7
108767: PUSH
108768: LD_VAR 0 3
108772: PUSH
108773: LD_VAR 0 1
108777: ARRAY
108778: PUSH
108779: LD_INT 4
108781: ARRAY
108782: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
108783: LD_ADDR_VAR 0 9
108787: PUSH
108788: LD_VAR 0 6
108792: PPUSH
108793: LD_VAR 0 7
108797: PPUSH
108798: LD_INT 16
108800: PPUSH
108801: CALL 91876 0 3
108805: ST_TO_ADDR
// if not cratesNearbyPoint then
108806: LD_VAR 0 9
108810: NOT
108811: IFFALSE 108817
// exit ;
108813: POP
108814: POP
108815: GO 109274
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
108817: LD_ADDR_VAR 0 4
108821: PUSH
108822: LD_INT 22
108824: PUSH
108825: LD_VAR 0 5
108829: PUSH
108830: EMPTY
108831: LIST
108832: LIST
108833: PUSH
108834: LD_INT 3
108836: PUSH
108837: LD_INT 60
108839: PUSH
108840: EMPTY
108841: LIST
108842: PUSH
108843: EMPTY
108844: LIST
108845: LIST
108846: PUSH
108847: LD_INT 91
108849: PUSH
108850: LD_VAR 0 8
108854: PUSH
108855: LD_INT 6
108857: PUSH
108858: EMPTY
108859: LIST
108860: LIST
108861: LIST
108862: PUSH
108863: LD_INT 2
108865: PUSH
108866: LD_INT 25
108868: PUSH
108869: LD_INT 2
108871: PUSH
108872: EMPTY
108873: LIST
108874: LIST
108875: PUSH
108876: LD_INT 25
108878: PUSH
108879: LD_INT 16
108881: PUSH
108882: EMPTY
108883: LIST
108884: LIST
108885: PUSH
108886: EMPTY
108887: LIST
108888: LIST
108889: LIST
108890: PUSH
108891: EMPTY
108892: LIST
108893: LIST
108894: LIST
108895: LIST
108896: PPUSH
108897: CALL_OW 69
108901: PUSH
108902: LD_VAR 0 8
108906: PPUSH
108907: CALL_OW 313
108911: PPUSH
108912: LD_INT 3
108914: PUSH
108915: LD_INT 60
108917: PUSH
108918: EMPTY
108919: LIST
108920: PUSH
108921: EMPTY
108922: LIST
108923: LIST
108924: PUSH
108925: LD_INT 2
108927: PUSH
108928: LD_INT 25
108930: PUSH
108931: LD_INT 2
108933: PUSH
108934: EMPTY
108935: LIST
108936: LIST
108937: PUSH
108938: LD_INT 25
108940: PUSH
108941: LD_INT 16
108943: PUSH
108944: EMPTY
108945: LIST
108946: LIST
108947: PUSH
108948: EMPTY
108949: LIST
108950: LIST
108951: LIST
108952: PUSH
108953: EMPTY
108954: LIST
108955: LIST
108956: PPUSH
108957: CALL_OW 72
108961: UNION
108962: ST_TO_ADDR
// if tmp then
108963: LD_VAR 0 4
108967: IFFALSE 109047
// begin tmp := ShrinkArray ( tmp , 3 ) ;
108969: LD_ADDR_VAR 0 4
108973: PUSH
108974: LD_VAR 0 4
108978: PPUSH
108979: LD_INT 3
108981: PPUSH
108982: CALL 89845 0 2
108986: ST_TO_ADDR
// for j in tmp do
108987: LD_ADDR_VAR 0 2
108991: PUSH
108992: LD_VAR 0 4
108996: PUSH
108997: FOR_IN
108998: IFFALSE 109041
// begin if IsInUnit ( j ) then
109000: LD_VAR 0 2
109004: PPUSH
109005: CALL_OW 310
109009: IFFALSE 109020
// ComExit ( j ) ;
109011: LD_VAR 0 2
109015: PPUSH
109016: CALL 89928 0 1
// AddComCollect ( j , x , y ) ;
109020: LD_VAR 0 2
109024: PPUSH
109025: LD_VAR 0 6
109029: PPUSH
109030: LD_VAR 0 7
109034: PPUSH
109035: CALL_OW 177
// end ;
109039: GO 108997
109041: POP
109042: POP
// exit ;
109043: POP
109044: POP
109045: GO 109274
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
109047: LD_ADDR_VAR 0 4
109051: PUSH
109052: LD_INT 22
109054: PUSH
109055: LD_VAR 0 5
109059: PUSH
109060: EMPTY
109061: LIST
109062: LIST
109063: PUSH
109064: LD_INT 91
109066: PUSH
109067: LD_VAR 0 8
109071: PUSH
109072: LD_INT 8
109074: PUSH
109075: EMPTY
109076: LIST
109077: LIST
109078: LIST
109079: PUSH
109080: LD_INT 2
109082: PUSH
109083: LD_INT 34
109085: PUSH
109086: LD_INT 12
109088: PUSH
109089: EMPTY
109090: LIST
109091: LIST
109092: PUSH
109093: LD_INT 34
109095: PUSH
109096: LD_INT 51
109098: PUSH
109099: EMPTY
109100: LIST
109101: LIST
109102: PUSH
109103: LD_INT 34
109105: PUSH
109106: LD_INT 32
109108: PUSH
109109: EMPTY
109110: LIST
109111: LIST
109112: PUSH
109113: LD_INT 34
109115: PUSH
109116: LD_INT 89
109118: PUSH
109119: EMPTY
109120: LIST
109121: LIST
109122: PUSH
109123: EMPTY
109124: LIST
109125: LIST
109126: LIST
109127: LIST
109128: LIST
109129: PUSH
109130: EMPTY
109131: LIST
109132: LIST
109133: LIST
109134: PPUSH
109135: CALL_OW 69
109139: ST_TO_ADDR
// if tmp then
109140: LD_VAR 0 4
109144: IFFALSE 109270
// begin for j in tmp do
109146: LD_ADDR_VAR 0 2
109150: PUSH
109151: LD_VAR 0 4
109155: PUSH
109156: FOR_IN
109157: IFFALSE 109268
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
109159: LD_VAR 0 2
109163: PPUSH
109164: CALL_OW 262
109168: PUSH
109169: LD_INT 3
109171: EQUAL
109172: PUSH
109173: LD_VAR 0 2
109177: PPUSH
109178: CALL_OW 261
109182: PUSH
109183: LD_INT 20
109185: GREATER
109186: OR
109187: PUSH
109188: LD_VAR 0 2
109192: PPUSH
109193: CALL_OW 314
109197: NOT
109198: AND
109199: PUSH
109200: LD_VAR 0 2
109204: PPUSH
109205: CALL_OW 263
109209: PUSH
109210: LD_INT 1
109212: NONEQUAL
109213: PUSH
109214: LD_VAR 0 2
109218: PPUSH
109219: CALL_OW 311
109223: OR
109224: AND
109225: IFFALSE 109266
// begin ComCollect ( j , x , y ) ;
109227: LD_VAR 0 2
109231: PPUSH
109232: LD_VAR 0 6
109236: PPUSH
109237: LD_VAR 0 7
109241: PPUSH
109242: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
109246: LD_VAR 0 2
109250: PPUSH
109251: LD_VAR 0 8
109255: PPUSH
109256: CALL_OW 172
// exit ;
109260: POP
109261: POP
109262: POP
109263: POP
109264: GO 109274
// end ;
109266: GO 109156
109268: POP
109269: POP
// end ; end ;
109270: GO 108645
109272: POP
109273: POP
// end ; end_of_file
109274: PPOPN 9
109276: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
109277: LD_INT 0
109279: PPUSH
109280: PPUSH
109281: PPUSH
109282: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
109283: LD_VAR 0 1
109287: PPUSH
109288: CALL_OW 264
109292: PUSH
109293: LD_INT 91
109295: EQUAL
109296: IFFALSE 109368
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
109298: LD_INT 68
109300: PPUSH
109301: LD_VAR 0 1
109305: PPUSH
109306: CALL_OW 255
109310: PPUSH
109311: CALL_OW 321
109315: PUSH
109316: LD_INT 2
109318: EQUAL
109319: IFFALSE 109331
// eff := 70 else
109321: LD_ADDR_VAR 0 4
109325: PUSH
109326: LD_INT 70
109328: ST_TO_ADDR
109329: GO 109339
// eff := 30 ;
109331: LD_ADDR_VAR 0 4
109335: PUSH
109336: LD_INT 30
109338: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
109339: LD_VAR 0 1
109343: PPUSH
109344: CALL_OW 250
109348: PPUSH
109349: LD_VAR 0 1
109353: PPUSH
109354: CALL_OW 251
109358: PPUSH
109359: LD_VAR 0 4
109363: PPUSH
109364: CALL_OW 495
// end ; end ;
109368: LD_VAR 0 2
109372: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
109373: LD_INT 0
109375: PPUSH
// end ;
109376: LD_VAR 0 4
109380: RET
// export function SOS_Command ( cmd ) ; begin
109381: LD_INT 0
109383: PPUSH
// end ;
109384: LD_VAR 0 2
109388: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
109389: LD_INT 0
109391: PPUSH
// end ;
109392: LD_VAR 0 6
109396: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
109397: LD_INT 0
109399: PPUSH
109400: PPUSH
// if not vehicle or not factory then
109401: LD_VAR 0 1
109405: NOT
109406: PUSH
109407: LD_VAR 0 2
109411: NOT
109412: OR
109413: IFFALSE 109417
// exit ;
109415: GO 109648
// if factoryWaypoints >= factory then
109417: LD_EXP 181
109421: PUSH
109422: LD_VAR 0 2
109426: GREATEREQUAL
109427: IFFALSE 109648
// if factoryWaypoints [ factory ] then
109429: LD_EXP 181
109433: PUSH
109434: LD_VAR 0 2
109438: ARRAY
109439: IFFALSE 109648
// begin if GetControl ( vehicle ) = control_manual then
109441: LD_VAR 0 1
109445: PPUSH
109446: CALL_OW 263
109450: PUSH
109451: LD_INT 1
109453: EQUAL
109454: IFFALSE 109535
// begin driver := IsDrivenBy ( vehicle ) ;
109456: LD_ADDR_VAR 0 4
109460: PUSH
109461: LD_VAR 0 1
109465: PPUSH
109466: CALL_OW 311
109470: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
109471: LD_VAR 0 4
109475: PPUSH
109476: LD_EXP 181
109480: PUSH
109481: LD_VAR 0 2
109485: ARRAY
109486: PUSH
109487: LD_INT 3
109489: ARRAY
109490: PPUSH
109491: LD_EXP 181
109495: PUSH
109496: LD_VAR 0 2
109500: ARRAY
109501: PUSH
109502: LD_INT 4
109504: ARRAY
109505: PPUSH
109506: CALL_OW 171
// AddComExitVehicle ( driver ) ;
109510: LD_VAR 0 4
109514: PPUSH
109515: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
109519: LD_VAR 0 4
109523: PPUSH
109524: LD_VAR 0 2
109528: PPUSH
109529: CALL_OW 180
// end else
109533: GO 109648
// if GetControl ( vehicle ) = control_remote then
109535: LD_VAR 0 1
109539: PPUSH
109540: CALL_OW 263
109544: PUSH
109545: LD_INT 2
109547: EQUAL
109548: IFFALSE 109609
// begin wait ( 0 0$2 ) ;
109550: LD_INT 70
109552: PPUSH
109553: CALL_OW 67
// if Connect ( vehicle ) then
109557: LD_VAR 0 1
109561: PPUSH
109562: CALL 60168 0 1
109566: IFFALSE 109607
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
109568: LD_VAR 0 1
109572: PPUSH
109573: LD_EXP 181
109577: PUSH
109578: LD_VAR 0 2
109582: ARRAY
109583: PUSH
109584: LD_INT 3
109586: ARRAY
109587: PPUSH
109588: LD_EXP 181
109592: PUSH
109593: LD_VAR 0 2
109597: ARRAY
109598: PUSH
109599: LD_INT 4
109601: ARRAY
109602: PPUSH
109603: CALL_OW 171
// end else
109607: GO 109648
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
109609: LD_VAR 0 1
109613: PPUSH
109614: LD_EXP 181
109618: PUSH
109619: LD_VAR 0 2
109623: ARRAY
109624: PUSH
109625: LD_INT 3
109627: ARRAY
109628: PPUSH
109629: LD_EXP 181
109633: PUSH
109634: LD_VAR 0 2
109638: ARRAY
109639: PUSH
109640: LD_INT 4
109642: ARRAY
109643: PPUSH
109644: CALL_OW 171
// end ; end ;
109648: LD_VAR 0 3
109652: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
109653: LD_INT 0
109655: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
109656: LD_VAR 0 1
109660: PUSH
109661: LD_INT 250
109663: EQUAL
109664: PUSH
109665: LD_VAR 0 2
109669: PPUSH
109670: CALL_OW 264
109674: PUSH
109675: LD_INT 81
109677: EQUAL
109678: AND
109679: IFFALSE 109700
// MinerPlaceMine ( unit , x , y ) ;
109681: LD_VAR 0 2
109685: PPUSH
109686: LD_VAR 0 4
109690: PPUSH
109691: LD_VAR 0 5
109695: PPUSH
109696: CALL 112085 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
109700: LD_VAR 0 1
109704: PUSH
109705: LD_INT 251
109707: EQUAL
109708: PUSH
109709: LD_VAR 0 2
109713: PPUSH
109714: CALL_OW 264
109718: PUSH
109719: LD_INT 81
109721: EQUAL
109722: AND
109723: IFFALSE 109744
// MinerDetonateMine ( unit , x , y ) ;
109725: LD_VAR 0 2
109729: PPUSH
109730: LD_VAR 0 4
109734: PPUSH
109735: LD_VAR 0 5
109739: PPUSH
109740: CALL 112360 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
109744: LD_VAR 0 1
109748: PUSH
109749: LD_INT 252
109751: EQUAL
109752: PUSH
109753: LD_VAR 0 2
109757: PPUSH
109758: CALL_OW 264
109762: PUSH
109763: LD_INT 81
109765: EQUAL
109766: AND
109767: IFFALSE 109788
// MinerCreateMinefield ( unit , x , y ) ;
109769: LD_VAR 0 2
109773: PPUSH
109774: LD_VAR 0 4
109778: PPUSH
109779: LD_VAR 0 5
109783: PPUSH
109784: CALL 112777 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
109788: LD_VAR 0 1
109792: PUSH
109793: LD_INT 253
109795: EQUAL
109796: PUSH
109797: LD_VAR 0 2
109801: PPUSH
109802: CALL_OW 257
109806: PUSH
109807: LD_INT 5
109809: EQUAL
109810: AND
109811: IFFALSE 109832
// ComBinocular ( unit , x , y ) ;
109813: LD_VAR 0 2
109817: PPUSH
109818: LD_VAR 0 4
109822: PPUSH
109823: LD_VAR 0 5
109827: PPUSH
109828: CALL 113146 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
109832: LD_VAR 0 1
109836: PUSH
109837: LD_INT 254
109839: EQUAL
109840: PUSH
109841: LD_VAR 0 2
109845: PPUSH
109846: CALL_OW 264
109850: PUSH
109851: LD_INT 99
109853: EQUAL
109854: AND
109855: PUSH
109856: LD_VAR 0 3
109860: PPUSH
109861: CALL_OW 263
109865: PUSH
109866: LD_INT 3
109868: EQUAL
109869: AND
109870: IFFALSE 109886
// HackDestroyVehicle ( unit , selectedUnit ) ;
109872: LD_VAR 0 2
109876: PPUSH
109877: LD_VAR 0 3
109881: PPUSH
109882: CALL 111449 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
109886: LD_VAR 0 1
109890: PUSH
109891: LD_INT 255
109893: EQUAL
109894: PUSH
109895: LD_VAR 0 2
109899: PPUSH
109900: CALL_OW 264
109904: PUSH
109905: LD_INT 14
109907: PUSH
109908: LD_INT 53
109910: PUSH
109911: EMPTY
109912: LIST
109913: LIST
109914: IN
109915: AND
109916: PUSH
109917: LD_VAR 0 4
109921: PPUSH
109922: LD_VAR 0 5
109926: PPUSH
109927: CALL_OW 488
109931: AND
109932: IFFALSE 109956
// CutTreeXYR ( unit , x , y , 12 ) ;
109934: LD_VAR 0 2
109938: PPUSH
109939: LD_VAR 0 4
109943: PPUSH
109944: LD_VAR 0 5
109948: PPUSH
109949: LD_INT 12
109951: PPUSH
109952: CALL 110019 0 4
// if cmd = 256 then
109956: LD_VAR 0 1
109960: PUSH
109961: LD_INT 256
109963: EQUAL
109964: IFFALSE 109985
// SetFactoryWaypoint ( unit , x , y ) ;
109966: LD_VAR 0 2
109970: PPUSH
109971: LD_VAR 0 4
109975: PPUSH
109976: LD_VAR 0 5
109980: PPUSH
109981: CALL 107966 0 3
// if cmd = 257 then
109985: LD_VAR 0 1
109989: PUSH
109990: LD_INT 257
109992: EQUAL
109993: IFFALSE 110014
// SetWarehouseGatheringPoint ( unit , x , y ) ;
109995: LD_VAR 0 2
109999: PPUSH
110000: LD_VAR 0 4
110004: PPUSH
110005: LD_VAR 0 5
110009: PPUSH
110010: CALL 108328 0 3
// end ;
110014: LD_VAR 0 6
110018: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
110019: LD_INT 0
110021: PPUSH
110022: PPUSH
110023: PPUSH
110024: PPUSH
110025: PPUSH
110026: PPUSH
110027: PPUSH
110028: PPUSH
110029: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
110030: LD_VAR 0 1
110034: NOT
110035: PUSH
110036: LD_VAR 0 2
110040: PPUSH
110041: LD_VAR 0 3
110045: PPUSH
110046: CALL_OW 488
110050: NOT
110051: OR
110052: PUSH
110053: LD_VAR 0 4
110057: NOT
110058: OR
110059: IFFALSE 110063
// exit ;
110061: GO 110403
// list := [ ] ;
110063: LD_ADDR_VAR 0 13
110067: PUSH
110068: EMPTY
110069: ST_TO_ADDR
// if x - r < 0 then
110070: LD_VAR 0 2
110074: PUSH
110075: LD_VAR 0 4
110079: MINUS
110080: PUSH
110081: LD_INT 0
110083: LESS
110084: IFFALSE 110096
// min_x := 0 else
110086: LD_ADDR_VAR 0 7
110090: PUSH
110091: LD_INT 0
110093: ST_TO_ADDR
110094: GO 110112
// min_x := x - r ;
110096: LD_ADDR_VAR 0 7
110100: PUSH
110101: LD_VAR 0 2
110105: PUSH
110106: LD_VAR 0 4
110110: MINUS
110111: ST_TO_ADDR
// if y - r < 0 then
110112: LD_VAR 0 3
110116: PUSH
110117: LD_VAR 0 4
110121: MINUS
110122: PUSH
110123: LD_INT 0
110125: LESS
110126: IFFALSE 110138
// min_y := 0 else
110128: LD_ADDR_VAR 0 8
110132: PUSH
110133: LD_INT 0
110135: ST_TO_ADDR
110136: GO 110154
// min_y := y - r ;
110138: LD_ADDR_VAR 0 8
110142: PUSH
110143: LD_VAR 0 3
110147: PUSH
110148: LD_VAR 0 4
110152: MINUS
110153: ST_TO_ADDR
// max_x := x + r ;
110154: LD_ADDR_VAR 0 9
110158: PUSH
110159: LD_VAR 0 2
110163: PUSH
110164: LD_VAR 0 4
110168: PLUS
110169: ST_TO_ADDR
// max_y := y + r ;
110170: LD_ADDR_VAR 0 10
110174: PUSH
110175: LD_VAR 0 3
110179: PUSH
110180: LD_VAR 0 4
110184: PLUS
110185: ST_TO_ADDR
// for _x = min_x to max_x do
110186: LD_ADDR_VAR 0 11
110190: PUSH
110191: DOUBLE
110192: LD_VAR 0 7
110196: DEC
110197: ST_TO_ADDR
110198: LD_VAR 0 9
110202: PUSH
110203: FOR_TO
110204: IFFALSE 110321
// for _y = min_y to max_y do
110206: LD_ADDR_VAR 0 12
110210: PUSH
110211: DOUBLE
110212: LD_VAR 0 8
110216: DEC
110217: ST_TO_ADDR
110218: LD_VAR 0 10
110222: PUSH
110223: FOR_TO
110224: IFFALSE 110317
// begin if not ValidHex ( _x , _y ) then
110226: LD_VAR 0 11
110230: PPUSH
110231: LD_VAR 0 12
110235: PPUSH
110236: CALL_OW 488
110240: NOT
110241: IFFALSE 110245
// continue ;
110243: GO 110223
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
110245: LD_VAR 0 11
110249: PPUSH
110250: LD_VAR 0 12
110254: PPUSH
110255: CALL_OW 351
110259: PUSH
110260: LD_VAR 0 11
110264: PPUSH
110265: LD_VAR 0 12
110269: PPUSH
110270: CALL_OW 554
110274: AND
110275: IFFALSE 110315
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
110277: LD_ADDR_VAR 0 13
110281: PUSH
110282: LD_VAR 0 13
110286: PPUSH
110287: LD_VAR 0 13
110291: PUSH
110292: LD_INT 1
110294: PLUS
110295: PPUSH
110296: LD_VAR 0 11
110300: PUSH
110301: LD_VAR 0 12
110305: PUSH
110306: EMPTY
110307: LIST
110308: LIST
110309: PPUSH
110310: CALL_OW 2
110314: ST_TO_ADDR
// end ;
110315: GO 110223
110317: POP
110318: POP
110319: GO 110203
110321: POP
110322: POP
// if not list then
110323: LD_VAR 0 13
110327: NOT
110328: IFFALSE 110332
// exit ;
110330: GO 110403
// for i in list do
110332: LD_ADDR_VAR 0 6
110336: PUSH
110337: LD_VAR 0 13
110341: PUSH
110342: FOR_IN
110343: IFFALSE 110401
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
110345: LD_VAR 0 1
110349: PPUSH
110350: LD_STRING M
110352: PUSH
110353: LD_VAR 0 6
110357: PUSH
110358: LD_INT 1
110360: ARRAY
110361: PUSH
110362: LD_VAR 0 6
110366: PUSH
110367: LD_INT 2
110369: ARRAY
110370: PUSH
110371: LD_INT 0
110373: PUSH
110374: LD_INT 0
110376: PUSH
110377: LD_INT 0
110379: PUSH
110380: LD_INT 0
110382: PUSH
110383: EMPTY
110384: LIST
110385: LIST
110386: LIST
110387: LIST
110388: LIST
110389: LIST
110390: LIST
110391: PUSH
110392: EMPTY
110393: LIST
110394: PPUSH
110395: CALL_OW 447
110399: GO 110342
110401: POP
110402: POP
// end ;
110403: LD_VAR 0 5
110407: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
110408: LD_EXP 184
110412: NOT
110413: IFFALSE 110463
110415: GO 110417
110417: DISABLE
// begin initHack := true ;
110418: LD_ADDR_EXP 184
110422: PUSH
110423: LD_INT 1
110425: ST_TO_ADDR
// hackTanks := [ ] ;
110426: LD_ADDR_EXP 185
110430: PUSH
110431: EMPTY
110432: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
110433: LD_ADDR_EXP 186
110437: PUSH
110438: EMPTY
110439: ST_TO_ADDR
// hackLimit := 3 ;
110440: LD_ADDR_EXP 187
110444: PUSH
110445: LD_INT 3
110447: ST_TO_ADDR
// hackDist := 12 ;
110448: LD_ADDR_EXP 188
110452: PUSH
110453: LD_INT 12
110455: ST_TO_ADDR
// hackCounter := [ ] ;
110456: LD_ADDR_EXP 189
110460: PUSH
110461: EMPTY
110462: ST_TO_ADDR
// end ;
110463: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
110464: LD_EXP 184
110468: PUSH
110469: LD_INT 34
110471: PUSH
110472: LD_INT 99
110474: PUSH
110475: EMPTY
110476: LIST
110477: LIST
110478: PPUSH
110479: CALL_OW 69
110483: AND
110484: IFFALSE 110737
110486: GO 110488
110488: DISABLE
110489: LD_INT 0
110491: PPUSH
110492: PPUSH
// begin enable ;
110493: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
110494: LD_ADDR_VAR 0 1
110498: PUSH
110499: LD_INT 34
110501: PUSH
110502: LD_INT 99
110504: PUSH
110505: EMPTY
110506: LIST
110507: LIST
110508: PPUSH
110509: CALL_OW 69
110513: PUSH
110514: FOR_IN
110515: IFFALSE 110735
// begin if not i in hackTanks then
110517: LD_VAR 0 1
110521: PUSH
110522: LD_EXP 185
110526: IN
110527: NOT
110528: IFFALSE 110611
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
110530: LD_ADDR_EXP 185
110534: PUSH
110535: LD_EXP 185
110539: PPUSH
110540: LD_EXP 185
110544: PUSH
110545: LD_INT 1
110547: PLUS
110548: PPUSH
110549: LD_VAR 0 1
110553: PPUSH
110554: CALL_OW 1
110558: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
110559: LD_ADDR_EXP 186
110563: PUSH
110564: LD_EXP 186
110568: PPUSH
110569: LD_EXP 186
110573: PUSH
110574: LD_INT 1
110576: PLUS
110577: PPUSH
110578: EMPTY
110579: PPUSH
110580: CALL_OW 1
110584: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
110585: LD_ADDR_EXP 189
110589: PUSH
110590: LD_EXP 189
110594: PPUSH
110595: LD_EXP 189
110599: PUSH
110600: LD_INT 1
110602: PLUS
110603: PPUSH
110604: EMPTY
110605: PPUSH
110606: CALL_OW 1
110610: ST_TO_ADDR
// end ; if not IsOk ( i ) then
110611: LD_VAR 0 1
110615: PPUSH
110616: CALL_OW 302
110620: NOT
110621: IFFALSE 110634
// begin HackUnlinkAll ( i ) ;
110623: LD_VAR 0 1
110627: PPUSH
110628: CALL 110740 0 1
// continue ;
110632: GO 110514
// end ; HackCheckCapturedStatus ( i ) ;
110634: LD_VAR 0 1
110638: PPUSH
110639: CALL 111183 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
110643: LD_ADDR_VAR 0 2
110647: PUSH
110648: LD_INT 81
110650: PUSH
110651: LD_VAR 0 1
110655: PPUSH
110656: CALL_OW 255
110660: PUSH
110661: EMPTY
110662: LIST
110663: LIST
110664: PUSH
110665: LD_INT 33
110667: PUSH
110668: LD_INT 3
110670: PUSH
110671: EMPTY
110672: LIST
110673: LIST
110674: PUSH
110675: LD_INT 91
110677: PUSH
110678: LD_VAR 0 1
110682: PUSH
110683: LD_EXP 188
110687: PUSH
110688: EMPTY
110689: LIST
110690: LIST
110691: LIST
110692: PUSH
110693: LD_INT 50
110695: PUSH
110696: EMPTY
110697: LIST
110698: PUSH
110699: EMPTY
110700: LIST
110701: LIST
110702: LIST
110703: LIST
110704: PPUSH
110705: CALL_OW 69
110709: ST_TO_ADDR
// if not tmp then
110710: LD_VAR 0 2
110714: NOT
110715: IFFALSE 110719
// continue ;
110717: GO 110514
// HackLink ( i , tmp ) ;
110719: LD_VAR 0 1
110723: PPUSH
110724: LD_VAR 0 2
110728: PPUSH
110729: CALL 110876 0 2
// end ;
110733: GO 110514
110735: POP
110736: POP
// end ;
110737: PPOPN 2
110739: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
110740: LD_INT 0
110742: PPUSH
110743: PPUSH
110744: PPUSH
// if not hack in hackTanks then
110745: LD_VAR 0 1
110749: PUSH
110750: LD_EXP 185
110754: IN
110755: NOT
110756: IFFALSE 110760
// exit ;
110758: GO 110871
// index := GetElementIndex ( hackTanks , hack ) ;
110760: LD_ADDR_VAR 0 4
110764: PUSH
110765: LD_EXP 185
110769: PPUSH
110770: LD_VAR 0 1
110774: PPUSH
110775: CALL 56984 0 2
110779: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
110780: LD_EXP 186
110784: PUSH
110785: LD_VAR 0 4
110789: ARRAY
110790: IFFALSE 110871
// begin for i in hackTanksCaptured [ index ] do
110792: LD_ADDR_VAR 0 3
110796: PUSH
110797: LD_EXP 186
110801: PUSH
110802: LD_VAR 0 4
110806: ARRAY
110807: PUSH
110808: FOR_IN
110809: IFFALSE 110835
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
110811: LD_VAR 0 3
110815: PUSH
110816: LD_INT 1
110818: ARRAY
110819: PPUSH
110820: LD_VAR 0 3
110824: PUSH
110825: LD_INT 2
110827: ARRAY
110828: PPUSH
110829: CALL_OW 235
110833: GO 110808
110835: POP
110836: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
110837: LD_ADDR_EXP 186
110841: PUSH
110842: LD_EXP 186
110846: PPUSH
110847: LD_VAR 0 4
110851: PPUSH
110852: EMPTY
110853: PPUSH
110854: CALL_OW 1
110858: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
110859: LD_VAR 0 1
110863: PPUSH
110864: LD_INT 0
110866: PPUSH
110867: CALL_OW 505
// end ; end ;
110871: LD_VAR 0 2
110875: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
110876: LD_INT 0
110878: PPUSH
110879: PPUSH
110880: PPUSH
// if not hack in hackTanks or not vehicles then
110881: LD_VAR 0 1
110885: PUSH
110886: LD_EXP 185
110890: IN
110891: NOT
110892: PUSH
110893: LD_VAR 0 2
110897: NOT
110898: OR
110899: IFFALSE 110903
// exit ;
110901: GO 111178
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
110903: LD_ADDR_VAR 0 2
110907: PUSH
110908: LD_VAR 0 1
110912: PPUSH
110913: LD_VAR 0 2
110917: PPUSH
110918: LD_INT 1
110920: PPUSH
110921: LD_INT 1
110923: PPUSH
110924: CALL 57634 0 4
110928: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
110929: LD_ADDR_VAR 0 5
110933: PUSH
110934: LD_EXP 185
110938: PPUSH
110939: LD_VAR 0 1
110943: PPUSH
110944: CALL 56984 0 2
110948: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
110949: LD_EXP 186
110953: PUSH
110954: LD_VAR 0 5
110958: ARRAY
110959: PUSH
110960: LD_EXP 187
110964: LESS
110965: IFFALSE 111154
// begin for i := 1 to vehicles do
110967: LD_ADDR_VAR 0 4
110971: PUSH
110972: DOUBLE
110973: LD_INT 1
110975: DEC
110976: ST_TO_ADDR
110977: LD_VAR 0 2
110981: PUSH
110982: FOR_TO
110983: IFFALSE 111152
// begin if hackTanksCaptured [ index ] = hackLimit then
110985: LD_EXP 186
110989: PUSH
110990: LD_VAR 0 5
110994: ARRAY
110995: PUSH
110996: LD_EXP 187
111000: EQUAL
111001: IFFALSE 111005
// break ;
111003: GO 111152
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
111005: LD_ADDR_EXP 189
111009: PUSH
111010: LD_EXP 189
111014: PPUSH
111015: LD_VAR 0 5
111019: PPUSH
111020: LD_EXP 189
111024: PUSH
111025: LD_VAR 0 5
111029: ARRAY
111030: PUSH
111031: LD_INT 1
111033: PLUS
111034: PPUSH
111035: CALL_OW 1
111039: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
111040: LD_ADDR_EXP 186
111044: PUSH
111045: LD_EXP 186
111049: PPUSH
111050: LD_VAR 0 5
111054: PUSH
111055: LD_EXP 186
111059: PUSH
111060: LD_VAR 0 5
111064: ARRAY
111065: PUSH
111066: LD_INT 1
111068: PLUS
111069: PUSH
111070: EMPTY
111071: LIST
111072: LIST
111073: PPUSH
111074: LD_VAR 0 2
111078: PUSH
111079: LD_VAR 0 4
111083: ARRAY
111084: PUSH
111085: LD_VAR 0 2
111089: PUSH
111090: LD_VAR 0 4
111094: ARRAY
111095: PPUSH
111096: CALL_OW 255
111100: PUSH
111101: EMPTY
111102: LIST
111103: LIST
111104: PPUSH
111105: CALL 57199 0 3
111109: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
111110: LD_VAR 0 2
111114: PUSH
111115: LD_VAR 0 4
111119: ARRAY
111120: PPUSH
111121: LD_VAR 0 1
111125: PPUSH
111126: CALL_OW 255
111130: PPUSH
111131: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
111135: LD_VAR 0 2
111139: PUSH
111140: LD_VAR 0 4
111144: ARRAY
111145: PPUSH
111146: CALL_OW 141
// end ;
111150: GO 110982
111152: POP
111153: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
111154: LD_VAR 0 1
111158: PPUSH
111159: LD_EXP 186
111163: PUSH
111164: LD_VAR 0 5
111168: ARRAY
111169: PUSH
111170: LD_INT 0
111172: PLUS
111173: PPUSH
111174: CALL_OW 505
// end ;
111178: LD_VAR 0 3
111182: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
111183: LD_INT 0
111185: PPUSH
111186: PPUSH
111187: PPUSH
111188: PPUSH
// if not hack in hackTanks then
111189: LD_VAR 0 1
111193: PUSH
111194: LD_EXP 185
111198: IN
111199: NOT
111200: IFFALSE 111204
// exit ;
111202: GO 111444
// index := GetElementIndex ( hackTanks , hack ) ;
111204: LD_ADDR_VAR 0 4
111208: PUSH
111209: LD_EXP 185
111213: PPUSH
111214: LD_VAR 0 1
111218: PPUSH
111219: CALL 56984 0 2
111223: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
111224: LD_ADDR_VAR 0 3
111228: PUSH
111229: DOUBLE
111230: LD_EXP 186
111234: PUSH
111235: LD_VAR 0 4
111239: ARRAY
111240: INC
111241: ST_TO_ADDR
111242: LD_INT 1
111244: PUSH
111245: FOR_DOWNTO
111246: IFFALSE 111418
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
111248: LD_ADDR_VAR 0 5
111252: PUSH
111253: LD_EXP 186
111257: PUSH
111258: LD_VAR 0 4
111262: ARRAY
111263: PUSH
111264: LD_VAR 0 3
111268: ARRAY
111269: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
111270: LD_VAR 0 5
111274: PUSH
111275: LD_INT 1
111277: ARRAY
111278: PPUSH
111279: CALL_OW 302
111283: NOT
111284: PUSH
111285: LD_VAR 0 5
111289: PUSH
111290: LD_INT 1
111292: ARRAY
111293: PPUSH
111294: CALL_OW 255
111298: PUSH
111299: LD_VAR 0 1
111303: PPUSH
111304: CALL_OW 255
111308: NONEQUAL
111309: OR
111310: IFFALSE 111416
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
111312: LD_VAR 0 5
111316: PUSH
111317: LD_INT 1
111319: ARRAY
111320: PPUSH
111321: CALL_OW 305
111325: PUSH
111326: LD_VAR 0 5
111330: PUSH
111331: LD_INT 1
111333: ARRAY
111334: PPUSH
111335: CALL_OW 255
111339: PUSH
111340: LD_VAR 0 1
111344: PPUSH
111345: CALL_OW 255
111349: EQUAL
111350: AND
111351: IFFALSE 111375
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
111353: LD_VAR 0 5
111357: PUSH
111358: LD_INT 1
111360: ARRAY
111361: PPUSH
111362: LD_VAR 0 5
111366: PUSH
111367: LD_INT 2
111369: ARRAY
111370: PPUSH
111371: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
111375: LD_ADDR_EXP 186
111379: PUSH
111380: LD_EXP 186
111384: PPUSH
111385: LD_VAR 0 4
111389: PPUSH
111390: LD_EXP 186
111394: PUSH
111395: LD_VAR 0 4
111399: ARRAY
111400: PPUSH
111401: LD_VAR 0 3
111405: PPUSH
111406: CALL_OW 3
111410: PPUSH
111411: CALL_OW 1
111415: ST_TO_ADDR
// end ; end ;
111416: GO 111245
111418: POP
111419: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
111420: LD_VAR 0 1
111424: PPUSH
111425: LD_EXP 186
111429: PUSH
111430: LD_VAR 0 4
111434: ARRAY
111435: PUSH
111436: LD_INT 0
111438: PLUS
111439: PPUSH
111440: CALL_OW 505
// end ;
111444: LD_VAR 0 2
111448: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
111449: LD_INT 0
111451: PPUSH
111452: PPUSH
111453: PPUSH
111454: PPUSH
// if not hack in hackTanks then
111455: LD_VAR 0 1
111459: PUSH
111460: LD_EXP 185
111464: IN
111465: NOT
111466: IFFALSE 111470
// exit ;
111468: GO 111555
// index := GetElementIndex ( hackTanks , hack ) ;
111470: LD_ADDR_VAR 0 5
111474: PUSH
111475: LD_EXP 185
111479: PPUSH
111480: LD_VAR 0 1
111484: PPUSH
111485: CALL 56984 0 2
111489: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
111490: LD_ADDR_VAR 0 4
111494: PUSH
111495: DOUBLE
111496: LD_INT 1
111498: DEC
111499: ST_TO_ADDR
111500: LD_EXP 186
111504: PUSH
111505: LD_VAR 0 5
111509: ARRAY
111510: PUSH
111511: FOR_TO
111512: IFFALSE 111553
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
111514: LD_EXP 186
111518: PUSH
111519: LD_VAR 0 5
111523: ARRAY
111524: PUSH
111525: LD_VAR 0 4
111529: ARRAY
111530: PUSH
111531: LD_INT 1
111533: ARRAY
111534: PUSH
111535: LD_VAR 0 2
111539: EQUAL
111540: IFFALSE 111551
// KillUnit ( vehicle ) ;
111542: LD_VAR 0 2
111546: PPUSH
111547: CALL_OW 66
111551: GO 111511
111553: POP
111554: POP
// end ;
111555: LD_VAR 0 3
111559: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
111560: LD_EXP 190
111564: NOT
111565: IFFALSE 111600
111567: GO 111569
111569: DISABLE
// begin initMiner := true ;
111570: LD_ADDR_EXP 190
111574: PUSH
111575: LD_INT 1
111577: ST_TO_ADDR
// minersList := [ ] ;
111578: LD_ADDR_EXP 191
111582: PUSH
111583: EMPTY
111584: ST_TO_ADDR
// minerMinesList := [ ] ;
111585: LD_ADDR_EXP 192
111589: PUSH
111590: EMPTY
111591: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
111592: LD_ADDR_EXP 193
111596: PUSH
111597: LD_INT 5
111599: ST_TO_ADDR
// end ;
111600: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
111601: LD_EXP 190
111605: PUSH
111606: LD_INT 34
111608: PUSH
111609: LD_INT 81
111611: PUSH
111612: EMPTY
111613: LIST
111614: LIST
111615: PPUSH
111616: CALL_OW 69
111620: AND
111621: IFFALSE 112082
111623: GO 111625
111625: DISABLE
111626: LD_INT 0
111628: PPUSH
111629: PPUSH
111630: PPUSH
111631: PPUSH
// begin enable ;
111632: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
111633: LD_ADDR_VAR 0 1
111637: PUSH
111638: LD_INT 34
111640: PUSH
111641: LD_INT 81
111643: PUSH
111644: EMPTY
111645: LIST
111646: LIST
111647: PPUSH
111648: CALL_OW 69
111652: PUSH
111653: FOR_IN
111654: IFFALSE 111726
// begin if not i in minersList then
111656: LD_VAR 0 1
111660: PUSH
111661: LD_EXP 191
111665: IN
111666: NOT
111667: IFFALSE 111724
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
111669: LD_ADDR_EXP 191
111673: PUSH
111674: LD_EXP 191
111678: PPUSH
111679: LD_EXP 191
111683: PUSH
111684: LD_INT 1
111686: PLUS
111687: PPUSH
111688: LD_VAR 0 1
111692: PPUSH
111693: CALL_OW 1
111697: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
111698: LD_ADDR_EXP 192
111702: PUSH
111703: LD_EXP 192
111707: PPUSH
111708: LD_EXP 192
111712: PUSH
111713: LD_INT 1
111715: PLUS
111716: PPUSH
111717: EMPTY
111718: PPUSH
111719: CALL_OW 1
111723: ST_TO_ADDR
// end end ;
111724: GO 111653
111726: POP
111727: POP
// for i := minerMinesList downto 1 do
111728: LD_ADDR_VAR 0 1
111732: PUSH
111733: DOUBLE
111734: LD_EXP 192
111738: INC
111739: ST_TO_ADDR
111740: LD_INT 1
111742: PUSH
111743: FOR_DOWNTO
111744: IFFALSE 112080
// begin if IsLive ( minersList [ i ] ) then
111746: LD_EXP 191
111750: PUSH
111751: LD_VAR 0 1
111755: ARRAY
111756: PPUSH
111757: CALL_OW 300
111761: IFFALSE 111789
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
111763: LD_EXP 191
111767: PUSH
111768: LD_VAR 0 1
111772: ARRAY
111773: PPUSH
111774: LD_EXP 192
111778: PUSH
111779: LD_VAR 0 1
111783: ARRAY
111784: PPUSH
111785: CALL_OW 505
// if not minerMinesList [ i ] then
111789: LD_EXP 192
111793: PUSH
111794: LD_VAR 0 1
111798: ARRAY
111799: NOT
111800: IFFALSE 111804
// continue ;
111802: GO 111743
// for j := minerMinesList [ i ] downto 1 do
111804: LD_ADDR_VAR 0 2
111808: PUSH
111809: DOUBLE
111810: LD_EXP 192
111814: PUSH
111815: LD_VAR 0 1
111819: ARRAY
111820: INC
111821: ST_TO_ADDR
111822: LD_INT 1
111824: PUSH
111825: FOR_DOWNTO
111826: IFFALSE 112076
// begin side := GetSide ( minersList [ i ] ) ;
111828: LD_ADDR_VAR 0 3
111832: PUSH
111833: LD_EXP 191
111837: PUSH
111838: LD_VAR 0 1
111842: ARRAY
111843: PPUSH
111844: CALL_OW 255
111848: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
111849: LD_ADDR_VAR 0 4
111853: PUSH
111854: LD_EXP 192
111858: PUSH
111859: LD_VAR 0 1
111863: ARRAY
111864: PUSH
111865: LD_VAR 0 2
111869: ARRAY
111870: PUSH
111871: LD_INT 1
111873: ARRAY
111874: PPUSH
111875: LD_EXP 192
111879: PUSH
111880: LD_VAR 0 1
111884: ARRAY
111885: PUSH
111886: LD_VAR 0 2
111890: ARRAY
111891: PUSH
111892: LD_INT 2
111894: ARRAY
111895: PPUSH
111896: CALL_OW 428
111900: ST_TO_ADDR
// if not tmp then
111901: LD_VAR 0 4
111905: NOT
111906: IFFALSE 111910
// continue ;
111908: GO 111825
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
111910: LD_VAR 0 4
111914: PUSH
111915: LD_INT 81
111917: PUSH
111918: LD_VAR 0 3
111922: PUSH
111923: EMPTY
111924: LIST
111925: LIST
111926: PPUSH
111927: CALL_OW 69
111931: IN
111932: PUSH
111933: LD_EXP 192
111937: PUSH
111938: LD_VAR 0 1
111942: ARRAY
111943: PUSH
111944: LD_VAR 0 2
111948: ARRAY
111949: PUSH
111950: LD_INT 1
111952: ARRAY
111953: PPUSH
111954: LD_EXP 192
111958: PUSH
111959: LD_VAR 0 1
111963: ARRAY
111964: PUSH
111965: LD_VAR 0 2
111969: ARRAY
111970: PUSH
111971: LD_INT 2
111973: ARRAY
111974: PPUSH
111975: CALL_OW 458
111979: AND
111980: IFFALSE 112074
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
111982: LD_EXP 192
111986: PUSH
111987: LD_VAR 0 1
111991: ARRAY
111992: PUSH
111993: LD_VAR 0 2
111997: ARRAY
111998: PUSH
111999: LD_INT 1
112001: ARRAY
112002: PPUSH
112003: LD_EXP 192
112007: PUSH
112008: LD_VAR 0 1
112012: ARRAY
112013: PUSH
112014: LD_VAR 0 2
112018: ARRAY
112019: PUSH
112020: LD_INT 2
112022: ARRAY
112023: PPUSH
112024: LD_VAR 0 3
112028: PPUSH
112029: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
112033: LD_ADDR_EXP 192
112037: PUSH
112038: LD_EXP 192
112042: PPUSH
112043: LD_VAR 0 1
112047: PPUSH
112048: LD_EXP 192
112052: PUSH
112053: LD_VAR 0 1
112057: ARRAY
112058: PPUSH
112059: LD_VAR 0 2
112063: PPUSH
112064: CALL_OW 3
112068: PPUSH
112069: CALL_OW 1
112073: ST_TO_ADDR
// end ; end ;
112074: GO 111825
112076: POP
112077: POP
// end ;
112078: GO 111743
112080: POP
112081: POP
// end ;
112082: PPOPN 4
112084: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
112085: LD_INT 0
112087: PPUSH
112088: PPUSH
// result := false ;
112089: LD_ADDR_VAR 0 4
112093: PUSH
112094: LD_INT 0
112096: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
112097: LD_VAR 0 1
112101: PPUSH
112102: CALL_OW 264
112106: PUSH
112107: LD_INT 81
112109: EQUAL
112110: NOT
112111: IFFALSE 112115
// exit ;
112113: GO 112355
// index := GetElementIndex ( minersList , unit ) ;
112115: LD_ADDR_VAR 0 5
112119: PUSH
112120: LD_EXP 191
112124: PPUSH
112125: LD_VAR 0 1
112129: PPUSH
112130: CALL 56984 0 2
112134: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
112135: LD_EXP 192
112139: PUSH
112140: LD_VAR 0 5
112144: ARRAY
112145: PUSH
112146: LD_EXP 193
112150: GREATEREQUAL
112151: IFFALSE 112155
// exit ;
112153: GO 112355
// ComMoveXY ( unit , x , y ) ;
112155: LD_VAR 0 1
112159: PPUSH
112160: LD_VAR 0 2
112164: PPUSH
112165: LD_VAR 0 3
112169: PPUSH
112170: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
112174: LD_INT 35
112176: PPUSH
112177: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
112181: LD_VAR 0 1
112185: PPUSH
112186: LD_VAR 0 2
112190: PPUSH
112191: LD_VAR 0 3
112195: PPUSH
112196: CALL 88339 0 3
112200: NOT
112201: PUSH
112202: LD_VAR 0 1
112206: PPUSH
112207: CALL_OW 314
112211: AND
112212: IFFALSE 112216
// exit ;
112214: GO 112355
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
112216: LD_VAR 0 2
112220: PPUSH
112221: LD_VAR 0 3
112225: PPUSH
112226: CALL_OW 428
112230: PUSH
112231: LD_VAR 0 1
112235: EQUAL
112236: PUSH
112237: LD_VAR 0 1
112241: PPUSH
112242: CALL_OW 314
112246: NOT
112247: AND
112248: IFFALSE 112174
// PlaySoundXY ( x , y , PlantMine ) ;
112250: LD_VAR 0 2
112254: PPUSH
112255: LD_VAR 0 3
112259: PPUSH
112260: LD_STRING PlantMine
112262: PPUSH
112263: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
112267: LD_VAR 0 2
112271: PPUSH
112272: LD_VAR 0 3
112276: PPUSH
112277: LD_VAR 0 1
112281: PPUSH
112282: CALL_OW 255
112286: PPUSH
112287: LD_INT 0
112289: PPUSH
112290: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
112294: LD_ADDR_EXP 192
112298: PUSH
112299: LD_EXP 192
112303: PPUSH
112304: LD_VAR 0 5
112308: PUSH
112309: LD_EXP 192
112313: PUSH
112314: LD_VAR 0 5
112318: ARRAY
112319: PUSH
112320: LD_INT 1
112322: PLUS
112323: PUSH
112324: EMPTY
112325: LIST
112326: LIST
112327: PPUSH
112328: LD_VAR 0 2
112332: PUSH
112333: LD_VAR 0 3
112337: PUSH
112338: EMPTY
112339: LIST
112340: LIST
112341: PPUSH
112342: CALL 57199 0 3
112346: ST_TO_ADDR
// result := true ;
112347: LD_ADDR_VAR 0 4
112351: PUSH
112352: LD_INT 1
112354: ST_TO_ADDR
// end ;
112355: LD_VAR 0 4
112359: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
112360: LD_INT 0
112362: PPUSH
112363: PPUSH
112364: PPUSH
// if not unit in minersList then
112365: LD_VAR 0 1
112369: PUSH
112370: LD_EXP 191
112374: IN
112375: NOT
112376: IFFALSE 112380
// exit ;
112378: GO 112772
// index := GetElementIndex ( minersList , unit ) ;
112380: LD_ADDR_VAR 0 6
112384: PUSH
112385: LD_EXP 191
112389: PPUSH
112390: LD_VAR 0 1
112394: PPUSH
112395: CALL 56984 0 2
112399: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
112400: LD_ADDR_VAR 0 5
112404: PUSH
112405: DOUBLE
112406: LD_EXP 192
112410: PUSH
112411: LD_VAR 0 6
112415: ARRAY
112416: INC
112417: ST_TO_ADDR
112418: LD_INT 1
112420: PUSH
112421: FOR_DOWNTO
112422: IFFALSE 112583
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
112424: LD_EXP 192
112428: PUSH
112429: LD_VAR 0 6
112433: ARRAY
112434: PUSH
112435: LD_VAR 0 5
112439: ARRAY
112440: PUSH
112441: LD_INT 1
112443: ARRAY
112444: PUSH
112445: LD_VAR 0 2
112449: EQUAL
112450: PUSH
112451: LD_EXP 192
112455: PUSH
112456: LD_VAR 0 6
112460: ARRAY
112461: PUSH
112462: LD_VAR 0 5
112466: ARRAY
112467: PUSH
112468: LD_INT 2
112470: ARRAY
112471: PUSH
112472: LD_VAR 0 3
112476: EQUAL
112477: AND
112478: IFFALSE 112581
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
112480: LD_EXP 192
112484: PUSH
112485: LD_VAR 0 6
112489: ARRAY
112490: PUSH
112491: LD_VAR 0 5
112495: ARRAY
112496: PUSH
112497: LD_INT 1
112499: ARRAY
112500: PPUSH
112501: LD_EXP 192
112505: PUSH
112506: LD_VAR 0 6
112510: ARRAY
112511: PUSH
112512: LD_VAR 0 5
112516: ARRAY
112517: PUSH
112518: LD_INT 2
112520: ARRAY
112521: PPUSH
112522: LD_VAR 0 1
112526: PPUSH
112527: CALL_OW 255
112531: PPUSH
112532: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
112536: LD_ADDR_EXP 192
112540: PUSH
112541: LD_EXP 192
112545: PPUSH
112546: LD_VAR 0 6
112550: PPUSH
112551: LD_EXP 192
112555: PUSH
112556: LD_VAR 0 6
112560: ARRAY
112561: PPUSH
112562: LD_VAR 0 5
112566: PPUSH
112567: CALL_OW 3
112571: PPUSH
112572: CALL_OW 1
112576: ST_TO_ADDR
// exit ;
112577: POP
112578: POP
112579: GO 112772
// end ; end ;
112581: GO 112421
112583: POP
112584: POP
// for i := minerMinesList [ index ] downto 1 do
112585: LD_ADDR_VAR 0 5
112589: PUSH
112590: DOUBLE
112591: LD_EXP 192
112595: PUSH
112596: LD_VAR 0 6
112600: ARRAY
112601: INC
112602: ST_TO_ADDR
112603: LD_INT 1
112605: PUSH
112606: FOR_DOWNTO
112607: IFFALSE 112770
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
112609: LD_EXP 192
112613: PUSH
112614: LD_VAR 0 6
112618: ARRAY
112619: PUSH
112620: LD_VAR 0 5
112624: ARRAY
112625: PUSH
112626: LD_INT 1
112628: ARRAY
112629: PPUSH
112630: LD_EXP 192
112634: PUSH
112635: LD_VAR 0 6
112639: ARRAY
112640: PUSH
112641: LD_VAR 0 5
112645: ARRAY
112646: PUSH
112647: LD_INT 2
112649: ARRAY
112650: PPUSH
112651: LD_VAR 0 2
112655: PPUSH
112656: LD_VAR 0 3
112660: PPUSH
112661: CALL_OW 298
112665: PUSH
112666: LD_INT 6
112668: LESS
112669: IFFALSE 112768
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
112671: LD_EXP 192
112675: PUSH
112676: LD_VAR 0 6
112680: ARRAY
112681: PUSH
112682: LD_VAR 0 5
112686: ARRAY
112687: PUSH
112688: LD_INT 1
112690: ARRAY
112691: PPUSH
112692: LD_EXP 192
112696: PUSH
112697: LD_VAR 0 6
112701: ARRAY
112702: PUSH
112703: LD_VAR 0 5
112707: ARRAY
112708: PUSH
112709: LD_INT 2
112711: ARRAY
112712: PPUSH
112713: LD_VAR 0 1
112717: PPUSH
112718: CALL_OW 255
112722: PPUSH
112723: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
112727: LD_ADDR_EXP 192
112731: PUSH
112732: LD_EXP 192
112736: PPUSH
112737: LD_VAR 0 6
112741: PPUSH
112742: LD_EXP 192
112746: PUSH
112747: LD_VAR 0 6
112751: ARRAY
112752: PPUSH
112753: LD_VAR 0 5
112757: PPUSH
112758: CALL_OW 3
112762: PPUSH
112763: CALL_OW 1
112767: ST_TO_ADDR
// end ; end ;
112768: GO 112606
112770: POP
112771: POP
// end ;
112772: LD_VAR 0 4
112776: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
112777: LD_INT 0
112779: PPUSH
112780: PPUSH
112781: PPUSH
112782: PPUSH
112783: PPUSH
112784: PPUSH
112785: PPUSH
112786: PPUSH
112787: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
112788: LD_VAR 0 1
112792: PPUSH
112793: CALL_OW 264
112797: PUSH
112798: LD_INT 81
112800: EQUAL
112801: NOT
112802: PUSH
112803: LD_VAR 0 1
112807: PUSH
112808: LD_EXP 191
112812: IN
112813: NOT
112814: OR
112815: IFFALSE 112819
// exit ;
112817: GO 113141
// index := GetElementIndex ( minersList , unit ) ;
112819: LD_ADDR_VAR 0 6
112823: PUSH
112824: LD_EXP 191
112828: PPUSH
112829: LD_VAR 0 1
112833: PPUSH
112834: CALL 56984 0 2
112838: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
112839: LD_ADDR_VAR 0 8
112843: PUSH
112844: LD_EXP 193
112848: PUSH
112849: LD_EXP 192
112853: PUSH
112854: LD_VAR 0 6
112858: ARRAY
112859: MINUS
112860: ST_TO_ADDR
// if not minesFreeAmount then
112861: LD_VAR 0 8
112865: NOT
112866: IFFALSE 112870
// exit ;
112868: GO 113141
// tmp := [ ] ;
112870: LD_ADDR_VAR 0 7
112874: PUSH
112875: EMPTY
112876: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
112877: LD_ADDR_VAR 0 5
112881: PUSH
112882: DOUBLE
112883: LD_INT 1
112885: DEC
112886: ST_TO_ADDR
112887: LD_VAR 0 8
112891: PUSH
112892: FOR_TO
112893: IFFALSE 113088
// begin _d := rand ( 0 , 5 ) ;
112895: LD_ADDR_VAR 0 11
112899: PUSH
112900: LD_INT 0
112902: PPUSH
112903: LD_INT 5
112905: PPUSH
112906: CALL_OW 12
112910: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
112911: LD_ADDR_VAR 0 12
112915: PUSH
112916: LD_INT 2
112918: PPUSH
112919: LD_INT 6
112921: PPUSH
112922: CALL_OW 12
112926: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
112927: LD_ADDR_VAR 0 9
112931: PUSH
112932: LD_VAR 0 2
112936: PPUSH
112937: LD_VAR 0 11
112941: PPUSH
112942: LD_VAR 0 12
112946: PPUSH
112947: CALL_OW 272
112951: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
112952: LD_ADDR_VAR 0 10
112956: PUSH
112957: LD_VAR 0 3
112961: PPUSH
112962: LD_VAR 0 11
112966: PPUSH
112967: LD_VAR 0 12
112971: PPUSH
112972: CALL_OW 273
112976: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
112977: LD_VAR 0 9
112981: PPUSH
112982: LD_VAR 0 10
112986: PPUSH
112987: CALL_OW 488
112991: PUSH
112992: LD_VAR 0 9
112996: PUSH
112997: LD_VAR 0 10
113001: PUSH
113002: EMPTY
113003: LIST
113004: LIST
113005: PUSH
113006: LD_VAR 0 7
113010: IN
113011: NOT
113012: AND
113013: PUSH
113014: LD_VAR 0 9
113018: PPUSH
113019: LD_VAR 0 10
113023: PPUSH
113024: CALL_OW 458
113028: NOT
113029: AND
113030: IFFALSE 113072
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
113032: LD_ADDR_VAR 0 7
113036: PUSH
113037: LD_VAR 0 7
113041: PPUSH
113042: LD_VAR 0 7
113046: PUSH
113047: LD_INT 1
113049: PLUS
113050: PPUSH
113051: LD_VAR 0 9
113055: PUSH
113056: LD_VAR 0 10
113060: PUSH
113061: EMPTY
113062: LIST
113063: LIST
113064: PPUSH
113065: CALL_OW 1
113069: ST_TO_ADDR
113070: GO 113086
// i := i - 1 ;
113072: LD_ADDR_VAR 0 5
113076: PUSH
113077: LD_VAR 0 5
113081: PUSH
113082: LD_INT 1
113084: MINUS
113085: ST_TO_ADDR
// end ;
113086: GO 112892
113088: POP
113089: POP
// for i in tmp do
113090: LD_ADDR_VAR 0 5
113094: PUSH
113095: LD_VAR 0 7
113099: PUSH
113100: FOR_IN
113101: IFFALSE 113139
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
113103: LD_VAR 0 1
113107: PPUSH
113108: LD_VAR 0 5
113112: PUSH
113113: LD_INT 1
113115: ARRAY
113116: PPUSH
113117: LD_VAR 0 5
113121: PUSH
113122: LD_INT 2
113124: ARRAY
113125: PPUSH
113126: CALL 112085 0 3
113130: NOT
113131: IFFALSE 113137
// exit ;
113133: POP
113134: POP
113135: GO 113141
113137: GO 113100
113139: POP
113140: POP
// end ;
113141: LD_VAR 0 4
113145: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
113146: LD_INT 0
113148: PPUSH
113149: PPUSH
113150: PPUSH
113151: PPUSH
113152: PPUSH
113153: PPUSH
113154: PPUSH
// if not GetClass ( unit ) = class_sniper then
113155: LD_VAR 0 1
113159: PPUSH
113160: CALL_OW 257
113164: PUSH
113165: LD_INT 5
113167: EQUAL
113168: NOT
113169: IFFALSE 113173
// exit ;
113171: GO 113561
// dist := 8 ;
113173: LD_ADDR_VAR 0 5
113177: PUSH
113178: LD_INT 8
113180: ST_TO_ADDR
// viewRange := 12 ;
113181: LD_ADDR_VAR 0 7
113185: PUSH
113186: LD_INT 12
113188: ST_TO_ADDR
// side := GetSide ( unit ) ;
113189: LD_ADDR_VAR 0 6
113193: PUSH
113194: LD_VAR 0 1
113198: PPUSH
113199: CALL_OW 255
113203: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
113204: LD_INT 61
113206: PPUSH
113207: LD_VAR 0 6
113211: PPUSH
113212: CALL_OW 321
113216: PUSH
113217: LD_INT 2
113219: EQUAL
113220: IFFALSE 113230
// viewRange := 16 ;
113222: LD_ADDR_VAR 0 7
113226: PUSH
113227: LD_INT 16
113229: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
113230: LD_VAR 0 1
113234: PPUSH
113235: LD_VAR 0 2
113239: PPUSH
113240: LD_VAR 0 3
113244: PPUSH
113245: CALL_OW 297
113249: PUSH
113250: LD_VAR 0 5
113254: GREATER
113255: IFFALSE 113334
// begin ComMoveXY ( unit , x , y ) ;
113257: LD_VAR 0 1
113261: PPUSH
113262: LD_VAR 0 2
113266: PPUSH
113267: LD_VAR 0 3
113271: PPUSH
113272: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
113276: LD_INT 35
113278: PPUSH
113279: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
113283: LD_VAR 0 1
113287: PPUSH
113288: LD_VAR 0 2
113292: PPUSH
113293: LD_VAR 0 3
113297: PPUSH
113298: CALL 88339 0 3
113302: NOT
113303: IFFALSE 113307
// exit ;
113305: GO 113561
// until GetDistUnitXY ( unit , x , y ) < dist ;
113307: LD_VAR 0 1
113311: PPUSH
113312: LD_VAR 0 2
113316: PPUSH
113317: LD_VAR 0 3
113321: PPUSH
113322: CALL_OW 297
113326: PUSH
113327: LD_VAR 0 5
113331: LESS
113332: IFFALSE 113276
// end ; ComTurnXY ( unit , x , y ) ;
113334: LD_VAR 0 1
113338: PPUSH
113339: LD_VAR 0 2
113343: PPUSH
113344: LD_VAR 0 3
113348: PPUSH
113349: CALL_OW 118
// wait ( 5 ) ;
113353: LD_INT 5
113355: PPUSH
113356: CALL_OW 67
// _d := GetDir ( unit ) ;
113360: LD_ADDR_VAR 0 10
113364: PUSH
113365: LD_VAR 0 1
113369: PPUSH
113370: CALL_OW 254
113374: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
113375: LD_ADDR_VAR 0 8
113379: PUSH
113380: LD_VAR 0 1
113384: PPUSH
113385: CALL_OW 250
113389: PPUSH
113390: LD_VAR 0 10
113394: PPUSH
113395: LD_VAR 0 5
113399: PPUSH
113400: CALL_OW 272
113404: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
113405: LD_ADDR_VAR 0 9
113409: PUSH
113410: LD_VAR 0 1
113414: PPUSH
113415: CALL_OW 251
113419: PPUSH
113420: LD_VAR 0 10
113424: PPUSH
113425: LD_VAR 0 5
113429: PPUSH
113430: CALL_OW 273
113434: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
113435: LD_VAR 0 8
113439: PPUSH
113440: LD_VAR 0 9
113444: PPUSH
113445: CALL_OW 488
113449: NOT
113450: IFFALSE 113454
// exit ;
113452: GO 113561
// ComAnimCustom ( unit , 1 ) ;
113454: LD_VAR 0 1
113458: PPUSH
113459: LD_INT 1
113461: PPUSH
113462: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
113466: LD_VAR 0 8
113470: PPUSH
113471: LD_VAR 0 9
113475: PPUSH
113476: LD_VAR 0 6
113480: PPUSH
113481: LD_VAR 0 7
113485: PPUSH
113486: CALL_OW 330
// repeat wait ( 1 ) ;
113490: LD_INT 1
113492: PPUSH
113493: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
113497: LD_VAR 0 1
113501: PPUSH
113502: CALL_OW 316
113506: PUSH
113507: LD_VAR 0 1
113511: PPUSH
113512: CALL_OW 314
113516: OR
113517: PUSH
113518: LD_VAR 0 1
113522: PPUSH
113523: CALL_OW 302
113527: NOT
113528: OR
113529: PUSH
113530: LD_VAR 0 1
113534: PPUSH
113535: CALL_OW 301
113539: OR
113540: IFFALSE 113490
// RemoveSeeing ( _x , _y , side ) ;
113542: LD_VAR 0 8
113546: PPUSH
113547: LD_VAR 0 9
113551: PPUSH
113552: LD_VAR 0 6
113556: PPUSH
113557: CALL_OW 331
// end ; end_of_file
113561: LD_VAR 0 4
113565: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
113566: LD_INT 0
113568: PPUSH
113569: PPUSH
113570: PPUSH
113571: PPUSH
113572: PPUSH
113573: PPUSH
113574: PPUSH
113575: PPUSH
113576: PPUSH
113577: PPUSH
113578: PPUSH
113579: PPUSH
113580: PPUSH
113581: PPUSH
113582: PPUSH
113583: PPUSH
113584: PPUSH
113585: PPUSH
113586: PPUSH
113587: PPUSH
113588: PPUSH
113589: PPUSH
113590: PPUSH
113591: PPUSH
113592: PPUSH
113593: PPUSH
113594: PPUSH
113595: PPUSH
113596: PPUSH
113597: PPUSH
113598: PPUSH
113599: PPUSH
113600: PPUSH
113601: PPUSH
// if not list then
113602: LD_VAR 0 1
113606: NOT
113607: IFFALSE 113611
// exit ;
113609: GO 118270
// base := list [ 1 ] ;
113611: LD_ADDR_VAR 0 3
113615: PUSH
113616: LD_VAR 0 1
113620: PUSH
113621: LD_INT 1
113623: ARRAY
113624: ST_TO_ADDR
// group := list [ 2 ] ;
113625: LD_ADDR_VAR 0 4
113629: PUSH
113630: LD_VAR 0 1
113634: PUSH
113635: LD_INT 2
113637: ARRAY
113638: ST_TO_ADDR
// path := list [ 3 ] ;
113639: LD_ADDR_VAR 0 5
113643: PUSH
113644: LD_VAR 0 1
113648: PUSH
113649: LD_INT 3
113651: ARRAY
113652: ST_TO_ADDR
// flags := list [ 4 ] ;
113653: LD_ADDR_VAR 0 6
113657: PUSH
113658: LD_VAR 0 1
113662: PUSH
113663: LD_INT 4
113665: ARRAY
113666: ST_TO_ADDR
// mined := [ ] ;
113667: LD_ADDR_VAR 0 27
113671: PUSH
113672: EMPTY
113673: ST_TO_ADDR
// bombed := [ ] ;
113674: LD_ADDR_VAR 0 28
113678: PUSH
113679: EMPTY
113680: ST_TO_ADDR
// healers := [ ] ;
113681: LD_ADDR_VAR 0 31
113685: PUSH
113686: EMPTY
113687: ST_TO_ADDR
// to_heal := [ ] ;
113688: LD_ADDR_VAR 0 30
113692: PUSH
113693: EMPTY
113694: ST_TO_ADDR
// repairs := [ ] ;
113695: LD_ADDR_VAR 0 33
113699: PUSH
113700: EMPTY
113701: ST_TO_ADDR
// to_repair := [ ] ;
113702: LD_ADDR_VAR 0 32
113706: PUSH
113707: EMPTY
113708: ST_TO_ADDR
// if not group or not path then
113709: LD_VAR 0 4
113713: NOT
113714: PUSH
113715: LD_VAR 0 5
113719: NOT
113720: OR
113721: IFFALSE 113725
// exit ;
113723: GO 118270
// side := GetSide ( group [ 1 ] ) ;
113725: LD_ADDR_VAR 0 35
113729: PUSH
113730: LD_VAR 0 4
113734: PUSH
113735: LD_INT 1
113737: ARRAY
113738: PPUSH
113739: CALL_OW 255
113743: ST_TO_ADDR
// if flags then
113744: LD_VAR 0 6
113748: IFFALSE 113892
// begin f_ignore_area := flags [ 1 ] ;
113750: LD_ADDR_VAR 0 17
113754: PUSH
113755: LD_VAR 0 6
113759: PUSH
113760: LD_INT 1
113762: ARRAY
113763: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
113764: LD_ADDR_VAR 0 18
113768: PUSH
113769: LD_VAR 0 6
113773: PUSH
113774: LD_INT 2
113776: ARRAY
113777: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
113778: LD_ADDR_VAR 0 19
113782: PUSH
113783: LD_VAR 0 6
113787: PUSH
113788: LD_INT 3
113790: ARRAY
113791: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
113792: LD_ADDR_VAR 0 20
113796: PUSH
113797: LD_VAR 0 6
113801: PUSH
113802: LD_INT 4
113804: ARRAY
113805: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
113806: LD_ADDR_VAR 0 21
113810: PUSH
113811: LD_VAR 0 6
113815: PUSH
113816: LD_INT 5
113818: ARRAY
113819: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
113820: LD_ADDR_VAR 0 22
113824: PUSH
113825: LD_VAR 0 6
113829: PUSH
113830: LD_INT 6
113832: ARRAY
113833: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
113834: LD_ADDR_VAR 0 23
113838: PUSH
113839: LD_VAR 0 6
113843: PUSH
113844: LD_INT 7
113846: ARRAY
113847: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
113848: LD_ADDR_VAR 0 24
113852: PUSH
113853: LD_VAR 0 6
113857: PUSH
113858: LD_INT 8
113860: ARRAY
113861: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
113862: LD_ADDR_VAR 0 25
113866: PUSH
113867: LD_VAR 0 6
113871: PUSH
113872: LD_INT 9
113874: ARRAY
113875: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
113876: LD_ADDR_VAR 0 26
113880: PUSH
113881: LD_VAR 0 6
113885: PUSH
113886: LD_INT 10
113888: ARRAY
113889: ST_TO_ADDR
// end else
113890: GO 113972
// begin f_ignore_area := false ;
113892: LD_ADDR_VAR 0 17
113896: PUSH
113897: LD_INT 0
113899: ST_TO_ADDR
// f_capture := false ;
113900: LD_ADDR_VAR 0 18
113904: PUSH
113905: LD_INT 0
113907: ST_TO_ADDR
// f_ignore_civ := false ;
113908: LD_ADDR_VAR 0 19
113912: PUSH
113913: LD_INT 0
113915: ST_TO_ADDR
// f_murder := false ;
113916: LD_ADDR_VAR 0 20
113920: PUSH
113921: LD_INT 0
113923: ST_TO_ADDR
// f_mines := false ;
113924: LD_ADDR_VAR 0 21
113928: PUSH
113929: LD_INT 0
113931: ST_TO_ADDR
// f_repair := false ;
113932: LD_ADDR_VAR 0 22
113936: PUSH
113937: LD_INT 0
113939: ST_TO_ADDR
// f_heal := false ;
113940: LD_ADDR_VAR 0 23
113944: PUSH
113945: LD_INT 0
113947: ST_TO_ADDR
// f_spacetime := false ;
113948: LD_ADDR_VAR 0 24
113952: PUSH
113953: LD_INT 0
113955: ST_TO_ADDR
// f_attack_depot := false ;
113956: LD_ADDR_VAR 0 25
113960: PUSH
113961: LD_INT 0
113963: ST_TO_ADDR
// f_crawl := false ;
113964: LD_ADDR_VAR 0 26
113968: PUSH
113969: LD_INT 0
113971: ST_TO_ADDR
// end ; if f_heal then
113972: LD_VAR 0 23
113976: IFFALSE 114003
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
113978: LD_ADDR_VAR 0 31
113982: PUSH
113983: LD_VAR 0 4
113987: PPUSH
113988: LD_INT 25
113990: PUSH
113991: LD_INT 4
113993: PUSH
113994: EMPTY
113995: LIST
113996: LIST
113997: PPUSH
113998: CALL_OW 72
114002: ST_TO_ADDR
// if f_repair then
114003: LD_VAR 0 22
114007: IFFALSE 114034
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
114009: LD_ADDR_VAR 0 33
114013: PUSH
114014: LD_VAR 0 4
114018: PPUSH
114019: LD_INT 25
114021: PUSH
114022: LD_INT 3
114024: PUSH
114025: EMPTY
114026: LIST
114027: LIST
114028: PPUSH
114029: CALL_OW 72
114033: ST_TO_ADDR
// units_path := [ ] ;
114034: LD_ADDR_VAR 0 16
114038: PUSH
114039: EMPTY
114040: ST_TO_ADDR
// for i = 1 to group do
114041: LD_ADDR_VAR 0 7
114045: PUSH
114046: DOUBLE
114047: LD_INT 1
114049: DEC
114050: ST_TO_ADDR
114051: LD_VAR 0 4
114055: PUSH
114056: FOR_TO
114057: IFFALSE 114086
// units_path := Replace ( units_path , i , path ) ;
114059: LD_ADDR_VAR 0 16
114063: PUSH
114064: LD_VAR 0 16
114068: PPUSH
114069: LD_VAR 0 7
114073: PPUSH
114074: LD_VAR 0 5
114078: PPUSH
114079: CALL_OW 1
114083: ST_TO_ADDR
114084: GO 114056
114086: POP
114087: POP
// repeat for i = group downto 1 do
114088: LD_ADDR_VAR 0 7
114092: PUSH
114093: DOUBLE
114094: LD_VAR 0 4
114098: INC
114099: ST_TO_ADDR
114100: LD_INT 1
114102: PUSH
114103: FOR_DOWNTO
114104: IFFALSE 118226
// begin wait ( 5 ) ;
114106: LD_INT 5
114108: PPUSH
114109: CALL_OW 67
// tmp := [ ] ;
114113: LD_ADDR_VAR 0 14
114117: PUSH
114118: EMPTY
114119: ST_TO_ADDR
// attacking := false ;
114120: LD_ADDR_VAR 0 29
114124: PUSH
114125: LD_INT 0
114127: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
114128: LD_VAR 0 4
114132: PUSH
114133: LD_VAR 0 7
114137: ARRAY
114138: PPUSH
114139: CALL_OW 301
114143: PUSH
114144: LD_VAR 0 4
114148: PUSH
114149: LD_VAR 0 7
114153: ARRAY
114154: NOT
114155: OR
114156: IFFALSE 114265
// begin if GetType ( group [ i ] ) = unit_human then
114158: LD_VAR 0 4
114162: PUSH
114163: LD_VAR 0 7
114167: ARRAY
114168: PPUSH
114169: CALL_OW 247
114173: PUSH
114174: LD_INT 1
114176: EQUAL
114177: IFFALSE 114223
// begin to_heal := to_heal diff group [ i ] ;
114179: LD_ADDR_VAR 0 30
114183: PUSH
114184: LD_VAR 0 30
114188: PUSH
114189: LD_VAR 0 4
114193: PUSH
114194: LD_VAR 0 7
114198: ARRAY
114199: DIFF
114200: ST_TO_ADDR
// healers := healers diff group [ i ] ;
114201: LD_ADDR_VAR 0 31
114205: PUSH
114206: LD_VAR 0 31
114210: PUSH
114211: LD_VAR 0 4
114215: PUSH
114216: LD_VAR 0 7
114220: ARRAY
114221: DIFF
114222: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
114223: LD_ADDR_VAR 0 4
114227: PUSH
114228: LD_VAR 0 4
114232: PPUSH
114233: LD_VAR 0 7
114237: PPUSH
114238: CALL_OW 3
114242: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
114243: LD_ADDR_VAR 0 16
114247: PUSH
114248: LD_VAR 0 16
114252: PPUSH
114253: LD_VAR 0 7
114257: PPUSH
114258: CALL_OW 3
114262: ST_TO_ADDR
// continue ;
114263: GO 114103
// end ; if f_repair then
114265: LD_VAR 0 22
114269: IFFALSE 114758
// begin if GetType ( group [ i ] ) = unit_vehicle then
114271: LD_VAR 0 4
114275: PUSH
114276: LD_VAR 0 7
114280: ARRAY
114281: PPUSH
114282: CALL_OW 247
114286: PUSH
114287: LD_INT 2
114289: EQUAL
114290: IFFALSE 114480
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
114292: LD_VAR 0 4
114296: PUSH
114297: LD_VAR 0 7
114301: ARRAY
114302: PPUSH
114303: CALL_OW 256
114307: PUSH
114308: LD_INT 700
114310: LESS
114311: PUSH
114312: LD_VAR 0 4
114316: PUSH
114317: LD_VAR 0 7
114321: ARRAY
114322: PUSH
114323: LD_VAR 0 32
114327: IN
114328: NOT
114329: AND
114330: IFFALSE 114354
// to_repair := to_repair union group [ i ] ;
114332: LD_ADDR_VAR 0 32
114336: PUSH
114337: LD_VAR 0 32
114341: PUSH
114342: LD_VAR 0 4
114346: PUSH
114347: LD_VAR 0 7
114351: ARRAY
114352: UNION
114353: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
114354: LD_VAR 0 4
114358: PUSH
114359: LD_VAR 0 7
114363: ARRAY
114364: PPUSH
114365: CALL_OW 256
114369: PUSH
114370: LD_INT 1000
114372: EQUAL
114373: PUSH
114374: LD_VAR 0 4
114378: PUSH
114379: LD_VAR 0 7
114383: ARRAY
114384: PUSH
114385: LD_VAR 0 32
114389: IN
114390: AND
114391: IFFALSE 114415
// to_repair := to_repair diff group [ i ] ;
114393: LD_ADDR_VAR 0 32
114397: PUSH
114398: LD_VAR 0 32
114402: PUSH
114403: LD_VAR 0 4
114407: PUSH
114408: LD_VAR 0 7
114412: ARRAY
114413: DIFF
114414: ST_TO_ADDR
// if group [ i ] in to_repair then
114415: LD_VAR 0 4
114419: PUSH
114420: LD_VAR 0 7
114424: ARRAY
114425: PUSH
114426: LD_VAR 0 32
114430: IN
114431: IFFALSE 114478
// begin if not IsInArea ( group [ i ] , f_repair ) then
114433: LD_VAR 0 4
114437: PUSH
114438: LD_VAR 0 7
114442: ARRAY
114443: PPUSH
114444: LD_VAR 0 22
114448: PPUSH
114449: CALL_OW 308
114453: NOT
114454: IFFALSE 114476
// ComMoveToArea ( group [ i ] , f_repair ) ;
114456: LD_VAR 0 4
114460: PUSH
114461: LD_VAR 0 7
114465: ARRAY
114466: PPUSH
114467: LD_VAR 0 22
114471: PPUSH
114472: CALL_OW 113
// continue ;
114476: GO 114103
// end ; end else
114478: GO 114758
// if group [ i ] in repairs then
114480: LD_VAR 0 4
114484: PUSH
114485: LD_VAR 0 7
114489: ARRAY
114490: PUSH
114491: LD_VAR 0 33
114495: IN
114496: IFFALSE 114758
// begin if IsInUnit ( group [ i ] ) then
114498: LD_VAR 0 4
114502: PUSH
114503: LD_VAR 0 7
114507: ARRAY
114508: PPUSH
114509: CALL_OW 310
114513: IFFALSE 114581
// begin z := IsInUnit ( group [ i ] ) ;
114515: LD_ADDR_VAR 0 13
114519: PUSH
114520: LD_VAR 0 4
114524: PUSH
114525: LD_VAR 0 7
114529: ARRAY
114530: PPUSH
114531: CALL_OW 310
114535: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
114536: LD_VAR 0 13
114540: PUSH
114541: LD_VAR 0 32
114545: IN
114546: PUSH
114547: LD_VAR 0 13
114551: PPUSH
114552: LD_VAR 0 22
114556: PPUSH
114557: CALL_OW 308
114561: AND
114562: IFFALSE 114579
// ComExitVehicle ( group [ i ] ) ;
114564: LD_VAR 0 4
114568: PUSH
114569: LD_VAR 0 7
114573: ARRAY
114574: PPUSH
114575: CALL_OW 121
// end else
114579: GO 114758
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
114581: LD_ADDR_VAR 0 13
114585: PUSH
114586: LD_VAR 0 4
114590: PPUSH
114591: LD_INT 95
114593: PUSH
114594: LD_VAR 0 22
114598: PUSH
114599: EMPTY
114600: LIST
114601: LIST
114602: PUSH
114603: LD_INT 58
114605: PUSH
114606: EMPTY
114607: LIST
114608: PUSH
114609: EMPTY
114610: LIST
114611: LIST
114612: PPUSH
114613: CALL_OW 72
114617: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
114618: LD_VAR 0 4
114622: PUSH
114623: LD_VAR 0 7
114627: ARRAY
114628: PPUSH
114629: CALL_OW 314
114633: NOT
114634: IFFALSE 114756
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
114636: LD_ADDR_VAR 0 10
114640: PUSH
114641: LD_VAR 0 13
114645: PPUSH
114646: LD_VAR 0 4
114650: PUSH
114651: LD_VAR 0 7
114655: ARRAY
114656: PPUSH
114657: CALL_OW 74
114661: ST_TO_ADDR
// if not x then
114662: LD_VAR 0 10
114666: NOT
114667: IFFALSE 114671
// continue ;
114669: GO 114103
// if GetLives ( x ) < 1000 then
114671: LD_VAR 0 10
114675: PPUSH
114676: CALL_OW 256
114680: PUSH
114681: LD_INT 1000
114683: LESS
114684: IFFALSE 114708
// ComRepairVehicle ( group [ i ] , x ) else
114686: LD_VAR 0 4
114690: PUSH
114691: LD_VAR 0 7
114695: ARRAY
114696: PPUSH
114697: LD_VAR 0 10
114701: PPUSH
114702: CALL_OW 129
114706: GO 114756
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
114708: LD_VAR 0 23
114712: PUSH
114713: LD_VAR 0 4
114717: PUSH
114718: LD_VAR 0 7
114722: ARRAY
114723: PPUSH
114724: CALL_OW 256
114728: PUSH
114729: LD_INT 1000
114731: LESS
114732: AND
114733: NOT
114734: IFFALSE 114756
// ComEnterUnit ( group [ i ] , x ) ;
114736: LD_VAR 0 4
114740: PUSH
114741: LD_VAR 0 7
114745: ARRAY
114746: PPUSH
114747: LD_VAR 0 10
114751: PPUSH
114752: CALL_OW 120
// end ; continue ;
114756: GO 114103
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
114758: LD_VAR 0 23
114762: PUSH
114763: LD_VAR 0 4
114767: PUSH
114768: LD_VAR 0 7
114772: ARRAY
114773: PPUSH
114774: CALL_OW 247
114778: PUSH
114779: LD_INT 1
114781: EQUAL
114782: AND
114783: IFFALSE 115261
// begin if group [ i ] in healers then
114785: LD_VAR 0 4
114789: PUSH
114790: LD_VAR 0 7
114794: ARRAY
114795: PUSH
114796: LD_VAR 0 31
114800: IN
114801: IFFALSE 115074
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
114803: LD_VAR 0 4
114807: PUSH
114808: LD_VAR 0 7
114812: ARRAY
114813: PPUSH
114814: LD_VAR 0 23
114818: PPUSH
114819: CALL_OW 308
114823: NOT
114824: PUSH
114825: LD_VAR 0 4
114829: PUSH
114830: LD_VAR 0 7
114834: ARRAY
114835: PPUSH
114836: CALL_OW 314
114840: NOT
114841: AND
114842: IFFALSE 114866
// ComMoveToArea ( group [ i ] , f_heal ) else
114844: LD_VAR 0 4
114848: PUSH
114849: LD_VAR 0 7
114853: ARRAY
114854: PPUSH
114855: LD_VAR 0 23
114859: PPUSH
114860: CALL_OW 113
114864: GO 115072
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
114866: LD_VAR 0 4
114870: PUSH
114871: LD_VAR 0 7
114875: ARRAY
114876: PPUSH
114877: CALL 86922 0 1
114881: PPUSH
114882: CALL_OW 256
114886: PUSH
114887: LD_INT 1000
114889: EQUAL
114890: IFFALSE 114909
// ComStop ( group [ i ] ) else
114892: LD_VAR 0 4
114896: PUSH
114897: LD_VAR 0 7
114901: ARRAY
114902: PPUSH
114903: CALL_OW 141
114907: GO 115072
// if not HasTask ( group [ i ] ) and to_heal then
114909: LD_VAR 0 4
114913: PUSH
114914: LD_VAR 0 7
114918: ARRAY
114919: PPUSH
114920: CALL_OW 314
114924: NOT
114925: PUSH
114926: LD_VAR 0 30
114930: AND
114931: IFFALSE 115072
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
114933: LD_ADDR_VAR 0 13
114937: PUSH
114938: LD_VAR 0 30
114942: PPUSH
114943: LD_INT 3
114945: PUSH
114946: LD_INT 54
114948: PUSH
114949: EMPTY
114950: LIST
114951: PUSH
114952: EMPTY
114953: LIST
114954: LIST
114955: PPUSH
114956: CALL_OW 72
114960: PPUSH
114961: LD_VAR 0 4
114965: PUSH
114966: LD_VAR 0 7
114970: ARRAY
114971: PPUSH
114972: CALL_OW 74
114976: ST_TO_ADDR
// if z then
114977: LD_VAR 0 13
114981: IFFALSE 115072
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
114983: LD_INT 91
114985: PUSH
114986: LD_VAR 0 13
114990: PUSH
114991: LD_INT 10
114993: PUSH
114994: EMPTY
114995: LIST
114996: LIST
114997: LIST
114998: PUSH
114999: LD_INT 81
115001: PUSH
115002: LD_VAR 0 13
115006: PPUSH
115007: CALL_OW 255
115011: PUSH
115012: EMPTY
115013: LIST
115014: LIST
115015: PUSH
115016: EMPTY
115017: LIST
115018: LIST
115019: PPUSH
115020: CALL_OW 69
115024: PUSH
115025: LD_INT 0
115027: EQUAL
115028: IFFALSE 115052
// ComHeal ( group [ i ] , z ) else
115030: LD_VAR 0 4
115034: PUSH
115035: LD_VAR 0 7
115039: ARRAY
115040: PPUSH
115041: LD_VAR 0 13
115045: PPUSH
115046: CALL_OW 128
115050: GO 115072
// ComMoveToArea ( group [ i ] , f_heal ) ;
115052: LD_VAR 0 4
115056: PUSH
115057: LD_VAR 0 7
115061: ARRAY
115062: PPUSH
115063: LD_VAR 0 23
115067: PPUSH
115068: CALL_OW 113
// end ; continue ;
115072: GO 114103
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
115074: LD_VAR 0 4
115078: PUSH
115079: LD_VAR 0 7
115083: ARRAY
115084: PPUSH
115085: CALL_OW 256
115089: PUSH
115090: LD_INT 700
115092: LESS
115093: PUSH
115094: LD_VAR 0 4
115098: PUSH
115099: LD_VAR 0 7
115103: ARRAY
115104: PUSH
115105: LD_VAR 0 30
115109: IN
115110: NOT
115111: AND
115112: IFFALSE 115136
// to_heal := to_heal union group [ i ] ;
115114: LD_ADDR_VAR 0 30
115118: PUSH
115119: LD_VAR 0 30
115123: PUSH
115124: LD_VAR 0 4
115128: PUSH
115129: LD_VAR 0 7
115133: ARRAY
115134: UNION
115135: ST_TO_ADDR
// if group [ i ] in to_heal then
115136: LD_VAR 0 4
115140: PUSH
115141: LD_VAR 0 7
115145: ARRAY
115146: PUSH
115147: LD_VAR 0 30
115151: IN
115152: IFFALSE 115261
// begin if GetLives ( group [ i ] ) = 1000 then
115154: LD_VAR 0 4
115158: PUSH
115159: LD_VAR 0 7
115163: ARRAY
115164: PPUSH
115165: CALL_OW 256
115169: PUSH
115170: LD_INT 1000
115172: EQUAL
115173: IFFALSE 115199
// to_heal := to_heal diff group [ i ] else
115175: LD_ADDR_VAR 0 30
115179: PUSH
115180: LD_VAR 0 30
115184: PUSH
115185: LD_VAR 0 4
115189: PUSH
115190: LD_VAR 0 7
115194: ARRAY
115195: DIFF
115196: ST_TO_ADDR
115197: GO 115261
// begin if not IsInArea ( group [ i ] , to_heal ) then
115199: LD_VAR 0 4
115203: PUSH
115204: LD_VAR 0 7
115208: ARRAY
115209: PPUSH
115210: LD_VAR 0 30
115214: PPUSH
115215: CALL_OW 308
115219: NOT
115220: IFFALSE 115244
// ComMoveToArea ( group [ i ] , f_heal ) else
115222: LD_VAR 0 4
115226: PUSH
115227: LD_VAR 0 7
115231: ARRAY
115232: PPUSH
115233: LD_VAR 0 23
115237: PPUSH
115238: CALL_OW 113
115242: GO 115259
// ComHold ( group [ i ] ) ;
115244: LD_VAR 0 4
115248: PUSH
115249: LD_VAR 0 7
115253: ARRAY
115254: PPUSH
115255: CALL_OW 140
// continue ;
115259: GO 114103
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
115261: LD_VAR 0 4
115265: PUSH
115266: LD_VAR 0 7
115270: ARRAY
115271: PPUSH
115272: LD_INT 10
115274: PPUSH
115275: CALL 84693 0 2
115279: NOT
115280: PUSH
115281: LD_VAR 0 16
115285: PUSH
115286: LD_VAR 0 7
115290: ARRAY
115291: PUSH
115292: EMPTY
115293: EQUAL
115294: NOT
115295: AND
115296: IFFALSE 115562
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
115298: LD_VAR 0 4
115302: PUSH
115303: LD_VAR 0 7
115307: ARRAY
115308: PPUSH
115309: CALL_OW 262
115313: PUSH
115314: LD_INT 1
115316: PUSH
115317: LD_INT 2
115319: PUSH
115320: EMPTY
115321: LIST
115322: LIST
115323: IN
115324: IFFALSE 115365
// if GetFuel ( group [ i ] ) < 10 then
115326: LD_VAR 0 4
115330: PUSH
115331: LD_VAR 0 7
115335: ARRAY
115336: PPUSH
115337: CALL_OW 261
115341: PUSH
115342: LD_INT 10
115344: LESS
115345: IFFALSE 115365
// SetFuel ( group [ i ] , 12 ) ;
115347: LD_VAR 0 4
115351: PUSH
115352: LD_VAR 0 7
115356: ARRAY
115357: PPUSH
115358: LD_INT 12
115360: PPUSH
115361: CALL_OW 240
// if units_path [ i ] then
115365: LD_VAR 0 16
115369: PUSH
115370: LD_VAR 0 7
115374: ARRAY
115375: IFFALSE 115560
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
115377: LD_VAR 0 4
115381: PUSH
115382: LD_VAR 0 7
115386: ARRAY
115387: PPUSH
115388: LD_VAR 0 16
115392: PUSH
115393: LD_VAR 0 7
115397: ARRAY
115398: PUSH
115399: LD_INT 1
115401: ARRAY
115402: PUSH
115403: LD_INT 1
115405: ARRAY
115406: PPUSH
115407: LD_VAR 0 16
115411: PUSH
115412: LD_VAR 0 7
115416: ARRAY
115417: PUSH
115418: LD_INT 1
115420: ARRAY
115421: PUSH
115422: LD_INT 2
115424: ARRAY
115425: PPUSH
115426: CALL_OW 297
115430: PUSH
115431: LD_INT 6
115433: GREATER
115434: IFFALSE 115509
// begin if not HasTask ( group [ i ] ) then
115436: LD_VAR 0 4
115440: PUSH
115441: LD_VAR 0 7
115445: ARRAY
115446: PPUSH
115447: CALL_OW 314
115451: NOT
115452: IFFALSE 115507
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
115454: LD_VAR 0 4
115458: PUSH
115459: LD_VAR 0 7
115463: ARRAY
115464: PPUSH
115465: LD_VAR 0 16
115469: PUSH
115470: LD_VAR 0 7
115474: ARRAY
115475: PUSH
115476: LD_INT 1
115478: ARRAY
115479: PUSH
115480: LD_INT 1
115482: ARRAY
115483: PPUSH
115484: LD_VAR 0 16
115488: PUSH
115489: LD_VAR 0 7
115493: ARRAY
115494: PUSH
115495: LD_INT 1
115497: ARRAY
115498: PUSH
115499: LD_INT 2
115501: ARRAY
115502: PPUSH
115503: CALL_OW 114
// end else
115507: GO 115560
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
115509: LD_ADDR_VAR 0 15
115513: PUSH
115514: LD_VAR 0 16
115518: PUSH
115519: LD_VAR 0 7
115523: ARRAY
115524: PPUSH
115525: LD_INT 1
115527: PPUSH
115528: CALL_OW 3
115532: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
115533: LD_ADDR_VAR 0 16
115537: PUSH
115538: LD_VAR 0 16
115542: PPUSH
115543: LD_VAR 0 7
115547: PPUSH
115548: LD_VAR 0 15
115552: PPUSH
115553: CALL_OW 1
115557: ST_TO_ADDR
// continue ;
115558: GO 114103
// end ; end ; end else
115560: GO 118224
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
115562: LD_ADDR_VAR 0 14
115566: PUSH
115567: LD_INT 81
115569: PUSH
115570: LD_VAR 0 4
115574: PUSH
115575: LD_VAR 0 7
115579: ARRAY
115580: PPUSH
115581: CALL_OW 255
115585: PUSH
115586: EMPTY
115587: LIST
115588: LIST
115589: PPUSH
115590: CALL_OW 69
115594: ST_TO_ADDR
// if not tmp then
115595: LD_VAR 0 14
115599: NOT
115600: IFFALSE 115604
// continue ;
115602: GO 114103
// if f_ignore_area then
115604: LD_VAR 0 17
115608: IFFALSE 115696
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
115610: LD_ADDR_VAR 0 15
115614: PUSH
115615: LD_VAR 0 14
115619: PPUSH
115620: LD_INT 3
115622: PUSH
115623: LD_INT 92
115625: PUSH
115626: LD_VAR 0 17
115630: PUSH
115631: LD_INT 1
115633: ARRAY
115634: PUSH
115635: LD_VAR 0 17
115639: PUSH
115640: LD_INT 2
115642: ARRAY
115643: PUSH
115644: LD_VAR 0 17
115648: PUSH
115649: LD_INT 3
115651: ARRAY
115652: PUSH
115653: EMPTY
115654: LIST
115655: LIST
115656: LIST
115657: LIST
115658: PUSH
115659: EMPTY
115660: LIST
115661: LIST
115662: PPUSH
115663: CALL_OW 72
115667: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
115668: LD_VAR 0 14
115672: PUSH
115673: LD_VAR 0 15
115677: DIFF
115678: IFFALSE 115696
// tmp := tmp diff tmp2 ;
115680: LD_ADDR_VAR 0 14
115684: PUSH
115685: LD_VAR 0 14
115689: PUSH
115690: LD_VAR 0 15
115694: DIFF
115695: ST_TO_ADDR
// end ; if not f_murder then
115696: LD_VAR 0 20
115700: NOT
115701: IFFALSE 115759
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
115703: LD_ADDR_VAR 0 15
115707: PUSH
115708: LD_VAR 0 14
115712: PPUSH
115713: LD_INT 3
115715: PUSH
115716: LD_INT 50
115718: PUSH
115719: EMPTY
115720: LIST
115721: PUSH
115722: EMPTY
115723: LIST
115724: LIST
115725: PPUSH
115726: CALL_OW 72
115730: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
115731: LD_VAR 0 14
115735: PUSH
115736: LD_VAR 0 15
115740: DIFF
115741: IFFALSE 115759
// tmp := tmp diff tmp2 ;
115743: LD_ADDR_VAR 0 14
115747: PUSH
115748: LD_VAR 0 14
115752: PUSH
115753: LD_VAR 0 15
115757: DIFF
115758: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
115759: LD_ADDR_VAR 0 14
115763: PUSH
115764: LD_VAR 0 4
115768: PUSH
115769: LD_VAR 0 7
115773: ARRAY
115774: PPUSH
115775: LD_VAR 0 14
115779: PPUSH
115780: LD_INT 1
115782: PPUSH
115783: LD_INT 1
115785: PPUSH
115786: CALL 57634 0 4
115790: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
115791: LD_VAR 0 4
115795: PUSH
115796: LD_VAR 0 7
115800: ARRAY
115801: PPUSH
115802: CALL_OW 257
115806: PUSH
115807: LD_INT 1
115809: EQUAL
115810: IFFALSE 116258
// begin if WantPlant ( group [ i ] ) then
115812: LD_VAR 0 4
115816: PUSH
115817: LD_VAR 0 7
115821: ARRAY
115822: PPUSH
115823: CALL 57135 0 1
115827: IFFALSE 115831
// continue ;
115829: GO 114103
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
115831: LD_VAR 0 18
115835: PUSH
115836: LD_VAR 0 4
115840: PUSH
115841: LD_VAR 0 7
115845: ARRAY
115846: PPUSH
115847: CALL_OW 310
115851: NOT
115852: AND
115853: PUSH
115854: LD_VAR 0 14
115858: PUSH
115859: LD_INT 1
115861: ARRAY
115862: PUSH
115863: LD_VAR 0 14
115867: PPUSH
115868: LD_INT 21
115870: PUSH
115871: LD_INT 2
115873: PUSH
115874: EMPTY
115875: LIST
115876: LIST
115877: PUSH
115878: LD_INT 58
115880: PUSH
115881: EMPTY
115882: LIST
115883: PUSH
115884: EMPTY
115885: LIST
115886: LIST
115887: PPUSH
115888: CALL_OW 72
115892: IN
115893: AND
115894: IFFALSE 115930
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
115896: LD_VAR 0 4
115900: PUSH
115901: LD_VAR 0 7
115905: ARRAY
115906: PPUSH
115907: LD_VAR 0 14
115911: PUSH
115912: LD_INT 1
115914: ARRAY
115915: PPUSH
115916: CALL_OW 120
// attacking := true ;
115920: LD_ADDR_VAR 0 29
115924: PUSH
115925: LD_INT 1
115927: ST_TO_ADDR
// continue ;
115928: GO 114103
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
115930: LD_VAR 0 26
115934: PUSH
115935: LD_VAR 0 4
115939: PUSH
115940: LD_VAR 0 7
115944: ARRAY
115945: PPUSH
115946: CALL_OW 257
115950: PUSH
115951: LD_INT 1
115953: EQUAL
115954: AND
115955: PUSH
115956: LD_VAR 0 4
115960: PUSH
115961: LD_VAR 0 7
115965: ARRAY
115966: PPUSH
115967: CALL_OW 256
115971: PUSH
115972: LD_INT 800
115974: LESS
115975: AND
115976: PUSH
115977: LD_VAR 0 4
115981: PUSH
115982: LD_VAR 0 7
115986: ARRAY
115987: PPUSH
115988: CALL_OW 318
115992: NOT
115993: AND
115994: IFFALSE 116011
// ComCrawl ( group [ i ] ) ;
115996: LD_VAR 0 4
116000: PUSH
116001: LD_VAR 0 7
116005: ARRAY
116006: PPUSH
116007: CALL_OW 137
// if f_mines then
116011: LD_VAR 0 21
116015: IFFALSE 116258
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
116017: LD_VAR 0 14
116021: PUSH
116022: LD_INT 1
116024: ARRAY
116025: PPUSH
116026: CALL_OW 247
116030: PUSH
116031: LD_INT 3
116033: EQUAL
116034: PUSH
116035: LD_VAR 0 14
116039: PUSH
116040: LD_INT 1
116042: ARRAY
116043: PUSH
116044: LD_VAR 0 27
116048: IN
116049: NOT
116050: AND
116051: IFFALSE 116258
// begin x := GetX ( tmp [ 1 ] ) ;
116053: LD_ADDR_VAR 0 10
116057: PUSH
116058: LD_VAR 0 14
116062: PUSH
116063: LD_INT 1
116065: ARRAY
116066: PPUSH
116067: CALL_OW 250
116071: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
116072: LD_ADDR_VAR 0 11
116076: PUSH
116077: LD_VAR 0 14
116081: PUSH
116082: LD_INT 1
116084: ARRAY
116085: PPUSH
116086: CALL_OW 251
116090: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
116091: LD_ADDR_VAR 0 12
116095: PUSH
116096: LD_VAR 0 4
116100: PUSH
116101: LD_VAR 0 7
116105: ARRAY
116106: PPUSH
116107: CALL 84778 0 1
116111: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
116112: LD_VAR 0 4
116116: PUSH
116117: LD_VAR 0 7
116121: ARRAY
116122: PPUSH
116123: LD_VAR 0 10
116127: PPUSH
116128: LD_VAR 0 11
116132: PPUSH
116133: LD_VAR 0 14
116137: PUSH
116138: LD_INT 1
116140: ARRAY
116141: PPUSH
116142: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
116146: LD_VAR 0 4
116150: PUSH
116151: LD_VAR 0 7
116155: ARRAY
116156: PPUSH
116157: LD_VAR 0 10
116161: PPUSH
116162: LD_VAR 0 12
116166: PPUSH
116167: LD_INT 7
116169: PPUSH
116170: CALL_OW 272
116174: PPUSH
116175: LD_VAR 0 11
116179: PPUSH
116180: LD_VAR 0 12
116184: PPUSH
116185: LD_INT 7
116187: PPUSH
116188: CALL_OW 273
116192: PPUSH
116193: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
116197: LD_VAR 0 4
116201: PUSH
116202: LD_VAR 0 7
116206: ARRAY
116207: PPUSH
116208: LD_INT 71
116210: PPUSH
116211: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
116215: LD_ADDR_VAR 0 27
116219: PUSH
116220: LD_VAR 0 27
116224: PPUSH
116225: LD_VAR 0 27
116229: PUSH
116230: LD_INT 1
116232: PLUS
116233: PPUSH
116234: LD_VAR 0 14
116238: PUSH
116239: LD_INT 1
116241: ARRAY
116242: PPUSH
116243: CALL_OW 1
116247: ST_TO_ADDR
// attacking := true ;
116248: LD_ADDR_VAR 0 29
116252: PUSH
116253: LD_INT 1
116255: ST_TO_ADDR
// continue ;
116256: GO 114103
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
116258: LD_VAR 0 4
116262: PUSH
116263: LD_VAR 0 7
116267: ARRAY
116268: PPUSH
116269: CALL_OW 257
116273: PUSH
116274: LD_INT 17
116276: EQUAL
116277: PUSH
116278: LD_VAR 0 4
116282: PUSH
116283: LD_VAR 0 7
116287: ARRAY
116288: PPUSH
116289: CALL_OW 110
116293: PUSH
116294: LD_INT 71
116296: EQUAL
116297: NOT
116298: AND
116299: IFFALSE 116445
// begin attacking := false ;
116301: LD_ADDR_VAR 0 29
116305: PUSH
116306: LD_INT 0
116308: ST_TO_ADDR
// k := 5 ;
116309: LD_ADDR_VAR 0 9
116313: PUSH
116314: LD_INT 5
116316: ST_TO_ADDR
// if tmp < k then
116317: LD_VAR 0 14
116321: PUSH
116322: LD_VAR 0 9
116326: LESS
116327: IFFALSE 116339
// k := tmp ;
116329: LD_ADDR_VAR 0 9
116333: PUSH
116334: LD_VAR 0 14
116338: ST_TO_ADDR
// for j = 1 to k do
116339: LD_ADDR_VAR 0 8
116343: PUSH
116344: DOUBLE
116345: LD_INT 1
116347: DEC
116348: ST_TO_ADDR
116349: LD_VAR 0 9
116353: PUSH
116354: FOR_TO
116355: IFFALSE 116443
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
116357: LD_VAR 0 14
116361: PUSH
116362: LD_VAR 0 8
116366: ARRAY
116367: PUSH
116368: LD_VAR 0 14
116372: PPUSH
116373: LD_INT 58
116375: PUSH
116376: EMPTY
116377: LIST
116378: PPUSH
116379: CALL_OW 72
116383: IN
116384: NOT
116385: IFFALSE 116441
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
116387: LD_VAR 0 4
116391: PUSH
116392: LD_VAR 0 7
116396: ARRAY
116397: PPUSH
116398: LD_VAR 0 14
116402: PUSH
116403: LD_VAR 0 8
116407: ARRAY
116408: PPUSH
116409: CALL_OW 115
// attacking := true ;
116413: LD_ADDR_VAR 0 29
116417: PUSH
116418: LD_INT 1
116420: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
116421: LD_VAR 0 4
116425: PUSH
116426: LD_VAR 0 7
116430: ARRAY
116431: PPUSH
116432: LD_INT 71
116434: PPUSH
116435: CALL_OW 109
// continue ;
116439: GO 116354
// end ; end ;
116441: GO 116354
116443: POP
116444: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
116445: LD_VAR 0 4
116449: PUSH
116450: LD_VAR 0 7
116454: ARRAY
116455: PPUSH
116456: CALL_OW 257
116460: PUSH
116461: LD_INT 8
116463: EQUAL
116464: PUSH
116465: LD_VAR 0 4
116469: PUSH
116470: LD_VAR 0 7
116474: ARRAY
116475: PPUSH
116476: CALL_OW 264
116480: PUSH
116481: LD_INT 28
116483: PUSH
116484: LD_INT 45
116486: PUSH
116487: LD_INT 7
116489: PUSH
116490: LD_INT 47
116492: PUSH
116493: EMPTY
116494: LIST
116495: LIST
116496: LIST
116497: LIST
116498: IN
116499: OR
116500: IFFALSE 116756
// begin attacking := false ;
116502: LD_ADDR_VAR 0 29
116506: PUSH
116507: LD_INT 0
116509: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
116510: LD_VAR 0 14
116514: PUSH
116515: LD_INT 1
116517: ARRAY
116518: PPUSH
116519: CALL_OW 266
116523: PUSH
116524: LD_INT 32
116526: PUSH
116527: LD_INT 31
116529: PUSH
116530: LD_INT 33
116532: PUSH
116533: LD_INT 4
116535: PUSH
116536: LD_INT 5
116538: PUSH
116539: EMPTY
116540: LIST
116541: LIST
116542: LIST
116543: LIST
116544: LIST
116545: IN
116546: IFFALSE 116732
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
116548: LD_ADDR_VAR 0 9
116552: PUSH
116553: LD_VAR 0 14
116557: PUSH
116558: LD_INT 1
116560: ARRAY
116561: PPUSH
116562: CALL_OW 266
116566: PPUSH
116567: LD_VAR 0 14
116571: PUSH
116572: LD_INT 1
116574: ARRAY
116575: PPUSH
116576: CALL_OW 250
116580: PPUSH
116581: LD_VAR 0 14
116585: PUSH
116586: LD_INT 1
116588: ARRAY
116589: PPUSH
116590: CALL_OW 251
116594: PPUSH
116595: LD_VAR 0 14
116599: PUSH
116600: LD_INT 1
116602: ARRAY
116603: PPUSH
116604: CALL_OW 254
116608: PPUSH
116609: LD_VAR 0 14
116613: PUSH
116614: LD_INT 1
116616: ARRAY
116617: PPUSH
116618: CALL_OW 248
116622: PPUSH
116623: LD_INT 0
116625: PPUSH
116626: CALL 66148 0 6
116630: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
116631: LD_ADDR_VAR 0 8
116635: PUSH
116636: LD_VAR 0 4
116640: PUSH
116641: LD_VAR 0 7
116645: ARRAY
116646: PPUSH
116647: LD_VAR 0 9
116651: PPUSH
116652: CALL 84891 0 2
116656: ST_TO_ADDR
// if j then
116657: LD_VAR 0 8
116661: IFFALSE 116730
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
116663: LD_VAR 0 8
116667: PUSH
116668: LD_INT 1
116670: ARRAY
116671: PPUSH
116672: LD_VAR 0 8
116676: PUSH
116677: LD_INT 2
116679: ARRAY
116680: PPUSH
116681: CALL_OW 488
116685: IFFALSE 116730
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
116687: LD_VAR 0 4
116691: PUSH
116692: LD_VAR 0 7
116696: ARRAY
116697: PPUSH
116698: LD_VAR 0 8
116702: PUSH
116703: LD_INT 1
116705: ARRAY
116706: PPUSH
116707: LD_VAR 0 8
116711: PUSH
116712: LD_INT 2
116714: ARRAY
116715: PPUSH
116716: CALL_OW 116
// attacking := true ;
116720: LD_ADDR_VAR 0 29
116724: PUSH
116725: LD_INT 1
116727: ST_TO_ADDR
// continue ;
116728: GO 114103
// end ; end else
116730: GO 116756
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116732: LD_VAR 0 4
116736: PUSH
116737: LD_VAR 0 7
116741: ARRAY
116742: PPUSH
116743: LD_VAR 0 14
116747: PUSH
116748: LD_INT 1
116750: ARRAY
116751: PPUSH
116752: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
116756: LD_VAR 0 4
116760: PUSH
116761: LD_VAR 0 7
116765: ARRAY
116766: PPUSH
116767: CALL_OW 265
116771: PUSH
116772: LD_INT 11
116774: EQUAL
116775: IFFALSE 117053
// begin k := 10 ;
116777: LD_ADDR_VAR 0 9
116781: PUSH
116782: LD_INT 10
116784: ST_TO_ADDR
// x := 0 ;
116785: LD_ADDR_VAR 0 10
116789: PUSH
116790: LD_INT 0
116792: ST_TO_ADDR
// if tmp < k then
116793: LD_VAR 0 14
116797: PUSH
116798: LD_VAR 0 9
116802: LESS
116803: IFFALSE 116815
// k := tmp ;
116805: LD_ADDR_VAR 0 9
116809: PUSH
116810: LD_VAR 0 14
116814: ST_TO_ADDR
// for j = k downto 1 do
116815: LD_ADDR_VAR 0 8
116819: PUSH
116820: DOUBLE
116821: LD_VAR 0 9
116825: INC
116826: ST_TO_ADDR
116827: LD_INT 1
116829: PUSH
116830: FOR_DOWNTO
116831: IFFALSE 116906
// begin if GetType ( tmp [ j ] ) = unit_human then
116833: LD_VAR 0 14
116837: PUSH
116838: LD_VAR 0 8
116842: ARRAY
116843: PPUSH
116844: CALL_OW 247
116848: PUSH
116849: LD_INT 1
116851: EQUAL
116852: IFFALSE 116904
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
116854: LD_VAR 0 4
116858: PUSH
116859: LD_VAR 0 7
116863: ARRAY
116864: PPUSH
116865: LD_VAR 0 14
116869: PUSH
116870: LD_VAR 0 8
116874: ARRAY
116875: PPUSH
116876: CALL 85145 0 2
// x := tmp [ j ] ;
116880: LD_ADDR_VAR 0 10
116884: PUSH
116885: LD_VAR 0 14
116889: PUSH
116890: LD_VAR 0 8
116894: ARRAY
116895: ST_TO_ADDR
// attacking := true ;
116896: LD_ADDR_VAR 0 29
116900: PUSH
116901: LD_INT 1
116903: ST_TO_ADDR
// end ; end ;
116904: GO 116830
116906: POP
116907: POP
// if not x then
116908: LD_VAR 0 10
116912: NOT
116913: IFFALSE 117053
// begin attacking := true ;
116915: LD_ADDR_VAR 0 29
116919: PUSH
116920: LD_INT 1
116922: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
116923: LD_VAR 0 4
116927: PUSH
116928: LD_VAR 0 7
116932: ARRAY
116933: PPUSH
116934: CALL_OW 250
116938: PPUSH
116939: LD_VAR 0 4
116943: PUSH
116944: LD_VAR 0 7
116948: ARRAY
116949: PPUSH
116950: CALL_OW 251
116954: PPUSH
116955: CALL_OW 546
116959: PUSH
116960: LD_INT 2
116962: ARRAY
116963: PUSH
116964: LD_VAR 0 14
116968: PUSH
116969: LD_INT 1
116971: ARRAY
116972: PPUSH
116973: CALL_OW 250
116977: PPUSH
116978: LD_VAR 0 14
116982: PUSH
116983: LD_INT 1
116985: ARRAY
116986: PPUSH
116987: CALL_OW 251
116991: PPUSH
116992: CALL_OW 546
116996: PUSH
116997: LD_INT 2
116999: ARRAY
117000: EQUAL
117001: IFFALSE 117029
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
117003: LD_VAR 0 4
117007: PUSH
117008: LD_VAR 0 7
117012: ARRAY
117013: PPUSH
117014: LD_VAR 0 14
117018: PUSH
117019: LD_INT 1
117021: ARRAY
117022: PPUSH
117023: CALL 85145 0 2
117027: GO 117053
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
117029: LD_VAR 0 4
117033: PUSH
117034: LD_VAR 0 7
117038: ARRAY
117039: PPUSH
117040: LD_VAR 0 14
117044: PUSH
117045: LD_INT 1
117047: ARRAY
117048: PPUSH
117049: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
117053: LD_VAR 0 4
117057: PUSH
117058: LD_VAR 0 7
117062: ARRAY
117063: PPUSH
117064: CALL_OW 264
117068: PUSH
117069: LD_INT 29
117071: EQUAL
117072: IFFALSE 117438
// begin if WantsToAttack ( group [ i ] ) in bombed then
117074: LD_VAR 0 4
117078: PUSH
117079: LD_VAR 0 7
117083: ARRAY
117084: PPUSH
117085: CALL_OW 319
117089: PUSH
117090: LD_VAR 0 28
117094: IN
117095: IFFALSE 117099
// continue ;
117097: GO 114103
// k := 8 ;
117099: LD_ADDR_VAR 0 9
117103: PUSH
117104: LD_INT 8
117106: ST_TO_ADDR
// x := 0 ;
117107: LD_ADDR_VAR 0 10
117111: PUSH
117112: LD_INT 0
117114: ST_TO_ADDR
// if tmp < k then
117115: LD_VAR 0 14
117119: PUSH
117120: LD_VAR 0 9
117124: LESS
117125: IFFALSE 117137
// k := tmp ;
117127: LD_ADDR_VAR 0 9
117131: PUSH
117132: LD_VAR 0 14
117136: ST_TO_ADDR
// for j = 1 to k do
117137: LD_ADDR_VAR 0 8
117141: PUSH
117142: DOUBLE
117143: LD_INT 1
117145: DEC
117146: ST_TO_ADDR
117147: LD_VAR 0 9
117151: PUSH
117152: FOR_TO
117153: IFFALSE 117285
// begin if GetType ( tmp [ j ] ) = unit_building then
117155: LD_VAR 0 14
117159: PUSH
117160: LD_VAR 0 8
117164: ARRAY
117165: PPUSH
117166: CALL_OW 247
117170: PUSH
117171: LD_INT 3
117173: EQUAL
117174: IFFALSE 117283
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
117176: LD_VAR 0 14
117180: PUSH
117181: LD_VAR 0 8
117185: ARRAY
117186: PUSH
117187: LD_VAR 0 28
117191: IN
117192: NOT
117193: PUSH
117194: LD_VAR 0 14
117198: PUSH
117199: LD_VAR 0 8
117203: ARRAY
117204: PPUSH
117205: CALL_OW 313
117209: AND
117210: IFFALSE 117283
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
117212: LD_VAR 0 4
117216: PUSH
117217: LD_VAR 0 7
117221: ARRAY
117222: PPUSH
117223: LD_VAR 0 14
117227: PUSH
117228: LD_VAR 0 8
117232: ARRAY
117233: PPUSH
117234: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
117238: LD_ADDR_VAR 0 28
117242: PUSH
117243: LD_VAR 0 28
117247: PPUSH
117248: LD_VAR 0 28
117252: PUSH
117253: LD_INT 1
117255: PLUS
117256: PPUSH
117257: LD_VAR 0 14
117261: PUSH
117262: LD_VAR 0 8
117266: ARRAY
117267: PPUSH
117268: CALL_OW 1
117272: ST_TO_ADDR
// attacking := true ;
117273: LD_ADDR_VAR 0 29
117277: PUSH
117278: LD_INT 1
117280: ST_TO_ADDR
// break ;
117281: GO 117285
// end ; end ;
117283: GO 117152
117285: POP
117286: POP
// if not attacking and f_attack_depot then
117287: LD_VAR 0 29
117291: NOT
117292: PUSH
117293: LD_VAR 0 25
117297: AND
117298: IFFALSE 117393
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
117300: LD_ADDR_VAR 0 13
117304: PUSH
117305: LD_VAR 0 14
117309: PPUSH
117310: LD_INT 2
117312: PUSH
117313: LD_INT 30
117315: PUSH
117316: LD_INT 0
117318: PUSH
117319: EMPTY
117320: LIST
117321: LIST
117322: PUSH
117323: LD_INT 30
117325: PUSH
117326: LD_INT 1
117328: PUSH
117329: EMPTY
117330: LIST
117331: LIST
117332: PUSH
117333: EMPTY
117334: LIST
117335: LIST
117336: LIST
117337: PPUSH
117338: CALL_OW 72
117342: ST_TO_ADDR
// if z then
117343: LD_VAR 0 13
117347: IFFALSE 117393
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
117349: LD_VAR 0 4
117353: PUSH
117354: LD_VAR 0 7
117358: ARRAY
117359: PPUSH
117360: LD_VAR 0 13
117364: PPUSH
117365: LD_VAR 0 4
117369: PUSH
117370: LD_VAR 0 7
117374: ARRAY
117375: PPUSH
117376: CALL_OW 74
117380: PPUSH
117381: CALL_OW 115
// attacking := true ;
117385: LD_ADDR_VAR 0 29
117389: PUSH
117390: LD_INT 1
117392: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
117393: LD_VAR 0 4
117397: PUSH
117398: LD_VAR 0 7
117402: ARRAY
117403: PPUSH
117404: CALL_OW 256
117408: PUSH
117409: LD_INT 500
117411: LESS
117412: IFFALSE 117438
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
117414: LD_VAR 0 4
117418: PUSH
117419: LD_VAR 0 7
117423: ARRAY
117424: PPUSH
117425: LD_VAR 0 14
117429: PUSH
117430: LD_INT 1
117432: ARRAY
117433: PPUSH
117434: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
117438: LD_VAR 0 4
117442: PUSH
117443: LD_VAR 0 7
117447: ARRAY
117448: PPUSH
117449: CALL_OW 264
117453: PUSH
117454: LD_INT 49
117456: EQUAL
117457: IFFALSE 117578
// begin if not HasTask ( group [ i ] ) then
117459: LD_VAR 0 4
117463: PUSH
117464: LD_VAR 0 7
117468: ARRAY
117469: PPUSH
117470: CALL_OW 314
117474: NOT
117475: IFFALSE 117578
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
117477: LD_ADDR_VAR 0 9
117481: PUSH
117482: LD_INT 81
117484: PUSH
117485: LD_VAR 0 4
117489: PUSH
117490: LD_VAR 0 7
117494: ARRAY
117495: PPUSH
117496: CALL_OW 255
117500: PUSH
117501: EMPTY
117502: LIST
117503: LIST
117504: PPUSH
117505: CALL_OW 69
117509: PPUSH
117510: LD_VAR 0 4
117514: PUSH
117515: LD_VAR 0 7
117519: ARRAY
117520: PPUSH
117521: CALL_OW 74
117525: ST_TO_ADDR
// if k then
117526: LD_VAR 0 9
117530: IFFALSE 117578
// if GetDistUnits ( group [ i ] , k ) > 10 then
117532: LD_VAR 0 4
117536: PUSH
117537: LD_VAR 0 7
117541: ARRAY
117542: PPUSH
117543: LD_VAR 0 9
117547: PPUSH
117548: CALL_OW 296
117552: PUSH
117553: LD_INT 10
117555: GREATER
117556: IFFALSE 117578
// ComMoveUnit ( group [ i ] , k ) ;
117558: LD_VAR 0 4
117562: PUSH
117563: LD_VAR 0 7
117567: ARRAY
117568: PPUSH
117569: LD_VAR 0 9
117573: PPUSH
117574: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
117578: LD_VAR 0 4
117582: PUSH
117583: LD_VAR 0 7
117587: ARRAY
117588: PPUSH
117589: CALL_OW 256
117593: PUSH
117594: LD_INT 250
117596: LESS
117597: PUSH
117598: LD_VAR 0 4
117602: PUSH
117603: LD_VAR 0 7
117607: ARRAY
117608: PUSH
117609: LD_INT 21
117611: PUSH
117612: LD_INT 2
117614: PUSH
117615: EMPTY
117616: LIST
117617: LIST
117618: PUSH
117619: LD_INT 23
117621: PUSH
117622: LD_INT 2
117624: PUSH
117625: EMPTY
117626: LIST
117627: LIST
117628: PUSH
117629: EMPTY
117630: LIST
117631: LIST
117632: PPUSH
117633: CALL_OW 69
117637: IN
117638: AND
117639: IFFALSE 117764
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
117641: LD_ADDR_VAR 0 9
117645: PUSH
117646: LD_OWVAR 3
117650: PUSH
117651: LD_VAR 0 4
117655: PUSH
117656: LD_VAR 0 7
117660: ARRAY
117661: DIFF
117662: PPUSH
117663: LD_VAR 0 4
117667: PUSH
117668: LD_VAR 0 7
117672: ARRAY
117673: PPUSH
117674: CALL_OW 74
117678: ST_TO_ADDR
// if not k then
117679: LD_VAR 0 9
117683: NOT
117684: IFFALSE 117688
// continue ;
117686: GO 114103
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
117688: LD_VAR 0 9
117692: PUSH
117693: LD_INT 81
117695: PUSH
117696: LD_VAR 0 4
117700: PUSH
117701: LD_VAR 0 7
117705: ARRAY
117706: PPUSH
117707: CALL_OW 255
117711: PUSH
117712: EMPTY
117713: LIST
117714: LIST
117715: PPUSH
117716: CALL_OW 69
117720: IN
117721: PUSH
117722: LD_VAR 0 9
117726: PPUSH
117727: LD_VAR 0 4
117731: PUSH
117732: LD_VAR 0 7
117736: ARRAY
117737: PPUSH
117738: CALL_OW 296
117742: PUSH
117743: LD_INT 5
117745: LESS
117746: AND
117747: IFFALSE 117764
// ComAutodestruct ( group [ i ] ) ;
117749: LD_VAR 0 4
117753: PUSH
117754: LD_VAR 0 7
117758: ARRAY
117759: PPUSH
117760: CALL 85043 0 1
// end ; if f_attack_depot then
117764: LD_VAR 0 25
117768: IFFALSE 117880
// begin k := 6 ;
117770: LD_ADDR_VAR 0 9
117774: PUSH
117775: LD_INT 6
117777: ST_TO_ADDR
// if tmp < k then
117778: LD_VAR 0 14
117782: PUSH
117783: LD_VAR 0 9
117787: LESS
117788: IFFALSE 117800
// k := tmp ;
117790: LD_ADDR_VAR 0 9
117794: PUSH
117795: LD_VAR 0 14
117799: ST_TO_ADDR
// for j = 1 to k do
117800: LD_ADDR_VAR 0 8
117804: PUSH
117805: DOUBLE
117806: LD_INT 1
117808: DEC
117809: ST_TO_ADDR
117810: LD_VAR 0 9
117814: PUSH
117815: FOR_TO
117816: IFFALSE 117878
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
117818: LD_VAR 0 8
117822: PPUSH
117823: CALL_OW 266
117827: PUSH
117828: LD_INT 0
117830: PUSH
117831: LD_INT 1
117833: PUSH
117834: EMPTY
117835: LIST
117836: LIST
117837: IN
117838: IFFALSE 117876
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
117840: LD_VAR 0 4
117844: PUSH
117845: LD_VAR 0 7
117849: ARRAY
117850: PPUSH
117851: LD_VAR 0 14
117855: PUSH
117856: LD_VAR 0 8
117860: ARRAY
117861: PPUSH
117862: CALL_OW 115
// attacking := true ;
117866: LD_ADDR_VAR 0 29
117870: PUSH
117871: LD_INT 1
117873: ST_TO_ADDR
// break ;
117874: GO 117878
// end ;
117876: GO 117815
117878: POP
117879: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
117880: LD_VAR 0 4
117884: PUSH
117885: LD_VAR 0 7
117889: ARRAY
117890: PPUSH
117891: CALL_OW 302
117895: PUSH
117896: LD_VAR 0 29
117900: NOT
117901: AND
117902: IFFALSE 118224
// begin if GetTag ( group [ i ] ) = 71 then
117904: LD_VAR 0 4
117908: PUSH
117909: LD_VAR 0 7
117913: ARRAY
117914: PPUSH
117915: CALL_OW 110
117919: PUSH
117920: LD_INT 71
117922: EQUAL
117923: IFFALSE 117964
// begin if HasTask ( group [ i ] ) then
117925: LD_VAR 0 4
117929: PUSH
117930: LD_VAR 0 7
117934: ARRAY
117935: PPUSH
117936: CALL_OW 314
117940: IFFALSE 117946
// continue else
117942: GO 114103
117944: GO 117964
// SetTag ( group [ i ] , 0 ) ;
117946: LD_VAR 0 4
117950: PUSH
117951: LD_VAR 0 7
117955: ARRAY
117956: PPUSH
117957: LD_INT 0
117959: PPUSH
117960: CALL_OW 109
// end ; k := 8 ;
117964: LD_ADDR_VAR 0 9
117968: PUSH
117969: LD_INT 8
117971: ST_TO_ADDR
// x := 0 ;
117972: LD_ADDR_VAR 0 10
117976: PUSH
117977: LD_INT 0
117979: ST_TO_ADDR
// if tmp < k then
117980: LD_VAR 0 14
117984: PUSH
117985: LD_VAR 0 9
117989: LESS
117990: IFFALSE 118002
// k := tmp ;
117992: LD_ADDR_VAR 0 9
117996: PUSH
117997: LD_VAR 0 14
118001: ST_TO_ADDR
// for j = 1 to k do
118002: LD_ADDR_VAR 0 8
118006: PUSH
118007: DOUBLE
118008: LD_INT 1
118010: DEC
118011: ST_TO_ADDR
118012: LD_VAR 0 9
118016: PUSH
118017: FOR_TO
118018: IFFALSE 118116
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
118020: LD_VAR 0 14
118024: PUSH
118025: LD_VAR 0 8
118029: ARRAY
118030: PPUSH
118031: CALL_OW 247
118035: PUSH
118036: LD_INT 1
118038: EQUAL
118039: PUSH
118040: LD_VAR 0 14
118044: PUSH
118045: LD_VAR 0 8
118049: ARRAY
118050: PPUSH
118051: CALL_OW 256
118055: PUSH
118056: LD_INT 250
118058: LESS
118059: PUSH
118060: LD_VAR 0 20
118064: AND
118065: PUSH
118066: LD_VAR 0 20
118070: NOT
118071: PUSH
118072: LD_VAR 0 14
118076: PUSH
118077: LD_VAR 0 8
118081: ARRAY
118082: PPUSH
118083: CALL_OW 256
118087: PUSH
118088: LD_INT 250
118090: GREATEREQUAL
118091: AND
118092: OR
118093: AND
118094: IFFALSE 118114
// begin x := tmp [ j ] ;
118096: LD_ADDR_VAR 0 10
118100: PUSH
118101: LD_VAR 0 14
118105: PUSH
118106: LD_VAR 0 8
118110: ARRAY
118111: ST_TO_ADDR
// break ;
118112: GO 118116
// end ;
118114: GO 118017
118116: POP
118117: POP
// if x then
118118: LD_VAR 0 10
118122: IFFALSE 118146
// ComAttackUnit ( group [ i ] , x ) else
118124: LD_VAR 0 4
118128: PUSH
118129: LD_VAR 0 7
118133: ARRAY
118134: PPUSH
118135: LD_VAR 0 10
118139: PPUSH
118140: CALL_OW 115
118144: GO 118170
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
118146: LD_VAR 0 4
118150: PUSH
118151: LD_VAR 0 7
118155: ARRAY
118156: PPUSH
118157: LD_VAR 0 14
118161: PUSH
118162: LD_INT 1
118164: ARRAY
118165: PPUSH
118166: CALL_OW 115
// if not HasTask ( group [ i ] ) then
118170: LD_VAR 0 4
118174: PUSH
118175: LD_VAR 0 7
118179: ARRAY
118180: PPUSH
118181: CALL_OW 314
118185: NOT
118186: IFFALSE 118224
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
118188: LD_VAR 0 4
118192: PUSH
118193: LD_VAR 0 7
118197: ARRAY
118198: PPUSH
118199: LD_VAR 0 14
118203: PPUSH
118204: LD_VAR 0 4
118208: PUSH
118209: LD_VAR 0 7
118213: ARRAY
118214: PPUSH
118215: CALL_OW 74
118219: PPUSH
118220: CALL_OW 115
// end ; end ; end ;
118224: GO 114103
118226: POP
118227: POP
// wait ( 0 0$2 ) ;
118228: LD_INT 70
118230: PPUSH
118231: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
118235: LD_VAR 0 4
118239: NOT
118240: PUSH
118241: LD_VAR 0 4
118245: PUSH
118246: EMPTY
118247: EQUAL
118248: OR
118249: PUSH
118250: LD_INT 81
118252: PUSH
118253: LD_VAR 0 35
118257: PUSH
118258: EMPTY
118259: LIST
118260: LIST
118261: PPUSH
118262: CALL_OW 69
118266: NOT
118267: OR
118268: IFFALSE 114088
// end ;
118270: LD_VAR 0 2
118274: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
118275: LD_INT 0
118277: PPUSH
118278: PPUSH
118279: PPUSH
118280: PPUSH
118281: PPUSH
118282: PPUSH
// if not base or not mc_bases [ base ] or not solds then
118283: LD_VAR 0 1
118287: NOT
118288: PUSH
118289: LD_EXP 77
118293: PUSH
118294: LD_VAR 0 1
118298: ARRAY
118299: NOT
118300: OR
118301: PUSH
118302: LD_VAR 0 2
118306: NOT
118307: OR
118308: IFFALSE 118312
// exit ;
118310: GO 118866
// side := mc_sides [ base ] ;
118312: LD_ADDR_VAR 0 6
118316: PUSH
118317: LD_EXP 103
118321: PUSH
118322: LD_VAR 0 1
118326: ARRAY
118327: ST_TO_ADDR
// if not side then
118328: LD_VAR 0 6
118332: NOT
118333: IFFALSE 118337
// exit ;
118335: GO 118866
// for i in solds do
118337: LD_ADDR_VAR 0 7
118341: PUSH
118342: LD_VAR 0 2
118346: PUSH
118347: FOR_IN
118348: IFFALSE 118409
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
118350: LD_VAR 0 7
118354: PPUSH
118355: CALL_OW 310
118359: PPUSH
118360: CALL_OW 266
118364: PUSH
118365: LD_INT 32
118367: PUSH
118368: LD_INT 31
118370: PUSH
118371: EMPTY
118372: LIST
118373: LIST
118374: IN
118375: IFFALSE 118395
// solds := solds diff i else
118377: LD_ADDR_VAR 0 2
118381: PUSH
118382: LD_VAR 0 2
118386: PUSH
118387: LD_VAR 0 7
118391: DIFF
118392: ST_TO_ADDR
118393: GO 118407
// SetTag ( i , 18 ) ;
118395: LD_VAR 0 7
118399: PPUSH
118400: LD_INT 18
118402: PPUSH
118403: CALL_OW 109
118407: GO 118347
118409: POP
118410: POP
// if not solds then
118411: LD_VAR 0 2
118415: NOT
118416: IFFALSE 118420
// exit ;
118418: GO 118866
// repeat wait ( 0 0$2 ) ;
118420: LD_INT 70
118422: PPUSH
118423: CALL_OW 67
// enemy := mc_scan [ base ] ;
118427: LD_ADDR_VAR 0 4
118431: PUSH
118432: LD_EXP 100
118436: PUSH
118437: LD_VAR 0 1
118441: ARRAY
118442: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
118443: LD_EXP 77
118447: PUSH
118448: LD_VAR 0 1
118452: ARRAY
118453: NOT
118454: PUSH
118455: LD_EXP 77
118459: PUSH
118460: LD_VAR 0 1
118464: ARRAY
118465: PUSH
118466: EMPTY
118467: EQUAL
118468: OR
118469: IFFALSE 118506
// begin for i in solds do
118471: LD_ADDR_VAR 0 7
118475: PUSH
118476: LD_VAR 0 2
118480: PUSH
118481: FOR_IN
118482: IFFALSE 118495
// ComStop ( i ) ;
118484: LD_VAR 0 7
118488: PPUSH
118489: CALL_OW 141
118493: GO 118481
118495: POP
118496: POP
// solds := [ ] ;
118497: LD_ADDR_VAR 0 2
118501: PUSH
118502: EMPTY
118503: ST_TO_ADDR
// exit ;
118504: GO 118866
// end ; for i in solds do
118506: LD_ADDR_VAR 0 7
118510: PUSH
118511: LD_VAR 0 2
118515: PUSH
118516: FOR_IN
118517: IFFALSE 118838
// begin if IsInUnit ( i ) then
118519: LD_VAR 0 7
118523: PPUSH
118524: CALL_OW 310
118528: IFFALSE 118539
// ComExitBuilding ( i ) ;
118530: LD_VAR 0 7
118534: PPUSH
118535: CALL_OW 122
// if GetLives ( i ) > 500 then
118539: LD_VAR 0 7
118543: PPUSH
118544: CALL_OW 256
118548: PUSH
118549: LD_INT 500
118551: GREATER
118552: IFFALSE 118605
// begin e := NearestUnitToUnit ( enemy , i ) ;
118554: LD_ADDR_VAR 0 5
118558: PUSH
118559: LD_VAR 0 4
118563: PPUSH
118564: LD_VAR 0 7
118568: PPUSH
118569: CALL_OW 74
118573: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
118574: LD_VAR 0 7
118578: PPUSH
118579: LD_VAR 0 5
118583: PPUSH
118584: CALL_OW 250
118588: PPUSH
118589: LD_VAR 0 5
118593: PPUSH
118594: CALL_OW 251
118598: PPUSH
118599: CALL_OW 114
// end else
118603: GO 118836
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
118605: LD_VAR 0 7
118609: PPUSH
118610: LD_EXP 77
118614: PUSH
118615: LD_VAR 0 1
118619: ARRAY
118620: PPUSH
118621: LD_INT 2
118623: PUSH
118624: LD_INT 30
118626: PUSH
118627: LD_INT 0
118629: PUSH
118630: EMPTY
118631: LIST
118632: LIST
118633: PUSH
118634: LD_INT 30
118636: PUSH
118637: LD_INT 1
118639: PUSH
118640: EMPTY
118641: LIST
118642: LIST
118643: PUSH
118644: LD_INT 30
118646: PUSH
118647: LD_INT 6
118649: PUSH
118650: EMPTY
118651: LIST
118652: LIST
118653: PUSH
118654: EMPTY
118655: LIST
118656: LIST
118657: LIST
118658: LIST
118659: PPUSH
118660: CALL_OW 72
118664: PPUSH
118665: LD_VAR 0 7
118669: PPUSH
118670: CALL_OW 74
118674: PPUSH
118675: CALL_OW 296
118679: PUSH
118680: LD_INT 10
118682: GREATER
118683: IFFALSE 118836
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
118685: LD_ADDR_VAR 0 8
118689: PUSH
118690: LD_EXP 77
118694: PUSH
118695: LD_VAR 0 1
118699: ARRAY
118700: PPUSH
118701: LD_INT 2
118703: PUSH
118704: LD_INT 30
118706: PUSH
118707: LD_INT 0
118709: PUSH
118710: EMPTY
118711: LIST
118712: LIST
118713: PUSH
118714: LD_INT 30
118716: PUSH
118717: LD_INT 1
118719: PUSH
118720: EMPTY
118721: LIST
118722: LIST
118723: PUSH
118724: LD_INT 30
118726: PUSH
118727: LD_INT 6
118729: PUSH
118730: EMPTY
118731: LIST
118732: LIST
118733: PUSH
118734: EMPTY
118735: LIST
118736: LIST
118737: LIST
118738: LIST
118739: PPUSH
118740: CALL_OW 72
118744: PPUSH
118745: LD_VAR 0 7
118749: PPUSH
118750: CALL_OW 74
118754: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
118755: LD_VAR 0 7
118759: PPUSH
118760: LD_VAR 0 8
118764: PPUSH
118765: CALL_OW 250
118769: PPUSH
118770: LD_INT 3
118772: PPUSH
118773: LD_INT 5
118775: PPUSH
118776: CALL_OW 272
118780: PPUSH
118781: LD_VAR 0 8
118785: PPUSH
118786: CALL_OW 251
118790: PPUSH
118791: LD_INT 3
118793: PPUSH
118794: LD_INT 5
118796: PPUSH
118797: CALL_OW 273
118801: PPUSH
118802: CALL_OW 111
// SetTag ( i , 0 ) ;
118806: LD_VAR 0 7
118810: PPUSH
118811: LD_INT 0
118813: PPUSH
118814: CALL_OW 109
// solds := solds diff i ;
118818: LD_ADDR_VAR 0 2
118822: PUSH
118823: LD_VAR 0 2
118827: PUSH
118828: LD_VAR 0 7
118832: DIFF
118833: ST_TO_ADDR
// continue ;
118834: GO 118516
// end ; end ;
118836: GO 118516
118838: POP
118839: POP
// until not solds or not enemy ;
118840: LD_VAR 0 2
118844: NOT
118845: PUSH
118846: LD_VAR 0 4
118850: NOT
118851: OR
118852: IFFALSE 118420
// MC_Reset ( base , 18 ) ;
118854: LD_VAR 0 1
118858: PPUSH
118859: LD_INT 18
118861: PPUSH
118862: CALL 25521 0 2
// end ;
118866: LD_VAR 0 3
118870: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
118871: LD_INT 0
118873: PPUSH
118874: PPUSH
118875: PPUSH
118876: PPUSH
118877: PPUSH
118878: PPUSH
118879: PPUSH
118880: PPUSH
118881: PPUSH
118882: PPUSH
118883: PPUSH
118884: PPUSH
118885: PPUSH
118886: PPUSH
118887: PPUSH
118888: PPUSH
118889: PPUSH
118890: PPUSH
118891: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
118892: LD_ADDR_VAR 0 12
118896: PUSH
118897: LD_EXP 77
118901: PUSH
118902: LD_VAR 0 1
118906: ARRAY
118907: PPUSH
118908: LD_INT 25
118910: PUSH
118911: LD_INT 3
118913: PUSH
118914: EMPTY
118915: LIST
118916: LIST
118917: PPUSH
118918: CALL_OW 72
118922: ST_TO_ADDR
// if mc_remote_driver [ base ] then
118923: LD_EXP 117
118927: PUSH
118928: LD_VAR 0 1
118932: ARRAY
118933: IFFALSE 118957
// mechs := mechs diff mc_remote_driver [ base ] ;
118935: LD_ADDR_VAR 0 12
118939: PUSH
118940: LD_VAR 0 12
118944: PUSH
118945: LD_EXP 117
118949: PUSH
118950: LD_VAR 0 1
118954: ARRAY
118955: DIFF
118956: ST_TO_ADDR
// for i in mechs do
118957: LD_ADDR_VAR 0 4
118961: PUSH
118962: LD_VAR 0 12
118966: PUSH
118967: FOR_IN
118968: IFFALSE 119003
// if GetTag ( i ) > 0 then
118970: LD_VAR 0 4
118974: PPUSH
118975: CALL_OW 110
118979: PUSH
118980: LD_INT 0
118982: GREATER
118983: IFFALSE 119001
// mechs := mechs diff i ;
118985: LD_ADDR_VAR 0 12
118989: PUSH
118990: LD_VAR 0 12
118994: PUSH
118995: LD_VAR 0 4
118999: DIFF
119000: ST_TO_ADDR
119001: GO 118967
119003: POP
119004: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
119005: LD_ADDR_VAR 0 8
119009: PUSH
119010: LD_EXP 77
119014: PUSH
119015: LD_VAR 0 1
119019: ARRAY
119020: PPUSH
119021: LD_INT 2
119023: PUSH
119024: LD_INT 25
119026: PUSH
119027: LD_INT 1
119029: PUSH
119030: EMPTY
119031: LIST
119032: LIST
119033: PUSH
119034: LD_INT 25
119036: PUSH
119037: LD_INT 5
119039: PUSH
119040: EMPTY
119041: LIST
119042: LIST
119043: PUSH
119044: LD_INT 25
119046: PUSH
119047: LD_INT 8
119049: PUSH
119050: EMPTY
119051: LIST
119052: LIST
119053: PUSH
119054: LD_INT 25
119056: PUSH
119057: LD_INT 9
119059: PUSH
119060: EMPTY
119061: LIST
119062: LIST
119063: PUSH
119064: EMPTY
119065: LIST
119066: LIST
119067: LIST
119068: LIST
119069: LIST
119070: PPUSH
119071: CALL_OW 72
119075: ST_TO_ADDR
// if not defenders and not solds then
119076: LD_VAR 0 2
119080: NOT
119081: PUSH
119082: LD_VAR 0 8
119086: NOT
119087: AND
119088: IFFALSE 119092
// exit ;
119090: GO 120862
// depot_under_attack := false ;
119092: LD_ADDR_VAR 0 16
119096: PUSH
119097: LD_INT 0
119099: ST_TO_ADDR
// sold_defenders := [ ] ;
119100: LD_ADDR_VAR 0 17
119104: PUSH
119105: EMPTY
119106: ST_TO_ADDR
// if mechs then
119107: LD_VAR 0 12
119111: IFFALSE 119264
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
119113: LD_ADDR_VAR 0 4
119117: PUSH
119118: LD_VAR 0 2
119122: PPUSH
119123: LD_INT 21
119125: PUSH
119126: LD_INT 2
119128: PUSH
119129: EMPTY
119130: LIST
119131: LIST
119132: PPUSH
119133: CALL_OW 72
119137: PUSH
119138: FOR_IN
119139: IFFALSE 119262
// begin if GetTag ( i ) <> 20 then
119141: LD_VAR 0 4
119145: PPUSH
119146: CALL_OW 110
119150: PUSH
119151: LD_INT 20
119153: NONEQUAL
119154: IFFALSE 119168
// SetTag ( i , 20 ) ;
119156: LD_VAR 0 4
119160: PPUSH
119161: LD_INT 20
119163: PPUSH
119164: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
119168: LD_VAR 0 4
119172: PPUSH
119173: CALL_OW 263
119177: PUSH
119178: LD_INT 1
119180: EQUAL
119181: PUSH
119182: LD_VAR 0 4
119186: PPUSH
119187: CALL_OW 311
119191: NOT
119192: AND
119193: IFFALSE 119260
// begin un := mechs [ 1 ] ;
119195: LD_ADDR_VAR 0 10
119199: PUSH
119200: LD_VAR 0 12
119204: PUSH
119205: LD_INT 1
119207: ARRAY
119208: ST_TO_ADDR
// ComExit ( un ) ;
119209: LD_VAR 0 10
119213: PPUSH
119214: CALL 89928 0 1
// AddComEnterUnit ( un , i ) ;
119218: LD_VAR 0 10
119222: PPUSH
119223: LD_VAR 0 4
119227: PPUSH
119228: CALL_OW 180
// SetTag ( un , 19 ) ;
119232: LD_VAR 0 10
119236: PPUSH
119237: LD_INT 19
119239: PPUSH
119240: CALL_OW 109
// mechs := mechs diff un ;
119244: LD_ADDR_VAR 0 12
119248: PUSH
119249: LD_VAR 0 12
119253: PUSH
119254: LD_VAR 0 10
119258: DIFF
119259: ST_TO_ADDR
// end ; end ;
119260: GO 119138
119262: POP
119263: POP
// if solds then
119264: LD_VAR 0 8
119268: IFFALSE 119327
// for i in solds do
119270: LD_ADDR_VAR 0 4
119274: PUSH
119275: LD_VAR 0 8
119279: PUSH
119280: FOR_IN
119281: IFFALSE 119325
// if not GetTag ( i ) then
119283: LD_VAR 0 4
119287: PPUSH
119288: CALL_OW 110
119292: NOT
119293: IFFALSE 119323
// begin defenders := defenders union i ;
119295: LD_ADDR_VAR 0 2
119299: PUSH
119300: LD_VAR 0 2
119304: PUSH
119305: LD_VAR 0 4
119309: UNION
119310: ST_TO_ADDR
// SetTag ( i , 18 ) ;
119311: LD_VAR 0 4
119315: PPUSH
119316: LD_INT 18
119318: PPUSH
119319: CALL_OW 109
// end ;
119323: GO 119280
119325: POP
119326: POP
// repeat wait ( 0 0$2 ) ;
119327: LD_INT 70
119329: PPUSH
119330: CALL_OW 67
// enemy := mc_scan [ base ] ;
119334: LD_ADDR_VAR 0 21
119338: PUSH
119339: LD_EXP 100
119343: PUSH
119344: LD_VAR 0 1
119348: ARRAY
119349: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
119350: LD_EXP 77
119354: PUSH
119355: LD_VAR 0 1
119359: ARRAY
119360: NOT
119361: PUSH
119362: LD_EXP 77
119366: PUSH
119367: LD_VAR 0 1
119371: ARRAY
119372: PUSH
119373: EMPTY
119374: EQUAL
119375: OR
119376: IFFALSE 119413
// begin for i in defenders do
119378: LD_ADDR_VAR 0 4
119382: PUSH
119383: LD_VAR 0 2
119387: PUSH
119388: FOR_IN
119389: IFFALSE 119402
// ComStop ( i ) ;
119391: LD_VAR 0 4
119395: PPUSH
119396: CALL_OW 141
119400: GO 119388
119402: POP
119403: POP
// defenders := [ ] ;
119404: LD_ADDR_VAR 0 2
119408: PUSH
119409: EMPTY
119410: ST_TO_ADDR
// exit ;
119411: GO 120862
// end ; for i in defenders do
119413: LD_ADDR_VAR 0 4
119417: PUSH
119418: LD_VAR 0 2
119422: PUSH
119423: FOR_IN
119424: IFFALSE 120322
// begin e := NearestUnitToUnit ( enemy , i ) ;
119426: LD_ADDR_VAR 0 13
119430: PUSH
119431: LD_VAR 0 21
119435: PPUSH
119436: LD_VAR 0 4
119440: PPUSH
119441: CALL_OW 74
119445: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
119446: LD_ADDR_VAR 0 7
119450: PUSH
119451: LD_EXP 77
119455: PUSH
119456: LD_VAR 0 1
119460: ARRAY
119461: PPUSH
119462: LD_INT 2
119464: PUSH
119465: LD_INT 30
119467: PUSH
119468: LD_INT 0
119470: PUSH
119471: EMPTY
119472: LIST
119473: LIST
119474: PUSH
119475: LD_INT 30
119477: PUSH
119478: LD_INT 1
119480: PUSH
119481: EMPTY
119482: LIST
119483: LIST
119484: PUSH
119485: EMPTY
119486: LIST
119487: LIST
119488: LIST
119489: PPUSH
119490: CALL_OW 72
119494: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
119495: LD_ADDR_VAR 0 16
119499: PUSH
119500: LD_VAR 0 7
119504: NOT
119505: PUSH
119506: LD_VAR 0 7
119510: PPUSH
119511: LD_INT 3
119513: PUSH
119514: LD_INT 24
119516: PUSH
119517: LD_INT 600
119519: PUSH
119520: EMPTY
119521: LIST
119522: LIST
119523: PUSH
119524: EMPTY
119525: LIST
119526: LIST
119527: PPUSH
119528: CALL_OW 72
119532: OR
119533: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
119534: LD_VAR 0 4
119538: PPUSH
119539: CALL_OW 247
119543: PUSH
119544: LD_INT 2
119546: DOUBLE
119547: EQUAL
119548: IFTRUE 119552
119550: GO 119948
119552: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
119553: LD_VAR 0 4
119557: PPUSH
119558: CALL_OW 256
119562: PUSH
119563: LD_INT 1000
119565: EQUAL
119566: PUSH
119567: LD_VAR 0 4
119571: PPUSH
119572: LD_VAR 0 13
119576: PPUSH
119577: CALL_OW 296
119581: PUSH
119582: LD_INT 40
119584: LESS
119585: PUSH
119586: LD_VAR 0 13
119590: PPUSH
119591: LD_EXP 102
119595: PUSH
119596: LD_VAR 0 1
119600: ARRAY
119601: PPUSH
119602: CALL_OW 308
119606: OR
119607: AND
119608: IFFALSE 119730
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
119610: LD_VAR 0 4
119614: PPUSH
119615: CALL_OW 262
119619: PUSH
119620: LD_INT 1
119622: EQUAL
119623: PUSH
119624: LD_VAR 0 4
119628: PPUSH
119629: CALL_OW 261
119633: PUSH
119634: LD_INT 30
119636: LESS
119637: AND
119638: PUSH
119639: LD_VAR 0 7
119643: AND
119644: IFFALSE 119714
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
119646: LD_VAR 0 4
119650: PPUSH
119651: LD_VAR 0 7
119655: PPUSH
119656: LD_VAR 0 4
119660: PPUSH
119661: CALL_OW 74
119665: PPUSH
119666: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
119670: LD_VAR 0 4
119674: PPUSH
119675: LD_VAR 0 7
119679: PPUSH
119680: LD_VAR 0 4
119684: PPUSH
119685: CALL_OW 74
119689: PPUSH
119690: CALL_OW 296
119694: PUSH
119695: LD_INT 6
119697: LESS
119698: IFFALSE 119712
// SetFuel ( i , 100 ) ;
119700: LD_VAR 0 4
119704: PPUSH
119705: LD_INT 100
119707: PPUSH
119708: CALL_OW 240
// end else
119712: GO 119728
// ComAttackUnit ( i , e ) ;
119714: LD_VAR 0 4
119718: PPUSH
119719: LD_VAR 0 13
119723: PPUSH
119724: CALL_OW 115
// end else
119728: GO 119831
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
119730: LD_VAR 0 13
119734: PPUSH
119735: LD_EXP 102
119739: PUSH
119740: LD_VAR 0 1
119744: ARRAY
119745: PPUSH
119746: CALL_OW 308
119750: NOT
119751: PUSH
119752: LD_VAR 0 4
119756: PPUSH
119757: LD_VAR 0 13
119761: PPUSH
119762: CALL_OW 296
119766: PUSH
119767: LD_INT 40
119769: GREATEREQUAL
119770: AND
119771: PUSH
119772: LD_VAR 0 4
119776: PPUSH
119777: CALL_OW 256
119781: PUSH
119782: LD_INT 650
119784: LESSEQUAL
119785: OR
119786: PUSH
119787: LD_VAR 0 4
119791: PPUSH
119792: LD_EXP 101
119796: PUSH
119797: LD_VAR 0 1
119801: ARRAY
119802: PPUSH
119803: CALL_OW 308
119807: NOT
119808: AND
119809: IFFALSE 119831
// ComMoveToArea ( i , mc_parking [ base ] ) ;
119811: LD_VAR 0 4
119815: PPUSH
119816: LD_EXP 101
119820: PUSH
119821: LD_VAR 0 1
119825: ARRAY
119826: PPUSH
119827: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
119831: LD_VAR 0 4
119835: PPUSH
119836: CALL_OW 256
119840: PUSH
119841: LD_INT 1000
119843: LESS
119844: PUSH
119845: LD_VAR 0 4
119849: PPUSH
119850: CALL_OW 263
119854: PUSH
119855: LD_INT 1
119857: EQUAL
119858: AND
119859: PUSH
119860: LD_VAR 0 4
119864: PPUSH
119865: CALL_OW 311
119869: AND
119870: PUSH
119871: LD_VAR 0 4
119875: PPUSH
119876: LD_EXP 101
119880: PUSH
119881: LD_VAR 0 1
119885: ARRAY
119886: PPUSH
119887: CALL_OW 308
119891: AND
119892: IFFALSE 119946
// begin mech := IsDrivenBy ( i ) ;
119894: LD_ADDR_VAR 0 9
119898: PUSH
119899: LD_VAR 0 4
119903: PPUSH
119904: CALL_OW 311
119908: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
119909: LD_VAR 0 9
119913: PPUSH
119914: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
119918: LD_VAR 0 9
119922: PPUSH
119923: LD_VAR 0 4
119927: PPUSH
119928: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
119932: LD_VAR 0 9
119936: PPUSH
119937: LD_VAR 0 4
119941: PPUSH
119942: CALL_OW 180
// end ; end ; unit_human :
119946: GO 120293
119948: LD_INT 1
119950: DOUBLE
119951: EQUAL
119952: IFTRUE 119956
119954: GO 120292
119956: POP
// begin b := IsInUnit ( i ) ;
119957: LD_ADDR_VAR 0 18
119961: PUSH
119962: LD_VAR 0 4
119966: PPUSH
119967: CALL_OW 310
119971: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
119972: LD_ADDR_VAR 0 19
119976: PUSH
119977: LD_VAR 0 18
119981: NOT
119982: PUSH
119983: LD_VAR 0 18
119987: PPUSH
119988: CALL_OW 266
119992: PUSH
119993: LD_INT 32
119995: PUSH
119996: LD_INT 31
119998: PUSH
119999: EMPTY
120000: LIST
120001: LIST
120002: IN
120003: OR
120004: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
120005: LD_VAR 0 18
120009: PPUSH
120010: CALL_OW 266
120014: PUSH
120015: LD_INT 5
120017: EQUAL
120018: PUSH
120019: LD_VAR 0 4
120023: PPUSH
120024: CALL_OW 257
120028: PUSH
120029: LD_INT 1
120031: PUSH
120032: LD_INT 2
120034: PUSH
120035: LD_INT 3
120037: PUSH
120038: LD_INT 4
120040: PUSH
120041: EMPTY
120042: LIST
120043: LIST
120044: LIST
120045: LIST
120046: IN
120047: AND
120048: IFFALSE 120085
// begin class := AllowSpecClass ( i ) ;
120050: LD_ADDR_VAR 0 20
120054: PUSH
120055: LD_VAR 0 4
120059: PPUSH
120060: CALL 53848 0 1
120064: ST_TO_ADDR
// if class then
120065: LD_VAR 0 20
120069: IFFALSE 120085
// ComChangeProfession ( i , class ) ;
120071: LD_VAR 0 4
120075: PPUSH
120076: LD_VAR 0 20
120080: PPUSH
120081: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
120085: LD_VAR 0 16
120089: PUSH
120090: LD_VAR 0 2
120094: PPUSH
120095: LD_INT 21
120097: PUSH
120098: LD_INT 2
120100: PUSH
120101: EMPTY
120102: LIST
120103: LIST
120104: PPUSH
120105: CALL_OW 72
120109: PUSH
120110: LD_INT 1
120112: LESSEQUAL
120113: OR
120114: PUSH
120115: LD_VAR 0 19
120119: AND
120120: PUSH
120121: LD_VAR 0 4
120125: PUSH
120126: LD_VAR 0 17
120130: IN
120131: NOT
120132: AND
120133: IFFALSE 120226
// begin if b then
120135: LD_VAR 0 18
120139: IFFALSE 120188
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
120141: LD_VAR 0 18
120145: PPUSH
120146: LD_VAR 0 21
120150: PPUSH
120151: LD_VAR 0 18
120155: PPUSH
120156: CALL_OW 74
120160: PPUSH
120161: CALL_OW 296
120165: PUSH
120166: LD_INT 10
120168: LESS
120169: PUSH
120170: LD_VAR 0 18
120174: PPUSH
120175: CALL_OW 461
120179: PUSH
120180: LD_INT 7
120182: NONEQUAL
120183: AND
120184: IFFALSE 120188
// continue ;
120186: GO 119423
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
120188: LD_ADDR_VAR 0 17
120192: PUSH
120193: LD_VAR 0 17
120197: PPUSH
120198: LD_VAR 0 17
120202: PUSH
120203: LD_INT 1
120205: PLUS
120206: PPUSH
120207: LD_VAR 0 4
120211: PPUSH
120212: CALL_OW 1
120216: ST_TO_ADDR
// ComExitBuilding ( i ) ;
120217: LD_VAR 0 4
120221: PPUSH
120222: CALL_OW 122
// end ; if sold_defenders then
120226: LD_VAR 0 17
120230: IFFALSE 120290
// if i in sold_defenders then
120232: LD_VAR 0 4
120236: PUSH
120237: LD_VAR 0 17
120241: IN
120242: IFFALSE 120290
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
120244: LD_VAR 0 4
120248: PPUSH
120249: CALL_OW 314
120253: NOT
120254: PUSH
120255: LD_VAR 0 4
120259: PPUSH
120260: LD_VAR 0 13
120264: PPUSH
120265: CALL_OW 296
120269: PUSH
120270: LD_INT 30
120272: LESS
120273: AND
120274: IFFALSE 120290
// ComAttackUnit ( i , e ) ;
120276: LD_VAR 0 4
120280: PPUSH
120281: LD_VAR 0 13
120285: PPUSH
120286: CALL_OW 115
// end ; end ; end ;
120290: GO 120293
120292: POP
// if IsDead ( i ) then
120293: LD_VAR 0 4
120297: PPUSH
120298: CALL_OW 301
120302: IFFALSE 120320
// defenders := defenders diff i ;
120304: LD_ADDR_VAR 0 2
120308: PUSH
120309: LD_VAR 0 2
120313: PUSH
120314: LD_VAR 0 4
120318: DIFF
120319: ST_TO_ADDR
// end ;
120320: GO 119423
120322: POP
120323: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
120324: LD_VAR 0 21
120328: NOT
120329: PUSH
120330: LD_VAR 0 2
120334: NOT
120335: OR
120336: PUSH
120337: LD_EXP 77
120341: PUSH
120342: LD_VAR 0 1
120346: ARRAY
120347: NOT
120348: OR
120349: IFFALSE 119327
// MC_Reset ( base , 18 ) ;
120351: LD_VAR 0 1
120355: PPUSH
120356: LD_INT 18
120358: PPUSH
120359: CALL 25521 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
120363: LD_ADDR_VAR 0 2
120367: PUSH
120368: LD_VAR 0 2
120372: PUSH
120373: LD_VAR 0 2
120377: PPUSH
120378: LD_INT 2
120380: PUSH
120381: LD_INT 25
120383: PUSH
120384: LD_INT 1
120386: PUSH
120387: EMPTY
120388: LIST
120389: LIST
120390: PUSH
120391: LD_INT 25
120393: PUSH
120394: LD_INT 5
120396: PUSH
120397: EMPTY
120398: LIST
120399: LIST
120400: PUSH
120401: LD_INT 25
120403: PUSH
120404: LD_INT 8
120406: PUSH
120407: EMPTY
120408: LIST
120409: LIST
120410: PUSH
120411: LD_INT 25
120413: PUSH
120414: LD_INT 9
120416: PUSH
120417: EMPTY
120418: LIST
120419: LIST
120420: PUSH
120421: EMPTY
120422: LIST
120423: LIST
120424: LIST
120425: LIST
120426: LIST
120427: PPUSH
120428: CALL_OW 72
120432: DIFF
120433: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
120434: LD_VAR 0 21
120438: NOT
120439: PUSH
120440: LD_VAR 0 2
120444: PPUSH
120445: LD_INT 21
120447: PUSH
120448: LD_INT 2
120450: PUSH
120451: EMPTY
120452: LIST
120453: LIST
120454: PPUSH
120455: CALL_OW 72
120459: AND
120460: IFFALSE 120798
// begin tmp := FilterByTag ( defenders , 19 ) ;
120462: LD_ADDR_VAR 0 11
120466: PUSH
120467: LD_VAR 0 2
120471: PPUSH
120472: LD_INT 19
120474: PPUSH
120475: CALL 87111 0 2
120479: ST_TO_ADDR
// if tmp then
120480: LD_VAR 0 11
120484: IFFALSE 120554
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
120486: LD_ADDR_VAR 0 11
120490: PUSH
120491: LD_VAR 0 11
120495: PPUSH
120496: LD_INT 25
120498: PUSH
120499: LD_INT 3
120501: PUSH
120502: EMPTY
120503: LIST
120504: LIST
120505: PPUSH
120506: CALL_OW 72
120510: ST_TO_ADDR
// if tmp then
120511: LD_VAR 0 11
120515: IFFALSE 120554
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
120517: LD_ADDR_EXP 89
120521: PUSH
120522: LD_EXP 89
120526: PPUSH
120527: LD_VAR 0 1
120531: PPUSH
120532: LD_EXP 89
120536: PUSH
120537: LD_VAR 0 1
120541: ARRAY
120542: PUSH
120543: LD_VAR 0 11
120547: UNION
120548: PPUSH
120549: CALL_OW 1
120553: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
120554: LD_VAR 0 1
120558: PPUSH
120559: LD_INT 19
120561: PPUSH
120562: CALL 25521 0 2
// repeat wait ( 0 0$1 ) ;
120566: LD_INT 35
120568: PPUSH
120569: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
120573: LD_EXP 77
120577: PUSH
120578: LD_VAR 0 1
120582: ARRAY
120583: NOT
120584: PUSH
120585: LD_EXP 77
120589: PUSH
120590: LD_VAR 0 1
120594: ARRAY
120595: PUSH
120596: EMPTY
120597: EQUAL
120598: OR
120599: IFFALSE 120636
// begin for i in defenders do
120601: LD_ADDR_VAR 0 4
120605: PUSH
120606: LD_VAR 0 2
120610: PUSH
120611: FOR_IN
120612: IFFALSE 120625
// ComStop ( i ) ;
120614: LD_VAR 0 4
120618: PPUSH
120619: CALL_OW 141
120623: GO 120611
120625: POP
120626: POP
// defenders := [ ] ;
120627: LD_ADDR_VAR 0 2
120631: PUSH
120632: EMPTY
120633: ST_TO_ADDR
// exit ;
120634: GO 120862
// end ; for i in defenders do
120636: LD_ADDR_VAR 0 4
120640: PUSH
120641: LD_VAR 0 2
120645: PUSH
120646: FOR_IN
120647: IFFALSE 120736
// begin if not IsInArea ( i , mc_parking [ base ] ) then
120649: LD_VAR 0 4
120653: PPUSH
120654: LD_EXP 101
120658: PUSH
120659: LD_VAR 0 1
120663: ARRAY
120664: PPUSH
120665: CALL_OW 308
120669: NOT
120670: IFFALSE 120694
// ComMoveToArea ( i , mc_parking [ base ] ) else
120672: LD_VAR 0 4
120676: PPUSH
120677: LD_EXP 101
120681: PUSH
120682: LD_VAR 0 1
120686: ARRAY
120687: PPUSH
120688: CALL_OW 113
120692: GO 120734
// if GetControl ( i ) = control_manual then
120694: LD_VAR 0 4
120698: PPUSH
120699: CALL_OW 263
120703: PUSH
120704: LD_INT 1
120706: EQUAL
120707: IFFALSE 120734
// if IsDrivenBy ( i ) then
120709: LD_VAR 0 4
120713: PPUSH
120714: CALL_OW 311
120718: IFFALSE 120734
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
120720: LD_VAR 0 4
120724: PPUSH
120725: CALL_OW 311
120729: PPUSH
120730: CALL_OW 121
// end ;
120734: GO 120646
120736: POP
120737: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
120738: LD_VAR 0 2
120742: PPUSH
120743: LD_INT 95
120745: PUSH
120746: LD_EXP 101
120750: PUSH
120751: LD_VAR 0 1
120755: ARRAY
120756: PUSH
120757: EMPTY
120758: LIST
120759: LIST
120760: PPUSH
120761: CALL_OW 72
120765: PUSH
120766: LD_VAR 0 2
120770: EQUAL
120771: PUSH
120772: LD_EXP 100
120776: PUSH
120777: LD_VAR 0 1
120781: ARRAY
120782: OR
120783: PUSH
120784: LD_EXP 77
120788: PUSH
120789: LD_VAR 0 1
120793: ARRAY
120794: NOT
120795: OR
120796: IFFALSE 120566
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
120798: LD_ADDR_EXP 99
120802: PUSH
120803: LD_EXP 99
120807: PPUSH
120808: LD_VAR 0 1
120812: PPUSH
120813: LD_VAR 0 2
120817: PPUSH
120818: LD_INT 21
120820: PUSH
120821: LD_INT 2
120823: PUSH
120824: EMPTY
120825: LIST
120826: LIST
120827: PPUSH
120828: CALL_OW 72
120832: PPUSH
120833: CALL_OW 1
120837: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
120838: LD_VAR 0 1
120842: PPUSH
120843: LD_INT 19
120845: PPUSH
120846: CALL 25521 0 2
// MC_Reset ( base , 20 ) ;
120850: LD_VAR 0 1
120854: PPUSH
120855: LD_INT 20
120857: PPUSH
120858: CALL 25521 0 2
// end ; end_of_file
120862: LD_VAR 0 3
120866: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
120867: LD_VAR 0 1
120871: PUSH
120872: LD_INT 200
120874: DOUBLE
120875: GREATEREQUAL
120876: IFFALSE 120884
120878: LD_INT 299
120880: DOUBLE
120881: LESSEQUAL
120882: IFTRUE 120886
120884: GO 120918
120886: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
120887: LD_VAR 0 1
120891: PPUSH
120892: LD_VAR 0 2
120896: PPUSH
120897: LD_VAR 0 3
120901: PPUSH
120902: LD_VAR 0 4
120906: PPUSH
120907: LD_VAR 0 5
120911: PPUSH
120912: CALL 109653 0 5
120916: GO 120995
120918: LD_INT 300
120920: DOUBLE
120921: GREATEREQUAL
120922: IFFALSE 120930
120924: LD_INT 399
120926: DOUBLE
120927: LESSEQUAL
120928: IFTRUE 120932
120930: GO 120994
120932: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
120933: LD_VAR 0 1
120937: PPUSH
120938: LD_VAR 0 2
120942: PPUSH
120943: LD_VAR 0 3
120947: PPUSH
120948: LD_VAR 0 4
120952: PPUSH
120953: LD_VAR 0 5
120957: PPUSH
120958: LD_VAR 0 6
120962: PPUSH
120963: LD_VAR 0 7
120967: PPUSH
120968: LD_VAR 0 8
120972: PPUSH
120973: LD_VAR 0 9
120977: PPUSH
120978: LD_VAR 0 10
120982: PPUSH
120983: LD_VAR 0 11
120987: PPUSH
120988: CALL 105986 0 11
120992: GO 120995
120994: POP
// end ;
120995: PPOPN 11
120997: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
120998: LD_VAR 0 1
121002: PPUSH
121003: LD_VAR 0 2
121007: PPUSH
121008: LD_VAR 0 3
121012: PPUSH
121013: LD_VAR 0 4
121017: PPUSH
121018: LD_VAR 0 5
121022: PPUSH
121023: CALL 109389 0 5
// end ; end_of_file
121027: PPOPN 5
121029: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
121030: LD_VAR 0 1
121034: PPUSH
121035: LD_VAR 0 2
121039: PPUSH
121040: LD_VAR 0 3
121044: PPUSH
121045: LD_VAR 0 4
121049: PPUSH
121050: LD_VAR 0 5
121054: PPUSH
121055: LD_VAR 0 6
121059: PPUSH
121060: CALL 93638 0 6
// end ;
121064: PPOPN 6
121066: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
121067: LD_INT 0
121069: PPUSH
// begin if not units then
121070: LD_VAR 0 1
121074: NOT
121075: IFFALSE 121079
// exit ;
121077: GO 121079
// end ;
121079: PPOPN 7
121081: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
121082: CALL 93542 0 0
// end ;
121086: PPOPN 1
121088: END
