// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitMacro ;
  15: CALL 20732 0 0
// InitNature ;
  19: CALL 17258 0 0
// InitArtifact ;
  23: CALL 17871 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAmerican ;
  40: CALL 4579 0 0
// PrepareAlliance ;
  44: CALL 1375 0 0
// PrepareArabian ;
  48: CALL 6347 0 0
// PrepareRussian ;
  52: CALL 8332 0 0
// PrepareLegion ;
  56: CALL 6775 0 0
// Action ;
  60: CALL 10885 0 0
// MC_Start ( ) ;
  64: CALL 22844 0 0
// end ;
  68: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  80: LD_ADDR_EXP 9
  84: PUSH
  85: LD_STRING 11_artifact_captured
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// russianDestroyed := false ;
  96: LD_ADDR_EXP 2
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// legionDestroyed := false ;
 104: LD_ADDR_EXP 3
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// americanDestroyed := false ;
 112: LD_ADDR_EXP 4
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// arabianDestroyed := false ;
 120: LD_ADDR_EXP 5
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// americanCapitulated := false ;
 128: LD_ADDR_EXP 6
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// russianCapitulated := false ;
 136: LD_ADDR_EXP 7
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// legionCapitulated := false ;
 144: LD_ADDR_EXP 8
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// artifactIResearched := false ;
 152: LD_ADDR_EXP 12
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// artifactIIResearched := false ;
 160: LD_ADDR_EXP 13
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// artifactIIIResearched := false ;
 168: LD_ADDR_EXP 14
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// alienSpotted := false ;
 176: LD_ADDR_EXP 10
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// spawnOmar := false ;
 184: LD_ADDR_EXP 11
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 192: LD_ADDR_EXP 15
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 200: LD_ADDR_EXP 16
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// end ;
 208: LD_VAR 0 1
 212: RET
// export function CustomInitMacro ( ) ; begin
 213: LD_INT 0
 215: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 216: LD_ADDR_EXP 114
 220: PUSH
 221: LD_INT 26
 223: PUSH
 224: LD_INT 1
 226: PUSH
 227: LD_INT 4
 229: PUSH
 230: LD_INT 8
 232: PUSH
 233: EMPTY
 234: LIST
 235: LIST
 236: LIST
 237: LIST
 238: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 239: LD_ADDR_EXP 115
 243: PUSH
 244: LD_INT 27
 246: PUSH
 247: LD_INT 2
 249: PUSH
 250: LD_INT 3
 252: PUSH
 253: LD_INT 7
 255: PUSH
 256: EMPTY
 257: LIST
 258: LIST
 259: LIST
 260: LIST
 261: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 ] [ Difficulty ] , arabianMinefield ) ;
 262: LD_INT 1
 264: PPUSH
 265: LD_INT 6
 267: PUSH
 268: LD_INT 7
 270: PUSH
 271: LD_INT 9
 273: PUSH
 274: EMPTY
 275: LIST
 276: LIST
 277: LIST
 278: PUSH
 279: LD_OWVAR 67
 283: ARRAY
 284: PPUSH
 285: LD_INT 28
 287: PPUSH
 288: CALL 44045 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 292: LD_INT 1
 294: PPUSH
 295: LD_INT 10
 297: PUSH
 298: LD_INT 11
 300: PUSH
 301: LD_INT 13
 303: PUSH
 304: LD_INT 15
 306: PUSH
 307: EMPTY
 308: LIST
 309: LIST
 310: LIST
 311: LIST
 312: PPUSH
 313: CALL 45105 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 317: LD_INT 1
 319: PPUSH
 320: LD_INT 29
 322: PUSH
 323: EMPTY
 324: LIST
 325: PPUSH
 326: CALL 45198 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 330: LD_ADDR_EXP 119
 334: PUSH
 335: LD_EXP 119
 339: PPUSH
 340: LD_INT 1
 342: PPUSH
 343: LD_INT 22
 345: PUSH
 346: LD_INT 2
 348: PUSH
 349: EMPTY
 350: LIST
 351: LIST
 352: PUSH
 353: LD_INT 25
 355: PUSH
 356: LD_INT 15
 358: PUSH
 359: EMPTY
 360: LIST
 361: LIST
 362: PUSH
 363: EMPTY
 364: LIST
 365: LIST
 366: PPUSH
 367: CALL_OW 69
 371: PPUSH
 372: CALL_OW 1
 376: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 377: LD_INT 1
 379: PPUSH
 380: LD_INT 13
 382: PUSH
 383: LD_INT 2
 385: PUSH
 386: LD_INT 1
 388: PUSH
 389: LD_INT 31
 391: PUSH
 392: EMPTY
 393: LIST
 394: LIST
 395: LIST
 396: LIST
 397: PUSH
 398: LD_INT 13
 400: PUSH
 401: LD_INT 2
 403: PUSH
 404: LD_INT 1
 406: PUSH
 407: LD_INT 31
 409: PUSH
 410: EMPTY
 411: LIST
 412: LIST
 413: LIST
 414: LIST
 415: PUSH
 416: LD_INT 13
 418: PUSH
 419: LD_INT 1
 421: PUSH
 422: LD_INT 1
 424: PUSH
 425: LD_INT 28
 427: PUSH
 428: EMPTY
 429: LIST
 430: LIST
 431: LIST
 432: LIST
 433: PUSH
 434: LD_INT 13
 436: PUSH
 437: LD_INT 1
 439: PUSH
 440: LD_INT 1
 442: PUSH
 443: LD_INT 28
 445: PUSH
 446: EMPTY
 447: LIST
 448: LIST
 449: LIST
 450: LIST
 451: PUSH
 452: LD_INT 13
 454: PUSH
 455: LD_INT 1
 457: PUSH
 458: LD_INT 1
 460: PUSH
 461: LD_INT 28
 463: PUSH
 464: EMPTY
 465: LIST
 466: LIST
 467: LIST
 468: LIST
 469: PUSH
 470: LD_INT 13
 472: PUSH
 473: LD_INT 1
 475: PUSH
 476: LD_INT 1
 478: PUSH
 479: LD_INT 28
 481: PUSH
 482: EMPTY
 483: LIST
 484: LIST
 485: LIST
 486: LIST
 487: PUSH
 488: EMPTY
 489: LIST
 490: LIST
 491: LIST
 492: LIST
 493: LIST
 494: LIST
 495: PPUSH
 496: CALL 44363 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 500: LD_INT 1
 502: PPUSH
 503: LD_INT 4
 505: PPUSH
 506: CALL 44548 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 510: LD_INT 2
 512: PPUSH
 513: LD_INT 10
 515: PUSH
 516: LD_INT 11
 518: PUSH
 519: LD_INT 12
 521: PUSH
 522: LD_INT 14
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: LIST
 529: LIST
 530: PPUSH
 531: CALL 45105 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 535: LD_INT 2
 537: PPUSH
 538: LD_INT 14
 540: PUSH
 541: EMPTY
 542: LIST
 543: PPUSH
 544: CALL 45198 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 548: LD_INT 2
 550: PPUSH
 551: LD_INT 21
 553: PUSH
 554: LD_INT 3
 556: PUSH
 557: LD_INT 3
 559: PUSH
 560: LD_INT 51
 562: PUSH
 563: EMPTY
 564: LIST
 565: LIST
 566: LIST
 567: LIST
 568: PUSH
 569: LD_INT 22
 571: PUSH
 572: LD_INT 3
 574: PUSH
 575: LD_INT 3
 577: PUSH
 578: LD_INT 52
 580: PUSH
 581: EMPTY
 582: LIST
 583: LIST
 584: LIST
 585: LIST
 586: PUSH
 587: LD_INT 22
 589: PUSH
 590: LD_INT 3
 592: PUSH
 593: LD_INT 3
 595: PUSH
 596: LD_INT 52
 598: PUSH
 599: EMPTY
 600: LIST
 601: LIST
 602: LIST
 603: LIST
 604: PUSH
 605: LD_INT 24
 607: PUSH
 608: LD_INT 3
 610: PUSH
 611: LD_INT 3
 613: PUSH
 614: LD_INT 47
 616: PUSH
 617: EMPTY
 618: LIST
 619: LIST
 620: LIST
 621: LIST
 622: PUSH
 623: LD_INT 24
 625: PUSH
 626: LD_INT 3
 628: PUSH
 629: LD_INT 3
 631: PUSH
 632: LD_INT 47
 634: PUSH
 635: EMPTY
 636: LIST
 637: LIST
 638: LIST
 639: LIST
 640: PUSH
 641: LD_INT 24
 643: PUSH
 644: LD_INT 3
 646: PUSH
 647: LD_INT 3
 649: PUSH
 650: LD_INT 47
 652: PUSH
 653: EMPTY
 654: LIST
 655: LIST
 656: LIST
 657: LIST
 658: PUSH
 659: LD_INT 24
 661: PUSH
 662: LD_INT 3
 664: PUSH
 665: LD_INT 3
 667: PUSH
 668: LD_INT 47
 670: PUSH
 671: EMPTY
 672: LIST
 673: LIST
 674: LIST
 675: LIST
 676: PUSH
 677: LD_INT 24
 679: PUSH
 680: LD_INT 3
 682: PUSH
 683: LD_INT 3
 685: PUSH
 686: LD_INT 47
 688: PUSH
 689: EMPTY
 690: LIST
 691: LIST
 692: LIST
 693: LIST
 694: PUSH
 695: EMPTY
 696: LIST
 697: LIST
 698: LIST
 699: LIST
 700: LIST
 701: LIST
 702: LIST
 703: LIST
 704: PPUSH
 705: CALL 44363 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 709: LD_INT 2
 711: PPUSH
 712: LD_INT 5
 714: PPUSH
 715: CALL 44548 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 719: LD_INT 2
 721: PPUSH
 722: LD_INT 0
 724: PPUSH
 725: CALL 44978 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 729: LD_INT 3
 731: PPUSH
 732: LD_INT 10
 734: PUSH
 735: LD_INT 12
 737: PUSH
 738: LD_INT 15
 740: PUSH
 741: EMPTY
 742: LIST
 743: LIST
 744: LIST
 745: PUSH
 746: LD_OWVAR 67
 750: ARRAY
 751: PPUSH
 752: LD_INT 24
 754: PPUSH
 755: CALL 44045 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 759: LD_INT 3
 761: PPUSH
 762: LD_INT 10
 764: PUSH
 765: LD_INT 11
 767: PUSH
 768: LD_INT 13
 770: PUSH
 771: LD_INT 15
 773: PUSH
 774: EMPTY
 775: LIST
 776: LIST
 777: LIST
 778: LIST
 779: PPUSH
 780: CALL 45105 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 784: LD_INT 3
 786: PPUSH
 787: LD_INT 13
 789: PUSH
 790: EMPTY
 791: LIST
 792: PPUSH
 793: CALL 45198 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 797: LD_ADDR_EXP 119
 801: PUSH
 802: LD_EXP 119
 806: PPUSH
 807: LD_INT 3
 809: PPUSH
 810: LD_INT 22
 812: PUSH
 813: LD_INT 8
 815: PUSH
 816: EMPTY
 817: LIST
 818: LIST
 819: PUSH
 820: LD_INT 25
 822: PUSH
 823: LD_INT 15
 825: PUSH
 826: EMPTY
 827: LIST
 828: LIST
 829: PUSH
 830: EMPTY
 831: LIST
 832: LIST
 833: PPUSH
 834: CALL_OW 69
 838: PPUSH
 839: CALL_OW 1
 843: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 844: LD_INT 3
 846: PPUSH
 847: LD_INT 13
 849: PUSH
 850: LD_INT 2
 852: PUSH
 853: LD_INT 1
 855: PUSH
 856: LD_INT 31
 858: PUSH
 859: EMPTY
 860: LIST
 861: LIST
 862: LIST
 863: LIST
 864: PUSH
 865: LD_INT 13
 867: PUSH
 868: LD_INT 2
 870: PUSH
 871: LD_INT 1
 873: PUSH
 874: LD_INT 31
 876: PUSH
 877: EMPTY
 878: LIST
 879: LIST
 880: LIST
 881: LIST
 882: PUSH
 883: LD_INT 13
 885: PUSH
 886: LD_INT 3
 888: PUSH
 889: LD_INT 2
 891: PUSH
 892: LD_INT 32
 894: PUSH
 895: EMPTY
 896: LIST
 897: LIST
 898: LIST
 899: LIST
 900: PUSH
 901: LD_INT 14
 903: PUSH
 904: LD_INT 1
 906: PUSH
 907: LD_INT 1
 909: PUSH
 910: LD_INT 28
 912: PUSH
 913: EMPTY
 914: LIST
 915: LIST
 916: LIST
 917: LIST
 918: PUSH
 919: LD_INT 14
 921: PUSH
 922: LD_INT 1
 924: PUSH
 925: LD_INT 1
 927: PUSH
 928: LD_INT 28
 930: PUSH
 931: EMPTY
 932: LIST
 933: LIST
 934: LIST
 935: LIST
 936: PUSH
 937: LD_INT 14
 939: PUSH
 940: LD_INT 1
 942: PUSH
 943: LD_INT 1
 945: PUSH
 946: LD_INT 28
 948: PUSH
 949: EMPTY
 950: LIST
 951: LIST
 952: LIST
 953: LIST
 954: PUSH
 955: LD_INT 14
 957: PUSH
 958: LD_INT 1
 960: PUSH
 961: LD_INT 1
 963: PUSH
 964: LD_INT 28
 966: PUSH
 967: EMPTY
 968: LIST
 969: LIST
 970: LIST
 971: LIST
 972: PUSH
 973: EMPTY
 974: LIST
 975: LIST
 976: LIST
 977: LIST
 978: LIST
 979: LIST
 980: LIST
 981: PPUSH
 982: CALL 44363 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
 986: LD_INT 3
 988: PPUSH
 989: LD_INT 4
 991: PPUSH
 992: CALL 44548 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
 996: LD_INT 4
 998: PPUSH
 999: LD_INT 10
1001: PUSH
1002: LD_INT 12
1004: PUSH
1005: LD_INT 11
1007: PUSH
1008: LD_INT 15
1010: PUSH
1011: EMPTY
1012: LIST
1013: LIST
1014: LIST
1015: LIST
1016: PPUSH
1017: CALL 45105 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1021: LD_INT 4
1023: PPUSH
1024: LD_INT 33
1026: PUSH
1027: EMPTY
1028: LIST
1029: PPUSH
1030: CALL 45198 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1034: LD_INT 4
1036: PPUSH
1037: LD_INT 5
1039: PUSH
1040: LD_INT 6
1042: PUSH
1043: LD_INT 7
1045: PUSH
1046: LD_INT 9
1048: PUSH
1049: LD_INT 10
1051: PUSH
1052: EMPTY
1053: LIST
1054: LIST
1055: LIST
1056: LIST
1057: LIST
1058: PPUSH
1059: CALL 45516 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1063: LD_INT 4
1065: PPUSH
1066: LD_INT 54
1068: PPUSH
1069: LD_INT 85
1071: PPUSH
1072: LD_INT 2
1074: PPUSH
1075: LD_INT 25
1077: PUSH
1078: LD_INT 16
1080: PUSH
1081: LD_INT 17
1083: PUSH
1084: LD_INT 18
1086: PUSH
1087: LD_INT 22
1089: PUSH
1090: EMPTY
1091: LIST
1092: LIST
1093: LIST
1094: LIST
1095: LIST
1096: PPUSH
1097: CALL 45310 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1101: LD_INT 4
1103: PPUSH
1104: LD_INT 5
1106: PUSH
1107: LD_INT 1
1109: PUSH
1110: LD_INT 1
1112: PUSH
1113: LD_INT 7
1115: PUSH
1116: EMPTY
1117: LIST
1118: LIST
1119: LIST
1120: LIST
1121: PUSH
1122: LD_INT 5
1124: PUSH
1125: LD_INT 1
1127: PUSH
1128: LD_INT 1
1130: PUSH
1131: LD_INT 6
1133: PUSH
1134: EMPTY
1135: LIST
1136: LIST
1137: LIST
1138: LIST
1139: PUSH
1140: LD_INT 5
1142: PUSH
1143: LD_INT 1
1145: PUSH
1146: LD_INT 1
1148: PUSH
1149: LD_INT 7
1151: PUSH
1152: EMPTY
1153: LIST
1154: LIST
1155: LIST
1156: LIST
1157: PUSH
1158: LD_INT 5
1160: PUSH
1161: LD_INT 1
1163: PUSH
1164: LD_INT 1
1166: PUSH
1167: LD_INT 6
1169: PUSH
1170: EMPTY
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: PUSH
1176: LD_INT 5
1178: PUSH
1179: LD_INT 1
1181: PUSH
1182: LD_INT 3
1184: PUSH
1185: LD_INT 12
1187: PUSH
1188: EMPTY
1189: LIST
1190: LIST
1191: LIST
1192: LIST
1193: PUSH
1194: LD_INT 3
1196: PUSH
1197: LD_INT 1
1199: PUSH
1200: LD_INT 3
1202: PUSH
1203: LD_INT 13
1205: PUSH
1206: EMPTY
1207: LIST
1208: LIST
1209: LIST
1210: LIST
1211: PUSH
1212: EMPTY
1213: LIST
1214: LIST
1215: LIST
1216: LIST
1217: LIST
1218: LIST
1219: PPUSH
1220: CALL 44363 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1224: LD_INT 4
1226: PPUSH
1227: LD_INT 4
1229: PPUSH
1230: CALL 44548 0 2
// MC_SetTame ( 4 , powellApe ) ;
1234: LD_INT 4
1236: PPUSH
1237: LD_INT 11
1239: PPUSH
1240: CALL 44929 0 2
// end ;
1244: LD_VAR 0 1
1248: RET
// every 0 0$1 trigger debug do var i ;
1249: LD_EXP 1
1253: IFFALSE 1351
1255: GO 1257
1257: DISABLE
1258: LD_INT 0
1260: PPUSH
// begin enable ;
1261: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1262: LD_ADDR_VAR 0 1
1266: PUSH
1267: LD_INT 22
1269: PUSH
1270: LD_INT 7
1272: PUSH
1273: EMPTY
1274: LIST
1275: LIST
1276: PUSH
1277: LD_INT 2
1279: PUSH
1280: LD_INT 21
1282: PUSH
1283: LD_INT 1
1285: PUSH
1286: EMPTY
1287: LIST
1288: LIST
1289: PUSH
1290: LD_INT 21
1292: PUSH
1293: LD_INT 2
1295: PUSH
1296: EMPTY
1297: LIST
1298: LIST
1299: PUSH
1300: EMPTY
1301: LIST
1302: LIST
1303: LIST
1304: PUSH
1305: LD_INT 3
1307: PUSH
1308: LD_INT 24
1310: PUSH
1311: LD_INT 1000
1313: PUSH
1314: EMPTY
1315: LIST
1316: LIST
1317: PUSH
1318: EMPTY
1319: LIST
1320: LIST
1321: PUSH
1322: EMPTY
1323: LIST
1324: LIST
1325: LIST
1326: PPUSH
1327: CALL_OW 69
1331: PUSH
1332: FOR_IN
1333: IFFALSE 1349
// SetLives ( i , 1000 ) ;
1335: LD_VAR 0 1
1339: PPUSH
1340: LD_INT 1000
1342: PPUSH
1343: CALL_OW 234
1347: GO 1332
1349: POP
1350: POP
// end ;
1351: PPOPN 1
1353: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1354: LD_EXP 16
1358: PUSH
1359: LD_INT 5
1361: GREATEREQUAL
1362: IFFALSE 1374
1364: GO 1366
1366: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1367: LD_STRING ACH_ARTIFACT
1369: PPUSH
1370: CALL_OW 543
1374: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1375: LD_INT 0
1377: PPUSH
1378: PPUSH
1379: PPUSH
1380: PPUSH
1381: PPUSH
// uc_side := 7 ;
1382: LD_ADDR_OWVAR 20
1386: PUSH
1387: LD_INT 7
1389: ST_TO_ADDR
// tmp := [ ] ;
1390: LD_ADDR_VAR 0 5
1394: PUSH
1395: EMPTY
1396: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1397: LD_ADDR_EXP 17
1401: PUSH
1402: LD_STRING JMM
1404: PPUSH
1405: LD_EXP 1
1409: NOT
1410: PPUSH
1411: LD_STRING 14a_
1413: PPUSH
1414: CALL 50755 0 3
1418: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1419: LD_ADDR_EXP 49
1423: PUSH
1424: LD_STRING Burlak
1426: PPUSH
1427: LD_EXP 1
1431: NOT
1432: PPUSH
1433: LD_STRING 14a_
1435: PPUSH
1436: CALL 50755 0 3
1440: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1441: LD_ADDR_EXP 32
1445: PUSH
1446: LD_STRING Joan
1448: PPUSH
1449: LD_EXP 1
1453: NOT
1454: PPUSH
1455: LD_STRING 13a_
1457: PPUSH
1458: CALL 50755 0 3
1462: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1463: LD_ADDR_EXP 18
1467: PUSH
1468: LD_STRING Roth
1470: PPUSH
1471: LD_EXP 1
1475: NOT
1476: PPUSH
1477: LD_STRING 13a_
1479: PPUSH
1480: CALL 50755 0 3
1484: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1485: LD_ADDR_EXP 35
1489: PUSH
1490: LD_STRING Gossudarov
1492: PPUSH
1493: LD_EXP 1
1497: NOT
1498: PPUSH
1499: LD_STRING 13a_
1501: PPUSH
1502: CALL 50755 0 3
1506: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1507: LD_ADDR_EXP 23
1511: PUSH
1512: LD_STRING Denis
1514: PPUSH
1515: LD_EXP 1
1519: NOT
1520: PPUSH
1521: LD_STRING 13a_
1523: PPUSH
1524: CALL 50755 0 3
1528: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1529: LD_ADDR_EXP 33
1533: PUSH
1534: LD_STRING DeltaDoctor
1536: PPUSH
1537: LD_EXP 1
1541: NOT
1542: PPUSH
1543: LD_STRING 13a_
1545: PPUSH
1546: CALL 50755 0 3
1550: ST_TO_ADDR
// if DeltaDoctor then
1551: LD_EXP 33
1555: IFFALSE 1573
// tmp := tmp ^ DeltaDoctor ;
1557: LD_ADDR_VAR 0 5
1561: PUSH
1562: LD_VAR 0 5
1566: PUSH
1567: LD_EXP 33
1571: ADD
1572: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1573: LD_ADDR_EXP 31
1577: PUSH
1578: LD_STRING Simms
1580: PPUSH
1581: LD_EXP 1
1585: NOT
1586: PPUSH
1587: LD_STRING 13a_
1589: PPUSH
1590: CALL 50755 0 3
1594: ST_TO_ADDR
// if Simms then
1595: LD_EXP 31
1599: IFFALSE 1617
// tmp := tmp ^ Simms ;
1601: LD_ADDR_VAR 0 5
1605: PUSH
1606: LD_VAR 0 5
1610: PUSH
1611: LD_EXP 31
1615: ADD
1616: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1617: LD_ADDR_EXP 29
1621: PUSH
1622: LD_STRING Frank
1624: PPUSH
1625: LD_EXP 1
1629: NOT
1630: PPUSH
1631: LD_STRING 13a_
1633: PPUSH
1634: CALL 50755 0 3
1638: ST_TO_ADDR
// if Frank then
1639: LD_EXP 29
1643: IFFALSE 1661
// tmp := tmp ^ Frank ;
1645: LD_ADDR_VAR 0 5
1649: PUSH
1650: LD_VAR 0 5
1654: PUSH
1655: LD_EXP 29
1659: ADD
1660: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1661: LD_ADDR_EXP 36
1665: PUSH
1666: LD_STRING Kirilenkova
1668: PPUSH
1669: LD_EXP 1
1673: NOT
1674: PPUSH
1675: LD_STRING 13a_
1677: PPUSH
1678: CALL 50755 0 3
1682: ST_TO_ADDR
// if Kirilenkova then
1683: LD_EXP 36
1687: IFFALSE 1705
// tmp := tmp ^ Kirilenkova ;
1689: LD_ADDR_VAR 0 5
1693: PUSH
1694: LD_VAR 0 5
1698: PUSH
1699: LD_EXP 36
1703: ADD
1704: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1705: LD_ADDR_EXP 37
1709: PUSH
1710: LD_STRING Titov
1712: PPUSH
1713: LD_EXP 1
1717: NOT
1718: PPUSH
1719: LD_STRING 13a_
1721: PPUSH
1722: CALL 50755 0 3
1726: ST_TO_ADDR
// if Titov then
1727: LD_EXP 37
1731: IFFALSE 1749
// tmp := tmp ^ Titov ;
1733: LD_ADDR_VAR 0 5
1737: PUSH
1738: LD_VAR 0 5
1742: PUSH
1743: LD_EXP 37
1747: ADD
1748: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1749: LD_ADDR_EXP 38
1753: PUSH
1754: LD_STRING Fadeev
1756: PPUSH
1757: LD_EXP 1
1761: NOT
1762: PPUSH
1763: LD_STRING 13a_
1765: PPUSH
1766: CALL 50755 0 3
1770: ST_TO_ADDR
// if Fadeev then
1771: LD_EXP 38
1775: IFFALSE 1793
// tmp := tmp ^ Fadeev ;
1777: LD_ADDR_VAR 0 5
1781: PUSH
1782: LD_VAR 0 5
1786: PUSH
1787: LD_EXP 38
1791: ADD
1792: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1793: LD_ADDR_EXP 39
1797: PUSH
1798: LD_STRING Dolgov
1800: PPUSH
1801: LD_EXP 1
1805: NOT
1806: PPUSH
1807: LD_STRING 13a_
1809: PPUSH
1810: CALL 50755 0 3
1814: ST_TO_ADDR
// if Dolgov then
1815: LD_EXP 39
1819: IFFALSE 1837
// tmp := tmp ^ Dolgov ;
1821: LD_ADDR_VAR 0 5
1825: PUSH
1826: LD_VAR 0 5
1830: PUSH
1831: LD_EXP 39
1835: ADD
1836: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1837: LD_ADDR_EXP 40
1841: PUSH
1842: LD_STRING Petrosyan
1844: PPUSH
1845: LD_EXP 1
1849: NOT
1850: PPUSH
1851: LD_STRING 13a_
1853: PPUSH
1854: CALL 50755 0 3
1858: ST_TO_ADDR
// if Petrosyan then
1859: LD_EXP 40
1863: IFFALSE 1881
// tmp := tmp ^ Petrosyan ;
1865: LD_ADDR_VAR 0 5
1869: PUSH
1870: LD_VAR 0 5
1874: PUSH
1875: LD_EXP 40
1879: ADD
1880: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1881: LD_ADDR_EXP 41
1885: PUSH
1886: LD_STRING Scholtze
1888: PPUSH
1889: LD_EXP 1
1893: NOT
1894: PPUSH
1895: LD_STRING 13a_
1897: PPUSH
1898: CALL 50755 0 3
1902: ST_TO_ADDR
// if Scholtze then
1903: LD_EXP 41
1907: IFFALSE 1925
// tmp := tmp ^ Scholtze ;
1909: LD_ADDR_VAR 0 5
1913: PUSH
1914: LD_VAR 0 5
1918: PUSH
1919: LD_EXP 41
1923: ADD
1924: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
1925: LD_ADDR_EXP 42
1929: PUSH
1930: LD_STRING Oblukov
1932: PPUSH
1933: LD_EXP 1
1937: NOT
1938: PPUSH
1939: LD_STRING 13a_
1941: PPUSH
1942: CALL 50755 0 3
1946: ST_TO_ADDR
// if Oblukov then
1947: LD_EXP 42
1951: IFFALSE 1969
// tmp := tmp ^ Oblukov ;
1953: LD_ADDR_VAR 0 5
1957: PUSH
1958: LD_VAR 0 5
1962: PUSH
1963: LD_EXP 42
1967: ADD
1968: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
1969: LD_ADDR_EXP 43
1973: PUSH
1974: LD_STRING Kapitsova
1976: PPUSH
1977: LD_EXP 1
1981: NOT
1982: PPUSH
1983: LD_STRING 13a_
1985: PPUSH
1986: CALL 50755 0 3
1990: ST_TO_ADDR
// if Kapitsova then
1991: LD_EXP 43
1995: IFFALSE 2013
// tmp := tmp ^ Kapitsova ;
1997: LD_ADDR_VAR 0 5
2001: PUSH
2002: LD_VAR 0 5
2006: PUSH
2007: LD_EXP 43
2011: ADD
2012: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2013: LD_ADDR_EXP 44
2017: PUSH
2018: LD_STRING Lipshchin
2020: PPUSH
2021: LD_EXP 1
2025: NOT
2026: PPUSH
2027: LD_STRING 13a_
2029: PPUSH
2030: CALL 50755 0 3
2034: ST_TO_ADDR
// if Lipshchin then
2035: LD_EXP 44
2039: IFFALSE 2057
// tmp := tmp ^ Lipshchin ;
2041: LD_ADDR_VAR 0 5
2045: PUSH
2046: LD_VAR 0 5
2050: PUSH
2051: LD_EXP 44
2055: ADD
2056: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2057: LD_ADDR_EXP 45
2061: PUSH
2062: LD_STRING Petrovova
2064: PPUSH
2065: LD_EXP 1
2069: NOT
2070: PPUSH
2071: LD_STRING 13a_
2073: PPUSH
2074: CALL 50755 0 3
2078: ST_TO_ADDR
// if Petrovova then
2079: LD_EXP 45
2083: IFFALSE 2101
// tmp := tmp ^ Petrovova ;
2085: LD_ADDR_VAR 0 5
2089: PUSH
2090: LD_VAR 0 5
2094: PUSH
2095: LD_EXP 45
2099: ADD
2100: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2101: LD_ADDR_EXP 46
2105: PUSH
2106: LD_STRING Kovalyuk
2108: PPUSH
2109: LD_EXP 1
2113: NOT
2114: PPUSH
2115: LD_STRING 13a_
2117: PPUSH
2118: CALL 50755 0 3
2122: ST_TO_ADDR
// if Kovalyuk then
2123: LD_EXP 46
2127: IFFALSE 2145
// tmp := tmp ^ Kovalyuk ;
2129: LD_ADDR_VAR 0 5
2133: PUSH
2134: LD_VAR 0 5
2138: PUSH
2139: LD_EXP 46
2143: ADD
2144: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2145: LD_ADDR_EXP 47
2149: PUSH
2150: LD_STRING Kuzmov
2152: PPUSH
2153: LD_EXP 1
2157: NOT
2158: PPUSH
2159: LD_STRING 13a_
2161: PPUSH
2162: CALL 50755 0 3
2166: ST_TO_ADDR
// if Kuzmov then
2167: LD_EXP 47
2171: IFFALSE 2189
// tmp := tmp ^ Kuzmov ;
2173: LD_ADDR_VAR 0 5
2177: PUSH
2178: LD_VAR 0 5
2182: PUSH
2183: LD_EXP 47
2187: ADD
2188: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2189: LD_ADDR_EXP 48
2193: PUSH
2194: LD_STRING Karamazov
2196: PPUSH
2197: LD_EXP 1
2201: NOT
2202: PPUSH
2203: LD_STRING 13a_
2205: PPUSH
2206: CALL 50755 0 3
2210: ST_TO_ADDR
// if Karamazov then
2211: LD_EXP 48
2215: IFFALSE 2233
// tmp := tmp ^ Karamazov ;
2217: LD_ADDR_VAR 0 5
2221: PUSH
2222: LD_VAR 0 5
2226: PUSH
2227: LD_EXP 48
2231: ADD
2232: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2233: LD_ADDR_EXP 50
2237: PUSH
2238: LD_STRING Belkov
2240: PPUSH
2241: LD_EXP 1
2245: NOT
2246: PPUSH
2247: LD_STRING 13a_
2249: PPUSH
2250: CALL 50755 0 3
2254: ST_TO_ADDR
// if Belkov then
2255: LD_EXP 50
2259: IFFALSE 2277
// tmp := tmp ^ Belkov ;
2261: LD_ADDR_VAR 0 5
2265: PUSH
2266: LD_VAR 0 5
2270: PUSH
2271: LD_EXP 50
2275: ADD
2276: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2277: LD_ADDR_EXP 51
2281: PUSH
2282: LD_STRING Gnyevko
2284: PPUSH
2285: LD_EXP 1
2289: NOT
2290: PPUSH
2291: LD_STRING 13a_
2293: PPUSH
2294: CALL 50755 0 3
2298: ST_TO_ADDR
// if Gnyevko then
2299: LD_EXP 51
2303: IFFALSE 2321
// tmp := tmp ^ Gnyevko ;
2305: LD_ADDR_VAR 0 5
2309: PUSH
2310: LD_VAR 0 5
2314: PUSH
2315: LD_EXP 51
2319: ADD
2320: ST_TO_ADDR
// Connie = NewCharacter ( Coonie ) ;
2321: LD_ADDR_EXP 34
2325: PUSH
2326: LD_STRING Coonie
2328: PPUSH
2329: CALL_OW 25
2333: ST_TO_ADDR
// if not Lisa then
2334: LD_EXP 19
2338: NOT
2339: IFFALSE 2385
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2341: LD_ADDR_EXP 19
2345: PUSH
2346: LD_STRING Lisa
2348: PPUSH
2349: LD_EXP 1
2353: NOT
2354: PPUSH
2355: LD_STRING 13a_
2357: PPUSH
2358: CALL 50755 0 3
2362: ST_TO_ADDR
// if Lisa then
2363: LD_EXP 19
2367: IFFALSE 2385
// tmp := tmp ^ Lisa ;
2369: LD_ADDR_VAR 0 5
2373: PUSH
2374: LD_VAR 0 5
2378: PUSH
2379: LD_EXP 19
2383: ADD
2384: ST_TO_ADDR
// end ; if not Donaldson then
2385: LD_EXP 20
2389: NOT
2390: IFFALSE 2436
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2392: LD_ADDR_EXP 20
2396: PUSH
2397: LD_STRING Donaldson
2399: PPUSH
2400: LD_EXP 1
2404: NOT
2405: PPUSH
2406: LD_STRING 13a_
2408: PPUSH
2409: CALL 50755 0 3
2413: ST_TO_ADDR
// if Donaldson then
2414: LD_EXP 20
2418: IFFALSE 2436
// tmp := tmp ^ Donaldson ;
2420: LD_ADDR_VAR 0 5
2424: PUSH
2425: LD_VAR 0 5
2429: PUSH
2430: LD_EXP 20
2434: ADD
2435: ST_TO_ADDR
// end ; if not Bobby then
2436: LD_EXP 21
2440: NOT
2441: IFFALSE 2487
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2443: LD_ADDR_EXP 21
2447: PUSH
2448: LD_STRING Bobby
2450: PPUSH
2451: LD_EXP 1
2455: NOT
2456: PPUSH
2457: LD_STRING 13a_
2459: PPUSH
2460: CALL 50755 0 3
2464: ST_TO_ADDR
// if Bobby then
2465: LD_EXP 21
2469: IFFALSE 2487
// tmp := tmp ^ Bobby ;
2471: LD_ADDR_VAR 0 5
2475: PUSH
2476: LD_VAR 0 5
2480: PUSH
2481: LD_EXP 21
2485: ADD
2486: ST_TO_ADDR
// end ; if not Cyrus then
2487: LD_EXP 22
2491: NOT
2492: IFFALSE 2538
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2494: LD_ADDR_EXP 22
2498: PUSH
2499: LD_STRING Cyrus
2501: PPUSH
2502: LD_EXP 1
2506: NOT
2507: PPUSH
2508: LD_STRING 13a_
2510: PPUSH
2511: CALL 50755 0 3
2515: ST_TO_ADDR
// if Cyrus then
2516: LD_EXP 22
2520: IFFALSE 2538
// tmp := tmp ^ Cyrus ;
2522: LD_ADDR_VAR 0 5
2526: PUSH
2527: LD_VAR 0 5
2531: PUSH
2532: LD_EXP 22
2536: ADD
2537: ST_TO_ADDR
// end ; if not Brown then
2538: LD_EXP 24
2542: NOT
2543: IFFALSE 2589
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2545: LD_ADDR_EXP 24
2549: PUSH
2550: LD_STRING Brown
2552: PPUSH
2553: LD_EXP 1
2557: NOT
2558: PPUSH
2559: LD_STRING 13a_
2561: PPUSH
2562: CALL 50755 0 3
2566: ST_TO_ADDR
// if Brown then
2567: LD_EXP 24
2571: IFFALSE 2589
// tmp := tmp ^ Brown ;
2573: LD_ADDR_VAR 0 5
2577: PUSH
2578: LD_VAR 0 5
2582: PUSH
2583: LD_EXP 24
2587: ADD
2588: ST_TO_ADDR
// end ; if not Gladstone then
2589: LD_EXP 25
2593: NOT
2594: IFFALSE 2640
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2596: LD_ADDR_EXP 25
2600: PUSH
2601: LD_STRING Gladstone
2603: PPUSH
2604: LD_EXP 1
2608: NOT
2609: PPUSH
2610: LD_STRING 13a_
2612: PPUSH
2613: CALL 50755 0 3
2617: ST_TO_ADDR
// if Gladstone then
2618: LD_EXP 25
2622: IFFALSE 2640
// tmp := tmp ^ Gladstone ;
2624: LD_ADDR_VAR 0 5
2628: PUSH
2629: LD_VAR 0 5
2633: PUSH
2634: LD_EXP 25
2638: ADD
2639: ST_TO_ADDR
// end ; if not Cornel then
2640: LD_EXP 27
2644: NOT
2645: IFFALSE 2691
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2647: LD_ADDR_EXP 27
2651: PUSH
2652: LD_STRING Cornel
2654: PPUSH
2655: LD_EXP 1
2659: NOT
2660: PPUSH
2661: LD_STRING 13a_
2663: PPUSH
2664: CALL 50755 0 3
2668: ST_TO_ADDR
// if Cornel then
2669: LD_EXP 27
2673: IFFALSE 2691
// tmp := tmp ^ Cornel ;
2675: LD_ADDR_VAR 0 5
2679: PUSH
2680: LD_VAR 0 5
2684: PUSH
2685: LD_EXP 27
2689: ADD
2690: ST_TO_ADDR
// end ; if not Houten then
2691: LD_EXP 26
2695: NOT
2696: IFFALSE 2742
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2698: LD_ADDR_EXP 26
2702: PUSH
2703: LD_STRING Houten
2705: PPUSH
2706: LD_EXP 1
2710: NOT
2711: PPUSH
2712: LD_STRING 13a_
2714: PPUSH
2715: CALL 50755 0 3
2719: ST_TO_ADDR
// if Houten then
2720: LD_EXP 26
2724: IFFALSE 2742
// tmp := tmp ^ Houten ;
2726: LD_ADDR_VAR 0 5
2730: PUSH
2731: LD_VAR 0 5
2735: PUSH
2736: LD_EXP 26
2740: ADD
2741: ST_TO_ADDR
// end ; if not Gary then
2742: LD_EXP 28
2746: NOT
2747: IFFALSE 2793
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2749: LD_ADDR_EXP 28
2753: PUSH
2754: LD_STRING Gary
2756: PPUSH
2757: LD_EXP 1
2761: NOT
2762: PPUSH
2763: LD_STRING 13a_
2765: PPUSH
2766: CALL 50755 0 3
2770: ST_TO_ADDR
// if Gary then
2771: LD_EXP 28
2775: IFFALSE 2793
// tmp := tmp ^ Gary ;
2777: LD_ADDR_VAR 0 5
2781: PUSH
2782: LD_VAR 0 5
2786: PUSH
2787: LD_EXP 28
2791: ADD
2792: ST_TO_ADDR
// end ; if not Kikuchi then
2793: LD_EXP 30
2797: NOT
2798: IFFALSE 2844
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2800: LD_ADDR_EXP 30
2804: PUSH
2805: LD_STRING Kikuchi
2807: PPUSH
2808: LD_EXP 1
2812: NOT
2813: PPUSH
2814: LD_STRING 13a_
2816: PPUSH
2817: CALL 50755 0 3
2821: ST_TO_ADDR
// if Kikuchi then
2822: LD_EXP 30
2826: IFFALSE 2844
// tmp := tmp ^ Kikuchi ;
2828: LD_ADDR_VAR 0 5
2832: PUSH
2833: LD_VAR 0 5
2837: PUSH
2838: LD_EXP 30
2842: ADD
2843: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2844: LD_ADDR_VAR 0 5
2848: PUSH
2849: LD_VAR 0 5
2853: PUSH
2854: LD_STRING 13a_others
2856: PPUSH
2857: CALL_OW 31
2861: UNION
2862: ST_TO_ADDR
// tmp := tmp diff 0 ;
2863: LD_ADDR_VAR 0 5
2867: PUSH
2868: LD_VAR 0 5
2872: PUSH
2873: LD_INT 0
2875: DIFF
2876: ST_TO_ADDR
// if tmp < 15 then
2877: LD_VAR 0 5
2881: PUSH
2882: LD_INT 15
2884: LESS
2885: IFFALSE 2973
// for i = 15 downto tmp do
2887: LD_ADDR_VAR 0 2
2891: PUSH
2892: DOUBLE
2893: LD_INT 15
2895: INC
2896: ST_TO_ADDR
2897: LD_VAR 0 5
2901: PUSH
2902: FOR_DOWNTO
2903: IFFALSE 2971
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2905: LD_ADDR_OWVAR 21
2909: PUSH
2910: LD_INT 1
2912: PUSH
2913: LD_INT 3
2915: PUSH
2916: EMPTY
2917: LIST
2918: LIST
2919: PUSH
2920: LD_INT 1
2922: PPUSH
2923: LD_INT 2
2925: PPUSH
2926: CALL_OW 12
2930: ARRAY
2931: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
2932: LD_INT 0
2934: PPUSH
2935: LD_INT 1
2937: PPUSH
2938: LD_INT 4
2940: PPUSH
2941: CALL_OW 12
2945: PPUSH
2946: LD_INT 8
2948: PPUSH
2949: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2953: LD_ADDR_VAR 0 5
2957: PUSH
2958: LD_VAR 0 5
2962: PUSH
2963: CALL_OW 44
2967: ADD
2968: ST_TO_ADDR
// end ;
2969: GO 2902
2971: POP
2972: POP
// if not debug then
2973: LD_EXP 1
2977: NOT
2978: IFFALSE 3150
// selected = CharacterSelection (  , [ 15 , 14 , 13 ] [ Difficulty ] , [ 15 , 14 , 13 ] [ Difficulty ] , [ sel_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
2980: LD_ADDR_VAR 0 4
2984: PUSH
2985: LD_STRING 
2987: PPUSH
2988: LD_INT 15
2990: PUSH
2991: LD_INT 14
2993: PUSH
2994: LD_INT 13
2996: PUSH
2997: EMPTY
2998: LIST
2999: LIST
3000: LIST
3001: PUSH
3002: LD_OWVAR 67
3006: ARRAY
3007: PPUSH
3008: LD_INT 15
3010: PUSH
3011: LD_INT 14
3013: PUSH
3014: LD_INT 13
3016: PUSH
3017: EMPTY
3018: LIST
3019: LIST
3020: LIST
3021: PUSH
3022: LD_OWVAR 67
3026: ARRAY
3027: PPUSH
3028: LD_INT -5
3030: PUSH
3031: LD_EXP 17
3035: PUSH
3036: LD_EXP 49
3040: PUSH
3041: LD_EXP 18
3045: PUSH
3046: LD_EXP 32
3050: PUSH
3051: LD_EXP 23
3055: PUSH
3056: LD_EXP 35
3060: PUSH
3061: LD_INT -2
3063: PUSH
3064: LD_INT -3
3066: PUSH
3067: LD_INT -5
3069: PUSH
3070: EMPTY
3071: LIST
3072: LIST
3073: LIST
3074: LIST
3075: LIST
3076: LIST
3077: LIST
3078: LIST
3079: LIST
3080: LIST
3081: PUSH
3082: LD_VAR 0 5
3086: ADD
3087: PPUSH
3088: LD_INT 1
3090: PUSH
3091: LD_INT 4
3093: PUSH
3094: LD_INT 2
3096: PUSH
3097: LD_INT 1
3099: PUSH
3100: EMPTY
3101: LIST
3102: LIST
3103: PUSH
3104: LD_INT 3
3106: PUSH
3107: LD_INT 5
3109: PUSH
3110: LD_INT 0
3112: PUSH
3113: LD_INT 3
3115: PUSH
3116: EMPTY
3117: LIST
3118: LIST
3119: LIST
3120: PUSH
3121: LD_INT 9
3123: PUSH
3124: LD_INT 0
3126: PUSH
3127: LD_INT 3
3129: PUSH
3130: EMPTY
3131: LIST
3132: LIST
3133: LIST
3134: PUSH
3135: EMPTY
3136: LIST
3137: LIST
3138: LIST
3139: LIST
3140: LIST
3141: LIST
3142: PPUSH
3143: CALL_OW 42
3147: ST_TO_ADDR
3148: GO 3229
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ] ;
3150: LD_ADDR_VAR 0 4
3154: PUSH
3155: LD_EXP 37
3159: PUSH
3160: LD_EXP 38
3164: PUSH
3165: LD_EXP 39
3169: PUSH
3170: LD_EXP 40
3174: PUSH
3175: LD_EXP 41
3179: PUSH
3180: LD_EXP 42
3184: PUSH
3185: LD_EXP 43
3189: PUSH
3190: LD_EXP 44
3194: PUSH
3195: LD_EXP 45
3199: PUSH
3200: LD_EXP 46
3204: PUSH
3205: LD_EXP 47
3209: PUSH
3210: LD_EXP 48
3214: PUSH
3215: EMPTY
3216: LIST
3217: LIST
3218: LIST
3219: LIST
3220: LIST
3221: LIST
3222: LIST
3223: LIST
3224: LIST
3225: LIST
3226: LIST
3227: LIST
3228: ST_TO_ADDR
// uc_nation := 1 ;
3229: LD_ADDR_OWVAR 21
3233: PUSH
3234: LD_INT 1
3236: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3237: LD_INT 5
3239: PPUSH
3240: LD_INT 3
3242: PPUSH
3243: LD_INT 1
3245: PPUSH
3246: LD_INT 6
3248: PPUSH
3249: LD_INT 100
3251: PPUSH
3252: CALL 55579 0 5
// veh := CreateVehicle ;
3256: LD_ADDR_VAR 0 3
3260: PUSH
3261: CALL_OW 45
3265: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3266: LD_VAR 0 3
3270: PPUSH
3271: LD_INT 7
3273: NEG
3274: PPUSH
3275: CALL_OW 242
// SetDir ( veh , 3 ) ;
3279: LD_VAR 0 3
3283: PPUSH
3284: LD_INT 3
3286: PPUSH
3287: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3291: LD_VAR 0 3
3295: PPUSH
3296: LD_INT 31
3298: PPUSH
3299: LD_INT 0
3301: PPUSH
3302: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3306: LD_EXP 17
3310: PPUSH
3311: LD_VAR 0 3
3315: PPUSH
3316: CALL_OW 52
// if Joan then
3320: LD_EXP 32
3324: IFFALSE 3396
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3326: LD_INT 3
3328: PPUSH
3329: LD_INT 3
3331: PPUSH
3332: LD_INT 1
3334: PPUSH
3335: LD_INT 11
3337: PPUSH
3338: LD_INT 100
3340: PPUSH
3341: CALL 55579 0 5
// veh := CreateVehicle ;
3345: LD_ADDR_VAR 0 3
3349: PUSH
3350: CALL_OW 45
3354: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3355: LD_VAR 0 3
3359: PPUSH
3360: LD_INT 3
3362: PPUSH
3363: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3367: LD_VAR 0 3
3371: PPUSH
3372: LD_INT 30
3374: PPUSH
3375: LD_INT 0
3377: PPUSH
3378: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3382: LD_EXP 32
3386: PPUSH
3387: LD_VAR 0 3
3391: PPUSH
3392: CALL_OW 52
// end ; if Roth then
3396: LD_EXP 18
3400: IFFALSE 3472
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3402: LD_INT 3
3404: PPUSH
3405: LD_INT 3
3407: PPUSH
3408: LD_INT 1
3410: PPUSH
3411: LD_INT 11
3413: PPUSH
3414: LD_INT 100
3416: PPUSH
3417: CALL 55579 0 5
// veh := CreateVehicle ;
3421: LD_ADDR_VAR 0 3
3425: PUSH
3426: CALL_OW 45
3430: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3431: LD_VAR 0 3
3435: PPUSH
3436: LD_INT 3
3438: PPUSH
3439: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3443: LD_VAR 0 3
3447: PPUSH
3448: LD_INT 30
3450: PPUSH
3451: LD_INT 0
3453: PPUSH
3454: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3458: LD_EXP 18
3462: PPUSH
3463: LD_VAR 0 3
3467: PPUSH
3468: CALL_OW 52
// end ; if Denis then
3472: LD_EXP 23
3476: IFFALSE 3548
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3478: LD_INT 5
3480: PPUSH
3481: LD_INT 3
3483: PPUSH
3484: LD_INT 1
3486: PPUSH
3487: LD_INT 9
3489: PPUSH
3490: LD_INT 100
3492: PPUSH
3493: CALL 55579 0 5
// veh := CreateVehicle ;
3497: LD_ADDR_VAR 0 3
3501: PUSH
3502: CALL_OW 45
3506: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3507: LD_VAR 0 3
3511: PPUSH
3512: LD_INT 3
3514: PPUSH
3515: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3519: LD_VAR 0 3
3523: PPUSH
3524: LD_INT 30
3526: PPUSH
3527: LD_INT 0
3529: PPUSH
3530: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3534: LD_EXP 23
3538: PPUSH
3539: LD_VAR 0 3
3543: PPUSH
3544: CALL_OW 52
// end ; uc_nation := 3 ;
3548: LD_ADDR_OWVAR 21
3552: PUSH
3553: LD_INT 3
3555: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3556: LD_INT 22
3558: PPUSH
3559: LD_INT 3
3561: PPUSH
3562: LD_INT 1
3564: PPUSH
3565: LD_INT 45
3567: PPUSH
3568: LD_INT 100
3570: PPUSH
3571: CALL 55579 0 5
// veh := CreateVehicle ;
3575: LD_ADDR_VAR 0 3
3579: PUSH
3580: CALL_OW 45
3584: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3585: LD_VAR 0 3
3589: PPUSH
3590: LD_INT 7
3592: NEG
3593: PPUSH
3594: CALL_OW 242
// SetDir ( veh , 3 ) ;
3598: LD_VAR 0 3
3602: PPUSH
3603: LD_INT 3
3605: PPUSH
3606: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3610: LD_VAR 0 3
3614: PPUSH
3615: LD_INT 31
3617: PPUSH
3618: LD_INT 0
3620: PPUSH
3621: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3625: LD_EXP 49
3629: PPUSH
3630: LD_VAR 0 3
3634: PPUSH
3635: CALL_OW 52
// if Gossudarov then
3639: LD_EXP 35
3643: IFFALSE 3730
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3645: LD_INT 22
3647: PPUSH
3648: LD_INT 3
3650: PPUSH
3651: LD_INT 1
3653: PPUSH
3654: LD_INT 51
3656: PPUSH
3657: LD_INT 100
3659: PPUSH
3660: CALL 55579 0 5
// veh := CreateVehicle ;
3664: LD_ADDR_VAR 0 3
3668: PUSH
3669: CALL_OW 45
3673: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3674: LD_VAR 0 3
3678: PPUSH
3679: LD_INT 3
3681: PPUSH
3682: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3686: LD_VAR 0 3
3690: PPUSH
3691: LD_INT 30
3693: PPUSH
3694: LD_INT 0
3696: PPUSH
3697: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3701: LD_EXP 35
3705: PPUSH
3706: LD_VAR 0 3
3710: PPUSH
3711: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3715: LD_VAR 0 3
3719: PPUSH
3720: LD_INT 1
3722: PPUSH
3723: LD_INT 100
3725: PPUSH
3726: CALL_OW 290
// end ; for i in selected do
3730: LD_ADDR_VAR 0 2
3734: PUSH
3735: LD_VAR 0 4
3739: PUSH
3740: FOR_IN
3741: IFFALSE 4299
// begin uc_nation := GetNation ( i ) ;
3743: LD_ADDR_OWVAR 21
3747: PUSH
3748: LD_VAR 0 2
3752: PPUSH
3753: CALL_OW 248
3757: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3758: LD_VAR 0 2
3762: PUSH
3763: LD_EXP 19
3767: PUSH
3768: LD_EXP 20
3772: PUSH
3773: LD_EXP 22
3777: PUSH
3778: LD_EXP 21
3782: PUSH
3783: EMPTY
3784: LIST
3785: LIST
3786: LIST
3787: LIST
3788: IN
3789: IFFALSE 3812
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3791: LD_INT 5
3793: PPUSH
3794: LD_INT 3
3796: PPUSH
3797: LD_INT 1
3799: PPUSH
3800: LD_INT 6
3802: PPUSH
3803: LD_INT 100
3805: PPUSH
3806: CALL 55579 0 5
3810: GO 4246
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3812: LD_VAR 0 2
3816: PUSH
3817: LD_EXP 42
3821: PUSH
3822: LD_EXP 47
3826: PUSH
3827: LD_EXP 45
3831: PUSH
3832: LD_EXP 37
3836: PUSH
3837: EMPTY
3838: LIST
3839: LIST
3840: LIST
3841: LIST
3842: IN
3843: IFFALSE 3874
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3845: LD_INT 24
3847: PPUSH
3848: LD_INT 1
3850: PPUSH
3851: LD_INT 1
3853: PPUSH
3854: LD_INT 46
3856: PPUSH
3857: LD_INT 65
3859: PPUSH
3860: LD_INT 75
3862: PPUSH
3863: CALL_OW 12
3867: PPUSH
3868: CALL 55579 0 5
3872: GO 4246
// if i = Karamazov then
3874: LD_VAR 0 2
3878: PUSH
3879: LD_EXP 48
3883: EQUAL
3884: IFFALSE 3907
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3886: LD_INT 22
3888: PPUSH
3889: LD_INT 3
3891: PPUSH
3892: LD_INT 1
3894: PPUSH
3895: LD_INT 52
3897: PPUSH
3898: LD_INT 100
3900: PPUSH
3901: CALL 55579 0 5
3905: GO 4246
// if i = Brown then
3907: LD_VAR 0 2
3911: PUSH
3912: LD_EXP 24
3916: EQUAL
3917: IFFALSE 3940
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
3919: LD_INT 3
3921: PPUSH
3922: LD_INT 3
3924: PPUSH
3925: LD_INT 1
3927: PPUSH
3928: LD_INT 13
3930: PPUSH
3931: LD_INT 100
3933: PPUSH
3934: CALL 55579 0 5
3938: GO 4246
// if uc_nation = nation_american then
3940: LD_OWVAR 21
3944: PUSH
3945: LD_INT 1
3947: EQUAL
3948: IFFALSE 4099
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
3950: LD_INT 3
3952: PUSH
3953: LD_INT 5
3955: PUSH
3956: LD_INT 5
3958: PUSH
3959: EMPTY
3960: LIST
3961: LIST
3962: LIST
3963: PUSH
3964: LD_OWVAR 21
3968: PUSH
3969: LD_INT 3
3971: MOD
3972: PUSH
3973: LD_INT 1
3975: PLUS
3976: ARRAY
3977: PPUSH
3978: LD_INT 1
3980: PUSH
3981: LD_INT 3
3983: PUSH
3984: LD_INT 1
3986: PUSH
3987: EMPTY
3988: LIST
3989: LIST
3990: LIST
3991: PUSH
3992: LD_OWVAR 21
3996: PUSH
3997: LD_INT 3
3999: MOD
4000: PUSH
4001: LD_INT 1
4003: PLUS
4004: ARRAY
4005: PPUSH
4006: LD_INT 1
4008: PPUSH
4009: LD_INT 11
4011: PUSH
4012: LD_INT 4
4014: PUSH
4015: LD_INT 5
4017: PUSH
4018: EMPTY
4019: LIST
4020: LIST
4021: LIST
4022: PUSH
4023: LD_INT 6
4025: PUSH
4026: LD_INT 7
4028: PUSH
4029: LD_INT 9
4031: PUSH
4032: EMPTY
4033: LIST
4034: LIST
4035: LIST
4036: PUSH
4037: LD_INT 6
4039: PUSH
4040: LD_INT 9
4042: PUSH
4043: LD_INT 12
4045: PUSH
4046: EMPTY
4047: LIST
4048: LIST
4049: LIST
4050: PUSH
4051: EMPTY
4052: LIST
4053: LIST
4054: LIST
4055: PUSH
4056: LD_OWVAR 21
4060: PUSH
4061: LD_INT 3
4063: MOD
4064: PUSH
4065: LD_INT 1
4067: PLUS
4068: ARRAY
4069: PUSH
4070: LD_INT 1
4072: PPUSH
4073: LD_INT 3
4075: PPUSH
4076: CALL_OW 12
4080: ARRAY
4081: PPUSH
4082: LD_INT 65
4084: PPUSH
4085: LD_INT 75
4087: PPUSH
4088: CALL_OW 12
4092: PPUSH
4093: CALL 55579 0 5
// end else
4097: GO 4246
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4099: LD_INT 22
4101: PUSH
4102: LD_INT 23
4104: PUSH
4105: LD_INT 23
4107: PUSH
4108: EMPTY
4109: LIST
4110: LIST
4111: LIST
4112: PUSH
4113: LD_OWVAR 21
4117: PUSH
4118: LD_INT 3
4120: MOD
4121: PUSH
4122: LD_INT 1
4124: PLUS
4125: ARRAY
4126: PPUSH
4127: LD_INT 1
4129: PUSH
4130: LD_INT 3
4132: PUSH
4133: LD_INT 1
4135: PUSH
4136: EMPTY
4137: LIST
4138: LIST
4139: LIST
4140: PUSH
4141: LD_OWVAR 21
4145: PUSH
4146: LD_INT 3
4148: MOD
4149: PUSH
4150: LD_INT 1
4152: PLUS
4153: ARRAY
4154: PPUSH
4155: LD_INT 1
4157: PPUSH
4158: LD_INT 45
4160: PUSH
4161: LD_INT 43
4163: PUSH
4164: LD_INT 44
4166: PUSH
4167: EMPTY
4168: LIST
4169: LIST
4170: LIST
4171: PUSH
4172: LD_INT 46
4174: PUSH
4175: LD_INT 45
4177: PUSH
4178: LD_INT 44
4180: PUSH
4181: EMPTY
4182: LIST
4183: LIST
4184: LIST
4185: PUSH
4186: LD_INT 46
4188: PUSH
4189: LD_INT 43
4191: PUSH
4192: LD_INT 45
4194: PUSH
4195: EMPTY
4196: LIST
4197: LIST
4198: LIST
4199: PUSH
4200: EMPTY
4201: LIST
4202: LIST
4203: LIST
4204: PUSH
4205: LD_OWVAR 21
4209: PUSH
4210: LD_INT 3
4212: MOD
4213: PUSH
4214: LD_INT 1
4216: PLUS
4217: ARRAY
4218: PUSH
4219: LD_INT 1
4221: PPUSH
4222: LD_INT 3
4224: PPUSH
4225: CALL_OW 12
4229: ARRAY
4230: PPUSH
4231: LD_INT 65
4233: PPUSH
4234: LD_INT 75
4236: PPUSH
4237: CALL_OW 12
4241: PPUSH
4242: CALL 55579 0 5
// end ; veh := CreateVehicle ;
4246: LD_ADDR_VAR 0 3
4250: PUSH
4251: CALL_OW 45
4255: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4256: LD_VAR 0 3
4260: PPUSH
4261: LD_INT 3
4263: PPUSH
4264: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4268: LD_VAR 0 3
4272: PPUSH
4273: LD_INT 30
4275: PPUSH
4276: LD_INT 0
4278: PPUSH
4279: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4283: LD_VAR 0 2
4287: PPUSH
4288: LD_VAR 0 3
4292: PPUSH
4293: CALL_OW 52
// end ;
4297: GO 3740
4299: POP
4300: POP
// if artifactArCaptured then
4301: LD_EXP 9
4305: IFFALSE 4391
// begin uc_nation := nation_american ;
4307: LD_ADDR_OWVAR 21
4311: PUSH
4312: LD_INT 1
4314: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4315: LD_INT 3
4317: PPUSH
4318: LD_INT 3
4320: PPUSH
4321: LD_INT 3
4323: PPUSH
4324: LD_INT 12
4326: PPUSH
4327: LD_INT 100
4329: PPUSH
4330: CALL 55579 0 5
// veh := CreateVehicle ;
4334: LD_ADDR_VAR 0 3
4338: PUSH
4339: CALL_OW 45
4343: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4344: LD_VAR 0 3
4348: PPUSH
4349: LD_INT 3
4351: PPUSH
4352: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4356: LD_VAR 0 3
4360: PPUSH
4361: LD_INT 198
4363: PPUSH
4364: LD_INT 22
4366: PPUSH
4367: LD_INT 0
4369: PPUSH
4370: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4374: LD_VAR 0 3
4378: PPUSH
4379: LD_INT 4
4381: PPUSH
4382: LD_INT 50
4384: PPUSH
4385: CALL_OW 290
// end else
4389: GO 4410
// begin CreateResourcesXY ( mat_artifact , 267 , 226 , 5 , false ) ;
4391: LD_INT 4
4393: PPUSH
4394: LD_INT 267
4396: PPUSH
4397: LD_INT 226
4399: PPUSH
4400: LD_INT 5
4402: PPUSH
4403: LD_INT 0
4405: PPUSH
4406: CALL_OW 58
// end ; uc_nation := nation_american ;
4410: LD_ADDR_OWVAR 21
4414: PUSH
4415: LD_INT 1
4417: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4418: LD_INT 3
4420: PPUSH
4421: LD_INT 3
4423: PPUSH
4424: LD_INT 3
4426: PPUSH
4427: LD_INT 12
4429: PPUSH
4430: LD_INT 100
4432: PPUSH
4433: CALL 55579 0 5
// veh := CreateVehicle ;
4437: LD_ADDR_VAR 0 3
4441: PUSH
4442: CALL_OW 45
4446: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4447: LD_VAR 0 3
4451: PPUSH
4452: LD_INT 3
4454: PPUSH
4455: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4459: LD_VAR 0 3
4463: PPUSH
4464: LD_INT 218
4466: PPUSH
4467: LD_INT 23
4469: PPUSH
4470: LD_INT 0
4472: PPUSH
4473: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4477: LD_VAR 0 3
4481: PPUSH
4482: LD_INT 4
4484: PPUSH
4485: LD_INT 30
4487: PPUSH
4488: CALL_OW 290
// uc_nation := nation_russian ;
4492: LD_ADDR_OWVAR 21
4496: PUSH
4497: LD_INT 3
4499: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4500: LD_INT 22
4502: PPUSH
4503: LD_INT 3
4505: PPUSH
4506: LD_INT 3
4508: PPUSH
4509: LD_INT 51
4511: PPUSH
4512: LD_INT 100
4514: PPUSH
4515: CALL 55579 0 5
// veh := CreateVehicle ;
4519: LD_ADDR_VAR 0 3
4523: PUSH
4524: CALL_OW 45
4528: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4529: LD_VAR 0 3
4533: PPUSH
4534: LD_INT 3
4536: PPUSH
4537: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4541: LD_VAR 0 3
4545: PPUSH
4546: LD_INT 214
4548: PPUSH
4549: LD_INT 20
4551: PPUSH
4552: LD_INT 0
4554: PPUSH
4555: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4559: LD_VAR 0 3
4563: PPUSH
4564: LD_INT 4
4566: PPUSH
4567: LD_INT 40
4569: PPUSH
4570: CALL_OW 290
// end ; end_of_file
4574: LD_VAR 0 1
4578: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
4579: LD_INT 0
4581: PPUSH
4582: PPUSH
4583: PPUSH
4584: PPUSH
4585: PPUSH
4586: PPUSH
4587: PPUSH
4588: PPUSH
4589: PPUSH
4590: PPUSH
// InitHc ;
4591: CALL_OW 19
// uc_side := 1 ;
4595: LD_ADDR_OWVAR 20
4599: PUSH
4600: LD_INT 1
4602: ST_TO_ADDR
// uc_nation := 1 ;
4603: LD_ADDR_OWVAR 21
4607: PUSH
4608: LD_INT 1
4610: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
4611: LD_ADDR_VAR 0 2
4615: PUSH
4616: LD_INT 22
4618: PUSH
4619: LD_INT 1
4621: PUSH
4622: EMPTY
4623: LIST
4624: LIST
4625: PUSH
4626: LD_INT 21
4628: PUSH
4629: LD_INT 3
4631: PUSH
4632: EMPTY
4633: LIST
4634: LIST
4635: PUSH
4636: EMPTY
4637: LIST
4638: LIST
4639: PPUSH
4640: CALL_OW 69
4644: PUSH
4645: FOR_IN
4646: IFFALSE 4662
// SetBLevel ( i , 10 ) ;
4648: LD_VAR 0 2
4652: PPUSH
4653: LD_INT 10
4655: PPUSH
4656: CALL_OW 241
4660: GO 4645
4662: POP
4663: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 7500 ) ;
4664: LD_INT 387
4666: PPUSH
4667: CALL_OW 274
4671: PPUSH
4672: LD_INT 1
4674: PPUSH
4675: LD_INT 7500
4677: PPUSH
4678: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
4682: LD_INT 387
4684: PPUSH
4685: CALL_OW 274
4689: PPUSH
4690: LD_INT 2
4692: PPUSH
4693: LD_INT 4000
4695: PPUSH
4696: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
4700: LD_INT 387
4702: PPUSH
4703: CALL_OW 274
4707: PPUSH
4708: LD_INT 3
4710: PPUSH
4711: LD_INT 50
4713: PPUSH
4714: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 5500 ) ;
4718: LD_INT 476
4720: PPUSH
4721: CALL_OW 274
4725: PPUSH
4726: LD_INT 1
4728: PPUSH
4729: LD_INT 5500
4731: PPUSH
4732: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
4736: LD_INT 476
4738: PPUSH
4739: CALL_OW 274
4743: PPUSH
4744: LD_INT 2
4746: PPUSH
4747: LD_INT 4000
4749: PPUSH
4750: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
4754: LD_INT 476
4756: PPUSH
4757: CALL_OW 274
4761: PPUSH
4762: LD_INT 3
4764: PPUSH
4765: LD_INT 10
4767: PPUSH
4768: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
4772: LD_ADDR_EXP 52
4776: PUSH
4777: LD_STRING Powell
4779: PPUSH
4780: CALL_OW 25
4784: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
4785: LD_EXP 52
4789: PPUSH
4790: LD_INT 387
4792: PPUSH
4793: CALL_OW 52
// tmp := [ ] ;
4797: LD_ADDR_VAR 0 6
4801: PUSH
4802: EMPTY
4803: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
4804: LD_ADDR_EXP 19
4808: PUSH
4809: LD_STRING Lisa
4811: PPUSH
4812: LD_EXP 1
4816: NOT
4817: PPUSH
4818: LD_STRING 12p_
4820: PPUSH
4821: CALL 50755 0 3
4825: ST_TO_ADDR
// if Lisa then
4826: LD_EXP 19
4830: IFFALSE 4848
// tmp := tmp ^ Lisa ;
4832: LD_ADDR_VAR 0 6
4836: PUSH
4837: LD_VAR 0 6
4841: PUSH
4842: LD_EXP 19
4846: ADD
4847: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
4848: LD_ADDR_EXP 20
4852: PUSH
4853: LD_STRING Donaldson
4855: PPUSH
4856: LD_EXP 1
4860: NOT
4861: PPUSH
4862: LD_STRING 12p_
4864: PPUSH
4865: CALL 50755 0 3
4869: ST_TO_ADDR
// if Donaldson then
4870: LD_EXP 20
4874: IFFALSE 4892
// tmp := tmp ^ Donaldson ;
4876: LD_ADDR_VAR 0 6
4880: PUSH
4881: LD_VAR 0 6
4885: PUSH
4886: LD_EXP 20
4890: ADD
4891: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
4892: LD_ADDR_EXP 21
4896: PUSH
4897: LD_STRING Bobby
4899: PPUSH
4900: LD_EXP 1
4904: NOT
4905: PPUSH
4906: LD_STRING 12p_
4908: PPUSH
4909: CALL 50755 0 3
4913: ST_TO_ADDR
// if Bobby then
4914: LD_EXP 21
4918: IFFALSE 4936
// tmp := tmp ^ Bobby ;
4920: LD_ADDR_VAR 0 6
4924: PUSH
4925: LD_VAR 0 6
4929: PUSH
4930: LD_EXP 21
4934: ADD
4935: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
4936: LD_ADDR_EXP 22
4940: PUSH
4941: LD_STRING Cyrus
4943: PPUSH
4944: LD_EXP 1
4948: NOT
4949: PPUSH
4950: LD_STRING 12p_
4952: PPUSH
4953: CALL 50755 0 3
4957: ST_TO_ADDR
// if Cyrus then
4958: LD_EXP 22
4962: IFFALSE 4980
// tmp := tmp ^ Cyrus ;
4964: LD_ADDR_VAR 0 6
4968: PUSH
4969: LD_VAR 0 6
4973: PUSH
4974: LD_EXP 22
4978: ADD
4979: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
4980: LD_ADDR_EXP 24
4984: PUSH
4985: LD_STRING Brown
4987: PPUSH
4988: LD_EXP 1
4992: NOT
4993: PPUSH
4994: LD_STRING 12p_
4996: PPUSH
4997: CALL 50755 0 3
5001: ST_TO_ADDR
// if Brown then
5002: LD_EXP 24
5006: IFFALSE 5024
// tmp := tmp ^ Brown ;
5008: LD_ADDR_VAR 0 6
5012: PUSH
5013: LD_VAR 0 6
5017: PUSH
5018: LD_EXP 24
5022: ADD
5023: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5024: LD_ADDR_EXP 25
5028: PUSH
5029: LD_STRING Gladstone
5031: PPUSH
5032: LD_EXP 1
5036: NOT
5037: PPUSH
5038: LD_STRING 12p_
5040: PPUSH
5041: CALL 50755 0 3
5045: ST_TO_ADDR
// if Gladstone then
5046: LD_EXP 25
5050: IFFALSE 5068
// tmp := tmp ^ Gladstone ;
5052: LD_ADDR_VAR 0 6
5056: PUSH
5057: LD_VAR 0 6
5061: PUSH
5062: LD_EXP 25
5066: ADD
5067: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5068: LD_ADDR_EXP 26
5072: PUSH
5073: LD_STRING Houten
5075: PPUSH
5076: LD_EXP 1
5080: NOT
5081: PPUSH
5082: LD_STRING 12p_
5084: PPUSH
5085: CALL 50755 0 3
5089: ST_TO_ADDR
// if Houten then
5090: LD_EXP 26
5094: IFFALSE 5112
// tmp := tmp ^ Houten ;
5096: LD_ADDR_VAR 0 6
5100: PUSH
5101: LD_VAR 0 6
5105: PUSH
5106: LD_EXP 26
5110: ADD
5111: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5112: LD_ADDR_EXP 27
5116: PUSH
5117: LD_STRING Cornel
5119: PPUSH
5120: LD_EXP 1
5124: NOT
5125: PPUSH
5126: LD_STRING 12p_
5128: PPUSH
5129: CALL 50755 0 3
5133: ST_TO_ADDR
// if Cornel then
5134: LD_EXP 27
5138: IFFALSE 5156
// tmp := tmp ^ Cornel ;
5140: LD_ADDR_VAR 0 6
5144: PUSH
5145: LD_VAR 0 6
5149: PUSH
5150: LD_EXP 27
5154: ADD
5155: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5156: LD_ADDR_EXP 28
5160: PUSH
5161: LD_STRING Gary
5163: PPUSH
5164: LD_EXP 1
5168: NOT
5169: PPUSH
5170: LD_STRING 12p_
5172: PPUSH
5173: CALL 50755 0 3
5177: ST_TO_ADDR
// if Gary then
5178: LD_EXP 28
5182: IFFALSE 5200
// tmp := tmp ^ Gary ;
5184: LD_ADDR_VAR 0 6
5188: PUSH
5189: LD_VAR 0 6
5193: PUSH
5194: LD_EXP 28
5198: ADD
5199: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5200: LD_ADDR_EXP 30
5204: PUSH
5205: LD_STRING Kikuchi
5207: PPUSH
5208: LD_EXP 1
5212: NOT
5213: PPUSH
5214: LD_STRING 12p_
5216: PPUSH
5217: CALL 50755 0 3
5221: ST_TO_ADDR
// if Kikuchi then
5222: LD_EXP 30
5226: IFFALSE 5244
// tmp := tmp ^ Kikuchi ;
5228: LD_ADDR_VAR 0 6
5232: PUSH
5233: LD_VAR 0 6
5237: PUSH
5238: LD_EXP 30
5242: ADD
5243: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5244: LD_ADDR_VAR 0 6
5248: PUSH
5249: LD_VAR 0 6
5253: PUSH
5254: LD_STRING 12p_others
5256: PPUSH
5257: CALL_OW 31
5261: UNION
5262: ST_TO_ADDR
// if tmp < 36 then
5263: LD_VAR 0 6
5267: PUSH
5268: LD_INT 36
5270: LESS
5271: IFFALSE 5338
// for i = 1 to 36 - tmp do
5273: LD_ADDR_VAR 0 2
5277: PUSH
5278: DOUBLE
5279: LD_INT 1
5281: DEC
5282: ST_TO_ADDR
5283: LD_INT 36
5285: PUSH
5286: LD_VAR 0 6
5290: MINUS
5291: PUSH
5292: FOR_TO
5293: IFFALSE 5336
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5295: LD_INT 1
5297: PPUSH
5298: LD_VAR 0 2
5302: PUSH
5303: LD_INT 4
5305: MOD
5306: PUSH
5307: LD_INT 1
5309: PLUS
5310: PPUSH
5311: LD_INT 10
5313: PPUSH
5314: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5318: LD_ADDR_VAR 0 6
5322: PUSH
5323: LD_VAR 0 6
5327: PUSH
5328: CALL_OW 44
5332: ADD
5333: ST_TO_ADDR
// end ;
5334: GO 5292
5336: POP
5337: POP
// for i in tmp do
5338: LD_ADDR_VAR 0 2
5342: PUSH
5343: LD_VAR 0 6
5347: PUSH
5348: FOR_IN
5349: IFFALSE 5374
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5351: LD_VAR 0 2
5355: PPUSH
5356: LD_INT 62
5358: PPUSH
5359: LD_INT 93
5361: PPUSH
5362: LD_INT 9
5364: PPUSH
5365: LD_INT 0
5367: PPUSH
5368: CALL_OW 50
5372: GO 5348
5374: POP
5375: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
5376: LD_ADDR_EXP 90
5380: PUSH
5381: LD_EXP 90
5385: PPUSH
5386: LD_INT 4
5388: PPUSH
5389: LD_INT 22
5391: PUSH
5392: LD_INT 1
5394: PUSH
5395: EMPTY
5396: LIST
5397: LIST
5398: PPUSH
5399: CALL_OW 69
5403: PUSH
5404: LD_EXP 52
5408: DIFF
5409: PPUSH
5410: CALL_OW 1
5414: ST_TO_ADDR
// uc_side := 0 ;
5415: LD_ADDR_OWVAR 20
5419: PUSH
5420: LD_INT 0
5422: ST_TO_ADDR
// uc_nation := 0 ;
5423: LD_ADDR_OWVAR 21
5427: PUSH
5428: LD_INT 0
5430: ST_TO_ADDR
// for i = 1 to 4 do
5431: LD_ADDR_VAR 0 2
5435: PUSH
5436: DOUBLE
5437: LD_INT 1
5439: DEC
5440: ST_TO_ADDR
5441: LD_INT 4
5443: PUSH
5444: FOR_TO
5445: IFFALSE 5476
// begin InitHc ;
5447: CALL_OW 19
// hc_class := class_apeman ;
5451: LD_ADDR_OWVAR 28
5455: PUSH
5456: LD_INT 12
5458: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
5459: CALL_OW 44
5463: PPUSH
5464: LD_INT 11
5466: PPUSH
5467: LD_INT 0
5469: PPUSH
5470: CALL_OW 49
// end ;
5474: GO 5444
5476: POP
5477: POP
// end ;
5478: LD_VAR 0 1
5482: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
5483: LD_EXP 4
5487: NOT
5488: PUSH
5489: LD_INT 4
5491: PPUSH
5492: LD_INT 1
5494: PPUSH
5495: CALL 45829 0 2
5499: NOT
5500: AND
5501: IFFALSE 6273
5503: GO 5505
5505: DISABLE
5506: LD_INT 0
5508: PPUSH
5509: PPUSH
5510: PPUSH
// begin enable ;
5511: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
5512: LD_INT 22
5514: PUSH
5515: LD_INT 1
5517: PUSH
5518: EMPTY
5519: LIST
5520: LIST
5521: PUSH
5522: LD_INT 23
5524: PUSH
5525: LD_INT 1
5527: PUSH
5528: EMPTY
5529: LIST
5530: LIST
5531: PUSH
5532: LD_INT 30
5534: PUSH
5535: LD_INT 3
5537: PUSH
5538: EMPTY
5539: LIST
5540: LIST
5541: PUSH
5542: EMPTY
5543: LIST
5544: LIST
5545: LIST
5546: PPUSH
5547: CALL_OW 69
5551: NOT
5552: IFFALSE 5556
// exit ;
5554: GO 6273
// if Prob ( 40 ) then
5556: LD_INT 40
5558: PPUSH
5559: CALL_OW 13
5563: IFFALSE 5690
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5565: LD_INT 4
5567: PPUSH
5568: LD_INT 5
5570: PUSH
5571: LD_INT 1
5573: PUSH
5574: LD_INT 2
5576: PUSH
5577: LD_INT 7
5579: PUSH
5580: EMPTY
5581: LIST
5582: LIST
5583: LIST
5584: LIST
5585: PUSH
5586: LD_INT 5
5588: PUSH
5589: LD_INT 1
5591: PUSH
5592: LD_INT 2
5594: PUSH
5595: LD_INT 7
5597: PUSH
5598: EMPTY
5599: LIST
5600: LIST
5601: LIST
5602: LIST
5603: PUSH
5604: LD_INT 5
5606: PUSH
5607: LD_INT 1
5609: PUSH
5610: LD_INT 2
5612: PUSH
5613: LD_INT 7
5615: PUSH
5616: EMPTY
5617: LIST
5618: LIST
5619: LIST
5620: LIST
5621: PUSH
5622: LD_INT 5
5624: PUSH
5625: LD_INT 1
5627: PUSH
5628: LD_INT 2
5630: PUSH
5631: LD_INT 6
5633: PUSH
5634: EMPTY
5635: LIST
5636: LIST
5637: LIST
5638: LIST
5639: PUSH
5640: LD_INT 5
5642: PUSH
5643: LD_INT 1
5645: PUSH
5646: LD_INT 2
5648: PUSH
5649: LD_INT 6
5651: PUSH
5652: EMPTY
5653: LIST
5654: LIST
5655: LIST
5656: LIST
5657: PUSH
5658: LD_INT 5
5660: PUSH
5661: LD_INT 1
5663: PUSH
5664: LD_INT 2
5666: PUSH
5667: LD_INT 6
5669: PUSH
5670: EMPTY
5671: LIST
5672: LIST
5673: LIST
5674: LIST
5675: PUSH
5676: EMPTY
5677: LIST
5678: LIST
5679: LIST
5680: LIST
5681: LIST
5682: LIST
5683: PPUSH
5684: CALL 44411 0 2
// end else
5688: GO 5813
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5690: LD_INT 4
5692: PPUSH
5693: LD_INT 5
5695: PUSH
5696: LD_INT 1
5698: PUSH
5699: LD_INT 2
5701: PUSH
5702: LD_INT 7
5704: PUSH
5705: EMPTY
5706: LIST
5707: LIST
5708: LIST
5709: LIST
5710: PUSH
5711: LD_INT 5
5713: PUSH
5714: LD_INT 1
5716: PUSH
5717: LD_INT 2
5719: PUSH
5720: LD_INT 9
5722: PUSH
5723: EMPTY
5724: LIST
5725: LIST
5726: LIST
5727: LIST
5728: PUSH
5729: LD_INT 5
5731: PUSH
5732: LD_INT 1
5734: PUSH
5735: LD_INT 2
5737: PUSH
5738: LD_INT 9
5740: PUSH
5741: EMPTY
5742: LIST
5743: LIST
5744: LIST
5745: LIST
5746: PUSH
5747: LD_INT 5
5749: PUSH
5750: LD_INT 1
5752: PUSH
5753: LD_INT 2
5755: PUSH
5756: LD_INT 6
5758: PUSH
5759: EMPTY
5760: LIST
5761: LIST
5762: LIST
5763: LIST
5764: PUSH
5765: LD_INT 5
5767: PUSH
5768: LD_INT 1
5770: PUSH
5771: LD_INT 2
5773: PUSH
5774: LD_INT 6
5776: PUSH
5777: EMPTY
5778: LIST
5779: LIST
5780: LIST
5781: LIST
5782: PUSH
5783: LD_INT 5
5785: PUSH
5786: LD_INT 1
5788: PUSH
5789: LD_INT 2
5791: PUSH
5792: LD_INT 6
5794: PUSH
5795: EMPTY
5796: LIST
5797: LIST
5798: LIST
5799: LIST
5800: PUSH
5801: EMPTY
5802: LIST
5803: LIST
5804: LIST
5805: LIST
5806: LIST
5807: LIST
5808: PPUSH
5809: CALL 44411 0 2
// end ; repeat wait ( 0 0$1 ) ;
5813: LD_INT 35
5815: PPUSH
5816: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
5820: LD_INT 4
5822: PPUSH
5823: LD_INT 1
5825: PPUSH
5826: CALL 45829 0 2
5830: PUSH
5831: LD_INT 6
5833: GREATEREQUAL
5834: IFFALSE 5813
// wait ( 0 0$30 ) ;
5836: LD_INT 1050
5838: PPUSH
5839: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
5843: LD_ADDR_VAR 0 2
5847: PUSH
5848: LD_INT 4
5850: PPUSH
5851: LD_INT 1
5853: PPUSH
5854: CALL 45829 0 2
5858: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
5859: LD_ADDR_EXP 109
5863: PUSH
5864: LD_EXP 109
5868: PPUSH
5869: LD_INT 4
5871: PPUSH
5872: LD_EXP 109
5876: PUSH
5877: LD_INT 4
5879: ARRAY
5880: PUSH
5881: LD_VAR 0 2
5885: DIFF
5886: PPUSH
5887: CALL_OW 1
5891: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5892: LD_ADDR_VAR 0 3
5896: PUSH
5897: LD_INT 0
5899: PPUSH
5900: LD_INT 2
5902: PPUSH
5903: CALL_OW 12
5907: ST_TO_ADDR
// if target then
5908: LD_VAR 0 3
5912: IFFALSE 6040
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5914: LD_ADDR_VAR 0 2
5918: PUSH
5919: LD_VAR 0 2
5923: PPUSH
5924: LD_INT 24
5926: PUSH
5927: LD_INT 250
5929: PUSH
5930: EMPTY
5931: LIST
5932: LIST
5933: PPUSH
5934: CALL_OW 72
5938: ST_TO_ADDR
// for i in tmp do
5939: LD_ADDR_VAR 0 1
5943: PUSH
5944: LD_VAR 0 2
5948: PUSH
5949: FOR_IN
5950: IFFALSE 5990
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
5952: LD_VAR 0 1
5956: PPUSH
5957: LD_INT 114
5959: PPUSH
5960: LD_INT 108
5962: PPUSH
5963: CALL_OW 297
5967: PUSH
5968: LD_INT 9
5970: GREATER
5971: IFFALSE 5988
// ComMoveXY ( i , 114 , 108 ) ;
5973: LD_VAR 0 1
5977: PPUSH
5978: LD_INT 114
5980: PPUSH
5981: LD_INT 108
5983: PPUSH
5984: CALL_OW 111
5988: GO 5949
5990: POP
5991: POP
// wait ( 0 0$1 ) ;
5992: LD_INT 35
5994: PPUSH
5995: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
5999: LD_VAR 0 2
6003: PPUSH
6004: LD_INT 92
6006: PUSH
6007: LD_INT 114
6009: PUSH
6010: LD_INT 108
6012: PUSH
6013: LD_INT 9
6015: PUSH
6016: EMPTY
6017: LIST
6018: LIST
6019: LIST
6020: LIST
6021: PPUSH
6022: CALL_OW 72
6026: PUSH
6027: LD_VAR 0 2
6031: PUSH
6032: LD_INT 1
6034: MINUS
6035: GREATEREQUAL
6036: IFFALSE 5914
// end else
6038: GO 6164
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6040: LD_ADDR_VAR 0 2
6044: PUSH
6045: LD_VAR 0 2
6049: PPUSH
6050: LD_INT 24
6052: PUSH
6053: LD_INT 250
6055: PUSH
6056: EMPTY
6057: LIST
6058: LIST
6059: PPUSH
6060: CALL_OW 72
6064: ST_TO_ADDR
// for i in tmp do
6065: LD_ADDR_VAR 0 1
6069: PUSH
6070: LD_VAR 0 2
6074: PUSH
6075: FOR_IN
6076: IFFALSE 6116
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6078: LD_VAR 0 1
6082: PPUSH
6083: LD_INT 129
6085: PPUSH
6086: LD_INT 139
6088: PPUSH
6089: CALL_OW 297
6093: PUSH
6094: LD_INT 9
6096: GREATER
6097: IFFALSE 6114
// ComMoveXY ( i , 129 , 139 ) ;
6099: LD_VAR 0 1
6103: PPUSH
6104: LD_INT 129
6106: PPUSH
6107: LD_INT 139
6109: PPUSH
6110: CALL_OW 111
6114: GO 6075
6116: POP
6117: POP
// wait ( 0 0$1 ) ;
6118: LD_INT 35
6120: PPUSH
6121: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
6125: LD_VAR 0 2
6129: PPUSH
6130: LD_INT 92
6132: PUSH
6133: LD_INT 129
6135: PUSH
6136: LD_INT 139
6138: PUSH
6139: LD_INT 9
6141: PUSH
6142: EMPTY
6143: LIST
6144: LIST
6145: LIST
6146: LIST
6147: PPUSH
6148: CALL_OW 72
6152: PUSH
6153: LD_VAR 0 2
6157: PUSH
6158: LD_INT 1
6160: MINUS
6161: GREATEREQUAL
6162: IFFALSE 6040
// end ; repeat wait ( 0 0$1 ) ;
6164: LD_INT 35
6166: PPUSH
6167: CALL_OW 67
// for i in tmp do
6171: LD_ADDR_VAR 0 1
6175: PUSH
6176: LD_VAR 0 2
6180: PUSH
6181: FOR_IN
6182: IFFALSE 6264
// begin if GetLives ( i ) > 251 then
6184: LD_VAR 0 1
6188: PPUSH
6189: CALL_OW 256
6193: PUSH
6194: LD_INT 251
6196: GREATER
6197: IFFALSE 6235
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6199: LD_VAR 0 1
6203: PPUSH
6204: LD_INT 81
6206: PUSH
6207: LD_INT 1
6209: PUSH
6210: EMPTY
6211: LIST
6212: LIST
6213: PPUSH
6214: CALL_OW 69
6218: PPUSH
6219: LD_VAR 0 1
6223: PPUSH
6224: CALL_OW 74
6228: PPUSH
6229: CALL_OW 115
6233: GO 6262
// if IsDead ( i ) then
6235: LD_VAR 0 1
6239: PPUSH
6240: CALL_OW 301
6244: IFFALSE 6262
// tmp := tmp diff i ;
6246: LD_ADDR_VAR 0 2
6250: PUSH
6251: LD_VAR 0 2
6255: PUSH
6256: LD_VAR 0 1
6260: DIFF
6261: ST_TO_ADDR
// end ;
6262: GO 6181
6264: POP
6265: POP
// until not tmp ;
6266: LD_VAR 0 2
6270: NOT
6271: IFFALSE 6164
// end ;
6273: PPOPN 3
6275: END
// every 30 30$00 trigger not americanDestroyed do
6276: LD_EXP 4
6280: NOT
6281: IFFALSE 6346
6283: GO 6285
6285: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 10 10$00 ] [ Difficulty ] ) ;
6286: LD_INT 63000
6288: PUSH
6289: LD_INT 42000
6291: PUSH
6292: LD_INT 21000
6294: PUSH
6295: EMPTY
6296: LIST
6297: LIST
6298: LIST
6299: PUSH
6300: LD_OWVAR 67
6304: ARRAY
6305: PPUSH
6306: CALL_OW 67
// if americanDestroyed then
6310: LD_EXP 4
6314: IFFALSE 6318
// exit ;
6316: GO 6346
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6318: LD_INT 4
6320: PPUSH
6321: LD_INT 5
6323: PUSH
6324: LD_INT 3
6326: PUSH
6327: LD_INT 1
6329: PUSH
6330: LD_INT 8
6332: PUSH
6333: EMPTY
6334: LIST
6335: LIST
6336: LIST
6337: LIST
6338: PUSH
6339: EMPTY
6340: LIST
6341: PPUSH
6342: CALL 44411 0 2
// end ; end_of_file
6346: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6347: LD_INT 0
6349: PPUSH
6350: PPUSH
6351: PPUSH
6352: PPUSH
6353: PPUSH
// side := 2 ;
6354: LD_ADDR_VAR 0 5
6358: PUSH
6359: LD_INT 2
6361: ST_TO_ADDR
// InitHc ;
6362: CALL_OW 19
// uc_side := side ;
6366: LD_ADDR_OWVAR 20
6370: PUSH
6371: LD_VAR 0 5
6375: ST_TO_ADDR
// uc_nation := 2 ;
6376: LD_ADDR_OWVAR 21
6380: PUSH
6381: LD_INT 2
6383: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
6384: LD_ADDR_VAR 0 2
6388: PUSH
6389: LD_INT 22
6391: PUSH
6392: LD_INT 2
6394: PUSH
6395: EMPTY
6396: LIST
6397: LIST
6398: PUSH
6399: LD_INT 21
6401: PUSH
6402: LD_INT 3
6404: PUSH
6405: EMPTY
6406: LIST
6407: LIST
6408: PUSH
6409: EMPTY
6410: LIST
6411: LIST
6412: PPUSH
6413: CALL_OW 69
6417: PUSH
6418: FOR_IN
6419: IFFALSE 6435
// SetBLevel ( i , 10 ) ;
6421: LD_VAR 0 2
6425: PPUSH
6426: LD_INT 10
6428: PPUSH
6429: CALL_OW 241
6433: GO 6418
6435: POP
6436: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6437: LD_ADDR_VAR 0 4
6441: PUSH
6442: LD_INT 22
6444: PUSH
6445: LD_VAR 0 5
6449: PUSH
6450: EMPTY
6451: LIST
6452: LIST
6453: PUSH
6454: LD_INT 30
6456: PUSH
6457: LD_INT 32
6459: PUSH
6460: EMPTY
6461: LIST
6462: LIST
6463: PUSH
6464: LD_INT 58
6466: PUSH
6467: EMPTY
6468: LIST
6469: PUSH
6470: EMPTY
6471: LIST
6472: LIST
6473: LIST
6474: PPUSH
6475: CALL_OW 69
6479: ST_TO_ADDR
// for i = 1 to 10 do
6480: LD_ADDR_VAR 0 2
6484: PUSH
6485: DOUBLE
6486: LD_INT 1
6488: DEC
6489: ST_TO_ADDR
6490: LD_INT 10
6492: PUSH
6493: FOR_TO
6494: IFFALSE 6566
// begin uc_nation := nation_nature ;
6496: LD_ADDR_OWVAR 21
6500: PUSH
6501: LD_INT 0
6503: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6504: LD_ADDR_OWVAR 28
6508: PUSH
6509: LD_INT 15
6511: ST_TO_ADDR
// hc_gallery :=  ;
6512: LD_ADDR_OWVAR 33
6516: PUSH
6517: LD_STRING 
6519: ST_TO_ADDR
// hc_name :=  ;
6520: LD_ADDR_OWVAR 26
6524: PUSH
6525: LD_STRING 
6527: ST_TO_ADDR
// un := CreateHuman ;
6528: LD_ADDR_VAR 0 3
6532: PUSH
6533: CALL_OW 44
6537: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
6538: LD_VAR 0 3
6542: PPUSH
6543: LD_VAR 0 4
6547: PUSH
6548: LD_VAR 0 4
6552: PUSH
6553: LD_VAR 0 2
6557: MINUS
6558: ARRAY
6559: PPUSH
6560: CALL_OW 52
// end ;
6564: GO 6493
6566: POP
6567: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
6568: LD_INT 503
6570: PPUSH
6571: LD_INT 27
6573: PPUSH
6574: LD_STRING 
6576: PPUSH
6577: LD_INT 8
6579: PUSH
6580: LD_INT 9
6582: PUSH
6583: LD_INT 10
6585: PUSH
6586: EMPTY
6587: LIST
6588: LIST
6589: LIST
6590: PUSH
6591: LD_OWVAR 67
6595: ARRAY
6596: PPUSH
6597: LD_INT 3000
6599: PUSH
6600: LD_INT 500
6602: PUSH
6603: LD_INT 150
6605: PUSH
6606: EMPTY
6607: LIST
6608: LIST
6609: LIST
6610: PPUSH
6611: LD_INT 16
6613: PUSH
6614: LD_INT 6
6616: PUSH
6617: LD_INT 6
6619: PUSH
6620: LD_INT 6
6622: PUSH
6623: EMPTY
6624: LIST
6625: LIST
6626: LIST
6627: LIST
6628: PPUSH
6629: CALL 58988 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
6633: LD_ADDR_EXP 90
6637: PUSH
6638: LD_EXP 90
6642: PPUSH
6643: LD_INT 1
6645: PPUSH
6646: LD_INT 22
6648: PUSH
6649: LD_VAR 0 5
6653: PUSH
6654: EMPTY
6655: LIST
6656: LIST
6657: PUSH
6658: LD_INT 23
6660: PUSH
6661: LD_INT 2
6663: PUSH
6664: EMPTY
6665: LIST
6666: LIST
6667: PUSH
6668: LD_INT 3
6670: PUSH
6671: LD_INT 21
6673: PUSH
6674: LD_INT 2
6676: PUSH
6677: EMPTY
6678: LIST
6679: LIST
6680: PUSH
6681: EMPTY
6682: LIST
6683: LIST
6684: PUSH
6685: EMPTY
6686: LIST
6687: LIST
6688: LIST
6689: PPUSH
6690: CALL_OW 69
6694: PPUSH
6695: CALL_OW 1
6699: ST_TO_ADDR
// end ;
6700: LD_VAR 0 1
6704: RET
// export Omar ; export function PrepareOmarAli ; begin
6705: LD_INT 0
6707: PPUSH
// uc_side := 5 ;
6708: LD_ADDR_OWVAR 20
6712: PUSH
6713: LD_INT 5
6715: ST_TO_ADDR
// uc_nation := 2 ;
6716: LD_ADDR_OWVAR 21
6720: PUSH
6721: LD_INT 2
6723: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
6724: LD_ADDR_EXP 53
6728: PUSH
6729: LD_STRING Omar
6731: PPUSH
6732: CALL_OW 25
6736: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
6737: LD_EXP 53
6741: PPUSH
6742: LD_INT 330
6744: PPUSH
6745: LD_INT 244
6747: PPUSH
6748: LD_INT 0
6750: PPUSH
6751: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
6755: LD_EXP 53
6759: PPUSH
6760: LD_INT 252
6762: PPUSH
6763: LD_INT 220
6765: PPUSH
6766: CALL_OW 111
// end ; end_of_file
6770: LD_VAR 0 1
6774: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
6775: LD_INT 0
6777: PPUSH
6778: PPUSH
6779: PPUSH
6780: PPUSH
6781: PPUSH
// side := 8 ;
6782: LD_ADDR_VAR 0 3
6786: PUSH
6787: LD_INT 8
6789: ST_TO_ADDR
// InitHc ;
6790: CALL_OW 19
// uc_side := side ;
6794: LD_ADDR_OWVAR 20
6798: PUSH
6799: LD_VAR 0 3
6803: ST_TO_ADDR
// uc_nation := 2 ;
6804: LD_ADDR_OWVAR 21
6808: PUSH
6809: LD_INT 2
6811: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6812: LD_ADDR_VAR 0 2
6816: PUSH
6817: LD_INT 22
6819: PUSH
6820: LD_VAR 0 3
6824: PUSH
6825: EMPTY
6826: LIST
6827: LIST
6828: PUSH
6829: LD_INT 21
6831: PUSH
6832: LD_INT 3
6834: PUSH
6835: EMPTY
6836: LIST
6837: LIST
6838: PUSH
6839: EMPTY
6840: LIST
6841: LIST
6842: PPUSH
6843: CALL_OW 69
6847: PUSH
6848: FOR_IN
6849: IFFALSE 6865
// SetBLevel ( i , 10 ) ;
6851: LD_VAR 0 2
6855: PPUSH
6856: LD_INT 10
6858: PPUSH
6859: CALL_OW 241
6863: GO 6848
6865: POP
6866: POP
// Schulz := NewCharacter ( Schulz ) ;
6867: LD_ADDR_EXP 54
6871: PUSH
6872: LD_STRING Schulz
6874: PPUSH
6875: CALL_OW 25
6879: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
6880: LD_ADDR_EXP 55
6884: PUSH
6885: LD_STRING Kozlov
6887: PPUSH
6888: LD_INT 0
6890: PPUSH
6891: LD_STRING 
6893: PPUSH
6894: CALL 50755 0 3
6898: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
6899: LD_EXP 55
6903: PPUSH
6904: LD_INT 22
6906: PUSH
6907: LD_INT 8
6909: PUSH
6910: EMPTY
6911: LIST
6912: LIST
6913: PUSH
6914: LD_INT 23
6916: PUSH
6917: LD_INT 3
6919: PUSH
6920: EMPTY
6921: LIST
6922: LIST
6923: PUSH
6924: LD_INT 30
6926: PUSH
6927: LD_INT 8
6929: PUSH
6930: EMPTY
6931: LIST
6932: LIST
6933: PUSH
6934: EMPTY
6935: LIST
6936: LIST
6937: LIST
6938: PPUSH
6939: CALL_OW 69
6943: PUSH
6944: LD_INT 1
6946: ARRAY
6947: PPUSH
6948: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
6952: LD_EXP 55
6956: PPUSH
6957: LD_INT 3
6959: PPUSH
6960: LD_INT 10
6962: PPUSH
6963: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6967: LD_ADDR_VAR 0 5
6971: PUSH
6972: LD_INT 22
6974: PUSH
6975: LD_VAR 0 3
6979: PUSH
6980: EMPTY
6981: LIST
6982: LIST
6983: PUSH
6984: LD_INT 30
6986: PUSH
6987: LD_INT 32
6989: PUSH
6990: EMPTY
6991: LIST
6992: LIST
6993: PUSH
6994: LD_INT 58
6996: PUSH
6997: EMPTY
6998: LIST
6999: PUSH
7000: EMPTY
7001: LIST
7002: LIST
7003: LIST
7004: PPUSH
7005: CALL_OW 69
7009: ST_TO_ADDR
// for i = 1 to 10 do
7010: LD_ADDR_VAR 0 2
7014: PUSH
7015: DOUBLE
7016: LD_INT 1
7018: DEC
7019: ST_TO_ADDR
7020: LD_INT 10
7022: PUSH
7023: FOR_TO
7024: IFFALSE 7096
// begin uc_nation := nation_nature ;
7026: LD_ADDR_OWVAR 21
7030: PUSH
7031: LD_INT 0
7033: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7034: LD_ADDR_OWVAR 28
7038: PUSH
7039: LD_INT 15
7041: ST_TO_ADDR
// hc_gallery :=  ;
7042: LD_ADDR_OWVAR 33
7046: PUSH
7047: LD_STRING 
7049: ST_TO_ADDR
// hc_name :=  ;
7050: LD_ADDR_OWVAR 26
7054: PUSH
7055: LD_STRING 
7057: ST_TO_ADDR
// un := CreateHuman ;
7058: LD_ADDR_VAR 0 4
7062: PUSH
7063: CALL_OW 44
7067: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7068: LD_VAR 0 4
7072: PPUSH
7073: LD_VAR 0 5
7077: PUSH
7078: LD_VAR 0 5
7082: PUSH
7083: LD_VAR 0 2
7087: MINUS
7088: ARRAY
7089: PPUSH
7090: CALL_OW 52
// end ;
7094: GO 7023
7096: POP
7097: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
7098: LD_INT 324
7100: PPUSH
7101: LD_INT 3
7103: PPUSH
7104: LD_STRING 
7106: PPUSH
7107: LD_INT 8
7109: PUSH
7110: LD_INT 9
7112: PUSH
7113: LD_INT 10
7115: PUSH
7116: EMPTY
7117: LIST
7118: LIST
7119: LIST
7120: PUSH
7121: LD_OWVAR 67
7125: ARRAY
7126: PPUSH
7127: LD_INT 3000
7129: PUSH
7130: LD_INT 500
7132: PUSH
7133: LD_INT 150
7135: PUSH
7136: EMPTY
7137: LIST
7138: LIST
7139: LIST
7140: PPUSH
7141: LD_INT 16
7143: PUSH
7144: LD_INT 6
7146: PUSH
7147: LD_INT 6
7149: PUSH
7150: LD_INT 8
7152: PUSH
7153: EMPTY
7154: LIST
7155: LIST
7156: LIST
7157: LIST
7158: PPUSH
7159: CALL 58988 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
7163: LD_ADDR_EXP 90
7167: PUSH
7168: LD_EXP 90
7172: PPUSH
7173: LD_INT 3
7175: PPUSH
7176: LD_INT 22
7178: PUSH
7179: LD_VAR 0 3
7183: PUSH
7184: EMPTY
7185: LIST
7186: LIST
7187: PUSH
7188: LD_INT 23
7190: PUSH
7191: LD_INT 2
7193: PUSH
7194: EMPTY
7195: LIST
7196: LIST
7197: PUSH
7198: LD_INT 3
7200: PUSH
7201: LD_INT 21
7203: PUSH
7204: LD_INT 2
7206: PUSH
7207: EMPTY
7208: LIST
7209: LIST
7210: PUSH
7211: EMPTY
7212: LIST
7213: LIST
7214: PUSH
7215: EMPTY
7216: LIST
7217: LIST
7218: LIST
7219: PPUSH
7220: CALL_OW 69
7224: PUSH
7225: LD_EXP 54
7229: DIFF
7230: PPUSH
7231: CALL_OW 1
7235: ST_TO_ADDR
// end ;
7236: LD_VAR 0 1
7240: RET
// export function BuildKozlovBomb ; begin
7241: LD_INT 0
7243: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7244: LD_INT 332
7246: PPUSH
7247: CALL_OW 302
7251: NOT
7252: PUSH
7253: LD_INT 336
7255: PPUSH
7256: CALL_OW 302
7260: NOT
7261: OR
7262: IFFALSE 7266
// exit ;
7264: GO 7363
// ComChangeProfession ( Kozlov , 4 ) ;
7266: LD_EXP 55
7270: PPUSH
7271: LD_INT 4
7273: PPUSH
7274: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7278: LD_INT 336
7280: PPUSH
7281: LD_INT 25
7283: PPUSH
7284: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7288: LD_INT 35
7290: PPUSH
7291: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7295: LD_INT 25
7297: PPUSH
7298: LD_INT 8
7300: PPUSH
7301: CALL_OW 321
7305: PUSH
7306: LD_INT 2
7308: EQUAL
7309: IFFALSE 7288
// ComExitBuilding ( Kozlov ) ;
7311: LD_EXP 55
7315: PPUSH
7316: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
7320: LD_EXP 55
7324: PPUSH
7325: LD_INT 332
7327: PPUSH
7328: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
7332: LD_EXP 55
7336: PPUSH
7337: LD_INT 3
7339: PPUSH
7340: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
7344: LD_INT 332
7346: PPUSH
7347: LD_INT 23
7349: PPUSH
7350: LD_INT 3
7352: PPUSH
7353: LD_INT 1
7355: PPUSH
7356: LD_INT 48
7358: PPUSH
7359: CALL_OW 125
// end ;
7363: LD_VAR 0 1
7367: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
7368: LD_EXP 3
7372: NOT
7373: PUSH
7374: LD_INT 3
7376: PPUSH
7377: LD_INT 1
7379: PPUSH
7380: CALL 45829 0 2
7384: NOT
7385: AND
7386: IFFALSE 8226
7388: GO 7390
7390: DISABLE
7391: LD_INT 0
7393: PPUSH
7394: PPUSH
7395: PPUSH
// begin enable ;
7396: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
7397: LD_INT 22
7399: PUSH
7400: LD_INT 8
7402: PUSH
7403: EMPTY
7404: LIST
7405: LIST
7406: PUSH
7407: LD_INT 23
7409: PUSH
7410: LD_INT 2
7412: PUSH
7413: EMPTY
7414: LIST
7415: LIST
7416: PUSH
7417: LD_INT 30
7419: PUSH
7420: LD_INT 3
7422: PUSH
7423: EMPTY
7424: LIST
7425: LIST
7426: PUSH
7427: EMPTY
7428: LIST
7429: LIST
7430: LIST
7431: PPUSH
7432: CALL_OW 69
7436: NOT
7437: IFFALSE 7441
// exit ;
7439: GO 8226
// if Prob ( 40 ) then
7441: LD_INT 40
7443: PPUSH
7444: CALL_OW 13
7448: IFFALSE 7575
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7450: LD_INT 3
7452: PPUSH
7453: LD_INT 14
7455: PUSH
7456: LD_INT 1
7458: PUSH
7459: LD_INT 2
7461: PUSH
7462: LD_INT 28
7464: PUSH
7465: EMPTY
7466: LIST
7467: LIST
7468: LIST
7469: LIST
7470: PUSH
7471: LD_INT 14
7473: PUSH
7474: LD_INT 1
7476: PUSH
7477: LD_INT 2
7479: PUSH
7480: LD_INT 28
7482: PUSH
7483: EMPTY
7484: LIST
7485: LIST
7486: LIST
7487: LIST
7488: PUSH
7489: LD_INT 14
7491: PUSH
7492: LD_INT 1
7494: PUSH
7495: LD_INT 2
7497: PUSH
7498: LD_INT 28
7500: PUSH
7501: EMPTY
7502: LIST
7503: LIST
7504: LIST
7505: LIST
7506: PUSH
7507: LD_INT 14
7509: PUSH
7510: LD_INT 1
7512: PUSH
7513: LD_INT 2
7515: PUSH
7516: LD_INT 28
7518: PUSH
7519: EMPTY
7520: LIST
7521: LIST
7522: LIST
7523: LIST
7524: PUSH
7525: LD_INT 14
7527: PUSH
7528: LD_INT 1
7530: PUSH
7531: LD_INT 2
7533: PUSH
7534: LD_INT 28
7536: PUSH
7537: EMPTY
7538: LIST
7539: LIST
7540: LIST
7541: LIST
7542: PUSH
7543: LD_INT 14
7545: PUSH
7546: LD_INT 1
7548: PUSH
7549: LD_INT 2
7551: PUSH
7552: LD_INT 26
7554: PUSH
7555: EMPTY
7556: LIST
7557: LIST
7558: LIST
7559: LIST
7560: PUSH
7561: EMPTY
7562: LIST
7563: LIST
7564: LIST
7565: LIST
7566: LIST
7567: LIST
7568: PPUSH
7569: CALL 44411 0 2
// end else
7573: GO 7766
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7575: LD_INT 3
7577: PPUSH
7578: LD_INT 14
7580: PUSH
7581: LD_INT 1
7583: PUSH
7584: LD_INT 2
7586: PUSH
7587: LD_INT 27
7589: PUSH
7590: LD_INT 26
7592: PUSH
7593: LD_INT 26
7595: PUSH
7596: EMPTY
7597: LIST
7598: LIST
7599: LIST
7600: PUSH
7601: LD_OWVAR 67
7605: ARRAY
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: LIST
7611: LIST
7612: PUSH
7613: LD_INT 14
7615: PUSH
7616: LD_INT 1
7618: PUSH
7619: LD_INT 2
7621: PUSH
7622: LD_INT 27
7624: PUSH
7625: LD_INT 26
7627: PUSH
7628: LD_INT 26
7630: PUSH
7631: EMPTY
7632: LIST
7633: LIST
7634: LIST
7635: PUSH
7636: LD_OWVAR 67
7640: ARRAY
7641: PUSH
7642: EMPTY
7643: LIST
7644: LIST
7645: LIST
7646: LIST
7647: PUSH
7648: LD_INT 14
7650: PUSH
7651: LD_INT 1
7653: PUSH
7654: LD_INT 2
7656: PUSH
7657: LD_INT 26
7659: PUSH
7660: LD_INT 26
7662: PUSH
7663: LD_INT 29
7665: PUSH
7666: EMPTY
7667: LIST
7668: LIST
7669: LIST
7670: PUSH
7671: LD_OWVAR 67
7675: ARRAY
7676: PUSH
7677: EMPTY
7678: LIST
7679: LIST
7680: LIST
7681: LIST
7682: PUSH
7683: LD_INT 13
7685: PUSH
7686: LD_INT 1
7688: PUSH
7689: LD_INT 2
7691: PUSH
7692: LD_INT 26
7694: PUSH
7695: LD_INT 29
7697: PUSH
7698: LD_INT 29
7700: PUSH
7701: EMPTY
7702: LIST
7703: LIST
7704: LIST
7705: PUSH
7706: LD_OWVAR 67
7710: ARRAY
7711: PUSH
7712: EMPTY
7713: LIST
7714: LIST
7715: LIST
7716: LIST
7717: PUSH
7718: LD_INT 13
7720: PUSH
7721: LD_INT 1
7723: PUSH
7724: LD_INT 2
7726: PUSH
7727: LD_INT 29
7729: PUSH
7730: EMPTY
7731: LIST
7732: LIST
7733: LIST
7734: LIST
7735: PUSH
7736: LD_INT 14
7738: PUSH
7739: LD_INT 1
7741: PUSH
7742: LD_INT 2
7744: PUSH
7745: LD_INT 26
7747: PUSH
7748: EMPTY
7749: LIST
7750: LIST
7751: LIST
7752: LIST
7753: PUSH
7754: EMPTY
7755: LIST
7756: LIST
7757: LIST
7758: LIST
7759: LIST
7760: LIST
7761: PPUSH
7762: CALL 44411 0 2
// end ; repeat wait ( 0 0$1 ) ;
7766: LD_INT 35
7768: PPUSH
7769: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
7773: LD_INT 3
7775: PPUSH
7776: LD_INT 1
7778: PPUSH
7779: CALL 45829 0 2
7783: PUSH
7784: LD_INT 6
7786: GREATEREQUAL
7787: IFFALSE 7766
// wait ( 0 0$30 ) ;
7789: LD_INT 1050
7791: PPUSH
7792: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
7796: LD_ADDR_VAR 0 2
7800: PUSH
7801: LD_INT 3
7803: PPUSH
7804: LD_INT 1
7806: PPUSH
7807: CALL 45829 0 2
7811: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
7812: LD_ADDR_EXP 109
7816: PUSH
7817: LD_EXP 109
7821: PPUSH
7822: LD_INT 3
7824: PPUSH
7825: LD_EXP 109
7829: PUSH
7830: LD_INT 3
7832: ARRAY
7833: PUSH
7834: LD_VAR 0 2
7838: DIFF
7839: PPUSH
7840: CALL_OW 1
7844: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
7845: LD_ADDR_VAR 0 3
7849: PUSH
7850: LD_INT 0
7852: PPUSH
7853: LD_INT 2
7855: PPUSH
7856: CALL_OW 12
7860: ST_TO_ADDR
// if target then
7861: LD_VAR 0 3
7865: IFFALSE 7993
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7867: LD_ADDR_VAR 0 2
7871: PUSH
7872: LD_VAR 0 2
7876: PPUSH
7877: LD_INT 24
7879: PUSH
7880: LD_INT 250
7882: PUSH
7883: EMPTY
7884: LIST
7885: LIST
7886: PPUSH
7887: CALL_OW 72
7891: ST_TO_ADDR
// for i in tmp do
7892: LD_ADDR_VAR 0 1
7896: PUSH
7897: LD_VAR 0 2
7901: PUSH
7902: FOR_IN
7903: IFFALSE 7943
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
7905: LD_VAR 0 1
7909: PPUSH
7910: LD_INT 89
7912: PPUSH
7913: LD_INT 71
7915: PPUSH
7916: CALL_OW 297
7920: PUSH
7921: LD_INT 9
7923: GREATER
7924: IFFALSE 7941
// ComMoveXY ( i , 89 , 71 ) ;
7926: LD_VAR 0 1
7930: PPUSH
7931: LD_INT 89
7933: PPUSH
7934: LD_INT 71
7936: PPUSH
7937: CALL_OW 111
7941: GO 7902
7943: POP
7944: POP
// wait ( 0 0$1 ) ;
7945: LD_INT 35
7947: PPUSH
7948: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
7952: LD_VAR 0 2
7956: PPUSH
7957: LD_INT 92
7959: PUSH
7960: LD_INT 89
7962: PUSH
7963: LD_INT 71
7965: PUSH
7966: LD_INT 9
7968: PUSH
7969: EMPTY
7970: LIST
7971: LIST
7972: LIST
7973: LIST
7974: PPUSH
7975: CALL_OW 72
7979: PUSH
7980: LD_VAR 0 2
7984: PUSH
7985: LD_INT 1
7987: MINUS
7988: GREATEREQUAL
7989: IFFALSE 7867
// end else
7991: GO 8117
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7993: LD_ADDR_VAR 0 2
7997: PUSH
7998: LD_VAR 0 2
8002: PPUSH
8003: LD_INT 24
8005: PUSH
8006: LD_INT 250
8008: PUSH
8009: EMPTY
8010: LIST
8011: LIST
8012: PPUSH
8013: CALL_OW 72
8017: ST_TO_ADDR
// for i in tmp do
8018: LD_ADDR_VAR 0 1
8022: PUSH
8023: LD_VAR 0 2
8027: PUSH
8028: FOR_IN
8029: IFFALSE 8069
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
8031: LD_VAR 0 1
8035: PPUSH
8036: LD_INT 147
8038: PPUSH
8039: LD_INT 4
8041: PPUSH
8042: CALL_OW 297
8046: PUSH
8047: LD_INT 9
8049: GREATER
8050: IFFALSE 8067
// ComMoveXY ( i , 147 , 4 ) ;
8052: LD_VAR 0 1
8056: PPUSH
8057: LD_INT 147
8059: PPUSH
8060: LD_INT 4
8062: PPUSH
8063: CALL_OW 111
8067: GO 8028
8069: POP
8070: POP
// wait ( 0 0$1 ) ;
8071: LD_INT 35
8073: PPUSH
8074: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
8078: LD_VAR 0 2
8082: PPUSH
8083: LD_INT 92
8085: PUSH
8086: LD_INT 147
8088: PUSH
8089: LD_INT 4
8091: PUSH
8092: LD_INT 9
8094: PUSH
8095: EMPTY
8096: LIST
8097: LIST
8098: LIST
8099: LIST
8100: PPUSH
8101: CALL_OW 72
8105: PUSH
8106: LD_VAR 0 2
8110: PUSH
8111: LD_INT 1
8113: MINUS
8114: GREATEREQUAL
8115: IFFALSE 7993
// end ; repeat wait ( 0 0$1 ) ;
8117: LD_INT 35
8119: PPUSH
8120: CALL_OW 67
// for i in tmp do
8124: LD_ADDR_VAR 0 1
8128: PUSH
8129: LD_VAR 0 2
8133: PUSH
8134: FOR_IN
8135: IFFALSE 8217
// begin if GetLives ( i ) > 251 then
8137: LD_VAR 0 1
8141: PPUSH
8142: CALL_OW 256
8146: PUSH
8147: LD_INT 251
8149: GREATER
8150: IFFALSE 8188
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
8152: LD_VAR 0 1
8156: PPUSH
8157: LD_INT 81
8159: PUSH
8160: LD_INT 8
8162: PUSH
8163: EMPTY
8164: LIST
8165: LIST
8166: PPUSH
8167: CALL_OW 69
8171: PPUSH
8172: LD_VAR 0 1
8176: PPUSH
8177: CALL_OW 74
8181: PPUSH
8182: CALL_OW 115
8186: GO 8215
// if IsDead ( i ) then
8188: LD_VAR 0 1
8192: PPUSH
8193: CALL_OW 301
8197: IFFALSE 8215
// tmp := tmp diff i ;
8199: LD_ADDR_VAR 0 2
8203: PUSH
8204: LD_VAR 0 2
8208: PUSH
8209: LD_VAR 0 1
8213: DIFF
8214: ST_TO_ADDR
// end ;
8215: GO 8134
8217: POP
8218: POP
// until not tmp ;
8219: LD_VAR 0 2
8223: NOT
8224: IFFALSE 8117
// end ;
8226: PPOPN 3
8228: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8229: LD_EXP 55
8233: PPUSH
8234: CALL_OW 302
8238: PUSH
8239: LD_EXP 3
8243: NOT
8244: AND
8245: IFFALSE 8254
8247: GO 8249
8249: DISABLE
// BuildKozlovBomb ;
8250: CALL 7241 0 0
8254: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8255: LD_INT 22
8257: PUSH
8258: LD_INT 8
8260: PUSH
8261: EMPTY
8262: LIST
8263: LIST
8264: PUSH
8265: LD_INT 34
8267: PUSH
8268: LD_INT 48
8270: PUSH
8271: EMPTY
8272: LIST
8273: LIST
8274: PUSH
8275: EMPTY
8276: LIST
8277: LIST
8278: PPUSH
8279: CALL_OW 69
8283: IFFALSE 8331
8285: GO 8287
8287: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
8288: LD_INT 22
8290: PUSH
8291: LD_INT 8
8293: PUSH
8294: EMPTY
8295: LIST
8296: LIST
8297: PUSH
8298: LD_INT 34
8300: PUSH
8301: LD_INT 48
8303: PUSH
8304: EMPTY
8305: LIST
8306: LIST
8307: PUSH
8308: EMPTY
8309: LIST
8310: LIST
8311: PPUSH
8312: CALL_OW 69
8316: PUSH
8317: LD_INT 1
8319: ARRAY
8320: PPUSH
8321: LD_INT 173
8323: PPUSH
8324: LD_INT 96
8326: PPUSH
8327: CALL_OW 116
// end ; end_of_file
8331: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
8332: LD_INT 0
8334: PPUSH
8335: PPUSH
8336: PPUSH
8337: PPUSH
8338: PPUSH
8339: PPUSH
8340: PPUSH
8341: PPUSH
8342: PPUSH
// side := 3 ;
8343: LD_ADDR_VAR 0 6
8347: PUSH
8348: LD_INT 3
8350: ST_TO_ADDR
// InitHc ;
8351: CALL_OW 19
// uc_side := side ;
8355: LD_ADDR_OWVAR 20
8359: PUSH
8360: LD_VAR 0 6
8364: ST_TO_ADDR
// uc_nation := 3 ;
8365: LD_ADDR_OWVAR 21
8369: PUSH
8370: LD_INT 3
8372: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
8373: LD_ADDR_VAR 0 2
8377: PUSH
8378: LD_INT 22
8380: PUSH
8381: LD_VAR 0 6
8385: PUSH
8386: EMPTY
8387: LIST
8388: LIST
8389: PUSH
8390: LD_INT 21
8392: PUSH
8393: LD_INT 3
8395: PUSH
8396: EMPTY
8397: LIST
8398: LIST
8399: PUSH
8400: EMPTY
8401: LIST
8402: LIST
8403: PPUSH
8404: CALL_OW 69
8408: PUSH
8409: FOR_IN
8410: IFFALSE 8426
// SetBLevel ( i , 10 ) ;
8412: LD_VAR 0 2
8416: PPUSH
8417: LD_INT 10
8419: PPUSH
8420: CALL_OW 241
8424: GO 8409
8426: POP
8427: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
8428: LD_ADDR_VAR 0 9
8432: PUSH
8433: LD_INT 22
8435: PUSH
8436: LD_VAR 0 6
8440: PUSH
8441: EMPTY
8442: LIST
8443: LIST
8444: PUSH
8445: LD_INT 30
8447: PUSH
8448: LD_INT 34
8450: PUSH
8451: EMPTY
8452: LIST
8453: LIST
8454: PUSH
8455: EMPTY
8456: LIST
8457: LIST
8458: PPUSH
8459: CALL_OW 69
8463: ST_TO_ADDR
// if teleport then
8464: LD_VAR 0 9
8468: IFFALSE 8489
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
8470: LD_VAR 0 9
8474: PUSH
8475: LD_INT 1
8477: ARRAY
8478: PPUSH
8479: LD_INT 123
8481: PPUSH
8482: LD_INT 122
8484: PPUSH
8485: CALL_OW 243
// hc_importance := 0 ;
8489: LD_ADDR_OWVAR 32
8493: PUSH
8494: LD_INT 0
8496: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
8497: LD_ADDR_EXP 56
8501: PUSH
8502: LD_STRING Platonov
8504: PPUSH
8505: CALL_OW 25
8509: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
8510: LD_ADDR_EXP 57
8514: PUSH
8515: LD_STRING Yakotich
8517: PPUSH
8518: CALL_OW 25
8522: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
8523: LD_ADDR_EXP 58
8527: PUSH
8528: LD_STRING Gleb
8530: PPUSH
8531: CALL_OW 25
8535: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
8536: LD_STRING 03_Cornel
8538: PPUSH
8539: CALL_OW 28
8543: IFFALSE 8591
// begin Bierezov := NewCharacter ( Mikhail ) ;
8545: LD_ADDR_EXP 59
8549: PUSH
8550: LD_STRING Mikhail
8552: PPUSH
8553: CALL_OW 25
8557: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
8558: LD_EXP 59
8562: PPUSH
8563: LD_INT 197
8565: PPUSH
8566: LD_INT 111
8568: PPUSH
8569: LD_INT 9
8571: PPUSH
8572: LD_INT 0
8574: PPUSH
8575: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
8579: LD_EXP 59
8583: PPUSH
8584: LD_INT 3
8586: PPUSH
8587: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
8591: LD_EXP 56
8595: PPUSH
8596: LD_INT 126
8598: PPUSH
8599: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
8603: LD_EXP 57
8607: PPUSH
8608: LD_INT 197
8610: PPUSH
8611: LD_INT 111
8613: PPUSH
8614: LD_INT 9
8616: PPUSH
8617: LD_INT 0
8619: PPUSH
8620: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
8624: LD_EXP 58
8628: PPUSH
8629: LD_INT 197
8631: PPUSH
8632: LD_INT 111
8634: PPUSH
8635: LD_INT 9
8637: PPUSH
8638: LD_INT 0
8640: PPUSH
8641: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 9000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
8645: LD_ADDR_VAR 0 5
8649: PUSH
8650: LD_INT 126
8652: PPUSH
8653: LD_INT 2
8655: PPUSH
8656: LD_STRING zhukov
8658: PPUSH
8659: LD_INT 9
8661: PUSH
8662: LD_INT 10
8664: PUSH
8665: LD_INT 10
8667: PUSH
8668: EMPTY
8669: LIST
8670: LIST
8671: LIST
8672: PUSH
8673: LD_OWVAR 67
8677: ARRAY
8678: PPUSH
8679: LD_INT 9000
8681: PUSH
8682: LD_INT 1000
8684: PUSH
8685: LD_INT 300
8687: PUSH
8688: EMPTY
8689: LIST
8690: LIST
8691: LIST
8692: PPUSH
8693: LD_INT 21
8695: PUSH
8696: LD_INT 8
8698: PUSH
8699: LD_INT 13
8701: PUSH
8702: LD_INT 8
8704: PUSH
8705: EMPTY
8706: LIST
8707: LIST
8708: LIST
8709: LIST
8710: PPUSH
8711: CALL 58988 0 6
8715: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
8716: LD_ADDR_VAR 0 4
8720: PUSH
8721: LD_INT 267
8723: PPUSH
8724: CALL_OW 274
8728: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
8729: LD_VAR 0 4
8733: PPUSH
8734: LD_INT 1
8736: PPUSH
8737: LD_INT 5000
8739: PPUSH
8740: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8744: LD_VAR 0 4
8748: PPUSH
8749: LD_INT 2
8751: PPUSH
8752: LD_INT 200
8754: PPUSH
8755: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8759: LD_VAR 0 4
8763: PPUSH
8764: LD_INT 3
8766: PPUSH
8767: LD_INT 200
8769: PPUSH
8770: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
8774: LD_ADDR_EXP 90
8778: PUSH
8779: LD_EXP 90
8783: PPUSH
8784: LD_INT 2
8786: PPUSH
8787: LD_VAR 0 5
8791: PUSH
8792: LD_INT 22
8794: PUSH
8795: LD_VAR 0 6
8799: PUSH
8800: EMPTY
8801: LIST
8802: LIST
8803: PUSH
8804: LD_INT 3
8806: PUSH
8807: LD_INT 21
8809: PUSH
8810: LD_INT 2
8812: PUSH
8813: EMPTY
8814: LIST
8815: LIST
8816: PUSH
8817: EMPTY
8818: LIST
8819: LIST
8820: PUSH
8821: EMPTY
8822: LIST
8823: LIST
8824: PPUSH
8825: CALL_OW 69
8829: UNION
8830: PUSH
8831: LD_EXP 56
8835: DIFF
8836: PPUSH
8837: CALL_OW 1
8841: ST_TO_ADDR
// behemoths := [ ] ;
8842: LD_ADDR_EXP 60
8846: PUSH
8847: EMPTY
8848: ST_TO_ADDR
// behemothBuilders := [ ] ;
8849: LD_ADDR_EXP 61
8853: PUSH
8854: EMPTY
8855: ST_TO_ADDR
// j := 3 ;
8856: LD_ADDR_VAR 0 3
8860: PUSH
8861: LD_INT 3
8863: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
8864: LD_ADDR_VAR 0 2
8868: PUSH
8869: LD_INT 22
8871: PUSH
8872: LD_INT 3
8874: PUSH
8875: EMPTY
8876: LIST
8877: LIST
8878: PUSH
8879: LD_INT 25
8881: PUSH
8882: LD_INT 3
8884: PUSH
8885: EMPTY
8886: LIST
8887: LIST
8888: PUSH
8889: EMPTY
8890: LIST
8891: LIST
8892: PPUSH
8893: CALL_OW 69
8897: PUSH
8898: FOR_IN
8899: IFFALSE 8949
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8901: LD_ADDR_EXP 61
8905: PUSH
8906: LD_EXP 61
8910: PPUSH
8911: LD_VAR 0 2
8915: PPUSH
8916: CALL 86744 0 2
8920: ST_TO_ADDR
// j := j - 1 ;
8921: LD_ADDR_VAR 0 3
8925: PUSH
8926: LD_VAR 0 3
8930: PUSH
8931: LD_INT 1
8933: MINUS
8934: ST_TO_ADDR
// if j = 0 then
8935: LD_VAR 0 3
8939: PUSH
8940: LD_INT 0
8942: EQUAL
8943: IFFALSE 8947
// break ;
8945: GO 8949
// end ;
8947: GO 8898
8949: POP
8950: POP
// end ;
8951: LD_VAR 0 1
8955: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
8956: LD_INT 0
8958: PPUSH
8959: PPUSH
8960: PPUSH
8961: PPUSH
8962: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
8963: LD_ADDR_VAR 0 4
8967: PUSH
8968: LD_INT 209
8970: PUSH
8971: LD_INT 149
8973: PUSH
8974: EMPTY
8975: LIST
8976: LIST
8977: PUSH
8978: LD_INT 219
8980: PUSH
8981: LD_INT 154
8983: PUSH
8984: EMPTY
8985: LIST
8986: LIST
8987: PUSH
8988: LD_INT 223
8990: PUSH
8991: LD_INT 149
8993: PUSH
8994: EMPTY
8995: LIST
8996: LIST
8997: PUSH
8998: LD_INT 232
9000: PUSH
9001: LD_INT 155
9003: PUSH
9004: EMPTY
9005: LIST
9006: LIST
9007: PUSH
9008: EMPTY
9009: LIST
9010: LIST
9011: LIST
9012: LIST
9013: ST_TO_ADDR
// if not behemothBuilders then
9014: LD_EXP 61
9018: NOT
9019: IFFALSE 9023
// exit ;
9021: GO 9127
// j := 1 ;
9023: LD_ADDR_VAR 0 3
9027: PUSH
9028: LD_INT 1
9030: ST_TO_ADDR
// for i in behemothBuilders do
9031: LD_ADDR_VAR 0 2
9035: PUSH
9036: LD_EXP 61
9040: PUSH
9041: FOR_IN
9042: IFFALSE 9125
// begin if IsInUnit ( i ) then
9044: LD_VAR 0 2
9048: PPUSH
9049: CALL_OW 310
9053: IFFALSE 9064
// ComExitBuilding ( i ) ;
9055: LD_VAR 0 2
9059: PPUSH
9060: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
9064: LD_VAR 0 2
9068: PPUSH
9069: LD_INT 37
9071: PPUSH
9072: LD_VAR 0 4
9076: PUSH
9077: LD_VAR 0 3
9081: ARRAY
9082: PUSH
9083: LD_INT 1
9085: ARRAY
9086: PPUSH
9087: LD_VAR 0 4
9091: PUSH
9092: LD_VAR 0 3
9096: ARRAY
9097: PUSH
9098: LD_INT 2
9100: ARRAY
9101: PPUSH
9102: LD_INT 0
9104: PPUSH
9105: CALL_OW 230
// j := j + 1 ;
9109: LD_ADDR_VAR 0 3
9113: PUSH
9114: LD_VAR 0 3
9118: PUSH
9119: LD_INT 1
9121: PLUS
9122: ST_TO_ADDR
// end ;
9123: GO 9041
9125: POP
9126: POP
// end ;
9127: LD_VAR 0 1
9131: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
9132: LD_INT 3
9134: PPUSH
9135: CALL 86805 0 1
9139: PUSH
9140: LD_INT 22
9142: PUSH
9143: LD_INT 3
9145: PUSH
9146: EMPTY
9147: LIST
9148: LIST
9149: PUSH
9150: LD_INT 30
9152: PUSH
9153: LD_INT 37
9155: PUSH
9156: EMPTY
9157: LIST
9158: LIST
9159: PUSH
9160: EMPTY
9161: LIST
9162: LIST
9163: PPUSH
9164: CALL_OW 69
9168: NOT
9169: AND
9170: IFFALSE 9356
9172: GO 9174
9174: DISABLE
9175: LD_INT 0
9177: PPUSH
9178: PPUSH
// begin enable ;
9179: ENABLE
// tmp := GetBehemoths ( 3 ) ;
9180: LD_ADDR_VAR 0 2
9184: PUSH
9185: LD_INT 3
9187: PPUSH
9188: CALL 86805 0 1
9192: ST_TO_ADDR
// for i in tmp do
9193: LD_ADDR_VAR 0 1
9197: PUSH
9198: LD_VAR 0 2
9202: PUSH
9203: FOR_IN
9204: IFFALSE 9354
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
9206: LD_VAR 0 1
9210: PPUSH
9211: LD_INT 7
9213: PPUSH
9214: CALL_OW 308
9218: PUSH
9219: LD_VAR 0 1
9223: PPUSH
9224: CALL_OW 110
9228: PUSH
9229: LD_INT 2
9231: EQUAL
9232: NOT
9233: AND
9234: IFFALSE 9248
// SetTag ( i , 2 ) ;
9236: LD_VAR 0 1
9240: PPUSH
9241: LD_INT 2
9243: PPUSH
9244: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
9248: LD_INT 81
9250: PUSH
9251: LD_INT 3
9253: PUSH
9254: EMPTY
9255: LIST
9256: LIST
9257: PUSH
9258: LD_INT 91
9260: PUSH
9261: LD_VAR 0 1
9265: PUSH
9266: LD_INT 12
9268: PUSH
9269: EMPTY
9270: LIST
9271: LIST
9272: LIST
9273: PUSH
9274: EMPTY
9275: LIST
9276: LIST
9277: PPUSH
9278: CALL_OW 69
9282: NOT
9283: PUSH
9284: LD_VAR 0 1
9288: PPUSH
9289: CALL_OW 110
9293: PUSH
9294: LD_INT 2
9296: EQUAL
9297: NOT
9298: AND
9299: IFFALSE 9318
// ComAgressiveMove ( i , 64 , 93 ) else
9301: LD_VAR 0 1
9305: PPUSH
9306: LD_INT 64
9308: PPUSH
9309: LD_INT 93
9311: PPUSH
9312: CALL_OW 114
9316: GO 9352
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9318: LD_VAR 0 1
9322: PPUSH
9323: LD_INT 81
9325: PUSH
9326: LD_INT 3
9328: PUSH
9329: EMPTY
9330: LIST
9331: LIST
9332: PPUSH
9333: CALL_OW 69
9337: PPUSH
9338: LD_VAR 0 1
9342: PPUSH
9343: CALL_OW 74
9347: PPUSH
9348: CALL_OW 115
// end ;
9352: GO 9203
9354: POP
9355: POP
// end ;
9356: PPOPN 2
9358: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9359: LD_EXP 2
9363: NOT
9364: PUSH
9365: LD_INT 2
9367: PPUSH
9368: LD_INT 1
9370: PPUSH
9371: CALL 45829 0 2
9375: NOT
9376: AND
9377: IFFALSE 10297
9379: GO 9381
9381: DISABLE
9382: LD_INT 0
9384: PPUSH
9385: PPUSH
9386: PPUSH
9387: PPUSH
// begin enable ;
9388: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9389: LD_INT 22
9391: PUSH
9392: LD_INT 3
9394: PUSH
9395: EMPTY
9396: LIST
9397: LIST
9398: PUSH
9399: LD_INT 30
9401: PUSH
9402: LD_INT 3
9404: PUSH
9405: EMPTY
9406: LIST
9407: LIST
9408: PUSH
9409: EMPTY
9410: LIST
9411: LIST
9412: PPUSH
9413: CALL_OW 69
9417: NOT
9418: IFFALSE 9422
// exit ;
9420: GO 10297
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9422: LD_ADDR_VAR 0 4
9426: PUSH
9427: LD_INT 22
9429: PUSH
9430: LD_INT 3
9432: PUSH
9433: EMPTY
9434: LIST
9435: LIST
9436: PUSH
9437: LD_INT 30
9439: PUSH
9440: LD_INT 34
9442: PUSH
9443: EMPTY
9444: LIST
9445: LIST
9446: PUSH
9447: EMPTY
9448: LIST
9449: LIST
9450: PPUSH
9451: CALL_OW 69
9455: ST_TO_ADDR
// if Prob ( 40 ) then
9456: LD_INT 40
9458: PPUSH
9459: CALL_OW 13
9463: IFFALSE 9590
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9465: LD_INT 2
9467: PPUSH
9468: LD_INT 22
9470: PUSH
9471: LD_INT 3
9473: PUSH
9474: LD_INT 3
9476: PUSH
9477: LD_INT 49
9479: PUSH
9480: EMPTY
9481: LIST
9482: LIST
9483: LIST
9484: LIST
9485: PUSH
9486: LD_INT 22
9488: PUSH
9489: LD_INT 3
9491: PUSH
9492: LD_INT 3
9494: PUSH
9495: LD_INT 49
9497: PUSH
9498: EMPTY
9499: LIST
9500: LIST
9501: LIST
9502: LIST
9503: PUSH
9504: LD_INT 22
9506: PUSH
9507: LD_INT 3
9509: PUSH
9510: LD_INT 3
9512: PUSH
9513: LD_INT 49
9515: PUSH
9516: EMPTY
9517: LIST
9518: LIST
9519: LIST
9520: LIST
9521: PUSH
9522: LD_INT 24
9524: PUSH
9525: LD_INT 3
9527: PUSH
9528: LD_INT 3
9530: PUSH
9531: LD_INT 46
9533: PUSH
9534: EMPTY
9535: LIST
9536: LIST
9537: LIST
9538: LIST
9539: PUSH
9540: LD_INT 24
9542: PUSH
9543: LD_INT 3
9545: PUSH
9546: LD_INT 3
9548: PUSH
9549: LD_INT 46
9551: PUSH
9552: EMPTY
9553: LIST
9554: LIST
9555: LIST
9556: LIST
9557: PUSH
9558: LD_INT 24
9560: PUSH
9561: LD_INT 3
9563: PUSH
9564: LD_INT 3
9566: PUSH
9567: LD_INT 46
9569: PUSH
9570: EMPTY
9571: LIST
9572: LIST
9573: LIST
9574: LIST
9575: PUSH
9576: EMPTY
9577: LIST
9578: LIST
9579: LIST
9580: LIST
9581: LIST
9582: LIST
9583: PPUSH
9584: CALL 44411 0 2
// end else
9588: GO 9713
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9590: LD_INT 2
9592: PPUSH
9593: LD_INT 24
9595: PUSH
9596: LD_INT 3
9598: PUSH
9599: LD_INT 3
9601: PUSH
9602: LD_INT 47
9604: PUSH
9605: EMPTY
9606: LIST
9607: LIST
9608: LIST
9609: LIST
9610: PUSH
9611: LD_INT 24
9613: PUSH
9614: LD_INT 3
9616: PUSH
9617: LD_INT 3
9619: PUSH
9620: LD_INT 47
9622: PUSH
9623: EMPTY
9624: LIST
9625: LIST
9626: LIST
9627: LIST
9628: PUSH
9629: LD_INT 24
9631: PUSH
9632: LD_INT 3
9634: PUSH
9635: LD_INT 3
9637: PUSH
9638: LD_INT 47
9640: PUSH
9641: EMPTY
9642: LIST
9643: LIST
9644: LIST
9645: LIST
9646: PUSH
9647: LD_INT 24
9649: PUSH
9650: LD_INT 3
9652: PUSH
9653: LD_INT 3
9655: PUSH
9656: LD_INT 46
9658: PUSH
9659: EMPTY
9660: LIST
9661: LIST
9662: LIST
9663: LIST
9664: PUSH
9665: LD_INT 24
9667: PUSH
9668: LD_INT 3
9670: PUSH
9671: LD_INT 3
9673: PUSH
9674: LD_INT 46
9676: PUSH
9677: EMPTY
9678: LIST
9679: LIST
9680: LIST
9681: LIST
9682: PUSH
9683: LD_INT 24
9685: PUSH
9686: LD_INT 3
9688: PUSH
9689: LD_INT 3
9691: PUSH
9692: LD_INT 46
9694: PUSH
9695: EMPTY
9696: LIST
9697: LIST
9698: LIST
9699: LIST
9700: PUSH
9701: EMPTY
9702: LIST
9703: LIST
9704: LIST
9705: LIST
9706: LIST
9707: LIST
9708: PPUSH
9709: CALL 44411 0 2
// end ; if Difficulty > 1 then
9713: LD_OWVAR 67
9717: PUSH
9718: LD_INT 1
9720: GREATER
9721: IFFALSE 9751
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
9723: LD_INT 2
9725: PPUSH
9726: LD_INT 24
9728: PUSH
9729: LD_INT 3
9731: PUSH
9732: LD_INT 3
9734: PUSH
9735: LD_INT 47
9737: PUSH
9738: EMPTY
9739: LIST
9740: LIST
9741: LIST
9742: LIST
9743: PUSH
9744: EMPTY
9745: LIST
9746: PPUSH
9747: CALL 44411 0 2
// repeat wait ( 0 0$1 ) ;
9751: LD_INT 35
9753: PPUSH
9754: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
9758: LD_INT 2
9760: PPUSH
9761: LD_INT 1
9763: PPUSH
9764: CALL 45829 0 2
9768: PUSH
9769: LD_INT 6
9771: PUSH
9772: LD_INT 7
9774: PUSH
9775: LD_INT 7
9777: PUSH
9778: EMPTY
9779: LIST
9780: LIST
9781: LIST
9782: PUSH
9783: LD_OWVAR 67
9787: ARRAY
9788: GREATEREQUAL
9789: IFFALSE 9751
// wait ( 0 0$30 ) ;
9791: LD_INT 1050
9793: PPUSH
9794: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
9798: LD_ADDR_VAR 0 2
9802: PUSH
9803: LD_INT 2
9805: PPUSH
9806: LD_INT 1
9808: PPUSH
9809: CALL 45829 0 2
9813: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
9814: LD_ADDR_EXP 109
9818: PUSH
9819: LD_EXP 109
9823: PPUSH
9824: LD_INT 2
9826: PPUSH
9827: LD_EXP 109
9831: PUSH
9832: LD_INT 2
9834: ARRAY
9835: PUSH
9836: LD_VAR 0 2
9840: DIFF
9841: PPUSH
9842: CALL_OW 1
9846: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
9847: LD_ADDR_VAR 0 3
9851: PUSH
9852: LD_INT 0
9854: PPUSH
9855: LD_INT 1
9857: PPUSH
9858: CALL_OW 12
9862: ST_TO_ADDR
// if target then
9863: LD_VAR 0 3
9867: IFFALSE 9995
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9869: LD_ADDR_VAR 0 2
9873: PUSH
9874: LD_VAR 0 2
9878: PPUSH
9879: LD_INT 24
9881: PUSH
9882: LD_INT 250
9884: PUSH
9885: EMPTY
9886: LIST
9887: LIST
9888: PPUSH
9889: CALL_OW 72
9893: ST_TO_ADDR
// for i in tmp do
9894: LD_ADDR_VAR 0 1
9898: PUSH
9899: LD_VAR 0 2
9903: PUSH
9904: FOR_IN
9905: IFFALSE 9945
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
9907: LD_VAR 0 1
9911: PPUSH
9912: LD_INT 139
9914: PPUSH
9915: LD_INT 89
9917: PPUSH
9918: CALL_OW 297
9922: PUSH
9923: LD_INT 9
9925: GREATER
9926: IFFALSE 9943
// ComMoveXY ( i , 139 , 89 ) ;
9928: LD_VAR 0 1
9932: PPUSH
9933: LD_INT 139
9935: PPUSH
9936: LD_INT 89
9938: PPUSH
9939: CALL_OW 111
9943: GO 9904
9945: POP
9946: POP
// wait ( 0 0$1 ) ;
9947: LD_INT 35
9949: PPUSH
9950: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
9954: LD_VAR 0 2
9958: PPUSH
9959: LD_INT 92
9961: PUSH
9962: LD_INT 139
9964: PUSH
9965: LD_INT 89
9967: PUSH
9968: LD_INT 9
9970: PUSH
9971: EMPTY
9972: LIST
9973: LIST
9974: LIST
9975: LIST
9976: PPUSH
9977: CALL_OW 72
9981: PUSH
9982: LD_VAR 0 2
9986: PUSH
9987: LD_INT 1
9989: MINUS
9990: GREATEREQUAL
9991: IFFALSE 9869
// end else
9993: GO 10137
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
9995: LD_VAR 0 2
9999: PPUSH
10000: LD_VAR 0 4
10004: PUSH
10005: LD_INT 1
10007: ARRAY
10008: PPUSH
10009: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10013: LD_ADDR_VAR 0 2
10017: PUSH
10018: LD_VAR 0 2
10022: PPUSH
10023: LD_INT 24
10025: PUSH
10026: LD_INT 250
10028: PUSH
10029: EMPTY
10030: LIST
10031: LIST
10032: PPUSH
10033: CALL_OW 72
10037: ST_TO_ADDR
// for i in tmp do
10038: LD_ADDR_VAR 0 1
10042: PUSH
10043: LD_VAR 0 2
10047: PUSH
10048: FOR_IN
10049: IFFALSE 10089
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10051: LD_VAR 0 1
10055: PPUSH
10056: LD_INT 124
10058: PPUSH
10059: LD_INT 139
10061: PPUSH
10062: CALL_OW 297
10066: PUSH
10067: LD_INT 9
10069: GREATER
10070: IFFALSE 10087
// ComMoveXY ( i , 124 , 139 ) ;
10072: LD_VAR 0 1
10076: PPUSH
10077: LD_INT 124
10079: PPUSH
10080: LD_INT 139
10082: PPUSH
10083: CALL_OW 111
10087: GO 10048
10089: POP
10090: POP
// wait ( 0 0$1 ) ;
10091: LD_INT 35
10093: PPUSH
10094: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10098: LD_VAR 0 2
10102: PPUSH
10103: LD_INT 92
10105: PUSH
10106: LD_INT 124
10108: PUSH
10109: LD_INT 139
10111: PUSH
10112: LD_INT 9
10114: PUSH
10115: EMPTY
10116: LIST
10117: LIST
10118: LIST
10119: LIST
10120: PPUSH
10121: CALL_OW 72
10125: PUSH
10126: LD_VAR 0 2
10130: PUSH
10131: LD_INT 1
10133: MINUS
10134: GREATEREQUAL
10135: IFFALSE 10013
// end ; repeat wait ( 0 0$1 ) ;
10137: LD_INT 35
10139: PPUSH
10140: CALL_OW 67
// for i in tmp do
10144: LD_ADDR_VAR 0 1
10148: PUSH
10149: LD_VAR 0 2
10153: PUSH
10154: FOR_IN
10155: IFFALSE 10288
// begin if GetLives ( i ) > 251 then
10157: LD_VAR 0 1
10161: PPUSH
10162: CALL_OW 256
10166: PUSH
10167: LD_INT 251
10169: GREATER
10170: IFFALSE 10259
// begin if GetWeapon ( i ) = ru_time_lapser then
10172: LD_VAR 0 1
10176: PPUSH
10177: CALL_OW 264
10181: PUSH
10182: LD_INT 49
10184: EQUAL
10185: IFFALSE 10223
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
10187: LD_VAR 0 1
10191: PPUSH
10192: LD_INT 81
10194: PUSH
10195: LD_INT 3
10197: PUSH
10198: EMPTY
10199: LIST
10200: LIST
10201: PPUSH
10202: CALL_OW 69
10206: PPUSH
10207: LD_VAR 0 1
10211: PPUSH
10212: CALL_OW 74
10216: PPUSH
10217: CALL_OW 112
10221: GO 10257
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10223: LD_VAR 0 1
10227: PPUSH
10228: LD_INT 81
10230: PUSH
10231: LD_INT 3
10233: PUSH
10234: EMPTY
10235: LIST
10236: LIST
10237: PPUSH
10238: CALL_OW 69
10242: PPUSH
10243: LD_VAR 0 1
10247: PPUSH
10248: CALL_OW 74
10252: PPUSH
10253: CALL_OW 115
// end else
10257: GO 10286
// if IsDead ( i ) then
10259: LD_VAR 0 1
10263: PPUSH
10264: CALL_OW 301
10268: IFFALSE 10286
// tmp := tmp diff i ;
10270: LD_ADDR_VAR 0 2
10274: PUSH
10275: LD_VAR 0 2
10279: PUSH
10280: LD_VAR 0 1
10284: DIFF
10285: ST_TO_ADDR
// end ;
10286: GO 10154
10288: POP
10289: POP
// until not tmp ;
10290: LD_VAR 0 2
10294: NOT
10295: IFFALSE 10137
// end ;
10297: PPOPN 4
10299: END
// every 30 30$00 trigger not russianDestroyed do
10300: LD_EXP 2
10304: NOT
10305: IFFALSE 10370
10307: GO 10309
10309: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 ] [ Difficulty ] ) ;
10310: LD_INT 105000
10312: PUSH
10313: LD_INT 84000
10315: PUSH
10316: LD_INT 63000
10318: PUSH
10319: EMPTY
10320: LIST
10321: LIST
10322: LIST
10323: PUSH
10324: LD_OWVAR 67
10328: ARRAY
10329: PPUSH
10330: CALL_OW 67
// if russianDestroyed then
10334: LD_EXP 2
10338: IFFALSE 10342
// exit ;
10340: GO 10370
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
10342: LD_INT 2
10344: PPUSH
10345: LD_INT 23
10347: PUSH
10348: LD_INT 3
10350: PUSH
10351: LD_INT 1
10353: PUSH
10354: LD_INT 48
10356: PUSH
10357: EMPTY
10358: LIST
10359: LIST
10360: LIST
10361: LIST
10362: PUSH
10363: EMPTY
10364: LIST
10365: PPUSH
10366: CALL 44411 0 2
// end ; end_of_file
10370: END
// export function CustomEvent ( event ) ; begin
10371: LD_INT 0
10373: PPUSH
// end ;
10374: LD_VAR 0 2
10378: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10379: LD_VAR 0 2
10383: PPUSH
10384: LD_VAR 0 3
10388: PPUSH
10389: LD_INT 15
10391: PPUSH
10392: CALL_OW 309
10396: IFFALSE 10405
// YouLost ( MothContaminate ) ;
10398: LD_STRING MothContaminate
10400: PPUSH
10401: CALL_OW 104
// end ;
10405: PPOPN 3
10407: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10408: LD_VAR 0 2
10412: PPUSH
10413: LD_VAR 0 3
10417: PPUSH
10418: LD_INT 15
10420: PPUSH
10421: CALL_OW 309
10425: IFFALSE 10441
// begin wait ( 0 0$6 ) ;
10427: LD_INT 210
10429: PPUSH
10430: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
10434: LD_STRING MothContaminateBomb
10436: PPUSH
10437: CALL_OW 104
// end ; end ;
10441: PPOPN 3
10443: END
// on UnitDestroyed ( un ) do begin if un = JMM then
10444: LD_VAR 0 1
10448: PUSH
10449: LD_EXP 17
10453: EQUAL
10454: IFFALSE 10465
// begin YouLost ( JMM ) ;
10456: LD_STRING JMM
10458: PPUSH
10459: CALL_OW 104
// exit ;
10463: GO 10564
// end ; if un = Powell then
10465: LD_VAR 0 1
10469: PUSH
10470: LD_EXP 52
10474: EQUAL
10475: IFFALSE 10485
// americanDestroyed := true ;
10477: LD_ADDR_EXP 4
10481: PUSH
10482: LD_INT 1
10484: ST_TO_ADDR
// if un = Platonov then
10485: LD_VAR 0 1
10489: PUSH
10490: LD_EXP 56
10494: EQUAL
10495: IFFALSE 10505
// russianDestroyed := true ;
10497: LD_ADDR_EXP 2
10501: PUSH
10502: LD_INT 1
10504: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
10505: LD_VAR 0 1
10509: PUSH
10510: LD_INT 22
10512: PUSH
10513: LD_INT 7
10515: PUSH
10516: EMPTY
10517: LIST
10518: LIST
10519: PUSH
10520: LD_INT 21
10522: PUSH
10523: LD_INT 2
10525: PUSH
10526: EMPTY
10527: LIST
10528: LIST
10529: PUSH
10530: EMPTY
10531: LIST
10532: LIST
10533: PPUSH
10534: CALL_OW 69
10538: IN
10539: IFFALSE 10555
// vehicleLostCounter := vehicleLostCounter + 1 ;
10541: LD_ADDR_EXP 15
10545: PUSH
10546: LD_EXP 15
10550: PUSH
10551: LD_INT 1
10553: PLUS
10554: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
10555: LD_VAR 0 1
10559: PPUSH
10560: CALL 47803 0 1
// end ;
10564: PPOPN 1
10566: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10567: LD_VAR 0 1
10571: PPUSH
10572: LD_VAR 0 2
10576: PPUSH
10577: CALL 50137 0 2
// end ;
10581: PPOPN 2
10583: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10584: LD_VAR 0 1
10588: PPUSH
10589: CALL 49205 0 1
// end ;
10593: PPOPN 1
10595: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
10596: LD_VAR 0 1
10600: PUSH
10601: LD_INT 22
10603: PUSH
10604: LD_INT 8
10606: PUSH
10607: EMPTY
10608: LIST
10609: LIST
10610: PUSH
10611: LD_INT 30
10613: PUSH
10614: LD_INT 2
10616: PUSH
10617: EMPTY
10618: LIST
10619: LIST
10620: PUSH
10621: LD_INT 23
10623: PUSH
10624: LD_INT 3
10626: PUSH
10627: EMPTY
10628: LIST
10629: LIST
10630: PUSH
10631: EMPTY
10632: LIST
10633: LIST
10634: LIST
10635: PPUSH
10636: CALL_OW 69
10640: IN
10641: IFFALSE 10668
// begin ComUpgrade ( building ) ;
10643: LD_VAR 0 1
10647: PPUSH
10648: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
10652: LD_EXP 55
10656: PPUSH
10657: LD_VAR 0 1
10661: PPUSH
10662: CALL 58552 0 2
// exit ;
10666: GO 10677
// end ; MCE_BuildingComplete ( building ) ;
10668: LD_VAR 0 1
10672: PPUSH
10673: CALL 49446 0 1
// end ;
10677: PPOPN 1
10679: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10680: LD_VAR 0 1
10684: PPUSH
10685: LD_VAR 0 2
10689: PPUSH
10690: CALL 47499 0 2
// end ;
10694: PPOPN 2
10696: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10697: LD_VAR 0 1
10701: PPUSH
10702: LD_VAR 0 2
10706: PPUSH
10707: LD_VAR 0 3
10711: PPUSH
10712: LD_VAR 0 4
10716: PPUSH
10717: LD_VAR 0 5
10721: PPUSH
10722: CALL 47119 0 5
// end ;
10726: PPOPN 5
10728: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
10729: LD_VAR 0 1
10733: PPUSH
10734: LD_VAR 0 2
10738: PPUSH
10739: CALL 46715 0 2
// end ;
10743: PPOPN 2
10745: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10746: LD_VAR 0 1
10750: PPUSH
10751: LD_VAR 0 2
10755: PPUSH
10756: LD_VAR 0 3
10760: PPUSH
10761: LD_VAR 0 4
10765: PPUSH
10766: CALL 46553 0 4
// end ;
10770: PPOPN 4
10772: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10773: LD_VAR 0 1
10777: PPUSH
10778: LD_VAR 0 2
10782: PPUSH
10783: LD_VAR 0 3
10787: PPUSH
10788: CALL 46328 0 3
// end ;
10792: PPOPN 3
10794: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10795: LD_VAR 0 1
10799: PPUSH
10800: LD_VAR 0 2
10804: PPUSH
10805: CALL 46213 0 2
// end ;
10809: PPOPN 2
10811: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10812: LD_VAR 0 1
10816: PPUSH
10817: LD_VAR 0 2
10821: PPUSH
10822: CALL 50398 0 2
// end ;
10826: PPOPN 2
10828: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10829: LD_VAR 0 1
10833: PPUSH
10834: LD_VAR 0 2
10838: PPUSH
10839: LD_VAR 0 3
10843: PPUSH
10844: LD_VAR 0 4
10848: PPUSH
10849: CALL 50614 0 4
// end ;
10853: PPOPN 4
10855: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10856: LD_VAR 0 1
10860: PPUSH
10861: LD_VAR 0 2
10865: PPUSH
10866: CALL 46022 0 2
// end ;
10870: PPOPN 2
10872: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
10873: LD_VAR 0 1
10877: PPUSH
10878: CALL 100840 0 1
// end ; end_of_file
10882: PPOPN 1
10884: END
// export function Action ; begin
10885: LD_INT 0
10887: PPUSH
// InGameOn ;
10888: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
10892: LD_INT 206
10894: PPUSH
10895: LD_INT 11
10897: PPUSH
10898: CALL_OW 86
// wait ( 0 0$1 ) ;
10902: LD_INT 35
10904: PPUSH
10905: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
10909: LD_EXP 17
10913: PPUSH
10914: LD_STRING DStart-JMM-JMM-1
10916: PPUSH
10917: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
10921: LD_EXP 49
10925: PPUSH
10926: LD_STRING DStart-JMM-Bur-1
10928: PPUSH
10929: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
10933: LD_EXP 17
10937: PPUSH
10938: LD_STRING DStart-JMM-JMM-2
10940: PPUSH
10941: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
10945: LD_EXP 49
10949: PPUSH
10950: LD_STRING DStart-JMM-Bur-2
10952: PPUSH
10953: CALL_OW 88
// InGameOff ;
10957: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
10961: LD_STRING MStart
10963: PPUSH
10964: CALL_OW 337
// SaveForQuickRestart ;
10968: CALL_OW 22
// end ;
10972: LD_VAR 0 1
10976: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
10977: LD_INT 7
10979: PPUSH
10980: LD_INT 255
10982: PPUSH
10983: LD_INT 219
10985: PPUSH
10986: CALL_OW 293
10990: IFFALSE 11599
10992: GO 10994
10994: DISABLE
10995: LD_INT 0
10997: PPUSH
// begin wait ( 0 0$3 ) ;
10998: LD_INT 105
11000: PPUSH
11001: CALL_OW 67
// alienSpotted := true ;
11005: LD_ADDR_EXP 10
11009: PUSH
11010: LD_INT 1
11012: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
11013: LD_ADDR_VAR 0 1
11017: PUSH
11018: LD_INT 22
11020: PUSH
11021: LD_INT 7
11023: PUSH
11024: EMPTY
11025: LIST
11026: LIST
11027: PUSH
11028: LD_INT 23
11030: PUSH
11031: LD_INT 3
11033: PUSH
11034: EMPTY
11035: LIST
11036: LIST
11037: PUSH
11038: LD_INT 21
11040: PUSH
11041: LD_INT 1
11043: PUSH
11044: EMPTY
11045: LIST
11046: LIST
11047: PUSH
11048: LD_INT 26
11050: PUSH
11051: LD_INT 1
11053: PUSH
11054: EMPTY
11055: LIST
11056: LIST
11057: PUSH
11058: EMPTY
11059: LIST
11060: LIST
11061: LIST
11062: LIST
11063: PPUSH
11064: CALL_OW 69
11068: PUSH
11069: LD_EXP 49
11073: PUSH
11074: LD_EXP 37
11078: PUSH
11079: LD_EXP 39
11083: PUSH
11084: LD_EXP 40
11088: PUSH
11089: LD_EXP 47
11093: PUSH
11094: LD_EXP 46
11098: PUSH
11099: LD_EXP 41
11103: PUSH
11104: EMPTY
11105: LIST
11106: LIST
11107: LIST
11108: LIST
11109: LIST
11110: LIST
11111: LIST
11112: DIFF
11113: ST_TO_ADDR
// DialogueOn ;
11114: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
11118: LD_INT 255
11120: PPUSH
11121: LD_INT 219
11123: PPUSH
11124: LD_INT 7
11126: PPUSH
11127: LD_INT 20
11129: NEG
11130: PPUSH
11131: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
11135: LD_INT 255
11137: PPUSH
11138: LD_INT 219
11140: PPUSH
11141: CALL_OW 86
// if speaker then
11145: LD_VAR 0 1
11149: IFFALSE 11167
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
11151: LD_VAR 0 1
11155: PUSH
11156: LD_INT 1
11158: ARRAY
11159: PPUSH
11160: LD_STRING DAlienBase-RSol1-1
11162: PPUSH
11163: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
11167: LD_EXP 17
11171: PPUSH
11172: LD_STRING DAlienBase-JMM-1
11174: PPUSH
11175: CALL_OW 88
// if IsOk ( Burlak ) then
11179: LD_EXP 49
11183: PPUSH
11184: CALL_OW 302
11188: IFFALSE 11209
// begin dwait ( 0 0$1 ) ;
11190: LD_INT 35
11192: PPUSH
11193: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
11197: LD_EXP 49
11201: PPUSH
11202: LD_STRING DAlienBase-Bur-1
11204: PPUSH
11205: CALL_OW 88
// end ; if IsOk ( Roth ) then
11209: LD_EXP 18
11213: PPUSH
11214: CALL_OW 302
11218: IFFALSE 11232
// Say ( Roth , DAlienBase-Roth-1 ) ;
11220: LD_EXP 18
11224: PPUSH
11225: LD_STRING DAlienBase-Roth-1
11227: PPUSH
11228: CALL_OW 88
// if IsOk ( Gossudarov ) then
11232: LD_EXP 35
11236: PPUSH
11237: CALL_OW 302
11241: IFFALSE 11257
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
11243: LD_EXP 35
11247: PPUSH
11248: LD_STRING DAlienBase-Gos-1
11250: PPUSH
11251: CALL_OW 88
11255: GO 11374
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11257: LD_ADDR_VAR 0 1
11261: PUSH
11262: LD_INT 22
11264: PUSH
11265: LD_INT 7
11267: PUSH
11268: EMPTY
11269: LIST
11270: LIST
11271: PUSH
11272: LD_INT 25
11274: PUSH
11275: LD_INT 4
11277: PUSH
11278: EMPTY
11279: LIST
11280: LIST
11281: PUSH
11282: LD_INT 21
11284: PUSH
11285: LD_INT 1
11287: PUSH
11288: EMPTY
11289: LIST
11290: LIST
11291: PUSH
11292: LD_INT 26
11294: PUSH
11295: LD_INT 1
11297: PUSH
11298: EMPTY
11299: LIST
11300: LIST
11301: PUSH
11302: EMPTY
11303: LIST
11304: LIST
11305: LIST
11306: LIST
11307: PPUSH
11308: CALL_OW 69
11312: PUSH
11313: LD_EXP 18
11317: PUSH
11318: LD_EXP 17
11322: PUSH
11323: LD_EXP 49
11327: PUSH
11328: LD_EXP 37
11332: PUSH
11333: LD_EXP 47
11337: PUSH
11338: LD_EXP 46
11342: PUSH
11343: EMPTY
11344: LIST
11345: LIST
11346: LIST
11347: LIST
11348: LIST
11349: LIST
11350: DIFF
11351: ST_TO_ADDR
// if speaker then
11352: LD_VAR 0 1
11356: IFFALSE 11374
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
11358: LD_VAR 0 1
11362: PUSH
11363: LD_INT 1
11365: ARRAY
11366: PPUSH
11367: LD_STRING DAlienBase-Sci1-1
11369: PPUSH
11370: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
11374: LD_INT 255
11376: PPUSH
11377: LD_INT 219
11379: PPUSH
11380: LD_INT 7
11382: PPUSH
11383: CALL_OW 331
// DialogueOff ;
11387: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
11391: LD_INT 35
11393: PPUSH
11394: CALL_OW 67
// until IsSelected ( alien ) ;
11398: LD_INT 1
11400: PPUSH
11401: CALL_OW 306
11405: IFFALSE 11391
// if not artifactIResearched or not artifactIIResearched then
11407: LD_EXP 12
11411: NOT
11412: PUSH
11413: LD_EXP 13
11417: NOT
11418: OR
11419: IFFALSE 11599
// begin if IsOk ( Roth ) then
11421: LD_EXP 18
11425: PPUSH
11426: CALL_OW 302
11430: IFFALSE 11446
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
11432: LD_EXP 18
11436: PPUSH
11437: LD_STRING DAlieBaseNotReady-Roth-1
11439: PPUSH
11440: CALL_OW 88
11444: GO 11599
// if IsOk ( Gossudarov ) then
11446: LD_EXP 35
11450: PPUSH
11451: CALL_OW 302
11455: IFFALSE 11471
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
11457: LD_EXP 35
11461: PPUSH
11462: LD_STRING DAlieBaseNotReady-Gos-1
11464: PPUSH
11465: CALL_OW 88
11469: GO 11599
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11471: LD_ADDR_VAR 0 1
11475: PUSH
11476: LD_INT 22
11478: PUSH
11479: LD_INT 7
11481: PUSH
11482: EMPTY
11483: LIST
11484: LIST
11485: PUSH
11486: LD_INT 23
11488: PUSH
11489: LD_INT 3
11491: PUSH
11492: EMPTY
11493: LIST
11494: LIST
11495: PUSH
11496: LD_INT 25
11498: PUSH
11499: LD_INT 4
11501: PUSH
11502: EMPTY
11503: LIST
11504: LIST
11505: PUSH
11506: LD_INT 21
11508: PUSH
11509: LD_INT 1
11511: PUSH
11512: EMPTY
11513: LIST
11514: LIST
11515: PUSH
11516: LD_INT 26
11518: PUSH
11519: LD_INT 1
11521: PUSH
11522: EMPTY
11523: LIST
11524: LIST
11525: PUSH
11526: EMPTY
11527: LIST
11528: LIST
11529: LIST
11530: LIST
11531: LIST
11532: PPUSH
11533: CALL_OW 69
11537: PUSH
11538: LD_EXP 18
11542: PUSH
11543: LD_EXP 17
11547: PUSH
11548: LD_EXP 49
11552: PUSH
11553: LD_EXP 37
11557: PUSH
11558: LD_EXP 47
11562: PUSH
11563: LD_EXP 46
11567: PUSH
11568: EMPTY
11569: LIST
11570: LIST
11571: LIST
11572: LIST
11573: LIST
11574: LIST
11575: DIFF
11576: ST_TO_ADDR
// if speaker then
11577: LD_VAR 0 1
11581: IFFALSE 11599
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
11583: LD_VAR 0 1
11587: PUSH
11588: LD_INT 1
11590: ARRAY
11591: PPUSH
11592: LD_STRING DAlieBaseNotReady-RSci1-1
11594: PPUSH
11595: CALL_OW 88
// end ; end ; end ;
11599: PPOPN 1
11601: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
11602: LD_INT 24
11604: PPUSH
11605: LD_INT 7
11607: PPUSH
11608: CALL_OW 321
11612: PUSH
11613: LD_INT 2
11615: EQUAL
11616: IFFALSE 12307
11618: GO 11620
11620: DISABLE
11621: LD_INT 0
11623: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11624: LD_ADDR_VAR 0 1
11628: PUSH
11629: LD_INT 22
11631: PUSH
11632: LD_INT 7
11634: PUSH
11635: EMPTY
11636: LIST
11637: LIST
11638: PUSH
11639: LD_INT 23
11641: PUSH
11642: LD_INT 3
11644: PUSH
11645: EMPTY
11646: LIST
11647: LIST
11648: PUSH
11649: LD_INT 25
11651: PUSH
11652: LD_INT 4
11654: PUSH
11655: EMPTY
11656: LIST
11657: LIST
11658: PUSH
11659: LD_INT 21
11661: PUSH
11662: LD_INT 1
11664: PUSH
11665: EMPTY
11666: LIST
11667: LIST
11668: PUSH
11669: LD_INT 26
11671: PUSH
11672: LD_INT 1
11674: PUSH
11675: EMPTY
11676: LIST
11677: LIST
11678: PUSH
11679: EMPTY
11680: LIST
11681: LIST
11682: LIST
11683: LIST
11684: LIST
11685: PPUSH
11686: CALL_OW 69
11690: PUSH
11691: LD_EXP 18
11695: PUSH
11696: LD_EXP 17
11700: PUSH
11701: LD_EXP 49
11705: PUSH
11706: LD_EXP 37
11710: PUSH
11711: LD_EXP 47
11715: PUSH
11716: LD_EXP 46
11720: PUSH
11721: EMPTY
11722: LIST
11723: LIST
11724: LIST
11725: LIST
11726: LIST
11727: LIST
11728: DIFF
11729: ST_TO_ADDR
// if not speaker then
11730: LD_VAR 0 1
11734: NOT
11735: IFFALSE 11739
// exit ;
11737: GO 12307
// DialogueOn ;
11739: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
11743: LD_VAR 0 1
11747: PUSH
11748: LD_INT 1
11750: ARRAY
11751: PPUSH
11752: LD_STRING DArtefTechnology-RSci1-1
11754: PPUSH
11755: CALL_OW 88
// if IsOk ( Burlak ) then
11759: LD_EXP 49
11763: PPUSH
11764: CALL_OW 302
11768: IFFALSE 11782
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
11770: LD_EXP 49
11774: PPUSH
11775: LD_STRING DArtefTechnology-Bur-1
11777: PPUSH
11778: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
11782: LD_VAR 0 1
11786: PUSH
11787: LD_INT 1
11789: ARRAY
11790: PPUSH
11791: LD_STRING DArtefTechnology-RSci1-2
11793: PPUSH
11794: CALL_OW 88
// if Denis then
11798: LD_EXP 23
11802: IFFALSE 11819
// speaker := [ Denis ] else
11804: LD_ADDR_VAR 0 1
11808: PUSH
11809: LD_EXP 23
11813: PUSH
11814: EMPTY
11815: LIST
11816: ST_TO_ADDR
11817: GO 11925
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11819: LD_ADDR_VAR 0 1
11823: PUSH
11824: LD_INT 22
11826: PUSH
11827: LD_INT 7
11829: PUSH
11830: EMPTY
11831: LIST
11832: LIST
11833: PUSH
11834: LD_INT 23
11836: PUSH
11837: LD_INT 1
11839: PUSH
11840: EMPTY
11841: LIST
11842: LIST
11843: PUSH
11844: LD_INT 25
11846: PUSH
11847: LD_INT 4
11849: PUSH
11850: EMPTY
11851: LIST
11852: LIST
11853: PUSH
11854: LD_INT 21
11856: PUSH
11857: LD_INT 1
11859: PUSH
11860: EMPTY
11861: LIST
11862: LIST
11863: PUSH
11864: LD_INT 26
11866: PUSH
11867: LD_INT 1
11869: PUSH
11870: EMPTY
11871: LIST
11872: LIST
11873: PUSH
11874: EMPTY
11875: LIST
11876: LIST
11877: LIST
11878: LIST
11879: LIST
11880: PPUSH
11881: CALL_OW 69
11885: PUSH
11886: LD_EXP 18
11890: PUSH
11891: LD_EXP 17
11895: PUSH
11896: LD_EXP 49
11900: PUSH
11901: LD_EXP 37
11905: PUSH
11906: LD_EXP 47
11910: PUSH
11911: LD_EXP 46
11915: PUSH
11916: EMPTY
11917: LIST
11918: LIST
11919: LIST
11920: LIST
11921: LIST
11922: LIST
11923: DIFF
11924: ST_TO_ADDR
// if speaker then
11925: LD_VAR 0 1
11929: IFFALSE 11947
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
11931: LD_VAR 0 1
11935: PUSH
11936: LD_INT 1
11938: ARRAY
11939: PPUSH
11940: LD_STRING DArtefTechnology-Sci1-2
11942: PPUSH
11943: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11947: LD_ADDR_VAR 0 1
11951: PUSH
11952: LD_INT 22
11954: PUSH
11955: LD_INT 7
11957: PUSH
11958: EMPTY
11959: LIST
11960: LIST
11961: PUSH
11962: LD_INT 23
11964: PUSH
11965: LD_INT 3
11967: PUSH
11968: EMPTY
11969: LIST
11970: LIST
11971: PUSH
11972: LD_INT 25
11974: PUSH
11975: LD_INT 4
11977: PUSH
11978: EMPTY
11979: LIST
11980: LIST
11981: PUSH
11982: LD_INT 21
11984: PUSH
11985: LD_INT 1
11987: PUSH
11988: EMPTY
11989: LIST
11990: LIST
11991: PUSH
11992: LD_INT 26
11994: PUSH
11995: LD_INT 1
11997: PUSH
11998: EMPTY
11999: LIST
12000: LIST
12001: PUSH
12002: EMPTY
12003: LIST
12004: LIST
12005: LIST
12006: LIST
12007: LIST
12008: PPUSH
12009: CALL_OW 69
12013: PUSH
12014: LD_EXP 18
12018: PUSH
12019: LD_EXP 17
12023: PUSH
12024: LD_EXP 49
12028: PUSH
12029: LD_EXP 37
12033: PUSH
12034: LD_EXP 47
12038: PUSH
12039: LD_EXP 46
12043: PUSH
12044: EMPTY
12045: LIST
12046: LIST
12047: LIST
12048: LIST
12049: LIST
12050: LIST
12051: DIFF
12052: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
12053: LD_VAR 0 1
12057: PUSH
12058: LD_EXP 9
12062: PUSH
12063: LD_EXP 5
12067: OR
12068: AND
12069: IFFALSE 12303
// begin if arabianDestroyed and IsOk ( Burlak ) then
12071: LD_EXP 5
12075: PUSH
12076: LD_EXP 49
12080: PPUSH
12081: CALL_OW 302
12085: AND
12086: IFFALSE 12102
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
12088: LD_EXP 49
12092: PPUSH
12093: LD_STRING DArtefTechnology-Bur-2
12095: PPUSH
12096: CALL_OW 88
12100: GO 12114
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
12102: LD_EXP 17
12106: PPUSH
12107: LD_STRING DArtefTechnology-JMM-2
12109: PPUSH
12110: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
12114: LD_VAR 0 1
12118: PUSH
12119: LD_INT 1
12121: ARRAY
12122: PPUSH
12123: LD_STRING DArtefTechnology-RSci1-3
12125: PPUSH
12126: CALL_OW 88
// if Denis then
12130: LD_EXP 23
12134: IFFALSE 12151
// speaker := [ Denis ] else
12136: LD_ADDR_VAR 0 1
12140: PUSH
12141: LD_EXP 23
12145: PUSH
12146: EMPTY
12147: LIST
12148: ST_TO_ADDR
12149: GO 12257
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12151: LD_ADDR_VAR 0 1
12155: PUSH
12156: LD_INT 22
12158: PUSH
12159: LD_INT 7
12161: PUSH
12162: EMPTY
12163: LIST
12164: LIST
12165: PUSH
12166: LD_INT 23
12168: PUSH
12169: LD_INT 1
12171: PUSH
12172: EMPTY
12173: LIST
12174: LIST
12175: PUSH
12176: LD_INT 25
12178: PUSH
12179: LD_INT 4
12181: PUSH
12182: EMPTY
12183: LIST
12184: LIST
12185: PUSH
12186: LD_INT 21
12188: PUSH
12189: LD_INT 1
12191: PUSH
12192: EMPTY
12193: LIST
12194: LIST
12195: PUSH
12196: LD_INT 26
12198: PUSH
12199: LD_INT 1
12201: PUSH
12202: EMPTY
12203: LIST
12204: LIST
12205: PUSH
12206: EMPTY
12207: LIST
12208: LIST
12209: LIST
12210: LIST
12211: LIST
12212: PPUSH
12213: CALL_OW 69
12217: PUSH
12218: LD_EXP 18
12222: PUSH
12223: LD_EXP 17
12227: PUSH
12228: LD_EXP 49
12232: PUSH
12233: LD_EXP 37
12237: PUSH
12238: LD_EXP 47
12242: PUSH
12243: LD_EXP 46
12247: PUSH
12248: EMPTY
12249: LIST
12250: LIST
12251: LIST
12252: LIST
12253: LIST
12254: LIST
12255: DIFF
12256: ST_TO_ADDR
// if speaker then
12257: LD_VAR 0 1
12261: IFFALSE 12303
// if alienSpotted then
12263: LD_EXP 10
12267: IFFALSE 12287
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
12269: LD_VAR 0 1
12273: PUSH
12274: LD_INT 1
12276: ARRAY
12277: PPUSH
12278: LD_STRING DArtefTechnology-Sci1-3
12280: PPUSH
12281: CALL_OW 88
12285: GO 12303
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
12287: LD_VAR 0 1
12291: PUSH
12292: LD_INT 1
12294: ARRAY
12295: PPUSH
12296: LD_STRING DArtefTechnology-Sci1-3a
12298: PPUSH
12299: CALL_OW 88
// end ; DialogueOff ;
12303: CALL_OW 7
// end ;
12307: PPOPN 1
12309: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
12310: LD_EXP 12
12314: IFFALSE 12509
12316: GO 12318
12318: DISABLE
12319: LD_INT 0
12321: PPUSH
// begin if Denis then
12322: LD_EXP 23
12326: IFFALSE 12343
// speaker := [ Denis ] else
12328: LD_ADDR_VAR 0 1
12332: PUSH
12333: LD_EXP 23
12337: PUSH
12338: EMPTY
12339: LIST
12340: ST_TO_ADDR
12341: GO 12449
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12343: LD_ADDR_VAR 0 1
12347: PUSH
12348: LD_INT 22
12350: PUSH
12351: LD_INT 7
12353: PUSH
12354: EMPTY
12355: LIST
12356: LIST
12357: PUSH
12358: LD_INT 23
12360: PUSH
12361: LD_INT 1
12363: PUSH
12364: EMPTY
12365: LIST
12366: LIST
12367: PUSH
12368: LD_INT 25
12370: PUSH
12371: LD_INT 4
12373: PUSH
12374: EMPTY
12375: LIST
12376: LIST
12377: PUSH
12378: LD_INT 21
12380: PUSH
12381: LD_INT 1
12383: PUSH
12384: EMPTY
12385: LIST
12386: LIST
12387: PUSH
12388: LD_INT 26
12390: PUSH
12391: LD_INT 1
12393: PUSH
12394: EMPTY
12395: LIST
12396: LIST
12397: PUSH
12398: EMPTY
12399: LIST
12400: LIST
12401: LIST
12402: LIST
12403: LIST
12404: PPUSH
12405: CALL_OW 69
12409: PUSH
12410: LD_EXP 18
12414: PUSH
12415: LD_EXP 17
12419: PUSH
12420: LD_EXP 49
12424: PUSH
12425: LD_EXP 37
12429: PUSH
12430: LD_EXP 47
12434: PUSH
12435: LD_EXP 46
12439: PUSH
12440: EMPTY
12441: LIST
12442: LIST
12443: LIST
12444: LIST
12445: LIST
12446: LIST
12447: DIFF
12448: ST_TO_ADDR
// if not speaker then
12449: LD_VAR 0 1
12453: NOT
12454: IFFALSE 12458
// exit ;
12456: GO 12509
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
12458: LD_VAR 0 1
12462: PUSH
12463: LD_INT 1
12465: ARRAY
12466: PPUSH
12467: LD_STRING DArtefTechnologyAm-Sci1-1
12469: PPUSH
12470: CALL_OW 88
// if IsOk ( Burlak ) then
12474: LD_EXP 49
12478: PPUSH
12479: CALL_OW 302
12483: IFFALSE 12497
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
12485: LD_EXP 49
12489: PPUSH
12490: LD_STRING DArtefTechnologyAm-Bur-1
12492: PPUSH
12493: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
12497: LD_EXP 17
12501: PPUSH
12502: LD_STRING DArtefTechnologyAm-JMM-1
12504: PPUSH
12505: CALL_OW 88
// end ;
12509: PPOPN 1
12511: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
12512: LD_EXP 13
12516: IFFALSE 12706
12518: GO 12520
12520: DISABLE
12521: LD_INT 0
12523: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12524: LD_ADDR_VAR 0 1
12528: PUSH
12529: LD_INT 22
12531: PUSH
12532: LD_INT 7
12534: PUSH
12535: EMPTY
12536: LIST
12537: LIST
12538: PUSH
12539: LD_INT 23
12541: PUSH
12542: LD_INT 3
12544: PUSH
12545: EMPTY
12546: LIST
12547: LIST
12548: PUSH
12549: LD_INT 25
12551: PUSH
12552: LD_INT 4
12554: PUSH
12555: EMPTY
12556: LIST
12557: LIST
12558: PUSH
12559: LD_INT 21
12561: PUSH
12562: LD_INT 1
12564: PUSH
12565: EMPTY
12566: LIST
12567: LIST
12568: PUSH
12569: LD_INT 26
12571: PUSH
12572: LD_INT 1
12574: PUSH
12575: EMPTY
12576: LIST
12577: LIST
12578: PUSH
12579: EMPTY
12580: LIST
12581: LIST
12582: LIST
12583: LIST
12584: LIST
12585: PPUSH
12586: CALL_OW 69
12590: PUSH
12591: LD_EXP 18
12595: PUSH
12596: LD_EXP 17
12600: PUSH
12601: LD_EXP 49
12605: PUSH
12606: LD_EXP 37
12610: PUSH
12611: LD_EXP 47
12615: PUSH
12616: LD_EXP 46
12620: PUSH
12621: EMPTY
12622: LIST
12623: LIST
12624: LIST
12625: LIST
12626: LIST
12627: LIST
12628: DIFF
12629: ST_TO_ADDR
// if not speaker then
12630: LD_VAR 0 1
12634: NOT
12635: IFFALSE 12639
// exit ;
12637: GO 12706
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-1 ) ;
12639: LD_VAR 0 1
12643: PUSH
12644: LD_INT 1
12646: ARRAY
12647: PPUSH
12648: LD_STRING DArtefTechnologyRu-RSci1-1
12650: PPUSH
12651: CALL_OW 88
// if IsOk ( Burlak ) then
12655: LD_EXP 49
12659: PPUSH
12660: CALL_OW 302
12664: IFFALSE 12678
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
12666: LD_EXP 49
12670: PPUSH
12671: LD_STRING DArtefTechnologyRu-Bur-1
12673: PPUSH
12674: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-2 ) ;
12678: LD_VAR 0 1
12682: PUSH
12683: LD_INT 1
12685: ARRAY
12686: PPUSH
12687: LD_STRING DArtefTechnologyRu-RSci1-2
12689: PPUSH
12690: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
12694: LD_EXP 17
12698: PPUSH
12699: LD_STRING DArtefTechnologyRu-JMM-1
12701: PPUSH
12702: CALL_OW 88
// end ;
12706: PPOPN 1
12708: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
12709: LD_INT 24
12711: PPUSH
12712: LD_INT 7
12714: PPUSH
12715: CALL_OW 321
12719: PUSH
12720: LD_INT 2
12722: EQUAL
12723: PUSH
12724: LD_INT 1
12726: PPUSH
12727: CALL_OW 255
12731: PUSH
12732: LD_INT 7
12734: EQUAL
12735: AND
12736: IFFALSE 12896
12738: GO 12740
12740: DISABLE
12741: LD_INT 0
12743: PPUSH
// begin if Denis then
12744: LD_EXP 23
12748: IFFALSE 12765
// speaker := [ Denis ] else
12750: LD_ADDR_VAR 0 1
12754: PUSH
12755: LD_EXP 23
12759: PUSH
12760: EMPTY
12761: LIST
12762: ST_TO_ADDR
12763: GO 12871
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12765: LD_ADDR_VAR 0 1
12769: PUSH
12770: LD_INT 22
12772: PUSH
12773: LD_INT 7
12775: PUSH
12776: EMPTY
12777: LIST
12778: LIST
12779: PUSH
12780: LD_INT 23
12782: PUSH
12783: LD_INT 1
12785: PUSH
12786: EMPTY
12787: LIST
12788: LIST
12789: PUSH
12790: LD_INT 25
12792: PUSH
12793: LD_INT 4
12795: PUSH
12796: EMPTY
12797: LIST
12798: LIST
12799: PUSH
12800: LD_INT 21
12802: PUSH
12803: LD_INT 1
12805: PUSH
12806: EMPTY
12807: LIST
12808: LIST
12809: PUSH
12810: LD_INT 26
12812: PUSH
12813: LD_INT 1
12815: PUSH
12816: EMPTY
12817: LIST
12818: LIST
12819: PUSH
12820: EMPTY
12821: LIST
12822: LIST
12823: LIST
12824: LIST
12825: LIST
12826: PPUSH
12827: CALL_OW 69
12831: PUSH
12832: LD_EXP 18
12836: PUSH
12837: LD_EXP 17
12841: PUSH
12842: LD_EXP 49
12846: PUSH
12847: LD_EXP 37
12851: PUSH
12852: LD_EXP 47
12856: PUSH
12857: LD_EXP 46
12861: PUSH
12862: EMPTY
12863: LIST
12864: LIST
12865: LIST
12866: LIST
12867: LIST
12868: LIST
12869: DIFF
12870: ST_TO_ADDR
// if not speaker then
12871: LD_VAR 0 1
12875: NOT
12876: IFFALSE 12880
// exit ;
12878: GO 12896
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
12880: LD_VAR 0 1
12884: PUSH
12885: LD_INT 1
12887: ARRAY
12888: PPUSH
12889: LD_STRING DArtefTechnologyArStart-Sci1-1
12891: PPUSH
12892: CALL_OW 88
// end ;
12896: PPOPN 1
12898: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
12899: LD_EXP 14
12903: IFFALSE 13184
12905: GO 12907
12907: DISABLE
12908: LD_INT 0
12910: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12911: LD_ADDR_VAR 0 1
12915: PUSH
12916: LD_INT 22
12918: PUSH
12919: LD_INT 7
12921: PUSH
12922: EMPTY
12923: LIST
12924: LIST
12925: PUSH
12926: LD_INT 23
12928: PUSH
12929: LD_INT 3
12931: PUSH
12932: EMPTY
12933: LIST
12934: LIST
12935: PUSH
12936: LD_INT 25
12938: PUSH
12939: LD_INT 4
12941: PUSH
12942: EMPTY
12943: LIST
12944: LIST
12945: PUSH
12946: LD_INT 21
12948: PUSH
12949: LD_INT 1
12951: PUSH
12952: EMPTY
12953: LIST
12954: LIST
12955: PUSH
12956: LD_INT 26
12958: PUSH
12959: LD_INT 1
12961: PUSH
12962: EMPTY
12963: LIST
12964: LIST
12965: PUSH
12966: EMPTY
12967: LIST
12968: LIST
12969: LIST
12970: LIST
12971: LIST
12972: PPUSH
12973: CALL_OW 69
12977: PUSH
12978: LD_EXP 18
12982: PUSH
12983: LD_EXP 17
12987: PUSH
12988: LD_EXP 49
12992: PUSH
12993: LD_EXP 37
12997: PUSH
12998: LD_EXP 47
13002: PUSH
13003: LD_EXP 46
13007: PUSH
13008: EMPTY
13009: LIST
13010: LIST
13011: LIST
13012: LIST
13013: LIST
13014: LIST
13015: DIFF
13016: ST_TO_ADDR
// if not speaker then
13017: LD_VAR 0 1
13021: NOT
13022: IFFALSE 13026
// exit ;
13024: GO 13184
// DialogueOn ;
13026: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
13030: LD_VAR 0 1
13034: PUSH
13035: LD_INT 1
13037: ARRAY
13038: PPUSH
13039: LD_STRING DArtefTechnologyAr-RSci1-1
13041: PPUSH
13042: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
13046: LD_EXP 17
13050: PPUSH
13051: LD_STRING DArtefTechnologyAr-JMM-1
13053: PPUSH
13054: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
13058: LD_VAR 0 1
13062: PUSH
13063: LD_INT 1
13065: ARRAY
13066: PPUSH
13067: LD_STRING DArtefTechnologyAr-RSci1-2
13069: PPUSH
13070: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
13074: LD_EXP 17
13078: PPUSH
13079: LD_STRING DArtefTechnologyAr-JMM-2
13081: PPUSH
13082: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
13086: LD_VAR 0 1
13090: PUSH
13091: LD_INT 1
13093: ARRAY
13094: PPUSH
13095: LD_STRING DArtefTechnologyAr-RSci1-3
13097: PPUSH
13098: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
13102: LD_EXP 17
13106: PPUSH
13107: LD_STRING DArtefTechnologyAr-JMM-3
13109: PPUSH
13110: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
13114: LD_VAR 0 1
13118: PUSH
13119: LD_INT 1
13121: ARRAY
13122: PPUSH
13123: LD_STRING DArtefTechnologyAr-RSci1-4
13125: PPUSH
13126: CALL_OW 88
// if IsOk ( Burlak ) then
13130: LD_EXP 49
13134: PPUSH
13135: CALL_OW 302
13139: IFFALSE 13153
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
13141: LD_EXP 49
13145: PPUSH
13146: LD_STRING DArtefTechnologyAr-Bur-4
13148: PPUSH
13149: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
13153: LD_EXP 17
13157: PPUSH
13158: LD_STRING DArtefTechnologyAr-JMM-4
13160: PPUSH
13161: CALL_OW 88
// DialogueOff ;
13165: CALL_OW 7
// wait ( 0 0$45 ) ;
13169: LD_INT 1575
13171: PPUSH
13172: CALL_OW 67
// spawnOmar := true ;
13176: LD_ADDR_EXP 11
13180: PUSH
13181: LD_INT 1
13183: ST_TO_ADDR
// end ;
13184: PPOPN 1
13186: END
// every 0 0$1 trigger spawnOmar do
13187: LD_EXP 11
13191: IFFALSE 13571
13193: GO 13195
13195: DISABLE
// begin PrepareOmarAli ;
13196: CALL 6705 0 0
// if not HasTask ( Omar ) then
13200: LD_EXP 53
13204: PPUSH
13205: CALL_OW 314
13209: NOT
13210: IFFALSE 13227
// ComMoveXY ( Omar , 252 , 220 ) ;
13212: LD_EXP 53
13216: PPUSH
13217: LD_INT 252
13219: PPUSH
13220: LD_INT 220
13222: PPUSH
13223: CALL_OW 111
// if not Omar then
13227: LD_EXP 53
13231: NOT
13232: IFFALSE 13236
// exit ;
13234: GO 13571
// repeat wait ( 0 0$1 ) ;
13236: LD_INT 35
13238: PPUSH
13239: CALL_OW 67
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
13243: LD_EXP 53
13247: PPUSH
13248: CALL_OW 314
13252: NOT
13253: PUSH
13254: LD_EXP 53
13258: PPUSH
13259: LD_INT 252
13261: PPUSH
13262: LD_INT 220
13264: PPUSH
13265: CALL_OW 297
13269: PUSH
13270: LD_INT 6
13272: GREATER
13273: AND
13274: IFFALSE 13291
// ComMoveXY ( Omar , 252 , 220 ) ;
13276: LD_EXP 53
13280: PPUSH
13281: LD_INT 252
13283: PPUSH
13284: LD_INT 220
13286: PPUSH
13287: CALL_OW 111
// until See ( 7 , Omar ) ;
13291: LD_INT 7
13293: PPUSH
13294: LD_EXP 53
13298: PPUSH
13299: CALL_OW 292
13303: IFFALSE 13236
// CenterNowOnUnits ( Omar ) ;
13305: LD_EXP 53
13309: PPUSH
13310: CALL_OW 87
// DialogueOn ;
13314: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
13318: LD_EXP 53
13322: PPUSH
13323: LD_STRING DOmar-Omar-1
13325: PPUSH
13326: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
13330: LD_EXP 17
13334: PPUSH
13335: LD_STRING DOmar-JMM-1
13337: PPUSH
13338: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
13342: LD_EXP 53
13346: PPUSH
13347: LD_STRING DOmar-Omar-2
13349: PPUSH
13350: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
13354: LD_EXP 17
13358: PPUSH
13359: LD_STRING DOmar-JMM-2
13361: PPUSH
13362: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
13366: LD_EXP 53
13370: PPUSH
13371: LD_STRING DOmar-Omar-3
13373: PPUSH
13374: CALL_OW 88
// if IsOk ( Burlak ) then
13378: LD_EXP 49
13382: PPUSH
13383: CALL_OW 302
13387: IFFALSE 13403
// Say ( Burlak , DOmar-Bur-3 ) else
13389: LD_EXP 49
13393: PPUSH
13394: LD_STRING DOmar-Bur-3
13396: PPUSH
13397: CALL_OW 88
13401: GO 13415
// Say ( JMM , DOmar-JMM-3 ) ;
13403: LD_EXP 17
13407: PPUSH
13408: LD_STRING DOmar-JMM-3
13410: PPUSH
13411: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
13415: LD_EXP 53
13419: PPUSH
13420: LD_STRING DOmar-Omar-4
13422: PPUSH
13423: CALL_OW 88
// case Query ( QAccept ) of 1 :
13427: LD_STRING QAccept
13429: PPUSH
13430: CALL_OW 97
13434: PUSH
13435: LD_INT 1
13437: DOUBLE
13438: EQUAL
13439: IFTRUE 13443
13441: GO 13479
13443: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
13444: LD_EXP 17
13448: PPUSH
13449: LD_STRING DQrAccept#1-JMM-1
13451: PPUSH
13452: CALL_OW 88
// SetSide ( Omar , 7 ) ;
13456: LD_EXP 53
13460: PPUSH
13461: LD_INT 7
13463: PPUSH
13464: CALL_OW 235
// ComStop ( Omar ) ;
13468: LD_EXP 53
13472: PPUSH
13473: CALL_OW 141
// end ; 2 :
13477: GO 13528
13479: LD_INT 2
13481: DOUBLE
13482: EQUAL
13483: IFTRUE 13487
13485: GO 13527
13487: POP
// begin if IsOk ( Burlak ) then
13488: LD_EXP 49
13492: PPUSH
13493: CALL_OW 302
13497: IFFALSE 13513
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
13499: LD_EXP 49
13503: PPUSH
13504: LD_STRING DQrAccept#2-Bur-1
13506: PPUSH
13507: CALL_OW 88
13511: GO 13525
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
13513: LD_EXP 17
13517: PPUSH
13518: LD_STRING DQrAccept#2-JMM-1
13520: PPUSH
13521: CALL_OW 88
// end ; end ;
13525: GO 13528
13527: POP
// DialogueOff ;
13528: CALL_OW 7
// if GetSide ( Omar ) = 7 then
13532: LD_EXP 53
13536: PPUSH
13537: CALL_OW 255
13541: PUSH
13542: LD_INT 7
13544: EQUAL
13545: IFFALSE 13556
// begin SetAchievement ( ACH_OMAR ) ;
13547: LD_STRING ACH_OMAR
13549: PPUSH
13550: CALL_OW 543
// exit ;
13554: GO 13571
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
13556: LD_EXP 53
13560: PPUSH
13561: LD_INT 202
13563: PPUSH
13564: LD_INT 115
13566: PPUSH
13567: CALL_OW 111
// end ;
13571: END
// every 0 0$1 trigger GetDistUnitXY ( Omar , 200 , 98 ) < 40 and russianDestroyed do
13572: LD_EXP 53
13576: PPUSH
13577: LD_INT 200
13579: PPUSH
13580: LD_INT 98
13582: PPUSH
13583: CALL_OW 297
13587: PUSH
13588: LD_INT 40
13590: LESS
13591: PUSH
13592: LD_EXP 2
13596: AND
13597: IFFALSE 13815
13599: GO 13601
13601: DISABLE
// begin SetSide ( Omar , 5 ) ;
13602: LD_EXP 53
13606: PPUSH
13607: LD_INT 5
13609: PPUSH
13610: CALL_OW 235
// if IsInUnit ( Omar ) then
13614: LD_EXP 53
13618: PPUSH
13619: CALL_OW 310
13623: IFFALSE 13634
// ComExitVehicle ( Omar ) ;
13625: LD_EXP 53
13629: PPUSH
13630: CALL_OW 121
// if IsInUnit ( Omar ) then
13634: LD_EXP 53
13638: PPUSH
13639: CALL_OW 310
13643: IFFALSE 13654
// ComExitBuilding ( Omar ) ;
13645: LD_EXP 53
13649: PPUSH
13650: CALL_OW 122
// wait ( 0 0$1 ) ;
13654: LD_INT 35
13656: PPUSH
13657: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
13661: LD_EXP 53
13665: PPUSH
13666: LD_INT 203
13668: PPUSH
13669: LD_INT 120
13671: PPUSH
13672: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
13676: LD_INT 35
13678: PPUSH
13679: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 6 ;
13683: LD_EXP 53
13687: PPUSH
13688: CALL_OW 306
13692: PUSH
13693: LD_EXP 53
13697: PPUSH
13698: LD_INT 203
13700: PPUSH
13701: LD_INT 120
13703: PPUSH
13704: CALL_OW 297
13708: PUSH
13709: LD_INT 6
13711: LESS
13712: OR
13713: IFFALSE 13676
// CenterNowOnUnits ( Omar ) ;
13715: LD_EXP 53
13719: PPUSH
13720: CALL_OW 87
// DialogueOn ;
13724: CALL_OW 6
// Say ( JMM , DOmarContam-JMM-1 ) ;
13728: LD_EXP 17
13732: PPUSH
13733: LD_STRING DOmarContam-JMM-1
13735: PPUSH
13736: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
13740: LD_EXP 53
13744: PPUSH
13745: LD_STRING DOmarContam-Omar-1
13747: PPUSH
13748: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
13752: LD_EXP 17
13756: PPUSH
13757: LD_STRING DOmarContam-JMM-2
13759: PPUSH
13760: CALL_OW 88
// DialogueOff ;
13764: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
13768: LD_INT 5
13770: PPUSH
13771: LD_INT 7
13773: PPUSH
13774: LD_INT 2
13776: PPUSH
13777: LD_INT 1
13779: PPUSH
13780: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
13784: LD_INT 105
13786: PPUSH
13787: CALL_OW 67
// until IsAt ( Omar , 203 , 120 ) ;
13791: LD_EXP 53
13795: PPUSH
13796: LD_INT 203
13798: PPUSH
13799: LD_INT 120
13801: PPUSH
13802: CALL_OW 307
13806: IFFALSE 13784
// YouLost ( MothContaminate ) ;
13808: LD_STRING MothContaminate
13810: PPUSH
13811: CALL_OW 104
// end ;
13815: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
13816: LD_EXP 4
13820: NOT
13821: PUSH
13822: LD_INT 22
13824: PUSH
13825: LD_INT 1
13827: PUSH
13828: EMPTY
13829: LIST
13830: LIST
13831: PUSH
13832: LD_INT 34
13834: PUSH
13835: LD_INT 8
13837: PUSH
13838: EMPTY
13839: LIST
13840: LIST
13841: PUSH
13842: EMPTY
13843: LIST
13844: LIST
13845: PPUSH
13846: CALL_OW 69
13850: AND
13851: IFFALSE 13970
13853: GO 13855
13855: DISABLE
// begin wait ( 0 0$5 ) ;
13856: LD_INT 175
13858: PPUSH
13859: CALL_OW 67
// if not IsOk ( Powell ) or not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
13863: LD_EXP 52
13867: PPUSH
13868: CALL_OW 302
13872: NOT
13873: PUSH
13874: LD_INT 22
13876: PUSH
13877: LD_INT 1
13879: PUSH
13880: EMPTY
13881: LIST
13882: LIST
13883: PUSH
13884: LD_INT 34
13886: PUSH
13887: LD_INT 8
13889: PUSH
13890: EMPTY
13891: LIST
13892: LIST
13893: PUSH
13894: EMPTY
13895: LIST
13896: LIST
13897: PPUSH
13898: CALL_OW 69
13902: NOT
13903: OR
13904: IFFALSE 13908
// exit ;
13906: GO 13970
// DialogueOn ;
13908: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
13912: LD_EXP 52
13916: PPUSH
13917: LD_STRING DWinAmericans-Pow-1
13919: PPUSH
13920: CALL_OW 94
// if IsOk ( Burlak ) then
13924: LD_EXP 49
13928: PPUSH
13929: CALL_OW 302
13933: IFFALSE 13947
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
13935: LD_EXP 49
13939: PPUSH
13940: LD_STRING DWinAmericans-Bur-1
13942: PPUSH
13943: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
13947: LD_EXP 17
13951: PPUSH
13952: LD_STRING DWinAmericans-JMM-1
13954: PPUSH
13955: CALL_OW 88
// DialogueOff ;
13959: CALL_OW 7
// YouLost ( AmBomb ) ;
13963: LD_STRING AmBomb
13965: PPUSH
13966: CALL_OW 104
// end ;
13970: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
13971: LD_EXP 2
13975: NOT
13976: PUSH
13977: LD_INT 22
13979: PUSH
13980: LD_INT 3
13982: PUSH
13983: EMPTY
13984: LIST
13985: LIST
13986: PUSH
13987: LD_INT 34
13989: PUSH
13990: LD_INT 48
13992: PUSH
13993: EMPTY
13994: LIST
13995: LIST
13996: PUSH
13997: EMPTY
13998: LIST
13999: LIST
14000: PPUSH
14001: CALL_OW 69
14005: AND
14006: IFFALSE 14125
14008: GO 14010
14010: DISABLE
// begin wait ( 0 0$5 ) ;
14011: LD_INT 175
14013: PPUSH
14014: CALL_OW 67
// if not IsOk ( Platonov ) or not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
14018: LD_EXP 56
14022: PPUSH
14023: CALL_OW 302
14027: NOT
14028: PUSH
14029: LD_INT 22
14031: PUSH
14032: LD_INT 3
14034: PUSH
14035: EMPTY
14036: LIST
14037: LIST
14038: PUSH
14039: LD_INT 34
14041: PUSH
14042: LD_INT 48
14044: PUSH
14045: EMPTY
14046: LIST
14047: LIST
14048: PUSH
14049: EMPTY
14050: LIST
14051: LIST
14052: PPUSH
14053: CALL_OW 69
14057: NOT
14058: OR
14059: IFFALSE 14063
// exit ;
14061: GO 14125
// DialogueOn ;
14063: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
14067: LD_EXP 56
14071: PPUSH
14072: LD_STRING DWinRussians-Pla-1
14074: PPUSH
14075: CALL_OW 94
// if IsOk ( Burlak ) then
14079: LD_EXP 49
14083: PPUSH
14084: CALL_OW 302
14088: IFFALSE 14102
// Say ( Burlak , DWinRussians-Bur-1 ) ;
14090: LD_EXP 49
14094: PPUSH
14095: LD_STRING DWinRussians-Bur-1
14097: PPUSH
14098: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
14102: LD_EXP 17
14106: PPUSH
14107: LD_STRING DWinRussians-JMM-1
14109: PPUSH
14110: CALL_OW 88
// DialogueOff ;
14114: CALL_OW 7
// YouLost ( RuBomb ) ;
14118: LD_STRING RuBomb
14120: PPUSH
14121: CALL_OW 104
// end ;
14125: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
14126: LD_INT 7
14128: PPUSH
14129: LD_INT 22
14131: PUSH
14132: LD_INT 7
14134: PUSH
14135: EMPTY
14136: LIST
14137: LIST
14138: PPUSH
14139: CALL_OW 70
14143: PUSH
14144: LD_EXP 4
14148: NOT
14149: AND
14150: IFFALSE 14179
14152: GO 14154
14154: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
14155: LD_EXP 52
14159: PPUSH
14160: LD_STRING DSurrenderAmericans-Pow-1
14162: PPUSH
14163: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
14167: LD_EXP 17
14171: PPUSH
14172: LD_STRING DSurrenderAmericans-JMM-1
14174: PPUSH
14175: CALL_OW 88
// end ;
14179: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
14180: LD_INT 2
14182: PPUSH
14183: LD_INT 22
14185: PUSH
14186: LD_INT 7
14188: PUSH
14189: EMPTY
14190: LIST
14191: LIST
14192: PPUSH
14193: CALL_OW 70
14197: PUSH
14198: LD_EXP 2
14202: NOT
14203: AND
14204: PUSH
14205: LD_EXP 49
14209: AND
14210: IFFALSE 14239
14212: GO 14214
14214: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
14215: LD_EXP 56
14219: PPUSH
14220: LD_STRING DSurrenderRussians-Pla-1
14222: PPUSH
14223: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
14227: LD_EXP 49
14231: PPUSH
14232: LD_STRING DSurrenderRussians-Bur-1
14234: PPUSH
14235: CALL_OW 88
// end ;
14239: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
14240: LD_EXP 4
14244: IFFALSE 14627
14246: GO 14248
14248: DISABLE
14249: LD_INT 0
14251: PPUSH
14252: PPUSH
14253: PPUSH
// begin MC_Kill ( 4 ) ;
14254: LD_INT 4
14256: PPUSH
14257: CALL 20967 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
14261: LD_INT 1
14263: PPUSH
14264: LD_INT 7
14266: PPUSH
14267: LD_INT 1
14269: PPUSH
14270: LD_INT 1
14272: PPUSH
14273: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
14277: LD_ADDR_VAR 0 3
14281: PUSH
14282: LD_INT 22
14284: PUSH
14285: LD_INT 1
14287: PUSH
14288: EMPTY
14289: LIST
14290: LIST
14291: PUSH
14292: LD_INT 26
14294: PUSH
14295: LD_INT 1
14297: PUSH
14298: EMPTY
14299: LIST
14300: LIST
14301: PUSH
14302: LD_INT 23
14304: PUSH
14305: LD_INT 1
14307: PUSH
14308: EMPTY
14309: LIST
14310: LIST
14311: PUSH
14312: EMPTY
14313: LIST
14314: LIST
14315: LIST
14316: PPUSH
14317: CALL_OW 69
14321: PUSH
14322: LD_EXP 52
14326: PUSH
14327: LD_EXP 25
14331: PUSH
14332: LD_EXP 22
14336: PUSH
14337: LD_EXP 21
14341: PUSH
14342: LD_EXP 28
14346: PUSH
14347: LD_EXP 26
14351: PUSH
14352: EMPTY
14353: LIST
14354: LIST
14355: LIST
14356: LIST
14357: LIST
14358: LIST
14359: DIFF
14360: ST_TO_ADDR
// if speaker then
14361: LD_VAR 0 3
14365: IFFALSE 14391
// begin DialogueOn ;
14367: CALL_OW 6
// SayRadio ( speaker [ 1 ] , DSurrenderAmericans-Sol1-1a ) ;
14371: LD_VAR 0 3
14375: PUSH
14376: LD_INT 1
14378: ARRAY
14379: PPUSH
14380: LD_STRING DSurrenderAmericans-Sol1-1a
14382: PPUSH
14383: CALL_OW 94
// DialogueOff ;
14387: CALL_OW 7
// end ; americanCapitulated := true ;
14391: LD_ADDR_EXP 6
14395: PUSH
14396: LD_INT 1
14398: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14399: LD_ADDR_VAR 0 2
14403: PUSH
14404: LD_INT 22
14406: PUSH
14407: LD_INT 1
14409: PUSH
14410: EMPTY
14411: LIST
14412: LIST
14413: PUSH
14414: LD_INT 21
14416: PUSH
14417: LD_INT 1
14419: PUSH
14420: EMPTY
14421: LIST
14422: LIST
14423: PUSH
14424: EMPTY
14425: LIST
14426: LIST
14427: PPUSH
14428: CALL_OW 69
14432: PUSH
14433: LD_INT 22
14435: PUSH
14436: LD_INT 1
14438: PUSH
14439: EMPTY
14440: LIST
14441: LIST
14442: PUSH
14443: LD_INT 21
14445: PUSH
14446: LD_INT 2
14448: PUSH
14449: EMPTY
14450: LIST
14451: LIST
14452: PUSH
14453: LD_INT 1
14455: PUSH
14456: EMPTY
14457: LIST
14458: PUSH
14459: EMPTY
14460: LIST
14461: LIST
14462: LIST
14463: PPUSH
14464: CALL_OW 69
14468: ADD
14469: ST_TO_ADDR
// if tmp then
14470: LD_VAR 0 2
14474: IFFALSE 14627
// repeat wait ( 0 0$1 ) ;
14476: LD_INT 35
14478: PPUSH
14479: CALL_OW 67
// for i in tmp do
14483: LD_ADDR_VAR 0 1
14487: PUSH
14488: LD_VAR 0 2
14492: PUSH
14493: FOR_IN
14494: IFFALSE 14576
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14496: LD_VAR 0 1
14500: PPUSH
14501: CALL_OW 310
14505: PUSH
14506: LD_VAR 0 1
14510: PPUSH
14511: CALL_OW 310
14515: PPUSH
14516: CALL_OW 247
14520: PUSH
14521: LD_INT 3
14523: EQUAL
14524: AND
14525: IFFALSE 14536
// ComExitBuilding ( i ) ;
14527: LD_VAR 0 1
14531: PPUSH
14532: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
14536: LD_VAR 0 1
14540: PPUSH
14541: LD_INT 122
14543: PPUSH
14544: LD_INT 242
14546: PPUSH
14547: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
14551: LD_VAR 0 1
14555: PPUSH
14556: LD_INT 35
14558: PPUSH
14559: CALL_OW 308
14563: IFFALSE 14574
// RemoveUnit ( i ) ;
14565: LD_VAR 0 1
14569: PPUSH
14570: CALL_OW 64
// end ;
14574: GO 14493
14576: POP
14577: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14578: LD_INT 22
14580: PUSH
14581: LD_INT 1
14583: PUSH
14584: EMPTY
14585: LIST
14586: LIST
14587: PUSH
14588: LD_INT 2
14590: PUSH
14591: LD_INT 21
14593: PUSH
14594: LD_INT 1
14596: PUSH
14597: EMPTY
14598: LIST
14599: LIST
14600: PUSH
14601: LD_INT 33
14603: PUSH
14604: LD_INT 1
14606: PUSH
14607: EMPTY
14608: LIST
14609: LIST
14610: PUSH
14611: EMPTY
14612: LIST
14613: LIST
14614: LIST
14615: PUSH
14616: EMPTY
14617: LIST
14618: LIST
14619: PPUSH
14620: CALL_OW 69
14624: NOT
14625: IFFALSE 14476
// end ;
14627: PPOPN 3
14629: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
14630: LD_EXP 2
14634: IFFALSE 15035
14636: GO 14638
14638: DISABLE
14639: LD_INT 0
14641: PPUSH
14642: PPUSH
14643: PPUSH
// begin repeat wait ( 0 0$1 ) ;
14644: LD_INT 35
14646: PPUSH
14647: CALL_OW 67
// until IsDead ( Yakotich ) ;
14651: LD_EXP 57
14655: PPUSH
14656: CALL_OW 301
14660: IFFALSE 14644
// MC_Kill ( 2 ) ;
14662: LD_INT 2
14664: PPUSH
14665: CALL 20967 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
14669: LD_INT 3
14671: PPUSH
14672: LD_INT 7
14674: PPUSH
14675: LD_INT 1
14677: PPUSH
14678: LD_INT 1
14680: PPUSH
14681: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff [ Platonov , Yakotich ] ;
14685: LD_ADDR_VAR 0 3
14689: PUSH
14690: LD_INT 22
14692: PUSH
14693: LD_INT 3
14695: PUSH
14696: EMPTY
14697: LIST
14698: LIST
14699: PUSH
14700: LD_INT 26
14702: PUSH
14703: LD_INT 1
14705: PUSH
14706: EMPTY
14707: LIST
14708: LIST
14709: PUSH
14710: LD_INT 23
14712: PUSH
14713: LD_INT 3
14715: PUSH
14716: EMPTY
14717: LIST
14718: LIST
14719: PUSH
14720: EMPTY
14721: LIST
14722: LIST
14723: LIST
14724: PPUSH
14725: CALL_OW 69
14729: PUSH
14730: LD_EXP 56
14734: PUSH
14735: LD_EXP 57
14739: PUSH
14740: EMPTY
14741: LIST
14742: LIST
14743: DIFF
14744: ST_TO_ADDR
// if speaker then
14745: LD_VAR 0 3
14749: IFFALSE 14799
// begin DialogueOn ;
14751: CALL_OW 6
// if Burlak then
14755: LD_EXP 49
14759: IFFALSE 14779
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1 ) else
14761: LD_VAR 0 3
14765: PUSH
14766: LD_INT 1
14768: ARRAY
14769: PPUSH
14770: LD_STRING DSurrenderRussians-RSol1-1
14772: PPUSH
14773: CALL_OW 94
14777: GO 14795
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1a ) ;
14779: LD_VAR 0 3
14783: PUSH
14784: LD_INT 1
14786: ARRAY
14787: PPUSH
14788: LD_STRING DSurrenderRussians-RSol1-1a
14790: PPUSH
14791: CALL_OW 94
// DialogueOff ;
14795: CALL_OW 7
// end ; russianCapitulated := true ;
14799: LD_ADDR_EXP 7
14803: PUSH
14804: LD_INT 1
14806: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14807: LD_ADDR_VAR 0 2
14811: PUSH
14812: LD_INT 22
14814: PUSH
14815: LD_INT 3
14817: PUSH
14818: EMPTY
14819: LIST
14820: LIST
14821: PUSH
14822: LD_INT 21
14824: PUSH
14825: LD_INT 1
14827: PUSH
14828: EMPTY
14829: LIST
14830: LIST
14831: PUSH
14832: EMPTY
14833: LIST
14834: LIST
14835: PPUSH
14836: CALL_OW 69
14840: PUSH
14841: LD_INT 22
14843: PUSH
14844: LD_INT 3
14846: PUSH
14847: EMPTY
14848: LIST
14849: LIST
14850: PUSH
14851: LD_INT 21
14853: PUSH
14854: LD_INT 2
14856: PUSH
14857: EMPTY
14858: LIST
14859: LIST
14860: PUSH
14861: LD_INT 1
14863: PUSH
14864: EMPTY
14865: LIST
14866: PUSH
14867: EMPTY
14868: LIST
14869: LIST
14870: LIST
14871: PPUSH
14872: CALL_OW 69
14876: ADD
14877: ST_TO_ADDR
// if tmp then
14878: LD_VAR 0 2
14882: IFFALSE 15035
// repeat wait ( 0 0$1 ) ;
14884: LD_INT 35
14886: PPUSH
14887: CALL_OW 67
// for i in tmp do
14891: LD_ADDR_VAR 0 1
14895: PUSH
14896: LD_VAR 0 2
14900: PUSH
14901: FOR_IN
14902: IFFALSE 14984
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14904: LD_VAR 0 1
14908: PPUSH
14909: CALL_OW 310
14913: PUSH
14914: LD_VAR 0 1
14918: PPUSH
14919: CALL_OW 310
14923: PPUSH
14924: CALL_OW 247
14928: PUSH
14929: LD_INT 3
14931: EQUAL
14932: AND
14933: IFFALSE 14944
// ComExitBuilding ( i ) ;
14935: LD_VAR 0 1
14939: PPUSH
14940: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
14944: LD_VAR 0 1
14948: PPUSH
14949: LD_INT 154
14951: PPUSH
14952: LD_INT 1
14954: PPUSH
14955: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
14959: LD_VAR 0 1
14963: PPUSH
14964: LD_INT 36
14966: PPUSH
14967: CALL_OW 308
14971: IFFALSE 14982
// RemoveUnit ( i ) ;
14973: LD_VAR 0 1
14977: PPUSH
14978: CALL_OW 64
// end ;
14982: GO 14901
14984: POP
14985: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14986: LD_INT 22
14988: PUSH
14989: LD_INT 3
14991: PUSH
14992: EMPTY
14993: LIST
14994: LIST
14995: PUSH
14996: LD_INT 2
14998: PUSH
14999: LD_INT 21
15001: PUSH
15002: LD_INT 1
15004: PUSH
15005: EMPTY
15006: LIST
15007: LIST
15008: PUSH
15009: LD_INT 33
15011: PUSH
15012: LD_INT 1
15014: PUSH
15015: EMPTY
15016: LIST
15017: LIST
15018: PUSH
15019: EMPTY
15020: LIST
15021: LIST
15022: LIST
15023: PUSH
15024: EMPTY
15025: LIST
15026: LIST
15027: PPUSH
15028: CALL_OW 69
15032: NOT
15033: IFFALSE 14884
// end ;
15035: PPOPN 3
15037: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
15038: LD_INT 22
15040: PUSH
15041: LD_INT 8
15043: PUSH
15044: EMPTY
15045: LIST
15046: LIST
15047: PUSH
15048: LD_INT 21
15050: PUSH
15051: LD_INT 1
15053: PUSH
15054: EMPTY
15055: LIST
15056: LIST
15057: PUSH
15058: LD_INT 23
15060: PUSH
15061: LD_INT 2
15063: PUSH
15064: EMPTY
15065: LIST
15066: LIST
15067: PUSH
15068: EMPTY
15069: LIST
15070: LIST
15071: LIST
15072: PPUSH
15073: CALL_OW 69
15077: PUSH
15078: LD_INT 18
15080: LESS
15081: PUSH
15082: LD_EXP 55
15086: PPUSH
15087: CALL_OW 301
15091: OR
15092: PUSH
15093: LD_INT 324
15095: PPUSH
15096: CALL_OW 255
15100: PUSH
15101: LD_INT 7
15103: EQUAL
15104: OR
15105: IFFALSE 15118
15107: GO 15109
15109: DISABLE
// legionDestroyed := true ;
15110: LD_ADDR_EXP 3
15114: PUSH
15115: LD_INT 1
15117: ST_TO_ADDR
15118: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 do
15119: LD_INT 22
15121: PUSH
15122: LD_INT 2
15124: PUSH
15125: EMPTY
15126: LIST
15127: LIST
15128: PUSH
15129: LD_INT 21
15131: PUSH
15132: LD_INT 1
15134: PUSH
15135: EMPTY
15136: LIST
15137: LIST
15138: PUSH
15139: LD_INT 23
15141: PUSH
15142: LD_INT 2
15144: PUSH
15145: EMPTY
15146: LIST
15147: LIST
15148: PUSH
15149: EMPTY
15150: LIST
15151: LIST
15152: LIST
15153: PPUSH
15154: CALL_OW 69
15158: PUSH
15159: LD_INT 9
15161: LESS
15162: IFFALSE 15175
15164: GO 15166
15166: DISABLE
// arabianDestroyed := true ;
15167: LD_ADDR_EXP 5
15171: PUSH
15172: LD_INT 1
15174: ST_TO_ADDR
15175: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
15176: LD_EXP 5
15180: IFFALSE 15424
15182: GO 15184
15184: DISABLE
15185: LD_INT 0
15187: PPUSH
15188: PPUSH
// begin MC_Kill ( 1 ) ;
15189: LD_INT 1
15191: PPUSH
15192: CALL 20967 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15196: LD_ADDR_VAR 0 2
15200: PUSH
15201: LD_INT 22
15203: PUSH
15204: LD_INT 2
15206: PUSH
15207: EMPTY
15208: LIST
15209: LIST
15210: PUSH
15211: LD_INT 21
15213: PUSH
15214: LD_INT 1
15216: PUSH
15217: EMPTY
15218: LIST
15219: LIST
15220: PUSH
15221: EMPTY
15222: LIST
15223: LIST
15224: PPUSH
15225: CALL_OW 69
15229: PUSH
15230: LD_INT 22
15232: PUSH
15233: LD_INT 8
15235: PUSH
15236: EMPTY
15237: LIST
15238: LIST
15239: PUSH
15240: LD_INT 21
15242: PUSH
15243: LD_INT 2
15245: PUSH
15246: EMPTY
15247: LIST
15248: LIST
15249: PUSH
15250: LD_INT 1
15252: PUSH
15253: EMPTY
15254: LIST
15255: PUSH
15256: EMPTY
15257: LIST
15258: LIST
15259: LIST
15260: PPUSH
15261: CALL_OW 69
15265: ADD
15266: ST_TO_ADDR
// if tmp then
15267: LD_VAR 0 2
15271: IFFALSE 15424
// repeat wait ( 0 0$1 ) ;
15273: LD_INT 35
15275: PPUSH
15276: CALL_OW 67
// for i in tmp do
15280: LD_ADDR_VAR 0 1
15284: PUSH
15285: LD_VAR 0 2
15289: PUSH
15290: FOR_IN
15291: IFFALSE 15373
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15293: LD_VAR 0 1
15297: PPUSH
15298: CALL_OW 310
15302: PUSH
15303: LD_VAR 0 1
15307: PPUSH
15308: CALL_OW 310
15312: PPUSH
15313: CALL_OW 247
15317: PUSH
15318: LD_INT 3
15320: EQUAL
15321: AND
15322: IFFALSE 15333
// ComExitBuilding ( i ) ;
15324: LD_VAR 0 1
15328: PPUSH
15329: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
15333: LD_VAR 0 1
15337: PPUSH
15338: LD_INT 254
15340: PPUSH
15341: LD_INT 268
15343: PPUSH
15344: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
15348: LD_VAR 0 1
15352: PPUSH
15353: LD_INT 34
15355: PPUSH
15356: CALL_OW 308
15360: IFFALSE 15371
// RemoveUnit ( i ) ;
15362: LD_VAR 0 1
15366: PPUSH
15367: CALL_OW 64
// end ;
15371: GO 15290
15373: POP
15374: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15375: LD_INT 22
15377: PUSH
15378: LD_INT 2
15380: PUSH
15381: EMPTY
15382: LIST
15383: LIST
15384: PUSH
15385: LD_INT 2
15387: PUSH
15388: LD_INT 21
15390: PUSH
15391: LD_INT 1
15393: PUSH
15394: EMPTY
15395: LIST
15396: LIST
15397: PUSH
15398: LD_INT 33
15400: PUSH
15401: LD_INT 1
15403: PUSH
15404: EMPTY
15405: LIST
15406: LIST
15407: PUSH
15408: EMPTY
15409: LIST
15410: LIST
15411: LIST
15412: PUSH
15413: EMPTY
15414: LIST
15415: LIST
15416: PPUSH
15417: CALL_OW 69
15421: NOT
15422: IFFALSE 15273
// end ;
15424: PPOPN 2
15426: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
15427: LD_EXP 3
15431: IFFALSE 15783
15433: GO 15435
15435: DISABLE
15436: LD_INT 0
15438: PPUSH
15439: PPUSH
// begin MC_Kill ( 3 ) ;
15440: LD_INT 3
15442: PPUSH
15443: CALL 20967 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
15447: LD_INT 8
15449: PPUSH
15450: LD_INT 7
15452: PPUSH
15453: LD_INT 1
15455: PPUSH
15456: LD_INT 1
15458: PPUSH
15459: CALL_OW 80
// DialogueOn ;
15463: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
15467: LD_EXP 54
15471: PPUSH
15472: LD_STRING D15-Szulc-1
15474: PPUSH
15475: CALL_OW 94
// DialogueOff ;
15479: CALL_OW 7
// legionCapitulated := true ;
15483: LD_ADDR_EXP 8
15487: PUSH
15488: LD_INT 1
15490: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
15491: LD_ADDR_VAR 0 1
15495: PUSH
15496: LD_INT 22
15498: PUSH
15499: LD_INT 8
15501: PUSH
15502: EMPTY
15503: LIST
15504: LIST
15505: PUSH
15506: LD_INT 21
15508: PUSH
15509: LD_INT 3
15511: PUSH
15512: EMPTY
15513: LIST
15514: LIST
15515: PUSH
15516: LD_INT 23
15518: PUSH
15519: LD_INT 3
15521: PUSH
15522: EMPTY
15523: LIST
15524: LIST
15525: PUSH
15526: EMPTY
15527: LIST
15528: LIST
15529: LIST
15530: PPUSH
15531: CALL_OW 69
15535: PUSH
15536: FOR_IN
15537: IFFALSE 15553
// SetLives ( i , 3 ) ;
15539: LD_VAR 0 1
15543: PPUSH
15544: LD_INT 3
15546: PPUSH
15547: CALL_OW 234
15551: GO 15536
15553: POP
15554: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15555: LD_ADDR_VAR 0 2
15559: PUSH
15560: LD_INT 22
15562: PUSH
15563: LD_INT 8
15565: PUSH
15566: EMPTY
15567: LIST
15568: LIST
15569: PUSH
15570: LD_INT 21
15572: PUSH
15573: LD_INT 1
15575: PUSH
15576: EMPTY
15577: LIST
15578: LIST
15579: PUSH
15580: EMPTY
15581: LIST
15582: LIST
15583: PPUSH
15584: CALL_OW 69
15588: PUSH
15589: LD_INT 22
15591: PUSH
15592: LD_INT 8
15594: PUSH
15595: EMPTY
15596: LIST
15597: LIST
15598: PUSH
15599: LD_INT 21
15601: PUSH
15602: LD_INT 2
15604: PUSH
15605: EMPTY
15606: LIST
15607: LIST
15608: PUSH
15609: LD_INT 1
15611: PUSH
15612: EMPTY
15613: LIST
15614: PUSH
15615: EMPTY
15616: LIST
15617: LIST
15618: LIST
15619: PPUSH
15620: CALL_OW 69
15624: ADD
15625: ST_TO_ADDR
// if tmp then
15626: LD_VAR 0 2
15630: IFFALSE 15783
// repeat wait ( 0 0$1 ) ;
15632: LD_INT 35
15634: PPUSH
15635: CALL_OW 67
// for i in tmp do
15639: LD_ADDR_VAR 0 1
15643: PUSH
15644: LD_VAR 0 2
15648: PUSH
15649: FOR_IN
15650: IFFALSE 15732
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15652: LD_VAR 0 1
15656: PPUSH
15657: CALL_OW 310
15661: PUSH
15662: LD_VAR 0 1
15666: PPUSH
15667: CALL_OW 310
15671: PPUSH
15672: CALL_OW 247
15676: PUSH
15677: LD_INT 3
15679: EQUAL
15680: AND
15681: IFFALSE 15692
// ComExitBuilding ( i ) ;
15683: LD_VAR 0 1
15687: PPUSH
15688: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
15692: LD_VAR 0 1
15696: PPUSH
15697: LD_INT 10
15699: PPUSH
15700: LD_INT 1
15702: PPUSH
15703: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
15707: LD_VAR 0 1
15711: PPUSH
15712: LD_INT 32
15714: PPUSH
15715: CALL_OW 308
15719: IFFALSE 15730
// RemoveUnit ( i ) ;
15721: LD_VAR 0 1
15725: PPUSH
15726: CALL_OW 64
// end ;
15730: GO 15649
15732: POP
15733: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15734: LD_INT 22
15736: PUSH
15737: LD_INT 8
15739: PUSH
15740: EMPTY
15741: LIST
15742: LIST
15743: PUSH
15744: LD_INT 2
15746: PUSH
15747: LD_INT 21
15749: PUSH
15750: LD_INT 1
15752: PUSH
15753: EMPTY
15754: LIST
15755: LIST
15756: PUSH
15757: LD_INT 33
15759: PUSH
15760: LD_INT 1
15762: PUSH
15763: EMPTY
15764: LIST
15765: LIST
15766: PUSH
15767: EMPTY
15768: LIST
15769: LIST
15770: LIST
15771: PUSH
15772: EMPTY
15773: LIST
15774: LIST
15775: PPUSH
15776: CALL_OW 69
15780: NOT
15781: IFFALSE 15632
// end ;
15783: PPOPN 2
15785: END
// every 0 0$5 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated and ( GetSide ( Omar ) <> 5 or IsDead ( Omar ) or not IsPlaced ( Omar ) ) do var med1 , med2 ;
15786: LD_EXP 4
15790: PUSH
15791: LD_EXP 2
15795: AND
15796: PUSH
15797: LD_EXP 3
15801: AND
15802: PUSH
15803: LD_EXP 5
15807: AND
15808: PUSH
15809: LD_EXP 6
15813: AND
15814: PUSH
15815: LD_EXP 7
15819: AND
15820: PUSH
15821: LD_EXP 8
15825: AND
15826: PUSH
15827: LD_EXP 53
15831: PPUSH
15832: CALL_OW 255
15836: PUSH
15837: LD_INT 5
15839: NONEQUAL
15840: PUSH
15841: LD_EXP 53
15845: PPUSH
15846: CALL_OW 301
15850: OR
15851: PUSH
15852: LD_EXP 53
15856: PPUSH
15857: CALL_OW 305
15861: NOT
15862: OR
15863: AND
15864: IFFALSE 17255
15866: GO 15868
15868: DISABLE
15869: LD_INT 0
15871: PPUSH
15872: PPUSH
// begin wait ( 0 0$5 ) ;
15873: LD_INT 175
15875: PPUSH
15876: CALL_OW 67
// music_class := 5 ;
15880: LD_ADDR_OWVAR 72
15884: PUSH
15885: LD_INT 5
15887: ST_TO_ADDR
// music_nat := 5 ;
15888: LD_ADDR_OWVAR 71
15892: PUSH
15893: LD_INT 5
15895: ST_TO_ADDR
// if vehicleLostCounter < 3 then
15896: LD_EXP 15
15900: PUSH
15901: LD_INT 3
15903: LESS
15904: IFFALSE 15913
// SetAchievement ( ACH_ECONOMY ) ;
15906: LD_STRING ACH_ECONOMY
15908: PPUSH
15909: CALL_OW 543
// if tick < 60 60$00 then
15913: LD_OWVAR 1
15917: PUSH
15918: LD_INT 126000
15920: LESS
15921: IFFALSE 15937
// begin wait ( 3 ) ;
15923: LD_INT 3
15925: PPUSH
15926: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
15930: LD_STRING ACH_ASPEED_19
15932: PPUSH
15933: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
15937: LD_EXP 17
15941: PPUSH
15942: CALL_OW 87
// InGameOn ;
15946: CALL_OW 8
// DialogueOn ;
15950: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
15954: LD_EXP 17
15958: PPUSH
15959: LD_STRING DEnd-JMM-JMM-1
15961: PPUSH
15962: CALL_OW 88
// if Joan then
15966: LD_EXP 32
15970: IFFALSE 15986
// Say ( Joan , DEnd-JMM-Joan-1 ) else
15972: LD_EXP 32
15976: PPUSH
15977: LD_STRING DEnd-JMM-Joan-1
15979: PPUSH
15980: CALL_OW 88
15984: GO 16030
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
15986: LD_EXP 19
15990: PUSH
15991: LD_EXP 19
15995: PPUSH
15996: CALL_OW 255
16000: PUSH
16001: LD_INT 7
16003: EQUAL
16004: AND
16005: PUSH
16006: LD_EXP 19
16010: PPUSH
16011: CALL_OW 305
16015: AND
16016: IFFALSE 16030
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
16018: LD_EXP 19
16022: PPUSH
16023: LD_STRING DEnd-JMM-Lisa-1
16025: PPUSH
16026: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
16030: LD_EXP 29
16034: PUSH
16035: LD_EXP 29
16039: PPUSH
16040: CALL_OW 305
16044: AND
16045: IFFALSE 16059
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
16047: LD_EXP 29
16051: PPUSH
16052: LD_STRING DEnd-JMM-Frank-1
16054: PPUSH
16055: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
16059: LD_EXP 22
16063: PUSH
16064: LD_EXP 22
16068: PPUSH
16069: CALL_OW 255
16073: PUSH
16074: LD_INT 7
16076: EQUAL
16077: AND
16078: PUSH
16079: LD_EXP 22
16083: PPUSH
16084: CALL_OW 305
16088: AND
16089: IFFALSE 16103
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
16091: LD_EXP 22
16095: PPUSH
16096: LD_STRING DEnd-JMM-Cyrus-1
16098: PPUSH
16099: CALL_OW 88
// if Burlak then
16103: LD_EXP 49
16107: IFFALSE 16121
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
16109: LD_EXP 49
16113: PPUSH
16114: LD_STRING DEnd-JMM-Bur-1
16116: PPUSH
16117: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
16121: LD_EXP 32
16125: PUSH
16126: LD_EXP 19
16130: AND
16131: PUSH
16132: LD_EXP 19
16136: PPUSH
16137: CALL_OW 255
16141: PUSH
16142: LD_INT 7
16144: EQUAL
16145: AND
16146: PUSH
16147: LD_EXP 19
16151: PPUSH
16152: CALL_OW 305
16156: AND
16157: IFFALSE 16171
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
16159: LD_EXP 19
16163: PPUSH
16164: LD_STRING DEnd-Burlak-Lisa-1
16166: PPUSH
16167: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
16171: LD_EXP 50
16175: PUSH
16176: LD_EXP 50
16180: PPUSH
16181: CALL_OW 305
16185: AND
16186: IFFALSE 16200
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
16188: LD_EXP 50
16192: PPUSH
16193: LD_STRING DEnd-JMM-Bel-1
16195: PPUSH
16196: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
16200: LD_EXP 51
16204: PUSH
16205: LD_EXP 51
16209: PPUSH
16210: CALL_OW 305
16214: AND
16215: IFFALSE 16229
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
16217: LD_EXP 51
16221: PPUSH
16222: LD_STRING DEnd-JMM-Gny-1
16224: PPUSH
16225: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
16229: LD_EXP 27
16233: PUSH
16234: LD_EXP 27
16238: PPUSH
16239: CALL_OW 255
16243: PUSH
16244: LD_INT 7
16246: EQUAL
16247: AND
16248: PUSH
16249: LD_EXP 27
16253: PPUSH
16254: CALL_OW 305
16258: AND
16259: IFFALSE 16273
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
16261: LD_EXP 27
16265: PPUSH
16266: LD_STRING DEnd-JMM-Corn-1
16268: PPUSH
16269: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
16273: LD_EXP 20
16277: PUSH
16278: LD_EXP 20
16282: PPUSH
16283: CALL_OW 255
16287: PUSH
16288: LD_INT 7
16290: EQUAL
16291: AND
16292: PUSH
16293: LD_EXP 20
16297: PPUSH
16298: CALL_OW 305
16302: AND
16303: IFFALSE 16317
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
16305: LD_EXP 20
16309: PPUSH
16310: LD_STRING DEnd-JMM-Don-1
16312: PPUSH
16313: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
16317: LD_EXP 21
16321: PUSH
16322: LD_EXP 21
16326: PPUSH
16327: CALL_OW 255
16331: PUSH
16332: LD_INT 7
16334: EQUAL
16335: AND
16336: PUSH
16337: LD_EXP 21
16341: PPUSH
16342: CALL_OW 305
16346: AND
16347: IFFALSE 16361
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
16349: LD_EXP 21
16353: PPUSH
16354: LD_STRING DEnd-JMM-Bobby-1
16356: PPUSH
16357: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
16361: LD_EXP 23
16365: PUSH
16366: LD_EXP 23
16370: PPUSH
16371: CALL_OW 255
16375: PUSH
16376: LD_INT 7
16378: EQUAL
16379: AND
16380: PUSH
16381: LD_EXP 23
16385: PPUSH
16386: CALL_OW 305
16390: AND
16391: IFFALSE 16405
// Say ( Denis , DEnd-JMM-Den-1 ) ;
16393: LD_EXP 23
16397: PPUSH
16398: LD_STRING DEnd-JMM-Den-1
16400: PPUSH
16401: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
16405: LD_EXP 25
16409: PUSH
16410: LD_EXP 25
16414: PPUSH
16415: CALL_OW 255
16419: PUSH
16420: LD_INT 7
16422: EQUAL
16423: AND
16424: PUSH
16425: LD_EXP 25
16429: PPUSH
16430: CALL_OW 305
16434: AND
16435: IFFALSE 16449
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
16437: LD_EXP 25
16441: PPUSH
16442: LD_STRING DEnd-JMM-Glad-1
16444: PPUSH
16445: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
16449: LD_EXP 30
16453: PUSH
16454: LD_EXP 30
16458: PPUSH
16459: CALL_OW 255
16463: PUSH
16464: LD_INT 7
16466: EQUAL
16467: AND
16468: PUSH
16469: LD_EXP 30
16473: PPUSH
16474: CALL_OW 305
16478: AND
16479: IFFALSE 16493
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
16481: LD_EXP 30
16485: PPUSH
16486: LD_STRING DEnd-JMM-Yam-1
16488: PPUSH
16489: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
16493: LD_EXP 24
16497: PUSH
16498: LD_EXP 24
16502: PPUSH
16503: CALL_OW 255
16507: PUSH
16508: LD_INT 7
16510: EQUAL
16511: AND
16512: PUSH
16513: LD_EXP 24
16517: PPUSH
16518: CALL_OW 305
16522: AND
16523: IFFALSE 16537
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
16525: LD_EXP 24
16529: PPUSH
16530: LD_STRING DEnd-JMM-Brown-1
16532: PPUSH
16533: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
16537: LD_EXP 34
16541: PUSH
16542: LD_EXP 34
16546: PPUSH
16547: CALL_OW 255
16551: PUSH
16552: LD_INT 7
16554: EQUAL
16555: AND
16556: PUSH
16557: LD_EXP 34
16561: PPUSH
16562: CALL_OW 305
16566: AND
16567: IFFALSE 16581
// Say ( Connie , DEnd-JMM-Con-1 ) ;
16569: LD_EXP 34
16573: PPUSH
16574: LD_STRING DEnd-JMM-Con-1
16576: PPUSH
16577: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
16581: LD_EXP 28
16585: PUSH
16586: LD_EXP 28
16590: PPUSH
16591: CALL_OW 255
16595: PUSH
16596: LD_INT 7
16598: EQUAL
16599: AND
16600: PUSH
16601: LD_EXP 28
16605: PPUSH
16606: CALL_OW 305
16610: AND
16611: IFFALSE 16625
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
16613: LD_EXP 28
16617: PPUSH
16618: LD_STRING DEnd-JMM-Gary-1
16620: PPUSH
16621: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
16625: LD_EXP 31
16629: PUSH
16630: LD_EXP 18
16634: AND
16635: PUSH
16636: LD_EXP 31
16640: PPUSH
16641: CALL_OW 305
16645: AND
16646: IFFALSE 16660
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
16648: LD_EXP 31
16652: PPUSH
16653: LD_STRING DEnd-JMM-Sim-1
16655: PPUSH
16656: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
16660: LD_EXP 26
16664: PUSH
16665: LD_EXP 26
16669: PPUSH
16670: CALL_OW 255
16674: PUSH
16675: LD_INT 7
16677: EQUAL
16678: AND
16679: PUSH
16680: LD_EXP 26
16684: PPUSH
16685: CALL_OW 305
16689: AND
16690: IFFALSE 16704
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
16692: LD_EXP 26
16696: PPUSH
16697: LD_STRING DEnd-JMM-VanH-1
16699: PPUSH
16700: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
16704: LD_EXP 39
16708: PUSH
16709: LD_EXP 39
16713: PPUSH
16714: CALL_OW 305
16718: AND
16719: IFFALSE 16733
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
16721: LD_EXP 39
16725: PPUSH
16726: LD_STRING DEnd-JMM-Dol-1
16728: PPUSH
16729: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
16733: LD_EXP 43
16737: PUSH
16738: LD_EXP 43
16742: PPUSH
16743: CALL_OW 305
16747: AND
16748: IFFALSE 16762
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
16750: LD_EXP 43
16754: PPUSH
16755: LD_STRING DEnd-JMM-Kap-1
16757: PPUSH
16758: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
16762: LD_EXP 46
16766: PUSH
16767: LD_EXP 46
16771: PPUSH
16772: CALL_OW 305
16776: AND
16777: IFFALSE 16791
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
16779: LD_EXP 46
16783: PPUSH
16784: LD_STRING DEnd-JMM-Kov-1
16786: PPUSH
16787: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
16791: LD_EXP 41
16795: PUSH
16796: LD_EXP 41
16800: PPUSH
16801: CALL_OW 305
16805: AND
16806: IFFALSE 16820
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
16808: LD_EXP 41
16812: PPUSH
16813: LD_STRING DEnd-JMM-Sch-1
16815: PPUSH
16816: CALL_OW 88
// if Titov and IsPlaced ( Titov ) then
16820: LD_EXP 37
16824: PUSH
16825: LD_EXP 37
16829: PPUSH
16830: CALL_OW 305
16834: AND
16835: IFFALSE 16849
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
16837: LD_EXP 37
16841: PPUSH
16842: LD_STRING DEnd-JMM-Tit-1
16844: PPUSH
16845: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
16849: LD_EXP 42
16853: PUSH
16854: LD_EXP 42
16858: PPUSH
16859: CALL_OW 305
16863: AND
16864: IFFALSE 16878
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
16866: LD_EXP 42
16870: PPUSH
16871: LD_STRING DEnd-JMM-Obl-1
16873: PPUSH
16874: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
16878: LD_EXP 44
16882: PUSH
16883: LD_EXP 44
16887: PPUSH
16888: CALL_OW 305
16892: AND
16893: IFFALSE 16907
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
16895: LD_EXP 44
16899: PPUSH
16900: LD_STRING DEnd-JMM-Lip-1
16902: PPUSH
16903: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and Burlak then
16907: LD_EXP 38
16911: PUSH
16912: LD_EXP 38
16916: PPUSH
16917: CALL_OW 305
16921: AND
16922: PUSH
16923: LD_EXP 49
16927: AND
16928: IFFALSE 16942
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
16930: LD_EXP 38
16934: PPUSH
16935: LD_STRING DEnd-Burlak-Fad-1
16937: PPUSH
16938: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
16942: LD_EXP 45
16946: PUSH
16947: LD_EXP 45
16951: PPUSH
16952: CALL_OW 305
16956: AND
16957: IFFALSE 16971
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
16959: LD_EXP 45
16963: PPUSH
16964: LD_STRING DEnd-Burlak-Ptr-1
16966: PPUSH
16967: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
16971: LD_EXP 47
16975: PUSH
16976: LD_EXP 47
16980: PPUSH
16981: CALL_OW 305
16985: AND
16986: IFFALSE 17000
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
16988: LD_EXP 47
16992: PPUSH
16993: LD_STRING DEnd-Burlak-Kuz-1
16995: PPUSH
16996: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and Burlak then
17000: LD_EXP 36
17004: PUSH
17005: LD_EXP 36
17009: PPUSH
17010: CALL_OW 305
17014: AND
17015: PUSH
17016: LD_EXP 49
17020: AND
17021: IFFALSE 17035
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
17023: LD_EXP 36
17027: PPUSH
17028: LD_STRING DEnd-Burlak-Kir-1
17030: PPUSH
17031: CALL_OW 88
// if Burlak then
17035: LD_EXP 49
17039: IFFALSE 17053
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
17041: LD_EXP 17
17045: PPUSH
17046: LD_STRING DEnd-Burlak-JMM-1
17048: PPUSH
17049: CALL_OW 88
// dwait ( 0 0$2 ) ;
17053: LD_INT 70
17055: PPUSH
17056: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
17060: LD_EXP 54
17064: PPUSH
17065: LD_STRING DEnd-Szulc
17067: PPUSH
17068: CALL_OW 94
// dwait ( 0 0$1 ) ;
17072: LD_INT 35
17074: PPUSH
17075: CALL_OW 68
// if IsLive ( Burlak ) then
17079: LD_EXP 49
17083: PPUSH
17084: CALL_OW 300
17088: IFFALSE 17100
// med1 := 1 else
17090: LD_ADDR_VAR 0 1
17094: PUSH
17095: LD_INT 1
17097: ST_TO_ADDR
17098: GO 17109
// med1 := - 1 ;
17100: LD_ADDR_VAR 0 1
17104: PUSH
17105: LD_INT 1
17107: NEG
17108: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
17109: LD_EXP 12
17113: PUSH
17114: LD_EXP 13
17118: AND
17119: PUSH
17120: LD_EXP 14
17124: AND
17125: IFFALSE 17137
// med2 := 1 else
17127: LD_ADDR_VAR 0 2
17131: PUSH
17132: LD_INT 1
17134: ST_TO_ADDR
17135: GO 17146
// med2 := - 1 ;
17137: LD_ADDR_VAR 0 2
17141: PUSH
17142: LD_INT 1
17144: NEG
17145: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
17146: LD_STRING Hero
17148: PPUSH
17149: LD_INT 1
17151: PPUSH
17152: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
17156: LD_STRING Artefact
17158: PPUSH
17159: LD_VAR 0 2
17163: PPUSH
17164: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
17168: LD_STRING ReconcileBurlak
17170: PPUSH
17171: LD_VAR 0 1
17175: PPUSH
17176: CALL_OW 101
// if Difficulty = 3 and med1 = 1 and med2 = 1 then
17180: LD_OWVAR 67
17184: PUSH
17185: LD_INT 3
17187: EQUAL
17188: PUSH
17189: LD_VAR 0 1
17193: PUSH
17194: LD_INT 1
17196: EQUAL
17197: AND
17198: PUSH
17199: LD_VAR 0 2
17203: PUSH
17204: LD_INT 1
17206: EQUAL
17207: AND
17208: IFFALSE 17220
// SetAchievementEX ( ACH_AMER , 19 ) ;
17210: LD_STRING ACH_AMER
17212: PPUSH
17213: LD_INT 19
17215: PPUSH
17216: CALL_OW 564
// GiveMedals ( MAIN ) ;
17220: LD_STRING MAIN
17222: PPUSH
17223: CALL_OW 102
// InGameOff ;
17227: CALL_OW 9
// DialogueOff ;
17231: CALL_OW 7
// music_nat := 1 ;
17235: LD_ADDR_OWVAR 71
17239: PUSH
17240: LD_INT 1
17242: ST_TO_ADDR
// music_class := 4 ;
17243: LD_ADDR_OWVAR 72
17247: PUSH
17248: LD_INT 4
17250: ST_TO_ADDR
// YouWin ;
17251: CALL_OW 103
// end ; end_of_file
17255: PPOPN 2
17257: END
// export function InitNature ; begin
17258: LD_INT 0
17260: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
17261: LD_INT 3
17263: PPUSH
17264: LD_INT 3
17266: PPUSH
17267: LD_INT 2
17269: PPUSH
17270: LD_INT 1
17272: PPUSH
17273: LD_INT 1
17275: PPUSH
17276: LD_INT 0
17278: PPUSH
17279: LD_INT 0
17281: PPUSH
17282: LD_INT 17
17284: PPUSH
17285: LD_INT 0
17287: PPUSH
17288: CALL 83370 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
17292: LD_INT 2
17294: PPUSH
17295: LD_INT 1
17297: PPUSH
17298: LD_INT 1
17300: PPUSH
17301: LD_INT 1
17303: PPUSH
17304: LD_INT 1
17306: PPUSH
17307: LD_INT 0
17309: PPUSH
17310: LD_INT 0
17312: PPUSH
17313: LD_INT 18
17315: PPUSH
17316: LD_INT 0
17318: PPUSH
17319: CALL 83370 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
17323: LD_INT 4
17325: PPUSH
17326: LD_INT 1
17328: PPUSH
17329: LD_INT 2
17331: PPUSH
17332: LD_INT 4
17334: PPUSH
17335: LD_INT 2
17337: PPUSH
17338: LD_INT 1
17340: PPUSH
17341: LD_INT 0
17343: PPUSH
17344: LD_INT 19
17346: PPUSH
17347: LD_INT 0
17349: PPUSH
17350: CALL 83370 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
17354: LD_INT 0
17356: PPUSH
17357: LD_INT 0
17359: PPUSH
17360: LD_INT 0
17362: PPUSH
17363: LD_INT 0
17365: PPUSH
17366: LD_INT 0
17368: PPUSH
17369: LD_INT 0
17371: PPUSH
17372: LD_INT 9
17374: PPUSH
17375: LD_INT 0
17377: PPUSH
17378: LD_INT 20
17380: PPUSH
17381: CALL 83370 0 9
// end ; end_of_file
17385: LD_VAR 0 1
17389: RET
// every 0 0$30 do var time ;
17390: GO 17392
17392: DISABLE
17393: LD_INT 0
17395: PPUSH
// begin time := 0 0$50 ;
17396: LD_ADDR_VAR 0 1
17400: PUSH
17401: LD_INT 1750
17403: ST_TO_ADDR
// repeat wait ( time ) ;
17404: LD_VAR 0 1
17408: PPUSH
17409: CALL_OW 67
// if Prob ( 50 ) then
17413: LD_INT 50
17415: PPUSH
17416: CALL_OW 13
17420: IFFALSE 17449
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
17422: LD_INT 1
17424: PPUSH
17425: LD_INT 5
17427: PPUSH
17428: CALL_OW 12
17432: PPUSH
17433: LD_INT 106
17435: PPUSH
17436: LD_INT 89
17438: PPUSH
17439: LD_INT 45
17441: PPUSH
17442: LD_INT 1
17444: PPUSH
17445: CALL_OW 56
// time := time + 0 0$3 ;
17449: LD_ADDR_VAR 0 1
17453: PUSH
17454: LD_VAR 0 1
17458: PUSH
17459: LD_INT 105
17461: PLUS
17462: ST_TO_ADDR
// if Prob ( 30 ) then
17463: LD_INT 30
17465: PPUSH
17466: CALL_OW 13
17470: IFFALSE 17516
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
17472: LD_INT 525
17474: PPUSH
17475: LD_INT 735
17477: PPUSH
17478: CALL_OW 12
17482: PPUSH
17483: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
17487: LD_INT 1
17489: PPUSH
17490: LD_INT 5
17492: PPUSH
17493: CALL_OW 12
17497: PPUSH
17498: LD_INT 21
17500: PPUSH
17501: LD_INT 26
17503: PPUSH
17504: LD_INT 12
17506: PPUSH
17507: LD_INT 1
17509: PPUSH
17510: CALL_OW 56
// end else
17514: GO 17552
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
17516: LD_INT 700
17518: PPUSH
17519: LD_INT 1225
17521: PPUSH
17522: CALL_OW 12
17526: PPUSH
17527: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
17531: LD_INT 1
17533: PPUSH
17534: LD_INT 5
17536: PPUSH
17537: CALL_OW 12
17541: PPUSH
17542: LD_INT 14
17544: PPUSH
17545: LD_INT 1
17547: PPUSH
17548: CALL_OW 55
// end ; if Prob ( 50 ) then
17552: LD_INT 50
17554: PPUSH
17555: CALL_OW 13
17559: IFFALSE 17605
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
17561: LD_INT 700
17563: PPUSH
17564: LD_INT 1050
17566: PPUSH
17567: CALL_OW 12
17571: PPUSH
17572: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
17576: LD_INT 1
17578: PPUSH
17579: LD_INT 5
17581: PPUSH
17582: CALL_OW 12
17586: PPUSH
17587: LD_INT 181
17589: PPUSH
17590: LD_INT 218
17592: PPUSH
17593: LD_INT 16
17595: PPUSH
17596: LD_INT 1
17598: PPUSH
17599: CALL_OW 56
// end else
17603: GO 17677
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
17605: LD_INT 350
17607: PPUSH
17608: LD_INT 525
17610: PPUSH
17611: CALL_OW 12
17615: PPUSH
17616: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
17620: LD_INT 1
17622: PPUSH
17623: LD_INT 5
17625: PPUSH
17626: CALL_OW 12
17630: PPUSH
17631: LD_INT 13
17633: PPUSH
17634: LD_INT 1
17636: PPUSH
17637: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17641: LD_INT 350
17643: PPUSH
17644: LD_INT 700
17646: PPUSH
17647: CALL_OW 12
17651: PPUSH
17652: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
17656: LD_INT 1
17658: PPUSH
17659: LD_INT 5
17661: PPUSH
17662: CALL_OW 12
17666: PPUSH
17667: LD_INT 33
17669: PPUSH
17670: LD_INT 1
17672: PPUSH
17673: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 ] [ Difficulty ] ) then
17677: LD_INT 65
17679: PUSH
17680: LD_INT 62
17682: PUSH
17683: LD_INT 55
17685: PUSH
17686: EMPTY
17687: LIST
17688: LIST
17689: LIST
17690: PUSH
17691: LD_OWVAR 67
17695: ARRAY
17696: PPUSH
17697: CALL_OW 13
17701: IFFALSE 17747
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
17703: LD_INT 525
17705: PPUSH
17706: LD_INT 875
17708: PPUSH
17709: CALL_OW 12
17713: PPUSH
17714: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17718: LD_INT 1
17720: PPUSH
17721: LD_INT 5
17723: PPUSH
17724: CALL_OW 12
17728: PPUSH
17729: LD_INT 294
17731: PPUSH
17732: LD_INT 211
17734: PPUSH
17735: LD_INT 30
17737: PPUSH
17738: LD_INT 1
17740: PPUSH
17741: CALL_OW 56
// end else
17745: GO 17789
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
17747: LD_INT 420
17749: PPUSH
17750: LD_INT 770
17752: PPUSH
17753: CALL_OW 12
17757: PPUSH
17758: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17762: LD_INT 1
17764: PPUSH
17765: LD_INT 5
17767: PPUSH
17768: CALL_OW 12
17772: PPUSH
17773: LD_INT 294
17775: PPUSH
17776: LD_INT 211
17778: PPUSH
17779: LD_INT 30
17781: PPUSH
17782: LD_INT 1
17784: PPUSH
17785: CALL_OW 56
// end ; if time > 2 2$20 then
17789: LD_VAR 0 1
17793: PUSH
17794: LD_INT 4900
17796: GREATER
17797: IFFALSE 17807
// time := 0 0$50 ;
17799: LD_ADDR_VAR 0 1
17803: PUSH
17804: LD_INT 1750
17806: ST_TO_ADDR
// until false ;
17807: LD_INT 0
17809: IFFALSE 17404
// end ;
17811: PPOPN 1
17813: END
// every 0 0$45 trigger tick < 10 10$00 do
17814: LD_OWVAR 1
17818: PUSH
17819: LD_INT 21000
17821: LESS
17822: IFFALSE 17870
17824: GO 17826
17826: DISABLE
// begin enable ;
17827: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17828: LD_INT 350
17830: PPUSH
17831: LD_INT 700
17833: PPUSH
17834: CALL_OW 12
17838: PPUSH
17839: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
17843: LD_INT 3
17845: PPUSH
17846: LD_INT 5
17848: PPUSH
17849: CALL_OW 12
17853: PPUSH
17854: LD_INT 181
17856: PPUSH
17857: LD_INT 13
17859: PPUSH
17860: LD_INT 20
17862: PPUSH
17863: LD_INT 1
17865: PPUSH
17866: CALL_OW 56
// end ; end_of_file
17870: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
17871: LD_INT 0
17873: PPUSH
// SetArtifactRes ( 7 , true ) ;
17874: LD_INT 7
17876: PPUSH
17877: LD_INT 1
17879: PPUSH
17880: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
17884: LD_ADDR_EXP 62
17888: PUSH
17889: EMPTY
17890: PUSH
17891: EMPTY
17892: PUSH
17893: EMPTY
17894: PUSH
17895: EMPTY
17896: LIST
17897: LIST
17898: LIST
17899: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
17900: LD_ADDR_EXP 63
17904: PUSH
17905: LD_INT 1050
17907: PUSH
17908: LD_OWVAR 67
17912: MUL
17913: PUSH
17914: LD_INT 2800
17916: PUSH
17917: LD_OWVAR 67
17921: MUL
17922: PUSH
17923: LD_INT 1
17925: NEG
17926: PUSH
17927: EMPTY
17928: LIST
17929: LIST
17930: LIST
17931: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
17932: LD_ADDR_EXP 64
17936: PUSH
17937: LD_INT 10
17939: PUSH
17940: LD_INT 35
17942: PUSH
17943: LD_INT 100
17945: PUSH
17946: EMPTY
17947: LIST
17948: LIST
17949: LIST
17950: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
17951: LD_ADDR_EXP 65
17955: PUSH
17956: LD_INT 0
17958: PUSH
17959: LD_INT 0
17961: PUSH
17962: LD_INT 0
17964: PUSH
17965: EMPTY
17966: LIST
17967: LIST
17968: LIST
17969: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
17970: LD_ADDR_EXP 67
17974: PUSH
17975: LD_INT 300
17977: PUSH
17978: LD_INT 500
17980: PUSH
17981: LD_INT 800
17983: PUSH
17984: EMPTY
17985: LIST
17986: LIST
17987: LIST
17988: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
17989: LD_ADDR_EXP 68
17993: PUSH
17994: LD_INT 0
17996: PUSH
17997: LD_INT 0
17999: PUSH
18000: LD_INT 0
18002: PUSH
18003: EMPTY
18004: LIST
18005: LIST
18006: LIST
18007: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
18008: LD_ADDR_EXP 69
18012: PUSH
18013: LD_INT 0
18015: PUSH
18016: LD_INT 0
18018: PUSH
18019: LD_INT 0
18021: PUSH
18022: EMPTY
18023: LIST
18024: LIST
18025: LIST
18026: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
18027: LD_ADDR_EXP 66
18031: PUSH
18032: LD_INT 0
18034: PUSH
18035: LD_INT 0
18037: PUSH
18038: LD_INT 0
18040: PUSH
18041: EMPTY
18042: LIST
18043: LIST
18044: LIST
18045: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
18046: LD_ADDR_EXP 70
18050: PUSH
18051: LD_INT 4
18053: PUSH
18054: LD_INT 3
18056: PUSH
18057: LD_INT 1
18059: PUSH
18060: EMPTY
18061: LIST
18062: LIST
18063: LIST
18064: PUSH
18065: LD_INT 5
18067: PUSH
18068: LD_INT 4
18070: PUSH
18071: LD_INT 2
18073: PUSH
18074: EMPTY
18075: LIST
18076: LIST
18077: LIST
18078: PUSH
18079: LD_INT 6
18081: PUSH
18082: LD_INT 3
18084: PUSH
18085: LD_INT 3
18087: PUSH
18088: EMPTY
18089: LIST
18090: LIST
18091: LIST
18092: PUSH
18093: EMPTY
18094: LIST
18095: LIST
18096: LIST
18097: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
18098: LD_ADDR_EXP 71
18102: PUSH
18103: LD_INT 0
18105: PUSH
18106: LD_INT 0
18108: PUSH
18109: LD_INT 0
18111: PUSH
18112: EMPTY
18113: LIST
18114: LIST
18115: LIST
18116: ST_TO_ADDR
// end ;
18117: LD_VAR 0 1
18121: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
18122: LD_INT 24
18124: PPUSH
18125: LD_INT 7
18127: PPUSH
18128: CALL_OW 321
18132: PUSH
18133: LD_INT 2
18135: EQUAL
18136: IFFALSE 19062
18138: GO 18140
18140: DISABLE
18141: LD_INT 0
18143: PPUSH
18144: PPUSH
18145: PPUSH
18146: PPUSH
18147: PPUSH
// begin enable ;
18148: ENABLE
// for i = 1 to 3 do
18149: LD_ADDR_VAR 0 1
18153: PUSH
18154: DOUBLE
18155: LD_INT 1
18157: DEC
18158: ST_TO_ADDR
18159: LD_INT 3
18161: PUSH
18162: FOR_TO
18163: IFFALSE 19060
// begin pos := FindArtifact ( i + 2 ) ;
18165: LD_ADDR_VAR 0 2
18169: PUSH
18170: LD_VAR 0 1
18174: PUSH
18175: LD_INT 2
18177: PLUS
18178: PPUSH
18179: CALL_OW 469
18183: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
18184: LD_ADDR_EXP 62
18188: PUSH
18189: LD_EXP 62
18193: PPUSH
18194: LD_VAR 0 1
18198: PPUSH
18199: LD_VAR 0 2
18203: PPUSH
18204: CALL_OW 1
18208: ST_TO_ADDR
// if pos then
18209: LD_VAR 0 2
18213: IFFALSE 18921
// begin case i of 1 :
18215: LD_VAR 0 1
18219: PUSH
18220: LD_INT 1
18222: DOUBLE
18223: EQUAL
18224: IFTRUE 18228
18226: GO 18305
18228: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
18229: LD_ADDR_VAR 0 4
18233: PUSH
18234: LD_INT 22
18236: PUSH
18237: LD_INT 7
18239: PUSH
18240: EMPTY
18241: LIST
18242: LIST
18243: PUSH
18244: LD_INT 23
18246: PUSH
18247: LD_INT 1
18249: PUSH
18250: EMPTY
18251: LIST
18252: LIST
18253: PUSH
18254: LD_INT 2
18256: PUSH
18257: LD_INT 30
18259: PUSH
18260: LD_INT 8
18262: PUSH
18263: EMPTY
18264: LIST
18265: LIST
18266: PUSH
18267: LD_INT 30
18269: PUSH
18270: LD_INT 7
18272: PUSH
18273: EMPTY
18274: LIST
18275: LIST
18276: PUSH
18277: LD_INT 30
18279: PUSH
18280: LD_INT 11
18282: PUSH
18283: EMPTY
18284: LIST
18285: LIST
18286: PUSH
18287: EMPTY
18288: LIST
18289: LIST
18290: LIST
18291: LIST
18292: PUSH
18293: EMPTY
18294: LIST
18295: LIST
18296: LIST
18297: PPUSH
18298: CALL_OW 69
18302: ST_TO_ADDR
18303: GO 18413
18305: LD_INT 2
18307: DOUBLE
18308: EQUAL
18309: IFTRUE 18313
18311: GO 18390
18313: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
18314: LD_ADDR_VAR 0 4
18318: PUSH
18319: LD_INT 22
18321: PUSH
18322: LD_INT 7
18324: PUSH
18325: EMPTY
18326: LIST
18327: LIST
18328: PUSH
18329: LD_INT 23
18331: PUSH
18332: LD_INT 3
18334: PUSH
18335: EMPTY
18336: LIST
18337: LIST
18338: PUSH
18339: LD_INT 2
18341: PUSH
18342: LD_INT 30
18344: PUSH
18345: LD_INT 8
18347: PUSH
18348: EMPTY
18349: LIST
18350: LIST
18351: PUSH
18352: LD_INT 30
18354: PUSH
18355: LD_INT 7
18357: PUSH
18358: EMPTY
18359: LIST
18360: LIST
18361: PUSH
18362: LD_INT 30
18364: PUSH
18365: LD_INT 11
18367: PUSH
18368: EMPTY
18369: LIST
18370: LIST
18371: PUSH
18372: EMPTY
18373: LIST
18374: LIST
18375: LIST
18376: LIST
18377: PUSH
18378: EMPTY
18379: LIST
18380: LIST
18381: LIST
18382: PPUSH
18383: CALL_OW 69
18387: ST_TO_ADDR
18388: GO 18413
18390: LD_INT 3
18392: DOUBLE
18393: EQUAL
18394: IFTRUE 18398
18396: GO 18412
18398: POP
// labs := [ alien ] ; end ;
18399: LD_ADDR_VAR 0 4
18403: PUSH
18404: LD_INT 1
18406: PUSH
18407: EMPTY
18408: LIST
18409: ST_TO_ADDR
18410: GO 18413
18412: POP
// if not labs then
18413: LD_VAR 0 4
18417: NOT
18418: IFFALSE 18422
// continue ;
18420: GO 18162
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
18422: LD_ADDR_VAR 0 5
18426: PUSH
18427: LD_VAR 0 4
18431: PPUSH
18432: LD_EXP 62
18436: PUSH
18437: LD_VAR 0 1
18441: ARRAY
18442: PUSH
18443: LD_INT 1
18445: ARRAY
18446: PPUSH
18447: LD_EXP 62
18451: PUSH
18452: LD_VAR 0 1
18456: ARRAY
18457: PUSH
18458: LD_INT 2
18460: ARRAY
18461: PPUSH
18462: CALL_OW 73
18466: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
18467: LD_VAR 0 5
18471: NOT
18472: PUSH
18473: LD_VAR 0 5
18477: PUSH
18478: LD_EXP 69
18482: PUSH
18483: LD_VAR 0 1
18487: ARRAY
18488: NONEQUAL
18489: OR
18490: IFFALSE 18595
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18492: LD_INT 7
18494: PPUSH
18495: LD_EXP 70
18499: PUSH
18500: LD_VAR 0 1
18504: ARRAY
18505: PUSH
18506: LD_INT 3
18508: ARRAY
18509: PPUSH
18510: LD_INT 0
18512: PPUSH
18513: LD_EXP 69
18517: PUSH
18518: LD_VAR 0 1
18522: ARRAY
18523: PPUSH
18524: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18528: LD_INT 7
18530: PPUSH
18531: LD_EXP 70
18535: PUSH
18536: LD_VAR 0 1
18540: ARRAY
18541: PUSH
18542: LD_INT 1
18544: ARRAY
18545: PPUSH
18546: LD_INT 0
18548: PPUSH
18549: LD_EXP 69
18553: PUSH
18554: LD_VAR 0 1
18558: ARRAY
18559: PPUSH
18560: CALL_OW 468
// if nearestLab then
18564: LD_VAR 0 5
18568: IFFALSE 18595
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
18570: LD_ADDR_EXP 69
18574: PUSH
18575: LD_EXP 69
18579: PPUSH
18580: LD_VAR 0 1
18584: PPUSH
18585: LD_VAR 0 5
18589: PPUSH
18590: CALL_OW 1
18594: ST_TO_ADDR
// end ; if not nearestLab then
18595: LD_VAR 0 5
18599: NOT
18600: IFFALSE 18604
// continue ;
18602: GO 18162
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
18604: LD_VAR 0 5
18608: PPUSH
18609: LD_EXP 62
18613: PUSH
18614: LD_VAR 0 1
18618: ARRAY
18619: PUSH
18620: LD_INT 1
18622: ARRAY
18623: PPUSH
18624: LD_EXP 62
18628: PUSH
18629: LD_VAR 0 1
18633: ARRAY
18634: PUSH
18635: LD_INT 2
18637: ARRAY
18638: PPUSH
18639: CALL_OW 297
18643: PUSH
18644: LD_INT 8
18646: LESS
18647: IFFALSE 18844
// begin if not artifactsResearched [ i ] then
18649: LD_EXP 65
18653: PUSH
18654: LD_VAR 0 1
18658: ARRAY
18659: NOT
18660: IFFALSE 18741
// begin if BuildingStatus ( nearestLab ) = bs_idle then
18662: LD_VAR 0 5
18666: PPUSH
18667: CALL_OW 461
18671: PUSH
18672: LD_INT 2
18674: EQUAL
18675: IFFALSE 18709
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
18677: LD_INT 7
18679: PPUSH
18680: LD_EXP 70
18684: PUSH
18685: LD_VAR 0 1
18689: ARRAY
18690: PUSH
18691: LD_INT 3
18693: ARRAY
18694: PPUSH
18695: LD_INT 2
18697: PPUSH
18698: LD_VAR 0 5
18702: PPUSH
18703: CALL_OW 468
18707: GO 18739
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
18709: LD_INT 7
18711: PPUSH
18712: LD_EXP 70
18716: PUSH
18717: LD_VAR 0 1
18721: ARRAY
18722: PUSH
18723: LD_INT 3
18725: ARRAY
18726: PPUSH
18727: LD_INT 1
18729: PPUSH
18730: LD_VAR 0 5
18734: PPUSH
18735: CALL_OW 468
// end else
18739: GO 18842
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
18741: LD_VAR 0 5
18745: PPUSH
18746: CALL_OW 461
18750: PUSH
18751: LD_INT 2
18753: EQUAL
18754: PUSH
18755: LD_EXP 71
18759: PUSH
18760: LD_VAR 0 1
18764: ARRAY
18765: AND
18766: IFFALSE 18812
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
18768: LD_INT 7
18770: PPUSH
18771: LD_EXP 70
18775: PUSH
18776: LD_VAR 0 1
18780: ARRAY
18781: PUSH
18782: LD_INT 1
18784: ARRAY
18785: PPUSH
18786: LD_EXP 70
18790: PUSH
18791: LD_VAR 0 1
18795: ARRAY
18796: PUSH
18797: LD_INT 2
18799: ARRAY
18800: PPUSH
18801: LD_VAR 0 5
18805: PPUSH
18806: CALL_OW 468
18810: GO 18842
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
18812: LD_INT 7
18814: PPUSH
18815: LD_EXP 70
18819: PUSH
18820: LD_VAR 0 1
18824: ARRAY
18825: PUSH
18826: LD_INT 1
18828: ARRAY
18829: PPUSH
18830: LD_INT 1
18832: PPUSH
18833: LD_VAR 0 5
18837: PPUSH
18838: CALL_OW 468
// end else
18842: GO 18919
// begin if not artifactsResearched [ i ] then
18844: LD_EXP 65
18848: PUSH
18849: LD_VAR 0 1
18853: ARRAY
18854: NOT
18855: IFFALSE 18889
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
18857: LD_INT 7
18859: PPUSH
18860: LD_EXP 70
18864: PUSH
18865: LD_VAR 0 1
18869: ARRAY
18870: PUSH
18871: LD_INT 3
18873: ARRAY
18874: PPUSH
18875: LD_INT 0
18877: PPUSH
18878: LD_VAR 0 5
18882: PPUSH
18883: CALL_OW 468
18887: GO 18919
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
18889: LD_INT 7
18891: PPUSH
18892: LD_EXP 70
18896: PUSH
18897: LD_VAR 0 1
18901: ARRAY
18902: PUSH
18903: LD_INT 1
18905: ARRAY
18906: PPUSH
18907: LD_INT 0
18909: PPUSH
18910: LD_VAR 0 5
18914: PPUSH
18915: CALL_OW 468
// end ; end else
18919: GO 19058
// begin if not artifactsLabs [ i ] then
18921: LD_EXP 69
18925: PUSH
18926: LD_VAR 0 1
18930: ARRAY
18931: NOT
18932: IFFALSE 18936
// continue ;
18934: GO 18162
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18936: LD_INT 7
18938: PPUSH
18939: LD_EXP 70
18943: PUSH
18944: LD_VAR 0 1
18948: ARRAY
18949: PUSH
18950: LD_INT 3
18952: ARRAY
18953: PPUSH
18954: LD_INT 0
18956: PPUSH
18957: LD_EXP 69
18961: PUSH
18962: LD_VAR 0 1
18966: ARRAY
18967: PPUSH
18968: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18972: LD_INT 7
18974: PPUSH
18975: LD_EXP 70
18979: PUSH
18980: LD_VAR 0 1
18984: ARRAY
18985: PUSH
18986: LD_INT 1
18988: ARRAY
18989: PPUSH
18990: LD_INT 0
18992: PPUSH
18993: LD_EXP 69
18997: PUSH
18998: LD_VAR 0 1
19002: ARRAY
19003: PPUSH
19004: CALL_OW 468
// if artifactsLabsWorking [ i ] then
19008: LD_EXP 66
19012: PUSH
19013: LD_VAR 0 1
19017: ARRAY
19018: IFFALSE 19058
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
19020: LD_ADDR_EXP 66
19024: PUSH
19025: LD_EXP 66
19029: PPUSH
19030: LD_VAR 0 1
19034: PPUSH
19035: LD_INT 0
19037: PPUSH
19038: CALL_OW 1
19042: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
19043: LD_EXP 69
19047: PUSH
19048: LD_VAR 0 1
19052: ARRAY
19053: PPUSH
19054: CALL_OW 127
// end ; end ; end ;
19058: GO 18162
19060: POP
19061: POP
// end ;
19062: PPOPN 5
19064: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
19065: LD_INT 0
19067: PPUSH
19068: PPUSH
19069: PPUSH
19070: PPUSH
19071: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
19072: LD_VAR 0 2
19076: PUSH
19077: LD_EXP 70
19081: PUSH
19082: LD_INT 1
19084: ARRAY
19085: PUSH
19086: LD_INT 3
19088: ARRAY
19089: EQUAL
19090: IFFALSE 19213
// begin lab := artifactsLabs [ 1 ] ;
19092: LD_ADDR_VAR 0 6
19096: PUSH
19097: LD_EXP 69
19101: PUSH
19102: LD_INT 1
19104: ARRAY
19105: ST_TO_ADDR
// if not lab then
19106: LD_VAR 0 6
19110: NOT
19111: IFFALSE 19115
// exit ;
19113: GO 20193
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
19115: LD_VAR 0 6
19119: PPUSH
19120: LD_EXP 67
19124: PUSH
19125: LD_INT 1
19127: ARRAY
19128: PPUSH
19129: LD_INT 1
19131: PPUSH
19132: CALL_OW 486
// if artifactsResProgress [ 1 ] then
19136: LD_EXP 68
19140: PUSH
19141: LD_INT 1
19143: ARRAY
19144: IFFALSE 19164
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
19146: LD_VAR 0 6
19150: PPUSH
19151: LD_EXP 68
19155: PUSH
19156: LD_INT 1
19158: ARRAY
19159: PPUSH
19160: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
19164: LD_ADDR_EXP 66
19168: PUSH
19169: LD_EXP 66
19173: PPUSH
19174: LD_INT 1
19176: PPUSH
19177: LD_INT 1
19179: PPUSH
19180: CALL_OW 1
19184: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
19185: LD_INT 7
19187: PPUSH
19188: LD_EXP 70
19192: PUSH
19193: LD_INT 1
19195: ARRAY
19196: PUSH
19197: LD_INT 3
19199: ARRAY
19200: PPUSH
19201: LD_INT 0
19203: PPUSH
19204: LD_VAR 0 6
19208: PPUSH
19209: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
19213: LD_VAR 0 2
19217: PUSH
19218: LD_EXP 70
19222: PUSH
19223: LD_INT 2
19225: ARRAY
19226: PUSH
19227: LD_INT 3
19229: ARRAY
19230: EQUAL
19231: IFFALSE 19354
// begin lab := artifactsLabs [ 2 ] ;
19233: LD_ADDR_VAR 0 6
19237: PUSH
19238: LD_EXP 69
19242: PUSH
19243: LD_INT 2
19245: ARRAY
19246: ST_TO_ADDR
// if not lab then
19247: LD_VAR 0 6
19251: NOT
19252: IFFALSE 19256
// exit ;
19254: GO 20193
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
19256: LD_VAR 0 6
19260: PPUSH
19261: LD_EXP 67
19265: PUSH
19266: LD_INT 2
19268: ARRAY
19269: PPUSH
19270: LD_INT 1
19272: PPUSH
19273: CALL_OW 486
// if artifactsResProgress [ 2 ] then
19277: LD_EXP 68
19281: PUSH
19282: LD_INT 2
19284: ARRAY
19285: IFFALSE 19305
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
19287: LD_VAR 0 6
19291: PPUSH
19292: LD_EXP 68
19296: PUSH
19297: LD_INT 2
19299: ARRAY
19300: PPUSH
19301: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
19305: LD_ADDR_EXP 66
19309: PUSH
19310: LD_EXP 66
19314: PPUSH
19315: LD_INT 2
19317: PPUSH
19318: LD_INT 1
19320: PPUSH
19321: CALL_OW 1
19325: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
19326: LD_INT 7
19328: PPUSH
19329: LD_EXP 70
19333: PUSH
19334: LD_INT 2
19336: ARRAY
19337: PUSH
19338: LD_INT 3
19340: ARRAY
19341: PPUSH
19342: LD_INT 0
19344: PPUSH
19345: LD_VAR 0 6
19349: PPUSH
19350: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
19354: LD_VAR 0 2
19358: PUSH
19359: LD_EXP 70
19363: PUSH
19364: LD_INT 3
19366: ARRAY
19367: PUSH
19368: LD_INT 3
19370: ARRAY
19371: EQUAL
19372: IFFALSE 19495
// begin lab := artifactsLabs [ 3 ] ;
19374: LD_ADDR_VAR 0 6
19378: PUSH
19379: LD_EXP 69
19383: PUSH
19384: LD_INT 3
19386: ARRAY
19387: ST_TO_ADDR
// if not lab then
19388: LD_VAR 0 6
19392: NOT
19393: IFFALSE 19397
// exit ;
19395: GO 20193
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
19397: LD_VAR 0 6
19401: PPUSH
19402: LD_EXP 67
19406: PUSH
19407: LD_INT 3
19409: ARRAY
19410: PPUSH
19411: LD_INT 1
19413: PPUSH
19414: CALL_OW 486
// if artifactsResProgress [ 3 ] then
19418: LD_EXP 68
19422: PUSH
19423: LD_INT 3
19425: ARRAY
19426: IFFALSE 19446
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
19428: LD_VAR 0 6
19432: PPUSH
19433: LD_EXP 68
19437: PUSH
19438: LD_INT 3
19440: ARRAY
19441: PPUSH
19442: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
19446: LD_ADDR_EXP 66
19450: PUSH
19451: LD_EXP 66
19455: PPUSH
19456: LD_INT 3
19458: PPUSH
19459: LD_INT 1
19461: PPUSH
19462: CALL_OW 1
19466: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
19467: LD_INT 7
19469: PPUSH
19470: LD_EXP 70
19474: PUSH
19475: LD_INT 3
19477: ARRAY
19478: PUSH
19479: LD_INT 3
19481: ARRAY
19482: PPUSH
19483: LD_INT 0
19485: PPUSH
19486: LD_VAR 0 6
19490: PPUSH
19491: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
19495: LD_VAR 0 2
19499: PUSH
19500: LD_EXP 70
19504: PUSH
19505: LD_INT 1
19507: ARRAY
19508: PUSH
19509: LD_INT 1
19511: ARRAY
19512: EQUAL
19513: IFFALSE 19671
// begin lab := artifactsLabs [ 1 ] ;
19515: LD_ADDR_VAR 0 6
19519: PUSH
19520: LD_EXP 69
19524: PUSH
19525: LD_INT 1
19527: ARRAY
19528: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
19529: LD_VAR 0 6
19533: PPUSH
19534: CALL_OW 274
19538: PPUSH
19539: CALL 86974 0 1
19543: PUSH
19544: LD_INT 3
19546: ARRAY
19547: PUSH
19548: LD_EXP 64
19552: PUSH
19553: LD_INT 1
19555: ARRAY
19556: LESS
19557: IFFALSE 19571
// begin HintSpec ( ArtifactCost , 2 ) ;
19559: LD_STRING ArtifactCost
19561: PPUSH
19562: LD_INT 2
19564: PPUSH
19565: CALL_OW 338
// exit ;
19569: GO 20193
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
19571: LD_ADDR_EXP 71
19575: PUSH
19576: LD_EXP 71
19580: PPUSH
19581: LD_INT 1
19583: PPUSH
19584: LD_INT 0
19586: PPUSH
19587: CALL_OW 1
19591: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
19592: LD_VAR 0 3
19596: PPUSH
19597: LD_VAR 0 4
19601: PPUSH
19602: LD_INT 7
19604: PPUSH
19605: LD_INT 12
19607: NEG
19608: PPUSH
19609: CALL_OW 330
// wait ( 0 0$30 ) ;
19613: LD_INT 1050
19615: PPUSH
19616: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
19620: LD_VAR 0 3
19624: PPUSH
19625: LD_VAR 0 4
19629: PPUSH
19630: LD_INT 7
19632: PPUSH
19633: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
19637: LD_EXP 63
19641: PUSH
19642: LD_INT 1
19644: ARRAY
19645: PPUSH
19646: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
19650: LD_ADDR_EXP 71
19654: PUSH
19655: LD_EXP 71
19659: PPUSH
19660: LD_INT 1
19662: PPUSH
19663: LD_INT 1
19665: PPUSH
19666: CALL_OW 1
19670: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
19671: LD_VAR 0 2
19675: PUSH
19676: LD_EXP 70
19680: PUSH
19681: LD_INT 2
19683: ARRAY
19684: PUSH
19685: LD_INT 1
19687: ARRAY
19688: EQUAL
19689: IFFALSE 19926
// begin lab := artifactsLabs [ 2 ] ;
19691: LD_ADDR_VAR 0 6
19695: PUSH
19696: LD_EXP 69
19700: PUSH
19701: LD_INT 2
19703: ARRAY
19704: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] , [ f_btype , b_ext_siberium ] ] ] ) then
19705: LD_VAR 0 3
19709: PUSH
19710: LD_INT 81
19712: PUSH
19713: LD_INT 7
19715: PUSH
19716: EMPTY
19717: LIST
19718: LIST
19719: PUSH
19720: LD_INT 2
19722: PUSH
19723: LD_INT 32
19725: PUSH
19726: LD_INT 3
19728: PUSH
19729: EMPTY
19730: LIST
19731: LIST
19732: PUSH
19733: LD_INT 30
19735: PUSH
19736: LD_INT 28
19738: PUSH
19739: EMPTY
19740: LIST
19741: LIST
19742: PUSH
19743: LD_INT 30
19745: PUSH
19746: LD_INT 30
19748: PUSH
19749: EMPTY
19750: LIST
19751: LIST
19752: PUSH
19753: LD_INT 35
19755: PUSH
19756: LD_INT 49
19758: PUSH
19759: EMPTY
19760: LIST
19761: LIST
19762: PUSH
19763: LD_INT 34
19765: PUSH
19766: LD_INT 49
19768: PUSH
19769: EMPTY
19770: LIST
19771: LIST
19772: PUSH
19773: LD_INT 30
19775: PUSH
19776: LD_INT 21
19778: PUSH
19779: EMPTY
19780: LIST
19781: LIST
19782: PUSH
19783: EMPTY
19784: LIST
19785: LIST
19786: LIST
19787: LIST
19788: LIST
19789: LIST
19790: LIST
19791: PUSH
19792: EMPTY
19793: LIST
19794: LIST
19795: PPUSH
19796: CALL_OW 69
19800: IN
19801: NOT
19802: IFFALSE 19806
// exit ;
19804: GO 20193
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
19806: LD_VAR 0 6
19810: PPUSH
19811: CALL_OW 274
19815: PPUSH
19816: CALL 86974 0 1
19820: PUSH
19821: LD_INT 3
19823: ARRAY
19824: PUSH
19825: LD_EXP 64
19829: PUSH
19830: LD_INT 2
19832: ARRAY
19833: LESS
19834: IFFALSE 19848
// begin HintSpec ( ArtifactCost , 2 ) ;
19836: LD_STRING ArtifactCost
19838: PPUSH
19839: LD_INT 2
19841: PPUSH
19842: CALL_OW 338
// exit ;
19846: GO 20193
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
19848: LD_ADDR_EXP 71
19852: PUSH
19853: LD_EXP 71
19857: PPUSH
19858: LD_INT 2
19860: PPUSH
19861: LD_INT 0
19863: PPUSH
19864: CALL_OW 1
19868: ST_TO_ADDR
// KillUnit ( x ) ;
19869: LD_VAR 0 3
19873: PPUSH
19874: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
19878: LD_ADDR_EXP 16
19882: PUSH
19883: LD_EXP 16
19887: PUSH
19888: LD_INT 1
19890: PLUS
19891: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
19892: LD_EXP 63
19896: PUSH
19897: LD_INT 2
19899: ARRAY
19900: PPUSH
19901: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
19905: LD_ADDR_EXP 71
19909: PUSH
19910: LD_EXP 71
19914: PPUSH
19915: LD_INT 2
19917: PPUSH
19918: LD_INT 1
19920: PPUSH
19921: CALL_OW 1
19925: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
19926: LD_VAR 0 2
19930: PUSH
19931: LD_EXP 70
19935: PUSH
19936: LD_INT 3
19938: ARRAY
19939: PUSH
19940: LD_INT 1
19942: ARRAY
19943: EQUAL
19944: IFFALSE 20193
// begin lab := artifactsLabs [ 3 ] ;
19946: LD_ADDR_VAR 0 6
19950: PUSH
19951: LD_EXP 69
19955: PUSH
19956: LD_INT 3
19958: ARRAY
19959: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
19960: LD_VAR 0 6
19964: PPUSH
19965: CALL_OW 274
19969: PPUSH
19970: CALL 86974 0 1
19974: PUSH
19975: LD_INT 3
19977: ARRAY
19978: PUSH
19979: LD_EXP 64
19983: PUSH
19984: LD_INT 3
19986: ARRAY
19987: LESS
19988: IFFALSE 20002
// begin HintSpec ( ArtifactCost , 2 ) ;
19990: LD_STRING ArtifactCost
19992: PPUSH
19993: LD_INT 2
19995: PPUSH
19996: CALL_OW 338
// exit ;
20000: GO 20193
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
20002: LD_INT 37
20004: PPUSH
20005: LD_INT 1
20007: PPUSH
20008: CALL_OW 424
// time := 0 0$30 ;
20012: LD_ADDR_VAR 0 7
20016: PUSH
20017: LD_INT 1050
20019: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
20020: LD_ADDR_EXP 71
20024: PUSH
20025: LD_EXP 71
20029: PPUSH
20030: LD_INT 3
20032: PPUSH
20033: LD_INT 0
20035: PPUSH
20036: CALL_OW 1
20040: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
20041: LD_ADDR_OWVAR 47
20045: PUSH
20046: LD_STRING #Am15a-1
20048: PUSH
20049: LD_VAR 0 7
20053: PUSH
20054: EMPTY
20055: LIST
20056: LIST
20057: ST_TO_ADDR
// wait ( 0 0$1 ) ;
20058: LD_INT 35
20060: PPUSH
20061: CALL_OW 67
// time := time - 0 0$1 ;
20065: LD_ADDR_VAR 0 7
20069: PUSH
20070: LD_VAR 0 7
20074: PUSH
20075: LD_INT 35
20077: MINUS
20078: ST_TO_ADDR
// until time = 0 0$00 ;
20079: LD_VAR 0 7
20083: PUSH
20084: LD_INT 0
20086: EQUAL
20087: IFFALSE 20041
// display_strings :=  ;
20089: LD_ADDR_OWVAR 47
20093: PUSH
20094: LD_STRING 
20096: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
20097: LD_INT 37
20099: PPUSH
20100: LD_INT 0
20102: PPUSH
20103: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
20107: LD_ADDR_VAR 0 8
20111: PUSH
20112: LD_INT 37
20114: PPUSH
20115: LD_INT 3
20117: PUSH
20118: LD_INT 21
20120: PUSH
20121: LD_INT 3
20123: PUSH
20124: EMPTY
20125: LIST
20126: LIST
20127: PUSH
20128: EMPTY
20129: LIST
20130: LIST
20131: PPUSH
20132: CALL_OW 70
20136: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
20137: LD_VAR 0 3
20141: PPUSH
20142: LD_VAR 0 4
20146: PPUSH
20147: CALL_OW 84
// for un in list do
20151: LD_ADDR_VAR 0 9
20155: PUSH
20156: LD_VAR 0 8
20160: PUSH
20161: FOR_IN
20162: IFFALSE 20191
// TeleportUnit ( un , x , y , 12 , true ) ;
20164: LD_VAR 0 9
20168: PPUSH
20169: LD_VAR 0 3
20173: PPUSH
20174: LD_VAR 0 4
20178: PPUSH
20179: LD_INT 12
20181: PPUSH
20182: LD_INT 1
20184: PPUSH
20185: CALL_OW 483
20189: GO 20161
20191: POP
20192: POP
// end ; end ;
20193: PPOPN 9
20195: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
20196: LD_INT 0
20198: PPUSH
20199: PPUSH
// begin labNum := 0 ;
20200: LD_ADDR_VAR 0 4
20204: PUSH
20205: LD_INT 0
20207: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20208: LD_ADDR_VAR 0 3
20212: PUSH
20213: DOUBLE
20214: LD_INT 1
20216: DEC
20217: ST_TO_ADDR
20218: LD_EXP 69
20222: PUSH
20223: FOR_TO
20224: IFFALSE 20258
// if artifactsLabs [ i ] = lab then
20226: LD_EXP 69
20230: PUSH
20231: LD_VAR 0 3
20235: ARRAY
20236: PUSH
20237: LD_VAR 0 1
20241: EQUAL
20242: IFFALSE 20256
// begin labNum := i ;
20244: LD_ADDR_VAR 0 4
20248: PUSH
20249: LD_VAR 0 3
20253: ST_TO_ADDR
// break ;
20254: GO 20258
// end ;
20256: GO 20223
20258: POP
20259: POP
// if not labNum then
20260: LD_VAR 0 4
20264: NOT
20265: IFFALSE 20269
// exit ;
20267: GO 20347
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
20269: LD_INT 7
20271: PPUSH
20272: LD_EXP 70
20276: PUSH
20277: LD_VAR 0 4
20281: ARRAY
20282: PUSH
20283: LD_INT 3
20285: ARRAY
20286: PPUSH
20287: LD_INT 2
20289: PPUSH
20290: LD_VAR 0 1
20294: PPUSH
20295: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
20299: LD_ADDR_EXP 68
20303: PUSH
20304: LD_EXP 68
20308: PPUSH
20309: LD_VAR 0 4
20313: PPUSH
20314: LD_VAR 0 2
20318: PPUSH
20319: CALL_OW 1
20323: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
20324: LD_ADDR_EXP 66
20328: PUSH
20329: LD_EXP 66
20333: PPUSH
20334: LD_VAR 0 4
20338: PPUSH
20339: LD_INT 0
20341: PPUSH
20342: CALL_OW 1
20346: ST_TO_ADDR
// end ;
20347: PPOPN 4
20349: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
20350: LD_INT 0
20352: PPUSH
20353: PPUSH
// begin labNum := 0 ;
20354: LD_ADDR_VAR 0 3
20358: PUSH
20359: LD_INT 0
20361: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20362: LD_ADDR_VAR 0 2
20366: PUSH
20367: DOUBLE
20368: LD_INT 1
20370: DEC
20371: ST_TO_ADDR
20372: LD_EXP 69
20376: PUSH
20377: FOR_TO
20378: IFFALSE 20412
// if artifactsLabs [ i ] = lab then
20380: LD_EXP 69
20384: PUSH
20385: LD_VAR 0 2
20389: ARRAY
20390: PUSH
20391: LD_VAR 0 1
20395: EQUAL
20396: IFFALSE 20410
// begin labNum := i ;
20398: LD_ADDR_VAR 0 3
20402: PUSH
20403: LD_VAR 0 2
20407: ST_TO_ADDR
// break ;
20408: GO 20412
// end ;
20410: GO 20377
20412: POP
20413: POP
// if not labNum then
20414: LD_VAR 0 3
20418: NOT
20419: IFFALSE 20423
// exit ;
20421: GO 20585
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
20423: LD_INT 7
20425: PPUSH
20426: LD_EXP 70
20430: PUSH
20431: LD_VAR 0 3
20435: ARRAY
20436: PUSH
20437: LD_INT 3
20439: ARRAY
20440: PPUSH
20441: LD_INT 0
20443: PPUSH
20444: LD_VAR 0 1
20448: PPUSH
20449: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
20453: LD_ADDR_EXP 65
20457: PUSH
20458: LD_EXP 65
20462: PPUSH
20463: LD_VAR 0 3
20467: PPUSH
20468: LD_INT 1
20470: PPUSH
20471: CALL_OW 1
20475: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
20476: LD_ADDR_EXP 71
20480: PUSH
20481: LD_EXP 71
20485: PPUSH
20486: LD_VAR 0 3
20490: PPUSH
20491: LD_INT 1
20493: PPUSH
20494: CALL_OW 1
20498: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
20499: LD_ADDR_EXP 66
20503: PUSH
20504: LD_EXP 66
20508: PPUSH
20509: LD_VAR 0 3
20513: PPUSH
20514: LD_INT 0
20516: PPUSH
20517: CALL_OW 1
20521: ST_TO_ADDR
// case labNum of 1 :
20522: LD_VAR 0 3
20526: PUSH
20527: LD_INT 1
20529: DOUBLE
20530: EQUAL
20531: IFTRUE 20535
20533: GO 20546
20535: POP
// artifactIResearched := true ; 2 :
20536: LD_ADDR_EXP 12
20540: PUSH
20541: LD_INT 1
20543: ST_TO_ADDR
20544: GO 20585
20546: LD_INT 2
20548: DOUBLE
20549: EQUAL
20550: IFTRUE 20554
20552: GO 20565
20554: POP
// artifactIIResearched := true ; 3 :
20555: LD_ADDR_EXP 13
20559: PUSH
20560: LD_INT 1
20562: ST_TO_ADDR
20563: GO 20585
20565: LD_INT 3
20567: DOUBLE
20568: EQUAL
20569: IFTRUE 20573
20571: GO 20584
20573: POP
// artifactIIIResearched := true ; end ;
20574: LD_ADDR_EXP 14
20578: PUSH
20579: LD_INT 1
20581: ST_TO_ADDR
20582: GO 20585
20584: POP
// end ; end_of_file
20585: PPOPN 3
20587: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
20588: LD_INT 0
20590: PPUSH
// ar_miner := 81 ;
20591: LD_ADDR_EXP 79
20595: PUSH
20596: LD_INT 81
20598: ST_TO_ADDR
// ar_crane := 88 ;
20599: LD_ADDR_EXP 78
20603: PUSH
20604: LD_INT 88
20606: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
20607: LD_ADDR_EXP 73
20611: PUSH
20612: LD_INT 89
20614: ST_TO_ADDR
// us_hack := 99 ;
20615: LD_ADDR_EXP 74
20619: PUSH
20620: LD_INT 99
20622: ST_TO_ADDR
// us_artillery := 97 ;
20623: LD_ADDR_EXP 75
20627: PUSH
20628: LD_INT 97
20630: ST_TO_ADDR
// ar_bio_bomb := 91 ;
20631: LD_ADDR_EXP 76
20635: PUSH
20636: LD_INT 91
20638: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
20639: LD_ADDR_EXP 77
20643: PUSH
20644: LD_INT 92
20646: ST_TO_ADDR
// ru_radar := 98 ;
20647: LD_ADDR_EXP 72
20651: PUSH
20652: LD_INT 98
20654: ST_TO_ADDR
// tech_Artillery := 80 ;
20655: LD_ADDR_EXP 80
20659: PUSH
20660: LD_INT 80
20662: ST_TO_ADDR
// tech_RadMat := 81 ;
20663: LD_ADDR_EXP 81
20667: PUSH
20668: LD_INT 81
20670: ST_TO_ADDR
// tech_BasicTools := 82 ;
20671: LD_ADDR_EXP 82
20675: PUSH
20676: LD_INT 82
20678: ST_TO_ADDR
// tech_Cargo := 83 ;
20679: LD_ADDR_EXP 83
20683: PUSH
20684: LD_INT 83
20686: ST_TO_ADDR
// tech_Track := 84 ;
20687: LD_ADDR_EXP 84
20691: PUSH
20692: LD_INT 84
20694: ST_TO_ADDR
// tech_Crane := 85 ;
20695: LD_ADDR_EXP 85
20699: PUSH
20700: LD_INT 85
20702: ST_TO_ADDR
// tech_Bulldozer := 86 ;
20703: LD_ADDR_EXP 86
20707: PUSH
20708: LD_INT 86
20710: ST_TO_ADDR
// tech_Hovercraft := 87 ;
20711: LD_ADDR_EXP 87
20715: PUSH
20716: LD_INT 87
20718: ST_TO_ADDR
// end ;
20719: LD_VAR 0 1
20723: RET
// every 1 do
20724: GO 20726
20726: DISABLE
// InitGlobalVariables ; end_of_file
20727: CALL 20588 0 0
20731: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
20732: LD_INT 0
20734: PPUSH
20735: PPUSH
// skirmish := false ;
20736: LD_ADDR_EXP 88
20740: PUSH
20741: LD_INT 0
20743: ST_TO_ADDR
// debug_mc := false ;
20744: LD_ADDR_EXP 89
20748: PUSH
20749: LD_INT 0
20751: ST_TO_ADDR
// mc_bases := [ ] ;
20752: LD_ADDR_EXP 90
20756: PUSH
20757: EMPTY
20758: ST_TO_ADDR
// mc_sides := [ ] ;
20759: LD_ADDR_EXP 116
20763: PUSH
20764: EMPTY
20765: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
20766: LD_ADDR_EXP 91
20770: PUSH
20771: EMPTY
20772: ST_TO_ADDR
// mc_building_repairs := [ ] ;
20773: LD_ADDR_EXP 92
20777: PUSH
20778: EMPTY
20779: ST_TO_ADDR
// mc_need_heal := [ ] ;
20780: LD_ADDR_EXP 93
20784: PUSH
20785: EMPTY
20786: ST_TO_ADDR
// mc_healers := [ ] ;
20787: LD_ADDR_EXP 94
20791: PUSH
20792: EMPTY
20793: ST_TO_ADDR
// mc_build_list := [ ] ;
20794: LD_ADDR_EXP 95
20798: PUSH
20799: EMPTY
20800: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
20801: LD_ADDR_EXP 122
20805: PUSH
20806: EMPTY
20807: ST_TO_ADDR
// mc_builders := [ ] ;
20808: LD_ADDR_EXP 96
20812: PUSH
20813: EMPTY
20814: ST_TO_ADDR
// mc_construct_list := [ ] ;
20815: LD_ADDR_EXP 97
20819: PUSH
20820: EMPTY
20821: ST_TO_ADDR
// mc_turret_list := [ ] ;
20822: LD_ADDR_EXP 98
20826: PUSH
20827: EMPTY
20828: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
20829: LD_ADDR_EXP 99
20833: PUSH
20834: EMPTY
20835: ST_TO_ADDR
// mc_miners := [ ] ;
20836: LD_ADDR_EXP 104
20840: PUSH
20841: EMPTY
20842: ST_TO_ADDR
// mc_mines := [ ] ;
20843: LD_ADDR_EXP 103
20847: PUSH
20848: EMPTY
20849: ST_TO_ADDR
// mc_minefields := [ ] ;
20850: LD_ADDR_EXP 105
20854: PUSH
20855: EMPTY
20856: ST_TO_ADDR
// mc_crates := [ ] ;
20857: LD_ADDR_EXP 106
20861: PUSH
20862: EMPTY
20863: ST_TO_ADDR
// mc_crates_collector := [ ] ;
20864: LD_ADDR_EXP 107
20868: PUSH
20869: EMPTY
20870: ST_TO_ADDR
// mc_crates_area := [ ] ;
20871: LD_ADDR_EXP 108
20875: PUSH
20876: EMPTY
20877: ST_TO_ADDR
// mc_vehicles := [ ] ;
20878: LD_ADDR_EXP 109
20882: PUSH
20883: EMPTY
20884: ST_TO_ADDR
// mc_attack := [ ] ;
20885: LD_ADDR_EXP 110
20889: PUSH
20890: EMPTY
20891: ST_TO_ADDR
// mc_produce := [ ] ;
20892: LD_ADDR_EXP 111
20896: PUSH
20897: EMPTY
20898: ST_TO_ADDR
// mc_defender := [ ] ;
20899: LD_ADDR_EXP 112
20903: PUSH
20904: EMPTY
20905: ST_TO_ADDR
// mc_parking := [ ] ;
20906: LD_ADDR_EXP 114
20910: PUSH
20911: EMPTY
20912: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
20913: LD_ADDR_EXP 100
20917: PUSH
20918: EMPTY
20919: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
20920: LD_ADDR_EXP 102
20924: PUSH
20925: EMPTY
20926: ST_TO_ADDR
// mc_scan := [ ] ;
20927: LD_ADDR_EXP 113
20931: PUSH
20932: EMPTY
20933: ST_TO_ADDR
// mc_scan_area := [ ] ;
20934: LD_ADDR_EXP 115
20938: PUSH
20939: EMPTY
20940: ST_TO_ADDR
// mc_tech := [ ] ;
20941: LD_ADDR_EXP 117
20945: PUSH
20946: EMPTY
20947: ST_TO_ADDR
// mc_class := [ ] ;
20948: LD_ADDR_EXP 131
20952: PUSH
20953: EMPTY
20954: ST_TO_ADDR
// mc_class_case_use := [ ] ;
20955: LD_ADDR_EXP 132
20959: PUSH
20960: EMPTY
20961: ST_TO_ADDR
// end ;
20962: LD_VAR 0 1
20966: RET
// export function MC_Kill ( base ) ; begin
20967: LD_INT 0
20969: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
20970: LD_ADDR_EXP 90
20974: PUSH
20975: LD_EXP 90
20979: PPUSH
20980: LD_VAR 0 1
20984: PPUSH
20985: EMPTY
20986: PPUSH
20987: CALL_OW 1
20991: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
20992: LD_ADDR_EXP 91
20996: PUSH
20997: LD_EXP 91
21001: PPUSH
21002: LD_VAR 0 1
21006: PPUSH
21007: EMPTY
21008: PPUSH
21009: CALL_OW 1
21013: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
21014: LD_ADDR_EXP 92
21018: PUSH
21019: LD_EXP 92
21023: PPUSH
21024: LD_VAR 0 1
21028: PPUSH
21029: EMPTY
21030: PPUSH
21031: CALL_OW 1
21035: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
21036: LD_ADDR_EXP 93
21040: PUSH
21041: LD_EXP 93
21045: PPUSH
21046: LD_VAR 0 1
21050: PPUSH
21051: EMPTY
21052: PPUSH
21053: CALL_OW 1
21057: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
21058: LD_ADDR_EXP 94
21062: PUSH
21063: LD_EXP 94
21067: PPUSH
21068: LD_VAR 0 1
21072: PPUSH
21073: EMPTY
21074: PPUSH
21075: CALL_OW 1
21079: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
21080: LD_ADDR_EXP 95
21084: PUSH
21085: LD_EXP 95
21089: PPUSH
21090: LD_VAR 0 1
21094: PPUSH
21095: EMPTY
21096: PPUSH
21097: CALL_OW 1
21101: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
21102: LD_ADDR_EXP 96
21106: PUSH
21107: LD_EXP 96
21111: PPUSH
21112: LD_VAR 0 1
21116: PPUSH
21117: EMPTY
21118: PPUSH
21119: CALL_OW 1
21123: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
21124: LD_ADDR_EXP 97
21128: PUSH
21129: LD_EXP 97
21133: PPUSH
21134: LD_VAR 0 1
21138: PPUSH
21139: EMPTY
21140: PPUSH
21141: CALL_OW 1
21145: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
21146: LD_ADDR_EXP 98
21150: PUSH
21151: LD_EXP 98
21155: PPUSH
21156: LD_VAR 0 1
21160: PPUSH
21161: EMPTY
21162: PPUSH
21163: CALL_OW 1
21167: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
21168: LD_ADDR_EXP 99
21172: PUSH
21173: LD_EXP 99
21177: PPUSH
21178: LD_VAR 0 1
21182: PPUSH
21183: EMPTY
21184: PPUSH
21185: CALL_OW 1
21189: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
21190: LD_ADDR_EXP 100
21194: PUSH
21195: LD_EXP 100
21199: PPUSH
21200: LD_VAR 0 1
21204: PPUSH
21205: EMPTY
21206: PPUSH
21207: CALL_OW 1
21211: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
21212: LD_ADDR_EXP 101
21216: PUSH
21217: LD_EXP 101
21221: PPUSH
21222: LD_VAR 0 1
21226: PPUSH
21227: LD_INT 0
21229: PPUSH
21230: CALL_OW 1
21234: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21235: LD_ADDR_EXP 102
21239: PUSH
21240: LD_EXP 102
21244: PPUSH
21245: LD_VAR 0 1
21249: PPUSH
21250: EMPTY
21251: PPUSH
21252: CALL_OW 1
21256: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21257: LD_ADDR_EXP 103
21261: PUSH
21262: LD_EXP 103
21266: PPUSH
21267: LD_VAR 0 1
21271: PPUSH
21272: EMPTY
21273: PPUSH
21274: CALL_OW 1
21278: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
21279: LD_ADDR_EXP 104
21283: PUSH
21284: LD_EXP 104
21288: PPUSH
21289: LD_VAR 0 1
21293: PPUSH
21294: EMPTY
21295: PPUSH
21296: CALL_OW 1
21300: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
21301: LD_ADDR_EXP 105
21305: PUSH
21306: LD_EXP 105
21310: PPUSH
21311: LD_VAR 0 1
21315: PPUSH
21316: EMPTY
21317: PPUSH
21318: CALL_OW 1
21322: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
21323: LD_ADDR_EXP 106
21327: PUSH
21328: LD_EXP 106
21332: PPUSH
21333: LD_VAR 0 1
21337: PPUSH
21338: EMPTY
21339: PPUSH
21340: CALL_OW 1
21344: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
21345: LD_ADDR_EXP 107
21349: PUSH
21350: LD_EXP 107
21354: PPUSH
21355: LD_VAR 0 1
21359: PPUSH
21360: EMPTY
21361: PPUSH
21362: CALL_OW 1
21366: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
21367: LD_ADDR_EXP 108
21371: PUSH
21372: LD_EXP 108
21376: PPUSH
21377: LD_VAR 0 1
21381: PPUSH
21382: EMPTY
21383: PPUSH
21384: CALL_OW 1
21388: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
21389: LD_ADDR_EXP 109
21393: PUSH
21394: LD_EXP 109
21398: PPUSH
21399: LD_VAR 0 1
21403: PPUSH
21404: EMPTY
21405: PPUSH
21406: CALL_OW 1
21410: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
21411: LD_ADDR_EXP 110
21415: PUSH
21416: LD_EXP 110
21420: PPUSH
21421: LD_VAR 0 1
21425: PPUSH
21426: EMPTY
21427: PPUSH
21428: CALL_OW 1
21432: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
21433: LD_ADDR_EXP 111
21437: PUSH
21438: LD_EXP 111
21442: PPUSH
21443: LD_VAR 0 1
21447: PPUSH
21448: EMPTY
21449: PPUSH
21450: CALL_OW 1
21454: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
21455: LD_ADDR_EXP 112
21459: PUSH
21460: LD_EXP 112
21464: PPUSH
21465: LD_VAR 0 1
21469: PPUSH
21470: EMPTY
21471: PPUSH
21472: CALL_OW 1
21476: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
21477: LD_ADDR_EXP 113
21481: PUSH
21482: LD_EXP 113
21486: PPUSH
21487: LD_VAR 0 1
21491: PPUSH
21492: EMPTY
21493: PPUSH
21494: CALL_OW 1
21498: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
21499: LD_ADDR_EXP 114
21503: PUSH
21504: LD_EXP 114
21508: PPUSH
21509: LD_VAR 0 1
21513: PPUSH
21514: EMPTY
21515: PPUSH
21516: CALL_OW 1
21520: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
21521: LD_ADDR_EXP 115
21525: PUSH
21526: LD_EXP 115
21530: PPUSH
21531: LD_VAR 0 1
21535: PPUSH
21536: EMPTY
21537: PPUSH
21538: CALL_OW 1
21542: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
21543: LD_ADDR_EXP 117
21547: PUSH
21548: LD_EXP 117
21552: PPUSH
21553: LD_VAR 0 1
21557: PPUSH
21558: EMPTY
21559: PPUSH
21560: CALL_OW 1
21564: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
21565: LD_ADDR_EXP 119
21569: PUSH
21570: LD_EXP 119
21574: PPUSH
21575: LD_VAR 0 1
21579: PPUSH
21580: EMPTY
21581: PPUSH
21582: CALL_OW 1
21586: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
21587: LD_ADDR_EXP 120
21591: PUSH
21592: LD_EXP 120
21596: PPUSH
21597: LD_VAR 0 1
21601: PPUSH
21602: EMPTY
21603: PPUSH
21604: CALL_OW 1
21608: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
21609: LD_ADDR_EXP 121
21613: PUSH
21614: LD_EXP 121
21618: PPUSH
21619: LD_VAR 0 1
21623: PPUSH
21624: EMPTY
21625: PPUSH
21626: CALL_OW 1
21630: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
21631: LD_ADDR_EXP 122
21635: PUSH
21636: LD_EXP 122
21640: PPUSH
21641: LD_VAR 0 1
21645: PPUSH
21646: EMPTY
21647: PPUSH
21648: CALL_OW 1
21652: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
21653: LD_ADDR_EXP 123
21657: PUSH
21658: LD_EXP 123
21662: PPUSH
21663: LD_VAR 0 1
21667: PPUSH
21668: EMPTY
21669: PPUSH
21670: CALL_OW 1
21674: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
21675: LD_ADDR_EXP 124
21679: PUSH
21680: LD_EXP 124
21684: PPUSH
21685: LD_VAR 0 1
21689: PPUSH
21690: EMPTY
21691: PPUSH
21692: CALL_OW 1
21696: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
21697: LD_ADDR_EXP 125
21701: PUSH
21702: LD_EXP 125
21706: PPUSH
21707: LD_VAR 0 1
21711: PPUSH
21712: EMPTY
21713: PPUSH
21714: CALL_OW 1
21718: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
21719: LD_ADDR_EXP 126
21723: PUSH
21724: LD_EXP 126
21728: PPUSH
21729: LD_VAR 0 1
21733: PPUSH
21734: EMPTY
21735: PPUSH
21736: CALL_OW 1
21740: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
21741: LD_ADDR_EXP 127
21745: PUSH
21746: LD_EXP 127
21750: PPUSH
21751: LD_VAR 0 1
21755: PPUSH
21756: EMPTY
21757: PPUSH
21758: CALL_OW 1
21762: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
21763: LD_ADDR_EXP 128
21767: PUSH
21768: LD_EXP 128
21772: PPUSH
21773: LD_VAR 0 1
21777: PPUSH
21778: EMPTY
21779: PPUSH
21780: CALL_OW 1
21784: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
21785: LD_ADDR_EXP 129
21789: PUSH
21790: LD_EXP 129
21794: PPUSH
21795: LD_VAR 0 1
21799: PPUSH
21800: EMPTY
21801: PPUSH
21802: CALL_OW 1
21806: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
21807: LD_ADDR_EXP 130
21811: PUSH
21812: LD_EXP 130
21816: PPUSH
21817: LD_VAR 0 1
21821: PPUSH
21822: EMPTY
21823: PPUSH
21824: CALL_OW 1
21828: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
21829: LD_ADDR_EXP 131
21833: PUSH
21834: LD_EXP 131
21838: PPUSH
21839: LD_VAR 0 1
21843: PPUSH
21844: EMPTY
21845: PPUSH
21846: CALL_OW 1
21850: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
21851: LD_ADDR_EXP 132
21855: PUSH
21856: LD_EXP 132
21860: PPUSH
21861: LD_VAR 0 1
21865: PPUSH
21866: LD_INT 0
21868: PPUSH
21869: CALL_OW 1
21873: ST_TO_ADDR
// end ;
21874: LD_VAR 0 2
21878: RET
// export function MC_Add ( side , units ) ; var base ; begin
21879: LD_INT 0
21881: PPUSH
21882: PPUSH
// base := mc_bases + 1 ;
21883: LD_ADDR_VAR 0 4
21887: PUSH
21888: LD_EXP 90
21892: PUSH
21893: LD_INT 1
21895: PLUS
21896: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
21897: LD_ADDR_EXP 116
21901: PUSH
21902: LD_EXP 116
21906: PPUSH
21907: LD_VAR 0 4
21911: PPUSH
21912: LD_VAR 0 1
21916: PPUSH
21917: CALL_OW 1
21921: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
21922: LD_ADDR_EXP 90
21926: PUSH
21927: LD_EXP 90
21931: PPUSH
21932: LD_VAR 0 4
21936: PPUSH
21937: LD_VAR 0 2
21941: PPUSH
21942: CALL_OW 1
21946: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
21947: LD_ADDR_EXP 91
21951: PUSH
21952: LD_EXP 91
21956: PPUSH
21957: LD_VAR 0 4
21961: PPUSH
21962: EMPTY
21963: PPUSH
21964: CALL_OW 1
21968: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
21969: LD_ADDR_EXP 92
21973: PUSH
21974: LD_EXP 92
21978: PPUSH
21979: LD_VAR 0 4
21983: PPUSH
21984: EMPTY
21985: PPUSH
21986: CALL_OW 1
21990: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
21991: LD_ADDR_EXP 93
21995: PUSH
21996: LD_EXP 93
22000: PPUSH
22001: LD_VAR 0 4
22005: PPUSH
22006: EMPTY
22007: PPUSH
22008: CALL_OW 1
22012: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
22013: LD_ADDR_EXP 94
22017: PUSH
22018: LD_EXP 94
22022: PPUSH
22023: LD_VAR 0 4
22027: PPUSH
22028: EMPTY
22029: PPUSH
22030: CALL_OW 1
22034: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
22035: LD_ADDR_EXP 95
22039: PUSH
22040: LD_EXP 95
22044: PPUSH
22045: LD_VAR 0 4
22049: PPUSH
22050: EMPTY
22051: PPUSH
22052: CALL_OW 1
22056: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
22057: LD_ADDR_EXP 96
22061: PUSH
22062: LD_EXP 96
22066: PPUSH
22067: LD_VAR 0 4
22071: PPUSH
22072: EMPTY
22073: PPUSH
22074: CALL_OW 1
22078: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
22079: LD_ADDR_EXP 97
22083: PUSH
22084: LD_EXP 97
22088: PPUSH
22089: LD_VAR 0 4
22093: PPUSH
22094: EMPTY
22095: PPUSH
22096: CALL_OW 1
22100: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
22101: LD_ADDR_EXP 98
22105: PUSH
22106: LD_EXP 98
22110: PPUSH
22111: LD_VAR 0 4
22115: PPUSH
22116: EMPTY
22117: PPUSH
22118: CALL_OW 1
22122: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
22123: LD_ADDR_EXP 99
22127: PUSH
22128: LD_EXP 99
22132: PPUSH
22133: LD_VAR 0 4
22137: PPUSH
22138: EMPTY
22139: PPUSH
22140: CALL_OW 1
22144: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
22145: LD_ADDR_EXP 100
22149: PUSH
22150: LD_EXP 100
22154: PPUSH
22155: LD_VAR 0 4
22159: PPUSH
22160: EMPTY
22161: PPUSH
22162: CALL_OW 1
22166: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
22167: LD_ADDR_EXP 101
22171: PUSH
22172: LD_EXP 101
22176: PPUSH
22177: LD_VAR 0 4
22181: PPUSH
22182: LD_INT 0
22184: PPUSH
22185: CALL_OW 1
22189: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
22190: LD_ADDR_EXP 102
22194: PUSH
22195: LD_EXP 102
22199: PPUSH
22200: LD_VAR 0 4
22204: PPUSH
22205: EMPTY
22206: PPUSH
22207: CALL_OW 1
22211: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
22212: LD_ADDR_EXP 103
22216: PUSH
22217: LD_EXP 103
22221: PPUSH
22222: LD_VAR 0 4
22226: PPUSH
22227: EMPTY
22228: PPUSH
22229: CALL_OW 1
22233: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
22234: LD_ADDR_EXP 104
22238: PUSH
22239: LD_EXP 104
22243: PPUSH
22244: LD_VAR 0 4
22248: PPUSH
22249: EMPTY
22250: PPUSH
22251: CALL_OW 1
22255: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
22256: LD_ADDR_EXP 105
22260: PUSH
22261: LD_EXP 105
22265: PPUSH
22266: LD_VAR 0 4
22270: PPUSH
22271: EMPTY
22272: PPUSH
22273: CALL_OW 1
22277: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
22278: LD_ADDR_EXP 106
22282: PUSH
22283: LD_EXP 106
22287: PPUSH
22288: LD_VAR 0 4
22292: PPUSH
22293: EMPTY
22294: PPUSH
22295: CALL_OW 1
22299: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
22300: LD_ADDR_EXP 107
22304: PUSH
22305: LD_EXP 107
22309: PPUSH
22310: LD_VAR 0 4
22314: PPUSH
22315: EMPTY
22316: PPUSH
22317: CALL_OW 1
22321: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
22322: LD_ADDR_EXP 108
22326: PUSH
22327: LD_EXP 108
22331: PPUSH
22332: LD_VAR 0 4
22336: PPUSH
22337: EMPTY
22338: PPUSH
22339: CALL_OW 1
22343: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
22344: LD_ADDR_EXP 109
22348: PUSH
22349: LD_EXP 109
22353: PPUSH
22354: LD_VAR 0 4
22358: PPUSH
22359: EMPTY
22360: PPUSH
22361: CALL_OW 1
22365: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
22366: LD_ADDR_EXP 110
22370: PUSH
22371: LD_EXP 110
22375: PPUSH
22376: LD_VAR 0 4
22380: PPUSH
22381: EMPTY
22382: PPUSH
22383: CALL_OW 1
22387: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
22388: LD_ADDR_EXP 111
22392: PUSH
22393: LD_EXP 111
22397: PPUSH
22398: LD_VAR 0 4
22402: PPUSH
22403: EMPTY
22404: PPUSH
22405: CALL_OW 1
22409: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
22410: LD_ADDR_EXP 112
22414: PUSH
22415: LD_EXP 112
22419: PPUSH
22420: LD_VAR 0 4
22424: PPUSH
22425: EMPTY
22426: PPUSH
22427: CALL_OW 1
22431: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
22432: LD_ADDR_EXP 113
22436: PUSH
22437: LD_EXP 113
22441: PPUSH
22442: LD_VAR 0 4
22446: PPUSH
22447: EMPTY
22448: PPUSH
22449: CALL_OW 1
22453: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
22454: LD_ADDR_EXP 114
22458: PUSH
22459: LD_EXP 114
22463: PPUSH
22464: LD_VAR 0 4
22468: PPUSH
22469: EMPTY
22470: PPUSH
22471: CALL_OW 1
22475: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
22476: LD_ADDR_EXP 115
22480: PUSH
22481: LD_EXP 115
22485: PPUSH
22486: LD_VAR 0 4
22490: PPUSH
22491: EMPTY
22492: PPUSH
22493: CALL_OW 1
22497: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
22498: LD_ADDR_EXP 117
22502: PUSH
22503: LD_EXP 117
22507: PPUSH
22508: LD_VAR 0 4
22512: PPUSH
22513: EMPTY
22514: PPUSH
22515: CALL_OW 1
22519: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
22520: LD_ADDR_EXP 119
22524: PUSH
22525: LD_EXP 119
22529: PPUSH
22530: LD_VAR 0 4
22534: PPUSH
22535: EMPTY
22536: PPUSH
22537: CALL_OW 1
22541: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
22542: LD_ADDR_EXP 120
22546: PUSH
22547: LD_EXP 120
22551: PPUSH
22552: LD_VAR 0 4
22556: PPUSH
22557: EMPTY
22558: PPUSH
22559: CALL_OW 1
22563: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
22564: LD_ADDR_EXP 121
22568: PUSH
22569: LD_EXP 121
22573: PPUSH
22574: LD_VAR 0 4
22578: PPUSH
22579: EMPTY
22580: PPUSH
22581: CALL_OW 1
22585: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
22586: LD_ADDR_EXP 122
22590: PUSH
22591: LD_EXP 122
22595: PPUSH
22596: LD_VAR 0 4
22600: PPUSH
22601: EMPTY
22602: PPUSH
22603: CALL_OW 1
22607: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
22608: LD_ADDR_EXP 123
22612: PUSH
22613: LD_EXP 123
22617: PPUSH
22618: LD_VAR 0 4
22622: PPUSH
22623: EMPTY
22624: PPUSH
22625: CALL_OW 1
22629: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
22630: LD_ADDR_EXP 124
22634: PUSH
22635: LD_EXP 124
22639: PPUSH
22640: LD_VAR 0 4
22644: PPUSH
22645: EMPTY
22646: PPUSH
22647: CALL_OW 1
22651: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
22652: LD_ADDR_EXP 125
22656: PUSH
22657: LD_EXP 125
22661: PPUSH
22662: LD_VAR 0 4
22666: PPUSH
22667: EMPTY
22668: PPUSH
22669: CALL_OW 1
22673: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
22674: LD_ADDR_EXP 126
22678: PUSH
22679: LD_EXP 126
22683: PPUSH
22684: LD_VAR 0 4
22688: PPUSH
22689: EMPTY
22690: PPUSH
22691: CALL_OW 1
22695: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
22696: LD_ADDR_EXP 127
22700: PUSH
22701: LD_EXP 127
22705: PPUSH
22706: LD_VAR 0 4
22710: PPUSH
22711: EMPTY
22712: PPUSH
22713: CALL_OW 1
22717: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
22718: LD_ADDR_EXP 128
22722: PUSH
22723: LD_EXP 128
22727: PPUSH
22728: LD_VAR 0 4
22732: PPUSH
22733: EMPTY
22734: PPUSH
22735: CALL_OW 1
22739: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
22740: LD_ADDR_EXP 129
22744: PUSH
22745: LD_EXP 129
22749: PPUSH
22750: LD_VAR 0 4
22754: PPUSH
22755: EMPTY
22756: PPUSH
22757: CALL_OW 1
22761: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
22762: LD_ADDR_EXP 130
22766: PUSH
22767: LD_EXP 130
22771: PPUSH
22772: LD_VAR 0 4
22776: PPUSH
22777: EMPTY
22778: PPUSH
22779: CALL_OW 1
22783: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
22784: LD_ADDR_EXP 131
22788: PUSH
22789: LD_EXP 131
22793: PPUSH
22794: LD_VAR 0 4
22798: PPUSH
22799: EMPTY
22800: PPUSH
22801: CALL_OW 1
22805: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
22806: LD_ADDR_EXP 132
22810: PUSH
22811: LD_EXP 132
22815: PPUSH
22816: LD_VAR 0 4
22820: PPUSH
22821: LD_INT 0
22823: PPUSH
22824: CALL_OW 1
22828: ST_TO_ADDR
// result := base ;
22829: LD_ADDR_VAR 0 3
22833: PUSH
22834: LD_VAR 0 4
22838: ST_TO_ADDR
// end ;
22839: LD_VAR 0 3
22843: RET
// export function MC_Start ( ) ; var i ; begin
22844: LD_INT 0
22846: PPUSH
22847: PPUSH
// for i = 1 to mc_bases do
22848: LD_ADDR_VAR 0 2
22852: PUSH
22853: DOUBLE
22854: LD_INT 1
22856: DEC
22857: ST_TO_ADDR
22858: LD_EXP 90
22862: PUSH
22863: FOR_TO
22864: IFFALSE 23941
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
22866: LD_ADDR_EXP 90
22870: PUSH
22871: LD_EXP 90
22875: PPUSH
22876: LD_VAR 0 2
22880: PPUSH
22881: LD_EXP 90
22885: PUSH
22886: LD_VAR 0 2
22890: ARRAY
22891: PUSH
22892: LD_INT 0
22894: DIFF
22895: PPUSH
22896: CALL_OW 1
22900: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
22901: LD_ADDR_EXP 91
22905: PUSH
22906: LD_EXP 91
22910: PPUSH
22911: LD_VAR 0 2
22915: PPUSH
22916: EMPTY
22917: PPUSH
22918: CALL_OW 1
22922: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
22923: LD_ADDR_EXP 92
22927: PUSH
22928: LD_EXP 92
22932: PPUSH
22933: LD_VAR 0 2
22937: PPUSH
22938: EMPTY
22939: PPUSH
22940: CALL_OW 1
22944: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
22945: LD_ADDR_EXP 93
22949: PUSH
22950: LD_EXP 93
22954: PPUSH
22955: LD_VAR 0 2
22959: PPUSH
22960: EMPTY
22961: PPUSH
22962: CALL_OW 1
22966: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
22967: LD_ADDR_EXP 94
22971: PUSH
22972: LD_EXP 94
22976: PPUSH
22977: LD_VAR 0 2
22981: PPUSH
22982: EMPTY
22983: PUSH
22984: EMPTY
22985: PUSH
22986: EMPTY
22987: LIST
22988: LIST
22989: PPUSH
22990: CALL_OW 1
22994: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
22995: LD_ADDR_EXP 95
22999: PUSH
23000: LD_EXP 95
23004: PPUSH
23005: LD_VAR 0 2
23009: PPUSH
23010: EMPTY
23011: PPUSH
23012: CALL_OW 1
23016: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
23017: LD_ADDR_EXP 122
23021: PUSH
23022: LD_EXP 122
23026: PPUSH
23027: LD_VAR 0 2
23031: PPUSH
23032: EMPTY
23033: PPUSH
23034: CALL_OW 1
23038: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
23039: LD_ADDR_EXP 96
23043: PUSH
23044: LD_EXP 96
23048: PPUSH
23049: LD_VAR 0 2
23053: PPUSH
23054: EMPTY
23055: PPUSH
23056: CALL_OW 1
23060: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
23061: LD_ADDR_EXP 97
23065: PUSH
23066: LD_EXP 97
23070: PPUSH
23071: LD_VAR 0 2
23075: PPUSH
23076: EMPTY
23077: PPUSH
23078: CALL_OW 1
23082: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
23083: LD_ADDR_EXP 98
23087: PUSH
23088: LD_EXP 98
23092: PPUSH
23093: LD_VAR 0 2
23097: PPUSH
23098: LD_EXP 90
23102: PUSH
23103: LD_VAR 0 2
23107: ARRAY
23108: PPUSH
23109: LD_INT 2
23111: PUSH
23112: LD_INT 30
23114: PUSH
23115: LD_INT 32
23117: PUSH
23118: EMPTY
23119: LIST
23120: LIST
23121: PUSH
23122: LD_INT 30
23124: PUSH
23125: LD_INT 33
23127: PUSH
23128: EMPTY
23129: LIST
23130: LIST
23131: PUSH
23132: EMPTY
23133: LIST
23134: LIST
23135: LIST
23136: PPUSH
23137: CALL_OW 72
23141: PPUSH
23142: CALL_OW 1
23146: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
23147: LD_ADDR_EXP 99
23151: PUSH
23152: LD_EXP 99
23156: PPUSH
23157: LD_VAR 0 2
23161: PPUSH
23162: LD_EXP 90
23166: PUSH
23167: LD_VAR 0 2
23171: ARRAY
23172: PPUSH
23173: LD_INT 2
23175: PUSH
23176: LD_INT 30
23178: PUSH
23179: LD_INT 32
23181: PUSH
23182: EMPTY
23183: LIST
23184: LIST
23185: PUSH
23186: LD_INT 30
23188: PUSH
23189: LD_INT 31
23191: PUSH
23192: EMPTY
23193: LIST
23194: LIST
23195: PUSH
23196: EMPTY
23197: LIST
23198: LIST
23199: LIST
23200: PUSH
23201: LD_INT 58
23203: PUSH
23204: EMPTY
23205: LIST
23206: PUSH
23207: EMPTY
23208: LIST
23209: LIST
23210: PPUSH
23211: CALL_OW 72
23215: PPUSH
23216: CALL_OW 1
23220: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
23221: LD_ADDR_EXP 100
23225: PUSH
23226: LD_EXP 100
23230: PPUSH
23231: LD_VAR 0 2
23235: PPUSH
23236: EMPTY
23237: PPUSH
23238: CALL_OW 1
23242: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
23243: LD_ADDR_EXP 104
23247: PUSH
23248: LD_EXP 104
23252: PPUSH
23253: LD_VAR 0 2
23257: PPUSH
23258: EMPTY
23259: PPUSH
23260: CALL_OW 1
23264: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
23265: LD_ADDR_EXP 103
23269: PUSH
23270: LD_EXP 103
23274: PPUSH
23275: LD_VAR 0 2
23279: PPUSH
23280: EMPTY
23281: PPUSH
23282: CALL_OW 1
23286: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
23287: LD_ADDR_EXP 105
23291: PUSH
23292: LD_EXP 105
23296: PPUSH
23297: LD_VAR 0 2
23301: PPUSH
23302: EMPTY
23303: PPUSH
23304: CALL_OW 1
23308: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
23309: LD_ADDR_EXP 106
23313: PUSH
23314: LD_EXP 106
23318: PPUSH
23319: LD_VAR 0 2
23323: PPUSH
23324: EMPTY
23325: PPUSH
23326: CALL_OW 1
23330: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
23331: LD_ADDR_EXP 107
23335: PUSH
23336: LD_EXP 107
23340: PPUSH
23341: LD_VAR 0 2
23345: PPUSH
23346: EMPTY
23347: PPUSH
23348: CALL_OW 1
23352: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
23353: LD_ADDR_EXP 108
23357: PUSH
23358: LD_EXP 108
23362: PPUSH
23363: LD_VAR 0 2
23367: PPUSH
23368: EMPTY
23369: PPUSH
23370: CALL_OW 1
23374: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
23375: LD_ADDR_EXP 109
23379: PUSH
23380: LD_EXP 109
23384: PPUSH
23385: LD_VAR 0 2
23389: PPUSH
23390: EMPTY
23391: PPUSH
23392: CALL_OW 1
23396: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
23397: LD_ADDR_EXP 110
23401: PUSH
23402: LD_EXP 110
23406: PPUSH
23407: LD_VAR 0 2
23411: PPUSH
23412: EMPTY
23413: PPUSH
23414: CALL_OW 1
23418: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
23419: LD_ADDR_EXP 111
23423: PUSH
23424: LD_EXP 111
23428: PPUSH
23429: LD_VAR 0 2
23433: PPUSH
23434: EMPTY
23435: PPUSH
23436: CALL_OW 1
23440: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
23441: LD_ADDR_EXP 112
23445: PUSH
23446: LD_EXP 112
23450: PPUSH
23451: LD_VAR 0 2
23455: PPUSH
23456: EMPTY
23457: PPUSH
23458: CALL_OW 1
23462: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
23463: LD_ADDR_EXP 101
23467: PUSH
23468: LD_EXP 101
23472: PPUSH
23473: LD_VAR 0 2
23477: PPUSH
23478: LD_INT 0
23480: PPUSH
23481: CALL_OW 1
23485: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
23486: LD_ADDR_EXP 114
23490: PUSH
23491: LD_EXP 114
23495: PPUSH
23496: LD_VAR 0 2
23500: PPUSH
23501: LD_INT 0
23503: PPUSH
23504: CALL_OW 1
23508: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
23509: LD_ADDR_EXP 102
23513: PUSH
23514: LD_EXP 102
23518: PPUSH
23519: LD_VAR 0 2
23523: PPUSH
23524: EMPTY
23525: PPUSH
23526: CALL_OW 1
23530: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
23531: LD_ADDR_EXP 113
23535: PUSH
23536: LD_EXP 113
23540: PPUSH
23541: LD_VAR 0 2
23545: PPUSH
23546: LD_INT 0
23548: PPUSH
23549: CALL_OW 1
23553: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
23554: LD_ADDR_EXP 115
23558: PUSH
23559: LD_EXP 115
23563: PPUSH
23564: LD_VAR 0 2
23568: PPUSH
23569: EMPTY
23570: PPUSH
23571: CALL_OW 1
23575: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
23576: LD_ADDR_EXP 118
23580: PUSH
23581: LD_EXP 118
23585: PPUSH
23586: LD_VAR 0 2
23590: PPUSH
23591: LD_INT 0
23593: PPUSH
23594: CALL_OW 1
23598: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
23599: LD_ADDR_EXP 119
23603: PUSH
23604: LD_EXP 119
23608: PPUSH
23609: LD_VAR 0 2
23613: PPUSH
23614: EMPTY
23615: PPUSH
23616: CALL_OW 1
23620: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
23621: LD_ADDR_EXP 120
23625: PUSH
23626: LD_EXP 120
23630: PPUSH
23631: LD_VAR 0 2
23635: PPUSH
23636: EMPTY
23637: PPUSH
23638: CALL_OW 1
23642: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
23643: LD_ADDR_EXP 121
23647: PUSH
23648: LD_EXP 121
23652: PPUSH
23653: LD_VAR 0 2
23657: PPUSH
23658: EMPTY
23659: PPUSH
23660: CALL_OW 1
23664: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
23665: LD_ADDR_EXP 123
23669: PUSH
23670: LD_EXP 123
23674: PPUSH
23675: LD_VAR 0 2
23679: PPUSH
23680: LD_EXP 90
23684: PUSH
23685: LD_VAR 0 2
23689: ARRAY
23690: PPUSH
23691: LD_INT 2
23693: PUSH
23694: LD_INT 30
23696: PUSH
23697: LD_INT 6
23699: PUSH
23700: EMPTY
23701: LIST
23702: LIST
23703: PUSH
23704: LD_INT 30
23706: PUSH
23707: LD_INT 7
23709: PUSH
23710: EMPTY
23711: LIST
23712: LIST
23713: PUSH
23714: LD_INT 30
23716: PUSH
23717: LD_INT 8
23719: PUSH
23720: EMPTY
23721: LIST
23722: LIST
23723: PUSH
23724: EMPTY
23725: LIST
23726: LIST
23727: LIST
23728: LIST
23729: PPUSH
23730: CALL_OW 72
23734: PPUSH
23735: CALL_OW 1
23739: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
23740: LD_ADDR_EXP 124
23744: PUSH
23745: LD_EXP 124
23749: PPUSH
23750: LD_VAR 0 2
23754: PPUSH
23755: EMPTY
23756: PPUSH
23757: CALL_OW 1
23761: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
23762: LD_ADDR_EXP 125
23766: PUSH
23767: LD_EXP 125
23771: PPUSH
23772: LD_VAR 0 2
23776: PPUSH
23777: EMPTY
23778: PPUSH
23779: CALL_OW 1
23783: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
23784: LD_ADDR_EXP 126
23788: PUSH
23789: LD_EXP 126
23793: PPUSH
23794: LD_VAR 0 2
23798: PPUSH
23799: EMPTY
23800: PPUSH
23801: CALL_OW 1
23805: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
23806: LD_ADDR_EXP 127
23810: PUSH
23811: LD_EXP 127
23815: PPUSH
23816: LD_VAR 0 2
23820: PPUSH
23821: EMPTY
23822: PPUSH
23823: CALL_OW 1
23827: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
23828: LD_ADDR_EXP 128
23832: PUSH
23833: LD_EXP 128
23837: PPUSH
23838: LD_VAR 0 2
23842: PPUSH
23843: EMPTY
23844: PPUSH
23845: CALL_OW 1
23849: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
23850: LD_ADDR_EXP 129
23854: PUSH
23855: LD_EXP 129
23859: PPUSH
23860: LD_VAR 0 2
23864: PPUSH
23865: EMPTY
23866: PPUSH
23867: CALL_OW 1
23871: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
23872: LD_ADDR_EXP 130
23876: PUSH
23877: LD_EXP 130
23881: PPUSH
23882: LD_VAR 0 2
23886: PPUSH
23887: EMPTY
23888: PPUSH
23889: CALL_OW 1
23893: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
23894: LD_ADDR_EXP 131
23898: PUSH
23899: LD_EXP 131
23903: PPUSH
23904: LD_VAR 0 2
23908: PPUSH
23909: EMPTY
23910: PPUSH
23911: CALL_OW 1
23915: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
23916: LD_ADDR_EXP 132
23920: PUSH
23921: LD_EXP 132
23925: PPUSH
23926: LD_VAR 0 2
23930: PPUSH
23931: LD_INT 0
23933: PPUSH
23934: CALL_OW 1
23938: ST_TO_ADDR
// end ;
23939: GO 22863
23941: POP
23942: POP
// MC_InitSides ( ) ;
23943: CALL 24229 0 0
// MC_InitResearch ( ) ;
23947: CALL 23968 0 0
// CustomInitMacro ( ) ;
23951: CALL 213 0 0
// skirmish := true ;
23955: LD_ADDR_EXP 88
23959: PUSH
23960: LD_INT 1
23962: ST_TO_ADDR
// end ;
23963: LD_VAR 0 1
23967: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
23968: LD_INT 0
23970: PPUSH
23971: PPUSH
23972: PPUSH
23973: PPUSH
23974: PPUSH
23975: PPUSH
// if not mc_bases then
23976: LD_EXP 90
23980: NOT
23981: IFFALSE 23985
// exit ;
23983: GO 24224
// for i = 1 to 8 do
23985: LD_ADDR_VAR 0 2
23989: PUSH
23990: DOUBLE
23991: LD_INT 1
23993: DEC
23994: ST_TO_ADDR
23995: LD_INT 8
23997: PUSH
23998: FOR_TO
23999: IFFALSE 24025
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
24001: LD_ADDR_EXP 117
24005: PUSH
24006: LD_EXP 117
24010: PPUSH
24011: LD_VAR 0 2
24015: PPUSH
24016: EMPTY
24017: PPUSH
24018: CALL_OW 1
24022: ST_TO_ADDR
24023: GO 23998
24025: POP
24026: POP
// tmp := [ ] ;
24027: LD_ADDR_VAR 0 5
24031: PUSH
24032: EMPTY
24033: ST_TO_ADDR
// for i = 1 to mc_sides do
24034: LD_ADDR_VAR 0 2
24038: PUSH
24039: DOUBLE
24040: LD_INT 1
24042: DEC
24043: ST_TO_ADDR
24044: LD_EXP 116
24048: PUSH
24049: FOR_TO
24050: IFFALSE 24108
// if not mc_sides [ i ] in tmp then
24052: LD_EXP 116
24056: PUSH
24057: LD_VAR 0 2
24061: ARRAY
24062: PUSH
24063: LD_VAR 0 5
24067: IN
24068: NOT
24069: IFFALSE 24106
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
24071: LD_ADDR_VAR 0 5
24075: PUSH
24076: LD_VAR 0 5
24080: PPUSH
24081: LD_VAR 0 5
24085: PUSH
24086: LD_INT 1
24088: PLUS
24089: PPUSH
24090: LD_EXP 116
24094: PUSH
24095: LD_VAR 0 2
24099: ARRAY
24100: PPUSH
24101: CALL_OW 2
24105: ST_TO_ADDR
24106: GO 24049
24108: POP
24109: POP
// if not tmp then
24110: LD_VAR 0 5
24114: NOT
24115: IFFALSE 24119
// exit ;
24117: GO 24224
// for j in tmp do
24119: LD_ADDR_VAR 0 3
24123: PUSH
24124: LD_VAR 0 5
24128: PUSH
24129: FOR_IN
24130: IFFALSE 24222
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
24132: LD_ADDR_VAR 0 6
24136: PUSH
24137: LD_INT 22
24139: PUSH
24140: LD_VAR 0 3
24144: PUSH
24145: EMPTY
24146: LIST
24147: LIST
24148: PPUSH
24149: CALL_OW 69
24153: ST_TO_ADDR
// if not un then
24154: LD_VAR 0 6
24158: NOT
24159: IFFALSE 24163
// continue ;
24161: GO 24129
// nation := GetNation ( un [ 1 ] ) ;
24163: LD_ADDR_VAR 0 4
24167: PUSH
24168: LD_VAR 0 6
24172: PUSH
24173: LD_INT 1
24175: ARRAY
24176: PPUSH
24177: CALL_OW 248
24181: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
24182: LD_ADDR_EXP 117
24186: PUSH
24187: LD_EXP 117
24191: PPUSH
24192: LD_VAR 0 3
24196: PPUSH
24197: LD_VAR 0 3
24201: PPUSH
24202: LD_VAR 0 4
24206: PPUSH
24207: LD_INT 1
24209: PPUSH
24210: CALL 50818 0 3
24214: PPUSH
24215: CALL_OW 1
24219: ST_TO_ADDR
// end ;
24220: GO 24129
24222: POP
24223: POP
// end ;
24224: LD_VAR 0 1
24228: RET
// export function MC_InitSides ( ) ; var i ; begin
24229: LD_INT 0
24231: PPUSH
24232: PPUSH
// if not mc_bases then
24233: LD_EXP 90
24237: NOT
24238: IFFALSE 24242
// exit ;
24240: GO 24316
// for i = 1 to mc_bases do
24242: LD_ADDR_VAR 0 2
24246: PUSH
24247: DOUBLE
24248: LD_INT 1
24250: DEC
24251: ST_TO_ADDR
24252: LD_EXP 90
24256: PUSH
24257: FOR_TO
24258: IFFALSE 24314
// if mc_bases [ i ] then
24260: LD_EXP 90
24264: PUSH
24265: LD_VAR 0 2
24269: ARRAY
24270: IFFALSE 24312
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
24272: LD_ADDR_EXP 116
24276: PUSH
24277: LD_EXP 116
24281: PPUSH
24282: LD_VAR 0 2
24286: PPUSH
24287: LD_EXP 90
24291: PUSH
24292: LD_VAR 0 2
24296: ARRAY
24297: PUSH
24298: LD_INT 1
24300: ARRAY
24301: PPUSH
24302: CALL_OW 255
24306: PPUSH
24307: CALL_OW 1
24311: ST_TO_ADDR
24312: GO 24257
24314: POP
24315: POP
// end ;
24316: LD_VAR 0 1
24320: RET
// every 0 0$01 trigger skirmish do
24321: LD_EXP 88
24325: IFFALSE 24479
24327: GO 24329
24329: DISABLE
// begin enable ;
24330: ENABLE
// MC_CheckBuildings ( ) ;
24331: CALL 28977 0 0
// MC_CheckPeopleLife ( ) ;
24335: CALL 29102 0 0
// RaiseSailEvent ( 100 ) ;
24339: LD_INT 100
24341: PPUSH
24342: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
24346: LD_INT 103
24348: PPUSH
24349: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
24353: LD_INT 104
24355: PPUSH
24356: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
24360: LD_INT 105
24362: PPUSH
24363: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
24367: LD_INT 106
24369: PPUSH
24370: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
24374: LD_INT 107
24376: PPUSH
24377: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
24381: LD_INT 108
24383: PPUSH
24384: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
24388: LD_INT 109
24390: PPUSH
24391: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
24395: LD_INT 110
24397: PPUSH
24398: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
24402: LD_INT 111
24404: PPUSH
24405: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
24409: LD_INT 112
24411: PPUSH
24412: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
24416: LD_INT 113
24418: PPUSH
24419: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
24423: LD_INT 120
24425: PPUSH
24426: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
24430: LD_INT 121
24432: PPUSH
24433: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
24437: LD_INT 122
24439: PPUSH
24440: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
24444: LD_INT 123
24446: PPUSH
24447: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
24451: LD_INT 124
24453: PPUSH
24454: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
24458: LD_INT 125
24460: PPUSH
24461: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
24465: LD_INT 126
24467: PPUSH
24468: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
24472: LD_INT 200
24474: PPUSH
24475: CALL_OW 427
// end ;
24479: END
// on SailEvent ( event ) do begin if event < 100 then
24480: LD_VAR 0 1
24484: PUSH
24485: LD_INT 100
24487: LESS
24488: IFFALSE 24499
// CustomEvent ( event ) ;
24490: LD_VAR 0 1
24494: PPUSH
24495: CALL 10371 0 1
// if event = 100 then
24499: LD_VAR 0 1
24503: PUSH
24504: LD_INT 100
24506: EQUAL
24507: IFFALSE 24513
// MC_ClassManager ( ) ;
24509: CALL 24905 0 0
// if event = 101 then
24513: LD_VAR 0 1
24517: PUSH
24518: LD_INT 101
24520: EQUAL
24521: IFFALSE 24527
// MC_RepairBuildings ( ) ;
24523: CALL 29687 0 0
// if event = 102 then
24527: LD_VAR 0 1
24531: PUSH
24532: LD_INT 102
24534: EQUAL
24535: IFFALSE 24541
// MC_Heal ( ) ;
24537: CALL 30546 0 0
// if event = 103 then
24541: LD_VAR 0 1
24545: PUSH
24546: LD_INT 103
24548: EQUAL
24549: IFFALSE 24555
// MC_Build ( ) ;
24551: CALL 30968 0 0
// if event = 104 then
24555: LD_VAR 0 1
24559: PUSH
24560: LD_INT 104
24562: EQUAL
24563: IFFALSE 24569
// MC_TurretWeapon ( ) ;
24565: CALL 32581 0 0
// if event = 105 then
24569: LD_VAR 0 1
24573: PUSH
24574: LD_INT 105
24576: EQUAL
24577: IFFALSE 24583
// MC_BuildUpgrade ( ) ;
24579: CALL 32132 0 0
// if event = 106 then
24583: LD_VAR 0 1
24587: PUSH
24588: LD_INT 106
24590: EQUAL
24591: IFFALSE 24597
// MC_PlantMines ( ) ;
24593: CALL 33011 0 0
// if event = 107 then
24597: LD_VAR 0 1
24601: PUSH
24602: LD_INT 107
24604: EQUAL
24605: IFFALSE 24611
// MC_CollectCrates ( ) ;
24607: CALL 33809 0 0
// if event = 108 then
24611: LD_VAR 0 1
24615: PUSH
24616: LD_INT 108
24618: EQUAL
24619: IFFALSE 24625
// MC_LinkRemoteControl ( ) ;
24621: CALL 35585 0 0
// if event = 109 then
24625: LD_VAR 0 1
24629: PUSH
24630: LD_INT 109
24632: EQUAL
24633: IFFALSE 24639
// MC_ProduceVehicle ( ) ;
24635: CALL 35766 0 0
// if event = 110 then
24639: LD_VAR 0 1
24643: PUSH
24644: LD_INT 110
24646: EQUAL
24647: IFFALSE 24653
// MC_SendAttack ( ) ;
24649: CALL 36232 0 0
// if event = 111 then
24653: LD_VAR 0 1
24657: PUSH
24658: LD_INT 111
24660: EQUAL
24661: IFFALSE 24667
// MC_Defend ( ) ;
24663: CALL 36340 0 0
// if event = 112 then
24667: LD_VAR 0 1
24671: PUSH
24672: LD_INT 112
24674: EQUAL
24675: IFFALSE 24681
// MC_Research ( ) ;
24677: CALL 36945 0 0
// if event = 113 then
24681: LD_VAR 0 1
24685: PUSH
24686: LD_INT 113
24688: EQUAL
24689: IFFALSE 24695
// MC_MinesTrigger ( ) ;
24691: CALL 38059 0 0
// if event = 120 then
24695: LD_VAR 0 1
24699: PUSH
24700: LD_INT 120
24702: EQUAL
24703: IFFALSE 24709
// MC_RepairVehicle ( ) ;
24705: CALL 38158 0 0
// if event = 121 then
24709: LD_VAR 0 1
24713: PUSH
24714: LD_INT 121
24716: EQUAL
24717: IFFALSE 24723
// MC_TameApe ( ) ;
24719: CALL 38888 0 0
// if event = 122 then
24723: LD_VAR 0 1
24727: PUSH
24728: LD_INT 122
24730: EQUAL
24731: IFFALSE 24737
// MC_ChangeApeClass ( ) ;
24733: CALL 39717 0 0
// if event = 123 then
24737: LD_VAR 0 1
24741: PUSH
24742: LD_INT 123
24744: EQUAL
24745: IFFALSE 24751
// MC_Bazooka ( ) ;
24747: CALL 40367 0 0
// if event = 124 then
24751: LD_VAR 0 1
24755: PUSH
24756: LD_INT 124
24758: EQUAL
24759: IFFALSE 24765
// MC_TeleportExit ( ) ;
24761: CALL 40565 0 0
// if event = 125 then
24765: LD_VAR 0 1
24769: PUSH
24770: LD_INT 125
24772: EQUAL
24773: IFFALSE 24779
// MC_Deposits ( ) ;
24775: CALL 41212 0 0
// if event = 126 then
24779: LD_VAR 0 1
24783: PUSH
24784: LD_INT 126
24786: EQUAL
24787: IFFALSE 24793
// MC_RemoteDriver ( ) ;
24789: CALL 41837 0 0
// if event = 200 then
24793: LD_VAR 0 1
24797: PUSH
24798: LD_INT 200
24800: EQUAL
24801: IFFALSE 24807
// MC_Idle ( ) ;
24803: CALL 43786 0 0
// end ;
24807: PPOPN 1
24809: END
// export function MC_Reset ( base , tag ) ; var i ; begin
24810: LD_INT 0
24812: PPUSH
24813: PPUSH
// if not mc_bases [ base ] or not tag then
24814: LD_EXP 90
24818: PUSH
24819: LD_VAR 0 1
24823: ARRAY
24824: NOT
24825: PUSH
24826: LD_VAR 0 2
24830: NOT
24831: OR
24832: IFFALSE 24836
// exit ;
24834: GO 24900
// for i in mc_bases [ base ] union mc_ape [ base ] do
24836: LD_ADDR_VAR 0 4
24840: PUSH
24841: LD_EXP 90
24845: PUSH
24846: LD_VAR 0 1
24850: ARRAY
24851: PUSH
24852: LD_EXP 119
24856: PUSH
24857: LD_VAR 0 1
24861: ARRAY
24862: UNION
24863: PUSH
24864: FOR_IN
24865: IFFALSE 24898
// if GetTag ( i ) = tag then
24867: LD_VAR 0 4
24871: PPUSH
24872: CALL_OW 110
24876: PUSH
24877: LD_VAR 0 2
24881: EQUAL
24882: IFFALSE 24896
// SetTag ( i , 0 ) ;
24884: LD_VAR 0 4
24888: PPUSH
24889: LD_INT 0
24891: PPUSH
24892: CALL_OW 109
24896: GO 24864
24898: POP
24899: POP
// end ;
24900: LD_VAR 0 3
24904: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
24905: LD_INT 0
24907: PPUSH
24908: PPUSH
24909: PPUSH
24910: PPUSH
24911: PPUSH
24912: PPUSH
24913: PPUSH
24914: PPUSH
// if not mc_bases then
24915: LD_EXP 90
24919: NOT
24920: IFFALSE 24924
// exit ;
24922: GO 25382
// for i = 1 to mc_bases do
24924: LD_ADDR_VAR 0 2
24928: PUSH
24929: DOUBLE
24930: LD_INT 1
24932: DEC
24933: ST_TO_ADDR
24934: LD_EXP 90
24938: PUSH
24939: FOR_TO
24940: IFFALSE 25380
// begin tmp := MC_ClassCheckReq ( i ) ;
24942: LD_ADDR_VAR 0 4
24946: PUSH
24947: LD_VAR 0 2
24951: PPUSH
24952: CALL 25387 0 1
24956: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
24957: LD_ADDR_EXP 131
24961: PUSH
24962: LD_EXP 131
24966: PPUSH
24967: LD_VAR 0 2
24971: PPUSH
24972: LD_VAR 0 4
24976: PPUSH
24977: CALL_OW 1
24981: ST_TO_ADDR
// if not tmp then
24982: LD_VAR 0 4
24986: NOT
24987: IFFALSE 24991
// continue ;
24989: GO 24939
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
24991: LD_ADDR_VAR 0 6
24995: PUSH
24996: LD_EXP 90
25000: PUSH
25001: LD_VAR 0 2
25005: ARRAY
25006: PPUSH
25007: LD_INT 2
25009: PUSH
25010: LD_INT 30
25012: PUSH
25013: LD_INT 4
25015: PUSH
25016: EMPTY
25017: LIST
25018: LIST
25019: PUSH
25020: LD_INT 30
25022: PUSH
25023: LD_INT 5
25025: PUSH
25026: EMPTY
25027: LIST
25028: LIST
25029: PUSH
25030: EMPTY
25031: LIST
25032: LIST
25033: LIST
25034: PPUSH
25035: CALL_OW 72
25039: PUSH
25040: LD_EXP 90
25044: PUSH
25045: LD_VAR 0 2
25049: ARRAY
25050: PPUSH
25051: LD_INT 2
25053: PUSH
25054: LD_INT 30
25056: PUSH
25057: LD_INT 0
25059: PUSH
25060: EMPTY
25061: LIST
25062: LIST
25063: PUSH
25064: LD_INT 30
25066: PUSH
25067: LD_INT 1
25069: PUSH
25070: EMPTY
25071: LIST
25072: LIST
25073: PUSH
25074: EMPTY
25075: LIST
25076: LIST
25077: LIST
25078: PPUSH
25079: CALL_OW 72
25083: PUSH
25084: LD_EXP 90
25088: PUSH
25089: LD_VAR 0 2
25093: ARRAY
25094: PPUSH
25095: LD_INT 30
25097: PUSH
25098: LD_INT 3
25100: PUSH
25101: EMPTY
25102: LIST
25103: LIST
25104: PPUSH
25105: CALL_OW 72
25109: PUSH
25110: LD_EXP 90
25114: PUSH
25115: LD_VAR 0 2
25119: ARRAY
25120: PPUSH
25121: LD_INT 2
25123: PUSH
25124: LD_INT 30
25126: PUSH
25127: LD_INT 6
25129: PUSH
25130: EMPTY
25131: LIST
25132: LIST
25133: PUSH
25134: LD_INT 30
25136: PUSH
25137: LD_INT 7
25139: PUSH
25140: EMPTY
25141: LIST
25142: LIST
25143: PUSH
25144: LD_INT 30
25146: PUSH
25147: LD_INT 8
25149: PUSH
25150: EMPTY
25151: LIST
25152: LIST
25153: PUSH
25154: EMPTY
25155: LIST
25156: LIST
25157: LIST
25158: LIST
25159: PPUSH
25160: CALL_OW 72
25164: PUSH
25165: EMPTY
25166: LIST
25167: LIST
25168: LIST
25169: LIST
25170: ST_TO_ADDR
// for j = 1 to 4 do
25171: LD_ADDR_VAR 0 3
25175: PUSH
25176: DOUBLE
25177: LD_INT 1
25179: DEC
25180: ST_TO_ADDR
25181: LD_INT 4
25183: PUSH
25184: FOR_TO
25185: IFFALSE 25376
// begin if not tmp [ j ] then
25187: LD_VAR 0 4
25191: PUSH
25192: LD_VAR 0 3
25196: ARRAY
25197: NOT
25198: IFFALSE 25202
// continue ;
25200: GO 25184
// for p in tmp [ j ] do
25202: LD_ADDR_VAR 0 5
25206: PUSH
25207: LD_VAR 0 4
25211: PUSH
25212: LD_VAR 0 3
25216: ARRAY
25217: PUSH
25218: FOR_IN
25219: IFFALSE 25372
// begin if not b [ j ] then
25221: LD_VAR 0 6
25225: PUSH
25226: LD_VAR 0 3
25230: ARRAY
25231: NOT
25232: IFFALSE 25236
// break ;
25234: GO 25372
// e := 0 ;
25236: LD_ADDR_VAR 0 7
25240: PUSH
25241: LD_INT 0
25243: ST_TO_ADDR
// for k in b [ j ] do
25244: LD_ADDR_VAR 0 8
25248: PUSH
25249: LD_VAR 0 6
25253: PUSH
25254: LD_VAR 0 3
25258: ARRAY
25259: PUSH
25260: FOR_IN
25261: IFFALSE 25288
// if IsNotFull ( k ) then
25263: LD_VAR 0 8
25267: PPUSH
25268: CALL 52967 0 1
25272: IFFALSE 25286
// begin e := k ;
25274: LD_ADDR_VAR 0 7
25278: PUSH
25279: LD_VAR 0 8
25283: ST_TO_ADDR
// break ;
25284: GO 25288
// end ;
25286: GO 25260
25288: POP
25289: POP
// if e and not UnitGoingToBuilding ( p , e ) then
25290: LD_VAR 0 7
25294: PUSH
25295: LD_VAR 0 5
25299: PPUSH
25300: LD_VAR 0 7
25304: PPUSH
25305: CALL 85387 0 2
25309: NOT
25310: AND
25311: IFFALSE 25370
// begin if IsInUnit ( p ) then
25313: LD_VAR 0 5
25317: PPUSH
25318: CALL_OW 310
25322: IFFALSE 25333
// ComExitBuilding ( p ) ;
25324: LD_VAR 0 5
25328: PPUSH
25329: CALL_OW 122
// ComEnterUnit ( p , e ) ;
25333: LD_VAR 0 5
25337: PPUSH
25338: LD_VAR 0 7
25342: PPUSH
25343: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
25347: LD_VAR 0 5
25351: PPUSH
25352: LD_VAR 0 3
25356: PPUSH
25357: CALL_OW 183
// AddComExitBuilding ( p ) ;
25361: LD_VAR 0 5
25365: PPUSH
25366: CALL_OW 182
// end ; end ;
25370: GO 25218
25372: POP
25373: POP
// end ;
25374: GO 25184
25376: POP
25377: POP
// end ;
25378: GO 24939
25380: POP
25381: POP
// end ;
25382: LD_VAR 0 1
25386: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
25387: LD_INT 0
25389: PPUSH
25390: PPUSH
25391: PPUSH
25392: PPUSH
25393: PPUSH
25394: PPUSH
25395: PPUSH
25396: PPUSH
25397: PPUSH
25398: PPUSH
25399: PPUSH
25400: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
25401: LD_VAR 0 1
25405: NOT
25406: PUSH
25407: LD_EXP 90
25411: PUSH
25412: LD_VAR 0 1
25416: ARRAY
25417: NOT
25418: OR
25419: PUSH
25420: LD_EXP 90
25424: PUSH
25425: LD_VAR 0 1
25429: ARRAY
25430: PPUSH
25431: LD_INT 2
25433: PUSH
25434: LD_INT 30
25436: PUSH
25437: LD_INT 0
25439: PUSH
25440: EMPTY
25441: LIST
25442: LIST
25443: PUSH
25444: LD_INT 30
25446: PUSH
25447: LD_INT 1
25449: PUSH
25450: EMPTY
25451: LIST
25452: LIST
25453: PUSH
25454: EMPTY
25455: LIST
25456: LIST
25457: LIST
25458: PPUSH
25459: CALL_OW 72
25463: NOT
25464: OR
25465: IFFALSE 25469
// exit ;
25467: GO 28972
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25469: LD_ADDR_VAR 0 4
25473: PUSH
25474: LD_EXP 90
25478: PUSH
25479: LD_VAR 0 1
25483: ARRAY
25484: PPUSH
25485: LD_INT 2
25487: PUSH
25488: LD_INT 25
25490: PUSH
25491: LD_INT 1
25493: PUSH
25494: EMPTY
25495: LIST
25496: LIST
25497: PUSH
25498: LD_INT 25
25500: PUSH
25501: LD_INT 2
25503: PUSH
25504: EMPTY
25505: LIST
25506: LIST
25507: PUSH
25508: LD_INT 25
25510: PUSH
25511: LD_INT 3
25513: PUSH
25514: EMPTY
25515: LIST
25516: LIST
25517: PUSH
25518: LD_INT 25
25520: PUSH
25521: LD_INT 4
25523: PUSH
25524: EMPTY
25525: LIST
25526: LIST
25527: PUSH
25528: LD_INT 25
25530: PUSH
25531: LD_INT 5
25533: PUSH
25534: EMPTY
25535: LIST
25536: LIST
25537: PUSH
25538: LD_INT 25
25540: PUSH
25541: LD_INT 8
25543: PUSH
25544: EMPTY
25545: LIST
25546: LIST
25547: PUSH
25548: LD_INT 25
25550: PUSH
25551: LD_INT 9
25553: PUSH
25554: EMPTY
25555: LIST
25556: LIST
25557: PUSH
25558: EMPTY
25559: LIST
25560: LIST
25561: LIST
25562: LIST
25563: LIST
25564: LIST
25565: LIST
25566: LIST
25567: PPUSH
25568: CALL_OW 72
25572: ST_TO_ADDR
// if not tmp then
25573: LD_VAR 0 4
25577: NOT
25578: IFFALSE 25582
// exit ;
25580: GO 28972
// for i in tmp do
25582: LD_ADDR_VAR 0 3
25586: PUSH
25587: LD_VAR 0 4
25591: PUSH
25592: FOR_IN
25593: IFFALSE 25624
// if GetTag ( i ) then
25595: LD_VAR 0 3
25599: PPUSH
25600: CALL_OW 110
25604: IFFALSE 25622
// tmp := tmp diff i ;
25606: LD_ADDR_VAR 0 4
25610: PUSH
25611: LD_VAR 0 4
25615: PUSH
25616: LD_VAR 0 3
25620: DIFF
25621: ST_TO_ADDR
25622: GO 25592
25624: POP
25625: POP
// if not tmp then
25626: LD_VAR 0 4
25630: NOT
25631: IFFALSE 25635
// exit ;
25633: GO 28972
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25635: LD_ADDR_VAR 0 5
25639: PUSH
25640: LD_EXP 90
25644: PUSH
25645: LD_VAR 0 1
25649: ARRAY
25650: PPUSH
25651: LD_INT 2
25653: PUSH
25654: LD_INT 25
25656: PUSH
25657: LD_INT 1
25659: PUSH
25660: EMPTY
25661: LIST
25662: LIST
25663: PUSH
25664: LD_INT 25
25666: PUSH
25667: LD_INT 5
25669: PUSH
25670: EMPTY
25671: LIST
25672: LIST
25673: PUSH
25674: LD_INT 25
25676: PUSH
25677: LD_INT 8
25679: PUSH
25680: EMPTY
25681: LIST
25682: LIST
25683: PUSH
25684: LD_INT 25
25686: PUSH
25687: LD_INT 9
25689: PUSH
25690: EMPTY
25691: LIST
25692: LIST
25693: PUSH
25694: EMPTY
25695: LIST
25696: LIST
25697: LIST
25698: LIST
25699: LIST
25700: PPUSH
25701: CALL_OW 72
25705: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
25706: LD_ADDR_VAR 0 6
25710: PUSH
25711: LD_EXP 90
25715: PUSH
25716: LD_VAR 0 1
25720: ARRAY
25721: PPUSH
25722: LD_INT 25
25724: PUSH
25725: LD_INT 2
25727: PUSH
25728: EMPTY
25729: LIST
25730: LIST
25731: PPUSH
25732: CALL_OW 72
25736: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
25737: LD_ADDR_VAR 0 7
25741: PUSH
25742: LD_EXP 90
25746: PUSH
25747: LD_VAR 0 1
25751: ARRAY
25752: PPUSH
25753: LD_INT 25
25755: PUSH
25756: LD_INT 3
25758: PUSH
25759: EMPTY
25760: LIST
25761: LIST
25762: PPUSH
25763: CALL_OW 72
25767: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
25768: LD_ADDR_VAR 0 8
25772: PUSH
25773: LD_EXP 90
25777: PUSH
25778: LD_VAR 0 1
25782: ARRAY
25783: PPUSH
25784: LD_INT 25
25786: PUSH
25787: LD_INT 4
25789: PUSH
25790: EMPTY
25791: LIST
25792: LIST
25793: PUSH
25794: LD_INT 24
25796: PUSH
25797: LD_INT 251
25799: PUSH
25800: EMPTY
25801: LIST
25802: LIST
25803: PUSH
25804: EMPTY
25805: LIST
25806: LIST
25807: PPUSH
25808: CALL_OW 72
25812: ST_TO_ADDR
// if mc_scan [ base ] then
25813: LD_EXP 113
25817: PUSH
25818: LD_VAR 0 1
25822: ARRAY
25823: IFFALSE 26284
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
25825: LD_ADDR_EXP 132
25829: PUSH
25830: LD_EXP 132
25834: PPUSH
25835: LD_VAR 0 1
25839: PPUSH
25840: LD_INT 4
25842: PPUSH
25843: CALL_OW 1
25847: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
25848: LD_ADDR_VAR 0 12
25852: PUSH
25853: LD_EXP 90
25857: PUSH
25858: LD_VAR 0 1
25862: ARRAY
25863: PPUSH
25864: LD_INT 2
25866: PUSH
25867: LD_INT 30
25869: PUSH
25870: LD_INT 4
25872: PUSH
25873: EMPTY
25874: LIST
25875: LIST
25876: PUSH
25877: LD_INT 30
25879: PUSH
25880: LD_INT 5
25882: PUSH
25883: EMPTY
25884: LIST
25885: LIST
25886: PUSH
25887: EMPTY
25888: LIST
25889: LIST
25890: LIST
25891: PPUSH
25892: CALL_OW 72
25896: ST_TO_ADDR
// if not b then
25897: LD_VAR 0 12
25901: NOT
25902: IFFALSE 25906
// exit ;
25904: GO 28972
// p := [ ] ;
25906: LD_ADDR_VAR 0 11
25910: PUSH
25911: EMPTY
25912: ST_TO_ADDR
// if sci >= 2 then
25913: LD_VAR 0 8
25917: PUSH
25918: LD_INT 2
25920: GREATEREQUAL
25921: IFFALSE 25952
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
25923: LD_ADDR_VAR 0 8
25927: PUSH
25928: LD_VAR 0 8
25932: PUSH
25933: LD_INT 1
25935: ARRAY
25936: PUSH
25937: LD_VAR 0 8
25941: PUSH
25942: LD_INT 2
25944: ARRAY
25945: PUSH
25946: EMPTY
25947: LIST
25948: LIST
25949: ST_TO_ADDR
25950: GO 26013
// if sci = 1 then
25952: LD_VAR 0 8
25956: PUSH
25957: LD_INT 1
25959: EQUAL
25960: IFFALSE 25981
// sci := [ sci [ 1 ] ] else
25962: LD_ADDR_VAR 0 8
25966: PUSH
25967: LD_VAR 0 8
25971: PUSH
25972: LD_INT 1
25974: ARRAY
25975: PUSH
25976: EMPTY
25977: LIST
25978: ST_TO_ADDR
25979: GO 26013
// if sci = 0 then
25981: LD_VAR 0 8
25985: PUSH
25986: LD_INT 0
25988: EQUAL
25989: IFFALSE 26013
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
25991: LD_ADDR_VAR 0 11
25995: PUSH
25996: LD_VAR 0 4
26000: PPUSH
26001: LD_INT 4
26003: PPUSH
26004: CALL 85250 0 2
26008: PUSH
26009: LD_INT 1
26011: ARRAY
26012: ST_TO_ADDR
// if eng > 4 then
26013: LD_VAR 0 6
26017: PUSH
26018: LD_INT 4
26020: GREATER
26021: IFFALSE 26067
// for i = eng downto 4 do
26023: LD_ADDR_VAR 0 3
26027: PUSH
26028: DOUBLE
26029: LD_VAR 0 6
26033: INC
26034: ST_TO_ADDR
26035: LD_INT 4
26037: PUSH
26038: FOR_DOWNTO
26039: IFFALSE 26065
// eng := eng diff eng [ i ] ;
26041: LD_ADDR_VAR 0 6
26045: PUSH
26046: LD_VAR 0 6
26050: PUSH
26051: LD_VAR 0 6
26055: PUSH
26056: LD_VAR 0 3
26060: ARRAY
26061: DIFF
26062: ST_TO_ADDR
26063: GO 26038
26065: POP
26066: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
26067: LD_ADDR_VAR 0 4
26071: PUSH
26072: LD_VAR 0 4
26076: PUSH
26077: LD_VAR 0 5
26081: PUSH
26082: LD_VAR 0 6
26086: UNION
26087: PUSH
26088: LD_VAR 0 7
26092: UNION
26093: PUSH
26094: LD_VAR 0 8
26098: UNION
26099: DIFF
26100: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
26101: LD_ADDR_VAR 0 13
26105: PUSH
26106: LD_EXP 90
26110: PUSH
26111: LD_VAR 0 1
26115: ARRAY
26116: PPUSH
26117: LD_INT 2
26119: PUSH
26120: LD_INT 30
26122: PUSH
26123: LD_INT 32
26125: PUSH
26126: EMPTY
26127: LIST
26128: LIST
26129: PUSH
26130: LD_INT 30
26132: PUSH
26133: LD_INT 31
26135: PUSH
26136: EMPTY
26137: LIST
26138: LIST
26139: PUSH
26140: EMPTY
26141: LIST
26142: LIST
26143: LIST
26144: PPUSH
26145: CALL_OW 72
26149: PUSH
26150: LD_EXP 90
26154: PUSH
26155: LD_VAR 0 1
26159: ARRAY
26160: PPUSH
26161: LD_INT 2
26163: PUSH
26164: LD_INT 30
26166: PUSH
26167: LD_INT 4
26169: PUSH
26170: EMPTY
26171: LIST
26172: LIST
26173: PUSH
26174: LD_INT 30
26176: PUSH
26177: LD_INT 5
26179: PUSH
26180: EMPTY
26181: LIST
26182: LIST
26183: PUSH
26184: EMPTY
26185: LIST
26186: LIST
26187: LIST
26188: PPUSH
26189: CALL_OW 72
26193: PUSH
26194: LD_INT 6
26196: MUL
26197: PLUS
26198: ST_TO_ADDR
// if bcount < tmp then
26199: LD_VAR 0 13
26203: PUSH
26204: LD_VAR 0 4
26208: LESS
26209: IFFALSE 26255
// for i = tmp downto bcount do
26211: LD_ADDR_VAR 0 3
26215: PUSH
26216: DOUBLE
26217: LD_VAR 0 4
26221: INC
26222: ST_TO_ADDR
26223: LD_VAR 0 13
26227: PUSH
26228: FOR_DOWNTO
26229: IFFALSE 26253
// tmp := Delete ( tmp , tmp ) ;
26231: LD_ADDR_VAR 0 4
26235: PUSH
26236: LD_VAR 0 4
26240: PPUSH
26241: LD_VAR 0 4
26245: PPUSH
26246: CALL_OW 3
26250: ST_TO_ADDR
26251: GO 26228
26253: POP
26254: POP
// result := [ tmp , 0 , 0 , p ] ;
26255: LD_ADDR_VAR 0 2
26259: PUSH
26260: LD_VAR 0 4
26264: PUSH
26265: LD_INT 0
26267: PUSH
26268: LD_INT 0
26270: PUSH
26271: LD_VAR 0 11
26275: PUSH
26276: EMPTY
26277: LIST
26278: LIST
26279: LIST
26280: LIST
26281: ST_TO_ADDR
// exit ;
26282: GO 28972
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26284: LD_EXP 90
26288: PUSH
26289: LD_VAR 0 1
26293: ARRAY
26294: PPUSH
26295: LD_INT 2
26297: PUSH
26298: LD_INT 30
26300: PUSH
26301: LD_INT 6
26303: PUSH
26304: EMPTY
26305: LIST
26306: LIST
26307: PUSH
26308: LD_INT 30
26310: PUSH
26311: LD_INT 7
26313: PUSH
26314: EMPTY
26315: LIST
26316: LIST
26317: PUSH
26318: LD_INT 30
26320: PUSH
26321: LD_INT 8
26323: PUSH
26324: EMPTY
26325: LIST
26326: LIST
26327: PUSH
26328: EMPTY
26329: LIST
26330: LIST
26331: LIST
26332: LIST
26333: PPUSH
26334: CALL_OW 72
26338: NOT
26339: PUSH
26340: LD_EXP 90
26344: PUSH
26345: LD_VAR 0 1
26349: ARRAY
26350: PPUSH
26351: LD_INT 30
26353: PUSH
26354: LD_INT 3
26356: PUSH
26357: EMPTY
26358: LIST
26359: LIST
26360: PPUSH
26361: CALL_OW 72
26365: NOT
26366: AND
26367: IFFALSE 26439
// begin if eng = tmp then
26369: LD_VAR 0 6
26373: PUSH
26374: LD_VAR 0 4
26378: EQUAL
26379: IFFALSE 26383
// exit ;
26381: GO 28972
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
26383: LD_ADDR_EXP 132
26387: PUSH
26388: LD_EXP 132
26392: PPUSH
26393: LD_VAR 0 1
26397: PPUSH
26398: LD_INT 1
26400: PPUSH
26401: CALL_OW 1
26405: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
26406: LD_ADDR_VAR 0 2
26410: PUSH
26411: LD_INT 0
26413: PUSH
26414: LD_VAR 0 4
26418: PUSH
26419: LD_VAR 0 6
26423: DIFF
26424: PUSH
26425: LD_INT 0
26427: PUSH
26428: LD_INT 0
26430: PUSH
26431: EMPTY
26432: LIST
26433: LIST
26434: LIST
26435: LIST
26436: ST_TO_ADDR
// exit ;
26437: GO 28972
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26439: LD_EXP 117
26443: PUSH
26444: LD_EXP 116
26448: PUSH
26449: LD_VAR 0 1
26453: ARRAY
26454: ARRAY
26455: PUSH
26456: LD_EXP 90
26460: PUSH
26461: LD_VAR 0 1
26465: ARRAY
26466: PPUSH
26467: LD_INT 2
26469: PUSH
26470: LD_INT 30
26472: PUSH
26473: LD_INT 6
26475: PUSH
26476: EMPTY
26477: LIST
26478: LIST
26479: PUSH
26480: LD_INT 30
26482: PUSH
26483: LD_INT 7
26485: PUSH
26486: EMPTY
26487: LIST
26488: LIST
26489: PUSH
26490: LD_INT 30
26492: PUSH
26493: LD_INT 8
26495: PUSH
26496: EMPTY
26497: LIST
26498: LIST
26499: PUSH
26500: EMPTY
26501: LIST
26502: LIST
26503: LIST
26504: LIST
26505: PPUSH
26506: CALL_OW 72
26510: AND
26511: PUSH
26512: LD_EXP 90
26516: PUSH
26517: LD_VAR 0 1
26521: ARRAY
26522: PPUSH
26523: LD_INT 30
26525: PUSH
26526: LD_INT 3
26528: PUSH
26529: EMPTY
26530: LIST
26531: LIST
26532: PPUSH
26533: CALL_OW 72
26537: NOT
26538: AND
26539: IFFALSE 26753
// begin if sci >= 6 then
26541: LD_VAR 0 8
26545: PUSH
26546: LD_INT 6
26548: GREATEREQUAL
26549: IFFALSE 26553
// exit ;
26551: GO 28972
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
26553: LD_ADDR_EXP 132
26557: PUSH
26558: LD_EXP 132
26562: PPUSH
26563: LD_VAR 0 1
26567: PPUSH
26568: LD_INT 2
26570: PPUSH
26571: CALL_OW 1
26575: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
26576: LD_ADDR_VAR 0 9
26580: PUSH
26581: LD_VAR 0 4
26585: PUSH
26586: LD_VAR 0 8
26590: DIFF
26591: PPUSH
26592: LD_INT 4
26594: PPUSH
26595: CALL 85250 0 2
26599: ST_TO_ADDR
// p := [ ] ;
26600: LD_ADDR_VAR 0 11
26604: PUSH
26605: EMPTY
26606: ST_TO_ADDR
// if sci < 6 and sort > 6 then
26607: LD_VAR 0 8
26611: PUSH
26612: LD_INT 6
26614: LESS
26615: PUSH
26616: LD_VAR 0 9
26620: PUSH
26621: LD_INT 6
26623: GREATER
26624: AND
26625: IFFALSE 26706
// begin for i = 1 to 6 - sci do
26627: LD_ADDR_VAR 0 3
26631: PUSH
26632: DOUBLE
26633: LD_INT 1
26635: DEC
26636: ST_TO_ADDR
26637: LD_INT 6
26639: PUSH
26640: LD_VAR 0 8
26644: MINUS
26645: PUSH
26646: FOR_TO
26647: IFFALSE 26702
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
26649: LD_ADDR_VAR 0 11
26653: PUSH
26654: LD_VAR 0 11
26658: PPUSH
26659: LD_VAR 0 11
26663: PUSH
26664: LD_INT 1
26666: PLUS
26667: PPUSH
26668: LD_VAR 0 9
26672: PUSH
26673: LD_INT 1
26675: ARRAY
26676: PPUSH
26677: CALL_OW 2
26681: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
26682: LD_ADDR_VAR 0 9
26686: PUSH
26687: LD_VAR 0 9
26691: PPUSH
26692: LD_INT 1
26694: PPUSH
26695: CALL_OW 3
26699: ST_TO_ADDR
// end ;
26700: GO 26646
26702: POP
26703: POP
// end else
26704: GO 26726
// if sort then
26706: LD_VAR 0 9
26710: IFFALSE 26726
// p := sort [ 1 ] ;
26712: LD_ADDR_VAR 0 11
26716: PUSH
26717: LD_VAR 0 9
26721: PUSH
26722: LD_INT 1
26724: ARRAY
26725: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
26726: LD_ADDR_VAR 0 2
26730: PUSH
26731: LD_INT 0
26733: PUSH
26734: LD_INT 0
26736: PUSH
26737: LD_INT 0
26739: PUSH
26740: LD_VAR 0 11
26744: PUSH
26745: EMPTY
26746: LIST
26747: LIST
26748: LIST
26749: LIST
26750: ST_TO_ADDR
// exit ;
26751: GO 28972
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26753: LD_EXP 117
26757: PUSH
26758: LD_EXP 116
26762: PUSH
26763: LD_VAR 0 1
26767: ARRAY
26768: ARRAY
26769: PUSH
26770: LD_EXP 90
26774: PUSH
26775: LD_VAR 0 1
26779: ARRAY
26780: PPUSH
26781: LD_INT 2
26783: PUSH
26784: LD_INT 30
26786: PUSH
26787: LD_INT 6
26789: PUSH
26790: EMPTY
26791: LIST
26792: LIST
26793: PUSH
26794: LD_INT 30
26796: PUSH
26797: LD_INT 7
26799: PUSH
26800: EMPTY
26801: LIST
26802: LIST
26803: PUSH
26804: LD_INT 30
26806: PUSH
26807: LD_INT 8
26809: PUSH
26810: EMPTY
26811: LIST
26812: LIST
26813: PUSH
26814: EMPTY
26815: LIST
26816: LIST
26817: LIST
26818: LIST
26819: PPUSH
26820: CALL_OW 72
26824: AND
26825: PUSH
26826: LD_EXP 90
26830: PUSH
26831: LD_VAR 0 1
26835: ARRAY
26836: PPUSH
26837: LD_INT 30
26839: PUSH
26840: LD_INT 3
26842: PUSH
26843: EMPTY
26844: LIST
26845: LIST
26846: PPUSH
26847: CALL_OW 72
26851: AND
26852: IFFALSE 27586
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
26854: LD_ADDR_EXP 132
26858: PUSH
26859: LD_EXP 132
26863: PPUSH
26864: LD_VAR 0 1
26868: PPUSH
26869: LD_INT 3
26871: PPUSH
26872: CALL_OW 1
26876: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
26877: LD_ADDR_VAR 0 2
26881: PUSH
26882: LD_INT 0
26884: PUSH
26885: LD_INT 0
26887: PUSH
26888: LD_INT 0
26890: PUSH
26891: LD_INT 0
26893: PUSH
26894: EMPTY
26895: LIST
26896: LIST
26897: LIST
26898: LIST
26899: ST_TO_ADDR
// if not eng then
26900: LD_VAR 0 6
26904: NOT
26905: IFFALSE 26968
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
26907: LD_ADDR_VAR 0 11
26911: PUSH
26912: LD_VAR 0 4
26916: PPUSH
26917: LD_INT 2
26919: PPUSH
26920: CALL 85250 0 2
26924: PUSH
26925: LD_INT 1
26927: ARRAY
26928: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
26929: LD_ADDR_VAR 0 2
26933: PUSH
26934: LD_VAR 0 2
26938: PPUSH
26939: LD_INT 2
26941: PPUSH
26942: LD_VAR 0 11
26946: PPUSH
26947: CALL_OW 1
26951: ST_TO_ADDR
// tmp := tmp diff p ;
26952: LD_ADDR_VAR 0 4
26956: PUSH
26957: LD_VAR 0 4
26961: PUSH
26962: LD_VAR 0 11
26966: DIFF
26967: ST_TO_ADDR
// end ; if tmp and sci < 6 then
26968: LD_VAR 0 4
26972: PUSH
26973: LD_VAR 0 8
26977: PUSH
26978: LD_INT 6
26980: LESS
26981: AND
26982: IFFALSE 27170
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
26984: LD_ADDR_VAR 0 9
26988: PUSH
26989: LD_VAR 0 4
26993: PUSH
26994: LD_VAR 0 8
26998: PUSH
26999: LD_VAR 0 7
27003: UNION
27004: DIFF
27005: PPUSH
27006: LD_INT 4
27008: PPUSH
27009: CALL 85250 0 2
27013: ST_TO_ADDR
// p := [ ] ;
27014: LD_ADDR_VAR 0 11
27018: PUSH
27019: EMPTY
27020: ST_TO_ADDR
// if sort then
27021: LD_VAR 0 9
27025: IFFALSE 27141
// for i = 1 to 6 - sci do
27027: LD_ADDR_VAR 0 3
27031: PUSH
27032: DOUBLE
27033: LD_INT 1
27035: DEC
27036: ST_TO_ADDR
27037: LD_INT 6
27039: PUSH
27040: LD_VAR 0 8
27044: MINUS
27045: PUSH
27046: FOR_TO
27047: IFFALSE 27139
// begin if i = sort then
27049: LD_VAR 0 3
27053: PUSH
27054: LD_VAR 0 9
27058: EQUAL
27059: IFFALSE 27063
// break ;
27061: GO 27139
// if GetClass ( i ) = 4 then
27063: LD_VAR 0 3
27067: PPUSH
27068: CALL_OW 257
27072: PUSH
27073: LD_INT 4
27075: EQUAL
27076: IFFALSE 27080
// continue ;
27078: GO 27046
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27080: LD_ADDR_VAR 0 11
27084: PUSH
27085: LD_VAR 0 11
27089: PPUSH
27090: LD_VAR 0 11
27094: PUSH
27095: LD_INT 1
27097: PLUS
27098: PPUSH
27099: LD_VAR 0 9
27103: PUSH
27104: LD_VAR 0 3
27108: ARRAY
27109: PPUSH
27110: CALL_OW 2
27114: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27115: LD_ADDR_VAR 0 4
27119: PUSH
27120: LD_VAR 0 4
27124: PUSH
27125: LD_VAR 0 9
27129: PUSH
27130: LD_VAR 0 3
27134: ARRAY
27135: DIFF
27136: ST_TO_ADDR
// end ;
27137: GO 27046
27139: POP
27140: POP
// if p then
27141: LD_VAR 0 11
27145: IFFALSE 27170
// result := Replace ( result , 4 , p ) ;
27147: LD_ADDR_VAR 0 2
27151: PUSH
27152: LD_VAR 0 2
27156: PPUSH
27157: LD_INT 4
27159: PPUSH
27160: LD_VAR 0 11
27164: PPUSH
27165: CALL_OW 1
27169: ST_TO_ADDR
// end ; if tmp and mech < 6 then
27170: LD_VAR 0 4
27174: PUSH
27175: LD_VAR 0 7
27179: PUSH
27180: LD_INT 6
27182: LESS
27183: AND
27184: IFFALSE 27372
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27186: LD_ADDR_VAR 0 9
27190: PUSH
27191: LD_VAR 0 4
27195: PUSH
27196: LD_VAR 0 8
27200: PUSH
27201: LD_VAR 0 7
27205: UNION
27206: DIFF
27207: PPUSH
27208: LD_INT 3
27210: PPUSH
27211: CALL 85250 0 2
27215: ST_TO_ADDR
// p := [ ] ;
27216: LD_ADDR_VAR 0 11
27220: PUSH
27221: EMPTY
27222: ST_TO_ADDR
// if sort then
27223: LD_VAR 0 9
27227: IFFALSE 27343
// for i = 1 to 6 - mech do
27229: LD_ADDR_VAR 0 3
27233: PUSH
27234: DOUBLE
27235: LD_INT 1
27237: DEC
27238: ST_TO_ADDR
27239: LD_INT 6
27241: PUSH
27242: LD_VAR 0 7
27246: MINUS
27247: PUSH
27248: FOR_TO
27249: IFFALSE 27341
// begin if i = sort then
27251: LD_VAR 0 3
27255: PUSH
27256: LD_VAR 0 9
27260: EQUAL
27261: IFFALSE 27265
// break ;
27263: GO 27341
// if GetClass ( i ) = 3 then
27265: LD_VAR 0 3
27269: PPUSH
27270: CALL_OW 257
27274: PUSH
27275: LD_INT 3
27277: EQUAL
27278: IFFALSE 27282
// continue ;
27280: GO 27248
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27282: LD_ADDR_VAR 0 11
27286: PUSH
27287: LD_VAR 0 11
27291: PPUSH
27292: LD_VAR 0 11
27296: PUSH
27297: LD_INT 1
27299: PLUS
27300: PPUSH
27301: LD_VAR 0 9
27305: PUSH
27306: LD_VAR 0 3
27310: ARRAY
27311: PPUSH
27312: CALL_OW 2
27316: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27317: LD_ADDR_VAR 0 4
27321: PUSH
27322: LD_VAR 0 4
27326: PUSH
27327: LD_VAR 0 9
27331: PUSH
27332: LD_VAR 0 3
27336: ARRAY
27337: DIFF
27338: ST_TO_ADDR
// end ;
27339: GO 27248
27341: POP
27342: POP
// if p then
27343: LD_VAR 0 11
27347: IFFALSE 27372
// result := Replace ( result , 3 , p ) ;
27349: LD_ADDR_VAR 0 2
27353: PUSH
27354: LD_VAR 0 2
27358: PPUSH
27359: LD_INT 3
27361: PPUSH
27362: LD_VAR 0 11
27366: PPUSH
27367: CALL_OW 1
27371: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
27372: LD_VAR 0 4
27376: PUSH
27377: LD_INT 6
27379: GREATER
27380: PUSH
27381: LD_VAR 0 6
27385: PUSH
27386: LD_INT 6
27388: LESS
27389: AND
27390: IFFALSE 27584
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
27392: LD_ADDR_VAR 0 9
27396: PUSH
27397: LD_VAR 0 4
27401: PUSH
27402: LD_VAR 0 8
27406: PUSH
27407: LD_VAR 0 7
27411: UNION
27412: PUSH
27413: LD_VAR 0 6
27417: UNION
27418: DIFF
27419: PPUSH
27420: LD_INT 2
27422: PPUSH
27423: CALL 85250 0 2
27427: ST_TO_ADDR
// p := [ ] ;
27428: LD_ADDR_VAR 0 11
27432: PUSH
27433: EMPTY
27434: ST_TO_ADDR
// if sort then
27435: LD_VAR 0 9
27439: IFFALSE 27555
// for i = 1 to 6 - eng do
27441: LD_ADDR_VAR 0 3
27445: PUSH
27446: DOUBLE
27447: LD_INT 1
27449: DEC
27450: ST_TO_ADDR
27451: LD_INT 6
27453: PUSH
27454: LD_VAR 0 6
27458: MINUS
27459: PUSH
27460: FOR_TO
27461: IFFALSE 27553
// begin if i = sort then
27463: LD_VAR 0 3
27467: PUSH
27468: LD_VAR 0 9
27472: EQUAL
27473: IFFALSE 27477
// break ;
27475: GO 27553
// if GetClass ( i ) = 2 then
27477: LD_VAR 0 3
27481: PPUSH
27482: CALL_OW 257
27486: PUSH
27487: LD_INT 2
27489: EQUAL
27490: IFFALSE 27494
// continue ;
27492: GO 27460
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27494: LD_ADDR_VAR 0 11
27498: PUSH
27499: LD_VAR 0 11
27503: PPUSH
27504: LD_VAR 0 11
27508: PUSH
27509: LD_INT 1
27511: PLUS
27512: PPUSH
27513: LD_VAR 0 9
27517: PUSH
27518: LD_VAR 0 3
27522: ARRAY
27523: PPUSH
27524: CALL_OW 2
27528: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27529: LD_ADDR_VAR 0 4
27533: PUSH
27534: LD_VAR 0 4
27538: PUSH
27539: LD_VAR 0 9
27543: PUSH
27544: LD_VAR 0 3
27548: ARRAY
27549: DIFF
27550: ST_TO_ADDR
// end ;
27551: GO 27460
27553: POP
27554: POP
// if p then
27555: LD_VAR 0 11
27559: IFFALSE 27584
// result := Replace ( result , 2 , p ) ;
27561: LD_ADDR_VAR 0 2
27565: PUSH
27566: LD_VAR 0 2
27570: PPUSH
27571: LD_INT 2
27573: PPUSH
27574: LD_VAR 0 11
27578: PPUSH
27579: CALL_OW 1
27583: ST_TO_ADDR
// end ; exit ;
27584: GO 28972
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
27586: LD_EXP 117
27590: PUSH
27591: LD_EXP 116
27595: PUSH
27596: LD_VAR 0 1
27600: ARRAY
27601: ARRAY
27602: NOT
27603: PUSH
27604: LD_EXP 90
27608: PUSH
27609: LD_VAR 0 1
27613: ARRAY
27614: PPUSH
27615: LD_INT 30
27617: PUSH
27618: LD_INT 3
27620: PUSH
27621: EMPTY
27622: LIST
27623: LIST
27624: PPUSH
27625: CALL_OW 72
27629: AND
27630: PUSH
27631: LD_EXP 95
27635: PUSH
27636: LD_VAR 0 1
27640: ARRAY
27641: AND
27642: IFFALSE 28250
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
27644: LD_ADDR_EXP 132
27648: PUSH
27649: LD_EXP 132
27653: PPUSH
27654: LD_VAR 0 1
27658: PPUSH
27659: LD_INT 5
27661: PPUSH
27662: CALL_OW 1
27666: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27667: LD_ADDR_VAR 0 2
27671: PUSH
27672: LD_INT 0
27674: PUSH
27675: LD_INT 0
27677: PUSH
27678: LD_INT 0
27680: PUSH
27681: LD_INT 0
27683: PUSH
27684: EMPTY
27685: LIST
27686: LIST
27687: LIST
27688: LIST
27689: ST_TO_ADDR
// if sci > 1 then
27690: LD_VAR 0 8
27694: PUSH
27695: LD_INT 1
27697: GREATER
27698: IFFALSE 27726
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
27700: LD_ADDR_VAR 0 4
27704: PUSH
27705: LD_VAR 0 4
27709: PUSH
27710: LD_VAR 0 8
27714: PUSH
27715: LD_VAR 0 8
27719: PUSH
27720: LD_INT 1
27722: ARRAY
27723: DIFF
27724: DIFF
27725: ST_TO_ADDR
// if tmp and not sci then
27726: LD_VAR 0 4
27730: PUSH
27731: LD_VAR 0 8
27735: NOT
27736: AND
27737: IFFALSE 27806
// begin sort := SortBySkill ( tmp , 4 ) ;
27739: LD_ADDR_VAR 0 9
27743: PUSH
27744: LD_VAR 0 4
27748: PPUSH
27749: LD_INT 4
27751: PPUSH
27752: CALL 85250 0 2
27756: ST_TO_ADDR
// if sort then
27757: LD_VAR 0 9
27761: IFFALSE 27777
// p := sort [ 1 ] ;
27763: LD_ADDR_VAR 0 11
27767: PUSH
27768: LD_VAR 0 9
27772: PUSH
27773: LD_INT 1
27775: ARRAY
27776: ST_TO_ADDR
// if p then
27777: LD_VAR 0 11
27781: IFFALSE 27806
// result := Replace ( result , 4 , p ) ;
27783: LD_ADDR_VAR 0 2
27787: PUSH
27788: LD_VAR 0 2
27792: PPUSH
27793: LD_INT 4
27795: PPUSH
27796: LD_VAR 0 11
27800: PPUSH
27801: CALL_OW 1
27805: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
27806: LD_ADDR_VAR 0 4
27810: PUSH
27811: LD_VAR 0 4
27815: PUSH
27816: LD_VAR 0 7
27820: DIFF
27821: ST_TO_ADDR
// if tmp and mech < 6 then
27822: LD_VAR 0 4
27826: PUSH
27827: LD_VAR 0 7
27831: PUSH
27832: LD_INT 6
27834: LESS
27835: AND
27836: IFFALSE 28024
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27838: LD_ADDR_VAR 0 9
27842: PUSH
27843: LD_VAR 0 4
27847: PUSH
27848: LD_VAR 0 8
27852: PUSH
27853: LD_VAR 0 7
27857: UNION
27858: DIFF
27859: PPUSH
27860: LD_INT 3
27862: PPUSH
27863: CALL 85250 0 2
27867: ST_TO_ADDR
// p := [ ] ;
27868: LD_ADDR_VAR 0 11
27872: PUSH
27873: EMPTY
27874: ST_TO_ADDR
// if sort then
27875: LD_VAR 0 9
27879: IFFALSE 27995
// for i = 1 to 6 - mech do
27881: LD_ADDR_VAR 0 3
27885: PUSH
27886: DOUBLE
27887: LD_INT 1
27889: DEC
27890: ST_TO_ADDR
27891: LD_INT 6
27893: PUSH
27894: LD_VAR 0 7
27898: MINUS
27899: PUSH
27900: FOR_TO
27901: IFFALSE 27993
// begin if i = sort then
27903: LD_VAR 0 3
27907: PUSH
27908: LD_VAR 0 9
27912: EQUAL
27913: IFFALSE 27917
// break ;
27915: GO 27993
// if GetClass ( i ) = 3 then
27917: LD_VAR 0 3
27921: PPUSH
27922: CALL_OW 257
27926: PUSH
27927: LD_INT 3
27929: EQUAL
27930: IFFALSE 27934
// continue ;
27932: GO 27900
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27934: LD_ADDR_VAR 0 11
27938: PUSH
27939: LD_VAR 0 11
27943: PPUSH
27944: LD_VAR 0 11
27948: PUSH
27949: LD_INT 1
27951: PLUS
27952: PPUSH
27953: LD_VAR 0 9
27957: PUSH
27958: LD_VAR 0 3
27962: ARRAY
27963: PPUSH
27964: CALL_OW 2
27968: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27969: LD_ADDR_VAR 0 4
27973: PUSH
27974: LD_VAR 0 4
27978: PUSH
27979: LD_VAR 0 9
27983: PUSH
27984: LD_VAR 0 3
27988: ARRAY
27989: DIFF
27990: ST_TO_ADDR
// end ;
27991: GO 27900
27993: POP
27994: POP
// if p then
27995: LD_VAR 0 11
27999: IFFALSE 28024
// result := Replace ( result , 3 , p ) ;
28001: LD_ADDR_VAR 0 2
28005: PUSH
28006: LD_VAR 0 2
28010: PPUSH
28011: LD_INT 3
28013: PPUSH
28014: LD_VAR 0 11
28018: PPUSH
28019: CALL_OW 1
28023: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28024: LD_ADDR_VAR 0 4
28028: PUSH
28029: LD_VAR 0 4
28033: PUSH
28034: LD_VAR 0 6
28038: DIFF
28039: ST_TO_ADDR
// if tmp and eng < 6 then
28040: LD_VAR 0 4
28044: PUSH
28045: LD_VAR 0 6
28049: PUSH
28050: LD_INT 6
28052: LESS
28053: AND
28054: IFFALSE 28248
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
28056: LD_ADDR_VAR 0 9
28060: PUSH
28061: LD_VAR 0 4
28065: PUSH
28066: LD_VAR 0 8
28070: PUSH
28071: LD_VAR 0 7
28075: UNION
28076: PUSH
28077: LD_VAR 0 6
28081: UNION
28082: DIFF
28083: PPUSH
28084: LD_INT 2
28086: PPUSH
28087: CALL 85250 0 2
28091: ST_TO_ADDR
// p := [ ] ;
28092: LD_ADDR_VAR 0 11
28096: PUSH
28097: EMPTY
28098: ST_TO_ADDR
// if sort then
28099: LD_VAR 0 9
28103: IFFALSE 28219
// for i = 1 to 6 - eng do
28105: LD_ADDR_VAR 0 3
28109: PUSH
28110: DOUBLE
28111: LD_INT 1
28113: DEC
28114: ST_TO_ADDR
28115: LD_INT 6
28117: PUSH
28118: LD_VAR 0 6
28122: MINUS
28123: PUSH
28124: FOR_TO
28125: IFFALSE 28217
// begin if i = sort then
28127: LD_VAR 0 3
28131: PUSH
28132: LD_VAR 0 9
28136: EQUAL
28137: IFFALSE 28141
// break ;
28139: GO 28217
// if GetClass ( i ) = 2 then
28141: LD_VAR 0 3
28145: PPUSH
28146: CALL_OW 257
28150: PUSH
28151: LD_INT 2
28153: EQUAL
28154: IFFALSE 28158
// continue ;
28156: GO 28124
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28158: LD_ADDR_VAR 0 11
28162: PUSH
28163: LD_VAR 0 11
28167: PPUSH
28168: LD_VAR 0 11
28172: PUSH
28173: LD_INT 1
28175: PLUS
28176: PPUSH
28177: LD_VAR 0 9
28181: PUSH
28182: LD_VAR 0 3
28186: ARRAY
28187: PPUSH
28188: CALL_OW 2
28192: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28193: LD_ADDR_VAR 0 4
28197: PUSH
28198: LD_VAR 0 4
28202: PUSH
28203: LD_VAR 0 9
28207: PUSH
28208: LD_VAR 0 3
28212: ARRAY
28213: DIFF
28214: ST_TO_ADDR
// end ;
28215: GO 28124
28217: POP
28218: POP
// if p then
28219: LD_VAR 0 11
28223: IFFALSE 28248
// result := Replace ( result , 2 , p ) ;
28225: LD_ADDR_VAR 0 2
28229: PUSH
28230: LD_VAR 0 2
28234: PPUSH
28235: LD_INT 2
28237: PPUSH
28238: LD_VAR 0 11
28242: PPUSH
28243: CALL_OW 1
28247: ST_TO_ADDR
// end ; exit ;
28248: GO 28972
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
28250: LD_EXP 117
28254: PUSH
28255: LD_EXP 116
28259: PUSH
28260: LD_VAR 0 1
28264: ARRAY
28265: ARRAY
28266: NOT
28267: PUSH
28268: LD_EXP 90
28272: PUSH
28273: LD_VAR 0 1
28277: ARRAY
28278: PPUSH
28279: LD_INT 30
28281: PUSH
28282: LD_INT 3
28284: PUSH
28285: EMPTY
28286: LIST
28287: LIST
28288: PPUSH
28289: CALL_OW 72
28293: AND
28294: PUSH
28295: LD_EXP 95
28299: PUSH
28300: LD_VAR 0 1
28304: ARRAY
28305: NOT
28306: AND
28307: IFFALSE 28972
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
28309: LD_ADDR_EXP 132
28313: PUSH
28314: LD_EXP 132
28318: PPUSH
28319: LD_VAR 0 1
28323: PPUSH
28324: LD_INT 6
28326: PPUSH
28327: CALL_OW 1
28331: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
28332: LD_ADDR_VAR 0 2
28336: PUSH
28337: LD_INT 0
28339: PUSH
28340: LD_INT 0
28342: PUSH
28343: LD_INT 0
28345: PUSH
28346: LD_INT 0
28348: PUSH
28349: EMPTY
28350: LIST
28351: LIST
28352: LIST
28353: LIST
28354: ST_TO_ADDR
// if sci >= 1 then
28355: LD_VAR 0 8
28359: PUSH
28360: LD_INT 1
28362: GREATEREQUAL
28363: IFFALSE 28385
// tmp := tmp diff sci [ 1 ] ;
28365: LD_ADDR_VAR 0 4
28369: PUSH
28370: LD_VAR 0 4
28374: PUSH
28375: LD_VAR 0 8
28379: PUSH
28380: LD_INT 1
28382: ARRAY
28383: DIFF
28384: ST_TO_ADDR
// if tmp and not sci then
28385: LD_VAR 0 4
28389: PUSH
28390: LD_VAR 0 8
28394: NOT
28395: AND
28396: IFFALSE 28465
// begin sort := SortBySkill ( tmp , 4 ) ;
28398: LD_ADDR_VAR 0 9
28402: PUSH
28403: LD_VAR 0 4
28407: PPUSH
28408: LD_INT 4
28410: PPUSH
28411: CALL 85250 0 2
28415: ST_TO_ADDR
// if sort then
28416: LD_VAR 0 9
28420: IFFALSE 28436
// p := sort [ 1 ] ;
28422: LD_ADDR_VAR 0 11
28426: PUSH
28427: LD_VAR 0 9
28431: PUSH
28432: LD_INT 1
28434: ARRAY
28435: ST_TO_ADDR
// if p then
28436: LD_VAR 0 11
28440: IFFALSE 28465
// result := Replace ( result , 4 , p ) ;
28442: LD_ADDR_VAR 0 2
28446: PUSH
28447: LD_VAR 0 2
28451: PPUSH
28452: LD_INT 4
28454: PPUSH
28455: LD_VAR 0 11
28459: PPUSH
28460: CALL_OW 1
28464: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
28465: LD_ADDR_VAR 0 4
28469: PUSH
28470: LD_VAR 0 4
28474: PUSH
28475: LD_VAR 0 7
28479: DIFF
28480: ST_TO_ADDR
// if tmp and mech < 6 then
28481: LD_VAR 0 4
28485: PUSH
28486: LD_VAR 0 7
28490: PUSH
28491: LD_INT 6
28493: LESS
28494: AND
28495: IFFALSE 28677
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
28497: LD_ADDR_VAR 0 9
28501: PUSH
28502: LD_VAR 0 4
28506: PUSH
28507: LD_VAR 0 7
28511: DIFF
28512: PPUSH
28513: LD_INT 3
28515: PPUSH
28516: CALL 85250 0 2
28520: ST_TO_ADDR
// p := [ ] ;
28521: LD_ADDR_VAR 0 11
28525: PUSH
28526: EMPTY
28527: ST_TO_ADDR
// if sort then
28528: LD_VAR 0 9
28532: IFFALSE 28648
// for i = 1 to 6 - mech do
28534: LD_ADDR_VAR 0 3
28538: PUSH
28539: DOUBLE
28540: LD_INT 1
28542: DEC
28543: ST_TO_ADDR
28544: LD_INT 6
28546: PUSH
28547: LD_VAR 0 7
28551: MINUS
28552: PUSH
28553: FOR_TO
28554: IFFALSE 28646
// begin if i = sort then
28556: LD_VAR 0 3
28560: PUSH
28561: LD_VAR 0 9
28565: EQUAL
28566: IFFALSE 28570
// break ;
28568: GO 28646
// if GetClass ( i ) = 3 then
28570: LD_VAR 0 3
28574: PPUSH
28575: CALL_OW 257
28579: PUSH
28580: LD_INT 3
28582: EQUAL
28583: IFFALSE 28587
// continue ;
28585: GO 28553
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28587: LD_ADDR_VAR 0 11
28591: PUSH
28592: LD_VAR 0 11
28596: PPUSH
28597: LD_VAR 0 11
28601: PUSH
28602: LD_INT 1
28604: PLUS
28605: PPUSH
28606: LD_VAR 0 9
28610: PUSH
28611: LD_VAR 0 3
28615: ARRAY
28616: PPUSH
28617: CALL_OW 2
28621: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28622: LD_ADDR_VAR 0 4
28626: PUSH
28627: LD_VAR 0 4
28631: PUSH
28632: LD_VAR 0 9
28636: PUSH
28637: LD_VAR 0 3
28641: ARRAY
28642: DIFF
28643: ST_TO_ADDR
// end ;
28644: GO 28553
28646: POP
28647: POP
// if p then
28648: LD_VAR 0 11
28652: IFFALSE 28677
// result := Replace ( result , 3 , p ) ;
28654: LD_ADDR_VAR 0 2
28658: PUSH
28659: LD_VAR 0 2
28663: PPUSH
28664: LD_INT 3
28666: PPUSH
28667: LD_VAR 0 11
28671: PPUSH
28672: CALL_OW 1
28676: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28677: LD_ADDR_VAR 0 4
28681: PUSH
28682: LD_VAR 0 4
28686: PUSH
28687: LD_VAR 0 6
28691: DIFF
28692: ST_TO_ADDR
// if tmp and eng < 4 then
28693: LD_VAR 0 4
28697: PUSH
28698: LD_VAR 0 6
28702: PUSH
28703: LD_INT 4
28705: LESS
28706: AND
28707: IFFALSE 28897
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
28709: LD_ADDR_VAR 0 9
28713: PUSH
28714: LD_VAR 0 4
28718: PUSH
28719: LD_VAR 0 7
28723: PUSH
28724: LD_VAR 0 6
28728: UNION
28729: DIFF
28730: PPUSH
28731: LD_INT 2
28733: PPUSH
28734: CALL 85250 0 2
28738: ST_TO_ADDR
// p := [ ] ;
28739: LD_ADDR_VAR 0 11
28743: PUSH
28744: EMPTY
28745: ST_TO_ADDR
// if sort then
28746: LD_VAR 0 9
28750: IFFALSE 28866
// for i = 1 to 4 - eng do
28752: LD_ADDR_VAR 0 3
28756: PUSH
28757: DOUBLE
28758: LD_INT 1
28760: DEC
28761: ST_TO_ADDR
28762: LD_INT 4
28764: PUSH
28765: LD_VAR 0 6
28769: MINUS
28770: PUSH
28771: FOR_TO
28772: IFFALSE 28864
// begin if i = sort then
28774: LD_VAR 0 3
28778: PUSH
28779: LD_VAR 0 9
28783: EQUAL
28784: IFFALSE 28788
// break ;
28786: GO 28864
// if GetClass ( i ) = 2 then
28788: LD_VAR 0 3
28792: PPUSH
28793: CALL_OW 257
28797: PUSH
28798: LD_INT 2
28800: EQUAL
28801: IFFALSE 28805
// continue ;
28803: GO 28771
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28805: LD_ADDR_VAR 0 11
28809: PUSH
28810: LD_VAR 0 11
28814: PPUSH
28815: LD_VAR 0 11
28819: PUSH
28820: LD_INT 1
28822: PLUS
28823: PPUSH
28824: LD_VAR 0 9
28828: PUSH
28829: LD_VAR 0 3
28833: ARRAY
28834: PPUSH
28835: CALL_OW 2
28839: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28840: LD_ADDR_VAR 0 4
28844: PUSH
28845: LD_VAR 0 4
28849: PUSH
28850: LD_VAR 0 9
28854: PUSH
28855: LD_VAR 0 3
28859: ARRAY
28860: DIFF
28861: ST_TO_ADDR
// end ;
28862: GO 28771
28864: POP
28865: POP
// if p then
28866: LD_VAR 0 11
28870: IFFALSE 28895
// result := Replace ( result , 2 , p ) ;
28872: LD_ADDR_VAR 0 2
28876: PUSH
28877: LD_VAR 0 2
28881: PPUSH
28882: LD_INT 2
28884: PPUSH
28885: LD_VAR 0 11
28889: PPUSH
28890: CALL_OW 1
28894: ST_TO_ADDR
// end else
28895: GO 28941
// for i = eng downto 5 do
28897: LD_ADDR_VAR 0 3
28901: PUSH
28902: DOUBLE
28903: LD_VAR 0 6
28907: INC
28908: ST_TO_ADDR
28909: LD_INT 5
28911: PUSH
28912: FOR_DOWNTO
28913: IFFALSE 28939
// tmp := tmp union eng [ i ] ;
28915: LD_ADDR_VAR 0 4
28919: PUSH
28920: LD_VAR 0 4
28924: PUSH
28925: LD_VAR 0 6
28929: PUSH
28930: LD_VAR 0 3
28934: ARRAY
28935: UNION
28936: ST_TO_ADDR
28937: GO 28912
28939: POP
28940: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
28941: LD_ADDR_VAR 0 2
28945: PUSH
28946: LD_VAR 0 2
28950: PPUSH
28951: LD_INT 1
28953: PPUSH
28954: LD_VAR 0 4
28958: PUSH
28959: LD_VAR 0 5
28963: DIFF
28964: PPUSH
28965: CALL_OW 1
28969: ST_TO_ADDR
// exit ;
28970: GO 28972
// end ; end ;
28972: LD_VAR 0 2
28976: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
28977: LD_INT 0
28979: PPUSH
28980: PPUSH
28981: PPUSH
// if not mc_bases then
28982: LD_EXP 90
28986: NOT
28987: IFFALSE 28991
// exit ;
28989: GO 29097
// for i = 1 to mc_bases do
28991: LD_ADDR_VAR 0 2
28995: PUSH
28996: DOUBLE
28997: LD_INT 1
28999: DEC
29000: ST_TO_ADDR
29001: LD_EXP 90
29005: PUSH
29006: FOR_TO
29007: IFFALSE 29088
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
29009: LD_ADDR_VAR 0 3
29013: PUSH
29014: LD_EXP 90
29018: PUSH
29019: LD_VAR 0 2
29023: ARRAY
29024: PPUSH
29025: LD_INT 21
29027: PUSH
29028: LD_INT 3
29030: PUSH
29031: EMPTY
29032: LIST
29033: LIST
29034: PUSH
29035: LD_INT 3
29037: PUSH
29038: LD_INT 24
29040: PUSH
29041: LD_INT 1000
29043: PUSH
29044: EMPTY
29045: LIST
29046: LIST
29047: PUSH
29048: EMPTY
29049: LIST
29050: LIST
29051: PUSH
29052: EMPTY
29053: LIST
29054: LIST
29055: PPUSH
29056: CALL_OW 72
29060: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
29061: LD_ADDR_EXP 91
29065: PUSH
29066: LD_EXP 91
29070: PPUSH
29071: LD_VAR 0 2
29075: PPUSH
29076: LD_VAR 0 3
29080: PPUSH
29081: CALL_OW 1
29085: ST_TO_ADDR
// end ;
29086: GO 29006
29088: POP
29089: POP
// RaiseSailEvent ( 101 ) ;
29090: LD_INT 101
29092: PPUSH
29093: CALL_OW 427
// end ;
29097: LD_VAR 0 1
29101: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
29102: LD_INT 0
29104: PPUSH
29105: PPUSH
29106: PPUSH
29107: PPUSH
29108: PPUSH
29109: PPUSH
29110: PPUSH
// if not mc_bases then
29111: LD_EXP 90
29115: NOT
29116: IFFALSE 29120
// exit ;
29118: GO 29682
// for i = 1 to mc_bases do
29120: LD_ADDR_VAR 0 2
29124: PUSH
29125: DOUBLE
29126: LD_INT 1
29128: DEC
29129: ST_TO_ADDR
29130: LD_EXP 90
29134: PUSH
29135: FOR_TO
29136: IFFALSE 29673
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
29138: LD_ADDR_VAR 0 5
29142: PUSH
29143: LD_EXP 90
29147: PUSH
29148: LD_VAR 0 2
29152: ARRAY
29153: PUSH
29154: LD_EXP 119
29158: PUSH
29159: LD_VAR 0 2
29163: ARRAY
29164: UNION
29165: PPUSH
29166: LD_INT 21
29168: PUSH
29169: LD_INT 1
29171: PUSH
29172: EMPTY
29173: LIST
29174: LIST
29175: PUSH
29176: LD_INT 1
29178: PUSH
29179: LD_INT 3
29181: PUSH
29182: LD_INT 54
29184: PUSH
29185: EMPTY
29186: LIST
29187: PUSH
29188: EMPTY
29189: LIST
29190: LIST
29191: PUSH
29192: LD_INT 3
29194: PUSH
29195: LD_INT 24
29197: PUSH
29198: LD_INT 800
29200: PUSH
29201: EMPTY
29202: LIST
29203: LIST
29204: PUSH
29205: EMPTY
29206: LIST
29207: LIST
29208: PUSH
29209: EMPTY
29210: LIST
29211: LIST
29212: LIST
29213: PUSH
29214: EMPTY
29215: LIST
29216: LIST
29217: PPUSH
29218: CALL_OW 72
29222: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
29223: LD_ADDR_VAR 0 6
29227: PUSH
29228: LD_EXP 90
29232: PUSH
29233: LD_VAR 0 2
29237: ARRAY
29238: PPUSH
29239: LD_INT 21
29241: PUSH
29242: LD_INT 1
29244: PUSH
29245: EMPTY
29246: LIST
29247: LIST
29248: PUSH
29249: LD_INT 1
29251: PUSH
29252: LD_INT 3
29254: PUSH
29255: LD_INT 54
29257: PUSH
29258: EMPTY
29259: LIST
29260: PUSH
29261: EMPTY
29262: LIST
29263: LIST
29264: PUSH
29265: LD_INT 3
29267: PUSH
29268: LD_INT 24
29270: PUSH
29271: LD_INT 250
29273: PUSH
29274: EMPTY
29275: LIST
29276: LIST
29277: PUSH
29278: EMPTY
29279: LIST
29280: LIST
29281: PUSH
29282: EMPTY
29283: LIST
29284: LIST
29285: LIST
29286: PUSH
29287: EMPTY
29288: LIST
29289: LIST
29290: PPUSH
29291: CALL_OW 72
29295: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
29296: LD_ADDR_VAR 0 7
29300: PUSH
29301: LD_VAR 0 5
29305: PUSH
29306: LD_VAR 0 6
29310: DIFF
29311: ST_TO_ADDR
// if not need_heal_1 then
29312: LD_VAR 0 6
29316: NOT
29317: IFFALSE 29350
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
29319: LD_ADDR_EXP 93
29323: PUSH
29324: LD_EXP 93
29328: PPUSH
29329: LD_VAR 0 2
29333: PUSH
29334: LD_INT 1
29336: PUSH
29337: EMPTY
29338: LIST
29339: LIST
29340: PPUSH
29341: EMPTY
29342: PPUSH
29343: CALL 55701 0 3
29347: ST_TO_ADDR
29348: GO 29420
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
29350: LD_ADDR_EXP 93
29354: PUSH
29355: LD_EXP 93
29359: PPUSH
29360: LD_VAR 0 2
29364: PUSH
29365: LD_INT 1
29367: PUSH
29368: EMPTY
29369: LIST
29370: LIST
29371: PPUSH
29372: LD_EXP 93
29376: PUSH
29377: LD_VAR 0 2
29381: ARRAY
29382: PUSH
29383: LD_INT 1
29385: ARRAY
29386: PPUSH
29387: LD_INT 3
29389: PUSH
29390: LD_INT 24
29392: PUSH
29393: LD_INT 1000
29395: PUSH
29396: EMPTY
29397: LIST
29398: LIST
29399: PUSH
29400: EMPTY
29401: LIST
29402: LIST
29403: PPUSH
29404: CALL_OW 72
29408: PUSH
29409: LD_VAR 0 6
29413: UNION
29414: PPUSH
29415: CALL 55701 0 3
29419: ST_TO_ADDR
// if not need_heal_2 then
29420: LD_VAR 0 7
29424: NOT
29425: IFFALSE 29458
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
29427: LD_ADDR_EXP 93
29431: PUSH
29432: LD_EXP 93
29436: PPUSH
29437: LD_VAR 0 2
29441: PUSH
29442: LD_INT 2
29444: PUSH
29445: EMPTY
29446: LIST
29447: LIST
29448: PPUSH
29449: EMPTY
29450: PPUSH
29451: CALL 55701 0 3
29455: ST_TO_ADDR
29456: GO 29490
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
29458: LD_ADDR_EXP 93
29462: PUSH
29463: LD_EXP 93
29467: PPUSH
29468: LD_VAR 0 2
29472: PUSH
29473: LD_INT 2
29475: PUSH
29476: EMPTY
29477: LIST
29478: LIST
29479: PPUSH
29480: LD_VAR 0 7
29484: PPUSH
29485: CALL 55701 0 3
29489: ST_TO_ADDR
// if need_heal_2 then
29490: LD_VAR 0 7
29494: IFFALSE 29655
// for j in need_heal_2 do
29496: LD_ADDR_VAR 0 3
29500: PUSH
29501: LD_VAR 0 7
29505: PUSH
29506: FOR_IN
29507: IFFALSE 29653
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
29509: LD_ADDR_VAR 0 5
29513: PUSH
29514: LD_EXP 90
29518: PUSH
29519: LD_VAR 0 2
29523: ARRAY
29524: PPUSH
29525: LD_INT 2
29527: PUSH
29528: LD_INT 30
29530: PUSH
29531: LD_INT 6
29533: PUSH
29534: EMPTY
29535: LIST
29536: LIST
29537: PUSH
29538: LD_INT 30
29540: PUSH
29541: LD_INT 7
29543: PUSH
29544: EMPTY
29545: LIST
29546: LIST
29547: PUSH
29548: LD_INT 30
29550: PUSH
29551: LD_INT 8
29553: PUSH
29554: EMPTY
29555: LIST
29556: LIST
29557: PUSH
29558: LD_INT 30
29560: PUSH
29561: LD_INT 0
29563: PUSH
29564: EMPTY
29565: LIST
29566: LIST
29567: PUSH
29568: LD_INT 30
29570: PUSH
29571: LD_INT 1
29573: PUSH
29574: EMPTY
29575: LIST
29576: LIST
29577: PUSH
29578: EMPTY
29579: LIST
29580: LIST
29581: LIST
29582: LIST
29583: LIST
29584: LIST
29585: PPUSH
29586: CALL_OW 72
29590: ST_TO_ADDR
// if tmp then
29591: LD_VAR 0 5
29595: IFFALSE 29651
// begin k := NearestUnitToUnit ( tmp , j ) ;
29597: LD_ADDR_VAR 0 4
29601: PUSH
29602: LD_VAR 0 5
29606: PPUSH
29607: LD_VAR 0 3
29611: PPUSH
29612: CALL_OW 74
29616: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
29617: LD_VAR 0 3
29621: PPUSH
29622: LD_VAR 0 4
29626: PPUSH
29627: CALL_OW 296
29631: PUSH
29632: LD_INT 5
29634: GREATER
29635: IFFALSE 29651
// ComMoveUnit ( j , k ) ;
29637: LD_VAR 0 3
29641: PPUSH
29642: LD_VAR 0 4
29646: PPUSH
29647: CALL_OW 112
// end ; end ;
29651: GO 29506
29653: POP
29654: POP
// if not need_heal_1 and not need_heal_2 then
29655: LD_VAR 0 6
29659: NOT
29660: PUSH
29661: LD_VAR 0 7
29665: NOT
29666: AND
29667: IFFALSE 29671
// continue ;
29669: GO 29135
// end ;
29671: GO 29135
29673: POP
29674: POP
// RaiseSailEvent ( 102 ) ;
29675: LD_INT 102
29677: PPUSH
29678: CALL_OW 427
// end ;
29682: LD_VAR 0 1
29686: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
29687: LD_INT 0
29689: PPUSH
29690: PPUSH
29691: PPUSH
29692: PPUSH
29693: PPUSH
29694: PPUSH
29695: PPUSH
29696: PPUSH
// if not mc_bases then
29697: LD_EXP 90
29701: NOT
29702: IFFALSE 29706
// exit ;
29704: GO 30541
// for i = 1 to mc_bases do
29706: LD_ADDR_VAR 0 2
29710: PUSH
29711: DOUBLE
29712: LD_INT 1
29714: DEC
29715: ST_TO_ADDR
29716: LD_EXP 90
29720: PUSH
29721: FOR_TO
29722: IFFALSE 30539
// begin if not mc_building_need_repair [ i ] then
29724: LD_EXP 91
29728: PUSH
29729: LD_VAR 0 2
29733: ARRAY
29734: NOT
29735: IFFALSE 29909
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
29737: LD_ADDR_VAR 0 6
29741: PUSH
29742: LD_EXP 109
29746: PUSH
29747: LD_VAR 0 2
29751: ARRAY
29752: PPUSH
29753: LD_INT 3
29755: PUSH
29756: LD_INT 24
29758: PUSH
29759: LD_INT 1000
29761: PUSH
29762: EMPTY
29763: LIST
29764: LIST
29765: PUSH
29766: EMPTY
29767: LIST
29768: LIST
29769: PUSH
29770: LD_INT 2
29772: PUSH
29773: LD_INT 34
29775: PUSH
29776: LD_INT 13
29778: PUSH
29779: EMPTY
29780: LIST
29781: LIST
29782: PUSH
29783: LD_INT 34
29785: PUSH
29786: LD_INT 52
29788: PUSH
29789: EMPTY
29790: LIST
29791: LIST
29792: PUSH
29793: EMPTY
29794: LIST
29795: LIST
29796: LIST
29797: PUSH
29798: EMPTY
29799: LIST
29800: LIST
29801: PPUSH
29802: CALL_OW 72
29806: ST_TO_ADDR
// if cranes then
29807: LD_VAR 0 6
29811: IFFALSE 29873
// for j in cranes do
29813: LD_ADDR_VAR 0 3
29817: PUSH
29818: LD_VAR 0 6
29822: PUSH
29823: FOR_IN
29824: IFFALSE 29871
// if not IsInArea ( j , mc_parking [ i ] ) then
29826: LD_VAR 0 3
29830: PPUSH
29831: LD_EXP 114
29835: PUSH
29836: LD_VAR 0 2
29840: ARRAY
29841: PPUSH
29842: CALL_OW 308
29846: NOT
29847: IFFALSE 29869
// ComMoveToArea ( j , mc_parking [ i ] ) ;
29849: LD_VAR 0 3
29853: PPUSH
29854: LD_EXP 114
29858: PUSH
29859: LD_VAR 0 2
29863: ARRAY
29864: PPUSH
29865: CALL_OW 113
29869: GO 29823
29871: POP
29872: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
29873: LD_ADDR_EXP 92
29877: PUSH
29878: LD_EXP 92
29882: PPUSH
29883: LD_VAR 0 2
29887: PPUSH
29888: EMPTY
29889: PPUSH
29890: CALL_OW 1
29894: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
29895: LD_VAR 0 2
29899: PPUSH
29900: LD_INT 101
29902: PPUSH
29903: CALL 24810 0 2
// continue ;
29907: GO 29721
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
29909: LD_ADDR_EXP 96
29913: PUSH
29914: LD_EXP 96
29918: PPUSH
29919: LD_VAR 0 2
29923: PPUSH
29924: EMPTY
29925: PPUSH
29926: CALL_OW 1
29930: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
29931: LD_VAR 0 2
29935: PPUSH
29936: LD_INT 103
29938: PPUSH
29939: CALL 24810 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
29943: LD_ADDR_VAR 0 5
29947: PUSH
29948: LD_EXP 90
29952: PUSH
29953: LD_VAR 0 2
29957: ARRAY
29958: PUSH
29959: LD_EXP 119
29963: PUSH
29964: LD_VAR 0 2
29968: ARRAY
29969: UNION
29970: PPUSH
29971: LD_INT 2
29973: PUSH
29974: LD_INT 25
29976: PUSH
29977: LD_INT 2
29979: PUSH
29980: EMPTY
29981: LIST
29982: LIST
29983: PUSH
29984: LD_INT 25
29986: PUSH
29987: LD_INT 16
29989: PUSH
29990: EMPTY
29991: LIST
29992: LIST
29993: PUSH
29994: EMPTY
29995: LIST
29996: LIST
29997: LIST
29998: PUSH
29999: EMPTY
30000: LIST
30001: PPUSH
30002: CALL_OW 72
30006: PUSH
30007: LD_EXP 93
30011: PUSH
30012: LD_VAR 0 2
30016: ARRAY
30017: PUSH
30018: LD_INT 1
30020: ARRAY
30021: PUSH
30022: LD_EXP 93
30026: PUSH
30027: LD_VAR 0 2
30031: ARRAY
30032: PUSH
30033: LD_INT 2
30035: ARRAY
30036: UNION
30037: DIFF
30038: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
30039: LD_ADDR_VAR 0 6
30043: PUSH
30044: LD_EXP 109
30048: PUSH
30049: LD_VAR 0 2
30053: ARRAY
30054: PPUSH
30055: LD_INT 2
30057: PUSH
30058: LD_INT 34
30060: PUSH
30061: LD_INT 13
30063: PUSH
30064: EMPTY
30065: LIST
30066: LIST
30067: PUSH
30068: LD_INT 34
30070: PUSH
30071: LD_INT 52
30073: PUSH
30074: EMPTY
30075: LIST
30076: LIST
30077: PUSH
30078: EMPTY
30079: LIST
30080: LIST
30081: LIST
30082: PPUSH
30083: CALL_OW 72
30087: ST_TO_ADDR
// if cranes then
30088: LD_VAR 0 6
30092: IFFALSE 30228
// begin for j in cranes do
30094: LD_ADDR_VAR 0 3
30098: PUSH
30099: LD_VAR 0 6
30103: PUSH
30104: FOR_IN
30105: IFFALSE 30226
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
30107: LD_VAR 0 3
30111: PPUSH
30112: CALL_OW 256
30116: PUSH
30117: LD_INT 500
30119: GREATEREQUAL
30120: PUSH
30121: LD_VAR 0 3
30125: PPUSH
30126: CALL_OW 314
30130: NOT
30131: AND
30132: IFFALSE 30166
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
30134: LD_VAR 0 3
30138: PPUSH
30139: LD_EXP 91
30143: PUSH
30144: LD_VAR 0 2
30148: ARRAY
30149: PPUSH
30150: LD_VAR 0 3
30154: PPUSH
30155: CALL_OW 74
30159: PPUSH
30160: CALL_OW 130
30164: GO 30224
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
30166: LD_VAR 0 3
30170: PPUSH
30171: CALL_OW 256
30175: PUSH
30176: LD_INT 500
30178: LESS
30179: PUSH
30180: LD_VAR 0 3
30184: PPUSH
30185: LD_EXP 114
30189: PUSH
30190: LD_VAR 0 2
30194: ARRAY
30195: PPUSH
30196: CALL_OW 308
30200: NOT
30201: AND
30202: IFFALSE 30224
// ComMoveToArea ( j , mc_parking [ i ] ) ;
30204: LD_VAR 0 3
30208: PPUSH
30209: LD_EXP 114
30213: PUSH
30214: LD_VAR 0 2
30218: ARRAY
30219: PPUSH
30220: CALL_OW 113
30224: GO 30104
30226: POP
30227: POP
// end ; if tmp > 3 then
30228: LD_VAR 0 5
30232: PUSH
30233: LD_INT 3
30235: GREATER
30236: IFFALSE 30256
// tmp := ShrinkArray ( tmp , 4 ) ;
30238: LD_ADDR_VAR 0 5
30242: PUSH
30243: LD_VAR 0 5
30247: PPUSH
30248: LD_INT 4
30250: PPUSH
30251: CALL 87059 0 2
30255: ST_TO_ADDR
// if not tmp then
30256: LD_VAR 0 5
30260: NOT
30261: IFFALSE 30265
// continue ;
30263: GO 29721
// for j in tmp do
30265: LD_ADDR_VAR 0 3
30269: PUSH
30270: LD_VAR 0 5
30274: PUSH
30275: FOR_IN
30276: IFFALSE 30535
// begin if IsInUnit ( j ) then
30278: LD_VAR 0 3
30282: PPUSH
30283: CALL_OW 310
30287: IFFALSE 30298
// ComExitBuilding ( j ) ;
30289: LD_VAR 0 3
30293: PPUSH
30294: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
30298: LD_VAR 0 3
30302: PUSH
30303: LD_EXP 92
30307: PUSH
30308: LD_VAR 0 2
30312: ARRAY
30313: IN
30314: NOT
30315: IFFALSE 30373
// begin SetTag ( j , 101 ) ;
30317: LD_VAR 0 3
30321: PPUSH
30322: LD_INT 101
30324: PPUSH
30325: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
30329: LD_ADDR_EXP 92
30333: PUSH
30334: LD_EXP 92
30338: PPUSH
30339: LD_VAR 0 2
30343: PUSH
30344: LD_EXP 92
30348: PUSH
30349: LD_VAR 0 2
30353: ARRAY
30354: PUSH
30355: LD_INT 1
30357: PLUS
30358: PUSH
30359: EMPTY
30360: LIST
30361: LIST
30362: PPUSH
30363: LD_VAR 0 3
30367: PPUSH
30368: CALL 55701 0 3
30372: ST_TO_ADDR
// end ; wait ( 1 ) ;
30373: LD_INT 1
30375: PPUSH
30376: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
30380: LD_ADDR_VAR 0 7
30384: PUSH
30385: LD_EXP 91
30389: PUSH
30390: LD_VAR 0 2
30394: ARRAY
30395: ST_TO_ADDR
// if mc_scan [ i ] then
30396: LD_EXP 113
30400: PUSH
30401: LD_VAR 0 2
30405: ARRAY
30406: IFFALSE 30468
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
30408: LD_ADDR_VAR 0 7
30412: PUSH
30413: LD_EXP 91
30417: PUSH
30418: LD_VAR 0 2
30422: ARRAY
30423: PPUSH
30424: LD_INT 3
30426: PUSH
30427: LD_INT 30
30429: PUSH
30430: LD_INT 32
30432: PUSH
30433: EMPTY
30434: LIST
30435: LIST
30436: PUSH
30437: LD_INT 30
30439: PUSH
30440: LD_INT 33
30442: PUSH
30443: EMPTY
30444: LIST
30445: LIST
30446: PUSH
30447: LD_INT 30
30449: PUSH
30450: LD_INT 31
30452: PUSH
30453: EMPTY
30454: LIST
30455: LIST
30456: PUSH
30457: EMPTY
30458: LIST
30459: LIST
30460: LIST
30461: LIST
30462: PPUSH
30463: CALL_OW 72
30467: ST_TO_ADDR
// if not to_repair_tmp then
30468: LD_VAR 0 7
30472: NOT
30473: IFFALSE 30477
// continue ;
30475: GO 30275
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
30477: LD_ADDR_VAR 0 8
30481: PUSH
30482: LD_VAR 0 7
30486: PPUSH
30487: LD_VAR 0 3
30491: PPUSH
30492: CALL_OW 74
30496: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 5 then
30497: LD_VAR 0 8
30501: PPUSH
30502: LD_INT 16
30504: PPUSH
30505: CALL 58294 0 2
30509: PUSH
30510: LD_INT 4
30512: ARRAY
30513: PUSH
30514: LD_INT 5
30516: LESS
30517: IFFALSE 30533
// ComRepairBuilding ( j , to_repair ) ;
30519: LD_VAR 0 3
30523: PPUSH
30524: LD_VAR 0 8
30528: PPUSH
30529: CALL_OW 130
// end ;
30533: GO 30275
30535: POP
30536: POP
// end ;
30537: GO 29721
30539: POP
30540: POP
// end ;
30541: LD_VAR 0 1
30545: RET
// export function MC_Heal ; var i , j , tmp ; begin
30546: LD_INT 0
30548: PPUSH
30549: PPUSH
30550: PPUSH
30551: PPUSH
// if not mc_bases then
30552: LD_EXP 90
30556: NOT
30557: IFFALSE 30561
// exit ;
30559: GO 30963
// for i = 1 to mc_bases do
30561: LD_ADDR_VAR 0 2
30565: PUSH
30566: DOUBLE
30567: LD_INT 1
30569: DEC
30570: ST_TO_ADDR
30571: LD_EXP 90
30575: PUSH
30576: FOR_TO
30577: IFFALSE 30961
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
30579: LD_EXP 93
30583: PUSH
30584: LD_VAR 0 2
30588: ARRAY
30589: PUSH
30590: LD_INT 1
30592: ARRAY
30593: NOT
30594: PUSH
30595: LD_EXP 93
30599: PUSH
30600: LD_VAR 0 2
30604: ARRAY
30605: PUSH
30606: LD_INT 2
30608: ARRAY
30609: NOT
30610: AND
30611: IFFALSE 30649
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
30613: LD_ADDR_EXP 94
30617: PUSH
30618: LD_EXP 94
30622: PPUSH
30623: LD_VAR 0 2
30627: PPUSH
30628: EMPTY
30629: PPUSH
30630: CALL_OW 1
30634: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
30635: LD_VAR 0 2
30639: PPUSH
30640: LD_INT 102
30642: PPUSH
30643: CALL 24810 0 2
// continue ;
30647: GO 30576
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
30649: LD_ADDR_VAR 0 4
30653: PUSH
30654: LD_EXP 90
30658: PUSH
30659: LD_VAR 0 2
30663: ARRAY
30664: PPUSH
30665: LD_INT 25
30667: PUSH
30668: LD_INT 4
30670: PUSH
30671: EMPTY
30672: LIST
30673: LIST
30674: PPUSH
30675: CALL_OW 72
30679: ST_TO_ADDR
// if not tmp then
30680: LD_VAR 0 4
30684: NOT
30685: IFFALSE 30689
// continue ;
30687: GO 30576
// if mc_taming [ i ] then
30689: LD_EXP 121
30693: PUSH
30694: LD_VAR 0 2
30698: ARRAY
30699: IFFALSE 30723
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
30701: LD_ADDR_EXP 121
30705: PUSH
30706: LD_EXP 121
30710: PPUSH
30711: LD_VAR 0 2
30715: PPUSH
30716: EMPTY
30717: PPUSH
30718: CALL_OW 1
30722: ST_TO_ADDR
// for j in tmp do
30723: LD_ADDR_VAR 0 3
30727: PUSH
30728: LD_VAR 0 4
30732: PUSH
30733: FOR_IN
30734: IFFALSE 30957
// begin if IsInUnit ( j ) then
30736: LD_VAR 0 3
30740: PPUSH
30741: CALL_OW 310
30745: IFFALSE 30756
// ComExitBuilding ( j ) ;
30747: LD_VAR 0 3
30751: PPUSH
30752: CALL_OW 122
// if not j in mc_healers [ i ] then
30756: LD_VAR 0 3
30760: PUSH
30761: LD_EXP 94
30765: PUSH
30766: LD_VAR 0 2
30770: ARRAY
30771: IN
30772: NOT
30773: IFFALSE 30819
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
30775: LD_ADDR_EXP 94
30779: PUSH
30780: LD_EXP 94
30784: PPUSH
30785: LD_VAR 0 2
30789: PUSH
30790: LD_EXP 94
30794: PUSH
30795: LD_VAR 0 2
30799: ARRAY
30800: PUSH
30801: LD_INT 1
30803: PLUS
30804: PUSH
30805: EMPTY
30806: LIST
30807: LIST
30808: PPUSH
30809: LD_VAR 0 3
30813: PPUSH
30814: CALL 55701 0 3
30818: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
30819: LD_VAR 0 3
30823: PPUSH
30824: CALL_OW 110
30828: PUSH
30829: LD_INT 102
30831: NONEQUAL
30832: IFFALSE 30846
// SetTag ( j , 102 ) ;
30834: LD_VAR 0 3
30838: PPUSH
30839: LD_INT 102
30841: PPUSH
30842: CALL_OW 109
// Wait ( 3 ) ;
30846: LD_INT 3
30848: PPUSH
30849: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
30853: LD_EXP 93
30857: PUSH
30858: LD_VAR 0 2
30862: ARRAY
30863: PUSH
30864: LD_INT 1
30866: ARRAY
30867: IFFALSE 30899
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
30869: LD_VAR 0 3
30873: PPUSH
30874: LD_EXP 93
30878: PUSH
30879: LD_VAR 0 2
30883: ARRAY
30884: PUSH
30885: LD_INT 1
30887: ARRAY
30888: PUSH
30889: LD_INT 1
30891: ARRAY
30892: PPUSH
30893: CALL_OW 128
30897: GO 30955
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
30899: LD_VAR 0 3
30903: PPUSH
30904: CALL_OW 314
30908: NOT
30909: PUSH
30910: LD_EXP 93
30914: PUSH
30915: LD_VAR 0 2
30919: ARRAY
30920: PUSH
30921: LD_INT 2
30923: ARRAY
30924: AND
30925: IFFALSE 30955
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
30927: LD_VAR 0 3
30931: PPUSH
30932: LD_EXP 93
30936: PUSH
30937: LD_VAR 0 2
30941: ARRAY
30942: PUSH
30943: LD_INT 2
30945: ARRAY
30946: PUSH
30947: LD_INT 1
30949: ARRAY
30950: PPUSH
30951: CALL_OW 128
// end ;
30955: GO 30733
30957: POP
30958: POP
// end ;
30959: GO 30576
30961: POP
30962: POP
// end ;
30963: LD_VAR 0 1
30967: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
30968: LD_INT 0
30970: PPUSH
30971: PPUSH
30972: PPUSH
30973: PPUSH
30974: PPUSH
// if not mc_bases then
30975: LD_EXP 90
30979: NOT
30980: IFFALSE 30984
// exit ;
30982: GO 32127
// for i = 1 to mc_bases do
30984: LD_ADDR_VAR 0 2
30988: PUSH
30989: DOUBLE
30990: LD_INT 1
30992: DEC
30993: ST_TO_ADDR
30994: LD_EXP 90
30998: PUSH
30999: FOR_TO
31000: IFFALSE 32125
// begin if mc_scan [ i ] then
31002: LD_EXP 113
31006: PUSH
31007: LD_VAR 0 2
31011: ARRAY
31012: IFFALSE 31016
// continue ;
31014: GO 30999
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
31016: LD_EXP 95
31020: PUSH
31021: LD_VAR 0 2
31025: ARRAY
31026: NOT
31027: PUSH
31028: LD_EXP 97
31032: PUSH
31033: LD_VAR 0 2
31037: ARRAY
31038: NOT
31039: AND
31040: PUSH
31041: LD_EXP 96
31045: PUSH
31046: LD_VAR 0 2
31050: ARRAY
31051: AND
31052: IFFALSE 31090
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
31054: LD_ADDR_EXP 96
31058: PUSH
31059: LD_EXP 96
31063: PPUSH
31064: LD_VAR 0 2
31068: PPUSH
31069: EMPTY
31070: PPUSH
31071: CALL_OW 1
31075: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
31076: LD_VAR 0 2
31080: PPUSH
31081: LD_INT 103
31083: PPUSH
31084: CALL 24810 0 2
// continue ;
31088: GO 30999
// end ; if mc_construct_list [ i ] then
31090: LD_EXP 97
31094: PUSH
31095: LD_VAR 0 2
31099: ARRAY
31100: IFFALSE 31320
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31102: LD_ADDR_VAR 0 4
31106: PUSH
31107: LD_EXP 90
31111: PUSH
31112: LD_VAR 0 2
31116: ARRAY
31117: PPUSH
31118: LD_INT 25
31120: PUSH
31121: LD_INT 2
31123: PUSH
31124: EMPTY
31125: LIST
31126: LIST
31127: PPUSH
31128: CALL_OW 72
31132: PUSH
31133: LD_EXP 92
31137: PUSH
31138: LD_VAR 0 2
31142: ARRAY
31143: DIFF
31144: ST_TO_ADDR
// if not tmp then
31145: LD_VAR 0 4
31149: NOT
31150: IFFALSE 31154
// continue ;
31152: GO 30999
// for j in tmp do
31154: LD_ADDR_VAR 0 3
31158: PUSH
31159: LD_VAR 0 4
31163: PUSH
31164: FOR_IN
31165: IFFALSE 31316
// begin if not mc_builders [ i ] then
31167: LD_EXP 96
31171: PUSH
31172: LD_VAR 0 2
31176: ARRAY
31177: NOT
31178: IFFALSE 31236
// begin SetTag ( j , 103 ) ;
31180: LD_VAR 0 3
31184: PPUSH
31185: LD_INT 103
31187: PPUSH
31188: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31192: LD_ADDR_EXP 96
31196: PUSH
31197: LD_EXP 96
31201: PPUSH
31202: LD_VAR 0 2
31206: PUSH
31207: LD_EXP 96
31211: PUSH
31212: LD_VAR 0 2
31216: ARRAY
31217: PUSH
31218: LD_INT 1
31220: PLUS
31221: PUSH
31222: EMPTY
31223: LIST
31224: LIST
31225: PPUSH
31226: LD_VAR 0 3
31230: PPUSH
31231: CALL 55701 0 3
31235: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31236: LD_VAR 0 3
31240: PPUSH
31241: CALL_OW 310
31245: IFFALSE 31256
// ComExitBuilding ( j ) ;
31247: LD_VAR 0 3
31251: PPUSH
31252: CALL_OW 122
// wait ( 3 ) ;
31256: LD_INT 3
31258: PPUSH
31259: CALL_OW 67
// if not mc_construct_list [ i ] then
31263: LD_EXP 97
31267: PUSH
31268: LD_VAR 0 2
31272: ARRAY
31273: NOT
31274: IFFALSE 31278
// break ;
31276: GO 31316
// if not HasTask ( j ) then
31278: LD_VAR 0 3
31282: PPUSH
31283: CALL_OW 314
31287: NOT
31288: IFFALSE 31314
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
31290: LD_VAR 0 3
31294: PPUSH
31295: LD_EXP 97
31299: PUSH
31300: LD_VAR 0 2
31304: ARRAY
31305: PUSH
31306: LD_INT 1
31308: ARRAY
31309: PPUSH
31310: CALL 58552 0 2
// end ;
31314: GO 31164
31316: POP
31317: POP
// end else
31318: GO 32123
// if mc_build_list [ i ] then
31320: LD_EXP 95
31324: PUSH
31325: LD_VAR 0 2
31329: ARRAY
31330: IFFALSE 32123
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31332: LD_ADDR_VAR 0 5
31336: PUSH
31337: LD_EXP 90
31341: PUSH
31342: LD_VAR 0 2
31346: ARRAY
31347: PPUSH
31348: LD_INT 2
31350: PUSH
31351: LD_INT 30
31353: PUSH
31354: LD_INT 0
31356: PUSH
31357: EMPTY
31358: LIST
31359: LIST
31360: PUSH
31361: LD_INT 30
31363: PUSH
31364: LD_INT 1
31366: PUSH
31367: EMPTY
31368: LIST
31369: LIST
31370: PUSH
31371: EMPTY
31372: LIST
31373: LIST
31374: LIST
31375: PPUSH
31376: CALL_OW 72
31380: ST_TO_ADDR
// if depot then
31381: LD_VAR 0 5
31385: IFFALSE 31403
// depot := depot [ 1 ] else
31387: LD_ADDR_VAR 0 5
31391: PUSH
31392: LD_VAR 0 5
31396: PUSH
31397: LD_INT 1
31399: ARRAY
31400: ST_TO_ADDR
31401: GO 31411
// depot := 0 ;
31403: LD_ADDR_VAR 0 5
31407: PUSH
31408: LD_INT 0
31410: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
31411: LD_EXP 95
31415: PUSH
31416: LD_VAR 0 2
31420: ARRAY
31421: PUSH
31422: LD_INT 1
31424: ARRAY
31425: PUSH
31426: LD_INT 1
31428: ARRAY
31429: PPUSH
31430: CALL 58382 0 1
31434: PUSH
31435: LD_EXP 90
31439: PUSH
31440: LD_VAR 0 2
31444: ARRAY
31445: PPUSH
31446: LD_INT 2
31448: PUSH
31449: LD_INT 30
31451: PUSH
31452: LD_INT 2
31454: PUSH
31455: EMPTY
31456: LIST
31457: LIST
31458: PUSH
31459: LD_INT 30
31461: PUSH
31462: LD_INT 3
31464: PUSH
31465: EMPTY
31466: LIST
31467: LIST
31468: PUSH
31469: EMPTY
31470: LIST
31471: LIST
31472: LIST
31473: PPUSH
31474: CALL_OW 72
31478: NOT
31479: AND
31480: IFFALSE 31585
// begin for j = 1 to mc_build_list [ i ] do
31482: LD_ADDR_VAR 0 3
31486: PUSH
31487: DOUBLE
31488: LD_INT 1
31490: DEC
31491: ST_TO_ADDR
31492: LD_EXP 95
31496: PUSH
31497: LD_VAR 0 2
31501: ARRAY
31502: PUSH
31503: FOR_TO
31504: IFFALSE 31583
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
31506: LD_EXP 95
31510: PUSH
31511: LD_VAR 0 2
31515: ARRAY
31516: PUSH
31517: LD_VAR 0 3
31521: ARRAY
31522: PUSH
31523: LD_INT 1
31525: ARRAY
31526: PUSH
31527: LD_INT 2
31529: EQUAL
31530: IFFALSE 31581
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
31532: LD_ADDR_EXP 95
31536: PUSH
31537: LD_EXP 95
31541: PPUSH
31542: LD_VAR 0 2
31546: PPUSH
31547: LD_EXP 95
31551: PUSH
31552: LD_VAR 0 2
31556: ARRAY
31557: PPUSH
31558: LD_VAR 0 3
31562: PPUSH
31563: LD_INT 1
31565: PPUSH
31566: LD_INT 0
31568: PPUSH
31569: CALL 55119 0 4
31573: PPUSH
31574: CALL_OW 1
31578: ST_TO_ADDR
// break ;
31579: GO 31583
// end ;
31581: GO 31503
31583: POP
31584: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
31585: LD_EXP 95
31589: PUSH
31590: LD_VAR 0 2
31594: ARRAY
31595: PUSH
31596: LD_INT 1
31598: ARRAY
31599: PUSH
31600: LD_INT 1
31602: ARRAY
31603: PUSH
31604: LD_INT 0
31606: EQUAL
31607: PUSH
31608: LD_VAR 0 5
31612: PUSH
31613: LD_VAR 0 5
31617: PPUSH
31618: LD_EXP 95
31622: PUSH
31623: LD_VAR 0 2
31627: ARRAY
31628: PUSH
31629: LD_INT 1
31631: ARRAY
31632: PUSH
31633: LD_INT 1
31635: ARRAY
31636: PPUSH
31637: LD_EXP 95
31641: PUSH
31642: LD_VAR 0 2
31646: ARRAY
31647: PUSH
31648: LD_INT 1
31650: ARRAY
31651: PUSH
31652: LD_INT 2
31654: ARRAY
31655: PPUSH
31656: LD_EXP 95
31660: PUSH
31661: LD_VAR 0 2
31665: ARRAY
31666: PUSH
31667: LD_INT 1
31669: ARRAY
31670: PUSH
31671: LD_INT 3
31673: ARRAY
31674: PPUSH
31675: LD_EXP 95
31679: PUSH
31680: LD_VAR 0 2
31684: ARRAY
31685: PUSH
31686: LD_INT 1
31688: ARRAY
31689: PUSH
31690: LD_INT 4
31692: ARRAY
31693: PPUSH
31694: CALL 63116 0 5
31698: AND
31699: OR
31700: IFFALSE 31981
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31702: LD_ADDR_VAR 0 4
31706: PUSH
31707: LD_EXP 90
31711: PUSH
31712: LD_VAR 0 2
31716: ARRAY
31717: PPUSH
31718: LD_INT 25
31720: PUSH
31721: LD_INT 2
31723: PUSH
31724: EMPTY
31725: LIST
31726: LIST
31727: PPUSH
31728: CALL_OW 72
31732: PUSH
31733: LD_EXP 92
31737: PUSH
31738: LD_VAR 0 2
31742: ARRAY
31743: DIFF
31744: ST_TO_ADDR
// if not tmp then
31745: LD_VAR 0 4
31749: NOT
31750: IFFALSE 31754
// continue ;
31752: GO 30999
// for j in tmp do
31754: LD_ADDR_VAR 0 3
31758: PUSH
31759: LD_VAR 0 4
31763: PUSH
31764: FOR_IN
31765: IFFALSE 31977
// begin if not mc_builders [ i ] then
31767: LD_EXP 96
31771: PUSH
31772: LD_VAR 0 2
31776: ARRAY
31777: NOT
31778: IFFALSE 31836
// begin SetTag ( j , 103 ) ;
31780: LD_VAR 0 3
31784: PPUSH
31785: LD_INT 103
31787: PPUSH
31788: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31792: LD_ADDR_EXP 96
31796: PUSH
31797: LD_EXP 96
31801: PPUSH
31802: LD_VAR 0 2
31806: PUSH
31807: LD_EXP 96
31811: PUSH
31812: LD_VAR 0 2
31816: ARRAY
31817: PUSH
31818: LD_INT 1
31820: PLUS
31821: PUSH
31822: EMPTY
31823: LIST
31824: LIST
31825: PPUSH
31826: LD_VAR 0 3
31830: PPUSH
31831: CALL 55701 0 3
31835: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31836: LD_VAR 0 3
31840: PPUSH
31841: CALL_OW 310
31845: IFFALSE 31856
// ComExitBuilding ( j ) ;
31847: LD_VAR 0 3
31851: PPUSH
31852: CALL_OW 122
// wait ( 3 ) ;
31856: LD_INT 3
31858: PPUSH
31859: CALL_OW 67
// if not mc_build_list [ i ] then
31863: LD_EXP 95
31867: PUSH
31868: LD_VAR 0 2
31872: ARRAY
31873: NOT
31874: IFFALSE 31878
// break ;
31876: GO 31977
// if not HasTask ( j ) then
31878: LD_VAR 0 3
31882: PPUSH
31883: CALL_OW 314
31887: NOT
31888: IFFALSE 31975
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
31890: LD_VAR 0 3
31894: PPUSH
31895: LD_EXP 95
31899: PUSH
31900: LD_VAR 0 2
31904: ARRAY
31905: PUSH
31906: LD_INT 1
31908: ARRAY
31909: PUSH
31910: LD_INT 1
31912: ARRAY
31913: PPUSH
31914: LD_EXP 95
31918: PUSH
31919: LD_VAR 0 2
31923: ARRAY
31924: PUSH
31925: LD_INT 1
31927: ARRAY
31928: PUSH
31929: LD_INT 2
31931: ARRAY
31932: PPUSH
31933: LD_EXP 95
31937: PUSH
31938: LD_VAR 0 2
31942: ARRAY
31943: PUSH
31944: LD_INT 1
31946: ARRAY
31947: PUSH
31948: LD_INT 3
31950: ARRAY
31951: PPUSH
31952: LD_EXP 95
31956: PUSH
31957: LD_VAR 0 2
31961: ARRAY
31962: PUSH
31963: LD_INT 1
31965: ARRAY
31966: PUSH
31967: LD_INT 4
31969: ARRAY
31970: PPUSH
31971: CALL_OW 145
// end ;
31975: GO 31764
31977: POP
31978: POP
// end else
31979: GO 32123
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
31981: LD_EXP 90
31985: PUSH
31986: LD_VAR 0 2
31990: ARRAY
31991: PPUSH
31992: LD_EXP 95
31996: PUSH
31997: LD_VAR 0 2
32001: ARRAY
32002: PUSH
32003: LD_INT 1
32005: ARRAY
32006: PUSH
32007: LD_INT 1
32009: ARRAY
32010: PPUSH
32011: LD_EXP 95
32015: PUSH
32016: LD_VAR 0 2
32020: ARRAY
32021: PUSH
32022: LD_INT 1
32024: ARRAY
32025: PUSH
32026: LD_INT 2
32028: ARRAY
32029: PPUSH
32030: LD_EXP 95
32034: PUSH
32035: LD_VAR 0 2
32039: ARRAY
32040: PUSH
32041: LD_INT 1
32043: ARRAY
32044: PUSH
32045: LD_INT 3
32047: ARRAY
32048: PPUSH
32049: LD_EXP 95
32053: PUSH
32054: LD_VAR 0 2
32058: ARRAY
32059: PUSH
32060: LD_INT 1
32062: ARRAY
32063: PUSH
32064: LD_INT 4
32066: ARRAY
32067: PPUSH
32068: CALL 62452 0 5
32072: NOT
32073: IFFALSE 32123
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
32075: LD_ADDR_EXP 95
32079: PUSH
32080: LD_EXP 95
32084: PPUSH
32085: LD_VAR 0 2
32089: PPUSH
32090: LD_EXP 95
32094: PUSH
32095: LD_VAR 0 2
32099: ARRAY
32100: PPUSH
32101: LD_INT 1
32103: PPUSH
32104: LD_INT 1
32106: NEG
32107: PPUSH
32108: LD_INT 0
32110: PPUSH
32111: CALL 55119 0 4
32115: PPUSH
32116: CALL_OW 1
32120: ST_TO_ADDR
// continue ;
32121: GO 30999
// end ; end ; end ;
32123: GO 30999
32125: POP
32126: POP
// end ;
32127: LD_VAR 0 1
32131: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
32132: LD_INT 0
32134: PPUSH
32135: PPUSH
32136: PPUSH
32137: PPUSH
32138: PPUSH
32139: PPUSH
// if not mc_bases then
32140: LD_EXP 90
32144: NOT
32145: IFFALSE 32149
// exit ;
32147: GO 32576
// for i = 1 to mc_bases do
32149: LD_ADDR_VAR 0 2
32153: PUSH
32154: DOUBLE
32155: LD_INT 1
32157: DEC
32158: ST_TO_ADDR
32159: LD_EXP 90
32163: PUSH
32164: FOR_TO
32165: IFFALSE 32574
// begin tmp := mc_build_upgrade [ i ] ;
32167: LD_ADDR_VAR 0 4
32171: PUSH
32172: LD_EXP 122
32176: PUSH
32177: LD_VAR 0 2
32181: ARRAY
32182: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
32183: LD_ADDR_VAR 0 6
32187: PUSH
32188: LD_EXP 123
32192: PUSH
32193: LD_VAR 0 2
32197: ARRAY
32198: PPUSH
32199: LD_INT 2
32201: PUSH
32202: LD_INT 30
32204: PUSH
32205: LD_INT 6
32207: PUSH
32208: EMPTY
32209: LIST
32210: LIST
32211: PUSH
32212: LD_INT 30
32214: PUSH
32215: LD_INT 7
32217: PUSH
32218: EMPTY
32219: LIST
32220: LIST
32221: PUSH
32222: EMPTY
32223: LIST
32224: LIST
32225: LIST
32226: PPUSH
32227: CALL_OW 72
32231: ST_TO_ADDR
// if not tmp and not lab then
32232: LD_VAR 0 4
32236: NOT
32237: PUSH
32238: LD_VAR 0 6
32242: NOT
32243: AND
32244: IFFALSE 32248
// continue ;
32246: GO 32164
// if tmp then
32248: LD_VAR 0 4
32252: IFFALSE 32372
// for j in tmp do
32254: LD_ADDR_VAR 0 3
32258: PUSH
32259: LD_VAR 0 4
32263: PUSH
32264: FOR_IN
32265: IFFALSE 32370
// begin if UpgradeCost ( j ) then
32267: LD_VAR 0 3
32271: PPUSH
32272: CALL 62112 0 1
32276: IFFALSE 32368
// begin ComUpgrade ( j ) ;
32278: LD_VAR 0 3
32282: PPUSH
32283: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
32287: LD_ADDR_EXP 122
32291: PUSH
32292: LD_EXP 122
32296: PPUSH
32297: LD_VAR 0 2
32301: PPUSH
32302: LD_EXP 122
32306: PUSH
32307: LD_VAR 0 2
32311: ARRAY
32312: PUSH
32313: LD_VAR 0 3
32317: DIFF
32318: PPUSH
32319: CALL_OW 1
32323: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
32324: LD_ADDR_EXP 97
32328: PUSH
32329: LD_EXP 97
32333: PPUSH
32334: LD_VAR 0 2
32338: PUSH
32339: LD_EXP 97
32343: PUSH
32344: LD_VAR 0 2
32348: ARRAY
32349: PUSH
32350: LD_INT 1
32352: PLUS
32353: PUSH
32354: EMPTY
32355: LIST
32356: LIST
32357: PPUSH
32358: LD_VAR 0 3
32362: PPUSH
32363: CALL 55701 0 3
32367: ST_TO_ADDR
// end ; end ;
32368: GO 32264
32370: POP
32371: POP
// if not lab or not mc_lab_upgrade [ i ] then
32372: LD_VAR 0 6
32376: NOT
32377: PUSH
32378: LD_EXP 124
32382: PUSH
32383: LD_VAR 0 2
32387: ARRAY
32388: NOT
32389: OR
32390: IFFALSE 32394
// continue ;
32392: GO 32164
// for j in lab do
32394: LD_ADDR_VAR 0 3
32398: PUSH
32399: LD_VAR 0 6
32403: PUSH
32404: FOR_IN
32405: IFFALSE 32570
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
32407: LD_VAR 0 3
32411: PPUSH
32412: CALL_OW 266
32416: PUSH
32417: LD_INT 6
32419: PUSH
32420: LD_INT 7
32422: PUSH
32423: EMPTY
32424: LIST
32425: LIST
32426: IN
32427: PUSH
32428: LD_VAR 0 3
32432: PPUSH
32433: CALL_OW 461
32437: PUSH
32438: LD_INT 1
32440: NONEQUAL
32441: AND
32442: IFFALSE 32568
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
32444: LD_VAR 0 3
32448: PPUSH
32449: LD_EXP 124
32453: PUSH
32454: LD_VAR 0 2
32458: ARRAY
32459: PUSH
32460: LD_INT 1
32462: ARRAY
32463: PPUSH
32464: CALL 62317 0 2
32468: IFFALSE 32568
// begin ComCancel ( j ) ;
32470: LD_VAR 0 3
32474: PPUSH
32475: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
32479: LD_VAR 0 3
32483: PPUSH
32484: LD_EXP 124
32488: PUSH
32489: LD_VAR 0 2
32493: ARRAY
32494: PUSH
32495: LD_INT 1
32497: ARRAY
32498: PPUSH
32499: CALL_OW 207
// if not j in mc_construct_list [ i ] then
32503: LD_VAR 0 3
32507: PUSH
32508: LD_EXP 97
32512: PUSH
32513: LD_VAR 0 2
32517: ARRAY
32518: IN
32519: NOT
32520: IFFALSE 32566
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
32522: LD_ADDR_EXP 97
32526: PUSH
32527: LD_EXP 97
32531: PPUSH
32532: LD_VAR 0 2
32536: PUSH
32537: LD_EXP 97
32541: PUSH
32542: LD_VAR 0 2
32546: ARRAY
32547: PUSH
32548: LD_INT 1
32550: PLUS
32551: PUSH
32552: EMPTY
32553: LIST
32554: LIST
32555: PPUSH
32556: LD_VAR 0 3
32560: PPUSH
32561: CALL 55701 0 3
32565: ST_TO_ADDR
// break ;
32566: GO 32570
// end ; end ; end ;
32568: GO 32404
32570: POP
32571: POP
// end ;
32572: GO 32164
32574: POP
32575: POP
// end ;
32576: LD_VAR 0 1
32580: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
32581: LD_INT 0
32583: PPUSH
32584: PPUSH
32585: PPUSH
32586: PPUSH
32587: PPUSH
32588: PPUSH
32589: PPUSH
32590: PPUSH
32591: PPUSH
// if not mc_bases then
32592: LD_EXP 90
32596: NOT
32597: IFFALSE 32601
// exit ;
32599: GO 33006
// for i = 1 to mc_bases do
32601: LD_ADDR_VAR 0 2
32605: PUSH
32606: DOUBLE
32607: LD_INT 1
32609: DEC
32610: ST_TO_ADDR
32611: LD_EXP 90
32615: PUSH
32616: FOR_TO
32617: IFFALSE 33004
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
32619: LD_EXP 98
32623: PUSH
32624: LD_VAR 0 2
32628: ARRAY
32629: NOT
32630: PUSH
32631: LD_EXP 90
32635: PUSH
32636: LD_VAR 0 2
32640: ARRAY
32641: PPUSH
32642: LD_INT 30
32644: PUSH
32645: LD_INT 3
32647: PUSH
32648: EMPTY
32649: LIST
32650: LIST
32651: PPUSH
32652: CALL_OW 72
32656: NOT
32657: OR
32658: IFFALSE 32662
// continue ;
32660: GO 32616
// busy := false ;
32662: LD_ADDR_VAR 0 8
32666: PUSH
32667: LD_INT 0
32669: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32670: LD_ADDR_VAR 0 4
32674: PUSH
32675: LD_EXP 90
32679: PUSH
32680: LD_VAR 0 2
32684: ARRAY
32685: PPUSH
32686: LD_INT 30
32688: PUSH
32689: LD_INT 3
32691: PUSH
32692: EMPTY
32693: LIST
32694: LIST
32695: PPUSH
32696: CALL_OW 72
32700: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
32701: LD_ADDR_VAR 0 6
32705: PUSH
32706: LD_EXP 98
32710: PUSH
32711: LD_VAR 0 2
32715: ARRAY
32716: PPUSH
32717: LD_INT 2
32719: PUSH
32720: LD_INT 30
32722: PUSH
32723: LD_INT 32
32725: PUSH
32726: EMPTY
32727: LIST
32728: LIST
32729: PUSH
32730: LD_INT 30
32732: PUSH
32733: LD_INT 33
32735: PUSH
32736: EMPTY
32737: LIST
32738: LIST
32739: PUSH
32740: EMPTY
32741: LIST
32742: LIST
32743: LIST
32744: PPUSH
32745: CALL_OW 72
32749: ST_TO_ADDR
// if not t then
32750: LD_VAR 0 6
32754: NOT
32755: IFFALSE 32759
// continue ;
32757: GO 32616
// for j in tmp do
32759: LD_ADDR_VAR 0 3
32763: PUSH
32764: LD_VAR 0 4
32768: PUSH
32769: FOR_IN
32770: IFFALSE 32800
// if not BuildingStatus ( j ) = bs_idle then
32772: LD_VAR 0 3
32776: PPUSH
32777: CALL_OW 461
32781: PUSH
32782: LD_INT 2
32784: EQUAL
32785: NOT
32786: IFFALSE 32798
// begin busy := true ;
32788: LD_ADDR_VAR 0 8
32792: PUSH
32793: LD_INT 1
32795: ST_TO_ADDR
// break ;
32796: GO 32800
// end ;
32798: GO 32769
32800: POP
32801: POP
// if busy then
32802: LD_VAR 0 8
32806: IFFALSE 32810
// continue ;
32808: GO 32616
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
32810: LD_ADDR_VAR 0 7
32814: PUSH
32815: LD_VAR 0 6
32819: PPUSH
32820: LD_INT 35
32822: PUSH
32823: LD_INT 0
32825: PUSH
32826: EMPTY
32827: LIST
32828: LIST
32829: PPUSH
32830: CALL_OW 72
32834: ST_TO_ADDR
// if tw then
32835: LD_VAR 0 7
32839: IFFALSE 32916
// begin tw := tw [ 1 ] ;
32841: LD_ADDR_VAR 0 7
32845: PUSH
32846: LD_VAR 0 7
32850: PUSH
32851: LD_INT 1
32853: ARRAY
32854: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
32855: LD_ADDR_VAR 0 9
32859: PUSH
32860: LD_VAR 0 7
32864: PPUSH
32865: LD_EXP 115
32869: PUSH
32870: LD_VAR 0 2
32874: ARRAY
32875: PPUSH
32876: CALL 60671 0 2
32880: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
32881: LD_EXP 129
32885: PUSH
32886: LD_VAR 0 2
32890: ARRAY
32891: IFFALSE 32914
// if not weapon in mc_allowed_tower_weapons [ i ] then
32893: LD_VAR 0 9
32897: PUSH
32898: LD_EXP 129
32902: PUSH
32903: LD_VAR 0 2
32907: ARRAY
32908: IN
32909: NOT
32910: IFFALSE 32914
// continue ;
32912: GO 32616
// end else
32914: GO 32979
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
32916: LD_ADDR_VAR 0 5
32920: PUSH
32921: LD_EXP 98
32925: PUSH
32926: LD_VAR 0 2
32930: ARRAY
32931: PPUSH
32932: LD_VAR 0 4
32936: PPUSH
32937: CALL 86292 0 2
32941: ST_TO_ADDR
// if not tmp2 then
32942: LD_VAR 0 5
32946: NOT
32947: IFFALSE 32951
// continue ;
32949: GO 32616
// tw := tmp2 [ 1 ] ;
32951: LD_ADDR_VAR 0 7
32955: PUSH
32956: LD_VAR 0 5
32960: PUSH
32961: LD_INT 1
32963: ARRAY
32964: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
32965: LD_ADDR_VAR 0 9
32969: PUSH
32970: LD_VAR 0 5
32974: PUSH
32975: LD_INT 2
32977: ARRAY
32978: ST_TO_ADDR
// end ; if not weapon then
32979: LD_VAR 0 9
32983: NOT
32984: IFFALSE 32988
// continue ;
32986: GO 32616
// ComPlaceWeapon ( tw , weapon ) ;
32988: LD_VAR 0 7
32992: PPUSH
32993: LD_VAR 0 9
32997: PPUSH
32998: CALL_OW 148
// end ;
33002: GO 32616
33004: POP
33005: POP
// end ;
33006: LD_VAR 0 1
33010: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
33011: LD_INT 0
33013: PPUSH
33014: PPUSH
33015: PPUSH
33016: PPUSH
33017: PPUSH
33018: PPUSH
// if not mc_bases then
33019: LD_EXP 90
33023: NOT
33024: IFFALSE 33028
// exit ;
33026: GO 33804
// for i = 1 to mc_bases do
33028: LD_ADDR_VAR 0 2
33032: PUSH
33033: DOUBLE
33034: LD_INT 1
33036: DEC
33037: ST_TO_ADDR
33038: LD_EXP 90
33042: PUSH
33043: FOR_TO
33044: IFFALSE 33802
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
33046: LD_EXP 103
33050: PUSH
33051: LD_VAR 0 2
33055: ARRAY
33056: NOT
33057: PUSH
33058: LD_EXP 103
33062: PUSH
33063: LD_VAR 0 2
33067: ARRAY
33068: PUSH
33069: LD_EXP 104
33073: PUSH
33074: LD_VAR 0 2
33078: ARRAY
33079: EQUAL
33080: OR
33081: PUSH
33082: LD_EXP 113
33086: PUSH
33087: LD_VAR 0 2
33091: ARRAY
33092: OR
33093: IFFALSE 33097
// continue ;
33095: GO 33043
// if mc_miners [ i ] then
33097: LD_EXP 104
33101: PUSH
33102: LD_VAR 0 2
33106: ARRAY
33107: IFFALSE 33489
// begin for j = mc_miners [ i ] downto 1 do
33109: LD_ADDR_VAR 0 3
33113: PUSH
33114: DOUBLE
33115: LD_EXP 104
33119: PUSH
33120: LD_VAR 0 2
33124: ARRAY
33125: INC
33126: ST_TO_ADDR
33127: LD_INT 1
33129: PUSH
33130: FOR_DOWNTO
33131: IFFALSE 33487
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
33133: LD_EXP 104
33137: PUSH
33138: LD_VAR 0 2
33142: ARRAY
33143: PUSH
33144: LD_VAR 0 3
33148: ARRAY
33149: PPUSH
33150: CALL_OW 301
33154: PUSH
33155: LD_EXP 104
33159: PUSH
33160: LD_VAR 0 2
33164: ARRAY
33165: PUSH
33166: LD_VAR 0 3
33170: ARRAY
33171: PPUSH
33172: CALL_OW 257
33176: PUSH
33177: LD_INT 1
33179: NONEQUAL
33180: OR
33181: IFFALSE 33244
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
33183: LD_ADDR_VAR 0 5
33187: PUSH
33188: LD_EXP 104
33192: PUSH
33193: LD_VAR 0 2
33197: ARRAY
33198: PUSH
33199: LD_EXP 104
33203: PUSH
33204: LD_VAR 0 2
33208: ARRAY
33209: PUSH
33210: LD_VAR 0 3
33214: ARRAY
33215: DIFF
33216: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
33217: LD_ADDR_EXP 104
33221: PUSH
33222: LD_EXP 104
33226: PPUSH
33227: LD_VAR 0 2
33231: PPUSH
33232: LD_VAR 0 5
33236: PPUSH
33237: CALL_OW 1
33241: ST_TO_ADDR
// continue ;
33242: GO 33130
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
33244: LD_EXP 104
33248: PUSH
33249: LD_VAR 0 2
33253: ARRAY
33254: PUSH
33255: LD_VAR 0 3
33259: ARRAY
33260: PPUSH
33261: CALL_OW 257
33265: PUSH
33266: LD_INT 1
33268: EQUAL
33269: PUSH
33270: LD_EXP 104
33274: PUSH
33275: LD_VAR 0 2
33279: ARRAY
33280: PUSH
33281: LD_VAR 0 3
33285: ARRAY
33286: PPUSH
33287: CALL_OW 459
33291: NOT
33292: AND
33293: PUSH
33294: LD_EXP 104
33298: PUSH
33299: LD_VAR 0 2
33303: ARRAY
33304: PUSH
33305: LD_VAR 0 3
33309: ARRAY
33310: PPUSH
33311: CALL_OW 314
33315: NOT
33316: AND
33317: IFFALSE 33485
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
33319: LD_EXP 104
33323: PUSH
33324: LD_VAR 0 2
33328: ARRAY
33329: PUSH
33330: LD_VAR 0 3
33334: ARRAY
33335: PPUSH
33336: CALL_OW 310
33340: IFFALSE 33363
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
33342: LD_EXP 104
33346: PUSH
33347: LD_VAR 0 2
33351: ARRAY
33352: PUSH
33353: LD_VAR 0 3
33357: ARRAY
33358: PPUSH
33359: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
33363: LD_EXP 104
33367: PUSH
33368: LD_VAR 0 2
33372: ARRAY
33373: PUSH
33374: LD_VAR 0 3
33378: ARRAY
33379: PPUSH
33380: CALL_OW 314
33384: NOT
33385: IFFALSE 33485
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
33387: LD_EXP 104
33391: PUSH
33392: LD_VAR 0 2
33396: ARRAY
33397: PUSH
33398: LD_VAR 0 3
33402: ARRAY
33403: PPUSH
33404: LD_EXP 103
33408: PUSH
33409: LD_VAR 0 2
33413: ARRAY
33414: PUSH
33415: LD_VAR 0 3
33419: PUSH
33420: LD_EXP 103
33424: PUSH
33425: LD_VAR 0 2
33429: ARRAY
33430: MOD
33431: PUSH
33432: LD_INT 1
33434: PLUS
33435: ARRAY
33436: PUSH
33437: LD_INT 1
33439: ARRAY
33440: PPUSH
33441: LD_EXP 103
33445: PUSH
33446: LD_VAR 0 2
33450: ARRAY
33451: PUSH
33452: LD_VAR 0 3
33456: PUSH
33457: LD_EXP 103
33461: PUSH
33462: LD_VAR 0 2
33466: ARRAY
33467: MOD
33468: PUSH
33469: LD_INT 1
33471: PLUS
33472: ARRAY
33473: PUSH
33474: LD_INT 2
33476: ARRAY
33477: PPUSH
33478: LD_INT 0
33480: PPUSH
33481: CALL_OW 193
// end ; end ;
33485: GO 33130
33487: POP
33488: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
33489: LD_ADDR_VAR 0 5
33493: PUSH
33494: LD_EXP 90
33498: PUSH
33499: LD_VAR 0 2
33503: ARRAY
33504: PPUSH
33505: LD_INT 2
33507: PUSH
33508: LD_INT 30
33510: PUSH
33511: LD_INT 4
33513: PUSH
33514: EMPTY
33515: LIST
33516: LIST
33517: PUSH
33518: LD_INT 30
33520: PUSH
33521: LD_INT 5
33523: PUSH
33524: EMPTY
33525: LIST
33526: LIST
33527: PUSH
33528: LD_INT 30
33530: PUSH
33531: LD_INT 32
33533: PUSH
33534: EMPTY
33535: LIST
33536: LIST
33537: PUSH
33538: EMPTY
33539: LIST
33540: LIST
33541: LIST
33542: LIST
33543: PPUSH
33544: CALL_OW 72
33548: ST_TO_ADDR
// if not tmp then
33549: LD_VAR 0 5
33553: NOT
33554: IFFALSE 33558
// continue ;
33556: GO 33043
// list := [ ] ;
33558: LD_ADDR_VAR 0 6
33562: PUSH
33563: EMPTY
33564: ST_TO_ADDR
// for j in tmp do
33565: LD_ADDR_VAR 0 3
33569: PUSH
33570: LD_VAR 0 5
33574: PUSH
33575: FOR_IN
33576: IFFALSE 33645
// begin for k in UnitsInside ( j ) do
33578: LD_ADDR_VAR 0 4
33582: PUSH
33583: LD_VAR 0 3
33587: PPUSH
33588: CALL_OW 313
33592: PUSH
33593: FOR_IN
33594: IFFALSE 33641
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
33596: LD_VAR 0 4
33600: PPUSH
33601: CALL_OW 257
33605: PUSH
33606: LD_INT 1
33608: EQUAL
33609: PUSH
33610: LD_VAR 0 4
33614: PPUSH
33615: CALL_OW 459
33619: NOT
33620: AND
33621: IFFALSE 33639
// list := list ^ k ;
33623: LD_ADDR_VAR 0 6
33627: PUSH
33628: LD_VAR 0 6
33632: PUSH
33633: LD_VAR 0 4
33637: ADD
33638: ST_TO_ADDR
33639: GO 33593
33641: POP
33642: POP
// end ;
33643: GO 33575
33645: POP
33646: POP
// list := list diff mc_miners [ i ] ;
33647: LD_ADDR_VAR 0 6
33651: PUSH
33652: LD_VAR 0 6
33656: PUSH
33657: LD_EXP 104
33661: PUSH
33662: LD_VAR 0 2
33666: ARRAY
33667: DIFF
33668: ST_TO_ADDR
// if not list then
33669: LD_VAR 0 6
33673: NOT
33674: IFFALSE 33678
// continue ;
33676: GO 33043
// k := mc_mines [ i ] - mc_miners [ i ] ;
33678: LD_ADDR_VAR 0 4
33682: PUSH
33683: LD_EXP 103
33687: PUSH
33688: LD_VAR 0 2
33692: ARRAY
33693: PUSH
33694: LD_EXP 104
33698: PUSH
33699: LD_VAR 0 2
33703: ARRAY
33704: MINUS
33705: ST_TO_ADDR
// if k > list then
33706: LD_VAR 0 4
33710: PUSH
33711: LD_VAR 0 6
33715: GREATER
33716: IFFALSE 33728
// k := list ;
33718: LD_ADDR_VAR 0 4
33722: PUSH
33723: LD_VAR 0 6
33727: ST_TO_ADDR
// for j = 1 to k do
33728: LD_ADDR_VAR 0 3
33732: PUSH
33733: DOUBLE
33734: LD_INT 1
33736: DEC
33737: ST_TO_ADDR
33738: LD_VAR 0 4
33742: PUSH
33743: FOR_TO
33744: IFFALSE 33798
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
33746: LD_ADDR_EXP 104
33750: PUSH
33751: LD_EXP 104
33755: PPUSH
33756: LD_VAR 0 2
33760: PUSH
33761: LD_EXP 104
33765: PUSH
33766: LD_VAR 0 2
33770: ARRAY
33771: PUSH
33772: LD_INT 1
33774: PLUS
33775: PUSH
33776: EMPTY
33777: LIST
33778: LIST
33779: PPUSH
33780: LD_VAR 0 6
33784: PUSH
33785: LD_VAR 0 3
33789: ARRAY
33790: PPUSH
33791: CALL 55701 0 3
33795: ST_TO_ADDR
33796: GO 33743
33798: POP
33799: POP
// end ;
33800: GO 33043
33802: POP
33803: POP
// end ;
33804: LD_VAR 0 1
33808: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
33809: LD_INT 0
33811: PPUSH
33812: PPUSH
33813: PPUSH
33814: PPUSH
33815: PPUSH
33816: PPUSH
33817: PPUSH
33818: PPUSH
33819: PPUSH
33820: PPUSH
// if not mc_bases then
33821: LD_EXP 90
33825: NOT
33826: IFFALSE 33830
// exit ;
33828: GO 35580
// for i = 1 to mc_bases do
33830: LD_ADDR_VAR 0 2
33834: PUSH
33835: DOUBLE
33836: LD_INT 1
33838: DEC
33839: ST_TO_ADDR
33840: LD_EXP 90
33844: PUSH
33845: FOR_TO
33846: IFFALSE 35578
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
33848: LD_EXP 90
33852: PUSH
33853: LD_VAR 0 2
33857: ARRAY
33858: NOT
33859: PUSH
33860: LD_EXP 97
33864: PUSH
33865: LD_VAR 0 2
33869: ARRAY
33870: OR
33871: IFFALSE 33875
// continue ;
33873: GO 33845
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
33875: LD_EXP 106
33879: PUSH
33880: LD_VAR 0 2
33884: ARRAY
33885: NOT
33886: PUSH
33887: LD_EXP 107
33891: PUSH
33892: LD_VAR 0 2
33896: ARRAY
33897: AND
33898: IFFALSE 33936
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
33900: LD_ADDR_EXP 107
33904: PUSH
33905: LD_EXP 107
33909: PPUSH
33910: LD_VAR 0 2
33914: PPUSH
33915: EMPTY
33916: PPUSH
33917: CALL_OW 1
33921: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
33922: LD_VAR 0 2
33926: PPUSH
33927: LD_INT 107
33929: PPUSH
33930: CALL 24810 0 2
// continue ;
33934: GO 33845
// end ; target := [ ] ;
33936: LD_ADDR_VAR 0 6
33940: PUSH
33941: EMPTY
33942: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
33943: LD_ADDR_VAR 0 3
33947: PUSH
33948: DOUBLE
33949: LD_EXP 106
33953: PUSH
33954: LD_VAR 0 2
33958: ARRAY
33959: INC
33960: ST_TO_ADDR
33961: LD_INT 1
33963: PUSH
33964: FOR_DOWNTO
33965: IFFALSE 34225
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
33967: LD_EXP 106
33971: PUSH
33972: LD_VAR 0 2
33976: ARRAY
33977: PUSH
33978: LD_VAR 0 3
33982: ARRAY
33983: PUSH
33984: LD_INT 2
33986: ARRAY
33987: PPUSH
33988: LD_EXP 106
33992: PUSH
33993: LD_VAR 0 2
33997: ARRAY
33998: PUSH
33999: LD_VAR 0 3
34003: ARRAY
34004: PUSH
34005: LD_INT 3
34007: ARRAY
34008: PPUSH
34009: CALL_OW 488
34013: PUSH
34014: LD_EXP 106
34018: PUSH
34019: LD_VAR 0 2
34023: ARRAY
34024: PUSH
34025: LD_VAR 0 3
34029: ARRAY
34030: PUSH
34031: LD_INT 2
34033: ARRAY
34034: PPUSH
34035: LD_EXP 106
34039: PUSH
34040: LD_VAR 0 2
34044: ARRAY
34045: PUSH
34046: LD_VAR 0 3
34050: ARRAY
34051: PUSH
34052: LD_INT 3
34054: ARRAY
34055: PPUSH
34056: CALL_OW 284
34060: PUSH
34061: LD_INT 0
34063: EQUAL
34064: AND
34065: IFFALSE 34120
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
34067: LD_ADDR_VAR 0 5
34071: PUSH
34072: LD_EXP 106
34076: PUSH
34077: LD_VAR 0 2
34081: ARRAY
34082: PPUSH
34083: LD_VAR 0 3
34087: PPUSH
34088: CALL_OW 3
34092: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
34093: LD_ADDR_EXP 106
34097: PUSH
34098: LD_EXP 106
34102: PPUSH
34103: LD_VAR 0 2
34107: PPUSH
34108: LD_VAR 0 5
34112: PPUSH
34113: CALL_OW 1
34117: ST_TO_ADDR
// continue ;
34118: GO 33964
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
34120: LD_EXP 90
34124: PUSH
34125: LD_VAR 0 2
34129: ARRAY
34130: PUSH
34131: LD_INT 1
34133: ARRAY
34134: PPUSH
34135: CALL_OW 255
34139: PPUSH
34140: LD_EXP 106
34144: PUSH
34145: LD_VAR 0 2
34149: ARRAY
34150: PUSH
34151: LD_VAR 0 3
34155: ARRAY
34156: PUSH
34157: LD_INT 2
34159: ARRAY
34160: PPUSH
34161: LD_EXP 106
34165: PUSH
34166: LD_VAR 0 2
34170: ARRAY
34171: PUSH
34172: LD_VAR 0 3
34176: ARRAY
34177: PUSH
34178: LD_INT 3
34180: ARRAY
34181: PPUSH
34182: LD_INT 30
34184: PPUSH
34185: CALL 56597 0 4
34189: PUSH
34190: LD_INT 4
34192: ARRAY
34193: PUSH
34194: LD_INT 0
34196: EQUAL
34197: IFFALSE 34223
// begin target := mc_crates [ i ] [ j ] ;
34199: LD_ADDR_VAR 0 6
34203: PUSH
34204: LD_EXP 106
34208: PUSH
34209: LD_VAR 0 2
34213: ARRAY
34214: PUSH
34215: LD_VAR 0 3
34219: ARRAY
34220: ST_TO_ADDR
// break ;
34221: GO 34225
// end ; end ;
34223: GO 33964
34225: POP
34226: POP
// if not target then
34227: LD_VAR 0 6
34231: NOT
34232: IFFALSE 34236
// continue ;
34234: GO 33845
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
34236: LD_ADDR_VAR 0 7
34240: PUSH
34241: LD_EXP 109
34245: PUSH
34246: LD_VAR 0 2
34250: ARRAY
34251: PPUSH
34252: LD_INT 2
34254: PUSH
34255: LD_INT 3
34257: PUSH
34258: LD_INT 58
34260: PUSH
34261: EMPTY
34262: LIST
34263: PUSH
34264: EMPTY
34265: LIST
34266: LIST
34267: PUSH
34268: LD_INT 61
34270: PUSH
34271: EMPTY
34272: LIST
34273: PUSH
34274: LD_INT 33
34276: PUSH
34277: LD_INT 5
34279: PUSH
34280: EMPTY
34281: LIST
34282: LIST
34283: PUSH
34284: LD_INT 33
34286: PUSH
34287: LD_INT 3
34289: PUSH
34290: EMPTY
34291: LIST
34292: LIST
34293: PUSH
34294: EMPTY
34295: LIST
34296: LIST
34297: LIST
34298: LIST
34299: LIST
34300: PUSH
34301: LD_INT 2
34303: PUSH
34304: LD_INT 34
34306: PUSH
34307: LD_INT 32
34309: PUSH
34310: EMPTY
34311: LIST
34312: LIST
34313: PUSH
34314: LD_INT 34
34316: PUSH
34317: LD_INT 51
34319: PUSH
34320: EMPTY
34321: LIST
34322: LIST
34323: PUSH
34324: LD_INT 34
34326: PUSH
34327: LD_INT 12
34329: PUSH
34330: EMPTY
34331: LIST
34332: LIST
34333: PUSH
34334: EMPTY
34335: LIST
34336: LIST
34337: LIST
34338: LIST
34339: PUSH
34340: EMPTY
34341: LIST
34342: LIST
34343: PPUSH
34344: CALL_OW 72
34348: ST_TO_ADDR
// if not cargo then
34349: LD_VAR 0 7
34353: NOT
34354: IFFALSE 34997
// begin if mc_crates_collector [ i ] < 5 then
34356: LD_EXP 107
34360: PUSH
34361: LD_VAR 0 2
34365: ARRAY
34366: PUSH
34367: LD_INT 5
34369: LESS
34370: IFFALSE 34736
// begin if mc_ape [ i ] then
34372: LD_EXP 119
34376: PUSH
34377: LD_VAR 0 2
34381: ARRAY
34382: IFFALSE 34429
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
34384: LD_ADDR_VAR 0 5
34388: PUSH
34389: LD_EXP 119
34393: PUSH
34394: LD_VAR 0 2
34398: ARRAY
34399: PPUSH
34400: LD_INT 25
34402: PUSH
34403: LD_INT 16
34405: PUSH
34406: EMPTY
34407: LIST
34408: LIST
34409: PUSH
34410: LD_INT 24
34412: PUSH
34413: LD_INT 750
34415: PUSH
34416: EMPTY
34417: LIST
34418: LIST
34419: PUSH
34420: EMPTY
34421: LIST
34422: LIST
34423: PPUSH
34424: CALL_OW 72
34428: ST_TO_ADDR
// if not tmp then
34429: LD_VAR 0 5
34433: NOT
34434: IFFALSE 34481
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
34436: LD_ADDR_VAR 0 5
34440: PUSH
34441: LD_EXP 90
34445: PUSH
34446: LD_VAR 0 2
34450: ARRAY
34451: PPUSH
34452: LD_INT 25
34454: PUSH
34455: LD_INT 2
34457: PUSH
34458: EMPTY
34459: LIST
34460: LIST
34461: PUSH
34462: LD_INT 24
34464: PUSH
34465: LD_INT 750
34467: PUSH
34468: EMPTY
34469: LIST
34470: LIST
34471: PUSH
34472: EMPTY
34473: LIST
34474: LIST
34475: PPUSH
34476: CALL_OW 72
34480: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
34481: LD_EXP 119
34485: PUSH
34486: LD_VAR 0 2
34490: ARRAY
34491: PUSH
34492: LD_EXP 90
34496: PUSH
34497: LD_VAR 0 2
34501: ARRAY
34502: PPUSH
34503: LD_INT 25
34505: PUSH
34506: LD_INT 2
34508: PUSH
34509: EMPTY
34510: LIST
34511: LIST
34512: PUSH
34513: LD_INT 24
34515: PUSH
34516: LD_INT 750
34518: PUSH
34519: EMPTY
34520: LIST
34521: LIST
34522: PUSH
34523: EMPTY
34524: LIST
34525: LIST
34526: PPUSH
34527: CALL_OW 72
34531: AND
34532: PUSH
34533: LD_VAR 0 5
34537: PUSH
34538: LD_INT 5
34540: LESS
34541: AND
34542: IFFALSE 34624
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
34544: LD_ADDR_VAR 0 3
34548: PUSH
34549: LD_EXP 90
34553: PUSH
34554: LD_VAR 0 2
34558: ARRAY
34559: PPUSH
34560: LD_INT 25
34562: PUSH
34563: LD_INT 2
34565: PUSH
34566: EMPTY
34567: LIST
34568: LIST
34569: PUSH
34570: LD_INT 24
34572: PUSH
34573: LD_INT 750
34575: PUSH
34576: EMPTY
34577: LIST
34578: LIST
34579: PUSH
34580: EMPTY
34581: LIST
34582: LIST
34583: PPUSH
34584: CALL_OW 72
34588: PUSH
34589: FOR_IN
34590: IFFALSE 34622
// begin tmp := tmp union j ;
34592: LD_ADDR_VAR 0 5
34596: PUSH
34597: LD_VAR 0 5
34601: PUSH
34602: LD_VAR 0 3
34606: UNION
34607: ST_TO_ADDR
// if tmp >= 5 then
34608: LD_VAR 0 5
34612: PUSH
34613: LD_INT 5
34615: GREATEREQUAL
34616: IFFALSE 34620
// break ;
34618: GO 34622
// end ;
34620: GO 34589
34622: POP
34623: POP
// end ; if not tmp then
34624: LD_VAR 0 5
34628: NOT
34629: IFFALSE 34633
// continue ;
34631: GO 33845
// for j in tmp do
34633: LD_ADDR_VAR 0 3
34637: PUSH
34638: LD_VAR 0 5
34642: PUSH
34643: FOR_IN
34644: IFFALSE 34734
// if not GetTag ( j ) then
34646: LD_VAR 0 3
34650: PPUSH
34651: CALL_OW 110
34655: NOT
34656: IFFALSE 34732
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
34658: LD_ADDR_EXP 107
34662: PUSH
34663: LD_EXP 107
34667: PPUSH
34668: LD_VAR 0 2
34672: PUSH
34673: LD_EXP 107
34677: PUSH
34678: LD_VAR 0 2
34682: ARRAY
34683: PUSH
34684: LD_INT 1
34686: PLUS
34687: PUSH
34688: EMPTY
34689: LIST
34690: LIST
34691: PPUSH
34692: LD_VAR 0 3
34696: PPUSH
34697: CALL 55701 0 3
34701: ST_TO_ADDR
// SetTag ( j , 107 ) ;
34702: LD_VAR 0 3
34706: PPUSH
34707: LD_INT 107
34709: PPUSH
34710: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
34714: LD_EXP 107
34718: PUSH
34719: LD_VAR 0 2
34723: ARRAY
34724: PUSH
34725: LD_INT 5
34727: GREATEREQUAL
34728: IFFALSE 34732
// break ;
34730: GO 34734
// end ;
34732: GO 34643
34734: POP
34735: POP
// end ; if mc_crates_collector [ i ] and target then
34736: LD_EXP 107
34740: PUSH
34741: LD_VAR 0 2
34745: ARRAY
34746: PUSH
34747: LD_VAR 0 6
34751: AND
34752: IFFALSE 34995
// begin if mc_crates_collector [ i ] < target [ 1 ] then
34754: LD_EXP 107
34758: PUSH
34759: LD_VAR 0 2
34763: ARRAY
34764: PUSH
34765: LD_VAR 0 6
34769: PUSH
34770: LD_INT 1
34772: ARRAY
34773: LESS
34774: IFFALSE 34794
// tmp := mc_crates_collector [ i ] else
34776: LD_ADDR_VAR 0 5
34780: PUSH
34781: LD_EXP 107
34785: PUSH
34786: LD_VAR 0 2
34790: ARRAY
34791: ST_TO_ADDR
34792: GO 34808
// tmp := target [ 1 ] ;
34794: LD_ADDR_VAR 0 5
34798: PUSH
34799: LD_VAR 0 6
34803: PUSH
34804: LD_INT 1
34806: ARRAY
34807: ST_TO_ADDR
// k := 0 ;
34808: LD_ADDR_VAR 0 4
34812: PUSH
34813: LD_INT 0
34815: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
34816: LD_ADDR_VAR 0 3
34820: PUSH
34821: LD_EXP 107
34825: PUSH
34826: LD_VAR 0 2
34830: ARRAY
34831: PUSH
34832: FOR_IN
34833: IFFALSE 34993
// begin k := k + 1 ;
34835: LD_ADDR_VAR 0 4
34839: PUSH
34840: LD_VAR 0 4
34844: PUSH
34845: LD_INT 1
34847: PLUS
34848: ST_TO_ADDR
// if k > tmp then
34849: LD_VAR 0 4
34853: PUSH
34854: LD_VAR 0 5
34858: GREATER
34859: IFFALSE 34863
// break ;
34861: GO 34993
// if not GetClass ( j ) in [ 2 , 16 ] then
34863: LD_VAR 0 3
34867: PPUSH
34868: CALL_OW 257
34872: PUSH
34873: LD_INT 2
34875: PUSH
34876: LD_INT 16
34878: PUSH
34879: EMPTY
34880: LIST
34881: LIST
34882: IN
34883: NOT
34884: IFFALSE 34937
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
34886: LD_ADDR_EXP 107
34890: PUSH
34891: LD_EXP 107
34895: PPUSH
34896: LD_VAR 0 2
34900: PPUSH
34901: LD_EXP 107
34905: PUSH
34906: LD_VAR 0 2
34910: ARRAY
34911: PUSH
34912: LD_VAR 0 3
34916: DIFF
34917: PPUSH
34918: CALL_OW 1
34922: ST_TO_ADDR
// SetTag ( j , 0 ) ;
34923: LD_VAR 0 3
34927: PPUSH
34928: LD_INT 0
34930: PPUSH
34931: CALL_OW 109
// continue ;
34935: GO 34832
// end ; if IsInUnit ( j ) then
34937: LD_VAR 0 3
34941: PPUSH
34942: CALL_OW 310
34946: IFFALSE 34957
// ComExitBuilding ( j ) ;
34948: LD_VAR 0 3
34952: PPUSH
34953: CALL_OW 122
// wait ( 3 ) ;
34957: LD_INT 3
34959: PPUSH
34960: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
34964: LD_VAR 0 3
34968: PPUSH
34969: LD_VAR 0 6
34973: PUSH
34974: LD_INT 2
34976: ARRAY
34977: PPUSH
34978: LD_VAR 0 6
34982: PUSH
34983: LD_INT 3
34985: ARRAY
34986: PPUSH
34987: CALL_OW 117
// end ;
34991: GO 34832
34993: POP
34994: POP
// end ; end else
34995: GO 35576
// begin for j in cargo do
34997: LD_ADDR_VAR 0 3
35001: PUSH
35002: LD_VAR 0 7
35006: PUSH
35007: FOR_IN
35008: IFFALSE 35574
// begin if GetTag ( j ) <> 0 then
35010: LD_VAR 0 3
35014: PPUSH
35015: CALL_OW 110
35019: PUSH
35020: LD_INT 0
35022: NONEQUAL
35023: IFFALSE 35027
// continue ;
35025: GO 35007
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
35027: LD_VAR 0 3
35031: PPUSH
35032: CALL_OW 256
35036: PUSH
35037: LD_INT 1000
35039: LESS
35040: PUSH
35041: LD_VAR 0 3
35045: PPUSH
35046: LD_EXP 114
35050: PUSH
35051: LD_VAR 0 2
35055: ARRAY
35056: PPUSH
35057: CALL_OW 308
35061: NOT
35062: AND
35063: IFFALSE 35085
// ComMoveToArea ( j , mc_parking [ i ] ) ;
35065: LD_VAR 0 3
35069: PPUSH
35070: LD_EXP 114
35074: PUSH
35075: LD_VAR 0 2
35079: ARRAY
35080: PPUSH
35081: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
35085: LD_VAR 0 3
35089: PPUSH
35090: CALL_OW 256
35094: PUSH
35095: LD_INT 1000
35097: LESS
35098: PUSH
35099: LD_VAR 0 3
35103: PPUSH
35104: LD_EXP 114
35108: PUSH
35109: LD_VAR 0 2
35113: ARRAY
35114: PPUSH
35115: CALL_OW 308
35119: AND
35120: IFFALSE 35124
// continue ;
35122: GO 35007
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
35124: LD_VAR 0 3
35128: PPUSH
35129: CALL_OW 262
35133: PUSH
35134: LD_INT 2
35136: EQUAL
35137: PUSH
35138: LD_VAR 0 3
35142: PPUSH
35143: CALL_OW 261
35147: PUSH
35148: LD_INT 15
35150: LESS
35151: AND
35152: IFFALSE 35156
// continue ;
35154: GO 35007
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
35156: LD_VAR 0 3
35160: PPUSH
35161: CALL_OW 262
35165: PUSH
35166: LD_INT 1
35168: EQUAL
35169: PUSH
35170: LD_VAR 0 3
35174: PPUSH
35175: CALL_OW 261
35179: PUSH
35180: LD_INT 10
35182: LESS
35183: AND
35184: IFFALSE 35513
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
35186: LD_ADDR_VAR 0 8
35190: PUSH
35191: LD_EXP 90
35195: PUSH
35196: LD_VAR 0 2
35200: ARRAY
35201: PPUSH
35202: LD_INT 2
35204: PUSH
35205: LD_INT 30
35207: PUSH
35208: LD_INT 0
35210: PUSH
35211: EMPTY
35212: LIST
35213: LIST
35214: PUSH
35215: LD_INT 30
35217: PUSH
35218: LD_INT 1
35220: PUSH
35221: EMPTY
35222: LIST
35223: LIST
35224: PUSH
35225: EMPTY
35226: LIST
35227: LIST
35228: LIST
35229: PPUSH
35230: CALL_OW 72
35234: ST_TO_ADDR
// if not depot then
35235: LD_VAR 0 8
35239: NOT
35240: IFFALSE 35244
// continue ;
35242: GO 35007
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
35244: LD_VAR 0 3
35248: PPUSH
35249: LD_VAR 0 8
35253: PPUSH
35254: LD_VAR 0 3
35258: PPUSH
35259: CALL_OW 74
35263: PPUSH
35264: CALL_OW 296
35268: PUSH
35269: LD_INT 6
35271: LESS
35272: IFFALSE 35288
// SetFuel ( j , 100 ) else
35274: LD_VAR 0 3
35278: PPUSH
35279: LD_INT 100
35281: PPUSH
35282: CALL_OW 240
35286: GO 35513
// if GetFuel ( j ) = 0 then
35288: LD_VAR 0 3
35292: PPUSH
35293: CALL_OW 261
35297: PUSH
35298: LD_INT 0
35300: EQUAL
35301: IFFALSE 35513
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
35303: LD_ADDR_EXP 109
35307: PUSH
35308: LD_EXP 109
35312: PPUSH
35313: LD_VAR 0 2
35317: PPUSH
35318: LD_EXP 109
35322: PUSH
35323: LD_VAR 0 2
35327: ARRAY
35328: PUSH
35329: LD_VAR 0 3
35333: DIFF
35334: PPUSH
35335: CALL_OW 1
35339: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
35340: LD_VAR 0 3
35344: PPUSH
35345: CALL_OW 263
35349: PUSH
35350: LD_INT 1
35352: EQUAL
35353: IFFALSE 35369
// ComExitVehicle ( IsInUnit ( j ) ) ;
35355: LD_VAR 0 3
35359: PPUSH
35360: CALL_OW 310
35364: PPUSH
35365: CALL_OW 121
// if GetControl ( j ) = control_remote then
35369: LD_VAR 0 3
35373: PPUSH
35374: CALL_OW 263
35378: PUSH
35379: LD_INT 2
35381: EQUAL
35382: IFFALSE 35393
// ComUnlink ( j ) ;
35384: LD_VAR 0 3
35388: PPUSH
35389: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
35393: LD_ADDR_VAR 0 9
35397: PUSH
35398: LD_VAR 0 2
35402: PPUSH
35403: LD_INT 3
35405: PPUSH
35406: CALL 44866 0 2
35410: ST_TO_ADDR
// if fac then
35411: LD_VAR 0 9
35415: IFFALSE 35511
// begin for k in fac do
35417: LD_ADDR_VAR 0 4
35421: PUSH
35422: LD_VAR 0 9
35426: PUSH
35427: FOR_IN
35428: IFFALSE 35509
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
35430: LD_ADDR_VAR 0 10
35434: PUSH
35435: LD_VAR 0 9
35439: PPUSH
35440: LD_VAR 0 3
35444: PPUSH
35445: CALL_OW 265
35449: PPUSH
35450: LD_VAR 0 3
35454: PPUSH
35455: CALL_OW 262
35459: PPUSH
35460: LD_VAR 0 3
35464: PPUSH
35465: CALL_OW 263
35469: PPUSH
35470: LD_VAR 0 3
35474: PPUSH
35475: CALL_OW 264
35479: PPUSH
35480: CALL 53233 0 5
35484: ST_TO_ADDR
// if components then
35485: LD_VAR 0 10
35489: IFFALSE 35507
// begin MC_InsertProduceList ( i , components ) ;
35491: LD_VAR 0 2
35495: PPUSH
35496: LD_VAR 0 10
35500: PPUSH
35501: CALL 44411 0 2
// break ;
35505: GO 35509
// end ; end ;
35507: GO 35427
35509: POP
35510: POP
// end ; continue ;
35511: GO 35007
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
35513: LD_VAR 0 3
35517: PPUSH
35518: LD_INT 1
35520: PPUSH
35521: CALL_OW 289
35525: PUSH
35526: LD_INT 100
35528: LESS
35529: PUSH
35530: LD_VAR 0 3
35534: PPUSH
35535: CALL_OW 314
35539: NOT
35540: AND
35541: IFFALSE 35570
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35543: LD_VAR 0 3
35547: PPUSH
35548: LD_VAR 0 6
35552: PUSH
35553: LD_INT 2
35555: ARRAY
35556: PPUSH
35557: LD_VAR 0 6
35561: PUSH
35562: LD_INT 3
35564: ARRAY
35565: PPUSH
35566: CALL_OW 117
// break ;
35570: GO 35574
// end ;
35572: GO 35007
35574: POP
35575: POP
// end ; end ;
35576: GO 33845
35578: POP
35579: POP
// end ;
35580: LD_VAR 0 1
35584: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
35585: LD_INT 0
35587: PPUSH
35588: PPUSH
35589: PPUSH
35590: PPUSH
// if not mc_bases then
35591: LD_EXP 90
35595: NOT
35596: IFFALSE 35600
// exit ;
35598: GO 35761
// for i = 1 to mc_bases do
35600: LD_ADDR_VAR 0 2
35604: PUSH
35605: DOUBLE
35606: LD_INT 1
35608: DEC
35609: ST_TO_ADDR
35610: LD_EXP 90
35614: PUSH
35615: FOR_TO
35616: IFFALSE 35759
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
35618: LD_ADDR_VAR 0 4
35622: PUSH
35623: LD_EXP 109
35627: PUSH
35628: LD_VAR 0 2
35632: ARRAY
35633: PUSH
35634: LD_EXP 112
35638: PUSH
35639: LD_VAR 0 2
35643: ARRAY
35644: UNION
35645: PPUSH
35646: LD_INT 33
35648: PUSH
35649: LD_INT 2
35651: PUSH
35652: EMPTY
35653: LIST
35654: LIST
35655: PPUSH
35656: CALL_OW 72
35660: ST_TO_ADDR
// if tmp then
35661: LD_VAR 0 4
35665: IFFALSE 35757
// for j in tmp do
35667: LD_ADDR_VAR 0 3
35671: PUSH
35672: LD_VAR 0 4
35676: PUSH
35677: FOR_IN
35678: IFFALSE 35755
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
35680: LD_VAR 0 3
35684: PPUSH
35685: CALL_OW 312
35689: NOT
35690: PUSH
35691: LD_VAR 0 3
35695: PPUSH
35696: CALL_OW 256
35700: PUSH
35701: LD_INT 250
35703: GREATEREQUAL
35704: AND
35705: IFFALSE 35718
// Connect ( j ) else
35707: LD_VAR 0 3
35711: PPUSH
35712: CALL 58634 0 1
35716: GO 35753
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
35718: LD_VAR 0 3
35722: PPUSH
35723: CALL_OW 256
35727: PUSH
35728: LD_INT 250
35730: LESS
35731: PUSH
35732: LD_VAR 0 3
35736: PPUSH
35737: CALL_OW 312
35741: AND
35742: IFFALSE 35753
// ComUnlink ( j ) ;
35744: LD_VAR 0 3
35748: PPUSH
35749: CALL_OW 136
35753: GO 35677
35755: POP
35756: POP
// end ;
35757: GO 35615
35759: POP
35760: POP
// end ;
35761: LD_VAR 0 1
35765: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
35766: LD_INT 0
35768: PPUSH
35769: PPUSH
35770: PPUSH
35771: PPUSH
35772: PPUSH
// if not mc_bases then
35773: LD_EXP 90
35777: NOT
35778: IFFALSE 35782
// exit ;
35780: GO 36227
// for i = 1 to mc_bases do
35782: LD_ADDR_VAR 0 2
35786: PUSH
35787: DOUBLE
35788: LD_INT 1
35790: DEC
35791: ST_TO_ADDR
35792: LD_EXP 90
35796: PUSH
35797: FOR_TO
35798: IFFALSE 36225
// begin if not mc_produce [ i ] then
35800: LD_EXP 111
35804: PUSH
35805: LD_VAR 0 2
35809: ARRAY
35810: NOT
35811: IFFALSE 35815
// continue ;
35813: GO 35797
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35815: LD_ADDR_VAR 0 5
35819: PUSH
35820: LD_EXP 90
35824: PUSH
35825: LD_VAR 0 2
35829: ARRAY
35830: PPUSH
35831: LD_INT 30
35833: PUSH
35834: LD_INT 3
35836: PUSH
35837: EMPTY
35838: LIST
35839: LIST
35840: PPUSH
35841: CALL_OW 72
35845: ST_TO_ADDR
// if not fac then
35846: LD_VAR 0 5
35850: NOT
35851: IFFALSE 35855
// continue ;
35853: GO 35797
// for j in fac do
35855: LD_ADDR_VAR 0 3
35859: PUSH
35860: LD_VAR 0 5
35864: PUSH
35865: FOR_IN
35866: IFFALSE 36221
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
35868: LD_VAR 0 3
35872: PPUSH
35873: CALL_OW 461
35877: PUSH
35878: LD_INT 2
35880: NONEQUAL
35881: PUSH
35882: LD_VAR 0 3
35886: PPUSH
35887: LD_INT 15
35889: PPUSH
35890: CALL 58294 0 2
35894: PUSH
35895: LD_INT 4
35897: ARRAY
35898: OR
35899: IFFALSE 35903
// continue ;
35901: GO 35865
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
35903: LD_VAR 0 3
35907: PPUSH
35908: LD_EXP 111
35912: PUSH
35913: LD_VAR 0 2
35917: ARRAY
35918: PUSH
35919: LD_INT 1
35921: ARRAY
35922: PUSH
35923: LD_INT 1
35925: ARRAY
35926: PPUSH
35927: LD_EXP 111
35931: PUSH
35932: LD_VAR 0 2
35936: ARRAY
35937: PUSH
35938: LD_INT 1
35940: ARRAY
35941: PUSH
35942: LD_INT 2
35944: ARRAY
35945: PPUSH
35946: LD_EXP 111
35950: PUSH
35951: LD_VAR 0 2
35955: ARRAY
35956: PUSH
35957: LD_INT 1
35959: ARRAY
35960: PUSH
35961: LD_INT 3
35963: ARRAY
35964: PPUSH
35965: LD_EXP 111
35969: PUSH
35970: LD_VAR 0 2
35974: ARRAY
35975: PUSH
35976: LD_INT 1
35978: ARRAY
35979: PUSH
35980: LD_INT 4
35982: ARRAY
35983: PPUSH
35984: CALL_OW 448
35988: PUSH
35989: LD_VAR 0 3
35993: PPUSH
35994: LD_EXP 111
35998: PUSH
35999: LD_VAR 0 2
36003: ARRAY
36004: PUSH
36005: LD_INT 1
36007: ARRAY
36008: PUSH
36009: LD_INT 1
36011: ARRAY
36012: PUSH
36013: LD_EXP 111
36017: PUSH
36018: LD_VAR 0 2
36022: ARRAY
36023: PUSH
36024: LD_INT 1
36026: ARRAY
36027: PUSH
36028: LD_INT 2
36030: ARRAY
36031: PUSH
36032: LD_EXP 111
36036: PUSH
36037: LD_VAR 0 2
36041: ARRAY
36042: PUSH
36043: LD_INT 1
36045: ARRAY
36046: PUSH
36047: LD_INT 3
36049: ARRAY
36050: PUSH
36051: LD_EXP 111
36055: PUSH
36056: LD_VAR 0 2
36060: ARRAY
36061: PUSH
36062: LD_INT 1
36064: ARRAY
36065: PUSH
36066: LD_INT 4
36068: ARRAY
36069: PUSH
36070: EMPTY
36071: LIST
36072: LIST
36073: LIST
36074: LIST
36075: PPUSH
36076: CALL 61965 0 2
36080: AND
36081: IFFALSE 36219
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
36083: LD_VAR 0 3
36087: PPUSH
36088: LD_EXP 111
36092: PUSH
36093: LD_VAR 0 2
36097: ARRAY
36098: PUSH
36099: LD_INT 1
36101: ARRAY
36102: PUSH
36103: LD_INT 1
36105: ARRAY
36106: PPUSH
36107: LD_EXP 111
36111: PUSH
36112: LD_VAR 0 2
36116: ARRAY
36117: PUSH
36118: LD_INT 1
36120: ARRAY
36121: PUSH
36122: LD_INT 2
36124: ARRAY
36125: PPUSH
36126: LD_EXP 111
36130: PUSH
36131: LD_VAR 0 2
36135: ARRAY
36136: PUSH
36137: LD_INT 1
36139: ARRAY
36140: PUSH
36141: LD_INT 3
36143: ARRAY
36144: PPUSH
36145: LD_EXP 111
36149: PUSH
36150: LD_VAR 0 2
36154: ARRAY
36155: PUSH
36156: LD_INT 1
36158: ARRAY
36159: PUSH
36160: LD_INT 4
36162: ARRAY
36163: PPUSH
36164: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
36168: LD_ADDR_VAR 0 4
36172: PUSH
36173: LD_EXP 111
36177: PUSH
36178: LD_VAR 0 2
36182: ARRAY
36183: PPUSH
36184: LD_INT 1
36186: PPUSH
36187: CALL_OW 3
36191: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
36192: LD_ADDR_EXP 111
36196: PUSH
36197: LD_EXP 111
36201: PPUSH
36202: LD_VAR 0 2
36206: PPUSH
36207: LD_VAR 0 4
36211: PPUSH
36212: CALL_OW 1
36216: ST_TO_ADDR
// break ;
36217: GO 36221
// end ; end ;
36219: GO 35865
36221: POP
36222: POP
// end ;
36223: GO 35797
36225: POP
36226: POP
// end ;
36227: LD_VAR 0 1
36231: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
36232: LD_INT 0
36234: PPUSH
36235: PPUSH
36236: PPUSH
// if not mc_bases then
36237: LD_EXP 90
36241: NOT
36242: IFFALSE 36246
// exit ;
36244: GO 36335
// for i = 1 to mc_bases do
36246: LD_ADDR_VAR 0 2
36250: PUSH
36251: DOUBLE
36252: LD_INT 1
36254: DEC
36255: ST_TO_ADDR
36256: LD_EXP 90
36260: PUSH
36261: FOR_TO
36262: IFFALSE 36333
// begin if mc_attack [ i ] then
36264: LD_EXP 110
36268: PUSH
36269: LD_VAR 0 2
36273: ARRAY
36274: IFFALSE 36331
// begin tmp := mc_attack [ i ] [ 1 ] ;
36276: LD_ADDR_VAR 0 3
36280: PUSH
36281: LD_EXP 110
36285: PUSH
36286: LD_VAR 0 2
36290: ARRAY
36291: PUSH
36292: LD_INT 1
36294: ARRAY
36295: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
36296: LD_ADDR_EXP 110
36300: PUSH
36301: LD_EXP 110
36305: PPUSH
36306: LD_VAR 0 2
36310: PPUSH
36311: EMPTY
36312: PPUSH
36313: CALL_OW 1
36317: ST_TO_ADDR
// Attack ( tmp ) ;
36318: LD_VAR 0 3
36322: PPUSH
36323: CALL 104723 0 1
// exit ;
36327: POP
36328: POP
36329: GO 36335
// end ; end ;
36331: GO 36261
36333: POP
36334: POP
// end ;
36335: LD_VAR 0 1
36339: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
36340: LD_INT 0
36342: PPUSH
36343: PPUSH
36344: PPUSH
36345: PPUSH
36346: PPUSH
36347: PPUSH
36348: PPUSH
// if not mc_bases then
36349: LD_EXP 90
36353: NOT
36354: IFFALSE 36358
// exit ;
36356: GO 36940
// for i = 1 to mc_bases do
36358: LD_ADDR_VAR 0 2
36362: PUSH
36363: DOUBLE
36364: LD_INT 1
36366: DEC
36367: ST_TO_ADDR
36368: LD_EXP 90
36372: PUSH
36373: FOR_TO
36374: IFFALSE 36938
// begin if not mc_bases [ i ] then
36376: LD_EXP 90
36380: PUSH
36381: LD_VAR 0 2
36385: ARRAY
36386: NOT
36387: IFFALSE 36391
// continue ;
36389: GO 36373
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
36391: LD_ADDR_VAR 0 7
36395: PUSH
36396: LD_EXP 90
36400: PUSH
36401: LD_VAR 0 2
36405: ARRAY
36406: PUSH
36407: LD_INT 1
36409: ARRAY
36410: PPUSH
36411: CALL 52537 0 1
36415: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
36416: LD_ADDR_EXP 113
36420: PUSH
36421: LD_EXP 113
36425: PPUSH
36426: LD_VAR 0 2
36430: PPUSH
36431: LD_EXP 90
36435: PUSH
36436: LD_VAR 0 2
36440: ARRAY
36441: PUSH
36442: LD_INT 1
36444: ARRAY
36445: PPUSH
36446: CALL_OW 255
36450: PPUSH
36451: LD_EXP 115
36455: PUSH
36456: LD_VAR 0 2
36460: ARRAY
36461: PPUSH
36462: CALL 52502 0 2
36466: PPUSH
36467: CALL_OW 1
36471: ST_TO_ADDR
// if not mc_scan [ i ] then
36472: LD_EXP 113
36476: PUSH
36477: LD_VAR 0 2
36481: ARRAY
36482: NOT
36483: IFFALSE 36638
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36485: LD_ADDR_VAR 0 4
36489: PUSH
36490: LD_EXP 90
36494: PUSH
36495: LD_VAR 0 2
36499: ARRAY
36500: PPUSH
36501: LD_INT 2
36503: PUSH
36504: LD_INT 25
36506: PUSH
36507: LD_INT 5
36509: PUSH
36510: EMPTY
36511: LIST
36512: LIST
36513: PUSH
36514: LD_INT 25
36516: PUSH
36517: LD_INT 8
36519: PUSH
36520: EMPTY
36521: LIST
36522: LIST
36523: PUSH
36524: LD_INT 25
36526: PUSH
36527: LD_INT 9
36529: PUSH
36530: EMPTY
36531: LIST
36532: LIST
36533: PUSH
36534: EMPTY
36535: LIST
36536: LIST
36537: LIST
36538: LIST
36539: PPUSH
36540: CALL_OW 72
36544: ST_TO_ADDR
// if not tmp then
36545: LD_VAR 0 4
36549: NOT
36550: IFFALSE 36554
// continue ;
36552: GO 36373
// for j in tmp do
36554: LD_ADDR_VAR 0 3
36558: PUSH
36559: LD_VAR 0 4
36563: PUSH
36564: FOR_IN
36565: IFFALSE 36636
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
36567: LD_VAR 0 3
36571: PPUSH
36572: CALL_OW 310
36576: PPUSH
36577: CALL_OW 266
36581: PUSH
36582: LD_INT 5
36584: EQUAL
36585: PUSH
36586: LD_VAR 0 3
36590: PPUSH
36591: CALL_OW 257
36595: PUSH
36596: LD_INT 1
36598: EQUAL
36599: AND
36600: PUSH
36601: LD_VAR 0 3
36605: PPUSH
36606: CALL_OW 459
36610: NOT
36611: AND
36612: PUSH
36613: LD_VAR 0 7
36617: AND
36618: IFFALSE 36634
// ComChangeProfession ( j , class ) ;
36620: LD_VAR 0 3
36624: PPUSH
36625: LD_VAR 0 7
36629: PPUSH
36630: CALL_OW 123
36634: GO 36564
36636: POP
36637: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
36638: LD_EXP 113
36642: PUSH
36643: LD_VAR 0 2
36647: ARRAY
36648: PUSH
36649: LD_EXP 112
36653: PUSH
36654: LD_VAR 0 2
36658: ARRAY
36659: NOT
36660: AND
36661: PUSH
36662: LD_EXP 90
36666: PUSH
36667: LD_VAR 0 2
36671: ARRAY
36672: PPUSH
36673: LD_INT 30
36675: PUSH
36676: LD_INT 32
36678: PUSH
36679: EMPTY
36680: LIST
36681: LIST
36682: PPUSH
36683: CALL_OW 72
36687: NOT
36688: AND
36689: PUSH
36690: LD_EXP 90
36694: PUSH
36695: LD_VAR 0 2
36699: ARRAY
36700: PPUSH
36701: LD_INT 2
36703: PUSH
36704: LD_INT 30
36706: PUSH
36707: LD_INT 4
36709: PUSH
36710: EMPTY
36711: LIST
36712: LIST
36713: PUSH
36714: LD_INT 30
36716: PUSH
36717: LD_INT 5
36719: PUSH
36720: EMPTY
36721: LIST
36722: LIST
36723: PUSH
36724: EMPTY
36725: LIST
36726: LIST
36727: LIST
36728: PPUSH
36729: CALL_OW 72
36733: NOT
36734: AND
36735: IFFALSE 36867
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36737: LD_ADDR_VAR 0 4
36741: PUSH
36742: LD_EXP 90
36746: PUSH
36747: LD_VAR 0 2
36751: ARRAY
36752: PPUSH
36753: LD_INT 2
36755: PUSH
36756: LD_INT 25
36758: PUSH
36759: LD_INT 1
36761: PUSH
36762: EMPTY
36763: LIST
36764: LIST
36765: PUSH
36766: LD_INT 25
36768: PUSH
36769: LD_INT 5
36771: PUSH
36772: EMPTY
36773: LIST
36774: LIST
36775: PUSH
36776: LD_INT 25
36778: PUSH
36779: LD_INT 8
36781: PUSH
36782: EMPTY
36783: LIST
36784: LIST
36785: PUSH
36786: LD_INT 25
36788: PUSH
36789: LD_INT 9
36791: PUSH
36792: EMPTY
36793: LIST
36794: LIST
36795: PUSH
36796: EMPTY
36797: LIST
36798: LIST
36799: LIST
36800: LIST
36801: LIST
36802: PPUSH
36803: CALL_OW 72
36807: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
36808: LD_ADDR_VAR 0 4
36812: PUSH
36813: LD_VAR 0 4
36817: PUSH
36818: LD_VAR 0 4
36822: PPUSH
36823: LD_INT 18
36825: PPUSH
36826: CALL 84262 0 2
36830: DIFF
36831: ST_TO_ADDR
// if tmp then
36832: LD_VAR 0 4
36836: IFFALSE 36867
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
36838: LD_VAR 0 2
36842: PPUSH
36843: LD_VAR 0 4
36847: PPUSH
36848: LD_EXP 115
36852: PUSH
36853: LD_VAR 0 2
36857: ARRAY
36858: PPUSH
36859: CALL 109432 0 3
// exit ;
36863: POP
36864: POP
36865: GO 36940
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
36867: LD_EXP 113
36871: PUSH
36872: LD_VAR 0 2
36876: ARRAY
36877: PUSH
36878: LD_EXP 112
36882: PUSH
36883: LD_VAR 0 2
36887: ARRAY
36888: AND
36889: IFFALSE 36936
// begin tmp := mc_defender [ i ] ;
36891: LD_ADDR_VAR 0 4
36895: PUSH
36896: LD_EXP 112
36900: PUSH
36901: LD_VAR 0 2
36905: ARRAY
36906: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
36907: LD_VAR 0 2
36911: PPUSH
36912: LD_VAR 0 4
36916: PPUSH
36917: LD_EXP 113
36921: PUSH
36922: LD_VAR 0 2
36926: ARRAY
36927: PPUSH
36928: CALL 109993 0 3
// exit ;
36932: POP
36933: POP
36934: GO 36940
// end ; end ;
36936: GO 36373
36938: POP
36939: POP
// end ;
36940: LD_VAR 0 1
36944: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
36945: LD_INT 0
36947: PPUSH
36948: PPUSH
36949: PPUSH
36950: PPUSH
36951: PPUSH
36952: PPUSH
36953: PPUSH
36954: PPUSH
36955: PPUSH
36956: PPUSH
36957: PPUSH
// if not mc_bases then
36958: LD_EXP 90
36962: NOT
36963: IFFALSE 36967
// exit ;
36965: GO 38054
// for i = 1 to mc_bases do
36967: LD_ADDR_VAR 0 2
36971: PUSH
36972: DOUBLE
36973: LD_INT 1
36975: DEC
36976: ST_TO_ADDR
36977: LD_EXP 90
36981: PUSH
36982: FOR_TO
36983: IFFALSE 38052
// begin tmp := mc_lab [ i ] ;
36985: LD_ADDR_VAR 0 6
36989: PUSH
36990: LD_EXP 123
36994: PUSH
36995: LD_VAR 0 2
36999: ARRAY
37000: ST_TO_ADDR
// if not tmp then
37001: LD_VAR 0 6
37005: NOT
37006: IFFALSE 37010
// continue ;
37008: GO 36982
// idle_lab := 0 ;
37010: LD_ADDR_VAR 0 11
37014: PUSH
37015: LD_INT 0
37017: ST_TO_ADDR
// for j in tmp do
37018: LD_ADDR_VAR 0 3
37022: PUSH
37023: LD_VAR 0 6
37027: PUSH
37028: FOR_IN
37029: IFFALSE 38048
// begin researching := false ;
37031: LD_ADDR_VAR 0 10
37035: PUSH
37036: LD_INT 0
37038: ST_TO_ADDR
// side := GetSide ( j ) ;
37039: LD_ADDR_VAR 0 4
37043: PUSH
37044: LD_VAR 0 3
37048: PPUSH
37049: CALL_OW 255
37053: ST_TO_ADDR
// if not mc_tech [ side ] then
37054: LD_EXP 117
37058: PUSH
37059: LD_VAR 0 4
37063: ARRAY
37064: NOT
37065: IFFALSE 37069
// continue ;
37067: GO 37028
// if BuildingStatus ( j ) = bs_idle then
37069: LD_VAR 0 3
37073: PPUSH
37074: CALL_OW 461
37078: PUSH
37079: LD_INT 2
37081: EQUAL
37082: IFFALSE 37270
// begin if idle_lab and UnitsInside ( j ) < 6 then
37084: LD_VAR 0 11
37088: PUSH
37089: LD_VAR 0 3
37093: PPUSH
37094: CALL_OW 313
37098: PUSH
37099: LD_INT 6
37101: LESS
37102: AND
37103: IFFALSE 37174
// begin tmp2 := UnitsInside ( idle_lab ) ;
37105: LD_ADDR_VAR 0 9
37109: PUSH
37110: LD_VAR 0 11
37114: PPUSH
37115: CALL_OW 313
37119: ST_TO_ADDR
// if tmp2 then
37120: LD_VAR 0 9
37124: IFFALSE 37166
// for x in tmp2 do
37126: LD_ADDR_VAR 0 7
37130: PUSH
37131: LD_VAR 0 9
37135: PUSH
37136: FOR_IN
37137: IFFALSE 37164
// begin ComExitBuilding ( x ) ;
37139: LD_VAR 0 7
37143: PPUSH
37144: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
37148: LD_VAR 0 7
37152: PPUSH
37153: LD_VAR 0 3
37157: PPUSH
37158: CALL_OW 180
// end ;
37162: GO 37136
37164: POP
37165: POP
// idle_lab := 0 ;
37166: LD_ADDR_VAR 0 11
37170: PUSH
37171: LD_INT 0
37173: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
37174: LD_ADDR_VAR 0 5
37178: PUSH
37179: LD_EXP 117
37183: PUSH
37184: LD_VAR 0 4
37188: ARRAY
37189: PUSH
37190: FOR_IN
37191: IFFALSE 37251
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
37193: LD_VAR 0 3
37197: PPUSH
37198: LD_VAR 0 5
37202: PPUSH
37203: CALL_OW 430
37207: PUSH
37208: LD_VAR 0 4
37212: PPUSH
37213: LD_VAR 0 5
37217: PPUSH
37218: CALL 51607 0 2
37222: AND
37223: IFFALSE 37249
// begin researching := true ;
37225: LD_ADDR_VAR 0 10
37229: PUSH
37230: LD_INT 1
37232: ST_TO_ADDR
// ComResearch ( j , t ) ;
37233: LD_VAR 0 3
37237: PPUSH
37238: LD_VAR 0 5
37242: PPUSH
37243: CALL_OW 124
// break ;
37247: GO 37251
// end ;
37249: GO 37190
37251: POP
37252: POP
// if not researching then
37253: LD_VAR 0 10
37257: NOT
37258: IFFALSE 37270
// idle_lab := j ;
37260: LD_ADDR_VAR 0 11
37264: PUSH
37265: LD_VAR 0 3
37269: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
37270: LD_VAR 0 3
37274: PPUSH
37275: CALL_OW 461
37279: PUSH
37280: LD_INT 10
37282: EQUAL
37283: IFFALSE 37871
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
37285: LD_EXP 119
37289: PUSH
37290: LD_VAR 0 2
37294: ARRAY
37295: NOT
37296: PUSH
37297: LD_EXP 120
37301: PUSH
37302: LD_VAR 0 2
37306: ARRAY
37307: NOT
37308: AND
37309: PUSH
37310: LD_EXP 117
37314: PUSH
37315: LD_VAR 0 4
37319: ARRAY
37320: PUSH
37321: LD_INT 1
37323: GREATER
37324: AND
37325: IFFALSE 37456
// begin ComCancel ( j ) ;
37327: LD_VAR 0 3
37331: PPUSH
37332: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
37336: LD_ADDR_EXP 117
37340: PUSH
37341: LD_EXP 117
37345: PPUSH
37346: LD_VAR 0 4
37350: PPUSH
37351: LD_EXP 117
37355: PUSH
37356: LD_VAR 0 4
37360: ARRAY
37361: PPUSH
37362: LD_EXP 117
37366: PUSH
37367: LD_VAR 0 4
37371: ARRAY
37372: PUSH
37373: LD_INT 1
37375: MINUS
37376: PPUSH
37377: LD_EXP 117
37381: PUSH
37382: LD_VAR 0 4
37386: ARRAY
37387: PPUSH
37388: LD_INT 0
37390: PPUSH
37391: CALL 55119 0 4
37395: PPUSH
37396: CALL_OW 1
37400: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
37401: LD_ADDR_EXP 117
37405: PUSH
37406: LD_EXP 117
37410: PPUSH
37411: LD_VAR 0 4
37415: PPUSH
37416: LD_EXP 117
37420: PUSH
37421: LD_VAR 0 4
37425: ARRAY
37426: PPUSH
37427: LD_EXP 117
37431: PUSH
37432: LD_VAR 0 4
37436: ARRAY
37437: PPUSH
37438: LD_INT 1
37440: PPUSH
37441: LD_INT 0
37443: PPUSH
37444: CALL 55119 0 4
37448: PPUSH
37449: CALL_OW 1
37453: ST_TO_ADDR
// continue ;
37454: GO 37028
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
37456: LD_EXP 119
37460: PUSH
37461: LD_VAR 0 2
37465: ARRAY
37466: PUSH
37467: LD_EXP 120
37471: PUSH
37472: LD_VAR 0 2
37476: ARRAY
37477: NOT
37478: AND
37479: IFFALSE 37606
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
37481: LD_ADDR_EXP 120
37485: PUSH
37486: LD_EXP 120
37490: PPUSH
37491: LD_VAR 0 2
37495: PUSH
37496: LD_EXP 120
37500: PUSH
37501: LD_VAR 0 2
37505: ARRAY
37506: PUSH
37507: LD_INT 1
37509: PLUS
37510: PUSH
37511: EMPTY
37512: LIST
37513: LIST
37514: PPUSH
37515: LD_EXP 119
37519: PUSH
37520: LD_VAR 0 2
37524: ARRAY
37525: PUSH
37526: LD_INT 1
37528: ARRAY
37529: PPUSH
37530: CALL 55701 0 3
37534: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
37535: LD_EXP 119
37539: PUSH
37540: LD_VAR 0 2
37544: ARRAY
37545: PUSH
37546: LD_INT 1
37548: ARRAY
37549: PPUSH
37550: LD_INT 112
37552: PPUSH
37553: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
37557: LD_ADDR_VAR 0 9
37561: PUSH
37562: LD_EXP 119
37566: PUSH
37567: LD_VAR 0 2
37571: ARRAY
37572: PPUSH
37573: LD_INT 1
37575: PPUSH
37576: CALL_OW 3
37580: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
37581: LD_ADDR_EXP 119
37585: PUSH
37586: LD_EXP 119
37590: PPUSH
37591: LD_VAR 0 2
37595: PPUSH
37596: LD_VAR 0 9
37600: PPUSH
37601: CALL_OW 1
37605: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
37606: LD_EXP 119
37610: PUSH
37611: LD_VAR 0 2
37615: ARRAY
37616: PUSH
37617: LD_EXP 120
37621: PUSH
37622: LD_VAR 0 2
37626: ARRAY
37627: AND
37628: PUSH
37629: LD_EXP 120
37633: PUSH
37634: LD_VAR 0 2
37638: ARRAY
37639: PUSH
37640: LD_INT 1
37642: ARRAY
37643: PPUSH
37644: CALL_OW 310
37648: NOT
37649: AND
37650: PUSH
37651: LD_VAR 0 3
37655: PPUSH
37656: CALL_OW 313
37660: PUSH
37661: LD_INT 6
37663: EQUAL
37664: AND
37665: IFFALSE 37721
// begin tmp2 := UnitsInside ( j ) ;
37667: LD_ADDR_VAR 0 9
37671: PUSH
37672: LD_VAR 0 3
37676: PPUSH
37677: CALL_OW 313
37681: ST_TO_ADDR
// if tmp2 = 6 then
37682: LD_VAR 0 9
37686: PUSH
37687: LD_INT 6
37689: EQUAL
37690: IFFALSE 37721
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
37692: LD_VAR 0 9
37696: PUSH
37697: LD_INT 1
37699: ARRAY
37700: PPUSH
37701: LD_INT 112
37703: PPUSH
37704: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
37708: LD_VAR 0 9
37712: PUSH
37713: LD_INT 1
37715: ARRAY
37716: PPUSH
37717: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
37721: LD_EXP 120
37725: PUSH
37726: LD_VAR 0 2
37730: ARRAY
37731: PUSH
37732: LD_EXP 120
37736: PUSH
37737: LD_VAR 0 2
37741: ARRAY
37742: PUSH
37743: LD_INT 1
37745: ARRAY
37746: PPUSH
37747: CALL_OW 314
37751: NOT
37752: AND
37753: PUSH
37754: LD_EXP 120
37758: PUSH
37759: LD_VAR 0 2
37763: ARRAY
37764: PUSH
37765: LD_INT 1
37767: ARRAY
37768: PPUSH
37769: CALL_OW 310
37773: NOT
37774: AND
37775: IFFALSE 37801
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
37777: LD_EXP 120
37781: PUSH
37782: LD_VAR 0 2
37786: ARRAY
37787: PUSH
37788: LD_INT 1
37790: ARRAY
37791: PPUSH
37792: LD_VAR 0 3
37796: PPUSH
37797: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
37801: LD_EXP 120
37805: PUSH
37806: LD_VAR 0 2
37810: ARRAY
37811: PUSH
37812: LD_INT 1
37814: ARRAY
37815: PPUSH
37816: CALL_OW 310
37820: PUSH
37821: LD_EXP 120
37825: PUSH
37826: LD_VAR 0 2
37830: ARRAY
37831: PUSH
37832: LD_INT 1
37834: ARRAY
37835: PPUSH
37836: CALL_OW 310
37840: PPUSH
37841: CALL_OW 461
37845: PUSH
37846: LD_INT 3
37848: NONEQUAL
37849: AND
37850: IFFALSE 37871
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
37852: LD_EXP 120
37856: PUSH
37857: LD_VAR 0 2
37861: ARRAY
37862: PUSH
37863: LD_INT 1
37865: ARRAY
37866: PPUSH
37867: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
37871: LD_VAR 0 3
37875: PPUSH
37876: CALL_OW 461
37880: PUSH
37881: LD_INT 6
37883: EQUAL
37884: PUSH
37885: LD_VAR 0 6
37889: PUSH
37890: LD_INT 1
37892: GREATER
37893: AND
37894: IFFALSE 38046
// begin sci := [ ] ;
37896: LD_ADDR_VAR 0 8
37900: PUSH
37901: EMPTY
37902: ST_TO_ADDR
// for x in ( tmp diff j ) do
37903: LD_ADDR_VAR 0 7
37907: PUSH
37908: LD_VAR 0 6
37912: PUSH
37913: LD_VAR 0 3
37917: DIFF
37918: PUSH
37919: FOR_IN
37920: IFFALSE 37972
// begin if sci = 6 then
37922: LD_VAR 0 8
37926: PUSH
37927: LD_INT 6
37929: EQUAL
37930: IFFALSE 37934
// break ;
37932: GO 37972
// if BuildingStatus ( x ) = bs_idle then
37934: LD_VAR 0 7
37938: PPUSH
37939: CALL_OW 461
37943: PUSH
37944: LD_INT 2
37946: EQUAL
37947: IFFALSE 37970
// sci := sci ^ UnitsInside ( x ) ;
37949: LD_ADDR_VAR 0 8
37953: PUSH
37954: LD_VAR 0 8
37958: PUSH
37959: LD_VAR 0 7
37963: PPUSH
37964: CALL_OW 313
37968: ADD
37969: ST_TO_ADDR
// end ;
37970: GO 37919
37972: POP
37973: POP
// if not sci then
37974: LD_VAR 0 8
37978: NOT
37979: IFFALSE 37983
// continue ;
37981: GO 37028
// for x in sci do
37983: LD_ADDR_VAR 0 7
37987: PUSH
37988: LD_VAR 0 8
37992: PUSH
37993: FOR_IN
37994: IFFALSE 38044
// if IsInUnit ( x ) and not HasTask ( x ) then
37996: LD_VAR 0 7
38000: PPUSH
38001: CALL_OW 310
38005: PUSH
38006: LD_VAR 0 7
38010: PPUSH
38011: CALL_OW 314
38015: NOT
38016: AND
38017: IFFALSE 38042
// begin ComExitBuilding ( x ) ;
38019: LD_VAR 0 7
38023: PPUSH
38024: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
38028: LD_VAR 0 7
38032: PPUSH
38033: LD_VAR 0 3
38037: PPUSH
38038: CALL_OW 180
// end ;
38042: GO 37993
38044: POP
38045: POP
// end ; end ;
38046: GO 37028
38048: POP
38049: POP
// end ;
38050: GO 36982
38052: POP
38053: POP
// end ;
38054: LD_VAR 0 1
38058: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
38059: LD_INT 0
38061: PPUSH
38062: PPUSH
// if not mc_bases then
38063: LD_EXP 90
38067: NOT
38068: IFFALSE 38072
// exit ;
38070: GO 38153
// for i = 1 to mc_bases do
38072: LD_ADDR_VAR 0 2
38076: PUSH
38077: DOUBLE
38078: LD_INT 1
38080: DEC
38081: ST_TO_ADDR
38082: LD_EXP 90
38086: PUSH
38087: FOR_TO
38088: IFFALSE 38151
// if mc_mines [ i ] and mc_miners [ i ] then
38090: LD_EXP 103
38094: PUSH
38095: LD_VAR 0 2
38099: ARRAY
38100: PUSH
38101: LD_EXP 104
38105: PUSH
38106: LD_VAR 0 2
38110: ARRAY
38111: AND
38112: IFFALSE 38149
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
38114: LD_EXP 104
38118: PUSH
38119: LD_VAR 0 2
38123: ARRAY
38124: PUSH
38125: LD_INT 1
38127: ARRAY
38128: PPUSH
38129: CALL_OW 255
38133: PPUSH
38134: LD_EXP 103
38138: PUSH
38139: LD_VAR 0 2
38143: ARRAY
38144: PPUSH
38145: CALL 52690 0 2
38149: GO 38087
38151: POP
38152: POP
// end ;
38153: LD_VAR 0 1
38157: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
38158: LD_INT 0
38160: PPUSH
38161: PPUSH
38162: PPUSH
38163: PPUSH
38164: PPUSH
38165: PPUSH
38166: PPUSH
38167: PPUSH
// if not mc_bases or not mc_parking then
38168: LD_EXP 90
38172: NOT
38173: PUSH
38174: LD_EXP 114
38178: NOT
38179: OR
38180: IFFALSE 38184
// exit ;
38182: GO 38883
// for i = 1 to mc_bases do
38184: LD_ADDR_VAR 0 2
38188: PUSH
38189: DOUBLE
38190: LD_INT 1
38192: DEC
38193: ST_TO_ADDR
38194: LD_EXP 90
38198: PUSH
38199: FOR_TO
38200: IFFALSE 38881
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
38202: LD_EXP 90
38206: PUSH
38207: LD_VAR 0 2
38211: ARRAY
38212: NOT
38213: PUSH
38214: LD_EXP 114
38218: PUSH
38219: LD_VAR 0 2
38223: ARRAY
38224: NOT
38225: OR
38226: IFFALSE 38230
// continue ;
38228: GO 38199
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
38230: LD_ADDR_VAR 0 5
38234: PUSH
38235: LD_EXP 90
38239: PUSH
38240: LD_VAR 0 2
38244: ARRAY
38245: PUSH
38246: LD_INT 1
38248: ARRAY
38249: PPUSH
38250: CALL_OW 255
38254: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38255: LD_ADDR_VAR 0 6
38259: PUSH
38260: LD_EXP 90
38264: PUSH
38265: LD_VAR 0 2
38269: ARRAY
38270: PPUSH
38271: LD_INT 30
38273: PUSH
38274: LD_INT 3
38276: PUSH
38277: EMPTY
38278: LIST
38279: LIST
38280: PPUSH
38281: CALL_OW 72
38285: ST_TO_ADDR
// if not fac then
38286: LD_VAR 0 6
38290: NOT
38291: IFFALSE 38342
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38293: LD_ADDR_VAR 0 6
38297: PUSH
38298: LD_EXP 90
38302: PUSH
38303: LD_VAR 0 2
38307: ARRAY
38308: PPUSH
38309: LD_INT 2
38311: PUSH
38312: LD_INT 30
38314: PUSH
38315: LD_INT 0
38317: PUSH
38318: EMPTY
38319: LIST
38320: LIST
38321: PUSH
38322: LD_INT 30
38324: PUSH
38325: LD_INT 1
38327: PUSH
38328: EMPTY
38329: LIST
38330: LIST
38331: PUSH
38332: EMPTY
38333: LIST
38334: LIST
38335: LIST
38336: PPUSH
38337: CALL_OW 72
38341: ST_TO_ADDR
// if not fac then
38342: LD_VAR 0 6
38346: NOT
38347: IFFALSE 38351
// continue ;
38349: GO 38199
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
38351: LD_ADDR_VAR 0 7
38355: PUSH
38356: LD_EXP 114
38360: PUSH
38361: LD_VAR 0 2
38365: ARRAY
38366: PPUSH
38367: LD_INT 22
38369: PUSH
38370: LD_VAR 0 5
38374: PUSH
38375: EMPTY
38376: LIST
38377: LIST
38378: PUSH
38379: LD_INT 21
38381: PUSH
38382: LD_INT 2
38384: PUSH
38385: EMPTY
38386: LIST
38387: LIST
38388: PUSH
38389: LD_INT 3
38391: PUSH
38392: LD_INT 24
38394: PUSH
38395: LD_INT 1000
38397: PUSH
38398: EMPTY
38399: LIST
38400: LIST
38401: PUSH
38402: EMPTY
38403: LIST
38404: LIST
38405: PUSH
38406: EMPTY
38407: LIST
38408: LIST
38409: LIST
38410: PPUSH
38411: CALL_OW 70
38415: ST_TO_ADDR
// for j in fac do
38416: LD_ADDR_VAR 0 3
38420: PUSH
38421: LD_VAR 0 6
38425: PUSH
38426: FOR_IN
38427: IFFALSE 38508
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
38429: LD_ADDR_VAR 0 7
38433: PUSH
38434: LD_VAR 0 7
38438: PUSH
38439: LD_INT 22
38441: PUSH
38442: LD_VAR 0 5
38446: PUSH
38447: EMPTY
38448: LIST
38449: LIST
38450: PUSH
38451: LD_INT 91
38453: PUSH
38454: LD_VAR 0 3
38458: PUSH
38459: LD_INT 15
38461: PUSH
38462: EMPTY
38463: LIST
38464: LIST
38465: LIST
38466: PUSH
38467: LD_INT 21
38469: PUSH
38470: LD_INT 2
38472: PUSH
38473: EMPTY
38474: LIST
38475: LIST
38476: PUSH
38477: LD_INT 3
38479: PUSH
38480: LD_INT 24
38482: PUSH
38483: LD_INT 1000
38485: PUSH
38486: EMPTY
38487: LIST
38488: LIST
38489: PUSH
38490: EMPTY
38491: LIST
38492: LIST
38493: PUSH
38494: EMPTY
38495: LIST
38496: LIST
38497: LIST
38498: LIST
38499: PPUSH
38500: CALL_OW 69
38504: UNION
38505: ST_TO_ADDR
38506: GO 38426
38508: POP
38509: POP
// if not vehs then
38510: LD_VAR 0 7
38514: NOT
38515: IFFALSE 38541
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
38517: LD_ADDR_EXP 102
38521: PUSH
38522: LD_EXP 102
38526: PPUSH
38527: LD_VAR 0 2
38531: PPUSH
38532: EMPTY
38533: PPUSH
38534: CALL_OW 1
38538: ST_TO_ADDR
// continue ;
38539: GO 38199
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38541: LD_ADDR_VAR 0 8
38545: PUSH
38546: LD_EXP 90
38550: PUSH
38551: LD_VAR 0 2
38555: ARRAY
38556: PPUSH
38557: LD_INT 30
38559: PUSH
38560: LD_INT 3
38562: PUSH
38563: EMPTY
38564: LIST
38565: LIST
38566: PPUSH
38567: CALL_OW 72
38571: ST_TO_ADDR
// if tmp then
38572: LD_VAR 0 8
38576: IFFALSE 38679
// begin for j in tmp do
38578: LD_ADDR_VAR 0 3
38582: PUSH
38583: LD_VAR 0 8
38587: PUSH
38588: FOR_IN
38589: IFFALSE 38677
// for k in UnitsInside ( j ) do
38591: LD_ADDR_VAR 0 4
38595: PUSH
38596: LD_VAR 0 3
38600: PPUSH
38601: CALL_OW 313
38605: PUSH
38606: FOR_IN
38607: IFFALSE 38673
// if k then
38609: LD_VAR 0 4
38613: IFFALSE 38671
// if not k in mc_repair_vehicle [ i ] then
38615: LD_VAR 0 4
38619: PUSH
38620: LD_EXP 102
38624: PUSH
38625: LD_VAR 0 2
38629: ARRAY
38630: IN
38631: NOT
38632: IFFALSE 38671
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
38634: LD_ADDR_EXP 102
38638: PUSH
38639: LD_EXP 102
38643: PPUSH
38644: LD_VAR 0 2
38648: PPUSH
38649: LD_EXP 102
38653: PUSH
38654: LD_VAR 0 2
38658: ARRAY
38659: PUSH
38660: LD_VAR 0 4
38664: UNION
38665: PPUSH
38666: CALL_OW 1
38670: ST_TO_ADDR
38671: GO 38606
38673: POP
38674: POP
38675: GO 38588
38677: POP
38678: POP
// end ; if not mc_repair_vehicle [ i ] then
38679: LD_EXP 102
38683: PUSH
38684: LD_VAR 0 2
38688: ARRAY
38689: NOT
38690: IFFALSE 38694
// continue ;
38692: GO 38199
// for j in mc_repair_vehicle [ i ] do
38694: LD_ADDR_VAR 0 3
38698: PUSH
38699: LD_EXP 102
38703: PUSH
38704: LD_VAR 0 2
38708: ARRAY
38709: PUSH
38710: FOR_IN
38711: IFFALSE 38877
// begin if GetClass ( j ) <> 3 then
38713: LD_VAR 0 3
38717: PPUSH
38718: CALL_OW 257
38722: PUSH
38723: LD_INT 3
38725: NONEQUAL
38726: IFFALSE 38767
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
38728: LD_ADDR_EXP 102
38732: PUSH
38733: LD_EXP 102
38737: PPUSH
38738: LD_VAR 0 2
38742: PPUSH
38743: LD_EXP 102
38747: PUSH
38748: LD_VAR 0 2
38752: ARRAY
38753: PUSH
38754: LD_VAR 0 3
38758: DIFF
38759: PPUSH
38760: CALL_OW 1
38764: ST_TO_ADDR
// continue ;
38765: GO 38710
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38767: LD_VAR 0 3
38771: PPUSH
38772: CALL_OW 311
38776: NOT
38777: PUSH
38778: LD_VAR 0 3
38782: PUSH
38783: LD_EXP 93
38787: PUSH
38788: LD_VAR 0 2
38792: ARRAY
38793: PUSH
38794: LD_INT 1
38796: ARRAY
38797: IN
38798: NOT
38799: AND
38800: PUSH
38801: LD_VAR 0 3
38805: PUSH
38806: LD_EXP 93
38810: PUSH
38811: LD_VAR 0 2
38815: ARRAY
38816: PUSH
38817: LD_INT 2
38819: ARRAY
38820: IN
38821: NOT
38822: AND
38823: IFFALSE 38875
// begin if IsInUnit ( j ) then
38825: LD_VAR 0 3
38829: PPUSH
38830: CALL_OW 310
38834: IFFALSE 38845
// ComExitBuilding ( j ) ;
38836: LD_VAR 0 3
38840: PPUSH
38841: CALL_OW 122
// if not HasTask ( j ) then
38845: LD_VAR 0 3
38849: PPUSH
38850: CALL_OW 314
38854: NOT
38855: IFFALSE 38875
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
38857: LD_VAR 0 3
38861: PPUSH
38862: LD_VAR 0 7
38866: PUSH
38867: LD_INT 1
38869: ARRAY
38870: PPUSH
38871: CALL_OW 189
// end ; end ;
38875: GO 38710
38877: POP
38878: POP
// end ;
38879: GO 38199
38881: POP
38882: POP
// end ;
38883: LD_VAR 0 1
38887: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
38888: LD_INT 0
38890: PPUSH
38891: PPUSH
38892: PPUSH
38893: PPUSH
38894: PPUSH
38895: PPUSH
38896: PPUSH
38897: PPUSH
38898: PPUSH
38899: PPUSH
38900: PPUSH
// if not mc_bases then
38901: LD_EXP 90
38905: NOT
38906: IFFALSE 38910
// exit ;
38908: GO 39712
// for i = 1 to mc_bases do
38910: LD_ADDR_VAR 0 2
38914: PUSH
38915: DOUBLE
38916: LD_INT 1
38918: DEC
38919: ST_TO_ADDR
38920: LD_EXP 90
38924: PUSH
38925: FOR_TO
38926: IFFALSE 39710
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
38928: LD_EXP 118
38932: PUSH
38933: LD_VAR 0 2
38937: ARRAY
38938: NOT
38939: PUSH
38940: LD_EXP 93
38944: PUSH
38945: LD_VAR 0 2
38949: ARRAY
38950: PUSH
38951: LD_INT 1
38953: ARRAY
38954: OR
38955: PUSH
38956: LD_EXP 93
38960: PUSH
38961: LD_VAR 0 2
38965: ARRAY
38966: PUSH
38967: LD_INT 2
38969: ARRAY
38970: OR
38971: PUSH
38972: LD_EXP 116
38976: PUSH
38977: LD_VAR 0 2
38981: ARRAY
38982: PPUSH
38983: LD_INT 1
38985: PPUSH
38986: CALL_OW 325
38990: NOT
38991: OR
38992: PUSH
38993: LD_EXP 113
38997: PUSH
38998: LD_VAR 0 2
39002: ARRAY
39003: OR
39004: IFFALSE 39008
// continue ;
39006: GO 38925
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
39008: LD_ADDR_VAR 0 8
39012: PUSH
39013: LD_EXP 90
39017: PUSH
39018: LD_VAR 0 2
39022: ARRAY
39023: PPUSH
39024: LD_INT 25
39026: PUSH
39027: LD_INT 4
39029: PUSH
39030: EMPTY
39031: LIST
39032: LIST
39033: PUSH
39034: LD_INT 50
39036: PUSH
39037: EMPTY
39038: LIST
39039: PUSH
39040: LD_INT 3
39042: PUSH
39043: LD_INT 60
39045: PUSH
39046: EMPTY
39047: LIST
39048: PUSH
39049: EMPTY
39050: LIST
39051: LIST
39052: PUSH
39053: EMPTY
39054: LIST
39055: LIST
39056: LIST
39057: PPUSH
39058: CALL_OW 72
39062: PUSH
39063: LD_EXP 94
39067: PUSH
39068: LD_VAR 0 2
39072: ARRAY
39073: DIFF
39074: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39075: LD_ADDR_VAR 0 9
39079: PUSH
39080: LD_EXP 90
39084: PUSH
39085: LD_VAR 0 2
39089: ARRAY
39090: PPUSH
39091: LD_INT 2
39093: PUSH
39094: LD_INT 30
39096: PUSH
39097: LD_INT 0
39099: PUSH
39100: EMPTY
39101: LIST
39102: LIST
39103: PUSH
39104: LD_INT 30
39106: PUSH
39107: LD_INT 1
39109: PUSH
39110: EMPTY
39111: LIST
39112: LIST
39113: PUSH
39114: EMPTY
39115: LIST
39116: LIST
39117: LIST
39118: PPUSH
39119: CALL_OW 72
39123: ST_TO_ADDR
// if not tmp or not dep then
39124: LD_VAR 0 8
39128: NOT
39129: PUSH
39130: LD_VAR 0 9
39134: NOT
39135: OR
39136: IFFALSE 39140
// continue ;
39138: GO 38925
// side := GetSide ( tmp [ 1 ] ) ;
39140: LD_ADDR_VAR 0 11
39144: PUSH
39145: LD_VAR 0 8
39149: PUSH
39150: LD_INT 1
39152: ARRAY
39153: PPUSH
39154: CALL_OW 255
39158: ST_TO_ADDR
// dep := dep [ 1 ] ;
39159: LD_ADDR_VAR 0 9
39163: PUSH
39164: LD_VAR 0 9
39168: PUSH
39169: LD_INT 1
39171: ARRAY
39172: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
39173: LD_ADDR_VAR 0 7
39177: PUSH
39178: LD_EXP 118
39182: PUSH
39183: LD_VAR 0 2
39187: ARRAY
39188: PPUSH
39189: LD_INT 22
39191: PUSH
39192: LD_INT 0
39194: PUSH
39195: EMPTY
39196: LIST
39197: LIST
39198: PUSH
39199: LD_INT 25
39201: PUSH
39202: LD_INT 12
39204: PUSH
39205: EMPTY
39206: LIST
39207: LIST
39208: PUSH
39209: EMPTY
39210: LIST
39211: LIST
39212: PPUSH
39213: CALL_OW 70
39217: PUSH
39218: LD_INT 22
39220: PUSH
39221: LD_INT 0
39223: PUSH
39224: EMPTY
39225: LIST
39226: LIST
39227: PUSH
39228: LD_INT 25
39230: PUSH
39231: LD_INT 12
39233: PUSH
39234: EMPTY
39235: LIST
39236: LIST
39237: PUSH
39238: LD_INT 91
39240: PUSH
39241: LD_VAR 0 9
39245: PUSH
39246: LD_INT 20
39248: PUSH
39249: EMPTY
39250: LIST
39251: LIST
39252: LIST
39253: PUSH
39254: EMPTY
39255: LIST
39256: LIST
39257: LIST
39258: PPUSH
39259: CALL_OW 69
39263: UNION
39264: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
39265: LD_ADDR_VAR 0 10
39269: PUSH
39270: LD_EXP 118
39274: PUSH
39275: LD_VAR 0 2
39279: ARRAY
39280: PPUSH
39281: LD_INT 81
39283: PUSH
39284: LD_VAR 0 11
39288: PUSH
39289: EMPTY
39290: LIST
39291: LIST
39292: PPUSH
39293: CALL_OW 70
39297: ST_TO_ADDR
// if not apes or danger_at_area then
39298: LD_VAR 0 7
39302: NOT
39303: PUSH
39304: LD_VAR 0 10
39308: OR
39309: IFFALSE 39359
// begin if mc_taming [ i ] then
39311: LD_EXP 121
39315: PUSH
39316: LD_VAR 0 2
39320: ARRAY
39321: IFFALSE 39357
// begin MC_Reset ( i , 121 ) ;
39323: LD_VAR 0 2
39327: PPUSH
39328: LD_INT 121
39330: PPUSH
39331: CALL 24810 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
39335: LD_ADDR_EXP 121
39339: PUSH
39340: LD_EXP 121
39344: PPUSH
39345: LD_VAR 0 2
39349: PPUSH
39350: EMPTY
39351: PPUSH
39352: CALL_OW 1
39356: ST_TO_ADDR
// end ; continue ;
39357: GO 38925
// end ; for j in tmp do
39359: LD_ADDR_VAR 0 3
39363: PUSH
39364: LD_VAR 0 8
39368: PUSH
39369: FOR_IN
39370: IFFALSE 39706
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
39372: LD_VAR 0 3
39376: PUSH
39377: LD_EXP 121
39381: PUSH
39382: LD_VAR 0 2
39386: ARRAY
39387: IN
39388: NOT
39389: PUSH
39390: LD_EXP 121
39394: PUSH
39395: LD_VAR 0 2
39399: ARRAY
39400: PUSH
39401: LD_INT 3
39403: LESS
39404: AND
39405: IFFALSE 39463
// begin SetTag ( j , 121 ) ;
39407: LD_VAR 0 3
39411: PPUSH
39412: LD_INT 121
39414: PPUSH
39415: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
39419: LD_ADDR_EXP 121
39423: PUSH
39424: LD_EXP 121
39428: PPUSH
39429: LD_VAR 0 2
39433: PUSH
39434: LD_EXP 121
39438: PUSH
39439: LD_VAR 0 2
39443: ARRAY
39444: PUSH
39445: LD_INT 1
39447: PLUS
39448: PUSH
39449: EMPTY
39450: LIST
39451: LIST
39452: PPUSH
39453: LD_VAR 0 3
39457: PPUSH
39458: CALL 55701 0 3
39462: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
39463: LD_VAR 0 3
39467: PUSH
39468: LD_EXP 121
39472: PUSH
39473: LD_VAR 0 2
39477: ARRAY
39478: IN
39479: IFFALSE 39704
// begin if GetClass ( j ) <> 4 then
39481: LD_VAR 0 3
39485: PPUSH
39486: CALL_OW 257
39490: PUSH
39491: LD_INT 4
39493: NONEQUAL
39494: IFFALSE 39547
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
39496: LD_ADDR_EXP 121
39500: PUSH
39501: LD_EXP 121
39505: PPUSH
39506: LD_VAR 0 2
39510: PPUSH
39511: LD_EXP 121
39515: PUSH
39516: LD_VAR 0 2
39520: ARRAY
39521: PUSH
39522: LD_VAR 0 3
39526: DIFF
39527: PPUSH
39528: CALL_OW 1
39532: ST_TO_ADDR
// SetTag ( j , 0 ) ;
39533: LD_VAR 0 3
39537: PPUSH
39538: LD_INT 0
39540: PPUSH
39541: CALL_OW 109
// continue ;
39545: GO 39369
// end ; if IsInUnit ( j ) then
39547: LD_VAR 0 3
39551: PPUSH
39552: CALL_OW 310
39556: IFFALSE 39567
// ComExitBuilding ( j ) ;
39558: LD_VAR 0 3
39562: PPUSH
39563: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
39567: LD_ADDR_VAR 0 6
39571: PUSH
39572: LD_VAR 0 7
39576: PPUSH
39577: LD_VAR 0 3
39581: PPUSH
39582: CALL_OW 74
39586: ST_TO_ADDR
// if not ape then
39587: LD_VAR 0 6
39591: NOT
39592: IFFALSE 39596
// break ;
39594: GO 39706
// x := GetX ( ape ) ;
39596: LD_ADDR_VAR 0 4
39600: PUSH
39601: LD_VAR 0 6
39605: PPUSH
39606: CALL_OW 250
39610: ST_TO_ADDR
// y := GetY ( ape ) ;
39611: LD_ADDR_VAR 0 5
39615: PUSH
39616: LD_VAR 0 6
39620: PPUSH
39621: CALL_OW 251
39625: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
39626: LD_VAR 0 4
39630: PPUSH
39631: LD_VAR 0 5
39635: PPUSH
39636: CALL_OW 488
39640: NOT
39641: PUSH
39642: LD_VAR 0 11
39646: PPUSH
39647: LD_VAR 0 4
39651: PPUSH
39652: LD_VAR 0 5
39656: PPUSH
39657: LD_INT 20
39659: PPUSH
39660: CALL 56597 0 4
39664: PUSH
39665: LD_INT 4
39667: ARRAY
39668: OR
39669: IFFALSE 39673
// break ;
39671: GO 39706
// if not HasTask ( j ) then
39673: LD_VAR 0 3
39677: PPUSH
39678: CALL_OW 314
39682: NOT
39683: IFFALSE 39704
// ComTameXY ( j , x , y ) ;
39685: LD_VAR 0 3
39689: PPUSH
39690: LD_VAR 0 4
39694: PPUSH
39695: LD_VAR 0 5
39699: PPUSH
39700: CALL_OW 131
// end ; end ;
39704: GO 39369
39706: POP
39707: POP
// end ;
39708: GO 38925
39710: POP
39711: POP
// end ;
39712: LD_VAR 0 1
39716: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
39717: LD_INT 0
39719: PPUSH
39720: PPUSH
39721: PPUSH
39722: PPUSH
39723: PPUSH
39724: PPUSH
39725: PPUSH
39726: PPUSH
// if not mc_bases then
39727: LD_EXP 90
39731: NOT
39732: IFFALSE 39736
// exit ;
39734: GO 40362
// for i = 1 to mc_bases do
39736: LD_ADDR_VAR 0 2
39740: PUSH
39741: DOUBLE
39742: LD_INT 1
39744: DEC
39745: ST_TO_ADDR
39746: LD_EXP 90
39750: PUSH
39751: FOR_TO
39752: IFFALSE 40360
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
39754: LD_EXP 119
39758: PUSH
39759: LD_VAR 0 2
39763: ARRAY
39764: NOT
39765: PUSH
39766: LD_EXP 119
39770: PUSH
39771: LD_VAR 0 2
39775: ARRAY
39776: PPUSH
39777: LD_INT 25
39779: PUSH
39780: LD_INT 12
39782: PUSH
39783: EMPTY
39784: LIST
39785: LIST
39786: PPUSH
39787: CALL_OW 72
39791: NOT
39792: OR
39793: IFFALSE 39797
// continue ;
39795: GO 39751
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
39797: LD_ADDR_VAR 0 5
39801: PUSH
39802: LD_EXP 119
39806: PUSH
39807: LD_VAR 0 2
39811: ARRAY
39812: PUSH
39813: LD_INT 1
39815: ARRAY
39816: PPUSH
39817: CALL_OW 255
39821: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
39822: LD_VAR 0 5
39826: PPUSH
39827: LD_INT 2
39829: PPUSH
39830: CALL_OW 325
39834: IFFALSE 40087
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
39836: LD_ADDR_VAR 0 4
39840: PUSH
39841: LD_EXP 119
39845: PUSH
39846: LD_VAR 0 2
39850: ARRAY
39851: PPUSH
39852: LD_INT 25
39854: PUSH
39855: LD_INT 16
39857: PUSH
39858: EMPTY
39859: LIST
39860: LIST
39861: PPUSH
39862: CALL_OW 72
39866: ST_TO_ADDR
// if tmp < 6 then
39867: LD_VAR 0 4
39871: PUSH
39872: LD_INT 6
39874: LESS
39875: IFFALSE 40087
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39877: LD_ADDR_VAR 0 6
39881: PUSH
39882: LD_EXP 90
39886: PUSH
39887: LD_VAR 0 2
39891: ARRAY
39892: PPUSH
39893: LD_INT 2
39895: PUSH
39896: LD_INT 30
39898: PUSH
39899: LD_INT 0
39901: PUSH
39902: EMPTY
39903: LIST
39904: LIST
39905: PUSH
39906: LD_INT 30
39908: PUSH
39909: LD_INT 1
39911: PUSH
39912: EMPTY
39913: LIST
39914: LIST
39915: PUSH
39916: EMPTY
39917: LIST
39918: LIST
39919: LIST
39920: PPUSH
39921: CALL_OW 72
39925: ST_TO_ADDR
// if depot then
39926: LD_VAR 0 6
39930: IFFALSE 40087
// begin selected := 0 ;
39932: LD_ADDR_VAR 0 7
39936: PUSH
39937: LD_INT 0
39939: ST_TO_ADDR
// for j in depot do
39940: LD_ADDR_VAR 0 3
39944: PUSH
39945: LD_VAR 0 6
39949: PUSH
39950: FOR_IN
39951: IFFALSE 39982
// begin if UnitsInside ( j ) < 6 then
39953: LD_VAR 0 3
39957: PPUSH
39958: CALL_OW 313
39962: PUSH
39963: LD_INT 6
39965: LESS
39966: IFFALSE 39980
// begin selected := j ;
39968: LD_ADDR_VAR 0 7
39972: PUSH
39973: LD_VAR 0 3
39977: ST_TO_ADDR
// break ;
39978: GO 39982
// end ; end ;
39980: GO 39950
39982: POP
39983: POP
// if selected then
39984: LD_VAR 0 7
39988: IFFALSE 40087
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
39990: LD_ADDR_VAR 0 3
39994: PUSH
39995: LD_EXP 119
39999: PUSH
40000: LD_VAR 0 2
40004: ARRAY
40005: PPUSH
40006: LD_INT 25
40008: PUSH
40009: LD_INT 12
40011: PUSH
40012: EMPTY
40013: LIST
40014: LIST
40015: PPUSH
40016: CALL_OW 72
40020: PUSH
40021: FOR_IN
40022: IFFALSE 40085
// if not HasTask ( j ) then
40024: LD_VAR 0 3
40028: PPUSH
40029: CALL_OW 314
40033: NOT
40034: IFFALSE 40083
// begin if not IsInUnit ( j ) then
40036: LD_VAR 0 3
40040: PPUSH
40041: CALL_OW 310
40045: NOT
40046: IFFALSE 40062
// ComEnterUnit ( j , selected ) ;
40048: LD_VAR 0 3
40052: PPUSH
40053: LD_VAR 0 7
40057: PPUSH
40058: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
40062: LD_VAR 0 3
40066: PPUSH
40067: LD_INT 16
40069: PPUSH
40070: CALL_OW 183
// AddComExitBuilding ( j ) ;
40074: LD_VAR 0 3
40078: PPUSH
40079: CALL_OW 182
// end ;
40083: GO 40021
40085: POP
40086: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
40087: LD_VAR 0 5
40091: PPUSH
40092: LD_INT 11
40094: PPUSH
40095: CALL_OW 325
40099: IFFALSE 40358
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
40101: LD_ADDR_VAR 0 4
40105: PUSH
40106: LD_EXP 119
40110: PUSH
40111: LD_VAR 0 2
40115: ARRAY
40116: PPUSH
40117: LD_INT 25
40119: PUSH
40120: LD_INT 16
40122: PUSH
40123: EMPTY
40124: LIST
40125: LIST
40126: PPUSH
40127: CALL_OW 72
40131: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
40132: LD_VAR 0 4
40136: PUSH
40137: LD_INT 6
40139: GREATEREQUAL
40140: PUSH
40141: LD_VAR 0 5
40145: PPUSH
40146: LD_INT 2
40148: PPUSH
40149: CALL_OW 325
40153: NOT
40154: OR
40155: IFFALSE 40358
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
40157: LD_ADDR_VAR 0 8
40161: PUSH
40162: LD_EXP 90
40166: PUSH
40167: LD_VAR 0 2
40171: ARRAY
40172: PPUSH
40173: LD_INT 2
40175: PUSH
40176: LD_INT 30
40178: PUSH
40179: LD_INT 4
40181: PUSH
40182: EMPTY
40183: LIST
40184: LIST
40185: PUSH
40186: LD_INT 30
40188: PUSH
40189: LD_INT 5
40191: PUSH
40192: EMPTY
40193: LIST
40194: LIST
40195: PUSH
40196: EMPTY
40197: LIST
40198: LIST
40199: LIST
40200: PPUSH
40201: CALL_OW 72
40205: ST_TO_ADDR
// if barracks then
40206: LD_VAR 0 8
40210: IFFALSE 40358
// begin selected := 0 ;
40212: LD_ADDR_VAR 0 7
40216: PUSH
40217: LD_INT 0
40219: ST_TO_ADDR
// for j in barracks do
40220: LD_ADDR_VAR 0 3
40224: PUSH
40225: LD_VAR 0 8
40229: PUSH
40230: FOR_IN
40231: IFFALSE 40262
// begin if UnitsInside ( j ) < 6 then
40233: LD_VAR 0 3
40237: PPUSH
40238: CALL_OW 313
40242: PUSH
40243: LD_INT 6
40245: LESS
40246: IFFALSE 40260
// begin selected := j ;
40248: LD_ADDR_VAR 0 7
40252: PUSH
40253: LD_VAR 0 3
40257: ST_TO_ADDR
// break ;
40258: GO 40262
// end ; end ;
40260: GO 40230
40262: POP
40263: POP
// if selected then
40264: LD_VAR 0 7
40268: IFFALSE 40358
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
40270: LD_ADDR_VAR 0 3
40274: PUSH
40275: LD_EXP 119
40279: PUSH
40280: LD_VAR 0 2
40284: ARRAY
40285: PPUSH
40286: LD_INT 25
40288: PUSH
40289: LD_INT 12
40291: PUSH
40292: EMPTY
40293: LIST
40294: LIST
40295: PPUSH
40296: CALL_OW 72
40300: PUSH
40301: FOR_IN
40302: IFFALSE 40356
// if not IsInUnit ( j ) and not HasTask ( j ) then
40304: LD_VAR 0 3
40308: PPUSH
40309: CALL_OW 310
40313: NOT
40314: PUSH
40315: LD_VAR 0 3
40319: PPUSH
40320: CALL_OW 314
40324: NOT
40325: AND
40326: IFFALSE 40354
// begin ComEnterUnit ( j , selected ) ;
40328: LD_VAR 0 3
40332: PPUSH
40333: LD_VAR 0 7
40337: PPUSH
40338: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
40342: LD_VAR 0 3
40346: PPUSH
40347: LD_INT 15
40349: PPUSH
40350: CALL_OW 183
// end ;
40354: GO 40301
40356: POP
40357: POP
// end ; end ; end ; end ; end ;
40358: GO 39751
40360: POP
40361: POP
// end ;
40362: LD_VAR 0 1
40366: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
40367: LD_INT 0
40369: PPUSH
40370: PPUSH
40371: PPUSH
40372: PPUSH
// if not mc_bases then
40373: LD_EXP 90
40377: NOT
40378: IFFALSE 40382
// exit ;
40380: GO 40560
// for i = 1 to mc_bases do
40382: LD_ADDR_VAR 0 2
40386: PUSH
40387: DOUBLE
40388: LD_INT 1
40390: DEC
40391: ST_TO_ADDR
40392: LD_EXP 90
40396: PUSH
40397: FOR_TO
40398: IFFALSE 40558
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
40400: LD_ADDR_VAR 0 4
40404: PUSH
40405: LD_EXP 90
40409: PUSH
40410: LD_VAR 0 2
40414: ARRAY
40415: PPUSH
40416: LD_INT 25
40418: PUSH
40419: LD_INT 9
40421: PUSH
40422: EMPTY
40423: LIST
40424: LIST
40425: PPUSH
40426: CALL_OW 72
40430: ST_TO_ADDR
// if not tmp then
40431: LD_VAR 0 4
40435: NOT
40436: IFFALSE 40440
// continue ;
40438: GO 40397
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
40440: LD_EXP 116
40444: PUSH
40445: LD_VAR 0 2
40449: ARRAY
40450: PPUSH
40451: LD_INT 29
40453: PPUSH
40454: CALL_OW 325
40458: NOT
40459: PUSH
40460: LD_EXP 116
40464: PUSH
40465: LD_VAR 0 2
40469: ARRAY
40470: PPUSH
40471: LD_INT 28
40473: PPUSH
40474: CALL_OW 325
40478: NOT
40479: AND
40480: IFFALSE 40484
// continue ;
40482: GO 40397
// for j in tmp do
40484: LD_ADDR_VAR 0 3
40488: PUSH
40489: LD_VAR 0 4
40493: PUSH
40494: FOR_IN
40495: IFFALSE 40554
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
40497: LD_VAR 0 3
40501: PUSH
40502: LD_EXP 93
40506: PUSH
40507: LD_VAR 0 2
40511: ARRAY
40512: PUSH
40513: LD_INT 1
40515: ARRAY
40516: IN
40517: NOT
40518: PUSH
40519: LD_VAR 0 3
40523: PUSH
40524: LD_EXP 93
40528: PUSH
40529: LD_VAR 0 2
40533: ARRAY
40534: PUSH
40535: LD_INT 2
40537: ARRAY
40538: IN
40539: NOT
40540: AND
40541: IFFALSE 40552
// ComSpaceTimeShoot ( j ) ;
40543: LD_VAR 0 3
40547: PPUSH
40548: CALL 51698 0 1
40552: GO 40494
40554: POP
40555: POP
// end ;
40556: GO 40397
40558: POP
40559: POP
// end ;
40560: LD_VAR 0 1
40564: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
40565: LD_INT 0
40567: PPUSH
40568: PPUSH
40569: PPUSH
40570: PPUSH
40571: PPUSH
40572: PPUSH
40573: PPUSH
40574: PPUSH
40575: PPUSH
// if not mc_bases then
40576: LD_EXP 90
40580: NOT
40581: IFFALSE 40585
// exit ;
40583: GO 41207
// for i = 1 to mc_bases do
40585: LD_ADDR_VAR 0 2
40589: PUSH
40590: DOUBLE
40591: LD_INT 1
40593: DEC
40594: ST_TO_ADDR
40595: LD_EXP 90
40599: PUSH
40600: FOR_TO
40601: IFFALSE 41205
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
40603: LD_EXP 125
40607: PUSH
40608: LD_VAR 0 2
40612: ARRAY
40613: NOT
40614: PUSH
40615: LD_INT 38
40617: PPUSH
40618: LD_EXP 116
40622: PUSH
40623: LD_VAR 0 2
40627: ARRAY
40628: PPUSH
40629: CALL_OW 321
40633: PUSH
40634: LD_INT 2
40636: NONEQUAL
40637: OR
40638: IFFALSE 40642
// continue ;
40640: GO 40600
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
40642: LD_ADDR_VAR 0 8
40646: PUSH
40647: LD_EXP 90
40651: PUSH
40652: LD_VAR 0 2
40656: ARRAY
40657: PPUSH
40658: LD_INT 30
40660: PUSH
40661: LD_INT 34
40663: PUSH
40664: EMPTY
40665: LIST
40666: LIST
40667: PPUSH
40668: CALL_OW 72
40672: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
40673: LD_ADDR_VAR 0 9
40677: PUSH
40678: LD_EXP 90
40682: PUSH
40683: LD_VAR 0 2
40687: ARRAY
40688: PPUSH
40689: LD_INT 25
40691: PUSH
40692: LD_INT 4
40694: PUSH
40695: EMPTY
40696: LIST
40697: LIST
40698: PPUSH
40699: CALL_OW 72
40703: PPUSH
40704: LD_INT 0
40706: PPUSH
40707: CALL 84262 0 2
40711: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
40712: LD_VAR 0 9
40716: NOT
40717: PUSH
40718: LD_VAR 0 8
40722: NOT
40723: OR
40724: PUSH
40725: LD_EXP 90
40729: PUSH
40730: LD_VAR 0 2
40734: ARRAY
40735: PPUSH
40736: LD_INT 124
40738: PPUSH
40739: CALL 84262 0 2
40743: OR
40744: IFFALSE 40748
// continue ;
40746: GO 40600
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
40748: LD_EXP 126
40752: PUSH
40753: LD_VAR 0 2
40757: ARRAY
40758: PUSH
40759: LD_EXP 125
40763: PUSH
40764: LD_VAR 0 2
40768: ARRAY
40769: LESS
40770: PUSH
40771: LD_EXP 126
40775: PUSH
40776: LD_VAR 0 2
40780: ARRAY
40781: PUSH
40782: LD_VAR 0 8
40786: LESS
40787: AND
40788: IFFALSE 41203
// begin tmp := sci [ 1 ] ;
40790: LD_ADDR_VAR 0 7
40794: PUSH
40795: LD_VAR 0 9
40799: PUSH
40800: LD_INT 1
40802: ARRAY
40803: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
40804: LD_VAR 0 7
40808: PPUSH
40809: LD_INT 124
40811: PPUSH
40812: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
40816: LD_ADDR_VAR 0 3
40820: PUSH
40821: DOUBLE
40822: LD_EXP 125
40826: PUSH
40827: LD_VAR 0 2
40831: ARRAY
40832: INC
40833: ST_TO_ADDR
40834: LD_EXP 125
40838: PUSH
40839: LD_VAR 0 2
40843: ARRAY
40844: PUSH
40845: FOR_DOWNTO
40846: IFFALSE 41189
// begin if IsInUnit ( tmp ) then
40848: LD_VAR 0 7
40852: PPUSH
40853: CALL_OW 310
40857: IFFALSE 40868
// ComExitBuilding ( tmp ) ;
40859: LD_VAR 0 7
40863: PPUSH
40864: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
40868: LD_INT 35
40870: PPUSH
40871: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
40875: LD_VAR 0 7
40879: PPUSH
40880: CALL_OW 310
40884: NOT
40885: PUSH
40886: LD_VAR 0 7
40890: PPUSH
40891: CALL_OW 314
40895: NOT
40896: AND
40897: IFFALSE 40868
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
40899: LD_ADDR_VAR 0 6
40903: PUSH
40904: LD_VAR 0 7
40908: PPUSH
40909: CALL_OW 250
40913: PUSH
40914: LD_VAR 0 7
40918: PPUSH
40919: CALL_OW 251
40923: PUSH
40924: EMPTY
40925: LIST
40926: LIST
40927: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
40928: LD_INT 35
40930: PPUSH
40931: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
40935: LD_ADDR_VAR 0 4
40939: PUSH
40940: LD_EXP 125
40944: PUSH
40945: LD_VAR 0 2
40949: ARRAY
40950: PUSH
40951: LD_VAR 0 3
40955: ARRAY
40956: PUSH
40957: LD_INT 1
40959: ARRAY
40960: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
40961: LD_ADDR_VAR 0 5
40965: PUSH
40966: LD_EXP 125
40970: PUSH
40971: LD_VAR 0 2
40975: ARRAY
40976: PUSH
40977: LD_VAR 0 3
40981: ARRAY
40982: PUSH
40983: LD_INT 2
40985: ARRAY
40986: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
40987: LD_VAR 0 7
40991: PPUSH
40992: LD_INT 10
40994: PPUSH
40995: CALL 58294 0 2
40999: PUSH
41000: LD_INT 4
41002: ARRAY
41003: IFFALSE 41041
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
41005: LD_VAR 0 7
41009: PPUSH
41010: LD_VAR 0 6
41014: PUSH
41015: LD_INT 1
41017: ARRAY
41018: PPUSH
41019: LD_VAR 0 6
41023: PUSH
41024: LD_INT 2
41026: ARRAY
41027: PPUSH
41028: CALL_OW 111
// wait ( 0 0$10 ) ;
41032: LD_INT 350
41034: PPUSH
41035: CALL_OW 67
// end else
41039: GO 41067
// begin ComMoveXY ( tmp , x , y ) ;
41041: LD_VAR 0 7
41045: PPUSH
41046: LD_VAR 0 4
41050: PPUSH
41051: LD_VAR 0 5
41055: PPUSH
41056: CALL_OW 111
// wait ( 0 0$3 ) ;
41060: LD_INT 105
41062: PPUSH
41063: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
41067: LD_VAR 0 7
41071: PPUSH
41072: LD_VAR 0 4
41076: PPUSH
41077: LD_VAR 0 5
41081: PPUSH
41082: CALL_OW 307
41086: IFFALSE 40928
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
41088: LD_VAR 0 7
41092: PPUSH
41093: LD_VAR 0 4
41097: PPUSH
41098: LD_VAR 0 5
41102: PPUSH
41103: LD_VAR 0 8
41107: PUSH
41108: LD_VAR 0 3
41112: ARRAY
41113: PPUSH
41114: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
41118: LD_INT 35
41120: PPUSH
41121: CALL_OW 67
// until not HasTask ( tmp ) ;
41125: LD_VAR 0 7
41129: PPUSH
41130: CALL_OW 314
41134: NOT
41135: IFFALSE 41118
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
41137: LD_ADDR_EXP 126
41141: PUSH
41142: LD_EXP 126
41146: PPUSH
41147: LD_VAR 0 2
41151: PUSH
41152: LD_EXP 126
41156: PUSH
41157: LD_VAR 0 2
41161: ARRAY
41162: PUSH
41163: LD_INT 1
41165: PLUS
41166: PUSH
41167: EMPTY
41168: LIST
41169: LIST
41170: PPUSH
41171: LD_VAR 0 8
41175: PUSH
41176: LD_VAR 0 3
41180: ARRAY
41181: PPUSH
41182: CALL 55701 0 3
41186: ST_TO_ADDR
// end ;
41187: GO 40845
41189: POP
41190: POP
// MC_Reset ( i , 124 ) ;
41191: LD_VAR 0 2
41195: PPUSH
41196: LD_INT 124
41198: PPUSH
41199: CALL 24810 0 2
// end ; end ;
41203: GO 40600
41205: POP
41206: POP
// end ;
41207: LD_VAR 0 1
41211: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
41212: LD_INT 0
41214: PPUSH
41215: PPUSH
41216: PPUSH
// if not mc_bases then
41217: LD_EXP 90
41221: NOT
41222: IFFALSE 41226
// exit ;
41224: GO 41832
// for i = 1 to mc_bases do
41226: LD_ADDR_VAR 0 2
41230: PUSH
41231: DOUBLE
41232: LD_INT 1
41234: DEC
41235: ST_TO_ADDR
41236: LD_EXP 90
41240: PUSH
41241: FOR_TO
41242: IFFALSE 41830
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
41244: LD_ADDR_VAR 0 3
41248: PUSH
41249: LD_EXP 90
41253: PUSH
41254: LD_VAR 0 2
41258: ARRAY
41259: PPUSH
41260: LD_INT 25
41262: PUSH
41263: LD_INT 4
41265: PUSH
41266: EMPTY
41267: LIST
41268: LIST
41269: PPUSH
41270: CALL_OW 72
41274: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
41275: LD_VAR 0 3
41279: NOT
41280: PUSH
41281: LD_EXP 127
41285: PUSH
41286: LD_VAR 0 2
41290: ARRAY
41291: NOT
41292: OR
41293: PUSH
41294: LD_EXP 90
41298: PUSH
41299: LD_VAR 0 2
41303: ARRAY
41304: PPUSH
41305: LD_INT 2
41307: PUSH
41308: LD_INT 30
41310: PUSH
41311: LD_INT 0
41313: PUSH
41314: EMPTY
41315: LIST
41316: LIST
41317: PUSH
41318: LD_INT 30
41320: PUSH
41321: LD_INT 1
41323: PUSH
41324: EMPTY
41325: LIST
41326: LIST
41327: PUSH
41328: EMPTY
41329: LIST
41330: LIST
41331: LIST
41332: PPUSH
41333: CALL_OW 72
41337: NOT
41338: OR
41339: IFFALSE 41389
// begin if mc_deposits_finder [ i ] then
41341: LD_EXP 128
41345: PUSH
41346: LD_VAR 0 2
41350: ARRAY
41351: IFFALSE 41387
// begin MC_Reset ( i , 125 ) ;
41353: LD_VAR 0 2
41357: PPUSH
41358: LD_INT 125
41360: PPUSH
41361: CALL 24810 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41365: LD_ADDR_EXP 128
41369: PUSH
41370: LD_EXP 128
41374: PPUSH
41375: LD_VAR 0 2
41379: PPUSH
41380: EMPTY
41381: PPUSH
41382: CALL_OW 1
41386: ST_TO_ADDR
// end ; continue ;
41387: GO 41241
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
41389: LD_EXP 127
41393: PUSH
41394: LD_VAR 0 2
41398: ARRAY
41399: PUSH
41400: LD_INT 1
41402: ARRAY
41403: PUSH
41404: LD_INT 3
41406: ARRAY
41407: PUSH
41408: LD_INT 1
41410: EQUAL
41411: PUSH
41412: LD_INT 20
41414: PPUSH
41415: LD_EXP 116
41419: PUSH
41420: LD_VAR 0 2
41424: ARRAY
41425: PPUSH
41426: CALL_OW 321
41430: PUSH
41431: LD_INT 2
41433: NONEQUAL
41434: AND
41435: IFFALSE 41485
// begin if mc_deposits_finder [ i ] then
41437: LD_EXP 128
41441: PUSH
41442: LD_VAR 0 2
41446: ARRAY
41447: IFFALSE 41483
// begin MC_Reset ( i , 125 ) ;
41449: LD_VAR 0 2
41453: PPUSH
41454: LD_INT 125
41456: PPUSH
41457: CALL 24810 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41461: LD_ADDR_EXP 128
41465: PUSH
41466: LD_EXP 128
41470: PPUSH
41471: LD_VAR 0 2
41475: PPUSH
41476: EMPTY
41477: PPUSH
41478: CALL_OW 1
41482: ST_TO_ADDR
// end ; continue ;
41483: GO 41241
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
41485: LD_EXP 127
41489: PUSH
41490: LD_VAR 0 2
41494: ARRAY
41495: PUSH
41496: LD_INT 1
41498: ARRAY
41499: PUSH
41500: LD_INT 1
41502: ARRAY
41503: PPUSH
41504: LD_EXP 127
41508: PUSH
41509: LD_VAR 0 2
41513: ARRAY
41514: PUSH
41515: LD_INT 1
41517: ARRAY
41518: PUSH
41519: LD_INT 2
41521: ARRAY
41522: PPUSH
41523: LD_EXP 116
41527: PUSH
41528: LD_VAR 0 2
41532: ARRAY
41533: PPUSH
41534: CALL_OW 440
41538: IFFALSE 41581
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
41540: LD_ADDR_EXP 127
41544: PUSH
41545: LD_EXP 127
41549: PPUSH
41550: LD_VAR 0 2
41554: PPUSH
41555: LD_EXP 127
41559: PUSH
41560: LD_VAR 0 2
41564: ARRAY
41565: PPUSH
41566: LD_INT 1
41568: PPUSH
41569: CALL_OW 3
41573: PPUSH
41574: CALL_OW 1
41578: ST_TO_ADDR
41579: GO 41828
// begin if not mc_deposits_finder [ i ] then
41581: LD_EXP 128
41585: PUSH
41586: LD_VAR 0 2
41590: ARRAY
41591: NOT
41592: IFFALSE 41644
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
41594: LD_ADDR_EXP 128
41598: PUSH
41599: LD_EXP 128
41603: PPUSH
41604: LD_VAR 0 2
41608: PPUSH
41609: LD_VAR 0 3
41613: PUSH
41614: LD_INT 1
41616: ARRAY
41617: PUSH
41618: EMPTY
41619: LIST
41620: PPUSH
41621: CALL_OW 1
41625: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
41626: LD_VAR 0 3
41630: PUSH
41631: LD_INT 1
41633: ARRAY
41634: PPUSH
41635: LD_INT 125
41637: PPUSH
41638: CALL_OW 109
// end else
41642: GO 41828
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
41644: LD_EXP 128
41648: PUSH
41649: LD_VAR 0 2
41653: ARRAY
41654: PUSH
41655: LD_INT 1
41657: ARRAY
41658: PPUSH
41659: CALL_OW 310
41663: IFFALSE 41686
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
41665: LD_EXP 128
41669: PUSH
41670: LD_VAR 0 2
41674: ARRAY
41675: PUSH
41676: LD_INT 1
41678: ARRAY
41679: PPUSH
41680: CALL_OW 122
41684: GO 41828
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
41686: LD_EXP 128
41690: PUSH
41691: LD_VAR 0 2
41695: ARRAY
41696: PUSH
41697: LD_INT 1
41699: ARRAY
41700: PPUSH
41701: CALL_OW 314
41705: NOT
41706: PUSH
41707: LD_EXP 128
41711: PUSH
41712: LD_VAR 0 2
41716: ARRAY
41717: PUSH
41718: LD_INT 1
41720: ARRAY
41721: PPUSH
41722: LD_EXP 127
41726: PUSH
41727: LD_VAR 0 2
41731: ARRAY
41732: PUSH
41733: LD_INT 1
41735: ARRAY
41736: PUSH
41737: LD_INT 1
41739: ARRAY
41740: PPUSH
41741: LD_EXP 127
41745: PUSH
41746: LD_VAR 0 2
41750: ARRAY
41751: PUSH
41752: LD_INT 1
41754: ARRAY
41755: PUSH
41756: LD_INT 2
41758: ARRAY
41759: PPUSH
41760: CALL_OW 297
41764: PUSH
41765: LD_INT 6
41767: GREATER
41768: AND
41769: IFFALSE 41828
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
41771: LD_EXP 128
41775: PUSH
41776: LD_VAR 0 2
41780: ARRAY
41781: PUSH
41782: LD_INT 1
41784: ARRAY
41785: PPUSH
41786: LD_EXP 127
41790: PUSH
41791: LD_VAR 0 2
41795: ARRAY
41796: PUSH
41797: LD_INT 1
41799: ARRAY
41800: PUSH
41801: LD_INT 1
41803: ARRAY
41804: PPUSH
41805: LD_EXP 127
41809: PUSH
41810: LD_VAR 0 2
41814: ARRAY
41815: PUSH
41816: LD_INT 1
41818: ARRAY
41819: PUSH
41820: LD_INT 2
41822: ARRAY
41823: PPUSH
41824: CALL_OW 111
// end ; end ; end ;
41828: GO 41241
41830: POP
41831: POP
// end ;
41832: LD_VAR 0 1
41836: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
41837: LD_INT 0
41839: PPUSH
41840: PPUSH
41841: PPUSH
41842: PPUSH
41843: PPUSH
41844: PPUSH
41845: PPUSH
41846: PPUSH
41847: PPUSH
41848: PPUSH
41849: PPUSH
// if not mc_bases then
41850: LD_EXP 90
41854: NOT
41855: IFFALSE 41859
// exit ;
41857: GO 42799
// for i = 1 to mc_bases do
41859: LD_ADDR_VAR 0 2
41863: PUSH
41864: DOUBLE
41865: LD_INT 1
41867: DEC
41868: ST_TO_ADDR
41869: LD_EXP 90
41873: PUSH
41874: FOR_TO
41875: IFFALSE 42797
// begin if not mc_bases [ i ] or mc_scan [ i ] then
41877: LD_EXP 90
41881: PUSH
41882: LD_VAR 0 2
41886: ARRAY
41887: NOT
41888: PUSH
41889: LD_EXP 113
41893: PUSH
41894: LD_VAR 0 2
41898: ARRAY
41899: OR
41900: IFFALSE 41904
// continue ;
41902: GO 41874
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
41904: LD_ADDR_VAR 0 7
41908: PUSH
41909: LD_EXP 90
41913: PUSH
41914: LD_VAR 0 2
41918: ARRAY
41919: PUSH
41920: LD_INT 1
41922: ARRAY
41923: PPUSH
41924: CALL_OW 248
41928: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
41929: LD_VAR 0 7
41933: PUSH
41934: LD_INT 3
41936: EQUAL
41937: PUSH
41938: LD_EXP 109
41942: PUSH
41943: LD_VAR 0 2
41947: ARRAY
41948: PUSH
41949: LD_EXP 112
41953: PUSH
41954: LD_VAR 0 2
41958: ARRAY
41959: UNION
41960: PPUSH
41961: LD_INT 33
41963: PUSH
41964: LD_INT 2
41966: PUSH
41967: EMPTY
41968: LIST
41969: LIST
41970: PPUSH
41971: CALL_OW 72
41975: NOT
41976: OR
41977: IFFALSE 41981
// continue ;
41979: GO 41874
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
41981: LD_ADDR_VAR 0 9
41985: PUSH
41986: LD_EXP 90
41990: PUSH
41991: LD_VAR 0 2
41995: ARRAY
41996: PPUSH
41997: LD_INT 30
41999: PUSH
42000: LD_INT 36
42002: PUSH
42003: EMPTY
42004: LIST
42005: LIST
42006: PPUSH
42007: CALL_OW 72
42011: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
42012: LD_ADDR_VAR 0 10
42016: PUSH
42017: LD_EXP 109
42021: PUSH
42022: LD_VAR 0 2
42026: ARRAY
42027: PPUSH
42028: LD_INT 34
42030: PUSH
42031: LD_INT 31
42033: PUSH
42034: EMPTY
42035: LIST
42036: LIST
42037: PPUSH
42038: CALL_OW 72
42042: ST_TO_ADDR
// if not cts and not mcts then
42043: LD_VAR 0 9
42047: NOT
42048: PUSH
42049: LD_VAR 0 10
42053: NOT
42054: AND
42055: IFFALSE 42059
// continue ;
42057: GO 41874
// x := cts ;
42059: LD_ADDR_VAR 0 11
42063: PUSH
42064: LD_VAR 0 9
42068: ST_TO_ADDR
// if not x then
42069: LD_VAR 0 11
42073: NOT
42074: IFFALSE 42086
// x := mcts ;
42076: LD_ADDR_VAR 0 11
42080: PUSH
42081: LD_VAR 0 10
42085: ST_TO_ADDR
// if not x then
42086: LD_VAR 0 11
42090: NOT
42091: IFFALSE 42095
// continue ;
42093: GO 41874
// if mc_remote_driver [ i ] then
42095: LD_EXP 130
42099: PUSH
42100: LD_VAR 0 2
42104: ARRAY
42105: IFFALSE 42492
// for j in mc_remote_driver [ i ] do
42107: LD_ADDR_VAR 0 3
42111: PUSH
42112: LD_EXP 130
42116: PUSH
42117: LD_VAR 0 2
42121: ARRAY
42122: PUSH
42123: FOR_IN
42124: IFFALSE 42490
// begin if GetClass ( j ) <> 3 then
42126: LD_VAR 0 3
42130: PPUSH
42131: CALL_OW 257
42135: PUSH
42136: LD_INT 3
42138: NONEQUAL
42139: IFFALSE 42192
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
42141: LD_ADDR_EXP 130
42145: PUSH
42146: LD_EXP 130
42150: PPUSH
42151: LD_VAR 0 2
42155: PPUSH
42156: LD_EXP 130
42160: PUSH
42161: LD_VAR 0 2
42165: ARRAY
42166: PUSH
42167: LD_VAR 0 3
42171: DIFF
42172: PPUSH
42173: CALL_OW 1
42177: ST_TO_ADDR
// SetTag ( j , 0 ) ;
42178: LD_VAR 0 3
42182: PPUSH
42183: LD_INT 0
42185: PPUSH
42186: CALL_OW 109
// continue ;
42190: GO 42123
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
42192: LD_EXP 109
42196: PUSH
42197: LD_VAR 0 2
42201: ARRAY
42202: PPUSH
42203: LD_INT 34
42205: PUSH
42206: LD_INT 31
42208: PUSH
42209: EMPTY
42210: LIST
42211: LIST
42212: PUSH
42213: LD_INT 58
42215: PUSH
42216: EMPTY
42217: LIST
42218: PUSH
42219: EMPTY
42220: LIST
42221: LIST
42222: PPUSH
42223: CALL_OW 72
42227: PUSH
42228: LD_VAR 0 3
42232: PPUSH
42233: CALL 84350 0 1
42237: NOT
42238: AND
42239: IFFALSE 42310
// begin if IsInUnit ( j ) then
42241: LD_VAR 0 3
42245: PPUSH
42246: CALL_OW 310
42250: IFFALSE 42261
// ComExitBuilding ( j ) ;
42252: LD_VAR 0 3
42256: PPUSH
42257: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
42261: LD_VAR 0 3
42265: PPUSH
42266: LD_EXP 109
42270: PUSH
42271: LD_VAR 0 2
42275: ARRAY
42276: PPUSH
42277: LD_INT 34
42279: PUSH
42280: LD_INT 31
42282: PUSH
42283: EMPTY
42284: LIST
42285: LIST
42286: PUSH
42287: LD_INT 58
42289: PUSH
42290: EMPTY
42291: LIST
42292: PUSH
42293: EMPTY
42294: LIST
42295: LIST
42296: PPUSH
42297: CALL_OW 72
42301: PUSH
42302: LD_INT 1
42304: ARRAY
42305: PPUSH
42306: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
42310: LD_VAR 0 3
42314: PPUSH
42315: CALL_OW 310
42319: NOT
42320: PUSH
42321: LD_VAR 0 3
42325: PPUSH
42326: CALL_OW 310
42330: PPUSH
42331: CALL_OW 266
42335: PUSH
42336: LD_INT 36
42338: NONEQUAL
42339: PUSH
42340: LD_VAR 0 3
42344: PPUSH
42345: CALL 84350 0 1
42349: NOT
42350: AND
42351: OR
42352: IFFALSE 42488
// begin if IsInUnit ( j ) then
42354: LD_VAR 0 3
42358: PPUSH
42359: CALL_OW 310
42363: IFFALSE 42374
// ComExitBuilding ( j ) ;
42365: LD_VAR 0 3
42369: PPUSH
42370: CALL_OW 122
// ct := 0 ;
42374: LD_ADDR_VAR 0 8
42378: PUSH
42379: LD_INT 0
42381: ST_TO_ADDR
// for k in x do
42382: LD_ADDR_VAR 0 4
42386: PUSH
42387: LD_VAR 0 11
42391: PUSH
42392: FOR_IN
42393: IFFALSE 42466
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
42395: LD_VAR 0 4
42399: PPUSH
42400: CALL_OW 264
42404: PUSH
42405: LD_INT 31
42407: EQUAL
42408: PUSH
42409: LD_VAR 0 4
42413: PPUSH
42414: CALL_OW 311
42418: NOT
42419: AND
42420: PUSH
42421: LD_VAR 0 4
42425: PPUSH
42426: CALL_OW 266
42430: PUSH
42431: LD_INT 36
42433: EQUAL
42434: PUSH
42435: LD_VAR 0 4
42439: PPUSH
42440: CALL_OW 313
42444: PUSH
42445: LD_INT 3
42447: LESS
42448: AND
42449: OR
42450: IFFALSE 42464
// begin ct := k ;
42452: LD_ADDR_VAR 0 8
42456: PUSH
42457: LD_VAR 0 4
42461: ST_TO_ADDR
// break ;
42462: GO 42466
// end ;
42464: GO 42392
42466: POP
42467: POP
// if ct then
42468: LD_VAR 0 8
42472: IFFALSE 42488
// ComEnterUnit ( j , ct ) ;
42474: LD_VAR 0 3
42478: PPUSH
42479: LD_VAR 0 8
42483: PPUSH
42484: CALL_OW 120
// end ; end ;
42488: GO 42123
42490: POP
42491: POP
// places := 0 ;
42492: LD_ADDR_VAR 0 5
42496: PUSH
42497: LD_INT 0
42499: ST_TO_ADDR
// for j = 1 to x do
42500: LD_ADDR_VAR 0 3
42504: PUSH
42505: DOUBLE
42506: LD_INT 1
42508: DEC
42509: ST_TO_ADDR
42510: LD_VAR 0 11
42514: PUSH
42515: FOR_TO
42516: IFFALSE 42592
// if GetWeapon ( x [ j ] ) = ar_control_tower then
42518: LD_VAR 0 11
42522: PUSH
42523: LD_VAR 0 3
42527: ARRAY
42528: PPUSH
42529: CALL_OW 264
42533: PUSH
42534: LD_INT 31
42536: EQUAL
42537: IFFALSE 42555
// places := places + 1 else
42539: LD_ADDR_VAR 0 5
42543: PUSH
42544: LD_VAR 0 5
42548: PUSH
42549: LD_INT 1
42551: PLUS
42552: ST_TO_ADDR
42553: GO 42590
// if GetBType ( x [ j ] ) = b_control_tower then
42555: LD_VAR 0 11
42559: PUSH
42560: LD_VAR 0 3
42564: ARRAY
42565: PPUSH
42566: CALL_OW 266
42570: PUSH
42571: LD_INT 36
42573: EQUAL
42574: IFFALSE 42590
// places := places + 3 ;
42576: LD_ADDR_VAR 0 5
42580: PUSH
42581: LD_VAR 0 5
42585: PUSH
42586: LD_INT 3
42588: PLUS
42589: ST_TO_ADDR
42590: GO 42515
42592: POP
42593: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
42594: LD_VAR 0 5
42598: PUSH
42599: LD_INT 0
42601: EQUAL
42602: PUSH
42603: LD_VAR 0 5
42607: PUSH
42608: LD_EXP 130
42612: PUSH
42613: LD_VAR 0 2
42617: ARRAY
42618: LESSEQUAL
42619: OR
42620: IFFALSE 42624
// continue ;
42622: GO 41874
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
42624: LD_ADDR_VAR 0 6
42628: PUSH
42629: LD_EXP 90
42633: PUSH
42634: LD_VAR 0 2
42638: ARRAY
42639: PPUSH
42640: LD_INT 25
42642: PUSH
42643: LD_INT 3
42645: PUSH
42646: EMPTY
42647: LIST
42648: LIST
42649: PPUSH
42650: CALL_OW 72
42654: PUSH
42655: LD_EXP 130
42659: PUSH
42660: LD_VAR 0 2
42664: ARRAY
42665: DIFF
42666: PPUSH
42667: LD_INT 3
42669: PPUSH
42670: CALL 85250 0 2
42674: ST_TO_ADDR
// for j in tmp do
42675: LD_ADDR_VAR 0 3
42679: PUSH
42680: LD_VAR 0 6
42684: PUSH
42685: FOR_IN
42686: IFFALSE 42721
// if GetTag ( j ) > 0 then
42688: LD_VAR 0 3
42692: PPUSH
42693: CALL_OW 110
42697: PUSH
42698: LD_INT 0
42700: GREATER
42701: IFFALSE 42719
// tmp := tmp diff j ;
42703: LD_ADDR_VAR 0 6
42707: PUSH
42708: LD_VAR 0 6
42712: PUSH
42713: LD_VAR 0 3
42717: DIFF
42718: ST_TO_ADDR
42719: GO 42685
42721: POP
42722: POP
// if not tmp then
42723: LD_VAR 0 6
42727: NOT
42728: IFFALSE 42732
// continue ;
42730: GO 41874
// if places then
42732: LD_VAR 0 5
42736: IFFALSE 42795
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
42738: LD_ADDR_EXP 130
42742: PUSH
42743: LD_EXP 130
42747: PPUSH
42748: LD_VAR 0 2
42752: PPUSH
42753: LD_EXP 130
42757: PUSH
42758: LD_VAR 0 2
42762: ARRAY
42763: PUSH
42764: LD_VAR 0 6
42768: PUSH
42769: LD_INT 1
42771: ARRAY
42772: UNION
42773: PPUSH
42774: CALL_OW 1
42778: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
42779: LD_VAR 0 6
42783: PUSH
42784: LD_INT 1
42786: ARRAY
42787: PPUSH
42788: LD_INT 126
42790: PPUSH
42791: CALL_OW 109
// end ; end ;
42795: GO 41874
42797: POP
42798: POP
// end ;
42799: LD_VAR 0 1
42803: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
42804: LD_INT 0
42806: PPUSH
42807: PPUSH
42808: PPUSH
42809: PPUSH
42810: PPUSH
42811: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
42812: LD_VAR 0 1
42816: NOT
42817: PUSH
42818: LD_VAR 0 2
42822: NOT
42823: OR
42824: PUSH
42825: LD_VAR 0 3
42829: NOT
42830: OR
42831: PUSH
42832: LD_VAR 0 4
42836: PUSH
42837: LD_INT 1
42839: PUSH
42840: LD_INT 2
42842: PUSH
42843: LD_INT 3
42845: PUSH
42846: LD_INT 4
42848: PUSH
42849: LD_INT 5
42851: PUSH
42852: LD_INT 8
42854: PUSH
42855: LD_INT 9
42857: PUSH
42858: LD_INT 15
42860: PUSH
42861: LD_INT 16
42863: PUSH
42864: EMPTY
42865: LIST
42866: LIST
42867: LIST
42868: LIST
42869: LIST
42870: LIST
42871: LIST
42872: LIST
42873: LIST
42874: IN
42875: NOT
42876: OR
42877: IFFALSE 42881
// exit ;
42879: GO 43781
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
42881: LD_ADDR_VAR 0 2
42885: PUSH
42886: LD_VAR 0 2
42890: PPUSH
42891: LD_INT 21
42893: PUSH
42894: LD_INT 3
42896: PUSH
42897: EMPTY
42898: LIST
42899: LIST
42900: PUSH
42901: LD_INT 24
42903: PUSH
42904: LD_INT 250
42906: PUSH
42907: EMPTY
42908: LIST
42909: LIST
42910: PUSH
42911: EMPTY
42912: LIST
42913: LIST
42914: PPUSH
42915: CALL_OW 72
42919: ST_TO_ADDR
// case class of 1 , 15 :
42920: LD_VAR 0 4
42924: PUSH
42925: LD_INT 1
42927: DOUBLE
42928: EQUAL
42929: IFTRUE 42939
42931: LD_INT 15
42933: DOUBLE
42934: EQUAL
42935: IFTRUE 42939
42937: GO 43024
42939: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
42940: LD_ADDR_VAR 0 8
42944: PUSH
42945: LD_VAR 0 2
42949: PPUSH
42950: LD_INT 2
42952: PUSH
42953: LD_INT 30
42955: PUSH
42956: LD_INT 32
42958: PUSH
42959: EMPTY
42960: LIST
42961: LIST
42962: PUSH
42963: LD_INT 30
42965: PUSH
42966: LD_INT 31
42968: PUSH
42969: EMPTY
42970: LIST
42971: LIST
42972: PUSH
42973: EMPTY
42974: LIST
42975: LIST
42976: LIST
42977: PPUSH
42978: CALL_OW 72
42982: PUSH
42983: LD_VAR 0 2
42987: PPUSH
42988: LD_INT 2
42990: PUSH
42991: LD_INT 30
42993: PUSH
42994: LD_INT 4
42996: PUSH
42997: EMPTY
42998: LIST
42999: LIST
43000: PUSH
43001: LD_INT 30
43003: PUSH
43004: LD_INT 5
43006: PUSH
43007: EMPTY
43008: LIST
43009: LIST
43010: PUSH
43011: EMPTY
43012: LIST
43013: LIST
43014: LIST
43015: PPUSH
43016: CALL_OW 72
43020: ADD
43021: ST_TO_ADDR
43022: GO 43270
43024: LD_INT 2
43026: DOUBLE
43027: EQUAL
43028: IFTRUE 43038
43030: LD_INT 16
43032: DOUBLE
43033: EQUAL
43034: IFTRUE 43038
43036: GO 43084
43038: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
43039: LD_ADDR_VAR 0 8
43043: PUSH
43044: LD_VAR 0 2
43048: PPUSH
43049: LD_INT 2
43051: PUSH
43052: LD_INT 30
43054: PUSH
43055: LD_INT 0
43057: PUSH
43058: EMPTY
43059: LIST
43060: LIST
43061: PUSH
43062: LD_INT 30
43064: PUSH
43065: LD_INT 1
43067: PUSH
43068: EMPTY
43069: LIST
43070: LIST
43071: PUSH
43072: EMPTY
43073: LIST
43074: LIST
43075: LIST
43076: PPUSH
43077: CALL_OW 72
43081: ST_TO_ADDR
43082: GO 43270
43084: LD_INT 3
43086: DOUBLE
43087: EQUAL
43088: IFTRUE 43092
43090: GO 43138
43092: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
43093: LD_ADDR_VAR 0 8
43097: PUSH
43098: LD_VAR 0 2
43102: PPUSH
43103: LD_INT 2
43105: PUSH
43106: LD_INT 30
43108: PUSH
43109: LD_INT 2
43111: PUSH
43112: EMPTY
43113: LIST
43114: LIST
43115: PUSH
43116: LD_INT 30
43118: PUSH
43119: LD_INT 3
43121: PUSH
43122: EMPTY
43123: LIST
43124: LIST
43125: PUSH
43126: EMPTY
43127: LIST
43128: LIST
43129: LIST
43130: PPUSH
43131: CALL_OW 72
43135: ST_TO_ADDR
43136: GO 43270
43138: LD_INT 4
43140: DOUBLE
43141: EQUAL
43142: IFTRUE 43146
43144: GO 43203
43146: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
43147: LD_ADDR_VAR 0 8
43151: PUSH
43152: LD_VAR 0 2
43156: PPUSH
43157: LD_INT 2
43159: PUSH
43160: LD_INT 30
43162: PUSH
43163: LD_INT 6
43165: PUSH
43166: EMPTY
43167: LIST
43168: LIST
43169: PUSH
43170: LD_INT 30
43172: PUSH
43173: LD_INT 7
43175: PUSH
43176: EMPTY
43177: LIST
43178: LIST
43179: PUSH
43180: LD_INT 30
43182: PUSH
43183: LD_INT 8
43185: PUSH
43186: EMPTY
43187: LIST
43188: LIST
43189: PUSH
43190: EMPTY
43191: LIST
43192: LIST
43193: LIST
43194: LIST
43195: PPUSH
43196: CALL_OW 72
43200: ST_TO_ADDR
43201: GO 43270
43203: LD_INT 5
43205: DOUBLE
43206: EQUAL
43207: IFTRUE 43223
43209: LD_INT 8
43211: DOUBLE
43212: EQUAL
43213: IFTRUE 43223
43215: LD_INT 9
43217: DOUBLE
43218: EQUAL
43219: IFTRUE 43223
43221: GO 43269
43223: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
43224: LD_ADDR_VAR 0 8
43228: PUSH
43229: LD_VAR 0 2
43233: PPUSH
43234: LD_INT 2
43236: PUSH
43237: LD_INT 30
43239: PUSH
43240: LD_INT 4
43242: PUSH
43243: EMPTY
43244: LIST
43245: LIST
43246: PUSH
43247: LD_INT 30
43249: PUSH
43250: LD_INT 5
43252: PUSH
43253: EMPTY
43254: LIST
43255: LIST
43256: PUSH
43257: EMPTY
43258: LIST
43259: LIST
43260: LIST
43261: PPUSH
43262: CALL_OW 72
43266: ST_TO_ADDR
43267: GO 43270
43269: POP
// if not tmp then
43270: LD_VAR 0 8
43274: NOT
43275: IFFALSE 43279
// exit ;
43277: GO 43781
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
43279: LD_VAR 0 4
43283: PUSH
43284: LD_INT 1
43286: PUSH
43287: LD_INT 15
43289: PUSH
43290: EMPTY
43291: LIST
43292: LIST
43293: IN
43294: PUSH
43295: LD_EXP 99
43299: PUSH
43300: LD_VAR 0 1
43304: ARRAY
43305: AND
43306: IFFALSE 43462
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
43308: LD_ADDR_VAR 0 9
43312: PUSH
43313: LD_EXP 99
43317: PUSH
43318: LD_VAR 0 1
43322: ARRAY
43323: PUSH
43324: LD_INT 1
43326: ARRAY
43327: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
43328: LD_VAR 0 9
43332: PUSH
43333: LD_EXP 100
43337: PUSH
43338: LD_VAR 0 1
43342: ARRAY
43343: IN
43344: NOT
43345: IFFALSE 43460
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
43347: LD_ADDR_EXP 100
43351: PUSH
43352: LD_EXP 100
43356: PPUSH
43357: LD_VAR 0 1
43361: PUSH
43362: LD_EXP 100
43366: PUSH
43367: LD_VAR 0 1
43371: ARRAY
43372: PUSH
43373: LD_INT 1
43375: PLUS
43376: PUSH
43377: EMPTY
43378: LIST
43379: LIST
43380: PPUSH
43381: LD_VAR 0 9
43385: PPUSH
43386: CALL 55701 0 3
43390: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
43391: LD_ADDR_EXP 99
43395: PUSH
43396: LD_EXP 99
43400: PPUSH
43401: LD_VAR 0 1
43405: PPUSH
43406: LD_EXP 99
43410: PUSH
43411: LD_VAR 0 1
43415: ARRAY
43416: PUSH
43417: LD_VAR 0 9
43421: DIFF
43422: PPUSH
43423: CALL_OW 1
43427: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
43428: LD_VAR 0 3
43432: PPUSH
43433: LD_EXP 100
43437: PUSH
43438: LD_VAR 0 1
43442: ARRAY
43443: PUSH
43444: LD_EXP 100
43448: PUSH
43449: LD_VAR 0 1
43453: ARRAY
43454: ARRAY
43455: PPUSH
43456: CALL_OW 120
// end ; exit ;
43460: GO 43781
// end ; if tmp > 1 then
43462: LD_VAR 0 8
43466: PUSH
43467: LD_INT 1
43469: GREATER
43470: IFFALSE 43574
// for i = 2 to tmp do
43472: LD_ADDR_VAR 0 6
43476: PUSH
43477: DOUBLE
43478: LD_INT 2
43480: DEC
43481: ST_TO_ADDR
43482: LD_VAR 0 8
43486: PUSH
43487: FOR_TO
43488: IFFALSE 43572
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
43490: LD_VAR 0 8
43494: PUSH
43495: LD_VAR 0 6
43499: ARRAY
43500: PPUSH
43501: CALL_OW 461
43505: PUSH
43506: LD_INT 6
43508: EQUAL
43509: IFFALSE 43570
// begin x := tmp [ i ] ;
43511: LD_ADDR_VAR 0 9
43515: PUSH
43516: LD_VAR 0 8
43520: PUSH
43521: LD_VAR 0 6
43525: ARRAY
43526: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
43527: LD_ADDR_VAR 0 8
43531: PUSH
43532: LD_VAR 0 8
43536: PPUSH
43537: LD_VAR 0 6
43541: PPUSH
43542: CALL_OW 3
43546: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
43547: LD_ADDR_VAR 0 8
43551: PUSH
43552: LD_VAR 0 8
43556: PPUSH
43557: LD_INT 1
43559: PPUSH
43560: LD_VAR 0 9
43564: PPUSH
43565: CALL_OW 2
43569: ST_TO_ADDR
// end ;
43570: GO 43487
43572: POP
43573: POP
// for i in tmp do
43574: LD_ADDR_VAR 0 6
43578: PUSH
43579: LD_VAR 0 8
43583: PUSH
43584: FOR_IN
43585: IFFALSE 43654
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
43587: LD_VAR 0 6
43591: PPUSH
43592: CALL_OW 313
43596: PUSH
43597: LD_INT 6
43599: LESS
43600: PUSH
43601: LD_VAR 0 6
43605: PPUSH
43606: CALL_OW 266
43610: PUSH
43611: LD_INT 31
43613: PUSH
43614: LD_INT 32
43616: PUSH
43617: EMPTY
43618: LIST
43619: LIST
43620: IN
43621: NOT
43622: AND
43623: PUSH
43624: LD_VAR 0 6
43628: PPUSH
43629: CALL_OW 313
43633: PUSH
43634: LD_INT 0
43636: EQUAL
43637: OR
43638: IFFALSE 43652
// begin j := i ;
43640: LD_ADDR_VAR 0 7
43644: PUSH
43645: LD_VAR 0 6
43649: ST_TO_ADDR
// break ;
43650: GO 43654
// end ; end ;
43652: GO 43584
43654: POP
43655: POP
// if j then
43656: LD_VAR 0 7
43660: IFFALSE 43678
// ComEnterUnit ( unit , j ) else
43662: LD_VAR 0 3
43666: PPUSH
43667: LD_VAR 0 7
43671: PPUSH
43672: CALL_OW 120
43676: GO 43781
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43678: LD_ADDR_VAR 0 10
43682: PUSH
43683: LD_VAR 0 2
43687: PPUSH
43688: LD_INT 2
43690: PUSH
43691: LD_INT 30
43693: PUSH
43694: LD_INT 0
43696: PUSH
43697: EMPTY
43698: LIST
43699: LIST
43700: PUSH
43701: LD_INT 30
43703: PUSH
43704: LD_INT 1
43706: PUSH
43707: EMPTY
43708: LIST
43709: LIST
43710: PUSH
43711: EMPTY
43712: LIST
43713: LIST
43714: LIST
43715: PPUSH
43716: CALL_OW 72
43720: ST_TO_ADDR
// if depot then
43721: LD_VAR 0 10
43725: IFFALSE 43781
// begin depot := NearestUnitToUnit ( depot , unit ) ;
43727: LD_ADDR_VAR 0 10
43731: PUSH
43732: LD_VAR 0 10
43736: PPUSH
43737: LD_VAR 0 3
43741: PPUSH
43742: CALL_OW 74
43746: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
43747: LD_VAR 0 3
43751: PPUSH
43752: LD_VAR 0 10
43756: PPUSH
43757: CALL_OW 296
43761: PUSH
43762: LD_INT 10
43764: GREATER
43765: IFFALSE 43781
// ComStandNearbyBuilding ( unit , depot ) ;
43767: LD_VAR 0 3
43771: PPUSH
43772: LD_VAR 0 10
43776: PPUSH
43777: CALL 52315 0 2
// end ; end ; end ;
43781: LD_VAR 0 5
43785: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
43786: LD_INT 0
43788: PPUSH
43789: PPUSH
43790: PPUSH
43791: PPUSH
// if not mc_bases then
43792: LD_EXP 90
43796: NOT
43797: IFFALSE 43801
// exit ;
43799: GO 44040
// for i = 1 to mc_bases do
43801: LD_ADDR_VAR 0 2
43805: PUSH
43806: DOUBLE
43807: LD_INT 1
43809: DEC
43810: ST_TO_ADDR
43811: LD_EXP 90
43815: PUSH
43816: FOR_TO
43817: IFFALSE 44038
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
43819: LD_ADDR_VAR 0 4
43823: PUSH
43824: LD_EXP 90
43828: PUSH
43829: LD_VAR 0 2
43833: ARRAY
43834: PPUSH
43835: LD_INT 21
43837: PUSH
43838: LD_INT 1
43840: PUSH
43841: EMPTY
43842: LIST
43843: LIST
43844: PPUSH
43845: CALL_OW 72
43849: PUSH
43850: LD_EXP 119
43854: PUSH
43855: LD_VAR 0 2
43859: ARRAY
43860: UNION
43861: ST_TO_ADDR
// if not tmp then
43862: LD_VAR 0 4
43866: NOT
43867: IFFALSE 43871
// continue ;
43869: GO 43816
// for j in tmp do
43871: LD_ADDR_VAR 0 3
43875: PUSH
43876: LD_VAR 0 4
43880: PUSH
43881: FOR_IN
43882: IFFALSE 44034
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
43884: LD_VAR 0 3
43888: PPUSH
43889: CALL_OW 110
43893: NOT
43894: PUSH
43895: LD_VAR 0 3
43899: PPUSH
43900: CALL_OW 314
43904: NOT
43905: AND
43906: PUSH
43907: LD_VAR 0 3
43911: PPUSH
43912: CALL_OW 311
43916: NOT
43917: AND
43918: PUSH
43919: LD_VAR 0 3
43923: PPUSH
43924: CALL_OW 310
43928: NOT
43929: AND
43930: PUSH
43931: LD_VAR 0 3
43935: PUSH
43936: LD_EXP 93
43940: PUSH
43941: LD_VAR 0 2
43945: ARRAY
43946: PUSH
43947: LD_INT 1
43949: ARRAY
43950: IN
43951: NOT
43952: AND
43953: PUSH
43954: LD_VAR 0 3
43958: PUSH
43959: LD_EXP 93
43963: PUSH
43964: LD_VAR 0 2
43968: ARRAY
43969: PUSH
43970: LD_INT 2
43972: ARRAY
43973: IN
43974: NOT
43975: AND
43976: PUSH
43977: LD_VAR 0 3
43981: PUSH
43982: LD_EXP 102
43986: PUSH
43987: LD_VAR 0 2
43991: ARRAY
43992: IN
43993: NOT
43994: AND
43995: IFFALSE 44032
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
43997: LD_VAR 0 2
44001: PPUSH
44002: LD_EXP 90
44006: PUSH
44007: LD_VAR 0 2
44011: ARRAY
44012: PPUSH
44013: LD_VAR 0 3
44017: PPUSH
44018: LD_VAR 0 3
44022: PPUSH
44023: CALL_OW 257
44027: PPUSH
44028: CALL 42804 0 4
// end ;
44032: GO 43881
44034: POP
44035: POP
// end ;
44036: GO 43816
44038: POP
44039: POP
// end ;
44040: LD_VAR 0 1
44044: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
44045: LD_INT 0
44047: PPUSH
44048: PPUSH
44049: PPUSH
44050: PPUSH
44051: PPUSH
44052: PPUSH
// if not mc_bases [ base ] then
44053: LD_EXP 90
44057: PUSH
44058: LD_VAR 0 1
44062: ARRAY
44063: NOT
44064: IFFALSE 44068
// exit ;
44066: GO 44250
// tmp := [ ] ;
44068: LD_ADDR_VAR 0 6
44072: PUSH
44073: EMPTY
44074: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
44075: LD_ADDR_VAR 0 7
44079: PUSH
44080: LD_VAR 0 3
44084: PPUSH
44085: LD_INT 0
44087: PPUSH
44088: CALL_OW 517
44092: ST_TO_ADDR
// if not list then
44093: LD_VAR 0 7
44097: NOT
44098: IFFALSE 44102
// exit ;
44100: GO 44250
// for i = 1 to amount do
44102: LD_ADDR_VAR 0 5
44106: PUSH
44107: DOUBLE
44108: LD_INT 1
44110: DEC
44111: ST_TO_ADDR
44112: LD_VAR 0 2
44116: PUSH
44117: FOR_TO
44118: IFFALSE 44198
// begin x := rand ( 1 , list [ 1 ] ) ;
44120: LD_ADDR_VAR 0 8
44124: PUSH
44125: LD_INT 1
44127: PPUSH
44128: LD_VAR 0 7
44132: PUSH
44133: LD_INT 1
44135: ARRAY
44136: PPUSH
44137: CALL_OW 12
44141: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
44142: LD_ADDR_VAR 0 6
44146: PUSH
44147: LD_VAR 0 6
44151: PPUSH
44152: LD_VAR 0 5
44156: PPUSH
44157: LD_VAR 0 7
44161: PUSH
44162: LD_INT 1
44164: ARRAY
44165: PUSH
44166: LD_VAR 0 8
44170: ARRAY
44171: PUSH
44172: LD_VAR 0 7
44176: PUSH
44177: LD_INT 2
44179: ARRAY
44180: PUSH
44181: LD_VAR 0 8
44185: ARRAY
44186: PUSH
44187: EMPTY
44188: LIST
44189: LIST
44190: PPUSH
44191: CALL_OW 1
44195: ST_TO_ADDR
// end ;
44196: GO 44117
44198: POP
44199: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
44200: LD_ADDR_EXP 103
44204: PUSH
44205: LD_EXP 103
44209: PPUSH
44210: LD_VAR 0 1
44214: PPUSH
44215: LD_VAR 0 6
44219: PPUSH
44220: CALL_OW 1
44224: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
44225: LD_ADDR_EXP 105
44229: PUSH
44230: LD_EXP 105
44234: PPUSH
44235: LD_VAR 0 1
44239: PPUSH
44240: LD_VAR 0 3
44244: PPUSH
44245: CALL_OW 1
44249: ST_TO_ADDR
// end ;
44250: LD_VAR 0 4
44254: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
44255: LD_INT 0
44257: PPUSH
// if not mc_bases [ base ] then
44258: LD_EXP 90
44262: PUSH
44263: LD_VAR 0 1
44267: ARRAY
44268: NOT
44269: IFFALSE 44273
// exit ;
44271: GO 44298
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
44273: LD_ADDR_EXP 95
44277: PUSH
44278: LD_EXP 95
44282: PPUSH
44283: LD_VAR 0 1
44287: PPUSH
44288: LD_VAR 0 2
44292: PPUSH
44293: CALL_OW 1
44297: ST_TO_ADDR
// end ;
44298: LD_VAR 0 3
44302: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
44303: LD_INT 0
44305: PPUSH
// if not mc_bases [ base ] then
44306: LD_EXP 90
44310: PUSH
44311: LD_VAR 0 1
44315: ARRAY
44316: NOT
44317: IFFALSE 44321
// exit ;
44319: GO 44358
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
44321: LD_ADDR_EXP 95
44325: PUSH
44326: LD_EXP 95
44330: PPUSH
44331: LD_VAR 0 1
44335: PPUSH
44336: LD_EXP 95
44340: PUSH
44341: LD_VAR 0 1
44345: ARRAY
44346: PUSH
44347: LD_VAR 0 2
44351: UNION
44352: PPUSH
44353: CALL_OW 1
44357: ST_TO_ADDR
// end ;
44358: LD_VAR 0 3
44362: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
44363: LD_INT 0
44365: PPUSH
// if not mc_bases [ base ] then
44366: LD_EXP 90
44370: PUSH
44371: LD_VAR 0 1
44375: ARRAY
44376: NOT
44377: IFFALSE 44381
// exit ;
44379: GO 44406
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
44381: LD_ADDR_EXP 111
44385: PUSH
44386: LD_EXP 111
44390: PPUSH
44391: LD_VAR 0 1
44395: PPUSH
44396: LD_VAR 0 2
44400: PPUSH
44401: CALL_OW 1
44405: ST_TO_ADDR
// end ;
44406: LD_VAR 0 3
44410: RET
// export function MC_InsertProduceList ( base , components ) ; begin
44411: LD_INT 0
44413: PPUSH
// if not mc_bases [ base ] then
44414: LD_EXP 90
44418: PUSH
44419: LD_VAR 0 1
44423: ARRAY
44424: NOT
44425: IFFALSE 44429
// exit ;
44427: GO 44466
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
44429: LD_ADDR_EXP 111
44433: PUSH
44434: LD_EXP 111
44438: PPUSH
44439: LD_VAR 0 1
44443: PPUSH
44444: LD_EXP 111
44448: PUSH
44449: LD_VAR 0 1
44453: ARRAY
44454: PUSH
44455: LD_VAR 0 2
44459: ADD
44460: PPUSH
44461: CALL_OW 1
44465: ST_TO_ADDR
// end ;
44466: LD_VAR 0 3
44470: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
44471: LD_INT 0
44473: PPUSH
// if not mc_bases [ base ] then
44474: LD_EXP 90
44478: PUSH
44479: LD_VAR 0 1
44483: ARRAY
44484: NOT
44485: IFFALSE 44489
// exit ;
44487: GO 44543
// mc_defender := Replace ( mc_defender , base , deflist ) ;
44489: LD_ADDR_EXP 112
44493: PUSH
44494: LD_EXP 112
44498: PPUSH
44499: LD_VAR 0 1
44503: PPUSH
44504: LD_VAR 0 2
44508: PPUSH
44509: CALL_OW 1
44513: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
44514: LD_ADDR_EXP 101
44518: PUSH
44519: LD_EXP 101
44523: PPUSH
44524: LD_VAR 0 1
44528: PPUSH
44529: LD_VAR 0 2
44533: PUSH
44534: LD_INT 0
44536: PLUS
44537: PPUSH
44538: CALL_OW 1
44542: ST_TO_ADDR
// end ;
44543: LD_VAR 0 3
44547: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
44548: LD_INT 0
44550: PPUSH
// if not mc_bases [ base ] then
44551: LD_EXP 90
44555: PUSH
44556: LD_VAR 0 1
44560: ARRAY
44561: NOT
44562: IFFALSE 44566
// exit ;
44564: GO 44591
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
44566: LD_ADDR_EXP 101
44570: PUSH
44571: LD_EXP 101
44575: PPUSH
44576: LD_VAR 0 1
44580: PPUSH
44581: LD_VAR 0 2
44585: PPUSH
44586: CALL_OW 1
44590: ST_TO_ADDR
// end ;
44591: LD_VAR 0 3
44595: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
44596: LD_INT 0
44598: PPUSH
44599: PPUSH
44600: PPUSH
44601: PPUSH
// if not mc_bases [ base ] then
44602: LD_EXP 90
44606: PUSH
44607: LD_VAR 0 1
44611: ARRAY
44612: NOT
44613: IFFALSE 44617
// exit ;
44615: GO 44682
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
44617: LD_ADDR_EXP 110
44621: PUSH
44622: LD_EXP 110
44626: PPUSH
44627: LD_VAR 0 1
44631: PUSH
44632: LD_EXP 110
44636: PUSH
44637: LD_VAR 0 1
44641: ARRAY
44642: PUSH
44643: LD_INT 1
44645: PLUS
44646: PUSH
44647: EMPTY
44648: LIST
44649: LIST
44650: PPUSH
44651: LD_VAR 0 1
44655: PUSH
44656: LD_VAR 0 2
44660: PUSH
44661: LD_VAR 0 3
44665: PUSH
44666: LD_VAR 0 4
44670: PUSH
44671: EMPTY
44672: LIST
44673: LIST
44674: LIST
44675: LIST
44676: PPUSH
44677: CALL 55701 0 3
44681: ST_TO_ADDR
// end ;
44682: LD_VAR 0 5
44686: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
44687: LD_INT 0
44689: PPUSH
// if not mc_bases [ base ] then
44690: LD_EXP 90
44694: PUSH
44695: LD_VAR 0 1
44699: ARRAY
44700: NOT
44701: IFFALSE 44705
// exit ;
44703: GO 44730
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
44705: LD_ADDR_EXP 127
44709: PUSH
44710: LD_EXP 127
44714: PPUSH
44715: LD_VAR 0 1
44719: PPUSH
44720: LD_VAR 0 2
44724: PPUSH
44725: CALL_OW 1
44729: ST_TO_ADDR
// end ;
44730: LD_VAR 0 3
44734: RET
// export function MC_GetMinesField ( base ) ; begin
44735: LD_INT 0
44737: PPUSH
// result := mc_mines [ base ] ;
44738: LD_ADDR_VAR 0 2
44742: PUSH
44743: LD_EXP 103
44747: PUSH
44748: LD_VAR 0 1
44752: ARRAY
44753: ST_TO_ADDR
// end ;
44754: LD_VAR 0 2
44758: RET
// export function MC_GetProduceList ( base ) ; begin
44759: LD_INT 0
44761: PPUSH
// result := mc_produce [ base ] ;
44762: LD_ADDR_VAR 0 2
44766: PUSH
44767: LD_EXP 111
44771: PUSH
44772: LD_VAR 0 1
44776: ARRAY
44777: ST_TO_ADDR
// end ;
44778: LD_VAR 0 2
44782: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
44783: LD_INT 0
44785: PPUSH
44786: PPUSH
// if not mc_bases then
44787: LD_EXP 90
44791: NOT
44792: IFFALSE 44796
// exit ;
44794: GO 44861
// if mc_bases [ base ] then
44796: LD_EXP 90
44800: PUSH
44801: LD_VAR 0 1
44805: ARRAY
44806: IFFALSE 44861
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44808: LD_ADDR_VAR 0 3
44812: PUSH
44813: LD_EXP 90
44817: PUSH
44818: LD_VAR 0 1
44822: ARRAY
44823: PPUSH
44824: LD_INT 30
44826: PUSH
44827: LD_VAR 0 2
44831: PUSH
44832: EMPTY
44833: LIST
44834: LIST
44835: PPUSH
44836: CALL_OW 72
44840: ST_TO_ADDR
// if result then
44841: LD_VAR 0 3
44845: IFFALSE 44861
// result := result [ 1 ] ;
44847: LD_ADDR_VAR 0 3
44851: PUSH
44852: LD_VAR 0 3
44856: PUSH
44857: LD_INT 1
44859: ARRAY
44860: ST_TO_ADDR
// end ; end ;
44861: LD_VAR 0 3
44865: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
44866: LD_INT 0
44868: PPUSH
44869: PPUSH
// if not mc_bases then
44870: LD_EXP 90
44874: NOT
44875: IFFALSE 44879
// exit ;
44877: GO 44924
// if mc_bases [ base ] then
44879: LD_EXP 90
44883: PUSH
44884: LD_VAR 0 1
44888: ARRAY
44889: IFFALSE 44924
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44891: LD_ADDR_VAR 0 3
44895: PUSH
44896: LD_EXP 90
44900: PUSH
44901: LD_VAR 0 1
44905: ARRAY
44906: PPUSH
44907: LD_INT 30
44909: PUSH
44910: LD_VAR 0 2
44914: PUSH
44915: EMPTY
44916: LIST
44917: LIST
44918: PPUSH
44919: CALL_OW 72
44923: ST_TO_ADDR
// end ;
44924: LD_VAR 0 3
44928: RET
// export function MC_SetTame ( base , area ) ; begin
44929: LD_INT 0
44931: PPUSH
// if not mc_bases or not base then
44932: LD_EXP 90
44936: NOT
44937: PUSH
44938: LD_VAR 0 1
44942: NOT
44943: OR
44944: IFFALSE 44948
// exit ;
44946: GO 44973
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
44948: LD_ADDR_EXP 118
44952: PUSH
44953: LD_EXP 118
44957: PPUSH
44958: LD_VAR 0 1
44962: PPUSH
44963: LD_VAR 0 2
44967: PPUSH
44968: CALL_OW 1
44972: ST_TO_ADDR
// end ;
44973: LD_VAR 0 3
44977: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
44978: LD_INT 0
44980: PPUSH
44981: PPUSH
// if not mc_bases or not base then
44982: LD_EXP 90
44986: NOT
44987: PUSH
44988: LD_VAR 0 1
44992: NOT
44993: OR
44994: IFFALSE 44998
// exit ;
44996: GO 45100
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44998: LD_ADDR_VAR 0 4
45002: PUSH
45003: LD_EXP 90
45007: PUSH
45008: LD_VAR 0 1
45012: ARRAY
45013: PPUSH
45014: LD_INT 30
45016: PUSH
45017: LD_VAR 0 2
45021: PUSH
45022: EMPTY
45023: LIST
45024: LIST
45025: PPUSH
45026: CALL_OW 72
45030: ST_TO_ADDR
// if not tmp then
45031: LD_VAR 0 4
45035: NOT
45036: IFFALSE 45040
// exit ;
45038: GO 45100
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
45040: LD_ADDR_EXP 122
45044: PUSH
45045: LD_EXP 122
45049: PPUSH
45050: LD_VAR 0 1
45054: PPUSH
45055: LD_EXP 122
45059: PUSH
45060: LD_VAR 0 1
45064: ARRAY
45065: PPUSH
45066: LD_EXP 122
45070: PUSH
45071: LD_VAR 0 1
45075: ARRAY
45076: PUSH
45077: LD_INT 1
45079: PLUS
45080: PPUSH
45081: LD_VAR 0 4
45085: PUSH
45086: LD_INT 1
45088: ARRAY
45089: PPUSH
45090: CALL_OW 2
45094: PPUSH
45095: CALL_OW 1
45099: ST_TO_ADDR
// end ;
45100: LD_VAR 0 3
45104: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
45105: LD_INT 0
45107: PPUSH
45108: PPUSH
// if not mc_bases or not base or not kinds then
45109: LD_EXP 90
45113: NOT
45114: PUSH
45115: LD_VAR 0 1
45119: NOT
45120: OR
45121: PUSH
45122: LD_VAR 0 2
45126: NOT
45127: OR
45128: IFFALSE 45132
// exit ;
45130: GO 45193
// for i in kinds do
45132: LD_ADDR_VAR 0 4
45136: PUSH
45137: LD_VAR 0 2
45141: PUSH
45142: FOR_IN
45143: IFFALSE 45191
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
45145: LD_ADDR_EXP 124
45149: PUSH
45150: LD_EXP 124
45154: PPUSH
45155: LD_VAR 0 1
45159: PUSH
45160: LD_EXP 124
45164: PUSH
45165: LD_VAR 0 1
45169: ARRAY
45170: PUSH
45171: LD_INT 1
45173: PLUS
45174: PUSH
45175: EMPTY
45176: LIST
45177: LIST
45178: PPUSH
45179: LD_VAR 0 4
45183: PPUSH
45184: CALL 55701 0 3
45188: ST_TO_ADDR
45189: GO 45142
45191: POP
45192: POP
// end ;
45193: LD_VAR 0 3
45197: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
45198: LD_INT 0
45200: PPUSH
// if not mc_bases or not base or not areas then
45201: LD_EXP 90
45205: NOT
45206: PUSH
45207: LD_VAR 0 1
45211: NOT
45212: OR
45213: PUSH
45214: LD_VAR 0 2
45218: NOT
45219: OR
45220: IFFALSE 45224
// exit ;
45222: GO 45249
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
45224: LD_ADDR_EXP 108
45228: PUSH
45229: LD_EXP 108
45233: PPUSH
45234: LD_VAR 0 1
45238: PPUSH
45239: LD_VAR 0 2
45243: PPUSH
45244: CALL_OW 1
45248: ST_TO_ADDR
// end ;
45249: LD_VAR 0 3
45253: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
45254: LD_INT 0
45256: PPUSH
// if not mc_bases or not base or not teleports_exit then
45257: LD_EXP 90
45261: NOT
45262: PUSH
45263: LD_VAR 0 1
45267: NOT
45268: OR
45269: PUSH
45270: LD_VAR 0 2
45274: NOT
45275: OR
45276: IFFALSE 45280
// exit ;
45278: GO 45305
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
45280: LD_ADDR_EXP 125
45284: PUSH
45285: LD_EXP 125
45289: PPUSH
45290: LD_VAR 0 1
45294: PPUSH
45295: LD_VAR 0 2
45299: PPUSH
45300: CALL_OW 1
45304: ST_TO_ADDR
// end ;
45305: LD_VAR 0 3
45309: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
45310: LD_INT 0
45312: PPUSH
45313: PPUSH
45314: PPUSH
// if not mc_bases or not base or not ext_list then
45315: LD_EXP 90
45319: NOT
45320: PUSH
45321: LD_VAR 0 1
45325: NOT
45326: OR
45327: PUSH
45328: LD_VAR 0 5
45332: NOT
45333: OR
45334: IFFALSE 45338
// exit ;
45336: GO 45511
// tmp := GetFacExtXYD ( x , y , d ) ;
45338: LD_ADDR_VAR 0 8
45342: PUSH
45343: LD_VAR 0 2
45347: PPUSH
45348: LD_VAR 0 3
45352: PPUSH
45353: LD_VAR 0 4
45357: PPUSH
45358: CALL 84380 0 3
45362: ST_TO_ADDR
// if not tmp then
45363: LD_VAR 0 8
45367: NOT
45368: IFFALSE 45372
// exit ;
45370: GO 45511
// for i in tmp do
45372: LD_ADDR_VAR 0 7
45376: PUSH
45377: LD_VAR 0 8
45381: PUSH
45382: FOR_IN
45383: IFFALSE 45509
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
45385: LD_ADDR_EXP 95
45389: PUSH
45390: LD_EXP 95
45394: PPUSH
45395: LD_VAR 0 1
45399: PPUSH
45400: LD_EXP 95
45404: PUSH
45405: LD_VAR 0 1
45409: ARRAY
45410: PPUSH
45411: LD_EXP 95
45415: PUSH
45416: LD_VAR 0 1
45420: ARRAY
45421: PUSH
45422: LD_INT 1
45424: PLUS
45425: PPUSH
45426: LD_VAR 0 5
45430: PUSH
45431: LD_INT 1
45433: ARRAY
45434: PUSH
45435: LD_VAR 0 7
45439: PUSH
45440: LD_INT 1
45442: ARRAY
45443: PUSH
45444: LD_VAR 0 7
45448: PUSH
45449: LD_INT 2
45451: ARRAY
45452: PUSH
45453: LD_VAR 0 7
45457: PUSH
45458: LD_INT 3
45460: ARRAY
45461: PUSH
45462: EMPTY
45463: LIST
45464: LIST
45465: LIST
45466: LIST
45467: PPUSH
45468: CALL_OW 2
45472: PPUSH
45473: CALL_OW 1
45477: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
45478: LD_ADDR_VAR 0 5
45482: PUSH
45483: LD_VAR 0 5
45487: PPUSH
45488: LD_INT 1
45490: PPUSH
45491: CALL_OW 3
45495: ST_TO_ADDR
// if not ext_list then
45496: LD_VAR 0 5
45500: NOT
45501: IFFALSE 45507
// exit ;
45503: POP
45504: POP
45505: GO 45511
// end ;
45507: GO 45382
45509: POP
45510: POP
// end ;
45511: LD_VAR 0 6
45515: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
45516: LD_INT 0
45518: PPUSH
// if not mc_bases or not base or not weapon_list then
45519: LD_EXP 90
45523: NOT
45524: PUSH
45525: LD_VAR 0 1
45529: NOT
45530: OR
45531: PUSH
45532: LD_VAR 0 2
45536: NOT
45537: OR
45538: IFFALSE 45542
// exit ;
45540: GO 45567
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
45542: LD_ADDR_EXP 129
45546: PUSH
45547: LD_EXP 129
45551: PPUSH
45552: LD_VAR 0 1
45556: PPUSH
45557: LD_VAR 0 2
45561: PPUSH
45562: CALL_OW 1
45566: ST_TO_ADDR
// end ;
45567: LD_VAR 0 3
45571: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
45572: LD_INT 0
45574: PPUSH
// if not mc_bases or not base or not tech_list then
45575: LD_EXP 90
45579: NOT
45580: PUSH
45581: LD_VAR 0 1
45585: NOT
45586: OR
45587: PUSH
45588: LD_VAR 0 2
45592: NOT
45593: OR
45594: IFFALSE 45598
// exit ;
45596: GO 45623
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
45598: LD_ADDR_EXP 117
45602: PUSH
45603: LD_EXP 117
45607: PPUSH
45608: LD_VAR 0 1
45612: PPUSH
45613: LD_VAR 0 2
45617: PPUSH
45618: CALL_OW 1
45622: ST_TO_ADDR
// end ;
45623: LD_VAR 0 3
45627: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
45628: LD_INT 0
45630: PPUSH
// if not mc_bases or not parking_area or not base then
45631: LD_EXP 90
45635: NOT
45636: PUSH
45637: LD_VAR 0 2
45641: NOT
45642: OR
45643: PUSH
45644: LD_VAR 0 1
45648: NOT
45649: OR
45650: IFFALSE 45654
// exit ;
45652: GO 45679
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
45654: LD_ADDR_EXP 114
45658: PUSH
45659: LD_EXP 114
45663: PPUSH
45664: LD_VAR 0 1
45668: PPUSH
45669: LD_VAR 0 2
45673: PPUSH
45674: CALL_OW 1
45678: ST_TO_ADDR
// end ;
45679: LD_VAR 0 3
45683: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
45684: LD_INT 0
45686: PPUSH
// if not mc_bases or not base or not scan_area then
45687: LD_EXP 90
45691: NOT
45692: PUSH
45693: LD_VAR 0 1
45697: NOT
45698: OR
45699: PUSH
45700: LD_VAR 0 2
45704: NOT
45705: OR
45706: IFFALSE 45710
// exit ;
45708: GO 45735
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
45710: LD_ADDR_EXP 115
45714: PUSH
45715: LD_EXP 115
45719: PPUSH
45720: LD_VAR 0 1
45724: PPUSH
45725: LD_VAR 0 2
45729: PPUSH
45730: CALL_OW 1
45734: ST_TO_ADDR
// end ;
45735: LD_VAR 0 3
45739: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
45740: LD_INT 0
45742: PPUSH
45743: PPUSH
// if not mc_bases or not base then
45744: LD_EXP 90
45748: NOT
45749: PUSH
45750: LD_VAR 0 1
45754: NOT
45755: OR
45756: IFFALSE 45760
// exit ;
45758: GO 45824
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
45760: LD_ADDR_VAR 0 3
45764: PUSH
45765: LD_INT 1
45767: PUSH
45768: LD_INT 2
45770: PUSH
45771: LD_INT 3
45773: PUSH
45774: LD_INT 4
45776: PUSH
45777: LD_INT 11
45779: PUSH
45780: EMPTY
45781: LIST
45782: LIST
45783: LIST
45784: LIST
45785: LIST
45786: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
45787: LD_ADDR_EXP 117
45791: PUSH
45792: LD_EXP 117
45796: PPUSH
45797: LD_VAR 0 1
45801: PPUSH
45802: LD_EXP 117
45806: PUSH
45807: LD_VAR 0 1
45811: ARRAY
45812: PUSH
45813: LD_VAR 0 3
45817: DIFF
45818: PPUSH
45819: CALL_OW 1
45823: ST_TO_ADDR
// end ;
45824: LD_VAR 0 2
45828: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
45829: LD_INT 0
45831: PPUSH
// result := mc_vehicles [ base ] ;
45832: LD_ADDR_VAR 0 3
45836: PUSH
45837: LD_EXP 109
45841: PUSH
45842: LD_VAR 0 1
45846: ARRAY
45847: ST_TO_ADDR
// if onlyCombat then
45848: LD_VAR 0 2
45852: IFFALSE 46017
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
45854: LD_ADDR_VAR 0 3
45858: PUSH
45859: LD_VAR 0 3
45863: PUSH
45864: LD_VAR 0 3
45868: PPUSH
45869: LD_INT 2
45871: PUSH
45872: LD_INT 34
45874: PUSH
45875: LD_INT 12
45877: PUSH
45878: EMPTY
45879: LIST
45880: LIST
45881: PUSH
45882: LD_INT 34
45884: PUSH
45885: LD_INT 51
45887: PUSH
45888: EMPTY
45889: LIST
45890: LIST
45891: PUSH
45892: LD_INT 34
45894: PUSH
45895: LD_EXP 73
45899: PUSH
45900: EMPTY
45901: LIST
45902: LIST
45903: PUSH
45904: LD_INT 34
45906: PUSH
45907: LD_INT 32
45909: PUSH
45910: EMPTY
45911: LIST
45912: LIST
45913: PUSH
45914: LD_INT 34
45916: PUSH
45917: LD_INT 13
45919: PUSH
45920: EMPTY
45921: LIST
45922: LIST
45923: PUSH
45924: LD_INT 34
45926: PUSH
45927: LD_INT 52
45929: PUSH
45930: EMPTY
45931: LIST
45932: LIST
45933: PUSH
45934: LD_INT 34
45936: PUSH
45937: LD_INT 14
45939: PUSH
45940: EMPTY
45941: LIST
45942: LIST
45943: PUSH
45944: LD_INT 34
45946: PUSH
45947: LD_INT 53
45949: PUSH
45950: EMPTY
45951: LIST
45952: LIST
45953: PUSH
45954: LD_INT 34
45956: PUSH
45957: LD_EXP 72
45961: PUSH
45962: EMPTY
45963: LIST
45964: LIST
45965: PUSH
45966: LD_INT 34
45968: PUSH
45969: LD_INT 31
45971: PUSH
45972: EMPTY
45973: LIST
45974: LIST
45975: PUSH
45976: LD_INT 34
45978: PUSH
45979: LD_INT 48
45981: PUSH
45982: EMPTY
45983: LIST
45984: LIST
45985: PUSH
45986: LD_INT 34
45988: PUSH
45989: LD_INT 8
45991: PUSH
45992: EMPTY
45993: LIST
45994: LIST
45995: PUSH
45996: EMPTY
45997: LIST
45998: LIST
45999: LIST
46000: LIST
46001: LIST
46002: LIST
46003: LIST
46004: LIST
46005: LIST
46006: LIST
46007: LIST
46008: LIST
46009: LIST
46010: PPUSH
46011: CALL_OW 72
46015: DIFF
46016: ST_TO_ADDR
// end ; end_of_file
46017: LD_VAR 0 3
46021: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
46022: LD_INT 0
46024: PPUSH
46025: PPUSH
46026: PPUSH
// if not mc_bases or not skirmish then
46027: LD_EXP 90
46031: NOT
46032: PUSH
46033: LD_EXP 88
46037: NOT
46038: OR
46039: IFFALSE 46043
// exit ;
46041: GO 46208
// for i = 1 to mc_bases do
46043: LD_ADDR_VAR 0 4
46047: PUSH
46048: DOUBLE
46049: LD_INT 1
46051: DEC
46052: ST_TO_ADDR
46053: LD_EXP 90
46057: PUSH
46058: FOR_TO
46059: IFFALSE 46206
// begin if sci in mc_bases [ i ] then
46061: LD_VAR 0 2
46065: PUSH
46066: LD_EXP 90
46070: PUSH
46071: LD_VAR 0 4
46075: ARRAY
46076: IN
46077: IFFALSE 46204
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
46079: LD_ADDR_EXP 119
46083: PUSH
46084: LD_EXP 119
46088: PPUSH
46089: LD_VAR 0 4
46093: PUSH
46094: LD_EXP 119
46098: PUSH
46099: LD_VAR 0 4
46103: ARRAY
46104: PUSH
46105: LD_INT 1
46107: PLUS
46108: PUSH
46109: EMPTY
46110: LIST
46111: LIST
46112: PPUSH
46113: LD_VAR 0 1
46117: PPUSH
46118: CALL 55701 0 3
46122: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
46123: LD_ADDR_VAR 0 5
46127: PUSH
46128: LD_EXP 90
46132: PUSH
46133: LD_VAR 0 4
46137: ARRAY
46138: PPUSH
46139: LD_INT 2
46141: PUSH
46142: LD_INT 30
46144: PUSH
46145: LD_INT 0
46147: PUSH
46148: EMPTY
46149: LIST
46150: LIST
46151: PUSH
46152: LD_INT 30
46154: PUSH
46155: LD_INT 1
46157: PUSH
46158: EMPTY
46159: LIST
46160: LIST
46161: PUSH
46162: EMPTY
46163: LIST
46164: LIST
46165: LIST
46166: PPUSH
46167: CALL_OW 72
46171: PPUSH
46172: LD_VAR 0 1
46176: PPUSH
46177: CALL_OW 74
46181: ST_TO_ADDR
// if tmp then
46182: LD_VAR 0 5
46186: IFFALSE 46202
// ComStandNearbyBuilding ( ape , tmp ) ;
46188: LD_VAR 0 1
46192: PPUSH
46193: LD_VAR 0 5
46197: PPUSH
46198: CALL 52315 0 2
// break ;
46202: GO 46206
// end ; end ;
46204: GO 46058
46206: POP
46207: POP
// end ;
46208: LD_VAR 0 3
46212: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
46213: LD_INT 0
46215: PPUSH
46216: PPUSH
46217: PPUSH
// if not mc_bases or not skirmish then
46218: LD_EXP 90
46222: NOT
46223: PUSH
46224: LD_EXP 88
46228: NOT
46229: OR
46230: IFFALSE 46234
// exit ;
46232: GO 46323
// for i = 1 to mc_bases do
46234: LD_ADDR_VAR 0 4
46238: PUSH
46239: DOUBLE
46240: LD_INT 1
46242: DEC
46243: ST_TO_ADDR
46244: LD_EXP 90
46248: PUSH
46249: FOR_TO
46250: IFFALSE 46321
// begin if building in mc_busy_turret_list [ i ] then
46252: LD_VAR 0 1
46256: PUSH
46257: LD_EXP 100
46261: PUSH
46262: LD_VAR 0 4
46266: ARRAY
46267: IN
46268: IFFALSE 46319
// begin tmp := mc_busy_turret_list [ i ] diff building ;
46270: LD_ADDR_VAR 0 5
46274: PUSH
46275: LD_EXP 100
46279: PUSH
46280: LD_VAR 0 4
46284: ARRAY
46285: PUSH
46286: LD_VAR 0 1
46290: DIFF
46291: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
46292: LD_ADDR_EXP 100
46296: PUSH
46297: LD_EXP 100
46301: PPUSH
46302: LD_VAR 0 4
46306: PPUSH
46307: LD_VAR 0 5
46311: PPUSH
46312: CALL_OW 1
46316: ST_TO_ADDR
// break ;
46317: GO 46321
// end ; end ;
46319: GO 46249
46321: POP
46322: POP
// end ;
46323: LD_VAR 0 3
46327: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
46328: LD_INT 0
46330: PPUSH
46331: PPUSH
46332: PPUSH
// if not mc_bases or not skirmish then
46333: LD_EXP 90
46337: NOT
46338: PUSH
46339: LD_EXP 88
46343: NOT
46344: OR
46345: IFFALSE 46349
// exit ;
46347: GO 46548
// for i = 1 to mc_bases do
46349: LD_ADDR_VAR 0 5
46353: PUSH
46354: DOUBLE
46355: LD_INT 1
46357: DEC
46358: ST_TO_ADDR
46359: LD_EXP 90
46363: PUSH
46364: FOR_TO
46365: IFFALSE 46546
// if building in mc_bases [ i ] then
46367: LD_VAR 0 1
46371: PUSH
46372: LD_EXP 90
46376: PUSH
46377: LD_VAR 0 5
46381: ARRAY
46382: IN
46383: IFFALSE 46544
// begin tmp := mc_bases [ i ] diff building ;
46385: LD_ADDR_VAR 0 6
46389: PUSH
46390: LD_EXP 90
46394: PUSH
46395: LD_VAR 0 5
46399: ARRAY
46400: PUSH
46401: LD_VAR 0 1
46405: DIFF
46406: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
46407: LD_ADDR_EXP 90
46411: PUSH
46412: LD_EXP 90
46416: PPUSH
46417: LD_VAR 0 5
46421: PPUSH
46422: LD_VAR 0 6
46426: PPUSH
46427: CALL_OW 1
46431: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
46432: LD_VAR 0 1
46436: PUSH
46437: LD_EXP 98
46441: PUSH
46442: LD_VAR 0 5
46446: ARRAY
46447: IN
46448: IFFALSE 46487
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
46450: LD_ADDR_EXP 98
46454: PUSH
46455: LD_EXP 98
46459: PPUSH
46460: LD_VAR 0 5
46464: PPUSH
46465: LD_EXP 98
46469: PUSH
46470: LD_VAR 0 5
46474: ARRAY
46475: PUSH
46476: LD_VAR 0 1
46480: DIFF
46481: PPUSH
46482: CALL_OW 1
46486: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
46487: LD_VAR 0 1
46491: PUSH
46492: LD_EXP 99
46496: PUSH
46497: LD_VAR 0 5
46501: ARRAY
46502: IN
46503: IFFALSE 46542
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
46505: LD_ADDR_EXP 99
46509: PUSH
46510: LD_EXP 99
46514: PPUSH
46515: LD_VAR 0 5
46519: PPUSH
46520: LD_EXP 99
46524: PUSH
46525: LD_VAR 0 5
46529: ARRAY
46530: PUSH
46531: LD_VAR 0 1
46535: DIFF
46536: PPUSH
46537: CALL_OW 1
46541: ST_TO_ADDR
// break ;
46542: GO 46546
// end ;
46544: GO 46364
46546: POP
46547: POP
// end ;
46548: LD_VAR 0 4
46552: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
46553: LD_INT 0
46555: PPUSH
46556: PPUSH
46557: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
46558: LD_EXP 90
46562: NOT
46563: PUSH
46564: LD_EXP 88
46568: NOT
46569: OR
46570: PUSH
46571: LD_VAR 0 3
46575: PUSH
46576: LD_EXP 116
46580: IN
46581: NOT
46582: OR
46583: IFFALSE 46587
// exit ;
46585: GO 46710
// for i = 1 to mc_vehicles do
46587: LD_ADDR_VAR 0 6
46591: PUSH
46592: DOUBLE
46593: LD_INT 1
46595: DEC
46596: ST_TO_ADDR
46597: LD_EXP 109
46601: PUSH
46602: FOR_TO
46603: IFFALSE 46708
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
46605: LD_VAR 0 2
46609: PUSH
46610: LD_EXP 109
46614: PUSH
46615: LD_VAR 0 6
46619: ARRAY
46620: IN
46621: PUSH
46622: LD_VAR 0 1
46626: PUSH
46627: LD_EXP 109
46631: PUSH
46632: LD_VAR 0 6
46636: ARRAY
46637: IN
46638: OR
46639: IFFALSE 46706
// begin tmp := mc_vehicles [ i ] diff old ;
46641: LD_ADDR_VAR 0 7
46645: PUSH
46646: LD_EXP 109
46650: PUSH
46651: LD_VAR 0 6
46655: ARRAY
46656: PUSH
46657: LD_VAR 0 2
46661: DIFF
46662: ST_TO_ADDR
// tmp := tmp diff new ;
46663: LD_ADDR_VAR 0 7
46667: PUSH
46668: LD_VAR 0 7
46672: PUSH
46673: LD_VAR 0 1
46677: DIFF
46678: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
46679: LD_ADDR_EXP 109
46683: PUSH
46684: LD_EXP 109
46688: PPUSH
46689: LD_VAR 0 6
46693: PPUSH
46694: LD_VAR 0 7
46698: PPUSH
46699: CALL_OW 1
46703: ST_TO_ADDR
// break ;
46704: GO 46708
// end ;
46706: GO 46602
46708: POP
46709: POP
// end ;
46710: LD_VAR 0 5
46714: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
46715: LD_INT 0
46717: PPUSH
46718: PPUSH
46719: PPUSH
46720: PPUSH
// if not mc_bases or not skirmish then
46721: LD_EXP 90
46725: NOT
46726: PUSH
46727: LD_EXP 88
46731: NOT
46732: OR
46733: IFFALSE 46737
// exit ;
46735: GO 47114
// side := GetSide ( vehicle ) ;
46737: LD_ADDR_VAR 0 5
46741: PUSH
46742: LD_VAR 0 1
46746: PPUSH
46747: CALL_OW 255
46751: ST_TO_ADDR
// for i = 1 to mc_bases do
46752: LD_ADDR_VAR 0 4
46756: PUSH
46757: DOUBLE
46758: LD_INT 1
46760: DEC
46761: ST_TO_ADDR
46762: LD_EXP 90
46766: PUSH
46767: FOR_TO
46768: IFFALSE 47112
// begin if factory in mc_bases [ i ] then
46770: LD_VAR 0 2
46774: PUSH
46775: LD_EXP 90
46779: PUSH
46780: LD_VAR 0 4
46784: ARRAY
46785: IN
46786: IFFALSE 47110
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
46788: LD_EXP 112
46792: PUSH
46793: LD_VAR 0 4
46797: ARRAY
46798: PUSH
46799: LD_EXP 101
46803: PUSH
46804: LD_VAR 0 4
46808: ARRAY
46809: LESS
46810: PUSH
46811: LD_VAR 0 1
46815: PPUSH
46816: CALL_OW 264
46820: PUSH
46821: LD_INT 31
46823: PUSH
46824: LD_INT 32
46826: PUSH
46827: LD_INT 51
46829: PUSH
46830: LD_EXP 73
46834: PUSH
46835: LD_INT 12
46837: PUSH
46838: LD_INT 30
46840: PUSH
46841: LD_EXP 72
46845: PUSH
46846: LD_INT 11
46848: PUSH
46849: LD_INT 53
46851: PUSH
46852: LD_INT 14
46854: PUSH
46855: LD_EXP 76
46859: PUSH
46860: LD_INT 29
46862: PUSH
46863: LD_EXP 74
46867: PUSH
46868: LD_INT 13
46870: PUSH
46871: LD_INT 52
46873: PUSH
46874: LD_INT 48
46876: PUSH
46877: LD_INT 8
46879: PUSH
46880: EMPTY
46881: LIST
46882: LIST
46883: LIST
46884: LIST
46885: LIST
46886: LIST
46887: LIST
46888: LIST
46889: LIST
46890: LIST
46891: LIST
46892: LIST
46893: LIST
46894: LIST
46895: LIST
46896: LIST
46897: LIST
46898: IN
46899: NOT
46900: AND
46901: IFFALSE 46949
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
46903: LD_ADDR_EXP 112
46907: PUSH
46908: LD_EXP 112
46912: PPUSH
46913: LD_VAR 0 4
46917: PUSH
46918: LD_EXP 112
46922: PUSH
46923: LD_VAR 0 4
46927: ARRAY
46928: PUSH
46929: LD_INT 1
46931: PLUS
46932: PUSH
46933: EMPTY
46934: LIST
46935: LIST
46936: PPUSH
46937: LD_VAR 0 1
46941: PPUSH
46942: CALL 55701 0 3
46946: ST_TO_ADDR
46947: GO 46993
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
46949: LD_ADDR_EXP 109
46953: PUSH
46954: LD_EXP 109
46958: PPUSH
46959: LD_VAR 0 4
46963: PUSH
46964: LD_EXP 109
46968: PUSH
46969: LD_VAR 0 4
46973: ARRAY
46974: PUSH
46975: LD_INT 1
46977: PLUS
46978: PUSH
46979: EMPTY
46980: LIST
46981: LIST
46982: PPUSH
46983: LD_VAR 0 1
46987: PPUSH
46988: CALL 55701 0 3
46992: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
46993: LD_VAR 0 1
46997: PPUSH
46998: CALL_OW 263
47002: PUSH
47003: LD_INT 2
47005: EQUAL
47006: IFFALSE 47026
// begin repeat wait ( 0 0$1 ) ;
47008: LD_INT 35
47010: PPUSH
47011: CALL_OW 67
// until IsControledBy ( vehicle ) ;
47015: LD_VAR 0 1
47019: PPUSH
47020: CALL_OW 312
47024: IFFALSE 47008
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
47026: LD_VAR 0 1
47030: PPUSH
47031: LD_EXP 114
47035: PUSH
47036: LD_VAR 0 4
47040: ARRAY
47041: PPUSH
47042: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
47046: LD_VAR 0 1
47050: PPUSH
47051: CALL_OW 263
47055: PUSH
47056: LD_INT 1
47058: NONEQUAL
47059: IFFALSE 47063
// break ;
47061: GO 47112
// repeat wait ( 0 0$1 ) ;
47063: LD_INT 35
47065: PPUSH
47066: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
47070: LD_VAR 0 1
47074: PPUSH
47075: LD_EXP 114
47079: PUSH
47080: LD_VAR 0 4
47084: ARRAY
47085: PPUSH
47086: CALL_OW 308
47090: IFFALSE 47063
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
47092: LD_VAR 0 1
47096: PPUSH
47097: CALL_OW 311
47101: PPUSH
47102: CALL_OW 121
// exit ;
47106: POP
47107: POP
47108: GO 47114
// end ; end ;
47110: GO 46767
47112: POP
47113: POP
// end ;
47114: LD_VAR 0 3
47118: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
47119: LD_INT 0
47121: PPUSH
47122: PPUSH
47123: PPUSH
47124: PPUSH
// if not mc_bases or not skirmish then
47125: LD_EXP 90
47129: NOT
47130: PUSH
47131: LD_EXP 88
47135: NOT
47136: OR
47137: IFFALSE 47141
// exit ;
47139: GO 47494
// repeat wait ( 0 0$1 ) ;
47141: LD_INT 35
47143: PPUSH
47144: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
47148: LD_VAR 0 2
47152: PPUSH
47153: LD_VAR 0 3
47157: PPUSH
47158: CALL_OW 284
47162: IFFALSE 47141
// if GetResourceTypeXY ( x , y ) = mat_artefact then
47164: LD_VAR 0 2
47168: PPUSH
47169: LD_VAR 0 3
47173: PPUSH
47174: CALL_OW 283
47178: PUSH
47179: LD_INT 4
47181: EQUAL
47182: IFFALSE 47186
// exit ;
47184: GO 47494
// for i = 1 to mc_bases do
47186: LD_ADDR_VAR 0 7
47190: PUSH
47191: DOUBLE
47192: LD_INT 1
47194: DEC
47195: ST_TO_ADDR
47196: LD_EXP 90
47200: PUSH
47201: FOR_TO
47202: IFFALSE 47492
// begin if mc_crates_area [ i ] then
47204: LD_EXP 108
47208: PUSH
47209: LD_VAR 0 7
47213: ARRAY
47214: IFFALSE 47325
// for j in mc_crates_area [ i ] do
47216: LD_ADDR_VAR 0 8
47220: PUSH
47221: LD_EXP 108
47225: PUSH
47226: LD_VAR 0 7
47230: ARRAY
47231: PUSH
47232: FOR_IN
47233: IFFALSE 47323
// if InArea ( x , y , j ) then
47235: LD_VAR 0 2
47239: PPUSH
47240: LD_VAR 0 3
47244: PPUSH
47245: LD_VAR 0 8
47249: PPUSH
47250: CALL_OW 309
47254: IFFALSE 47321
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
47256: LD_ADDR_EXP 106
47260: PUSH
47261: LD_EXP 106
47265: PPUSH
47266: LD_VAR 0 7
47270: PUSH
47271: LD_EXP 106
47275: PUSH
47276: LD_VAR 0 7
47280: ARRAY
47281: PUSH
47282: LD_INT 1
47284: PLUS
47285: PUSH
47286: EMPTY
47287: LIST
47288: LIST
47289: PPUSH
47290: LD_VAR 0 4
47294: PUSH
47295: LD_VAR 0 2
47299: PUSH
47300: LD_VAR 0 3
47304: PUSH
47305: EMPTY
47306: LIST
47307: LIST
47308: LIST
47309: PPUSH
47310: CALL 55701 0 3
47314: ST_TO_ADDR
// exit ;
47315: POP
47316: POP
47317: POP
47318: POP
47319: GO 47494
// end ;
47321: GO 47232
47323: POP
47324: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47325: LD_ADDR_VAR 0 9
47329: PUSH
47330: LD_EXP 90
47334: PUSH
47335: LD_VAR 0 7
47339: ARRAY
47340: PPUSH
47341: LD_INT 2
47343: PUSH
47344: LD_INT 30
47346: PUSH
47347: LD_INT 0
47349: PUSH
47350: EMPTY
47351: LIST
47352: LIST
47353: PUSH
47354: LD_INT 30
47356: PUSH
47357: LD_INT 1
47359: PUSH
47360: EMPTY
47361: LIST
47362: LIST
47363: PUSH
47364: EMPTY
47365: LIST
47366: LIST
47367: LIST
47368: PPUSH
47369: CALL_OW 72
47373: ST_TO_ADDR
// if not depot then
47374: LD_VAR 0 9
47378: NOT
47379: IFFALSE 47383
// continue ;
47381: GO 47201
// for j in depot do
47383: LD_ADDR_VAR 0 8
47387: PUSH
47388: LD_VAR 0 9
47392: PUSH
47393: FOR_IN
47394: IFFALSE 47488
// if GetDistUnitXY ( j , x , y ) < 30 then
47396: LD_VAR 0 8
47400: PPUSH
47401: LD_VAR 0 2
47405: PPUSH
47406: LD_VAR 0 3
47410: PPUSH
47411: CALL_OW 297
47415: PUSH
47416: LD_INT 30
47418: LESS
47419: IFFALSE 47486
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
47421: LD_ADDR_EXP 106
47425: PUSH
47426: LD_EXP 106
47430: PPUSH
47431: LD_VAR 0 7
47435: PUSH
47436: LD_EXP 106
47440: PUSH
47441: LD_VAR 0 7
47445: ARRAY
47446: PUSH
47447: LD_INT 1
47449: PLUS
47450: PUSH
47451: EMPTY
47452: LIST
47453: LIST
47454: PPUSH
47455: LD_VAR 0 4
47459: PUSH
47460: LD_VAR 0 2
47464: PUSH
47465: LD_VAR 0 3
47469: PUSH
47470: EMPTY
47471: LIST
47472: LIST
47473: LIST
47474: PPUSH
47475: CALL 55701 0 3
47479: ST_TO_ADDR
// exit ;
47480: POP
47481: POP
47482: POP
47483: POP
47484: GO 47494
// end ;
47486: GO 47393
47488: POP
47489: POP
// end ;
47490: GO 47201
47492: POP
47493: POP
// end ;
47494: LD_VAR 0 6
47498: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
47499: LD_INT 0
47501: PPUSH
47502: PPUSH
47503: PPUSH
47504: PPUSH
// if not mc_bases or not skirmish then
47505: LD_EXP 90
47509: NOT
47510: PUSH
47511: LD_EXP 88
47515: NOT
47516: OR
47517: IFFALSE 47521
// exit ;
47519: GO 47798
// side := GetSide ( lab ) ;
47521: LD_ADDR_VAR 0 4
47525: PUSH
47526: LD_VAR 0 2
47530: PPUSH
47531: CALL_OW 255
47535: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
47536: LD_VAR 0 4
47540: PUSH
47541: LD_EXP 116
47545: IN
47546: NOT
47547: PUSH
47548: LD_EXP 117
47552: NOT
47553: OR
47554: PUSH
47555: LD_EXP 90
47559: NOT
47560: OR
47561: IFFALSE 47565
// exit ;
47563: GO 47798
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
47565: LD_ADDR_EXP 117
47569: PUSH
47570: LD_EXP 117
47574: PPUSH
47575: LD_VAR 0 4
47579: PPUSH
47580: LD_EXP 117
47584: PUSH
47585: LD_VAR 0 4
47589: ARRAY
47590: PUSH
47591: LD_VAR 0 1
47595: DIFF
47596: PPUSH
47597: CALL_OW 1
47601: ST_TO_ADDR
// for i = 1 to mc_bases do
47602: LD_ADDR_VAR 0 5
47606: PUSH
47607: DOUBLE
47608: LD_INT 1
47610: DEC
47611: ST_TO_ADDR
47612: LD_EXP 90
47616: PUSH
47617: FOR_TO
47618: IFFALSE 47796
// begin if lab in mc_bases [ i ] then
47620: LD_VAR 0 2
47624: PUSH
47625: LD_EXP 90
47629: PUSH
47630: LD_VAR 0 5
47634: ARRAY
47635: IN
47636: IFFALSE 47794
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
47638: LD_VAR 0 1
47642: PUSH
47643: LD_INT 11
47645: PUSH
47646: LD_INT 4
47648: PUSH
47649: LD_INT 3
47651: PUSH
47652: LD_INT 2
47654: PUSH
47655: EMPTY
47656: LIST
47657: LIST
47658: LIST
47659: LIST
47660: IN
47661: PUSH
47662: LD_EXP 120
47666: PUSH
47667: LD_VAR 0 5
47671: ARRAY
47672: AND
47673: IFFALSE 47794
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
47675: LD_ADDR_VAR 0 6
47679: PUSH
47680: LD_EXP 120
47684: PUSH
47685: LD_VAR 0 5
47689: ARRAY
47690: PUSH
47691: LD_INT 1
47693: ARRAY
47694: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
47695: LD_ADDR_EXP 120
47699: PUSH
47700: LD_EXP 120
47704: PPUSH
47705: LD_VAR 0 5
47709: PPUSH
47710: EMPTY
47711: PPUSH
47712: CALL_OW 1
47716: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
47717: LD_VAR 0 6
47721: PPUSH
47722: LD_INT 0
47724: PPUSH
47725: CALL_OW 109
// ComExitBuilding ( tmp ) ;
47729: LD_VAR 0 6
47733: PPUSH
47734: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
47738: LD_ADDR_EXP 119
47742: PUSH
47743: LD_EXP 119
47747: PPUSH
47748: LD_VAR 0 5
47752: PPUSH
47753: LD_EXP 119
47757: PUSH
47758: LD_VAR 0 5
47762: ARRAY
47763: PPUSH
47764: LD_INT 1
47766: PPUSH
47767: LD_VAR 0 6
47771: PPUSH
47772: CALL_OW 2
47776: PPUSH
47777: CALL_OW 1
47781: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
47782: LD_VAR 0 5
47786: PPUSH
47787: LD_INT 112
47789: PPUSH
47790: CALL 24810 0 2
// end ; end ; end ;
47794: GO 47617
47796: POP
47797: POP
// end ;
47798: LD_VAR 0 3
47802: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
47803: LD_INT 0
47805: PPUSH
47806: PPUSH
47807: PPUSH
47808: PPUSH
47809: PPUSH
47810: PPUSH
47811: PPUSH
47812: PPUSH
// if not mc_bases or not skirmish then
47813: LD_EXP 90
47817: NOT
47818: PUSH
47819: LD_EXP 88
47823: NOT
47824: OR
47825: IFFALSE 47829
// exit ;
47827: GO 49200
// for i = 1 to mc_bases do
47829: LD_ADDR_VAR 0 3
47833: PUSH
47834: DOUBLE
47835: LD_INT 1
47837: DEC
47838: ST_TO_ADDR
47839: LD_EXP 90
47843: PUSH
47844: FOR_TO
47845: IFFALSE 49198
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
47847: LD_VAR 0 1
47851: PUSH
47852: LD_EXP 90
47856: PUSH
47857: LD_VAR 0 3
47861: ARRAY
47862: IN
47863: PUSH
47864: LD_VAR 0 1
47868: PUSH
47869: LD_EXP 97
47873: PUSH
47874: LD_VAR 0 3
47878: ARRAY
47879: IN
47880: OR
47881: PUSH
47882: LD_VAR 0 1
47886: PUSH
47887: LD_EXP 112
47891: PUSH
47892: LD_VAR 0 3
47896: ARRAY
47897: IN
47898: OR
47899: PUSH
47900: LD_VAR 0 1
47904: PUSH
47905: LD_EXP 109
47909: PUSH
47910: LD_VAR 0 3
47914: ARRAY
47915: IN
47916: OR
47917: PUSH
47918: LD_VAR 0 1
47922: PUSH
47923: LD_EXP 119
47927: PUSH
47928: LD_VAR 0 3
47932: ARRAY
47933: IN
47934: OR
47935: PUSH
47936: LD_VAR 0 1
47940: PUSH
47941: LD_EXP 120
47945: PUSH
47946: LD_VAR 0 3
47950: ARRAY
47951: IN
47952: OR
47953: IFFALSE 49196
// begin if un in mc_ape [ i ] then
47955: LD_VAR 0 1
47959: PUSH
47960: LD_EXP 119
47964: PUSH
47965: LD_VAR 0 3
47969: ARRAY
47970: IN
47971: IFFALSE 48010
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
47973: LD_ADDR_EXP 119
47977: PUSH
47978: LD_EXP 119
47982: PPUSH
47983: LD_VAR 0 3
47987: PPUSH
47988: LD_EXP 119
47992: PUSH
47993: LD_VAR 0 3
47997: ARRAY
47998: PUSH
47999: LD_VAR 0 1
48003: DIFF
48004: PPUSH
48005: CALL_OW 1
48009: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
48010: LD_VAR 0 1
48014: PUSH
48015: LD_EXP 120
48019: PUSH
48020: LD_VAR 0 3
48024: ARRAY
48025: IN
48026: IFFALSE 48050
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
48028: LD_ADDR_EXP 120
48032: PUSH
48033: LD_EXP 120
48037: PPUSH
48038: LD_VAR 0 3
48042: PPUSH
48043: EMPTY
48044: PPUSH
48045: CALL_OW 1
48049: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
48050: LD_VAR 0 1
48054: PPUSH
48055: CALL_OW 247
48059: PUSH
48060: LD_INT 2
48062: EQUAL
48063: PUSH
48064: LD_VAR 0 1
48068: PPUSH
48069: CALL_OW 110
48073: PUSH
48074: LD_INT 20
48076: EQUAL
48077: PUSH
48078: LD_VAR 0 1
48082: PUSH
48083: LD_EXP 112
48087: PUSH
48088: LD_VAR 0 3
48092: ARRAY
48093: IN
48094: OR
48095: PUSH
48096: LD_VAR 0 1
48100: PPUSH
48101: CALL_OW 264
48105: PUSH
48106: LD_INT 12
48108: PUSH
48109: LD_INT 51
48111: PUSH
48112: LD_EXP 73
48116: PUSH
48117: LD_INT 32
48119: PUSH
48120: LD_INT 13
48122: PUSH
48123: LD_INT 52
48125: PUSH
48126: LD_INT 31
48128: PUSH
48129: EMPTY
48130: LIST
48131: LIST
48132: LIST
48133: LIST
48134: LIST
48135: LIST
48136: LIST
48137: IN
48138: OR
48139: AND
48140: IFFALSE 48448
// begin if un in mc_defender [ i ] then
48142: LD_VAR 0 1
48146: PUSH
48147: LD_EXP 112
48151: PUSH
48152: LD_VAR 0 3
48156: ARRAY
48157: IN
48158: IFFALSE 48197
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
48160: LD_ADDR_EXP 112
48164: PUSH
48165: LD_EXP 112
48169: PPUSH
48170: LD_VAR 0 3
48174: PPUSH
48175: LD_EXP 112
48179: PUSH
48180: LD_VAR 0 3
48184: ARRAY
48185: PUSH
48186: LD_VAR 0 1
48190: DIFF
48191: PPUSH
48192: CALL_OW 1
48196: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
48197: LD_ADDR_VAR 0 8
48201: PUSH
48202: LD_VAR 0 3
48206: PPUSH
48207: LD_INT 3
48209: PPUSH
48210: CALL 44866 0 2
48214: ST_TO_ADDR
// if fac then
48215: LD_VAR 0 8
48219: IFFALSE 48448
// begin for j in fac do
48221: LD_ADDR_VAR 0 4
48225: PUSH
48226: LD_VAR 0 8
48230: PUSH
48231: FOR_IN
48232: IFFALSE 48446
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
48234: LD_ADDR_VAR 0 9
48238: PUSH
48239: LD_VAR 0 8
48243: PPUSH
48244: LD_VAR 0 1
48248: PPUSH
48249: CALL_OW 265
48253: PPUSH
48254: LD_VAR 0 1
48258: PPUSH
48259: CALL_OW 262
48263: PPUSH
48264: LD_VAR 0 1
48268: PPUSH
48269: CALL_OW 263
48273: PPUSH
48274: LD_VAR 0 1
48278: PPUSH
48279: CALL_OW 264
48283: PPUSH
48284: CALL 53233 0 5
48288: ST_TO_ADDR
// if components then
48289: LD_VAR 0 9
48293: IFFALSE 48444
// begin if GetWeapon ( un ) = ar_control_tower then
48295: LD_VAR 0 1
48299: PPUSH
48300: CALL_OW 264
48304: PUSH
48305: LD_INT 31
48307: EQUAL
48308: IFFALSE 48425
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
48310: LD_VAR 0 1
48314: PPUSH
48315: CALL_OW 311
48319: PPUSH
48320: LD_INT 0
48322: PPUSH
48323: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
48327: LD_ADDR_EXP 130
48331: PUSH
48332: LD_EXP 130
48336: PPUSH
48337: LD_VAR 0 3
48341: PPUSH
48342: LD_EXP 130
48346: PUSH
48347: LD_VAR 0 3
48351: ARRAY
48352: PUSH
48353: LD_VAR 0 1
48357: PPUSH
48358: CALL_OW 311
48362: DIFF
48363: PPUSH
48364: CALL_OW 1
48368: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
48369: LD_ADDR_VAR 0 7
48373: PUSH
48374: LD_EXP 111
48378: PUSH
48379: LD_VAR 0 3
48383: ARRAY
48384: PPUSH
48385: LD_INT 1
48387: PPUSH
48388: LD_VAR 0 9
48392: PPUSH
48393: CALL_OW 2
48397: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
48398: LD_ADDR_EXP 111
48402: PUSH
48403: LD_EXP 111
48407: PPUSH
48408: LD_VAR 0 3
48412: PPUSH
48413: LD_VAR 0 7
48417: PPUSH
48418: CALL_OW 1
48422: ST_TO_ADDR
// end else
48423: GO 48442
// MC_InsertProduceList ( i , [ components ] ) ;
48425: LD_VAR 0 3
48429: PPUSH
48430: LD_VAR 0 9
48434: PUSH
48435: EMPTY
48436: LIST
48437: PPUSH
48438: CALL 44411 0 2
// break ;
48442: GO 48446
// end ; end ;
48444: GO 48231
48446: POP
48447: POP
// end ; end ; if GetType ( un ) = unit_building then
48448: LD_VAR 0 1
48452: PPUSH
48453: CALL_OW 247
48457: PUSH
48458: LD_INT 3
48460: EQUAL
48461: IFFALSE 48864
// begin btype := GetBType ( un ) ;
48463: LD_ADDR_VAR 0 5
48467: PUSH
48468: LD_VAR 0 1
48472: PPUSH
48473: CALL_OW 266
48477: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
48478: LD_VAR 0 5
48482: PUSH
48483: LD_INT 29
48485: PUSH
48486: LD_INT 30
48488: PUSH
48489: EMPTY
48490: LIST
48491: LIST
48492: IN
48493: IFFALSE 48566
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
48495: LD_VAR 0 1
48499: PPUSH
48500: CALL_OW 250
48504: PPUSH
48505: LD_VAR 0 1
48509: PPUSH
48510: CALL_OW 251
48514: PPUSH
48515: LD_VAR 0 1
48519: PPUSH
48520: CALL_OW 255
48524: PPUSH
48525: CALL_OW 440
48529: NOT
48530: IFFALSE 48566
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
48532: LD_VAR 0 1
48536: PPUSH
48537: CALL_OW 250
48541: PPUSH
48542: LD_VAR 0 1
48546: PPUSH
48547: CALL_OW 251
48551: PPUSH
48552: LD_VAR 0 1
48556: PPUSH
48557: CALL_OW 255
48561: PPUSH
48562: CALL_OW 441
// end ; if btype = b_warehouse then
48566: LD_VAR 0 5
48570: PUSH
48571: LD_INT 1
48573: EQUAL
48574: IFFALSE 48592
// begin btype := b_depot ;
48576: LD_ADDR_VAR 0 5
48580: PUSH
48581: LD_INT 0
48583: ST_TO_ADDR
// pos := 1 ;
48584: LD_ADDR_VAR 0 6
48588: PUSH
48589: LD_INT 1
48591: ST_TO_ADDR
// end ; if btype = b_factory then
48592: LD_VAR 0 5
48596: PUSH
48597: LD_INT 3
48599: EQUAL
48600: IFFALSE 48618
// begin btype := b_workshop ;
48602: LD_ADDR_VAR 0 5
48606: PUSH
48607: LD_INT 2
48609: ST_TO_ADDR
// pos := 1 ;
48610: LD_ADDR_VAR 0 6
48614: PUSH
48615: LD_INT 1
48617: ST_TO_ADDR
// end ; if btype = b_barracks then
48618: LD_VAR 0 5
48622: PUSH
48623: LD_INT 5
48625: EQUAL
48626: IFFALSE 48636
// btype := b_armoury ;
48628: LD_ADDR_VAR 0 5
48632: PUSH
48633: LD_INT 4
48635: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
48636: LD_VAR 0 5
48640: PUSH
48641: LD_INT 7
48643: PUSH
48644: LD_INT 8
48646: PUSH
48647: EMPTY
48648: LIST
48649: LIST
48650: IN
48651: IFFALSE 48661
// btype := b_lab ;
48653: LD_ADDR_VAR 0 5
48657: PUSH
48658: LD_INT 6
48660: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
48661: LD_ADDR_EXP 95
48665: PUSH
48666: LD_EXP 95
48670: PPUSH
48671: LD_VAR 0 3
48675: PUSH
48676: LD_EXP 95
48680: PUSH
48681: LD_VAR 0 3
48685: ARRAY
48686: PUSH
48687: LD_INT 1
48689: PLUS
48690: PUSH
48691: EMPTY
48692: LIST
48693: LIST
48694: PPUSH
48695: LD_VAR 0 5
48699: PUSH
48700: LD_VAR 0 1
48704: PPUSH
48705: CALL_OW 250
48709: PUSH
48710: LD_VAR 0 1
48714: PPUSH
48715: CALL_OW 251
48719: PUSH
48720: LD_VAR 0 1
48724: PPUSH
48725: CALL_OW 254
48729: PUSH
48730: EMPTY
48731: LIST
48732: LIST
48733: LIST
48734: LIST
48735: PPUSH
48736: CALL 55701 0 3
48740: ST_TO_ADDR
// if pos = 1 then
48741: LD_VAR 0 6
48745: PUSH
48746: LD_INT 1
48748: EQUAL
48749: IFFALSE 48864
// begin tmp := mc_build_list [ i ] ;
48751: LD_ADDR_VAR 0 7
48755: PUSH
48756: LD_EXP 95
48760: PUSH
48761: LD_VAR 0 3
48765: ARRAY
48766: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
48767: LD_VAR 0 7
48771: PPUSH
48772: LD_INT 2
48774: PUSH
48775: LD_INT 30
48777: PUSH
48778: LD_INT 0
48780: PUSH
48781: EMPTY
48782: LIST
48783: LIST
48784: PUSH
48785: LD_INT 30
48787: PUSH
48788: LD_INT 1
48790: PUSH
48791: EMPTY
48792: LIST
48793: LIST
48794: PUSH
48795: EMPTY
48796: LIST
48797: LIST
48798: LIST
48799: PPUSH
48800: CALL_OW 72
48804: IFFALSE 48814
// pos := 2 ;
48806: LD_ADDR_VAR 0 6
48810: PUSH
48811: LD_INT 2
48813: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
48814: LD_ADDR_VAR 0 7
48818: PUSH
48819: LD_VAR 0 7
48823: PPUSH
48824: LD_VAR 0 6
48828: PPUSH
48829: LD_VAR 0 7
48833: PPUSH
48834: CALL 56027 0 3
48838: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
48839: LD_ADDR_EXP 95
48843: PUSH
48844: LD_EXP 95
48848: PPUSH
48849: LD_VAR 0 3
48853: PPUSH
48854: LD_VAR 0 7
48858: PPUSH
48859: CALL_OW 1
48863: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
48864: LD_VAR 0 1
48868: PUSH
48869: LD_EXP 90
48873: PUSH
48874: LD_VAR 0 3
48878: ARRAY
48879: IN
48880: IFFALSE 48919
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
48882: LD_ADDR_EXP 90
48886: PUSH
48887: LD_EXP 90
48891: PPUSH
48892: LD_VAR 0 3
48896: PPUSH
48897: LD_EXP 90
48901: PUSH
48902: LD_VAR 0 3
48906: ARRAY
48907: PUSH
48908: LD_VAR 0 1
48912: DIFF
48913: PPUSH
48914: CALL_OW 1
48918: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
48919: LD_VAR 0 1
48923: PUSH
48924: LD_EXP 97
48928: PUSH
48929: LD_VAR 0 3
48933: ARRAY
48934: IN
48935: IFFALSE 48974
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
48937: LD_ADDR_EXP 97
48941: PUSH
48942: LD_EXP 97
48946: PPUSH
48947: LD_VAR 0 3
48951: PPUSH
48952: LD_EXP 97
48956: PUSH
48957: LD_VAR 0 3
48961: ARRAY
48962: PUSH
48963: LD_VAR 0 1
48967: DIFF
48968: PPUSH
48969: CALL_OW 1
48973: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
48974: LD_VAR 0 1
48978: PUSH
48979: LD_EXP 109
48983: PUSH
48984: LD_VAR 0 3
48988: ARRAY
48989: IN
48990: IFFALSE 49029
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
48992: LD_ADDR_EXP 109
48996: PUSH
48997: LD_EXP 109
49001: PPUSH
49002: LD_VAR 0 3
49006: PPUSH
49007: LD_EXP 109
49011: PUSH
49012: LD_VAR 0 3
49016: ARRAY
49017: PUSH
49018: LD_VAR 0 1
49022: DIFF
49023: PPUSH
49024: CALL_OW 1
49028: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
49029: LD_VAR 0 1
49033: PUSH
49034: LD_EXP 112
49038: PUSH
49039: LD_VAR 0 3
49043: ARRAY
49044: IN
49045: IFFALSE 49084
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
49047: LD_ADDR_EXP 112
49051: PUSH
49052: LD_EXP 112
49056: PPUSH
49057: LD_VAR 0 3
49061: PPUSH
49062: LD_EXP 112
49066: PUSH
49067: LD_VAR 0 3
49071: ARRAY
49072: PUSH
49073: LD_VAR 0 1
49077: DIFF
49078: PPUSH
49079: CALL_OW 1
49083: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
49084: LD_VAR 0 1
49088: PUSH
49089: LD_EXP 99
49093: PUSH
49094: LD_VAR 0 3
49098: ARRAY
49099: IN
49100: IFFALSE 49139
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
49102: LD_ADDR_EXP 99
49106: PUSH
49107: LD_EXP 99
49111: PPUSH
49112: LD_VAR 0 3
49116: PPUSH
49117: LD_EXP 99
49121: PUSH
49122: LD_VAR 0 3
49126: ARRAY
49127: PUSH
49128: LD_VAR 0 1
49132: DIFF
49133: PPUSH
49134: CALL_OW 1
49138: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
49139: LD_VAR 0 1
49143: PUSH
49144: LD_EXP 98
49148: PUSH
49149: LD_VAR 0 3
49153: ARRAY
49154: IN
49155: IFFALSE 49194
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
49157: LD_ADDR_EXP 98
49161: PUSH
49162: LD_EXP 98
49166: PPUSH
49167: LD_VAR 0 3
49171: PPUSH
49172: LD_EXP 98
49176: PUSH
49177: LD_VAR 0 3
49181: ARRAY
49182: PUSH
49183: LD_VAR 0 1
49187: DIFF
49188: PPUSH
49189: CALL_OW 1
49193: ST_TO_ADDR
// end ; break ;
49194: GO 49198
// end ;
49196: GO 47844
49198: POP
49199: POP
// end ;
49200: LD_VAR 0 2
49204: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
49205: LD_INT 0
49207: PPUSH
49208: PPUSH
49209: PPUSH
// if not mc_bases or not skirmish then
49210: LD_EXP 90
49214: NOT
49215: PUSH
49216: LD_EXP 88
49220: NOT
49221: OR
49222: IFFALSE 49226
// exit ;
49224: GO 49441
// for i = 1 to mc_bases do
49226: LD_ADDR_VAR 0 3
49230: PUSH
49231: DOUBLE
49232: LD_INT 1
49234: DEC
49235: ST_TO_ADDR
49236: LD_EXP 90
49240: PUSH
49241: FOR_TO
49242: IFFALSE 49439
// begin if building in mc_construct_list [ i ] then
49244: LD_VAR 0 1
49248: PUSH
49249: LD_EXP 97
49253: PUSH
49254: LD_VAR 0 3
49258: ARRAY
49259: IN
49260: IFFALSE 49437
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
49262: LD_ADDR_EXP 97
49266: PUSH
49267: LD_EXP 97
49271: PPUSH
49272: LD_VAR 0 3
49276: PPUSH
49277: LD_EXP 97
49281: PUSH
49282: LD_VAR 0 3
49286: ARRAY
49287: PUSH
49288: LD_VAR 0 1
49292: DIFF
49293: PPUSH
49294: CALL_OW 1
49298: ST_TO_ADDR
// if building in mc_lab [ i ] then
49299: LD_VAR 0 1
49303: PUSH
49304: LD_EXP 123
49308: PUSH
49309: LD_VAR 0 3
49313: ARRAY
49314: IN
49315: IFFALSE 49370
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
49317: LD_ADDR_EXP 124
49321: PUSH
49322: LD_EXP 124
49326: PPUSH
49327: LD_VAR 0 3
49331: PPUSH
49332: LD_EXP 124
49336: PUSH
49337: LD_VAR 0 3
49341: ARRAY
49342: PPUSH
49343: LD_INT 1
49345: PPUSH
49346: LD_EXP 124
49350: PUSH
49351: LD_VAR 0 3
49355: ARRAY
49356: PPUSH
49357: LD_INT 0
49359: PPUSH
49360: CALL 55119 0 4
49364: PPUSH
49365: CALL_OW 1
49369: ST_TO_ADDR
// if not building in mc_bases [ i ] then
49370: LD_VAR 0 1
49374: PUSH
49375: LD_EXP 90
49379: PUSH
49380: LD_VAR 0 3
49384: ARRAY
49385: IN
49386: NOT
49387: IFFALSE 49433
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
49389: LD_ADDR_EXP 90
49393: PUSH
49394: LD_EXP 90
49398: PPUSH
49399: LD_VAR 0 3
49403: PUSH
49404: LD_EXP 90
49408: PUSH
49409: LD_VAR 0 3
49413: ARRAY
49414: PUSH
49415: LD_INT 1
49417: PLUS
49418: PUSH
49419: EMPTY
49420: LIST
49421: LIST
49422: PPUSH
49423: LD_VAR 0 1
49427: PPUSH
49428: CALL 55701 0 3
49432: ST_TO_ADDR
// exit ;
49433: POP
49434: POP
49435: GO 49441
// end ; end ;
49437: GO 49241
49439: POP
49440: POP
// end ;
49441: LD_VAR 0 2
49445: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
49446: LD_INT 0
49448: PPUSH
49449: PPUSH
49450: PPUSH
49451: PPUSH
49452: PPUSH
49453: PPUSH
49454: PPUSH
// if not mc_bases or not skirmish then
49455: LD_EXP 90
49459: NOT
49460: PUSH
49461: LD_EXP 88
49465: NOT
49466: OR
49467: IFFALSE 49471
// exit ;
49469: GO 50132
// for i = 1 to mc_bases do
49471: LD_ADDR_VAR 0 3
49475: PUSH
49476: DOUBLE
49477: LD_INT 1
49479: DEC
49480: ST_TO_ADDR
49481: LD_EXP 90
49485: PUSH
49486: FOR_TO
49487: IFFALSE 50130
// begin if building in mc_construct_list [ i ] then
49489: LD_VAR 0 1
49493: PUSH
49494: LD_EXP 97
49498: PUSH
49499: LD_VAR 0 3
49503: ARRAY
49504: IN
49505: IFFALSE 50128
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
49507: LD_ADDR_EXP 97
49511: PUSH
49512: LD_EXP 97
49516: PPUSH
49517: LD_VAR 0 3
49521: PPUSH
49522: LD_EXP 97
49526: PUSH
49527: LD_VAR 0 3
49531: ARRAY
49532: PUSH
49533: LD_VAR 0 1
49537: DIFF
49538: PPUSH
49539: CALL_OW 1
49543: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
49544: LD_ADDR_EXP 90
49548: PUSH
49549: LD_EXP 90
49553: PPUSH
49554: LD_VAR 0 3
49558: PUSH
49559: LD_EXP 90
49563: PUSH
49564: LD_VAR 0 3
49568: ARRAY
49569: PUSH
49570: LD_INT 1
49572: PLUS
49573: PUSH
49574: EMPTY
49575: LIST
49576: LIST
49577: PPUSH
49578: LD_VAR 0 1
49582: PPUSH
49583: CALL 55701 0 3
49587: ST_TO_ADDR
// btype := GetBType ( building ) ;
49588: LD_ADDR_VAR 0 5
49592: PUSH
49593: LD_VAR 0 1
49597: PPUSH
49598: CALL_OW 266
49602: ST_TO_ADDR
// side := GetSide ( building ) ;
49603: LD_ADDR_VAR 0 8
49607: PUSH
49608: LD_VAR 0 1
49612: PPUSH
49613: CALL_OW 255
49617: ST_TO_ADDR
// if btype = b_lab then
49618: LD_VAR 0 5
49622: PUSH
49623: LD_INT 6
49625: EQUAL
49626: IFFALSE 49676
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
49628: LD_ADDR_EXP 123
49632: PUSH
49633: LD_EXP 123
49637: PPUSH
49638: LD_VAR 0 3
49642: PUSH
49643: LD_EXP 123
49647: PUSH
49648: LD_VAR 0 3
49652: ARRAY
49653: PUSH
49654: LD_INT 1
49656: PLUS
49657: PUSH
49658: EMPTY
49659: LIST
49660: LIST
49661: PPUSH
49662: LD_VAR 0 1
49666: PPUSH
49667: CALL 55701 0 3
49671: ST_TO_ADDR
// exit ;
49672: POP
49673: POP
49674: GO 50132
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
49676: LD_VAR 0 5
49680: PUSH
49681: LD_INT 0
49683: PUSH
49684: LD_INT 2
49686: PUSH
49687: LD_INT 4
49689: PUSH
49690: EMPTY
49691: LIST
49692: LIST
49693: LIST
49694: IN
49695: IFFALSE 49819
// begin if btype = b_armoury then
49697: LD_VAR 0 5
49701: PUSH
49702: LD_INT 4
49704: EQUAL
49705: IFFALSE 49715
// btype := b_barracks ;
49707: LD_ADDR_VAR 0 5
49711: PUSH
49712: LD_INT 5
49714: ST_TO_ADDR
// if btype = b_depot then
49715: LD_VAR 0 5
49719: PUSH
49720: LD_INT 0
49722: EQUAL
49723: IFFALSE 49733
// btype := b_warehouse ;
49725: LD_ADDR_VAR 0 5
49729: PUSH
49730: LD_INT 1
49732: ST_TO_ADDR
// if btype = b_workshop then
49733: LD_VAR 0 5
49737: PUSH
49738: LD_INT 2
49740: EQUAL
49741: IFFALSE 49751
// btype := b_factory ;
49743: LD_ADDR_VAR 0 5
49747: PUSH
49748: LD_INT 3
49750: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
49751: LD_VAR 0 5
49755: PPUSH
49756: LD_VAR 0 8
49760: PPUSH
49761: CALL_OW 323
49765: PUSH
49766: LD_INT 1
49768: EQUAL
49769: IFFALSE 49815
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
49771: LD_ADDR_EXP 122
49775: PUSH
49776: LD_EXP 122
49780: PPUSH
49781: LD_VAR 0 3
49785: PUSH
49786: LD_EXP 122
49790: PUSH
49791: LD_VAR 0 3
49795: ARRAY
49796: PUSH
49797: LD_INT 1
49799: PLUS
49800: PUSH
49801: EMPTY
49802: LIST
49803: LIST
49804: PPUSH
49805: LD_VAR 0 1
49809: PPUSH
49810: CALL 55701 0 3
49814: ST_TO_ADDR
// exit ;
49815: POP
49816: POP
49817: GO 50132
// end ; if btype in [ b_bunker , b_turret ] then
49819: LD_VAR 0 5
49823: PUSH
49824: LD_INT 32
49826: PUSH
49827: LD_INT 33
49829: PUSH
49830: EMPTY
49831: LIST
49832: LIST
49833: IN
49834: IFFALSE 50124
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
49836: LD_ADDR_EXP 98
49840: PUSH
49841: LD_EXP 98
49845: PPUSH
49846: LD_VAR 0 3
49850: PUSH
49851: LD_EXP 98
49855: PUSH
49856: LD_VAR 0 3
49860: ARRAY
49861: PUSH
49862: LD_INT 1
49864: PLUS
49865: PUSH
49866: EMPTY
49867: LIST
49868: LIST
49869: PPUSH
49870: LD_VAR 0 1
49874: PPUSH
49875: CALL 55701 0 3
49879: ST_TO_ADDR
// if btype = b_bunker then
49880: LD_VAR 0 5
49884: PUSH
49885: LD_INT 32
49887: EQUAL
49888: IFFALSE 50124
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
49890: LD_ADDR_EXP 99
49894: PUSH
49895: LD_EXP 99
49899: PPUSH
49900: LD_VAR 0 3
49904: PUSH
49905: LD_EXP 99
49909: PUSH
49910: LD_VAR 0 3
49914: ARRAY
49915: PUSH
49916: LD_INT 1
49918: PLUS
49919: PUSH
49920: EMPTY
49921: LIST
49922: LIST
49923: PPUSH
49924: LD_VAR 0 1
49928: PPUSH
49929: CALL 55701 0 3
49933: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
49934: LD_ADDR_VAR 0 6
49938: PUSH
49939: LD_EXP 90
49943: PUSH
49944: LD_VAR 0 3
49948: ARRAY
49949: PPUSH
49950: LD_INT 25
49952: PUSH
49953: LD_INT 1
49955: PUSH
49956: EMPTY
49957: LIST
49958: LIST
49959: PUSH
49960: LD_INT 3
49962: PUSH
49963: LD_INT 54
49965: PUSH
49966: EMPTY
49967: LIST
49968: PUSH
49969: EMPTY
49970: LIST
49971: LIST
49972: PUSH
49973: EMPTY
49974: LIST
49975: LIST
49976: PPUSH
49977: CALL_OW 72
49981: ST_TO_ADDR
// if tmp then
49982: LD_VAR 0 6
49986: IFFALSE 49992
// exit ;
49988: POP
49989: POP
49990: GO 50132
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
49992: LD_ADDR_VAR 0 6
49996: PUSH
49997: LD_EXP 90
50001: PUSH
50002: LD_VAR 0 3
50006: ARRAY
50007: PPUSH
50008: LD_INT 2
50010: PUSH
50011: LD_INT 30
50013: PUSH
50014: LD_INT 4
50016: PUSH
50017: EMPTY
50018: LIST
50019: LIST
50020: PUSH
50021: LD_INT 30
50023: PUSH
50024: LD_INT 5
50026: PUSH
50027: EMPTY
50028: LIST
50029: LIST
50030: PUSH
50031: EMPTY
50032: LIST
50033: LIST
50034: LIST
50035: PPUSH
50036: CALL_OW 72
50040: ST_TO_ADDR
// if not tmp then
50041: LD_VAR 0 6
50045: NOT
50046: IFFALSE 50052
// exit ;
50048: POP
50049: POP
50050: GO 50132
// for j in tmp do
50052: LD_ADDR_VAR 0 4
50056: PUSH
50057: LD_VAR 0 6
50061: PUSH
50062: FOR_IN
50063: IFFALSE 50122
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
50065: LD_ADDR_VAR 0 7
50069: PUSH
50070: LD_VAR 0 4
50074: PPUSH
50075: CALL_OW 313
50079: PPUSH
50080: LD_INT 25
50082: PUSH
50083: LD_INT 1
50085: PUSH
50086: EMPTY
50087: LIST
50088: LIST
50089: PPUSH
50090: CALL_OW 72
50094: ST_TO_ADDR
// if units then
50095: LD_VAR 0 7
50099: IFFALSE 50120
// begin ComExitBuilding ( units [ 1 ] ) ;
50101: LD_VAR 0 7
50105: PUSH
50106: LD_INT 1
50108: ARRAY
50109: PPUSH
50110: CALL_OW 122
// exit ;
50114: POP
50115: POP
50116: POP
50117: POP
50118: GO 50132
// end ; end ;
50120: GO 50062
50122: POP
50123: POP
// end ; end ; exit ;
50124: POP
50125: POP
50126: GO 50132
// end ; end ;
50128: GO 49486
50130: POP
50131: POP
// end ;
50132: LD_VAR 0 2
50136: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
50137: LD_INT 0
50139: PPUSH
50140: PPUSH
50141: PPUSH
50142: PPUSH
50143: PPUSH
50144: PPUSH
50145: PPUSH
// if not mc_bases or not skirmish then
50146: LD_EXP 90
50150: NOT
50151: PUSH
50152: LD_EXP 88
50156: NOT
50157: OR
50158: IFFALSE 50162
// exit ;
50160: GO 50393
// btype := GetBType ( building ) ;
50162: LD_ADDR_VAR 0 6
50166: PUSH
50167: LD_VAR 0 1
50171: PPUSH
50172: CALL_OW 266
50176: ST_TO_ADDR
// x := GetX ( building ) ;
50177: LD_ADDR_VAR 0 7
50181: PUSH
50182: LD_VAR 0 1
50186: PPUSH
50187: CALL_OW 250
50191: ST_TO_ADDR
// y := GetY ( building ) ;
50192: LD_ADDR_VAR 0 8
50196: PUSH
50197: LD_VAR 0 1
50201: PPUSH
50202: CALL_OW 251
50206: ST_TO_ADDR
// d := GetDir ( building ) ;
50207: LD_ADDR_VAR 0 9
50211: PUSH
50212: LD_VAR 0 1
50216: PPUSH
50217: CALL_OW 254
50221: ST_TO_ADDR
// for i = 1 to mc_bases do
50222: LD_ADDR_VAR 0 4
50226: PUSH
50227: DOUBLE
50228: LD_INT 1
50230: DEC
50231: ST_TO_ADDR
50232: LD_EXP 90
50236: PUSH
50237: FOR_TO
50238: IFFALSE 50391
// begin if not mc_build_list [ i ] then
50240: LD_EXP 95
50244: PUSH
50245: LD_VAR 0 4
50249: ARRAY
50250: NOT
50251: IFFALSE 50255
// continue ;
50253: GO 50237
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
50255: LD_VAR 0 6
50259: PUSH
50260: LD_VAR 0 7
50264: PUSH
50265: LD_VAR 0 8
50269: PUSH
50270: LD_VAR 0 9
50274: PUSH
50275: EMPTY
50276: LIST
50277: LIST
50278: LIST
50279: LIST
50280: PPUSH
50281: LD_EXP 95
50285: PUSH
50286: LD_VAR 0 4
50290: ARRAY
50291: PUSH
50292: LD_INT 1
50294: ARRAY
50295: PPUSH
50296: CALL 61870 0 2
50300: IFFALSE 50389
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
50302: LD_ADDR_EXP 95
50306: PUSH
50307: LD_EXP 95
50311: PPUSH
50312: LD_VAR 0 4
50316: PPUSH
50317: LD_EXP 95
50321: PUSH
50322: LD_VAR 0 4
50326: ARRAY
50327: PPUSH
50328: LD_INT 1
50330: PPUSH
50331: CALL_OW 3
50335: PPUSH
50336: CALL_OW 1
50340: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
50341: LD_ADDR_EXP 97
50345: PUSH
50346: LD_EXP 97
50350: PPUSH
50351: LD_VAR 0 4
50355: PUSH
50356: LD_EXP 97
50360: PUSH
50361: LD_VAR 0 4
50365: ARRAY
50366: PUSH
50367: LD_INT 1
50369: PLUS
50370: PUSH
50371: EMPTY
50372: LIST
50373: LIST
50374: PPUSH
50375: LD_VAR 0 1
50379: PPUSH
50380: CALL 55701 0 3
50384: ST_TO_ADDR
// exit ;
50385: POP
50386: POP
50387: GO 50393
// end ; end ;
50389: GO 50237
50391: POP
50392: POP
// end ;
50393: LD_VAR 0 3
50397: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
50398: LD_INT 0
50400: PPUSH
50401: PPUSH
50402: PPUSH
// if not mc_bases or not skirmish then
50403: LD_EXP 90
50407: NOT
50408: PUSH
50409: LD_EXP 88
50413: NOT
50414: OR
50415: IFFALSE 50419
// exit ;
50417: GO 50609
// for i = 1 to mc_bases do
50419: LD_ADDR_VAR 0 4
50423: PUSH
50424: DOUBLE
50425: LD_INT 1
50427: DEC
50428: ST_TO_ADDR
50429: LD_EXP 90
50433: PUSH
50434: FOR_TO
50435: IFFALSE 50522
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
50437: LD_VAR 0 1
50441: PUSH
50442: LD_EXP 98
50446: PUSH
50447: LD_VAR 0 4
50451: ARRAY
50452: IN
50453: PUSH
50454: LD_VAR 0 1
50458: PUSH
50459: LD_EXP 99
50463: PUSH
50464: LD_VAR 0 4
50468: ARRAY
50469: IN
50470: NOT
50471: AND
50472: IFFALSE 50520
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
50474: LD_ADDR_EXP 99
50478: PUSH
50479: LD_EXP 99
50483: PPUSH
50484: LD_VAR 0 4
50488: PUSH
50489: LD_EXP 99
50493: PUSH
50494: LD_VAR 0 4
50498: ARRAY
50499: PUSH
50500: LD_INT 1
50502: PLUS
50503: PUSH
50504: EMPTY
50505: LIST
50506: LIST
50507: PPUSH
50508: LD_VAR 0 1
50512: PPUSH
50513: CALL 55701 0 3
50517: ST_TO_ADDR
// break ;
50518: GO 50522
// end ; end ;
50520: GO 50434
50522: POP
50523: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
50524: LD_VAR 0 1
50528: PPUSH
50529: CALL_OW 257
50533: PUSH
50534: LD_EXP 116
50538: IN
50539: PUSH
50540: LD_VAR 0 1
50544: PPUSH
50545: CALL_OW 266
50549: PUSH
50550: LD_INT 5
50552: EQUAL
50553: AND
50554: PUSH
50555: LD_VAR 0 2
50559: PPUSH
50560: CALL_OW 110
50564: PUSH
50565: LD_INT 18
50567: NONEQUAL
50568: AND
50569: IFFALSE 50609
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
50571: LD_VAR 0 2
50575: PPUSH
50576: CALL_OW 257
50580: PUSH
50581: LD_INT 5
50583: PUSH
50584: LD_INT 8
50586: PUSH
50587: LD_INT 9
50589: PUSH
50590: EMPTY
50591: LIST
50592: LIST
50593: LIST
50594: IN
50595: IFFALSE 50609
// SetClass ( unit , 1 ) ;
50597: LD_VAR 0 2
50601: PPUSH
50602: LD_INT 1
50604: PPUSH
50605: CALL_OW 336
// end ;
50609: LD_VAR 0 3
50613: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
50614: LD_INT 0
50616: PPUSH
50617: PPUSH
// if not mc_bases or not skirmish then
50618: LD_EXP 90
50622: NOT
50623: PUSH
50624: LD_EXP 88
50628: NOT
50629: OR
50630: IFFALSE 50634
// exit ;
50632: GO 50750
// if GetLives ( abandoned_vehicle ) > 250 then
50634: LD_VAR 0 2
50638: PPUSH
50639: CALL_OW 256
50643: PUSH
50644: LD_INT 250
50646: GREATER
50647: IFFALSE 50651
// exit ;
50649: GO 50750
// for i = 1 to mc_bases do
50651: LD_ADDR_VAR 0 6
50655: PUSH
50656: DOUBLE
50657: LD_INT 1
50659: DEC
50660: ST_TO_ADDR
50661: LD_EXP 90
50665: PUSH
50666: FOR_TO
50667: IFFALSE 50748
// begin if driver in mc_bases [ i ] then
50669: LD_VAR 0 1
50673: PUSH
50674: LD_EXP 90
50678: PUSH
50679: LD_VAR 0 6
50683: ARRAY
50684: IN
50685: IFFALSE 50746
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
50687: LD_VAR 0 1
50691: PPUSH
50692: LD_EXP 90
50696: PUSH
50697: LD_VAR 0 6
50701: ARRAY
50702: PPUSH
50703: LD_INT 2
50705: PUSH
50706: LD_INT 30
50708: PUSH
50709: LD_INT 0
50711: PUSH
50712: EMPTY
50713: LIST
50714: LIST
50715: PUSH
50716: LD_INT 30
50718: PUSH
50719: LD_INT 1
50721: PUSH
50722: EMPTY
50723: LIST
50724: LIST
50725: PUSH
50726: EMPTY
50727: LIST
50728: LIST
50729: LIST
50730: PPUSH
50731: CALL_OW 72
50735: PUSH
50736: LD_INT 1
50738: ARRAY
50739: PPUSH
50740: CALL_OW 112
// break ;
50744: GO 50748
// end ; end ;
50746: GO 50666
50748: POP
50749: POP
// end ; end_of_file
50750: LD_VAR 0 5
50754: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
50755: LD_INT 0
50757: PPUSH
50758: PPUSH
// if exist_mode then
50759: LD_VAR 0 2
50763: IFFALSE 50788
// unit := CreateCharacter ( prefix & ident ) else
50765: LD_ADDR_VAR 0 5
50769: PUSH
50770: LD_VAR 0 3
50774: PUSH
50775: LD_VAR 0 1
50779: STR
50780: PPUSH
50781: CALL_OW 34
50785: ST_TO_ADDR
50786: GO 50803
// unit := NewCharacter ( ident ) ;
50788: LD_ADDR_VAR 0 5
50792: PUSH
50793: LD_VAR 0 1
50797: PPUSH
50798: CALL_OW 25
50802: ST_TO_ADDR
// result := unit ;
50803: LD_ADDR_VAR 0 4
50807: PUSH
50808: LD_VAR 0 5
50812: ST_TO_ADDR
// end ;
50813: LD_VAR 0 4
50817: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
50818: LD_INT 0
50820: PPUSH
50821: PPUSH
// if not side or not nation then
50822: LD_VAR 0 1
50826: NOT
50827: PUSH
50828: LD_VAR 0 2
50832: NOT
50833: OR
50834: IFFALSE 50838
// exit ;
50836: GO 51602
// case nation of nation_american :
50838: LD_VAR 0 2
50842: PUSH
50843: LD_INT 1
50845: DOUBLE
50846: EQUAL
50847: IFTRUE 50851
50849: GO 51065
50851: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
50852: LD_ADDR_VAR 0 4
50856: PUSH
50857: LD_INT 35
50859: PUSH
50860: LD_INT 45
50862: PUSH
50863: LD_INT 46
50865: PUSH
50866: LD_INT 47
50868: PUSH
50869: LD_INT 82
50871: PUSH
50872: LD_INT 83
50874: PUSH
50875: LD_INT 84
50877: PUSH
50878: LD_INT 85
50880: PUSH
50881: LD_INT 86
50883: PUSH
50884: LD_INT 1
50886: PUSH
50887: LD_INT 2
50889: PUSH
50890: LD_INT 6
50892: PUSH
50893: LD_INT 15
50895: PUSH
50896: LD_INT 16
50898: PUSH
50899: LD_INT 7
50901: PUSH
50902: LD_INT 12
50904: PUSH
50905: LD_INT 13
50907: PUSH
50908: LD_INT 10
50910: PUSH
50911: LD_INT 14
50913: PUSH
50914: LD_INT 20
50916: PUSH
50917: LD_INT 21
50919: PUSH
50920: LD_INT 22
50922: PUSH
50923: LD_INT 25
50925: PUSH
50926: LD_INT 32
50928: PUSH
50929: LD_INT 27
50931: PUSH
50932: LD_INT 36
50934: PUSH
50935: LD_INT 69
50937: PUSH
50938: LD_INT 39
50940: PUSH
50941: LD_INT 34
50943: PUSH
50944: LD_INT 40
50946: PUSH
50947: LD_INT 48
50949: PUSH
50950: LD_INT 49
50952: PUSH
50953: LD_INT 50
50955: PUSH
50956: LD_INT 51
50958: PUSH
50959: LD_INT 52
50961: PUSH
50962: LD_INT 53
50964: PUSH
50965: LD_INT 54
50967: PUSH
50968: LD_INT 55
50970: PUSH
50971: LD_INT 56
50973: PUSH
50974: LD_INT 57
50976: PUSH
50977: LD_INT 58
50979: PUSH
50980: LD_INT 59
50982: PUSH
50983: LD_INT 60
50985: PUSH
50986: LD_INT 61
50988: PUSH
50989: LD_INT 62
50991: PUSH
50992: LD_INT 80
50994: PUSH
50995: LD_INT 82
50997: PUSH
50998: LD_INT 83
51000: PUSH
51001: LD_INT 84
51003: PUSH
51004: LD_INT 85
51006: PUSH
51007: LD_INT 86
51009: PUSH
51010: EMPTY
51011: LIST
51012: LIST
51013: LIST
51014: LIST
51015: LIST
51016: LIST
51017: LIST
51018: LIST
51019: LIST
51020: LIST
51021: LIST
51022: LIST
51023: LIST
51024: LIST
51025: LIST
51026: LIST
51027: LIST
51028: LIST
51029: LIST
51030: LIST
51031: LIST
51032: LIST
51033: LIST
51034: LIST
51035: LIST
51036: LIST
51037: LIST
51038: LIST
51039: LIST
51040: LIST
51041: LIST
51042: LIST
51043: LIST
51044: LIST
51045: LIST
51046: LIST
51047: LIST
51048: LIST
51049: LIST
51050: LIST
51051: LIST
51052: LIST
51053: LIST
51054: LIST
51055: LIST
51056: LIST
51057: LIST
51058: LIST
51059: LIST
51060: LIST
51061: LIST
51062: ST_TO_ADDR
51063: GO 51526
51065: LD_INT 2
51067: DOUBLE
51068: EQUAL
51069: IFTRUE 51073
51071: GO 51295
51073: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
51074: LD_ADDR_VAR 0 4
51078: PUSH
51079: LD_INT 35
51081: PUSH
51082: LD_INT 45
51084: PUSH
51085: LD_INT 46
51087: PUSH
51088: LD_INT 47
51090: PUSH
51091: LD_INT 82
51093: PUSH
51094: LD_INT 83
51096: PUSH
51097: LD_INT 84
51099: PUSH
51100: LD_INT 85
51102: PUSH
51103: LD_INT 87
51105: PUSH
51106: LD_INT 70
51108: PUSH
51109: LD_INT 1
51111: PUSH
51112: LD_INT 11
51114: PUSH
51115: LD_INT 3
51117: PUSH
51118: LD_INT 4
51120: PUSH
51121: LD_INT 5
51123: PUSH
51124: LD_INT 6
51126: PUSH
51127: LD_INT 15
51129: PUSH
51130: LD_INT 18
51132: PUSH
51133: LD_INT 7
51135: PUSH
51136: LD_INT 17
51138: PUSH
51139: LD_INT 8
51141: PUSH
51142: LD_INT 20
51144: PUSH
51145: LD_INT 21
51147: PUSH
51148: LD_INT 22
51150: PUSH
51151: LD_INT 72
51153: PUSH
51154: LD_INT 26
51156: PUSH
51157: LD_INT 69
51159: PUSH
51160: LD_INT 39
51162: PUSH
51163: LD_INT 40
51165: PUSH
51166: LD_INT 41
51168: PUSH
51169: LD_INT 42
51171: PUSH
51172: LD_INT 43
51174: PUSH
51175: LD_INT 48
51177: PUSH
51178: LD_INT 49
51180: PUSH
51181: LD_INT 50
51183: PUSH
51184: LD_INT 51
51186: PUSH
51187: LD_INT 52
51189: PUSH
51190: LD_INT 53
51192: PUSH
51193: LD_INT 54
51195: PUSH
51196: LD_INT 55
51198: PUSH
51199: LD_INT 56
51201: PUSH
51202: LD_INT 60
51204: PUSH
51205: LD_INT 61
51207: PUSH
51208: LD_INT 62
51210: PUSH
51211: LD_INT 66
51213: PUSH
51214: LD_INT 67
51216: PUSH
51217: LD_INT 68
51219: PUSH
51220: LD_INT 81
51222: PUSH
51223: LD_INT 82
51225: PUSH
51226: LD_INT 83
51228: PUSH
51229: LD_INT 84
51231: PUSH
51232: LD_INT 85
51234: PUSH
51235: LD_INT 87
51237: PUSH
51238: EMPTY
51239: LIST
51240: LIST
51241: LIST
51242: LIST
51243: LIST
51244: LIST
51245: LIST
51246: LIST
51247: LIST
51248: LIST
51249: LIST
51250: LIST
51251: LIST
51252: LIST
51253: LIST
51254: LIST
51255: LIST
51256: LIST
51257: LIST
51258: LIST
51259: LIST
51260: LIST
51261: LIST
51262: LIST
51263: LIST
51264: LIST
51265: LIST
51266: LIST
51267: LIST
51268: LIST
51269: LIST
51270: LIST
51271: LIST
51272: LIST
51273: LIST
51274: LIST
51275: LIST
51276: LIST
51277: LIST
51278: LIST
51279: LIST
51280: LIST
51281: LIST
51282: LIST
51283: LIST
51284: LIST
51285: LIST
51286: LIST
51287: LIST
51288: LIST
51289: LIST
51290: LIST
51291: LIST
51292: ST_TO_ADDR
51293: GO 51526
51295: LD_INT 3
51297: DOUBLE
51298: EQUAL
51299: IFTRUE 51303
51301: GO 51525
51303: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
51304: LD_ADDR_VAR 0 4
51308: PUSH
51309: LD_INT 46
51311: PUSH
51312: LD_INT 47
51314: PUSH
51315: LD_INT 1
51317: PUSH
51318: LD_INT 2
51320: PUSH
51321: LD_INT 82
51323: PUSH
51324: LD_INT 83
51326: PUSH
51327: LD_INT 84
51329: PUSH
51330: LD_INT 85
51332: PUSH
51333: LD_INT 86
51335: PUSH
51336: LD_INT 11
51338: PUSH
51339: LD_INT 9
51341: PUSH
51342: LD_INT 20
51344: PUSH
51345: LD_INT 19
51347: PUSH
51348: LD_INT 21
51350: PUSH
51351: LD_INT 24
51353: PUSH
51354: LD_INT 22
51356: PUSH
51357: LD_INT 25
51359: PUSH
51360: LD_INT 28
51362: PUSH
51363: LD_INT 29
51365: PUSH
51366: LD_INT 30
51368: PUSH
51369: LD_INT 31
51371: PUSH
51372: LD_INT 37
51374: PUSH
51375: LD_INT 38
51377: PUSH
51378: LD_INT 32
51380: PUSH
51381: LD_INT 27
51383: PUSH
51384: LD_INT 33
51386: PUSH
51387: LD_INT 69
51389: PUSH
51390: LD_INT 39
51392: PUSH
51393: LD_INT 34
51395: PUSH
51396: LD_INT 40
51398: PUSH
51399: LD_INT 71
51401: PUSH
51402: LD_INT 23
51404: PUSH
51405: LD_INT 44
51407: PUSH
51408: LD_INT 48
51410: PUSH
51411: LD_INT 49
51413: PUSH
51414: LD_INT 50
51416: PUSH
51417: LD_INT 51
51419: PUSH
51420: LD_INT 52
51422: PUSH
51423: LD_INT 53
51425: PUSH
51426: LD_INT 54
51428: PUSH
51429: LD_INT 55
51431: PUSH
51432: LD_INT 56
51434: PUSH
51435: LD_INT 57
51437: PUSH
51438: LD_INT 58
51440: PUSH
51441: LD_INT 59
51443: PUSH
51444: LD_INT 63
51446: PUSH
51447: LD_INT 64
51449: PUSH
51450: LD_INT 65
51452: PUSH
51453: LD_INT 82
51455: PUSH
51456: LD_INT 83
51458: PUSH
51459: LD_INT 84
51461: PUSH
51462: LD_INT 85
51464: PUSH
51465: LD_INT 86
51467: PUSH
51468: EMPTY
51469: LIST
51470: LIST
51471: LIST
51472: LIST
51473: LIST
51474: LIST
51475: LIST
51476: LIST
51477: LIST
51478: LIST
51479: LIST
51480: LIST
51481: LIST
51482: LIST
51483: LIST
51484: LIST
51485: LIST
51486: LIST
51487: LIST
51488: LIST
51489: LIST
51490: LIST
51491: LIST
51492: LIST
51493: LIST
51494: LIST
51495: LIST
51496: LIST
51497: LIST
51498: LIST
51499: LIST
51500: LIST
51501: LIST
51502: LIST
51503: LIST
51504: LIST
51505: LIST
51506: LIST
51507: LIST
51508: LIST
51509: LIST
51510: LIST
51511: LIST
51512: LIST
51513: LIST
51514: LIST
51515: LIST
51516: LIST
51517: LIST
51518: LIST
51519: LIST
51520: LIST
51521: LIST
51522: ST_TO_ADDR
51523: GO 51526
51525: POP
// if state > - 1 and state < 3 then
51526: LD_VAR 0 3
51530: PUSH
51531: LD_INT 1
51533: NEG
51534: GREATER
51535: PUSH
51536: LD_VAR 0 3
51540: PUSH
51541: LD_INT 3
51543: LESS
51544: AND
51545: IFFALSE 51602
// for i in result do
51547: LD_ADDR_VAR 0 5
51551: PUSH
51552: LD_VAR 0 4
51556: PUSH
51557: FOR_IN
51558: IFFALSE 51600
// if GetTech ( i , side ) <> state then
51560: LD_VAR 0 5
51564: PPUSH
51565: LD_VAR 0 1
51569: PPUSH
51570: CALL_OW 321
51574: PUSH
51575: LD_VAR 0 3
51579: NONEQUAL
51580: IFFALSE 51598
// result := result diff i ;
51582: LD_ADDR_VAR 0 4
51586: PUSH
51587: LD_VAR 0 4
51591: PUSH
51592: LD_VAR 0 5
51596: DIFF
51597: ST_TO_ADDR
51598: GO 51557
51600: POP
51601: POP
// end ;
51602: LD_VAR 0 4
51606: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
51607: LD_INT 0
51609: PPUSH
51610: PPUSH
51611: PPUSH
// result := true ;
51612: LD_ADDR_VAR 0 3
51616: PUSH
51617: LD_INT 1
51619: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
51620: LD_ADDR_VAR 0 5
51624: PUSH
51625: LD_VAR 0 2
51629: PPUSH
51630: CALL_OW 480
51634: ST_TO_ADDR
// if not tmp then
51635: LD_VAR 0 5
51639: NOT
51640: IFFALSE 51644
// exit ;
51642: GO 51693
// for i in tmp do
51644: LD_ADDR_VAR 0 4
51648: PUSH
51649: LD_VAR 0 5
51653: PUSH
51654: FOR_IN
51655: IFFALSE 51691
// if GetTech ( i , side ) <> state_researched then
51657: LD_VAR 0 4
51661: PPUSH
51662: LD_VAR 0 1
51666: PPUSH
51667: CALL_OW 321
51671: PUSH
51672: LD_INT 2
51674: NONEQUAL
51675: IFFALSE 51689
// begin result := false ;
51677: LD_ADDR_VAR 0 3
51681: PUSH
51682: LD_INT 0
51684: ST_TO_ADDR
// exit ;
51685: POP
51686: POP
51687: GO 51693
// end ;
51689: GO 51654
51691: POP
51692: POP
// end ;
51693: LD_VAR 0 3
51697: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
51698: LD_INT 0
51700: PPUSH
51701: PPUSH
51702: PPUSH
51703: PPUSH
51704: PPUSH
51705: PPUSH
51706: PPUSH
51707: PPUSH
51708: PPUSH
51709: PPUSH
51710: PPUSH
51711: PPUSH
51712: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
51713: LD_VAR 0 1
51717: NOT
51718: PUSH
51719: LD_VAR 0 1
51723: PPUSH
51724: CALL_OW 257
51728: PUSH
51729: LD_INT 9
51731: NONEQUAL
51732: OR
51733: IFFALSE 51737
// exit ;
51735: GO 52310
// side := GetSide ( unit ) ;
51737: LD_ADDR_VAR 0 9
51741: PUSH
51742: LD_VAR 0 1
51746: PPUSH
51747: CALL_OW 255
51751: ST_TO_ADDR
// tech_space := tech_spacanom ;
51752: LD_ADDR_VAR 0 12
51756: PUSH
51757: LD_INT 29
51759: ST_TO_ADDR
// tech_time := tech_taurad ;
51760: LD_ADDR_VAR 0 13
51764: PUSH
51765: LD_INT 28
51767: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
51768: LD_ADDR_VAR 0 11
51772: PUSH
51773: LD_VAR 0 1
51777: PPUSH
51778: CALL_OW 310
51782: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
51783: LD_VAR 0 11
51787: PPUSH
51788: CALL_OW 247
51792: PUSH
51793: LD_INT 2
51795: EQUAL
51796: IFFALSE 51800
// exit ;
51798: GO 52310
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
51800: LD_ADDR_VAR 0 8
51804: PUSH
51805: LD_INT 81
51807: PUSH
51808: LD_VAR 0 9
51812: PUSH
51813: EMPTY
51814: LIST
51815: LIST
51816: PUSH
51817: LD_INT 3
51819: PUSH
51820: LD_INT 21
51822: PUSH
51823: LD_INT 3
51825: PUSH
51826: EMPTY
51827: LIST
51828: LIST
51829: PUSH
51830: EMPTY
51831: LIST
51832: LIST
51833: PUSH
51834: EMPTY
51835: LIST
51836: LIST
51837: PPUSH
51838: CALL_OW 69
51842: ST_TO_ADDR
// if not tmp then
51843: LD_VAR 0 8
51847: NOT
51848: IFFALSE 51852
// exit ;
51850: GO 52310
// if in_unit then
51852: LD_VAR 0 11
51856: IFFALSE 51880
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
51858: LD_ADDR_VAR 0 10
51862: PUSH
51863: LD_VAR 0 8
51867: PPUSH
51868: LD_VAR 0 11
51872: PPUSH
51873: CALL_OW 74
51877: ST_TO_ADDR
51878: GO 51900
// enemy := NearestUnitToUnit ( tmp , unit ) ;
51880: LD_ADDR_VAR 0 10
51884: PUSH
51885: LD_VAR 0 8
51889: PPUSH
51890: LD_VAR 0 1
51894: PPUSH
51895: CALL_OW 74
51899: ST_TO_ADDR
// if not enemy then
51900: LD_VAR 0 10
51904: NOT
51905: IFFALSE 51909
// exit ;
51907: GO 52310
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
51909: LD_VAR 0 11
51913: PUSH
51914: LD_VAR 0 11
51918: PPUSH
51919: LD_VAR 0 10
51923: PPUSH
51924: CALL_OW 296
51928: PUSH
51929: LD_INT 13
51931: GREATER
51932: AND
51933: PUSH
51934: LD_VAR 0 1
51938: PPUSH
51939: LD_VAR 0 10
51943: PPUSH
51944: CALL_OW 296
51948: PUSH
51949: LD_INT 12
51951: GREATER
51952: OR
51953: IFFALSE 51957
// exit ;
51955: GO 52310
// missile := [ 1 ] ;
51957: LD_ADDR_VAR 0 14
51961: PUSH
51962: LD_INT 1
51964: PUSH
51965: EMPTY
51966: LIST
51967: ST_TO_ADDR
// if Researched ( side , tech_space ) then
51968: LD_VAR 0 9
51972: PPUSH
51973: LD_VAR 0 12
51977: PPUSH
51978: CALL_OW 325
51982: IFFALSE 52011
// missile := Insert ( missile , missile + 1 , 2 ) ;
51984: LD_ADDR_VAR 0 14
51988: PUSH
51989: LD_VAR 0 14
51993: PPUSH
51994: LD_VAR 0 14
51998: PUSH
51999: LD_INT 1
52001: PLUS
52002: PPUSH
52003: LD_INT 2
52005: PPUSH
52006: CALL_OW 2
52010: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
52011: LD_VAR 0 9
52015: PPUSH
52016: LD_VAR 0 13
52020: PPUSH
52021: CALL_OW 325
52025: PUSH
52026: LD_VAR 0 10
52030: PPUSH
52031: CALL_OW 255
52035: PPUSH
52036: LD_VAR 0 13
52040: PPUSH
52041: CALL_OW 325
52045: NOT
52046: AND
52047: IFFALSE 52076
// missile := Insert ( missile , missile + 1 , 3 ) ;
52049: LD_ADDR_VAR 0 14
52053: PUSH
52054: LD_VAR 0 14
52058: PPUSH
52059: LD_VAR 0 14
52063: PUSH
52064: LD_INT 1
52066: PLUS
52067: PPUSH
52068: LD_INT 3
52070: PPUSH
52071: CALL_OW 2
52075: ST_TO_ADDR
// if missile < 2 then
52076: LD_VAR 0 14
52080: PUSH
52081: LD_INT 2
52083: LESS
52084: IFFALSE 52088
// exit ;
52086: GO 52310
// x := GetX ( enemy ) ;
52088: LD_ADDR_VAR 0 4
52092: PUSH
52093: LD_VAR 0 10
52097: PPUSH
52098: CALL_OW 250
52102: ST_TO_ADDR
// y := GetY ( enemy ) ;
52103: LD_ADDR_VAR 0 5
52107: PUSH
52108: LD_VAR 0 10
52112: PPUSH
52113: CALL_OW 251
52117: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
52118: LD_ADDR_VAR 0 6
52122: PUSH
52123: LD_VAR 0 4
52127: PUSH
52128: LD_INT 1
52130: NEG
52131: PPUSH
52132: LD_INT 1
52134: PPUSH
52135: CALL_OW 12
52139: PLUS
52140: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
52141: LD_ADDR_VAR 0 7
52145: PUSH
52146: LD_VAR 0 5
52150: PUSH
52151: LD_INT 1
52153: NEG
52154: PPUSH
52155: LD_INT 1
52157: PPUSH
52158: CALL_OW 12
52162: PLUS
52163: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
52164: LD_VAR 0 6
52168: PPUSH
52169: LD_VAR 0 7
52173: PPUSH
52174: CALL_OW 488
52178: NOT
52179: IFFALSE 52201
// begin _x := x ;
52181: LD_ADDR_VAR 0 6
52185: PUSH
52186: LD_VAR 0 4
52190: ST_TO_ADDR
// _y := y ;
52191: LD_ADDR_VAR 0 7
52195: PUSH
52196: LD_VAR 0 5
52200: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
52201: LD_ADDR_VAR 0 3
52205: PUSH
52206: LD_INT 1
52208: PPUSH
52209: LD_VAR 0 14
52213: PPUSH
52214: CALL_OW 12
52218: ST_TO_ADDR
// case i of 1 :
52219: LD_VAR 0 3
52223: PUSH
52224: LD_INT 1
52226: DOUBLE
52227: EQUAL
52228: IFTRUE 52232
52230: GO 52249
52232: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
52233: LD_VAR 0 1
52237: PPUSH
52238: LD_VAR 0 10
52242: PPUSH
52243: CALL_OW 115
52247: GO 52310
52249: LD_INT 2
52251: DOUBLE
52252: EQUAL
52253: IFTRUE 52257
52255: GO 52279
52257: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
52258: LD_VAR 0 1
52262: PPUSH
52263: LD_VAR 0 6
52267: PPUSH
52268: LD_VAR 0 7
52272: PPUSH
52273: CALL_OW 153
52277: GO 52310
52279: LD_INT 3
52281: DOUBLE
52282: EQUAL
52283: IFTRUE 52287
52285: GO 52309
52287: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
52288: LD_VAR 0 1
52292: PPUSH
52293: LD_VAR 0 6
52297: PPUSH
52298: LD_VAR 0 7
52302: PPUSH
52303: CALL_OW 154
52307: GO 52310
52309: POP
// end ;
52310: LD_VAR 0 2
52314: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
52315: LD_INT 0
52317: PPUSH
52318: PPUSH
52319: PPUSH
52320: PPUSH
52321: PPUSH
52322: PPUSH
// if not unit or not building then
52323: LD_VAR 0 1
52327: NOT
52328: PUSH
52329: LD_VAR 0 2
52333: NOT
52334: OR
52335: IFFALSE 52339
// exit ;
52337: GO 52497
// x := GetX ( building ) ;
52339: LD_ADDR_VAR 0 5
52343: PUSH
52344: LD_VAR 0 2
52348: PPUSH
52349: CALL_OW 250
52353: ST_TO_ADDR
// y := GetY ( building ) ;
52354: LD_ADDR_VAR 0 6
52358: PUSH
52359: LD_VAR 0 2
52363: PPUSH
52364: CALL_OW 251
52368: ST_TO_ADDR
// for i = 0 to 5 do
52369: LD_ADDR_VAR 0 4
52373: PUSH
52374: DOUBLE
52375: LD_INT 0
52377: DEC
52378: ST_TO_ADDR
52379: LD_INT 5
52381: PUSH
52382: FOR_TO
52383: IFFALSE 52495
// begin _x := ShiftX ( x , i , 3 ) ;
52385: LD_ADDR_VAR 0 7
52389: PUSH
52390: LD_VAR 0 5
52394: PPUSH
52395: LD_VAR 0 4
52399: PPUSH
52400: LD_INT 3
52402: PPUSH
52403: CALL_OW 272
52407: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
52408: LD_ADDR_VAR 0 8
52412: PUSH
52413: LD_VAR 0 6
52417: PPUSH
52418: LD_VAR 0 4
52422: PPUSH
52423: LD_INT 3
52425: PPUSH
52426: CALL_OW 273
52430: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
52431: LD_VAR 0 7
52435: PPUSH
52436: LD_VAR 0 8
52440: PPUSH
52441: CALL_OW 488
52445: NOT
52446: IFFALSE 52450
// continue ;
52448: GO 52382
// if HexInfo ( _x , _y ) = 0 then
52450: LD_VAR 0 7
52454: PPUSH
52455: LD_VAR 0 8
52459: PPUSH
52460: CALL_OW 428
52464: PUSH
52465: LD_INT 0
52467: EQUAL
52468: IFFALSE 52493
// begin ComMoveXY ( unit , _x , _y ) ;
52470: LD_VAR 0 1
52474: PPUSH
52475: LD_VAR 0 7
52479: PPUSH
52480: LD_VAR 0 8
52484: PPUSH
52485: CALL_OW 111
// exit ;
52489: POP
52490: POP
52491: GO 52497
// end ; end ;
52493: GO 52382
52495: POP
52496: POP
// end ;
52497: LD_VAR 0 3
52501: RET
// export function ScanBase ( side , base_area ) ; begin
52502: LD_INT 0
52504: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
52505: LD_ADDR_VAR 0 3
52509: PUSH
52510: LD_VAR 0 2
52514: PPUSH
52515: LD_INT 81
52517: PUSH
52518: LD_VAR 0 1
52522: PUSH
52523: EMPTY
52524: LIST
52525: LIST
52526: PPUSH
52527: CALL_OW 70
52531: ST_TO_ADDR
// end ;
52532: LD_VAR 0 3
52536: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
52537: LD_INT 0
52539: PPUSH
52540: PPUSH
52541: PPUSH
52542: PPUSH
// result := false ;
52543: LD_ADDR_VAR 0 2
52547: PUSH
52548: LD_INT 0
52550: ST_TO_ADDR
// side := GetSide ( unit ) ;
52551: LD_ADDR_VAR 0 3
52555: PUSH
52556: LD_VAR 0 1
52560: PPUSH
52561: CALL_OW 255
52565: ST_TO_ADDR
// nat := GetNation ( unit ) ;
52566: LD_ADDR_VAR 0 4
52570: PUSH
52571: LD_VAR 0 1
52575: PPUSH
52576: CALL_OW 248
52580: ST_TO_ADDR
// case nat of 1 :
52581: LD_VAR 0 4
52585: PUSH
52586: LD_INT 1
52588: DOUBLE
52589: EQUAL
52590: IFTRUE 52594
52592: GO 52605
52594: POP
// tech := tech_lassight ; 2 :
52595: LD_ADDR_VAR 0 5
52599: PUSH
52600: LD_INT 12
52602: ST_TO_ADDR
52603: GO 52644
52605: LD_INT 2
52607: DOUBLE
52608: EQUAL
52609: IFTRUE 52613
52611: GO 52624
52613: POP
// tech := tech_mortar ; 3 :
52614: LD_ADDR_VAR 0 5
52618: PUSH
52619: LD_INT 41
52621: ST_TO_ADDR
52622: GO 52644
52624: LD_INT 3
52626: DOUBLE
52627: EQUAL
52628: IFTRUE 52632
52630: GO 52643
52632: POP
// tech := tech_bazooka ; end ;
52633: LD_ADDR_VAR 0 5
52637: PUSH
52638: LD_INT 44
52640: ST_TO_ADDR
52641: GO 52644
52643: POP
// if Researched ( side , tech ) then
52644: LD_VAR 0 3
52648: PPUSH
52649: LD_VAR 0 5
52653: PPUSH
52654: CALL_OW 325
52658: IFFALSE 52685
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
52660: LD_ADDR_VAR 0 2
52664: PUSH
52665: LD_INT 5
52667: PUSH
52668: LD_INT 8
52670: PUSH
52671: LD_INT 9
52673: PUSH
52674: EMPTY
52675: LIST
52676: LIST
52677: LIST
52678: PUSH
52679: LD_VAR 0 4
52683: ARRAY
52684: ST_TO_ADDR
// end ;
52685: LD_VAR 0 2
52689: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
52690: LD_INT 0
52692: PPUSH
52693: PPUSH
52694: PPUSH
// if not mines then
52695: LD_VAR 0 2
52699: NOT
52700: IFFALSE 52704
// exit ;
52702: GO 52848
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
52704: LD_ADDR_VAR 0 5
52708: PUSH
52709: LD_INT 81
52711: PUSH
52712: LD_VAR 0 1
52716: PUSH
52717: EMPTY
52718: LIST
52719: LIST
52720: PUSH
52721: LD_INT 3
52723: PUSH
52724: LD_INT 21
52726: PUSH
52727: LD_INT 3
52729: PUSH
52730: EMPTY
52731: LIST
52732: LIST
52733: PUSH
52734: EMPTY
52735: LIST
52736: LIST
52737: PUSH
52738: EMPTY
52739: LIST
52740: LIST
52741: PPUSH
52742: CALL_OW 69
52746: ST_TO_ADDR
// for i in mines do
52747: LD_ADDR_VAR 0 4
52751: PUSH
52752: LD_VAR 0 2
52756: PUSH
52757: FOR_IN
52758: IFFALSE 52846
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
52760: LD_VAR 0 4
52764: PUSH
52765: LD_INT 1
52767: ARRAY
52768: PPUSH
52769: LD_VAR 0 4
52773: PUSH
52774: LD_INT 2
52776: ARRAY
52777: PPUSH
52778: CALL_OW 458
52782: NOT
52783: IFFALSE 52787
// continue ;
52785: GO 52757
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
52787: LD_VAR 0 4
52791: PUSH
52792: LD_INT 1
52794: ARRAY
52795: PPUSH
52796: LD_VAR 0 4
52800: PUSH
52801: LD_INT 2
52803: ARRAY
52804: PPUSH
52805: CALL_OW 428
52809: PUSH
52810: LD_VAR 0 5
52814: IN
52815: IFFALSE 52844
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
52817: LD_VAR 0 4
52821: PUSH
52822: LD_INT 1
52824: ARRAY
52825: PPUSH
52826: LD_VAR 0 4
52830: PUSH
52831: LD_INT 2
52833: ARRAY
52834: PPUSH
52835: LD_VAR 0 1
52839: PPUSH
52840: CALL_OW 456
// end ;
52844: GO 52757
52846: POP
52847: POP
// end ;
52848: LD_VAR 0 3
52852: RET
// export function Count ( array ) ; var i ; begin
52853: LD_INT 0
52855: PPUSH
52856: PPUSH
// result := 0 ;
52857: LD_ADDR_VAR 0 2
52861: PUSH
52862: LD_INT 0
52864: ST_TO_ADDR
// for i in array do
52865: LD_ADDR_VAR 0 3
52869: PUSH
52870: LD_VAR 0 1
52874: PUSH
52875: FOR_IN
52876: IFFALSE 52900
// if i then
52878: LD_VAR 0 3
52882: IFFALSE 52898
// result := result + 1 ;
52884: LD_ADDR_VAR 0 2
52888: PUSH
52889: LD_VAR 0 2
52893: PUSH
52894: LD_INT 1
52896: PLUS
52897: ST_TO_ADDR
52898: GO 52875
52900: POP
52901: POP
// end ;
52902: LD_VAR 0 2
52906: RET
// export function IsEmpty ( building ) ; begin
52907: LD_INT 0
52909: PPUSH
// if not building then
52910: LD_VAR 0 1
52914: NOT
52915: IFFALSE 52919
// exit ;
52917: GO 52962
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
52919: LD_ADDR_VAR 0 2
52923: PUSH
52924: LD_VAR 0 1
52928: PUSH
52929: LD_INT 22
52931: PUSH
52932: LD_VAR 0 1
52936: PPUSH
52937: CALL_OW 255
52941: PUSH
52942: EMPTY
52943: LIST
52944: LIST
52945: PUSH
52946: LD_INT 58
52948: PUSH
52949: EMPTY
52950: LIST
52951: PUSH
52952: EMPTY
52953: LIST
52954: LIST
52955: PPUSH
52956: CALL_OW 69
52960: IN
52961: ST_TO_ADDR
// end ;
52962: LD_VAR 0 2
52966: RET
// export function IsNotFull ( building ) ; begin
52967: LD_INT 0
52969: PPUSH
// if not building then
52970: LD_VAR 0 1
52974: NOT
52975: IFFALSE 52979
// exit ;
52977: GO 52998
// result := UnitsInside ( building ) < 6 ;
52979: LD_ADDR_VAR 0 2
52983: PUSH
52984: LD_VAR 0 1
52988: PPUSH
52989: CALL_OW 313
52993: PUSH
52994: LD_INT 6
52996: LESS
52997: ST_TO_ADDR
// end ;
52998: LD_VAR 0 2
53002: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
53003: LD_INT 0
53005: PPUSH
53006: PPUSH
53007: PPUSH
53008: PPUSH
// tmp := [ ] ;
53009: LD_ADDR_VAR 0 3
53013: PUSH
53014: EMPTY
53015: ST_TO_ADDR
// list := [ ] ;
53016: LD_ADDR_VAR 0 5
53020: PUSH
53021: EMPTY
53022: ST_TO_ADDR
// for i = 16 to 25 do
53023: LD_ADDR_VAR 0 4
53027: PUSH
53028: DOUBLE
53029: LD_INT 16
53031: DEC
53032: ST_TO_ADDR
53033: LD_INT 25
53035: PUSH
53036: FOR_TO
53037: IFFALSE 53110
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
53039: LD_ADDR_VAR 0 3
53043: PUSH
53044: LD_VAR 0 3
53048: PUSH
53049: LD_INT 22
53051: PUSH
53052: LD_VAR 0 1
53056: PPUSH
53057: CALL_OW 255
53061: PUSH
53062: EMPTY
53063: LIST
53064: LIST
53065: PUSH
53066: LD_INT 91
53068: PUSH
53069: LD_VAR 0 1
53073: PUSH
53074: LD_INT 6
53076: PUSH
53077: EMPTY
53078: LIST
53079: LIST
53080: LIST
53081: PUSH
53082: LD_INT 30
53084: PUSH
53085: LD_VAR 0 4
53089: PUSH
53090: EMPTY
53091: LIST
53092: LIST
53093: PUSH
53094: EMPTY
53095: LIST
53096: LIST
53097: LIST
53098: PUSH
53099: EMPTY
53100: LIST
53101: PPUSH
53102: CALL_OW 69
53106: ADD
53107: ST_TO_ADDR
53108: GO 53036
53110: POP
53111: POP
// for i = 1 to tmp do
53112: LD_ADDR_VAR 0 4
53116: PUSH
53117: DOUBLE
53118: LD_INT 1
53120: DEC
53121: ST_TO_ADDR
53122: LD_VAR 0 3
53126: PUSH
53127: FOR_TO
53128: IFFALSE 53216
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
53130: LD_ADDR_VAR 0 5
53134: PUSH
53135: LD_VAR 0 5
53139: PUSH
53140: LD_VAR 0 3
53144: PUSH
53145: LD_VAR 0 4
53149: ARRAY
53150: PPUSH
53151: CALL_OW 266
53155: PUSH
53156: LD_VAR 0 3
53160: PUSH
53161: LD_VAR 0 4
53165: ARRAY
53166: PPUSH
53167: CALL_OW 250
53171: PUSH
53172: LD_VAR 0 3
53176: PUSH
53177: LD_VAR 0 4
53181: ARRAY
53182: PPUSH
53183: CALL_OW 251
53187: PUSH
53188: LD_VAR 0 3
53192: PUSH
53193: LD_VAR 0 4
53197: ARRAY
53198: PPUSH
53199: CALL_OW 254
53203: PUSH
53204: EMPTY
53205: LIST
53206: LIST
53207: LIST
53208: LIST
53209: PUSH
53210: EMPTY
53211: LIST
53212: ADD
53213: ST_TO_ADDR
53214: GO 53127
53216: POP
53217: POP
// result := list ;
53218: LD_ADDR_VAR 0 2
53222: PUSH
53223: LD_VAR 0 5
53227: ST_TO_ADDR
// end ;
53228: LD_VAR 0 2
53232: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
53233: LD_INT 0
53235: PPUSH
53236: PPUSH
53237: PPUSH
53238: PPUSH
53239: PPUSH
53240: PPUSH
53241: PPUSH
// if not factory then
53242: LD_VAR 0 1
53246: NOT
53247: IFFALSE 53251
// exit ;
53249: GO 53844
// if control = control_apeman then
53251: LD_VAR 0 4
53255: PUSH
53256: LD_INT 5
53258: EQUAL
53259: IFFALSE 53368
// begin tmp := UnitsInside ( factory ) ;
53261: LD_ADDR_VAR 0 8
53265: PUSH
53266: LD_VAR 0 1
53270: PPUSH
53271: CALL_OW 313
53275: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
53276: LD_VAR 0 8
53280: PPUSH
53281: LD_INT 25
53283: PUSH
53284: LD_INT 12
53286: PUSH
53287: EMPTY
53288: LIST
53289: LIST
53290: PPUSH
53291: CALL_OW 72
53295: NOT
53296: IFFALSE 53306
// control := control_manual ;
53298: LD_ADDR_VAR 0 4
53302: PUSH
53303: LD_INT 1
53305: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
53306: LD_ADDR_VAR 0 8
53310: PUSH
53311: LD_VAR 0 1
53315: PPUSH
53316: CALL 53003 0 1
53320: ST_TO_ADDR
// if tmp then
53321: LD_VAR 0 8
53325: IFFALSE 53368
// begin for i in tmp do
53327: LD_ADDR_VAR 0 7
53331: PUSH
53332: LD_VAR 0 8
53336: PUSH
53337: FOR_IN
53338: IFFALSE 53366
// if i [ 1 ] = b_ext_radio then
53340: LD_VAR 0 7
53344: PUSH
53345: LD_INT 1
53347: ARRAY
53348: PUSH
53349: LD_INT 22
53351: EQUAL
53352: IFFALSE 53364
// begin control := control_remote ;
53354: LD_ADDR_VAR 0 4
53358: PUSH
53359: LD_INT 2
53361: ST_TO_ADDR
// break ;
53362: GO 53366
// end ;
53364: GO 53337
53366: POP
53367: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
53368: LD_VAR 0 1
53372: PPUSH
53373: LD_VAR 0 2
53377: PPUSH
53378: LD_VAR 0 3
53382: PPUSH
53383: LD_VAR 0 4
53387: PPUSH
53388: LD_VAR 0 5
53392: PPUSH
53393: CALL_OW 448
53397: IFFALSE 53432
// begin result := [ chassis , engine , control , weapon ] ;
53399: LD_ADDR_VAR 0 6
53403: PUSH
53404: LD_VAR 0 2
53408: PUSH
53409: LD_VAR 0 3
53413: PUSH
53414: LD_VAR 0 4
53418: PUSH
53419: LD_VAR 0 5
53423: PUSH
53424: EMPTY
53425: LIST
53426: LIST
53427: LIST
53428: LIST
53429: ST_TO_ADDR
// exit ;
53430: GO 53844
// end ; _chassis := AvailableChassisList ( factory ) ;
53432: LD_ADDR_VAR 0 9
53436: PUSH
53437: LD_VAR 0 1
53441: PPUSH
53442: CALL_OW 475
53446: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
53447: LD_ADDR_VAR 0 11
53451: PUSH
53452: LD_VAR 0 1
53456: PPUSH
53457: CALL_OW 476
53461: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
53462: LD_ADDR_VAR 0 12
53466: PUSH
53467: LD_VAR 0 1
53471: PPUSH
53472: CALL_OW 477
53476: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
53477: LD_ADDR_VAR 0 10
53481: PUSH
53482: LD_VAR 0 1
53486: PPUSH
53487: CALL_OW 478
53491: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
53492: LD_VAR 0 9
53496: NOT
53497: PUSH
53498: LD_VAR 0 11
53502: NOT
53503: OR
53504: PUSH
53505: LD_VAR 0 12
53509: NOT
53510: OR
53511: PUSH
53512: LD_VAR 0 10
53516: NOT
53517: OR
53518: IFFALSE 53553
// begin result := [ chassis , engine , control , weapon ] ;
53520: LD_ADDR_VAR 0 6
53524: PUSH
53525: LD_VAR 0 2
53529: PUSH
53530: LD_VAR 0 3
53534: PUSH
53535: LD_VAR 0 4
53539: PUSH
53540: LD_VAR 0 5
53544: PUSH
53545: EMPTY
53546: LIST
53547: LIST
53548: LIST
53549: LIST
53550: ST_TO_ADDR
// exit ;
53551: GO 53844
// end ; if not chassis in _chassis then
53553: LD_VAR 0 2
53557: PUSH
53558: LD_VAR 0 9
53562: IN
53563: NOT
53564: IFFALSE 53590
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
53566: LD_ADDR_VAR 0 2
53570: PUSH
53571: LD_VAR 0 9
53575: PUSH
53576: LD_INT 1
53578: PPUSH
53579: LD_VAR 0 9
53583: PPUSH
53584: CALL_OW 12
53588: ARRAY
53589: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
53590: LD_VAR 0 2
53594: PPUSH
53595: LD_VAR 0 3
53599: PPUSH
53600: CALL 53849 0 2
53604: NOT
53605: IFFALSE 53664
// repeat engine := _engine [ 1 ] ;
53607: LD_ADDR_VAR 0 3
53611: PUSH
53612: LD_VAR 0 11
53616: PUSH
53617: LD_INT 1
53619: ARRAY
53620: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
53621: LD_ADDR_VAR 0 11
53625: PUSH
53626: LD_VAR 0 11
53630: PPUSH
53631: LD_INT 1
53633: PPUSH
53634: CALL_OW 3
53638: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
53639: LD_VAR 0 2
53643: PPUSH
53644: LD_VAR 0 3
53648: PPUSH
53649: CALL 53849 0 2
53653: PUSH
53654: LD_VAR 0 11
53658: PUSH
53659: EMPTY
53660: EQUAL
53661: OR
53662: IFFALSE 53607
// if not control in _control then
53664: LD_VAR 0 4
53668: PUSH
53669: LD_VAR 0 12
53673: IN
53674: NOT
53675: IFFALSE 53701
// control := _control [ rand ( 1 , _control ) ] ;
53677: LD_ADDR_VAR 0 4
53681: PUSH
53682: LD_VAR 0 12
53686: PUSH
53687: LD_INT 1
53689: PPUSH
53690: LD_VAR 0 12
53694: PPUSH
53695: CALL_OW 12
53699: ARRAY
53700: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
53701: LD_VAR 0 2
53705: PPUSH
53706: LD_VAR 0 5
53710: PPUSH
53711: CALL 54069 0 2
53715: NOT
53716: IFFALSE 53775
// repeat weapon := _weapon [ 1 ] ;
53718: LD_ADDR_VAR 0 5
53722: PUSH
53723: LD_VAR 0 10
53727: PUSH
53728: LD_INT 1
53730: ARRAY
53731: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
53732: LD_ADDR_VAR 0 10
53736: PUSH
53737: LD_VAR 0 10
53741: PPUSH
53742: LD_INT 1
53744: PPUSH
53745: CALL_OW 3
53749: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
53750: LD_VAR 0 2
53754: PPUSH
53755: LD_VAR 0 5
53759: PPUSH
53760: CALL 54069 0 2
53764: PUSH
53765: LD_VAR 0 10
53769: PUSH
53770: EMPTY
53771: EQUAL
53772: OR
53773: IFFALSE 53718
// result := [ ] ;
53775: LD_ADDR_VAR 0 6
53779: PUSH
53780: EMPTY
53781: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
53782: LD_VAR 0 1
53786: PPUSH
53787: LD_VAR 0 2
53791: PPUSH
53792: LD_VAR 0 3
53796: PPUSH
53797: LD_VAR 0 4
53801: PPUSH
53802: LD_VAR 0 5
53806: PPUSH
53807: CALL_OW 448
53811: IFFALSE 53844
// result := [ chassis , engine , control , weapon ] ;
53813: LD_ADDR_VAR 0 6
53817: PUSH
53818: LD_VAR 0 2
53822: PUSH
53823: LD_VAR 0 3
53827: PUSH
53828: LD_VAR 0 4
53832: PUSH
53833: LD_VAR 0 5
53837: PUSH
53838: EMPTY
53839: LIST
53840: LIST
53841: LIST
53842: LIST
53843: ST_TO_ADDR
// end ;
53844: LD_VAR 0 6
53848: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
53849: LD_INT 0
53851: PPUSH
// if not chassis or not engine then
53852: LD_VAR 0 1
53856: NOT
53857: PUSH
53858: LD_VAR 0 2
53862: NOT
53863: OR
53864: IFFALSE 53868
// exit ;
53866: GO 54064
// case engine of engine_solar :
53868: LD_VAR 0 2
53872: PUSH
53873: LD_INT 2
53875: DOUBLE
53876: EQUAL
53877: IFTRUE 53881
53879: GO 53919
53881: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
53882: LD_ADDR_VAR 0 3
53886: PUSH
53887: LD_INT 11
53889: PUSH
53890: LD_INT 12
53892: PUSH
53893: LD_INT 13
53895: PUSH
53896: LD_INT 14
53898: PUSH
53899: LD_INT 1
53901: PUSH
53902: LD_INT 2
53904: PUSH
53905: LD_INT 3
53907: PUSH
53908: EMPTY
53909: LIST
53910: LIST
53911: LIST
53912: LIST
53913: LIST
53914: LIST
53915: LIST
53916: ST_TO_ADDR
53917: GO 54048
53919: LD_INT 1
53921: DOUBLE
53922: EQUAL
53923: IFTRUE 53927
53925: GO 53989
53927: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
53928: LD_ADDR_VAR 0 3
53932: PUSH
53933: LD_INT 11
53935: PUSH
53936: LD_INT 12
53938: PUSH
53939: LD_INT 13
53941: PUSH
53942: LD_INT 14
53944: PUSH
53945: LD_INT 1
53947: PUSH
53948: LD_INT 2
53950: PUSH
53951: LD_INT 3
53953: PUSH
53954: LD_INT 4
53956: PUSH
53957: LD_INT 5
53959: PUSH
53960: LD_INT 21
53962: PUSH
53963: LD_INT 23
53965: PUSH
53966: LD_INT 22
53968: PUSH
53969: LD_INT 24
53971: PUSH
53972: EMPTY
53973: LIST
53974: LIST
53975: LIST
53976: LIST
53977: LIST
53978: LIST
53979: LIST
53980: LIST
53981: LIST
53982: LIST
53983: LIST
53984: LIST
53985: LIST
53986: ST_TO_ADDR
53987: GO 54048
53989: LD_INT 3
53991: DOUBLE
53992: EQUAL
53993: IFTRUE 53997
53995: GO 54047
53997: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
53998: LD_ADDR_VAR 0 3
54002: PUSH
54003: LD_INT 13
54005: PUSH
54006: LD_INT 14
54008: PUSH
54009: LD_INT 2
54011: PUSH
54012: LD_INT 3
54014: PUSH
54015: LD_INT 4
54017: PUSH
54018: LD_INT 5
54020: PUSH
54021: LD_INT 21
54023: PUSH
54024: LD_INT 22
54026: PUSH
54027: LD_INT 23
54029: PUSH
54030: LD_INT 24
54032: PUSH
54033: EMPTY
54034: LIST
54035: LIST
54036: LIST
54037: LIST
54038: LIST
54039: LIST
54040: LIST
54041: LIST
54042: LIST
54043: LIST
54044: ST_TO_ADDR
54045: GO 54048
54047: POP
// result := ( chassis in result ) ;
54048: LD_ADDR_VAR 0 3
54052: PUSH
54053: LD_VAR 0 1
54057: PUSH
54058: LD_VAR 0 3
54062: IN
54063: ST_TO_ADDR
// end ;
54064: LD_VAR 0 3
54068: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
54069: LD_INT 0
54071: PPUSH
// if not chassis or not weapon then
54072: LD_VAR 0 1
54076: NOT
54077: PUSH
54078: LD_VAR 0 2
54082: NOT
54083: OR
54084: IFFALSE 54088
// exit ;
54086: GO 55114
// case weapon of us_machine_gun :
54088: LD_VAR 0 2
54092: PUSH
54093: LD_INT 2
54095: DOUBLE
54096: EQUAL
54097: IFTRUE 54101
54099: GO 54131
54101: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
54102: LD_ADDR_VAR 0 3
54106: PUSH
54107: LD_INT 1
54109: PUSH
54110: LD_INT 2
54112: PUSH
54113: LD_INT 3
54115: PUSH
54116: LD_INT 4
54118: PUSH
54119: LD_INT 5
54121: PUSH
54122: EMPTY
54123: LIST
54124: LIST
54125: LIST
54126: LIST
54127: LIST
54128: ST_TO_ADDR
54129: GO 55098
54131: LD_INT 3
54133: DOUBLE
54134: EQUAL
54135: IFTRUE 54139
54137: GO 54169
54139: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
54140: LD_ADDR_VAR 0 3
54144: PUSH
54145: LD_INT 1
54147: PUSH
54148: LD_INT 2
54150: PUSH
54151: LD_INT 3
54153: PUSH
54154: LD_INT 4
54156: PUSH
54157: LD_INT 5
54159: PUSH
54160: EMPTY
54161: LIST
54162: LIST
54163: LIST
54164: LIST
54165: LIST
54166: ST_TO_ADDR
54167: GO 55098
54169: LD_INT 11
54171: DOUBLE
54172: EQUAL
54173: IFTRUE 54177
54175: GO 54207
54177: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
54178: LD_ADDR_VAR 0 3
54182: PUSH
54183: LD_INT 1
54185: PUSH
54186: LD_INT 2
54188: PUSH
54189: LD_INT 3
54191: PUSH
54192: LD_INT 4
54194: PUSH
54195: LD_INT 5
54197: PUSH
54198: EMPTY
54199: LIST
54200: LIST
54201: LIST
54202: LIST
54203: LIST
54204: ST_TO_ADDR
54205: GO 55098
54207: LD_INT 4
54209: DOUBLE
54210: EQUAL
54211: IFTRUE 54215
54213: GO 54241
54215: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
54216: LD_ADDR_VAR 0 3
54220: PUSH
54221: LD_INT 2
54223: PUSH
54224: LD_INT 3
54226: PUSH
54227: LD_INT 4
54229: PUSH
54230: LD_INT 5
54232: PUSH
54233: EMPTY
54234: LIST
54235: LIST
54236: LIST
54237: LIST
54238: ST_TO_ADDR
54239: GO 55098
54241: LD_INT 5
54243: DOUBLE
54244: EQUAL
54245: IFTRUE 54249
54247: GO 54275
54249: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
54250: LD_ADDR_VAR 0 3
54254: PUSH
54255: LD_INT 2
54257: PUSH
54258: LD_INT 3
54260: PUSH
54261: LD_INT 4
54263: PUSH
54264: LD_INT 5
54266: PUSH
54267: EMPTY
54268: LIST
54269: LIST
54270: LIST
54271: LIST
54272: ST_TO_ADDR
54273: GO 55098
54275: LD_INT 9
54277: DOUBLE
54278: EQUAL
54279: IFTRUE 54283
54281: GO 54309
54283: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
54284: LD_ADDR_VAR 0 3
54288: PUSH
54289: LD_INT 2
54291: PUSH
54292: LD_INT 3
54294: PUSH
54295: LD_INT 4
54297: PUSH
54298: LD_INT 5
54300: PUSH
54301: EMPTY
54302: LIST
54303: LIST
54304: LIST
54305: LIST
54306: ST_TO_ADDR
54307: GO 55098
54309: LD_INT 7
54311: DOUBLE
54312: EQUAL
54313: IFTRUE 54317
54315: GO 54343
54317: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
54318: LD_ADDR_VAR 0 3
54322: PUSH
54323: LD_INT 2
54325: PUSH
54326: LD_INT 3
54328: PUSH
54329: LD_INT 4
54331: PUSH
54332: LD_INT 5
54334: PUSH
54335: EMPTY
54336: LIST
54337: LIST
54338: LIST
54339: LIST
54340: ST_TO_ADDR
54341: GO 55098
54343: LD_INT 12
54345: DOUBLE
54346: EQUAL
54347: IFTRUE 54351
54349: GO 54377
54351: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
54352: LD_ADDR_VAR 0 3
54356: PUSH
54357: LD_INT 2
54359: PUSH
54360: LD_INT 3
54362: PUSH
54363: LD_INT 4
54365: PUSH
54366: LD_INT 5
54368: PUSH
54369: EMPTY
54370: LIST
54371: LIST
54372: LIST
54373: LIST
54374: ST_TO_ADDR
54375: GO 55098
54377: LD_INT 13
54379: DOUBLE
54380: EQUAL
54381: IFTRUE 54385
54383: GO 54411
54385: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
54386: LD_ADDR_VAR 0 3
54390: PUSH
54391: LD_INT 2
54393: PUSH
54394: LD_INT 3
54396: PUSH
54397: LD_INT 4
54399: PUSH
54400: LD_INT 5
54402: PUSH
54403: EMPTY
54404: LIST
54405: LIST
54406: LIST
54407: LIST
54408: ST_TO_ADDR
54409: GO 55098
54411: LD_INT 14
54413: DOUBLE
54414: EQUAL
54415: IFTRUE 54419
54417: GO 54437
54419: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
54420: LD_ADDR_VAR 0 3
54424: PUSH
54425: LD_INT 4
54427: PUSH
54428: LD_INT 5
54430: PUSH
54431: EMPTY
54432: LIST
54433: LIST
54434: ST_TO_ADDR
54435: GO 55098
54437: LD_INT 6
54439: DOUBLE
54440: EQUAL
54441: IFTRUE 54445
54443: GO 54463
54445: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
54446: LD_ADDR_VAR 0 3
54450: PUSH
54451: LD_INT 4
54453: PUSH
54454: LD_INT 5
54456: PUSH
54457: EMPTY
54458: LIST
54459: LIST
54460: ST_TO_ADDR
54461: GO 55098
54463: LD_INT 10
54465: DOUBLE
54466: EQUAL
54467: IFTRUE 54471
54469: GO 54489
54471: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
54472: LD_ADDR_VAR 0 3
54476: PUSH
54477: LD_INT 4
54479: PUSH
54480: LD_INT 5
54482: PUSH
54483: EMPTY
54484: LIST
54485: LIST
54486: ST_TO_ADDR
54487: GO 55098
54489: LD_INT 22
54491: DOUBLE
54492: EQUAL
54493: IFTRUE 54497
54495: GO 54523
54497: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
54498: LD_ADDR_VAR 0 3
54502: PUSH
54503: LD_INT 11
54505: PUSH
54506: LD_INT 12
54508: PUSH
54509: LD_INT 13
54511: PUSH
54512: LD_INT 14
54514: PUSH
54515: EMPTY
54516: LIST
54517: LIST
54518: LIST
54519: LIST
54520: ST_TO_ADDR
54521: GO 55098
54523: LD_INT 23
54525: DOUBLE
54526: EQUAL
54527: IFTRUE 54531
54529: GO 54557
54531: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
54532: LD_ADDR_VAR 0 3
54536: PUSH
54537: LD_INT 11
54539: PUSH
54540: LD_INT 12
54542: PUSH
54543: LD_INT 13
54545: PUSH
54546: LD_INT 14
54548: PUSH
54549: EMPTY
54550: LIST
54551: LIST
54552: LIST
54553: LIST
54554: ST_TO_ADDR
54555: GO 55098
54557: LD_INT 24
54559: DOUBLE
54560: EQUAL
54561: IFTRUE 54565
54563: GO 54591
54565: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
54566: LD_ADDR_VAR 0 3
54570: PUSH
54571: LD_INT 11
54573: PUSH
54574: LD_INT 12
54576: PUSH
54577: LD_INT 13
54579: PUSH
54580: LD_INT 14
54582: PUSH
54583: EMPTY
54584: LIST
54585: LIST
54586: LIST
54587: LIST
54588: ST_TO_ADDR
54589: GO 55098
54591: LD_INT 30
54593: DOUBLE
54594: EQUAL
54595: IFTRUE 54599
54597: GO 54625
54599: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
54600: LD_ADDR_VAR 0 3
54604: PUSH
54605: LD_INT 11
54607: PUSH
54608: LD_INT 12
54610: PUSH
54611: LD_INT 13
54613: PUSH
54614: LD_INT 14
54616: PUSH
54617: EMPTY
54618: LIST
54619: LIST
54620: LIST
54621: LIST
54622: ST_TO_ADDR
54623: GO 55098
54625: LD_INT 25
54627: DOUBLE
54628: EQUAL
54629: IFTRUE 54633
54631: GO 54651
54633: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
54634: LD_ADDR_VAR 0 3
54638: PUSH
54639: LD_INT 13
54641: PUSH
54642: LD_INT 14
54644: PUSH
54645: EMPTY
54646: LIST
54647: LIST
54648: ST_TO_ADDR
54649: GO 55098
54651: LD_INT 27
54653: DOUBLE
54654: EQUAL
54655: IFTRUE 54659
54657: GO 54677
54659: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
54660: LD_ADDR_VAR 0 3
54664: PUSH
54665: LD_INT 13
54667: PUSH
54668: LD_INT 14
54670: PUSH
54671: EMPTY
54672: LIST
54673: LIST
54674: ST_TO_ADDR
54675: GO 55098
54677: LD_INT 28
54679: DOUBLE
54680: EQUAL
54681: IFTRUE 54685
54683: GO 54703
54685: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
54686: LD_ADDR_VAR 0 3
54690: PUSH
54691: LD_INT 13
54693: PUSH
54694: LD_INT 14
54696: PUSH
54697: EMPTY
54698: LIST
54699: LIST
54700: ST_TO_ADDR
54701: GO 55098
54703: LD_INT 29
54705: DOUBLE
54706: EQUAL
54707: IFTRUE 54711
54709: GO 54729
54711: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
54712: LD_ADDR_VAR 0 3
54716: PUSH
54717: LD_INT 13
54719: PUSH
54720: LD_INT 14
54722: PUSH
54723: EMPTY
54724: LIST
54725: LIST
54726: ST_TO_ADDR
54727: GO 55098
54729: LD_INT 31
54731: DOUBLE
54732: EQUAL
54733: IFTRUE 54737
54735: GO 54755
54737: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
54738: LD_ADDR_VAR 0 3
54742: PUSH
54743: LD_INT 13
54745: PUSH
54746: LD_INT 14
54748: PUSH
54749: EMPTY
54750: LIST
54751: LIST
54752: ST_TO_ADDR
54753: GO 55098
54755: LD_INT 26
54757: DOUBLE
54758: EQUAL
54759: IFTRUE 54763
54761: GO 54781
54763: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
54764: LD_ADDR_VAR 0 3
54768: PUSH
54769: LD_INT 13
54771: PUSH
54772: LD_INT 14
54774: PUSH
54775: EMPTY
54776: LIST
54777: LIST
54778: ST_TO_ADDR
54779: GO 55098
54781: LD_INT 42
54783: DOUBLE
54784: EQUAL
54785: IFTRUE 54789
54787: GO 54815
54789: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
54790: LD_ADDR_VAR 0 3
54794: PUSH
54795: LD_INT 21
54797: PUSH
54798: LD_INT 22
54800: PUSH
54801: LD_INT 23
54803: PUSH
54804: LD_INT 24
54806: PUSH
54807: EMPTY
54808: LIST
54809: LIST
54810: LIST
54811: LIST
54812: ST_TO_ADDR
54813: GO 55098
54815: LD_INT 43
54817: DOUBLE
54818: EQUAL
54819: IFTRUE 54823
54821: GO 54849
54823: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
54824: LD_ADDR_VAR 0 3
54828: PUSH
54829: LD_INT 21
54831: PUSH
54832: LD_INT 22
54834: PUSH
54835: LD_INT 23
54837: PUSH
54838: LD_INT 24
54840: PUSH
54841: EMPTY
54842: LIST
54843: LIST
54844: LIST
54845: LIST
54846: ST_TO_ADDR
54847: GO 55098
54849: LD_INT 44
54851: DOUBLE
54852: EQUAL
54853: IFTRUE 54857
54855: GO 54883
54857: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
54858: LD_ADDR_VAR 0 3
54862: PUSH
54863: LD_INT 21
54865: PUSH
54866: LD_INT 22
54868: PUSH
54869: LD_INT 23
54871: PUSH
54872: LD_INT 24
54874: PUSH
54875: EMPTY
54876: LIST
54877: LIST
54878: LIST
54879: LIST
54880: ST_TO_ADDR
54881: GO 55098
54883: LD_INT 45
54885: DOUBLE
54886: EQUAL
54887: IFTRUE 54891
54889: GO 54917
54891: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
54892: LD_ADDR_VAR 0 3
54896: PUSH
54897: LD_INT 21
54899: PUSH
54900: LD_INT 22
54902: PUSH
54903: LD_INT 23
54905: PUSH
54906: LD_INT 24
54908: PUSH
54909: EMPTY
54910: LIST
54911: LIST
54912: LIST
54913: LIST
54914: ST_TO_ADDR
54915: GO 55098
54917: LD_INT 49
54919: DOUBLE
54920: EQUAL
54921: IFTRUE 54925
54923: GO 54951
54925: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
54926: LD_ADDR_VAR 0 3
54930: PUSH
54931: LD_INT 21
54933: PUSH
54934: LD_INT 22
54936: PUSH
54937: LD_INT 23
54939: PUSH
54940: LD_INT 24
54942: PUSH
54943: EMPTY
54944: LIST
54945: LIST
54946: LIST
54947: LIST
54948: ST_TO_ADDR
54949: GO 55098
54951: LD_INT 51
54953: DOUBLE
54954: EQUAL
54955: IFTRUE 54959
54957: GO 54985
54959: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
54960: LD_ADDR_VAR 0 3
54964: PUSH
54965: LD_INT 21
54967: PUSH
54968: LD_INT 22
54970: PUSH
54971: LD_INT 23
54973: PUSH
54974: LD_INT 24
54976: PUSH
54977: EMPTY
54978: LIST
54979: LIST
54980: LIST
54981: LIST
54982: ST_TO_ADDR
54983: GO 55098
54985: LD_INT 52
54987: DOUBLE
54988: EQUAL
54989: IFTRUE 54993
54991: GO 55019
54993: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
54994: LD_ADDR_VAR 0 3
54998: PUSH
54999: LD_INT 21
55001: PUSH
55002: LD_INT 22
55004: PUSH
55005: LD_INT 23
55007: PUSH
55008: LD_INT 24
55010: PUSH
55011: EMPTY
55012: LIST
55013: LIST
55014: LIST
55015: LIST
55016: ST_TO_ADDR
55017: GO 55098
55019: LD_INT 53
55021: DOUBLE
55022: EQUAL
55023: IFTRUE 55027
55025: GO 55045
55027: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
55028: LD_ADDR_VAR 0 3
55032: PUSH
55033: LD_INT 23
55035: PUSH
55036: LD_INT 24
55038: PUSH
55039: EMPTY
55040: LIST
55041: LIST
55042: ST_TO_ADDR
55043: GO 55098
55045: LD_INT 46
55047: DOUBLE
55048: EQUAL
55049: IFTRUE 55053
55051: GO 55071
55053: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
55054: LD_ADDR_VAR 0 3
55058: PUSH
55059: LD_INT 23
55061: PUSH
55062: LD_INT 24
55064: PUSH
55065: EMPTY
55066: LIST
55067: LIST
55068: ST_TO_ADDR
55069: GO 55098
55071: LD_INT 47
55073: DOUBLE
55074: EQUAL
55075: IFTRUE 55079
55077: GO 55097
55079: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
55080: LD_ADDR_VAR 0 3
55084: PUSH
55085: LD_INT 23
55087: PUSH
55088: LD_INT 24
55090: PUSH
55091: EMPTY
55092: LIST
55093: LIST
55094: ST_TO_ADDR
55095: GO 55098
55097: POP
// result := ( chassis in result ) ;
55098: LD_ADDR_VAR 0 3
55102: PUSH
55103: LD_VAR 0 1
55107: PUSH
55108: LD_VAR 0 3
55112: IN
55113: ST_TO_ADDR
// end ;
55114: LD_VAR 0 3
55118: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
55119: LD_INT 0
55121: PPUSH
55122: PPUSH
55123: PPUSH
55124: PPUSH
55125: PPUSH
55126: PPUSH
55127: PPUSH
// result := array ;
55128: LD_ADDR_VAR 0 5
55132: PUSH
55133: LD_VAR 0 1
55137: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
55138: LD_VAR 0 1
55142: NOT
55143: PUSH
55144: LD_VAR 0 2
55148: NOT
55149: OR
55150: PUSH
55151: LD_VAR 0 3
55155: NOT
55156: OR
55157: PUSH
55158: LD_VAR 0 2
55162: PUSH
55163: LD_VAR 0 1
55167: GREATER
55168: OR
55169: PUSH
55170: LD_VAR 0 3
55174: PUSH
55175: LD_VAR 0 1
55179: GREATER
55180: OR
55181: IFFALSE 55185
// exit ;
55183: GO 55481
// if direction then
55185: LD_VAR 0 4
55189: IFFALSE 55253
// begin d := 1 ;
55191: LD_ADDR_VAR 0 9
55195: PUSH
55196: LD_INT 1
55198: ST_TO_ADDR
// if i_from > i_to then
55199: LD_VAR 0 2
55203: PUSH
55204: LD_VAR 0 3
55208: GREATER
55209: IFFALSE 55235
// length := ( array - i_from ) + i_to else
55211: LD_ADDR_VAR 0 11
55215: PUSH
55216: LD_VAR 0 1
55220: PUSH
55221: LD_VAR 0 2
55225: MINUS
55226: PUSH
55227: LD_VAR 0 3
55231: PLUS
55232: ST_TO_ADDR
55233: GO 55251
// length := i_to - i_from ;
55235: LD_ADDR_VAR 0 11
55239: PUSH
55240: LD_VAR 0 3
55244: PUSH
55245: LD_VAR 0 2
55249: MINUS
55250: ST_TO_ADDR
// end else
55251: GO 55314
// begin d := - 1 ;
55253: LD_ADDR_VAR 0 9
55257: PUSH
55258: LD_INT 1
55260: NEG
55261: ST_TO_ADDR
// if i_from > i_to then
55262: LD_VAR 0 2
55266: PUSH
55267: LD_VAR 0 3
55271: GREATER
55272: IFFALSE 55292
// length := i_from - i_to else
55274: LD_ADDR_VAR 0 11
55278: PUSH
55279: LD_VAR 0 2
55283: PUSH
55284: LD_VAR 0 3
55288: MINUS
55289: ST_TO_ADDR
55290: GO 55314
// length := ( array - i_to ) + i_from ;
55292: LD_ADDR_VAR 0 11
55296: PUSH
55297: LD_VAR 0 1
55301: PUSH
55302: LD_VAR 0 3
55306: MINUS
55307: PUSH
55308: LD_VAR 0 2
55312: PLUS
55313: ST_TO_ADDR
// end ; if not length then
55314: LD_VAR 0 11
55318: NOT
55319: IFFALSE 55323
// exit ;
55321: GO 55481
// tmp := array ;
55323: LD_ADDR_VAR 0 10
55327: PUSH
55328: LD_VAR 0 1
55332: ST_TO_ADDR
// for i = 1 to length do
55333: LD_ADDR_VAR 0 6
55337: PUSH
55338: DOUBLE
55339: LD_INT 1
55341: DEC
55342: ST_TO_ADDR
55343: LD_VAR 0 11
55347: PUSH
55348: FOR_TO
55349: IFFALSE 55469
// begin for j = 1 to array do
55351: LD_ADDR_VAR 0 7
55355: PUSH
55356: DOUBLE
55357: LD_INT 1
55359: DEC
55360: ST_TO_ADDR
55361: LD_VAR 0 1
55365: PUSH
55366: FOR_TO
55367: IFFALSE 55455
// begin k := j + d ;
55369: LD_ADDR_VAR 0 8
55373: PUSH
55374: LD_VAR 0 7
55378: PUSH
55379: LD_VAR 0 9
55383: PLUS
55384: ST_TO_ADDR
// if k > array then
55385: LD_VAR 0 8
55389: PUSH
55390: LD_VAR 0 1
55394: GREATER
55395: IFFALSE 55405
// k := 1 ;
55397: LD_ADDR_VAR 0 8
55401: PUSH
55402: LD_INT 1
55404: ST_TO_ADDR
// if not k then
55405: LD_VAR 0 8
55409: NOT
55410: IFFALSE 55422
// k := array ;
55412: LD_ADDR_VAR 0 8
55416: PUSH
55417: LD_VAR 0 1
55421: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
55422: LD_ADDR_VAR 0 10
55426: PUSH
55427: LD_VAR 0 10
55431: PPUSH
55432: LD_VAR 0 8
55436: PPUSH
55437: LD_VAR 0 1
55441: PUSH
55442: LD_VAR 0 7
55446: ARRAY
55447: PPUSH
55448: CALL_OW 1
55452: ST_TO_ADDR
// end ;
55453: GO 55366
55455: POP
55456: POP
// array := tmp ;
55457: LD_ADDR_VAR 0 1
55461: PUSH
55462: LD_VAR 0 10
55466: ST_TO_ADDR
// end ;
55467: GO 55348
55469: POP
55470: POP
// result := array ;
55471: LD_ADDR_VAR 0 5
55475: PUSH
55476: LD_VAR 0 1
55480: ST_TO_ADDR
// end ;
55481: LD_VAR 0 5
55485: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
55486: LD_INT 0
55488: PPUSH
55489: PPUSH
// result := 0 ;
55490: LD_ADDR_VAR 0 3
55494: PUSH
55495: LD_INT 0
55497: ST_TO_ADDR
// if not array or not value in array then
55498: LD_VAR 0 1
55502: NOT
55503: PUSH
55504: LD_VAR 0 2
55508: PUSH
55509: LD_VAR 0 1
55513: IN
55514: NOT
55515: OR
55516: IFFALSE 55520
// exit ;
55518: GO 55574
// for i = 1 to array do
55520: LD_ADDR_VAR 0 4
55524: PUSH
55525: DOUBLE
55526: LD_INT 1
55528: DEC
55529: ST_TO_ADDR
55530: LD_VAR 0 1
55534: PUSH
55535: FOR_TO
55536: IFFALSE 55572
// if value = array [ i ] then
55538: LD_VAR 0 2
55542: PUSH
55543: LD_VAR 0 1
55547: PUSH
55548: LD_VAR 0 4
55552: ARRAY
55553: EQUAL
55554: IFFALSE 55570
// begin result := i ;
55556: LD_ADDR_VAR 0 3
55560: PUSH
55561: LD_VAR 0 4
55565: ST_TO_ADDR
// exit ;
55566: POP
55567: POP
55568: GO 55574
// end ;
55570: GO 55535
55572: POP
55573: POP
// end ;
55574: LD_VAR 0 3
55578: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
55579: LD_INT 0
55581: PPUSH
// vc_chassis := chassis ;
55582: LD_ADDR_OWVAR 37
55586: PUSH
55587: LD_VAR 0 1
55591: ST_TO_ADDR
// vc_engine := engine ;
55592: LD_ADDR_OWVAR 39
55596: PUSH
55597: LD_VAR 0 2
55601: ST_TO_ADDR
// vc_control := control ;
55602: LD_ADDR_OWVAR 38
55606: PUSH
55607: LD_VAR 0 3
55611: ST_TO_ADDR
// vc_weapon := weapon ;
55612: LD_ADDR_OWVAR 40
55616: PUSH
55617: LD_VAR 0 4
55621: ST_TO_ADDR
// vc_fuel_battery := fuel ;
55622: LD_ADDR_OWVAR 41
55626: PUSH
55627: LD_VAR 0 5
55631: ST_TO_ADDR
// end ;
55632: LD_VAR 0 6
55636: RET
// export function WantPlant ( unit ) ; var task ; begin
55637: LD_INT 0
55639: PPUSH
55640: PPUSH
// result := false ;
55641: LD_ADDR_VAR 0 2
55645: PUSH
55646: LD_INT 0
55648: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
55649: LD_ADDR_VAR 0 3
55653: PUSH
55654: LD_VAR 0 1
55658: PPUSH
55659: CALL_OW 437
55663: ST_TO_ADDR
// if task then
55664: LD_VAR 0 3
55668: IFFALSE 55696
// if task [ 1 ] [ 1 ] = p then
55670: LD_VAR 0 3
55674: PUSH
55675: LD_INT 1
55677: ARRAY
55678: PUSH
55679: LD_INT 1
55681: ARRAY
55682: PUSH
55683: LD_STRING p
55685: EQUAL
55686: IFFALSE 55696
// result := true ;
55688: LD_ADDR_VAR 0 2
55692: PUSH
55693: LD_INT 1
55695: ST_TO_ADDR
// end ;
55696: LD_VAR 0 2
55700: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
55701: LD_INT 0
55703: PPUSH
55704: PPUSH
55705: PPUSH
55706: PPUSH
// if pos < 1 then
55707: LD_VAR 0 2
55711: PUSH
55712: LD_INT 1
55714: LESS
55715: IFFALSE 55719
// exit ;
55717: GO 56022
// if pos = 1 then
55719: LD_VAR 0 2
55723: PUSH
55724: LD_INT 1
55726: EQUAL
55727: IFFALSE 55760
// result := Replace ( arr , pos [ 1 ] , value ) else
55729: LD_ADDR_VAR 0 4
55733: PUSH
55734: LD_VAR 0 1
55738: PPUSH
55739: LD_VAR 0 2
55743: PUSH
55744: LD_INT 1
55746: ARRAY
55747: PPUSH
55748: LD_VAR 0 3
55752: PPUSH
55753: CALL_OW 1
55757: ST_TO_ADDR
55758: GO 56022
// begin tmp := arr ;
55760: LD_ADDR_VAR 0 6
55764: PUSH
55765: LD_VAR 0 1
55769: ST_TO_ADDR
// s_arr := [ tmp ] ;
55770: LD_ADDR_VAR 0 7
55774: PUSH
55775: LD_VAR 0 6
55779: PUSH
55780: EMPTY
55781: LIST
55782: ST_TO_ADDR
// for i = 1 to pos - 1 do
55783: LD_ADDR_VAR 0 5
55787: PUSH
55788: DOUBLE
55789: LD_INT 1
55791: DEC
55792: ST_TO_ADDR
55793: LD_VAR 0 2
55797: PUSH
55798: LD_INT 1
55800: MINUS
55801: PUSH
55802: FOR_TO
55803: IFFALSE 55848
// begin tmp := tmp [ pos [ i ] ] ;
55805: LD_ADDR_VAR 0 6
55809: PUSH
55810: LD_VAR 0 6
55814: PUSH
55815: LD_VAR 0 2
55819: PUSH
55820: LD_VAR 0 5
55824: ARRAY
55825: ARRAY
55826: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
55827: LD_ADDR_VAR 0 7
55831: PUSH
55832: LD_VAR 0 7
55836: PUSH
55837: LD_VAR 0 6
55841: PUSH
55842: EMPTY
55843: LIST
55844: ADD
55845: ST_TO_ADDR
// end ;
55846: GO 55802
55848: POP
55849: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
55850: LD_ADDR_VAR 0 6
55854: PUSH
55855: LD_VAR 0 6
55859: PPUSH
55860: LD_VAR 0 2
55864: PUSH
55865: LD_VAR 0 2
55869: ARRAY
55870: PPUSH
55871: LD_VAR 0 3
55875: PPUSH
55876: CALL_OW 1
55880: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
55881: LD_ADDR_VAR 0 7
55885: PUSH
55886: LD_VAR 0 7
55890: PPUSH
55891: LD_VAR 0 7
55895: PPUSH
55896: LD_VAR 0 6
55900: PPUSH
55901: CALL_OW 1
55905: ST_TO_ADDR
// for i = s_arr downto 2 do
55906: LD_ADDR_VAR 0 5
55910: PUSH
55911: DOUBLE
55912: LD_VAR 0 7
55916: INC
55917: ST_TO_ADDR
55918: LD_INT 2
55920: PUSH
55921: FOR_DOWNTO
55922: IFFALSE 56006
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
55924: LD_ADDR_VAR 0 6
55928: PUSH
55929: LD_VAR 0 7
55933: PUSH
55934: LD_VAR 0 5
55938: PUSH
55939: LD_INT 1
55941: MINUS
55942: ARRAY
55943: PPUSH
55944: LD_VAR 0 2
55948: PUSH
55949: LD_VAR 0 5
55953: PUSH
55954: LD_INT 1
55956: MINUS
55957: ARRAY
55958: PPUSH
55959: LD_VAR 0 7
55963: PUSH
55964: LD_VAR 0 5
55968: ARRAY
55969: PPUSH
55970: CALL_OW 1
55974: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
55975: LD_ADDR_VAR 0 7
55979: PUSH
55980: LD_VAR 0 7
55984: PPUSH
55985: LD_VAR 0 5
55989: PUSH
55990: LD_INT 1
55992: MINUS
55993: PPUSH
55994: LD_VAR 0 6
55998: PPUSH
55999: CALL_OW 1
56003: ST_TO_ADDR
// end ;
56004: GO 55921
56006: POP
56007: POP
// result := s_arr [ 1 ] ;
56008: LD_ADDR_VAR 0 4
56012: PUSH
56013: LD_VAR 0 7
56017: PUSH
56018: LD_INT 1
56020: ARRAY
56021: ST_TO_ADDR
// end ; end ;
56022: LD_VAR 0 4
56026: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
56027: LD_INT 0
56029: PPUSH
56030: PPUSH
// if not list then
56031: LD_VAR 0 1
56035: NOT
56036: IFFALSE 56040
// exit ;
56038: GO 56131
// i := list [ pos1 ] ;
56040: LD_ADDR_VAR 0 5
56044: PUSH
56045: LD_VAR 0 1
56049: PUSH
56050: LD_VAR 0 2
56054: ARRAY
56055: ST_TO_ADDR
// if not i then
56056: LD_VAR 0 5
56060: NOT
56061: IFFALSE 56065
// exit ;
56063: GO 56131
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
56065: LD_ADDR_VAR 0 1
56069: PUSH
56070: LD_VAR 0 1
56074: PPUSH
56075: LD_VAR 0 2
56079: PPUSH
56080: LD_VAR 0 1
56084: PUSH
56085: LD_VAR 0 3
56089: ARRAY
56090: PPUSH
56091: CALL_OW 1
56095: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
56096: LD_ADDR_VAR 0 1
56100: PUSH
56101: LD_VAR 0 1
56105: PPUSH
56106: LD_VAR 0 3
56110: PPUSH
56111: LD_VAR 0 5
56115: PPUSH
56116: CALL_OW 1
56120: ST_TO_ADDR
// result := list ;
56121: LD_ADDR_VAR 0 4
56125: PUSH
56126: LD_VAR 0 1
56130: ST_TO_ADDR
// end ;
56131: LD_VAR 0 4
56135: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
56136: LD_INT 0
56138: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
56139: LD_ADDR_VAR 0 5
56143: PUSH
56144: LD_VAR 0 1
56148: PPUSH
56149: CALL_OW 250
56153: PPUSH
56154: LD_VAR 0 1
56158: PPUSH
56159: CALL_OW 251
56163: PPUSH
56164: LD_VAR 0 2
56168: PPUSH
56169: LD_VAR 0 3
56173: PPUSH
56174: LD_VAR 0 4
56178: PPUSH
56179: CALL 56189 0 5
56183: ST_TO_ADDR
// end ;
56184: LD_VAR 0 5
56188: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
56189: LD_INT 0
56191: PPUSH
56192: PPUSH
56193: PPUSH
56194: PPUSH
// if not list then
56195: LD_VAR 0 3
56199: NOT
56200: IFFALSE 56204
// exit ;
56202: GO 56592
// result := [ ] ;
56204: LD_ADDR_VAR 0 6
56208: PUSH
56209: EMPTY
56210: ST_TO_ADDR
// for i in list do
56211: LD_ADDR_VAR 0 7
56215: PUSH
56216: LD_VAR 0 3
56220: PUSH
56221: FOR_IN
56222: IFFALSE 56424
// begin tmp := GetDistUnitXY ( i , x , y ) ;
56224: LD_ADDR_VAR 0 9
56228: PUSH
56229: LD_VAR 0 7
56233: PPUSH
56234: LD_VAR 0 1
56238: PPUSH
56239: LD_VAR 0 2
56243: PPUSH
56244: CALL_OW 297
56248: ST_TO_ADDR
// if not result then
56249: LD_VAR 0 6
56253: NOT
56254: IFFALSE 56280
// result := [ [ i , tmp ] ] else
56256: LD_ADDR_VAR 0 6
56260: PUSH
56261: LD_VAR 0 7
56265: PUSH
56266: LD_VAR 0 9
56270: PUSH
56271: EMPTY
56272: LIST
56273: LIST
56274: PUSH
56275: EMPTY
56276: LIST
56277: ST_TO_ADDR
56278: GO 56422
// begin if result [ result ] [ 2 ] < tmp then
56280: LD_VAR 0 6
56284: PUSH
56285: LD_VAR 0 6
56289: ARRAY
56290: PUSH
56291: LD_INT 2
56293: ARRAY
56294: PUSH
56295: LD_VAR 0 9
56299: LESS
56300: IFFALSE 56342
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
56302: LD_ADDR_VAR 0 6
56306: PUSH
56307: LD_VAR 0 6
56311: PPUSH
56312: LD_VAR 0 6
56316: PUSH
56317: LD_INT 1
56319: PLUS
56320: PPUSH
56321: LD_VAR 0 7
56325: PUSH
56326: LD_VAR 0 9
56330: PUSH
56331: EMPTY
56332: LIST
56333: LIST
56334: PPUSH
56335: CALL_OW 2
56339: ST_TO_ADDR
56340: GO 56422
// for j = 1 to result do
56342: LD_ADDR_VAR 0 8
56346: PUSH
56347: DOUBLE
56348: LD_INT 1
56350: DEC
56351: ST_TO_ADDR
56352: LD_VAR 0 6
56356: PUSH
56357: FOR_TO
56358: IFFALSE 56420
// begin if tmp < result [ j ] [ 2 ] then
56360: LD_VAR 0 9
56364: PUSH
56365: LD_VAR 0 6
56369: PUSH
56370: LD_VAR 0 8
56374: ARRAY
56375: PUSH
56376: LD_INT 2
56378: ARRAY
56379: LESS
56380: IFFALSE 56418
// begin result := Insert ( result , j , [ i , tmp ] ) ;
56382: LD_ADDR_VAR 0 6
56386: PUSH
56387: LD_VAR 0 6
56391: PPUSH
56392: LD_VAR 0 8
56396: PPUSH
56397: LD_VAR 0 7
56401: PUSH
56402: LD_VAR 0 9
56406: PUSH
56407: EMPTY
56408: LIST
56409: LIST
56410: PPUSH
56411: CALL_OW 2
56415: ST_TO_ADDR
// break ;
56416: GO 56420
// end ; end ;
56418: GO 56357
56420: POP
56421: POP
// end ; end ;
56422: GO 56221
56424: POP
56425: POP
// if result and not asc then
56426: LD_VAR 0 6
56430: PUSH
56431: LD_VAR 0 4
56435: NOT
56436: AND
56437: IFFALSE 56512
// begin tmp := result ;
56439: LD_ADDR_VAR 0 9
56443: PUSH
56444: LD_VAR 0 6
56448: ST_TO_ADDR
// for i = tmp downto 1 do
56449: LD_ADDR_VAR 0 7
56453: PUSH
56454: DOUBLE
56455: LD_VAR 0 9
56459: INC
56460: ST_TO_ADDR
56461: LD_INT 1
56463: PUSH
56464: FOR_DOWNTO
56465: IFFALSE 56510
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
56467: LD_ADDR_VAR 0 6
56471: PUSH
56472: LD_VAR 0 6
56476: PPUSH
56477: LD_VAR 0 9
56481: PUSH
56482: LD_VAR 0 7
56486: MINUS
56487: PUSH
56488: LD_INT 1
56490: PLUS
56491: PPUSH
56492: LD_VAR 0 9
56496: PUSH
56497: LD_VAR 0 7
56501: ARRAY
56502: PPUSH
56503: CALL_OW 1
56507: ST_TO_ADDR
56508: GO 56464
56510: POP
56511: POP
// end ; tmp := [ ] ;
56512: LD_ADDR_VAR 0 9
56516: PUSH
56517: EMPTY
56518: ST_TO_ADDR
// if mode then
56519: LD_VAR 0 5
56523: IFFALSE 56592
// begin for i = 1 to result do
56525: LD_ADDR_VAR 0 7
56529: PUSH
56530: DOUBLE
56531: LD_INT 1
56533: DEC
56534: ST_TO_ADDR
56535: LD_VAR 0 6
56539: PUSH
56540: FOR_TO
56541: IFFALSE 56580
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
56543: LD_ADDR_VAR 0 9
56547: PUSH
56548: LD_VAR 0 9
56552: PPUSH
56553: LD_VAR 0 7
56557: PPUSH
56558: LD_VAR 0 6
56562: PUSH
56563: LD_VAR 0 7
56567: ARRAY
56568: PUSH
56569: LD_INT 1
56571: ARRAY
56572: PPUSH
56573: CALL_OW 1
56577: ST_TO_ADDR
56578: GO 56540
56580: POP
56581: POP
// result := tmp ;
56582: LD_ADDR_VAR 0 6
56586: PUSH
56587: LD_VAR 0 9
56591: ST_TO_ADDR
// end ; end ;
56592: LD_VAR 0 6
56596: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
56597: LD_INT 0
56599: PPUSH
56600: PPUSH
56601: PPUSH
56602: PPUSH
56603: PPUSH
56604: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
56605: LD_ADDR_VAR 0 5
56609: PUSH
56610: LD_INT 0
56612: PUSH
56613: LD_INT 0
56615: PUSH
56616: LD_INT 0
56618: PUSH
56619: EMPTY
56620: PUSH
56621: EMPTY
56622: LIST
56623: LIST
56624: LIST
56625: LIST
56626: ST_TO_ADDR
// if not x or not y then
56627: LD_VAR 0 2
56631: NOT
56632: PUSH
56633: LD_VAR 0 3
56637: NOT
56638: OR
56639: IFFALSE 56643
// exit ;
56641: GO 58289
// if not range then
56643: LD_VAR 0 4
56647: NOT
56648: IFFALSE 56658
// range := 10 ;
56650: LD_ADDR_VAR 0 4
56654: PUSH
56655: LD_INT 10
56657: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
56658: LD_ADDR_VAR 0 8
56662: PUSH
56663: LD_INT 81
56665: PUSH
56666: LD_VAR 0 1
56670: PUSH
56671: EMPTY
56672: LIST
56673: LIST
56674: PUSH
56675: LD_INT 92
56677: PUSH
56678: LD_VAR 0 2
56682: PUSH
56683: LD_VAR 0 3
56687: PUSH
56688: LD_VAR 0 4
56692: PUSH
56693: EMPTY
56694: LIST
56695: LIST
56696: LIST
56697: LIST
56698: PUSH
56699: LD_INT 3
56701: PUSH
56702: LD_INT 21
56704: PUSH
56705: LD_INT 3
56707: PUSH
56708: EMPTY
56709: LIST
56710: LIST
56711: PUSH
56712: EMPTY
56713: LIST
56714: LIST
56715: PUSH
56716: EMPTY
56717: LIST
56718: LIST
56719: LIST
56720: PPUSH
56721: CALL_OW 69
56725: ST_TO_ADDR
// if not tmp then
56726: LD_VAR 0 8
56730: NOT
56731: IFFALSE 56735
// exit ;
56733: GO 58289
// for i in tmp do
56735: LD_ADDR_VAR 0 6
56739: PUSH
56740: LD_VAR 0 8
56744: PUSH
56745: FOR_IN
56746: IFFALSE 58264
// begin points := [ 0 , 0 , 0 ] ;
56748: LD_ADDR_VAR 0 9
56752: PUSH
56753: LD_INT 0
56755: PUSH
56756: LD_INT 0
56758: PUSH
56759: LD_INT 0
56761: PUSH
56762: EMPTY
56763: LIST
56764: LIST
56765: LIST
56766: ST_TO_ADDR
// bpoints := 1 ;
56767: LD_ADDR_VAR 0 10
56771: PUSH
56772: LD_INT 1
56774: ST_TO_ADDR
// case GetType ( i ) of unit_human :
56775: LD_VAR 0 6
56779: PPUSH
56780: CALL_OW 247
56784: PUSH
56785: LD_INT 1
56787: DOUBLE
56788: EQUAL
56789: IFTRUE 56793
56791: GO 57371
56793: POP
// begin if GetClass ( i ) = 1 then
56794: LD_VAR 0 6
56798: PPUSH
56799: CALL_OW 257
56803: PUSH
56804: LD_INT 1
56806: EQUAL
56807: IFFALSE 56828
// points := [ 10 , 5 , 3 ] ;
56809: LD_ADDR_VAR 0 9
56813: PUSH
56814: LD_INT 10
56816: PUSH
56817: LD_INT 5
56819: PUSH
56820: LD_INT 3
56822: PUSH
56823: EMPTY
56824: LIST
56825: LIST
56826: LIST
56827: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
56828: LD_VAR 0 6
56832: PPUSH
56833: CALL_OW 257
56837: PUSH
56838: LD_INT 2
56840: PUSH
56841: LD_INT 3
56843: PUSH
56844: LD_INT 4
56846: PUSH
56847: EMPTY
56848: LIST
56849: LIST
56850: LIST
56851: IN
56852: IFFALSE 56873
// points := [ 3 , 2 , 1 ] ;
56854: LD_ADDR_VAR 0 9
56858: PUSH
56859: LD_INT 3
56861: PUSH
56862: LD_INT 2
56864: PUSH
56865: LD_INT 1
56867: PUSH
56868: EMPTY
56869: LIST
56870: LIST
56871: LIST
56872: ST_TO_ADDR
// if GetClass ( i ) = 5 then
56873: LD_VAR 0 6
56877: PPUSH
56878: CALL_OW 257
56882: PUSH
56883: LD_INT 5
56885: EQUAL
56886: IFFALSE 56907
// points := [ 130 , 5 , 2 ] ;
56888: LD_ADDR_VAR 0 9
56892: PUSH
56893: LD_INT 130
56895: PUSH
56896: LD_INT 5
56898: PUSH
56899: LD_INT 2
56901: PUSH
56902: EMPTY
56903: LIST
56904: LIST
56905: LIST
56906: ST_TO_ADDR
// if GetClass ( i ) = 8 then
56907: LD_VAR 0 6
56911: PPUSH
56912: CALL_OW 257
56916: PUSH
56917: LD_INT 8
56919: EQUAL
56920: IFFALSE 56941
// points := [ 35 , 35 , 30 ] ;
56922: LD_ADDR_VAR 0 9
56926: PUSH
56927: LD_INT 35
56929: PUSH
56930: LD_INT 35
56932: PUSH
56933: LD_INT 30
56935: PUSH
56936: EMPTY
56937: LIST
56938: LIST
56939: LIST
56940: ST_TO_ADDR
// if GetClass ( i ) = 9 then
56941: LD_VAR 0 6
56945: PPUSH
56946: CALL_OW 257
56950: PUSH
56951: LD_INT 9
56953: EQUAL
56954: IFFALSE 56975
// points := [ 20 , 55 , 40 ] ;
56956: LD_ADDR_VAR 0 9
56960: PUSH
56961: LD_INT 20
56963: PUSH
56964: LD_INT 55
56966: PUSH
56967: LD_INT 40
56969: PUSH
56970: EMPTY
56971: LIST
56972: LIST
56973: LIST
56974: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
56975: LD_VAR 0 6
56979: PPUSH
56980: CALL_OW 257
56984: PUSH
56985: LD_INT 12
56987: PUSH
56988: LD_INT 16
56990: PUSH
56991: EMPTY
56992: LIST
56993: LIST
56994: IN
56995: IFFALSE 57016
// points := [ 5 , 3 , 2 ] ;
56997: LD_ADDR_VAR 0 9
57001: PUSH
57002: LD_INT 5
57004: PUSH
57005: LD_INT 3
57007: PUSH
57008: LD_INT 2
57010: PUSH
57011: EMPTY
57012: LIST
57013: LIST
57014: LIST
57015: ST_TO_ADDR
// if GetClass ( i ) = 17 then
57016: LD_VAR 0 6
57020: PPUSH
57021: CALL_OW 257
57025: PUSH
57026: LD_INT 17
57028: EQUAL
57029: IFFALSE 57050
// points := [ 100 , 50 , 75 ] ;
57031: LD_ADDR_VAR 0 9
57035: PUSH
57036: LD_INT 100
57038: PUSH
57039: LD_INT 50
57041: PUSH
57042: LD_INT 75
57044: PUSH
57045: EMPTY
57046: LIST
57047: LIST
57048: LIST
57049: ST_TO_ADDR
// if GetClass ( i ) = 15 then
57050: LD_VAR 0 6
57054: PPUSH
57055: CALL_OW 257
57059: PUSH
57060: LD_INT 15
57062: EQUAL
57063: IFFALSE 57084
// points := [ 10 , 5 , 3 ] ;
57065: LD_ADDR_VAR 0 9
57069: PUSH
57070: LD_INT 10
57072: PUSH
57073: LD_INT 5
57075: PUSH
57076: LD_INT 3
57078: PUSH
57079: EMPTY
57080: LIST
57081: LIST
57082: LIST
57083: ST_TO_ADDR
// if GetClass ( i ) = 14 then
57084: LD_VAR 0 6
57088: PPUSH
57089: CALL_OW 257
57093: PUSH
57094: LD_INT 14
57096: EQUAL
57097: IFFALSE 57118
// points := [ 10 , 0 , 0 ] ;
57099: LD_ADDR_VAR 0 9
57103: PUSH
57104: LD_INT 10
57106: PUSH
57107: LD_INT 0
57109: PUSH
57110: LD_INT 0
57112: PUSH
57113: EMPTY
57114: LIST
57115: LIST
57116: LIST
57117: ST_TO_ADDR
// if GetClass ( i ) = 11 then
57118: LD_VAR 0 6
57122: PPUSH
57123: CALL_OW 257
57127: PUSH
57128: LD_INT 11
57130: EQUAL
57131: IFFALSE 57152
// points := [ 30 , 10 , 5 ] ;
57133: LD_ADDR_VAR 0 9
57137: PUSH
57138: LD_INT 30
57140: PUSH
57141: LD_INT 10
57143: PUSH
57144: LD_INT 5
57146: PUSH
57147: EMPTY
57148: LIST
57149: LIST
57150: LIST
57151: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
57152: LD_VAR 0 1
57156: PPUSH
57157: LD_INT 5
57159: PPUSH
57160: CALL_OW 321
57164: PUSH
57165: LD_INT 2
57167: EQUAL
57168: IFFALSE 57185
// bpoints := bpoints * 1.8 ;
57170: LD_ADDR_VAR 0 10
57174: PUSH
57175: LD_VAR 0 10
57179: PUSH
57180: LD_REAL  1.80000000000000E+0000
57183: MUL
57184: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
57185: LD_VAR 0 6
57189: PPUSH
57190: CALL_OW 257
57194: PUSH
57195: LD_INT 1
57197: PUSH
57198: LD_INT 2
57200: PUSH
57201: LD_INT 3
57203: PUSH
57204: LD_INT 4
57206: PUSH
57207: EMPTY
57208: LIST
57209: LIST
57210: LIST
57211: LIST
57212: IN
57213: PUSH
57214: LD_VAR 0 1
57218: PPUSH
57219: LD_INT 51
57221: PPUSH
57222: CALL_OW 321
57226: PUSH
57227: LD_INT 2
57229: EQUAL
57230: AND
57231: IFFALSE 57248
// bpoints := bpoints * 1.2 ;
57233: LD_ADDR_VAR 0 10
57237: PUSH
57238: LD_VAR 0 10
57242: PUSH
57243: LD_REAL  1.20000000000000E+0000
57246: MUL
57247: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
57248: LD_VAR 0 6
57252: PPUSH
57253: CALL_OW 257
57257: PUSH
57258: LD_INT 5
57260: PUSH
57261: LD_INT 7
57263: PUSH
57264: LD_INT 9
57266: PUSH
57267: EMPTY
57268: LIST
57269: LIST
57270: LIST
57271: IN
57272: PUSH
57273: LD_VAR 0 1
57277: PPUSH
57278: LD_INT 52
57280: PPUSH
57281: CALL_OW 321
57285: PUSH
57286: LD_INT 2
57288: EQUAL
57289: AND
57290: IFFALSE 57307
// bpoints := bpoints * 1.5 ;
57292: LD_ADDR_VAR 0 10
57296: PUSH
57297: LD_VAR 0 10
57301: PUSH
57302: LD_REAL  1.50000000000000E+0000
57305: MUL
57306: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
57307: LD_VAR 0 1
57311: PPUSH
57312: LD_INT 66
57314: PPUSH
57315: CALL_OW 321
57319: PUSH
57320: LD_INT 2
57322: EQUAL
57323: IFFALSE 57340
// bpoints := bpoints * 1.1 ;
57325: LD_ADDR_VAR 0 10
57329: PUSH
57330: LD_VAR 0 10
57334: PUSH
57335: LD_REAL  1.10000000000000E+0000
57338: MUL
57339: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
57340: LD_ADDR_VAR 0 10
57344: PUSH
57345: LD_VAR 0 10
57349: PUSH
57350: LD_VAR 0 6
57354: PPUSH
57355: LD_INT 1
57357: PPUSH
57358: CALL_OW 259
57362: PUSH
57363: LD_REAL  1.15000000000000E+0000
57366: MUL
57367: MUL
57368: ST_TO_ADDR
// end ; unit_vehicle :
57369: GO 58193
57371: LD_INT 2
57373: DOUBLE
57374: EQUAL
57375: IFTRUE 57379
57377: GO 58181
57379: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
57380: LD_VAR 0 6
57384: PPUSH
57385: CALL_OW 264
57389: PUSH
57390: LD_INT 2
57392: PUSH
57393: LD_INT 42
57395: PUSH
57396: LD_INT 24
57398: PUSH
57399: EMPTY
57400: LIST
57401: LIST
57402: LIST
57403: IN
57404: IFFALSE 57425
// points := [ 25 , 5 , 3 ] ;
57406: LD_ADDR_VAR 0 9
57410: PUSH
57411: LD_INT 25
57413: PUSH
57414: LD_INT 5
57416: PUSH
57417: LD_INT 3
57419: PUSH
57420: EMPTY
57421: LIST
57422: LIST
57423: LIST
57424: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
57425: LD_VAR 0 6
57429: PPUSH
57430: CALL_OW 264
57434: PUSH
57435: LD_INT 4
57437: PUSH
57438: LD_INT 43
57440: PUSH
57441: LD_INT 25
57443: PUSH
57444: EMPTY
57445: LIST
57446: LIST
57447: LIST
57448: IN
57449: IFFALSE 57470
// points := [ 40 , 15 , 5 ] ;
57451: LD_ADDR_VAR 0 9
57455: PUSH
57456: LD_INT 40
57458: PUSH
57459: LD_INT 15
57461: PUSH
57462: LD_INT 5
57464: PUSH
57465: EMPTY
57466: LIST
57467: LIST
57468: LIST
57469: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
57470: LD_VAR 0 6
57474: PPUSH
57475: CALL_OW 264
57479: PUSH
57480: LD_INT 3
57482: PUSH
57483: LD_INT 23
57485: PUSH
57486: EMPTY
57487: LIST
57488: LIST
57489: IN
57490: IFFALSE 57511
// points := [ 7 , 25 , 8 ] ;
57492: LD_ADDR_VAR 0 9
57496: PUSH
57497: LD_INT 7
57499: PUSH
57500: LD_INT 25
57502: PUSH
57503: LD_INT 8
57505: PUSH
57506: EMPTY
57507: LIST
57508: LIST
57509: LIST
57510: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
57511: LD_VAR 0 6
57515: PPUSH
57516: CALL_OW 264
57520: PUSH
57521: LD_INT 5
57523: PUSH
57524: LD_INT 27
57526: PUSH
57527: LD_INT 44
57529: PUSH
57530: EMPTY
57531: LIST
57532: LIST
57533: LIST
57534: IN
57535: IFFALSE 57556
// points := [ 14 , 50 , 16 ] ;
57537: LD_ADDR_VAR 0 9
57541: PUSH
57542: LD_INT 14
57544: PUSH
57545: LD_INT 50
57547: PUSH
57548: LD_INT 16
57550: PUSH
57551: EMPTY
57552: LIST
57553: LIST
57554: LIST
57555: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
57556: LD_VAR 0 6
57560: PPUSH
57561: CALL_OW 264
57565: PUSH
57566: LD_INT 6
57568: PUSH
57569: LD_INT 46
57571: PUSH
57572: EMPTY
57573: LIST
57574: LIST
57575: IN
57576: IFFALSE 57597
// points := [ 32 , 120 , 70 ] ;
57578: LD_ADDR_VAR 0 9
57582: PUSH
57583: LD_INT 32
57585: PUSH
57586: LD_INT 120
57588: PUSH
57589: LD_INT 70
57591: PUSH
57592: EMPTY
57593: LIST
57594: LIST
57595: LIST
57596: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
57597: LD_VAR 0 6
57601: PPUSH
57602: CALL_OW 264
57606: PUSH
57607: LD_INT 7
57609: PUSH
57610: LD_INT 28
57612: PUSH
57613: LD_INT 45
57615: PUSH
57616: EMPTY
57617: LIST
57618: LIST
57619: LIST
57620: IN
57621: IFFALSE 57642
// points := [ 35 , 20 , 45 ] ;
57623: LD_ADDR_VAR 0 9
57627: PUSH
57628: LD_INT 35
57630: PUSH
57631: LD_INT 20
57633: PUSH
57634: LD_INT 45
57636: PUSH
57637: EMPTY
57638: LIST
57639: LIST
57640: LIST
57641: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
57642: LD_VAR 0 6
57646: PPUSH
57647: CALL_OW 264
57651: PUSH
57652: LD_INT 47
57654: PUSH
57655: EMPTY
57656: LIST
57657: IN
57658: IFFALSE 57679
// points := [ 67 , 45 , 75 ] ;
57660: LD_ADDR_VAR 0 9
57664: PUSH
57665: LD_INT 67
57667: PUSH
57668: LD_INT 45
57670: PUSH
57671: LD_INT 75
57673: PUSH
57674: EMPTY
57675: LIST
57676: LIST
57677: LIST
57678: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
57679: LD_VAR 0 6
57683: PPUSH
57684: CALL_OW 264
57688: PUSH
57689: LD_INT 26
57691: PUSH
57692: EMPTY
57693: LIST
57694: IN
57695: IFFALSE 57716
// points := [ 120 , 30 , 80 ] ;
57697: LD_ADDR_VAR 0 9
57701: PUSH
57702: LD_INT 120
57704: PUSH
57705: LD_INT 30
57707: PUSH
57708: LD_INT 80
57710: PUSH
57711: EMPTY
57712: LIST
57713: LIST
57714: LIST
57715: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
57716: LD_VAR 0 6
57720: PPUSH
57721: CALL_OW 264
57725: PUSH
57726: LD_INT 22
57728: PUSH
57729: EMPTY
57730: LIST
57731: IN
57732: IFFALSE 57753
// points := [ 40 , 1 , 1 ] ;
57734: LD_ADDR_VAR 0 9
57738: PUSH
57739: LD_INT 40
57741: PUSH
57742: LD_INT 1
57744: PUSH
57745: LD_INT 1
57747: PUSH
57748: EMPTY
57749: LIST
57750: LIST
57751: LIST
57752: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
57753: LD_VAR 0 6
57757: PPUSH
57758: CALL_OW 264
57762: PUSH
57763: LD_INT 29
57765: PUSH
57766: EMPTY
57767: LIST
57768: IN
57769: IFFALSE 57790
// points := [ 70 , 200 , 400 ] ;
57771: LD_ADDR_VAR 0 9
57775: PUSH
57776: LD_INT 70
57778: PUSH
57779: LD_INT 200
57781: PUSH
57782: LD_INT 400
57784: PUSH
57785: EMPTY
57786: LIST
57787: LIST
57788: LIST
57789: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
57790: LD_VAR 0 6
57794: PPUSH
57795: CALL_OW 264
57799: PUSH
57800: LD_INT 14
57802: PUSH
57803: LD_INT 53
57805: PUSH
57806: EMPTY
57807: LIST
57808: LIST
57809: IN
57810: IFFALSE 57831
// points := [ 40 , 10 , 20 ] ;
57812: LD_ADDR_VAR 0 9
57816: PUSH
57817: LD_INT 40
57819: PUSH
57820: LD_INT 10
57822: PUSH
57823: LD_INT 20
57825: PUSH
57826: EMPTY
57827: LIST
57828: LIST
57829: LIST
57830: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
57831: LD_VAR 0 6
57835: PPUSH
57836: CALL_OW 264
57840: PUSH
57841: LD_INT 9
57843: PUSH
57844: EMPTY
57845: LIST
57846: IN
57847: IFFALSE 57868
// points := [ 5 , 70 , 20 ] ;
57849: LD_ADDR_VAR 0 9
57853: PUSH
57854: LD_INT 5
57856: PUSH
57857: LD_INT 70
57859: PUSH
57860: LD_INT 20
57862: PUSH
57863: EMPTY
57864: LIST
57865: LIST
57866: LIST
57867: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
57868: LD_VAR 0 6
57872: PPUSH
57873: CALL_OW 264
57877: PUSH
57878: LD_INT 10
57880: PUSH
57881: EMPTY
57882: LIST
57883: IN
57884: IFFALSE 57905
// points := [ 35 , 110 , 70 ] ;
57886: LD_ADDR_VAR 0 9
57890: PUSH
57891: LD_INT 35
57893: PUSH
57894: LD_INT 110
57896: PUSH
57897: LD_INT 70
57899: PUSH
57900: EMPTY
57901: LIST
57902: LIST
57903: LIST
57904: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
57905: LD_VAR 0 6
57909: PPUSH
57910: CALL_OW 265
57914: PUSH
57915: LD_INT 25
57917: EQUAL
57918: IFFALSE 57939
// points := [ 80 , 65 , 100 ] ;
57920: LD_ADDR_VAR 0 9
57924: PUSH
57925: LD_INT 80
57927: PUSH
57928: LD_INT 65
57930: PUSH
57931: LD_INT 100
57933: PUSH
57934: EMPTY
57935: LIST
57936: LIST
57937: LIST
57938: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
57939: LD_VAR 0 6
57943: PPUSH
57944: CALL_OW 263
57948: PUSH
57949: LD_INT 1
57951: EQUAL
57952: IFFALSE 57987
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
57954: LD_ADDR_VAR 0 10
57958: PUSH
57959: LD_VAR 0 10
57963: PUSH
57964: LD_VAR 0 6
57968: PPUSH
57969: CALL_OW 311
57973: PPUSH
57974: LD_INT 3
57976: PPUSH
57977: CALL_OW 259
57981: PUSH
57982: LD_INT 4
57984: MUL
57985: MUL
57986: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
57987: LD_VAR 0 6
57991: PPUSH
57992: CALL_OW 263
57996: PUSH
57997: LD_INT 2
57999: EQUAL
58000: IFFALSE 58051
// begin j := IsControledBy ( i ) ;
58002: LD_ADDR_VAR 0 7
58006: PUSH
58007: LD_VAR 0 6
58011: PPUSH
58012: CALL_OW 312
58016: ST_TO_ADDR
// if j then
58017: LD_VAR 0 7
58021: IFFALSE 58051
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
58023: LD_ADDR_VAR 0 10
58027: PUSH
58028: LD_VAR 0 10
58032: PUSH
58033: LD_VAR 0 7
58037: PPUSH
58038: LD_INT 3
58040: PPUSH
58041: CALL_OW 259
58045: PUSH
58046: LD_INT 3
58048: MUL
58049: MUL
58050: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
58051: LD_VAR 0 6
58055: PPUSH
58056: CALL_OW 264
58060: PUSH
58061: LD_INT 5
58063: PUSH
58064: LD_INT 6
58066: PUSH
58067: LD_INT 46
58069: PUSH
58070: LD_INT 44
58072: PUSH
58073: LD_INT 47
58075: PUSH
58076: LD_INT 45
58078: PUSH
58079: LD_INT 28
58081: PUSH
58082: LD_INT 7
58084: PUSH
58085: LD_INT 27
58087: PUSH
58088: LD_INT 29
58090: PUSH
58091: EMPTY
58092: LIST
58093: LIST
58094: LIST
58095: LIST
58096: LIST
58097: LIST
58098: LIST
58099: LIST
58100: LIST
58101: LIST
58102: IN
58103: PUSH
58104: LD_VAR 0 1
58108: PPUSH
58109: LD_INT 52
58111: PPUSH
58112: CALL_OW 321
58116: PUSH
58117: LD_INT 2
58119: EQUAL
58120: AND
58121: IFFALSE 58138
// bpoints := bpoints * 1.2 ;
58123: LD_ADDR_VAR 0 10
58127: PUSH
58128: LD_VAR 0 10
58132: PUSH
58133: LD_REAL  1.20000000000000E+0000
58136: MUL
58137: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
58138: LD_VAR 0 6
58142: PPUSH
58143: CALL_OW 264
58147: PUSH
58148: LD_INT 6
58150: PUSH
58151: LD_INT 46
58153: PUSH
58154: LD_INT 47
58156: PUSH
58157: EMPTY
58158: LIST
58159: LIST
58160: LIST
58161: IN
58162: IFFALSE 58179
// bpoints := bpoints * 1.2 ;
58164: LD_ADDR_VAR 0 10
58168: PUSH
58169: LD_VAR 0 10
58173: PUSH
58174: LD_REAL  1.20000000000000E+0000
58177: MUL
58178: ST_TO_ADDR
// end ; unit_building :
58179: GO 58193
58181: LD_INT 3
58183: DOUBLE
58184: EQUAL
58185: IFTRUE 58189
58187: GO 58192
58189: POP
// ; end ;
58190: GO 58193
58192: POP
// for j = 1 to 3 do
58193: LD_ADDR_VAR 0 7
58197: PUSH
58198: DOUBLE
58199: LD_INT 1
58201: DEC
58202: ST_TO_ADDR
58203: LD_INT 3
58205: PUSH
58206: FOR_TO
58207: IFFALSE 58260
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
58209: LD_ADDR_VAR 0 5
58213: PUSH
58214: LD_VAR 0 5
58218: PPUSH
58219: LD_VAR 0 7
58223: PPUSH
58224: LD_VAR 0 5
58228: PUSH
58229: LD_VAR 0 7
58233: ARRAY
58234: PUSH
58235: LD_VAR 0 9
58239: PUSH
58240: LD_VAR 0 7
58244: ARRAY
58245: PUSH
58246: LD_VAR 0 10
58250: MUL
58251: PLUS
58252: PPUSH
58253: CALL_OW 1
58257: ST_TO_ADDR
58258: GO 58206
58260: POP
58261: POP
// end ;
58262: GO 56745
58264: POP
58265: POP
// result := Replace ( result , 4 , tmp ) ;
58266: LD_ADDR_VAR 0 5
58270: PUSH
58271: LD_VAR 0 5
58275: PPUSH
58276: LD_INT 4
58278: PPUSH
58279: LD_VAR 0 8
58283: PPUSH
58284: CALL_OW 1
58288: ST_TO_ADDR
// end ;
58289: LD_VAR 0 5
58293: RET
// export function DangerAtRange ( unit , range ) ; begin
58294: LD_INT 0
58296: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
58297: LD_ADDR_VAR 0 3
58301: PUSH
58302: LD_VAR 0 1
58306: PPUSH
58307: CALL_OW 255
58311: PPUSH
58312: LD_VAR 0 1
58316: PPUSH
58317: CALL_OW 250
58321: PPUSH
58322: LD_VAR 0 1
58326: PPUSH
58327: CALL_OW 251
58331: PPUSH
58332: LD_VAR 0 2
58336: PPUSH
58337: CALL 56597 0 4
58341: ST_TO_ADDR
// end ;
58342: LD_VAR 0 3
58346: RET
// export function DangerInArea ( side , area ) ; begin
58347: LD_INT 0
58349: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
58350: LD_ADDR_VAR 0 3
58354: PUSH
58355: LD_VAR 0 2
58359: PPUSH
58360: LD_INT 81
58362: PUSH
58363: LD_VAR 0 1
58367: PUSH
58368: EMPTY
58369: LIST
58370: LIST
58371: PPUSH
58372: CALL_OW 70
58376: ST_TO_ADDR
// end ;
58377: LD_VAR 0 3
58381: RET
// export function IsExtension ( b ) ; begin
58382: LD_INT 0
58384: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
58385: LD_ADDR_VAR 0 2
58389: PUSH
58390: LD_VAR 0 1
58394: PUSH
58395: LD_INT 23
58397: PUSH
58398: LD_INT 20
58400: PUSH
58401: LD_INT 22
58403: PUSH
58404: LD_INT 17
58406: PUSH
58407: LD_INT 24
58409: PUSH
58410: LD_INT 21
58412: PUSH
58413: LD_INT 19
58415: PUSH
58416: LD_INT 16
58418: PUSH
58419: LD_INT 25
58421: PUSH
58422: LD_INT 18
58424: PUSH
58425: EMPTY
58426: LIST
58427: LIST
58428: LIST
58429: LIST
58430: LIST
58431: LIST
58432: LIST
58433: LIST
58434: LIST
58435: LIST
58436: IN
58437: ST_TO_ADDR
// end ;
58438: LD_VAR 0 2
58442: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
58443: LD_INT 0
58445: PPUSH
58446: PPUSH
58447: PPUSH
// result := [ ] ;
58448: LD_ADDR_VAR 0 3
58452: PUSH
58453: EMPTY
58454: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
58455: LD_ADDR_VAR 0 4
58459: PUSH
58460: LD_VAR 0 2
58464: PPUSH
58465: LD_INT 21
58467: PUSH
58468: LD_INT 3
58470: PUSH
58471: EMPTY
58472: LIST
58473: LIST
58474: PPUSH
58475: CALL_OW 70
58479: ST_TO_ADDR
// if not tmp then
58480: LD_VAR 0 4
58484: NOT
58485: IFFALSE 58489
// exit ;
58487: GO 58547
// for i in tmp do
58489: LD_ADDR_VAR 0 5
58493: PUSH
58494: LD_VAR 0 4
58498: PUSH
58499: FOR_IN
58500: IFFALSE 58535
// if GetBase ( i ) <> base then
58502: LD_VAR 0 5
58506: PPUSH
58507: CALL_OW 274
58511: PUSH
58512: LD_VAR 0 1
58516: NONEQUAL
58517: IFFALSE 58533
// ComLinkToBase ( base , i ) ;
58519: LD_VAR 0 1
58523: PPUSH
58524: LD_VAR 0 5
58528: PPUSH
58529: CALL_OW 169
58533: GO 58499
58535: POP
58536: POP
// result := tmp ;
58537: LD_ADDR_VAR 0 3
58541: PUSH
58542: LD_VAR 0 4
58546: ST_TO_ADDR
// end ;
58547: LD_VAR 0 3
58551: RET
// export function ComComplete ( unit , b ) ; var i ; begin
58552: LD_INT 0
58554: PPUSH
58555: PPUSH
// if BuildingStatus ( b ) = bs_build then
58556: LD_VAR 0 2
58560: PPUSH
58561: CALL_OW 461
58565: PUSH
58566: LD_INT 1
58568: EQUAL
58569: IFFALSE 58629
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
58571: LD_VAR 0 1
58575: PPUSH
58576: LD_STRING h
58578: PUSH
58579: LD_VAR 0 2
58583: PPUSH
58584: CALL_OW 250
58588: PUSH
58589: LD_VAR 0 2
58593: PPUSH
58594: CALL_OW 251
58598: PUSH
58599: LD_VAR 0 2
58603: PUSH
58604: LD_INT 0
58606: PUSH
58607: LD_INT 0
58609: PUSH
58610: LD_INT 0
58612: PUSH
58613: EMPTY
58614: LIST
58615: LIST
58616: LIST
58617: LIST
58618: LIST
58619: LIST
58620: LIST
58621: PUSH
58622: EMPTY
58623: LIST
58624: PPUSH
58625: CALL_OW 446
// end ;
58629: LD_VAR 0 3
58633: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
58634: LD_INT 0
58636: PPUSH
58637: PPUSH
58638: PPUSH
58639: PPUSH
58640: PPUSH
58641: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
58642: LD_VAR 0 1
58646: NOT
58647: PUSH
58648: LD_VAR 0 1
58652: PPUSH
58653: CALL_OW 263
58657: PUSH
58658: LD_INT 2
58660: EQUAL
58661: NOT
58662: OR
58663: IFFALSE 58667
// exit ;
58665: GO 58983
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
58667: LD_ADDR_VAR 0 6
58671: PUSH
58672: LD_INT 22
58674: PUSH
58675: LD_VAR 0 1
58679: PPUSH
58680: CALL_OW 255
58684: PUSH
58685: EMPTY
58686: LIST
58687: LIST
58688: PUSH
58689: LD_INT 2
58691: PUSH
58692: LD_INT 30
58694: PUSH
58695: LD_INT 36
58697: PUSH
58698: EMPTY
58699: LIST
58700: LIST
58701: PUSH
58702: LD_INT 34
58704: PUSH
58705: LD_INT 31
58707: PUSH
58708: EMPTY
58709: LIST
58710: LIST
58711: PUSH
58712: EMPTY
58713: LIST
58714: LIST
58715: LIST
58716: PUSH
58717: EMPTY
58718: LIST
58719: LIST
58720: PPUSH
58721: CALL_OW 69
58725: ST_TO_ADDR
// if not tmp then
58726: LD_VAR 0 6
58730: NOT
58731: IFFALSE 58735
// exit ;
58733: GO 58983
// result := [ ] ;
58735: LD_ADDR_VAR 0 2
58739: PUSH
58740: EMPTY
58741: ST_TO_ADDR
// for i in tmp do
58742: LD_ADDR_VAR 0 3
58746: PUSH
58747: LD_VAR 0 6
58751: PUSH
58752: FOR_IN
58753: IFFALSE 58824
// begin t := UnitsInside ( i ) ;
58755: LD_ADDR_VAR 0 4
58759: PUSH
58760: LD_VAR 0 3
58764: PPUSH
58765: CALL_OW 313
58769: ST_TO_ADDR
// if t then
58770: LD_VAR 0 4
58774: IFFALSE 58822
// for j in t do
58776: LD_ADDR_VAR 0 7
58780: PUSH
58781: LD_VAR 0 4
58785: PUSH
58786: FOR_IN
58787: IFFALSE 58820
// result := Insert ( result , result + 1 , j ) ;
58789: LD_ADDR_VAR 0 2
58793: PUSH
58794: LD_VAR 0 2
58798: PPUSH
58799: LD_VAR 0 2
58803: PUSH
58804: LD_INT 1
58806: PLUS
58807: PPUSH
58808: LD_VAR 0 7
58812: PPUSH
58813: CALL_OW 2
58817: ST_TO_ADDR
58818: GO 58786
58820: POP
58821: POP
// end ;
58822: GO 58752
58824: POP
58825: POP
// if not result then
58826: LD_VAR 0 2
58830: NOT
58831: IFFALSE 58835
// exit ;
58833: GO 58983
// mech := result [ 1 ] ;
58835: LD_ADDR_VAR 0 5
58839: PUSH
58840: LD_VAR 0 2
58844: PUSH
58845: LD_INT 1
58847: ARRAY
58848: ST_TO_ADDR
// if result > 1 then
58849: LD_VAR 0 2
58853: PUSH
58854: LD_INT 1
58856: GREATER
58857: IFFALSE 58969
// for i = 2 to result do
58859: LD_ADDR_VAR 0 3
58863: PUSH
58864: DOUBLE
58865: LD_INT 2
58867: DEC
58868: ST_TO_ADDR
58869: LD_VAR 0 2
58873: PUSH
58874: FOR_TO
58875: IFFALSE 58967
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
58877: LD_ADDR_VAR 0 4
58881: PUSH
58882: LD_VAR 0 2
58886: PUSH
58887: LD_VAR 0 3
58891: ARRAY
58892: PPUSH
58893: LD_INT 3
58895: PPUSH
58896: CALL_OW 259
58900: PUSH
58901: LD_VAR 0 2
58905: PUSH
58906: LD_VAR 0 3
58910: ARRAY
58911: PPUSH
58912: CALL_OW 432
58916: MINUS
58917: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
58918: LD_VAR 0 4
58922: PUSH
58923: LD_VAR 0 5
58927: PPUSH
58928: LD_INT 3
58930: PPUSH
58931: CALL_OW 259
58935: PUSH
58936: LD_VAR 0 5
58940: PPUSH
58941: CALL_OW 432
58945: MINUS
58946: GREATEREQUAL
58947: IFFALSE 58965
// mech := result [ i ] ;
58949: LD_ADDR_VAR 0 5
58953: PUSH
58954: LD_VAR 0 2
58958: PUSH
58959: LD_VAR 0 3
58963: ARRAY
58964: ST_TO_ADDR
// end ;
58965: GO 58874
58967: POP
58968: POP
// ComLinkTo ( vehicle , mech ) ;
58969: LD_VAR 0 1
58973: PPUSH
58974: LD_VAR 0 5
58978: PPUSH
58979: CALL_OW 135
// end ;
58983: LD_VAR 0 2
58987: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
58988: LD_INT 0
58990: PPUSH
58991: PPUSH
58992: PPUSH
58993: PPUSH
58994: PPUSH
58995: PPUSH
58996: PPUSH
58997: PPUSH
58998: PPUSH
58999: PPUSH
59000: PPUSH
59001: PPUSH
59002: PPUSH
// result := [ ] ;
59003: LD_ADDR_VAR 0 7
59007: PUSH
59008: EMPTY
59009: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
59010: LD_VAR 0 1
59014: PPUSH
59015: CALL_OW 266
59019: PUSH
59020: LD_INT 0
59022: PUSH
59023: LD_INT 1
59025: PUSH
59026: EMPTY
59027: LIST
59028: LIST
59029: IN
59030: NOT
59031: IFFALSE 59035
// exit ;
59033: GO 60666
// if name then
59035: LD_VAR 0 3
59039: IFFALSE 59055
// SetBName ( base_dep , name ) ;
59041: LD_VAR 0 1
59045: PPUSH
59046: LD_VAR 0 3
59050: PPUSH
59051: CALL_OW 500
// base := GetBase ( base_dep ) ;
59055: LD_ADDR_VAR 0 15
59059: PUSH
59060: LD_VAR 0 1
59064: PPUSH
59065: CALL_OW 274
59069: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
59070: LD_ADDR_VAR 0 16
59074: PUSH
59075: LD_VAR 0 1
59079: PPUSH
59080: CALL_OW 255
59084: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
59085: LD_ADDR_VAR 0 17
59089: PUSH
59090: LD_VAR 0 1
59094: PPUSH
59095: CALL_OW 248
59099: ST_TO_ADDR
// if sources then
59100: LD_VAR 0 5
59104: IFFALSE 59151
// for i = 1 to 3 do
59106: LD_ADDR_VAR 0 8
59110: PUSH
59111: DOUBLE
59112: LD_INT 1
59114: DEC
59115: ST_TO_ADDR
59116: LD_INT 3
59118: PUSH
59119: FOR_TO
59120: IFFALSE 59149
// AddResourceType ( base , i , sources [ i ] ) ;
59122: LD_VAR 0 15
59126: PPUSH
59127: LD_VAR 0 8
59131: PPUSH
59132: LD_VAR 0 5
59136: PUSH
59137: LD_VAR 0 8
59141: ARRAY
59142: PPUSH
59143: CALL_OW 276
59147: GO 59119
59149: POP
59150: POP
// buildings := GetBaseBuildings ( base , area ) ;
59151: LD_ADDR_VAR 0 18
59155: PUSH
59156: LD_VAR 0 15
59160: PPUSH
59161: LD_VAR 0 2
59165: PPUSH
59166: CALL 58443 0 2
59170: ST_TO_ADDR
// InitHc ;
59171: CALL_OW 19
// InitUc ;
59175: CALL_OW 18
// uc_side := side ;
59179: LD_ADDR_OWVAR 20
59183: PUSH
59184: LD_VAR 0 16
59188: ST_TO_ADDR
// uc_nation := nation ;
59189: LD_ADDR_OWVAR 21
59193: PUSH
59194: LD_VAR 0 17
59198: ST_TO_ADDR
// if buildings then
59199: LD_VAR 0 18
59203: IFFALSE 60525
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
59205: LD_ADDR_VAR 0 19
59209: PUSH
59210: LD_VAR 0 18
59214: PPUSH
59215: LD_INT 2
59217: PUSH
59218: LD_INT 30
59220: PUSH
59221: LD_INT 29
59223: PUSH
59224: EMPTY
59225: LIST
59226: LIST
59227: PUSH
59228: LD_INT 30
59230: PUSH
59231: LD_INT 30
59233: PUSH
59234: EMPTY
59235: LIST
59236: LIST
59237: PUSH
59238: EMPTY
59239: LIST
59240: LIST
59241: LIST
59242: PPUSH
59243: CALL_OW 72
59247: ST_TO_ADDR
// if tmp then
59248: LD_VAR 0 19
59252: IFFALSE 59300
// for i in tmp do
59254: LD_ADDR_VAR 0 8
59258: PUSH
59259: LD_VAR 0 19
59263: PUSH
59264: FOR_IN
59265: IFFALSE 59298
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
59267: LD_VAR 0 8
59271: PPUSH
59272: CALL_OW 250
59276: PPUSH
59277: LD_VAR 0 8
59281: PPUSH
59282: CALL_OW 251
59286: PPUSH
59287: LD_VAR 0 16
59291: PPUSH
59292: CALL_OW 441
59296: GO 59264
59298: POP
59299: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
59300: LD_VAR 0 18
59304: PPUSH
59305: LD_INT 2
59307: PUSH
59308: LD_INT 30
59310: PUSH
59311: LD_INT 32
59313: PUSH
59314: EMPTY
59315: LIST
59316: LIST
59317: PUSH
59318: LD_INT 30
59320: PUSH
59321: LD_INT 33
59323: PUSH
59324: EMPTY
59325: LIST
59326: LIST
59327: PUSH
59328: EMPTY
59329: LIST
59330: LIST
59331: LIST
59332: PPUSH
59333: CALL_OW 72
59337: IFFALSE 59425
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
59339: LD_ADDR_VAR 0 8
59343: PUSH
59344: LD_VAR 0 18
59348: PPUSH
59349: LD_INT 2
59351: PUSH
59352: LD_INT 30
59354: PUSH
59355: LD_INT 32
59357: PUSH
59358: EMPTY
59359: LIST
59360: LIST
59361: PUSH
59362: LD_INT 30
59364: PUSH
59365: LD_INT 33
59367: PUSH
59368: EMPTY
59369: LIST
59370: LIST
59371: PUSH
59372: EMPTY
59373: LIST
59374: LIST
59375: LIST
59376: PPUSH
59377: CALL_OW 72
59381: PUSH
59382: FOR_IN
59383: IFFALSE 59423
// begin if not GetBWeapon ( i ) then
59385: LD_VAR 0 8
59389: PPUSH
59390: CALL_OW 269
59394: NOT
59395: IFFALSE 59421
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
59397: LD_VAR 0 8
59401: PPUSH
59402: LD_VAR 0 8
59406: PPUSH
59407: LD_VAR 0 2
59411: PPUSH
59412: CALL 60671 0 2
59416: PPUSH
59417: CALL_OW 431
// end ;
59421: GO 59382
59423: POP
59424: POP
// end ; for i = 1 to personel do
59425: LD_ADDR_VAR 0 8
59429: PUSH
59430: DOUBLE
59431: LD_INT 1
59433: DEC
59434: ST_TO_ADDR
59435: LD_VAR 0 6
59439: PUSH
59440: FOR_TO
59441: IFFALSE 60505
// begin if i > 4 then
59443: LD_VAR 0 8
59447: PUSH
59448: LD_INT 4
59450: GREATER
59451: IFFALSE 59455
// break ;
59453: GO 60505
// case i of 1 :
59455: LD_VAR 0 8
59459: PUSH
59460: LD_INT 1
59462: DOUBLE
59463: EQUAL
59464: IFTRUE 59468
59466: GO 59548
59468: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
59469: LD_ADDR_VAR 0 12
59473: PUSH
59474: LD_VAR 0 18
59478: PPUSH
59479: LD_INT 22
59481: PUSH
59482: LD_VAR 0 16
59486: PUSH
59487: EMPTY
59488: LIST
59489: LIST
59490: PUSH
59491: LD_INT 58
59493: PUSH
59494: EMPTY
59495: LIST
59496: PUSH
59497: LD_INT 2
59499: PUSH
59500: LD_INT 30
59502: PUSH
59503: LD_INT 32
59505: PUSH
59506: EMPTY
59507: LIST
59508: LIST
59509: PUSH
59510: LD_INT 30
59512: PUSH
59513: LD_INT 4
59515: PUSH
59516: EMPTY
59517: LIST
59518: LIST
59519: PUSH
59520: LD_INT 30
59522: PUSH
59523: LD_INT 5
59525: PUSH
59526: EMPTY
59527: LIST
59528: LIST
59529: PUSH
59530: EMPTY
59531: LIST
59532: LIST
59533: LIST
59534: LIST
59535: PUSH
59536: EMPTY
59537: LIST
59538: LIST
59539: LIST
59540: PPUSH
59541: CALL_OW 72
59545: ST_TO_ADDR
59546: GO 59770
59548: LD_INT 2
59550: DOUBLE
59551: EQUAL
59552: IFTRUE 59556
59554: GO 59618
59556: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
59557: LD_ADDR_VAR 0 12
59561: PUSH
59562: LD_VAR 0 18
59566: PPUSH
59567: LD_INT 22
59569: PUSH
59570: LD_VAR 0 16
59574: PUSH
59575: EMPTY
59576: LIST
59577: LIST
59578: PUSH
59579: LD_INT 2
59581: PUSH
59582: LD_INT 30
59584: PUSH
59585: LD_INT 0
59587: PUSH
59588: EMPTY
59589: LIST
59590: LIST
59591: PUSH
59592: LD_INT 30
59594: PUSH
59595: LD_INT 1
59597: PUSH
59598: EMPTY
59599: LIST
59600: LIST
59601: PUSH
59602: EMPTY
59603: LIST
59604: LIST
59605: LIST
59606: PUSH
59607: EMPTY
59608: LIST
59609: LIST
59610: PPUSH
59611: CALL_OW 72
59615: ST_TO_ADDR
59616: GO 59770
59618: LD_INT 3
59620: DOUBLE
59621: EQUAL
59622: IFTRUE 59626
59624: GO 59688
59626: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
59627: LD_ADDR_VAR 0 12
59631: PUSH
59632: LD_VAR 0 18
59636: PPUSH
59637: LD_INT 22
59639: PUSH
59640: LD_VAR 0 16
59644: PUSH
59645: EMPTY
59646: LIST
59647: LIST
59648: PUSH
59649: LD_INT 2
59651: PUSH
59652: LD_INT 30
59654: PUSH
59655: LD_INT 2
59657: PUSH
59658: EMPTY
59659: LIST
59660: LIST
59661: PUSH
59662: LD_INT 30
59664: PUSH
59665: LD_INT 3
59667: PUSH
59668: EMPTY
59669: LIST
59670: LIST
59671: PUSH
59672: EMPTY
59673: LIST
59674: LIST
59675: LIST
59676: PUSH
59677: EMPTY
59678: LIST
59679: LIST
59680: PPUSH
59681: CALL_OW 72
59685: ST_TO_ADDR
59686: GO 59770
59688: LD_INT 4
59690: DOUBLE
59691: EQUAL
59692: IFTRUE 59696
59694: GO 59769
59696: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
59697: LD_ADDR_VAR 0 12
59701: PUSH
59702: LD_VAR 0 18
59706: PPUSH
59707: LD_INT 22
59709: PUSH
59710: LD_VAR 0 16
59714: PUSH
59715: EMPTY
59716: LIST
59717: LIST
59718: PUSH
59719: LD_INT 2
59721: PUSH
59722: LD_INT 30
59724: PUSH
59725: LD_INT 6
59727: PUSH
59728: EMPTY
59729: LIST
59730: LIST
59731: PUSH
59732: LD_INT 30
59734: PUSH
59735: LD_INT 7
59737: PUSH
59738: EMPTY
59739: LIST
59740: LIST
59741: PUSH
59742: LD_INT 30
59744: PUSH
59745: LD_INT 8
59747: PUSH
59748: EMPTY
59749: LIST
59750: LIST
59751: PUSH
59752: EMPTY
59753: LIST
59754: LIST
59755: LIST
59756: LIST
59757: PUSH
59758: EMPTY
59759: LIST
59760: LIST
59761: PPUSH
59762: CALL_OW 72
59766: ST_TO_ADDR
59767: GO 59770
59769: POP
// if i = 1 then
59770: LD_VAR 0 8
59774: PUSH
59775: LD_INT 1
59777: EQUAL
59778: IFFALSE 59889
// begin tmp := [ ] ;
59780: LD_ADDR_VAR 0 19
59784: PUSH
59785: EMPTY
59786: ST_TO_ADDR
// for j in f do
59787: LD_ADDR_VAR 0 9
59791: PUSH
59792: LD_VAR 0 12
59796: PUSH
59797: FOR_IN
59798: IFFALSE 59871
// if GetBType ( j ) = b_bunker then
59800: LD_VAR 0 9
59804: PPUSH
59805: CALL_OW 266
59809: PUSH
59810: LD_INT 32
59812: EQUAL
59813: IFFALSE 59840
// tmp := Insert ( tmp , 1 , j ) else
59815: LD_ADDR_VAR 0 19
59819: PUSH
59820: LD_VAR 0 19
59824: PPUSH
59825: LD_INT 1
59827: PPUSH
59828: LD_VAR 0 9
59832: PPUSH
59833: CALL_OW 2
59837: ST_TO_ADDR
59838: GO 59869
// tmp := Insert ( tmp , tmp + 1 , j ) ;
59840: LD_ADDR_VAR 0 19
59844: PUSH
59845: LD_VAR 0 19
59849: PPUSH
59850: LD_VAR 0 19
59854: PUSH
59855: LD_INT 1
59857: PLUS
59858: PPUSH
59859: LD_VAR 0 9
59863: PPUSH
59864: CALL_OW 2
59868: ST_TO_ADDR
59869: GO 59797
59871: POP
59872: POP
// if tmp then
59873: LD_VAR 0 19
59877: IFFALSE 59889
// f := tmp ;
59879: LD_ADDR_VAR 0 12
59883: PUSH
59884: LD_VAR 0 19
59888: ST_TO_ADDR
// end ; x := personel [ i ] ;
59889: LD_ADDR_VAR 0 13
59893: PUSH
59894: LD_VAR 0 6
59898: PUSH
59899: LD_VAR 0 8
59903: ARRAY
59904: ST_TO_ADDR
// if x = - 1 then
59905: LD_VAR 0 13
59909: PUSH
59910: LD_INT 1
59912: NEG
59913: EQUAL
59914: IFFALSE 60123
// begin for j in f do
59916: LD_ADDR_VAR 0 9
59920: PUSH
59921: LD_VAR 0 12
59925: PUSH
59926: FOR_IN
59927: IFFALSE 60119
// repeat InitHc ;
59929: CALL_OW 19
// if GetBType ( j ) = b_barracks then
59933: LD_VAR 0 9
59937: PPUSH
59938: CALL_OW 266
59942: PUSH
59943: LD_INT 5
59945: EQUAL
59946: IFFALSE 60016
// begin if UnitsInside ( j ) < 3 then
59948: LD_VAR 0 9
59952: PPUSH
59953: CALL_OW 313
59957: PUSH
59958: LD_INT 3
59960: LESS
59961: IFFALSE 59997
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
59963: LD_INT 0
59965: PPUSH
59966: LD_INT 5
59968: PUSH
59969: LD_INT 8
59971: PUSH
59972: LD_INT 9
59974: PUSH
59975: EMPTY
59976: LIST
59977: LIST
59978: LIST
59979: PUSH
59980: LD_VAR 0 17
59984: ARRAY
59985: PPUSH
59986: LD_VAR 0 4
59990: PPUSH
59991: CALL_OW 380
59995: GO 60014
// PrepareHuman ( false , i , skill ) ;
59997: LD_INT 0
59999: PPUSH
60000: LD_VAR 0 8
60004: PPUSH
60005: LD_VAR 0 4
60009: PPUSH
60010: CALL_OW 380
// end else
60014: GO 60033
// PrepareHuman ( false , i , skill ) ;
60016: LD_INT 0
60018: PPUSH
60019: LD_VAR 0 8
60023: PPUSH
60024: LD_VAR 0 4
60028: PPUSH
60029: CALL_OW 380
// un := CreateHuman ;
60033: LD_ADDR_VAR 0 14
60037: PUSH
60038: CALL_OW 44
60042: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60043: LD_ADDR_VAR 0 7
60047: PUSH
60048: LD_VAR 0 7
60052: PPUSH
60053: LD_INT 1
60055: PPUSH
60056: LD_VAR 0 14
60060: PPUSH
60061: CALL_OW 2
60065: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
60066: LD_VAR 0 14
60070: PPUSH
60071: LD_VAR 0 9
60075: PPUSH
60076: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
60080: LD_VAR 0 9
60084: PPUSH
60085: CALL_OW 313
60089: PUSH
60090: LD_INT 6
60092: EQUAL
60093: PUSH
60094: LD_VAR 0 9
60098: PPUSH
60099: CALL_OW 266
60103: PUSH
60104: LD_INT 32
60106: PUSH
60107: LD_INT 31
60109: PUSH
60110: EMPTY
60111: LIST
60112: LIST
60113: IN
60114: OR
60115: IFFALSE 59929
60117: GO 59926
60119: POP
60120: POP
// end else
60121: GO 60503
// for j = 1 to x do
60123: LD_ADDR_VAR 0 9
60127: PUSH
60128: DOUBLE
60129: LD_INT 1
60131: DEC
60132: ST_TO_ADDR
60133: LD_VAR 0 13
60137: PUSH
60138: FOR_TO
60139: IFFALSE 60501
// begin InitHc ;
60141: CALL_OW 19
// if not f then
60145: LD_VAR 0 12
60149: NOT
60150: IFFALSE 60239
// begin PrepareHuman ( false , i , skill ) ;
60152: LD_INT 0
60154: PPUSH
60155: LD_VAR 0 8
60159: PPUSH
60160: LD_VAR 0 4
60164: PPUSH
60165: CALL_OW 380
// un := CreateHuman ;
60169: LD_ADDR_VAR 0 14
60173: PUSH
60174: CALL_OW 44
60178: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60179: LD_ADDR_VAR 0 7
60183: PUSH
60184: LD_VAR 0 7
60188: PPUSH
60189: LD_INT 1
60191: PPUSH
60192: LD_VAR 0 14
60196: PPUSH
60197: CALL_OW 2
60201: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
60202: LD_VAR 0 14
60206: PPUSH
60207: LD_VAR 0 1
60211: PPUSH
60212: CALL_OW 250
60216: PPUSH
60217: LD_VAR 0 1
60221: PPUSH
60222: CALL_OW 251
60226: PPUSH
60227: LD_INT 10
60229: PPUSH
60230: LD_INT 0
60232: PPUSH
60233: CALL_OW 50
// continue ;
60237: GO 60138
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
60239: LD_VAR 0 12
60243: PUSH
60244: LD_INT 1
60246: ARRAY
60247: PPUSH
60248: CALL_OW 313
60252: PUSH
60253: LD_VAR 0 12
60257: PUSH
60258: LD_INT 1
60260: ARRAY
60261: PPUSH
60262: CALL_OW 266
60266: PUSH
60267: LD_INT 32
60269: PUSH
60270: LD_INT 31
60272: PUSH
60273: EMPTY
60274: LIST
60275: LIST
60276: IN
60277: AND
60278: PUSH
60279: LD_VAR 0 12
60283: PUSH
60284: LD_INT 1
60286: ARRAY
60287: PPUSH
60288: CALL_OW 313
60292: PUSH
60293: LD_INT 6
60295: EQUAL
60296: OR
60297: IFFALSE 60317
// f := Delete ( f , 1 ) ;
60299: LD_ADDR_VAR 0 12
60303: PUSH
60304: LD_VAR 0 12
60308: PPUSH
60309: LD_INT 1
60311: PPUSH
60312: CALL_OW 3
60316: ST_TO_ADDR
// if not f then
60317: LD_VAR 0 12
60321: NOT
60322: IFFALSE 60340
// begin x := x + 2 ;
60324: LD_ADDR_VAR 0 13
60328: PUSH
60329: LD_VAR 0 13
60333: PUSH
60334: LD_INT 2
60336: PLUS
60337: ST_TO_ADDR
// continue ;
60338: GO 60138
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
60340: LD_VAR 0 12
60344: PUSH
60345: LD_INT 1
60347: ARRAY
60348: PPUSH
60349: CALL_OW 266
60353: PUSH
60354: LD_INT 5
60356: EQUAL
60357: IFFALSE 60431
// begin if UnitsInside ( f [ 1 ] ) < 3 then
60359: LD_VAR 0 12
60363: PUSH
60364: LD_INT 1
60366: ARRAY
60367: PPUSH
60368: CALL_OW 313
60372: PUSH
60373: LD_INT 3
60375: LESS
60376: IFFALSE 60412
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
60378: LD_INT 0
60380: PPUSH
60381: LD_INT 5
60383: PUSH
60384: LD_INT 8
60386: PUSH
60387: LD_INT 9
60389: PUSH
60390: EMPTY
60391: LIST
60392: LIST
60393: LIST
60394: PUSH
60395: LD_VAR 0 17
60399: ARRAY
60400: PPUSH
60401: LD_VAR 0 4
60405: PPUSH
60406: CALL_OW 380
60410: GO 60429
// PrepareHuman ( false , i , skill ) ;
60412: LD_INT 0
60414: PPUSH
60415: LD_VAR 0 8
60419: PPUSH
60420: LD_VAR 0 4
60424: PPUSH
60425: CALL_OW 380
// end else
60429: GO 60448
// PrepareHuman ( false , i , skill ) ;
60431: LD_INT 0
60433: PPUSH
60434: LD_VAR 0 8
60438: PPUSH
60439: LD_VAR 0 4
60443: PPUSH
60444: CALL_OW 380
// un := CreateHuman ;
60448: LD_ADDR_VAR 0 14
60452: PUSH
60453: CALL_OW 44
60457: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60458: LD_ADDR_VAR 0 7
60462: PUSH
60463: LD_VAR 0 7
60467: PPUSH
60468: LD_INT 1
60470: PPUSH
60471: LD_VAR 0 14
60475: PPUSH
60476: CALL_OW 2
60480: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
60481: LD_VAR 0 14
60485: PPUSH
60486: LD_VAR 0 12
60490: PUSH
60491: LD_INT 1
60493: ARRAY
60494: PPUSH
60495: CALL_OW 52
// end ;
60499: GO 60138
60501: POP
60502: POP
// end ;
60503: GO 59440
60505: POP
60506: POP
// result := result ^ buildings ;
60507: LD_ADDR_VAR 0 7
60511: PUSH
60512: LD_VAR 0 7
60516: PUSH
60517: LD_VAR 0 18
60521: ADD
60522: ST_TO_ADDR
// end else
60523: GO 60666
// begin for i = 1 to personel do
60525: LD_ADDR_VAR 0 8
60529: PUSH
60530: DOUBLE
60531: LD_INT 1
60533: DEC
60534: ST_TO_ADDR
60535: LD_VAR 0 6
60539: PUSH
60540: FOR_TO
60541: IFFALSE 60664
// begin if i > 4 then
60543: LD_VAR 0 8
60547: PUSH
60548: LD_INT 4
60550: GREATER
60551: IFFALSE 60555
// break ;
60553: GO 60664
// x := personel [ i ] ;
60555: LD_ADDR_VAR 0 13
60559: PUSH
60560: LD_VAR 0 6
60564: PUSH
60565: LD_VAR 0 8
60569: ARRAY
60570: ST_TO_ADDR
// if x = - 1 then
60571: LD_VAR 0 13
60575: PUSH
60576: LD_INT 1
60578: NEG
60579: EQUAL
60580: IFFALSE 60584
// continue ;
60582: GO 60540
// PrepareHuman ( false , i , skill ) ;
60584: LD_INT 0
60586: PPUSH
60587: LD_VAR 0 8
60591: PPUSH
60592: LD_VAR 0 4
60596: PPUSH
60597: CALL_OW 380
// un := CreateHuman ;
60601: LD_ADDR_VAR 0 14
60605: PUSH
60606: CALL_OW 44
60610: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
60611: LD_VAR 0 14
60615: PPUSH
60616: LD_VAR 0 1
60620: PPUSH
60621: CALL_OW 250
60625: PPUSH
60626: LD_VAR 0 1
60630: PPUSH
60631: CALL_OW 251
60635: PPUSH
60636: LD_INT 10
60638: PPUSH
60639: LD_INT 0
60641: PPUSH
60642: CALL_OW 50
// result := result ^ un ;
60646: LD_ADDR_VAR 0 7
60650: PUSH
60651: LD_VAR 0 7
60655: PUSH
60656: LD_VAR 0 14
60660: ADD
60661: ST_TO_ADDR
// end ;
60662: GO 60540
60664: POP
60665: POP
// end ; end ;
60666: LD_VAR 0 7
60670: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
60671: LD_INT 0
60673: PPUSH
60674: PPUSH
60675: PPUSH
60676: PPUSH
60677: PPUSH
60678: PPUSH
60679: PPUSH
60680: PPUSH
60681: PPUSH
60682: PPUSH
60683: PPUSH
60684: PPUSH
60685: PPUSH
60686: PPUSH
60687: PPUSH
60688: PPUSH
// result := false ;
60689: LD_ADDR_VAR 0 3
60693: PUSH
60694: LD_INT 0
60696: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
60697: LD_VAR 0 1
60701: NOT
60702: PUSH
60703: LD_VAR 0 1
60707: PPUSH
60708: CALL_OW 266
60712: PUSH
60713: LD_INT 32
60715: PUSH
60716: LD_INT 33
60718: PUSH
60719: EMPTY
60720: LIST
60721: LIST
60722: IN
60723: NOT
60724: OR
60725: IFFALSE 60729
// exit ;
60727: GO 61865
// nat := GetNation ( tower ) ;
60729: LD_ADDR_VAR 0 12
60733: PUSH
60734: LD_VAR 0 1
60738: PPUSH
60739: CALL_OW 248
60743: ST_TO_ADDR
// side := GetSide ( tower ) ;
60744: LD_ADDR_VAR 0 16
60748: PUSH
60749: LD_VAR 0 1
60753: PPUSH
60754: CALL_OW 255
60758: ST_TO_ADDR
// x := GetX ( tower ) ;
60759: LD_ADDR_VAR 0 10
60763: PUSH
60764: LD_VAR 0 1
60768: PPUSH
60769: CALL_OW 250
60773: ST_TO_ADDR
// y := GetY ( tower ) ;
60774: LD_ADDR_VAR 0 11
60778: PUSH
60779: LD_VAR 0 1
60783: PPUSH
60784: CALL_OW 251
60788: ST_TO_ADDR
// if not x or not y then
60789: LD_VAR 0 10
60793: NOT
60794: PUSH
60795: LD_VAR 0 11
60799: NOT
60800: OR
60801: IFFALSE 60805
// exit ;
60803: GO 61865
// weapon := 0 ;
60805: LD_ADDR_VAR 0 18
60809: PUSH
60810: LD_INT 0
60812: ST_TO_ADDR
// fac_list := [ ] ;
60813: LD_ADDR_VAR 0 17
60817: PUSH
60818: EMPTY
60819: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
60820: LD_ADDR_VAR 0 6
60824: PUSH
60825: LD_VAR 0 1
60829: PPUSH
60830: CALL_OW 274
60834: PPUSH
60835: LD_VAR 0 2
60839: PPUSH
60840: CALL 58443 0 2
60844: PPUSH
60845: LD_INT 30
60847: PUSH
60848: LD_INT 3
60850: PUSH
60851: EMPTY
60852: LIST
60853: LIST
60854: PPUSH
60855: CALL_OW 72
60859: ST_TO_ADDR
// if not factories then
60860: LD_VAR 0 6
60864: NOT
60865: IFFALSE 60869
// exit ;
60867: GO 61865
// for i in factories do
60869: LD_ADDR_VAR 0 8
60873: PUSH
60874: LD_VAR 0 6
60878: PUSH
60879: FOR_IN
60880: IFFALSE 60905
// fac_list := fac_list union AvailableWeaponList ( i ) ;
60882: LD_ADDR_VAR 0 17
60886: PUSH
60887: LD_VAR 0 17
60891: PUSH
60892: LD_VAR 0 8
60896: PPUSH
60897: CALL_OW 478
60901: UNION
60902: ST_TO_ADDR
60903: GO 60879
60905: POP
60906: POP
// if not fac_list then
60907: LD_VAR 0 17
60911: NOT
60912: IFFALSE 60916
// exit ;
60914: GO 61865
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
60916: LD_ADDR_VAR 0 5
60920: PUSH
60921: LD_INT 4
60923: PUSH
60924: LD_INT 5
60926: PUSH
60927: LD_INT 9
60929: PUSH
60930: LD_INT 10
60932: PUSH
60933: LD_INT 6
60935: PUSH
60936: LD_INT 7
60938: PUSH
60939: LD_INT 11
60941: PUSH
60942: EMPTY
60943: LIST
60944: LIST
60945: LIST
60946: LIST
60947: LIST
60948: LIST
60949: LIST
60950: PUSH
60951: LD_INT 27
60953: PUSH
60954: LD_INT 28
60956: PUSH
60957: LD_INT 26
60959: PUSH
60960: LD_INT 30
60962: PUSH
60963: EMPTY
60964: LIST
60965: LIST
60966: LIST
60967: LIST
60968: PUSH
60969: LD_INT 43
60971: PUSH
60972: LD_INT 44
60974: PUSH
60975: LD_INT 46
60977: PUSH
60978: LD_INT 45
60980: PUSH
60981: LD_INT 47
60983: PUSH
60984: LD_INT 49
60986: PUSH
60987: EMPTY
60988: LIST
60989: LIST
60990: LIST
60991: LIST
60992: LIST
60993: LIST
60994: PUSH
60995: EMPTY
60996: LIST
60997: LIST
60998: LIST
60999: PUSH
61000: LD_VAR 0 12
61004: ARRAY
61005: ST_TO_ADDR
// for i in list do
61006: LD_ADDR_VAR 0 8
61010: PUSH
61011: LD_VAR 0 5
61015: PUSH
61016: FOR_IN
61017: IFFALSE 61050
// if not i in fac_list then
61019: LD_VAR 0 8
61023: PUSH
61024: LD_VAR 0 17
61028: IN
61029: NOT
61030: IFFALSE 61048
// list := list diff i ;
61032: LD_ADDR_VAR 0 5
61036: PUSH
61037: LD_VAR 0 5
61041: PUSH
61042: LD_VAR 0 8
61046: DIFF
61047: ST_TO_ADDR
61048: GO 61016
61050: POP
61051: POP
// if not list then
61052: LD_VAR 0 5
61056: NOT
61057: IFFALSE 61061
// exit ;
61059: GO 61865
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
61061: LD_VAR 0 12
61065: PUSH
61066: LD_INT 3
61068: EQUAL
61069: PUSH
61070: LD_INT 49
61072: PUSH
61073: LD_VAR 0 5
61077: IN
61078: AND
61079: PUSH
61080: LD_INT 31
61082: PPUSH
61083: LD_VAR 0 16
61087: PPUSH
61088: CALL_OW 321
61092: PUSH
61093: LD_INT 2
61095: EQUAL
61096: AND
61097: IFFALSE 61157
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
61099: LD_INT 22
61101: PUSH
61102: LD_VAR 0 16
61106: PUSH
61107: EMPTY
61108: LIST
61109: LIST
61110: PUSH
61111: LD_INT 35
61113: PUSH
61114: LD_INT 49
61116: PUSH
61117: EMPTY
61118: LIST
61119: LIST
61120: PUSH
61121: LD_INT 91
61123: PUSH
61124: LD_VAR 0 1
61128: PUSH
61129: LD_INT 10
61131: PUSH
61132: EMPTY
61133: LIST
61134: LIST
61135: LIST
61136: PUSH
61137: EMPTY
61138: LIST
61139: LIST
61140: LIST
61141: PPUSH
61142: CALL_OW 69
61146: NOT
61147: IFFALSE 61157
// weapon := ru_time_lapser ;
61149: LD_ADDR_VAR 0 18
61153: PUSH
61154: LD_INT 49
61156: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
61157: LD_VAR 0 12
61161: PUSH
61162: LD_INT 1
61164: PUSH
61165: LD_INT 2
61167: PUSH
61168: EMPTY
61169: LIST
61170: LIST
61171: IN
61172: PUSH
61173: LD_INT 11
61175: PUSH
61176: LD_VAR 0 5
61180: IN
61181: PUSH
61182: LD_INT 30
61184: PUSH
61185: LD_VAR 0 5
61189: IN
61190: OR
61191: AND
61192: PUSH
61193: LD_INT 6
61195: PPUSH
61196: LD_VAR 0 16
61200: PPUSH
61201: CALL_OW 321
61205: PUSH
61206: LD_INT 2
61208: EQUAL
61209: AND
61210: IFFALSE 61375
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
61212: LD_INT 22
61214: PUSH
61215: LD_VAR 0 16
61219: PUSH
61220: EMPTY
61221: LIST
61222: LIST
61223: PUSH
61224: LD_INT 2
61226: PUSH
61227: LD_INT 35
61229: PUSH
61230: LD_INT 11
61232: PUSH
61233: EMPTY
61234: LIST
61235: LIST
61236: PUSH
61237: LD_INT 35
61239: PUSH
61240: LD_INT 30
61242: PUSH
61243: EMPTY
61244: LIST
61245: LIST
61246: PUSH
61247: EMPTY
61248: LIST
61249: LIST
61250: LIST
61251: PUSH
61252: LD_INT 91
61254: PUSH
61255: LD_VAR 0 1
61259: PUSH
61260: LD_INT 18
61262: PUSH
61263: EMPTY
61264: LIST
61265: LIST
61266: LIST
61267: PUSH
61268: EMPTY
61269: LIST
61270: LIST
61271: LIST
61272: PPUSH
61273: CALL_OW 69
61277: NOT
61278: PUSH
61279: LD_INT 22
61281: PUSH
61282: LD_VAR 0 16
61286: PUSH
61287: EMPTY
61288: LIST
61289: LIST
61290: PUSH
61291: LD_INT 2
61293: PUSH
61294: LD_INT 30
61296: PUSH
61297: LD_INT 32
61299: PUSH
61300: EMPTY
61301: LIST
61302: LIST
61303: PUSH
61304: LD_INT 30
61306: PUSH
61307: LD_INT 33
61309: PUSH
61310: EMPTY
61311: LIST
61312: LIST
61313: PUSH
61314: EMPTY
61315: LIST
61316: LIST
61317: LIST
61318: PUSH
61319: LD_INT 91
61321: PUSH
61322: LD_VAR 0 1
61326: PUSH
61327: LD_INT 12
61329: PUSH
61330: EMPTY
61331: LIST
61332: LIST
61333: LIST
61334: PUSH
61335: EMPTY
61336: LIST
61337: LIST
61338: LIST
61339: PUSH
61340: EMPTY
61341: LIST
61342: PPUSH
61343: CALL_OW 69
61347: PUSH
61348: LD_INT 2
61350: GREATER
61351: AND
61352: IFFALSE 61375
// weapon := [ us_radar , ar_radar ] [ nat ] ;
61354: LD_ADDR_VAR 0 18
61358: PUSH
61359: LD_INT 11
61361: PUSH
61362: LD_INT 30
61364: PUSH
61365: EMPTY
61366: LIST
61367: LIST
61368: PUSH
61369: LD_VAR 0 12
61373: ARRAY
61374: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
61375: LD_VAR 0 18
61379: NOT
61380: PUSH
61381: LD_INT 40
61383: PPUSH
61384: LD_VAR 0 16
61388: PPUSH
61389: CALL_OW 321
61393: PUSH
61394: LD_INT 2
61396: EQUAL
61397: AND
61398: PUSH
61399: LD_INT 7
61401: PUSH
61402: LD_VAR 0 5
61406: IN
61407: PUSH
61408: LD_INT 28
61410: PUSH
61411: LD_VAR 0 5
61415: IN
61416: OR
61417: PUSH
61418: LD_INT 45
61420: PUSH
61421: LD_VAR 0 5
61425: IN
61426: OR
61427: AND
61428: IFFALSE 61682
// begin hex := GetHexInfo ( x , y ) ;
61430: LD_ADDR_VAR 0 4
61434: PUSH
61435: LD_VAR 0 10
61439: PPUSH
61440: LD_VAR 0 11
61444: PPUSH
61445: CALL_OW 546
61449: ST_TO_ADDR
// if hex [ 1 ] then
61450: LD_VAR 0 4
61454: PUSH
61455: LD_INT 1
61457: ARRAY
61458: IFFALSE 61462
// exit ;
61460: GO 61865
// height := hex [ 2 ] ;
61462: LD_ADDR_VAR 0 15
61466: PUSH
61467: LD_VAR 0 4
61471: PUSH
61472: LD_INT 2
61474: ARRAY
61475: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
61476: LD_ADDR_VAR 0 14
61480: PUSH
61481: LD_INT 0
61483: PUSH
61484: LD_INT 2
61486: PUSH
61487: LD_INT 3
61489: PUSH
61490: LD_INT 5
61492: PUSH
61493: EMPTY
61494: LIST
61495: LIST
61496: LIST
61497: LIST
61498: ST_TO_ADDR
// for i in tmp do
61499: LD_ADDR_VAR 0 8
61503: PUSH
61504: LD_VAR 0 14
61508: PUSH
61509: FOR_IN
61510: IFFALSE 61680
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
61512: LD_ADDR_VAR 0 9
61516: PUSH
61517: LD_VAR 0 10
61521: PPUSH
61522: LD_VAR 0 8
61526: PPUSH
61527: LD_INT 5
61529: PPUSH
61530: CALL_OW 272
61534: PUSH
61535: LD_VAR 0 11
61539: PPUSH
61540: LD_VAR 0 8
61544: PPUSH
61545: LD_INT 5
61547: PPUSH
61548: CALL_OW 273
61552: PUSH
61553: EMPTY
61554: LIST
61555: LIST
61556: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
61557: LD_VAR 0 9
61561: PUSH
61562: LD_INT 1
61564: ARRAY
61565: PPUSH
61566: LD_VAR 0 9
61570: PUSH
61571: LD_INT 2
61573: ARRAY
61574: PPUSH
61575: CALL_OW 488
61579: IFFALSE 61678
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
61581: LD_ADDR_VAR 0 4
61585: PUSH
61586: LD_VAR 0 9
61590: PUSH
61591: LD_INT 1
61593: ARRAY
61594: PPUSH
61595: LD_VAR 0 9
61599: PUSH
61600: LD_INT 2
61602: ARRAY
61603: PPUSH
61604: CALL_OW 546
61608: ST_TO_ADDR
// if hex [ 1 ] then
61609: LD_VAR 0 4
61613: PUSH
61614: LD_INT 1
61616: ARRAY
61617: IFFALSE 61621
// continue ;
61619: GO 61509
// h := hex [ 2 ] ;
61621: LD_ADDR_VAR 0 13
61625: PUSH
61626: LD_VAR 0 4
61630: PUSH
61631: LD_INT 2
61633: ARRAY
61634: ST_TO_ADDR
// if h + 7 < height then
61635: LD_VAR 0 13
61639: PUSH
61640: LD_INT 7
61642: PLUS
61643: PUSH
61644: LD_VAR 0 15
61648: LESS
61649: IFFALSE 61678
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
61651: LD_ADDR_VAR 0 18
61655: PUSH
61656: LD_INT 7
61658: PUSH
61659: LD_INT 28
61661: PUSH
61662: LD_INT 45
61664: PUSH
61665: EMPTY
61666: LIST
61667: LIST
61668: LIST
61669: PUSH
61670: LD_VAR 0 12
61674: ARRAY
61675: ST_TO_ADDR
// break ;
61676: GO 61680
// end ; end ; end ;
61678: GO 61509
61680: POP
61681: POP
// end ; if not weapon then
61682: LD_VAR 0 18
61686: NOT
61687: IFFALSE 61747
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
61689: LD_ADDR_VAR 0 5
61693: PUSH
61694: LD_VAR 0 5
61698: PUSH
61699: LD_INT 11
61701: PUSH
61702: LD_INT 30
61704: PUSH
61705: LD_INT 49
61707: PUSH
61708: EMPTY
61709: LIST
61710: LIST
61711: LIST
61712: DIFF
61713: ST_TO_ADDR
// if not list then
61714: LD_VAR 0 5
61718: NOT
61719: IFFALSE 61723
// exit ;
61721: GO 61865
// weapon := list [ rand ( 1 , list ) ] ;
61723: LD_ADDR_VAR 0 18
61727: PUSH
61728: LD_VAR 0 5
61732: PUSH
61733: LD_INT 1
61735: PPUSH
61736: LD_VAR 0 5
61740: PPUSH
61741: CALL_OW 12
61745: ARRAY
61746: ST_TO_ADDR
// end ; if weapon then
61747: LD_VAR 0 18
61751: IFFALSE 61865
// begin tmp := CostOfWeapon ( weapon ) ;
61753: LD_ADDR_VAR 0 14
61757: PUSH
61758: LD_VAR 0 18
61762: PPUSH
61763: CALL_OW 451
61767: ST_TO_ADDR
// j := GetBase ( tower ) ;
61768: LD_ADDR_VAR 0 9
61772: PUSH
61773: LD_VAR 0 1
61777: PPUSH
61778: CALL_OW 274
61782: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
61783: LD_VAR 0 9
61787: PPUSH
61788: LD_INT 1
61790: PPUSH
61791: CALL_OW 275
61795: PUSH
61796: LD_VAR 0 14
61800: PUSH
61801: LD_INT 1
61803: ARRAY
61804: GREATEREQUAL
61805: PUSH
61806: LD_VAR 0 9
61810: PPUSH
61811: LD_INT 2
61813: PPUSH
61814: CALL_OW 275
61818: PUSH
61819: LD_VAR 0 14
61823: PUSH
61824: LD_INT 2
61826: ARRAY
61827: GREATEREQUAL
61828: AND
61829: PUSH
61830: LD_VAR 0 9
61834: PPUSH
61835: LD_INT 3
61837: PPUSH
61838: CALL_OW 275
61842: PUSH
61843: LD_VAR 0 14
61847: PUSH
61848: LD_INT 3
61850: ARRAY
61851: GREATEREQUAL
61852: AND
61853: IFFALSE 61865
// result := weapon ;
61855: LD_ADDR_VAR 0 3
61859: PUSH
61860: LD_VAR 0 18
61864: ST_TO_ADDR
// end ; end ;
61865: LD_VAR 0 3
61869: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
61870: LD_INT 0
61872: PPUSH
61873: PPUSH
// result := true ;
61874: LD_ADDR_VAR 0 3
61878: PUSH
61879: LD_INT 1
61881: ST_TO_ADDR
// if array1 = array2 then
61882: LD_VAR 0 1
61886: PUSH
61887: LD_VAR 0 2
61891: EQUAL
61892: IFFALSE 61952
// begin for i = 1 to array1 do
61894: LD_ADDR_VAR 0 4
61898: PUSH
61899: DOUBLE
61900: LD_INT 1
61902: DEC
61903: ST_TO_ADDR
61904: LD_VAR 0 1
61908: PUSH
61909: FOR_TO
61910: IFFALSE 61948
// if array1 [ i ] <> array2 [ i ] then
61912: LD_VAR 0 1
61916: PUSH
61917: LD_VAR 0 4
61921: ARRAY
61922: PUSH
61923: LD_VAR 0 2
61927: PUSH
61928: LD_VAR 0 4
61932: ARRAY
61933: NONEQUAL
61934: IFFALSE 61946
// begin result := false ;
61936: LD_ADDR_VAR 0 3
61940: PUSH
61941: LD_INT 0
61943: ST_TO_ADDR
// break ;
61944: GO 61948
// end ;
61946: GO 61909
61948: POP
61949: POP
// end else
61950: GO 61960
// result := false ;
61952: LD_ADDR_VAR 0 3
61956: PUSH
61957: LD_INT 0
61959: ST_TO_ADDR
// end ;
61960: LD_VAR 0 3
61964: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
61965: LD_INT 0
61967: PPUSH
61968: PPUSH
61969: PPUSH
// pom := GetBase ( fac ) ;
61970: LD_ADDR_VAR 0 5
61974: PUSH
61975: LD_VAR 0 1
61979: PPUSH
61980: CALL_OW 274
61984: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
61985: LD_ADDR_VAR 0 4
61989: PUSH
61990: LD_VAR 0 2
61994: PUSH
61995: LD_INT 1
61997: ARRAY
61998: PPUSH
61999: LD_VAR 0 2
62003: PUSH
62004: LD_INT 2
62006: ARRAY
62007: PPUSH
62008: LD_VAR 0 2
62012: PUSH
62013: LD_INT 3
62015: ARRAY
62016: PPUSH
62017: LD_VAR 0 2
62021: PUSH
62022: LD_INT 4
62024: ARRAY
62025: PPUSH
62026: CALL_OW 449
62030: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62031: LD_ADDR_VAR 0 3
62035: PUSH
62036: LD_VAR 0 5
62040: PPUSH
62041: LD_INT 1
62043: PPUSH
62044: CALL_OW 275
62048: PUSH
62049: LD_VAR 0 4
62053: PUSH
62054: LD_INT 1
62056: ARRAY
62057: GREATEREQUAL
62058: PUSH
62059: LD_VAR 0 5
62063: PPUSH
62064: LD_INT 2
62066: PPUSH
62067: CALL_OW 275
62071: PUSH
62072: LD_VAR 0 4
62076: PUSH
62077: LD_INT 2
62079: ARRAY
62080: GREATEREQUAL
62081: AND
62082: PUSH
62083: LD_VAR 0 5
62087: PPUSH
62088: LD_INT 3
62090: PPUSH
62091: CALL_OW 275
62095: PUSH
62096: LD_VAR 0 4
62100: PUSH
62101: LD_INT 3
62103: ARRAY
62104: GREATEREQUAL
62105: AND
62106: ST_TO_ADDR
// end ;
62107: LD_VAR 0 3
62111: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
62112: LD_INT 0
62114: PPUSH
62115: PPUSH
62116: PPUSH
62117: PPUSH
// pom := GetBase ( building ) ;
62118: LD_ADDR_VAR 0 3
62122: PUSH
62123: LD_VAR 0 1
62127: PPUSH
62128: CALL_OW 274
62132: ST_TO_ADDR
// if not pom then
62133: LD_VAR 0 3
62137: NOT
62138: IFFALSE 62142
// exit ;
62140: GO 62312
// btype := GetBType ( building ) ;
62142: LD_ADDR_VAR 0 5
62146: PUSH
62147: LD_VAR 0 1
62151: PPUSH
62152: CALL_OW 266
62156: ST_TO_ADDR
// if btype = b_armoury then
62157: LD_VAR 0 5
62161: PUSH
62162: LD_INT 4
62164: EQUAL
62165: IFFALSE 62175
// btype := b_barracks ;
62167: LD_ADDR_VAR 0 5
62171: PUSH
62172: LD_INT 5
62174: ST_TO_ADDR
// if btype = b_depot then
62175: LD_VAR 0 5
62179: PUSH
62180: LD_INT 0
62182: EQUAL
62183: IFFALSE 62193
// btype := b_warehouse ;
62185: LD_ADDR_VAR 0 5
62189: PUSH
62190: LD_INT 1
62192: ST_TO_ADDR
// if btype = b_workshop then
62193: LD_VAR 0 5
62197: PUSH
62198: LD_INT 2
62200: EQUAL
62201: IFFALSE 62211
// btype := b_factory ;
62203: LD_ADDR_VAR 0 5
62207: PUSH
62208: LD_INT 3
62210: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
62211: LD_ADDR_VAR 0 4
62215: PUSH
62216: LD_VAR 0 5
62220: PPUSH
62221: LD_VAR 0 1
62225: PPUSH
62226: CALL_OW 248
62230: PPUSH
62231: CALL_OW 450
62235: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62236: LD_ADDR_VAR 0 2
62240: PUSH
62241: LD_VAR 0 3
62245: PPUSH
62246: LD_INT 1
62248: PPUSH
62249: CALL_OW 275
62253: PUSH
62254: LD_VAR 0 4
62258: PUSH
62259: LD_INT 1
62261: ARRAY
62262: GREATEREQUAL
62263: PUSH
62264: LD_VAR 0 3
62268: PPUSH
62269: LD_INT 2
62271: PPUSH
62272: CALL_OW 275
62276: PUSH
62277: LD_VAR 0 4
62281: PUSH
62282: LD_INT 2
62284: ARRAY
62285: GREATEREQUAL
62286: AND
62287: PUSH
62288: LD_VAR 0 3
62292: PPUSH
62293: LD_INT 3
62295: PPUSH
62296: CALL_OW 275
62300: PUSH
62301: LD_VAR 0 4
62305: PUSH
62306: LD_INT 3
62308: ARRAY
62309: GREATEREQUAL
62310: AND
62311: ST_TO_ADDR
// end ;
62312: LD_VAR 0 2
62316: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
62317: LD_INT 0
62319: PPUSH
62320: PPUSH
62321: PPUSH
// pom := GetBase ( building ) ;
62322: LD_ADDR_VAR 0 4
62326: PUSH
62327: LD_VAR 0 1
62331: PPUSH
62332: CALL_OW 274
62336: ST_TO_ADDR
// if not pom then
62337: LD_VAR 0 4
62341: NOT
62342: IFFALSE 62346
// exit ;
62344: GO 62447
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
62346: LD_ADDR_VAR 0 5
62350: PUSH
62351: LD_VAR 0 2
62355: PPUSH
62356: LD_VAR 0 1
62360: PPUSH
62361: CALL_OW 248
62365: PPUSH
62366: CALL_OW 450
62370: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62371: LD_ADDR_VAR 0 3
62375: PUSH
62376: LD_VAR 0 4
62380: PPUSH
62381: LD_INT 1
62383: PPUSH
62384: CALL_OW 275
62388: PUSH
62389: LD_VAR 0 5
62393: PUSH
62394: LD_INT 1
62396: ARRAY
62397: GREATEREQUAL
62398: PUSH
62399: LD_VAR 0 4
62403: PPUSH
62404: LD_INT 2
62406: PPUSH
62407: CALL_OW 275
62411: PUSH
62412: LD_VAR 0 5
62416: PUSH
62417: LD_INT 2
62419: ARRAY
62420: GREATEREQUAL
62421: AND
62422: PUSH
62423: LD_VAR 0 4
62427: PPUSH
62428: LD_INT 3
62430: PPUSH
62431: CALL_OW 275
62435: PUSH
62436: LD_VAR 0 5
62440: PUSH
62441: LD_INT 3
62443: ARRAY
62444: GREATEREQUAL
62445: AND
62446: ST_TO_ADDR
// end ;
62447: LD_VAR 0 3
62451: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
62452: LD_INT 0
62454: PPUSH
62455: PPUSH
62456: PPUSH
62457: PPUSH
62458: PPUSH
62459: PPUSH
62460: PPUSH
62461: PPUSH
62462: PPUSH
62463: PPUSH
// result := false ;
62464: LD_ADDR_VAR 0 6
62468: PUSH
62469: LD_INT 0
62471: ST_TO_ADDR
// if not base or not btype or not x or not y then
62472: LD_VAR 0 1
62476: NOT
62477: PUSH
62478: LD_VAR 0 2
62482: NOT
62483: OR
62484: PUSH
62485: LD_VAR 0 3
62489: NOT
62490: OR
62491: PUSH
62492: LD_VAR 0 4
62496: NOT
62497: OR
62498: IFFALSE 62502
// exit ;
62500: GO 63111
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
62502: LD_ADDR_VAR 0 12
62506: PUSH
62507: LD_VAR 0 2
62511: PPUSH
62512: LD_VAR 0 3
62516: PPUSH
62517: LD_VAR 0 4
62521: PPUSH
62522: LD_VAR 0 5
62526: PPUSH
62527: LD_VAR 0 1
62531: PUSH
62532: LD_INT 1
62534: ARRAY
62535: PPUSH
62536: CALL_OW 248
62540: PPUSH
62541: LD_INT 0
62543: PPUSH
62544: CALL 63948 0 6
62548: ST_TO_ADDR
// if not hexes then
62549: LD_VAR 0 12
62553: NOT
62554: IFFALSE 62558
// exit ;
62556: GO 63111
// for i = 1 to hexes do
62558: LD_ADDR_VAR 0 7
62562: PUSH
62563: DOUBLE
62564: LD_INT 1
62566: DEC
62567: ST_TO_ADDR
62568: LD_VAR 0 12
62572: PUSH
62573: FOR_TO
62574: IFFALSE 63109
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
62576: LD_ADDR_VAR 0 11
62580: PUSH
62581: LD_VAR 0 12
62585: PUSH
62586: LD_VAR 0 7
62590: ARRAY
62591: PUSH
62592: LD_INT 1
62594: ARRAY
62595: PPUSH
62596: LD_VAR 0 12
62600: PUSH
62601: LD_VAR 0 7
62605: ARRAY
62606: PUSH
62607: LD_INT 2
62609: ARRAY
62610: PPUSH
62611: CALL_OW 428
62615: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
62616: LD_VAR 0 12
62620: PUSH
62621: LD_VAR 0 7
62625: ARRAY
62626: PUSH
62627: LD_INT 1
62629: ARRAY
62630: PPUSH
62631: LD_VAR 0 12
62635: PUSH
62636: LD_VAR 0 7
62640: ARRAY
62641: PUSH
62642: LD_INT 2
62644: ARRAY
62645: PPUSH
62646: CALL_OW 351
62650: PUSH
62651: LD_VAR 0 12
62655: PUSH
62656: LD_VAR 0 7
62660: ARRAY
62661: PUSH
62662: LD_INT 1
62664: ARRAY
62665: PPUSH
62666: LD_VAR 0 12
62670: PUSH
62671: LD_VAR 0 7
62675: ARRAY
62676: PUSH
62677: LD_INT 2
62679: ARRAY
62680: PPUSH
62681: CALL_OW 488
62685: NOT
62686: OR
62687: PUSH
62688: LD_VAR 0 11
62692: PPUSH
62693: CALL_OW 247
62697: PUSH
62698: LD_INT 3
62700: EQUAL
62701: OR
62702: IFFALSE 62708
// exit ;
62704: POP
62705: POP
62706: GO 63111
// if not tmp or not tmp in base then
62708: LD_VAR 0 11
62712: NOT
62713: PUSH
62714: LD_VAR 0 11
62718: PUSH
62719: LD_VAR 0 1
62723: IN
62724: NOT
62725: OR
62726: IFFALSE 62730
// continue ;
62728: GO 62573
// result := true ;
62730: LD_ADDR_VAR 0 6
62734: PUSH
62735: LD_INT 1
62737: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
62738: LD_ADDR_VAR 0 15
62742: PUSH
62743: LD_VAR 0 1
62747: PPUSH
62748: LD_INT 22
62750: PUSH
62751: LD_VAR 0 11
62755: PPUSH
62756: CALL_OW 255
62760: PUSH
62761: EMPTY
62762: LIST
62763: LIST
62764: PUSH
62765: LD_INT 2
62767: PUSH
62768: LD_INT 30
62770: PUSH
62771: LD_INT 0
62773: PUSH
62774: EMPTY
62775: LIST
62776: LIST
62777: PUSH
62778: LD_INT 30
62780: PUSH
62781: LD_INT 1
62783: PUSH
62784: EMPTY
62785: LIST
62786: LIST
62787: PUSH
62788: EMPTY
62789: LIST
62790: LIST
62791: LIST
62792: PUSH
62793: EMPTY
62794: LIST
62795: LIST
62796: PPUSH
62797: CALL_OW 72
62801: ST_TO_ADDR
// if dep then
62802: LD_VAR 0 15
62806: IFFALSE 62942
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
62808: LD_ADDR_VAR 0 14
62812: PUSH
62813: LD_VAR 0 15
62817: PUSH
62818: LD_INT 1
62820: ARRAY
62821: PPUSH
62822: CALL_OW 250
62826: PPUSH
62827: LD_VAR 0 15
62831: PUSH
62832: LD_INT 1
62834: ARRAY
62835: PPUSH
62836: CALL_OW 254
62840: PPUSH
62841: LD_INT 5
62843: PPUSH
62844: CALL_OW 272
62848: PUSH
62849: LD_VAR 0 15
62853: PUSH
62854: LD_INT 1
62856: ARRAY
62857: PPUSH
62858: CALL_OW 251
62862: PPUSH
62863: LD_VAR 0 15
62867: PUSH
62868: LD_INT 1
62870: ARRAY
62871: PPUSH
62872: CALL_OW 254
62876: PPUSH
62877: LD_INT 5
62879: PPUSH
62880: CALL_OW 273
62884: PUSH
62885: EMPTY
62886: LIST
62887: LIST
62888: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
62889: LD_VAR 0 14
62893: PUSH
62894: LD_INT 1
62896: ARRAY
62897: PPUSH
62898: LD_VAR 0 14
62902: PUSH
62903: LD_INT 2
62905: ARRAY
62906: PPUSH
62907: CALL_OW 488
62911: IFFALSE 62942
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
62913: LD_VAR 0 11
62917: PPUSH
62918: LD_VAR 0 14
62922: PUSH
62923: LD_INT 1
62925: ARRAY
62926: PPUSH
62927: LD_VAR 0 14
62931: PUSH
62932: LD_INT 2
62934: ARRAY
62935: PPUSH
62936: CALL_OW 111
// continue ;
62940: GO 62573
// end ; end ; r := GetDir ( tmp ) ;
62942: LD_ADDR_VAR 0 13
62946: PUSH
62947: LD_VAR 0 11
62951: PPUSH
62952: CALL_OW 254
62956: ST_TO_ADDR
// if r = 5 then
62957: LD_VAR 0 13
62961: PUSH
62962: LD_INT 5
62964: EQUAL
62965: IFFALSE 62975
// r := 0 ;
62967: LD_ADDR_VAR 0 13
62971: PUSH
62972: LD_INT 0
62974: ST_TO_ADDR
// for j = r to 5 do
62975: LD_ADDR_VAR 0 8
62979: PUSH
62980: DOUBLE
62981: LD_VAR 0 13
62985: DEC
62986: ST_TO_ADDR
62987: LD_INT 5
62989: PUSH
62990: FOR_TO
62991: IFFALSE 63105
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
62993: LD_ADDR_VAR 0 9
62997: PUSH
62998: LD_VAR 0 11
63002: PPUSH
63003: CALL_OW 250
63007: PPUSH
63008: LD_VAR 0 8
63012: PPUSH
63013: LD_INT 2
63015: PPUSH
63016: CALL_OW 272
63020: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
63021: LD_ADDR_VAR 0 10
63025: PUSH
63026: LD_VAR 0 11
63030: PPUSH
63031: CALL_OW 251
63035: PPUSH
63036: LD_VAR 0 8
63040: PPUSH
63041: LD_INT 2
63043: PPUSH
63044: CALL_OW 273
63048: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
63049: LD_VAR 0 9
63053: PPUSH
63054: LD_VAR 0 10
63058: PPUSH
63059: CALL_OW 488
63063: PUSH
63064: LD_VAR 0 9
63068: PPUSH
63069: LD_VAR 0 10
63073: PPUSH
63074: CALL_OW 428
63078: NOT
63079: AND
63080: IFFALSE 63103
// begin ComMoveXY ( tmp , _x , _y ) ;
63082: LD_VAR 0 11
63086: PPUSH
63087: LD_VAR 0 9
63091: PPUSH
63092: LD_VAR 0 10
63096: PPUSH
63097: CALL_OW 111
// break ;
63101: GO 63105
// end ; end ;
63103: GO 62990
63105: POP
63106: POP
// end ;
63107: GO 62573
63109: POP
63110: POP
// end ;
63111: LD_VAR 0 6
63115: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
63116: LD_INT 0
63118: PPUSH
63119: PPUSH
63120: PPUSH
63121: PPUSH
63122: PPUSH
63123: PPUSH
63124: PPUSH
63125: PPUSH
63126: PPUSH
63127: PPUSH
// result := false ;
63128: LD_ADDR_VAR 0 6
63132: PUSH
63133: LD_INT 0
63135: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
63136: LD_VAR 0 1
63140: NOT
63141: PUSH
63142: LD_VAR 0 1
63146: PPUSH
63147: CALL_OW 266
63151: PUSH
63152: LD_INT 0
63154: PUSH
63155: LD_INT 1
63157: PUSH
63158: EMPTY
63159: LIST
63160: LIST
63161: IN
63162: NOT
63163: OR
63164: PUSH
63165: LD_VAR 0 2
63169: NOT
63170: OR
63171: PUSH
63172: LD_VAR 0 5
63176: PUSH
63177: LD_INT 0
63179: PUSH
63180: LD_INT 1
63182: PUSH
63183: LD_INT 2
63185: PUSH
63186: LD_INT 3
63188: PUSH
63189: LD_INT 4
63191: PUSH
63192: LD_INT 5
63194: PUSH
63195: EMPTY
63196: LIST
63197: LIST
63198: LIST
63199: LIST
63200: LIST
63201: LIST
63202: IN
63203: NOT
63204: OR
63205: PUSH
63206: LD_VAR 0 3
63210: PPUSH
63211: LD_VAR 0 4
63215: PPUSH
63216: CALL_OW 488
63220: NOT
63221: OR
63222: IFFALSE 63226
// exit ;
63224: GO 63943
// pom := GetBase ( depot ) ;
63226: LD_ADDR_VAR 0 10
63230: PUSH
63231: LD_VAR 0 1
63235: PPUSH
63236: CALL_OW 274
63240: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
63241: LD_ADDR_VAR 0 11
63245: PUSH
63246: LD_VAR 0 2
63250: PPUSH
63251: LD_VAR 0 1
63255: PPUSH
63256: CALL_OW 248
63260: PPUSH
63261: CALL_OW 450
63265: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
63266: LD_VAR 0 10
63270: PPUSH
63271: LD_INT 1
63273: PPUSH
63274: CALL_OW 275
63278: PUSH
63279: LD_VAR 0 11
63283: PUSH
63284: LD_INT 1
63286: ARRAY
63287: GREATEREQUAL
63288: PUSH
63289: LD_VAR 0 10
63293: PPUSH
63294: LD_INT 2
63296: PPUSH
63297: CALL_OW 275
63301: PUSH
63302: LD_VAR 0 11
63306: PUSH
63307: LD_INT 2
63309: ARRAY
63310: GREATEREQUAL
63311: AND
63312: PUSH
63313: LD_VAR 0 10
63317: PPUSH
63318: LD_INT 3
63320: PPUSH
63321: CALL_OW 275
63325: PUSH
63326: LD_VAR 0 11
63330: PUSH
63331: LD_INT 3
63333: ARRAY
63334: GREATEREQUAL
63335: AND
63336: NOT
63337: IFFALSE 63341
// exit ;
63339: GO 63943
// if GetBType ( depot ) = b_depot then
63341: LD_VAR 0 1
63345: PPUSH
63346: CALL_OW 266
63350: PUSH
63351: LD_INT 0
63353: EQUAL
63354: IFFALSE 63366
// dist := 28 else
63356: LD_ADDR_VAR 0 14
63360: PUSH
63361: LD_INT 28
63363: ST_TO_ADDR
63364: GO 63374
// dist := 36 ;
63366: LD_ADDR_VAR 0 14
63370: PUSH
63371: LD_INT 36
63373: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
63374: LD_VAR 0 1
63378: PPUSH
63379: LD_VAR 0 3
63383: PPUSH
63384: LD_VAR 0 4
63388: PPUSH
63389: CALL_OW 297
63393: PUSH
63394: LD_VAR 0 14
63398: GREATER
63399: IFFALSE 63403
// exit ;
63401: GO 63943
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
63403: LD_ADDR_VAR 0 12
63407: PUSH
63408: LD_VAR 0 2
63412: PPUSH
63413: LD_VAR 0 3
63417: PPUSH
63418: LD_VAR 0 4
63422: PPUSH
63423: LD_VAR 0 5
63427: PPUSH
63428: LD_VAR 0 1
63432: PPUSH
63433: CALL_OW 248
63437: PPUSH
63438: LD_INT 0
63440: PPUSH
63441: CALL 63948 0 6
63445: ST_TO_ADDR
// if not hexes then
63446: LD_VAR 0 12
63450: NOT
63451: IFFALSE 63455
// exit ;
63453: GO 63943
// hex := GetHexInfo ( x , y ) ;
63455: LD_ADDR_VAR 0 15
63459: PUSH
63460: LD_VAR 0 3
63464: PPUSH
63465: LD_VAR 0 4
63469: PPUSH
63470: CALL_OW 546
63474: ST_TO_ADDR
// if hex [ 1 ] then
63475: LD_VAR 0 15
63479: PUSH
63480: LD_INT 1
63482: ARRAY
63483: IFFALSE 63487
// exit ;
63485: GO 63943
// height := hex [ 2 ] ;
63487: LD_ADDR_VAR 0 13
63491: PUSH
63492: LD_VAR 0 15
63496: PUSH
63497: LD_INT 2
63499: ARRAY
63500: ST_TO_ADDR
// for i = 1 to hexes do
63501: LD_ADDR_VAR 0 7
63505: PUSH
63506: DOUBLE
63507: LD_INT 1
63509: DEC
63510: ST_TO_ADDR
63511: LD_VAR 0 12
63515: PUSH
63516: FOR_TO
63517: IFFALSE 63847
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
63519: LD_VAR 0 12
63523: PUSH
63524: LD_VAR 0 7
63528: ARRAY
63529: PUSH
63530: LD_INT 1
63532: ARRAY
63533: PPUSH
63534: LD_VAR 0 12
63538: PUSH
63539: LD_VAR 0 7
63543: ARRAY
63544: PUSH
63545: LD_INT 2
63547: ARRAY
63548: PPUSH
63549: CALL_OW 488
63553: NOT
63554: PUSH
63555: LD_VAR 0 12
63559: PUSH
63560: LD_VAR 0 7
63564: ARRAY
63565: PUSH
63566: LD_INT 1
63568: ARRAY
63569: PPUSH
63570: LD_VAR 0 12
63574: PUSH
63575: LD_VAR 0 7
63579: ARRAY
63580: PUSH
63581: LD_INT 2
63583: ARRAY
63584: PPUSH
63585: CALL_OW 428
63589: PUSH
63590: LD_INT 0
63592: GREATER
63593: OR
63594: PUSH
63595: LD_VAR 0 12
63599: PUSH
63600: LD_VAR 0 7
63604: ARRAY
63605: PUSH
63606: LD_INT 1
63608: ARRAY
63609: PPUSH
63610: LD_VAR 0 12
63614: PUSH
63615: LD_VAR 0 7
63619: ARRAY
63620: PUSH
63621: LD_INT 2
63623: ARRAY
63624: PPUSH
63625: CALL_OW 351
63629: OR
63630: IFFALSE 63636
// exit ;
63632: POP
63633: POP
63634: GO 63943
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
63636: LD_ADDR_VAR 0 8
63640: PUSH
63641: LD_VAR 0 12
63645: PUSH
63646: LD_VAR 0 7
63650: ARRAY
63651: PUSH
63652: LD_INT 1
63654: ARRAY
63655: PPUSH
63656: LD_VAR 0 12
63660: PUSH
63661: LD_VAR 0 7
63665: ARRAY
63666: PUSH
63667: LD_INT 2
63669: ARRAY
63670: PPUSH
63671: CALL_OW 546
63675: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
63676: LD_VAR 0 8
63680: PUSH
63681: LD_INT 1
63683: ARRAY
63684: PUSH
63685: LD_VAR 0 8
63689: PUSH
63690: LD_INT 2
63692: ARRAY
63693: PUSH
63694: LD_VAR 0 13
63698: PUSH
63699: LD_INT 2
63701: PLUS
63702: GREATER
63703: OR
63704: PUSH
63705: LD_VAR 0 8
63709: PUSH
63710: LD_INT 2
63712: ARRAY
63713: PUSH
63714: LD_VAR 0 13
63718: PUSH
63719: LD_INT 2
63721: MINUS
63722: LESS
63723: OR
63724: PUSH
63725: LD_VAR 0 8
63729: PUSH
63730: LD_INT 3
63732: ARRAY
63733: PUSH
63734: LD_INT 0
63736: PUSH
63737: LD_INT 8
63739: PUSH
63740: LD_INT 9
63742: PUSH
63743: LD_INT 10
63745: PUSH
63746: LD_INT 11
63748: PUSH
63749: LD_INT 12
63751: PUSH
63752: LD_INT 13
63754: PUSH
63755: LD_INT 16
63757: PUSH
63758: LD_INT 17
63760: PUSH
63761: LD_INT 18
63763: PUSH
63764: LD_INT 19
63766: PUSH
63767: LD_INT 20
63769: PUSH
63770: LD_INT 21
63772: PUSH
63773: EMPTY
63774: LIST
63775: LIST
63776: LIST
63777: LIST
63778: LIST
63779: LIST
63780: LIST
63781: LIST
63782: LIST
63783: LIST
63784: LIST
63785: LIST
63786: LIST
63787: IN
63788: NOT
63789: OR
63790: PUSH
63791: LD_VAR 0 8
63795: PUSH
63796: LD_INT 5
63798: ARRAY
63799: NOT
63800: OR
63801: PUSH
63802: LD_VAR 0 8
63806: PUSH
63807: LD_INT 6
63809: ARRAY
63810: PUSH
63811: LD_INT 1
63813: PUSH
63814: LD_INT 2
63816: PUSH
63817: LD_INT 7
63819: PUSH
63820: LD_INT 9
63822: PUSH
63823: LD_INT 10
63825: PUSH
63826: LD_INT 11
63828: PUSH
63829: EMPTY
63830: LIST
63831: LIST
63832: LIST
63833: LIST
63834: LIST
63835: LIST
63836: IN
63837: NOT
63838: OR
63839: IFFALSE 63845
// exit ;
63841: POP
63842: POP
63843: GO 63943
// end ;
63845: GO 63516
63847: POP
63848: POP
// side := GetSide ( depot ) ;
63849: LD_ADDR_VAR 0 9
63853: PUSH
63854: LD_VAR 0 1
63858: PPUSH
63859: CALL_OW 255
63863: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
63864: LD_VAR 0 9
63868: PPUSH
63869: LD_VAR 0 3
63873: PPUSH
63874: LD_VAR 0 4
63878: PPUSH
63879: LD_INT 20
63881: PPUSH
63882: CALL 56597 0 4
63886: PUSH
63887: LD_INT 4
63889: ARRAY
63890: IFFALSE 63894
// exit ;
63892: GO 63943
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
63894: LD_VAR 0 2
63898: PUSH
63899: LD_INT 29
63901: PUSH
63902: LD_INT 30
63904: PUSH
63905: EMPTY
63906: LIST
63907: LIST
63908: IN
63909: PUSH
63910: LD_VAR 0 3
63914: PPUSH
63915: LD_VAR 0 4
63919: PPUSH
63920: LD_VAR 0 9
63924: PPUSH
63925: CALL_OW 440
63929: NOT
63930: AND
63931: IFFALSE 63935
// exit ;
63933: GO 63943
// result := true ;
63935: LD_ADDR_VAR 0 6
63939: PUSH
63940: LD_INT 1
63942: ST_TO_ADDR
// end ;
63943: LD_VAR 0 6
63947: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
63948: LD_INT 0
63950: PPUSH
63951: PPUSH
63952: PPUSH
63953: PPUSH
63954: PPUSH
63955: PPUSH
63956: PPUSH
63957: PPUSH
63958: PPUSH
63959: PPUSH
63960: PPUSH
63961: PPUSH
63962: PPUSH
63963: PPUSH
63964: PPUSH
63965: PPUSH
63966: PPUSH
63967: PPUSH
63968: PPUSH
63969: PPUSH
63970: PPUSH
63971: PPUSH
63972: PPUSH
63973: PPUSH
63974: PPUSH
63975: PPUSH
63976: PPUSH
63977: PPUSH
63978: PPUSH
63979: PPUSH
63980: PPUSH
63981: PPUSH
63982: PPUSH
63983: PPUSH
63984: PPUSH
63985: PPUSH
63986: PPUSH
63987: PPUSH
63988: PPUSH
63989: PPUSH
63990: PPUSH
63991: PPUSH
63992: PPUSH
63993: PPUSH
63994: PPUSH
63995: PPUSH
63996: PPUSH
63997: PPUSH
63998: PPUSH
63999: PPUSH
64000: PPUSH
64001: PPUSH
64002: PPUSH
64003: PPUSH
64004: PPUSH
64005: PPUSH
64006: PPUSH
64007: PPUSH
// result = [ ] ;
64008: LD_ADDR_VAR 0 7
64012: PUSH
64013: EMPTY
64014: ST_TO_ADDR
// temp_list = [ ] ;
64015: LD_ADDR_VAR 0 9
64019: PUSH
64020: EMPTY
64021: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
64022: LD_VAR 0 4
64026: PUSH
64027: LD_INT 0
64029: PUSH
64030: LD_INT 1
64032: PUSH
64033: LD_INT 2
64035: PUSH
64036: LD_INT 3
64038: PUSH
64039: LD_INT 4
64041: PUSH
64042: LD_INT 5
64044: PUSH
64045: EMPTY
64046: LIST
64047: LIST
64048: LIST
64049: LIST
64050: LIST
64051: LIST
64052: IN
64053: NOT
64054: PUSH
64055: LD_VAR 0 1
64059: PUSH
64060: LD_INT 0
64062: PUSH
64063: LD_INT 1
64065: PUSH
64066: EMPTY
64067: LIST
64068: LIST
64069: IN
64070: PUSH
64071: LD_VAR 0 5
64075: PUSH
64076: LD_INT 1
64078: PUSH
64079: LD_INT 2
64081: PUSH
64082: LD_INT 3
64084: PUSH
64085: EMPTY
64086: LIST
64087: LIST
64088: LIST
64089: IN
64090: NOT
64091: AND
64092: OR
64093: IFFALSE 64097
// exit ;
64095: GO 82488
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
64097: LD_VAR 0 1
64101: PUSH
64102: LD_INT 6
64104: PUSH
64105: LD_INT 7
64107: PUSH
64108: LD_INT 8
64110: PUSH
64111: LD_INT 13
64113: PUSH
64114: LD_INT 12
64116: PUSH
64117: LD_INT 15
64119: PUSH
64120: LD_INT 11
64122: PUSH
64123: LD_INT 14
64125: PUSH
64126: LD_INT 10
64128: PUSH
64129: EMPTY
64130: LIST
64131: LIST
64132: LIST
64133: LIST
64134: LIST
64135: LIST
64136: LIST
64137: LIST
64138: LIST
64139: IN
64140: IFFALSE 64150
// btype = b_lab ;
64142: LD_ADDR_VAR 0 1
64146: PUSH
64147: LD_INT 6
64149: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
64150: LD_VAR 0 6
64154: PUSH
64155: LD_INT 0
64157: PUSH
64158: LD_INT 1
64160: PUSH
64161: LD_INT 2
64163: PUSH
64164: EMPTY
64165: LIST
64166: LIST
64167: LIST
64168: IN
64169: NOT
64170: PUSH
64171: LD_VAR 0 1
64175: PUSH
64176: LD_INT 0
64178: PUSH
64179: LD_INT 1
64181: PUSH
64182: LD_INT 2
64184: PUSH
64185: LD_INT 3
64187: PUSH
64188: LD_INT 6
64190: PUSH
64191: LD_INT 36
64193: PUSH
64194: LD_INT 4
64196: PUSH
64197: LD_INT 5
64199: PUSH
64200: LD_INT 31
64202: PUSH
64203: LD_INT 32
64205: PUSH
64206: LD_INT 33
64208: PUSH
64209: EMPTY
64210: LIST
64211: LIST
64212: LIST
64213: LIST
64214: LIST
64215: LIST
64216: LIST
64217: LIST
64218: LIST
64219: LIST
64220: LIST
64221: IN
64222: NOT
64223: PUSH
64224: LD_VAR 0 6
64228: PUSH
64229: LD_INT 1
64231: EQUAL
64232: AND
64233: OR
64234: PUSH
64235: LD_VAR 0 1
64239: PUSH
64240: LD_INT 2
64242: PUSH
64243: LD_INT 3
64245: PUSH
64246: EMPTY
64247: LIST
64248: LIST
64249: IN
64250: NOT
64251: PUSH
64252: LD_VAR 0 6
64256: PUSH
64257: LD_INT 2
64259: EQUAL
64260: AND
64261: OR
64262: IFFALSE 64272
// mode = 0 ;
64264: LD_ADDR_VAR 0 6
64268: PUSH
64269: LD_INT 0
64271: ST_TO_ADDR
// case mode of 0 :
64272: LD_VAR 0 6
64276: PUSH
64277: LD_INT 0
64279: DOUBLE
64280: EQUAL
64281: IFTRUE 64285
64283: GO 75738
64285: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
64286: LD_ADDR_VAR 0 11
64290: PUSH
64291: LD_INT 0
64293: PUSH
64294: LD_INT 0
64296: PUSH
64297: EMPTY
64298: LIST
64299: LIST
64300: PUSH
64301: LD_INT 0
64303: PUSH
64304: LD_INT 1
64306: NEG
64307: PUSH
64308: EMPTY
64309: LIST
64310: LIST
64311: PUSH
64312: LD_INT 1
64314: PUSH
64315: LD_INT 0
64317: PUSH
64318: EMPTY
64319: LIST
64320: LIST
64321: PUSH
64322: LD_INT 1
64324: PUSH
64325: LD_INT 1
64327: PUSH
64328: EMPTY
64329: LIST
64330: LIST
64331: PUSH
64332: LD_INT 0
64334: PUSH
64335: LD_INT 1
64337: PUSH
64338: EMPTY
64339: LIST
64340: LIST
64341: PUSH
64342: LD_INT 1
64344: NEG
64345: PUSH
64346: LD_INT 0
64348: PUSH
64349: EMPTY
64350: LIST
64351: LIST
64352: PUSH
64353: LD_INT 1
64355: NEG
64356: PUSH
64357: LD_INT 1
64359: NEG
64360: PUSH
64361: EMPTY
64362: LIST
64363: LIST
64364: PUSH
64365: LD_INT 1
64367: NEG
64368: PUSH
64369: LD_INT 2
64371: NEG
64372: PUSH
64373: EMPTY
64374: LIST
64375: LIST
64376: PUSH
64377: LD_INT 0
64379: PUSH
64380: LD_INT 2
64382: NEG
64383: PUSH
64384: EMPTY
64385: LIST
64386: LIST
64387: PUSH
64388: LD_INT 1
64390: PUSH
64391: LD_INT 1
64393: NEG
64394: PUSH
64395: EMPTY
64396: LIST
64397: LIST
64398: PUSH
64399: LD_INT 1
64401: PUSH
64402: LD_INT 2
64404: PUSH
64405: EMPTY
64406: LIST
64407: LIST
64408: PUSH
64409: LD_INT 0
64411: PUSH
64412: LD_INT 2
64414: PUSH
64415: EMPTY
64416: LIST
64417: LIST
64418: PUSH
64419: LD_INT 1
64421: NEG
64422: PUSH
64423: LD_INT 1
64425: PUSH
64426: EMPTY
64427: LIST
64428: LIST
64429: PUSH
64430: LD_INT 1
64432: PUSH
64433: LD_INT 3
64435: PUSH
64436: EMPTY
64437: LIST
64438: LIST
64439: PUSH
64440: LD_INT 0
64442: PUSH
64443: LD_INT 3
64445: PUSH
64446: EMPTY
64447: LIST
64448: LIST
64449: PUSH
64450: LD_INT 1
64452: NEG
64453: PUSH
64454: LD_INT 2
64456: PUSH
64457: EMPTY
64458: LIST
64459: LIST
64460: PUSH
64461: EMPTY
64462: LIST
64463: LIST
64464: LIST
64465: LIST
64466: LIST
64467: LIST
64468: LIST
64469: LIST
64470: LIST
64471: LIST
64472: LIST
64473: LIST
64474: LIST
64475: LIST
64476: LIST
64477: LIST
64478: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
64479: LD_ADDR_VAR 0 12
64483: PUSH
64484: LD_INT 0
64486: PUSH
64487: LD_INT 0
64489: PUSH
64490: EMPTY
64491: LIST
64492: LIST
64493: PUSH
64494: LD_INT 0
64496: PUSH
64497: LD_INT 1
64499: NEG
64500: PUSH
64501: EMPTY
64502: LIST
64503: LIST
64504: PUSH
64505: LD_INT 1
64507: PUSH
64508: LD_INT 0
64510: PUSH
64511: EMPTY
64512: LIST
64513: LIST
64514: PUSH
64515: LD_INT 1
64517: PUSH
64518: LD_INT 1
64520: PUSH
64521: EMPTY
64522: LIST
64523: LIST
64524: PUSH
64525: LD_INT 0
64527: PUSH
64528: LD_INT 1
64530: PUSH
64531: EMPTY
64532: LIST
64533: LIST
64534: PUSH
64535: LD_INT 1
64537: NEG
64538: PUSH
64539: LD_INT 0
64541: PUSH
64542: EMPTY
64543: LIST
64544: LIST
64545: PUSH
64546: LD_INT 1
64548: NEG
64549: PUSH
64550: LD_INT 1
64552: NEG
64553: PUSH
64554: EMPTY
64555: LIST
64556: LIST
64557: PUSH
64558: LD_INT 1
64560: PUSH
64561: LD_INT 1
64563: NEG
64564: PUSH
64565: EMPTY
64566: LIST
64567: LIST
64568: PUSH
64569: LD_INT 2
64571: PUSH
64572: LD_INT 0
64574: PUSH
64575: EMPTY
64576: LIST
64577: LIST
64578: PUSH
64579: LD_INT 2
64581: PUSH
64582: LD_INT 1
64584: PUSH
64585: EMPTY
64586: LIST
64587: LIST
64588: PUSH
64589: LD_INT 1
64591: NEG
64592: PUSH
64593: LD_INT 1
64595: PUSH
64596: EMPTY
64597: LIST
64598: LIST
64599: PUSH
64600: LD_INT 2
64602: NEG
64603: PUSH
64604: LD_INT 0
64606: PUSH
64607: EMPTY
64608: LIST
64609: LIST
64610: PUSH
64611: LD_INT 2
64613: NEG
64614: PUSH
64615: LD_INT 1
64617: NEG
64618: PUSH
64619: EMPTY
64620: LIST
64621: LIST
64622: PUSH
64623: LD_INT 2
64625: NEG
64626: PUSH
64627: LD_INT 1
64629: PUSH
64630: EMPTY
64631: LIST
64632: LIST
64633: PUSH
64634: LD_INT 3
64636: NEG
64637: PUSH
64638: LD_INT 0
64640: PUSH
64641: EMPTY
64642: LIST
64643: LIST
64644: PUSH
64645: LD_INT 3
64647: NEG
64648: PUSH
64649: LD_INT 1
64651: NEG
64652: PUSH
64653: EMPTY
64654: LIST
64655: LIST
64656: PUSH
64657: EMPTY
64658: LIST
64659: LIST
64660: LIST
64661: LIST
64662: LIST
64663: LIST
64664: LIST
64665: LIST
64666: LIST
64667: LIST
64668: LIST
64669: LIST
64670: LIST
64671: LIST
64672: LIST
64673: LIST
64674: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
64675: LD_ADDR_VAR 0 13
64679: PUSH
64680: LD_INT 0
64682: PUSH
64683: LD_INT 0
64685: PUSH
64686: EMPTY
64687: LIST
64688: LIST
64689: PUSH
64690: LD_INT 0
64692: PUSH
64693: LD_INT 1
64695: NEG
64696: PUSH
64697: EMPTY
64698: LIST
64699: LIST
64700: PUSH
64701: LD_INT 1
64703: PUSH
64704: LD_INT 0
64706: PUSH
64707: EMPTY
64708: LIST
64709: LIST
64710: PUSH
64711: LD_INT 1
64713: PUSH
64714: LD_INT 1
64716: PUSH
64717: EMPTY
64718: LIST
64719: LIST
64720: PUSH
64721: LD_INT 0
64723: PUSH
64724: LD_INT 1
64726: PUSH
64727: EMPTY
64728: LIST
64729: LIST
64730: PUSH
64731: LD_INT 1
64733: NEG
64734: PUSH
64735: LD_INT 0
64737: PUSH
64738: EMPTY
64739: LIST
64740: LIST
64741: PUSH
64742: LD_INT 1
64744: NEG
64745: PUSH
64746: LD_INT 1
64748: NEG
64749: PUSH
64750: EMPTY
64751: LIST
64752: LIST
64753: PUSH
64754: LD_INT 1
64756: NEG
64757: PUSH
64758: LD_INT 2
64760: NEG
64761: PUSH
64762: EMPTY
64763: LIST
64764: LIST
64765: PUSH
64766: LD_INT 2
64768: PUSH
64769: LD_INT 1
64771: PUSH
64772: EMPTY
64773: LIST
64774: LIST
64775: PUSH
64776: LD_INT 2
64778: PUSH
64779: LD_INT 2
64781: PUSH
64782: EMPTY
64783: LIST
64784: LIST
64785: PUSH
64786: LD_INT 1
64788: PUSH
64789: LD_INT 2
64791: PUSH
64792: EMPTY
64793: LIST
64794: LIST
64795: PUSH
64796: LD_INT 2
64798: NEG
64799: PUSH
64800: LD_INT 1
64802: NEG
64803: PUSH
64804: EMPTY
64805: LIST
64806: LIST
64807: PUSH
64808: LD_INT 2
64810: NEG
64811: PUSH
64812: LD_INT 2
64814: NEG
64815: PUSH
64816: EMPTY
64817: LIST
64818: LIST
64819: PUSH
64820: LD_INT 2
64822: NEG
64823: PUSH
64824: LD_INT 3
64826: NEG
64827: PUSH
64828: EMPTY
64829: LIST
64830: LIST
64831: PUSH
64832: LD_INT 3
64834: NEG
64835: PUSH
64836: LD_INT 2
64838: NEG
64839: PUSH
64840: EMPTY
64841: LIST
64842: LIST
64843: PUSH
64844: LD_INT 3
64846: NEG
64847: PUSH
64848: LD_INT 3
64850: NEG
64851: PUSH
64852: EMPTY
64853: LIST
64854: LIST
64855: PUSH
64856: EMPTY
64857: LIST
64858: LIST
64859: LIST
64860: LIST
64861: LIST
64862: LIST
64863: LIST
64864: LIST
64865: LIST
64866: LIST
64867: LIST
64868: LIST
64869: LIST
64870: LIST
64871: LIST
64872: LIST
64873: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
64874: LD_ADDR_VAR 0 14
64878: PUSH
64879: LD_INT 0
64881: PUSH
64882: LD_INT 0
64884: PUSH
64885: EMPTY
64886: LIST
64887: LIST
64888: PUSH
64889: LD_INT 0
64891: PUSH
64892: LD_INT 1
64894: NEG
64895: PUSH
64896: EMPTY
64897: LIST
64898: LIST
64899: PUSH
64900: LD_INT 1
64902: PUSH
64903: LD_INT 0
64905: PUSH
64906: EMPTY
64907: LIST
64908: LIST
64909: PUSH
64910: LD_INT 1
64912: PUSH
64913: LD_INT 1
64915: PUSH
64916: EMPTY
64917: LIST
64918: LIST
64919: PUSH
64920: LD_INT 0
64922: PUSH
64923: LD_INT 1
64925: PUSH
64926: EMPTY
64927: LIST
64928: LIST
64929: PUSH
64930: LD_INT 1
64932: NEG
64933: PUSH
64934: LD_INT 0
64936: PUSH
64937: EMPTY
64938: LIST
64939: LIST
64940: PUSH
64941: LD_INT 1
64943: NEG
64944: PUSH
64945: LD_INT 1
64947: NEG
64948: PUSH
64949: EMPTY
64950: LIST
64951: LIST
64952: PUSH
64953: LD_INT 1
64955: NEG
64956: PUSH
64957: LD_INT 2
64959: NEG
64960: PUSH
64961: EMPTY
64962: LIST
64963: LIST
64964: PUSH
64965: LD_INT 0
64967: PUSH
64968: LD_INT 2
64970: NEG
64971: PUSH
64972: EMPTY
64973: LIST
64974: LIST
64975: PUSH
64976: LD_INT 1
64978: PUSH
64979: LD_INT 1
64981: NEG
64982: PUSH
64983: EMPTY
64984: LIST
64985: LIST
64986: PUSH
64987: LD_INT 1
64989: PUSH
64990: LD_INT 2
64992: PUSH
64993: EMPTY
64994: LIST
64995: LIST
64996: PUSH
64997: LD_INT 0
64999: PUSH
65000: LD_INT 2
65002: PUSH
65003: EMPTY
65004: LIST
65005: LIST
65006: PUSH
65007: LD_INT 1
65009: NEG
65010: PUSH
65011: LD_INT 1
65013: PUSH
65014: EMPTY
65015: LIST
65016: LIST
65017: PUSH
65018: LD_INT 1
65020: NEG
65021: PUSH
65022: LD_INT 3
65024: NEG
65025: PUSH
65026: EMPTY
65027: LIST
65028: LIST
65029: PUSH
65030: LD_INT 0
65032: PUSH
65033: LD_INT 3
65035: NEG
65036: PUSH
65037: EMPTY
65038: LIST
65039: LIST
65040: PUSH
65041: LD_INT 1
65043: PUSH
65044: LD_INT 2
65046: NEG
65047: PUSH
65048: EMPTY
65049: LIST
65050: LIST
65051: PUSH
65052: EMPTY
65053: LIST
65054: LIST
65055: LIST
65056: LIST
65057: LIST
65058: LIST
65059: LIST
65060: LIST
65061: LIST
65062: LIST
65063: LIST
65064: LIST
65065: LIST
65066: LIST
65067: LIST
65068: LIST
65069: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
65070: LD_ADDR_VAR 0 15
65074: PUSH
65075: LD_INT 0
65077: PUSH
65078: LD_INT 0
65080: PUSH
65081: EMPTY
65082: LIST
65083: LIST
65084: PUSH
65085: LD_INT 0
65087: PUSH
65088: LD_INT 1
65090: NEG
65091: PUSH
65092: EMPTY
65093: LIST
65094: LIST
65095: PUSH
65096: LD_INT 1
65098: PUSH
65099: LD_INT 0
65101: PUSH
65102: EMPTY
65103: LIST
65104: LIST
65105: PUSH
65106: LD_INT 1
65108: PUSH
65109: LD_INT 1
65111: PUSH
65112: EMPTY
65113: LIST
65114: LIST
65115: PUSH
65116: LD_INT 0
65118: PUSH
65119: LD_INT 1
65121: PUSH
65122: EMPTY
65123: LIST
65124: LIST
65125: PUSH
65126: LD_INT 1
65128: NEG
65129: PUSH
65130: LD_INT 0
65132: PUSH
65133: EMPTY
65134: LIST
65135: LIST
65136: PUSH
65137: LD_INT 1
65139: NEG
65140: PUSH
65141: LD_INT 1
65143: NEG
65144: PUSH
65145: EMPTY
65146: LIST
65147: LIST
65148: PUSH
65149: LD_INT 1
65151: PUSH
65152: LD_INT 1
65154: NEG
65155: PUSH
65156: EMPTY
65157: LIST
65158: LIST
65159: PUSH
65160: LD_INT 2
65162: PUSH
65163: LD_INT 0
65165: PUSH
65166: EMPTY
65167: LIST
65168: LIST
65169: PUSH
65170: LD_INT 2
65172: PUSH
65173: LD_INT 1
65175: PUSH
65176: EMPTY
65177: LIST
65178: LIST
65179: PUSH
65180: LD_INT 1
65182: NEG
65183: PUSH
65184: LD_INT 1
65186: PUSH
65187: EMPTY
65188: LIST
65189: LIST
65190: PUSH
65191: LD_INT 2
65193: NEG
65194: PUSH
65195: LD_INT 0
65197: PUSH
65198: EMPTY
65199: LIST
65200: LIST
65201: PUSH
65202: LD_INT 2
65204: NEG
65205: PUSH
65206: LD_INT 1
65208: NEG
65209: PUSH
65210: EMPTY
65211: LIST
65212: LIST
65213: PUSH
65214: LD_INT 2
65216: PUSH
65217: LD_INT 1
65219: NEG
65220: PUSH
65221: EMPTY
65222: LIST
65223: LIST
65224: PUSH
65225: LD_INT 3
65227: PUSH
65228: LD_INT 0
65230: PUSH
65231: EMPTY
65232: LIST
65233: LIST
65234: PUSH
65235: LD_INT 3
65237: PUSH
65238: LD_INT 1
65240: PUSH
65241: EMPTY
65242: LIST
65243: LIST
65244: PUSH
65245: EMPTY
65246: LIST
65247: LIST
65248: LIST
65249: LIST
65250: LIST
65251: LIST
65252: LIST
65253: LIST
65254: LIST
65255: LIST
65256: LIST
65257: LIST
65258: LIST
65259: LIST
65260: LIST
65261: LIST
65262: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
65263: LD_ADDR_VAR 0 16
65267: PUSH
65268: LD_INT 0
65270: PUSH
65271: LD_INT 0
65273: PUSH
65274: EMPTY
65275: LIST
65276: LIST
65277: PUSH
65278: LD_INT 0
65280: PUSH
65281: LD_INT 1
65283: NEG
65284: PUSH
65285: EMPTY
65286: LIST
65287: LIST
65288: PUSH
65289: LD_INT 1
65291: PUSH
65292: LD_INT 0
65294: PUSH
65295: EMPTY
65296: LIST
65297: LIST
65298: PUSH
65299: LD_INT 1
65301: PUSH
65302: LD_INT 1
65304: PUSH
65305: EMPTY
65306: LIST
65307: LIST
65308: PUSH
65309: LD_INT 0
65311: PUSH
65312: LD_INT 1
65314: PUSH
65315: EMPTY
65316: LIST
65317: LIST
65318: PUSH
65319: LD_INT 1
65321: NEG
65322: PUSH
65323: LD_INT 0
65325: PUSH
65326: EMPTY
65327: LIST
65328: LIST
65329: PUSH
65330: LD_INT 1
65332: NEG
65333: PUSH
65334: LD_INT 1
65336: NEG
65337: PUSH
65338: EMPTY
65339: LIST
65340: LIST
65341: PUSH
65342: LD_INT 1
65344: NEG
65345: PUSH
65346: LD_INT 2
65348: NEG
65349: PUSH
65350: EMPTY
65351: LIST
65352: LIST
65353: PUSH
65354: LD_INT 2
65356: PUSH
65357: LD_INT 1
65359: PUSH
65360: EMPTY
65361: LIST
65362: LIST
65363: PUSH
65364: LD_INT 2
65366: PUSH
65367: LD_INT 2
65369: PUSH
65370: EMPTY
65371: LIST
65372: LIST
65373: PUSH
65374: LD_INT 1
65376: PUSH
65377: LD_INT 2
65379: PUSH
65380: EMPTY
65381: LIST
65382: LIST
65383: PUSH
65384: LD_INT 2
65386: NEG
65387: PUSH
65388: LD_INT 1
65390: NEG
65391: PUSH
65392: EMPTY
65393: LIST
65394: LIST
65395: PUSH
65396: LD_INT 2
65398: NEG
65399: PUSH
65400: LD_INT 2
65402: NEG
65403: PUSH
65404: EMPTY
65405: LIST
65406: LIST
65407: PUSH
65408: LD_INT 3
65410: PUSH
65411: LD_INT 2
65413: PUSH
65414: EMPTY
65415: LIST
65416: LIST
65417: PUSH
65418: LD_INT 3
65420: PUSH
65421: LD_INT 3
65423: PUSH
65424: EMPTY
65425: LIST
65426: LIST
65427: PUSH
65428: LD_INT 2
65430: PUSH
65431: LD_INT 3
65433: PUSH
65434: EMPTY
65435: LIST
65436: LIST
65437: PUSH
65438: EMPTY
65439: LIST
65440: LIST
65441: LIST
65442: LIST
65443: LIST
65444: LIST
65445: LIST
65446: LIST
65447: LIST
65448: LIST
65449: LIST
65450: LIST
65451: LIST
65452: LIST
65453: LIST
65454: LIST
65455: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65456: LD_ADDR_VAR 0 17
65460: PUSH
65461: LD_INT 0
65463: PUSH
65464: LD_INT 0
65466: PUSH
65467: EMPTY
65468: LIST
65469: LIST
65470: PUSH
65471: LD_INT 0
65473: PUSH
65474: LD_INT 1
65476: NEG
65477: PUSH
65478: EMPTY
65479: LIST
65480: LIST
65481: PUSH
65482: LD_INT 1
65484: PUSH
65485: LD_INT 0
65487: PUSH
65488: EMPTY
65489: LIST
65490: LIST
65491: PUSH
65492: LD_INT 1
65494: PUSH
65495: LD_INT 1
65497: PUSH
65498: EMPTY
65499: LIST
65500: LIST
65501: PUSH
65502: LD_INT 0
65504: PUSH
65505: LD_INT 1
65507: PUSH
65508: EMPTY
65509: LIST
65510: LIST
65511: PUSH
65512: LD_INT 1
65514: NEG
65515: PUSH
65516: LD_INT 0
65518: PUSH
65519: EMPTY
65520: LIST
65521: LIST
65522: PUSH
65523: LD_INT 1
65525: NEG
65526: PUSH
65527: LD_INT 1
65529: NEG
65530: PUSH
65531: EMPTY
65532: LIST
65533: LIST
65534: PUSH
65535: LD_INT 1
65537: NEG
65538: PUSH
65539: LD_INT 2
65541: NEG
65542: PUSH
65543: EMPTY
65544: LIST
65545: LIST
65546: PUSH
65547: LD_INT 0
65549: PUSH
65550: LD_INT 2
65552: NEG
65553: PUSH
65554: EMPTY
65555: LIST
65556: LIST
65557: PUSH
65558: LD_INT 1
65560: PUSH
65561: LD_INT 1
65563: NEG
65564: PUSH
65565: EMPTY
65566: LIST
65567: LIST
65568: PUSH
65569: LD_INT 2
65571: PUSH
65572: LD_INT 0
65574: PUSH
65575: EMPTY
65576: LIST
65577: LIST
65578: PUSH
65579: LD_INT 2
65581: PUSH
65582: LD_INT 1
65584: PUSH
65585: EMPTY
65586: LIST
65587: LIST
65588: PUSH
65589: LD_INT 2
65591: PUSH
65592: LD_INT 2
65594: PUSH
65595: EMPTY
65596: LIST
65597: LIST
65598: PUSH
65599: LD_INT 1
65601: PUSH
65602: LD_INT 2
65604: PUSH
65605: EMPTY
65606: LIST
65607: LIST
65608: PUSH
65609: LD_INT 0
65611: PUSH
65612: LD_INT 2
65614: PUSH
65615: EMPTY
65616: LIST
65617: LIST
65618: PUSH
65619: LD_INT 1
65621: NEG
65622: PUSH
65623: LD_INT 1
65625: PUSH
65626: EMPTY
65627: LIST
65628: LIST
65629: PUSH
65630: LD_INT 2
65632: NEG
65633: PUSH
65634: LD_INT 0
65636: PUSH
65637: EMPTY
65638: LIST
65639: LIST
65640: PUSH
65641: LD_INT 2
65643: NEG
65644: PUSH
65645: LD_INT 1
65647: NEG
65648: PUSH
65649: EMPTY
65650: LIST
65651: LIST
65652: PUSH
65653: LD_INT 2
65655: NEG
65656: PUSH
65657: LD_INT 2
65659: NEG
65660: PUSH
65661: EMPTY
65662: LIST
65663: LIST
65664: PUSH
65665: EMPTY
65666: LIST
65667: LIST
65668: LIST
65669: LIST
65670: LIST
65671: LIST
65672: LIST
65673: LIST
65674: LIST
65675: LIST
65676: LIST
65677: LIST
65678: LIST
65679: LIST
65680: LIST
65681: LIST
65682: LIST
65683: LIST
65684: LIST
65685: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65686: LD_ADDR_VAR 0 18
65690: PUSH
65691: LD_INT 0
65693: PUSH
65694: LD_INT 0
65696: PUSH
65697: EMPTY
65698: LIST
65699: LIST
65700: PUSH
65701: LD_INT 0
65703: PUSH
65704: LD_INT 1
65706: NEG
65707: PUSH
65708: EMPTY
65709: LIST
65710: LIST
65711: PUSH
65712: LD_INT 1
65714: PUSH
65715: LD_INT 0
65717: PUSH
65718: EMPTY
65719: LIST
65720: LIST
65721: PUSH
65722: LD_INT 1
65724: PUSH
65725: LD_INT 1
65727: PUSH
65728: EMPTY
65729: LIST
65730: LIST
65731: PUSH
65732: LD_INT 0
65734: PUSH
65735: LD_INT 1
65737: PUSH
65738: EMPTY
65739: LIST
65740: LIST
65741: PUSH
65742: LD_INT 1
65744: NEG
65745: PUSH
65746: LD_INT 0
65748: PUSH
65749: EMPTY
65750: LIST
65751: LIST
65752: PUSH
65753: LD_INT 1
65755: NEG
65756: PUSH
65757: LD_INT 1
65759: NEG
65760: PUSH
65761: EMPTY
65762: LIST
65763: LIST
65764: PUSH
65765: LD_INT 1
65767: NEG
65768: PUSH
65769: LD_INT 2
65771: NEG
65772: PUSH
65773: EMPTY
65774: LIST
65775: LIST
65776: PUSH
65777: LD_INT 0
65779: PUSH
65780: LD_INT 2
65782: NEG
65783: PUSH
65784: EMPTY
65785: LIST
65786: LIST
65787: PUSH
65788: LD_INT 1
65790: PUSH
65791: LD_INT 1
65793: NEG
65794: PUSH
65795: EMPTY
65796: LIST
65797: LIST
65798: PUSH
65799: LD_INT 2
65801: PUSH
65802: LD_INT 0
65804: PUSH
65805: EMPTY
65806: LIST
65807: LIST
65808: PUSH
65809: LD_INT 2
65811: PUSH
65812: LD_INT 1
65814: PUSH
65815: EMPTY
65816: LIST
65817: LIST
65818: PUSH
65819: LD_INT 2
65821: PUSH
65822: LD_INT 2
65824: PUSH
65825: EMPTY
65826: LIST
65827: LIST
65828: PUSH
65829: LD_INT 1
65831: PUSH
65832: LD_INT 2
65834: PUSH
65835: EMPTY
65836: LIST
65837: LIST
65838: PUSH
65839: LD_INT 0
65841: PUSH
65842: LD_INT 2
65844: PUSH
65845: EMPTY
65846: LIST
65847: LIST
65848: PUSH
65849: LD_INT 1
65851: NEG
65852: PUSH
65853: LD_INT 1
65855: PUSH
65856: EMPTY
65857: LIST
65858: LIST
65859: PUSH
65860: LD_INT 2
65862: NEG
65863: PUSH
65864: LD_INT 0
65866: PUSH
65867: EMPTY
65868: LIST
65869: LIST
65870: PUSH
65871: LD_INT 2
65873: NEG
65874: PUSH
65875: LD_INT 1
65877: NEG
65878: PUSH
65879: EMPTY
65880: LIST
65881: LIST
65882: PUSH
65883: LD_INT 2
65885: NEG
65886: PUSH
65887: LD_INT 2
65889: NEG
65890: PUSH
65891: EMPTY
65892: LIST
65893: LIST
65894: PUSH
65895: EMPTY
65896: LIST
65897: LIST
65898: LIST
65899: LIST
65900: LIST
65901: LIST
65902: LIST
65903: LIST
65904: LIST
65905: LIST
65906: LIST
65907: LIST
65908: LIST
65909: LIST
65910: LIST
65911: LIST
65912: LIST
65913: LIST
65914: LIST
65915: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65916: LD_ADDR_VAR 0 19
65920: PUSH
65921: LD_INT 0
65923: PUSH
65924: LD_INT 0
65926: PUSH
65927: EMPTY
65928: LIST
65929: LIST
65930: PUSH
65931: LD_INT 0
65933: PUSH
65934: LD_INT 1
65936: NEG
65937: PUSH
65938: EMPTY
65939: LIST
65940: LIST
65941: PUSH
65942: LD_INT 1
65944: PUSH
65945: LD_INT 0
65947: PUSH
65948: EMPTY
65949: LIST
65950: LIST
65951: PUSH
65952: LD_INT 1
65954: PUSH
65955: LD_INT 1
65957: PUSH
65958: EMPTY
65959: LIST
65960: LIST
65961: PUSH
65962: LD_INT 0
65964: PUSH
65965: LD_INT 1
65967: PUSH
65968: EMPTY
65969: LIST
65970: LIST
65971: PUSH
65972: LD_INT 1
65974: NEG
65975: PUSH
65976: LD_INT 0
65978: PUSH
65979: EMPTY
65980: LIST
65981: LIST
65982: PUSH
65983: LD_INT 1
65985: NEG
65986: PUSH
65987: LD_INT 1
65989: NEG
65990: PUSH
65991: EMPTY
65992: LIST
65993: LIST
65994: PUSH
65995: LD_INT 1
65997: NEG
65998: PUSH
65999: LD_INT 2
66001: NEG
66002: PUSH
66003: EMPTY
66004: LIST
66005: LIST
66006: PUSH
66007: LD_INT 0
66009: PUSH
66010: LD_INT 2
66012: NEG
66013: PUSH
66014: EMPTY
66015: LIST
66016: LIST
66017: PUSH
66018: LD_INT 1
66020: PUSH
66021: LD_INT 1
66023: NEG
66024: PUSH
66025: EMPTY
66026: LIST
66027: LIST
66028: PUSH
66029: LD_INT 2
66031: PUSH
66032: LD_INT 0
66034: PUSH
66035: EMPTY
66036: LIST
66037: LIST
66038: PUSH
66039: LD_INT 2
66041: PUSH
66042: LD_INT 1
66044: PUSH
66045: EMPTY
66046: LIST
66047: LIST
66048: PUSH
66049: LD_INT 2
66051: PUSH
66052: LD_INT 2
66054: PUSH
66055: EMPTY
66056: LIST
66057: LIST
66058: PUSH
66059: LD_INT 1
66061: PUSH
66062: LD_INT 2
66064: PUSH
66065: EMPTY
66066: LIST
66067: LIST
66068: PUSH
66069: LD_INT 0
66071: PUSH
66072: LD_INT 2
66074: PUSH
66075: EMPTY
66076: LIST
66077: LIST
66078: PUSH
66079: LD_INT 1
66081: NEG
66082: PUSH
66083: LD_INT 1
66085: PUSH
66086: EMPTY
66087: LIST
66088: LIST
66089: PUSH
66090: LD_INT 2
66092: NEG
66093: PUSH
66094: LD_INT 0
66096: PUSH
66097: EMPTY
66098: LIST
66099: LIST
66100: PUSH
66101: LD_INT 2
66103: NEG
66104: PUSH
66105: LD_INT 1
66107: NEG
66108: PUSH
66109: EMPTY
66110: LIST
66111: LIST
66112: PUSH
66113: LD_INT 2
66115: NEG
66116: PUSH
66117: LD_INT 2
66119: NEG
66120: PUSH
66121: EMPTY
66122: LIST
66123: LIST
66124: PUSH
66125: EMPTY
66126: LIST
66127: LIST
66128: LIST
66129: LIST
66130: LIST
66131: LIST
66132: LIST
66133: LIST
66134: LIST
66135: LIST
66136: LIST
66137: LIST
66138: LIST
66139: LIST
66140: LIST
66141: LIST
66142: LIST
66143: LIST
66144: LIST
66145: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66146: LD_ADDR_VAR 0 20
66150: PUSH
66151: LD_INT 0
66153: PUSH
66154: LD_INT 0
66156: PUSH
66157: EMPTY
66158: LIST
66159: LIST
66160: PUSH
66161: LD_INT 0
66163: PUSH
66164: LD_INT 1
66166: NEG
66167: PUSH
66168: EMPTY
66169: LIST
66170: LIST
66171: PUSH
66172: LD_INT 1
66174: PUSH
66175: LD_INT 0
66177: PUSH
66178: EMPTY
66179: LIST
66180: LIST
66181: PUSH
66182: LD_INT 1
66184: PUSH
66185: LD_INT 1
66187: PUSH
66188: EMPTY
66189: LIST
66190: LIST
66191: PUSH
66192: LD_INT 0
66194: PUSH
66195: LD_INT 1
66197: PUSH
66198: EMPTY
66199: LIST
66200: LIST
66201: PUSH
66202: LD_INT 1
66204: NEG
66205: PUSH
66206: LD_INT 0
66208: PUSH
66209: EMPTY
66210: LIST
66211: LIST
66212: PUSH
66213: LD_INT 1
66215: NEG
66216: PUSH
66217: LD_INT 1
66219: NEG
66220: PUSH
66221: EMPTY
66222: LIST
66223: LIST
66224: PUSH
66225: LD_INT 1
66227: NEG
66228: PUSH
66229: LD_INT 2
66231: NEG
66232: PUSH
66233: EMPTY
66234: LIST
66235: LIST
66236: PUSH
66237: LD_INT 0
66239: PUSH
66240: LD_INT 2
66242: NEG
66243: PUSH
66244: EMPTY
66245: LIST
66246: LIST
66247: PUSH
66248: LD_INT 1
66250: PUSH
66251: LD_INT 1
66253: NEG
66254: PUSH
66255: EMPTY
66256: LIST
66257: LIST
66258: PUSH
66259: LD_INT 2
66261: PUSH
66262: LD_INT 0
66264: PUSH
66265: EMPTY
66266: LIST
66267: LIST
66268: PUSH
66269: LD_INT 2
66271: PUSH
66272: LD_INT 1
66274: PUSH
66275: EMPTY
66276: LIST
66277: LIST
66278: PUSH
66279: LD_INT 2
66281: PUSH
66282: LD_INT 2
66284: PUSH
66285: EMPTY
66286: LIST
66287: LIST
66288: PUSH
66289: LD_INT 1
66291: PUSH
66292: LD_INT 2
66294: PUSH
66295: EMPTY
66296: LIST
66297: LIST
66298: PUSH
66299: LD_INT 0
66301: PUSH
66302: LD_INT 2
66304: PUSH
66305: EMPTY
66306: LIST
66307: LIST
66308: PUSH
66309: LD_INT 1
66311: NEG
66312: PUSH
66313: LD_INT 1
66315: PUSH
66316: EMPTY
66317: LIST
66318: LIST
66319: PUSH
66320: LD_INT 2
66322: NEG
66323: PUSH
66324: LD_INT 0
66326: PUSH
66327: EMPTY
66328: LIST
66329: LIST
66330: PUSH
66331: LD_INT 2
66333: NEG
66334: PUSH
66335: LD_INT 1
66337: NEG
66338: PUSH
66339: EMPTY
66340: LIST
66341: LIST
66342: PUSH
66343: LD_INT 2
66345: NEG
66346: PUSH
66347: LD_INT 2
66349: NEG
66350: PUSH
66351: EMPTY
66352: LIST
66353: LIST
66354: PUSH
66355: EMPTY
66356: LIST
66357: LIST
66358: LIST
66359: LIST
66360: LIST
66361: LIST
66362: LIST
66363: LIST
66364: LIST
66365: LIST
66366: LIST
66367: LIST
66368: LIST
66369: LIST
66370: LIST
66371: LIST
66372: LIST
66373: LIST
66374: LIST
66375: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66376: LD_ADDR_VAR 0 21
66380: PUSH
66381: LD_INT 0
66383: PUSH
66384: LD_INT 0
66386: PUSH
66387: EMPTY
66388: LIST
66389: LIST
66390: PUSH
66391: LD_INT 0
66393: PUSH
66394: LD_INT 1
66396: NEG
66397: PUSH
66398: EMPTY
66399: LIST
66400: LIST
66401: PUSH
66402: LD_INT 1
66404: PUSH
66405: LD_INT 0
66407: PUSH
66408: EMPTY
66409: LIST
66410: LIST
66411: PUSH
66412: LD_INT 1
66414: PUSH
66415: LD_INT 1
66417: PUSH
66418: EMPTY
66419: LIST
66420: LIST
66421: PUSH
66422: LD_INT 0
66424: PUSH
66425: LD_INT 1
66427: PUSH
66428: EMPTY
66429: LIST
66430: LIST
66431: PUSH
66432: LD_INT 1
66434: NEG
66435: PUSH
66436: LD_INT 0
66438: PUSH
66439: EMPTY
66440: LIST
66441: LIST
66442: PUSH
66443: LD_INT 1
66445: NEG
66446: PUSH
66447: LD_INT 1
66449: NEG
66450: PUSH
66451: EMPTY
66452: LIST
66453: LIST
66454: PUSH
66455: LD_INT 1
66457: NEG
66458: PUSH
66459: LD_INT 2
66461: NEG
66462: PUSH
66463: EMPTY
66464: LIST
66465: LIST
66466: PUSH
66467: LD_INT 0
66469: PUSH
66470: LD_INT 2
66472: NEG
66473: PUSH
66474: EMPTY
66475: LIST
66476: LIST
66477: PUSH
66478: LD_INT 1
66480: PUSH
66481: LD_INT 1
66483: NEG
66484: PUSH
66485: EMPTY
66486: LIST
66487: LIST
66488: PUSH
66489: LD_INT 2
66491: PUSH
66492: LD_INT 0
66494: PUSH
66495: EMPTY
66496: LIST
66497: LIST
66498: PUSH
66499: LD_INT 2
66501: PUSH
66502: LD_INT 1
66504: PUSH
66505: EMPTY
66506: LIST
66507: LIST
66508: PUSH
66509: LD_INT 2
66511: PUSH
66512: LD_INT 2
66514: PUSH
66515: EMPTY
66516: LIST
66517: LIST
66518: PUSH
66519: LD_INT 1
66521: PUSH
66522: LD_INT 2
66524: PUSH
66525: EMPTY
66526: LIST
66527: LIST
66528: PUSH
66529: LD_INT 0
66531: PUSH
66532: LD_INT 2
66534: PUSH
66535: EMPTY
66536: LIST
66537: LIST
66538: PUSH
66539: LD_INT 1
66541: NEG
66542: PUSH
66543: LD_INT 1
66545: PUSH
66546: EMPTY
66547: LIST
66548: LIST
66549: PUSH
66550: LD_INT 2
66552: NEG
66553: PUSH
66554: LD_INT 0
66556: PUSH
66557: EMPTY
66558: LIST
66559: LIST
66560: PUSH
66561: LD_INT 2
66563: NEG
66564: PUSH
66565: LD_INT 1
66567: NEG
66568: PUSH
66569: EMPTY
66570: LIST
66571: LIST
66572: PUSH
66573: LD_INT 2
66575: NEG
66576: PUSH
66577: LD_INT 2
66579: NEG
66580: PUSH
66581: EMPTY
66582: LIST
66583: LIST
66584: PUSH
66585: EMPTY
66586: LIST
66587: LIST
66588: LIST
66589: LIST
66590: LIST
66591: LIST
66592: LIST
66593: LIST
66594: LIST
66595: LIST
66596: LIST
66597: LIST
66598: LIST
66599: LIST
66600: LIST
66601: LIST
66602: LIST
66603: LIST
66604: LIST
66605: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66606: LD_ADDR_VAR 0 22
66610: PUSH
66611: LD_INT 0
66613: PUSH
66614: LD_INT 0
66616: PUSH
66617: EMPTY
66618: LIST
66619: LIST
66620: PUSH
66621: LD_INT 0
66623: PUSH
66624: LD_INT 1
66626: NEG
66627: PUSH
66628: EMPTY
66629: LIST
66630: LIST
66631: PUSH
66632: LD_INT 1
66634: PUSH
66635: LD_INT 0
66637: PUSH
66638: EMPTY
66639: LIST
66640: LIST
66641: PUSH
66642: LD_INT 1
66644: PUSH
66645: LD_INT 1
66647: PUSH
66648: EMPTY
66649: LIST
66650: LIST
66651: PUSH
66652: LD_INT 0
66654: PUSH
66655: LD_INT 1
66657: PUSH
66658: EMPTY
66659: LIST
66660: LIST
66661: PUSH
66662: LD_INT 1
66664: NEG
66665: PUSH
66666: LD_INT 0
66668: PUSH
66669: EMPTY
66670: LIST
66671: LIST
66672: PUSH
66673: LD_INT 1
66675: NEG
66676: PUSH
66677: LD_INT 1
66679: NEG
66680: PUSH
66681: EMPTY
66682: LIST
66683: LIST
66684: PUSH
66685: LD_INT 1
66687: NEG
66688: PUSH
66689: LD_INT 2
66691: NEG
66692: PUSH
66693: EMPTY
66694: LIST
66695: LIST
66696: PUSH
66697: LD_INT 0
66699: PUSH
66700: LD_INT 2
66702: NEG
66703: PUSH
66704: EMPTY
66705: LIST
66706: LIST
66707: PUSH
66708: LD_INT 1
66710: PUSH
66711: LD_INT 1
66713: NEG
66714: PUSH
66715: EMPTY
66716: LIST
66717: LIST
66718: PUSH
66719: LD_INT 2
66721: PUSH
66722: LD_INT 0
66724: PUSH
66725: EMPTY
66726: LIST
66727: LIST
66728: PUSH
66729: LD_INT 2
66731: PUSH
66732: LD_INT 1
66734: PUSH
66735: EMPTY
66736: LIST
66737: LIST
66738: PUSH
66739: LD_INT 2
66741: PUSH
66742: LD_INT 2
66744: PUSH
66745: EMPTY
66746: LIST
66747: LIST
66748: PUSH
66749: LD_INT 1
66751: PUSH
66752: LD_INT 2
66754: PUSH
66755: EMPTY
66756: LIST
66757: LIST
66758: PUSH
66759: LD_INT 0
66761: PUSH
66762: LD_INT 2
66764: PUSH
66765: EMPTY
66766: LIST
66767: LIST
66768: PUSH
66769: LD_INT 1
66771: NEG
66772: PUSH
66773: LD_INT 1
66775: PUSH
66776: EMPTY
66777: LIST
66778: LIST
66779: PUSH
66780: LD_INT 2
66782: NEG
66783: PUSH
66784: LD_INT 0
66786: PUSH
66787: EMPTY
66788: LIST
66789: LIST
66790: PUSH
66791: LD_INT 2
66793: NEG
66794: PUSH
66795: LD_INT 1
66797: NEG
66798: PUSH
66799: EMPTY
66800: LIST
66801: LIST
66802: PUSH
66803: LD_INT 2
66805: NEG
66806: PUSH
66807: LD_INT 2
66809: NEG
66810: PUSH
66811: EMPTY
66812: LIST
66813: LIST
66814: PUSH
66815: EMPTY
66816: LIST
66817: LIST
66818: LIST
66819: LIST
66820: LIST
66821: LIST
66822: LIST
66823: LIST
66824: LIST
66825: LIST
66826: LIST
66827: LIST
66828: LIST
66829: LIST
66830: LIST
66831: LIST
66832: LIST
66833: LIST
66834: LIST
66835: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
66836: LD_ADDR_VAR 0 23
66840: PUSH
66841: LD_INT 0
66843: PUSH
66844: LD_INT 0
66846: PUSH
66847: EMPTY
66848: LIST
66849: LIST
66850: PUSH
66851: LD_INT 0
66853: PUSH
66854: LD_INT 1
66856: NEG
66857: PUSH
66858: EMPTY
66859: LIST
66860: LIST
66861: PUSH
66862: LD_INT 1
66864: PUSH
66865: LD_INT 0
66867: PUSH
66868: EMPTY
66869: LIST
66870: LIST
66871: PUSH
66872: LD_INT 1
66874: PUSH
66875: LD_INT 1
66877: PUSH
66878: EMPTY
66879: LIST
66880: LIST
66881: PUSH
66882: LD_INT 0
66884: PUSH
66885: LD_INT 1
66887: PUSH
66888: EMPTY
66889: LIST
66890: LIST
66891: PUSH
66892: LD_INT 1
66894: NEG
66895: PUSH
66896: LD_INT 0
66898: PUSH
66899: EMPTY
66900: LIST
66901: LIST
66902: PUSH
66903: LD_INT 1
66905: NEG
66906: PUSH
66907: LD_INT 1
66909: NEG
66910: PUSH
66911: EMPTY
66912: LIST
66913: LIST
66914: PUSH
66915: LD_INT 1
66917: NEG
66918: PUSH
66919: LD_INT 2
66921: NEG
66922: PUSH
66923: EMPTY
66924: LIST
66925: LIST
66926: PUSH
66927: LD_INT 0
66929: PUSH
66930: LD_INT 2
66932: NEG
66933: PUSH
66934: EMPTY
66935: LIST
66936: LIST
66937: PUSH
66938: LD_INT 1
66940: PUSH
66941: LD_INT 1
66943: NEG
66944: PUSH
66945: EMPTY
66946: LIST
66947: LIST
66948: PUSH
66949: LD_INT 2
66951: PUSH
66952: LD_INT 0
66954: PUSH
66955: EMPTY
66956: LIST
66957: LIST
66958: PUSH
66959: LD_INT 2
66961: PUSH
66962: LD_INT 1
66964: PUSH
66965: EMPTY
66966: LIST
66967: LIST
66968: PUSH
66969: LD_INT 2
66971: PUSH
66972: LD_INT 2
66974: PUSH
66975: EMPTY
66976: LIST
66977: LIST
66978: PUSH
66979: LD_INT 1
66981: PUSH
66982: LD_INT 2
66984: PUSH
66985: EMPTY
66986: LIST
66987: LIST
66988: PUSH
66989: LD_INT 0
66991: PUSH
66992: LD_INT 2
66994: PUSH
66995: EMPTY
66996: LIST
66997: LIST
66998: PUSH
66999: LD_INT 1
67001: NEG
67002: PUSH
67003: LD_INT 1
67005: PUSH
67006: EMPTY
67007: LIST
67008: LIST
67009: PUSH
67010: LD_INT 2
67012: NEG
67013: PUSH
67014: LD_INT 0
67016: PUSH
67017: EMPTY
67018: LIST
67019: LIST
67020: PUSH
67021: LD_INT 2
67023: NEG
67024: PUSH
67025: LD_INT 1
67027: NEG
67028: PUSH
67029: EMPTY
67030: LIST
67031: LIST
67032: PUSH
67033: LD_INT 2
67035: NEG
67036: PUSH
67037: LD_INT 2
67039: NEG
67040: PUSH
67041: EMPTY
67042: LIST
67043: LIST
67044: PUSH
67045: LD_INT 2
67047: NEG
67048: PUSH
67049: LD_INT 3
67051: NEG
67052: PUSH
67053: EMPTY
67054: LIST
67055: LIST
67056: PUSH
67057: LD_INT 1
67059: NEG
67060: PUSH
67061: LD_INT 3
67063: NEG
67064: PUSH
67065: EMPTY
67066: LIST
67067: LIST
67068: PUSH
67069: LD_INT 1
67071: PUSH
67072: LD_INT 2
67074: NEG
67075: PUSH
67076: EMPTY
67077: LIST
67078: LIST
67079: PUSH
67080: LD_INT 2
67082: PUSH
67083: LD_INT 1
67085: NEG
67086: PUSH
67087: EMPTY
67088: LIST
67089: LIST
67090: PUSH
67091: EMPTY
67092: LIST
67093: LIST
67094: LIST
67095: LIST
67096: LIST
67097: LIST
67098: LIST
67099: LIST
67100: LIST
67101: LIST
67102: LIST
67103: LIST
67104: LIST
67105: LIST
67106: LIST
67107: LIST
67108: LIST
67109: LIST
67110: LIST
67111: LIST
67112: LIST
67113: LIST
67114: LIST
67115: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
67116: LD_ADDR_VAR 0 24
67120: PUSH
67121: LD_INT 0
67123: PUSH
67124: LD_INT 0
67126: PUSH
67127: EMPTY
67128: LIST
67129: LIST
67130: PUSH
67131: LD_INT 0
67133: PUSH
67134: LD_INT 1
67136: NEG
67137: PUSH
67138: EMPTY
67139: LIST
67140: LIST
67141: PUSH
67142: LD_INT 1
67144: PUSH
67145: LD_INT 0
67147: PUSH
67148: EMPTY
67149: LIST
67150: LIST
67151: PUSH
67152: LD_INT 1
67154: PUSH
67155: LD_INT 1
67157: PUSH
67158: EMPTY
67159: LIST
67160: LIST
67161: PUSH
67162: LD_INT 0
67164: PUSH
67165: LD_INT 1
67167: PUSH
67168: EMPTY
67169: LIST
67170: LIST
67171: PUSH
67172: LD_INT 1
67174: NEG
67175: PUSH
67176: LD_INT 0
67178: PUSH
67179: EMPTY
67180: LIST
67181: LIST
67182: PUSH
67183: LD_INT 1
67185: NEG
67186: PUSH
67187: LD_INT 1
67189: NEG
67190: PUSH
67191: EMPTY
67192: LIST
67193: LIST
67194: PUSH
67195: LD_INT 1
67197: NEG
67198: PUSH
67199: LD_INT 2
67201: NEG
67202: PUSH
67203: EMPTY
67204: LIST
67205: LIST
67206: PUSH
67207: LD_INT 0
67209: PUSH
67210: LD_INT 2
67212: NEG
67213: PUSH
67214: EMPTY
67215: LIST
67216: LIST
67217: PUSH
67218: LD_INT 1
67220: PUSH
67221: LD_INT 1
67223: NEG
67224: PUSH
67225: EMPTY
67226: LIST
67227: LIST
67228: PUSH
67229: LD_INT 2
67231: PUSH
67232: LD_INT 0
67234: PUSH
67235: EMPTY
67236: LIST
67237: LIST
67238: PUSH
67239: LD_INT 2
67241: PUSH
67242: LD_INT 1
67244: PUSH
67245: EMPTY
67246: LIST
67247: LIST
67248: PUSH
67249: LD_INT 2
67251: PUSH
67252: LD_INT 2
67254: PUSH
67255: EMPTY
67256: LIST
67257: LIST
67258: PUSH
67259: LD_INT 1
67261: PUSH
67262: LD_INT 2
67264: PUSH
67265: EMPTY
67266: LIST
67267: LIST
67268: PUSH
67269: LD_INT 0
67271: PUSH
67272: LD_INT 2
67274: PUSH
67275: EMPTY
67276: LIST
67277: LIST
67278: PUSH
67279: LD_INT 1
67281: NEG
67282: PUSH
67283: LD_INT 1
67285: PUSH
67286: EMPTY
67287: LIST
67288: LIST
67289: PUSH
67290: LD_INT 2
67292: NEG
67293: PUSH
67294: LD_INT 0
67296: PUSH
67297: EMPTY
67298: LIST
67299: LIST
67300: PUSH
67301: LD_INT 2
67303: NEG
67304: PUSH
67305: LD_INT 1
67307: NEG
67308: PUSH
67309: EMPTY
67310: LIST
67311: LIST
67312: PUSH
67313: LD_INT 2
67315: NEG
67316: PUSH
67317: LD_INT 2
67319: NEG
67320: PUSH
67321: EMPTY
67322: LIST
67323: LIST
67324: PUSH
67325: LD_INT 1
67327: PUSH
67328: LD_INT 2
67330: NEG
67331: PUSH
67332: EMPTY
67333: LIST
67334: LIST
67335: PUSH
67336: LD_INT 2
67338: PUSH
67339: LD_INT 1
67341: NEG
67342: PUSH
67343: EMPTY
67344: LIST
67345: LIST
67346: PUSH
67347: LD_INT 3
67349: PUSH
67350: LD_INT 1
67352: PUSH
67353: EMPTY
67354: LIST
67355: LIST
67356: PUSH
67357: LD_INT 3
67359: PUSH
67360: LD_INT 2
67362: PUSH
67363: EMPTY
67364: LIST
67365: LIST
67366: PUSH
67367: EMPTY
67368: LIST
67369: LIST
67370: LIST
67371: LIST
67372: LIST
67373: LIST
67374: LIST
67375: LIST
67376: LIST
67377: LIST
67378: LIST
67379: LIST
67380: LIST
67381: LIST
67382: LIST
67383: LIST
67384: LIST
67385: LIST
67386: LIST
67387: LIST
67388: LIST
67389: LIST
67390: LIST
67391: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
67392: LD_ADDR_VAR 0 25
67396: PUSH
67397: LD_INT 0
67399: PUSH
67400: LD_INT 0
67402: PUSH
67403: EMPTY
67404: LIST
67405: LIST
67406: PUSH
67407: LD_INT 0
67409: PUSH
67410: LD_INT 1
67412: NEG
67413: PUSH
67414: EMPTY
67415: LIST
67416: LIST
67417: PUSH
67418: LD_INT 1
67420: PUSH
67421: LD_INT 0
67423: PUSH
67424: EMPTY
67425: LIST
67426: LIST
67427: PUSH
67428: LD_INT 1
67430: PUSH
67431: LD_INT 1
67433: PUSH
67434: EMPTY
67435: LIST
67436: LIST
67437: PUSH
67438: LD_INT 0
67440: PUSH
67441: LD_INT 1
67443: PUSH
67444: EMPTY
67445: LIST
67446: LIST
67447: PUSH
67448: LD_INT 1
67450: NEG
67451: PUSH
67452: LD_INT 0
67454: PUSH
67455: EMPTY
67456: LIST
67457: LIST
67458: PUSH
67459: LD_INT 1
67461: NEG
67462: PUSH
67463: LD_INT 1
67465: NEG
67466: PUSH
67467: EMPTY
67468: LIST
67469: LIST
67470: PUSH
67471: LD_INT 1
67473: NEG
67474: PUSH
67475: LD_INT 2
67477: NEG
67478: PUSH
67479: EMPTY
67480: LIST
67481: LIST
67482: PUSH
67483: LD_INT 0
67485: PUSH
67486: LD_INT 2
67488: NEG
67489: PUSH
67490: EMPTY
67491: LIST
67492: LIST
67493: PUSH
67494: LD_INT 1
67496: PUSH
67497: LD_INT 1
67499: NEG
67500: PUSH
67501: EMPTY
67502: LIST
67503: LIST
67504: PUSH
67505: LD_INT 2
67507: PUSH
67508: LD_INT 0
67510: PUSH
67511: EMPTY
67512: LIST
67513: LIST
67514: PUSH
67515: LD_INT 2
67517: PUSH
67518: LD_INT 1
67520: PUSH
67521: EMPTY
67522: LIST
67523: LIST
67524: PUSH
67525: LD_INT 2
67527: PUSH
67528: LD_INT 2
67530: PUSH
67531: EMPTY
67532: LIST
67533: LIST
67534: PUSH
67535: LD_INT 1
67537: PUSH
67538: LD_INT 2
67540: PUSH
67541: EMPTY
67542: LIST
67543: LIST
67544: PUSH
67545: LD_INT 0
67547: PUSH
67548: LD_INT 2
67550: PUSH
67551: EMPTY
67552: LIST
67553: LIST
67554: PUSH
67555: LD_INT 1
67557: NEG
67558: PUSH
67559: LD_INT 1
67561: PUSH
67562: EMPTY
67563: LIST
67564: LIST
67565: PUSH
67566: LD_INT 2
67568: NEG
67569: PUSH
67570: LD_INT 0
67572: PUSH
67573: EMPTY
67574: LIST
67575: LIST
67576: PUSH
67577: LD_INT 2
67579: NEG
67580: PUSH
67581: LD_INT 1
67583: NEG
67584: PUSH
67585: EMPTY
67586: LIST
67587: LIST
67588: PUSH
67589: LD_INT 2
67591: NEG
67592: PUSH
67593: LD_INT 2
67595: NEG
67596: PUSH
67597: EMPTY
67598: LIST
67599: LIST
67600: PUSH
67601: LD_INT 3
67603: PUSH
67604: LD_INT 1
67606: PUSH
67607: EMPTY
67608: LIST
67609: LIST
67610: PUSH
67611: LD_INT 3
67613: PUSH
67614: LD_INT 2
67616: PUSH
67617: EMPTY
67618: LIST
67619: LIST
67620: PUSH
67621: LD_INT 2
67623: PUSH
67624: LD_INT 3
67626: PUSH
67627: EMPTY
67628: LIST
67629: LIST
67630: PUSH
67631: LD_INT 1
67633: PUSH
67634: LD_INT 3
67636: PUSH
67637: EMPTY
67638: LIST
67639: LIST
67640: PUSH
67641: EMPTY
67642: LIST
67643: LIST
67644: LIST
67645: LIST
67646: LIST
67647: LIST
67648: LIST
67649: LIST
67650: LIST
67651: LIST
67652: LIST
67653: LIST
67654: LIST
67655: LIST
67656: LIST
67657: LIST
67658: LIST
67659: LIST
67660: LIST
67661: LIST
67662: LIST
67663: LIST
67664: LIST
67665: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
67666: LD_ADDR_VAR 0 26
67670: PUSH
67671: LD_INT 0
67673: PUSH
67674: LD_INT 0
67676: PUSH
67677: EMPTY
67678: LIST
67679: LIST
67680: PUSH
67681: LD_INT 0
67683: PUSH
67684: LD_INT 1
67686: NEG
67687: PUSH
67688: EMPTY
67689: LIST
67690: LIST
67691: PUSH
67692: LD_INT 1
67694: PUSH
67695: LD_INT 0
67697: PUSH
67698: EMPTY
67699: LIST
67700: LIST
67701: PUSH
67702: LD_INT 1
67704: PUSH
67705: LD_INT 1
67707: PUSH
67708: EMPTY
67709: LIST
67710: LIST
67711: PUSH
67712: LD_INT 0
67714: PUSH
67715: LD_INT 1
67717: PUSH
67718: EMPTY
67719: LIST
67720: LIST
67721: PUSH
67722: LD_INT 1
67724: NEG
67725: PUSH
67726: LD_INT 0
67728: PUSH
67729: EMPTY
67730: LIST
67731: LIST
67732: PUSH
67733: LD_INT 1
67735: NEG
67736: PUSH
67737: LD_INT 1
67739: NEG
67740: PUSH
67741: EMPTY
67742: LIST
67743: LIST
67744: PUSH
67745: LD_INT 1
67747: NEG
67748: PUSH
67749: LD_INT 2
67751: NEG
67752: PUSH
67753: EMPTY
67754: LIST
67755: LIST
67756: PUSH
67757: LD_INT 0
67759: PUSH
67760: LD_INT 2
67762: NEG
67763: PUSH
67764: EMPTY
67765: LIST
67766: LIST
67767: PUSH
67768: LD_INT 1
67770: PUSH
67771: LD_INT 1
67773: NEG
67774: PUSH
67775: EMPTY
67776: LIST
67777: LIST
67778: PUSH
67779: LD_INT 2
67781: PUSH
67782: LD_INT 0
67784: PUSH
67785: EMPTY
67786: LIST
67787: LIST
67788: PUSH
67789: LD_INT 2
67791: PUSH
67792: LD_INT 1
67794: PUSH
67795: EMPTY
67796: LIST
67797: LIST
67798: PUSH
67799: LD_INT 2
67801: PUSH
67802: LD_INT 2
67804: PUSH
67805: EMPTY
67806: LIST
67807: LIST
67808: PUSH
67809: LD_INT 1
67811: PUSH
67812: LD_INT 2
67814: PUSH
67815: EMPTY
67816: LIST
67817: LIST
67818: PUSH
67819: LD_INT 0
67821: PUSH
67822: LD_INT 2
67824: PUSH
67825: EMPTY
67826: LIST
67827: LIST
67828: PUSH
67829: LD_INT 1
67831: NEG
67832: PUSH
67833: LD_INT 1
67835: PUSH
67836: EMPTY
67837: LIST
67838: LIST
67839: PUSH
67840: LD_INT 2
67842: NEG
67843: PUSH
67844: LD_INT 0
67846: PUSH
67847: EMPTY
67848: LIST
67849: LIST
67850: PUSH
67851: LD_INT 2
67853: NEG
67854: PUSH
67855: LD_INT 1
67857: NEG
67858: PUSH
67859: EMPTY
67860: LIST
67861: LIST
67862: PUSH
67863: LD_INT 2
67865: NEG
67866: PUSH
67867: LD_INT 2
67869: NEG
67870: PUSH
67871: EMPTY
67872: LIST
67873: LIST
67874: PUSH
67875: LD_INT 2
67877: PUSH
67878: LD_INT 3
67880: PUSH
67881: EMPTY
67882: LIST
67883: LIST
67884: PUSH
67885: LD_INT 1
67887: PUSH
67888: LD_INT 3
67890: PUSH
67891: EMPTY
67892: LIST
67893: LIST
67894: PUSH
67895: LD_INT 1
67897: NEG
67898: PUSH
67899: LD_INT 2
67901: PUSH
67902: EMPTY
67903: LIST
67904: LIST
67905: PUSH
67906: LD_INT 2
67908: NEG
67909: PUSH
67910: LD_INT 1
67912: PUSH
67913: EMPTY
67914: LIST
67915: LIST
67916: PUSH
67917: EMPTY
67918: LIST
67919: LIST
67920: LIST
67921: LIST
67922: LIST
67923: LIST
67924: LIST
67925: LIST
67926: LIST
67927: LIST
67928: LIST
67929: LIST
67930: LIST
67931: LIST
67932: LIST
67933: LIST
67934: LIST
67935: LIST
67936: LIST
67937: LIST
67938: LIST
67939: LIST
67940: LIST
67941: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
67942: LD_ADDR_VAR 0 27
67946: PUSH
67947: LD_INT 0
67949: PUSH
67950: LD_INT 0
67952: PUSH
67953: EMPTY
67954: LIST
67955: LIST
67956: PUSH
67957: LD_INT 0
67959: PUSH
67960: LD_INT 1
67962: NEG
67963: PUSH
67964: EMPTY
67965: LIST
67966: LIST
67967: PUSH
67968: LD_INT 1
67970: PUSH
67971: LD_INT 0
67973: PUSH
67974: EMPTY
67975: LIST
67976: LIST
67977: PUSH
67978: LD_INT 1
67980: PUSH
67981: LD_INT 1
67983: PUSH
67984: EMPTY
67985: LIST
67986: LIST
67987: PUSH
67988: LD_INT 0
67990: PUSH
67991: LD_INT 1
67993: PUSH
67994: EMPTY
67995: LIST
67996: LIST
67997: PUSH
67998: LD_INT 1
68000: NEG
68001: PUSH
68002: LD_INT 0
68004: PUSH
68005: EMPTY
68006: LIST
68007: LIST
68008: PUSH
68009: LD_INT 1
68011: NEG
68012: PUSH
68013: LD_INT 1
68015: NEG
68016: PUSH
68017: EMPTY
68018: LIST
68019: LIST
68020: PUSH
68021: LD_INT 1
68023: NEG
68024: PUSH
68025: LD_INT 2
68027: NEG
68028: PUSH
68029: EMPTY
68030: LIST
68031: LIST
68032: PUSH
68033: LD_INT 0
68035: PUSH
68036: LD_INT 2
68038: NEG
68039: PUSH
68040: EMPTY
68041: LIST
68042: LIST
68043: PUSH
68044: LD_INT 1
68046: PUSH
68047: LD_INT 1
68049: NEG
68050: PUSH
68051: EMPTY
68052: LIST
68053: LIST
68054: PUSH
68055: LD_INT 2
68057: PUSH
68058: LD_INT 0
68060: PUSH
68061: EMPTY
68062: LIST
68063: LIST
68064: PUSH
68065: LD_INT 2
68067: PUSH
68068: LD_INT 1
68070: PUSH
68071: EMPTY
68072: LIST
68073: LIST
68074: PUSH
68075: LD_INT 2
68077: PUSH
68078: LD_INT 2
68080: PUSH
68081: EMPTY
68082: LIST
68083: LIST
68084: PUSH
68085: LD_INT 1
68087: PUSH
68088: LD_INT 2
68090: PUSH
68091: EMPTY
68092: LIST
68093: LIST
68094: PUSH
68095: LD_INT 0
68097: PUSH
68098: LD_INT 2
68100: PUSH
68101: EMPTY
68102: LIST
68103: LIST
68104: PUSH
68105: LD_INT 1
68107: NEG
68108: PUSH
68109: LD_INT 1
68111: PUSH
68112: EMPTY
68113: LIST
68114: LIST
68115: PUSH
68116: LD_INT 2
68118: NEG
68119: PUSH
68120: LD_INT 0
68122: PUSH
68123: EMPTY
68124: LIST
68125: LIST
68126: PUSH
68127: LD_INT 2
68129: NEG
68130: PUSH
68131: LD_INT 1
68133: NEG
68134: PUSH
68135: EMPTY
68136: LIST
68137: LIST
68138: PUSH
68139: LD_INT 2
68141: NEG
68142: PUSH
68143: LD_INT 2
68145: NEG
68146: PUSH
68147: EMPTY
68148: LIST
68149: LIST
68150: PUSH
68151: LD_INT 1
68153: NEG
68154: PUSH
68155: LD_INT 2
68157: PUSH
68158: EMPTY
68159: LIST
68160: LIST
68161: PUSH
68162: LD_INT 2
68164: NEG
68165: PUSH
68166: LD_INT 1
68168: PUSH
68169: EMPTY
68170: LIST
68171: LIST
68172: PUSH
68173: LD_INT 3
68175: NEG
68176: PUSH
68177: LD_INT 1
68179: NEG
68180: PUSH
68181: EMPTY
68182: LIST
68183: LIST
68184: PUSH
68185: LD_INT 3
68187: NEG
68188: PUSH
68189: LD_INT 2
68191: NEG
68192: PUSH
68193: EMPTY
68194: LIST
68195: LIST
68196: PUSH
68197: EMPTY
68198: LIST
68199: LIST
68200: LIST
68201: LIST
68202: LIST
68203: LIST
68204: LIST
68205: LIST
68206: LIST
68207: LIST
68208: LIST
68209: LIST
68210: LIST
68211: LIST
68212: LIST
68213: LIST
68214: LIST
68215: LIST
68216: LIST
68217: LIST
68218: LIST
68219: LIST
68220: LIST
68221: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
68222: LD_ADDR_VAR 0 28
68226: PUSH
68227: LD_INT 0
68229: PUSH
68230: LD_INT 0
68232: PUSH
68233: EMPTY
68234: LIST
68235: LIST
68236: PUSH
68237: LD_INT 0
68239: PUSH
68240: LD_INT 1
68242: NEG
68243: PUSH
68244: EMPTY
68245: LIST
68246: LIST
68247: PUSH
68248: LD_INT 1
68250: PUSH
68251: LD_INT 0
68253: PUSH
68254: EMPTY
68255: LIST
68256: LIST
68257: PUSH
68258: LD_INT 1
68260: PUSH
68261: LD_INT 1
68263: PUSH
68264: EMPTY
68265: LIST
68266: LIST
68267: PUSH
68268: LD_INT 0
68270: PUSH
68271: LD_INT 1
68273: PUSH
68274: EMPTY
68275: LIST
68276: LIST
68277: PUSH
68278: LD_INT 1
68280: NEG
68281: PUSH
68282: LD_INT 0
68284: PUSH
68285: EMPTY
68286: LIST
68287: LIST
68288: PUSH
68289: LD_INT 1
68291: NEG
68292: PUSH
68293: LD_INT 1
68295: NEG
68296: PUSH
68297: EMPTY
68298: LIST
68299: LIST
68300: PUSH
68301: LD_INT 1
68303: NEG
68304: PUSH
68305: LD_INT 2
68307: NEG
68308: PUSH
68309: EMPTY
68310: LIST
68311: LIST
68312: PUSH
68313: LD_INT 0
68315: PUSH
68316: LD_INT 2
68318: NEG
68319: PUSH
68320: EMPTY
68321: LIST
68322: LIST
68323: PUSH
68324: LD_INT 1
68326: PUSH
68327: LD_INT 1
68329: NEG
68330: PUSH
68331: EMPTY
68332: LIST
68333: LIST
68334: PUSH
68335: LD_INT 2
68337: PUSH
68338: LD_INT 0
68340: PUSH
68341: EMPTY
68342: LIST
68343: LIST
68344: PUSH
68345: LD_INT 2
68347: PUSH
68348: LD_INT 1
68350: PUSH
68351: EMPTY
68352: LIST
68353: LIST
68354: PUSH
68355: LD_INT 2
68357: PUSH
68358: LD_INT 2
68360: PUSH
68361: EMPTY
68362: LIST
68363: LIST
68364: PUSH
68365: LD_INT 1
68367: PUSH
68368: LD_INT 2
68370: PUSH
68371: EMPTY
68372: LIST
68373: LIST
68374: PUSH
68375: LD_INT 0
68377: PUSH
68378: LD_INT 2
68380: PUSH
68381: EMPTY
68382: LIST
68383: LIST
68384: PUSH
68385: LD_INT 1
68387: NEG
68388: PUSH
68389: LD_INT 1
68391: PUSH
68392: EMPTY
68393: LIST
68394: LIST
68395: PUSH
68396: LD_INT 2
68398: NEG
68399: PUSH
68400: LD_INT 0
68402: PUSH
68403: EMPTY
68404: LIST
68405: LIST
68406: PUSH
68407: LD_INT 2
68409: NEG
68410: PUSH
68411: LD_INT 1
68413: NEG
68414: PUSH
68415: EMPTY
68416: LIST
68417: LIST
68418: PUSH
68419: LD_INT 2
68421: NEG
68422: PUSH
68423: LD_INT 2
68425: NEG
68426: PUSH
68427: EMPTY
68428: LIST
68429: LIST
68430: PUSH
68431: LD_INT 2
68433: NEG
68434: PUSH
68435: LD_INT 3
68437: NEG
68438: PUSH
68439: EMPTY
68440: LIST
68441: LIST
68442: PUSH
68443: LD_INT 1
68445: NEG
68446: PUSH
68447: LD_INT 3
68449: NEG
68450: PUSH
68451: EMPTY
68452: LIST
68453: LIST
68454: PUSH
68455: LD_INT 3
68457: NEG
68458: PUSH
68459: LD_INT 1
68461: NEG
68462: PUSH
68463: EMPTY
68464: LIST
68465: LIST
68466: PUSH
68467: LD_INT 3
68469: NEG
68470: PUSH
68471: LD_INT 2
68473: NEG
68474: PUSH
68475: EMPTY
68476: LIST
68477: LIST
68478: PUSH
68479: EMPTY
68480: LIST
68481: LIST
68482: LIST
68483: LIST
68484: LIST
68485: LIST
68486: LIST
68487: LIST
68488: LIST
68489: LIST
68490: LIST
68491: LIST
68492: LIST
68493: LIST
68494: LIST
68495: LIST
68496: LIST
68497: LIST
68498: LIST
68499: LIST
68500: LIST
68501: LIST
68502: LIST
68503: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68504: LD_ADDR_VAR 0 29
68508: PUSH
68509: LD_INT 0
68511: PUSH
68512: LD_INT 0
68514: PUSH
68515: EMPTY
68516: LIST
68517: LIST
68518: PUSH
68519: LD_INT 0
68521: PUSH
68522: LD_INT 1
68524: NEG
68525: PUSH
68526: EMPTY
68527: LIST
68528: LIST
68529: PUSH
68530: LD_INT 1
68532: PUSH
68533: LD_INT 0
68535: PUSH
68536: EMPTY
68537: LIST
68538: LIST
68539: PUSH
68540: LD_INT 1
68542: PUSH
68543: LD_INT 1
68545: PUSH
68546: EMPTY
68547: LIST
68548: LIST
68549: PUSH
68550: LD_INT 0
68552: PUSH
68553: LD_INT 1
68555: PUSH
68556: EMPTY
68557: LIST
68558: LIST
68559: PUSH
68560: LD_INT 1
68562: NEG
68563: PUSH
68564: LD_INT 0
68566: PUSH
68567: EMPTY
68568: LIST
68569: LIST
68570: PUSH
68571: LD_INT 1
68573: NEG
68574: PUSH
68575: LD_INT 1
68577: NEG
68578: PUSH
68579: EMPTY
68580: LIST
68581: LIST
68582: PUSH
68583: LD_INT 1
68585: NEG
68586: PUSH
68587: LD_INT 2
68589: NEG
68590: PUSH
68591: EMPTY
68592: LIST
68593: LIST
68594: PUSH
68595: LD_INT 0
68597: PUSH
68598: LD_INT 2
68600: NEG
68601: PUSH
68602: EMPTY
68603: LIST
68604: LIST
68605: PUSH
68606: LD_INT 1
68608: PUSH
68609: LD_INT 1
68611: NEG
68612: PUSH
68613: EMPTY
68614: LIST
68615: LIST
68616: PUSH
68617: LD_INT 2
68619: PUSH
68620: LD_INT 0
68622: PUSH
68623: EMPTY
68624: LIST
68625: LIST
68626: PUSH
68627: LD_INT 2
68629: PUSH
68630: LD_INT 1
68632: PUSH
68633: EMPTY
68634: LIST
68635: LIST
68636: PUSH
68637: LD_INT 1
68639: PUSH
68640: LD_INT 2
68642: PUSH
68643: EMPTY
68644: LIST
68645: LIST
68646: PUSH
68647: LD_INT 0
68649: PUSH
68650: LD_INT 2
68652: PUSH
68653: EMPTY
68654: LIST
68655: LIST
68656: PUSH
68657: LD_INT 1
68659: NEG
68660: PUSH
68661: LD_INT 1
68663: PUSH
68664: EMPTY
68665: LIST
68666: LIST
68667: PUSH
68668: LD_INT 2
68670: NEG
68671: PUSH
68672: LD_INT 1
68674: NEG
68675: PUSH
68676: EMPTY
68677: LIST
68678: LIST
68679: PUSH
68680: LD_INT 2
68682: NEG
68683: PUSH
68684: LD_INT 2
68686: NEG
68687: PUSH
68688: EMPTY
68689: LIST
68690: LIST
68691: PUSH
68692: LD_INT 2
68694: NEG
68695: PUSH
68696: LD_INT 3
68698: NEG
68699: PUSH
68700: EMPTY
68701: LIST
68702: LIST
68703: PUSH
68704: LD_INT 2
68706: PUSH
68707: LD_INT 1
68709: NEG
68710: PUSH
68711: EMPTY
68712: LIST
68713: LIST
68714: PUSH
68715: LD_INT 3
68717: PUSH
68718: LD_INT 1
68720: PUSH
68721: EMPTY
68722: LIST
68723: LIST
68724: PUSH
68725: LD_INT 1
68727: PUSH
68728: LD_INT 3
68730: PUSH
68731: EMPTY
68732: LIST
68733: LIST
68734: PUSH
68735: LD_INT 1
68737: NEG
68738: PUSH
68739: LD_INT 2
68741: PUSH
68742: EMPTY
68743: LIST
68744: LIST
68745: PUSH
68746: LD_INT 3
68748: NEG
68749: PUSH
68750: LD_INT 2
68752: NEG
68753: PUSH
68754: EMPTY
68755: LIST
68756: LIST
68757: PUSH
68758: EMPTY
68759: LIST
68760: LIST
68761: LIST
68762: LIST
68763: LIST
68764: LIST
68765: LIST
68766: LIST
68767: LIST
68768: LIST
68769: LIST
68770: LIST
68771: LIST
68772: LIST
68773: LIST
68774: LIST
68775: LIST
68776: LIST
68777: LIST
68778: LIST
68779: LIST
68780: LIST
68781: LIST
68782: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68783: LD_ADDR_VAR 0 30
68787: PUSH
68788: LD_INT 0
68790: PUSH
68791: LD_INT 0
68793: PUSH
68794: EMPTY
68795: LIST
68796: LIST
68797: PUSH
68798: LD_INT 0
68800: PUSH
68801: LD_INT 1
68803: NEG
68804: PUSH
68805: EMPTY
68806: LIST
68807: LIST
68808: PUSH
68809: LD_INT 1
68811: PUSH
68812: LD_INT 0
68814: PUSH
68815: EMPTY
68816: LIST
68817: LIST
68818: PUSH
68819: LD_INT 1
68821: PUSH
68822: LD_INT 1
68824: PUSH
68825: EMPTY
68826: LIST
68827: LIST
68828: PUSH
68829: LD_INT 0
68831: PUSH
68832: LD_INT 1
68834: PUSH
68835: EMPTY
68836: LIST
68837: LIST
68838: PUSH
68839: LD_INT 1
68841: NEG
68842: PUSH
68843: LD_INT 0
68845: PUSH
68846: EMPTY
68847: LIST
68848: LIST
68849: PUSH
68850: LD_INT 1
68852: NEG
68853: PUSH
68854: LD_INT 1
68856: NEG
68857: PUSH
68858: EMPTY
68859: LIST
68860: LIST
68861: PUSH
68862: LD_INT 1
68864: NEG
68865: PUSH
68866: LD_INT 2
68868: NEG
68869: PUSH
68870: EMPTY
68871: LIST
68872: LIST
68873: PUSH
68874: LD_INT 0
68876: PUSH
68877: LD_INT 2
68879: NEG
68880: PUSH
68881: EMPTY
68882: LIST
68883: LIST
68884: PUSH
68885: LD_INT 1
68887: PUSH
68888: LD_INT 1
68890: NEG
68891: PUSH
68892: EMPTY
68893: LIST
68894: LIST
68895: PUSH
68896: LD_INT 2
68898: PUSH
68899: LD_INT 0
68901: PUSH
68902: EMPTY
68903: LIST
68904: LIST
68905: PUSH
68906: LD_INT 2
68908: PUSH
68909: LD_INT 1
68911: PUSH
68912: EMPTY
68913: LIST
68914: LIST
68915: PUSH
68916: LD_INT 2
68918: PUSH
68919: LD_INT 2
68921: PUSH
68922: EMPTY
68923: LIST
68924: LIST
68925: PUSH
68926: LD_INT 1
68928: PUSH
68929: LD_INT 2
68931: PUSH
68932: EMPTY
68933: LIST
68934: LIST
68935: PUSH
68936: LD_INT 1
68938: NEG
68939: PUSH
68940: LD_INT 1
68942: PUSH
68943: EMPTY
68944: LIST
68945: LIST
68946: PUSH
68947: LD_INT 2
68949: NEG
68950: PUSH
68951: LD_INT 0
68953: PUSH
68954: EMPTY
68955: LIST
68956: LIST
68957: PUSH
68958: LD_INT 2
68960: NEG
68961: PUSH
68962: LD_INT 1
68964: NEG
68965: PUSH
68966: EMPTY
68967: LIST
68968: LIST
68969: PUSH
68970: LD_INT 1
68972: NEG
68973: PUSH
68974: LD_INT 3
68976: NEG
68977: PUSH
68978: EMPTY
68979: LIST
68980: LIST
68981: PUSH
68982: LD_INT 1
68984: PUSH
68985: LD_INT 2
68987: NEG
68988: PUSH
68989: EMPTY
68990: LIST
68991: LIST
68992: PUSH
68993: LD_INT 3
68995: PUSH
68996: LD_INT 2
68998: PUSH
68999: EMPTY
69000: LIST
69001: LIST
69002: PUSH
69003: LD_INT 2
69005: PUSH
69006: LD_INT 3
69008: PUSH
69009: EMPTY
69010: LIST
69011: LIST
69012: PUSH
69013: LD_INT 2
69015: NEG
69016: PUSH
69017: LD_INT 1
69019: PUSH
69020: EMPTY
69021: LIST
69022: LIST
69023: PUSH
69024: LD_INT 3
69026: NEG
69027: PUSH
69028: LD_INT 1
69030: NEG
69031: PUSH
69032: EMPTY
69033: LIST
69034: LIST
69035: PUSH
69036: EMPTY
69037: LIST
69038: LIST
69039: LIST
69040: LIST
69041: LIST
69042: LIST
69043: LIST
69044: LIST
69045: LIST
69046: LIST
69047: LIST
69048: LIST
69049: LIST
69050: LIST
69051: LIST
69052: LIST
69053: LIST
69054: LIST
69055: LIST
69056: LIST
69057: LIST
69058: LIST
69059: LIST
69060: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
69061: LD_ADDR_VAR 0 31
69065: PUSH
69066: LD_INT 0
69068: PUSH
69069: LD_INT 0
69071: PUSH
69072: EMPTY
69073: LIST
69074: LIST
69075: PUSH
69076: LD_INT 0
69078: PUSH
69079: LD_INT 1
69081: NEG
69082: PUSH
69083: EMPTY
69084: LIST
69085: LIST
69086: PUSH
69087: LD_INT 1
69089: PUSH
69090: LD_INT 0
69092: PUSH
69093: EMPTY
69094: LIST
69095: LIST
69096: PUSH
69097: LD_INT 1
69099: PUSH
69100: LD_INT 1
69102: PUSH
69103: EMPTY
69104: LIST
69105: LIST
69106: PUSH
69107: LD_INT 0
69109: PUSH
69110: LD_INT 1
69112: PUSH
69113: EMPTY
69114: LIST
69115: LIST
69116: PUSH
69117: LD_INT 1
69119: NEG
69120: PUSH
69121: LD_INT 0
69123: PUSH
69124: EMPTY
69125: LIST
69126: LIST
69127: PUSH
69128: LD_INT 1
69130: NEG
69131: PUSH
69132: LD_INT 1
69134: NEG
69135: PUSH
69136: EMPTY
69137: LIST
69138: LIST
69139: PUSH
69140: LD_INT 1
69142: NEG
69143: PUSH
69144: LD_INT 2
69146: NEG
69147: PUSH
69148: EMPTY
69149: LIST
69150: LIST
69151: PUSH
69152: LD_INT 1
69154: PUSH
69155: LD_INT 1
69157: NEG
69158: PUSH
69159: EMPTY
69160: LIST
69161: LIST
69162: PUSH
69163: LD_INT 2
69165: PUSH
69166: LD_INT 0
69168: PUSH
69169: EMPTY
69170: LIST
69171: LIST
69172: PUSH
69173: LD_INT 2
69175: PUSH
69176: LD_INT 1
69178: PUSH
69179: EMPTY
69180: LIST
69181: LIST
69182: PUSH
69183: LD_INT 2
69185: PUSH
69186: LD_INT 2
69188: PUSH
69189: EMPTY
69190: LIST
69191: LIST
69192: PUSH
69193: LD_INT 1
69195: PUSH
69196: LD_INT 2
69198: PUSH
69199: EMPTY
69200: LIST
69201: LIST
69202: PUSH
69203: LD_INT 0
69205: PUSH
69206: LD_INT 2
69208: PUSH
69209: EMPTY
69210: LIST
69211: LIST
69212: PUSH
69213: LD_INT 1
69215: NEG
69216: PUSH
69217: LD_INT 1
69219: PUSH
69220: EMPTY
69221: LIST
69222: LIST
69223: PUSH
69224: LD_INT 2
69226: NEG
69227: PUSH
69228: LD_INT 1
69230: NEG
69231: PUSH
69232: EMPTY
69233: LIST
69234: LIST
69235: PUSH
69236: LD_INT 2
69238: NEG
69239: PUSH
69240: LD_INT 2
69242: NEG
69243: PUSH
69244: EMPTY
69245: LIST
69246: LIST
69247: PUSH
69248: LD_INT 2
69250: NEG
69251: PUSH
69252: LD_INT 3
69254: NEG
69255: PUSH
69256: EMPTY
69257: LIST
69258: LIST
69259: PUSH
69260: LD_INT 2
69262: PUSH
69263: LD_INT 1
69265: NEG
69266: PUSH
69267: EMPTY
69268: LIST
69269: LIST
69270: PUSH
69271: LD_INT 3
69273: PUSH
69274: LD_INT 1
69276: PUSH
69277: EMPTY
69278: LIST
69279: LIST
69280: PUSH
69281: LD_INT 1
69283: PUSH
69284: LD_INT 3
69286: PUSH
69287: EMPTY
69288: LIST
69289: LIST
69290: PUSH
69291: LD_INT 1
69293: NEG
69294: PUSH
69295: LD_INT 2
69297: PUSH
69298: EMPTY
69299: LIST
69300: LIST
69301: PUSH
69302: LD_INT 3
69304: NEG
69305: PUSH
69306: LD_INT 2
69308: NEG
69309: PUSH
69310: EMPTY
69311: LIST
69312: LIST
69313: PUSH
69314: EMPTY
69315: LIST
69316: LIST
69317: LIST
69318: LIST
69319: LIST
69320: LIST
69321: LIST
69322: LIST
69323: LIST
69324: LIST
69325: LIST
69326: LIST
69327: LIST
69328: LIST
69329: LIST
69330: LIST
69331: LIST
69332: LIST
69333: LIST
69334: LIST
69335: LIST
69336: LIST
69337: LIST
69338: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
69339: LD_ADDR_VAR 0 32
69343: PUSH
69344: LD_INT 0
69346: PUSH
69347: LD_INT 0
69349: PUSH
69350: EMPTY
69351: LIST
69352: LIST
69353: PUSH
69354: LD_INT 0
69356: PUSH
69357: LD_INT 1
69359: NEG
69360: PUSH
69361: EMPTY
69362: LIST
69363: LIST
69364: PUSH
69365: LD_INT 1
69367: PUSH
69368: LD_INT 0
69370: PUSH
69371: EMPTY
69372: LIST
69373: LIST
69374: PUSH
69375: LD_INT 1
69377: PUSH
69378: LD_INT 1
69380: PUSH
69381: EMPTY
69382: LIST
69383: LIST
69384: PUSH
69385: LD_INT 0
69387: PUSH
69388: LD_INT 1
69390: PUSH
69391: EMPTY
69392: LIST
69393: LIST
69394: PUSH
69395: LD_INT 1
69397: NEG
69398: PUSH
69399: LD_INT 0
69401: PUSH
69402: EMPTY
69403: LIST
69404: LIST
69405: PUSH
69406: LD_INT 1
69408: NEG
69409: PUSH
69410: LD_INT 1
69412: NEG
69413: PUSH
69414: EMPTY
69415: LIST
69416: LIST
69417: PUSH
69418: LD_INT 1
69420: NEG
69421: PUSH
69422: LD_INT 2
69424: NEG
69425: PUSH
69426: EMPTY
69427: LIST
69428: LIST
69429: PUSH
69430: LD_INT 0
69432: PUSH
69433: LD_INT 2
69435: NEG
69436: PUSH
69437: EMPTY
69438: LIST
69439: LIST
69440: PUSH
69441: LD_INT 1
69443: PUSH
69444: LD_INT 1
69446: NEG
69447: PUSH
69448: EMPTY
69449: LIST
69450: LIST
69451: PUSH
69452: LD_INT 2
69454: PUSH
69455: LD_INT 1
69457: PUSH
69458: EMPTY
69459: LIST
69460: LIST
69461: PUSH
69462: LD_INT 2
69464: PUSH
69465: LD_INT 2
69467: PUSH
69468: EMPTY
69469: LIST
69470: LIST
69471: PUSH
69472: LD_INT 1
69474: PUSH
69475: LD_INT 2
69477: PUSH
69478: EMPTY
69479: LIST
69480: LIST
69481: PUSH
69482: LD_INT 0
69484: PUSH
69485: LD_INT 2
69487: PUSH
69488: EMPTY
69489: LIST
69490: LIST
69491: PUSH
69492: LD_INT 1
69494: NEG
69495: PUSH
69496: LD_INT 1
69498: PUSH
69499: EMPTY
69500: LIST
69501: LIST
69502: PUSH
69503: LD_INT 2
69505: NEG
69506: PUSH
69507: LD_INT 0
69509: PUSH
69510: EMPTY
69511: LIST
69512: LIST
69513: PUSH
69514: LD_INT 2
69516: NEG
69517: PUSH
69518: LD_INT 1
69520: NEG
69521: PUSH
69522: EMPTY
69523: LIST
69524: LIST
69525: PUSH
69526: LD_INT 1
69528: NEG
69529: PUSH
69530: LD_INT 3
69532: NEG
69533: PUSH
69534: EMPTY
69535: LIST
69536: LIST
69537: PUSH
69538: LD_INT 1
69540: PUSH
69541: LD_INT 2
69543: NEG
69544: PUSH
69545: EMPTY
69546: LIST
69547: LIST
69548: PUSH
69549: LD_INT 3
69551: PUSH
69552: LD_INT 2
69554: PUSH
69555: EMPTY
69556: LIST
69557: LIST
69558: PUSH
69559: LD_INT 2
69561: PUSH
69562: LD_INT 3
69564: PUSH
69565: EMPTY
69566: LIST
69567: LIST
69568: PUSH
69569: LD_INT 2
69571: NEG
69572: PUSH
69573: LD_INT 1
69575: PUSH
69576: EMPTY
69577: LIST
69578: LIST
69579: PUSH
69580: LD_INT 3
69582: NEG
69583: PUSH
69584: LD_INT 1
69586: NEG
69587: PUSH
69588: EMPTY
69589: LIST
69590: LIST
69591: PUSH
69592: EMPTY
69593: LIST
69594: LIST
69595: LIST
69596: LIST
69597: LIST
69598: LIST
69599: LIST
69600: LIST
69601: LIST
69602: LIST
69603: LIST
69604: LIST
69605: LIST
69606: LIST
69607: LIST
69608: LIST
69609: LIST
69610: LIST
69611: LIST
69612: LIST
69613: LIST
69614: LIST
69615: LIST
69616: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
69617: LD_ADDR_VAR 0 33
69621: PUSH
69622: LD_INT 0
69624: PUSH
69625: LD_INT 0
69627: PUSH
69628: EMPTY
69629: LIST
69630: LIST
69631: PUSH
69632: LD_INT 0
69634: PUSH
69635: LD_INT 1
69637: NEG
69638: PUSH
69639: EMPTY
69640: LIST
69641: LIST
69642: PUSH
69643: LD_INT 1
69645: PUSH
69646: LD_INT 0
69648: PUSH
69649: EMPTY
69650: LIST
69651: LIST
69652: PUSH
69653: LD_INT 1
69655: PUSH
69656: LD_INT 1
69658: PUSH
69659: EMPTY
69660: LIST
69661: LIST
69662: PUSH
69663: LD_INT 0
69665: PUSH
69666: LD_INT 1
69668: PUSH
69669: EMPTY
69670: LIST
69671: LIST
69672: PUSH
69673: LD_INT 1
69675: NEG
69676: PUSH
69677: LD_INT 0
69679: PUSH
69680: EMPTY
69681: LIST
69682: LIST
69683: PUSH
69684: LD_INT 1
69686: NEG
69687: PUSH
69688: LD_INT 1
69690: NEG
69691: PUSH
69692: EMPTY
69693: LIST
69694: LIST
69695: PUSH
69696: LD_INT 1
69698: NEG
69699: PUSH
69700: LD_INT 2
69702: NEG
69703: PUSH
69704: EMPTY
69705: LIST
69706: LIST
69707: PUSH
69708: LD_INT 1
69710: PUSH
69711: LD_INT 1
69713: NEG
69714: PUSH
69715: EMPTY
69716: LIST
69717: LIST
69718: PUSH
69719: LD_INT 2
69721: PUSH
69722: LD_INT 0
69724: PUSH
69725: EMPTY
69726: LIST
69727: LIST
69728: PUSH
69729: LD_INT 2
69731: PUSH
69732: LD_INT 1
69734: PUSH
69735: EMPTY
69736: LIST
69737: LIST
69738: PUSH
69739: LD_INT 1
69741: PUSH
69742: LD_INT 2
69744: PUSH
69745: EMPTY
69746: LIST
69747: LIST
69748: PUSH
69749: LD_INT 0
69751: PUSH
69752: LD_INT 2
69754: PUSH
69755: EMPTY
69756: LIST
69757: LIST
69758: PUSH
69759: LD_INT 1
69761: NEG
69762: PUSH
69763: LD_INT 1
69765: PUSH
69766: EMPTY
69767: LIST
69768: LIST
69769: PUSH
69770: LD_INT 2
69772: NEG
69773: PUSH
69774: LD_INT 0
69776: PUSH
69777: EMPTY
69778: LIST
69779: LIST
69780: PUSH
69781: LD_INT 2
69783: NEG
69784: PUSH
69785: LD_INT 1
69787: NEG
69788: PUSH
69789: EMPTY
69790: LIST
69791: LIST
69792: PUSH
69793: LD_INT 2
69795: NEG
69796: PUSH
69797: LD_INT 2
69799: NEG
69800: PUSH
69801: EMPTY
69802: LIST
69803: LIST
69804: PUSH
69805: LD_INT 2
69807: NEG
69808: PUSH
69809: LD_INT 3
69811: NEG
69812: PUSH
69813: EMPTY
69814: LIST
69815: LIST
69816: PUSH
69817: LD_INT 2
69819: PUSH
69820: LD_INT 1
69822: NEG
69823: PUSH
69824: EMPTY
69825: LIST
69826: LIST
69827: PUSH
69828: LD_INT 3
69830: PUSH
69831: LD_INT 1
69833: PUSH
69834: EMPTY
69835: LIST
69836: LIST
69837: PUSH
69838: LD_INT 1
69840: PUSH
69841: LD_INT 3
69843: PUSH
69844: EMPTY
69845: LIST
69846: LIST
69847: PUSH
69848: LD_INT 1
69850: NEG
69851: PUSH
69852: LD_INT 2
69854: PUSH
69855: EMPTY
69856: LIST
69857: LIST
69858: PUSH
69859: LD_INT 3
69861: NEG
69862: PUSH
69863: LD_INT 2
69865: NEG
69866: PUSH
69867: EMPTY
69868: LIST
69869: LIST
69870: PUSH
69871: EMPTY
69872: LIST
69873: LIST
69874: LIST
69875: LIST
69876: LIST
69877: LIST
69878: LIST
69879: LIST
69880: LIST
69881: LIST
69882: LIST
69883: LIST
69884: LIST
69885: LIST
69886: LIST
69887: LIST
69888: LIST
69889: LIST
69890: LIST
69891: LIST
69892: LIST
69893: LIST
69894: LIST
69895: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
69896: LD_ADDR_VAR 0 34
69900: PUSH
69901: LD_INT 0
69903: PUSH
69904: LD_INT 0
69906: PUSH
69907: EMPTY
69908: LIST
69909: LIST
69910: PUSH
69911: LD_INT 0
69913: PUSH
69914: LD_INT 1
69916: NEG
69917: PUSH
69918: EMPTY
69919: LIST
69920: LIST
69921: PUSH
69922: LD_INT 1
69924: PUSH
69925: LD_INT 0
69927: PUSH
69928: EMPTY
69929: LIST
69930: LIST
69931: PUSH
69932: LD_INT 1
69934: PUSH
69935: LD_INT 1
69937: PUSH
69938: EMPTY
69939: LIST
69940: LIST
69941: PUSH
69942: LD_INT 0
69944: PUSH
69945: LD_INT 1
69947: PUSH
69948: EMPTY
69949: LIST
69950: LIST
69951: PUSH
69952: LD_INT 1
69954: NEG
69955: PUSH
69956: LD_INT 0
69958: PUSH
69959: EMPTY
69960: LIST
69961: LIST
69962: PUSH
69963: LD_INT 1
69965: NEG
69966: PUSH
69967: LD_INT 1
69969: NEG
69970: PUSH
69971: EMPTY
69972: LIST
69973: LIST
69974: PUSH
69975: LD_INT 1
69977: NEG
69978: PUSH
69979: LD_INT 2
69981: NEG
69982: PUSH
69983: EMPTY
69984: LIST
69985: LIST
69986: PUSH
69987: LD_INT 0
69989: PUSH
69990: LD_INT 2
69992: NEG
69993: PUSH
69994: EMPTY
69995: LIST
69996: LIST
69997: PUSH
69998: LD_INT 1
70000: PUSH
70001: LD_INT 1
70003: NEG
70004: PUSH
70005: EMPTY
70006: LIST
70007: LIST
70008: PUSH
70009: LD_INT 2
70011: PUSH
70012: LD_INT 1
70014: PUSH
70015: EMPTY
70016: LIST
70017: LIST
70018: PUSH
70019: LD_INT 2
70021: PUSH
70022: LD_INT 2
70024: PUSH
70025: EMPTY
70026: LIST
70027: LIST
70028: PUSH
70029: LD_INT 1
70031: PUSH
70032: LD_INT 2
70034: PUSH
70035: EMPTY
70036: LIST
70037: LIST
70038: PUSH
70039: LD_INT 1
70041: NEG
70042: PUSH
70043: LD_INT 1
70045: PUSH
70046: EMPTY
70047: LIST
70048: LIST
70049: PUSH
70050: LD_INT 2
70052: NEG
70053: PUSH
70054: LD_INT 0
70056: PUSH
70057: EMPTY
70058: LIST
70059: LIST
70060: PUSH
70061: LD_INT 2
70063: NEG
70064: PUSH
70065: LD_INT 1
70067: NEG
70068: PUSH
70069: EMPTY
70070: LIST
70071: LIST
70072: PUSH
70073: LD_INT 2
70075: NEG
70076: PUSH
70077: LD_INT 2
70079: NEG
70080: PUSH
70081: EMPTY
70082: LIST
70083: LIST
70084: PUSH
70085: LD_INT 1
70087: NEG
70088: PUSH
70089: LD_INT 3
70091: NEG
70092: PUSH
70093: EMPTY
70094: LIST
70095: LIST
70096: PUSH
70097: LD_INT 1
70099: PUSH
70100: LD_INT 2
70102: NEG
70103: PUSH
70104: EMPTY
70105: LIST
70106: LIST
70107: PUSH
70108: LD_INT 3
70110: PUSH
70111: LD_INT 2
70113: PUSH
70114: EMPTY
70115: LIST
70116: LIST
70117: PUSH
70118: LD_INT 2
70120: PUSH
70121: LD_INT 3
70123: PUSH
70124: EMPTY
70125: LIST
70126: LIST
70127: PUSH
70128: LD_INT 2
70130: NEG
70131: PUSH
70132: LD_INT 1
70134: PUSH
70135: EMPTY
70136: LIST
70137: LIST
70138: PUSH
70139: LD_INT 3
70141: NEG
70142: PUSH
70143: LD_INT 1
70145: NEG
70146: PUSH
70147: EMPTY
70148: LIST
70149: LIST
70150: PUSH
70151: EMPTY
70152: LIST
70153: LIST
70154: LIST
70155: LIST
70156: LIST
70157: LIST
70158: LIST
70159: LIST
70160: LIST
70161: LIST
70162: LIST
70163: LIST
70164: LIST
70165: LIST
70166: LIST
70167: LIST
70168: LIST
70169: LIST
70170: LIST
70171: LIST
70172: LIST
70173: LIST
70174: LIST
70175: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
70176: LD_ADDR_VAR 0 35
70180: PUSH
70181: LD_INT 0
70183: PUSH
70184: LD_INT 0
70186: PUSH
70187: EMPTY
70188: LIST
70189: LIST
70190: PUSH
70191: LD_INT 0
70193: PUSH
70194: LD_INT 1
70196: NEG
70197: PUSH
70198: EMPTY
70199: LIST
70200: LIST
70201: PUSH
70202: LD_INT 1
70204: PUSH
70205: LD_INT 0
70207: PUSH
70208: EMPTY
70209: LIST
70210: LIST
70211: PUSH
70212: LD_INT 1
70214: PUSH
70215: LD_INT 1
70217: PUSH
70218: EMPTY
70219: LIST
70220: LIST
70221: PUSH
70222: LD_INT 0
70224: PUSH
70225: LD_INT 1
70227: PUSH
70228: EMPTY
70229: LIST
70230: LIST
70231: PUSH
70232: LD_INT 1
70234: NEG
70235: PUSH
70236: LD_INT 0
70238: PUSH
70239: EMPTY
70240: LIST
70241: LIST
70242: PUSH
70243: LD_INT 1
70245: NEG
70246: PUSH
70247: LD_INT 1
70249: NEG
70250: PUSH
70251: EMPTY
70252: LIST
70253: LIST
70254: PUSH
70255: LD_INT 2
70257: PUSH
70258: LD_INT 1
70260: PUSH
70261: EMPTY
70262: LIST
70263: LIST
70264: PUSH
70265: LD_INT 2
70267: NEG
70268: PUSH
70269: LD_INT 1
70271: NEG
70272: PUSH
70273: EMPTY
70274: LIST
70275: LIST
70276: PUSH
70277: EMPTY
70278: LIST
70279: LIST
70280: LIST
70281: LIST
70282: LIST
70283: LIST
70284: LIST
70285: LIST
70286: LIST
70287: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
70288: LD_ADDR_VAR 0 36
70292: PUSH
70293: LD_INT 0
70295: PUSH
70296: LD_INT 0
70298: PUSH
70299: EMPTY
70300: LIST
70301: LIST
70302: PUSH
70303: LD_INT 0
70305: PUSH
70306: LD_INT 1
70308: NEG
70309: PUSH
70310: EMPTY
70311: LIST
70312: LIST
70313: PUSH
70314: LD_INT 1
70316: PUSH
70317: LD_INT 0
70319: PUSH
70320: EMPTY
70321: LIST
70322: LIST
70323: PUSH
70324: LD_INT 1
70326: PUSH
70327: LD_INT 1
70329: PUSH
70330: EMPTY
70331: LIST
70332: LIST
70333: PUSH
70334: LD_INT 0
70336: PUSH
70337: LD_INT 1
70339: PUSH
70340: EMPTY
70341: LIST
70342: LIST
70343: PUSH
70344: LD_INT 1
70346: NEG
70347: PUSH
70348: LD_INT 0
70350: PUSH
70351: EMPTY
70352: LIST
70353: LIST
70354: PUSH
70355: LD_INT 1
70357: NEG
70358: PUSH
70359: LD_INT 1
70361: NEG
70362: PUSH
70363: EMPTY
70364: LIST
70365: LIST
70366: PUSH
70367: LD_INT 1
70369: NEG
70370: PUSH
70371: LD_INT 2
70373: NEG
70374: PUSH
70375: EMPTY
70376: LIST
70377: LIST
70378: PUSH
70379: LD_INT 1
70381: PUSH
70382: LD_INT 2
70384: PUSH
70385: EMPTY
70386: LIST
70387: LIST
70388: PUSH
70389: EMPTY
70390: LIST
70391: LIST
70392: LIST
70393: LIST
70394: LIST
70395: LIST
70396: LIST
70397: LIST
70398: LIST
70399: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
70400: LD_ADDR_VAR 0 37
70404: PUSH
70405: LD_INT 0
70407: PUSH
70408: LD_INT 0
70410: PUSH
70411: EMPTY
70412: LIST
70413: LIST
70414: PUSH
70415: LD_INT 0
70417: PUSH
70418: LD_INT 1
70420: NEG
70421: PUSH
70422: EMPTY
70423: LIST
70424: LIST
70425: PUSH
70426: LD_INT 1
70428: PUSH
70429: LD_INT 0
70431: PUSH
70432: EMPTY
70433: LIST
70434: LIST
70435: PUSH
70436: LD_INT 1
70438: PUSH
70439: LD_INT 1
70441: PUSH
70442: EMPTY
70443: LIST
70444: LIST
70445: PUSH
70446: LD_INT 0
70448: PUSH
70449: LD_INT 1
70451: PUSH
70452: EMPTY
70453: LIST
70454: LIST
70455: PUSH
70456: LD_INT 1
70458: NEG
70459: PUSH
70460: LD_INT 0
70462: PUSH
70463: EMPTY
70464: LIST
70465: LIST
70466: PUSH
70467: LD_INT 1
70469: NEG
70470: PUSH
70471: LD_INT 1
70473: NEG
70474: PUSH
70475: EMPTY
70476: LIST
70477: LIST
70478: PUSH
70479: LD_INT 1
70481: PUSH
70482: LD_INT 1
70484: NEG
70485: PUSH
70486: EMPTY
70487: LIST
70488: LIST
70489: PUSH
70490: LD_INT 1
70492: NEG
70493: PUSH
70494: LD_INT 1
70496: PUSH
70497: EMPTY
70498: LIST
70499: LIST
70500: PUSH
70501: EMPTY
70502: LIST
70503: LIST
70504: LIST
70505: LIST
70506: LIST
70507: LIST
70508: LIST
70509: LIST
70510: LIST
70511: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
70512: LD_ADDR_VAR 0 38
70516: PUSH
70517: LD_INT 0
70519: PUSH
70520: LD_INT 0
70522: PUSH
70523: EMPTY
70524: LIST
70525: LIST
70526: PUSH
70527: LD_INT 0
70529: PUSH
70530: LD_INT 1
70532: NEG
70533: PUSH
70534: EMPTY
70535: LIST
70536: LIST
70537: PUSH
70538: LD_INT 1
70540: PUSH
70541: LD_INT 0
70543: PUSH
70544: EMPTY
70545: LIST
70546: LIST
70547: PUSH
70548: LD_INT 1
70550: PUSH
70551: LD_INT 1
70553: PUSH
70554: EMPTY
70555: LIST
70556: LIST
70557: PUSH
70558: LD_INT 0
70560: PUSH
70561: LD_INT 1
70563: PUSH
70564: EMPTY
70565: LIST
70566: LIST
70567: PUSH
70568: LD_INT 1
70570: NEG
70571: PUSH
70572: LD_INT 0
70574: PUSH
70575: EMPTY
70576: LIST
70577: LIST
70578: PUSH
70579: LD_INT 1
70581: NEG
70582: PUSH
70583: LD_INT 1
70585: NEG
70586: PUSH
70587: EMPTY
70588: LIST
70589: LIST
70590: PUSH
70591: LD_INT 2
70593: PUSH
70594: LD_INT 1
70596: PUSH
70597: EMPTY
70598: LIST
70599: LIST
70600: PUSH
70601: LD_INT 2
70603: NEG
70604: PUSH
70605: LD_INT 1
70607: NEG
70608: PUSH
70609: EMPTY
70610: LIST
70611: LIST
70612: PUSH
70613: EMPTY
70614: LIST
70615: LIST
70616: LIST
70617: LIST
70618: LIST
70619: LIST
70620: LIST
70621: LIST
70622: LIST
70623: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
70624: LD_ADDR_VAR 0 39
70628: PUSH
70629: LD_INT 0
70631: PUSH
70632: LD_INT 0
70634: PUSH
70635: EMPTY
70636: LIST
70637: LIST
70638: PUSH
70639: LD_INT 0
70641: PUSH
70642: LD_INT 1
70644: NEG
70645: PUSH
70646: EMPTY
70647: LIST
70648: LIST
70649: PUSH
70650: LD_INT 1
70652: PUSH
70653: LD_INT 0
70655: PUSH
70656: EMPTY
70657: LIST
70658: LIST
70659: PUSH
70660: LD_INT 1
70662: PUSH
70663: LD_INT 1
70665: PUSH
70666: EMPTY
70667: LIST
70668: LIST
70669: PUSH
70670: LD_INT 0
70672: PUSH
70673: LD_INT 1
70675: PUSH
70676: EMPTY
70677: LIST
70678: LIST
70679: PUSH
70680: LD_INT 1
70682: NEG
70683: PUSH
70684: LD_INT 0
70686: PUSH
70687: EMPTY
70688: LIST
70689: LIST
70690: PUSH
70691: LD_INT 1
70693: NEG
70694: PUSH
70695: LD_INT 1
70697: NEG
70698: PUSH
70699: EMPTY
70700: LIST
70701: LIST
70702: PUSH
70703: LD_INT 1
70705: NEG
70706: PUSH
70707: LD_INT 2
70709: NEG
70710: PUSH
70711: EMPTY
70712: LIST
70713: LIST
70714: PUSH
70715: LD_INT 1
70717: PUSH
70718: LD_INT 2
70720: PUSH
70721: EMPTY
70722: LIST
70723: LIST
70724: PUSH
70725: EMPTY
70726: LIST
70727: LIST
70728: LIST
70729: LIST
70730: LIST
70731: LIST
70732: LIST
70733: LIST
70734: LIST
70735: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
70736: LD_ADDR_VAR 0 40
70740: PUSH
70741: LD_INT 0
70743: PUSH
70744: LD_INT 0
70746: PUSH
70747: EMPTY
70748: LIST
70749: LIST
70750: PUSH
70751: LD_INT 0
70753: PUSH
70754: LD_INT 1
70756: NEG
70757: PUSH
70758: EMPTY
70759: LIST
70760: LIST
70761: PUSH
70762: LD_INT 1
70764: PUSH
70765: LD_INT 0
70767: PUSH
70768: EMPTY
70769: LIST
70770: LIST
70771: PUSH
70772: LD_INT 1
70774: PUSH
70775: LD_INT 1
70777: PUSH
70778: EMPTY
70779: LIST
70780: LIST
70781: PUSH
70782: LD_INT 0
70784: PUSH
70785: LD_INT 1
70787: PUSH
70788: EMPTY
70789: LIST
70790: LIST
70791: PUSH
70792: LD_INT 1
70794: NEG
70795: PUSH
70796: LD_INT 0
70798: PUSH
70799: EMPTY
70800: LIST
70801: LIST
70802: PUSH
70803: LD_INT 1
70805: NEG
70806: PUSH
70807: LD_INT 1
70809: NEG
70810: PUSH
70811: EMPTY
70812: LIST
70813: LIST
70814: PUSH
70815: LD_INT 1
70817: PUSH
70818: LD_INT 1
70820: NEG
70821: PUSH
70822: EMPTY
70823: LIST
70824: LIST
70825: PUSH
70826: LD_INT 1
70828: NEG
70829: PUSH
70830: LD_INT 1
70832: PUSH
70833: EMPTY
70834: LIST
70835: LIST
70836: PUSH
70837: EMPTY
70838: LIST
70839: LIST
70840: LIST
70841: LIST
70842: LIST
70843: LIST
70844: LIST
70845: LIST
70846: LIST
70847: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70848: LD_ADDR_VAR 0 41
70852: PUSH
70853: LD_INT 0
70855: PUSH
70856: LD_INT 0
70858: PUSH
70859: EMPTY
70860: LIST
70861: LIST
70862: PUSH
70863: LD_INT 0
70865: PUSH
70866: LD_INT 1
70868: NEG
70869: PUSH
70870: EMPTY
70871: LIST
70872: LIST
70873: PUSH
70874: LD_INT 1
70876: PUSH
70877: LD_INT 0
70879: PUSH
70880: EMPTY
70881: LIST
70882: LIST
70883: PUSH
70884: LD_INT 1
70886: PUSH
70887: LD_INT 1
70889: PUSH
70890: EMPTY
70891: LIST
70892: LIST
70893: PUSH
70894: LD_INT 0
70896: PUSH
70897: LD_INT 1
70899: PUSH
70900: EMPTY
70901: LIST
70902: LIST
70903: PUSH
70904: LD_INT 1
70906: NEG
70907: PUSH
70908: LD_INT 0
70910: PUSH
70911: EMPTY
70912: LIST
70913: LIST
70914: PUSH
70915: LD_INT 1
70917: NEG
70918: PUSH
70919: LD_INT 1
70921: NEG
70922: PUSH
70923: EMPTY
70924: LIST
70925: LIST
70926: PUSH
70927: LD_INT 1
70929: NEG
70930: PUSH
70931: LD_INT 2
70933: NEG
70934: PUSH
70935: EMPTY
70936: LIST
70937: LIST
70938: PUSH
70939: LD_INT 1
70941: PUSH
70942: LD_INT 1
70944: NEG
70945: PUSH
70946: EMPTY
70947: LIST
70948: LIST
70949: PUSH
70950: LD_INT 2
70952: PUSH
70953: LD_INT 0
70955: PUSH
70956: EMPTY
70957: LIST
70958: LIST
70959: PUSH
70960: LD_INT 2
70962: PUSH
70963: LD_INT 1
70965: PUSH
70966: EMPTY
70967: LIST
70968: LIST
70969: PUSH
70970: LD_INT 2
70972: PUSH
70973: LD_INT 2
70975: PUSH
70976: EMPTY
70977: LIST
70978: LIST
70979: PUSH
70980: LD_INT 1
70982: PUSH
70983: LD_INT 2
70985: PUSH
70986: EMPTY
70987: LIST
70988: LIST
70989: PUSH
70990: LD_INT 1
70992: NEG
70993: PUSH
70994: LD_INT 1
70996: PUSH
70997: EMPTY
70998: LIST
70999: LIST
71000: PUSH
71001: LD_INT 2
71003: NEG
71004: PUSH
71005: LD_INT 0
71007: PUSH
71008: EMPTY
71009: LIST
71010: LIST
71011: PUSH
71012: LD_INT 2
71014: NEG
71015: PUSH
71016: LD_INT 1
71018: NEG
71019: PUSH
71020: EMPTY
71021: LIST
71022: LIST
71023: PUSH
71024: LD_INT 2
71026: NEG
71027: PUSH
71028: LD_INT 2
71030: NEG
71031: PUSH
71032: EMPTY
71033: LIST
71034: LIST
71035: PUSH
71036: LD_INT 2
71038: NEG
71039: PUSH
71040: LD_INT 3
71042: NEG
71043: PUSH
71044: EMPTY
71045: LIST
71046: LIST
71047: PUSH
71048: LD_INT 2
71050: PUSH
71051: LD_INT 1
71053: NEG
71054: PUSH
71055: EMPTY
71056: LIST
71057: LIST
71058: PUSH
71059: LD_INT 3
71061: PUSH
71062: LD_INT 0
71064: PUSH
71065: EMPTY
71066: LIST
71067: LIST
71068: PUSH
71069: LD_INT 3
71071: PUSH
71072: LD_INT 1
71074: PUSH
71075: EMPTY
71076: LIST
71077: LIST
71078: PUSH
71079: LD_INT 3
71081: PUSH
71082: LD_INT 2
71084: PUSH
71085: EMPTY
71086: LIST
71087: LIST
71088: PUSH
71089: LD_INT 3
71091: PUSH
71092: LD_INT 3
71094: PUSH
71095: EMPTY
71096: LIST
71097: LIST
71098: PUSH
71099: LD_INT 2
71101: PUSH
71102: LD_INT 3
71104: PUSH
71105: EMPTY
71106: LIST
71107: LIST
71108: PUSH
71109: LD_INT 2
71111: NEG
71112: PUSH
71113: LD_INT 1
71115: PUSH
71116: EMPTY
71117: LIST
71118: LIST
71119: PUSH
71120: LD_INT 3
71122: NEG
71123: PUSH
71124: LD_INT 0
71126: PUSH
71127: EMPTY
71128: LIST
71129: LIST
71130: PUSH
71131: LD_INT 3
71133: NEG
71134: PUSH
71135: LD_INT 1
71137: NEG
71138: PUSH
71139: EMPTY
71140: LIST
71141: LIST
71142: PUSH
71143: LD_INT 3
71145: NEG
71146: PUSH
71147: LD_INT 2
71149: NEG
71150: PUSH
71151: EMPTY
71152: LIST
71153: LIST
71154: PUSH
71155: LD_INT 3
71157: NEG
71158: PUSH
71159: LD_INT 3
71161: NEG
71162: PUSH
71163: EMPTY
71164: LIST
71165: LIST
71166: PUSH
71167: EMPTY
71168: LIST
71169: LIST
71170: LIST
71171: LIST
71172: LIST
71173: LIST
71174: LIST
71175: LIST
71176: LIST
71177: LIST
71178: LIST
71179: LIST
71180: LIST
71181: LIST
71182: LIST
71183: LIST
71184: LIST
71185: LIST
71186: LIST
71187: LIST
71188: LIST
71189: LIST
71190: LIST
71191: LIST
71192: LIST
71193: LIST
71194: LIST
71195: LIST
71196: LIST
71197: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71198: LD_ADDR_VAR 0 42
71202: PUSH
71203: LD_INT 0
71205: PUSH
71206: LD_INT 0
71208: PUSH
71209: EMPTY
71210: LIST
71211: LIST
71212: PUSH
71213: LD_INT 0
71215: PUSH
71216: LD_INT 1
71218: NEG
71219: PUSH
71220: EMPTY
71221: LIST
71222: LIST
71223: PUSH
71224: LD_INT 1
71226: PUSH
71227: LD_INT 0
71229: PUSH
71230: EMPTY
71231: LIST
71232: LIST
71233: PUSH
71234: LD_INT 1
71236: PUSH
71237: LD_INT 1
71239: PUSH
71240: EMPTY
71241: LIST
71242: LIST
71243: PUSH
71244: LD_INT 0
71246: PUSH
71247: LD_INT 1
71249: PUSH
71250: EMPTY
71251: LIST
71252: LIST
71253: PUSH
71254: LD_INT 1
71256: NEG
71257: PUSH
71258: LD_INT 0
71260: PUSH
71261: EMPTY
71262: LIST
71263: LIST
71264: PUSH
71265: LD_INT 1
71267: NEG
71268: PUSH
71269: LD_INT 1
71271: NEG
71272: PUSH
71273: EMPTY
71274: LIST
71275: LIST
71276: PUSH
71277: LD_INT 1
71279: NEG
71280: PUSH
71281: LD_INT 2
71283: NEG
71284: PUSH
71285: EMPTY
71286: LIST
71287: LIST
71288: PUSH
71289: LD_INT 0
71291: PUSH
71292: LD_INT 2
71294: NEG
71295: PUSH
71296: EMPTY
71297: LIST
71298: LIST
71299: PUSH
71300: LD_INT 1
71302: PUSH
71303: LD_INT 1
71305: NEG
71306: PUSH
71307: EMPTY
71308: LIST
71309: LIST
71310: PUSH
71311: LD_INT 2
71313: PUSH
71314: LD_INT 1
71316: PUSH
71317: EMPTY
71318: LIST
71319: LIST
71320: PUSH
71321: LD_INT 2
71323: PUSH
71324: LD_INT 2
71326: PUSH
71327: EMPTY
71328: LIST
71329: LIST
71330: PUSH
71331: LD_INT 1
71333: PUSH
71334: LD_INT 2
71336: PUSH
71337: EMPTY
71338: LIST
71339: LIST
71340: PUSH
71341: LD_INT 0
71343: PUSH
71344: LD_INT 2
71346: PUSH
71347: EMPTY
71348: LIST
71349: LIST
71350: PUSH
71351: LD_INT 1
71353: NEG
71354: PUSH
71355: LD_INT 1
71357: PUSH
71358: EMPTY
71359: LIST
71360: LIST
71361: PUSH
71362: LD_INT 2
71364: NEG
71365: PUSH
71366: LD_INT 1
71368: NEG
71369: PUSH
71370: EMPTY
71371: LIST
71372: LIST
71373: PUSH
71374: LD_INT 2
71376: NEG
71377: PUSH
71378: LD_INT 2
71380: NEG
71381: PUSH
71382: EMPTY
71383: LIST
71384: LIST
71385: PUSH
71386: LD_INT 2
71388: NEG
71389: PUSH
71390: LD_INT 3
71392: NEG
71393: PUSH
71394: EMPTY
71395: LIST
71396: LIST
71397: PUSH
71398: LD_INT 1
71400: NEG
71401: PUSH
71402: LD_INT 3
71404: NEG
71405: PUSH
71406: EMPTY
71407: LIST
71408: LIST
71409: PUSH
71410: LD_INT 0
71412: PUSH
71413: LD_INT 3
71415: NEG
71416: PUSH
71417: EMPTY
71418: LIST
71419: LIST
71420: PUSH
71421: LD_INT 1
71423: PUSH
71424: LD_INT 2
71426: NEG
71427: PUSH
71428: EMPTY
71429: LIST
71430: LIST
71431: PUSH
71432: LD_INT 3
71434: PUSH
71435: LD_INT 2
71437: PUSH
71438: EMPTY
71439: LIST
71440: LIST
71441: PUSH
71442: LD_INT 3
71444: PUSH
71445: LD_INT 3
71447: PUSH
71448: EMPTY
71449: LIST
71450: LIST
71451: PUSH
71452: LD_INT 2
71454: PUSH
71455: LD_INT 3
71457: PUSH
71458: EMPTY
71459: LIST
71460: LIST
71461: PUSH
71462: LD_INT 1
71464: PUSH
71465: LD_INT 3
71467: PUSH
71468: EMPTY
71469: LIST
71470: LIST
71471: PUSH
71472: LD_INT 0
71474: PUSH
71475: LD_INT 3
71477: PUSH
71478: EMPTY
71479: LIST
71480: LIST
71481: PUSH
71482: LD_INT 1
71484: NEG
71485: PUSH
71486: LD_INT 2
71488: PUSH
71489: EMPTY
71490: LIST
71491: LIST
71492: PUSH
71493: LD_INT 3
71495: NEG
71496: PUSH
71497: LD_INT 2
71499: NEG
71500: PUSH
71501: EMPTY
71502: LIST
71503: LIST
71504: PUSH
71505: LD_INT 3
71507: NEG
71508: PUSH
71509: LD_INT 3
71511: NEG
71512: PUSH
71513: EMPTY
71514: LIST
71515: LIST
71516: PUSH
71517: EMPTY
71518: LIST
71519: LIST
71520: LIST
71521: LIST
71522: LIST
71523: LIST
71524: LIST
71525: LIST
71526: LIST
71527: LIST
71528: LIST
71529: LIST
71530: LIST
71531: LIST
71532: LIST
71533: LIST
71534: LIST
71535: LIST
71536: LIST
71537: LIST
71538: LIST
71539: LIST
71540: LIST
71541: LIST
71542: LIST
71543: LIST
71544: LIST
71545: LIST
71546: LIST
71547: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
71548: LD_ADDR_VAR 0 43
71552: PUSH
71553: LD_INT 0
71555: PUSH
71556: LD_INT 0
71558: PUSH
71559: EMPTY
71560: LIST
71561: LIST
71562: PUSH
71563: LD_INT 0
71565: PUSH
71566: LD_INT 1
71568: NEG
71569: PUSH
71570: EMPTY
71571: LIST
71572: LIST
71573: PUSH
71574: LD_INT 1
71576: PUSH
71577: LD_INT 0
71579: PUSH
71580: EMPTY
71581: LIST
71582: LIST
71583: PUSH
71584: LD_INT 1
71586: PUSH
71587: LD_INT 1
71589: PUSH
71590: EMPTY
71591: LIST
71592: LIST
71593: PUSH
71594: LD_INT 0
71596: PUSH
71597: LD_INT 1
71599: PUSH
71600: EMPTY
71601: LIST
71602: LIST
71603: PUSH
71604: LD_INT 1
71606: NEG
71607: PUSH
71608: LD_INT 0
71610: PUSH
71611: EMPTY
71612: LIST
71613: LIST
71614: PUSH
71615: LD_INT 1
71617: NEG
71618: PUSH
71619: LD_INT 1
71621: NEG
71622: PUSH
71623: EMPTY
71624: LIST
71625: LIST
71626: PUSH
71627: LD_INT 1
71629: NEG
71630: PUSH
71631: LD_INT 2
71633: NEG
71634: PUSH
71635: EMPTY
71636: LIST
71637: LIST
71638: PUSH
71639: LD_INT 0
71641: PUSH
71642: LD_INT 2
71644: NEG
71645: PUSH
71646: EMPTY
71647: LIST
71648: LIST
71649: PUSH
71650: LD_INT 1
71652: PUSH
71653: LD_INT 1
71655: NEG
71656: PUSH
71657: EMPTY
71658: LIST
71659: LIST
71660: PUSH
71661: LD_INT 2
71663: PUSH
71664: LD_INT 0
71666: PUSH
71667: EMPTY
71668: LIST
71669: LIST
71670: PUSH
71671: LD_INT 2
71673: PUSH
71674: LD_INT 1
71676: PUSH
71677: EMPTY
71678: LIST
71679: LIST
71680: PUSH
71681: LD_INT 1
71683: PUSH
71684: LD_INT 2
71686: PUSH
71687: EMPTY
71688: LIST
71689: LIST
71690: PUSH
71691: LD_INT 0
71693: PUSH
71694: LD_INT 2
71696: PUSH
71697: EMPTY
71698: LIST
71699: LIST
71700: PUSH
71701: LD_INT 1
71703: NEG
71704: PUSH
71705: LD_INT 1
71707: PUSH
71708: EMPTY
71709: LIST
71710: LIST
71711: PUSH
71712: LD_INT 2
71714: NEG
71715: PUSH
71716: LD_INT 0
71718: PUSH
71719: EMPTY
71720: LIST
71721: LIST
71722: PUSH
71723: LD_INT 2
71725: NEG
71726: PUSH
71727: LD_INT 1
71729: NEG
71730: PUSH
71731: EMPTY
71732: LIST
71733: LIST
71734: PUSH
71735: LD_INT 1
71737: NEG
71738: PUSH
71739: LD_INT 3
71741: NEG
71742: PUSH
71743: EMPTY
71744: LIST
71745: LIST
71746: PUSH
71747: LD_INT 0
71749: PUSH
71750: LD_INT 3
71752: NEG
71753: PUSH
71754: EMPTY
71755: LIST
71756: LIST
71757: PUSH
71758: LD_INT 1
71760: PUSH
71761: LD_INT 2
71763: NEG
71764: PUSH
71765: EMPTY
71766: LIST
71767: LIST
71768: PUSH
71769: LD_INT 2
71771: PUSH
71772: LD_INT 1
71774: NEG
71775: PUSH
71776: EMPTY
71777: LIST
71778: LIST
71779: PUSH
71780: LD_INT 3
71782: PUSH
71783: LD_INT 0
71785: PUSH
71786: EMPTY
71787: LIST
71788: LIST
71789: PUSH
71790: LD_INT 3
71792: PUSH
71793: LD_INT 1
71795: PUSH
71796: EMPTY
71797: LIST
71798: LIST
71799: PUSH
71800: LD_INT 1
71802: PUSH
71803: LD_INT 3
71805: PUSH
71806: EMPTY
71807: LIST
71808: LIST
71809: PUSH
71810: LD_INT 0
71812: PUSH
71813: LD_INT 3
71815: PUSH
71816: EMPTY
71817: LIST
71818: LIST
71819: PUSH
71820: LD_INT 1
71822: NEG
71823: PUSH
71824: LD_INT 2
71826: PUSH
71827: EMPTY
71828: LIST
71829: LIST
71830: PUSH
71831: LD_INT 2
71833: NEG
71834: PUSH
71835: LD_INT 1
71837: PUSH
71838: EMPTY
71839: LIST
71840: LIST
71841: PUSH
71842: LD_INT 3
71844: NEG
71845: PUSH
71846: LD_INT 0
71848: PUSH
71849: EMPTY
71850: LIST
71851: LIST
71852: PUSH
71853: LD_INT 3
71855: NEG
71856: PUSH
71857: LD_INT 1
71859: NEG
71860: PUSH
71861: EMPTY
71862: LIST
71863: LIST
71864: PUSH
71865: EMPTY
71866: LIST
71867: LIST
71868: LIST
71869: LIST
71870: LIST
71871: LIST
71872: LIST
71873: LIST
71874: LIST
71875: LIST
71876: LIST
71877: LIST
71878: LIST
71879: LIST
71880: LIST
71881: LIST
71882: LIST
71883: LIST
71884: LIST
71885: LIST
71886: LIST
71887: LIST
71888: LIST
71889: LIST
71890: LIST
71891: LIST
71892: LIST
71893: LIST
71894: LIST
71895: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71896: LD_ADDR_VAR 0 44
71900: PUSH
71901: LD_INT 0
71903: PUSH
71904: LD_INT 0
71906: PUSH
71907: EMPTY
71908: LIST
71909: LIST
71910: PUSH
71911: LD_INT 0
71913: PUSH
71914: LD_INT 1
71916: NEG
71917: PUSH
71918: EMPTY
71919: LIST
71920: LIST
71921: PUSH
71922: LD_INT 1
71924: PUSH
71925: LD_INT 0
71927: PUSH
71928: EMPTY
71929: LIST
71930: LIST
71931: PUSH
71932: LD_INT 1
71934: PUSH
71935: LD_INT 1
71937: PUSH
71938: EMPTY
71939: LIST
71940: LIST
71941: PUSH
71942: LD_INT 0
71944: PUSH
71945: LD_INT 1
71947: PUSH
71948: EMPTY
71949: LIST
71950: LIST
71951: PUSH
71952: LD_INT 1
71954: NEG
71955: PUSH
71956: LD_INT 0
71958: PUSH
71959: EMPTY
71960: LIST
71961: LIST
71962: PUSH
71963: LD_INT 1
71965: NEG
71966: PUSH
71967: LD_INT 1
71969: NEG
71970: PUSH
71971: EMPTY
71972: LIST
71973: LIST
71974: PUSH
71975: LD_INT 1
71977: NEG
71978: PUSH
71979: LD_INT 2
71981: NEG
71982: PUSH
71983: EMPTY
71984: LIST
71985: LIST
71986: PUSH
71987: LD_INT 1
71989: PUSH
71990: LD_INT 1
71992: NEG
71993: PUSH
71994: EMPTY
71995: LIST
71996: LIST
71997: PUSH
71998: LD_INT 2
72000: PUSH
72001: LD_INT 0
72003: PUSH
72004: EMPTY
72005: LIST
72006: LIST
72007: PUSH
72008: LD_INT 2
72010: PUSH
72011: LD_INT 1
72013: PUSH
72014: EMPTY
72015: LIST
72016: LIST
72017: PUSH
72018: LD_INT 2
72020: PUSH
72021: LD_INT 2
72023: PUSH
72024: EMPTY
72025: LIST
72026: LIST
72027: PUSH
72028: LD_INT 1
72030: PUSH
72031: LD_INT 2
72033: PUSH
72034: EMPTY
72035: LIST
72036: LIST
72037: PUSH
72038: LD_INT 1
72040: NEG
72041: PUSH
72042: LD_INT 1
72044: PUSH
72045: EMPTY
72046: LIST
72047: LIST
72048: PUSH
72049: LD_INT 2
72051: NEG
72052: PUSH
72053: LD_INT 0
72055: PUSH
72056: EMPTY
72057: LIST
72058: LIST
72059: PUSH
72060: LD_INT 2
72062: NEG
72063: PUSH
72064: LD_INT 1
72066: NEG
72067: PUSH
72068: EMPTY
72069: LIST
72070: LIST
72071: PUSH
72072: LD_INT 2
72074: NEG
72075: PUSH
72076: LD_INT 2
72078: NEG
72079: PUSH
72080: EMPTY
72081: LIST
72082: LIST
72083: PUSH
72084: LD_INT 2
72086: NEG
72087: PUSH
72088: LD_INT 3
72090: NEG
72091: PUSH
72092: EMPTY
72093: LIST
72094: LIST
72095: PUSH
72096: LD_INT 2
72098: PUSH
72099: LD_INT 1
72101: NEG
72102: PUSH
72103: EMPTY
72104: LIST
72105: LIST
72106: PUSH
72107: LD_INT 3
72109: PUSH
72110: LD_INT 0
72112: PUSH
72113: EMPTY
72114: LIST
72115: LIST
72116: PUSH
72117: LD_INT 3
72119: PUSH
72120: LD_INT 1
72122: PUSH
72123: EMPTY
72124: LIST
72125: LIST
72126: PUSH
72127: LD_INT 3
72129: PUSH
72130: LD_INT 2
72132: PUSH
72133: EMPTY
72134: LIST
72135: LIST
72136: PUSH
72137: LD_INT 3
72139: PUSH
72140: LD_INT 3
72142: PUSH
72143: EMPTY
72144: LIST
72145: LIST
72146: PUSH
72147: LD_INT 2
72149: PUSH
72150: LD_INT 3
72152: PUSH
72153: EMPTY
72154: LIST
72155: LIST
72156: PUSH
72157: LD_INT 2
72159: NEG
72160: PUSH
72161: LD_INT 1
72163: PUSH
72164: EMPTY
72165: LIST
72166: LIST
72167: PUSH
72168: LD_INT 3
72170: NEG
72171: PUSH
72172: LD_INT 0
72174: PUSH
72175: EMPTY
72176: LIST
72177: LIST
72178: PUSH
72179: LD_INT 3
72181: NEG
72182: PUSH
72183: LD_INT 1
72185: NEG
72186: PUSH
72187: EMPTY
72188: LIST
72189: LIST
72190: PUSH
72191: LD_INT 3
72193: NEG
72194: PUSH
72195: LD_INT 2
72197: NEG
72198: PUSH
72199: EMPTY
72200: LIST
72201: LIST
72202: PUSH
72203: LD_INT 3
72205: NEG
72206: PUSH
72207: LD_INT 3
72209: NEG
72210: PUSH
72211: EMPTY
72212: LIST
72213: LIST
72214: PUSH
72215: EMPTY
72216: LIST
72217: LIST
72218: LIST
72219: LIST
72220: LIST
72221: LIST
72222: LIST
72223: LIST
72224: LIST
72225: LIST
72226: LIST
72227: LIST
72228: LIST
72229: LIST
72230: LIST
72231: LIST
72232: LIST
72233: LIST
72234: LIST
72235: LIST
72236: LIST
72237: LIST
72238: LIST
72239: LIST
72240: LIST
72241: LIST
72242: LIST
72243: LIST
72244: LIST
72245: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72246: LD_ADDR_VAR 0 45
72250: PUSH
72251: LD_INT 0
72253: PUSH
72254: LD_INT 0
72256: PUSH
72257: EMPTY
72258: LIST
72259: LIST
72260: PUSH
72261: LD_INT 0
72263: PUSH
72264: LD_INT 1
72266: NEG
72267: PUSH
72268: EMPTY
72269: LIST
72270: LIST
72271: PUSH
72272: LD_INT 1
72274: PUSH
72275: LD_INT 0
72277: PUSH
72278: EMPTY
72279: LIST
72280: LIST
72281: PUSH
72282: LD_INT 1
72284: PUSH
72285: LD_INT 1
72287: PUSH
72288: EMPTY
72289: LIST
72290: LIST
72291: PUSH
72292: LD_INT 0
72294: PUSH
72295: LD_INT 1
72297: PUSH
72298: EMPTY
72299: LIST
72300: LIST
72301: PUSH
72302: LD_INT 1
72304: NEG
72305: PUSH
72306: LD_INT 0
72308: PUSH
72309: EMPTY
72310: LIST
72311: LIST
72312: PUSH
72313: LD_INT 1
72315: NEG
72316: PUSH
72317: LD_INT 1
72319: NEG
72320: PUSH
72321: EMPTY
72322: LIST
72323: LIST
72324: PUSH
72325: LD_INT 1
72327: NEG
72328: PUSH
72329: LD_INT 2
72331: NEG
72332: PUSH
72333: EMPTY
72334: LIST
72335: LIST
72336: PUSH
72337: LD_INT 0
72339: PUSH
72340: LD_INT 2
72342: NEG
72343: PUSH
72344: EMPTY
72345: LIST
72346: LIST
72347: PUSH
72348: LD_INT 1
72350: PUSH
72351: LD_INT 1
72353: NEG
72354: PUSH
72355: EMPTY
72356: LIST
72357: LIST
72358: PUSH
72359: LD_INT 2
72361: PUSH
72362: LD_INT 1
72364: PUSH
72365: EMPTY
72366: LIST
72367: LIST
72368: PUSH
72369: LD_INT 2
72371: PUSH
72372: LD_INT 2
72374: PUSH
72375: EMPTY
72376: LIST
72377: LIST
72378: PUSH
72379: LD_INT 1
72381: PUSH
72382: LD_INT 2
72384: PUSH
72385: EMPTY
72386: LIST
72387: LIST
72388: PUSH
72389: LD_INT 0
72391: PUSH
72392: LD_INT 2
72394: PUSH
72395: EMPTY
72396: LIST
72397: LIST
72398: PUSH
72399: LD_INT 1
72401: NEG
72402: PUSH
72403: LD_INT 1
72405: PUSH
72406: EMPTY
72407: LIST
72408: LIST
72409: PUSH
72410: LD_INT 2
72412: NEG
72413: PUSH
72414: LD_INT 1
72416: NEG
72417: PUSH
72418: EMPTY
72419: LIST
72420: LIST
72421: PUSH
72422: LD_INT 2
72424: NEG
72425: PUSH
72426: LD_INT 2
72428: NEG
72429: PUSH
72430: EMPTY
72431: LIST
72432: LIST
72433: PUSH
72434: LD_INT 2
72436: NEG
72437: PUSH
72438: LD_INT 3
72440: NEG
72441: PUSH
72442: EMPTY
72443: LIST
72444: LIST
72445: PUSH
72446: LD_INT 1
72448: NEG
72449: PUSH
72450: LD_INT 3
72452: NEG
72453: PUSH
72454: EMPTY
72455: LIST
72456: LIST
72457: PUSH
72458: LD_INT 0
72460: PUSH
72461: LD_INT 3
72463: NEG
72464: PUSH
72465: EMPTY
72466: LIST
72467: LIST
72468: PUSH
72469: LD_INT 1
72471: PUSH
72472: LD_INT 2
72474: NEG
72475: PUSH
72476: EMPTY
72477: LIST
72478: LIST
72479: PUSH
72480: LD_INT 3
72482: PUSH
72483: LD_INT 2
72485: PUSH
72486: EMPTY
72487: LIST
72488: LIST
72489: PUSH
72490: LD_INT 3
72492: PUSH
72493: LD_INT 3
72495: PUSH
72496: EMPTY
72497: LIST
72498: LIST
72499: PUSH
72500: LD_INT 2
72502: PUSH
72503: LD_INT 3
72505: PUSH
72506: EMPTY
72507: LIST
72508: LIST
72509: PUSH
72510: LD_INT 1
72512: PUSH
72513: LD_INT 3
72515: PUSH
72516: EMPTY
72517: LIST
72518: LIST
72519: PUSH
72520: LD_INT 0
72522: PUSH
72523: LD_INT 3
72525: PUSH
72526: EMPTY
72527: LIST
72528: LIST
72529: PUSH
72530: LD_INT 1
72532: NEG
72533: PUSH
72534: LD_INT 2
72536: PUSH
72537: EMPTY
72538: LIST
72539: LIST
72540: PUSH
72541: LD_INT 3
72543: NEG
72544: PUSH
72545: LD_INT 2
72547: NEG
72548: PUSH
72549: EMPTY
72550: LIST
72551: LIST
72552: PUSH
72553: LD_INT 3
72555: NEG
72556: PUSH
72557: LD_INT 3
72559: NEG
72560: PUSH
72561: EMPTY
72562: LIST
72563: LIST
72564: PUSH
72565: EMPTY
72566: LIST
72567: LIST
72568: LIST
72569: LIST
72570: LIST
72571: LIST
72572: LIST
72573: LIST
72574: LIST
72575: LIST
72576: LIST
72577: LIST
72578: LIST
72579: LIST
72580: LIST
72581: LIST
72582: LIST
72583: LIST
72584: LIST
72585: LIST
72586: LIST
72587: LIST
72588: LIST
72589: LIST
72590: LIST
72591: LIST
72592: LIST
72593: LIST
72594: LIST
72595: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
72596: LD_ADDR_VAR 0 46
72600: PUSH
72601: LD_INT 0
72603: PUSH
72604: LD_INT 0
72606: PUSH
72607: EMPTY
72608: LIST
72609: LIST
72610: PUSH
72611: LD_INT 0
72613: PUSH
72614: LD_INT 1
72616: NEG
72617: PUSH
72618: EMPTY
72619: LIST
72620: LIST
72621: PUSH
72622: LD_INT 1
72624: PUSH
72625: LD_INT 0
72627: PUSH
72628: EMPTY
72629: LIST
72630: LIST
72631: PUSH
72632: LD_INT 1
72634: PUSH
72635: LD_INT 1
72637: PUSH
72638: EMPTY
72639: LIST
72640: LIST
72641: PUSH
72642: LD_INT 0
72644: PUSH
72645: LD_INT 1
72647: PUSH
72648: EMPTY
72649: LIST
72650: LIST
72651: PUSH
72652: LD_INT 1
72654: NEG
72655: PUSH
72656: LD_INT 0
72658: PUSH
72659: EMPTY
72660: LIST
72661: LIST
72662: PUSH
72663: LD_INT 1
72665: NEG
72666: PUSH
72667: LD_INT 1
72669: NEG
72670: PUSH
72671: EMPTY
72672: LIST
72673: LIST
72674: PUSH
72675: LD_INT 1
72677: NEG
72678: PUSH
72679: LD_INT 2
72681: NEG
72682: PUSH
72683: EMPTY
72684: LIST
72685: LIST
72686: PUSH
72687: LD_INT 0
72689: PUSH
72690: LD_INT 2
72692: NEG
72693: PUSH
72694: EMPTY
72695: LIST
72696: LIST
72697: PUSH
72698: LD_INT 1
72700: PUSH
72701: LD_INT 1
72703: NEG
72704: PUSH
72705: EMPTY
72706: LIST
72707: LIST
72708: PUSH
72709: LD_INT 2
72711: PUSH
72712: LD_INT 0
72714: PUSH
72715: EMPTY
72716: LIST
72717: LIST
72718: PUSH
72719: LD_INT 2
72721: PUSH
72722: LD_INT 1
72724: PUSH
72725: EMPTY
72726: LIST
72727: LIST
72728: PUSH
72729: LD_INT 1
72731: PUSH
72732: LD_INT 2
72734: PUSH
72735: EMPTY
72736: LIST
72737: LIST
72738: PUSH
72739: LD_INT 0
72741: PUSH
72742: LD_INT 2
72744: PUSH
72745: EMPTY
72746: LIST
72747: LIST
72748: PUSH
72749: LD_INT 1
72751: NEG
72752: PUSH
72753: LD_INT 1
72755: PUSH
72756: EMPTY
72757: LIST
72758: LIST
72759: PUSH
72760: LD_INT 2
72762: NEG
72763: PUSH
72764: LD_INT 0
72766: PUSH
72767: EMPTY
72768: LIST
72769: LIST
72770: PUSH
72771: LD_INT 2
72773: NEG
72774: PUSH
72775: LD_INT 1
72777: NEG
72778: PUSH
72779: EMPTY
72780: LIST
72781: LIST
72782: PUSH
72783: LD_INT 1
72785: NEG
72786: PUSH
72787: LD_INT 3
72789: NEG
72790: PUSH
72791: EMPTY
72792: LIST
72793: LIST
72794: PUSH
72795: LD_INT 0
72797: PUSH
72798: LD_INT 3
72800: NEG
72801: PUSH
72802: EMPTY
72803: LIST
72804: LIST
72805: PUSH
72806: LD_INT 1
72808: PUSH
72809: LD_INT 2
72811: NEG
72812: PUSH
72813: EMPTY
72814: LIST
72815: LIST
72816: PUSH
72817: LD_INT 2
72819: PUSH
72820: LD_INT 1
72822: NEG
72823: PUSH
72824: EMPTY
72825: LIST
72826: LIST
72827: PUSH
72828: LD_INT 3
72830: PUSH
72831: LD_INT 0
72833: PUSH
72834: EMPTY
72835: LIST
72836: LIST
72837: PUSH
72838: LD_INT 3
72840: PUSH
72841: LD_INT 1
72843: PUSH
72844: EMPTY
72845: LIST
72846: LIST
72847: PUSH
72848: LD_INT 1
72850: PUSH
72851: LD_INT 3
72853: PUSH
72854: EMPTY
72855: LIST
72856: LIST
72857: PUSH
72858: LD_INT 0
72860: PUSH
72861: LD_INT 3
72863: PUSH
72864: EMPTY
72865: LIST
72866: LIST
72867: PUSH
72868: LD_INT 1
72870: NEG
72871: PUSH
72872: LD_INT 2
72874: PUSH
72875: EMPTY
72876: LIST
72877: LIST
72878: PUSH
72879: LD_INT 2
72881: NEG
72882: PUSH
72883: LD_INT 1
72885: PUSH
72886: EMPTY
72887: LIST
72888: LIST
72889: PUSH
72890: LD_INT 3
72892: NEG
72893: PUSH
72894: LD_INT 0
72896: PUSH
72897: EMPTY
72898: LIST
72899: LIST
72900: PUSH
72901: LD_INT 3
72903: NEG
72904: PUSH
72905: LD_INT 1
72907: NEG
72908: PUSH
72909: EMPTY
72910: LIST
72911: LIST
72912: PUSH
72913: EMPTY
72914: LIST
72915: LIST
72916: LIST
72917: LIST
72918: LIST
72919: LIST
72920: LIST
72921: LIST
72922: LIST
72923: LIST
72924: LIST
72925: LIST
72926: LIST
72927: LIST
72928: LIST
72929: LIST
72930: LIST
72931: LIST
72932: LIST
72933: LIST
72934: LIST
72935: LIST
72936: LIST
72937: LIST
72938: LIST
72939: LIST
72940: LIST
72941: LIST
72942: LIST
72943: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72944: LD_ADDR_VAR 0 47
72948: PUSH
72949: LD_INT 0
72951: PUSH
72952: LD_INT 0
72954: PUSH
72955: EMPTY
72956: LIST
72957: LIST
72958: PUSH
72959: LD_INT 0
72961: PUSH
72962: LD_INT 1
72964: NEG
72965: PUSH
72966: EMPTY
72967: LIST
72968: LIST
72969: PUSH
72970: LD_INT 1
72972: PUSH
72973: LD_INT 0
72975: PUSH
72976: EMPTY
72977: LIST
72978: LIST
72979: PUSH
72980: LD_INT 1
72982: PUSH
72983: LD_INT 1
72985: PUSH
72986: EMPTY
72987: LIST
72988: LIST
72989: PUSH
72990: LD_INT 0
72992: PUSH
72993: LD_INT 1
72995: PUSH
72996: EMPTY
72997: LIST
72998: LIST
72999: PUSH
73000: LD_INT 1
73002: NEG
73003: PUSH
73004: LD_INT 0
73006: PUSH
73007: EMPTY
73008: LIST
73009: LIST
73010: PUSH
73011: LD_INT 1
73013: NEG
73014: PUSH
73015: LD_INT 1
73017: NEG
73018: PUSH
73019: EMPTY
73020: LIST
73021: LIST
73022: PUSH
73023: LD_INT 1
73025: NEG
73026: PUSH
73027: LD_INT 2
73029: NEG
73030: PUSH
73031: EMPTY
73032: LIST
73033: LIST
73034: PUSH
73035: LD_INT 0
73037: PUSH
73038: LD_INT 2
73040: NEG
73041: PUSH
73042: EMPTY
73043: LIST
73044: LIST
73045: PUSH
73046: LD_INT 1
73048: PUSH
73049: LD_INT 1
73051: NEG
73052: PUSH
73053: EMPTY
73054: LIST
73055: LIST
73056: PUSH
73057: LD_INT 2
73059: NEG
73060: PUSH
73061: LD_INT 1
73063: NEG
73064: PUSH
73065: EMPTY
73066: LIST
73067: LIST
73068: PUSH
73069: LD_INT 2
73071: NEG
73072: PUSH
73073: LD_INT 2
73075: NEG
73076: PUSH
73077: EMPTY
73078: LIST
73079: LIST
73080: PUSH
73081: EMPTY
73082: LIST
73083: LIST
73084: LIST
73085: LIST
73086: LIST
73087: LIST
73088: LIST
73089: LIST
73090: LIST
73091: LIST
73092: LIST
73093: LIST
73094: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
73095: LD_ADDR_VAR 0 48
73099: PUSH
73100: LD_INT 0
73102: PUSH
73103: LD_INT 0
73105: PUSH
73106: EMPTY
73107: LIST
73108: LIST
73109: PUSH
73110: LD_INT 0
73112: PUSH
73113: LD_INT 1
73115: NEG
73116: PUSH
73117: EMPTY
73118: LIST
73119: LIST
73120: PUSH
73121: LD_INT 1
73123: PUSH
73124: LD_INT 0
73126: PUSH
73127: EMPTY
73128: LIST
73129: LIST
73130: PUSH
73131: LD_INT 1
73133: PUSH
73134: LD_INT 1
73136: PUSH
73137: EMPTY
73138: LIST
73139: LIST
73140: PUSH
73141: LD_INT 0
73143: PUSH
73144: LD_INT 1
73146: PUSH
73147: EMPTY
73148: LIST
73149: LIST
73150: PUSH
73151: LD_INT 1
73153: NEG
73154: PUSH
73155: LD_INT 0
73157: PUSH
73158: EMPTY
73159: LIST
73160: LIST
73161: PUSH
73162: LD_INT 1
73164: NEG
73165: PUSH
73166: LD_INT 1
73168: NEG
73169: PUSH
73170: EMPTY
73171: LIST
73172: LIST
73173: PUSH
73174: LD_INT 1
73176: NEG
73177: PUSH
73178: LD_INT 2
73180: NEG
73181: PUSH
73182: EMPTY
73183: LIST
73184: LIST
73185: PUSH
73186: LD_INT 0
73188: PUSH
73189: LD_INT 2
73191: NEG
73192: PUSH
73193: EMPTY
73194: LIST
73195: LIST
73196: PUSH
73197: LD_INT 1
73199: PUSH
73200: LD_INT 1
73202: NEG
73203: PUSH
73204: EMPTY
73205: LIST
73206: LIST
73207: PUSH
73208: LD_INT 2
73210: PUSH
73211: LD_INT 0
73213: PUSH
73214: EMPTY
73215: LIST
73216: LIST
73217: PUSH
73218: LD_INT 2
73220: PUSH
73221: LD_INT 1
73223: PUSH
73224: EMPTY
73225: LIST
73226: LIST
73227: PUSH
73228: EMPTY
73229: LIST
73230: LIST
73231: LIST
73232: LIST
73233: LIST
73234: LIST
73235: LIST
73236: LIST
73237: LIST
73238: LIST
73239: LIST
73240: LIST
73241: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
73242: LD_ADDR_VAR 0 49
73246: PUSH
73247: LD_INT 0
73249: PUSH
73250: LD_INT 0
73252: PUSH
73253: EMPTY
73254: LIST
73255: LIST
73256: PUSH
73257: LD_INT 0
73259: PUSH
73260: LD_INT 1
73262: NEG
73263: PUSH
73264: EMPTY
73265: LIST
73266: LIST
73267: PUSH
73268: LD_INT 1
73270: PUSH
73271: LD_INT 0
73273: PUSH
73274: EMPTY
73275: LIST
73276: LIST
73277: PUSH
73278: LD_INT 1
73280: PUSH
73281: LD_INT 1
73283: PUSH
73284: EMPTY
73285: LIST
73286: LIST
73287: PUSH
73288: LD_INT 0
73290: PUSH
73291: LD_INT 1
73293: PUSH
73294: EMPTY
73295: LIST
73296: LIST
73297: PUSH
73298: LD_INT 1
73300: NEG
73301: PUSH
73302: LD_INT 0
73304: PUSH
73305: EMPTY
73306: LIST
73307: LIST
73308: PUSH
73309: LD_INT 1
73311: NEG
73312: PUSH
73313: LD_INT 1
73315: NEG
73316: PUSH
73317: EMPTY
73318: LIST
73319: LIST
73320: PUSH
73321: LD_INT 1
73323: PUSH
73324: LD_INT 1
73326: NEG
73327: PUSH
73328: EMPTY
73329: LIST
73330: LIST
73331: PUSH
73332: LD_INT 2
73334: PUSH
73335: LD_INT 0
73337: PUSH
73338: EMPTY
73339: LIST
73340: LIST
73341: PUSH
73342: LD_INT 2
73344: PUSH
73345: LD_INT 1
73347: PUSH
73348: EMPTY
73349: LIST
73350: LIST
73351: PUSH
73352: LD_INT 2
73354: PUSH
73355: LD_INT 2
73357: PUSH
73358: EMPTY
73359: LIST
73360: LIST
73361: PUSH
73362: LD_INT 1
73364: PUSH
73365: LD_INT 2
73367: PUSH
73368: EMPTY
73369: LIST
73370: LIST
73371: PUSH
73372: EMPTY
73373: LIST
73374: LIST
73375: LIST
73376: LIST
73377: LIST
73378: LIST
73379: LIST
73380: LIST
73381: LIST
73382: LIST
73383: LIST
73384: LIST
73385: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
73386: LD_ADDR_VAR 0 50
73390: PUSH
73391: LD_INT 0
73393: PUSH
73394: LD_INT 0
73396: PUSH
73397: EMPTY
73398: LIST
73399: LIST
73400: PUSH
73401: LD_INT 0
73403: PUSH
73404: LD_INT 1
73406: NEG
73407: PUSH
73408: EMPTY
73409: LIST
73410: LIST
73411: PUSH
73412: LD_INT 1
73414: PUSH
73415: LD_INT 0
73417: PUSH
73418: EMPTY
73419: LIST
73420: LIST
73421: PUSH
73422: LD_INT 1
73424: PUSH
73425: LD_INT 1
73427: PUSH
73428: EMPTY
73429: LIST
73430: LIST
73431: PUSH
73432: LD_INT 0
73434: PUSH
73435: LD_INT 1
73437: PUSH
73438: EMPTY
73439: LIST
73440: LIST
73441: PUSH
73442: LD_INT 1
73444: NEG
73445: PUSH
73446: LD_INT 0
73448: PUSH
73449: EMPTY
73450: LIST
73451: LIST
73452: PUSH
73453: LD_INT 1
73455: NEG
73456: PUSH
73457: LD_INT 1
73459: NEG
73460: PUSH
73461: EMPTY
73462: LIST
73463: LIST
73464: PUSH
73465: LD_INT 2
73467: PUSH
73468: LD_INT 1
73470: PUSH
73471: EMPTY
73472: LIST
73473: LIST
73474: PUSH
73475: LD_INT 2
73477: PUSH
73478: LD_INT 2
73480: PUSH
73481: EMPTY
73482: LIST
73483: LIST
73484: PUSH
73485: LD_INT 1
73487: PUSH
73488: LD_INT 2
73490: PUSH
73491: EMPTY
73492: LIST
73493: LIST
73494: PUSH
73495: LD_INT 0
73497: PUSH
73498: LD_INT 2
73500: PUSH
73501: EMPTY
73502: LIST
73503: LIST
73504: PUSH
73505: LD_INT 1
73507: NEG
73508: PUSH
73509: LD_INT 1
73511: PUSH
73512: EMPTY
73513: LIST
73514: LIST
73515: PUSH
73516: EMPTY
73517: LIST
73518: LIST
73519: LIST
73520: LIST
73521: LIST
73522: LIST
73523: LIST
73524: LIST
73525: LIST
73526: LIST
73527: LIST
73528: LIST
73529: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
73530: LD_ADDR_VAR 0 51
73534: PUSH
73535: LD_INT 0
73537: PUSH
73538: LD_INT 0
73540: PUSH
73541: EMPTY
73542: LIST
73543: LIST
73544: PUSH
73545: LD_INT 0
73547: PUSH
73548: LD_INT 1
73550: NEG
73551: PUSH
73552: EMPTY
73553: LIST
73554: LIST
73555: PUSH
73556: LD_INT 1
73558: PUSH
73559: LD_INT 0
73561: PUSH
73562: EMPTY
73563: LIST
73564: LIST
73565: PUSH
73566: LD_INT 1
73568: PUSH
73569: LD_INT 1
73571: PUSH
73572: EMPTY
73573: LIST
73574: LIST
73575: PUSH
73576: LD_INT 0
73578: PUSH
73579: LD_INT 1
73581: PUSH
73582: EMPTY
73583: LIST
73584: LIST
73585: PUSH
73586: LD_INT 1
73588: NEG
73589: PUSH
73590: LD_INT 0
73592: PUSH
73593: EMPTY
73594: LIST
73595: LIST
73596: PUSH
73597: LD_INT 1
73599: NEG
73600: PUSH
73601: LD_INT 1
73603: NEG
73604: PUSH
73605: EMPTY
73606: LIST
73607: LIST
73608: PUSH
73609: LD_INT 1
73611: PUSH
73612: LD_INT 2
73614: PUSH
73615: EMPTY
73616: LIST
73617: LIST
73618: PUSH
73619: LD_INT 0
73621: PUSH
73622: LD_INT 2
73624: PUSH
73625: EMPTY
73626: LIST
73627: LIST
73628: PUSH
73629: LD_INT 1
73631: NEG
73632: PUSH
73633: LD_INT 1
73635: PUSH
73636: EMPTY
73637: LIST
73638: LIST
73639: PUSH
73640: LD_INT 2
73642: NEG
73643: PUSH
73644: LD_INT 0
73646: PUSH
73647: EMPTY
73648: LIST
73649: LIST
73650: PUSH
73651: LD_INT 2
73653: NEG
73654: PUSH
73655: LD_INT 1
73657: NEG
73658: PUSH
73659: EMPTY
73660: LIST
73661: LIST
73662: PUSH
73663: EMPTY
73664: LIST
73665: LIST
73666: LIST
73667: LIST
73668: LIST
73669: LIST
73670: LIST
73671: LIST
73672: LIST
73673: LIST
73674: LIST
73675: LIST
73676: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73677: LD_ADDR_VAR 0 52
73681: PUSH
73682: LD_INT 0
73684: PUSH
73685: LD_INT 0
73687: PUSH
73688: EMPTY
73689: LIST
73690: LIST
73691: PUSH
73692: LD_INT 0
73694: PUSH
73695: LD_INT 1
73697: NEG
73698: PUSH
73699: EMPTY
73700: LIST
73701: LIST
73702: PUSH
73703: LD_INT 1
73705: PUSH
73706: LD_INT 0
73708: PUSH
73709: EMPTY
73710: LIST
73711: LIST
73712: PUSH
73713: LD_INT 1
73715: PUSH
73716: LD_INT 1
73718: PUSH
73719: EMPTY
73720: LIST
73721: LIST
73722: PUSH
73723: LD_INT 0
73725: PUSH
73726: LD_INT 1
73728: PUSH
73729: EMPTY
73730: LIST
73731: LIST
73732: PUSH
73733: LD_INT 1
73735: NEG
73736: PUSH
73737: LD_INT 0
73739: PUSH
73740: EMPTY
73741: LIST
73742: LIST
73743: PUSH
73744: LD_INT 1
73746: NEG
73747: PUSH
73748: LD_INT 1
73750: NEG
73751: PUSH
73752: EMPTY
73753: LIST
73754: LIST
73755: PUSH
73756: LD_INT 1
73758: NEG
73759: PUSH
73760: LD_INT 2
73762: NEG
73763: PUSH
73764: EMPTY
73765: LIST
73766: LIST
73767: PUSH
73768: LD_INT 1
73770: NEG
73771: PUSH
73772: LD_INT 1
73774: PUSH
73775: EMPTY
73776: LIST
73777: LIST
73778: PUSH
73779: LD_INT 2
73781: NEG
73782: PUSH
73783: LD_INT 0
73785: PUSH
73786: EMPTY
73787: LIST
73788: LIST
73789: PUSH
73790: LD_INT 2
73792: NEG
73793: PUSH
73794: LD_INT 1
73796: NEG
73797: PUSH
73798: EMPTY
73799: LIST
73800: LIST
73801: PUSH
73802: LD_INT 2
73804: NEG
73805: PUSH
73806: LD_INT 2
73808: NEG
73809: PUSH
73810: EMPTY
73811: LIST
73812: LIST
73813: PUSH
73814: EMPTY
73815: LIST
73816: LIST
73817: LIST
73818: LIST
73819: LIST
73820: LIST
73821: LIST
73822: LIST
73823: LIST
73824: LIST
73825: LIST
73826: LIST
73827: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73828: LD_ADDR_VAR 0 53
73832: PUSH
73833: LD_INT 0
73835: PUSH
73836: LD_INT 0
73838: PUSH
73839: EMPTY
73840: LIST
73841: LIST
73842: PUSH
73843: LD_INT 0
73845: PUSH
73846: LD_INT 1
73848: NEG
73849: PUSH
73850: EMPTY
73851: LIST
73852: LIST
73853: PUSH
73854: LD_INT 1
73856: PUSH
73857: LD_INT 0
73859: PUSH
73860: EMPTY
73861: LIST
73862: LIST
73863: PUSH
73864: LD_INT 1
73866: PUSH
73867: LD_INT 1
73869: PUSH
73870: EMPTY
73871: LIST
73872: LIST
73873: PUSH
73874: LD_INT 0
73876: PUSH
73877: LD_INT 1
73879: PUSH
73880: EMPTY
73881: LIST
73882: LIST
73883: PUSH
73884: LD_INT 1
73886: NEG
73887: PUSH
73888: LD_INT 0
73890: PUSH
73891: EMPTY
73892: LIST
73893: LIST
73894: PUSH
73895: LD_INT 1
73897: NEG
73898: PUSH
73899: LD_INT 1
73901: NEG
73902: PUSH
73903: EMPTY
73904: LIST
73905: LIST
73906: PUSH
73907: LD_INT 1
73909: NEG
73910: PUSH
73911: LD_INT 2
73913: NEG
73914: PUSH
73915: EMPTY
73916: LIST
73917: LIST
73918: PUSH
73919: LD_INT 0
73921: PUSH
73922: LD_INT 2
73924: NEG
73925: PUSH
73926: EMPTY
73927: LIST
73928: LIST
73929: PUSH
73930: LD_INT 1
73932: PUSH
73933: LD_INT 1
73935: NEG
73936: PUSH
73937: EMPTY
73938: LIST
73939: LIST
73940: PUSH
73941: LD_INT 2
73943: PUSH
73944: LD_INT 0
73946: PUSH
73947: EMPTY
73948: LIST
73949: LIST
73950: PUSH
73951: LD_INT 2
73953: PUSH
73954: LD_INT 1
73956: PUSH
73957: EMPTY
73958: LIST
73959: LIST
73960: PUSH
73961: LD_INT 2
73963: PUSH
73964: LD_INT 2
73966: PUSH
73967: EMPTY
73968: LIST
73969: LIST
73970: PUSH
73971: LD_INT 1
73973: PUSH
73974: LD_INT 2
73976: PUSH
73977: EMPTY
73978: LIST
73979: LIST
73980: PUSH
73981: LD_INT 0
73983: PUSH
73984: LD_INT 2
73986: PUSH
73987: EMPTY
73988: LIST
73989: LIST
73990: PUSH
73991: LD_INT 1
73993: NEG
73994: PUSH
73995: LD_INT 1
73997: PUSH
73998: EMPTY
73999: LIST
74000: LIST
74001: PUSH
74002: LD_INT 2
74004: NEG
74005: PUSH
74006: LD_INT 0
74008: PUSH
74009: EMPTY
74010: LIST
74011: LIST
74012: PUSH
74013: LD_INT 2
74015: NEG
74016: PUSH
74017: LD_INT 1
74019: NEG
74020: PUSH
74021: EMPTY
74022: LIST
74023: LIST
74024: PUSH
74025: LD_INT 2
74027: NEG
74028: PUSH
74029: LD_INT 2
74031: NEG
74032: PUSH
74033: EMPTY
74034: LIST
74035: LIST
74036: PUSH
74037: EMPTY
74038: LIST
74039: LIST
74040: LIST
74041: LIST
74042: LIST
74043: LIST
74044: LIST
74045: LIST
74046: LIST
74047: LIST
74048: LIST
74049: LIST
74050: LIST
74051: LIST
74052: LIST
74053: LIST
74054: LIST
74055: LIST
74056: LIST
74057: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74058: LD_ADDR_VAR 0 54
74062: PUSH
74063: LD_INT 0
74065: PUSH
74066: LD_INT 0
74068: PUSH
74069: EMPTY
74070: LIST
74071: LIST
74072: PUSH
74073: LD_INT 0
74075: PUSH
74076: LD_INT 1
74078: NEG
74079: PUSH
74080: EMPTY
74081: LIST
74082: LIST
74083: PUSH
74084: LD_INT 1
74086: PUSH
74087: LD_INT 0
74089: PUSH
74090: EMPTY
74091: LIST
74092: LIST
74093: PUSH
74094: LD_INT 1
74096: PUSH
74097: LD_INT 1
74099: PUSH
74100: EMPTY
74101: LIST
74102: LIST
74103: PUSH
74104: LD_INT 0
74106: PUSH
74107: LD_INT 1
74109: PUSH
74110: EMPTY
74111: LIST
74112: LIST
74113: PUSH
74114: LD_INT 1
74116: NEG
74117: PUSH
74118: LD_INT 0
74120: PUSH
74121: EMPTY
74122: LIST
74123: LIST
74124: PUSH
74125: LD_INT 1
74127: NEG
74128: PUSH
74129: LD_INT 1
74131: NEG
74132: PUSH
74133: EMPTY
74134: LIST
74135: LIST
74136: PUSH
74137: LD_INT 1
74139: NEG
74140: PUSH
74141: LD_INT 2
74143: NEG
74144: PUSH
74145: EMPTY
74146: LIST
74147: LIST
74148: PUSH
74149: LD_INT 0
74151: PUSH
74152: LD_INT 2
74154: NEG
74155: PUSH
74156: EMPTY
74157: LIST
74158: LIST
74159: PUSH
74160: LD_INT 1
74162: PUSH
74163: LD_INT 1
74165: NEG
74166: PUSH
74167: EMPTY
74168: LIST
74169: LIST
74170: PUSH
74171: LD_INT 2
74173: PUSH
74174: LD_INT 0
74176: PUSH
74177: EMPTY
74178: LIST
74179: LIST
74180: PUSH
74181: LD_INT 2
74183: PUSH
74184: LD_INT 1
74186: PUSH
74187: EMPTY
74188: LIST
74189: LIST
74190: PUSH
74191: LD_INT 2
74193: PUSH
74194: LD_INT 2
74196: PUSH
74197: EMPTY
74198: LIST
74199: LIST
74200: PUSH
74201: LD_INT 1
74203: PUSH
74204: LD_INT 2
74206: PUSH
74207: EMPTY
74208: LIST
74209: LIST
74210: PUSH
74211: LD_INT 0
74213: PUSH
74214: LD_INT 2
74216: PUSH
74217: EMPTY
74218: LIST
74219: LIST
74220: PUSH
74221: LD_INT 1
74223: NEG
74224: PUSH
74225: LD_INT 1
74227: PUSH
74228: EMPTY
74229: LIST
74230: LIST
74231: PUSH
74232: LD_INT 2
74234: NEG
74235: PUSH
74236: LD_INT 0
74238: PUSH
74239: EMPTY
74240: LIST
74241: LIST
74242: PUSH
74243: LD_INT 2
74245: NEG
74246: PUSH
74247: LD_INT 1
74249: NEG
74250: PUSH
74251: EMPTY
74252: LIST
74253: LIST
74254: PUSH
74255: LD_INT 2
74257: NEG
74258: PUSH
74259: LD_INT 2
74261: NEG
74262: PUSH
74263: EMPTY
74264: LIST
74265: LIST
74266: PUSH
74267: EMPTY
74268: LIST
74269: LIST
74270: LIST
74271: LIST
74272: LIST
74273: LIST
74274: LIST
74275: LIST
74276: LIST
74277: LIST
74278: LIST
74279: LIST
74280: LIST
74281: LIST
74282: LIST
74283: LIST
74284: LIST
74285: LIST
74286: LIST
74287: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74288: LD_ADDR_VAR 0 55
74292: PUSH
74293: LD_INT 0
74295: PUSH
74296: LD_INT 0
74298: PUSH
74299: EMPTY
74300: LIST
74301: LIST
74302: PUSH
74303: LD_INT 0
74305: PUSH
74306: LD_INT 1
74308: NEG
74309: PUSH
74310: EMPTY
74311: LIST
74312: LIST
74313: PUSH
74314: LD_INT 1
74316: PUSH
74317: LD_INT 0
74319: PUSH
74320: EMPTY
74321: LIST
74322: LIST
74323: PUSH
74324: LD_INT 1
74326: PUSH
74327: LD_INT 1
74329: PUSH
74330: EMPTY
74331: LIST
74332: LIST
74333: PUSH
74334: LD_INT 0
74336: PUSH
74337: LD_INT 1
74339: PUSH
74340: EMPTY
74341: LIST
74342: LIST
74343: PUSH
74344: LD_INT 1
74346: NEG
74347: PUSH
74348: LD_INT 0
74350: PUSH
74351: EMPTY
74352: LIST
74353: LIST
74354: PUSH
74355: LD_INT 1
74357: NEG
74358: PUSH
74359: LD_INT 1
74361: NEG
74362: PUSH
74363: EMPTY
74364: LIST
74365: LIST
74366: PUSH
74367: LD_INT 1
74369: NEG
74370: PUSH
74371: LD_INT 2
74373: NEG
74374: PUSH
74375: EMPTY
74376: LIST
74377: LIST
74378: PUSH
74379: LD_INT 0
74381: PUSH
74382: LD_INT 2
74384: NEG
74385: PUSH
74386: EMPTY
74387: LIST
74388: LIST
74389: PUSH
74390: LD_INT 1
74392: PUSH
74393: LD_INT 1
74395: NEG
74396: PUSH
74397: EMPTY
74398: LIST
74399: LIST
74400: PUSH
74401: LD_INT 2
74403: PUSH
74404: LD_INT 0
74406: PUSH
74407: EMPTY
74408: LIST
74409: LIST
74410: PUSH
74411: LD_INT 2
74413: PUSH
74414: LD_INT 1
74416: PUSH
74417: EMPTY
74418: LIST
74419: LIST
74420: PUSH
74421: LD_INT 2
74423: PUSH
74424: LD_INT 2
74426: PUSH
74427: EMPTY
74428: LIST
74429: LIST
74430: PUSH
74431: LD_INT 1
74433: PUSH
74434: LD_INT 2
74436: PUSH
74437: EMPTY
74438: LIST
74439: LIST
74440: PUSH
74441: LD_INT 0
74443: PUSH
74444: LD_INT 2
74446: PUSH
74447: EMPTY
74448: LIST
74449: LIST
74450: PUSH
74451: LD_INT 1
74453: NEG
74454: PUSH
74455: LD_INT 1
74457: PUSH
74458: EMPTY
74459: LIST
74460: LIST
74461: PUSH
74462: LD_INT 2
74464: NEG
74465: PUSH
74466: LD_INT 0
74468: PUSH
74469: EMPTY
74470: LIST
74471: LIST
74472: PUSH
74473: LD_INT 2
74475: NEG
74476: PUSH
74477: LD_INT 1
74479: NEG
74480: PUSH
74481: EMPTY
74482: LIST
74483: LIST
74484: PUSH
74485: LD_INT 2
74487: NEG
74488: PUSH
74489: LD_INT 2
74491: NEG
74492: PUSH
74493: EMPTY
74494: LIST
74495: LIST
74496: PUSH
74497: EMPTY
74498: LIST
74499: LIST
74500: LIST
74501: LIST
74502: LIST
74503: LIST
74504: LIST
74505: LIST
74506: LIST
74507: LIST
74508: LIST
74509: LIST
74510: LIST
74511: LIST
74512: LIST
74513: LIST
74514: LIST
74515: LIST
74516: LIST
74517: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74518: LD_ADDR_VAR 0 56
74522: PUSH
74523: LD_INT 0
74525: PUSH
74526: LD_INT 0
74528: PUSH
74529: EMPTY
74530: LIST
74531: LIST
74532: PUSH
74533: LD_INT 0
74535: PUSH
74536: LD_INT 1
74538: NEG
74539: PUSH
74540: EMPTY
74541: LIST
74542: LIST
74543: PUSH
74544: LD_INT 1
74546: PUSH
74547: LD_INT 0
74549: PUSH
74550: EMPTY
74551: LIST
74552: LIST
74553: PUSH
74554: LD_INT 1
74556: PUSH
74557: LD_INT 1
74559: PUSH
74560: EMPTY
74561: LIST
74562: LIST
74563: PUSH
74564: LD_INT 0
74566: PUSH
74567: LD_INT 1
74569: PUSH
74570: EMPTY
74571: LIST
74572: LIST
74573: PUSH
74574: LD_INT 1
74576: NEG
74577: PUSH
74578: LD_INT 0
74580: PUSH
74581: EMPTY
74582: LIST
74583: LIST
74584: PUSH
74585: LD_INT 1
74587: NEG
74588: PUSH
74589: LD_INT 1
74591: NEG
74592: PUSH
74593: EMPTY
74594: LIST
74595: LIST
74596: PUSH
74597: LD_INT 1
74599: NEG
74600: PUSH
74601: LD_INT 2
74603: NEG
74604: PUSH
74605: EMPTY
74606: LIST
74607: LIST
74608: PUSH
74609: LD_INT 0
74611: PUSH
74612: LD_INT 2
74614: NEG
74615: PUSH
74616: EMPTY
74617: LIST
74618: LIST
74619: PUSH
74620: LD_INT 1
74622: PUSH
74623: LD_INT 1
74625: NEG
74626: PUSH
74627: EMPTY
74628: LIST
74629: LIST
74630: PUSH
74631: LD_INT 2
74633: PUSH
74634: LD_INT 0
74636: PUSH
74637: EMPTY
74638: LIST
74639: LIST
74640: PUSH
74641: LD_INT 2
74643: PUSH
74644: LD_INT 1
74646: PUSH
74647: EMPTY
74648: LIST
74649: LIST
74650: PUSH
74651: LD_INT 2
74653: PUSH
74654: LD_INT 2
74656: PUSH
74657: EMPTY
74658: LIST
74659: LIST
74660: PUSH
74661: LD_INT 1
74663: PUSH
74664: LD_INT 2
74666: PUSH
74667: EMPTY
74668: LIST
74669: LIST
74670: PUSH
74671: LD_INT 0
74673: PUSH
74674: LD_INT 2
74676: PUSH
74677: EMPTY
74678: LIST
74679: LIST
74680: PUSH
74681: LD_INT 1
74683: NEG
74684: PUSH
74685: LD_INT 1
74687: PUSH
74688: EMPTY
74689: LIST
74690: LIST
74691: PUSH
74692: LD_INT 2
74694: NEG
74695: PUSH
74696: LD_INT 0
74698: PUSH
74699: EMPTY
74700: LIST
74701: LIST
74702: PUSH
74703: LD_INT 2
74705: NEG
74706: PUSH
74707: LD_INT 1
74709: NEG
74710: PUSH
74711: EMPTY
74712: LIST
74713: LIST
74714: PUSH
74715: LD_INT 2
74717: NEG
74718: PUSH
74719: LD_INT 2
74721: NEG
74722: PUSH
74723: EMPTY
74724: LIST
74725: LIST
74726: PUSH
74727: EMPTY
74728: LIST
74729: LIST
74730: LIST
74731: LIST
74732: LIST
74733: LIST
74734: LIST
74735: LIST
74736: LIST
74737: LIST
74738: LIST
74739: LIST
74740: LIST
74741: LIST
74742: LIST
74743: LIST
74744: LIST
74745: LIST
74746: LIST
74747: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74748: LD_ADDR_VAR 0 57
74752: PUSH
74753: LD_INT 0
74755: PUSH
74756: LD_INT 0
74758: PUSH
74759: EMPTY
74760: LIST
74761: LIST
74762: PUSH
74763: LD_INT 0
74765: PUSH
74766: LD_INT 1
74768: NEG
74769: PUSH
74770: EMPTY
74771: LIST
74772: LIST
74773: PUSH
74774: LD_INT 1
74776: PUSH
74777: LD_INT 0
74779: PUSH
74780: EMPTY
74781: LIST
74782: LIST
74783: PUSH
74784: LD_INT 1
74786: PUSH
74787: LD_INT 1
74789: PUSH
74790: EMPTY
74791: LIST
74792: LIST
74793: PUSH
74794: LD_INT 0
74796: PUSH
74797: LD_INT 1
74799: PUSH
74800: EMPTY
74801: LIST
74802: LIST
74803: PUSH
74804: LD_INT 1
74806: NEG
74807: PUSH
74808: LD_INT 0
74810: PUSH
74811: EMPTY
74812: LIST
74813: LIST
74814: PUSH
74815: LD_INT 1
74817: NEG
74818: PUSH
74819: LD_INT 1
74821: NEG
74822: PUSH
74823: EMPTY
74824: LIST
74825: LIST
74826: PUSH
74827: LD_INT 1
74829: NEG
74830: PUSH
74831: LD_INT 2
74833: NEG
74834: PUSH
74835: EMPTY
74836: LIST
74837: LIST
74838: PUSH
74839: LD_INT 0
74841: PUSH
74842: LD_INT 2
74844: NEG
74845: PUSH
74846: EMPTY
74847: LIST
74848: LIST
74849: PUSH
74850: LD_INT 1
74852: PUSH
74853: LD_INT 1
74855: NEG
74856: PUSH
74857: EMPTY
74858: LIST
74859: LIST
74860: PUSH
74861: LD_INT 2
74863: PUSH
74864: LD_INT 0
74866: PUSH
74867: EMPTY
74868: LIST
74869: LIST
74870: PUSH
74871: LD_INT 2
74873: PUSH
74874: LD_INT 1
74876: PUSH
74877: EMPTY
74878: LIST
74879: LIST
74880: PUSH
74881: LD_INT 2
74883: PUSH
74884: LD_INT 2
74886: PUSH
74887: EMPTY
74888: LIST
74889: LIST
74890: PUSH
74891: LD_INT 1
74893: PUSH
74894: LD_INT 2
74896: PUSH
74897: EMPTY
74898: LIST
74899: LIST
74900: PUSH
74901: LD_INT 0
74903: PUSH
74904: LD_INT 2
74906: PUSH
74907: EMPTY
74908: LIST
74909: LIST
74910: PUSH
74911: LD_INT 1
74913: NEG
74914: PUSH
74915: LD_INT 1
74917: PUSH
74918: EMPTY
74919: LIST
74920: LIST
74921: PUSH
74922: LD_INT 2
74924: NEG
74925: PUSH
74926: LD_INT 0
74928: PUSH
74929: EMPTY
74930: LIST
74931: LIST
74932: PUSH
74933: LD_INT 2
74935: NEG
74936: PUSH
74937: LD_INT 1
74939: NEG
74940: PUSH
74941: EMPTY
74942: LIST
74943: LIST
74944: PUSH
74945: LD_INT 2
74947: NEG
74948: PUSH
74949: LD_INT 2
74951: NEG
74952: PUSH
74953: EMPTY
74954: LIST
74955: LIST
74956: PUSH
74957: EMPTY
74958: LIST
74959: LIST
74960: LIST
74961: LIST
74962: LIST
74963: LIST
74964: LIST
74965: LIST
74966: LIST
74967: LIST
74968: LIST
74969: LIST
74970: LIST
74971: LIST
74972: LIST
74973: LIST
74974: LIST
74975: LIST
74976: LIST
74977: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74978: LD_ADDR_VAR 0 58
74982: PUSH
74983: LD_INT 0
74985: PUSH
74986: LD_INT 0
74988: PUSH
74989: EMPTY
74990: LIST
74991: LIST
74992: PUSH
74993: LD_INT 0
74995: PUSH
74996: LD_INT 1
74998: NEG
74999: PUSH
75000: EMPTY
75001: LIST
75002: LIST
75003: PUSH
75004: LD_INT 1
75006: PUSH
75007: LD_INT 0
75009: PUSH
75010: EMPTY
75011: LIST
75012: LIST
75013: PUSH
75014: LD_INT 1
75016: PUSH
75017: LD_INT 1
75019: PUSH
75020: EMPTY
75021: LIST
75022: LIST
75023: PUSH
75024: LD_INT 0
75026: PUSH
75027: LD_INT 1
75029: PUSH
75030: EMPTY
75031: LIST
75032: LIST
75033: PUSH
75034: LD_INT 1
75036: NEG
75037: PUSH
75038: LD_INT 0
75040: PUSH
75041: EMPTY
75042: LIST
75043: LIST
75044: PUSH
75045: LD_INT 1
75047: NEG
75048: PUSH
75049: LD_INT 1
75051: NEG
75052: PUSH
75053: EMPTY
75054: LIST
75055: LIST
75056: PUSH
75057: LD_INT 1
75059: NEG
75060: PUSH
75061: LD_INT 2
75063: NEG
75064: PUSH
75065: EMPTY
75066: LIST
75067: LIST
75068: PUSH
75069: LD_INT 0
75071: PUSH
75072: LD_INT 2
75074: NEG
75075: PUSH
75076: EMPTY
75077: LIST
75078: LIST
75079: PUSH
75080: LD_INT 1
75082: PUSH
75083: LD_INT 1
75085: NEG
75086: PUSH
75087: EMPTY
75088: LIST
75089: LIST
75090: PUSH
75091: LD_INT 2
75093: PUSH
75094: LD_INT 0
75096: PUSH
75097: EMPTY
75098: LIST
75099: LIST
75100: PUSH
75101: LD_INT 2
75103: PUSH
75104: LD_INT 1
75106: PUSH
75107: EMPTY
75108: LIST
75109: LIST
75110: PUSH
75111: LD_INT 2
75113: PUSH
75114: LD_INT 2
75116: PUSH
75117: EMPTY
75118: LIST
75119: LIST
75120: PUSH
75121: LD_INT 1
75123: PUSH
75124: LD_INT 2
75126: PUSH
75127: EMPTY
75128: LIST
75129: LIST
75130: PUSH
75131: LD_INT 0
75133: PUSH
75134: LD_INT 2
75136: PUSH
75137: EMPTY
75138: LIST
75139: LIST
75140: PUSH
75141: LD_INT 1
75143: NEG
75144: PUSH
75145: LD_INT 1
75147: PUSH
75148: EMPTY
75149: LIST
75150: LIST
75151: PUSH
75152: LD_INT 2
75154: NEG
75155: PUSH
75156: LD_INT 0
75158: PUSH
75159: EMPTY
75160: LIST
75161: LIST
75162: PUSH
75163: LD_INT 2
75165: NEG
75166: PUSH
75167: LD_INT 1
75169: NEG
75170: PUSH
75171: EMPTY
75172: LIST
75173: LIST
75174: PUSH
75175: LD_INT 2
75177: NEG
75178: PUSH
75179: LD_INT 2
75181: NEG
75182: PUSH
75183: EMPTY
75184: LIST
75185: LIST
75186: PUSH
75187: EMPTY
75188: LIST
75189: LIST
75190: LIST
75191: LIST
75192: LIST
75193: LIST
75194: LIST
75195: LIST
75196: LIST
75197: LIST
75198: LIST
75199: LIST
75200: LIST
75201: LIST
75202: LIST
75203: LIST
75204: LIST
75205: LIST
75206: LIST
75207: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75208: LD_ADDR_VAR 0 59
75212: PUSH
75213: LD_INT 0
75215: PUSH
75216: LD_INT 0
75218: PUSH
75219: EMPTY
75220: LIST
75221: LIST
75222: PUSH
75223: LD_INT 0
75225: PUSH
75226: LD_INT 1
75228: NEG
75229: PUSH
75230: EMPTY
75231: LIST
75232: LIST
75233: PUSH
75234: LD_INT 1
75236: PUSH
75237: LD_INT 0
75239: PUSH
75240: EMPTY
75241: LIST
75242: LIST
75243: PUSH
75244: LD_INT 1
75246: PUSH
75247: LD_INT 1
75249: PUSH
75250: EMPTY
75251: LIST
75252: LIST
75253: PUSH
75254: LD_INT 0
75256: PUSH
75257: LD_INT 1
75259: PUSH
75260: EMPTY
75261: LIST
75262: LIST
75263: PUSH
75264: LD_INT 1
75266: NEG
75267: PUSH
75268: LD_INT 0
75270: PUSH
75271: EMPTY
75272: LIST
75273: LIST
75274: PUSH
75275: LD_INT 1
75277: NEG
75278: PUSH
75279: LD_INT 1
75281: NEG
75282: PUSH
75283: EMPTY
75284: LIST
75285: LIST
75286: PUSH
75287: EMPTY
75288: LIST
75289: LIST
75290: LIST
75291: LIST
75292: LIST
75293: LIST
75294: LIST
75295: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75296: LD_ADDR_VAR 0 60
75300: PUSH
75301: LD_INT 0
75303: PUSH
75304: LD_INT 0
75306: PUSH
75307: EMPTY
75308: LIST
75309: LIST
75310: PUSH
75311: LD_INT 0
75313: PUSH
75314: LD_INT 1
75316: NEG
75317: PUSH
75318: EMPTY
75319: LIST
75320: LIST
75321: PUSH
75322: LD_INT 1
75324: PUSH
75325: LD_INT 0
75327: PUSH
75328: EMPTY
75329: LIST
75330: LIST
75331: PUSH
75332: LD_INT 1
75334: PUSH
75335: LD_INT 1
75337: PUSH
75338: EMPTY
75339: LIST
75340: LIST
75341: PUSH
75342: LD_INT 0
75344: PUSH
75345: LD_INT 1
75347: PUSH
75348: EMPTY
75349: LIST
75350: LIST
75351: PUSH
75352: LD_INT 1
75354: NEG
75355: PUSH
75356: LD_INT 0
75358: PUSH
75359: EMPTY
75360: LIST
75361: LIST
75362: PUSH
75363: LD_INT 1
75365: NEG
75366: PUSH
75367: LD_INT 1
75369: NEG
75370: PUSH
75371: EMPTY
75372: LIST
75373: LIST
75374: PUSH
75375: EMPTY
75376: LIST
75377: LIST
75378: LIST
75379: LIST
75380: LIST
75381: LIST
75382: LIST
75383: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75384: LD_ADDR_VAR 0 61
75388: PUSH
75389: LD_INT 0
75391: PUSH
75392: LD_INT 0
75394: PUSH
75395: EMPTY
75396: LIST
75397: LIST
75398: PUSH
75399: LD_INT 0
75401: PUSH
75402: LD_INT 1
75404: NEG
75405: PUSH
75406: EMPTY
75407: LIST
75408: LIST
75409: PUSH
75410: LD_INT 1
75412: PUSH
75413: LD_INT 0
75415: PUSH
75416: EMPTY
75417: LIST
75418: LIST
75419: PUSH
75420: LD_INT 1
75422: PUSH
75423: LD_INT 1
75425: PUSH
75426: EMPTY
75427: LIST
75428: LIST
75429: PUSH
75430: LD_INT 0
75432: PUSH
75433: LD_INT 1
75435: PUSH
75436: EMPTY
75437: LIST
75438: LIST
75439: PUSH
75440: LD_INT 1
75442: NEG
75443: PUSH
75444: LD_INT 0
75446: PUSH
75447: EMPTY
75448: LIST
75449: LIST
75450: PUSH
75451: LD_INT 1
75453: NEG
75454: PUSH
75455: LD_INT 1
75457: NEG
75458: PUSH
75459: EMPTY
75460: LIST
75461: LIST
75462: PUSH
75463: EMPTY
75464: LIST
75465: LIST
75466: LIST
75467: LIST
75468: LIST
75469: LIST
75470: LIST
75471: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75472: LD_ADDR_VAR 0 62
75476: PUSH
75477: LD_INT 0
75479: PUSH
75480: LD_INT 0
75482: PUSH
75483: EMPTY
75484: LIST
75485: LIST
75486: PUSH
75487: LD_INT 0
75489: PUSH
75490: LD_INT 1
75492: NEG
75493: PUSH
75494: EMPTY
75495: LIST
75496: LIST
75497: PUSH
75498: LD_INT 1
75500: PUSH
75501: LD_INT 0
75503: PUSH
75504: EMPTY
75505: LIST
75506: LIST
75507: PUSH
75508: LD_INT 1
75510: PUSH
75511: LD_INT 1
75513: PUSH
75514: EMPTY
75515: LIST
75516: LIST
75517: PUSH
75518: LD_INT 0
75520: PUSH
75521: LD_INT 1
75523: PUSH
75524: EMPTY
75525: LIST
75526: LIST
75527: PUSH
75528: LD_INT 1
75530: NEG
75531: PUSH
75532: LD_INT 0
75534: PUSH
75535: EMPTY
75536: LIST
75537: LIST
75538: PUSH
75539: LD_INT 1
75541: NEG
75542: PUSH
75543: LD_INT 1
75545: NEG
75546: PUSH
75547: EMPTY
75548: LIST
75549: LIST
75550: PUSH
75551: EMPTY
75552: LIST
75553: LIST
75554: LIST
75555: LIST
75556: LIST
75557: LIST
75558: LIST
75559: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75560: LD_ADDR_VAR 0 63
75564: PUSH
75565: LD_INT 0
75567: PUSH
75568: LD_INT 0
75570: PUSH
75571: EMPTY
75572: LIST
75573: LIST
75574: PUSH
75575: LD_INT 0
75577: PUSH
75578: LD_INT 1
75580: NEG
75581: PUSH
75582: EMPTY
75583: LIST
75584: LIST
75585: PUSH
75586: LD_INT 1
75588: PUSH
75589: LD_INT 0
75591: PUSH
75592: EMPTY
75593: LIST
75594: LIST
75595: PUSH
75596: LD_INT 1
75598: PUSH
75599: LD_INT 1
75601: PUSH
75602: EMPTY
75603: LIST
75604: LIST
75605: PUSH
75606: LD_INT 0
75608: PUSH
75609: LD_INT 1
75611: PUSH
75612: EMPTY
75613: LIST
75614: LIST
75615: PUSH
75616: LD_INT 1
75618: NEG
75619: PUSH
75620: LD_INT 0
75622: PUSH
75623: EMPTY
75624: LIST
75625: LIST
75626: PUSH
75627: LD_INT 1
75629: NEG
75630: PUSH
75631: LD_INT 1
75633: NEG
75634: PUSH
75635: EMPTY
75636: LIST
75637: LIST
75638: PUSH
75639: EMPTY
75640: LIST
75641: LIST
75642: LIST
75643: LIST
75644: LIST
75645: LIST
75646: LIST
75647: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75648: LD_ADDR_VAR 0 64
75652: PUSH
75653: LD_INT 0
75655: PUSH
75656: LD_INT 0
75658: PUSH
75659: EMPTY
75660: LIST
75661: LIST
75662: PUSH
75663: LD_INT 0
75665: PUSH
75666: LD_INT 1
75668: NEG
75669: PUSH
75670: EMPTY
75671: LIST
75672: LIST
75673: PUSH
75674: LD_INT 1
75676: PUSH
75677: LD_INT 0
75679: PUSH
75680: EMPTY
75681: LIST
75682: LIST
75683: PUSH
75684: LD_INT 1
75686: PUSH
75687: LD_INT 1
75689: PUSH
75690: EMPTY
75691: LIST
75692: LIST
75693: PUSH
75694: LD_INT 0
75696: PUSH
75697: LD_INT 1
75699: PUSH
75700: EMPTY
75701: LIST
75702: LIST
75703: PUSH
75704: LD_INT 1
75706: NEG
75707: PUSH
75708: LD_INT 0
75710: PUSH
75711: EMPTY
75712: LIST
75713: LIST
75714: PUSH
75715: LD_INT 1
75717: NEG
75718: PUSH
75719: LD_INT 1
75721: NEG
75722: PUSH
75723: EMPTY
75724: LIST
75725: LIST
75726: PUSH
75727: EMPTY
75728: LIST
75729: LIST
75730: LIST
75731: LIST
75732: LIST
75733: LIST
75734: LIST
75735: ST_TO_ADDR
// end ; 1 :
75736: GO 81633
75738: LD_INT 1
75740: DOUBLE
75741: EQUAL
75742: IFTRUE 75746
75744: GO 78369
75746: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
75747: LD_ADDR_VAR 0 11
75751: PUSH
75752: LD_INT 1
75754: NEG
75755: PUSH
75756: LD_INT 3
75758: NEG
75759: PUSH
75760: EMPTY
75761: LIST
75762: LIST
75763: PUSH
75764: LD_INT 0
75766: PUSH
75767: LD_INT 3
75769: NEG
75770: PUSH
75771: EMPTY
75772: LIST
75773: LIST
75774: PUSH
75775: LD_INT 1
75777: PUSH
75778: LD_INT 2
75780: NEG
75781: PUSH
75782: EMPTY
75783: LIST
75784: LIST
75785: PUSH
75786: EMPTY
75787: LIST
75788: LIST
75789: LIST
75790: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
75791: LD_ADDR_VAR 0 12
75795: PUSH
75796: LD_INT 2
75798: PUSH
75799: LD_INT 1
75801: NEG
75802: PUSH
75803: EMPTY
75804: LIST
75805: LIST
75806: PUSH
75807: LD_INT 3
75809: PUSH
75810: LD_INT 0
75812: PUSH
75813: EMPTY
75814: LIST
75815: LIST
75816: PUSH
75817: LD_INT 3
75819: PUSH
75820: LD_INT 1
75822: PUSH
75823: EMPTY
75824: LIST
75825: LIST
75826: PUSH
75827: EMPTY
75828: LIST
75829: LIST
75830: LIST
75831: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
75832: LD_ADDR_VAR 0 13
75836: PUSH
75837: LD_INT 3
75839: PUSH
75840: LD_INT 2
75842: PUSH
75843: EMPTY
75844: LIST
75845: LIST
75846: PUSH
75847: LD_INT 3
75849: PUSH
75850: LD_INT 3
75852: PUSH
75853: EMPTY
75854: LIST
75855: LIST
75856: PUSH
75857: LD_INT 2
75859: PUSH
75860: LD_INT 3
75862: PUSH
75863: EMPTY
75864: LIST
75865: LIST
75866: PUSH
75867: EMPTY
75868: LIST
75869: LIST
75870: LIST
75871: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
75872: LD_ADDR_VAR 0 14
75876: PUSH
75877: LD_INT 1
75879: PUSH
75880: LD_INT 3
75882: PUSH
75883: EMPTY
75884: LIST
75885: LIST
75886: PUSH
75887: LD_INT 0
75889: PUSH
75890: LD_INT 3
75892: PUSH
75893: EMPTY
75894: LIST
75895: LIST
75896: PUSH
75897: LD_INT 1
75899: NEG
75900: PUSH
75901: LD_INT 2
75903: PUSH
75904: EMPTY
75905: LIST
75906: LIST
75907: PUSH
75908: EMPTY
75909: LIST
75910: LIST
75911: LIST
75912: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75913: LD_ADDR_VAR 0 15
75917: PUSH
75918: LD_INT 2
75920: NEG
75921: PUSH
75922: LD_INT 1
75924: PUSH
75925: EMPTY
75926: LIST
75927: LIST
75928: PUSH
75929: LD_INT 3
75931: NEG
75932: PUSH
75933: LD_INT 0
75935: PUSH
75936: EMPTY
75937: LIST
75938: LIST
75939: PUSH
75940: LD_INT 3
75942: NEG
75943: PUSH
75944: LD_INT 1
75946: NEG
75947: PUSH
75948: EMPTY
75949: LIST
75950: LIST
75951: PUSH
75952: EMPTY
75953: LIST
75954: LIST
75955: LIST
75956: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75957: LD_ADDR_VAR 0 16
75961: PUSH
75962: LD_INT 2
75964: NEG
75965: PUSH
75966: LD_INT 3
75968: NEG
75969: PUSH
75970: EMPTY
75971: LIST
75972: LIST
75973: PUSH
75974: LD_INT 3
75976: NEG
75977: PUSH
75978: LD_INT 2
75980: NEG
75981: PUSH
75982: EMPTY
75983: LIST
75984: LIST
75985: PUSH
75986: LD_INT 3
75988: NEG
75989: PUSH
75990: LD_INT 3
75992: NEG
75993: PUSH
75994: EMPTY
75995: LIST
75996: LIST
75997: PUSH
75998: EMPTY
75999: LIST
76000: LIST
76001: LIST
76002: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76003: LD_ADDR_VAR 0 17
76007: PUSH
76008: LD_INT 1
76010: NEG
76011: PUSH
76012: LD_INT 3
76014: NEG
76015: PUSH
76016: EMPTY
76017: LIST
76018: LIST
76019: PUSH
76020: LD_INT 0
76022: PUSH
76023: LD_INT 3
76025: NEG
76026: PUSH
76027: EMPTY
76028: LIST
76029: LIST
76030: PUSH
76031: LD_INT 1
76033: PUSH
76034: LD_INT 2
76036: NEG
76037: PUSH
76038: EMPTY
76039: LIST
76040: LIST
76041: PUSH
76042: EMPTY
76043: LIST
76044: LIST
76045: LIST
76046: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76047: LD_ADDR_VAR 0 18
76051: PUSH
76052: LD_INT 2
76054: PUSH
76055: LD_INT 1
76057: NEG
76058: PUSH
76059: EMPTY
76060: LIST
76061: LIST
76062: PUSH
76063: LD_INT 3
76065: PUSH
76066: LD_INT 0
76068: PUSH
76069: EMPTY
76070: LIST
76071: LIST
76072: PUSH
76073: LD_INT 3
76075: PUSH
76076: LD_INT 1
76078: PUSH
76079: EMPTY
76080: LIST
76081: LIST
76082: PUSH
76083: EMPTY
76084: LIST
76085: LIST
76086: LIST
76087: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
76088: LD_ADDR_VAR 0 19
76092: PUSH
76093: LD_INT 3
76095: PUSH
76096: LD_INT 2
76098: PUSH
76099: EMPTY
76100: LIST
76101: LIST
76102: PUSH
76103: LD_INT 3
76105: PUSH
76106: LD_INT 3
76108: PUSH
76109: EMPTY
76110: LIST
76111: LIST
76112: PUSH
76113: LD_INT 2
76115: PUSH
76116: LD_INT 3
76118: PUSH
76119: EMPTY
76120: LIST
76121: LIST
76122: PUSH
76123: EMPTY
76124: LIST
76125: LIST
76126: LIST
76127: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76128: LD_ADDR_VAR 0 20
76132: PUSH
76133: LD_INT 1
76135: PUSH
76136: LD_INT 3
76138: PUSH
76139: EMPTY
76140: LIST
76141: LIST
76142: PUSH
76143: LD_INT 0
76145: PUSH
76146: LD_INT 3
76148: PUSH
76149: EMPTY
76150: LIST
76151: LIST
76152: PUSH
76153: LD_INT 1
76155: NEG
76156: PUSH
76157: LD_INT 2
76159: PUSH
76160: EMPTY
76161: LIST
76162: LIST
76163: PUSH
76164: EMPTY
76165: LIST
76166: LIST
76167: LIST
76168: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76169: LD_ADDR_VAR 0 21
76173: PUSH
76174: LD_INT 2
76176: NEG
76177: PUSH
76178: LD_INT 1
76180: PUSH
76181: EMPTY
76182: LIST
76183: LIST
76184: PUSH
76185: LD_INT 3
76187: NEG
76188: PUSH
76189: LD_INT 0
76191: PUSH
76192: EMPTY
76193: LIST
76194: LIST
76195: PUSH
76196: LD_INT 3
76198: NEG
76199: PUSH
76200: LD_INT 1
76202: NEG
76203: PUSH
76204: EMPTY
76205: LIST
76206: LIST
76207: PUSH
76208: EMPTY
76209: LIST
76210: LIST
76211: LIST
76212: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76213: LD_ADDR_VAR 0 22
76217: PUSH
76218: LD_INT 2
76220: NEG
76221: PUSH
76222: LD_INT 3
76224: NEG
76225: PUSH
76226: EMPTY
76227: LIST
76228: LIST
76229: PUSH
76230: LD_INT 3
76232: NEG
76233: PUSH
76234: LD_INT 2
76236: NEG
76237: PUSH
76238: EMPTY
76239: LIST
76240: LIST
76241: PUSH
76242: LD_INT 3
76244: NEG
76245: PUSH
76246: LD_INT 3
76248: NEG
76249: PUSH
76250: EMPTY
76251: LIST
76252: LIST
76253: PUSH
76254: EMPTY
76255: LIST
76256: LIST
76257: LIST
76258: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
76259: LD_ADDR_VAR 0 23
76263: PUSH
76264: LD_INT 0
76266: PUSH
76267: LD_INT 3
76269: NEG
76270: PUSH
76271: EMPTY
76272: LIST
76273: LIST
76274: PUSH
76275: LD_INT 1
76277: NEG
76278: PUSH
76279: LD_INT 4
76281: NEG
76282: PUSH
76283: EMPTY
76284: LIST
76285: LIST
76286: PUSH
76287: LD_INT 1
76289: PUSH
76290: LD_INT 3
76292: NEG
76293: PUSH
76294: EMPTY
76295: LIST
76296: LIST
76297: PUSH
76298: EMPTY
76299: LIST
76300: LIST
76301: LIST
76302: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
76303: LD_ADDR_VAR 0 24
76307: PUSH
76308: LD_INT 3
76310: PUSH
76311: LD_INT 0
76313: PUSH
76314: EMPTY
76315: LIST
76316: LIST
76317: PUSH
76318: LD_INT 3
76320: PUSH
76321: LD_INT 1
76323: NEG
76324: PUSH
76325: EMPTY
76326: LIST
76327: LIST
76328: PUSH
76329: LD_INT 4
76331: PUSH
76332: LD_INT 1
76334: PUSH
76335: EMPTY
76336: LIST
76337: LIST
76338: PUSH
76339: EMPTY
76340: LIST
76341: LIST
76342: LIST
76343: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
76344: LD_ADDR_VAR 0 25
76348: PUSH
76349: LD_INT 3
76351: PUSH
76352: LD_INT 3
76354: PUSH
76355: EMPTY
76356: LIST
76357: LIST
76358: PUSH
76359: LD_INT 4
76361: PUSH
76362: LD_INT 3
76364: PUSH
76365: EMPTY
76366: LIST
76367: LIST
76368: PUSH
76369: LD_INT 3
76371: PUSH
76372: LD_INT 4
76374: PUSH
76375: EMPTY
76376: LIST
76377: LIST
76378: PUSH
76379: EMPTY
76380: LIST
76381: LIST
76382: LIST
76383: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
76384: LD_ADDR_VAR 0 26
76388: PUSH
76389: LD_INT 0
76391: PUSH
76392: LD_INT 3
76394: PUSH
76395: EMPTY
76396: LIST
76397: LIST
76398: PUSH
76399: LD_INT 1
76401: PUSH
76402: LD_INT 4
76404: PUSH
76405: EMPTY
76406: LIST
76407: LIST
76408: PUSH
76409: LD_INT 1
76411: NEG
76412: PUSH
76413: LD_INT 3
76415: PUSH
76416: EMPTY
76417: LIST
76418: LIST
76419: PUSH
76420: EMPTY
76421: LIST
76422: LIST
76423: LIST
76424: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
76425: LD_ADDR_VAR 0 27
76429: PUSH
76430: LD_INT 3
76432: NEG
76433: PUSH
76434: LD_INT 0
76436: PUSH
76437: EMPTY
76438: LIST
76439: LIST
76440: PUSH
76441: LD_INT 3
76443: NEG
76444: PUSH
76445: LD_INT 1
76447: PUSH
76448: EMPTY
76449: LIST
76450: LIST
76451: PUSH
76452: LD_INT 4
76454: NEG
76455: PUSH
76456: LD_INT 1
76458: NEG
76459: PUSH
76460: EMPTY
76461: LIST
76462: LIST
76463: PUSH
76464: EMPTY
76465: LIST
76466: LIST
76467: LIST
76468: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
76469: LD_ADDR_VAR 0 28
76473: PUSH
76474: LD_INT 3
76476: NEG
76477: PUSH
76478: LD_INT 3
76480: NEG
76481: PUSH
76482: EMPTY
76483: LIST
76484: LIST
76485: PUSH
76486: LD_INT 3
76488: NEG
76489: PUSH
76490: LD_INT 4
76492: NEG
76493: PUSH
76494: EMPTY
76495: LIST
76496: LIST
76497: PUSH
76498: LD_INT 4
76500: NEG
76501: PUSH
76502: LD_INT 3
76504: NEG
76505: PUSH
76506: EMPTY
76507: LIST
76508: LIST
76509: PUSH
76510: EMPTY
76511: LIST
76512: LIST
76513: LIST
76514: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
76515: LD_ADDR_VAR 0 29
76519: PUSH
76520: LD_INT 1
76522: NEG
76523: PUSH
76524: LD_INT 3
76526: NEG
76527: PUSH
76528: EMPTY
76529: LIST
76530: LIST
76531: PUSH
76532: LD_INT 0
76534: PUSH
76535: LD_INT 3
76537: NEG
76538: PUSH
76539: EMPTY
76540: LIST
76541: LIST
76542: PUSH
76543: LD_INT 1
76545: PUSH
76546: LD_INT 2
76548: NEG
76549: PUSH
76550: EMPTY
76551: LIST
76552: LIST
76553: PUSH
76554: LD_INT 1
76556: NEG
76557: PUSH
76558: LD_INT 4
76560: NEG
76561: PUSH
76562: EMPTY
76563: LIST
76564: LIST
76565: PUSH
76566: LD_INT 0
76568: PUSH
76569: LD_INT 4
76571: NEG
76572: PUSH
76573: EMPTY
76574: LIST
76575: LIST
76576: PUSH
76577: LD_INT 1
76579: PUSH
76580: LD_INT 3
76582: NEG
76583: PUSH
76584: EMPTY
76585: LIST
76586: LIST
76587: PUSH
76588: LD_INT 1
76590: NEG
76591: PUSH
76592: LD_INT 5
76594: NEG
76595: PUSH
76596: EMPTY
76597: LIST
76598: LIST
76599: PUSH
76600: LD_INT 0
76602: PUSH
76603: LD_INT 5
76605: NEG
76606: PUSH
76607: EMPTY
76608: LIST
76609: LIST
76610: PUSH
76611: LD_INT 1
76613: PUSH
76614: LD_INT 4
76616: NEG
76617: PUSH
76618: EMPTY
76619: LIST
76620: LIST
76621: PUSH
76622: LD_INT 1
76624: NEG
76625: PUSH
76626: LD_INT 6
76628: NEG
76629: PUSH
76630: EMPTY
76631: LIST
76632: LIST
76633: PUSH
76634: LD_INT 0
76636: PUSH
76637: LD_INT 6
76639: NEG
76640: PUSH
76641: EMPTY
76642: LIST
76643: LIST
76644: PUSH
76645: LD_INT 1
76647: PUSH
76648: LD_INT 5
76650: NEG
76651: PUSH
76652: EMPTY
76653: LIST
76654: LIST
76655: PUSH
76656: EMPTY
76657: LIST
76658: LIST
76659: LIST
76660: LIST
76661: LIST
76662: LIST
76663: LIST
76664: LIST
76665: LIST
76666: LIST
76667: LIST
76668: LIST
76669: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
76670: LD_ADDR_VAR 0 30
76674: PUSH
76675: LD_INT 2
76677: PUSH
76678: LD_INT 1
76680: NEG
76681: PUSH
76682: EMPTY
76683: LIST
76684: LIST
76685: PUSH
76686: LD_INT 3
76688: PUSH
76689: LD_INT 0
76691: PUSH
76692: EMPTY
76693: LIST
76694: LIST
76695: PUSH
76696: LD_INT 3
76698: PUSH
76699: LD_INT 1
76701: PUSH
76702: EMPTY
76703: LIST
76704: LIST
76705: PUSH
76706: LD_INT 3
76708: PUSH
76709: LD_INT 1
76711: NEG
76712: PUSH
76713: EMPTY
76714: LIST
76715: LIST
76716: PUSH
76717: LD_INT 4
76719: PUSH
76720: LD_INT 0
76722: PUSH
76723: EMPTY
76724: LIST
76725: LIST
76726: PUSH
76727: LD_INT 4
76729: PUSH
76730: LD_INT 1
76732: PUSH
76733: EMPTY
76734: LIST
76735: LIST
76736: PUSH
76737: LD_INT 4
76739: PUSH
76740: LD_INT 1
76742: NEG
76743: PUSH
76744: EMPTY
76745: LIST
76746: LIST
76747: PUSH
76748: LD_INT 5
76750: PUSH
76751: LD_INT 0
76753: PUSH
76754: EMPTY
76755: LIST
76756: LIST
76757: PUSH
76758: LD_INT 5
76760: PUSH
76761: LD_INT 1
76763: PUSH
76764: EMPTY
76765: LIST
76766: LIST
76767: PUSH
76768: LD_INT 5
76770: PUSH
76771: LD_INT 1
76773: NEG
76774: PUSH
76775: EMPTY
76776: LIST
76777: LIST
76778: PUSH
76779: LD_INT 6
76781: PUSH
76782: LD_INT 0
76784: PUSH
76785: EMPTY
76786: LIST
76787: LIST
76788: PUSH
76789: LD_INT 6
76791: PUSH
76792: LD_INT 1
76794: PUSH
76795: EMPTY
76796: LIST
76797: LIST
76798: PUSH
76799: EMPTY
76800: LIST
76801: LIST
76802: LIST
76803: LIST
76804: LIST
76805: LIST
76806: LIST
76807: LIST
76808: LIST
76809: LIST
76810: LIST
76811: LIST
76812: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
76813: LD_ADDR_VAR 0 31
76817: PUSH
76818: LD_INT 3
76820: PUSH
76821: LD_INT 2
76823: PUSH
76824: EMPTY
76825: LIST
76826: LIST
76827: PUSH
76828: LD_INT 3
76830: PUSH
76831: LD_INT 3
76833: PUSH
76834: EMPTY
76835: LIST
76836: LIST
76837: PUSH
76838: LD_INT 2
76840: PUSH
76841: LD_INT 3
76843: PUSH
76844: EMPTY
76845: LIST
76846: LIST
76847: PUSH
76848: LD_INT 4
76850: PUSH
76851: LD_INT 3
76853: PUSH
76854: EMPTY
76855: LIST
76856: LIST
76857: PUSH
76858: LD_INT 4
76860: PUSH
76861: LD_INT 4
76863: PUSH
76864: EMPTY
76865: LIST
76866: LIST
76867: PUSH
76868: LD_INT 3
76870: PUSH
76871: LD_INT 4
76873: PUSH
76874: EMPTY
76875: LIST
76876: LIST
76877: PUSH
76878: LD_INT 5
76880: PUSH
76881: LD_INT 4
76883: PUSH
76884: EMPTY
76885: LIST
76886: LIST
76887: PUSH
76888: LD_INT 5
76890: PUSH
76891: LD_INT 5
76893: PUSH
76894: EMPTY
76895: LIST
76896: LIST
76897: PUSH
76898: LD_INT 4
76900: PUSH
76901: LD_INT 5
76903: PUSH
76904: EMPTY
76905: LIST
76906: LIST
76907: PUSH
76908: LD_INT 6
76910: PUSH
76911: LD_INT 5
76913: PUSH
76914: EMPTY
76915: LIST
76916: LIST
76917: PUSH
76918: LD_INT 6
76920: PUSH
76921: LD_INT 6
76923: PUSH
76924: EMPTY
76925: LIST
76926: LIST
76927: PUSH
76928: LD_INT 5
76930: PUSH
76931: LD_INT 6
76933: PUSH
76934: EMPTY
76935: LIST
76936: LIST
76937: PUSH
76938: EMPTY
76939: LIST
76940: LIST
76941: LIST
76942: LIST
76943: LIST
76944: LIST
76945: LIST
76946: LIST
76947: LIST
76948: LIST
76949: LIST
76950: LIST
76951: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
76952: LD_ADDR_VAR 0 32
76956: PUSH
76957: LD_INT 1
76959: PUSH
76960: LD_INT 3
76962: PUSH
76963: EMPTY
76964: LIST
76965: LIST
76966: PUSH
76967: LD_INT 0
76969: PUSH
76970: LD_INT 3
76972: PUSH
76973: EMPTY
76974: LIST
76975: LIST
76976: PUSH
76977: LD_INT 1
76979: NEG
76980: PUSH
76981: LD_INT 2
76983: PUSH
76984: EMPTY
76985: LIST
76986: LIST
76987: PUSH
76988: LD_INT 1
76990: PUSH
76991: LD_INT 4
76993: PUSH
76994: EMPTY
76995: LIST
76996: LIST
76997: PUSH
76998: LD_INT 0
77000: PUSH
77001: LD_INT 4
77003: PUSH
77004: EMPTY
77005: LIST
77006: LIST
77007: PUSH
77008: LD_INT 1
77010: NEG
77011: PUSH
77012: LD_INT 3
77014: PUSH
77015: EMPTY
77016: LIST
77017: LIST
77018: PUSH
77019: LD_INT 1
77021: PUSH
77022: LD_INT 5
77024: PUSH
77025: EMPTY
77026: LIST
77027: LIST
77028: PUSH
77029: LD_INT 0
77031: PUSH
77032: LD_INT 5
77034: PUSH
77035: EMPTY
77036: LIST
77037: LIST
77038: PUSH
77039: LD_INT 1
77041: NEG
77042: PUSH
77043: LD_INT 4
77045: PUSH
77046: EMPTY
77047: LIST
77048: LIST
77049: PUSH
77050: LD_INT 1
77052: PUSH
77053: LD_INT 6
77055: PUSH
77056: EMPTY
77057: LIST
77058: LIST
77059: PUSH
77060: LD_INT 0
77062: PUSH
77063: LD_INT 6
77065: PUSH
77066: EMPTY
77067: LIST
77068: LIST
77069: PUSH
77070: LD_INT 1
77072: NEG
77073: PUSH
77074: LD_INT 5
77076: PUSH
77077: EMPTY
77078: LIST
77079: LIST
77080: PUSH
77081: EMPTY
77082: LIST
77083: LIST
77084: LIST
77085: LIST
77086: LIST
77087: LIST
77088: LIST
77089: LIST
77090: LIST
77091: LIST
77092: LIST
77093: LIST
77094: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
77095: LD_ADDR_VAR 0 33
77099: PUSH
77100: LD_INT 2
77102: NEG
77103: PUSH
77104: LD_INT 1
77106: PUSH
77107: EMPTY
77108: LIST
77109: LIST
77110: PUSH
77111: LD_INT 3
77113: NEG
77114: PUSH
77115: LD_INT 0
77117: PUSH
77118: EMPTY
77119: LIST
77120: LIST
77121: PUSH
77122: LD_INT 3
77124: NEG
77125: PUSH
77126: LD_INT 1
77128: NEG
77129: PUSH
77130: EMPTY
77131: LIST
77132: LIST
77133: PUSH
77134: LD_INT 3
77136: NEG
77137: PUSH
77138: LD_INT 1
77140: PUSH
77141: EMPTY
77142: LIST
77143: LIST
77144: PUSH
77145: LD_INT 4
77147: NEG
77148: PUSH
77149: LD_INT 0
77151: PUSH
77152: EMPTY
77153: LIST
77154: LIST
77155: PUSH
77156: LD_INT 4
77158: NEG
77159: PUSH
77160: LD_INT 1
77162: NEG
77163: PUSH
77164: EMPTY
77165: LIST
77166: LIST
77167: PUSH
77168: LD_INT 4
77170: NEG
77171: PUSH
77172: LD_INT 1
77174: PUSH
77175: EMPTY
77176: LIST
77177: LIST
77178: PUSH
77179: LD_INT 5
77181: NEG
77182: PUSH
77183: LD_INT 0
77185: PUSH
77186: EMPTY
77187: LIST
77188: LIST
77189: PUSH
77190: LD_INT 5
77192: NEG
77193: PUSH
77194: LD_INT 1
77196: NEG
77197: PUSH
77198: EMPTY
77199: LIST
77200: LIST
77201: PUSH
77202: LD_INT 5
77204: NEG
77205: PUSH
77206: LD_INT 1
77208: PUSH
77209: EMPTY
77210: LIST
77211: LIST
77212: PUSH
77213: LD_INT 6
77215: NEG
77216: PUSH
77217: LD_INT 0
77219: PUSH
77220: EMPTY
77221: LIST
77222: LIST
77223: PUSH
77224: LD_INT 6
77226: NEG
77227: PUSH
77228: LD_INT 1
77230: NEG
77231: PUSH
77232: EMPTY
77233: LIST
77234: LIST
77235: PUSH
77236: EMPTY
77237: LIST
77238: LIST
77239: LIST
77240: LIST
77241: LIST
77242: LIST
77243: LIST
77244: LIST
77245: LIST
77246: LIST
77247: LIST
77248: LIST
77249: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
77250: LD_ADDR_VAR 0 34
77254: PUSH
77255: LD_INT 2
77257: NEG
77258: PUSH
77259: LD_INT 3
77261: NEG
77262: PUSH
77263: EMPTY
77264: LIST
77265: LIST
77266: PUSH
77267: LD_INT 3
77269: NEG
77270: PUSH
77271: LD_INT 2
77273: NEG
77274: PUSH
77275: EMPTY
77276: LIST
77277: LIST
77278: PUSH
77279: LD_INT 3
77281: NEG
77282: PUSH
77283: LD_INT 3
77285: NEG
77286: PUSH
77287: EMPTY
77288: LIST
77289: LIST
77290: PUSH
77291: LD_INT 3
77293: NEG
77294: PUSH
77295: LD_INT 4
77297: NEG
77298: PUSH
77299: EMPTY
77300: LIST
77301: LIST
77302: PUSH
77303: LD_INT 4
77305: NEG
77306: PUSH
77307: LD_INT 3
77309: NEG
77310: PUSH
77311: EMPTY
77312: LIST
77313: LIST
77314: PUSH
77315: LD_INT 4
77317: NEG
77318: PUSH
77319: LD_INT 4
77321: NEG
77322: PUSH
77323: EMPTY
77324: LIST
77325: LIST
77326: PUSH
77327: LD_INT 4
77329: NEG
77330: PUSH
77331: LD_INT 5
77333: NEG
77334: PUSH
77335: EMPTY
77336: LIST
77337: LIST
77338: PUSH
77339: LD_INT 5
77341: NEG
77342: PUSH
77343: LD_INT 4
77345: NEG
77346: PUSH
77347: EMPTY
77348: LIST
77349: LIST
77350: PUSH
77351: LD_INT 5
77353: NEG
77354: PUSH
77355: LD_INT 5
77357: NEG
77358: PUSH
77359: EMPTY
77360: LIST
77361: LIST
77362: PUSH
77363: LD_INT 5
77365: NEG
77366: PUSH
77367: LD_INT 6
77369: NEG
77370: PUSH
77371: EMPTY
77372: LIST
77373: LIST
77374: PUSH
77375: LD_INT 6
77377: NEG
77378: PUSH
77379: LD_INT 5
77381: NEG
77382: PUSH
77383: EMPTY
77384: LIST
77385: LIST
77386: PUSH
77387: LD_INT 6
77389: NEG
77390: PUSH
77391: LD_INT 6
77393: NEG
77394: PUSH
77395: EMPTY
77396: LIST
77397: LIST
77398: PUSH
77399: EMPTY
77400: LIST
77401: LIST
77402: LIST
77403: LIST
77404: LIST
77405: LIST
77406: LIST
77407: LIST
77408: LIST
77409: LIST
77410: LIST
77411: LIST
77412: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
77413: LD_ADDR_VAR 0 41
77417: PUSH
77418: LD_INT 0
77420: PUSH
77421: LD_INT 2
77423: NEG
77424: PUSH
77425: EMPTY
77426: LIST
77427: LIST
77428: PUSH
77429: LD_INT 1
77431: NEG
77432: PUSH
77433: LD_INT 3
77435: NEG
77436: PUSH
77437: EMPTY
77438: LIST
77439: LIST
77440: PUSH
77441: LD_INT 1
77443: PUSH
77444: LD_INT 2
77446: NEG
77447: PUSH
77448: EMPTY
77449: LIST
77450: LIST
77451: PUSH
77452: EMPTY
77453: LIST
77454: LIST
77455: LIST
77456: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
77457: LD_ADDR_VAR 0 42
77461: PUSH
77462: LD_INT 2
77464: PUSH
77465: LD_INT 0
77467: PUSH
77468: EMPTY
77469: LIST
77470: LIST
77471: PUSH
77472: LD_INT 2
77474: PUSH
77475: LD_INT 1
77477: NEG
77478: PUSH
77479: EMPTY
77480: LIST
77481: LIST
77482: PUSH
77483: LD_INT 3
77485: PUSH
77486: LD_INT 1
77488: PUSH
77489: EMPTY
77490: LIST
77491: LIST
77492: PUSH
77493: EMPTY
77494: LIST
77495: LIST
77496: LIST
77497: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
77498: LD_ADDR_VAR 0 43
77502: PUSH
77503: LD_INT 2
77505: PUSH
77506: LD_INT 2
77508: PUSH
77509: EMPTY
77510: LIST
77511: LIST
77512: PUSH
77513: LD_INT 3
77515: PUSH
77516: LD_INT 2
77518: PUSH
77519: EMPTY
77520: LIST
77521: LIST
77522: PUSH
77523: LD_INT 2
77525: PUSH
77526: LD_INT 3
77528: PUSH
77529: EMPTY
77530: LIST
77531: LIST
77532: PUSH
77533: EMPTY
77534: LIST
77535: LIST
77536: LIST
77537: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
77538: LD_ADDR_VAR 0 44
77542: PUSH
77543: LD_INT 0
77545: PUSH
77546: LD_INT 2
77548: PUSH
77549: EMPTY
77550: LIST
77551: LIST
77552: PUSH
77553: LD_INT 1
77555: PUSH
77556: LD_INT 3
77558: PUSH
77559: EMPTY
77560: LIST
77561: LIST
77562: PUSH
77563: LD_INT 1
77565: NEG
77566: PUSH
77567: LD_INT 2
77569: PUSH
77570: EMPTY
77571: LIST
77572: LIST
77573: PUSH
77574: EMPTY
77575: LIST
77576: LIST
77577: LIST
77578: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
77579: LD_ADDR_VAR 0 45
77583: PUSH
77584: LD_INT 2
77586: NEG
77587: PUSH
77588: LD_INT 0
77590: PUSH
77591: EMPTY
77592: LIST
77593: LIST
77594: PUSH
77595: LD_INT 2
77597: NEG
77598: PUSH
77599: LD_INT 1
77601: PUSH
77602: EMPTY
77603: LIST
77604: LIST
77605: PUSH
77606: LD_INT 3
77608: NEG
77609: PUSH
77610: LD_INT 1
77612: NEG
77613: PUSH
77614: EMPTY
77615: LIST
77616: LIST
77617: PUSH
77618: EMPTY
77619: LIST
77620: LIST
77621: LIST
77622: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
77623: LD_ADDR_VAR 0 46
77627: PUSH
77628: LD_INT 2
77630: NEG
77631: PUSH
77632: LD_INT 2
77634: NEG
77635: PUSH
77636: EMPTY
77637: LIST
77638: LIST
77639: PUSH
77640: LD_INT 2
77642: NEG
77643: PUSH
77644: LD_INT 3
77646: NEG
77647: PUSH
77648: EMPTY
77649: LIST
77650: LIST
77651: PUSH
77652: LD_INT 3
77654: NEG
77655: PUSH
77656: LD_INT 2
77658: NEG
77659: PUSH
77660: EMPTY
77661: LIST
77662: LIST
77663: PUSH
77664: EMPTY
77665: LIST
77666: LIST
77667: LIST
77668: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
77669: LD_ADDR_VAR 0 47
77673: PUSH
77674: LD_INT 2
77676: NEG
77677: PUSH
77678: LD_INT 3
77680: NEG
77681: PUSH
77682: EMPTY
77683: LIST
77684: LIST
77685: PUSH
77686: LD_INT 1
77688: NEG
77689: PUSH
77690: LD_INT 3
77692: NEG
77693: PUSH
77694: EMPTY
77695: LIST
77696: LIST
77697: PUSH
77698: EMPTY
77699: LIST
77700: LIST
77701: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
77702: LD_ADDR_VAR 0 48
77706: PUSH
77707: LD_INT 1
77709: PUSH
77710: LD_INT 2
77712: NEG
77713: PUSH
77714: EMPTY
77715: LIST
77716: LIST
77717: PUSH
77718: LD_INT 2
77720: PUSH
77721: LD_INT 1
77723: NEG
77724: PUSH
77725: EMPTY
77726: LIST
77727: LIST
77728: PUSH
77729: EMPTY
77730: LIST
77731: LIST
77732: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
77733: LD_ADDR_VAR 0 49
77737: PUSH
77738: LD_INT 3
77740: PUSH
77741: LD_INT 1
77743: PUSH
77744: EMPTY
77745: LIST
77746: LIST
77747: PUSH
77748: LD_INT 3
77750: PUSH
77751: LD_INT 2
77753: PUSH
77754: EMPTY
77755: LIST
77756: LIST
77757: PUSH
77758: EMPTY
77759: LIST
77760: LIST
77761: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
77762: LD_ADDR_VAR 0 50
77766: PUSH
77767: LD_INT 2
77769: PUSH
77770: LD_INT 3
77772: PUSH
77773: EMPTY
77774: LIST
77775: LIST
77776: PUSH
77777: LD_INT 1
77779: PUSH
77780: LD_INT 3
77782: PUSH
77783: EMPTY
77784: LIST
77785: LIST
77786: PUSH
77787: EMPTY
77788: LIST
77789: LIST
77790: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
77791: LD_ADDR_VAR 0 51
77795: PUSH
77796: LD_INT 1
77798: NEG
77799: PUSH
77800: LD_INT 2
77802: PUSH
77803: EMPTY
77804: LIST
77805: LIST
77806: PUSH
77807: LD_INT 2
77809: NEG
77810: PUSH
77811: LD_INT 1
77813: PUSH
77814: EMPTY
77815: LIST
77816: LIST
77817: PUSH
77818: EMPTY
77819: LIST
77820: LIST
77821: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
77822: LD_ADDR_VAR 0 52
77826: PUSH
77827: LD_INT 3
77829: NEG
77830: PUSH
77831: LD_INT 1
77833: NEG
77834: PUSH
77835: EMPTY
77836: LIST
77837: LIST
77838: PUSH
77839: LD_INT 3
77841: NEG
77842: PUSH
77843: LD_INT 2
77845: NEG
77846: PUSH
77847: EMPTY
77848: LIST
77849: LIST
77850: PUSH
77851: EMPTY
77852: LIST
77853: LIST
77854: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77855: LD_ADDR_VAR 0 53
77859: PUSH
77860: LD_INT 1
77862: NEG
77863: PUSH
77864: LD_INT 3
77866: NEG
77867: PUSH
77868: EMPTY
77869: LIST
77870: LIST
77871: PUSH
77872: LD_INT 0
77874: PUSH
77875: LD_INT 3
77877: NEG
77878: PUSH
77879: EMPTY
77880: LIST
77881: LIST
77882: PUSH
77883: LD_INT 1
77885: PUSH
77886: LD_INT 2
77888: NEG
77889: PUSH
77890: EMPTY
77891: LIST
77892: LIST
77893: PUSH
77894: EMPTY
77895: LIST
77896: LIST
77897: LIST
77898: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77899: LD_ADDR_VAR 0 54
77903: PUSH
77904: LD_INT 2
77906: PUSH
77907: LD_INT 1
77909: NEG
77910: PUSH
77911: EMPTY
77912: LIST
77913: LIST
77914: PUSH
77915: LD_INT 3
77917: PUSH
77918: LD_INT 0
77920: PUSH
77921: EMPTY
77922: LIST
77923: LIST
77924: PUSH
77925: LD_INT 3
77927: PUSH
77928: LD_INT 1
77930: PUSH
77931: EMPTY
77932: LIST
77933: LIST
77934: PUSH
77935: EMPTY
77936: LIST
77937: LIST
77938: LIST
77939: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77940: LD_ADDR_VAR 0 55
77944: PUSH
77945: LD_INT 3
77947: PUSH
77948: LD_INT 2
77950: PUSH
77951: EMPTY
77952: LIST
77953: LIST
77954: PUSH
77955: LD_INT 3
77957: PUSH
77958: LD_INT 3
77960: PUSH
77961: EMPTY
77962: LIST
77963: LIST
77964: PUSH
77965: LD_INT 2
77967: PUSH
77968: LD_INT 3
77970: PUSH
77971: EMPTY
77972: LIST
77973: LIST
77974: PUSH
77975: EMPTY
77976: LIST
77977: LIST
77978: LIST
77979: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77980: LD_ADDR_VAR 0 56
77984: PUSH
77985: LD_INT 1
77987: PUSH
77988: LD_INT 3
77990: PUSH
77991: EMPTY
77992: LIST
77993: LIST
77994: PUSH
77995: LD_INT 0
77997: PUSH
77998: LD_INT 3
78000: PUSH
78001: EMPTY
78002: LIST
78003: LIST
78004: PUSH
78005: LD_INT 1
78007: NEG
78008: PUSH
78009: LD_INT 2
78011: PUSH
78012: EMPTY
78013: LIST
78014: LIST
78015: PUSH
78016: EMPTY
78017: LIST
78018: LIST
78019: LIST
78020: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78021: LD_ADDR_VAR 0 57
78025: PUSH
78026: LD_INT 2
78028: NEG
78029: PUSH
78030: LD_INT 1
78032: PUSH
78033: EMPTY
78034: LIST
78035: LIST
78036: PUSH
78037: LD_INT 3
78039: NEG
78040: PUSH
78041: LD_INT 0
78043: PUSH
78044: EMPTY
78045: LIST
78046: LIST
78047: PUSH
78048: LD_INT 3
78050: NEG
78051: PUSH
78052: LD_INT 1
78054: NEG
78055: PUSH
78056: EMPTY
78057: LIST
78058: LIST
78059: PUSH
78060: EMPTY
78061: LIST
78062: LIST
78063: LIST
78064: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78065: LD_ADDR_VAR 0 58
78069: PUSH
78070: LD_INT 2
78072: NEG
78073: PUSH
78074: LD_INT 3
78076: NEG
78077: PUSH
78078: EMPTY
78079: LIST
78080: LIST
78081: PUSH
78082: LD_INT 3
78084: NEG
78085: PUSH
78086: LD_INT 2
78088: NEG
78089: PUSH
78090: EMPTY
78091: LIST
78092: LIST
78093: PUSH
78094: LD_INT 3
78096: NEG
78097: PUSH
78098: LD_INT 3
78100: NEG
78101: PUSH
78102: EMPTY
78103: LIST
78104: LIST
78105: PUSH
78106: EMPTY
78107: LIST
78108: LIST
78109: LIST
78110: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
78111: LD_ADDR_VAR 0 59
78115: PUSH
78116: LD_INT 1
78118: NEG
78119: PUSH
78120: LD_INT 2
78122: NEG
78123: PUSH
78124: EMPTY
78125: LIST
78126: LIST
78127: PUSH
78128: LD_INT 0
78130: PUSH
78131: LD_INT 2
78133: NEG
78134: PUSH
78135: EMPTY
78136: LIST
78137: LIST
78138: PUSH
78139: LD_INT 1
78141: PUSH
78142: LD_INT 1
78144: NEG
78145: PUSH
78146: EMPTY
78147: LIST
78148: LIST
78149: PUSH
78150: EMPTY
78151: LIST
78152: LIST
78153: LIST
78154: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
78155: LD_ADDR_VAR 0 60
78159: PUSH
78160: LD_INT 1
78162: PUSH
78163: LD_INT 1
78165: NEG
78166: PUSH
78167: EMPTY
78168: LIST
78169: LIST
78170: PUSH
78171: LD_INT 2
78173: PUSH
78174: LD_INT 0
78176: PUSH
78177: EMPTY
78178: LIST
78179: LIST
78180: PUSH
78181: LD_INT 2
78183: PUSH
78184: LD_INT 1
78186: PUSH
78187: EMPTY
78188: LIST
78189: LIST
78190: PUSH
78191: EMPTY
78192: LIST
78193: LIST
78194: LIST
78195: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
78196: LD_ADDR_VAR 0 61
78200: PUSH
78201: LD_INT 2
78203: PUSH
78204: LD_INT 1
78206: PUSH
78207: EMPTY
78208: LIST
78209: LIST
78210: PUSH
78211: LD_INT 2
78213: PUSH
78214: LD_INT 2
78216: PUSH
78217: EMPTY
78218: LIST
78219: LIST
78220: PUSH
78221: LD_INT 1
78223: PUSH
78224: LD_INT 2
78226: PUSH
78227: EMPTY
78228: LIST
78229: LIST
78230: PUSH
78231: EMPTY
78232: LIST
78233: LIST
78234: LIST
78235: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
78236: LD_ADDR_VAR 0 62
78240: PUSH
78241: LD_INT 1
78243: PUSH
78244: LD_INT 2
78246: PUSH
78247: EMPTY
78248: LIST
78249: LIST
78250: PUSH
78251: LD_INT 0
78253: PUSH
78254: LD_INT 2
78256: PUSH
78257: EMPTY
78258: LIST
78259: LIST
78260: PUSH
78261: LD_INT 1
78263: NEG
78264: PUSH
78265: LD_INT 1
78267: PUSH
78268: EMPTY
78269: LIST
78270: LIST
78271: PUSH
78272: EMPTY
78273: LIST
78274: LIST
78275: LIST
78276: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
78277: LD_ADDR_VAR 0 63
78281: PUSH
78282: LD_INT 1
78284: NEG
78285: PUSH
78286: LD_INT 1
78288: PUSH
78289: EMPTY
78290: LIST
78291: LIST
78292: PUSH
78293: LD_INT 2
78295: NEG
78296: PUSH
78297: LD_INT 0
78299: PUSH
78300: EMPTY
78301: LIST
78302: LIST
78303: PUSH
78304: LD_INT 2
78306: NEG
78307: PUSH
78308: LD_INT 1
78310: NEG
78311: PUSH
78312: EMPTY
78313: LIST
78314: LIST
78315: PUSH
78316: EMPTY
78317: LIST
78318: LIST
78319: LIST
78320: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78321: LD_ADDR_VAR 0 64
78325: PUSH
78326: LD_INT 1
78328: NEG
78329: PUSH
78330: LD_INT 2
78332: NEG
78333: PUSH
78334: EMPTY
78335: LIST
78336: LIST
78337: PUSH
78338: LD_INT 2
78340: NEG
78341: PUSH
78342: LD_INT 1
78344: NEG
78345: PUSH
78346: EMPTY
78347: LIST
78348: LIST
78349: PUSH
78350: LD_INT 2
78352: NEG
78353: PUSH
78354: LD_INT 2
78356: NEG
78357: PUSH
78358: EMPTY
78359: LIST
78360: LIST
78361: PUSH
78362: EMPTY
78363: LIST
78364: LIST
78365: LIST
78366: ST_TO_ADDR
// end ; 2 :
78367: GO 81633
78369: LD_INT 2
78371: DOUBLE
78372: EQUAL
78373: IFTRUE 78377
78375: GO 81632
78377: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
78378: LD_ADDR_VAR 0 29
78382: PUSH
78383: LD_INT 4
78385: PUSH
78386: LD_INT 0
78388: PUSH
78389: EMPTY
78390: LIST
78391: LIST
78392: PUSH
78393: LD_INT 4
78395: PUSH
78396: LD_INT 1
78398: NEG
78399: PUSH
78400: EMPTY
78401: LIST
78402: LIST
78403: PUSH
78404: LD_INT 5
78406: PUSH
78407: LD_INT 0
78409: PUSH
78410: EMPTY
78411: LIST
78412: LIST
78413: PUSH
78414: LD_INT 5
78416: PUSH
78417: LD_INT 1
78419: PUSH
78420: EMPTY
78421: LIST
78422: LIST
78423: PUSH
78424: LD_INT 4
78426: PUSH
78427: LD_INT 1
78429: PUSH
78430: EMPTY
78431: LIST
78432: LIST
78433: PUSH
78434: LD_INT 3
78436: PUSH
78437: LD_INT 0
78439: PUSH
78440: EMPTY
78441: LIST
78442: LIST
78443: PUSH
78444: LD_INT 3
78446: PUSH
78447: LD_INT 1
78449: NEG
78450: PUSH
78451: EMPTY
78452: LIST
78453: LIST
78454: PUSH
78455: LD_INT 3
78457: PUSH
78458: LD_INT 2
78460: NEG
78461: PUSH
78462: EMPTY
78463: LIST
78464: LIST
78465: PUSH
78466: LD_INT 5
78468: PUSH
78469: LD_INT 2
78471: PUSH
78472: EMPTY
78473: LIST
78474: LIST
78475: PUSH
78476: LD_INT 3
78478: PUSH
78479: LD_INT 3
78481: PUSH
78482: EMPTY
78483: LIST
78484: LIST
78485: PUSH
78486: LD_INT 3
78488: PUSH
78489: LD_INT 2
78491: PUSH
78492: EMPTY
78493: LIST
78494: LIST
78495: PUSH
78496: LD_INT 4
78498: PUSH
78499: LD_INT 3
78501: PUSH
78502: EMPTY
78503: LIST
78504: LIST
78505: PUSH
78506: LD_INT 4
78508: PUSH
78509: LD_INT 4
78511: PUSH
78512: EMPTY
78513: LIST
78514: LIST
78515: PUSH
78516: LD_INT 3
78518: PUSH
78519: LD_INT 4
78521: PUSH
78522: EMPTY
78523: LIST
78524: LIST
78525: PUSH
78526: LD_INT 2
78528: PUSH
78529: LD_INT 3
78531: PUSH
78532: EMPTY
78533: LIST
78534: LIST
78535: PUSH
78536: LD_INT 2
78538: PUSH
78539: LD_INT 2
78541: PUSH
78542: EMPTY
78543: LIST
78544: LIST
78545: PUSH
78546: LD_INT 4
78548: PUSH
78549: LD_INT 2
78551: PUSH
78552: EMPTY
78553: LIST
78554: LIST
78555: PUSH
78556: LD_INT 2
78558: PUSH
78559: LD_INT 4
78561: PUSH
78562: EMPTY
78563: LIST
78564: LIST
78565: PUSH
78566: LD_INT 0
78568: PUSH
78569: LD_INT 4
78571: PUSH
78572: EMPTY
78573: LIST
78574: LIST
78575: PUSH
78576: LD_INT 0
78578: PUSH
78579: LD_INT 3
78581: PUSH
78582: EMPTY
78583: LIST
78584: LIST
78585: PUSH
78586: LD_INT 1
78588: PUSH
78589: LD_INT 4
78591: PUSH
78592: EMPTY
78593: LIST
78594: LIST
78595: PUSH
78596: LD_INT 1
78598: PUSH
78599: LD_INT 5
78601: PUSH
78602: EMPTY
78603: LIST
78604: LIST
78605: PUSH
78606: LD_INT 0
78608: PUSH
78609: LD_INT 5
78611: PUSH
78612: EMPTY
78613: LIST
78614: LIST
78615: PUSH
78616: LD_INT 1
78618: NEG
78619: PUSH
78620: LD_INT 4
78622: PUSH
78623: EMPTY
78624: LIST
78625: LIST
78626: PUSH
78627: LD_INT 1
78629: NEG
78630: PUSH
78631: LD_INT 3
78633: PUSH
78634: EMPTY
78635: LIST
78636: LIST
78637: PUSH
78638: LD_INT 2
78640: PUSH
78641: LD_INT 5
78643: PUSH
78644: EMPTY
78645: LIST
78646: LIST
78647: PUSH
78648: LD_INT 2
78650: NEG
78651: PUSH
78652: LD_INT 3
78654: PUSH
78655: EMPTY
78656: LIST
78657: LIST
78658: PUSH
78659: LD_INT 3
78661: NEG
78662: PUSH
78663: LD_INT 0
78665: PUSH
78666: EMPTY
78667: LIST
78668: LIST
78669: PUSH
78670: LD_INT 3
78672: NEG
78673: PUSH
78674: LD_INT 1
78676: NEG
78677: PUSH
78678: EMPTY
78679: LIST
78680: LIST
78681: PUSH
78682: LD_INT 2
78684: NEG
78685: PUSH
78686: LD_INT 0
78688: PUSH
78689: EMPTY
78690: LIST
78691: LIST
78692: PUSH
78693: LD_INT 2
78695: NEG
78696: PUSH
78697: LD_INT 1
78699: PUSH
78700: EMPTY
78701: LIST
78702: LIST
78703: PUSH
78704: LD_INT 3
78706: NEG
78707: PUSH
78708: LD_INT 1
78710: PUSH
78711: EMPTY
78712: LIST
78713: LIST
78714: PUSH
78715: LD_INT 4
78717: NEG
78718: PUSH
78719: LD_INT 0
78721: PUSH
78722: EMPTY
78723: LIST
78724: LIST
78725: PUSH
78726: LD_INT 4
78728: NEG
78729: PUSH
78730: LD_INT 1
78732: NEG
78733: PUSH
78734: EMPTY
78735: LIST
78736: LIST
78737: PUSH
78738: LD_INT 4
78740: NEG
78741: PUSH
78742: LD_INT 2
78744: NEG
78745: PUSH
78746: EMPTY
78747: LIST
78748: LIST
78749: PUSH
78750: LD_INT 2
78752: NEG
78753: PUSH
78754: LD_INT 2
78756: PUSH
78757: EMPTY
78758: LIST
78759: LIST
78760: PUSH
78761: LD_INT 4
78763: NEG
78764: PUSH
78765: LD_INT 4
78767: NEG
78768: PUSH
78769: EMPTY
78770: LIST
78771: LIST
78772: PUSH
78773: LD_INT 4
78775: NEG
78776: PUSH
78777: LD_INT 5
78779: NEG
78780: PUSH
78781: EMPTY
78782: LIST
78783: LIST
78784: PUSH
78785: LD_INT 3
78787: NEG
78788: PUSH
78789: LD_INT 4
78791: NEG
78792: PUSH
78793: EMPTY
78794: LIST
78795: LIST
78796: PUSH
78797: LD_INT 3
78799: NEG
78800: PUSH
78801: LD_INT 3
78803: NEG
78804: PUSH
78805: EMPTY
78806: LIST
78807: LIST
78808: PUSH
78809: LD_INT 4
78811: NEG
78812: PUSH
78813: LD_INT 3
78815: NEG
78816: PUSH
78817: EMPTY
78818: LIST
78819: LIST
78820: PUSH
78821: LD_INT 5
78823: NEG
78824: PUSH
78825: LD_INT 4
78827: NEG
78828: PUSH
78829: EMPTY
78830: LIST
78831: LIST
78832: PUSH
78833: LD_INT 5
78835: NEG
78836: PUSH
78837: LD_INT 5
78839: NEG
78840: PUSH
78841: EMPTY
78842: LIST
78843: LIST
78844: PUSH
78845: LD_INT 3
78847: NEG
78848: PUSH
78849: LD_INT 5
78851: NEG
78852: PUSH
78853: EMPTY
78854: LIST
78855: LIST
78856: PUSH
78857: LD_INT 5
78859: NEG
78860: PUSH
78861: LD_INT 3
78863: NEG
78864: PUSH
78865: EMPTY
78866: LIST
78867: LIST
78868: PUSH
78869: EMPTY
78870: LIST
78871: LIST
78872: LIST
78873: LIST
78874: LIST
78875: LIST
78876: LIST
78877: LIST
78878: LIST
78879: LIST
78880: LIST
78881: LIST
78882: LIST
78883: LIST
78884: LIST
78885: LIST
78886: LIST
78887: LIST
78888: LIST
78889: LIST
78890: LIST
78891: LIST
78892: LIST
78893: LIST
78894: LIST
78895: LIST
78896: LIST
78897: LIST
78898: LIST
78899: LIST
78900: LIST
78901: LIST
78902: LIST
78903: LIST
78904: LIST
78905: LIST
78906: LIST
78907: LIST
78908: LIST
78909: LIST
78910: LIST
78911: LIST
78912: LIST
78913: LIST
78914: LIST
78915: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
78916: LD_ADDR_VAR 0 30
78920: PUSH
78921: LD_INT 4
78923: PUSH
78924: LD_INT 4
78926: PUSH
78927: EMPTY
78928: LIST
78929: LIST
78930: PUSH
78931: LD_INT 4
78933: PUSH
78934: LD_INT 3
78936: PUSH
78937: EMPTY
78938: LIST
78939: LIST
78940: PUSH
78941: LD_INT 5
78943: PUSH
78944: LD_INT 4
78946: PUSH
78947: EMPTY
78948: LIST
78949: LIST
78950: PUSH
78951: LD_INT 5
78953: PUSH
78954: LD_INT 5
78956: PUSH
78957: EMPTY
78958: LIST
78959: LIST
78960: PUSH
78961: LD_INT 4
78963: PUSH
78964: LD_INT 5
78966: PUSH
78967: EMPTY
78968: LIST
78969: LIST
78970: PUSH
78971: LD_INT 3
78973: PUSH
78974: LD_INT 4
78976: PUSH
78977: EMPTY
78978: LIST
78979: LIST
78980: PUSH
78981: LD_INT 3
78983: PUSH
78984: LD_INT 3
78986: PUSH
78987: EMPTY
78988: LIST
78989: LIST
78990: PUSH
78991: LD_INT 5
78993: PUSH
78994: LD_INT 3
78996: PUSH
78997: EMPTY
78998: LIST
78999: LIST
79000: PUSH
79001: LD_INT 3
79003: PUSH
79004: LD_INT 5
79006: PUSH
79007: EMPTY
79008: LIST
79009: LIST
79010: PUSH
79011: LD_INT 0
79013: PUSH
79014: LD_INT 3
79016: PUSH
79017: EMPTY
79018: LIST
79019: LIST
79020: PUSH
79021: LD_INT 0
79023: PUSH
79024: LD_INT 2
79026: PUSH
79027: EMPTY
79028: LIST
79029: LIST
79030: PUSH
79031: LD_INT 1
79033: PUSH
79034: LD_INT 3
79036: PUSH
79037: EMPTY
79038: LIST
79039: LIST
79040: PUSH
79041: LD_INT 1
79043: PUSH
79044: LD_INT 4
79046: PUSH
79047: EMPTY
79048: LIST
79049: LIST
79050: PUSH
79051: LD_INT 0
79053: PUSH
79054: LD_INT 4
79056: PUSH
79057: EMPTY
79058: LIST
79059: LIST
79060: PUSH
79061: LD_INT 1
79063: NEG
79064: PUSH
79065: LD_INT 3
79067: PUSH
79068: EMPTY
79069: LIST
79070: LIST
79071: PUSH
79072: LD_INT 1
79074: NEG
79075: PUSH
79076: LD_INT 2
79078: PUSH
79079: EMPTY
79080: LIST
79081: LIST
79082: PUSH
79083: LD_INT 2
79085: PUSH
79086: LD_INT 4
79088: PUSH
79089: EMPTY
79090: LIST
79091: LIST
79092: PUSH
79093: LD_INT 2
79095: NEG
79096: PUSH
79097: LD_INT 2
79099: PUSH
79100: EMPTY
79101: LIST
79102: LIST
79103: PUSH
79104: LD_INT 4
79106: NEG
79107: PUSH
79108: LD_INT 0
79110: PUSH
79111: EMPTY
79112: LIST
79113: LIST
79114: PUSH
79115: LD_INT 4
79117: NEG
79118: PUSH
79119: LD_INT 1
79121: NEG
79122: PUSH
79123: EMPTY
79124: LIST
79125: LIST
79126: PUSH
79127: LD_INT 3
79129: NEG
79130: PUSH
79131: LD_INT 0
79133: PUSH
79134: EMPTY
79135: LIST
79136: LIST
79137: PUSH
79138: LD_INT 3
79140: NEG
79141: PUSH
79142: LD_INT 1
79144: PUSH
79145: EMPTY
79146: LIST
79147: LIST
79148: PUSH
79149: LD_INT 4
79151: NEG
79152: PUSH
79153: LD_INT 1
79155: PUSH
79156: EMPTY
79157: LIST
79158: LIST
79159: PUSH
79160: LD_INT 5
79162: NEG
79163: PUSH
79164: LD_INT 0
79166: PUSH
79167: EMPTY
79168: LIST
79169: LIST
79170: PUSH
79171: LD_INT 5
79173: NEG
79174: PUSH
79175: LD_INT 1
79177: NEG
79178: PUSH
79179: EMPTY
79180: LIST
79181: LIST
79182: PUSH
79183: LD_INT 5
79185: NEG
79186: PUSH
79187: LD_INT 2
79189: NEG
79190: PUSH
79191: EMPTY
79192: LIST
79193: LIST
79194: PUSH
79195: LD_INT 3
79197: NEG
79198: PUSH
79199: LD_INT 2
79201: PUSH
79202: EMPTY
79203: LIST
79204: LIST
79205: PUSH
79206: LD_INT 3
79208: NEG
79209: PUSH
79210: LD_INT 3
79212: NEG
79213: PUSH
79214: EMPTY
79215: LIST
79216: LIST
79217: PUSH
79218: LD_INT 3
79220: NEG
79221: PUSH
79222: LD_INT 4
79224: NEG
79225: PUSH
79226: EMPTY
79227: LIST
79228: LIST
79229: PUSH
79230: LD_INT 2
79232: NEG
79233: PUSH
79234: LD_INT 3
79236: NEG
79237: PUSH
79238: EMPTY
79239: LIST
79240: LIST
79241: PUSH
79242: LD_INT 2
79244: NEG
79245: PUSH
79246: LD_INT 2
79248: NEG
79249: PUSH
79250: EMPTY
79251: LIST
79252: LIST
79253: PUSH
79254: LD_INT 3
79256: NEG
79257: PUSH
79258: LD_INT 2
79260: NEG
79261: PUSH
79262: EMPTY
79263: LIST
79264: LIST
79265: PUSH
79266: LD_INT 4
79268: NEG
79269: PUSH
79270: LD_INT 3
79272: NEG
79273: PUSH
79274: EMPTY
79275: LIST
79276: LIST
79277: PUSH
79278: LD_INT 4
79280: NEG
79281: PUSH
79282: LD_INT 4
79284: NEG
79285: PUSH
79286: EMPTY
79287: LIST
79288: LIST
79289: PUSH
79290: LD_INT 2
79292: NEG
79293: PUSH
79294: LD_INT 4
79296: NEG
79297: PUSH
79298: EMPTY
79299: LIST
79300: LIST
79301: PUSH
79302: LD_INT 4
79304: NEG
79305: PUSH
79306: LD_INT 2
79308: NEG
79309: PUSH
79310: EMPTY
79311: LIST
79312: LIST
79313: PUSH
79314: LD_INT 0
79316: PUSH
79317: LD_INT 4
79319: NEG
79320: PUSH
79321: EMPTY
79322: LIST
79323: LIST
79324: PUSH
79325: LD_INT 0
79327: PUSH
79328: LD_INT 5
79330: NEG
79331: PUSH
79332: EMPTY
79333: LIST
79334: LIST
79335: PUSH
79336: LD_INT 1
79338: PUSH
79339: LD_INT 4
79341: NEG
79342: PUSH
79343: EMPTY
79344: LIST
79345: LIST
79346: PUSH
79347: LD_INT 1
79349: PUSH
79350: LD_INT 3
79352: NEG
79353: PUSH
79354: EMPTY
79355: LIST
79356: LIST
79357: PUSH
79358: LD_INT 0
79360: PUSH
79361: LD_INT 3
79363: NEG
79364: PUSH
79365: EMPTY
79366: LIST
79367: LIST
79368: PUSH
79369: LD_INT 1
79371: NEG
79372: PUSH
79373: LD_INT 4
79375: NEG
79376: PUSH
79377: EMPTY
79378: LIST
79379: LIST
79380: PUSH
79381: LD_INT 1
79383: NEG
79384: PUSH
79385: LD_INT 5
79387: NEG
79388: PUSH
79389: EMPTY
79390: LIST
79391: LIST
79392: PUSH
79393: LD_INT 2
79395: PUSH
79396: LD_INT 3
79398: NEG
79399: PUSH
79400: EMPTY
79401: LIST
79402: LIST
79403: PUSH
79404: LD_INT 2
79406: NEG
79407: PUSH
79408: LD_INT 5
79410: NEG
79411: PUSH
79412: EMPTY
79413: LIST
79414: LIST
79415: PUSH
79416: EMPTY
79417: LIST
79418: LIST
79419: LIST
79420: LIST
79421: LIST
79422: LIST
79423: LIST
79424: LIST
79425: LIST
79426: LIST
79427: LIST
79428: LIST
79429: LIST
79430: LIST
79431: LIST
79432: LIST
79433: LIST
79434: LIST
79435: LIST
79436: LIST
79437: LIST
79438: LIST
79439: LIST
79440: LIST
79441: LIST
79442: LIST
79443: LIST
79444: LIST
79445: LIST
79446: LIST
79447: LIST
79448: LIST
79449: LIST
79450: LIST
79451: LIST
79452: LIST
79453: LIST
79454: LIST
79455: LIST
79456: LIST
79457: LIST
79458: LIST
79459: LIST
79460: LIST
79461: LIST
79462: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
79463: LD_ADDR_VAR 0 31
79467: PUSH
79468: LD_INT 0
79470: PUSH
79471: LD_INT 4
79473: PUSH
79474: EMPTY
79475: LIST
79476: LIST
79477: PUSH
79478: LD_INT 0
79480: PUSH
79481: LD_INT 3
79483: PUSH
79484: EMPTY
79485: LIST
79486: LIST
79487: PUSH
79488: LD_INT 1
79490: PUSH
79491: LD_INT 4
79493: PUSH
79494: EMPTY
79495: LIST
79496: LIST
79497: PUSH
79498: LD_INT 1
79500: PUSH
79501: LD_INT 5
79503: PUSH
79504: EMPTY
79505: LIST
79506: LIST
79507: PUSH
79508: LD_INT 0
79510: PUSH
79511: LD_INT 5
79513: PUSH
79514: EMPTY
79515: LIST
79516: LIST
79517: PUSH
79518: LD_INT 1
79520: NEG
79521: PUSH
79522: LD_INT 4
79524: PUSH
79525: EMPTY
79526: LIST
79527: LIST
79528: PUSH
79529: LD_INT 1
79531: NEG
79532: PUSH
79533: LD_INT 3
79535: PUSH
79536: EMPTY
79537: LIST
79538: LIST
79539: PUSH
79540: LD_INT 2
79542: PUSH
79543: LD_INT 5
79545: PUSH
79546: EMPTY
79547: LIST
79548: LIST
79549: PUSH
79550: LD_INT 2
79552: NEG
79553: PUSH
79554: LD_INT 3
79556: PUSH
79557: EMPTY
79558: LIST
79559: LIST
79560: PUSH
79561: LD_INT 3
79563: NEG
79564: PUSH
79565: LD_INT 0
79567: PUSH
79568: EMPTY
79569: LIST
79570: LIST
79571: PUSH
79572: LD_INT 3
79574: NEG
79575: PUSH
79576: LD_INT 1
79578: NEG
79579: PUSH
79580: EMPTY
79581: LIST
79582: LIST
79583: PUSH
79584: LD_INT 2
79586: NEG
79587: PUSH
79588: LD_INT 0
79590: PUSH
79591: EMPTY
79592: LIST
79593: LIST
79594: PUSH
79595: LD_INT 2
79597: NEG
79598: PUSH
79599: LD_INT 1
79601: PUSH
79602: EMPTY
79603: LIST
79604: LIST
79605: PUSH
79606: LD_INT 3
79608: NEG
79609: PUSH
79610: LD_INT 1
79612: PUSH
79613: EMPTY
79614: LIST
79615: LIST
79616: PUSH
79617: LD_INT 4
79619: NEG
79620: PUSH
79621: LD_INT 0
79623: PUSH
79624: EMPTY
79625: LIST
79626: LIST
79627: PUSH
79628: LD_INT 4
79630: NEG
79631: PUSH
79632: LD_INT 1
79634: NEG
79635: PUSH
79636: EMPTY
79637: LIST
79638: LIST
79639: PUSH
79640: LD_INT 4
79642: NEG
79643: PUSH
79644: LD_INT 2
79646: NEG
79647: PUSH
79648: EMPTY
79649: LIST
79650: LIST
79651: PUSH
79652: LD_INT 2
79654: NEG
79655: PUSH
79656: LD_INT 2
79658: PUSH
79659: EMPTY
79660: LIST
79661: LIST
79662: PUSH
79663: LD_INT 4
79665: NEG
79666: PUSH
79667: LD_INT 4
79669: NEG
79670: PUSH
79671: EMPTY
79672: LIST
79673: LIST
79674: PUSH
79675: LD_INT 4
79677: NEG
79678: PUSH
79679: LD_INT 5
79681: NEG
79682: PUSH
79683: EMPTY
79684: LIST
79685: LIST
79686: PUSH
79687: LD_INT 3
79689: NEG
79690: PUSH
79691: LD_INT 4
79693: NEG
79694: PUSH
79695: EMPTY
79696: LIST
79697: LIST
79698: PUSH
79699: LD_INT 3
79701: NEG
79702: PUSH
79703: LD_INT 3
79705: NEG
79706: PUSH
79707: EMPTY
79708: LIST
79709: LIST
79710: PUSH
79711: LD_INT 4
79713: NEG
79714: PUSH
79715: LD_INT 3
79717: NEG
79718: PUSH
79719: EMPTY
79720: LIST
79721: LIST
79722: PUSH
79723: LD_INT 5
79725: NEG
79726: PUSH
79727: LD_INT 4
79729: NEG
79730: PUSH
79731: EMPTY
79732: LIST
79733: LIST
79734: PUSH
79735: LD_INT 5
79737: NEG
79738: PUSH
79739: LD_INT 5
79741: NEG
79742: PUSH
79743: EMPTY
79744: LIST
79745: LIST
79746: PUSH
79747: LD_INT 3
79749: NEG
79750: PUSH
79751: LD_INT 5
79753: NEG
79754: PUSH
79755: EMPTY
79756: LIST
79757: LIST
79758: PUSH
79759: LD_INT 5
79761: NEG
79762: PUSH
79763: LD_INT 3
79765: NEG
79766: PUSH
79767: EMPTY
79768: LIST
79769: LIST
79770: PUSH
79771: LD_INT 0
79773: PUSH
79774: LD_INT 3
79776: NEG
79777: PUSH
79778: EMPTY
79779: LIST
79780: LIST
79781: PUSH
79782: LD_INT 0
79784: PUSH
79785: LD_INT 4
79787: NEG
79788: PUSH
79789: EMPTY
79790: LIST
79791: LIST
79792: PUSH
79793: LD_INT 1
79795: PUSH
79796: LD_INT 3
79798: NEG
79799: PUSH
79800: EMPTY
79801: LIST
79802: LIST
79803: PUSH
79804: LD_INT 1
79806: PUSH
79807: LD_INT 2
79809: NEG
79810: PUSH
79811: EMPTY
79812: LIST
79813: LIST
79814: PUSH
79815: LD_INT 0
79817: PUSH
79818: LD_INT 2
79820: NEG
79821: PUSH
79822: EMPTY
79823: LIST
79824: LIST
79825: PUSH
79826: LD_INT 1
79828: NEG
79829: PUSH
79830: LD_INT 3
79832: NEG
79833: PUSH
79834: EMPTY
79835: LIST
79836: LIST
79837: PUSH
79838: LD_INT 1
79840: NEG
79841: PUSH
79842: LD_INT 4
79844: NEG
79845: PUSH
79846: EMPTY
79847: LIST
79848: LIST
79849: PUSH
79850: LD_INT 2
79852: PUSH
79853: LD_INT 2
79855: NEG
79856: PUSH
79857: EMPTY
79858: LIST
79859: LIST
79860: PUSH
79861: LD_INT 2
79863: NEG
79864: PUSH
79865: LD_INT 4
79867: NEG
79868: PUSH
79869: EMPTY
79870: LIST
79871: LIST
79872: PUSH
79873: LD_INT 4
79875: PUSH
79876: LD_INT 0
79878: PUSH
79879: EMPTY
79880: LIST
79881: LIST
79882: PUSH
79883: LD_INT 4
79885: PUSH
79886: LD_INT 1
79888: NEG
79889: PUSH
79890: EMPTY
79891: LIST
79892: LIST
79893: PUSH
79894: LD_INT 5
79896: PUSH
79897: LD_INT 0
79899: PUSH
79900: EMPTY
79901: LIST
79902: LIST
79903: PUSH
79904: LD_INT 5
79906: PUSH
79907: LD_INT 1
79909: PUSH
79910: EMPTY
79911: LIST
79912: LIST
79913: PUSH
79914: LD_INT 4
79916: PUSH
79917: LD_INT 1
79919: PUSH
79920: EMPTY
79921: LIST
79922: LIST
79923: PUSH
79924: LD_INT 3
79926: PUSH
79927: LD_INT 0
79929: PUSH
79930: EMPTY
79931: LIST
79932: LIST
79933: PUSH
79934: LD_INT 3
79936: PUSH
79937: LD_INT 1
79939: NEG
79940: PUSH
79941: EMPTY
79942: LIST
79943: LIST
79944: PUSH
79945: LD_INT 3
79947: PUSH
79948: LD_INT 2
79950: NEG
79951: PUSH
79952: EMPTY
79953: LIST
79954: LIST
79955: PUSH
79956: LD_INT 5
79958: PUSH
79959: LD_INT 2
79961: PUSH
79962: EMPTY
79963: LIST
79964: LIST
79965: PUSH
79966: EMPTY
79967: LIST
79968: LIST
79969: LIST
79970: LIST
79971: LIST
79972: LIST
79973: LIST
79974: LIST
79975: LIST
79976: LIST
79977: LIST
79978: LIST
79979: LIST
79980: LIST
79981: LIST
79982: LIST
79983: LIST
79984: LIST
79985: LIST
79986: LIST
79987: LIST
79988: LIST
79989: LIST
79990: LIST
79991: LIST
79992: LIST
79993: LIST
79994: LIST
79995: LIST
79996: LIST
79997: LIST
79998: LIST
79999: LIST
80000: LIST
80001: LIST
80002: LIST
80003: LIST
80004: LIST
80005: LIST
80006: LIST
80007: LIST
80008: LIST
80009: LIST
80010: LIST
80011: LIST
80012: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
80013: LD_ADDR_VAR 0 32
80017: PUSH
80018: LD_INT 4
80020: NEG
80021: PUSH
80022: LD_INT 0
80024: PUSH
80025: EMPTY
80026: LIST
80027: LIST
80028: PUSH
80029: LD_INT 4
80031: NEG
80032: PUSH
80033: LD_INT 1
80035: NEG
80036: PUSH
80037: EMPTY
80038: LIST
80039: LIST
80040: PUSH
80041: LD_INT 3
80043: NEG
80044: PUSH
80045: LD_INT 0
80047: PUSH
80048: EMPTY
80049: LIST
80050: LIST
80051: PUSH
80052: LD_INT 3
80054: NEG
80055: PUSH
80056: LD_INT 1
80058: PUSH
80059: EMPTY
80060: LIST
80061: LIST
80062: PUSH
80063: LD_INT 4
80065: NEG
80066: PUSH
80067: LD_INT 1
80069: PUSH
80070: EMPTY
80071: LIST
80072: LIST
80073: PUSH
80074: LD_INT 5
80076: NEG
80077: PUSH
80078: LD_INT 0
80080: PUSH
80081: EMPTY
80082: LIST
80083: LIST
80084: PUSH
80085: LD_INT 5
80087: NEG
80088: PUSH
80089: LD_INT 1
80091: NEG
80092: PUSH
80093: EMPTY
80094: LIST
80095: LIST
80096: PUSH
80097: LD_INT 5
80099: NEG
80100: PUSH
80101: LD_INT 2
80103: NEG
80104: PUSH
80105: EMPTY
80106: LIST
80107: LIST
80108: PUSH
80109: LD_INT 3
80111: NEG
80112: PUSH
80113: LD_INT 2
80115: PUSH
80116: EMPTY
80117: LIST
80118: LIST
80119: PUSH
80120: LD_INT 3
80122: NEG
80123: PUSH
80124: LD_INT 3
80126: NEG
80127: PUSH
80128: EMPTY
80129: LIST
80130: LIST
80131: PUSH
80132: LD_INT 3
80134: NEG
80135: PUSH
80136: LD_INT 4
80138: NEG
80139: PUSH
80140: EMPTY
80141: LIST
80142: LIST
80143: PUSH
80144: LD_INT 2
80146: NEG
80147: PUSH
80148: LD_INT 3
80150: NEG
80151: PUSH
80152: EMPTY
80153: LIST
80154: LIST
80155: PUSH
80156: LD_INT 2
80158: NEG
80159: PUSH
80160: LD_INT 2
80162: NEG
80163: PUSH
80164: EMPTY
80165: LIST
80166: LIST
80167: PUSH
80168: LD_INT 3
80170: NEG
80171: PUSH
80172: LD_INT 2
80174: NEG
80175: PUSH
80176: EMPTY
80177: LIST
80178: LIST
80179: PUSH
80180: LD_INT 4
80182: NEG
80183: PUSH
80184: LD_INT 3
80186: NEG
80187: PUSH
80188: EMPTY
80189: LIST
80190: LIST
80191: PUSH
80192: LD_INT 4
80194: NEG
80195: PUSH
80196: LD_INT 4
80198: NEG
80199: PUSH
80200: EMPTY
80201: LIST
80202: LIST
80203: PUSH
80204: LD_INT 2
80206: NEG
80207: PUSH
80208: LD_INT 4
80210: NEG
80211: PUSH
80212: EMPTY
80213: LIST
80214: LIST
80215: PUSH
80216: LD_INT 4
80218: NEG
80219: PUSH
80220: LD_INT 2
80222: NEG
80223: PUSH
80224: EMPTY
80225: LIST
80226: LIST
80227: PUSH
80228: LD_INT 0
80230: PUSH
80231: LD_INT 4
80233: NEG
80234: PUSH
80235: EMPTY
80236: LIST
80237: LIST
80238: PUSH
80239: LD_INT 0
80241: PUSH
80242: LD_INT 5
80244: NEG
80245: PUSH
80246: EMPTY
80247: LIST
80248: LIST
80249: PUSH
80250: LD_INT 1
80252: PUSH
80253: LD_INT 4
80255: NEG
80256: PUSH
80257: EMPTY
80258: LIST
80259: LIST
80260: PUSH
80261: LD_INT 1
80263: PUSH
80264: LD_INT 3
80266: NEG
80267: PUSH
80268: EMPTY
80269: LIST
80270: LIST
80271: PUSH
80272: LD_INT 0
80274: PUSH
80275: LD_INT 3
80277: NEG
80278: PUSH
80279: EMPTY
80280: LIST
80281: LIST
80282: PUSH
80283: LD_INT 1
80285: NEG
80286: PUSH
80287: LD_INT 4
80289: NEG
80290: PUSH
80291: EMPTY
80292: LIST
80293: LIST
80294: PUSH
80295: LD_INT 1
80297: NEG
80298: PUSH
80299: LD_INT 5
80301: NEG
80302: PUSH
80303: EMPTY
80304: LIST
80305: LIST
80306: PUSH
80307: LD_INT 2
80309: PUSH
80310: LD_INT 3
80312: NEG
80313: PUSH
80314: EMPTY
80315: LIST
80316: LIST
80317: PUSH
80318: LD_INT 2
80320: NEG
80321: PUSH
80322: LD_INT 5
80324: NEG
80325: PUSH
80326: EMPTY
80327: LIST
80328: LIST
80329: PUSH
80330: LD_INT 3
80332: PUSH
80333: LD_INT 0
80335: PUSH
80336: EMPTY
80337: LIST
80338: LIST
80339: PUSH
80340: LD_INT 3
80342: PUSH
80343: LD_INT 1
80345: NEG
80346: PUSH
80347: EMPTY
80348: LIST
80349: LIST
80350: PUSH
80351: LD_INT 4
80353: PUSH
80354: LD_INT 0
80356: PUSH
80357: EMPTY
80358: LIST
80359: LIST
80360: PUSH
80361: LD_INT 4
80363: PUSH
80364: LD_INT 1
80366: PUSH
80367: EMPTY
80368: LIST
80369: LIST
80370: PUSH
80371: LD_INT 3
80373: PUSH
80374: LD_INT 1
80376: PUSH
80377: EMPTY
80378: LIST
80379: LIST
80380: PUSH
80381: LD_INT 2
80383: PUSH
80384: LD_INT 0
80386: PUSH
80387: EMPTY
80388: LIST
80389: LIST
80390: PUSH
80391: LD_INT 2
80393: PUSH
80394: LD_INT 1
80396: NEG
80397: PUSH
80398: EMPTY
80399: LIST
80400: LIST
80401: PUSH
80402: LD_INT 2
80404: PUSH
80405: LD_INT 2
80407: NEG
80408: PUSH
80409: EMPTY
80410: LIST
80411: LIST
80412: PUSH
80413: LD_INT 4
80415: PUSH
80416: LD_INT 2
80418: PUSH
80419: EMPTY
80420: LIST
80421: LIST
80422: PUSH
80423: LD_INT 4
80425: PUSH
80426: LD_INT 4
80428: PUSH
80429: EMPTY
80430: LIST
80431: LIST
80432: PUSH
80433: LD_INT 4
80435: PUSH
80436: LD_INT 3
80438: PUSH
80439: EMPTY
80440: LIST
80441: LIST
80442: PUSH
80443: LD_INT 5
80445: PUSH
80446: LD_INT 4
80448: PUSH
80449: EMPTY
80450: LIST
80451: LIST
80452: PUSH
80453: LD_INT 5
80455: PUSH
80456: LD_INT 5
80458: PUSH
80459: EMPTY
80460: LIST
80461: LIST
80462: PUSH
80463: LD_INT 4
80465: PUSH
80466: LD_INT 5
80468: PUSH
80469: EMPTY
80470: LIST
80471: LIST
80472: PUSH
80473: LD_INT 3
80475: PUSH
80476: LD_INT 4
80478: PUSH
80479: EMPTY
80480: LIST
80481: LIST
80482: PUSH
80483: LD_INT 3
80485: PUSH
80486: LD_INT 3
80488: PUSH
80489: EMPTY
80490: LIST
80491: LIST
80492: PUSH
80493: LD_INT 5
80495: PUSH
80496: LD_INT 3
80498: PUSH
80499: EMPTY
80500: LIST
80501: LIST
80502: PUSH
80503: LD_INT 3
80505: PUSH
80506: LD_INT 5
80508: PUSH
80509: EMPTY
80510: LIST
80511: LIST
80512: PUSH
80513: EMPTY
80514: LIST
80515: LIST
80516: LIST
80517: LIST
80518: LIST
80519: LIST
80520: LIST
80521: LIST
80522: LIST
80523: LIST
80524: LIST
80525: LIST
80526: LIST
80527: LIST
80528: LIST
80529: LIST
80530: LIST
80531: LIST
80532: LIST
80533: LIST
80534: LIST
80535: LIST
80536: LIST
80537: LIST
80538: LIST
80539: LIST
80540: LIST
80541: LIST
80542: LIST
80543: LIST
80544: LIST
80545: LIST
80546: LIST
80547: LIST
80548: LIST
80549: LIST
80550: LIST
80551: LIST
80552: LIST
80553: LIST
80554: LIST
80555: LIST
80556: LIST
80557: LIST
80558: LIST
80559: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
80560: LD_ADDR_VAR 0 33
80564: PUSH
80565: LD_INT 4
80567: NEG
80568: PUSH
80569: LD_INT 4
80571: NEG
80572: PUSH
80573: EMPTY
80574: LIST
80575: LIST
80576: PUSH
80577: LD_INT 4
80579: NEG
80580: PUSH
80581: LD_INT 5
80583: NEG
80584: PUSH
80585: EMPTY
80586: LIST
80587: LIST
80588: PUSH
80589: LD_INT 3
80591: NEG
80592: PUSH
80593: LD_INT 4
80595: NEG
80596: PUSH
80597: EMPTY
80598: LIST
80599: LIST
80600: PUSH
80601: LD_INT 3
80603: NEG
80604: PUSH
80605: LD_INT 3
80607: NEG
80608: PUSH
80609: EMPTY
80610: LIST
80611: LIST
80612: PUSH
80613: LD_INT 4
80615: NEG
80616: PUSH
80617: LD_INT 3
80619: NEG
80620: PUSH
80621: EMPTY
80622: LIST
80623: LIST
80624: PUSH
80625: LD_INT 5
80627: NEG
80628: PUSH
80629: LD_INT 4
80631: NEG
80632: PUSH
80633: EMPTY
80634: LIST
80635: LIST
80636: PUSH
80637: LD_INT 5
80639: NEG
80640: PUSH
80641: LD_INT 5
80643: NEG
80644: PUSH
80645: EMPTY
80646: LIST
80647: LIST
80648: PUSH
80649: LD_INT 3
80651: NEG
80652: PUSH
80653: LD_INT 5
80655: NEG
80656: PUSH
80657: EMPTY
80658: LIST
80659: LIST
80660: PUSH
80661: LD_INT 5
80663: NEG
80664: PUSH
80665: LD_INT 3
80667: NEG
80668: PUSH
80669: EMPTY
80670: LIST
80671: LIST
80672: PUSH
80673: LD_INT 0
80675: PUSH
80676: LD_INT 3
80678: NEG
80679: PUSH
80680: EMPTY
80681: LIST
80682: LIST
80683: PUSH
80684: LD_INT 0
80686: PUSH
80687: LD_INT 4
80689: NEG
80690: PUSH
80691: EMPTY
80692: LIST
80693: LIST
80694: PUSH
80695: LD_INT 1
80697: PUSH
80698: LD_INT 3
80700: NEG
80701: PUSH
80702: EMPTY
80703: LIST
80704: LIST
80705: PUSH
80706: LD_INT 1
80708: PUSH
80709: LD_INT 2
80711: NEG
80712: PUSH
80713: EMPTY
80714: LIST
80715: LIST
80716: PUSH
80717: LD_INT 0
80719: PUSH
80720: LD_INT 2
80722: NEG
80723: PUSH
80724: EMPTY
80725: LIST
80726: LIST
80727: PUSH
80728: LD_INT 1
80730: NEG
80731: PUSH
80732: LD_INT 3
80734: NEG
80735: PUSH
80736: EMPTY
80737: LIST
80738: LIST
80739: PUSH
80740: LD_INT 1
80742: NEG
80743: PUSH
80744: LD_INT 4
80746: NEG
80747: PUSH
80748: EMPTY
80749: LIST
80750: LIST
80751: PUSH
80752: LD_INT 2
80754: PUSH
80755: LD_INT 2
80757: NEG
80758: PUSH
80759: EMPTY
80760: LIST
80761: LIST
80762: PUSH
80763: LD_INT 2
80765: NEG
80766: PUSH
80767: LD_INT 4
80769: NEG
80770: PUSH
80771: EMPTY
80772: LIST
80773: LIST
80774: PUSH
80775: LD_INT 4
80777: PUSH
80778: LD_INT 0
80780: PUSH
80781: EMPTY
80782: LIST
80783: LIST
80784: PUSH
80785: LD_INT 4
80787: PUSH
80788: LD_INT 1
80790: NEG
80791: PUSH
80792: EMPTY
80793: LIST
80794: LIST
80795: PUSH
80796: LD_INT 5
80798: PUSH
80799: LD_INT 0
80801: PUSH
80802: EMPTY
80803: LIST
80804: LIST
80805: PUSH
80806: LD_INT 5
80808: PUSH
80809: LD_INT 1
80811: PUSH
80812: EMPTY
80813: LIST
80814: LIST
80815: PUSH
80816: LD_INT 4
80818: PUSH
80819: LD_INT 1
80821: PUSH
80822: EMPTY
80823: LIST
80824: LIST
80825: PUSH
80826: LD_INT 3
80828: PUSH
80829: LD_INT 0
80831: PUSH
80832: EMPTY
80833: LIST
80834: LIST
80835: PUSH
80836: LD_INT 3
80838: PUSH
80839: LD_INT 1
80841: NEG
80842: PUSH
80843: EMPTY
80844: LIST
80845: LIST
80846: PUSH
80847: LD_INT 3
80849: PUSH
80850: LD_INT 2
80852: NEG
80853: PUSH
80854: EMPTY
80855: LIST
80856: LIST
80857: PUSH
80858: LD_INT 5
80860: PUSH
80861: LD_INT 2
80863: PUSH
80864: EMPTY
80865: LIST
80866: LIST
80867: PUSH
80868: LD_INT 3
80870: PUSH
80871: LD_INT 3
80873: PUSH
80874: EMPTY
80875: LIST
80876: LIST
80877: PUSH
80878: LD_INT 3
80880: PUSH
80881: LD_INT 2
80883: PUSH
80884: EMPTY
80885: LIST
80886: LIST
80887: PUSH
80888: LD_INT 4
80890: PUSH
80891: LD_INT 3
80893: PUSH
80894: EMPTY
80895: LIST
80896: LIST
80897: PUSH
80898: LD_INT 4
80900: PUSH
80901: LD_INT 4
80903: PUSH
80904: EMPTY
80905: LIST
80906: LIST
80907: PUSH
80908: LD_INT 3
80910: PUSH
80911: LD_INT 4
80913: PUSH
80914: EMPTY
80915: LIST
80916: LIST
80917: PUSH
80918: LD_INT 2
80920: PUSH
80921: LD_INT 3
80923: PUSH
80924: EMPTY
80925: LIST
80926: LIST
80927: PUSH
80928: LD_INT 2
80930: PUSH
80931: LD_INT 2
80933: PUSH
80934: EMPTY
80935: LIST
80936: LIST
80937: PUSH
80938: LD_INT 4
80940: PUSH
80941: LD_INT 2
80943: PUSH
80944: EMPTY
80945: LIST
80946: LIST
80947: PUSH
80948: LD_INT 2
80950: PUSH
80951: LD_INT 4
80953: PUSH
80954: EMPTY
80955: LIST
80956: LIST
80957: PUSH
80958: LD_INT 0
80960: PUSH
80961: LD_INT 4
80963: PUSH
80964: EMPTY
80965: LIST
80966: LIST
80967: PUSH
80968: LD_INT 0
80970: PUSH
80971: LD_INT 3
80973: PUSH
80974: EMPTY
80975: LIST
80976: LIST
80977: PUSH
80978: LD_INT 1
80980: PUSH
80981: LD_INT 4
80983: PUSH
80984: EMPTY
80985: LIST
80986: LIST
80987: PUSH
80988: LD_INT 1
80990: PUSH
80991: LD_INT 5
80993: PUSH
80994: EMPTY
80995: LIST
80996: LIST
80997: PUSH
80998: LD_INT 0
81000: PUSH
81001: LD_INT 5
81003: PUSH
81004: EMPTY
81005: LIST
81006: LIST
81007: PUSH
81008: LD_INT 1
81010: NEG
81011: PUSH
81012: LD_INT 4
81014: PUSH
81015: EMPTY
81016: LIST
81017: LIST
81018: PUSH
81019: LD_INT 1
81021: NEG
81022: PUSH
81023: LD_INT 3
81025: PUSH
81026: EMPTY
81027: LIST
81028: LIST
81029: PUSH
81030: LD_INT 2
81032: PUSH
81033: LD_INT 5
81035: PUSH
81036: EMPTY
81037: LIST
81038: LIST
81039: PUSH
81040: LD_INT 2
81042: NEG
81043: PUSH
81044: LD_INT 3
81046: PUSH
81047: EMPTY
81048: LIST
81049: LIST
81050: PUSH
81051: EMPTY
81052: LIST
81053: LIST
81054: LIST
81055: LIST
81056: LIST
81057: LIST
81058: LIST
81059: LIST
81060: LIST
81061: LIST
81062: LIST
81063: LIST
81064: LIST
81065: LIST
81066: LIST
81067: LIST
81068: LIST
81069: LIST
81070: LIST
81071: LIST
81072: LIST
81073: LIST
81074: LIST
81075: LIST
81076: LIST
81077: LIST
81078: LIST
81079: LIST
81080: LIST
81081: LIST
81082: LIST
81083: LIST
81084: LIST
81085: LIST
81086: LIST
81087: LIST
81088: LIST
81089: LIST
81090: LIST
81091: LIST
81092: LIST
81093: LIST
81094: LIST
81095: LIST
81096: LIST
81097: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
81098: LD_ADDR_VAR 0 34
81102: PUSH
81103: LD_INT 0
81105: PUSH
81106: LD_INT 4
81108: NEG
81109: PUSH
81110: EMPTY
81111: LIST
81112: LIST
81113: PUSH
81114: LD_INT 0
81116: PUSH
81117: LD_INT 5
81119: NEG
81120: PUSH
81121: EMPTY
81122: LIST
81123: LIST
81124: PUSH
81125: LD_INT 1
81127: PUSH
81128: LD_INT 4
81130: NEG
81131: PUSH
81132: EMPTY
81133: LIST
81134: LIST
81135: PUSH
81136: LD_INT 1
81138: PUSH
81139: LD_INT 3
81141: NEG
81142: PUSH
81143: EMPTY
81144: LIST
81145: LIST
81146: PUSH
81147: LD_INT 0
81149: PUSH
81150: LD_INT 3
81152: NEG
81153: PUSH
81154: EMPTY
81155: LIST
81156: LIST
81157: PUSH
81158: LD_INT 1
81160: NEG
81161: PUSH
81162: LD_INT 4
81164: NEG
81165: PUSH
81166: EMPTY
81167: LIST
81168: LIST
81169: PUSH
81170: LD_INT 1
81172: NEG
81173: PUSH
81174: LD_INT 5
81176: NEG
81177: PUSH
81178: EMPTY
81179: LIST
81180: LIST
81181: PUSH
81182: LD_INT 2
81184: PUSH
81185: LD_INT 3
81187: NEG
81188: PUSH
81189: EMPTY
81190: LIST
81191: LIST
81192: PUSH
81193: LD_INT 2
81195: NEG
81196: PUSH
81197: LD_INT 5
81199: NEG
81200: PUSH
81201: EMPTY
81202: LIST
81203: LIST
81204: PUSH
81205: LD_INT 3
81207: PUSH
81208: LD_INT 0
81210: PUSH
81211: EMPTY
81212: LIST
81213: LIST
81214: PUSH
81215: LD_INT 3
81217: PUSH
81218: LD_INT 1
81220: NEG
81221: PUSH
81222: EMPTY
81223: LIST
81224: LIST
81225: PUSH
81226: LD_INT 4
81228: PUSH
81229: LD_INT 0
81231: PUSH
81232: EMPTY
81233: LIST
81234: LIST
81235: PUSH
81236: LD_INT 4
81238: PUSH
81239: LD_INT 1
81241: PUSH
81242: EMPTY
81243: LIST
81244: LIST
81245: PUSH
81246: LD_INT 3
81248: PUSH
81249: LD_INT 1
81251: PUSH
81252: EMPTY
81253: LIST
81254: LIST
81255: PUSH
81256: LD_INT 2
81258: PUSH
81259: LD_INT 0
81261: PUSH
81262: EMPTY
81263: LIST
81264: LIST
81265: PUSH
81266: LD_INT 2
81268: PUSH
81269: LD_INT 1
81271: NEG
81272: PUSH
81273: EMPTY
81274: LIST
81275: LIST
81276: PUSH
81277: LD_INT 2
81279: PUSH
81280: LD_INT 2
81282: NEG
81283: PUSH
81284: EMPTY
81285: LIST
81286: LIST
81287: PUSH
81288: LD_INT 4
81290: PUSH
81291: LD_INT 2
81293: PUSH
81294: EMPTY
81295: LIST
81296: LIST
81297: PUSH
81298: LD_INT 4
81300: PUSH
81301: LD_INT 4
81303: PUSH
81304: EMPTY
81305: LIST
81306: LIST
81307: PUSH
81308: LD_INT 4
81310: PUSH
81311: LD_INT 3
81313: PUSH
81314: EMPTY
81315: LIST
81316: LIST
81317: PUSH
81318: LD_INT 5
81320: PUSH
81321: LD_INT 4
81323: PUSH
81324: EMPTY
81325: LIST
81326: LIST
81327: PUSH
81328: LD_INT 5
81330: PUSH
81331: LD_INT 5
81333: PUSH
81334: EMPTY
81335: LIST
81336: LIST
81337: PUSH
81338: LD_INT 4
81340: PUSH
81341: LD_INT 5
81343: PUSH
81344: EMPTY
81345: LIST
81346: LIST
81347: PUSH
81348: LD_INT 3
81350: PUSH
81351: LD_INT 4
81353: PUSH
81354: EMPTY
81355: LIST
81356: LIST
81357: PUSH
81358: LD_INT 3
81360: PUSH
81361: LD_INT 3
81363: PUSH
81364: EMPTY
81365: LIST
81366: LIST
81367: PUSH
81368: LD_INT 5
81370: PUSH
81371: LD_INT 3
81373: PUSH
81374: EMPTY
81375: LIST
81376: LIST
81377: PUSH
81378: LD_INT 3
81380: PUSH
81381: LD_INT 5
81383: PUSH
81384: EMPTY
81385: LIST
81386: LIST
81387: PUSH
81388: LD_INT 0
81390: PUSH
81391: LD_INT 3
81393: PUSH
81394: EMPTY
81395: LIST
81396: LIST
81397: PUSH
81398: LD_INT 0
81400: PUSH
81401: LD_INT 2
81403: PUSH
81404: EMPTY
81405: LIST
81406: LIST
81407: PUSH
81408: LD_INT 1
81410: PUSH
81411: LD_INT 3
81413: PUSH
81414: EMPTY
81415: LIST
81416: LIST
81417: PUSH
81418: LD_INT 1
81420: PUSH
81421: LD_INT 4
81423: PUSH
81424: EMPTY
81425: LIST
81426: LIST
81427: PUSH
81428: LD_INT 0
81430: PUSH
81431: LD_INT 4
81433: PUSH
81434: EMPTY
81435: LIST
81436: LIST
81437: PUSH
81438: LD_INT 1
81440: NEG
81441: PUSH
81442: LD_INT 3
81444: PUSH
81445: EMPTY
81446: LIST
81447: LIST
81448: PUSH
81449: LD_INT 1
81451: NEG
81452: PUSH
81453: LD_INT 2
81455: PUSH
81456: EMPTY
81457: LIST
81458: LIST
81459: PUSH
81460: LD_INT 2
81462: PUSH
81463: LD_INT 4
81465: PUSH
81466: EMPTY
81467: LIST
81468: LIST
81469: PUSH
81470: LD_INT 2
81472: NEG
81473: PUSH
81474: LD_INT 2
81476: PUSH
81477: EMPTY
81478: LIST
81479: LIST
81480: PUSH
81481: LD_INT 4
81483: NEG
81484: PUSH
81485: LD_INT 0
81487: PUSH
81488: EMPTY
81489: LIST
81490: LIST
81491: PUSH
81492: LD_INT 4
81494: NEG
81495: PUSH
81496: LD_INT 1
81498: NEG
81499: PUSH
81500: EMPTY
81501: LIST
81502: LIST
81503: PUSH
81504: LD_INT 3
81506: NEG
81507: PUSH
81508: LD_INT 0
81510: PUSH
81511: EMPTY
81512: LIST
81513: LIST
81514: PUSH
81515: LD_INT 3
81517: NEG
81518: PUSH
81519: LD_INT 1
81521: PUSH
81522: EMPTY
81523: LIST
81524: LIST
81525: PUSH
81526: LD_INT 4
81528: NEG
81529: PUSH
81530: LD_INT 1
81532: PUSH
81533: EMPTY
81534: LIST
81535: LIST
81536: PUSH
81537: LD_INT 5
81539: NEG
81540: PUSH
81541: LD_INT 0
81543: PUSH
81544: EMPTY
81545: LIST
81546: LIST
81547: PUSH
81548: LD_INT 5
81550: NEG
81551: PUSH
81552: LD_INT 1
81554: NEG
81555: PUSH
81556: EMPTY
81557: LIST
81558: LIST
81559: PUSH
81560: LD_INT 5
81562: NEG
81563: PUSH
81564: LD_INT 2
81566: NEG
81567: PUSH
81568: EMPTY
81569: LIST
81570: LIST
81571: PUSH
81572: LD_INT 3
81574: NEG
81575: PUSH
81576: LD_INT 2
81578: PUSH
81579: EMPTY
81580: LIST
81581: LIST
81582: PUSH
81583: EMPTY
81584: LIST
81585: LIST
81586: LIST
81587: LIST
81588: LIST
81589: LIST
81590: LIST
81591: LIST
81592: LIST
81593: LIST
81594: LIST
81595: LIST
81596: LIST
81597: LIST
81598: LIST
81599: LIST
81600: LIST
81601: LIST
81602: LIST
81603: LIST
81604: LIST
81605: LIST
81606: LIST
81607: LIST
81608: LIST
81609: LIST
81610: LIST
81611: LIST
81612: LIST
81613: LIST
81614: LIST
81615: LIST
81616: LIST
81617: LIST
81618: LIST
81619: LIST
81620: LIST
81621: LIST
81622: LIST
81623: LIST
81624: LIST
81625: LIST
81626: LIST
81627: LIST
81628: LIST
81629: ST_TO_ADDR
// end ; end ;
81630: GO 81633
81632: POP
// case btype of b_depot , b_warehouse :
81633: LD_VAR 0 1
81637: PUSH
81638: LD_INT 0
81640: DOUBLE
81641: EQUAL
81642: IFTRUE 81652
81644: LD_INT 1
81646: DOUBLE
81647: EQUAL
81648: IFTRUE 81652
81650: GO 81853
81652: POP
// case nation of nation_american :
81653: LD_VAR 0 5
81657: PUSH
81658: LD_INT 1
81660: DOUBLE
81661: EQUAL
81662: IFTRUE 81666
81664: GO 81722
81666: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
81667: LD_ADDR_VAR 0 9
81671: PUSH
81672: LD_VAR 0 11
81676: PUSH
81677: LD_VAR 0 12
81681: PUSH
81682: LD_VAR 0 13
81686: PUSH
81687: LD_VAR 0 14
81691: PUSH
81692: LD_VAR 0 15
81696: PUSH
81697: LD_VAR 0 16
81701: PUSH
81702: EMPTY
81703: LIST
81704: LIST
81705: LIST
81706: LIST
81707: LIST
81708: LIST
81709: PUSH
81710: LD_VAR 0 4
81714: PUSH
81715: LD_INT 1
81717: PLUS
81718: ARRAY
81719: ST_TO_ADDR
81720: GO 81851
81722: LD_INT 2
81724: DOUBLE
81725: EQUAL
81726: IFTRUE 81730
81728: GO 81786
81730: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
81731: LD_ADDR_VAR 0 9
81735: PUSH
81736: LD_VAR 0 17
81740: PUSH
81741: LD_VAR 0 18
81745: PUSH
81746: LD_VAR 0 19
81750: PUSH
81751: LD_VAR 0 20
81755: PUSH
81756: LD_VAR 0 21
81760: PUSH
81761: LD_VAR 0 22
81765: PUSH
81766: EMPTY
81767: LIST
81768: LIST
81769: LIST
81770: LIST
81771: LIST
81772: LIST
81773: PUSH
81774: LD_VAR 0 4
81778: PUSH
81779: LD_INT 1
81781: PLUS
81782: ARRAY
81783: ST_TO_ADDR
81784: GO 81851
81786: LD_INT 3
81788: DOUBLE
81789: EQUAL
81790: IFTRUE 81794
81792: GO 81850
81794: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
81795: LD_ADDR_VAR 0 9
81799: PUSH
81800: LD_VAR 0 23
81804: PUSH
81805: LD_VAR 0 24
81809: PUSH
81810: LD_VAR 0 25
81814: PUSH
81815: LD_VAR 0 26
81819: PUSH
81820: LD_VAR 0 27
81824: PUSH
81825: LD_VAR 0 28
81829: PUSH
81830: EMPTY
81831: LIST
81832: LIST
81833: LIST
81834: LIST
81835: LIST
81836: LIST
81837: PUSH
81838: LD_VAR 0 4
81842: PUSH
81843: LD_INT 1
81845: PLUS
81846: ARRAY
81847: ST_TO_ADDR
81848: GO 81851
81850: POP
81851: GO 82406
81853: LD_INT 2
81855: DOUBLE
81856: EQUAL
81857: IFTRUE 81867
81859: LD_INT 3
81861: DOUBLE
81862: EQUAL
81863: IFTRUE 81867
81865: GO 81923
81867: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
81868: LD_ADDR_VAR 0 9
81872: PUSH
81873: LD_VAR 0 29
81877: PUSH
81878: LD_VAR 0 30
81882: PUSH
81883: LD_VAR 0 31
81887: PUSH
81888: LD_VAR 0 32
81892: PUSH
81893: LD_VAR 0 33
81897: PUSH
81898: LD_VAR 0 34
81902: PUSH
81903: EMPTY
81904: LIST
81905: LIST
81906: LIST
81907: LIST
81908: LIST
81909: LIST
81910: PUSH
81911: LD_VAR 0 4
81915: PUSH
81916: LD_INT 1
81918: PLUS
81919: ARRAY
81920: ST_TO_ADDR
81921: GO 82406
81923: LD_INT 16
81925: DOUBLE
81926: EQUAL
81927: IFTRUE 81985
81929: LD_INT 17
81931: DOUBLE
81932: EQUAL
81933: IFTRUE 81985
81935: LD_INT 18
81937: DOUBLE
81938: EQUAL
81939: IFTRUE 81985
81941: LD_INT 19
81943: DOUBLE
81944: EQUAL
81945: IFTRUE 81985
81947: LD_INT 22
81949: DOUBLE
81950: EQUAL
81951: IFTRUE 81985
81953: LD_INT 20
81955: DOUBLE
81956: EQUAL
81957: IFTRUE 81985
81959: LD_INT 21
81961: DOUBLE
81962: EQUAL
81963: IFTRUE 81985
81965: LD_INT 23
81967: DOUBLE
81968: EQUAL
81969: IFTRUE 81985
81971: LD_INT 24
81973: DOUBLE
81974: EQUAL
81975: IFTRUE 81985
81977: LD_INT 25
81979: DOUBLE
81980: EQUAL
81981: IFTRUE 81985
81983: GO 82041
81985: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
81986: LD_ADDR_VAR 0 9
81990: PUSH
81991: LD_VAR 0 35
81995: PUSH
81996: LD_VAR 0 36
82000: PUSH
82001: LD_VAR 0 37
82005: PUSH
82006: LD_VAR 0 38
82010: PUSH
82011: LD_VAR 0 39
82015: PUSH
82016: LD_VAR 0 40
82020: PUSH
82021: EMPTY
82022: LIST
82023: LIST
82024: LIST
82025: LIST
82026: LIST
82027: LIST
82028: PUSH
82029: LD_VAR 0 4
82033: PUSH
82034: LD_INT 1
82036: PLUS
82037: ARRAY
82038: ST_TO_ADDR
82039: GO 82406
82041: LD_INT 6
82043: DOUBLE
82044: EQUAL
82045: IFTRUE 82097
82047: LD_INT 7
82049: DOUBLE
82050: EQUAL
82051: IFTRUE 82097
82053: LD_INT 8
82055: DOUBLE
82056: EQUAL
82057: IFTRUE 82097
82059: LD_INT 13
82061: DOUBLE
82062: EQUAL
82063: IFTRUE 82097
82065: LD_INT 12
82067: DOUBLE
82068: EQUAL
82069: IFTRUE 82097
82071: LD_INT 15
82073: DOUBLE
82074: EQUAL
82075: IFTRUE 82097
82077: LD_INT 11
82079: DOUBLE
82080: EQUAL
82081: IFTRUE 82097
82083: LD_INT 14
82085: DOUBLE
82086: EQUAL
82087: IFTRUE 82097
82089: LD_INT 10
82091: DOUBLE
82092: EQUAL
82093: IFTRUE 82097
82095: GO 82153
82097: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
82098: LD_ADDR_VAR 0 9
82102: PUSH
82103: LD_VAR 0 41
82107: PUSH
82108: LD_VAR 0 42
82112: PUSH
82113: LD_VAR 0 43
82117: PUSH
82118: LD_VAR 0 44
82122: PUSH
82123: LD_VAR 0 45
82127: PUSH
82128: LD_VAR 0 46
82132: PUSH
82133: EMPTY
82134: LIST
82135: LIST
82136: LIST
82137: LIST
82138: LIST
82139: LIST
82140: PUSH
82141: LD_VAR 0 4
82145: PUSH
82146: LD_INT 1
82148: PLUS
82149: ARRAY
82150: ST_TO_ADDR
82151: GO 82406
82153: LD_INT 36
82155: DOUBLE
82156: EQUAL
82157: IFTRUE 82161
82159: GO 82217
82161: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
82162: LD_ADDR_VAR 0 9
82166: PUSH
82167: LD_VAR 0 47
82171: PUSH
82172: LD_VAR 0 48
82176: PUSH
82177: LD_VAR 0 49
82181: PUSH
82182: LD_VAR 0 50
82186: PUSH
82187: LD_VAR 0 51
82191: PUSH
82192: LD_VAR 0 52
82196: PUSH
82197: EMPTY
82198: LIST
82199: LIST
82200: LIST
82201: LIST
82202: LIST
82203: LIST
82204: PUSH
82205: LD_VAR 0 4
82209: PUSH
82210: LD_INT 1
82212: PLUS
82213: ARRAY
82214: ST_TO_ADDR
82215: GO 82406
82217: LD_INT 4
82219: DOUBLE
82220: EQUAL
82221: IFTRUE 82243
82223: LD_INT 5
82225: DOUBLE
82226: EQUAL
82227: IFTRUE 82243
82229: LD_INT 34
82231: DOUBLE
82232: EQUAL
82233: IFTRUE 82243
82235: LD_INT 37
82237: DOUBLE
82238: EQUAL
82239: IFTRUE 82243
82241: GO 82299
82243: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
82244: LD_ADDR_VAR 0 9
82248: PUSH
82249: LD_VAR 0 53
82253: PUSH
82254: LD_VAR 0 54
82258: PUSH
82259: LD_VAR 0 55
82263: PUSH
82264: LD_VAR 0 56
82268: PUSH
82269: LD_VAR 0 57
82273: PUSH
82274: LD_VAR 0 58
82278: PUSH
82279: EMPTY
82280: LIST
82281: LIST
82282: LIST
82283: LIST
82284: LIST
82285: LIST
82286: PUSH
82287: LD_VAR 0 4
82291: PUSH
82292: LD_INT 1
82294: PLUS
82295: ARRAY
82296: ST_TO_ADDR
82297: GO 82406
82299: LD_INT 31
82301: DOUBLE
82302: EQUAL
82303: IFTRUE 82349
82305: LD_INT 32
82307: DOUBLE
82308: EQUAL
82309: IFTRUE 82349
82311: LD_INT 33
82313: DOUBLE
82314: EQUAL
82315: IFTRUE 82349
82317: LD_INT 27
82319: DOUBLE
82320: EQUAL
82321: IFTRUE 82349
82323: LD_INT 26
82325: DOUBLE
82326: EQUAL
82327: IFTRUE 82349
82329: LD_INT 28
82331: DOUBLE
82332: EQUAL
82333: IFTRUE 82349
82335: LD_INT 29
82337: DOUBLE
82338: EQUAL
82339: IFTRUE 82349
82341: LD_INT 30
82343: DOUBLE
82344: EQUAL
82345: IFTRUE 82349
82347: GO 82405
82349: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
82350: LD_ADDR_VAR 0 9
82354: PUSH
82355: LD_VAR 0 59
82359: PUSH
82360: LD_VAR 0 60
82364: PUSH
82365: LD_VAR 0 61
82369: PUSH
82370: LD_VAR 0 62
82374: PUSH
82375: LD_VAR 0 63
82379: PUSH
82380: LD_VAR 0 64
82384: PUSH
82385: EMPTY
82386: LIST
82387: LIST
82388: LIST
82389: LIST
82390: LIST
82391: LIST
82392: PUSH
82393: LD_VAR 0 4
82397: PUSH
82398: LD_INT 1
82400: PLUS
82401: ARRAY
82402: ST_TO_ADDR
82403: GO 82406
82405: POP
// temp_list2 = [ ] ;
82406: LD_ADDR_VAR 0 10
82410: PUSH
82411: EMPTY
82412: ST_TO_ADDR
// for i in temp_list do
82413: LD_ADDR_VAR 0 8
82417: PUSH
82418: LD_VAR 0 9
82422: PUSH
82423: FOR_IN
82424: IFFALSE 82476
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
82426: LD_ADDR_VAR 0 10
82430: PUSH
82431: LD_VAR 0 10
82435: PUSH
82436: LD_VAR 0 8
82440: PUSH
82441: LD_INT 1
82443: ARRAY
82444: PUSH
82445: LD_VAR 0 2
82449: PLUS
82450: PUSH
82451: LD_VAR 0 8
82455: PUSH
82456: LD_INT 2
82458: ARRAY
82459: PUSH
82460: LD_VAR 0 3
82464: PLUS
82465: PUSH
82466: EMPTY
82467: LIST
82468: LIST
82469: PUSH
82470: EMPTY
82471: LIST
82472: ADD
82473: ST_TO_ADDR
82474: GO 82423
82476: POP
82477: POP
// result = temp_list2 ;
82478: LD_ADDR_VAR 0 7
82482: PUSH
82483: LD_VAR 0 10
82487: ST_TO_ADDR
// end ;
82488: LD_VAR 0 7
82492: RET
// export function EnemyInRange ( unit , dist ) ; begin
82493: LD_INT 0
82495: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
82496: LD_ADDR_VAR 0 3
82500: PUSH
82501: LD_VAR 0 1
82505: PPUSH
82506: CALL_OW 255
82510: PPUSH
82511: LD_VAR 0 1
82515: PPUSH
82516: CALL_OW 250
82520: PPUSH
82521: LD_VAR 0 1
82525: PPUSH
82526: CALL_OW 251
82530: PPUSH
82531: LD_VAR 0 2
82535: PPUSH
82536: CALL 56597 0 4
82540: PUSH
82541: LD_INT 4
82543: ARRAY
82544: ST_TO_ADDR
// end ;
82545: LD_VAR 0 3
82549: RET
// export function PlayerSeeMe ( unit ) ; begin
82550: LD_INT 0
82552: PPUSH
// result := See ( your_side , unit ) ;
82553: LD_ADDR_VAR 0 2
82557: PUSH
82558: LD_OWVAR 2
82562: PPUSH
82563: LD_VAR 0 1
82567: PPUSH
82568: CALL_OW 292
82572: ST_TO_ADDR
// end ;
82573: LD_VAR 0 2
82577: RET
// export function ReverseDir ( unit ) ; begin
82578: LD_INT 0
82580: PPUSH
// if not unit then
82581: LD_VAR 0 1
82585: NOT
82586: IFFALSE 82590
// exit ;
82588: GO 82613
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
82590: LD_ADDR_VAR 0 2
82594: PUSH
82595: LD_VAR 0 1
82599: PPUSH
82600: CALL_OW 254
82604: PUSH
82605: LD_INT 3
82607: PLUS
82608: PUSH
82609: LD_INT 6
82611: MOD
82612: ST_TO_ADDR
// end ;
82613: LD_VAR 0 2
82617: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
82618: LD_INT 0
82620: PPUSH
82621: PPUSH
82622: PPUSH
82623: PPUSH
82624: PPUSH
// if not hexes then
82625: LD_VAR 0 2
82629: NOT
82630: IFFALSE 82634
// exit ;
82632: GO 82782
// dist := 9999 ;
82634: LD_ADDR_VAR 0 5
82638: PUSH
82639: LD_INT 9999
82641: ST_TO_ADDR
// for i = 1 to hexes do
82642: LD_ADDR_VAR 0 4
82646: PUSH
82647: DOUBLE
82648: LD_INT 1
82650: DEC
82651: ST_TO_ADDR
82652: LD_VAR 0 2
82656: PUSH
82657: FOR_TO
82658: IFFALSE 82770
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
82660: LD_VAR 0 1
82664: PPUSH
82665: LD_VAR 0 2
82669: PUSH
82670: LD_VAR 0 4
82674: ARRAY
82675: PUSH
82676: LD_INT 1
82678: ARRAY
82679: PPUSH
82680: LD_VAR 0 2
82684: PUSH
82685: LD_VAR 0 4
82689: ARRAY
82690: PUSH
82691: LD_INT 2
82693: ARRAY
82694: PPUSH
82695: CALL_OW 297
82699: PUSH
82700: LD_VAR 0 5
82704: LESS
82705: IFFALSE 82768
// begin hex := hexes [ i ] ;
82707: LD_ADDR_VAR 0 7
82711: PUSH
82712: LD_VAR 0 2
82716: PUSH
82717: LD_VAR 0 4
82721: ARRAY
82722: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
82723: LD_ADDR_VAR 0 5
82727: PUSH
82728: LD_VAR 0 1
82732: PPUSH
82733: LD_VAR 0 2
82737: PUSH
82738: LD_VAR 0 4
82742: ARRAY
82743: PUSH
82744: LD_INT 1
82746: ARRAY
82747: PPUSH
82748: LD_VAR 0 2
82752: PUSH
82753: LD_VAR 0 4
82757: ARRAY
82758: PUSH
82759: LD_INT 2
82761: ARRAY
82762: PPUSH
82763: CALL_OW 297
82767: ST_TO_ADDR
// end ; end ;
82768: GO 82657
82770: POP
82771: POP
// result := hex ;
82772: LD_ADDR_VAR 0 3
82776: PUSH
82777: LD_VAR 0 7
82781: ST_TO_ADDR
// end ;
82782: LD_VAR 0 3
82786: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
82787: LD_INT 0
82789: PPUSH
82790: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
82791: LD_VAR 0 1
82795: NOT
82796: PUSH
82797: LD_VAR 0 1
82801: PUSH
82802: LD_INT 21
82804: PUSH
82805: LD_INT 2
82807: PUSH
82808: EMPTY
82809: LIST
82810: LIST
82811: PUSH
82812: LD_INT 23
82814: PUSH
82815: LD_INT 2
82817: PUSH
82818: EMPTY
82819: LIST
82820: LIST
82821: PUSH
82822: EMPTY
82823: LIST
82824: LIST
82825: PPUSH
82826: CALL_OW 69
82830: IN
82831: NOT
82832: OR
82833: IFFALSE 82837
// exit ;
82835: GO 82884
// for i = 1 to 3 do
82837: LD_ADDR_VAR 0 3
82841: PUSH
82842: DOUBLE
82843: LD_INT 1
82845: DEC
82846: ST_TO_ADDR
82847: LD_INT 3
82849: PUSH
82850: FOR_TO
82851: IFFALSE 82882
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
82853: LD_VAR 0 1
82857: PPUSH
82858: CALL_OW 250
82862: PPUSH
82863: LD_VAR 0 1
82867: PPUSH
82868: CALL_OW 251
82872: PPUSH
82873: LD_INT 1
82875: PPUSH
82876: CALL_OW 453
82880: GO 82850
82882: POP
82883: POP
// end ;
82884: LD_VAR 0 2
82888: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
82889: LD_INT 0
82891: PPUSH
82892: PPUSH
82893: PPUSH
82894: PPUSH
82895: PPUSH
82896: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
82897: LD_VAR 0 1
82901: NOT
82902: PUSH
82903: LD_VAR 0 2
82907: NOT
82908: OR
82909: PUSH
82910: LD_VAR 0 1
82914: PPUSH
82915: CALL_OW 314
82919: OR
82920: IFFALSE 82924
// exit ;
82922: GO 83365
// x := GetX ( enemy_unit ) ;
82924: LD_ADDR_VAR 0 7
82928: PUSH
82929: LD_VAR 0 2
82933: PPUSH
82934: CALL_OW 250
82938: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
82939: LD_ADDR_VAR 0 8
82943: PUSH
82944: LD_VAR 0 2
82948: PPUSH
82949: CALL_OW 251
82953: ST_TO_ADDR
// if not x or not y then
82954: LD_VAR 0 7
82958: NOT
82959: PUSH
82960: LD_VAR 0 8
82964: NOT
82965: OR
82966: IFFALSE 82970
// exit ;
82968: GO 83365
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
82970: LD_ADDR_VAR 0 6
82974: PUSH
82975: LD_VAR 0 7
82979: PPUSH
82980: LD_INT 0
82982: PPUSH
82983: LD_INT 4
82985: PPUSH
82986: CALL_OW 272
82990: PUSH
82991: LD_VAR 0 8
82995: PPUSH
82996: LD_INT 0
82998: PPUSH
82999: LD_INT 4
83001: PPUSH
83002: CALL_OW 273
83006: PUSH
83007: EMPTY
83008: LIST
83009: LIST
83010: PUSH
83011: LD_VAR 0 7
83015: PPUSH
83016: LD_INT 1
83018: PPUSH
83019: LD_INT 4
83021: PPUSH
83022: CALL_OW 272
83026: PUSH
83027: LD_VAR 0 8
83031: PPUSH
83032: LD_INT 1
83034: PPUSH
83035: LD_INT 4
83037: PPUSH
83038: CALL_OW 273
83042: PUSH
83043: EMPTY
83044: LIST
83045: LIST
83046: PUSH
83047: LD_VAR 0 7
83051: PPUSH
83052: LD_INT 2
83054: PPUSH
83055: LD_INT 4
83057: PPUSH
83058: CALL_OW 272
83062: PUSH
83063: LD_VAR 0 8
83067: PPUSH
83068: LD_INT 2
83070: PPUSH
83071: LD_INT 4
83073: PPUSH
83074: CALL_OW 273
83078: PUSH
83079: EMPTY
83080: LIST
83081: LIST
83082: PUSH
83083: LD_VAR 0 7
83087: PPUSH
83088: LD_INT 3
83090: PPUSH
83091: LD_INT 4
83093: PPUSH
83094: CALL_OW 272
83098: PUSH
83099: LD_VAR 0 8
83103: PPUSH
83104: LD_INT 3
83106: PPUSH
83107: LD_INT 4
83109: PPUSH
83110: CALL_OW 273
83114: PUSH
83115: EMPTY
83116: LIST
83117: LIST
83118: PUSH
83119: LD_VAR 0 7
83123: PPUSH
83124: LD_INT 4
83126: PPUSH
83127: LD_INT 4
83129: PPUSH
83130: CALL_OW 272
83134: PUSH
83135: LD_VAR 0 8
83139: PPUSH
83140: LD_INT 4
83142: PPUSH
83143: LD_INT 4
83145: PPUSH
83146: CALL_OW 273
83150: PUSH
83151: EMPTY
83152: LIST
83153: LIST
83154: PUSH
83155: LD_VAR 0 7
83159: PPUSH
83160: LD_INT 5
83162: PPUSH
83163: LD_INT 4
83165: PPUSH
83166: CALL_OW 272
83170: PUSH
83171: LD_VAR 0 8
83175: PPUSH
83176: LD_INT 5
83178: PPUSH
83179: LD_INT 4
83181: PPUSH
83182: CALL_OW 273
83186: PUSH
83187: EMPTY
83188: LIST
83189: LIST
83190: PUSH
83191: EMPTY
83192: LIST
83193: LIST
83194: LIST
83195: LIST
83196: LIST
83197: LIST
83198: ST_TO_ADDR
// for i = tmp downto 1 do
83199: LD_ADDR_VAR 0 4
83203: PUSH
83204: DOUBLE
83205: LD_VAR 0 6
83209: INC
83210: ST_TO_ADDR
83211: LD_INT 1
83213: PUSH
83214: FOR_DOWNTO
83215: IFFALSE 83316
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
83217: LD_VAR 0 6
83221: PUSH
83222: LD_VAR 0 4
83226: ARRAY
83227: PUSH
83228: LD_INT 1
83230: ARRAY
83231: PPUSH
83232: LD_VAR 0 6
83236: PUSH
83237: LD_VAR 0 4
83241: ARRAY
83242: PUSH
83243: LD_INT 2
83245: ARRAY
83246: PPUSH
83247: CALL_OW 488
83251: NOT
83252: PUSH
83253: LD_VAR 0 6
83257: PUSH
83258: LD_VAR 0 4
83262: ARRAY
83263: PUSH
83264: LD_INT 1
83266: ARRAY
83267: PPUSH
83268: LD_VAR 0 6
83272: PUSH
83273: LD_VAR 0 4
83277: ARRAY
83278: PUSH
83279: LD_INT 2
83281: ARRAY
83282: PPUSH
83283: CALL_OW 428
83287: PUSH
83288: LD_INT 0
83290: NONEQUAL
83291: OR
83292: IFFALSE 83314
// tmp := Delete ( tmp , i ) ;
83294: LD_ADDR_VAR 0 6
83298: PUSH
83299: LD_VAR 0 6
83303: PPUSH
83304: LD_VAR 0 4
83308: PPUSH
83309: CALL_OW 3
83313: ST_TO_ADDR
83314: GO 83214
83316: POP
83317: POP
// j := GetClosestHex ( unit , tmp ) ;
83318: LD_ADDR_VAR 0 5
83322: PUSH
83323: LD_VAR 0 1
83327: PPUSH
83328: LD_VAR 0 6
83332: PPUSH
83333: CALL 82618 0 2
83337: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
83338: LD_VAR 0 1
83342: PPUSH
83343: LD_VAR 0 5
83347: PUSH
83348: LD_INT 1
83350: ARRAY
83351: PPUSH
83352: LD_VAR 0 5
83356: PUSH
83357: LD_INT 2
83359: ARRAY
83360: PPUSH
83361: CALL_OW 111
// end ;
83365: LD_VAR 0 3
83369: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
83370: LD_INT 0
83372: PPUSH
83373: PPUSH
83374: PPUSH
// uc_side = 0 ;
83375: LD_ADDR_OWVAR 20
83379: PUSH
83380: LD_INT 0
83382: ST_TO_ADDR
// uc_nation = 0 ;
83383: LD_ADDR_OWVAR 21
83387: PUSH
83388: LD_INT 0
83390: ST_TO_ADDR
// InitHc_All ( ) ;
83391: CALL_OW 584
// InitVc ;
83395: CALL_OW 20
// if mastodonts then
83399: LD_VAR 0 6
83403: IFFALSE 83470
// for i = 1 to mastodonts do
83405: LD_ADDR_VAR 0 11
83409: PUSH
83410: DOUBLE
83411: LD_INT 1
83413: DEC
83414: ST_TO_ADDR
83415: LD_VAR 0 6
83419: PUSH
83420: FOR_TO
83421: IFFALSE 83468
// begin vc_chassis := 31 ;
83423: LD_ADDR_OWVAR 37
83427: PUSH
83428: LD_INT 31
83430: ST_TO_ADDR
// vc_control := control_rider ;
83431: LD_ADDR_OWVAR 38
83435: PUSH
83436: LD_INT 4
83438: ST_TO_ADDR
// animal := CreateVehicle ;
83439: LD_ADDR_VAR 0 12
83443: PUSH
83444: CALL_OW 45
83448: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83449: LD_VAR 0 12
83453: PPUSH
83454: LD_VAR 0 8
83458: PPUSH
83459: LD_INT 0
83461: PPUSH
83462: CALL 85658 0 3
// end ;
83466: GO 83420
83468: POP
83469: POP
// if horses then
83470: LD_VAR 0 5
83474: IFFALSE 83541
// for i = 1 to horses do
83476: LD_ADDR_VAR 0 11
83480: PUSH
83481: DOUBLE
83482: LD_INT 1
83484: DEC
83485: ST_TO_ADDR
83486: LD_VAR 0 5
83490: PUSH
83491: FOR_TO
83492: IFFALSE 83539
// begin hc_class := 21 ;
83494: LD_ADDR_OWVAR 28
83498: PUSH
83499: LD_INT 21
83501: ST_TO_ADDR
// hc_gallery :=  ;
83502: LD_ADDR_OWVAR 33
83506: PUSH
83507: LD_STRING 
83509: ST_TO_ADDR
// animal := CreateHuman ;
83510: LD_ADDR_VAR 0 12
83514: PUSH
83515: CALL_OW 44
83519: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83520: LD_VAR 0 12
83524: PPUSH
83525: LD_VAR 0 8
83529: PPUSH
83530: LD_INT 0
83532: PPUSH
83533: CALL 85658 0 3
// end ;
83537: GO 83491
83539: POP
83540: POP
// if birds then
83541: LD_VAR 0 1
83545: IFFALSE 83612
// for i = 1 to birds do
83547: LD_ADDR_VAR 0 11
83551: PUSH
83552: DOUBLE
83553: LD_INT 1
83555: DEC
83556: ST_TO_ADDR
83557: LD_VAR 0 1
83561: PUSH
83562: FOR_TO
83563: IFFALSE 83610
// begin hc_class = 18 ;
83565: LD_ADDR_OWVAR 28
83569: PUSH
83570: LD_INT 18
83572: ST_TO_ADDR
// hc_gallery =  ;
83573: LD_ADDR_OWVAR 33
83577: PUSH
83578: LD_STRING 
83580: ST_TO_ADDR
// animal := CreateHuman ;
83581: LD_ADDR_VAR 0 12
83585: PUSH
83586: CALL_OW 44
83590: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83591: LD_VAR 0 12
83595: PPUSH
83596: LD_VAR 0 8
83600: PPUSH
83601: LD_INT 0
83603: PPUSH
83604: CALL 85658 0 3
// end ;
83608: GO 83562
83610: POP
83611: POP
// if tigers then
83612: LD_VAR 0 2
83616: IFFALSE 83700
// for i = 1 to tigers do
83618: LD_ADDR_VAR 0 11
83622: PUSH
83623: DOUBLE
83624: LD_INT 1
83626: DEC
83627: ST_TO_ADDR
83628: LD_VAR 0 2
83632: PUSH
83633: FOR_TO
83634: IFFALSE 83698
// begin hc_class = class_tiger ;
83636: LD_ADDR_OWVAR 28
83640: PUSH
83641: LD_INT 14
83643: ST_TO_ADDR
// hc_gallery =  ;
83644: LD_ADDR_OWVAR 33
83648: PUSH
83649: LD_STRING 
83651: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
83652: LD_ADDR_OWVAR 35
83656: PUSH
83657: LD_INT 7
83659: NEG
83660: PPUSH
83661: LD_INT 7
83663: PPUSH
83664: CALL_OW 12
83668: ST_TO_ADDR
// animal := CreateHuman ;
83669: LD_ADDR_VAR 0 12
83673: PUSH
83674: CALL_OW 44
83678: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83679: LD_VAR 0 12
83683: PPUSH
83684: LD_VAR 0 8
83688: PPUSH
83689: LD_INT 0
83691: PPUSH
83692: CALL 85658 0 3
// end ;
83696: GO 83633
83698: POP
83699: POP
// if apemans then
83700: LD_VAR 0 3
83704: IFFALSE 83827
// for i = 1 to apemans do
83706: LD_ADDR_VAR 0 11
83710: PUSH
83711: DOUBLE
83712: LD_INT 1
83714: DEC
83715: ST_TO_ADDR
83716: LD_VAR 0 3
83720: PUSH
83721: FOR_TO
83722: IFFALSE 83825
// begin hc_class = class_apeman ;
83724: LD_ADDR_OWVAR 28
83728: PUSH
83729: LD_INT 12
83731: ST_TO_ADDR
// hc_gallery =  ;
83732: LD_ADDR_OWVAR 33
83736: PUSH
83737: LD_STRING 
83739: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
83740: LD_ADDR_OWVAR 35
83744: PUSH
83745: LD_INT 5
83747: NEG
83748: PPUSH
83749: LD_INT 5
83751: PPUSH
83752: CALL_OW 12
83756: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
83757: LD_ADDR_OWVAR 31
83761: PUSH
83762: LD_INT 1
83764: PPUSH
83765: LD_INT 3
83767: PPUSH
83768: CALL_OW 12
83772: PUSH
83773: LD_INT 1
83775: PPUSH
83776: LD_INT 3
83778: PPUSH
83779: CALL_OW 12
83783: PUSH
83784: LD_INT 0
83786: PUSH
83787: LD_INT 0
83789: PUSH
83790: EMPTY
83791: LIST
83792: LIST
83793: LIST
83794: LIST
83795: ST_TO_ADDR
// animal := CreateHuman ;
83796: LD_ADDR_VAR 0 12
83800: PUSH
83801: CALL_OW 44
83805: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83806: LD_VAR 0 12
83810: PPUSH
83811: LD_VAR 0 8
83815: PPUSH
83816: LD_INT 0
83818: PPUSH
83819: CALL 85658 0 3
// end ;
83823: GO 83721
83825: POP
83826: POP
// if enchidnas then
83827: LD_VAR 0 4
83831: IFFALSE 83898
// for i = 1 to enchidnas do
83833: LD_ADDR_VAR 0 11
83837: PUSH
83838: DOUBLE
83839: LD_INT 1
83841: DEC
83842: ST_TO_ADDR
83843: LD_VAR 0 4
83847: PUSH
83848: FOR_TO
83849: IFFALSE 83896
// begin hc_class = 13 ;
83851: LD_ADDR_OWVAR 28
83855: PUSH
83856: LD_INT 13
83858: ST_TO_ADDR
// hc_gallery =  ;
83859: LD_ADDR_OWVAR 33
83863: PUSH
83864: LD_STRING 
83866: ST_TO_ADDR
// animal := CreateHuman ;
83867: LD_ADDR_VAR 0 12
83871: PUSH
83872: CALL_OW 44
83876: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83877: LD_VAR 0 12
83881: PPUSH
83882: LD_VAR 0 8
83886: PPUSH
83887: LD_INT 0
83889: PPUSH
83890: CALL 85658 0 3
// end ;
83894: GO 83848
83896: POP
83897: POP
// if fishes then
83898: LD_VAR 0 7
83902: IFFALSE 83969
// for i = 1 to fishes do
83904: LD_ADDR_VAR 0 11
83908: PUSH
83909: DOUBLE
83910: LD_INT 1
83912: DEC
83913: ST_TO_ADDR
83914: LD_VAR 0 7
83918: PUSH
83919: FOR_TO
83920: IFFALSE 83967
// begin hc_class = 20 ;
83922: LD_ADDR_OWVAR 28
83926: PUSH
83927: LD_INT 20
83929: ST_TO_ADDR
// hc_gallery =  ;
83930: LD_ADDR_OWVAR 33
83934: PUSH
83935: LD_STRING 
83937: ST_TO_ADDR
// animal := CreateHuman ;
83938: LD_ADDR_VAR 0 12
83942: PUSH
83943: CALL_OW 44
83947: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
83948: LD_VAR 0 12
83952: PPUSH
83953: LD_VAR 0 9
83957: PPUSH
83958: LD_INT 0
83960: PPUSH
83961: CALL 85658 0 3
// end ;
83965: GO 83919
83967: POP
83968: POP
// end ;
83969: LD_VAR 0 10
83973: RET
// export function WantHeal ( sci , unit ) ; begin
83974: LD_INT 0
83976: PPUSH
// if GetTaskList ( sci ) > 0 then
83977: LD_VAR 0 1
83981: PPUSH
83982: CALL_OW 437
83986: PUSH
83987: LD_INT 0
83989: GREATER
83990: IFFALSE 84060
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
83992: LD_VAR 0 1
83996: PPUSH
83997: CALL_OW 437
84001: PUSH
84002: LD_INT 1
84004: ARRAY
84005: PUSH
84006: LD_INT 1
84008: ARRAY
84009: PUSH
84010: LD_STRING l
84012: EQUAL
84013: PUSH
84014: LD_VAR 0 1
84018: PPUSH
84019: CALL_OW 437
84023: PUSH
84024: LD_INT 1
84026: ARRAY
84027: PUSH
84028: LD_INT 4
84030: ARRAY
84031: PUSH
84032: LD_VAR 0 2
84036: EQUAL
84037: AND
84038: IFFALSE 84050
// result := true else
84040: LD_ADDR_VAR 0 3
84044: PUSH
84045: LD_INT 1
84047: ST_TO_ADDR
84048: GO 84058
// result := false ;
84050: LD_ADDR_VAR 0 3
84054: PUSH
84055: LD_INT 0
84057: ST_TO_ADDR
// end else
84058: GO 84068
// result := false ;
84060: LD_ADDR_VAR 0 3
84064: PUSH
84065: LD_INT 0
84067: ST_TO_ADDR
// end ;
84068: LD_VAR 0 3
84072: RET
// export function HealTarget ( sci ) ; begin
84073: LD_INT 0
84075: PPUSH
// if not sci then
84076: LD_VAR 0 1
84080: NOT
84081: IFFALSE 84085
// exit ;
84083: GO 84150
// result := 0 ;
84085: LD_ADDR_VAR 0 2
84089: PUSH
84090: LD_INT 0
84092: ST_TO_ADDR
// if GetTaskList ( sci ) then
84093: LD_VAR 0 1
84097: PPUSH
84098: CALL_OW 437
84102: IFFALSE 84150
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
84104: LD_VAR 0 1
84108: PPUSH
84109: CALL_OW 437
84113: PUSH
84114: LD_INT 1
84116: ARRAY
84117: PUSH
84118: LD_INT 1
84120: ARRAY
84121: PUSH
84122: LD_STRING l
84124: EQUAL
84125: IFFALSE 84150
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
84127: LD_ADDR_VAR 0 2
84131: PUSH
84132: LD_VAR 0 1
84136: PPUSH
84137: CALL_OW 437
84141: PUSH
84142: LD_INT 1
84144: ARRAY
84145: PUSH
84146: LD_INT 4
84148: ARRAY
84149: ST_TO_ADDR
// end ;
84150: LD_VAR 0 2
84154: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
84155: LD_INT 0
84157: PPUSH
84158: PPUSH
84159: PPUSH
84160: PPUSH
// if not base_units then
84161: LD_VAR 0 1
84165: NOT
84166: IFFALSE 84170
// exit ;
84168: GO 84257
// result := false ;
84170: LD_ADDR_VAR 0 2
84174: PUSH
84175: LD_INT 0
84177: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
84178: LD_ADDR_VAR 0 5
84182: PUSH
84183: LD_VAR 0 1
84187: PPUSH
84188: LD_INT 21
84190: PUSH
84191: LD_INT 3
84193: PUSH
84194: EMPTY
84195: LIST
84196: LIST
84197: PPUSH
84198: CALL_OW 72
84202: ST_TO_ADDR
// if not tmp then
84203: LD_VAR 0 5
84207: NOT
84208: IFFALSE 84212
// exit ;
84210: GO 84257
// for i in tmp do
84212: LD_ADDR_VAR 0 3
84216: PUSH
84217: LD_VAR 0 5
84221: PUSH
84222: FOR_IN
84223: IFFALSE 84255
// begin result := EnemyInRange ( i , 22 ) ;
84225: LD_ADDR_VAR 0 2
84229: PUSH
84230: LD_VAR 0 3
84234: PPUSH
84235: LD_INT 22
84237: PPUSH
84238: CALL 82493 0 2
84242: ST_TO_ADDR
// if result then
84243: LD_VAR 0 2
84247: IFFALSE 84253
// exit ;
84249: POP
84250: POP
84251: GO 84257
// end ;
84253: GO 84222
84255: POP
84256: POP
// end ;
84257: LD_VAR 0 2
84261: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
84262: LD_INT 0
84264: PPUSH
84265: PPUSH
// if not units then
84266: LD_VAR 0 1
84270: NOT
84271: IFFALSE 84275
// exit ;
84273: GO 84345
// result := [ ] ;
84275: LD_ADDR_VAR 0 3
84279: PUSH
84280: EMPTY
84281: ST_TO_ADDR
// for i in units do
84282: LD_ADDR_VAR 0 4
84286: PUSH
84287: LD_VAR 0 1
84291: PUSH
84292: FOR_IN
84293: IFFALSE 84343
// if GetTag ( i ) = tag then
84295: LD_VAR 0 4
84299: PPUSH
84300: CALL_OW 110
84304: PUSH
84305: LD_VAR 0 2
84309: EQUAL
84310: IFFALSE 84341
// result := Insert ( result , result + 1 , i ) ;
84312: LD_ADDR_VAR 0 3
84316: PUSH
84317: LD_VAR 0 3
84321: PPUSH
84322: LD_VAR 0 3
84326: PUSH
84327: LD_INT 1
84329: PLUS
84330: PPUSH
84331: LD_VAR 0 4
84335: PPUSH
84336: CALL_OW 2
84340: ST_TO_ADDR
84341: GO 84292
84343: POP
84344: POP
// end ;
84345: LD_VAR 0 3
84349: RET
// export function IsDriver ( un ) ; begin
84350: LD_INT 0
84352: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
84353: LD_ADDR_VAR 0 2
84357: PUSH
84358: LD_VAR 0 1
84362: PUSH
84363: LD_INT 55
84365: PUSH
84366: EMPTY
84367: LIST
84368: PPUSH
84369: CALL_OW 69
84373: IN
84374: ST_TO_ADDR
// end ;
84375: LD_VAR 0 2
84379: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
84380: LD_INT 0
84382: PPUSH
84383: PPUSH
// list := [ ] ;
84384: LD_ADDR_VAR 0 5
84388: PUSH
84389: EMPTY
84390: ST_TO_ADDR
// case d of 0 :
84391: LD_VAR 0 3
84395: PUSH
84396: LD_INT 0
84398: DOUBLE
84399: EQUAL
84400: IFTRUE 84404
84402: GO 84537
84404: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
84405: LD_ADDR_VAR 0 5
84409: PUSH
84410: LD_VAR 0 1
84414: PUSH
84415: LD_INT 4
84417: MINUS
84418: PUSH
84419: LD_VAR 0 2
84423: PUSH
84424: LD_INT 4
84426: MINUS
84427: PUSH
84428: LD_INT 2
84430: PUSH
84431: EMPTY
84432: LIST
84433: LIST
84434: LIST
84435: PUSH
84436: LD_VAR 0 1
84440: PUSH
84441: LD_INT 3
84443: MINUS
84444: PUSH
84445: LD_VAR 0 2
84449: PUSH
84450: LD_INT 1
84452: PUSH
84453: EMPTY
84454: LIST
84455: LIST
84456: LIST
84457: PUSH
84458: LD_VAR 0 1
84462: PUSH
84463: LD_INT 4
84465: PLUS
84466: PUSH
84467: LD_VAR 0 2
84471: PUSH
84472: LD_INT 4
84474: PUSH
84475: EMPTY
84476: LIST
84477: LIST
84478: LIST
84479: PUSH
84480: LD_VAR 0 1
84484: PUSH
84485: LD_INT 3
84487: PLUS
84488: PUSH
84489: LD_VAR 0 2
84493: PUSH
84494: LD_INT 3
84496: PLUS
84497: PUSH
84498: LD_INT 5
84500: PUSH
84501: EMPTY
84502: LIST
84503: LIST
84504: LIST
84505: PUSH
84506: LD_VAR 0 1
84510: PUSH
84511: LD_VAR 0 2
84515: PUSH
84516: LD_INT 4
84518: PLUS
84519: PUSH
84520: LD_INT 0
84522: PUSH
84523: EMPTY
84524: LIST
84525: LIST
84526: LIST
84527: PUSH
84528: EMPTY
84529: LIST
84530: LIST
84531: LIST
84532: LIST
84533: LIST
84534: ST_TO_ADDR
// end ; 1 :
84535: GO 85235
84537: LD_INT 1
84539: DOUBLE
84540: EQUAL
84541: IFTRUE 84545
84543: GO 84678
84545: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
84546: LD_ADDR_VAR 0 5
84550: PUSH
84551: LD_VAR 0 1
84555: PUSH
84556: LD_VAR 0 2
84560: PUSH
84561: LD_INT 4
84563: MINUS
84564: PUSH
84565: LD_INT 3
84567: PUSH
84568: EMPTY
84569: LIST
84570: LIST
84571: LIST
84572: PUSH
84573: LD_VAR 0 1
84577: PUSH
84578: LD_INT 3
84580: MINUS
84581: PUSH
84582: LD_VAR 0 2
84586: PUSH
84587: LD_INT 3
84589: MINUS
84590: PUSH
84591: LD_INT 2
84593: PUSH
84594: EMPTY
84595: LIST
84596: LIST
84597: LIST
84598: PUSH
84599: LD_VAR 0 1
84603: PUSH
84604: LD_INT 4
84606: MINUS
84607: PUSH
84608: LD_VAR 0 2
84612: PUSH
84613: LD_INT 1
84615: PUSH
84616: EMPTY
84617: LIST
84618: LIST
84619: LIST
84620: PUSH
84621: LD_VAR 0 1
84625: PUSH
84626: LD_VAR 0 2
84630: PUSH
84631: LD_INT 3
84633: PLUS
84634: PUSH
84635: LD_INT 0
84637: PUSH
84638: EMPTY
84639: LIST
84640: LIST
84641: LIST
84642: PUSH
84643: LD_VAR 0 1
84647: PUSH
84648: LD_INT 4
84650: PLUS
84651: PUSH
84652: LD_VAR 0 2
84656: PUSH
84657: LD_INT 4
84659: PLUS
84660: PUSH
84661: LD_INT 5
84663: PUSH
84664: EMPTY
84665: LIST
84666: LIST
84667: LIST
84668: PUSH
84669: EMPTY
84670: LIST
84671: LIST
84672: LIST
84673: LIST
84674: LIST
84675: ST_TO_ADDR
// end ; 2 :
84676: GO 85235
84678: LD_INT 2
84680: DOUBLE
84681: EQUAL
84682: IFTRUE 84686
84684: GO 84815
84686: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
84687: LD_ADDR_VAR 0 5
84691: PUSH
84692: LD_VAR 0 1
84696: PUSH
84697: LD_VAR 0 2
84701: PUSH
84702: LD_INT 3
84704: MINUS
84705: PUSH
84706: LD_INT 3
84708: PUSH
84709: EMPTY
84710: LIST
84711: LIST
84712: LIST
84713: PUSH
84714: LD_VAR 0 1
84718: PUSH
84719: LD_INT 4
84721: PLUS
84722: PUSH
84723: LD_VAR 0 2
84727: PUSH
84728: LD_INT 4
84730: PUSH
84731: EMPTY
84732: LIST
84733: LIST
84734: LIST
84735: PUSH
84736: LD_VAR 0 1
84740: PUSH
84741: LD_VAR 0 2
84745: PUSH
84746: LD_INT 4
84748: PLUS
84749: PUSH
84750: LD_INT 0
84752: PUSH
84753: EMPTY
84754: LIST
84755: LIST
84756: LIST
84757: PUSH
84758: LD_VAR 0 1
84762: PUSH
84763: LD_INT 3
84765: MINUS
84766: PUSH
84767: LD_VAR 0 2
84771: PUSH
84772: LD_INT 1
84774: PUSH
84775: EMPTY
84776: LIST
84777: LIST
84778: LIST
84779: PUSH
84780: LD_VAR 0 1
84784: PUSH
84785: LD_INT 4
84787: MINUS
84788: PUSH
84789: LD_VAR 0 2
84793: PUSH
84794: LD_INT 4
84796: MINUS
84797: PUSH
84798: LD_INT 2
84800: PUSH
84801: EMPTY
84802: LIST
84803: LIST
84804: LIST
84805: PUSH
84806: EMPTY
84807: LIST
84808: LIST
84809: LIST
84810: LIST
84811: LIST
84812: ST_TO_ADDR
// end ; 3 :
84813: GO 85235
84815: LD_INT 3
84817: DOUBLE
84818: EQUAL
84819: IFTRUE 84823
84821: GO 84956
84823: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
84824: LD_ADDR_VAR 0 5
84828: PUSH
84829: LD_VAR 0 1
84833: PUSH
84834: LD_INT 3
84836: PLUS
84837: PUSH
84838: LD_VAR 0 2
84842: PUSH
84843: LD_INT 4
84845: PUSH
84846: EMPTY
84847: LIST
84848: LIST
84849: LIST
84850: PUSH
84851: LD_VAR 0 1
84855: PUSH
84856: LD_INT 4
84858: PLUS
84859: PUSH
84860: LD_VAR 0 2
84864: PUSH
84865: LD_INT 4
84867: PLUS
84868: PUSH
84869: LD_INT 5
84871: PUSH
84872: EMPTY
84873: LIST
84874: LIST
84875: LIST
84876: PUSH
84877: LD_VAR 0 1
84881: PUSH
84882: LD_INT 4
84884: MINUS
84885: PUSH
84886: LD_VAR 0 2
84890: PUSH
84891: LD_INT 1
84893: PUSH
84894: EMPTY
84895: LIST
84896: LIST
84897: LIST
84898: PUSH
84899: LD_VAR 0 1
84903: PUSH
84904: LD_VAR 0 2
84908: PUSH
84909: LD_INT 4
84911: MINUS
84912: PUSH
84913: LD_INT 3
84915: PUSH
84916: EMPTY
84917: LIST
84918: LIST
84919: LIST
84920: PUSH
84921: LD_VAR 0 1
84925: PUSH
84926: LD_INT 3
84928: MINUS
84929: PUSH
84930: LD_VAR 0 2
84934: PUSH
84935: LD_INT 3
84937: MINUS
84938: PUSH
84939: LD_INT 2
84941: PUSH
84942: EMPTY
84943: LIST
84944: LIST
84945: LIST
84946: PUSH
84947: EMPTY
84948: LIST
84949: LIST
84950: LIST
84951: LIST
84952: LIST
84953: ST_TO_ADDR
// end ; 4 :
84954: GO 85235
84956: LD_INT 4
84958: DOUBLE
84959: EQUAL
84960: IFTRUE 84964
84962: GO 85097
84964: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
84965: LD_ADDR_VAR 0 5
84969: PUSH
84970: LD_VAR 0 1
84974: PUSH
84975: LD_VAR 0 2
84979: PUSH
84980: LD_INT 4
84982: PLUS
84983: PUSH
84984: LD_INT 0
84986: PUSH
84987: EMPTY
84988: LIST
84989: LIST
84990: LIST
84991: PUSH
84992: LD_VAR 0 1
84996: PUSH
84997: LD_INT 3
84999: PLUS
85000: PUSH
85001: LD_VAR 0 2
85005: PUSH
85006: LD_INT 3
85008: PLUS
85009: PUSH
85010: LD_INT 5
85012: PUSH
85013: EMPTY
85014: LIST
85015: LIST
85016: LIST
85017: PUSH
85018: LD_VAR 0 1
85022: PUSH
85023: LD_INT 4
85025: PLUS
85026: PUSH
85027: LD_VAR 0 2
85031: PUSH
85032: LD_INT 4
85034: PUSH
85035: EMPTY
85036: LIST
85037: LIST
85038: LIST
85039: PUSH
85040: LD_VAR 0 1
85044: PUSH
85045: LD_VAR 0 2
85049: PUSH
85050: LD_INT 3
85052: MINUS
85053: PUSH
85054: LD_INT 3
85056: PUSH
85057: EMPTY
85058: LIST
85059: LIST
85060: LIST
85061: PUSH
85062: LD_VAR 0 1
85066: PUSH
85067: LD_INT 4
85069: MINUS
85070: PUSH
85071: LD_VAR 0 2
85075: PUSH
85076: LD_INT 4
85078: MINUS
85079: PUSH
85080: LD_INT 2
85082: PUSH
85083: EMPTY
85084: LIST
85085: LIST
85086: LIST
85087: PUSH
85088: EMPTY
85089: LIST
85090: LIST
85091: LIST
85092: LIST
85093: LIST
85094: ST_TO_ADDR
// end ; 5 :
85095: GO 85235
85097: LD_INT 5
85099: DOUBLE
85100: EQUAL
85101: IFTRUE 85105
85103: GO 85234
85105: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
85106: LD_ADDR_VAR 0 5
85110: PUSH
85111: LD_VAR 0 1
85115: PUSH
85116: LD_INT 4
85118: MINUS
85119: PUSH
85120: LD_VAR 0 2
85124: PUSH
85125: LD_INT 1
85127: PUSH
85128: EMPTY
85129: LIST
85130: LIST
85131: LIST
85132: PUSH
85133: LD_VAR 0 1
85137: PUSH
85138: LD_VAR 0 2
85142: PUSH
85143: LD_INT 4
85145: MINUS
85146: PUSH
85147: LD_INT 3
85149: PUSH
85150: EMPTY
85151: LIST
85152: LIST
85153: LIST
85154: PUSH
85155: LD_VAR 0 1
85159: PUSH
85160: LD_INT 4
85162: PLUS
85163: PUSH
85164: LD_VAR 0 2
85168: PUSH
85169: LD_INT 4
85171: PLUS
85172: PUSH
85173: LD_INT 5
85175: PUSH
85176: EMPTY
85177: LIST
85178: LIST
85179: LIST
85180: PUSH
85181: LD_VAR 0 1
85185: PUSH
85186: LD_INT 3
85188: PLUS
85189: PUSH
85190: LD_VAR 0 2
85194: PUSH
85195: LD_INT 4
85197: PUSH
85198: EMPTY
85199: LIST
85200: LIST
85201: LIST
85202: PUSH
85203: LD_VAR 0 1
85207: PUSH
85208: LD_VAR 0 2
85212: PUSH
85213: LD_INT 3
85215: PLUS
85216: PUSH
85217: LD_INT 0
85219: PUSH
85220: EMPTY
85221: LIST
85222: LIST
85223: LIST
85224: PUSH
85225: EMPTY
85226: LIST
85227: LIST
85228: LIST
85229: LIST
85230: LIST
85231: ST_TO_ADDR
// end ; end ;
85232: GO 85235
85234: POP
// result := list ;
85235: LD_ADDR_VAR 0 4
85239: PUSH
85240: LD_VAR 0 5
85244: ST_TO_ADDR
// end ;
85245: LD_VAR 0 4
85249: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
85250: LD_INT 0
85252: PPUSH
85253: PPUSH
85254: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
85255: LD_VAR 0 1
85259: NOT
85260: PUSH
85261: LD_VAR 0 2
85265: PUSH
85266: LD_INT 1
85268: PUSH
85269: LD_INT 2
85271: PUSH
85272: LD_INT 3
85274: PUSH
85275: LD_INT 4
85277: PUSH
85278: EMPTY
85279: LIST
85280: LIST
85281: LIST
85282: LIST
85283: IN
85284: NOT
85285: OR
85286: IFFALSE 85290
// exit ;
85288: GO 85382
// tmp := [ ] ;
85290: LD_ADDR_VAR 0 5
85294: PUSH
85295: EMPTY
85296: ST_TO_ADDR
// for i in units do
85297: LD_ADDR_VAR 0 4
85301: PUSH
85302: LD_VAR 0 1
85306: PUSH
85307: FOR_IN
85308: IFFALSE 85351
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
85310: LD_ADDR_VAR 0 5
85314: PUSH
85315: LD_VAR 0 5
85319: PPUSH
85320: LD_VAR 0 5
85324: PUSH
85325: LD_INT 1
85327: PLUS
85328: PPUSH
85329: LD_VAR 0 4
85333: PPUSH
85334: LD_VAR 0 2
85338: PPUSH
85339: CALL_OW 259
85343: PPUSH
85344: CALL_OW 2
85348: ST_TO_ADDR
85349: GO 85307
85351: POP
85352: POP
// if not tmp then
85353: LD_VAR 0 5
85357: NOT
85358: IFFALSE 85362
// exit ;
85360: GO 85382
// result := SortListByListDesc ( units , tmp ) ;
85362: LD_ADDR_VAR 0 3
85366: PUSH
85367: LD_VAR 0 1
85371: PPUSH
85372: LD_VAR 0 5
85376: PPUSH
85377: CALL_OW 77
85381: ST_TO_ADDR
// end ;
85382: LD_VAR 0 3
85386: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
85387: LD_INT 0
85389: PPUSH
85390: PPUSH
85391: PPUSH
// result := false ;
85392: LD_ADDR_VAR 0 3
85396: PUSH
85397: LD_INT 0
85399: ST_TO_ADDR
// x := GetX ( building ) ;
85400: LD_ADDR_VAR 0 4
85404: PUSH
85405: LD_VAR 0 2
85409: PPUSH
85410: CALL_OW 250
85414: ST_TO_ADDR
// y := GetY ( building ) ;
85415: LD_ADDR_VAR 0 5
85419: PUSH
85420: LD_VAR 0 2
85424: PPUSH
85425: CALL_OW 251
85429: ST_TO_ADDR
// if not building or not x or not y then
85430: LD_VAR 0 2
85434: NOT
85435: PUSH
85436: LD_VAR 0 4
85440: NOT
85441: OR
85442: PUSH
85443: LD_VAR 0 5
85447: NOT
85448: OR
85449: IFFALSE 85453
// exit ;
85451: GO 85545
// if GetTaskList ( unit ) then
85453: LD_VAR 0 1
85457: PPUSH
85458: CALL_OW 437
85462: IFFALSE 85545
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
85464: LD_STRING e
85466: PUSH
85467: LD_VAR 0 1
85471: PPUSH
85472: CALL_OW 437
85476: PUSH
85477: LD_INT 1
85479: ARRAY
85480: PUSH
85481: LD_INT 1
85483: ARRAY
85484: EQUAL
85485: PUSH
85486: LD_VAR 0 4
85490: PUSH
85491: LD_VAR 0 1
85495: PPUSH
85496: CALL_OW 437
85500: PUSH
85501: LD_INT 1
85503: ARRAY
85504: PUSH
85505: LD_INT 2
85507: ARRAY
85508: EQUAL
85509: AND
85510: PUSH
85511: LD_VAR 0 5
85515: PUSH
85516: LD_VAR 0 1
85520: PPUSH
85521: CALL_OW 437
85525: PUSH
85526: LD_INT 1
85528: ARRAY
85529: PUSH
85530: LD_INT 3
85532: ARRAY
85533: EQUAL
85534: AND
85535: IFFALSE 85545
// result := true end ;
85537: LD_ADDR_VAR 0 3
85541: PUSH
85542: LD_INT 1
85544: ST_TO_ADDR
// end ;
85545: LD_VAR 0 3
85549: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
85550: LD_INT 0
85552: PPUSH
// result := false ;
85553: LD_ADDR_VAR 0 4
85557: PUSH
85558: LD_INT 0
85560: ST_TO_ADDR
// if GetTaskList ( unit ) then
85561: LD_VAR 0 1
85565: PPUSH
85566: CALL_OW 437
85570: IFFALSE 85653
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
85572: LD_STRING M
85574: PUSH
85575: LD_VAR 0 1
85579: PPUSH
85580: CALL_OW 437
85584: PUSH
85585: LD_INT 1
85587: ARRAY
85588: PUSH
85589: LD_INT 1
85591: ARRAY
85592: EQUAL
85593: PUSH
85594: LD_VAR 0 2
85598: PUSH
85599: LD_VAR 0 1
85603: PPUSH
85604: CALL_OW 437
85608: PUSH
85609: LD_INT 1
85611: ARRAY
85612: PUSH
85613: LD_INT 2
85615: ARRAY
85616: EQUAL
85617: AND
85618: PUSH
85619: LD_VAR 0 3
85623: PUSH
85624: LD_VAR 0 1
85628: PPUSH
85629: CALL_OW 437
85633: PUSH
85634: LD_INT 1
85636: ARRAY
85637: PUSH
85638: LD_INT 3
85640: ARRAY
85641: EQUAL
85642: AND
85643: IFFALSE 85653
// result := true ;
85645: LD_ADDR_VAR 0 4
85649: PUSH
85650: LD_INT 1
85652: ST_TO_ADDR
// end ; end ;
85653: LD_VAR 0 4
85657: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
85658: LD_INT 0
85660: PPUSH
85661: PPUSH
85662: PPUSH
85663: PPUSH
// if not unit or not area then
85664: LD_VAR 0 1
85668: NOT
85669: PUSH
85670: LD_VAR 0 2
85674: NOT
85675: OR
85676: IFFALSE 85680
// exit ;
85678: GO 85844
// tmp := AreaToList ( area , i ) ;
85680: LD_ADDR_VAR 0 6
85684: PUSH
85685: LD_VAR 0 2
85689: PPUSH
85690: LD_VAR 0 5
85694: PPUSH
85695: CALL_OW 517
85699: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
85700: LD_ADDR_VAR 0 5
85704: PUSH
85705: DOUBLE
85706: LD_INT 1
85708: DEC
85709: ST_TO_ADDR
85710: LD_VAR 0 6
85714: PUSH
85715: LD_INT 1
85717: ARRAY
85718: PUSH
85719: FOR_TO
85720: IFFALSE 85842
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
85722: LD_ADDR_VAR 0 7
85726: PUSH
85727: LD_VAR 0 6
85731: PUSH
85732: LD_INT 1
85734: ARRAY
85735: PUSH
85736: LD_VAR 0 5
85740: ARRAY
85741: PUSH
85742: LD_VAR 0 6
85746: PUSH
85747: LD_INT 2
85749: ARRAY
85750: PUSH
85751: LD_VAR 0 5
85755: ARRAY
85756: PUSH
85757: EMPTY
85758: LIST
85759: LIST
85760: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
85761: LD_VAR 0 7
85765: PUSH
85766: LD_INT 1
85768: ARRAY
85769: PPUSH
85770: LD_VAR 0 7
85774: PUSH
85775: LD_INT 2
85777: ARRAY
85778: PPUSH
85779: CALL_OW 428
85783: PUSH
85784: LD_INT 0
85786: EQUAL
85787: IFFALSE 85840
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
85789: LD_VAR 0 1
85793: PPUSH
85794: LD_VAR 0 7
85798: PUSH
85799: LD_INT 1
85801: ARRAY
85802: PPUSH
85803: LD_VAR 0 7
85807: PUSH
85808: LD_INT 2
85810: ARRAY
85811: PPUSH
85812: LD_VAR 0 3
85816: PPUSH
85817: CALL_OW 48
// result := IsPlaced ( unit ) ;
85821: LD_ADDR_VAR 0 4
85825: PUSH
85826: LD_VAR 0 1
85830: PPUSH
85831: CALL_OW 305
85835: ST_TO_ADDR
// exit ;
85836: POP
85837: POP
85838: GO 85844
// end ; end ;
85840: GO 85719
85842: POP
85843: POP
// end ;
85844: LD_VAR 0 4
85848: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
85849: LD_INT 0
85851: PPUSH
85852: PPUSH
85853: PPUSH
// if not side or side > 8 then
85854: LD_VAR 0 1
85858: NOT
85859: PUSH
85860: LD_VAR 0 1
85864: PUSH
85865: LD_INT 8
85867: GREATER
85868: OR
85869: IFFALSE 85873
// exit ;
85871: GO 86060
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
85873: LD_ADDR_VAR 0 4
85877: PUSH
85878: LD_INT 22
85880: PUSH
85881: LD_VAR 0 1
85885: PUSH
85886: EMPTY
85887: LIST
85888: LIST
85889: PUSH
85890: LD_INT 21
85892: PUSH
85893: LD_INT 3
85895: PUSH
85896: EMPTY
85897: LIST
85898: LIST
85899: PUSH
85900: EMPTY
85901: LIST
85902: LIST
85903: PPUSH
85904: CALL_OW 69
85908: ST_TO_ADDR
// if not tmp then
85909: LD_VAR 0 4
85913: NOT
85914: IFFALSE 85918
// exit ;
85916: GO 86060
// enable_addtolog := true ;
85918: LD_ADDR_OWVAR 81
85922: PUSH
85923: LD_INT 1
85925: ST_TO_ADDR
// AddToLog ( [ ) ;
85926: LD_STRING [
85928: PPUSH
85929: CALL_OW 561
// for i in tmp do
85933: LD_ADDR_VAR 0 3
85937: PUSH
85938: LD_VAR 0 4
85942: PUSH
85943: FOR_IN
85944: IFFALSE 86051
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
85946: LD_STRING [
85948: PUSH
85949: LD_VAR 0 3
85953: PPUSH
85954: CALL_OW 266
85958: STR
85959: PUSH
85960: LD_STRING , 
85962: STR
85963: PUSH
85964: LD_VAR 0 3
85968: PPUSH
85969: CALL_OW 250
85973: STR
85974: PUSH
85975: LD_STRING , 
85977: STR
85978: PUSH
85979: LD_VAR 0 3
85983: PPUSH
85984: CALL_OW 251
85988: STR
85989: PUSH
85990: LD_STRING , 
85992: STR
85993: PUSH
85994: LD_VAR 0 3
85998: PPUSH
85999: CALL_OW 254
86003: STR
86004: PUSH
86005: LD_STRING , 
86007: STR
86008: PUSH
86009: LD_VAR 0 3
86013: PPUSH
86014: LD_INT 1
86016: PPUSH
86017: CALL_OW 268
86021: STR
86022: PUSH
86023: LD_STRING , 
86025: STR
86026: PUSH
86027: LD_VAR 0 3
86031: PPUSH
86032: LD_INT 2
86034: PPUSH
86035: CALL_OW 268
86039: STR
86040: PUSH
86041: LD_STRING ],
86043: STR
86044: PPUSH
86045: CALL_OW 561
// end ;
86049: GO 85943
86051: POP
86052: POP
// AddToLog ( ]; ) ;
86053: LD_STRING ];
86055: PPUSH
86056: CALL_OW 561
// end ;
86060: LD_VAR 0 2
86064: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
86065: LD_INT 0
86067: PPUSH
86068: PPUSH
86069: PPUSH
86070: PPUSH
86071: PPUSH
// if not area or not rate or not max then
86072: LD_VAR 0 1
86076: NOT
86077: PUSH
86078: LD_VAR 0 2
86082: NOT
86083: OR
86084: PUSH
86085: LD_VAR 0 4
86089: NOT
86090: OR
86091: IFFALSE 86095
// exit ;
86093: GO 86287
// while 1 do
86095: LD_INT 1
86097: IFFALSE 86287
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
86099: LD_ADDR_VAR 0 9
86103: PUSH
86104: LD_VAR 0 1
86108: PPUSH
86109: LD_INT 1
86111: PPUSH
86112: CALL_OW 287
86116: PUSH
86117: LD_INT 10
86119: MUL
86120: ST_TO_ADDR
// r := rate / 10 ;
86121: LD_ADDR_VAR 0 7
86125: PUSH
86126: LD_VAR 0 2
86130: PUSH
86131: LD_INT 10
86133: DIVREAL
86134: ST_TO_ADDR
// time := 1 1$00 ;
86135: LD_ADDR_VAR 0 8
86139: PUSH
86140: LD_INT 2100
86142: ST_TO_ADDR
// if amount < min then
86143: LD_VAR 0 9
86147: PUSH
86148: LD_VAR 0 3
86152: LESS
86153: IFFALSE 86171
// r := r * 2 else
86155: LD_ADDR_VAR 0 7
86159: PUSH
86160: LD_VAR 0 7
86164: PUSH
86165: LD_INT 2
86167: MUL
86168: ST_TO_ADDR
86169: GO 86197
// if amount > max then
86171: LD_VAR 0 9
86175: PUSH
86176: LD_VAR 0 4
86180: GREATER
86181: IFFALSE 86197
// r := r / 2 ;
86183: LD_ADDR_VAR 0 7
86187: PUSH
86188: LD_VAR 0 7
86192: PUSH
86193: LD_INT 2
86195: DIVREAL
86196: ST_TO_ADDR
// time := time / r ;
86197: LD_ADDR_VAR 0 8
86201: PUSH
86202: LD_VAR 0 8
86206: PUSH
86207: LD_VAR 0 7
86211: DIVREAL
86212: ST_TO_ADDR
// if time < 0 then
86213: LD_VAR 0 8
86217: PUSH
86218: LD_INT 0
86220: LESS
86221: IFFALSE 86238
// time := time * - 1 ;
86223: LD_ADDR_VAR 0 8
86227: PUSH
86228: LD_VAR 0 8
86232: PUSH
86233: LD_INT 1
86235: NEG
86236: MUL
86237: ST_TO_ADDR
// wait ( time ) ;
86238: LD_VAR 0 8
86242: PPUSH
86243: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
86247: LD_INT 35
86249: PPUSH
86250: LD_INT 875
86252: PPUSH
86253: CALL_OW 12
86257: PPUSH
86258: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
86262: LD_INT 1
86264: PPUSH
86265: LD_INT 5
86267: PPUSH
86268: CALL_OW 12
86272: PPUSH
86273: LD_VAR 0 1
86277: PPUSH
86278: LD_INT 1
86280: PPUSH
86281: CALL_OW 55
// end ;
86285: GO 86095
// end ;
86287: LD_VAR 0 5
86291: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
86292: LD_INT 0
86294: PPUSH
86295: PPUSH
86296: PPUSH
86297: PPUSH
86298: PPUSH
86299: PPUSH
86300: PPUSH
86301: PPUSH
// if not turrets or not factories then
86302: LD_VAR 0 1
86306: NOT
86307: PUSH
86308: LD_VAR 0 2
86312: NOT
86313: OR
86314: IFFALSE 86318
// exit ;
86316: GO 86625
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
86318: LD_ADDR_VAR 0 10
86322: PUSH
86323: LD_INT 5
86325: PUSH
86326: LD_INT 6
86328: PUSH
86329: EMPTY
86330: LIST
86331: LIST
86332: PUSH
86333: LD_INT 2
86335: PUSH
86336: LD_INT 4
86338: PUSH
86339: EMPTY
86340: LIST
86341: LIST
86342: PUSH
86343: LD_INT 3
86345: PUSH
86346: LD_INT 5
86348: PUSH
86349: EMPTY
86350: LIST
86351: LIST
86352: PUSH
86353: EMPTY
86354: LIST
86355: LIST
86356: LIST
86357: PUSH
86358: LD_INT 24
86360: PUSH
86361: LD_INT 25
86363: PUSH
86364: EMPTY
86365: LIST
86366: LIST
86367: PUSH
86368: LD_INT 23
86370: PUSH
86371: LD_INT 27
86373: PUSH
86374: EMPTY
86375: LIST
86376: LIST
86377: PUSH
86378: EMPTY
86379: LIST
86380: LIST
86381: PUSH
86382: LD_INT 42
86384: PUSH
86385: LD_INT 43
86387: PUSH
86388: EMPTY
86389: LIST
86390: LIST
86391: PUSH
86392: LD_INT 44
86394: PUSH
86395: LD_INT 46
86397: PUSH
86398: EMPTY
86399: LIST
86400: LIST
86401: PUSH
86402: LD_INT 45
86404: PUSH
86405: LD_INT 47
86407: PUSH
86408: EMPTY
86409: LIST
86410: LIST
86411: PUSH
86412: EMPTY
86413: LIST
86414: LIST
86415: LIST
86416: PUSH
86417: EMPTY
86418: LIST
86419: LIST
86420: LIST
86421: ST_TO_ADDR
// result := [ ] ;
86422: LD_ADDR_VAR 0 3
86426: PUSH
86427: EMPTY
86428: ST_TO_ADDR
// for i in turrets do
86429: LD_ADDR_VAR 0 4
86433: PUSH
86434: LD_VAR 0 1
86438: PUSH
86439: FOR_IN
86440: IFFALSE 86623
// begin nat := GetNation ( i ) ;
86442: LD_ADDR_VAR 0 7
86446: PUSH
86447: LD_VAR 0 4
86451: PPUSH
86452: CALL_OW 248
86456: ST_TO_ADDR
// weapon := 0 ;
86457: LD_ADDR_VAR 0 8
86461: PUSH
86462: LD_INT 0
86464: ST_TO_ADDR
// if not nat then
86465: LD_VAR 0 7
86469: NOT
86470: IFFALSE 86474
// continue ;
86472: GO 86439
// for j in list [ nat ] do
86474: LD_ADDR_VAR 0 5
86478: PUSH
86479: LD_VAR 0 10
86483: PUSH
86484: LD_VAR 0 7
86488: ARRAY
86489: PUSH
86490: FOR_IN
86491: IFFALSE 86532
// if GetBWeapon ( i ) = j [ 1 ] then
86493: LD_VAR 0 4
86497: PPUSH
86498: CALL_OW 269
86502: PUSH
86503: LD_VAR 0 5
86507: PUSH
86508: LD_INT 1
86510: ARRAY
86511: EQUAL
86512: IFFALSE 86530
// begin weapon := j [ 2 ] ;
86514: LD_ADDR_VAR 0 8
86518: PUSH
86519: LD_VAR 0 5
86523: PUSH
86524: LD_INT 2
86526: ARRAY
86527: ST_TO_ADDR
// break ;
86528: GO 86532
// end ;
86530: GO 86490
86532: POP
86533: POP
// if not weapon then
86534: LD_VAR 0 8
86538: NOT
86539: IFFALSE 86543
// continue ;
86541: GO 86439
// for k in factories do
86543: LD_ADDR_VAR 0 6
86547: PUSH
86548: LD_VAR 0 2
86552: PUSH
86553: FOR_IN
86554: IFFALSE 86619
// begin weapons := AvailableWeaponList ( k ) ;
86556: LD_ADDR_VAR 0 9
86560: PUSH
86561: LD_VAR 0 6
86565: PPUSH
86566: CALL_OW 478
86570: ST_TO_ADDR
// if not weapons then
86571: LD_VAR 0 9
86575: NOT
86576: IFFALSE 86580
// continue ;
86578: GO 86553
// if weapon in weapons then
86580: LD_VAR 0 8
86584: PUSH
86585: LD_VAR 0 9
86589: IN
86590: IFFALSE 86617
// begin result := [ i , weapon ] ;
86592: LD_ADDR_VAR 0 3
86596: PUSH
86597: LD_VAR 0 4
86601: PUSH
86602: LD_VAR 0 8
86606: PUSH
86607: EMPTY
86608: LIST
86609: LIST
86610: ST_TO_ADDR
// exit ;
86611: POP
86612: POP
86613: POP
86614: POP
86615: GO 86625
// end ; end ;
86617: GO 86553
86619: POP
86620: POP
// end ;
86621: GO 86439
86623: POP
86624: POP
// end ;
86625: LD_VAR 0 3
86629: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
86630: LD_INT 0
86632: PPUSH
// if not side or side > 8 then
86633: LD_VAR 0 3
86637: NOT
86638: PUSH
86639: LD_VAR 0 3
86643: PUSH
86644: LD_INT 8
86646: GREATER
86647: OR
86648: IFFALSE 86652
// exit ;
86650: GO 86711
// if not range then
86652: LD_VAR 0 4
86656: NOT
86657: IFFALSE 86668
// range := - 12 ;
86659: LD_ADDR_VAR 0 4
86663: PUSH
86664: LD_INT 12
86666: NEG
86667: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
86668: LD_VAR 0 1
86672: PPUSH
86673: LD_VAR 0 2
86677: PPUSH
86678: LD_VAR 0 3
86682: PPUSH
86683: LD_VAR 0 4
86687: PPUSH
86688: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
86692: LD_VAR 0 1
86696: PPUSH
86697: LD_VAR 0 2
86701: PPUSH
86702: LD_VAR 0 3
86706: PPUSH
86707: CALL_OW 331
// end ;
86711: LD_VAR 0 5
86715: RET
// export function Video ( mode ) ; begin
86716: LD_INT 0
86718: PPUSH
// ingame_video = mode ;
86719: LD_ADDR_OWVAR 52
86723: PUSH
86724: LD_VAR 0 1
86728: ST_TO_ADDR
// interface_hidden = mode ;
86729: LD_ADDR_OWVAR 54
86733: PUSH
86734: LD_VAR 0 1
86738: ST_TO_ADDR
// end ;
86739: LD_VAR 0 2
86743: RET
// export function Join ( array , element ) ; begin
86744: LD_INT 0
86746: PPUSH
// result := Replace ( array , array + 1 , element ) ;
86747: LD_ADDR_VAR 0 3
86751: PUSH
86752: LD_VAR 0 1
86756: PPUSH
86757: LD_VAR 0 1
86761: PUSH
86762: LD_INT 1
86764: PLUS
86765: PPUSH
86766: LD_VAR 0 2
86770: PPUSH
86771: CALL_OW 1
86775: ST_TO_ADDR
// end ;
86776: LD_VAR 0 3
86780: RET
// export function JoinUnion ( array , element ) ; begin
86781: LD_INT 0
86783: PPUSH
// result := array union element ;
86784: LD_ADDR_VAR 0 3
86788: PUSH
86789: LD_VAR 0 1
86793: PUSH
86794: LD_VAR 0 2
86798: UNION
86799: ST_TO_ADDR
// end ;
86800: LD_VAR 0 3
86804: RET
// export function GetBehemoths ( side ) ; begin
86805: LD_INT 0
86807: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
86808: LD_ADDR_VAR 0 2
86812: PUSH
86813: LD_INT 22
86815: PUSH
86816: LD_VAR 0 1
86820: PUSH
86821: EMPTY
86822: LIST
86823: LIST
86824: PUSH
86825: LD_INT 31
86827: PUSH
86828: LD_INT 25
86830: PUSH
86831: EMPTY
86832: LIST
86833: LIST
86834: PUSH
86835: EMPTY
86836: LIST
86837: LIST
86838: PPUSH
86839: CALL_OW 69
86843: ST_TO_ADDR
// end ;
86844: LD_VAR 0 2
86848: RET
// export function Shuffle ( array ) ; var i , index ; begin
86849: LD_INT 0
86851: PPUSH
86852: PPUSH
86853: PPUSH
// result := [ ] ;
86854: LD_ADDR_VAR 0 2
86858: PUSH
86859: EMPTY
86860: ST_TO_ADDR
// if not array then
86861: LD_VAR 0 1
86865: NOT
86866: IFFALSE 86870
// exit ;
86868: GO 86969
// Randomize ;
86870: CALL_OW 10
// for i = array downto 1 do
86874: LD_ADDR_VAR 0 3
86878: PUSH
86879: DOUBLE
86880: LD_VAR 0 1
86884: INC
86885: ST_TO_ADDR
86886: LD_INT 1
86888: PUSH
86889: FOR_DOWNTO
86890: IFFALSE 86967
// begin index := rand ( 1 , array ) ;
86892: LD_ADDR_VAR 0 4
86896: PUSH
86897: LD_INT 1
86899: PPUSH
86900: LD_VAR 0 1
86904: PPUSH
86905: CALL_OW 12
86909: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
86910: LD_ADDR_VAR 0 2
86914: PUSH
86915: LD_VAR 0 2
86919: PPUSH
86920: LD_VAR 0 2
86924: PUSH
86925: LD_INT 1
86927: PLUS
86928: PPUSH
86929: LD_VAR 0 1
86933: PUSH
86934: LD_VAR 0 4
86938: ARRAY
86939: PPUSH
86940: CALL_OW 2
86944: ST_TO_ADDR
// array := Delete ( array , index ) ;
86945: LD_ADDR_VAR 0 1
86949: PUSH
86950: LD_VAR 0 1
86954: PPUSH
86955: LD_VAR 0 4
86959: PPUSH
86960: CALL_OW 3
86964: ST_TO_ADDR
// end ;
86965: GO 86889
86967: POP
86968: POP
// end ;
86969: LD_VAR 0 2
86973: RET
// export function GetBaseMaterials ( base ) ; begin
86974: LD_INT 0
86976: PPUSH
// result := [ 0 , 0 , 0 ] ;
86977: LD_ADDR_VAR 0 2
86981: PUSH
86982: LD_INT 0
86984: PUSH
86985: LD_INT 0
86987: PUSH
86988: LD_INT 0
86990: PUSH
86991: EMPTY
86992: LIST
86993: LIST
86994: LIST
86995: ST_TO_ADDR
// if not base then
86996: LD_VAR 0 1
87000: NOT
87001: IFFALSE 87005
// exit ;
87003: GO 87054
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
87005: LD_ADDR_VAR 0 2
87009: PUSH
87010: LD_VAR 0 1
87014: PPUSH
87015: LD_INT 1
87017: PPUSH
87018: CALL_OW 275
87022: PUSH
87023: LD_VAR 0 1
87027: PPUSH
87028: LD_INT 2
87030: PPUSH
87031: CALL_OW 275
87035: PUSH
87036: LD_VAR 0 1
87040: PPUSH
87041: LD_INT 3
87043: PPUSH
87044: CALL_OW 275
87048: PUSH
87049: EMPTY
87050: LIST
87051: LIST
87052: LIST
87053: ST_TO_ADDR
// end ;
87054: LD_VAR 0 2
87058: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
87059: LD_INT 0
87061: PPUSH
87062: PPUSH
// result := array ;
87063: LD_ADDR_VAR 0 3
87067: PUSH
87068: LD_VAR 0 1
87072: ST_TO_ADDR
// if size > 0 then
87073: LD_VAR 0 2
87077: PUSH
87078: LD_INT 0
87080: GREATER
87081: IFFALSE 87127
// for i := array downto size do
87083: LD_ADDR_VAR 0 4
87087: PUSH
87088: DOUBLE
87089: LD_VAR 0 1
87093: INC
87094: ST_TO_ADDR
87095: LD_VAR 0 2
87099: PUSH
87100: FOR_DOWNTO
87101: IFFALSE 87125
// result := Delete ( result , result ) ;
87103: LD_ADDR_VAR 0 3
87107: PUSH
87108: LD_VAR 0 3
87112: PPUSH
87113: LD_VAR 0 3
87117: PPUSH
87118: CALL_OW 3
87122: ST_TO_ADDR
87123: GO 87100
87125: POP
87126: POP
// end ;
87127: LD_VAR 0 3
87131: RET
// export function ComExit ( unit ) ; var tmp ; begin
87132: LD_INT 0
87134: PPUSH
87135: PPUSH
// if not IsInUnit ( unit ) then
87136: LD_VAR 0 1
87140: PPUSH
87141: CALL_OW 310
87145: NOT
87146: IFFALSE 87150
// exit ;
87148: GO 87210
// tmp := IsInUnit ( unit ) ;
87150: LD_ADDR_VAR 0 3
87154: PUSH
87155: LD_VAR 0 1
87159: PPUSH
87160: CALL_OW 310
87164: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
87165: LD_VAR 0 3
87169: PPUSH
87170: CALL_OW 247
87174: PUSH
87175: LD_INT 2
87177: EQUAL
87178: IFFALSE 87191
// ComExitVehicle ( unit ) else
87180: LD_VAR 0 1
87184: PPUSH
87185: CALL_OW 121
87189: GO 87200
// ComExitBuilding ( unit ) ;
87191: LD_VAR 0 1
87195: PPUSH
87196: CALL_OW 122
// result := tmp ;
87200: LD_ADDR_VAR 0 2
87204: PUSH
87205: LD_VAR 0 3
87209: ST_TO_ADDR
// end ;
87210: LD_VAR 0 2
87214: RET
// export function ResetHc ; begin
87215: LD_INT 0
87217: PPUSH
// InitHc ;
87218: CALL_OW 19
// hc_importance := 0 ;
87222: LD_ADDR_OWVAR 32
87226: PUSH
87227: LD_INT 0
87229: ST_TO_ADDR
// end ;
87230: LD_VAR 0 1
87234: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
87235: LD_INT 0
87237: PPUSH
87238: PPUSH
87239: PPUSH
// _x := ( x1 + x2 ) div 2 ;
87240: LD_ADDR_VAR 0 6
87244: PUSH
87245: LD_VAR 0 1
87249: PUSH
87250: LD_VAR 0 3
87254: PLUS
87255: PUSH
87256: LD_INT 2
87258: DIV
87259: ST_TO_ADDR
// if _x < 0 then
87260: LD_VAR 0 6
87264: PUSH
87265: LD_INT 0
87267: LESS
87268: IFFALSE 87285
// _x := _x * - 1 ;
87270: LD_ADDR_VAR 0 6
87274: PUSH
87275: LD_VAR 0 6
87279: PUSH
87280: LD_INT 1
87282: NEG
87283: MUL
87284: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
87285: LD_ADDR_VAR 0 7
87289: PUSH
87290: LD_VAR 0 2
87294: PUSH
87295: LD_VAR 0 4
87299: PLUS
87300: PUSH
87301: LD_INT 2
87303: DIV
87304: ST_TO_ADDR
// if _y < 0 then
87305: LD_VAR 0 7
87309: PUSH
87310: LD_INT 0
87312: LESS
87313: IFFALSE 87330
// _y := _y * - 1 ;
87315: LD_ADDR_VAR 0 7
87319: PUSH
87320: LD_VAR 0 7
87324: PUSH
87325: LD_INT 1
87327: NEG
87328: MUL
87329: ST_TO_ADDR
// result := [ _x , _y ] ;
87330: LD_ADDR_VAR 0 5
87334: PUSH
87335: LD_VAR 0 6
87339: PUSH
87340: LD_VAR 0 7
87344: PUSH
87345: EMPTY
87346: LIST
87347: LIST
87348: ST_TO_ADDR
// end ;
87349: LD_VAR 0 5
87353: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
87354: LD_INT 0
87356: PPUSH
87357: PPUSH
87358: PPUSH
87359: PPUSH
// task := GetTaskList ( unit ) ;
87360: LD_ADDR_VAR 0 7
87364: PUSH
87365: LD_VAR 0 1
87369: PPUSH
87370: CALL_OW 437
87374: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
87375: LD_VAR 0 7
87379: NOT
87380: PUSH
87381: LD_VAR 0 1
87385: PPUSH
87386: LD_VAR 0 2
87390: PPUSH
87391: CALL_OW 308
87395: NOT
87396: AND
87397: IFFALSE 87401
// exit ;
87399: GO 87519
// if IsInArea ( unit , area ) then
87401: LD_VAR 0 1
87405: PPUSH
87406: LD_VAR 0 2
87410: PPUSH
87411: CALL_OW 308
87415: IFFALSE 87433
// begin ComMoveToArea ( unit , goAway ) ;
87417: LD_VAR 0 1
87421: PPUSH
87422: LD_VAR 0 3
87426: PPUSH
87427: CALL_OW 113
// exit ;
87431: GO 87519
// end ; if task [ 1 ] [ 1 ] <> M then
87433: LD_VAR 0 7
87437: PUSH
87438: LD_INT 1
87440: ARRAY
87441: PUSH
87442: LD_INT 1
87444: ARRAY
87445: PUSH
87446: LD_STRING M
87448: NONEQUAL
87449: IFFALSE 87453
// exit ;
87451: GO 87519
// x := task [ 1 ] [ 2 ] ;
87453: LD_ADDR_VAR 0 5
87457: PUSH
87458: LD_VAR 0 7
87462: PUSH
87463: LD_INT 1
87465: ARRAY
87466: PUSH
87467: LD_INT 2
87469: ARRAY
87470: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
87471: LD_ADDR_VAR 0 6
87475: PUSH
87476: LD_VAR 0 7
87480: PUSH
87481: LD_INT 1
87483: ARRAY
87484: PUSH
87485: LD_INT 3
87487: ARRAY
87488: ST_TO_ADDR
// if InArea ( x , y , area ) then
87489: LD_VAR 0 5
87493: PPUSH
87494: LD_VAR 0 6
87498: PPUSH
87499: LD_VAR 0 2
87503: PPUSH
87504: CALL_OW 309
87508: IFFALSE 87519
// ComStop ( unit ) ;
87510: LD_VAR 0 1
87514: PPUSH
87515: CALL_OW 141
// end ;
87519: LD_VAR 0 4
87523: RET
// export function Abs ( value ) ; begin
87524: LD_INT 0
87526: PPUSH
// result := value ;
87527: LD_ADDR_VAR 0 2
87531: PUSH
87532: LD_VAR 0 1
87536: ST_TO_ADDR
// if value < 0 then
87537: LD_VAR 0 1
87541: PUSH
87542: LD_INT 0
87544: LESS
87545: IFFALSE 87562
// result := value * - 1 ;
87547: LD_ADDR_VAR 0 2
87551: PUSH
87552: LD_VAR 0 1
87556: PUSH
87557: LD_INT 1
87559: NEG
87560: MUL
87561: ST_TO_ADDR
// end ; end_of_file end_of_file
87562: LD_VAR 0 2
87566: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
87567: LD_VAR 0 2
87571: PUSH
87572: LD_INT 100
87574: EQUAL
87575: IFFALSE 88524
// begin if not StreamModeActive then
87577: LD_EXP 133
87581: NOT
87582: IFFALSE 87592
// StreamModeActive := true ;
87584: LD_ADDR_EXP 133
87588: PUSH
87589: LD_INT 1
87591: ST_TO_ADDR
// if p3 = 0 then
87592: LD_VAR 0 3
87596: PUSH
87597: LD_INT 0
87599: EQUAL
87600: IFFALSE 87606
// InitStreamMode ;
87602: CALL 88682 0 0
// if p3 = 1 then
87606: LD_VAR 0 3
87610: PUSH
87611: LD_INT 1
87613: EQUAL
87614: IFFALSE 87624
// sRocket := true ;
87616: LD_ADDR_EXP 138
87620: PUSH
87621: LD_INT 1
87623: ST_TO_ADDR
// if p3 = 2 then
87624: LD_VAR 0 3
87628: PUSH
87629: LD_INT 2
87631: EQUAL
87632: IFFALSE 87642
// sSpeed := true ;
87634: LD_ADDR_EXP 137
87638: PUSH
87639: LD_INT 1
87641: ST_TO_ADDR
// if p3 = 3 then
87642: LD_VAR 0 3
87646: PUSH
87647: LD_INT 3
87649: EQUAL
87650: IFFALSE 87660
// sEngine := true ;
87652: LD_ADDR_EXP 139
87656: PUSH
87657: LD_INT 1
87659: ST_TO_ADDR
// if p3 = 4 then
87660: LD_VAR 0 3
87664: PUSH
87665: LD_INT 4
87667: EQUAL
87668: IFFALSE 87678
// sSpec := true ;
87670: LD_ADDR_EXP 136
87674: PUSH
87675: LD_INT 1
87677: ST_TO_ADDR
// if p3 = 5 then
87678: LD_VAR 0 3
87682: PUSH
87683: LD_INT 5
87685: EQUAL
87686: IFFALSE 87696
// sLevel := true ;
87688: LD_ADDR_EXP 140
87692: PUSH
87693: LD_INT 1
87695: ST_TO_ADDR
// if p3 = 6 then
87696: LD_VAR 0 3
87700: PUSH
87701: LD_INT 6
87703: EQUAL
87704: IFFALSE 87714
// sArmoury := true ;
87706: LD_ADDR_EXP 141
87710: PUSH
87711: LD_INT 1
87713: ST_TO_ADDR
// if p3 = 7 then
87714: LD_VAR 0 3
87718: PUSH
87719: LD_INT 7
87721: EQUAL
87722: IFFALSE 87732
// sRadar := true ;
87724: LD_ADDR_EXP 142
87728: PUSH
87729: LD_INT 1
87731: ST_TO_ADDR
// if p3 = 8 then
87732: LD_VAR 0 3
87736: PUSH
87737: LD_INT 8
87739: EQUAL
87740: IFFALSE 87750
// sBunker := true ;
87742: LD_ADDR_EXP 143
87746: PUSH
87747: LD_INT 1
87749: ST_TO_ADDR
// if p3 = 9 then
87750: LD_VAR 0 3
87754: PUSH
87755: LD_INT 9
87757: EQUAL
87758: IFFALSE 87768
// sHack := true ;
87760: LD_ADDR_EXP 144
87764: PUSH
87765: LD_INT 1
87767: ST_TO_ADDR
// if p3 = 10 then
87768: LD_VAR 0 3
87772: PUSH
87773: LD_INT 10
87775: EQUAL
87776: IFFALSE 87786
// sFire := true ;
87778: LD_ADDR_EXP 145
87782: PUSH
87783: LD_INT 1
87785: ST_TO_ADDR
// if p3 = 11 then
87786: LD_VAR 0 3
87790: PUSH
87791: LD_INT 11
87793: EQUAL
87794: IFFALSE 87804
// sRefresh := true ;
87796: LD_ADDR_EXP 146
87800: PUSH
87801: LD_INT 1
87803: ST_TO_ADDR
// if p3 = 12 then
87804: LD_VAR 0 3
87808: PUSH
87809: LD_INT 12
87811: EQUAL
87812: IFFALSE 87822
// sExp := true ;
87814: LD_ADDR_EXP 147
87818: PUSH
87819: LD_INT 1
87821: ST_TO_ADDR
// if p3 = 13 then
87822: LD_VAR 0 3
87826: PUSH
87827: LD_INT 13
87829: EQUAL
87830: IFFALSE 87840
// sDepot := true ;
87832: LD_ADDR_EXP 148
87836: PUSH
87837: LD_INT 1
87839: ST_TO_ADDR
// if p3 = 14 then
87840: LD_VAR 0 3
87844: PUSH
87845: LD_INT 14
87847: EQUAL
87848: IFFALSE 87858
// sFlag := true ;
87850: LD_ADDR_EXP 149
87854: PUSH
87855: LD_INT 1
87857: ST_TO_ADDR
// if p3 = 15 then
87858: LD_VAR 0 3
87862: PUSH
87863: LD_INT 15
87865: EQUAL
87866: IFFALSE 87876
// sKamikadze := true ;
87868: LD_ADDR_EXP 157
87872: PUSH
87873: LD_INT 1
87875: ST_TO_ADDR
// if p3 = 16 then
87876: LD_VAR 0 3
87880: PUSH
87881: LD_INT 16
87883: EQUAL
87884: IFFALSE 87894
// sTroll := true ;
87886: LD_ADDR_EXP 158
87890: PUSH
87891: LD_INT 1
87893: ST_TO_ADDR
// if p3 = 17 then
87894: LD_VAR 0 3
87898: PUSH
87899: LD_INT 17
87901: EQUAL
87902: IFFALSE 87912
// sSlow := true ;
87904: LD_ADDR_EXP 159
87908: PUSH
87909: LD_INT 1
87911: ST_TO_ADDR
// if p3 = 18 then
87912: LD_VAR 0 3
87916: PUSH
87917: LD_INT 18
87919: EQUAL
87920: IFFALSE 87930
// sLack := true ;
87922: LD_ADDR_EXP 160
87926: PUSH
87927: LD_INT 1
87929: ST_TO_ADDR
// if p3 = 19 then
87930: LD_VAR 0 3
87934: PUSH
87935: LD_INT 19
87937: EQUAL
87938: IFFALSE 87948
// sTank := true ;
87940: LD_ADDR_EXP 162
87944: PUSH
87945: LD_INT 1
87947: ST_TO_ADDR
// if p3 = 20 then
87948: LD_VAR 0 3
87952: PUSH
87953: LD_INT 20
87955: EQUAL
87956: IFFALSE 87966
// sRemote := true ;
87958: LD_ADDR_EXP 163
87962: PUSH
87963: LD_INT 1
87965: ST_TO_ADDR
// if p3 = 21 then
87966: LD_VAR 0 3
87970: PUSH
87971: LD_INT 21
87973: EQUAL
87974: IFFALSE 87984
// sPowell := true ;
87976: LD_ADDR_EXP 164
87980: PUSH
87981: LD_INT 1
87983: ST_TO_ADDR
// if p3 = 22 then
87984: LD_VAR 0 3
87988: PUSH
87989: LD_INT 22
87991: EQUAL
87992: IFFALSE 88002
// sTeleport := true ;
87994: LD_ADDR_EXP 167
87998: PUSH
87999: LD_INT 1
88001: ST_TO_ADDR
// if p3 = 23 then
88002: LD_VAR 0 3
88006: PUSH
88007: LD_INT 23
88009: EQUAL
88010: IFFALSE 88020
// sOilTower := true ;
88012: LD_ADDR_EXP 169
88016: PUSH
88017: LD_INT 1
88019: ST_TO_ADDR
// if p3 = 24 then
88020: LD_VAR 0 3
88024: PUSH
88025: LD_INT 24
88027: EQUAL
88028: IFFALSE 88038
// sShovel := true ;
88030: LD_ADDR_EXP 170
88034: PUSH
88035: LD_INT 1
88037: ST_TO_ADDR
// if p3 = 25 then
88038: LD_VAR 0 3
88042: PUSH
88043: LD_INT 25
88045: EQUAL
88046: IFFALSE 88056
// sSheik := true ;
88048: LD_ADDR_EXP 171
88052: PUSH
88053: LD_INT 1
88055: ST_TO_ADDR
// if p3 = 26 then
88056: LD_VAR 0 3
88060: PUSH
88061: LD_INT 26
88063: EQUAL
88064: IFFALSE 88074
// sEarthquake := true ;
88066: LD_ADDR_EXP 173
88070: PUSH
88071: LD_INT 1
88073: ST_TO_ADDR
// if p3 = 27 then
88074: LD_VAR 0 3
88078: PUSH
88079: LD_INT 27
88081: EQUAL
88082: IFFALSE 88092
// sAI := true ;
88084: LD_ADDR_EXP 174
88088: PUSH
88089: LD_INT 1
88091: ST_TO_ADDR
// if p3 = 28 then
88092: LD_VAR 0 3
88096: PUSH
88097: LD_INT 28
88099: EQUAL
88100: IFFALSE 88110
// sCargo := true ;
88102: LD_ADDR_EXP 177
88106: PUSH
88107: LD_INT 1
88109: ST_TO_ADDR
// if p3 = 29 then
88110: LD_VAR 0 3
88114: PUSH
88115: LD_INT 29
88117: EQUAL
88118: IFFALSE 88128
// sDLaser := true ;
88120: LD_ADDR_EXP 178
88124: PUSH
88125: LD_INT 1
88127: ST_TO_ADDR
// if p3 = 30 then
88128: LD_VAR 0 3
88132: PUSH
88133: LD_INT 30
88135: EQUAL
88136: IFFALSE 88146
// sExchange := true ;
88138: LD_ADDR_EXP 179
88142: PUSH
88143: LD_INT 1
88145: ST_TO_ADDR
// if p3 = 31 then
88146: LD_VAR 0 3
88150: PUSH
88151: LD_INT 31
88153: EQUAL
88154: IFFALSE 88164
// sFac := true ;
88156: LD_ADDR_EXP 180
88160: PUSH
88161: LD_INT 1
88163: ST_TO_ADDR
// if p3 = 32 then
88164: LD_VAR 0 3
88168: PUSH
88169: LD_INT 32
88171: EQUAL
88172: IFFALSE 88182
// sPower := true ;
88174: LD_ADDR_EXP 181
88178: PUSH
88179: LD_INT 1
88181: ST_TO_ADDR
// if p3 = 33 then
88182: LD_VAR 0 3
88186: PUSH
88187: LD_INT 33
88189: EQUAL
88190: IFFALSE 88200
// sRandom := true ;
88192: LD_ADDR_EXP 182
88196: PUSH
88197: LD_INT 1
88199: ST_TO_ADDR
// if p3 = 34 then
88200: LD_VAR 0 3
88204: PUSH
88205: LD_INT 34
88207: EQUAL
88208: IFFALSE 88218
// sShield := true ;
88210: LD_ADDR_EXP 183
88214: PUSH
88215: LD_INT 1
88217: ST_TO_ADDR
// if p3 = 35 then
88218: LD_VAR 0 3
88222: PUSH
88223: LD_INT 35
88225: EQUAL
88226: IFFALSE 88236
// sTime := true ;
88228: LD_ADDR_EXP 184
88232: PUSH
88233: LD_INT 1
88235: ST_TO_ADDR
// if p3 = 36 then
88236: LD_VAR 0 3
88240: PUSH
88241: LD_INT 36
88243: EQUAL
88244: IFFALSE 88254
// sTools := true ;
88246: LD_ADDR_EXP 185
88250: PUSH
88251: LD_INT 1
88253: ST_TO_ADDR
// if p3 = 101 then
88254: LD_VAR 0 3
88258: PUSH
88259: LD_INT 101
88261: EQUAL
88262: IFFALSE 88272
// sSold := true ;
88264: LD_ADDR_EXP 150
88268: PUSH
88269: LD_INT 1
88271: ST_TO_ADDR
// if p3 = 102 then
88272: LD_VAR 0 3
88276: PUSH
88277: LD_INT 102
88279: EQUAL
88280: IFFALSE 88290
// sDiff := true ;
88282: LD_ADDR_EXP 151
88286: PUSH
88287: LD_INT 1
88289: ST_TO_ADDR
// if p3 = 103 then
88290: LD_VAR 0 3
88294: PUSH
88295: LD_INT 103
88297: EQUAL
88298: IFFALSE 88308
// sFog := true ;
88300: LD_ADDR_EXP 154
88304: PUSH
88305: LD_INT 1
88307: ST_TO_ADDR
// if p3 = 104 then
88308: LD_VAR 0 3
88312: PUSH
88313: LD_INT 104
88315: EQUAL
88316: IFFALSE 88326
// sReset := true ;
88318: LD_ADDR_EXP 155
88322: PUSH
88323: LD_INT 1
88325: ST_TO_ADDR
// if p3 = 105 then
88326: LD_VAR 0 3
88330: PUSH
88331: LD_INT 105
88333: EQUAL
88334: IFFALSE 88344
// sSun := true ;
88336: LD_ADDR_EXP 156
88340: PUSH
88341: LD_INT 1
88343: ST_TO_ADDR
// if p3 = 106 then
88344: LD_VAR 0 3
88348: PUSH
88349: LD_INT 106
88351: EQUAL
88352: IFFALSE 88362
// sTiger := true ;
88354: LD_ADDR_EXP 152
88358: PUSH
88359: LD_INT 1
88361: ST_TO_ADDR
// if p3 = 107 then
88362: LD_VAR 0 3
88366: PUSH
88367: LD_INT 107
88369: EQUAL
88370: IFFALSE 88380
// sBomb := true ;
88372: LD_ADDR_EXP 153
88376: PUSH
88377: LD_INT 1
88379: ST_TO_ADDR
// if p3 = 108 then
88380: LD_VAR 0 3
88384: PUSH
88385: LD_INT 108
88387: EQUAL
88388: IFFALSE 88398
// sWound := true ;
88390: LD_ADDR_EXP 161
88394: PUSH
88395: LD_INT 1
88397: ST_TO_ADDR
// if p3 = 109 then
88398: LD_VAR 0 3
88402: PUSH
88403: LD_INT 109
88405: EQUAL
88406: IFFALSE 88416
// sBetray := true ;
88408: LD_ADDR_EXP 165
88412: PUSH
88413: LD_INT 1
88415: ST_TO_ADDR
// if p3 = 110 then
88416: LD_VAR 0 3
88420: PUSH
88421: LD_INT 110
88423: EQUAL
88424: IFFALSE 88434
// sContamin := true ;
88426: LD_ADDR_EXP 166
88430: PUSH
88431: LD_INT 1
88433: ST_TO_ADDR
// if p3 = 111 then
88434: LD_VAR 0 3
88438: PUSH
88439: LD_INT 111
88441: EQUAL
88442: IFFALSE 88452
// sOil := true ;
88444: LD_ADDR_EXP 168
88448: PUSH
88449: LD_INT 1
88451: ST_TO_ADDR
// if p3 = 112 then
88452: LD_VAR 0 3
88456: PUSH
88457: LD_INT 112
88459: EQUAL
88460: IFFALSE 88470
// sStu := true ;
88462: LD_ADDR_EXP 172
88466: PUSH
88467: LD_INT 1
88469: ST_TO_ADDR
// if p3 = 113 then
88470: LD_VAR 0 3
88474: PUSH
88475: LD_INT 113
88477: EQUAL
88478: IFFALSE 88488
// sBazooka := true ;
88480: LD_ADDR_EXP 175
88484: PUSH
88485: LD_INT 1
88487: ST_TO_ADDR
// if p3 = 114 then
88488: LD_VAR 0 3
88492: PUSH
88493: LD_INT 114
88495: EQUAL
88496: IFFALSE 88506
// sMortar := true ;
88498: LD_ADDR_EXP 176
88502: PUSH
88503: LD_INT 1
88505: ST_TO_ADDR
// if p3 = 115 then
88506: LD_VAR 0 3
88510: PUSH
88511: LD_INT 115
88513: EQUAL
88514: IFFALSE 88524
// sRanger := true ;
88516: LD_ADDR_EXP 186
88520: PUSH
88521: LD_INT 1
88523: ST_TO_ADDR
// end ; if p2 = 101 then
88524: LD_VAR 0 2
88528: PUSH
88529: LD_INT 101
88531: EQUAL
88532: IFFALSE 88660
// begin case p3 of 1 :
88534: LD_VAR 0 3
88538: PUSH
88539: LD_INT 1
88541: DOUBLE
88542: EQUAL
88543: IFTRUE 88547
88545: GO 88554
88547: POP
// hHackUnlimitedResources ; 2 :
88548: CALL 99695 0 0
88552: GO 88660
88554: LD_INT 2
88556: DOUBLE
88557: EQUAL
88558: IFTRUE 88562
88560: GO 88569
88562: POP
// hHackSetLevel10 ; 3 :
88563: CALL 99828 0 0
88567: GO 88660
88569: LD_INT 3
88571: DOUBLE
88572: EQUAL
88573: IFTRUE 88577
88575: GO 88584
88577: POP
// hHackSetLevel10YourUnits ; 4 :
88578: CALL 99913 0 0
88582: GO 88660
88584: LD_INT 4
88586: DOUBLE
88587: EQUAL
88588: IFTRUE 88592
88590: GO 88599
88592: POP
// hHackInvincible ; 5 :
88593: CALL 100361 0 0
88597: GO 88660
88599: LD_INT 5
88601: DOUBLE
88602: EQUAL
88603: IFTRUE 88607
88605: GO 88614
88607: POP
// hHackInvisible ; 6 :
88608: CALL 100472 0 0
88612: GO 88660
88614: LD_INT 6
88616: DOUBLE
88617: EQUAL
88618: IFTRUE 88622
88620: GO 88629
88622: POP
// hHackChangeYourSide ; 7 :
88623: CALL 100529 0 0
88627: GO 88660
88629: LD_INT 7
88631: DOUBLE
88632: EQUAL
88633: IFTRUE 88637
88635: GO 88644
88637: POP
// hHackChangeUnitSide ; 8 :
88638: CALL 100571 0 0
88642: GO 88660
88644: LD_INT 8
88646: DOUBLE
88647: EQUAL
88648: IFTRUE 88652
88650: GO 88659
88652: POP
// hHackFog ; end ;
88653: CALL 100672 0 0
88657: GO 88660
88659: POP
// end ; end ;
88660: PPOPN 6
88662: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
88663: GO 88665
88665: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
88666: LD_STRING initStreamRollete();
88668: PPUSH
88669: CALL_OW 559
// InitStreamMode ;
88673: CALL 88682 0 0
// DefineStreamItems ( ) ;
88677: CALL 89122 0 0
// end ;
88681: END
// function InitStreamMode ; begin
88682: LD_INT 0
88684: PPUSH
// streamModeActive := false ;
88685: LD_ADDR_EXP 133
88689: PUSH
88690: LD_INT 0
88692: ST_TO_ADDR
// normalCounter := 36 ;
88693: LD_ADDR_EXP 134
88697: PUSH
88698: LD_INT 36
88700: ST_TO_ADDR
// hardcoreCounter := 16 ;
88701: LD_ADDR_EXP 135
88705: PUSH
88706: LD_INT 16
88708: ST_TO_ADDR
// sRocket := false ;
88709: LD_ADDR_EXP 138
88713: PUSH
88714: LD_INT 0
88716: ST_TO_ADDR
// sSpeed := false ;
88717: LD_ADDR_EXP 137
88721: PUSH
88722: LD_INT 0
88724: ST_TO_ADDR
// sEngine := false ;
88725: LD_ADDR_EXP 139
88729: PUSH
88730: LD_INT 0
88732: ST_TO_ADDR
// sSpec := false ;
88733: LD_ADDR_EXP 136
88737: PUSH
88738: LD_INT 0
88740: ST_TO_ADDR
// sLevel := false ;
88741: LD_ADDR_EXP 140
88745: PUSH
88746: LD_INT 0
88748: ST_TO_ADDR
// sArmoury := false ;
88749: LD_ADDR_EXP 141
88753: PUSH
88754: LD_INT 0
88756: ST_TO_ADDR
// sRadar := false ;
88757: LD_ADDR_EXP 142
88761: PUSH
88762: LD_INT 0
88764: ST_TO_ADDR
// sBunker := false ;
88765: LD_ADDR_EXP 143
88769: PUSH
88770: LD_INT 0
88772: ST_TO_ADDR
// sHack := false ;
88773: LD_ADDR_EXP 144
88777: PUSH
88778: LD_INT 0
88780: ST_TO_ADDR
// sFire := false ;
88781: LD_ADDR_EXP 145
88785: PUSH
88786: LD_INT 0
88788: ST_TO_ADDR
// sRefresh := false ;
88789: LD_ADDR_EXP 146
88793: PUSH
88794: LD_INT 0
88796: ST_TO_ADDR
// sExp := false ;
88797: LD_ADDR_EXP 147
88801: PUSH
88802: LD_INT 0
88804: ST_TO_ADDR
// sDepot := false ;
88805: LD_ADDR_EXP 148
88809: PUSH
88810: LD_INT 0
88812: ST_TO_ADDR
// sFlag := false ;
88813: LD_ADDR_EXP 149
88817: PUSH
88818: LD_INT 0
88820: ST_TO_ADDR
// sKamikadze := false ;
88821: LD_ADDR_EXP 157
88825: PUSH
88826: LD_INT 0
88828: ST_TO_ADDR
// sTroll := false ;
88829: LD_ADDR_EXP 158
88833: PUSH
88834: LD_INT 0
88836: ST_TO_ADDR
// sSlow := false ;
88837: LD_ADDR_EXP 159
88841: PUSH
88842: LD_INT 0
88844: ST_TO_ADDR
// sLack := false ;
88845: LD_ADDR_EXP 160
88849: PUSH
88850: LD_INT 0
88852: ST_TO_ADDR
// sTank := false ;
88853: LD_ADDR_EXP 162
88857: PUSH
88858: LD_INT 0
88860: ST_TO_ADDR
// sRemote := false ;
88861: LD_ADDR_EXP 163
88865: PUSH
88866: LD_INT 0
88868: ST_TO_ADDR
// sPowell := false ;
88869: LD_ADDR_EXP 164
88873: PUSH
88874: LD_INT 0
88876: ST_TO_ADDR
// sTeleport := false ;
88877: LD_ADDR_EXP 167
88881: PUSH
88882: LD_INT 0
88884: ST_TO_ADDR
// sOilTower := false ;
88885: LD_ADDR_EXP 169
88889: PUSH
88890: LD_INT 0
88892: ST_TO_ADDR
// sShovel := false ;
88893: LD_ADDR_EXP 170
88897: PUSH
88898: LD_INT 0
88900: ST_TO_ADDR
// sSheik := false ;
88901: LD_ADDR_EXP 171
88905: PUSH
88906: LD_INT 0
88908: ST_TO_ADDR
// sEarthquake := false ;
88909: LD_ADDR_EXP 173
88913: PUSH
88914: LD_INT 0
88916: ST_TO_ADDR
// sAI := false ;
88917: LD_ADDR_EXP 174
88921: PUSH
88922: LD_INT 0
88924: ST_TO_ADDR
// sCargo := false ;
88925: LD_ADDR_EXP 177
88929: PUSH
88930: LD_INT 0
88932: ST_TO_ADDR
// sDLaser := false ;
88933: LD_ADDR_EXP 178
88937: PUSH
88938: LD_INT 0
88940: ST_TO_ADDR
// sExchange := false ;
88941: LD_ADDR_EXP 179
88945: PUSH
88946: LD_INT 0
88948: ST_TO_ADDR
// sFac := false ;
88949: LD_ADDR_EXP 180
88953: PUSH
88954: LD_INT 0
88956: ST_TO_ADDR
// sPower := false ;
88957: LD_ADDR_EXP 181
88961: PUSH
88962: LD_INT 0
88964: ST_TO_ADDR
// sRandom := false ;
88965: LD_ADDR_EXP 182
88969: PUSH
88970: LD_INT 0
88972: ST_TO_ADDR
// sShield := false ;
88973: LD_ADDR_EXP 183
88977: PUSH
88978: LD_INT 0
88980: ST_TO_ADDR
// sTime := false ;
88981: LD_ADDR_EXP 184
88985: PUSH
88986: LD_INT 0
88988: ST_TO_ADDR
// sTools := false ;
88989: LD_ADDR_EXP 185
88993: PUSH
88994: LD_INT 0
88996: ST_TO_ADDR
// sSold := false ;
88997: LD_ADDR_EXP 150
89001: PUSH
89002: LD_INT 0
89004: ST_TO_ADDR
// sDiff := false ;
89005: LD_ADDR_EXP 151
89009: PUSH
89010: LD_INT 0
89012: ST_TO_ADDR
// sFog := false ;
89013: LD_ADDR_EXP 154
89017: PUSH
89018: LD_INT 0
89020: ST_TO_ADDR
// sReset := false ;
89021: LD_ADDR_EXP 155
89025: PUSH
89026: LD_INT 0
89028: ST_TO_ADDR
// sSun := false ;
89029: LD_ADDR_EXP 156
89033: PUSH
89034: LD_INT 0
89036: ST_TO_ADDR
// sTiger := false ;
89037: LD_ADDR_EXP 152
89041: PUSH
89042: LD_INT 0
89044: ST_TO_ADDR
// sBomb := false ;
89045: LD_ADDR_EXP 153
89049: PUSH
89050: LD_INT 0
89052: ST_TO_ADDR
// sWound := false ;
89053: LD_ADDR_EXP 161
89057: PUSH
89058: LD_INT 0
89060: ST_TO_ADDR
// sBetray := false ;
89061: LD_ADDR_EXP 165
89065: PUSH
89066: LD_INT 0
89068: ST_TO_ADDR
// sContamin := false ;
89069: LD_ADDR_EXP 166
89073: PUSH
89074: LD_INT 0
89076: ST_TO_ADDR
// sOil := false ;
89077: LD_ADDR_EXP 168
89081: PUSH
89082: LD_INT 0
89084: ST_TO_ADDR
// sStu := false ;
89085: LD_ADDR_EXP 172
89089: PUSH
89090: LD_INT 0
89092: ST_TO_ADDR
// sBazooka := false ;
89093: LD_ADDR_EXP 175
89097: PUSH
89098: LD_INT 0
89100: ST_TO_ADDR
// sMortar := false ;
89101: LD_ADDR_EXP 176
89105: PUSH
89106: LD_INT 0
89108: ST_TO_ADDR
// sRanger := false ;
89109: LD_ADDR_EXP 186
89113: PUSH
89114: LD_INT 0
89116: ST_TO_ADDR
// end ;
89117: LD_VAR 0 1
89121: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
89122: LD_INT 0
89124: PPUSH
89125: PPUSH
89126: PPUSH
89127: PPUSH
89128: PPUSH
// result := [ ] ;
89129: LD_ADDR_VAR 0 1
89133: PUSH
89134: EMPTY
89135: ST_TO_ADDR
// if campaign_id = 1 then
89136: LD_OWVAR 69
89140: PUSH
89141: LD_INT 1
89143: EQUAL
89144: IFFALSE 92082
// begin case mission_number of 1 :
89146: LD_OWVAR 70
89150: PUSH
89151: LD_INT 1
89153: DOUBLE
89154: EQUAL
89155: IFTRUE 89159
89157: GO 89223
89159: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
89160: LD_ADDR_VAR 0 1
89164: PUSH
89165: LD_INT 2
89167: PUSH
89168: LD_INT 4
89170: PUSH
89171: LD_INT 11
89173: PUSH
89174: LD_INT 12
89176: PUSH
89177: LD_INT 15
89179: PUSH
89180: LD_INT 16
89182: PUSH
89183: LD_INT 22
89185: PUSH
89186: LD_INT 23
89188: PUSH
89189: LD_INT 26
89191: PUSH
89192: EMPTY
89193: LIST
89194: LIST
89195: LIST
89196: LIST
89197: LIST
89198: LIST
89199: LIST
89200: LIST
89201: LIST
89202: PUSH
89203: LD_INT 101
89205: PUSH
89206: LD_INT 102
89208: PUSH
89209: LD_INT 106
89211: PUSH
89212: EMPTY
89213: LIST
89214: LIST
89215: LIST
89216: PUSH
89217: EMPTY
89218: LIST
89219: LIST
89220: ST_TO_ADDR
89221: GO 92080
89223: LD_INT 2
89225: DOUBLE
89226: EQUAL
89227: IFTRUE 89231
89229: GO 89303
89231: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
89232: LD_ADDR_VAR 0 1
89236: PUSH
89237: LD_INT 2
89239: PUSH
89240: LD_INT 4
89242: PUSH
89243: LD_INT 11
89245: PUSH
89246: LD_INT 12
89248: PUSH
89249: LD_INT 15
89251: PUSH
89252: LD_INT 16
89254: PUSH
89255: LD_INT 22
89257: PUSH
89258: LD_INT 23
89260: PUSH
89261: LD_INT 26
89263: PUSH
89264: EMPTY
89265: LIST
89266: LIST
89267: LIST
89268: LIST
89269: LIST
89270: LIST
89271: LIST
89272: LIST
89273: LIST
89274: PUSH
89275: LD_INT 101
89277: PUSH
89278: LD_INT 102
89280: PUSH
89281: LD_INT 105
89283: PUSH
89284: LD_INT 106
89286: PUSH
89287: LD_INT 108
89289: PUSH
89290: EMPTY
89291: LIST
89292: LIST
89293: LIST
89294: LIST
89295: LIST
89296: PUSH
89297: EMPTY
89298: LIST
89299: LIST
89300: ST_TO_ADDR
89301: GO 92080
89303: LD_INT 3
89305: DOUBLE
89306: EQUAL
89307: IFTRUE 89311
89309: GO 89387
89311: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
89312: LD_ADDR_VAR 0 1
89316: PUSH
89317: LD_INT 2
89319: PUSH
89320: LD_INT 4
89322: PUSH
89323: LD_INT 5
89325: PUSH
89326: LD_INT 11
89328: PUSH
89329: LD_INT 12
89331: PUSH
89332: LD_INT 15
89334: PUSH
89335: LD_INT 16
89337: PUSH
89338: LD_INT 22
89340: PUSH
89341: LD_INT 26
89343: PUSH
89344: LD_INT 36
89346: PUSH
89347: EMPTY
89348: LIST
89349: LIST
89350: LIST
89351: LIST
89352: LIST
89353: LIST
89354: LIST
89355: LIST
89356: LIST
89357: LIST
89358: PUSH
89359: LD_INT 101
89361: PUSH
89362: LD_INT 102
89364: PUSH
89365: LD_INT 105
89367: PUSH
89368: LD_INT 106
89370: PUSH
89371: LD_INT 108
89373: PUSH
89374: EMPTY
89375: LIST
89376: LIST
89377: LIST
89378: LIST
89379: LIST
89380: PUSH
89381: EMPTY
89382: LIST
89383: LIST
89384: ST_TO_ADDR
89385: GO 92080
89387: LD_INT 4
89389: DOUBLE
89390: EQUAL
89391: IFTRUE 89395
89393: GO 89479
89395: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
89396: LD_ADDR_VAR 0 1
89400: PUSH
89401: LD_INT 2
89403: PUSH
89404: LD_INT 4
89406: PUSH
89407: LD_INT 5
89409: PUSH
89410: LD_INT 8
89412: PUSH
89413: LD_INT 11
89415: PUSH
89416: LD_INT 12
89418: PUSH
89419: LD_INT 15
89421: PUSH
89422: LD_INT 16
89424: PUSH
89425: LD_INT 22
89427: PUSH
89428: LD_INT 23
89430: PUSH
89431: LD_INT 26
89433: PUSH
89434: LD_INT 36
89436: PUSH
89437: EMPTY
89438: LIST
89439: LIST
89440: LIST
89441: LIST
89442: LIST
89443: LIST
89444: LIST
89445: LIST
89446: LIST
89447: LIST
89448: LIST
89449: LIST
89450: PUSH
89451: LD_INT 101
89453: PUSH
89454: LD_INT 102
89456: PUSH
89457: LD_INT 105
89459: PUSH
89460: LD_INT 106
89462: PUSH
89463: LD_INT 108
89465: PUSH
89466: EMPTY
89467: LIST
89468: LIST
89469: LIST
89470: LIST
89471: LIST
89472: PUSH
89473: EMPTY
89474: LIST
89475: LIST
89476: ST_TO_ADDR
89477: GO 92080
89479: LD_INT 5
89481: DOUBLE
89482: EQUAL
89483: IFTRUE 89487
89485: GO 89587
89487: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
89488: LD_ADDR_VAR 0 1
89492: PUSH
89493: LD_INT 2
89495: PUSH
89496: LD_INT 4
89498: PUSH
89499: LD_INT 5
89501: PUSH
89502: LD_INT 6
89504: PUSH
89505: LD_INT 8
89507: PUSH
89508: LD_INT 11
89510: PUSH
89511: LD_INT 12
89513: PUSH
89514: LD_INT 15
89516: PUSH
89517: LD_INT 16
89519: PUSH
89520: LD_INT 22
89522: PUSH
89523: LD_INT 23
89525: PUSH
89526: LD_INT 25
89528: PUSH
89529: LD_INT 26
89531: PUSH
89532: LD_INT 36
89534: PUSH
89535: EMPTY
89536: LIST
89537: LIST
89538: LIST
89539: LIST
89540: LIST
89541: LIST
89542: LIST
89543: LIST
89544: LIST
89545: LIST
89546: LIST
89547: LIST
89548: LIST
89549: LIST
89550: PUSH
89551: LD_INT 101
89553: PUSH
89554: LD_INT 102
89556: PUSH
89557: LD_INT 105
89559: PUSH
89560: LD_INT 106
89562: PUSH
89563: LD_INT 108
89565: PUSH
89566: LD_INT 109
89568: PUSH
89569: LD_INT 112
89571: PUSH
89572: EMPTY
89573: LIST
89574: LIST
89575: LIST
89576: LIST
89577: LIST
89578: LIST
89579: LIST
89580: PUSH
89581: EMPTY
89582: LIST
89583: LIST
89584: ST_TO_ADDR
89585: GO 92080
89587: LD_INT 6
89589: DOUBLE
89590: EQUAL
89591: IFTRUE 89595
89593: GO 89715
89595: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
89596: LD_ADDR_VAR 0 1
89600: PUSH
89601: LD_INT 2
89603: PUSH
89604: LD_INT 4
89606: PUSH
89607: LD_INT 5
89609: PUSH
89610: LD_INT 6
89612: PUSH
89613: LD_INT 8
89615: PUSH
89616: LD_INT 11
89618: PUSH
89619: LD_INT 12
89621: PUSH
89622: LD_INT 15
89624: PUSH
89625: LD_INT 16
89627: PUSH
89628: LD_INT 20
89630: PUSH
89631: LD_INT 21
89633: PUSH
89634: LD_INT 22
89636: PUSH
89637: LD_INT 23
89639: PUSH
89640: LD_INT 25
89642: PUSH
89643: LD_INT 26
89645: PUSH
89646: LD_INT 30
89648: PUSH
89649: LD_INT 31
89651: PUSH
89652: LD_INT 32
89654: PUSH
89655: LD_INT 36
89657: PUSH
89658: EMPTY
89659: LIST
89660: LIST
89661: LIST
89662: LIST
89663: LIST
89664: LIST
89665: LIST
89666: LIST
89667: LIST
89668: LIST
89669: LIST
89670: LIST
89671: LIST
89672: LIST
89673: LIST
89674: LIST
89675: LIST
89676: LIST
89677: LIST
89678: PUSH
89679: LD_INT 101
89681: PUSH
89682: LD_INT 102
89684: PUSH
89685: LD_INT 105
89687: PUSH
89688: LD_INT 106
89690: PUSH
89691: LD_INT 108
89693: PUSH
89694: LD_INT 109
89696: PUSH
89697: LD_INT 112
89699: PUSH
89700: EMPTY
89701: LIST
89702: LIST
89703: LIST
89704: LIST
89705: LIST
89706: LIST
89707: LIST
89708: PUSH
89709: EMPTY
89710: LIST
89711: LIST
89712: ST_TO_ADDR
89713: GO 92080
89715: LD_INT 7
89717: DOUBLE
89718: EQUAL
89719: IFTRUE 89723
89721: GO 89823
89723: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
89724: LD_ADDR_VAR 0 1
89728: PUSH
89729: LD_INT 2
89731: PUSH
89732: LD_INT 4
89734: PUSH
89735: LD_INT 5
89737: PUSH
89738: LD_INT 7
89740: PUSH
89741: LD_INT 11
89743: PUSH
89744: LD_INT 12
89746: PUSH
89747: LD_INT 15
89749: PUSH
89750: LD_INT 16
89752: PUSH
89753: LD_INT 20
89755: PUSH
89756: LD_INT 21
89758: PUSH
89759: LD_INT 22
89761: PUSH
89762: LD_INT 23
89764: PUSH
89765: LD_INT 25
89767: PUSH
89768: LD_INT 26
89770: PUSH
89771: EMPTY
89772: LIST
89773: LIST
89774: LIST
89775: LIST
89776: LIST
89777: LIST
89778: LIST
89779: LIST
89780: LIST
89781: LIST
89782: LIST
89783: LIST
89784: LIST
89785: LIST
89786: PUSH
89787: LD_INT 101
89789: PUSH
89790: LD_INT 102
89792: PUSH
89793: LD_INT 103
89795: PUSH
89796: LD_INT 105
89798: PUSH
89799: LD_INT 106
89801: PUSH
89802: LD_INT 108
89804: PUSH
89805: LD_INT 112
89807: PUSH
89808: EMPTY
89809: LIST
89810: LIST
89811: LIST
89812: LIST
89813: LIST
89814: LIST
89815: LIST
89816: PUSH
89817: EMPTY
89818: LIST
89819: LIST
89820: ST_TO_ADDR
89821: GO 92080
89823: LD_INT 8
89825: DOUBLE
89826: EQUAL
89827: IFTRUE 89831
89829: GO 89959
89831: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
89832: LD_ADDR_VAR 0 1
89836: PUSH
89837: LD_INT 2
89839: PUSH
89840: LD_INT 4
89842: PUSH
89843: LD_INT 5
89845: PUSH
89846: LD_INT 6
89848: PUSH
89849: LD_INT 7
89851: PUSH
89852: LD_INT 8
89854: PUSH
89855: LD_INT 11
89857: PUSH
89858: LD_INT 12
89860: PUSH
89861: LD_INT 15
89863: PUSH
89864: LD_INT 16
89866: PUSH
89867: LD_INT 20
89869: PUSH
89870: LD_INT 21
89872: PUSH
89873: LD_INT 22
89875: PUSH
89876: LD_INT 23
89878: PUSH
89879: LD_INT 25
89881: PUSH
89882: LD_INT 26
89884: PUSH
89885: LD_INT 30
89887: PUSH
89888: LD_INT 31
89890: PUSH
89891: LD_INT 32
89893: PUSH
89894: LD_INT 36
89896: PUSH
89897: EMPTY
89898: LIST
89899: LIST
89900: LIST
89901: LIST
89902: LIST
89903: LIST
89904: LIST
89905: LIST
89906: LIST
89907: LIST
89908: LIST
89909: LIST
89910: LIST
89911: LIST
89912: LIST
89913: LIST
89914: LIST
89915: LIST
89916: LIST
89917: LIST
89918: PUSH
89919: LD_INT 101
89921: PUSH
89922: LD_INT 102
89924: PUSH
89925: LD_INT 103
89927: PUSH
89928: LD_INT 105
89930: PUSH
89931: LD_INT 106
89933: PUSH
89934: LD_INT 108
89936: PUSH
89937: LD_INT 109
89939: PUSH
89940: LD_INT 112
89942: PUSH
89943: EMPTY
89944: LIST
89945: LIST
89946: LIST
89947: LIST
89948: LIST
89949: LIST
89950: LIST
89951: LIST
89952: PUSH
89953: EMPTY
89954: LIST
89955: LIST
89956: ST_TO_ADDR
89957: GO 92080
89959: LD_INT 9
89961: DOUBLE
89962: EQUAL
89963: IFTRUE 89967
89965: GO 90103
89967: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
89968: LD_ADDR_VAR 0 1
89972: PUSH
89973: LD_INT 2
89975: PUSH
89976: LD_INT 4
89978: PUSH
89979: LD_INT 5
89981: PUSH
89982: LD_INT 6
89984: PUSH
89985: LD_INT 7
89987: PUSH
89988: LD_INT 8
89990: PUSH
89991: LD_INT 11
89993: PUSH
89994: LD_INT 12
89996: PUSH
89997: LD_INT 15
89999: PUSH
90000: LD_INT 16
90002: PUSH
90003: LD_INT 20
90005: PUSH
90006: LD_INT 21
90008: PUSH
90009: LD_INT 22
90011: PUSH
90012: LD_INT 23
90014: PUSH
90015: LD_INT 25
90017: PUSH
90018: LD_INT 26
90020: PUSH
90021: LD_INT 28
90023: PUSH
90024: LD_INT 30
90026: PUSH
90027: LD_INT 31
90029: PUSH
90030: LD_INT 32
90032: PUSH
90033: LD_INT 36
90035: PUSH
90036: EMPTY
90037: LIST
90038: LIST
90039: LIST
90040: LIST
90041: LIST
90042: LIST
90043: LIST
90044: LIST
90045: LIST
90046: LIST
90047: LIST
90048: LIST
90049: LIST
90050: LIST
90051: LIST
90052: LIST
90053: LIST
90054: LIST
90055: LIST
90056: LIST
90057: LIST
90058: PUSH
90059: LD_INT 101
90061: PUSH
90062: LD_INT 102
90064: PUSH
90065: LD_INT 103
90067: PUSH
90068: LD_INT 105
90070: PUSH
90071: LD_INT 106
90073: PUSH
90074: LD_INT 108
90076: PUSH
90077: LD_INT 109
90079: PUSH
90080: LD_INT 112
90082: PUSH
90083: LD_INT 114
90085: PUSH
90086: EMPTY
90087: LIST
90088: LIST
90089: LIST
90090: LIST
90091: LIST
90092: LIST
90093: LIST
90094: LIST
90095: LIST
90096: PUSH
90097: EMPTY
90098: LIST
90099: LIST
90100: ST_TO_ADDR
90101: GO 92080
90103: LD_INT 10
90105: DOUBLE
90106: EQUAL
90107: IFTRUE 90111
90109: GO 90295
90111: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
90112: LD_ADDR_VAR 0 1
90116: PUSH
90117: LD_INT 2
90119: PUSH
90120: LD_INT 4
90122: PUSH
90123: LD_INT 5
90125: PUSH
90126: LD_INT 6
90128: PUSH
90129: LD_INT 7
90131: PUSH
90132: LD_INT 8
90134: PUSH
90135: LD_INT 9
90137: PUSH
90138: LD_INT 10
90140: PUSH
90141: LD_INT 11
90143: PUSH
90144: LD_INT 12
90146: PUSH
90147: LD_INT 13
90149: PUSH
90150: LD_INT 14
90152: PUSH
90153: LD_INT 15
90155: PUSH
90156: LD_INT 16
90158: PUSH
90159: LD_INT 17
90161: PUSH
90162: LD_INT 18
90164: PUSH
90165: LD_INT 19
90167: PUSH
90168: LD_INT 20
90170: PUSH
90171: LD_INT 21
90173: PUSH
90174: LD_INT 22
90176: PUSH
90177: LD_INT 23
90179: PUSH
90180: LD_INT 24
90182: PUSH
90183: LD_INT 25
90185: PUSH
90186: LD_INT 26
90188: PUSH
90189: LD_INT 28
90191: PUSH
90192: LD_INT 30
90194: PUSH
90195: LD_INT 31
90197: PUSH
90198: LD_INT 32
90200: PUSH
90201: LD_INT 36
90203: PUSH
90204: EMPTY
90205: LIST
90206: LIST
90207: LIST
90208: LIST
90209: LIST
90210: LIST
90211: LIST
90212: LIST
90213: LIST
90214: LIST
90215: LIST
90216: LIST
90217: LIST
90218: LIST
90219: LIST
90220: LIST
90221: LIST
90222: LIST
90223: LIST
90224: LIST
90225: LIST
90226: LIST
90227: LIST
90228: LIST
90229: LIST
90230: LIST
90231: LIST
90232: LIST
90233: LIST
90234: PUSH
90235: LD_INT 101
90237: PUSH
90238: LD_INT 102
90240: PUSH
90241: LD_INT 103
90243: PUSH
90244: LD_INT 104
90246: PUSH
90247: LD_INT 105
90249: PUSH
90250: LD_INT 106
90252: PUSH
90253: LD_INT 107
90255: PUSH
90256: LD_INT 108
90258: PUSH
90259: LD_INT 109
90261: PUSH
90262: LD_INT 110
90264: PUSH
90265: LD_INT 111
90267: PUSH
90268: LD_INT 112
90270: PUSH
90271: LD_INT 114
90273: PUSH
90274: EMPTY
90275: LIST
90276: LIST
90277: LIST
90278: LIST
90279: LIST
90280: LIST
90281: LIST
90282: LIST
90283: LIST
90284: LIST
90285: LIST
90286: LIST
90287: LIST
90288: PUSH
90289: EMPTY
90290: LIST
90291: LIST
90292: ST_TO_ADDR
90293: GO 92080
90295: LD_INT 11
90297: DOUBLE
90298: EQUAL
90299: IFTRUE 90303
90301: GO 90495
90303: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
90304: LD_ADDR_VAR 0 1
90308: PUSH
90309: LD_INT 2
90311: PUSH
90312: LD_INT 3
90314: PUSH
90315: LD_INT 4
90317: PUSH
90318: LD_INT 5
90320: PUSH
90321: LD_INT 6
90323: PUSH
90324: LD_INT 7
90326: PUSH
90327: LD_INT 8
90329: PUSH
90330: LD_INT 9
90332: PUSH
90333: LD_INT 10
90335: PUSH
90336: LD_INT 11
90338: PUSH
90339: LD_INT 12
90341: PUSH
90342: LD_INT 13
90344: PUSH
90345: LD_INT 14
90347: PUSH
90348: LD_INT 15
90350: PUSH
90351: LD_INT 16
90353: PUSH
90354: LD_INT 17
90356: PUSH
90357: LD_INT 18
90359: PUSH
90360: LD_INT 19
90362: PUSH
90363: LD_INT 20
90365: PUSH
90366: LD_INT 21
90368: PUSH
90369: LD_INT 22
90371: PUSH
90372: LD_INT 23
90374: PUSH
90375: LD_INT 24
90377: PUSH
90378: LD_INT 25
90380: PUSH
90381: LD_INT 26
90383: PUSH
90384: LD_INT 28
90386: PUSH
90387: LD_INT 30
90389: PUSH
90390: LD_INT 31
90392: PUSH
90393: LD_INT 32
90395: PUSH
90396: LD_INT 34
90398: PUSH
90399: LD_INT 36
90401: PUSH
90402: EMPTY
90403: LIST
90404: LIST
90405: LIST
90406: LIST
90407: LIST
90408: LIST
90409: LIST
90410: LIST
90411: LIST
90412: LIST
90413: LIST
90414: LIST
90415: LIST
90416: LIST
90417: LIST
90418: LIST
90419: LIST
90420: LIST
90421: LIST
90422: LIST
90423: LIST
90424: LIST
90425: LIST
90426: LIST
90427: LIST
90428: LIST
90429: LIST
90430: LIST
90431: LIST
90432: LIST
90433: LIST
90434: PUSH
90435: LD_INT 101
90437: PUSH
90438: LD_INT 102
90440: PUSH
90441: LD_INT 103
90443: PUSH
90444: LD_INT 104
90446: PUSH
90447: LD_INT 105
90449: PUSH
90450: LD_INT 106
90452: PUSH
90453: LD_INT 107
90455: PUSH
90456: LD_INT 108
90458: PUSH
90459: LD_INT 109
90461: PUSH
90462: LD_INT 110
90464: PUSH
90465: LD_INT 111
90467: PUSH
90468: LD_INT 112
90470: PUSH
90471: LD_INT 114
90473: PUSH
90474: EMPTY
90475: LIST
90476: LIST
90477: LIST
90478: LIST
90479: LIST
90480: LIST
90481: LIST
90482: LIST
90483: LIST
90484: LIST
90485: LIST
90486: LIST
90487: LIST
90488: PUSH
90489: EMPTY
90490: LIST
90491: LIST
90492: ST_TO_ADDR
90493: GO 92080
90495: LD_INT 12
90497: DOUBLE
90498: EQUAL
90499: IFTRUE 90503
90501: GO 90711
90503: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
90504: LD_ADDR_VAR 0 1
90508: PUSH
90509: LD_INT 1
90511: PUSH
90512: LD_INT 2
90514: PUSH
90515: LD_INT 3
90517: PUSH
90518: LD_INT 4
90520: PUSH
90521: LD_INT 5
90523: PUSH
90524: LD_INT 6
90526: PUSH
90527: LD_INT 7
90529: PUSH
90530: LD_INT 8
90532: PUSH
90533: LD_INT 9
90535: PUSH
90536: LD_INT 10
90538: PUSH
90539: LD_INT 11
90541: PUSH
90542: LD_INT 12
90544: PUSH
90545: LD_INT 13
90547: PUSH
90548: LD_INT 14
90550: PUSH
90551: LD_INT 15
90553: PUSH
90554: LD_INT 16
90556: PUSH
90557: LD_INT 17
90559: PUSH
90560: LD_INT 18
90562: PUSH
90563: LD_INT 19
90565: PUSH
90566: LD_INT 20
90568: PUSH
90569: LD_INT 21
90571: PUSH
90572: LD_INT 22
90574: PUSH
90575: LD_INT 23
90577: PUSH
90578: LD_INT 24
90580: PUSH
90581: LD_INT 25
90583: PUSH
90584: LD_INT 26
90586: PUSH
90587: LD_INT 27
90589: PUSH
90590: LD_INT 28
90592: PUSH
90593: LD_INT 30
90595: PUSH
90596: LD_INT 31
90598: PUSH
90599: LD_INT 32
90601: PUSH
90602: LD_INT 33
90604: PUSH
90605: LD_INT 34
90607: PUSH
90608: LD_INT 36
90610: PUSH
90611: EMPTY
90612: LIST
90613: LIST
90614: LIST
90615: LIST
90616: LIST
90617: LIST
90618: LIST
90619: LIST
90620: LIST
90621: LIST
90622: LIST
90623: LIST
90624: LIST
90625: LIST
90626: LIST
90627: LIST
90628: LIST
90629: LIST
90630: LIST
90631: LIST
90632: LIST
90633: LIST
90634: LIST
90635: LIST
90636: LIST
90637: LIST
90638: LIST
90639: LIST
90640: LIST
90641: LIST
90642: LIST
90643: LIST
90644: LIST
90645: LIST
90646: PUSH
90647: LD_INT 101
90649: PUSH
90650: LD_INT 102
90652: PUSH
90653: LD_INT 103
90655: PUSH
90656: LD_INT 104
90658: PUSH
90659: LD_INT 105
90661: PUSH
90662: LD_INT 106
90664: PUSH
90665: LD_INT 107
90667: PUSH
90668: LD_INT 108
90670: PUSH
90671: LD_INT 109
90673: PUSH
90674: LD_INT 110
90676: PUSH
90677: LD_INT 111
90679: PUSH
90680: LD_INT 112
90682: PUSH
90683: LD_INT 113
90685: PUSH
90686: LD_INT 114
90688: PUSH
90689: EMPTY
90690: LIST
90691: LIST
90692: LIST
90693: LIST
90694: LIST
90695: LIST
90696: LIST
90697: LIST
90698: LIST
90699: LIST
90700: LIST
90701: LIST
90702: LIST
90703: LIST
90704: PUSH
90705: EMPTY
90706: LIST
90707: LIST
90708: ST_TO_ADDR
90709: GO 92080
90711: LD_INT 13
90713: DOUBLE
90714: EQUAL
90715: IFTRUE 90719
90717: GO 90915
90719: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
90720: LD_ADDR_VAR 0 1
90724: PUSH
90725: LD_INT 1
90727: PUSH
90728: LD_INT 2
90730: PUSH
90731: LD_INT 3
90733: PUSH
90734: LD_INT 4
90736: PUSH
90737: LD_INT 5
90739: PUSH
90740: LD_INT 8
90742: PUSH
90743: LD_INT 9
90745: PUSH
90746: LD_INT 10
90748: PUSH
90749: LD_INT 11
90751: PUSH
90752: LD_INT 12
90754: PUSH
90755: LD_INT 14
90757: PUSH
90758: LD_INT 15
90760: PUSH
90761: LD_INT 16
90763: PUSH
90764: LD_INT 17
90766: PUSH
90767: LD_INT 18
90769: PUSH
90770: LD_INT 19
90772: PUSH
90773: LD_INT 20
90775: PUSH
90776: LD_INT 21
90778: PUSH
90779: LD_INT 22
90781: PUSH
90782: LD_INT 23
90784: PUSH
90785: LD_INT 24
90787: PUSH
90788: LD_INT 25
90790: PUSH
90791: LD_INT 26
90793: PUSH
90794: LD_INT 27
90796: PUSH
90797: LD_INT 28
90799: PUSH
90800: LD_INT 30
90802: PUSH
90803: LD_INT 31
90805: PUSH
90806: LD_INT 32
90808: PUSH
90809: LD_INT 33
90811: PUSH
90812: LD_INT 34
90814: PUSH
90815: LD_INT 36
90817: PUSH
90818: EMPTY
90819: LIST
90820: LIST
90821: LIST
90822: LIST
90823: LIST
90824: LIST
90825: LIST
90826: LIST
90827: LIST
90828: LIST
90829: LIST
90830: LIST
90831: LIST
90832: LIST
90833: LIST
90834: LIST
90835: LIST
90836: LIST
90837: LIST
90838: LIST
90839: LIST
90840: LIST
90841: LIST
90842: LIST
90843: LIST
90844: LIST
90845: LIST
90846: LIST
90847: LIST
90848: LIST
90849: LIST
90850: PUSH
90851: LD_INT 101
90853: PUSH
90854: LD_INT 102
90856: PUSH
90857: LD_INT 103
90859: PUSH
90860: LD_INT 104
90862: PUSH
90863: LD_INT 105
90865: PUSH
90866: LD_INT 106
90868: PUSH
90869: LD_INT 107
90871: PUSH
90872: LD_INT 108
90874: PUSH
90875: LD_INT 109
90877: PUSH
90878: LD_INT 110
90880: PUSH
90881: LD_INT 111
90883: PUSH
90884: LD_INT 112
90886: PUSH
90887: LD_INT 113
90889: PUSH
90890: LD_INT 114
90892: PUSH
90893: EMPTY
90894: LIST
90895: LIST
90896: LIST
90897: LIST
90898: LIST
90899: LIST
90900: LIST
90901: LIST
90902: LIST
90903: LIST
90904: LIST
90905: LIST
90906: LIST
90907: LIST
90908: PUSH
90909: EMPTY
90910: LIST
90911: LIST
90912: ST_TO_ADDR
90913: GO 92080
90915: LD_INT 14
90917: DOUBLE
90918: EQUAL
90919: IFTRUE 90923
90921: GO 91135
90923: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
90924: LD_ADDR_VAR 0 1
90928: PUSH
90929: LD_INT 1
90931: PUSH
90932: LD_INT 2
90934: PUSH
90935: LD_INT 3
90937: PUSH
90938: LD_INT 4
90940: PUSH
90941: LD_INT 5
90943: PUSH
90944: LD_INT 6
90946: PUSH
90947: LD_INT 7
90949: PUSH
90950: LD_INT 8
90952: PUSH
90953: LD_INT 9
90955: PUSH
90956: LD_INT 10
90958: PUSH
90959: LD_INT 11
90961: PUSH
90962: LD_INT 12
90964: PUSH
90965: LD_INT 13
90967: PUSH
90968: LD_INT 14
90970: PUSH
90971: LD_INT 15
90973: PUSH
90974: LD_INT 16
90976: PUSH
90977: LD_INT 17
90979: PUSH
90980: LD_INT 18
90982: PUSH
90983: LD_INT 19
90985: PUSH
90986: LD_INT 20
90988: PUSH
90989: LD_INT 21
90991: PUSH
90992: LD_INT 22
90994: PUSH
90995: LD_INT 23
90997: PUSH
90998: LD_INT 24
91000: PUSH
91001: LD_INT 25
91003: PUSH
91004: LD_INT 26
91006: PUSH
91007: LD_INT 27
91009: PUSH
91010: LD_INT 28
91012: PUSH
91013: LD_INT 29
91015: PUSH
91016: LD_INT 30
91018: PUSH
91019: LD_INT 31
91021: PUSH
91022: LD_INT 32
91024: PUSH
91025: LD_INT 33
91027: PUSH
91028: LD_INT 34
91030: PUSH
91031: LD_INT 36
91033: PUSH
91034: EMPTY
91035: LIST
91036: LIST
91037: LIST
91038: LIST
91039: LIST
91040: LIST
91041: LIST
91042: LIST
91043: LIST
91044: LIST
91045: LIST
91046: LIST
91047: LIST
91048: LIST
91049: LIST
91050: LIST
91051: LIST
91052: LIST
91053: LIST
91054: LIST
91055: LIST
91056: LIST
91057: LIST
91058: LIST
91059: LIST
91060: LIST
91061: LIST
91062: LIST
91063: LIST
91064: LIST
91065: LIST
91066: LIST
91067: LIST
91068: LIST
91069: LIST
91070: PUSH
91071: LD_INT 101
91073: PUSH
91074: LD_INT 102
91076: PUSH
91077: LD_INT 103
91079: PUSH
91080: LD_INT 104
91082: PUSH
91083: LD_INT 105
91085: PUSH
91086: LD_INT 106
91088: PUSH
91089: LD_INT 107
91091: PUSH
91092: LD_INT 108
91094: PUSH
91095: LD_INT 109
91097: PUSH
91098: LD_INT 110
91100: PUSH
91101: LD_INT 111
91103: PUSH
91104: LD_INT 112
91106: PUSH
91107: LD_INT 113
91109: PUSH
91110: LD_INT 114
91112: PUSH
91113: EMPTY
91114: LIST
91115: LIST
91116: LIST
91117: LIST
91118: LIST
91119: LIST
91120: LIST
91121: LIST
91122: LIST
91123: LIST
91124: LIST
91125: LIST
91126: LIST
91127: LIST
91128: PUSH
91129: EMPTY
91130: LIST
91131: LIST
91132: ST_TO_ADDR
91133: GO 92080
91135: LD_INT 15
91137: DOUBLE
91138: EQUAL
91139: IFTRUE 91143
91141: GO 91355
91143: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
91144: LD_ADDR_VAR 0 1
91148: PUSH
91149: LD_INT 1
91151: PUSH
91152: LD_INT 2
91154: PUSH
91155: LD_INT 3
91157: PUSH
91158: LD_INT 4
91160: PUSH
91161: LD_INT 5
91163: PUSH
91164: LD_INT 6
91166: PUSH
91167: LD_INT 7
91169: PUSH
91170: LD_INT 8
91172: PUSH
91173: LD_INT 9
91175: PUSH
91176: LD_INT 10
91178: PUSH
91179: LD_INT 11
91181: PUSH
91182: LD_INT 12
91184: PUSH
91185: LD_INT 13
91187: PUSH
91188: LD_INT 14
91190: PUSH
91191: LD_INT 15
91193: PUSH
91194: LD_INT 16
91196: PUSH
91197: LD_INT 17
91199: PUSH
91200: LD_INT 18
91202: PUSH
91203: LD_INT 19
91205: PUSH
91206: LD_INT 20
91208: PUSH
91209: LD_INT 21
91211: PUSH
91212: LD_INT 22
91214: PUSH
91215: LD_INT 23
91217: PUSH
91218: LD_INT 24
91220: PUSH
91221: LD_INT 25
91223: PUSH
91224: LD_INT 26
91226: PUSH
91227: LD_INT 27
91229: PUSH
91230: LD_INT 28
91232: PUSH
91233: LD_INT 29
91235: PUSH
91236: LD_INT 30
91238: PUSH
91239: LD_INT 31
91241: PUSH
91242: LD_INT 32
91244: PUSH
91245: LD_INT 33
91247: PUSH
91248: LD_INT 34
91250: PUSH
91251: LD_INT 36
91253: PUSH
91254: EMPTY
91255: LIST
91256: LIST
91257: LIST
91258: LIST
91259: LIST
91260: LIST
91261: LIST
91262: LIST
91263: LIST
91264: LIST
91265: LIST
91266: LIST
91267: LIST
91268: LIST
91269: LIST
91270: LIST
91271: LIST
91272: LIST
91273: LIST
91274: LIST
91275: LIST
91276: LIST
91277: LIST
91278: LIST
91279: LIST
91280: LIST
91281: LIST
91282: LIST
91283: LIST
91284: LIST
91285: LIST
91286: LIST
91287: LIST
91288: LIST
91289: LIST
91290: PUSH
91291: LD_INT 101
91293: PUSH
91294: LD_INT 102
91296: PUSH
91297: LD_INT 103
91299: PUSH
91300: LD_INT 104
91302: PUSH
91303: LD_INT 105
91305: PUSH
91306: LD_INT 106
91308: PUSH
91309: LD_INT 107
91311: PUSH
91312: LD_INT 108
91314: PUSH
91315: LD_INT 109
91317: PUSH
91318: LD_INT 110
91320: PUSH
91321: LD_INT 111
91323: PUSH
91324: LD_INT 112
91326: PUSH
91327: LD_INT 113
91329: PUSH
91330: LD_INT 114
91332: PUSH
91333: EMPTY
91334: LIST
91335: LIST
91336: LIST
91337: LIST
91338: LIST
91339: LIST
91340: LIST
91341: LIST
91342: LIST
91343: LIST
91344: LIST
91345: LIST
91346: LIST
91347: LIST
91348: PUSH
91349: EMPTY
91350: LIST
91351: LIST
91352: ST_TO_ADDR
91353: GO 92080
91355: LD_INT 16
91357: DOUBLE
91358: EQUAL
91359: IFTRUE 91363
91361: GO 91487
91363: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
91364: LD_ADDR_VAR 0 1
91368: PUSH
91369: LD_INT 2
91371: PUSH
91372: LD_INT 4
91374: PUSH
91375: LD_INT 5
91377: PUSH
91378: LD_INT 7
91380: PUSH
91381: LD_INT 11
91383: PUSH
91384: LD_INT 12
91386: PUSH
91387: LD_INT 15
91389: PUSH
91390: LD_INT 16
91392: PUSH
91393: LD_INT 20
91395: PUSH
91396: LD_INT 21
91398: PUSH
91399: LD_INT 22
91401: PUSH
91402: LD_INT 23
91404: PUSH
91405: LD_INT 25
91407: PUSH
91408: LD_INT 26
91410: PUSH
91411: LD_INT 30
91413: PUSH
91414: LD_INT 31
91416: PUSH
91417: LD_INT 32
91419: PUSH
91420: LD_INT 33
91422: PUSH
91423: LD_INT 34
91425: PUSH
91426: EMPTY
91427: LIST
91428: LIST
91429: LIST
91430: LIST
91431: LIST
91432: LIST
91433: LIST
91434: LIST
91435: LIST
91436: LIST
91437: LIST
91438: LIST
91439: LIST
91440: LIST
91441: LIST
91442: LIST
91443: LIST
91444: LIST
91445: LIST
91446: PUSH
91447: LD_INT 101
91449: PUSH
91450: LD_INT 102
91452: PUSH
91453: LD_INT 103
91455: PUSH
91456: LD_INT 106
91458: PUSH
91459: LD_INT 108
91461: PUSH
91462: LD_INT 112
91464: PUSH
91465: LD_INT 113
91467: PUSH
91468: LD_INT 114
91470: PUSH
91471: EMPTY
91472: LIST
91473: LIST
91474: LIST
91475: LIST
91476: LIST
91477: LIST
91478: LIST
91479: LIST
91480: PUSH
91481: EMPTY
91482: LIST
91483: LIST
91484: ST_TO_ADDR
91485: GO 92080
91487: LD_INT 17
91489: DOUBLE
91490: EQUAL
91491: IFTRUE 91495
91493: GO 91707
91495: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
91496: LD_ADDR_VAR 0 1
91500: PUSH
91501: LD_INT 1
91503: PUSH
91504: LD_INT 2
91506: PUSH
91507: LD_INT 3
91509: PUSH
91510: LD_INT 4
91512: PUSH
91513: LD_INT 5
91515: PUSH
91516: LD_INT 6
91518: PUSH
91519: LD_INT 7
91521: PUSH
91522: LD_INT 8
91524: PUSH
91525: LD_INT 9
91527: PUSH
91528: LD_INT 10
91530: PUSH
91531: LD_INT 11
91533: PUSH
91534: LD_INT 12
91536: PUSH
91537: LD_INT 13
91539: PUSH
91540: LD_INT 14
91542: PUSH
91543: LD_INT 15
91545: PUSH
91546: LD_INT 16
91548: PUSH
91549: LD_INT 17
91551: PUSH
91552: LD_INT 18
91554: PUSH
91555: LD_INT 19
91557: PUSH
91558: LD_INT 20
91560: PUSH
91561: LD_INT 21
91563: PUSH
91564: LD_INT 22
91566: PUSH
91567: LD_INT 23
91569: PUSH
91570: LD_INT 24
91572: PUSH
91573: LD_INT 25
91575: PUSH
91576: LD_INT 26
91578: PUSH
91579: LD_INT 27
91581: PUSH
91582: LD_INT 28
91584: PUSH
91585: LD_INT 29
91587: PUSH
91588: LD_INT 30
91590: PUSH
91591: LD_INT 31
91593: PUSH
91594: LD_INT 32
91596: PUSH
91597: LD_INT 33
91599: PUSH
91600: LD_INT 34
91602: PUSH
91603: LD_INT 36
91605: PUSH
91606: EMPTY
91607: LIST
91608: LIST
91609: LIST
91610: LIST
91611: LIST
91612: LIST
91613: LIST
91614: LIST
91615: LIST
91616: LIST
91617: LIST
91618: LIST
91619: LIST
91620: LIST
91621: LIST
91622: LIST
91623: LIST
91624: LIST
91625: LIST
91626: LIST
91627: LIST
91628: LIST
91629: LIST
91630: LIST
91631: LIST
91632: LIST
91633: LIST
91634: LIST
91635: LIST
91636: LIST
91637: LIST
91638: LIST
91639: LIST
91640: LIST
91641: LIST
91642: PUSH
91643: LD_INT 101
91645: PUSH
91646: LD_INT 102
91648: PUSH
91649: LD_INT 103
91651: PUSH
91652: LD_INT 104
91654: PUSH
91655: LD_INT 105
91657: PUSH
91658: LD_INT 106
91660: PUSH
91661: LD_INT 107
91663: PUSH
91664: LD_INT 108
91666: PUSH
91667: LD_INT 109
91669: PUSH
91670: LD_INT 110
91672: PUSH
91673: LD_INT 111
91675: PUSH
91676: LD_INT 112
91678: PUSH
91679: LD_INT 113
91681: PUSH
91682: LD_INT 114
91684: PUSH
91685: EMPTY
91686: LIST
91687: LIST
91688: LIST
91689: LIST
91690: LIST
91691: LIST
91692: LIST
91693: LIST
91694: LIST
91695: LIST
91696: LIST
91697: LIST
91698: LIST
91699: LIST
91700: PUSH
91701: EMPTY
91702: LIST
91703: LIST
91704: ST_TO_ADDR
91705: GO 92080
91707: LD_INT 18
91709: DOUBLE
91710: EQUAL
91711: IFTRUE 91715
91713: GO 91851
91715: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
91716: LD_ADDR_VAR 0 1
91720: PUSH
91721: LD_INT 2
91723: PUSH
91724: LD_INT 4
91726: PUSH
91727: LD_INT 5
91729: PUSH
91730: LD_INT 7
91732: PUSH
91733: LD_INT 11
91735: PUSH
91736: LD_INT 12
91738: PUSH
91739: LD_INT 15
91741: PUSH
91742: LD_INT 16
91744: PUSH
91745: LD_INT 20
91747: PUSH
91748: LD_INT 21
91750: PUSH
91751: LD_INT 22
91753: PUSH
91754: LD_INT 23
91756: PUSH
91757: LD_INT 25
91759: PUSH
91760: LD_INT 26
91762: PUSH
91763: LD_INT 30
91765: PUSH
91766: LD_INT 31
91768: PUSH
91769: LD_INT 32
91771: PUSH
91772: LD_INT 33
91774: PUSH
91775: LD_INT 34
91777: PUSH
91778: LD_INT 35
91780: PUSH
91781: LD_INT 36
91783: PUSH
91784: EMPTY
91785: LIST
91786: LIST
91787: LIST
91788: LIST
91789: LIST
91790: LIST
91791: LIST
91792: LIST
91793: LIST
91794: LIST
91795: LIST
91796: LIST
91797: LIST
91798: LIST
91799: LIST
91800: LIST
91801: LIST
91802: LIST
91803: LIST
91804: LIST
91805: LIST
91806: PUSH
91807: LD_INT 101
91809: PUSH
91810: LD_INT 102
91812: PUSH
91813: LD_INT 103
91815: PUSH
91816: LD_INT 106
91818: PUSH
91819: LD_INT 108
91821: PUSH
91822: LD_INT 112
91824: PUSH
91825: LD_INT 113
91827: PUSH
91828: LD_INT 114
91830: PUSH
91831: LD_INT 115
91833: PUSH
91834: EMPTY
91835: LIST
91836: LIST
91837: LIST
91838: LIST
91839: LIST
91840: LIST
91841: LIST
91842: LIST
91843: LIST
91844: PUSH
91845: EMPTY
91846: LIST
91847: LIST
91848: ST_TO_ADDR
91849: GO 92080
91851: LD_INT 19
91853: DOUBLE
91854: EQUAL
91855: IFTRUE 91859
91857: GO 92079
91859: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
91860: LD_ADDR_VAR 0 1
91864: PUSH
91865: LD_INT 1
91867: PUSH
91868: LD_INT 2
91870: PUSH
91871: LD_INT 3
91873: PUSH
91874: LD_INT 4
91876: PUSH
91877: LD_INT 5
91879: PUSH
91880: LD_INT 6
91882: PUSH
91883: LD_INT 7
91885: PUSH
91886: LD_INT 8
91888: PUSH
91889: LD_INT 9
91891: PUSH
91892: LD_INT 10
91894: PUSH
91895: LD_INT 11
91897: PUSH
91898: LD_INT 12
91900: PUSH
91901: LD_INT 13
91903: PUSH
91904: LD_INT 14
91906: PUSH
91907: LD_INT 15
91909: PUSH
91910: LD_INT 16
91912: PUSH
91913: LD_INT 17
91915: PUSH
91916: LD_INT 18
91918: PUSH
91919: LD_INT 19
91921: PUSH
91922: LD_INT 20
91924: PUSH
91925: LD_INT 21
91927: PUSH
91928: LD_INT 22
91930: PUSH
91931: LD_INT 23
91933: PUSH
91934: LD_INT 24
91936: PUSH
91937: LD_INT 25
91939: PUSH
91940: LD_INT 26
91942: PUSH
91943: LD_INT 27
91945: PUSH
91946: LD_INT 28
91948: PUSH
91949: LD_INT 29
91951: PUSH
91952: LD_INT 30
91954: PUSH
91955: LD_INT 31
91957: PUSH
91958: LD_INT 32
91960: PUSH
91961: LD_INT 33
91963: PUSH
91964: LD_INT 34
91966: PUSH
91967: LD_INT 35
91969: PUSH
91970: LD_INT 36
91972: PUSH
91973: EMPTY
91974: LIST
91975: LIST
91976: LIST
91977: LIST
91978: LIST
91979: LIST
91980: LIST
91981: LIST
91982: LIST
91983: LIST
91984: LIST
91985: LIST
91986: LIST
91987: LIST
91988: LIST
91989: LIST
91990: LIST
91991: LIST
91992: LIST
91993: LIST
91994: LIST
91995: LIST
91996: LIST
91997: LIST
91998: LIST
91999: LIST
92000: LIST
92001: LIST
92002: LIST
92003: LIST
92004: LIST
92005: LIST
92006: LIST
92007: LIST
92008: LIST
92009: LIST
92010: PUSH
92011: LD_INT 101
92013: PUSH
92014: LD_INT 102
92016: PUSH
92017: LD_INT 103
92019: PUSH
92020: LD_INT 104
92022: PUSH
92023: LD_INT 105
92025: PUSH
92026: LD_INT 106
92028: PUSH
92029: LD_INT 107
92031: PUSH
92032: LD_INT 108
92034: PUSH
92035: LD_INT 109
92037: PUSH
92038: LD_INT 110
92040: PUSH
92041: LD_INT 111
92043: PUSH
92044: LD_INT 112
92046: PUSH
92047: LD_INT 113
92049: PUSH
92050: LD_INT 114
92052: PUSH
92053: LD_INT 115
92055: PUSH
92056: EMPTY
92057: LIST
92058: LIST
92059: LIST
92060: LIST
92061: LIST
92062: LIST
92063: LIST
92064: LIST
92065: LIST
92066: LIST
92067: LIST
92068: LIST
92069: LIST
92070: LIST
92071: LIST
92072: PUSH
92073: EMPTY
92074: LIST
92075: LIST
92076: ST_TO_ADDR
92077: GO 92080
92079: POP
// end else
92080: GO 92299
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
92082: LD_ADDR_VAR 0 1
92086: PUSH
92087: LD_INT 1
92089: PUSH
92090: LD_INT 2
92092: PUSH
92093: LD_INT 3
92095: PUSH
92096: LD_INT 4
92098: PUSH
92099: LD_INT 5
92101: PUSH
92102: LD_INT 6
92104: PUSH
92105: LD_INT 7
92107: PUSH
92108: LD_INT 8
92110: PUSH
92111: LD_INT 9
92113: PUSH
92114: LD_INT 10
92116: PUSH
92117: LD_INT 11
92119: PUSH
92120: LD_INT 12
92122: PUSH
92123: LD_INT 13
92125: PUSH
92126: LD_INT 14
92128: PUSH
92129: LD_INT 15
92131: PUSH
92132: LD_INT 16
92134: PUSH
92135: LD_INT 17
92137: PUSH
92138: LD_INT 18
92140: PUSH
92141: LD_INT 19
92143: PUSH
92144: LD_INT 20
92146: PUSH
92147: LD_INT 21
92149: PUSH
92150: LD_INT 22
92152: PUSH
92153: LD_INT 23
92155: PUSH
92156: LD_INT 24
92158: PUSH
92159: LD_INT 25
92161: PUSH
92162: LD_INT 26
92164: PUSH
92165: LD_INT 27
92167: PUSH
92168: LD_INT 28
92170: PUSH
92171: LD_INT 29
92173: PUSH
92174: LD_INT 30
92176: PUSH
92177: LD_INT 31
92179: PUSH
92180: LD_INT 32
92182: PUSH
92183: LD_INT 33
92185: PUSH
92186: LD_INT 34
92188: PUSH
92189: LD_INT 35
92191: PUSH
92192: LD_INT 36
92194: PUSH
92195: EMPTY
92196: LIST
92197: LIST
92198: LIST
92199: LIST
92200: LIST
92201: LIST
92202: LIST
92203: LIST
92204: LIST
92205: LIST
92206: LIST
92207: LIST
92208: LIST
92209: LIST
92210: LIST
92211: LIST
92212: LIST
92213: LIST
92214: LIST
92215: LIST
92216: LIST
92217: LIST
92218: LIST
92219: LIST
92220: LIST
92221: LIST
92222: LIST
92223: LIST
92224: LIST
92225: LIST
92226: LIST
92227: LIST
92228: LIST
92229: LIST
92230: LIST
92231: LIST
92232: PUSH
92233: LD_INT 101
92235: PUSH
92236: LD_INT 102
92238: PUSH
92239: LD_INT 103
92241: PUSH
92242: LD_INT 104
92244: PUSH
92245: LD_INT 105
92247: PUSH
92248: LD_INT 106
92250: PUSH
92251: LD_INT 107
92253: PUSH
92254: LD_INT 108
92256: PUSH
92257: LD_INT 109
92259: PUSH
92260: LD_INT 110
92262: PUSH
92263: LD_INT 111
92265: PUSH
92266: LD_INT 112
92268: PUSH
92269: LD_INT 113
92271: PUSH
92272: LD_INT 114
92274: PUSH
92275: LD_INT 115
92277: PUSH
92278: EMPTY
92279: LIST
92280: LIST
92281: LIST
92282: LIST
92283: LIST
92284: LIST
92285: LIST
92286: LIST
92287: LIST
92288: LIST
92289: LIST
92290: LIST
92291: LIST
92292: LIST
92293: LIST
92294: PUSH
92295: EMPTY
92296: LIST
92297: LIST
92298: ST_TO_ADDR
// if result then
92299: LD_VAR 0 1
92303: IFFALSE 92592
// begin normal :=  ;
92305: LD_ADDR_VAR 0 3
92309: PUSH
92310: LD_STRING 
92312: ST_TO_ADDR
// hardcore :=  ;
92313: LD_ADDR_VAR 0 4
92317: PUSH
92318: LD_STRING 
92320: ST_TO_ADDR
// for i = 1 to normalCounter do
92321: LD_ADDR_VAR 0 5
92325: PUSH
92326: DOUBLE
92327: LD_INT 1
92329: DEC
92330: ST_TO_ADDR
92331: LD_EXP 134
92335: PUSH
92336: FOR_TO
92337: IFFALSE 92438
// begin tmp := 0 ;
92339: LD_ADDR_VAR 0 2
92343: PUSH
92344: LD_STRING 0
92346: ST_TO_ADDR
// if result [ 1 ] then
92347: LD_VAR 0 1
92351: PUSH
92352: LD_INT 1
92354: ARRAY
92355: IFFALSE 92420
// if result [ 1 ] [ 1 ] = i then
92357: LD_VAR 0 1
92361: PUSH
92362: LD_INT 1
92364: ARRAY
92365: PUSH
92366: LD_INT 1
92368: ARRAY
92369: PUSH
92370: LD_VAR 0 5
92374: EQUAL
92375: IFFALSE 92420
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
92377: LD_ADDR_VAR 0 1
92381: PUSH
92382: LD_VAR 0 1
92386: PPUSH
92387: LD_INT 1
92389: PPUSH
92390: LD_VAR 0 1
92394: PUSH
92395: LD_INT 1
92397: ARRAY
92398: PPUSH
92399: LD_INT 1
92401: PPUSH
92402: CALL_OW 3
92406: PPUSH
92407: CALL_OW 1
92411: ST_TO_ADDR
// tmp := 1 ;
92412: LD_ADDR_VAR 0 2
92416: PUSH
92417: LD_STRING 1
92419: ST_TO_ADDR
// end ; normal := normal & tmp ;
92420: LD_ADDR_VAR 0 3
92424: PUSH
92425: LD_VAR 0 3
92429: PUSH
92430: LD_VAR 0 2
92434: STR
92435: ST_TO_ADDR
// end ;
92436: GO 92336
92438: POP
92439: POP
// for i = 1 to hardcoreCounter do
92440: LD_ADDR_VAR 0 5
92444: PUSH
92445: DOUBLE
92446: LD_INT 1
92448: DEC
92449: ST_TO_ADDR
92450: LD_EXP 135
92454: PUSH
92455: FOR_TO
92456: IFFALSE 92561
// begin tmp := 0 ;
92458: LD_ADDR_VAR 0 2
92462: PUSH
92463: LD_STRING 0
92465: ST_TO_ADDR
// if result [ 2 ] then
92466: LD_VAR 0 1
92470: PUSH
92471: LD_INT 2
92473: ARRAY
92474: IFFALSE 92543
// if result [ 2 ] [ 1 ] = 100 + i then
92476: LD_VAR 0 1
92480: PUSH
92481: LD_INT 2
92483: ARRAY
92484: PUSH
92485: LD_INT 1
92487: ARRAY
92488: PUSH
92489: LD_INT 100
92491: PUSH
92492: LD_VAR 0 5
92496: PLUS
92497: EQUAL
92498: IFFALSE 92543
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
92500: LD_ADDR_VAR 0 1
92504: PUSH
92505: LD_VAR 0 1
92509: PPUSH
92510: LD_INT 2
92512: PPUSH
92513: LD_VAR 0 1
92517: PUSH
92518: LD_INT 2
92520: ARRAY
92521: PPUSH
92522: LD_INT 1
92524: PPUSH
92525: CALL_OW 3
92529: PPUSH
92530: CALL_OW 1
92534: ST_TO_ADDR
// tmp := 1 ;
92535: LD_ADDR_VAR 0 2
92539: PUSH
92540: LD_STRING 1
92542: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
92543: LD_ADDR_VAR 0 4
92547: PUSH
92548: LD_VAR 0 4
92552: PUSH
92553: LD_VAR 0 2
92557: STR
92558: ST_TO_ADDR
// end ;
92559: GO 92455
92561: POP
92562: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
92563: LD_STRING getStreamItemsFromMission("
92565: PUSH
92566: LD_VAR 0 3
92570: STR
92571: PUSH
92572: LD_STRING ","
92574: STR
92575: PUSH
92576: LD_VAR 0 4
92580: STR
92581: PUSH
92582: LD_STRING ")
92584: STR
92585: PPUSH
92586: CALL_OW 559
// end else
92590: GO 92599
// ToLua ( getStreamItemsFromMission("","") ) ;
92592: LD_STRING getStreamItemsFromMission("","")
92594: PPUSH
92595: CALL_OW 559
// end ;
92599: LD_VAR 0 1
92603: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
92604: LD_EXP 133
92608: PUSH
92609: LD_EXP 138
92613: AND
92614: IFFALSE 92738
92616: GO 92618
92618: DISABLE
92619: LD_INT 0
92621: PPUSH
92622: PPUSH
// begin enable ;
92623: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
92624: LD_ADDR_VAR 0 2
92628: PUSH
92629: LD_INT 22
92631: PUSH
92632: LD_OWVAR 2
92636: PUSH
92637: EMPTY
92638: LIST
92639: LIST
92640: PUSH
92641: LD_INT 2
92643: PUSH
92644: LD_INT 34
92646: PUSH
92647: LD_INT 7
92649: PUSH
92650: EMPTY
92651: LIST
92652: LIST
92653: PUSH
92654: LD_INT 34
92656: PUSH
92657: LD_INT 45
92659: PUSH
92660: EMPTY
92661: LIST
92662: LIST
92663: PUSH
92664: LD_INT 34
92666: PUSH
92667: LD_INT 28
92669: PUSH
92670: EMPTY
92671: LIST
92672: LIST
92673: PUSH
92674: LD_INT 34
92676: PUSH
92677: LD_INT 47
92679: PUSH
92680: EMPTY
92681: LIST
92682: LIST
92683: PUSH
92684: EMPTY
92685: LIST
92686: LIST
92687: LIST
92688: LIST
92689: LIST
92690: PUSH
92691: EMPTY
92692: LIST
92693: LIST
92694: PPUSH
92695: CALL_OW 69
92699: ST_TO_ADDR
// if not tmp then
92700: LD_VAR 0 2
92704: NOT
92705: IFFALSE 92709
// exit ;
92707: GO 92738
// for i in tmp do
92709: LD_ADDR_VAR 0 1
92713: PUSH
92714: LD_VAR 0 2
92718: PUSH
92719: FOR_IN
92720: IFFALSE 92736
// begin SetLives ( i , 0 ) ;
92722: LD_VAR 0 1
92726: PPUSH
92727: LD_INT 0
92729: PPUSH
92730: CALL_OW 234
// end ;
92734: GO 92719
92736: POP
92737: POP
// end ;
92738: PPOPN 2
92740: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
92741: LD_EXP 133
92745: PUSH
92746: LD_EXP 139
92750: AND
92751: IFFALSE 92835
92753: GO 92755
92755: DISABLE
92756: LD_INT 0
92758: PPUSH
92759: PPUSH
// begin enable ;
92760: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
92761: LD_ADDR_VAR 0 2
92765: PUSH
92766: LD_INT 22
92768: PUSH
92769: LD_OWVAR 2
92773: PUSH
92774: EMPTY
92775: LIST
92776: LIST
92777: PUSH
92778: LD_INT 32
92780: PUSH
92781: LD_INT 3
92783: PUSH
92784: EMPTY
92785: LIST
92786: LIST
92787: PUSH
92788: EMPTY
92789: LIST
92790: LIST
92791: PPUSH
92792: CALL_OW 69
92796: ST_TO_ADDR
// if not tmp then
92797: LD_VAR 0 2
92801: NOT
92802: IFFALSE 92806
// exit ;
92804: GO 92835
// for i in tmp do
92806: LD_ADDR_VAR 0 1
92810: PUSH
92811: LD_VAR 0 2
92815: PUSH
92816: FOR_IN
92817: IFFALSE 92833
// begin SetLives ( i , 0 ) ;
92819: LD_VAR 0 1
92823: PPUSH
92824: LD_INT 0
92826: PPUSH
92827: CALL_OW 234
// end ;
92831: GO 92816
92833: POP
92834: POP
// end ;
92835: PPOPN 2
92837: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
92838: LD_EXP 133
92842: PUSH
92843: LD_EXP 136
92847: AND
92848: IFFALSE 92941
92850: GO 92852
92852: DISABLE
92853: LD_INT 0
92855: PPUSH
// begin enable ;
92856: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
92857: LD_ADDR_VAR 0 1
92861: PUSH
92862: LD_INT 22
92864: PUSH
92865: LD_OWVAR 2
92869: PUSH
92870: EMPTY
92871: LIST
92872: LIST
92873: PUSH
92874: LD_INT 2
92876: PUSH
92877: LD_INT 25
92879: PUSH
92880: LD_INT 5
92882: PUSH
92883: EMPTY
92884: LIST
92885: LIST
92886: PUSH
92887: LD_INT 25
92889: PUSH
92890: LD_INT 9
92892: PUSH
92893: EMPTY
92894: LIST
92895: LIST
92896: PUSH
92897: LD_INT 25
92899: PUSH
92900: LD_INT 8
92902: PUSH
92903: EMPTY
92904: LIST
92905: LIST
92906: PUSH
92907: EMPTY
92908: LIST
92909: LIST
92910: LIST
92911: LIST
92912: PUSH
92913: EMPTY
92914: LIST
92915: LIST
92916: PPUSH
92917: CALL_OW 69
92921: PUSH
92922: FOR_IN
92923: IFFALSE 92939
// begin SetClass ( i , 1 ) ;
92925: LD_VAR 0 1
92929: PPUSH
92930: LD_INT 1
92932: PPUSH
92933: CALL_OW 336
// end ;
92937: GO 92922
92939: POP
92940: POP
// end ;
92941: PPOPN 1
92943: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
92944: LD_EXP 133
92948: PUSH
92949: LD_EXP 137
92953: AND
92954: PUSH
92955: LD_OWVAR 65
92959: PUSH
92960: LD_INT 7
92962: LESS
92963: AND
92964: IFFALSE 92978
92966: GO 92968
92968: DISABLE
// begin enable ;
92969: ENABLE
// game_speed := 7 ;
92970: LD_ADDR_OWVAR 65
92974: PUSH
92975: LD_INT 7
92977: ST_TO_ADDR
// end ;
92978: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
92979: LD_EXP 133
92983: PUSH
92984: LD_EXP 140
92988: AND
92989: IFFALSE 93191
92991: GO 92993
92993: DISABLE
92994: LD_INT 0
92996: PPUSH
92997: PPUSH
92998: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
92999: LD_ADDR_VAR 0 3
93003: PUSH
93004: LD_INT 81
93006: PUSH
93007: LD_OWVAR 2
93011: PUSH
93012: EMPTY
93013: LIST
93014: LIST
93015: PUSH
93016: LD_INT 21
93018: PUSH
93019: LD_INT 1
93021: PUSH
93022: EMPTY
93023: LIST
93024: LIST
93025: PUSH
93026: EMPTY
93027: LIST
93028: LIST
93029: PPUSH
93030: CALL_OW 69
93034: ST_TO_ADDR
// if not tmp then
93035: LD_VAR 0 3
93039: NOT
93040: IFFALSE 93044
// exit ;
93042: GO 93191
// if tmp > 5 then
93044: LD_VAR 0 3
93048: PUSH
93049: LD_INT 5
93051: GREATER
93052: IFFALSE 93064
// k := 5 else
93054: LD_ADDR_VAR 0 2
93058: PUSH
93059: LD_INT 5
93061: ST_TO_ADDR
93062: GO 93074
// k := tmp ;
93064: LD_ADDR_VAR 0 2
93068: PUSH
93069: LD_VAR 0 3
93073: ST_TO_ADDR
// for i := 1 to k do
93074: LD_ADDR_VAR 0 1
93078: PUSH
93079: DOUBLE
93080: LD_INT 1
93082: DEC
93083: ST_TO_ADDR
93084: LD_VAR 0 2
93088: PUSH
93089: FOR_TO
93090: IFFALSE 93189
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
93092: LD_VAR 0 3
93096: PUSH
93097: LD_VAR 0 1
93101: ARRAY
93102: PPUSH
93103: LD_VAR 0 1
93107: PUSH
93108: LD_INT 4
93110: MOD
93111: PUSH
93112: LD_INT 1
93114: PLUS
93115: PPUSH
93116: CALL_OW 259
93120: PUSH
93121: LD_INT 10
93123: LESS
93124: IFFALSE 93187
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
93126: LD_VAR 0 3
93130: PUSH
93131: LD_VAR 0 1
93135: ARRAY
93136: PPUSH
93137: LD_VAR 0 1
93141: PUSH
93142: LD_INT 4
93144: MOD
93145: PUSH
93146: LD_INT 1
93148: PLUS
93149: PPUSH
93150: LD_VAR 0 3
93154: PUSH
93155: LD_VAR 0 1
93159: ARRAY
93160: PPUSH
93161: LD_VAR 0 1
93165: PUSH
93166: LD_INT 4
93168: MOD
93169: PUSH
93170: LD_INT 1
93172: PLUS
93173: PPUSH
93174: CALL_OW 259
93178: PUSH
93179: LD_INT 1
93181: PLUS
93182: PPUSH
93183: CALL_OW 237
93187: GO 93089
93189: POP
93190: POP
// end ;
93191: PPOPN 3
93193: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
93194: LD_EXP 133
93198: PUSH
93199: LD_EXP 141
93203: AND
93204: IFFALSE 93224
93206: GO 93208
93208: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
93209: LD_INT 4
93211: PPUSH
93212: LD_OWVAR 2
93216: PPUSH
93217: LD_INT 0
93219: PPUSH
93220: CALL_OW 324
93224: END
// every 0 0$1 trigger StreamModeActive and sShovel do
93225: LD_EXP 133
93229: PUSH
93230: LD_EXP 170
93234: AND
93235: IFFALSE 93255
93237: GO 93239
93239: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
93240: LD_INT 19
93242: PPUSH
93243: LD_OWVAR 2
93247: PPUSH
93248: LD_INT 0
93250: PPUSH
93251: CALL_OW 324
93255: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
93256: LD_EXP 133
93260: PUSH
93261: LD_EXP 142
93265: AND
93266: IFFALSE 93368
93268: GO 93270
93270: DISABLE
93271: LD_INT 0
93273: PPUSH
93274: PPUSH
// begin enable ;
93275: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
93276: LD_ADDR_VAR 0 2
93280: PUSH
93281: LD_INT 22
93283: PUSH
93284: LD_OWVAR 2
93288: PUSH
93289: EMPTY
93290: LIST
93291: LIST
93292: PUSH
93293: LD_INT 2
93295: PUSH
93296: LD_INT 34
93298: PUSH
93299: LD_INT 11
93301: PUSH
93302: EMPTY
93303: LIST
93304: LIST
93305: PUSH
93306: LD_INT 34
93308: PUSH
93309: LD_INT 30
93311: PUSH
93312: EMPTY
93313: LIST
93314: LIST
93315: PUSH
93316: EMPTY
93317: LIST
93318: LIST
93319: LIST
93320: PUSH
93321: EMPTY
93322: LIST
93323: LIST
93324: PPUSH
93325: CALL_OW 69
93329: ST_TO_ADDR
// if not tmp then
93330: LD_VAR 0 2
93334: NOT
93335: IFFALSE 93339
// exit ;
93337: GO 93368
// for i in tmp do
93339: LD_ADDR_VAR 0 1
93343: PUSH
93344: LD_VAR 0 2
93348: PUSH
93349: FOR_IN
93350: IFFALSE 93366
// begin SetLives ( i , 0 ) ;
93352: LD_VAR 0 1
93356: PPUSH
93357: LD_INT 0
93359: PPUSH
93360: CALL_OW 234
// end ;
93364: GO 93349
93366: POP
93367: POP
// end ;
93368: PPOPN 2
93370: END
// every 0 0$1 trigger StreamModeActive and sBunker do
93371: LD_EXP 133
93375: PUSH
93376: LD_EXP 143
93380: AND
93381: IFFALSE 93401
93383: GO 93385
93385: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
93386: LD_INT 32
93388: PPUSH
93389: LD_OWVAR 2
93393: PPUSH
93394: LD_INT 0
93396: PPUSH
93397: CALL_OW 324
93401: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
93402: LD_EXP 133
93406: PUSH
93407: LD_EXP 144
93411: AND
93412: IFFALSE 93593
93414: GO 93416
93416: DISABLE
93417: LD_INT 0
93419: PPUSH
93420: PPUSH
93421: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
93422: LD_ADDR_VAR 0 2
93426: PUSH
93427: LD_INT 22
93429: PUSH
93430: LD_OWVAR 2
93434: PUSH
93435: EMPTY
93436: LIST
93437: LIST
93438: PUSH
93439: LD_INT 33
93441: PUSH
93442: LD_INT 3
93444: PUSH
93445: EMPTY
93446: LIST
93447: LIST
93448: PUSH
93449: EMPTY
93450: LIST
93451: LIST
93452: PPUSH
93453: CALL_OW 69
93457: ST_TO_ADDR
// if not tmp then
93458: LD_VAR 0 2
93462: NOT
93463: IFFALSE 93467
// exit ;
93465: GO 93593
// side := 0 ;
93467: LD_ADDR_VAR 0 3
93471: PUSH
93472: LD_INT 0
93474: ST_TO_ADDR
// for i := 1 to 8 do
93475: LD_ADDR_VAR 0 1
93479: PUSH
93480: DOUBLE
93481: LD_INT 1
93483: DEC
93484: ST_TO_ADDR
93485: LD_INT 8
93487: PUSH
93488: FOR_TO
93489: IFFALSE 93537
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
93491: LD_OWVAR 2
93495: PUSH
93496: LD_VAR 0 1
93500: NONEQUAL
93501: PUSH
93502: LD_OWVAR 2
93506: PPUSH
93507: LD_VAR 0 1
93511: PPUSH
93512: CALL_OW 81
93516: PUSH
93517: LD_INT 2
93519: EQUAL
93520: AND
93521: IFFALSE 93535
// begin side := i ;
93523: LD_ADDR_VAR 0 3
93527: PUSH
93528: LD_VAR 0 1
93532: ST_TO_ADDR
// break ;
93533: GO 93537
// end ;
93535: GO 93488
93537: POP
93538: POP
// if not side then
93539: LD_VAR 0 3
93543: NOT
93544: IFFALSE 93548
// exit ;
93546: GO 93593
// for i := 1 to tmp do
93548: LD_ADDR_VAR 0 1
93552: PUSH
93553: DOUBLE
93554: LD_INT 1
93556: DEC
93557: ST_TO_ADDR
93558: LD_VAR 0 2
93562: PUSH
93563: FOR_TO
93564: IFFALSE 93591
// if Prob ( 60 ) then
93566: LD_INT 60
93568: PPUSH
93569: CALL_OW 13
93573: IFFALSE 93589
// SetSide ( i , side ) ;
93575: LD_VAR 0 1
93579: PPUSH
93580: LD_VAR 0 3
93584: PPUSH
93585: CALL_OW 235
93589: GO 93563
93591: POP
93592: POP
// end ;
93593: PPOPN 3
93595: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
93596: LD_EXP 133
93600: PUSH
93601: LD_EXP 146
93605: AND
93606: IFFALSE 93725
93608: GO 93610
93610: DISABLE
93611: LD_INT 0
93613: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
93614: LD_ADDR_VAR 0 1
93618: PUSH
93619: LD_INT 22
93621: PUSH
93622: LD_OWVAR 2
93626: PUSH
93627: EMPTY
93628: LIST
93629: LIST
93630: PUSH
93631: LD_INT 21
93633: PUSH
93634: LD_INT 1
93636: PUSH
93637: EMPTY
93638: LIST
93639: LIST
93640: PUSH
93641: LD_INT 3
93643: PUSH
93644: LD_INT 23
93646: PUSH
93647: LD_INT 0
93649: PUSH
93650: EMPTY
93651: LIST
93652: LIST
93653: PUSH
93654: EMPTY
93655: LIST
93656: LIST
93657: PUSH
93658: EMPTY
93659: LIST
93660: LIST
93661: LIST
93662: PPUSH
93663: CALL_OW 69
93667: PUSH
93668: FOR_IN
93669: IFFALSE 93723
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
93671: LD_VAR 0 1
93675: PPUSH
93676: CALL_OW 257
93680: PUSH
93681: LD_INT 1
93683: PUSH
93684: LD_INT 2
93686: PUSH
93687: LD_INT 3
93689: PUSH
93690: LD_INT 4
93692: PUSH
93693: EMPTY
93694: LIST
93695: LIST
93696: LIST
93697: LIST
93698: IN
93699: IFFALSE 93721
// SetClass ( un , rand ( 1 , 4 ) ) ;
93701: LD_VAR 0 1
93705: PPUSH
93706: LD_INT 1
93708: PPUSH
93709: LD_INT 4
93711: PPUSH
93712: CALL_OW 12
93716: PPUSH
93717: CALL_OW 336
93721: GO 93668
93723: POP
93724: POP
// end ;
93725: PPOPN 1
93727: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
93728: LD_EXP 133
93732: PUSH
93733: LD_EXP 145
93737: AND
93738: IFFALSE 93817
93740: GO 93742
93742: DISABLE
93743: LD_INT 0
93745: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
93746: LD_ADDR_VAR 0 1
93750: PUSH
93751: LD_INT 22
93753: PUSH
93754: LD_OWVAR 2
93758: PUSH
93759: EMPTY
93760: LIST
93761: LIST
93762: PUSH
93763: LD_INT 21
93765: PUSH
93766: LD_INT 3
93768: PUSH
93769: EMPTY
93770: LIST
93771: LIST
93772: PUSH
93773: EMPTY
93774: LIST
93775: LIST
93776: PPUSH
93777: CALL_OW 69
93781: ST_TO_ADDR
// if not tmp then
93782: LD_VAR 0 1
93786: NOT
93787: IFFALSE 93791
// exit ;
93789: GO 93817
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
93791: LD_VAR 0 1
93795: PUSH
93796: LD_INT 1
93798: PPUSH
93799: LD_VAR 0 1
93803: PPUSH
93804: CALL_OW 12
93808: ARRAY
93809: PPUSH
93810: LD_INT 100
93812: PPUSH
93813: CALL_OW 234
// end ;
93817: PPOPN 1
93819: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
93820: LD_EXP 133
93824: PUSH
93825: LD_EXP 147
93829: AND
93830: IFFALSE 93928
93832: GO 93834
93834: DISABLE
93835: LD_INT 0
93837: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
93838: LD_ADDR_VAR 0 1
93842: PUSH
93843: LD_INT 22
93845: PUSH
93846: LD_OWVAR 2
93850: PUSH
93851: EMPTY
93852: LIST
93853: LIST
93854: PUSH
93855: LD_INT 21
93857: PUSH
93858: LD_INT 1
93860: PUSH
93861: EMPTY
93862: LIST
93863: LIST
93864: PUSH
93865: EMPTY
93866: LIST
93867: LIST
93868: PPUSH
93869: CALL_OW 69
93873: ST_TO_ADDR
// if not tmp then
93874: LD_VAR 0 1
93878: NOT
93879: IFFALSE 93883
// exit ;
93881: GO 93928
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
93883: LD_VAR 0 1
93887: PUSH
93888: LD_INT 1
93890: PPUSH
93891: LD_VAR 0 1
93895: PPUSH
93896: CALL_OW 12
93900: ARRAY
93901: PPUSH
93902: LD_INT 1
93904: PPUSH
93905: LD_INT 4
93907: PPUSH
93908: CALL_OW 12
93912: PPUSH
93913: LD_INT 3000
93915: PPUSH
93916: LD_INT 9000
93918: PPUSH
93919: CALL_OW 12
93923: PPUSH
93924: CALL_OW 492
// end ;
93928: PPOPN 1
93930: END
// every 0 0$1 trigger StreamModeActive and sDepot do
93931: LD_EXP 133
93935: PUSH
93936: LD_EXP 148
93940: AND
93941: IFFALSE 93961
93943: GO 93945
93945: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
93946: LD_INT 1
93948: PPUSH
93949: LD_OWVAR 2
93953: PPUSH
93954: LD_INT 0
93956: PPUSH
93957: CALL_OW 324
93961: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
93962: LD_EXP 133
93966: PUSH
93967: LD_EXP 149
93971: AND
93972: IFFALSE 94055
93974: GO 93976
93976: DISABLE
93977: LD_INT 0
93979: PPUSH
93980: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
93981: LD_ADDR_VAR 0 2
93985: PUSH
93986: LD_INT 22
93988: PUSH
93989: LD_OWVAR 2
93993: PUSH
93994: EMPTY
93995: LIST
93996: LIST
93997: PUSH
93998: LD_INT 21
94000: PUSH
94001: LD_INT 3
94003: PUSH
94004: EMPTY
94005: LIST
94006: LIST
94007: PUSH
94008: EMPTY
94009: LIST
94010: LIST
94011: PPUSH
94012: CALL_OW 69
94016: ST_TO_ADDR
// if not tmp then
94017: LD_VAR 0 2
94021: NOT
94022: IFFALSE 94026
// exit ;
94024: GO 94055
// for i in tmp do
94026: LD_ADDR_VAR 0 1
94030: PUSH
94031: LD_VAR 0 2
94035: PUSH
94036: FOR_IN
94037: IFFALSE 94053
// SetBLevel ( i , 10 ) ;
94039: LD_VAR 0 1
94043: PPUSH
94044: LD_INT 10
94046: PPUSH
94047: CALL_OW 241
94051: GO 94036
94053: POP
94054: POP
// end ;
94055: PPOPN 2
94057: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
94058: LD_EXP 133
94062: PUSH
94063: LD_EXP 150
94067: AND
94068: IFFALSE 94179
94070: GO 94072
94072: DISABLE
94073: LD_INT 0
94075: PPUSH
94076: PPUSH
94077: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
94078: LD_ADDR_VAR 0 3
94082: PUSH
94083: LD_INT 22
94085: PUSH
94086: LD_OWVAR 2
94090: PUSH
94091: EMPTY
94092: LIST
94093: LIST
94094: PUSH
94095: LD_INT 25
94097: PUSH
94098: LD_INT 1
94100: PUSH
94101: EMPTY
94102: LIST
94103: LIST
94104: PUSH
94105: EMPTY
94106: LIST
94107: LIST
94108: PPUSH
94109: CALL_OW 69
94113: ST_TO_ADDR
// if not tmp then
94114: LD_VAR 0 3
94118: NOT
94119: IFFALSE 94123
// exit ;
94121: GO 94179
// un := tmp [ rand ( 1 , tmp ) ] ;
94123: LD_ADDR_VAR 0 2
94127: PUSH
94128: LD_VAR 0 3
94132: PUSH
94133: LD_INT 1
94135: PPUSH
94136: LD_VAR 0 3
94140: PPUSH
94141: CALL_OW 12
94145: ARRAY
94146: ST_TO_ADDR
// if Crawls ( un ) then
94147: LD_VAR 0 2
94151: PPUSH
94152: CALL_OW 318
94156: IFFALSE 94167
// ComWalk ( un ) ;
94158: LD_VAR 0 2
94162: PPUSH
94163: CALL_OW 138
// SetClass ( un , class_sniper ) ;
94167: LD_VAR 0 2
94171: PPUSH
94172: LD_INT 5
94174: PPUSH
94175: CALL_OW 336
// end ;
94179: PPOPN 3
94181: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
94182: LD_EXP 133
94186: PUSH
94187: LD_EXP 151
94191: AND
94192: PUSH
94193: LD_OWVAR 67
94197: PUSH
94198: LD_INT 3
94200: LESS
94201: AND
94202: IFFALSE 94221
94204: GO 94206
94206: DISABLE
// Difficulty := Difficulty + 1 ;
94207: LD_ADDR_OWVAR 67
94211: PUSH
94212: LD_OWVAR 67
94216: PUSH
94217: LD_INT 1
94219: PLUS
94220: ST_TO_ADDR
94221: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
94222: LD_EXP 133
94226: PUSH
94227: LD_EXP 152
94231: AND
94232: IFFALSE 94335
94234: GO 94236
94236: DISABLE
94237: LD_INT 0
94239: PPUSH
// begin for i := 1 to 5 do
94240: LD_ADDR_VAR 0 1
94244: PUSH
94245: DOUBLE
94246: LD_INT 1
94248: DEC
94249: ST_TO_ADDR
94250: LD_INT 5
94252: PUSH
94253: FOR_TO
94254: IFFALSE 94333
// begin uc_nation := nation_nature ;
94256: LD_ADDR_OWVAR 21
94260: PUSH
94261: LD_INT 0
94263: ST_TO_ADDR
// uc_side := 0 ;
94264: LD_ADDR_OWVAR 20
94268: PUSH
94269: LD_INT 0
94271: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
94272: LD_ADDR_OWVAR 29
94276: PUSH
94277: LD_INT 12
94279: PUSH
94280: LD_INT 12
94282: PUSH
94283: EMPTY
94284: LIST
94285: LIST
94286: ST_TO_ADDR
// hc_agressivity := 20 ;
94287: LD_ADDR_OWVAR 35
94291: PUSH
94292: LD_INT 20
94294: ST_TO_ADDR
// hc_class := class_tiger ;
94295: LD_ADDR_OWVAR 28
94299: PUSH
94300: LD_INT 14
94302: ST_TO_ADDR
// hc_gallery :=  ;
94303: LD_ADDR_OWVAR 33
94307: PUSH
94308: LD_STRING 
94310: ST_TO_ADDR
// hc_name :=  ;
94311: LD_ADDR_OWVAR 26
94315: PUSH
94316: LD_STRING 
94318: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
94319: CALL_OW 44
94323: PPUSH
94324: LD_INT 0
94326: PPUSH
94327: CALL_OW 51
// end ;
94331: GO 94253
94333: POP
94334: POP
// end ;
94335: PPOPN 1
94337: END
// every 0 0$1 trigger StreamModeActive and sBomb do
94338: LD_EXP 133
94342: PUSH
94343: LD_EXP 153
94347: AND
94348: IFFALSE 94357
94350: GO 94352
94352: DISABLE
// StreamSibBomb ;
94353: CALL 94358 0 0
94357: END
// export function StreamSibBomb ; var i , x , y ; begin
94358: LD_INT 0
94360: PPUSH
94361: PPUSH
94362: PPUSH
94363: PPUSH
// result := false ;
94364: LD_ADDR_VAR 0 1
94368: PUSH
94369: LD_INT 0
94371: ST_TO_ADDR
// for i := 1 to 16 do
94372: LD_ADDR_VAR 0 2
94376: PUSH
94377: DOUBLE
94378: LD_INT 1
94380: DEC
94381: ST_TO_ADDR
94382: LD_INT 16
94384: PUSH
94385: FOR_TO
94386: IFFALSE 94585
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
94388: LD_ADDR_VAR 0 3
94392: PUSH
94393: LD_INT 10
94395: PUSH
94396: LD_INT 20
94398: PUSH
94399: LD_INT 30
94401: PUSH
94402: LD_INT 40
94404: PUSH
94405: LD_INT 50
94407: PUSH
94408: LD_INT 60
94410: PUSH
94411: LD_INT 70
94413: PUSH
94414: LD_INT 80
94416: PUSH
94417: LD_INT 90
94419: PUSH
94420: LD_INT 100
94422: PUSH
94423: LD_INT 110
94425: PUSH
94426: LD_INT 120
94428: PUSH
94429: LD_INT 130
94431: PUSH
94432: LD_INT 140
94434: PUSH
94435: LD_INT 150
94437: PUSH
94438: EMPTY
94439: LIST
94440: LIST
94441: LIST
94442: LIST
94443: LIST
94444: LIST
94445: LIST
94446: LIST
94447: LIST
94448: LIST
94449: LIST
94450: LIST
94451: LIST
94452: LIST
94453: LIST
94454: PUSH
94455: LD_INT 1
94457: PPUSH
94458: LD_INT 15
94460: PPUSH
94461: CALL_OW 12
94465: ARRAY
94466: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
94467: LD_ADDR_VAR 0 4
94471: PUSH
94472: LD_INT 10
94474: PUSH
94475: LD_INT 20
94477: PUSH
94478: LD_INT 30
94480: PUSH
94481: LD_INT 40
94483: PUSH
94484: LD_INT 50
94486: PUSH
94487: LD_INT 60
94489: PUSH
94490: LD_INT 70
94492: PUSH
94493: LD_INT 80
94495: PUSH
94496: LD_INT 90
94498: PUSH
94499: LD_INT 100
94501: PUSH
94502: LD_INT 110
94504: PUSH
94505: LD_INT 120
94507: PUSH
94508: LD_INT 130
94510: PUSH
94511: LD_INT 140
94513: PUSH
94514: LD_INT 150
94516: PUSH
94517: EMPTY
94518: LIST
94519: LIST
94520: LIST
94521: LIST
94522: LIST
94523: LIST
94524: LIST
94525: LIST
94526: LIST
94527: LIST
94528: LIST
94529: LIST
94530: LIST
94531: LIST
94532: LIST
94533: PUSH
94534: LD_INT 1
94536: PPUSH
94537: LD_INT 15
94539: PPUSH
94540: CALL_OW 12
94544: ARRAY
94545: ST_TO_ADDR
// if ValidHex ( x , y ) then
94546: LD_VAR 0 3
94550: PPUSH
94551: LD_VAR 0 4
94555: PPUSH
94556: CALL_OW 488
94560: IFFALSE 94583
// begin result := [ x , y ] ;
94562: LD_ADDR_VAR 0 1
94566: PUSH
94567: LD_VAR 0 3
94571: PUSH
94572: LD_VAR 0 4
94576: PUSH
94577: EMPTY
94578: LIST
94579: LIST
94580: ST_TO_ADDR
// break ;
94581: GO 94585
// end ; end ;
94583: GO 94385
94585: POP
94586: POP
// if result then
94587: LD_VAR 0 1
94591: IFFALSE 94651
// begin ToLua ( playSibBomb() ) ;
94593: LD_STRING playSibBomb()
94595: PPUSH
94596: CALL_OW 559
// wait ( 0 0$14 ) ;
94600: LD_INT 490
94602: PPUSH
94603: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
94607: LD_VAR 0 1
94611: PUSH
94612: LD_INT 1
94614: ARRAY
94615: PPUSH
94616: LD_VAR 0 1
94620: PUSH
94621: LD_INT 2
94623: ARRAY
94624: PPUSH
94625: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
94629: LD_VAR 0 1
94633: PUSH
94634: LD_INT 1
94636: ARRAY
94637: PPUSH
94638: LD_VAR 0 1
94642: PUSH
94643: LD_INT 2
94645: ARRAY
94646: PPUSH
94647: CALL_OW 429
// end ; end ;
94651: LD_VAR 0 1
94655: RET
// every 0 0$1 trigger StreamModeActive and sReset do
94656: LD_EXP 133
94660: PUSH
94661: LD_EXP 155
94665: AND
94666: IFFALSE 94678
94668: GO 94670
94670: DISABLE
// YouLost (  ) ;
94671: LD_STRING 
94673: PPUSH
94674: CALL_OW 104
94678: END
// every 0 0$1 trigger StreamModeActive and sFog do
94679: LD_EXP 133
94683: PUSH
94684: LD_EXP 154
94688: AND
94689: IFFALSE 94703
94691: GO 94693
94693: DISABLE
// FogOff ( your_side ) ;
94694: LD_OWVAR 2
94698: PPUSH
94699: CALL_OW 344
94703: END
// every 0 0$1 trigger StreamModeActive and sSun do
94704: LD_EXP 133
94708: PUSH
94709: LD_EXP 156
94713: AND
94714: IFFALSE 94742
94716: GO 94718
94718: DISABLE
// begin solar_recharge_percent := 0 ;
94719: LD_ADDR_OWVAR 79
94723: PUSH
94724: LD_INT 0
94726: ST_TO_ADDR
// wait ( 5 5$00 ) ;
94727: LD_INT 10500
94729: PPUSH
94730: CALL_OW 67
// solar_recharge_percent := 100 ;
94734: LD_ADDR_OWVAR 79
94738: PUSH
94739: LD_INT 100
94741: ST_TO_ADDR
// end ;
94742: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
94743: LD_EXP 133
94747: PUSH
94748: LD_EXP 157
94752: AND
94753: IFFALSE 94992
94755: GO 94757
94757: DISABLE
94758: LD_INT 0
94760: PPUSH
94761: PPUSH
94762: PPUSH
// begin tmp := [ ] ;
94763: LD_ADDR_VAR 0 3
94767: PUSH
94768: EMPTY
94769: ST_TO_ADDR
// for i := 1 to 6 do
94770: LD_ADDR_VAR 0 1
94774: PUSH
94775: DOUBLE
94776: LD_INT 1
94778: DEC
94779: ST_TO_ADDR
94780: LD_INT 6
94782: PUSH
94783: FOR_TO
94784: IFFALSE 94889
// begin uc_nation := nation_nature ;
94786: LD_ADDR_OWVAR 21
94790: PUSH
94791: LD_INT 0
94793: ST_TO_ADDR
// uc_side := 0 ;
94794: LD_ADDR_OWVAR 20
94798: PUSH
94799: LD_INT 0
94801: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
94802: LD_ADDR_OWVAR 29
94806: PUSH
94807: LD_INT 12
94809: PUSH
94810: LD_INT 12
94812: PUSH
94813: EMPTY
94814: LIST
94815: LIST
94816: ST_TO_ADDR
// hc_agressivity := 20 ;
94817: LD_ADDR_OWVAR 35
94821: PUSH
94822: LD_INT 20
94824: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
94825: LD_ADDR_OWVAR 28
94829: PUSH
94830: LD_INT 17
94832: ST_TO_ADDR
// hc_gallery :=  ;
94833: LD_ADDR_OWVAR 33
94837: PUSH
94838: LD_STRING 
94840: ST_TO_ADDR
// hc_name :=  ;
94841: LD_ADDR_OWVAR 26
94845: PUSH
94846: LD_STRING 
94848: ST_TO_ADDR
// un := CreateHuman ;
94849: LD_ADDR_VAR 0 2
94853: PUSH
94854: CALL_OW 44
94858: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
94859: LD_VAR 0 2
94863: PPUSH
94864: LD_INT 1
94866: PPUSH
94867: CALL_OW 51
// tmp := tmp ^ un ;
94871: LD_ADDR_VAR 0 3
94875: PUSH
94876: LD_VAR 0 3
94880: PUSH
94881: LD_VAR 0 2
94885: ADD
94886: ST_TO_ADDR
// end ;
94887: GO 94783
94889: POP
94890: POP
// repeat wait ( 0 0$1 ) ;
94891: LD_INT 35
94893: PPUSH
94894: CALL_OW 67
// for un in tmp do
94898: LD_ADDR_VAR 0 2
94902: PUSH
94903: LD_VAR 0 3
94907: PUSH
94908: FOR_IN
94909: IFFALSE 94983
// begin if IsDead ( un ) then
94911: LD_VAR 0 2
94915: PPUSH
94916: CALL_OW 301
94920: IFFALSE 94940
// begin tmp := tmp diff un ;
94922: LD_ADDR_VAR 0 3
94926: PUSH
94927: LD_VAR 0 3
94931: PUSH
94932: LD_VAR 0 2
94936: DIFF
94937: ST_TO_ADDR
// continue ;
94938: GO 94908
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
94940: LD_VAR 0 2
94944: PPUSH
94945: LD_INT 3
94947: PUSH
94948: LD_INT 22
94950: PUSH
94951: LD_INT 0
94953: PUSH
94954: EMPTY
94955: LIST
94956: LIST
94957: PUSH
94958: EMPTY
94959: LIST
94960: LIST
94961: PPUSH
94962: CALL_OW 69
94966: PPUSH
94967: LD_VAR 0 2
94971: PPUSH
94972: CALL_OW 74
94976: PPUSH
94977: CALL_OW 115
// end ;
94981: GO 94908
94983: POP
94984: POP
// until not tmp ;
94985: LD_VAR 0 3
94989: NOT
94990: IFFALSE 94891
// end ;
94992: PPOPN 3
94994: END
// every 0 0$1 trigger StreamModeActive and sTroll do
94995: LD_EXP 133
94999: PUSH
95000: LD_EXP 158
95004: AND
95005: IFFALSE 95059
95007: GO 95009
95009: DISABLE
// begin ToLua ( displayTroll(); ) ;
95010: LD_STRING displayTroll();
95012: PPUSH
95013: CALL_OW 559
// wait ( 3 3$00 ) ;
95017: LD_INT 6300
95019: PPUSH
95020: CALL_OW 67
// ToLua ( hideTroll(); ) ;
95024: LD_STRING hideTroll();
95026: PPUSH
95027: CALL_OW 559
// wait ( 1 1$00 ) ;
95031: LD_INT 2100
95033: PPUSH
95034: CALL_OW 67
// ToLua ( displayTroll(); ) ;
95038: LD_STRING displayTroll();
95040: PPUSH
95041: CALL_OW 559
// wait ( 1 1$00 ) ;
95045: LD_INT 2100
95047: PPUSH
95048: CALL_OW 67
// ToLua ( hideTroll(); ) ;
95052: LD_STRING hideTroll();
95054: PPUSH
95055: CALL_OW 559
// end ;
95059: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
95060: LD_EXP 133
95064: PUSH
95065: LD_EXP 159
95069: AND
95070: IFFALSE 95133
95072: GO 95074
95074: DISABLE
95075: LD_INT 0
95077: PPUSH
// begin p := 0 ;
95078: LD_ADDR_VAR 0 1
95082: PUSH
95083: LD_INT 0
95085: ST_TO_ADDR
// repeat game_speed := 1 ;
95086: LD_ADDR_OWVAR 65
95090: PUSH
95091: LD_INT 1
95093: ST_TO_ADDR
// wait ( 0 0$1 ) ;
95094: LD_INT 35
95096: PPUSH
95097: CALL_OW 67
// p := p + 1 ;
95101: LD_ADDR_VAR 0 1
95105: PUSH
95106: LD_VAR 0 1
95110: PUSH
95111: LD_INT 1
95113: PLUS
95114: ST_TO_ADDR
// until p >= 60 ;
95115: LD_VAR 0 1
95119: PUSH
95120: LD_INT 60
95122: GREATEREQUAL
95123: IFFALSE 95086
// game_speed := 4 ;
95125: LD_ADDR_OWVAR 65
95129: PUSH
95130: LD_INT 4
95132: ST_TO_ADDR
// end ;
95133: PPOPN 1
95135: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
95136: LD_EXP 133
95140: PUSH
95141: LD_EXP 160
95145: AND
95146: IFFALSE 95292
95148: GO 95150
95150: DISABLE
95151: LD_INT 0
95153: PPUSH
95154: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
95155: LD_ADDR_VAR 0 1
95159: PUSH
95160: LD_INT 22
95162: PUSH
95163: LD_OWVAR 2
95167: PUSH
95168: EMPTY
95169: LIST
95170: LIST
95171: PUSH
95172: LD_INT 2
95174: PUSH
95175: LD_INT 30
95177: PUSH
95178: LD_INT 0
95180: PUSH
95181: EMPTY
95182: LIST
95183: LIST
95184: PUSH
95185: LD_INT 30
95187: PUSH
95188: LD_INT 1
95190: PUSH
95191: EMPTY
95192: LIST
95193: LIST
95194: PUSH
95195: EMPTY
95196: LIST
95197: LIST
95198: LIST
95199: PUSH
95200: EMPTY
95201: LIST
95202: LIST
95203: PPUSH
95204: CALL_OW 69
95208: ST_TO_ADDR
// if not depot then
95209: LD_VAR 0 1
95213: NOT
95214: IFFALSE 95218
// exit ;
95216: GO 95292
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
95218: LD_ADDR_VAR 0 2
95222: PUSH
95223: LD_VAR 0 1
95227: PUSH
95228: LD_INT 1
95230: PPUSH
95231: LD_VAR 0 1
95235: PPUSH
95236: CALL_OW 12
95240: ARRAY
95241: PPUSH
95242: CALL_OW 274
95246: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
95247: LD_VAR 0 2
95251: PPUSH
95252: LD_INT 1
95254: PPUSH
95255: LD_INT 0
95257: PPUSH
95258: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
95262: LD_VAR 0 2
95266: PPUSH
95267: LD_INT 2
95269: PPUSH
95270: LD_INT 0
95272: PPUSH
95273: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
95277: LD_VAR 0 2
95281: PPUSH
95282: LD_INT 3
95284: PPUSH
95285: LD_INT 0
95287: PPUSH
95288: CALL_OW 277
// end ;
95292: PPOPN 2
95294: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
95295: LD_EXP 133
95299: PUSH
95300: LD_EXP 161
95304: AND
95305: IFFALSE 95402
95307: GO 95309
95309: DISABLE
95310: LD_INT 0
95312: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
95313: LD_ADDR_VAR 0 1
95317: PUSH
95318: LD_INT 22
95320: PUSH
95321: LD_OWVAR 2
95325: PUSH
95326: EMPTY
95327: LIST
95328: LIST
95329: PUSH
95330: LD_INT 21
95332: PUSH
95333: LD_INT 1
95335: PUSH
95336: EMPTY
95337: LIST
95338: LIST
95339: PUSH
95340: LD_INT 3
95342: PUSH
95343: LD_INT 23
95345: PUSH
95346: LD_INT 0
95348: PUSH
95349: EMPTY
95350: LIST
95351: LIST
95352: PUSH
95353: EMPTY
95354: LIST
95355: LIST
95356: PUSH
95357: EMPTY
95358: LIST
95359: LIST
95360: LIST
95361: PPUSH
95362: CALL_OW 69
95366: ST_TO_ADDR
// if not tmp then
95367: LD_VAR 0 1
95371: NOT
95372: IFFALSE 95376
// exit ;
95374: GO 95402
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
95376: LD_VAR 0 1
95380: PUSH
95381: LD_INT 1
95383: PPUSH
95384: LD_VAR 0 1
95388: PPUSH
95389: CALL_OW 12
95393: ARRAY
95394: PPUSH
95395: LD_INT 200
95397: PPUSH
95398: CALL_OW 234
// end ;
95402: PPOPN 1
95404: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
95405: LD_EXP 133
95409: PUSH
95410: LD_EXP 162
95414: AND
95415: IFFALSE 95494
95417: GO 95419
95419: DISABLE
95420: LD_INT 0
95422: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
95423: LD_ADDR_VAR 0 1
95427: PUSH
95428: LD_INT 22
95430: PUSH
95431: LD_OWVAR 2
95435: PUSH
95436: EMPTY
95437: LIST
95438: LIST
95439: PUSH
95440: LD_INT 21
95442: PUSH
95443: LD_INT 2
95445: PUSH
95446: EMPTY
95447: LIST
95448: LIST
95449: PUSH
95450: EMPTY
95451: LIST
95452: LIST
95453: PPUSH
95454: CALL_OW 69
95458: ST_TO_ADDR
// if not tmp then
95459: LD_VAR 0 1
95463: NOT
95464: IFFALSE 95468
// exit ;
95466: GO 95494
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
95468: LD_VAR 0 1
95472: PUSH
95473: LD_INT 1
95475: PPUSH
95476: LD_VAR 0 1
95480: PPUSH
95481: CALL_OW 12
95485: ARRAY
95486: PPUSH
95487: LD_INT 60
95489: PPUSH
95490: CALL_OW 234
// end ;
95494: PPOPN 1
95496: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
95497: LD_EXP 133
95501: PUSH
95502: LD_EXP 163
95506: AND
95507: IFFALSE 95606
95509: GO 95511
95511: DISABLE
95512: LD_INT 0
95514: PPUSH
95515: PPUSH
// begin enable ;
95516: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
95517: LD_ADDR_VAR 0 1
95521: PUSH
95522: LD_INT 22
95524: PUSH
95525: LD_OWVAR 2
95529: PUSH
95530: EMPTY
95531: LIST
95532: LIST
95533: PUSH
95534: LD_INT 61
95536: PUSH
95537: EMPTY
95538: LIST
95539: PUSH
95540: LD_INT 33
95542: PUSH
95543: LD_INT 2
95545: PUSH
95546: EMPTY
95547: LIST
95548: LIST
95549: PUSH
95550: EMPTY
95551: LIST
95552: LIST
95553: LIST
95554: PPUSH
95555: CALL_OW 69
95559: ST_TO_ADDR
// if not tmp then
95560: LD_VAR 0 1
95564: NOT
95565: IFFALSE 95569
// exit ;
95567: GO 95606
// for i in tmp do
95569: LD_ADDR_VAR 0 2
95573: PUSH
95574: LD_VAR 0 1
95578: PUSH
95579: FOR_IN
95580: IFFALSE 95604
// if IsControledBy ( i ) then
95582: LD_VAR 0 2
95586: PPUSH
95587: CALL_OW 312
95591: IFFALSE 95602
// ComUnlink ( i ) ;
95593: LD_VAR 0 2
95597: PPUSH
95598: CALL_OW 136
95602: GO 95579
95604: POP
95605: POP
// end ;
95606: PPOPN 2
95608: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
95609: LD_EXP 133
95613: PUSH
95614: LD_EXP 164
95618: AND
95619: IFFALSE 95759
95621: GO 95623
95623: DISABLE
95624: LD_INT 0
95626: PPUSH
95627: PPUSH
// begin ToLua ( displayPowell(); ) ;
95628: LD_STRING displayPowell();
95630: PPUSH
95631: CALL_OW 559
// uc_side := 0 ;
95635: LD_ADDR_OWVAR 20
95639: PUSH
95640: LD_INT 0
95642: ST_TO_ADDR
// uc_nation := 2 ;
95643: LD_ADDR_OWVAR 21
95647: PUSH
95648: LD_INT 2
95650: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
95651: LD_ADDR_OWVAR 37
95655: PUSH
95656: LD_INT 14
95658: ST_TO_ADDR
// vc_engine := engine_siberite ;
95659: LD_ADDR_OWVAR 39
95663: PUSH
95664: LD_INT 3
95666: ST_TO_ADDR
// vc_control := control_apeman ;
95667: LD_ADDR_OWVAR 38
95671: PUSH
95672: LD_INT 5
95674: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
95675: LD_ADDR_OWVAR 40
95679: PUSH
95680: LD_INT 29
95682: ST_TO_ADDR
// un := CreateVehicle ;
95683: LD_ADDR_VAR 0 2
95687: PUSH
95688: CALL_OW 45
95692: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
95693: LD_VAR 0 2
95697: PPUSH
95698: LD_INT 1
95700: PPUSH
95701: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
95705: LD_INT 35
95707: PPUSH
95708: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
95712: LD_VAR 0 2
95716: PPUSH
95717: LD_INT 22
95719: PUSH
95720: LD_OWVAR 2
95724: PUSH
95725: EMPTY
95726: LIST
95727: LIST
95728: PPUSH
95729: CALL_OW 69
95733: PPUSH
95734: LD_VAR 0 2
95738: PPUSH
95739: CALL_OW 74
95743: PPUSH
95744: CALL_OW 115
// until IsDead ( un ) ;
95748: LD_VAR 0 2
95752: PPUSH
95753: CALL_OW 301
95757: IFFALSE 95705
// end ;
95759: PPOPN 2
95761: END
// every 0 0$1 trigger StreamModeActive and sStu do
95762: LD_EXP 133
95766: PUSH
95767: LD_EXP 172
95771: AND
95772: IFFALSE 95788
95774: GO 95776
95776: DISABLE
// begin ToLua ( displayStucuk(); ) ;
95777: LD_STRING displayStucuk();
95779: PPUSH
95780: CALL_OW 559
// ResetFog ;
95784: CALL_OW 335
// end ;
95788: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
95789: LD_EXP 133
95793: PUSH
95794: LD_EXP 165
95798: AND
95799: IFFALSE 95940
95801: GO 95803
95803: DISABLE
95804: LD_INT 0
95806: PPUSH
95807: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
95808: LD_ADDR_VAR 0 2
95812: PUSH
95813: LD_INT 22
95815: PUSH
95816: LD_OWVAR 2
95820: PUSH
95821: EMPTY
95822: LIST
95823: LIST
95824: PUSH
95825: LD_INT 21
95827: PUSH
95828: LD_INT 1
95830: PUSH
95831: EMPTY
95832: LIST
95833: LIST
95834: PUSH
95835: EMPTY
95836: LIST
95837: LIST
95838: PPUSH
95839: CALL_OW 69
95843: ST_TO_ADDR
// if not tmp then
95844: LD_VAR 0 2
95848: NOT
95849: IFFALSE 95853
// exit ;
95851: GO 95940
// un := tmp [ rand ( 1 , tmp ) ] ;
95853: LD_ADDR_VAR 0 1
95857: PUSH
95858: LD_VAR 0 2
95862: PUSH
95863: LD_INT 1
95865: PPUSH
95866: LD_VAR 0 2
95870: PPUSH
95871: CALL_OW 12
95875: ARRAY
95876: ST_TO_ADDR
// SetSide ( un , 0 ) ;
95877: LD_VAR 0 1
95881: PPUSH
95882: LD_INT 0
95884: PPUSH
95885: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
95889: LD_VAR 0 1
95893: PPUSH
95894: LD_OWVAR 3
95898: PUSH
95899: LD_VAR 0 1
95903: DIFF
95904: PPUSH
95905: LD_VAR 0 1
95909: PPUSH
95910: CALL_OW 74
95914: PPUSH
95915: CALL_OW 115
// wait ( 0 0$20 ) ;
95919: LD_INT 700
95921: PPUSH
95922: CALL_OW 67
// SetSide ( un , your_side ) ;
95926: LD_VAR 0 1
95930: PPUSH
95931: LD_OWVAR 2
95935: PPUSH
95936: CALL_OW 235
// end ;
95940: PPOPN 2
95942: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
95943: LD_EXP 133
95947: PUSH
95948: LD_EXP 166
95952: AND
95953: IFFALSE 96059
95955: GO 95957
95957: DISABLE
95958: LD_INT 0
95960: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
95961: LD_ADDR_VAR 0 1
95965: PUSH
95966: LD_INT 22
95968: PUSH
95969: LD_OWVAR 2
95973: PUSH
95974: EMPTY
95975: LIST
95976: LIST
95977: PUSH
95978: LD_INT 2
95980: PUSH
95981: LD_INT 30
95983: PUSH
95984: LD_INT 0
95986: PUSH
95987: EMPTY
95988: LIST
95989: LIST
95990: PUSH
95991: LD_INT 30
95993: PUSH
95994: LD_INT 1
95996: PUSH
95997: EMPTY
95998: LIST
95999: LIST
96000: PUSH
96001: EMPTY
96002: LIST
96003: LIST
96004: LIST
96005: PUSH
96006: EMPTY
96007: LIST
96008: LIST
96009: PPUSH
96010: CALL_OW 69
96014: ST_TO_ADDR
// if not depot then
96015: LD_VAR 0 1
96019: NOT
96020: IFFALSE 96024
// exit ;
96022: GO 96059
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
96024: LD_VAR 0 1
96028: PUSH
96029: LD_INT 1
96031: ARRAY
96032: PPUSH
96033: CALL_OW 250
96037: PPUSH
96038: LD_VAR 0 1
96042: PUSH
96043: LD_INT 1
96045: ARRAY
96046: PPUSH
96047: CALL_OW 251
96051: PPUSH
96052: LD_INT 70
96054: PPUSH
96055: CALL_OW 495
// end ;
96059: PPOPN 1
96061: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
96062: LD_EXP 133
96066: PUSH
96067: LD_EXP 167
96071: AND
96072: IFFALSE 96283
96074: GO 96076
96076: DISABLE
96077: LD_INT 0
96079: PPUSH
96080: PPUSH
96081: PPUSH
96082: PPUSH
96083: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
96084: LD_ADDR_VAR 0 5
96088: PUSH
96089: LD_INT 22
96091: PUSH
96092: LD_OWVAR 2
96096: PUSH
96097: EMPTY
96098: LIST
96099: LIST
96100: PUSH
96101: LD_INT 21
96103: PUSH
96104: LD_INT 1
96106: PUSH
96107: EMPTY
96108: LIST
96109: LIST
96110: PUSH
96111: EMPTY
96112: LIST
96113: LIST
96114: PPUSH
96115: CALL_OW 69
96119: ST_TO_ADDR
// if not tmp then
96120: LD_VAR 0 5
96124: NOT
96125: IFFALSE 96129
// exit ;
96127: GO 96283
// for i in tmp do
96129: LD_ADDR_VAR 0 1
96133: PUSH
96134: LD_VAR 0 5
96138: PUSH
96139: FOR_IN
96140: IFFALSE 96281
// begin d := rand ( 0 , 5 ) ;
96142: LD_ADDR_VAR 0 4
96146: PUSH
96147: LD_INT 0
96149: PPUSH
96150: LD_INT 5
96152: PPUSH
96153: CALL_OW 12
96157: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
96158: LD_ADDR_VAR 0 2
96162: PUSH
96163: LD_VAR 0 1
96167: PPUSH
96168: CALL_OW 250
96172: PPUSH
96173: LD_VAR 0 4
96177: PPUSH
96178: LD_INT 3
96180: PPUSH
96181: LD_INT 12
96183: PPUSH
96184: CALL_OW 12
96188: PPUSH
96189: CALL_OW 272
96193: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
96194: LD_ADDR_VAR 0 3
96198: PUSH
96199: LD_VAR 0 1
96203: PPUSH
96204: CALL_OW 251
96208: PPUSH
96209: LD_VAR 0 4
96213: PPUSH
96214: LD_INT 3
96216: PPUSH
96217: LD_INT 12
96219: PPUSH
96220: CALL_OW 12
96224: PPUSH
96225: CALL_OW 273
96229: ST_TO_ADDR
// if ValidHex ( x , y ) then
96230: LD_VAR 0 2
96234: PPUSH
96235: LD_VAR 0 3
96239: PPUSH
96240: CALL_OW 488
96244: IFFALSE 96279
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
96246: LD_VAR 0 1
96250: PPUSH
96251: LD_VAR 0 2
96255: PPUSH
96256: LD_VAR 0 3
96260: PPUSH
96261: LD_INT 3
96263: PPUSH
96264: LD_INT 6
96266: PPUSH
96267: CALL_OW 12
96271: PPUSH
96272: LD_INT 1
96274: PPUSH
96275: CALL_OW 483
// end ;
96279: GO 96139
96281: POP
96282: POP
// end ;
96283: PPOPN 5
96285: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
96286: LD_EXP 133
96290: PUSH
96291: LD_EXP 168
96295: AND
96296: IFFALSE 96390
96298: GO 96300
96300: DISABLE
96301: LD_INT 0
96303: PPUSH
96304: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
96305: LD_ADDR_VAR 0 2
96309: PUSH
96310: LD_INT 22
96312: PUSH
96313: LD_OWVAR 2
96317: PUSH
96318: EMPTY
96319: LIST
96320: LIST
96321: PUSH
96322: LD_INT 32
96324: PUSH
96325: LD_INT 1
96327: PUSH
96328: EMPTY
96329: LIST
96330: LIST
96331: PUSH
96332: LD_INT 21
96334: PUSH
96335: LD_INT 2
96337: PUSH
96338: EMPTY
96339: LIST
96340: LIST
96341: PUSH
96342: EMPTY
96343: LIST
96344: LIST
96345: LIST
96346: PPUSH
96347: CALL_OW 69
96351: ST_TO_ADDR
// if not tmp then
96352: LD_VAR 0 2
96356: NOT
96357: IFFALSE 96361
// exit ;
96359: GO 96390
// for i in tmp do
96361: LD_ADDR_VAR 0 1
96365: PUSH
96366: LD_VAR 0 2
96370: PUSH
96371: FOR_IN
96372: IFFALSE 96388
// SetFuel ( i , 0 ) ;
96374: LD_VAR 0 1
96378: PPUSH
96379: LD_INT 0
96381: PPUSH
96382: CALL_OW 240
96386: GO 96371
96388: POP
96389: POP
// end ;
96390: PPOPN 2
96392: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
96393: LD_EXP 133
96397: PUSH
96398: LD_EXP 169
96402: AND
96403: IFFALSE 96469
96405: GO 96407
96407: DISABLE
96408: LD_INT 0
96410: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
96411: LD_ADDR_VAR 0 1
96415: PUSH
96416: LD_INT 22
96418: PUSH
96419: LD_OWVAR 2
96423: PUSH
96424: EMPTY
96425: LIST
96426: LIST
96427: PUSH
96428: LD_INT 30
96430: PUSH
96431: LD_INT 29
96433: PUSH
96434: EMPTY
96435: LIST
96436: LIST
96437: PUSH
96438: EMPTY
96439: LIST
96440: LIST
96441: PPUSH
96442: CALL_OW 69
96446: ST_TO_ADDR
// if not tmp then
96447: LD_VAR 0 1
96451: NOT
96452: IFFALSE 96456
// exit ;
96454: GO 96469
// DestroyUnit ( tmp [ 1 ] ) ;
96456: LD_VAR 0 1
96460: PUSH
96461: LD_INT 1
96463: ARRAY
96464: PPUSH
96465: CALL_OW 65
// end ;
96469: PPOPN 1
96471: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
96472: LD_EXP 133
96476: PUSH
96477: LD_EXP 171
96481: AND
96482: IFFALSE 96611
96484: GO 96486
96486: DISABLE
96487: LD_INT 0
96489: PPUSH
// begin uc_side := 0 ;
96490: LD_ADDR_OWVAR 20
96494: PUSH
96495: LD_INT 0
96497: ST_TO_ADDR
// uc_nation := nation_arabian ;
96498: LD_ADDR_OWVAR 21
96502: PUSH
96503: LD_INT 2
96505: ST_TO_ADDR
// hc_gallery :=  ;
96506: LD_ADDR_OWVAR 33
96510: PUSH
96511: LD_STRING 
96513: ST_TO_ADDR
// hc_name :=  ;
96514: LD_ADDR_OWVAR 26
96518: PUSH
96519: LD_STRING 
96521: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
96522: LD_INT 1
96524: PPUSH
96525: LD_INT 11
96527: PPUSH
96528: LD_INT 10
96530: PPUSH
96531: CALL_OW 380
// un := CreateHuman ;
96535: LD_ADDR_VAR 0 1
96539: PUSH
96540: CALL_OW 44
96544: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
96545: LD_VAR 0 1
96549: PPUSH
96550: LD_INT 1
96552: PPUSH
96553: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
96557: LD_INT 35
96559: PPUSH
96560: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
96564: LD_VAR 0 1
96568: PPUSH
96569: LD_INT 22
96571: PUSH
96572: LD_OWVAR 2
96576: PUSH
96577: EMPTY
96578: LIST
96579: LIST
96580: PPUSH
96581: CALL_OW 69
96585: PPUSH
96586: LD_VAR 0 1
96590: PPUSH
96591: CALL_OW 74
96595: PPUSH
96596: CALL_OW 115
// until IsDead ( un ) ;
96600: LD_VAR 0 1
96604: PPUSH
96605: CALL_OW 301
96609: IFFALSE 96557
// end ;
96611: PPOPN 1
96613: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
96614: LD_EXP 133
96618: PUSH
96619: LD_EXP 173
96623: AND
96624: IFFALSE 96636
96626: GO 96628
96628: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
96629: LD_STRING earthquake(getX(game), 0, 32)
96631: PPUSH
96632: CALL_OW 559
96636: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
96637: LD_EXP 133
96641: PUSH
96642: LD_EXP 174
96646: AND
96647: IFFALSE 96738
96649: GO 96651
96651: DISABLE
96652: LD_INT 0
96654: PPUSH
// begin enable ;
96655: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
96656: LD_ADDR_VAR 0 1
96660: PUSH
96661: LD_INT 22
96663: PUSH
96664: LD_OWVAR 2
96668: PUSH
96669: EMPTY
96670: LIST
96671: LIST
96672: PUSH
96673: LD_INT 21
96675: PUSH
96676: LD_INT 2
96678: PUSH
96679: EMPTY
96680: LIST
96681: LIST
96682: PUSH
96683: LD_INT 33
96685: PUSH
96686: LD_INT 3
96688: PUSH
96689: EMPTY
96690: LIST
96691: LIST
96692: PUSH
96693: EMPTY
96694: LIST
96695: LIST
96696: LIST
96697: PPUSH
96698: CALL_OW 69
96702: ST_TO_ADDR
// if not tmp then
96703: LD_VAR 0 1
96707: NOT
96708: IFFALSE 96712
// exit ;
96710: GO 96738
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
96712: LD_VAR 0 1
96716: PUSH
96717: LD_INT 1
96719: PPUSH
96720: LD_VAR 0 1
96724: PPUSH
96725: CALL_OW 12
96729: ARRAY
96730: PPUSH
96731: LD_INT 1
96733: PPUSH
96734: CALL_OW 234
// end ;
96738: PPOPN 1
96740: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
96741: LD_EXP 133
96745: PUSH
96746: LD_EXP 175
96750: AND
96751: IFFALSE 96892
96753: GO 96755
96755: DISABLE
96756: LD_INT 0
96758: PPUSH
96759: PPUSH
96760: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96761: LD_ADDR_VAR 0 3
96765: PUSH
96766: LD_INT 22
96768: PUSH
96769: LD_OWVAR 2
96773: PUSH
96774: EMPTY
96775: LIST
96776: LIST
96777: PUSH
96778: LD_INT 25
96780: PUSH
96781: LD_INT 1
96783: PUSH
96784: EMPTY
96785: LIST
96786: LIST
96787: PUSH
96788: EMPTY
96789: LIST
96790: LIST
96791: PPUSH
96792: CALL_OW 69
96796: ST_TO_ADDR
// if not tmp then
96797: LD_VAR 0 3
96801: NOT
96802: IFFALSE 96806
// exit ;
96804: GO 96892
// un := tmp [ rand ( 1 , tmp ) ] ;
96806: LD_ADDR_VAR 0 2
96810: PUSH
96811: LD_VAR 0 3
96815: PUSH
96816: LD_INT 1
96818: PPUSH
96819: LD_VAR 0 3
96823: PPUSH
96824: CALL_OW 12
96828: ARRAY
96829: ST_TO_ADDR
// if Crawls ( un ) then
96830: LD_VAR 0 2
96834: PPUSH
96835: CALL_OW 318
96839: IFFALSE 96850
// ComWalk ( un ) ;
96841: LD_VAR 0 2
96845: PPUSH
96846: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
96850: LD_VAR 0 2
96854: PPUSH
96855: LD_INT 9
96857: PPUSH
96858: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
96862: LD_INT 28
96864: PPUSH
96865: LD_OWVAR 2
96869: PPUSH
96870: LD_INT 2
96872: PPUSH
96873: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
96877: LD_INT 29
96879: PPUSH
96880: LD_OWVAR 2
96884: PPUSH
96885: LD_INT 2
96887: PPUSH
96888: CALL_OW 322
// end ;
96892: PPOPN 3
96894: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
96895: LD_EXP 133
96899: PUSH
96900: LD_EXP 176
96904: AND
96905: IFFALSE 97016
96907: GO 96909
96909: DISABLE
96910: LD_INT 0
96912: PPUSH
96913: PPUSH
96914: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96915: LD_ADDR_VAR 0 3
96919: PUSH
96920: LD_INT 22
96922: PUSH
96923: LD_OWVAR 2
96927: PUSH
96928: EMPTY
96929: LIST
96930: LIST
96931: PUSH
96932: LD_INT 25
96934: PUSH
96935: LD_INT 1
96937: PUSH
96938: EMPTY
96939: LIST
96940: LIST
96941: PUSH
96942: EMPTY
96943: LIST
96944: LIST
96945: PPUSH
96946: CALL_OW 69
96950: ST_TO_ADDR
// if not tmp then
96951: LD_VAR 0 3
96955: NOT
96956: IFFALSE 96960
// exit ;
96958: GO 97016
// un := tmp [ rand ( 1 , tmp ) ] ;
96960: LD_ADDR_VAR 0 2
96964: PUSH
96965: LD_VAR 0 3
96969: PUSH
96970: LD_INT 1
96972: PPUSH
96973: LD_VAR 0 3
96977: PPUSH
96978: CALL_OW 12
96982: ARRAY
96983: ST_TO_ADDR
// if Crawls ( un ) then
96984: LD_VAR 0 2
96988: PPUSH
96989: CALL_OW 318
96993: IFFALSE 97004
// ComWalk ( un ) ;
96995: LD_VAR 0 2
96999: PPUSH
97000: CALL_OW 138
// SetClass ( un , class_mortar ) ;
97004: LD_VAR 0 2
97008: PPUSH
97009: LD_INT 8
97011: PPUSH
97012: CALL_OW 336
// end ;
97016: PPOPN 3
97018: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
97019: LD_EXP 133
97023: PUSH
97024: LD_EXP 177
97028: AND
97029: IFFALSE 97173
97031: GO 97033
97033: DISABLE
97034: LD_INT 0
97036: PPUSH
97037: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
97038: LD_ADDR_VAR 0 2
97042: PUSH
97043: LD_INT 22
97045: PUSH
97046: LD_OWVAR 2
97050: PUSH
97051: EMPTY
97052: LIST
97053: LIST
97054: PUSH
97055: LD_INT 21
97057: PUSH
97058: LD_INT 2
97060: PUSH
97061: EMPTY
97062: LIST
97063: LIST
97064: PUSH
97065: LD_INT 2
97067: PUSH
97068: LD_INT 34
97070: PUSH
97071: LD_INT 12
97073: PUSH
97074: EMPTY
97075: LIST
97076: LIST
97077: PUSH
97078: LD_INT 34
97080: PUSH
97081: LD_INT 51
97083: PUSH
97084: EMPTY
97085: LIST
97086: LIST
97087: PUSH
97088: LD_INT 34
97090: PUSH
97091: LD_INT 32
97093: PUSH
97094: EMPTY
97095: LIST
97096: LIST
97097: PUSH
97098: EMPTY
97099: LIST
97100: LIST
97101: LIST
97102: LIST
97103: PUSH
97104: EMPTY
97105: LIST
97106: LIST
97107: LIST
97108: PPUSH
97109: CALL_OW 69
97113: ST_TO_ADDR
// if not tmp then
97114: LD_VAR 0 2
97118: NOT
97119: IFFALSE 97123
// exit ;
97121: GO 97173
// for i in tmp do
97123: LD_ADDR_VAR 0 1
97127: PUSH
97128: LD_VAR 0 2
97132: PUSH
97133: FOR_IN
97134: IFFALSE 97171
// if GetCargo ( i , mat_artifact ) = 0 then
97136: LD_VAR 0 1
97140: PPUSH
97141: LD_INT 4
97143: PPUSH
97144: CALL_OW 289
97148: PUSH
97149: LD_INT 0
97151: EQUAL
97152: IFFALSE 97169
// SetCargo ( i , mat_siberit , 100 ) ;
97154: LD_VAR 0 1
97158: PPUSH
97159: LD_INT 3
97161: PPUSH
97162: LD_INT 100
97164: PPUSH
97165: CALL_OW 290
97169: GO 97133
97171: POP
97172: POP
// end ;
97173: PPOPN 2
97175: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
97176: LD_EXP 133
97180: PUSH
97181: LD_EXP 178
97185: AND
97186: IFFALSE 97369
97188: GO 97190
97190: DISABLE
97191: LD_INT 0
97193: PPUSH
97194: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
97195: LD_ADDR_VAR 0 2
97199: PUSH
97200: LD_INT 22
97202: PUSH
97203: LD_OWVAR 2
97207: PUSH
97208: EMPTY
97209: LIST
97210: LIST
97211: PPUSH
97212: CALL_OW 69
97216: ST_TO_ADDR
// if not tmp then
97217: LD_VAR 0 2
97221: NOT
97222: IFFALSE 97226
// exit ;
97224: GO 97369
// for i := 1 to 2 do
97226: LD_ADDR_VAR 0 1
97230: PUSH
97231: DOUBLE
97232: LD_INT 1
97234: DEC
97235: ST_TO_ADDR
97236: LD_INT 2
97238: PUSH
97239: FOR_TO
97240: IFFALSE 97367
// begin uc_side := your_side ;
97242: LD_ADDR_OWVAR 20
97246: PUSH
97247: LD_OWVAR 2
97251: ST_TO_ADDR
// uc_nation := nation_american ;
97252: LD_ADDR_OWVAR 21
97256: PUSH
97257: LD_INT 1
97259: ST_TO_ADDR
// vc_chassis := us_morphling ;
97260: LD_ADDR_OWVAR 37
97264: PUSH
97265: LD_INT 5
97267: ST_TO_ADDR
// vc_engine := engine_siberite ;
97268: LD_ADDR_OWVAR 39
97272: PUSH
97273: LD_INT 3
97275: ST_TO_ADDR
// vc_control := control_computer ;
97276: LD_ADDR_OWVAR 38
97280: PUSH
97281: LD_INT 3
97283: ST_TO_ADDR
// vc_weapon := us_double_laser ;
97284: LD_ADDR_OWVAR 40
97288: PUSH
97289: LD_INT 10
97291: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
97292: LD_VAR 0 2
97296: PUSH
97297: LD_INT 1
97299: ARRAY
97300: PPUSH
97301: CALL_OW 310
97305: NOT
97306: IFFALSE 97353
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
97308: CALL_OW 45
97312: PPUSH
97313: LD_VAR 0 2
97317: PUSH
97318: LD_INT 1
97320: ARRAY
97321: PPUSH
97322: CALL_OW 250
97326: PPUSH
97327: LD_VAR 0 2
97331: PUSH
97332: LD_INT 1
97334: ARRAY
97335: PPUSH
97336: CALL_OW 251
97340: PPUSH
97341: LD_INT 12
97343: PPUSH
97344: LD_INT 1
97346: PPUSH
97347: CALL_OW 50
97351: GO 97365
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
97353: CALL_OW 45
97357: PPUSH
97358: LD_INT 1
97360: PPUSH
97361: CALL_OW 51
// end ;
97365: GO 97239
97367: POP
97368: POP
// end ;
97369: PPOPN 2
97371: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
97372: LD_EXP 133
97376: PUSH
97377: LD_EXP 179
97381: AND
97382: IFFALSE 97604
97384: GO 97386
97386: DISABLE
97387: LD_INT 0
97389: PPUSH
97390: PPUSH
97391: PPUSH
97392: PPUSH
97393: PPUSH
97394: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
97395: LD_ADDR_VAR 0 6
97399: PUSH
97400: LD_INT 22
97402: PUSH
97403: LD_OWVAR 2
97407: PUSH
97408: EMPTY
97409: LIST
97410: LIST
97411: PUSH
97412: LD_INT 21
97414: PUSH
97415: LD_INT 1
97417: PUSH
97418: EMPTY
97419: LIST
97420: LIST
97421: PUSH
97422: LD_INT 3
97424: PUSH
97425: LD_INT 23
97427: PUSH
97428: LD_INT 0
97430: PUSH
97431: EMPTY
97432: LIST
97433: LIST
97434: PUSH
97435: EMPTY
97436: LIST
97437: LIST
97438: PUSH
97439: EMPTY
97440: LIST
97441: LIST
97442: LIST
97443: PPUSH
97444: CALL_OW 69
97448: ST_TO_ADDR
// if not tmp then
97449: LD_VAR 0 6
97453: NOT
97454: IFFALSE 97458
// exit ;
97456: GO 97604
// s1 := rand ( 1 , 4 ) ;
97458: LD_ADDR_VAR 0 2
97462: PUSH
97463: LD_INT 1
97465: PPUSH
97466: LD_INT 4
97468: PPUSH
97469: CALL_OW 12
97473: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
97474: LD_ADDR_VAR 0 4
97478: PUSH
97479: LD_VAR 0 6
97483: PUSH
97484: LD_INT 1
97486: ARRAY
97487: PPUSH
97488: LD_VAR 0 2
97492: PPUSH
97493: CALL_OW 259
97497: ST_TO_ADDR
// if s1 = 1 then
97498: LD_VAR 0 2
97502: PUSH
97503: LD_INT 1
97505: EQUAL
97506: IFFALSE 97526
// s2 := rand ( 2 , 4 ) else
97508: LD_ADDR_VAR 0 3
97512: PUSH
97513: LD_INT 2
97515: PPUSH
97516: LD_INT 4
97518: PPUSH
97519: CALL_OW 12
97523: ST_TO_ADDR
97524: GO 97534
// s2 := 1 ;
97526: LD_ADDR_VAR 0 3
97530: PUSH
97531: LD_INT 1
97533: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
97534: LD_ADDR_VAR 0 5
97538: PUSH
97539: LD_VAR 0 6
97543: PUSH
97544: LD_INT 1
97546: ARRAY
97547: PPUSH
97548: LD_VAR 0 3
97552: PPUSH
97553: CALL_OW 259
97557: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
97558: LD_VAR 0 6
97562: PUSH
97563: LD_INT 1
97565: ARRAY
97566: PPUSH
97567: LD_VAR 0 2
97571: PPUSH
97572: LD_VAR 0 5
97576: PPUSH
97577: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
97581: LD_VAR 0 6
97585: PUSH
97586: LD_INT 1
97588: ARRAY
97589: PPUSH
97590: LD_VAR 0 3
97594: PPUSH
97595: LD_VAR 0 4
97599: PPUSH
97600: CALL_OW 237
// end ;
97604: PPOPN 6
97606: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
97607: LD_EXP 133
97611: PUSH
97612: LD_EXP 180
97616: AND
97617: IFFALSE 97696
97619: GO 97621
97621: DISABLE
97622: LD_INT 0
97624: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
97625: LD_ADDR_VAR 0 1
97629: PUSH
97630: LD_INT 22
97632: PUSH
97633: LD_OWVAR 2
97637: PUSH
97638: EMPTY
97639: LIST
97640: LIST
97641: PUSH
97642: LD_INT 30
97644: PUSH
97645: LD_INT 3
97647: PUSH
97648: EMPTY
97649: LIST
97650: LIST
97651: PUSH
97652: EMPTY
97653: LIST
97654: LIST
97655: PPUSH
97656: CALL_OW 69
97660: ST_TO_ADDR
// if not tmp then
97661: LD_VAR 0 1
97665: NOT
97666: IFFALSE 97670
// exit ;
97668: GO 97696
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
97670: LD_VAR 0 1
97674: PUSH
97675: LD_INT 1
97677: PPUSH
97678: LD_VAR 0 1
97682: PPUSH
97683: CALL_OW 12
97687: ARRAY
97688: PPUSH
97689: LD_INT 1
97691: PPUSH
97692: CALL_OW 234
// end ;
97696: PPOPN 1
97698: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
97699: LD_EXP 133
97703: PUSH
97704: LD_EXP 181
97708: AND
97709: IFFALSE 97821
97711: GO 97713
97713: DISABLE
97714: LD_INT 0
97716: PPUSH
97717: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
97718: LD_ADDR_VAR 0 2
97722: PUSH
97723: LD_INT 22
97725: PUSH
97726: LD_OWVAR 2
97730: PUSH
97731: EMPTY
97732: LIST
97733: LIST
97734: PUSH
97735: LD_INT 2
97737: PUSH
97738: LD_INT 30
97740: PUSH
97741: LD_INT 27
97743: PUSH
97744: EMPTY
97745: LIST
97746: LIST
97747: PUSH
97748: LD_INT 30
97750: PUSH
97751: LD_INT 26
97753: PUSH
97754: EMPTY
97755: LIST
97756: LIST
97757: PUSH
97758: LD_INT 30
97760: PUSH
97761: LD_INT 28
97763: PUSH
97764: EMPTY
97765: LIST
97766: LIST
97767: PUSH
97768: EMPTY
97769: LIST
97770: LIST
97771: LIST
97772: LIST
97773: PUSH
97774: EMPTY
97775: LIST
97776: LIST
97777: PPUSH
97778: CALL_OW 69
97782: ST_TO_ADDR
// if not tmp then
97783: LD_VAR 0 2
97787: NOT
97788: IFFALSE 97792
// exit ;
97790: GO 97821
// for i in tmp do
97792: LD_ADDR_VAR 0 1
97796: PUSH
97797: LD_VAR 0 2
97801: PUSH
97802: FOR_IN
97803: IFFALSE 97819
// SetLives ( i , 1 ) ;
97805: LD_VAR 0 1
97809: PPUSH
97810: LD_INT 1
97812: PPUSH
97813: CALL_OW 234
97817: GO 97802
97819: POP
97820: POP
// end ;
97821: PPOPN 2
97823: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
97824: LD_EXP 133
97828: PUSH
97829: LD_EXP 182
97833: AND
97834: IFFALSE 98108
97836: GO 97838
97838: DISABLE
97839: LD_INT 0
97841: PPUSH
97842: PPUSH
97843: PPUSH
// begin i := rand ( 1 , 7 ) ;
97844: LD_ADDR_VAR 0 1
97848: PUSH
97849: LD_INT 1
97851: PPUSH
97852: LD_INT 7
97854: PPUSH
97855: CALL_OW 12
97859: ST_TO_ADDR
// case i of 1 :
97860: LD_VAR 0 1
97864: PUSH
97865: LD_INT 1
97867: DOUBLE
97868: EQUAL
97869: IFTRUE 97873
97871: GO 97883
97873: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
97874: LD_STRING earthquake(getX(game), 0, 32)
97876: PPUSH
97877: CALL_OW 559
97881: GO 98108
97883: LD_INT 2
97885: DOUBLE
97886: EQUAL
97887: IFTRUE 97891
97889: GO 97905
97891: POP
// begin ToLua ( displayStucuk(); ) ;
97892: LD_STRING displayStucuk();
97894: PPUSH
97895: CALL_OW 559
// ResetFog ;
97899: CALL_OW 335
// end ; 3 :
97903: GO 98108
97905: LD_INT 3
97907: DOUBLE
97908: EQUAL
97909: IFTRUE 97913
97911: GO 98017
97913: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97914: LD_ADDR_VAR 0 2
97918: PUSH
97919: LD_INT 22
97921: PUSH
97922: LD_OWVAR 2
97926: PUSH
97927: EMPTY
97928: LIST
97929: LIST
97930: PUSH
97931: LD_INT 25
97933: PUSH
97934: LD_INT 1
97936: PUSH
97937: EMPTY
97938: LIST
97939: LIST
97940: PUSH
97941: EMPTY
97942: LIST
97943: LIST
97944: PPUSH
97945: CALL_OW 69
97949: ST_TO_ADDR
// if not tmp then
97950: LD_VAR 0 2
97954: NOT
97955: IFFALSE 97959
// exit ;
97957: GO 98108
// un := tmp [ rand ( 1 , tmp ) ] ;
97959: LD_ADDR_VAR 0 3
97963: PUSH
97964: LD_VAR 0 2
97968: PUSH
97969: LD_INT 1
97971: PPUSH
97972: LD_VAR 0 2
97976: PPUSH
97977: CALL_OW 12
97981: ARRAY
97982: ST_TO_ADDR
// if Crawls ( un ) then
97983: LD_VAR 0 3
97987: PPUSH
97988: CALL_OW 318
97992: IFFALSE 98003
// ComWalk ( un ) ;
97994: LD_VAR 0 3
97998: PPUSH
97999: CALL_OW 138
// SetClass ( un , class_mortar ) ;
98003: LD_VAR 0 3
98007: PPUSH
98008: LD_INT 8
98010: PPUSH
98011: CALL_OW 336
// end ; 4 :
98015: GO 98108
98017: LD_INT 4
98019: DOUBLE
98020: EQUAL
98021: IFTRUE 98025
98023: GO 98086
98025: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
98026: LD_ADDR_VAR 0 2
98030: PUSH
98031: LD_INT 22
98033: PUSH
98034: LD_OWVAR 2
98038: PUSH
98039: EMPTY
98040: LIST
98041: LIST
98042: PUSH
98043: LD_INT 30
98045: PUSH
98046: LD_INT 29
98048: PUSH
98049: EMPTY
98050: LIST
98051: LIST
98052: PUSH
98053: EMPTY
98054: LIST
98055: LIST
98056: PPUSH
98057: CALL_OW 69
98061: ST_TO_ADDR
// if not tmp then
98062: LD_VAR 0 2
98066: NOT
98067: IFFALSE 98071
// exit ;
98069: GO 98108
// DestroyUnit ( tmp [ 1 ] ) ;
98071: LD_VAR 0 2
98075: PUSH
98076: LD_INT 1
98078: ARRAY
98079: PPUSH
98080: CALL_OW 65
// end ; 5 .. 7 :
98084: GO 98108
98086: LD_INT 5
98088: DOUBLE
98089: GREATEREQUAL
98090: IFFALSE 98098
98092: LD_INT 7
98094: DOUBLE
98095: LESSEQUAL
98096: IFTRUE 98100
98098: GO 98107
98100: POP
// StreamSibBomb ; end ;
98101: CALL 94358 0 0
98105: GO 98108
98107: POP
// end ;
98108: PPOPN 3
98110: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
98111: LD_EXP 133
98115: PUSH
98116: LD_EXP 183
98120: AND
98121: IFFALSE 98277
98123: GO 98125
98125: DISABLE
98126: LD_INT 0
98128: PPUSH
98129: PPUSH
98130: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
98131: LD_ADDR_VAR 0 2
98135: PUSH
98136: LD_INT 81
98138: PUSH
98139: LD_OWVAR 2
98143: PUSH
98144: EMPTY
98145: LIST
98146: LIST
98147: PUSH
98148: LD_INT 2
98150: PUSH
98151: LD_INT 21
98153: PUSH
98154: LD_INT 1
98156: PUSH
98157: EMPTY
98158: LIST
98159: LIST
98160: PUSH
98161: LD_INT 21
98163: PUSH
98164: LD_INT 2
98166: PUSH
98167: EMPTY
98168: LIST
98169: LIST
98170: PUSH
98171: EMPTY
98172: LIST
98173: LIST
98174: LIST
98175: PUSH
98176: EMPTY
98177: LIST
98178: LIST
98179: PPUSH
98180: CALL_OW 69
98184: ST_TO_ADDR
// if not tmp then
98185: LD_VAR 0 2
98189: NOT
98190: IFFALSE 98194
// exit ;
98192: GO 98277
// p := 0 ;
98194: LD_ADDR_VAR 0 3
98198: PUSH
98199: LD_INT 0
98201: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
98202: LD_INT 35
98204: PPUSH
98205: CALL_OW 67
// p := p + 1 ;
98209: LD_ADDR_VAR 0 3
98213: PUSH
98214: LD_VAR 0 3
98218: PUSH
98219: LD_INT 1
98221: PLUS
98222: ST_TO_ADDR
// for i in tmp do
98223: LD_ADDR_VAR 0 1
98227: PUSH
98228: LD_VAR 0 2
98232: PUSH
98233: FOR_IN
98234: IFFALSE 98265
// if GetLives ( i ) < 1000 then
98236: LD_VAR 0 1
98240: PPUSH
98241: CALL_OW 256
98245: PUSH
98246: LD_INT 1000
98248: LESS
98249: IFFALSE 98263
// SetLives ( i , 1000 ) ;
98251: LD_VAR 0 1
98255: PPUSH
98256: LD_INT 1000
98258: PPUSH
98259: CALL_OW 234
98263: GO 98233
98265: POP
98266: POP
// until p > 20 ;
98267: LD_VAR 0 3
98271: PUSH
98272: LD_INT 20
98274: GREATER
98275: IFFALSE 98202
// end ;
98277: PPOPN 3
98279: END
// every 0 0$1 trigger StreamModeActive and sTime do
98280: LD_EXP 133
98284: PUSH
98285: LD_EXP 184
98289: AND
98290: IFFALSE 98325
98292: GO 98294
98294: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
98295: LD_INT 28
98297: PPUSH
98298: LD_OWVAR 2
98302: PPUSH
98303: LD_INT 2
98305: PPUSH
98306: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
98310: LD_INT 30
98312: PPUSH
98313: LD_OWVAR 2
98317: PPUSH
98318: LD_INT 2
98320: PPUSH
98321: CALL_OW 322
// end ;
98325: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
98326: LD_EXP 133
98330: PUSH
98331: LD_EXP 185
98335: AND
98336: IFFALSE 98457
98338: GO 98340
98340: DISABLE
98341: LD_INT 0
98343: PPUSH
98344: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
98345: LD_ADDR_VAR 0 2
98349: PUSH
98350: LD_INT 22
98352: PUSH
98353: LD_OWVAR 2
98357: PUSH
98358: EMPTY
98359: LIST
98360: LIST
98361: PUSH
98362: LD_INT 21
98364: PUSH
98365: LD_INT 1
98367: PUSH
98368: EMPTY
98369: LIST
98370: LIST
98371: PUSH
98372: LD_INT 3
98374: PUSH
98375: LD_INT 23
98377: PUSH
98378: LD_INT 0
98380: PUSH
98381: EMPTY
98382: LIST
98383: LIST
98384: PUSH
98385: EMPTY
98386: LIST
98387: LIST
98388: PUSH
98389: EMPTY
98390: LIST
98391: LIST
98392: LIST
98393: PPUSH
98394: CALL_OW 69
98398: ST_TO_ADDR
// if not tmp then
98399: LD_VAR 0 2
98403: NOT
98404: IFFALSE 98408
// exit ;
98406: GO 98457
// for i in tmp do
98408: LD_ADDR_VAR 0 1
98412: PUSH
98413: LD_VAR 0 2
98417: PUSH
98418: FOR_IN
98419: IFFALSE 98455
// begin if Crawls ( i ) then
98421: LD_VAR 0 1
98425: PPUSH
98426: CALL_OW 318
98430: IFFALSE 98441
// ComWalk ( i ) ;
98432: LD_VAR 0 1
98436: PPUSH
98437: CALL_OW 138
// SetClass ( i , 2 ) ;
98441: LD_VAR 0 1
98445: PPUSH
98446: LD_INT 2
98448: PPUSH
98449: CALL_OW 336
// end ;
98453: GO 98418
98455: POP
98456: POP
// end ;
98457: PPOPN 2
98459: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
98460: LD_EXP 133
98464: PUSH
98465: LD_EXP 186
98469: AND
98470: IFFALSE 98751
98472: GO 98474
98474: DISABLE
98475: LD_INT 0
98477: PPUSH
98478: PPUSH
98479: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
98480: LD_OWVAR 2
98484: PPUSH
98485: LD_INT 9
98487: PPUSH
98488: LD_INT 1
98490: PPUSH
98491: LD_INT 1
98493: PPUSH
98494: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
98498: LD_INT 9
98500: PPUSH
98501: LD_OWVAR 2
98505: PPUSH
98506: CALL_OW 343
// uc_side := 9 ;
98510: LD_ADDR_OWVAR 20
98514: PUSH
98515: LD_INT 9
98517: ST_TO_ADDR
// uc_nation := 2 ;
98518: LD_ADDR_OWVAR 21
98522: PUSH
98523: LD_INT 2
98525: ST_TO_ADDR
// hc_name := Dark Warrior ;
98526: LD_ADDR_OWVAR 26
98530: PUSH
98531: LD_STRING Dark Warrior
98533: ST_TO_ADDR
// hc_gallery :=  ;
98534: LD_ADDR_OWVAR 33
98538: PUSH
98539: LD_STRING 
98541: ST_TO_ADDR
// hc_noskilllimit := true ;
98542: LD_ADDR_OWVAR 76
98546: PUSH
98547: LD_INT 1
98549: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
98550: LD_ADDR_OWVAR 31
98554: PUSH
98555: LD_INT 30
98557: PUSH
98558: LD_INT 30
98560: PUSH
98561: LD_INT 30
98563: PUSH
98564: LD_INT 30
98566: PUSH
98567: EMPTY
98568: LIST
98569: LIST
98570: LIST
98571: LIST
98572: ST_TO_ADDR
// un := CreateHuman ;
98573: LD_ADDR_VAR 0 3
98577: PUSH
98578: CALL_OW 44
98582: ST_TO_ADDR
// hc_noskilllimit := false ;
98583: LD_ADDR_OWVAR 76
98587: PUSH
98588: LD_INT 0
98590: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
98591: LD_VAR 0 3
98595: PPUSH
98596: LD_INT 1
98598: PPUSH
98599: CALL_OW 51
// p := 0 ;
98603: LD_ADDR_VAR 0 2
98607: PUSH
98608: LD_INT 0
98610: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
98611: LD_INT 35
98613: PPUSH
98614: CALL_OW 67
// p := p + 1 ;
98618: LD_ADDR_VAR 0 2
98622: PUSH
98623: LD_VAR 0 2
98627: PUSH
98628: LD_INT 1
98630: PLUS
98631: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
98632: LD_VAR 0 3
98636: PPUSH
98637: CALL_OW 256
98641: PUSH
98642: LD_INT 1000
98644: LESS
98645: IFFALSE 98659
// SetLives ( un , 1000 ) ;
98647: LD_VAR 0 3
98651: PPUSH
98652: LD_INT 1000
98654: PPUSH
98655: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
98659: LD_VAR 0 3
98663: PPUSH
98664: LD_INT 81
98666: PUSH
98667: LD_OWVAR 2
98671: PUSH
98672: EMPTY
98673: LIST
98674: LIST
98675: PUSH
98676: LD_INT 91
98678: PUSH
98679: LD_VAR 0 3
98683: PUSH
98684: LD_INT 30
98686: PUSH
98687: EMPTY
98688: LIST
98689: LIST
98690: LIST
98691: PUSH
98692: EMPTY
98693: LIST
98694: LIST
98695: PPUSH
98696: CALL_OW 69
98700: PPUSH
98701: LD_VAR 0 3
98705: PPUSH
98706: CALL_OW 74
98710: PPUSH
98711: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
98715: LD_VAR 0 2
98719: PUSH
98720: LD_INT 60
98722: GREATER
98723: PUSH
98724: LD_VAR 0 3
98728: PPUSH
98729: CALL_OW 301
98733: OR
98734: IFFALSE 98611
// if un then
98736: LD_VAR 0 3
98740: IFFALSE 98751
// RemoveUnit ( un ) ;
98742: LD_VAR 0 3
98746: PPUSH
98747: CALL_OW 64
// end ;
98751: PPOPN 3
98753: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
98754: LD_INT 0
98756: PPUSH
// case cmd of 301 :
98757: LD_VAR 0 1
98761: PUSH
98762: LD_INT 301
98764: DOUBLE
98765: EQUAL
98766: IFTRUE 98770
98768: GO 98802
98770: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
98771: LD_VAR 0 6
98775: PPUSH
98776: LD_VAR 0 7
98780: PPUSH
98781: LD_VAR 0 8
98785: PPUSH
98786: LD_VAR 0 4
98790: PPUSH
98791: LD_VAR 0 5
98795: PPUSH
98796: CALL 100003 0 5
98800: GO 98923
98802: LD_INT 302
98804: DOUBLE
98805: EQUAL
98806: IFTRUE 98810
98808: GO 98847
98810: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
98811: LD_VAR 0 6
98815: PPUSH
98816: LD_VAR 0 7
98820: PPUSH
98821: LD_VAR 0 8
98825: PPUSH
98826: LD_VAR 0 9
98830: PPUSH
98831: LD_VAR 0 4
98835: PPUSH
98836: LD_VAR 0 5
98840: PPUSH
98841: CALL 100094 0 6
98845: GO 98923
98847: LD_INT 303
98849: DOUBLE
98850: EQUAL
98851: IFTRUE 98855
98853: GO 98892
98855: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
98856: LD_VAR 0 6
98860: PPUSH
98861: LD_VAR 0 7
98865: PPUSH
98866: LD_VAR 0 8
98870: PPUSH
98871: LD_VAR 0 9
98875: PPUSH
98876: LD_VAR 0 4
98880: PPUSH
98881: LD_VAR 0 5
98885: PPUSH
98886: CALL 98928 0 6
98890: GO 98923
98892: LD_INT 304
98894: DOUBLE
98895: EQUAL
98896: IFTRUE 98900
98898: GO 98922
98900: POP
// hHackTeleport ( unit , x , y ) ; end ;
98901: LD_VAR 0 2
98905: PPUSH
98906: LD_VAR 0 4
98910: PPUSH
98911: LD_VAR 0 5
98915: PPUSH
98916: CALL 100687 0 3
98920: GO 98923
98922: POP
// end ;
98923: LD_VAR 0 12
98927: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
98928: LD_INT 0
98930: PPUSH
98931: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
98932: LD_VAR 0 1
98936: PUSH
98937: LD_INT 1
98939: LESS
98940: PUSH
98941: LD_VAR 0 1
98945: PUSH
98946: LD_INT 3
98948: GREATER
98949: OR
98950: PUSH
98951: LD_VAR 0 5
98955: PPUSH
98956: LD_VAR 0 6
98960: PPUSH
98961: CALL_OW 428
98965: OR
98966: IFFALSE 98970
// exit ;
98968: GO 99690
// uc_side := your_side ;
98970: LD_ADDR_OWVAR 20
98974: PUSH
98975: LD_OWVAR 2
98979: ST_TO_ADDR
// uc_nation := nation ;
98980: LD_ADDR_OWVAR 21
98984: PUSH
98985: LD_VAR 0 1
98989: ST_TO_ADDR
// bc_level = 1 ;
98990: LD_ADDR_OWVAR 43
98994: PUSH
98995: LD_INT 1
98997: ST_TO_ADDR
// case btype of 1 :
98998: LD_VAR 0 2
99002: PUSH
99003: LD_INT 1
99005: DOUBLE
99006: EQUAL
99007: IFTRUE 99011
99009: GO 99022
99011: POP
// bc_type := b_depot ; 2 :
99012: LD_ADDR_OWVAR 42
99016: PUSH
99017: LD_INT 0
99019: ST_TO_ADDR
99020: GO 99634
99022: LD_INT 2
99024: DOUBLE
99025: EQUAL
99026: IFTRUE 99030
99028: GO 99041
99030: POP
// bc_type := b_warehouse ; 3 :
99031: LD_ADDR_OWVAR 42
99035: PUSH
99036: LD_INT 1
99038: ST_TO_ADDR
99039: GO 99634
99041: LD_INT 3
99043: DOUBLE
99044: EQUAL
99045: IFTRUE 99049
99047: GO 99060
99049: POP
// bc_type := b_lab ; 4 .. 9 :
99050: LD_ADDR_OWVAR 42
99054: PUSH
99055: LD_INT 6
99057: ST_TO_ADDR
99058: GO 99634
99060: LD_INT 4
99062: DOUBLE
99063: GREATEREQUAL
99064: IFFALSE 99072
99066: LD_INT 9
99068: DOUBLE
99069: LESSEQUAL
99070: IFTRUE 99074
99072: GO 99126
99074: POP
// begin bc_type := b_lab_half ;
99075: LD_ADDR_OWVAR 42
99079: PUSH
99080: LD_INT 7
99082: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
99083: LD_ADDR_OWVAR 44
99087: PUSH
99088: LD_INT 10
99090: PUSH
99091: LD_INT 11
99093: PUSH
99094: LD_INT 12
99096: PUSH
99097: LD_INT 15
99099: PUSH
99100: LD_INT 14
99102: PUSH
99103: LD_INT 13
99105: PUSH
99106: EMPTY
99107: LIST
99108: LIST
99109: LIST
99110: LIST
99111: LIST
99112: LIST
99113: PUSH
99114: LD_VAR 0 2
99118: PUSH
99119: LD_INT 3
99121: MINUS
99122: ARRAY
99123: ST_TO_ADDR
// end ; 10 .. 13 :
99124: GO 99634
99126: LD_INT 10
99128: DOUBLE
99129: GREATEREQUAL
99130: IFFALSE 99138
99132: LD_INT 13
99134: DOUBLE
99135: LESSEQUAL
99136: IFTRUE 99140
99138: GO 99217
99140: POP
// begin bc_type := b_lab_full ;
99141: LD_ADDR_OWVAR 42
99145: PUSH
99146: LD_INT 8
99148: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
99149: LD_ADDR_OWVAR 44
99153: PUSH
99154: LD_INT 10
99156: PUSH
99157: LD_INT 12
99159: PUSH
99160: LD_INT 14
99162: PUSH
99163: LD_INT 13
99165: PUSH
99166: EMPTY
99167: LIST
99168: LIST
99169: LIST
99170: LIST
99171: PUSH
99172: LD_VAR 0 2
99176: PUSH
99177: LD_INT 9
99179: MINUS
99180: ARRAY
99181: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
99182: LD_ADDR_OWVAR 45
99186: PUSH
99187: LD_INT 11
99189: PUSH
99190: LD_INT 15
99192: PUSH
99193: LD_INT 12
99195: PUSH
99196: LD_INT 15
99198: PUSH
99199: EMPTY
99200: LIST
99201: LIST
99202: LIST
99203: LIST
99204: PUSH
99205: LD_VAR 0 2
99209: PUSH
99210: LD_INT 9
99212: MINUS
99213: ARRAY
99214: ST_TO_ADDR
// end ; 14 :
99215: GO 99634
99217: LD_INT 14
99219: DOUBLE
99220: EQUAL
99221: IFTRUE 99225
99223: GO 99236
99225: POP
// bc_type := b_workshop ; 15 :
99226: LD_ADDR_OWVAR 42
99230: PUSH
99231: LD_INT 2
99233: ST_TO_ADDR
99234: GO 99634
99236: LD_INT 15
99238: DOUBLE
99239: EQUAL
99240: IFTRUE 99244
99242: GO 99255
99244: POP
// bc_type := b_factory ; 16 :
99245: LD_ADDR_OWVAR 42
99249: PUSH
99250: LD_INT 3
99252: ST_TO_ADDR
99253: GO 99634
99255: LD_INT 16
99257: DOUBLE
99258: EQUAL
99259: IFTRUE 99263
99261: GO 99274
99263: POP
// bc_type := b_ext_gun ; 17 :
99264: LD_ADDR_OWVAR 42
99268: PUSH
99269: LD_INT 17
99271: ST_TO_ADDR
99272: GO 99634
99274: LD_INT 17
99276: DOUBLE
99277: EQUAL
99278: IFTRUE 99282
99280: GO 99310
99282: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
99283: LD_ADDR_OWVAR 42
99287: PUSH
99288: LD_INT 19
99290: PUSH
99291: LD_INT 23
99293: PUSH
99294: LD_INT 19
99296: PUSH
99297: EMPTY
99298: LIST
99299: LIST
99300: LIST
99301: PUSH
99302: LD_VAR 0 1
99306: ARRAY
99307: ST_TO_ADDR
99308: GO 99634
99310: LD_INT 18
99312: DOUBLE
99313: EQUAL
99314: IFTRUE 99318
99316: GO 99329
99318: POP
// bc_type := b_ext_radar ; 19 :
99319: LD_ADDR_OWVAR 42
99323: PUSH
99324: LD_INT 20
99326: ST_TO_ADDR
99327: GO 99634
99329: LD_INT 19
99331: DOUBLE
99332: EQUAL
99333: IFTRUE 99337
99335: GO 99348
99337: POP
// bc_type := b_ext_radio ; 20 :
99338: LD_ADDR_OWVAR 42
99342: PUSH
99343: LD_INT 22
99345: ST_TO_ADDR
99346: GO 99634
99348: LD_INT 20
99350: DOUBLE
99351: EQUAL
99352: IFTRUE 99356
99354: GO 99367
99356: POP
// bc_type := b_ext_siberium ; 21 :
99357: LD_ADDR_OWVAR 42
99361: PUSH
99362: LD_INT 21
99364: ST_TO_ADDR
99365: GO 99634
99367: LD_INT 21
99369: DOUBLE
99370: EQUAL
99371: IFTRUE 99375
99373: GO 99386
99375: POP
// bc_type := b_ext_computer ; 22 :
99376: LD_ADDR_OWVAR 42
99380: PUSH
99381: LD_INT 24
99383: ST_TO_ADDR
99384: GO 99634
99386: LD_INT 22
99388: DOUBLE
99389: EQUAL
99390: IFTRUE 99394
99392: GO 99405
99394: POP
// bc_type := b_ext_track ; 23 :
99395: LD_ADDR_OWVAR 42
99399: PUSH
99400: LD_INT 16
99402: ST_TO_ADDR
99403: GO 99634
99405: LD_INT 23
99407: DOUBLE
99408: EQUAL
99409: IFTRUE 99413
99411: GO 99424
99413: POP
// bc_type := b_ext_laser ; 24 :
99414: LD_ADDR_OWVAR 42
99418: PUSH
99419: LD_INT 25
99421: ST_TO_ADDR
99422: GO 99634
99424: LD_INT 24
99426: DOUBLE
99427: EQUAL
99428: IFTRUE 99432
99430: GO 99443
99432: POP
// bc_type := b_control_tower ; 25 :
99433: LD_ADDR_OWVAR 42
99437: PUSH
99438: LD_INT 36
99440: ST_TO_ADDR
99441: GO 99634
99443: LD_INT 25
99445: DOUBLE
99446: EQUAL
99447: IFTRUE 99451
99449: GO 99462
99451: POP
// bc_type := b_breastwork ; 26 :
99452: LD_ADDR_OWVAR 42
99456: PUSH
99457: LD_INT 31
99459: ST_TO_ADDR
99460: GO 99634
99462: LD_INT 26
99464: DOUBLE
99465: EQUAL
99466: IFTRUE 99470
99468: GO 99481
99470: POP
// bc_type := b_bunker ; 27 :
99471: LD_ADDR_OWVAR 42
99475: PUSH
99476: LD_INT 32
99478: ST_TO_ADDR
99479: GO 99634
99481: LD_INT 27
99483: DOUBLE
99484: EQUAL
99485: IFTRUE 99489
99487: GO 99500
99489: POP
// bc_type := b_turret ; 28 :
99490: LD_ADDR_OWVAR 42
99494: PUSH
99495: LD_INT 33
99497: ST_TO_ADDR
99498: GO 99634
99500: LD_INT 28
99502: DOUBLE
99503: EQUAL
99504: IFTRUE 99508
99506: GO 99519
99508: POP
// bc_type := b_armoury ; 29 :
99509: LD_ADDR_OWVAR 42
99513: PUSH
99514: LD_INT 4
99516: ST_TO_ADDR
99517: GO 99634
99519: LD_INT 29
99521: DOUBLE
99522: EQUAL
99523: IFTRUE 99527
99525: GO 99538
99527: POP
// bc_type := b_barracks ; 30 :
99528: LD_ADDR_OWVAR 42
99532: PUSH
99533: LD_INT 5
99535: ST_TO_ADDR
99536: GO 99634
99538: LD_INT 30
99540: DOUBLE
99541: EQUAL
99542: IFTRUE 99546
99544: GO 99557
99546: POP
// bc_type := b_solar_power ; 31 :
99547: LD_ADDR_OWVAR 42
99551: PUSH
99552: LD_INT 27
99554: ST_TO_ADDR
99555: GO 99634
99557: LD_INT 31
99559: DOUBLE
99560: EQUAL
99561: IFTRUE 99565
99563: GO 99576
99565: POP
// bc_type := b_oil_power ; 32 :
99566: LD_ADDR_OWVAR 42
99570: PUSH
99571: LD_INT 26
99573: ST_TO_ADDR
99574: GO 99634
99576: LD_INT 32
99578: DOUBLE
99579: EQUAL
99580: IFTRUE 99584
99582: GO 99595
99584: POP
// bc_type := b_siberite_power ; 33 :
99585: LD_ADDR_OWVAR 42
99589: PUSH
99590: LD_INT 28
99592: ST_TO_ADDR
99593: GO 99634
99595: LD_INT 33
99597: DOUBLE
99598: EQUAL
99599: IFTRUE 99603
99601: GO 99614
99603: POP
// bc_type := b_oil_mine ; 34 :
99604: LD_ADDR_OWVAR 42
99608: PUSH
99609: LD_INT 29
99611: ST_TO_ADDR
99612: GO 99634
99614: LD_INT 34
99616: DOUBLE
99617: EQUAL
99618: IFTRUE 99622
99620: GO 99633
99622: POP
// bc_type := b_siberite_mine ; end ;
99623: LD_ADDR_OWVAR 42
99627: PUSH
99628: LD_INT 30
99630: ST_TO_ADDR
99631: GO 99634
99633: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
99634: LD_ADDR_VAR 0 8
99638: PUSH
99639: LD_VAR 0 5
99643: PPUSH
99644: LD_VAR 0 6
99648: PPUSH
99649: LD_VAR 0 3
99653: PPUSH
99654: CALL_OW 47
99658: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
99659: LD_OWVAR 42
99663: PUSH
99664: LD_INT 32
99666: PUSH
99667: LD_INT 33
99669: PUSH
99670: EMPTY
99671: LIST
99672: LIST
99673: IN
99674: IFFALSE 99690
// PlaceWeaponTurret ( b , weapon ) ;
99676: LD_VAR 0 8
99680: PPUSH
99681: LD_VAR 0 4
99685: PPUSH
99686: CALL_OW 431
// end ;
99690: LD_VAR 0 7
99694: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
99695: LD_INT 0
99697: PPUSH
99698: PPUSH
99699: PPUSH
99700: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
99701: LD_ADDR_VAR 0 4
99705: PUSH
99706: LD_INT 22
99708: PUSH
99709: LD_OWVAR 2
99713: PUSH
99714: EMPTY
99715: LIST
99716: LIST
99717: PUSH
99718: LD_INT 2
99720: PUSH
99721: LD_INT 30
99723: PUSH
99724: LD_INT 0
99726: PUSH
99727: EMPTY
99728: LIST
99729: LIST
99730: PUSH
99731: LD_INT 30
99733: PUSH
99734: LD_INT 1
99736: PUSH
99737: EMPTY
99738: LIST
99739: LIST
99740: PUSH
99741: EMPTY
99742: LIST
99743: LIST
99744: LIST
99745: PUSH
99746: EMPTY
99747: LIST
99748: LIST
99749: PPUSH
99750: CALL_OW 69
99754: ST_TO_ADDR
// if not tmp then
99755: LD_VAR 0 4
99759: NOT
99760: IFFALSE 99764
// exit ;
99762: GO 99823
// for i in tmp do
99764: LD_ADDR_VAR 0 2
99768: PUSH
99769: LD_VAR 0 4
99773: PUSH
99774: FOR_IN
99775: IFFALSE 99821
// for j = 1 to 3 do
99777: LD_ADDR_VAR 0 3
99781: PUSH
99782: DOUBLE
99783: LD_INT 1
99785: DEC
99786: ST_TO_ADDR
99787: LD_INT 3
99789: PUSH
99790: FOR_TO
99791: IFFALSE 99817
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
99793: LD_VAR 0 2
99797: PPUSH
99798: CALL_OW 274
99802: PPUSH
99803: LD_VAR 0 3
99807: PPUSH
99808: LD_INT 99999
99810: PPUSH
99811: CALL_OW 277
99815: GO 99790
99817: POP
99818: POP
99819: GO 99774
99821: POP
99822: POP
// end ;
99823: LD_VAR 0 1
99827: RET
// export function hHackSetLevel10 ; var i , j ; begin
99828: LD_INT 0
99830: PPUSH
99831: PPUSH
99832: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
99833: LD_ADDR_VAR 0 2
99837: PUSH
99838: LD_INT 21
99840: PUSH
99841: LD_INT 1
99843: PUSH
99844: EMPTY
99845: LIST
99846: LIST
99847: PPUSH
99848: CALL_OW 69
99852: PUSH
99853: FOR_IN
99854: IFFALSE 99906
// if IsSelected ( i ) then
99856: LD_VAR 0 2
99860: PPUSH
99861: CALL_OW 306
99865: IFFALSE 99904
// begin for j := 1 to 4 do
99867: LD_ADDR_VAR 0 3
99871: PUSH
99872: DOUBLE
99873: LD_INT 1
99875: DEC
99876: ST_TO_ADDR
99877: LD_INT 4
99879: PUSH
99880: FOR_TO
99881: IFFALSE 99902
// SetSkill ( i , j , 10 ) ;
99883: LD_VAR 0 2
99887: PPUSH
99888: LD_VAR 0 3
99892: PPUSH
99893: LD_INT 10
99895: PPUSH
99896: CALL_OW 237
99900: GO 99880
99902: POP
99903: POP
// end ;
99904: GO 99853
99906: POP
99907: POP
// end ;
99908: LD_VAR 0 1
99912: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
99913: LD_INT 0
99915: PPUSH
99916: PPUSH
99917: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
99918: LD_ADDR_VAR 0 2
99922: PUSH
99923: LD_INT 22
99925: PUSH
99926: LD_OWVAR 2
99930: PUSH
99931: EMPTY
99932: LIST
99933: LIST
99934: PUSH
99935: LD_INT 21
99937: PUSH
99938: LD_INT 1
99940: PUSH
99941: EMPTY
99942: LIST
99943: LIST
99944: PUSH
99945: EMPTY
99946: LIST
99947: LIST
99948: PPUSH
99949: CALL_OW 69
99953: PUSH
99954: FOR_IN
99955: IFFALSE 99996
// begin for j := 1 to 4 do
99957: LD_ADDR_VAR 0 3
99961: PUSH
99962: DOUBLE
99963: LD_INT 1
99965: DEC
99966: ST_TO_ADDR
99967: LD_INT 4
99969: PUSH
99970: FOR_TO
99971: IFFALSE 99992
// SetSkill ( i , j , 10 ) ;
99973: LD_VAR 0 2
99977: PPUSH
99978: LD_VAR 0 3
99982: PPUSH
99983: LD_INT 10
99985: PPUSH
99986: CALL_OW 237
99990: GO 99970
99992: POP
99993: POP
// end ;
99994: GO 99954
99996: POP
99997: POP
// end ;
99998: LD_VAR 0 1
100002: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
100003: LD_INT 0
100005: PPUSH
// uc_side := your_side ;
100006: LD_ADDR_OWVAR 20
100010: PUSH
100011: LD_OWVAR 2
100015: ST_TO_ADDR
// uc_nation := nation ;
100016: LD_ADDR_OWVAR 21
100020: PUSH
100021: LD_VAR 0 1
100025: ST_TO_ADDR
// InitHc ;
100026: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
100030: LD_INT 0
100032: PPUSH
100033: LD_VAR 0 2
100037: PPUSH
100038: LD_VAR 0 3
100042: PPUSH
100043: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
100047: LD_VAR 0 4
100051: PPUSH
100052: LD_VAR 0 5
100056: PPUSH
100057: CALL_OW 428
100061: PUSH
100062: LD_INT 0
100064: EQUAL
100065: IFFALSE 100089
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
100067: CALL_OW 44
100071: PPUSH
100072: LD_VAR 0 4
100076: PPUSH
100077: LD_VAR 0 5
100081: PPUSH
100082: LD_INT 1
100084: PPUSH
100085: CALL_OW 48
// end ;
100089: LD_VAR 0 6
100093: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
100094: LD_INT 0
100096: PPUSH
100097: PPUSH
// uc_side := your_side ;
100098: LD_ADDR_OWVAR 20
100102: PUSH
100103: LD_OWVAR 2
100107: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
100108: LD_VAR 0 1
100112: PUSH
100113: LD_INT 1
100115: PUSH
100116: LD_INT 2
100118: PUSH
100119: LD_INT 3
100121: PUSH
100122: LD_INT 4
100124: PUSH
100125: LD_INT 5
100127: PUSH
100128: EMPTY
100129: LIST
100130: LIST
100131: LIST
100132: LIST
100133: LIST
100134: IN
100135: IFFALSE 100147
// uc_nation := nation_american else
100137: LD_ADDR_OWVAR 21
100141: PUSH
100142: LD_INT 1
100144: ST_TO_ADDR
100145: GO 100190
// if chassis in [ 11 , 12 , 13 , 14 ] then
100147: LD_VAR 0 1
100151: PUSH
100152: LD_INT 11
100154: PUSH
100155: LD_INT 12
100157: PUSH
100158: LD_INT 13
100160: PUSH
100161: LD_INT 14
100163: PUSH
100164: EMPTY
100165: LIST
100166: LIST
100167: LIST
100168: LIST
100169: IN
100170: IFFALSE 100182
// uc_nation := nation_arabian else
100172: LD_ADDR_OWVAR 21
100176: PUSH
100177: LD_INT 2
100179: ST_TO_ADDR
100180: GO 100190
// uc_nation := nation_russian ;
100182: LD_ADDR_OWVAR 21
100186: PUSH
100187: LD_INT 3
100189: ST_TO_ADDR
// vc_chassis := chassis ;
100190: LD_ADDR_OWVAR 37
100194: PUSH
100195: LD_VAR 0 1
100199: ST_TO_ADDR
// vc_engine := engine ;
100200: LD_ADDR_OWVAR 39
100204: PUSH
100205: LD_VAR 0 2
100209: ST_TO_ADDR
// vc_control := control ;
100210: LD_ADDR_OWVAR 38
100214: PUSH
100215: LD_VAR 0 3
100219: ST_TO_ADDR
// vc_weapon := weapon ;
100220: LD_ADDR_OWVAR 40
100224: PUSH
100225: LD_VAR 0 4
100229: ST_TO_ADDR
// un := CreateVehicle ;
100230: LD_ADDR_VAR 0 8
100234: PUSH
100235: CALL_OW 45
100239: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
100240: LD_VAR 0 8
100244: PPUSH
100245: LD_INT 0
100247: PPUSH
100248: LD_INT 5
100250: PPUSH
100251: CALL_OW 12
100255: PPUSH
100256: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
100260: LD_VAR 0 8
100264: PPUSH
100265: LD_VAR 0 5
100269: PPUSH
100270: LD_VAR 0 6
100274: PPUSH
100275: LD_INT 1
100277: PPUSH
100278: CALL_OW 48
// end ;
100282: LD_VAR 0 7
100286: RET
// export hInvincible ; every 1 do
100287: GO 100289
100289: DISABLE
// hInvincible := [ ] ;
100290: LD_ADDR_EXP 187
100294: PUSH
100295: EMPTY
100296: ST_TO_ADDR
100297: END
// every 10 do var i ;
100298: GO 100300
100300: DISABLE
100301: LD_INT 0
100303: PPUSH
// begin enable ;
100304: ENABLE
// if not hInvincible then
100305: LD_EXP 187
100309: NOT
100310: IFFALSE 100314
// exit ;
100312: GO 100358
// for i in hInvincible do
100314: LD_ADDR_VAR 0 1
100318: PUSH
100319: LD_EXP 187
100323: PUSH
100324: FOR_IN
100325: IFFALSE 100356
// if GetLives ( i ) < 1000 then
100327: LD_VAR 0 1
100331: PPUSH
100332: CALL_OW 256
100336: PUSH
100337: LD_INT 1000
100339: LESS
100340: IFFALSE 100354
// SetLives ( i , 1000 ) ;
100342: LD_VAR 0 1
100346: PPUSH
100347: LD_INT 1000
100349: PPUSH
100350: CALL_OW 234
100354: GO 100324
100356: POP
100357: POP
// end ;
100358: PPOPN 1
100360: END
// export function hHackInvincible ; var i ; begin
100361: LD_INT 0
100363: PPUSH
100364: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
100365: LD_ADDR_VAR 0 2
100369: PUSH
100370: LD_INT 2
100372: PUSH
100373: LD_INT 21
100375: PUSH
100376: LD_INT 1
100378: PUSH
100379: EMPTY
100380: LIST
100381: LIST
100382: PUSH
100383: LD_INT 21
100385: PUSH
100386: LD_INT 2
100388: PUSH
100389: EMPTY
100390: LIST
100391: LIST
100392: PUSH
100393: EMPTY
100394: LIST
100395: LIST
100396: LIST
100397: PPUSH
100398: CALL_OW 69
100402: PUSH
100403: FOR_IN
100404: IFFALSE 100465
// if IsSelected ( i ) then
100406: LD_VAR 0 2
100410: PPUSH
100411: CALL_OW 306
100415: IFFALSE 100463
// begin if i in hInvincible then
100417: LD_VAR 0 2
100421: PUSH
100422: LD_EXP 187
100426: IN
100427: IFFALSE 100447
// hInvincible := hInvincible diff i else
100429: LD_ADDR_EXP 187
100433: PUSH
100434: LD_EXP 187
100438: PUSH
100439: LD_VAR 0 2
100443: DIFF
100444: ST_TO_ADDR
100445: GO 100463
// hInvincible := hInvincible union i ;
100447: LD_ADDR_EXP 187
100451: PUSH
100452: LD_EXP 187
100456: PUSH
100457: LD_VAR 0 2
100461: UNION
100462: ST_TO_ADDR
// end ;
100463: GO 100403
100465: POP
100466: POP
// end ;
100467: LD_VAR 0 1
100471: RET
// export function hHackInvisible ; var i , j ; begin
100472: LD_INT 0
100474: PPUSH
100475: PPUSH
100476: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
100477: LD_ADDR_VAR 0 2
100481: PUSH
100482: LD_INT 21
100484: PUSH
100485: LD_INT 1
100487: PUSH
100488: EMPTY
100489: LIST
100490: LIST
100491: PPUSH
100492: CALL_OW 69
100496: PUSH
100497: FOR_IN
100498: IFFALSE 100522
// if IsSelected ( i ) then
100500: LD_VAR 0 2
100504: PPUSH
100505: CALL_OW 306
100509: IFFALSE 100520
// ComForceInvisible ( i ) ;
100511: LD_VAR 0 2
100515: PPUSH
100516: CALL_OW 496
100520: GO 100497
100522: POP
100523: POP
// end ;
100524: LD_VAR 0 1
100528: RET
// export function hHackChangeYourSide ; begin
100529: LD_INT 0
100531: PPUSH
// if your_side = 8 then
100532: LD_OWVAR 2
100536: PUSH
100537: LD_INT 8
100539: EQUAL
100540: IFFALSE 100552
// your_side := 0 else
100542: LD_ADDR_OWVAR 2
100546: PUSH
100547: LD_INT 0
100549: ST_TO_ADDR
100550: GO 100566
// your_side := your_side + 1 ;
100552: LD_ADDR_OWVAR 2
100556: PUSH
100557: LD_OWVAR 2
100561: PUSH
100562: LD_INT 1
100564: PLUS
100565: ST_TO_ADDR
// end ;
100566: LD_VAR 0 1
100570: RET
// export function hHackChangeUnitSide ; var i , j ; begin
100571: LD_INT 0
100573: PPUSH
100574: PPUSH
100575: PPUSH
// for i in all_units do
100576: LD_ADDR_VAR 0 2
100580: PUSH
100581: LD_OWVAR 3
100585: PUSH
100586: FOR_IN
100587: IFFALSE 100665
// if IsSelected ( i ) then
100589: LD_VAR 0 2
100593: PPUSH
100594: CALL_OW 306
100598: IFFALSE 100663
// begin j := GetSide ( i ) ;
100600: LD_ADDR_VAR 0 3
100604: PUSH
100605: LD_VAR 0 2
100609: PPUSH
100610: CALL_OW 255
100614: ST_TO_ADDR
// if j = 8 then
100615: LD_VAR 0 3
100619: PUSH
100620: LD_INT 8
100622: EQUAL
100623: IFFALSE 100635
// j := 0 else
100625: LD_ADDR_VAR 0 3
100629: PUSH
100630: LD_INT 0
100632: ST_TO_ADDR
100633: GO 100649
// j := j + 1 ;
100635: LD_ADDR_VAR 0 3
100639: PUSH
100640: LD_VAR 0 3
100644: PUSH
100645: LD_INT 1
100647: PLUS
100648: ST_TO_ADDR
// SetSide ( i , j ) ;
100649: LD_VAR 0 2
100653: PPUSH
100654: LD_VAR 0 3
100658: PPUSH
100659: CALL_OW 235
// end ;
100663: GO 100586
100665: POP
100666: POP
// end ;
100667: LD_VAR 0 1
100671: RET
// export function hHackFog ; begin
100672: LD_INT 0
100674: PPUSH
// FogOff ( true ) ;
100675: LD_INT 1
100677: PPUSH
100678: CALL_OW 344
// end ;
100682: LD_VAR 0 1
100686: RET
// export function hHackTeleport ( unit , x , y ) ; begin
100687: LD_INT 0
100689: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
100690: LD_VAR 0 1
100694: PPUSH
100695: LD_VAR 0 2
100699: PPUSH
100700: LD_VAR 0 3
100704: PPUSH
100705: LD_INT 1
100707: PPUSH
100708: LD_INT 1
100710: PPUSH
100711: CALL_OW 483
// CenterOnXY ( x , y ) ;
100715: LD_VAR 0 2
100719: PPUSH
100720: LD_VAR 0 3
100724: PPUSH
100725: CALL_OW 84
// end ; end_of_file
100729: LD_VAR 0 4
100733: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
100734: LD_INT 0
100736: PPUSH
100737: PPUSH
100738: PPUSH
100739: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
100740: LD_VAR 0 1
100744: PPUSH
100745: CALL_OW 264
100749: PUSH
100750: LD_EXP 76
100754: EQUAL
100755: IFFALSE 100827
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
100757: LD_INT 68
100759: PPUSH
100760: LD_VAR 0 1
100764: PPUSH
100765: CALL_OW 255
100769: PPUSH
100770: CALL_OW 321
100774: PUSH
100775: LD_INT 2
100777: EQUAL
100778: IFFALSE 100790
// eff := 70 else
100780: LD_ADDR_VAR 0 4
100784: PUSH
100785: LD_INT 70
100787: ST_TO_ADDR
100788: GO 100798
// eff := 30 ;
100790: LD_ADDR_VAR 0 4
100794: PUSH
100795: LD_INT 30
100797: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
100798: LD_VAR 0 1
100802: PPUSH
100803: CALL_OW 250
100807: PPUSH
100808: LD_VAR 0 1
100812: PPUSH
100813: CALL_OW 251
100817: PPUSH
100818: LD_VAR 0 4
100822: PPUSH
100823: CALL_OW 495
// end ; end ;
100827: LD_VAR 0 2
100831: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
100832: LD_INT 0
100834: PPUSH
// end ;
100835: LD_VAR 0 4
100839: RET
// export function SOS_Command ( cmd ) ; begin
100840: LD_INT 0
100842: PPUSH
// end ;
100843: LD_VAR 0 2
100847: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
100848: LD_INT 0
100850: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
100851: LD_VAR 0 1
100855: PUSH
100856: LD_INT 250
100858: EQUAL
100859: PUSH
100860: LD_VAR 0 2
100864: PPUSH
100865: CALL_OW 264
100869: PUSH
100870: LD_EXP 79
100874: EQUAL
100875: AND
100876: IFFALSE 100897
// MinerPlaceMine ( unit , x , y ) ;
100878: LD_VAR 0 2
100882: PPUSH
100883: LD_VAR 0 4
100887: PPUSH
100888: LD_VAR 0 5
100892: PPUSH
100893: CALL 103238 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
100897: LD_VAR 0 1
100901: PUSH
100902: LD_INT 251
100904: EQUAL
100905: PUSH
100906: LD_VAR 0 2
100910: PPUSH
100911: CALL_OW 264
100915: PUSH
100916: LD_EXP 79
100920: EQUAL
100921: AND
100922: IFFALSE 100943
// MinerDetonateMine ( unit , x , y ) ;
100924: LD_VAR 0 2
100928: PPUSH
100929: LD_VAR 0 4
100933: PPUSH
100934: LD_VAR 0 5
100938: PPUSH
100939: CALL 103515 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
100943: LD_VAR 0 1
100947: PUSH
100948: LD_INT 252
100950: EQUAL
100951: PUSH
100952: LD_VAR 0 2
100956: PPUSH
100957: CALL_OW 264
100961: PUSH
100962: LD_EXP 79
100966: EQUAL
100967: AND
100968: IFFALSE 100989
// MinerCreateMinefield ( unit , x , y ) ;
100970: LD_VAR 0 2
100974: PPUSH
100975: LD_VAR 0 4
100979: PPUSH
100980: LD_VAR 0 5
100984: PPUSH
100985: CALL 103932 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
100989: LD_VAR 0 1
100993: PUSH
100994: LD_INT 253
100996: EQUAL
100997: PUSH
100998: LD_VAR 0 2
101002: PPUSH
101003: CALL_OW 257
101007: PUSH
101008: LD_INT 5
101010: EQUAL
101011: AND
101012: IFFALSE 101033
// ComBinocular ( unit , x , y ) ;
101014: LD_VAR 0 2
101018: PPUSH
101019: LD_VAR 0 4
101023: PPUSH
101024: LD_VAR 0 5
101028: PPUSH
101029: CALL 104303 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
101033: LD_VAR 0 1
101037: PUSH
101038: LD_INT 254
101040: EQUAL
101041: PUSH
101042: LD_VAR 0 2
101046: PPUSH
101047: CALL_OW 264
101051: PUSH
101052: LD_EXP 74
101056: EQUAL
101057: AND
101058: PUSH
101059: LD_VAR 0 3
101063: PPUSH
101064: CALL_OW 263
101068: PUSH
101069: LD_INT 3
101071: EQUAL
101072: AND
101073: IFFALSE 101089
// HackDestroyVehicle ( unit , selectedUnit ) ;
101075: LD_VAR 0 2
101079: PPUSH
101080: LD_VAR 0 3
101084: PPUSH
101085: CALL 102598 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
101089: LD_VAR 0 1
101093: PUSH
101094: LD_INT 255
101096: EQUAL
101097: PUSH
101098: LD_VAR 0 2
101102: PPUSH
101103: CALL_OW 264
101107: PUSH
101108: LD_INT 14
101110: PUSH
101111: LD_INT 53
101113: PUSH
101114: EMPTY
101115: LIST
101116: LIST
101117: IN
101118: AND
101119: PUSH
101120: LD_VAR 0 4
101124: PPUSH
101125: LD_VAR 0 5
101129: PPUSH
101130: CALL_OW 488
101134: AND
101135: IFFALSE 101159
// CutTreeXYR ( unit , x , y , 12 ) ;
101137: LD_VAR 0 2
101141: PPUSH
101142: LD_VAR 0 4
101146: PPUSH
101147: LD_VAR 0 5
101151: PPUSH
101152: LD_INT 12
101154: PPUSH
101155: CALL 101164 0 4
// end ;
101159: LD_VAR 0 6
101163: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
101164: LD_INT 0
101166: PPUSH
101167: PPUSH
101168: PPUSH
101169: PPUSH
101170: PPUSH
101171: PPUSH
101172: PPUSH
101173: PPUSH
101174: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
101175: LD_VAR 0 1
101179: NOT
101180: PUSH
101181: LD_VAR 0 2
101185: PPUSH
101186: LD_VAR 0 3
101190: PPUSH
101191: CALL_OW 488
101195: NOT
101196: OR
101197: PUSH
101198: LD_VAR 0 4
101202: NOT
101203: OR
101204: IFFALSE 101208
// exit ;
101206: GO 101548
// list := [ ] ;
101208: LD_ADDR_VAR 0 13
101212: PUSH
101213: EMPTY
101214: ST_TO_ADDR
// if x - r < 0 then
101215: LD_VAR 0 2
101219: PUSH
101220: LD_VAR 0 4
101224: MINUS
101225: PUSH
101226: LD_INT 0
101228: LESS
101229: IFFALSE 101241
// min_x := 0 else
101231: LD_ADDR_VAR 0 7
101235: PUSH
101236: LD_INT 0
101238: ST_TO_ADDR
101239: GO 101257
// min_x := x - r ;
101241: LD_ADDR_VAR 0 7
101245: PUSH
101246: LD_VAR 0 2
101250: PUSH
101251: LD_VAR 0 4
101255: MINUS
101256: ST_TO_ADDR
// if y - r < 0 then
101257: LD_VAR 0 3
101261: PUSH
101262: LD_VAR 0 4
101266: MINUS
101267: PUSH
101268: LD_INT 0
101270: LESS
101271: IFFALSE 101283
// min_y := 0 else
101273: LD_ADDR_VAR 0 8
101277: PUSH
101278: LD_INT 0
101280: ST_TO_ADDR
101281: GO 101299
// min_y := y - r ;
101283: LD_ADDR_VAR 0 8
101287: PUSH
101288: LD_VAR 0 3
101292: PUSH
101293: LD_VAR 0 4
101297: MINUS
101298: ST_TO_ADDR
// max_x := x + r ;
101299: LD_ADDR_VAR 0 9
101303: PUSH
101304: LD_VAR 0 2
101308: PUSH
101309: LD_VAR 0 4
101313: PLUS
101314: ST_TO_ADDR
// max_y := y + r ;
101315: LD_ADDR_VAR 0 10
101319: PUSH
101320: LD_VAR 0 3
101324: PUSH
101325: LD_VAR 0 4
101329: PLUS
101330: ST_TO_ADDR
// for _x = min_x to max_x do
101331: LD_ADDR_VAR 0 11
101335: PUSH
101336: DOUBLE
101337: LD_VAR 0 7
101341: DEC
101342: ST_TO_ADDR
101343: LD_VAR 0 9
101347: PUSH
101348: FOR_TO
101349: IFFALSE 101466
// for _y = min_y to max_y do
101351: LD_ADDR_VAR 0 12
101355: PUSH
101356: DOUBLE
101357: LD_VAR 0 8
101361: DEC
101362: ST_TO_ADDR
101363: LD_VAR 0 10
101367: PUSH
101368: FOR_TO
101369: IFFALSE 101462
// begin if not ValidHex ( _x , _y ) then
101371: LD_VAR 0 11
101375: PPUSH
101376: LD_VAR 0 12
101380: PPUSH
101381: CALL_OW 488
101385: NOT
101386: IFFALSE 101390
// continue ;
101388: GO 101368
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
101390: LD_VAR 0 11
101394: PPUSH
101395: LD_VAR 0 12
101399: PPUSH
101400: CALL_OW 351
101404: PUSH
101405: LD_VAR 0 11
101409: PPUSH
101410: LD_VAR 0 12
101414: PPUSH
101415: CALL_OW 554
101419: AND
101420: IFFALSE 101460
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
101422: LD_ADDR_VAR 0 13
101426: PUSH
101427: LD_VAR 0 13
101431: PPUSH
101432: LD_VAR 0 13
101436: PUSH
101437: LD_INT 1
101439: PLUS
101440: PPUSH
101441: LD_VAR 0 11
101445: PUSH
101446: LD_VAR 0 12
101450: PUSH
101451: EMPTY
101452: LIST
101453: LIST
101454: PPUSH
101455: CALL_OW 2
101459: ST_TO_ADDR
// end ;
101460: GO 101368
101462: POP
101463: POP
101464: GO 101348
101466: POP
101467: POP
// if not list then
101468: LD_VAR 0 13
101472: NOT
101473: IFFALSE 101477
// exit ;
101475: GO 101548
// for i in list do
101477: LD_ADDR_VAR 0 6
101481: PUSH
101482: LD_VAR 0 13
101486: PUSH
101487: FOR_IN
101488: IFFALSE 101546
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
101490: LD_VAR 0 1
101494: PPUSH
101495: LD_STRING M
101497: PUSH
101498: LD_VAR 0 6
101502: PUSH
101503: LD_INT 1
101505: ARRAY
101506: PUSH
101507: LD_VAR 0 6
101511: PUSH
101512: LD_INT 2
101514: ARRAY
101515: PUSH
101516: LD_INT 0
101518: PUSH
101519: LD_INT 0
101521: PUSH
101522: LD_INT 0
101524: PUSH
101525: LD_INT 0
101527: PUSH
101528: EMPTY
101529: LIST
101530: LIST
101531: LIST
101532: LIST
101533: LIST
101534: LIST
101535: LIST
101536: PUSH
101537: EMPTY
101538: LIST
101539: PPUSH
101540: CALL_OW 447
101544: GO 101487
101546: POP
101547: POP
// end ;
101548: LD_VAR 0 5
101552: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
101553: LD_EXP 188
101557: NOT
101558: IFFALSE 101608
101560: GO 101562
101562: DISABLE
// begin initHack := true ;
101563: LD_ADDR_EXP 188
101567: PUSH
101568: LD_INT 1
101570: ST_TO_ADDR
// hackTanks := [ ] ;
101571: LD_ADDR_EXP 189
101575: PUSH
101576: EMPTY
101577: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
101578: LD_ADDR_EXP 190
101582: PUSH
101583: EMPTY
101584: ST_TO_ADDR
// hackLimit := 3 ;
101585: LD_ADDR_EXP 191
101589: PUSH
101590: LD_INT 3
101592: ST_TO_ADDR
// hackDist := 12 ;
101593: LD_ADDR_EXP 192
101597: PUSH
101598: LD_INT 12
101600: ST_TO_ADDR
// hackCounter := [ ] ;
101601: LD_ADDR_EXP 193
101605: PUSH
101606: EMPTY
101607: ST_TO_ADDR
// end ;
101608: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
101609: LD_EXP 188
101613: PUSH
101614: LD_INT 34
101616: PUSH
101617: LD_EXP 74
101621: PUSH
101622: EMPTY
101623: LIST
101624: LIST
101625: PPUSH
101626: CALL_OW 69
101630: AND
101631: IFFALSE 101886
101633: GO 101635
101635: DISABLE
101636: LD_INT 0
101638: PPUSH
101639: PPUSH
// begin enable ;
101640: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
101641: LD_ADDR_VAR 0 1
101645: PUSH
101646: LD_INT 34
101648: PUSH
101649: LD_EXP 74
101653: PUSH
101654: EMPTY
101655: LIST
101656: LIST
101657: PPUSH
101658: CALL_OW 69
101662: PUSH
101663: FOR_IN
101664: IFFALSE 101884
// begin if not i in hackTanks then
101666: LD_VAR 0 1
101670: PUSH
101671: LD_EXP 189
101675: IN
101676: NOT
101677: IFFALSE 101760
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
101679: LD_ADDR_EXP 189
101683: PUSH
101684: LD_EXP 189
101688: PPUSH
101689: LD_EXP 189
101693: PUSH
101694: LD_INT 1
101696: PLUS
101697: PPUSH
101698: LD_VAR 0 1
101702: PPUSH
101703: CALL_OW 1
101707: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
101708: LD_ADDR_EXP 190
101712: PUSH
101713: LD_EXP 190
101717: PPUSH
101718: LD_EXP 190
101722: PUSH
101723: LD_INT 1
101725: PLUS
101726: PPUSH
101727: EMPTY
101728: PPUSH
101729: CALL_OW 1
101733: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
101734: LD_ADDR_EXP 193
101738: PUSH
101739: LD_EXP 193
101743: PPUSH
101744: LD_EXP 193
101748: PUSH
101749: LD_INT 1
101751: PLUS
101752: PPUSH
101753: EMPTY
101754: PPUSH
101755: CALL_OW 1
101759: ST_TO_ADDR
// end ; if not IsOk ( i ) then
101760: LD_VAR 0 1
101764: PPUSH
101765: CALL_OW 302
101769: NOT
101770: IFFALSE 101783
// begin HackUnlinkAll ( i ) ;
101772: LD_VAR 0 1
101776: PPUSH
101777: CALL 101889 0 1
// continue ;
101781: GO 101663
// end ; HackCheckCapturedStatus ( i ) ;
101783: LD_VAR 0 1
101787: PPUSH
101788: CALL 102332 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
101792: LD_ADDR_VAR 0 2
101796: PUSH
101797: LD_INT 81
101799: PUSH
101800: LD_VAR 0 1
101804: PPUSH
101805: CALL_OW 255
101809: PUSH
101810: EMPTY
101811: LIST
101812: LIST
101813: PUSH
101814: LD_INT 33
101816: PUSH
101817: LD_INT 3
101819: PUSH
101820: EMPTY
101821: LIST
101822: LIST
101823: PUSH
101824: LD_INT 91
101826: PUSH
101827: LD_VAR 0 1
101831: PUSH
101832: LD_EXP 192
101836: PUSH
101837: EMPTY
101838: LIST
101839: LIST
101840: LIST
101841: PUSH
101842: LD_INT 50
101844: PUSH
101845: EMPTY
101846: LIST
101847: PUSH
101848: EMPTY
101849: LIST
101850: LIST
101851: LIST
101852: LIST
101853: PPUSH
101854: CALL_OW 69
101858: ST_TO_ADDR
// if not tmp then
101859: LD_VAR 0 2
101863: NOT
101864: IFFALSE 101868
// continue ;
101866: GO 101663
// HackLink ( i , tmp ) ;
101868: LD_VAR 0 1
101872: PPUSH
101873: LD_VAR 0 2
101877: PPUSH
101878: CALL 102025 0 2
// end ;
101882: GO 101663
101884: POP
101885: POP
// end ;
101886: PPOPN 2
101888: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
101889: LD_INT 0
101891: PPUSH
101892: PPUSH
101893: PPUSH
// if not hack in hackTanks then
101894: LD_VAR 0 1
101898: PUSH
101899: LD_EXP 189
101903: IN
101904: NOT
101905: IFFALSE 101909
// exit ;
101907: GO 102020
// index := GetElementIndex ( hackTanks , hack ) ;
101909: LD_ADDR_VAR 0 4
101913: PUSH
101914: LD_EXP 189
101918: PPUSH
101919: LD_VAR 0 1
101923: PPUSH
101924: CALL 55486 0 2
101928: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
101929: LD_EXP 190
101933: PUSH
101934: LD_VAR 0 4
101938: ARRAY
101939: IFFALSE 102020
// begin for i in hackTanksCaptured [ index ] do
101941: LD_ADDR_VAR 0 3
101945: PUSH
101946: LD_EXP 190
101950: PUSH
101951: LD_VAR 0 4
101955: ARRAY
101956: PUSH
101957: FOR_IN
101958: IFFALSE 101984
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
101960: LD_VAR 0 3
101964: PUSH
101965: LD_INT 1
101967: ARRAY
101968: PPUSH
101969: LD_VAR 0 3
101973: PUSH
101974: LD_INT 2
101976: ARRAY
101977: PPUSH
101978: CALL_OW 235
101982: GO 101957
101984: POP
101985: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
101986: LD_ADDR_EXP 190
101990: PUSH
101991: LD_EXP 190
101995: PPUSH
101996: LD_VAR 0 4
102000: PPUSH
102001: EMPTY
102002: PPUSH
102003: CALL_OW 1
102007: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
102008: LD_VAR 0 1
102012: PPUSH
102013: LD_INT 0
102015: PPUSH
102016: CALL_OW 505
// end ; end ;
102020: LD_VAR 0 2
102024: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
102025: LD_INT 0
102027: PPUSH
102028: PPUSH
102029: PPUSH
// if not hack in hackTanks or not vehicles then
102030: LD_VAR 0 1
102034: PUSH
102035: LD_EXP 189
102039: IN
102040: NOT
102041: PUSH
102042: LD_VAR 0 2
102046: NOT
102047: OR
102048: IFFALSE 102052
// exit ;
102050: GO 102327
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
102052: LD_ADDR_VAR 0 2
102056: PUSH
102057: LD_VAR 0 1
102061: PPUSH
102062: LD_VAR 0 2
102066: PPUSH
102067: LD_INT 1
102069: PPUSH
102070: LD_INT 1
102072: PPUSH
102073: CALL 56136 0 4
102077: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
102078: LD_ADDR_VAR 0 5
102082: PUSH
102083: LD_EXP 189
102087: PPUSH
102088: LD_VAR 0 1
102092: PPUSH
102093: CALL 55486 0 2
102097: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
102098: LD_EXP 190
102102: PUSH
102103: LD_VAR 0 5
102107: ARRAY
102108: PUSH
102109: LD_EXP 191
102113: LESS
102114: IFFALSE 102303
// begin for i := 1 to vehicles do
102116: LD_ADDR_VAR 0 4
102120: PUSH
102121: DOUBLE
102122: LD_INT 1
102124: DEC
102125: ST_TO_ADDR
102126: LD_VAR 0 2
102130: PUSH
102131: FOR_TO
102132: IFFALSE 102301
// begin if hackTanksCaptured [ index ] = hackLimit then
102134: LD_EXP 190
102138: PUSH
102139: LD_VAR 0 5
102143: ARRAY
102144: PUSH
102145: LD_EXP 191
102149: EQUAL
102150: IFFALSE 102154
// break ;
102152: GO 102301
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
102154: LD_ADDR_EXP 193
102158: PUSH
102159: LD_EXP 193
102163: PPUSH
102164: LD_VAR 0 5
102168: PPUSH
102169: LD_EXP 193
102173: PUSH
102174: LD_VAR 0 5
102178: ARRAY
102179: PUSH
102180: LD_INT 1
102182: PLUS
102183: PPUSH
102184: CALL_OW 1
102188: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
102189: LD_ADDR_EXP 190
102193: PUSH
102194: LD_EXP 190
102198: PPUSH
102199: LD_VAR 0 5
102203: PUSH
102204: LD_EXP 190
102208: PUSH
102209: LD_VAR 0 5
102213: ARRAY
102214: PUSH
102215: LD_INT 1
102217: PLUS
102218: PUSH
102219: EMPTY
102220: LIST
102221: LIST
102222: PPUSH
102223: LD_VAR 0 2
102227: PUSH
102228: LD_VAR 0 4
102232: ARRAY
102233: PUSH
102234: LD_VAR 0 2
102238: PUSH
102239: LD_VAR 0 4
102243: ARRAY
102244: PPUSH
102245: CALL_OW 255
102249: PUSH
102250: EMPTY
102251: LIST
102252: LIST
102253: PPUSH
102254: CALL 55701 0 3
102258: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
102259: LD_VAR 0 2
102263: PUSH
102264: LD_VAR 0 4
102268: ARRAY
102269: PPUSH
102270: LD_VAR 0 1
102274: PPUSH
102275: CALL_OW 255
102279: PPUSH
102280: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
102284: LD_VAR 0 2
102288: PUSH
102289: LD_VAR 0 4
102293: ARRAY
102294: PPUSH
102295: CALL_OW 141
// end ;
102299: GO 102131
102301: POP
102302: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
102303: LD_VAR 0 1
102307: PPUSH
102308: LD_EXP 190
102312: PUSH
102313: LD_VAR 0 5
102317: ARRAY
102318: PUSH
102319: LD_INT 0
102321: PLUS
102322: PPUSH
102323: CALL_OW 505
// end ;
102327: LD_VAR 0 3
102331: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
102332: LD_INT 0
102334: PPUSH
102335: PPUSH
102336: PPUSH
102337: PPUSH
// if not hack in hackTanks then
102338: LD_VAR 0 1
102342: PUSH
102343: LD_EXP 189
102347: IN
102348: NOT
102349: IFFALSE 102353
// exit ;
102351: GO 102593
// index := GetElementIndex ( hackTanks , hack ) ;
102353: LD_ADDR_VAR 0 4
102357: PUSH
102358: LD_EXP 189
102362: PPUSH
102363: LD_VAR 0 1
102367: PPUSH
102368: CALL 55486 0 2
102372: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
102373: LD_ADDR_VAR 0 3
102377: PUSH
102378: DOUBLE
102379: LD_EXP 190
102383: PUSH
102384: LD_VAR 0 4
102388: ARRAY
102389: INC
102390: ST_TO_ADDR
102391: LD_INT 1
102393: PUSH
102394: FOR_DOWNTO
102395: IFFALSE 102567
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
102397: LD_ADDR_VAR 0 5
102401: PUSH
102402: LD_EXP 190
102406: PUSH
102407: LD_VAR 0 4
102411: ARRAY
102412: PUSH
102413: LD_VAR 0 3
102417: ARRAY
102418: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
102419: LD_VAR 0 5
102423: PUSH
102424: LD_INT 1
102426: ARRAY
102427: PPUSH
102428: CALL_OW 302
102432: NOT
102433: PUSH
102434: LD_VAR 0 5
102438: PUSH
102439: LD_INT 1
102441: ARRAY
102442: PPUSH
102443: CALL_OW 255
102447: PUSH
102448: LD_VAR 0 1
102452: PPUSH
102453: CALL_OW 255
102457: NONEQUAL
102458: OR
102459: IFFALSE 102565
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
102461: LD_VAR 0 5
102465: PUSH
102466: LD_INT 1
102468: ARRAY
102469: PPUSH
102470: CALL_OW 305
102474: PUSH
102475: LD_VAR 0 5
102479: PUSH
102480: LD_INT 1
102482: ARRAY
102483: PPUSH
102484: CALL_OW 255
102488: PUSH
102489: LD_VAR 0 1
102493: PPUSH
102494: CALL_OW 255
102498: EQUAL
102499: AND
102500: IFFALSE 102524
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
102502: LD_VAR 0 5
102506: PUSH
102507: LD_INT 1
102509: ARRAY
102510: PPUSH
102511: LD_VAR 0 5
102515: PUSH
102516: LD_INT 2
102518: ARRAY
102519: PPUSH
102520: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
102524: LD_ADDR_EXP 190
102528: PUSH
102529: LD_EXP 190
102533: PPUSH
102534: LD_VAR 0 4
102538: PPUSH
102539: LD_EXP 190
102543: PUSH
102544: LD_VAR 0 4
102548: ARRAY
102549: PPUSH
102550: LD_VAR 0 3
102554: PPUSH
102555: CALL_OW 3
102559: PPUSH
102560: CALL_OW 1
102564: ST_TO_ADDR
// end ; end ;
102565: GO 102394
102567: POP
102568: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
102569: LD_VAR 0 1
102573: PPUSH
102574: LD_EXP 190
102578: PUSH
102579: LD_VAR 0 4
102583: ARRAY
102584: PUSH
102585: LD_INT 0
102587: PLUS
102588: PPUSH
102589: CALL_OW 505
// end ;
102593: LD_VAR 0 2
102597: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
102598: LD_INT 0
102600: PPUSH
102601: PPUSH
102602: PPUSH
102603: PPUSH
// if not hack in hackTanks then
102604: LD_VAR 0 1
102608: PUSH
102609: LD_EXP 189
102613: IN
102614: NOT
102615: IFFALSE 102619
// exit ;
102617: GO 102704
// index := GetElementIndex ( hackTanks , hack ) ;
102619: LD_ADDR_VAR 0 5
102623: PUSH
102624: LD_EXP 189
102628: PPUSH
102629: LD_VAR 0 1
102633: PPUSH
102634: CALL 55486 0 2
102638: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
102639: LD_ADDR_VAR 0 4
102643: PUSH
102644: DOUBLE
102645: LD_INT 1
102647: DEC
102648: ST_TO_ADDR
102649: LD_EXP 190
102653: PUSH
102654: LD_VAR 0 5
102658: ARRAY
102659: PUSH
102660: FOR_TO
102661: IFFALSE 102702
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
102663: LD_EXP 190
102667: PUSH
102668: LD_VAR 0 5
102672: ARRAY
102673: PUSH
102674: LD_VAR 0 4
102678: ARRAY
102679: PUSH
102680: LD_INT 1
102682: ARRAY
102683: PUSH
102684: LD_VAR 0 2
102688: EQUAL
102689: IFFALSE 102700
// KillUnit ( vehicle ) ;
102691: LD_VAR 0 2
102695: PPUSH
102696: CALL_OW 66
102700: GO 102660
102702: POP
102703: POP
// end ;
102704: LD_VAR 0 3
102708: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
102709: LD_EXP 194
102713: NOT
102714: IFFALSE 102749
102716: GO 102718
102718: DISABLE
// begin initMiner := true ;
102719: LD_ADDR_EXP 194
102723: PUSH
102724: LD_INT 1
102726: ST_TO_ADDR
// minersList := [ ] ;
102727: LD_ADDR_EXP 195
102731: PUSH
102732: EMPTY
102733: ST_TO_ADDR
// minerMinesList := [ ] ;
102734: LD_ADDR_EXP 196
102738: PUSH
102739: EMPTY
102740: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
102741: LD_ADDR_EXP 197
102745: PUSH
102746: LD_INT 5
102748: ST_TO_ADDR
// end ;
102749: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
102750: LD_EXP 194
102754: PUSH
102755: LD_INT 34
102757: PUSH
102758: LD_EXP 79
102762: PUSH
102763: EMPTY
102764: LIST
102765: LIST
102766: PPUSH
102767: CALL_OW 69
102771: AND
102772: IFFALSE 103235
102774: GO 102776
102776: DISABLE
102777: LD_INT 0
102779: PPUSH
102780: PPUSH
102781: PPUSH
102782: PPUSH
// begin enable ;
102783: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
102784: LD_ADDR_VAR 0 1
102788: PUSH
102789: LD_INT 34
102791: PUSH
102792: LD_EXP 79
102796: PUSH
102797: EMPTY
102798: LIST
102799: LIST
102800: PPUSH
102801: CALL_OW 69
102805: PUSH
102806: FOR_IN
102807: IFFALSE 102879
// begin if not i in minersList then
102809: LD_VAR 0 1
102813: PUSH
102814: LD_EXP 195
102818: IN
102819: NOT
102820: IFFALSE 102877
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
102822: LD_ADDR_EXP 195
102826: PUSH
102827: LD_EXP 195
102831: PPUSH
102832: LD_EXP 195
102836: PUSH
102837: LD_INT 1
102839: PLUS
102840: PPUSH
102841: LD_VAR 0 1
102845: PPUSH
102846: CALL_OW 1
102850: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
102851: LD_ADDR_EXP 196
102855: PUSH
102856: LD_EXP 196
102860: PPUSH
102861: LD_EXP 196
102865: PUSH
102866: LD_INT 1
102868: PLUS
102869: PPUSH
102870: EMPTY
102871: PPUSH
102872: CALL_OW 1
102876: ST_TO_ADDR
// end end ;
102877: GO 102806
102879: POP
102880: POP
// for i := minerMinesList downto 1 do
102881: LD_ADDR_VAR 0 1
102885: PUSH
102886: DOUBLE
102887: LD_EXP 196
102891: INC
102892: ST_TO_ADDR
102893: LD_INT 1
102895: PUSH
102896: FOR_DOWNTO
102897: IFFALSE 103233
// begin if IsLive ( minersList [ i ] ) then
102899: LD_EXP 195
102903: PUSH
102904: LD_VAR 0 1
102908: ARRAY
102909: PPUSH
102910: CALL_OW 300
102914: IFFALSE 102942
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
102916: LD_EXP 195
102920: PUSH
102921: LD_VAR 0 1
102925: ARRAY
102926: PPUSH
102927: LD_EXP 196
102931: PUSH
102932: LD_VAR 0 1
102936: ARRAY
102937: PPUSH
102938: CALL_OW 505
// if not minerMinesList [ i ] then
102942: LD_EXP 196
102946: PUSH
102947: LD_VAR 0 1
102951: ARRAY
102952: NOT
102953: IFFALSE 102957
// continue ;
102955: GO 102896
// for j := minerMinesList [ i ] downto 1 do
102957: LD_ADDR_VAR 0 2
102961: PUSH
102962: DOUBLE
102963: LD_EXP 196
102967: PUSH
102968: LD_VAR 0 1
102972: ARRAY
102973: INC
102974: ST_TO_ADDR
102975: LD_INT 1
102977: PUSH
102978: FOR_DOWNTO
102979: IFFALSE 103229
// begin side := GetSide ( minersList [ i ] ) ;
102981: LD_ADDR_VAR 0 3
102985: PUSH
102986: LD_EXP 195
102990: PUSH
102991: LD_VAR 0 1
102995: ARRAY
102996: PPUSH
102997: CALL_OW 255
103001: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
103002: LD_ADDR_VAR 0 4
103006: PUSH
103007: LD_EXP 196
103011: PUSH
103012: LD_VAR 0 1
103016: ARRAY
103017: PUSH
103018: LD_VAR 0 2
103022: ARRAY
103023: PUSH
103024: LD_INT 1
103026: ARRAY
103027: PPUSH
103028: LD_EXP 196
103032: PUSH
103033: LD_VAR 0 1
103037: ARRAY
103038: PUSH
103039: LD_VAR 0 2
103043: ARRAY
103044: PUSH
103045: LD_INT 2
103047: ARRAY
103048: PPUSH
103049: CALL_OW 428
103053: ST_TO_ADDR
// if not tmp then
103054: LD_VAR 0 4
103058: NOT
103059: IFFALSE 103063
// continue ;
103061: GO 102978
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
103063: LD_VAR 0 4
103067: PUSH
103068: LD_INT 81
103070: PUSH
103071: LD_VAR 0 3
103075: PUSH
103076: EMPTY
103077: LIST
103078: LIST
103079: PPUSH
103080: CALL_OW 69
103084: IN
103085: PUSH
103086: LD_EXP 196
103090: PUSH
103091: LD_VAR 0 1
103095: ARRAY
103096: PUSH
103097: LD_VAR 0 2
103101: ARRAY
103102: PUSH
103103: LD_INT 1
103105: ARRAY
103106: PPUSH
103107: LD_EXP 196
103111: PUSH
103112: LD_VAR 0 1
103116: ARRAY
103117: PUSH
103118: LD_VAR 0 2
103122: ARRAY
103123: PUSH
103124: LD_INT 2
103126: ARRAY
103127: PPUSH
103128: CALL_OW 458
103132: AND
103133: IFFALSE 103227
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
103135: LD_EXP 196
103139: PUSH
103140: LD_VAR 0 1
103144: ARRAY
103145: PUSH
103146: LD_VAR 0 2
103150: ARRAY
103151: PUSH
103152: LD_INT 1
103154: ARRAY
103155: PPUSH
103156: LD_EXP 196
103160: PUSH
103161: LD_VAR 0 1
103165: ARRAY
103166: PUSH
103167: LD_VAR 0 2
103171: ARRAY
103172: PUSH
103173: LD_INT 2
103175: ARRAY
103176: PPUSH
103177: LD_VAR 0 3
103181: PPUSH
103182: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
103186: LD_ADDR_EXP 196
103190: PUSH
103191: LD_EXP 196
103195: PPUSH
103196: LD_VAR 0 1
103200: PPUSH
103201: LD_EXP 196
103205: PUSH
103206: LD_VAR 0 1
103210: ARRAY
103211: PPUSH
103212: LD_VAR 0 2
103216: PPUSH
103217: CALL_OW 3
103221: PPUSH
103222: CALL_OW 1
103226: ST_TO_ADDR
// end ; end ;
103227: GO 102978
103229: POP
103230: POP
// end ;
103231: GO 102896
103233: POP
103234: POP
// end ;
103235: PPOPN 4
103237: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
103238: LD_INT 0
103240: PPUSH
103241: PPUSH
// result := false ;
103242: LD_ADDR_VAR 0 4
103246: PUSH
103247: LD_INT 0
103249: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
103250: LD_VAR 0 1
103254: PPUSH
103255: CALL_OW 264
103259: PUSH
103260: LD_EXP 79
103264: EQUAL
103265: NOT
103266: IFFALSE 103270
// exit ;
103268: GO 103510
// index := GetElementIndex ( minersList , unit ) ;
103270: LD_ADDR_VAR 0 5
103274: PUSH
103275: LD_EXP 195
103279: PPUSH
103280: LD_VAR 0 1
103284: PPUSH
103285: CALL 55486 0 2
103289: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
103290: LD_EXP 196
103294: PUSH
103295: LD_VAR 0 5
103299: ARRAY
103300: PUSH
103301: LD_EXP 197
103305: GREATEREQUAL
103306: IFFALSE 103310
// exit ;
103308: GO 103510
// ComMoveXY ( unit , x , y ) ;
103310: LD_VAR 0 1
103314: PPUSH
103315: LD_VAR 0 2
103319: PPUSH
103320: LD_VAR 0 3
103324: PPUSH
103325: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
103329: LD_INT 35
103331: PPUSH
103332: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
103336: LD_VAR 0 1
103340: PPUSH
103341: LD_VAR 0 2
103345: PPUSH
103346: LD_VAR 0 3
103350: PPUSH
103351: CALL 85550 0 3
103355: NOT
103356: PUSH
103357: LD_VAR 0 1
103361: PPUSH
103362: CALL_OW 314
103366: AND
103367: IFFALSE 103371
// exit ;
103369: GO 103510
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
103371: LD_VAR 0 2
103375: PPUSH
103376: LD_VAR 0 3
103380: PPUSH
103381: CALL_OW 428
103385: PUSH
103386: LD_VAR 0 1
103390: EQUAL
103391: PUSH
103392: LD_VAR 0 1
103396: PPUSH
103397: CALL_OW 314
103401: NOT
103402: AND
103403: IFFALSE 103329
// PlaySoundXY ( x , y , PlantMine ) ;
103405: LD_VAR 0 2
103409: PPUSH
103410: LD_VAR 0 3
103414: PPUSH
103415: LD_STRING PlantMine
103417: PPUSH
103418: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
103422: LD_VAR 0 2
103426: PPUSH
103427: LD_VAR 0 3
103431: PPUSH
103432: LD_VAR 0 1
103436: PPUSH
103437: CALL_OW 255
103441: PPUSH
103442: LD_INT 0
103444: PPUSH
103445: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
103449: LD_ADDR_EXP 196
103453: PUSH
103454: LD_EXP 196
103458: PPUSH
103459: LD_VAR 0 5
103463: PUSH
103464: LD_EXP 196
103468: PUSH
103469: LD_VAR 0 5
103473: ARRAY
103474: PUSH
103475: LD_INT 1
103477: PLUS
103478: PUSH
103479: EMPTY
103480: LIST
103481: LIST
103482: PPUSH
103483: LD_VAR 0 2
103487: PUSH
103488: LD_VAR 0 3
103492: PUSH
103493: EMPTY
103494: LIST
103495: LIST
103496: PPUSH
103497: CALL 55701 0 3
103501: ST_TO_ADDR
// result := true ;
103502: LD_ADDR_VAR 0 4
103506: PUSH
103507: LD_INT 1
103509: ST_TO_ADDR
// end ;
103510: LD_VAR 0 4
103514: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
103515: LD_INT 0
103517: PPUSH
103518: PPUSH
103519: PPUSH
// if not unit in minersList then
103520: LD_VAR 0 1
103524: PUSH
103525: LD_EXP 195
103529: IN
103530: NOT
103531: IFFALSE 103535
// exit ;
103533: GO 103927
// index := GetElementIndex ( minersList , unit ) ;
103535: LD_ADDR_VAR 0 6
103539: PUSH
103540: LD_EXP 195
103544: PPUSH
103545: LD_VAR 0 1
103549: PPUSH
103550: CALL 55486 0 2
103554: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
103555: LD_ADDR_VAR 0 5
103559: PUSH
103560: DOUBLE
103561: LD_EXP 196
103565: PUSH
103566: LD_VAR 0 6
103570: ARRAY
103571: INC
103572: ST_TO_ADDR
103573: LD_INT 1
103575: PUSH
103576: FOR_DOWNTO
103577: IFFALSE 103738
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
103579: LD_EXP 196
103583: PUSH
103584: LD_VAR 0 6
103588: ARRAY
103589: PUSH
103590: LD_VAR 0 5
103594: ARRAY
103595: PUSH
103596: LD_INT 1
103598: ARRAY
103599: PUSH
103600: LD_VAR 0 2
103604: EQUAL
103605: PUSH
103606: LD_EXP 196
103610: PUSH
103611: LD_VAR 0 6
103615: ARRAY
103616: PUSH
103617: LD_VAR 0 5
103621: ARRAY
103622: PUSH
103623: LD_INT 2
103625: ARRAY
103626: PUSH
103627: LD_VAR 0 3
103631: EQUAL
103632: AND
103633: IFFALSE 103736
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
103635: LD_EXP 196
103639: PUSH
103640: LD_VAR 0 6
103644: ARRAY
103645: PUSH
103646: LD_VAR 0 5
103650: ARRAY
103651: PUSH
103652: LD_INT 1
103654: ARRAY
103655: PPUSH
103656: LD_EXP 196
103660: PUSH
103661: LD_VAR 0 6
103665: ARRAY
103666: PUSH
103667: LD_VAR 0 5
103671: ARRAY
103672: PUSH
103673: LD_INT 2
103675: ARRAY
103676: PPUSH
103677: LD_VAR 0 1
103681: PPUSH
103682: CALL_OW 255
103686: PPUSH
103687: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
103691: LD_ADDR_EXP 196
103695: PUSH
103696: LD_EXP 196
103700: PPUSH
103701: LD_VAR 0 6
103705: PPUSH
103706: LD_EXP 196
103710: PUSH
103711: LD_VAR 0 6
103715: ARRAY
103716: PPUSH
103717: LD_VAR 0 5
103721: PPUSH
103722: CALL_OW 3
103726: PPUSH
103727: CALL_OW 1
103731: ST_TO_ADDR
// exit ;
103732: POP
103733: POP
103734: GO 103927
// end ; end ;
103736: GO 103576
103738: POP
103739: POP
// for i := minerMinesList [ index ] downto 1 do
103740: LD_ADDR_VAR 0 5
103744: PUSH
103745: DOUBLE
103746: LD_EXP 196
103750: PUSH
103751: LD_VAR 0 6
103755: ARRAY
103756: INC
103757: ST_TO_ADDR
103758: LD_INT 1
103760: PUSH
103761: FOR_DOWNTO
103762: IFFALSE 103925
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
103764: LD_EXP 196
103768: PUSH
103769: LD_VAR 0 6
103773: ARRAY
103774: PUSH
103775: LD_VAR 0 5
103779: ARRAY
103780: PUSH
103781: LD_INT 1
103783: ARRAY
103784: PPUSH
103785: LD_EXP 196
103789: PUSH
103790: LD_VAR 0 6
103794: ARRAY
103795: PUSH
103796: LD_VAR 0 5
103800: ARRAY
103801: PUSH
103802: LD_INT 2
103804: ARRAY
103805: PPUSH
103806: LD_VAR 0 2
103810: PPUSH
103811: LD_VAR 0 3
103815: PPUSH
103816: CALL_OW 298
103820: PUSH
103821: LD_INT 6
103823: LESS
103824: IFFALSE 103923
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
103826: LD_EXP 196
103830: PUSH
103831: LD_VAR 0 6
103835: ARRAY
103836: PUSH
103837: LD_VAR 0 5
103841: ARRAY
103842: PUSH
103843: LD_INT 1
103845: ARRAY
103846: PPUSH
103847: LD_EXP 196
103851: PUSH
103852: LD_VAR 0 6
103856: ARRAY
103857: PUSH
103858: LD_VAR 0 5
103862: ARRAY
103863: PUSH
103864: LD_INT 2
103866: ARRAY
103867: PPUSH
103868: LD_VAR 0 1
103872: PPUSH
103873: CALL_OW 255
103877: PPUSH
103878: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
103882: LD_ADDR_EXP 196
103886: PUSH
103887: LD_EXP 196
103891: PPUSH
103892: LD_VAR 0 6
103896: PPUSH
103897: LD_EXP 196
103901: PUSH
103902: LD_VAR 0 6
103906: ARRAY
103907: PPUSH
103908: LD_VAR 0 5
103912: PPUSH
103913: CALL_OW 3
103917: PPUSH
103918: CALL_OW 1
103922: ST_TO_ADDR
// end ; end ;
103923: GO 103761
103925: POP
103926: POP
// end ;
103927: LD_VAR 0 4
103931: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
103932: LD_INT 0
103934: PPUSH
103935: PPUSH
103936: PPUSH
103937: PPUSH
103938: PPUSH
103939: PPUSH
103940: PPUSH
103941: PPUSH
103942: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
103943: LD_VAR 0 1
103947: PPUSH
103948: CALL_OW 264
103952: PUSH
103953: LD_EXP 79
103957: EQUAL
103958: NOT
103959: PUSH
103960: LD_VAR 0 1
103964: PUSH
103965: LD_EXP 195
103969: IN
103970: NOT
103971: OR
103972: IFFALSE 103976
// exit ;
103974: GO 104298
// index := GetElementIndex ( minersList , unit ) ;
103976: LD_ADDR_VAR 0 6
103980: PUSH
103981: LD_EXP 195
103985: PPUSH
103986: LD_VAR 0 1
103990: PPUSH
103991: CALL 55486 0 2
103995: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
103996: LD_ADDR_VAR 0 8
104000: PUSH
104001: LD_EXP 197
104005: PUSH
104006: LD_EXP 196
104010: PUSH
104011: LD_VAR 0 6
104015: ARRAY
104016: MINUS
104017: ST_TO_ADDR
// if not minesFreeAmount then
104018: LD_VAR 0 8
104022: NOT
104023: IFFALSE 104027
// exit ;
104025: GO 104298
// tmp := [ ] ;
104027: LD_ADDR_VAR 0 7
104031: PUSH
104032: EMPTY
104033: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
104034: LD_ADDR_VAR 0 5
104038: PUSH
104039: DOUBLE
104040: LD_INT 1
104042: DEC
104043: ST_TO_ADDR
104044: LD_VAR 0 8
104048: PUSH
104049: FOR_TO
104050: IFFALSE 104245
// begin _d := rand ( 0 , 5 ) ;
104052: LD_ADDR_VAR 0 11
104056: PUSH
104057: LD_INT 0
104059: PPUSH
104060: LD_INT 5
104062: PPUSH
104063: CALL_OW 12
104067: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
104068: LD_ADDR_VAR 0 12
104072: PUSH
104073: LD_INT 2
104075: PPUSH
104076: LD_INT 6
104078: PPUSH
104079: CALL_OW 12
104083: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
104084: LD_ADDR_VAR 0 9
104088: PUSH
104089: LD_VAR 0 2
104093: PPUSH
104094: LD_VAR 0 11
104098: PPUSH
104099: LD_VAR 0 12
104103: PPUSH
104104: CALL_OW 272
104108: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
104109: LD_ADDR_VAR 0 10
104113: PUSH
104114: LD_VAR 0 3
104118: PPUSH
104119: LD_VAR 0 11
104123: PPUSH
104124: LD_VAR 0 12
104128: PPUSH
104129: CALL_OW 273
104133: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
104134: LD_VAR 0 9
104138: PPUSH
104139: LD_VAR 0 10
104143: PPUSH
104144: CALL_OW 488
104148: PUSH
104149: LD_VAR 0 9
104153: PUSH
104154: LD_VAR 0 10
104158: PUSH
104159: EMPTY
104160: LIST
104161: LIST
104162: PUSH
104163: LD_VAR 0 7
104167: IN
104168: NOT
104169: AND
104170: PUSH
104171: LD_VAR 0 9
104175: PPUSH
104176: LD_VAR 0 10
104180: PPUSH
104181: CALL_OW 458
104185: NOT
104186: AND
104187: IFFALSE 104229
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
104189: LD_ADDR_VAR 0 7
104193: PUSH
104194: LD_VAR 0 7
104198: PPUSH
104199: LD_VAR 0 7
104203: PUSH
104204: LD_INT 1
104206: PLUS
104207: PPUSH
104208: LD_VAR 0 9
104212: PUSH
104213: LD_VAR 0 10
104217: PUSH
104218: EMPTY
104219: LIST
104220: LIST
104221: PPUSH
104222: CALL_OW 1
104226: ST_TO_ADDR
104227: GO 104243
// i := i - 1 ;
104229: LD_ADDR_VAR 0 5
104233: PUSH
104234: LD_VAR 0 5
104238: PUSH
104239: LD_INT 1
104241: MINUS
104242: ST_TO_ADDR
// end ;
104243: GO 104049
104245: POP
104246: POP
// for i in tmp do
104247: LD_ADDR_VAR 0 5
104251: PUSH
104252: LD_VAR 0 7
104256: PUSH
104257: FOR_IN
104258: IFFALSE 104296
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
104260: LD_VAR 0 1
104264: PPUSH
104265: LD_VAR 0 5
104269: PUSH
104270: LD_INT 1
104272: ARRAY
104273: PPUSH
104274: LD_VAR 0 5
104278: PUSH
104279: LD_INT 2
104281: ARRAY
104282: PPUSH
104283: CALL 103238 0 3
104287: NOT
104288: IFFALSE 104294
// exit ;
104290: POP
104291: POP
104292: GO 104298
104294: GO 104257
104296: POP
104297: POP
// end ;
104298: LD_VAR 0 4
104302: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
104303: LD_INT 0
104305: PPUSH
104306: PPUSH
104307: PPUSH
104308: PPUSH
104309: PPUSH
104310: PPUSH
104311: PPUSH
// if not GetClass ( unit ) = class_sniper then
104312: LD_VAR 0 1
104316: PPUSH
104317: CALL_OW 257
104321: PUSH
104322: LD_INT 5
104324: EQUAL
104325: NOT
104326: IFFALSE 104330
// exit ;
104328: GO 104718
// dist := 8 ;
104330: LD_ADDR_VAR 0 5
104334: PUSH
104335: LD_INT 8
104337: ST_TO_ADDR
// viewRange := 12 ;
104338: LD_ADDR_VAR 0 7
104342: PUSH
104343: LD_INT 12
104345: ST_TO_ADDR
// side := GetSide ( unit ) ;
104346: LD_ADDR_VAR 0 6
104350: PUSH
104351: LD_VAR 0 1
104355: PPUSH
104356: CALL_OW 255
104360: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
104361: LD_INT 61
104363: PPUSH
104364: LD_VAR 0 6
104368: PPUSH
104369: CALL_OW 321
104373: PUSH
104374: LD_INT 2
104376: EQUAL
104377: IFFALSE 104387
// viewRange := 16 ;
104379: LD_ADDR_VAR 0 7
104383: PUSH
104384: LD_INT 16
104386: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
104387: LD_VAR 0 1
104391: PPUSH
104392: LD_VAR 0 2
104396: PPUSH
104397: LD_VAR 0 3
104401: PPUSH
104402: CALL_OW 297
104406: PUSH
104407: LD_VAR 0 5
104411: GREATER
104412: IFFALSE 104491
// begin ComMoveXY ( unit , x , y ) ;
104414: LD_VAR 0 1
104418: PPUSH
104419: LD_VAR 0 2
104423: PPUSH
104424: LD_VAR 0 3
104428: PPUSH
104429: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
104433: LD_INT 35
104435: PPUSH
104436: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
104440: LD_VAR 0 1
104444: PPUSH
104445: LD_VAR 0 2
104449: PPUSH
104450: LD_VAR 0 3
104454: PPUSH
104455: CALL 85550 0 3
104459: NOT
104460: IFFALSE 104464
// exit ;
104462: GO 104718
// until GetDistUnitXY ( unit , x , y ) < dist ;
104464: LD_VAR 0 1
104468: PPUSH
104469: LD_VAR 0 2
104473: PPUSH
104474: LD_VAR 0 3
104478: PPUSH
104479: CALL_OW 297
104483: PUSH
104484: LD_VAR 0 5
104488: LESS
104489: IFFALSE 104433
// end ; ComTurnXY ( unit , x , y ) ;
104491: LD_VAR 0 1
104495: PPUSH
104496: LD_VAR 0 2
104500: PPUSH
104501: LD_VAR 0 3
104505: PPUSH
104506: CALL_OW 118
// wait ( 5 ) ;
104510: LD_INT 5
104512: PPUSH
104513: CALL_OW 67
// _d := GetDir ( unit ) ;
104517: LD_ADDR_VAR 0 10
104521: PUSH
104522: LD_VAR 0 1
104526: PPUSH
104527: CALL_OW 254
104531: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
104532: LD_ADDR_VAR 0 8
104536: PUSH
104537: LD_VAR 0 1
104541: PPUSH
104542: CALL_OW 250
104546: PPUSH
104547: LD_VAR 0 10
104551: PPUSH
104552: LD_VAR 0 5
104556: PPUSH
104557: CALL_OW 272
104561: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
104562: LD_ADDR_VAR 0 9
104566: PUSH
104567: LD_VAR 0 1
104571: PPUSH
104572: CALL_OW 251
104576: PPUSH
104577: LD_VAR 0 10
104581: PPUSH
104582: LD_VAR 0 5
104586: PPUSH
104587: CALL_OW 273
104591: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
104592: LD_VAR 0 8
104596: PPUSH
104597: LD_VAR 0 9
104601: PPUSH
104602: CALL_OW 488
104606: NOT
104607: IFFALSE 104611
// exit ;
104609: GO 104718
// ComAnimCustom ( unit , 1 ) ;
104611: LD_VAR 0 1
104615: PPUSH
104616: LD_INT 1
104618: PPUSH
104619: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
104623: LD_VAR 0 8
104627: PPUSH
104628: LD_VAR 0 9
104632: PPUSH
104633: LD_VAR 0 6
104637: PPUSH
104638: LD_VAR 0 7
104642: PPUSH
104643: CALL_OW 330
// repeat wait ( 1 ) ;
104647: LD_INT 1
104649: PPUSH
104650: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
104654: LD_VAR 0 1
104658: PPUSH
104659: CALL_OW 316
104663: PUSH
104664: LD_VAR 0 1
104668: PPUSH
104669: CALL_OW 314
104673: OR
104674: PUSH
104675: LD_VAR 0 1
104679: PPUSH
104680: CALL_OW 302
104684: NOT
104685: OR
104686: PUSH
104687: LD_VAR 0 1
104691: PPUSH
104692: CALL_OW 301
104696: OR
104697: IFFALSE 104647
// RemoveSeeing ( _x , _y , side ) ;
104699: LD_VAR 0 8
104703: PPUSH
104704: LD_VAR 0 9
104708: PPUSH
104709: LD_VAR 0 6
104713: PPUSH
104714: CALL_OW 331
// end ; end_of_file
104718: LD_VAR 0 4
104722: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
104723: LD_INT 0
104725: PPUSH
104726: PPUSH
104727: PPUSH
104728: PPUSH
104729: PPUSH
104730: PPUSH
104731: PPUSH
104732: PPUSH
104733: PPUSH
104734: PPUSH
104735: PPUSH
104736: PPUSH
104737: PPUSH
104738: PPUSH
104739: PPUSH
104740: PPUSH
104741: PPUSH
104742: PPUSH
104743: PPUSH
104744: PPUSH
104745: PPUSH
104746: PPUSH
104747: PPUSH
104748: PPUSH
104749: PPUSH
104750: PPUSH
104751: PPUSH
104752: PPUSH
104753: PPUSH
104754: PPUSH
104755: PPUSH
104756: PPUSH
104757: PPUSH
104758: PPUSH
// if not list then
104759: LD_VAR 0 1
104763: NOT
104764: IFFALSE 104768
// exit ;
104766: GO 109427
// base := list [ 1 ] ;
104768: LD_ADDR_VAR 0 3
104772: PUSH
104773: LD_VAR 0 1
104777: PUSH
104778: LD_INT 1
104780: ARRAY
104781: ST_TO_ADDR
// group := list [ 2 ] ;
104782: LD_ADDR_VAR 0 4
104786: PUSH
104787: LD_VAR 0 1
104791: PUSH
104792: LD_INT 2
104794: ARRAY
104795: ST_TO_ADDR
// path := list [ 3 ] ;
104796: LD_ADDR_VAR 0 5
104800: PUSH
104801: LD_VAR 0 1
104805: PUSH
104806: LD_INT 3
104808: ARRAY
104809: ST_TO_ADDR
// flags := list [ 4 ] ;
104810: LD_ADDR_VAR 0 6
104814: PUSH
104815: LD_VAR 0 1
104819: PUSH
104820: LD_INT 4
104822: ARRAY
104823: ST_TO_ADDR
// mined := [ ] ;
104824: LD_ADDR_VAR 0 27
104828: PUSH
104829: EMPTY
104830: ST_TO_ADDR
// bombed := [ ] ;
104831: LD_ADDR_VAR 0 28
104835: PUSH
104836: EMPTY
104837: ST_TO_ADDR
// healers := [ ] ;
104838: LD_ADDR_VAR 0 31
104842: PUSH
104843: EMPTY
104844: ST_TO_ADDR
// to_heal := [ ] ;
104845: LD_ADDR_VAR 0 30
104849: PUSH
104850: EMPTY
104851: ST_TO_ADDR
// repairs := [ ] ;
104852: LD_ADDR_VAR 0 33
104856: PUSH
104857: EMPTY
104858: ST_TO_ADDR
// to_repair := [ ] ;
104859: LD_ADDR_VAR 0 32
104863: PUSH
104864: EMPTY
104865: ST_TO_ADDR
// if not group or not path then
104866: LD_VAR 0 4
104870: NOT
104871: PUSH
104872: LD_VAR 0 5
104876: NOT
104877: OR
104878: IFFALSE 104882
// exit ;
104880: GO 109427
// side := GetSide ( group [ 1 ] ) ;
104882: LD_ADDR_VAR 0 35
104886: PUSH
104887: LD_VAR 0 4
104891: PUSH
104892: LD_INT 1
104894: ARRAY
104895: PPUSH
104896: CALL_OW 255
104900: ST_TO_ADDR
// if flags then
104901: LD_VAR 0 6
104905: IFFALSE 105049
// begin f_ignore_area := flags [ 1 ] ;
104907: LD_ADDR_VAR 0 17
104911: PUSH
104912: LD_VAR 0 6
104916: PUSH
104917: LD_INT 1
104919: ARRAY
104920: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
104921: LD_ADDR_VAR 0 18
104925: PUSH
104926: LD_VAR 0 6
104930: PUSH
104931: LD_INT 2
104933: ARRAY
104934: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
104935: LD_ADDR_VAR 0 19
104939: PUSH
104940: LD_VAR 0 6
104944: PUSH
104945: LD_INT 3
104947: ARRAY
104948: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
104949: LD_ADDR_VAR 0 20
104953: PUSH
104954: LD_VAR 0 6
104958: PUSH
104959: LD_INT 4
104961: ARRAY
104962: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
104963: LD_ADDR_VAR 0 21
104967: PUSH
104968: LD_VAR 0 6
104972: PUSH
104973: LD_INT 5
104975: ARRAY
104976: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
104977: LD_ADDR_VAR 0 22
104981: PUSH
104982: LD_VAR 0 6
104986: PUSH
104987: LD_INT 6
104989: ARRAY
104990: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
104991: LD_ADDR_VAR 0 23
104995: PUSH
104996: LD_VAR 0 6
105000: PUSH
105001: LD_INT 7
105003: ARRAY
105004: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
105005: LD_ADDR_VAR 0 24
105009: PUSH
105010: LD_VAR 0 6
105014: PUSH
105015: LD_INT 8
105017: ARRAY
105018: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
105019: LD_ADDR_VAR 0 25
105023: PUSH
105024: LD_VAR 0 6
105028: PUSH
105029: LD_INT 9
105031: ARRAY
105032: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
105033: LD_ADDR_VAR 0 26
105037: PUSH
105038: LD_VAR 0 6
105042: PUSH
105043: LD_INT 10
105045: ARRAY
105046: ST_TO_ADDR
// end else
105047: GO 105129
// begin f_ignore_area := false ;
105049: LD_ADDR_VAR 0 17
105053: PUSH
105054: LD_INT 0
105056: ST_TO_ADDR
// f_capture := false ;
105057: LD_ADDR_VAR 0 18
105061: PUSH
105062: LD_INT 0
105064: ST_TO_ADDR
// f_ignore_civ := false ;
105065: LD_ADDR_VAR 0 19
105069: PUSH
105070: LD_INT 0
105072: ST_TO_ADDR
// f_murder := false ;
105073: LD_ADDR_VAR 0 20
105077: PUSH
105078: LD_INT 0
105080: ST_TO_ADDR
// f_mines := false ;
105081: LD_ADDR_VAR 0 21
105085: PUSH
105086: LD_INT 0
105088: ST_TO_ADDR
// f_repair := false ;
105089: LD_ADDR_VAR 0 22
105093: PUSH
105094: LD_INT 0
105096: ST_TO_ADDR
// f_heal := false ;
105097: LD_ADDR_VAR 0 23
105101: PUSH
105102: LD_INT 0
105104: ST_TO_ADDR
// f_spacetime := false ;
105105: LD_ADDR_VAR 0 24
105109: PUSH
105110: LD_INT 0
105112: ST_TO_ADDR
// f_attack_depot := false ;
105113: LD_ADDR_VAR 0 25
105117: PUSH
105118: LD_INT 0
105120: ST_TO_ADDR
// f_crawl := false ;
105121: LD_ADDR_VAR 0 26
105125: PUSH
105126: LD_INT 0
105128: ST_TO_ADDR
// end ; if f_heal then
105129: LD_VAR 0 23
105133: IFFALSE 105160
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
105135: LD_ADDR_VAR 0 31
105139: PUSH
105140: LD_VAR 0 4
105144: PPUSH
105145: LD_INT 25
105147: PUSH
105148: LD_INT 4
105150: PUSH
105151: EMPTY
105152: LIST
105153: LIST
105154: PPUSH
105155: CALL_OW 72
105159: ST_TO_ADDR
// if f_repair then
105160: LD_VAR 0 22
105164: IFFALSE 105191
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
105166: LD_ADDR_VAR 0 33
105170: PUSH
105171: LD_VAR 0 4
105175: PPUSH
105176: LD_INT 25
105178: PUSH
105179: LD_INT 3
105181: PUSH
105182: EMPTY
105183: LIST
105184: LIST
105185: PPUSH
105186: CALL_OW 72
105190: ST_TO_ADDR
// units_path := [ ] ;
105191: LD_ADDR_VAR 0 16
105195: PUSH
105196: EMPTY
105197: ST_TO_ADDR
// for i = 1 to group do
105198: LD_ADDR_VAR 0 7
105202: PUSH
105203: DOUBLE
105204: LD_INT 1
105206: DEC
105207: ST_TO_ADDR
105208: LD_VAR 0 4
105212: PUSH
105213: FOR_TO
105214: IFFALSE 105243
// units_path := Replace ( units_path , i , path ) ;
105216: LD_ADDR_VAR 0 16
105220: PUSH
105221: LD_VAR 0 16
105225: PPUSH
105226: LD_VAR 0 7
105230: PPUSH
105231: LD_VAR 0 5
105235: PPUSH
105236: CALL_OW 1
105240: ST_TO_ADDR
105241: GO 105213
105243: POP
105244: POP
// repeat for i = group downto 1 do
105245: LD_ADDR_VAR 0 7
105249: PUSH
105250: DOUBLE
105251: LD_VAR 0 4
105255: INC
105256: ST_TO_ADDR
105257: LD_INT 1
105259: PUSH
105260: FOR_DOWNTO
105261: IFFALSE 109383
// begin wait ( 5 ) ;
105263: LD_INT 5
105265: PPUSH
105266: CALL_OW 67
// tmp := [ ] ;
105270: LD_ADDR_VAR 0 14
105274: PUSH
105275: EMPTY
105276: ST_TO_ADDR
// attacking := false ;
105277: LD_ADDR_VAR 0 29
105281: PUSH
105282: LD_INT 0
105284: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
105285: LD_VAR 0 4
105289: PUSH
105290: LD_VAR 0 7
105294: ARRAY
105295: PPUSH
105296: CALL_OW 301
105300: PUSH
105301: LD_VAR 0 4
105305: PUSH
105306: LD_VAR 0 7
105310: ARRAY
105311: NOT
105312: OR
105313: IFFALSE 105422
// begin if GetType ( group [ i ] ) = unit_human then
105315: LD_VAR 0 4
105319: PUSH
105320: LD_VAR 0 7
105324: ARRAY
105325: PPUSH
105326: CALL_OW 247
105330: PUSH
105331: LD_INT 1
105333: EQUAL
105334: IFFALSE 105380
// begin to_heal := to_heal diff group [ i ] ;
105336: LD_ADDR_VAR 0 30
105340: PUSH
105341: LD_VAR 0 30
105345: PUSH
105346: LD_VAR 0 4
105350: PUSH
105351: LD_VAR 0 7
105355: ARRAY
105356: DIFF
105357: ST_TO_ADDR
// healers := healers diff group [ i ] ;
105358: LD_ADDR_VAR 0 31
105362: PUSH
105363: LD_VAR 0 31
105367: PUSH
105368: LD_VAR 0 4
105372: PUSH
105373: LD_VAR 0 7
105377: ARRAY
105378: DIFF
105379: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
105380: LD_ADDR_VAR 0 4
105384: PUSH
105385: LD_VAR 0 4
105389: PPUSH
105390: LD_VAR 0 7
105394: PPUSH
105395: CALL_OW 3
105399: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
105400: LD_ADDR_VAR 0 16
105404: PUSH
105405: LD_VAR 0 16
105409: PPUSH
105410: LD_VAR 0 7
105414: PPUSH
105415: CALL_OW 3
105419: ST_TO_ADDR
// continue ;
105420: GO 105260
// end ; if f_repair then
105422: LD_VAR 0 22
105426: IFFALSE 105915
// begin if GetType ( group [ i ] ) = unit_vehicle then
105428: LD_VAR 0 4
105432: PUSH
105433: LD_VAR 0 7
105437: ARRAY
105438: PPUSH
105439: CALL_OW 247
105443: PUSH
105444: LD_INT 2
105446: EQUAL
105447: IFFALSE 105637
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
105449: LD_VAR 0 4
105453: PUSH
105454: LD_VAR 0 7
105458: ARRAY
105459: PPUSH
105460: CALL_OW 256
105464: PUSH
105465: LD_INT 700
105467: LESS
105468: PUSH
105469: LD_VAR 0 4
105473: PUSH
105474: LD_VAR 0 7
105478: ARRAY
105479: PUSH
105480: LD_VAR 0 32
105484: IN
105485: NOT
105486: AND
105487: IFFALSE 105511
// to_repair := to_repair union group [ i ] ;
105489: LD_ADDR_VAR 0 32
105493: PUSH
105494: LD_VAR 0 32
105498: PUSH
105499: LD_VAR 0 4
105503: PUSH
105504: LD_VAR 0 7
105508: ARRAY
105509: UNION
105510: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
105511: LD_VAR 0 4
105515: PUSH
105516: LD_VAR 0 7
105520: ARRAY
105521: PPUSH
105522: CALL_OW 256
105526: PUSH
105527: LD_INT 1000
105529: EQUAL
105530: PUSH
105531: LD_VAR 0 4
105535: PUSH
105536: LD_VAR 0 7
105540: ARRAY
105541: PUSH
105542: LD_VAR 0 32
105546: IN
105547: AND
105548: IFFALSE 105572
// to_repair := to_repair diff group [ i ] ;
105550: LD_ADDR_VAR 0 32
105554: PUSH
105555: LD_VAR 0 32
105559: PUSH
105560: LD_VAR 0 4
105564: PUSH
105565: LD_VAR 0 7
105569: ARRAY
105570: DIFF
105571: ST_TO_ADDR
// if group [ i ] in to_repair then
105572: LD_VAR 0 4
105576: PUSH
105577: LD_VAR 0 7
105581: ARRAY
105582: PUSH
105583: LD_VAR 0 32
105587: IN
105588: IFFALSE 105635
// begin if not IsInArea ( group [ i ] , f_repair ) then
105590: LD_VAR 0 4
105594: PUSH
105595: LD_VAR 0 7
105599: ARRAY
105600: PPUSH
105601: LD_VAR 0 22
105605: PPUSH
105606: CALL_OW 308
105610: NOT
105611: IFFALSE 105633
// ComMoveToArea ( group [ i ] , f_repair ) ;
105613: LD_VAR 0 4
105617: PUSH
105618: LD_VAR 0 7
105622: ARRAY
105623: PPUSH
105624: LD_VAR 0 22
105628: PPUSH
105629: CALL_OW 113
// continue ;
105633: GO 105260
// end ; end else
105635: GO 105915
// if group [ i ] in repairs then
105637: LD_VAR 0 4
105641: PUSH
105642: LD_VAR 0 7
105646: ARRAY
105647: PUSH
105648: LD_VAR 0 33
105652: IN
105653: IFFALSE 105915
// begin if IsInUnit ( group [ i ] ) then
105655: LD_VAR 0 4
105659: PUSH
105660: LD_VAR 0 7
105664: ARRAY
105665: PPUSH
105666: CALL_OW 310
105670: IFFALSE 105738
// begin z := IsInUnit ( group [ i ] ) ;
105672: LD_ADDR_VAR 0 13
105676: PUSH
105677: LD_VAR 0 4
105681: PUSH
105682: LD_VAR 0 7
105686: ARRAY
105687: PPUSH
105688: CALL_OW 310
105692: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
105693: LD_VAR 0 13
105697: PUSH
105698: LD_VAR 0 32
105702: IN
105703: PUSH
105704: LD_VAR 0 13
105708: PPUSH
105709: LD_VAR 0 22
105713: PPUSH
105714: CALL_OW 308
105718: AND
105719: IFFALSE 105736
// ComExitVehicle ( group [ i ] ) ;
105721: LD_VAR 0 4
105725: PUSH
105726: LD_VAR 0 7
105730: ARRAY
105731: PPUSH
105732: CALL_OW 121
// end else
105736: GO 105915
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
105738: LD_ADDR_VAR 0 13
105742: PUSH
105743: LD_VAR 0 4
105747: PPUSH
105748: LD_INT 95
105750: PUSH
105751: LD_VAR 0 22
105755: PUSH
105756: EMPTY
105757: LIST
105758: LIST
105759: PUSH
105760: LD_INT 58
105762: PUSH
105763: EMPTY
105764: LIST
105765: PUSH
105766: EMPTY
105767: LIST
105768: LIST
105769: PPUSH
105770: CALL_OW 72
105774: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
105775: LD_VAR 0 4
105779: PUSH
105780: LD_VAR 0 7
105784: ARRAY
105785: PPUSH
105786: CALL_OW 314
105790: NOT
105791: IFFALSE 105913
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
105793: LD_ADDR_VAR 0 10
105797: PUSH
105798: LD_VAR 0 13
105802: PPUSH
105803: LD_VAR 0 4
105807: PUSH
105808: LD_VAR 0 7
105812: ARRAY
105813: PPUSH
105814: CALL_OW 74
105818: ST_TO_ADDR
// if not x then
105819: LD_VAR 0 10
105823: NOT
105824: IFFALSE 105828
// continue ;
105826: GO 105260
// if GetLives ( x ) < 1000 then
105828: LD_VAR 0 10
105832: PPUSH
105833: CALL_OW 256
105837: PUSH
105838: LD_INT 1000
105840: LESS
105841: IFFALSE 105865
// ComRepairVehicle ( group [ i ] , x ) else
105843: LD_VAR 0 4
105847: PUSH
105848: LD_VAR 0 7
105852: ARRAY
105853: PPUSH
105854: LD_VAR 0 10
105858: PPUSH
105859: CALL_OW 129
105863: GO 105913
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
105865: LD_VAR 0 23
105869: PUSH
105870: LD_VAR 0 4
105874: PUSH
105875: LD_VAR 0 7
105879: ARRAY
105880: PPUSH
105881: CALL_OW 256
105885: PUSH
105886: LD_INT 1000
105888: LESS
105889: AND
105890: NOT
105891: IFFALSE 105913
// ComEnterUnit ( group [ i ] , x ) ;
105893: LD_VAR 0 4
105897: PUSH
105898: LD_VAR 0 7
105902: ARRAY
105903: PPUSH
105904: LD_VAR 0 10
105908: PPUSH
105909: CALL_OW 120
// end ; continue ;
105913: GO 105260
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
105915: LD_VAR 0 23
105919: PUSH
105920: LD_VAR 0 4
105924: PUSH
105925: LD_VAR 0 7
105929: ARRAY
105930: PPUSH
105931: CALL_OW 247
105935: PUSH
105936: LD_INT 1
105938: EQUAL
105939: AND
105940: IFFALSE 106418
// begin if group [ i ] in healers then
105942: LD_VAR 0 4
105946: PUSH
105947: LD_VAR 0 7
105951: ARRAY
105952: PUSH
105953: LD_VAR 0 31
105957: IN
105958: IFFALSE 106231
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
105960: LD_VAR 0 4
105964: PUSH
105965: LD_VAR 0 7
105969: ARRAY
105970: PPUSH
105971: LD_VAR 0 23
105975: PPUSH
105976: CALL_OW 308
105980: NOT
105981: PUSH
105982: LD_VAR 0 4
105986: PUSH
105987: LD_VAR 0 7
105991: ARRAY
105992: PPUSH
105993: CALL_OW 314
105997: NOT
105998: AND
105999: IFFALSE 106023
// ComMoveToArea ( group [ i ] , f_heal ) else
106001: LD_VAR 0 4
106005: PUSH
106006: LD_VAR 0 7
106010: ARRAY
106011: PPUSH
106012: LD_VAR 0 23
106016: PPUSH
106017: CALL_OW 113
106021: GO 106229
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
106023: LD_VAR 0 4
106027: PUSH
106028: LD_VAR 0 7
106032: ARRAY
106033: PPUSH
106034: CALL 84073 0 1
106038: PPUSH
106039: CALL_OW 256
106043: PUSH
106044: LD_INT 1000
106046: EQUAL
106047: IFFALSE 106066
// ComStop ( group [ i ] ) else
106049: LD_VAR 0 4
106053: PUSH
106054: LD_VAR 0 7
106058: ARRAY
106059: PPUSH
106060: CALL_OW 141
106064: GO 106229
// if not HasTask ( group [ i ] ) and to_heal then
106066: LD_VAR 0 4
106070: PUSH
106071: LD_VAR 0 7
106075: ARRAY
106076: PPUSH
106077: CALL_OW 314
106081: NOT
106082: PUSH
106083: LD_VAR 0 30
106087: AND
106088: IFFALSE 106229
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
106090: LD_ADDR_VAR 0 13
106094: PUSH
106095: LD_VAR 0 30
106099: PPUSH
106100: LD_INT 3
106102: PUSH
106103: LD_INT 54
106105: PUSH
106106: EMPTY
106107: LIST
106108: PUSH
106109: EMPTY
106110: LIST
106111: LIST
106112: PPUSH
106113: CALL_OW 72
106117: PPUSH
106118: LD_VAR 0 4
106122: PUSH
106123: LD_VAR 0 7
106127: ARRAY
106128: PPUSH
106129: CALL_OW 74
106133: ST_TO_ADDR
// if z then
106134: LD_VAR 0 13
106138: IFFALSE 106229
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
106140: LD_INT 91
106142: PUSH
106143: LD_VAR 0 13
106147: PUSH
106148: LD_INT 10
106150: PUSH
106151: EMPTY
106152: LIST
106153: LIST
106154: LIST
106155: PUSH
106156: LD_INT 81
106158: PUSH
106159: LD_VAR 0 13
106163: PPUSH
106164: CALL_OW 255
106168: PUSH
106169: EMPTY
106170: LIST
106171: LIST
106172: PUSH
106173: EMPTY
106174: LIST
106175: LIST
106176: PPUSH
106177: CALL_OW 69
106181: PUSH
106182: LD_INT 0
106184: EQUAL
106185: IFFALSE 106209
// ComHeal ( group [ i ] , z ) else
106187: LD_VAR 0 4
106191: PUSH
106192: LD_VAR 0 7
106196: ARRAY
106197: PPUSH
106198: LD_VAR 0 13
106202: PPUSH
106203: CALL_OW 128
106207: GO 106229
// ComMoveToArea ( group [ i ] , f_heal ) ;
106209: LD_VAR 0 4
106213: PUSH
106214: LD_VAR 0 7
106218: ARRAY
106219: PPUSH
106220: LD_VAR 0 23
106224: PPUSH
106225: CALL_OW 113
// end ; continue ;
106229: GO 105260
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
106231: LD_VAR 0 4
106235: PUSH
106236: LD_VAR 0 7
106240: ARRAY
106241: PPUSH
106242: CALL_OW 256
106246: PUSH
106247: LD_INT 700
106249: LESS
106250: PUSH
106251: LD_VAR 0 4
106255: PUSH
106256: LD_VAR 0 7
106260: ARRAY
106261: PUSH
106262: LD_VAR 0 30
106266: IN
106267: NOT
106268: AND
106269: IFFALSE 106293
// to_heal := to_heal union group [ i ] ;
106271: LD_ADDR_VAR 0 30
106275: PUSH
106276: LD_VAR 0 30
106280: PUSH
106281: LD_VAR 0 4
106285: PUSH
106286: LD_VAR 0 7
106290: ARRAY
106291: UNION
106292: ST_TO_ADDR
// if group [ i ] in to_heal then
106293: LD_VAR 0 4
106297: PUSH
106298: LD_VAR 0 7
106302: ARRAY
106303: PUSH
106304: LD_VAR 0 30
106308: IN
106309: IFFALSE 106418
// begin if GetLives ( group [ i ] ) = 1000 then
106311: LD_VAR 0 4
106315: PUSH
106316: LD_VAR 0 7
106320: ARRAY
106321: PPUSH
106322: CALL_OW 256
106326: PUSH
106327: LD_INT 1000
106329: EQUAL
106330: IFFALSE 106356
// to_heal := to_heal diff group [ i ] else
106332: LD_ADDR_VAR 0 30
106336: PUSH
106337: LD_VAR 0 30
106341: PUSH
106342: LD_VAR 0 4
106346: PUSH
106347: LD_VAR 0 7
106351: ARRAY
106352: DIFF
106353: ST_TO_ADDR
106354: GO 106418
// begin if not IsInArea ( group [ i ] , to_heal ) then
106356: LD_VAR 0 4
106360: PUSH
106361: LD_VAR 0 7
106365: ARRAY
106366: PPUSH
106367: LD_VAR 0 30
106371: PPUSH
106372: CALL_OW 308
106376: NOT
106377: IFFALSE 106401
// ComMoveToArea ( group [ i ] , f_heal ) else
106379: LD_VAR 0 4
106383: PUSH
106384: LD_VAR 0 7
106388: ARRAY
106389: PPUSH
106390: LD_VAR 0 23
106394: PPUSH
106395: CALL_OW 113
106399: GO 106416
// ComHold ( group [ i ] ) ;
106401: LD_VAR 0 4
106405: PUSH
106406: LD_VAR 0 7
106410: ARRAY
106411: PPUSH
106412: CALL_OW 140
// continue ;
106416: GO 105260
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
106418: LD_VAR 0 4
106422: PUSH
106423: LD_VAR 0 7
106427: ARRAY
106428: PPUSH
106429: LD_INT 10
106431: PPUSH
106432: CALL 82493 0 2
106436: NOT
106437: PUSH
106438: LD_VAR 0 16
106442: PUSH
106443: LD_VAR 0 7
106447: ARRAY
106448: PUSH
106449: EMPTY
106450: EQUAL
106451: NOT
106452: AND
106453: IFFALSE 106719
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
106455: LD_VAR 0 4
106459: PUSH
106460: LD_VAR 0 7
106464: ARRAY
106465: PPUSH
106466: CALL_OW 262
106470: PUSH
106471: LD_INT 1
106473: PUSH
106474: LD_INT 2
106476: PUSH
106477: EMPTY
106478: LIST
106479: LIST
106480: IN
106481: IFFALSE 106522
// if GetFuel ( group [ i ] ) < 10 then
106483: LD_VAR 0 4
106487: PUSH
106488: LD_VAR 0 7
106492: ARRAY
106493: PPUSH
106494: CALL_OW 261
106498: PUSH
106499: LD_INT 10
106501: LESS
106502: IFFALSE 106522
// SetFuel ( group [ i ] , 12 ) ;
106504: LD_VAR 0 4
106508: PUSH
106509: LD_VAR 0 7
106513: ARRAY
106514: PPUSH
106515: LD_INT 12
106517: PPUSH
106518: CALL_OW 240
// if units_path [ i ] then
106522: LD_VAR 0 16
106526: PUSH
106527: LD_VAR 0 7
106531: ARRAY
106532: IFFALSE 106717
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
106534: LD_VAR 0 4
106538: PUSH
106539: LD_VAR 0 7
106543: ARRAY
106544: PPUSH
106545: LD_VAR 0 16
106549: PUSH
106550: LD_VAR 0 7
106554: ARRAY
106555: PUSH
106556: LD_INT 1
106558: ARRAY
106559: PUSH
106560: LD_INT 1
106562: ARRAY
106563: PPUSH
106564: LD_VAR 0 16
106568: PUSH
106569: LD_VAR 0 7
106573: ARRAY
106574: PUSH
106575: LD_INT 1
106577: ARRAY
106578: PUSH
106579: LD_INT 2
106581: ARRAY
106582: PPUSH
106583: CALL_OW 297
106587: PUSH
106588: LD_INT 6
106590: GREATER
106591: IFFALSE 106666
// begin if not HasTask ( group [ i ] ) then
106593: LD_VAR 0 4
106597: PUSH
106598: LD_VAR 0 7
106602: ARRAY
106603: PPUSH
106604: CALL_OW 314
106608: NOT
106609: IFFALSE 106664
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
106611: LD_VAR 0 4
106615: PUSH
106616: LD_VAR 0 7
106620: ARRAY
106621: PPUSH
106622: LD_VAR 0 16
106626: PUSH
106627: LD_VAR 0 7
106631: ARRAY
106632: PUSH
106633: LD_INT 1
106635: ARRAY
106636: PUSH
106637: LD_INT 1
106639: ARRAY
106640: PPUSH
106641: LD_VAR 0 16
106645: PUSH
106646: LD_VAR 0 7
106650: ARRAY
106651: PUSH
106652: LD_INT 1
106654: ARRAY
106655: PUSH
106656: LD_INT 2
106658: ARRAY
106659: PPUSH
106660: CALL_OW 114
// end else
106664: GO 106717
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
106666: LD_ADDR_VAR 0 15
106670: PUSH
106671: LD_VAR 0 16
106675: PUSH
106676: LD_VAR 0 7
106680: ARRAY
106681: PPUSH
106682: LD_INT 1
106684: PPUSH
106685: CALL_OW 3
106689: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
106690: LD_ADDR_VAR 0 16
106694: PUSH
106695: LD_VAR 0 16
106699: PPUSH
106700: LD_VAR 0 7
106704: PPUSH
106705: LD_VAR 0 15
106709: PPUSH
106710: CALL_OW 1
106714: ST_TO_ADDR
// continue ;
106715: GO 105260
// end ; end ; end else
106717: GO 109381
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
106719: LD_ADDR_VAR 0 14
106723: PUSH
106724: LD_INT 81
106726: PUSH
106727: LD_VAR 0 4
106731: PUSH
106732: LD_VAR 0 7
106736: ARRAY
106737: PPUSH
106738: CALL_OW 255
106742: PUSH
106743: EMPTY
106744: LIST
106745: LIST
106746: PPUSH
106747: CALL_OW 69
106751: ST_TO_ADDR
// if not tmp then
106752: LD_VAR 0 14
106756: NOT
106757: IFFALSE 106761
// continue ;
106759: GO 105260
// if f_ignore_area then
106761: LD_VAR 0 17
106765: IFFALSE 106853
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
106767: LD_ADDR_VAR 0 15
106771: PUSH
106772: LD_VAR 0 14
106776: PPUSH
106777: LD_INT 3
106779: PUSH
106780: LD_INT 92
106782: PUSH
106783: LD_VAR 0 17
106787: PUSH
106788: LD_INT 1
106790: ARRAY
106791: PUSH
106792: LD_VAR 0 17
106796: PUSH
106797: LD_INT 2
106799: ARRAY
106800: PUSH
106801: LD_VAR 0 17
106805: PUSH
106806: LD_INT 3
106808: ARRAY
106809: PUSH
106810: EMPTY
106811: LIST
106812: LIST
106813: LIST
106814: LIST
106815: PUSH
106816: EMPTY
106817: LIST
106818: LIST
106819: PPUSH
106820: CALL_OW 72
106824: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
106825: LD_VAR 0 14
106829: PUSH
106830: LD_VAR 0 15
106834: DIFF
106835: IFFALSE 106853
// tmp := tmp diff tmp2 ;
106837: LD_ADDR_VAR 0 14
106841: PUSH
106842: LD_VAR 0 14
106846: PUSH
106847: LD_VAR 0 15
106851: DIFF
106852: ST_TO_ADDR
// end ; if not f_murder then
106853: LD_VAR 0 20
106857: NOT
106858: IFFALSE 106916
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
106860: LD_ADDR_VAR 0 15
106864: PUSH
106865: LD_VAR 0 14
106869: PPUSH
106870: LD_INT 3
106872: PUSH
106873: LD_INT 50
106875: PUSH
106876: EMPTY
106877: LIST
106878: PUSH
106879: EMPTY
106880: LIST
106881: LIST
106882: PPUSH
106883: CALL_OW 72
106887: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
106888: LD_VAR 0 14
106892: PUSH
106893: LD_VAR 0 15
106897: DIFF
106898: IFFALSE 106916
// tmp := tmp diff tmp2 ;
106900: LD_ADDR_VAR 0 14
106904: PUSH
106905: LD_VAR 0 14
106909: PUSH
106910: LD_VAR 0 15
106914: DIFF
106915: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
106916: LD_ADDR_VAR 0 14
106920: PUSH
106921: LD_VAR 0 4
106925: PUSH
106926: LD_VAR 0 7
106930: ARRAY
106931: PPUSH
106932: LD_VAR 0 14
106936: PPUSH
106937: LD_INT 1
106939: PPUSH
106940: LD_INT 1
106942: PPUSH
106943: CALL 56136 0 4
106947: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
106948: LD_VAR 0 4
106952: PUSH
106953: LD_VAR 0 7
106957: ARRAY
106958: PPUSH
106959: CALL_OW 257
106963: PUSH
106964: LD_INT 1
106966: EQUAL
106967: IFFALSE 107415
// begin if WantPlant ( group [ i ] ) then
106969: LD_VAR 0 4
106973: PUSH
106974: LD_VAR 0 7
106978: ARRAY
106979: PPUSH
106980: CALL 55637 0 1
106984: IFFALSE 106988
// continue ;
106986: GO 105260
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
106988: LD_VAR 0 18
106992: PUSH
106993: LD_VAR 0 4
106997: PUSH
106998: LD_VAR 0 7
107002: ARRAY
107003: PPUSH
107004: CALL_OW 310
107008: NOT
107009: AND
107010: PUSH
107011: LD_VAR 0 14
107015: PUSH
107016: LD_INT 1
107018: ARRAY
107019: PUSH
107020: LD_VAR 0 14
107024: PPUSH
107025: LD_INT 21
107027: PUSH
107028: LD_INT 2
107030: PUSH
107031: EMPTY
107032: LIST
107033: LIST
107034: PUSH
107035: LD_INT 58
107037: PUSH
107038: EMPTY
107039: LIST
107040: PUSH
107041: EMPTY
107042: LIST
107043: LIST
107044: PPUSH
107045: CALL_OW 72
107049: IN
107050: AND
107051: IFFALSE 107087
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
107053: LD_VAR 0 4
107057: PUSH
107058: LD_VAR 0 7
107062: ARRAY
107063: PPUSH
107064: LD_VAR 0 14
107068: PUSH
107069: LD_INT 1
107071: ARRAY
107072: PPUSH
107073: CALL_OW 120
// attacking := true ;
107077: LD_ADDR_VAR 0 29
107081: PUSH
107082: LD_INT 1
107084: ST_TO_ADDR
// continue ;
107085: GO 105260
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
107087: LD_VAR 0 26
107091: PUSH
107092: LD_VAR 0 4
107096: PUSH
107097: LD_VAR 0 7
107101: ARRAY
107102: PPUSH
107103: CALL_OW 257
107107: PUSH
107108: LD_INT 1
107110: EQUAL
107111: AND
107112: PUSH
107113: LD_VAR 0 4
107117: PUSH
107118: LD_VAR 0 7
107122: ARRAY
107123: PPUSH
107124: CALL_OW 256
107128: PUSH
107129: LD_INT 800
107131: LESS
107132: AND
107133: PUSH
107134: LD_VAR 0 4
107138: PUSH
107139: LD_VAR 0 7
107143: ARRAY
107144: PPUSH
107145: CALL_OW 318
107149: NOT
107150: AND
107151: IFFALSE 107168
// ComCrawl ( group [ i ] ) ;
107153: LD_VAR 0 4
107157: PUSH
107158: LD_VAR 0 7
107162: ARRAY
107163: PPUSH
107164: CALL_OW 137
// if f_mines then
107168: LD_VAR 0 21
107172: IFFALSE 107415
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
107174: LD_VAR 0 14
107178: PUSH
107179: LD_INT 1
107181: ARRAY
107182: PPUSH
107183: CALL_OW 247
107187: PUSH
107188: LD_INT 3
107190: EQUAL
107191: PUSH
107192: LD_VAR 0 14
107196: PUSH
107197: LD_INT 1
107199: ARRAY
107200: PUSH
107201: LD_VAR 0 27
107205: IN
107206: NOT
107207: AND
107208: IFFALSE 107415
// begin x := GetX ( tmp [ 1 ] ) ;
107210: LD_ADDR_VAR 0 10
107214: PUSH
107215: LD_VAR 0 14
107219: PUSH
107220: LD_INT 1
107222: ARRAY
107223: PPUSH
107224: CALL_OW 250
107228: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
107229: LD_ADDR_VAR 0 11
107233: PUSH
107234: LD_VAR 0 14
107238: PUSH
107239: LD_INT 1
107241: ARRAY
107242: PPUSH
107243: CALL_OW 251
107247: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
107248: LD_ADDR_VAR 0 12
107252: PUSH
107253: LD_VAR 0 4
107257: PUSH
107258: LD_VAR 0 7
107262: ARRAY
107263: PPUSH
107264: CALL 82578 0 1
107268: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
107269: LD_VAR 0 4
107273: PUSH
107274: LD_VAR 0 7
107278: ARRAY
107279: PPUSH
107280: LD_VAR 0 10
107284: PPUSH
107285: LD_VAR 0 11
107289: PPUSH
107290: LD_VAR 0 14
107294: PUSH
107295: LD_INT 1
107297: ARRAY
107298: PPUSH
107299: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
107303: LD_VAR 0 4
107307: PUSH
107308: LD_VAR 0 7
107312: ARRAY
107313: PPUSH
107314: LD_VAR 0 10
107318: PPUSH
107319: LD_VAR 0 12
107323: PPUSH
107324: LD_INT 7
107326: PPUSH
107327: CALL_OW 272
107331: PPUSH
107332: LD_VAR 0 11
107336: PPUSH
107337: LD_VAR 0 12
107341: PPUSH
107342: LD_INT 7
107344: PPUSH
107345: CALL_OW 273
107349: PPUSH
107350: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
107354: LD_VAR 0 4
107358: PUSH
107359: LD_VAR 0 7
107363: ARRAY
107364: PPUSH
107365: LD_INT 71
107367: PPUSH
107368: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
107372: LD_ADDR_VAR 0 27
107376: PUSH
107377: LD_VAR 0 27
107381: PPUSH
107382: LD_VAR 0 27
107386: PUSH
107387: LD_INT 1
107389: PLUS
107390: PPUSH
107391: LD_VAR 0 14
107395: PUSH
107396: LD_INT 1
107398: ARRAY
107399: PPUSH
107400: CALL_OW 1
107404: ST_TO_ADDR
// attacking := true ;
107405: LD_ADDR_VAR 0 29
107409: PUSH
107410: LD_INT 1
107412: ST_TO_ADDR
// continue ;
107413: GO 105260
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
107415: LD_VAR 0 4
107419: PUSH
107420: LD_VAR 0 7
107424: ARRAY
107425: PPUSH
107426: CALL_OW 257
107430: PUSH
107431: LD_INT 17
107433: EQUAL
107434: PUSH
107435: LD_VAR 0 4
107439: PUSH
107440: LD_VAR 0 7
107444: ARRAY
107445: PPUSH
107446: CALL_OW 110
107450: PUSH
107451: LD_INT 71
107453: EQUAL
107454: NOT
107455: AND
107456: IFFALSE 107602
// begin attacking := false ;
107458: LD_ADDR_VAR 0 29
107462: PUSH
107463: LD_INT 0
107465: ST_TO_ADDR
// k := 5 ;
107466: LD_ADDR_VAR 0 9
107470: PUSH
107471: LD_INT 5
107473: ST_TO_ADDR
// if tmp < k then
107474: LD_VAR 0 14
107478: PUSH
107479: LD_VAR 0 9
107483: LESS
107484: IFFALSE 107496
// k := tmp ;
107486: LD_ADDR_VAR 0 9
107490: PUSH
107491: LD_VAR 0 14
107495: ST_TO_ADDR
// for j = 1 to k do
107496: LD_ADDR_VAR 0 8
107500: PUSH
107501: DOUBLE
107502: LD_INT 1
107504: DEC
107505: ST_TO_ADDR
107506: LD_VAR 0 9
107510: PUSH
107511: FOR_TO
107512: IFFALSE 107600
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
107514: LD_VAR 0 14
107518: PUSH
107519: LD_VAR 0 8
107523: ARRAY
107524: PUSH
107525: LD_VAR 0 14
107529: PPUSH
107530: LD_INT 58
107532: PUSH
107533: EMPTY
107534: LIST
107535: PPUSH
107536: CALL_OW 72
107540: IN
107541: NOT
107542: IFFALSE 107598
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
107544: LD_VAR 0 4
107548: PUSH
107549: LD_VAR 0 7
107553: ARRAY
107554: PPUSH
107555: LD_VAR 0 14
107559: PUSH
107560: LD_VAR 0 8
107564: ARRAY
107565: PPUSH
107566: CALL_OW 115
// attacking := true ;
107570: LD_ADDR_VAR 0 29
107574: PUSH
107575: LD_INT 1
107577: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
107578: LD_VAR 0 4
107582: PUSH
107583: LD_VAR 0 7
107587: ARRAY
107588: PPUSH
107589: LD_INT 71
107591: PPUSH
107592: CALL_OW 109
// continue ;
107596: GO 107511
// end ; end ;
107598: GO 107511
107600: POP
107601: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
107602: LD_VAR 0 4
107606: PUSH
107607: LD_VAR 0 7
107611: ARRAY
107612: PPUSH
107613: CALL_OW 257
107617: PUSH
107618: LD_INT 8
107620: EQUAL
107621: PUSH
107622: LD_VAR 0 4
107626: PUSH
107627: LD_VAR 0 7
107631: ARRAY
107632: PPUSH
107633: CALL_OW 264
107637: PUSH
107638: LD_INT 28
107640: PUSH
107641: LD_INT 45
107643: PUSH
107644: LD_INT 7
107646: PUSH
107647: LD_INT 47
107649: PUSH
107650: EMPTY
107651: LIST
107652: LIST
107653: LIST
107654: LIST
107655: IN
107656: OR
107657: IFFALSE 107913
// begin attacking := false ;
107659: LD_ADDR_VAR 0 29
107663: PUSH
107664: LD_INT 0
107666: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
107667: LD_VAR 0 14
107671: PUSH
107672: LD_INT 1
107674: ARRAY
107675: PPUSH
107676: CALL_OW 266
107680: PUSH
107681: LD_INT 32
107683: PUSH
107684: LD_INT 31
107686: PUSH
107687: LD_INT 33
107689: PUSH
107690: LD_INT 4
107692: PUSH
107693: LD_INT 5
107695: PUSH
107696: EMPTY
107697: LIST
107698: LIST
107699: LIST
107700: LIST
107701: LIST
107702: IN
107703: IFFALSE 107889
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
107705: LD_ADDR_VAR 0 9
107709: PUSH
107710: LD_VAR 0 14
107714: PUSH
107715: LD_INT 1
107717: ARRAY
107718: PPUSH
107719: CALL_OW 266
107723: PPUSH
107724: LD_VAR 0 14
107728: PUSH
107729: LD_INT 1
107731: ARRAY
107732: PPUSH
107733: CALL_OW 250
107737: PPUSH
107738: LD_VAR 0 14
107742: PUSH
107743: LD_INT 1
107745: ARRAY
107746: PPUSH
107747: CALL_OW 251
107751: PPUSH
107752: LD_VAR 0 14
107756: PUSH
107757: LD_INT 1
107759: ARRAY
107760: PPUSH
107761: CALL_OW 254
107765: PPUSH
107766: LD_VAR 0 14
107770: PUSH
107771: LD_INT 1
107773: ARRAY
107774: PPUSH
107775: CALL_OW 248
107779: PPUSH
107780: LD_INT 0
107782: PPUSH
107783: CALL 63948 0 6
107787: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
107788: LD_ADDR_VAR 0 8
107792: PUSH
107793: LD_VAR 0 4
107797: PUSH
107798: LD_VAR 0 7
107802: ARRAY
107803: PPUSH
107804: LD_VAR 0 9
107808: PPUSH
107809: CALL 82618 0 2
107813: ST_TO_ADDR
// if j then
107814: LD_VAR 0 8
107818: IFFALSE 107887
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
107820: LD_VAR 0 8
107824: PUSH
107825: LD_INT 1
107827: ARRAY
107828: PPUSH
107829: LD_VAR 0 8
107833: PUSH
107834: LD_INT 2
107836: ARRAY
107837: PPUSH
107838: CALL_OW 488
107842: IFFALSE 107887
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
107844: LD_VAR 0 4
107848: PUSH
107849: LD_VAR 0 7
107853: ARRAY
107854: PPUSH
107855: LD_VAR 0 8
107859: PUSH
107860: LD_INT 1
107862: ARRAY
107863: PPUSH
107864: LD_VAR 0 8
107868: PUSH
107869: LD_INT 2
107871: ARRAY
107872: PPUSH
107873: CALL_OW 116
// attacking := true ;
107877: LD_ADDR_VAR 0 29
107881: PUSH
107882: LD_INT 1
107884: ST_TO_ADDR
// continue ;
107885: GO 105260
// end ; end else
107887: GO 107913
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
107889: LD_VAR 0 4
107893: PUSH
107894: LD_VAR 0 7
107898: ARRAY
107899: PPUSH
107900: LD_VAR 0 14
107904: PUSH
107905: LD_INT 1
107907: ARRAY
107908: PPUSH
107909: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
107913: LD_VAR 0 4
107917: PUSH
107918: LD_VAR 0 7
107922: ARRAY
107923: PPUSH
107924: CALL_OW 265
107928: PUSH
107929: LD_INT 11
107931: EQUAL
107932: IFFALSE 108210
// begin k := 10 ;
107934: LD_ADDR_VAR 0 9
107938: PUSH
107939: LD_INT 10
107941: ST_TO_ADDR
// x := 0 ;
107942: LD_ADDR_VAR 0 10
107946: PUSH
107947: LD_INT 0
107949: ST_TO_ADDR
// if tmp < k then
107950: LD_VAR 0 14
107954: PUSH
107955: LD_VAR 0 9
107959: LESS
107960: IFFALSE 107972
// k := tmp ;
107962: LD_ADDR_VAR 0 9
107966: PUSH
107967: LD_VAR 0 14
107971: ST_TO_ADDR
// for j = k downto 1 do
107972: LD_ADDR_VAR 0 8
107976: PUSH
107977: DOUBLE
107978: LD_VAR 0 9
107982: INC
107983: ST_TO_ADDR
107984: LD_INT 1
107986: PUSH
107987: FOR_DOWNTO
107988: IFFALSE 108063
// begin if GetType ( tmp [ j ] ) = unit_human then
107990: LD_VAR 0 14
107994: PUSH
107995: LD_VAR 0 8
107999: ARRAY
108000: PPUSH
108001: CALL_OW 247
108005: PUSH
108006: LD_INT 1
108008: EQUAL
108009: IFFALSE 108061
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
108011: LD_VAR 0 4
108015: PUSH
108016: LD_VAR 0 7
108020: ARRAY
108021: PPUSH
108022: LD_VAR 0 14
108026: PUSH
108027: LD_VAR 0 8
108031: ARRAY
108032: PPUSH
108033: CALL 82889 0 2
// x := tmp [ j ] ;
108037: LD_ADDR_VAR 0 10
108041: PUSH
108042: LD_VAR 0 14
108046: PUSH
108047: LD_VAR 0 8
108051: ARRAY
108052: ST_TO_ADDR
// attacking := true ;
108053: LD_ADDR_VAR 0 29
108057: PUSH
108058: LD_INT 1
108060: ST_TO_ADDR
// end ; end ;
108061: GO 107987
108063: POP
108064: POP
// if not x then
108065: LD_VAR 0 10
108069: NOT
108070: IFFALSE 108210
// begin attacking := true ;
108072: LD_ADDR_VAR 0 29
108076: PUSH
108077: LD_INT 1
108079: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
108080: LD_VAR 0 4
108084: PUSH
108085: LD_VAR 0 7
108089: ARRAY
108090: PPUSH
108091: CALL_OW 250
108095: PPUSH
108096: LD_VAR 0 4
108100: PUSH
108101: LD_VAR 0 7
108105: ARRAY
108106: PPUSH
108107: CALL_OW 251
108111: PPUSH
108112: CALL_OW 546
108116: PUSH
108117: LD_INT 2
108119: ARRAY
108120: PUSH
108121: LD_VAR 0 14
108125: PUSH
108126: LD_INT 1
108128: ARRAY
108129: PPUSH
108130: CALL_OW 250
108134: PPUSH
108135: LD_VAR 0 14
108139: PUSH
108140: LD_INT 1
108142: ARRAY
108143: PPUSH
108144: CALL_OW 251
108148: PPUSH
108149: CALL_OW 546
108153: PUSH
108154: LD_INT 2
108156: ARRAY
108157: EQUAL
108158: IFFALSE 108186
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
108160: LD_VAR 0 4
108164: PUSH
108165: LD_VAR 0 7
108169: ARRAY
108170: PPUSH
108171: LD_VAR 0 14
108175: PUSH
108176: LD_INT 1
108178: ARRAY
108179: PPUSH
108180: CALL 82889 0 2
108184: GO 108210
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
108186: LD_VAR 0 4
108190: PUSH
108191: LD_VAR 0 7
108195: ARRAY
108196: PPUSH
108197: LD_VAR 0 14
108201: PUSH
108202: LD_INT 1
108204: ARRAY
108205: PPUSH
108206: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
108210: LD_VAR 0 4
108214: PUSH
108215: LD_VAR 0 7
108219: ARRAY
108220: PPUSH
108221: CALL_OW 264
108225: PUSH
108226: LD_INT 29
108228: EQUAL
108229: IFFALSE 108595
// begin if WantsToAttack ( group [ i ] ) in bombed then
108231: LD_VAR 0 4
108235: PUSH
108236: LD_VAR 0 7
108240: ARRAY
108241: PPUSH
108242: CALL_OW 319
108246: PUSH
108247: LD_VAR 0 28
108251: IN
108252: IFFALSE 108256
// continue ;
108254: GO 105260
// k := 8 ;
108256: LD_ADDR_VAR 0 9
108260: PUSH
108261: LD_INT 8
108263: ST_TO_ADDR
// x := 0 ;
108264: LD_ADDR_VAR 0 10
108268: PUSH
108269: LD_INT 0
108271: ST_TO_ADDR
// if tmp < k then
108272: LD_VAR 0 14
108276: PUSH
108277: LD_VAR 0 9
108281: LESS
108282: IFFALSE 108294
// k := tmp ;
108284: LD_ADDR_VAR 0 9
108288: PUSH
108289: LD_VAR 0 14
108293: ST_TO_ADDR
// for j = 1 to k do
108294: LD_ADDR_VAR 0 8
108298: PUSH
108299: DOUBLE
108300: LD_INT 1
108302: DEC
108303: ST_TO_ADDR
108304: LD_VAR 0 9
108308: PUSH
108309: FOR_TO
108310: IFFALSE 108442
// begin if GetType ( tmp [ j ] ) = unit_building then
108312: LD_VAR 0 14
108316: PUSH
108317: LD_VAR 0 8
108321: ARRAY
108322: PPUSH
108323: CALL_OW 247
108327: PUSH
108328: LD_INT 3
108330: EQUAL
108331: IFFALSE 108440
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
108333: LD_VAR 0 14
108337: PUSH
108338: LD_VAR 0 8
108342: ARRAY
108343: PUSH
108344: LD_VAR 0 28
108348: IN
108349: NOT
108350: PUSH
108351: LD_VAR 0 14
108355: PUSH
108356: LD_VAR 0 8
108360: ARRAY
108361: PPUSH
108362: CALL_OW 313
108366: AND
108367: IFFALSE 108440
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
108369: LD_VAR 0 4
108373: PUSH
108374: LD_VAR 0 7
108378: ARRAY
108379: PPUSH
108380: LD_VAR 0 14
108384: PUSH
108385: LD_VAR 0 8
108389: ARRAY
108390: PPUSH
108391: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
108395: LD_ADDR_VAR 0 28
108399: PUSH
108400: LD_VAR 0 28
108404: PPUSH
108405: LD_VAR 0 28
108409: PUSH
108410: LD_INT 1
108412: PLUS
108413: PPUSH
108414: LD_VAR 0 14
108418: PUSH
108419: LD_VAR 0 8
108423: ARRAY
108424: PPUSH
108425: CALL_OW 1
108429: ST_TO_ADDR
// attacking := true ;
108430: LD_ADDR_VAR 0 29
108434: PUSH
108435: LD_INT 1
108437: ST_TO_ADDR
// break ;
108438: GO 108442
// end ; end ;
108440: GO 108309
108442: POP
108443: POP
// if not attacking and f_attack_depot then
108444: LD_VAR 0 29
108448: NOT
108449: PUSH
108450: LD_VAR 0 25
108454: AND
108455: IFFALSE 108550
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
108457: LD_ADDR_VAR 0 13
108461: PUSH
108462: LD_VAR 0 14
108466: PPUSH
108467: LD_INT 2
108469: PUSH
108470: LD_INT 30
108472: PUSH
108473: LD_INT 0
108475: PUSH
108476: EMPTY
108477: LIST
108478: LIST
108479: PUSH
108480: LD_INT 30
108482: PUSH
108483: LD_INT 1
108485: PUSH
108486: EMPTY
108487: LIST
108488: LIST
108489: PUSH
108490: EMPTY
108491: LIST
108492: LIST
108493: LIST
108494: PPUSH
108495: CALL_OW 72
108499: ST_TO_ADDR
// if z then
108500: LD_VAR 0 13
108504: IFFALSE 108550
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
108506: LD_VAR 0 4
108510: PUSH
108511: LD_VAR 0 7
108515: ARRAY
108516: PPUSH
108517: LD_VAR 0 13
108521: PPUSH
108522: LD_VAR 0 4
108526: PUSH
108527: LD_VAR 0 7
108531: ARRAY
108532: PPUSH
108533: CALL_OW 74
108537: PPUSH
108538: CALL_OW 115
// attacking := true ;
108542: LD_ADDR_VAR 0 29
108546: PUSH
108547: LD_INT 1
108549: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
108550: LD_VAR 0 4
108554: PUSH
108555: LD_VAR 0 7
108559: ARRAY
108560: PPUSH
108561: CALL_OW 256
108565: PUSH
108566: LD_INT 500
108568: LESS
108569: IFFALSE 108595
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
108571: LD_VAR 0 4
108575: PUSH
108576: LD_VAR 0 7
108580: ARRAY
108581: PPUSH
108582: LD_VAR 0 14
108586: PUSH
108587: LD_INT 1
108589: ARRAY
108590: PPUSH
108591: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
108595: LD_VAR 0 4
108599: PUSH
108600: LD_VAR 0 7
108604: ARRAY
108605: PPUSH
108606: CALL_OW 264
108610: PUSH
108611: LD_INT 49
108613: EQUAL
108614: IFFALSE 108735
// begin if not HasTask ( group [ i ] ) then
108616: LD_VAR 0 4
108620: PUSH
108621: LD_VAR 0 7
108625: ARRAY
108626: PPUSH
108627: CALL_OW 314
108631: NOT
108632: IFFALSE 108735
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
108634: LD_ADDR_VAR 0 9
108638: PUSH
108639: LD_INT 81
108641: PUSH
108642: LD_VAR 0 4
108646: PUSH
108647: LD_VAR 0 7
108651: ARRAY
108652: PPUSH
108653: CALL_OW 255
108657: PUSH
108658: EMPTY
108659: LIST
108660: LIST
108661: PPUSH
108662: CALL_OW 69
108666: PPUSH
108667: LD_VAR 0 4
108671: PUSH
108672: LD_VAR 0 7
108676: ARRAY
108677: PPUSH
108678: CALL_OW 74
108682: ST_TO_ADDR
// if k then
108683: LD_VAR 0 9
108687: IFFALSE 108735
// if GetDistUnits ( group [ i ] , k ) > 10 then
108689: LD_VAR 0 4
108693: PUSH
108694: LD_VAR 0 7
108698: ARRAY
108699: PPUSH
108700: LD_VAR 0 9
108704: PPUSH
108705: CALL_OW 296
108709: PUSH
108710: LD_INT 10
108712: GREATER
108713: IFFALSE 108735
// ComMoveUnit ( group [ i ] , k ) ;
108715: LD_VAR 0 4
108719: PUSH
108720: LD_VAR 0 7
108724: ARRAY
108725: PPUSH
108726: LD_VAR 0 9
108730: PPUSH
108731: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
108735: LD_VAR 0 4
108739: PUSH
108740: LD_VAR 0 7
108744: ARRAY
108745: PPUSH
108746: CALL_OW 256
108750: PUSH
108751: LD_INT 250
108753: LESS
108754: PUSH
108755: LD_VAR 0 4
108759: PUSH
108760: LD_VAR 0 7
108764: ARRAY
108765: PUSH
108766: LD_INT 21
108768: PUSH
108769: LD_INT 2
108771: PUSH
108772: EMPTY
108773: LIST
108774: LIST
108775: PUSH
108776: LD_INT 23
108778: PUSH
108779: LD_INT 2
108781: PUSH
108782: EMPTY
108783: LIST
108784: LIST
108785: PUSH
108786: EMPTY
108787: LIST
108788: LIST
108789: PPUSH
108790: CALL_OW 69
108794: IN
108795: AND
108796: IFFALSE 108921
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
108798: LD_ADDR_VAR 0 9
108802: PUSH
108803: LD_OWVAR 3
108807: PUSH
108808: LD_VAR 0 4
108812: PUSH
108813: LD_VAR 0 7
108817: ARRAY
108818: DIFF
108819: PPUSH
108820: LD_VAR 0 4
108824: PUSH
108825: LD_VAR 0 7
108829: ARRAY
108830: PPUSH
108831: CALL_OW 74
108835: ST_TO_ADDR
// if not k then
108836: LD_VAR 0 9
108840: NOT
108841: IFFALSE 108845
// continue ;
108843: GO 105260
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
108845: LD_VAR 0 9
108849: PUSH
108850: LD_INT 81
108852: PUSH
108853: LD_VAR 0 4
108857: PUSH
108858: LD_VAR 0 7
108862: ARRAY
108863: PPUSH
108864: CALL_OW 255
108868: PUSH
108869: EMPTY
108870: LIST
108871: LIST
108872: PPUSH
108873: CALL_OW 69
108877: IN
108878: PUSH
108879: LD_VAR 0 9
108883: PPUSH
108884: LD_VAR 0 4
108888: PUSH
108889: LD_VAR 0 7
108893: ARRAY
108894: PPUSH
108895: CALL_OW 296
108899: PUSH
108900: LD_INT 5
108902: LESS
108903: AND
108904: IFFALSE 108921
// ComAutodestruct ( group [ i ] ) ;
108906: LD_VAR 0 4
108910: PUSH
108911: LD_VAR 0 7
108915: ARRAY
108916: PPUSH
108917: CALL 82787 0 1
// end ; if f_attack_depot then
108921: LD_VAR 0 25
108925: IFFALSE 109037
// begin k := 6 ;
108927: LD_ADDR_VAR 0 9
108931: PUSH
108932: LD_INT 6
108934: ST_TO_ADDR
// if tmp < k then
108935: LD_VAR 0 14
108939: PUSH
108940: LD_VAR 0 9
108944: LESS
108945: IFFALSE 108957
// k := tmp ;
108947: LD_ADDR_VAR 0 9
108951: PUSH
108952: LD_VAR 0 14
108956: ST_TO_ADDR
// for j = 1 to k do
108957: LD_ADDR_VAR 0 8
108961: PUSH
108962: DOUBLE
108963: LD_INT 1
108965: DEC
108966: ST_TO_ADDR
108967: LD_VAR 0 9
108971: PUSH
108972: FOR_TO
108973: IFFALSE 109035
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
108975: LD_VAR 0 8
108979: PPUSH
108980: CALL_OW 266
108984: PUSH
108985: LD_INT 0
108987: PUSH
108988: LD_INT 1
108990: PUSH
108991: EMPTY
108992: LIST
108993: LIST
108994: IN
108995: IFFALSE 109033
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
108997: LD_VAR 0 4
109001: PUSH
109002: LD_VAR 0 7
109006: ARRAY
109007: PPUSH
109008: LD_VAR 0 14
109012: PUSH
109013: LD_VAR 0 8
109017: ARRAY
109018: PPUSH
109019: CALL_OW 115
// attacking := true ;
109023: LD_ADDR_VAR 0 29
109027: PUSH
109028: LD_INT 1
109030: ST_TO_ADDR
// break ;
109031: GO 109035
// end ;
109033: GO 108972
109035: POP
109036: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
109037: LD_VAR 0 4
109041: PUSH
109042: LD_VAR 0 7
109046: ARRAY
109047: PPUSH
109048: CALL_OW 302
109052: PUSH
109053: LD_VAR 0 29
109057: NOT
109058: AND
109059: IFFALSE 109381
// begin if GetTag ( group [ i ] ) = 71 then
109061: LD_VAR 0 4
109065: PUSH
109066: LD_VAR 0 7
109070: ARRAY
109071: PPUSH
109072: CALL_OW 110
109076: PUSH
109077: LD_INT 71
109079: EQUAL
109080: IFFALSE 109121
// begin if HasTask ( group [ i ] ) then
109082: LD_VAR 0 4
109086: PUSH
109087: LD_VAR 0 7
109091: ARRAY
109092: PPUSH
109093: CALL_OW 314
109097: IFFALSE 109103
// continue else
109099: GO 105260
109101: GO 109121
// SetTag ( group [ i ] , 0 ) ;
109103: LD_VAR 0 4
109107: PUSH
109108: LD_VAR 0 7
109112: ARRAY
109113: PPUSH
109114: LD_INT 0
109116: PPUSH
109117: CALL_OW 109
// end ; k := 8 ;
109121: LD_ADDR_VAR 0 9
109125: PUSH
109126: LD_INT 8
109128: ST_TO_ADDR
// x := 0 ;
109129: LD_ADDR_VAR 0 10
109133: PUSH
109134: LD_INT 0
109136: ST_TO_ADDR
// if tmp < k then
109137: LD_VAR 0 14
109141: PUSH
109142: LD_VAR 0 9
109146: LESS
109147: IFFALSE 109159
// k := tmp ;
109149: LD_ADDR_VAR 0 9
109153: PUSH
109154: LD_VAR 0 14
109158: ST_TO_ADDR
// for j = 1 to k do
109159: LD_ADDR_VAR 0 8
109163: PUSH
109164: DOUBLE
109165: LD_INT 1
109167: DEC
109168: ST_TO_ADDR
109169: LD_VAR 0 9
109173: PUSH
109174: FOR_TO
109175: IFFALSE 109273
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
109177: LD_VAR 0 14
109181: PUSH
109182: LD_VAR 0 8
109186: ARRAY
109187: PPUSH
109188: CALL_OW 247
109192: PUSH
109193: LD_INT 1
109195: EQUAL
109196: PUSH
109197: LD_VAR 0 14
109201: PUSH
109202: LD_VAR 0 8
109206: ARRAY
109207: PPUSH
109208: CALL_OW 256
109212: PUSH
109213: LD_INT 250
109215: LESS
109216: PUSH
109217: LD_VAR 0 20
109221: AND
109222: PUSH
109223: LD_VAR 0 20
109227: NOT
109228: PUSH
109229: LD_VAR 0 14
109233: PUSH
109234: LD_VAR 0 8
109238: ARRAY
109239: PPUSH
109240: CALL_OW 256
109244: PUSH
109245: LD_INT 250
109247: GREATEREQUAL
109248: AND
109249: OR
109250: AND
109251: IFFALSE 109271
// begin x := tmp [ j ] ;
109253: LD_ADDR_VAR 0 10
109257: PUSH
109258: LD_VAR 0 14
109262: PUSH
109263: LD_VAR 0 8
109267: ARRAY
109268: ST_TO_ADDR
// break ;
109269: GO 109273
// end ;
109271: GO 109174
109273: POP
109274: POP
// if x then
109275: LD_VAR 0 10
109279: IFFALSE 109303
// ComAttackUnit ( group [ i ] , x ) else
109281: LD_VAR 0 4
109285: PUSH
109286: LD_VAR 0 7
109290: ARRAY
109291: PPUSH
109292: LD_VAR 0 10
109296: PPUSH
109297: CALL_OW 115
109301: GO 109327
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
109303: LD_VAR 0 4
109307: PUSH
109308: LD_VAR 0 7
109312: ARRAY
109313: PPUSH
109314: LD_VAR 0 14
109318: PUSH
109319: LD_INT 1
109321: ARRAY
109322: PPUSH
109323: CALL_OW 115
// if not HasTask ( group [ i ] ) then
109327: LD_VAR 0 4
109331: PUSH
109332: LD_VAR 0 7
109336: ARRAY
109337: PPUSH
109338: CALL_OW 314
109342: NOT
109343: IFFALSE 109381
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
109345: LD_VAR 0 4
109349: PUSH
109350: LD_VAR 0 7
109354: ARRAY
109355: PPUSH
109356: LD_VAR 0 14
109360: PPUSH
109361: LD_VAR 0 4
109365: PUSH
109366: LD_VAR 0 7
109370: ARRAY
109371: PPUSH
109372: CALL_OW 74
109376: PPUSH
109377: CALL_OW 115
// end ; end ; end ;
109381: GO 105260
109383: POP
109384: POP
// wait ( 0 0$2 ) ;
109385: LD_INT 70
109387: PPUSH
109388: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
109392: LD_VAR 0 4
109396: NOT
109397: PUSH
109398: LD_VAR 0 4
109402: PUSH
109403: EMPTY
109404: EQUAL
109405: OR
109406: PUSH
109407: LD_INT 81
109409: PUSH
109410: LD_VAR 0 35
109414: PUSH
109415: EMPTY
109416: LIST
109417: LIST
109418: PPUSH
109419: CALL_OW 69
109423: NOT
109424: OR
109425: IFFALSE 105245
// end ;
109427: LD_VAR 0 2
109431: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
109432: LD_INT 0
109434: PPUSH
109435: PPUSH
109436: PPUSH
109437: PPUSH
109438: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
109439: LD_VAR 0 1
109443: NOT
109444: PUSH
109445: LD_EXP 90
109449: PUSH
109450: LD_VAR 0 1
109454: ARRAY
109455: NOT
109456: OR
109457: PUSH
109458: LD_VAR 0 2
109462: NOT
109463: OR
109464: PUSH
109465: LD_VAR 0 3
109469: NOT
109470: OR
109471: IFFALSE 109475
// exit ;
109473: GO 109988
// side := mc_sides [ base ] ;
109475: LD_ADDR_VAR 0 6
109479: PUSH
109480: LD_EXP 116
109484: PUSH
109485: LD_VAR 0 1
109489: ARRAY
109490: ST_TO_ADDR
// if not side then
109491: LD_VAR 0 6
109495: NOT
109496: IFFALSE 109500
// exit ;
109498: GO 109988
// for i in solds do
109500: LD_ADDR_VAR 0 7
109504: PUSH
109505: LD_VAR 0 2
109509: PUSH
109510: FOR_IN
109511: IFFALSE 109572
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
109513: LD_VAR 0 7
109517: PPUSH
109518: CALL_OW 310
109522: PPUSH
109523: CALL_OW 266
109527: PUSH
109528: LD_INT 32
109530: PUSH
109531: LD_INT 31
109533: PUSH
109534: EMPTY
109535: LIST
109536: LIST
109537: IN
109538: IFFALSE 109558
// solds := solds diff i else
109540: LD_ADDR_VAR 0 2
109544: PUSH
109545: LD_VAR 0 2
109549: PUSH
109550: LD_VAR 0 7
109554: DIFF
109555: ST_TO_ADDR
109556: GO 109570
// SetTag ( i , 18 ) ;
109558: LD_VAR 0 7
109562: PPUSH
109563: LD_INT 18
109565: PPUSH
109566: CALL_OW 109
109570: GO 109510
109572: POP
109573: POP
// if not solds then
109574: LD_VAR 0 2
109578: NOT
109579: IFFALSE 109583
// exit ;
109581: GO 109988
// repeat wait ( 0 0$1 ) ;
109583: LD_INT 35
109585: PPUSH
109586: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
109590: LD_ADDR_VAR 0 5
109594: PUSH
109595: LD_VAR 0 6
109599: PPUSH
109600: LD_VAR 0 3
109604: PPUSH
109605: CALL 52502 0 2
109609: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
109610: LD_EXP 90
109614: PUSH
109615: LD_VAR 0 1
109619: ARRAY
109620: NOT
109621: PUSH
109622: LD_EXP 90
109626: PUSH
109627: LD_VAR 0 1
109631: ARRAY
109632: PUSH
109633: EMPTY
109634: EQUAL
109635: OR
109636: IFFALSE 109673
// begin for i in solds do
109638: LD_ADDR_VAR 0 7
109642: PUSH
109643: LD_VAR 0 2
109647: PUSH
109648: FOR_IN
109649: IFFALSE 109662
// ComStop ( i ) ;
109651: LD_VAR 0 7
109655: PPUSH
109656: CALL_OW 141
109660: GO 109648
109662: POP
109663: POP
// solds := [ ] ;
109664: LD_ADDR_VAR 0 2
109668: PUSH
109669: EMPTY
109670: ST_TO_ADDR
// exit ;
109671: GO 109988
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
109673: LD_VAR 0 5
109677: NOT
109678: PUSH
109679: LD_VAR 0 5
109683: PUSH
109684: LD_INT 3
109686: GREATER
109687: OR
109688: PUSH
109689: LD_EXP 112
109693: PUSH
109694: LD_VAR 0 1
109698: ARRAY
109699: OR
109700: IFFALSE 109741
// begin for i in solds do
109702: LD_ADDR_VAR 0 7
109706: PUSH
109707: LD_VAR 0 2
109711: PUSH
109712: FOR_IN
109713: IFFALSE 109737
// if HasTask ( i ) then
109715: LD_VAR 0 7
109719: PPUSH
109720: CALL_OW 314
109724: IFFALSE 109735
// ComStop ( i ) ;
109726: LD_VAR 0 7
109730: PPUSH
109731: CALL_OW 141
109735: GO 109712
109737: POP
109738: POP
// break ;
109739: GO 109976
// end ; for i in solds do
109741: LD_ADDR_VAR 0 7
109745: PUSH
109746: LD_VAR 0 2
109750: PUSH
109751: FOR_IN
109752: IFFALSE 109968
// begin if IsInUnit ( i ) then
109754: LD_VAR 0 7
109758: PPUSH
109759: CALL_OW 310
109763: IFFALSE 109774
// ComExitBuilding ( i ) ;
109765: LD_VAR 0 7
109769: PPUSH
109770: CALL_OW 122
// if GetLives ( i ) > 333 then
109774: LD_VAR 0 7
109778: PPUSH
109779: CALL_OW 256
109783: PUSH
109784: LD_INT 333
109786: GREATER
109787: IFFALSE 109815
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
109789: LD_VAR 0 7
109793: PPUSH
109794: LD_VAR 0 5
109798: PPUSH
109799: LD_VAR 0 7
109803: PPUSH
109804: CALL_OW 74
109808: PPUSH
109809: CALL_OW 115
109813: GO 109966
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
109815: LD_ADDR_VAR 0 8
109819: PUSH
109820: LD_EXP 90
109824: PUSH
109825: LD_VAR 0 1
109829: ARRAY
109830: PPUSH
109831: LD_INT 2
109833: PUSH
109834: LD_INT 30
109836: PUSH
109837: LD_INT 0
109839: PUSH
109840: EMPTY
109841: LIST
109842: LIST
109843: PUSH
109844: LD_INT 30
109846: PUSH
109847: LD_INT 1
109849: PUSH
109850: EMPTY
109851: LIST
109852: LIST
109853: PUSH
109854: LD_INT 30
109856: PUSH
109857: LD_INT 6
109859: PUSH
109860: EMPTY
109861: LIST
109862: LIST
109863: PUSH
109864: EMPTY
109865: LIST
109866: LIST
109867: LIST
109868: LIST
109869: PPUSH
109870: CALL_OW 72
109874: PPUSH
109875: LD_VAR 0 7
109879: PPUSH
109880: CALL_OW 74
109884: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
109885: LD_VAR 0 7
109889: PPUSH
109890: LD_VAR 0 8
109894: PPUSH
109895: CALL_OW 250
109899: PPUSH
109900: LD_INT 3
109902: PPUSH
109903: LD_INT 5
109905: PPUSH
109906: CALL_OW 272
109910: PPUSH
109911: LD_VAR 0 8
109915: PPUSH
109916: CALL_OW 251
109920: PPUSH
109921: LD_INT 3
109923: PPUSH
109924: LD_INT 5
109926: PPUSH
109927: CALL_OW 273
109931: PPUSH
109932: CALL_OW 111
// SetTag ( i , 0 ) ;
109936: LD_VAR 0 7
109940: PPUSH
109941: LD_INT 0
109943: PPUSH
109944: CALL_OW 109
// solds := solds diff i ;
109948: LD_ADDR_VAR 0 2
109952: PUSH
109953: LD_VAR 0 2
109957: PUSH
109958: LD_VAR 0 7
109962: DIFF
109963: ST_TO_ADDR
// continue ;
109964: GO 109751
// end ; end ;
109966: GO 109751
109968: POP
109969: POP
// until solds ;
109970: LD_VAR 0 2
109974: IFFALSE 109583
// MC_Reset ( base , 18 ) ;
109976: LD_VAR 0 1
109980: PPUSH
109981: LD_INT 18
109983: PPUSH
109984: CALL 24810 0 2
// end ;
109988: LD_VAR 0 4
109992: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
109993: LD_INT 0
109995: PPUSH
109996: PPUSH
109997: PPUSH
109998: PPUSH
109999: PPUSH
110000: PPUSH
110001: PPUSH
110002: PPUSH
110003: PPUSH
110004: PPUSH
110005: PPUSH
110006: PPUSH
110007: PPUSH
110008: PPUSH
110009: PPUSH
110010: PPUSH
110011: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
110012: LD_ADDR_VAR 0 13
110016: PUSH
110017: LD_EXP 90
110021: PUSH
110022: LD_VAR 0 1
110026: ARRAY
110027: PPUSH
110028: LD_INT 25
110030: PUSH
110031: LD_INT 3
110033: PUSH
110034: EMPTY
110035: LIST
110036: LIST
110037: PPUSH
110038: CALL_OW 72
110042: ST_TO_ADDR
// if mc_remote_driver [ base ] then
110043: LD_EXP 130
110047: PUSH
110048: LD_VAR 0 1
110052: ARRAY
110053: IFFALSE 110077
// mechs := mechs diff mc_remote_driver [ base ] ;
110055: LD_ADDR_VAR 0 13
110059: PUSH
110060: LD_VAR 0 13
110064: PUSH
110065: LD_EXP 130
110069: PUSH
110070: LD_VAR 0 1
110074: ARRAY
110075: DIFF
110076: ST_TO_ADDR
// for i in mechs do
110077: LD_ADDR_VAR 0 5
110081: PUSH
110082: LD_VAR 0 13
110086: PUSH
110087: FOR_IN
110088: IFFALSE 110123
// if GetTag ( i ) > 0 then
110090: LD_VAR 0 5
110094: PPUSH
110095: CALL_OW 110
110099: PUSH
110100: LD_INT 0
110102: GREATER
110103: IFFALSE 110121
// mechs := mechs diff i ;
110105: LD_ADDR_VAR 0 13
110109: PUSH
110110: LD_VAR 0 13
110114: PUSH
110115: LD_VAR 0 5
110119: DIFF
110120: ST_TO_ADDR
110121: GO 110087
110123: POP
110124: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
110125: LD_ADDR_VAR 0 9
110129: PUSH
110130: LD_EXP 90
110134: PUSH
110135: LD_VAR 0 1
110139: ARRAY
110140: PPUSH
110141: LD_INT 2
110143: PUSH
110144: LD_INT 25
110146: PUSH
110147: LD_INT 1
110149: PUSH
110150: EMPTY
110151: LIST
110152: LIST
110153: PUSH
110154: LD_INT 25
110156: PUSH
110157: LD_INT 5
110159: PUSH
110160: EMPTY
110161: LIST
110162: LIST
110163: PUSH
110164: LD_INT 25
110166: PUSH
110167: LD_INT 8
110169: PUSH
110170: EMPTY
110171: LIST
110172: LIST
110173: PUSH
110174: LD_INT 25
110176: PUSH
110177: LD_INT 9
110179: PUSH
110180: EMPTY
110181: LIST
110182: LIST
110183: PUSH
110184: EMPTY
110185: LIST
110186: LIST
110187: LIST
110188: LIST
110189: LIST
110190: PPUSH
110191: CALL_OW 72
110195: ST_TO_ADDR
// if not defenders and not solds then
110196: LD_VAR 0 2
110200: NOT
110201: PUSH
110202: LD_VAR 0 9
110206: NOT
110207: AND
110208: IFFALSE 110212
// exit ;
110210: GO 111838
// depot_under_attack := false ;
110212: LD_ADDR_VAR 0 17
110216: PUSH
110217: LD_INT 0
110219: ST_TO_ADDR
// sold_defenders := [ ] ;
110220: LD_ADDR_VAR 0 18
110224: PUSH
110225: EMPTY
110226: ST_TO_ADDR
// if mechs then
110227: LD_VAR 0 13
110231: IFFALSE 110360
// for i in defenders do
110233: LD_ADDR_VAR 0 5
110237: PUSH
110238: LD_VAR 0 2
110242: PUSH
110243: FOR_IN
110244: IFFALSE 110358
// begin SetTag ( i , 20 ) ;
110246: LD_VAR 0 5
110250: PPUSH
110251: LD_INT 20
110253: PPUSH
110254: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
110258: LD_VAR 0 5
110262: PPUSH
110263: CALL_OW 263
110267: PUSH
110268: LD_INT 1
110270: EQUAL
110271: PUSH
110272: LD_VAR 0 5
110276: PPUSH
110277: CALL_OW 311
110281: NOT
110282: AND
110283: PUSH
110284: LD_VAR 0 13
110288: AND
110289: IFFALSE 110356
// begin un := mechs [ 1 ] ;
110291: LD_ADDR_VAR 0 11
110295: PUSH
110296: LD_VAR 0 13
110300: PUSH
110301: LD_INT 1
110303: ARRAY
110304: ST_TO_ADDR
// ComExitBuilding ( un ) ;
110305: LD_VAR 0 11
110309: PPUSH
110310: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
110314: LD_VAR 0 11
110318: PPUSH
110319: LD_VAR 0 5
110323: PPUSH
110324: CALL_OW 180
// SetTag ( un , 19 ) ;
110328: LD_VAR 0 11
110332: PPUSH
110333: LD_INT 19
110335: PPUSH
110336: CALL_OW 109
// mechs := mechs diff un ;
110340: LD_ADDR_VAR 0 13
110344: PUSH
110345: LD_VAR 0 13
110349: PUSH
110350: LD_VAR 0 11
110354: DIFF
110355: ST_TO_ADDR
// end ; end ;
110356: GO 110243
110358: POP
110359: POP
// if solds then
110360: LD_VAR 0 9
110364: IFFALSE 110423
// for i in solds do
110366: LD_ADDR_VAR 0 5
110370: PUSH
110371: LD_VAR 0 9
110375: PUSH
110376: FOR_IN
110377: IFFALSE 110421
// if not GetTag ( i ) then
110379: LD_VAR 0 5
110383: PPUSH
110384: CALL_OW 110
110388: NOT
110389: IFFALSE 110419
// begin defenders := defenders union i ;
110391: LD_ADDR_VAR 0 2
110395: PUSH
110396: LD_VAR 0 2
110400: PUSH
110401: LD_VAR 0 5
110405: UNION
110406: ST_TO_ADDR
// SetTag ( i , 18 ) ;
110407: LD_VAR 0 5
110411: PPUSH
110412: LD_INT 18
110414: PPUSH
110415: CALL_OW 109
// end ;
110419: GO 110376
110421: POP
110422: POP
// repeat wait ( 0 0$1 ) ;
110423: LD_INT 35
110425: PPUSH
110426: CALL_OW 67
// enemy := mc_scan [ base ] ;
110430: LD_ADDR_VAR 0 3
110434: PUSH
110435: LD_EXP 113
110439: PUSH
110440: LD_VAR 0 1
110444: ARRAY
110445: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
110446: LD_EXP 90
110450: PUSH
110451: LD_VAR 0 1
110455: ARRAY
110456: NOT
110457: PUSH
110458: LD_EXP 90
110462: PUSH
110463: LD_VAR 0 1
110467: ARRAY
110468: PUSH
110469: EMPTY
110470: EQUAL
110471: OR
110472: IFFALSE 110509
// begin for i in defenders do
110474: LD_ADDR_VAR 0 5
110478: PUSH
110479: LD_VAR 0 2
110483: PUSH
110484: FOR_IN
110485: IFFALSE 110498
// ComStop ( i ) ;
110487: LD_VAR 0 5
110491: PPUSH
110492: CALL_OW 141
110496: GO 110484
110498: POP
110499: POP
// defenders := [ ] ;
110500: LD_ADDR_VAR 0 2
110504: PUSH
110505: EMPTY
110506: ST_TO_ADDR
// exit ;
110507: GO 111838
// end ; for i in defenders do
110509: LD_ADDR_VAR 0 5
110513: PUSH
110514: LD_VAR 0 2
110518: PUSH
110519: FOR_IN
110520: IFFALSE 111338
// begin e := NearestUnitToUnit ( enemy , i ) ;
110522: LD_ADDR_VAR 0 14
110526: PUSH
110527: LD_VAR 0 3
110531: PPUSH
110532: LD_VAR 0 5
110536: PPUSH
110537: CALL_OW 74
110541: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
110542: LD_ADDR_VAR 0 8
110546: PUSH
110547: LD_EXP 90
110551: PUSH
110552: LD_VAR 0 1
110556: ARRAY
110557: PPUSH
110558: LD_INT 2
110560: PUSH
110561: LD_INT 30
110563: PUSH
110564: LD_INT 0
110566: PUSH
110567: EMPTY
110568: LIST
110569: LIST
110570: PUSH
110571: LD_INT 30
110573: PUSH
110574: LD_INT 1
110576: PUSH
110577: EMPTY
110578: LIST
110579: LIST
110580: PUSH
110581: EMPTY
110582: LIST
110583: LIST
110584: LIST
110585: PPUSH
110586: CALL_OW 72
110590: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
110591: LD_ADDR_VAR 0 17
110595: PUSH
110596: LD_VAR 0 8
110600: NOT
110601: PUSH
110602: LD_VAR 0 8
110606: PPUSH
110607: LD_INT 3
110609: PUSH
110610: LD_INT 24
110612: PUSH
110613: LD_INT 600
110615: PUSH
110616: EMPTY
110617: LIST
110618: LIST
110619: PUSH
110620: EMPTY
110621: LIST
110622: LIST
110623: PPUSH
110624: CALL_OW 72
110628: OR
110629: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
110630: LD_VAR 0 5
110634: PPUSH
110635: CALL_OW 247
110639: PUSH
110640: LD_INT 2
110642: DOUBLE
110643: EQUAL
110644: IFTRUE 110648
110646: GO 111044
110648: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
110649: LD_VAR 0 5
110653: PPUSH
110654: CALL_OW 256
110658: PUSH
110659: LD_INT 650
110661: GREATER
110662: PUSH
110663: LD_VAR 0 5
110667: PPUSH
110668: LD_VAR 0 14
110672: PPUSH
110673: CALL_OW 296
110677: PUSH
110678: LD_INT 40
110680: LESS
110681: PUSH
110682: LD_VAR 0 14
110686: PPUSH
110687: LD_EXP 115
110691: PUSH
110692: LD_VAR 0 1
110696: ARRAY
110697: PPUSH
110698: CALL_OW 308
110702: OR
110703: AND
110704: IFFALSE 110826
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
110706: LD_VAR 0 5
110710: PPUSH
110711: CALL_OW 262
110715: PUSH
110716: LD_INT 1
110718: EQUAL
110719: PUSH
110720: LD_VAR 0 5
110724: PPUSH
110725: CALL_OW 261
110729: PUSH
110730: LD_INT 30
110732: LESS
110733: AND
110734: PUSH
110735: LD_VAR 0 8
110739: AND
110740: IFFALSE 110810
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
110742: LD_VAR 0 5
110746: PPUSH
110747: LD_VAR 0 8
110751: PPUSH
110752: LD_VAR 0 5
110756: PPUSH
110757: CALL_OW 74
110761: PPUSH
110762: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
110766: LD_VAR 0 5
110770: PPUSH
110771: LD_VAR 0 8
110775: PPUSH
110776: LD_VAR 0 5
110780: PPUSH
110781: CALL_OW 74
110785: PPUSH
110786: CALL_OW 296
110790: PUSH
110791: LD_INT 6
110793: LESS
110794: IFFALSE 110808
// SetFuel ( i , 100 ) ;
110796: LD_VAR 0 5
110800: PPUSH
110801: LD_INT 100
110803: PPUSH
110804: CALL_OW 240
// end else
110808: GO 110824
// ComAttackUnit ( i , e ) ;
110810: LD_VAR 0 5
110814: PPUSH
110815: LD_VAR 0 14
110819: PPUSH
110820: CALL_OW 115
// end else
110824: GO 110927
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
110826: LD_VAR 0 14
110830: PPUSH
110831: LD_EXP 115
110835: PUSH
110836: LD_VAR 0 1
110840: ARRAY
110841: PPUSH
110842: CALL_OW 308
110846: NOT
110847: PUSH
110848: LD_VAR 0 5
110852: PPUSH
110853: LD_VAR 0 14
110857: PPUSH
110858: CALL_OW 296
110862: PUSH
110863: LD_INT 40
110865: GREATEREQUAL
110866: AND
110867: PUSH
110868: LD_VAR 0 5
110872: PPUSH
110873: CALL_OW 256
110877: PUSH
110878: LD_INT 650
110880: LESSEQUAL
110881: OR
110882: PUSH
110883: LD_VAR 0 5
110887: PPUSH
110888: LD_EXP 114
110892: PUSH
110893: LD_VAR 0 1
110897: ARRAY
110898: PPUSH
110899: CALL_OW 308
110903: NOT
110904: AND
110905: IFFALSE 110927
// ComMoveToArea ( i , mc_parking [ base ] ) ;
110907: LD_VAR 0 5
110911: PPUSH
110912: LD_EXP 114
110916: PUSH
110917: LD_VAR 0 1
110921: ARRAY
110922: PPUSH
110923: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
110927: LD_VAR 0 5
110931: PPUSH
110932: CALL_OW 256
110936: PUSH
110937: LD_INT 998
110939: LESS
110940: PUSH
110941: LD_VAR 0 5
110945: PPUSH
110946: CALL_OW 263
110950: PUSH
110951: LD_INT 1
110953: EQUAL
110954: AND
110955: PUSH
110956: LD_VAR 0 5
110960: PPUSH
110961: CALL_OW 311
110965: AND
110966: PUSH
110967: LD_VAR 0 5
110971: PPUSH
110972: LD_EXP 114
110976: PUSH
110977: LD_VAR 0 1
110981: ARRAY
110982: PPUSH
110983: CALL_OW 308
110987: AND
110988: IFFALSE 111042
// begin mech := IsDrivenBy ( i ) ;
110990: LD_ADDR_VAR 0 10
110994: PUSH
110995: LD_VAR 0 5
110999: PPUSH
111000: CALL_OW 311
111004: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
111005: LD_VAR 0 10
111009: PPUSH
111010: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
111014: LD_VAR 0 10
111018: PPUSH
111019: LD_VAR 0 5
111023: PPUSH
111024: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
111028: LD_VAR 0 10
111032: PPUSH
111033: LD_VAR 0 5
111037: PPUSH
111038: CALL_OW 180
// end ; end ; unit_human :
111042: GO 111309
111044: LD_INT 1
111046: DOUBLE
111047: EQUAL
111048: IFTRUE 111052
111050: GO 111308
111052: POP
// begin b := IsInUnit ( i ) ;
111053: LD_ADDR_VAR 0 19
111057: PUSH
111058: LD_VAR 0 5
111062: PPUSH
111063: CALL_OW 310
111067: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
111068: LD_ADDR_VAR 0 20
111072: PUSH
111073: LD_VAR 0 19
111077: NOT
111078: PUSH
111079: LD_VAR 0 19
111083: PPUSH
111084: CALL_OW 266
111088: PUSH
111089: LD_INT 32
111091: PUSH
111092: LD_INT 31
111094: PUSH
111095: EMPTY
111096: LIST
111097: LIST
111098: IN
111099: OR
111100: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
111101: LD_VAR 0 17
111105: PUSH
111106: LD_VAR 0 2
111110: PPUSH
111111: LD_INT 21
111113: PUSH
111114: LD_INT 2
111116: PUSH
111117: EMPTY
111118: LIST
111119: LIST
111120: PPUSH
111121: CALL_OW 72
111125: PUSH
111126: LD_INT 1
111128: LESSEQUAL
111129: OR
111130: PUSH
111131: LD_VAR 0 20
111135: AND
111136: PUSH
111137: LD_VAR 0 5
111141: PUSH
111142: LD_VAR 0 18
111146: IN
111147: NOT
111148: AND
111149: IFFALSE 111242
// begin if b then
111151: LD_VAR 0 19
111155: IFFALSE 111204
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
111157: LD_VAR 0 19
111161: PPUSH
111162: LD_VAR 0 3
111166: PPUSH
111167: LD_VAR 0 19
111171: PPUSH
111172: CALL_OW 74
111176: PPUSH
111177: CALL_OW 296
111181: PUSH
111182: LD_INT 10
111184: LESS
111185: PUSH
111186: LD_VAR 0 19
111190: PPUSH
111191: CALL_OW 461
111195: PUSH
111196: LD_INT 7
111198: NONEQUAL
111199: AND
111200: IFFALSE 111204
// continue ;
111202: GO 110519
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
111204: LD_ADDR_VAR 0 18
111208: PUSH
111209: LD_VAR 0 18
111213: PPUSH
111214: LD_VAR 0 18
111218: PUSH
111219: LD_INT 1
111221: PLUS
111222: PPUSH
111223: LD_VAR 0 5
111227: PPUSH
111228: CALL_OW 1
111232: ST_TO_ADDR
// ComExitBuilding ( i ) ;
111233: LD_VAR 0 5
111237: PPUSH
111238: CALL_OW 122
// end ; if sold_defenders then
111242: LD_VAR 0 18
111246: IFFALSE 111306
// if i in sold_defenders then
111248: LD_VAR 0 5
111252: PUSH
111253: LD_VAR 0 18
111257: IN
111258: IFFALSE 111306
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
111260: LD_VAR 0 5
111264: PPUSH
111265: CALL_OW 314
111269: NOT
111270: PUSH
111271: LD_VAR 0 5
111275: PPUSH
111276: LD_VAR 0 14
111280: PPUSH
111281: CALL_OW 296
111285: PUSH
111286: LD_INT 30
111288: LESS
111289: AND
111290: IFFALSE 111306
// ComAttackUnit ( i , e ) ;
111292: LD_VAR 0 5
111296: PPUSH
111297: LD_VAR 0 14
111301: PPUSH
111302: CALL_OW 115
// end ; end ; end ;
111306: GO 111309
111308: POP
// if IsDead ( i ) then
111309: LD_VAR 0 5
111313: PPUSH
111314: CALL_OW 301
111318: IFFALSE 111336
// defenders := defenders diff i ;
111320: LD_ADDR_VAR 0 2
111324: PUSH
111325: LD_VAR 0 2
111329: PUSH
111330: LD_VAR 0 5
111334: DIFF
111335: ST_TO_ADDR
// end ;
111336: GO 110519
111338: POP
111339: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
111340: LD_VAR 0 3
111344: NOT
111345: PUSH
111346: LD_VAR 0 2
111350: NOT
111351: OR
111352: PUSH
111353: LD_EXP 90
111357: PUSH
111358: LD_VAR 0 1
111362: ARRAY
111363: NOT
111364: OR
111365: IFFALSE 110423
// MC_Reset ( base , 18 ) ;
111367: LD_VAR 0 1
111371: PPUSH
111372: LD_INT 18
111374: PPUSH
111375: CALL 24810 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
111379: LD_ADDR_VAR 0 2
111383: PUSH
111384: LD_VAR 0 2
111388: PUSH
111389: LD_VAR 0 2
111393: PPUSH
111394: LD_INT 2
111396: PUSH
111397: LD_INT 25
111399: PUSH
111400: LD_INT 1
111402: PUSH
111403: EMPTY
111404: LIST
111405: LIST
111406: PUSH
111407: LD_INT 25
111409: PUSH
111410: LD_INT 5
111412: PUSH
111413: EMPTY
111414: LIST
111415: LIST
111416: PUSH
111417: LD_INT 25
111419: PUSH
111420: LD_INT 8
111422: PUSH
111423: EMPTY
111424: LIST
111425: LIST
111426: PUSH
111427: LD_INT 25
111429: PUSH
111430: LD_INT 9
111432: PUSH
111433: EMPTY
111434: LIST
111435: LIST
111436: PUSH
111437: EMPTY
111438: LIST
111439: LIST
111440: LIST
111441: LIST
111442: LIST
111443: PPUSH
111444: CALL_OW 72
111448: DIFF
111449: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
111450: LD_VAR 0 3
111454: NOT
111455: PUSH
111456: LD_VAR 0 2
111460: PPUSH
111461: LD_INT 21
111463: PUSH
111464: LD_INT 2
111466: PUSH
111467: EMPTY
111468: LIST
111469: LIST
111470: PPUSH
111471: CALL_OW 72
111475: AND
111476: IFFALSE 111814
// begin tmp := FilterByTag ( defenders , 19 ) ;
111478: LD_ADDR_VAR 0 12
111482: PUSH
111483: LD_VAR 0 2
111487: PPUSH
111488: LD_INT 19
111490: PPUSH
111491: CALL 84262 0 2
111495: ST_TO_ADDR
// if tmp then
111496: LD_VAR 0 12
111500: IFFALSE 111570
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
111502: LD_ADDR_VAR 0 12
111506: PUSH
111507: LD_VAR 0 12
111511: PPUSH
111512: LD_INT 25
111514: PUSH
111515: LD_INT 3
111517: PUSH
111518: EMPTY
111519: LIST
111520: LIST
111521: PPUSH
111522: CALL_OW 72
111526: ST_TO_ADDR
// if tmp then
111527: LD_VAR 0 12
111531: IFFALSE 111570
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
111533: LD_ADDR_EXP 102
111537: PUSH
111538: LD_EXP 102
111542: PPUSH
111543: LD_VAR 0 1
111547: PPUSH
111548: LD_EXP 102
111552: PUSH
111553: LD_VAR 0 1
111557: ARRAY
111558: PUSH
111559: LD_VAR 0 12
111563: UNION
111564: PPUSH
111565: CALL_OW 1
111569: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
111570: LD_VAR 0 1
111574: PPUSH
111575: LD_INT 19
111577: PPUSH
111578: CALL 24810 0 2
// repeat wait ( 0 0$1 ) ;
111582: LD_INT 35
111584: PPUSH
111585: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
111589: LD_EXP 90
111593: PUSH
111594: LD_VAR 0 1
111598: ARRAY
111599: NOT
111600: PUSH
111601: LD_EXP 90
111605: PUSH
111606: LD_VAR 0 1
111610: ARRAY
111611: PUSH
111612: EMPTY
111613: EQUAL
111614: OR
111615: IFFALSE 111652
// begin for i in defenders do
111617: LD_ADDR_VAR 0 5
111621: PUSH
111622: LD_VAR 0 2
111626: PUSH
111627: FOR_IN
111628: IFFALSE 111641
// ComStop ( i ) ;
111630: LD_VAR 0 5
111634: PPUSH
111635: CALL_OW 141
111639: GO 111627
111641: POP
111642: POP
// defenders := [ ] ;
111643: LD_ADDR_VAR 0 2
111647: PUSH
111648: EMPTY
111649: ST_TO_ADDR
// exit ;
111650: GO 111838
// end ; for i in defenders do
111652: LD_ADDR_VAR 0 5
111656: PUSH
111657: LD_VAR 0 2
111661: PUSH
111662: FOR_IN
111663: IFFALSE 111752
// begin if not IsInArea ( i , mc_parking [ base ] ) then
111665: LD_VAR 0 5
111669: PPUSH
111670: LD_EXP 114
111674: PUSH
111675: LD_VAR 0 1
111679: ARRAY
111680: PPUSH
111681: CALL_OW 308
111685: NOT
111686: IFFALSE 111710
// ComMoveToArea ( i , mc_parking [ base ] ) else
111688: LD_VAR 0 5
111692: PPUSH
111693: LD_EXP 114
111697: PUSH
111698: LD_VAR 0 1
111702: ARRAY
111703: PPUSH
111704: CALL_OW 113
111708: GO 111750
// if GetControl ( i ) = control_manual then
111710: LD_VAR 0 5
111714: PPUSH
111715: CALL_OW 263
111719: PUSH
111720: LD_INT 1
111722: EQUAL
111723: IFFALSE 111750
// if IsDrivenBy ( i ) then
111725: LD_VAR 0 5
111729: PPUSH
111730: CALL_OW 311
111734: IFFALSE 111750
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
111736: LD_VAR 0 5
111740: PPUSH
111741: CALL_OW 311
111745: PPUSH
111746: CALL_OW 121
// end ;
111750: GO 111662
111752: POP
111753: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
111754: LD_VAR 0 2
111758: PPUSH
111759: LD_INT 95
111761: PUSH
111762: LD_EXP 114
111766: PUSH
111767: LD_VAR 0 1
111771: ARRAY
111772: PUSH
111773: EMPTY
111774: LIST
111775: LIST
111776: PPUSH
111777: CALL_OW 72
111781: PUSH
111782: LD_VAR 0 2
111786: EQUAL
111787: PUSH
111788: LD_EXP 113
111792: PUSH
111793: LD_VAR 0 1
111797: ARRAY
111798: OR
111799: PUSH
111800: LD_EXP 90
111804: PUSH
111805: LD_VAR 0 1
111809: ARRAY
111810: NOT
111811: OR
111812: IFFALSE 111582
// end ; MC_Reset ( base , 19 ) ;
111814: LD_VAR 0 1
111818: PPUSH
111819: LD_INT 19
111821: PPUSH
111822: CALL 24810 0 2
// MC_Reset ( base , 20 ) ;
111826: LD_VAR 0 1
111830: PPUSH
111831: LD_INT 20
111833: PPUSH
111834: CALL 24810 0 2
// end ; end_of_file
111838: LD_VAR 0 4
111842: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
111843: LD_VAR 0 1
111847: PUSH
111848: LD_INT 200
111850: DOUBLE
111851: GREATEREQUAL
111852: IFFALSE 111860
111854: LD_INT 299
111856: DOUBLE
111857: LESSEQUAL
111858: IFTRUE 111862
111860: GO 111894
111862: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
111863: LD_VAR 0 1
111867: PPUSH
111868: LD_VAR 0 2
111872: PPUSH
111873: LD_VAR 0 3
111877: PPUSH
111878: LD_VAR 0 4
111882: PPUSH
111883: LD_VAR 0 5
111887: PPUSH
111888: CALL 100848 0 5
111892: GO 111971
111894: LD_INT 300
111896: DOUBLE
111897: GREATEREQUAL
111898: IFFALSE 111906
111900: LD_INT 399
111902: DOUBLE
111903: LESSEQUAL
111904: IFTRUE 111908
111906: GO 111970
111908: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
111909: LD_VAR 0 1
111913: PPUSH
111914: LD_VAR 0 2
111918: PPUSH
111919: LD_VAR 0 3
111923: PPUSH
111924: LD_VAR 0 4
111928: PPUSH
111929: LD_VAR 0 5
111933: PPUSH
111934: LD_VAR 0 6
111938: PPUSH
111939: LD_VAR 0 7
111943: PPUSH
111944: LD_VAR 0 8
111948: PPUSH
111949: LD_VAR 0 9
111953: PPUSH
111954: LD_VAR 0 10
111958: PPUSH
111959: LD_VAR 0 11
111963: PPUSH
111964: CALL 98754 0 11
111968: GO 111971
111970: POP
// end ;
111971: PPOPN 11
111973: END
