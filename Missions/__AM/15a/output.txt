// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 73 0 0
// InitGlobalVariables ;
  15: CALL 20634 0 0
// InitMacro ;
  19: CALL 20802 0 0
// InitNature ;
  23: CALL 17304 0 0
// InitArtifact ;
  27: CALL 17917 0 0
// if debug then
  31: LD_EXP 1
  35: IFFALSE 44
// FogOff ( 1 ) ;
  37: LD_INT 1
  39: PPUSH
  40: CALL_OW 344
// PrepareAmerican ;
  44: CALL 4625 0 0
// PrepareAlliance ;
  48: CALL 1421 0 0
// PrepareArabian ;
  52: CALL 6393 0 0
// PrepareRussian ;
  56: CALL 8378 0 0
// PrepareLegion ;
  60: CALL 6821 0 0
// Action ;
  64: CALL 10931 0 0
// MC_Start ( ) ;
  68: CALL 22967 0 0
// end ;
  72: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export function InitVariables ; begin
  73: LD_INT 0
  75: PPUSH
// debug := false ;
  76: LD_ADDR_EXP 1
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  84: LD_ADDR_EXP 9
  88: PUSH
  89: LD_STRING 11_artifact_captured
  91: PPUSH
  92: LD_INT 0
  94: PPUSH
  95: CALL_OW 30
  99: ST_TO_ADDR
// russianDestroyed := false ;
 100: LD_ADDR_EXP 2
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// legionDestroyed := false ;
 108: LD_ADDR_EXP 3
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// americanDestroyed := false ;
 116: LD_ADDR_EXP 4
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// arabianDestroyed := false ;
 124: LD_ADDR_EXP 5
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// americanCapitulated := false ;
 132: LD_ADDR_EXP 6
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// russianCapitulated := false ;
 140: LD_ADDR_EXP 7
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// legionCapitulated := false ;
 148: LD_ADDR_EXP 8
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// artifactIResearched := false ;
 156: LD_ADDR_EXP 12
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// artifactIIResearched := false ;
 164: LD_ADDR_EXP 13
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// artifactIIIResearched := false ;
 172: LD_ADDR_EXP 14
 176: PUSH
 177: LD_INT 0
 179: ST_TO_ADDR
// alienSpotted := false ;
 180: LD_ADDR_EXP 10
 184: PUSH
 185: LD_INT 0
 187: ST_TO_ADDR
// spawnOmar := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 196: LD_ADDR_EXP 15
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 204: LD_ADDR_EXP 16
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// end ;
 212: LD_VAR 0 1
 216: RET
// export function CustomInitMacro ( ) ; begin
 217: LD_INT 0
 219: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 220: LD_ADDR_EXP 117
 224: PUSH
 225: LD_INT 26
 227: PUSH
 228: LD_INT 1
 230: PUSH
 231: LD_INT 4
 233: PUSH
 234: LD_INT 8
 236: PUSH
 237: EMPTY
 238: LIST
 239: LIST
 240: LIST
 241: LIST
 242: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 243: LD_ADDR_EXP 118
 247: PUSH
 248: LD_INT 27
 250: PUSH
 251: LD_INT 2
 253: PUSH
 254: LD_INT 3
 256: PUSH
 257: LD_INT 7
 259: PUSH
 260: EMPTY
 261: LIST
 262: LIST
 263: LIST
 264: LIST
 265: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 ] [ Difficulty ] , arabianMinefield ) ;
 266: LD_INT 1
 268: PPUSH
 269: LD_INT 6
 271: PUSH
 272: LD_INT 7
 274: PUSH
 275: LD_INT 9
 277: PUSH
 278: EMPTY
 279: LIST
 280: LIST
 281: LIST
 282: PUSH
 283: LD_OWVAR 67
 287: ARRAY
 288: PPUSH
 289: LD_INT 28
 291: PPUSH
 292: CALL 44440 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 296: LD_INT 1
 298: PPUSH
 299: LD_INT 10
 301: PUSH
 302: LD_INT 11
 304: PUSH
 305: LD_INT 13
 307: PUSH
 308: LD_INT 15
 310: PUSH
 311: EMPTY
 312: LIST
 313: LIST
 314: LIST
 315: LIST
 316: PPUSH
 317: CALL 45500 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 321: LD_INT 1
 323: PPUSH
 324: LD_INT 29
 326: PUSH
 327: EMPTY
 328: LIST
 329: PPUSH
 330: CALL 45593 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 334: LD_ADDR_EXP 122
 338: PUSH
 339: LD_EXP 122
 343: PPUSH
 344: LD_INT 1
 346: PPUSH
 347: LD_INT 22
 349: PUSH
 350: LD_INT 2
 352: PUSH
 353: EMPTY
 354: LIST
 355: LIST
 356: PUSH
 357: LD_INT 25
 359: PUSH
 360: LD_INT 15
 362: PUSH
 363: EMPTY
 364: LIST
 365: LIST
 366: PUSH
 367: EMPTY
 368: LIST
 369: LIST
 370: PPUSH
 371: CALL_OW 69
 375: PPUSH
 376: CALL_OW 1
 380: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 381: LD_INT 1
 383: PPUSH
 384: LD_INT 13
 386: PUSH
 387: LD_INT 2
 389: PUSH
 390: LD_INT 1
 392: PUSH
 393: LD_INT 31
 395: PUSH
 396: EMPTY
 397: LIST
 398: LIST
 399: LIST
 400: LIST
 401: PUSH
 402: LD_INT 13
 404: PUSH
 405: LD_INT 2
 407: PUSH
 408: LD_INT 1
 410: PUSH
 411: LD_INT 31
 413: PUSH
 414: EMPTY
 415: LIST
 416: LIST
 417: LIST
 418: LIST
 419: PUSH
 420: LD_INT 13
 422: PUSH
 423: LD_INT 1
 425: PUSH
 426: LD_INT 1
 428: PUSH
 429: LD_INT 28
 431: PUSH
 432: EMPTY
 433: LIST
 434: LIST
 435: LIST
 436: LIST
 437: PUSH
 438: LD_INT 13
 440: PUSH
 441: LD_INT 1
 443: PUSH
 444: LD_INT 1
 446: PUSH
 447: LD_INT 28
 449: PUSH
 450: EMPTY
 451: LIST
 452: LIST
 453: LIST
 454: LIST
 455: PUSH
 456: LD_INT 13
 458: PUSH
 459: LD_INT 1
 461: PUSH
 462: LD_INT 1
 464: PUSH
 465: LD_INT 28
 467: PUSH
 468: EMPTY
 469: LIST
 470: LIST
 471: LIST
 472: LIST
 473: PUSH
 474: LD_INT 13
 476: PUSH
 477: LD_INT 1
 479: PUSH
 480: LD_INT 1
 482: PUSH
 483: LD_INT 28
 485: PUSH
 486: EMPTY
 487: LIST
 488: LIST
 489: LIST
 490: LIST
 491: PUSH
 492: LD_INT 13
 494: PUSH
 495: LD_INT 1
 497: PUSH
 498: LD_INT 2
 500: PUSH
 501: LD_EXP 78
 505: PUSH
 506: EMPTY
 507: LIST
 508: LIST
 509: LIST
 510: LIST
 511: PUSH
 512: EMPTY
 513: LIST
 514: LIST
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: LIST
 520: PPUSH
 521: CALL 44758 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 525: LD_INT 1
 527: PPUSH
 528: LD_INT 4
 530: PPUSH
 531: CALL 44943 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 535: LD_INT 2
 537: PPUSH
 538: LD_INT 10
 540: PUSH
 541: LD_INT 11
 543: PUSH
 544: LD_INT 12
 546: PUSH
 547: LD_INT 14
 549: PUSH
 550: EMPTY
 551: LIST
 552: LIST
 553: LIST
 554: LIST
 555: PPUSH
 556: CALL 45500 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 560: LD_INT 2
 562: PPUSH
 563: LD_INT 14
 565: PUSH
 566: EMPTY
 567: LIST
 568: PPUSH
 569: CALL 45593 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 573: LD_INT 2
 575: PPUSH
 576: LD_INT 21
 578: PUSH
 579: LD_INT 3
 581: PUSH
 582: LD_INT 3
 584: PUSH
 585: LD_INT 51
 587: PUSH
 588: EMPTY
 589: LIST
 590: LIST
 591: LIST
 592: LIST
 593: PUSH
 594: LD_INT 22
 596: PUSH
 597: LD_INT 3
 599: PUSH
 600: LD_INT 3
 602: PUSH
 603: LD_INT 52
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: PUSH
 612: LD_INT 22
 614: PUSH
 615: LD_INT 3
 617: PUSH
 618: LD_INT 3
 620: PUSH
 621: LD_INT 52
 623: PUSH
 624: EMPTY
 625: LIST
 626: LIST
 627: LIST
 628: LIST
 629: PUSH
 630: LD_INT 24
 632: PUSH
 633: LD_INT 3
 635: PUSH
 636: LD_INT 3
 638: PUSH
 639: LD_INT 47
 641: PUSH
 642: EMPTY
 643: LIST
 644: LIST
 645: LIST
 646: LIST
 647: PUSH
 648: LD_INT 24
 650: PUSH
 651: LD_INT 3
 653: PUSH
 654: LD_INT 3
 656: PUSH
 657: LD_INT 47
 659: PUSH
 660: EMPTY
 661: LIST
 662: LIST
 663: LIST
 664: LIST
 665: PUSH
 666: LD_INT 24
 668: PUSH
 669: LD_INT 3
 671: PUSH
 672: LD_INT 3
 674: PUSH
 675: LD_INT 47
 677: PUSH
 678: EMPTY
 679: LIST
 680: LIST
 681: LIST
 682: LIST
 683: PUSH
 684: LD_INT 24
 686: PUSH
 687: LD_INT 3
 689: PUSH
 690: LD_INT 3
 692: PUSH
 693: LD_INT 47
 695: PUSH
 696: EMPTY
 697: LIST
 698: LIST
 699: LIST
 700: LIST
 701: PUSH
 702: LD_INT 24
 704: PUSH
 705: LD_INT 3
 707: PUSH
 708: LD_INT 3
 710: PUSH
 711: LD_INT 47
 713: PUSH
 714: EMPTY
 715: LIST
 716: LIST
 717: LIST
 718: LIST
 719: PUSH
 720: EMPTY
 721: LIST
 722: LIST
 723: LIST
 724: LIST
 725: LIST
 726: LIST
 727: LIST
 728: LIST
 729: PPUSH
 730: CALL 44758 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 734: LD_INT 2
 736: PPUSH
 737: LD_INT 5
 739: PPUSH
 740: CALL 44943 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 744: LD_INT 2
 746: PPUSH
 747: LD_INT 0
 749: PPUSH
 750: CALL 45373 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 754: LD_INT 3
 756: PPUSH
 757: LD_INT 10
 759: PUSH
 760: LD_INT 12
 762: PUSH
 763: LD_INT 15
 765: PUSH
 766: EMPTY
 767: LIST
 768: LIST
 769: LIST
 770: PUSH
 771: LD_OWVAR 67
 775: ARRAY
 776: PPUSH
 777: LD_INT 24
 779: PPUSH
 780: CALL 44440 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 784: LD_INT 3
 786: PPUSH
 787: LD_INT 10
 789: PUSH
 790: LD_INT 11
 792: PUSH
 793: LD_INT 13
 795: PUSH
 796: LD_INT 15
 798: PUSH
 799: EMPTY
 800: LIST
 801: LIST
 802: LIST
 803: LIST
 804: PPUSH
 805: CALL 45500 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 809: LD_INT 3
 811: PPUSH
 812: LD_INT 13
 814: PUSH
 815: EMPTY
 816: LIST
 817: PPUSH
 818: CALL 45593 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 822: LD_ADDR_EXP 122
 826: PUSH
 827: LD_EXP 122
 831: PPUSH
 832: LD_INT 3
 834: PPUSH
 835: LD_INT 22
 837: PUSH
 838: LD_INT 8
 840: PUSH
 841: EMPTY
 842: LIST
 843: LIST
 844: PUSH
 845: LD_INT 25
 847: PUSH
 848: LD_INT 15
 850: PUSH
 851: EMPTY
 852: LIST
 853: LIST
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: PPUSH
 859: CALL_OW 69
 863: PPUSH
 864: CALL_OW 1
 868: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 869: LD_INT 3
 871: PPUSH
 872: LD_INT 13
 874: PUSH
 875: LD_INT 2
 877: PUSH
 878: LD_INT 1
 880: PUSH
 881: LD_INT 31
 883: PUSH
 884: EMPTY
 885: LIST
 886: LIST
 887: LIST
 888: LIST
 889: PUSH
 890: LD_INT 13
 892: PUSH
 893: LD_INT 2
 895: PUSH
 896: LD_INT 1
 898: PUSH
 899: LD_INT 31
 901: PUSH
 902: EMPTY
 903: LIST
 904: LIST
 905: LIST
 906: LIST
 907: PUSH
 908: LD_INT 13
 910: PUSH
 911: LD_INT 3
 913: PUSH
 914: LD_INT 2
 916: PUSH
 917: LD_INT 32
 919: PUSH
 920: EMPTY
 921: LIST
 922: LIST
 923: LIST
 924: LIST
 925: PUSH
 926: LD_INT 14
 928: PUSH
 929: LD_INT 1
 931: PUSH
 932: LD_INT 1
 934: PUSH
 935: LD_INT 28
 937: PUSH
 938: EMPTY
 939: LIST
 940: LIST
 941: LIST
 942: LIST
 943: PUSH
 944: LD_INT 14
 946: PUSH
 947: LD_INT 1
 949: PUSH
 950: LD_INT 1
 952: PUSH
 953: LD_INT 28
 955: PUSH
 956: EMPTY
 957: LIST
 958: LIST
 959: LIST
 960: LIST
 961: PUSH
 962: LD_INT 14
 964: PUSH
 965: LD_INT 1
 967: PUSH
 968: LD_INT 1
 970: PUSH
 971: LD_INT 28
 973: PUSH
 974: EMPTY
 975: LIST
 976: LIST
 977: LIST
 978: LIST
 979: PUSH
 980: LD_INT 14
 982: PUSH
 983: LD_INT 1
 985: PUSH
 986: LD_INT 1
 988: PUSH
 989: LD_INT 28
 991: PUSH
 992: EMPTY
 993: LIST
 994: LIST
 995: LIST
 996: LIST
 997: PUSH
 998: LD_INT 14
1000: PUSH
1001: LD_INT 1
1003: PUSH
1004: LD_INT 2
1006: PUSH
1007: LD_EXP 78
1011: PUSH
1012: EMPTY
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: PUSH
1018: EMPTY
1019: LIST
1020: LIST
1021: LIST
1022: LIST
1023: LIST
1024: LIST
1025: LIST
1026: LIST
1027: PPUSH
1028: CALL 44758 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
1032: LD_INT 3
1034: PPUSH
1035: LD_INT 4
1037: PPUSH
1038: CALL 44943 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
1042: LD_INT 4
1044: PPUSH
1045: LD_INT 10
1047: PUSH
1048: LD_INT 12
1050: PUSH
1051: LD_INT 11
1053: PUSH
1054: LD_INT 15
1056: PUSH
1057: EMPTY
1058: LIST
1059: LIST
1060: LIST
1061: LIST
1062: PPUSH
1063: CALL 45500 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1067: LD_INT 4
1069: PPUSH
1070: LD_INT 33
1072: PUSH
1073: EMPTY
1074: LIST
1075: PPUSH
1076: CALL 45593 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1080: LD_INT 4
1082: PPUSH
1083: LD_INT 5
1085: PUSH
1086: LD_INT 6
1088: PUSH
1089: LD_INT 7
1091: PUSH
1092: LD_INT 9
1094: PUSH
1095: LD_INT 10
1097: PUSH
1098: EMPTY
1099: LIST
1100: LIST
1101: LIST
1102: LIST
1103: LIST
1104: PPUSH
1105: CALL 45911 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1109: LD_INT 4
1111: PPUSH
1112: LD_INT 54
1114: PPUSH
1115: LD_INT 85
1117: PPUSH
1118: LD_INT 2
1120: PPUSH
1121: LD_INT 25
1123: PUSH
1124: LD_INT 16
1126: PUSH
1127: LD_INT 17
1129: PUSH
1130: LD_INT 18
1132: PUSH
1133: LD_INT 22
1135: PUSH
1136: EMPTY
1137: LIST
1138: LIST
1139: LIST
1140: LIST
1141: LIST
1142: PPUSH
1143: CALL 45705 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1147: LD_INT 4
1149: PPUSH
1150: LD_INT 5
1152: PUSH
1153: LD_INT 1
1155: PUSH
1156: LD_INT 1
1158: PUSH
1159: LD_INT 7
1161: PUSH
1162: EMPTY
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: PUSH
1168: LD_INT 5
1170: PUSH
1171: LD_INT 1
1173: PUSH
1174: LD_INT 1
1176: PUSH
1177: LD_INT 6
1179: PUSH
1180: EMPTY
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 5
1188: PUSH
1189: LD_INT 1
1191: PUSH
1192: LD_INT 1
1194: PUSH
1195: LD_INT 7
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: PUSH
1204: LD_INT 5
1206: PUSH
1207: LD_INT 1
1209: PUSH
1210: LD_INT 1
1212: PUSH
1213: LD_INT 6
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_INT 5
1224: PUSH
1225: LD_INT 1
1227: PUSH
1228: LD_INT 3
1230: PUSH
1231: LD_INT 12
1233: PUSH
1234: EMPTY
1235: LIST
1236: LIST
1237: LIST
1238: LIST
1239: PUSH
1240: LD_INT 3
1242: PUSH
1243: LD_INT 1
1245: PUSH
1246: LD_INT 3
1248: PUSH
1249: LD_INT 13
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: PUSH
1258: EMPTY
1259: LIST
1260: LIST
1261: LIST
1262: LIST
1263: LIST
1264: LIST
1265: PPUSH
1266: CALL 44758 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1270: LD_INT 4
1272: PPUSH
1273: LD_INT 4
1275: PPUSH
1276: CALL 44943 0 2
// MC_SetTame ( 4 , powellApe ) ;
1280: LD_INT 4
1282: PPUSH
1283: LD_INT 11
1285: PPUSH
1286: CALL 45324 0 2
// end ;
1290: LD_VAR 0 1
1294: RET
// every 0 0$1 trigger debug do var i ;
1295: LD_EXP 1
1299: IFFALSE 1397
1301: GO 1303
1303: DISABLE
1304: LD_INT 0
1306: PPUSH
// begin enable ;
1307: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1308: LD_ADDR_VAR 0 1
1312: PUSH
1313: LD_INT 22
1315: PUSH
1316: LD_INT 7
1318: PUSH
1319: EMPTY
1320: LIST
1321: LIST
1322: PUSH
1323: LD_INT 2
1325: PUSH
1326: LD_INT 21
1328: PUSH
1329: LD_INT 1
1331: PUSH
1332: EMPTY
1333: LIST
1334: LIST
1335: PUSH
1336: LD_INT 21
1338: PUSH
1339: LD_INT 2
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: PUSH
1346: EMPTY
1347: LIST
1348: LIST
1349: LIST
1350: PUSH
1351: LD_INT 3
1353: PUSH
1354: LD_INT 24
1356: PUSH
1357: LD_INT 1000
1359: PUSH
1360: EMPTY
1361: LIST
1362: LIST
1363: PUSH
1364: EMPTY
1365: LIST
1366: LIST
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: LIST
1372: PPUSH
1373: CALL_OW 69
1377: PUSH
1378: FOR_IN
1379: IFFALSE 1395
// SetLives ( i , 1000 ) ;
1381: LD_VAR 0 1
1385: PPUSH
1386: LD_INT 1000
1388: PPUSH
1389: CALL_OW 234
1393: GO 1378
1395: POP
1396: POP
// end ;
1397: PPOPN 1
1399: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1400: LD_EXP 16
1404: PUSH
1405: LD_INT 5
1407: GREATEREQUAL
1408: IFFALSE 1420
1410: GO 1412
1412: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1413: LD_STRING ACH_ARTIFACT
1415: PPUSH
1416: CALL_OW 543
1420: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1421: LD_INT 0
1423: PPUSH
1424: PPUSH
1425: PPUSH
1426: PPUSH
1427: PPUSH
// uc_side := 7 ;
1428: LD_ADDR_OWVAR 20
1432: PUSH
1433: LD_INT 7
1435: ST_TO_ADDR
// tmp := [ ] ;
1436: LD_ADDR_VAR 0 5
1440: PUSH
1441: EMPTY
1442: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1443: LD_ADDR_EXP 17
1447: PUSH
1448: LD_STRING JMM
1450: PPUSH
1451: LD_EXP 1
1455: NOT
1456: PPUSH
1457: LD_STRING 14a_
1459: PPUSH
1460: CALL 51212 0 3
1464: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1465: LD_ADDR_EXP 49
1469: PUSH
1470: LD_STRING Burlak
1472: PPUSH
1473: LD_EXP 1
1477: NOT
1478: PPUSH
1479: LD_STRING 14a_
1481: PPUSH
1482: CALL 51212 0 3
1486: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1487: LD_ADDR_EXP 32
1491: PUSH
1492: LD_STRING Joan
1494: PPUSH
1495: LD_EXP 1
1499: NOT
1500: PPUSH
1501: LD_STRING 13a_
1503: PPUSH
1504: CALL 51212 0 3
1508: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1509: LD_ADDR_EXP 18
1513: PUSH
1514: LD_STRING Roth
1516: PPUSH
1517: LD_EXP 1
1521: NOT
1522: PPUSH
1523: LD_STRING 13a_
1525: PPUSH
1526: CALL 51212 0 3
1530: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1531: LD_ADDR_EXP 35
1535: PUSH
1536: LD_STRING Gossudarov
1538: PPUSH
1539: LD_EXP 1
1543: NOT
1544: PPUSH
1545: LD_STRING 13a_
1547: PPUSH
1548: CALL 51212 0 3
1552: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1553: LD_ADDR_EXP 23
1557: PUSH
1558: LD_STRING Denis
1560: PPUSH
1561: LD_EXP 1
1565: NOT
1566: PPUSH
1567: LD_STRING 13a_
1569: PPUSH
1570: CALL 51212 0 3
1574: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1575: LD_ADDR_EXP 33
1579: PUSH
1580: LD_STRING DeltaDoctor
1582: PPUSH
1583: LD_EXP 1
1587: NOT
1588: PPUSH
1589: LD_STRING 13a_
1591: PPUSH
1592: CALL 51212 0 3
1596: ST_TO_ADDR
// if DeltaDoctor then
1597: LD_EXP 33
1601: IFFALSE 1619
// tmp := tmp ^ DeltaDoctor ;
1603: LD_ADDR_VAR 0 5
1607: PUSH
1608: LD_VAR 0 5
1612: PUSH
1613: LD_EXP 33
1617: ADD
1618: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1619: LD_ADDR_EXP 31
1623: PUSH
1624: LD_STRING Simms
1626: PPUSH
1627: LD_EXP 1
1631: NOT
1632: PPUSH
1633: LD_STRING 13a_
1635: PPUSH
1636: CALL 51212 0 3
1640: ST_TO_ADDR
// if Simms then
1641: LD_EXP 31
1645: IFFALSE 1663
// tmp := tmp ^ Simms ;
1647: LD_ADDR_VAR 0 5
1651: PUSH
1652: LD_VAR 0 5
1656: PUSH
1657: LD_EXP 31
1661: ADD
1662: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1663: LD_ADDR_EXP 29
1667: PUSH
1668: LD_STRING Frank
1670: PPUSH
1671: LD_EXP 1
1675: NOT
1676: PPUSH
1677: LD_STRING 13a_
1679: PPUSH
1680: CALL 51212 0 3
1684: ST_TO_ADDR
// if Frank then
1685: LD_EXP 29
1689: IFFALSE 1707
// tmp := tmp ^ Frank ;
1691: LD_ADDR_VAR 0 5
1695: PUSH
1696: LD_VAR 0 5
1700: PUSH
1701: LD_EXP 29
1705: ADD
1706: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1707: LD_ADDR_EXP 36
1711: PUSH
1712: LD_STRING Kirilenkova
1714: PPUSH
1715: LD_EXP 1
1719: NOT
1720: PPUSH
1721: LD_STRING 13a_
1723: PPUSH
1724: CALL 51212 0 3
1728: ST_TO_ADDR
// if Kirilenkova then
1729: LD_EXP 36
1733: IFFALSE 1751
// tmp := tmp ^ Kirilenkova ;
1735: LD_ADDR_VAR 0 5
1739: PUSH
1740: LD_VAR 0 5
1744: PUSH
1745: LD_EXP 36
1749: ADD
1750: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1751: LD_ADDR_EXP 37
1755: PUSH
1756: LD_STRING Titov
1758: PPUSH
1759: LD_EXP 1
1763: NOT
1764: PPUSH
1765: LD_STRING 13a_
1767: PPUSH
1768: CALL 51212 0 3
1772: ST_TO_ADDR
// if Titov then
1773: LD_EXP 37
1777: IFFALSE 1795
// tmp := tmp ^ Titov ;
1779: LD_ADDR_VAR 0 5
1783: PUSH
1784: LD_VAR 0 5
1788: PUSH
1789: LD_EXP 37
1793: ADD
1794: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1795: LD_ADDR_EXP 38
1799: PUSH
1800: LD_STRING Fadeev
1802: PPUSH
1803: LD_EXP 1
1807: NOT
1808: PPUSH
1809: LD_STRING 13a_
1811: PPUSH
1812: CALL 51212 0 3
1816: ST_TO_ADDR
// if Fadeev then
1817: LD_EXP 38
1821: IFFALSE 1839
// tmp := tmp ^ Fadeev ;
1823: LD_ADDR_VAR 0 5
1827: PUSH
1828: LD_VAR 0 5
1832: PUSH
1833: LD_EXP 38
1837: ADD
1838: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1839: LD_ADDR_EXP 39
1843: PUSH
1844: LD_STRING Dolgov
1846: PPUSH
1847: LD_EXP 1
1851: NOT
1852: PPUSH
1853: LD_STRING 13a_
1855: PPUSH
1856: CALL 51212 0 3
1860: ST_TO_ADDR
// if Dolgov then
1861: LD_EXP 39
1865: IFFALSE 1883
// tmp := tmp ^ Dolgov ;
1867: LD_ADDR_VAR 0 5
1871: PUSH
1872: LD_VAR 0 5
1876: PUSH
1877: LD_EXP 39
1881: ADD
1882: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1883: LD_ADDR_EXP 40
1887: PUSH
1888: LD_STRING Petrosyan
1890: PPUSH
1891: LD_EXP 1
1895: NOT
1896: PPUSH
1897: LD_STRING 13a_
1899: PPUSH
1900: CALL 51212 0 3
1904: ST_TO_ADDR
// if Petrosyan then
1905: LD_EXP 40
1909: IFFALSE 1927
// tmp := tmp ^ Petrosyan ;
1911: LD_ADDR_VAR 0 5
1915: PUSH
1916: LD_VAR 0 5
1920: PUSH
1921: LD_EXP 40
1925: ADD
1926: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1927: LD_ADDR_EXP 41
1931: PUSH
1932: LD_STRING Scholtze
1934: PPUSH
1935: LD_EXP 1
1939: NOT
1940: PPUSH
1941: LD_STRING 13a_
1943: PPUSH
1944: CALL 51212 0 3
1948: ST_TO_ADDR
// if Scholtze then
1949: LD_EXP 41
1953: IFFALSE 1971
// tmp := tmp ^ Scholtze ;
1955: LD_ADDR_VAR 0 5
1959: PUSH
1960: LD_VAR 0 5
1964: PUSH
1965: LD_EXP 41
1969: ADD
1970: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
1971: LD_ADDR_EXP 42
1975: PUSH
1976: LD_STRING Oblukov
1978: PPUSH
1979: LD_EXP 1
1983: NOT
1984: PPUSH
1985: LD_STRING 13a_
1987: PPUSH
1988: CALL 51212 0 3
1992: ST_TO_ADDR
// if Oblukov then
1993: LD_EXP 42
1997: IFFALSE 2015
// tmp := tmp ^ Oblukov ;
1999: LD_ADDR_VAR 0 5
2003: PUSH
2004: LD_VAR 0 5
2008: PUSH
2009: LD_EXP 42
2013: ADD
2014: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
2015: LD_ADDR_EXP 43
2019: PUSH
2020: LD_STRING Kapitsova
2022: PPUSH
2023: LD_EXP 1
2027: NOT
2028: PPUSH
2029: LD_STRING 13a_
2031: PPUSH
2032: CALL 51212 0 3
2036: ST_TO_ADDR
// if Kapitsova then
2037: LD_EXP 43
2041: IFFALSE 2059
// tmp := tmp ^ Kapitsova ;
2043: LD_ADDR_VAR 0 5
2047: PUSH
2048: LD_VAR 0 5
2052: PUSH
2053: LD_EXP 43
2057: ADD
2058: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2059: LD_ADDR_EXP 44
2063: PUSH
2064: LD_STRING Lipshchin
2066: PPUSH
2067: LD_EXP 1
2071: NOT
2072: PPUSH
2073: LD_STRING 13a_
2075: PPUSH
2076: CALL 51212 0 3
2080: ST_TO_ADDR
// if Lipshchin then
2081: LD_EXP 44
2085: IFFALSE 2103
// tmp := tmp ^ Lipshchin ;
2087: LD_ADDR_VAR 0 5
2091: PUSH
2092: LD_VAR 0 5
2096: PUSH
2097: LD_EXP 44
2101: ADD
2102: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2103: LD_ADDR_EXP 45
2107: PUSH
2108: LD_STRING Petrovova
2110: PPUSH
2111: LD_EXP 1
2115: NOT
2116: PPUSH
2117: LD_STRING 13a_
2119: PPUSH
2120: CALL 51212 0 3
2124: ST_TO_ADDR
// if Petrovova then
2125: LD_EXP 45
2129: IFFALSE 2147
// tmp := tmp ^ Petrovova ;
2131: LD_ADDR_VAR 0 5
2135: PUSH
2136: LD_VAR 0 5
2140: PUSH
2141: LD_EXP 45
2145: ADD
2146: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2147: LD_ADDR_EXP 46
2151: PUSH
2152: LD_STRING Kovalyuk
2154: PPUSH
2155: LD_EXP 1
2159: NOT
2160: PPUSH
2161: LD_STRING 13a_
2163: PPUSH
2164: CALL 51212 0 3
2168: ST_TO_ADDR
// if Kovalyuk then
2169: LD_EXP 46
2173: IFFALSE 2191
// tmp := tmp ^ Kovalyuk ;
2175: LD_ADDR_VAR 0 5
2179: PUSH
2180: LD_VAR 0 5
2184: PUSH
2185: LD_EXP 46
2189: ADD
2190: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2191: LD_ADDR_EXP 47
2195: PUSH
2196: LD_STRING Kuzmov
2198: PPUSH
2199: LD_EXP 1
2203: NOT
2204: PPUSH
2205: LD_STRING 13a_
2207: PPUSH
2208: CALL 51212 0 3
2212: ST_TO_ADDR
// if Kuzmov then
2213: LD_EXP 47
2217: IFFALSE 2235
// tmp := tmp ^ Kuzmov ;
2219: LD_ADDR_VAR 0 5
2223: PUSH
2224: LD_VAR 0 5
2228: PUSH
2229: LD_EXP 47
2233: ADD
2234: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2235: LD_ADDR_EXP 48
2239: PUSH
2240: LD_STRING Karamazov
2242: PPUSH
2243: LD_EXP 1
2247: NOT
2248: PPUSH
2249: LD_STRING 13a_
2251: PPUSH
2252: CALL 51212 0 3
2256: ST_TO_ADDR
// if Karamazov then
2257: LD_EXP 48
2261: IFFALSE 2279
// tmp := tmp ^ Karamazov ;
2263: LD_ADDR_VAR 0 5
2267: PUSH
2268: LD_VAR 0 5
2272: PUSH
2273: LD_EXP 48
2277: ADD
2278: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2279: LD_ADDR_EXP 50
2283: PUSH
2284: LD_STRING Belkov
2286: PPUSH
2287: LD_EXP 1
2291: NOT
2292: PPUSH
2293: LD_STRING 13a_
2295: PPUSH
2296: CALL 51212 0 3
2300: ST_TO_ADDR
// if Belkov then
2301: LD_EXP 50
2305: IFFALSE 2323
// tmp := tmp ^ Belkov ;
2307: LD_ADDR_VAR 0 5
2311: PUSH
2312: LD_VAR 0 5
2316: PUSH
2317: LD_EXP 50
2321: ADD
2322: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2323: LD_ADDR_EXP 51
2327: PUSH
2328: LD_STRING Gnyevko
2330: PPUSH
2331: LD_EXP 1
2335: NOT
2336: PPUSH
2337: LD_STRING 13a_
2339: PPUSH
2340: CALL 51212 0 3
2344: ST_TO_ADDR
// if Gnyevko then
2345: LD_EXP 51
2349: IFFALSE 2367
// tmp := tmp ^ Gnyevko ;
2351: LD_ADDR_VAR 0 5
2355: PUSH
2356: LD_VAR 0 5
2360: PUSH
2361: LD_EXP 51
2365: ADD
2366: ST_TO_ADDR
// Connie = NewCharacter ( Coonie ) ;
2367: LD_ADDR_EXP 34
2371: PUSH
2372: LD_STRING Coonie
2374: PPUSH
2375: CALL_OW 25
2379: ST_TO_ADDR
// if not Lisa then
2380: LD_EXP 19
2384: NOT
2385: IFFALSE 2431
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2387: LD_ADDR_EXP 19
2391: PUSH
2392: LD_STRING Lisa
2394: PPUSH
2395: LD_EXP 1
2399: NOT
2400: PPUSH
2401: LD_STRING 13a_
2403: PPUSH
2404: CALL 51212 0 3
2408: ST_TO_ADDR
// if Lisa then
2409: LD_EXP 19
2413: IFFALSE 2431
// tmp := tmp ^ Lisa ;
2415: LD_ADDR_VAR 0 5
2419: PUSH
2420: LD_VAR 0 5
2424: PUSH
2425: LD_EXP 19
2429: ADD
2430: ST_TO_ADDR
// end ; if not Donaldson then
2431: LD_EXP 20
2435: NOT
2436: IFFALSE 2482
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2438: LD_ADDR_EXP 20
2442: PUSH
2443: LD_STRING Donaldson
2445: PPUSH
2446: LD_EXP 1
2450: NOT
2451: PPUSH
2452: LD_STRING 13a_
2454: PPUSH
2455: CALL 51212 0 3
2459: ST_TO_ADDR
// if Donaldson then
2460: LD_EXP 20
2464: IFFALSE 2482
// tmp := tmp ^ Donaldson ;
2466: LD_ADDR_VAR 0 5
2470: PUSH
2471: LD_VAR 0 5
2475: PUSH
2476: LD_EXP 20
2480: ADD
2481: ST_TO_ADDR
// end ; if not Bobby then
2482: LD_EXP 21
2486: NOT
2487: IFFALSE 2533
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2489: LD_ADDR_EXP 21
2493: PUSH
2494: LD_STRING Bobby
2496: PPUSH
2497: LD_EXP 1
2501: NOT
2502: PPUSH
2503: LD_STRING 13a_
2505: PPUSH
2506: CALL 51212 0 3
2510: ST_TO_ADDR
// if Bobby then
2511: LD_EXP 21
2515: IFFALSE 2533
// tmp := tmp ^ Bobby ;
2517: LD_ADDR_VAR 0 5
2521: PUSH
2522: LD_VAR 0 5
2526: PUSH
2527: LD_EXP 21
2531: ADD
2532: ST_TO_ADDR
// end ; if not Cyrus then
2533: LD_EXP 22
2537: NOT
2538: IFFALSE 2584
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2540: LD_ADDR_EXP 22
2544: PUSH
2545: LD_STRING Cyrus
2547: PPUSH
2548: LD_EXP 1
2552: NOT
2553: PPUSH
2554: LD_STRING 13a_
2556: PPUSH
2557: CALL 51212 0 3
2561: ST_TO_ADDR
// if Cyrus then
2562: LD_EXP 22
2566: IFFALSE 2584
// tmp := tmp ^ Cyrus ;
2568: LD_ADDR_VAR 0 5
2572: PUSH
2573: LD_VAR 0 5
2577: PUSH
2578: LD_EXP 22
2582: ADD
2583: ST_TO_ADDR
// end ; if not Brown then
2584: LD_EXP 24
2588: NOT
2589: IFFALSE 2635
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2591: LD_ADDR_EXP 24
2595: PUSH
2596: LD_STRING Brown
2598: PPUSH
2599: LD_EXP 1
2603: NOT
2604: PPUSH
2605: LD_STRING 13a_
2607: PPUSH
2608: CALL 51212 0 3
2612: ST_TO_ADDR
// if Brown then
2613: LD_EXP 24
2617: IFFALSE 2635
// tmp := tmp ^ Brown ;
2619: LD_ADDR_VAR 0 5
2623: PUSH
2624: LD_VAR 0 5
2628: PUSH
2629: LD_EXP 24
2633: ADD
2634: ST_TO_ADDR
// end ; if not Gladstone then
2635: LD_EXP 25
2639: NOT
2640: IFFALSE 2686
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2642: LD_ADDR_EXP 25
2646: PUSH
2647: LD_STRING Gladstone
2649: PPUSH
2650: LD_EXP 1
2654: NOT
2655: PPUSH
2656: LD_STRING 13a_
2658: PPUSH
2659: CALL 51212 0 3
2663: ST_TO_ADDR
// if Gladstone then
2664: LD_EXP 25
2668: IFFALSE 2686
// tmp := tmp ^ Gladstone ;
2670: LD_ADDR_VAR 0 5
2674: PUSH
2675: LD_VAR 0 5
2679: PUSH
2680: LD_EXP 25
2684: ADD
2685: ST_TO_ADDR
// end ; if not Cornel then
2686: LD_EXP 27
2690: NOT
2691: IFFALSE 2737
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2693: LD_ADDR_EXP 27
2697: PUSH
2698: LD_STRING Cornel
2700: PPUSH
2701: LD_EXP 1
2705: NOT
2706: PPUSH
2707: LD_STRING 13a_
2709: PPUSH
2710: CALL 51212 0 3
2714: ST_TO_ADDR
// if Cornel then
2715: LD_EXP 27
2719: IFFALSE 2737
// tmp := tmp ^ Cornel ;
2721: LD_ADDR_VAR 0 5
2725: PUSH
2726: LD_VAR 0 5
2730: PUSH
2731: LD_EXP 27
2735: ADD
2736: ST_TO_ADDR
// end ; if not Houten then
2737: LD_EXP 26
2741: NOT
2742: IFFALSE 2788
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2744: LD_ADDR_EXP 26
2748: PUSH
2749: LD_STRING Houten
2751: PPUSH
2752: LD_EXP 1
2756: NOT
2757: PPUSH
2758: LD_STRING 13a_
2760: PPUSH
2761: CALL 51212 0 3
2765: ST_TO_ADDR
// if Houten then
2766: LD_EXP 26
2770: IFFALSE 2788
// tmp := tmp ^ Houten ;
2772: LD_ADDR_VAR 0 5
2776: PUSH
2777: LD_VAR 0 5
2781: PUSH
2782: LD_EXP 26
2786: ADD
2787: ST_TO_ADDR
// end ; if not Gary then
2788: LD_EXP 28
2792: NOT
2793: IFFALSE 2839
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2795: LD_ADDR_EXP 28
2799: PUSH
2800: LD_STRING Gary
2802: PPUSH
2803: LD_EXP 1
2807: NOT
2808: PPUSH
2809: LD_STRING 13a_
2811: PPUSH
2812: CALL 51212 0 3
2816: ST_TO_ADDR
// if Gary then
2817: LD_EXP 28
2821: IFFALSE 2839
// tmp := tmp ^ Gary ;
2823: LD_ADDR_VAR 0 5
2827: PUSH
2828: LD_VAR 0 5
2832: PUSH
2833: LD_EXP 28
2837: ADD
2838: ST_TO_ADDR
// end ; if not Kikuchi then
2839: LD_EXP 30
2843: NOT
2844: IFFALSE 2890
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2846: LD_ADDR_EXP 30
2850: PUSH
2851: LD_STRING Kikuchi
2853: PPUSH
2854: LD_EXP 1
2858: NOT
2859: PPUSH
2860: LD_STRING 13a_
2862: PPUSH
2863: CALL 51212 0 3
2867: ST_TO_ADDR
// if Kikuchi then
2868: LD_EXP 30
2872: IFFALSE 2890
// tmp := tmp ^ Kikuchi ;
2874: LD_ADDR_VAR 0 5
2878: PUSH
2879: LD_VAR 0 5
2883: PUSH
2884: LD_EXP 30
2888: ADD
2889: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2890: LD_ADDR_VAR 0 5
2894: PUSH
2895: LD_VAR 0 5
2899: PUSH
2900: LD_STRING 13a_others
2902: PPUSH
2903: CALL_OW 31
2907: UNION
2908: ST_TO_ADDR
// tmp := tmp diff 0 ;
2909: LD_ADDR_VAR 0 5
2913: PUSH
2914: LD_VAR 0 5
2918: PUSH
2919: LD_INT 0
2921: DIFF
2922: ST_TO_ADDR
// if tmp < 15 then
2923: LD_VAR 0 5
2927: PUSH
2928: LD_INT 15
2930: LESS
2931: IFFALSE 3019
// for i = 15 downto tmp do
2933: LD_ADDR_VAR 0 2
2937: PUSH
2938: DOUBLE
2939: LD_INT 15
2941: INC
2942: ST_TO_ADDR
2943: LD_VAR 0 5
2947: PUSH
2948: FOR_DOWNTO
2949: IFFALSE 3017
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2951: LD_ADDR_OWVAR 21
2955: PUSH
2956: LD_INT 1
2958: PUSH
2959: LD_INT 3
2961: PUSH
2962: EMPTY
2963: LIST
2964: LIST
2965: PUSH
2966: LD_INT 1
2968: PPUSH
2969: LD_INT 2
2971: PPUSH
2972: CALL_OW 12
2976: ARRAY
2977: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
2978: LD_INT 0
2980: PPUSH
2981: LD_INT 1
2983: PPUSH
2984: LD_INT 4
2986: PPUSH
2987: CALL_OW 12
2991: PPUSH
2992: LD_INT 8
2994: PPUSH
2995: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2999: LD_ADDR_VAR 0 5
3003: PUSH
3004: LD_VAR 0 5
3008: PUSH
3009: CALL_OW 44
3013: ADD
3014: ST_TO_ADDR
// end ;
3015: GO 2948
3017: POP
3018: POP
// if not debug then
3019: LD_EXP 1
3023: NOT
3024: IFFALSE 3196
// selected = CharacterSelection (  , [ 15 , 14 , 13 ] [ Difficulty ] , [ 15 , 14 , 13 ] [ Difficulty ] , [ sel_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
3026: LD_ADDR_VAR 0 4
3030: PUSH
3031: LD_STRING 
3033: PPUSH
3034: LD_INT 15
3036: PUSH
3037: LD_INT 14
3039: PUSH
3040: LD_INT 13
3042: PUSH
3043: EMPTY
3044: LIST
3045: LIST
3046: LIST
3047: PUSH
3048: LD_OWVAR 67
3052: ARRAY
3053: PPUSH
3054: LD_INT 15
3056: PUSH
3057: LD_INT 14
3059: PUSH
3060: LD_INT 13
3062: PUSH
3063: EMPTY
3064: LIST
3065: LIST
3066: LIST
3067: PUSH
3068: LD_OWVAR 67
3072: ARRAY
3073: PPUSH
3074: LD_INT -5
3076: PUSH
3077: LD_EXP 17
3081: PUSH
3082: LD_EXP 49
3086: PUSH
3087: LD_EXP 18
3091: PUSH
3092: LD_EXP 32
3096: PUSH
3097: LD_EXP 23
3101: PUSH
3102: LD_EXP 35
3106: PUSH
3107: LD_INT -2
3109: PUSH
3110: LD_INT -3
3112: PUSH
3113: LD_INT -5
3115: PUSH
3116: EMPTY
3117: LIST
3118: LIST
3119: LIST
3120: LIST
3121: LIST
3122: LIST
3123: LIST
3124: LIST
3125: LIST
3126: LIST
3127: PUSH
3128: LD_VAR 0 5
3132: ADD
3133: PPUSH
3134: LD_INT 1
3136: PUSH
3137: LD_INT 4
3139: PUSH
3140: LD_INT 2
3142: PUSH
3143: LD_INT 1
3145: PUSH
3146: EMPTY
3147: LIST
3148: LIST
3149: PUSH
3150: LD_INT 3
3152: PUSH
3153: LD_INT 5
3155: PUSH
3156: LD_INT 0
3158: PUSH
3159: LD_INT 3
3161: PUSH
3162: EMPTY
3163: LIST
3164: LIST
3165: LIST
3166: PUSH
3167: LD_INT 9
3169: PUSH
3170: LD_INT 0
3172: PUSH
3173: LD_INT 3
3175: PUSH
3176: EMPTY
3177: LIST
3178: LIST
3179: LIST
3180: PUSH
3181: EMPTY
3182: LIST
3183: LIST
3184: LIST
3185: LIST
3186: LIST
3187: LIST
3188: PPUSH
3189: CALL_OW 42
3193: ST_TO_ADDR
3194: GO 3275
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ] ;
3196: LD_ADDR_VAR 0 4
3200: PUSH
3201: LD_EXP 37
3205: PUSH
3206: LD_EXP 38
3210: PUSH
3211: LD_EXP 39
3215: PUSH
3216: LD_EXP 40
3220: PUSH
3221: LD_EXP 41
3225: PUSH
3226: LD_EXP 42
3230: PUSH
3231: LD_EXP 43
3235: PUSH
3236: LD_EXP 44
3240: PUSH
3241: LD_EXP 45
3245: PUSH
3246: LD_EXP 46
3250: PUSH
3251: LD_EXP 47
3255: PUSH
3256: LD_EXP 48
3260: PUSH
3261: EMPTY
3262: LIST
3263: LIST
3264: LIST
3265: LIST
3266: LIST
3267: LIST
3268: LIST
3269: LIST
3270: LIST
3271: LIST
3272: LIST
3273: LIST
3274: ST_TO_ADDR
// uc_nation := 1 ;
3275: LD_ADDR_OWVAR 21
3279: PUSH
3280: LD_INT 1
3282: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3283: LD_INT 5
3285: PPUSH
3286: LD_INT 3
3288: PPUSH
3289: LD_INT 1
3291: PPUSH
3292: LD_INT 6
3294: PPUSH
3295: LD_INT 100
3297: PPUSH
3298: CALL 56076 0 5
// veh := CreateVehicle ;
3302: LD_ADDR_VAR 0 3
3306: PUSH
3307: CALL_OW 45
3311: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3312: LD_VAR 0 3
3316: PPUSH
3317: LD_INT 7
3319: NEG
3320: PPUSH
3321: CALL_OW 242
// SetDir ( veh , 3 ) ;
3325: LD_VAR 0 3
3329: PPUSH
3330: LD_INT 3
3332: PPUSH
3333: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3337: LD_VAR 0 3
3341: PPUSH
3342: LD_INT 31
3344: PPUSH
3345: LD_INT 0
3347: PPUSH
3348: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3352: LD_EXP 17
3356: PPUSH
3357: LD_VAR 0 3
3361: PPUSH
3362: CALL_OW 52
// if Joan then
3366: LD_EXP 32
3370: IFFALSE 3442
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3372: LD_INT 3
3374: PPUSH
3375: LD_INT 3
3377: PPUSH
3378: LD_INT 1
3380: PPUSH
3381: LD_INT 11
3383: PPUSH
3384: LD_INT 100
3386: PPUSH
3387: CALL 56076 0 5
// veh := CreateVehicle ;
3391: LD_ADDR_VAR 0 3
3395: PUSH
3396: CALL_OW 45
3400: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3401: LD_VAR 0 3
3405: PPUSH
3406: LD_INT 3
3408: PPUSH
3409: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3413: LD_VAR 0 3
3417: PPUSH
3418: LD_INT 30
3420: PPUSH
3421: LD_INT 0
3423: PPUSH
3424: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3428: LD_EXP 32
3432: PPUSH
3433: LD_VAR 0 3
3437: PPUSH
3438: CALL_OW 52
// end ; if Roth then
3442: LD_EXP 18
3446: IFFALSE 3518
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3448: LD_INT 3
3450: PPUSH
3451: LD_INT 3
3453: PPUSH
3454: LD_INT 1
3456: PPUSH
3457: LD_INT 11
3459: PPUSH
3460: LD_INT 100
3462: PPUSH
3463: CALL 56076 0 5
// veh := CreateVehicle ;
3467: LD_ADDR_VAR 0 3
3471: PUSH
3472: CALL_OW 45
3476: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3477: LD_VAR 0 3
3481: PPUSH
3482: LD_INT 3
3484: PPUSH
3485: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3489: LD_VAR 0 3
3493: PPUSH
3494: LD_INT 30
3496: PPUSH
3497: LD_INT 0
3499: PPUSH
3500: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3504: LD_EXP 18
3508: PPUSH
3509: LD_VAR 0 3
3513: PPUSH
3514: CALL_OW 52
// end ; if Denis then
3518: LD_EXP 23
3522: IFFALSE 3594
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3524: LD_INT 5
3526: PPUSH
3527: LD_INT 3
3529: PPUSH
3530: LD_INT 1
3532: PPUSH
3533: LD_INT 9
3535: PPUSH
3536: LD_INT 100
3538: PPUSH
3539: CALL 56076 0 5
// veh := CreateVehicle ;
3543: LD_ADDR_VAR 0 3
3547: PUSH
3548: CALL_OW 45
3552: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3553: LD_VAR 0 3
3557: PPUSH
3558: LD_INT 3
3560: PPUSH
3561: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3565: LD_VAR 0 3
3569: PPUSH
3570: LD_INT 30
3572: PPUSH
3573: LD_INT 0
3575: PPUSH
3576: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3580: LD_EXP 23
3584: PPUSH
3585: LD_VAR 0 3
3589: PPUSH
3590: CALL_OW 52
// end ; uc_nation := 3 ;
3594: LD_ADDR_OWVAR 21
3598: PUSH
3599: LD_INT 3
3601: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3602: LD_INT 22
3604: PPUSH
3605: LD_INT 3
3607: PPUSH
3608: LD_INT 1
3610: PPUSH
3611: LD_INT 45
3613: PPUSH
3614: LD_INT 100
3616: PPUSH
3617: CALL 56076 0 5
// veh := CreateVehicle ;
3621: LD_ADDR_VAR 0 3
3625: PUSH
3626: CALL_OW 45
3630: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3631: LD_VAR 0 3
3635: PPUSH
3636: LD_INT 7
3638: NEG
3639: PPUSH
3640: CALL_OW 242
// SetDir ( veh , 3 ) ;
3644: LD_VAR 0 3
3648: PPUSH
3649: LD_INT 3
3651: PPUSH
3652: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3656: LD_VAR 0 3
3660: PPUSH
3661: LD_INT 31
3663: PPUSH
3664: LD_INT 0
3666: PPUSH
3667: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3671: LD_EXP 49
3675: PPUSH
3676: LD_VAR 0 3
3680: PPUSH
3681: CALL_OW 52
// if Gossudarov then
3685: LD_EXP 35
3689: IFFALSE 3776
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3691: LD_INT 22
3693: PPUSH
3694: LD_INT 3
3696: PPUSH
3697: LD_INT 1
3699: PPUSH
3700: LD_INT 51
3702: PPUSH
3703: LD_INT 100
3705: PPUSH
3706: CALL 56076 0 5
// veh := CreateVehicle ;
3710: LD_ADDR_VAR 0 3
3714: PUSH
3715: CALL_OW 45
3719: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3720: LD_VAR 0 3
3724: PPUSH
3725: LD_INT 3
3727: PPUSH
3728: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3732: LD_VAR 0 3
3736: PPUSH
3737: LD_INT 30
3739: PPUSH
3740: LD_INT 0
3742: PPUSH
3743: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3747: LD_EXP 35
3751: PPUSH
3752: LD_VAR 0 3
3756: PPUSH
3757: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3761: LD_VAR 0 3
3765: PPUSH
3766: LD_INT 1
3768: PPUSH
3769: LD_INT 100
3771: PPUSH
3772: CALL_OW 290
// end ; for i in selected do
3776: LD_ADDR_VAR 0 2
3780: PUSH
3781: LD_VAR 0 4
3785: PUSH
3786: FOR_IN
3787: IFFALSE 4345
// begin uc_nation := GetNation ( i ) ;
3789: LD_ADDR_OWVAR 21
3793: PUSH
3794: LD_VAR 0 2
3798: PPUSH
3799: CALL_OW 248
3803: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3804: LD_VAR 0 2
3808: PUSH
3809: LD_EXP 19
3813: PUSH
3814: LD_EXP 20
3818: PUSH
3819: LD_EXP 22
3823: PUSH
3824: LD_EXP 21
3828: PUSH
3829: EMPTY
3830: LIST
3831: LIST
3832: LIST
3833: LIST
3834: IN
3835: IFFALSE 3858
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3837: LD_INT 5
3839: PPUSH
3840: LD_INT 3
3842: PPUSH
3843: LD_INT 1
3845: PPUSH
3846: LD_INT 6
3848: PPUSH
3849: LD_INT 100
3851: PPUSH
3852: CALL 56076 0 5
3856: GO 4292
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3858: LD_VAR 0 2
3862: PUSH
3863: LD_EXP 42
3867: PUSH
3868: LD_EXP 47
3872: PUSH
3873: LD_EXP 45
3877: PUSH
3878: LD_EXP 37
3882: PUSH
3883: EMPTY
3884: LIST
3885: LIST
3886: LIST
3887: LIST
3888: IN
3889: IFFALSE 3920
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3891: LD_INT 24
3893: PPUSH
3894: LD_INT 1
3896: PPUSH
3897: LD_INT 1
3899: PPUSH
3900: LD_INT 46
3902: PPUSH
3903: LD_INT 65
3905: PPUSH
3906: LD_INT 75
3908: PPUSH
3909: CALL_OW 12
3913: PPUSH
3914: CALL 56076 0 5
3918: GO 4292
// if i = Karamazov then
3920: LD_VAR 0 2
3924: PUSH
3925: LD_EXP 48
3929: EQUAL
3930: IFFALSE 3953
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3932: LD_INT 22
3934: PPUSH
3935: LD_INT 3
3937: PPUSH
3938: LD_INT 1
3940: PPUSH
3941: LD_INT 52
3943: PPUSH
3944: LD_INT 100
3946: PPUSH
3947: CALL 56076 0 5
3951: GO 4292
// if i = Brown then
3953: LD_VAR 0 2
3957: PUSH
3958: LD_EXP 24
3962: EQUAL
3963: IFFALSE 3986
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
3965: LD_INT 3
3967: PPUSH
3968: LD_INT 3
3970: PPUSH
3971: LD_INT 1
3973: PPUSH
3974: LD_INT 13
3976: PPUSH
3977: LD_INT 100
3979: PPUSH
3980: CALL 56076 0 5
3984: GO 4292
// if uc_nation = nation_american then
3986: LD_OWVAR 21
3990: PUSH
3991: LD_INT 1
3993: EQUAL
3994: IFFALSE 4145
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
3996: LD_INT 3
3998: PUSH
3999: LD_INT 5
4001: PUSH
4002: LD_INT 5
4004: PUSH
4005: EMPTY
4006: LIST
4007: LIST
4008: LIST
4009: PUSH
4010: LD_OWVAR 21
4014: PUSH
4015: LD_INT 3
4017: MOD
4018: PUSH
4019: LD_INT 1
4021: PLUS
4022: ARRAY
4023: PPUSH
4024: LD_INT 1
4026: PUSH
4027: LD_INT 3
4029: PUSH
4030: LD_INT 1
4032: PUSH
4033: EMPTY
4034: LIST
4035: LIST
4036: LIST
4037: PUSH
4038: LD_OWVAR 21
4042: PUSH
4043: LD_INT 3
4045: MOD
4046: PUSH
4047: LD_INT 1
4049: PLUS
4050: ARRAY
4051: PPUSH
4052: LD_INT 1
4054: PPUSH
4055: LD_INT 11
4057: PUSH
4058: LD_INT 4
4060: PUSH
4061: LD_INT 5
4063: PUSH
4064: EMPTY
4065: LIST
4066: LIST
4067: LIST
4068: PUSH
4069: LD_INT 6
4071: PUSH
4072: LD_INT 7
4074: PUSH
4075: LD_INT 9
4077: PUSH
4078: EMPTY
4079: LIST
4080: LIST
4081: LIST
4082: PUSH
4083: LD_INT 6
4085: PUSH
4086: LD_INT 9
4088: PUSH
4089: LD_INT 12
4091: PUSH
4092: EMPTY
4093: LIST
4094: LIST
4095: LIST
4096: PUSH
4097: EMPTY
4098: LIST
4099: LIST
4100: LIST
4101: PUSH
4102: LD_OWVAR 21
4106: PUSH
4107: LD_INT 3
4109: MOD
4110: PUSH
4111: LD_INT 1
4113: PLUS
4114: ARRAY
4115: PUSH
4116: LD_INT 1
4118: PPUSH
4119: LD_INT 3
4121: PPUSH
4122: CALL_OW 12
4126: ARRAY
4127: PPUSH
4128: LD_INT 65
4130: PPUSH
4131: LD_INT 75
4133: PPUSH
4134: CALL_OW 12
4138: PPUSH
4139: CALL 56076 0 5
// end else
4143: GO 4292
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4145: LD_INT 22
4147: PUSH
4148: LD_INT 23
4150: PUSH
4151: LD_INT 23
4153: PUSH
4154: EMPTY
4155: LIST
4156: LIST
4157: LIST
4158: PUSH
4159: LD_OWVAR 21
4163: PUSH
4164: LD_INT 3
4166: MOD
4167: PUSH
4168: LD_INT 1
4170: PLUS
4171: ARRAY
4172: PPUSH
4173: LD_INT 1
4175: PUSH
4176: LD_INT 3
4178: PUSH
4179: LD_INT 1
4181: PUSH
4182: EMPTY
4183: LIST
4184: LIST
4185: LIST
4186: PUSH
4187: LD_OWVAR 21
4191: PUSH
4192: LD_INT 3
4194: MOD
4195: PUSH
4196: LD_INT 1
4198: PLUS
4199: ARRAY
4200: PPUSH
4201: LD_INT 1
4203: PPUSH
4204: LD_INT 45
4206: PUSH
4207: LD_INT 43
4209: PUSH
4210: LD_INT 44
4212: PUSH
4213: EMPTY
4214: LIST
4215: LIST
4216: LIST
4217: PUSH
4218: LD_INT 46
4220: PUSH
4221: LD_INT 45
4223: PUSH
4224: LD_INT 44
4226: PUSH
4227: EMPTY
4228: LIST
4229: LIST
4230: LIST
4231: PUSH
4232: LD_INT 46
4234: PUSH
4235: LD_INT 43
4237: PUSH
4238: LD_INT 45
4240: PUSH
4241: EMPTY
4242: LIST
4243: LIST
4244: LIST
4245: PUSH
4246: EMPTY
4247: LIST
4248: LIST
4249: LIST
4250: PUSH
4251: LD_OWVAR 21
4255: PUSH
4256: LD_INT 3
4258: MOD
4259: PUSH
4260: LD_INT 1
4262: PLUS
4263: ARRAY
4264: PUSH
4265: LD_INT 1
4267: PPUSH
4268: LD_INT 3
4270: PPUSH
4271: CALL_OW 12
4275: ARRAY
4276: PPUSH
4277: LD_INT 65
4279: PPUSH
4280: LD_INT 75
4282: PPUSH
4283: CALL_OW 12
4287: PPUSH
4288: CALL 56076 0 5
// end ; veh := CreateVehicle ;
4292: LD_ADDR_VAR 0 3
4296: PUSH
4297: CALL_OW 45
4301: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4302: LD_VAR 0 3
4306: PPUSH
4307: LD_INT 3
4309: PPUSH
4310: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4314: LD_VAR 0 3
4318: PPUSH
4319: LD_INT 30
4321: PPUSH
4322: LD_INT 0
4324: PPUSH
4325: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4329: LD_VAR 0 2
4333: PPUSH
4334: LD_VAR 0 3
4338: PPUSH
4339: CALL_OW 52
// end ;
4343: GO 3786
4345: POP
4346: POP
// if artifactArCaptured then
4347: LD_EXP 9
4351: IFFALSE 4437
// begin uc_nation := nation_american ;
4353: LD_ADDR_OWVAR 21
4357: PUSH
4358: LD_INT 1
4360: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4361: LD_INT 3
4363: PPUSH
4364: LD_INT 3
4366: PPUSH
4367: LD_INT 3
4369: PPUSH
4370: LD_INT 12
4372: PPUSH
4373: LD_INT 100
4375: PPUSH
4376: CALL 56076 0 5
// veh := CreateVehicle ;
4380: LD_ADDR_VAR 0 3
4384: PUSH
4385: CALL_OW 45
4389: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4390: LD_VAR 0 3
4394: PPUSH
4395: LD_INT 3
4397: PPUSH
4398: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4402: LD_VAR 0 3
4406: PPUSH
4407: LD_INT 198
4409: PPUSH
4410: LD_INT 22
4412: PPUSH
4413: LD_INT 0
4415: PPUSH
4416: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4420: LD_VAR 0 3
4424: PPUSH
4425: LD_INT 4
4427: PPUSH
4428: LD_INT 50
4430: PPUSH
4431: CALL_OW 290
// end else
4435: GO 4456
// begin CreateResourcesXY ( mat_artifact , 5 , 267 , 226 , false ) ;
4437: LD_INT 4
4439: PPUSH
4440: LD_INT 5
4442: PPUSH
4443: LD_INT 267
4445: PPUSH
4446: LD_INT 226
4448: PPUSH
4449: LD_INT 0
4451: PPUSH
4452: CALL_OW 58
// end ; uc_nation := nation_american ;
4456: LD_ADDR_OWVAR 21
4460: PUSH
4461: LD_INT 1
4463: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4464: LD_INT 3
4466: PPUSH
4467: LD_INT 3
4469: PPUSH
4470: LD_INT 3
4472: PPUSH
4473: LD_INT 12
4475: PPUSH
4476: LD_INT 100
4478: PPUSH
4479: CALL 56076 0 5
// veh := CreateVehicle ;
4483: LD_ADDR_VAR 0 3
4487: PUSH
4488: CALL_OW 45
4492: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4493: LD_VAR 0 3
4497: PPUSH
4498: LD_INT 3
4500: PPUSH
4501: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4505: LD_VAR 0 3
4509: PPUSH
4510: LD_INT 218
4512: PPUSH
4513: LD_INT 23
4515: PPUSH
4516: LD_INT 0
4518: PPUSH
4519: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4523: LD_VAR 0 3
4527: PPUSH
4528: LD_INT 4
4530: PPUSH
4531: LD_INT 30
4533: PPUSH
4534: CALL_OW 290
// uc_nation := nation_russian ;
4538: LD_ADDR_OWVAR 21
4542: PUSH
4543: LD_INT 3
4545: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4546: LD_INT 22
4548: PPUSH
4549: LD_INT 3
4551: PPUSH
4552: LD_INT 3
4554: PPUSH
4555: LD_INT 51
4557: PPUSH
4558: LD_INT 100
4560: PPUSH
4561: CALL 56076 0 5
// veh := CreateVehicle ;
4565: LD_ADDR_VAR 0 3
4569: PUSH
4570: CALL_OW 45
4574: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4575: LD_VAR 0 3
4579: PPUSH
4580: LD_INT 3
4582: PPUSH
4583: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4587: LD_VAR 0 3
4591: PPUSH
4592: LD_INT 214
4594: PPUSH
4595: LD_INT 20
4597: PPUSH
4598: LD_INT 0
4600: PPUSH
4601: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4605: LD_VAR 0 3
4609: PPUSH
4610: LD_INT 4
4612: PPUSH
4613: LD_INT 40
4615: PPUSH
4616: CALL_OW 290
// end ; end_of_file
4620: LD_VAR 0 1
4624: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
4625: LD_INT 0
4627: PPUSH
4628: PPUSH
4629: PPUSH
4630: PPUSH
4631: PPUSH
4632: PPUSH
4633: PPUSH
4634: PPUSH
4635: PPUSH
4636: PPUSH
// InitHc ;
4637: CALL_OW 19
// uc_side := 1 ;
4641: LD_ADDR_OWVAR 20
4645: PUSH
4646: LD_INT 1
4648: ST_TO_ADDR
// uc_nation := 1 ;
4649: LD_ADDR_OWVAR 21
4653: PUSH
4654: LD_INT 1
4656: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
4657: LD_ADDR_VAR 0 2
4661: PUSH
4662: LD_INT 22
4664: PUSH
4665: LD_INT 1
4667: PUSH
4668: EMPTY
4669: LIST
4670: LIST
4671: PUSH
4672: LD_INT 21
4674: PUSH
4675: LD_INT 3
4677: PUSH
4678: EMPTY
4679: LIST
4680: LIST
4681: PUSH
4682: EMPTY
4683: LIST
4684: LIST
4685: PPUSH
4686: CALL_OW 69
4690: PUSH
4691: FOR_IN
4692: IFFALSE 4708
// SetBLevel ( i , 10 ) ;
4694: LD_VAR 0 2
4698: PPUSH
4699: LD_INT 10
4701: PPUSH
4702: CALL_OW 241
4706: GO 4691
4708: POP
4709: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 7500 ) ;
4710: LD_INT 387
4712: PPUSH
4713: CALL_OW 274
4717: PPUSH
4718: LD_INT 1
4720: PPUSH
4721: LD_INT 7500
4723: PPUSH
4724: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
4728: LD_INT 387
4730: PPUSH
4731: CALL_OW 274
4735: PPUSH
4736: LD_INT 2
4738: PPUSH
4739: LD_INT 4000
4741: PPUSH
4742: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
4746: LD_INT 387
4748: PPUSH
4749: CALL_OW 274
4753: PPUSH
4754: LD_INT 3
4756: PPUSH
4757: LD_INT 50
4759: PPUSH
4760: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 5500 ) ;
4764: LD_INT 476
4766: PPUSH
4767: CALL_OW 274
4771: PPUSH
4772: LD_INT 1
4774: PPUSH
4775: LD_INT 5500
4777: PPUSH
4778: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
4782: LD_INT 476
4784: PPUSH
4785: CALL_OW 274
4789: PPUSH
4790: LD_INT 2
4792: PPUSH
4793: LD_INT 4000
4795: PPUSH
4796: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
4800: LD_INT 476
4802: PPUSH
4803: CALL_OW 274
4807: PPUSH
4808: LD_INT 3
4810: PPUSH
4811: LD_INT 10
4813: PPUSH
4814: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
4818: LD_ADDR_EXP 52
4822: PUSH
4823: LD_STRING Powell
4825: PPUSH
4826: CALL_OW 25
4830: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
4831: LD_EXP 52
4835: PPUSH
4836: LD_INT 387
4838: PPUSH
4839: CALL_OW 52
// tmp := [ ] ;
4843: LD_ADDR_VAR 0 6
4847: PUSH
4848: EMPTY
4849: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
4850: LD_ADDR_EXP 19
4854: PUSH
4855: LD_STRING Lisa
4857: PPUSH
4858: LD_EXP 1
4862: NOT
4863: PPUSH
4864: LD_STRING 12p_
4866: PPUSH
4867: CALL 51212 0 3
4871: ST_TO_ADDR
// if Lisa then
4872: LD_EXP 19
4876: IFFALSE 4894
// tmp := tmp ^ Lisa ;
4878: LD_ADDR_VAR 0 6
4882: PUSH
4883: LD_VAR 0 6
4887: PUSH
4888: LD_EXP 19
4892: ADD
4893: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
4894: LD_ADDR_EXP 20
4898: PUSH
4899: LD_STRING Donaldson
4901: PPUSH
4902: LD_EXP 1
4906: NOT
4907: PPUSH
4908: LD_STRING 12p_
4910: PPUSH
4911: CALL 51212 0 3
4915: ST_TO_ADDR
// if Donaldson then
4916: LD_EXP 20
4920: IFFALSE 4938
// tmp := tmp ^ Donaldson ;
4922: LD_ADDR_VAR 0 6
4926: PUSH
4927: LD_VAR 0 6
4931: PUSH
4932: LD_EXP 20
4936: ADD
4937: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
4938: LD_ADDR_EXP 21
4942: PUSH
4943: LD_STRING Bobby
4945: PPUSH
4946: LD_EXP 1
4950: NOT
4951: PPUSH
4952: LD_STRING 12p_
4954: PPUSH
4955: CALL 51212 0 3
4959: ST_TO_ADDR
// if Bobby then
4960: LD_EXP 21
4964: IFFALSE 4982
// tmp := tmp ^ Bobby ;
4966: LD_ADDR_VAR 0 6
4970: PUSH
4971: LD_VAR 0 6
4975: PUSH
4976: LD_EXP 21
4980: ADD
4981: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
4982: LD_ADDR_EXP 22
4986: PUSH
4987: LD_STRING Cyrus
4989: PPUSH
4990: LD_EXP 1
4994: NOT
4995: PPUSH
4996: LD_STRING 12p_
4998: PPUSH
4999: CALL 51212 0 3
5003: ST_TO_ADDR
// if Cyrus then
5004: LD_EXP 22
5008: IFFALSE 5026
// tmp := tmp ^ Cyrus ;
5010: LD_ADDR_VAR 0 6
5014: PUSH
5015: LD_VAR 0 6
5019: PUSH
5020: LD_EXP 22
5024: ADD
5025: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
5026: LD_ADDR_EXP 24
5030: PUSH
5031: LD_STRING Brown
5033: PPUSH
5034: LD_EXP 1
5038: NOT
5039: PPUSH
5040: LD_STRING 12p_
5042: PPUSH
5043: CALL 51212 0 3
5047: ST_TO_ADDR
// if Brown then
5048: LD_EXP 24
5052: IFFALSE 5070
// tmp := tmp ^ Brown ;
5054: LD_ADDR_VAR 0 6
5058: PUSH
5059: LD_VAR 0 6
5063: PUSH
5064: LD_EXP 24
5068: ADD
5069: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5070: LD_ADDR_EXP 25
5074: PUSH
5075: LD_STRING Gladstone
5077: PPUSH
5078: LD_EXP 1
5082: NOT
5083: PPUSH
5084: LD_STRING 12p_
5086: PPUSH
5087: CALL 51212 0 3
5091: ST_TO_ADDR
// if Gladstone then
5092: LD_EXP 25
5096: IFFALSE 5114
// tmp := tmp ^ Gladstone ;
5098: LD_ADDR_VAR 0 6
5102: PUSH
5103: LD_VAR 0 6
5107: PUSH
5108: LD_EXP 25
5112: ADD
5113: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5114: LD_ADDR_EXP 26
5118: PUSH
5119: LD_STRING Houten
5121: PPUSH
5122: LD_EXP 1
5126: NOT
5127: PPUSH
5128: LD_STRING 12p_
5130: PPUSH
5131: CALL 51212 0 3
5135: ST_TO_ADDR
// if Houten then
5136: LD_EXP 26
5140: IFFALSE 5158
// tmp := tmp ^ Houten ;
5142: LD_ADDR_VAR 0 6
5146: PUSH
5147: LD_VAR 0 6
5151: PUSH
5152: LD_EXP 26
5156: ADD
5157: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5158: LD_ADDR_EXP 27
5162: PUSH
5163: LD_STRING Cornel
5165: PPUSH
5166: LD_EXP 1
5170: NOT
5171: PPUSH
5172: LD_STRING 12p_
5174: PPUSH
5175: CALL 51212 0 3
5179: ST_TO_ADDR
// if Cornel then
5180: LD_EXP 27
5184: IFFALSE 5202
// tmp := tmp ^ Cornel ;
5186: LD_ADDR_VAR 0 6
5190: PUSH
5191: LD_VAR 0 6
5195: PUSH
5196: LD_EXP 27
5200: ADD
5201: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5202: LD_ADDR_EXP 28
5206: PUSH
5207: LD_STRING Gary
5209: PPUSH
5210: LD_EXP 1
5214: NOT
5215: PPUSH
5216: LD_STRING 12p_
5218: PPUSH
5219: CALL 51212 0 3
5223: ST_TO_ADDR
// if Gary then
5224: LD_EXP 28
5228: IFFALSE 5246
// tmp := tmp ^ Gary ;
5230: LD_ADDR_VAR 0 6
5234: PUSH
5235: LD_VAR 0 6
5239: PUSH
5240: LD_EXP 28
5244: ADD
5245: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5246: LD_ADDR_EXP 30
5250: PUSH
5251: LD_STRING Kikuchi
5253: PPUSH
5254: LD_EXP 1
5258: NOT
5259: PPUSH
5260: LD_STRING 12p_
5262: PPUSH
5263: CALL 51212 0 3
5267: ST_TO_ADDR
// if Kikuchi then
5268: LD_EXP 30
5272: IFFALSE 5290
// tmp := tmp ^ Kikuchi ;
5274: LD_ADDR_VAR 0 6
5278: PUSH
5279: LD_VAR 0 6
5283: PUSH
5284: LD_EXP 30
5288: ADD
5289: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5290: LD_ADDR_VAR 0 6
5294: PUSH
5295: LD_VAR 0 6
5299: PUSH
5300: LD_STRING 12p_others
5302: PPUSH
5303: CALL_OW 31
5307: UNION
5308: ST_TO_ADDR
// if tmp < 36 then
5309: LD_VAR 0 6
5313: PUSH
5314: LD_INT 36
5316: LESS
5317: IFFALSE 5384
// for i = 1 to 36 - tmp do
5319: LD_ADDR_VAR 0 2
5323: PUSH
5324: DOUBLE
5325: LD_INT 1
5327: DEC
5328: ST_TO_ADDR
5329: LD_INT 36
5331: PUSH
5332: LD_VAR 0 6
5336: MINUS
5337: PUSH
5338: FOR_TO
5339: IFFALSE 5382
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5341: LD_INT 1
5343: PPUSH
5344: LD_VAR 0 2
5348: PUSH
5349: LD_INT 4
5351: MOD
5352: PUSH
5353: LD_INT 1
5355: PLUS
5356: PPUSH
5357: LD_INT 10
5359: PPUSH
5360: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5364: LD_ADDR_VAR 0 6
5368: PUSH
5369: LD_VAR 0 6
5373: PUSH
5374: CALL_OW 44
5378: ADD
5379: ST_TO_ADDR
// end ;
5380: GO 5338
5382: POP
5383: POP
// for i in tmp do
5384: LD_ADDR_VAR 0 2
5388: PUSH
5389: LD_VAR 0 6
5393: PUSH
5394: FOR_IN
5395: IFFALSE 5420
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5397: LD_VAR 0 2
5401: PPUSH
5402: LD_INT 62
5404: PPUSH
5405: LD_INT 93
5407: PPUSH
5408: LD_INT 9
5410: PPUSH
5411: LD_INT 0
5413: PPUSH
5414: CALL_OW 50
5418: GO 5394
5420: POP
5421: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
5422: LD_ADDR_EXP 93
5426: PUSH
5427: LD_EXP 93
5431: PPUSH
5432: LD_INT 4
5434: PPUSH
5435: LD_INT 22
5437: PUSH
5438: LD_INT 1
5440: PUSH
5441: EMPTY
5442: LIST
5443: LIST
5444: PPUSH
5445: CALL_OW 69
5449: PUSH
5450: LD_EXP 52
5454: DIFF
5455: PPUSH
5456: CALL_OW 1
5460: ST_TO_ADDR
// uc_side := 0 ;
5461: LD_ADDR_OWVAR 20
5465: PUSH
5466: LD_INT 0
5468: ST_TO_ADDR
// uc_nation := 0 ;
5469: LD_ADDR_OWVAR 21
5473: PUSH
5474: LD_INT 0
5476: ST_TO_ADDR
// for i = 1 to 4 do
5477: LD_ADDR_VAR 0 2
5481: PUSH
5482: DOUBLE
5483: LD_INT 1
5485: DEC
5486: ST_TO_ADDR
5487: LD_INT 4
5489: PUSH
5490: FOR_TO
5491: IFFALSE 5522
// begin InitHc ;
5493: CALL_OW 19
// hc_class := class_apeman ;
5497: LD_ADDR_OWVAR 28
5501: PUSH
5502: LD_INT 12
5504: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
5505: CALL_OW 44
5509: PPUSH
5510: LD_INT 11
5512: PPUSH
5513: LD_INT 0
5515: PPUSH
5516: CALL_OW 49
// end ;
5520: GO 5490
5522: POP
5523: POP
// end ;
5524: LD_VAR 0 1
5528: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
5529: LD_EXP 4
5533: NOT
5534: PUSH
5535: LD_INT 4
5537: PPUSH
5538: LD_INT 1
5540: PPUSH
5541: CALL 46224 0 2
5545: NOT
5546: AND
5547: IFFALSE 6319
5549: GO 5551
5551: DISABLE
5552: LD_INT 0
5554: PPUSH
5555: PPUSH
5556: PPUSH
// begin enable ;
5557: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
5558: LD_INT 22
5560: PUSH
5561: LD_INT 1
5563: PUSH
5564: EMPTY
5565: LIST
5566: LIST
5567: PUSH
5568: LD_INT 23
5570: PUSH
5571: LD_INT 1
5573: PUSH
5574: EMPTY
5575: LIST
5576: LIST
5577: PUSH
5578: LD_INT 30
5580: PUSH
5581: LD_INT 3
5583: PUSH
5584: EMPTY
5585: LIST
5586: LIST
5587: PUSH
5588: EMPTY
5589: LIST
5590: LIST
5591: LIST
5592: PPUSH
5593: CALL_OW 69
5597: NOT
5598: IFFALSE 5602
// exit ;
5600: GO 6319
// if Prob ( 40 ) then
5602: LD_INT 40
5604: PPUSH
5605: CALL_OW 13
5609: IFFALSE 5736
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5611: LD_INT 4
5613: PPUSH
5614: LD_INT 5
5616: PUSH
5617: LD_INT 1
5619: PUSH
5620: LD_INT 2
5622: PUSH
5623: LD_INT 7
5625: PUSH
5626: EMPTY
5627: LIST
5628: LIST
5629: LIST
5630: LIST
5631: PUSH
5632: LD_INT 5
5634: PUSH
5635: LD_INT 1
5637: PUSH
5638: LD_INT 2
5640: PUSH
5641: LD_INT 7
5643: PUSH
5644: EMPTY
5645: LIST
5646: LIST
5647: LIST
5648: LIST
5649: PUSH
5650: LD_INT 5
5652: PUSH
5653: LD_INT 1
5655: PUSH
5656: LD_INT 2
5658: PUSH
5659: LD_INT 7
5661: PUSH
5662: EMPTY
5663: LIST
5664: LIST
5665: LIST
5666: LIST
5667: PUSH
5668: LD_INT 5
5670: PUSH
5671: LD_INT 1
5673: PUSH
5674: LD_INT 2
5676: PUSH
5677: LD_INT 6
5679: PUSH
5680: EMPTY
5681: LIST
5682: LIST
5683: LIST
5684: LIST
5685: PUSH
5686: LD_INT 5
5688: PUSH
5689: LD_INT 1
5691: PUSH
5692: LD_INT 2
5694: PUSH
5695: LD_INT 6
5697: PUSH
5698: EMPTY
5699: LIST
5700: LIST
5701: LIST
5702: LIST
5703: PUSH
5704: LD_INT 5
5706: PUSH
5707: LD_INT 1
5709: PUSH
5710: LD_INT 2
5712: PUSH
5713: LD_INT 6
5715: PUSH
5716: EMPTY
5717: LIST
5718: LIST
5719: LIST
5720: LIST
5721: PUSH
5722: EMPTY
5723: LIST
5724: LIST
5725: LIST
5726: LIST
5727: LIST
5728: LIST
5729: PPUSH
5730: CALL 44806 0 2
// end else
5734: GO 5859
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5736: LD_INT 4
5738: PPUSH
5739: LD_INT 5
5741: PUSH
5742: LD_INT 1
5744: PUSH
5745: LD_INT 2
5747: PUSH
5748: LD_INT 7
5750: PUSH
5751: EMPTY
5752: LIST
5753: LIST
5754: LIST
5755: LIST
5756: PUSH
5757: LD_INT 5
5759: PUSH
5760: LD_INT 1
5762: PUSH
5763: LD_INT 2
5765: PUSH
5766: LD_INT 9
5768: PUSH
5769: EMPTY
5770: LIST
5771: LIST
5772: LIST
5773: LIST
5774: PUSH
5775: LD_INT 5
5777: PUSH
5778: LD_INT 1
5780: PUSH
5781: LD_INT 2
5783: PUSH
5784: LD_INT 9
5786: PUSH
5787: EMPTY
5788: LIST
5789: LIST
5790: LIST
5791: LIST
5792: PUSH
5793: LD_INT 5
5795: PUSH
5796: LD_INT 1
5798: PUSH
5799: LD_INT 2
5801: PUSH
5802: LD_INT 6
5804: PUSH
5805: EMPTY
5806: LIST
5807: LIST
5808: LIST
5809: LIST
5810: PUSH
5811: LD_INT 5
5813: PUSH
5814: LD_INT 1
5816: PUSH
5817: LD_INT 2
5819: PUSH
5820: LD_INT 6
5822: PUSH
5823: EMPTY
5824: LIST
5825: LIST
5826: LIST
5827: LIST
5828: PUSH
5829: LD_INT 5
5831: PUSH
5832: LD_INT 1
5834: PUSH
5835: LD_INT 2
5837: PUSH
5838: LD_INT 6
5840: PUSH
5841: EMPTY
5842: LIST
5843: LIST
5844: LIST
5845: LIST
5846: PUSH
5847: EMPTY
5848: LIST
5849: LIST
5850: LIST
5851: LIST
5852: LIST
5853: LIST
5854: PPUSH
5855: CALL 44806 0 2
// end ; repeat wait ( 0 0$1 ) ;
5859: LD_INT 35
5861: PPUSH
5862: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
5866: LD_INT 4
5868: PPUSH
5869: LD_INT 1
5871: PPUSH
5872: CALL 46224 0 2
5876: PUSH
5877: LD_INT 6
5879: GREATEREQUAL
5880: IFFALSE 5859
// wait ( 0 0$30 ) ;
5882: LD_INT 1050
5884: PPUSH
5885: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
5889: LD_ADDR_VAR 0 2
5893: PUSH
5894: LD_INT 4
5896: PPUSH
5897: LD_INT 1
5899: PPUSH
5900: CALL 46224 0 2
5904: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
5905: LD_ADDR_EXP 112
5909: PUSH
5910: LD_EXP 112
5914: PPUSH
5915: LD_INT 4
5917: PPUSH
5918: LD_EXP 112
5922: PUSH
5923: LD_INT 4
5925: ARRAY
5926: PUSH
5927: LD_VAR 0 2
5931: DIFF
5932: PPUSH
5933: CALL_OW 1
5937: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5938: LD_ADDR_VAR 0 3
5942: PUSH
5943: LD_INT 0
5945: PPUSH
5946: LD_INT 2
5948: PPUSH
5949: CALL_OW 12
5953: ST_TO_ADDR
// if target then
5954: LD_VAR 0 3
5958: IFFALSE 6086
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5960: LD_ADDR_VAR 0 2
5964: PUSH
5965: LD_VAR 0 2
5969: PPUSH
5970: LD_INT 24
5972: PUSH
5973: LD_INT 250
5975: PUSH
5976: EMPTY
5977: LIST
5978: LIST
5979: PPUSH
5980: CALL_OW 72
5984: ST_TO_ADDR
// for i in tmp do
5985: LD_ADDR_VAR 0 1
5989: PUSH
5990: LD_VAR 0 2
5994: PUSH
5995: FOR_IN
5996: IFFALSE 6036
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
5998: LD_VAR 0 1
6002: PPUSH
6003: LD_INT 114
6005: PPUSH
6006: LD_INT 108
6008: PPUSH
6009: CALL_OW 297
6013: PUSH
6014: LD_INT 9
6016: GREATER
6017: IFFALSE 6034
// ComMoveXY ( i , 114 , 108 ) ;
6019: LD_VAR 0 1
6023: PPUSH
6024: LD_INT 114
6026: PPUSH
6027: LD_INT 108
6029: PPUSH
6030: CALL_OW 111
6034: GO 5995
6036: POP
6037: POP
// wait ( 0 0$1 ) ;
6038: LD_INT 35
6040: PPUSH
6041: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
6045: LD_VAR 0 2
6049: PPUSH
6050: LD_INT 92
6052: PUSH
6053: LD_INT 114
6055: PUSH
6056: LD_INT 108
6058: PUSH
6059: LD_INT 9
6061: PUSH
6062: EMPTY
6063: LIST
6064: LIST
6065: LIST
6066: LIST
6067: PPUSH
6068: CALL_OW 72
6072: PUSH
6073: LD_VAR 0 2
6077: PUSH
6078: LD_INT 1
6080: MINUS
6081: GREATEREQUAL
6082: IFFALSE 5960
// end else
6084: GO 6210
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6086: LD_ADDR_VAR 0 2
6090: PUSH
6091: LD_VAR 0 2
6095: PPUSH
6096: LD_INT 24
6098: PUSH
6099: LD_INT 250
6101: PUSH
6102: EMPTY
6103: LIST
6104: LIST
6105: PPUSH
6106: CALL_OW 72
6110: ST_TO_ADDR
// for i in tmp do
6111: LD_ADDR_VAR 0 1
6115: PUSH
6116: LD_VAR 0 2
6120: PUSH
6121: FOR_IN
6122: IFFALSE 6162
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6124: LD_VAR 0 1
6128: PPUSH
6129: LD_INT 129
6131: PPUSH
6132: LD_INT 139
6134: PPUSH
6135: CALL_OW 297
6139: PUSH
6140: LD_INT 9
6142: GREATER
6143: IFFALSE 6160
// ComMoveXY ( i , 129 , 139 ) ;
6145: LD_VAR 0 1
6149: PPUSH
6150: LD_INT 129
6152: PPUSH
6153: LD_INT 139
6155: PPUSH
6156: CALL_OW 111
6160: GO 6121
6162: POP
6163: POP
// wait ( 0 0$1 ) ;
6164: LD_INT 35
6166: PPUSH
6167: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
6171: LD_VAR 0 2
6175: PPUSH
6176: LD_INT 92
6178: PUSH
6179: LD_INT 129
6181: PUSH
6182: LD_INT 139
6184: PUSH
6185: LD_INT 9
6187: PUSH
6188: EMPTY
6189: LIST
6190: LIST
6191: LIST
6192: LIST
6193: PPUSH
6194: CALL_OW 72
6198: PUSH
6199: LD_VAR 0 2
6203: PUSH
6204: LD_INT 1
6206: MINUS
6207: GREATEREQUAL
6208: IFFALSE 6086
// end ; repeat wait ( 0 0$1 ) ;
6210: LD_INT 35
6212: PPUSH
6213: CALL_OW 67
// for i in tmp do
6217: LD_ADDR_VAR 0 1
6221: PUSH
6222: LD_VAR 0 2
6226: PUSH
6227: FOR_IN
6228: IFFALSE 6310
// begin if GetLives ( i ) > 251 then
6230: LD_VAR 0 1
6234: PPUSH
6235: CALL_OW 256
6239: PUSH
6240: LD_INT 251
6242: GREATER
6243: IFFALSE 6281
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6245: LD_VAR 0 1
6249: PPUSH
6250: LD_INT 81
6252: PUSH
6253: LD_INT 1
6255: PUSH
6256: EMPTY
6257: LIST
6258: LIST
6259: PPUSH
6260: CALL_OW 69
6264: PPUSH
6265: LD_VAR 0 1
6269: PPUSH
6270: CALL_OW 74
6274: PPUSH
6275: CALL_OW 115
6279: GO 6308
// if IsDead ( i ) then
6281: LD_VAR 0 1
6285: PPUSH
6286: CALL_OW 301
6290: IFFALSE 6308
// tmp := tmp diff i ;
6292: LD_ADDR_VAR 0 2
6296: PUSH
6297: LD_VAR 0 2
6301: PUSH
6302: LD_VAR 0 1
6306: DIFF
6307: ST_TO_ADDR
// end ;
6308: GO 6227
6310: POP
6311: POP
// until not tmp ;
6312: LD_VAR 0 2
6316: NOT
6317: IFFALSE 6210
// end ;
6319: PPOPN 3
6321: END
// every 30 30$00 trigger not americanDestroyed do
6322: LD_EXP 4
6326: NOT
6327: IFFALSE 6392
6329: GO 6331
6331: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 10 10$00 ] [ Difficulty ] ) ;
6332: LD_INT 63000
6334: PUSH
6335: LD_INT 42000
6337: PUSH
6338: LD_INT 21000
6340: PUSH
6341: EMPTY
6342: LIST
6343: LIST
6344: LIST
6345: PUSH
6346: LD_OWVAR 67
6350: ARRAY
6351: PPUSH
6352: CALL_OW 67
// if americanDestroyed then
6356: LD_EXP 4
6360: IFFALSE 6364
// exit ;
6362: GO 6392
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6364: LD_INT 4
6366: PPUSH
6367: LD_INT 5
6369: PUSH
6370: LD_INT 3
6372: PUSH
6373: LD_INT 1
6375: PUSH
6376: LD_INT 8
6378: PUSH
6379: EMPTY
6380: LIST
6381: LIST
6382: LIST
6383: LIST
6384: PUSH
6385: EMPTY
6386: LIST
6387: PPUSH
6388: CALL 44806 0 2
// end ; end_of_file
6392: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6393: LD_INT 0
6395: PPUSH
6396: PPUSH
6397: PPUSH
6398: PPUSH
6399: PPUSH
// side := 2 ;
6400: LD_ADDR_VAR 0 5
6404: PUSH
6405: LD_INT 2
6407: ST_TO_ADDR
// InitHc ;
6408: CALL_OW 19
// uc_side := side ;
6412: LD_ADDR_OWVAR 20
6416: PUSH
6417: LD_VAR 0 5
6421: ST_TO_ADDR
// uc_nation := 2 ;
6422: LD_ADDR_OWVAR 21
6426: PUSH
6427: LD_INT 2
6429: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
6430: LD_ADDR_VAR 0 2
6434: PUSH
6435: LD_INT 22
6437: PUSH
6438: LD_INT 2
6440: PUSH
6441: EMPTY
6442: LIST
6443: LIST
6444: PUSH
6445: LD_INT 21
6447: PUSH
6448: LD_INT 3
6450: PUSH
6451: EMPTY
6452: LIST
6453: LIST
6454: PUSH
6455: EMPTY
6456: LIST
6457: LIST
6458: PPUSH
6459: CALL_OW 69
6463: PUSH
6464: FOR_IN
6465: IFFALSE 6481
// SetBLevel ( i , 10 ) ;
6467: LD_VAR 0 2
6471: PPUSH
6472: LD_INT 10
6474: PPUSH
6475: CALL_OW 241
6479: GO 6464
6481: POP
6482: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6483: LD_ADDR_VAR 0 4
6487: PUSH
6488: LD_INT 22
6490: PUSH
6491: LD_VAR 0 5
6495: PUSH
6496: EMPTY
6497: LIST
6498: LIST
6499: PUSH
6500: LD_INT 30
6502: PUSH
6503: LD_INT 32
6505: PUSH
6506: EMPTY
6507: LIST
6508: LIST
6509: PUSH
6510: LD_INT 58
6512: PUSH
6513: EMPTY
6514: LIST
6515: PUSH
6516: EMPTY
6517: LIST
6518: LIST
6519: LIST
6520: PPUSH
6521: CALL_OW 69
6525: ST_TO_ADDR
// for i = 1 to 10 do
6526: LD_ADDR_VAR 0 2
6530: PUSH
6531: DOUBLE
6532: LD_INT 1
6534: DEC
6535: ST_TO_ADDR
6536: LD_INT 10
6538: PUSH
6539: FOR_TO
6540: IFFALSE 6612
// begin uc_nation := nation_nature ;
6542: LD_ADDR_OWVAR 21
6546: PUSH
6547: LD_INT 0
6549: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6550: LD_ADDR_OWVAR 28
6554: PUSH
6555: LD_INT 15
6557: ST_TO_ADDR
// hc_gallery :=  ;
6558: LD_ADDR_OWVAR 33
6562: PUSH
6563: LD_STRING 
6565: ST_TO_ADDR
// hc_name :=  ;
6566: LD_ADDR_OWVAR 26
6570: PUSH
6571: LD_STRING 
6573: ST_TO_ADDR
// un := CreateHuman ;
6574: LD_ADDR_VAR 0 3
6578: PUSH
6579: CALL_OW 44
6583: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
6584: LD_VAR 0 3
6588: PPUSH
6589: LD_VAR 0 4
6593: PUSH
6594: LD_VAR 0 4
6598: PUSH
6599: LD_VAR 0 2
6603: MINUS
6604: ARRAY
6605: PPUSH
6606: CALL_OW 52
// end ;
6610: GO 6539
6612: POP
6613: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
6614: LD_INT 503
6616: PPUSH
6617: LD_INT 27
6619: PPUSH
6620: LD_STRING 
6622: PPUSH
6623: LD_INT 8
6625: PUSH
6626: LD_INT 9
6628: PUSH
6629: LD_INT 10
6631: PUSH
6632: EMPTY
6633: LIST
6634: LIST
6635: LIST
6636: PUSH
6637: LD_OWVAR 67
6641: ARRAY
6642: PPUSH
6643: LD_INT 3000
6645: PUSH
6646: LD_INT 500
6648: PUSH
6649: LD_INT 150
6651: PUSH
6652: EMPTY
6653: LIST
6654: LIST
6655: LIST
6656: PPUSH
6657: LD_INT 16
6659: PUSH
6660: LD_INT 6
6662: PUSH
6663: LD_INT 6
6665: PUSH
6666: LD_INT 6
6668: PUSH
6669: EMPTY
6670: LIST
6671: LIST
6672: LIST
6673: LIST
6674: PPUSH
6675: CALL 59523 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
6679: LD_ADDR_EXP 93
6683: PUSH
6684: LD_EXP 93
6688: PPUSH
6689: LD_INT 1
6691: PPUSH
6692: LD_INT 22
6694: PUSH
6695: LD_VAR 0 5
6699: PUSH
6700: EMPTY
6701: LIST
6702: LIST
6703: PUSH
6704: LD_INT 23
6706: PUSH
6707: LD_INT 2
6709: PUSH
6710: EMPTY
6711: LIST
6712: LIST
6713: PUSH
6714: LD_INT 3
6716: PUSH
6717: LD_INT 21
6719: PUSH
6720: LD_INT 2
6722: PUSH
6723: EMPTY
6724: LIST
6725: LIST
6726: PUSH
6727: EMPTY
6728: LIST
6729: LIST
6730: PUSH
6731: EMPTY
6732: LIST
6733: LIST
6734: LIST
6735: PPUSH
6736: CALL_OW 69
6740: PPUSH
6741: CALL_OW 1
6745: ST_TO_ADDR
// end ;
6746: LD_VAR 0 1
6750: RET
// export Omar ; export function PrepareOmarAli ; begin
6751: LD_INT 0
6753: PPUSH
// uc_side := 5 ;
6754: LD_ADDR_OWVAR 20
6758: PUSH
6759: LD_INT 5
6761: ST_TO_ADDR
// uc_nation := 2 ;
6762: LD_ADDR_OWVAR 21
6766: PUSH
6767: LD_INT 2
6769: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
6770: LD_ADDR_EXP 53
6774: PUSH
6775: LD_STRING Omar
6777: PPUSH
6778: CALL_OW 25
6782: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
6783: LD_EXP 53
6787: PPUSH
6788: LD_INT 330
6790: PPUSH
6791: LD_INT 244
6793: PPUSH
6794: LD_INT 0
6796: PPUSH
6797: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
6801: LD_EXP 53
6805: PPUSH
6806: LD_INT 252
6808: PPUSH
6809: LD_INT 220
6811: PPUSH
6812: CALL_OW 111
// end ; end_of_file
6816: LD_VAR 0 1
6820: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
6821: LD_INT 0
6823: PPUSH
6824: PPUSH
6825: PPUSH
6826: PPUSH
6827: PPUSH
// side := 8 ;
6828: LD_ADDR_VAR 0 3
6832: PUSH
6833: LD_INT 8
6835: ST_TO_ADDR
// InitHc ;
6836: CALL_OW 19
// uc_side := side ;
6840: LD_ADDR_OWVAR 20
6844: PUSH
6845: LD_VAR 0 3
6849: ST_TO_ADDR
// uc_nation := 2 ;
6850: LD_ADDR_OWVAR 21
6854: PUSH
6855: LD_INT 2
6857: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6858: LD_ADDR_VAR 0 2
6862: PUSH
6863: LD_INT 22
6865: PUSH
6866: LD_VAR 0 3
6870: PUSH
6871: EMPTY
6872: LIST
6873: LIST
6874: PUSH
6875: LD_INT 21
6877: PUSH
6878: LD_INT 3
6880: PUSH
6881: EMPTY
6882: LIST
6883: LIST
6884: PUSH
6885: EMPTY
6886: LIST
6887: LIST
6888: PPUSH
6889: CALL_OW 69
6893: PUSH
6894: FOR_IN
6895: IFFALSE 6911
// SetBLevel ( i , 10 ) ;
6897: LD_VAR 0 2
6901: PPUSH
6902: LD_INT 10
6904: PPUSH
6905: CALL_OW 241
6909: GO 6894
6911: POP
6912: POP
// Schulz := NewCharacter ( Schulz ) ;
6913: LD_ADDR_EXP 54
6917: PUSH
6918: LD_STRING Schulz
6920: PPUSH
6921: CALL_OW 25
6925: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
6926: LD_ADDR_EXP 55
6930: PUSH
6931: LD_STRING Kozlov
6933: PPUSH
6934: LD_INT 0
6936: PPUSH
6937: LD_STRING 
6939: PPUSH
6940: CALL 51212 0 3
6944: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
6945: LD_EXP 55
6949: PPUSH
6950: LD_INT 22
6952: PUSH
6953: LD_INT 8
6955: PUSH
6956: EMPTY
6957: LIST
6958: LIST
6959: PUSH
6960: LD_INT 23
6962: PUSH
6963: LD_INT 3
6965: PUSH
6966: EMPTY
6967: LIST
6968: LIST
6969: PUSH
6970: LD_INT 30
6972: PUSH
6973: LD_INT 8
6975: PUSH
6976: EMPTY
6977: LIST
6978: LIST
6979: PUSH
6980: EMPTY
6981: LIST
6982: LIST
6983: LIST
6984: PPUSH
6985: CALL_OW 69
6989: PUSH
6990: LD_INT 1
6992: ARRAY
6993: PPUSH
6994: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
6998: LD_EXP 55
7002: PPUSH
7003: LD_INT 3
7005: PPUSH
7006: LD_INT 10
7008: PPUSH
7009: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7013: LD_ADDR_VAR 0 5
7017: PUSH
7018: LD_INT 22
7020: PUSH
7021: LD_VAR 0 3
7025: PUSH
7026: EMPTY
7027: LIST
7028: LIST
7029: PUSH
7030: LD_INT 30
7032: PUSH
7033: LD_INT 32
7035: PUSH
7036: EMPTY
7037: LIST
7038: LIST
7039: PUSH
7040: LD_INT 58
7042: PUSH
7043: EMPTY
7044: LIST
7045: PUSH
7046: EMPTY
7047: LIST
7048: LIST
7049: LIST
7050: PPUSH
7051: CALL_OW 69
7055: ST_TO_ADDR
// for i = 1 to 10 do
7056: LD_ADDR_VAR 0 2
7060: PUSH
7061: DOUBLE
7062: LD_INT 1
7064: DEC
7065: ST_TO_ADDR
7066: LD_INT 10
7068: PUSH
7069: FOR_TO
7070: IFFALSE 7142
// begin uc_nation := nation_nature ;
7072: LD_ADDR_OWVAR 21
7076: PUSH
7077: LD_INT 0
7079: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7080: LD_ADDR_OWVAR 28
7084: PUSH
7085: LD_INT 15
7087: ST_TO_ADDR
// hc_gallery :=  ;
7088: LD_ADDR_OWVAR 33
7092: PUSH
7093: LD_STRING 
7095: ST_TO_ADDR
// hc_name :=  ;
7096: LD_ADDR_OWVAR 26
7100: PUSH
7101: LD_STRING 
7103: ST_TO_ADDR
// un := CreateHuman ;
7104: LD_ADDR_VAR 0 4
7108: PUSH
7109: CALL_OW 44
7113: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7114: LD_VAR 0 4
7118: PPUSH
7119: LD_VAR 0 5
7123: PUSH
7124: LD_VAR 0 5
7128: PUSH
7129: LD_VAR 0 2
7133: MINUS
7134: ARRAY
7135: PPUSH
7136: CALL_OW 52
// end ;
7140: GO 7069
7142: POP
7143: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
7144: LD_INT 324
7146: PPUSH
7147: LD_INT 3
7149: PPUSH
7150: LD_STRING 
7152: PPUSH
7153: LD_INT 8
7155: PUSH
7156: LD_INT 9
7158: PUSH
7159: LD_INT 10
7161: PUSH
7162: EMPTY
7163: LIST
7164: LIST
7165: LIST
7166: PUSH
7167: LD_OWVAR 67
7171: ARRAY
7172: PPUSH
7173: LD_INT 3000
7175: PUSH
7176: LD_INT 500
7178: PUSH
7179: LD_INT 150
7181: PUSH
7182: EMPTY
7183: LIST
7184: LIST
7185: LIST
7186: PPUSH
7187: LD_INT 16
7189: PUSH
7190: LD_INT 6
7192: PUSH
7193: LD_INT 6
7195: PUSH
7196: LD_INT 8
7198: PUSH
7199: EMPTY
7200: LIST
7201: LIST
7202: LIST
7203: LIST
7204: PPUSH
7205: CALL 59523 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
7209: LD_ADDR_EXP 93
7213: PUSH
7214: LD_EXP 93
7218: PPUSH
7219: LD_INT 3
7221: PPUSH
7222: LD_INT 22
7224: PUSH
7225: LD_VAR 0 3
7229: PUSH
7230: EMPTY
7231: LIST
7232: LIST
7233: PUSH
7234: LD_INT 23
7236: PUSH
7237: LD_INT 2
7239: PUSH
7240: EMPTY
7241: LIST
7242: LIST
7243: PUSH
7244: LD_INT 3
7246: PUSH
7247: LD_INT 21
7249: PUSH
7250: LD_INT 2
7252: PUSH
7253: EMPTY
7254: LIST
7255: LIST
7256: PUSH
7257: EMPTY
7258: LIST
7259: LIST
7260: PUSH
7261: EMPTY
7262: LIST
7263: LIST
7264: LIST
7265: PPUSH
7266: CALL_OW 69
7270: PUSH
7271: LD_EXP 54
7275: DIFF
7276: PPUSH
7277: CALL_OW 1
7281: ST_TO_ADDR
// end ;
7282: LD_VAR 0 1
7286: RET
// export function BuildKozlovBomb ; begin
7287: LD_INT 0
7289: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7290: LD_INT 332
7292: PPUSH
7293: CALL_OW 302
7297: NOT
7298: PUSH
7299: LD_INT 336
7301: PPUSH
7302: CALL_OW 302
7306: NOT
7307: OR
7308: IFFALSE 7312
// exit ;
7310: GO 7409
// ComChangeProfession ( Kozlov , 4 ) ;
7312: LD_EXP 55
7316: PPUSH
7317: LD_INT 4
7319: PPUSH
7320: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7324: LD_INT 336
7326: PPUSH
7327: LD_INT 25
7329: PPUSH
7330: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7334: LD_INT 35
7336: PPUSH
7337: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7341: LD_INT 25
7343: PPUSH
7344: LD_INT 8
7346: PPUSH
7347: CALL_OW 321
7351: PUSH
7352: LD_INT 2
7354: EQUAL
7355: IFFALSE 7334
// ComExitBuilding ( Kozlov ) ;
7357: LD_EXP 55
7361: PPUSH
7362: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
7366: LD_EXP 55
7370: PPUSH
7371: LD_INT 332
7373: PPUSH
7374: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
7378: LD_EXP 55
7382: PPUSH
7383: LD_INT 3
7385: PPUSH
7386: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
7390: LD_INT 332
7392: PPUSH
7393: LD_INT 23
7395: PPUSH
7396: LD_INT 3
7398: PPUSH
7399: LD_INT 1
7401: PPUSH
7402: LD_INT 48
7404: PPUSH
7405: CALL_OW 125
// end ;
7409: LD_VAR 0 1
7413: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
7414: LD_EXP 3
7418: NOT
7419: PUSH
7420: LD_INT 3
7422: PPUSH
7423: LD_INT 1
7425: PPUSH
7426: CALL 46224 0 2
7430: NOT
7431: AND
7432: IFFALSE 8272
7434: GO 7436
7436: DISABLE
7437: LD_INT 0
7439: PPUSH
7440: PPUSH
7441: PPUSH
// begin enable ;
7442: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
7443: LD_INT 22
7445: PUSH
7446: LD_INT 8
7448: PUSH
7449: EMPTY
7450: LIST
7451: LIST
7452: PUSH
7453: LD_INT 23
7455: PUSH
7456: LD_INT 2
7458: PUSH
7459: EMPTY
7460: LIST
7461: LIST
7462: PUSH
7463: LD_INT 30
7465: PUSH
7466: LD_INT 3
7468: PUSH
7469: EMPTY
7470: LIST
7471: LIST
7472: PUSH
7473: EMPTY
7474: LIST
7475: LIST
7476: LIST
7477: PPUSH
7478: CALL_OW 69
7482: NOT
7483: IFFALSE 7487
// exit ;
7485: GO 8272
// if Prob ( 40 ) then
7487: LD_INT 40
7489: PPUSH
7490: CALL_OW 13
7494: IFFALSE 7621
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7496: LD_INT 3
7498: PPUSH
7499: LD_INT 14
7501: PUSH
7502: LD_INT 1
7504: PUSH
7505: LD_INT 2
7507: PUSH
7508: LD_INT 28
7510: PUSH
7511: EMPTY
7512: LIST
7513: LIST
7514: LIST
7515: LIST
7516: PUSH
7517: LD_INT 14
7519: PUSH
7520: LD_INT 1
7522: PUSH
7523: LD_INT 2
7525: PUSH
7526: LD_INT 28
7528: PUSH
7529: EMPTY
7530: LIST
7531: LIST
7532: LIST
7533: LIST
7534: PUSH
7535: LD_INT 14
7537: PUSH
7538: LD_INT 1
7540: PUSH
7541: LD_INT 2
7543: PUSH
7544: LD_INT 28
7546: PUSH
7547: EMPTY
7548: LIST
7549: LIST
7550: LIST
7551: LIST
7552: PUSH
7553: LD_INT 14
7555: PUSH
7556: LD_INT 1
7558: PUSH
7559: LD_INT 2
7561: PUSH
7562: LD_INT 28
7564: PUSH
7565: EMPTY
7566: LIST
7567: LIST
7568: LIST
7569: LIST
7570: PUSH
7571: LD_INT 14
7573: PUSH
7574: LD_INT 1
7576: PUSH
7577: LD_INT 2
7579: PUSH
7580: LD_INT 28
7582: PUSH
7583: EMPTY
7584: LIST
7585: LIST
7586: LIST
7587: LIST
7588: PUSH
7589: LD_INT 14
7591: PUSH
7592: LD_INT 1
7594: PUSH
7595: LD_INT 2
7597: PUSH
7598: LD_INT 26
7600: PUSH
7601: EMPTY
7602: LIST
7603: LIST
7604: LIST
7605: LIST
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: LIST
7611: LIST
7612: LIST
7613: LIST
7614: PPUSH
7615: CALL 44806 0 2
// end else
7619: GO 7812
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7621: LD_INT 3
7623: PPUSH
7624: LD_INT 14
7626: PUSH
7627: LD_INT 1
7629: PUSH
7630: LD_INT 2
7632: PUSH
7633: LD_INT 27
7635: PUSH
7636: LD_INT 26
7638: PUSH
7639: LD_INT 26
7641: PUSH
7642: EMPTY
7643: LIST
7644: LIST
7645: LIST
7646: PUSH
7647: LD_OWVAR 67
7651: ARRAY
7652: PUSH
7653: EMPTY
7654: LIST
7655: LIST
7656: LIST
7657: LIST
7658: PUSH
7659: LD_INT 14
7661: PUSH
7662: LD_INT 1
7664: PUSH
7665: LD_INT 2
7667: PUSH
7668: LD_INT 27
7670: PUSH
7671: LD_INT 26
7673: PUSH
7674: LD_INT 26
7676: PUSH
7677: EMPTY
7678: LIST
7679: LIST
7680: LIST
7681: PUSH
7682: LD_OWVAR 67
7686: ARRAY
7687: PUSH
7688: EMPTY
7689: LIST
7690: LIST
7691: LIST
7692: LIST
7693: PUSH
7694: LD_INT 14
7696: PUSH
7697: LD_INT 1
7699: PUSH
7700: LD_INT 2
7702: PUSH
7703: LD_INT 26
7705: PUSH
7706: LD_INT 26
7708: PUSH
7709: LD_INT 29
7711: PUSH
7712: EMPTY
7713: LIST
7714: LIST
7715: LIST
7716: PUSH
7717: LD_OWVAR 67
7721: ARRAY
7722: PUSH
7723: EMPTY
7724: LIST
7725: LIST
7726: LIST
7727: LIST
7728: PUSH
7729: LD_INT 13
7731: PUSH
7732: LD_INT 1
7734: PUSH
7735: LD_INT 2
7737: PUSH
7738: LD_INT 26
7740: PUSH
7741: LD_INT 29
7743: PUSH
7744: LD_INT 29
7746: PUSH
7747: EMPTY
7748: LIST
7749: LIST
7750: LIST
7751: PUSH
7752: LD_OWVAR 67
7756: ARRAY
7757: PUSH
7758: EMPTY
7759: LIST
7760: LIST
7761: LIST
7762: LIST
7763: PUSH
7764: LD_INT 13
7766: PUSH
7767: LD_INT 1
7769: PUSH
7770: LD_INT 2
7772: PUSH
7773: LD_INT 29
7775: PUSH
7776: EMPTY
7777: LIST
7778: LIST
7779: LIST
7780: LIST
7781: PUSH
7782: LD_INT 14
7784: PUSH
7785: LD_INT 1
7787: PUSH
7788: LD_INT 2
7790: PUSH
7791: LD_INT 26
7793: PUSH
7794: EMPTY
7795: LIST
7796: LIST
7797: LIST
7798: LIST
7799: PUSH
7800: EMPTY
7801: LIST
7802: LIST
7803: LIST
7804: LIST
7805: LIST
7806: LIST
7807: PPUSH
7808: CALL 44806 0 2
// end ; repeat wait ( 0 0$1 ) ;
7812: LD_INT 35
7814: PPUSH
7815: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
7819: LD_INT 3
7821: PPUSH
7822: LD_INT 1
7824: PPUSH
7825: CALL 46224 0 2
7829: PUSH
7830: LD_INT 6
7832: GREATEREQUAL
7833: IFFALSE 7812
// wait ( 0 0$30 ) ;
7835: LD_INT 1050
7837: PPUSH
7838: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
7842: LD_ADDR_VAR 0 2
7846: PUSH
7847: LD_INT 3
7849: PPUSH
7850: LD_INT 1
7852: PPUSH
7853: CALL 46224 0 2
7857: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
7858: LD_ADDR_EXP 112
7862: PUSH
7863: LD_EXP 112
7867: PPUSH
7868: LD_INT 3
7870: PPUSH
7871: LD_EXP 112
7875: PUSH
7876: LD_INT 3
7878: ARRAY
7879: PUSH
7880: LD_VAR 0 2
7884: DIFF
7885: PPUSH
7886: CALL_OW 1
7890: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
7891: LD_ADDR_VAR 0 3
7895: PUSH
7896: LD_INT 0
7898: PPUSH
7899: LD_INT 2
7901: PPUSH
7902: CALL_OW 12
7906: ST_TO_ADDR
// if target then
7907: LD_VAR 0 3
7911: IFFALSE 8039
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7913: LD_ADDR_VAR 0 2
7917: PUSH
7918: LD_VAR 0 2
7922: PPUSH
7923: LD_INT 24
7925: PUSH
7926: LD_INT 250
7928: PUSH
7929: EMPTY
7930: LIST
7931: LIST
7932: PPUSH
7933: CALL_OW 72
7937: ST_TO_ADDR
// for i in tmp do
7938: LD_ADDR_VAR 0 1
7942: PUSH
7943: LD_VAR 0 2
7947: PUSH
7948: FOR_IN
7949: IFFALSE 7989
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
7951: LD_VAR 0 1
7955: PPUSH
7956: LD_INT 89
7958: PPUSH
7959: LD_INT 71
7961: PPUSH
7962: CALL_OW 297
7966: PUSH
7967: LD_INT 9
7969: GREATER
7970: IFFALSE 7987
// ComMoveXY ( i , 89 , 71 ) ;
7972: LD_VAR 0 1
7976: PPUSH
7977: LD_INT 89
7979: PPUSH
7980: LD_INT 71
7982: PPUSH
7983: CALL_OW 111
7987: GO 7948
7989: POP
7990: POP
// wait ( 0 0$1 ) ;
7991: LD_INT 35
7993: PPUSH
7994: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
7998: LD_VAR 0 2
8002: PPUSH
8003: LD_INT 92
8005: PUSH
8006: LD_INT 89
8008: PUSH
8009: LD_INT 71
8011: PUSH
8012: LD_INT 9
8014: PUSH
8015: EMPTY
8016: LIST
8017: LIST
8018: LIST
8019: LIST
8020: PPUSH
8021: CALL_OW 72
8025: PUSH
8026: LD_VAR 0 2
8030: PUSH
8031: LD_INT 1
8033: MINUS
8034: GREATEREQUAL
8035: IFFALSE 7913
// end else
8037: GO 8163
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8039: LD_ADDR_VAR 0 2
8043: PUSH
8044: LD_VAR 0 2
8048: PPUSH
8049: LD_INT 24
8051: PUSH
8052: LD_INT 250
8054: PUSH
8055: EMPTY
8056: LIST
8057: LIST
8058: PPUSH
8059: CALL_OW 72
8063: ST_TO_ADDR
// for i in tmp do
8064: LD_ADDR_VAR 0 1
8068: PUSH
8069: LD_VAR 0 2
8073: PUSH
8074: FOR_IN
8075: IFFALSE 8115
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
8077: LD_VAR 0 1
8081: PPUSH
8082: LD_INT 147
8084: PPUSH
8085: LD_INT 4
8087: PPUSH
8088: CALL_OW 297
8092: PUSH
8093: LD_INT 9
8095: GREATER
8096: IFFALSE 8113
// ComMoveXY ( i , 147 , 4 ) ;
8098: LD_VAR 0 1
8102: PPUSH
8103: LD_INT 147
8105: PPUSH
8106: LD_INT 4
8108: PPUSH
8109: CALL_OW 111
8113: GO 8074
8115: POP
8116: POP
// wait ( 0 0$1 ) ;
8117: LD_INT 35
8119: PPUSH
8120: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
8124: LD_VAR 0 2
8128: PPUSH
8129: LD_INT 92
8131: PUSH
8132: LD_INT 147
8134: PUSH
8135: LD_INT 4
8137: PUSH
8138: LD_INT 9
8140: PUSH
8141: EMPTY
8142: LIST
8143: LIST
8144: LIST
8145: LIST
8146: PPUSH
8147: CALL_OW 72
8151: PUSH
8152: LD_VAR 0 2
8156: PUSH
8157: LD_INT 1
8159: MINUS
8160: GREATEREQUAL
8161: IFFALSE 8039
// end ; repeat wait ( 0 0$1 ) ;
8163: LD_INT 35
8165: PPUSH
8166: CALL_OW 67
// for i in tmp do
8170: LD_ADDR_VAR 0 1
8174: PUSH
8175: LD_VAR 0 2
8179: PUSH
8180: FOR_IN
8181: IFFALSE 8263
// begin if GetLives ( i ) > 251 then
8183: LD_VAR 0 1
8187: PPUSH
8188: CALL_OW 256
8192: PUSH
8193: LD_INT 251
8195: GREATER
8196: IFFALSE 8234
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
8198: LD_VAR 0 1
8202: PPUSH
8203: LD_INT 81
8205: PUSH
8206: LD_INT 8
8208: PUSH
8209: EMPTY
8210: LIST
8211: LIST
8212: PPUSH
8213: CALL_OW 69
8217: PPUSH
8218: LD_VAR 0 1
8222: PPUSH
8223: CALL_OW 74
8227: PPUSH
8228: CALL_OW 115
8232: GO 8261
// if IsDead ( i ) then
8234: LD_VAR 0 1
8238: PPUSH
8239: CALL_OW 301
8243: IFFALSE 8261
// tmp := tmp diff i ;
8245: LD_ADDR_VAR 0 2
8249: PUSH
8250: LD_VAR 0 2
8254: PUSH
8255: LD_VAR 0 1
8259: DIFF
8260: ST_TO_ADDR
// end ;
8261: GO 8180
8263: POP
8264: POP
// until not tmp ;
8265: LD_VAR 0 2
8269: NOT
8270: IFFALSE 8163
// end ;
8272: PPOPN 3
8274: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8275: LD_EXP 55
8279: PPUSH
8280: CALL_OW 302
8284: PUSH
8285: LD_EXP 3
8289: NOT
8290: AND
8291: IFFALSE 8300
8293: GO 8295
8295: DISABLE
// BuildKozlovBomb ;
8296: CALL 7287 0 0
8300: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8301: LD_INT 22
8303: PUSH
8304: LD_INT 8
8306: PUSH
8307: EMPTY
8308: LIST
8309: LIST
8310: PUSH
8311: LD_INT 34
8313: PUSH
8314: LD_INT 48
8316: PUSH
8317: EMPTY
8318: LIST
8319: LIST
8320: PUSH
8321: EMPTY
8322: LIST
8323: LIST
8324: PPUSH
8325: CALL_OW 69
8329: IFFALSE 8377
8331: GO 8333
8333: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
8334: LD_INT 22
8336: PUSH
8337: LD_INT 8
8339: PUSH
8340: EMPTY
8341: LIST
8342: LIST
8343: PUSH
8344: LD_INT 34
8346: PUSH
8347: LD_INT 48
8349: PUSH
8350: EMPTY
8351: LIST
8352: LIST
8353: PUSH
8354: EMPTY
8355: LIST
8356: LIST
8357: PPUSH
8358: CALL_OW 69
8362: PUSH
8363: LD_INT 1
8365: ARRAY
8366: PPUSH
8367: LD_INT 173
8369: PPUSH
8370: LD_INT 96
8372: PPUSH
8373: CALL_OW 116
// end ; end_of_file
8377: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
8378: LD_INT 0
8380: PPUSH
8381: PPUSH
8382: PPUSH
8383: PPUSH
8384: PPUSH
8385: PPUSH
8386: PPUSH
8387: PPUSH
8388: PPUSH
// side := 3 ;
8389: LD_ADDR_VAR 0 6
8393: PUSH
8394: LD_INT 3
8396: ST_TO_ADDR
// InitHc ;
8397: CALL_OW 19
// uc_side := side ;
8401: LD_ADDR_OWVAR 20
8405: PUSH
8406: LD_VAR 0 6
8410: ST_TO_ADDR
// uc_nation := 3 ;
8411: LD_ADDR_OWVAR 21
8415: PUSH
8416: LD_INT 3
8418: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
8419: LD_ADDR_VAR 0 2
8423: PUSH
8424: LD_INT 22
8426: PUSH
8427: LD_VAR 0 6
8431: PUSH
8432: EMPTY
8433: LIST
8434: LIST
8435: PUSH
8436: LD_INT 21
8438: PUSH
8439: LD_INT 3
8441: PUSH
8442: EMPTY
8443: LIST
8444: LIST
8445: PUSH
8446: EMPTY
8447: LIST
8448: LIST
8449: PPUSH
8450: CALL_OW 69
8454: PUSH
8455: FOR_IN
8456: IFFALSE 8472
// SetBLevel ( i , 10 ) ;
8458: LD_VAR 0 2
8462: PPUSH
8463: LD_INT 10
8465: PPUSH
8466: CALL_OW 241
8470: GO 8455
8472: POP
8473: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
8474: LD_ADDR_VAR 0 9
8478: PUSH
8479: LD_INT 22
8481: PUSH
8482: LD_VAR 0 6
8486: PUSH
8487: EMPTY
8488: LIST
8489: LIST
8490: PUSH
8491: LD_INT 30
8493: PUSH
8494: LD_INT 34
8496: PUSH
8497: EMPTY
8498: LIST
8499: LIST
8500: PUSH
8501: EMPTY
8502: LIST
8503: LIST
8504: PPUSH
8505: CALL_OW 69
8509: ST_TO_ADDR
// if teleport then
8510: LD_VAR 0 9
8514: IFFALSE 8535
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
8516: LD_VAR 0 9
8520: PUSH
8521: LD_INT 1
8523: ARRAY
8524: PPUSH
8525: LD_INT 123
8527: PPUSH
8528: LD_INT 122
8530: PPUSH
8531: CALL_OW 243
// hc_importance := 0 ;
8535: LD_ADDR_OWVAR 32
8539: PUSH
8540: LD_INT 0
8542: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
8543: LD_ADDR_EXP 56
8547: PUSH
8548: LD_STRING Platonov
8550: PPUSH
8551: CALL_OW 25
8555: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
8556: LD_ADDR_EXP 57
8560: PUSH
8561: LD_STRING Yakotich
8563: PPUSH
8564: CALL_OW 25
8568: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
8569: LD_ADDR_EXP 58
8573: PUSH
8574: LD_STRING Gleb
8576: PPUSH
8577: CALL_OW 25
8581: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
8582: LD_STRING 03_Cornel
8584: PPUSH
8585: CALL_OW 28
8589: IFFALSE 8637
// begin Bierezov := NewCharacter ( Mikhail ) ;
8591: LD_ADDR_EXP 59
8595: PUSH
8596: LD_STRING Mikhail
8598: PPUSH
8599: CALL_OW 25
8603: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
8604: LD_EXP 59
8608: PPUSH
8609: LD_INT 197
8611: PPUSH
8612: LD_INT 111
8614: PPUSH
8615: LD_INT 9
8617: PPUSH
8618: LD_INT 0
8620: PPUSH
8621: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
8625: LD_EXP 59
8629: PPUSH
8630: LD_INT 3
8632: PPUSH
8633: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
8637: LD_EXP 56
8641: PPUSH
8642: LD_INT 126
8644: PPUSH
8645: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
8649: LD_EXP 57
8653: PPUSH
8654: LD_INT 197
8656: PPUSH
8657: LD_INT 111
8659: PPUSH
8660: LD_INT 9
8662: PPUSH
8663: LD_INT 0
8665: PPUSH
8666: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
8670: LD_EXP 58
8674: PPUSH
8675: LD_INT 197
8677: PPUSH
8678: LD_INT 111
8680: PPUSH
8681: LD_INT 9
8683: PPUSH
8684: LD_INT 0
8686: PPUSH
8687: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 9000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
8691: LD_ADDR_VAR 0 5
8695: PUSH
8696: LD_INT 126
8698: PPUSH
8699: LD_INT 2
8701: PPUSH
8702: LD_STRING zhukov
8704: PPUSH
8705: LD_INT 9
8707: PUSH
8708: LD_INT 10
8710: PUSH
8711: LD_INT 10
8713: PUSH
8714: EMPTY
8715: LIST
8716: LIST
8717: LIST
8718: PUSH
8719: LD_OWVAR 67
8723: ARRAY
8724: PPUSH
8725: LD_INT 9000
8727: PUSH
8728: LD_INT 1000
8730: PUSH
8731: LD_INT 300
8733: PUSH
8734: EMPTY
8735: LIST
8736: LIST
8737: LIST
8738: PPUSH
8739: LD_INT 21
8741: PUSH
8742: LD_INT 8
8744: PUSH
8745: LD_INT 13
8747: PUSH
8748: LD_INT 8
8750: PUSH
8751: EMPTY
8752: LIST
8753: LIST
8754: LIST
8755: LIST
8756: PPUSH
8757: CALL 59523 0 6
8761: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
8762: LD_ADDR_VAR 0 4
8766: PUSH
8767: LD_INT 267
8769: PPUSH
8770: CALL_OW 274
8774: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
8775: LD_VAR 0 4
8779: PPUSH
8780: LD_INT 1
8782: PPUSH
8783: LD_INT 5000
8785: PPUSH
8786: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8790: LD_VAR 0 4
8794: PPUSH
8795: LD_INT 2
8797: PPUSH
8798: LD_INT 200
8800: PPUSH
8801: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8805: LD_VAR 0 4
8809: PPUSH
8810: LD_INT 3
8812: PPUSH
8813: LD_INT 200
8815: PPUSH
8816: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
8820: LD_ADDR_EXP 93
8824: PUSH
8825: LD_EXP 93
8829: PPUSH
8830: LD_INT 2
8832: PPUSH
8833: LD_VAR 0 5
8837: PUSH
8838: LD_INT 22
8840: PUSH
8841: LD_VAR 0 6
8845: PUSH
8846: EMPTY
8847: LIST
8848: LIST
8849: PUSH
8850: LD_INT 3
8852: PUSH
8853: LD_INT 21
8855: PUSH
8856: LD_INT 2
8858: PUSH
8859: EMPTY
8860: LIST
8861: LIST
8862: PUSH
8863: EMPTY
8864: LIST
8865: LIST
8866: PUSH
8867: EMPTY
8868: LIST
8869: LIST
8870: PPUSH
8871: CALL_OW 69
8875: UNION
8876: PUSH
8877: LD_EXP 56
8881: DIFF
8882: PPUSH
8883: CALL_OW 1
8887: ST_TO_ADDR
// behemoths := [ ] ;
8888: LD_ADDR_EXP 60
8892: PUSH
8893: EMPTY
8894: ST_TO_ADDR
// behemothBuilders := [ ] ;
8895: LD_ADDR_EXP 61
8899: PUSH
8900: EMPTY
8901: ST_TO_ADDR
// j := 3 ;
8902: LD_ADDR_VAR 0 3
8906: PUSH
8907: LD_INT 3
8909: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
8910: LD_ADDR_VAR 0 2
8914: PUSH
8915: LD_INT 22
8917: PUSH
8918: LD_INT 3
8920: PUSH
8921: EMPTY
8922: LIST
8923: LIST
8924: PUSH
8925: LD_INT 25
8927: PUSH
8928: LD_INT 3
8930: PUSH
8931: EMPTY
8932: LIST
8933: LIST
8934: PUSH
8935: EMPTY
8936: LIST
8937: LIST
8938: PPUSH
8939: CALL_OW 69
8943: PUSH
8944: FOR_IN
8945: IFFALSE 8995
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8947: LD_ADDR_EXP 61
8951: PUSH
8952: LD_EXP 61
8956: PPUSH
8957: LD_VAR 0 2
8961: PPUSH
8962: CALL 87950 0 2
8966: ST_TO_ADDR
// j := j - 1 ;
8967: LD_ADDR_VAR 0 3
8971: PUSH
8972: LD_VAR 0 3
8976: PUSH
8977: LD_INT 1
8979: MINUS
8980: ST_TO_ADDR
// if j = 0 then
8981: LD_VAR 0 3
8985: PUSH
8986: LD_INT 0
8988: EQUAL
8989: IFFALSE 8993
// break ;
8991: GO 8995
// end ;
8993: GO 8944
8995: POP
8996: POP
// end ;
8997: LD_VAR 0 1
9001: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
9002: LD_INT 0
9004: PPUSH
9005: PPUSH
9006: PPUSH
9007: PPUSH
9008: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
9009: LD_ADDR_VAR 0 4
9013: PUSH
9014: LD_INT 209
9016: PUSH
9017: LD_INT 149
9019: PUSH
9020: EMPTY
9021: LIST
9022: LIST
9023: PUSH
9024: LD_INT 219
9026: PUSH
9027: LD_INT 154
9029: PUSH
9030: EMPTY
9031: LIST
9032: LIST
9033: PUSH
9034: LD_INT 223
9036: PUSH
9037: LD_INT 149
9039: PUSH
9040: EMPTY
9041: LIST
9042: LIST
9043: PUSH
9044: LD_INT 232
9046: PUSH
9047: LD_INT 155
9049: PUSH
9050: EMPTY
9051: LIST
9052: LIST
9053: PUSH
9054: EMPTY
9055: LIST
9056: LIST
9057: LIST
9058: LIST
9059: ST_TO_ADDR
// if not behemothBuilders then
9060: LD_EXP 61
9064: NOT
9065: IFFALSE 9069
// exit ;
9067: GO 9173
// j := 1 ;
9069: LD_ADDR_VAR 0 3
9073: PUSH
9074: LD_INT 1
9076: ST_TO_ADDR
// for i in behemothBuilders do
9077: LD_ADDR_VAR 0 2
9081: PUSH
9082: LD_EXP 61
9086: PUSH
9087: FOR_IN
9088: IFFALSE 9171
// begin if IsInUnit ( i ) then
9090: LD_VAR 0 2
9094: PPUSH
9095: CALL_OW 310
9099: IFFALSE 9110
// ComExitBuilding ( i ) ;
9101: LD_VAR 0 2
9105: PPUSH
9106: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
9110: LD_VAR 0 2
9114: PPUSH
9115: LD_INT 37
9117: PPUSH
9118: LD_VAR 0 4
9122: PUSH
9123: LD_VAR 0 3
9127: ARRAY
9128: PUSH
9129: LD_INT 1
9131: ARRAY
9132: PPUSH
9133: LD_VAR 0 4
9137: PUSH
9138: LD_VAR 0 3
9142: ARRAY
9143: PUSH
9144: LD_INT 2
9146: ARRAY
9147: PPUSH
9148: LD_INT 0
9150: PPUSH
9151: CALL_OW 230
// j := j + 1 ;
9155: LD_ADDR_VAR 0 3
9159: PUSH
9160: LD_VAR 0 3
9164: PUSH
9165: LD_INT 1
9167: PLUS
9168: ST_TO_ADDR
// end ;
9169: GO 9087
9171: POP
9172: POP
// end ;
9173: LD_VAR 0 1
9177: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
9178: LD_INT 3
9180: PPUSH
9181: CALL 88011 0 1
9185: PUSH
9186: LD_INT 22
9188: PUSH
9189: LD_INT 3
9191: PUSH
9192: EMPTY
9193: LIST
9194: LIST
9195: PUSH
9196: LD_INT 30
9198: PUSH
9199: LD_INT 37
9201: PUSH
9202: EMPTY
9203: LIST
9204: LIST
9205: PUSH
9206: EMPTY
9207: LIST
9208: LIST
9209: PPUSH
9210: CALL_OW 69
9214: NOT
9215: AND
9216: IFFALSE 9402
9218: GO 9220
9220: DISABLE
9221: LD_INT 0
9223: PPUSH
9224: PPUSH
// begin enable ;
9225: ENABLE
// tmp := GetBehemoths ( 3 ) ;
9226: LD_ADDR_VAR 0 2
9230: PUSH
9231: LD_INT 3
9233: PPUSH
9234: CALL 88011 0 1
9238: ST_TO_ADDR
// for i in tmp do
9239: LD_ADDR_VAR 0 1
9243: PUSH
9244: LD_VAR 0 2
9248: PUSH
9249: FOR_IN
9250: IFFALSE 9400
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
9252: LD_VAR 0 1
9256: PPUSH
9257: LD_INT 7
9259: PPUSH
9260: CALL_OW 308
9264: PUSH
9265: LD_VAR 0 1
9269: PPUSH
9270: CALL_OW 110
9274: PUSH
9275: LD_INT 2
9277: EQUAL
9278: NOT
9279: AND
9280: IFFALSE 9294
// SetTag ( i , 2 ) ;
9282: LD_VAR 0 1
9286: PPUSH
9287: LD_INT 2
9289: PPUSH
9290: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
9294: LD_INT 81
9296: PUSH
9297: LD_INT 3
9299: PUSH
9300: EMPTY
9301: LIST
9302: LIST
9303: PUSH
9304: LD_INT 91
9306: PUSH
9307: LD_VAR 0 1
9311: PUSH
9312: LD_INT 12
9314: PUSH
9315: EMPTY
9316: LIST
9317: LIST
9318: LIST
9319: PUSH
9320: EMPTY
9321: LIST
9322: LIST
9323: PPUSH
9324: CALL_OW 69
9328: NOT
9329: PUSH
9330: LD_VAR 0 1
9334: PPUSH
9335: CALL_OW 110
9339: PUSH
9340: LD_INT 2
9342: EQUAL
9343: NOT
9344: AND
9345: IFFALSE 9364
// ComAgressiveMove ( i , 64 , 93 ) else
9347: LD_VAR 0 1
9351: PPUSH
9352: LD_INT 64
9354: PPUSH
9355: LD_INT 93
9357: PPUSH
9358: CALL_OW 114
9362: GO 9398
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9364: LD_VAR 0 1
9368: PPUSH
9369: LD_INT 81
9371: PUSH
9372: LD_INT 3
9374: PUSH
9375: EMPTY
9376: LIST
9377: LIST
9378: PPUSH
9379: CALL_OW 69
9383: PPUSH
9384: LD_VAR 0 1
9388: PPUSH
9389: CALL_OW 74
9393: PPUSH
9394: CALL_OW 115
// end ;
9398: GO 9249
9400: POP
9401: POP
// end ;
9402: PPOPN 2
9404: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9405: LD_EXP 2
9409: NOT
9410: PUSH
9411: LD_INT 2
9413: PPUSH
9414: LD_INT 1
9416: PPUSH
9417: CALL 46224 0 2
9421: NOT
9422: AND
9423: IFFALSE 10343
9425: GO 9427
9427: DISABLE
9428: LD_INT 0
9430: PPUSH
9431: PPUSH
9432: PPUSH
9433: PPUSH
// begin enable ;
9434: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9435: LD_INT 22
9437: PUSH
9438: LD_INT 3
9440: PUSH
9441: EMPTY
9442: LIST
9443: LIST
9444: PUSH
9445: LD_INT 30
9447: PUSH
9448: LD_INT 3
9450: PUSH
9451: EMPTY
9452: LIST
9453: LIST
9454: PUSH
9455: EMPTY
9456: LIST
9457: LIST
9458: PPUSH
9459: CALL_OW 69
9463: NOT
9464: IFFALSE 9468
// exit ;
9466: GO 10343
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9468: LD_ADDR_VAR 0 4
9472: PUSH
9473: LD_INT 22
9475: PUSH
9476: LD_INT 3
9478: PUSH
9479: EMPTY
9480: LIST
9481: LIST
9482: PUSH
9483: LD_INT 30
9485: PUSH
9486: LD_INT 34
9488: PUSH
9489: EMPTY
9490: LIST
9491: LIST
9492: PUSH
9493: EMPTY
9494: LIST
9495: LIST
9496: PPUSH
9497: CALL_OW 69
9501: ST_TO_ADDR
// if Prob ( 40 ) then
9502: LD_INT 40
9504: PPUSH
9505: CALL_OW 13
9509: IFFALSE 9636
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9511: LD_INT 2
9513: PPUSH
9514: LD_INT 22
9516: PUSH
9517: LD_INT 3
9519: PUSH
9520: LD_INT 3
9522: PUSH
9523: LD_INT 49
9525: PUSH
9526: EMPTY
9527: LIST
9528: LIST
9529: LIST
9530: LIST
9531: PUSH
9532: LD_INT 22
9534: PUSH
9535: LD_INT 3
9537: PUSH
9538: LD_INT 3
9540: PUSH
9541: LD_INT 49
9543: PUSH
9544: EMPTY
9545: LIST
9546: LIST
9547: LIST
9548: LIST
9549: PUSH
9550: LD_INT 22
9552: PUSH
9553: LD_INT 3
9555: PUSH
9556: LD_INT 3
9558: PUSH
9559: LD_INT 49
9561: PUSH
9562: EMPTY
9563: LIST
9564: LIST
9565: LIST
9566: LIST
9567: PUSH
9568: LD_INT 24
9570: PUSH
9571: LD_INT 3
9573: PUSH
9574: LD_INT 3
9576: PUSH
9577: LD_INT 46
9579: PUSH
9580: EMPTY
9581: LIST
9582: LIST
9583: LIST
9584: LIST
9585: PUSH
9586: LD_INT 24
9588: PUSH
9589: LD_INT 3
9591: PUSH
9592: LD_INT 3
9594: PUSH
9595: LD_INT 46
9597: PUSH
9598: EMPTY
9599: LIST
9600: LIST
9601: LIST
9602: LIST
9603: PUSH
9604: LD_INT 24
9606: PUSH
9607: LD_INT 3
9609: PUSH
9610: LD_INT 3
9612: PUSH
9613: LD_INT 46
9615: PUSH
9616: EMPTY
9617: LIST
9618: LIST
9619: LIST
9620: LIST
9621: PUSH
9622: EMPTY
9623: LIST
9624: LIST
9625: LIST
9626: LIST
9627: LIST
9628: LIST
9629: PPUSH
9630: CALL 44806 0 2
// end else
9634: GO 9759
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9636: LD_INT 2
9638: PPUSH
9639: LD_INT 24
9641: PUSH
9642: LD_INT 3
9644: PUSH
9645: LD_INT 3
9647: PUSH
9648: LD_INT 47
9650: PUSH
9651: EMPTY
9652: LIST
9653: LIST
9654: LIST
9655: LIST
9656: PUSH
9657: LD_INT 24
9659: PUSH
9660: LD_INT 3
9662: PUSH
9663: LD_INT 3
9665: PUSH
9666: LD_INT 47
9668: PUSH
9669: EMPTY
9670: LIST
9671: LIST
9672: LIST
9673: LIST
9674: PUSH
9675: LD_INT 24
9677: PUSH
9678: LD_INT 3
9680: PUSH
9681: LD_INT 3
9683: PUSH
9684: LD_INT 47
9686: PUSH
9687: EMPTY
9688: LIST
9689: LIST
9690: LIST
9691: LIST
9692: PUSH
9693: LD_INT 24
9695: PUSH
9696: LD_INT 3
9698: PUSH
9699: LD_INT 3
9701: PUSH
9702: LD_INT 46
9704: PUSH
9705: EMPTY
9706: LIST
9707: LIST
9708: LIST
9709: LIST
9710: PUSH
9711: LD_INT 24
9713: PUSH
9714: LD_INT 3
9716: PUSH
9717: LD_INT 3
9719: PUSH
9720: LD_INT 46
9722: PUSH
9723: EMPTY
9724: LIST
9725: LIST
9726: LIST
9727: LIST
9728: PUSH
9729: LD_INT 24
9731: PUSH
9732: LD_INT 3
9734: PUSH
9735: LD_INT 3
9737: PUSH
9738: LD_INT 46
9740: PUSH
9741: EMPTY
9742: LIST
9743: LIST
9744: LIST
9745: LIST
9746: PUSH
9747: EMPTY
9748: LIST
9749: LIST
9750: LIST
9751: LIST
9752: LIST
9753: LIST
9754: PPUSH
9755: CALL 44806 0 2
// end ; if Difficulty > 1 then
9759: LD_OWVAR 67
9763: PUSH
9764: LD_INT 1
9766: GREATER
9767: IFFALSE 9797
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
9769: LD_INT 2
9771: PPUSH
9772: LD_INT 24
9774: PUSH
9775: LD_INT 3
9777: PUSH
9778: LD_INT 3
9780: PUSH
9781: LD_INT 47
9783: PUSH
9784: EMPTY
9785: LIST
9786: LIST
9787: LIST
9788: LIST
9789: PUSH
9790: EMPTY
9791: LIST
9792: PPUSH
9793: CALL 44806 0 2
// repeat wait ( 0 0$1 ) ;
9797: LD_INT 35
9799: PPUSH
9800: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
9804: LD_INT 2
9806: PPUSH
9807: LD_INT 1
9809: PPUSH
9810: CALL 46224 0 2
9814: PUSH
9815: LD_INT 6
9817: PUSH
9818: LD_INT 7
9820: PUSH
9821: LD_INT 7
9823: PUSH
9824: EMPTY
9825: LIST
9826: LIST
9827: LIST
9828: PUSH
9829: LD_OWVAR 67
9833: ARRAY
9834: GREATEREQUAL
9835: IFFALSE 9797
// wait ( 0 0$30 ) ;
9837: LD_INT 1050
9839: PPUSH
9840: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
9844: LD_ADDR_VAR 0 2
9848: PUSH
9849: LD_INT 2
9851: PPUSH
9852: LD_INT 1
9854: PPUSH
9855: CALL 46224 0 2
9859: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
9860: LD_ADDR_EXP 112
9864: PUSH
9865: LD_EXP 112
9869: PPUSH
9870: LD_INT 2
9872: PPUSH
9873: LD_EXP 112
9877: PUSH
9878: LD_INT 2
9880: ARRAY
9881: PUSH
9882: LD_VAR 0 2
9886: DIFF
9887: PPUSH
9888: CALL_OW 1
9892: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
9893: LD_ADDR_VAR 0 3
9897: PUSH
9898: LD_INT 0
9900: PPUSH
9901: LD_INT 1
9903: PPUSH
9904: CALL_OW 12
9908: ST_TO_ADDR
// if target then
9909: LD_VAR 0 3
9913: IFFALSE 10041
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9915: LD_ADDR_VAR 0 2
9919: PUSH
9920: LD_VAR 0 2
9924: PPUSH
9925: LD_INT 24
9927: PUSH
9928: LD_INT 250
9930: PUSH
9931: EMPTY
9932: LIST
9933: LIST
9934: PPUSH
9935: CALL_OW 72
9939: ST_TO_ADDR
// for i in tmp do
9940: LD_ADDR_VAR 0 1
9944: PUSH
9945: LD_VAR 0 2
9949: PUSH
9950: FOR_IN
9951: IFFALSE 9991
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
9953: LD_VAR 0 1
9957: PPUSH
9958: LD_INT 139
9960: PPUSH
9961: LD_INT 89
9963: PPUSH
9964: CALL_OW 297
9968: PUSH
9969: LD_INT 9
9971: GREATER
9972: IFFALSE 9989
// ComMoveXY ( i , 139 , 89 ) ;
9974: LD_VAR 0 1
9978: PPUSH
9979: LD_INT 139
9981: PPUSH
9982: LD_INT 89
9984: PPUSH
9985: CALL_OW 111
9989: GO 9950
9991: POP
9992: POP
// wait ( 0 0$1 ) ;
9993: LD_INT 35
9995: PPUSH
9996: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10000: LD_VAR 0 2
10004: PPUSH
10005: LD_INT 92
10007: PUSH
10008: LD_INT 139
10010: PUSH
10011: LD_INT 89
10013: PUSH
10014: LD_INT 9
10016: PUSH
10017: EMPTY
10018: LIST
10019: LIST
10020: LIST
10021: LIST
10022: PPUSH
10023: CALL_OW 72
10027: PUSH
10028: LD_VAR 0 2
10032: PUSH
10033: LD_INT 1
10035: MINUS
10036: GREATEREQUAL
10037: IFFALSE 9915
// end else
10039: GO 10183
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10041: LD_VAR 0 2
10045: PPUSH
10046: LD_VAR 0 4
10050: PUSH
10051: LD_INT 1
10053: ARRAY
10054: PPUSH
10055: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10059: LD_ADDR_VAR 0 2
10063: PUSH
10064: LD_VAR 0 2
10068: PPUSH
10069: LD_INT 24
10071: PUSH
10072: LD_INT 250
10074: PUSH
10075: EMPTY
10076: LIST
10077: LIST
10078: PPUSH
10079: CALL_OW 72
10083: ST_TO_ADDR
// for i in tmp do
10084: LD_ADDR_VAR 0 1
10088: PUSH
10089: LD_VAR 0 2
10093: PUSH
10094: FOR_IN
10095: IFFALSE 10135
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10097: LD_VAR 0 1
10101: PPUSH
10102: LD_INT 124
10104: PPUSH
10105: LD_INT 139
10107: PPUSH
10108: CALL_OW 297
10112: PUSH
10113: LD_INT 9
10115: GREATER
10116: IFFALSE 10133
// ComMoveXY ( i , 124 , 139 ) ;
10118: LD_VAR 0 1
10122: PPUSH
10123: LD_INT 124
10125: PPUSH
10126: LD_INT 139
10128: PPUSH
10129: CALL_OW 111
10133: GO 10094
10135: POP
10136: POP
// wait ( 0 0$1 ) ;
10137: LD_INT 35
10139: PPUSH
10140: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10144: LD_VAR 0 2
10148: PPUSH
10149: LD_INT 92
10151: PUSH
10152: LD_INT 124
10154: PUSH
10155: LD_INT 139
10157: PUSH
10158: LD_INT 9
10160: PUSH
10161: EMPTY
10162: LIST
10163: LIST
10164: LIST
10165: LIST
10166: PPUSH
10167: CALL_OW 72
10171: PUSH
10172: LD_VAR 0 2
10176: PUSH
10177: LD_INT 1
10179: MINUS
10180: GREATEREQUAL
10181: IFFALSE 10059
// end ; repeat wait ( 0 0$1 ) ;
10183: LD_INT 35
10185: PPUSH
10186: CALL_OW 67
// for i in tmp do
10190: LD_ADDR_VAR 0 1
10194: PUSH
10195: LD_VAR 0 2
10199: PUSH
10200: FOR_IN
10201: IFFALSE 10334
// begin if GetLives ( i ) > 251 then
10203: LD_VAR 0 1
10207: PPUSH
10208: CALL_OW 256
10212: PUSH
10213: LD_INT 251
10215: GREATER
10216: IFFALSE 10305
// begin if GetWeapon ( i ) = ru_time_lapser then
10218: LD_VAR 0 1
10222: PPUSH
10223: CALL_OW 264
10227: PUSH
10228: LD_INT 49
10230: EQUAL
10231: IFFALSE 10269
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
10233: LD_VAR 0 1
10237: PPUSH
10238: LD_INT 81
10240: PUSH
10241: LD_INT 3
10243: PUSH
10244: EMPTY
10245: LIST
10246: LIST
10247: PPUSH
10248: CALL_OW 69
10252: PPUSH
10253: LD_VAR 0 1
10257: PPUSH
10258: CALL_OW 74
10262: PPUSH
10263: CALL_OW 112
10267: GO 10303
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10269: LD_VAR 0 1
10273: PPUSH
10274: LD_INT 81
10276: PUSH
10277: LD_INT 3
10279: PUSH
10280: EMPTY
10281: LIST
10282: LIST
10283: PPUSH
10284: CALL_OW 69
10288: PPUSH
10289: LD_VAR 0 1
10293: PPUSH
10294: CALL_OW 74
10298: PPUSH
10299: CALL_OW 115
// end else
10303: GO 10332
// if IsDead ( i ) then
10305: LD_VAR 0 1
10309: PPUSH
10310: CALL_OW 301
10314: IFFALSE 10332
// tmp := tmp diff i ;
10316: LD_ADDR_VAR 0 2
10320: PUSH
10321: LD_VAR 0 2
10325: PUSH
10326: LD_VAR 0 1
10330: DIFF
10331: ST_TO_ADDR
// end ;
10332: GO 10200
10334: POP
10335: POP
// until not tmp ;
10336: LD_VAR 0 2
10340: NOT
10341: IFFALSE 10183
// end ;
10343: PPOPN 4
10345: END
// every 30 30$00 trigger not russianDestroyed do
10346: LD_EXP 2
10350: NOT
10351: IFFALSE 10416
10353: GO 10355
10355: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 ] [ Difficulty ] ) ;
10356: LD_INT 105000
10358: PUSH
10359: LD_INT 84000
10361: PUSH
10362: LD_INT 63000
10364: PUSH
10365: EMPTY
10366: LIST
10367: LIST
10368: LIST
10369: PUSH
10370: LD_OWVAR 67
10374: ARRAY
10375: PPUSH
10376: CALL_OW 67
// if russianDestroyed then
10380: LD_EXP 2
10384: IFFALSE 10388
// exit ;
10386: GO 10416
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
10388: LD_INT 2
10390: PPUSH
10391: LD_INT 23
10393: PUSH
10394: LD_INT 3
10396: PUSH
10397: LD_INT 1
10399: PUSH
10400: LD_INT 48
10402: PUSH
10403: EMPTY
10404: LIST
10405: LIST
10406: LIST
10407: LIST
10408: PUSH
10409: EMPTY
10410: LIST
10411: PPUSH
10412: CALL 44806 0 2
// end ; end_of_file
10416: END
// export function CustomEvent ( event ) ; begin
10417: LD_INT 0
10419: PPUSH
// end ;
10420: LD_VAR 0 2
10424: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10425: LD_VAR 0 2
10429: PPUSH
10430: LD_VAR 0 3
10434: PPUSH
10435: LD_INT 15
10437: PPUSH
10438: CALL_OW 309
10442: IFFALSE 10451
// YouLost ( MothContaminate ) ;
10444: LD_STRING MothContaminate
10446: PPUSH
10447: CALL_OW 104
// end ;
10451: PPOPN 3
10453: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10454: LD_VAR 0 2
10458: PPUSH
10459: LD_VAR 0 3
10463: PPUSH
10464: LD_INT 15
10466: PPUSH
10467: CALL_OW 309
10471: IFFALSE 10487
// begin wait ( 0 0$6 ) ;
10473: LD_INT 210
10475: PPUSH
10476: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
10480: LD_STRING MothContaminateBomb
10482: PPUSH
10483: CALL_OW 104
// end ; end ;
10487: PPOPN 3
10489: END
// on UnitDestroyed ( un ) do begin if un = JMM then
10490: LD_VAR 0 1
10494: PUSH
10495: LD_EXP 17
10499: EQUAL
10500: IFFALSE 10511
// begin YouLost ( JMM ) ;
10502: LD_STRING JMM
10504: PPUSH
10505: CALL_OW 104
// exit ;
10509: GO 10610
// end ; if un = Powell then
10511: LD_VAR 0 1
10515: PUSH
10516: LD_EXP 52
10520: EQUAL
10521: IFFALSE 10531
// americanDestroyed := true ;
10523: LD_ADDR_EXP 4
10527: PUSH
10528: LD_INT 1
10530: ST_TO_ADDR
// if un = Platonov then
10531: LD_VAR 0 1
10535: PUSH
10536: LD_EXP 56
10540: EQUAL
10541: IFFALSE 10551
// russianDestroyed := true ;
10543: LD_ADDR_EXP 2
10547: PUSH
10548: LD_INT 1
10550: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
10551: LD_VAR 0 1
10555: PUSH
10556: LD_INT 22
10558: PUSH
10559: LD_INT 7
10561: PUSH
10562: EMPTY
10563: LIST
10564: LIST
10565: PUSH
10566: LD_INT 21
10568: PUSH
10569: LD_INT 2
10571: PUSH
10572: EMPTY
10573: LIST
10574: LIST
10575: PUSH
10576: EMPTY
10577: LIST
10578: LIST
10579: PPUSH
10580: CALL_OW 69
10584: IN
10585: IFFALSE 10601
// vehicleLostCounter := vehicleLostCounter + 1 ;
10587: LD_ADDR_EXP 15
10591: PUSH
10592: LD_EXP 15
10596: PUSH
10597: LD_INT 1
10599: PLUS
10600: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
10601: LD_VAR 0 1
10605: PPUSH
10606: CALL 48226 0 1
// end ;
10610: PPOPN 1
10612: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10613: LD_VAR 0 1
10617: PPUSH
10618: LD_VAR 0 2
10622: PPUSH
10623: CALL 50560 0 2
// end ;
10627: PPOPN 2
10629: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10630: LD_VAR 0 1
10634: PPUSH
10635: CALL 49628 0 1
// end ;
10639: PPOPN 1
10641: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
10642: LD_VAR 0 1
10646: PUSH
10647: LD_INT 22
10649: PUSH
10650: LD_INT 8
10652: PUSH
10653: EMPTY
10654: LIST
10655: LIST
10656: PUSH
10657: LD_INT 30
10659: PUSH
10660: LD_INT 2
10662: PUSH
10663: EMPTY
10664: LIST
10665: LIST
10666: PUSH
10667: LD_INT 23
10669: PUSH
10670: LD_INT 3
10672: PUSH
10673: EMPTY
10674: LIST
10675: LIST
10676: PUSH
10677: EMPTY
10678: LIST
10679: LIST
10680: LIST
10681: PPUSH
10682: CALL_OW 69
10686: IN
10687: IFFALSE 10714
// begin ComUpgrade ( building ) ;
10689: LD_VAR 0 1
10693: PPUSH
10694: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
10698: LD_EXP 55
10702: PPUSH
10703: LD_VAR 0 1
10707: PPUSH
10708: CALL 59061 0 2
// exit ;
10712: GO 10723
// end ; MCE_BuildingComplete ( building ) ;
10714: LD_VAR 0 1
10718: PPUSH
10719: CALL 49869 0 1
// end ;
10723: PPOPN 1
10725: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10726: LD_VAR 0 1
10730: PPUSH
10731: LD_VAR 0 2
10735: PPUSH
10736: CALL 47922 0 2
// end ;
10740: PPOPN 2
10742: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10743: LD_VAR 0 1
10747: PPUSH
10748: LD_VAR 0 2
10752: PPUSH
10753: LD_VAR 0 3
10757: PPUSH
10758: LD_VAR 0 4
10762: PPUSH
10763: LD_VAR 0 5
10767: PPUSH
10768: CALL 47542 0 5
// end ;
10772: PPOPN 5
10774: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
10775: LD_VAR 0 1
10779: PPUSH
10780: LD_VAR 0 2
10784: PPUSH
10785: CALL 47123 0 2
// end ;
10789: PPOPN 2
10791: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10792: LD_VAR 0 1
10796: PPUSH
10797: LD_VAR 0 2
10801: PPUSH
10802: LD_VAR 0 3
10806: PPUSH
10807: LD_VAR 0 4
10811: PPUSH
10812: CALL 46961 0 4
// end ;
10816: PPOPN 4
10818: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10819: LD_VAR 0 1
10823: PPUSH
10824: LD_VAR 0 2
10828: PPUSH
10829: LD_VAR 0 3
10833: PPUSH
10834: CALL 46736 0 3
// end ;
10838: PPOPN 3
10840: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10841: LD_VAR 0 1
10845: PPUSH
10846: LD_VAR 0 2
10850: PPUSH
10851: CALL 46621 0 2
// end ;
10855: PPOPN 2
10857: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10858: LD_VAR 0 1
10862: PPUSH
10863: LD_VAR 0 2
10867: PPUSH
10868: CALL 50855 0 2
// end ;
10872: PPOPN 2
10874: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10875: LD_VAR 0 1
10879: PPUSH
10880: LD_VAR 0 2
10884: PPUSH
10885: LD_VAR 0 3
10889: PPUSH
10890: LD_VAR 0 4
10894: PPUSH
10895: CALL 51071 0 4
// end ;
10899: PPOPN 4
10901: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10902: LD_VAR 0 1
10906: PPUSH
10907: LD_VAR 0 2
10911: PPUSH
10912: CALL 46430 0 2
// end ;
10916: PPOPN 2
10918: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
10919: LD_VAR 0 1
10923: PPUSH
10924: CALL 103085 0 1
// end ; end_of_file
10928: PPOPN 1
10930: END
// export function Action ; begin
10931: LD_INT 0
10933: PPUSH
// InGameOn ;
10934: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
10938: LD_INT 206
10940: PPUSH
10941: LD_INT 11
10943: PPUSH
10944: CALL_OW 86
// wait ( 0 0$1 ) ;
10948: LD_INT 35
10950: PPUSH
10951: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
10955: LD_EXP 17
10959: PPUSH
10960: LD_STRING DStart-JMM-JMM-1
10962: PPUSH
10963: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
10967: LD_EXP 49
10971: PPUSH
10972: LD_STRING DStart-JMM-Bur-1
10974: PPUSH
10975: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
10979: LD_EXP 17
10983: PPUSH
10984: LD_STRING DStart-JMM-JMM-2
10986: PPUSH
10987: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
10991: LD_EXP 49
10995: PPUSH
10996: LD_STRING DStart-JMM-Bur-2
10998: PPUSH
10999: CALL_OW 88
// InGameOff ;
11003: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
11007: LD_STRING MStart
11009: PPUSH
11010: CALL_OW 337
// SaveForQuickRestart ;
11014: CALL_OW 22
// end ;
11018: LD_VAR 0 1
11022: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
11023: LD_INT 7
11025: PPUSH
11026: LD_INT 255
11028: PPUSH
11029: LD_INT 219
11031: PPUSH
11032: CALL_OW 293
11036: IFFALSE 11645
11038: GO 11040
11040: DISABLE
11041: LD_INT 0
11043: PPUSH
// begin wait ( 0 0$3 ) ;
11044: LD_INT 105
11046: PPUSH
11047: CALL_OW 67
// alienSpotted := true ;
11051: LD_ADDR_EXP 10
11055: PUSH
11056: LD_INT 1
11058: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
11059: LD_ADDR_VAR 0 1
11063: PUSH
11064: LD_INT 22
11066: PUSH
11067: LD_INT 7
11069: PUSH
11070: EMPTY
11071: LIST
11072: LIST
11073: PUSH
11074: LD_INT 23
11076: PUSH
11077: LD_INT 3
11079: PUSH
11080: EMPTY
11081: LIST
11082: LIST
11083: PUSH
11084: LD_INT 21
11086: PUSH
11087: LD_INT 1
11089: PUSH
11090: EMPTY
11091: LIST
11092: LIST
11093: PUSH
11094: LD_INT 26
11096: PUSH
11097: LD_INT 1
11099: PUSH
11100: EMPTY
11101: LIST
11102: LIST
11103: PUSH
11104: EMPTY
11105: LIST
11106: LIST
11107: LIST
11108: LIST
11109: PPUSH
11110: CALL_OW 69
11114: PUSH
11115: LD_EXP 49
11119: PUSH
11120: LD_EXP 37
11124: PUSH
11125: LD_EXP 39
11129: PUSH
11130: LD_EXP 40
11134: PUSH
11135: LD_EXP 47
11139: PUSH
11140: LD_EXP 46
11144: PUSH
11145: LD_EXP 41
11149: PUSH
11150: EMPTY
11151: LIST
11152: LIST
11153: LIST
11154: LIST
11155: LIST
11156: LIST
11157: LIST
11158: DIFF
11159: ST_TO_ADDR
// DialogueOn ;
11160: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
11164: LD_INT 255
11166: PPUSH
11167: LD_INT 219
11169: PPUSH
11170: LD_INT 7
11172: PPUSH
11173: LD_INT 20
11175: NEG
11176: PPUSH
11177: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
11181: LD_INT 255
11183: PPUSH
11184: LD_INT 219
11186: PPUSH
11187: CALL_OW 86
// if speaker then
11191: LD_VAR 0 1
11195: IFFALSE 11213
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
11197: LD_VAR 0 1
11201: PUSH
11202: LD_INT 1
11204: ARRAY
11205: PPUSH
11206: LD_STRING DAlienBase-RSol1-1
11208: PPUSH
11209: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
11213: LD_EXP 17
11217: PPUSH
11218: LD_STRING DAlienBase-JMM-1
11220: PPUSH
11221: CALL_OW 88
// if IsOk ( Burlak ) then
11225: LD_EXP 49
11229: PPUSH
11230: CALL_OW 302
11234: IFFALSE 11255
// begin dwait ( 0 0$1 ) ;
11236: LD_INT 35
11238: PPUSH
11239: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
11243: LD_EXP 49
11247: PPUSH
11248: LD_STRING DAlienBase-Bur-1
11250: PPUSH
11251: CALL_OW 88
// end ; if IsOk ( Roth ) then
11255: LD_EXP 18
11259: PPUSH
11260: CALL_OW 302
11264: IFFALSE 11278
// Say ( Roth , DAlienBase-Roth-1 ) ;
11266: LD_EXP 18
11270: PPUSH
11271: LD_STRING DAlienBase-Roth-1
11273: PPUSH
11274: CALL_OW 88
// if IsOk ( Gossudarov ) then
11278: LD_EXP 35
11282: PPUSH
11283: CALL_OW 302
11287: IFFALSE 11303
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
11289: LD_EXP 35
11293: PPUSH
11294: LD_STRING DAlienBase-Gos-1
11296: PPUSH
11297: CALL_OW 88
11301: GO 11420
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11303: LD_ADDR_VAR 0 1
11307: PUSH
11308: LD_INT 22
11310: PUSH
11311: LD_INT 7
11313: PUSH
11314: EMPTY
11315: LIST
11316: LIST
11317: PUSH
11318: LD_INT 25
11320: PUSH
11321: LD_INT 4
11323: PUSH
11324: EMPTY
11325: LIST
11326: LIST
11327: PUSH
11328: LD_INT 21
11330: PUSH
11331: LD_INT 1
11333: PUSH
11334: EMPTY
11335: LIST
11336: LIST
11337: PUSH
11338: LD_INT 26
11340: PUSH
11341: LD_INT 1
11343: PUSH
11344: EMPTY
11345: LIST
11346: LIST
11347: PUSH
11348: EMPTY
11349: LIST
11350: LIST
11351: LIST
11352: LIST
11353: PPUSH
11354: CALL_OW 69
11358: PUSH
11359: LD_EXP 18
11363: PUSH
11364: LD_EXP 17
11368: PUSH
11369: LD_EXP 49
11373: PUSH
11374: LD_EXP 37
11378: PUSH
11379: LD_EXP 47
11383: PUSH
11384: LD_EXP 46
11388: PUSH
11389: EMPTY
11390: LIST
11391: LIST
11392: LIST
11393: LIST
11394: LIST
11395: LIST
11396: DIFF
11397: ST_TO_ADDR
// if speaker then
11398: LD_VAR 0 1
11402: IFFALSE 11420
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
11404: LD_VAR 0 1
11408: PUSH
11409: LD_INT 1
11411: ARRAY
11412: PPUSH
11413: LD_STRING DAlienBase-Sci1-1
11415: PPUSH
11416: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
11420: LD_INT 255
11422: PPUSH
11423: LD_INT 219
11425: PPUSH
11426: LD_INT 7
11428: PPUSH
11429: CALL_OW 331
// DialogueOff ;
11433: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
11437: LD_INT 35
11439: PPUSH
11440: CALL_OW 67
// until IsSelected ( alien ) ;
11444: LD_INT 1
11446: PPUSH
11447: CALL_OW 306
11451: IFFALSE 11437
// if not artifactIResearched or not artifactIIResearched then
11453: LD_EXP 12
11457: NOT
11458: PUSH
11459: LD_EXP 13
11463: NOT
11464: OR
11465: IFFALSE 11645
// begin if IsOk ( Roth ) then
11467: LD_EXP 18
11471: PPUSH
11472: CALL_OW 302
11476: IFFALSE 11492
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
11478: LD_EXP 18
11482: PPUSH
11483: LD_STRING DAlieBaseNotReady-Roth-1
11485: PPUSH
11486: CALL_OW 88
11490: GO 11645
// if IsOk ( Gossudarov ) then
11492: LD_EXP 35
11496: PPUSH
11497: CALL_OW 302
11501: IFFALSE 11517
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
11503: LD_EXP 35
11507: PPUSH
11508: LD_STRING DAlieBaseNotReady-Gos-1
11510: PPUSH
11511: CALL_OW 88
11515: GO 11645
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11517: LD_ADDR_VAR 0 1
11521: PUSH
11522: LD_INT 22
11524: PUSH
11525: LD_INT 7
11527: PUSH
11528: EMPTY
11529: LIST
11530: LIST
11531: PUSH
11532: LD_INT 23
11534: PUSH
11535: LD_INT 3
11537: PUSH
11538: EMPTY
11539: LIST
11540: LIST
11541: PUSH
11542: LD_INT 25
11544: PUSH
11545: LD_INT 4
11547: PUSH
11548: EMPTY
11549: LIST
11550: LIST
11551: PUSH
11552: LD_INT 21
11554: PUSH
11555: LD_INT 1
11557: PUSH
11558: EMPTY
11559: LIST
11560: LIST
11561: PUSH
11562: LD_INT 26
11564: PUSH
11565: LD_INT 1
11567: PUSH
11568: EMPTY
11569: LIST
11570: LIST
11571: PUSH
11572: EMPTY
11573: LIST
11574: LIST
11575: LIST
11576: LIST
11577: LIST
11578: PPUSH
11579: CALL_OW 69
11583: PUSH
11584: LD_EXP 18
11588: PUSH
11589: LD_EXP 17
11593: PUSH
11594: LD_EXP 49
11598: PUSH
11599: LD_EXP 37
11603: PUSH
11604: LD_EXP 47
11608: PUSH
11609: LD_EXP 46
11613: PUSH
11614: EMPTY
11615: LIST
11616: LIST
11617: LIST
11618: LIST
11619: LIST
11620: LIST
11621: DIFF
11622: ST_TO_ADDR
// if speaker then
11623: LD_VAR 0 1
11627: IFFALSE 11645
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
11629: LD_VAR 0 1
11633: PUSH
11634: LD_INT 1
11636: ARRAY
11637: PPUSH
11638: LD_STRING DAlieBaseNotReady-RSci1-1
11640: PPUSH
11641: CALL_OW 88
// end ; end ; end ;
11645: PPOPN 1
11647: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
11648: LD_INT 24
11650: PPUSH
11651: LD_INT 7
11653: PPUSH
11654: CALL_OW 321
11658: PUSH
11659: LD_INT 2
11661: EQUAL
11662: IFFALSE 12353
11664: GO 11666
11666: DISABLE
11667: LD_INT 0
11669: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11670: LD_ADDR_VAR 0 1
11674: PUSH
11675: LD_INT 22
11677: PUSH
11678: LD_INT 7
11680: PUSH
11681: EMPTY
11682: LIST
11683: LIST
11684: PUSH
11685: LD_INT 23
11687: PUSH
11688: LD_INT 3
11690: PUSH
11691: EMPTY
11692: LIST
11693: LIST
11694: PUSH
11695: LD_INT 25
11697: PUSH
11698: LD_INT 4
11700: PUSH
11701: EMPTY
11702: LIST
11703: LIST
11704: PUSH
11705: LD_INT 21
11707: PUSH
11708: LD_INT 1
11710: PUSH
11711: EMPTY
11712: LIST
11713: LIST
11714: PUSH
11715: LD_INT 26
11717: PUSH
11718: LD_INT 1
11720: PUSH
11721: EMPTY
11722: LIST
11723: LIST
11724: PUSH
11725: EMPTY
11726: LIST
11727: LIST
11728: LIST
11729: LIST
11730: LIST
11731: PPUSH
11732: CALL_OW 69
11736: PUSH
11737: LD_EXP 18
11741: PUSH
11742: LD_EXP 17
11746: PUSH
11747: LD_EXP 49
11751: PUSH
11752: LD_EXP 37
11756: PUSH
11757: LD_EXP 47
11761: PUSH
11762: LD_EXP 46
11766: PUSH
11767: EMPTY
11768: LIST
11769: LIST
11770: LIST
11771: LIST
11772: LIST
11773: LIST
11774: DIFF
11775: ST_TO_ADDR
// if not speaker then
11776: LD_VAR 0 1
11780: NOT
11781: IFFALSE 11785
// exit ;
11783: GO 12353
// DialogueOn ;
11785: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
11789: LD_VAR 0 1
11793: PUSH
11794: LD_INT 1
11796: ARRAY
11797: PPUSH
11798: LD_STRING DArtefTechnology-RSci1-1
11800: PPUSH
11801: CALL_OW 88
// if IsOk ( Burlak ) then
11805: LD_EXP 49
11809: PPUSH
11810: CALL_OW 302
11814: IFFALSE 11828
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
11816: LD_EXP 49
11820: PPUSH
11821: LD_STRING DArtefTechnology-Bur-1
11823: PPUSH
11824: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
11828: LD_VAR 0 1
11832: PUSH
11833: LD_INT 1
11835: ARRAY
11836: PPUSH
11837: LD_STRING DArtefTechnology-RSci1-2
11839: PPUSH
11840: CALL_OW 88
// if Denis then
11844: LD_EXP 23
11848: IFFALSE 11865
// speaker := [ Denis ] else
11850: LD_ADDR_VAR 0 1
11854: PUSH
11855: LD_EXP 23
11859: PUSH
11860: EMPTY
11861: LIST
11862: ST_TO_ADDR
11863: GO 11971
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11865: LD_ADDR_VAR 0 1
11869: PUSH
11870: LD_INT 22
11872: PUSH
11873: LD_INT 7
11875: PUSH
11876: EMPTY
11877: LIST
11878: LIST
11879: PUSH
11880: LD_INT 23
11882: PUSH
11883: LD_INT 1
11885: PUSH
11886: EMPTY
11887: LIST
11888: LIST
11889: PUSH
11890: LD_INT 25
11892: PUSH
11893: LD_INT 4
11895: PUSH
11896: EMPTY
11897: LIST
11898: LIST
11899: PUSH
11900: LD_INT 21
11902: PUSH
11903: LD_INT 1
11905: PUSH
11906: EMPTY
11907: LIST
11908: LIST
11909: PUSH
11910: LD_INT 26
11912: PUSH
11913: LD_INT 1
11915: PUSH
11916: EMPTY
11917: LIST
11918: LIST
11919: PUSH
11920: EMPTY
11921: LIST
11922: LIST
11923: LIST
11924: LIST
11925: LIST
11926: PPUSH
11927: CALL_OW 69
11931: PUSH
11932: LD_EXP 18
11936: PUSH
11937: LD_EXP 17
11941: PUSH
11942: LD_EXP 49
11946: PUSH
11947: LD_EXP 37
11951: PUSH
11952: LD_EXP 47
11956: PUSH
11957: LD_EXP 46
11961: PUSH
11962: EMPTY
11963: LIST
11964: LIST
11965: LIST
11966: LIST
11967: LIST
11968: LIST
11969: DIFF
11970: ST_TO_ADDR
// if speaker then
11971: LD_VAR 0 1
11975: IFFALSE 11993
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
11977: LD_VAR 0 1
11981: PUSH
11982: LD_INT 1
11984: ARRAY
11985: PPUSH
11986: LD_STRING DArtefTechnology-Sci1-2
11988: PPUSH
11989: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11993: LD_ADDR_VAR 0 1
11997: PUSH
11998: LD_INT 22
12000: PUSH
12001: LD_INT 7
12003: PUSH
12004: EMPTY
12005: LIST
12006: LIST
12007: PUSH
12008: LD_INT 23
12010: PUSH
12011: LD_INT 3
12013: PUSH
12014: EMPTY
12015: LIST
12016: LIST
12017: PUSH
12018: LD_INT 25
12020: PUSH
12021: LD_INT 4
12023: PUSH
12024: EMPTY
12025: LIST
12026: LIST
12027: PUSH
12028: LD_INT 21
12030: PUSH
12031: LD_INT 1
12033: PUSH
12034: EMPTY
12035: LIST
12036: LIST
12037: PUSH
12038: LD_INT 26
12040: PUSH
12041: LD_INT 1
12043: PUSH
12044: EMPTY
12045: LIST
12046: LIST
12047: PUSH
12048: EMPTY
12049: LIST
12050: LIST
12051: LIST
12052: LIST
12053: LIST
12054: PPUSH
12055: CALL_OW 69
12059: PUSH
12060: LD_EXP 18
12064: PUSH
12065: LD_EXP 17
12069: PUSH
12070: LD_EXP 49
12074: PUSH
12075: LD_EXP 37
12079: PUSH
12080: LD_EXP 47
12084: PUSH
12085: LD_EXP 46
12089: PUSH
12090: EMPTY
12091: LIST
12092: LIST
12093: LIST
12094: LIST
12095: LIST
12096: LIST
12097: DIFF
12098: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
12099: LD_VAR 0 1
12103: PUSH
12104: LD_EXP 9
12108: PUSH
12109: LD_EXP 5
12113: OR
12114: AND
12115: IFFALSE 12349
// begin if arabianDestroyed and IsOk ( Burlak ) then
12117: LD_EXP 5
12121: PUSH
12122: LD_EXP 49
12126: PPUSH
12127: CALL_OW 302
12131: AND
12132: IFFALSE 12148
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
12134: LD_EXP 49
12138: PPUSH
12139: LD_STRING DArtefTechnology-Bur-2
12141: PPUSH
12142: CALL_OW 88
12146: GO 12160
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
12148: LD_EXP 17
12152: PPUSH
12153: LD_STRING DArtefTechnology-JMM-2
12155: PPUSH
12156: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
12160: LD_VAR 0 1
12164: PUSH
12165: LD_INT 1
12167: ARRAY
12168: PPUSH
12169: LD_STRING DArtefTechnology-RSci1-3
12171: PPUSH
12172: CALL_OW 88
// if Denis then
12176: LD_EXP 23
12180: IFFALSE 12197
// speaker := [ Denis ] else
12182: LD_ADDR_VAR 0 1
12186: PUSH
12187: LD_EXP 23
12191: PUSH
12192: EMPTY
12193: LIST
12194: ST_TO_ADDR
12195: GO 12303
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12197: LD_ADDR_VAR 0 1
12201: PUSH
12202: LD_INT 22
12204: PUSH
12205: LD_INT 7
12207: PUSH
12208: EMPTY
12209: LIST
12210: LIST
12211: PUSH
12212: LD_INT 23
12214: PUSH
12215: LD_INT 1
12217: PUSH
12218: EMPTY
12219: LIST
12220: LIST
12221: PUSH
12222: LD_INT 25
12224: PUSH
12225: LD_INT 4
12227: PUSH
12228: EMPTY
12229: LIST
12230: LIST
12231: PUSH
12232: LD_INT 21
12234: PUSH
12235: LD_INT 1
12237: PUSH
12238: EMPTY
12239: LIST
12240: LIST
12241: PUSH
12242: LD_INT 26
12244: PUSH
12245: LD_INT 1
12247: PUSH
12248: EMPTY
12249: LIST
12250: LIST
12251: PUSH
12252: EMPTY
12253: LIST
12254: LIST
12255: LIST
12256: LIST
12257: LIST
12258: PPUSH
12259: CALL_OW 69
12263: PUSH
12264: LD_EXP 18
12268: PUSH
12269: LD_EXP 17
12273: PUSH
12274: LD_EXP 49
12278: PUSH
12279: LD_EXP 37
12283: PUSH
12284: LD_EXP 47
12288: PUSH
12289: LD_EXP 46
12293: PUSH
12294: EMPTY
12295: LIST
12296: LIST
12297: LIST
12298: LIST
12299: LIST
12300: LIST
12301: DIFF
12302: ST_TO_ADDR
// if speaker then
12303: LD_VAR 0 1
12307: IFFALSE 12349
// if alienSpotted then
12309: LD_EXP 10
12313: IFFALSE 12333
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
12315: LD_VAR 0 1
12319: PUSH
12320: LD_INT 1
12322: ARRAY
12323: PPUSH
12324: LD_STRING DArtefTechnology-Sci1-3
12326: PPUSH
12327: CALL_OW 88
12331: GO 12349
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
12333: LD_VAR 0 1
12337: PUSH
12338: LD_INT 1
12340: ARRAY
12341: PPUSH
12342: LD_STRING DArtefTechnology-Sci1-3a
12344: PPUSH
12345: CALL_OW 88
// end ; DialogueOff ;
12349: CALL_OW 7
// end ;
12353: PPOPN 1
12355: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
12356: LD_EXP 12
12360: IFFALSE 12555
12362: GO 12364
12364: DISABLE
12365: LD_INT 0
12367: PPUSH
// begin if Denis then
12368: LD_EXP 23
12372: IFFALSE 12389
// speaker := [ Denis ] else
12374: LD_ADDR_VAR 0 1
12378: PUSH
12379: LD_EXP 23
12383: PUSH
12384: EMPTY
12385: LIST
12386: ST_TO_ADDR
12387: GO 12495
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12389: LD_ADDR_VAR 0 1
12393: PUSH
12394: LD_INT 22
12396: PUSH
12397: LD_INT 7
12399: PUSH
12400: EMPTY
12401: LIST
12402: LIST
12403: PUSH
12404: LD_INT 23
12406: PUSH
12407: LD_INT 1
12409: PUSH
12410: EMPTY
12411: LIST
12412: LIST
12413: PUSH
12414: LD_INT 25
12416: PUSH
12417: LD_INT 4
12419: PUSH
12420: EMPTY
12421: LIST
12422: LIST
12423: PUSH
12424: LD_INT 21
12426: PUSH
12427: LD_INT 1
12429: PUSH
12430: EMPTY
12431: LIST
12432: LIST
12433: PUSH
12434: LD_INT 26
12436: PUSH
12437: LD_INT 1
12439: PUSH
12440: EMPTY
12441: LIST
12442: LIST
12443: PUSH
12444: EMPTY
12445: LIST
12446: LIST
12447: LIST
12448: LIST
12449: LIST
12450: PPUSH
12451: CALL_OW 69
12455: PUSH
12456: LD_EXP 18
12460: PUSH
12461: LD_EXP 17
12465: PUSH
12466: LD_EXP 49
12470: PUSH
12471: LD_EXP 37
12475: PUSH
12476: LD_EXP 47
12480: PUSH
12481: LD_EXP 46
12485: PUSH
12486: EMPTY
12487: LIST
12488: LIST
12489: LIST
12490: LIST
12491: LIST
12492: LIST
12493: DIFF
12494: ST_TO_ADDR
// if not speaker then
12495: LD_VAR 0 1
12499: NOT
12500: IFFALSE 12504
// exit ;
12502: GO 12555
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
12504: LD_VAR 0 1
12508: PUSH
12509: LD_INT 1
12511: ARRAY
12512: PPUSH
12513: LD_STRING DArtefTechnologyAm-Sci1-1
12515: PPUSH
12516: CALL_OW 88
// if IsOk ( Burlak ) then
12520: LD_EXP 49
12524: PPUSH
12525: CALL_OW 302
12529: IFFALSE 12543
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
12531: LD_EXP 49
12535: PPUSH
12536: LD_STRING DArtefTechnologyAm-Bur-1
12538: PPUSH
12539: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
12543: LD_EXP 17
12547: PPUSH
12548: LD_STRING DArtefTechnologyAm-JMM-1
12550: PPUSH
12551: CALL_OW 88
// end ;
12555: PPOPN 1
12557: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
12558: LD_EXP 13
12562: IFFALSE 12752
12564: GO 12566
12566: DISABLE
12567: LD_INT 0
12569: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12570: LD_ADDR_VAR 0 1
12574: PUSH
12575: LD_INT 22
12577: PUSH
12578: LD_INT 7
12580: PUSH
12581: EMPTY
12582: LIST
12583: LIST
12584: PUSH
12585: LD_INT 23
12587: PUSH
12588: LD_INT 3
12590: PUSH
12591: EMPTY
12592: LIST
12593: LIST
12594: PUSH
12595: LD_INT 25
12597: PUSH
12598: LD_INT 4
12600: PUSH
12601: EMPTY
12602: LIST
12603: LIST
12604: PUSH
12605: LD_INT 21
12607: PUSH
12608: LD_INT 1
12610: PUSH
12611: EMPTY
12612: LIST
12613: LIST
12614: PUSH
12615: LD_INT 26
12617: PUSH
12618: LD_INT 1
12620: PUSH
12621: EMPTY
12622: LIST
12623: LIST
12624: PUSH
12625: EMPTY
12626: LIST
12627: LIST
12628: LIST
12629: LIST
12630: LIST
12631: PPUSH
12632: CALL_OW 69
12636: PUSH
12637: LD_EXP 18
12641: PUSH
12642: LD_EXP 17
12646: PUSH
12647: LD_EXP 49
12651: PUSH
12652: LD_EXP 37
12656: PUSH
12657: LD_EXP 47
12661: PUSH
12662: LD_EXP 46
12666: PUSH
12667: EMPTY
12668: LIST
12669: LIST
12670: LIST
12671: LIST
12672: LIST
12673: LIST
12674: DIFF
12675: ST_TO_ADDR
// if not speaker then
12676: LD_VAR 0 1
12680: NOT
12681: IFFALSE 12685
// exit ;
12683: GO 12752
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-1 ) ;
12685: LD_VAR 0 1
12689: PUSH
12690: LD_INT 1
12692: ARRAY
12693: PPUSH
12694: LD_STRING DArtefTechnologyRu-RSci1-1
12696: PPUSH
12697: CALL_OW 88
// if IsOk ( Burlak ) then
12701: LD_EXP 49
12705: PPUSH
12706: CALL_OW 302
12710: IFFALSE 12724
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
12712: LD_EXP 49
12716: PPUSH
12717: LD_STRING DArtefTechnologyRu-Bur-1
12719: PPUSH
12720: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-2 ) ;
12724: LD_VAR 0 1
12728: PUSH
12729: LD_INT 1
12731: ARRAY
12732: PPUSH
12733: LD_STRING DArtefTechnologyRu-RSci1-2
12735: PPUSH
12736: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
12740: LD_EXP 17
12744: PPUSH
12745: LD_STRING DArtefTechnologyRu-JMM-1
12747: PPUSH
12748: CALL_OW 88
// end ;
12752: PPOPN 1
12754: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
12755: LD_INT 24
12757: PPUSH
12758: LD_INT 7
12760: PPUSH
12761: CALL_OW 321
12765: PUSH
12766: LD_INT 2
12768: EQUAL
12769: PUSH
12770: LD_INT 1
12772: PPUSH
12773: CALL_OW 255
12777: PUSH
12778: LD_INT 7
12780: EQUAL
12781: AND
12782: IFFALSE 12942
12784: GO 12786
12786: DISABLE
12787: LD_INT 0
12789: PPUSH
// begin if Denis then
12790: LD_EXP 23
12794: IFFALSE 12811
// speaker := [ Denis ] else
12796: LD_ADDR_VAR 0 1
12800: PUSH
12801: LD_EXP 23
12805: PUSH
12806: EMPTY
12807: LIST
12808: ST_TO_ADDR
12809: GO 12917
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12811: LD_ADDR_VAR 0 1
12815: PUSH
12816: LD_INT 22
12818: PUSH
12819: LD_INT 7
12821: PUSH
12822: EMPTY
12823: LIST
12824: LIST
12825: PUSH
12826: LD_INT 23
12828: PUSH
12829: LD_INT 1
12831: PUSH
12832: EMPTY
12833: LIST
12834: LIST
12835: PUSH
12836: LD_INT 25
12838: PUSH
12839: LD_INT 4
12841: PUSH
12842: EMPTY
12843: LIST
12844: LIST
12845: PUSH
12846: LD_INT 21
12848: PUSH
12849: LD_INT 1
12851: PUSH
12852: EMPTY
12853: LIST
12854: LIST
12855: PUSH
12856: LD_INT 26
12858: PUSH
12859: LD_INT 1
12861: PUSH
12862: EMPTY
12863: LIST
12864: LIST
12865: PUSH
12866: EMPTY
12867: LIST
12868: LIST
12869: LIST
12870: LIST
12871: LIST
12872: PPUSH
12873: CALL_OW 69
12877: PUSH
12878: LD_EXP 18
12882: PUSH
12883: LD_EXP 17
12887: PUSH
12888: LD_EXP 49
12892: PUSH
12893: LD_EXP 37
12897: PUSH
12898: LD_EXP 47
12902: PUSH
12903: LD_EXP 46
12907: PUSH
12908: EMPTY
12909: LIST
12910: LIST
12911: LIST
12912: LIST
12913: LIST
12914: LIST
12915: DIFF
12916: ST_TO_ADDR
// if not speaker then
12917: LD_VAR 0 1
12921: NOT
12922: IFFALSE 12926
// exit ;
12924: GO 12942
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
12926: LD_VAR 0 1
12930: PUSH
12931: LD_INT 1
12933: ARRAY
12934: PPUSH
12935: LD_STRING DArtefTechnologyArStart-Sci1-1
12937: PPUSH
12938: CALL_OW 88
// end ;
12942: PPOPN 1
12944: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
12945: LD_EXP 14
12949: IFFALSE 13230
12951: GO 12953
12953: DISABLE
12954: LD_INT 0
12956: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12957: LD_ADDR_VAR 0 1
12961: PUSH
12962: LD_INT 22
12964: PUSH
12965: LD_INT 7
12967: PUSH
12968: EMPTY
12969: LIST
12970: LIST
12971: PUSH
12972: LD_INT 23
12974: PUSH
12975: LD_INT 3
12977: PUSH
12978: EMPTY
12979: LIST
12980: LIST
12981: PUSH
12982: LD_INT 25
12984: PUSH
12985: LD_INT 4
12987: PUSH
12988: EMPTY
12989: LIST
12990: LIST
12991: PUSH
12992: LD_INT 21
12994: PUSH
12995: LD_INT 1
12997: PUSH
12998: EMPTY
12999: LIST
13000: LIST
13001: PUSH
13002: LD_INT 26
13004: PUSH
13005: LD_INT 1
13007: PUSH
13008: EMPTY
13009: LIST
13010: LIST
13011: PUSH
13012: EMPTY
13013: LIST
13014: LIST
13015: LIST
13016: LIST
13017: LIST
13018: PPUSH
13019: CALL_OW 69
13023: PUSH
13024: LD_EXP 18
13028: PUSH
13029: LD_EXP 17
13033: PUSH
13034: LD_EXP 49
13038: PUSH
13039: LD_EXP 37
13043: PUSH
13044: LD_EXP 47
13048: PUSH
13049: LD_EXP 46
13053: PUSH
13054: EMPTY
13055: LIST
13056: LIST
13057: LIST
13058: LIST
13059: LIST
13060: LIST
13061: DIFF
13062: ST_TO_ADDR
// if not speaker then
13063: LD_VAR 0 1
13067: NOT
13068: IFFALSE 13072
// exit ;
13070: GO 13230
// DialogueOn ;
13072: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
13076: LD_VAR 0 1
13080: PUSH
13081: LD_INT 1
13083: ARRAY
13084: PPUSH
13085: LD_STRING DArtefTechnologyAr-RSci1-1
13087: PPUSH
13088: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
13092: LD_EXP 17
13096: PPUSH
13097: LD_STRING DArtefTechnologyAr-JMM-1
13099: PPUSH
13100: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
13104: LD_VAR 0 1
13108: PUSH
13109: LD_INT 1
13111: ARRAY
13112: PPUSH
13113: LD_STRING DArtefTechnologyAr-RSci1-2
13115: PPUSH
13116: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
13120: LD_EXP 17
13124: PPUSH
13125: LD_STRING DArtefTechnologyAr-JMM-2
13127: PPUSH
13128: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
13132: LD_VAR 0 1
13136: PUSH
13137: LD_INT 1
13139: ARRAY
13140: PPUSH
13141: LD_STRING DArtefTechnologyAr-RSci1-3
13143: PPUSH
13144: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
13148: LD_EXP 17
13152: PPUSH
13153: LD_STRING DArtefTechnologyAr-JMM-3
13155: PPUSH
13156: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
13160: LD_VAR 0 1
13164: PUSH
13165: LD_INT 1
13167: ARRAY
13168: PPUSH
13169: LD_STRING DArtefTechnologyAr-RSci1-4
13171: PPUSH
13172: CALL_OW 88
// if IsOk ( Burlak ) then
13176: LD_EXP 49
13180: PPUSH
13181: CALL_OW 302
13185: IFFALSE 13199
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
13187: LD_EXP 49
13191: PPUSH
13192: LD_STRING DArtefTechnologyAr-Bur-4
13194: PPUSH
13195: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
13199: LD_EXP 17
13203: PPUSH
13204: LD_STRING DArtefTechnologyAr-JMM-4
13206: PPUSH
13207: CALL_OW 88
// DialogueOff ;
13211: CALL_OW 7
// wait ( 0 0$45 ) ;
13215: LD_INT 1575
13217: PPUSH
13218: CALL_OW 67
// spawnOmar := true ;
13222: LD_ADDR_EXP 11
13226: PUSH
13227: LD_INT 1
13229: ST_TO_ADDR
// end ;
13230: PPOPN 1
13232: END
// every 0 0$1 trigger spawnOmar do
13233: LD_EXP 11
13237: IFFALSE 13617
13239: GO 13241
13241: DISABLE
// begin PrepareOmarAli ;
13242: CALL 6751 0 0
// if not HasTask ( Omar ) then
13246: LD_EXP 53
13250: PPUSH
13251: CALL_OW 314
13255: NOT
13256: IFFALSE 13273
// ComMoveXY ( Omar , 252 , 220 ) ;
13258: LD_EXP 53
13262: PPUSH
13263: LD_INT 252
13265: PPUSH
13266: LD_INT 220
13268: PPUSH
13269: CALL_OW 111
// if not Omar then
13273: LD_EXP 53
13277: NOT
13278: IFFALSE 13282
// exit ;
13280: GO 13617
// repeat wait ( 0 0$1 ) ;
13282: LD_INT 35
13284: PPUSH
13285: CALL_OW 67
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
13289: LD_EXP 53
13293: PPUSH
13294: CALL_OW 314
13298: NOT
13299: PUSH
13300: LD_EXP 53
13304: PPUSH
13305: LD_INT 252
13307: PPUSH
13308: LD_INT 220
13310: PPUSH
13311: CALL_OW 297
13315: PUSH
13316: LD_INT 6
13318: GREATER
13319: AND
13320: IFFALSE 13337
// ComMoveXY ( Omar , 252 , 220 ) ;
13322: LD_EXP 53
13326: PPUSH
13327: LD_INT 252
13329: PPUSH
13330: LD_INT 220
13332: PPUSH
13333: CALL_OW 111
// until See ( 7 , Omar ) ;
13337: LD_INT 7
13339: PPUSH
13340: LD_EXP 53
13344: PPUSH
13345: CALL_OW 292
13349: IFFALSE 13282
// CenterNowOnUnits ( Omar ) ;
13351: LD_EXP 53
13355: PPUSH
13356: CALL_OW 87
// DialogueOn ;
13360: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
13364: LD_EXP 53
13368: PPUSH
13369: LD_STRING DOmar-Omar-1
13371: PPUSH
13372: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
13376: LD_EXP 17
13380: PPUSH
13381: LD_STRING DOmar-JMM-1
13383: PPUSH
13384: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
13388: LD_EXP 53
13392: PPUSH
13393: LD_STRING DOmar-Omar-2
13395: PPUSH
13396: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
13400: LD_EXP 17
13404: PPUSH
13405: LD_STRING DOmar-JMM-2
13407: PPUSH
13408: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
13412: LD_EXP 53
13416: PPUSH
13417: LD_STRING DOmar-Omar-3
13419: PPUSH
13420: CALL_OW 88
// if IsOk ( Burlak ) then
13424: LD_EXP 49
13428: PPUSH
13429: CALL_OW 302
13433: IFFALSE 13449
// Say ( Burlak , DOmar-Bur-3 ) else
13435: LD_EXP 49
13439: PPUSH
13440: LD_STRING DOmar-Bur-3
13442: PPUSH
13443: CALL_OW 88
13447: GO 13461
// Say ( JMM , DOmar-JMM-3 ) ;
13449: LD_EXP 17
13453: PPUSH
13454: LD_STRING DOmar-JMM-3
13456: PPUSH
13457: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
13461: LD_EXP 53
13465: PPUSH
13466: LD_STRING DOmar-Omar-4
13468: PPUSH
13469: CALL_OW 88
// case Query ( QAccept ) of 1 :
13473: LD_STRING QAccept
13475: PPUSH
13476: CALL_OW 97
13480: PUSH
13481: LD_INT 1
13483: DOUBLE
13484: EQUAL
13485: IFTRUE 13489
13487: GO 13525
13489: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
13490: LD_EXP 17
13494: PPUSH
13495: LD_STRING DQrAccept#1-JMM-1
13497: PPUSH
13498: CALL_OW 88
// SetSide ( Omar , 7 ) ;
13502: LD_EXP 53
13506: PPUSH
13507: LD_INT 7
13509: PPUSH
13510: CALL_OW 235
// ComStop ( Omar ) ;
13514: LD_EXP 53
13518: PPUSH
13519: CALL_OW 141
// end ; 2 :
13523: GO 13574
13525: LD_INT 2
13527: DOUBLE
13528: EQUAL
13529: IFTRUE 13533
13531: GO 13573
13533: POP
// begin if IsOk ( Burlak ) then
13534: LD_EXP 49
13538: PPUSH
13539: CALL_OW 302
13543: IFFALSE 13559
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
13545: LD_EXP 49
13549: PPUSH
13550: LD_STRING DQrAccept#2-Bur-1
13552: PPUSH
13553: CALL_OW 88
13557: GO 13571
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
13559: LD_EXP 17
13563: PPUSH
13564: LD_STRING DQrAccept#2-JMM-1
13566: PPUSH
13567: CALL_OW 88
// end ; end ;
13571: GO 13574
13573: POP
// DialogueOff ;
13574: CALL_OW 7
// if GetSide ( Omar ) = 7 then
13578: LD_EXP 53
13582: PPUSH
13583: CALL_OW 255
13587: PUSH
13588: LD_INT 7
13590: EQUAL
13591: IFFALSE 13602
// begin SetAchievement ( ACH_OMAR ) ;
13593: LD_STRING ACH_OMAR
13595: PPUSH
13596: CALL_OW 543
// exit ;
13600: GO 13617
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
13602: LD_EXP 53
13606: PPUSH
13607: LD_INT 202
13609: PPUSH
13610: LD_INT 115
13612: PPUSH
13613: CALL_OW 111
// end ;
13617: END
// every 0 0$1 trigger GetDistUnitXY ( Omar , 200 , 98 ) < 40 and russianDestroyed do
13618: LD_EXP 53
13622: PPUSH
13623: LD_INT 200
13625: PPUSH
13626: LD_INT 98
13628: PPUSH
13629: CALL_OW 297
13633: PUSH
13634: LD_INT 40
13636: LESS
13637: PUSH
13638: LD_EXP 2
13642: AND
13643: IFFALSE 13861
13645: GO 13647
13647: DISABLE
// begin SetSide ( Omar , 5 ) ;
13648: LD_EXP 53
13652: PPUSH
13653: LD_INT 5
13655: PPUSH
13656: CALL_OW 235
// if IsInUnit ( Omar ) then
13660: LD_EXP 53
13664: PPUSH
13665: CALL_OW 310
13669: IFFALSE 13680
// ComExitVehicle ( Omar ) ;
13671: LD_EXP 53
13675: PPUSH
13676: CALL_OW 121
// if IsInUnit ( Omar ) then
13680: LD_EXP 53
13684: PPUSH
13685: CALL_OW 310
13689: IFFALSE 13700
// ComExitBuilding ( Omar ) ;
13691: LD_EXP 53
13695: PPUSH
13696: CALL_OW 122
// wait ( 0 0$1 ) ;
13700: LD_INT 35
13702: PPUSH
13703: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
13707: LD_EXP 53
13711: PPUSH
13712: LD_INT 203
13714: PPUSH
13715: LD_INT 120
13717: PPUSH
13718: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
13722: LD_INT 35
13724: PPUSH
13725: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 6 ;
13729: LD_EXP 53
13733: PPUSH
13734: CALL_OW 306
13738: PUSH
13739: LD_EXP 53
13743: PPUSH
13744: LD_INT 203
13746: PPUSH
13747: LD_INT 120
13749: PPUSH
13750: CALL_OW 297
13754: PUSH
13755: LD_INT 6
13757: LESS
13758: OR
13759: IFFALSE 13722
// CenterNowOnUnits ( Omar ) ;
13761: LD_EXP 53
13765: PPUSH
13766: CALL_OW 87
// DialogueOn ;
13770: CALL_OW 6
// Say ( JMM , DOmarContam-JMM-1 ) ;
13774: LD_EXP 17
13778: PPUSH
13779: LD_STRING DOmarContam-JMM-1
13781: PPUSH
13782: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
13786: LD_EXP 53
13790: PPUSH
13791: LD_STRING DOmarContam-Omar-1
13793: PPUSH
13794: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
13798: LD_EXP 17
13802: PPUSH
13803: LD_STRING DOmarContam-JMM-2
13805: PPUSH
13806: CALL_OW 88
// DialogueOff ;
13810: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
13814: LD_INT 5
13816: PPUSH
13817: LD_INT 7
13819: PPUSH
13820: LD_INT 2
13822: PPUSH
13823: LD_INT 1
13825: PPUSH
13826: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
13830: LD_INT 105
13832: PPUSH
13833: CALL_OW 67
// until IsAt ( Omar , 203 , 120 ) ;
13837: LD_EXP 53
13841: PPUSH
13842: LD_INT 203
13844: PPUSH
13845: LD_INT 120
13847: PPUSH
13848: CALL_OW 307
13852: IFFALSE 13830
// YouLost ( MothContaminate ) ;
13854: LD_STRING MothContaminate
13856: PPUSH
13857: CALL_OW 104
// end ;
13861: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
13862: LD_EXP 4
13866: NOT
13867: PUSH
13868: LD_INT 22
13870: PUSH
13871: LD_INT 1
13873: PUSH
13874: EMPTY
13875: LIST
13876: LIST
13877: PUSH
13878: LD_INT 34
13880: PUSH
13881: LD_INT 8
13883: PUSH
13884: EMPTY
13885: LIST
13886: LIST
13887: PUSH
13888: EMPTY
13889: LIST
13890: LIST
13891: PPUSH
13892: CALL_OW 69
13896: AND
13897: IFFALSE 14016
13899: GO 13901
13901: DISABLE
// begin wait ( 0 0$5 ) ;
13902: LD_INT 175
13904: PPUSH
13905: CALL_OW 67
// if not IsOk ( Powell ) or not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
13909: LD_EXP 52
13913: PPUSH
13914: CALL_OW 302
13918: NOT
13919: PUSH
13920: LD_INT 22
13922: PUSH
13923: LD_INT 1
13925: PUSH
13926: EMPTY
13927: LIST
13928: LIST
13929: PUSH
13930: LD_INT 34
13932: PUSH
13933: LD_INT 8
13935: PUSH
13936: EMPTY
13937: LIST
13938: LIST
13939: PUSH
13940: EMPTY
13941: LIST
13942: LIST
13943: PPUSH
13944: CALL_OW 69
13948: NOT
13949: OR
13950: IFFALSE 13954
// exit ;
13952: GO 14016
// DialogueOn ;
13954: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
13958: LD_EXP 52
13962: PPUSH
13963: LD_STRING DWinAmericans-Pow-1
13965: PPUSH
13966: CALL_OW 94
// if IsOk ( Burlak ) then
13970: LD_EXP 49
13974: PPUSH
13975: CALL_OW 302
13979: IFFALSE 13993
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
13981: LD_EXP 49
13985: PPUSH
13986: LD_STRING DWinAmericans-Bur-1
13988: PPUSH
13989: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
13993: LD_EXP 17
13997: PPUSH
13998: LD_STRING DWinAmericans-JMM-1
14000: PPUSH
14001: CALL_OW 88
// DialogueOff ;
14005: CALL_OW 7
// YouLost ( AmBomb ) ;
14009: LD_STRING AmBomb
14011: PPUSH
14012: CALL_OW 104
// end ;
14016: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
14017: LD_EXP 2
14021: NOT
14022: PUSH
14023: LD_INT 22
14025: PUSH
14026: LD_INT 3
14028: PUSH
14029: EMPTY
14030: LIST
14031: LIST
14032: PUSH
14033: LD_INT 34
14035: PUSH
14036: LD_INT 48
14038: PUSH
14039: EMPTY
14040: LIST
14041: LIST
14042: PUSH
14043: EMPTY
14044: LIST
14045: LIST
14046: PPUSH
14047: CALL_OW 69
14051: AND
14052: IFFALSE 14171
14054: GO 14056
14056: DISABLE
// begin wait ( 0 0$5 ) ;
14057: LD_INT 175
14059: PPUSH
14060: CALL_OW 67
// if not IsOk ( Platonov ) or not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
14064: LD_EXP 56
14068: PPUSH
14069: CALL_OW 302
14073: NOT
14074: PUSH
14075: LD_INT 22
14077: PUSH
14078: LD_INT 3
14080: PUSH
14081: EMPTY
14082: LIST
14083: LIST
14084: PUSH
14085: LD_INT 34
14087: PUSH
14088: LD_INT 48
14090: PUSH
14091: EMPTY
14092: LIST
14093: LIST
14094: PUSH
14095: EMPTY
14096: LIST
14097: LIST
14098: PPUSH
14099: CALL_OW 69
14103: NOT
14104: OR
14105: IFFALSE 14109
// exit ;
14107: GO 14171
// DialogueOn ;
14109: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
14113: LD_EXP 56
14117: PPUSH
14118: LD_STRING DWinRussians-Pla-1
14120: PPUSH
14121: CALL_OW 94
// if IsOk ( Burlak ) then
14125: LD_EXP 49
14129: PPUSH
14130: CALL_OW 302
14134: IFFALSE 14148
// Say ( Burlak , DWinRussians-Bur-1 ) ;
14136: LD_EXP 49
14140: PPUSH
14141: LD_STRING DWinRussians-Bur-1
14143: PPUSH
14144: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
14148: LD_EXP 17
14152: PPUSH
14153: LD_STRING DWinRussians-JMM-1
14155: PPUSH
14156: CALL_OW 88
// DialogueOff ;
14160: CALL_OW 7
// YouLost ( RuBomb ) ;
14164: LD_STRING RuBomb
14166: PPUSH
14167: CALL_OW 104
// end ;
14171: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
14172: LD_INT 7
14174: PPUSH
14175: LD_INT 22
14177: PUSH
14178: LD_INT 7
14180: PUSH
14181: EMPTY
14182: LIST
14183: LIST
14184: PPUSH
14185: CALL_OW 70
14189: PUSH
14190: LD_EXP 4
14194: NOT
14195: AND
14196: IFFALSE 14225
14198: GO 14200
14200: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
14201: LD_EXP 52
14205: PPUSH
14206: LD_STRING DSurrenderAmericans-Pow-1
14208: PPUSH
14209: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
14213: LD_EXP 17
14217: PPUSH
14218: LD_STRING DSurrenderAmericans-JMM-1
14220: PPUSH
14221: CALL_OW 88
// end ;
14225: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
14226: LD_INT 2
14228: PPUSH
14229: LD_INT 22
14231: PUSH
14232: LD_INT 7
14234: PUSH
14235: EMPTY
14236: LIST
14237: LIST
14238: PPUSH
14239: CALL_OW 70
14243: PUSH
14244: LD_EXP 2
14248: NOT
14249: AND
14250: PUSH
14251: LD_EXP 49
14255: AND
14256: IFFALSE 14285
14258: GO 14260
14260: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
14261: LD_EXP 56
14265: PPUSH
14266: LD_STRING DSurrenderRussians-Pla-1
14268: PPUSH
14269: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
14273: LD_EXP 49
14277: PPUSH
14278: LD_STRING DSurrenderRussians-Bur-1
14280: PPUSH
14281: CALL_OW 88
// end ;
14285: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
14286: LD_EXP 4
14290: IFFALSE 14673
14292: GO 14294
14294: DISABLE
14295: LD_INT 0
14297: PPUSH
14298: PPUSH
14299: PPUSH
// begin MC_Kill ( 4 ) ;
14300: LD_INT 4
14302: PPUSH
14303: CALL 21044 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
14307: LD_INT 1
14309: PPUSH
14310: LD_INT 7
14312: PPUSH
14313: LD_INT 1
14315: PPUSH
14316: LD_INT 1
14318: PPUSH
14319: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
14323: LD_ADDR_VAR 0 3
14327: PUSH
14328: LD_INT 22
14330: PUSH
14331: LD_INT 1
14333: PUSH
14334: EMPTY
14335: LIST
14336: LIST
14337: PUSH
14338: LD_INT 26
14340: PUSH
14341: LD_INT 1
14343: PUSH
14344: EMPTY
14345: LIST
14346: LIST
14347: PUSH
14348: LD_INT 23
14350: PUSH
14351: LD_INT 1
14353: PUSH
14354: EMPTY
14355: LIST
14356: LIST
14357: PUSH
14358: EMPTY
14359: LIST
14360: LIST
14361: LIST
14362: PPUSH
14363: CALL_OW 69
14367: PUSH
14368: LD_EXP 52
14372: PUSH
14373: LD_EXP 25
14377: PUSH
14378: LD_EXP 22
14382: PUSH
14383: LD_EXP 21
14387: PUSH
14388: LD_EXP 28
14392: PUSH
14393: LD_EXP 26
14397: PUSH
14398: EMPTY
14399: LIST
14400: LIST
14401: LIST
14402: LIST
14403: LIST
14404: LIST
14405: DIFF
14406: ST_TO_ADDR
// if speaker then
14407: LD_VAR 0 3
14411: IFFALSE 14437
// begin DialogueOn ;
14413: CALL_OW 6
// SayRadio ( speaker [ 1 ] , DSurrenderAmericans-Sol1-1a ) ;
14417: LD_VAR 0 3
14421: PUSH
14422: LD_INT 1
14424: ARRAY
14425: PPUSH
14426: LD_STRING DSurrenderAmericans-Sol1-1a
14428: PPUSH
14429: CALL_OW 94
// DialogueOff ;
14433: CALL_OW 7
// end ; americanCapitulated := true ;
14437: LD_ADDR_EXP 6
14441: PUSH
14442: LD_INT 1
14444: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14445: LD_ADDR_VAR 0 2
14449: PUSH
14450: LD_INT 22
14452: PUSH
14453: LD_INT 1
14455: PUSH
14456: EMPTY
14457: LIST
14458: LIST
14459: PUSH
14460: LD_INT 21
14462: PUSH
14463: LD_INT 1
14465: PUSH
14466: EMPTY
14467: LIST
14468: LIST
14469: PUSH
14470: EMPTY
14471: LIST
14472: LIST
14473: PPUSH
14474: CALL_OW 69
14478: PUSH
14479: LD_INT 22
14481: PUSH
14482: LD_INT 1
14484: PUSH
14485: EMPTY
14486: LIST
14487: LIST
14488: PUSH
14489: LD_INT 21
14491: PUSH
14492: LD_INT 2
14494: PUSH
14495: EMPTY
14496: LIST
14497: LIST
14498: PUSH
14499: LD_INT 1
14501: PUSH
14502: EMPTY
14503: LIST
14504: PUSH
14505: EMPTY
14506: LIST
14507: LIST
14508: LIST
14509: PPUSH
14510: CALL_OW 69
14514: ADD
14515: ST_TO_ADDR
// if tmp then
14516: LD_VAR 0 2
14520: IFFALSE 14673
// repeat wait ( 0 0$1 ) ;
14522: LD_INT 35
14524: PPUSH
14525: CALL_OW 67
// for i in tmp do
14529: LD_ADDR_VAR 0 1
14533: PUSH
14534: LD_VAR 0 2
14538: PUSH
14539: FOR_IN
14540: IFFALSE 14622
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14542: LD_VAR 0 1
14546: PPUSH
14547: CALL_OW 310
14551: PUSH
14552: LD_VAR 0 1
14556: PPUSH
14557: CALL_OW 310
14561: PPUSH
14562: CALL_OW 247
14566: PUSH
14567: LD_INT 3
14569: EQUAL
14570: AND
14571: IFFALSE 14582
// ComExitBuilding ( i ) ;
14573: LD_VAR 0 1
14577: PPUSH
14578: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
14582: LD_VAR 0 1
14586: PPUSH
14587: LD_INT 122
14589: PPUSH
14590: LD_INT 242
14592: PPUSH
14593: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
14597: LD_VAR 0 1
14601: PPUSH
14602: LD_INT 35
14604: PPUSH
14605: CALL_OW 308
14609: IFFALSE 14620
// RemoveUnit ( i ) ;
14611: LD_VAR 0 1
14615: PPUSH
14616: CALL_OW 64
// end ;
14620: GO 14539
14622: POP
14623: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14624: LD_INT 22
14626: PUSH
14627: LD_INT 1
14629: PUSH
14630: EMPTY
14631: LIST
14632: LIST
14633: PUSH
14634: LD_INT 2
14636: PUSH
14637: LD_INT 21
14639: PUSH
14640: LD_INT 1
14642: PUSH
14643: EMPTY
14644: LIST
14645: LIST
14646: PUSH
14647: LD_INT 33
14649: PUSH
14650: LD_INT 1
14652: PUSH
14653: EMPTY
14654: LIST
14655: LIST
14656: PUSH
14657: EMPTY
14658: LIST
14659: LIST
14660: LIST
14661: PUSH
14662: EMPTY
14663: LIST
14664: LIST
14665: PPUSH
14666: CALL_OW 69
14670: NOT
14671: IFFALSE 14522
// end ;
14673: PPOPN 3
14675: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
14676: LD_EXP 2
14680: IFFALSE 15081
14682: GO 14684
14684: DISABLE
14685: LD_INT 0
14687: PPUSH
14688: PPUSH
14689: PPUSH
// begin repeat wait ( 0 0$1 ) ;
14690: LD_INT 35
14692: PPUSH
14693: CALL_OW 67
// until IsDead ( Yakotich ) ;
14697: LD_EXP 57
14701: PPUSH
14702: CALL_OW 301
14706: IFFALSE 14690
// MC_Kill ( 2 ) ;
14708: LD_INT 2
14710: PPUSH
14711: CALL 21044 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
14715: LD_INT 3
14717: PPUSH
14718: LD_INT 7
14720: PPUSH
14721: LD_INT 1
14723: PPUSH
14724: LD_INT 1
14726: PPUSH
14727: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff [ Platonov , Yakotich ] ;
14731: LD_ADDR_VAR 0 3
14735: PUSH
14736: LD_INT 22
14738: PUSH
14739: LD_INT 3
14741: PUSH
14742: EMPTY
14743: LIST
14744: LIST
14745: PUSH
14746: LD_INT 26
14748: PUSH
14749: LD_INT 1
14751: PUSH
14752: EMPTY
14753: LIST
14754: LIST
14755: PUSH
14756: LD_INT 23
14758: PUSH
14759: LD_INT 3
14761: PUSH
14762: EMPTY
14763: LIST
14764: LIST
14765: PUSH
14766: EMPTY
14767: LIST
14768: LIST
14769: LIST
14770: PPUSH
14771: CALL_OW 69
14775: PUSH
14776: LD_EXP 56
14780: PUSH
14781: LD_EXP 57
14785: PUSH
14786: EMPTY
14787: LIST
14788: LIST
14789: DIFF
14790: ST_TO_ADDR
// if speaker then
14791: LD_VAR 0 3
14795: IFFALSE 14845
// begin DialogueOn ;
14797: CALL_OW 6
// if Burlak then
14801: LD_EXP 49
14805: IFFALSE 14825
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1 ) else
14807: LD_VAR 0 3
14811: PUSH
14812: LD_INT 1
14814: ARRAY
14815: PPUSH
14816: LD_STRING DSurrenderRussians-RSol1-1
14818: PPUSH
14819: CALL_OW 94
14823: GO 14841
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1a ) ;
14825: LD_VAR 0 3
14829: PUSH
14830: LD_INT 1
14832: ARRAY
14833: PPUSH
14834: LD_STRING DSurrenderRussians-RSol1-1a
14836: PPUSH
14837: CALL_OW 94
// DialogueOff ;
14841: CALL_OW 7
// end ; russianCapitulated := true ;
14845: LD_ADDR_EXP 7
14849: PUSH
14850: LD_INT 1
14852: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14853: LD_ADDR_VAR 0 2
14857: PUSH
14858: LD_INT 22
14860: PUSH
14861: LD_INT 3
14863: PUSH
14864: EMPTY
14865: LIST
14866: LIST
14867: PUSH
14868: LD_INT 21
14870: PUSH
14871: LD_INT 1
14873: PUSH
14874: EMPTY
14875: LIST
14876: LIST
14877: PUSH
14878: EMPTY
14879: LIST
14880: LIST
14881: PPUSH
14882: CALL_OW 69
14886: PUSH
14887: LD_INT 22
14889: PUSH
14890: LD_INT 3
14892: PUSH
14893: EMPTY
14894: LIST
14895: LIST
14896: PUSH
14897: LD_INT 21
14899: PUSH
14900: LD_INT 2
14902: PUSH
14903: EMPTY
14904: LIST
14905: LIST
14906: PUSH
14907: LD_INT 1
14909: PUSH
14910: EMPTY
14911: LIST
14912: PUSH
14913: EMPTY
14914: LIST
14915: LIST
14916: LIST
14917: PPUSH
14918: CALL_OW 69
14922: ADD
14923: ST_TO_ADDR
// if tmp then
14924: LD_VAR 0 2
14928: IFFALSE 15081
// repeat wait ( 0 0$1 ) ;
14930: LD_INT 35
14932: PPUSH
14933: CALL_OW 67
// for i in tmp do
14937: LD_ADDR_VAR 0 1
14941: PUSH
14942: LD_VAR 0 2
14946: PUSH
14947: FOR_IN
14948: IFFALSE 15030
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14950: LD_VAR 0 1
14954: PPUSH
14955: CALL_OW 310
14959: PUSH
14960: LD_VAR 0 1
14964: PPUSH
14965: CALL_OW 310
14969: PPUSH
14970: CALL_OW 247
14974: PUSH
14975: LD_INT 3
14977: EQUAL
14978: AND
14979: IFFALSE 14990
// ComExitBuilding ( i ) ;
14981: LD_VAR 0 1
14985: PPUSH
14986: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
14990: LD_VAR 0 1
14994: PPUSH
14995: LD_INT 154
14997: PPUSH
14998: LD_INT 1
15000: PPUSH
15001: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
15005: LD_VAR 0 1
15009: PPUSH
15010: LD_INT 36
15012: PPUSH
15013: CALL_OW 308
15017: IFFALSE 15028
// RemoveUnit ( i ) ;
15019: LD_VAR 0 1
15023: PPUSH
15024: CALL_OW 64
// end ;
15028: GO 14947
15030: POP
15031: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15032: LD_INT 22
15034: PUSH
15035: LD_INT 3
15037: PUSH
15038: EMPTY
15039: LIST
15040: LIST
15041: PUSH
15042: LD_INT 2
15044: PUSH
15045: LD_INT 21
15047: PUSH
15048: LD_INT 1
15050: PUSH
15051: EMPTY
15052: LIST
15053: LIST
15054: PUSH
15055: LD_INT 33
15057: PUSH
15058: LD_INT 1
15060: PUSH
15061: EMPTY
15062: LIST
15063: LIST
15064: PUSH
15065: EMPTY
15066: LIST
15067: LIST
15068: LIST
15069: PUSH
15070: EMPTY
15071: LIST
15072: LIST
15073: PPUSH
15074: CALL_OW 69
15078: NOT
15079: IFFALSE 14930
// end ;
15081: PPOPN 3
15083: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
15084: LD_INT 22
15086: PUSH
15087: LD_INT 8
15089: PUSH
15090: EMPTY
15091: LIST
15092: LIST
15093: PUSH
15094: LD_INT 21
15096: PUSH
15097: LD_INT 1
15099: PUSH
15100: EMPTY
15101: LIST
15102: LIST
15103: PUSH
15104: LD_INT 23
15106: PUSH
15107: LD_INT 2
15109: PUSH
15110: EMPTY
15111: LIST
15112: LIST
15113: PUSH
15114: EMPTY
15115: LIST
15116: LIST
15117: LIST
15118: PPUSH
15119: CALL_OW 69
15123: PUSH
15124: LD_INT 18
15126: LESS
15127: PUSH
15128: LD_EXP 55
15132: PPUSH
15133: CALL_OW 301
15137: OR
15138: PUSH
15139: LD_INT 324
15141: PPUSH
15142: CALL_OW 255
15146: PUSH
15147: LD_INT 7
15149: EQUAL
15150: OR
15151: IFFALSE 15164
15153: GO 15155
15155: DISABLE
// legionDestroyed := true ;
15156: LD_ADDR_EXP 3
15160: PUSH
15161: LD_INT 1
15163: ST_TO_ADDR
15164: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 do
15165: LD_INT 22
15167: PUSH
15168: LD_INT 2
15170: PUSH
15171: EMPTY
15172: LIST
15173: LIST
15174: PUSH
15175: LD_INT 21
15177: PUSH
15178: LD_INT 1
15180: PUSH
15181: EMPTY
15182: LIST
15183: LIST
15184: PUSH
15185: LD_INT 23
15187: PUSH
15188: LD_INT 2
15190: PUSH
15191: EMPTY
15192: LIST
15193: LIST
15194: PUSH
15195: EMPTY
15196: LIST
15197: LIST
15198: LIST
15199: PPUSH
15200: CALL_OW 69
15204: PUSH
15205: LD_INT 9
15207: LESS
15208: IFFALSE 15221
15210: GO 15212
15212: DISABLE
// arabianDestroyed := true ;
15213: LD_ADDR_EXP 5
15217: PUSH
15218: LD_INT 1
15220: ST_TO_ADDR
15221: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
15222: LD_EXP 5
15226: IFFALSE 15470
15228: GO 15230
15230: DISABLE
15231: LD_INT 0
15233: PPUSH
15234: PPUSH
// begin MC_Kill ( 1 ) ;
15235: LD_INT 1
15237: PPUSH
15238: CALL 21044 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15242: LD_ADDR_VAR 0 2
15246: PUSH
15247: LD_INT 22
15249: PUSH
15250: LD_INT 2
15252: PUSH
15253: EMPTY
15254: LIST
15255: LIST
15256: PUSH
15257: LD_INT 21
15259: PUSH
15260: LD_INT 1
15262: PUSH
15263: EMPTY
15264: LIST
15265: LIST
15266: PUSH
15267: EMPTY
15268: LIST
15269: LIST
15270: PPUSH
15271: CALL_OW 69
15275: PUSH
15276: LD_INT 22
15278: PUSH
15279: LD_INT 8
15281: PUSH
15282: EMPTY
15283: LIST
15284: LIST
15285: PUSH
15286: LD_INT 21
15288: PUSH
15289: LD_INT 2
15291: PUSH
15292: EMPTY
15293: LIST
15294: LIST
15295: PUSH
15296: LD_INT 1
15298: PUSH
15299: EMPTY
15300: LIST
15301: PUSH
15302: EMPTY
15303: LIST
15304: LIST
15305: LIST
15306: PPUSH
15307: CALL_OW 69
15311: ADD
15312: ST_TO_ADDR
// if tmp then
15313: LD_VAR 0 2
15317: IFFALSE 15470
// repeat wait ( 0 0$1 ) ;
15319: LD_INT 35
15321: PPUSH
15322: CALL_OW 67
// for i in tmp do
15326: LD_ADDR_VAR 0 1
15330: PUSH
15331: LD_VAR 0 2
15335: PUSH
15336: FOR_IN
15337: IFFALSE 15419
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15339: LD_VAR 0 1
15343: PPUSH
15344: CALL_OW 310
15348: PUSH
15349: LD_VAR 0 1
15353: PPUSH
15354: CALL_OW 310
15358: PPUSH
15359: CALL_OW 247
15363: PUSH
15364: LD_INT 3
15366: EQUAL
15367: AND
15368: IFFALSE 15379
// ComExitBuilding ( i ) ;
15370: LD_VAR 0 1
15374: PPUSH
15375: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
15379: LD_VAR 0 1
15383: PPUSH
15384: LD_INT 254
15386: PPUSH
15387: LD_INT 268
15389: PPUSH
15390: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
15394: LD_VAR 0 1
15398: PPUSH
15399: LD_INT 34
15401: PPUSH
15402: CALL_OW 308
15406: IFFALSE 15417
// RemoveUnit ( i ) ;
15408: LD_VAR 0 1
15412: PPUSH
15413: CALL_OW 64
// end ;
15417: GO 15336
15419: POP
15420: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15421: LD_INT 22
15423: PUSH
15424: LD_INT 2
15426: PUSH
15427: EMPTY
15428: LIST
15429: LIST
15430: PUSH
15431: LD_INT 2
15433: PUSH
15434: LD_INT 21
15436: PUSH
15437: LD_INT 1
15439: PUSH
15440: EMPTY
15441: LIST
15442: LIST
15443: PUSH
15444: LD_INT 33
15446: PUSH
15447: LD_INT 1
15449: PUSH
15450: EMPTY
15451: LIST
15452: LIST
15453: PUSH
15454: EMPTY
15455: LIST
15456: LIST
15457: LIST
15458: PUSH
15459: EMPTY
15460: LIST
15461: LIST
15462: PPUSH
15463: CALL_OW 69
15467: NOT
15468: IFFALSE 15319
// end ;
15470: PPOPN 2
15472: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
15473: LD_EXP 3
15477: IFFALSE 15829
15479: GO 15481
15481: DISABLE
15482: LD_INT 0
15484: PPUSH
15485: PPUSH
// begin MC_Kill ( 3 ) ;
15486: LD_INT 3
15488: PPUSH
15489: CALL 21044 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
15493: LD_INT 8
15495: PPUSH
15496: LD_INT 7
15498: PPUSH
15499: LD_INT 1
15501: PPUSH
15502: LD_INT 1
15504: PPUSH
15505: CALL_OW 80
// DialogueOn ;
15509: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
15513: LD_EXP 54
15517: PPUSH
15518: LD_STRING D15-Szulc-1
15520: PPUSH
15521: CALL_OW 94
// DialogueOff ;
15525: CALL_OW 7
// legionCapitulated := true ;
15529: LD_ADDR_EXP 8
15533: PUSH
15534: LD_INT 1
15536: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
15537: LD_ADDR_VAR 0 1
15541: PUSH
15542: LD_INT 22
15544: PUSH
15545: LD_INT 8
15547: PUSH
15548: EMPTY
15549: LIST
15550: LIST
15551: PUSH
15552: LD_INT 21
15554: PUSH
15555: LD_INT 3
15557: PUSH
15558: EMPTY
15559: LIST
15560: LIST
15561: PUSH
15562: LD_INT 23
15564: PUSH
15565: LD_INT 3
15567: PUSH
15568: EMPTY
15569: LIST
15570: LIST
15571: PUSH
15572: EMPTY
15573: LIST
15574: LIST
15575: LIST
15576: PPUSH
15577: CALL_OW 69
15581: PUSH
15582: FOR_IN
15583: IFFALSE 15599
// SetLives ( i , 3 ) ;
15585: LD_VAR 0 1
15589: PPUSH
15590: LD_INT 3
15592: PPUSH
15593: CALL_OW 234
15597: GO 15582
15599: POP
15600: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15601: LD_ADDR_VAR 0 2
15605: PUSH
15606: LD_INT 22
15608: PUSH
15609: LD_INT 8
15611: PUSH
15612: EMPTY
15613: LIST
15614: LIST
15615: PUSH
15616: LD_INT 21
15618: PUSH
15619: LD_INT 1
15621: PUSH
15622: EMPTY
15623: LIST
15624: LIST
15625: PUSH
15626: EMPTY
15627: LIST
15628: LIST
15629: PPUSH
15630: CALL_OW 69
15634: PUSH
15635: LD_INT 22
15637: PUSH
15638: LD_INT 8
15640: PUSH
15641: EMPTY
15642: LIST
15643: LIST
15644: PUSH
15645: LD_INT 21
15647: PUSH
15648: LD_INT 2
15650: PUSH
15651: EMPTY
15652: LIST
15653: LIST
15654: PUSH
15655: LD_INT 1
15657: PUSH
15658: EMPTY
15659: LIST
15660: PUSH
15661: EMPTY
15662: LIST
15663: LIST
15664: LIST
15665: PPUSH
15666: CALL_OW 69
15670: ADD
15671: ST_TO_ADDR
// if tmp then
15672: LD_VAR 0 2
15676: IFFALSE 15829
// repeat wait ( 0 0$1 ) ;
15678: LD_INT 35
15680: PPUSH
15681: CALL_OW 67
// for i in tmp do
15685: LD_ADDR_VAR 0 1
15689: PUSH
15690: LD_VAR 0 2
15694: PUSH
15695: FOR_IN
15696: IFFALSE 15778
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15698: LD_VAR 0 1
15702: PPUSH
15703: CALL_OW 310
15707: PUSH
15708: LD_VAR 0 1
15712: PPUSH
15713: CALL_OW 310
15717: PPUSH
15718: CALL_OW 247
15722: PUSH
15723: LD_INT 3
15725: EQUAL
15726: AND
15727: IFFALSE 15738
// ComExitBuilding ( i ) ;
15729: LD_VAR 0 1
15733: PPUSH
15734: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
15738: LD_VAR 0 1
15742: PPUSH
15743: LD_INT 10
15745: PPUSH
15746: LD_INT 1
15748: PPUSH
15749: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
15753: LD_VAR 0 1
15757: PPUSH
15758: LD_INT 32
15760: PPUSH
15761: CALL_OW 308
15765: IFFALSE 15776
// RemoveUnit ( i ) ;
15767: LD_VAR 0 1
15771: PPUSH
15772: CALL_OW 64
// end ;
15776: GO 15695
15778: POP
15779: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15780: LD_INT 22
15782: PUSH
15783: LD_INT 8
15785: PUSH
15786: EMPTY
15787: LIST
15788: LIST
15789: PUSH
15790: LD_INT 2
15792: PUSH
15793: LD_INT 21
15795: PUSH
15796: LD_INT 1
15798: PUSH
15799: EMPTY
15800: LIST
15801: LIST
15802: PUSH
15803: LD_INT 33
15805: PUSH
15806: LD_INT 1
15808: PUSH
15809: EMPTY
15810: LIST
15811: LIST
15812: PUSH
15813: EMPTY
15814: LIST
15815: LIST
15816: LIST
15817: PUSH
15818: EMPTY
15819: LIST
15820: LIST
15821: PPUSH
15822: CALL_OW 69
15826: NOT
15827: IFFALSE 15678
// end ;
15829: PPOPN 2
15831: END
// every 0 0$5 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated and ( GetSide ( Omar ) <> 5 or IsDead ( Omar ) or not IsPlaced ( Omar ) ) do var med1 , med2 ;
15832: LD_EXP 4
15836: PUSH
15837: LD_EXP 2
15841: AND
15842: PUSH
15843: LD_EXP 3
15847: AND
15848: PUSH
15849: LD_EXP 5
15853: AND
15854: PUSH
15855: LD_EXP 6
15859: AND
15860: PUSH
15861: LD_EXP 7
15865: AND
15866: PUSH
15867: LD_EXP 8
15871: AND
15872: PUSH
15873: LD_EXP 53
15877: PPUSH
15878: CALL_OW 255
15882: PUSH
15883: LD_INT 5
15885: NONEQUAL
15886: PUSH
15887: LD_EXP 53
15891: PPUSH
15892: CALL_OW 301
15896: OR
15897: PUSH
15898: LD_EXP 53
15902: PPUSH
15903: CALL_OW 305
15907: NOT
15908: OR
15909: AND
15910: IFFALSE 17301
15912: GO 15914
15914: DISABLE
15915: LD_INT 0
15917: PPUSH
15918: PPUSH
// begin wait ( 0 0$5 ) ;
15919: LD_INT 175
15921: PPUSH
15922: CALL_OW 67
// music_class := 5 ;
15926: LD_ADDR_OWVAR 72
15930: PUSH
15931: LD_INT 5
15933: ST_TO_ADDR
// music_nat := 5 ;
15934: LD_ADDR_OWVAR 71
15938: PUSH
15939: LD_INT 5
15941: ST_TO_ADDR
// if vehicleLostCounter < 3 then
15942: LD_EXP 15
15946: PUSH
15947: LD_INT 3
15949: LESS
15950: IFFALSE 15959
// SetAchievement ( ACH_ECONOMY ) ;
15952: LD_STRING ACH_ECONOMY
15954: PPUSH
15955: CALL_OW 543
// if tick < 60 60$00 then
15959: LD_OWVAR 1
15963: PUSH
15964: LD_INT 126000
15966: LESS
15967: IFFALSE 15983
// begin wait ( 3 ) ;
15969: LD_INT 3
15971: PPUSH
15972: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
15976: LD_STRING ACH_ASPEED_19
15978: PPUSH
15979: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
15983: LD_EXP 17
15987: PPUSH
15988: CALL_OW 87
// InGameOn ;
15992: CALL_OW 8
// DialogueOn ;
15996: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
16000: LD_EXP 17
16004: PPUSH
16005: LD_STRING DEnd-JMM-JMM-1
16007: PPUSH
16008: CALL_OW 88
// if Joan then
16012: LD_EXP 32
16016: IFFALSE 16032
// Say ( Joan , DEnd-JMM-Joan-1 ) else
16018: LD_EXP 32
16022: PPUSH
16023: LD_STRING DEnd-JMM-Joan-1
16025: PPUSH
16026: CALL_OW 88
16030: GO 16076
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
16032: LD_EXP 19
16036: PUSH
16037: LD_EXP 19
16041: PPUSH
16042: CALL_OW 255
16046: PUSH
16047: LD_INT 7
16049: EQUAL
16050: AND
16051: PUSH
16052: LD_EXP 19
16056: PPUSH
16057: CALL_OW 305
16061: AND
16062: IFFALSE 16076
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
16064: LD_EXP 19
16068: PPUSH
16069: LD_STRING DEnd-JMM-Lisa-1
16071: PPUSH
16072: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
16076: LD_EXP 29
16080: PUSH
16081: LD_EXP 29
16085: PPUSH
16086: CALL_OW 305
16090: AND
16091: IFFALSE 16105
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
16093: LD_EXP 29
16097: PPUSH
16098: LD_STRING DEnd-JMM-Frank-1
16100: PPUSH
16101: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
16105: LD_EXP 22
16109: PUSH
16110: LD_EXP 22
16114: PPUSH
16115: CALL_OW 255
16119: PUSH
16120: LD_INT 7
16122: EQUAL
16123: AND
16124: PUSH
16125: LD_EXP 22
16129: PPUSH
16130: CALL_OW 305
16134: AND
16135: IFFALSE 16149
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
16137: LD_EXP 22
16141: PPUSH
16142: LD_STRING DEnd-JMM-Cyrus-1
16144: PPUSH
16145: CALL_OW 88
// if Burlak then
16149: LD_EXP 49
16153: IFFALSE 16167
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
16155: LD_EXP 49
16159: PPUSH
16160: LD_STRING DEnd-JMM-Bur-1
16162: PPUSH
16163: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
16167: LD_EXP 32
16171: PUSH
16172: LD_EXP 19
16176: AND
16177: PUSH
16178: LD_EXP 19
16182: PPUSH
16183: CALL_OW 255
16187: PUSH
16188: LD_INT 7
16190: EQUAL
16191: AND
16192: PUSH
16193: LD_EXP 19
16197: PPUSH
16198: CALL_OW 305
16202: AND
16203: IFFALSE 16217
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
16205: LD_EXP 19
16209: PPUSH
16210: LD_STRING DEnd-Burlak-Lisa-1
16212: PPUSH
16213: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
16217: LD_EXP 50
16221: PUSH
16222: LD_EXP 50
16226: PPUSH
16227: CALL_OW 305
16231: AND
16232: IFFALSE 16246
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
16234: LD_EXP 50
16238: PPUSH
16239: LD_STRING DEnd-JMM-Bel-1
16241: PPUSH
16242: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
16246: LD_EXP 51
16250: PUSH
16251: LD_EXP 51
16255: PPUSH
16256: CALL_OW 305
16260: AND
16261: IFFALSE 16275
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
16263: LD_EXP 51
16267: PPUSH
16268: LD_STRING DEnd-JMM-Gny-1
16270: PPUSH
16271: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
16275: LD_EXP 27
16279: PUSH
16280: LD_EXP 27
16284: PPUSH
16285: CALL_OW 255
16289: PUSH
16290: LD_INT 7
16292: EQUAL
16293: AND
16294: PUSH
16295: LD_EXP 27
16299: PPUSH
16300: CALL_OW 305
16304: AND
16305: IFFALSE 16319
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
16307: LD_EXP 27
16311: PPUSH
16312: LD_STRING DEnd-JMM-Corn-1
16314: PPUSH
16315: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
16319: LD_EXP 20
16323: PUSH
16324: LD_EXP 20
16328: PPUSH
16329: CALL_OW 255
16333: PUSH
16334: LD_INT 7
16336: EQUAL
16337: AND
16338: PUSH
16339: LD_EXP 20
16343: PPUSH
16344: CALL_OW 305
16348: AND
16349: IFFALSE 16363
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
16351: LD_EXP 20
16355: PPUSH
16356: LD_STRING DEnd-JMM-Don-1
16358: PPUSH
16359: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
16363: LD_EXP 21
16367: PUSH
16368: LD_EXP 21
16372: PPUSH
16373: CALL_OW 255
16377: PUSH
16378: LD_INT 7
16380: EQUAL
16381: AND
16382: PUSH
16383: LD_EXP 21
16387: PPUSH
16388: CALL_OW 305
16392: AND
16393: IFFALSE 16407
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
16395: LD_EXP 21
16399: PPUSH
16400: LD_STRING DEnd-JMM-Bobby-1
16402: PPUSH
16403: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
16407: LD_EXP 23
16411: PUSH
16412: LD_EXP 23
16416: PPUSH
16417: CALL_OW 255
16421: PUSH
16422: LD_INT 7
16424: EQUAL
16425: AND
16426: PUSH
16427: LD_EXP 23
16431: PPUSH
16432: CALL_OW 305
16436: AND
16437: IFFALSE 16451
// Say ( Denis , DEnd-JMM-Den-1 ) ;
16439: LD_EXP 23
16443: PPUSH
16444: LD_STRING DEnd-JMM-Den-1
16446: PPUSH
16447: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
16451: LD_EXP 25
16455: PUSH
16456: LD_EXP 25
16460: PPUSH
16461: CALL_OW 255
16465: PUSH
16466: LD_INT 7
16468: EQUAL
16469: AND
16470: PUSH
16471: LD_EXP 25
16475: PPUSH
16476: CALL_OW 305
16480: AND
16481: IFFALSE 16495
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
16483: LD_EXP 25
16487: PPUSH
16488: LD_STRING DEnd-JMM-Glad-1
16490: PPUSH
16491: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
16495: LD_EXP 30
16499: PUSH
16500: LD_EXP 30
16504: PPUSH
16505: CALL_OW 255
16509: PUSH
16510: LD_INT 7
16512: EQUAL
16513: AND
16514: PUSH
16515: LD_EXP 30
16519: PPUSH
16520: CALL_OW 305
16524: AND
16525: IFFALSE 16539
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
16527: LD_EXP 30
16531: PPUSH
16532: LD_STRING DEnd-JMM-Yam-1
16534: PPUSH
16535: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
16539: LD_EXP 24
16543: PUSH
16544: LD_EXP 24
16548: PPUSH
16549: CALL_OW 255
16553: PUSH
16554: LD_INT 7
16556: EQUAL
16557: AND
16558: PUSH
16559: LD_EXP 24
16563: PPUSH
16564: CALL_OW 305
16568: AND
16569: IFFALSE 16583
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
16571: LD_EXP 24
16575: PPUSH
16576: LD_STRING DEnd-JMM-Brown-1
16578: PPUSH
16579: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
16583: LD_EXP 34
16587: PUSH
16588: LD_EXP 34
16592: PPUSH
16593: CALL_OW 255
16597: PUSH
16598: LD_INT 7
16600: EQUAL
16601: AND
16602: PUSH
16603: LD_EXP 34
16607: PPUSH
16608: CALL_OW 305
16612: AND
16613: IFFALSE 16627
// Say ( Connie , DEnd-JMM-Con-1 ) ;
16615: LD_EXP 34
16619: PPUSH
16620: LD_STRING DEnd-JMM-Con-1
16622: PPUSH
16623: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
16627: LD_EXP 28
16631: PUSH
16632: LD_EXP 28
16636: PPUSH
16637: CALL_OW 255
16641: PUSH
16642: LD_INT 7
16644: EQUAL
16645: AND
16646: PUSH
16647: LD_EXP 28
16651: PPUSH
16652: CALL_OW 305
16656: AND
16657: IFFALSE 16671
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
16659: LD_EXP 28
16663: PPUSH
16664: LD_STRING DEnd-JMM-Gary-1
16666: PPUSH
16667: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
16671: LD_EXP 31
16675: PUSH
16676: LD_EXP 18
16680: AND
16681: PUSH
16682: LD_EXP 31
16686: PPUSH
16687: CALL_OW 305
16691: AND
16692: IFFALSE 16706
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
16694: LD_EXP 31
16698: PPUSH
16699: LD_STRING DEnd-JMM-Sim-1
16701: PPUSH
16702: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
16706: LD_EXP 26
16710: PUSH
16711: LD_EXP 26
16715: PPUSH
16716: CALL_OW 255
16720: PUSH
16721: LD_INT 7
16723: EQUAL
16724: AND
16725: PUSH
16726: LD_EXP 26
16730: PPUSH
16731: CALL_OW 305
16735: AND
16736: IFFALSE 16750
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
16738: LD_EXP 26
16742: PPUSH
16743: LD_STRING DEnd-JMM-VanH-1
16745: PPUSH
16746: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
16750: LD_EXP 39
16754: PUSH
16755: LD_EXP 39
16759: PPUSH
16760: CALL_OW 305
16764: AND
16765: IFFALSE 16779
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
16767: LD_EXP 39
16771: PPUSH
16772: LD_STRING DEnd-JMM-Dol-1
16774: PPUSH
16775: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
16779: LD_EXP 43
16783: PUSH
16784: LD_EXP 43
16788: PPUSH
16789: CALL_OW 305
16793: AND
16794: IFFALSE 16808
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
16796: LD_EXP 43
16800: PPUSH
16801: LD_STRING DEnd-JMM-Kap-1
16803: PPUSH
16804: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
16808: LD_EXP 46
16812: PUSH
16813: LD_EXP 46
16817: PPUSH
16818: CALL_OW 305
16822: AND
16823: IFFALSE 16837
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
16825: LD_EXP 46
16829: PPUSH
16830: LD_STRING DEnd-JMM-Kov-1
16832: PPUSH
16833: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
16837: LD_EXP 41
16841: PUSH
16842: LD_EXP 41
16846: PPUSH
16847: CALL_OW 305
16851: AND
16852: IFFALSE 16866
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
16854: LD_EXP 41
16858: PPUSH
16859: LD_STRING DEnd-JMM-Sch-1
16861: PPUSH
16862: CALL_OW 88
// if Titov and IsPlaced ( Titov ) then
16866: LD_EXP 37
16870: PUSH
16871: LD_EXP 37
16875: PPUSH
16876: CALL_OW 305
16880: AND
16881: IFFALSE 16895
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
16883: LD_EXP 37
16887: PPUSH
16888: LD_STRING DEnd-JMM-Tit-1
16890: PPUSH
16891: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
16895: LD_EXP 42
16899: PUSH
16900: LD_EXP 42
16904: PPUSH
16905: CALL_OW 305
16909: AND
16910: IFFALSE 16924
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
16912: LD_EXP 42
16916: PPUSH
16917: LD_STRING DEnd-JMM-Obl-1
16919: PPUSH
16920: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
16924: LD_EXP 44
16928: PUSH
16929: LD_EXP 44
16933: PPUSH
16934: CALL_OW 305
16938: AND
16939: IFFALSE 16953
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
16941: LD_EXP 44
16945: PPUSH
16946: LD_STRING DEnd-JMM-Lip-1
16948: PPUSH
16949: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and Burlak then
16953: LD_EXP 38
16957: PUSH
16958: LD_EXP 38
16962: PPUSH
16963: CALL_OW 305
16967: AND
16968: PUSH
16969: LD_EXP 49
16973: AND
16974: IFFALSE 16988
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
16976: LD_EXP 38
16980: PPUSH
16981: LD_STRING DEnd-Burlak-Fad-1
16983: PPUSH
16984: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
16988: LD_EXP 45
16992: PUSH
16993: LD_EXP 45
16997: PPUSH
16998: CALL_OW 305
17002: AND
17003: IFFALSE 17017
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
17005: LD_EXP 45
17009: PPUSH
17010: LD_STRING DEnd-Burlak-Ptr-1
17012: PPUSH
17013: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
17017: LD_EXP 47
17021: PUSH
17022: LD_EXP 47
17026: PPUSH
17027: CALL_OW 305
17031: AND
17032: IFFALSE 17046
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
17034: LD_EXP 47
17038: PPUSH
17039: LD_STRING DEnd-Burlak-Kuz-1
17041: PPUSH
17042: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and Burlak then
17046: LD_EXP 36
17050: PUSH
17051: LD_EXP 36
17055: PPUSH
17056: CALL_OW 305
17060: AND
17061: PUSH
17062: LD_EXP 49
17066: AND
17067: IFFALSE 17081
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
17069: LD_EXP 36
17073: PPUSH
17074: LD_STRING DEnd-Burlak-Kir-1
17076: PPUSH
17077: CALL_OW 88
// if Burlak then
17081: LD_EXP 49
17085: IFFALSE 17099
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
17087: LD_EXP 17
17091: PPUSH
17092: LD_STRING DEnd-Burlak-JMM-1
17094: PPUSH
17095: CALL_OW 88
// dwait ( 0 0$2 ) ;
17099: LD_INT 70
17101: PPUSH
17102: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
17106: LD_EXP 54
17110: PPUSH
17111: LD_STRING DEnd-Szulc
17113: PPUSH
17114: CALL_OW 94
// dwait ( 0 0$1 ) ;
17118: LD_INT 35
17120: PPUSH
17121: CALL_OW 68
// if IsLive ( Burlak ) then
17125: LD_EXP 49
17129: PPUSH
17130: CALL_OW 300
17134: IFFALSE 17146
// med1 := 1 else
17136: LD_ADDR_VAR 0 1
17140: PUSH
17141: LD_INT 1
17143: ST_TO_ADDR
17144: GO 17155
// med1 := - 1 ;
17146: LD_ADDR_VAR 0 1
17150: PUSH
17151: LD_INT 1
17153: NEG
17154: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
17155: LD_EXP 12
17159: PUSH
17160: LD_EXP 13
17164: AND
17165: PUSH
17166: LD_EXP 14
17170: AND
17171: IFFALSE 17183
// med2 := 1 else
17173: LD_ADDR_VAR 0 2
17177: PUSH
17178: LD_INT 1
17180: ST_TO_ADDR
17181: GO 17192
// med2 := - 1 ;
17183: LD_ADDR_VAR 0 2
17187: PUSH
17188: LD_INT 1
17190: NEG
17191: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
17192: LD_STRING Hero
17194: PPUSH
17195: LD_INT 1
17197: PPUSH
17198: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
17202: LD_STRING Artefact
17204: PPUSH
17205: LD_VAR 0 2
17209: PPUSH
17210: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
17214: LD_STRING ReconcileBurlak
17216: PPUSH
17217: LD_VAR 0 1
17221: PPUSH
17222: CALL_OW 101
// if Difficulty = 3 and med1 = 1 and med2 = 1 then
17226: LD_OWVAR 67
17230: PUSH
17231: LD_INT 3
17233: EQUAL
17234: PUSH
17235: LD_VAR 0 1
17239: PUSH
17240: LD_INT 1
17242: EQUAL
17243: AND
17244: PUSH
17245: LD_VAR 0 2
17249: PUSH
17250: LD_INT 1
17252: EQUAL
17253: AND
17254: IFFALSE 17266
// SetAchievementEX ( ACH_AMER , 19 ) ;
17256: LD_STRING ACH_AMER
17258: PPUSH
17259: LD_INT 19
17261: PPUSH
17262: CALL_OW 564
// GiveMedals ( MAIN ) ;
17266: LD_STRING MAIN
17268: PPUSH
17269: CALL_OW 102
// InGameOff ;
17273: CALL_OW 9
// DialogueOff ;
17277: CALL_OW 7
// music_nat := 1 ;
17281: LD_ADDR_OWVAR 71
17285: PUSH
17286: LD_INT 1
17288: ST_TO_ADDR
// music_class := 4 ;
17289: LD_ADDR_OWVAR 72
17293: PUSH
17294: LD_INT 4
17296: ST_TO_ADDR
// YouWin ;
17297: CALL_OW 103
// end ; end_of_file
17301: PPOPN 2
17303: END
// export function InitNature ; begin
17304: LD_INT 0
17306: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
17307: LD_INT 3
17309: PPUSH
17310: LD_INT 3
17312: PPUSH
17313: LD_INT 2
17315: PPUSH
17316: LD_INT 1
17318: PPUSH
17319: LD_INT 1
17321: PPUSH
17322: LD_INT 0
17324: PPUSH
17325: LD_INT 0
17327: PPUSH
17328: LD_INT 17
17330: PPUSH
17331: LD_INT 0
17333: PPUSH
17334: CALL 84576 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
17338: LD_INT 2
17340: PPUSH
17341: LD_INT 1
17343: PPUSH
17344: LD_INT 1
17346: PPUSH
17347: LD_INT 1
17349: PPUSH
17350: LD_INT 1
17352: PPUSH
17353: LD_INT 0
17355: PPUSH
17356: LD_INT 0
17358: PPUSH
17359: LD_INT 18
17361: PPUSH
17362: LD_INT 0
17364: PPUSH
17365: CALL 84576 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
17369: LD_INT 4
17371: PPUSH
17372: LD_INT 1
17374: PPUSH
17375: LD_INT 2
17377: PPUSH
17378: LD_INT 4
17380: PPUSH
17381: LD_INT 2
17383: PPUSH
17384: LD_INT 1
17386: PPUSH
17387: LD_INT 0
17389: PPUSH
17390: LD_INT 19
17392: PPUSH
17393: LD_INT 0
17395: PPUSH
17396: CALL 84576 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
17400: LD_INT 0
17402: PPUSH
17403: LD_INT 0
17405: PPUSH
17406: LD_INT 0
17408: PPUSH
17409: LD_INT 0
17411: PPUSH
17412: LD_INT 0
17414: PPUSH
17415: LD_INT 0
17417: PPUSH
17418: LD_INT 9
17420: PPUSH
17421: LD_INT 0
17423: PPUSH
17424: LD_INT 20
17426: PPUSH
17427: CALL 84576 0 9
// end ; end_of_file
17431: LD_VAR 0 1
17435: RET
// every 0 0$30 do var time ;
17436: GO 17438
17438: DISABLE
17439: LD_INT 0
17441: PPUSH
// begin time := 0 0$30 ;
17442: LD_ADDR_VAR 0 1
17446: PUSH
17447: LD_INT 1050
17449: ST_TO_ADDR
// repeat wait ( time ) ;
17450: LD_VAR 0 1
17454: PPUSH
17455: CALL_OW 67
// if Prob ( 50 ) then
17459: LD_INT 50
17461: PPUSH
17462: CALL_OW 13
17466: IFFALSE 17495
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
17468: LD_INT 1
17470: PPUSH
17471: LD_INT 5
17473: PPUSH
17474: CALL_OW 12
17478: PPUSH
17479: LD_INT 106
17481: PPUSH
17482: LD_INT 89
17484: PPUSH
17485: LD_INT 45
17487: PPUSH
17488: LD_INT 1
17490: PPUSH
17491: CALL_OW 56
// time := time + 0 0$3 ;
17495: LD_ADDR_VAR 0 1
17499: PUSH
17500: LD_VAR 0 1
17504: PUSH
17505: LD_INT 105
17507: PLUS
17508: ST_TO_ADDR
// if Prob ( 30 ) then
17509: LD_INT 30
17511: PPUSH
17512: CALL_OW 13
17516: IFFALSE 17562
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
17518: LD_INT 525
17520: PPUSH
17521: LD_INT 735
17523: PPUSH
17524: CALL_OW 12
17528: PPUSH
17529: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
17533: LD_INT 1
17535: PPUSH
17536: LD_INT 5
17538: PPUSH
17539: CALL_OW 12
17543: PPUSH
17544: LD_INT 21
17546: PPUSH
17547: LD_INT 26
17549: PPUSH
17550: LD_INT 12
17552: PPUSH
17553: LD_INT 1
17555: PPUSH
17556: CALL_OW 56
// end else
17560: GO 17598
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
17562: LD_INT 700
17564: PPUSH
17565: LD_INT 1225
17567: PPUSH
17568: CALL_OW 12
17572: PPUSH
17573: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
17577: LD_INT 1
17579: PPUSH
17580: LD_INT 5
17582: PPUSH
17583: CALL_OW 12
17587: PPUSH
17588: LD_INT 14
17590: PPUSH
17591: LD_INT 1
17593: PPUSH
17594: CALL_OW 55
// end ; if Prob ( 50 ) then
17598: LD_INT 50
17600: PPUSH
17601: CALL_OW 13
17605: IFFALSE 17651
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
17607: LD_INT 700
17609: PPUSH
17610: LD_INT 1050
17612: PPUSH
17613: CALL_OW 12
17617: PPUSH
17618: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
17622: LD_INT 1
17624: PPUSH
17625: LD_INT 5
17627: PPUSH
17628: CALL_OW 12
17632: PPUSH
17633: LD_INT 181
17635: PPUSH
17636: LD_INT 218
17638: PPUSH
17639: LD_INT 16
17641: PPUSH
17642: LD_INT 1
17644: PPUSH
17645: CALL_OW 56
// end else
17649: GO 17723
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
17651: LD_INT 350
17653: PPUSH
17654: LD_INT 525
17656: PPUSH
17657: CALL_OW 12
17661: PPUSH
17662: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
17666: LD_INT 1
17668: PPUSH
17669: LD_INT 5
17671: PPUSH
17672: CALL_OW 12
17676: PPUSH
17677: LD_INT 13
17679: PPUSH
17680: LD_INT 1
17682: PPUSH
17683: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17687: LD_INT 350
17689: PPUSH
17690: LD_INT 700
17692: PPUSH
17693: CALL_OW 12
17697: PPUSH
17698: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
17702: LD_INT 1
17704: PPUSH
17705: LD_INT 5
17707: PPUSH
17708: CALL_OW 12
17712: PPUSH
17713: LD_INT 33
17715: PPUSH
17716: LD_INT 1
17718: PPUSH
17719: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 ] [ Difficulty ] ) then
17723: LD_INT 65
17725: PUSH
17726: LD_INT 62
17728: PUSH
17729: LD_INT 55
17731: PUSH
17732: EMPTY
17733: LIST
17734: LIST
17735: LIST
17736: PUSH
17737: LD_OWVAR 67
17741: ARRAY
17742: PPUSH
17743: CALL_OW 13
17747: IFFALSE 17793
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
17749: LD_INT 525
17751: PPUSH
17752: LD_INT 875
17754: PPUSH
17755: CALL_OW 12
17759: PPUSH
17760: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17764: LD_INT 1
17766: PPUSH
17767: LD_INT 5
17769: PPUSH
17770: CALL_OW 12
17774: PPUSH
17775: LD_INT 294
17777: PPUSH
17778: LD_INT 211
17780: PPUSH
17781: LD_INT 30
17783: PPUSH
17784: LD_INT 1
17786: PPUSH
17787: CALL_OW 56
// end else
17791: GO 17835
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
17793: LD_INT 420
17795: PPUSH
17796: LD_INT 770
17798: PPUSH
17799: CALL_OW 12
17803: PPUSH
17804: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17808: LD_INT 1
17810: PPUSH
17811: LD_INT 5
17813: PPUSH
17814: CALL_OW 12
17818: PPUSH
17819: LD_INT 294
17821: PPUSH
17822: LD_INT 211
17824: PPUSH
17825: LD_INT 30
17827: PPUSH
17828: LD_INT 1
17830: PPUSH
17831: CALL_OW 56
// end ; if time > 2 2$20 then
17835: LD_VAR 0 1
17839: PUSH
17840: LD_INT 4900
17842: GREATER
17843: IFFALSE 17853
// time := 0 0$50 ;
17845: LD_ADDR_VAR 0 1
17849: PUSH
17850: LD_INT 1750
17852: ST_TO_ADDR
// until false ;
17853: LD_INT 0
17855: IFFALSE 17450
// end ;
17857: PPOPN 1
17859: END
// every 0 0$45 trigger tick < 10 10$00 do
17860: LD_OWVAR 1
17864: PUSH
17865: LD_INT 21000
17867: LESS
17868: IFFALSE 17916
17870: GO 17872
17872: DISABLE
// begin enable ;
17873: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17874: LD_INT 350
17876: PPUSH
17877: LD_INT 700
17879: PPUSH
17880: CALL_OW 12
17884: PPUSH
17885: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
17889: LD_INT 3
17891: PPUSH
17892: LD_INT 5
17894: PPUSH
17895: CALL_OW 12
17899: PPUSH
17900: LD_INT 181
17902: PPUSH
17903: LD_INT 13
17905: PPUSH
17906: LD_INT 20
17908: PPUSH
17909: LD_INT 1
17911: PPUSH
17912: CALL_OW 56
// end ; end_of_file
17916: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
17917: LD_INT 0
17919: PPUSH
// SetArtifactRes ( 7 , true ) ;
17920: LD_INT 7
17922: PPUSH
17923: LD_INT 1
17925: PPUSH
17926: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
17930: LD_ADDR_EXP 62
17934: PUSH
17935: EMPTY
17936: PUSH
17937: EMPTY
17938: PUSH
17939: EMPTY
17940: PUSH
17941: EMPTY
17942: LIST
17943: LIST
17944: LIST
17945: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
17946: LD_ADDR_EXP 63
17950: PUSH
17951: LD_INT 1050
17953: PUSH
17954: LD_OWVAR 67
17958: MUL
17959: PUSH
17960: LD_INT 2800
17962: PUSH
17963: LD_OWVAR 67
17967: MUL
17968: PUSH
17969: LD_INT 1
17971: NEG
17972: PUSH
17973: EMPTY
17974: LIST
17975: LIST
17976: LIST
17977: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
17978: LD_ADDR_EXP 64
17982: PUSH
17983: LD_INT 10
17985: PUSH
17986: LD_INT 35
17988: PUSH
17989: LD_INT 100
17991: PUSH
17992: EMPTY
17993: LIST
17994: LIST
17995: LIST
17996: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
17997: LD_ADDR_EXP 65
18001: PUSH
18002: LD_INT 0
18004: PUSH
18005: LD_INT 0
18007: PUSH
18008: LD_INT 0
18010: PUSH
18011: EMPTY
18012: LIST
18013: LIST
18014: LIST
18015: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
18016: LD_ADDR_EXP 67
18020: PUSH
18021: LD_INT 300
18023: PUSH
18024: LD_INT 500
18026: PUSH
18027: LD_INT 800
18029: PUSH
18030: EMPTY
18031: LIST
18032: LIST
18033: LIST
18034: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
18035: LD_ADDR_EXP 68
18039: PUSH
18040: LD_INT 0
18042: PUSH
18043: LD_INT 0
18045: PUSH
18046: LD_INT 0
18048: PUSH
18049: EMPTY
18050: LIST
18051: LIST
18052: LIST
18053: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
18054: LD_ADDR_EXP 69
18058: PUSH
18059: LD_INT 0
18061: PUSH
18062: LD_INT 0
18064: PUSH
18065: LD_INT 0
18067: PUSH
18068: EMPTY
18069: LIST
18070: LIST
18071: LIST
18072: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
18073: LD_ADDR_EXP 66
18077: PUSH
18078: LD_INT 0
18080: PUSH
18081: LD_INT 0
18083: PUSH
18084: LD_INT 0
18086: PUSH
18087: EMPTY
18088: LIST
18089: LIST
18090: LIST
18091: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
18092: LD_ADDR_EXP 70
18096: PUSH
18097: LD_INT 4
18099: PUSH
18100: LD_INT 3
18102: PUSH
18103: LD_INT 1
18105: PUSH
18106: EMPTY
18107: LIST
18108: LIST
18109: LIST
18110: PUSH
18111: LD_INT 5
18113: PUSH
18114: LD_INT 4
18116: PUSH
18117: LD_INT 2
18119: PUSH
18120: EMPTY
18121: LIST
18122: LIST
18123: LIST
18124: PUSH
18125: LD_INT 6
18127: PUSH
18128: LD_INT 3
18130: PUSH
18131: LD_INT 3
18133: PUSH
18134: EMPTY
18135: LIST
18136: LIST
18137: LIST
18138: PUSH
18139: EMPTY
18140: LIST
18141: LIST
18142: LIST
18143: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
18144: LD_ADDR_EXP 71
18148: PUSH
18149: LD_INT 0
18151: PUSH
18152: LD_INT 0
18154: PUSH
18155: LD_INT 0
18157: PUSH
18158: EMPTY
18159: LIST
18160: LIST
18161: LIST
18162: ST_TO_ADDR
// end ;
18163: LD_VAR 0 1
18167: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
18168: LD_INT 24
18170: PPUSH
18171: LD_INT 7
18173: PPUSH
18174: CALL_OW 321
18178: PUSH
18179: LD_INT 2
18181: EQUAL
18182: IFFALSE 19108
18184: GO 18186
18186: DISABLE
18187: LD_INT 0
18189: PPUSH
18190: PPUSH
18191: PPUSH
18192: PPUSH
18193: PPUSH
// begin enable ;
18194: ENABLE
// for i = 1 to 3 do
18195: LD_ADDR_VAR 0 1
18199: PUSH
18200: DOUBLE
18201: LD_INT 1
18203: DEC
18204: ST_TO_ADDR
18205: LD_INT 3
18207: PUSH
18208: FOR_TO
18209: IFFALSE 19106
// begin pos := FindArtifact ( i + 2 ) ;
18211: LD_ADDR_VAR 0 2
18215: PUSH
18216: LD_VAR 0 1
18220: PUSH
18221: LD_INT 2
18223: PLUS
18224: PPUSH
18225: CALL_OW 469
18229: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
18230: LD_ADDR_EXP 62
18234: PUSH
18235: LD_EXP 62
18239: PPUSH
18240: LD_VAR 0 1
18244: PPUSH
18245: LD_VAR 0 2
18249: PPUSH
18250: CALL_OW 1
18254: ST_TO_ADDR
// if pos then
18255: LD_VAR 0 2
18259: IFFALSE 18967
// begin case i of 1 :
18261: LD_VAR 0 1
18265: PUSH
18266: LD_INT 1
18268: DOUBLE
18269: EQUAL
18270: IFTRUE 18274
18272: GO 18351
18274: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
18275: LD_ADDR_VAR 0 4
18279: PUSH
18280: LD_INT 22
18282: PUSH
18283: LD_INT 7
18285: PUSH
18286: EMPTY
18287: LIST
18288: LIST
18289: PUSH
18290: LD_INT 23
18292: PUSH
18293: LD_INT 1
18295: PUSH
18296: EMPTY
18297: LIST
18298: LIST
18299: PUSH
18300: LD_INT 2
18302: PUSH
18303: LD_INT 30
18305: PUSH
18306: LD_INT 8
18308: PUSH
18309: EMPTY
18310: LIST
18311: LIST
18312: PUSH
18313: LD_INT 30
18315: PUSH
18316: LD_INT 7
18318: PUSH
18319: EMPTY
18320: LIST
18321: LIST
18322: PUSH
18323: LD_INT 30
18325: PUSH
18326: LD_INT 11
18328: PUSH
18329: EMPTY
18330: LIST
18331: LIST
18332: PUSH
18333: EMPTY
18334: LIST
18335: LIST
18336: LIST
18337: LIST
18338: PUSH
18339: EMPTY
18340: LIST
18341: LIST
18342: LIST
18343: PPUSH
18344: CALL_OW 69
18348: ST_TO_ADDR
18349: GO 18459
18351: LD_INT 2
18353: DOUBLE
18354: EQUAL
18355: IFTRUE 18359
18357: GO 18436
18359: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
18360: LD_ADDR_VAR 0 4
18364: PUSH
18365: LD_INT 22
18367: PUSH
18368: LD_INT 7
18370: PUSH
18371: EMPTY
18372: LIST
18373: LIST
18374: PUSH
18375: LD_INT 23
18377: PUSH
18378: LD_INT 3
18380: PUSH
18381: EMPTY
18382: LIST
18383: LIST
18384: PUSH
18385: LD_INT 2
18387: PUSH
18388: LD_INT 30
18390: PUSH
18391: LD_INT 8
18393: PUSH
18394: EMPTY
18395: LIST
18396: LIST
18397: PUSH
18398: LD_INT 30
18400: PUSH
18401: LD_INT 7
18403: PUSH
18404: EMPTY
18405: LIST
18406: LIST
18407: PUSH
18408: LD_INT 30
18410: PUSH
18411: LD_INT 11
18413: PUSH
18414: EMPTY
18415: LIST
18416: LIST
18417: PUSH
18418: EMPTY
18419: LIST
18420: LIST
18421: LIST
18422: LIST
18423: PUSH
18424: EMPTY
18425: LIST
18426: LIST
18427: LIST
18428: PPUSH
18429: CALL_OW 69
18433: ST_TO_ADDR
18434: GO 18459
18436: LD_INT 3
18438: DOUBLE
18439: EQUAL
18440: IFTRUE 18444
18442: GO 18458
18444: POP
// labs := [ alien ] ; end ;
18445: LD_ADDR_VAR 0 4
18449: PUSH
18450: LD_INT 1
18452: PUSH
18453: EMPTY
18454: LIST
18455: ST_TO_ADDR
18456: GO 18459
18458: POP
// if not labs then
18459: LD_VAR 0 4
18463: NOT
18464: IFFALSE 18468
// continue ;
18466: GO 18208
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
18468: LD_ADDR_VAR 0 5
18472: PUSH
18473: LD_VAR 0 4
18477: PPUSH
18478: LD_EXP 62
18482: PUSH
18483: LD_VAR 0 1
18487: ARRAY
18488: PUSH
18489: LD_INT 1
18491: ARRAY
18492: PPUSH
18493: LD_EXP 62
18497: PUSH
18498: LD_VAR 0 1
18502: ARRAY
18503: PUSH
18504: LD_INT 2
18506: ARRAY
18507: PPUSH
18508: CALL_OW 73
18512: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
18513: LD_VAR 0 5
18517: NOT
18518: PUSH
18519: LD_VAR 0 5
18523: PUSH
18524: LD_EXP 69
18528: PUSH
18529: LD_VAR 0 1
18533: ARRAY
18534: NONEQUAL
18535: OR
18536: IFFALSE 18641
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18538: LD_INT 7
18540: PPUSH
18541: LD_EXP 70
18545: PUSH
18546: LD_VAR 0 1
18550: ARRAY
18551: PUSH
18552: LD_INT 3
18554: ARRAY
18555: PPUSH
18556: LD_INT 0
18558: PPUSH
18559: LD_EXP 69
18563: PUSH
18564: LD_VAR 0 1
18568: ARRAY
18569: PPUSH
18570: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18574: LD_INT 7
18576: PPUSH
18577: LD_EXP 70
18581: PUSH
18582: LD_VAR 0 1
18586: ARRAY
18587: PUSH
18588: LD_INT 1
18590: ARRAY
18591: PPUSH
18592: LD_INT 0
18594: PPUSH
18595: LD_EXP 69
18599: PUSH
18600: LD_VAR 0 1
18604: ARRAY
18605: PPUSH
18606: CALL_OW 468
// if nearestLab then
18610: LD_VAR 0 5
18614: IFFALSE 18641
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
18616: LD_ADDR_EXP 69
18620: PUSH
18621: LD_EXP 69
18625: PPUSH
18626: LD_VAR 0 1
18630: PPUSH
18631: LD_VAR 0 5
18635: PPUSH
18636: CALL_OW 1
18640: ST_TO_ADDR
// end ; if not nearestLab then
18641: LD_VAR 0 5
18645: NOT
18646: IFFALSE 18650
// continue ;
18648: GO 18208
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
18650: LD_VAR 0 5
18654: PPUSH
18655: LD_EXP 62
18659: PUSH
18660: LD_VAR 0 1
18664: ARRAY
18665: PUSH
18666: LD_INT 1
18668: ARRAY
18669: PPUSH
18670: LD_EXP 62
18674: PUSH
18675: LD_VAR 0 1
18679: ARRAY
18680: PUSH
18681: LD_INT 2
18683: ARRAY
18684: PPUSH
18685: CALL_OW 297
18689: PUSH
18690: LD_INT 8
18692: LESS
18693: IFFALSE 18890
// begin if not artifactsResearched [ i ] then
18695: LD_EXP 65
18699: PUSH
18700: LD_VAR 0 1
18704: ARRAY
18705: NOT
18706: IFFALSE 18787
// begin if BuildingStatus ( nearestLab ) = bs_idle then
18708: LD_VAR 0 5
18712: PPUSH
18713: CALL_OW 461
18717: PUSH
18718: LD_INT 2
18720: EQUAL
18721: IFFALSE 18755
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
18723: LD_INT 7
18725: PPUSH
18726: LD_EXP 70
18730: PUSH
18731: LD_VAR 0 1
18735: ARRAY
18736: PUSH
18737: LD_INT 3
18739: ARRAY
18740: PPUSH
18741: LD_INT 2
18743: PPUSH
18744: LD_VAR 0 5
18748: PPUSH
18749: CALL_OW 468
18753: GO 18785
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
18755: LD_INT 7
18757: PPUSH
18758: LD_EXP 70
18762: PUSH
18763: LD_VAR 0 1
18767: ARRAY
18768: PUSH
18769: LD_INT 3
18771: ARRAY
18772: PPUSH
18773: LD_INT 1
18775: PPUSH
18776: LD_VAR 0 5
18780: PPUSH
18781: CALL_OW 468
// end else
18785: GO 18888
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
18787: LD_VAR 0 5
18791: PPUSH
18792: CALL_OW 461
18796: PUSH
18797: LD_INT 2
18799: EQUAL
18800: PUSH
18801: LD_EXP 71
18805: PUSH
18806: LD_VAR 0 1
18810: ARRAY
18811: AND
18812: IFFALSE 18858
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
18814: LD_INT 7
18816: PPUSH
18817: LD_EXP 70
18821: PUSH
18822: LD_VAR 0 1
18826: ARRAY
18827: PUSH
18828: LD_INT 1
18830: ARRAY
18831: PPUSH
18832: LD_EXP 70
18836: PUSH
18837: LD_VAR 0 1
18841: ARRAY
18842: PUSH
18843: LD_INT 2
18845: ARRAY
18846: PPUSH
18847: LD_VAR 0 5
18851: PPUSH
18852: CALL_OW 468
18856: GO 18888
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
18858: LD_INT 7
18860: PPUSH
18861: LD_EXP 70
18865: PUSH
18866: LD_VAR 0 1
18870: ARRAY
18871: PUSH
18872: LD_INT 1
18874: ARRAY
18875: PPUSH
18876: LD_INT 1
18878: PPUSH
18879: LD_VAR 0 5
18883: PPUSH
18884: CALL_OW 468
// end else
18888: GO 18965
// begin if not artifactsResearched [ i ] then
18890: LD_EXP 65
18894: PUSH
18895: LD_VAR 0 1
18899: ARRAY
18900: NOT
18901: IFFALSE 18935
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
18903: LD_INT 7
18905: PPUSH
18906: LD_EXP 70
18910: PUSH
18911: LD_VAR 0 1
18915: ARRAY
18916: PUSH
18917: LD_INT 3
18919: ARRAY
18920: PPUSH
18921: LD_INT 0
18923: PPUSH
18924: LD_VAR 0 5
18928: PPUSH
18929: CALL_OW 468
18933: GO 18965
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
18935: LD_INT 7
18937: PPUSH
18938: LD_EXP 70
18942: PUSH
18943: LD_VAR 0 1
18947: ARRAY
18948: PUSH
18949: LD_INT 1
18951: ARRAY
18952: PPUSH
18953: LD_INT 0
18955: PPUSH
18956: LD_VAR 0 5
18960: PPUSH
18961: CALL_OW 468
// end ; end else
18965: GO 19104
// begin if not artifactsLabs [ i ] then
18967: LD_EXP 69
18971: PUSH
18972: LD_VAR 0 1
18976: ARRAY
18977: NOT
18978: IFFALSE 18982
// continue ;
18980: GO 18208
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18982: LD_INT 7
18984: PPUSH
18985: LD_EXP 70
18989: PUSH
18990: LD_VAR 0 1
18994: ARRAY
18995: PUSH
18996: LD_INT 3
18998: ARRAY
18999: PPUSH
19000: LD_INT 0
19002: PPUSH
19003: LD_EXP 69
19007: PUSH
19008: LD_VAR 0 1
19012: ARRAY
19013: PPUSH
19014: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
19018: LD_INT 7
19020: PPUSH
19021: LD_EXP 70
19025: PUSH
19026: LD_VAR 0 1
19030: ARRAY
19031: PUSH
19032: LD_INT 1
19034: ARRAY
19035: PPUSH
19036: LD_INT 0
19038: PPUSH
19039: LD_EXP 69
19043: PUSH
19044: LD_VAR 0 1
19048: ARRAY
19049: PPUSH
19050: CALL_OW 468
// if artifactsLabsWorking [ i ] then
19054: LD_EXP 66
19058: PUSH
19059: LD_VAR 0 1
19063: ARRAY
19064: IFFALSE 19104
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
19066: LD_ADDR_EXP 66
19070: PUSH
19071: LD_EXP 66
19075: PPUSH
19076: LD_VAR 0 1
19080: PPUSH
19081: LD_INT 0
19083: PPUSH
19084: CALL_OW 1
19088: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
19089: LD_EXP 69
19093: PUSH
19094: LD_VAR 0 1
19098: ARRAY
19099: PPUSH
19100: CALL_OW 127
// end ; end ; end ;
19104: GO 18208
19106: POP
19107: POP
// end ;
19108: PPOPN 5
19110: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
19111: LD_INT 0
19113: PPUSH
19114: PPUSH
19115: PPUSH
19116: PPUSH
19117: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
19118: LD_VAR 0 2
19122: PUSH
19123: LD_EXP 70
19127: PUSH
19128: LD_INT 1
19130: ARRAY
19131: PUSH
19132: LD_INT 3
19134: ARRAY
19135: EQUAL
19136: IFFALSE 19259
// begin lab := artifactsLabs [ 1 ] ;
19138: LD_ADDR_VAR 0 6
19142: PUSH
19143: LD_EXP 69
19147: PUSH
19148: LD_INT 1
19150: ARRAY
19151: ST_TO_ADDR
// if not lab then
19152: LD_VAR 0 6
19156: NOT
19157: IFFALSE 19161
// exit ;
19159: GO 20239
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
19161: LD_VAR 0 6
19165: PPUSH
19166: LD_EXP 67
19170: PUSH
19171: LD_INT 1
19173: ARRAY
19174: PPUSH
19175: LD_INT 1
19177: PPUSH
19178: CALL_OW 486
// if artifactsResProgress [ 1 ] then
19182: LD_EXP 68
19186: PUSH
19187: LD_INT 1
19189: ARRAY
19190: IFFALSE 19210
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
19192: LD_VAR 0 6
19196: PPUSH
19197: LD_EXP 68
19201: PUSH
19202: LD_INT 1
19204: ARRAY
19205: PPUSH
19206: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
19210: LD_ADDR_EXP 66
19214: PUSH
19215: LD_EXP 66
19219: PPUSH
19220: LD_INT 1
19222: PPUSH
19223: LD_INT 1
19225: PPUSH
19226: CALL_OW 1
19230: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
19231: LD_INT 7
19233: PPUSH
19234: LD_EXP 70
19238: PUSH
19239: LD_INT 1
19241: ARRAY
19242: PUSH
19243: LD_INT 3
19245: ARRAY
19246: PPUSH
19247: LD_INT 0
19249: PPUSH
19250: LD_VAR 0 6
19254: PPUSH
19255: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
19259: LD_VAR 0 2
19263: PUSH
19264: LD_EXP 70
19268: PUSH
19269: LD_INT 2
19271: ARRAY
19272: PUSH
19273: LD_INT 3
19275: ARRAY
19276: EQUAL
19277: IFFALSE 19400
// begin lab := artifactsLabs [ 2 ] ;
19279: LD_ADDR_VAR 0 6
19283: PUSH
19284: LD_EXP 69
19288: PUSH
19289: LD_INT 2
19291: ARRAY
19292: ST_TO_ADDR
// if not lab then
19293: LD_VAR 0 6
19297: NOT
19298: IFFALSE 19302
// exit ;
19300: GO 20239
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
19302: LD_VAR 0 6
19306: PPUSH
19307: LD_EXP 67
19311: PUSH
19312: LD_INT 2
19314: ARRAY
19315: PPUSH
19316: LD_INT 1
19318: PPUSH
19319: CALL_OW 486
// if artifactsResProgress [ 2 ] then
19323: LD_EXP 68
19327: PUSH
19328: LD_INT 2
19330: ARRAY
19331: IFFALSE 19351
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
19333: LD_VAR 0 6
19337: PPUSH
19338: LD_EXP 68
19342: PUSH
19343: LD_INT 2
19345: ARRAY
19346: PPUSH
19347: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
19351: LD_ADDR_EXP 66
19355: PUSH
19356: LD_EXP 66
19360: PPUSH
19361: LD_INT 2
19363: PPUSH
19364: LD_INT 1
19366: PPUSH
19367: CALL_OW 1
19371: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
19372: LD_INT 7
19374: PPUSH
19375: LD_EXP 70
19379: PUSH
19380: LD_INT 2
19382: ARRAY
19383: PUSH
19384: LD_INT 3
19386: ARRAY
19387: PPUSH
19388: LD_INT 0
19390: PPUSH
19391: LD_VAR 0 6
19395: PPUSH
19396: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
19400: LD_VAR 0 2
19404: PUSH
19405: LD_EXP 70
19409: PUSH
19410: LD_INT 3
19412: ARRAY
19413: PUSH
19414: LD_INT 3
19416: ARRAY
19417: EQUAL
19418: IFFALSE 19541
// begin lab := artifactsLabs [ 3 ] ;
19420: LD_ADDR_VAR 0 6
19424: PUSH
19425: LD_EXP 69
19429: PUSH
19430: LD_INT 3
19432: ARRAY
19433: ST_TO_ADDR
// if not lab then
19434: LD_VAR 0 6
19438: NOT
19439: IFFALSE 19443
// exit ;
19441: GO 20239
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
19443: LD_VAR 0 6
19447: PPUSH
19448: LD_EXP 67
19452: PUSH
19453: LD_INT 3
19455: ARRAY
19456: PPUSH
19457: LD_INT 1
19459: PPUSH
19460: CALL_OW 486
// if artifactsResProgress [ 3 ] then
19464: LD_EXP 68
19468: PUSH
19469: LD_INT 3
19471: ARRAY
19472: IFFALSE 19492
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
19474: LD_VAR 0 6
19478: PPUSH
19479: LD_EXP 68
19483: PUSH
19484: LD_INT 3
19486: ARRAY
19487: PPUSH
19488: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
19492: LD_ADDR_EXP 66
19496: PUSH
19497: LD_EXP 66
19501: PPUSH
19502: LD_INT 3
19504: PPUSH
19505: LD_INT 1
19507: PPUSH
19508: CALL_OW 1
19512: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
19513: LD_INT 7
19515: PPUSH
19516: LD_EXP 70
19520: PUSH
19521: LD_INT 3
19523: ARRAY
19524: PUSH
19525: LD_INT 3
19527: ARRAY
19528: PPUSH
19529: LD_INT 0
19531: PPUSH
19532: LD_VAR 0 6
19536: PPUSH
19537: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
19541: LD_VAR 0 2
19545: PUSH
19546: LD_EXP 70
19550: PUSH
19551: LD_INT 1
19553: ARRAY
19554: PUSH
19555: LD_INT 1
19557: ARRAY
19558: EQUAL
19559: IFFALSE 19717
// begin lab := artifactsLabs [ 1 ] ;
19561: LD_ADDR_VAR 0 6
19565: PUSH
19566: LD_EXP 69
19570: PUSH
19571: LD_INT 1
19573: ARRAY
19574: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
19575: LD_VAR 0 6
19579: PPUSH
19580: CALL_OW 274
19584: PPUSH
19585: CALL 88180 0 1
19589: PUSH
19590: LD_INT 3
19592: ARRAY
19593: PUSH
19594: LD_EXP 64
19598: PUSH
19599: LD_INT 1
19601: ARRAY
19602: LESS
19603: IFFALSE 19617
// begin HintSpec ( ArtifactCost , 2 ) ;
19605: LD_STRING ArtifactCost
19607: PPUSH
19608: LD_INT 2
19610: PPUSH
19611: CALL_OW 338
// exit ;
19615: GO 20239
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
19617: LD_ADDR_EXP 71
19621: PUSH
19622: LD_EXP 71
19626: PPUSH
19627: LD_INT 1
19629: PPUSH
19630: LD_INT 0
19632: PPUSH
19633: CALL_OW 1
19637: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
19638: LD_VAR 0 3
19642: PPUSH
19643: LD_VAR 0 4
19647: PPUSH
19648: LD_INT 7
19650: PPUSH
19651: LD_INT 12
19653: NEG
19654: PPUSH
19655: CALL_OW 330
// wait ( 0 0$30 ) ;
19659: LD_INT 1050
19661: PPUSH
19662: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
19666: LD_VAR 0 3
19670: PPUSH
19671: LD_VAR 0 4
19675: PPUSH
19676: LD_INT 7
19678: PPUSH
19679: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
19683: LD_EXP 63
19687: PUSH
19688: LD_INT 1
19690: ARRAY
19691: PPUSH
19692: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
19696: LD_ADDR_EXP 71
19700: PUSH
19701: LD_EXP 71
19705: PPUSH
19706: LD_INT 1
19708: PPUSH
19709: LD_INT 1
19711: PPUSH
19712: CALL_OW 1
19716: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
19717: LD_VAR 0 2
19721: PUSH
19722: LD_EXP 70
19726: PUSH
19727: LD_INT 2
19729: ARRAY
19730: PUSH
19731: LD_INT 1
19733: ARRAY
19734: EQUAL
19735: IFFALSE 19972
// begin lab := artifactsLabs [ 2 ] ;
19737: LD_ADDR_VAR 0 6
19741: PUSH
19742: LD_EXP 69
19746: PUSH
19747: LD_INT 2
19749: ARRAY
19750: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] , [ f_btype , b_ext_siberium ] ] ] ) then
19751: LD_VAR 0 3
19755: PUSH
19756: LD_INT 81
19758: PUSH
19759: LD_INT 7
19761: PUSH
19762: EMPTY
19763: LIST
19764: LIST
19765: PUSH
19766: LD_INT 2
19768: PUSH
19769: LD_INT 32
19771: PUSH
19772: LD_INT 3
19774: PUSH
19775: EMPTY
19776: LIST
19777: LIST
19778: PUSH
19779: LD_INT 30
19781: PUSH
19782: LD_INT 28
19784: PUSH
19785: EMPTY
19786: LIST
19787: LIST
19788: PUSH
19789: LD_INT 30
19791: PUSH
19792: LD_INT 30
19794: PUSH
19795: EMPTY
19796: LIST
19797: LIST
19798: PUSH
19799: LD_INT 35
19801: PUSH
19802: LD_INT 49
19804: PUSH
19805: EMPTY
19806: LIST
19807: LIST
19808: PUSH
19809: LD_INT 34
19811: PUSH
19812: LD_INT 49
19814: PUSH
19815: EMPTY
19816: LIST
19817: LIST
19818: PUSH
19819: LD_INT 30
19821: PUSH
19822: LD_INT 21
19824: PUSH
19825: EMPTY
19826: LIST
19827: LIST
19828: PUSH
19829: EMPTY
19830: LIST
19831: LIST
19832: LIST
19833: LIST
19834: LIST
19835: LIST
19836: LIST
19837: PUSH
19838: EMPTY
19839: LIST
19840: LIST
19841: PPUSH
19842: CALL_OW 69
19846: IN
19847: NOT
19848: IFFALSE 19852
// exit ;
19850: GO 20239
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
19852: LD_VAR 0 6
19856: PPUSH
19857: CALL_OW 274
19861: PPUSH
19862: CALL 88180 0 1
19866: PUSH
19867: LD_INT 3
19869: ARRAY
19870: PUSH
19871: LD_EXP 64
19875: PUSH
19876: LD_INT 2
19878: ARRAY
19879: LESS
19880: IFFALSE 19894
// begin HintSpec ( ArtifactCost , 2 ) ;
19882: LD_STRING ArtifactCost
19884: PPUSH
19885: LD_INT 2
19887: PPUSH
19888: CALL_OW 338
// exit ;
19892: GO 20239
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
19894: LD_ADDR_EXP 71
19898: PUSH
19899: LD_EXP 71
19903: PPUSH
19904: LD_INT 2
19906: PPUSH
19907: LD_INT 0
19909: PPUSH
19910: CALL_OW 1
19914: ST_TO_ADDR
// KillUnit ( x ) ;
19915: LD_VAR 0 3
19919: PPUSH
19920: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
19924: LD_ADDR_EXP 16
19928: PUSH
19929: LD_EXP 16
19933: PUSH
19934: LD_INT 1
19936: PLUS
19937: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
19938: LD_EXP 63
19942: PUSH
19943: LD_INT 2
19945: ARRAY
19946: PPUSH
19947: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
19951: LD_ADDR_EXP 71
19955: PUSH
19956: LD_EXP 71
19960: PPUSH
19961: LD_INT 2
19963: PPUSH
19964: LD_INT 1
19966: PPUSH
19967: CALL_OW 1
19971: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
19972: LD_VAR 0 2
19976: PUSH
19977: LD_EXP 70
19981: PUSH
19982: LD_INT 3
19984: ARRAY
19985: PUSH
19986: LD_INT 1
19988: ARRAY
19989: EQUAL
19990: IFFALSE 20239
// begin lab := artifactsLabs [ 3 ] ;
19992: LD_ADDR_VAR 0 6
19996: PUSH
19997: LD_EXP 69
20001: PUSH
20002: LD_INT 3
20004: ARRAY
20005: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
20006: LD_VAR 0 6
20010: PPUSH
20011: CALL_OW 274
20015: PPUSH
20016: CALL 88180 0 1
20020: PUSH
20021: LD_INT 3
20023: ARRAY
20024: PUSH
20025: LD_EXP 64
20029: PUSH
20030: LD_INT 3
20032: ARRAY
20033: LESS
20034: IFFALSE 20048
// begin HintSpec ( ArtifactCost , 2 ) ;
20036: LD_STRING ArtifactCost
20038: PPUSH
20039: LD_INT 2
20041: PPUSH
20042: CALL_OW 338
// exit ;
20046: GO 20239
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
20048: LD_INT 37
20050: PPUSH
20051: LD_INT 1
20053: PPUSH
20054: CALL_OW 424
// time := 0 0$30 ;
20058: LD_ADDR_VAR 0 7
20062: PUSH
20063: LD_INT 1050
20065: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
20066: LD_ADDR_EXP 71
20070: PUSH
20071: LD_EXP 71
20075: PPUSH
20076: LD_INT 3
20078: PPUSH
20079: LD_INT 0
20081: PPUSH
20082: CALL_OW 1
20086: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
20087: LD_ADDR_OWVAR 47
20091: PUSH
20092: LD_STRING #Am15a-1
20094: PUSH
20095: LD_VAR 0 7
20099: PUSH
20100: EMPTY
20101: LIST
20102: LIST
20103: ST_TO_ADDR
// wait ( 0 0$1 ) ;
20104: LD_INT 35
20106: PPUSH
20107: CALL_OW 67
// time := time - 0 0$1 ;
20111: LD_ADDR_VAR 0 7
20115: PUSH
20116: LD_VAR 0 7
20120: PUSH
20121: LD_INT 35
20123: MINUS
20124: ST_TO_ADDR
// until time = 0 0$00 ;
20125: LD_VAR 0 7
20129: PUSH
20130: LD_INT 0
20132: EQUAL
20133: IFFALSE 20087
// display_strings :=  ;
20135: LD_ADDR_OWVAR 47
20139: PUSH
20140: LD_STRING 
20142: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
20143: LD_INT 37
20145: PPUSH
20146: LD_INT 0
20148: PPUSH
20149: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
20153: LD_ADDR_VAR 0 8
20157: PUSH
20158: LD_INT 37
20160: PPUSH
20161: LD_INT 3
20163: PUSH
20164: LD_INT 21
20166: PUSH
20167: LD_INT 3
20169: PUSH
20170: EMPTY
20171: LIST
20172: LIST
20173: PUSH
20174: EMPTY
20175: LIST
20176: LIST
20177: PPUSH
20178: CALL_OW 70
20182: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
20183: LD_VAR 0 3
20187: PPUSH
20188: LD_VAR 0 4
20192: PPUSH
20193: CALL_OW 84
// for un in list do
20197: LD_ADDR_VAR 0 9
20201: PUSH
20202: LD_VAR 0 8
20206: PUSH
20207: FOR_IN
20208: IFFALSE 20237
// TeleportUnit ( un , x , y , 12 , true ) ;
20210: LD_VAR 0 9
20214: PPUSH
20215: LD_VAR 0 3
20219: PPUSH
20220: LD_VAR 0 4
20224: PPUSH
20225: LD_INT 12
20227: PPUSH
20228: LD_INT 1
20230: PPUSH
20231: CALL_OW 483
20235: GO 20207
20237: POP
20238: POP
// end ; end ;
20239: PPOPN 9
20241: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
20242: LD_INT 0
20244: PPUSH
20245: PPUSH
// begin labNum := 0 ;
20246: LD_ADDR_VAR 0 4
20250: PUSH
20251: LD_INT 0
20253: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20254: LD_ADDR_VAR 0 3
20258: PUSH
20259: DOUBLE
20260: LD_INT 1
20262: DEC
20263: ST_TO_ADDR
20264: LD_EXP 69
20268: PUSH
20269: FOR_TO
20270: IFFALSE 20304
// if artifactsLabs [ i ] = lab then
20272: LD_EXP 69
20276: PUSH
20277: LD_VAR 0 3
20281: ARRAY
20282: PUSH
20283: LD_VAR 0 1
20287: EQUAL
20288: IFFALSE 20302
// begin labNum := i ;
20290: LD_ADDR_VAR 0 4
20294: PUSH
20295: LD_VAR 0 3
20299: ST_TO_ADDR
// break ;
20300: GO 20304
// end ;
20302: GO 20269
20304: POP
20305: POP
// if not labNum then
20306: LD_VAR 0 4
20310: NOT
20311: IFFALSE 20315
// exit ;
20313: GO 20393
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
20315: LD_INT 7
20317: PPUSH
20318: LD_EXP 70
20322: PUSH
20323: LD_VAR 0 4
20327: ARRAY
20328: PUSH
20329: LD_INT 3
20331: ARRAY
20332: PPUSH
20333: LD_INT 2
20335: PPUSH
20336: LD_VAR 0 1
20340: PPUSH
20341: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
20345: LD_ADDR_EXP 68
20349: PUSH
20350: LD_EXP 68
20354: PPUSH
20355: LD_VAR 0 4
20359: PPUSH
20360: LD_VAR 0 2
20364: PPUSH
20365: CALL_OW 1
20369: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
20370: LD_ADDR_EXP 66
20374: PUSH
20375: LD_EXP 66
20379: PPUSH
20380: LD_VAR 0 4
20384: PPUSH
20385: LD_INT 0
20387: PPUSH
20388: CALL_OW 1
20392: ST_TO_ADDR
// end ;
20393: PPOPN 4
20395: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
20396: LD_INT 0
20398: PPUSH
20399: PPUSH
// begin labNum := 0 ;
20400: LD_ADDR_VAR 0 3
20404: PUSH
20405: LD_INT 0
20407: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20408: LD_ADDR_VAR 0 2
20412: PUSH
20413: DOUBLE
20414: LD_INT 1
20416: DEC
20417: ST_TO_ADDR
20418: LD_EXP 69
20422: PUSH
20423: FOR_TO
20424: IFFALSE 20458
// if artifactsLabs [ i ] = lab then
20426: LD_EXP 69
20430: PUSH
20431: LD_VAR 0 2
20435: ARRAY
20436: PUSH
20437: LD_VAR 0 1
20441: EQUAL
20442: IFFALSE 20456
// begin labNum := i ;
20444: LD_ADDR_VAR 0 3
20448: PUSH
20449: LD_VAR 0 2
20453: ST_TO_ADDR
// break ;
20454: GO 20458
// end ;
20456: GO 20423
20458: POP
20459: POP
// if not labNum then
20460: LD_VAR 0 3
20464: NOT
20465: IFFALSE 20469
// exit ;
20467: GO 20631
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
20469: LD_INT 7
20471: PPUSH
20472: LD_EXP 70
20476: PUSH
20477: LD_VAR 0 3
20481: ARRAY
20482: PUSH
20483: LD_INT 3
20485: ARRAY
20486: PPUSH
20487: LD_INT 0
20489: PPUSH
20490: LD_VAR 0 1
20494: PPUSH
20495: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
20499: LD_ADDR_EXP 65
20503: PUSH
20504: LD_EXP 65
20508: PPUSH
20509: LD_VAR 0 3
20513: PPUSH
20514: LD_INT 1
20516: PPUSH
20517: CALL_OW 1
20521: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
20522: LD_ADDR_EXP 71
20526: PUSH
20527: LD_EXP 71
20531: PPUSH
20532: LD_VAR 0 3
20536: PPUSH
20537: LD_INT 1
20539: PPUSH
20540: CALL_OW 1
20544: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
20545: LD_ADDR_EXP 66
20549: PUSH
20550: LD_EXP 66
20554: PPUSH
20555: LD_VAR 0 3
20559: PPUSH
20560: LD_INT 0
20562: PPUSH
20563: CALL_OW 1
20567: ST_TO_ADDR
// case labNum of 1 :
20568: LD_VAR 0 3
20572: PUSH
20573: LD_INT 1
20575: DOUBLE
20576: EQUAL
20577: IFTRUE 20581
20579: GO 20592
20581: POP
// artifactIResearched := true ; 2 :
20582: LD_ADDR_EXP 12
20586: PUSH
20587: LD_INT 1
20589: ST_TO_ADDR
20590: GO 20631
20592: LD_INT 2
20594: DOUBLE
20595: EQUAL
20596: IFTRUE 20600
20598: GO 20611
20600: POP
// artifactIIResearched := true ; 3 :
20601: LD_ADDR_EXP 13
20605: PUSH
20606: LD_INT 1
20608: ST_TO_ADDR
20609: GO 20631
20611: LD_INT 3
20613: DOUBLE
20614: EQUAL
20615: IFTRUE 20619
20617: GO 20630
20619: POP
// artifactIIIResearched := true ; end ;
20620: LD_ADDR_EXP 14
20624: PUSH
20625: LD_INT 1
20627: ST_TO_ADDR
20628: GO 20631
20630: POP
// end ; end_of_file
20631: PPOPN 3
20633: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
20634: LD_INT 0
20636: PPUSH
// ar_miner := 81 ;
20637: LD_ADDR_EXP 79
20641: PUSH
20642: LD_INT 81
20644: ST_TO_ADDR
// ar_crane := 88 ;
20645: LD_ADDR_EXP 78
20649: PUSH
20650: LD_INT 88
20652: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
20653: LD_ADDR_EXP 73
20657: PUSH
20658: LD_INT 89
20660: ST_TO_ADDR
// us_hack := 99 ;
20661: LD_ADDR_EXP 74
20665: PUSH
20666: LD_INT 99
20668: ST_TO_ADDR
// us_artillery := 97 ;
20669: LD_ADDR_EXP 75
20673: PUSH
20674: LD_INT 97
20676: ST_TO_ADDR
// ar_bio_bomb := 91 ;
20677: LD_ADDR_EXP 76
20681: PUSH
20682: LD_INT 91
20684: ST_TO_ADDR
// ar_mortar := 92 ;
20685: LD_ADDR_EXP 77
20689: PUSH
20690: LD_INT 92
20692: ST_TO_ADDR
// ru_radar := 98 ;
20693: LD_ADDR_EXP 72
20697: PUSH
20698: LD_INT 98
20700: ST_TO_ADDR
// tech_Artillery := 80 ;
20701: LD_ADDR_EXP 80
20705: PUSH
20706: LD_INT 80
20708: ST_TO_ADDR
// tech_RadMat := 81 ;
20709: LD_ADDR_EXP 81
20713: PUSH
20714: LD_INT 81
20716: ST_TO_ADDR
// tech_BasicTools := 82 ;
20717: LD_ADDR_EXP 82
20721: PUSH
20722: LD_INT 82
20724: ST_TO_ADDR
// tech_Cargo := 83 ;
20725: LD_ADDR_EXP 83
20729: PUSH
20730: LD_INT 83
20732: ST_TO_ADDR
// tech_Track := 84 ;
20733: LD_ADDR_EXP 84
20737: PUSH
20738: LD_INT 84
20740: ST_TO_ADDR
// tech_Crane := 85 ;
20741: LD_ADDR_EXP 85
20745: PUSH
20746: LD_INT 85
20748: ST_TO_ADDR
// tech_Bulldozer := 86 ;
20749: LD_ADDR_EXP 86
20753: PUSH
20754: LD_INT 86
20756: ST_TO_ADDR
// tech_Hovercraft := 87 ;
20757: LD_ADDR_EXP 87
20761: PUSH
20762: LD_INT 87
20764: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
20765: LD_ADDR_EXP 88
20769: PUSH
20770: LD_INT 88
20772: ST_TO_ADDR
// class_mastodont := 31 ;
20773: LD_ADDR_EXP 89
20777: PUSH
20778: LD_INT 31
20780: ST_TO_ADDR
// class_horse := 21 ;
20781: LD_ADDR_EXP 90
20785: PUSH
20786: LD_INT 21
20788: ST_TO_ADDR
// end ;
20789: LD_VAR 0 1
20793: RET
// every 1 do
20794: GO 20796
20796: DISABLE
// InitGlobalVariables ; end_of_file
20797: CALL 20634 0 0
20801: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
20802: LD_INT 0
20804: PPUSH
20805: PPUSH
// skirmish := false ;
20806: LD_ADDR_EXP 91
20810: PUSH
20811: LD_INT 0
20813: ST_TO_ADDR
// debug_mc := false ;
20814: LD_ADDR_EXP 92
20818: PUSH
20819: LD_INT 0
20821: ST_TO_ADDR
// mc_bases := [ ] ;
20822: LD_ADDR_EXP 93
20826: PUSH
20827: EMPTY
20828: ST_TO_ADDR
// mc_sides := [ ] ;
20829: LD_ADDR_EXP 119
20833: PUSH
20834: EMPTY
20835: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
20836: LD_ADDR_EXP 94
20840: PUSH
20841: EMPTY
20842: ST_TO_ADDR
// mc_building_repairs := [ ] ;
20843: LD_ADDR_EXP 95
20847: PUSH
20848: EMPTY
20849: ST_TO_ADDR
// mc_need_heal := [ ] ;
20850: LD_ADDR_EXP 96
20854: PUSH
20855: EMPTY
20856: ST_TO_ADDR
// mc_healers := [ ] ;
20857: LD_ADDR_EXP 97
20861: PUSH
20862: EMPTY
20863: ST_TO_ADDR
// mc_build_list := [ ] ;
20864: LD_ADDR_EXP 98
20868: PUSH
20869: EMPTY
20870: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
20871: LD_ADDR_EXP 125
20875: PUSH
20876: EMPTY
20877: ST_TO_ADDR
// mc_builders := [ ] ;
20878: LD_ADDR_EXP 99
20882: PUSH
20883: EMPTY
20884: ST_TO_ADDR
// mc_construct_list := [ ] ;
20885: LD_ADDR_EXP 100
20889: PUSH
20890: EMPTY
20891: ST_TO_ADDR
// mc_turret_list := [ ] ;
20892: LD_ADDR_EXP 101
20896: PUSH
20897: EMPTY
20898: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
20899: LD_ADDR_EXP 102
20903: PUSH
20904: EMPTY
20905: ST_TO_ADDR
// mc_miners := [ ] ;
20906: LD_ADDR_EXP 107
20910: PUSH
20911: EMPTY
20912: ST_TO_ADDR
// mc_mines := [ ] ;
20913: LD_ADDR_EXP 106
20917: PUSH
20918: EMPTY
20919: ST_TO_ADDR
// mc_minefields := [ ] ;
20920: LD_ADDR_EXP 108
20924: PUSH
20925: EMPTY
20926: ST_TO_ADDR
// mc_crates := [ ] ;
20927: LD_ADDR_EXP 109
20931: PUSH
20932: EMPTY
20933: ST_TO_ADDR
// mc_crates_collector := [ ] ;
20934: LD_ADDR_EXP 110
20938: PUSH
20939: EMPTY
20940: ST_TO_ADDR
// mc_crates_area := [ ] ;
20941: LD_ADDR_EXP 111
20945: PUSH
20946: EMPTY
20947: ST_TO_ADDR
// mc_vehicles := [ ] ;
20948: LD_ADDR_EXP 112
20952: PUSH
20953: EMPTY
20954: ST_TO_ADDR
// mc_attack := [ ] ;
20955: LD_ADDR_EXP 113
20959: PUSH
20960: EMPTY
20961: ST_TO_ADDR
// mc_produce := [ ] ;
20962: LD_ADDR_EXP 114
20966: PUSH
20967: EMPTY
20968: ST_TO_ADDR
// mc_defender := [ ] ;
20969: LD_ADDR_EXP 115
20973: PUSH
20974: EMPTY
20975: ST_TO_ADDR
// mc_parking := [ ] ;
20976: LD_ADDR_EXP 117
20980: PUSH
20981: EMPTY
20982: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
20983: LD_ADDR_EXP 103
20987: PUSH
20988: EMPTY
20989: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
20990: LD_ADDR_EXP 105
20994: PUSH
20995: EMPTY
20996: ST_TO_ADDR
// mc_scan := [ ] ;
20997: LD_ADDR_EXP 116
21001: PUSH
21002: EMPTY
21003: ST_TO_ADDR
// mc_scan_area := [ ] ;
21004: LD_ADDR_EXP 118
21008: PUSH
21009: EMPTY
21010: ST_TO_ADDR
// mc_tech := [ ] ;
21011: LD_ADDR_EXP 120
21015: PUSH
21016: EMPTY
21017: ST_TO_ADDR
// mc_class := [ ] ;
21018: LD_ADDR_EXP 134
21022: PUSH
21023: EMPTY
21024: ST_TO_ADDR
// mc_class_case_use := [ ] ;
21025: LD_ADDR_EXP 135
21029: PUSH
21030: EMPTY
21031: ST_TO_ADDR
// mc_is_defending := [ ] ;
21032: LD_ADDR_EXP 136
21036: PUSH
21037: EMPTY
21038: ST_TO_ADDR
// end ;
21039: LD_VAR 0 1
21043: RET
// export function MC_Kill ( base ) ; begin
21044: LD_INT 0
21046: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
21047: LD_ADDR_EXP 93
21051: PUSH
21052: LD_EXP 93
21056: PPUSH
21057: LD_VAR 0 1
21061: PPUSH
21062: EMPTY
21063: PPUSH
21064: CALL_OW 1
21068: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
21069: LD_ADDR_EXP 94
21073: PUSH
21074: LD_EXP 94
21078: PPUSH
21079: LD_VAR 0 1
21083: PPUSH
21084: EMPTY
21085: PPUSH
21086: CALL_OW 1
21090: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
21091: LD_ADDR_EXP 95
21095: PUSH
21096: LD_EXP 95
21100: PPUSH
21101: LD_VAR 0 1
21105: PPUSH
21106: EMPTY
21107: PPUSH
21108: CALL_OW 1
21112: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
21113: LD_ADDR_EXP 96
21117: PUSH
21118: LD_EXP 96
21122: PPUSH
21123: LD_VAR 0 1
21127: PPUSH
21128: EMPTY
21129: PPUSH
21130: CALL_OW 1
21134: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
21135: LD_ADDR_EXP 97
21139: PUSH
21140: LD_EXP 97
21144: PPUSH
21145: LD_VAR 0 1
21149: PPUSH
21150: EMPTY
21151: PPUSH
21152: CALL_OW 1
21156: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
21157: LD_ADDR_EXP 98
21161: PUSH
21162: LD_EXP 98
21166: PPUSH
21167: LD_VAR 0 1
21171: PPUSH
21172: EMPTY
21173: PPUSH
21174: CALL_OW 1
21178: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
21179: LD_ADDR_EXP 99
21183: PUSH
21184: LD_EXP 99
21188: PPUSH
21189: LD_VAR 0 1
21193: PPUSH
21194: EMPTY
21195: PPUSH
21196: CALL_OW 1
21200: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
21201: LD_ADDR_EXP 100
21205: PUSH
21206: LD_EXP 100
21210: PPUSH
21211: LD_VAR 0 1
21215: PPUSH
21216: EMPTY
21217: PPUSH
21218: CALL_OW 1
21222: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
21223: LD_ADDR_EXP 101
21227: PUSH
21228: LD_EXP 101
21232: PPUSH
21233: LD_VAR 0 1
21237: PPUSH
21238: EMPTY
21239: PPUSH
21240: CALL_OW 1
21244: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
21245: LD_ADDR_EXP 102
21249: PUSH
21250: LD_EXP 102
21254: PPUSH
21255: LD_VAR 0 1
21259: PPUSH
21260: EMPTY
21261: PPUSH
21262: CALL_OW 1
21266: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
21267: LD_ADDR_EXP 103
21271: PUSH
21272: LD_EXP 103
21276: PPUSH
21277: LD_VAR 0 1
21281: PPUSH
21282: EMPTY
21283: PPUSH
21284: CALL_OW 1
21288: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
21289: LD_ADDR_EXP 104
21293: PUSH
21294: LD_EXP 104
21298: PPUSH
21299: LD_VAR 0 1
21303: PPUSH
21304: LD_INT 0
21306: PPUSH
21307: CALL_OW 1
21311: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21312: LD_ADDR_EXP 105
21316: PUSH
21317: LD_EXP 105
21321: PPUSH
21322: LD_VAR 0 1
21326: PPUSH
21327: EMPTY
21328: PPUSH
21329: CALL_OW 1
21333: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21334: LD_ADDR_EXP 106
21338: PUSH
21339: LD_EXP 106
21343: PPUSH
21344: LD_VAR 0 1
21348: PPUSH
21349: EMPTY
21350: PPUSH
21351: CALL_OW 1
21355: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
21356: LD_ADDR_EXP 107
21360: PUSH
21361: LD_EXP 107
21365: PPUSH
21366: LD_VAR 0 1
21370: PPUSH
21371: EMPTY
21372: PPUSH
21373: CALL_OW 1
21377: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
21378: LD_ADDR_EXP 108
21382: PUSH
21383: LD_EXP 108
21387: PPUSH
21388: LD_VAR 0 1
21392: PPUSH
21393: EMPTY
21394: PPUSH
21395: CALL_OW 1
21399: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
21400: LD_ADDR_EXP 109
21404: PUSH
21405: LD_EXP 109
21409: PPUSH
21410: LD_VAR 0 1
21414: PPUSH
21415: EMPTY
21416: PPUSH
21417: CALL_OW 1
21421: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
21422: LD_ADDR_EXP 110
21426: PUSH
21427: LD_EXP 110
21431: PPUSH
21432: LD_VAR 0 1
21436: PPUSH
21437: EMPTY
21438: PPUSH
21439: CALL_OW 1
21443: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
21444: LD_ADDR_EXP 111
21448: PUSH
21449: LD_EXP 111
21453: PPUSH
21454: LD_VAR 0 1
21458: PPUSH
21459: EMPTY
21460: PPUSH
21461: CALL_OW 1
21465: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
21466: LD_ADDR_EXP 112
21470: PUSH
21471: LD_EXP 112
21475: PPUSH
21476: LD_VAR 0 1
21480: PPUSH
21481: EMPTY
21482: PPUSH
21483: CALL_OW 1
21487: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
21488: LD_ADDR_EXP 113
21492: PUSH
21493: LD_EXP 113
21497: PPUSH
21498: LD_VAR 0 1
21502: PPUSH
21503: EMPTY
21504: PPUSH
21505: CALL_OW 1
21509: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
21510: LD_ADDR_EXP 114
21514: PUSH
21515: LD_EXP 114
21519: PPUSH
21520: LD_VAR 0 1
21524: PPUSH
21525: EMPTY
21526: PPUSH
21527: CALL_OW 1
21531: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
21532: LD_ADDR_EXP 115
21536: PUSH
21537: LD_EXP 115
21541: PPUSH
21542: LD_VAR 0 1
21546: PPUSH
21547: EMPTY
21548: PPUSH
21549: CALL_OW 1
21553: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
21554: LD_ADDR_EXP 116
21558: PUSH
21559: LD_EXP 116
21563: PPUSH
21564: LD_VAR 0 1
21568: PPUSH
21569: EMPTY
21570: PPUSH
21571: CALL_OW 1
21575: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
21576: LD_ADDR_EXP 117
21580: PUSH
21581: LD_EXP 117
21585: PPUSH
21586: LD_VAR 0 1
21590: PPUSH
21591: EMPTY
21592: PPUSH
21593: CALL_OW 1
21597: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
21598: LD_ADDR_EXP 118
21602: PUSH
21603: LD_EXP 118
21607: PPUSH
21608: LD_VAR 0 1
21612: PPUSH
21613: EMPTY
21614: PPUSH
21615: CALL_OW 1
21619: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
21620: LD_ADDR_EXP 120
21624: PUSH
21625: LD_EXP 120
21629: PPUSH
21630: LD_VAR 0 1
21634: PPUSH
21635: EMPTY
21636: PPUSH
21637: CALL_OW 1
21641: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
21642: LD_ADDR_EXP 122
21646: PUSH
21647: LD_EXP 122
21651: PPUSH
21652: LD_VAR 0 1
21656: PPUSH
21657: EMPTY
21658: PPUSH
21659: CALL_OW 1
21663: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
21664: LD_ADDR_EXP 123
21668: PUSH
21669: LD_EXP 123
21673: PPUSH
21674: LD_VAR 0 1
21678: PPUSH
21679: EMPTY
21680: PPUSH
21681: CALL_OW 1
21685: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
21686: LD_ADDR_EXP 124
21690: PUSH
21691: LD_EXP 124
21695: PPUSH
21696: LD_VAR 0 1
21700: PPUSH
21701: EMPTY
21702: PPUSH
21703: CALL_OW 1
21707: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
21708: LD_ADDR_EXP 125
21712: PUSH
21713: LD_EXP 125
21717: PPUSH
21718: LD_VAR 0 1
21722: PPUSH
21723: EMPTY
21724: PPUSH
21725: CALL_OW 1
21729: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
21730: LD_ADDR_EXP 126
21734: PUSH
21735: LD_EXP 126
21739: PPUSH
21740: LD_VAR 0 1
21744: PPUSH
21745: EMPTY
21746: PPUSH
21747: CALL_OW 1
21751: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
21752: LD_ADDR_EXP 127
21756: PUSH
21757: LD_EXP 127
21761: PPUSH
21762: LD_VAR 0 1
21766: PPUSH
21767: EMPTY
21768: PPUSH
21769: CALL_OW 1
21773: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
21774: LD_ADDR_EXP 128
21778: PUSH
21779: LD_EXP 128
21783: PPUSH
21784: LD_VAR 0 1
21788: PPUSH
21789: EMPTY
21790: PPUSH
21791: CALL_OW 1
21795: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
21796: LD_ADDR_EXP 129
21800: PUSH
21801: LD_EXP 129
21805: PPUSH
21806: LD_VAR 0 1
21810: PPUSH
21811: EMPTY
21812: PPUSH
21813: CALL_OW 1
21817: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
21818: LD_ADDR_EXP 130
21822: PUSH
21823: LD_EXP 130
21827: PPUSH
21828: LD_VAR 0 1
21832: PPUSH
21833: EMPTY
21834: PPUSH
21835: CALL_OW 1
21839: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
21840: LD_ADDR_EXP 131
21844: PUSH
21845: LD_EXP 131
21849: PPUSH
21850: LD_VAR 0 1
21854: PPUSH
21855: EMPTY
21856: PPUSH
21857: CALL_OW 1
21861: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
21862: LD_ADDR_EXP 132
21866: PUSH
21867: LD_EXP 132
21871: PPUSH
21872: LD_VAR 0 1
21876: PPUSH
21877: EMPTY
21878: PPUSH
21879: CALL_OW 1
21883: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
21884: LD_ADDR_EXP 133
21888: PUSH
21889: LD_EXP 133
21893: PPUSH
21894: LD_VAR 0 1
21898: PPUSH
21899: EMPTY
21900: PPUSH
21901: CALL_OW 1
21905: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
21906: LD_ADDR_EXP 134
21910: PUSH
21911: LD_EXP 134
21915: PPUSH
21916: LD_VAR 0 1
21920: PPUSH
21921: EMPTY
21922: PPUSH
21923: CALL_OW 1
21927: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
21928: LD_ADDR_EXP 135
21932: PUSH
21933: LD_EXP 135
21937: PPUSH
21938: LD_VAR 0 1
21942: PPUSH
21943: LD_INT 0
21945: PPUSH
21946: CALL_OW 1
21950: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
21951: LD_ADDR_EXP 136
21955: PUSH
21956: LD_EXP 136
21960: PPUSH
21961: LD_VAR 0 1
21965: PPUSH
21966: LD_INT 0
21968: PPUSH
21969: CALL_OW 1
21973: ST_TO_ADDR
// end ;
21974: LD_VAR 0 2
21978: RET
// export function MC_Add ( side , units ) ; var base ; begin
21979: LD_INT 0
21981: PPUSH
21982: PPUSH
// base := mc_bases + 1 ;
21983: LD_ADDR_VAR 0 4
21987: PUSH
21988: LD_EXP 93
21992: PUSH
21993: LD_INT 1
21995: PLUS
21996: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
21997: LD_ADDR_EXP 119
22001: PUSH
22002: LD_EXP 119
22006: PPUSH
22007: LD_VAR 0 4
22011: PPUSH
22012: LD_VAR 0 1
22016: PPUSH
22017: CALL_OW 1
22021: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
22022: LD_ADDR_EXP 93
22026: PUSH
22027: LD_EXP 93
22031: PPUSH
22032: LD_VAR 0 4
22036: PPUSH
22037: LD_VAR 0 2
22041: PPUSH
22042: CALL_OW 1
22046: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
22047: LD_ADDR_EXP 94
22051: PUSH
22052: LD_EXP 94
22056: PPUSH
22057: LD_VAR 0 4
22061: PPUSH
22062: EMPTY
22063: PPUSH
22064: CALL_OW 1
22068: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
22069: LD_ADDR_EXP 95
22073: PUSH
22074: LD_EXP 95
22078: PPUSH
22079: LD_VAR 0 4
22083: PPUSH
22084: EMPTY
22085: PPUSH
22086: CALL_OW 1
22090: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
22091: LD_ADDR_EXP 96
22095: PUSH
22096: LD_EXP 96
22100: PPUSH
22101: LD_VAR 0 4
22105: PPUSH
22106: EMPTY
22107: PPUSH
22108: CALL_OW 1
22112: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
22113: LD_ADDR_EXP 97
22117: PUSH
22118: LD_EXP 97
22122: PPUSH
22123: LD_VAR 0 4
22127: PPUSH
22128: EMPTY
22129: PPUSH
22130: CALL_OW 1
22134: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
22135: LD_ADDR_EXP 98
22139: PUSH
22140: LD_EXP 98
22144: PPUSH
22145: LD_VAR 0 4
22149: PPUSH
22150: EMPTY
22151: PPUSH
22152: CALL_OW 1
22156: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
22157: LD_ADDR_EXP 99
22161: PUSH
22162: LD_EXP 99
22166: PPUSH
22167: LD_VAR 0 4
22171: PPUSH
22172: EMPTY
22173: PPUSH
22174: CALL_OW 1
22178: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
22179: LD_ADDR_EXP 100
22183: PUSH
22184: LD_EXP 100
22188: PPUSH
22189: LD_VAR 0 4
22193: PPUSH
22194: EMPTY
22195: PPUSH
22196: CALL_OW 1
22200: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
22201: LD_ADDR_EXP 101
22205: PUSH
22206: LD_EXP 101
22210: PPUSH
22211: LD_VAR 0 4
22215: PPUSH
22216: EMPTY
22217: PPUSH
22218: CALL_OW 1
22222: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
22223: LD_ADDR_EXP 102
22227: PUSH
22228: LD_EXP 102
22232: PPUSH
22233: LD_VAR 0 4
22237: PPUSH
22238: EMPTY
22239: PPUSH
22240: CALL_OW 1
22244: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
22245: LD_ADDR_EXP 103
22249: PUSH
22250: LD_EXP 103
22254: PPUSH
22255: LD_VAR 0 4
22259: PPUSH
22260: EMPTY
22261: PPUSH
22262: CALL_OW 1
22266: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
22267: LD_ADDR_EXP 104
22271: PUSH
22272: LD_EXP 104
22276: PPUSH
22277: LD_VAR 0 4
22281: PPUSH
22282: LD_INT 0
22284: PPUSH
22285: CALL_OW 1
22289: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
22290: LD_ADDR_EXP 105
22294: PUSH
22295: LD_EXP 105
22299: PPUSH
22300: LD_VAR 0 4
22304: PPUSH
22305: EMPTY
22306: PPUSH
22307: CALL_OW 1
22311: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
22312: LD_ADDR_EXP 106
22316: PUSH
22317: LD_EXP 106
22321: PPUSH
22322: LD_VAR 0 4
22326: PPUSH
22327: EMPTY
22328: PPUSH
22329: CALL_OW 1
22333: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
22334: LD_ADDR_EXP 107
22338: PUSH
22339: LD_EXP 107
22343: PPUSH
22344: LD_VAR 0 4
22348: PPUSH
22349: EMPTY
22350: PPUSH
22351: CALL_OW 1
22355: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
22356: LD_ADDR_EXP 108
22360: PUSH
22361: LD_EXP 108
22365: PPUSH
22366: LD_VAR 0 4
22370: PPUSH
22371: EMPTY
22372: PPUSH
22373: CALL_OW 1
22377: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
22378: LD_ADDR_EXP 109
22382: PUSH
22383: LD_EXP 109
22387: PPUSH
22388: LD_VAR 0 4
22392: PPUSH
22393: EMPTY
22394: PPUSH
22395: CALL_OW 1
22399: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
22400: LD_ADDR_EXP 110
22404: PUSH
22405: LD_EXP 110
22409: PPUSH
22410: LD_VAR 0 4
22414: PPUSH
22415: EMPTY
22416: PPUSH
22417: CALL_OW 1
22421: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
22422: LD_ADDR_EXP 111
22426: PUSH
22427: LD_EXP 111
22431: PPUSH
22432: LD_VAR 0 4
22436: PPUSH
22437: EMPTY
22438: PPUSH
22439: CALL_OW 1
22443: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
22444: LD_ADDR_EXP 112
22448: PUSH
22449: LD_EXP 112
22453: PPUSH
22454: LD_VAR 0 4
22458: PPUSH
22459: EMPTY
22460: PPUSH
22461: CALL_OW 1
22465: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
22466: LD_ADDR_EXP 113
22470: PUSH
22471: LD_EXP 113
22475: PPUSH
22476: LD_VAR 0 4
22480: PPUSH
22481: EMPTY
22482: PPUSH
22483: CALL_OW 1
22487: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
22488: LD_ADDR_EXP 114
22492: PUSH
22493: LD_EXP 114
22497: PPUSH
22498: LD_VAR 0 4
22502: PPUSH
22503: EMPTY
22504: PPUSH
22505: CALL_OW 1
22509: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
22510: LD_ADDR_EXP 115
22514: PUSH
22515: LD_EXP 115
22519: PPUSH
22520: LD_VAR 0 4
22524: PPUSH
22525: EMPTY
22526: PPUSH
22527: CALL_OW 1
22531: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
22532: LD_ADDR_EXP 116
22536: PUSH
22537: LD_EXP 116
22541: PPUSH
22542: LD_VAR 0 4
22546: PPUSH
22547: EMPTY
22548: PPUSH
22549: CALL_OW 1
22553: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
22554: LD_ADDR_EXP 117
22558: PUSH
22559: LD_EXP 117
22563: PPUSH
22564: LD_VAR 0 4
22568: PPUSH
22569: EMPTY
22570: PPUSH
22571: CALL_OW 1
22575: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
22576: LD_ADDR_EXP 118
22580: PUSH
22581: LD_EXP 118
22585: PPUSH
22586: LD_VAR 0 4
22590: PPUSH
22591: EMPTY
22592: PPUSH
22593: CALL_OW 1
22597: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
22598: LD_ADDR_EXP 120
22602: PUSH
22603: LD_EXP 120
22607: PPUSH
22608: LD_VAR 0 4
22612: PPUSH
22613: EMPTY
22614: PPUSH
22615: CALL_OW 1
22619: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
22620: LD_ADDR_EXP 122
22624: PUSH
22625: LD_EXP 122
22629: PPUSH
22630: LD_VAR 0 4
22634: PPUSH
22635: EMPTY
22636: PPUSH
22637: CALL_OW 1
22641: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
22642: LD_ADDR_EXP 123
22646: PUSH
22647: LD_EXP 123
22651: PPUSH
22652: LD_VAR 0 4
22656: PPUSH
22657: EMPTY
22658: PPUSH
22659: CALL_OW 1
22663: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
22664: LD_ADDR_EXP 124
22668: PUSH
22669: LD_EXP 124
22673: PPUSH
22674: LD_VAR 0 4
22678: PPUSH
22679: EMPTY
22680: PPUSH
22681: CALL_OW 1
22685: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
22686: LD_ADDR_EXP 125
22690: PUSH
22691: LD_EXP 125
22695: PPUSH
22696: LD_VAR 0 4
22700: PPUSH
22701: EMPTY
22702: PPUSH
22703: CALL_OW 1
22707: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
22708: LD_ADDR_EXP 126
22712: PUSH
22713: LD_EXP 126
22717: PPUSH
22718: LD_VAR 0 4
22722: PPUSH
22723: EMPTY
22724: PPUSH
22725: CALL_OW 1
22729: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
22730: LD_ADDR_EXP 127
22734: PUSH
22735: LD_EXP 127
22739: PPUSH
22740: LD_VAR 0 4
22744: PPUSH
22745: EMPTY
22746: PPUSH
22747: CALL_OW 1
22751: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
22752: LD_ADDR_EXP 128
22756: PUSH
22757: LD_EXP 128
22761: PPUSH
22762: LD_VAR 0 4
22766: PPUSH
22767: EMPTY
22768: PPUSH
22769: CALL_OW 1
22773: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
22774: LD_ADDR_EXP 129
22778: PUSH
22779: LD_EXP 129
22783: PPUSH
22784: LD_VAR 0 4
22788: PPUSH
22789: EMPTY
22790: PPUSH
22791: CALL_OW 1
22795: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
22796: LD_ADDR_EXP 130
22800: PUSH
22801: LD_EXP 130
22805: PPUSH
22806: LD_VAR 0 4
22810: PPUSH
22811: EMPTY
22812: PPUSH
22813: CALL_OW 1
22817: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
22818: LD_ADDR_EXP 131
22822: PUSH
22823: LD_EXP 131
22827: PPUSH
22828: LD_VAR 0 4
22832: PPUSH
22833: EMPTY
22834: PPUSH
22835: CALL_OW 1
22839: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
22840: LD_ADDR_EXP 132
22844: PUSH
22845: LD_EXP 132
22849: PPUSH
22850: LD_VAR 0 4
22854: PPUSH
22855: EMPTY
22856: PPUSH
22857: CALL_OW 1
22861: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
22862: LD_ADDR_EXP 133
22866: PUSH
22867: LD_EXP 133
22871: PPUSH
22872: LD_VAR 0 4
22876: PPUSH
22877: EMPTY
22878: PPUSH
22879: CALL_OW 1
22883: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
22884: LD_ADDR_EXP 134
22888: PUSH
22889: LD_EXP 134
22893: PPUSH
22894: LD_VAR 0 4
22898: PPUSH
22899: EMPTY
22900: PPUSH
22901: CALL_OW 1
22905: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
22906: LD_ADDR_EXP 135
22910: PUSH
22911: LD_EXP 135
22915: PPUSH
22916: LD_VAR 0 4
22920: PPUSH
22921: LD_INT 0
22923: PPUSH
22924: CALL_OW 1
22928: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
22929: LD_ADDR_EXP 136
22933: PUSH
22934: LD_EXP 136
22938: PPUSH
22939: LD_VAR 0 4
22943: PPUSH
22944: LD_INT 0
22946: PPUSH
22947: CALL_OW 1
22951: ST_TO_ADDR
// result := base ;
22952: LD_ADDR_VAR 0 3
22956: PUSH
22957: LD_VAR 0 4
22961: ST_TO_ADDR
// end ;
22962: LD_VAR 0 3
22966: RET
// export function MC_Start ( ) ; var i ; begin
22967: LD_INT 0
22969: PPUSH
22970: PPUSH
// for i = 1 to mc_bases do
22971: LD_ADDR_VAR 0 2
22975: PUSH
22976: DOUBLE
22977: LD_INT 1
22979: DEC
22980: ST_TO_ADDR
22981: LD_EXP 93
22985: PUSH
22986: FOR_TO
22987: IFFALSE 24087
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
22989: LD_ADDR_EXP 93
22993: PUSH
22994: LD_EXP 93
22998: PPUSH
22999: LD_VAR 0 2
23003: PPUSH
23004: LD_EXP 93
23008: PUSH
23009: LD_VAR 0 2
23013: ARRAY
23014: PUSH
23015: LD_INT 0
23017: DIFF
23018: PPUSH
23019: CALL_OW 1
23023: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
23024: LD_ADDR_EXP 94
23028: PUSH
23029: LD_EXP 94
23033: PPUSH
23034: LD_VAR 0 2
23038: PPUSH
23039: EMPTY
23040: PPUSH
23041: CALL_OW 1
23045: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
23046: LD_ADDR_EXP 95
23050: PUSH
23051: LD_EXP 95
23055: PPUSH
23056: LD_VAR 0 2
23060: PPUSH
23061: EMPTY
23062: PPUSH
23063: CALL_OW 1
23067: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
23068: LD_ADDR_EXP 96
23072: PUSH
23073: LD_EXP 96
23077: PPUSH
23078: LD_VAR 0 2
23082: PPUSH
23083: EMPTY
23084: PPUSH
23085: CALL_OW 1
23089: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
23090: LD_ADDR_EXP 97
23094: PUSH
23095: LD_EXP 97
23099: PPUSH
23100: LD_VAR 0 2
23104: PPUSH
23105: EMPTY
23106: PUSH
23107: EMPTY
23108: PUSH
23109: EMPTY
23110: LIST
23111: LIST
23112: PPUSH
23113: CALL_OW 1
23117: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
23118: LD_ADDR_EXP 98
23122: PUSH
23123: LD_EXP 98
23127: PPUSH
23128: LD_VAR 0 2
23132: PPUSH
23133: EMPTY
23134: PPUSH
23135: CALL_OW 1
23139: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
23140: LD_ADDR_EXP 125
23144: PUSH
23145: LD_EXP 125
23149: PPUSH
23150: LD_VAR 0 2
23154: PPUSH
23155: EMPTY
23156: PPUSH
23157: CALL_OW 1
23161: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
23162: LD_ADDR_EXP 99
23166: PUSH
23167: LD_EXP 99
23171: PPUSH
23172: LD_VAR 0 2
23176: PPUSH
23177: EMPTY
23178: PPUSH
23179: CALL_OW 1
23183: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
23184: LD_ADDR_EXP 100
23188: PUSH
23189: LD_EXP 100
23193: PPUSH
23194: LD_VAR 0 2
23198: PPUSH
23199: EMPTY
23200: PPUSH
23201: CALL_OW 1
23205: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
23206: LD_ADDR_EXP 101
23210: PUSH
23211: LD_EXP 101
23215: PPUSH
23216: LD_VAR 0 2
23220: PPUSH
23221: LD_EXP 93
23225: PUSH
23226: LD_VAR 0 2
23230: ARRAY
23231: PPUSH
23232: LD_INT 2
23234: PUSH
23235: LD_INT 30
23237: PUSH
23238: LD_INT 32
23240: PUSH
23241: EMPTY
23242: LIST
23243: LIST
23244: PUSH
23245: LD_INT 30
23247: PUSH
23248: LD_INT 33
23250: PUSH
23251: EMPTY
23252: LIST
23253: LIST
23254: PUSH
23255: EMPTY
23256: LIST
23257: LIST
23258: LIST
23259: PPUSH
23260: CALL_OW 72
23264: PPUSH
23265: CALL_OW 1
23269: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
23270: LD_ADDR_EXP 102
23274: PUSH
23275: LD_EXP 102
23279: PPUSH
23280: LD_VAR 0 2
23284: PPUSH
23285: LD_EXP 93
23289: PUSH
23290: LD_VAR 0 2
23294: ARRAY
23295: PPUSH
23296: LD_INT 2
23298: PUSH
23299: LD_INT 30
23301: PUSH
23302: LD_INT 32
23304: PUSH
23305: EMPTY
23306: LIST
23307: LIST
23308: PUSH
23309: LD_INT 30
23311: PUSH
23312: LD_INT 31
23314: PUSH
23315: EMPTY
23316: LIST
23317: LIST
23318: PUSH
23319: EMPTY
23320: LIST
23321: LIST
23322: LIST
23323: PUSH
23324: LD_INT 58
23326: PUSH
23327: EMPTY
23328: LIST
23329: PUSH
23330: EMPTY
23331: LIST
23332: LIST
23333: PPUSH
23334: CALL_OW 72
23338: PPUSH
23339: CALL_OW 1
23343: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
23344: LD_ADDR_EXP 103
23348: PUSH
23349: LD_EXP 103
23353: PPUSH
23354: LD_VAR 0 2
23358: PPUSH
23359: EMPTY
23360: PPUSH
23361: CALL_OW 1
23365: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
23366: LD_ADDR_EXP 107
23370: PUSH
23371: LD_EXP 107
23375: PPUSH
23376: LD_VAR 0 2
23380: PPUSH
23381: EMPTY
23382: PPUSH
23383: CALL_OW 1
23387: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
23388: LD_ADDR_EXP 106
23392: PUSH
23393: LD_EXP 106
23397: PPUSH
23398: LD_VAR 0 2
23402: PPUSH
23403: EMPTY
23404: PPUSH
23405: CALL_OW 1
23409: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
23410: LD_ADDR_EXP 108
23414: PUSH
23415: LD_EXP 108
23419: PPUSH
23420: LD_VAR 0 2
23424: PPUSH
23425: EMPTY
23426: PPUSH
23427: CALL_OW 1
23431: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
23432: LD_ADDR_EXP 109
23436: PUSH
23437: LD_EXP 109
23441: PPUSH
23442: LD_VAR 0 2
23446: PPUSH
23447: EMPTY
23448: PPUSH
23449: CALL_OW 1
23453: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
23454: LD_ADDR_EXP 110
23458: PUSH
23459: LD_EXP 110
23463: PPUSH
23464: LD_VAR 0 2
23468: PPUSH
23469: EMPTY
23470: PPUSH
23471: CALL_OW 1
23475: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
23476: LD_ADDR_EXP 111
23480: PUSH
23481: LD_EXP 111
23485: PPUSH
23486: LD_VAR 0 2
23490: PPUSH
23491: EMPTY
23492: PPUSH
23493: CALL_OW 1
23497: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
23498: LD_ADDR_EXP 112
23502: PUSH
23503: LD_EXP 112
23507: PPUSH
23508: LD_VAR 0 2
23512: PPUSH
23513: EMPTY
23514: PPUSH
23515: CALL_OW 1
23519: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
23520: LD_ADDR_EXP 113
23524: PUSH
23525: LD_EXP 113
23529: PPUSH
23530: LD_VAR 0 2
23534: PPUSH
23535: EMPTY
23536: PPUSH
23537: CALL_OW 1
23541: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
23542: LD_ADDR_EXP 114
23546: PUSH
23547: LD_EXP 114
23551: PPUSH
23552: LD_VAR 0 2
23556: PPUSH
23557: EMPTY
23558: PPUSH
23559: CALL_OW 1
23563: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
23564: LD_ADDR_EXP 115
23568: PUSH
23569: LD_EXP 115
23573: PPUSH
23574: LD_VAR 0 2
23578: PPUSH
23579: EMPTY
23580: PPUSH
23581: CALL_OW 1
23585: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
23586: LD_ADDR_EXP 104
23590: PUSH
23591: LD_EXP 104
23595: PPUSH
23596: LD_VAR 0 2
23600: PPUSH
23601: LD_INT 0
23603: PPUSH
23604: CALL_OW 1
23608: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
23609: LD_ADDR_EXP 117
23613: PUSH
23614: LD_EXP 117
23618: PPUSH
23619: LD_VAR 0 2
23623: PPUSH
23624: LD_INT 0
23626: PPUSH
23627: CALL_OW 1
23631: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
23632: LD_ADDR_EXP 105
23636: PUSH
23637: LD_EXP 105
23641: PPUSH
23642: LD_VAR 0 2
23646: PPUSH
23647: EMPTY
23648: PPUSH
23649: CALL_OW 1
23653: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
23654: LD_ADDR_EXP 116
23658: PUSH
23659: LD_EXP 116
23663: PPUSH
23664: LD_VAR 0 2
23668: PPUSH
23669: LD_INT 0
23671: PPUSH
23672: CALL_OW 1
23676: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
23677: LD_ADDR_EXP 118
23681: PUSH
23682: LD_EXP 118
23686: PPUSH
23687: LD_VAR 0 2
23691: PPUSH
23692: EMPTY
23693: PPUSH
23694: CALL_OW 1
23698: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
23699: LD_ADDR_EXP 121
23703: PUSH
23704: LD_EXP 121
23708: PPUSH
23709: LD_VAR 0 2
23713: PPUSH
23714: LD_INT 0
23716: PPUSH
23717: CALL_OW 1
23721: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
23722: LD_ADDR_EXP 122
23726: PUSH
23727: LD_EXP 122
23731: PPUSH
23732: LD_VAR 0 2
23736: PPUSH
23737: EMPTY
23738: PPUSH
23739: CALL_OW 1
23743: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
23744: LD_ADDR_EXP 123
23748: PUSH
23749: LD_EXP 123
23753: PPUSH
23754: LD_VAR 0 2
23758: PPUSH
23759: EMPTY
23760: PPUSH
23761: CALL_OW 1
23765: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
23766: LD_ADDR_EXP 124
23770: PUSH
23771: LD_EXP 124
23775: PPUSH
23776: LD_VAR 0 2
23780: PPUSH
23781: EMPTY
23782: PPUSH
23783: CALL_OW 1
23787: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
23788: LD_ADDR_EXP 126
23792: PUSH
23793: LD_EXP 126
23797: PPUSH
23798: LD_VAR 0 2
23802: PPUSH
23803: LD_EXP 93
23807: PUSH
23808: LD_VAR 0 2
23812: ARRAY
23813: PPUSH
23814: LD_INT 2
23816: PUSH
23817: LD_INT 30
23819: PUSH
23820: LD_INT 6
23822: PUSH
23823: EMPTY
23824: LIST
23825: LIST
23826: PUSH
23827: LD_INT 30
23829: PUSH
23830: LD_INT 7
23832: PUSH
23833: EMPTY
23834: LIST
23835: LIST
23836: PUSH
23837: LD_INT 30
23839: PUSH
23840: LD_INT 8
23842: PUSH
23843: EMPTY
23844: LIST
23845: LIST
23846: PUSH
23847: EMPTY
23848: LIST
23849: LIST
23850: LIST
23851: LIST
23852: PPUSH
23853: CALL_OW 72
23857: PPUSH
23858: CALL_OW 1
23862: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
23863: LD_ADDR_EXP 127
23867: PUSH
23868: LD_EXP 127
23872: PPUSH
23873: LD_VAR 0 2
23877: PPUSH
23878: EMPTY
23879: PPUSH
23880: CALL_OW 1
23884: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
23885: LD_ADDR_EXP 128
23889: PUSH
23890: LD_EXP 128
23894: PPUSH
23895: LD_VAR 0 2
23899: PPUSH
23900: EMPTY
23901: PPUSH
23902: CALL_OW 1
23906: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
23907: LD_ADDR_EXP 129
23911: PUSH
23912: LD_EXP 129
23916: PPUSH
23917: LD_VAR 0 2
23921: PPUSH
23922: EMPTY
23923: PPUSH
23924: CALL_OW 1
23928: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
23929: LD_ADDR_EXP 130
23933: PUSH
23934: LD_EXP 130
23938: PPUSH
23939: LD_VAR 0 2
23943: PPUSH
23944: EMPTY
23945: PPUSH
23946: CALL_OW 1
23950: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
23951: LD_ADDR_EXP 131
23955: PUSH
23956: LD_EXP 131
23960: PPUSH
23961: LD_VAR 0 2
23965: PPUSH
23966: EMPTY
23967: PPUSH
23968: CALL_OW 1
23972: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
23973: LD_ADDR_EXP 132
23977: PUSH
23978: LD_EXP 132
23982: PPUSH
23983: LD_VAR 0 2
23987: PPUSH
23988: EMPTY
23989: PPUSH
23990: CALL_OW 1
23994: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
23995: LD_ADDR_EXP 133
23999: PUSH
24000: LD_EXP 133
24004: PPUSH
24005: LD_VAR 0 2
24009: PPUSH
24010: EMPTY
24011: PPUSH
24012: CALL_OW 1
24016: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
24017: LD_ADDR_EXP 134
24021: PUSH
24022: LD_EXP 134
24026: PPUSH
24027: LD_VAR 0 2
24031: PPUSH
24032: EMPTY
24033: PPUSH
24034: CALL_OW 1
24038: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
24039: LD_ADDR_EXP 135
24043: PUSH
24044: LD_EXP 135
24048: PPUSH
24049: LD_VAR 0 2
24053: PPUSH
24054: LD_INT 0
24056: PPUSH
24057: CALL_OW 1
24061: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
24062: LD_ADDR_EXP 136
24066: PUSH
24067: LD_EXP 136
24071: PPUSH
24072: LD_VAR 0 2
24076: PPUSH
24077: LD_INT 0
24079: PPUSH
24080: CALL_OW 1
24084: ST_TO_ADDR
// end ;
24085: GO 22986
24087: POP
24088: POP
// MC_InitSides ( ) ;
24089: CALL 24375 0 0
// MC_InitResearch ( ) ;
24093: CALL 24114 0 0
// CustomInitMacro ( ) ;
24097: CALL 217 0 0
// skirmish := true ;
24101: LD_ADDR_EXP 91
24105: PUSH
24106: LD_INT 1
24108: ST_TO_ADDR
// end ;
24109: LD_VAR 0 1
24113: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
24114: LD_INT 0
24116: PPUSH
24117: PPUSH
24118: PPUSH
24119: PPUSH
24120: PPUSH
24121: PPUSH
// if not mc_bases then
24122: LD_EXP 93
24126: NOT
24127: IFFALSE 24131
// exit ;
24129: GO 24370
// for i = 1 to 8 do
24131: LD_ADDR_VAR 0 2
24135: PUSH
24136: DOUBLE
24137: LD_INT 1
24139: DEC
24140: ST_TO_ADDR
24141: LD_INT 8
24143: PUSH
24144: FOR_TO
24145: IFFALSE 24171
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
24147: LD_ADDR_EXP 120
24151: PUSH
24152: LD_EXP 120
24156: PPUSH
24157: LD_VAR 0 2
24161: PPUSH
24162: EMPTY
24163: PPUSH
24164: CALL_OW 1
24168: ST_TO_ADDR
24169: GO 24144
24171: POP
24172: POP
// tmp := [ ] ;
24173: LD_ADDR_VAR 0 5
24177: PUSH
24178: EMPTY
24179: ST_TO_ADDR
// for i = 1 to mc_sides do
24180: LD_ADDR_VAR 0 2
24184: PUSH
24185: DOUBLE
24186: LD_INT 1
24188: DEC
24189: ST_TO_ADDR
24190: LD_EXP 119
24194: PUSH
24195: FOR_TO
24196: IFFALSE 24254
// if not mc_sides [ i ] in tmp then
24198: LD_EXP 119
24202: PUSH
24203: LD_VAR 0 2
24207: ARRAY
24208: PUSH
24209: LD_VAR 0 5
24213: IN
24214: NOT
24215: IFFALSE 24252
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
24217: LD_ADDR_VAR 0 5
24221: PUSH
24222: LD_VAR 0 5
24226: PPUSH
24227: LD_VAR 0 5
24231: PUSH
24232: LD_INT 1
24234: PLUS
24235: PPUSH
24236: LD_EXP 119
24240: PUSH
24241: LD_VAR 0 2
24245: ARRAY
24246: PPUSH
24247: CALL_OW 2
24251: ST_TO_ADDR
24252: GO 24195
24254: POP
24255: POP
// if not tmp then
24256: LD_VAR 0 5
24260: NOT
24261: IFFALSE 24265
// exit ;
24263: GO 24370
// for j in tmp do
24265: LD_ADDR_VAR 0 3
24269: PUSH
24270: LD_VAR 0 5
24274: PUSH
24275: FOR_IN
24276: IFFALSE 24368
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
24278: LD_ADDR_VAR 0 6
24282: PUSH
24283: LD_INT 22
24285: PUSH
24286: LD_VAR 0 3
24290: PUSH
24291: EMPTY
24292: LIST
24293: LIST
24294: PPUSH
24295: CALL_OW 69
24299: ST_TO_ADDR
// if not un then
24300: LD_VAR 0 6
24304: NOT
24305: IFFALSE 24309
// continue ;
24307: GO 24275
// nation := GetNation ( un [ 1 ] ) ;
24309: LD_ADDR_VAR 0 4
24313: PUSH
24314: LD_VAR 0 6
24318: PUSH
24319: LD_INT 1
24321: ARRAY
24322: PPUSH
24323: CALL_OW 248
24327: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
24328: LD_ADDR_EXP 120
24332: PUSH
24333: LD_EXP 120
24337: PPUSH
24338: LD_VAR 0 3
24342: PPUSH
24343: LD_VAR 0 3
24347: PPUSH
24348: LD_VAR 0 4
24352: PPUSH
24353: LD_INT 1
24355: PPUSH
24356: CALL 51275 0 3
24360: PPUSH
24361: CALL_OW 1
24365: ST_TO_ADDR
// end ;
24366: GO 24275
24368: POP
24369: POP
// end ;
24370: LD_VAR 0 1
24374: RET
// export function MC_InitSides ( ) ; var i ; begin
24375: LD_INT 0
24377: PPUSH
24378: PPUSH
// if not mc_bases then
24379: LD_EXP 93
24383: NOT
24384: IFFALSE 24388
// exit ;
24386: GO 24462
// for i = 1 to mc_bases do
24388: LD_ADDR_VAR 0 2
24392: PUSH
24393: DOUBLE
24394: LD_INT 1
24396: DEC
24397: ST_TO_ADDR
24398: LD_EXP 93
24402: PUSH
24403: FOR_TO
24404: IFFALSE 24460
// if mc_bases [ i ] then
24406: LD_EXP 93
24410: PUSH
24411: LD_VAR 0 2
24415: ARRAY
24416: IFFALSE 24458
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
24418: LD_ADDR_EXP 119
24422: PUSH
24423: LD_EXP 119
24427: PPUSH
24428: LD_VAR 0 2
24432: PPUSH
24433: LD_EXP 93
24437: PUSH
24438: LD_VAR 0 2
24442: ARRAY
24443: PUSH
24444: LD_INT 1
24446: ARRAY
24447: PPUSH
24448: CALL_OW 255
24452: PPUSH
24453: CALL_OW 1
24457: ST_TO_ADDR
24458: GO 24403
24460: POP
24461: POP
// end ;
24462: LD_VAR 0 1
24466: RET
// every 0 0$03 trigger skirmish do
24467: LD_EXP 91
24471: IFFALSE 24625
24473: GO 24475
24475: DISABLE
// begin enable ;
24476: ENABLE
// MC_CheckBuildings ( ) ;
24477: CALL 29123 0 0
// MC_CheckPeopleLife ( ) ;
24481: CALL 29248 0 0
// RaiseSailEvent ( 100 ) ;
24485: LD_INT 100
24487: PPUSH
24488: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
24492: LD_INT 103
24494: PPUSH
24495: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
24499: LD_INT 104
24501: PPUSH
24502: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
24506: LD_INT 105
24508: PPUSH
24509: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
24513: LD_INT 106
24515: PPUSH
24516: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
24520: LD_INT 107
24522: PPUSH
24523: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
24527: LD_INT 108
24529: PPUSH
24530: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
24534: LD_INT 109
24536: PPUSH
24537: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
24541: LD_INT 110
24543: PPUSH
24544: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
24548: LD_INT 111
24550: PPUSH
24551: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
24555: LD_INT 112
24557: PPUSH
24558: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
24562: LD_INT 113
24564: PPUSH
24565: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
24569: LD_INT 120
24571: PPUSH
24572: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
24576: LD_INT 121
24578: PPUSH
24579: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
24583: LD_INT 122
24585: PPUSH
24586: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
24590: LD_INT 123
24592: PPUSH
24593: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
24597: LD_INT 124
24599: PPUSH
24600: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
24604: LD_INT 125
24606: PPUSH
24607: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
24611: LD_INT 126
24613: PPUSH
24614: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
24618: LD_INT 200
24620: PPUSH
24621: CALL_OW 427
// end ;
24625: END
// on SailEvent ( event ) do begin if event < 100 then
24626: LD_VAR 0 1
24630: PUSH
24631: LD_INT 100
24633: LESS
24634: IFFALSE 24645
// CustomEvent ( event ) ;
24636: LD_VAR 0 1
24640: PPUSH
24641: CALL 10417 0 1
// if event = 100 then
24645: LD_VAR 0 1
24649: PUSH
24650: LD_INT 100
24652: EQUAL
24653: IFFALSE 24659
// MC_ClassManager ( ) ;
24655: CALL 25051 0 0
// if event = 101 then
24659: LD_VAR 0 1
24663: PUSH
24664: LD_INT 101
24666: EQUAL
24667: IFFALSE 24673
// MC_RepairBuildings ( ) ;
24669: CALL 29833 0 0
// if event = 102 then
24673: LD_VAR 0 1
24677: PUSH
24678: LD_INT 102
24680: EQUAL
24681: IFFALSE 24687
// MC_Heal ( ) ;
24683: CALL 30718 0 0
// if event = 103 then
24687: LD_VAR 0 1
24691: PUSH
24692: LD_INT 103
24694: EQUAL
24695: IFFALSE 24701
// MC_Build ( ) ;
24697: CALL 31140 0 0
// if event = 104 then
24701: LD_VAR 0 1
24705: PUSH
24706: LD_INT 104
24708: EQUAL
24709: IFFALSE 24715
// MC_TurretWeapon ( ) ;
24711: CALL 32781 0 0
// if event = 105 then
24715: LD_VAR 0 1
24719: PUSH
24720: LD_INT 105
24722: EQUAL
24723: IFFALSE 24729
// MC_BuildUpgrade ( ) ;
24725: CALL 32332 0 0
// if event = 106 then
24729: LD_VAR 0 1
24733: PUSH
24734: LD_INT 106
24736: EQUAL
24737: IFFALSE 24743
// MC_PlantMines ( ) ;
24739: CALL 33211 0 0
// if event = 107 then
24743: LD_VAR 0 1
24747: PUSH
24748: LD_INT 107
24750: EQUAL
24751: IFFALSE 24757
// MC_CollectCrates ( ) ;
24753: CALL 34002 0 0
// if event = 108 then
24757: LD_VAR 0 1
24761: PUSH
24762: LD_INT 108
24764: EQUAL
24765: IFFALSE 24771
// MC_LinkRemoteControl ( ) ;
24767: CALL 35852 0 0
// if event = 109 then
24771: LD_VAR 0 1
24775: PUSH
24776: LD_INT 109
24778: EQUAL
24779: IFFALSE 24785
// MC_ProduceVehicle ( ) ;
24781: CALL 36033 0 0
// if event = 110 then
24785: LD_VAR 0 1
24789: PUSH
24790: LD_INT 110
24792: EQUAL
24793: IFFALSE 24799
// MC_SendAttack ( ) ;
24795: CALL 36499 0 0
// if event = 111 then
24799: LD_VAR 0 1
24803: PUSH
24804: LD_INT 111
24806: EQUAL
24807: IFFALSE 24813
// MC_Defend ( ) ;
24809: CALL 36607 0 0
// if event = 112 then
24813: LD_VAR 0 1
24817: PUSH
24818: LD_INT 112
24820: EQUAL
24821: IFFALSE 24827
// MC_Research ( ) ;
24823: CALL 37329 0 0
// if event = 113 then
24827: LD_VAR 0 1
24831: PUSH
24832: LD_INT 113
24834: EQUAL
24835: IFFALSE 24841
// MC_MinesTrigger ( ) ;
24837: CALL 38443 0 0
// if event = 120 then
24841: LD_VAR 0 1
24845: PUSH
24846: LD_INT 120
24848: EQUAL
24849: IFFALSE 24855
// MC_RepairVehicle ( ) ;
24851: CALL 38542 0 0
// if event = 121 then
24855: LD_VAR 0 1
24859: PUSH
24860: LD_INT 121
24862: EQUAL
24863: IFFALSE 24869
// MC_TameApe ( ) ;
24865: CALL 39283 0 0
// if event = 122 then
24869: LD_VAR 0 1
24873: PUSH
24874: LD_INT 122
24876: EQUAL
24877: IFFALSE 24883
// MC_ChangeApeClass ( ) ;
24879: CALL 40112 0 0
// if event = 123 then
24883: LD_VAR 0 1
24887: PUSH
24888: LD_INT 123
24890: EQUAL
24891: IFFALSE 24897
// MC_Bazooka ( ) ;
24893: CALL 40762 0 0
// if event = 124 then
24897: LD_VAR 0 1
24901: PUSH
24902: LD_INT 124
24904: EQUAL
24905: IFFALSE 24911
// MC_TeleportExit ( ) ;
24907: CALL 40960 0 0
// if event = 125 then
24911: LD_VAR 0 1
24915: PUSH
24916: LD_INT 125
24918: EQUAL
24919: IFFALSE 24925
// MC_Deposits ( ) ;
24921: CALL 41607 0 0
// if event = 126 then
24925: LD_VAR 0 1
24929: PUSH
24930: LD_INT 126
24932: EQUAL
24933: IFFALSE 24939
// MC_RemoteDriver ( ) ;
24935: CALL 42232 0 0
// if event = 200 then
24939: LD_VAR 0 1
24943: PUSH
24944: LD_INT 200
24946: EQUAL
24947: IFFALSE 24953
// MC_Idle ( ) ;
24949: CALL 44181 0 0
// end ;
24953: PPOPN 1
24955: END
// export function MC_Reset ( base , tag ) ; var i ; begin
24956: LD_INT 0
24958: PPUSH
24959: PPUSH
// if not mc_bases [ base ] or not tag then
24960: LD_EXP 93
24964: PUSH
24965: LD_VAR 0 1
24969: ARRAY
24970: NOT
24971: PUSH
24972: LD_VAR 0 2
24976: NOT
24977: OR
24978: IFFALSE 24982
// exit ;
24980: GO 25046
// for i in mc_bases [ base ] union mc_ape [ base ] do
24982: LD_ADDR_VAR 0 4
24986: PUSH
24987: LD_EXP 93
24991: PUSH
24992: LD_VAR 0 1
24996: ARRAY
24997: PUSH
24998: LD_EXP 122
25002: PUSH
25003: LD_VAR 0 1
25007: ARRAY
25008: UNION
25009: PUSH
25010: FOR_IN
25011: IFFALSE 25044
// if GetTag ( i ) = tag then
25013: LD_VAR 0 4
25017: PPUSH
25018: CALL_OW 110
25022: PUSH
25023: LD_VAR 0 2
25027: EQUAL
25028: IFFALSE 25042
// SetTag ( i , 0 ) ;
25030: LD_VAR 0 4
25034: PPUSH
25035: LD_INT 0
25037: PPUSH
25038: CALL_OW 109
25042: GO 25010
25044: POP
25045: POP
// end ;
25046: LD_VAR 0 3
25050: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
25051: LD_INT 0
25053: PPUSH
25054: PPUSH
25055: PPUSH
25056: PPUSH
25057: PPUSH
25058: PPUSH
25059: PPUSH
25060: PPUSH
// if not mc_bases then
25061: LD_EXP 93
25065: NOT
25066: IFFALSE 25070
// exit ;
25068: GO 25528
// for i = 1 to mc_bases do
25070: LD_ADDR_VAR 0 2
25074: PUSH
25075: DOUBLE
25076: LD_INT 1
25078: DEC
25079: ST_TO_ADDR
25080: LD_EXP 93
25084: PUSH
25085: FOR_TO
25086: IFFALSE 25526
// begin tmp := MC_ClassCheckReq ( i ) ;
25088: LD_ADDR_VAR 0 4
25092: PUSH
25093: LD_VAR 0 2
25097: PPUSH
25098: CALL 25533 0 1
25102: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
25103: LD_ADDR_EXP 134
25107: PUSH
25108: LD_EXP 134
25112: PPUSH
25113: LD_VAR 0 2
25117: PPUSH
25118: LD_VAR 0 4
25122: PPUSH
25123: CALL_OW 1
25127: ST_TO_ADDR
// if not tmp then
25128: LD_VAR 0 4
25132: NOT
25133: IFFALSE 25137
// continue ;
25135: GO 25085
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
25137: LD_ADDR_VAR 0 6
25141: PUSH
25142: LD_EXP 93
25146: PUSH
25147: LD_VAR 0 2
25151: ARRAY
25152: PPUSH
25153: LD_INT 2
25155: PUSH
25156: LD_INT 30
25158: PUSH
25159: LD_INT 4
25161: PUSH
25162: EMPTY
25163: LIST
25164: LIST
25165: PUSH
25166: LD_INT 30
25168: PUSH
25169: LD_INT 5
25171: PUSH
25172: EMPTY
25173: LIST
25174: LIST
25175: PUSH
25176: EMPTY
25177: LIST
25178: LIST
25179: LIST
25180: PPUSH
25181: CALL_OW 72
25185: PUSH
25186: LD_EXP 93
25190: PUSH
25191: LD_VAR 0 2
25195: ARRAY
25196: PPUSH
25197: LD_INT 2
25199: PUSH
25200: LD_INT 30
25202: PUSH
25203: LD_INT 0
25205: PUSH
25206: EMPTY
25207: LIST
25208: LIST
25209: PUSH
25210: LD_INT 30
25212: PUSH
25213: LD_INT 1
25215: PUSH
25216: EMPTY
25217: LIST
25218: LIST
25219: PUSH
25220: EMPTY
25221: LIST
25222: LIST
25223: LIST
25224: PPUSH
25225: CALL_OW 72
25229: PUSH
25230: LD_EXP 93
25234: PUSH
25235: LD_VAR 0 2
25239: ARRAY
25240: PPUSH
25241: LD_INT 30
25243: PUSH
25244: LD_INT 3
25246: PUSH
25247: EMPTY
25248: LIST
25249: LIST
25250: PPUSH
25251: CALL_OW 72
25255: PUSH
25256: LD_EXP 93
25260: PUSH
25261: LD_VAR 0 2
25265: ARRAY
25266: PPUSH
25267: LD_INT 2
25269: PUSH
25270: LD_INT 30
25272: PUSH
25273: LD_INT 6
25275: PUSH
25276: EMPTY
25277: LIST
25278: LIST
25279: PUSH
25280: LD_INT 30
25282: PUSH
25283: LD_INT 7
25285: PUSH
25286: EMPTY
25287: LIST
25288: LIST
25289: PUSH
25290: LD_INT 30
25292: PUSH
25293: LD_INT 8
25295: PUSH
25296: EMPTY
25297: LIST
25298: LIST
25299: PUSH
25300: EMPTY
25301: LIST
25302: LIST
25303: LIST
25304: LIST
25305: PPUSH
25306: CALL_OW 72
25310: PUSH
25311: EMPTY
25312: LIST
25313: LIST
25314: LIST
25315: LIST
25316: ST_TO_ADDR
// for j = 1 to 4 do
25317: LD_ADDR_VAR 0 3
25321: PUSH
25322: DOUBLE
25323: LD_INT 1
25325: DEC
25326: ST_TO_ADDR
25327: LD_INT 4
25329: PUSH
25330: FOR_TO
25331: IFFALSE 25522
// begin if not tmp [ j ] then
25333: LD_VAR 0 4
25337: PUSH
25338: LD_VAR 0 3
25342: ARRAY
25343: NOT
25344: IFFALSE 25348
// continue ;
25346: GO 25330
// for p in tmp [ j ] do
25348: LD_ADDR_VAR 0 5
25352: PUSH
25353: LD_VAR 0 4
25357: PUSH
25358: LD_VAR 0 3
25362: ARRAY
25363: PUSH
25364: FOR_IN
25365: IFFALSE 25518
// begin if not b [ j ] then
25367: LD_VAR 0 6
25371: PUSH
25372: LD_VAR 0 3
25376: ARRAY
25377: NOT
25378: IFFALSE 25382
// break ;
25380: GO 25518
// e := 0 ;
25382: LD_ADDR_VAR 0 7
25386: PUSH
25387: LD_INT 0
25389: ST_TO_ADDR
// for k in b [ j ] do
25390: LD_ADDR_VAR 0 8
25394: PUSH
25395: LD_VAR 0 6
25399: PUSH
25400: LD_VAR 0 3
25404: ARRAY
25405: PUSH
25406: FOR_IN
25407: IFFALSE 25434
// if IsNotFull ( k ) then
25409: LD_VAR 0 8
25413: PPUSH
25414: CALL 53428 0 1
25418: IFFALSE 25432
// begin e := k ;
25420: LD_ADDR_VAR 0 7
25424: PUSH
25425: LD_VAR 0 8
25429: ST_TO_ADDR
// break ;
25430: GO 25434
// end ;
25432: GO 25406
25434: POP
25435: POP
// if e and not UnitGoingToBuilding ( p , e ) then
25436: LD_VAR 0 7
25440: PUSH
25441: LD_VAR 0 5
25445: PPUSH
25446: LD_VAR 0 7
25450: PPUSH
25451: CALL 86593 0 2
25455: NOT
25456: AND
25457: IFFALSE 25516
// begin if IsInUnit ( p ) then
25459: LD_VAR 0 5
25463: PPUSH
25464: CALL_OW 310
25468: IFFALSE 25479
// ComExitBuilding ( p ) ;
25470: LD_VAR 0 5
25474: PPUSH
25475: CALL_OW 122
// ComEnterUnit ( p , e ) ;
25479: LD_VAR 0 5
25483: PPUSH
25484: LD_VAR 0 7
25488: PPUSH
25489: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
25493: LD_VAR 0 5
25497: PPUSH
25498: LD_VAR 0 3
25502: PPUSH
25503: CALL_OW 183
// AddComExitBuilding ( p ) ;
25507: LD_VAR 0 5
25511: PPUSH
25512: CALL_OW 182
// end ; end ;
25516: GO 25364
25518: POP
25519: POP
// end ;
25520: GO 25330
25522: POP
25523: POP
// end ;
25524: GO 25085
25526: POP
25527: POP
// end ;
25528: LD_VAR 0 1
25532: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
25533: LD_INT 0
25535: PPUSH
25536: PPUSH
25537: PPUSH
25538: PPUSH
25539: PPUSH
25540: PPUSH
25541: PPUSH
25542: PPUSH
25543: PPUSH
25544: PPUSH
25545: PPUSH
25546: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
25547: LD_VAR 0 1
25551: NOT
25552: PUSH
25553: LD_EXP 93
25557: PUSH
25558: LD_VAR 0 1
25562: ARRAY
25563: NOT
25564: OR
25565: PUSH
25566: LD_EXP 93
25570: PUSH
25571: LD_VAR 0 1
25575: ARRAY
25576: PPUSH
25577: LD_INT 2
25579: PUSH
25580: LD_INT 30
25582: PUSH
25583: LD_INT 0
25585: PUSH
25586: EMPTY
25587: LIST
25588: LIST
25589: PUSH
25590: LD_INT 30
25592: PUSH
25593: LD_INT 1
25595: PUSH
25596: EMPTY
25597: LIST
25598: LIST
25599: PUSH
25600: EMPTY
25601: LIST
25602: LIST
25603: LIST
25604: PPUSH
25605: CALL_OW 72
25609: NOT
25610: OR
25611: IFFALSE 25615
// exit ;
25613: GO 29118
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25615: LD_ADDR_VAR 0 4
25619: PUSH
25620: LD_EXP 93
25624: PUSH
25625: LD_VAR 0 1
25629: ARRAY
25630: PPUSH
25631: LD_INT 2
25633: PUSH
25634: LD_INT 25
25636: PUSH
25637: LD_INT 1
25639: PUSH
25640: EMPTY
25641: LIST
25642: LIST
25643: PUSH
25644: LD_INT 25
25646: PUSH
25647: LD_INT 2
25649: PUSH
25650: EMPTY
25651: LIST
25652: LIST
25653: PUSH
25654: LD_INT 25
25656: PUSH
25657: LD_INT 3
25659: PUSH
25660: EMPTY
25661: LIST
25662: LIST
25663: PUSH
25664: LD_INT 25
25666: PUSH
25667: LD_INT 4
25669: PUSH
25670: EMPTY
25671: LIST
25672: LIST
25673: PUSH
25674: LD_INT 25
25676: PUSH
25677: LD_INT 5
25679: PUSH
25680: EMPTY
25681: LIST
25682: LIST
25683: PUSH
25684: LD_INT 25
25686: PUSH
25687: LD_INT 8
25689: PUSH
25690: EMPTY
25691: LIST
25692: LIST
25693: PUSH
25694: LD_INT 25
25696: PUSH
25697: LD_INT 9
25699: PUSH
25700: EMPTY
25701: LIST
25702: LIST
25703: PUSH
25704: EMPTY
25705: LIST
25706: LIST
25707: LIST
25708: LIST
25709: LIST
25710: LIST
25711: LIST
25712: LIST
25713: PPUSH
25714: CALL_OW 72
25718: ST_TO_ADDR
// if not tmp then
25719: LD_VAR 0 4
25723: NOT
25724: IFFALSE 25728
// exit ;
25726: GO 29118
// for i in tmp do
25728: LD_ADDR_VAR 0 3
25732: PUSH
25733: LD_VAR 0 4
25737: PUSH
25738: FOR_IN
25739: IFFALSE 25770
// if GetTag ( i ) then
25741: LD_VAR 0 3
25745: PPUSH
25746: CALL_OW 110
25750: IFFALSE 25768
// tmp := tmp diff i ;
25752: LD_ADDR_VAR 0 4
25756: PUSH
25757: LD_VAR 0 4
25761: PUSH
25762: LD_VAR 0 3
25766: DIFF
25767: ST_TO_ADDR
25768: GO 25738
25770: POP
25771: POP
// if not tmp then
25772: LD_VAR 0 4
25776: NOT
25777: IFFALSE 25781
// exit ;
25779: GO 29118
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25781: LD_ADDR_VAR 0 5
25785: PUSH
25786: LD_EXP 93
25790: PUSH
25791: LD_VAR 0 1
25795: ARRAY
25796: PPUSH
25797: LD_INT 2
25799: PUSH
25800: LD_INT 25
25802: PUSH
25803: LD_INT 1
25805: PUSH
25806: EMPTY
25807: LIST
25808: LIST
25809: PUSH
25810: LD_INT 25
25812: PUSH
25813: LD_INT 5
25815: PUSH
25816: EMPTY
25817: LIST
25818: LIST
25819: PUSH
25820: LD_INT 25
25822: PUSH
25823: LD_INT 8
25825: PUSH
25826: EMPTY
25827: LIST
25828: LIST
25829: PUSH
25830: LD_INT 25
25832: PUSH
25833: LD_INT 9
25835: PUSH
25836: EMPTY
25837: LIST
25838: LIST
25839: PUSH
25840: EMPTY
25841: LIST
25842: LIST
25843: LIST
25844: LIST
25845: LIST
25846: PPUSH
25847: CALL_OW 72
25851: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
25852: LD_ADDR_VAR 0 6
25856: PUSH
25857: LD_EXP 93
25861: PUSH
25862: LD_VAR 0 1
25866: ARRAY
25867: PPUSH
25868: LD_INT 25
25870: PUSH
25871: LD_INT 2
25873: PUSH
25874: EMPTY
25875: LIST
25876: LIST
25877: PPUSH
25878: CALL_OW 72
25882: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
25883: LD_ADDR_VAR 0 7
25887: PUSH
25888: LD_EXP 93
25892: PUSH
25893: LD_VAR 0 1
25897: ARRAY
25898: PPUSH
25899: LD_INT 25
25901: PUSH
25902: LD_INT 3
25904: PUSH
25905: EMPTY
25906: LIST
25907: LIST
25908: PPUSH
25909: CALL_OW 72
25913: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
25914: LD_ADDR_VAR 0 8
25918: PUSH
25919: LD_EXP 93
25923: PUSH
25924: LD_VAR 0 1
25928: ARRAY
25929: PPUSH
25930: LD_INT 25
25932: PUSH
25933: LD_INT 4
25935: PUSH
25936: EMPTY
25937: LIST
25938: LIST
25939: PUSH
25940: LD_INT 24
25942: PUSH
25943: LD_INT 251
25945: PUSH
25946: EMPTY
25947: LIST
25948: LIST
25949: PUSH
25950: EMPTY
25951: LIST
25952: LIST
25953: PPUSH
25954: CALL_OW 72
25958: ST_TO_ADDR
// if mc_scan [ base ] then
25959: LD_EXP 116
25963: PUSH
25964: LD_VAR 0 1
25968: ARRAY
25969: IFFALSE 26430
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
25971: LD_ADDR_EXP 135
25975: PUSH
25976: LD_EXP 135
25980: PPUSH
25981: LD_VAR 0 1
25985: PPUSH
25986: LD_INT 4
25988: PPUSH
25989: CALL_OW 1
25993: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
25994: LD_ADDR_VAR 0 12
25998: PUSH
25999: LD_EXP 93
26003: PUSH
26004: LD_VAR 0 1
26008: ARRAY
26009: PPUSH
26010: LD_INT 2
26012: PUSH
26013: LD_INT 30
26015: PUSH
26016: LD_INT 4
26018: PUSH
26019: EMPTY
26020: LIST
26021: LIST
26022: PUSH
26023: LD_INT 30
26025: PUSH
26026: LD_INT 5
26028: PUSH
26029: EMPTY
26030: LIST
26031: LIST
26032: PUSH
26033: EMPTY
26034: LIST
26035: LIST
26036: LIST
26037: PPUSH
26038: CALL_OW 72
26042: ST_TO_ADDR
// if not b then
26043: LD_VAR 0 12
26047: NOT
26048: IFFALSE 26052
// exit ;
26050: GO 29118
// p := [ ] ;
26052: LD_ADDR_VAR 0 11
26056: PUSH
26057: EMPTY
26058: ST_TO_ADDR
// if sci >= 2 then
26059: LD_VAR 0 8
26063: PUSH
26064: LD_INT 2
26066: GREATEREQUAL
26067: IFFALSE 26098
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
26069: LD_ADDR_VAR 0 8
26073: PUSH
26074: LD_VAR 0 8
26078: PUSH
26079: LD_INT 1
26081: ARRAY
26082: PUSH
26083: LD_VAR 0 8
26087: PUSH
26088: LD_INT 2
26090: ARRAY
26091: PUSH
26092: EMPTY
26093: LIST
26094: LIST
26095: ST_TO_ADDR
26096: GO 26159
// if sci = 1 then
26098: LD_VAR 0 8
26102: PUSH
26103: LD_INT 1
26105: EQUAL
26106: IFFALSE 26127
// sci := [ sci [ 1 ] ] else
26108: LD_ADDR_VAR 0 8
26112: PUSH
26113: LD_VAR 0 8
26117: PUSH
26118: LD_INT 1
26120: ARRAY
26121: PUSH
26122: EMPTY
26123: LIST
26124: ST_TO_ADDR
26125: GO 26159
// if sci = 0 then
26127: LD_VAR 0 8
26131: PUSH
26132: LD_INT 0
26134: EQUAL
26135: IFFALSE 26159
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
26137: LD_ADDR_VAR 0 11
26141: PUSH
26142: LD_VAR 0 4
26146: PPUSH
26147: LD_INT 4
26149: PPUSH
26150: CALL 86456 0 2
26154: PUSH
26155: LD_INT 1
26157: ARRAY
26158: ST_TO_ADDR
// if eng > 4 then
26159: LD_VAR 0 6
26163: PUSH
26164: LD_INT 4
26166: GREATER
26167: IFFALSE 26213
// for i = eng downto 4 do
26169: LD_ADDR_VAR 0 3
26173: PUSH
26174: DOUBLE
26175: LD_VAR 0 6
26179: INC
26180: ST_TO_ADDR
26181: LD_INT 4
26183: PUSH
26184: FOR_DOWNTO
26185: IFFALSE 26211
// eng := eng diff eng [ i ] ;
26187: LD_ADDR_VAR 0 6
26191: PUSH
26192: LD_VAR 0 6
26196: PUSH
26197: LD_VAR 0 6
26201: PUSH
26202: LD_VAR 0 3
26206: ARRAY
26207: DIFF
26208: ST_TO_ADDR
26209: GO 26184
26211: POP
26212: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
26213: LD_ADDR_VAR 0 4
26217: PUSH
26218: LD_VAR 0 4
26222: PUSH
26223: LD_VAR 0 5
26227: PUSH
26228: LD_VAR 0 6
26232: UNION
26233: PUSH
26234: LD_VAR 0 7
26238: UNION
26239: PUSH
26240: LD_VAR 0 8
26244: UNION
26245: DIFF
26246: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
26247: LD_ADDR_VAR 0 13
26251: PUSH
26252: LD_EXP 93
26256: PUSH
26257: LD_VAR 0 1
26261: ARRAY
26262: PPUSH
26263: LD_INT 2
26265: PUSH
26266: LD_INT 30
26268: PUSH
26269: LD_INT 32
26271: PUSH
26272: EMPTY
26273: LIST
26274: LIST
26275: PUSH
26276: LD_INT 30
26278: PUSH
26279: LD_INT 31
26281: PUSH
26282: EMPTY
26283: LIST
26284: LIST
26285: PUSH
26286: EMPTY
26287: LIST
26288: LIST
26289: LIST
26290: PPUSH
26291: CALL_OW 72
26295: PUSH
26296: LD_EXP 93
26300: PUSH
26301: LD_VAR 0 1
26305: ARRAY
26306: PPUSH
26307: LD_INT 2
26309: PUSH
26310: LD_INT 30
26312: PUSH
26313: LD_INT 4
26315: PUSH
26316: EMPTY
26317: LIST
26318: LIST
26319: PUSH
26320: LD_INT 30
26322: PUSH
26323: LD_INT 5
26325: PUSH
26326: EMPTY
26327: LIST
26328: LIST
26329: PUSH
26330: EMPTY
26331: LIST
26332: LIST
26333: LIST
26334: PPUSH
26335: CALL_OW 72
26339: PUSH
26340: LD_INT 6
26342: MUL
26343: PLUS
26344: ST_TO_ADDR
// if bcount < tmp then
26345: LD_VAR 0 13
26349: PUSH
26350: LD_VAR 0 4
26354: LESS
26355: IFFALSE 26401
// for i = tmp downto bcount do
26357: LD_ADDR_VAR 0 3
26361: PUSH
26362: DOUBLE
26363: LD_VAR 0 4
26367: INC
26368: ST_TO_ADDR
26369: LD_VAR 0 13
26373: PUSH
26374: FOR_DOWNTO
26375: IFFALSE 26399
// tmp := Delete ( tmp , tmp ) ;
26377: LD_ADDR_VAR 0 4
26381: PUSH
26382: LD_VAR 0 4
26386: PPUSH
26387: LD_VAR 0 4
26391: PPUSH
26392: CALL_OW 3
26396: ST_TO_ADDR
26397: GO 26374
26399: POP
26400: POP
// result := [ tmp , 0 , 0 , p ] ;
26401: LD_ADDR_VAR 0 2
26405: PUSH
26406: LD_VAR 0 4
26410: PUSH
26411: LD_INT 0
26413: PUSH
26414: LD_INT 0
26416: PUSH
26417: LD_VAR 0 11
26421: PUSH
26422: EMPTY
26423: LIST
26424: LIST
26425: LIST
26426: LIST
26427: ST_TO_ADDR
// exit ;
26428: GO 29118
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26430: LD_EXP 93
26434: PUSH
26435: LD_VAR 0 1
26439: ARRAY
26440: PPUSH
26441: LD_INT 2
26443: PUSH
26444: LD_INT 30
26446: PUSH
26447: LD_INT 6
26449: PUSH
26450: EMPTY
26451: LIST
26452: LIST
26453: PUSH
26454: LD_INT 30
26456: PUSH
26457: LD_INT 7
26459: PUSH
26460: EMPTY
26461: LIST
26462: LIST
26463: PUSH
26464: LD_INT 30
26466: PUSH
26467: LD_INT 8
26469: PUSH
26470: EMPTY
26471: LIST
26472: LIST
26473: PUSH
26474: EMPTY
26475: LIST
26476: LIST
26477: LIST
26478: LIST
26479: PPUSH
26480: CALL_OW 72
26484: NOT
26485: PUSH
26486: LD_EXP 93
26490: PUSH
26491: LD_VAR 0 1
26495: ARRAY
26496: PPUSH
26497: LD_INT 30
26499: PUSH
26500: LD_INT 3
26502: PUSH
26503: EMPTY
26504: LIST
26505: LIST
26506: PPUSH
26507: CALL_OW 72
26511: NOT
26512: AND
26513: IFFALSE 26585
// begin if eng = tmp then
26515: LD_VAR 0 6
26519: PUSH
26520: LD_VAR 0 4
26524: EQUAL
26525: IFFALSE 26529
// exit ;
26527: GO 29118
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
26529: LD_ADDR_EXP 135
26533: PUSH
26534: LD_EXP 135
26538: PPUSH
26539: LD_VAR 0 1
26543: PPUSH
26544: LD_INT 1
26546: PPUSH
26547: CALL_OW 1
26551: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
26552: LD_ADDR_VAR 0 2
26556: PUSH
26557: LD_INT 0
26559: PUSH
26560: LD_VAR 0 4
26564: PUSH
26565: LD_VAR 0 6
26569: DIFF
26570: PUSH
26571: LD_INT 0
26573: PUSH
26574: LD_INT 0
26576: PUSH
26577: EMPTY
26578: LIST
26579: LIST
26580: LIST
26581: LIST
26582: ST_TO_ADDR
// exit ;
26583: GO 29118
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26585: LD_EXP 120
26589: PUSH
26590: LD_EXP 119
26594: PUSH
26595: LD_VAR 0 1
26599: ARRAY
26600: ARRAY
26601: PUSH
26602: LD_EXP 93
26606: PUSH
26607: LD_VAR 0 1
26611: ARRAY
26612: PPUSH
26613: LD_INT 2
26615: PUSH
26616: LD_INT 30
26618: PUSH
26619: LD_INT 6
26621: PUSH
26622: EMPTY
26623: LIST
26624: LIST
26625: PUSH
26626: LD_INT 30
26628: PUSH
26629: LD_INT 7
26631: PUSH
26632: EMPTY
26633: LIST
26634: LIST
26635: PUSH
26636: LD_INT 30
26638: PUSH
26639: LD_INT 8
26641: PUSH
26642: EMPTY
26643: LIST
26644: LIST
26645: PUSH
26646: EMPTY
26647: LIST
26648: LIST
26649: LIST
26650: LIST
26651: PPUSH
26652: CALL_OW 72
26656: AND
26657: PUSH
26658: LD_EXP 93
26662: PUSH
26663: LD_VAR 0 1
26667: ARRAY
26668: PPUSH
26669: LD_INT 30
26671: PUSH
26672: LD_INT 3
26674: PUSH
26675: EMPTY
26676: LIST
26677: LIST
26678: PPUSH
26679: CALL_OW 72
26683: NOT
26684: AND
26685: IFFALSE 26899
// begin if sci >= 6 then
26687: LD_VAR 0 8
26691: PUSH
26692: LD_INT 6
26694: GREATEREQUAL
26695: IFFALSE 26699
// exit ;
26697: GO 29118
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
26699: LD_ADDR_EXP 135
26703: PUSH
26704: LD_EXP 135
26708: PPUSH
26709: LD_VAR 0 1
26713: PPUSH
26714: LD_INT 2
26716: PPUSH
26717: CALL_OW 1
26721: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
26722: LD_ADDR_VAR 0 9
26726: PUSH
26727: LD_VAR 0 4
26731: PUSH
26732: LD_VAR 0 8
26736: DIFF
26737: PPUSH
26738: LD_INT 4
26740: PPUSH
26741: CALL 86456 0 2
26745: ST_TO_ADDR
// p := [ ] ;
26746: LD_ADDR_VAR 0 11
26750: PUSH
26751: EMPTY
26752: ST_TO_ADDR
// if sci < 6 and sort > 6 then
26753: LD_VAR 0 8
26757: PUSH
26758: LD_INT 6
26760: LESS
26761: PUSH
26762: LD_VAR 0 9
26766: PUSH
26767: LD_INT 6
26769: GREATER
26770: AND
26771: IFFALSE 26852
// begin for i = 1 to 6 - sci do
26773: LD_ADDR_VAR 0 3
26777: PUSH
26778: DOUBLE
26779: LD_INT 1
26781: DEC
26782: ST_TO_ADDR
26783: LD_INT 6
26785: PUSH
26786: LD_VAR 0 8
26790: MINUS
26791: PUSH
26792: FOR_TO
26793: IFFALSE 26848
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
26795: LD_ADDR_VAR 0 11
26799: PUSH
26800: LD_VAR 0 11
26804: PPUSH
26805: LD_VAR 0 11
26809: PUSH
26810: LD_INT 1
26812: PLUS
26813: PPUSH
26814: LD_VAR 0 9
26818: PUSH
26819: LD_INT 1
26821: ARRAY
26822: PPUSH
26823: CALL_OW 2
26827: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
26828: LD_ADDR_VAR 0 9
26832: PUSH
26833: LD_VAR 0 9
26837: PPUSH
26838: LD_INT 1
26840: PPUSH
26841: CALL_OW 3
26845: ST_TO_ADDR
// end ;
26846: GO 26792
26848: POP
26849: POP
// end else
26850: GO 26872
// if sort then
26852: LD_VAR 0 9
26856: IFFALSE 26872
// p := sort [ 1 ] ;
26858: LD_ADDR_VAR 0 11
26862: PUSH
26863: LD_VAR 0 9
26867: PUSH
26868: LD_INT 1
26870: ARRAY
26871: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
26872: LD_ADDR_VAR 0 2
26876: PUSH
26877: LD_INT 0
26879: PUSH
26880: LD_INT 0
26882: PUSH
26883: LD_INT 0
26885: PUSH
26886: LD_VAR 0 11
26890: PUSH
26891: EMPTY
26892: LIST
26893: LIST
26894: LIST
26895: LIST
26896: ST_TO_ADDR
// exit ;
26897: GO 29118
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26899: LD_EXP 120
26903: PUSH
26904: LD_EXP 119
26908: PUSH
26909: LD_VAR 0 1
26913: ARRAY
26914: ARRAY
26915: PUSH
26916: LD_EXP 93
26920: PUSH
26921: LD_VAR 0 1
26925: ARRAY
26926: PPUSH
26927: LD_INT 2
26929: PUSH
26930: LD_INT 30
26932: PUSH
26933: LD_INT 6
26935: PUSH
26936: EMPTY
26937: LIST
26938: LIST
26939: PUSH
26940: LD_INT 30
26942: PUSH
26943: LD_INT 7
26945: PUSH
26946: EMPTY
26947: LIST
26948: LIST
26949: PUSH
26950: LD_INT 30
26952: PUSH
26953: LD_INT 8
26955: PUSH
26956: EMPTY
26957: LIST
26958: LIST
26959: PUSH
26960: EMPTY
26961: LIST
26962: LIST
26963: LIST
26964: LIST
26965: PPUSH
26966: CALL_OW 72
26970: AND
26971: PUSH
26972: LD_EXP 93
26976: PUSH
26977: LD_VAR 0 1
26981: ARRAY
26982: PPUSH
26983: LD_INT 30
26985: PUSH
26986: LD_INT 3
26988: PUSH
26989: EMPTY
26990: LIST
26991: LIST
26992: PPUSH
26993: CALL_OW 72
26997: AND
26998: IFFALSE 27732
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
27000: LD_ADDR_EXP 135
27004: PUSH
27005: LD_EXP 135
27009: PPUSH
27010: LD_VAR 0 1
27014: PPUSH
27015: LD_INT 3
27017: PPUSH
27018: CALL_OW 1
27022: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27023: LD_ADDR_VAR 0 2
27027: PUSH
27028: LD_INT 0
27030: PUSH
27031: LD_INT 0
27033: PUSH
27034: LD_INT 0
27036: PUSH
27037: LD_INT 0
27039: PUSH
27040: EMPTY
27041: LIST
27042: LIST
27043: LIST
27044: LIST
27045: ST_TO_ADDR
// if not eng then
27046: LD_VAR 0 6
27050: NOT
27051: IFFALSE 27114
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
27053: LD_ADDR_VAR 0 11
27057: PUSH
27058: LD_VAR 0 4
27062: PPUSH
27063: LD_INT 2
27065: PPUSH
27066: CALL 86456 0 2
27070: PUSH
27071: LD_INT 1
27073: ARRAY
27074: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
27075: LD_ADDR_VAR 0 2
27079: PUSH
27080: LD_VAR 0 2
27084: PPUSH
27085: LD_INT 2
27087: PPUSH
27088: LD_VAR 0 11
27092: PPUSH
27093: CALL_OW 1
27097: ST_TO_ADDR
// tmp := tmp diff p ;
27098: LD_ADDR_VAR 0 4
27102: PUSH
27103: LD_VAR 0 4
27107: PUSH
27108: LD_VAR 0 11
27112: DIFF
27113: ST_TO_ADDR
// end ; if tmp and sci < 6 then
27114: LD_VAR 0 4
27118: PUSH
27119: LD_VAR 0 8
27123: PUSH
27124: LD_INT 6
27126: LESS
27127: AND
27128: IFFALSE 27316
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
27130: LD_ADDR_VAR 0 9
27134: PUSH
27135: LD_VAR 0 4
27139: PUSH
27140: LD_VAR 0 8
27144: PUSH
27145: LD_VAR 0 7
27149: UNION
27150: DIFF
27151: PPUSH
27152: LD_INT 4
27154: PPUSH
27155: CALL 86456 0 2
27159: ST_TO_ADDR
// p := [ ] ;
27160: LD_ADDR_VAR 0 11
27164: PUSH
27165: EMPTY
27166: ST_TO_ADDR
// if sort then
27167: LD_VAR 0 9
27171: IFFALSE 27287
// for i = 1 to 6 - sci do
27173: LD_ADDR_VAR 0 3
27177: PUSH
27178: DOUBLE
27179: LD_INT 1
27181: DEC
27182: ST_TO_ADDR
27183: LD_INT 6
27185: PUSH
27186: LD_VAR 0 8
27190: MINUS
27191: PUSH
27192: FOR_TO
27193: IFFALSE 27285
// begin if i = sort then
27195: LD_VAR 0 3
27199: PUSH
27200: LD_VAR 0 9
27204: EQUAL
27205: IFFALSE 27209
// break ;
27207: GO 27285
// if GetClass ( i ) = 4 then
27209: LD_VAR 0 3
27213: PPUSH
27214: CALL_OW 257
27218: PUSH
27219: LD_INT 4
27221: EQUAL
27222: IFFALSE 27226
// continue ;
27224: GO 27192
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27226: LD_ADDR_VAR 0 11
27230: PUSH
27231: LD_VAR 0 11
27235: PPUSH
27236: LD_VAR 0 11
27240: PUSH
27241: LD_INT 1
27243: PLUS
27244: PPUSH
27245: LD_VAR 0 9
27249: PUSH
27250: LD_VAR 0 3
27254: ARRAY
27255: PPUSH
27256: CALL_OW 2
27260: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27261: LD_ADDR_VAR 0 4
27265: PUSH
27266: LD_VAR 0 4
27270: PUSH
27271: LD_VAR 0 9
27275: PUSH
27276: LD_VAR 0 3
27280: ARRAY
27281: DIFF
27282: ST_TO_ADDR
// end ;
27283: GO 27192
27285: POP
27286: POP
// if p then
27287: LD_VAR 0 11
27291: IFFALSE 27316
// result := Replace ( result , 4 , p ) ;
27293: LD_ADDR_VAR 0 2
27297: PUSH
27298: LD_VAR 0 2
27302: PPUSH
27303: LD_INT 4
27305: PPUSH
27306: LD_VAR 0 11
27310: PPUSH
27311: CALL_OW 1
27315: ST_TO_ADDR
// end ; if tmp and mech < 6 then
27316: LD_VAR 0 4
27320: PUSH
27321: LD_VAR 0 7
27325: PUSH
27326: LD_INT 6
27328: LESS
27329: AND
27330: IFFALSE 27518
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27332: LD_ADDR_VAR 0 9
27336: PUSH
27337: LD_VAR 0 4
27341: PUSH
27342: LD_VAR 0 8
27346: PUSH
27347: LD_VAR 0 7
27351: UNION
27352: DIFF
27353: PPUSH
27354: LD_INT 3
27356: PPUSH
27357: CALL 86456 0 2
27361: ST_TO_ADDR
// p := [ ] ;
27362: LD_ADDR_VAR 0 11
27366: PUSH
27367: EMPTY
27368: ST_TO_ADDR
// if sort then
27369: LD_VAR 0 9
27373: IFFALSE 27489
// for i = 1 to 6 - mech do
27375: LD_ADDR_VAR 0 3
27379: PUSH
27380: DOUBLE
27381: LD_INT 1
27383: DEC
27384: ST_TO_ADDR
27385: LD_INT 6
27387: PUSH
27388: LD_VAR 0 7
27392: MINUS
27393: PUSH
27394: FOR_TO
27395: IFFALSE 27487
// begin if i = sort then
27397: LD_VAR 0 3
27401: PUSH
27402: LD_VAR 0 9
27406: EQUAL
27407: IFFALSE 27411
// break ;
27409: GO 27487
// if GetClass ( i ) = 3 then
27411: LD_VAR 0 3
27415: PPUSH
27416: CALL_OW 257
27420: PUSH
27421: LD_INT 3
27423: EQUAL
27424: IFFALSE 27428
// continue ;
27426: GO 27394
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27428: LD_ADDR_VAR 0 11
27432: PUSH
27433: LD_VAR 0 11
27437: PPUSH
27438: LD_VAR 0 11
27442: PUSH
27443: LD_INT 1
27445: PLUS
27446: PPUSH
27447: LD_VAR 0 9
27451: PUSH
27452: LD_VAR 0 3
27456: ARRAY
27457: PPUSH
27458: CALL_OW 2
27462: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27463: LD_ADDR_VAR 0 4
27467: PUSH
27468: LD_VAR 0 4
27472: PUSH
27473: LD_VAR 0 9
27477: PUSH
27478: LD_VAR 0 3
27482: ARRAY
27483: DIFF
27484: ST_TO_ADDR
// end ;
27485: GO 27394
27487: POP
27488: POP
// if p then
27489: LD_VAR 0 11
27493: IFFALSE 27518
// result := Replace ( result , 3 , p ) ;
27495: LD_ADDR_VAR 0 2
27499: PUSH
27500: LD_VAR 0 2
27504: PPUSH
27505: LD_INT 3
27507: PPUSH
27508: LD_VAR 0 11
27512: PPUSH
27513: CALL_OW 1
27517: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
27518: LD_VAR 0 4
27522: PUSH
27523: LD_INT 6
27525: GREATER
27526: PUSH
27527: LD_VAR 0 6
27531: PUSH
27532: LD_INT 6
27534: LESS
27535: AND
27536: IFFALSE 27730
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
27538: LD_ADDR_VAR 0 9
27542: PUSH
27543: LD_VAR 0 4
27547: PUSH
27548: LD_VAR 0 8
27552: PUSH
27553: LD_VAR 0 7
27557: UNION
27558: PUSH
27559: LD_VAR 0 6
27563: UNION
27564: DIFF
27565: PPUSH
27566: LD_INT 2
27568: PPUSH
27569: CALL 86456 0 2
27573: ST_TO_ADDR
// p := [ ] ;
27574: LD_ADDR_VAR 0 11
27578: PUSH
27579: EMPTY
27580: ST_TO_ADDR
// if sort then
27581: LD_VAR 0 9
27585: IFFALSE 27701
// for i = 1 to 6 - eng do
27587: LD_ADDR_VAR 0 3
27591: PUSH
27592: DOUBLE
27593: LD_INT 1
27595: DEC
27596: ST_TO_ADDR
27597: LD_INT 6
27599: PUSH
27600: LD_VAR 0 6
27604: MINUS
27605: PUSH
27606: FOR_TO
27607: IFFALSE 27699
// begin if i = sort then
27609: LD_VAR 0 3
27613: PUSH
27614: LD_VAR 0 9
27618: EQUAL
27619: IFFALSE 27623
// break ;
27621: GO 27699
// if GetClass ( i ) = 2 then
27623: LD_VAR 0 3
27627: PPUSH
27628: CALL_OW 257
27632: PUSH
27633: LD_INT 2
27635: EQUAL
27636: IFFALSE 27640
// continue ;
27638: GO 27606
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27640: LD_ADDR_VAR 0 11
27644: PUSH
27645: LD_VAR 0 11
27649: PPUSH
27650: LD_VAR 0 11
27654: PUSH
27655: LD_INT 1
27657: PLUS
27658: PPUSH
27659: LD_VAR 0 9
27663: PUSH
27664: LD_VAR 0 3
27668: ARRAY
27669: PPUSH
27670: CALL_OW 2
27674: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27675: LD_ADDR_VAR 0 4
27679: PUSH
27680: LD_VAR 0 4
27684: PUSH
27685: LD_VAR 0 9
27689: PUSH
27690: LD_VAR 0 3
27694: ARRAY
27695: DIFF
27696: ST_TO_ADDR
// end ;
27697: GO 27606
27699: POP
27700: POP
// if p then
27701: LD_VAR 0 11
27705: IFFALSE 27730
// result := Replace ( result , 2 , p ) ;
27707: LD_ADDR_VAR 0 2
27711: PUSH
27712: LD_VAR 0 2
27716: PPUSH
27717: LD_INT 2
27719: PPUSH
27720: LD_VAR 0 11
27724: PPUSH
27725: CALL_OW 1
27729: ST_TO_ADDR
// end ; exit ;
27730: GO 29118
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
27732: LD_EXP 120
27736: PUSH
27737: LD_EXP 119
27741: PUSH
27742: LD_VAR 0 1
27746: ARRAY
27747: ARRAY
27748: NOT
27749: PUSH
27750: LD_EXP 93
27754: PUSH
27755: LD_VAR 0 1
27759: ARRAY
27760: PPUSH
27761: LD_INT 30
27763: PUSH
27764: LD_INT 3
27766: PUSH
27767: EMPTY
27768: LIST
27769: LIST
27770: PPUSH
27771: CALL_OW 72
27775: AND
27776: PUSH
27777: LD_EXP 98
27781: PUSH
27782: LD_VAR 0 1
27786: ARRAY
27787: AND
27788: IFFALSE 28396
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
27790: LD_ADDR_EXP 135
27794: PUSH
27795: LD_EXP 135
27799: PPUSH
27800: LD_VAR 0 1
27804: PPUSH
27805: LD_INT 5
27807: PPUSH
27808: CALL_OW 1
27812: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27813: LD_ADDR_VAR 0 2
27817: PUSH
27818: LD_INT 0
27820: PUSH
27821: LD_INT 0
27823: PUSH
27824: LD_INT 0
27826: PUSH
27827: LD_INT 0
27829: PUSH
27830: EMPTY
27831: LIST
27832: LIST
27833: LIST
27834: LIST
27835: ST_TO_ADDR
// if sci > 1 then
27836: LD_VAR 0 8
27840: PUSH
27841: LD_INT 1
27843: GREATER
27844: IFFALSE 27872
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
27846: LD_ADDR_VAR 0 4
27850: PUSH
27851: LD_VAR 0 4
27855: PUSH
27856: LD_VAR 0 8
27860: PUSH
27861: LD_VAR 0 8
27865: PUSH
27866: LD_INT 1
27868: ARRAY
27869: DIFF
27870: DIFF
27871: ST_TO_ADDR
// if tmp and not sci then
27872: LD_VAR 0 4
27876: PUSH
27877: LD_VAR 0 8
27881: NOT
27882: AND
27883: IFFALSE 27952
// begin sort := SortBySkill ( tmp , 4 ) ;
27885: LD_ADDR_VAR 0 9
27889: PUSH
27890: LD_VAR 0 4
27894: PPUSH
27895: LD_INT 4
27897: PPUSH
27898: CALL 86456 0 2
27902: ST_TO_ADDR
// if sort then
27903: LD_VAR 0 9
27907: IFFALSE 27923
// p := sort [ 1 ] ;
27909: LD_ADDR_VAR 0 11
27913: PUSH
27914: LD_VAR 0 9
27918: PUSH
27919: LD_INT 1
27921: ARRAY
27922: ST_TO_ADDR
// if p then
27923: LD_VAR 0 11
27927: IFFALSE 27952
// result := Replace ( result , 4 , p ) ;
27929: LD_ADDR_VAR 0 2
27933: PUSH
27934: LD_VAR 0 2
27938: PPUSH
27939: LD_INT 4
27941: PPUSH
27942: LD_VAR 0 11
27946: PPUSH
27947: CALL_OW 1
27951: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
27952: LD_ADDR_VAR 0 4
27956: PUSH
27957: LD_VAR 0 4
27961: PUSH
27962: LD_VAR 0 7
27966: DIFF
27967: ST_TO_ADDR
// if tmp and mech < 6 then
27968: LD_VAR 0 4
27972: PUSH
27973: LD_VAR 0 7
27977: PUSH
27978: LD_INT 6
27980: LESS
27981: AND
27982: IFFALSE 28170
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27984: LD_ADDR_VAR 0 9
27988: PUSH
27989: LD_VAR 0 4
27993: PUSH
27994: LD_VAR 0 8
27998: PUSH
27999: LD_VAR 0 7
28003: UNION
28004: DIFF
28005: PPUSH
28006: LD_INT 3
28008: PPUSH
28009: CALL 86456 0 2
28013: ST_TO_ADDR
// p := [ ] ;
28014: LD_ADDR_VAR 0 11
28018: PUSH
28019: EMPTY
28020: ST_TO_ADDR
// if sort then
28021: LD_VAR 0 9
28025: IFFALSE 28141
// for i = 1 to 6 - mech do
28027: LD_ADDR_VAR 0 3
28031: PUSH
28032: DOUBLE
28033: LD_INT 1
28035: DEC
28036: ST_TO_ADDR
28037: LD_INT 6
28039: PUSH
28040: LD_VAR 0 7
28044: MINUS
28045: PUSH
28046: FOR_TO
28047: IFFALSE 28139
// begin if i = sort then
28049: LD_VAR 0 3
28053: PUSH
28054: LD_VAR 0 9
28058: EQUAL
28059: IFFALSE 28063
// break ;
28061: GO 28139
// if GetClass ( i ) = 3 then
28063: LD_VAR 0 3
28067: PPUSH
28068: CALL_OW 257
28072: PUSH
28073: LD_INT 3
28075: EQUAL
28076: IFFALSE 28080
// continue ;
28078: GO 28046
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28080: LD_ADDR_VAR 0 11
28084: PUSH
28085: LD_VAR 0 11
28089: PPUSH
28090: LD_VAR 0 11
28094: PUSH
28095: LD_INT 1
28097: PLUS
28098: PPUSH
28099: LD_VAR 0 9
28103: PUSH
28104: LD_VAR 0 3
28108: ARRAY
28109: PPUSH
28110: CALL_OW 2
28114: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28115: LD_ADDR_VAR 0 4
28119: PUSH
28120: LD_VAR 0 4
28124: PUSH
28125: LD_VAR 0 9
28129: PUSH
28130: LD_VAR 0 3
28134: ARRAY
28135: DIFF
28136: ST_TO_ADDR
// end ;
28137: GO 28046
28139: POP
28140: POP
// if p then
28141: LD_VAR 0 11
28145: IFFALSE 28170
// result := Replace ( result , 3 , p ) ;
28147: LD_ADDR_VAR 0 2
28151: PUSH
28152: LD_VAR 0 2
28156: PPUSH
28157: LD_INT 3
28159: PPUSH
28160: LD_VAR 0 11
28164: PPUSH
28165: CALL_OW 1
28169: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28170: LD_ADDR_VAR 0 4
28174: PUSH
28175: LD_VAR 0 4
28179: PUSH
28180: LD_VAR 0 6
28184: DIFF
28185: ST_TO_ADDR
// if tmp and eng < 6 then
28186: LD_VAR 0 4
28190: PUSH
28191: LD_VAR 0 6
28195: PUSH
28196: LD_INT 6
28198: LESS
28199: AND
28200: IFFALSE 28394
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
28202: LD_ADDR_VAR 0 9
28206: PUSH
28207: LD_VAR 0 4
28211: PUSH
28212: LD_VAR 0 8
28216: PUSH
28217: LD_VAR 0 7
28221: UNION
28222: PUSH
28223: LD_VAR 0 6
28227: UNION
28228: DIFF
28229: PPUSH
28230: LD_INT 2
28232: PPUSH
28233: CALL 86456 0 2
28237: ST_TO_ADDR
// p := [ ] ;
28238: LD_ADDR_VAR 0 11
28242: PUSH
28243: EMPTY
28244: ST_TO_ADDR
// if sort then
28245: LD_VAR 0 9
28249: IFFALSE 28365
// for i = 1 to 6 - eng do
28251: LD_ADDR_VAR 0 3
28255: PUSH
28256: DOUBLE
28257: LD_INT 1
28259: DEC
28260: ST_TO_ADDR
28261: LD_INT 6
28263: PUSH
28264: LD_VAR 0 6
28268: MINUS
28269: PUSH
28270: FOR_TO
28271: IFFALSE 28363
// begin if i = sort then
28273: LD_VAR 0 3
28277: PUSH
28278: LD_VAR 0 9
28282: EQUAL
28283: IFFALSE 28287
// break ;
28285: GO 28363
// if GetClass ( i ) = 2 then
28287: LD_VAR 0 3
28291: PPUSH
28292: CALL_OW 257
28296: PUSH
28297: LD_INT 2
28299: EQUAL
28300: IFFALSE 28304
// continue ;
28302: GO 28270
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28304: LD_ADDR_VAR 0 11
28308: PUSH
28309: LD_VAR 0 11
28313: PPUSH
28314: LD_VAR 0 11
28318: PUSH
28319: LD_INT 1
28321: PLUS
28322: PPUSH
28323: LD_VAR 0 9
28327: PUSH
28328: LD_VAR 0 3
28332: ARRAY
28333: PPUSH
28334: CALL_OW 2
28338: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28339: LD_ADDR_VAR 0 4
28343: PUSH
28344: LD_VAR 0 4
28348: PUSH
28349: LD_VAR 0 9
28353: PUSH
28354: LD_VAR 0 3
28358: ARRAY
28359: DIFF
28360: ST_TO_ADDR
// end ;
28361: GO 28270
28363: POP
28364: POP
// if p then
28365: LD_VAR 0 11
28369: IFFALSE 28394
// result := Replace ( result , 2 , p ) ;
28371: LD_ADDR_VAR 0 2
28375: PUSH
28376: LD_VAR 0 2
28380: PPUSH
28381: LD_INT 2
28383: PPUSH
28384: LD_VAR 0 11
28388: PPUSH
28389: CALL_OW 1
28393: ST_TO_ADDR
// end ; exit ;
28394: GO 29118
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
28396: LD_EXP 120
28400: PUSH
28401: LD_EXP 119
28405: PUSH
28406: LD_VAR 0 1
28410: ARRAY
28411: ARRAY
28412: NOT
28413: PUSH
28414: LD_EXP 93
28418: PUSH
28419: LD_VAR 0 1
28423: ARRAY
28424: PPUSH
28425: LD_INT 30
28427: PUSH
28428: LD_INT 3
28430: PUSH
28431: EMPTY
28432: LIST
28433: LIST
28434: PPUSH
28435: CALL_OW 72
28439: AND
28440: PUSH
28441: LD_EXP 98
28445: PUSH
28446: LD_VAR 0 1
28450: ARRAY
28451: NOT
28452: AND
28453: IFFALSE 29118
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
28455: LD_ADDR_EXP 135
28459: PUSH
28460: LD_EXP 135
28464: PPUSH
28465: LD_VAR 0 1
28469: PPUSH
28470: LD_INT 6
28472: PPUSH
28473: CALL_OW 1
28477: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
28478: LD_ADDR_VAR 0 2
28482: PUSH
28483: LD_INT 0
28485: PUSH
28486: LD_INT 0
28488: PUSH
28489: LD_INT 0
28491: PUSH
28492: LD_INT 0
28494: PUSH
28495: EMPTY
28496: LIST
28497: LIST
28498: LIST
28499: LIST
28500: ST_TO_ADDR
// if sci >= 1 then
28501: LD_VAR 0 8
28505: PUSH
28506: LD_INT 1
28508: GREATEREQUAL
28509: IFFALSE 28531
// tmp := tmp diff sci [ 1 ] ;
28511: LD_ADDR_VAR 0 4
28515: PUSH
28516: LD_VAR 0 4
28520: PUSH
28521: LD_VAR 0 8
28525: PUSH
28526: LD_INT 1
28528: ARRAY
28529: DIFF
28530: ST_TO_ADDR
// if tmp and not sci then
28531: LD_VAR 0 4
28535: PUSH
28536: LD_VAR 0 8
28540: NOT
28541: AND
28542: IFFALSE 28611
// begin sort := SortBySkill ( tmp , 4 ) ;
28544: LD_ADDR_VAR 0 9
28548: PUSH
28549: LD_VAR 0 4
28553: PPUSH
28554: LD_INT 4
28556: PPUSH
28557: CALL 86456 0 2
28561: ST_TO_ADDR
// if sort then
28562: LD_VAR 0 9
28566: IFFALSE 28582
// p := sort [ 1 ] ;
28568: LD_ADDR_VAR 0 11
28572: PUSH
28573: LD_VAR 0 9
28577: PUSH
28578: LD_INT 1
28580: ARRAY
28581: ST_TO_ADDR
// if p then
28582: LD_VAR 0 11
28586: IFFALSE 28611
// result := Replace ( result , 4 , p ) ;
28588: LD_ADDR_VAR 0 2
28592: PUSH
28593: LD_VAR 0 2
28597: PPUSH
28598: LD_INT 4
28600: PPUSH
28601: LD_VAR 0 11
28605: PPUSH
28606: CALL_OW 1
28610: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
28611: LD_ADDR_VAR 0 4
28615: PUSH
28616: LD_VAR 0 4
28620: PUSH
28621: LD_VAR 0 7
28625: DIFF
28626: ST_TO_ADDR
// if tmp and mech < 6 then
28627: LD_VAR 0 4
28631: PUSH
28632: LD_VAR 0 7
28636: PUSH
28637: LD_INT 6
28639: LESS
28640: AND
28641: IFFALSE 28823
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
28643: LD_ADDR_VAR 0 9
28647: PUSH
28648: LD_VAR 0 4
28652: PUSH
28653: LD_VAR 0 7
28657: DIFF
28658: PPUSH
28659: LD_INT 3
28661: PPUSH
28662: CALL 86456 0 2
28666: ST_TO_ADDR
// p := [ ] ;
28667: LD_ADDR_VAR 0 11
28671: PUSH
28672: EMPTY
28673: ST_TO_ADDR
// if sort then
28674: LD_VAR 0 9
28678: IFFALSE 28794
// for i = 1 to 6 - mech do
28680: LD_ADDR_VAR 0 3
28684: PUSH
28685: DOUBLE
28686: LD_INT 1
28688: DEC
28689: ST_TO_ADDR
28690: LD_INT 6
28692: PUSH
28693: LD_VAR 0 7
28697: MINUS
28698: PUSH
28699: FOR_TO
28700: IFFALSE 28792
// begin if i = sort then
28702: LD_VAR 0 3
28706: PUSH
28707: LD_VAR 0 9
28711: EQUAL
28712: IFFALSE 28716
// break ;
28714: GO 28792
// if GetClass ( i ) = 3 then
28716: LD_VAR 0 3
28720: PPUSH
28721: CALL_OW 257
28725: PUSH
28726: LD_INT 3
28728: EQUAL
28729: IFFALSE 28733
// continue ;
28731: GO 28699
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28733: LD_ADDR_VAR 0 11
28737: PUSH
28738: LD_VAR 0 11
28742: PPUSH
28743: LD_VAR 0 11
28747: PUSH
28748: LD_INT 1
28750: PLUS
28751: PPUSH
28752: LD_VAR 0 9
28756: PUSH
28757: LD_VAR 0 3
28761: ARRAY
28762: PPUSH
28763: CALL_OW 2
28767: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28768: LD_ADDR_VAR 0 4
28772: PUSH
28773: LD_VAR 0 4
28777: PUSH
28778: LD_VAR 0 9
28782: PUSH
28783: LD_VAR 0 3
28787: ARRAY
28788: DIFF
28789: ST_TO_ADDR
// end ;
28790: GO 28699
28792: POP
28793: POP
// if p then
28794: LD_VAR 0 11
28798: IFFALSE 28823
// result := Replace ( result , 3 , p ) ;
28800: LD_ADDR_VAR 0 2
28804: PUSH
28805: LD_VAR 0 2
28809: PPUSH
28810: LD_INT 3
28812: PPUSH
28813: LD_VAR 0 11
28817: PPUSH
28818: CALL_OW 1
28822: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28823: LD_ADDR_VAR 0 4
28827: PUSH
28828: LD_VAR 0 4
28832: PUSH
28833: LD_VAR 0 6
28837: DIFF
28838: ST_TO_ADDR
// if tmp and eng < 4 then
28839: LD_VAR 0 4
28843: PUSH
28844: LD_VAR 0 6
28848: PUSH
28849: LD_INT 4
28851: LESS
28852: AND
28853: IFFALSE 29043
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
28855: LD_ADDR_VAR 0 9
28859: PUSH
28860: LD_VAR 0 4
28864: PUSH
28865: LD_VAR 0 7
28869: PUSH
28870: LD_VAR 0 6
28874: UNION
28875: DIFF
28876: PPUSH
28877: LD_INT 2
28879: PPUSH
28880: CALL 86456 0 2
28884: ST_TO_ADDR
// p := [ ] ;
28885: LD_ADDR_VAR 0 11
28889: PUSH
28890: EMPTY
28891: ST_TO_ADDR
// if sort then
28892: LD_VAR 0 9
28896: IFFALSE 29012
// for i = 1 to 4 - eng do
28898: LD_ADDR_VAR 0 3
28902: PUSH
28903: DOUBLE
28904: LD_INT 1
28906: DEC
28907: ST_TO_ADDR
28908: LD_INT 4
28910: PUSH
28911: LD_VAR 0 6
28915: MINUS
28916: PUSH
28917: FOR_TO
28918: IFFALSE 29010
// begin if i = sort then
28920: LD_VAR 0 3
28924: PUSH
28925: LD_VAR 0 9
28929: EQUAL
28930: IFFALSE 28934
// break ;
28932: GO 29010
// if GetClass ( i ) = 2 then
28934: LD_VAR 0 3
28938: PPUSH
28939: CALL_OW 257
28943: PUSH
28944: LD_INT 2
28946: EQUAL
28947: IFFALSE 28951
// continue ;
28949: GO 28917
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28951: LD_ADDR_VAR 0 11
28955: PUSH
28956: LD_VAR 0 11
28960: PPUSH
28961: LD_VAR 0 11
28965: PUSH
28966: LD_INT 1
28968: PLUS
28969: PPUSH
28970: LD_VAR 0 9
28974: PUSH
28975: LD_VAR 0 3
28979: ARRAY
28980: PPUSH
28981: CALL_OW 2
28985: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28986: LD_ADDR_VAR 0 4
28990: PUSH
28991: LD_VAR 0 4
28995: PUSH
28996: LD_VAR 0 9
29000: PUSH
29001: LD_VAR 0 3
29005: ARRAY
29006: DIFF
29007: ST_TO_ADDR
// end ;
29008: GO 28917
29010: POP
29011: POP
// if p then
29012: LD_VAR 0 11
29016: IFFALSE 29041
// result := Replace ( result , 2 , p ) ;
29018: LD_ADDR_VAR 0 2
29022: PUSH
29023: LD_VAR 0 2
29027: PPUSH
29028: LD_INT 2
29030: PPUSH
29031: LD_VAR 0 11
29035: PPUSH
29036: CALL_OW 1
29040: ST_TO_ADDR
// end else
29041: GO 29087
// for i = eng downto 5 do
29043: LD_ADDR_VAR 0 3
29047: PUSH
29048: DOUBLE
29049: LD_VAR 0 6
29053: INC
29054: ST_TO_ADDR
29055: LD_INT 5
29057: PUSH
29058: FOR_DOWNTO
29059: IFFALSE 29085
// tmp := tmp union eng [ i ] ;
29061: LD_ADDR_VAR 0 4
29065: PUSH
29066: LD_VAR 0 4
29070: PUSH
29071: LD_VAR 0 6
29075: PUSH
29076: LD_VAR 0 3
29080: ARRAY
29081: UNION
29082: ST_TO_ADDR
29083: GO 29058
29085: POP
29086: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
29087: LD_ADDR_VAR 0 2
29091: PUSH
29092: LD_VAR 0 2
29096: PPUSH
29097: LD_INT 1
29099: PPUSH
29100: LD_VAR 0 4
29104: PUSH
29105: LD_VAR 0 5
29109: DIFF
29110: PPUSH
29111: CALL_OW 1
29115: ST_TO_ADDR
// exit ;
29116: GO 29118
// end ; end ;
29118: LD_VAR 0 2
29122: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
29123: LD_INT 0
29125: PPUSH
29126: PPUSH
29127: PPUSH
// if not mc_bases then
29128: LD_EXP 93
29132: NOT
29133: IFFALSE 29137
// exit ;
29135: GO 29243
// for i = 1 to mc_bases do
29137: LD_ADDR_VAR 0 2
29141: PUSH
29142: DOUBLE
29143: LD_INT 1
29145: DEC
29146: ST_TO_ADDR
29147: LD_EXP 93
29151: PUSH
29152: FOR_TO
29153: IFFALSE 29234
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
29155: LD_ADDR_VAR 0 3
29159: PUSH
29160: LD_EXP 93
29164: PUSH
29165: LD_VAR 0 2
29169: ARRAY
29170: PPUSH
29171: LD_INT 21
29173: PUSH
29174: LD_INT 3
29176: PUSH
29177: EMPTY
29178: LIST
29179: LIST
29180: PUSH
29181: LD_INT 3
29183: PUSH
29184: LD_INT 24
29186: PUSH
29187: LD_INT 1000
29189: PUSH
29190: EMPTY
29191: LIST
29192: LIST
29193: PUSH
29194: EMPTY
29195: LIST
29196: LIST
29197: PUSH
29198: EMPTY
29199: LIST
29200: LIST
29201: PPUSH
29202: CALL_OW 72
29206: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
29207: LD_ADDR_EXP 94
29211: PUSH
29212: LD_EXP 94
29216: PPUSH
29217: LD_VAR 0 2
29221: PPUSH
29222: LD_VAR 0 3
29226: PPUSH
29227: CALL_OW 1
29231: ST_TO_ADDR
// end ;
29232: GO 29152
29234: POP
29235: POP
// RaiseSailEvent ( 101 ) ;
29236: LD_INT 101
29238: PPUSH
29239: CALL_OW 427
// end ;
29243: LD_VAR 0 1
29247: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
29248: LD_INT 0
29250: PPUSH
29251: PPUSH
29252: PPUSH
29253: PPUSH
29254: PPUSH
29255: PPUSH
29256: PPUSH
// if not mc_bases then
29257: LD_EXP 93
29261: NOT
29262: IFFALSE 29266
// exit ;
29264: GO 29828
// for i = 1 to mc_bases do
29266: LD_ADDR_VAR 0 2
29270: PUSH
29271: DOUBLE
29272: LD_INT 1
29274: DEC
29275: ST_TO_ADDR
29276: LD_EXP 93
29280: PUSH
29281: FOR_TO
29282: IFFALSE 29819
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
29284: LD_ADDR_VAR 0 5
29288: PUSH
29289: LD_EXP 93
29293: PUSH
29294: LD_VAR 0 2
29298: ARRAY
29299: PUSH
29300: LD_EXP 122
29304: PUSH
29305: LD_VAR 0 2
29309: ARRAY
29310: UNION
29311: PPUSH
29312: LD_INT 21
29314: PUSH
29315: LD_INT 1
29317: PUSH
29318: EMPTY
29319: LIST
29320: LIST
29321: PUSH
29322: LD_INT 1
29324: PUSH
29325: LD_INT 3
29327: PUSH
29328: LD_INT 54
29330: PUSH
29331: EMPTY
29332: LIST
29333: PUSH
29334: EMPTY
29335: LIST
29336: LIST
29337: PUSH
29338: LD_INT 3
29340: PUSH
29341: LD_INT 24
29343: PUSH
29344: LD_INT 1000
29346: PUSH
29347: EMPTY
29348: LIST
29349: LIST
29350: PUSH
29351: EMPTY
29352: LIST
29353: LIST
29354: PUSH
29355: EMPTY
29356: LIST
29357: LIST
29358: LIST
29359: PUSH
29360: EMPTY
29361: LIST
29362: LIST
29363: PPUSH
29364: CALL_OW 72
29368: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
29369: LD_ADDR_VAR 0 6
29373: PUSH
29374: LD_EXP 93
29378: PUSH
29379: LD_VAR 0 2
29383: ARRAY
29384: PPUSH
29385: LD_INT 21
29387: PUSH
29388: LD_INT 1
29390: PUSH
29391: EMPTY
29392: LIST
29393: LIST
29394: PUSH
29395: LD_INT 1
29397: PUSH
29398: LD_INT 3
29400: PUSH
29401: LD_INT 54
29403: PUSH
29404: EMPTY
29405: LIST
29406: PUSH
29407: EMPTY
29408: LIST
29409: LIST
29410: PUSH
29411: LD_INT 3
29413: PUSH
29414: LD_INT 24
29416: PUSH
29417: LD_INT 250
29419: PUSH
29420: EMPTY
29421: LIST
29422: LIST
29423: PUSH
29424: EMPTY
29425: LIST
29426: LIST
29427: PUSH
29428: EMPTY
29429: LIST
29430: LIST
29431: LIST
29432: PUSH
29433: EMPTY
29434: LIST
29435: LIST
29436: PPUSH
29437: CALL_OW 72
29441: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
29442: LD_ADDR_VAR 0 7
29446: PUSH
29447: LD_VAR 0 5
29451: PUSH
29452: LD_VAR 0 6
29456: DIFF
29457: ST_TO_ADDR
// if not need_heal_1 then
29458: LD_VAR 0 6
29462: NOT
29463: IFFALSE 29496
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
29465: LD_ADDR_EXP 96
29469: PUSH
29470: LD_EXP 96
29474: PPUSH
29475: LD_VAR 0 2
29479: PUSH
29480: LD_INT 1
29482: PUSH
29483: EMPTY
29484: LIST
29485: LIST
29486: PPUSH
29487: EMPTY
29488: PPUSH
29489: CALL 56198 0 3
29493: ST_TO_ADDR
29494: GO 29566
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
29496: LD_ADDR_EXP 96
29500: PUSH
29501: LD_EXP 96
29505: PPUSH
29506: LD_VAR 0 2
29510: PUSH
29511: LD_INT 1
29513: PUSH
29514: EMPTY
29515: LIST
29516: LIST
29517: PPUSH
29518: LD_EXP 96
29522: PUSH
29523: LD_VAR 0 2
29527: ARRAY
29528: PUSH
29529: LD_INT 1
29531: ARRAY
29532: PPUSH
29533: LD_INT 3
29535: PUSH
29536: LD_INT 24
29538: PUSH
29539: LD_INT 1000
29541: PUSH
29542: EMPTY
29543: LIST
29544: LIST
29545: PUSH
29546: EMPTY
29547: LIST
29548: LIST
29549: PPUSH
29550: CALL_OW 72
29554: PUSH
29555: LD_VAR 0 6
29559: UNION
29560: PPUSH
29561: CALL 56198 0 3
29565: ST_TO_ADDR
// if not need_heal_2 then
29566: LD_VAR 0 7
29570: NOT
29571: IFFALSE 29604
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
29573: LD_ADDR_EXP 96
29577: PUSH
29578: LD_EXP 96
29582: PPUSH
29583: LD_VAR 0 2
29587: PUSH
29588: LD_INT 2
29590: PUSH
29591: EMPTY
29592: LIST
29593: LIST
29594: PPUSH
29595: EMPTY
29596: PPUSH
29597: CALL 56198 0 3
29601: ST_TO_ADDR
29602: GO 29636
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
29604: LD_ADDR_EXP 96
29608: PUSH
29609: LD_EXP 96
29613: PPUSH
29614: LD_VAR 0 2
29618: PUSH
29619: LD_INT 2
29621: PUSH
29622: EMPTY
29623: LIST
29624: LIST
29625: PPUSH
29626: LD_VAR 0 7
29630: PPUSH
29631: CALL 56198 0 3
29635: ST_TO_ADDR
// if need_heal_2 then
29636: LD_VAR 0 7
29640: IFFALSE 29801
// for j in need_heal_2 do
29642: LD_ADDR_VAR 0 3
29646: PUSH
29647: LD_VAR 0 7
29651: PUSH
29652: FOR_IN
29653: IFFALSE 29799
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
29655: LD_ADDR_VAR 0 5
29659: PUSH
29660: LD_EXP 93
29664: PUSH
29665: LD_VAR 0 2
29669: ARRAY
29670: PPUSH
29671: LD_INT 2
29673: PUSH
29674: LD_INT 30
29676: PUSH
29677: LD_INT 6
29679: PUSH
29680: EMPTY
29681: LIST
29682: LIST
29683: PUSH
29684: LD_INT 30
29686: PUSH
29687: LD_INT 7
29689: PUSH
29690: EMPTY
29691: LIST
29692: LIST
29693: PUSH
29694: LD_INT 30
29696: PUSH
29697: LD_INT 8
29699: PUSH
29700: EMPTY
29701: LIST
29702: LIST
29703: PUSH
29704: LD_INT 30
29706: PUSH
29707: LD_INT 0
29709: PUSH
29710: EMPTY
29711: LIST
29712: LIST
29713: PUSH
29714: LD_INT 30
29716: PUSH
29717: LD_INT 1
29719: PUSH
29720: EMPTY
29721: LIST
29722: LIST
29723: PUSH
29724: EMPTY
29725: LIST
29726: LIST
29727: LIST
29728: LIST
29729: LIST
29730: LIST
29731: PPUSH
29732: CALL_OW 72
29736: ST_TO_ADDR
// if tmp then
29737: LD_VAR 0 5
29741: IFFALSE 29797
// begin k := NearestUnitToUnit ( tmp , j ) ;
29743: LD_ADDR_VAR 0 4
29747: PUSH
29748: LD_VAR 0 5
29752: PPUSH
29753: LD_VAR 0 3
29757: PPUSH
29758: CALL_OW 74
29762: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
29763: LD_VAR 0 3
29767: PPUSH
29768: LD_VAR 0 4
29772: PPUSH
29773: CALL_OW 296
29777: PUSH
29778: LD_INT 5
29780: GREATER
29781: IFFALSE 29797
// ComMoveToNearbyEntrance ( j , k ) ;
29783: LD_VAR 0 3
29787: PPUSH
29788: LD_VAR 0 4
29792: PPUSH
29793: CALL 88817 0 2
// end ; end ;
29797: GO 29652
29799: POP
29800: POP
// if not need_heal_1 and not need_heal_2 then
29801: LD_VAR 0 6
29805: NOT
29806: PUSH
29807: LD_VAR 0 7
29811: NOT
29812: AND
29813: IFFALSE 29817
// continue ;
29815: GO 29281
// end ;
29817: GO 29281
29819: POP
29820: POP
// RaiseSailEvent ( 102 ) ;
29821: LD_INT 102
29823: PPUSH
29824: CALL_OW 427
// end ;
29828: LD_VAR 0 1
29832: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
29833: LD_INT 0
29835: PPUSH
29836: PPUSH
29837: PPUSH
29838: PPUSH
29839: PPUSH
29840: PPUSH
29841: PPUSH
29842: PPUSH
// if not mc_bases then
29843: LD_EXP 93
29847: NOT
29848: IFFALSE 29852
// exit ;
29850: GO 30713
// for i = 1 to mc_bases do
29852: LD_ADDR_VAR 0 2
29856: PUSH
29857: DOUBLE
29858: LD_INT 1
29860: DEC
29861: ST_TO_ADDR
29862: LD_EXP 93
29866: PUSH
29867: FOR_TO
29868: IFFALSE 30711
// begin if not mc_building_need_repair [ i ] then
29870: LD_EXP 94
29874: PUSH
29875: LD_VAR 0 2
29879: ARRAY
29880: NOT
29881: IFFALSE 30068
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
29883: LD_ADDR_VAR 0 6
29887: PUSH
29888: LD_EXP 112
29892: PUSH
29893: LD_VAR 0 2
29897: ARRAY
29898: PPUSH
29899: LD_INT 3
29901: PUSH
29902: LD_INT 24
29904: PUSH
29905: LD_INT 1000
29907: PUSH
29908: EMPTY
29909: LIST
29910: LIST
29911: PUSH
29912: EMPTY
29913: LIST
29914: LIST
29915: PUSH
29916: LD_INT 2
29918: PUSH
29919: LD_INT 34
29921: PUSH
29922: LD_INT 13
29924: PUSH
29925: EMPTY
29926: LIST
29927: LIST
29928: PUSH
29929: LD_INT 34
29931: PUSH
29932: LD_INT 52
29934: PUSH
29935: EMPTY
29936: LIST
29937: LIST
29938: PUSH
29939: LD_INT 34
29941: PUSH
29942: LD_EXP 78
29946: PUSH
29947: EMPTY
29948: LIST
29949: LIST
29950: PUSH
29951: EMPTY
29952: LIST
29953: LIST
29954: LIST
29955: LIST
29956: PUSH
29957: EMPTY
29958: LIST
29959: LIST
29960: PPUSH
29961: CALL_OW 72
29965: ST_TO_ADDR
// if cranes then
29966: LD_VAR 0 6
29970: IFFALSE 30032
// for j in cranes do
29972: LD_ADDR_VAR 0 3
29976: PUSH
29977: LD_VAR 0 6
29981: PUSH
29982: FOR_IN
29983: IFFALSE 30030
// if not IsInArea ( j , mc_parking [ i ] ) then
29985: LD_VAR 0 3
29989: PPUSH
29990: LD_EXP 117
29994: PUSH
29995: LD_VAR 0 2
29999: ARRAY
30000: PPUSH
30001: CALL_OW 308
30005: NOT
30006: IFFALSE 30028
// ComMoveToArea ( j , mc_parking [ i ] ) ;
30008: LD_VAR 0 3
30012: PPUSH
30013: LD_EXP 117
30017: PUSH
30018: LD_VAR 0 2
30022: ARRAY
30023: PPUSH
30024: CALL_OW 113
30028: GO 29982
30030: POP
30031: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
30032: LD_ADDR_EXP 95
30036: PUSH
30037: LD_EXP 95
30041: PPUSH
30042: LD_VAR 0 2
30046: PPUSH
30047: EMPTY
30048: PPUSH
30049: CALL_OW 1
30053: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
30054: LD_VAR 0 2
30058: PPUSH
30059: LD_INT 101
30061: PPUSH
30062: CALL 24956 0 2
// continue ;
30066: GO 29867
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
30068: LD_ADDR_EXP 99
30072: PUSH
30073: LD_EXP 99
30077: PPUSH
30078: LD_VAR 0 2
30082: PPUSH
30083: EMPTY
30084: PPUSH
30085: CALL_OW 1
30089: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
30090: LD_VAR 0 2
30094: PPUSH
30095: LD_INT 103
30097: PPUSH
30098: CALL 24956 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
30102: LD_ADDR_VAR 0 5
30106: PUSH
30107: LD_EXP 93
30111: PUSH
30112: LD_VAR 0 2
30116: ARRAY
30117: PUSH
30118: LD_EXP 122
30122: PUSH
30123: LD_VAR 0 2
30127: ARRAY
30128: UNION
30129: PPUSH
30130: LD_INT 2
30132: PUSH
30133: LD_INT 25
30135: PUSH
30136: LD_INT 2
30138: PUSH
30139: EMPTY
30140: LIST
30141: LIST
30142: PUSH
30143: LD_INT 25
30145: PUSH
30146: LD_INT 16
30148: PUSH
30149: EMPTY
30150: LIST
30151: LIST
30152: PUSH
30153: EMPTY
30154: LIST
30155: LIST
30156: LIST
30157: PUSH
30158: EMPTY
30159: LIST
30160: PPUSH
30161: CALL_OW 72
30165: PUSH
30166: LD_EXP 96
30170: PUSH
30171: LD_VAR 0 2
30175: ARRAY
30176: PUSH
30177: LD_INT 1
30179: ARRAY
30180: PUSH
30181: LD_EXP 96
30185: PUSH
30186: LD_VAR 0 2
30190: ARRAY
30191: PUSH
30192: LD_INT 2
30194: ARRAY
30195: UNION
30196: DIFF
30197: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
30198: LD_ADDR_VAR 0 6
30202: PUSH
30203: LD_EXP 112
30207: PUSH
30208: LD_VAR 0 2
30212: ARRAY
30213: PPUSH
30214: LD_INT 2
30216: PUSH
30217: LD_INT 34
30219: PUSH
30220: LD_INT 13
30222: PUSH
30223: EMPTY
30224: LIST
30225: LIST
30226: PUSH
30227: LD_INT 34
30229: PUSH
30230: LD_INT 52
30232: PUSH
30233: EMPTY
30234: LIST
30235: LIST
30236: PUSH
30237: LD_INT 34
30239: PUSH
30240: LD_EXP 78
30244: PUSH
30245: EMPTY
30246: LIST
30247: LIST
30248: PUSH
30249: EMPTY
30250: LIST
30251: LIST
30252: LIST
30253: LIST
30254: PPUSH
30255: CALL_OW 72
30259: ST_TO_ADDR
// if cranes then
30260: LD_VAR 0 6
30264: IFFALSE 30400
// begin for j in cranes do
30266: LD_ADDR_VAR 0 3
30270: PUSH
30271: LD_VAR 0 6
30275: PUSH
30276: FOR_IN
30277: IFFALSE 30398
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
30279: LD_VAR 0 3
30283: PPUSH
30284: CALL_OW 256
30288: PUSH
30289: LD_INT 1000
30291: EQUAL
30292: PUSH
30293: LD_VAR 0 3
30297: PPUSH
30298: CALL_OW 314
30302: NOT
30303: AND
30304: IFFALSE 30338
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
30306: LD_VAR 0 3
30310: PPUSH
30311: LD_EXP 94
30315: PUSH
30316: LD_VAR 0 2
30320: ARRAY
30321: PPUSH
30322: LD_VAR 0 3
30326: PPUSH
30327: CALL_OW 74
30331: PPUSH
30332: CALL_OW 130
30336: GO 30396
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
30338: LD_VAR 0 3
30342: PPUSH
30343: CALL_OW 256
30347: PUSH
30348: LD_INT 500
30350: LESS
30351: PUSH
30352: LD_VAR 0 3
30356: PPUSH
30357: LD_EXP 117
30361: PUSH
30362: LD_VAR 0 2
30366: ARRAY
30367: PPUSH
30368: CALL_OW 308
30372: NOT
30373: AND
30374: IFFALSE 30396
// ComMoveToArea ( j , mc_parking [ i ] ) ;
30376: LD_VAR 0 3
30380: PPUSH
30381: LD_EXP 117
30385: PUSH
30386: LD_VAR 0 2
30390: ARRAY
30391: PPUSH
30392: CALL_OW 113
// end ;
30396: GO 30276
30398: POP
30399: POP
// end ; if tmp > 3 then
30400: LD_VAR 0 5
30404: PUSH
30405: LD_INT 3
30407: GREATER
30408: IFFALSE 30428
// tmp := ShrinkArray ( tmp , 4 ) ;
30410: LD_ADDR_VAR 0 5
30414: PUSH
30415: LD_VAR 0 5
30419: PPUSH
30420: LD_INT 4
30422: PPUSH
30423: CALL 88265 0 2
30427: ST_TO_ADDR
// if not tmp then
30428: LD_VAR 0 5
30432: NOT
30433: IFFALSE 30437
// continue ;
30435: GO 29867
// for j in tmp do
30437: LD_ADDR_VAR 0 3
30441: PUSH
30442: LD_VAR 0 5
30446: PUSH
30447: FOR_IN
30448: IFFALSE 30707
// begin if IsInUnit ( j ) then
30450: LD_VAR 0 3
30454: PPUSH
30455: CALL_OW 310
30459: IFFALSE 30470
// ComExitBuilding ( j ) ;
30461: LD_VAR 0 3
30465: PPUSH
30466: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
30470: LD_VAR 0 3
30474: PUSH
30475: LD_EXP 95
30479: PUSH
30480: LD_VAR 0 2
30484: ARRAY
30485: IN
30486: NOT
30487: IFFALSE 30545
// begin SetTag ( j , 101 ) ;
30489: LD_VAR 0 3
30493: PPUSH
30494: LD_INT 101
30496: PPUSH
30497: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
30501: LD_ADDR_EXP 95
30505: PUSH
30506: LD_EXP 95
30510: PPUSH
30511: LD_VAR 0 2
30515: PUSH
30516: LD_EXP 95
30520: PUSH
30521: LD_VAR 0 2
30525: ARRAY
30526: PUSH
30527: LD_INT 1
30529: PLUS
30530: PUSH
30531: EMPTY
30532: LIST
30533: LIST
30534: PPUSH
30535: LD_VAR 0 3
30539: PPUSH
30540: CALL 56198 0 3
30544: ST_TO_ADDR
// end ; wait ( 1 ) ;
30545: LD_INT 1
30547: PPUSH
30548: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
30552: LD_ADDR_VAR 0 7
30556: PUSH
30557: LD_EXP 94
30561: PUSH
30562: LD_VAR 0 2
30566: ARRAY
30567: ST_TO_ADDR
// if mc_scan [ i ] then
30568: LD_EXP 116
30572: PUSH
30573: LD_VAR 0 2
30577: ARRAY
30578: IFFALSE 30640
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
30580: LD_ADDR_VAR 0 7
30584: PUSH
30585: LD_EXP 94
30589: PUSH
30590: LD_VAR 0 2
30594: ARRAY
30595: PPUSH
30596: LD_INT 3
30598: PUSH
30599: LD_INT 30
30601: PUSH
30602: LD_INT 32
30604: PUSH
30605: EMPTY
30606: LIST
30607: LIST
30608: PUSH
30609: LD_INT 30
30611: PUSH
30612: LD_INT 33
30614: PUSH
30615: EMPTY
30616: LIST
30617: LIST
30618: PUSH
30619: LD_INT 30
30621: PUSH
30622: LD_INT 31
30624: PUSH
30625: EMPTY
30626: LIST
30627: LIST
30628: PUSH
30629: EMPTY
30630: LIST
30631: LIST
30632: LIST
30633: LIST
30634: PPUSH
30635: CALL_OW 72
30639: ST_TO_ADDR
// if not to_repair_tmp then
30640: LD_VAR 0 7
30644: NOT
30645: IFFALSE 30649
// continue ;
30647: GO 30447
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
30649: LD_ADDR_VAR 0 8
30653: PUSH
30654: LD_VAR 0 7
30658: PPUSH
30659: LD_VAR 0 3
30663: PPUSH
30664: CALL_OW 74
30668: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
30669: LD_VAR 0 8
30673: PPUSH
30674: LD_INT 16
30676: PPUSH
30677: CALL 58797 0 2
30681: PUSH
30682: LD_INT 4
30684: ARRAY
30685: PUSH
30686: LD_INT 10
30688: LESS
30689: IFFALSE 30705
// ComRepairBuilding ( j , to_repair ) ;
30691: LD_VAR 0 3
30695: PPUSH
30696: LD_VAR 0 8
30700: PPUSH
30701: CALL_OW 130
// end ;
30705: GO 30447
30707: POP
30708: POP
// end ;
30709: GO 29867
30711: POP
30712: POP
// end ;
30713: LD_VAR 0 1
30717: RET
// export function MC_Heal ; var i , j , tmp ; begin
30718: LD_INT 0
30720: PPUSH
30721: PPUSH
30722: PPUSH
30723: PPUSH
// if not mc_bases then
30724: LD_EXP 93
30728: NOT
30729: IFFALSE 30733
// exit ;
30731: GO 31135
// for i = 1 to mc_bases do
30733: LD_ADDR_VAR 0 2
30737: PUSH
30738: DOUBLE
30739: LD_INT 1
30741: DEC
30742: ST_TO_ADDR
30743: LD_EXP 93
30747: PUSH
30748: FOR_TO
30749: IFFALSE 31133
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
30751: LD_EXP 96
30755: PUSH
30756: LD_VAR 0 2
30760: ARRAY
30761: PUSH
30762: LD_INT 1
30764: ARRAY
30765: NOT
30766: PUSH
30767: LD_EXP 96
30771: PUSH
30772: LD_VAR 0 2
30776: ARRAY
30777: PUSH
30778: LD_INT 2
30780: ARRAY
30781: NOT
30782: AND
30783: IFFALSE 30821
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
30785: LD_ADDR_EXP 97
30789: PUSH
30790: LD_EXP 97
30794: PPUSH
30795: LD_VAR 0 2
30799: PPUSH
30800: EMPTY
30801: PPUSH
30802: CALL_OW 1
30806: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
30807: LD_VAR 0 2
30811: PPUSH
30812: LD_INT 102
30814: PPUSH
30815: CALL 24956 0 2
// continue ;
30819: GO 30748
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
30821: LD_ADDR_VAR 0 4
30825: PUSH
30826: LD_EXP 93
30830: PUSH
30831: LD_VAR 0 2
30835: ARRAY
30836: PPUSH
30837: LD_INT 25
30839: PUSH
30840: LD_INT 4
30842: PUSH
30843: EMPTY
30844: LIST
30845: LIST
30846: PPUSH
30847: CALL_OW 72
30851: ST_TO_ADDR
// if not tmp then
30852: LD_VAR 0 4
30856: NOT
30857: IFFALSE 30861
// continue ;
30859: GO 30748
// if mc_taming [ i ] then
30861: LD_EXP 124
30865: PUSH
30866: LD_VAR 0 2
30870: ARRAY
30871: IFFALSE 30895
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
30873: LD_ADDR_EXP 124
30877: PUSH
30878: LD_EXP 124
30882: PPUSH
30883: LD_VAR 0 2
30887: PPUSH
30888: EMPTY
30889: PPUSH
30890: CALL_OW 1
30894: ST_TO_ADDR
// for j in tmp do
30895: LD_ADDR_VAR 0 3
30899: PUSH
30900: LD_VAR 0 4
30904: PUSH
30905: FOR_IN
30906: IFFALSE 31129
// begin if IsInUnit ( j ) then
30908: LD_VAR 0 3
30912: PPUSH
30913: CALL_OW 310
30917: IFFALSE 30928
// ComExitBuilding ( j ) ;
30919: LD_VAR 0 3
30923: PPUSH
30924: CALL_OW 122
// if not j in mc_healers [ i ] then
30928: LD_VAR 0 3
30932: PUSH
30933: LD_EXP 97
30937: PUSH
30938: LD_VAR 0 2
30942: ARRAY
30943: IN
30944: NOT
30945: IFFALSE 30991
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
30947: LD_ADDR_EXP 97
30951: PUSH
30952: LD_EXP 97
30956: PPUSH
30957: LD_VAR 0 2
30961: PUSH
30962: LD_EXP 97
30966: PUSH
30967: LD_VAR 0 2
30971: ARRAY
30972: PUSH
30973: LD_INT 1
30975: PLUS
30976: PUSH
30977: EMPTY
30978: LIST
30979: LIST
30980: PPUSH
30981: LD_VAR 0 3
30985: PPUSH
30986: CALL 56198 0 3
30990: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
30991: LD_VAR 0 3
30995: PPUSH
30996: CALL_OW 110
31000: PUSH
31001: LD_INT 102
31003: NONEQUAL
31004: IFFALSE 31018
// SetTag ( j , 102 ) ;
31006: LD_VAR 0 3
31010: PPUSH
31011: LD_INT 102
31013: PPUSH
31014: CALL_OW 109
// Wait ( 3 ) ;
31018: LD_INT 3
31020: PPUSH
31021: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
31025: LD_EXP 96
31029: PUSH
31030: LD_VAR 0 2
31034: ARRAY
31035: PUSH
31036: LD_INT 1
31038: ARRAY
31039: IFFALSE 31071
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
31041: LD_VAR 0 3
31045: PPUSH
31046: LD_EXP 96
31050: PUSH
31051: LD_VAR 0 2
31055: ARRAY
31056: PUSH
31057: LD_INT 1
31059: ARRAY
31060: PUSH
31061: LD_INT 1
31063: ARRAY
31064: PPUSH
31065: CALL_OW 128
31069: GO 31127
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
31071: LD_VAR 0 3
31075: PPUSH
31076: CALL_OW 314
31080: NOT
31081: PUSH
31082: LD_EXP 96
31086: PUSH
31087: LD_VAR 0 2
31091: ARRAY
31092: PUSH
31093: LD_INT 2
31095: ARRAY
31096: AND
31097: IFFALSE 31127
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
31099: LD_VAR 0 3
31103: PPUSH
31104: LD_EXP 96
31108: PUSH
31109: LD_VAR 0 2
31113: ARRAY
31114: PUSH
31115: LD_INT 2
31117: ARRAY
31118: PUSH
31119: LD_INT 1
31121: ARRAY
31122: PPUSH
31123: CALL_OW 128
// end ;
31127: GO 30905
31129: POP
31130: POP
// end ;
31131: GO 30748
31133: POP
31134: POP
// end ;
31135: LD_VAR 0 1
31139: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
31140: LD_INT 0
31142: PPUSH
31143: PPUSH
31144: PPUSH
31145: PPUSH
31146: PPUSH
// if not mc_bases then
31147: LD_EXP 93
31151: NOT
31152: IFFALSE 31156
// exit ;
31154: GO 32327
// for i = 1 to mc_bases do
31156: LD_ADDR_VAR 0 2
31160: PUSH
31161: DOUBLE
31162: LD_INT 1
31164: DEC
31165: ST_TO_ADDR
31166: LD_EXP 93
31170: PUSH
31171: FOR_TO
31172: IFFALSE 32325
// begin if mc_scan [ i ] then
31174: LD_EXP 116
31178: PUSH
31179: LD_VAR 0 2
31183: ARRAY
31184: IFFALSE 31188
// continue ;
31186: GO 31171
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
31188: LD_EXP 98
31192: PUSH
31193: LD_VAR 0 2
31197: ARRAY
31198: NOT
31199: PUSH
31200: LD_EXP 100
31204: PUSH
31205: LD_VAR 0 2
31209: ARRAY
31210: NOT
31211: AND
31212: PUSH
31213: LD_EXP 99
31217: PUSH
31218: LD_VAR 0 2
31222: ARRAY
31223: AND
31224: IFFALSE 31262
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
31226: LD_ADDR_EXP 99
31230: PUSH
31231: LD_EXP 99
31235: PPUSH
31236: LD_VAR 0 2
31240: PPUSH
31241: EMPTY
31242: PPUSH
31243: CALL_OW 1
31247: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
31248: LD_VAR 0 2
31252: PPUSH
31253: LD_INT 103
31255: PPUSH
31256: CALL 24956 0 2
// continue ;
31260: GO 31171
// end ; if mc_construct_list [ i ] then
31262: LD_EXP 100
31266: PUSH
31267: LD_VAR 0 2
31271: ARRAY
31272: IFFALSE 31492
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31274: LD_ADDR_VAR 0 4
31278: PUSH
31279: LD_EXP 93
31283: PUSH
31284: LD_VAR 0 2
31288: ARRAY
31289: PPUSH
31290: LD_INT 25
31292: PUSH
31293: LD_INT 2
31295: PUSH
31296: EMPTY
31297: LIST
31298: LIST
31299: PPUSH
31300: CALL_OW 72
31304: PUSH
31305: LD_EXP 95
31309: PUSH
31310: LD_VAR 0 2
31314: ARRAY
31315: DIFF
31316: ST_TO_ADDR
// if not tmp then
31317: LD_VAR 0 4
31321: NOT
31322: IFFALSE 31326
// continue ;
31324: GO 31171
// for j in tmp do
31326: LD_ADDR_VAR 0 3
31330: PUSH
31331: LD_VAR 0 4
31335: PUSH
31336: FOR_IN
31337: IFFALSE 31488
// begin if not mc_builders [ i ] then
31339: LD_EXP 99
31343: PUSH
31344: LD_VAR 0 2
31348: ARRAY
31349: NOT
31350: IFFALSE 31408
// begin SetTag ( j , 103 ) ;
31352: LD_VAR 0 3
31356: PPUSH
31357: LD_INT 103
31359: PPUSH
31360: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31364: LD_ADDR_EXP 99
31368: PUSH
31369: LD_EXP 99
31373: PPUSH
31374: LD_VAR 0 2
31378: PUSH
31379: LD_EXP 99
31383: PUSH
31384: LD_VAR 0 2
31388: ARRAY
31389: PUSH
31390: LD_INT 1
31392: PLUS
31393: PUSH
31394: EMPTY
31395: LIST
31396: LIST
31397: PPUSH
31398: LD_VAR 0 3
31402: PPUSH
31403: CALL 56198 0 3
31407: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31408: LD_VAR 0 3
31412: PPUSH
31413: CALL_OW 310
31417: IFFALSE 31428
// ComExitBuilding ( j ) ;
31419: LD_VAR 0 3
31423: PPUSH
31424: CALL_OW 122
// wait ( 3 ) ;
31428: LD_INT 3
31430: PPUSH
31431: CALL_OW 67
// if not mc_construct_list [ i ] then
31435: LD_EXP 100
31439: PUSH
31440: LD_VAR 0 2
31444: ARRAY
31445: NOT
31446: IFFALSE 31450
// break ;
31448: GO 31488
// if not HasTask ( j ) then
31450: LD_VAR 0 3
31454: PPUSH
31455: CALL_OW 314
31459: NOT
31460: IFFALSE 31486
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
31462: LD_VAR 0 3
31466: PPUSH
31467: LD_EXP 100
31471: PUSH
31472: LD_VAR 0 2
31476: ARRAY
31477: PUSH
31478: LD_INT 1
31480: ARRAY
31481: PPUSH
31482: CALL 59061 0 2
// end ;
31486: GO 31336
31488: POP
31489: POP
// end else
31490: GO 32323
// if mc_build_list [ i ] then
31492: LD_EXP 98
31496: PUSH
31497: LD_VAR 0 2
31501: ARRAY
31502: IFFALSE 32323
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31504: LD_ADDR_VAR 0 5
31508: PUSH
31509: LD_EXP 93
31513: PUSH
31514: LD_VAR 0 2
31518: ARRAY
31519: PPUSH
31520: LD_INT 2
31522: PUSH
31523: LD_INT 30
31525: PUSH
31526: LD_INT 0
31528: PUSH
31529: EMPTY
31530: LIST
31531: LIST
31532: PUSH
31533: LD_INT 30
31535: PUSH
31536: LD_INT 1
31538: PUSH
31539: EMPTY
31540: LIST
31541: LIST
31542: PUSH
31543: EMPTY
31544: LIST
31545: LIST
31546: LIST
31547: PPUSH
31548: CALL_OW 72
31552: ST_TO_ADDR
// if depot then
31553: LD_VAR 0 5
31557: IFFALSE 31575
// depot := depot [ 1 ] else
31559: LD_ADDR_VAR 0 5
31563: PUSH
31564: LD_VAR 0 5
31568: PUSH
31569: LD_INT 1
31571: ARRAY
31572: ST_TO_ADDR
31573: GO 31583
// depot := 0 ;
31575: LD_ADDR_VAR 0 5
31579: PUSH
31580: LD_INT 0
31582: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
31583: LD_EXP 98
31587: PUSH
31588: LD_VAR 0 2
31592: ARRAY
31593: PUSH
31594: LD_INT 1
31596: ARRAY
31597: PUSH
31598: LD_INT 1
31600: ARRAY
31601: PPUSH
31602: CALL 58885 0 1
31606: PUSH
31607: LD_EXP 93
31611: PUSH
31612: LD_VAR 0 2
31616: ARRAY
31617: PPUSH
31618: LD_INT 2
31620: PUSH
31621: LD_INT 30
31623: PUSH
31624: LD_INT 2
31626: PUSH
31627: EMPTY
31628: LIST
31629: LIST
31630: PUSH
31631: LD_INT 30
31633: PUSH
31634: LD_INT 3
31636: PUSH
31637: EMPTY
31638: LIST
31639: LIST
31640: PUSH
31641: EMPTY
31642: LIST
31643: LIST
31644: LIST
31645: PPUSH
31646: CALL_OW 72
31650: NOT
31651: AND
31652: IFFALSE 31757
// begin for j = 1 to mc_build_list [ i ] do
31654: LD_ADDR_VAR 0 3
31658: PUSH
31659: DOUBLE
31660: LD_INT 1
31662: DEC
31663: ST_TO_ADDR
31664: LD_EXP 98
31668: PUSH
31669: LD_VAR 0 2
31673: ARRAY
31674: PUSH
31675: FOR_TO
31676: IFFALSE 31755
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
31678: LD_EXP 98
31682: PUSH
31683: LD_VAR 0 2
31687: ARRAY
31688: PUSH
31689: LD_VAR 0 3
31693: ARRAY
31694: PUSH
31695: LD_INT 1
31697: ARRAY
31698: PUSH
31699: LD_INT 2
31701: EQUAL
31702: IFFALSE 31753
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
31704: LD_ADDR_EXP 98
31708: PUSH
31709: LD_EXP 98
31713: PPUSH
31714: LD_VAR 0 2
31718: PPUSH
31719: LD_EXP 98
31723: PUSH
31724: LD_VAR 0 2
31728: ARRAY
31729: PPUSH
31730: LD_VAR 0 3
31734: PPUSH
31735: LD_INT 1
31737: PPUSH
31738: LD_INT 0
31740: PPUSH
31741: CALL 55616 0 4
31745: PPUSH
31746: CALL_OW 1
31750: ST_TO_ADDR
// break ;
31751: GO 31755
// end ;
31753: GO 31675
31755: POP
31756: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
31757: LD_EXP 98
31761: PUSH
31762: LD_VAR 0 2
31766: ARRAY
31767: PUSH
31768: LD_INT 1
31770: ARRAY
31771: PUSH
31772: LD_INT 1
31774: ARRAY
31775: PUSH
31776: LD_INT 0
31778: EQUAL
31779: PUSH
31780: LD_VAR 0 5
31784: PUSH
31785: LD_VAR 0 5
31789: PPUSH
31790: LD_EXP 98
31794: PUSH
31795: LD_VAR 0 2
31799: ARRAY
31800: PUSH
31801: LD_INT 1
31803: ARRAY
31804: PUSH
31805: LD_INT 1
31807: ARRAY
31808: PPUSH
31809: LD_EXP 98
31813: PUSH
31814: LD_VAR 0 2
31818: ARRAY
31819: PUSH
31820: LD_INT 1
31822: ARRAY
31823: PUSH
31824: LD_INT 2
31826: ARRAY
31827: PPUSH
31828: LD_EXP 98
31832: PUSH
31833: LD_VAR 0 2
31837: ARRAY
31838: PUSH
31839: LD_INT 1
31841: ARRAY
31842: PUSH
31843: LD_INT 3
31845: ARRAY
31846: PPUSH
31847: LD_EXP 98
31851: PUSH
31852: LD_VAR 0 2
31856: ARRAY
31857: PUSH
31858: LD_INT 1
31860: ARRAY
31861: PUSH
31862: LD_INT 4
31864: ARRAY
31865: PPUSH
31866: CALL 64302 0 5
31870: AND
31871: OR
31872: IFFALSE 32153
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31874: LD_ADDR_VAR 0 4
31878: PUSH
31879: LD_EXP 93
31883: PUSH
31884: LD_VAR 0 2
31888: ARRAY
31889: PPUSH
31890: LD_INT 25
31892: PUSH
31893: LD_INT 2
31895: PUSH
31896: EMPTY
31897: LIST
31898: LIST
31899: PPUSH
31900: CALL_OW 72
31904: PUSH
31905: LD_EXP 95
31909: PUSH
31910: LD_VAR 0 2
31914: ARRAY
31915: DIFF
31916: ST_TO_ADDR
// if not tmp then
31917: LD_VAR 0 4
31921: NOT
31922: IFFALSE 31926
// continue ;
31924: GO 31171
// for j in tmp do
31926: LD_ADDR_VAR 0 3
31930: PUSH
31931: LD_VAR 0 4
31935: PUSH
31936: FOR_IN
31937: IFFALSE 32149
// begin if not mc_builders [ i ] then
31939: LD_EXP 99
31943: PUSH
31944: LD_VAR 0 2
31948: ARRAY
31949: NOT
31950: IFFALSE 32008
// begin SetTag ( j , 103 ) ;
31952: LD_VAR 0 3
31956: PPUSH
31957: LD_INT 103
31959: PPUSH
31960: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31964: LD_ADDR_EXP 99
31968: PUSH
31969: LD_EXP 99
31973: PPUSH
31974: LD_VAR 0 2
31978: PUSH
31979: LD_EXP 99
31983: PUSH
31984: LD_VAR 0 2
31988: ARRAY
31989: PUSH
31990: LD_INT 1
31992: PLUS
31993: PUSH
31994: EMPTY
31995: LIST
31996: LIST
31997: PPUSH
31998: LD_VAR 0 3
32002: PPUSH
32003: CALL 56198 0 3
32007: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
32008: LD_VAR 0 3
32012: PPUSH
32013: CALL_OW 310
32017: IFFALSE 32028
// ComExitBuilding ( j ) ;
32019: LD_VAR 0 3
32023: PPUSH
32024: CALL_OW 122
// wait ( 3 ) ;
32028: LD_INT 3
32030: PPUSH
32031: CALL_OW 67
// if not mc_build_list [ i ] then
32035: LD_EXP 98
32039: PUSH
32040: LD_VAR 0 2
32044: ARRAY
32045: NOT
32046: IFFALSE 32050
// break ;
32048: GO 32149
// if not HasTask ( j ) then
32050: LD_VAR 0 3
32054: PPUSH
32055: CALL_OW 314
32059: NOT
32060: IFFALSE 32147
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
32062: LD_VAR 0 3
32066: PPUSH
32067: LD_EXP 98
32071: PUSH
32072: LD_VAR 0 2
32076: ARRAY
32077: PUSH
32078: LD_INT 1
32080: ARRAY
32081: PUSH
32082: LD_INT 1
32084: ARRAY
32085: PPUSH
32086: LD_EXP 98
32090: PUSH
32091: LD_VAR 0 2
32095: ARRAY
32096: PUSH
32097: LD_INT 1
32099: ARRAY
32100: PUSH
32101: LD_INT 2
32103: ARRAY
32104: PPUSH
32105: LD_EXP 98
32109: PUSH
32110: LD_VAR 0 2
32114: ARRAY
32115: PUSH
32116: LD_INT 1
32118: ARRAY
32119: PUSH
32120: LD_INT 3
32122: ARRAY
32123: PPUSH
32124: LD_EXP 98
32128: PUSH
32129: LD_VAR 0 2
32133: ARRAY
32134: PUSH
32135: LD_INT 1
32137: ARRAY
32138: PUSH
32139: LD_INT 4
32141: ARRAY
32142: PPUSH
32143: CALL_OW 145
// end ;
32147: GO 31936
32149: POP
32150: POP
// end else
32151: GO 32323
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
32153: LD_EXP 93
32157: PUSH
32158: LD_VAR 0 2
32162: ARRAY
32163: PPUSH
32164: LD_EXP 98
32168: PUSH
32169: LD_VAR 0 2
32173: ARRAY
32174: PUSH
32175: LD_INT 1
32177: ARRAY
32178: PUSH
32179: LD_INT 1
32181: ARRAY
32182: PPUSH
32183: LD_EXP 98
32187: PUSH
32188: LD_VAR 0 2
32192: ARRAY
32193: PUSH
32194: LD_INT 1
32196: ARRAY
32197: PUSH
32198: LD_INT 2
32200: ARRAY
32201: PPUSH
32202: LD_EXP 98
32206: PUSH
32207: LD_VAR 0 2
32211: ARRAY
32212: PUSH
32213: LD_INT 1
32215: ARRAY
32216: PUSH
32217: LD_INT 3
32219: ARRAY
32220: PPUSH
32221: LD_EXP 98
32225: PUSH
32226: LD_VAR 0 2
32230: ARRAY
32231: PUSH
32232: LD_INT 1
32234: ARRAY
32235: PUSH
32236: LD_INT 4
32238: ARRAY
32239: PPUSH
32240: LD_EXP 93
32244: PUSH
32245: LD_VAR 0 2
32249: ARRAY
32250: PPUSH
32251: LD_INT 21
32253: PUSH
32254: LD_INT 3
32256: PUSH
32257: EMPTY
32258: LIST
32259: LIST
32260: PPUSH
32261: CALL_OW 72
32265: PPUSH
32266: EMPTY
32267: PPUSH
32268: CALL 63052 0 7
32272: NOT
32273: IFFALSE 32323
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
32275: LD_ADDR_EXP 98
32279: PUSH
32280: LD_EXP 98
32284: PPUSH
32285: LD_VAR 0 2
32289: PPUSH
32290: LD_EXP 98
32294: PUSH
32295: LD_VAR 0 2
32299: ARRAY
32300: PPUSH
32301: LD_INT 1
32303: PPUSH
32304: LD_INT 1
32306: NEG
32307: PPUSH
32308: LD_INT 0
32310: PPUSH
32311: CALL 55616 0 4
32315: PPUSH
32316: CALL_OW 1
32320: ST_TO_ADDR
// continue ;
32321: GO 31171
// end ; end ; end ;
32323: GO 31171
32325: POP
32326: POP
// end ;
32327: LD_VAR 0 1
32331: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
32332: LD_INT 0
32334: PPUSH
32335: PPUSH
32336: PPUSH
32337: PPUSH
32338: PPUSH
32339: PPUSH
// if not mc_bases then
32340: LD_EXP 93
32344: NOT
32345: IFFALSE 32349
// exit ;
32347: GO 32776
// for i = 1 to mc_bases do
32349: LD_ADDR_VAR 0 2
32353: PUSH
32354: DOUBLE
32355: LD_INT 1
32357: DEC
32358: ST_TO_ADDR
32359: LD_EXP 93
32363: PUSH
32364: FOR_TO
32365: IFFALSE 32774
// begin tmp := mc_build_upgrade [ i ] ;
32367: LD_ADDR_VAR 0 4
32371: PUSH
32372: LD_EXP 125
32376: PUSH
32377: LD_VAR 0 2
32381: ARRAY
32382: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
32383: LD_ADDR_VAR 0 6
32387: PUSH
32388: LD_EXP 126
32392: PUSH
32393: LD_VAR 0 2
32397: ARRAY
32398: PPUSH
32399: LD_INT 2
32401: PUSH
32402: LD_INT 30
32404: PUSH
32405: LD_INT 6
32407: PUSH
32408: EMPTY
32409: LIST
32410: LIST
32411: PUSH
32412: LD_INT 30
32414: PUSH
32415: LD_INT 7
32417: PUSH
32418: EMPTY
32419: LIST
32420: LIST
32421: PUSH
32422: EMPTY
32423: LIST
32424: LIST
32425: LIST
32426: PPUSH
32427: CALL_OW 72
32431: ST_TO_ADDR
// if not tmp and not lab then
32432: LD_VAR 0 4
32436: NOT
32437: PUSH
32438: LD_VAR 0 6
32442: NOT
32443: AND
32444: IFFALSE 32448
// continue ;
32446: GO 32364
// if tmp then
32448: LD_VAR 0 4
32452: IFFALSE 32572
// for j in tmp do
32454: LD_ADDR_VAR 0 3
32458: PUSH
32459: LD_VAR 0 4
32463: PUSH
32464: FOR_IN
32465: IFFALSE 32570
// begin if UpgradeCost ( j ) then
32467: LD_VAR 0 3
32471: PPUSH
32472: CALL 62712 0 1
32476: IFFALSE 32568
// begin ComUpgrade ( j ) ;
32478: LD_VAR 0 3
32482: PPUSH
32483: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
32487: LD_ADDR_EXP 125
32491: PUSH
32492: LD_EXP 125
32496: PPUSH
32497: LD_VAR 0 2
32501: PPUSH
32502: LD_EXP 125
32506: PUSH
32507: LD_VAR 0 2
32511: ARRAY
32512: PUSH
32513: LD_VAR 0 3
32517: DIFF
32518: PPUSH
32519: CALL_OW 1
32523: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
32524: LD_ADDR_EXP 100
32528: PUSH
32529: LD_EXP 100
32533: PPUSH
32534: LD_VAR 0 2
32538: PUSH
32539: LD_EXP 100
32543: PUSH
32544: LD_VAR 0 2
32548: ARRAY
32549: PUSH
32550: LD_INT 1
32552: PLUS
32553: PUSH
32554: EMPTY
32555: LIST
32556: LIST
32557: PPUSH
32558: LD_VAR 0 3
32562: PPUSH
32563: CALL 56198 0 3
32567: ST_TO_ADDR
// end ; end ;
32568: GO 32464
32570: POP
32571: POP
// if not lab or not mc_lab_upgrade [ i ] then
32572: LD_VAR 0 6
32576: NOT
32577: PUSH
32578: LD_EXP 127
32582: PUSH
32583: LD_VAR 0 2
32587: ARRAY
32588: NOT
32589: OR
32590: IFFALSE 32594
// continue ;
32592: GO 32364
// for j in lab do
32594: LD_ADDR_VAR 0 3
32598: PUSH
32599: LD_VAR 0 6
32603: PUSH
32604: FOR_IN
32605: IFFALSE 32770
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
32607: LD_VAR 0 3
32611: PPUSH
32612: CALL_OW 266
32616: PUSH
32617: LD_INT 6
32619: PUSH
32620: LD_INT 7
32622: PUSH
32623: EMPTY
32624: LIST
32625: LIST
32626: IN
32627: PUSH
32628: LD_VAR 0 3
32632: PPUSH
32633: CALL_OW 461
32637: PUSH
32638: LD_INT 1
32640: NONEQUAL
32641: AND
32642: IFFALSE 32768
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
32644: LD_VAR 0 3
32648: PPUSH
32649: LD_EXP 127
32653: PUSH
32654: LD_VAR 0 2
32658: ARRAY
32659: PUSH
32660: LD_INT 1
32662: ARRAY
32663: PPUSH
32664: CALL 62917 0 2
32668: IFFALSE 32768
// begin ComCancel ( j ) ;
32670: LD_VAR 0 3
32674: PPUSH
32675: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
32679: LD_VAR 0 3
32683: PPUSH
32684: LD_EXP 127
32688: PUSH
32689: LD_VAR 0 2
32693: ARRAY
32694: PUSH
32695: LD_INT 1
32697: ARRAY
32698: PPUSH
32699: CALL_OW 207
// if not j in mc_construct_list [ i ] then
32703: LD_VAR 0 3
32707: PUSH
32708: LD_EXP 100
32712: PUSH
32713: LD_VAR 0 2
32717: ARRAY
32718: IN
32719: NOT
32720: IFFALSE 32766
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
32722: LD_ADDR_EXP 100
32726: PUSH
32727: LD_EXP 100
32731: PPUSH
32732: LD_VAR 0 2
32736: PUSH
32737: LD_EXP 100
32741: PUSH
32742: LD_VAR 0 2
32746: ARRAY
32747: PUSH
32748: LD_INT 1
32750: PLUS
32751: PUSH
32752: EMPTY
32753: LIST
32754: LIST
32755: PPUSH
32756: LD_VAR 0 3
32760: PPUSH
32761: CALL 56198 0 3
32765: ST_TO_ADDR
// break ;
32766: GO 32770
// end ; end ; end ;
32768: GO 32604
32770: POP
32771: POP
// end ;
32772: GO 32364
32774: POP
32775: POP
// end ;
32776: LD_VAR 0 1
32780: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
32781: LD_INT 0
32783: PPUSH
32784: PPUSH
32785: PPUSH
32786: PPUSH
32787: PPUSH
32788: PPUSH
32789: PPUSH
32790: PPUSH
32791: PPUSH
// if not mc_bases then
32792: LD_EXP 93
32796: NOT
32797: IFFALSE 32801
// exit ;
32799: GO 33206
// for i = 1 to mc_bases do
32801: LD_ADDR_VAR 0 2
32805: PUSH
32806: DOUBLE
32807: LD_INT 1
32809: DEC
32810: ST_TO_ADDR
32811: LD_EXP 93
32815: PUSH
32816: FOR_TO
32817: IFFALSE 33204
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
32819: LD_EXP 101
32823: PUSH
32824: LD_VAR 0 2
32828: ARRAY
32829: NOT
32830: PUSH
32831: LD_EXP 93
32835: PUSH
32836: LD_VAR 0 2
32840: ARRAY
32841: PPUSH
32842: LD_INT 30
32844: PUSH
32845: LD_INT 3
32847: PUSH
32848: EMPTY
32849: LIST
32850: LIST
32851: PPUSH
32852: CALL_OW 72
32856: NOT
32857: OR
32858: IFFALSE 32862
// continue ;
32860: GO 32816
// busy := false ;
32862: LD_ADDR_VAR 0 8
32866: PUSH
32867: LD_INT 0
32869: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32870: LD_ADDR_VAR 0 4
32874: PUSH
32875: LD_EXP 93
32879: PUSH
32880: LD_VAR 0 2
32884: ARRAY
32885: PPUSH
32886: LD_INT 30
32888: PUSH
32889: LD_INT 3
32891: PUSH
32892: EMPTY
32893: LIST
32894: LIST
32895: PPUSH
32896: CALL_OW 72
32900: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
32901: LD_ADDR_VAR 0 6
32905: PUSH
32906: LD_EXP 101
32910: PUSH
32911: LD_VAR 0 2
32915: ARRAY
32916: PPUSH
32917: LD_INT 2
32919: PUSH
32920: LD_INT 30
32922: PUSH
32923: LD_INT 32
32925: PUSH
32926: EMPTY
32927: LIST
32928: LIST
32929: PUSH
32930: LD_INT 30
32932: PUSH
32933: LD_INT 33
32935: PUSH
32936: EMPTY
32937: LIST
32938: LIST
32939: PUSH
32940: EMPTY
32941: LIST
32942: LIST
32943: LIST
32944: PPUSH
32945: CALL_OW 72
32949: ST_TO_ADDR
// if not t then
32950: LD_VAR 0 6
32954: NOT
32955: IFFALSE 32959
// continue ;
32957: GO 32816
// for j in tmp do
32959: LD_ADDR_VAR 0 3
32963: PUSH
32964: LD_VAR 0 4
32968: PUSH
32969: FOR_IN
32970: IFFALSE 33000
// if not BuildingStatus ( j ) = bs_idle then
32972: LD_VAR 0 3
32976: PPUSH
32977: CALL_OW 461
32981: PUSH
32982: LD_INT 2
32984: EQUAL
32985: NOT
32986: IFFALSE 32998
// begin busy := true ;
32988: LD_ADDR_VAR 0 8
32992: PUSH
32993: LD_INT 1
32995: ST_TO_ADDR
// break ;
32996: GO 33000
// end ;
32998: GO 32969
33000: POP
33001: POP
// if busy then
33002: LD_VAR 0 8
33006: IFFALSE 33010
// continue ;
33008: GO 32816
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
33010: LD_ADDR_VAR 0 7
33014: PUSH
33015: LD_VAR 0 6
33019: PPUSH
33020: LD_INT 35
33022: PUSH
33023: LD_INT 0
33025: PUSH
33026: EMPTY
33027: LIST
33028: LIST
33029: PPUSH
33030: CALL_OW 72
33034: ST_TO_ADDR
// if tw then
33035: LD_VAR 0 7
33039: IFFALSE 33116
// begin tw := tw [ 1 ] ;
33041: LD_ADDR_VAR 0 7
33045: PUSH
33046: LD_VAR 0 7
33050: PUSH
33051: LD_INT 1
33053: ARRAY
33054: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
33055: LD_ADDR_VAR 0 9
33059: PUSH
33060: LD_VAR 0 7
33064: PPUSH
33065: LD_EXP 118
33069: PUSH
33070: LD_VAR 0 2
33074: ARRAY
33075: PPUSH
33076: CALL 61209 0 2
33080: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
33081: LD_EXP 132
33085: PUSH
33086: LD_VAR 0 2
33090: ARRAY
33091: IFFALSE 33114
// if not weapon in mc_allowed_tower_weapons [ i ] then
33093: LD_VAR 0 9
33097: PUSH
33098: LD_EXP 132
33102: PUSH
33103: LD_VAR 0 2
33107: ARRAY
33108: IN
33109: NOT
33110: IFFALSE 33114
// continue ;
33112: GO 32816
// end else
33114: GO 33179
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
33116: LD_ADDR_VAR 0 5
33120: PUSH
33121: LD_EXP 101
33125: PUSH
33126: LD_VAR 0 2
33130: ARRAY
33131: PPUSH
33132: LD_VAR 0 4
33136: PPUSH
33137: CALL 87498 0 2
33141: ST_TO_ADDR
// if not tmp2 then
33142: LD_VAR 0 5
33146: NOT
33147: IFFALSE 33151
// continue ;
33149: GO 32816
// tw := tmp2 [ 1 ] ;
33151: LD_ADDR_VAR 0 7
33155: PUSH
33156: LD_VAR 0 5
33160: PUSH
33161: LD_INT 1
33163: ARRAY
33164: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
33165: LD_ADDR_VAR 0 9
33169: PUSH
33170: LD_VAR 0 5
33174: PUSH
33175: LD_INT 2
33177: ARRAY
33178: ST_TO_ADDR
// end ; if not weapon then
33179: LD_VAR 0 9
33183: NOT
33184: IFFALSE 33188
// continue ;
33186: GO 32816
// ComPlaceWeapon ( tw , weapon ) ;
33188: LD_VAR 0 7
33192: PPUSH
33193: LD_VAR 0 9
33197: PPUSH
33198: CALL_OW 148
// end ;
33202: GO 32816
33204: POP
33205: POP
// end ;
33206: LD_VAR 0 1
33210: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
33211: LD_INT 0
33213: PPUSH
33214: PPUSH
33215: PPUSH
33216: PPUSH
33217: PPUSH
33218: PPUSH
33219: PPUSH
// if not mc_bases then
33220: LD_EXP 93
33224: NOT
33225: IFFALSE 33229
// exit ;
33227: GO 33997
// for i = 1 to mc_bases do
33229: LD_ADDR_VAR 0 2
33233: PUSH
33234: DOUBLE
33235: LD_INT 1
33237: DEC
33238: ST_TO_ADDR
33239: LD_EXP 93
33243: PUSH
33244: FOR_TO
33245: IFFALSE 33995
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
33247: LD_EXP 106
33251: PUSH
33252: LD_VAR 0 2
33256: ARRAY
33257: NOT
33258: PUSH
33259: LD_EXP 106
33263: PUSH
33264: LD_VAR 0 2
33268: ARRAY
33269: PUSH
33270: LD_EXP 107
33274: PUSH
33275: LD_VAR 0 2
33279: ARRAY
33280: EQUAL
33281: OR
33282: PUSH
33283: LD_EXP 116
33287: PUSH
33288: LD_VAR 0 2
33292: ARRAY
33293: OR
33294: IFFALSE 33298
// continue ;
33296: GO 33244
// if mc_miners [ i ] then
33298: LD_EXP 107
33302: PUSH
33303: LD_VAR 0 2
33307: ARRAY
33308: IFFALSE 33682
// begin for j = mc_miners [ i ] downto 1 do
33310: LD_ADDR_VAR 0 3
33314: PUSH
33315: DOUBLE
33316: LD_EXP 107
33320: PUSH
33321: LD_VAR 0 2
33325: ARRAY
33326: INC
33327: ST_TO_ADDR
33328: LD_INT 1
33330: PUSH
33331: FOR_DOWNTO
33332: IFFALSE 33680
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
33334: LD_EXP 107
33338: PUSH
33339: LD_VAR 0 2
33343: ARRAY
33344: PUSH
33345: LD_VAR 0 3
33349: ARRAY
33350: PPUSH
33351: CALL_OW 301
33355: PUSH
33356: LD_EXP 107
33360: PUSH
33361: LD_VAR 0 2
33365: ARRAY
33366: PUSH
33367: LD_VAR 0 3
33371: ARRAY
33372: PPUSH
33373: CALL_OW 257
33377: PUSH
33378: LD_INT 1
33380: NONEQUAL
33381: OR
33382: IFFALSE 33445
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
33384: LD_ADDR_VAR 0 5
33388: PUSH
33389: LD_EXP 107
33393: PUSH
33394: LD_VAR 0 2
33398: ARRAY
33399: PUSH
33400: LD_EXP 107
33404: PUSH
33405: LD_VAR 0 2
33409: ARRAY
33410: PUSH
33411: LD_VAR 0 3
33415: ARRAY
33416: DIFF
33417: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
33418: LD_ADDR_EXP 107
33422: PUSH
33423: LD_EXP 107
33427: PPUSH
33428: LD_VAR 0 2
33432: PPUSH
33433: LD_VAR 0 5
33437: PPUSH
33438: CALL_OW 1
33442: ST_TO_ADDR
// continue ;
33443: GO 33331
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
33445: LD_EXP 107
33449: PUSH
33450: LD_VAR 0 2
33454: ARRAY
33455: PUSH
33456: LD_VAR 0 3
33460: ARRAY
33461: PPUSH
33462: CALL_OW 257
33466: PUSH
33467: LD_INT 1
33469: EQUAL
33470: PUSH
33471: LD_EXP 107
33475: PUSH
33476: LD_VAR 0 2
33480: ARRAY
33481: PUSH
33482: LD_VAR 0 3
33486: ARRAY
33487: PPUSH
33488: CALL_OW 459
33492: NOT
33493: AND
33494: PUSH
33495: LD_EXP 107
33499: PUSH
33500: LD_VAR 0 2
33504: ARRAY
33505: PUSH
33506: LD_VAR 0 3
33510: ARRAY
33511: PPUSH
33512: CALL_OW 314
33516: NOT
33517: AND
33518: IFFALSE 33678
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
33520: LD_EXP 107
33524: PUSH
33525: LD_VAR 0 2
33529: ARRAY
33530: PUSH
33531: LD_VAR 0 3
33535: ARRAY
33536: PPUSH
33537: CALL_OW 310
33541: IFFALSE 33564
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
33543: LD_EXP 107
33547: PUSH
33548: LD_VAR 0 2
33552: ARRAY
33553: PUSH
33554: LD_VAR 0 3
33558: ARRAY
33559: PPUSH
33560: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
33564: LD_EXP 107
33568: PUSH
33569: LD_VAR 0 2
33573: ARRAY
33574: PUSH
33575: LD_VAR 0 3
33579: ARRAY
33580: PPUSH
33581: CALL_OW 314
33585: NOT
33586: IFFALSE 33678
// begin r := rand ( 1 , mc_mines [ i ] ) ;
33588: LD_ADDR_VAR 0 7
33592: PUSH
33593: LD_INT 1
33595: PPUSH
33596: LD_EXP 106
33600: PUSH
33601: LD_VAR 0 2
33605: ARRAY
33606: PPUSH
33607: CALL_OW 12
33611: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
33612: LD_EXP 107
33616: PUSH
33617: LD_VAR 0 2
33621: ARRAY
33622: PUSH
33623: LD_VAR 0 3
33627: ARRAY
33628: PPUSH
33629: LD_EXP 106
33633: PUSH
33634: LD_VAR 0 2
33638: ARRAY
33639: PUSH
33640: LD_VAR 0 7
33644: ARRAY
33645: PUSH
33646: LD_INT 1
33648: ARRAY
33649: PPUSH
33650: LD_EXP 106
33654: PUSH
33655: LD_VAR 0 2
33659: ARRAY
33660: PUSH
33661: LD_VAR 0 7
33665: ARRAY
33666: PUSH
33667: LD_INT 2
33669: ARRAY
33670: PPUSH
33671: LD_INT 0
33673: PPUSH
33674: CALL_OW 193
// end ; end ; end ;
33678: GO 33331
33680: POP
33681: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
33682: LD_ADDR_VAR 0 5
33686: PUSH
33687: LD_EXP 93
33691: PUSH
33692: LD_VAR 0 2
33696: ARRAY
33697: PPUSH
33698: LD_INT 2
33700: PUSH
33701: LD_INT 30
33703: PUSH
33704: LD_INT 4
33706: PUSH
33707: EMPTY
33708: LIST
33709: LIST
33710: PUSH
33711: LD_INT 30
33713: PUSH
33714: LD_INT 5
33716: PUSH
33717: EMPTY
33718: LIST
33719: LIST
33720: PUSH
33721: LD_INT 30
33723: PUSH
33724: LD_INT 32
33726: PUSH
33727: EMPTY
33728: LIST
33729: LIST
33730: PUSH
33731: EMPTY
33732: LIST
33733: LIST
33734: LIST
33735: LIST
33736: PPUSH
33737: CALL_OW 72
33741: ST_TO_ADDR
// if not tmp then
33742: LD_VAR 0 5
33746: NOT
33747: IFFALSE 33751
// continue ;
33749: GO 33244
// list := [ ] ;
33751: LD_ADDR_VAR 0 6
33755: PUSH
33756: EMPTY
33757: ST_TO_ADDR
// for j in tmp do
33758: LD_ADDR_VAR 0 3
33762: PUSH
33763: LD_VAR 0 5
33767: PUSH
33768: FOR_IN
33769: IFFALSE 33838
// begin for k in UnitsInside ( j ) do
33771: LD_ADDR_VAR 0 4
33775: PUSH
33776: LD_VAR 0 3
33780: PPUSH
33781: CALL_OW 313
33785: PUSH
33786: FOR_IN
33787: IFFALSE 33834
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
33789: LD_VAR 0 4
33793: PPUSH
33794: CALL_OW 257
33798: PUSH
33799: LD_INT 1
33801: EQUAL
33802: PUSH
33803: LD_VAR 0 4
33807: PPUSH
33808: CALL_OW 459
33812: NOT
33813: AND
33814: IFFALSE 33832
// list := list ^ k ;
33816: LD_ADDR_VAR 0 6
33820: PUSH
33821: LD_VAR 0 6
33825: PUSH
33826: LD_VAR 0 4
33830: ADD
33831: ST_TO_ADDR
33832: GO 33786
33834: POP
33835: POP
// end ;
33836: GO 33768
33838: POP
33839: POP
// list := list diff mc_miners [ i ] ;
33840: LD_ADDR_VAR 0 6
33844: PUSH
33845: LD_VAR 0 6
33849: PUSH
33850: LD_EXP 107
33854: PUSH
33855: LD_VAR 0 2
33859: ARRAY
33860: DIFF
33861: ST_TO_ADDR
// if not list then
33862: LD_VAR 0 6
33866: NOT
33867: IFFALSE 33871
// continue ;
33869: GO 33244
// k := mc_mines [ i ] - mc_miners [ i ] ;
33871: LD_ADDR_VAR 0 4
33875: PUSH
33876: LD_EXP 106
33880: PUSH
33881: LD_VAR 0 2
33885: ARRAY
33886: PUSH
33887: LD_EXP 107
33891: PUSH
33892: LD_VAR 0 2
33896: ARRAY
33897: MINUS
33898: ST_TO_ADDR
// if k > list then
33899: LD_VAR 0 4
33903: PUSH
33904: LD_VAR 0 6
33908: GREATER
33909: IFFALSE 33921
// k := list ;
33911: LD_ADDR_VAR 0 4
33915: PUSH
33916: LD_VAR 0 6
33920: ST_TO_ADDR
// for j = 1 to k do
33921: LD_ADDR_VAR 0 3
33925: PUSH
33926: DOUBLE
33927: LD_INT 1
33929: DEC
33930: ST_TO_ADDR
33931: LD_VAR 0 4
33935: PUSH
33936: FOR_TO
33937: IFFALSE 33991
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
33939: LD_ADDR_EXP 107
33943: PUSH
33944: LD_EXP 107
33948: PPUSH
33949: LD_VAR 0 2
33953: PUSH
33954: LD_EXP 107
33958: PUSH
33959: LD_VAR 0 2
33963: ARRAY
33964: PUSH
33965: LD_INT 1
33967: PLUS
33968: PUSH
33969: EMPTY
33970: LIST
33971: LIST
33972: PPUSH
33973: LD_VAR 0 6
33977: PUSH
33978: LD_VAR 0 3
33982: ARRAY
33983: PPUSH
33984: CALL 56198 0 3
33988: ST_TO_ADDR
33989: GO 33936
33991: POP
33992: POP
// end ;
33993: GO 33244
33995: POP
33996: POP
// end ;
33997: LD_VAR 0 1
34001: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
34002: LD_INT 0
34004: PPUSH
34005: PPUSH
34006: PPUSH
34007: PPUSH
34008: PPUSH
34009: PPUSH
34010: PPUSH
34011: PPUSH
34012: PPUSH
34013: PPUSH
34014: PPUSH
// if not mc_bases then
34015: LD_EXP 93
34019: NOT
34020: IFFALSE 34024
// exit ;
34022: GO 35847
// for i = 1 to mc_bases do
34024: LD_ADDR_VAR 0 2
34028: PUSH
34029: DOUBLE
34030: LD_INT 1
34032: DEC
34033: ST_TO_ADDR
34034: LD_EXP 93
34038: PUSH
34039: FOR_TO
34040: IFFALSE 35845
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
34042: LD_EXP 93
34046: PUSH
34047: LD_VAR 0 2
34051: ARRAY
34052: NOT
34053: PUSH
34054: LD_EXP 100
34058: PUSH
34059: LD_VAR 0 2
34063: ARRAY
34064: OR
34065: IFFALSE 34069
// continue ;
34067: GO 34039
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
34069: LD_EXP 109
34073: PUSH
34074: LD_VAR 0 2
34078: ARRAY
34079: NOT
34080: PUSH
34081: LD_EXP 110
34085: PUSH
34086: LD_VAR 0 2
34090: ARRAY
34091: AND
34092: IFFALSE 34130
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
34094: LD_ADDR_EXP 110
34098: PUSH
34099: LD_EXP 110
34103: PPUSH
34104: LD_VAR 0 2
34108: PPUSH
34109: EMPTY
34110: PPUSH
34111: CALL_OW 1
34115: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
34116: LD_VAR 0 2
34120: PPUSH
34121: LD_INT 107
34123: PPUSH
34124: CALL 24956 0 2
// continue ;
34128: GO 34039
// end ; target := [ ] ;
34130: LD_ADDR_VAR 0 7
34134: PUSH
34135: EMPTY
34136: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
34137: LD_ADDR_VAR 0 6
34141: PUSH
34142: LD_EXP 93
34146: PUSH
34147: LD_VAR 0 2
34151: ARRAY
34152: PUSH
34153: LD_INT 1
34155: ARRAY
34156: PPUSH
34157: CALL_OW 255
34161: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34162: LD_ADDR_VAR 0 9
34166: PUSH
34167: LD_EXP 93
34171: PUSH
34172: LD_VAR 0 2
34176: ARRAY
34177: PPUSH
34178: LD_INT 2
34180: PUSH
34181: LD_INT 30
34183: PUSH
34184: LD_INT 0
34186: PUSH
34187: EMPTY
34188: LIST
34189: LIST
34190: PUSH
34191: LD_INT 30
34193: PUSH
34194: LD_INT 1
34196: PUSH
34197: EMPTY
34198: LIST
34199: LIST
34200: PUSH
34201: EMPTY
34202: LIST
34203: LIST
34204: LIST
34205: PPUSH
34206: CALL_OW 72
34210: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
34211: LD_ADDR_VAR 0 3
34215: PUSH
34216: DOUBLE
34217: LD_EXP 109
34221: PUSH
34222: LD_VAR 0 2
34226: ARRAY
34227: INC
34228: ST_TO_ADDR
34229: LD_INT 1
34231: PUSH
34232: FOR_DOWNTO
34233: IFFALSE 34478
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
34235: LD_EXP 109
34239: PUSH
34240: LD_VAR 0 2
34244: ARRAY
34245: PUSH
34246: LD_VAR 0 3
34250: ARRAY
34251: PUSH
34252: LD_INT 2
34254: ARRAY
34255: PPUSH
34256: LD_EXP 109
34260: PUSH
34261: LD_VAR 0 2
34265: ARRAY
34266: PUSH
34267: LD_VAR 0 3
34271: ARRAY
34272: PUSH
34273: LD_INT 3
34275: ARRAY
34276: PPUSH
34277: CALL_OW 488
34281: PUSH
34282: LD_EXP 109
34286: PUSH
34287: LD_VAR 0 2
34291: ARRAY
34292: PUSH
34293: LD_VAR 0 3
34297: ARRAY
34298: PUSH
34299: LD_INT 2
34301: ARRAY
34302: PPUSH
34303: LD_EXP 109
34307: PUSH
34308: LD_VAR 0 2
34312: ARRAY
34313: PUSH
34314: LD_VAR 0 3
34318: ARRAY
34319: PUSH
34320: LD_INT 3
34322: ARRAY
34323: PPUSH
34324: CALL_OW 284
34328: PUSH
34329: LD_INT 0
34331: EQUAL
34332: AND
34333: IFFALSE 34388
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
34335: LD_ADDR_VAR 0 5
34339: PUSH
34340: LD_EXP 109
34344: PUSH
34345: LD_VAR 0 2
34349: ARRAY
34350: PPUSH
34351: LD_VAR 0 3
34355: PPUSH
34356: CALL_OW 3
34360: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
34361: LD_ADDR_EXP 109
34365: PUSH
34366: LD_EXP 109
34370: PPUSH
34371: LD_VAR 0 2
34375: PPUSH
34376: LD_VAR 0 5
34380: PPUSH
34381: CALL_OW 1
34385: ST_TO_ADDR
// continue ;
34386: GO 34232
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
34388: LD_VAR 0 6
34392: PPUSH
34393: LD_EXP 109
34397: PUSH
34398: LD_VAR 0 2
34402: ARRAY
34403: PUSH
34404: LD_VAR 0 3
34408: ARRAY
34409: PUSH
34410: LD_INT 2
34412: ARRAY
34413: PPUSH
34414: LD_EXP 109
34418: PUSH
34419: LD_VAR 0 2
34423: ARRAY
34424: PUSH
34425: LD_VAR 0 3
34429: ARRAY
34430: PUSH
34431: LD_INT 3
34433: ARRAY
34434: PPUSH
34435: LD_INT 30
34437: PPUSH
34438: CALL 57094 0 4
34442: PUSH
34443: LD_INT 4
34445: ARRAY
34446: PUSH
34447: LD_INT 0
34449: EQUAL
34450: IFFALSE 34476
// begin target := mc_crates [ i ] [ j ] ;
34452: LD_ADDR_VAR 0 7
34456: PUSH
34457: LD_EXP 109
34461: PUSH
34462: LD_VAR 0 2
34466: ARRAY
34467: PUSH
34468: LD_VAR 0 3
34472: ARRAY
34473: ST_TO_ADDR
// break ;
34474: GO 34478
// end ; end ;
34476: GO 34232
34478: POP
34479: POP
// if not target then
34480: LD_VAR 0 7
34484: NOT
34485: IFFALSE 34489
// continue ;
34487: GO 34039
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
34489: LD_ADDR_VAR 0 8
34493: PUSH
34494: LD_EXP 112
34498: PUSH
34499: LD_VAR 0 2
34503: ARRAY
34504: PPUSH
34505: LD_INT 2
34507: PUSH
34508: LD_INT 3
34510: PUSH
34511: LD_INT 58
34513: PUSH
34514: EMPTY
34515: LIST
34516: PUSH
34517: EMPTY
34518: LIST
34519: LIST
34520: PUSH
34521: LD_INT 61
34523: PUSH
34524: EMPTY
34525: LIST
34526: PUSH
34527: LD_INT 33
34529: PUSH
34530: LD_INT 5
34532: PUSH
34533: EMPTY
34534: LIST
34535: LIST
34536: PUSH
34537: LD_INT 33
34539: PUSH
34540: LD_INT 3
34542: PUSH
34543: EMPTY
34544: LIST
34545: LIST
34546: PUSH
34547: EMPTY
34548: LIST
34549: LIST
34550: LIST
34551: LIST
34552: LIST
34553: PUSH
34554: LD_INT 2
34556: PUSH
34557: LD_INT 34
34559: PUSH
34560: LD_INT 32
34562: PUSH
34563: EMPTY
34564: LIST
34565: LIST
34566: PUSH
34567: LD_INT 34
34569: PUSH
34570: LD_INT 51
34572: PUSH
34573: EMPTY
34574: LIST
34575: LIST
34576: PUSH
34577: LD_INT 34
34579: PUSH
34580: LD_INT 12
34582: PUSH
34583: EMPTY
34584: LIST
34585: LIST
34586: PUSH
34587: EMPTY
34588: LIST
34589: LIST
34590: LIST
34591: LIST
34592: PUSH
34593: EMPTY
34594: LIST
34595: LIST
34596: PPUSH
34597: CALL_OW 72
34601: ST_TO_ADDR
// if not cargo then
34602: LD_VAR 0 8
34606: NOT
34607: IFFALSE 35313
// begin if mc_crates_collector [ i ] < 5 then
34609: LD_EXP 110
34613: PUSH
34614: LD_VAR 0 2
34618: ARRAY
34619: PUSH
34620: LD_INT 5
34622: LESS
34623: IFFALSE 34989
// begin if mc_ape [ i ] then
34625: LD_EXP 122
34629: PUSH
34630: LD_VAR 0 2
34634: ARRAY
34635: IFFALSE 34682
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
34637: LD_ADDR_VAR 0 5
34641: PUSH
34642: LD_EXP 122
34646: PUSH
34647: LD_VAR 0 2
34651: ARRAY
34652: PPUSH
34653: LD_INT 25
34655: PUSH
34656: LD_INT 16
34658: PUSH
34659: EMPTY
34660: LIST
34661: LIST
34662: PUSH
34663: LD_INT 24
34665: PUSH
34666: LD_INT 750
34668: PUSH
34669: EMPTY
34670: LIST
34671: LIST
34672: PUSH
34673: EMPTY
34674: LIST
34675: LIST
34676: PPUSH
34677: CALL_OW 72
34681: ST_TO_ADDR
// if not tmp then
34682: LD_VAR 0 5
34686: NOT
34687: IFFALSE 34734
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
34689: LD_ADDR_VAR 0 5
34693: PUSH
34694: LD_EXP 93
34698: PUSH
34699: LD_VAR 0 2
34703: ARRAY
34704: PPUSH
34705: LD_INT 25
34707: PUSH
34708: LD_INT 2
34710: PUSH
34711: EMPTY
34712: LIST
34713: LIST
34714: PUSH
34715: LD_INT 24
34717: PUSH
34718: LD_INT 750
34720: PUSH
34721: EMPTY
34722: LIST
34723: LIST
34724: PUSH
34725: EMPTY
34726: LIST
34727: LIST
34728: PPUSH
34729: CALL_OW 72
34733: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
34734: LD_EXP 122
34738: PUSH
34739: LD_VAR 0 2
34743: ARRAY
34744: PUSH
34745: LD_EXP 93
34749: PUSH
34750: LD_VAR 0 2
34754: ARRAY
34755: PPUSH
34756: LD_INT 25
34758: PUSH
34759: LD_INT 2
34761: PUSH
34762: EMPTY
34763: LIST
34764: LIST
34765: PUSH
34766: LD_INT 24
34768: PUSH
34769: LD_INT 750
34771: PUSH
34772: EMPTY
34773: LIST
34774: LIST
34775: PUSH
34776: EMPTY
34777: LIST
34778: LIST
34779: PPUSH
34780: CALL_OW 72
34784: AND
34785: PUSH
34786: LD_VAR 0 5
34790: PUSH
34791: LD_INT 5
34793: LESS
34794: AND
34795: IFFALSE 34877
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
34797: LD_ADDR_VAR 0 3
34801: PUSH
34802: LD_EXP 93
34806: PUSH
34807: LD_VAR 0 2
34811: ARRAY
34812: PPUSH
34813: LD_INT 25
34815: PUSH
34816: LD_INT 2
34818: PUSH
34819: EMPTY
34820: LIST
34821: LIST
34822: PUSH
34823: LD_INT 24
34825: PUSH
34826: LD_INT 750
34828: PUSH
34829: EMPTY
34830: LIST
34831: LIST
34832: PUSH
34833: EMPTY
34834: LIST
34835: LIST
34836: PPUSH
34837: CALL_OW 72
34841: PUSH
34842: FOR_IN
34843: IFFALSE 34875
// begin tmp := tmp union j ;
34845: LD_ADDR_VAR 0 5
34849: PUSH
34850: LD_VAR 0 5
34854: PUSH
34855: LD_VAR 0 3
34859: UNION
34860: ST_TO_ADDR
// if tmp >= 5 then
34861: LD_VAR 0 5
34865: PUSH
34866: LD_INT 5
34868: GREATEREQUAL
34869: IFFALSE 34873
// break ;
34871: GO 34875
// end ;
34873: GO 34842
34875: POP
34876: POP
// end ; if not tmp then
34877: LD_VAR 0 5
34881: NOT
34882: IFFALSE 34886
// continue ;
34884: GO 34039
// for j in tmp do
34886: LD_ADDR_VAR 0 3
34890: PUSH
34891: LD_VAR 0 5
34895: PUSH
34896: FOR_IN
34897: IFFALSE 34987
// if not GetTag ( j ) then
34899: LD_VAR 0 3
34903: PPUSH
34904: CALL_OW 110
34908: NOT
34909: IFFALSE 34985
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
34911: LD_ADDR_EXP 110
34915: PUSH
34916: LD_EXP 110
34920: PPUSH
34921: LD_VAR 0 2
34925: PUSH
34926: LD_EXP 110
34930: PUSH
34931: LD_VAR 0 2
34935: ARRAY
34936: PUSH
34937: LD_INT 1
34939: PLUS
34940: PUSH
34941: EMPTY
34942: LIST
34943: LIST
34944: PPUSH
34945: LD_VAR 0 3
34949: PPUSH
34950: CALL 56198 0 3
34954: ST_TO_ADDR
// SetTag ( j , 107 ) ;
34955: LD_VAR 0 3
34959: PPUSH
34960: LD_INT 107
34962: PPUSH
34963: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
34967: LD_EXP 110
34971: PUSH
34972: LD_VAR 0 2
34976: ARRAY
34977: PUSH
34978: LD_INT 5
34980: GREATEREQUAL
34981: IFFALSE 34985
// break ;
34983: GO 34987
// end ;
34985: GO 34896
34987: POP
34988: POP
// end ; if mc_crates_collector [ i ] and target then
34989: LD_EXP 110
34993: PUSH
34994: LD_VAR 0 2
34998: ARRAY
34999: PUSH
35000: LD_VAR 0 7
35004: AND
35005: IFFALSE 35311
// begin if mc_crates_collector [ i ] < target [ 1 ] then
35007: LD_EXP 110
35011: PUSH
35012: LD_VAR 0 2
35016: ARRAY
35017: PUSH
35018: LD_VAR 0 7
35022: PUSH
35023: LD_INT 1
35025: ARRAY
35026: LESS
35027: IFFALSE 35047
// tmp := mc_crates_collector [ i ] else
35029: LD_ADDR_VAR 0 5
35033: PUSH
35034: LD_EXP 110
35038: PUSH
35039: LD_VAR 0 2
35043: ARRAY
35044: ST_TO_ADDR
35045: GO 35061
// tmp := target [ 1 ] ;
35047: LD_ADDR_VAR 0 5
35051: PUSH
35052: LD_VAR 0 7
35056: PUSH
35057: LD_INT 1
35059: ARRAY
35060: ST_TO_ADDR
// k := 0 ;
35061: LD_ADDR_VAR 0 4
35065: PUSH
35066: LD_INT 0
35068: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
35069: LD_ADDR_VAR 0 3
35073: PUSH
35074: LD_EXP 110
35078: PUSH
35079: LD_VAR 0 2
35083: ARRAY
35084: PUSH
35085: FOR_IN
35086: IFFALSE 35309
// begin k := k + 1 ;
35088: LD_ADDR_VAR 0 4
35092: PUSH
35093: LD_VAR 0 4
35097: PUSH
35098: LD_INT 1
35100: PLUS
35101: ST_TO_ADDR
// if k > tmp then
35102: LD_VAR 0 4
35106: PUSH
35107: LD_VAR 0 5
35111: GREATER
35112: IFFALSE 35116
// break ;
35114: GO 35309
// if not GetClass ( j ) in [ 2 , 16 ] then
35116: LD_VAR 0 3
35120: PPUSH
35121: CALL_OW 257
35125: PUSH
35126: LD_INT 2
35128: PUSH
35129: LD_INT 16
35131: PUSH
35132: EMPTY
35133: LIST
35134: LIST
35135: IN
35136: NOT
35137: IFFALSE 35190
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
35139: LD_ADDR_EXP 110
35143: PUSH
35144: LD_EXP 110
35148: PPUSH
35149: LD_VAR 0 2
35153: PPUSH
35154: LD_EXP 110
35158: PUSH
35159: LD_VAR 0 2
35163: ARRAY
35164: PUSH
35165: LD_VAR 0 3
35169: DIFF
35170: PPUSH
35171: CALL_OW 1
35175: ST_TO_ADDR
// SetTag ( j , 0 ) ;
35176: LD_VAR 0 3
35180: PPUSH
35181: LD_INT 0
35183: PPUSH
35184: CALL_OW 109
// continue ;
35188: GO 35085
// end ; if IsInUnit ( j ) then
35190: LD_VAR 0 3
35194: PPUSH
35195: CALL_OW 310
35199: IFFALSE 35210
// ComExitBuilding ( j ) ;
35201: LD_VAR 0 3
35205: PPUSH
35206: CALL_OW 122
// wait ( 3 ) ;
35210: LD_INT 3
35212: PPUSH
35213: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
35217: LD_VAR 0 3
35221: PPUSH
35222: CALL_OW 314
35226: PUSH
35227: LD_VAR 0 6
35231: PPUSH
35232: LD_VAR 0 7
35236: PUSH
35237: LD_INT 2
35239: ARRAY
35240: PPUSH
35241: LD_VAR 0 7
35245: PUSH
35246: LD_INT 3
35248: ARRAY
35249: PPUSH
35250: LD_INT 30
35252: PPUSH
35253: CALL 57094 0 4
35257: PUSH
35258: LD_INT 4
35260: ARRAY
35261: AND
35262: IFFALSE 35280
// ComStandNearbyBuilding ( j , depot ) else
35264: LD_VAR 0 3
35268: PPUSH
35269: LD_VAR 0 9
35273: PPUSH
35274: CALL 52776 0 2
35278: GO 35307
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35280: LD_VAR 0 3
35284: PPUSH
35285: LD_VAR 0 7
35289: PUSH
35290: LD_INT 2
35292: ARRAY
35293: PPUSH
35294: LD_VAR 0 7
35298: PUSH
35299: LD_INT 3
35301: ARRAY
35302: PPUSH
35303: CALL_OW 117
// end ;
35307: GO 35085
35309: POP
35310: POP
// end ; end else
35311: GO 35843
// begin for j in cargo do
35313: LD_ADDR_VAR 0 3
35317: PUSH
35318: LD_VAR 0 8
35322: PUSH
35323: FOR_IN
35324: IFFALSE 35841
// begin if GetTag ( j ) <> 0 then
35326: LD_VAR 0 3
35330: PPUSH
35331: CALL_OW 110
35335: PUSH
35336: LD_INT 0
35338: NONEQUAL
35339: IFFALSE 35343
// continue ;
35341: GO 35323
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
35343: LD_VAR 0 3
35347: PPUSH
35348: CALL_OW 256
35352: PUSH
35353: LD_INT 1000
35355: LESS
35356: PUSH
35357: LD_VAR 0 3
35361: PPUSH
35362: LD_EXP 117
35366: PUSH
35367: LD_VAR 0 2
35371: ARRAY
35372: PPUSH
35373: CALL_OW 308
35377: NOT
35378: AND
35379: IFFALSE 35401
// ComMoveToArea ( j , mc_parking [ i ] ) ;
35381: LD_VAR 0 3
35385: PPUSH
35386: LD_EXP 117
35390: PUSH
35391: LD_VAR 0 2
35395: ARRAY
35396: PPUSH
35397: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
35401: LD_VAR 0 3
35405: PPUSH
35406: CALL_OW 256
35410: PUSH
35411: LD_INT 1000
35413: LESS
35414: PUSH
35415: LD_VAR 0 3
35419: PPUSH
35420: LD_EXP 117
35424: PUSH
35425: LD_VAR 0 2
35429: ARRAY
35430: PPUSH
35431: CALL_OW 308
35435: AND
35436: IFFALSE 35440
// continue ;
35438: GO 35323
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
35440: LD_VAR 0 3
35444: PPUSH
35445: CALL_OW 262
35449: PUSH
35450: LD_INT 2
35452: EQUAL
35453: PUSH
35454: LD_VAR 0 3
35458: PPUSH
35459: CALL_OW 261
35463: PUSH
35464: LD_INT 15
35466: LESS
35467: AND
35468: IFFALSE 35472
// continue ;
35470: GO 35323
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
35472: LD_VAR 0 3
35476: PPUSH
35477: CALL_OW 262
35481: PUSH
35482: LD_INT 1
35484: EQUAL
35485: PUSH
35486: LD_VAR 0 3
35490: PPUSH
35491: CALL_OW 261
35495: PUSH
35496: LD_INT 10
35498: LESS
35499: AND
35500: IFFALSE 35780
// begin if not depot then
35502: LD_VAR 0 9
35506: NOT
35507: IFFALSE 35511
// continue ;
35509: GO 35323
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
35511: LD_VAR 0 3
35515: PPUSH
35516: LD_VAR 0 9
35520: PPUSH
35521: LD_VAR 0 3
35525: PPUSH
35526: CALL_OW 74
35530: PPUSH
35531: CALL_OW 296
35535: PUSH
35536: LD_INT 6
35538: LESS
35539: IFFALSE 35555
// SetFuel ( j , 100 ) else
35541: LD_VAR 0 3
35545: PPUSH
35546: LD_INT 100
35548: PPUSH
35549: CALL_OW 240
35553: GO 35780
// if GetFuel ( j ) = 0 then
35555: LD_VAR 0 3
35559: PPUSH
35560: CALL_OW 261
35564: PUSH
35565: LD_INT 0
35567: EQUAL
35568: IFFALSE 35780
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
35570: LD_ADDR_EXP 112
35574: PUSH
35575: LD_EXP 112
35579: PPUSH
35580: LD_VAR 0 2
35584: PPUSH
35585: LD_EXP 112
35589: PUSH
35590: LD_VAR 0 2
35594: ARRAY
35595: PUSH
35596: LD_VAR 0 3
35600: DIFF
35601: PPUSH
35602: CALL_OW 1
35606: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
35607: LD_VAR 0 3
35611: PPUSH
35612: CALL_OW 263
35616: PUSH
35617: LD_INT 1
35619: EQUAL
35620: IFFALSE 35636
// ComExitVehicle ( IsInUnit ( j ) ) ;
35622: LD_VAR 0 3
35626: PPUSH
35627: CALL_OW 310
35631: PPUSH
35632: CALL_OW 121
// if GetControl ( j ) = control_remote then
35636: LD_VAR 0 3
35640: PPUSH
35641: CALL_OW 263
35645: PUSH
35646: LD_INT 2
35648: EQUAL
35649: IFFALSE 35660
// ComUnlink ( j ) ;
35651: LD_VAR 0 3
35655: PPUSH
35656: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
35660: LD_ADDR_VAR 0 10
35664: PUSH
35665: LD_VAR 0 2
35669: PPUSH
35670: LD_INT 3
35672: PPUSH
35673: CALL 45261 0 2
35677: ST_TO_ADDR
// if fac then
35678: LD_VAR 0 10
35682: IFFALSE 35778
// begin for k in fac do
35684: LD_ADDR_VAR 0 4
35688: PUSH
35689: LD_VAR 0 10
35693: PUSH
35694: FOR_IN
35695: IFFALSE 35776
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
35697: LD_ADDR_VAR 0 11
35701: PUSH
35702: LD_VAR 0 10
35706: PPUSH
35707: LD_VAR 0 3
35711: PPUSH
35712: CALL_OW 265
35716: PPUSH
35717: LD_VAR 0 3
35721: PPUSH
35722: CALL_OW 262
35726: PPUSH
35727: LD_VAR 0 3
35731: PPUSH
35732: CALL_OW 263
35736: PPUSH
35737: LD_VAR 0 3
35741: PPUSH
35742: CALL_OW 264
35746: PPUSH
35747: CALL 53694 0 5
35751: ST_TO_ADDR
// if components then
35752: LD_VAR 0 11
35756: IFFALSE 35774
// begin MC_InsertProduceList ( i , components ) ;
35758: LD_VAR 0 2
35762: PPUSH
35763: LD_VAR 0 11
35767: PPUSH
35768: CALL 44806 0 2
// break ;
35772: GO 35776
// end ; end ;
35774: GO 35694
35776: POP
35777: POP
// end ; continue ;
35778: GO 35323
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
35780: LD_VAR 0 3
35784: PPUSH
35785: LD_INT 1
35787: PPUSH
35788: CALL_OW 289
35792: PUSH
35793: LD_INT 100
35795: LESS
35796: PUSH
35797: LD_VAR 0 3
35801: PPUSH
35802: CALL_OW 314
35806: NOT
35807: AND
35808: IFFALSE 35837
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35810: LD_VAR 0 3
35814: PPUSH
35815: LD_VAR 0 7
35819: PUSH
35820: LD_INT 2
35822: ARRAY
35823: PPUSH
35824: LD_VAR 0 7
35828: PUSH
35829: LD_INT 3
35831: ARRAY
35832: PPUSH
35833: CALL_OW 117
// break ;
35837: GO 35841
// end ;
35839: GO 35323
35841: POP
35842: POP
// end ; end ;
35843: GO 34039
35845: POP
35846: POP
// end ;
35847: LD_VAR 0 1
35851: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
35852: LD_INT 0
35854: PPUSH
35855: PPUSH
35856: PPUSH
35857: PPUSH
// if not mc_bases then
35858: LD_EXP 93
35862: NOT
35863: IFFALSE 35867
// exit ;
35865: GO 36028
// for i = 1 to mc_bases do
35867: LD_ADDR_VAR 0 2
35871: PUSH
35872: DOUBLE
35873: LD_INT 1
35875: DEC
35876: ST_TO_ADDR
35877: LD_EXP 93
35881: PUSH
35882: FOR_TO
35883: IFFALSE 36026
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
35885: LD_ADDR_VAR 0 4
35889: PUSH
35890: LD_EXP 112
35894: PUSH
35895: LD_VAR 0 2
35899: ARRAY
35900: PUSH
35901: LD_EXP 115
35905: PUSH
35906: LD_VAR 0 2
35910: ARRAY
35911: UNION
35912: PPUSH
35913: LD_INT 33
35915: PUSH
35916: LD_INT 2
35918: PUSH
35919: EMPTY
35920: LIST
35921: LIST
35922: PPUSH
35923: CALL_OW 72
35927: ST_TO_ADDR
// if tmp then
35928: LD_VAR 0 4
35932: IFFALSE 36024
// for j in tmp do
35934: LD_ADDR_VAR 0 3
35938: PUSH
35939: LD_VAR 0 4
35943: PUSH
35944: FOR_IN
35945: IFFALSE 36022
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
35947: LD_VAR 0 3
35951: PPUSH
35952: CALL_OW 312
35956: NOT
35957: PUSH
35958: LD_VAR 0 3
35962: PPUSH
35963: CALL_OW 256
35967: PUSH
35968: LD_INT 250
35970: GREATEREQUAL
35971: AND
35972: IFFALSE 35985
// Connect ( j ) else
35974: LD_VAR 0 3
35978: PPUSH
35979: CALL 59169 0 1
35983: GO 36020
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
35985: LD_VAR 0 3
35989: PPUSH
35990: CALL_OW 256
35994: PUSH
35995: LD_INT 250
35997: LESS
35998: PUSH
35999: LD_VAR 0 3
36003: PPUSH
36004: CALL_OW 312
36008: AND
36009: IFFALSE 36020
// ComUnlink ( j ) ;
36011: LD_VAR 0 3
36015: PPUSH
36016: CALL_OW 136
36020: GO 35944
36022: POP
36023: POP
// end ;
36024: GO 35882
36026: POP
36027: POP
// end ;
36028: LD_VAR 0 1
36032: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
36033: LD_INT 0
36035: PPUSH
36036: PPUSH
36037: PPUSH
36038: PPUSH
36039: PPUSH
// if not mc_bases then
36040: LD_EXP 93
36044: NOT
36045: IFFALSE 36049
// exit ;
36047: GO 36494
// for i = 1 to mc_bases do
36049: LD_ADDR_VAR 0 2
36053: PUSH
36054: DOUBLE
36055: LD_INT 1
36057: DEC
36058: ST_TO_ADDR
36059: LD_EXP 93
36063: PUSH
36064: FOR_TO
36065: IFFALSE 36492
// begin if not mc_produce [ i ] then
36067: LD_EXP 114
36071: PUSH
36072: LD_VAR 0 2
36076: ARRAY
36077: NOT
36078: IFFALSE 36082
// continue ;
36080: GO 36064
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36082: LD_ADDR_VAR 0 5
36086: PUSH
36087: LD_EXP 93
36091: PUSH
36092: LD_VAR 0 2
36096: ARRAY
36097: PPUSH
36098: LD_INT 30
36100: PUSH
36101: LD_INT 3
36103: PUSH
36104: EMPTY
36105: LIST
36106: LIST
36107: PPUSH
36108: CALL_OW 72
36112: ST_TO_ADDR
// if not fac then
36113: LD_VAR 0 5
36117: NOT
36118: IFFALSE 36122
// continue ;
36120: GO 36064
// for j in fac do
36122: LD_ADDR_VAR 0 3
36126: PUSH
36127: LD_VAR 0 5
36131: PUSH
36132: FOR_IN
36133: IFFALSE 36488
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
36135: LD_VAR 0 3
36139: PPUSH
36140: CALL_OW 461
36144: PUSH
36145: LD_INT 2
36147: NONEQUAL
36148: PUSH
36149: LD_VAR 0 3
36153: PPUSH
36154: LD_INT 15
36156: PPUSH
36157: CALL 58797 0 2
36161: PUSH
36162: LD_INT 4
36164: ARRAY
36165: OR
36166: IFFALSE 36170
// continue ;
36168: GO 36132
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
36170: LD_VAR 0 3
36174: PPUSH
36175: LD_EXP 114
36179: PUSH
36180: LD_VAR 0 2
36184: ARRAY
36185: PUSH
36186: LD_INT 1
36188: ARRAY
36189: PUSH
36190: LD_INT 1
36192: ARRAY
36193: PPUSH
36194: LD_EXP 114
36198: PUSH
36199: LD_VAR 0 2
36203: ARRAY
36204: PUSH
36205: LD_INT 1
36207: ARRAY
36208: PUSH
36209: LD_INT 2
36211: ARRAY
36212: PPUSH
36213: LD_EXP 114
36217: PUSH
36218: LD_VAR 0 2
36222: ARRAY
36223: PUSH
36224: LD_INT 1
36226: ARRAY
36227: PUSH
36228: LD_INT 3
36230: ARRAY
36231: PPUSH
36232: LD_EXP 114
36236: PUSH
36237: LD_VAR 0 2
36241: ARRAY
36242: PUSH
36243: LD_INT 1
36245: ARRAY
36246: PUSH
36247: LD_INT 4
36249: ARRAY
36250: PPUSH
36251: CALL_OW 448
36255: PUSH
36256: LD_VAR 0 3
36260: PPUSH
36261: LD_EXP 114
36265: PUSH
36266: LD_VAR 0 2
36270: ARRAY
36271: PUSH
36272: LD_INT 1
36274: ARRAY
36275: PUSH
36276: LD_INT 1
36278: ARRAY
36279: PUSH
36280: LD_EXP 114
36284: PUSH
36285: LD_VAR 0 2
36289: ARRAY
36290: PUSH
36291: LD_INT 1
36293: ARRAY
36294: PUSH
36295: LD_INT 2
36297: ARRAY
36298: PUSH
36299: LD_EXP 114
36303: PUSH
36304: LD_VAR 0 2
36308: ARRAY
36309: PUSH
36310: LD_INT 1
36312: ARRAY
36313: PUSH
36314: LD_INT 3
36316: ARRAY
36317: PUSH
36318: LD_EXP 114
36322: PUSH
36323: LD_VAR 0 2
36327: ARRAY
36328: PUSH
36329: LD_INT 1
36331: ARRAY
36332: PUSH
36333: LD_INT 4
36335: ARRAY
36336: PUSH
36337: EMPTY
36338: LIST
36339: LIST
36340: LIST
36341: LIST
36342: PPUSH
36343: CALL 62565 0 2
36347: AND
36348: IFFALSE 36486
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
36350: LD_VAR 0 3
36354: PPUSH
36355: LD_EXP 114
36359: PUSH
36360: LD_VAR 0 2
36364: ARRAY
36365: PUSH
36366: LD_INT 1
36368: ARRAY
36369: PUSH
36370: LD_INT 1
36372: ARRAY
36373: PPUSH
36374: LD_EXP 114
36378: PUSH
36379: LD_VAR 0 2
36383: ARRAY
36384: PUSH
36385: LD_INT 1
36387: ARRAY
36388: PUSH
36389: LD_INT 2
36391: ARRAY
36392: PPUSH
36393: LD_EXP 114
36397: PUSH
36398: LD_VAR 0 2
36402: ARRAY
36403: PUSH
36404: LD_INT 1
36406: ARRAY
36407: PUSH
36408: LD_INT 3
36410: ARRAY
36411: PPUSH
36412: LD_EXP 114
36416: PUSH
36417: LD_VAR 0 2
36421: ARRAY
36422: PUSH
36423: LD_INT 1
36425: ARRAY
36426: PUSH
36427: LD_INT 4
36429: ARRAY
36430: PPUSH
36431: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
36435: LD_ADDR_VAR 0 4
36439: PUSH
36440: LD_EXP 114
36444: PUSH
36445: LD_VAR 0 2
36449: ARRAY
36450: PPUSH
36451: LD_INT 1
36453: PPUSH
36454: CALL_OW 3
36458: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
36459: LD_ADDR_EXP 114
36463: PUSH
36464: LD_EXP 114
36468: PPUSH
36469: LD_VAR 0 2
36473: PPUSH
36474: LD_VAR 0 4
36478: PPUSH
36479: CALL_OW 1
36483: ST_TO_ADDR
// break ;
36484: GO 36488
// end ; end ;
36486: GO 36132
36488: POP
36489: POP
// end ;
36490: GO 36064
36492: POP
36493: POP
// end ;
36494: LD_VAR 0 1
36498: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
36499: LD_INT 0
36501: PPUSH
36502: PPUSH
36503: PPUSH
// if not mc_bases then
36504: LD_EXP 93
36508: NOT
36509: IFFALSE 36513
// exit ;
36511: GO 36602
// for i = 1 to mc_bases do
36513: LD_ADDR_VAR 0 2
36517: PUSH
36518: DOUBLE
36519: LD_INT 1
36521: DEC
36522: ST_TO_ADDR
36523: LD_EXP 93
36527: PUSH
36528: FOR_TO
36529: IFFALSE 36600
// begin if mc_attack [ i ] then
36531: LD_EXP 113
36535: PUSH
36536: LD_VAR 0 2
36540: ARRAY
36541: IFFALSE 36598
// begin tmp := mc_attack [ i ] [ 1 ] ;
36543: LD_ADDR_VAR 0 3
36547: PUSH
36548: LD_EXP 113
36552: PUSH
36553: LD_VAR 0 2
36557: ARRAY
36558: PUSH
36559: LD_INT 1
36561: ARRAY
36562: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
36563: LD_ADDR_EXP 113
36567: PUSH
36568: LD_EXP 113
36572: PPUSH
36573: LD_VAR 0 2
36577: PPUSH
36578: EMPTY
36579: PPUSH
36580: CALL_OW 1
36584: ST_TO_ADDR
// Attack ( tmp ) ;
36585: LD_VAR 0 3
36589: PPUSH
36590: CALL 106994 0 1
// exit ;
36594: POP
36595: POP
36596: GO 36602
// end ; end ;
36598: GO 36528
36600: POP
36601: POP
// end ;
36602: LD_VAR 0 1
36606: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
36607: LD_INT 0
36609: PPUSH
36610: PPUSH
36611: PPUSH
36612: PPUSH
36613: PPUSH
36614: PPUSH
36615: PPUSH
// if not mc_bases then
36616: LD_EXP 93
36620: NOT
36621: IFFALSE 36625
// exit ;
36623: GO 37324
// for i = 1 to mc_bases do
36625: LD_ADDR_VAR 0 2
36629: PUSH
36630: DOUBLE
36631: LD_INT 1
36633: DEC
36634: ST_TO_ADDR
36635: LD_EXP 93
36639: PUSH
36640: FOR_TO
36641: IFFALSE 37322
// begin if not mc_bases [ i ] then
36643: LD_EXP 93
36647: PUSH
36648: LD_VAR 0 2
36652: ARRAY
36653: NOT
36654: IFFALSE 36658
// continue ;
36656: GO 36640
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
36658: LD_ADDR_VAR 0 7
36662: PUSH
36663: LD_EXP 93
36667: PUSH
36668: LD_VAR 0 2
36672: ARRAY
36673: PUSH
36674: LD_INT 1
36676: ARRAY
36677: PPUSH
36678: CALL 52998 0 1
36682: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
36683: LD_ADDR_EXP 116
36687: PUSH
36688: LD_EXP 116
36692: PPUSH
36693: LD_VAR 0 2
36697: PPUSH
36698: LD_EXP 93
36702: PUSH
36703: LD_VAR 0 2
36707: ARRAY
36708: PUSH
36709: LD_INT 1
36711: ARRAY
36712: PPUSH
36713: CALL_OW 255
36717: PPUSH
36718: LD_EXP 118
36722: PUSH
36723: LD_VAR 0 2
36727: ARRAY
36728: PPUSH
36729: CALL 52963 0 2
36733: PPUSH
36734: CALL_OW 1
36738: ST_TO_ADDR
// if not mc_scan [ i ] then
36739: LD_EXP 116
36743: PUSH
36744: LD_VAR 0 2
36748: ARRAY
36749: NOT
36750: IFFALSE 36928
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36752: LD_ADDR_VAR 0 4
36756: PUSH
36757: LD_EXP 93
36761: PUSH
36762: LD_VAR 0 2
36766: ARRAY
36767: PPUSH
36768: LD_INT 2
36770: PUSH
36771: LD_INT 25
36773: PUSH
36774: LD_INT 5
36776: PUSH
36777: EMPTY
36778: LIST
36779: LIST
36780: PUSH
36781: LD_INT 25
36783: PUSH
36784: LD_INT 8
36786: PUSH
36787: EMPTY
36788: LIST
36789: LIST
36790: PUSH
36791: LD_INT 25
36793: PUSH
36794: LD_INT 9
36796: PUSH
36797: EMPTY
36798: LIST
36799: LIST
36800: PUSH
36801: EMPTY
36802: LIST
36803: LIST
36804: LIST
36805: LIST
36806: PPUSH
36807: CALL_OW 72
36811: ST_TO_ADDR
// if not tmp then
36812: LD_VAR 0 4
36816: NOT
36817: IFFALSE 36821
// continue ;
36819: GO 36640
// for j in tmp do
36821: LD_ADDR_VAR 0 3
36825: PUSH
36826: LD_VAR 0 4
36830: PUSH
36831: FOR_IN
36832: IFFALSE 36903
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
36834: LD_VAR 0 3
36838: PPUSH
36839: CALL_OW 310
36843: PPUSH
36844: CALL_OW 266
36848: PUSH
36849: LD_INT 5
36851: EQUAL
36852: PUSH
36853: LD_VAR 0 3
36857: PPUSH
36858: CALL_OW 257
36862: PUSH
36863: LD_INT 1
36865: EQUAL
36866: AND
36867: PUSH
36868: LD_VAR 0 3
36872: PPUSH
36873: CALL_OW 459
36877: NOT
36878: AND
36879: PUSH
36880: LD_VAR 0 7
36884: AND
36885: IFFALSE 36901
// ComChangeProfession ( j , class ) ;
36887: LD_VAR 0 3
36891: PPUSH
36892: LD_VAR 0 7
36896: PPUSH
36897: CALL_OW 123
36901: GO 36831
36903: POP
36904: POP
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
36905: LD_ADDR_EXP 136
36909: PUSH
36910: LD_EXP 136
36914: PPUSH
36915: LD_VAR 0 2
36919: PPUSH
36920: LD_INT 0
36922: PPUSH
36923: CALL_OW 1
36927: ST_TO_ADDR
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
36928: LD_EXP 116
36932: PUSH
36933: LD_VAR 0 2
36937: ARRAY
36938: PUSH
36939: LD_EXP 136
36943: PUSH
36944: LD_VAR 0 2
36948: ARRAY
36949: NOT
36950: AND
36951: PUSH
36952: LD_EXP 115
36956: PUSH
36957: LD_VAR 0 2
36961: ARRAY
36962: NOT
36963: AND
36964: PUSH
36965: LD_EXP 93
36969: PUSH
36970: LD_VAR 0 2
36974: ARRAY
36975: PPUSH
36976: LD_INT 30
36978: PUSH
36979: LD_INT 32
36981: PUSH
36982: EMPTY
36983: LIST
36984: LIST
36985: PPUSH
36986: CALL_OW 72
36990: NOT
36991: AND
36992: PUSH
36993: LD_EXP 93
36997: PUSH
36998: LD_VAR 0 2
37002: ARRAY
37003: PPUSH
37004: LD_INT 2
37006: PUSH
37007: LD_INT 30
37009: PUSH
37010: LD_INT 4
37012: PUSH
37013: EMPTY
37014: LIST
37015: LIST
37016: PUSH
37017: LD_INT 30
37019: PUSH
37020: LD_INT 5
37022: PUSH
37023: EMPTY
37024: LIST
37025: LIST
37026: PUSH
37027: EMPTY
37028: LIST
37029: LIST
37030: LIST
37031: PPUSH
37032: CALL_OW 72
37036: NOT
37037: AND
37038: IFFALSE 37193
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
37040: LD_ADDR_VAR 0 4
37044: PUSH
37045: LD_EXP 93
37049: PUSH
37050: LD_VAR 0 2
37054: ARRAY
37055: PPUSH
37056: LD_INT 2
37058: PUSH
37059: LD_INT 25
37061: PUSH
37062: LD_INT 1
37064: PUSH
37065: EMPTY
37066: LIST
37067: LIST
37068: PUSH
37069: LD_INT 25
37071: PUSH
37072: LD_INT 5
37074: PUSH
37075: EMPTY
37076: LIST
37077: LIST
37078: PUSH
37079: LD_INT 25
37081: PUSH
37082: LD_INT 8
37084: PUSH
37085: EMPTY
37086: LIST
37087: LIST
37088: PUSH
37089: LD_INT 25
37091: PUSH
37092: LD_INT 9
37094: PUSH
37095: EMPTY
37096: LIST
37097: LIST
37098: PUSH
37099: EMPTY
37100: LIST
37101: LIST
37102: LIST
37103: LIST
37104: LIST
37105: PPUSH
37106: CALL_OW 72
37110: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
37111: LD_ADDR_VAR 0 4
37115: PUSH
37116: LD_VAR 0 4
37120: PUSH
37121: LD_VAR 0 4
37125: PPUSH
37126: LD_INT 18
37128: PPUSH
37129: CALL 85468 0 2
37133: DIFF
37134: ST_TO_ADDR
// if tmp then
37135: LD_VAR 0 4
37139: IFFALSE 37193
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
37141: LD_ADDR_EXP 136
37145: PUSH
37146: LD_EXP 136
37150: PPUSH
37151: LD_VAR 0 2
37155: PPUSH
37156: LD_INT 1
37158: PPUSH
37159: CALL_OW 1
37163: ST_TO_ADDR
// BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
37164: LD_VAR 0 2
37168: PPUSH
37169: LD_VAR 0 4
37173: PPUSH
37174: LD_EXP 118
37178: PUSH
37179: LD_VAR 0 2
37183: ARRAY
37184: PPUSH
37185: CALL 111703 0 3
// exit ;
37189: POP
37190: POP
37191: GO 37324
// end ; end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
37193: LD_EXP 116
37197: PUSH
37198: LD_VAR 0 2
37202: ARRAY
37203: PUSH
37204: LD_EXP 136
37208: PUSH
37209: LD_VAR 0 2
37213: ARRAY
37214: NOT
37215: AND
37216: PUSH
37217: LD_EXP 115
37221: PUSH
37222: LD_VAR 0 2
37226: ARRAY
37227: AND
37228: IFFALSE 37320
// begin tmp := mc_defender [ i ] ;
37230: LD_ADDR_VAR 0 4
37234: PUSH
37235: LD_EXP 115
37239: PUSH
37240: LD_VAR 0 2
37244: ARRAY
37245: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
37246: LD_ADDR_EXP 115
37250: PUSH
37251: LD_EXP 115
37255: PPUSH
37256: LD_VAR 0 2
37260: PPUSH
37261: EMPTY
37262: PPUSH
37263: CALL_OW 1
37267: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , true ) ;
37268: LD_ADDR_EXP 136
37272: PUSH
37273: LD_EXP 136
37277: PPUSH
37278: LD_VAR 0 2
37282: PPUSH
37283: LD_INT 1
37285: PPUSH
37286: CALL_OW 1
37290: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
37291: LD_VAR 0 2
37295: PPUSH
37296: LD_VAR 0 4
37300: PPUSH
37301: LD_EXP 116
37305: PUSH
37306: LD_VAR 0 2
37310: ARRAY
37311: PPUSH
37312: CALL 112264 0 3
// exit ;
37316: POP
37317: POP
37318: GO 37324
// end ; end ;
37320: GO 36640
37322: POP
37323: POP
// end ;
37324: LD_VAR 0 1
37328: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
37329: LD_INT 0
37331: PPUSH
37332: PPUSH
37333: PPUSH
37334: PPUSH
37335: PPUSH
37336: PPUSH
37337: PPUSH
37338: PPUSH
37339: PPUSH
37340: PPUSH
37341: PPUSH
// if not mc_bases then
37342: LD_EXP 93
37346: NOT
37347: IFFALSE 37351
// exit ;
37349: GO 38438
// for i = 1 to mc_bases do
37351: LD_ADDR_VAR 0 2
37355: PUSH
37356: DOUBLE
37357: LD_INT 1
37359: DEC
37360: ST_TO_ADDR
37361: LD_EXP 93
37365: PUSH
37366: FOR_TO
37367: IFFALSE 38436
// begin tmp := mc_lab [ i ] ;
37369: LD_ADDR_VAR 0 6
37373: PUSH
37374: LD_EXP 126
37378: PUSH
37379: LD_VAR 0 2
37383: ARRAY
37384: ST_TO_ADDR
// if not tmp then
37385: LD_VAR 0 6
37389: NOT
37390: IFFALSE 37394
// continue ;
37392: GO 37366
// idle_lab := 0 ;
37394: LD_ADDR_VAR 0 11
37398: PUSH
37399: LD_INT 0
37401: ST_TO_ADDR
// for j in tmp do
37402: LD_ADDR_VAR 0 3
37406: PUSH
37407: LD_VAR 0 6
37411: PUSH
37412: FOR_IN
37413: IFFALSE 38432
// begin researching := false ;
37415: LD_ADDR_VAR 0 10
37419: PUSH
37420: LD_INT 0
37422: ST_TO_ADDR
// side := GetSide ( j ) ;
37423: LD_ADDR_VAR 0 4
37427: PUSH
37428: LD_VAR 0 3
37432: PPUSH
37433: CALL_OW 255
37437: ST_TO_ADDR
// if not mc_tech [ side ] then
37438: LD_EXP 120
37442: PUSH
37443: LD_VAR 0 4
37447: ARRAY
37448: NOT
37449: IFFALSE 37453
// continue ;
37451: GO 37412
// if BuildingStatus ( j ) = bs_idle then
37453: LD_VAR 0 3
37457: PPUSH
37458: CALL_OW 461
37462: PUSH
37463: LD_INT 2
37465: EQUAL
37466: IFFALSE 37654
// begin if idle_lab and UnitsInside ( j ) < 6 then
37468: LD_VAR 0 11
37472: PUSH
37473: LD_VAR 0 3
37477: PPUSH
37478: CALL_OW 313
37482: PUSH
37483: LD_INT 6
37485: LESS
37486: AND
37487: IFFALSE 37558
// begin tmp2 := UnitsInside ( idle_lab ) ;
37489: LD_ADDR_VAR 0 9
37493: PUSH
37494: LD_VAR 0 11
37498: PPUSH
37499: CALL_OW 313
37503: ST_TO_ADDR
// if tmp2 then
37504: LD_VAR 0 9
37508: IFFALSE 37550
// for x in tmp2 do
37510: LD_ADDR_VAR 0 7
37514: PUSH
37515: LD_VAR 0 9
37519: PUSH
37520: FOR_IN
37521: IFFALSE 37548
// begin ComExitBuilding ( x ) ;
37523: LD_VAR 0 7
37527: PPUSH
37528: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
37532: LD_VAR 0 7
37536: PPUSH
37537: LD_VAR 0 3
37541: PPUSH
37542: CALL_OW 180
// end ;
37546: GO 37520
37548: POP
37549: POP
// idle_lab := 0 ;
37550: LD_ADDR_VAR 0 11
37554: PUSH
37555: LD_INT 0
37557: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
37558: LD_ADDR_VAR 0 5
37562: PUSH
37563: LD_EXP 120
37567: PUSH
37568: LD_VAR 0 4
37572: ARRAY
37573: PUSH
37574: FOR_IN
37575: IFFALSE 37635
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
37577: LD_VAR 0 3
37581: PPUSH
37582: LD_VAR 0 5
37586: PPUSH
37587: CALL_OW 430
37591: PUSH
37592: LD_VAR 0 4
37596: PPUSH
37597: LD_VAR 0 5
37601: PPUSH
37602: CALL 52068 0 2
37606: AND
37607: IFFALSE 37633
// begin researching := true ;
37609: LD_ADDR_VAR 0 10
37613: PUSH
37614: LD_INT 1
37616: ST_TO_ADDR
// ComResearch ( j , t ) ;
37617: LD_VAR 0 3
37621: PPUSH
37622: LD_VAR 0 5
37626: PPUSH
37627: CALL_OW 124
// break ;
37631: GO 37635
// end ;
37633: GO 37574
37635: POP
37636: POP
// if not researching then
37637: LD_VAR 0 10
37641: NOT
37642: IFFALSE 37654
// idle_lab := j ;
37644: LD_ADDR_VAR 0 11
37648: PUSH
37649: LD_VAR 0 3
37653: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
37654: LD_VAR 0 3
37658: PPUSH
37659: CALL_OW 461
37663: PUSH
37664: LD_INT 10
37666: EQUAL
37667: IFFALSE 38255
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
37669: LD_EXP 122
37673: PUSH
37674: LD_VAR 0 2
37678: ARRAY
37679: NOT
37680: PUSH
37681: LD_EXP 123
37685: PUSH
37686: LD_VAR 0 2
37690: ARRAY
37691: NOT
37692: AND
37693: PUSH
37694: LD_EXP 120
37698: PUSH
37699: LD_VAR 0 4
37703: ARRAY
37704: PUSH
37705: LD_INT 1
37707: GREATER
37708: AND
37709: IFFALSE 37840
// begin ComCancel ( j ) ;
37711: LD_VAR 0 3
37715: PPUSH
37716: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
37720: LD_ADDR_EXP 120
37724: PUSH
37725: LD_EXP 120
37729: PPUSH
37730: LD_VAR 0 4
37734: PPUSH
37735: LD_EXP 120
37739: PUSH
37740: LD_VAR 0 4
37744: ARRAY
37745: PPUSH
37746: LD_EXP 120
37750: PUSH
37751: LD_VAR 0 4
37755: ARRAY
37756: PUSH
37757: LD_INT 1
37759: MINUS
37760: PPUSH
37761: LD_EXP 120
37765: PUSH
37766: LD_VAR 0 4
37770: ARRAY
37771: PPUSH
37772: LD_INT 0
37774: PPUSH
37775: CALL 55616 0 4
37779: PPUSH
37780: CALL_OW 1
37784: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
37785: LD_ADDR_EXP 120
37789: PUSH
37790: LD_EXP 120
37794: PPUSH
37795: LD_VAR 0 4
37799: PPUSH
37800: LD_EXP 120
37804: PUSH
37805: LD_VAR 0 4
37809: ARRAY
37810: PPUSH
37811: LD_EXP 120
37815: PUSH
37816: LD_VAR 0 4
37820: ARRAY
37821: PPUSH
37822: LD_INT 1
37824: PPUSH
37825: LD_INT 0
37827: PPUSH
37828: CALL 55616 0 4
37832: PPUSH
37833: CALL_OW 1
37837: ST_TO_ADDR
// continue ;
37838: GO 37412
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
37840: LD_EXP 122
37844: PUSH
37845: LD_VAR 0 2
37849: ARRAY
37850: PUSH
37851: LD_EXP 123
37855: PUSH
37856: LD_VAR 0 2
37860: ARRAY
37861: NOT
37862: AND
37863: IFFALSE 37990
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
37865: LD_ADDR_EXP 123
37869: PUSH
37870: LD_EXP 123
37874: PPUSH
37875: LD_VAR 0 2
37879: PUSH
37880: LD_EXP 123
37884: PUSH
37885: LD_VAR 0 2
37889: ARRAY
37890: PUSH
37891: LD_INT 1
37893: PLUS
37894: PUSH
37895: EMPTY
37896: LIST
37897: LIST
37898: PPUSH
37899: LD_EXP 122
37903: PUSH
37904: LD_VAR 0 2
37908: ARRAY
37909: PUSH
37910: LD_INT 1
37912: ARRAY
37913: PPUSH
37914: CALL 56198 0 3
37918: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
37919: LD_EXP 122
37923: PUSH
37924: LD_VAR 0 2
37928: ARRAY
37929: PUSH
37930: LD_INT 1
37932: ARRAY
37933: PPUSH
37934: LD_INT 112
37936: PPUSH
37937: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
37941: LD_ADDR_VAR 0 9
37945: PUSH
37946: LD_EXP 122
37950: PUSH
37951: LD_VAR 0 2
37955: ARRAY
37956: PPUSH
37957: LD_INT 1
37959: PPUSH
37960: CALL_OW 3
37964: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
37965: LD_ADDR_EXP 122
37969: PUSH
37970: LD_EXP 122
37974: PPUSH
37975: LD_VAR 0 2
37979: PPUSH
37980: LD_VAR 0 9
37984: PPUSH
37985: CALL_OW 1
37989: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
37990: LD_EXP 122
37994: PUSH
37995: LD_VAR 0 2
37999: ARRAY
38000: PUSH
38001: LD_EXP 123
38005: PUSH
38006: LD_VAR 0 2
38010: ARRAY
38011: AND
38012: PUSH
38013: LD_EXP 123
38017: PUSH
38018: LD_VAR 0 2
38022: ARRAY
38023: PUSH
38024: LD_INT 1
38026: ARRAY
38027: PPUSH
38028: CALL_OW 310
38032: NOT
38033: AND
38034: PUSH
38035: LD_VAR 0 3
38039: PPUSH
38040: CALL_OW 313
38044: PUSH
38045: LD_INT 6
38047: EQUAL
38048: AND
38049: IFFALSE 38105
// begin tmp2 := UnitsInside ( j ) ;
38051: LD_ADDR_VAR 0 9
38055: PUSH
38056: LD_VAR 0 3
38060: PPUSH
38061: CALL_OW 313
38065: ST_TO_ADDR
// if tmp2 = 6 then
38066: LD_VAR 0 9
38070: PUSH
38071: LD_INT 6
38073: EQUAL
38074: IFFALSE 38105
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
38076: LD_VAR 0 9
38080: PUSH
38081: LD_INT 1
38083: ARRAY
38084: PPUSH
38085: LD_INT 112
38087: PPUSH
38088: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
38092: LD_VAR 0 9
38096: PUSH
38097: LD_INT 1
38099: ARRAY
38100: PPUSH
38101: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
38105: LD_EXP 123
38109: PUSH
38110: LD_VAR 0 2
38114: ARRAY
38115: PUSH
38116: LD_EXP 123
38120: PUSH
38121: LD_VAR 0 2
38125: ARRAY
38126: PUSH
38127: LD_INT 1
38129: ARRAY
38130: PPUSH
38131: CALL_OW 314
38135: NOT
38136: AND
38137: PUSH
38138: LD_EXP 123
38142: PUSH
38143: LD_VAR 0 2
38147: ARRAY
38148: PUSH
38149: LD_INT 1
38151: ARRAY
38152: PPUSH
38153: CALL_OW 310
38157: NOT
38158: AND
38159: IFFALSE 38185
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
38161: LD_EXP 123
38165: PUSH
38166: LD_VAR 0 2
38170: ARRAY
38171: PUSH
38172: LD_INT 1
38174: ARRAY
38175: PPUSH
38176: LD_VAR 0 3
38180: PPUSH
38181: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
38185: LD_EXP 123
38189: PUSH
38190: LD_VAR 0 2
38194: ARRAY
38195: PUSH
38196: LD_INT 1
38198: ARRAY
38199: PPUSH
38200: CALL_OW 310
38204: PUSH
38205: LD_EXP 123
38209: PUSH
38210: LD_VAR 0 2
38214: ARRAY
38215: PUSH
38216: LD_INT 1
38218: ARRAY
38219: PPUSH
38220: CALL_OW 310
38224: PPUSH
38225: CALL_OW 461
38229: PUSH
38230: LD_INT 3
38232: NONEQUAL
38233: AND
38234: IFFALSE 38255
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
38236: LD_EXP 123
38240: PUSH
38241: LD_VAR 0 2
38245: ARRAY
38246: PUSH
38247: LD_INT 1
38249: ARRAY
38250: PPUSH
38251: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
38255: LD_VAR 0 3
38259: PPUSH
38260: CALL_OW 461
38264: PUSH
38265: LD_INT 6
38267: EQUAL
38268: PUSH
38269: LD_VAR 0 6
38273: PUSH
38274: LD_INT 1
38276: GREATER
38277: AND
38278: IFFALSE 38430
// begin sci := [ ] ;
38280: LD_ADDR_VAR 0 8
38284: PUSH
38285: EMPTY
38286: ST_TO_ADDR
// for x in ( tmp diff j ) do
38287: LD_ADDR_VAR 0 7
38291: PUSH
38292: LD_VAR 0 6
38296: PUSH
38297: LD_VAR 0 3
38301: DIFF
38302: PUSH
38303: FOR_IN
38304: IFFALSE 38356
// begin if sci = 6 then
38306: LD_VAR 0 8
38310: PUSH
38311: LD_INT 6
38313: EQUAL
38314: IFFALSE 38318
// break ;
38316: GO 38356
// if BuildingStatus ( x ) = bs_idle then
38318: LD_VAR 0 7
38322: PPUSH
38323: CALL_OW 461
38327: PUSH
38328: LD_INT 2
38330: EQUAL
38331: IFFALSE 38354
// sci := sci ^ UnitsInside ( x ) ;
38333: LD_ADDR_VAR 0 8
38337: PUSH
38338: LD_VAR 0 8
38342: PUSH
38343: LD_VAR 0 7
38347: PPUSH
38348: CALL_OW 313
38352: ADD
38353: ST_TO_ADDR
// end ;
38354: GO 38303
38356: POP
38357: POP
// if not sci then
38358: LD_VAR 0 8
38362: NOT
38363: IFFALSE 38367
// continue ;
38365: GO 37412
// for x in sci do
38367: LD_ADDR_VAR 0 7
38371: PUSH
38372: LD_VAR 0 8
38376: PUSH
38377: FOR_IN
38378: IFFALSE 38428
// if IsInUnit ( x ) and not HasTask ( x ) then
38380: LD_VAR 0 7
38384: PPUSH
38385: CALL_OW 310
38389: PUSH
38390: LD_VAR 0 7
38394: PPUSH
38395: CALL_OW 314
38399: NOT
38400: AND
38401: IFFALSE 38426
// begin ComExitBuilding ( x ) ;
38403: LD_VAR 0 7
38407: PPUSH
38408: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
38412: LD_VAR 0 7
38416: PPUSH
38417: LD_VAR 0 3
38421: PPUSH
38422: CALL_OW 180
// end ;
38426: GO 38377
38428: POP
38429: POP
// end ; end ;
38430: GO 37412
38432: POP
38433: POP
// end ;
38434: GO 37366
38436: POP
38437: POP
// end ;
38438: LD_VAR 0 1
38442: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
38443: LD_INT 0
38445: PPUSH
38446: PPUSH
// if not mc_bases then
38447: LD_EXP 93
38451: NOT
38452: IFFALSE 38456
// exit ;
38454: GO 38537
// for i = 1 to mc_bases do
38456: LD_ADDR_VAR 0 2
38460: PUSH
38461: DOUBLE
38462: LD_INT 1
38464: DEC
38465: ST_TO_ADDR
38466: LD_EXP 93
38470: PUSH
38471: FOR_TO
38472: IFFALSE 38535
// if mc_mines [ i ] and mc_miners [ i ] then
38474: LD_EXP 106
38478: PUSH
38479: LD_VAR 0 2
38483: ARRAY
38484: PUSH
38485: LD_EXP 107
38489: PUSH
38490: LD_VAR 0 2
38494: ARRAY
38495: AND
38496: IFFALSE 38533
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
38498: LD_EXP 107
38502: PUSH
38503: LD_VAR 0 2
38507: ARRAY
38508: PUSH
38509: LD_INT 1
38511: ARRAY
38512: PPUSH
38513: CALL_OW 255
38517: PPUSH
38518: LD_EXP 106
38522: PUSH
38523: LD_VAR 0 2
38527: ARRAY
38528: PPUSH
38529: CALL 53151 0 2
38533: GO 38471
38535: POP
38536: POP
// end ;
38537: LD_VAR 0 1
38541: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
38542: LD_INT 0
38544: PPUSH
38545: PPUSH
38546: PPUSH
38547: PPUSH
38548: PPUSH
38549: PPUSH
38550: PPUSH
38551: PPUSH
// if not mc_bases or not mc_parking then
38552: LD_EXP 93
38556: NOT
38557: PUSH
38558: LD_EXP 117
38562: NOT
38563: OR
38564: IFFALSE 38568
// exit ;
38566: GO 39278
// for i = 1 to mc_bases do
38568: LD_ADDR_VAR 0 2
38572: PUSH
38573: DOUBLE
38574: LD_INT 1
38576: DEC
38577: ST_TO_ADDR
38578: LD_EXP 93
38582: PUSH
38583: FOR_TO
38584: IFFALSE 39276
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
38586: LD_EXP 93
38590: PUSH
38591: LD_VAR 0 2
38595: ARRAY
38596: NOT
38597: PUSH
38598: LD_EXP 117
38602: PUSH
38603: LD_VAR 0 2
38607: ARRAY
38608: NOT
38609: OR
38610: IFFALSE 38614
// continue ;
38612: GO 38583
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
38614: LD_ADDR_VAR 0 5
38618: PUSH
38619: LD_EXP 93
38623: PUSH
38624: LD_VAR 0 2
38628: ARRAY
38629: PUSH
38630: LD_INT 1
38632: ARRAY
38633: PPUSH
38634: CALL_OW 255
38638: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38639: LD_ADDR_VAR 0 6
38643: PUSH
38644: LD_EXP 93
38648: PUSH
38649: LD_VAR 0 2
38653: ARRAY
38654: PPUSH
38655: LD_INT 30
38657: PUSH
38658: LD_INT 3
38660: PUSH
38661: EMPTY
38662: LIST
38663: LIST
38664: PPUSH
38665: CALL_OW 72
38669: ST_TO_ADDR
// if not fac then
38670: LD_VAR 0 6
38674: NOT
38675: IFFALSE 38726
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38677: LD_ADDR_VAR 0 6
38681: PUSH
38682: LD_EXP 93
38686: PUSH
38687: LD_VAR 0 2
38691: ARRAY
38692: PPUSH
38693: LD_INT 2
38695: PUSH
38696: LD_INT 30
38698: PUSH
38699: LD_INT 0
38701: PUSH
38702: EMPTY
38703: LIST
38704: LIST
38705: PUSH
38706: LD_INT 30
38708: PUSH
38709: LD_INT 1
38711: PUSH
38712: EMPTY
38713: LIST
38714: LIST
38715: PUSH
38716: EMPTY
38717: LIST
38718: LIST
38719: LIST
38720: PPUSH
38721: CALL_OW 72
38725: ST_TO_ADDR
// if not fac then
38726: LD_VAR 0 6
38730: NOT
38731: IFFALSE 38735
// continue ;
38733: GO 38583
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
38735: LD_ADDR_VAR 0 7
38739: PUSH
38740: LD_EXP 117
38744: PUSH
38745: LD_VAR 0 2
38749: ARRAY
38750: PPUSH
38751: LD_INT 22
38753: PUSH
38754: LD_VAR 0 5
38758: PUSH
38759: EMPTY
38760: LIST
38761: LIST
38762: PUSH
38763: LD_INT 21
38765: PUSH
38766: LD_INT 2
38768: PUSH
38769: EMPTY
38770: LIST
38771: LIST
38772: PUSH
38773: LD_INT 3
38775: PUSH
38776: LD_INT 24
38778: PUSH
38779: LD_INT 1000
38781: PUSH
38782: EMPTY
38783: LIST
38784: LIST
38785: PUSH
38786: EMPTY
38787: LIST
38788: LIST
38789: PUSH
38790: EMPTY
38791: LIST
38792: LIST
38793: LIST
38794: PPUSH
38795: CALL_OW 70
38799: ST_TO_ADDR
// for j in fac do
38800: LD_ADDR_VAR 0 3
38804: PUSH
38805: LD_VAR 0 6
38809: PUSH
38810: FOR_IN
38811: IFFALSE 38892
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
38813: LD_ADDR_VAR 0 7
38817: PUSH
38818: LD_VAR 0 7
38822: PUSH
38823: LD_INT 22
38825: PUSH
38826: LD_VAR 0 5
38830: PUSH
38831: EMPTY
38832: LIST
38833: LIST
38834: PUSH
38835: LD_INT 91
38837: PUSH
38838: LD_VAR 0 3
38842: PUSH
38843: LD_INT 15
38845: PUSH
38846: EMPTY
38847: LIST
38848: LIST
38849: LIST
38850: PUSH
38851: LD_INT 21
38853: PUSH
38854: LD_INT 2
38856: PUSH
38857: EMPTY
38858: LIST
38859: LIST
38860: PUSH
38861: LD_INT 3
38863: PUSH
38864: LD_INT 24
38866: PUSH
38867: LD_INT 1000
38869: PUSH
38870: EMPTY
38871: LIST
38872: LIST
38873: PUSH
38874: EMPTY
38875: LIST
38876: LIST
38877: PUSH
38878: EMPTY
38879: LIST
38880: LIST
38881: LIST
38882: LIST
38883: PPUSH
38884: CALL_OW 69
38888: UNION
38889: ST_TO_ADDR
38890: GO 38810
38892: POP
38893: POP
// if not vehs then
38894: LD_VAR 0 7
38898: NOT
38899: IFFALSE 38925
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
38901: LD_ADDR_EXP 105
38905: PUSH
38906: LD_EXP 105
38910: PPUSH
38911: LD_VAR 0 2
38915: PPUSH
38916: EMPTY
38917: PPUSH
38918: CALL_OW 1
38922: ST_TO_ADDR
// continue ;
38923: GO 38583
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38925: LD_ADDR_VAR 0 8
38929: PUSH
38930: LD_EXP 93
38934: PUSH
38935: LD_VAR 0 2
38939: ARRAY
38940: PPUSH
38941: LD_INT 30
38943: PUSH
38944: LD_INT 3
38946: PUSH
38947: EMPTY
38948: LIST
38949: LIST
38950: PPUSH
38951: CALL_OW 72
38955: ST_TO_ADDR
// if tmp then
38956: LD_VAR 0 8
38960: IFFALSE 39063
// begin for j in tmp do
38962: LD_ADDR_VAR 0 3
38966: PUSH
38967: LD_VAR 0 8
38971: PUSH
38972: FOR_IN
38973: IFFALSE 39061
// for k in UnitsInside ( j ) do
38975: LD_ADDR_VAR 0 4
38979: PUSH
38980: LD_VAR 0 3
38984: PPUSH
38985: CALL_OW 313
38989: PUSH
38990: FOR_IN
38991: IFFALSE 39057
// if k then
38993: LD_VAR 0 4
38997: IFFALSE 39055
// if not k in mc_repair_vehicle [ i ] then
38999: LD_VAR 0 4
39003: PUSH
39004: LD_EXP 105
39008: PUSH
39009: LD_VAR 0 2
39013: ARRAY
39014: IN
39015: NOT
39016: IFFALSE 39055
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
39018: LD_ADDR_EXP 105
39022: PUSH
39023: LD_EXP 105
39027: PPUSH
39028: LD_VAR 0 2
39032: PPUSH
39033: LD_EXP 105
39037: PUSH
39038: LD_VAR 0 2
39042: ARRAY
39043: PUSH
39044: LD_VAR 0 4
39048: UNION
39049: PPUSH
39050: CALL_OW 1
39054: ST_TO_ADDR
39055: GO 38990
39057: POP
39058: POP
39059: GO 38972
39061: POP
39062: POP
// end ; if not mc_repair_vehicle [ i ] then
39063: LD_EXP 105
39067: PUSH
39068: LD_VAR 0 2
39072: ARRAY
39073: NOT
39074: IFFALSE 39078
// continue ;
39076: GO 38583
// for j in mc_repair_vehicle [ i ] do
39078: LD_ADDR_VAR 0 3
39082: PUSH
39083: LD_EXP 105
39087: PUSH
39088: LD_VAR 0 2
39092: ARRAY
39093: PUSH
39094: FOR_IN
39095: IFFALSE 39272
// begin if GetClass ( j ) <> 3 then
39097: LD_VAR 0 3
39101: PPUSH
39102: CALL_OW 257
39106: PUSH
39107: LD_INT 3
39109: NONEQUAL
39110: IFFALSE 39151
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
39112: LD_ADDR_EXP 105
39116: PUSH
39117: LD_EXP 105
39121: PPUSH
39122: LD_VAR 0 2
39126: PPUSH
39127: LD_EXP 105
39131: PUSH
39132: LD_VAR 0 2
39136: ARRAY
39137: PUSH
39138: LD_VAR 0 3
39142: DIFF
39143: PPUSH
39144: CALL_OW 1
39148: ST_TO_ADDR
// continue ;
39149: GO 39094
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
39151: LD_VAR 0 3
39155: PPUSH
39156: CALL_OW 311
39160: NOT
39161: PUSH
39162: LD_VAR 0 3
39166: PUSH
39167: LD_EXP 96
39171: PUSH
39172: LD_VAR 0 2
39176: ARRAY
39177: PUSH
39178: LD_INT 1
39180: ARRAY
39181: IN
39182: NOT
39183: AND
39184: PUSH
39185: LD_VAR 0 3
39189: PUSH
39190: LD_EXP 96
39194: PUSH
39195: LD_VAR 0 2
39199: ARRAY
39200: PUSH
39201: LD_INT 2
39203: ARRAY
39204: IN
39205: NOT
39206: AND
39207: IFFALSE 39270
// begin if IsInUnit ( j ) then
39209: LD_VAR 0 3
39213: PPUSH
39214: CALL_OW 310
39218: IFFALSE 39231
// ComExitBuilding ( j ) else
39220: LD_VAR 0 3
39224: PPUSH
39225: CALL_OW 122
39229: GO 39270
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
39231: LD_VAR 0 3
39235: PPUSH
39236: LD_VAR 0 7
39240: PUSH
39241: LD_INT 1
39243: ARRAY
39244: PPUSH
39245: CALL 89686 0 2
39249: NOT
39250: IFFALSE 39270
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
39252: LD_VAR 0 3
39256: PPUSH
39257: LD_VAR 0 7
39261: PUSH
39262: LD_INT 1
39264: ARRAY
39265: PPUSH
39266: CALL_OW 129
// end ; end ;
39270: GO 39094
39272: POP
39273: POP
// end ;
39274: GO 38583
39276: POP
39277: POP
// end ;
39278: LD_VAR 0 1
39282: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
39283: LD_INT 0
39285: PPUSH
39286: PPUSH
39287: PPUSH
39288: PPUSH
39289: PPUSH
39290: PPUSH
39291: PPUSH
39292: PPUSH
39293: PPUSH
39294: PPUSH
39295: PPUSH
// if not mc_bases then
39296: LD_EXP 93
39300: NOT
39301: IFFALSE 39305
// exit ;
39303: GO 40107
// for i = 1 to mc_bases do
39305: LD_ADDR_VAR 0 2
39309: PUSH
39310: DOUBLE
39311: LD_INT 1
39313: DEC
39314: ST_TO_ADDR
39315: LD_EXP 93
39319: PUSH
39320: FOR_TO
39321: IFFALSE 40105
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
39323: LD_EXP 121
39327: PUSH
39328: LD_VAR 0 2
39332: ARRAY
39333: NOT
39334: PUSH
39335: LD_EXP 96
39339: PUSH
39340: LD_VAR 0 2
39344: ARRAY
39345: PUSH
39346: LD_INT 1
39348: ARRAY
39349: OR
39350: PUSH
39351: LD_EXP 96
39355: PUSH
39356: LD_VAR 0 2
39360: ARRAY
39361: PUSH
39362: LD_INT 2
39364: ARRAY
39365: OR
39366: PUSH
39367: LD_EXP 119
39371: PUSH
39372: LD_VAR 0 2
39376: ARRAY
39377: PPUSH
39378: LD_INT 1
39380: PPUSH
39381: CALL_OW 325
39385: NOT
39386: OR
39387: PUSH
39388: LD_EXP 116
39392: PUSH
39393: LD_VAR 0 2
39397: ARRAY
39398: OR
39399: IFFALSE 39403
// continue ;
39401: GO 39320
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
39403: LD_ADDR_VAR 0 8
39407: PUSH
39408: LD_EXP 93
39412: PUSH
39413: LD_VAR 0 2
39417: ARRAY
39418: PPUSH
39419: LD_INT 25
39421: PUSH
39422: LD_INT 4
39424: PUSH
39425: EMPTY
39426: LIST
39427: LIST
39428: PUSH
39429: LD_INT 50
39431: PUSH
39432: EMPTY
39433: LIST
39434: PUSH
39435: LD_INT 3
39437: PUSH
39438: LD_INT 60
39440: PUSH
39441: EMPTY
39442: LIST
39443: PUSH
39444: EMPTY
39445: LIST
39446: LIST
39447: PUSH
39448: EMPTY
39449: LIST
39450: LIST
39451: LIST
39452: PPUSH
39453: CALL_OW 72
39457: PUSH
39458: LD_EXP 97
39462: PUSH
39463: LD_VAR 0 2
39467: ARRAY
39468: DIFF
39469: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39470: LD_ADDR_VAR 0 9
39474: PUSH
39475: LD_EXP 93
39479: PUSH
39480: LD_VAR 0 2
39484: ARRAY
39485: PPUSH
39486: LD_INT 2
39488: PUSH
39489: LD_INT 30
39491: PUSH
39492: LD_INT 0
39494: PUSH
39495: EMPTY
39496: LIST
39497: LIST
39498: PUSH
39499: LD_INT 30
39501: PUSH
39502: LD_INT 1
39504: PUSH
39505: EMPTY
39506: LIST
39507: LIST
39508: PUSH
39509: EMPTY
39510: LIST
39511: LIST
39512: LIST
39513: PPUSH
39514: CALL_OW 72
39518: ST_TO_ADDR
// if not tmp or not dep then
39519: LD_VAR 0 8
39523: NOT
39524: PUSH
39525: LD_VAR 0 9
39529: NOT
39530: OR
39531: IFFALSE 39535
// continue ;
39533: GO 39320
// side := GetSide ( tmp [ 1 ] ) ;
39535: LD_ADDR_VAR 0 11
39539: PUSH
39540: LD_VAR 0 8
39544: PUSH
39545: LD_INT 1
39547: ARRAY
39548: PPUSH
39549: CALL_OW 255
39553: ST_TO_ADDR
// dep := dep [ 1 ] ;
39554: LD_ADDR_VAR 0 9
39558: PUSH
39559: LD_VAR 0 9
39563: PUSH
39564: LD_INT 1
39566: ARRAY
39567: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
39568: LD_ADDR_VAR 0 7
39572: PUSH
39573: LD_EXP 121
39577: PUSH
39578: LD_VAR 0 2
39582: ARRAY
39583: PPUSH
39584: LD_INT 22
39586: PUSH
39587: LD_INT 0
39589: PUSH
39590: EMPTY
39591: LIST
39592: LIST
39593: PUSH
39594: LD_INT 25
39596: PUSH
39597: LD_INT 12
39599: PUSH
39600: EMPTY
39601: LIST
39602: LIST
39603: PUSH
39604: EMPTY
39605: LIST
39606: LIST
39607: PPUSH
39608: CALL_OW 70
39612: PUSH
39613: LD_INT 22
39615: PUSH
39616: LD_INT 0
39618: PUSH
39619: EMPTY
39620: LIST
39621: LIST
39622: PUSH
39623: LD_INT 25
39625: PUSH
39626: LD_INT 12
39628: PUSH
39629: EMPTY
39630: LIST
39631: LIST
39632: PUSH
39633: LD_INT 91
39635: PUSH
39636: LD_VAR 0 9
39640: PUSH
39641: LD_INT 20
39643: PUSH
39644: EMPTY
39645: LIST
39646: LIST
39647: LIST
39648: PUSH
39649: EMPTY
39650: LIST
39651: LIST
39652: LIST
39653: PPUSH
39654: CALL_OW 69
39658: UNION
39659: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
39660: LD_ADDR_VAR 0 10
39664: PUSH
39665: LD_EXP 121
39669: PUSH
39670: LD_VAR 0 2
39674: ARRAY
39675: PPUSH
39676: LD_INT 81
39678: PUSH
39679: LD_VAR 0 11
39683: PUSH
39684: EMPTY
39685: LIST
39686: LIST
39687: PPUSH
39688: CALL_OW 70
39692: ST_TO_ADDR
// if not apes or danger_at_area then
39693: LD_VAR 0 7
39697: NOT
39698: PUSH
39699: LD_VAR 0 10
39703: OR
39704: IFFALSE 39754
// begin if mc_taming [ i ] then
39706: LD_EXP 124
39710: PUSH
39711: LD_VAR 0 2
39715: ARRAY
39716: IFFALSE 39752
// begin MC_Reset ( i , 121 ) ;
39718: LD_VAR 0 2
39722: PPUSH
39723: LD_INT 121
39725: PPUSH
39726: CALL 24956 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
39730: LD_ADDR_EXP 124
39734: PUSH
39735: LD_EXP 124
39739: PPUSH
39740: LD_VAR 0 2
39744: PPUSH
39745: EMPTY
39746: PPUSH
39747: CALL_OW 1
39751: ST_TO_ADDR
// end ; continue ;
39752: GO 39320
// end ; for j in tmp do
39754: LD_ADDR_VAR 0 3
39758: PUSH
39759: LD_VAR 0 8
39763: PUSH
39764: FOR_IN
39765: IFFALSE 40101
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
39767: LD_VAR 0 3
39771: PUSH
39772: LD_EXP 124
39776: PUSH
39777: LD_VAR 0 2
39781: ARRAY
39782: IN
39783: NOT
39784: PUSH
39785: LD_EXP 124
39789: PUSH
39790: LD_VAR 0 2
39794: ARRAY
39795: PUSH
39796: LD_INT 3
39798: LESS
39799: AND
39800: IFFALSE 39858
// begin SetTag ( j , 121 ) ;
39802: LD_VAR 0 3
39806: PPUSH
39807: LD_INT 121
39809: PPUSH
39810: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
39814: LD_ADDR_EXP 124
39818: PUSH
39819: LD_EXP 124
39823: PPUSH
39824: LD_VAR 0 2
39828: PUSH
39829: LD_EXP 124
39833: PUSH
39834: LD_VAR 0 2
39838: ARRAY
39839: PUSH
39840: LD_INT 1
39842: PLUS
39843: PUSH
39844: EMPTY
39845: LIST
39846: LIST
39847: PPUSH
39848: LD_VAR 0 3
39852: PPUSH
39853: CALL 56198 0 3
39857: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
39858: LD_VAR 0 3
39862: PUSH
39863: LD_EXP 124
39867: PUSH
39868: LD_VAR 0 2
39872: ARRAY
39873: IN
39874: IFFALSE 40099
// begin if GetClass ( j ) <> 4 then
39876: LD_VAR 0 3
39880: PPUSH
39881: CALL_OW 257
39885: PUSH
39886: LD_INT 4
39888: NONEQUAL
39889: IFFALSE 39942
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
39891: LD_ADDR_EXP 124
39895: PUSH
39896: LD_EXP 124
39900: PPUSH
39901: LD_VAR 0 2
39905: PPUSH
39906: LD_EXP 124
39910: PUSH
39911: LD_VAR 0 2
39915: ARRAY
39916: PUSH
39917: LD_VAR 0 3
39921: DIFF
39922: PPUSH
39923: CALL_OW 1
39927: ST_TO_ADDR
// SetTag ( j , 0 ) ;
39928: LD_VAR 0 3
39932: PPUSH
39933: LD_INT 0
39935: PPUSH
39936: CALL_OW 109
// continue ;
39940: GO 39764
// end ; if IsInUnit ( j ) then
39942: LD_VAR 0 3
39946: PPUSH
39947: CALL_OW 310
39951: IFFALSE 39962
// ComExitBuilding ( j ) ;
39953: LD_VAR 0 3
39957: PPUSH
39958: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
39962: LD_ADDR_VAR 0 6
39966: PUSH
39967: LD_VAR 0 7
39971: PPUSH
39972: LD_VAR 0 3
39976: PPUSH
39977: CALL_OW 74
39981: ST_TO_ADDR
// if not ape then
39982: LD_VAR 0 6
39986: NOT
39987: IFFALSE 39991
// break ;
39989: GO 40101
// x := GetX ( ape ) ;
39991: LD_ADDR_VAR 0 4
39995: PUSH
39996: LD_VAR 0 6
40000: PPUSH
40001: CALL_OW 250
40005: ST_TO_ADDR
// y := GetY ( ape ) ;
40006: LD_ADDR_VAR 0 5
40010: PUSH
40011: LD_VAR 0 6
40015: PPUSH
40016: CALL_OW 251
40020: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
40021: LD_VAR 0 4
40025: PPUSH
40026: LD_VAR 0 5
40030: PPUSH
40031: CALL_OW 488
40035: NOT
40036: PUSH
40037: LD_VAR 0 11
40041: PPUSH
40042: LD_VAR 0 4
40046: PPUSH
40047: LD_VAR 0 5
40051: PPUSH
40052: LD_INT 20
40054: PPUSH
40055: CALL 57094 0 4
40059: PUSH
40060: LD_INT 4
40062: ARRAY
40063: OR
40064: IFFALSE 40068
// break ;
40066: GO 40101
// if not HasTask ( j ) then
40068: LD_VAR 0 3
40072: PPUSH
40073: CALL_OW 314
40077: NOT
40078: IFFALSE 40099
// ComTameXY ( j , x , y ) ;
40080: LD_VAR 0 3
40084: PPUSH
40085: LD_VAR 0 4
40089: PPUSH
40090: LD_VAR 0 5
40094: PPUSH
40095: CALL_OW 131
// end ; end ;
40099: GO 39764
40101: POP
40102: POP
// end ;
40103: GO 39320
40105: POP
40106: POP
// end ;
40107: LD_VAR 0 1
40111: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
40112: LD_INT 0
40114: PPUSH
40115: PPUSH
40116: PPUSH
40117: PPUSH
40118: PPUSH
40119: PPUSH
40120: PPUSH
40121: PPUSH
// if not mc_bases then
40122: LD_EXP 93
40126: NOT
40127: IFFALSE 40131
// exit ;
40129: GO 40757
// for i = 1 to mc_bases do
40131: LD_ADDR_VAR 0 2
40135: PUSH
40136: DOUBLE
40137: LD_INT 1
40139: DEC
40140: ST_TO_ADDR
40141: LD_EXP 93
40145: PUSH
40146: FOR_TO
40147: IFFALSE 40755
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
40149: LD_EXP 122
40153: PUSH
40154: LD_VAR 0 2
40158: ARRAY
40159: NOT
40160: PUSH
40161: LD_EXP 122
40165: PUSH
40166: LD_VAR 0 2
40170: ARRAY
40171: PPUSH
40172: LD_INT 25
40174: PUSH
40175: LD_INT 12
40177: PUSH
40178: EMPTY
40179: LIST
40180: LIST
40181: PPUSH
40182: CALL_OW 72
40186: NOT
40187: OR
40188: IFFALSE 40192
// continue ;
40190: GO 40146
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
40192: LD_ADDR_VAR 0 5
40196: PUSH
40197: LD_EXP 122
40201: PUSH
40202: LD_VAR 0 2
40206: ARRAY
40207: PUSH
40208: LD_INT 1
40210: ARRAY
40211: PPUSH
40212: CALL_OW 255
40216: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
40217: LD_VAR 0 5
40221: PPUSH
40222: LD_INT 2
40224: PPUSH
40225: CALL_OW 325
40229: IFFALSE 40482
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
40231: LD_ADDR_VAR 0 4
40235: PUSH
40236: LD_EXP 122
40240: PUSH
40241: LD_VAR 0 2
40245: ARRAY
40246: PPUSH
40247: LD_INT 25
40249: PUSH
40250: LD_INT 16
40252: PUSH
40253: EMPTY
40254: LIST
40255: LIST
40256: PPUSH
40257: CALL_OW 72
40261: ST_TO_ADDR
// if tmp < 6 then
40262: LD_VAR 0 4
40266: PUSH
40267: LD_INT 6
40269: LESS
40270: IFFALSE 40482
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40272: LD_ADDR_VAR 0 6
40276: PUSH
40277: LD_EXP 93
40281: PUSH
40282: LD_VAR 0 2
40286: ARRAY
40287: PPUSH
40288: LD_INT 2
40290: PUSH
40291: LD_INT 30
40293: PUSH
40294: LD_INT 0
40296: PUSH
40297: EMPTY
40298: LIST
40299: LIST
40300: PUSH
40301: LD_INT 30
40303: PUSH
40304: LD_INT 1
40306: PUSH
40307: EMPTY
40308: LIST
40309: LIST
40310: PUSH
40311: EMPTY
40312: LIST
40313: LIST
40314: LIST
40315: PPUSH
40316: CALL_OW 72
40320: ST_TO_ADDR
// if depot then
40321: LD_VAR 0 6
40325: IFFALSE 40482
// begin selected := 0 ;
40327: LD_ADDR_VAR 0 7
40331: PUSH
40332: LD_INT 0
40334: ST_TO_ADDR
// for j in depot do
40335: LD_ADDR_VAR 0 3
40339: PUSH
40340: LD_VAR 0 6
40344: PUSH
40345: FOR_IN
40346: IFFALSE 40377
// begin if UnitsInside ( j ) < 6 then
40348: LD_VAR 0 3
40352: PPUSH
40353: CALL_OW 313
40357: PUSH
40358: LD_INT 6
40360: LESS
40361: IFFALSE 40375
// begin selected := j ;
40363: LD_ADDR_VAR 0 7
40367: PUSH
40368: LD_VAR 0 3
40372: ST_TO_ADDR
// break ;
40373: GO 40377
// end ; end ;
40375: GO 40345
40377: POP
40378: POP
// if selected then
40379: LD_VAR 0 7
40383: IFFALSE 40482
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
40385: LD_ADDR_VAR 0 3
40389: PUSH
40390: LD_EXP 122
40394: PUSH
40395: LD_VAR 0 2
40399: ARRAY
40400: PPUSH
40401: LD_INT 25
40403: PUSH
40404: LD_INT 12
40406: PUSH
40407: EMPTY
40408: LIST
40409: LIST
40410: PPUSH
40411: CALL_OW 72
40415: PUSH
40416: FOR_IN
40417: IFFALSE 40480
// if not HasTask ( j ) then
40419: LD_VAR 0 3
40423: PPUSH
40424: CALL_OW 314
40428: NOT
40429: IFFALSE 40478
// begin if not IsInUnit ( j ) then
40431: LD_VAR 0 3
40435: PPUSH
40436: CALL_OW 310
40440: NOT
40441: IFFALSE 40457
// ComEnterUnit ( j , selected ) ;
40443: LD_VAR 0 3
40447: PPUSH
40448: LD_VAR 0 7
40452: PPUSH
40453: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
40457: LD_VAR 0 3
40461: PPUSH
40462: LD_INT 16
40464: PPUSH
40465: CALL_OW 183
// AddComExitBuilding ( j ) ;
40469: LD_VAR 0 3
40473: PPUSH
40474: CALL_OW 182
// end ;
40478: GO 40416
40480: POP
40481: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
40482: LD_VAR 0 5
40486: PPUSH
40487: LD_INT 11
40489: PPUSH
40490: CALL_OW 325
40494: IFFALSE 40753
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
40496: LD_ADDR_VAR 0 4
40500: PUSH
40501: LD_EXP 122
40505: PUSH
40506: LD_VAR 0 2
40510: ARRAY
40511: PPUSH
40512: LD_INT 25
40514: PUSH
40515: LD_INT 16
40517: PUSH
40518: EMPTY
40519: LIST
40520: LIST
40521: PPUSH
40522: CALL_OW 72
40526: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
40527: LD_VAR 0 4
40531: PUSH
40532: LD_INT 6
40534: GREATEREQUAL
40535: PUSH
40536: LD_VAR 0 5
40540: PPUSH
40541: LD_INT 2
40543: PPUSH
40544: CALL_OW 325
40548: NOT
40549: OR
40550: IFFALSE 40753
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
40552: LD_ADDR_VAR 0 8
40556: PUSH
40557: LD_EXP 93
40561: PUSH
40562: LD_VAR 0 2
40566: ARRAY
40567: PPUSH
40568: LD_INT 2
40570: PUSH
40571: LD_INT 30
40573: PUSH
40574: LD_INT 4
40576: PUSH
40577: EMPTY
40578: LIST
40579: LIST
40580: PUSH
40581: LD_INT 30
40583: PUSH
40584: LD_INT 5
40586: PUSH
40587: EMPTY
40588: LIST
40589: LIST
40590: PUSH
40591: EMPTY
40592: LIST
40593: LIST
40594: LIST
40595: PPUSH
40596: CALL_OW 72
40600: ST_TO_ADDR
// if barracks then
40601: LD_VAR 0 8
40605: IFFALSE 40753
// begin selected := 0 ;
40607: LD_ADDR_VAR 0 7
40611: PUSH
40612: LD_INT 0
40614: ST_TO_ADDR
// for j in barracks do
40615: LD_ADDR_VAR 0 3
40619: PUSH
40620: LD_VAR 0 8
40624: PUSH
40625: FOR_IN
40626: IFFALSE 40657
// begin if UnitsInside ( j ) < 6 then
40628: LD_VAR 0 3
40632: PPUSH
40633: CALL_OW 313
40637: PUSH
40638: LD_INT 6
40640: LESS
40641: IFFALSE 40655
// begin selected := j ;
40643: LD_ADDR_VAR 0 7
40647: PUSH
40648: LD_VAR 0 3
40652: ST_TO_ADDR
// break ;
40653: GO 40657
// end ; end ;
40655: GO 40625
40657: POP
40658: POP
// if selected then
40659: LD_VAR 0 7
40663: IFFALSE 40753
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
40665: LD_ADDR_VAR 0 3
40669: PUSH
40670: LD_EXP 122
40674: PUSH
40675: LD_VAR 0 2
40679: ARRAY
40680: PPUSH
40681: LD_INT 25
40683: PUSH
40684: LD_INT 12
40686: PUSH
40687: EMPTY
40688: LIST
40689: LIST
40690: PPUSH
40691: CALL_OW 72
40695: PUSH
40696: FOR_IN
40697: IFFALSE 40751
// if not IsInUnit ( j ) and not HasTask ( j ) then
40699: LD_VAR 0 3
40703: PPUSH
40704: CALL_OW 310
40708: NOT
40709: PUSH
40710: LD_VAR 0 3
40714: PPUSH
40715: CALL_OW 314
40719: NOT
40720: AND
40721: IFFALSE 40749
// begin ComEnterUnit ( j , selected ) ;
40723: LD_VAR 0 3
40727: PPUSH
40728: LD_VAR 0 7
40732: PPUSH
40733: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
40737: LD_VAR 0 3
40741: PPUSH
40742: LD_INT 15
40744: PPUSH
40745: CALL_OW 183
// end ;
40749: GO 40696
40751: POP
40752: POP
// end ; end ; end ; end ; end ;
40753: GO 40146
40755: POP
40756: POP
// end ;
40757: LD_VAR 0 1
40761: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
40762: LD_INT 0
40764: PPUSH
40765: PPUSH
40766: PPUSH
40767: PPUSH
// if not mc_bases then
40768: LD_EXP 93
40772: NOT
40773: IFFALSE 40777
// exit ;
40775: GO 40955
// for i = 1 to mc_bases do
40777: LD_ADDR_VAR 0 2
40781: PUSH
40782: DOUBLE
40783: LD_INT 1
40785: DEC
40786: ST_TO_ADDR
40787: LD_EXP 93
40791: PUSH
40792: FOR_TO
40793: IFFALSE 40953
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
40795: LD_ADDR_VAR 0 4
40799: PUSH
40800: LD_EXP 93
40804: PUSH
40805: LD_VAR 0 2
40809: ARRAY
40810: PPUSH
40811: LD_INT 25
40813: PUSH
40814: LD_INT 9
40816: PUSH
40817: EMPTY
40818: LIST
40819: LIST
40820: PPUSH
40821: CALL_OW 72
40825: ST_TO_ADDR
// if not tmp then
40826: LD_VAR 0 4
40830: NOT
40831: IFFALSE 40835
// continue ;
40833: GO 40792
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
40835: LD_EXP 119
40839: PUSH
40840: LD_VAR 0 2
40844: ARRAY
40845: PPUSH
40846: LD_INT 29
40848: PPUSH
40849: CALL_OW 325
40853: NOT
40854: PUSH
40855: LD_EXP 119
40859: PUSH
40860: LD_VAR 0 2
40864: ARRAY
40865: PPUSH
40866: LD_INT 28
40868: PPUSH
40869: CALL_OW 325
40873: NOT
40874: AND
40875: IFFALSE 40879
// continue ;
40877: GO 40792
// for j in tmp do
40879: LD_ADDR_VAR 0 3
40883: PUSH
40884: LD_VAR 0 4
40888: PUSH
40889: FOR_IN
40890: IFFALSE 40949
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
40892: LD_VAR 0 3
40896: PUSH
40897: LD_EXP 96
40901: PUSH
40902: LD_VAR 0 2
40906: ARRAY
40907: PUSH
40908: LD_INT 1
40910: ARRAY
40911: IN
40912: NOT
40913: PUSH
40914: LD_VAR 0 3
40918: PUSH
40919: LD_EXP 96
40923: PUSH
40924: LD_VAR 0 2
40928: ARRAY
40929: PUSH
40930: LD_INT 2
40932: ARRAY
40933: IN
40934: NOT
40935: AND
40936: IFFALSE 40947
// ComSpaceTimeShoot ( j ) ;
40938: LD_VAR 0 3
40942: PPUSH
40943: CALL 52159 0 1
40947: GO 40889
40949: POP
40950: POP
// end ;
40951: GO 40792
40953: POP
40954: POP
// end ;
40955: LD_VAR 0 1
40959: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
40960: LD_INT 0
40962: PPUSH
40963: PPUSH
40964: PPUSH
40965: PPUSH
40966: PPUSH
40967: PPUSH
40968: PPUSH
40969: PPUSH
40970: PPUSH
// if not mc_bases then
40971: LD_EXP 93
40975: NOT
40976: IFFALSE 40980
// exit ;
40978: GO 41602
// for i = 1 to mc_bases do
40980: LD_ADDR_VAR 0 2
40984: PUSH
40985: DOUBLE
40986: LD_INT 1
40988: DEC
40989: ST_TO_ADDR
40990: LD_EXP 93
40994: PUSH
40995: FOR_TO
40996: IFFALSE 41600
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
40998: LD_EXP 128
41002: PUSH
41003: LD_VAR 0 2
41007: ARRAY
41008: NOT
41009: PUSH
41010: LD_INT 38
41012: PPUSH
41013: LD_EXP 119
41017: PUSH
41018: LD_VAR 0 2
41022: ARRAY
41023: PPUSH
41024: CALL_OW 321
41028: PUSH
41029: LD_INT 2
41031: NONEQUAL
41032: OR
41033: IFFALSE 41037
// continue ;
41035: GO 40995
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
41037: LD_ADDR_VAR 0 8
41041: PUSH
41042: LD_EXP 93
41046: PUSH
41047: LD_VAR 0 2
41051: ARRAY
41052: PPUSH
41053: LD_INT 30
41055: PUSH
41056: LD_INT 34
41058: PUSH
41059: EMPTY
41060: LIST
41061: LIST
41062: PPUSH
41063: CALL_OW 72
41067: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
41068: LD_ADDR_VAR 0 9
41072: PUSH
41073: LD_EXP 93
41077: PUSH
41078: LD_VAR 0 2
41082: ARRAY
41083: PPUSH
41084: LD_INT 25
41086: PUSH
41087: LD_INT 4
41089: PUSH
41090: EMPTY
41091: LIST
41092: LIST
41093: PPUSH
41094: CALL_OW 72
41098: PPUSH
41099: LD_INT 0
41101: PPUSH
41102: CALL 85468 0 2
41106: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
41107: LD_VAR 0 9
41111: NOT
41112: PUSH
41113: LD_VAR 0 8
41117: NOT
41118: OR
41119: PUSH
41120: LD_EXP 93
41124: PUSH
41125: LD_VAR 0 2
41129: ARRAY
41130: PPUSH
41131: LD_INT 124
41133: PPUSH
41134: CALL 85468 0 2
41138: OR
41139: IFFALSE 41143
// continue ;
41141: GO 40995
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
41143: LD_EXP 129
41147: PUSH
41148: LD_VAR 0 2
41152: ARRAY
41153: PUSH
41154: LD_EXP 128
41158: PUSH
41159: LD_VAR 0 2
41163: ARRAY
41164: LESS
41165: PUSH
41166: LD_EXP 129
41170: PUSH
41171: LD_VAR 0 2
41175: ARRAY
41176: PUSH
41177: LD_VAR 0 8
41181: LESS
41182: AND
41183: IFFALSE 41598
// begin tmp := sci [ 1 ] ;
41185: LD_ADDR_VAR 0 7
41189: PUSH
41190: LD_VAR 0 9
41194: PUSH
41195: LD_INT 1
41197: ARRAY
41198: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
41199: LD_VAR 0 7
41203: PPUSH
41204: LD_INT 124
41206: PPUSH
41207: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
41211: LD_ADDR_VAR 0 3
41215: PUSH
41216: DOUBLE
41217: LD_EXP 128
41221: PUSH
41222: LD_VAR 0 2
41226: ARRAY
41227: INC
41228: ST_TO_ADDR
41229: LD_EXP 128
41233: PUSH
41234: LD_VAR 0 2
41238: ARRAY
41239: PUSH
41240: FOR_DOWNTO
41241: IFFALSE 41584
// begin if IsInUnit ( tmp ) then
41243: LD_VAR 0 7
41247: PPUSH
41248: CALL_OW 310
41252: IFFALSE 41263
// ComExitBuilding ( tmp ) ;
41254: LD_VAR 0 7
41258: PPUSH
41259: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
41263: LD_INT 35
41265: PPUSH
41266: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
41270: LD_VAR 0 7
41274: PPUSH
41275: CALL_OW 310
41279: NOT
41280: PUSH
41281: LD_VAR 0 7
41285: PPUSH
41286: CALL_OW 314
41290: NOT
41291: AND
41292: IFFALSE 41263
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
41294: LD_ADDR_VAR 0 6
41298: PUSH
41299: LD_VAR 0 7
41303: PPUSH
41304: CALL_OW 250
41308: PUSH
41309: LD_VAR 0 7
41313: PPUSH
41314: CALL_OW 251
41318: PUSH
41319: EMPTY
41320: LIST
41321: LIST
41322: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
41323: LD_INT 35
41325: PPUSH
41326: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
41330: LD_ADDR_VAR 0 4
41334: PUSH
41335: LD_EXP 128
41339: PUSH
41340: LD_VAR 0 2
41344: ARRAY
41345: PUSH
41346: LD_VAR 0 3
41350: ARRAY
41351: PUSH
41352: LD_INT 1
41354: ARRAY
41355: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
41356: LD_ADDR_VAR 0 5
41360: PUSH
41361: LD_EXP 128
41365: PUSH
41366: LD_VAR 0 2
41370: ARRAY
41371: PUSH
41372: LD_VAR 0 3
41376: ARRAY
41377: PUSH
41378: LD_INT 2
41380: ARRAY
41381: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
41382: LD_VAR 0 7
41386: PPUSH
41387: LD_INT 10
41389: PPUSH
41390: CALL 58797 0 2
41394: PUSH
41395: LD_INT 4
41397: ARRAY
41398: IFFALSE 41436
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
41400: LD_VAR 0 7
41404: PPUSH
41405: LD_VAR 0 6
41409: PUSH
41410: LD_INT 1
41412: ARRAY
41413: PPUSH
41414: LD_VAR 0 6
41418: PUSH
41419: LD_INT 2
41421: ARRAY
41422: PPUSH
41423: CALL_OW 111
// wait ( 0 0$10 ) ;
41427: LD_INT 350
41429: PPUSH
41430: CALL_OW 67
// end else
41434: GO 41462
// begin ComMoveXY ( tmp , x , y ) ;
41436: LD_VAR 0 7
41440: PPUSH
41441: LD_VAR 0 4
41445: PPUSH
41446: LD_VAR 0 5
41450: PPUSH
41451: CALL_OW 111
// wait ( 0 0$3 ) ;
41455: LD_INT 105
41457: PPUSH
41458: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
41462: LD_VAR 0 7
41466: PPUSH
41467: LD_VAR 0 4
41471: PPUSH
41472: LD_VAR 0 5
41476: PPUSH
41477: CALL_OW 307
41481: IFFALSE 41323
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
41483: LD_VAR 0 7
41487: PPUSH
41488: LD_VAR 0 4
41492: PPUSH
41493: LD_VAR 0 5
41497: PPUSH
41498: LD_VAR 0 8
41502: PUSH
41503: LD_VAR 0 3
41507: ARRAY
41508: PPUSH
41509: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
41513: LD_INT 35
41515: PPUSH
41516: CALL_OW 67
// until not HasTask ( tmp ) ;
41520: LD_VAR 0 7
41524: PPUSH
41525: CALL_OW 314
41529: NOT
41530: IFFALSE 41513
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
41532: LD_ADDR_EXP 129
41536: PUSH
41537: LD_EXP 129
41541: PPUSH
41542: LD_VAR 0 2
41546: PUSH
41547: LD_EXP 129
41551: PUSH
41552: LD_VAR 0 2
41556: ARRAY
41557: PUSH
41558: LD_INT 1
41560: PLUS
41561: PUSH
41562: EMPTY
41563: LIST
41564: LIST
41565: PPUSH
41566: LD_VAR 0 8
41570: PUSH
41571: LD_VAR 0 3
41575: ARRAY
41576: PPUSH
41577: CALL 56198 0 3
41581: ST_TO_ADDR
// end ;
41582: GO 41240
41584: POP
41585: POP
// MC_Reset ( i , 124 ) ;
41586: LD_VAR 0 2
41590: PPUSH
41591: LD_INT 124
41593: PPUSH
41594: CALL 24956 0 2
// end ; end ;
41598: GO 40995
41600: POP
41601: POP
// end ;
41602: LD_VAR 0 1
41606: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
41607: LD_INT 0
41609: PPUSH
41610: PPUSH
41611: PPUSH
// if not mc_bases then
41612: LD_EXP 93
41616: NOT
41617: IFFALSE 41621
// exit ;
41619: GO 42227
// for i = 1 to mc_bases do
41621: LD_ADDR_VAR 0 2
41625: PUSH
41626: DOUBLE
41627: LD_INT 1
41629: DEC
41630: ST_TO_ADDR
41631: LD_EXP 93
41635: PUSH
41636: FOR_TO
41637: IFFALSE 42225
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
41639: LD_ADDR_VAR 0 3
41643: PUSH
41644: LD_EXP 93
41648: PUSH
41649: LD_VAR 0 2
41653: ARRAY
41654: PPUSH
41655: LD_INT 25
41657: PUSH
41658: LD_INT 4
41660: PUSH
41661: EMPTY
41662: LIST
41663: LIST
41664: PPUSH
41665: CALL_OW 72
41669: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
41670: LD_VAR 0 3
41674: NOT
41675: PUSH
41676: LD_EXP 130
41680: PUSH
41681: LD_VAR 0 2
41685: ARRAY
41686: NOT
41687: OR
41688: PUSH
41689: LD_EXP 93
41693: PUSH
41694: LD_VAR 0 2
41698: ARRAY
41699: PPUSH
41700: LD_INT 2
41702: PUSH
41703: LD_INT 30
41705: PUSH
41706: LD_INT 0
41708: PUSH
41709: EMPTY
41710: LIST
41711: LIST
41712: PUSH
41713: LD_INT 30
41715: PUSH
41716: LD_INT 1
41718: PUSH
41719: EMPTY
41720: LIST
41721: LIST
41722: PUSH
41723: EMPTY
41724: LIST
41725: LIST
41726: LIST
41727: PPUSH
41728: CALL_OW 72
41732: NOT
41733: OR
41734: IFFALSE 41784
// begin if mc_deposits_finder [ i ] then
41736: LD_EXP 131
41740: PUSH
41741: LD_VAR 0 2
41745: ARRAY
41746: IFFALSE 41782
// begin MC_Reset ( i , 125 ) ;
41748: LD_VAR 0 2
41752: PPUSH
41753: LD_INT 125
41755: PPUSH
41756: CALL 24956 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41760: LD_ADDR_EXP 131
41764: PUSH
41765: LD_EXP 131
41769: PPUSH
41770: LD_VAR 0 2
41774: PPUSH
41775: EMPTY
41776: PPUSH
41777: CALL_OW 1
41781: ST_TO_ADDR
// end ; continue ;
41782: GO 41636
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
41784: LD_EXP 130
41788: PUSH
41789: LD_VAR 0 2
41793: ARRAY
41794: PUSH
41795: LD_INT 1
41797: ARRAY
41798: PUSH
41799: LD_INT 3
41801: ARRAY
41802: PUSH
41803: LD_INT 1
41805: EQUAL
41806: PUSH
41807: LD_INT 20
41809: PPUSH
41810: LD_EXP 119
41814: PUSH
41815: LD_VAR 0 2
41819: ARRAY
41820: PPUSH
41821: CALL_OW 321
41825: PUSH
41826: LD_INT 2
41828: NONEQUAL
41829: AND
41830: IFFALSE 41880
// begin if mc_deposits_finder [ i ] then
41832: LD_EXP 131
41836: PUSH
41837: LD_VAR 0 2
41841: ARRAY
41842: IFFALSE 41878
// begin MC_Reset ( i , 125 ) ;
41844: LD_VAR 0 2
41848: PPUSH
41849: LD_INT 125
41851: PPUSH
41852: CALL 24956 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41856: LD_ADDR_EXP 131
41860: PUSH
41861: LD_EXP 131
41865: PPUSH
41866: LD_VAR 0 2
41870: PPUSH
41871: EMPTY
41872: PPUSH
41873: CALL_OW 1
41877: ST_TO_ADDR
// end ; continue ;
41878: GO 41636
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
41880: LD_EXP 130
41884: PUSH
41885: LD_VAR 0 2
41889: ARRAY
41890: PUSH
41891: LD_INT 1
41893: ARRAY
41894: PUSH
41895: LD_INT 1
41897: ARRAY
41898: PPUSH
41899: LD_EXP 130
41903: PUSH
41904: LD_VAR 0 2
41908: ARRAY
41909: PUSH
41910: LD_INT 1
41912: ARRAY
41913: PUSH
41914: LD_INT 2
41916: ARRAY
41917: PPUSH
41918: LD_EXP 119
41922: PUSH
41923: LD_VAR 0 2
41927: ARRAY
41928: PPUSH
41929: CALL_OW 440
41933: IFFALSE 41976
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
41935: LD_ADDR_EXP 130
41939: PUSH
41940: LD_EXP 130
41944: PPUSH
41945: LD_VAR 0 2
41949: PPUSH
41950: LD_EXP 130
41954: PUSH
41955: LD_VAR 0 2
41959: ARRAY
41960: PPUSH
41961: LD_INT 1
41963: PPUSH
41964: CALL_OW 3
41968: PPUSH
41969: CALL_OW 1
41973: ST_TO_ADDR
41974: GO 42223
// begin if not mc_deposits_finder [ i ] then
41976: LD_EXP 131
41980: PUSH
41981: LD_VAR 0 2
41985: ARRAY
41986: NOT
41987: IFFALSE 42039
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
41989: LD_ADDR_EXP 131
41993: PUSH
41994: LD_EXP 131
41998: PPUSH
41999: LD_VAR 0 2
42003: PPUSH
42004: LD_VAR 0 3
42008: PUSH
42009: LD_INT 1
42011: ARRAY
42012: PUSH
42013: EMPTY
42014: LIST
42015: PPUSH
42016: CALL_OW 1
42020: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
42021: LD_VAR 0 3
42025: PUSH
42026: LD_INT 1
42028: ARRAY
42029: PPUSH
42030: LD_INT 125
42032: PPUSH
42033: CALL_OW 109
// end else
42037: GO 42223
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
42039: LD_EXP 131
42043: PUSH
42044: LD_VAR 0 2
42048: ARRAY
42049: PUSH
42050: LD_INT 1
42052: ARRAY
42053: PPUSH
42054: CALL_OW 310
42058: IFFALSE 42081
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
42060: LD_EXP 131
42064: PUSH
42065: LD_VAR 0 2
42069: ARRAY
42070: PUSH
42071: LD_INT 1
42073: ARRAY
42074: PPUSH
42075: CALL_OW 122
42079: GO 42223
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
42081: LD_EXP 131
42085: PUSH
42086: LD_VAR 0 2
42090: ARRAY
42091: PUSH
42092: LD_INT 1
42094: ARRAY
42095: PPUSH
42096: CALL_OW 314
42100: NOT
42101: PUSH
42102: LD_EXP 131
42106: PUSH
42107: LD_VAR 0 2
42111: ARRAY
42112: PUSH
42113: LD_INT 1
42115: ARRAY
42116: PPUSH
42117: LD_EXP 130
42121: PUSH
42122: LD_VAR 0 2
42126: ARRAY
42127: PUSH
42128: LD_INT 1
42130: ARRAY
42131: PUSH
42132: LD_INT 1
42134: ARRAY
42135: PPUSH
42136: LD_EXP 130
42140: PUSH
42141: LD_VAR 0 2
42145: ARRAY
42146: PUSH
42147: LD_INT 1
42149: ARRAY
42150: PUSH
42151: LD_INT 2
42153: ARRAY
42154: PPUSH
42155: CALL_OW 297
42159: PUSH
42160: LD_INT 6
42162: GREATER
42163: AND
42164: IFFALSE 42223
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
42166: LD_EXP 131
42170: PUSH
42171: LD_VAR 0 2
42175: ARRAY
42176: PUSH
42177: LD_INT 1
42179: ARRAY
42180: PPUSH
42181: LD_EXP 130
42185: PUSH
42186: LD_VAR 0 2
42190: ARRAY
42191: PUSH
42192: LD_INT 1
42194: ARRAY
42195: PUSH
42196: LD_INT 1
42198: ARRAY
42199: PPUSH
42200: LD_EXP 130
42204: PUSH
42205: LD_VAR 0 2
42209: ARRAY
42210: PUSH
42211: LD_INT 1
42213: ARRAY
42214: PUSH
42215: LD_INT 2
42217: ARRAY
42218: PPUSH
42219: CALL_OW 111
// end ; end ; end ;
42223: GO 41636
42225: POP
42226: POP
// end ;
42227: LD_VAR 0 1
42231: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
42232: LD_INT 0
42234: PPUSH
42235: PPUSH
42236: PPUSH
42237: PPUSH
42238: PPUSH
42239: PPUSH
42240: PPUSH
42241: PPUSH
42242: PPUSH
42243: PPUSH
42244: PPUSH
// if not mc_bases then
42245: LD_EXP 93
42249: NOT
42250: IFFALSE 42254
// exit ;
42252: GO 43194
// for i = 1 to mc_bases do
42254: LD_ADDR_VAR 0 2
42258: PUSH
42259: DOUBLE
42260: LD_INT 1
42262: DEC
42263: ST_TO_ADDR
42264: LD_EXP 93
42268: PUSH
42269: FOR_TO
42270: IFFALSE 43192
// begin if not mc_bases [ i ] or mc_scan [ i ] then
42272: LD_EXP 93
42276: PUSH
42277: LD_VAR 0 2
42281: ARRAY
42282: NOT
42283: PUSH
42284: LD_EXP 116
42288: PUSH
42289: LD_VAR 0 2
42293: ARRAY
42294: OR
42295: IFFALSE 42299
// continue ;
42297: GO 42269
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
42299: LD_ADDR_VAR 0 7
42303: PUSH
42304: LD_EXP 93
42308: PUSH
42309: LD_VAR 0 2
42313: ARRAY
42314: PUSH
42315: LD_INT 1
42317: ARRAY
42318: PPUSH
42319: CALL_OW 248
42323: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
42324: LD_VAR 0 7
42328: PUSH
42329: LD_INT 3
42331: EQUAL
42332: PUSH
42333: LD_EXP 112
42337: PUSH
42338: LD_VAR 0 2
42342: ARRAY
42343: PUSH
42344: LD_EXP 115
42348: PUSH
42349: LD_VAR 0 2
42353: ARRAY
42354: UNION
42355: PPUSH
42356: LD_INT 33
42358: PUSH
42359: LD_INT 2
42361: PUSH
42362: EMPTY
42363: LIST
42364: LIST
42365: PPUSH
42366: CALL_OW 72
42370: NOT
42371: OR
42372: IFFALSE 42376
// continue ;
42374: GO 42269
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
42376: LD_ADDR_VAR 0 9
42380: PUSH
42381: LD_EXP 93
42385: PUSH
42386: LD_VAR 0 2
42390: ARRAY
42391: PPUSH
42392: LD_INT 30
42394: PUSH
42395: LD_INT 36
42397: PUSH
42398: EMPTY
42399: LIST
42400: LIST
42401: PPUSH
42402: CALL_OW 72
42406: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
42407: LD_ADDR_VAR 0 10
42411: PUSH
42412: LD_EXP 112
42416: PUSH
42417: LD_VAR 0 2
42421: ARRAY
42422: PPUSH
42423: LD_INT 34
42425: PUSH
42426: LD_INT 31
42428: PUSH
42429: EMPTY
42430: LIST
42431: LIST
42432: PPUSH
42433: CALL_OW 72
42437: ST_TO_ADDR
// if not cts and not mcts then
42438: LD_VAR 0 9
42442: NOT
42443: PUSH
42444: LD_VAR 0 10
42448: NOT
42449: AND
42450: IFFALSE 42454
// continue ;
42452: GO 42269
// x := cts ;
42454: LD_ADDR_VAR 0 11
42458: PUSH
42459: LD_VAR 0 9
42463: ST_TO_ADDR
// if not x then
42464: LD_VAR 0 11
42468: NOT
42469: IFFALSE 42481
// x := mcts ;
42471: LD_ADDR_VAR 0 11
42475: PUSH
42476: LD_VAR 0 10
42480: ST_TO_ADDR
// if not x then
42481: LD_VAR 0 11
42485: NOT
42486: IFFALSE 42490
// continue ;
42488: GO 42269
// if mc_remote_driver [ i ] then
42490: LD_EXP 133
42494: PUSH
42495: LD_VAR 0 2
42499: ARRAY
42500: IFFALSE 42887
// for j in mc_remote_driver [ i ] do
42502: LD_ADDR_VAR 0 3
42506: PUSH
42507: LD_EXP 133
42511: PUSH
42512: LD_VAR 0 2
42516: ARRAY
42517: PUSH
42518: FOR_IN
42519: IFFALSE 42885
// begin if GetClass ( j ) <> 3 then
42521: LD_VAR 0 3
42525: PPUSH
42526: CALL_OW 257
42530: PUSH
42531: LD_INT 3
42533: NONEQUAL
42534: IFFALSE 42587
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
42536: LD_ADDR_EXP 133
42540: PUSH
42541: LD_EXP 133
42545: PPUSH
42546: LD_VAR 0 2
42550: PPUSH
42551: LD_EXP 133
42555: PUSH
42556: LD_VAR 0 2
42560: ARRAY
42561: PUSH
42562: LD_VAR 0 3
42566: DIFF
42567: PPUSH
42568: CALL_OW 1
42572: ST_TO_ADDR
// SetTag ( j , 0 ) ;
42573: LD_VAR 0 3
42577: PPUSH
42578: LD_INT 0
42580: PPUSH
42581: CALL_OW 109
// continue ;
42585: GO 42518
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
42587: LD_EXP 112
42591: PUSH
42592: LD_VAR 0 2
42596: ARRAY
42597: PPUSH
42598: LD_INT 34
42600: PUSH
42601: LD_INT 31
42603: PUSH
42604: EMPTY
42605: LIST
42606: LIST
42607: PUSH
42608: LD_INT 58
42610: PUSH
42611: EMPTY
42612: LIST
42613: PUSH
42614: EMPTY
42615: LIST
42616: LIST
42617: PPUSH
42618: CALL_OW 72
42622: PUSH
42623: LD_VAR 0 3
42627: PPUSH
42628: CALL 85556 0 1
42632: NOT
42633: AND
42634: IFFALSE 42705
// begin if IsInUnit ( j ) then
42636: LD_VAR 0 3
42640: PPUSH
42641: CALL_OW 310
42645: IFFALSE 42656
// ComExitBuilding ( j ) ;
42647: LD_VAR 0 3
42651: PPUSH
42652: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
42656: LD_VAR 0 3
42660: PPUSH
42661: LD_EXP 112
42665: PUSH
42666: LD_VAR 0 2
42670: ARRAY
42671: PPUSH
42672: LD_INT 34
42674: PUSH
42675: LD_INT 31
42677: PUSH
42678: EMPTY
42679: LIST
42680: LIST
42681: PUSH
42682: LD_INT 58
42684: PUSH
42685: EMPTY
42686: LIST
42687: PUSH
42688: EMPTY
42689: LIST
42690: LIST
42691: PPUSH
42692: CALL_OW 72
42696: PUSH
42697: LD_INT 1
42699: ARRAY
42700: PPUSH
42701: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
42705: LD_VAR 0 3
42709: PPUSH
42710: CALL_OW 310
42714: NOT
42715: PUSH
42716: LD_VAR 0 3
42720: PPUSH
42721: CALL_OW 310
42725: PPUSH
42726: CALL_OW 266
42730: PUSH
42731: LD_INT 36
42733: NONEQUAL
42734: PUSH
42735: LD_VAR 0 3
42739: PPUSH
42740: CALL 85556 0 1
42744: NOT
42745: AND
42746: OR
42747: IFFALSE 42883
// begin if IsInUnit ( j ) then
42749: LD_VAR 0 3
42753: PPUSH
42754: CALL_OW 310
42758: IFFALSE 42769
// ComExitBuilding ( j ) ;
42760: LD_VAR 0 3
42764: PPUSH
42765: CALL_OW 122
// ct := 0 ;
42769: LD_ADDR_VAR 0 8
42773: PUSH
42774: LD_INT 0
42776: ST_TO_ADDR
// for k in x do
42777: LD_ADDR_VAR 0 4
42781: PUSH
42782: LD_VAR 0 11
42786: PUSH
42787: FOR_IN
42788: IFFALSE 42861
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
42790: LD_VAR 0 4
42794: PPUSH
42795: CALL_OW 264
42799: PUSH
42800: LD_INT 31
42802: EQUAL
42803: PUSH
42804: LD_VAR 0 4
42808: PPUSH
42809: CALL_OW 311
42813: NOT
42814: AND
42815: PUSH
42816: LD_VAR 0 4
42820: PPUSH
42821: CALL_OW 266
42825: PUSH
42826: LD_INT 36
42828: EQUAL
42829: PUSH
42830: LD_VAR 0 4
42834: PPUSH
42835: CALL_OW 313
42839: PUSH
42840: LD_INT 3
42842: LESS
42843: AND
42844: OR
42845: IFFALSE 42859
// begin ct := k ;
42847: LD_ADDR_VAR 0 8
42851: PUSH
42852: LD_VAR 0 4
42856: ST_TO_ADDR
// break ;
42857: GO 42861
// end ;
42859: GO 42787
42861: POP
42862: POP
// if ct then
42863: LD_VAR 0 8
42867: IFFALSE 42883
// ComEnterUnit ( j , ct ) ;
42869: LD_VAR 0 3
42873: PPUSH
42874: LD_VAR 0 8
42878: PPUSH
42879: CALL_OW 120
// end ; end ;
42883: GO 42518
42885: POP
42886: POP
// places := 0 ;
42887: LD_ADDR_VAR 0 5
42891: PUSH
42892: LD_INT 0
42894: ST_TO_ADDR
// for j = 1 to x do
42895: LD_ADDR_VAR 0 3
42899: PUSH
42900: DOUBLE
42901: LD_INT 1
42903: DEC
42904: ST_TO_ADDR
42905: LD_VAR 0 11
42909: PUSH
42910: FOR_TO
42911: IFFALSE 42987
// if GetWeapon ( x [ j ] ) = ar_control_tower then
42913: LD_VAR 0 11
42917: PUSH
42918: LD_VAR 0 3
42922: ARRAY
42923: PPUSH
42924: CALL_OW 264
42928: PUSH
42929: LD_INT 31
42931: EQUAL
42932: IFFALSE 42950
// places := places + 1 else
42934: LD_ADDR_VAR 0 5
42938: PUSH
42939: LD_VAR 0 5
42943: PUSH
42944: LD_INT 1
42946: PLUS
42947: ST_TO_ADDR
42948: GO 42985
// if GetBType ( x [ j ] ) = b_control_tower then
42950: LD_VAR 0 11
42954: PUSH
42955: LD_VAR 0 3
42959: ARRAY
42960: PPUSH
42961: CALL_OW 266
42965: PUSH
42966: LD_INT 36
42968: EQUAL
42969: IFFALSE 42985
// places := places + 3 ;
42971: LD_ADDR_VAR 0 5
42975: PUSH
42976: LD_VAR 0 5
42980: PUSH
42981: LD_INT 3
42983: PLUS
42984: ST_TO_ADDR
42985: GO 42910
42987: POP
42988: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
42989: LD_VAR 0 5
42993: PUSH
42994: LD_INT 0
42996: EQUAL
42997: PUSH
42998: LD_VAR 0 5
43002: PUSH
43003: LD_EXP 133
43007: PUSH
43008: LD_VAR 0 2
43012: ARRAY
43013: LESSEQUAL
43014: OR
43015: IFFALSE 43019
// continue ;
43017: GO 42269
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
43019: LD_ADDR_VAR 0 6
43023: PUSH
43024: LD_EXP 93
43028: PUSH
43029: LD_VAR 0 2
43033: ARRAY
43034: PPUSH
43035: LD_INT 25
43037: PUSH
43038: LD_INT 3
43040: PUSH
43041: EMPTY
43042: LIST
43043: LIST
43044: PPUSH
43045: CALL_OW 72
43049: PUSH
43050: LD_EXP 133
43054: PUSH
43055: LD_VAR 0 2
43059: ARRAY
43060: DIFF
43061: PPUSH
43062: LD_INT 3
43064: PPUSH
43065: CALL 86456 0 2
43069: ST_TO_ADDR
// for j in tmp do
43070: LD_ADDR_VAR 0 3
43074: PUSH
43075: LD_VAR 0 6
43079: PUSH
43080: FOR_IN
43081: IFFALSE 43116
// if GetTag ( j ) > 0 then
43083: LD_VAR 0 3
43087: PPUSH
43088: CALL_OW 110
43092: PUSH
43093: LD_INT 0
43095: GREATER
43096: IFFALSE 43114
// tmp := tmp diff j ;
43098: LD_ADDR_VAR 0 6
43102: PUSH
43103: LD_VAR 0 6
43107: PUSH
43108: LD_VAR 0 3
43112: DIFF
43113: ST_TO_ADDR
43114: GO 43080
43116: POP
43117: POP
// if not tmp then
43118: LD_VAR 0 6
43122: NOT
43123: IFFALSE 43127
// continue ;
43125: GO 42269
// if places then
43127: LD_VAR 0 5
43131: IFFALSE 43190
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
43133: LD_ADDR_EXP 133
43137: PUSH
43138: LD_EXP 133
43142: PPUSH
43143: LD_VAR 0 2
43147: PPUSH
43148: LD_EXP 133
43152: PUSH
43153: LD_VAR 0 2
43157: ARRAY
43158: PUSH
43159: LD_VAR 0 6
43163: PUSH
43164: LD_INT 1
43166: ARRAY
43167: UNION
43168: PPUSH
43169: CALL_OW 1
43173: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
43174: LD_VAR 0 6
43178: PUSH
43179: LD_INT 1
43181: ARRAY
43182: PPUSH
43183: LD_INT 126
43185: PPUSH
43186: CALL_OW 109
// end ; end ;
43190: GO 42269
43192: POP
43193: POP
// end ;
43194: LD_VAR 0 1
43198: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
43199: LD_INT 0
43201: PPUSH
43202: PPUSH
43203: PPUSH
43204: PPUSH
43205: PPUSH
43206: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
43207: LD_VAR 0 1
43211: NOT
43212: PUSH
43213: LD_VAR 0 2
43217: NOT
43218: OR
43219: PUSH
43220: LD_VAR 0 3
43224: NOT
43225: OR
43226: PUSH
43227: LD_VAR 0 4
43231: PUSH
43232: LD_INT 1
43234: PUSH
43235: LD_INT 2
43237: PUSH
43238: LD_INT 3
43240: PUSH
43241: LD_INT 4
43243: PUSH
43244: LD_INT 5
43246: PUSH
43247: LD_INT 8
43249: PUSH
43250: LD_INT 9
43252: PUSH
43253: LD_INT 15
43255: PUSH
43256: LD_INT 16
43258: PUSH
43259: EMPTY
43260: LIST
43261: LIST
43262: LIST
43263: LIST
43264: LIST
43265: LIST
43266: LIST
43267: LIST
43268: LIST
43269: IN
43270: NOT
43271: OR
43272: IFFALSE 43276
// exit ;
43274: GO 44176
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
43276: LD_ADDR_VAR 0 2
43280: PUSH
43281: LD_VAR 0 2
43285: PPUSH
43286: LD_INT 21
43288: PUSH
43289: LD_INT 3
43291: PUSH
43292: EMPTY
43293: LIST
43294: LIST
43295: PUSH
43296: LD_INT 24
43298: PUSH
43299: LD_INT 250
43301: PUSH
43302: EMPTY
43303: LIST
43304: LIST
43305: PUSH
43306: EMPTY
43307: LIST
43308: LIST
43309: PPUSH
43310: CALL_OW 72
43314: ST_TO_ADDR
// case class of 1 , 15 :
43315: LD_VAR 0 4
43319: PUSH
43320: LD_INT 1
43322: DOUBLE
43323: EQUAL
43324: IFTRUE 43334
43326: LD_INT 15
43328: DOUBLE
43329: EQUAL
43330: IFTRUE 43334
43332: GO 43419
43334: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
43335: LD_ADDR_VAR 0 8
43339: PUSH
43340: LD_VAR 0 2
43344: PPUSH
43345: LD_INT 2
43347: PUSH
43348: LD_INT 30
43350: PUSH
43351: LD_INT 32
43353: PUSH
43354: EMPTY
43355: LIST
43356: LIST
43357: PUSH
43358: LD_INT 30
43360: PUSH
43361: LD_INT 31
43363: PUSH
43364: EMPTY
43365: LIST
43366: LIST
43367: PUSH
43368: EMPTY
43369: LIST
43370: LIST
43371: LIST
43372: PPUSH
43373: CALL_OW 72
43377: PUSH
43378: LD_VAR 0 2
43382: PPUSH
43383: LD_INT 2
43385: PUSH
43386: LD_INT 30
43388: PUSH
43389: LD_INT 4
43391: PUSH
43392: EMPTY
43393: LIST
43394: LIST
43395: PUSH
43396: LD_INT 30
43398: PUSH
43399: LD_INT 5
43401: PUSH
43402: EMPTY
43403: LIST
43404: LIST
43405: PUSH
43406: EMPTY
43407: LIST
43408: LIST
43409: LIST
43410: PPUSH
43411: CALL_OW 72
43415: ADD
43416: ST_TO_ADDR
43417: GO 43665
43419: LD_INT 2
43421: DOUBLE
43422: EQUAL
43423: IFTRUE 43433
43425: LD_INT 16
43427: DOUBLE
43428: EQUAL
43429: IFTRUE 43433
43431: GO 43479
43433: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
43434: LD_ADDR_VAR 0 8
43438: PUSH
43439: LD_VAR 0 2
43443: PPUSH
43444: LD_INT 2
43446: PUSH
43447: LD_INT 30
43449: PUSH
43450: LD_INT 0
43452: PUSH
43453: EMPTY
43454: LIST
43455: LIST
43456: PUSH
43457: LD_INT 30
43459: PUSH
43460: LD_INT 1
43462: PUSH
43463: EMPTY
43464: LIST
43465: LIST
43466: PUSH
43467: EMPTY
43468: LIST
43469: LIST
43470: LIST
43471: PPUSH
43472: CALL_OW 72
43476: ST_TO_ADDR
43477: GO 43665
43479: LD_INT 3
43481: DOUBLE
43482: EQUAL
43483: IFTRUE 43487
43485: GO 43533
43487: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
43488: LD_ADDR_VAR 0 8
43492: PUSH
43493: LD_VAR 0 2
43497: PPUSH
43498: LD_INT 2
43500: PUSH
43501: LD_INT 30
43503: PUSH
43504: LD_INT 2
43506: PUSH
43507: EMPTY
43508: LIST
43509: LIST
43510: PUSH
43511: LD_INT 30
43513: PUSH
43514: LD_INT 3
43516: PUSH
43517: EMPTY
43518: LIST
43519: LIST
43520: PUSH
43521: EMPTY
43522: LIST
43523: LIST
43524: LIST
43525: PPUSH
43526: CALL_OW 72
43530: ST_TO_ADDR
43531: GO 43665
43533: LD_INT 4
43535: DOUBLE
43536: EQUAL
43537: IFTRUE 43541
43539: GO 43598
43541: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
43542: LD_ADDR_VAR 0 8
43546: PUSH
43547: LD_VAR 0 2
43551: PPUSH
43552: LD_INT 2
43554: PUSH
43555: LD_INT 30
43557: PUSH
43558: LD_INT 6
43560: PUSH
43561: EMPTY
43562: LIST
43563: LIST
43564: PUSH
43565: LD_INT 30
43567: PUSH
43568: LD_INT 7
43570: PUSH
43571: EMPTY
43572: LIST
43573: LIST
43574: PUSH
43575: LD_INT 30
43577: PUSH
43578: LD_INT 8
43580: PUSH
43581: EMPTY
43582: LIST
43583: LIST
43584: PUSH
43585: EMPTY
43586: LIST
43587: LIST
43588: LIST
43589: LIST
43590: PPUSH
43591: CALL_OW 72
43595: ST_TO_ADDR
43596: GO 43665
43598: LD_INT 5
43600: DOUBLE
43601: EQUAL
43602: IFTRUE 43618
43604: LD_INT 8
43606: DOUBLE
43607: EQUAL
43608: IFTRUE 43618
43610: LD_INT 9
43612: DOUBLE
43613: EQUAL
43614: IFTRUE 43618
43616: GO 43664
43618: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
43619: LD_ADDR_VAR 0 8
43623: PUSH
43624: LD_VAR 0 2
43628: PPUSH
43629: LD_INT 2
43631: PUSH
43632: LD_INT 30
43634: PUSH
43635: LD_INT 4
43637: PUSH
43638: EMPTY
43639: LIST
43640: LIST
43641: PUSH
43642: LD_INT 30
43644: PUSH
43645: LD_INT 5
43647: PUSH
43648: EMPTY
43649: LIST
43650: LIST
43651: PUSH
43652: EMPTY
43653: LIST
43654: LIST
43655: LIST
43656: PPUSH
43657: CALL_OW 72
43661: ST_TO_ADDR
43662: GO 43665
43664: POP
// if not tmp then
43665: LD_VAR 0 8
43669: NOT
43670: IFFALSE 43674
// exit ;
43672: GO 44176
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
43674: LD_VAR 0 4
43678: PUSH
43679: LD_INT 1
43681: PUSH
43682: LD_INT 15
43684: PUSH
43685: EMPTY
43686: LIST
43687: LIST
43688: IN
43689: PUSH
43690: LD_EXP 102
43694: PUSH
43695: LD_VAR 0 1
43699: ARRAY
43700: AND
43701: IFFALSE 43857
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
43703: LD_ADDR_VAR 0 9
43707: PUSH
43708: LD_EXP 102
43712: PUSH
43713: LD_VAR 0 1
43717: ARRAY
43718: PUSH
43719: LD_INT 1
43721: ARRAY
43722: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
43723: LD_VAR 0 9
43727: PUSH
43728: LD_EXP 103
43732: PUSH
43733: LD_VAR 0 1
43737: ARRAY
43738: IN
43739: NOT
43740: IFFALSE 43855
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
43742: LD_ADDR_EXP 103
43746: PUSH
43747: LD_EXP 103
43751: PPUSH
43752: LD_VAR 0 1
43756: PUSH
43757: LD_EXP 103
43761: PUSH
43762: LD_VAR 0 1
43766: ARRAY
43767: PUSH
43768: LD_INT 1
43770: PLUS
43771: PUSH
43772: EMPTY
43773: LIST
43774: LIST
43775: PPUSH
43776: LD_VAR 0 9
43780: PPUSH
43781: CALL 56198 0 3
43785: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
43786: LD_ADDR_EXP 102
43790: PUSH
43791: LD_EXP 102
43795: PPUSH
43796: LD_VAR 0 1
43800: PPUSH
43801: LD_EXP 102
43805: PUSH
43806: LD_VAR 0 1
43810: ARRAY
43811: PUSH
43812: LD_VAR 0 9
43816: DIFF
43817: PPUSH
43818: CALL_OW 1
43822: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
43823: LD_VAR 0 3
43827: PPUSH
43828: LD_EXP 103
43832: PUSH
43833: LD_VAR 0 1
43837: ARRAY
43838: PUSH
43839: LD_EXP 103
43843: PUSH
43844: LD_VAR 0 1
43848: ARRAY
43849: ARRAY
43850: PPUSH
43851: CALL_OW 120
// end ; exit ;
43855: GO 44176
// end ; if tmp > 1 then
43857: LD_VAR 0 8
43861: PUSH
43862: LD_INT 1
43864: GREATER
43865: IFFALSE 43969
// for i = 2 to tmp do
43867: LD_ADDR_VAR 0 6
43871: PUSH
43872: DOUBLE
43873: LD_INT 2
43875: DEC
43876: ST_TO_ADDR
43877: LD_VAR 0 8
43881: PUSH
43882: FOR_TO
43883: IFFALSE 43967
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
43885: LD_VAR 0 8
43889: PUSH
43890: LD_VAR 0 6
43894: ARRAY
43895: PPUSH
43896: CALL_OW 461
43900: PUSH
43901: LD_INT 6
43903: EQUAL
43904: IFFALSE 43965
// begin x := tmp [ i ] ;
43906: LD_ADDR_VAR 0 9
43910: PUSH
43911: LD_VAR 0 8
43915: PUSH
43916: LD_VAR 0 6
43920: ARRAY
43921: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
43922: LD_ADDR_VAR 0 8
43926: PUSH
43927: LD_VAR 0 8
43931: PPUSH
43932: LD_VAR 0 6
43936: PPUSH
43937: CALL_OW 3
43941: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
43942: LD_ADDR_VAR 0 8
43946: PUSH
43947: LD_VAR 0 8
43951: PPUSH
43952: LD_INT 1
43954: PPUSH
43955: LD_VAR 0 9
43959: PPUSH
43960: CALL_OW 2
43964: ST_TO_ADDR
// end ;
43965: GO 43882
43967: POP
43968: POP
// for i in tmp do
43969: LD_ADDR_VAR 0 6
43973: PUSH
43974: LD_VAR 0 8
43978: PUSH
43979: FOR_IN
43980: IFFALSE 44049
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
43982: LD_VAR 0 6
43986: PPUSH
43987: CALL_OW 313
43991: PUSH
43992: LD_INT 6
43994: LESS
43995: PUSH
43996: LD_VAR 0 6
44000: PPUSH
44001: CALL_OW 266
44005: PUSH
44006: LD_INT 31
44008: PUSH
44009: LD_INT 32
44011: PUSH
44012: EMPTY
44013: LIST
44014: LIST
44015: IN
44016: NOT
44017: AND
44018: PUSH
44019: LD_VAR 0 6
44023: PPUSH
44024: CALL_OW 313
44028: PUSH
44029: LD_INT 0
44031: EQUAL
44032: OR
44033: IFFALSE 44047
// begin j := i ;
44035: LD_ADDR_VAR 0 7
44039: PUSH
44040: LD_VAR 0 6
44044: ST_TO_ADDR
// break ;
44045: GO 44049
// end ; end ;
44047: GO 43979
44049: POP
44050: POP
// if j then
44051: LD_VAR 0 7
44055: IFFALSE 44073
// ComEnterUnit ( unit , j ) else
44057: LD_VAR 0 3
44061: PPUSH
44062: LD_VAR 0 7
44066: PPUSH
44067: CALL_OW 120
44071: GO 44176
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44073: LD_ADDR_VAR 0 10
44077: PUSH
44078: LD_VAR 0 2
44082: PPUSH
44083: LD_INT 2
44085: PUSH
44086: LD_INT 30
44088: PUSH
44089: LD_INT 0
44091: PUSH
44092: EMPTY
44093: LIST
44094: LIST
44095: PUSH
44096: LD_INT 30
44098: PUSH
44099: LD_INT 1
44101: PUSH
44102: EMPTY
44103: LIST
44104: LIST
44105: PUSH
44106: EMPTY
44107: LIST
44108: LIST
44109: LIST
44110: PPUSH
44111: CALL_OW 72
44115: ST_TO_ADDR
// if depot then
44116: LD_VAR 0 10
44120: IFFALSE 44176
// begin depot := NearestUnitToUnit ( depot , unit ) ;
44122: LD_ADDR_VAR 0 10
44126: PUSH
44127: LD_VAR 0 10
44131: PPUSH
44132: LD_VAR 0 3
44136: PPUSH
44137: CALL_OW 74
44141: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
44142: LD_VAR 0 3
44146: PPUSH
44147: LD_VAR 0 10
44151: PPUSH
44152: CALL_OW 296
44156: PUSH
44157: LD_INT 10
44159: GREATER
44160: IFFALSE 44176
// ComStandNearbyBuilding ( unit , depot ) ;
44162: LD_VAR 0 3
44166: PPUSH
44167: LD_VAR 0 10
44171: PPUSH
44172: CALL 52776 0 2
// end ; end ; end ;
44176: LD_VAR 0 5
44180: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
44181: LD_INT 0
44183: PPUSH
44184: PPUSH
44185: PPUSH
44186: PPUSH
// if not mc_bases then
44187: LD_EXP 93
44191: NOT
44192: IFFALSE 44196
// exit ;
44194: GO 44435
// for i = 1 to mc_bases do
44196: LD_ADDR_VAR 0 2
44200: PUSH
44201: DOUBLE
44202: LD_INT 1
44204: DEC
44205: ST_TO_ADDR
44206: LD_EXP 93
44210: PUSH
44211: FOR_TO
44212: IFFALSE 44433
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
44214: LD_ADDR_VAR 0 4
44218: PUSH
44219: LD_EXP 93
44223: PUSH
44224: LD_VAR 0 2
44228: ARRAY
44229: PPUSH
44230: LD_INT 21
44232: PUSH
44233: LD_INT 1
44235: PUSH
44236: EMPTY
44237: LIST
44238: LIST
44239: PPUSH
44240: CALL_OW 72
44244: PUSH
44245: LD_EXP 122
44249: PUSH
44250: LD_VAR 0 2
44254: ARRAY
44255: UNION
44256: ST_TO_ADDR
// if not tmp then
44257: LD_VAR 0 4
44261: NOT
44262: IFFALSE 44266
// continue ;
44264: GO 44211
// for j in tmp do
44266: LD_ADDR_VAR 0 3
44270: PUSH
44271: LD_VAR 0 4
44275: PUSH
44276: FOR_IN
44277: IFFALSE 44429
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
44279: LD_VAR 0 3
44283: PPUSH
44284: CALL_OW 110
44288: NOT
44289: PUSH
44290: LD_VAR 0 3
44294: PPUSH
44295: CALL_OW 314
44299: NOT
44300: AND
44301: PUSH
44302: LD_VAR 0 3
44306: PPUSH
44307: CALL_OW 311
44311: NOT
44312: AND
44313: PUSH
44314: LD_VAR 0 3
44318: PPUSH
44319: CALL_OW 310
44323: NOT
44324: AND
44325: PUSH
44326: LD_VAR 0 3
44330: PUSH
44331: LD_EXP 96
44335: PUSH
44336: LD_VAR 0 2
44340: ARRAY
44341: PUSH
44342: LD_INT 1
44344: ARRAY
44345: IN
44346: NOT
44347: AND
44348: PUSH
44349: LD_VAR 0 3
44353: PUSH
44354: LD_EXP 96
44358: PUSH
44359: LD_VAR 0 2
44363: ARRAY
44364: PUSH
44365: LD_INT 2
44367: ARRAY
44368: IN
44369: NOT
44370: AND
44371: PUSH
44372: LD_VAR 0 3
44376: PUSH
44377: LD_EXP 105
44381: PUSH
44382: LD_VAR 0 2
44386: ARRAY
44387: IN
44388: NOT
44389: AND
44390: IFFALSE 44427
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
44392: LD_VAR 0 2
44396: PPUSH
44397: LD_EXP 93
44401: PUSH
44402: LD_VAR 0 2
44406: ARRAY
44407: PPUSH
44408: LD_VAR 0 3
44412: PPUSH
44413: LD_VAR 0 3
44417: PPUSH
44418: CALL_OW 257
44422: PPUSH
44423: CALL 43199 0 4
// end ;
44427: GO 44276
44429: POP
44430: POP
// end ;
44431: GO 44211
44433: POP
44434: POP
// end ;
44435: LD_VAR 0 1
44439: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
44440: LD_INT 0
44442: PPUSH
44443: PPUSH
44444: PPUSH
44445: PPUSH
44446: PPUSH
44447: PPUSH
// if not mc_bases [ base ] then
44448: LD_EXP 93
44452: PUSH
44453: LD_VAR 0 1
44457: ARRAY
44458: NOT
44459: IFFALSE 44463
// exit ;
44461: GO 44645
// tmp := [ ] ;
44463: LD_ADDR_VAR 0 6
44467: PUSH
44468: EMPTY
44469: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
44470: LD_ADDR_VAR 0 7
44474: PUSH
44475: LD_VAR 0 3
44479: PPUSH
44480: LD_INT 0
44482: PPUSH
44483: CALL_OW 517
44487: ST_TO_ADDR
// if not list then
44488: LD_VAR 0 7
44492: NOT
44493: IFFALSE 44497
// exit ;
44495: GO 44645
// for i = 1 to amount do
44497: LD_ADDR_VAR 0 5
44501: PUSH
44502: DOUBLE
44503: LD_INT 1
44505: DEC
44506: ST_TO_ADDR
44507: LD_VAR 0 2
44511: PUSH
44512: FOR_TO
44513: IFFALSE 44593
// begin x := rand ( 1 , list [ 1 ] ) ;
44515: LD_ADDR_VAR 0 8
44519: PUSH
44520: LD_INT 1
44522: PPUSH
44523: LD_VAR 0 7
44527: PUSH
44528: LD_INT 1
44530: ARRAY
44531: PPUSH
44532: CALL_OW 12
44536: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
44537: LD_ADDR_VAR 0 6
44541: PUSH
44542: LD_VAR 0 6
44546: PPUSH
44547: LD_VAR 0 5
44551: PPUSH
44552: LD_VAR 0 7
44556: PUSH
44557: LD_INT 1
44559: ARRAY
44560: PUSH
44561: LD_VAR 0 8
44565: ARRAY
44566: PUSH
44567: LD_VAR 0 7
44571: PUSH
44572: LD_INT 2
44574: ARRAY
44575: PUSH
44576: LD_VAR 0 8
44580: ARRAY
44581: PUSH
44582: EMPTY
44583: LIST
44584: LIST
44585: PPUSH
44586: CALL_OW 1
44590: ST_TO_ADDR
// end ;
44591: GO 44512
44593: POP
44594: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
44595: LD_ADDR_EXP 106
44599: PUSH
44600: LD_EXP 106
44604: PPUSH
44605: LD_VAR 0 1
44609: PPUSH
44610: LD_VAR 0 6
44614: PPUSH
44615: CALL_OW 1
44619: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
44620: LD_ADDR_EXP 108
44624: PUSH
44625: LD_EXP 108
44629: PPUSH
44630: LD_VAR 0 1
44634: PPUSH
44635: LD_VAR 0 3
44639: PPUSH
44640: CALL_OW 1
44644: ST_TO_ADDR
// end ;
44645: LD_VAR 0 4
44649: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
44650: LD_INT 0
44652: PPUSH
// if not mc_bases [ base ] then
44653: LD_EXP 93
44657: PUSH
44658: LD_VAR 0 1
44662: ARRAY
44663: NOT
44664: IFFALSE 44668
// exit ;
44666: GO 44693
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
44668: LD_ADDR_EXP 98
44672: PUSH
44673: LD_EXP 98
44677: PPUSH
44678: LD_VAR 0 1
44682: PPUSH
44683: LD_VAR 0 2
44687: PPUSH
44688: CALL_OW 1
44692: ST_TO_ADDR
// end ;
44693: LD_VAR 0 3
44697: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
44698: LD_INT 0
44700: PPUSH
// if not mc_bases [ base ] then
44701: LD_EXP 93
44705: PUSH
44706: LD_VAR 0 1
44710: ARRAY
44711: NOT
44712: IFFALSE 44716
// exit ;
44714: GO 44753
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
44716: LD_ADDR_EXP 98
44720: PUSH
44721: LD_EXP 98
44725: PPUSH
44726: LD_VAR 0 1
44730: PPUSH
44731: LD_EXP 98
44735: PUSH
44736: LD_VAR 0 1
44740: ARRAY
44741: PUSH
44742: LD_VAR 0 2
44746: UNION
44747: PPUSH
44748: CALL_OW 1
44752: ST_TO_ADDR
// end ;
44753: LD_VAR 0 3
44757: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
44758: LD_INT 0
44760: PPUSH
// if not mc_bases [ base ] then
44761: LD_EXP 93
44765: PUSH
44766: LD_VAR 0 1
44770: ARRAY
44771: NOT
44772: IFFALSE 44776
// exit ;
44774: GO 44801
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
44776: LD_ADDR_EXP 114
44780: PUSH
44781: LD_EXP 114
44785: PPUSH
44786: LD_VAR 0 1
44790: PPUSH
44791: LD_VAR 0 2
44795: PPUSH
44796: CALL_OW 1
44800: ST_TO_ADDR
// end ;
44801: LD_VAR 0 3
44805: RET
// export function MC_InsertProduceList ( base , components ) ; begin
44806: LD_INT 0
44808: PPUSH
// if not mc_bases [ base ] then
44809: LD_EXP 93
44813: PUSH
44814: LD_VAR 0 1
44818: ARRAY
44819: NOT
44820: IFFALSE 44824
// exit ;
44822: GO 44861
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
44824: LD_ADDR_EXP 114
44828: PUSH
44829: LD_EXP 114
44833: PPUSH
44834: LD_VAR 0 1
44838: PPUSH
44839: LD_EXP 114
44843: PUSH
44844: LD_VAR 0 1
44848: ARRAY
44849: PUSH
44850: LD_VAR 0 2
44854: ADD
44855: PPUSH
44856: CALL_OW 1
44860: ST_TO_ADDR
// end ;
44861: LD_VAR 0 3
44865: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
44866: LD_INT 0
44868: PPUSH
// if not mc_bases [ base ] then
44869: LD_EXP 93
44873: PUSH
44874: LD_VAR 0 1
44878: ARRAY
44879: NOT
44880: IFFALSE 44884
// exit ;
44882: GO 44938
// mc_defender := Replace ( mc_defender , base , deflist ) ;
44884: LD_ADDR_EXP 115
44888: PUSH
44889: LD_EXP 115
44893: PPUSH
44894: LD_VAR 0 1
44898: PPUSH
44899: LD_VAR 0 2
44903: PPUSH
44904: CALL_OW 1
44908: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
44909: LD_ADDR_EXP 104
44913: PUSH
44914: LD_EXP 104
44918: PPUSH
44919: LD_VAR 0 1
44923: PPUSH
44924: LD_VAR 0 2
44928: PUSH
44929: LD_INT 0
44931: PLUS
44932: PPUSH
44933: CALL_OW 1
44937: ST_TO_ADDR
// end ;
44938: LD_VAR 0 3
44942: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
44943: LD_INT 0
44945: PPUSH
// if not mc_bases [ base ] then
44946: LD_EXP 93
44950: PUSH
44951: LD_VAR 0 1
44955: ARRAY
44956: NOT
44957: IFFALSE 44961
// exit ;
44959: GO 44986
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
44961: LD_ADDR_EXP 104
44965: PUSH
44966: LD_EXP 104
44970: PPUSH
44971: LD_VAR 0 1
44975: PPUSH
44976: LD_VAR 0 2
44980: PPUSH
44981: CALL_OW 1
44985: ST_TO_ADDR
// end ;
44986: LD_VAR 0 3
44990: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
44991: LD_INT 0
44993: PPUSH
44994: PPUSH
44995: PPUSH
44996: PPUSH
// if not mc_bases [ base ] then
44997: LD_EXP 93
45001: PUSH
45002: LD_VAR 0 1
45006: ARRAY
45007: NOT
45008: IFFALSE 45012
// exit ;
45010: GO 45077
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
45012: LD_ADDR_EXP 113
45016: PUSH
45017: LD_EXP 113
45021: PPUSH
45022: LD_VAR 0 1
45026: PUSH
45027: LD_EXP 113
45031: PUSH
45032: LD_VAR 0 1
45036: ARRAY
45037: PUSH
45038: LD_INT 1
45040: PLUS
45041: PUSH
45042: EMPTY
45043: LIST
45044: LIST
45045: PPUSH
45046: LD_VAR 0 1
45050: PUSH
45051: LD_VAR 0 2
45055: PUSH
45056: LD_VAR 0 3
45060: PUSH
45061: LD_VAR 0 4
45065: PUSH
45066: EMPTY
45067: LIST
45068: LIST
45069: LIST
45070: LIST
45071: PPUSH
45072: CALL 56198 0 3
45076: ST_TO_ADDR
// end ;
45077: LD_VAR 0 5
45081: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
45082: LD_INT 0
45084: PPUSH
// if not mc_bases [ base ] then
45085: LD_EXP 93
45089: PUSH
45090: LD_VAR 0 1
45094: ARRAY
45095: NOT
45096: IFFALSE 45100
// exit ;
45098: GO 45125
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
45100: LD_ADDR_EXP 130
45104: PUSH
45105: LD_EXP 130
45109: PPUSH
45110: LD_VAR 0 1
45114: PPUSH
45115: LD_VAR 0 2
45119: PPUSH
45120: CALL_OW 1
45124: ST_TO_ADDR
// end ;
45125: LD_VAR 0 3
45129: RET
// export function MC_GetMinesField ( base ) ; begin
45130: LD_INT 0
45132: PPUSH
// result := mc_mines [ base ] ;
45133: LD_ADDR_VAR 0 2
45137: PUSH
45138: LD_EXP 106
45142: PUSH
45143: LD_VAR 0 1
45147: ARRAY
45148: ST_TO_ADDR
// end ;
45149: LD_VAR 0 2
45153: RET
// export function MC_GetProduceList ( base ) ; begin
45154: LD_INT 0
45156: PPUSH
// result := mc_produce [ base ] ;
45157: LD_ADDR_VAR 0 2
45161: PUSH
45162: LD_EXP 114
45166: PUSH
45167: LD_VAR 0 1
45171: ARRAY
45172: ST_TO_ADDR
// end ;
45173: LD_VAR 0 2
45177: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
45178: LD_INT 0
45180: PPUSH
45181: PPUSH
// if not mc_bases then
45182: LD_EXP 93
45186: NOT
45187: IFFALSE 45191
// exit ;
45189: GO 45256
// if mc_bases [ base ] then
45191: LD_EXP 93
45195: PUSH
45196: LD_VAR 0 1
45200: ARRAY
45201: IFFALSE 45256
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
45203: LD_ADDR_VAR 0 3
45207: PUSH
45208: LD_EXP 93
45212: PUSH
45213: LD_VAR 0 1
45217: ARRAY
45218: PPUSH
45219: LD_INT 30
45221: PUSH
45222: LD_VAR 0 2
45226: PUSH
45227: EMPTY
45228: LIST
45229: LIST
45230: PPUSH
45231: CALL_OW 72
45235: ST_TO_ADDR
// if result then
45236: LD_VAR 0 3
45240: IFFALSE 45256
// result := result [ 1 ] ;
45242: LD_ADDR_VAR 0 3
45246: PUSH
45247: LD_VAR 0 3
45251: PUSH
45252: LD_INT 1
45254: ARRAY
45255: ST_TO_ADDR
// end ; end ;
45256: LD_VAR 0 3
45260: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
45261: LD_INT 0
45263: PPUSH
45264: PPUSH
// if not mc_bases then
45265: LD_EXP 93
45269: NOT
45270: IFFALSE 45274
// exit ;
45272: GO 45319
// if mc_bases [ base ] then
45274: LD_EXP 93
45278: PUSH
45279: LD_VAR 0 1
45283: ARRAY
45284: IFFALSE 45319
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
45286: LD_ADDR_VAR 0 3
45290: PUSH
45291: LD_EXP 93
45295: PUSH
45296: LD_VAR 0 1
45300: ARRAY
45301: PPUSH
45302: LD_INT 30
45304: PUSH
45305: LD_VAR 0 2
45309: PUSH
45310: EMPTY
45311: LIST
45312: LIST
45313: PPUSH
45314: CALL_OW 72
45318: ST_TO_ADDR
// end ;
45319: LD_VAR 0 3
45323: RET
// export function MC_SetTame ( base , area ) ; begin
45324: LD_INT 0
45326: PPUSH
// if not mc_bases or not base then
45327: LD_EXP 93
45331: NOT
45332: PUSH
45333: LD_VAR 0 1
45337: NOT
45338: OR
45339: IFFALSE 45343
// exit ;
45341: GO 45368
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
45343: LD_ADDR_EXP 121
45347: PUSH
45348: LD_EXP 121
45352: PPUSH
45353: LD_VAR 0 1
45357: PPUSH
45358: LD_VAR 0 2
45362: PPUSH
45363: CALL_OW 1
45367: ST_TO_ADDR
// end ;
45368: LD_VAR 0 3
45372: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
45373: LD_INT 0
45375: PPUSH
45376: PPUSH
// if not mc_bases or not base then
45377: LD_EXP 93
45381: NOT
45382: PUSH
45383: LD_VAR 0 1
45387: NOT
45388: OR
45389: IFFALSE 45393
// exit ;
45391: GO 45495
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
45393: LD_ADDR_VAR 0 4
45397: PUSH
45398: LD_EXP 93
45402: PUSH
45403: LD_VAR 0 1
45407: ARRAY
45408: PPUSH
45409: LD_INT 30
45411: PUSH
45412: LD_VAR 0 2
45416: PUSH
45417: EMPTY
45418: LIST
45419: LIST
45420: PPUSH
45421: CALL_OW 72
45425: ST_TO_ADDR
// if not tmp then
45426: LD_VAR 0 4
45430: NOT
45431: IFFALSE 45435
// exit ;
45433: GO 45495
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
45435: LD_ADDR_EXP 125
45439: PUSH
45440: LD_EXP 125
45444: PPUSH
45445: LD_VAR 0 1
45449: PPUSH
45450: LD_EXP 125
45454: PUSH
45455: LD_VAR 0 1
45459: ARRAY
45460: PPUSH
45461: LD_EXP 125
45465: PUSH
45466: LD_VAR 0 1
45470: ARRAY
45471: PUSH
45472: LD_INT 1
45474: PLUS
45475: PPUSH
45476: LD_VAR 0 4
45480: PUSH
45481: LD_INT 1
45483: ARRAY
45484: PPUSH
45485: CALL_OW 2
45489: PPUSH
45490: CALL_OW 1
45494: ST_TO_ADDR
// end ;
45495: LD_VAR 0 3
45499: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
45500: LD_INT 0
45502: PPUSH
45503: PPUSH
// if not mc_bases or not base or not kinds then
45504: LD_EXP 93
45508: NOT
45509: PUSH
45510: LD_VAR 0 1
45514: NOT
45515: OR
45516: PUSH
45517: LD_VAR 0 2
45521: NOT
45522: OR
45523: IFFALSE 45527
// exit ;
45525: GO 45588
// for i in kinds do
45527: LD_ADDR_VAR 0 4
45531: PUSH
45532: LD_VAR 0 2
45536: PUSH
45537: FOR_IN
45538: IFFALSE 45586
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
45540: LD_ADDR_EXP 127
45544: PUSH
45545: LD_EXP 127
45549: PPUSH
45550: LD_VAR 0 1
45554: PUSH
45555: LD_EXP 127
45559: PUSH
45560: LD_VAR 0 1
45564: ARRAY
45565: PUSH
45566: LD_INT 1
45568: PLUS
45569: PUSH
45570: EMPTY
45571: LIST
45572: LIST
45573: PPUSH
45574: LD_VAR 0 4
45578: PPUSH
45579: CALL 56198 0 3
45583: ST_TO_ADDR
45584: GO 45537
45586: POP
45587: POP
// end ;
45588: LD_VAR 0 3
45592: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
45593: LD_INT 0
45595: PPUSH
// if not mc_bases or not base or not areas then
45596: LD_EXP 93
45600: NOT
45601: PUSH
45602: LD_VAR 0 1
45606: NOT
45607: OR
45608: PUSH
45609: LD_VAR 0 2
45613: NOT
45614: OR
45615: IFFALSE 45619
// exit ;
45617: GO 45644
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
45619: LD_ADDR_EXP 111
45623: PUSH
45624: LD_EXP 111
45628: PPUSH
45629: LD_VAR 0 1
45633: PPUSH
45634: LD_VAR 0 2
45638: PPUSH
45639: CALL_OW 1
45643: ST_TO_ADDR
// end ;
45644: LD_VAR 0 3
45648: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
45649: LD_INT 0
45651: PPUSH
// if not mc_bases or not base or not teleports_exit then
45652: LD_EXP 93
45656: NOT
45657: PUSH
45658: LD_VAR 0 1
45662: NOT
45663: OR
45664: PUSH
45665: LD_VAR 0 2
45669: NOT
45670: OR
45671: IFFALSE 45675
// exit ;
45673: GO 45700
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
45675: LD_ADDR_EXP 128
45679: PUSH
45680: LD_EXP 128
45684: PPUSH
45685: LD_VAR 0 1
45689: PPUSH
45690: LD_VAR 0 2
45694: PPUSH
45695: CALL_OW 1
45699: ST_TO_ADDR
// end ;
45700: LD_VAR 0 3
45704: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
45705: LD_INT 0
45707: PPUSH
45708: PPUSH
45709: PPUSH
// if not mc_bases or not base or not ext_list then
45710: LD_EXP 93
45714: NOT
45715: PUSH
45716: LD_VAR 0 1
45720: NOT
45721: OR
45722: PUSH
45723: LD_VAR 0 5
45727: NOT
45728: OR
45729: IFFALSE 45733
// exit ;
45731: GO 45906
// tmp := GetFacExtXYD ( x , y , d ) ;
45733: LD_ADDR_VAR 0 8
45737: PUSH
45738: LD_VAR 0 2
45742: PPUSH
45743: LD_VAR 0 3
45747: PPUSH
45748: LD_VAR 0 4
45752: PPUSH
45753: CALL 85586 0 3
45757: ST_TO_ADDR
// if not tmp then
45758: LD_VAR 0 8
45762: NOT
45763: IFFALSE 45767
// exit ;
45765: GO 45906
// for i in tmp do
45767: LD_ADDR_VAR 0 7
45771: PUSH
45772: LD_VAR 0 8
45776: PUSH
45777: FOR_IN
45778: IFFALSE 45904
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
45780: LD_ADDR_EXP 98
45784: PUSH
45785: LD_EXP 98
45789: PPUSH
45790: LD_VAR 0 1
45794: PPUSH
45795: LD_EXP 98
45799: PUSH
45800: LD_VAR 0 1
45804: ARRAY
45805: PPUSH
45806: LD_EXP 98
45810: PUSH
45811: LD_VAR 0 1
45815: ARRAY
45816: PUSH
45817: LD_INT 1
45819: PLUS
45820: PPUSH
45821: LD_VAR 0 5
45825: PUSH
45826: LD_INT 1
45828: ARRAY
45829: PUSH
45830: LD_VAR 0 7
45834: PUSH
45835: LD_INT 1
45837: ARRAY
45838: PUSH
45839: LD_VAR 0 7
45843: PUSH
45844: LD_INT 2
45846: ARRAY
45847: PUSH
45848: LD_VAR 0 7
45852: PUSH
45853: LD_INT 3
45855: ARRAY
45856: PUSH
45857: EMPTY
45858: LIST
45859: LIST
45860: LIST
45861: LIST
45862: PPUSH
45863: CALL_OW 2
45867: PPUSH
45868: CALL_OW 1
45872: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
45873: LD_ADDR_VAR 0 5
45877: PUSH
45878: LD_VAR 0 5
45882: PPUSH
45883: LD_INT 1
45885: PPUSH
45886: CALL_OW 3
45890: ST_TO_ADDR
// if not ext_list then
45891: LD_VAR 0 5
45895: NOT
45896: IFFALSE 45902
// exit ;
45898: POP
45899: POP
45900: GO 45906
// end ;
45902: GO 45777
45904: POP
45905: POP
// end ;
45906: LD_VAR 0 6
45910: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
45911: LD_INT 0
45913: PPUSH
// if not mc_bases or not base or not weapon_list then
45914: LD_EXP 93
45918: NOT
45919: PUSH
45920: LD_VAR 0 1
45924: NOT
45925: OR
45926: PUSH
45927: LD_VAR 0 2
45931: NOT
45932: OR
45933: IFFALSE 45937
// exit ;
45935: GO 45962
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
45937: LD_ADDR_EXP 132
45941: PUSH
45942: LD_EXP 132
45946: PPUSH
45947: LD_VAR 0 1
45951: PPUSH
45952: LD_VAR 0 2
45956: PPUSH
45957: CALL_OW 1
45961: ST_TO_ADDR
// end ;
45962: LD_VAR 0 3
45966: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
45967: LD_INT 0
45969: PPUSH
// if not mc_bases or not base or not tech_list then
45970: LD_EXP 93
45974: NOT
45975: PUSH
45976: LD_VAR 0 1
45980: NOT
45981: OR
45982: PUSH
45983: LD_VAR 0 2
45987: NOT
45988: OR
45989: IFFALSE 45993
// exit ;
45991: GO 46018
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
45993: LD_ADDR_EXP 120
45997: PUSH
45998: LD_EXP 120
46002: PPUSH
46003: LD_VAR 0 1
46007: PPUSH
46008: LD_VAR 0 2
46012: PPUSH
46013: CALL_OW 1
46017: ST_TO_ADDR
// end ;
46018: LD_VAR 0 3
46022: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
46023: LD_INT 0
46025: PPUSH
// if not mc_bases or not parking_area or not base then
46026: LD_EXP 93
46030: NOT
46031: PUSH
46032: LD_VAR 0 2
46036: NOT
46037: OR
46038: PUSH
46039: LD_VAR 0 1
46043: NOT
46044: OR
46045: IFFALSE 46049
// exit ;
46047: GO 46074
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
46049: LD_ADDR_EXP 117
46053: PUSH
46054: LD_EXP 117
46058: PPUSH
46059: LD_VAR 0 1
46063: PPUSH
46064: LD_VAR 0 2
46068: PPUSH
46069: CALL_OW 1
46073: ST_TO_ADDR
// end ;
46074: LD_VAR 0 3
46078: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
46079: LD_INT 0
46081: PPUSH
// if not mc_bases or not base or not scan_area then
46082: LD_EXP 93
46086: NOT
46087: PUSH
46088: LD_VAR 0 1
46092: NOT
46093: OR
46094: PUSH
46095: LD_VAR 0 2
46099: NOT
46100: OR
46101: IFFALSE 46105
// exit ;
46103: GO 46130
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
46105: LD_ADDR_EXP 118
46109: PUSH
46110: LD_EXP 118
46114: PPUSH
46115: LD_VAR 0 1
46119: PPUSH
46120: LD_VAR 0 2
46124: PPUSH
46125: CALL_OW 1
46129: ST_TO_ADDR
// end ;
46130: LD_VAR 0 3
46134: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
46135: LD_INT 0
46137: PPUSH
46138: PPUSH
// if not mc_bases or not base then
46139: LD_EXP 93
46143: NOT
46144: PUSH
46145: LD_VAR 0 1
46149: NOT
46150: OR
46151: IFFALSE 46155
// exit ;
46153: GO 46219
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
46155: LD_ADDR_VAR 0 3
46159: PUSH
46160: LD_INT 1
46162: PUSH
46163: LD_INT 2
46165: PUSH
46166: LD_INT 3
46168: PUSH
46169: LD_INT 4
46171: PUSH
46172: LD_INT 11
46174: PUSH
46175: EMPTY
46176: LIST
46177: LIST
46178: LIST
46179: LIST
46180: LIST
46181: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
46182: LD_ADDR_EXP 120
46186: PUSH
46187: LD_EXP 120
46191: PPUSH
46192: LD_VAR 0 1
46196: PPUSH
46197: LD_EXP 120
46201: PUSH
46202: LD_VAR 0 1
46206: ARRAY
46207: PUSH
46208: LD_VAR 0 3
46212: DIFF
46213: PPUSH
46214: CALL_OW 1
46218: ST_TO_ADDR
// end ;
46219: LD_VAR 0 2
46223: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
46224: LD_INT 0
46226: PPUSH
// result := mc_vehicles [ base ] ;
46227: LD_ADDR_VAR 0 3
46231: PUSH
46232: LD_EXP 112
46236: PUSH
46237: LD_VAR 0 1
46241: ARRAY
46242: ST_TO_ADDR
// if onlyCombat then
46243: LD_VAR 0 2
46247: IFFALSE 46425
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
46249: LD_ADDR_VAR 0 3
46253: PUSH
46254: LD_VAR 0 3
46258: PUSH
46259: LD_VAR 0 3
46263: PPUSH
46264: LD_INT 2
46266: PUSH
46267: LD_INT 34
46269: PUSH
46270: LD_INT 12
46272: PUSH
46273: EMPTY
46274: LIST
46275: LIST
46276: PUSH
46277: LD_INT 34
46279: PUSH
46280: LD_INT 51
46282: PUSH
46283: EMPTY
46284: LIST
46285: LIST
46286: PUSH
46287: LD_INT 34
46289: PUSH
46290: LD_EXP 73
46294: PUSH
46295: EMPTY
46296: LIST
46297: LIST
46298: PUSH
46299: LD_INT 34
46301: PUSH
46302: LD_INT 32
46304: PUSH
46305: EMPTY
46306: LIST
46307: LIST
46308: PUSH
46309: LD_INT 34
46311: PUSH
46312: LD_INT 13
46314: PUSH
46315: EMPTY
46316: LIST
46317: LIST
46318: PUSH
46319: LD_INT 34
46321: PUSH
46322: LD_INT 52
46324: PUSH
46325: EMPTY
46326: LIST
46327: LIST
46328: PUSH
46329: LD_INT 34
46331: PUSH
46332: LD_EXP 78
46336: PUSH
46337: EMPTY
46338: LIST
46339: LIST
46340: PUSH
46341: LD_INT 34
46343: PUSH
46344: LD_INT 14
46346: PUSH
46347: EMPTY
46348: LIST
46349: LIST
46350: PUSH
46351: LD_INT 34
46353: PUSH
46354: LD_INT 53
46356: PUSH
46357: EMPTY
46358: LIST
46359: LIST
46360: PUSH
46361: LD_INT 34
46363: PUSH
46364: LD_EXP 72
46368: PUSH
46369: EMPTY
46370: LIST
46371: LIST
46372: PUSH
46373: LD_INT 34
46375: PUSH
46376: LD_INT 31
46378: PUSH
46379: EMPTY
46380: LIST
46381: LIST
46382: PUSH
46383: LD_INT 34
46385: PUSH
46386: LD_INT 48
46388: PUSH
46389: EMPTY
46390: LIST
46391: LIST
46392: PUSH
46393: LD_INT 34
46395: PUSH
46396: LD_INT 8
46398: PUSH
46399: EMPTY
46400: LIST
46401: LIST
46402: PUSH
46403: EMPTY
46404: LIST
46405: LIST
46406: LIST
46407: LIST
46408: LIST
46409: LIST
46410: LIST
46411: LIST
46412: LIST
46413: LIST
46414: LIST
46415: LIST
46416: LIST
46417: LIST
46418: PPUSH
46419: CALL_OW 72
46423: DIFF
46424: ST_TO_ADDR
// end ; end_of_file
46425: LD_VAR 0 3
46429: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
46430: LD_INT 0
46432: PPUSH
46433: PPUSH
46434: PPUSH
// if not mc_bases or not skirmish then
46435: LD_EXP 93
46439: NOT
46440: PUSH
46441: LD_EXP 91
46445: NOT
46446: OR
46447: IFFALSE 46451
// exit ;
46449: GO 46616
// for i = 1 to mc_bases do
46451: LD_ADDR_VAR 0 4
46455: PUSH
46456: DOUBLE
46457: LD_INT 1
46459: DEC
46460: ST_TO_ADDR
46461: LD_EXP 93
46465: PUSH
46466: FOR_TO
46467: IFFALSE 46614
// begin if sci in mc_bases [ i ] then
46469: LD_VAR 0 2
46473: PUSH
46474: LD_EXP 93
46478: PUSH
46479: LD_VAR 0 4
46483: ARRAY
46484: IN
46485: IFFALSE 46612
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
46487: LD_ADDR_EXP 122
46491: PUSH
46492: LD_EXP 122
46496: PPUSH
46497: LD_VAR 0 4
46501: PUSH
46502: LD_EXP 122
46506: PUSH
46507: LD_VAR 0 4
46511: ARRAY
46512: PUSH
46513: LD_INT 1
46515: PLUS
46516: PUSH
46517: EMPTY
46518: LIST
46519: LIST
46520: PPUSH
46521: LD_VAR 0 1
46525: PPUSH
46526: CALL 56198 0 3
46530: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
46531: LD_ADDR_VAR 0 5
46535: PUSH
46536: LD_EXP 93
46540: PUSH
46541: LD_VAR 0 4
46545: ARRAY
46546: PPUSH
46547: LD_INT 2
46549: PUSH
46550: LD_INT 30
46552: PUSH
46553: LD_INT 0
46555: PUSH
46556: EMPTY
46557: LIST
46558: LIST
46559: PUSH
46560: LD_INT 30
46562: PUSH
46563: LD_INT 1
46565: PUSH
46566: EMPTY
46567: LIST
46568: LIST
46569: PUSH
46570: EMPTY
46571: LIST
46572: LIST
46573: LIST
46574: PPUSH
46575: CALL_OW 72
46579: PPUSH
46580: LD_VAR 0 1
46584: PPUSH
46585: CALL_OW 74
46589: ST_TO_ADDR
// if tmp then
46590: LD_VAR 0 5
46594: IFFALSE 46610
// ComStandNearbyBuilding ( ape , tmp ) ;
46596: LD_VAR 0 1
46600: PPUSH
46601: LD_VAR 0 5
46605: PPUSH
46606: CALL 52776 0 2
// break ;
46610: GO 46614
// end ; end ;
46612: GO 46466
46614: POP
46615: POP
// end ;
46616: LD_VAR 0 3
46620: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
46621: LD_INT 0
46623: PPUSH
46624: PPUSH
46625: PPUSH
// if not mc_bases or not skirmish then
46626: LD_EXP 93
46630: NOT
46631: PUSH
46632: LD_EXP 91
46636: NOT
46637: OR
46638: IFFALSE 46642
// exit ;
46640: GO 46731
// for i = 1 to mc_bases do
46642: LD_ADDR_VAR 0 4
46646: PUSH
46647: DOUBLE
46648: LD_INT 1
46650: DEC
46651: ST_TO_ADDR
46652: LD_EXP 93
46656: PUSH
46657: FOR_TO
46658: IFFALSE 46729
// begin if building in mc_busy_turret_list [ i ] then
46660: LD_VAR 0 1
46664: PUSH
46665: LD_EXP 103
46669: PUSH
46670: LD_VAR 0 4
46674: ARRAY
46675: IN
46676: IFFALSE 46727
// begin tmp := mc_busy_turret_list [ i ] diff building ;
46678: LD_ADDR_VAR 0 5
46682: PUSH
46683: LD_EXP 103
46687: PUSH
46688: LD_VAR 0 4
46692: ARRAY
46693: PUSH
46694: LD_VAR 0 1
46698: DIFF
46699: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
46700: LD_ADDR_EXP 103
46704: PUSH
46705: LD_EXP 103
46709: PPUSH
46710: LD_VAR 0 4
46714: PPUSH
46715: LD_VAR 0 5
46719: PPUSH
46720: CALL_OW 1
46724: ST_TO_ADDR
// break ;
46725: GO 46729
// end ; end ;
46727: GO 46657
46729: POP
46730: POP
// end ;
46731: LD_VAR 0 3
46735: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
46736: LD_INT 0
46738: PPUSH
46739: PPUSH
46740: PPUSH
// if not mc_bases or not skirmish then
46741: LD_EXP 93
46745: NOT
46746: PUSH
46747: LD_EXP 91
46751: NOT
46752: OR
46753: IFFALSE 46757
// exit ;
46755: GO 46956
// for i = 1 to mc_bases do
46757: LD_ADDR_VAR 0 5
46761: PUSH
46762: DOUBLE
46763: LD_INT 1
46765: DEC
46766: ST_TO_ADDR
46767: LD_EXP 93
46771: PUSH
46772: FOR_TO
46773: IFFALSE 46954
// if building in mc_bases [ i ] then
46775: LD_VAR 0 1
46779: PUSH
46780: LD_EXP 93
46784: PUSH
46785: LD_VAR 0 5
46789: ARRAY
46790: IN
46791: IFFALSE 46952
// begin tmp := mc_bases [ i ] diff building ;
46793: LD_ADDR_VAR 0 6
46797: PUSH
46798: LD_EXP 93
46802: PUSH
46803: LD_VAR 0 5
46807: ARRAY
46808: PUSH
46809: LD_VAR 0 1
46813: DIFF
46814: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
46815: LD_ADDR_EXP 93
46819: PUSH
46820: LD_EXP 93
46824: PPUSH
46825: LD_VAR 0 5
46829: PPUSH
46830: LD_VAR 0 6
46834: PPUSH
46835: CALL_OW 1
46839: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
46840: LD_VAR 0 1
46844: PUSH
46845: LD_EXP 101
46849: PUSH
46850: LD_VAR 0 5
46854: ARRAY
46855: IN
46856: IFFALSE 46895
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
46858: LD_ADDR_EXP 101
46862: PUSH
46863: LD_EXP 101
46867: PPUSH
46868: LD_VAR 0 5
46872: PPUSH
46873: LD_EXP 101
46877: PUSH
46878: LD_VAR 0 5
46882: ARRAY
46883: PUSH
46884: LD_VAR 0 1
46888: DIFF
46889: PPUSH
46890: CALL_OW 1
46894: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
46895: LD_VAR 0 1
46899: PUSH
46900: LD_EXP 102
46904: PUSH
46905: LD_VAR 0 5
46909: ARRAY
46910: IN
46911: IFFALSE 46950
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
46913: LD_ADDR_EXP 102
46917: PUSH
46918: LD_EXP 102
46922: PPUSH
46923: LD_VAR 0 5
46927: PPUSH
46928: LD_EXP 102
46932: PUSH
46933: LD_VAR 0 5
46937: ARRAY
46938: PUSH
46939: LD_VAR 0 1
46943: DIFF
46944: PPUSH
46945: CALL_OW 1
46949: ST_TO_ADDR
// break ;
46950: GO 46954
// end ;
46952: GO 46772
46954: POP
46955: POP
// end ;
46956: LD_VAR 0 4
46960: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
46961: LD_INT 0
46963: PPUSH
46964: PPUSH
46965: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
46966: LD_EXP 93
46970: NOT
46971: PUSH
46972: LD_EXP 91
46976: NOT
46977: OR
46978: PUSH
46979: LD_VAR 0 3
46983: PUSH
46984: LD_EXP 119
46988: IN
46989: NOT
46990: OR
46991: IFFALSE 46995
// exit ;
46993: GO 47118
// for i = 1 to mc_vehicles do
46995: LD_ADDR_VAR 0 6
46999: PUSH
47000: DOUBLE
47001: LD_INT 1
47003: DEC
47004: ST_TO_ADDR
47005: LD_EXP 112
47009: PUSH
47010: FOR_TO
47011: IFFALSE 47116
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
47013: LD_VAR 0 2
47017: PUSH
47018: LD_EXP 112
47022: PUSH
47023: LD_VAR 0 6
47027: ARRAY
47028: IN
47029: PUSH
47030: LD_VAR 0 1
47034: PUSH
47035: LD_EXP 112
47039: PUSH
47040: LD_VAR 0 6
47044: ARRAY
47045: IN
47046: OR
47047: IFFALSE 47114
// begin tmp := mc_vehicles [ i ] diff old ;
47049: LD_ADDR_VAR 0 7
47053: PUSH
47054: LD_EXP 112
47058: PUSH
47059: LD_VAR 0 6
47063: ARRAY
47064: PUSH
47065: LD_VAR 0 2
47069: DIFF
47070: ST_TO_ADDR
// tmp := tmp diff new ;
47071: LD_ADDR_VAR 0 7
47075: PUSH
47076: LD_VAR 0 7
47080: PUSH
47081: LD_VAR 0 1
47085: DIFF
47086: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
47087: LD_ADDR_EXP 112
47091: PUSH
47092: LD_EXP 112
47096: PPUSH
47097: LD_VAR 0 6
47101: PPUSH
47102: LD_VAR 0 7
47106: PPUSH
47107: CALL_OW 1
47111: ST_TO_ADDR
// break ;
47112: GO 47116
// end ;
47114: GO 47010
47116: POP
47117: POP
// end ;
47118: LD_VAR 0 5
47122: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
47123: LD_INT 0
47125: PPUSH
47126: PPUSH
47127: PPUSH
47128: PPUSH
// if not mc_bases or not skirmish then
47129: LD_EXP 93
47133: NOT
47134: PUSH
47135: LD_EXP 91
47139: NOT
47140: OR
47141: IFFALSE 47145
// exit ;
47143: GO 47537
// side := GetSide ( vehicle ) ;
47145: LD_ADDR_VAR 0 5
47149: PUSH
47150: LD_VAR 0 1
47154: PPUSH
47155: CALL_OW 255
47159: ST_TO_ADDR
// for i = 1 to mc_bases do
47160: LD_ADDR_VAR 0 4
47164: PUSH
47165: DOUBLE
47166: LD_INT 1
47168: DEC
47169: ST_TO_ADDR
47170: LD_EXP 93
47174: PUSH
47175: FOR_TO
47176: IFFALSE 47535
// begin if factory in mc_bases [ i ] then
47178: LD_VAR 0 2
47182: PUSH
47183: LD_EXP 93
47187: PUSH
47188: LD_VAR 0 4
47192: ARRAY
47193: IN
47194: IFFALSE 47533
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
47196: LD_EXP 115
47200: PUSH
47201: LD_VAR 0 4
47205: ARRAY
47206: PUSH
47207: LD_EXP 104
47211: PUSH
47212: LD_VAR 0 4
47216: ARRAY
47217: LESS
47218: PUSH
47219: LD_VAR 0 1
47223: PPUSH
47224: CALL_OW 264
47228: PUSH
47229: LD_INT 31
47231: PUSH
47232: LD_INT 32
47234: PUSH
47235: LD_INT 51
47237: PUSH
47238: LD_EXP 73
47242: PUSH
47243: LD_INT 12
47245: PUSH
47246: LD_INT 30
47248: PUSH
47249: LD_EXP 72
47253: PUSH
47254: LD_INT 11
47256: PUSH
47257: LD_INT 53
47259: PUSH
47260: LD_INT 14
47262: PUSH
47263: LD_EXP 76
47267: PUSH
47268: LD_INT 29
47270: PUSH
47271: LD_EXP 74
47275: PUSH
47276: LD_INT 13
47278: PUSH
47279: LD_INT 52
47281: PUSH
47282: LD_EXP 78
47286: PUSH
47287: LD_INT 48
47289: PUSH
47290: LD_INT 8
47292: PUSH
47293: EMPTY
47294: LIST
47295: LIST
47296: LIST
47297: LIST
47298: LIST
47299: LIST
47300: LIST
47301: LIST
47302: LIST
47303: LIST
47304: LIST
47305: LIST
47306: LIST
47307: LIST
47308: LIST
47309: LIST
47310: LIST
47311: LIST
47312: IN
47313: NOT
47314: AND
47315: IFFALSE 47363
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
47317: LD_ADDR_EXP 115
47321: PUSH
47322: LD_EXP 115
47326: PPUSH
47327: LD_VAR 0 4
47331: PUSH
47332: LD_EXP 115
47336: PUSH
47337: LD_VAR 0 4
47341: ARRAY
47342: PUSH
47343: LD_INT 1
47345: PLUS
47346: PUSH
47347: EMPTY
47348: LIST
47349: LIST
47350: PPUSH
47351: LD_VAR 0 1
47355: PPUSH
47356: CALL 56198 0 3
47360: ST_TO_ADDR
47361: GO 47407
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
47363: LD_ADDR_EXP 112
47367: PUSH
47368: LD_EXP 112
47372: PPUSH
47373: LD_VAR 0 4
47377: PUSH
47378: LD_EXP 112
47382: PUSH
47383: LD_VAR 0 4
47387: ARRAY
47388: PUSH
47389: LD_INT 1
47391: PLUS
47392: PUSH
47393: EMPTY
47394: LIST
47395: LIST
47396: PPUSH
47397: LD_VAR 0 1
47401: PPUSH
47402: CALL 56198 0 3
47406: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
47407: LD_VAR 0 1
47411: PPUSH
47412: CALL_OW 263
47416: PUSH
47417: LD_INT 2
47419: EQUAL
47420: IFFALSE 47449
// begin repeat Connect ( vehicle ) ;
47422: LD_VAR 0 1
47426: PPUSH
47427: CALL 59169 0 1
// wait ( 0 0$1 ) ;
47431: LD_INT 35
47433: PPUSH
47434: CALL_OW 67
// until IsControledBy ( vehicle ) ;
47438: LD_VAR 0 1
47442: PPUSH
47443: CALL_OW 312
47447: IFFALSE 47422
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
47449: LD_VAR 0 1
47453: PPUSH
47454: LD_EXP 117
47458: PUSH
47459: LD_VAR 0 4
47463: ARRAY
47464: PPUSH
47465: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
47469: LD_VAR 0 1
47473: PPUSH
47474: CALL_OW 263
47478: PUSH
47479: LD_INT 1
47481: NONEQUAL
47482: IFFALSE 47486
// break ;
47484: GO 47535
// repeat wait ( 0 0$1 ) ;
47486: LD_INT 35
47488: PPUSH
47489: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
47493: LD_VAR 0 1
47497: PPUSH
47498: LD_EXP 117
47502: PUSH
47503: LD_VAR 0 4
47507: ARRAY
47508: PPUSH
47509: CALL_OW 308
47513: IFFALSE 47486
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
47515: LD_VAR 0 1
47519: PPUSH
47520: CALL_OW 311
47524: PPUSH
47525: CALL_OW 121
// exit ;
47529: POP
47530: POP
47531: GO 47537
// end ; end ;
47533: GO 47175
47535: POP
47536: POP
// end ;
47537: LD_VAR 0 3
47541: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
47542: LD_INT 0
47544: PPUSH
47545: PPUSH
47546: PPUSH
47547: PPUSH
// if not mc_bases or not skirmish then
47548: LD_EXP 93
47552: NOT
47553: PUSH
47554: LD_EXP 91
47558: NOT
47559: OR
47560: IFFALSE 47564
// exit ;
47562: GO 47917
// repeat wait ( 0 0$1 ) ;
47564: LD_INT 35
47566: PPUSH
47567: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
47571: LD_VAR 0 2
47575: PPUSH
47576: LD_VAR 0 3
47580: PPUSH
47581: CALL_OW 284
47585: IFFALSE 47564
// if GetResourceTypeXY ( x , y ) = mat_artefact then
47587: LD_VAR 0 2
47591: PPUSH
47592: LD_VAR 0 3
47596: PPUSH
47597: CALL_OW 283
47601: PUSH
47602: LD_INT 4
47604: EQUAL
47605: IFFALSE 47609
// exit ;
47607: GO 47917
// for i = 1 to mc_bases do
47609: LD_ADDR_VAR 0 7
47613: PUSH
47614: DOUBLE
47615: LD_INT 1
47617: DEC
47618: ST_TO_ADDR
47619: LD_EXP 93
47623: PUSH
47624: FOR_TO
47625: IFFALSE 47915
// begin if mc_crates_area [ i ] then
47627: LD_EXP 111
47631: PUSH
47632: LD_VAR 0 7
47636: ARRAY
47637: IFFALSE 47748
// for j in mc_crates_area [ i ] do
47639: LD_ADDR_VAR 0 8
47643: PUSH
47644: LD_EXP 111
47648: PUSH
47649: LD_VAR 0 7
47653: ARRAY
47654: PUSH
47655: FOR_IN
47656: IFFALSE 47746
// if InArea ( x , y , j ) then
47658: LD_VAR 0 2
47662: PPUSH
47663: LD_VAR 0 3
47667: PPUSH
47668: LD_VAR 0 8
47672: PPUSH
47673: CALL_OW 309
47677: IFFALSE 47744
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
47679: LD_ADDR_EXP 109
47683: PUSH
47684: LD_EXP 109
47688: PPUSH
47689: LD_VAR 0 7
47693: PUSH
47694: LD_EXP 109
47698: PUSH
47699: LD_VAR 0 7
47703: ARRAY
47704: PUSH
47705: LD_INT 1
47707: PLUS
47708: PUSH
47709: EMPTY
47710: LIST
47711: LIST
47712: PPUSH
47713: LD_VAR 0 4
47717: PUSH
47718: LD_VAR 0 2
47722: PUSH
47723: LD_VAR 0 3
47727: PUSH
47728: EMPTY
47729: LIST
47730: LIST
47731: LIST
47732: PPUSH
47733: CALL 56198 0 3
47737: ST_TO_ADDR
// exit ;
47738: POP
47739: POP
47740: POP
47741: POP
47742: GO 47917
// end ;
47744: GO 47655
47746: POP
47747: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47748: LD_ADDR_VAR 0 9
47752: PUSH
47753: LD_EXP 93
47757: PUSH
47758: LD_VAR 0 7
47762: ARRAY
47763: PPUSH
47764: LD_INT 2
47766: PUSH
47767: LD_INT 30
47769: PUSH
47770: LD_INT 0
47772: PUSH
47773: EMPTY
47774: LIST
47775: LIST
47776: PUSH
47777: LD_INT 30
47779: PUSH
47780: LD_INT 1
47782: PUSH
47783: EMPTY
47784: LIST
47785: LIST
47786: PUSH
47787: EMPTY
47788: LIST
47789: LIST
47790: LIST
47791: PPUSH
47792: CALL_OW 72
47796: ST_TO_ADDR
// if not depot then
47797: LD_VAR 0 9
47801: NOT
47802: IFFALSE 47806
// continue ;
47804: GO 47624
// for j in depot do
47806: LD_ADDR_VAR 0 8
47810: PUSH
47811: LD_VAR 0 9
47815: PUSH
47816: FOR_IN
47817: IFFALSE 47911
// if GetDistUnitXY ( j , x , y ) < 30 then
47819: LD_VAR 0 8
47823: PPUSH
47824: LD_VAR 0 2
47828: PPUSH
47829: LD_VAR 0 3
47833: PPUSH
47834: CALL_OW 297
47838: PUSH
47839: LD_INT 30
47841: LESS
47842: IFFALSE 47909
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
47844: LD_ADDR_EXP 109
47848: PUSH
47849: LD_EXP 109
47853: PPUSH
47854: LD_VAR 0 7
47858: PUSH
47859: LD_EXP 109
47863: PUSH
47864: LD_VAR 0 7
47868: ARRAY
47869: PUSH
47870: LD_INT 1
47872: PLUS
47873: PUSH
47874: EMPTY
47875: LIST
47876: LIST
47877: PPUSH
47878: LD_VAR 0 4
47882: PUSH
47883: LD_VAR 0 2
47887: PUSH
47888: LD_VAR 0 3
47892: PUSH
47893: EMPTY
47894: LIST
47895: LIST
47896: LIST
47897: PPUSH
47898: CALL 56198 0 3
47902: ST_TO_ADDR
// exit ;
47903: POP
47904: POP
47905: POP
47906: POP
47907: GO 47917
// end ;
47909: GO 47816
47911: POP
47912: POP
// end ;
47913: GO 47624
47915: POP
47916: POP
// end ;
47917: LD_VAR 0 6
47921: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
47922: LD_INT 0
47924: PPUSH
47925: PPUSH
47926: PPUSH
47927: PPUSH
// if not mc_bases or not skirmish then
47928: LD_EXP 93
47932: NOT
47933: PUSH
47934: LD_EXP 91
47938: NOT
47939: OR
47940: IFFALSE 47944
// exit ;
47942: GO 48221
// side := GetSide ( lab ) ;
47944: LD_ADDR_VAR 0 4
47948: PUSH
47949: LD_VAR 0 2
47953: PPUSH
47954: CALL_OW 255
47958: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
47959: LD_VAR 0 4
47963: PUSH
47964: LD_EXP 119
47968: IN
47969: NOT
47970: PUSH
47971: LD_EXP 120
47975: NOT
47976: OR
47977: PUSH
47978: LD_EXP 93
47982: NOT
47983: OR
47984: IFFALSE 47988
// exit ;
47986: GO 48221
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
47988: LD_ADDR_EXP 120
47992: PUSH
47993: LD_EXP 120
47997: PPUSH
47998: LD_VAR 0 4
48002: PPUSH
48003: LD_EXP 120
48007: PUSH
48008: LD_VAR 0 4
48012: ARRAY
48013: PUSH
48014: LD_VAR 0 1
48018: DIFF
48019: PPUSH
48020: CALL_OW 1
48024: ST_TO_ADDR
// for i = 1 to mc_bases do
48025: LD_ADDR_VAR 0 5
48029: PUSH
48030: DOUBLE
48031: LD_INT 1
48033: DEC
48034: ST_TO_ADDR
48035: LD_EXP 93
48039: PUSH
48040: FOR_TO
48041: IFFALSE 48219
// begin if lab in mc_bases [ i ] then
48043: LD_VAR 0 2
48047: PUSH
48048: LD_EXP 93
48052: PUSH
48053: LD_VAR 0 5
48057: ARRAY
48058: IN
48059: IFFALSE 48217
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
48061: LD_VAR 0 1
48065: PUSH
48066: LD_INT 11
48068: PUSH
48069: LD_INT 4
48071: PUSH
48072: LD_INT 3
48074: PUSH
48075: LD_INT 2
48077: PUSH
48078: EMPTY
48079: LIST
48080: LIST
48081: LIST
48082: LIST
48083: IN
48084: PUSH
48085: LD_EXP 123
48089: PUSH
48090: LD_VAR 0 5
48094: ARRAY
48095: AND
48096: IFFALSE 48217
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
48098: LD_ADDR_VAR 0 6
48102: PUSH
48103: LD_EXP 123
48107: PUSH
48108: LD_VAR 0 5
48112: ARRAY
48113: PUSH
48114: LD_INT 1
48116: ARRAY
48117: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
48118: LD_ADDR_EXP 123
48122: PUSH
48123: LD_EXP 123
48127: PPUSH
48128: LD_VAR 0 5
48132: PPUSH
48133: EMPTY
48134: PPUSH
48135: CALL_OW 1
48139: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
48140: LD_VAR 0 6
48144: PPUSH
48145: LD_INT 0
48147: PPUSH
48148: CALL_OW 109
// ComExitBuilding ( tmp ) ;
48152: LD_VAR 0 6
48156: PPUSH
48157: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
48161: LD_ADDR_EXP 122
48165: PUSH
48166: LD_EXP 122
48170: PPUSH
48171: LD_VAR 0 5
48175: PPUSH
48176: LD_EXP 122
48180: PUSH
48181: LD_VAR 0 5
48185: ARRAY
48186: PPUSH
48187: LD_INT 1
48189: PPUSH
48190: LD_VAR 0 6
48194: PPUSH
48195: CALL_OW 2
48199: PPUSH
48200: CALL_OW 1
48204: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
48205: LD_VAR 0 5
48209: PPUSH
48210: LD_INT 112
48212: PPUSH
48213: CALL 24956 0 2
// end ; end ; end ;
48217: GO 48040
48219: POP
48220: POP
// end ;
48221: LD_VAR 0 3
48225: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
48226: LD_INT 0
48228: PPUSH
48229: PPUSH
48230: PPUSH
48231: PPUSH
48232: PPUSH
48233: PPUSH
48234: PPUSH
48235: PPUSH
// if not mc_bases or not skirmish then
48236: LD_EXP 93
48240: NOT
48241: PUSH
48242: LD_EXP 91
48246: NOT
48247: OR
48248: IFFALSE 48252
// exit ;
48250: GO 49623
// for i = 1 to mc_bases do
48252: LD_ADDR_VAR 0 3
48256: PUSH
48257: DOUBLE
48258: LD_INT 1
48260: DEC
48261: ST_TO_ADDR
48262: LD_EXP 93
48266: PUSH
48267: FOR_TO
48268: IFFALSE 49621
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
48270: LD_VAR 0 1
48274: PUSH
48275: LD_EXP 93
48279: PUSH
48280: LD_VAR 0 3
48284: ARRAY
48285: IN
48286: PUSH
48287: LD_VAR 0 1
48291: PUSH
48292: LD_EXP 100
48296: PUSH
48297: LD_VAR 0 3
48301: ARRAY
48302: IN
48303: OR
48304: PUSH
48305: LD_VAR 0 1
48309: PUSH
48310: LD_EXP 115
48314: PUSH
48315: LD_VAR 0 3
48319: ARRAY
48320: IN
48321: OR
48322: PUSH
48323: LD_VAR 0 1
48327: PUSH
48328: LD_EXP 112
48332: PUSH
48333: LD_VAR 0 3
48337: ARRAY
48338: IN
48339: OR
48340: PUSH
48341: LD_VAR 0 1
48345: PUSH
48346: LD_EXP 122
48350: PUSH
48351: LD_VAR 0 3
48355: ARRAY
48356: IN
48357: OR
48358: PUSH
48359: LD_VAR 0 1
48363: PUSH
48364: LD_EXP 123
48368: PUSH
48369: LD_VAR 0 3
48373: ARRAY
48374: IN
48375: OR
48376: IFFALSE 49619
// begin if un in mc_ape [ i ] then
48378: LD_VAR 0 1
48382: PUSH
48383: LD_EXP 122
48387: PUSH
48388: LD_VAR 0 3
48392: ARRAY
48393: IN
48394: IFFALSE 48433
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
48396: LD_ADDR_EXP 122
48400: PUSH
48401: LD_EXP 122
48405: PPUSH
48406: LD_VAR 0 3
48410: PPUSH
48411: LD_EXP 122
48415: PUSH
48416: LD_VAR 0 3
48420: ARRAY
48421: PUSH
48422: LD_VAR 0 1
48426: DIFF
48427: PPUSH
48428: CALL_OW 1
48432: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
48433: LD_VAR 0 1
48437: PUSH
48438: LD_EXP 123
48442: PUSH
48443: LD_VAR 0 3
48447: ARRAY
48448: IN
48449: IFFALSE 48473
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
48451: LD_ADDR_EXP 123
48455: PUSH
48456: LD_EXP 123
48460: PPUSH
48461: LD_VAR 0 3
48465: PPUSH
48466: EMPTY
48467: PPUSH
48468: CALL_OW 1
48472: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
48473: LD_VAR 0 1
48477: PPUSH
48478: CALL_OW 247
48482: PUSH
48483: LD_INT 2
48485: EQUAL
48486: PUSH
48487: LD_VAR 0 1
48491: PPUSH
48492: CALL_OW 110
48496: PUSH
48497: LD_INT 20
48499: EQUAL
48500: PUSH
48501: LD_VAR 0 1
48505: PUSH
48506: LD_EXP 115
48510: PUSH
48511: LD_VAR 0 3
48515: ARRAY
48516: IN
48517: OR
48518: PUSH
48519: LD_VAR 0 1
48523: PPUSH
48524: CALL_OW 264
48528: PUSH
48529: LD_INT 12
48531: PUSH
48532: LD_INT 51
48534: PUSH
48535: LD_EXP 73
48539: PUSH
48540: LD_INT 32
48542: PUSH
48543: LD_INT 13
48545: PUSH
48546: LD_INT 52
48548: PUSH
48549: LD_INT 31
48551: PUSH
48552: EMPTY
48553: LIST
48554: LIST
48555: LIST
48556: LIST
48557: LIST
48558: LIST
48559: LIST
48560: IN
48561: OR
48562: AND
48563: IFFALSE 48871
// begin if un in mc_defender [ i ] then
48565: LD_VAR 0 1
48569: PUSH
48570: LD_EXP 115
48574: PUSH
48575: LD_VAR 0 3
48579: ARRAY
48580: IN
48581: IFFALSE 48620
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
48583: LD_ADDR_EXP 115
48587: PUSH
48588: LD_EXP 115
48592: PPUSH
48593: LD_VAR 0 3
48597: PPUSH
48598: LD_EXP 115
48602: PUSH
48603: LD_VAR 0 3
48607: ARRAY
48608: PUSH
48609: LD_VAR 0 1
48613: DIFF
48614: PPUSH
48615: CALL_OW 1
48619: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
48620: LD_ADDR_VAR 0 8
48624: PUSH
48625: LD_VAR 0 3
48629: PPUSH
48630: LD_INT 3
48632: PPUSH
48633: CALL 45261 0 2
48637: ST_TO_ADDR
// if fac then
48638: LD_VAR 0 8
48642: IFFALSE 48871
// begin for j in fac do
48644: LD_ADDR_VAR 0 4
48648: PUSH
48649: LD_VAR 0 8
48653: PUSH
48654: FOR_IN
48655: IFFALSE 48869
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
48657: LD_ADDR_VAR 0 9
48661: PUSH
48662: LD_VAR 0 8
48666: PPUSH
48667: LD_VAR 0 1
48671: PPUSH
48672: CALL_OW 265
48676: PPUSH
48677: LD_VAR 0 1
48681: PPUSH
48682: CALL_OW 262
48686: PPUSH
48687: LD_VAR 0 1
48691: PPUSH
48692: CALL_OW 263
48696: PPUSH
48697: LD_VAR 0 1
48701: PPUSH
48702: CALL_OW 264
48706: PPUSH
48707: CALL 53694 0 5
48711: ST_TO_ADDR
// if components then
48712: LD_VAR 0 9
48716: IFFALSE 48867
// begin if GetWeapon ( un ) = ar_control_tower then
48718: LD_VAR 0 1
48722: PPUSH
48723: CALL_OW 264
48727: PUSH
48728: LD_INT 31
48730: EQUAL
48731: IFFALSE 48848
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
48733: LD_VAR 0 1
48737: PPUSH
48738: CALL_OW 311
48742: PPUSH
48743: LD_INT 0
48745: PPUSH
48746: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
48750: LD_ADDR_EXP 133
48754: PUSH
48755: LD_EXP 133
48759: PPUSH
48760: LD_VAR 0 3
48764: PPUSH
48765: LD_EXP 133
48769: PUSH
48770: LD_VAR 0 3
48774: ARRAY
48775: PUSH
48776: LD_VAR 0 1
48780: PPUSH
48781: CALL_OW 311
48785: DIFF
48786: PPUSH
48787: CALL_OW 1
48791: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
48792: LD_ADDR_VAR 0 7
48796: PUSH
48797: LD_EXP 114
48801: PUSH
48802: LD_VAR 0 3
48806: ARRAY
48807: PPUSH
48808: LD_INT 1
48810: PPUSH
48811: LD_VAR 0 9
48815: PPUSH
48816: CALL_OW 2
48820: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
48821: LD_ADDR_EXP 114
48825: PUSH
48826: LD_EXP 114
48830: PPUSH
48831: LD_VAR 0 3
48835: PPUSH
48836: LD_VAR 0 7
48840: PPUSH
48841: CALL_OW 1
48845: ST_TO_ADDR
// end else
48846: GO 48865
// MC_InsertProduceList ( i , [ components ] ) ;
48848: LD_VAR 0 3
48852: PPUSH
48853: LD_VAR 0 9
48857: PUSH
48858: EMPTY
48859: LIST
48860: PPUSH
48861: CALL 44806 0 2
// break ;
48865: GO 48869
// end ; end ;
48867: GO 48654
48869: POP
48870: POP
// end ; end ; if GetType ( un ) = unit_building then
48871: LD_VAR 0 1
48875: PPUSH
48876: CALL_OW 247
48880: PUSH
48881: LD_INT 3
48883: EQUAL
48884: IFFALSE 49287
// begin btype := GetBType ( un ) ;
48886: LD_ADDR_VAR 0 5
48890: PUSH
48891: LD_VAR 0 1
48895: PPUSH
48896: CALL_OW 266
48900: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
48901: LD_VAR 0 5
48905: PUSH
48906: LD_INT 29
48908: PUSH
48909: LD_INT 30
48911: PUSH
48912: EMPTY
48913: LIST
48914: LIST
48915: IN
48916: IFFALSE 48989
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
48918: LD_VAR 0 1
48922: PPUSH
48923: CALL_OW 250
48927: PPUSH
48928: LD_VAR 0 1
48932: PPUSH
48933: CALL_OW 251
48937: PPUSH
48938: LD_VAR 0 1
48942: PPUSH
48943: CALL_OW 255
48947: PPUSH
48948: CALL_OW 440
48952: NOT
48953: IFFALSE 48989
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
48955: LD_VAR 0 1
48959: PPUSH
48960: CALL_OW 250
48964: PPUSH
48965: LD_VAR 0 1
48969: PPUSH
48970: CALL_OW 251
48974: PPUSH
48975: LD_VAR 0 1
48979: PPUSH
48980: CALL_OW 255
48984: PPUSH
48985: CALL_OW 441
// end ; if btype = b_warehouse then
48989: LD_VAR 0 5
48993: PUSH
48994: LD_INT 1
48996: EQUAL
48997: IFFALSE 49015
// begin btype := b_depot ;
48999: LD_ADDR_VAR 0 5
49003: PUSH
49004: LD_INT 0
49006: ST_TO_ADDR
// pos := 1 ;
49007: LD_ADDR_VAR 0 6
49011: PUSH
49012: LD_INT 1
49014: ST_TO_ADDR
// end ; if btype = b_factory then
49015: LD_VAR 0 5
49019: PUSH
49020: LD_INT 3
49022: EQUAL
49023: IFFALSE 49041
// begin btype := b_workshop ;
49025: LD_ADDR_VAR 0 5
49029: PUSH
49030: LD_INT 2
49032: ST_TO_ADDR
// pos := 1 ;
49033: LD_ADDR_VAR 0 6
49037: PUSH
49038: LD_INT 1
49040: ST_TO_ADDR
// end ; if btype = b_barracks then
49041: LD_VAR 0 5
49045: PUSH
49046: LD_INT 5
49048: EQUAL
49049: IFFALSE 49059
// btype := b_armoury ;
49051: LD_ADDR_VAR 0 5
49055: PUSH
49056: LD_INT 4
49058: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
49059: LD_VAR 0 5
49063: PUSH
49064: LD_INT 7
49066: PUSH
49067: LD_INT 8
49069: PUSH
49070: EMPTY
49071: LIST
49072: LIST
49073: IN
49074: IFFALSE 49084
// btype := b_lab ;
49076: LD_ADDR_VAR 0 5
49080: PUSH
49081: LD_INT 6
49083: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
49084: LD_ADDR_EXP 98
49088: PUSH
49089: LD_EXP 98
49093: PPUSH
49094: LD_VAR 0 3
49098: PUSH
49099: LD_EXP 98
49103: PUSH
49104: LD_VAR 0 3
49108: ARRAY
49109: PUSH
49110: LD_INT 1
49112: PLUS
49113: PUSH
49114: EMPTY
49115: LIST
49116: LIST
49117: PPUSH
49118: LD_VAR 0 5
49122: PUSH
49123: LD_VAR 0 1
49127: PPUSH
49128: CALL_OW 250
49132: PUSH
49133: LD_VAR 0 1
49137: PPUSH
49138: CALL_OW 251
49142: PUSH
49143: LD_VAR 0 1
49147: PPUSH
49148: CALL_OW 254
49152: PUSH
49153: EMPTY
49154: LIST
49155: LIST
49156: LIST
49157: LIST
49158: PPUSH
49159: CALL 56198 0 3
49163: ST_TO_ADDR
// if pos = 1 then
49164: LD_VAR 0 6
49168: PUSH
49169: LD_INT 1
49171: EQUAL
49172: IFFALSE 49287
// begin tmp := mc_build_list [ i ] ;
49174: LD_ADDR_VAR 0 7
49178: PUSH
49179: LD_EXP 98
49183: PUSH
49184: LD_VAR 0 3
49188: ARRAY
49189: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
49190: LD_VAR 0 7
49194: PPUSH
49195: LD_INT 2
49197: PUSH
49198: LD_INT 30
49200: PUSH
49201: LD_INT 0
49203: PUSH
49204: EMPTY
49205: LIST
49206: LIST
49207: PUSH
49208: LD_INT 30
49210: PUSH
49211: LD_INT 1
49213: PUSH
49214: EMPTY
49215: LIST
49216: LIST
49217: PUSH
49218: EMPTY
49219: LIST
49220: LIST
49221: LIST
49222: PPUSH
49223: CALL_OW 72
49227: IFFALSE 49237
// pos := 2 ;
49229: LD_ADDR_VAR 0 6
49233: PUSH
49234: LD_INT 2
49236: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
49237: LD_ADDR_VAR 0 7
49241: PUSH
49242: LD_VAR 0 7
49246: PPUSH
49247: LD_VAR 0 6
49251: PPUSH
49252: LD_VAR 0 7
49256: PPUSH
49257: CALL 56524 0 3
49261: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
49262: LD_ADDR_EXP 98
49266: PUSH
49267: LD_EXP 98
49271: PPUSH
49272: LD_VAR 0 3
49276: PPUSH
49277: LD_VAR 0 7
49281: PPUSH
49282: CALL_OW 1
49286: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
49287: LD_VAR 0 1
49291: PUSH
49292: LD_EXP 93
49296: PUSH
49297: LD_VAR 0 3
49301: ARRAY
49302: IN
49303: IFFALSE 49342
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
49305: LD_ADDR_EXP 93
49309: PUSH
49310: LD_EXP 93
49314: PPUSH
49315: LD_VAR 0 3
49319: PPUSH
49320: LD_EXP 93
49324: PUSH
49325: LD_VAR 0 3
49329: ARRAY
49330: PUSH
49331: LD_VAR 0 1
49335: DIFF
49336: PPUSH
49337: CALL_OW 1
49341: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
49342: LD_VAR 0 1
49346: PUSH
49347: LD_EXP 100
49351: PUSH
49352: LD_VAR 0 3
49356: ARRAY
49357: IN
49358: IFFALSE 49397
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
49360: LD_ADDR_EXP 100
49364: PUSH
49365: LD_EXP 100
49369: PPUSH
49370: LD_VAR 0 3
49374: PPUSH
49375: LD_EXP 100
49379: PUSH
49380: LD_VAR 0 3
49384: ARRAY
49385: PUSH
49386: LD_VAR 0 1
49390: DIFF
49391: PPUSH
49392: CALL_OW 1
49396: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
49397: LD_VAR 0 1
49401: PUSH
49402: LD_EXP 112
49406: PUSH
49407: LD_VAR 0 3
49411: ARRAY
49412: IN
49413: IFFALSE 49452
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
49415: LD_ADDR_EXP 112
49419: PUSH
49420: LD_EXP 112
49424: PPUSH
49425: LD_VAR 0 3
49429: PPUSH
49430: LD_EXP 112
49434: PUSH
49435: LD_VAR 0 3
49439: ARRAY
49440: PUSH
49441: LD_VAR 0 1
49445: DIFF
49446: PPUSH
49447: CALL_OW 1
49451: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
49452: LD_VAR 0 1
49456: PUSH
49457: LD_EXP 115
49461: PUSH
49462: LD_VAR 0 3
49466: ARRAY
49467: IN
49468: IFFALSE 49507
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
49470: LD_ADDR_EXP 115
49474: PUSH
49475: LD_EXP 115
49479: PPUSH
49480: LD_VAR 0 3
49484: PPUSH
49485: LD_EXP 115
49489: PUSH
49490: LD_VAR 0 3
49494: ARRAY
49495: PUSH
49496: LD_VAR 0 1
49500: DIFF
49501: PPUSH
49502: CALL_OW 1
49506: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
49507: LD_VAR 0 1
49511: PUSH
49512: LD_EXP 102
49516: PUSH
49517: LD_VAR 0 3
49521: ARRAY
49522: IN
49523: IFFALSE 49562
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
49525: LD_ADDR_EXP 102
49529: PUSH
49530: LD_EXP 102
49534: PPUSH
49535: LD_VAR 0 3
49539: PPUSH
49540: LD_EXP 102
49544: PUSH
49545: LD_VAR 0 3
49549: ARRAY
49550: PUSH
49551: LD_VAR 0 1
49555: DIFF
49556: PPUSH
49557: CALL_OW 1
49561: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
49562: LD_VAR 0 1
49566: PUSH
49567: LD_EXP 101
49571: PUSH
49572: LD_VAR 0 3
49576: ARRAY
49577: IN
49578: IFFALSE 49617
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
49580: LD_ADDR_EXP 101
49584: PUSH
49585: LD_EXP 101
49589: PPUSH
49590: LD_VAR 0 3
49594: PPUSH
49595: LD_EXP 101
49599: PUSH
49600: LD_VAR 0 3
49604: ARRAY
49605: PUSH
49606: LD_VAR 0 1
49610: DIFF
49611: PPUSH
49612: CALL_OW 1
49616: ST_TO_ADDR
// end ; break ;
49617: GO 49621
// end ;
49619: GO 48267
49621: POP
49622: POP
// end ;
49623: LD_VAR 0 2
49627: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
49628: LD_INT 0
49630: PPUSH
49631: PPUSH
49632: PPUSH
// if not mc_bases or not skirmish then
49633: LD_EXP 93
49637: NOT
49638: PUSH
49639: LD_EXP 91
49643: NOT
49644: OR
49645: IFFALSE 49649
// exit ;
49647: GO 49864
// for i = 1 to mc_bases do
49649: LD_ADDR_VAR 0 3
49653: PUSH
49654: DOUBLE
49655: LD_INT 1
49657: DEC
49658: ST_TO_ADDR
49659: LD_EXP 93
49663: PUSH
49664: FOR_TO
49665: IFFALSE 49862
// begin if building in mc_construct_list [ i ] then
49667: LD_VAR 0 1
49671: PUSH
49672: LD_EXP 100
49676: PUSH
49677: LD_VAR 0 3
49681: ARRAY
49682: IN
49683: IFFALSE 49860
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
49685: LD_ADDR_EXP 100
49689: PUSH
49690: LD_EXP 100
49694: PPUSH
49695: LD_VAR 0 3
49699: PPUSH
49700: LD_EXP 100
49704: PUSH
49705: LD_VAR 0 3
49709: ARRAY
49710: PUSH
49711: LD_VAR 0 1
49715: DIFF
49716: PPUSH
49717: CALL_OW 1
49721: ST_TO_ADDR
// if building in mc_lab [ i ] then
49722: LD_VAR 0 1
49726: PUSH
49727: LD_EXP 126
49731: PUSH
49732: LD_VAR 0 3
49736: ARRAY
49737: IN
49738: IFFALSE 49793
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
49740: LD_ADDR_EXP 127
49744: PUSH
49745: LD_EXP 127
49749: PPUSH
49750: LD_VAR 0 3
49754: PPUSH
49755: LD_EXP 127
49759: PUSH
49760: LD_VAR 0 3
49764: ARRAY
49765: PPUSH
49766: LD_INT 1
49768: PPUSH
49769: LD_EXP 127
49773: PUSH
49774: LD_VAR 0 3
49778: ARRAY
49779: PPUSH
49780: LD_INT 0
49782: PPUSH
49783: CALL 55616 0 4
49787: PPUSH
49788: CALL_OW 1
49792: ST_TO_ADDR
// if not building in mc_bases [ i ] then
49793: LD_VAR 0 1
49797: PUSH
49798: LD_EXP 93
49802: PUSH
49803: LD_VAR 0 3
49807: ARRAY
49808: IN
49809: NOT
49810: IFFALSE 49856
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
49812: LD_ADDR_EXP 93
49816: PUSH
49817: LD_EXP 93
49821: PPUSH
49822: LD_VAR 0 3
49826: PUSH
49827: LD_EXP 93
49831: PUSH
49832: LD_VAR 0 3
49836: ARRAY
49837: PUSH
49838: LD_INT 1
49840: PLUS
49841: PUSH
49842: EMPTY
49843: LIST
49844: LIST
49845: PPUSH
49846: LD_VAR 0 1
49850: PPUSH
49851: CALL 56198 0 3
49855: ST_TO_ADDR
// exit ;
49856: POP
49857: POP
49858: GO 49864
// end ; end ;
49860: GO 49664
49862: POP
49863: POP
// end ;
49864: LD_VAR 0 2
49868: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
49869: LD_INT 0
49871: PPUSH
49872: PPUSH
49873: PPUSH
49874: PPUSH
49875: PPUSH
49876: PPUSH
49877: PPUSH
// if not mc_bases or not skirmish then
49878: LD_EXP 93
49882: NOT
49883: PUSH
49884: LD_EXP 91
49888: NOT
49889: OR
49890: IFFALSE 49894
// exit ;
49892: GO 50555
// for i = 1 to mc_bases do
49894: LD_ADDR_VAR 0 3
49898: PUSH
49899: DOUBLE
49900: LD_INT 1
49902: DEC
49903: ST_TO_ADDR
49904: LD_EXP 93
49908: PUSH
49909: FOR_TO
49910: IFFALSE 50553
// begin if building in mc_construct_list [ i ] then
49912: LD_VAR 0 1
49916: PUSH
49917: LD_EXP 100
49921: PUSH
49922: LD_VAR 0 3
49926: ARRAY
49927: IN
49928: IFFALSE 50551
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
49930: LD_ADDR_EXP 100
49934: PUSH
49935: LD_EXP 100
49939: PPUSH
49940: LD_VAR 0 3
49944: PPUSH
49945: LD_EXP 100
49949: PUSH
49950: LD_VAR 0 3
49954: ARRAY
49955: PUSH
49956: LD_VAR 0 1
49960: DIFF
49961: PPUSH
49962: CALL_OW 1
49966: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
49967: LD_ADDR_EXP 93
49971: PUSH
49972: LD_EXP 93
49976: PPUSH
49977: LD_VAR 0 3
49981: PUSH
49982: LD_EXP 93
49986: PUSH
49987: LD_VAR 0 3
49991: ARRAY
49992: PUSH
49993: LD_INT 1
49995: PLUS
49996: PUSH
49997: EMPTY
49998: LIST
49999: LIST
50000: PPUSH
50001: LD_VAR 0 1
50005: PPUSH
50006: CALL 56198 0 3
50010: ST_TO_ADDR
// btype := GetBType ( building ) ;
50011: LD_ADDR_VAR 0 5
50015: PUSH
50016: LD_VAR 0 1
50020: PPUSH
50021: CALL_OW 266
50025: ST_TO_ADDR
// side := GetSide ( building ) ;
50026: LD_ADDR_VAR 0 8
50030: PUSH
50031: LD_VAR 0 1
50035: PPUSH
50036: CALL_OW 255
50040: ST_TO_ADDR
// if btype = b_lab then
50041: LD_VAR 0 5
50045: PUSH
50046: LD_INT 6
50048: EQUAL
50049: IFFALSE 50099
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
50051: LD_ADDR_EXP 126
50055: PUSH
50056: LD_EXP 126
50060: PPUSH
50061: LD_VAR 0 3
50065: PUSH
50066: LD_EXP 126
50070: PUSH
50071: LD_VAR 0 3
50075: ARRAY
50076: PUSH
50077: LD_INT 1
50079: PLUS
50080: PUSH
50081: EMPTY
50082: LIST
50083: LIST
50084: PPUSH
50085: LD_VAR 0 1
50089: PPUSH
50090: CALL 56198 0 3
50094: ST_TO_ADDR
// exit ;
50095: POP
50096: POP
50097: GO 50555
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
50099: LD_VAR 0 5
50103: PUSH
50104: LD_INT 0
50106: PUSH
50107: LD_INT 2
50109: PUSH
50110: LD_INT 4
50112: PUSH
50113: EMPTY
50114: LIST
50115: LIST
50116: LIST
50117: IN
50118: IFFALSE 50242
// begin if btype = b_armoury then
50120: LD_VAR 0 5
50124: PUSH
50125: LD_INT 4
50127: EQUAL
50128: IFFALSE 50138
// btype := b_barracks ;
50130: LD_ADDR_VAR 0 5
50134: PUSH
50135: LD_INT 5
50137: ST_TO_ADDR
// if btype = b_depot then
50138: LD_VAR 0 5
50142: PUSH
50143: LD_INT 0
50145: EQUAL
50146: IFFALSE 50156
// btype := b_warehouse ;
50148: LD_ADDR_VAR 0 5
50152: PUSH
50153: LD_INT 1
50155: ST_TO_ADDR
// if btype = b_workshop then
50156: LD_VAR 0 5
50160: PUSH
50161: LD_INT 2
50163: EQUAL
50164: IFFALSE 50174
// btype := b_factory ;
50166: LD_ADDR_VAR 0 5
50170: PUSH
50171: LD_INT 3
50173: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
50174: LD_VAR 0 5
50178: PPUSH
50179: LD_VAR 0 8
50183: PPUSH
50184: CALL_OW 323
50188: PUSH
50189: LD_INT 1
50191: EQUAL
50192: IFFALSE 50238
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
50194: LD_ADDR_EXP 125
50198: PUSH
50199: LD_EXP 125
50203: PPUSH
50204: LD_VAR 0 3
50208: PUSH
50209: LD_EXP 125
50213: PUSH
50214: LD_VAR 0 3
50218: ARRAY
50219: PUSH
50220: LD_INT 1
50222: PLUS
50223: PUSH
50224: EMPTY
50225: LIST
50226: LIST
50227: PPUSH
50228: LD_VAR 0 1
50232: PPUSH
50233: CALL 56198 0 3
50237: ST_TO_ADDR
// exit ;
50238: POP
50239: POP
50240: GO 50555
// end ; if btype in [ b_bunker , b_turret ] then
50242: LD_VAR 0 5
50246: PUSH
50247: LD_INT 32
50249: PUSH
50250: LD_INT 33
50252: PUSH
50253: EMPTY
50254: LIST
50255: LIST
50256: IN
50257: IFFALSE 50547
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
50259: LD_ADDR_EXP 101
50263: PUSH
50264: LD_EXP 101
50268: PPUSH
50269: LD_VAR 0 3
50273: PUSH
50274: LD_EXP 101
50278: PUSH
50279: LD_VAR 0 3
50283: ARRAY
50284: PUSH
50285: LD_INT 1
50287: PLUS
50288: PUSH
50289: EMPTY
50290: LIST
50291: LIST
50292: PPUSH
50293: LD_VAR 0 1
50297: PPUSH
50298: CALL 56198 0 3
50302: ST_TO_ADDR
// if btype = b_bunker then
50303: LD_VAR 0 5
50307: PUSH
50308: LD_INT 32
50310: EQUAL
50311: IFFALSE 50547
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
50313: LD_ADDR_EXP 102
50317: PUSH
50318: LD_EXP 102
50322: PPUSH
50323: LD_VAR 0 3
50327: PUSH
50328: LD_EXP 102
50332: PUSH
50333: LD_VAR 0 3
50337: ARRAY
50338: PUSH
50339: LD_INT 1
50341: PLUS
50342: PUSH
50343: EMPTY
50344: LIST
50345: LIST
50346: PPUSH
50347: LD_VAR 0 1
50351: PPUSH
50352: CALL 56198 0 3
50356: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
50357: LD_ADDR_VAR 0 6
50361: PUSH
50362: LD_EXP 93
50366: PUSH
50367: LD_VAR 0 3
50371: ARRAY
50372: PPUSH
50373: LD_INT 25
50375: PUSH
50376: LD_INT 1
50378: PUSH
50379: EMPTY
50380: LIST
50381: LIST
50382: PUSH
50383: LD_INT 3
50385: PUSH
50386: LD_INT 54
50388: PUSH
50389: EMPTY
50390: LIST
50391: PUSH
50392: EMPTY
50393: LIST
50394: LIST
50395: PUSH
50396: EMPTY
50397: LIST
50398: LIST
50399: PPUSH
50400: CALL_OW 72
50404: ST_TO_ADDR
// if tmp then
50405: LD_VAR 0 6
50409: IFFALSE 50415
// exit ;
50411: POP
50412: POP
50413: GO 50555
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
50415: LD_ADDR_VAR 0 6
50419: PUSH
50420: LD_EXP 93
50424: PUSH
50425: LD_VAR 0 3
50429: ARRAY
50430: PPUSH
50431: LD_INT 2
50433: PUSH
50434: LD_INT 30
50436: PUSH
50437: LD_INT 4
50439: PUSH
50440: EMPTY
50441: LIST
50442: LIST
50443: PUSH
50444: LD_INT 30
50446: PUSH
50447: LD_INT 5
50449: PUSH
50450: EMPTY
50451: LIST
50452: LIST
50453: PUSH
50454: EMPTY
50455: LIST
50456: LIST
50457: LIST
50458: PPUSH
50459: CALL_OW 72
50463: ST_TO_ADDR
// if not tmp then
50464: LD_VAR 0 6
50468: NOT
50469: IFFALSE 50475
// exit ;
50471: POP
50472: POP
50473: GO 50555
// for j in tmp do
50475: LD_ADDR_VAR 0 4
50479: PUSH
50480: LD_VAR 0 6
50484: PUSH
50485: FOR_IN
50486: IFFALSE 50545
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
50488: LD_ADDR_VAR 0 7
50492: PUSH
50493: LD_VAR 0 4
50497: PPUSH
50498: CALL_OW 313
50502: PPUSH
50503: LD_INT 25
50505: PUSH
50506: LD_INT 1
50508: PUSH
50509: EMPTY
50510: LIST
50511: LIST
50512: PPUSH
50513: CALL_OW 72
50517: ST_TO_ADDR
// if units then
50518: LD_VAR 0 7
50522: IFFALSE 50543
// begin ComExitBuilding ( units [ 1 ] ) ;
50524: LD_VAR 0 7
50528: PUSH
50529: LD_INT 1
50531: ARRAY
50532: PPUSH
50533: CALL_OW 122
// exit ;
50537: POP
50538: POP
50539: POP
50540: POP
50541: GO 50555
// end ; end ;
50543: GO 50485
50545: POP
50546: POP
// end ; end ; exit ;
50547: POP
50548: POP
50549: GO 50555
// end ; end ;
50551: GO 49909
50553: POP
50554: POP
// end ;
50555: LD_VAR 0 2
50559: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
50560: LD_INT 0
50562: PPUSH
50563: PPUSH
50564: PPUSH
50565: PPUSH
50566: PPUSH
50567: PPUSH
50568: PPUSH
// if not mc_bases or not skirmish then
50569: LD_EXP 93
50573: NOT
50574: PUSH
50575: LD_EXP 91
50579: NOT
50580: OR
50581: IFFALSE 50585
// exit ;
50583: GO 50850
// btype := GetBType ( building ) ;
50585: LD_ADDR_VAR 0 6
50589: PUSH
50590: LD_VAR 0 1
50594: PPUSH
50595: CALL_OW 266
50599: ST_TO_ADDR
// x := GetX ( building ) ;
50600: LD_ADDR_VAR 0 7
50604: PUSH
50605: LD_VAR 0 1
50609: PPUSH
50610: CALL_OW 250
50614: ST_TO_ADDR
// y := GetY ( building ) ;
50615: LD_ADDR_VAR 0 8
50619: PUSH
50620: LD_VAR 0 1
50624: PPUSH
50625: CALL_OW 251
50629: ST_TO_ADDR
// d := GetDir ( building ) ;
50630: LD_ADDR_VAR 0 9
50634: PUSH
50635: LD_VAR 0 1
50639: PPUSH
50640: CALL_OW 254
50644: ST_TO_ADDR
// for i = 1 to mc_bases do
50645: LD_ADDR_VAR 0 4
50649: PUSH
50650: DOUBLE
50651: LD_INT 1
50653: DEC
50654: ST_TO_ADDR
50655: LD_EXP 93
50659: PUSH
50660: FOR_TO
50661: IFFALSE 50848
// begin if not mc_build_list [ i ] then
50663: LD_EXP 98
50667: PUSH
50668: LD_VAR 0 4
50672: ARRAY
50673: NOT
50674: IFFALSE 50678
// continue ;
50676: GO 50660
// for j := 1 to mc_build_list [ i ] do
50678: LD_ADDR_VAR 0 5
50682: PUSH
50683: DOUBLE
50684: LD_INT 1
50686: DEC
50687: ST_TO_ADDR
50688: LD_EXP 98
50692: PUSH
50693: LD_VAR 0 4
50697: ARRAY
50698: PUSH
50699: FOR_TO
50700: IFFALSE 50844
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
50702: LD_VAR 0 6
50706: PUSH
50707: LD_VAR 0 7
50711: PUSH
50712: LD_VAR 0 8
50716: PUSH
50717: LD_VAR 0 9
50721: PUSH
50722: EMPTY
50723: LIST
50724: LIST
50725: LIST
50726: LIST
50727: PPUSH
50728: LD_EXP 98
50732: PUSH
50733: LD_VAR 0 4
50737: ARRAY
50738: PUSH
50739: LD_VAR 0 5
50743: ARRAY
50744: PPUSH
50745: CALL 62381 0 2
50749: IFFALSE 50842
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
50751: LD_ADDR_EXP 98
50755: PUSH
50756: LD_EXP 98
50760: PPUSH
50761: LD_VAR 0 4
50765: PPUSH
50766: LD_EXP 98
50770: PUSH
50771: LD_VAR 0 4
50775: ARRAY
50776: PPUSH
50777: LD_VAR 0 5
50781: PPUSH
50782: CALL_OW 3
50786: PPUSH
50787: CALL_OW 1
50791: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
50792: LD_ADDR_EXP 100
50796: PUSH
50797: LD_EXP 100
50801: PPUSH
50802: LD_VAR 0 4
50806: PUSH
50807: LD_EXP 100
50811: PUSH
50812: LD_VAR 0 4
50816: ARRAY
50817: PUSH
50818: LD_INT 1
50820: PLUS
50821: PUSH
50822: EMPTY
50823: LIST
50824: LIST
50825: PPUSH
50826: LD_VAR 0 1
50830: PPUSH
50831: CALL 56198 0 3
50835: ST_TO_ADDR
// exit ;
50836: POP
50837: POP
50838: POP
50839: POP
50840: GO 50850
// end ;
50842: GO 50699
50844: POP
50845: POP
// end ;
50846: GO 50660
50848: POP
50849: POP
// end ;
50850: LD_VAR 0 3
50854: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
50855: LD_INT 0
50857: PPUSH
50858: PPUSH
50859: PPUSH
// if not mc_bases or not skirmish then
50860: LD_EXP 93
50864: NOT
50865: PUSH
50866: LD_EXP 91
50870: NOT
50871: OR
50872: IFFALSE 50876
// exit ;
50874: GO 51066
// for i = 1 to mc_bases do
50876: LD_ADDR_VAR 0 4
50880: PUSH
50881: DOUBLE
50882: LD_INT 1
50884: DEC
50885: ST_TO_ADDR
50886: LD_EXP 93
50890: PUSH
50891: FOR_TO
50892: IFFALSE 50979
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
50894: LD_VAR 0 1
50898: PUSH
50899: LD_EXP 101
50903: PUSH
50904: LD_VAR 0 4
50908: ARRAY
50909: IN
50910: PUSH
50911: LD_VAR 0 1
50915: PUSH
50916: LD_EXP 102
50920: PUSH
50921: LD_VAR 0 4
50925: ARRAY
50926: IN
50927: NOT
50928: AND
50929: IFFALSE 50977
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
50931: LD_ADDR_EXP 102
50935: PUSH
50936: LD_EXP 102
50940: PPUSH
50941: LD_VAR 0 4
50945: PUSH
50946: LD_EXP 102
50950: PUSH
50951: LD_VAR 0 4
50955: ARRAY
50956: PUSH
50957: LD_INT 1
50959: PLUS
50960: PUSH
50961: EMPTY
50962: LIST
50963: LIST
50964: PPUSH
50965: LD_VAR 0 1
50969: PPUSH
50970: CALL 56198 0 3
50974: ST_TO_ADDR
// break ;
50975: GO 50979
// end ; end ;
50977: GO 50891
50979: POP
50980: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
50981: LD_VAR 0 1
50985: PPUSH
50986: CALL_OW 257
50990: PUSH
50991: LD_EXP 119
50995: IN
50996: PUSH
50997: LD_VAR 0 1
51001: PPUSH
51002: CALL_OW 266
51006: PUSH
51007: LD_INT 5
51009: EQUAL
51010: AND
51011: PUSH
51012: LD_VAR 0 2
51016: PPUSH
51017: CALL_OW 110
51021: PUSH
51022: LD_INT 18
51024: NONEQUAL
51025: AND
51026: IFFALSE 51066
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
51028: LD_VAR 0 2
51032: PPUSH
51033: CALL_OW 257
51037: PUSH
51038: LD_INT 5
51040: PUSH
51041: LD_INT 8
51043: PUSH
51044: LD_INT 9
51046: PUSH
51047: EMPTY
51048: LIST
51049: LIST
51050: LIST
51051: IN
51052: IFFALSE 51066
// SetClass ( unit , 1 ) ;
51054: LD_VAR 0 2
51058: PPUSH
51059: LD_INT 1
51061: PPUSH
51062: CALL_OW 336
// end ;
51066: LD_VAR 0 3
51070: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
51071: LD_INT 0
51073: PPUSH
51074: PPUSH
// if not mc_bases or not skirmish then
51075: LD_EXP 93
51079: NOT
51080: PUSH
51081: LD_EXP 91
51085: NOT
51086: OR
51087: IFFALSE 51091
// exit ;
51089: GO 51207
// if GetLives ( abandoned_vehicle ) > 250 then
51091: LD_VAR 0 2
51095: PPUSH
51096: CALL_OW 256
51100: PUSH
51101: LD_INT 250
51103: GREATER
51104: IFFALSE 51108
// exit ;
51106: GO 51207
// for i = 1 to mc_bases do
51108: LD_ADDR_VAR 0 6
51112: PUSH
51113: DOUBLE
51114: LD_INT 1
51116: DEC
51117: ST_TO_ADDR
51118: LD_EXP 93
51122: PUSH
51123: FOR_TO
51124: IFFALSE 51205
// begin if driver in mc_bases [ i ] then
51126: LD_VAR 0 1
51130: PUSH
51131: LD_EXP 93
51135: PUSH
51136: LD_VAR 0 6
51140: ARRAY
51141: IN
51142: IFFALSE 51203
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
51144: LD_VAR 0 1
51148: PPUSH
51149: LD_EXP 93
51153: PUSH
51154: LD_VAR 0 6
51158: ARRAY
51159: PPUSH
51160: LD_INT 2
51162: PUSH
51163: LD_INT 30
51165: PUSH
51166: LD_INT 0
51168: PUSH
51169: EMPTY
51170: LIST
51171: LIST
51172: PUSH
51173: LD_INT 30
51175: PUSH
51176: LD_INT 1
51178: PUSH
51179: EMPTY
51180: LIST
51181: LIST
51182: PUSH
51183: EMPTY
51184: LIST
51185: LIST
51186: LIST
51187: PPUSH
51188: CALL_OW 72
51192: PUSH
51193: LD_INT 1
51195: ARRAY
51196: PPUSH
51197: CALL 88817 0 2
// break ;
51201: GO 51205
// end ; end ;
51203: GO 51123
51205: POP
51206: POP
// end ; end_of_file
51207: LD_VAR 0 5
51211: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
51212: LD_INT 0
51214: PPUSH
51215: PPUSH
// if exist_mode then
51216: LD_VAR 0 2
51220: IFFALSE 51245
// unit := CreateCharacter ( prefix & ident ) else
51222: LD_ADDR_VAR 0 5
51226: PUSH
51227: LD_VAR 0 3
51231: PUSH
51232: LD_VAR 0 1
51236: STR
51237: PPUSH
51238: CALL_OW 34
51242: ST_TO_ADDR
51243: GO 51260
// unit := NewCharacter ( ident ) ;
51245: LD_ADDR_VAR 0 5
51249: PUSH
51250: LD_VAR 0 1
51254: PPUSH
51255: CALL_OW 25
51259: ST_TO_ADDR
// result := unit ;
51260: LD_ADDR_VAR 0 4
51264: PUSH
51265: LD_VAR 0 5
51269: ST_TO_ADDR
// end ;
51270: LD_VAR 0 4
51274: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
51275: LD_INT 0
51277: PPUSH
51278: PPUSH
// if not side or not nation then
51279: LD_VAR 0 1
51283: NOT
51284: PUSH
51285: LD_VAR 0 2
51289: NOT
51290: OR
51291: IFFALSE 51295
// exit ;
51293: GO 52063
// case nation of nation_american :
51295: LD_VAR 0 2
51299: PUSH
51300: LD_INT 1
51302: DOUBLE
51303: EQUAL
51304: IFTRUE 51308
51306: GO 51522
51308: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
51309: LD_ADDR_VAR 0 4
51313: PUSH
51314: LD_INT 35
51316: PUSH
51317: LD_INT 45
51319: PUSH
51320: LD_INT 46
51322: PUSH
51323: LD_INT 47
51325: PUSH
51326: LD_INT 82
51328: PUSH
51329: LD_INT 83
51331: PUSH
51332: LD_INT 84
51334: PUSH
51335: LD_INT 85
51337: PUSH
51338: LD_INT 86
51340: PUSH
51341: LD_INT 1
51343: PUSH
51344: LD_INT 2
51346: PUSH
51347: LD_INT 6
51349: PUSH
51350: LD_INT 15
51352: PUSH
51353: LD_INT 16
51355: PUSH
51356: LD_INT 7
51358: PUSH
51359: LD_INT 12
51361: PUSH
51362: LD_INT 13
51364: PUSH
51365: LD_INT 10
51367: PUSH
51368: LD_INT 14
51370: PUSH
51371: LD_INT 20
51373: PUSH
51374: LD_INT 21
51376: PUSH
51377: LD_INT 22
51379: PUSH
51380: LD_INT 25
51382: PUSH
51383: LD_INT 32
51385: PUSH
51386: LD_INT 27
51388: PUSH
51389: LD_INT 36
51391: PUSH
51392: LD_INT 69
51394: PUSH
51395: LD_INT 39
51397: PUSH
51398: LD_INT 34
51400: PUSH
51401: LD_INT 40
51403: PUSH
51404: LD_INT 48
51406: PUSH
51407: LD_INT 49
51409: PUSH
51410: LD_INT 50
51412: PUSH
51413: LD_INT 51
51415: PUSH
51416: LD_INT 52
51418: PUSH
51419: LD_INT 53
51421: PUSH
51422: LD_INT 54
51424: PUSH
51425: LD_INT 55
51427: PUSH
51428: LD_INT 56
51430: PUSH
51431: LD_INT 57
51433: PUSH
51434: LD_INT 58
51436: PUSH
51437: LD_INT 59
51439: PUSH
51440: LD_INT 60
51442: PUSH
51443: LD_INT 61
51445: PUSH
51446: LD_INT 62
51448: PUSH
51449: LD_INT 80
51451: PUSH
51452: LD_INT 82
51454: PUSH
51455: LD_INT 83
51457: PUSH
51458: LD_INT 84
51460: PUSH
51461: LD_INT 85
51463: PUSH
51464: LD_INT 86
51466: PUSH
51467: EMPTY
51468: LIST
51469: LIST
51470: LIST
51471: LIST
51472: LIST
51473: LIST
51474: LIST
51475: LIST
51476: LIST
51477: LIST
51478: LIST
51479: LIST
51480: LIST
51481: LIST
51482: LIST
51483: LIST
51484: LIST
51485: LIST
51486: LIST
51487: LIST
51488: LIST
51489: LIST
51490: LIST
51491: LIST
51492: LIST
51493: LIST
51494: LIST
51495: LIST
51496: LIST
51497: LIST
51498: LIST
51499: LIST
51500: LIST
51501: LIST
51502: LIST
51503: LIST
51504: LIST
51505: LIST
51506: LIST
51507: LIST
51508: LIST
51509: LIST
51510: LIST
51511: LIST
51512: LIST
51513: LIST
51514: LIST
51515: LIST
51516: LIST
51517: LIST
51518: LIST
51519: ST_TO_ADDR
51520: GO 51987
51522: LD_INT 2
51524: DOUBLE
51525: EQUAL
51526: IFTRUE 51530
51528: GO 51756
51530: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
51531: LD_ADDR_VAR 0 4
51535: PUSH
51536: LD_INT 35
51538: PUSH
51539: LD_INT 45
51541: PUSH
51542: LD_INT 46
51544: PUSH
51545: LD_INT 47
51547: PUSH
51548: LD_INT 82
51550: PUSH
51551: LD_INT 83
51553: PUSH
51554: LD_INT 84
51556: PUSH
51557: LD_INT 85
51559: PUSH
51560: LD_INT 87
51562: PUSH
51563: LD_INT 70
51565: PUSH
51566: LD_INT 1
51568: PUSH
51569: LD_INT 11
51571: PUSH
51572: LD_INT 3
51574: PUSH
51575: LD_INT 4
51577: PUSH
51578: LD_INT 5
51580: PUSH
51581: LD_INT 6
51583: PUSH
51584: LD_INT 15
51586: PUSH
51587: LD_INT 18
51589: PUSH
51590: LD_INT 7
51592: PUSH
51593: LD_INT 17
51595: PUSH
51596: LD_INT 8
51598: PUSH
51599: LD_INT 20
51601: PUSH
51602: LD_INT 21
51604: PUSH
51605: LD_INT 22
51607: PUSH
51608: LD_INT 72
51610: PUSH
51611: LD_INT 26
51613: PUSH
51614: LD_INT 69
51616: PUSH
51617: LD_INT 39
51619: PUSH
51620: LD_INT 40
51622: PUSH
51623: LD_INT 41
51625: PUSH
51626: LD_INT 42
51628: PUSH
51629: LD_INT 43
51631: PUSH
51632: LD_INT 48
51634: PUSH
51635: LD_INT 49
51637: PUSH
51638: LD_INT 50
51640: PUSH
51641: LD_INT 51
51643: PUSH
51644: LD_INT 52
51646: PUSH
51647: LD_INT 53
51649: PUSH
51650: LD_INT 54
51652: PUSH
51653: LD_INT 55
51655: PUSH
51656: LD_INT 56
51658: PUSH
51659: LD_INT 60
51661: PUSH
51662: LD_INT 61
51664: PUSH
51665: LD_INT 62
51667: PUSH
51668: LD_INT 66
51670: PUSH
51671: LD_INT 67
51673: PUSH
51674: LD_INT 68
51676: PUSH
51677: LD_INT 81
51679: PUSH
51680: LD_INT 82
51682: PUSH
51683: LD_INT 83
51685: PUSH
51686: LD_INT 84
51688: PUSH
51689: LD_INT 85
51691: PUSH
51692: LD_INT 87
51694: PUSH
51695: LD_INT 88
51697: PUSH
51698: EMPTY
51699: LIST
51700: LIST
51701: LIST
51702: LIST
51703: LIST
51704: LIST
51705: LIST
51706: LIST
51707: LIST
51708: LIST
51709: LIST
51710: LIST
51711: LIST
51712: LIST
51713: LIST
51714: LIST
51715: LIST
51716: LIST
51717: LIST
51718: LIST
51719: LIST
51720: LIST
51721: LIST
51722: LIST
51723: LIST
51724: LIST
51725: LIST
51726: LIST
51727: LIST
51728: LIST
51729: LIST
51730: LIST
51731: LIST
51732: LIST
51733: LIST
51734: LIST
51735: LIST
51736: LIST
51737: LIST
51738: LIST
51739: LIST
51740: LIST
51741: LIST
51742: LIST
51743: LIST
51744: LIST
51745: LIST
51746: LIST
51747: LIST
51748: LIST
51749: LIST
51750: LIST
51751: LIST
51752: LIST
51753: ST_TO_ADDR
51754: GO 51987
51756: LD_INT 3
51758: DOUBLE
51759: EQUAL
51760: IFTRUE 51764
51762: GO 51986
51764: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
51765: LD_ADDR_VAR 0 4
51769: PUSH
51770: LD_INT 46
51772: PUSH
51773: LD_INT 47
51775: PUSH
51776: LD_INT 1
51778: PUSH
51779: LD_INT 2
51781: PUSH
51782: LD_INT 82
51784: PUSH
51785: LD_INT 83
51787: PUSH
51788: LD_INT 84
51790: PUSH
51791: LD_INT 85
51793: PUSH
51794: LD_INT 86
51796: PUSH
51797: LD_INT 11
51799: PUSH
51800: LD_INT 9
51802: PUSH
51803: LD_INT 20
51805: PUSH
51806: LD_INT 19
51808: PUSH
51809: LD_INT 21
51811: PUSH
51812: LD_INT 24
51814: PUSH
51815: LD_INT 22
51817: PUSH
51818: LD_INT 25
51820: PUSH
51821: LD_INT 28
51823: PUSH
51824: LD_INT 29
51826: PUSH
51827: LD_INT 30
51829: PUSH
51830: LD_INT 31
51832: PUSH
51833: LD_INT 37
51835: PUSH
51836: LD_INT 38
51838: PUSH
51839: LD_INT 32
51841: PUSH
51842: LD_INT 27
51844: PUSH
51845: LD_INT 33
51847: PUSH
51848: LD_INT 69
51850: PUSH
51851: LD_INT 39
51853: PUSH
51854: LD_INT 34
51856: PUSH
51857: LD_INT 40
51859: PUSH
51860: LD_INT 71
51862: PUSH
51863: LD_INT 23
51865: PUSH
51866: LD_INT 44
51868: PUSH
51869: LD_INT 48
51871: PUSH
51872: LD_INT 49
51874: PUSH
51875: LD_INT 50
51877: PUSH
51878: LD_INT 51
51880: PUSH
51881: LD_INT 52
51883: PUSH
51884: LD_INT 53
51886: PUSH
51887: LD_INT 54
51889: PUSH
51890: LD_INT 55
51892: PUSH
51893: LD_INT 56
51895: PUSH
51896: LD_INT 57
51898: PUSH
51899: LD_INT 58
51901: PUSH
51902: LD_INT 59
51904: PUSH
51905: LD_INT 63
51907: PUSH
51908: LD_INT 64
51910: PUSH
51911: LD_INT 65
51913: PUSH
51914: LD_INT 82
51916: PUSH
51917: LD_INT 83
51919: PUSH
51920: LD_INT 84
51922: PUSH
51923: LD_INT 85
51925: PUSH
51926: LD_INT 86
51928: PUSH
51929: EMPTY
51930: LIST
51931: LIST
51932: LIST
51933: LIST
51934: LIST
51935: LIST
51936: LIST
51937: LIST
51938: LIST
51939: LIST
51940: LIST
51941: LIST
51942: LIST
51943: LIST
51944: LIST
51945: LIST
51946: LIST
51947: LIST
51948: LIST
51949: LIST
51950: LIST
51951: LIST
51952: LIST
51953: LIST
51954: LIST
51955: LIST
51956: LIST
51957: LIST
51958: LIST
51959: LIST
51960: LIST
51961: LIST
51962: LIST
51963: LIST
51964: LIST
51965: LIST
51966: LIST
51967: LIST
51968: LIST
51969: LIST
51970: LIST
51971: LIST
51972: LIST
51973: LIST
51974: LIST
51975: LIST
51976: LIST
51977: LIST
51978: LIST
51979: LIST
51980: LIST
51981: LIST
51982: LIST
51983: ST_TO_ADDR
51984: GO 51987
51986: POP
// if state > - 1 and state < 3 then
51987: LD_VAR 0 3
51991: PUSH
51992: LD_INT 1
51994: NEG
51995: GREATER
51996: PUSH
51997: LD_VAR 0 3
52001: PUSH
52002: LD_INT 3
52004: LESS
52005: AND
52006: IFFALSE 52063
// for i in result do
52008: LD_ADDR_VAR 0 5
52012: PUSH
52013: LD_VAR 0 4
52017: PUSH
52018: FOR_IN
52019: IFFALSE 52061
// if GetTech ( i , side ) <> state then
52021: LD_VAR 0 5
52025: PPUSH
52026: LD_VAR 0 1
52030: PPUSH
52031: CALL_OW 321
52035: PUSH
52036: LD_VAR 0 3
52040: NONEQUAL
52041: IFFALSE 52059
// result := result diff i ;
52043: LD_ADDR_VAR 0 4
52047: PUSH
52048: LD_VAR 0 4
52052: PUSH
52053: LD_VAR 0 5
52057: DIFF
52058: ST_TO_ADDR
52059: GO 52018
52061: POP
52062: POP
// end ;
52063: LD_VAR 0 4
52067: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
52068: LD_INT 0
52070: PPUSH
52071: PPUSH
52072: PPUSH
// result := true ;
52073: LD_ADDR_VAR 0 3
52077: PUSH
52078: LD_INT 1
52080: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
52081: LD_ADDR_VAR 0 5
52085: PUSH
52086: LD_VAR 0 2
52090: PPUSH
52091: CALL_OW 480
52095: ST_TO_ADDR
// if not tmp then
52096: LD_VAR 0 5
52100: NOT
52101: IFFALSE 52105
// exit ;
52103: GO 52154
// for i in tmp do
52105: LD_ADDR_VAR 0 4
52109: PUSH
52110: LD_VAR 0 5
52114: PUSH
52115: FOR_IN
52116: IFFALSE 52152
// if GetTech ( i , side ) <> state_researched then
52118: LD_VAR 0 4
52122: PPUSH
52123: LD_VAR 0 1
52127: PPUSH
52128: CALL_OW 321
52132: PUSH
52133: LD_INT 2
52135: NONEQUAL
52136: IFFALSE 52150
// begin result := false ;
52138: LD_ADDR_VAR 0 3
52142: PUSH
52143: LD_INT 0
52145: ST_TO_ADDR
// exit ;
52146: POP
52147: POP
52148: GO 52154
// end ;
52150: GO 52115
52152: POP
52153: POP
// end ;
52154: LD_VAR 0 3
52158: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
52159: LD_INT 0
52161: PPUSH
52162: PPUSH
52163: PPUSH
52164: PPUSH
52165: PPUSH
52166: PPUSH
52167: PPUSH
52168: PPUSH
52169: PPUSH
52170: PPUSH
52171: PPUSH
52172: PPUSH
52173: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
52174: LD_VAR 0 1
52178: NOT
52179: PUSH
52180: LD_VAR 0 1
52184: PPUSH
52185: CALL_OW 257
52189: PUSH
52190: LD_INT 9
52192: NONEQUAL
52193: OR
52194: IFFALSE 52198
// exit ;
52196: GO 52771
// side := GetSide ( unit ) ;
52198: LD_ADDR_VAR 0 9
52202: PUSH
52203: LD_VAR 0 1
52207: PPUSH
52208: CALL_OW 255
52212: ST_TO_ADDR
// tech_space := tech_spacanom ;
52213: LD_ADDR_VAR 0 12
52217: PUSH
52218: LD_INT 29
52220: ST_TO_ADDR
// tech_time := tech_taurad ;
52221: LD_ADDR_VAR 0 13
52225: PUSH
52226: LD_INT 28
52228: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
52229: LD_ADDR_VAR 0 11
52233: PUSH
52234: LD_VAR 0 1
52238: PPUSH
52239: CALL_OW 310
52243: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
52244: LD_VAR 0 11
52248: PPUSH
52249: CALL_OW 247
52253: PUSH
52254: LD_INT 2
52256: EQUAL
52257: IFFALSE 52261
// exit ;
52259: GO 52771
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
52261: LD_ADDR_VAR 0 8
52265: PUSH
52266: LD_INT 81
52268: PUSH
52269: LD_VAR 0 9
52273: PUSH
52274: EMPTY
52275: LIST
52276: LIST
52277: PUSH
52278: LD_INT 3
52280: PUSH
52281: LD_INT 21
52283: PUSH
52284: LD_INT 3
52286: PUSH
52287: EMPTY
52288: LIST
52289: LIST
52290: PUSH
52291: EMPTY
52292: LIST
52293: LIST
52294: PUSH
52295: EMPTY
52296: LIST
52297: LIST
52298: PPUSH
52299: CALL_OW 69
52303: ST_TO_ADDR
// if not tmp then
52304: LD_VAR 0 8
52308: NOT
52309: IFFALSE 52313
// exit ;
52311: GO 52771
// if in_unit then
52313: LD_VAR 0 11
52317: IFFALSE 52341
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
52319: LD_ADDR_VAR 0 10
52323: PUSH
52324: LD_VAR 0 8
52328: PPUSH
52329: LD_VAR 0 11
52333: PPUSH
52334: CALL_OW 74
52338: ST_TO_ADDR
52339: GO 52361
// enemy := NearestUnitToUnit ( tmp , unit ) ;
52341: LD_ADDR_VAR 0 10
52345: PUSH
52346: LD_VAR 0 8
52350: PPUSH
52351: LD_VAR 0 1
52355: PPUSH
52356: CALL_OW 74
52360: ST_TO_ADDR
// if not enemy then
52361: LD_VAR 0 10
52365: NOT
52366: IFFALSE 52370
// exit ;
52368: GO 52771
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
52370: LD_VAR 0 11
52374: PUSH
52375: LD_VAR 0 11
52379: PPUSH
52380: LD_VAR 0 10
52384: PPUSH
52385: CALL_OW 296
52389: PUSH
52390: LD_INT 13
52392: GREATER
52393: AND
52394: PUSH
52395: LD_VAR 0 1
52399: PPUSH
52400: LD_VAR 0 10
52404: PPUSH
52405: CALL_OW 296
52409: PUSH
52410: LD_INT 12
52412: GREATER
52413: OR
52414: IFFALSE 52418
// exit ;
52416: GO 52771
// missile := [ 1 ] ;
52418: LD_ADDR_VAR 0 14
52422: PUSH
52423: LD_INT 1
52425: PUSH
52426: EMPTY
52427: LIST
52428: ST_TO_ADDR
// if Researched ( side , tech_space ) then
52429: LD_VAR 0 9
52433: PPUSH
52434: LD_VAR 0 12
52438: PPUSH
52439: CALL_OW 325
52443: IFFALSE 52472
// missile := Insert ( missile , missile + 1 , 2 ) ;
52445: LD_ADDR_VAR 0 14
52449: PUSH
52450: LD_VAR 0 14
52454: PPUSH
52455: LD_VAR 0 14
52459: PUSH
52460: LD_INT 1
52462: PLUS
52463: PPUSH
52464: LD_INT 2
52466: PPUSH
52467: CALL_OW 2
52471: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
52472: LD_VAR 0 9
52476: PPUSH
52477: LD_VAR 0 13
52481: PPUSH
52482: CALL_OW 325
52486: PUSH
52487: LD_VAR 0 10
52491: PPUSH
52492: CALL_OW 255
52496: PPUSH
52497: LD_VAR 0 13
52501: PPUSH
52502: CALL_OW 325
52506: NOT
52507: AND
52508: IFFALSE 52537
// missile := Insert ( missile , missile + 1 , 3 ) ;
52510: LD_ADDR_VAR 0 14
52514: PUSH
52515: LD_VAR 0 14
52519: PPUSH
52520: LD_VAR 0 14
52524: PUSH
52525: LD_INT 1
52527: PLUS
52528: PPUSH
52529: LD_INT 3
52531: PPUSH
52532: CALL_OW 2
52536: ST_TO_ADDR
// if missile < 2 then
52537: LD_VAR 0 14
52541: PUSH
52542: LD_INT 2
52544: LESS
52545: IFFALSE 52549
// exit ;
52547: GO 52771
// x := GetX ( enemy ) ;
52549: LD_ADDR_VAR 0 4
52553: PUSH
52554: LD_VAR 0 10
52558: PPUSH
52559: CALL_OW 250
52563: ST_TO_ADDR
// y := GetY ( enemy ) ;
52564: LD_ADDR_VAR 0 5
52568: PUSH
52569: LD_VAR 0 10
52573: PPUSH
52574: CALL_OW 251
52578: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
52579: LD_ADDR_VAR 0 6
52583: PUSH
52584: LD_VAR 0 4
52588: PUSH
52589: LD_INT 1
52591: NEG
52592: PPUSH
52593: LD_INT 1
52595: PPUSH
52596: CALL_OW 12
52600: PLUS
52601: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
52602: LD_ADDR_VAR 0 7
52606: PUSH
52607: LD_VAR 0 5
52611: PUSH
52612: LD_INT 1
52614: NEG
52615: PPUSH
52616: LD_INT 1
52618: PPUSH
52619: CALL_OW 12
52623: PLUS
52624: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
52625: LD_VAR 0 6
52629: PPUSH
52630: LD_VAR 0 7
52634: PPUSH
52635: CALL_OW 488
52639: NOT
52640: IFFALSE 52662
// begin _x := x ;
52642: LD_ADDR_VAR 0 6
52646: PUSH
52647: LD_VAR 0 4
52651: ST_TO_ADDR
// _y := y ;
52652: LD_ADDR_VAR 0 7
52656: PUSH
52657: LD_VAR 0 5
52661: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
52662: LD_ADDR_VAR 0 3
52666: PUSH
52667: LD_INT 1
52669: PPUSH
52670: LD_VAR 0 14
52674: PPUSH
52675: CALL_OW 12
52679: ST_TO_ADDR
// case i of 1 :
52680: LD_VAR 0 3
52684: PUSH
52685: LD_INT 1
52687: DOUBLE
52688: EQUAL
52689: IFTRUE 52693
52691: GO 52710
52693: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
52694: LD_VAR 0 1
52698: PPUSH
52699: LD_VAR 0 10
52703: PPUSH
52704: CALL_OW 115
52708: GO 52771
52710: LD_INT 2
52712: DOUBLE
52713: EQUAL
52714: IFTRUE 52718
52716: GO 52740
52718: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
52719: LD_VAR 0 1
52723: PPUSH
52724: LD_VAR 0 6
52728: PPUSH
52729: LD_VAR 0 7
52733: PPUSH
52734: CALL_OW 153
52738: GO 52771
52740: LD_INT 3
52742: DOUBLE
52743: EQUAL
52744: IFTRUE 52748
52746: GO 52770
52748: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
52749: LD_VAR 0 1
52753: PPUSH
52754: LD_VAR 0 6
52758: PPUSH
52759: LD_VAR 0 7
52763: PPUSH
52764: CALL_OW 154
52768: GO 52771
52770: POP
// end ;
52771: LD_VAR 0 2
52775: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
52776: LD_INT 0
52778: PPUSH
52779: PPUSH
52780: PPUSH
52781: PPUSH
52782: PPUSH
52783: PPUSH
// if not unit or not building then
52784: LD_VAR 0 1
52788: NOT
52789: PUSH
52790: LD_VAR 0 2
52794: NOT
52795: OR
52796: IFFALSE 52800
// exit ;
52798: GO 52958
// x := GetX ( building ) ;
52800: LD_ADDR_VAR 0 5
52804: PUSH
52805: LD_VAR 0 2
52809: PPUSH
52810: CALL_OW 250
52814: ST_TO_ADDR
// y := GetY ( building ) ;
52815: LD_ADDR_VAR 0 6
52819: PUSH
52820: LD_VAR 0 2
52824: PPUSH
52825: CALL_OW 251
52829: ST_TO_ADDR
// for i = 0 to 5 do
52830: LD_ADDR_VAR 0 4
52834: PUSH
52835: DOUBLE
52836: LD_INT 0
52838: DEC
52839: ST_TO_ADDR
52840: LD_INT 5
52842: PUSH
52843: FOR_TO
52844: IFFALSE 52956
// begin _x := ShiftX ( x , i , 3 ) ;
52846: LD_ADDR_VAR 0 7
52850: PUSH
52851: LD_VAR 0 5
52855: PPUSH
52856: LD_VAR 0 4
52860: PPUSH
52861: LD_INT 3
52863: PPUSH
52864: CALL_OW 272
52868: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
52869: LD_ADDR_VAR 0 8
52873: PUSH
52874: LD_VAR 0 6
52878: PPUSH
52879: LD_VAR 0 4
52883: PPUSH
52884: LD_INT 3
52886: PPUSH
52887: CALL_OW 273
52891: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
52892: LD_VAR 0 7
52896: PPUSH
52897: LD_VAR 0 8
52901: PPUSH
52902: CALL_OW 488
52906: NOT
52907: IFFALSE 52911
// continue ;
52909: GO 52843
// if HexInfo ( _x , _y ) = 0 then
52911: LD_VAR 0 7
52915: PPUSH
52916: LD_VAR 0 8
52920: PPUSH
52921: CALL_OW 428
52925: PUSH
52926: LD_INT 0
52928: EQUAL
52929: IFFALSE 52954
// begin ComMoveXY ( unit , _x , _y ) ;
52931: LD_VAR 0 1
52935: PPUSH
52936: LD_VAR 0 7
52940: PPUSH
52941: LD_VAR 0 8
52945: PPUSH
52946: CALL_OW 111
// exit ;
52950: POP
52951: POP
52952: GO 52958
// end ; end ;
52954: GO 52843
52956: POP
52957: POP
// end ;
52958: LD_VAR 0 3
52962: RET
// export function ScanBase ( side , base_area ) ; begin
52963: LD_INT 0
52965: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
52966: LD_ADDR_VAR 0 3
52970: PUSH
52971: LD_VAR 0 2
52975: PPUSH
52976: LD_INT 81
52978: PUSH
52979: LD_VAR 0 1
52983: PUSH
52984: EMPTY
52985: LIST
52986: LIST
52987: PPUSH
52988: CALL_OW 70
52992: ST_TO_ADDR
// end ;
52993: LD_VAR 0 3
52997: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
52998: LD_INT 0
53000: PPUSH
53001: PPUSH
53002: PPUSH
53003: PPUSH
// result := false ;
53004: LD_ADDR_VAR 0 2
53008: PUSH
53009: LD_INT 0
53011: ST_TO_ADDR
// side := GetSide ( unit ) ;
53012: LD_ADDR_VAR 0 3
53016: PUSH
53017: LD_VAR 0 1
53021: PPUSH
53022: CALL_OW 255
53026: ST_TO_ADDR
// nat := GetNation ( unit ) ;
53027: LD_ADDR_VAR 0 4
53031: PUSH
53032: LD_VAR 0 1
53036: PPUSH
53037: CALL_OW 248
53041: ST_TO_ADDR
// case nat of 1 :
53042: LD_VAR 0 4
53046: PUSH
53047: LD_INT 1
53049: DOUBLE
53050: EQUAL
53051: IFTRUE 53055
53053: GO 53066
53055: POP
// tech := tech_lassight ; 2 :
53056: LD_ADDR_VAR 0 5
53060: PUSH
53061: LD_INT 12
53063: ST_TO_ADDR
53064: GO 53105
53066: LD_INT 2
53068: DOUBLE
53069: EQUAL
53070: IFTRUE 53074
53072: GO 53085
53074: POP
// tech := tech_mortar ; 3 :
53075: LD_ADDR_VAR 0 5
53079: PUSH
53080: LD_INT 41
53082: ST_TO_ADDR
53083: GO 53105
53085: LD_INT 3
53087: DOUBLE
53088: EQUAL
53089: IFTRUE 53093
53091: GO 53104
53093: POP
// tech := tech_bazooka ; end ;
53094: LD_ADDR_VAR 0 5
53098: PUSH
53099: LD_INT 44
53101: ST_TO_ADDR
53102: GO 53105
53104: POP
// if Researched ( side , tech ) then
53105: LD_VAR 0 3
53109: PPUSH
53110: LD_VAR 0 5
53114: PPUSH
53115: CALL_OW 325
53119: IFFALSE 53146
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
53121: LD_ADDR_VAR 0 2
53125: PUSH
53126: LD_INT 5
53128: PUSH
53129: LD_INT 8
53131: PUSH
53132: LD_INT 9
53134: PUSH
53135: EMPTY
53136: LIST
53137: LIST
53138: LIST
53139: PUSH
53140: LD_VAR 0 4
53144: ARRAY
53145: ST_TO_ADDR
// end ;
53146: LD_VAR 0 2
53150: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
53151: LD_INT 0
53153: PPUSH
53154: PPUSH
53155: PPUSH
// if not mines then
53156: LD_VAR 0 2
53160: NOT
53161: IFFALSE 53165
// exit ;
53163: GO 53309
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
53165: LD_ADDR_VAR 0 5
53169: PUSH
53170: LD_INT 81
53172: PUSH
53173: LD_VAR 0 1
53177: PUSH
53178: EMPTY
53179: LIST
53180: LIST
53181: PUSH
53182: LD_INT 3
53184: PUSH
53185: LD_INT 21
53187: PUSH
53188: LD_INT 3
53190: PUSH
53191: EMPTY
53192: LIST
53193: LIST
53194: PUSH
53195: EMPTY
53196: LIST
53197: LIST
53198: PUSH
53199: EMPTY
53200: LIST
53201: LIST
53202: PPUSH
53203: CALL_OW 69
53207: ST_TO_ADDR
// for i in mines do
53208: LD_ADDR_VAR 0 4
53212: PUSH
53213: LD_VAR 0 2
53217: PUSH
53218: FOR_IN
53219: IFFALSE 53307
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
53221: LD_VAR 0 4
53225: PUSH
53226: LD_INT 1
53228: ARRAY
53229: PPUSH
53230: LD_VAR 0 4
53234: PUSH
53235: LD_INT 2
53237: ARRAY
53238: PPUSH
53239: CALL_OW 458
53243: NOT
53244: IFFALSE 53248
// continue ;
53246: GO 53218
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
53248: LD_VAR 0 4
53252: PUSH
53253: LD_INT 1
53255: ARRAY
53256: PPUSH
53257: LD_VAR 0 4
53261: PUSH
53262: LD_INT 2
53264: ARRAY
53265: PPUSH
53266: CALL_OW 428
53270: PUSH
53271: LD_VAR 0 5
53275: IN
53276: IFFALSE 53305
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
53278: LD_VAR 0 4
53282: PUSH
53283: LD_INT 1
53285: ARRAY
53286: PPUSH
53287: LD_VAR 0 4
53291: PUSH
53292: LD_INT 2
53294: ARRAY
53295: PPUSH
53296: LD_VAR 0 1
53300: PPUSH
53301: CALL_OW 456
// end ;
53305: GO 53218
53307: POP
53308: POP
// end ;
53309: LD_VAR 0 3
53313: RET
// export function Count ( array ) ; var i ; begin
53314: LD_INT 0
53316: PPUSH
53317: PPUSH
// result := 0 ;
53318: LD_ADDR_VAR 0 2
53322: PUSH
53323: LD_INT 0
53325: ST_TO_ADDR
// for i in array do
53326: LD_ADDR_VAR 0 3
53330: PUSH
53331: LD_VAR 0 1
53335: PUSH
53336: FOR_IN
53337: IFFALSE 53361
// if i then
53339: LD_VAR 0 3
53343: IFFALSE 53359
// result := result + 1 ;
53345: LD_ADDR_VAR 0 2
53349: PUSH
53350: LD_VAR 0 2
53354: PUSH
53355: LD_INT 1
53357: PLUS
53358: ST_TO_ADDR
53359: GO 53336
53361: POP
53362: POP
// end ;
53363: LD_VAR 0 2
53367: RET
// export function IsEmpty ( building ) ; begin
53368: LD_INT 0
53370: PPUSH
// if not building then
53371: LD_VAR 0 1
53375: NOT
53376: IFFALSE 53380
// exit ;
53378: GO 53423
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
53380: LD_ADDR_VAR 0 2
53384: PUSH
53385: LD_VAR 0 1
53389: PUSH
53390: LD_INT 22
53392: PUSH
53393: LD_VAR 0 1
53397: PPUSH
53398: CALL_OW 255
53402: PUSH
53403: EMPTY
53404: LIST
53405: LIST
53406: PUSH
53407: LD_INT 58
53409: PUSH
53410: EMPTY
53411: LIST
53412: PUSH
53413: EMPTY
53414: LIST
53415: LIST
53416: PPUSH
53417: CALL_OW 69
53421: IN
53422: ST_TO_ADDR
// end ;
53423: LD_VAR 0 2
53427: RET
// export function IsNotFull ( building ) ; begin
53428: LD_INT 0
53430: PPUSH
// if not building then
53431: LD_VAR 0 1
53435: NOT
53436: IFFALSE 53440
// exit ;
53438: GO 53459
// result := UnitsInside ( building ) < 6 ;
53440: LD_ADDR_VAR 0 2
53444: PUSH
53445: LD_VAR 0 1
53449: PPUSH
53450: CALL_OW 313
53454: PUSH
53455: LD_INT 6
53457: LESS
53458: ST_TO_ADDR
// end ;
53459: LD_VAR 0 2
53463: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
53464: LD_INT 0
53466: PPUSH
53467: PPUSH
53468: PPUSH
53469: PPUSH
// tmp := [ ] ;
53470: LD_ADDR_VAR 0 3
53474: PUSH
53475: EMPTY
53476: ST_TO_ADDR
// list := [ ] ;
53477: LD_ADDR_VAR 0 5
53481: PUSH
53482: EMPTY
53483: ST_TO_ADDR
// for i = 16 to 25 do
53484: LD_ADDR_VAR 0 4
53488: PUSH
53489: DOUBLE
53490: LD_INT 16
53492: DEC
53493: ST_TO_ADDR
53494: LD_INT 25
53496: PUSH
53497: FOR_TO
53498: IFFALSE 53571
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
53500: LD_ADDR_VAR 0 3
53504: PUSH
53505: LD_VAR 0 3
53509: PUSH
53510: LD_INT 22
53512: PUSH
53513: LD_VAR 0 1
53517: PPUSH
53518: CALL_OW 255
53522: PUSH
53523: EMPTY
53524: LIST
53525: LIST
53526: PUSH
53527: LD_INT 91
53529: PUSH
53530: LD_VAR 0 1
53534: PUSH
53535: LD_INT 6
53537: PUSH
53538: EMPTY
53539: LIST
53540: LIST
53541: LIST
53542: PUSH
53543: LD_INT 30
53545: PUSH
53546: LD_VAR 0 4
53550: PUSH
53551: EMPTY
53552: LIST
53553: LIST
53554: PUSH
53555: EMPTY
53556: LIST
53557: LIST
53558: LIST
53559: PUSH
53560: EMPTY
53561: LIST
53562: PPUSH
53563: CALL_OW 69
53567: ADD
53568: ST_TO_ADDR
53569: GO 53497
53571: POP
53572: POP
// for i = 1 to tmp do
53573: LD_ADDR_VAR 0 4
53577: PUSH
53578: DOUBLE
53579: LD_INT 1
53581: DEC
53582: ST_TO_ADDR
53583: LD_VAR 0 3
53587: PUSH
53588: FOR_TO
53589: IFFALSE 53677
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
53591: LD_ADDR_VAR 0 5
53595: PUSH
53596: LD_VAR 0 5
53600: PUSH
53601: LD_VAR 0 3
53605: PUSH
53606: LD_VAR 0 4
53610: ARRAY
53611: PPUSH
53612: CALL_OW 266
53616: PUSH
53617: LD_VAR 0 3
53621: PUSH
53622: LD_VAR 0 4
53626: ARRAY
53627: PPUSH
53628: CALL_OW 250
53632: PUSH
53633: LD_VAR 0 3
53637: PUSH
53638: LD_VAR 0 4
53642: ARRAY
53643: PPUSH
53644: CALL_OW 251
53648: PUSH
53649: LD_VAR 0 3
53653: PUSH
53654: LD_VAR 0 4
53658: ARRAY
53659: PPUSH
53660: CALL_OW 254
53664: PUSH
53665: EMPTY
53666: LIST
53667: LIST
53668: LIST
53669: LIST
53670: PUSH
53671: EMPTY
53672: LIST
53673: ADD
53674: ST_TO_ADDR
53675: GO 53588
53677: POP
53678: POP
// result := list ;
53679: LD_ADDR_VAR 0 2
53683: PUSH
53684: LD_VAR 0 5
53688: ST_TO_ADDR
// end ;
53689: LD_VAR 0 2
53693: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
53694: LD_INT 0
53696: PPUSH
53697: PPUSH
53698: PPUSH
53699: PPUSH
53700: PPUSH
53701: PPUSH
53702: PPUSH
// if not factory then
53703: LD_VAR 0 1
53707: NOT
53708: IFFALSE 53712
// exit ;
53710: GO 54305
// if control = control_apeman then
53712: LD_VAR 0 4
53716: PUSH
53717: LD_INT 5
53719: EQUAL
53720: IFFALSE 53829
// begin tmp := UnitsInside ( factory ) ;
53722: LD_ADDR_VAR 0 8
53726: PUSH
53727: LD_VAR 0 1
53731: PPUSH
53732: CALL_OW 313
53736: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
53737: LD_VAR 0 8
53741: PPUSH
53742: LD_INT 25
53744: PUSH
53745: LD_INT 12
53747: PUSH
53748: EMPTY
53749: LIST
53750: LIST
53751: PPUSH
53752: CALL_OW 72
53756: NOT
53757: IFFALSE 53767
// control := control_manual ;
53759: LD_ADDR_VAR 0 4
53763: PUSH
53764: LD_INT 1
53766: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
53767: LD_ADDR_VAR 0 8
53771: PUSH
53772: LD_VAR 0 1
53776: PPUSH
53777: CALL 53464 0 1
53781: ST_TO_ADDR
// if tmp then
53782: LD_VAR 0 8
53786: IFFALSE 53829
// begin for i in tmp do
53788: LD_ADDR_VAR 0 7
53792: PUSH
53793: LD_VAR 0 8
53797: PUSH
53798: FOR_IN
53799: IFFALSE 53827
// if i [ 1 ] = b_ext_radio then
53801: LD_VAR 0 7
53805: PUSH
53806: LD_INT 1
53808: ARRAY
53809: PUSH
53810: LD_INT 22
53812: EQUAL
53813: IFFALSE 53825
// begin control := control_remote ;
53815: LD_ADDR_VAR 0 4
53819: PUSH
53820: LD_INT 2
53822: ST_TO_ADDR
// break ;
53823: GO 53827
// end ;
53825: GO 53798
53827: POP
53828: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
53829: LD_VAR 0 1
53833: PPUSH
53834: LD_VAR 0 2
53838: PPUSH
53839: LD_VAR 0 3
53843: PPUSH
53844: LD_VAR 0 4
53848: PPUSH
53849: LD_VAR 0 5
53853: PPUSH
53854: CALL_OW 448
53858: IFFALSE 53893
// begin result := [ chassis , engine , control , weapon ] ;
53860: LD_ADDR_VAR 0 6
53864: PUSH
53865: LD_VAR 0 2
53869: PUSH
53870: LD_VAR 0 3
53874: PUSH
53875: LD_VAR 0 4
53879: PUSH
53880: LD_VAR 0 5
53884: PUSH
53885: EMPTY
53886: LIST
53887: LIST
53888: LIST
53889: LIST
53890: ST_TO_ADDR
// exit ;
53891: GO 54305
// end ; _chassis := AvailableChassisList ( factory ) ;
53893: LD_ADDR_VAR 0 9
53897: PUSH
53898: LD_VAR 0 1
53902: PPUSH
53903: CALL_OW 475
53907: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
53908: LD_ADDR_VAR 0 11
53912: PUSH
53913: LD_VAR 0 1
53917: PPUSH
53918: CALL_OW 476
53922: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
53923: LD_ADDR_VAR 0 12
53927: PUSH
53928: LD_VAR 0 1
53932: PPUSH
53933: CALL_OW 477
53937: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
53938: LD_ADDR_VAR 0 10
53942: PUSH
53943: LD_VAR 0 1
53947: PPUSH
53948: CALL_OW 478
53952: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
53953: LD_VAR 0 9
53957: NOT
53958: PUSH
53959: LD_VAR 0 11
53963: NOT
53964: OR
53965: PUSH
53966: LD_VAR 0 12
53970: NOT
53971: OR
53972: PUSH
53973: LD_VAR 0 10
53977: NOT
53978: OR
53979: IFFALSE 54014
// begin result := [ chassis , engine , control , weapon ] ;
53981: LD_ADDR_VAR 0 6
53985: PUSH
53986: LD_VAR 0 2
53990: PUSH
53991: LD_VAR 0 3
53995: PUSH
53996: LD_VAR 0 4
54000: PUSH
54001: LD_VAR 0 5
54005: PUSH
54006: EMPTY
54007: LIST
54008: LIST
54009: LIST
54010: LIST
54011: ST_TO_ADDR
// exit ;
54012: GO 54305
// end ; if not chassis in _chassis then
54014: LD_VAR 0 2
54018: PUSH
54019: LD_VAR 0 9
54023: IN
54024: NOT
54025: IFFALSE 54051
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
54027: LD_ADDR_VAR 0 2
54031: PUSH
54032: LD_VAR 0 9
54036: PUSH
54037: LD_INT 1
54039: PPUSH
54040: LD_VAR 0 9
54044: PPUSH
54045: CALL_OW 12
54049: ARRAY
54050: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
54051: LD_VAR 0 2
54055: PPUSH
54056: LD_VAR 0 3
54060: PPUSH
54061: CALL 54310 0 2
54065: NOT
54066: IFFALSE 54125
// repeat engine := _engine [ 1 ] ;
54068: LD_ADDR_VAR 0 3
54072: PUSH
54073: LD_VAR 0 11
54077: PUSH
54078: LD_INT 1
54080: ARRAY
54081: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
54082: LD_ADDR_VAR 0 11
54086: PUSH
54087: LD_VAR 0 11
54091: PPUSH
54092: LD_INT 1
54094: PPUSH
54095: CALL_OW 3
54099: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
54100: LD_VAR 0 2
54104: PPUSH
54105: LD_VAR 0 3
54109: PPUSH
54110: CALL 54310 0 2
54114: PUSH
54115: LD_VAR 0 11
54119: PUSH
54120: EMPTY
54121: EQUAL
54122: OR
54123: IFFALSE 54068
// if not control in _control then
54125: LD_VAR 0 4
54129: PUSH
54130: LD_VAR 0 12
54134: IN
54135: NOT
54136: IFFALSE 54162
// control := _control [ rand ( 1 , _control ) ] ;
54138: LD_ADDR_VAR 0 4
54142: PUSH
54143: LD_VAR 0 12
54147: PUSH
54148: LD_INT 1
54150: PPUSH
54151: LD_VAR 0 12
54155: PPUSH
54156: CALL_OW 12
54160: ARRAY
54161: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
54162: LD_VAR 0 2
54166: PPUSH
54167: LD_VAR 0 5
54171: PPUSH
54172: CALL 54530 0 2
54176: NOT
54177: IFFALSE 54236
// repeat weapon := _weapon [ 1 ] ;
54179: LD_ADDR_VAR 0 5
54183: PUSH
54184: LD_VAR 0 10
54188: PUSH
54189: LD_INT 1
54191: ARRAY
54192: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
54193: LD_ADDR_VAR 0 10
54197: PUSH
54198: LD_VAR 0 10
54202: PPUSH
54203: LD_INT 1
54205: PPUSH
54206: CALL_OW 3
54210: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
54211: LD_VAR 0 2
54215: PPUSH
54216: LD_VAR 0 5
54220: PPUSH
54221: CALL 54530 0 2
54225: PUSH
54226: LD_VAR 0 10
54230: PUSH
54231: EMPTY
54232: EQUAL
54233: OR
54234: IFFALSE 54179
// result := [ ] ;
54236: LD_ADDR_VAR 0 6
54240: PUSH
54241: EMPTY
54242: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
54243: LD_VAR 0 1
54247: PPUSH
54248: LD_VAR 0 2
54252: PPUSH
54253: LD_VAR 0 3
54257: PPUSH
54258: LD_VAR 0 4
54262: PPUSH
54263: LD_VAR 0 5
54267: PPUSH
54268: CALL_OW 448
54272: IFFALSE 54305
// result := [ chassis , engine , control , weapon ] ;
54274: LD_ADDR_VAR 0 6
54278: PUSH
54279: LD_VAR 0 2
54283: PUSH
54284: LD_VAR 0 3
54288: PUSH
54289: LD_VAR 0 4
54293: PUSH
54294: LD_VAR 0 5
54298: PUSH
54299: EMPTY
54300: LIST
54301: LIST
54302: LIST
54303: LIST
54304: ST_TO_ADDR
// end ;
54305: LD_VAR 0 6
54309: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
54310: LD_INT 0
54312: PPUSH
// if not chassis or not engine then
54313: LD_VAR 0 1
54317: NOT
54318: PUSH
54319: LD_VAR 0 2
54323: NOT
54324: OR
54325: IFFALSE 54329
// exit ;
54327: GO 54525
// case engine of engine_solar :
54329: LD_VAR 0 2
54333: PUSH
54334: LD_INT 2
54336: DOUBLE
54337: EQUAL
54338: IFTRUE 54342
54340: GO 54380
54342: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
54343: LD_ADDR_VAR 0 3
54347: PUSH
54348: LD_INT 11
54350: PUSH
54351: LD_INT 12
54353: PUSH
54354: LD_INT 13
54356: PUSH
54357: LD_INT 14
54359: PUSH
54360: LD_INT 1
54362: PUSH
54363: LD_INT 2
54365: PUSH
54366: LD_INT 3
54368: PUSH
54369: EMPTY
54370: LIST
54371: LIST
54372: LIST
54373: LIST
54374: LIST
54375: LIST
54376: LIST
54377: ST_TO_ADDR
54378: GO 54509
54380: LD_INT 1
54382: DOUBLE
54383: EQUAL
54384: IFTRUE 54388
54386: GO 54450
54388: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
54389: LD_ADDR_VAR 0 3
54393: PUSH
54394: LD_INT 11
54396: PUSH
54397: LD_INT 12
54399: PUSH
54400: LD_INT 13
54402: PUSH
54403: LD_INT 14
54405: PUSH
54406: LD_INT 1
54408: PUSH
54409: LD_INT 2
54411: PUSH
54412: LD_INT 3
54414: PUSH
54415: LD_INT 4
54417: PUSH
54418: LD_INT 5
54420: PUSH
54421: LD_INT 21
54423: PUSH
54424: LD_INT 23
54426: PUSH
54427: LD_INT 22
54429: PUSH
54430: LD_INT 24
54432: PUSH
54433: EMPTY
54434: LIST
54435: LIST
54436: LIST
54437: LIST
54438: LIST
54439: LIST
54440: LIST
54441: LIST
54442: LIST
54443: LIST
54444: LIST
54445: LIST
54446: LIST
54447: ST_TO_ADDR
54448: GO 54509
54450: LD_INT 3
54452: DOUBLE
54453: EQUAL
54454: IFTRUE 54458
54456: GO 54508
54458: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
54459: LD_ADDR_VAR 0 3
54463: PUSH
54464: LD_INT 13
54466: PUSH
54467: LD_INT 14
54469: PUSH
54470: LD_INT 2
54472: PUSH
54473: LD_INT 3
54475: PUSH
54476: LD_INT 4
54478: PUSH
54479: LD_INT 5
54481: PUSH
54482: LD_INT 21
54484: PUSH
54485: LD_INT 22
54487: PUSH
54488: LD_INT 23
54490: PUSH
54491: LD_INT 24
54493: PUSH
54494: EMPTY
54495: LIST
54496: LIST
54497: LIST
54498: LIST
54499: LIST
54500: LIST
54501: LIST
54502: LIST
54503: LIST
54504: LIST
54505: ST_TO_ADDR
54506: GO 54509
54508: POP
// result := ( chassis in result ) ;
54509: LD_ADDR_VAR 0 3
54513: PUSH
54514: LD_VAR 0 1
54518: PUSH
54519: LD_VAR 0 3
54523: IN
54524: ST_TO_ADDR
// end ;
54525: LD_VAR 0 3
54529: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
54530: LD_INT 0
54532: PPUSH
// if not chassis or not weapon then
54533: LD_VAR 0 1
54537: NOT
54538: PUSH
54539: LD_VAR 0 2
54543: NOT
54544: OR
54545: IFFALSE 54549
// exit ;
54547: GO 55611
// case weapon of us_machine_gun :
54549: LD_VAR 0 2
54553: PUSH
54554: LD_INT 2
54556: DOUBLE
54557: EQUAL
54558: IFTRUE 54562
54560: GO 54592
54562: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
54563: LD_ADDR_VAR 0 3
54567: PUSH
54568: LD_INT 1
54570: PUSH
54571: LD_INT 2
54573: PUSH
54574: LD_INT 3
54576: PUSH
54577: LD_INT 4
54579: PUSH
54580: LD_INT 5
54582: PUSH
54583: EMPTY
54584: LIST
54585: LIST
54586: LIST
54587: LIST
54588: LIST
54589: ST_TO_ADDR
54590: GO 55595
54592: LD_INT 3
54594: DOUBLE
54595: EQUAL
54596: IFTRUE 54600
54598: GO 54630
54600: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
54601: LD_ADDR_VAR 0 3
54605: PUSH
54606: LD_INT 1
54608: PUSH
54609: LD_INT 2
54611: PUSH
54612: LD_INT 3
54614: PUSH
54615: LD_INT 4
54617: PUSH
54618: LD_INT 5
54620: PUSH
54621: EMPTY
54622: LIST
54623: LIST
54624: LIST
54625: LIST
54626: LIST
54627: ST_TO_ADDR
54628: GO 55595
54630: LD_INT 11
54632: DOUBLE
54633: EQUAL
54634: IFTRUE 54638
54636: GO 54668
54638: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
54639: LD_ADDR_VAR 0 3
54643: PUSH
54644: LD_INT 1
54646: PUSH
54647: LD_INT 2
54649: PUSH
54650: LD_INT 3
54652: PUSH
54653: LD_INT 4
54655: PUSH
54656: LD_INT 5
54658: PUSH
54659: EMPTY
54660: LIST
54661: LIST
54662: LIST
54663: LIST
54664: LIST
54665: ST_TO_ADDR
54666: GO 55595
54668: LD_INT 4
54670: DOUBLE
54671: EQUAL
54672: IFTRUE 54676
54674: GO 54702
54676: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
54677: LD_ADDR_VAR 0 3
54681: PUSH
54682: LD_INT 2
54684: PUSH
54685: LD_INT 3
54687: PUSH
54688: LD_INT 4
54690: PUSH
54691: LD_INT 5
54693: PUSH
54694: EMPTY
54695: LIST
54696: LIST
54697: LIST
54698: LIST
54699: ST_TO_ADDR
54700: GO 55595
54702: LD_INT 5
54704: DOUBLE
54705: EQUAL
54706: IFTRUE 54710
54708: GO 54736
54710: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
54711: LD_ADDR_VAR 0 3
54715: PUSH
54716: LD_INT 2
54718: PUSH
54719: LD_INT 3
54721: PUSH
54722: LD_INT 4
54724: PUSH
54725: LD_INT 5
54727: PUSH
54728: EMPTY
54729: LIST
54730: LIST
54731: LIST
54732: LIST
54733: ST_TO_ADDR
54734: GO 55595
54736: LD_INT 9
54738: DOUBLE
54739: EQUAL
54740: IFTRUE 54744
54742: GO 54770
54744: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
54745: LD_ADDR_VAR 0 3
54749: PUSH
54750: LD_INT 2
54752: PUSH
54753: LD_INT 3
54755: PUSH
54756: LD_INT 4
54758: PUSH
54759: LD_INT 5
54761: PUSH
54762: EMPTY
54763: LIST
54764: LIST
54765: LIST
54766: LIST
54767: ST_TO_ADDR
54768: GO 55595
54770: LD_INT 7
54772: DOUBLE
54773: EQUAL
54774: IFTRUE 54778
54776: GO 54804
54778: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
54779: LD_ADDR_VAR 0 3
54783: PUSH
54784: LD_INT 2
54786: PUSH
54787: LD_INT 3
54789: PUSH
54790: LD_INT 4
54792: PUSH
54793: LD_INT 5
54795: PUSH
54796: EMPTY
54797: LIST
54798: LIST
54799: LIST
54800: LIST
54801: ST_TO_ADDR
54802: GO 55595
54804: LD_INT 12
54806: DOUBLE
54807: EQUAL
54808: IFTRUE 54812
54810: GO 54838
54812: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
54813: LD_ADDR_VAR 0 3
54817: PUSH
54818: LD_INT 2
54820: PUSH
54821: LD_INT 3
54823: PUSH
54824: LD_INT 4
54826: PUSH
54827: LD_INT 5
54829: PUSH
54830: EMPTY
54831: LIST
54832: LIST
54833: LIST
54834: LIST
54835: ST_TO_ADDR
54836: GO 55595
54838: LD_INT 13
54840: DOUBLE
54841: EQUAL
54842: IFTRUE 54846
54844: GO 54872
54846: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
54847: LD_ADDR_VAR 0 3
54851: PUSH
54852: LD_INT 2
54854: PUSH
54855: LD_INT 3
54857: PUSH
54858: LD_INT 4
54860: PUSH
54861: LD_INT 5
54863: PUSH
54864: EMPTY
54865: LIST
54866: LIST
54867: LIST
54868: LIST
54869: ST_TO_ADDR
54870: GO 55595
54872: LD_INT 14
54874: DOUBLE
54875: EQUAL
54876: IFTRUE 54880
54878: GO 54898
54880: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
54881: LD_ADDR_VAR 0 3
54885: PUSH
54886: LD_INT 4
54888: PUSH
54889: LD_INT 5
54891: PUSH
54892: EMPTY
54893: LIST
54894: LIST
54895: ST_TO_ADDR
54896: GO 55595
54898: LD_INT 6
54900: DOUBLE
54901: EQUAL
54902: IFTRUE 54906
54904: GO 54924
54906: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
54907: LD_ADDR_VAR 0 3
54911: PUSH
54912: LD_INT 4
54914: PUSH
54915: LD_INT 5
54917: PUSH
54918: EMPTY
54919: LIST
54920: LIST
54921: ST_TO_ADDR
54922: GO 55595
54924: LD_INT 10
54926: DOUBLE
54927: EQUAL
54928: IFTRUE 54932
54930: GO 54950
54932: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
54933: LD_ADDR_VAR 0 3
54937: PUSH
54938: LD_INT 4
54940: PUSH
54941: LD_INT 5
54943: PUSH
54944: EMPTY
54945: LIST
54946: LIST
54947: ST_TO_ADDR
54948: GO 55595
54950: LD_INT 22
54952: DOUBLE
54953: EQUAL
54954: IFTRUE 54958
54956: GO 54984
54958: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
54959: LD_ADDR_VAR 0 3
54963: PUSH
54964: LD_INT 11
54966: PUSH
54967: LD_INT 12
54969: PUSH
54970: LD_INT 13
54972: PUSH
54973: LD_INT 14
54975: PUSH
54976: EMPTY
54977: LIST
54978: LIST
54979: LIST
54980: LIST
54981: ST_TO_ADDR
54982: GO 55595
54984: LD_INT 23
54986: DOUBLE
54987: EQUAL
54988: IFTRUE 54992
54990: GO 55018
54992: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
54993: LD_ADDR_VAR 0 3
54997: PUSH
54998: LD_INT 11
55000: PUSH
55001: LD_INT 12
55003: PUSH
55004: LD_INT 13
55006: PUSH
55007: LD_INT 14
55009: PUSH
55010: EMPTY
55011: LIST
55012: LIST
55013: LIST
55014: LIST
55015: ST_TO_ADDR
55016: GO 55595
55018: LD_INT 24
55020: DOUBLE
55021: EQUAL
55022: IFTRUE 55026
55024: GO 55052
55026: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
55027: LD_ADDR_VAR 0 3
55031: PUSH
55032: LD_INT 11
55034: PUSH
55035: LD_INT 12
55037: PUSH
55038: LD_INT 13
55040: PUSH
55041: LD_INT 14
55043: PUSH
55044: EMPTY
55045: LIST
55046: LIST
55047: LIST
55048: LIST
55049: ST_TO_ADDR
55050: GO 55595
55052: LD_INT 30
55054: DOUBLE
55055: EQUAL
55056: IFTRUE 55060
55058: GO 55086
55060: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
55061: LD_ADDR_VAR 0 3
55065: PUSH
55066: LD_INT 11
55068: PUSH
55069: LD_INT 12
55071: PUSH
55072: LD_INT 13
55074: PUSH
55075: LD_INT 14
55077: PUSH
55078: EMPTY
55079: LIST
55080: LIST
55081: LIST
55082: LIST
55083: ST_TO_ADDR
55084: GO 55595
55086: LD_INT 25
55088: DOUBLE
55089: EQUAL
55090: IFTRUE 55094
55092: GO 55112
55094: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
55095: LD_ADDR_VAR 0 3
55099: PUSH
55100: LD_INT 13
55102: PUSH
55103: LD_INT 14
55105: PUSH
55106: EMPTY
55107: LIST
55108: LIST
55109: ST_TO_ADDR
55110: GO 55595
55112: LD_INT 27
55114: DOUBLE
55115: EQUAL
55116: IFTRUE 55120
55118: GO 55138
55120: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
55121: LD_ADDR_VAR 0 3
55125: PUSH
55126: LD_INT 13
55128: PUSH
55129: LD_INT 14
55131: PUSH
55132: EMPTY
55133: LIST
55134: LIST
55135: ST_TO_ADDR
55136: GO 55595
55138: LD_EXP 77
55142: DOUBLE
55143: EQUAL
55144: IFTRUE 55148
55146: GO 55174
55148: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
55149: LD_ADDR_VAR 0 3
55153: PUSH
55154: LD_INT 11
55156: PUSH
55157: LD_INT 12
55159: PUSH
55160: LD_INT 13
55162: PUSH
55163: LD_INT 14
55165: PUSH
55166: EMPTY
55167: LIST
55168: LIST
55169: LIST
55170: LIST
55171: ST_TO_ADDR
55172: GO 55595
55174: LD_INT 28
55176: DOUBLE
55177: EQUAL
55178: IFTRUE 55182
55180: GO 55200
55182: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
55183: LD_ADDR_VAR 0 3
55187: PUSH
55188: LD_INT 13
55190: PUSH
55191: LD_INT 14
55193: PUSH
55194: EMPTY
55195: LIST
55196: LIST
55197: ST_TO_ADDR
55198: GO 55595
55200: LD_INT 29
55202: DOUBLE
55203: EQUAL
55204: IFTRUE 55208
55206: GO 55226
55208: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
55209: LD_ADDR_VAR 0 3
55213: PUSH
55214: LD_INT 13
55216: PUSH
55217: LD_INT 14
55219: PUSH
55220: EMPTY
55221: LIST
55222: LIST
55223: ST_TO_ADDR
55224: GO 55595
55226: LD_INT 31
55228: DOUBLE
55229: EQUAL
55230: IFTRUE 55234
55232: GO 55252
55234: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
55235: LD_ADDR_VAR 0 3
55239: PUSH
55240: LD_INT 13
55242: PUSH
55243: LD_INT 14
55245: PUSH
55246: EMPTY
55247: LIST
55248: LIST
55249: ST_TO_ADDR
55250: GO 55595
55252: LD_INT 26
55254: DOUBLE
55255: EQUAL
55256: IFTRUE 55260
55258: GO 55278
55260: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
55261: LD_ADDR_VAR 0 3
55265: PUSH
55266: LD_INT 13
55268: PUSH
55269: LD_INT 14
55271: PUSH
55272: EMPTY
55273: LIST
55274: LIST
55275: ST_TO_ADDR
55276: GO 55595
55278: LD_INT 42
55280: DOUBLE
55281: EQUAL
55282: IFTRUE 55286
55284: GO 55312
55286: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
55287: LD_ADDR_VAR 0 3
55291: PUSH
55292: LD_INT 21
55294: PUSH
55295: LD_INT 22
55297: PUSH
55298: LD_INT 23
55300: PUSH
55301: LD_INT 24
55303: PUSH
55304: EMPTY
55305: LIST
55306: LIST
55307: LIST
55308: LIST
55309: ST_TO_ADDR
55310: GO 55595
55312: LD_INT 43
55314: DOUBLE
55315: EQUAL
55316: IFTRUE 55320
55318: GO 55346
55320: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
55321: LD_ADDR_VAR 0 3
55325: PUSH
55326: LD_INT 21
55328: PUSH
55329: LD_INT 22
55331: PUSH
55332: LD_INT 23
55334: PUSH
55335: LD_INT 24
55337: PUSH
55338: EMPTY
55339: LIST
55340: LIST
55341: LIST
55342: LIST
55343: ST_TO_ADDR
55344: GO 55595
55346: LD_INT 44
55348: DOUBLE
55349: EQUAL
55350: IFTRUE 55354
55352: GO 55380
55354: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
55355: LD_ADDR_VAR 0 3
55359: PUSH
55360: LD_INT 21
55362: PUSH
55363: LD_INT 22
55365: PUSH
55366: LD_INT 23
55368: PUSH
55369: LD_INT 24
55371: PUSH
55372: EMPTY
55373: LIST
55374: LIST
55375: LIST
55376: LIST
55377: ST_TO_ADDR
55378: GO 55595
55380: LD_INT 45
55382: DOUBLE
55383: EQUAL
55384: IFTRUE 55388
55386: GO 55414
55388: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
55389: LD_ADDR_VAR 0 3
55393: PUSH
55394: LD_INT 21
55396: PUSH
55397: LD_INT 22
55399: PUSH
55400: LD_INT 23
55402: PUSH
55403: LD_INT 24
55405: PUSH
55406: EMPTY
55407: LIST
55408: LIST
55409: LIST
55410: LIST
55411: ST_TO_ADDR
55412: GO 55595
55414: LD_INT 49
55416: DOUBLE
55417: EQUAL
55418: IFTRUE 55422
55420: GO 55448
55422: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
55423: LD_ADDR_VAR 0 3
55427: PUSH
55428: LD_INT 21
55430: PUSH
55431: LD_INT 22
55433: PUSH
55434: LD_INT 23
55436: PUSH
55437: LD_INT 24
55439: PUSH
55440: EMPTY
55441: LIST
55442: LIST
55443: LIST
55444: LIST
55445: ST_TO_ADDR
55446: GO 55595
55448: LD_INT 51
55450: DOUBLE
55451: EQUAL
55452: IFTRUE 55456
55454: GO 55482
55456: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
55457: LD_ADDR_VAR 0 3
55461: PUSH
55462: LD_INT 21
55464: PUSH
55465: LD_INT 22
55467: PUSH
55468: LD_INT 23
55470: PUSH
55471: LD_INT 24
55473: PUSH
55474: EMPTY
55475: LIST
55476: LIST
55477: LIST
55478: LIST
55479: ST_TO_ADDR
55480: GO 55595
55482: LD_INT 52
55484: DOUBLE
55485: EQUAL
55486: IFTRUE 55490
55488: GO 55516
55490: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
55491: LD_ADDR_VAR 0 3
55495: PUSH
55496: LD_INT 21
55498: PUSH
55499: LD_INT 22
55501: PUSH
55502: LD_INT 23
55504: PUSH
55505: LD_INT 24
55507: PUSH
55508: EMPTY
55509: LIST
55510: LIST
55511: LIST
55512: LIST
55513: ST_TO_ADDR
55514: GO 55595
55516: LD_INT 53
55518: DOUBLE
55519: EQUAL
55520: IFTRUE 55524
55522: GO 55542
55524: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
55525: LD_ADDR_VAR 0 3
55529: PUSH
55530: LD_INT 23
55532: PUSH
55533: LD_INT 24
55535: PUSH
55536: EMPTY
55537: LIST
55538: LIST
55539: ST_TO_ADDR
55540: GO 55595
55542: LD_INT 46
55544: DOUBLE
55545: EQUAL
55546: IFTRUE 55550
55548: GO 55568
55550: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
55551: LD_ADDR_VAR 0 3
55555: PUSH
55556: LD_INT 23
55558: PUSH
55559: LD_INT 24
55561: PUSH
55562: EMPTY
55563: LIST
55564: LIST
55565: ST_TO_ADDR
55566: GO 55595
55568: LD_INT 47
55570: DOUBLE
55571: EQUAL
55572: IFTRUE 55576
55574: GO 55594
55576: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
55577: LD_ADDR_VAR 0 3
55581: PUSH
55582: LD_INT 23
55584: PUSH
55585: LD_INT 24
55587: PUSH
55588: EMPTY
55589: LIST
55590: LIST
55591: ST_TO_ADDR
55592: GO 55595
55594: POP
// result := ( chassis in result ) ;
55595: LD_ADDR_VAR 0 3
55599: PUSH
55600: LD_VAR 0 1
55604: PUSH
55605: LD_VAR 0 3
55609: IN
55610: ST_TO_ADDR
// end ;
55611: LD_VAR 0 3
55615: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
55616: LD_INT 0
55618: PPUSH
55619: PPUSH
55620: PPUSH
55621: PPUSH
55622: PPUSH
55623: PPUSH
55624: PPUSH
// result := array ;
55625: LD_ADDR_VAR 0 5
55629: PUSH
55630: LD_VAR 0 1
55634: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
55635: LD_VAR 0 1
55639: NOT
55640: PUSH
55641: LD_VAR 0 2
55645: NOT
55646: OR
55647: PUSH
55648: LD_VAR 0 3
55652: NOT
55653: OR
55654: PUSH
55655: LD_VAR 0 2
55659: PUSH
55660: LD_VAR 0 1
55664: GREATER
55665: OR
55666: PUSH
55667: LD_VAR 0 3
55671: PUSH
55672: LD_VAR 0 1
55676: GREATER
55677: OR
55678: IFFALSE 55682
// exit ;
55680: GO 55978
// if direction then
55682: LD_VAR 0 4
55686: IFFALSE 55750
// begin d := 1 ;
55688: LD_ADDR_VAR 0 9
55692: PUSH
55693: LD_INT 1
55695: ST_TO_ADDR
// if i_from > i_to then
55696: LD_VAR 0 2
55700: PUSH
55701: LD_VAR 0 3
55705: GREATER
55706: IFFALSE 55732
// length := ( array - i_from ) + i_to else
55708: LD_ADDR_VAR 0 11
55712: PUSH
55713: LD_VAR 0 1
55717: PUSH
55718: LD_VAR 0 2
55722: MINUS
55723: PUSH
55724: LD_VAR 0 3
55728: PLUS
55729: ST_TO_ADDR
55730: GO 55748
// length := i_to - i_from ;
55732: LD_ADDR_VAR 0 11
55736: PUSH
55737: LD_VAR 0 3
55741: PUSH
55742: LD_VAR 0 2
55746: MINUS
55747: ST_TO_ADDR
// end else
55748: GO 55811
// begin d := - 1 ;
55750: LD_ADDR_VAR 0 9
55754: PUSH
55755: LD_INT 1
55757: NEG
55758: ST_TO_ADDR
// if i_from > i_to then
55759: LD_VAR 0 2
55763: PUSH
55764: LD_VAR 0 3
55768: GREATER
55769: IFFALSE 55789
// length := i_from - i_to else
55771: LD_ADDR_VAR 0 11
55775: PUSH
55776: LD_VAR 0 2
55780: PUSH
55781: LD_VAR 0 3
55785: MINUS
55786: ST_TO_ADDR
55787: GO 55811
// length := ( array - i_to ) + i_from ;
55789: LD_ADDR_VAR 0 11
55793: PUSH
55794: LD_VAR 0 1
55798: PUSH
55799: LD_VAR 0 3
55803: MINUS
55804: PUSH
55805: LD_VAR 0 2
55809: PLUS
55810: ST_TO_ADDR
// end ; if not length then
55811: LD_VAR 0 11
55815: NOT
55816: IFFALSE 55820
// exit ;
55818: GO 55978
// tmp := array ;
55820: LD_ADDR_VAR 0 10
55824: PUSH
55825: LD_VAR 0 1
55829: ST_TO_ADDR
// for i = 1 to length do
55830: LD_ADDR_VAR 0 6
55834: PUSH
55835: DOUBLE
55836: LD_INT 1
55838: DEC
55839: ST_TO_ADDR
55840: LD_VAR 0 11
55844: PUSH
55845: FOR_TO
55846: IFFALSE 55966
// begin for j = 1 to array do
55848: LD_ADDR_VAR 0 7
55852: PUSH
55853: DOUBLE
55854: LD_INT 1
55856: DEC
55857: ST_TO_ADDR
55858: LD_VAR 0 1
55862: PUSH
55863: FOR_TO
55864: IFFALSE 55952
// begin k := j + d ;
55866: LD_ADDR_VAR 0 8
55870: PUSH
55871: LD_VAR 0 7
55875: PUSH
55876: LD_VAR 0 9
55880: PLUS
55881: ST_TO_ADDR
// if k > array then
55882: LD_VAR 0 8
55886: PUSH
55887: LD_VAR 0 1
55891: GREATER
55892: IFFALSE 55902
// k := 1 ;
55894: LD_ADDR_VAR 0 8
55898: PUSH
55899: LD_INT 1
55901: ST_TO_ADDR
// if not k then
55902: LD_VAR 0 8
55906: NOT
55907: IFFALSE 55919
// k := array ;
55909: LD_ADDR_VAR 0 8
55913: PUSH
55914: LD_VAR 0 1
55918: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
55919: LD_ADDR_VAR 0 10
55923: PUSH
55924: LD_VAR 0 10
55928: PPUSH
55929: LD_VAR 0 8
55933: PPUSH
55934: LD_VAR 0 1
55938: PUSH
55939: LD_VAR 0 7
55943: ARRAY
55944: PPUSH
55945: CALL_OW 1
55949: ST_TO_ADDR
// end ;
55950: GO 55863
55952: POP
55953: POP
// array := tmp ;
55954: LD_ADDR_VAR 0 1
55958: PUSH
55959: LD_VAR 0 10
55963: ST_TO_ADDR
// end ;
55964: GO 55845
55966: POP
55967: POP
// result := array ;
55968: LD_ADDR_VAR 0 5
55972: PUSH
55973: LD_VAR 0 1
55977: ST_TO_ADDR
// end ;
55978: LD_VAR 0 5
55982: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
55983: LD_INT 0
55985: PPUSH
55986: PPUSH
// result := 0 ;
55987: LD_ADDR_VAR 0 3
55991: PUSH
55992: LD_INT 0
55994: ST_TO_ADDR
// if not array or not value in array then
55995: LD_VAR 0 1
55999: NOT
56000: PUSH
56001: LD_VAR 0 2
56005: PUSH
56006: LD_VAR 0 1
56010: IN
56011: NOT
56012: OR
56013: IFFALSE 56017
// exit ;
56015: GO 56071
// for i = 1 to array do
56017: LD_ADDR_VAR 0 4
56021: PUSH
56022: DOUBLE
56023: LD_INT 1
56025: DEC
56026: ST_TO_ADDR
56027: LD_VAR 0 1
56031: PUSH
56032: FOR_TO
56033: IFFALSE 56069
// if value = array [ i ] then
56035: LD_VAR 0 2
56039: PUSH
56040: LD_VAR 0 1
56044: PUSH
56045: LD_VAR 0 4
56049: ARRAY
56050: EQUAL
56051: IFFALSE 56067
// begin result := i ;
56053: LD_ADDR_VAR 0 3
56057: PUSH
56058: LD_VAR 0 4
56062: ST_TO_ADDR
// exit ;
56063: POP
56064: POP
56065: GO 56071
// end ;
56067: GO 56032
56069: POP
56070: POP
// end ;
56071: LD_VAR 0 3
56075: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
56076: LD_INT 0
56078: PPUSH
// vc_chassis := chassis ;
56079: LD_ADDR_OWVAR 37
56083: PUSH
56084: LD_VAR 0 1
56088: ST_TO_ADDR
// vc_engine := engine ;
56089: LD_ADDR_OWVAR 39
56093: PUSH
56094: LD_VAR 0 2
56098: ST_TO_ADDR
// vc_control := control ;
56099: LD_ADDR_OWVAR 38
56103: PUSH
56104: LD_VAR 0 3
56108: ST_TO_ADDR
// vc_weapon := weapon ;
56109: LD_ADDR_OWVAR 40
56113: PUSH
56114: LD_VAR 0 4
56118: ST_TO_ADDR
// vc_fuel_battery := fuel ;
56119: LD_ADDR_OWVAR 41
56123: PUSH
56124: LD_VAR 0 5
56128: ST_TO_ADDR
// end ;
56129: LD_VAR 0 6
56133: RET
// export function WantPlant ( unit ) ; var task ; begin
56134: LD_INT 0
56136: PPUSH
56137: PPUSH
// result := false ;
56138: LD_ADDR_VAR 0 2
56142: PUSH
56143: LD_INT 0
56145: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
56146: LD_ADDR_VAR 0 3
56150: PUSH
56151: LD_VAR 0 1
56155: PPUSH
56156: CALL_OW 437
56160: ST_TO_ADDR
// if task then
56161: LD_VAR 0 3
56165: IFFALSE 56193
// if task [ 1 ] [ 1 ] = p then
56167: LD_VAR 0 3
56171: PUSH
56172: LD_INT 1
56174: ARRAY
56175: PUSH
56176: LD_INT 1
56178: ARRAY
56179: PUSH
56180: LD_STRING p
56182: EQUAL
56183: IFFALSE 56193
// result := true ;
56185: LD_ADDR_VAR 0 2
56189: PUSH
56190: LD_INT 1
56192: ST_TO_ADDR
// end ;
56193: LD_VAR 0 2
56197: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
56198: LD_INT 0
56200: PPUSH
56201: PPUSH
56202: PPUSH
56203: PPUSH
// if pos < 1 then
56204: LD_VAR 0 2
56208: PUSH
56209: LD_INT 1
56211: LESS
56212: IFFALSE 56216
// exit ;
56214: GO 56519
// if pos = 1 then
56216: LD_VAR 0 2
56220: PUSH
56221: LD_INT 1
56223: EQUAL
56224: IFFALSE 56257
// result := Replace ( arr , pos [ 1 ] , value ) else
56226: LD_ADDR_VAR 0 4
56230: PUSH
56231: LD_VAR 0 1
56235: PPUSH
56236: LD_VAR 0 2
56240: PUSH
56241: LD_INT 1
56243: ARRAY
56244: PPUSH
56245: LD_VAR 0 3
56249: PPUSH
56250: CALL_OW 1
56254: ST_TO_ADDR
56255: GO 56519
// begin tmp := arr ;
56257: LD_ADDR_VAR 0 6
56261: PUSH
56262: LD_VAR 0 1
56266: ST_TO_ADDR
// s_arr := [ tmp ] ;
56267: LD_ADDR_VAR 0 7
56271: PUSH
56272: LD_VAR 0 6
56276: PUSH
56277: EMPTY
56278: LIST
56279: ST_TO_ADDR
// for i = 1 to pos - 1 do
56280: LD_ADDR_VAR 0 5
56284: PUSH
56285: DOUBLE
56286: LD_INT 1
56288: DEC
56289: ST_TO_ADDR
56290: LD_VAR 0 2
56294: PUSH
56295: LD_INT 1
56297: MINUS
56298: PUSH
56299: FOR_TO
56300: IFFALSE 56345
// begin tmp := tmp [ pos [ i ] ] ;
56302: LD_ADDR_VAR 0 6
56306: PUSH
56307: LD_VAR 0 6
56311: PUSH
56312: LD_VAR 0 2
56316: PUSH
56317: LD_VAR 0 5
56321: ARRAY
56322: ARRAY
56323: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
56324: LD_ADDR_VAR 0 7
56328: PUSH
56329: LD_VAR 0 7
56333: PUSH
56334: LD_VAR 0 6
56338: PUSH
56339: EMPTY
56340: LIST
56341: ADD
56342: ST_TO_ADDR
// end ;
56343: GO 56299
56345: POP
56346: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
56347: LD_ADDR_VAR 0 6
56351: PUSH
56352: LD_VAR 0 6
56356: PPUSH
56357: LD_VAR 0 2
56361: PUSH
56362: LD_VAR 0 2
56366: ARRAY
56367: PPUSH
56368: LD_VAR 0 3
56372: PPUSH
56373: CALL_OW 1
56377: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
56378: LD_ADDR_VAR 0 7
56382: PUSH
56383: LD_VAR 0 7
56387: PPUSH
56388: LD_VAR 0 7
56392: PPUSH
56393: LD_VAR 0 6
56397: PPUSH
56398: CALL_OW 1
56402: ST_TO_ADDR
// for i = s_arr downto 2 do
56403: LD_ADDR_VAR 0 5
56407: PUSH
56408: DOUBLE
56409: LD_VAR 0 7
56413: INC
56414: ST_TO_ADDR
56415: LD_INT 2
56417: PUSH
56418: FOR_DOWNTO
56419: IFFALSE 56503
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
56421: LD_ADDR_VAR 0 6
56425: PUSH
56426: LD_VAR 0 7
56430: PUSH
56431: LD_VAR 0 5
56435: PUSH
56436: LD_INT 1
56438: MINUS
56439: ARRAY
56440: PPUSH
56441: LD_VAR 0 2
56445: PUSH
56446: LD_VAR 0 5
56450: PUSH
56451: LD_INT 1
56453: MINUS
56454: ARRAY
56455: PPUSH
56456: LD_VAR 0 7
56460: PUSH
56461: LD_VAR 0 5
56465: ARRAY
56466: PPUSH
56467: CALL_OW 1
56471: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
56472: LD_ADDR_VAR 0 7
56476: PUSH
56477: LD_VAR 0 7
56481: PPUSH
56482: LD_VAR 0 5
56486: PUSH
56487: LD_INT 1
56489: MINUS
56490: PPUSH
56491: LD_VAR 0 6
56495: PPUSH
56496: CALL_OW 1
56500: ST_TO_ADDR
// end ;
56501: GO 56418
56503: POP
56504: POP
// result := s_arr [ 1 ] ;
56505: LD_ADDR_VAR 0 4
56509: PUSH
56510: LD_VAR 0 7
56514: PUSH
56515: LD_INT 1
56517: ARRAY
56518: ST_TO_ADDR
// end ; end ;
56519: LD_VAR 0 4
56523: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
56524: LD_INT 0
56526: PPUSH
56527: PPUSH
// if not list then
56528: LD_VAR 0 1
56532: NOT
56533: IFFALSE 56537
// exit ;
56535: GO 56628
// i := list [ pos1 ] ;
56537: LD_ADDR_VAR 0 5
56541: PUSH
56542: LD_VAR 0 1
56546: PUSH
56547: LD_VAR 0 2
56551: ARRAY
56552: ST_TO_ADDR
// if not i then
56553: LD_VAR 0 5
56557: NOT
56558: IFFALSE 56562
// exit ;
56560: GO 56628
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
56562: LD_ADDR_VAR 0 1
56566: PUSH
56567: LD_VAR 0 1
56571: PPUSH
56572: LD_VAR 0 2
56576: PPUSH
56577: LD_VAR 0 1
56581: PUSH
56582: LD_VAR 0 3
56586: ARRAY
56587: PPUSH
56588: CALL_OW 1
56592: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
56593: LD_ADDR_VAR 0 1
56597: PUSH
56598: LD_VAR 0 1
56602: PPUSH
56603: LD_VAR 0 3
56607: PPUSH
56608: LD_VAR 0 5
56612: PPUSH
56613: CALL_OW 1
56617: ST_TO_ADDR
// result := list ;
56618: LD_ADDR_VAR 0 4
56622: PUSH
56623: LD_VAR 0 1
56627: ST_TO_ADDR
// end ;
56628: LD_VAR 0 4
56632: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
56633: LD_INT 0
56635: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
56636: LD_ADDR_VAR 0 5
56640: PUSH
56641: LD_VAR 0 1
56645: PPUSH
56646: CALL_OW 250
56650: PPUSH
56651: LD_VAR 0 1
56655: PPUSH
56656: CALL_OW 251
56660: PPUSH
56661: LD_VAR 0 2
56665: PPUSH
56666: LD_VAR 0 3
56670: PPUSH
56671: LD_VAR 0 4
56675: PPUSH
56676: CALL 56686 0 5
56680: ST_TO_ADDR
// end ;
56681: LD_VAR 0 5
56685: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
56686: LD_INT 0
56688: PPUSH
56689: PPUSH
56690: PPUSH
56691: PPUSH
// if not list then
56692: LD_VAR 0 3
56696: NOT
56697: IFFALSE 56701
// exit ;
56699: GO 57089
// result := [ ] ;
56701: LD_ADDR_VAR 0 6
56705: PUSH
56706: EMPTY
56707: ST_TO_ADDR
// for i in list do
56708: LD_ADDR_VAR 0 7
56712: PUSH
56713: LD_VAR 0 3
56717: PUSH
56718: FOR_IN
56719: IFFALSE 56921
// begin tmp := GetDistUnitXY ( i , x , y ) ;
56721: LD_ADDR_VAR 0 9
56725: PUSH
56726: LD_VAR 0 7
56730: PPUSH
56731: LD_VAR 0 1
56735: PPUSH
56736: LD_VAR 0 2
56740: PPUSH
56741: CALL_OW 297
56745: ST_TO_ADDR
// if not result then
56746: LD_VAR 0 6
56750: NOT
56751: IFFALSE 56777
// result := [ [ i , tmp ] ] else
56753: LD_ADDR_VAR 0 6
56757: PUSH
56758: LD_VAR 0 7
56762: PUSH
56763: LD_VAR 0 9
56767: PUSH
56768: EMPTY
56769: LIST
56770: LIST
56771: PUSH
56772: EMPTY
56773: LIST
56774: ST_TO_ADDR
56775: GO 56919
// begin if result [ result ] [ 2 ] < tmp then
56777: LD_VAR 0 6
56781: PUSH
56782: LD_VAR 0 6
56786: ARRAY
56787: PUSH
56788: LD_INT 2
56790: ARRAY
56791: PUSH
56792: LD_VAR 0 9
56796: LESS
56797: IFFALSE 56839
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
56799: LD_ADDR_VAR 0 6
56803: PUSH
56804: LD_VAR 0 6
56808: PPUSH
56809: LD_VAR 0 6
56813: PUSH
56814: LD_INT 1
56816: PLUS
56817: PPUSH
56818: LD_VAR 0 7
56822: PUSH
56823: LD_VAR 0 9
56827: PUSH
56828: EMPTY
56829: LIST
56830: LIST
56831: PPUSH
56832: CALL_OW 2
56836: ST_TO_ADDR
56837: GO 56919
// for j = 1 to result do
56839: LD_ADDR_VAR 0 8
56843: PUSH
56844: DOUBLE
56845: LD_INT 1
56847: DEC
56848: ST_TO_ADDR
56849: LD_VAR 0 6
56853: PUSH
56854: FOR_TO
56855: IFFALSE 56917
// begin if tmp < result [ j ] [ 2 ] then
56857: LD_VAR 0 9
56861: PUSH
56862: LD_VAR 0 6
56866: PUSH
56867: LD_VAR 0 8
56871: ARRAY
56872: PUSH
56873: LD_INT 2
56875: ARRAY
56876: LESS
56877: IFFALSE 56915
// begin result := Insert ( result , j , [ i , tmp ] ) ;
56879: LD_ADDR_VAR 0 6
56883: PUSH
56884: LD_VAR 0 6
56888: PPUSH
56889: LD_VAR 0 8
56893: PPUSH
56894: LD_VAR 0 7
56898: PUSH
56899: LD_VAR 0 9
56903: PUSH
56904: EMPTY
56905: LIST
56906: LIST
56907: PPUSH
56908: CALL_OW 2
56912: ST_TO_ADDR
// break ;
56913: GO 56917
// end ; end ;
56915: GO 56854
56917: POP
56918: POP
// end ; end ;
56919: GO 56718
56921: POP
56922: POP
// if result and not asc then
56923: LD_VAR 0 6
56927: PUSH
56928: LD_VAR 0 4
56932: NOT
56933: AND
56934: IFFALSE 57009
// begin tmp := result ;
56936: LD_ADDR_VAR 0 9
56940: PUSH
56941: LD_VAR 0 6
56945: ST_TO_ADDR
// for i = tmp downto 1 do
56946: LD_ADDR_VAR 0 7
56950: PUSH
56951: DOUBLE
56952: LD_VAR 0 9
56956: INC
56957: ST_TO_ADDR
56958: LD_INT 1
56960: PUSH
56961: FOR_DOWNTO
56962: IFFALSE 57007
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
56964: LD_ADDR_VAR 0 6
56968: PUSH
56969: LD_VAR 0 6
56973: PPUSH
56974: LD_VAR 0 9
56978: PUSH
56979: LD_VAR 0 7
56983: MINUS
56984: PUSH
56985: LD_INT 1
56987: PLUS
56988: PPUSH
56989: LD_VAR 0 9
56993: PUSH
56994: LD_VAR 0 7
56998: ARRAY
56999: PPUSH
57000: CALL_OW 1
57004: ST_TO_ADDR
57005: GO 56961
57007: POP
57008: POP
// end ; tmp := [ ] ;
57009: LD_ADDR_VAR 0 9
57013: PUSH
57014: EMPTY
57015: ST_TO_ADDR
// if mode then
57016: LD_VAR 0 5
57020: IFFALSE 57089
// begin for i = 1 to result do
57022: LD_ADDR_VAR 0 7
57026: PUSH
57027: DOUBLE
57028: LD_INT 1
57030: DEC
57031: ST_TO_ADDR
57032: LD_VAR 0 6
57036: PUSH
57037: FOR_TO
57038: IFFALSE 57077
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
57040: LD_ADDR_VAR 0 9
57044: PUSH
57045: LD_VAR 0 9
57049: PPUSH
57050: LD_VAR 0 7
57054: PPUSH
57055: LD_VAR 0 6
57059: PUSH
57060: LD_VAR 0 7
57064: ARRAY
57065: PUSH
57066: LD_INT 1
57068: ARRAY
57069: PPUSH
57070: CALL_OW 1
57074: ST_TO_ADDR
57075: GO 57037
57077: POP
57078: POP
// result := tmp ;
57079: LD_ADDR_VAR 0 6
57083: PUSH
57084: LD_VAR 0 9
57088: ST_TO_ADDR
// end ; end ;
57089: LD_VAR 0 6
57093: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
57094: LD_INT 0
57096: PPUSH
57097: PPUSH
57098: PPUSH
57099: PPUSH
57100: PPUSH
57101: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
57102: LD_ADDR_VAR 0 5
57106: PUSH
57107: LD_INT 0
57109: PUSH
57110: LD_INT 0
57112: PUSH
57113: LD_INT 0
57115: PUSH
57116: EMPTY
57117: PUSH
57118: EMPTY
57119: LIST
57120: LIST
57121: LIST
57122: LIST
57123: ST_TO_ADDR
// if not x or not y then
57124: LD_VAR 0 2
57128: NOT
57129: PUSH
57130: LD_VAR 0 3
57134: NOT
57135: OR
57136: IFFALSE 57140
// exit ;
57138: GO 58792
// if not range then
57140: LD_VAR 0 4
57144: NOT
57145: IFFALSE 57155
// range := 10 ;
57147: LD_ADDR_VAR 0 4
57151: PUSH
57152: LD_INT 10
57154: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
57155: LD_ADDR_VAR 0 8
57159: PUSH
57160: LD_INT 81
57162: PUSH
57163: LD_VAR 0 1
57167: PUSH
57168: EMPTY
57169: LIST
57170: LIST
57171: PUSH
57172: LD_INT 92
57174: PUSH
57175: LD_VAR 0 2
57179: PUSH
57180: LD_VAR 0 3
57184: PUSH
57185: LD_VAR 0 4
57189: PUSH
57190: EMPTY
57191: LIST
57192: LIST
57193: LIST
57194: LIST
57195: PUSH
57196: LD_INT 3
57198: PUSH
57199: LD_INT 21
57201: PUSH
57202: LD_INT 3
57204: PUSH
57205: EMPTY
57206: LIST
57207: LIST
57208: PUSH
57209: EMPTY
57210: LIST
57211: LIST
57212: PUSH
57213: EMPTY
57214: LIST
57215: LIST
57216: LIST
57217: PPUSH
57218: CALL_OW 69
57222: ST_TO_ADDR
// if not tmp then
57223: LD_VAR 0 8
57227: NOT
57228: IFFALSE 57232
// exit ;
57230: GO 58792
// for i in tmp do
57232: LD_ADDR_VAR 0 6
57236: PUSH
57237: LD_VAR 0 8
57241: PUSH
57242: FOR_IN
57243: IFFALSE 58767
// begin points := [ 0 , 0 , 0 ] ;
57245: LD_ADDR_VAR 0 9
57249: PUSH
57250: LD_INT 0
57252: PUSH
57253: LD_INT 0
57255: PUSH
57256: LD_INT 0
57258: PUSH
57259: EMPTY
57260: LIST
57261: LIST
57262: LIST
57263: ST_TO_ADDR
// bpoints := 1 ;
57264: LD_ADDR_VAR 0 10
57268: PUSH
57269: LD_INT 1
57271: ST_TO_ADDR
// case GetType ( i ) of unit_human :
57272: LD_VAR 0 6
57276: PPUSH
57277: CALL_OW 247
57281: PUSH
57282: LD_INT 1
57284: DOUBLE
57285: EQUAL
57286: IFTRUE 57290
57288: GO 57868
57290: POP
// begin if GetClass ( i ) = 1 then
57291: LD_VAR 0 6
57295: PPUSH
57296: CALL_OW 257
57300: PUSH
57301: LD_INT 1
57303: EQUAL
57304: IFFALSE 57325
// points := [ 10 , 5 , 3 ] ;
57306: LD_ADDR_VAR 0 9
57310: PUSH
57311: LD_INT 10
57313: PUSH
57314: LD_INT 5
57316: PUSH
57317: LD_INT 3
57319: PUSH
57320: EMPTY
57321: LIST
57322: LIST
57323: LIST
57324: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
57325: LD_VAR 0 6
57329: PPUSH
57330: CALL_OW 257
57334: PUSH
57335: LD_INT 2
57337: PUSH
57338: LD_INT 3
57340: PUSH
57341: LD_INT 4
57343: PUSH
57344: EMPTY
57345: LIST
57346: LIST
57347: LIST
57348: IN
57349: IFFALSE 57370
// points := [ 3 , 2 , 1 ] ;
57351: LD_ADDR_VAR 0 9
57355: PUSH
57356: LD_INT 3
57358: PUSH
57359: LD_INT 2
57361: PUSH
57362: LD_INT 1
57364: PUSH
57365: EMPTY
57366: LIST
57367: LIST
57368: LIST
57369: ST_TO_ADDR
// if GetClass ( i ) = 5 then
57370: LD_VAR 0 6
57374: PPUSH
57375: CALL_OW 257
57379: PUSH
57380: LD_INT 5
57382: EQUAL
57383: IFFALSE 57404
// points := [ 130 , 5 , 2 ] ;
57385: LD_ADDR_VAR 0 9
57389: PUSH
57390: LD_INT 130
57392: PUSH
57393: LD_INT 5
57395: PUSH
57396: LD_INT 2
57398: PUSH
57399: EMPTY
57400: LIST
57401: LIST
57402: LIST
57403: ST_TO_ADDR
// if GetClass ( i ) = 8 then
57404: LD_VAR 0 6
57408: PPUSH
57409: CALL_OW 257
57413: PUSH
57414: LD_INT 8
57416: EQUAL
57417: IFFALSE 57438
// points := [ 35 , 35 , 30 ] ;
57419: LD_ADDR_VAR 0 9
57423: PUSH
57424: LD_INT 35
57426: PUSH
57427: LD_INT 35
57429: PUSH
57430: LD_INT 30
57432: PUSH
57433: EMPTY
57434: LIST
57435: LIST
57436: LIST
57437: ST_TO_ADDR
// if GetClass ( i ) = 9 then
57438: LD_VAR 0 6
57442: PPUSH
57443: CALL_OW 257
57447: PUSH
57448: LD_INT 9
57450: EQUAL
57451: IFFALSE 57472
// points := [ 20 , 55 , 40 ] ;
57453: LD_ADDR_VAR 0 9
57457: PUSH
57458: LD_INT 20
57460: PUSH
57461: LD_INT 55
57463: PUSH
57464: LD_INT 40
57466: PUSH
57467: EMPTY
57468: LIST
57469: LIST
57470: LIST
57471: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
57472: LD_VAR 0 6
57476: PPUSH
57477: CALL_OW 257
57481: PUSH
57482: LD_INT 12
57484: PUSH
57485: LD_INT 16
57487: PUSH
57488: EMPTY
57489: LIST
57490: LIST
57491: IN
57492: IFFALSE 57513
// points := [ 5 , 3 , 2 ] ;
57494: LD_ADDR_VAR 0 9
57498: PUSH
57499: LD_INT 5
57501: PUSH
57502: LD_INT 3
57504: PUSH
57505: LD_INT 2
57507: PUSH
57508: EMPTY
57509: LIST
57510: LIST
57511: LIST
57512: ST_TO_ADDR
// if GetClass ( i ) = 17 then
57513: LD_VAR 0 6
57517: PPUSH
57518: CALL_OW 257
57522: PUSH
57523: LD_INT 17
57525: EQUAL
57526: IFFALSE 57547
// points := [ 100 , 50 , 75 ] ;
57528: LD_ADDR_VAR 0 9
57532: PUSH
57533: LD_INT 100
57535: PUSH
57536: LD_INT 50
57538: PUSH
57539: LD_INT 75
57541: PUSH
57542: EMPTY
57543: LIST
57544: LIST
57545: LIST
57546: ST_TO_ADDR
// if GetClass ( i ) = 15 then
57547: LD_VAR 0 6
57551: PPUSH
57552: CALL_OW 257
57556: PUSH
57557: LD_INT 15
57559: EQUAL
57560: IFFALSE 57581
// points := [ 10 , 5 , 3 ] ;
57562: LD_ADDR_VAR 0 9
57566: PUSH
57567: LD_INT 10
57569: PUSH
57570: LD_INT 5
57572: PUSH
57573: LD_INT 3
57575: PUSH
57576: EMPTY
57577: LIST
57578: LIST
57579: LIST
57580: ST_TO_ADDR
// if GetClass ( i ) = 14 then
57581: LD_VAR 0 6
57585: PPUSH
57586: CALL_OW 257
57590: PUSH
57591: LD_INT 14
57593: EQUAL
57594: IFFALSE 57615
// points := [ 10 , 0 , 0 ] ;
57596: LD_ADDR_VAR 0 9
57600: PUSH
57601: LD_INT 10
57603: PUSH
57604: LD_INT 0
57606: PUSH
57607: LD_INT 0
57609: PUSH
57610: EMPTY
57611: LIST
57612: LIST
57613: LIST
57614: ST_TO_ADDR
// if GetClass ( i ) = 11 then
57615: LD_VAR 0 6
57619: PPUSH
57620: CALL_OW 257
57624: PUSH
57625: LD_INT 11
57627: EQUAL
57628: IFFALSE 57649
// points := [ 30 , 10 , 5 ] ;
57630: LD_ADDR_VAR 0 9
57634: PUSH
57635: LD_INT 30
57637: PUSH
57638: LD_INT 10
57640: PUSH
57641: LD_INT 5
57643: PUSH
57644: EMPTY
57645: LIST
57646: LIST
57647: LIST
57648: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
57649: LD_VAR 0 1
57653: PPUSH
57654: LD_INT 5
57656: PPUSH
57657: CALL_OW 321
57661: PUSH
57662: LD_INT 2
57664: EQUAL
57665: IFFALSE 57682
// bpoints := bpoints * 1.8 ;
57667: LD_ADDR_VAR 0 10
57671: PUSH
57672: LD_VAR 0 10
57676: PUSH
57677: LD_REAL  1.80000000000000E+0000
57680: MUL
57681: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
57682: LD_VAR 0 6
57686: PPUSH
57687: CALL_OW 257
57691: PUSH
57692: LD_INT 1
57694: PUSH
57695: LD_INT 2
57697: PUSH
57698: LD_INT 3
57700: PUSH
57701: LD_INT 4
57703: PUSH
57704: EMPTY
57705: LIST
57706: LIST
57707: LIST
57708: LIST
57709: IN
57710: PUSH
57711: LD_VAR 0 1
57715: PPUSH
57716: LD_INT 51
57718: PPUSH
57719: CALL_OW 321
57723: PUSH
57724: LD_INT 2
57726: EQUAL
57727: AND
57728: IFFALSE 57745
// bpoints := bpoints * 1.2 ;
57730: LD_ADDR_VAR 0 10
57734: PUSH
57735: LD_VAR 0 10
57739: PUSH
57740: LD_REAL  1.20000000000000E+0000
57743: MUL
57744: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
57745: LD_VAR 0 6
57749: PPUSH
57750: CALL_OW 257
57754: PUSH
57755: LD_INT 5
57757: PUSH
57758: LD_INT 7
57760: PUSH
57761: LD_INT 9
57763: PUSH
57764: EMPTY
57765: LIST
57766: LIST
57767: LIST
57768: IN
57769: PUSH
57770: LD_VAR 0 1
57774: PPUSH
57775: LD_INT 52
57777: PPUSH
57778: CALL_OW 321
57782: PUSH
57783: LD_INT 2
57785: EQUAL
57786: AND
57787: IFFALSE 57804
// bpoints := bpoints * 1.5 ;
57789: LD_ADDR_VAR 0 10
57793: PUSH
57794: LD_VAR 0 10
57798: PUSH
57799: LD_REAL  1.50000000000000E+0000
57802: MUL
57803: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
57804: LD_VAR 0 1
57808: PPUSH
57809: LD_INT 66
57811: PPUSH
57812: CALL_OW 321
57816: PUSH
57817: LD_INT 2
57819: EQUAL
57820: IFFALSE 57837
// bpoints := bpoints * 1.1 ;
57822: LD_ADDR_VAR 0 10
57826: PUSH
57827: LD_VAR 0 10
57831: PUSH
57832: LD_REAL  1.10000000000000E+0000
57835: MUL
57836: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
57837: LD_ADDR_VAR 0 10
57841: PUSH
57842: LD_VAR 0 10
57846: PUSH
57847: LD_VAR 0 6
57851: PPUSH
57852: LD_INT 1
57854: PPUSH
57855: CALL_OW 259
57859: PUSH
57860: LD_REAL  1.15000000000000E+0000
57863: MUL
57864: MUL
57865: ST_TO_ADDR
// end ; unit_vehicle :
57866: GO 58696
57868: LD_INT 2
57870: DOUBLE
57871: EQUAL
57872: IFTRUE 57876
57874: GO 58684
57876: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
57877: LD_VAR 0 6
57881: PPUSH
57882: CALL_OW 264
57886: PUSH
57887: LD_INT 2
57889: PUSH
57890: LD_INT 42
57892: PUSH
57893: LD_INT 24
57895: PUSH
57896: EMPTY
57897: LIST
57898: LIST
57899: LIST
57900: IN
57901: IFFALSE 57922
// points := [ 25 , 5 , 3 ] ;
57903: LD_ADDR_VAR 0 9
57907: PUSH
57908: LD_INT 25
57910: PUSH
57911: LD_INT 5
57913: PUSH
57914: LD_INT 3
57916: PUSH
57917: EMPTY
57918: LIST
57919: LIST
57920: LIST
57921: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
57922: LD_VAR 0 6
57926: PPUSH
57927: CALL_OW 264
57931: PUSH
57932: LD_INT 4
57934: PUSH
57935: LD_INT 43
57937: PUSH
57938: LD_INT 25
57940: PUSH
57941: EMPTY
57942: LIST
57943: LIST
57944: LIST
57945: IN
57946: IFFALSE 57967
// points := [ 40 , 15 , 5 ] ;
57948: LD_ADDR_VAR 0 9
57952: PUSH
57953: LD_INT 40
57955: PUSH
57956: LD_INT 15
57958: PUSH
57959: LD_INT 5
57961: PUSH
57962: EMPTY
57963: LIST
57964: LIST
57965: LIST
57966: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
57967: LD_VAR 0 6
57971: PPUSH
57972: CALL_OW 264
57976: PUSH
57977: LD_INT 3
57979: PUSH
57980: LD_INT 23
57982: PUSH
57983: EMPTY
57984: LIST
57985: LIST
57986: IN
57987: IFFALSE 58008
// points := [ 7 , 25 , 8 ] ;
57989: LD_ADDR_VAR 0 9
57993: PUSH
57994: LD_INT 7
57996: PUSH
57997: LD_INT 25
57999: PUSH
58000: LD_INT 8
58002: PUSH
58003: EMPTY
58004: LIST
58005: LIST
58006: LIST
58007: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
58008: LD_VAR 0 6
58012: PPUSH
58013: CALL_OW 264
58017: PUSH
58018: LD_INT 5
58020: PUSH
58021: LD_INT 27
58023: PUSH
58024: LD_INT 44
58026: PUSH
58027: EMPTY
58028: LIST
58029: LIST
58030: LIST
58031: IN
58032: IFFALSE 58053
// points := [ 14 , 50 , 16 ] ;
58034: LD_ADDR_VAR 0 9
58038: PUSH
58039: LD_INT 14
58041: PUSH
58042: LD_INT 50
58044: PUSH
58045: LD_INT 16
58047: PUSH
58048: EMPTY
58049: LIST
58050: LIST
58051: LIST
58052: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
58053: LD_VAR 0 6
58057: PPUSH
58058: CALL_OW 264
58062: PUSH
58063: LD_INT 6
58065: PUSH
58066: LD_INT 46
58068: PUSH
58069: EMPTY
58070: LIST
58071: LIST
58072: IN
58073: IFFALSE 58094
// points := [ 32 , 120 , 70 ] ;
58075: LD_ADDR_VAR 0 9
58079: PUSH
58080: LD_INT 32
58082: PUSH
58083: LD_INT 120
58085: PUSH
58086: LD_INT 70
58088: PUSH
58089: EMPTY
58090: LIST
58091: LIST
58092: LIST
58093: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
58094: LD_VAR 0 6
58098: PPUSH
58099: CALL_OW 264
58103: PUSH
58104: LD_INT 7
58106: PUSH
58107: LD_INT 28
58109: PUSH
58110: LD_INT 45
58112: PUSH
58113: LD_EXP 77
58117: PUSH
58118: EMPTY
58119: LIST
58120: LIST
58121: LIST
58122: LIST
58123: IN
58124: IFFALSE 58145
// points := [ 35 , 20 , 45 ] ;
58126: LD_ADDR_VAR 0 9
58130: PUSH
58131: LD_INT 35
58133: PUSH
58134: LD_INT 20
58136: PUSH
58137: LD_INT 45
58139: PUSH
58140: EMPTY
58141: LIST
58142: LIST
58143: LIST
58144: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
58145: LD_VAR 0 6
58149: PPUSH
58150: CALL_OW 264
58154: PUSH
58155: LD_INT 47
58157: PUSH
58158: EMPTY
58159: LIST
58160: IN
58161: IFFALSE 58182
// points := [ 67 , 45 , 75 ] ;
58163: LD_ADDR_VAR 0 9
58167: PUSH
58168: LD_INT 67
58170: PUSH
58171: LD_INT 45
58173: PUSH
58174: LD_INT 75
58176: PUSH
58177: EMPTY
58178: LIST
58179: LIST
58180: LIST
58181: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
58182: LD_VAR 0 6
58186: PPUSH
58187: CALL_OW 264
58191: PUSH
58192: LD_INT 26
58194: PUSH
58195: EMPTY
58196: LIST
58197: IN
58198: IFFALSE 58219
// points := [ 120 , 30 , 80 ] ;
58200: LD_ADDR_VAR 0 9
58204: PUSH
58205: LD_INT 120
58207: PUSH
58208: LD_INT 30
58210: PUSH
58211: LD_INT 80
58213: PUSH
58214: EMPTY
58215: LIST
58216: LIST
58217: LIST
58218: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
58219: LD_VAR 0 6
58223: PPUSH
58224: CALL_OW 264
58228: PUSH
58229: LD_INT 22
58231: PUSH
58232: EMPTY
58233: LIST
58234: IN
58235: IFFALSE 58256
// points := [ 40 , 1 , 1 ] ;
58237: LD_ADDR_VAR 0 9
58241: PUSH
58242: LD_INT 40
58244: PUSH
58245: LD_INT 1
58247: PUSH
58248: LD_INT 1
58250: PUSH
58251: EMPTY
58252: LIST
58253: LIST
58254: LIST
58255: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
58256: LD_VAR 0 6
58260: PPUSH
58261: CALL_OW 264
58265: PUSH
58266: LD_INT 29
58268: PUSH
58269: EMPTY
58270: LIST
58271: IN
58272: IFFALSE 58293
// points := [ 70 , 200 , 400 ] ;
58274: LD_ADDR_VAR 0 9
58278: PUSH
58279: LD_INT 70
58281: PUSH
58282: LD_INT 200
58284: PUSH
58285: LD_INT 400
58287: PUSH
58288: EMPTY
58289: LIST
58290: LIST
58291: LIST
58292: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
58293: LD_VAR 0 6
58297: PPUSH
58298: CALL_OW 264
58302: PUSH
58303: LD_INT 14
58305: PUSH
58306: LD_INT 53
58308: PUSH
58309: EMPTY
58310: LIST
58311: LIST
58312: IN
58313: IFFALSE 58334
// points := [ 40 , 10 , 20 ] ;
58315: LD_ADDR_VAR 0 9
58319: PUSH
58320: LD_INT 40
58322: PUSH
58323: LD_INT 10
58325: PUSH
58326: LD_INT 20
58328: PUSH
58329: EMPTY
58330: LIST
58331: LIST
58332: LIST
58333: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
58334: LD_VAR 0 6
58338: PPUSH
58339: CALL_OW 264
58343: PUSH
58344: LD_INT 9
58346: PUSH
58347: EMPTY
58348: LIST
58349: IN
58350: IFFALSE 58371
// points := [ 5 , 70 , 20 ] ;
58352: LD_ADDR_VAR 0 9
58356: PUSH
58357: LD_INT 5
58359: PUSH
58360: LD_INT 70
58362: PUSH
58363: LD_INT 20
58365: PUSH
58366: EMPTY
58367: LIST
58368: LIST
58369: LIST
58370: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
58371: LD_VAR 0 6
58375: PPUSH
58376: CALL_OW 264
58380: PUSH
58381: LD_INT 10
58383: PUSH
58384: EMPTY
58385: LIST
58386: IN
58387: IFFALSE 58408
// points := [ 35 , 110 , 70 ] ;
58389: LD_ADDR_VAR 0 9
58393: PUSH
58394: LD_INT 35
58396: PUSH
58397: LD_INT 110
58399: PUSH
58400: LD_INT 70
58402: PUSH
58403: EMPTY
58404: LIST
58405: LIST
58406: LIST
58407: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
58408: LD_VAR 0 6
58412: PPUSH
58413: CALL_OW 265
58417: PUSH
58418: LD_INT 25
58420: EQUAL
58421: IFFALSE 58442
// points := [ 80 , 65 , 100 ] ;
58423: LD_ADDR_VAR 0 9
58427: PUSH
58428: LD_INT 80
58430: PUSH
58431: LD_INT 65
58433: PUSH
58434: LD_INT 100
58436: PUSH
58437: EMPTY
58438: LIST
58439: LIST
58440: LIST
58441: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
58442: LD_VAR 0 6
58446: PPUSH
58447: CALL_OW 263
58451: PUSH
58452: LD_INT 1
58454: EQUAL
58455: IFFALSE 58490
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
58457: LD_ADDR_VAR 0 10
58461: PUSH
58462: LD_VAR 0 10
58466: PUSH
58467: LD_VAR 0 6
58471: PPUSH
58472: CALL_OW 311
58476: PPUSH
58477: LD_INT 3
58479: PPUSH
58480: CALL_OW 259
58484: PUSH
58485: LD_INT 4
58487: MUL
58488: MUL
58489: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
58490: LD_VAR 0 6
58494: PPUSH
58495: CALL_OW 263
58499: PUSH
58500: LD_INT 2
58502: EQUAL
58503: IFFALSE 58554
// begin j := IsControledBy ( i ) ;
58505: LD_ADDR_VAR 0 7
58509: PUSH
58510: LD_VAR 0 6
58514: PPUSH
58515: CALL_OW 312
58519: ST_TO_ADDR
// if j then
58520: LD_VAR 0 7
58524: IFFALSE 58554
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
58526: LD_ADDR_VAR 0 10
58530: PUSH
58531: LD_VAR 0 10
58535: PUSH
58536: LD_VAR 0 7
58540: PPUSH
58541: LD_INT 3
58543: PPUSH
58544: CALL_OW 259
58548: PUSH
58549: LD_INT 3
58551: MUL
58552: MUL
58553: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
58554: LD_VAR 0 6
58558: PPUSH
58559: CALL_OW 264
58563: PUSH
58564: LD_INT 5
58566: PUSH
58567: LD_INT 6
58569: PUSH
58570: LD_INT 46
58572: PUSH
58573: LD_INT 44
58575: PUSH
58576: LD_INT 47
58578: PUSH
58579: LD_INT 45
58581: PUSH
58582: LD_INT 28
58584: PUSH
58585: LD_INT 7
58587: PUSH
58588: LD_INT 27
58590: PUSH
58591: LD_INT 29
58593: PUSH
58594: EMPTY
58595: LIST
58596: LIST
58597: LIST
58598: LIST
58599: LIST
58600: LIST
58601: LIST
58602: LIST
58603: LIST
58604: LIST
58605: IN
58606: PUSH
58607: LD_VAR 0 1
58611: PPUSH
58612: LD_INT 52
58614: PPUSH
58615: CALL_OW 321
58619: PUSH
58620: LD_INT 2
58622: EQUAL
58623: AND
58624: IFFALSE 58641
// bpoints := bpoints * 1.2 ;
58626: LD_ADDR_VAR 0 10
58630: PUSH
58631: LD_VAR 0 10
58635: PUSH
58636: LD_REAL  1.20000000000000E+0000
58639: MUL
58640: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
58641: LD_VAR 0 6
58645: PPUSH
58646: CALL_OW 264
58650: PUSH
58651: LD_INT 6
58653: PUSH
58654: LD_INT 46
58656: PUSH
58657: LD_INT 47
58659: PUSH
58660: EMPTY
58661: LIST
58662: LIST
58663: LIST
58664: IN
58665: IFFALSE 58682
// bpoints := bpoints * 1.2 ;
58667: LD_ADDR_VAR 0 10
58671: PUSH
58672: LD_VAR 0 10
58676: PUSH
58677: LD_REAL  1.20000000000000E+0000
58680: MUL
58681: ST_TO_ADDR
// end ; unit_building :
58682: GO 58696
58684: LD_INT 3
58686: DOUBLE
58687: EQUAL
58688: IFTRUE 58692
58690: GO 58695
58692: POP
// ; end ;
58693: GO 58696
58695: POP
// for j = 1 to 3 do
58696: LD_ADDR_VAR 0 7
58700: PUSH
58701: DOUBLE
58702: LD_INT 1
58704: DEC
58705: ST_TO_ADDR
58706: LD_INT 3
58708: PUSH
58709: FOR_TO
58710: IFFALSE 58763
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
58712: LD_ADDR_VAR 0 5
58716: PUSH
58717: LD_VAR 0 5
58721: PPUSH
58722: LD_VAR 0 7
58726: PPUSH
58727: LD_VAR 0 5
58731: PUSH
58732: LD_VAR 0 7
58736: ARRAY
58737: PUSH
58738: LD_VAR 0 9
58742: PUSH
58743: LD_VAR 0 7
58747: ARRAY
58748: PUSH
58749: LD_VAR 0 10
58753: MUL
58754: PLUS
58755: PPUSH
58756: CALL_OW 1
58760: ST_TO_ADDR
58761: GO 58709
58763: POP
58764: POP
// end ;
58765: GO 57242
58767: POP
58768: POP
// result := Replace ( result , 4 , tmp ) ;
58769: LD_ADDR_VAR 0 5
58773: PUSH
58774: LD_VAR 0 5
58778: PPUSH
58779: LD_INT 4
58781: PPUSH
58782: LD_VAR 0 8
58786: PPUSH
58787: CALL_OW 1
58791: ST_TO_ADDR
// end ;
58792: LD_VAR 0 5
58796: RET
// export function DangerAtRange ( unit , range ) ; begin
58797: LD_INT 0
58799: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
58800: LD_ADDR_VAR 0 3
58804: PUSH
58805: LD_VAR 0 1
58809: PPUSH
58810: CALL_OW 255
58814: PPUSH
58815: LD_VAR 0 1
58819: PPUSH
58820: CALL_OW 250
58824: PPUSH
58825: LD_VAR 0 1
58829: PPUSH
58830: CALL_OW 251
58834: PPUSH
58835: LD_VAR 0 2
58839: PPUSH
58840: CALL 57094 0 4
58844: ST_TO_ADDR
// end ;
58845: LD_VAR 0 3
58849: RET
// export function DangerInArea ( side , area ) ; begin
58850: LD_INT 0
58852: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
58853: LD_ADDR_VAR 0 3
58857: PUSH
58858: LD_VAR 0 2
58862: PPUSH
58863: LD_INT 81
58865: PUSH
58866: LD_VAR 0 1
58870: PUSH
58871: EMPTY
58872: LIST
58873: LIST
58874: PPUSH
58875: CALL_OW 70
58879: ST_TO_ADDR
// end ;
58880: LD_VAR 0 3
58884: RET
// export function IsExtension ( b ) ; begin
58885: LD_INT 0
58887: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
58888: LD_ADDR_VAR 0 2
58892: PUSH
58893: LD_VAR 0 1
58897: PUSH
58898: LD_INT 23
58900: PUSH
58901: LD_INT 20
58903: PUSH
58904: LD_INT 22
58906: PUSH
58907: LD_INT 17
58909: PUSH
58910: LD_INT 24
58912: PUSH
58913: LD_INT 21
58915: PUSH
58916: LD_INT 19
58918: PUSH
58919: LD_INT 16
58921: PUSH
58922: LD_INT 25
58924: PUSH
58925: LD_INT 18
58927: PUSH
58928: EMPTY
58929: LIST
58930: LIST
58931: LIST
58932: LIST
58933: LIST
58934: LIST
58935: LIST
58936: LIST
58937: LIST
58938: LIST
58939: IN
58940: ST_TO_ADDR
// end ;
58941: LD_VAR 0 2
58945: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
58946: LD_INT 0
58948: PPUSH
58949: PPUSH
58950: PPUSH
// result := [ ] ;
58951: LD_ADDR_VAR 0 4
58955: PUSH
58956: EMPTY
58957: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
58958: LD_ADDR_VAR 0 5
58962: PUSH
58963: LD_VAR 0 2
58967: PPUSH
58968: LD_INT 21
58970: PUSH
58971: LD_INT 3
58973: PUSH
58974: EMPTY
58975: LIST
58976: LIST
58977: PPUSH
58978: CALL_OW 70
58982: ST_TO_ADDR
// if not tmp then
58983: LD_VAR 0 5
58987: NOT
58988: IFFALSE 58992
// exit ;
58990: GO 59056
// if checkLink then
58992: LD_VAR 0 3
58996: IFFALSE 59046
// begin for i in tmp do
58998: LD_ADDR_VAR 0 6
59002: PUSH
59003: LD_VAR 0 5
59007: PUSH
59008: FOR_IN
59009: IFFALSE 59044
// if GetBase ( i ) <> base then
59011: LD_VAR 0 6
59015: PPUSH
59016: CALL_OW 274
59020: PUSH
59021: LD_VAR 0 1
59025: NONEQUAL
59026: IFFALSE 59042
// ComLinkToBase ( base , i ) ;
59028: LD_VAR 0 1
59032: PPUSH
59033: LD_VAR 0 6
59037: PPUSH
59038: CALL_OW 169
59042: GO 59008
59044: POP
59045: POP
// end ; result := tmp ;
59046: LD_ADDR_VAR 0 4
59050: PUSH
59051: LD_VAR 0 5
59055: ST_TO_ADDR
// end ;
59056: LD_VAR 0 4
59060: RET
// export function ComComplete ( units , b ) ; var i ; begin
59061: LD_INT 0
59063: PPUSH
59064: PPUSH
// if not units then
59065: LD_VAR 0 1
59069: NOT
59070: IFFALSE 59074
// exit ;
59072: GO 59164
// for i in units do
59074: LD_ADDR_VAR 0 4
59078: PUSH
59079: LD_VAR 0 1
59083: PUSH
59084: FOR_IN
59085: IFFALSE 59162
// if BuildingStatus ( b ) = bs_build then
59087: LD_VAR 0 2
59091: PPUSH
59092: CALL_OW 461
59096: PUSH
59097: LD_INT 1
59099: EQUAL
59100: IFFALSE 59160
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
59102: LD_VAR 0 4
59106: PPUSH
59107: LD_STRING h
59109: PUSH
59110: LD_VAR 0 2
59114: PPUSH
59115: CALL_OW 250
59119: PUSH
59120: LD_VAR 0 2
59124: PPUSH
59125: CALL_OW 251
59129: PUSH
59130: LD_VAR 0 2
59134: PUSH
59135: LD_INT 0
59137: PUSH
59138: LD_INT 0
59140: PUSH
59141: LD_INT 0
59143: PUSH
59144: EMPTY
59145: LIST
59146: LIST
59147: LIST
59148: LIST
59149: LIST
59150: LIST
59151: LIST
59152: PUSH
59153: EMPTY
59154: LIST
59155: PPUSH
59156: CALL_OW 446
59160: GO 59084
59162: POP
59163: POP
// end ;
59164: LD_VAR 0 3
59168: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
59169: LD_INT 0
59171: PPUSH
59172: PPUSH
59173: PPUSH
59174: PPUSH
59175: PPUSH
59176: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
59177: LD_VAR 0 1
59181: NOT
59182: PUSH
59183: LD_VAR 0 1
59187: PPUSH
59188: CALL_OW 263
59192: PUSH
59193: LD_INT 2
59195: EQUAL
59196: NOT
59197: OR
59198: IFFALSE 59202
// exit ;
59200: GO 59518
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
59202: LD_ADDR_VAR 0 6
59206: PUSH
59207: LD_INT 22
59209: PUSH
59210: LD_VAR 0 1
59214: PPUSH
59215: CALL_OW 255
59219: PUSH
59220: EMPTY
59221: LIST
59222: LIST
59223: PUSH
59224: LD_INT 2
59226: PUSH
59227: LD_INT 30
59229: PUSH
59230: LD_INT 36
59232: PUSH
59233: EMPTY
59234: LIST
59235: LIST
59236: PUSH
59237: LD_INT 34
59239: PUSH
59240: LD_INT 31
59242: PUSH
59243: EMPTY
59244: LIST
59245: LIST
59246: PUSH
59247: EMPTY
59248: LIST
59249: LIST
59250: LIST
59251: PUSH
59252: EMPTY
59253: LIST
59254: LIST
59255: PPUSH
59256: CALL_OW 69
59260: ST_TO_ADDR
// if not tmp then
59261: LD_VAR 0 6
59265: NOT
59266: IFFALSE 59270
// exit ;
59268: GO 59518
// result := [ ] ;
59270: LD_ADDR_VAR 0 2
59274: PUSH
59275: EMPTY
59276: ST_TO_ADDR
// for i in tmp do
59277: LD_ADDR_VAR 0 3
59281: PUSH
59282: LD_VAR 0 6
59286: PUSH
59287: FOR_IN
59288: IFFALSE 59359
// begin t := UnitsInside ( i ) ;
59290: LD_ADDR_VAR 0 4
59294: PUSH
59295: LD_VAR 0 3
59299: PPUSH
59300: CALL_OW 313
59304: ST_TO_ADDR
// if t then
59305: LD_VAR 0 4
59309: IFFALSE 59357
// for j in t do
59311: LD_ADDR_VAR 0 7
59315: PUSH
59316: LD_VAR 0 4
59320: PUSH
59321: FOR_IN
59322: IFFALSE 59355
// result := Insert ( result , result + 1 , j ) ;
59324: LD_ADDR_VAR 0 2
59328: PUSH
59329: LD_VAR 0 2
59333: PPUSH
59334: LD_VAR 0 2
59338: PUSH
59339: LD_INT 1
59341: PLUS
59342: PPUSH
59343: LD_VAR 0 7
59347: PPUSH
59348: CALL_OW 2
59352: ST_TO_ADDR
59353: GO 59321
59355: POP
59356: POP
// end ;
59357: GO 59287
59359: POP
59360: POP
// if not result then
59361: LD_VAR 0 2
59365: NOT
59366: IFFALSE 59370
// exit ;
59368: GO 59518
// mech := result [ 1 ] ;
59370: LD_ADDR_VAR 0 5
59374: PUSH
59375: LD_VAR 0 2
59379: PUSH
59380: LD_INT 1
59382: ARRAY
59383: ST_TO_ADDR
// if result > 1 then
59384: LD_VAR 0 2
59388: PUSH
59389: LD_INT 1
59391: GREATER
59392: IFFALSE 59504
// for i = 2 to result do
59394: LD_ADDR_VAR 0 3
59398: PUSH
59399: DOUBLE
59400: LD_INT 2
59402: DEC
59403: ST_TO_ADDR
59404: LD_VAR 0 2
59408: PUSH
59409: FOR_TO
59410: IFFALSE 59502
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
59412: LD_ADDR_VAR 0 4
59416: PUSH
59417: LD_VAR 0 2
59421: PUSH
59422: LD_VAR 0 3
59426: ARRAY
59427: PPUSH
59428: LD_INT 3
59430: PPUSH
59431: CALL_OW 259
59435: PUSH
59436: LD_VAR 0 2
59440: PUSH
59441: LD_VAR 0 3
59445: ARRAY
59446: PPUSH
59447: CALL_OW 432
59451: MINUS
59452: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
59453: LD_VAR 0 4
59457: PUSH
59458: LD_VAR 0 5
59462: PPUSH
59463: LD_INT 3
59465: PPUSH
59466: CALL_OW 259
59470: PUSH
59471: LD_VAR 0 5
59475: PPUSH
59476: CALL_OW 432
59480: MINUS
59481: GREATEREQUAL
59482: IFFALSE 59500
// mech := result [ i ] ;
59484: LD_ADDR_VAR 0 5
59488: PUSH
59489: LD_VAR 0 2
59493: PUSH
59494: LD_VAR 0 3
59498: ARRAY
59499: ST_TO_ADDR
// end ;
59500: GO 59409
59502: POP
59503: POP
// ComLinkTo ( vehicle , mech ) ;
59504: LD_VAR 0 1
59508: PPUSH
59509: LD_VAR 0 5
59513: PPUSH
59514: CALL_OW 135
// end ;
59518: LD_VAR 0 2
59522: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
59523: LD_INT 0
59525: PPUSH
59526: PPUSH
59527: PPUSH
59528: PPUSH
59529: PPUSH
59530: PPUSH
59531: PPUSH
59532: PPUSH
59533: PPUSH
59534: PPUSH
59535: PPUSH
59536: PPUSH
59537: PPUSH
// result := [ ] ;
59538: LD_ADDR_VAR 0 7
59542: PUSH
59543: EMPTY
59544: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
59545: LD_VAR 0 1
59549: PPUSH
59550: CALL_OW 266
59554: PUSH
59555: LD_INT 0
59557: PUSH
59558: LD_INT 1
59560: PUSH
59561: EMPTY
59562: LIST
59563: LIST
59564: IN
59565: NOT
59566: IFFALSE 59570
// exit ;
59568: GO 61204
// if name then
59570: LD_VAR 0 3
59574: IFFALSE 59590
// SetBName ( base_dep , name ) ;
59576: LD_VAR 0 1
59580: PPUSH
59581: LD_VAR 0 3
59585: PPUSH
59586: CALL_OW 500
// base := GetBase ( base_dep ) ;
59590: LD_ADDR_VAR 0 15
59594: PUSH
59595: LD_VAR 0 1
59599: PPUSH
59600: CALL_OW 274
59604: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
59605: LD_ADDR_VAR 0 16
59609: PUSH
59610: LD_VAR 0 1
59614: PPUSH
59615: CALL_OW 255
59619: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
59620: LD_ADDR_VAR 0 17
59624: PUSH
59625: LD_VAR 0 1
59629: PPUSH
59630: CALL_OW 248
59634: ST_TO_ADDR
// if sources then
59635: LD_VAR 0 5
59639: IFFALSE 59686
// for i = 1 to 3 do
59641: LD_ADDR_VAR 0 8
59645: PUSH
59646: DOUBLE
59647: LD_INT 1
59649: DEC
59650: ST_TO_ADDR
59651: LD_INT 3
59653: PUSH
59654: FOR_TO
59655: IFFALSE 59684
// AddResourceType ( base , i , sources [ i ] ) ;
59657: LD_VAR 0 15
59661: PPUSH
59662: LD_VAR 0 8
59666: PPUSH
59667: LD_VAR 0 5
59671: PUSH
59672: LD_VAR 0 8
59676: ARRAY
59677: PPUSH
59678: CALL_OW 276
59682: GO 59654
59684: POP
59685: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
59686: LD_ADDR_VAR 0 18
59690: PUSH
59691: LD_VAR 0 15
59695: PPUSH
59696: LD_VAR 0 2
59700: PPUSH
59701: LD_INT 1
59703: PPUSH
59704: CALL 58946 0 3
59708: ST_TO_ADDR
// InitHc ;
59709: CALL_OW 19
// InitUc ;
59713: CALL_OW 18
// uc_side := side ;
59717: LD_ADDR_OWVAR 20
59721: PUSH
59722: LD_VAR 0 16
59726: ST_TO_ADDR
// uc_nation := nation ;
59727: LD_ADDR_OWVAR 21
59731: PUSH
59732: LD_VAR 0 17
59736: ST_TO_ADDR
// if buildings then
59737: LD_VAR 0 18
59741: IFFALSE 61063
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
59743: LD_ADDR_VAR 0 19
59747: PUSH
59748: LD_VAR 0 18
59752: PPUSH
59753: LD_INT 2
59755: PUSH
59756: LD_INT 30
59758: PUSH
59759: LD_INT 29
59761: PUSH
59762: EMPTY
59763: LIST
59764: LIST
59765: PUSH
59766: LD_INT 30
59768: PUSH
59769: LD_INT 30
59771: PUSH
59772: EMPTY
59773: LIST
59774: LIST
59775: PUSH
59776: EMPTY
59777: LIST
59778: LIST
59779: LIST
59780: PPUSH
59781: CALL_OW 72
59785: ST_TO_ADDR
// if tmp then
59786: LD_VAR 0 19
59790: IFFALSE 59838
// for i in tmp do
59792: LD_ADDR_VAR 0 8
59796: PUSH
59797: LD_VAR 0 19
59801: PUSH
59802: FOR_IN
59803: IFFALSE 59836
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
59805: LD_VAR 0 8
59809: PPUSH
59810: CALL_OW 250
59814: PPUSH
59815: LD_VAR 0 8
59819: PPUSH
59820: CALL_OW 251
59824: PPUSH
59825: LD_VAR 0 16
59829: PPUSH
59830: CALL_OW 441
59834: GO 59802
59836: POP
59837: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
59838: LD_VAR 0 18
59842: PPUSH
59843: LD_INT 2
59845: PUSH
59846: LD_INT 30
59848: PUSH
59849: LD_INT 32
59851: PUSH
59852: EMPTY
59853: LIST
59854: LIST
59855: PUSH
59856: LD_INT 30
59858: PUSH
59859: LD_INT 33
59861: PUSH
59862: EMPTY
59863: LIST
59864: LIST
59865: PUSH
59866: EMPTY
59867: LIST
59868: LIST
59869: LIST
59870: PPUSH
59871: CALL_OW 72
59875: IFFALSE 59963
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
59877: LD_ADDR_VAR 0 8
59881: PUSH
59882: LD_VAR 0 18
59886: PPUSH
59887: LD_INT 2
59889: PUSH
59890: LD_INT 30
59892: PUSH
59893: LD_INT 32
59895: PUSH
59896: EMPTY
59897: LIST
59898: LIST
59899: PUSH
59900: LD_INT 30
59902: PUSH
59903: LD_INT 33
59905: PUSH
59906: EMPTY
59907: LIST
59908: LIST
59909: PUSH
59910: EMPTY
59911: LIST
59912: LIST
59913: LIST
59914: PPUSH
59915: CALL_OW 72
59919: PUSH
59920: FOR_IN
59921: IFFALSE 59961
// begin if not GetBWeapon ( i ) then
59923: LD_VAR 0 8
59927: PPUSH
59928: CALL_OW 269
59932: NOT
59933: IFFALSE 59959
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
59935: LD_VAR 0 8
59939: PPUSH
59940: LD_VAR 0 8
59944: PPUSH
59945: LD_VAR 0 2
59949: PPUSH
59950: CALL 61209 0 2
59954: PPUSH
59955: CALL_OW 431
// end ;
59959: GO 59920
59961: POP
59962: POP
// end ; for i = 1 to personel do
59963: LD_ADDR_VAR 0 8
59967: PUSH
59968: DOUBLE
59969: LD_INT 1
59971: DEC
59972: ST_TO_ADDR
59973: LD_VAR 0 6
59977: PUSH
59978: FOR_TO
59979: IFFALSE 61043
// begin if i > 4 then
59981: LD_VAR 0 8
59985: PUSH
59986: LD_INT 4
59988: GREATER
59989: IFFALSE 59993
// break ;
59991: GO 61043
// case i of 1 :
59993: LD_VAR 0 8
59997: PUSH
59998: LD_INT 1
60000: DOUBLE
60001: EQUAL
60002: IFTRUE 60006
60004: GO 60086
60006: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
60007: LD_ADDR_VAR 0 12
60011: PUSH
60012: LD_VAR 0 18
60016: PPUSH
60017: LD_INT 22
60019: PUSH
60020: LD_VAR 0 16
60024: PUSH
60025: EMPTY
60026: LIST
60027: LIST
60028: PUSH
60029: LD_INT 58
60031: PUSH
60032: EMPTY
60033: LIST
60034: PUSH
60035: LD_INT 2
60037: PUSH
60038: LD_INT 30
60040: PUSH
60041: LD_INT 32
60043: PUSH
60044: EMPTY
60045: LIST
60046: LIST
60047: PUSH
60048: LD_INT 30
60050: PUSH
60051: LD_INT 4
60053: PUSH
60054: EMPTY
60055: LIST
60056: LIST
60057: PUSH
60058: LD_INT 30
60060: PUSH
60061: LD_INT 5
60063: PUSH
60064: EMPTY
60065: LIST
60066: LIST
60067: PUSH
60068: EMPTY
60069: LIST
60070: LIST
60071: LIST
60072: LIST
60073: PUSH
60074: EMPTY
60075: LIST
60076: LIST
60077: LIST
60078: PPUSH
60079: CALL_OW 72
60083: ST_TO_ADDR
60084: GO 60308
60086: LD_INT 2
60088: DOUBLE
60089: EQUAL
60090: IFTRUE 60094
60092: GO 60156
60094: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
60095: LD_ADDR_VAR 0 12
60099: PUSH
60100: LD_VAR 0 18
60104: PPUSH
60105: LD_INT 22
60107: PUSH
60108: LD_VAR 0 16
60112: PUSH
60113: EMPTY
60114: LIST
60115: LIST
60116: PUSH
60117: LD_INT 2
60119: PUSH
60120: LD_INT 30
60122: PUSH
60123: LD_INT 0
60125: PUSH
60126: EMPTY
60127: LIST
60128: LIST
60129: PUSH
60130: LD_INT 30
60132: PUSH
60133: LD_INT 1
60135: PUSH
60136: EMPTY
60137: LIST
60138: LIST
60139: PUSH
60140: EMPTY
60141: LIST
60142: LIST
60143: LIST
60144: PUSH
60145: EMPTY
60146: LIST
60147: LIST
60148: PPUSH
60149: CALL_OW 72
60153: ST_TO_ADDR
60154: GO 60308
60156: LD_INT 3
60158: DOUBLE
60159: EQUAL
60160: IFTRUE 60164
60162: GO 60226
60164: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
60165: LD_ADDR_VAR 0 12
60169: PUSH
60170: LD_VAR 0 18
60174: PPUSH
60175: LD_INT 22
60177: PUSH
60178: LD_VAR 0 16
60182: PUSH
60183: EMPTY
60184: LIST
60185: LIST
60186: PUSH
60187: LD_INT 2
60189: PUSH
60190: LD_INT 30
60192: PUSH
60193: LD_INT 2
60195: PUSH
60196: EMPTY
60197: LIST
60198: LIST
60199: PUSH
60200: LD_INT 30
60202: PUSH
60203: LD_INT 3
60205: PUSH
60206: EMPTY
60207: LIST
60208: LIST
60209: PUSH
60210: EMPTY
60211: LIST
60212: LIST
60213: LIST
60214: PUSH
60215: EMPTY
60216: LIST
60217: LIST
60218: PPUSH
60219: CALL_OW 72
60223: ST_TO_ADDR
60224: GO 60308
60226: LD_INT 4
60228: DOUBLE
60229: EQUAL
60230: IFTRUE 60234
60232: GO 60307
60234: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
60235: LD_ADDR_VAR 0 12
60239: PUSH
60240: LD_VAR 0 18
60244: PPUSH
60245: LD_INT 22
60247: PUSH
60248: LD_VAR 0 16
60252: PUSH
60253: EMPTY
60254: LIST
60255: LIST
60256: PUSH
60257: LD_INT 2
60259: PUSH
60260: LD_INT 30
60262: PUSH
60263: LD_INT 6
60265: PUSH
60266: EMPTY
60267: LIST
60268: LIST
60269: PUSH
60270: LD_INT 30
60272: PUSH
60273: LD_INT 7
60275: PUSH
60276: EMPTY
60277: LIST
60278: LIST
60279: PUSH
60280: LD_INT 30
60282: PUSH
60283: LD_INT 8
60285: PUSH
60286: EMPTY
60287: LIST
60288: LIST
60289: PUSH
60290: EMPTY
60291: LIST
60292: LIST
60293: LIST
60294: LIST
60295: PUSH
60296: EMPTY
60297: LIST
60298: LIST
60299: PPUSH
60300: CALL_OW 72
60304: ST_TO_ADDR
60305: GO 60308
60307: POP
// if i = 1 then
60308: LD_VAR 0 8
60312: PUSH
60313: LD_INT 1
60315: EQUAL
60316: IFFALSE 60427
// begin tmp := [ ] ;
60318: LD_ADDR_VAR 0 19
60322: PUSH
60323: EMPTY
60324: ST_TO_ADDR
// for j in f do
60325: LD_ADDR_VAR 0 9
60329: PUSH
60330: LD_VAR 0 12
60334: PUSH
60335: FOR_IN
60336: IFFALSE 60409
// if GetBType ( j ) = b_bunker then
60338: LD_VAR 0 9
60342: PPUSH
60343: CALL_OW 266
60347: PUSH
60348: LD_INT 32
60350: EQUAL
60351: IFFALSE 60378
// tmp := Insert ( tmp , 1 , j ) else
60353: LD_ADDR_VAR 0 19
60357: PUSH
60358: LD_VAR 0 19
60362: PPUSH
60363: LD_INT 1
60365: PPUSH
60366: LD_VAR 0 9
60370: PPUSH
60371: CALL_OW 2
60375: ST_TO_ADDR
60376: GO 60407
// tmp := Insert ( tmp , tmp + 1 , j ) ;
60378: LD_ADDR_VAR 0 19
60382: PUSH
60383: LD_VAR 0 19
60387: PPUSH
60388: LD_VAR 0 19
60392: PUSH
60393: LD_INT 1
60395: PLUS
60396: PPUSH
60397: LD_VAR 0 9
60401: PPUSH
60402: CALL_OW 2
60406: ST_TO_ADDR
60407: GO 60335
60409: POP
60410: POP
// if tmp then
60411: LD_VAR 0 19
60415: IFFALSE 60427
// f := tmp ;
60417: LD_ADDR_VAR 0 12
60421: PUSH
60422: LD_VAR 0 19
60426: ST_TO_ADDR
// end ; x := personel [ i ] ;
60427: LD_ADDR_VAR 0 13
60431: PUSH
60432: LD_VAR 0 6
60436: PUSH
60437: LD_VAR 0 8
60441: ARRAY
60442: ST_TO_ADDR
// if x = - 1 then
60443: LD_VAR 0 13
60447: PUSH
60448: LD_INT 1
60450: NEG
60451: EQUAL
60452: IFFALSE 60661
// begin for j in f do
60454: LD_ADDR_VAR 0 9
60458: PUSH
60459: LD_VAR 0 12
60463: PUSH
60464: FOR_IN
60465: IFFALSE 60657
// repeat InitHc ;
60467: CALL_OW 19
// if GetBType ( j ) = b_barracks then
60471: LD_VAR 0 9
60475: PPUSH
60476: CALL_OW 266
60480: PUSH
60481: LD_INT 5
60483: EQUAL
60484: IFFALSE 60554
// begin if UnitsInside ( j ) < 3 then
60486: LD_VAR 0 9
60490: PPUSH
60491: CALL_OW 313
60495: PUSH
60496: LD_INT 3
60498: LESS
60499: IFFALSE 60535
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
60501: LD_INT 0
60503: PPUSH
60504: LD_INT 5
60506: PUSH
60507: LD_INT 8
60509: PUSH
60510: LD_INT 9
60512: PUSH
60513: EMPTY
60514: LIST
60515: LIST
60516: LIST
60517: PUSH
60518: LD_VAR 0 17
60522: ARRAY
60523: PPUSH
60524: LD_VAR 0 4
60528: PPUSH
60529: CALL_OW 380
60533: GO 60552
// PrepareHuman ( false , i , skill ) ;
60535: LD_INT 0
60537: PPUSH
60538: LD_VAR 0 8
60542: PPUSH
60543: LD_VAR 0 4
60547: PPUSH
60548: CALL_OW 380
// end else
60552: GO 60571
// PrepareHuman ( false , i , skill ) ;
60554: LD_INT 0
60556: PPUSH
60557: LD_VAR 0 8
60561: PPUSH
60562: LD_VAR 0 4
60566: PPUSH
60567: CALL_OW 380
// un := CreateHuman ;
60571: LD_ADDR_VAR 0 14
60575: PUSH
60576: CALL_OW 44
60580: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60581: LD_ADDR_VAR 0 7
60585: PUSH
60586: LD_VAR 0 7
60590: PPUSH
60591: LD_INT 1
60593: PPUSH
60594: LD_VAR 0 14
60598: PPUSH
60599: CALL_OW 2
60603: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
60604: LD_VAR 0 14
60608: PPUSH
60609: LD_VAR 0 9
60613: PPUSH
60614: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
60618: LD_VAR 0 9
60622: PPUSH
60623: CALL_OW 313
60627: PUSH
60628: LD_INT 6
60630: EQUAL
60631: PUSH
60632: LD_VAR 0 9
60636: PPUSH
60637: CALL_OW 266
60641: PUSH
60642: LD_INT 32
60644: PUSH
60645: LD_INT 31
60647: PUSH
60648: EMPTY
60649: LIST
60650: LIST
60651: IN
60652: OR
60653: IFFALSE 60467
60655: GO 60464
60657: POP
60658: POP
// end else
60659: GO 61041
// for j = 1 to x do
60661: LD_ADDR_VAR 0 9
60665: PUSH
60666: DOUBLE
60667: LD_INT 1
60669: DEC
60670: ST_TO_ADDR
60671: LD_VAR 0 13
60675: PUSH
60676: FOR_TO
60677: IFFALSE 61039
// begin InitHc ;
60679: CALL_OW 19
// if not f then
60683: LD_VAR 0 12
60687: NOT
60688: IFFALSE 60777
// begin PrepareHuman ( false , i , skill ) ;
60690: LD_INT 0
60692: PPUSH
60693: LD_VAR 0 8
60697: PPUSH
60698: LD_VAR 0 4
60702: PPUSH
60703: CALL_OW 380
// un := CreateHuman ;
60707: LD_ADDR_VAR 0 14
60711: PUSH
60712: CALL_OW 44
60716: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60717: LD_ADDR_VAR 0 7
60721: PUSH
60722: LD_VAR 0 7
60726: PPUSH
60727: LD_INT 1
60729: PPUSH
60730: LD_VAR 0 14
60734: PPUSH
60735: CALL_OW 2
60739: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
60740: LD_VAR 0 14
60744: PPUSH
60745: LD_VAR 0 1
60749: PPUSH
60750: CALL_OW 250
60754: PPUSH
60755: LD_VAR 0 1
60759: PPUSH
60760: CALL_OW 251
60764: PPUSH
60765: LD_INT 10
60767: PPUSH
60768: LD_INT 0
60770: PPUSH
60771: CALL_OW 50
// continue ;
60775: GO 60676
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
60777: LD_VAR 0 12
60781: PUSH
60782: LD_INT 1
60784: ARRAY
60785: PPUSH
60786: CALL_OW 313
60790: PUSH
60791: LD_VAR 0 12
60795: PUSH
60796: LD_INT 1
60798: ARRAY
60799: PPUSH
60800: CALL_OW 266
60804: PUSH
60805: LD_INT 32
60807: PUSH
60808: LD_INT 31
60810: PUSH
60811: EMPTY
60812: LIST
60813: LIST
60814: IN
60815: AND
60816: PUSH
60817: LD_VAR 0 12
60821: PUSH
60822: LD_INT 1
60824: ARRAY
60825: PPUSH
60826: CALL_OW 313
60830: PUSH
60831: LD_INT 6
60833: EQUAL
60834: OR
60835: IFFALSE 60855
// f := Delete ( f , 1 ) ;
60837: LD_ADDR_VAR 0 12
60841: PUSH
60842: LD_VAR 0 12
60846: PPUSH
60847: LD_INT 1
60849: PPUSH
60850: CALL_OW 3
60854: ST_TO_ADDR
// if not f then
60855: LD_VAR 0 12
60859: NOT
60860: IFFALSE 60878
// begin x := x + 2 ;
60862: LD_ADDR_VAR 0 13
60866: PUSH
60867: LD_VAR 0 13
60871: PUSH
60872: LD_INT 2
60874: PLUS
60875: ST_TO_ADDR
// continue ;
60876: GO 60676
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
60878: LD_VAR 0 12
60882: PUSH
60883: LD_INT 1
60885: ARRAY
60886: PPUSH
60887: CALL_OW 266
60891: PUSH
60892: LD_INT 5
60894: EQUAL
60895: IFFALSE 60969
// begin if UnitsInside ( f [ 1 ] ) < 3 then
60897: LD_VAR 0 12
60901: PUSH
60902: LD_INT 1
60904: ARRAY
60905: PPUSH
60906: CALL_OW 313
60910: PUSH
60911: LD_INT 3
60913: LESS
60914: IFFALSE 60950
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
60916: LD_INT 0
60918: PPUSH
60919: LD_INT 5
60921: PUSH
60922: LD_INT 8
60924: PUSH
60925: LD_INT 9
60927: PUSH
60928: EMPTY
60929: LIST
60930: LIST
60931: LIST
60932: PUSH
60933: LD_VAR 0 17
60937: ARRAY
60938: PPUSH
60939: LD_VAR 0 4
60943: PPUSH
60944: CALL_OW 380
60948: GO 60967
// PrepareHuman ( false , i , skill ) ;
60950: LD_INT 0
60952: PPUSH
60953: LD_VAR 0 8
60957: PPUSH
60958: LD_VAR 0 4
60962: PPUSH
60963: CALL_OW 380
// end else
60967: GO 60986
// PrepareHuman ( false , i , skill ) ;
60969: LD_INT 0
60971: PPUSH
60972: LD_VAR 0 8
60976: PPUSH
60977: LD_VAR 0 4
60981: PPUSH
60982: CALL_OW 380
// un := CreateHuman ;
60986: LD_ADDR_VAR 0 14
60990: PUSH
60991: CALL_OW 44
60995: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60996: LD_ADDR_VAR 0 7
61000: PUSH
61001: LD_VAR 0 7
61005: PPUSH
61006: LD_INT 1
61008: PPUSH
61009: LD_VAR 0 14
61013: PPUSH
61014: CALL_OW 2
61018: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
61019: LD_VAR 0 14
61023: PPUSH
61024: LD_VAR 0 12
61028: PUSH
61029: LD_INT 1
61031: ARRAY
61032: PPUSH
61033: CALL_OW 52
// end ;
61037: GO 60676
61039: POP
61040: POP
// end ;
61041: GO 59978
61043: POP
61044: POP
// result := result ^ buildings ;
61045: LD_ADDR_VAR 0 7
61049: PUSH
61050: LD_VAR 0 7
61054: PUSH
61055: LD_VAR 0 18
61059: ADD
61060: ST_TO_ADDR
// end else
61061: GO 61204
// begin for i = 1 to personel do
61063: LD_ADDR_VAR 0 8
61067: PUSH
61068: DOUBLE
61069: LD_INT 1
61071: DEC
61072: ST_TO_ADDR
61073: LD_VAR 0 6
61077: PUSH
61078: FOR_TO
61079: IFFALSE 61202
// begin if i > 4 then
61081: LD_VAR 0 8
61085: PUSH
61086: LD_INT 4
61088: GREATER
61089: IFFALSE 61093
// break ;
61091: GO 61202
// x := personel [ i ] ;
61093: LD_ADDR_VAR 0 13
61097: PUSH
61098: LD_VAR 0 6
61102: PUSH
61103: LD_VAR 0 8
61107: ARRAY
61108: ST_TO_ADDR
// if x = - 1 then
61109: LD_VAR 0 13
61113: PUSH
61114: LD_INT 1
61116: NEG
61117: EQUAL
61118: IFFALSE 61122
// continue ;
61120: GO 61078
// PrepareHuman ( false , i , skill ) ;
61122: LD_INT 0
61124: PPUSH
61125: LD_VAR 0 8
61129: PPUSH
61130: LD_VAR 0 4
61134: PPUSH
61135: CALL_OW 380
// un := CreateHuman ;
61139: LD_ADDR_VAR 0 14
61143: PUSH
61144: CALL_OW 44
61148: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
61149: LD_VAR 0 14
61153: PPUSH
61154: LD_VAR 0 1
61158: PPUSH
61159: CALL_OW 250
61163: PPUSH
61164: LD_VAR 0 1
61168: PPUSH
61169: CALL_OW 251
61173: PPUSH
61174: LD_INT 10
61176: PPUSH
61177: LD_INT 0
61179: PPUSH
61180: CALL_OW 50
// result := result ^ un ;
61184: LD_ADDR_VAR 0 7
61188: PUSH
61189: LD_VAR 0 7
61193: PUSH
61194: LD_VAR 0 14
61198: ADD
61199: ST_TO_ADDR
// end ;
61200: GO 61078
61202: POP
61203: POP
// end ; end ;
61204: LD_VAR 0 7
61208: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
61209: LD_INT 0
61211: PPUSH
61212: PPUSH
61213: PPUSH
61214: PPUSH
61215: PPUSH
61216: PPUSH
61217: PPUSH
61218: PPUSH
61219: PPUSH
61220: PPUSH
61221: PPUSH
61222: PPUSH
61223: PPUSH
61224: PPUSH
61225: PPUSH
61226: PPUSH
// result := false ;
61227: LD_ADDR_VAR 0 3
61231: PUSH
61232: LD_INT 0
61234: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
61235: LD_VAR 0 1
61239: NOT
61240: PUSH
61241: LD_VAR 0 1
61245: PPUSH
61246: CALL_OW 266
61250: PUSH
61251: LD_INT 32
61253: PUSH
61254: LD_INT 33
61256: PUSH
61257: EMPTY
61258: LIST
61259: LIST
61260: IN
61261: NOT
61262: OR
61263: IFFALSE 61267
// exit ;
61265: GO 62376
// nat := GetNation ( tower ) ;
61267: LD_ADDR_VAR 0 12
61271: PUSH
61272: LD_VAR 0 1
61276: PPUSH
61277: CALL_OW 248
61281: ST_TO_ADDR
// side := GetSide ( tower ) ;
61282: LD_ADDR_VAR 0 16
61286: PUSH
61287: LD_VAR 0 1
61291: PPUSH
61292: CALL_OW 255
61296: ST_TO_ADDR
// x := GetX ( tower ) ;
61297: LD_ADDR_VAR 0 10
61301: PUSH
61302: LD_VAR 0 1
61306: PPUSH
61307: CALL_OW 250
61311: ST_TO_ADDR
// y := GetY ( tower ) ;
61312: LD_ADDR_VAR 0 11
61316: PUSH
61317: LD_VAR 0 1
61321: PPUSH
61322: CALL_OW 251
61326: ST_TO_ADDR
// if not x or not y then
61327: LD_VAR 0 10
61331: NOT
61332: PUSH
61333: LD_VAR 0 11
61337: NOT
61338: OR
61339: IFFALSE 61343
// exit ;
61341: GO 62376
// weapon := 0 ;
61343: LD_ADDR_VAR 0 18
61347: PUSH
61348: LD_INT 0
61350: ST_TO_ADDR
// fac_list := [ ] ;
61351: LD_ADDR_VAR 0 17
61355: PUSH
61356: EMPTY
61357: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
61358: LD_ADDR_VAR 0 6
61362: PUSH
61363: LD_VAR 0 1
61367: PPUSH
61368: CALL_OW 274
61372: PPUSH
61373: LD_VAR 0 2
61377: PPUSH
61378: LD_INT 0
61380: PPUSH
61381: CALL 58946 0 3
61385: PPUSH
61386: LD_INT 30
61388: PUSH
61389: LD_INT 3
61391: PUSH
61392: EMPTY
61393: LIST
61394: LIST
61395: PPUSH
61396: CALL_OW 72
61400: ST_TO_ADDR
// if not factories then
61401: LD_VAR 0 6
61405: NOT
61406: IFFALSE 61410
// exit ;
61408: GO 62376
// for i in factories do
61410: LD_ADDR_VAR 0 8
61414: PUSH
61415: LD_VAR 0 6
61419: PUSH
61420: FOR_IN
61421: IFFALSE 61446
// fac_list := fac_list union AvailableWeaponList ( i ) ;
61423: LD_ADDR_VAR 0 17
61427: PUSH
61428: LD_VAR 0 17
61432: PUSH
61433: LD_VAR 0 8
61437: PPUSH
61438: CALL_OW 478
61442: UNION
61443: ST_TO_ADDR
61444: GO 61420
61446: POP
61447: POP
// if not fac_list then
61448: LD_VAR 0 17
61452: NOT
61453: IFFALSE 61457
// exit ;
61455: GO 62376
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
61457: LD_ADDR_VAR 0 5
61461: PUSH
61462: LD_INT 4
61464: PUSH
61465: LD_INT 5
61467: PUSH
61468: LD_INT 9
61470: PUSH
61471: LD_INT 10
61473: PUSH
61474: LD_INT 6
61476: PUSH
61477: LD_INT 7
61479: PUSH
61480: LD_INT 11
61482: PUSH
61483: EMPTY
61484: LIST
61485: LIST
61486: LIST
61487: LIST
61488: LIST
61489: LIST
61490: LIST
61491: PUSH
61492: LD_INT 27
61494: PUSH
61495: LD_INT 28
61497: PUSH
61498: LD_INT 26
61500: PUSH
61501: LD_INT 30
61503: PUSH
61504: EMPTY
61505: LIST
61506: LIST
61507: LIST
61508: LIST
61509: PUSH
61510: LD_INT 43
61512: PUSH
61513: LD_INT 44
61515: PUSH
61516: LD_INT 46
61518: PUSH
61519: LD_INT 45
61521: PUSH
61522: LD_INT 47
61524: PUSH
61525: LD_INT 49
61527: PUSH
61528: EMPTY
61529: LIST
61530: LIST
61531: LIST
61532: LIST
61533: LIST
61534: LIST
61535: PUSH
61536: EMPTY
61537: LIST
61538: LIST
61539: LIST
61540: PUSH
61541: LD_VAR 0 12
61545: ARRAY
61546: ST_TO_ADDR
// list := list isect fac_list ;
61547: LD_ADDR_VAR 0 5
61551: PUSH
61552: LD_VAR 0 5
61556: PUSH
61557: LD_VAR 0 17
61561: ISECT
61562: ST_TO_ADDR
// if not list then
61563: LD_VAR 0 5
61567: NOT
61568: IFFALSE 61572
// exit ;
61570: GO 62376
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
61572: LD_VAR 0 12
61576: PUSH
61577: LD_INT 3
61579: EQUAL
61580: PUSH
61581: LD_INT 49
61583: PUSH
61584: LD_VAR 0 5
61588: IN
61589: AND
61590: PUSH
61591: LD_INT 31
61593: PPUSH
61594: LD_VAR 0 16
61598: PPUSH
61599: CALL_OW 321
61603: PUSH
61604: LD_INT 2
61606: EQUAL
61607: AND
61608: IFFALSE 61668
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
61610: LD_INT 22
61612: PUSH
61613: LD_VAR 0 16
61617: PUSH
61618: EMPTY
61619: LIST
61620: LIST
61621: PUSH
61622: LD_INT 35
61624: PUSH
61625: LD_INT 49
61627: PUSH
61628: EMPTY
61629: LIST
61630: LIST
61631: PUSH
61632: LD_INT 91
61634: PUSH
61635: LD_VAR 0 1
61639: PUSH
61640: LD_INT 10
61642: PUSH
61643: EMPTY
61644: LIST
61645: LIST
61646: LIST
61647: PUSH
61648: EMPTY
61649: LIST
61650: LIST
61651: LIST
61652: PPUSH
61653: CALL_OW 69
61657: NOT
61658: IFFALSE 61668
// weapon := ru_time_lapser ;
61660: LD_ADDR_VAR 0 18
61664: PUSH
61665: LD_INT 49
61667: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
61668: LD_VAR 0 12
61672: PUSH
61673: LD_INT 1
61675: PUSH
61676: LD_INT 2
61678: PUSH
61679: EMPTY
61680: LIST
61681: LIST
61682: IN
61683: PUSH
61684: LD_INT 11
61686: PUSH
61687: LD_VAR 0 5
61691: IN
61692: PUSH
61693: LD_INT 30
61695: PUSH
61696: LD_VAR 0 5
61700: IN
61701: OR
61702: AND
61703: PUSH
61704: LD_INT 6
61706: PPUSH
61707: LD_VAR 0 16
61711: PPUSH
61712: CALL_OW 321
61716: PUSH
61717: LD_INT 2
61719: EQUAL
61720: AND
61721: IFFALSE 61886
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
61723: LD_INT 22
61725: PUSH
61726: LD_VAR 0 16
61730: PUSH
61731: EMPTY
61732: LIST
61733: LIST
61734: PUSH
61735: LD_INT 2
61737: PUSH
61738: LD_INT 35
61740: PUSH
61741: LD_INT 11
61743: PUSH
61744: EMPTY
61745: LIST
61746: LIST
61747: PUSH
61748: LD_INT 35
61750: PUSH
61751: LD_INT 30
61753: PUSH
61754: EMPTY
61755: LIST
61756: LIST
61757: PUSH
61758: EMPTY
61759: LIST
61760: LIST
61761: LIST
61762: PUSH
61763: LD_INT 91
61765: PUSH
61766: LD_VAR 0 1
61770: PUSH
61771: LD_INT 18
61773: PUSH
61774: EMPTY
61775: LIST
61776: LIST
61777: LIST
61778: PUSH
61779: EMPTY
61780: LIST
61781: LIST
61782: LIST
61783: PPUSH
61784: CALL_OW 69
61788: NOT
61789: PUSH
61790: LD_INT 22
61792: PUSH
61793: LD_VAR 0 16
61797: PUSH
61798: EMPTY
61799: LIST
61800: LIST
61801: PUSH
61802: LD_INT 2
61804: PUSH
61805: LD_INT 30
61807: PUSH
61808: LD_INT 32
61810: PUSH
61811: EMPTY
61812: LIST
61813: LIST
61814: PUSH
61815: LD_INT 30
61817: PUSH
61818: LD_INT 33
61820: PUSH
61821: EMPTY
61822: LIST
61823: LIST
61824: PUSH
61825: EMPTY
61826: LIST
61827: LIST
61828: LIST
61829: PUSH
61830: LD_INT 91
61832: PUSH
61833: LD_VAR 0 1
61837: PUSH
61838: LD_INT 12
61840: PUSH
61841: EMPTY
61842: LIST
61843: LIST
61844: LIST
61845: PUSH
61846: EMPTY
61847: LIST
61848: LIST
61849: LIST
61850: PUSH
61851: EMPTY
61852: LIST
61853: PPUSH
61854: CALL_OW 69
61858: PUSH
61859: LD_INT 2
61861: GREATER
61862: AND
61863: IFFALSE 61886
// weapon := [ us_radar , ar_radar ] [ nat ] ;
61865: LD_ADDR_VAR 0 18
61869: PUSH
61870: LD_INT 11
61872: PUSH
61873: LD_INT 30
61875: PUSH
61876: EMPTY
61877: LIST
61878: LIST
61879: PUSH
61880: LD_VAR 0 12
61884: ARRAY
61885: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
61886: LD_VAR 0 18
61890: NOT
61891: PUSH
61892: LD_INT 40
61894: PPUSH
61895: LD_VAR 0 16
61899: PPUSH
61900: CALL_OW 321
61904: PUSH
61905: LD_INT 2
61907: EQUAL
61908: AND
61909: PUSH
61910: LD_INT 7
61912: PUSH
61913: LD_VAR 0 5
61917: IN
61918: PUSH
61919: LD_INT 28
61921: PUSH
61922: LD_VAR 0 5
61926: IN
61927: OR
61928: PUSH
61929: LD_INT 45
61931: PUSH
61932: LD_VAR 0 5
61936: IN
61937: OR
61938: AND
61939: IFFALSE 62193
// begin hex := GetHexInfo ( x , y ) ;
61941: LD_ADDR_VAR 0 4
61945: PUSH
61946: LD_VAR 0 10
61950: PPUSH
61951: LD_VAR 0 11
61955: PPUSH
61956: CALL_OW 546
61960: ST_TO_ADDR
// if hex [ 1 ] then
61961: LD_VAR 0 4
61965: PUSH
61966: LD_INT 1
61968: ARRAY
61969: IFFALSE 61973
// exit ;
61971: GO 62376
// height := hex [ 2 ] ;
61973: LD_ADDR_VAR 0 15
61977: PUSH
61978: LD_VAR 0 4
61982: PUSH
61983: LD_INT 2
61985: ARRAY
61986: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
61987: LD_ADDR_VAR 0 14
61991: PUSH
61992: LD_INT 0
61994: PUSH
61995: LD_INT 2
61997: PUSH
61998: LD_INT 3
62000: PUSH
62001: LD_INT 5
62003: PUSH
62004: EMPTY
62005: LIST
62006: LIST
62007: LIST
62008: LIST
62009: ST_TO_ADDR
// for i in tmp do
62010: LD_ADDR_VAR 0 8
62014: PUSH
62015: LD_VAR 0 14
62019: PUSH
62020: FOR_IN
62021: IFFALSE 62191
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
62023: LD_ADDR_VAR 0 9
62027: PUSH
62028: LD_VAR 0 10
62032: PPUSH
62033: LD_VAR 0 8
62037: PPUSH
62038: LD_INT 5
62040: PPUSH
62041: CALL_OW 272
62045: PUSH
62046: LD_VAR 0 11
62050: PPUSH
62051: LD_VAR 0 8
62055: PPUSH
62056: LD_INT 5
62058: PPUSH
62059: CALL_OW 273
62063: PUSH
62064: EMPTY
62065: LIST
62066: LIST
62067: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
62068: LD_VAR 0 9
62072: PUSH
62073: LD_INT 1
62075: ARRAY
62076: PPUSH
62077: LD_VAR 0 9
62081: PUSH
62082: LD_INT 2
62084: ARRAY
62085: PPUSH
62086: CALL_OW 488
62090: IFFALSE 62189
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
62092: LD_ADDR_VAR 0 4
62096: PUSH
62097: LD_VAR 0 9
62101: PUSH
62102: LD_INT 1
62104: ARRAY
62105: PPUSH
62106: LD_VAR 0 9
62110: PUSH
62111: LD_INT 2
62113: ARRAY
62114: PPUSH
62115: CALL_OW 546
62119: ST_TO_ADDR
// if hex [ 1 ] then
62120: LD_VAR 0 4
62124: PUSH
62125: LD_INT 1
62127: ARRAY
62128: IFFALSE 62132
// continue ;
62130: GO 62020
// h := hex [ 2 ] ;
62132: LD_ADDR_VAR 0 13
62136: PUSH
62137: LD_VAR 0 4
62141: PUSH
62142: LD_INT 2
62144: ARRAY
62145: ST_TO_ADDR
// if h + 7 < height then
62146: LD_VAR 0 13
62150: PUSH
62151: LD_INT 7
62153: PLUS
62154: PUSH
62155: LD_VAR 0 15
62159: LESS
62160: IFFALSE 62189
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
62162: LD_ADDR_VAR 0 18
62166: PUSH
62167: LD_INT 7
62169: PUSH
62170: LD_INT 28
62172: PUSH
62173: LD_INT 45
62175: PUSH
62176: EMPTY
62177: LIST
62178: LIST
62179: LIST
62180: PUSH
62181: LD_VAR 0 12
62185: ARRAY
62186: ST_TO_ADDR
// break ;
62187: GO 62191
// end ; end ; end ;
62189: GO 62020
62191: POP
62192: POP
// end ; if not weapon then
62193: LD_VAR 0 18
62197: NOT
62198: IFFALSE 62258
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
62200: LD_ADDR_VAR 0 5
62204: PUSH
62205: LD_VAR 0 5
62209: PUSH
62210: LD_INT 11
62212: PUSH
62213: LD_INT 30
62215: PUSH
62216: LD_INT 49
62218: PUSH
62219: EMPTY
62220: LIST
62221: LIST
62222: LIST
62223: DIFF
62224: ST_TO_ADDR
// if not list then
62225: LD_VAR 0 5
62229: NOT
62230: IFFALSE 62234
// exit ;
62232: GO 62376
// weapon := list [ rand ( 1 , list ) ] ;
62234: LD_ADDR_VAR 0 18
62238: PUSH
62239: LD_VAR 0 5
62243: PUSH
62244: LD_INT 1
62246: PPUSH
62247: LD_VAR 0 5
62251: PPUSH
62252: CALL_OW 12
62256: ARRAY
62257: ST_TO_ADDR
// end ; if weapon then
62258: LD_VAR 0 18
62262: IFFALSE 62376
// begin tmp := CostOfWeapon ( weapon ) ;
62264: LD_ADDR_VAR 0 14
62268: PUSH
62269: LD_VAR 0 18
62273: PPUSH
62274: CALL_OW 451
62278: ST_TO_ADDR
// j := GetBase ( tower ) ;
62279: LD_ADDR_VAR 0 9
62283: PUSH
62284: LD_VAR 0 1
62288: PPUSH
62289: CALL_OW 274
62293: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
62294: LD_VAR 0 9
62298: PPUSH
62299: LD_INT 1
62301: PPUSH
62302: CALL_OW 275
62306: PUSH
62307: LD_VAR 0 14
62311: PUSH
62312: LD_INT 1
62314: ARRAY
62315: GREATEREQUAL
62316: PUSH
62317: LD_VAR 0 9
62321: PPUSH
62322: LD_INT 2
62324: PPUSH
62325: CALL_OW 275
62329: PUSH
62330: LD_VAR 0 14
62334: PUSH
62335: LD_INT 2
62337: ARRAY
62338: GREATEREQUAL
62339: AND
62340: PUSH
62341: LD_VAR 0 9
62345: PPUSH
62346: LD_INT 3
62348: PPUSH
62349: CALL_OW 275
62353: PUSH
62354: LD_VAR 0 14
62358: PUSH
62359: LD_INT 3
62361: ARRAY
62362: GREATEREQUAL
62363: AND
62364: IFFALSE 62376
// result := weapon ;
62366: LD_ADDR_VAR 0 3
62370: PUSH
62371: LD_VAR 0 18
62375: ST_TO_ADDR
// end ; end ;
62376: LD_VAR 0 3
62380: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
62381: LD_INT 0
62383: PPUSH
62384: PPUSH
// result := true ;
62385: LD_ADDR_VAR 0 3
62389: PUSH
62390: LD_INT 1
62392: ST_TO_ADDR
// if array1 = array2 then
62393: LD_VAR 0 1
62397: PUSH
62398: LD_VAR 0 2
62402: EQUAL
62403: IFFALSE 62463
// begin for i = 1 to array1 do
62405: LD_ADDR_VAR 0 4
62409: PUSH
62410: DOUBLE
62411: LD_INT 1
62413: DEC
62414: ST_TO_ADDR
62415: LD_VAR 0 1
62419: PUSH
62420: FOR_TO
62421: IFFALSE 62459
// if array1 [ i ] <> array2 [ i ] then
62423: LD_VAR 0 1
62427: PUSH
62428: LD_VAR 0 4
62432: ARRAY
62433: PUSH
62434: LD_VAR 0 2
62438: PUSH
62439: LD_VAR 0 4
62443: ARRAY
62444: NONEQUAL
62445: IFFALSE 62457
// begin result := false ;
62447: LD_ADDR_VAR 0 3
62451: PUSH
62452: LD_INT 0
62454: ST_TO_ADDR
// break ;
62455: GO 62459
// end ;
62457: GO 62420
62459: POP
62460: POP
// end else
62461: GO 62471
// result := false ;
62463: LD_ADDR_VAR 0 3
62467: PUSH
62468: LD_INT 0
62470: ST_TO_ADDR
// end ;
62471: LD_VAR 0 3
62475: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
62476: LD_INT 0
62478: PPUSH
62479: PPUSH
// if not array1 or not array2 then
62480: LD_VAR 0 1
62484: NOT
62485: PUSH
62486: LD_VAR 0 2
62490: NOT
62491: OR
62492: IFFALSE 62496
// exit ;
62494: GO 62560
// result := true ;
62496: LD_ADDR_VAR 0 3
62500: PUSH
62501: LD_INT 1
62503: ST_TO_ADDR
// for i = 1 to array1 do
62504: LD_ADDR_VAR 0 4
62508: PUSH
62509: DOUBLE
62510: LD_INT 1
62512: DEC
62513: ST_TO_ADDR
62514: LD_VAR 0 1
62518: PUSH
62519: FOR_TO
62520: IFFALSE 62558
// if array1 [ i ] <> array2 [ i ] then
62522: LD_VAR 0 1
62526: PUSH
62527: LD_VAR 0 4
62531: ARRAY
62532: PUSH
62533: LD_VAR 0 2
62537: PUSH
62538: LD_VAR 0 4
62542: ARRAY
62543: NONEQUAL
62544: IFFALSE 62556
// begin result := false ;
62546: LD_ADDR_VAR 0 3
62550: PUSH
62551: LD_INT 0
62553: ST_TO_ADDR
// break ;
62554: GO 62558
// end ;
62556: GO 62519
62558: POP
62559: POP
// end ;
62560: LD_VAR 0 3
62564: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
62565: LD_INT 0
62567: PPUSH
62568: PPUSH
62569: PPUSH
// pom := GetBase ( fac ) ;
62570: LD_ADDR_VAR 0 5
62574: PUSH
62575: LD_VAR 0 1
62579: PPUSH
62580: CALL_OW 274
62584: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
62585: LD_ADDR_VAR 0 4
62589: PUSH
62590: LD_VAR 0 2
62594: PUSH
62595: LD_INT 1
62597: ARRAY
62598: PPUSH
62599: LD_VAR 0 2
62603: PUSH
62604: LD_INT 2
62606: ARRAY
62607: PPUSH
62608: LD_VAR 0 2
62612: PUSH
62613: LD_INT 3
62615: ARRAY
62616: PPUSH
62617: LD_VAR 0 2
62621: PUSH
62622: LD_INT 4
62624: ARRAY
62625: PPUSH
62626: CALL_OW 449
62630: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62631: LD_ADDR_VAR 0 3
62635: PUSH
62636: LD_VAR 0 5
62640: PPUSH
62641: LD_INT 1
62643: PPUSH
62644: CALL_OW 275
62648: PUSH
62649: LD_VAR 0 4
62653: PUSH
62654: LD_INT 1
62656: ARRAY
62657: GREATEREQUAL
62658: PUSH
62659: LD_VAR 0 5
62663: PPUSH
62664: LD_INT 2
62666: PPUSH
62667: CALL_OW 275
62671: PUSH
62672: LD_VAR 0 4
62676: PUSH
62677: LD_INT 2
62679: ARRAY
62680: GREATEREQUAL
62681: AND
62682: PUSH
62683: LD_VAR 0 5
62687: PPUSH
62688: LD_INT 3
62690: PPUSH
62691: CALL_OW 275
62695: PUSH
62696: LD_VAR 0 4
62700: PUSH
62701: LD_INT 3
62703: ARRAY
62704: GREATEREQUAL
62705: AND
62706: ST_TO_ADDR
// end ;
62707: LD_VAR 0 3
62711: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
62712: LD_INT 0
62714: PPUSH
62715: PPUSH
62716: PPUSH
62717: PPUSH
// pom := GetBase ( building ) ;
62718: LD_ADDR_VAR 0 3
62722: PUSH
62723: LD_VAR 0 1
62727: PPUSH
62728: CALL_OW 274
62732: ST_TO_ADDR
// if not pom then
62733: LD_VAR 0 3
62737: NOT
62738: IFFALSE 62742
// exit ;
62740: GO 62912
// btype := GetBType ( building ) ;
62742: LD_ADDR_VAR 0 5
62746: PUSH
62747: LD_VAR 0 1
62751: PPUSH
62752: CALL_OW 266
62756: ST_TO_ADDR
// if btype = b_armoury then
62757: LD_VAR 0 5
62761: PUSH
62762: LD_INT 4
62764: EQUAL
62765: IFFALSE 62775
// btype := b_barracks ;
62767: LD_ADDR_VAR 0 5
62771: PUSH
62772: LD_INT 5
62774: ST_TO_ADDR
// if btype = b_depot then
62775: LD_VAR 0 5
62779: PUSH
62780: LD_INT 0
62782: EQUAL
62783: IFFALSE 62793
// btype := b_warehouse ;
62785: LD_ADDR_VAR 0 5
62789: PUSH
62790: LD_INT 1
62792: ST_TO_ADDR
// if btype = b_workshop then
62793: LD_VAR 0 5
62797: PUSH
62798: LD_INT 2
62800: EQUAL
62801: IFFALSE 62811
// btype := b_factory ;
62803: LD_ADDR_VAR 0 5
62807: PUSH
62808: LD_INT 3
62810: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
62811: LD_ADDR_VAR 0 4
62815: PUSH
62816: LD_VAR 0 5
62820: PPUSH
62821: LD_VAR 0 1
62825: PPUSH
62826: CALL_OW 248
62830: PPUSH
62831: CALL_OW 450
62835: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62836: LD_ADDR_VAR 0 2
62840: PUSH
62841: LD_VAR 0 3
62845: PPUSH
62846: LD_INT 1
62848: PPUSH
62849: CALL_OW 275
62853: PUSH
62854: LD_VAR 0 4
62858: PUSH
62859: LD_INT 1
62861: ARRAY
62862: GREATEREQUAL
62863: PUSH
62864: LD_VAR 0 3
62868: PPUSH
62869: LD_INT 2
62871: PPUSH
62872: CALL_OW 275
62876: PUSH
62877: LD_VAR 0 4
62881: PUSH
62882: LD_INT 2
62884: ARRAY
62885: GREATEREQUAL
62886: AND
62887: PUSH
62888: LD_VAR 0 3
62892: PPUSH
62893: LD_INT 3
62895: PPUSH
62896: CALL_OW 275
62900: PUSH
62901: LD_VAR 0 4
62905: PUSH
62906: LD_INT 3
62908: ARRAY
62909: GREATEREQUAL
62910: AND
62911: ST_TO_ADDR
// end ;
62912: LD_VAR 0 2
62916: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
62917: LD_INT 0
62919: PPUSH
62920: PPUSH
62921: PPUSH
// pom := GetBase ( building ) ;
62922: LD_ADDR_VAR 0 4
62926: PUSH
62927: LD_VAR 0 1
62931: PPUSH
62932: CALL_OW 274
62936: ST_TO_ADDR
// if not pom then
62937: LD_VAR 0 4
62941: NOT
62942: IFFALSE 62946
// exit ;
62944: GO 63047
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
62946: LD_ADDR_VAR 0 5
62950: PUSH
62951: LD_VAR 0 2
62955: PPUSH
62956: LD_VAR 0 1
62960: PPUSH
62961: CALL_OW 248
62965: PPUSH
62966: CALL_OW 450
62970: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62971: LD_ADDR_VAR 0 3
62975: PUSH
62976: LD_VAR 0 4
62980: PPUSH
62981: LD_INT 1
62983: PPUSH
62984: CALL_OW 275
62988: PUSH
62989: LD_VAR 0 5
62993: PUSH
62994: LD_INT 1
62996: ARRAY
62997: GREATEREQUAL
62998: PUSH
62999: LD_VAR 0 4
63003: PPUSH
63004: LD_INT 2
63006: PPUSH
63007: CALL_OW 275
63011: PUSH
63012: LD_VAR 0 5
63016: PUSH
63017: LD_INT 2
63019: ARRAY
63020: GREATEREQUAL
63021: AND
63022: PUSH
63023: LD_VAR 0 4
63027: PPUSH
63028: LD_INT 3
63030: PPUSH
63031: CALL_OW 275
63035: PUSH
63036: LD_VAR 0 5
63040: PUSH
63041: LD_INT 3
63043: ARRAY
63044: GREATEREQUAL
63045: AND
63046: ST_TO_ADDR
// end ;
63047: LD_VAR 0 3
63051: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
63052: LD_INT 0
63054: PPUSH
63055: PPUSH
63056: PPUSH
63057: PPUSH
63058: PPUSH
63059: PPUSH
63060: PPUSH
63061: PPUSH
63062: PPUSH
63063: PPUSH
63064: PPUSH
// result := false ;
63065: LD_ADDR_VAR 0 8
63069: PUSH
63070: LD_INT 0
63072: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
63073: LD_VAR 0 5
63077: NOT
63078: PUSH
63079: LD_VAR 0 1
63083: NOT
63084: OR
63085: PUSH
63086: LD_VAR 0 2
63090: NOT
63091: OR
63092: PUSH
63093: LD_VAR 0 3
63097: NOT
63098: OR
63099: IFFALSE 63103
// exit ;
63101: GO 63917
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
63103: LD_ADDR_VAR 0 14
63107: PUSH
63108: LD_VAR 0 1
63112: PPUSH
63113: LD_VAR 0 2
63117: PPUSH
63118: LD_VAR 0 3
63122: PPUSH
63123: LD_VAR 0 4
63127: PPUSH
63128: LD_VAR 0 5
63132: PUSH
63133: LD_INT 1
63135: ARRAY
63136: PPUSH
63137: CALL_OW 248
63141: PPUSH
63142: LD_INT 0
63144: PPUSH
63145: CALL 65154 0 6
63149: ST_TO_ADDR
// if not hexes then
63150: LD_VAR 0 14
63154: NOT
63155: IFFALSE 63159
// exit ;
63157: GO 63917
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
63159: LD_ADDR_VAR 0 17
63163: PUSH
63164: LD_VAR 0 5
63168: PPUSH
63169: LD_INT 22
63171: PUSH
63172: LD_VAR 0 13
63176: PPUSH
63177: CALL_OW 255
63181: PUSH
63182: EMPTY
63183: LIST
63184: LIST
63185: PUSH
63186: LD_INT 2
63188: PUSH
63189: LD_INT 30
63191: PUSH
63192: LD_INT 0
63194: PUSH
63195: EMPTY
63196: LIST
63197: LIST
63198: PUSH
63199: LD_INT 30
63201: PUSH
63202: LD_INT 1
63204: PUSH
63205: EMPTY
63206: LIST
63207: LIST
63208: PUSH
63209: EMPTY
63210: LIST
63211: LIST
63212: LIST
63213: PUSH
63214: EMPTY
63215: LIST
63216: LIST
63217: PPUSH
63218: CALL_OW 72
63222: ST_TO_ADDR
// for i = 1 to hexes do
63223: LD_ADDR_VAR 0 9
63227: PUSH
63228: DOUBLE
63229: LD_INT 1
63231: DEC
63232: ST_TO_ADDR
63233: LD_VAR 0 14
63237: PUSH
63238: FOR_TO
63239: IFFALSE 63915
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
63241: LD_ADDR_VAR 0 13
63245: PUSH
63246: LD_VAR 0 14
63250: PUSH
63251: LD_VAR 0 9
63255: ARRAY
63256: PUSH
63257: LD_INT 1
63259: ARRAY
63260: PPUSH
63261: LD_VAR 0 14
63265: PUSH
63266: LD_VAR 0 9
63270: ARRAY
63271: PUSH
63272: LD_INT 2
63274: ARRAY
63275: PPUSH
63276: CALL_OW 428
63280: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
63281: LD_VAR 0 14
63285: PUSH
63286: LD_VAR 0 9
63290: ARRAY
63291: PUSH
63292: LD_INT 1
63294: ARRAY
63295: PPUSH
63296: LD_VAR 0 14
63300: PUSH
63301: LD_VAR 0 9
63305: ARRAY
63306: PUSH
63307: LD_INT 2
63309: ARRAY
63310: PPUSH
63311: CALL_OW 351
63315: PUSH
63316: LD_VAR 0 14
63320: PUSH
63321: LD_VAR 0 9
63325: ARRAY
63326: PUSH
63327: LD_INT 1
63329: ARRAY
63330: PPUSH
63331: LD_VAR 0 14
63335: PUSH
63336: LD_VAR 0 9
63340: ARRAY
63341: PUSH
63342: LD_INT 2
63344: ARRAY
63345: PPUSH
63346: CALL_OW 488
63350: NOT
63351: OR
63352: PUSH
63353: LD_VAR 0 13
63357: PPUSH
63358: CALL_OW 247
63362: PUSH
63363: LD_INT 3
63365: EQUAL
63366: OR
63367: IFFALSE 63373
// exit ;
63369: POP
63370: POP
63371: GO 63917
// if not tmp then
63373: LD_VAR 0 13
63377: NOT
63378: IFFALSE 63382
// continue ;
63380: GO 63238
// result := true ;
63382: LD_ADDR_VAR 0 8
63386: PUSH
63387: LD_INT 1
63389: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
63390: LD_VAR 0 6
63394: PUSH
63395: LD_VAR 0 13
63399: PPUSH
63400: CALL_OW 247
63404: PUSH
63405: LD_INT 2
63407: EQUAL
63408: AND
63409: PUSH
63410: LD_VAR 0 13
63414: PPUSH
63415: CALL_OW 263
63419: PUSH
63420: LD_INT 1
63422: EQUAL
63423: AND
63424: IFFALSE 63588
// begin if IsDrivenBy ( tmp ) then
63426: LD_VAR 0 13
63430: PPUSH
63431: CALL_OW 311
63435: IFFALSE 63439
// continue ;
63437: GO 63238
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
63439: LD_VAR 0 6
63443: PPUSH
63444: LD_INT 3
63446: PUSH
63447: LD_INT 60
63449: PUSH
63450: EMPTY
63451: LIST
63452: PUSH
63453: EMPTY
63454: LIST
63455: LIST
63456: PUSH
63457: LD_INT 3
63459: PUSH
63460: LD_INT 55
63462: PUSH
63463: EMPTY
63464: LIST
63465: PUSH
63466: EMPTY
63467: LIST
63468: LIST
63469: PUSH
63470: EMPTY
63471: LIST
63472: LIST
63473: PPUSH
63474: CALL_OW 72
63478: IFFALSE 63586
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
63480: LD_ADDR_VAR 0 18
63484: PUSH
63485: LD_VAR 0 6
63489: PPUSH
63490: LD_INT 3
63492: PUSH
63493: LD_INT 60
63495: PUSH
63496: EMPTY
63497: LIST
63498: PUSH
63499: EMPTY
63500: LIST
63501: LIST
63502: PUSH
63503: LD_INT 3
63505: PUSH
63506: LD_INT 55
63508: PUSH
63509: EMPTY
63510: LIST
63511: PUSH
63512: EMPTY
63513: LIST
63514: LIST
63515: PUSH
63516: EMPTY
63517: LIST
63518: LIST
63519: PPUSH
63520: CALL_OW 72
63524: PUSH
63525: LD_INT 1
63527: ARRAY
63528: ST_TO_ADDR
// if IsInUnit ( driver ) then
63529: LD_VAR 0 18
63533: PPUSH
63534: CALL_OW 310
63538: IFFALSE 63549
// ComExit ( driver ) ;
63540: LD_VAR 0 18
63544: PPUSH
63545: CALL 88338 0 1
// AddComEnterUnit ( driver , tmp ) ;
63549: LD_VAR 0 18
63553: PPUSH
63554: LD_VAR 0 13
63558: PPUSH
63559: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
63563: LD_VAR 0 18
63567: PPUSH
63568: LD_VAR 0 7
63572: PPUSH
63573: CALL_OW 173
// AddComExitVehicle ( driver ) ;
63577: LD_VAR 0 18
63581: PPUSH
63582: CALL_OW 181
// end ; continue ;
63586: GO 63238
// end ; if not cleaners or not tmp in cleaners then
63588: LD_VAR 0 6
63592: NOT
63593: PUSH
63594: LD_VAR 0 13
63598: PUSH
63599: LD_VAR 0 6
63603: IN
63604: NOT
63605: OR
63606: IFFALSE 63913
// begin if dep then
63608: LD_VAR 0 17
63612: IFFALSE 63748
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
63614: LD_ADDR_VAR 0 16
63618: PUSH
63619: LD_VAR 0 17
63623: PUSH
63624: LD_INT 1
63626: ARRAY
63627: PPUSH
63628: CALL_OW 250
63632: PPUSH
63633: LD_VAR 0 17
63637: PUSH
63638: LD_INT 1
63640: ARRAY
63641: PPUSH
63642: CALL_OW 254
63646: PPUSH
63647: LD_INT 5
63649: PPUSH
63650: CALL_OW 272
63654: PUSH
63655: LD_VAR 0 17
63659: PUSH
63660: LD_INT 1
63662: ARRAY
63663: PPUSH
63664: CALL_OW 251
63668: PPUSH
63669: LD_VAR 0 17
63673: PUSH
63674: LD_INT 1
63676: ARRAY
63677: PPUSH
63678: CALL_OW 254
63682: PPUSH
63683: LD_INT 5
63685: PPUSH
63686: CALL_OW 273
63690: PUSH
63691: EMPTY
63692: LIST
63693: LIST
63694: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
63695: LD_VAR 0 16
63699: PUSH
63700: LD_INT 1
63702: ARRAY
63703: PPUSH
63704: LD_VAR 0 16
63708: PUSH
63709: LD_INT 2
63711: ARRAY
63712: PPUSH
63713: CALL_OW 488
63717: IFFALSE 63748
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
63719: LD_VAR 0 13
63723: PPUSH
63724: LD_VAR 0 16
63728: PUSH
63729: LD_INT 1
63731: ARRAY
63732: PPUSH
63733: LD_VAR 0 16
63737: PUSH
63738: LD_INT 2
63740: ARRAY
63741: PPUSH
63742: CALL_OW 111
// continue ;
63746: GO 63238
// end ; end ; r := GetDir ( tmp ) ;
63748: LD_ADDR_VAR 0 15
63752: PUSH
63753: LD_VAR 0 13
63757: PPUSH
63758: CALL_OW 254
63762: ST_TO_ADDR
// if r = 5 then
63763: LD_VAR 0 15
63767: PUSH
63768: LD_INT 5
63770: EQUAL
63771: IFFALSE 63781
// r := 0 ;
63773: LD_ADDR_VAR 0 15
63777: PUSH
63778: LD_INT 0
63780: ST_TO_ADDR
// for j = r to 5 do
63781: LD_ADDR_VAR 0 10
63785: PUSH
63786: DOUBLE
63787: LD_VAR 0 15
63791: DEC
63792: ST_TO_ADDR
63793: LD_INT 5
63795: PUSH
63796: FOR_TO
63797: IFFALSE 63911
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
63799: LD_ADDR_VAR 0 11
63803: PUSH
63804: LD_VAR 0 13
63808: PPUSH
63809: CALL_OW 250
63813: PPUSH
63814: LD_VAR 0 10
63818: PPUSH
63819: LD_INT 2
63821: PPUSH
63822: CALL_OW 272
63826: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
63827: LD_ADDR_VAR 0 12
63831: PUSH
63832: LD_VAR 0 13
63836: PPUSH
63837: CALL_OW 251
63841: PPUSH
63842: LD_VAR 0 10
63846: PPUSH
63847: LD_INT 2
63849: PPUSH
63850: CALL_OW 273
63854: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
63855: LD_VAR 0 11
63859: PPUSH
63860: LD_VAR 0 12
63864: PPUSH
63865: CALL_OW 488
63869: PUSH
63870: LD_VAR 0 11
63874: PPUSH
63875: LD_VAR 0 12
63879: PPUSH
63880: CALL_OW 428
63884: NOT
63885: AND
63886: IFFALSE 63909
// begin ComMoveXY ( tmp , _x , _y ) ;
63888: LD_VAR 0 13
63892: PPUSH
63893: LD_VAR 0 11
63897: PPUSH
63898: LD_VAR 0 12
63902: PPUSH
63903: CALL_OW 111
// break ;
63907: GO 63911
// end ; end ;
63909: GO 63796
63911: POP
63912: POP
// end ; end ;
63913: GO 63238
63915: POP
63916: POP
// end ;
63917: LD_VAR 0 8
63921: RET
// export function BuildingTechInvented ( side , btype ) ; begin
63922: LD_INT 0
63924: PPUSH
// result := true ;
63925: LD_ADDR_VAR 0 3
63929: PUSH
63930: LD_INT 1
63932: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
63933: LD_VAR 0 2
63937: PUSH
63938: LD_INT 24
63940: DOUBLE
63941: EQUAL
63942: IFTRUE 63952
63944: LD_INT 33
63946: DOUBLE
63947: EQUAL
63948: IFTRUE 63952
63950: GO 63977
63952: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
63953: LD_ADDR_VAR 0 3
63957: PUSH
63958: LD_INT 32
63960: PPUSH
63961: LD_VAR 0 1
63965: PPUSH
63966: CALL_OW 321
63970: PUSH
63971: LD_INT 2
63973: EQUAL
63974: ST_TO_ADDR
63975: GO 64297
63977: LD_INT 20
63979: DOUBLE
63980: EQUAL
63981: IFTRUE 63985
63983: GO 64010
63985: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
63986: LD_ADDR_VAR 0 3
63990: PUSH
63991: LD_INT 6
63993: PPUSH
63994: LD_VAR 0 1
63998: PPUSH
63999: CALL_OW 321
64003: PUSH
64004: LD_INT 2
64006: EQUAL
64007: ST_TO_ADDR
64008: GO 64297
64010: LD_INT 22
64012: DOUBLE
64013: EQUAL
64014: IFTRUE 64024
64016: LD_INT 36
64018: DOUBLE
64019: EQUAL
64020: IFTRUE 64024
64022: GO 64049
64024: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
64025: LD_ADDR_VAR 0 3
64029: PUSH
64030: LD_INT 15
64032: PPUSH
64033: LD_VAR 0 1
64037: PPUSH
64038: CALL_OW 321
64042: PUSH
64043: LD_INT 2
64045: EQUAL
64046: ST_TO_ADDR
64047: GO 64297
64049: LD_INT 30
64051: DOUBLE
64052: EQUAL
64053: IFTRUE 64057
64055: GO 64082
64057: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
64058: LD_ADDR_VAR 0 3
64062: PUSH
64063: LD_INT 20
64065: PPUSH
64066: LD_VAR 0 1
64070: PPUSH
64071: CALL_OW 321
64075: PUSH
64076: LD_INT 2
64078: EQUAL
64079: ST_TO_ADDR
64080: GO 64297
64082: LD_INT 28
64084: DOUBLE
64085: EQUAL
64086: IFTRUE 64096
64088: LD_INT 21
64090: DOUBLE
64091: EQUAL
64092: IFTRUE 64096
64094: GO 64121
64096: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
64097: LD_ADDR_VAR 0 3
64101: PUSH
64102: LD_INT 21
64104: PPUSH
64105: LD_VAR 0 1
64109: PPUSH
64110: CALL_OW 321
64114: PUSH
64115: LD_INT 2
64117: EQUAL
64118: ST_TO_ADDR
64119: GO 64297
64121: LD_INT 16
64123: DOUBLE
64124: EQUAL
64125: IFTRUE 64129
64127: GO 64156
64129: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
64130: LD_ADDR_VAR 0 3
64134: PUSH
64135: LD_EXP 84
64139: PPUSH
64140: LD_VAR 0 1
64144: PPUSH
64145: CALL_OW 321
64149: PUSH
64150: LD_INT 2
64152: EQUAL
64153: ST_TO_ADDR
64154: GO 64297
64156: LD_INT 19
64158: DOUBLE
64159: EQUAL
64160: IFTRUE 64170
64162: LD_INT 23
64164: DOUBLE
64165: EQUAL
64166: IFTRUE 64170
64168: GO 64197
64170: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
64171: LD_ADDR_VAR 0 3
64175: PUSH
64176: LD_EXP 83
64180: PPUSH
64181: LD_VAR 0 1
64185: PPUSH
64186: CALL_OW 321
64190: PUSH
64191: LD_INT 2
64193: EQUAL
64194: ST_TO_ADDR
64195: GO 64297
64197: LD_INT 17
64199: DOUBLE
64200: EQUAL
64201: IFTRUE 64205
64203: GO 64230
64205: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
64206: LD_ADDR_VAR 0 3
64210: PUSH
64211: LD_INT 39
64213: PPUSH
64214: LD_VAR 0 1
64218: PPUSH
64219: CALL_OW 321
64223: PUSH
64224: LD_INT 2
64226: EQUAL
64227: ST_TO_ADDR
64228: GO 64297
64230: LD_INT 18
64232: DOUBLE
64233: EQUAL
64234: IFTRUE 64238
64236: GO 64263
64238: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
64239: LD_ADDR_VAR 0 3
64243: PUSH
64244: LD_INT 40
64246: PPUSH
64247: LD_VAR 0 1
64251: PPUSH
64252: CALL_OW 321
64256: PUSH
64257: LD_INT 2
64259: EQUAL
64260: ST_TO_ADDR
64261: GO 64297
64263: LD_INT 27
64265: DOUBLE
64266: EQUAL
64267: IFTRUE 64271
64269: GO 64296
64271: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
64272: LD_ADDR_VAR 0 3
64276: PUSH
64277: LD_INT 35
64279: PPUSH
64280: LD_VAR 0 1
64284: PPUSH
64285: CALL_OW 321
64289: PUSH
64290: LD_INT 2
64292: EQUAL
64293: ST_TO_ADDR
64294: GO 64297
64296: POP
// end ;
64297: LD_VAR 0 3
64301: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
64302: LD_INT 0
64304: PPUSH
64305: PPUSH
64306: PPUSH
64307: PPUSH
64308: PPUSH
64309: PPUSH
64310: PPUSH
64311: PPUSH
64312: PPUSH
64313: PPUSH
64314: PPUSH
// result := false ;
64315: LD_ADDR_VAR 0 6
64319: PUSH
64320: LD_INT 0
64322: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
64323: LD_VAR 0 1
64327: NOT
64328: PUSH
64329: LD_VAR 0 1
64333: PPUSH
64334: CALL_OW 266
64338: PUSH
64339: LD_INT 0
64341: PUSH
64342: LD_INT 1
64344: PUSH
64345: EMPTY
64346: LIST
64347: LIST
64348: IN
64349: NOT
64350: OR
64351: PUSH
64352: LD_VAR 0 2
64356: NOT
64357: OR
64358: PUSH
64359: LD_VAR 0 5
64363: PUSH
64364: LD_INT 0
64366: PUSH
64367: LD_INT 1
64369: PUSH
64370: LD_INT 2
64372: PUSH
64373: LD_INT 3
64375: PUSH
64376: LD_INT 4
64378: PUSH
64379: LD_INT 5
64381: PUSH
64382: EMPTY
64383: LIST
64384: LIST
64385: LIST
64386: LIST
64387: LIST
64388: LIST
64389: IN
64390: NOT
64391: OR
64392: PUSH
64393: LD_VAR 0 3
64397: PPUSH
64398: LD_VAR 0 4
64402: PPUSH
64403: CALL_OW 488
64407: NOT
64408: OR
64409: IFFALSE 64413
// exit ;
64411: GO 65149
// side := GetSide ( depot ) ;
64413: LD_ADDR_VAR 0 9
64417: PUSH
64418: LD_VAR 0 1
64422: PPUSH
64423: CALL_OW 255
64427: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
64428: LD_VAR 0 9
64432: PPUSH
64433: LD_VAR 0 2
64437: PPUSH
64438: CALL 63922 0 2
64442: NOT
64443: IFFALSE 64447
// exit ;
64445: GO 65149
// pom := GetBase ( depot ) ;
64447: LD_ADDR_VAR 0 10
64451: PUSH
64452: LD_VAR 0 1
64456: PPUSH
64457: CALL_OW 274
64461: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
64462: LD_ADDR_VAR 0 11
64466: PUSH
64467: LD_VAR 0 2
64471: PPUSH
64472: LD_VAR 0 1
64476: PPUSH
64477: CALL_OW 248
64481: PPUSH
64482: CALL_OW 450
64486: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
64487: LD_VAR 0 10
64491: PPUSH
64492: LD_INT 1
64494: PPUSH
64495: CALL_OW 275
64499: PUSH
64500: LD_VAR 0 11
64504: PUSH
64505: LD_INT 1
64507: ARRAY
64508: GREATEREQUAL
64509: PUSH
64510: LD_VAR 0 10
64514: PPUSH
64515: LD_INT 2
64517: PPUSH
64518: CALL_OW 275
64522: PUSH
64523: LD_VAR 0 11
64527: PUSH
64528: LD_INT 2
64530: ARRAY
64531: GREATEREQUAL
64532: AND
64533: PUSH
64534: LD_VAR 0 10
64538: PPUSH
64539: LD_INT 3
64541: PPUSH
64542: CALL_OW 275
64546: PUSH
64547: LD_VAR 0 11
64551: PUSH
64552: LD_INT 3
64554: ARRAY
64555: GREATEREQUAL
64556: AND
64557: NOT
64558: IFFALSE 64562
// exit ;
64560: GO 65149
// if GetBType ( depot ) = b_depot then
64562: LD_VAR 0 1
64566: PPUSH
64567: CALL_OW 266
64571: PUSH
64572: LD_INT 0
64574: EQUAL
64575: IFFALSE 64587
// dist := 28 else
64577: LD_ADDR_VAR 0 14
64581: PUSH
64582: LD_INT 28
64584: ST_TO_ADDR
64585: GO 64595
// dist := 36 ;
64587: LD_ADDR_VAR 0 14
64591: PUSH
64592: LD_INT 36
64594: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
64595: LD_VAR 0 1
64599: PPUSH
64600: LD_VAR 0 3
64604: PPUSH
64605: LD_VAR 0 4
64609: PPUSH
64610: CALL_OW 297
64614: PUSH
64615: LD_VAR 0 14
64619: GREATER
64620: IFFALSE 64624
// exit ;
64622: GO 65149
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
64624: LD_ADDR_VAR 0 12
64628: PUSH
64629: LD_VAR 0 2
64633: PPUSH
64634: LD_VAR 0 3
64638: PPUSH
64639: LD_VAR 0 4
64643: PPUSH
64644: LD_VAR 0 5
64648: PPUSH
64649: LD_VAR 0 1
64653: PPUSH
64654: CALL_OW 248
64658: PPUSH
64659: LD_INT 0
64661: PPUSH
64662: CALL 65154 0 6
64666: ST_TO_ADDR
// if not hexes then
64667: LD_VAR 0 12
64671: NOT
64672: IFFALSE 64676
// exit ;
64674: GO 65149
// hex := GetHexInfo ( x , y ) ;
64676: LD_ADDR_VAR 0 15
64680: PUSH
64681: LD_VAR 0 3
64685: PPUSH
64686: LD_VAR 0 4
64690: PPUSH
64691: CALL_OW 546
64695: ST_TO_ADDR
// if hex [ 1 ] then
64696: LD_VAR 0 15
64700: PUSH
64701: LD_INT 1
64703: ARRAY
64704: IFFALSE 64708
// exit ;
64706: GO 65149
// height := hex [ 2 ] ;
64708: LD_ADDR_VAR 0 13
64712: PUSH
64713: LD_VAR 0 15
64717: PUSH
64718: LD_INT 2
64720: ARRAY
64721: ST_TO_ADDR
// for i = 1 to hexes do
64722: LD_ADDR_VAR 0 7
64726: PUSH
64727: DOUBLE
64728: LD_INT 1
64730: DEC
64731: ST_TO_ADDR
64732: LD_VAR 0 12
64736: PUSH
64737: FOR_TO
64738: IFFALSE 65068
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
64740: LD_VAR 0 12
64744: PUSH
64745: LD_VAR 0 7
64749: ARRAY
64750: PUSH
64751: LD_INT 1
64753: ARRAY
64754: PPUSH
64755: LD_VAR 0 12
64759: PUSH
64760: LD_VAR 0 7
64764: ARRAY
64765: PUSH
64766: LD_INT 2
64768: ARRAY
64769: PPUSH
64770: CALL_OW 488
64774: NOT
64775: PUSH
64776: LD_VAR 0 12
64780: PUSH
64781: LD_VAR 0 7
64785: ARRAY
64786: PUSH
64787: LD_INT 1
64789: ARRAY
64790: PPUSH
64791: LD_VAR 0 12
64795: PUSH
64796: LD_VAR 0 7
64800: ARRAY
64801: PUSH
64802: LD_INT 2
64804: ARRAY
64805: PPUSH
64806: CALL_OW 428
64810: PUSH
64811: LD_INT 0
64813: GREATER
64814: OR
64815: PUSH
64816: LD_VAR 0 12
64820: PUSH
64821: LD_VAR 0 7
64825: ARRAY
64826: PUSH
64827: LD_INT 1
64829: ARRAY
64830: PPUSH
64831: LD_VAR 0 12
64835: PUSH
64836: LD_VAR 0 7
64840: ARRAY
64841: PUSH
64842: LD_INT 2
64844: ARRAY
64845: PPUSH
64846: CALL_OW 351
64850: OR
64851: IFFALSE 64857
// exit ;
64853: POP
64854: POP
64855: GO 65149
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
64857: LD_ADDR_VAR 0 8
64861: PUSH
64862: LD_VAR 0 12
64866: PUSH
64867: LD_VAR 0 7
64871: ARRAY
64872: PUSH
64873: LD_INT 1
64875: ARRAY
64876: PPUSH
64877: LD_VAR 0 12
64881: PUSH
64882: LD_VAR 0 7
64886: ARRAY
64887: PUSH
64888: LD_INT 2
64890: ARRAY
64891: PPUSH
64892: CALL_OW 546
64896: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
64897: LD_VAR 0 8
64901: PUSH
64902: LD_INT 1
64904: ARRAY
64905: PUSH
64906: LD_VAR 0 8
64910: PUSH
64911: LD_INT 2
64913: ARRAY
64914: PUSH
64915: LD_VAR 0 13
64919: PUSH
64920: LD_INT 2
64922: PLUS
64923: GREATER
64924: OR
64925: PUSH
64926: LD_VAR 0 8
64930: PUSH
64931: LD_INT 2
64933: ARRAY
64934: PUSH
64935: LD_VAR 0 13
64939: PUSH
64940: LD_INT 2
64942: MINUS
64943: LESS
64944: OR
64945: PUSH
64946: LD_VAR 0 8
64950: PUSH
64951: LD_INT 3
64953: ARRAY
64954: PUSH
64955: LD_INT 0
64957: PUSH
64958: LD_INT 8
64960: PUSH
64961: LD_INT 9
64963: PUSH
64964: LD_INT 10
64966: PUSH
64967: LD_INT 11
64969: PUSH
64970: LD_INT 12
64972: PUSH
64973: LD_INT 13
64975: PUSH
64976: LD_INT 16
64978: PUSH
64979: LD_INT 17
64981: PUSH
64982: LD_INT 18
64984: PUSH
64985: LD_INT 19
64987: PUSH
64988: LD_INT 20
64990: PUSH
64991: LD_INT 21
64993: PUSH
64994: EMPTY
64995: LIST
64996: LIST
64997: LIST
64998: LIST
64999: LIST
65000: LIST
65001: LIST
65002: LIST
65003: LIST
65004: LIST
65005: LIST
65006: LIST
65007: LIST
65008: IN
65009: NOT
65010: OR
65011: PUSH
65012: LD_VAR 0 8
65016: PUSH
65017: LD_INT 5
65019: ARRAY
65020: NOT
65021: OR
65022: PUSH
65023: LD_VAR 0 8
65027: PUSH
65028: LD_INT 6
65030: ARRAY
65031: PUSH
65032: LD_INT 1
65034: PUSH
65035: LD_INT 2
65037: PUSH
65038: LD_INT 7
65040: PUSH
65041: LD_INT 9
65043: PUSH
65044: LD_INT 10
65046: PUSH
65047: LD_INT 11
65049: PUSH
65050: EMPTY
65051: LIST
65052: LIST
65053: LIST
65054: LIST
65055: LIST
65056: LIST
65057: IN
65058: NOT
65059: OR
65060: IFFALSE 65066
// exit ;
65062: POP
65063: POP
65064: GO 65149
// end ;
65066: GO 64737
65068: POP
65069: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
65070: LD_VAR 0 9
65074: PPUSH
65075: LD_VAR 0 3
65079: PPUSH
65080: LD_VAR 0 4
65084: PPUSH
65085: LD_INT 20
65087: PPUSH
65088: CALL 57094 0 4
65092: PUSH
65093: LD_INT 4
65095: ARRAY
65096: IFFALSE 65100
// exit ;
65098: GO 65149
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
65100: LD_VAR 0 2
65104: PUSH
65105: LD_INT 29
65107: PUSH
65108: LD_INT 30
65110: PUSH
65111: EMPTY
65112: LIST
65113: LIST
65114: IN
65115: PUSH
65116: LD_VAR 0 3
65120: PPUSH
65121: LD_VAR 0 4
65125: PPUSH
65126: LD_VAR 0 9
65130: PPUSH
65131: CALL_OW 440
65135: NOT
65136: AND
65137: IFFALSE 65141
// exit ;
65139: GO 65149
// result := true ;
65141: LD_ADDR_VAR 0 6
65145: PUSH
65146: LD_INT 1
65148: ST_TO_ADDR
// end ;
65149: LD_VAR 0 6
65153: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
65154: LD_INT 0
65156: PPUSH
65157: PPUSH
65158: PPUSH
65159: PPUSH
65160: PPUSH
65161: PPUSH
65162: PPUSH
65163: PPUSH
65164: PPUSH
65165: PPUSH
65166: PPUSH
65167: PPUSH
65168: PPUSH
65169: PPUSH
65170: PPUSH
65171: PPUSH
65172: PPUSH
65173: PPUSH
65174: PPUSH
65175: PPUSH
65176: PPUSH
65177: PPUSH
65178: PPUSH
65179: PPUSH
65180: PPUSH
65181: PPUSH
65182: PPUSH
65183: PPUSH
65184: PPUSH
65185: PPUSH
65186: PPUSH
65187: PPUSH
65188: PPUSH
65189: PPUSH
65190: PPUSH
65191: PPUSH
65192: PPUSH
65193: PPUSH
65194: PPUSH
65195: PPUSH
65196: PPUSH
65197: PPUSH
65198: PPUSH
65199: PPUSH
65200: PPUSH
65201: PPUSH
65202: PPUSH
65203: PPUSH
65204: PPUSH
65205: PPUSH
65206: PPUSH
65207: PPUSH
65208: PPUSH
65209: PPUSH
65210: PPUSH
65211: PPUSH
65212: PPUSH
65213: PPUSH
// result = [ ] ;
65214: LD_ADDR_VAR 0 7
65218: PUSH
65219: EMPTY
65220: ST_TO_ADDR
// temp_list = [ ] ;
65221: LD_ADDR_VAR 0 9
65225: PUSH
65226: EMPTY
65227: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
65228: LD_VAR 0 4
65232: PUSH
65233: LD_INT 0
65235: PUSH
65236: LD_INT 1
65238: PUSH
65239: LD_INT 2
65241: PUSH
65242: LD_INT 3
65244: PUSH
65245: LD_INT 4
65247: PUSH
65248: LD_INT 5
65250: PUSH
65251: EMPTY
65252: LIST
65253: LIST
65254: LIST
65255: LIST
65256: LIST
65257: LIST
65258: IN
65259: NOT
65260: PUSH
65261: LD_VAR 0 1
65265: PUSH
65266: LD_INT 0
65268: PUSH
65269: LD_INT 1
65271: PUSH
65272: EMPTY
65273: LIST
65274: LIST
65275: IN
65276: PUSH
65277: LD_VAR 0 5
65281: PUSH
65282: LD_INT 1
65284: PUSH
65285: LD_INT 2
65287: PUSH
65288: LD_INT 3
65290: PUSH
65291: EMPTY
65292: LIST
65293: LIST
65294: LIST
65295: IN
65296: NOT
65297: AND
65298: OR
65299: IFFALSE 65303
// exit ;
65301: GO 83694
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
65303: LD_VAR 0 1
65307: PUSH
65308: LD_INT 6
65310: PUSH
65311: LD_INT 7
65313: PUSH
65314: LD_INT 8
65316: PUSH
65317: LD_INT 13
65319: PUSH
65320: LD_INT 12
65322: PUSH
65323: LD_INT 15
65325: PUSH
65326: LD_INT 11
65328: PUSH
65329: LD_INT 14
65331: PUSH
65332: LD_INT 10
65334: PUSH
65335: EMPTY
65336: LIST
65337: LIST
65338: LIST
65339: LIST
65340: LIST
65341: LIST
65342: LIST
65343: LIST
65344: LIST
65345: IN
65346: IFFALSE 65356
// btype = b_lab ;
65348: LD_ADDR_VAR 0 1
65352: PUSH
65353: LD_INT 6
65355: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
65356: LD_VAR 0 6
65360: PUSH
65361: LD_INT 0
65363: PUSH
65364: LD_INT 1
65366: PUSH
65367: LD_INT 2
65369: PUSH
65370: EMPTY
65371: LIST
65372: LIST
65373: LIST
65374: IN
65375: NOT
65376: PUSH
65377: LD_VAR 0 1
65381: PUSH
65382: LD_INT 0
65384: PUSH
65385: LD_INT 1
65387: PUSH
65388: LD_INT 2
65390: PUSH
65391: LD_INT 3
65393: PUSH
65394: LD_INT 6
65396: PUSH
65397: LD_INT 36
65399: PUSH
65400: LD_INT 4
65402: PUSH
65403: LD_INT 5
65405: PUSH
65406: LD_INT 31
65408: PUSH
65409: LD_INT 32
65411: PUSH
65412: LD_INT 33
65414: PUSH
65415: EMPTY
65416: LIST
65417: LIST
65418: LIST
65419: LIST
65420: LIST
65421: LIST
65422: LIST
65423: LIST
65424: LIST
65425: LIST
65426: LIST
65427: IN
65428: NOT
65429: PUSH
65430: LD_VAR 0 6
65434: PUSH
65435: LD_INT 1
65437: EQUAL
65438: AND
65439: OR
65440: PUSH
65441: LD_VAR 0 1
65445: PUSH
65446: LD_INT 2
65448: PUSH
65449: LD_INT 3
65451: PUSH
65452: EMPTY
65453: LIST
65454: LIST
65455: IN
65456: NOT
65457: PUSH
65458: LD_VAR 0 6
65462: PUSH
65463: LD_INT 2
65465: EQUAL
65466: AND
65467: OR
65468: IFFALSE 65478
// mode = 0 ;
65470: LD_ADDR_VAR 0 6
65474: PUSH
65475: LD_INT 0
65477: ST_TO_ADDR
// case mode of 0 :
65478: LD_VAR 0 6
65482: PUSH
65483: LD_INT 0
65485: DOUBLE
65486: EQUAL
65487: IFTRUE 65491
65489: GO 76944
65491: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
65492: LD_ADDR_VAR 0 11
65496: PUSH
65497: LD_INT 0
65499: PUSH
65500: LD_INT 0
65502: PUSH
65503: EMPTY
65504: LIST
65505: LIST
65506: PUSH
65507: LD_INT 0
65509: PUSH
65510: LD_INT 1
65512: NEG
65513: PUSH
65514: EMPTY
65515: LIST
65516: LIST
65517: PUSH
65518: LD_INT 1
65520: PUSH
65521: LD_INT 0
65523: PUSH
65524: EMPTY
65525: LIST
65526: LIST
65527: PUSH
65528: LD_INT 1
65530: PUSH
65531: LD_INT 1
65533: PUSH
65534: EMPTY
65535: LIST
65536: LIST
65537: PUSH
65538: LD_INT 0
65540: PUSH
65541: LD_INT 1
65543: PUSH
65544: EMPTY
65545: LIST
65546: LIST
65547: PUSH
65548: LD_INT 1
65550: NEG
65551: PUSH
65552: LD_INT 0
65554: PUSH
65555: EMPTY
65556: LIST
65557: LIST
65558: PUSH
65559: LD_INT 1
65561: NEG
65562: PUSH
65563: LD_INT 1
65565: NEG
65566: PUSH
65567: EMPTY
65568: LIST
65569: LIST
65570: PUSH
65571: LD_INT 1
65573: NEG
65574: PUSH
65575: LD_INT 2
65577: NEG
65578: PUSH
65579: EMPTY
65580: LIST
65581: LIST
65582: PUSH
65583: LD_INT 0
65585: PUSH
65586: LD_INT 2
65588: NEG
65589: PUSH
65590: EMPTY
65591: LIST
65592: LIST
65593: PUSH
65594: LD_INT 1
65596: PUSH
65597: LD_INT 1
65599: NEG
65600: PUSH
65601: EMPTY
65602: LIST
65603: LIST
65604: PUSH
65605: LD_INT 1
65607: PUSH
65608: LD_INT 2
65610: PUSH
65611: EMPTY
65612: LIST
65613: LIST
65614: PUSH
65615: LD_INT 0
65617: PUSH
65618: LD_INT 2
65620: PUSH
65621: EMPTY
65622: LIST
65623: LIST
65624: PUSH
65625: LD_INT 1
65627: NEG
65628: PUSH
65629: LD_INT 1
65631: PUSH
65632: EMPTY
65633: LIST
65634: LIST
65635: PUSH
65636: LD_INT 1
65638: PUSH
65639: LD_INT 3
65641: PUSH
65642: EMPTY
65643: LIST
65644: LIST
65645: PUSH
65646: LD_INT 0
65648: PUSH
65649: LD_INT 3
65651: PUSH
65652: EMPTY
65653: LIST
65654: LIST
65655: PUSH
65656: LD_INT 1
65658: NEG
65659: PUSH
65660: LD_INT 2
65662: PUSH
65663: EMPTY
65664: LIST
65665: LIST
65666: PUSH
65667: EMPTY
65668: LIST
65669: LIST
65670: LIST
65671: LIST
65672: LIST
65673: LIST
65674: LIST
65675: LIST
65676: LIST
65677: LIST
65678: LIST
65679: LIST
65680: LIST
65681: LIST
65682: LIST
65683: LIST
65684: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
65685: LD_ADDR_VAR 0 12
65689: PUSH
65690: LD_INT 0
65692: PUSH
65693: LD_INT 0
65695: PUSH
65696: EMPTY
65697: LIST
65698: LIST
65699: PUSH
65700: LD_INT 0
65702: PUSH
65703: LD_INT 1
65705: NEG
65706: PUSH
65707: EMPTY
65708: LIST
65709: LIST
65710: PUSH
65711: LD_INT 1
65713: PUSH
65714: LD_INT 0
65716: PUSH
65717: EMPTY
65718: LIST
65719: LIST
65720: PUSH
65721: LD_INT 1
65723: PUSH
65724: LD_INT 1
65726: PUSH
65727: EMPTY
65728: LIST
65729: LIST
65730: PUSH
65731: LD_INT 0
65733: PUSH
65734: LD_INT 1
65736: PUSH
65737: EMPTY
65738: LIST
65739: LIST
65740: PUSH
65741: LD_INT 1
65743: NEG
65744: PUSH
65745: LD_INT 0
65747: PUSH
65748: EMPTY
65749: LIST
65750: LIST
65751: PUSH
65752: LD_INT 1
65754: NEG
65755: PUSH
65756: LD_INT 1
65758: NEG
65759: PUSH
65760: EMPTY
65761: LIST
65762: LIST
65763: PUSH
65764: LD_INT 1
65766: PUSH
65767: LD_INT 1
65769: NEG
65770: PUSH
65771: EMPTY
65772: LIST
65773: LIST
65774: PUSH
65775: LD_INT 2
65777: PUSH
65778: LD_INT 0
65780: PUSH
65781: EMPTY
65782: LIST
65783: LIST
65784: PUSH
65785: LD_INT 2
65787: PUSH
65788: LD_INT 1
65790: PUSH
65791: EMPTY
65792: LIST
65793: LIST
65794: PUSH
65795: LD_INT 1
65797: NEG
65798: PUSH
65799: LD_INT 1
65801: PUSH
65802: EMPTY
65803: LIST
65804: LIST
65805: PUSH
65806: LD_INT 2
65808: NEG
65809: PUSH
65810: LD_INT 0
65812: PUSH
65813: EMPTY
65814: LIST
65815: LIST
65816: PUSH
65817: LD_INT 2
65819: NEG
65820: PUSH
65821: LD_INT 1
65823: NEG
65824: PUSH
65825: EMPTY
65826: LIST
65827: LIST
65828: PUSH
65829: LD_INT 2
65831: NEG
65832: PUSH
65833: LD_INT 1
65835: PUSH
65836: EMPTY
65837: LIST
65838: LIST
65839: PUSH
65840: LD_INT 3
65842: NEG
65843: PUSH
65844: LD_INT 0
65846: PUSH
65847: EMPTY
65848: LIST
65849: LIST
65850: PUSH
65851: LD_INT 3
65853: NEG
65854: PUSH
65855: LD_INT 1
65857: NEG
65858: PUSH
65859: EMPTY
65860: LIST
65861: LIST
65862: PUSH
65863: EMPTY
65864: LIST
65865: LIST
65866: LIST
65867: LIST
65868: LIST
65869: LIST
65870: LIST
65871: LIST
65872: LIST
65873: LIST
65874: LIST
65875: LIST
65876: LIST
65877: LIST
65878: LIST
65879: LIST
65880: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
65881: LD_ADDR_VAR 0 13
65885: PUSH
65886: LD_INT 0
65888: PUSH
65889: LD_INT 0
65891: PUSH
65892: EMPTY
65893: LIST
65894: LIST
65895: PUSH
65896: LD_INT 0
65898: PUSH
65899: LD_INT 1
65901: NEG
65902: PUSH
65903: EMPTY
65904: LIST
65905: LIST
65906: PUSH
65907: LD_INT 1
65909: PUSH
65910: LD_INT 0
65912: PUSH
65913: EMPTY
65914: LIST
65915: LIST
65916: PUSH
65917: LD_INT 1
65919: PUSH
65920: LD_INT 1
65922: PUSH
65923: EMPTY
65924: LIST
65925: LIST
65926: PUSH
65927: LD_INT 0
65929: PUSH
65930: LD_INT 1
65932: PUSH
65933: EMPTY
65934: LIST
65935: LIST
65936: PUSH
65937: LD_INT 1
65939: NEG
65940: PUSH
65941: LD_INT 0
65943: PUSH
65944: EMPTY
65945: LIST
65946: LIST
65947: PUSH
65948: LD_INT 1
65950: NEG
65951: PUSH
65952: LD_INT 1
65954: NEG
65955: PUSH
65956: EMPTY
65957: LIST
65958: LIST
65959: PUSH
65960: LD_INT 1
65962: NEG
65963: PUSH
65964: LD_INT 2
65966: NEG
65967: PUSH
65968: EMPTY
65969: LIST
65970: LIST
65971: PUSH
65972: LD_INT 2
65974: PUSH
65975: LD_INT 1
65977: PUSH
65978: EMPTY
65979: LIST
65980: LIST
65981: PUSH
65982: LD_INT 2
65984: PUSH
65985: LD_INT 2
65987: PUSH
65988: EMPTY
65989: LIST
65990: LIST
65991: PUSH
65992: LD_INT 1
65994: PUSH
65995: LD_INT 2
65997: PUSH
65998: EMPTY
65999: LIST
66000: LIST
66001: PUSH
66002: LD_INT 2
66004: NEG
66005: PUSH
66006: LD_INT 1
66008: NEG
66009: PUSH
66010: EMPTY
66011: LIST
66012: LIST
66013: PUSH
66014: LD_INT 2
66016: NEG
66017: PUSH
66018: LD_INT 2
66020: NEG
66021: PUSH
66022: EMPTY
66023: LIST
66024: LIST
66025: PUSH
66026: LD_INT 2
66028: NEG
66029: PUSH
66030: LD_INT 3
66032: NEG
66033: PUSH
66034: EMPTY
66035: LIST
66036: LIST
66037: PUSH
66038: LD_INT 3
66040: NEG
66041: PUSH
66042: LD_INT 2
66044: NEG
66045: PUSH
66046: EMPTY
66047: LIST
66048: LIST
66049: PUSH
66050: LD_INT 3
66052: NEG
66053: PUSH
66054: LD_INT 3
66056: NEG
66057: PUSH
66058: EMPTY
66059: LIST
66060: LIST
66061: PUSH
66062: EMPTY
66063: LIST
66064: LIST
66065: LIST
66066: LIST
66067: LIST
66068: LIST
66069: LIST
66070: LIST
66071: LIST
66072: LIST
66073: LIST
66074: LIST
66075: LIST
66076: LIST
66077: LIST
66078: LIST
66079: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
66080: LD_ADDR_VAR 0 14
66084: PUSH
66085: LD_INT 0
66087: PUSH
66088: LD_INT 0
66090: PUSH
66091: EMPTY
66092: LIST
66093: LIST
66094: PUSH
66095: LD_INT 0
66097: PUSH
66098: LD_INT 1
66100: NEG
66101: PUSH
66102: EMPTY
66103: LIST
66104: LIST
66105: PUSH
66106: LD_INT 1
66108: PUSH
66109: LD_INT 0
66111: PUSH
66112: EMPTY
66113: LIST
66114: LIST
66115: PUSH
66116: LD_INT 1
66118: PUSH
66119: LD_INT 1
66121: PUSH
66122: EMPTY
66123: LIST
66124: LIST
66125: PUSH
66126: LD_INT 0
66128: PUSH
66129: LD_INT 1
66131: PUSH
66132: EMPTY
66133: LIST
66134: LIST
66135: PUSH
66136: LD_INT 1
66138: NEG
66139: PUSH
66140: LD_INT 0
66142: PUSH
66143: EMPTY
66144: LIST
66145: LIST
66146: PUSH
66147: LD_INT 1
66149: NEG
66150: PUSH
66151: LD_INT 1
66153: NEG
66154: PUSH
66155: EMPTY
66156: LIST
66157: LIST
66158: PUSH
66159: LD_INT 1
66161: NEG
66162: PUSH
66163: LD_INT 2
66165: NEG
66166: PUSH
66167: EMPTY
66168: LIST
66169: LIST
66170: PUSH
66171: LD_INT 0
66173: PUSH
66174: LD_INT 2
66176: NEG
66177: PUSH
66178: EMPTY
66179: LIST
66180: LIST
66181: PUSH
66182: LD_INT 1
66184: PUSH
66185: LD_INT 1
66187: NEG
66188: PUSH
66189: EMPTY
66190: LIST
66191: LIST
66192: PUSH
66193: LD_INT 1
66195: PUSH
66196: LD_INT 2
66198: PUSH
66199: EMPTY
66200: LIST
66201: LIST
66202: PUSH
66203: LD_INT 0
66205: PUSH
66206: LD_INT 2
66208: PUSH
66209: EMPTY
66210: LIST
66211: LIST
66212: PUSH
66213: LD_INT 1
66215: NEG
66216: PUSH
66217: LD_INT 1
66219: PUSH
66220: EMPTY
66221: LIST
66222: LIST
66223: PUSH
66224: LD_INT 1
66226: NEG
66227: PUSH
66228: LD_INT 3
66230: NEG
66231: PUSH
66232: EMPTY
66233: LIST
66234: LIST
66235: PUSH
66236: LD_INT 0
66238: PUSH
66239: LD_INT 3
66241: NEG
66242: PUSH
66243: EMPTY
66244: LIST
66245: LIST
66246: PUSH
66247: LD_INT 1
66249: PUSH
66250: LD_INT 2
66252: NEG
66253: PUSH
66254: EMPTY
66255: LIST
66256: LIST
66257: PUSH
66258: EMPTY
66259: LIST
66260: LIST
66261: LIST
66262: LIST
66263: LIST
66264: LIST
66265: LIST
66266: LIST
66267: LIST
66268: LIST
66269: LIST
66270: LIST
66271: LIST
66272: LIST
66273: LIST
66274: LIST
66275: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
66276: LD_ADDR_VAR 0 15
66280: PUSH
66281: LD_INT 0
66283: PUSH
66284: LD_INT 0
66286: PUSH
66287: EMPTY
66288: LIST
66289: LIST
66290: PUSH
66291: LD_INT 0
66293: PUSH
66294: LD_INT 1
66296: NEG
66297: PUSH
66298: EMPTY
66299: LIST
66300: LIST
66301: PUSH
66302: LD_INT 1
66304: PUSH
66305: LD_INT 0
66307: PUSH
66308: EMPTY
66309: LIST
66310: LIST
66311: PUSH
66312: LD_INT 1
66314: PUSH
66315: LD_INT 1
66317: PUSH
66318: EMPTY
66319: LIST
66320: LIST
66321: PUSH
66322: LD_INT 0
66324: PUSH
66325: LD_INT 1
66327: PUSH
66328: EMPTY
66329: LIST
66330: LIST
66331: PUSH
66332: LD_INT 1
66334: NEG
66335: PUSH
66336: LD_INT 0
66338: PUSH
66339: EMPTY
66340: LIST
66341: LIST
66342: PUSH
66343: LD_INT 1
66345: NEG
66346: PUSH
66347: LD_INT 1
66349: NEG
66350: PUSH
66351: EMPTY
66352: LIST
66353: LIST
66354: PUSH
66355: LD_INT 1
66357: PUSH
66358: LD_INT 1
66360: NEG
66361: PUSH
66362: EMPTY
66363: LIST
66364: LIST
66365: PUSH
66366: LD_INT 2
66368: PUSH
66369: LD_INT 0
66371: PUSH
66372: EMPTY
66373: LIST
66374: LIST
66375: PUSH
66376: LD_INT 2
66378: PUSH
66379: LD_INT 1
66381: PUSH
66382: EMPTY
66383: LIST
66384: LIST
66385: PUSH
66386: LD_INT 1
66388: NEG
66389: PUSH
66390: LD_INT 1
66392: PUSH
66393: EMPTY
66394: LIST
66395: LIST
66396: PUSH
66397: LD_INT 2
66399: NEG
66400: PUSH
66401: LD_INT 0
66403: PUSH
66404: EMPTY
66405: LIST
66406: LIST
66407: PUSH
66408: LD_INT 2
66410: NEG
66411: PUSH
66412: LD_INT 1
66414: NEG
66415: PUSH
66416: EMPTY
66417: LIST
66418: LIST
66419: PUSH
66420: LD_INT 2
66422: PUSH
66423: LD_INT 1
66425: NEG
66426: PUSH
66427: EMPTY
66428: LIST
66429: LIST
66430: PUSH
66431: LD_INT 3
66433: PUSH
66434: LD_INT 0
66436: PUSH
66437: EMPTY
66438: LIST
66439: LIST
66440: PUSH
66441: LD_INT 3
66443: PUSH
66444: LD_INT 1
66446: PUSH
66447: EMPTY
66448: LIST
66449: LIST
66450: PUSH
66451: EMPTY
66452: LIST
66453: LIST
66454: LIST
66455: LIST
66456: LIST
66457: LIST
66458: LIST
66459: LIST
66460: LIST
66461: LIST
66462: LIST
66463: LIST
66464: LIST
66465: LIST
66466: LIST
66467: LIST
66468: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
66469: LD_ADDR_VAR 0 16
66473: PUSH
66474: LD_INT 0
66476: PUSH
66477: LD_INT 0
66479: PUSH
66480: EMPTY
66481: LIST
66482: LIST
66483: PUSH
66484: LD_INT 0
66486: PUSH
66487: LD_INT 1
66489: NEG
66490: PUSH
66491: EMPTY
66492: LIST
66493: LIST
66494: PUSH
66495: LD_INT 1
66497: PUSH
66498: LD_INT 0
66500: PUSH
66501: EMPTY
66502: LIST
66503: LIST
66504: PUSH
66505: LD_INT 1
66507: PUSH
66508: LD_INT 1
66510: PUSH
66511: EMPTY
66512: LIST
66513: LIST
66514: PUSH
66515: LD_INT 0
66517: PUSH
66518: LD_INT 1
66520: PUSH
66521: EMPTY
66522: LIST
66523: LIST
66524: PUSH
66525: LD_INT 1
66527: NEG
66528: PUSH
66529: LD_INT 0
66531: PUSH
66532: EMPTY
66533: LIST
66534: LIST
66535: PUSH
66536: LD_INT 1
66538: NEG
66539: PUSH
66540: LD_INT 1
66542: NEG
66543: PUSH
66544: EMPTY
66545: LIST
66546: LIST
66547: PUSH
66548: LD_INT 1
66550: NEG
66551: PUSH
66552: LD_INT 2
66554: NEG
66555: PUSH
66556: EMPTY
66557: LIST
66558: LIST
66559: PUSH
66560: LD_INT 2
66562: PUSH
66563: LD_INT 1
66565: PUSH
66566: EMPTY
66567: LIST
66568: LIST
66569: PUSH
66570: LD_INT 2
66572: PUSH
66573: LD_INT 2
66575: PUSH
66576: EMPTY
66577: LIST
66578: LIST
66579: PUSH
66580: LD_INT 1
66582: PUSH
66583: LD_INT 2
66585: PUSH
66586: EMPTY
66587: LIST
66588: LIST
66589: PUSH
66590: LD_INT 2
66592: NEG
66593: PUSH
66594: LD_INT 1
66596: NEG
66597: PUSH
66598: EMPTY
66599: LIST
66600: LIST
66601: PUSH
66602: LD_INT 2
66604: NEG
66605: PUSH
66606: LD_INT 2
66608: NEG
66609: PUSH
66610: EMPTY
66611: LIST
66612: LIST
66613: PUSH
66614: LD_INT 3
66616: PUSH
66617: LD_INT 2
66619: PUSH
66620: EMPTY
66621: LIST
66622: LIST
66623: PUSH
66624: LD_INT 3
66626: PUSH
66627: LD_INT 3
66629: PUSH
66630: EMPTY
66631: LIST
66632: LIST
66633: PUSH
66634: LD_INT 2
66636: PUSH
66637: LD_INT 3
66639: PUSH
66640: EMPTY
66641: LIST
66642: LIST
66643: PUSH
66644: EMPTY
66645: LIST
66646: LIST
66647: LIST
66648: LIST
66649: LIST
66650: LIST
66651: LIST
66652: LIST
66653: LIST
66654: LIST
66655: LIST
66656: LIST
66657: LIST
66658: LIST
66659: LIST
66660: LIST
66661: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66662: LD_ADDR_VAR 0 17
66666: PUSH
66667: LD_INT 0
66669: PUSH
66670: LD_INT 0
66672: PUSH
66673: EMPTY
66674: LIST
66675: LIST
66676: PUSH
66677: LD_INT 0
66679: PUSH
66680: LD_INT 1
66682: NEG
66683: PUSH
66684: EMPTY
66685: LIST
66686: LIST
66687: PUSH
66688: LD_INT 1
66690: PUSH
66691: LD_INT 0
66693: PUSH
66694: EMPTY
66695: LIST
66696: LIST
66697: PUSH
66698: LD_INT 1
66700: PUSH
66701: LD_INT 1
66703: PUSH
66704: EMPTY
66705: LIST
66706: LIST
66707: PUSH
66708: LD_INT 0
66710: PUSH
66711: LD_INT 1
66713: PUSH
66714: EMPTY
66715: LIST
66716: LIST
66717: PUSH
66718: LD_INT 1
66720: NEG
66721: PUSH
66722: LD_INT 0
66724: PUSH
66725: EMPTY
66726: LIST
66727: LIST
66728: PUSH
66729: LD_INT 1
66731: NEG
66732: PUSH
66733: LD_INT 1
66735: NEG
66736: PUSH
66737: EMPTY
66738: LIST
66739: LIST
66740: PUSH
66741: LD_INT 1
66743: NEG
66744: PUSH
66745: LD_INT 2
66747: NEG
66748: PUSH
66749: EMPTY
66750: LIST
66751: LIST
66752: PUSH
66753: LD_INT 0
66755: PUSH
66756: LD_INT 2
66758: NEG
66759: PUSH
66760: EMPTY
66761: LIST
66762: LIST
66763: PUSH
66764: LD_INT 1
66766: PUSH
66767: LD_INT 1
66769: NEG
66770: PUSH
66771: EMPTY
66772: LIST
66773: LIST
66774: PUSH
66775: LD_INT 2
66777: PUSH
66778: LD_INT 0
66780: PUSH
66781: EMPTY
66782: LIST
66783: LIST
66784: PUSH
66785: LD_INT 2
66787: PUSH
66788: LD_INT 1
66790: PUSH
66791: EMPTY
66792: LIST
66793: LIST
66794: PUSH
66795: LD_INT 2
66797: PUSH
66798: LD_INT 2
66800: PUSH
66801: EMPTY
66802: LIST
66803: LIST
66804: PUSH
66805: LD_INT 1
66807: PUSH
66808: LD_INT 2
66810: PUSH
66811: EMPTY
66812: LIST
66813: LIST
66814: PUSH
66815: LD_INT 0
66817: PUSH
66818: LD_INT 2
66820: PUSH
66821: EMPTY
66822: LIST
66823: LIST
66824: PUSH
66825: LD_INT 1
66827: NEG
66828: PUSH
66829: LD_INT 1
66831: PUSH
66832: EMPTY
66833: LIST
66834: LIST
66835: PUSH
66836: LD_INT 2
66838: NEG
66839: PUSH
66840: LD_INT 0
66842: PUSH
66843: EMPTY
66844: LIST
66845: LIST
66846: PUSH
66847: LD_INT 2
66849: NEG
66850: PUSH
66851: LD_INT 1
66853: NEG
66854: PUSH
66855: EMPTY
66856: LIST
66857: LIST
66858: PUSH
66859: LD_INT 2
66861: NEG
66862: PUSH
66863: LD_INT 2
66865: NEG
66866: PUSH
66867: EMPTY
66868: LIST
66869: LIST
66870: PUSH
66871: EMPTY
66872: LIST
66873: LIST
66874: LIST
66875: LIST
66876: LIST
66877: LIST
66878: LIST
66879: LIST
66880: LIST
66881: LIST
66882: LIST
66883: LIST
66884: LIST
66885: LIST
66886: LIST
66887: LIST
66888: LIST
66889: LIST
66890: LIST
66891: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66892: LD_ADDR_VAR 0 18
66896: PUSH
66897: LD_INT 0
66899: PUSH
66900: LD_INT 0
66902: PUSH
66903: EMPTY
66904: LIST
66905: LIST
66906: PUSH
66907: LD_INT 0
66909: PUSH
66910: LD_INT 1
66912: NEG
66913: PUSH
66914: EMPTY
66915: LIST
66916: LIST
66917: PUSH
66918: LD_INT 1
66920: PUSH
66921: LD_INT 0
66923: PUSH
66924: EMPTY
66925: LIST
66926: LIST
66927: PUSH
66928: LD_INT 1
66930: PUSH
66931: LD_INT 1
66933: PUSH
66934: EMPTY
66935: LIST
66936: LIST
66937: PUSH
66938: LD_INT 0
66940: PUSH
66941: LD_INT 1
66943: PUSH
66944: EMPTY
66945: LIST
66946: LIST
66947: PUSH
66948: LD_INT 1
66950: NEG
66951: PUSH
66952: LD_INT 0
66954: PUSH
66955: EMPTY
66956: LIST
66957: LIST
66958: PUSH
66959: LD_INT 1
66961: NEG
66962: PUSH
66963: LD_INT 1
66965: NEG
66966: PUSH
66967: EMPTY
66968: LIST
66969: LIST
66970: PUSH
66971: LD_INT 1
66973: NEG
66974: PUSH
66975: LD_INT 2
66977: NEG
66978: PUSH
66979: EMPTY
66980: LIST
66981: LIST
66982: PUSH
66983: LD_INT 0
66985: PUSH
66986: LD_INT 2
66988: NEG
66989: PUSH
66990: EMPTY
66991: LIST
66992: LIST
66993: PUSH
66994: LD_INT 1
66996: PUSH
66997: LD_INT 1
66999: NEG
67000: PUSH
67001: EMPTY
67002: LIST
67003: LIST
67004: PUSH
67005: LD_INT 2
67007: PUSH
67008: LD_INT 0
67010: PUSH
67011: EMPTY
67012: LIST
67013: LIST
67014: PUSH
67015: LD_INT 2
67017: PUSH
67018: LD_INT 1
67020: PUSH
67021: EMPTY
67022: LIST
67023: LIST
67024: PUSH
67025: LD_INT 2
67027: PUSH
67028: LD_INT 2
67030: PUSH
67031: EMPTY
67032: LIST
67033: LIST
67034: PUSH
67035: LD_INT 1
67037: PUSH
67038: LD_INT 2
67040: PUSH
67041: EMPTY
67042: LIST
67043: LIST
67044: PUSH
67045: LD_INT 0
67047: PUSH
67048: LD_INT 2
67050: PUSH
67051: EMPTY
67052: LIST
67053: LIST
67054: PUSH
67055: LD_INT 1
67057: NEG
67058: PUSH
67059: LD_INT 1
67061: PUSH
67062: EMPTY
67063: LIST
67064: LIST
67065: PUSH
67066: LD_INT 2
67068: NEG
67069: PUSH
67070: LD_INT 0
67072: PUSH
67073: EMPTY
67074: LIST
67075: LIST
67076: PUSH
67077: LD_INT 2
67079: NEG
67080: PUSH
67081: LD_INT 1
67083: NEG
67084: PUSH
67085: EMPTY
67086: LIST
67087: LIST
67088: PUSH
67089: LD_INT 2
67091: NEG
67092: PUSH
67093: LD_INT 2
67095: NEG
67096: PUSH
67097: EMPTY
67098: LIST
67099: LIST
67100: PUSH
67101: EMPTY
67102: LIST
67103: LIST
67104: LIST
67105: LIST
67106: LIST
67107: LIST
67108: LIST
67109: LIST
67110: LIST
67111: LIST
67112: LIST
67113: LIST
67114: LIST
67115: LIST
67116: LIST
67117: LIST
67118: LIST
67119: LIST
67120: LIST
67121: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67122: LD_ADDR_VAR 0 19
67126: PUSH
67127: LD_INT 0
67129: PUSH
67130: LD_INT 0
67132: PUSH
67133: EMPTY
67134: LIST
67135: LIST
67136: PUSH
67137: LD_INT 0
67139: PUSH
67140: LD_INT 1
67142: NEG
67143: PUSH
67144: EMPTY
67145: LIST
67146: LIST
67147: PUSH
67148: LD_INT 1
67150: PUSH
67151: LD_INT 0
67153: PUSH
67154: EMPTY
67155: LIST
67156: LIST
67157: PUSH
67158: LD_INT 1
67160: PUSH
67161: LD_INT 1
67163: PUSH
67164: EMPTY
67165: LIST
67166: LIST
67167: PUSH
67168: LD_INT 0
67170: PUSH
67171: LD_INT 1
67173: PUSH
67174: EMPTY
67175: LIST
67176: LIST
67177: PUSH
67178: LD_INT 1
67180: NEG
67181: PUSH
67182: LD_INT 0
67184: PUSH
67185: EMPTY
67186: LIST
67187: LIST
67188: PUSH
67189: LD_INT 1
67191: NEG
67192: PUSH
67193: LD_INT 1
67195: NEG
67196: PUSH
67197: EMPTY
67198: LIST
67199: LIST
67200: PUSH
67201: LD_INT 1
67203: NEG
67204: PUSH
67205: LD_INT 2
67207: NEG
67208: PUSH
67209: EMPTY
67210: LIST
67211: LIST
67212: PUSH
67213: LD_INT 0
67215: PUSH
67216: LD_INT 2
67218: NEG
67219: PUSH
67220: EMPTY
67221: LIST
67222: LIST
67223: PUSH
67224: LD_INT 1
67226: PUSH
67227: LD_INT 1
67229: NEG
67230: PUSH
67231: EMPTY
67232: LIST
67233: LIST
67234: PUSH
67235: LD_INT 2
67237: PUSH
67238: LD_INT 0
67240: PUSH
67241: EMPTY
67242: LIST
67243: LIST
67244: PUSH
67245: LD_INT 2
67247: PUSH
67248: LD_INT 1
67250: PUSH
67251: EMPTY
67252: LIST
67253: LIST
67254: PUSH
67255: LD_INT 2
67257: PUSH
67258: LD_INT 2
67260: PUSH
67261: EMPTY
67262: LIST
67263: LIST
67264: PUSH
67265: LD_INT 1
67267: PUSH
67268: LD_INT 2
67270: PUSH
67271: EMPTY
67272: LIST
67273: LIST
67274: PUSH
67275: LD_INT 0
67277: PUSH
67278: LD_INT 2
67280: PUSH
67281: EMPTY
67282: LIST
67283: LIST
67284: PUSH
67285: LD_INT 1
67287: NEG
67288: PUSH
67289: LD_INT 1
67291: PUSH
67292: EMPTY
67293: LIST
67294: LIST
67295: PUSH
67296: LD_INT 2
67298: NEG
67299: PUSH
67300: LD_INT 0
67302: PUSH
67303: EMPTY
67304: LIST
67305: LIST
67306: PUSH
67307: LD_INT 2
67309: NEG
67310: PUSH
67311: LD_INT 1
67313: NEG
67314: PUSH
67315: EMPTY
67316: LIST
67317: LIST
67318: PUSH
67319: LD_INT 2
67321: NEG
67322: PUSH
67323: LD_INT 2
67325: NEG
67326: PUSH
67327: EMPTY
67328: LIST
67329: LIST
67330: PUSH
67331: EMPTY
67332: LIST
67333: LIST
67334: LIST
67335: LIST
67336: LIST
67337: LIST
67338: LIST
67339: LIST
67340: LIST
67341: LIST
67342: LIST
67343: LIST
67344: LIST
67345: LIST
67346: LIST
67347: LIST
67348: LIST
67349: LIST
67350: LIST
67351: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67352: LD_ADDR_VAR 0 20
67356: PUSH
67357: LD_INT 0
67359: PUSH
67360: LD_INT 0
67362: PUSH
67363: EMPTY
67364: LIST
67365: LIST
67366: PUSH
67367: LD_INT 0
67369: PUSH
67370: LD_INT 1
67372: NEG
67373: PUSH
67374: EMPTY
67375: LIST
67376: LIST
67377: PUSH
67378: LD_INT 1
67380: PUSH
67381: LD_INT 0
67383: PUSH
67384: EMPTY
67385: LIST
67386: LIST
67387: PUSH
67388: LD_INT 1
67390: PUSH
67391: LD_INT 1
67393: PUSH
67394: EMPTY
67395: LIST
67396: LIST
67397: PUSH
67398: LD_INT 0
67400: PUSH
67401: LD_INT 1
67403: PUSH
67404: EMPTY
67405: LIST
67406: LIST
67407: PUSH
67408: LD_INT 1
67410: NEG
67411: PUSH
67412: LD_INT 0
67414: PUSH
67415: EMPTY
67416: LIST
67417: LIST
67418: PUSH
67419: LD_INT 1
67421: NEG
67422: PUSH
67423: LD_INT 1
67425: NEG
67426: PUSH
67427: EMPTY
67428: LIST
67429: LIST
67430: PUSH
67431: LD_INT 1
67433: NEG
67434: PUSH
67435: LD_INT 2
67437: NEG
67438: PUSH
67439: EMPTY
67440: LIST
67441: LIST
67442: PUSH
67443: LD_INT 0
67445: PUSH
67446: LD_INT 2
67448: NEG
67449: PUSH
67450: EMPTY
67451: LIST
67452: LIST
67453: PUSH
67454: LD_INT 1
67456: PUSH
67457: LD_INT 1
67459: NEG
67460: PUSH
67461: EMPTY
67462: LIST
67463: LIST
67464: PUSH
67465: LD_INT 2
67467: PUSH
67468: LD_INT 0
67470: PUSH
67471: EMPTY
67472: LIST
67473: LIST
67474: PUSH
67475: LD_INT 2
67477: PUSH
67478: LD_INT 1
67480: PUSH
67481: EMPTY
67482: LIST
67483: LIST
67484: PUSH
67485: LD_INT 2
67487: PUSH
67488: LD_INT 2
67490: PUSH
67491: EMPTY
67492: LIST
67493: LIST
67494: PUSH
67495: LD_INT 1
67497: PUSH
67498: LD_INT 2
67500: PUSH
67501: EMPTY
67502: LIST
67503: LIST
67504: PUSH
67505: LD_INT 0
67507: PUSH
67508: LD_INT 2
67510: PUSH
67511: EMPTY
67512: LIST
67513: LIST
67514: PUSH
67515: LD_INT 1
67517: NEG
67518: PUSH
67519: LD_INT 1
67521: PUSH
67522: EMPTY
67523: LIST
67524: LIST
67525: PUSH
67526: LD_INT 2
67528: NEG
67529: PUSH
67530: LD_INT 0
67532: PUSH
67533: EMPTY
67534: LIST
67535: LIST
67536: PUSH
67537: LD_INT 2
67539: NEG
67540: PUSH
67541: LD_INT 1
67543: NEG
67544: PUSH
67545: EMPTY
67546: LIST
67547: LIST
67548: PUSH
67549: LD_INT 2
67551: NEG
67552: PUSH
67553: LD_INT 2
67555: NEG
67556: PUSH
67557: EMPTY
67558: LIST
67559: LIST
67560: PUSH
67561: EMPTY
67562: LIST
67563: LIST
67564: LIST
67565: LIST
67566: LIST
67567: LIST
67568: LIST
67569: LIST
67570: LIST
67571: LIST
67572: LIST
67573: LIST
67574: LIST
67575: LIST
67576: LIST
67577: LIST
67578: LIST
67579: LIST
67580: LIST
67581: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67582: LD_ADDR_VAR 0 21
67586: PUSH
67587: LD_INT 0
67589: PUSH
67590: LD_INT 0
67592: PUSH
67593: EMPTY
67594: LIST
67595: LIST
67596: PUSH
67597: LD_INT 0
67599: PUSH
67600: LD_INT 1
67602: NEG
67603: PUSH
67604: EMPTY
67605: LIST
67606: LIST
67607: PUSH
67608: LD_INT 1
67610: PUSH
67611: LD_INT 0
67613: PUSH
67614: EMPTY
67615: LIST
67616: LIST
67617: PUSH
67618: LD_INT 1
67620: PUSH
67621: LD_INT 1
67623: PUSH
67624: EMPTY
67625: LIST
67626: LIST
67627: PUSH
67628: LD_INT 0
67630: PUSH
67631: LD_INT 1
67633: PUSH
67634: EMPTY
67635: LIST
67636: LIST
67637: PUSH
67638: LD_INT 1
67640: NEG
67641: PUSH
67642: LD_INT 0
67644: PUSH
67645: EMPTY
67646: LIST
67647: LIST
67648: PUSH
67649: LD_INT 1
67651: NEG
67652: PUSH
67653: LD_INT 1
67655: NEG
67656: PUSH
67657: EMPTY
67658: LIST
67659: LIST
67660: PUSH
67661: LD_INT 1
67663: NEG
67664: PUSH
67665: LD_INT 2
67667: NEG
67668: PUSH
67669: EMPTY
67670: LIST
67671: LIST
67672: PUSH
67673: LD_INT 0
67675: PUSH
67676: LD_INT 2
67678: NEG
67679: PUSH
67680: EMPTY
67681: LIST
67682: LIST
67683: PUSH
67684: LD_INT 1
67686: PUSH
67687: LD_INT 1
67689: NEG
67690: PUSH
67691: EMPTY
67692: LIST
67693: LIST
67694: PUSH
67695: LD_INT 2
67697: PUSH
67698: LD_INT 0
67700: PUSH
67701: EMPTY
67702: LIST
67703: LIST
67704: PUSH
67705: LD_INT 2
67707: PUSH
67708: LD_INT 1
67710: PUSH
67711: EMPTY
67712: LIST
67713: LIST
67714: PUSH
67715: LD_INT 2
67717: PUSH
67718: LD_INT 2
67720: PUSH
67721: EMPTY
67722: LIST
67723: LIST
67724: PUSH
67725: LD_INT 1
67727: PUSH
67728: LD_INT 2
67730: PUSH
67731: EMPTY
67732: LIST
67733: LIST
67734: PUSH
67735: LD_INT 0
67737: PUSH
67738: LD_INT 2
67740: PUSH
67741: EMPTY
67742: LIST
67743: LIST
67744: PUSH
67745: LD_INT 1
67747: NEG
67748: PUSH
67749: LD_INT 1
67751: PUSH
67752: EMPTY
67753: LIST
67754: LIST
67755: PUSH
67756: LD_INT 2
67758: NEG
67759: PUSH
67760: LD_INT 0
67762: PUSH
67763: EMPTY
67764: LIST
67765: LIST
67766: PUSH
67767: LD_INT 2
67769: NEG
67770: PUSH
67771: LD_INT 1
67773: NEG
67774: PUSH
67775: EMPTY
67776: LIST
67777: LIST
67778: PUSH
67779: LD_INT 2
67781: NEG
67782: PUSH
67783: LD_INT 2
67785: NEG
67786: PUSH
67787: EMPTY
67788: LIST
67789: LIST
67790: PUSH
67791: EMPTY
67792: LIST
67793: LIST
67794: LIST
67795: LIST
67796: LIST
67797: LIST
67798: LIST
67799: LIST
67800: LIST
67801: LIST
67802: LIST
67803: LIST
67804: LIST
67805: LIST
67806: LIST
67807: LIST
67808: LIST
67809: LIST
67810: LIST
67811: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67812: LD_ADDR_VAR 0 22
67816: PUSH
67817: LD_INT 0
67819: PUSH
67820: LD_INT 0
67822: PUSH
67823: EMPTY
67824: LIST
67825: LIST
67826: PUSH
67827: LD_INT 0
67829: PUSH
67830: LD_INT 1
67832: NEG
67833: PUSH
67834: EMPTY
67835: LIST
67836: LIST
67837: PUSH
67838: LD_INT 1
67840: PUSH
67841: LD_INT 0
67843: PUSH
67844: EMPTY
67845: LIST
67846: LIST
67847: PUSH
67848: LD_INT 1
67850: PUSH
67851: LD_INT 1
67853: PUSH
67854: EMPTY
67855: LIST
67856: LIST
67857: PUSH
67858: LD_INT 0
67860: PUSH
67861: LD_INT 1
67863: PUSH
67864: EMPTY
67865: LIST
67866: LIST
67867: PUSH
67868: LD_INT 1
67870: NEG
67871: PUSH
67872: LD_INT 0
67874: PUSH
67875: EMPTY
67876: LIST
67877: LIST
67878: PUSH
67879: LD_INT 1
67881: NEG
67882: PUSH
67883: LD_INT 1
67885: NEG
67886: PUSH
67887: EMPTY
67888: LIST
67889: LIST
67890: PUSH
67891: LD_INT 1
67893: NEG
67894: PUSH
67895: LD_INT 2
67897: NEG
67898: PUSH
67899: EMPTY
67900: LIST
67901: LIST
67902: PUSH
67903: LD_INT 0
67905: PUSH
67906: LD_INT 2
67908: NEG
67909: PUSH
67910: EMPTY
67911: LIST
67912: LIST
67913: PUSH
67914: LD_INT 1
67916: PUSH
67917: LD_INT 1
67919: NEG
67920: PUSH
67921: EMPTY
67922: LIST
67923: LIST
67924: PUSH
67925: LD_INT 2
67927: PUSH
67928: LD_INT 0
67930: PUSH
67931: EMPTY
67932: LIST
67933: LIST
67934: PUSH
67935: LD_INT 2
67937: PUSH
67938: LD_INT 1
67940: PUSH
67941: EMPTY
67942: LIST
67943: LIST
67944: PUSH
67945: LD_INT 2
67947: PUSH
67948: LD_INT 2
67950: PUSH
67951: EMPTY
67952: LIST
67953: LIST
67954: PUSH
67955: LD_INT 1
67957: PUSH
67958: LD_INT 2
67960: PUSH
67961: EMPTY
67962: LIST
67963: LIST
67964: PUSH
67965: LD_INT 0
67967: PUSH
67968: LD_INT 2
67970: PUSH
67971: EMPTY
67972: LIST
67973: LIST
67974: PUSH
67975: LD_INT 1
67977: NEG
67978: PUSH
67979: LD_INT 1
67981: PUSH
67982: EMPTY
67983: LIST
67984: LIST
67985: PUSH
67986: LD_INT 2
67988: NEG
67989: PUSH
67990: LD_INT 0
67992: PUSH
67993: EMPTY
67994: LIST
67995: LIST
67996: PUSH
67997: LD_INT 2
67999: NEG
68000: PUSH
68001: LD_INT 1
68003: NEG
68004: PUSH
68005: EMPTY
68006: LIST
68007: LIST
68008: PUSH
68009: LD_INT 2
68011: NEG
68012: PUSH
68013: LD_INT 2
68015: NEG
68016: PUSH
68017: EMPTY
68018: LIST
68019: LIST
68020: PUSH
68021: EMPTY
68022: LIST
68023: LIST
68024: LIST
68025: LIST
68026: LIST
68027: LIST
68028: LIST
68029: LIST
68030: LIST
68031: LIST
68032: LIST
68033: LIST
68034: LIST
68035: LIST
68036: LIST
68037: LIST
68038: LIST
68039: LIST
68040: LIST
68041: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
68042: LD_ADDR_VAR 0 23
68046: PUSH
68047: LD_INT 0
68049: PUSH
68050: LD_INT 0
68052: PUSH
68053: EMPTY
68054: LIST
68055: LIST
68056: PUSH
68057: LD_INT 0
68059: PUSH
68060: LD_INT 1
68062: NEG
68063: PUSH
68064: EMPTY
68065: LIST
68066: LIST
68067: PUSH
68068: LD_INT 1
68070: PUSH
68071: LD_INT 0
68073: PUSH
68074: EMPTY
68075: LIST
68076: LIST
68077: PUSH
68078: LD_INT 1
68080: PUSH
68081: LD_INT 1
68083: PUSH
68084: EMPTY
68085: LIST
68086: LIST
68087: PUSH
68088: LD_INT 0
68090: PUSH
68091: LD_INT 1
68093: PUSH
68094: EMPTY
68095: LIST
68096: LIST
68097: PUSH
68098: LD_INT 1
68100: NEG
68101: PUSH
68102: LD_INT 0
68104: PUSH
68105: EMPTY
68106: LIST
68107: LIST
68108: PUSH
68109: LD_INT 1
68111: NEG
68112: PUSH
68113: LD_INT 1
68115: NEG
68116: PUSH
68117: EMPTY
68118: LIST
68119: LIST
68120: PUSH
68121: LD_INT 1
68123: NEG
68124: PUSH
68125: LD_INT 2
68127: NEG
68128: PUSH
68129: EMPTY
68130: LIST
68131: LIST
68132: PUSH
68133: LD_INT 0
68135: PUSH
68136: LD_INT 2
68138: NEG
68139: PUSH
68140: EMPTY
68141: LIST
68142: LIST
68143: PUSH
68144: LD_INT 1
68146: PUSH
68147: LD_INT 1
68149: NEG
68150: PUSH
68151: EMPTY
68152: LIST
68153: LIST
68154: PUSH
68155: LD_INT 2
68157: PUSH
68158: LD_INT 0
68160: PUSH
68161: EMPTY
68162: LIST
68163: LIST
68164: PUSH
68165: LD_INT 2
68167: PUSH
68168: LD_INT 1
68170: PUSH
68171: EMPTY
68172: LIST
68173: LIST
68174: PUSH
68175: LD_INT 2
68177: PUSH
68178: LD_INT 2
68180: PUSH
68181: EMPTY
68182: LIST
68183: LIST
68184: PUSH
68185: LD_INT 1
68187: PUSH
68188: LD_INT 2
68190: PUSH
68191: EMPTY
68192: LIST
68193: LIST
68194: PUSH
68195: LD_INT 0
68197: PUSH
68198: LD_INT 2
68200: PUSH
68201: EMPTY
68202: LIST
68203: LIST
68204: PUSH
68205: LD_INT 1
68207: NEG
68208: PUSH
68209: LD_INT 1
68211: PUSH
68212: EMPTY
68213: LIST
68214: LIST
68215: PUSH
68216: LD_INT 2
68218: NEG
68219: PUSH
68220: LD_INT 0
68222: PUSH
68223: EMPTY
68224: LIST
68225: LIST
68226: PUSH
68227: LD_INT 2
68229: NEG
68230: PUSH
68231: LD_INT 1
68233: NEG
68234: PUSH
68235: EMPTY
68236: LIST
68237: LIST
68238: PUSH
68239: LD_INT 2
68241: NEG
68242: PUSH
68243: LD_INT 2
68245: NEG
68246: PUSH
68247: EMPTY
68248: LIST
68249: LIST
68250: PUSH
68251: LD_INT 2
68253: NEG
68254: PUSH
68255: LD_INT 3
68257: NEG
68258: PUSH
68259: EMPTY
68260: LIST
68261: LIST
68262: PUSH
68263: LD_INT 1
68265: NEG
68266: PUSH
68267: LD_INT 3
68269: NEG
68270: PUSH
68271: EMPTY
68272: LIST
68273: LIST
68274: PUSH
68275: LD_INT 1
68277: PUSH
68278: LD_INT 2
68280: NEG
68281: PUSH
68282: EMPTY
68283: LIST
68284: LIST
68285: PUSH
68286: LD_INT 2
68288: PUSH
68289: LD_INT 1
68291: NEG
68292: PUSH
68293: EMPTY
68294: LIST
68295: LIST
68296: PUSH
68297: EMPTY
68298: LIST
68299: LIST
68300: LIST
68301: LIST
68302: LIST
68303: LIST
68304: LIST
68305: LIST
68306: LIST
68307: LIST
68308: LIST
68309: LIST
68310: LIST
68311: LIST
68312: LIST
68313: LIST
68314: LIST
68315: LIST
68316: LIST
68317: LIST
68318: LIST
68319: LIST
68320: LIST
68321: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
68322: LD_ADDR_VAR 0 24
68326: PUSH
68327: LD_INT 0
68329: PUSH
68330: LD_INT 0
68332: PUSH
68333: EMPTY
68334: LIST
68335: LIST
68336: PUSH
68337: LD_INT 0
68339: PUSH
68340: LD_INT 1
68342: NEG
68343: PUSH
68344: EMPTY
68345: LIST
68346: LIST
68347: PUSH
68348: LD_INT 1
68350: PUSH
68351: LD_INT 0
68353: PUSH
68354: EMPTY
68355: LIST
68356: LIST
68357: PUSH
68358: LD_INT 1
68360: PUSH
68361: LD_INT 1
68363: PUSH
68364: EMPTY
68365: LIST
68366: LIST
68367: PUSH
68368: LD_INT 0
68370: PUSH
68371: LD_INT 1
68373: PUSH
68374: EMPTY
68375: LIST
68376: LIST
68377: PUSH
68378: LD_INT 1
68380: NEG
68381: PUSH
68382: LD_INT 0
68384: PUSH
68385: EMPTY
68386: LIST
68387: LIST
68388: PUSH
68389: LD_INT 1
68391: NEG
68392: PUSH
68393: LD_INT 1
68395: NEG
68396: PUSH
68397: EMPTY
68398: LIST
68399: LIST
68400: PUSH
68401: LD_INT 1
68403: NEG
68404: PUSH
68405: LD_INT 2
68407: NEG
68408: PUSH
68409: EMPTY
68410: LIST
68411: LIST
68412: PUSH
68413: LD_INT 0
68415: PUSH
68416: LD_INT 2
68418: NEG
68419: PUSH
68420: EMPTY
68421: LIST
68422: LIST
68423: PUSH
68424: LD_INT 1
68426: PUSH
68427: LD_INT 1
68429: NEG
68430: PUSH
68431: EMPTY
68432: LIST
68433: LIST
68434: PUSH
68435: LD_INT 2
68437: PUSH
68438: LD_INT 0
68440: PUSH
68441: EMPTY
68442: LIST
68443: LIST
68444: PUSH
68445: LD_INT 2
68447: PUSH
68448: LD_INT 1
68450: PUSH
68451: EMPTY
68452: LIST
68453: LIST
68454: PUSH
68455: LD_INT 2
68457: PUSH
68458: LD_INT 2
68460: PUSH
68461: EMPTY
68462: LIST
68463: LIST
68464: PUSH
68465: LD_INT 1
68467: PUSH
68468: LD_INT 2
68470: PUSH
68471: EMPTY
68472: LIST
68473: LIST
68474: PUSH
68475: LD_INT 0
68477: PUSH
68478: LD_INT 2
68480: PUSH
68481: EMPTY
68482: LIST
68483: LIST
68484: PUSH
68485: LD_INT 1
68487: NEG
68488: PUSH
68489: LD_INT 1
68491: PUSH
68492: EMPTY
68493: LIST
68494: LIST
68495: PUSH
68496: LD_INT 2
68498: NEG
68499: PUSH
68500: LD_INT 0
68502: PUSH
68503: EMPTY
68504: LIST
68505: LIST
68506: PUSH
68507: LD_INT 2
68509: NEG
68510: PUSH
68511: LD_INT 1
68513: NEG
68514: PUSH
68515: EMPTY
68516: LIST
68517: LIST
68518: PUSH
68519: LD_INT 2
68521: NEG
68522: PUSH
68523: LD_INT 2
68525: NEG
68526: PUSH
68527: EMPTY
68528: LIST
68529: LIST
68530: PUSH
68531: LD_INT 1
68533: PUSH
68534: LD_INT 2
68536: NEG
68537: PUSH
68538: EMPTY
68539: LIST
68540: LIST
68541: PUSH
68542: LD_INT 2
68544: PUSH
68545: LD_INT 1
68547: NEG
68548: PUSH
68549: EMPTY
68550: LIST
68551: LIST
68552: PUSH
68553: LD_INT 3
68555: PUSH
68556: LD_INT 1
68558: PUSH
68559: EMPTY
68560: LIST
68561: LIST
68562: PUSH
68563: LD_INT 3
68565: PUSH
68566: LD_INT 2
68568: PUSH
68569: EMPTY
68570: LIST
68571: LIST
68572: PUSH
68573: EMPTY
68574: LIST
68575: LIST
68576: LIST
68577: LIST
68578: LIST
68579: LIST
68580: LIST
68581: LIST
68582: LIST
68583: LIST
68584: LIST
68585: LIST
68586: LIST
68587: LIST
68588: LIST
68589: LIST
68590: LIST
68591: LIST
68592: LIST
68593: LIST
68594: LIST
68595: LIST
68596: LIST
68597: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
68598: LD_ADDR_VAR 0 25
68602: PUSH
68603: LD_INT 0
68605: PUSH
68606: LD_INT 0
68608: PUSH
68609: EMPTY
68610: LIST
68611: LIST
68612: PUSH
68613: LD_INT 0
68615: PUSH
68616: LD_INT 1
68618: NEG
68619: PUSH
68620: EMPTY
68621: LIST
68622: LIST
68623: PUSH
68624: LD_INT 1
68626: PUSH
68627: LD_INT 0
68629: PUSH
68630: EMPTY
68631: LIST
68632: LIST
68633: PUSH
68634: LD_INT 1
68636: PUSH
68637: LD_INT 1
68639: PUSH
68640: EMPTY
68641: LIST
68642: LIST
68643: PUSH
68644: LD_INT 0
68646: PUSH
68647: LD_INT 1
68649: PUSH
68650: EMPTY
68651: LIST
68652: LIST
68653: PUSH
68654: LD_INT 1
68656: NEG
68657: PUSH
68658: LD_INT 0
68660: PUSH
68661: EMPTY
68662: LIST
68663: LIST
68664: PUSH
68665: LD_INT 1
68667: NEG
68668: PUSH
68669: LD_INT 1
68671: NEG
68672: PUSH
68673: EMPTY
68674: LIST
68675: LIST
68676: PUSH
68677: LD_INT 1
68679: NEG
68680: PUSH
68681: LD_INT 2
68683: NEG
68684: PUSH
68685: EMPTY
68686: LIST
68687: LIST
68688: PUSH
68689: LD_INT 0
68691: PUSH
68692: LD_INT 2
68694: NEG
68695: PUSH
68696: EMPTY
68697: LIST
68698: LIST
68699: PUSH
68700: LD_INT 1
68702: PUSH
68703: LD_INT 1
68705: NEG
68706: PUSH
68707: EMPTY
68708: LIST
68709: LIST
68710: PUSH
68711: LD_INT 2
68713: PUSH
68714: LD_INT 0
68716: PUSH
68717: EMPTY
68718: LIST
68719: LIST
68720: PUSH
68721: LD_INT 2
68723: PUSH
68724: LD_INT 1
68726: PUSH
68727: EMPTY
68728: LIST
68729: LIST
68730: PUSH
68731: LD_INT 2
68733: PUSH
68734: LD_INT 2
68736: PUSH
68737: EMPTY
68738: LIST
68739: LIST
68740: PUSH
68741: LD_INT 1
68743: PUSH
68744: LD_INT 2
68746: PUSH
68747: EMPTY
68748: LIST
68749: LIST
68750: PUSH
68751: LD_INT 0
68753: PUSH
68754: LD_INT 2
68756: PUSH
68757: EMPTY
68758: LIST
68759: LIST
68760: PUSH
68761: LD_INT 1
68763: NEG
68764: PUSH
68765: LD_INT 1
68767: PUSH
68768: EMPTY
68769: LIST
68770: LIST
68771: PUSH
68772: LD_INT 2
68774: NEG
68775: PUSH
68776: LD_INT 0
68778: PUSH
68779: EMPTY
68780: LIST
68781: LIST
68782: PUSH
68783: LD_INT 2
68785: NEG
68786: PUSH
68787: LD_INT 1
68789: NEG
68790: PUSH
68791: EMPTY
68792: LIST
68793: LIST
68794: PUSH
68795: LD_INT 2
68797: NEG
68798: PUSH
68799: LD_INT 2
68801: NEG
68802: PUSH
68803: EMPTY
68804: LIST
68805: LIST
68806: PUSH
68807: LD_INT 3
68809: PUSH
68810: LD_INT 1
68812: PUSH
68813: EMPTY
68814: LIST
68815: LIST
68816: PUSH
68817: LD_INT 3
68819: PUSH
68820: LD_INT 2
68822: PUSH
68823: EMPTY
68824: LIST
68825: LIST
68826: PUSH
68827: LD_INT 2
68829: PUSH
68830: LD_INT 3
68832: PUSH
68833: EMPTY
68834: LIST
68835: LIST
68836: PUSH
68837: LD_INT 1
68839: PUSH
68840: LD_INT 3
68842: PUSH
68843: EMPTY
68844: LIST
68845: LIST
68846: PUSH
68847: EMPTY
68848: LIST
68849: LIST
68850: LIST
68851: LIST
68852: LIST
68853: LIST
68854: LIST
68855: LIST
68856: LIST
68857: LIST
68858: LIST
68859: LIST
68860: LIST
68861: LIST
68862: LIST
68863: LIST
68864: LIST
68865: LIST
68866: LIST
68867: LIST
68868: LIST
68869: LIST
68870: LIST
68871: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
68872: LD_ADDR_VAR 0 26
68876: PUSH
68877: LD_INT 0
68879: PUSH
68880: LD_INT 0
68882: PUSH
68883: EMPTY
68884: LIST
68885: LIST
68886: PUSH
68887: LD_INT 0
68889: PUSH
68890: LD_INT 1
68892: NEG
68893: PUSH
68894: EMPTY
68895: LIST
68896: LIST
68897: PUSH
68898: LD_INT 1
68900: PUSH
68901: LD_INT 0
68903: PUSH
68904: EMPTY
68905: LIST
68906: LIST
68907: PUSH
68908: LD_INT 1
68910: PUSH
68911: LD_INT 1
68913: PUSH
68914: EMPTY
68915: LIST
68916: LIST
68917: PUSH
68918: LD_INT 0
68920: PUSH
68921: LD_INT 1
68923: PUSH
68924: EMPTY
68925: LIST
68926: LIST
68927: PUSH
68928: LD_INT 1
68930: NEG
68931: PUSH
68932: LD_INT 0
68934: PUSH
68935: EMPTY
68936: LIST
68937: LIST
68938: PUSH
68939: LD_INT 1
68941: NEG
68942: PUSH
68943: LD_INT 1
68945: NEG
68946: PUSH
68947: EMPTY
68948: LIST
68949: LIST
68950: PUSH
68951: LD_INT 1
68953: NEG
68954: PUSH
68955: LD_INT 2
68957: NEG
68958: PUSH
68959: EMPTY
68960: LIST
68961: LIST
68962: PUSH
68963: LD_INT 0
68965: PUSH
68966: LD_INT 2
68968: NEG
68969: PUSH
68970: EMPTY
68971: LIST
68972: LIST
68973: PUSH
68974: LD_INT 1
68976: PUSH
68977: LD_INT 1
68979: NEG
68980: PUSH
68981: EMPTY
68982: LIST
68983: LIST
68984: PUSH
68985: LD_INT 2
68987: PUSH
68988: LD_INT 0
68990: PUSH
68991: EMPTY
68992: LIST
68993: LIST
68994: PUSH
68995: LD_INT 2
68997: PUSH
68998: LD_INT 1
69000: PUSH
69001: EMPTY
69002: LIST
69003: LIST
69004: PUSH
69005: LD_INT 2
69007: PUSH
69008: LD_INT 2
69010: PUSH
69011: EMPTY
69012: LIST
69013: LIST
69014: PUSH
69015: LD_INT 1
69017: PUSH
69018: LD_INT 2
69020: PUSH
69021: EMPTY
69022: LIST
69023: LIST
69024: PUSH
69025: LD_INT 0
69027: PUSH
69028: LD_INT 2
69030: PUSH
69031: EMPTY
69032: LIST
69033: LIST
69034: PUSH
69035: LD_INT 1
69037: NEG
69038: PUSH
69039: LD_INT 1
69041: PUSH
69042: EMPTY
69043: LIST
69044: LIST
69045: PUSH
69046: LD_INT 2
69048: NEG
69049: PUSH
69050: LD_INT 0
69052: PUSH
69053: EMPTY
69054: LIST
69055: LIST
69056: PUSH
69057: LD_INT 2
69059: NEG
69060: PUSH
69061: LD_INT 1
69063: NEG
69064: PUSH
69065: EMPTY
69066: LIST
69067: LIST
69068: PUSH
69069: LD_INT 2
69071: NEG
69072: PUSH
69073: LD_INT 2
69075: NEG
69076: PUSH
69077: EMPTY
69078: LIST
69079: LIST
69080: PUSH
69081: LD_INT 2
69083: PUSH
69084: LD_INT 3
69086: PUSH
69087: EMPTY
69088: LIST
69089: LIST
69090: PUSH
69091: LD_INT 1
69093: PUSH
69094: LD_INT 3
69096: PUSH
69097: EMPTY
69098: LIST
69099: LIST
69100: PUSH
69101: LD_INT 1
69103: NEG
69104: PUSH
69105: LD_INT 2
69107: PUSH
69108: EMPTY
69109: LIST
69110: LIST
69111: PUSH
69112: LD_INT 2
69114: NEG
69115: PUSH
69116: LD_INT 1
69118: PUSH
69119: EMPTY
69120: LIST
69121: LIST
69122: PUSH
69123: EMPTY
69124: LIST
69125: LIST
69126: LIST
69127: LIST
69128: LIST
69129: LIST
69130: LIST
69131: LIST
69132: LIST
69133: LIST
69134: LIST
69135: LIST
69136: LIST
69137: LIST
69138: LIST
69139: LIST
69140: LIST
69141: LIST
69142: LIST
69143: LIST
69144: LIST
69145: LIST
69146: LIST
69147: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
69148: LD_ADDR_VAR 0 27
69152: PUSH
69153: LD_INT 0
69155: PUSH
69156: LD_INT 0
69158: PUSH
69159: EMPTY
69160: LIST
69161: LIST
69162: PUSH
69163: LD_INT 0
69165: PUSH
69166: LD_INT 1
69168: NEG
69169: PUSH
69170: EMPTY
69171: LIST
69172: LIST
69173: PUSH
69174: LD_INT 1
69176: PUSH
69177: LD_INT 0
69179: PUSH
69180: EMPTY
69181: LIST
69182: LIST
69183: PUSH
69184: LD_INT 1
69186: PUSH
69187: LD_INT 1
69189: PUSH
69190: EMPTY
69191: LIST
69192: LIST
69193: PUSH
69194: LD_INT 0
69196: PUSH
69197: LD_INT 1
69199: PUSH
69200: EMPTY
69201: LIST
69202: LIST
69203: PUSH
69204: LD_INT 1
69206: NEG
69207: PUSH
69208: LD_INT 0
69210: PUSH
69211: EMPTY
69212: LIST
69213: LIST
69214: PUSH
69215: LD_INT 1
69217: NEG
69218: PUSH
69219: LD_INT 1
69221: NEG
69222: PUSH
69223: EMPTY
69224: LIST
69225: LIST
69226: PUSH
69227: LD_INT 1
69229: NEG
69230: PUSH
69231: LD_INT 2
69233: NEG
69234: PUSH
69235: EMPTY
69236: LIST
69237: LIST
69238: PUSH
69239: LD_INT 0
69241: PUSH
69242: LD_INT 2
69244: NEG
69245: PUSH
69246: EMPTY
69247: LIST
69248: LIST
69249: PUSH
69250: LD_INT 1
69252: PUSH
69253: LD_INT 1
69255: NEG
69256: PUSH
69257: EMPTY
69258: LIST
69259: LIST
69260: PUSH
69261: LD_INT 2
69263: PUSH
69264: LD_INT 0
69266: PUSH
69267: EMPTY
69268: LIST
69269: LIST
69270: PUSH
69271: LD_INT 2
69273: PUSH
69274: LD_INT 1
69276: PUSH
69277: EMPTY
69278: LIST
69279: LIST
69280: PUSH
69281: LD_INT 2
69283: PUSH
69284: LD_INT 2
69286: PUSH
69287: EMPTY
69288: LIST
69289: LIST
69290: PUSH
69291: LD_INT 1
69293: PUSH
69294: LD_INT 2
69296: PUSH
69297: EMPTY
69298: LIST
69299: LIST
69300: PUSH
69301: LD_INT 0
69303: PUSH
69304: LD_INT 2
69306: PUSH
69307: EMPTY
69308: LIST
69309: LIST
69310: PUSH
69311: LD_INT 1
69313: NEG
69314: PUSH
69315: LD_INT 1
69317: PUSH
69318: EMPTY
69319: LIST
69320: LIST
69321: PUSH
69322: LD_INT 2
69324: NEG
69325: PUSH
69326: LD_INT 0
69328: PUSH
69329: EMPTY
69330: LIST
69331: LIST
69332: PUSH
69333: LD_INT 2
69335: NEG
69336: PUSH
69337: LD_INT 1
69339: NEG
69340: PUSH
69341: EMPTY
69342: LIST
69343: LIST
69344: PUSH
69345: LD_INT 2
69347: NEG
69348: PUSH
69349: LD_INT 2
69351: NEG
69352: PUSH
69353: EMPTY
69354: LIST
69355: LIST
69356: PUSH
69357: LD_INT 1
69359: NEG
69360: PUSH
69361: LD_INT 2
69363: PUSH
69364: EMPTY
69365: LIST
69366: LIST
69367: PUSH
69368: LD_INT 2
69370: NEG
69371: PUSH
69372: LD_INT 1
69374: PUSH
69375: EMPTY
69376: LIST
69377: LIST
69378: PUSH
69379: LD_INT 3
69381: NEG
69382: PUSH
69383: LD_INT 1
69385: NEG
69386: PUSH
69387: EMPTY
69388: LIST
69389: LIST
69390: PUSH
69391: LD_INT 3
69393: NEG
69394: PUSH
69395: LD_INT 2
69397: NEG
69398: PUSH
69399: EMPTY
69400: LIST
69401: LIST
69402: PUSH
69403: EMPTY
69404: LIST
69405: LIST
69406: LIST
69407: LIST
69408: LIST
69409: LIST
69410: LIST
69411: LIST
69412: LIST
69413: LIST
69414: LIST
69415: LIST
69416: LIST
69417: LIST
69418: LIST
69419: LIST
69420: LIST
69421: LIST
69422: LIST
69423: LIST
69424: LIST
69425: LIST
69426: LIST
69427: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
69428: LD_ADDR_VAR 0 28
69432: PUSH
69433: LD_INT 0
69435: PUSH
69436: LD_INT 0
69438: PUSH
69439: EMPTY
69440: LIST
69441: LIST
69442: PUSH
69443: LD_INT 0
69445: PUSH
69446: LD_INT 1
69448: NEG
69449: PUSH
69450: EMPTY
69451: LIST
69452: LIST
69453: PUSH
69454: LD_INT 1
69456: PUSH
69457: LD_INT 0
69459: PUSH
69460: EMPTY
69461: LIST
69462: LIST
69463: PUSH
69464: LD_INT 1
69466: PUSH
69467: LD_INT 1
69469: PUSH
69470: EMPTY
69471: LIST
69472: LIST
69473: PUSH
69474: LD_INT 0
69476: PUSH
69477: LD_INT 1
69479: PUSH
69480: EMPTY
69481: LIST
69482: LIST
69483: PUSH
69484: LD_INT 1
69486: NEG
69487: PUSH
69488: LD_INT 0
69490: PUSH
69491: EMPTY
69492: LIST
69493: LIST
69494: PUSH
69495: LD_INT 1
69497: NEG
69498: PUSH
69499: LD_INT 1
69501: NEG
69502: PUSH
69503: EMPTY
69504: LIST
69505: LIST
69506: PUSH
69507: LD_INT 1
69509: NEG
69510: PUSH
69511: LD_INT 2
69513: NEG
69514: PUSH
69515: EMPTY
69516: LIST
69517: LIST
69518: PUSH
69519: LD_INT 0
69521: PUSH
69522: LD_INT 2
69524: NEG
69525: PUSH
69526: EMPTY
69527: LIST
69528: LIST
69529: PUSH
69530: LD_INT 1
69532: PUSH
69533: LD_INT 1
69535: NEG
69536: PUSH
69537: EMPTY
69538: LIST
69539: LIST
69540: PUSH
69541: LD_INT 2
69543: PUSH
69544: LD_INT 0
69546: PUSH
69547: EMPTY
69548: LIST
69549: LIST
69550: PUSH
69551: LD_INT 2
69553: PUSH
69554: LD_INT 1
69556: PUSH
69557: EMPTY
69558: LIST
69559: LIST
69560: PUSH
69561: LD_INT 2
69563: PUSH
69564: LD_INT 2
69566: PUSH
69567: EMPTY
69568: LIST
69569: LIST
69570: PUSH
69571: LD_INT 1
69573: PUSH
69574: LD_INT 2
69576: PUSH
69577: EMPTY
69578: LIST
69579: LIST
69580: PUSH
69581: LD_INT 0
69583: PUSH
69584: LD_INT 2
69586: PUSH
69587: EMPTY
69588: LIST
69589: LIST
69590: PUSH
69591: LD_INT 1
69593: NEG
69594: PUSH
69595: LD_INT 1
69597: PUSH
69598: EMPTY
69599: LIST
69600: LIST
69601: PUSH
69602: LD_INT 2
69604: NEG
69605: PUSH
69606: LD_INT 0
69608: PUSH
69609: EMPTY
69610: LIST
69611: LIST
69612: PUSH
69613: LD_INT 2
69615: NEG
69616: PUSH
69617: LD_INT 1
69619: NEG
69620: PUSH
69621: EMPTY
69622: LIST
69623: LIST
69624: PUSH
69625: LD_INT 2
69627: NEG
69628: PUSH
69629: LD_INT 2
69631: NEG
69632: PUSH
69633: EMPTY
69634: LIST
69635: LIST
69636: PUSH
69637: LD_INT 2
69639: NEG
69640: PUSH
69641: LD_INT 3
69643: NEG
69644: PUSH
69645: EMPTY
69646: LIST
69647: LIST
69648: PUSH
69649: LD_INT 1
69651: NEG
69652: PUSH
69653: LD_INT 3
69655: NEG
69656: PUSH
69657: EMPTY
69658: LIST
69659: LIST
69660: PUSH
69661: LD_INT 3
69663: NEG
69664: PUSH
69665: LD_INT 1
69667: NEG
69668: PUSH
69669: EMPTY
69670: LIST
69671: LIST
69672: PUSH
69673: LD_INT 3
69675: NEG
69676: PUSH
69677: LD_INT 2
69679: NEG
69680: PUSH
69681: EMPTY
69682: LIST
69683: LIST
69684: PUSH
69685: EMPTY
69686: LIST
69687: LIST
69688: LIST
69689: LIST
69690: LIST
69691: LIST
69692: LIST
69693: LIST
69694: LIST
69695: LIST
69696: LIST
69697: LIST
69698: LIST
69699: LIST
69700: LIST
69701: LIST
69702: LIST
69703: LIST
69704: LIST
69705: LIST
69706: LIST
69707: LIST
69708: LIST
69709: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
69710: LD_ADDR_VAR 0 29
69714: PUSH
69715: LD_INT 0
69717: PUSH
69718: LD_INT 0
69720: PUSH
69721: EMPTY
69722: LIST
69723: LIST
69724: PUSH
69725: LD_INT 0
69727: PUSH
69728: LD_INT 1
69730: NEG
69731: PUSH
69732: EMPTY
69733: LIST
69734: LIST
69735: PUSH
69736: LD_INT 1
69738: PUSH
69739: LD_INT 0
69741: PUSH
69742: EMPTY
69743: LIST
69744: LIST
69745: PUSH
69746: LD_INT 1
69748: PUSH
69749: LD_INT 1
69751: PUSH
69752: EMPTY
69753: LIST
69754: LIST
69755: PUSH
69756: LD_INT 0
69758: PUSH
69759: LD_INT 1
69761: PUSH
69762: EMPTY
69763: LIST
69764: LIST
69765: PUSH
69766: LD_INT 1
69768: NEG
69769: PUSH
69770: LD_INT 0
69772: PUSH
69773: EMPTY
69774: LIST
69775: LIST
69776: PUSH
69777: LD_INT 1
69779: NEG
69780: PUSH
69781: LD_INT 1
69783: NEG
69784: PUSH
69785: EMPTY
69786: LIST
69787: LIST
69788: PUSH
69789: LD_INT 1
69791: NEG
69792: PUSH
69793: LD_INT 2
69795: NEG
69796: PUSH
69797: EMPTY
69798: LIST
69799: LIST
69800: PUSH
69801: LD_INT 0
69803: PUSH
69804: LD_INT 2
69806: NEG
69807: PUSH
69808: EMPTY
69809: LIST
69810: LIST
69811: PUSH
69812: LD_INT 1
69814: PUSH
69815: LD_INT 1
69817: NEG
69818: PUSH
69819: EMPTY
69820: LIST
69821: LIST
69822: PUSH
69823: LD_INT 2
69825: PUSH
69826: LD_INT 0
69828: PUSH
69829: EMPTY
69830: LIST
69831: LIST
69832: PUSH
69833: LD_INT 2
69835: PUSH
69836: LD_INT 1
69838: PUSH
69839: EMPTY
69840: LIST
69841: LIST
69842: PUSH
69843: LD_INT 1
69845: PUSH
69846: LD_INT 2
69848: PUSH
69849: EMPTY
69850: LIST
69851: LIST
69852: PUSH
69853: LD_INT 0
69855: PUSH
69856: LD_INT 2
69858: PUSH
69859: EMPTY
69860: LIST
69861: LIST
69862: PUSH
69863: LD_INT 1
69865: NEG
69866: PUSH
69867: LD_INT 1
69869: PUSH
69870: EMPTY
69871: LIST
69872: LIST
69873: PUSH
69874: LD_INT 2
69876: NEG
69877: PUSH
69878: LD_INT 1
69880: NEG
69881: PUSH
69882: EMPTY
69883: LIST
69884: LIST
69885: PUSH
69886: LD_INT 2
69888: NEG
69889: PUSH
69890: LD_INT 2
69892: NEG
69893: PUSH
69894: EMPTY
69895: LIST
69896: LIST
69897: PUSH
69898: LD_INT 2
69900: NEG
69901: PUSH
69902: LD_INT 3
69904: NEG
69905: PUSH
69906: EMPTY
69907: LIST
69908: LIST
69909: PUSH
69910: LD_INT 2
69912: PUSH
69913: LD_INT 1
69915: NEG
69916: PUSH
69917: EMPTY
69918: LIST
69919: LIST
69920: PUSH
69921: LD_INT 3
69923: PUSH
69924: LD_INT 1
69926: PUSH
69927: EMPTY
69928: LIST
69929: LIST
69930: PUSH
69931: LD_INT 1
69933: PUSH
69934: LD_INT 3
69936: PUSH
69937: EMPTY
69938: LIST
69939: LIST
69940: PUSH
69941: LD_INT 1
69943: NEG
69944: PUSH
69945: LD_INT 2
69947: PUSH
69948: EMPTY
69949: LIST
69950: LIST
69951: PUSH
69952: LD_INT 3
69954: NEG
69955: PUSH
69956: LD_INT 2
69958: NEG
69959: PUSH
69960: EMPTY
69961: LIST
69962: LIST
69963: PUSH
69964: EMPTY
69965: LIST
69966: LIST
69967: LIST
69968: LIST
69969: LIST
69970: LIST
69971: LIST
69972: LIST
69973: LIST
69974: LIST
69975: LIST
69976: LIST
69977: LIST
69978: LIST
69979: LIST
69980: LIST
69981: LIST
69982: LIST
69983: LIST
69984: LIST
69985: LIST
69986: LIST
69987: LIST
69988: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
69989: LD_ADDR_VAR 0 30
69993: PUSH
69994: LD_INT 0
69996: PUSH
69997: LD_INT 0
69999: PUSH
70000: EMPTY
70001: LIST
70002: LIST
70003: PUSH
70004: LD_INT 0
70006: PUSH
70007: LD_INT 1
70009: NEG
70010: PUSH
70011: EMPTY
70012: LIST
70013: LIST
70014: PUSH
70015: LD_INT 1
70017: PUSH
70018: LD_INT 0
70020: PUSH
70021: EMPTY
70022: LIST
70023: LIST
70024: PUSH
70025: LD_INT 1
70027: PUSH
70028: LD_INT 1
70030: PUSH
70031: EMPTY
70032: LIST
70033: LIST
70034: PUSH
70035: LD_INT 0
70037: PUSH
70038: LD_INT 1
70040: PUSH
70041: EMPTY
70042: LIST
70043: LIST
70044: PUSH
70045: LD_INT 1
70047: NEG
70048: PUSH
70049: LD_INT 0
70051: PUSH
70052: EMPTY
70053: LIST
70054: LIST
70055: PUSH
70056: LD_INT 1
70058: NEG
70059: PUSH
70060: LD_INT 1
70062: NEG
70063: PUSH
70064: EMPTY
70065: LIST
70066: LIST
70067: PUSH
70068: LD_INT 1
70070: NEG
70071: PUSH
70072: LD_INT 2
70074: NEG
70075: PUSH
70076: EMPTY
70077: LIST
70078: LIST
70079: PUSH
70080: LD_INT 0
70082: PUSH
70083: LD_INT 2
70085: NEG
70086: PUSH
70087: EMPTY
70088: LIST
70089: LIST
70090: PUSH
70091: LD_INT 1
70093: PUSH
70094: LD_INT 1
70096: NEG
70097: PUSH
70098: EMPTY
70099: LIST
70100: LIST
70101: PUSH
70102: LD_INT 2
70104: PUSH
70105: LD_INT 0
70107: PUSH
70108: EMPTY
70109: LIST
70110: LIST
70111: PUSH
70112: LD_INT 2
70114: PUSH
70115: LD_INT 1
70117: PUSH
70118: EMPTY
70119: LIST
70120: LIST
70121: PUSH
70122: LD_INT 2
70124: PUSH
70125: LD_INT 2
70127: PUSH
70128: EMPTY
70129: LIST
70130: LIST
70131: PUSH
70132: LD_INT 1
70134: PUSH
70135: LD_INT 2
70137: PUSH
70138: EMPTY
70139: LIST
70140: LIST
70141: PUSH
70142: LD_INT 1
70144: NEG
70145: PUSH
70146: LD_INT 1
70148: PUSH
70149: EMPTY
70150: LIST
70151: LIST
70152: PUSH
70153: LD_INT 2
70155: NEG
70156: PUSH
70157: LD_INT 0
70159: PUSH
70160: EMPTY
70161: LIST
70162: LIST
70163: PUSH
70164: LD_INT 2
70166: NEG
70167: PUSH
70168: LD_INT 1
70170: NEG
70171: PUSH
70172: EMPTY
70173: LIST
70174: LIST
70175: PUSH
70176: LD_INT 1
70178: NEG
70179: PUSH
70180: LD_INT 3
70182: NEG
70183: PUSH
70184: EMPTY
70185: LIST
70186: LIST
70187: PUSH
70188: LD_INT 1
70190: PUSH
70191: LD_INT 2
70193: NEG
70194: PUSH
70195: EMPTY
70196: LIST
70197: LIST
70198: PUSH
70199: LD_INT 3
70201: PUSH
70202: LD_INT 2
70204: PUSH
70205: EMPTY
70206: LIST
70207: LIST
70208: PUSH
70209: LD_INT 2
70211: PUSH
70212: LD_INT 3
70214: PUSH
70215: EMPTY
70216: LIST
70217: LIST
70218: PUSH
70219: LD_INT 2
70221: NEG
70222: PUSH
70223: LD_INT 1
70225: PUSH
70226: EMPTY
70227: LIST
70228: LIST
70229: PUSH
70230: LD_INT 3
70232: NEG
70233: PUSH
70234: LD_INT 1
70236: NEG
70237: PUSH
70238: EMPTY
70239: LIST
70240: LIST
70241: PUSH
70242: EMPTY
70243: LIST
70244: LIST
70245: LIST
70246: LIST
70247: LIST
70248: LIST
70249: LIST
70250: LIST
70251: LIST
70252: LIST
70253: LIST
70254: LIST
70255: LIST
70256: LIST
70257: LIST
70258: LIST
70259: LIST
70260: LIST
70261: LIST
70262: LIST
70263: LIST
70264: LIST
70265: LIST
70266: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70267: LD_ADDR_VAR 0 31
70271: PUSH
70272: LD_INT 0
70274: PUSH
70275: LD_INT 0
70277: PUSH
70278: EMPTY
70279: LIST
70280: LIST
70281: PUSH
70282: LD_INT 0
70284: PUSH
70285: LD_INT 1
70287: NEG
70288: PUSH
70289: EMPTY
70290: LIST
70291: LIST
70292: PUSH
70293: LD_INT 1
70295: PUSH
70296: LD_INT 0
70298: PUSH
70299: EMPTY
70300: LIST
70301: LIST
70302: PUSH
70303: LD_INT 1
70305: PUSH
70306: LD_INT 1
70308: PUSH
70309: EMPTY
70310: LIST
70311: LIST
70312: PUSH
70313: LD_INT 0
70315: PUSH
70316: LD_INT 1
70318: PUSH
70319: EMPTY
70320: LIST
70321: LIST
70322: PUSH
70323: LD_INT 1
70325: NEG
70326: PUSH
70327: LD_INT 0
70329: PUSH
70330: EMPTY
70331: LIST
70332: LIST
70333: PUSH
70334: LD_INT 1
70336: NEG
70337: PUSH
70338: LD_INT 1
70340: NEG
70341: PUSH
70342: EMPTY
70343: LIST
70344: LIST
70345: PUSH
70346: LD_INT 1
70348: NEG
70349: PUSH
70350: LD_INT 2
70352: NEG
70353: PUSH
70354: EMPTY
70355: LIST
70356: LIST
70357: PUSH
70358: LD_INT 1
70360: PUSH
70361: LD_INT 1
70363: NEG
70364: PUSH
70365: EMPTY
70366: LIST
70367: LIST
70368: PUSH
70369: LD_INT 2
70371: PUSH
70372: LD_INT 0
70374: PUSH
70375: EMPTY
70376: LIST
70377: LIST
70378: PUSH
70379: LD_INT 2
70381: PUSH
70382: LD_INT 1
70384: PUSH
70385: EMPTY
70386: LIST
70387: LIST
70388: PUSH
70389: LD_INT 2
70391: PUSH
70392: LD_INT 2
70394: PUSH
70395: EMPTY
70396: LIST
70397: LIST
70398: PUSH
70399: LD_INT 1
70401: PUSH
70402: LD_INT 2
70404: PUSH
70405: EMPTY
70406: LIST
70407: LIST
70408: PUSH
70409: LD_INT 0
70411: PUSH
70412: LD_INT 2
70414: PUSH
70415: EMPTY
70416: LIST
70417: LIST
70418: PUSH
70419: LD_INT 1
70421: NEG
70422: PUSH
70423: LD_INT 1
70425: PUSH
70426: EMPTY
70427: LIST
70428: LIST
70429: PUSH
70430: LD_INT 2
70432: NEG
70433: PUSH
70434: LD_INT 1
70436: NEG
70437: PUSH
70438: EMPTY
70439: LIST
70440: LIST
70441: PUSH
70442: LD_INT 2
70444: NEG
70445: PUSH
70446: LD_INT 2
70448: NEG
70449: PUSH
70450: EMPTY
70451: LIST
70452: LIST
70453: PUSH
70454: LD_INT 2
70456: NEG
70457: PUSH
70458: LD_INT 3
70460: NEG
70461: PUSH
70462: EMPTY
70463: LIST
70464: LIST
70465: PUSH
70466: LD_INT 2
70468: PUSH
70469: LD_INT 1
70471: NEG
70472: PUSH
70473: EMPTY
70474: LIST
70475: LIST
70476: PUSH
70477: LD_INT 3
70479: PUSH
70480: LD_INT 1
70482: PUSH
70483: EMPTY
70484: LIST
70485: LIST
70486: PUSH
70487: LD_INT 1
70489: PUSH
70490: LD_INT 3
70492: PUSH
70493: EMPTY
70494: LIST
70495: LIST
70496: PUSH
70497: LD_INT 1
70499: NEG
70500: PUSH
70501: LD_INT 2
70503: PUSH
70504: EMPTY
70505: LIST
70506: LIST
70507: PUSH
70508: LD_INT 3
70510: NEG
70511: PUSH
70512: LD_INT 2
70514: NEG
70515: PUSH
70516: EMPTY
70517: LIST
70518: LIST
70519: PUSH
70520: EMPTY
70521: LIST
70522: LIST
70523: LIST
70524: LIST
70525: LIST
70526: LIST
70527: LIST
70528: LIST
70529: LIST
70530: LIST
70531: LIST
70532: LIST
70533: LIST
70534: LIST
70535: LIST
70536: LIST
70537: LIST
70538: LIST
70539: LIST
70540: LIST
70541: LIST
70542: LIST
70543: LIST
70544: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70545: LD_ADDR_VAR 0 32
70549: PUSH
70550: LD_INT 0
70552: PUSH
70553: LD_INT 0
70555: PUSH
70556: EMPTY
70557: LIST
70558: LIST
70559: PUSH
70560: LD_INT 0
70562: PUSH
70563: LD_INT 1
70565: NEG
70566: PUSH
70567: EMPTY
70568: LIST
70569: LIST
70570: PUSH
70571: LD_INT 1
70573: PUSH
70574: LD_INT 0
70576: PUSH
70577: EMPTY
70578: LIST
70579: LIST
70580: PUSH
70581: LD_INT 1
70583: PUSH
70584: LD_INT 1
70586: PUSH
70587: EMPTY
70588: LIST
70589: LIST
70590: PUSH
70591: LD_INT 0
70593: PUSH
70594: LD_INT 1
70596: PUSH
70597: EMPTY
70598: LIST
70599: LIST
70600: PUSH
70601: LD_INT 1
70603: NEG
70604: PUSH
70605: LD_INT 0
70607: PUSH
70608: EMPTY
70609: LIST
70610: LIST
70611: PUSH
70612: LD_INT 1
70614: NEG
70615: PUSH
70616: LD_INT 1
70618: NEG
70619: PUSH
70620: EMPTY
70621: LIST
70622: LIST
70623: PUSH
70624: LD_INT 1
70626: NEG
70627: PUSH
70628: LD_INT 2
70630: NEG
70631: PUSH
70632: EMPTY
70633: LIST
70634: LIST
70635: PUSH
70636: LD_INT 0
70638: PUSH
70639: LD_INT 2
70641: NEG
70642: PUSH
70643: EMPTY
70644: LIST
70645: LIST
70646: PUSH
70647: LD_INT 1
70649: PUSH
70650: LD_INT 1
70652: NEG
70653: PUSH
70654: EMPTY
70655: LIST
70656: LIST
70657: PUSH
70658: LD_INT 2
70660: PUSH
70661: LD_INT 1
70663: PUSH
70664: EMPTY
70665: LIST
70666: LIST
70667: PUSH
70668: LD_INT 2
70670: PUSH
70671: LD_INT 2
70673: PUSH
70674: EMPTY
70675: LIST
70676: LIST
70677: PUSH
70678: LD_INT 1
70680: PUSH
70681: LD_INT 2
70683: PUSH
70684: EMPTY
70685: LIST
70686: LIST
70687: PUSH
70688: LD_INT 0
70690: PUSH
70691: LD_INT 2
70693: PUSH
70694: EMPTY
70695: LIST
70696: LIST
70697: PUSH
70698: LD_INT 1
70700: NEG
70701: PUSH
70702: LD_INT 1
70704: PUSH
70705: EMPTY
70706: LIST
70707: LIST
70708: PUSH
70709: LD_INT 2
70711: NEG
70712: PUSH
70713: LD_INT 0
70715: PUSH
70716: EMPTY
70717: LIST
70718: LIST
70719: PUSH
70720: LD_INT 2
70722: NEG
70723: PUSH
70724: LD_INT 1
70726: NEG
70727: PUSH
70728: EMPTY
70729: LIST
70730: LIST
70731: PUSH
70732: LD_INT 1
70734: NEG
70735: PUSH
70736: LD_INT 3
70738: NEG
70739: PUSH
70740: EMPTY
70741: LIST
70742: LIST
70743: PUSH
70744: LD_INT 1
70746: PUSH
70747: LD_INT 2
70749: NEG
70750: PUSH
70751: EMPTY
70752: LIST
70753: LIST
70754: PUSH
70755: LD_INT 3
70757: PUSH
70758: LD_INT 2
70760: PUSH
70761: EMPTY
70762: LIST
70763: LIST
70764: PUSH
70765: LD_INT 2
70767: PUSH
70768: LD_INT 3
70770: PUSH
70771: EMPTY
70772: LIST
70773: LIST
70774: PUSH
70775: LD_INT 2
70777: NEG
70778: PUSH
70779: LD_INT 1
70781: PUSH
70782: EMPTY
70783: LIST
70784: LIST
70785: PUSH
70786: LD_INT 3
70788: NEG
70789: PUSH
70790: LD_INT 1
70792: NEG
70793: PUSH
70794: EMPTY
70795: LIST
70796: LIST
70797: PUSH
70798: EMPTY
70799: LIST
70800: LIST
70801: LIST
70802: LIST
70803: LIST
70804: LIST
70805: LIST
70806: LIST
70807: LIST
70808: LIST
70809: LIST
70810: LIST
70811: LIST
70812: LIST
70813: LIST
70814: LIST
70815: LIST
70816: LIST
70817: LIST
70818: LIST
70819: LIST
70820: LIST
70821: LIST
70822: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70823: LD_ADDR_VAR 0 33
70827: PUSH
70828: LD_INT 0
70830: PUSH
70831: LD_INT 0
70833: PUSH
70834: EMPTY
70835: LIST
70836: LIST
70837: PUSH
70838: LD_INT 0
70840: PUSH
70841: LD_INT 1
70843: NEG
70844: PUSH
70845: EMPTY
70846: LIST
70847: LIST
70848: PUSH
70849: LD_INT 1
70851: PUSH
70852: LD_INT 0
70854: PUSH
70855: EMPTY
70856: LIST
70857: LIST
70858: PUSH
70859: LD_INT 1
70861: PUSH
70862: LD_INT 1
70864: PUSH
70865: EMPTY
70866: LIST
70867: LIST
70868: PUSH
70869: LD_INT 0
70871: PUSH
70872: LD_INT 1
70874: PUSH
70875: EMPTY
70876: LIST
70877: LIST
70878: PUSH
70879: LD_INT 1
70881: NEG
70882: PUSH
70883: LD_INT 0
70885: PUSH
70886: EMPTY
70887: LIST
70888: LIST
70889: PUSH
70890: LD_INT 1
70892: NEG
70893: PUSH
70894: LD_INT 1
70896: NEG
70897: PUSH
70898: EMPTY
70899: LIST
70900: LIST
70901: PUSH
70902: LD_INT 1
70904: NEG
70905: PUSH
70906: LD_INT 2
70908: NEG
70909: PUSH
70910: EMPTY
70911: LIST
70912: LIST
70913: PUSH
70914: LD_INT 1
70916: PUSH
70917: LD_INT 1
70919: NEG
70920: PUSH
70921: EMPTY
70922: LIST
70923: LIST
70924: PUSH
70925: LD_INT 2
70927: PUSH
70928: LD_INT 0
70930: PUSH
70931: EMPTY
70932: LIST
70933: LIST
70934: PUSH
70935: LD_INT 2
70937: PUSH
70938: LD_INT 1
70940: PUSH
70941: EMPTY
70942: LIST
70943: LIST
70944: PUSH
70945: LD_INT 1
70947: PUSH
70948: LD_INT 2
70950: PUSH
70951: EMPTY
70952: LIST
70953: LIST
70954: PUSH
70955: LD_INT 0
70957: PUSH
70958: LD_INT 2
70960: PUSH
70961: EMPTY
70962: LIST
70963: LIST
70964: PUSH
70965: LD_INT 1
70967: NEG
70968: PUSH
70969: LD_INT 1
70971: PUSH
70972: EMPTY
70973: LIST
70974: LIST
70975: PUSH
70976: LD_INT 2
70978: NEG
70979: PUSH
70980: LD_INT 0
70982: PUSH
70983: EMPTY
70984: LIST
70985: LIST
70986: PUSH
70987: LD_INT 2
70989: NEG
70990: PUSH
70991: LD_INT 1
70993: NEG
70994: PUSH
70995: EMPTY
70996: LIST
70997: LIST
70998: PUSH
70999: LD_INT 2
71001: NEG
71002: PUSH
71003: LD_INT 2
71005: NEG
71006: PUSH
71007: EMPTY
71008: LIST
71009: LIST
71010: PUSH
71011: LD_INT 2
71013: NEG
71014: PUSH
71015: LD_INT 3
71017: NEG
71018: PUSH
71019: EMPTY
71020: LIST
71021: LIST
71022: PUSH
71023: LD_INT 2
71025: PUSH
71026: LD_INT 1
71028: NEG
71029: PUSH
71030: EMPTY
71031: LIST
71032: LIST
71033: PUSH
71034: LD_INT 3
71036: PUSH
71037: LD_INT 1
71039: PUSH
71040: EMPTY
71041: LIST
71042: LIST
71043: PUSH
71044: LD_INT 1
71046: PUSH
71047: LD_INT 3
71049: PUSH
71050: EMPTY
71051: LIST
71052: LIST
71053: PUSH
71054: LD_INT 1
71056: NEG
71057: PUSH
71058: LD_INT 2
71060: PUSH
71061: EMPTY
71062: LIST
71063: LIST
71064: PUSH
71065: LD_INT 3
71067: NEG
71068: PUSH
71069: LD_INT 2
71071: NEG
71072: PUSH
71073: EMPTY
71074: LIST
71075: LIST
71076: PUSH
71077: EMPTY
71078: LIST
71079: LIST
71080: LIST
71081: LIST
71082: LIST
71083: LIST
71084: LIST
71085: LIST
71086: LIST
71087: LIST
71088: LIST
71089: LIST
71090: LIST
71091: LIST
71092: LIST
71093: LIST
71094: LIST
71095: LIST
71096: LIST
71097: LIST
71098: LIST
71099: LIST
71100: LIST
71101: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71102: LD_ADDR_VAR 0 34
71106: PUSH
71107: LD_INT 0
71109: PUSH
71110: LD_INT 0
71112: PUSH
71113: EMPTY
71114: LIST
71115: LIST
71116: PUSH
71117: LD_INT 0
71119: PUSH
71120: LD_INT 1
71122: NEG
71123: PUSH
71124: EMPTY
71125: LIST
71126: LIST
71127: PUSH
71128: LD_INT 1
71130: PUSH
71131: LD_INT 0
71133: PUSH
71134: EMPTY
71135: LIST
71136: LIST
71137: PUSH
71138: LD_INT 1
71140: PUSH
71141: LD_INT 1
71143: PUSH
71144: EMPTY
71145: LIST
71146: LIST
71147: PUSH
71148: LD_INT 0
71150: PUSH
71151: LD_INT 1
71153: PUSH
71154: EMPTY
71155: LIST
71156: LIST
71157: PUSH
71158: LD_INT 1
71160: NEG
71161: PUSH
71162: LD_INT 0
71164: PUSH
71165: EMPTY
71166: LIST
71167: LIST
71168: PUSH
71169: LD_INT 1
71171: NEG
71172: PUSH
71173: LD_INT 1
71175: NEG
71176: PUSH
71177: EMPTY
71178: LIST
71179: LIST
71180: PUSH
71181: LD_INT 1
71183: NEG
71184: PUSH
71185: LD_INT 2
71187: NEG
71188: PUSH
71189: EMPTY
71190: LIST
71191: LIST
71192: PUSH
71193: LD_INT 0
71195: PUSH
71196: LD_INT 2
71198: NEG
71199: PUSH
71200: EMPTY
71201: LIST
71202: LIST
71203: PUSH
71204: LD_INT 1
71206: PUSH
71207: LD_INT 1
71209: NEG
71210: PUSH
71211: EMPTY
71212: LIST
71213: LIST
71214: PUSH
71215: LD_INT 2
71217: PUSH
71218: LD_INT 1
71220: PUSH
71221: EMPTY
71222: LIST
71223: LIST
71224: PUSH
71225: LD_INT 2
71227: PUSH
71228: LD_INT 2
71230: PUSH
71231: EMPTY
71232: LIST
71233: LIST
71234: PUSH
71235: LD_INT 1
71237: PUSH
71238: LD_INT 2
71240: PUSH
71241: EMPTY
71242: LIST
71243: LIST
71244: PUSH
71245: LD_INT 1
71247: NEG
71248: PUSH
71249: LD_INT 1
71251: PUSH
71252: EMPTY
71253: LIST
71254: LIST
71255: PUSH
71256: LD_INT 2
71258: NEG
71259: PUSH
71260: LD_INT 0
71262: PUSH
71263: EMPTY
71264: LIST
71265: LIST
71266: PUSH
71267: LD_INT 2
71269: NEG
71270: PUSH
71271: LD_INT 1
71273: NEG
71274: PUSH
71275: EMPTY
71276: LIST
71277: LIST
71278: PUSH
71279: LD_INT 2
71281: NEG
71282: PUSH
71283: LD_INT 2
71285: NEG
71286: PUSH
71287: EMPTY
71288: LIST
71289: LIST
71290: PUSH
71291: LD_INT 1
71293: NEG
71294: PUSH
71295: LD_INT 3
71297: NEG
71298: PUSH
71299: EMPTY
71300: LIST
71301: LIST
71302: PUSH
71303: LD_INT 1
71305: PUSH
71306: LD_INT 2
71308: NEG
71309: PUSH
71310: EMPTY
71311: LIST
71312: LIST
71313: PUSH
71314: LD_INT 3
71316: PUSH
71317: LD_INT 2
71319: PUSH
71320: EMPTY
71321: LIST
71322: LIST
71323: PUSH
71324: LD_INT 2
71326: PUSH
71327: LD_INT 3
71329: PUSH
71330: EMPTY
71331: LIST
71332: LIST
71333: PUSH
71334: LD_INT 2
71336: NEG
71337: PUSH
71338: LD_INT 1
71340: PUSH
71341: EMPTY
71342: LIST
71343: LIST
71344: PUSH
71345: LD_INT 3
71347: NEG
71348: PUSH
71349: LD_INT 1
71351: NEG
71352: PUSH
71353: EMPTY
71354: LIST
71355: LIST
71356: PUSH
71357: EMPTY
71358: LIST
71359: LIST
71360: LIST
71361: LIST
71362: LIST
71363: LIST
71364: LIST
71365: LIST
71366: LIST
71367: LIST
71368: LIST
71369: LIST
71370: LIST
71371: LIST
71372: LIST
71373: LIST
71374: LIST
71375: LIST
71376: LIST
71377: LIST
71378: LIST
71379: LIST
71380: LIST
71381: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
71382: LD_ADDR_VAR 0 35
71386: PUSH
71387: LD_INT 0
71389: PUSH
71390: LD_INT 0
71392: PUSH
71393: EMPTY
71394: LIST
71395: LIST
71396: PUSH
71397: LD_INT 0
71399: PUSH
71400: LD_INT 1
71402: NEG
71403: PUSH
71404: EMPTY
71405: LIST
71406: LIST
71407: PUSH
71408: LD_INT 1
71410: PUSH
71411: LD_INT 0
71413: PUSH
71414: EMPTY
71415: LIST
71416: LIST
71417: PUSH
71418: LD_INT 1
71420: PUSH
71421: LD_INT 1
71423: PUSH
71424: EMPTY
71425: LIST
71426: LIST
71427: PUSH
71428: LD_INT 0
71430: PUSH
71431: LD_INT 1
71433: PUSH
71434: EMPTY
71435: LIST
71436: LIST
71437: PUSH
71438: LD_INT 1
71440: NEG
71441: PUSH
71442: LD_INT 0
71444: PUSH
71445: EMPTY
71446: LIST
71447: LIST
71448: PUSH
71449: LD_INT 1
71451: NEG
71452: PUSH
71453: LD_INT 1
71455: NEG
71456: PUSH
71457: EMPTY
71458: LIST
71459: LIST
71460: PUSH
71461: LD_INT 2
71463: PUSH
71464: LD_INT 1
71466: PUSH
71467: EMPTY
71468: LIST
71469: LIST
71470: PUSH
71471: LD_INT 2
71473: NEG
71474: PUSH
71475: LD_INT 1
71477: NEG
71478: PUSH
71479: EMPTY
71480: LIST
71481: LIST
71482: PUSH
71483: EMPTY
71484: LIST
71485: LIST
71486: LIST
71487: LIST
71488: LIST
71489: LIST
71490: LIST
71491: LIST
71492: LIST
71493: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
71494: LD_ADDR_VAR 0 36
71498: PUSH
71499: LD_INT 0
71501: PUSH
71502: LD_INT 0
71504: PUSH
71505: EMPTY
71506: LIST
71507: LIST
71508: PUSH
71509: LD_INT 0
71511: PUSH
71512: LD_INT 1
71514: NEG
71515: PUSH
71516: EMPTY
71517: LIST
71518: LIST
71519: PUSH
71520: LD_INT 1
71522: PUSH
71523: LD_INT 0
71525: PUSH
71526: EMPTY
71527: LIST
71528: LIST
71529: PUSH
71530: LD_INT 1
71532: PUSH
71533: LD_INT 1
71535: PUSH
71536: EMPTY
71537: LIST
71538: LIST
71539: PUSH
71540: LD_INT 0
71542: PUSH
71543: LD_INT 1
71545: PUSH
71546: EMPTY
71547: LIST
71548: LIST
71549: PUSH
71550: LD_INT 1
71552: NEG
71553: PUSH
71554: LD_INT 0
71556: PUSH
71557: EMPTY
71558: LIST
71559: LIST
71560: PUSH
71561: LD_INT 1
71563: NEG
71564: PUSH
71565: LD_INT 1
71567: NEG
71568: PUSH
71569: EMPTY
71570: LIST
71571: LIST
71572: PUSH
71573: LD_INT 1
71575: NEG
71576: PUSH
71577: LD_INT 2
71579: NEG
71580: PUSH
71581: EMPTY
71582: LIST
71583: LIST
71584: PUSH
71585: LD_INT 1
71587: PUSH
71588: LD_INT 2
71590: PUSH
71591: EMPTY
71592: LIST
71593: LIST
71594: PUSH
71595: EMPTY
71596: LIST
71597: LIST
71598: LIST
71599: LIST
71600: LIST
71601: LIST
71602: LIST
71603: LIST
71604: LIST
71605: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
71606: LD_ADDR_VAR 0 37
71610: PUSH
71611: LD_INT 0
71613: PUSH
71614: LD_INT 0
71616: PUSH
71617: EMPTY
71618: LIST
71619: LIST
71620: PUSH
71621: LD_INT 0
71623: PUSH
71624: LD_INT 1
71626: NEG
71627: PUSH
71628: EMPTY
71629: LIST
71630: LIST
71631: PUSH
71632: LD_INT 1
71634: PUSH
71635: LD_INT 0
71637: PUSH
71638: EMPTY
71639: LIST
71640: LIST
71641: PUSH
71642: LD_INT 1
71644: PUSH
71645: LD_INT 1
71647: PUSH
71648: EMPTY
71649: LIST
71650: LIST
71651: PUSH
71652: LD_INT 0
71654: PUSH
71655: LD_INT 1
71657: PUSH
71658: EMPTY
71659: LIST
71660: LIST
71661: PUSH
71662: LD_INT 1
71664: NEG
71665: PUSH
71666: LD_INT 0
71668: PUSH
71669: EMPTY
71670: LIST
71671: LIST
71672: PUSH
71673: LD_INT 1
71675: NEG
71676: PUSH
71677: LD_INT 1
71679: NEG
71680: PUSH
71681: EMPTY
71682: LIST
71683: LIST
71684: PUSH
71685: LD_INT 1
71687: PUSH
71688: LD_INT 1
71690: NEG
71691: PUSH
71692: EMPTY
71693: LIST
71694: LIST
71695: PUSH
71696: LD_INT 1
71698: NEG
71699: PUSH
71700: LD_INT 1
71702: PUSH
71703: EMPTY
71704: LIST
71705: LIST
71706: PUSH
71707: EMPTY
71708: LIST
71709: LIST
71710: LIST
71711: LIST
71712: LIST
71713: LIST
71714: LIST
71715: LIST
71716: LIST
71717: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
71718: LD_ADDR_VAR 0 38
71722: PUSH
71723: LD_INT 0
71725: PUSH
71726: LD_INT 0
71728: PUSH
71729: EMPTY
71730: LIST
71731: LIST
71732: PUSH
71733: LD_INT 0
71735: PUSH
71736: LD_INT 1
71738: NEG
71739: PUSH
71740: EMPTY
71741: LIST
71742: LIST
71743: PUSH
71744: LD_INT 1
71746: PUSH
71747: LD_INT 0
71749: PUSH
71750: EMPTY
71751: LIST
71752: LIST
71753: PUSH
71754: LD_INT 1
71756: PUSH
71757: LD_INT 1
71759: PUSH
71760: EMPTY
71761: LIST
71762: LIST
71763: PUSH
71764: LD_INT 0
71766: PUSH
71767: LD_INT 1
71769: PUSH
71770: EMPTY
71771: LIST
71772: LIST
71773: PUSH
71774: LD_INT 1
71776: NEG
71777: PUSH
71778: LD_INT 0
71780: PUSH
71781: EMPTY
71782: LIST
71783: LIST
71784: PUSH
71785: LD_INT 1
71787: NEG
71788: PUSH
71789: LD_INT 1
71791: NEG
71792: PUSH
71793: EMPTY
71794: LIST
71795: LIST
71796: PUSH
71797: LD_INT 2
71799: PUSH
71800: LD_INT 1
71802: PUSH
71803: EMPTY
71804: LIST
71805: LIST
71806: PUSH
71807: LD_INT 2
71809: NEG
71810: PUSH
71811: LD_INT 1
71813: NEG
71814: PUSH
71815: EMPTY
71816: LIST
71817: LIST
71818: PUSH
71819: EMPTY
71820: LIST
71821: LIST
71822: LIST
71823: LIST
71824: LIST
71825: LIST
71826: LIST
71827: LIST
71828: LIST
71829: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
71830: LD_ADDR_VAR 0 39
71834: PUSH
71835: LD_INT 0
71837: PUSH
71838: LD_INT 0
71840: PUSH
71841: EMPTY
71842: LIST
71843: LIST
71844: PUSH
71845: LD_INT 0
71847: PUSH
71848: LD_INT 1
71850: NEG
71851: PUSH
71852: EMPTY
71853: LIST
71854: LIST
71855: PUSH
71856: LD_INT 1
71858: PUSH
71859: LD_INT 0
71861: PUSH
71862: EMPTY
71863: LIST
71864: LIST
71865: PUSH
71866: LD_INT 1
71868: PUSH
71869: LD_INT 1
71871: PUSH
71872: EMPTY
71873: LIST
71874: LIST
71875: PUSH
71876: LD_INT 0
71878: PUSH
71879: LD_INT 1
71881: PUSH
71882: EMPTY
71883: LIST
71884: LIST
71885: PUSH
71886: LD_INT 1
71888: NEG
71889: PUSH
71890: LD_INT 0
71892: PUSH
71893: EMPTY
71894: LIST
71895: LIST
71896: PUSH
71897: LD_INT 1
71899: NEG
71900: PUSH
71901: LD_INT 1
71903: NEG
71904: PUSH
71905: EMPTY
71906: LIST
71907: LIST
71908: PUSH
71909: LD_INT 1
71911: NEG
71912: PUSH
71913: LD_INT 2
71915: NEG
71916: PUSH
71917: EMPTY
71918: LIST
71919: LIST
71920: PUSH
71921: LD_INT 1
71923: PUSH
71924: LD_INT 2
71926: PUSH
71927: EMPTY
71928: LIST
71929: LIST
71930: PUSH
71931: EMPTY
71932: LIST
71933: LIST
71934: LIST
71935: LIST
71936: LIST
71937: LIST
71938: LIST
71939: LIST
71940: LIST
71941: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
71942: LD_ADDR_VAR 0 40
71946: PUSH
71947: LD_INT 0
71949: PUSH
71950: LD_INT 0
71952: PUSH
71953: EMPTY
71954: LIST
71955: LIST
71956: PUSH
71957: LD_INT 0
71959: PUSH
71960: LD_INT 1
71962: NEG
71963: PUSH
71964: EMPTY
71965: LIST
71966: LIST
71967: PUSH
71968: LD_INT 1
71970: PUSH
71971: LD_INT 0
71973: PUSH
71974: EMPTY
71975: LIST
71976: LIST
71977: PUSH
71978: LD_INT 1
71980: PUSH
71981: LD_INT 1
71983: PUSH
71984: EMPTY
71985: LIST
71986: LIST
71987: PUSH
71988: LD_INT 0
71990: PUSH
71991: LD_INT 1
71993: PUSH
71994: EMPTY
71995: LIST
71996: LIST
71997: PUSH
71998: LD_INT 1
72000: NEG
72001: PUSH
72002: LD_INT 0
72004: PUSH
72005: EMPTY
72006: LIST
72007: LIST
72008: PUSH
72009: LD_INT 1
72011: NEG
72012: PUSH
72013: LD_INT 1
72015: NEG
72016: PUSH
72017: EMPTY
72018: LIST
72019: LIST
72020: PUSH
72021: LD_INT 1
72023: PUSH
72024: LD_INT 1
72026: NEG
72027: PUSH
72028: EMPTY
72029: LIST
72030: LIST
72031: PUSH
72032: LD_INT 1
72034: NEG
72035: PUSH
72036: LD_INT 1
72038: PUSH
72039: EMPTY
72040: LIST
72041: LIST
72042: PUSH
72043: EMPTY
72044: LIST
72045: LIST
72046: LIST
72047: LIST
72048: LIST
72049: LIST
72050: LIST
72051: LIST
72052: LIST
72053: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72054: LD_ADDR_VAR 0 41
72058: PUSH
72059: LD_INT 0
72061: PUSH
72062: LD_INT 0
72064: PUSH
72065: EMPTY
72066: LIST
72067: LIST
72068: PUSH
72069: LD_INT 0
72071: PUSH
72072: LD_INT 1
72074: NEG
72075: PUSH
72076: EMPTY
72077: LIST
72078: LIST
72079: PUSH
72080: LD_INT 1
72082: PUSH
72083: LD_INT 0
72085: PUSH
72086: EMPTY
72087: LIST
72088: LIST
72089: PUSH
72090: LD_INT 1
72092: PUSH
72093: LD_INT 1
72095: PUSH
72096: EMPTY
72097: LIST
72098: LIST
72099: PUSH
72100: LD_INT 0
72102: PUSH
72103: LD_INT 1
72105: PUSH
72106: EMPTY
72107: LIST
72108: LIST
72109: PUSH
72110: LD_INT 1
72112: NEG
72113: PUSH
72114: LD_INT 0
72116: PUSH
72117: EMPTY
72118: LIST
72119: LIST
72120: PUSH
72121: LD_INT 1
72123: NEG
72124: PUSH
72125: LD_INT 1
72127: NEG
72128: PUSH
72129: EMPTY
72130: LIST
72131: LIST
72132: PUSH
72133: LD_INT 1
72135: NEG
72136: PUSH
72137: LD_INT 2
72139: NEG
72140: PUSH
72141: EMPTY
72142: LIST
72143: LIST
72144: PUSH
72145: LD_INT 1
72147: PUSH
72148: LD_INT 1
72150: NEG
72151: PUSH
72152: EMPTY
72153: LIST
72154: LIST
72155: PUSH
72156: LD_INT 2
72158: PUSH
72159: LD_INT 0
72161: PUSH
72162: EMPTY
72163: LIST
72164: LIST
72165: PUSH
72166: LD_INT 2
72168: PUSH
72169: LD_INT 1
72171: PUSH
72172: EMPTY
72173: LIST
72174: LIST
72175: PUSH
72176: LD_INT 2
72178: PUSH
72179: LD_INT 2
72181: PUSH
72182: EMPTY
72183: LIST
72184: LIST
72185: PUSH
72186: LD_INT 1
72188: PUSH
72189: LD_INT 2
72191: PUSH
72192: EMPTY
72193: LIST
72194: LIST
72195: PUSH
72196: LD_INT 1
72198: NEG
72199: PUSH
72200: LD_INT 1
72202: PUSH
72203: EMPTY
72204: LIST
72205: LIST
72206: PUSH
72207: LD_INT 2
72209: NEG
72210: PUSH
72211: LD_INT 0
72213: PUSH
72214: EMPTY
72215: LIST
72216: LIST
72217: PUSH
72218: LD_INT 2
72220: NEG
72221: PUSH
72222: LD_INT 1
72224: NEG
72225: PUSH
72226: EMPTY
72227: LIST
72228: LIST
72229: PUSH
72230: LD_INT 2
72232: NEG
72233: PUSH
72234: LD_INT 2
72236: NEG
72237: PUSH
72238: EMPTY
72239: LIST
72240: LIST
72241: PUSH
72242: LD_INT 2
72244: NEG
72245: PUSH
72246: LD_INT 3
72248: NEG
72249: PUSH
72250: EMPTY
72251: LIST
72252: LIST
72253: PUSH
72254: LD_INT 2
72256: PUSH
72257: LD_INT 1
72259: NEG
72260: PUSH
72261: EMPTY
72262: LIST
72263: LIST
72264: PUSH
72265: LD_INT 3
72267: PUSH
72268: LD_INT 0
72270: PUSH
72271: EMPTY
72272: LIST
72273: LIST
72274: PUSH
72275: LD_INT 3
72277: PUSH
72278: LD_INT 1
72280: PUSH
72281: EMPTY
72282: LIST
72283: LIST
72284: PUSH
72285: LD_INT 3
72287: PUSH
72288: LD_INT 2
72290: PUSH
72291: EMPTY
72292: LIST
72293: LIST
72294: PUSH
72295: LD_INT 3
72297: PUSH
72298: LD_INT 3
72300: PUSH
72301: EMPTY
72302: LIST
72303: LIST
72304: PUSH
72305: LD_INT 2
72307: PUSH
72308: LD_INT 3
72310: PUSH
72311: EMPTY
72312: LIST
72313: LIST
72314: PUSH
72315: LD_INT 2
72317: NEG
72318: PUSH
72319: LD_INT 1
72321: PUSH
72322: EMPTY
72323: LIST
72324: LIST
72325: PUSH
72326: LD_INT 3
72328: NEG
72329: PUSH
72330: LD_INT 0
72332: PUSH
72333: EMPTY
72334: LIST
72335: LIST
72336: PUSH
72337: LD_INT 3
72339: NEG
72340: PUSH
72341: LD_INT 1
72343: NEG
72344: PUSH
72345: EMPTY
72346: LIST
72347: LIST
72348: PUSH
72349: LD_INT 3
72351: NEG
72352: PUSH
72353: LD_INT 2
72355: NEG
72356: PUSH
72357: EMPTY
72358: LIST
72359: LIST
72360: PUSH
72361: LD_INT 3
72363: NEG
72364: PUSH
72365: LD_INT 3
72367: NEG
72368: PUSH
72369: EMPTY
72370: LIST
72371: LIST
72372: PUSH
72373: EMPTY
72374: LIST
72375: LIST
72376: LIST
72377: LIST
72378: LIST
72379: LIST
72380: LIST
72381: LIST
72382: LIST
72383: LIST
72384: LIST
72385: LIST
72386: LIST
72387: LIST
72388: LIST
72389: LIST
72390: LIST
72391: LIST
72392: LIST
72393: LIST
72394: LIST
72395: LIST
72396: LIST
72397: LIST
72398: LIST
72399: LIST
72400: LIST
72401: LIST
72402: LIST
72403: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72404: LD_ADDR_VAR 0 42
72408: PUSH
72409: LD_INT 0
72411: PUSH
72412: LD_INT 0
72414: PUSH
72415: EMPTY
72416: LIST
72417: LIST
72418: PUSH
72419: LD_INT 0
72421: PUSH
72422: LD_INT 1
72424: NEG
72425: PUSH
72426: EMPTY
72427: LIST
72428: LIST
72429: PUSH
72430: LD_INT 1
72432: PUSH
72433: LD_INT 0
72435: PUSH
72436: EMPTY
72437: LIST
72438: LIST
72439: PUSH
72440: LD_INT 1
72442: PUSH
72443: LD_INT 1
72445: PUSH
72446: EMPTY
72447: LIST
72448: LIST
72449: PUSH
72450: LD_INT 0
72452: PUSH
72453: LD_INT 1
72455: PUSH
72456: EMPTY
72457: LIST
72458: LIST
72459: PUSH
72460: LD_INT 1
72462: NEG
72463: PUSH
72464: LD_INT 0
72466: PUSH
72467: EMPTY
72468: LIST
72469: LIST
72470: PUSH
72471: LD_INT 1
72473: NEG
72474: PUSH
72475: LD_INT 1
72477: NEG
72478: PUSH
72479: EMPTY
72480: LIST
72481: LIST
72482: PUSH
72483: LD_INT 1
72485: NEG
72486: PUSH
72487: LD_INT 2
72489: NEG
72490: PUSH
72491: EMPTY
72492: LIST
72493: LIST
72494: PUSH
72495: LD_INT 0
72497: PUSH
72498: LD_INT 2
72500: NEG
72501: PUSH
72502: EMPTY
72503: LIST
72504: LIST
72505: PUSH
72506: LD_INT 1
72508: PUSH
72509: LD_INT 1
72511: NEG
72512: PUSH
72513: EMPTY
72514: LIST
72515: LIST
72516: PUSH
72517: LD_INT 2
72519: PUSH
72520: LD_INT 1
72522: PUSH
72523: EMPTY
72524: LIST
72525: LIST
72526: PUSH
72527: LD_INT 2
72529: PUSH
72530: LD_INT 2
72532: PUSH
72533: EMPTY
72534: LIST
72535: LIST
72536: PUSH
72537: LD_INT 1
72539: PUSH
72540: LD_INT 2
72542: PUSH
72543: EMPTY
72544: LIST
72545: LIST
72546: PUSH
72547: LD_INT 0
72549: PUSH
72550: LD_INT 2
72552: PUSH
72553: EMPTY
72554: LIST
72555: LIST
72556: PUSH
72557: LD_INT 1
72559: NEG
72560: PUSH
72561: LD_INT 1
72563: PUSH
72564: EMPTY
72565: LIST
72566: LIST
72567: PUSH
72568: LD_INT 2
72570: NEG
72571: PUSH
72572: LD_INT 1
72574: NEG
72575: PUSH
72576: EMPTY
72577: LIST
72578: LIST
72579: PUSH
72580: LD_INT 2
72582: NEG
72583: PUSH
72584: LD_INT 2
72586: NEG
72587: PUSH
72588: EMPTY
72589: LIST
72590: LIST
72591: PUSH
72592: LD_INT 2
72594: NEG
72595: PUSH
72596: LD_INT 3
72598: NEG
72599: PUSH
72600: EMPTY
72601: LIST
72602: LIST
72603: PUSH
72604: LD_INT 1
72606: NEG
72607: PUSH
72608: LD_INT 3
72610: NEG
72611: PUSH
72612: EMPTY
72613: LIST
72614: LIST
72615: PUSH
72616: LD_INT 0
72618: PUSH
72619: LD_INT 3
72621: NEG
72622: PUSH
72623: EMPTY
72624: LIST
72625: LIST
72626: PUSH
72627: LD_INT 1
72629: PUSH
72630: LD_INT 2
72632: NEG
72633: PUSH
72634: EMPTY
72635: LIST
72636: LIST
72637: PUSH
72638: LD_INT 3
72640: PUSH
72641: LD_INT 2
72643: PUSH
72644: EMPTY
72645: LIST
72646: LIST
72647: PUSH
72648: LD_INT 3
72650: PUSH
72651: LD_INT 3
72653: PUSH
72654: EMPTY
72655: LIST
72656: LIST
72657: PUSH
72658: LD_INT 2
72660: PUSH
72661: LD_INT 3
72663: PUSH
72664: EMPTY
72665: LIST
72666: LIST
72667: PUSH
72668: LD_INT 1
72670: PUSH
72671: LD_INT 3
72673: PUSH
72674: EMPTY
72675: LIST
72676: LIST
72677: PUSH
72678: LD_INT 0
72680: PUSH
72681: LD_INT 3
72683: PUSH
72684: EMPTY
72685: LIST
72686: LIST
72687: PUSH
72688: LD_INT 1
72690: NEG
72691: PUSH
72692: LD_INT 2
72694: PUSH
72695: EMPTY
72696: LIST
72697: LIST
72698: PUSH
72699: LD_INT 3
72701: NEG
72702: PUSH
72703: LD_INT 2
72705: NEG
72706: PUSH
72707: EMPTY
72708: LIST
72709: LIST
72710: PUSH
72711: LD_INT 3
72713: NEG
72714: PUSH
72715: LD_INT 3
72717: NEG
72718: PUSH
72719: EMPTY
72720: LIST
72721: LIST
72722: PUSH
72723: EMPTY
72724: LIST
72725: LIST
72726: LIST
72727: LIST
72728: LIST
72729: LIST
72730: LIST
72731: LIST
72732: LIST
72733: LIST
72734: LIST
72735: LIST
72736: LIST
72737: LIST
72738: LIST
72739: LIST
72740: LIST
72741: LIST
72742: LIST
72743: LIST
72744: LIST
72745: LIST
72746: LIST
72747: LIST
72748: LIST
72749: LIST
72750: LIST
72751: LIST
72752: LIST
72753: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
72754: LD_ADDR_VAR 0 43
72758: PUSH
72759: LD_INT 0
72761: PUSH
72762: LD_INT 0
72764: PUSH
72765: EMPTY
72766: LIST
72767: LIST
72768: PUSH
72769: LD_INT 0
72771: PUSH
72772: LD_INT 1
72774: NEG
72775: PUSH
72776: EMPTY
72777: LIST
72778: LIST
72779: PUSH
72780: LD_INT 1
72782: PUSH
72783: LD_INT 0
72785: PUSH
72786: EMPTY
72787: LIST
72788: LIST
72789: PUSH
72790: LD_INT 1
72792: PUSH
72793: LD_INT 1
72795: PUSH
72796: EMPTY
72797: LIST
72798: LIST
72799: PUSH
72800: LD_INT 0
72802: PUSH
72803: LD_INT 1
72805: PUSH
72806: EMPTY
72807: LIST
72808: LIST
72809: PUSH
72810: LD_INT 1
72812: NEG
72813: PUSH
72814: LD_INT 0
72816: PUSH
72817: EMPTY
72818: LIST
72819: LIST
72820: PUSH
72821: LD_INT 1
72823: NEG
72824: PUSH
72825: LD_INT 1
72827: NEG
72828: PUSH
72829: EMPTY
72830: LIST
72831: LIST
72832: PUSH
72833: LD_INT 1
72835: NEG
72836: PUSH
72837: LD_INT 2
72839: NEG
72840: PUSH
72841: EMPTY
72842: LIST
72843: LIST
72844: PUSH
72845: LD_INT 0
72847: PUSH
72848: LD_INT 2
72850: NEG
72851: PUSH
72852: EMPTY
72853: LIST
72854: LIST
72855: PUSH
72856: LD_INT 1
72858: PUSH
72859: LD_INT 1
72861: NEG
72862: PUSH
72863: EMPTY
72864: LIST
72865: LIST
72866: PUSH
72867: LD_INT 2
72869: PUSH
72870: LD_INT 0
72872: PUSH
72873: EMPTY
72874: LIST
72875: LIST
72876: PUSH
72877: LD_INT 2
72879: PUSH
72880: LD_INT 1
72882: PUSH
72883: EMPTY
72884: LIST
72885: LIST
72886: PUSH
72887: LD_INT 1
72889: PUSH
72890: LD_INT 2
72892: PUSH
72893: EMPTY
72894: LIST
72895: LIST
72896: PUSH
72897: LD_INT 0
72899: PUSH
72900: LD_INT 2
72902: PUSH
72903: EMPTY
72904: LIST
72905: LIST
72906: PUSH
72907: LD_INT 1
72909: NEG
72910: PUSH
72911: LD_INT 1
72913: PUSH
72914: EMPTY
72915: LIST
72916: LIST
72917: PUSH
72918: LD_INT 2
72920: NEG
72921: PUSH
72922: LD_INT 0
72924: PUSH
72925: EMPTY
72926: LIST
72927: LIST
72928: PUSH
72929: LD_INT 2
72931: NEG
72932: PUSH
72933: LD_INT 1
72935: NEG
72936: PUSH
72937: EMPTY
72938: LIST
72939: LIST
72940: PUSH
72941: LD_INT 1
72943: NEG
72944: PUSH
72945: LD_INT 3
72947: NEG
72948: PUSH
72949: EMPTY
72950: LIST
72951: LIST
72952: PUSH
72953: LD_INT 0
72955: PUSH
72956: LD_INT 3
72958: NEG
72959: PUSH
72960: EMPTY
72961: LIST
72962: LIST
72963: PUSH
72964: LD_INT 1
72966: PUSH
72967: LD_INT 2
72969: NEG
72970: PUSH
72971: EMPTY
72972: LIST
72973: LIST
72974: PUSH
72975: LD_INT 2
72977: PUSH
72978: LD_INT 1
72980: NEG
72981: PUSH
72982: EMPTY
72983: LIST
72984: LIST
72985: PUSH
72986: LD_INT 3
72988: PUSH
72989: LD_INT 0
72991: PUSH
72992: EMPTY
72993: LIST
72994: LIST
72995: PUSH
72996: LD_INT 3
72998: PUSH
72999: LD_INT 1
73001: PUSH
73002: EMPTY
73003: LIST
73004: LIST
73005: PUSH
73006: LD_INT 1
73008: PUSH
73009: LD_INT 3
73011: PUSH
73012: EMPTY
73013: LIST
73014: LIST
73015: PUSH
73016: LD_INT 0
73018: PUSH
73019: LD_INT 3
73021: PUSH
73022: EMPTY
73023: LIST
73024: LIST
73025: PUSH
73026: LD_INT 1
73028: NEG
73029: PUSH
73030: LD_INT 2
73032: PUSH
73033: EMPTY
73034: LIST
73035: LIST
73036: PUSH
73037: LD_INT 2
73039: NEG
73040: PUSH
73041: LD_INT 1
73043: PUSH
73044: EMPTY
73045: LIST
73046: LIST
73047: PUSH
73048: LD_INT 3
73050: NEG
73051: PUSH
73052: LD_INT 0
73054: PUSH
73055: EMPTY
73056: LIST
73057: LIST
73058: PUSH
73059: LD_INT 3
73061: NEG
73062: PUSH
73063: LD_INT 1
73065: NEG
73066: PUSH
73067: EMPTY
73068: LIST
73069: LIST
73070: PUSH
73071: EMPTY
73072: LIST
73073: LIST
73074: LIST
73075: LIST
73076: LIST
73077: LIST
73078: LIST
73079: LIST
73080: LIST
73081: LIST
73082: LIST
73083: LIST
73084: LIST
73085: LIST
73086: LIST
73087: LIST
73088: LIST
73089: LIST
73090: LIST
73091: LIST
73092: LIST
73093: LIST
73094: LIST
73095: LIST
73096: LIST
73097: LIST
73098: LIST
73099: LIST
73100: LIST
73101: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73102: LD_ADDR_VAR 0 44
73106: PUSH
73107: LD_INT 0
73109: PUSH
73110: LD_INT 0
73112: PUSH
73113: EMPTY
73114: LIST
73115: LIST
73116: PUSH
73117: LD_INT 0
73119: PUSH
73120: LD_INT 1
73122: NEG
73123: PUSH
73124: EMPTY
73125: LIST
73126: LIST
73127: PUSH
73128: LD_INT 1
73130: PUSH
73131: LD_INT 0
73133: PUSH
73134: EMPTY
73135: LIST
73136: LIST
73137: PUSH
73138: LD_INT 1
73140: PUSH
73141: LD_INT 1
73143: PUSH
73144: EMPTY
73145: LIST
73146: LIST
73147: PUSH
73148: LD_INT 0
73150: PUSH
73151: LD_INT 1
73153: PUSH
73154: EMPTY
73155: LIST
73156: LIST
73157: PUSH
73158: LD_INT 1
73160: NEG
73161: PUSH
73162: LD_INT 0
73164: PUSH
73165: EMPTY
73166: LIST
73167: LIST
73168: PUSH
73169: LD_INT 1
73171: NEG
73172: PUSH
73173: LD_INT 1
73175: NEG
73176: PUSH
73177: EMPTY
73178: LIST
73179: LIST
73180: PUSH
73181: LD_INT 1
73183: NEG
73184: PUSH
73185: LD_INT 2
73187: NEG
73188: PUSH
73189: EMPTY
73190: LIST
73191: LIST
73192: PUSH
73193: LD_INT 1
73195: PUSH
73196: LD_INT 1
73198: NEG
73199: PUSH
73200: EMPTY
73201: LIST
73202: LIST
73203: PUSH
73204: LD_INT 2
73206: PUSH
73207: LD_INT 0
73209: PUSH
73210: EMPTY
73211: LIST
73212: LIST
73213: PUSH
73214: LD_INT 2
73216: PUSH
73217: LD_INT 1
73219: PUSH
73220: EMPTY
73221: LIST
73222: LIST
73223: PUSH
73224: LD_INT 2
73226: PUSH
73227: LD_INT 2
73229: PUSH
73230: EMPTY
73231: LIST
73232: LIST
73233: PUSH
73234: LD_INT 1
73236: PUSH
73237: LD_INT 2
73239: PUSH
73240: EMPTY
73241: LIST
73242: LIST
73243: PUSH
73244: LD_INT 1
73246: NEG
73247: PUSH
73248: LD_INT 1
73250: PUSH
73251: EMPTY
73252: LIST
73253: LIST
73254: PUSH
73255: LD_INT 2
73257: NEG
73258: PUSH
73259: LD_INT 0
73261: PUSH
73262: EMPTY
73263: LIST
73264: LIST
73265: PUSH
73266: LD_INT 2
73268: NEG
73269: PUSH
73270: LD_INT 1
73272: NEG
73273: PUSH
73274: EMPTY
73275: LIST
73276: LIST
73277: PUSH
73278: LD_INT 2
73280: NEG
73281: PUSH
73282: LD_INT 2
73284: NEG
73285: PUSH
73286: EMPTY
73287: LIST
73288: LIST
73289: PUSH
73290: LD_INT 2
73292: NEG
73293: PUSH
73294: LD_INT 3
73296: NEG
73297: PUSH
73298: EMPTY
73299: LIST
73300: LIST
73301: PUSH
73302: LD_INT 2
73304: PUSH
73305: LD_INT 1
73307: NEG
73308: PUSH
73309: EMPTY
73310: LIST
73311: LIST
73312: PUSH
73313: LD_INT 3
73315: PUSH
73316: LD_INT 0
73318: PUSH
73319: EMPTY
73320: LIST
73321: LIST
73322: PUSH
73323: LD_INT 3
73325: PUSH
73326: LD_INT 1
73328: PUSH
73329: EMPTY
73330: LIST
73331: LIST
73332: PUSH
73333: LD_INT 3
73335: PUSH
73336: LD_INT 2
73338: PUSH
73339: EMPTY
73340: LIST
73341: LIST
73342: PUSH
73343: LD_INT 3
73345: PUSH
73346: LD_INT 3
73348: PUSH
73349: EMPTY
73350: LIST
73351: LIST
73352: PUSH
73353: LD_INT 2
73355: PUSH
73356: LD_INT 3
73358: PUSH
73359: EMPTY
73360: LIST
73361: LIST
73362: PUSH
73363: LD_INT 2
73365: NEG
73366: PUSH
73367: LD_INT 1
73369: PUSH
73370: EMPTY
73371: LIST
73372: LIST
73373: PUSH
73374: LD_INT 3
73376: NEG
73377: PUSH
73378: LD_INT 0
73380: PUSH
73381: EMPTY
73382: LIST
73383: LIST
73384: PUSH
73385: LD_INT 3
73387: NEG
73388: PUSH
73389: LD_INT 1
73391: NEG
73392: PUSH
73393: EMPTY
73394: LIST
73395: LIST
73396: PUSH
73397: LD_INT 3
73399: NEG
73400: PUSH
73401: LD_INT 2
73403: NEG
73404: PUSH
73405: EMPTY
73406: LIST
73407: LIST
73408: PUSH
73409: LD_INT 3
73411: NEG
73412: PUSH
73413: LD_INT 3
73415: NEG
73416: PUSH
73417: EMPTY
73418: LIST
73419: LIST
73420: PUSH
73421: EMPTY
73422: LIST
73423: LIST
73424: LIST
73425: LIST
73426: LIST
73427: LIST
73428: LIST
73429: LIST
73430: LIST
73431: LIST
73432: LIST
73433: LIST
73434: LIST
73435: LIST
73436: LIST
73437: LIST
73438: LIST
73439: LIST
73440: LIST
73441: LIST
73442: LIST
73443: LIST
73444: LIST
73445: LIST
73446: LIST
73447: LIST
73448: LIST
73449: LIST
73450: LIST
73451: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73452: LD_ADDR_VAR 0 45
73456: PUSH
73457: LD_INT 0
73459: PUSH
73460: LD_INT 0
73462: PUSH
73463: EMPTY
73464: LIST
73465: LIST
73466: PUSH
73467: LD_INT 0
73469: PUSH
73470: LD_INT 1
73472: NEG
73473: PUSH
73474: EMPTY
73475: LIST
73476: LIST
73477: PUSH
73478: LD_INT 1
73480: PUSH
73481: LD_INT 0
73483: PUSH
73484: EMPTY
73485: LIST
73486: LIST
73487: PUSH
73488: LD_INT 1
73490: PUSH
73491: LD_INT 1
73493: PUSH
73494: EMPTY
73495: LIST
73496: LIST
73497: PUSH
73498: LD_INT 0
73500: PUSH
73501: LD_INT 1
73503: PUSH
73504: EMPTY
73505: LIST
73506: LIST
73507: PUSH
73508: LD_INT 1
73510: NEG
73511: PUSH
73512: LD_INT 0
73514: PUSH
73515: EMPTY
73516: LIST
73517: LIST
73518: PUSH
73519: LD_INT 1
73521: NEG
73522: PUSH
73523: LD_INT 1
73525: NEG
73526: PUSH
73527: EMPTY
73528: LIST
73529: LIST
73530: PUSH
73531: LD_INT 1
73533: NEG
73534: PUSH
73535: LD_INT 2
73537: NEG
73538: PUSH
73539: EMPTY
73540: LIST
73541: LIST
73542: PUSH
73543: LD_INT 0
73545: PUSH
73546: LD_INT 2
73548: NEG
73549: PUSH
73550: EMPTY
73551: LIST
73552: LIST
73553: PUSH
73554: LD_INT 1
73556: PUSH
73557: LD_INT 1
73559: NEG
73560: PUSH
73561: EMPTY
73562: LIST
73563: LIST
73564: PUSH
73565: LD_INT 2
73567: PUSH
73568: LD_INT 1
73570: PUSH
73571: EMPTY
73572: LIST
73573: LIST
73574: PUSH
73575: LD_INT 2
73577: PUSH
73578: LD_INT 2
73580: PUSH
73581: EMPTY
73582: LIST
73583: LIST
73584: PUSH
73585: LD_INT 1
73587: PUSH
73588: LD_INT 2
73590: PUSH
73591: EMPTY
73592: LIST
73593: LIST
73594: PUSH
73595: LD_INT 0
73597: PUSH
73598: LD_INT 2
73600: PUSH
73601: EMPTY
73602: LIST
73603: LIST
73604: PUSH
73605: LD_INT 1
73607: NEG
73608: PUSH
73609: LD_INT 1
73611: PUSH
73612: EMPTY
73613: LIST
73614: LIST
73615: PUSH
73616: LD_INT 2
73618: NEG
73619: PUSH
73620: LD_INT 1
73622: NEG
73623: PUSH
73624: EMPTY
73625: LIST
73626: LIST
73627: PUSH
73628: LD_INT 2
73630: NEG
73631: PUSH
73632: LD_INT 2
73634: NEG
73635: PUSH
73636: EMPTY
73637: LIST
73638: LIST
73639: PUSH
73640: LD_INT 2
73642: NEG
73643: PUSH
73644: LD_INT 3
73646: NEG
73647: PUSH
73648: EMPTY
73649: LIST
73650: LIST
73651: PUSH
73652: LD_INT 1
73654: NEG
73655: PUSH
73656: LD_INT 3
73658: NEG
73659: PUSH
73660: EMPTY
73661: LIST
73662: LIST
73663: PUSH
73664: LD_INT 0
73666: PUSH
73667: LD_INT 3
73669: NEG
73670: PUSH
73671: EMPTY
73672: LIST
73673: LIST
73674: PUSH
73675: LD_INT 1
73677: PUSH
73678: LD_INT 2
73680: NEG
73681: PUSH
73682: EMPTY
73683: LIST
73684: LIST
73685: PUSH
73686: LD_INT 3
73688: PUSH
73689: LD_INT 2
73691: PUSH
73692: EMPTY
73693: LIST
73694: LIST
73695: PUSH
73696: LD_INT 3
73698: PUSH
73699: LD_INT 3
73701: PUSH
73702: EMPTY
73703: LIST
73704: LIST
73705: PUSH
73706: LD_INT 2
73708: PUSH
73709: LD_INT 3
73711: PUSH
73712: EMPTY
73713: LIST
73714: LIST
73715: PUSH
73716: LD_INT 1
73718: PUSH
73719: LD_INT 3
73721: PUSH
73722: EMPTY
73723: LIST
73724: LIST
73725: PUSH
73726: LD_INT 0
73728: PUSH
73729: LD_INT 3
73731: PUSH
73732: EMPTY
73733: LIST
73734: LIST
73735: PUSH
73736: LD_INT 1
73738: NEG
73739: PUSH
73740: LD_INT 2
73742: PUSH
73743: EMPTY
73744: LIST
73745: LIST
73746: PUSH
73747: LD_INT 3
73749: NEG
73750: PUSH
73751: LD_INT 2
73753: NEG
73754: PUSH
73755: EMPTY
73756: LIST
73757: LIST
73758: PUSH
73759: LD_INT 3
73761: NEG
73762: PUSH
73763: LD_INT 3
73765: NEG
73766: PUSH
73767: EMPTY
73768: LIST
73769: LIST
73770: PUSH
73771: EMPTY
73772: LIST
73773: LIST
73774: LIST
73775: LIST
73776: LIST
73777: LIST
73778: LIST
73779: LIST
73780: LIST
73781: LIST
73782: LIST
73783: LIST
73784: LIST
73785: LIST
73786: LIST
73787: LIST
73788: LIST
73789: LIST
73790: LIST
73791: LIST
73792: LIST
73793: LIST
73794: LIST
73795: LIST
73796: LIST
73797: LIST
73798: LIST
73799: LIST
73800: LIST
73801: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73802: LD_ADDR_VAR 0 46
73806: PUSH
73807: LD_INT 0
73809: PUSH
73810: LD_INT 0
73812: PUSH
73813: EMPTY
73814: LIST
73815: LIST
73816: PUSH
73817: LD_INT 0
73819: PUSH
73820: LD_INT 1
73822: NEG
73823: PUSH
73824: EMPTY
73825: LIST
73826: LIST
73827: PUSH
73828: LD_INT 1
73830: PUSH
73831: LD_INT 0
73833: PUSH
73834: EMPTY
73835: LIST
73836: LIST
73837: PUSH
73838: LD_INT 1
73840: PUSH
73841: LD_INT 1
73843: PUSH
73844: EMPTY
73845: LIST
73846: LIST
73847: PUSH
73848: LD_INT 0
73850: PUSH
73851: LD_INT 1
73853: PUSH
73854: EMPTY
73855: LIST
73856: LIST
73857: PUSH
73858: LD_INT 1
73860: NEG
73861: PUSH
73862: LD_INT 0
73864: PUSH
73865: EMPTY
73866: LIST
73867: LIST
73868: PUSH
73869: LD_INT 1
73871: NEG
73872: PUSH
73873: LD_INT 1
73875: NEG
73876: PUSH
73877: EMPTY
73878: LIST
73879: LIST
73880: PUSH
73881: LD_INT 1
73883: NEG
73884: PUSH
73885: LD_INT 2
73887: NEG
73888: PUSH
73889: EMPTY
73890: LIST
73891: LIST
73892: PUSH
73893: LD_INT 0
73895: PUSH
73896: LD_INT 2
73898: NEG
73899: PUSH
73900: EMPTY
73901: LIST
73902: LIST
73903: PUSH
73904: LD_INT 1
73906: PUSH
73907: LD_INT 1
73909: NEG
73910: PUSH
73911: EMPTY
73912: LIST
73913: LIST
73914: PUSH
73915: LD_INT 2
73917: PUSH
73918: LD_INT 0
73920: PUSH
73921: EMPTY
73922: LIST
73923: LIST
73924: PUSH
73925: LD_INT 2
73927: PUSH
73928: LD_INT 1
73930: PUSH
73931: EMPTY
73932: LIST
73933: LIST
73934: PUSH
73935: LD_INT 1
73937: PUSH
73938: LD_INT 2
73940: PUSH
73941: EMPTY
73942: LIST
73943: LIST
73944: PUSH
73945: LD_INT 0
73947: PUSH
73948: LD_INT 2
73950: PUSH
73951: EMPTY
73952: LIST
73953: LIST
73954: PUSH
73955: LD_INT 1
73957: NEG
73958: PUSH
73959: LD_INT 1
73961: PUSH
73962: EMPTY
73963: LIST
73964: LIST
73965: PUSH
73966: LD_INT 2
73968: NEG
73969: PUSH
73970: LD_INT 0
73972: PUSH
73973: EMPTY
73974: LIST
73975: LIST
73976: PUSH
73977: LD_INT 2
73979: NEG
73980: PUSH
73981: LD_INT 1
73983: NEG
73984: PUSH
73985: EMPTY
73986: LIST
73987: LIST
73988: PUSH
73989: LD_INT 1
73991: NEG
73992: PUSH
73993: LD_INT 3
73995: NEG
73996: PUSH
73997: EMPTY
73998: LIST
73999: LIST
74000: PUSH
74001: LD_INT 0
74003: PUSH
74004: LD_INT 3
74006: NEG
74007: PUSH
74008: EMPTY
74009: LIST
74010: LIST
74011: PUSH
74012: LD_INT 1
74014: PUSH
74015: LD_INT 2
74017: NEG
74018: PUSH
74019: EMPTY
74020: LIST
74021: LIST
74022: PUSH
74023: LD_INT 2
74025: PUSH
74026: LD_INT 1
74028: NEG
74029: PUSH
74030: EMPTY
74031: LIST
74032: LIST
74033: PUSH
74034: LD_INT 3
74036: PUSH
74037: LD_INT 0
74039: PUSH
74040: EMPTY
74041: LIST
74042: LIST
74043: PUSH
74044: LD_INT 3
74046: PUSH
74047: LD_INT 1
74049: PUSH
74050: EMPTY
74051: LIST
74052: LIST
74053: PUSH
74054: LD_INT 1
74056: PUSH
74057: LD_INT 3
74059: PUSH
74060: EMPTY
74061: LIST
74062: LIST
74063: PUSH
74064: LD_INT 0
74066: PUSH
74067: LD_INT 3
74069: PUSH
74070: EMPTY
74071: LIST
74072: LIST
74073: PUSH
74074: LD_INT 1
74076: NEG
74077: PUSH
74078: LD_INT 2
74080: PUSH
74081: EMPTY
74082: LIST
74083: LIST
74084: PUSH
74085: LD_INT 2
74087: NEG
74088: PUSH
74089: LD_INT 1
74091: PUSH
74092: EMPTY
74093: LIST
74094: LIST
74095: PUSH
74096: LD_INT 3
74098: NEG
74099: PUSH
74100: LD_INT 0
74102: PUSH
74103: EMPTY
74104: LIST
74105: LIST
74106: PUSH
74107: LD_INT 3
74109: NEG
74110: PUSH
74111: LD_INT 1
74113: NEG
74114: PUSH
74115: EMPTY
74116: LIST
74117: LIST
74118: PUSH
74119: EMPTY
74120: LIST
74121: LIST
74122: LIST
74123: LIST
74124: LIST
74125: LIST
74126: LIST
74127: LIST
74128: LIST
74129: LIST
74130: LIST
74131: LIST
74132: LIST
74133: LIST
74134: LIST
74135: LIST
74136: LIST
74137: LIST
74138: LIST
74139: LIST
74140: LIST
74141: LIST
74142: LIST
74143: LIST
74144: LIST
74145: LIST
74146: LIST
74147: LIST
74148: LIST
74149: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74150: LD_ADDR_VAR 0 47
74154: PUSH
74155: LD_INT 0
74157: PUSH
74158: LD_INT 0
74160: PUSH
74161: EMPTY
74162: LIST
74163: LIST
74164: PUSH
74165: LD_INT 0
74167: PUSH
74168: LD_INT 1
74170: NEG
74171: PUSH
74172: EMPTY
74173: LIST
74174: LIST
74175: PUSH
74176: LD_INT 1
74178: PUSH
74179: LD_INT 0
74181: PUSH
74182: EMPTY
74183: LIST
74184: LIST
74185: PUSH
74186: LD_INT 1
74188: PUSH
74189: LD_INT 1
74191: PUSH
74192: EMPTY
74193: LIST
74194: LIST
74195: PUSH
74196: LD_INT 0
74198: PUSH
74199: LD_INT 1
74201: PUSH
74202: EMPTY
74203: LIST
74204: LIST
74205: PUSH
74206: LD_INT 1
74208: NEG
74209: PUSH
74210: LD_INT 0
74212: PUSH
74213: EMPTY
74214: LIST
74215: LIST
74216: PUSH
74217: LD_INT 1
74219: NEG
74220: PUSH
74221: LD_INT 1
74223: NEG
74224: PUSH
74225: EMPTY
74226: LIST
74227: LIST
74228: PUSH
74229: LD_INT 1
74231: NEG
74232: PUSH
74233: LD_INT 2
74235: NEG
74236: PUSH
74237: EMPTY
74238: LIST
74239: LIST
74240: PUSH
74241: LD_INT 0
74243: PUSH
74244: LD_INT 2
74246: NEG
74247: PUSH
74248: EMPTY
74249: LIST
74250: LIST
74251: PUSH
74252: LD_INT 1
74254: PUSH
74255: LD_INT 1
74257: NEG
74258: PUSH
74259: EMPTY
74260: LIST
74261: LIST
74262: PUSH
74263: LD_INT 2
74265: NEG
74266: PUSH
74267: LD_INT 1
74269: NEG
74270: PUSH
74271: EMPTY
74272: LIST
74273: LIST
74274: PUSH
74275: LD_INT 2
74277: NEG
74278: PUSH
74279: LD_INT 2
74281: NEG
74282: PUSH
74283: EMPTY
74284: LIST
74285: LIST
74286: PUSH
74287: EMPTY
74288: LIST
74289: LIST
74290: LIST
74291: LIST
74292: LIST
74293: LIST
74294: LIST
74295: LIST
74296: LIST
74297: LIST
74298: LIST
74299: LIST
74300: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
74301: LD_ADDR_VAR 0 48
74305: PUSH
74306: LD_INT 0
74308: PUSH
74309: LD_INT 0
74311: PUSH
74312: EMPTY
74313: LIST
74314: LIST
74315: PUSH
74316: LD_INT 0
74318: PUSH
74319: LD_INT 1
74321: NEG
74322: PUSH
74323: EMPTY
74324: LIST
74325: LIST
74326: PUSH
74327: LD_INT 1
74329: PUSH
74330: LD_INT 0
74332: PUSH
74333: EMPTY
74334: LIST
74335: LIST
74336: PUSH
74337: LD_INT 1
74339: PUSH
74340: LD_INT 1
74342: PUSH
74343: EMPTY
74344: LIST
74345: LIST
74346: PUSH
74347: LD_INT 0
74349: PUSH
74350: LD_INT 1
74352: PUSH
74353: EMPTY
74354: LIST
74355: LIST
74356: PUSH
74357: LD_INT 1
74359: NEG
74360: PUSH
74361: LD_INT 0
74363: PUSH
74364: EMPTY
74365: LIST
74366: LIST
74367: PUSH
74368: LD_INT 1
74370: NEG
74371: PUSH
74372: LD_INT 1
74374: NEG
74375: PUSH
74376: EMPTY
74377: LIST
74378: LIST
74379: PUSH
74380: LD_INT 1
74382: NEG
74383: PUSH
74384: LD_INT 2
74386: NEG
74387: PUSH
74388: EMPTY
74389: LIST
74390: LIST
74391: PUSH
74392: LD_INT 0
74394: PUSH
74395: LD_INT 2
74397: NEG
74398: PUSH
74399: EMPTY
74400: LIST
74401: LIST
74402: PUSH
74403: LD_INT 1
74405: PUSH
74406: LD_INT 1
74408: NEG
74409: PUSH
74410: EMPTY
74411: LIST
74412: LIST
74413: PUSH
74414: LD_INT 2
74416: PUSH
74417: LD_INT 0
74419: PUSH
74420: EMPTY
74421: LIST
74422: LIST
74423: PUSH
74424: LD_INT 2
74426: PUSH
74427: LD_INT 1
74429: PUSH
74430: EMPTY
74431: LIST
74432: LIST
74433: PUSH
74434: EMPTY
74435: LIST
74436: LIST
74437: LIST
74438: LIST
74439: LIST
74440: LIST
74441: LIST
74442: LIST
74443: LIST
74444: LIST
74445: LIST
74446: LIST
74447: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
74448: LD_ADDR_VAR 0 49
74452: PUSH
74453: LD_INT 0
74455: PUSH
74456: LD_INT 0
74458: PUSH
74459: EMPTY
74460: LIST
74461: LIST
74462: PUSH
74463: LD_INT 0
74465: PUSH
74466: LD_INT 1
74468: NEG
74469: PUSH
74470: EMPTY
74471: LIST
74472: LIST
74473: PUSH
74474: LD_INT 1
74476: PUSH
74477: LD_INT 0
74479: PUSH
74480: EMPTY
74481: LIST
74482: LIST
74483: PUSH
74484: LD_INT 1
74486: PUSH
74487: LD_INT 1
74489: PUSH
74490: EMPTY
74491: LIST
74492: LIST
74493: PUSH
74494: LD_INT 0
74496: PUSH
74497: LD_INT 1
74499: PUSH
74500: EMPTY
74501: LIST
74502: LIST
74503: PUSH
74504: LD_INT 1
74506: NEG
74507: PUSH
74508: LD_INT 0
74510: PUSH
74511: EMPTY
74512: LIST
74513: LIST
74514: PUSH
74515: LD_INT 1
74517: NEG
74518: PUSH
74519: LD_INT 1
74521: NEG
74522: PUSH
74523: EMPTY
74524: LIST
74525: LIST
74526: PUSH
74527: LD_INT 1
74529: PUSH
74530: LD_INT 1
74532: NEG
74533: PUSH
74534: EMPTY
74535: LIST
74536: LIST
74537: PUSH
74538: LD_INT 2
74540: PUSH
74541: LD_INT 0
74543: PUSH
74544: EMPTY
74545: LIST
74546: LIST
74547: PUSH
74548: LD_INT 2
74550: PUSH
74551: LD_INT 1
74553: PUSH
74554: EMPTY
74555: LIST
74556: LIST
74557: PUSH
74558: LD_INT 2
74560: PUSH
74561: LD_INT 2
74563: PUSH
74564: EMPTY
74565: LIST
74566: LIST
74567: PUSH
74568: LD_INT 1
74570: PUSH
74571: LD_INT 2
74573: PUSH
74574: EMPTY
74575: LIST
74576: LIST
74577: PUSH
74578: EMPTY
74579: LIST
74580: LIST
74581: LIST
74582: LIST
74583: LIST
74584: LIST
74585: LIST
74586: LIST
74587: LIST
74588: LIST
74589: LIST
74590: LIST
74591: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
74592: LD_ADDR_VAR 0 50
74596: PUSH
74597: LD_INT 0
74599: PUSH
74600: LD_INT 0
74602: PUSH
74603: EMPTY
74604: LIST
74605: LIST
74606: PUSH
74607: LD_INT 0
74609: PUSH
74610: LD_INT 1
74612: NEG
74613: PUSH
74614: EMPTY
74615: LIST
74616: LIST
74617: PUSH
74618: LD_INT 1
74620: PUSH
74621: LD_INT 0
74623: PUSH
74624: EMPTY
74625: LIST
74626: LIST
74627: PUSH
74628: LD_INT 1
74630: PUSH
74631: LD_INT 1
74633: PUSH
74634: EMPTY
74635: LIST
74636: LIST
74637: PUSH
74638: LD_INT 0
74640: PUSH
74641: LD_INT 1
74643: PUSH
74644: EMPTY
74645: LIST
74646: LIST
74647: PUSH
74648: LD_INT 1
74650: NEG
74651: PUSH
74652: LD_INT 0
74654: PUSH
74655: EMPTY
74656: LIST
74657: LIST
74658: PUSH
74659: LD_INT 1
74661: NEG
74662: PUSH
74663: LD_INT 1
74665: NEG
74666: PUSH
74667: EMPTY
74668: LIST
74669: LIST
74670: PUSH
74671: LD_INT 2
74673: PUSH
74674: LD_INT 1
74676: PUSH
74677: EMPTY
74678: LIST
74679: LIST
74680: PUSH
74681: LD_INT 2
74683: PUSH
74684: LD_INT 2
74686: PUSH
74687: EMPTY
74688: LIST
74689: LIST
74690: PUSH
74691: LD_INT 1
74693: PUSH
74694: LD_INT 2
74696: PUSH
74697: EMPTY
74698: LIST
74699: LIST
74700: PUSH
74701: LD_INT 0
74703: PUSH
74704: LD_INT 2
74706: PUSH
74707: EMPTY
74708: LIST
74709: LIST
74710: PUSH
74711: LD_INT 1
74713: NEG
74714: PUSH
74715: LD_INT 1
74717: PUSH
74718: EMPTY
74719: LIST
74720: LIST
74721: PUSH
74722: EMPTY
74723: LIST
74724: LIST
74725: LIST
74726: LIST
74727: LIST
74728: LIST
74729: LIST
74730: LIST
74731: LIST
74732: LIST
74733: LIST
74734: LIST
74735: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
74736: LD_ADDR_VAR 0 51
74740: PUSH
74741: LD_INT 0
74743: PUSH
74744: LD_INT 0
74746: PUSH
74747: EMPTY
74748: LIST
74749: LIST
74750: PUSH
74751: LD_INT 0
74753: PUSH
74754: LD_INT 1
74756: NEG
74757: PUSH
74758: EMPTY
74759: LIST
74760: LIST
74761: PUSH
74762: LD_INT 1
74764: PUSH
74765: LD_INT 0
74767: PUSH
74768: EMPTY
74769: LIST
74770: LIST
74771: PUSH
74772: LD_INT 1
74774: PUSH
74775: LD_INT 1
74777: PUSH
74778: EMPTY
74779: LIST
74780: LIST
74781: PUSH
74782: LD_INT 0
74784: PUSH
74785: LD_INT 1
74787: PUSH
74788: EMPTY
74789: LIST
74790: LIST
74791: PUSH
74792: LD_INT 1
74794: NEG
74795: PUSH
74796: LD_INT 0
74798: PUSH
74799: EMPTY
74800: LIST
74801: LIST
74802: PUSH
74803: LD_INT 1
74805: NEG
74806: PUSH
74807: LD_INT 1
74809: NEG
74810: PUSH
74811: EMPTY
74812: LIST
74813: LIST
74814: PUSH
74815: LD_INT 1
74817: PUSH
74818: LD_INT 2
74820: PUSH
74821: EMPTY
74822: LIST
74823: LIST
74824: PUSH
74825: LD_INT 0
74827: PUSH
74828: LD_INT 2
74830: PUSH
74831: EMPTY
74832: LIST
74833: LIST
74834: PUSH
74835: LD_INT 1
74837: NEG
74838: PUSH
74839: LD_INT 1
74841: PUSH
74842: EMPTY
74843: LIST
74844: LIST
74845: PUSH
74846: LD_INT 2
74848: NEG
74849: PUSH
74850: LD_INT 0
74852: PUSH
74853: EMPTY
74854: LIST
74855: LIST
74856: PUSH
74857: LD_INT 2
74859: NEG
74860: PUSH
74861: LD_INT 1
74863: NEG
74864: PUSH
74865: EMPTY
74866: LIST
74867: LIST
74868: PUSH
74869: EMPTY
74870: LIST
74871: LIST
74872: LIST
74873: LIST
74874: LIST
74875: LIST
74876: LIST
74877: LIST
74878: LIST
74879: LIST
74880: LIST
74881: LIST
74882: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74883: LD_ADDR_VAR 0 52
74887: PUSH
74888: LD_INT 0
74890: PUSH
74891: LD_INT 0
74893: PUSH
74894: EMPTY
74895: LIST
74896: LIST
74897: PUSH
74898: LD_INT 0
74900: PUSH
74901: LD_INT 1
74903: NEG
74904: PUSH
74905: EMPTY
74906: LIST
74907: LIST
74908: PUSH
74909: LD_INT 1
74911: PUSH
74912: LD_INT 0
74914: PUSH
74915: EMPTY
74916: LIST
74917: LIST
74918: PUSH
74919: LD_INT 1
74921: PUSH
74922: LD_INT 1
74924: PUSH
74925: EMPTY
74926: LIST
74927: LIST
74928: PUSH
74929: LD_INT 0
74931: PUSH
74932: LD_INT 1
74934: PUSH
74935: EMPTY
74936: LIST
74937: LIST
74938: PUSH
74939: LD_INT 1
74941: NEG
74942: PUSH
74943: LD_INT 0
74945: PUSH
74946: EMPTY
74947: LIST
74948: LIST
74949: PUSH
74950: LD_INT 1
74952: NEG
74953: PUSH
74954: LD_INT 1
74956: NEG
74957: PUSH
74958: EMPTY
74959: LIST
74960: LIST
74961: PUSH
74962: LD_INT 1
74964: NEG
74965: PUSH
74966: LD_INT 2
74968: NEG
74969: PUSH
74970: EMPTY
74971: LIST
74972: LIST
74973: PUSH
74974: LD_INT 1
74976: NEG
74977: PUSH
74978: LD_INT 1
74980: PUSH
74981: EMPTY
74982: LIST
74983: LIST
74984: PUSH
74985: LD_INT 2
74987: NEG
74988: PUSH
74989: LD_INT 0
74991: PUSH
74992: EMPTY
74993: LIST
74994: LIST
74995: PUSH
74996: LD_INT 2
74998: NEG
74999: PUSH
75000: LD_INT 1
75002: NEG
75003: PUSH
75004: EMPTY
75005: LIST
75006: LIST
75007: PUSH
75008: LD_INT 2
75010: NEG
75011: PUSH
75012: LD_INT 2
75014: NEG
75015: PUSH
75016: EMPTY
75017: LIST
75018: LIST
75019: PUSH
75020: EMPTY
75021: LIST
75022: LIST
75023: LIST
75024: LIST
75025: LIST
75026: LIST
75027: LIST
75028: LIST
75029: LIST
75030: LIST
75031: LIST
75032: LIST
75033: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75034: LD_ADDR_VAR 0 53
75038: PUSH
75039: LD_INT 0
75041: PUSH
75042: LD_INT 0
75044: PUSH
75045: EMPTY
75046: LIST
75047: LIST
75048: PUSH
75049: LD_INT 0
75051: PUSH
75052: LD_INT 1
75054: NEG
75055: PUSH
75056: EMPTY
75057: LIST
75058: LIST
75059: PUSH
75060: LD_INT 1
75062: PUSH
75063: LD_INT 0
75065: PUSH
75066: EMPTY
75067: LIST
75068: LIST
75069: PUSH
75070: LD_INT 1
75072: PUSH
75073: LD_INT 1
75075: PUSH
75076: EMPTY
75077: LIST
75078: LIST
75079: PUSH
75080: LD_INT 0
75082: PUSH
75083: LD_INT 1
75085: PUSH
75086: EMPTY
75087: LIST
75088: LIST
75089: PUSH
75090: LD_INT 1
75092: NEG
75093: PUSH
75094: LD_INT 0
75096: PUSH
75097: EMPTY
75098: LIST
75099: LIST
75100: PUSH
75101: LD_INT 1
75103: NEG
75104: PUSH
75105: LD_INT 1
75107: NEG
75108: PUSH
75109: EMPTY
75110: LIST
75111: LIST
75112: PUSH
75113: LD_INT 1
75115: NEG
75116: PUSH
75117: LD_INT 2
75119: NEG
75120: PUSH
75121: EMPTY
75122: LIST
75123: LIST
75124: PUSH
75125: LD_INT 0
75127: PUSH
75128: LD_INT 2
75130: NEG
75131: PUSH
75132: EMPTY
75133: LIST
75134: LIST
75135: PUSH
75136: LD_INT 1
75138: PUSH
75139: LD_INT 1
75141: NEG
75142: PUSH
75143: EMPTY
75144: LIST
75145: LIST
75146: PUSH
75147: LD_INT 2
75149: PUSH
75150: LD_INT 0
75152: PUSH
75153: EMPTY
75154: LIST
75155: LIST
75156: PUSH
75157: LD_INT 2
75159: PUSH
75160: LD_INT 1
75162: PUSH
75163: EMPTY
75164: LIST
75165: LIST
75166: PUSH
75167: LD_INT 2
75169: PUSH
75170: LD_INT 2
75172: PUSH
75173: EMPTY
75174: LIST
75175: LIST
75176: PUSH
75177: LD_INT 1
75179: PUSH
75180: LD_INT 2
75182: PUSH
75183: EMPTY
75184: LIST
75185: LIST
75186: PUSH
75187: LD_INT 0
75189: PUSH
75190: LD_INT 2
75192: PUSH
75193: EMPTY
75194: LIST
75195: LIST
75196: PUSH
75197: LD_INT 1
75199: NEG
75200: PUSH
75201: LD_INT 1
75203: PUSH
75204: EMPTY
75205: LIST
75206: LIST
75207: PUSH
75208: LD_INT 2
75210: NEG
75211: PUSH
75212: LD_INT 0
75214: PUSH
75215: EMPTY
75216: LIST
75217: LIST
75218: PUSH
75219: LD_INT 2
75221: NEG
75222: PUSH
75223: LD_INT 1
75225: NEG
75226: PUSH
75227: EMPTY
75228: LIST
75229: LIST
75230: PUSH
75231: LD_INT 2
75233: NEG
75234: PUSH
75235: LD_INT 2
75237: NEG
75238: PUSH
75239: EMPTY
75240: LIST
75241: LIST
75242: PUSH
75243: EMPTY
75244: LIST
75245: LIST
75246: LIST
75247: LIST
75248: LIST
75249: LIST
75250: LIST
75251: LIST
75252: LIST
75253: LIST
75254: LIST
75255: LIST
75256: LIST
75257: LIST
75258: LIST
75259: LIST
75260: LIST
75261: LIST
75262: LIST
75263: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75264: LD_ADDR_VAR 0 54
75268: PUSH
75269: LD_INT 0
75271: PUSH
75272: LD_INT 0
75274: PUSH
75275: EMPTY
75276: LIST
75277: LIST
75278: PUSH
75279: LD_INT 0
75281: PUSH
75282: LD_INT 1
75284: NEG
75285: PUSH
75286: EMPTY
75287: LIST
75288: LIST
75289: PUSH
75290: LD_INT 1
75292: PUSH
75293: LD_INT 0
75295: PUSH
75296: EMPTY
75297: LIST
75298: LIST
75299: PUSH
75300: LD_INT 1
75302: PUSH
75303: LD_INT 1
75305: PUSH
75306: EMPTY
75307: LIST
75308: LIST
75309: PUSH
75310: LD_INT 0
75312: PUSH
75313: LD_INT 1
75315: PUSH
75316: EMPTY
75317: LIST
75318: LIST
75319: PUSH
75320: LD_INT 1
75322: NEG
75323: PUSH
75324: LD_INT 0
75326: PUSH
75327: EMPTY
75328: LIST
75329: LIST
75330: PUSH
75331: LD_INT 1
75333: NEG
75334: PUSH
75335: LD_INT 1
75337: NEG
75338: PUSH
75339: EMPTY
75340: LIST
75341: LIST
75342: PUSH
75343: LD_INT 1
75345: NEG
75346: PUSH
75347: LD_INT 2
75349: NEG
75350: PUSH
75351: EMPTY
75352: LIST
75353: LIST
75354: PUSH
75355: LD_INT 0
75357: PUSH
75358: LD_INT 2
75360: NEG
75361: PUSH
75362: EMPTY
75363: LIST
75364: LIST
75365: PUSH
75366: LD_INT 1
75368: PUSH
75369: LD_INT 1
75371: NEG
75372: PUSH
75373: EMPTY
75374: LIST
75375: LIST
75376: PUSH
75377: LD_INT 2
75379: PUSH
75380: LD_INT 0
75382: PUSH
75383: EMPTY
75384: LIST
75385: LIST
75386: PUSH
75387: LD_INT 2
75389: PUSH
75390: LD_INT 1
75392: PUSH
75393: EMPTY
75394: LIST
75395: LIST
75396: PUSH
75397: LD_INT 2
75399: PUSH
75400: LD_INT 2
75402: PUSH
75403: EMPTY
75404: LIST
75405: LIST
75406: PUSH
75407: LD_INT 1
75409: PUSH
75410: LD_INT 2
75412: PUSH
75413: EMPTY
75414: LIST
75415: LIST
75416: PUSH
75417: LD_INT 0
75419: PUSH
75420: LD_INT 2
75422: PUSH
75423: EMPTY
75424: LIST
75425: LIST
75426: PUSH
75427: LD_INT 1
75429: NEG
75430: PUSH
75431: LD_INT 1
75433: PUSH
75434: EMPTY
75435: LIST
75436: LIST
75437: PUSH
75438: LD_INT 2
75440: NEG
75441: PUSH
75442: LD_INT 0
75444: PUSH
75445: EMPTY
75446: LIST
75447: LIST
75448: PUSH
75449: LD_INT 2
75451: NEG
75452: PUSH
75453: LD_INT 1
75455: NEG
75456: PUSH
75457: EMPTY
75458: LIST
75459: LIST
75460: PUSH
75461: LD_INT 2
75463: NEG
75464: PUSH
75465: LD_INT 2
75467: NEG
75468: PUSH
75469: EMPTY
75470: LIST
75471: LIST
75472: PUSH
75473: EMPTY
75474: LIST
75475: LIST
75476: LIST
75477: LIST
75478: LIST
75479: LIST
75480: LIST
75481: LIST
75482: LIST
75483: LIST
75484: LIST
75485: LIST
75486: LIST
75487: LIST
75488: LIST
75489: LIST
75490: LIST
75491: LIST
75492: LIST
75493: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75494: LD_ADDR_VAR 0 55
75498: PUSH
75499: LD_INT 0
75501: PUSH
75502: LD_INT 0
75504: PUSH
75505: EMPTY
75506: LIST
75507: LIST
75508: PUSH
75509: LD_INT 0
75511: PUSH
75512: LD_INT 1
75514: NEG
75515: PUSH
75516: EMPTY
75517: LIST
75518: LIST
75519: PUSH
75520: LD_INT 1
75522: PUSH
75523: LD_INT 0
75525: PUSH
75526: EMPTY
75527: LIST
75528: LIST
75529: PUSH
75530: LD_INT 1
75532: PUSH
75533: LD_INT 1
75535: PUSH
75536: EMPTY
75537: LIST
75538: LIST
75539: PUSH
75540: LD_INT 0
75542: PUSH
75543: LD_INT 1
75545: PUSH
75546: EMPTY
75547: LIST
75548: LIST
75549: PUSH
75550: LD_INT 1
75552: NEG
75553: PUSH
75554: LD_INT 0
75556: PUSH
75557: EMPTY
75558: LIST
75559: LIST
75560: PUSH
75561: LD_INT 1
75563: NEG
75564: PUSH
75565: LD_INT 1
75567: NEG
75568: PUSH
75569: EMPTY
75570: LIST
75571: LIST
75572: PUSH
75573: LD_INT 1
75575: NEG
75576: PUSH
75577: LD_INT 2
75579: NEG
75580: PUSH
75581: EMPTY
75582: LIST
75583: LIST
75584: PUSH
75585: LD_INT 0
75587: PUSH
75588: LD_INT 2
75590: NEG
75591: PUSH
75592: EMPTY
75593: LIST
75594: LIST
75595: PUSH
75596: LD_INT 1
75598: PUSH
75599: LD_INT 1
75601: NEG
75602: PUSH
75603: EMPTY
75604: LIST
75605: LIST
75606: PUSH
75607: LD_INT 2
75609: PUSH
75610: LD_INT 0
75612: PUSH
75613: EMPTY
75614: LIST
75615: LIST
75616: PUSH
75617: LD_INT 2
75619: PUSH
75620: LD_INT 1
75622: PUSH
75623: EMPTY
75624: LIST
75625: LIST
75626: PUSH
75627: LD_INT 2
75629: PUSH
75630: LD_INT 2
75632: PUSH
75633: EMPTY
75634: LIST
75635: LIST
75636: PUSH
75637: LD_INT 1
75639: PUSH
75640: LD_INT 2
75642: PUSH
75643: EMPTY
75644: LIST
75645: LIST
75646: PUSH
75647: LD_INT 0
75649: PUSH
75650: LD_INT 2
75652: PUSH
75653: EMPTY
75654: LIST
75655: LIST
75656: PUSH
75657: LD_INT 1
75659: NEG
75660: PUSH
75661: LD_INT 1
75663: PUSH
75664: EMPTY
75665: LIST
75666: LIST
75667: PUSH
75668: LD_INT 2
75670: NEG
75671: PUSH
75672: LD_INT 0
75674: PUSH
75675: EMPTY
75676: LIST
75677: LIST
75678: PUSH
75679: LD_INT 2
75681: NEG
75682: PUSH
75683: LD_INT 1
75685: NEG
75686: PUSH
75687: EMPTY
75688: LIST
75689: LIST
75690: PUSH
75691: LD_INT 2
75693: NEG
75694: PUSH
75695: LD_INT 2
75697: NEG
75698: PUSH
75699: EMPTY
75700: LIST
75701: LIST
75702: PUSH
75703: EMPTY
75704: LIST
75705: LIST
75706: LIST
75707: LIST
75708: LIST
75709: LIST
75710: LIST
75711: LIST
75712: LIST
75713: LIST
75714: LIST
75715: LIST
75716: LIST
75717: LIST
75718: LIST
75719: LIST
75720: LIST
75721: LIST
75722: LIST
75723: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75724: LD_ADDR_VAR 0 56
75728: PUSH
75729: LD_INT 0
75731: PUSH
75732: LD_INT 0
75734: PUSH
75735: EMPTY
75736: LIST
75737: LIST
75738: PUSH
75739: LD_INT 0
75741: PUSH
75742: LD_INT 1
75744: NEG
75745: PUSH
75746: EMPTY
75747: LIST
75748: LIST
75749: PUSH
75750: LD_INT 1
75752: PUSH
75753: LD_INT 0
75755: PUSH
75756: EMPTY
75757: LIST
75758: LIST
75759: PUSH
75760: LD_INT 1
75762: PUSH
75763: LD_INT 1
75765: PUSH
75766: EMPTY
75767: LIST
75768: LIST
75769: PUSH
75770: LD_INT 0
75772: PUSH
75773: LD_INT 1
75775: PUSH
75776: EMPTY
75777: LIST
75778: LIST
75779: PUSH
75780: LD_INT 1
75782: NEG
75783: PUSH
75784: LD_INT 0
75786: PUSH
75787: EMPTY
75788: LIST
75789: LIST
75790: PUSH
75791: LD_INT 1
75793: NEG
75794: PUSH
75795: LD_INT 1
75797: NEG
75798: PUSH
75799: EMPTY
75800: LIST
75801: LIST
75802: PUSH
75803: LD_INT 1
75805: NEG
75806: PUSH
75807: LD_INT 2
75809: NEG
75810: PUSH
75811: EMPTY
75812: LIST
75813: LIST
75814: PUSH
75815: LD_INT 0
75817: PUSH
75818: LD_INT 2
75820: NEG
75821: PUSH
75822: EMPTY
75823: LIST
75824: LIST
75825: PUSH
75826: LD_INT 1
75828: PUSH
75829: LD_INT 1
75831: NEG
75832: PUSH
75833: EMPTY
75834: LIST
75835: LIST
75836: PUSH
75837: LD_INT 2
75839: PUSH
75840: LD_INT 0
75842: PUSH
75843: EMPTY
75844: LIST
75845: LIST
75846: PUSH
75847: LD_INT 2
75849: PUSH
75850: LD_INT 1
75852: PUSH
75853: EMPTY
75854: LIST
75855: LIST
75856: PUSH
75857: LD_INT 2
75859: PUSH
75860: LD_INT 2
75862: PUSH
75863: EMPTY
75864: LIST
75865: LIST
75866: PUSH
75867: LD_INT 1
75869: PUSH
75870: LD_INT 2
75872: PUSH
75873: EMPTY
75874: LIST
75875: LIST
75876: PUSH
75877: LD_INT 0
75879: PUSH
75880: LD_INT 2
75882: PUSH
75883: EMPTY
75884: LIST
75885: LIST
75886: PUSH
75887: LD_INT 1
75889: NEG
75890: PUSH
75891: LD_INT 1
75893: PUSH
75894: EMPTY
75895: LIST
75896: LIST
75897: PUSH
75898: LD_INT 2
75900: NEG
75901: PUSH
75902: LD_INT 0
75904: PUSH
75905: EMPTY
75906: LIST
75907: LIST
75908: PUSH
75909: LD_INT 2
75911: NEG
75912: PUSH
75913: LD_INT 1
75915: NEG
75916: PUSH
75917: EMPTY
75918: LIST
75919: LIST
75920: PUSH
75921: LD_INT 2
75923: NEG
75924: PUSH
75925: LD_INT 2
75927: NEG
75928: PUSH
75929: EMPTY
75930: LIST
75931: LIST
75932: PUSH
75933: EMPTY
75934: LIST
75935: LIST
75936: LIST
75937: LIST
75938: LIST
75939: LIST
75940: LIST
75941: LIST
75942: LIST
75943: LIST
75944: LIST
75945: LIST
75946: LIST
75947: LIST
75948: LIST
75949: LIST
75950: LIST
75951: LIST
75952: LIST
75953: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75954: LD_ADDR_VAR 0 57
75958: PUSH
75959: LD_INT 0
75961: PUSH
75962: LD_INT 0
75964: PUSH
75965: EMPTY
75966: LIST
75967: LIST
75968: PUSH
75969: LD_INT 0
75971: PUSH
75972: LD_INT 1
75974: NEG
75975: PUSH
75976: EMPTY
75977: LIST
75978: LIST
75979: PUSH
75980: LD_INT 1
75982: PUSH
75983: LD_INT 0
75985: PUSH
75986: EMPTY
75987: LIST
75988: LIST
75989: PUSH
75990: LD_INT 1
75992: PUSH
75993: LD_INT 1
75995: PUSH
75996: EMPTY
75997: LIST
75998: LIST
75999: PUSH
76000: LD_INT 0
76002: PUSH
76003: LD_INT 1
76005: PUSH
76006: EMPTY
76007: LIST
76008: LIST
76009: PUSH
76010: LD_INT 1
76012: NEG
76013: PUSH
76014: LD_INT 0
76016: PUSH
76017: EMPTY
76018: LIST
76019: LIST
76020: PUSH
76021: LD_INT 1
76023: NEG
76024: PUSH
76025: LD_INT 1
76027: NEG
76028: PUSH
76029: EMPTY
76030: LIST
76031: LIST
76032: PUSH
76033: LD_INT 1
76035: NEG
76036: PUSH
76037: LD_INT 2
76039: NEG
76040: PUSH
76041: EMPTY
76042: LIST
76043: LIST
76044: PUSH
76045: LD_INT 0
76047: PUSH
76048: LD_INT 2
76050: NEG
76051: PUSH
76052: EMPTY
76053: LIST
76054: LIST
76055: PUSH
76056: LD_INT 1
76058: PUSH
76059: LD_INT 1
76061: NEG
76062: PUSH
76063: EMPTY
76064: LIST
76065: LIST
76066: PUSH
76067: LD_INT 2
76069: PUSH
76070: LD_INT 0
76072: PUSH
76073: EMPTY
76074: LIST
76075: LIST
76076: PUSH
76077: LD_INT 2
76079: PUSH
76080: LD_INT 1
76082: PUSH
76083: EMPTY
76084: LIST
76085: LIST
76086: PUSH
76087: LD_INT 2
76089: PUSH
76090: LD_INT 2
76092: PUSH
76093: EMPTY
76094: LIST
76095: LIST
76096: PUSH
76097: LD_INT 1
76099: PUSH
76100: LD_INT 2
76102: PUSH
76103: EMPTY
76104: LIST
76105: LIST
76106: PUSH
76107: LD_INT 0
76109: PUSH
76110: LD_INT 2
76112: PUSH
76113: EMPTY
76114: LIST
76115: LIST
76116: PUSH
76117: LD_INT 1
76119: NEG
76120: PUSH
76121: LD_INT 1
76123: PUSH
76124: EMPTY
76125: LIST
76126: LIST
76127: PUSH
76128: LD_INT 2
76130: NEG
76131: PUSH
76132: LD_INT 0
76134: PUSH
76135: EMPTY
76136: LIST
76137: LIST
76138: PUSH
76139: LD_INT 2
76141: NEG
76142: PUSH
76143: LD_INT 1
76145: NEG
76146: PUSH
76147: EMPTY
76148: LIST
76149: LIST
76150: PUSH
76151: LD_INT 2
76153: NEG
76154: PUSH
76155: LD_INT 2
76157: NEG
76158: PUSH
76159: EMPTY
76160: LIST
76161: LIST
76162: PUSH
76163: EMPTY
76164: LIST
76165: LIST
76166: LIST
76167: LIST
76168: LIST
76169: LIST
76170: LIST
76171: LIST
76172: LIST
76173: LIST
76174: LIST
76175: LIST
76176: LIST
76177: LIST
76178: LIST
76179: LIST
76180: LIST
76181: LIST
76182: LIST
76183: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76184: LD_ADDR_VAR 0 58
76188: PUSH
76189: LD_INT 0
76191: PUSH
76192: LD_INT 0
76194: PUSH
76195: EMPTY
76196: LIST
76197: LIST
76198: PUSH
76199: LD_INT 0
76201: PUSH
76202: LD_INT 1
76204: NEG
76205: PUSH
76206: EMPTY
76207: LIST
76208: LIST
76209: PUSH
76210: LD_INT 1
76212: PUSH
76213: LD_INT 0
76215: PUSH
76216: EMPTY
76217: LIST
76218: LIST
76219: PUSH
76220: LD_INT 1
76222: PUSH
76223: LD_INT 1
76225: PUSH
76226: EMPTY
76227: LIST
76228: LIST
76229: PUSH
76230: LD_INT 0
76232: PUSH
76233: LD_INT 1
76235: PUSH
76236: EMPTY
76237: LIST
76238: LIST
76239: PUSH
76240: LD_INT 1
76242: NEG
76243: PUSH
76244: LD_INT 0
76246: PUSH
76247: EMPTY
76248: LIST
76249: LIST
76250: PUSH
76251: LD_INT 1
76253: NEG
76254: PUSH
76255: LD_INT 1
76257: NEG
76258: PUSH
76259: EMPTY
76260: LIST
76261: LIST
76262: PUSH
76263: LD_INT 1
76265: NEG
76266: PUSH
76267: LD_INT 2
76269: NEG
76270: PUSH
76271: EMPTY
76272: LIST
76273: LIST
76274: PUSH
76275: LD_INT 0
76277: PUSH
76278: LD_INT 2
76280: NEG
76281: PUSH
76282: EMPTY
76283: LIST
76284: LIST
76285: PUSH
76286: LD_INT 1
76288: PUSH
76289: LD_INT 1
76291: NEG
76292: PUSH
76293: EMPTY
76294: LIST
76295: LIST
76296: PUSH
76297: LD_INT 2
76299: PUSH
76300: LD_INT 0
76302: PUSH
76303: EMPTY
76304: LIST
76305: LIST
76306: PUSH
76307: LD_INT 2
76309: PUSH
76310: LD_INT 1
76312: PUSH
76313: EMPTY
76314: LIST
76315: LIST
76316: PUSH
76317: LD_INT 2
76319: PUSH
76320: LD_INT 2
76322: PUSH
76323: EMPTY
76324: LIST
76325: LIST
76326: PUSH
76327: LD_INT 1
76329: PUSH
76330: LD_INT 2
76332: PUSH
76333: EMPTY
76334: LIST
76335: LIST
76336: PUSH
76337: LD_INT 0
76339: PUSH
76340: LD_INT 2
76342: PUSH
76343: EMPTY
76344: LIST
76345: LIST
76346: PUSH
76347: LD_INT 1
76349: NEG
76350: PUSH
76351: LD_INT 1
76353: PUSH
76354: EMPTY
76355: LIST
76356: LIST
76357: PUSH
76358: LD_INT 2
76360: NEG
76361: PUSH
76362: LD_INT 0
76364: PUSH
76365: EMPTY
76366: LIST
76367: LIST
76368: PUSH
76369: LD_INT 2
76371: NEG
76372: PUSH
76373: LD_INT 1
76375: NEG
76376: PUSH
76377: EMPTY
76378: LIST
76379: LIST
76380: PUSH
76381: LD_INT 2
76383: NEG
76384: PUSH
76385: LD_INT 2
76387: NEG
76388: PUSH
76389: EMPTY
76390: LIST
76391: LIST
76392: PUSH
76393: EMPTY
76394: LIST
76395: LIST
76396: LIST
76397: LIST
76398: LIST
76399: LIST
76400: LIST
76401: LIST
76402: LIST
76403: LIST
76404: LIST
76405: LIST
76406: LIST
76407: LIST
76408: LIST
76409: LIST
76410: LIST
76411: LIST
76412: LIST
76413: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76414: LD_ADDR_VAR 0 59
76418: PUSH
76419: LD_INT 0
76421: PUSH
76422: LD_INT 0
76424: PUSH
76425: EMPTY
76426: LIST
76427: LIST
76428: PUSH
76429: LD_INT 0
76431: PUSH
76432: LD_INT 1
76434: NEG
76435: PUSH
76436: EMPTY
76437: LIST
76438: LIST
76439: PUSH
76440: LD_INT 1
76442: PUSH
76443: LD_INT 0
76445: PUSH
76446: EMPTY
76447: LIST
76448: LIST
76449: PUSH
76450: LD_INT 1
76452: PUSH
76453: LD_INT 1
76455: PUSH
76456: EMPTY
76457: LIST
76458: LIST
76459: PUSH
76460: LD_INT 0
76462: PUSH
76463: LD_INT 1
76465: PUSH
76466: EMPTY
76467: LIST
76468: LIST
76469: PUSH
76470: LD_INT 1
76472: NEG
76473: PUSH
76474: LD_INT 0
76476: PUSH
76477: EMPTY
76478: LIST
76479: LIST
76480: PUSH
76481: LD_INT 1
76483: NEG
76484: PUSH
76485: LD_INT 1
76487: NEG
76488: PUSH
76489: EMPTY
76490: LIST
76491: LIST
76492: PUSH
76493: EMPTY
76494: LIST
76495: LIST
76496: LIST
76497: LIST
76498: LIST
76499: LIST
76500: LIST
76501: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76502: LD_ADDR_VAR 0 60
76506: PUSH
76507: LD_INT 0
76509: PUSH
76510: LD_INT 0
76512: PUSH
76513: EMPTY
76514: LIST
76515: LIST
76516: PUSH
76517: LD_INT 0
76519: PUSH
76520: LD_INT 1
76522: NEG
76523: PUSH
76524: EMPTY
76525: LIST
76526: LIST
76527: PUSH
76528: LD_INT 1
76530: PUSH
76531: LD_INT 0
76533: PUSH
76534: EMPTY
76535: LIST
76536: LIST
76537: PUSH
76538: LD_INT 1
76540: PUSH
76541: LD_INT 1
76543: PUSH
76544: EMPTY
76545: LIST
76546: LIST
76547: PUSH
76548: LD_INT 0
76550: PUSH
76551: LD_INT 1
76553: PUSH
76554: EMPTY
76555: LIST
76556: LIST
76557: PUSH
76558: LD_INT 1
76560: NEG
76561: PUSH
76562: LD_INT 0
76564: PUSH
76565: EMPTY
76566: LIST
76567: LIST
76568: PUSH
76569: LD_INT 1
76571: NEG
76572: PUSH
76573: LD_INT 1
76575: NEG
76576: PUSH
76577: EMPTY
76578: LIST
76579: LIST
76580: PUSH
76581: EMPTY
76582: LIST
76583: LIST
76584: LIST
76585: LIST
76586: LIST
76587: LIST
76588: LIST
76589: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76590: LD_ADDR_VAR 0 61
76594: PUSH
76595: LD_INT 0
76597: PUSH
76598: LD_INT 0
76600: PUSH
76601: EMPTY
76602: LIST
76603: LIST
76604: PUSH
76605: LD_INT 0
76607: PUSH
76608: LD_INT 1
76610: NEG
76611: PUSH
76612: EMPTY
76613: LIST
76614: LIST
76615: PUSH
76616: LD_INT 1
76618: PUSH
76619: LD_INT 0
76621: PUSH
76622: EMPTY
76623: LIST
76624: LIST
76625: PUSH
76626: LD_INT 1
76628: PUSH
76629: LD_INT 1
76631: PUSH
76632: EMPTY
76633: LIST
76634: LIST
76635: PUSH
76636: LD_INT 0
76638: PUSH
76639: LD_INT 1
76641: PUSH
76642: EMPTY
76643: LIST
76644: LIST
76645: PUSH
76646: LD_INT 1
76648: NEG
76649: PUSH
76650: LD_INT 0
76652: PUSH
76653: EMPTY
76654: LIST
76655: LIST
76656: PUSH
76657: LD_INT 1
76659: NEG
76660: PUSH
76661: LD_INT 1
76663: NEG
76664: PUSH
76665: EMPTY
76666: LIST
76667: LIST
76668: PUSH
76669: EMPTY
76670: LIST
76671: LIST
76672: LIST
76673: LIST
76674: LIST
76675: LIST
76676: LIST
76677: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76678: LD_ADDR_VAR 0 62
76682: PUSH
76683: LD_INT 0
76685: PUSH
76686: LD_INT 0
76688: PUSH
76689: EMPTY
76690: LIST
76691: LIST
76692: PUSH
76693: LD_INT 0
76695: PUSH
76696: LD_INT 1
76698: NEG
76699: PUSH
76700: EMPTY
76701: LIST
76702: LIST
76703: PUSH
76704: LD_INT 1
76706: PUSH
76707: LD_INT 0
76709: PUSH
76710: EMPTY
76711: LIST
76712: LIST
76713: PUSH
76714: LD_INT 1
76716: PUSH
76717: LD_INT 1
76719: PUSH
76720: EMPTY
76721: LIST
76722: LIST
76723: PUSH
76724: LD_INT 0
76726: PUSH
76727: LD_INT 1
76729: PUSH
76730: EMPTY
76731: LIST
76732: LIST
76733: PUSH
76734: LD_INT 1
76736: NEG
76737: PUSH
76738: LD_INT 0
76740: PUSH
76741: EMPTY
76742: LIST
76743: LIST
76744: PUSH
76745: LD_INT 1
76747: NEG
76748: PUSH
76749: LD_INT 1
76751: NEG
76752: PUSH
76753: EMPTY
76754: LIST
76755: LIST
76756: PUSH
76757: EMPTY
76758: LIST
76759: LIST
76760: LIST
76761: LIST
76762: LIST
76763: LIST
76764: LIST
76765: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76766: LD_ADDR_VAR 0 63
76770: PUSH
76771: LD_INT 0
76773: PUSH
76774: LD_INT 0
76776: PUSH
76777: EMPTY
76778: LIST
76779: LIST
76780: PUSH
76781: LD_INT 0
76783: PUSH
76784: LD_INT 1
76786: NEG
76787: PUSH
76788: EMPTY
76789: LIST
76790: LIST
76791: PUSH
76792: LD_INT 1
76794: PUSH
76795: LD_INT 0
76797: PUSH
76798: EMPTY
76799: LIST
76800: LIST
76801: PUSH
76802: LD_INT 1
76804: PUSH
76805: LD_INT 1
76807: PUSH
76808: EMPTY
76809: LIST
76810: LIST
76811: PUSH
76812: LD_INT 0
76814: PUSH
76815: LD_INT 1
76817: PUSH
76818: EMPTY
76819: LIST
76820: LIST
76821: PUSH
76822: LD_INT 1
76824: NEG
76825: PUSH
76826: LD_INT 0
76828: PUSH
76829: EMPTY
76830: LIST
76831: LIST
76832: PUSH
76833: LD_INT 1
76835: NEG
76836: PUSH
76837: LD_INT 1
76839: NEG
76840: PUSH
76841: EMPTY
76842: LIST
76843: LIST
76844: PUSH
76845: EMPTY
76846: LIST
76847: LIST
76848: LIST
76849: LIST
76850: LIST
76851: LIST
76852: LIST
76853: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76854: LD_ADDR_VAR 0 64
76858: PUSH
76859: LD_INT 0
76861: PUSH
76862: LD_INT 0
76864: PUSH
76865: EMPTY
76866: LIST
76867: LIST
76868: PUSH
76869: LD_INT 0
76871: PUSH
76872: LD_INT 1
76874: NEG
76875: PUSH
76876: EMPTY
76877: LIST
76878: LIST
76879: PUSH
76880: LD_INT 1
76882: PUSH
76883: LD_INT 0
76885: PUSH
76886: EMPTY
76887: LIST
76888: LIST
76889: PUSH
76890: LD_INT 1
76892: PUSH
76893: LD_INT 1
76895: PUSH
76896: EMPTY
76897: LIST
76898: LIST
76899: PUSH
76900: LD_INT 0
76902: PUSH
76903: LD_INT 1
76905: PUSH
76906: EMPTY
76907: LIST
76908: LIST
76909: PUSH
76910: LD_INT 1
76912: NEG
76913: PUSH
76914: LD_INT 0
76916: PUSH
76917: EMPTY
76918: LIST
76919: LIST
76920: PUSH
76921: LD_INT 1
76923: NEG
76924: PUSH
76925: LD_INT 1
76927: NEG
76928: PUSH
76929: EMPTY
76930: LIST
76931: LIST
76932: PUSH
76933: EMPTY
76934: LIST
76935: LIST
76936: LIST
76937: LIST
76938: LIST
76939: LIST
76940: LIST
76941: ST_TO_ADDR
// end ; 1 :
76942: GO 82839
76944: LD_INT 1
76946: DOUBLE
76947: EQUAL
76948: IFTRUE 76952
76950: GO 79575
76952: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76953: LD_ADDR_VAR 0 11
76957: PUSH
76958: LD_INT 1
76960: NEG
76961: PUSH
76962: LD_INT 3
76964: NEG
76965: PUSH
76966: EMPTY
76967: LIST
76968: LIST
76969: PUSH
76970: LD_INT 0
76972: PUSH
76973: LD_INT 3
76975: NEG
76976: PUSH
76977: EMPTY
76978: LIST
76979: LIST
76980: PUSH
76981: LD_INT 1
76983: PUSH
76984: LD_INT 2
76986: NEG
76987: PUSH
76988: EMPTY
76989: LIST
76990: LIST
76991: PUSH
76992: EMPTY
76993: LIST
76994: LIST
76995: LIST
76996: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76997: LD_ADDR_VAR 0 12
77001: PUSH
77002: LD_INT 2
77004: PUSH
77005: LD_INT 1
77007: NEG
77008: PUSH
77009: EMPTY
77010: LIST
77011: LIST
77012: PUSH
77013: LD_INT 3
77015: PUSH
77016: LD_INT 0
77018: PUSH
77019: EMPTY
77020: LIST
77021: LIST
77022: PUSH
77023: LD_INT 3
77025: PUSH
77026: LD_INT 1
77028: PUSH
77029: EMPTY
77030: LIST
77031: LIST
77032: PUSH
77033: EMPTY
77034: LIST
77035: LIST
77036: LIST
77037: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77038: LD_ADDR_VAR 0 13
77042: PUSH
77043: LD_INT 3
77045: PUSH
77046: LD_INT 2
77048: PUSH
77049: EMPTY
77050: LIST
77051: LIST
77052: PUSH
77053: LD_INT 3
77055: PUSH
77056: LD_INT 3
77058: PUSH
77059: EMPTY
77060: LIST
77061: LIST
77062: PUSH
77063: LD_INT 2
77065: PUSH
77066: LD_INT 3
77068: PUSH
77069: EMPTY
77070: LIST
77071: LIST
77072: PUSH
77073: EMPTY
77074: LIST
77075: LIST
77076: LIST
77077: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77078: LD_ADDR_VAR 0 14
77082: PUSH
77083: LD_INT 1
77085: PUSH
77086: LD_INT 3
77088: PUSH
77089: EMPTY
77090: LIST
77091: LIST
77092: PUSH
77093: LD_INT 0
77095: PUSH
77096: LD_INT 3
77098: PUSH
77099: EMPTY
77100: LIST
77101: LIST
77102: PUSH
77103: LD_INT 1
77105: NEG
77106: PUSH
77107: LD_INT 2
77109: PUSH
77110: EMPTY
77111: LIST
77112: LIST
77113: PUSH
77114: EMPTY
77115: LIST
77116: LIST
77117: LIST
77118: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77119: LD_ADDR_VAR 0 15
77123: PUSH
77124: LD_INT 2
77126: NEG
77127: PUSH
77128: LD_INT 1
77130: PUSH
77131: EMPTY
77132: LIST
77133: LIST
77134: PUSH
77135: LD_INT 3
77137: NEG
77138: PUSH
77139: LD_INT 0
77141: PUSH
77142: EMPTY
77143: LIST
77144: LIST
77145: PUSH
77146: LD_INT 3
77148: NEG
77149: PUSH
77150: LD_INT 1
77152: NEG
77153: PUSH
77154: EMPTY
77155: LIST
77156: LIST
77157: PUSH
77158: EMPTY
77159: LIST
77160: LIST
77161: LIST
77162: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77163: LD_ADDR_VAR 0 16
77167: PUSH
77168: LD_INT 2
77170: NEG
77171: PUSH
77172: LD_INT 3
77174: NEG
77175: PUSH
77176: EMPTY
77177: LIST
77178: LIST
77179: PUSH
77180: LD_INT 3
77182: NEG
77183: PUSH
77184: LD_INT 2
77186: NEG
77187: PUSH
77188: EMPTY
77189: LIST
77190: LIST
77191: PUSH
77192: LD_INT 3
77194: NEG
77195: PUSH
77196: LD_INT 3
77198: NEG
77199: PUSH
77200: EMPTY
77201: LIST
77202: LIST
77203: PUSH
77204: EMPTY
77205: LIST
77206: LIST
77207: LIST
77208: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77209: LD_ADDR_VAR 0 17
77213: PUSH
77214: LD_INT 1
77216: NEG
77217: PUSH
77218: LD_INT 3
77220: NEG
77221: PUSH
77222: EMPTY
77223: LIST
77224: LIST
77225: PUSH
77226: LD_INT 0
77228: PUSH
77229: LD_INT 3
77231: NEG
77232: PUSH
77233: EMPTY
77234: LIST
77235: LIST
77236: PUSH
77237: LD_INT 1
77239: PUSH
77240: LD_INT 2
77242: NEG
77243: PUSH
77244: EMPTY
77245: LIST
77246: LIST
77247: PUSH
77248: EMPTY
77249: LIST
77250: LIST
77251: LIST
77252: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77253: LD_ADDR_VAR 0 18
77257: PUSH
77258: LD_INT 2
77260: PUSH
77261: LD_INT 1
77263: NEG
77264: PUSH
77265: EMPTY
77266: LIST
77267: LIST
77268: PUSH
77269: LD_INT 3
77271: PUSH
77272: LD_INT 0
77274: PUSH
77275: EMPTY
77276: LIST
77277: LIST
77278: PUSH
77279: LD_INT 3
77281: PUSH
77282: LD_INT 1
77284: PUSH
77285: EMPTY
77286: LIST
77287: LIST
77288: PUSH
77289: EMPTY
77290: LIST
77291: LIST
77292: LIST
77293: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77294: LD_ADDR_VAR 0 19
77298: PUSH
77299: LD_INT 3
77301: PUSH
77302: LD_INT 2
77304: PUSH
77305: EMPTY
77306: LIST
77307: LIST
77308: PUSH
77309: LD_INT 3
77311: PUSH
77312: LD_INT 3
77314: PUSH
77315: EMPTY
77316: LIST
77317: LIST
77318: PUSH
77319: LD_INT 2
77321: PUSH
77322: LD_INT 3
77324: PUSH
77325: EMPTY
77326: LIST
77327: LIST
77328: PUSH
77329: EMPTY
77330: LIST
77331: LIST
77332: LIST
77333: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77334: LD_ADDR_VAR 0 20
77338: PUSH
77339: LD_INT 1
77341: PUSH
77342: LD_INT 3
77344: PUSH
77345: EMPTY
77346: LIST
77347: LIST
77348: PUSH
77349: LD_INT 0
77351: PUSH
77352: LD_INT 3
77354: PUSH
77355: EMPTY
77356: LIST
77357: LIST
77358: PUSH
77359: LD_INT 1
77361: NEG
77362: PUSH
77363: LD_INT 2
77365: PUSH
77366: EMPTY
77367: LIST
77368: LIST
77369: PUSH
77370: EMPTY
77371: LIST
77372: LIST
77373: LIST
77374: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77375: LD_ADDR_VAR 0 21
77379: PUSH
77380: LD_INT 2
77382: NEG
77383: PUSH
77384: LD_INT 1
77386: PUSH
77387: EMPTY
77388: LIST
77389: LIST
77390: PUSH
77391: LD_INT 3
77393: NEG
77394: PUSH
77395: LD_INT 0
77397: PUSH
77398: EMPTY
77399: LIST
77400: LIST
77401: PUSH
77402: LD_INT 3
77404: NEG
77405: PUSH
77406: LD_INT 1
77408: NEG
77409: PUSH
77410: EMPTY
77411: LIST
77412: LIST
77413: PUSH
77414: EMPTY
77415: LIST
77416: LIST
77417: LIST
77418: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77419: LD_ADDR_VAR 0 22
77423: PUSH
77424: LD_INT 2
77426: NEG
77427: PUSH
77428: LD_INT 3
77430: NEG
77431: PUSH
77432: EMPTY
77433: LIST
77434: LIST
77435: PUSH
77436: LD_INT 3
77438: NEG
77439: PUSH
77440: LD_INT 2
77442: NEG
77443: PUSH
77444: EMPTY
77445: LIST
77446: LIST
77447: PUSH
77448: LD_INT 3
77450: NEG
77451: PUSH
77452: LD_INT 3
77454: NEG
77455: PUSH
77456: EMPTY
77457: LIST
77458: LIST
77459: PUSH
77460: EMPTY
77461: LIST
77462: LIST
77463: LIST
77464: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
77465: LD_ADDR_VAR 0 23
77469: PUSH
77470: LD_INT 0
77472: PUSH
77473: LD_INT 3
77475: NEG
77476: PUSH
77477: EMPTY
77478: LIST
77479: LIST
77480: PUSH
77481: LD_INT 1
77483: NEG
77484: PUSH
77485: LD_INT 4
77487: NEG
77488: PUSH
77489: EMPTY
77490: LIST
77491: LIST
77492: PUSH
77493: LD_INT 1
77495: PUSH
77496: LD_INT 3
77498: NEG
77499: PUSH
77500: EMPTY
77501: LIST
77502: LIST
77503: PUSH
77504: EMPTY
77505: LIST
77506: LIST
77507: LIST
77508: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
77509: LD_ADDR_VAR 0 24
77513: PUSH
77514: LD_INT 3
77516: PUSH
77517: LD_INT 0
77519: PUSH
77520: EMPTY
77521: LIST
77522: LIST
77523: PUSH
77524: LD_INT 3
77526: PUSH
77527: LD_INT 1
77529: NEG
77530: PUSH
77531: EMPTY
77532: LIST
77533: LIST
77534: PUSH
77535: LD_INT 4
77537: PUSH
77538: LD_INT 1
77540: PUSH
77541: EMPTY
77542: LIST
77543: LIST
77544: PUSH
77545: EMPTY
77546: LIST
77547: LIST
77548: LIST
77549: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
77550: LD_ADDR_VAR 0 25
77554: PUSH
77555: LD_INT 3
77557: PUSH
77558: LD_INT 3
77560: PUSH
77561: EMPTY
77562: LIST
77563: LIST
77564: PUSH
77565: LD_INT 4
77567: PUSH
77568: LD_INT 3
77570: PUSH
77571: EMPTY
77572: LIST
77573: LIST
77574: PUSH
77575: LD_INT 3
77577: PUSH
77578: LD_INT 4
77580: PUSH
77581: EMPTY
77582: LIST
77583: LIST
77584: PUSH
77585: EMPTY
77586: LIST
77587: LIST
77588: LIST
77589: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
77590: LD_ADDR_VAR 0 26
77594: PUSH
77595: LD_INT 0
77597: PUSH
77598: LD_INT 3
77600: PUSH
77601: EMPTY
77602: LIST
77603: LIST
77604: PUSH
77605: LD_INT 1
77607: PUSH
77608: LD_INT 4
77610: PUSH
77611: EMPTY
77612: LIST
77613: LIST
77614: PUSH
77615: LD_INT 1
77617: NEG
77618: PUSH
77619: LD_INT 3
77621: PUSH
77622: EMPTY
77623: LIST
77624: LIST
77625: PUSH
77626: EMPTY
77627: LIST
77628: LIST
77629: LIST
77630: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
77631: LD_ADDR_VAR 0 27
77635: PUSH
77636: LD_INT 3
77638: NEG
77639: PUSH
77640: LD_INT 0
77642: PUSH
77643: EMPTY
77644: LIST
77645: LIST
77646: PUSH
77647: LD_INT 3
77649: NEG
77650: PUSH
77651: LD_INT 1
77653: PUSH
77654: EMPTY
77655: LIST
77656: LIST
77657: PUSH
77658: LD_INT 4
77660: NEG
77661: PUSH
77662: LD_INT 1
77664: NEG
77665: PUSH
77666: EMPTY
77667: LIST
77668: LIST
77669: PUSH
77670: EMPTY
77671: LIST
77672: LIST
77673: LIST
77674: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
77675: LD_ADDR_VAR 0 28
77679: PUSH
77680: LD_INT 3
77682: NEG
77683: PUSH
77684: LD_INT 3
77686: NEG
77687: PUSH
77688: EMPTY
77689: LIST
77690: LIST
77691: PUSH
77692: LD_INT 3
77694: NEG
77695: PUSH
77696: LD_INT 4
77698: NEG
77699: PUSH
77700: EMPTY
77701: LIST
77702: LIST
77703: PUSH
77704: LD_INT 4
77706: NEG
77707: PUSH
77708: LD_INT 3
77710: NEG
77711: PUSH
77712: EMPTY
77713: LIST
77714: LIST
77715: PUSH
77716: EMPTY
77717: LIST
77718: LIST
77719: LIST
77720: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
77721: LD_ADDR_VAR 0 29
77725: PUSH
77726: LD_INT 1
77728: NEG
77729: PUSH
77730: LD_INT 3
77732: NEG
77733: PUSH
77734: EMPTY
77735: LIST
77736: LIST
77737: PUSH
77738: LD_INT 0
77740: PUSH
77741: LD_INT 3
77743: NEG
77744: PUSH
77745: EMPTY
77746: LIST
77747: LIST
77748: PUSH
77749: LD_INT 1
77751: PUSH
77752: LD_INT 2
77754: NEG
77755: PUSH
77756: EMPTY
77757: LIST
77758: LIST
77759: PUSH
77760: LD_INT 1
77762: NEG
77763: PUSH
77764: LD_INT 4
77766: NEG
77767: PUSH
77768: EMPTY
77769: LIST
77770: LIST
77771: PUSH
77772: LD_INT 0
77774: PUSH
77775: LD_INT 4
77777: NEG
77778: PUSH
77779: EMPTY
77780: LIST
77781: LIST
77782: PUSH
77783: LD_INT 1
77785: PUSH
77786: LD_INT 3
77788: NEG
77789: PUSH
77790: EMPTY
77791: LIST
77792: LIST
77793: PUSH
77794: LD_INT 1
77796: NEG
77797: PUSH
77798: LD_INT 5
77800: NEG
77801: PUSH
77802: EMPTY
77803: LIST
77804: LIST
77805: PUSH
77806: LD_INT 0
77808: PUSH
77809: LD_INT 5
77811: NEG
77812: PUSH
77813: EMPTY
77814: LIST
77815: LIST
77816: PUSH
77817: LD_INT 1
77819: PUSH
77820: LD_INT 4
77822: NEG
77823: PUSH
77824: EMPTY
77825: LIST
77826: LIST
77827: PUSH
77828: LD_INT 1
77830: NEG
77831: PUSH
77832: LD_INT 6
77834: NEG
77835: PUSH
77836: EMPTY
77837: LIST
77838: LIST
77839: PUSH
77840: LD_INT 0
77842: PUSH
77843: LD_INT 6
77845: NEG
77846: PUSH
77847: EMPTY
77848: LIST
77849: LIST
77850: PUSH
77851: LD_INT 1
77853: PUSH
77854: LD_INT 5
77856: NEG
77857: PUSH
77858: EMPTY
77859: LIST
77860: LIST
77861: PUSH
77862: EMPTY
77863: LIST
77864: LIST
77865: LIST
77866: LIST
77867: LIST
77868: LIST
77869: LIST
77870: LIST
77871: LIST
77872: LIST
77873: LIST
77874: LIST
77875: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
77876: LD_ADDR_VAR 0 30
77880: PUSH
77881: LD_INT 2
77883: PUSH
77884: LD_INT 1
77886: NEG
77887: PUSH
77888: EMPTY
77889: LIST
77890: LIST
77891: PUSH
77892: LD_INT 3
77894: PUSH
77895: LD_INT 0
77897: PUSH
77898: EMPTY
77899: LIST
77900: LIST
77901: PUSH
77902: LD_INT 3
77904: PUSH
77905: LD_INT 1
77907: PUSH
77908: EMPTY
77909: LIST
77910: LIST
77911: PUSH
77912: LD_INT 3
77914: PUSH
77915: LD_INT 1
77917: NEG
77918: PUSH
77919: EMPTY
77920: LIST
77921: LIST
77922: PUSH
77923: LD_INT 4
77925: PUSH
77926: LD_INT 0
77928: PUSH
77929: EMPTY
77930: LIST
77931: LIST
77932: PUSH
77933: LD_INT 4
77935: PUSH
77936: LD_INT 1
77938: PUSH
77939: EMPTY
77940: LIST
77941: LIST
77942: PUSH
77943: LD_INT 4
77945: PUSH
77946: LD_INT 1
77948: NEG
77949: PUSH
77950: EMPTY
77951: LIST
77952: LIST
77953: PUSH
77954: LD_INT 5
77956: PUSH
77957: LD_INT 0
77959: PUSH
77960: EMPTY
77961: LIST
77962: LIST
77963: PUSH
77964: LD_INT 5
77966: PUSH
77967: LD_INT 1
77969: PUSH
77970: EMPTY
77971: LIST
77972: LIST
77973: PUSH
77974: LD_INT 5
77976: PUSH
77977: LD_INT 1
77979: NEG
77980: PUSH
77981: EMPTY
77982: LIST
77983: LIST
77984: PUSH
77985: LD_INT 6
77987: PUSH
77988: LD_INT 0
77990: PUSH
77991: EMPTY
77992: LIST
77993: LIST
77994: PUSH
77995: LD_INT 6
77997: PUSH
77998: LD_INT 1
78000: PUSH
78001: EMPTY
78002: LIST
78003: LIST
78004: PUSH
78005: EMPTY
78006: LIST
78007: LIST
78008: LIST
78009: LIST
78010: LIST
78011: LIST
78012: LIST
78013: LIST
78014: LIST
78015: LIST
78016: LIST
78017: LIST
78018: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
78019: LD_ADDR_VAR 0 31
78023: PUSH
78024: LD_INT 3
78026: PUSH
78027: LD_INT 2
78029: PUSH
78030: EMPTY
78031: LIST
78032: LIST
78033: PUSH
78034: LD_INT 3
78036: PUSH
78037: LD_INT 3
78039: PUSH
78040: EMPTY
78041: LIST
78042: LIST
78043: PUSH
78044: LD_INT 2
78046: PUSH
78047: LD_INT 3
78049: PUSH
78050: EMPTY
78051: LIST
78052: LIST
78053: PUSH
78054: LD_INT 4
78056: PUSH
78057: LD_INT 3
78059: PUSH
78060: EMPTY
78061: LIST
78062: LIST
78063: PUSH
78064: LD_INT 4
78066: PUSH
78067: LD_INT 4
78069: PUSH
78070: EMPTY
78071: LIST
78072: LIST
78073: PUSH
78074: LD_INT 3
78076: PUSH
78077: LD_INT 4
78079: PUSH
78080: EMPTY
78081: LIST
78082: LIST
78083: PUSH
78084: LD_INT 5
78086: PUSH
78087: LD_INT 4
78089: PUSH
78090: EMPTY
78091: LIST
78092: LIST
78093: PUSH
78094: LD_INT 5
78096: PUSH
78097: LD_INT 5
78099: PUSH
78100: EMPTY
78101: LIST
78102: LIST
78103: PUSH
78104: LD_INT 4
78106: PUSH
78107: LD_INT 5
78109: PUSH
78110: EMPTY
78111: LIST
78112: LIST
78113: PUSH
78114: LD_INT 6
78116: PUSH
78117: LD_INT 5
78119: PUSH
78120: EMPTY
78121: LIST
78122: LIST
78123: PUSH
78124: LD_INT 6
78126: PUSH
78127: LD_INT 6
78129: PUSH
78130: EMPTY
78131: LIST
78132: LIST
78133: PUSH
78134: LD_INT 5
78136: PUSH
78137: LD_INT 6
78139: PUSH
78140: EMPTY
78141: LIST
78142: LIST
78143: PUSH
78144: EMPTY
78145: LIST
78146: LIST
78147: LIST
78148: LIST
78149: LIST
78150: LIST
78151: LIST
78152: LIST
78153: LIST
78154: LIST
78155: LIST
78156: LIST
78157: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
78158: LD_ADDR_VAR 0 32
78162: PUSH
78163: LD_INT 1
78165: PUSH
78166: LD_INT 3
78168: PUSH
78169: EMPTY
78170: LIST
78171: LIST
78172: PUSH
78173: LD_INT 0
78175: PUSH
78176: LD_INT 3
78178: PUSH
78179: EMPTY
78180: LIST
78181: LIST
78182: PUSH
78183: LD_INT 1
78185: NEG
78186: PUSH
78187: LD_INT 2
78189: PUSH
78190: EMPTY
78191: LIST
78192: LIST
78193: PUSH
78194: LD_INT 1
78196: PUSH
78197: LD_INT 4
78199: PUSH
78200: EMPTY
78201: LIST
78202: LIST
78203: PUSH
78204: LD_INT 0
78206: PUSH
78207: LD_INT 4
78209: PUSH
78210: EMPTY
78211: LIST
78212: LIST
78213: PUSH
78214: LD_INT 1
78216: NEG
78217: PUSH
78218: LD_INT 3
78220: PUSH
78221: EMPTY
78222: LIST
78223: LIST
78224: PUSH
78225: LD_INT 1
78227: PUSH
78228: LD_INT 5
78230: PUSH
78231: EMPTY
78232: LIST
78233: LIST
78234: PUSH
78235: LD_INT 0
78237: PUSH
78238: LD_INT 5
78240: PUSH
78241: EMPTY
78242: LIST
78243: LIST
78244: PUSH
78245: LD_INT 1
78247: NEG
78248: PUSH
78249: LD_INT 4
78251: PUSH
78252: EMPTY
78253: LIST
78254: LIST
78255: PUSH
78256: LD_INT 1
78258: PUSH
78259: LD_INT 6
78261: PUSH
78262: EMPTY
78263: LIST
78264: LIST
78265: PUSH
78266: LD_INT 0
78268: PUSH
78269: LD_INT 6
78271: PUSH
78272: EMPTY
78273: LIST
78274: LIST
78275: PUSH
78276: LD_INT 1
78278: NEG
78279: PUSH
78280: LD_INT 5
78282: PUSH
78283: EMPTY
78284: LIST
78285: LIST
78286: PUSH
78287: EMPTY
78288: LIST
78289: LIST
78290: LIST
78291: LIST
78292: LIST
78293: LIST
78294: LIST
78295: LIST
78296: LIST
78297: LIST
78298: LIST
78299: LIST
78300: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
78301: LD_ADDR_VAR 0 33
78305: PUSH
78306: LD_INT 2
78308: NEG
78309: PUSH
78310: LD_INT 1
78312: PUSH
78313: EMPTY
78314: LIST
78315: LIST
78316: PUSH
78317: LD_INT 3
78319: NEG
78320: PUSH
78321: LD_INT 0
78323: PUSH
78324: EMPTY
78325: LIST
78326: LIST
78327: PUSH
78328: LD_INT 3
78330: NEG
78331: PUSH
78332: LD_INT 1
78334: NEG
78335: PUSH
78336: EMPTY
78337: LIST
78338: LIST
78339: PUSH
78340: LD_INT 3
78342: NEG
78343: PUSH
78344: LD_INT 1
78346: PUSH
78347: EMPTY
78348: LIST
78349: LIST
78350: PUSH
78351: LD_INT 4
78353: NEG
78354: PUSH
78355: LD_INT 0
78357: PUSH
78358: EMPTY
78359: LIST
78360: LIST
78361: PUSH
78362: LD_INT 4
78364: NEG
78365: PUSH
78366: LD_INT 1
78368: NEG
78369: PUSH
78370: EMPTY
78371: LIST
78372: LIST
78373: PUSH
78374: LD_INT 4
78376: NEG
78377: PUSH
78378: LD_INT 1
78380: PUSH
78381: EMPTY
78382: LIST
78383: LIST
78384: PUSH
78385: LD_INT 5
78387: NEG
78388: PUSH
78389: LD_INT 0
78391: PUSH
78392: EMPTY
78393: LIST
78394: LIST
78395: PUSH
78396: LD_INT 5
78398: NEG
78399: PUSH
78400: LD_INT 1
78402: NEG
78403: PUSH
78404: EMPTY
78405: LIST
78406: LIST
78407: PUSH
78408: LD_INT 5
78410: NEG
78411: PUSH
78412: LD_INT 1
78414: PUSH
78415: EMPTY
78416: LIST
78417: LIST
78418: PUSH
78419: LD_INT 6
78421: NEG
78422: PUSH
78423: LD_INT 0
78425: PUSH
78426: EMPTY
78427: LIST
78428: LIST
78429: PUSH
78430: LD_INT 6
78432: NEG
78433: PUSH
78434: LD_INT 1
78436: NEG
78437: PUSH
78438: EMPTY
78439: LIST
78440: LIST
78441: PUSH
78442: EMPTY
78443: LIST
78444: LIST
78445: LIST
78446: LIST
78447: LIST
78448: LIST
78449: LIST
78450: LIST
78451: LIST
78452: LIST
78453: LIST
78454: LIST
78455: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
78456: LD_ADDR_VAR 0 34
78460: PUSH
78461: LD_INT 2
78463: NEG
78464: PUSH
78465: LD_INT 3
78467: NEG
78468: PUSH
78469: EMPTY
78470: LIST
78471: LIST
78472: PUSH
78473: LD_INT 3
78475: NEG
78476: PUSH
78477: LD_INT 2
78479: NEG
78480: PUSH
78481: EMPTY
78482: LIST
78483: LIST
78484: PUSH
78485: LD_INT 3
78487: NEG
78488: PUSH
78489: LD_INT 3
78491: NEG
78492: PUSH
78493: EMPTY
78494: LIST
78495: LIST
78496: PUSH
78497: LD_INT 3
78499: NEG
78500: PUSH
78501: LD_INT 4
78503: NEG
78504: PUSH
78505: EMPTY
78506: LIST
78507: LIST
78508: PUSH
78509: LD_INT 4
78511: NEG
78512: PUSH
78513: LD_INT 3
78515: NEG
78516: PUSH
78517: EMPTY
78518: LIST
78519: LIST
78520: PUSH
78521: LD_INT 4
78523: NEG
78524: PUSH
78525: LD_INT 4
78527: NEG
78528: PUSH
78529: EMPTY
78530: LIST
78531: LIST
78532: PUSH
78533: LD_INT 4
78535: NEG
78536: PUSH
78537: LD_INT 5
78539: NEG
78540: PUSH
78541: EMPTY
78542: LIST
78543: LIST
78544: PUSH
78545: LD_INT 5
78547: NEG
78548: PUSH
78549: LD_INT 4
78551: NEG
78552: PUSH
78553: EMPTY
78554: LIST
78555: LIST
78556: PUSH
78557: LD_INT 5
78559: NEG
78560: PUSH
78561: LD_INT 5
78563: NEG
78564: PUSH
78565: EMPTY
78566: LIST
78567: LIST
78568: PUSH
78569: LD_INT 5
78571: NEG
78572: PUSH
78573: LD_INT 6
78575: NEG
78576: PUSH
78577: EMPTY
78578: LIST
78579: LIST
78580: PUSH
78581: LD_INT 6
78583: NEG
78584: PUSH
78585: LD_INT 5
78587: NEG
78588: PUSH
78589: EMPTY
78590: LIST
78591: LIST
78592: PUSH
78593: LD_INT 6
78595: NEG
78596: PUSH
78597: LD_INT 6
78599: NEG
78600: PUSH
78601: EMPTY
78602: LIST
78603: LIST
78604: PUSH
78605: EMPTY
78606: LIST
78607: LIST
78608: LIST
78609: LIST
78610: LIST
78611: LIST
78612: LIST
78613: LIST
78614: LIST
78615: LIST
78616: LIST
78617: LIST
78618: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
78619: LD_ADDR_VAR 0 41
78623: PUSH
78624: LD_INT 0
78626: PUSH
78627: LD_INT 2
78629: NEG
78630: PUSH
78631: EMPTY
78632: LIST
78633: LIST
78634: PUSH
78635: LD_INT 1
78637: NEG
78638: PUSH
78639: LD_INT 3
78641: NEG
78642: PUSH
78643: EMPTY
78644: LIST
78645: LIST
78646: PUSH
78647: LD_INT 1
78649: PUSH
78650: LD_INT 2
78652: NEG
78653: PUSH
78654: EMPTY
78655: LIST
78656: LIST
78657: PUSH
78658: EMPTY
78659: LIST
78660: LIST
78661: LIST
78662: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
78663: LD_ADDR_VAR 0 42
78667: PUSH
78668: LD_INT 2
78670: PUSH
78671: LD_INT 0
78673: PUSH
78674: EMPTY
78675: LIST
78676: LIST
78677: PUSH
78678: LD_INT 2
78680: PUSH
78681: LD_INT 1
78683: NEG
78684: PUSH
78685: EMPTY
78686: LIST
78687: LIST
78688: PUSH
78689: LD_INT 3
78691: PUSH
78692: LD_INT 1
78694: PUSH
78695: EMPTY
78696: LIST
78697: LIST
78698: PUSH
78699: EMPTY
78700: LIST
78701: LIST
78702: LIST
78703: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
78704: LD_ADDR_VAR 0 43
78708: PUSH
78709: LD_INT 2
78711: PUSH
78712: LD_INT 2
78714: PUSH
78715: EMPTY
78716: LIST
78717: LIST
78718: PUSH
78719: LD_INT 3
78721: PUSH
78722: LD_INT 2
78724: PUSH
78725: EMPTY
78726: LIST
78727: LIST
78728: PUSH
78729: LD_INT 2
78731: PUSH
78732: LD_INT 3
78734: PUSH
78735: EMPTY
78736: LIST
78737: LIST
78738: PUSH
78739: EMPTY
78740: LIST
78741: LIST
78742: LIST
78743: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
78744: LD_ADDR_VAR 0 44
78748: PUSH
78749: LD_INT 0
78751: PUSH
78752: LD_INT 2
78754: PUSH
78755: EMPTY
78756: LIST
78757: LIST
78758: PUSH
78759: LD_INT 1
78761: PUSH
78762: LD_INT 3
78764: PUSH
78765: EMPTY
78766: LIST
78767: LIST
78768: PUSH
78769: LD_INT 1
78771: NEG
78772: PUSH
78773: LD_INT 2
78775: PUSH
78776: EMPTY
78777: LIST
78778: LIST
78779: PUSH
78780: EMPTY
78781: LIST
78782: LIST
78783: LIST
78784: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
78785: LD_ADDR_VAR 0 45
78789: PUSH
78790: LD_INT 2
78792: NEG
78793: PUSH
78794: LD_INT 0
78796: PUSH
78797: EMPTY
78798: LIST
78799: LIST
78800: PUSH
78801: LD_INT 2
78803: NEG
78804: PUSH
78805: LD_INT 1
78807: PUSH
78808: EMPTY
78809: LIST
78810: LIST
78811: PUSH
78812: LD_INT 3
78814: NEG
78815: PUSH
78816: LD_INT 1
78818: NEG
78819: PUSH
78820: EMPTY
78821: LIST
78822: LIST
78823: PUSH
78824: EMPTY
78825: LIST
78826: LIST
78827: LIST
78828: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
78829: LD_ADDR_VAR 0 46
78833: PUSH
78834: LD_INT 2
78836: NEG
78837: PUSH
78838: LD_INT 2
78840: NEG
78841: PUSH
78842: EMPTY
78843: LIST
78844: LIST
78845: PUSH
78846: LD_INT 2
78848: NEG
78849: PUSH
78850: LD_INT 3
78852: NEG
78853: PUSH
78854: EMPTY
78855: LIST
78856: LIST
78857: PUSH
78858: LD_INT 3
78860: NEG
78861: PUSH
78862: LD_INT 2
78864: NEG
78865: PUSH
78866: EMPTY
78867: LIST
78868: LIST
78869: PUSH
78870: EMPTY
78871: LIST
78872: LIST
78873: LIST
78874: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
78875: LD_ADDR_VAR 0 47
78879: PUSH
78880: LD_INT 2
78882: NEG
78883: PUSH
78884: LD_INT 3
78886: NEG
78887: PUSH
78888: EMPTY
78889: LIST
78890: LIST
78891: PUSH
78892: LD_INT 1
78894: NEG
78895: PUSH
78896: LD_INT 3
78898: NEG
78899: PUSH
78900: EMPTY
78901: LIST
78902: LIST
78903: PUSH
78904: EMPTY
78905: LIST
78906: LIST
78907: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
78908: LD_ADDR_VAR 0 48
78912: PUSH
78913: LD_INT 1
78915: PUSH
78916: LD_INT 2
78918: NEG
78919: PUSH
78920: EMPTY
78921: LIST
78922: LIST
78923: PUSH
78924: LD_INT 2
78926: PUSH
78927: LD_INT 1
78929: NEG
78930: PUSH
78931: EMPTY
78932: LIST
78933: LIST
78934: PUSH
78935: EMPTY
78936: LIST
78937: LIST
78938: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
78939: LD_ADDR_VAR 0 49
78943: PUSH
78944: LD_INT 3
78946: PUSH
78947: LD_INT 1
78949: PUSH
78950: EMPTY
78951: LIST
78952: LIST
78953: PUSH
78954: LD_INT 3
78956: PUSH
78957: LD_INT 2
78959: PUSH
78960: EMPTY
78961: LIST
78962: LIST
78963: PUSH
78964: EMPTY
78965: LIST
78966: LIST
78967: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
78968: LD_ADDR_VAR 0 50
78972: PUSH
78973: LD_INT 2
78975: PUSH
78976: LD_INT 3
78978: PUSH
78979: EMPTY
78980: LIST
78981: LIST
78982: PUSH
78983: LD_INT 1
78985: PUSH
78986: LD_INT 3
78988: PUSH
78989: EMPTY
78990: LIST
78991: LIST
78992: PUSH
78993: EMPTY
78994: LIST
78995: LIST
78996: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
78997: LD_ADDR_VAR 0 51
79001: PUSH
79002: LD_INT 1
79004: NEG
79005: PUSH
79006: LD_INT 2
79008: PUSH
79009: EMPTY
79010: LIST
79011: LIST
79012: PUSH
79013: LD_INT 2
79015: NEG
79016: PUSH
79017: LD_INT 1
79019: PUSH
79020: EMPTY
79021: LIST
79022: LIST
79023: PUSH
79024: EMPTY
79025: LIST
79026: LIST
79027: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
79028: LD_ADDR_VAR 0 52
79032: PUSH
79033: LD_INT 3
79035: NEG
79036: PUSH
79037: LD_INT 1
79039: NEG
79040: PUSH
79041: EMPTY
79042: LIST
79043: LIST
79044: PUSH
79045: LD_INT 3
79047: NEG
79048: PUSH
79049: LD_INT 2
79051: NEG
79052: PUSH
79053: EMPTY
79054: LIST
79055: LIST
79056: PUSH
79057: EMPTY
79058: LIST
79059: LIST
79060: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79061: LD_ADDR_VAR 0 53
79065: PUSH
79066: LD_INT 1
79068: NEG
79069: PUSH
79070: LD_INT 3
79072: NEG
79073: PUSH
79074: EMPTY
79075: LIST
79076: LIST
79077: PUSH
79078: LD_INT 0
79080: PUSH
79081: LD_INT 3
79083: NEG
79084: PUSH
79085: EMPTY
79086: LIST
79087: LIST
79088: PUSH
79089: LD_INT 1
79091: PUSH
79092: LD_INT 2
79094: NEG
79095: PUSH
79096: EMPTY
79097: LIST
79098: LIST
79099: PUSH
79100: EMPTY
79101: LIST
79102: LIST
79103: LIST
79104: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79105: LD_ADDR_VAR 0 54
79109: PUSH
79110: LD_INT 2
79112: PUSH
79113: LD_INT 1
79115: NEG
79116: PUSH
79117: EMPTY
79118: LIST
79119: LIST
79120: PUSH
79121: LD_INT 3
79123: PUSH
79124: LD_INT 0
79126: PUSH
79127: EMPTY
79128: LIST
79129: LIST
79130: PUSH
79131: LD_INT 3
79133: PUSH
79134: LD_INT 1
79136: PUSH
79137: EMPTY
79138: LIST
79139: LIST
79140: PUSH
79141: EMPTY
79142: LIST
79143: LIST
79144: LIST
79145: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79146: LD_ADDR_VAR 0 55
79150: PUSH
79151: LD_INT 3
79153: PUSH
79154: LD_INT 2
79156: PUSH
79157: EMPTY
79158: LIST
79159: LIST
79160: PUSH
79161: LD_INT 3
79163: PUSH
79164: LD_INT 3
79166: PUSH
79167: EMPTY
79168: LIST
79169: LIST
79170: PUSH
79171: LD_INT 2
79173: PUSH
79174: LD_INT 3
79176: PUSH
79177: EMPTY
79178: LIST
79179: LIST
79180: PUSH
79181: EMPTY
79182: LIST
79183: LIST
79184: LIST
79185: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
79186: LD_ADDR_VAR 0 56
79190: PUSH
79191: LD_INT 1
79193: PUSH
79194: LD_INT 3
79196: PUSH
79197: EMPTY
79198: LIST
79199: LIST
79200: PUSH
79201: LD_INT 0
79203: PUSH
79204: LD_INT 3
79206: PUSH
79207: EMPTY
79208: LIST
79209: LIST
79210: PUSH
79211: LD_INT 1
79213: NEG
79214: PUSH
79215: LD_INT 2
79217: PUSH
79218: EMPTY
79219: LIST
79220: LIST
79221: PUSH
79222: EMPTY
79223: LIST
79224: LIST
79225: LIST
79226: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
79227: LD_ADDR_VAR 0 57
79231: PUSH
79232: LD_INT 2
79234: NEG
79235: PUSH
79236: LD_INT 1
79238: PUSH
79239: EMPTY
79240: LIST
79241: LIST
79242: PUSH
79243: LD_INT 3
79245: NEG
79246: PUSH
79247: LD_INT 0
79249: PUSH
79250: EMPTY
79251: LIST
79252: LIST
79253: PUSH
79254: LD_INT 3
79256: NEG
79257: PUSH
79258: LD_INT 1
79260: NEG
79261: PUSH
79262: EMPTY
79263: LIST
79264: LIST
79265: PUSH
79266: EMPTY
79267: LIST
79268: LIST
79269: LIST
79270: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
79271: LD_ADDR_VAR 0 58
79275: PUSH
79276: LD_INT 2
79278: NEG
79279: PUSH
79280: LD_INT 3
79282: NEG
79283: PUSH
79284: EMPTY
79285: LIST
79286: LIST
79287: PUSH
79288: LD_INT 3
79290: NEG
79291: PUSH
79292: LD_INT 2
79294: NEG
79295: PUSH
79296: EMPTY
79297: LIST
79298: LIST
79299: PUSH
79300: LD_INT 3
79302: NEG
79303: PUSH
79304: LD_INT 3
79306: NEG
79307: PUSH
79308: EMPTY
79309: LIST
79310: LIST
79311: PUSH
79312: EMPTY
79313: LIST
79314: LIST
79315: LIST
79316: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
79317: LD_ADDR_VAR 0 59
79321: PUSH
79322: LD_INT 1
79324: NEG
79325: PUSH
79326: LD_INT 2
79328: NEG
79329: PUSH
79330: EMPTY
79331: LIST
79332: LIST
79333: PUSH
79334: LD_INT 0
79336: PUSH
79337: LD_INT 2
79339: NEG
79340: PUSH
79341: EMPTY
79342: LIST
79343: LIST
79344: PUSH
79345: LD_INT 1
79347: PUSH
79348: LD_INT 1
79350: NEG
79351: PUSH
79352: EMPTY
79353: LIST
79354: LIST
79355: PUSH
79356: EMPTY
79357: LIST
79358: LIST
79359: LIST
79360: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
79361: LD_ADDR_VAR 0 60
79365: PUSH
79366: LD_INT 1
79368: PUSH
79369: LD_INT 1
79371: NEG
79372: PUSH
79373: EMPTY
79374: LIST
79375: LIST
79376: PUSH
79377: LD_INT 2
79379: PUSH
79380: LD_INT 0
79382: PUSH
79383: EMPTY
79384: LIST
79385: LIST
79386: PUSH
79387: LD_INT 2
79389: PUSH
79390: LD_INT 1
79392: PUSH
79393: EMPTY
79394: LIST
79395: LIST
79396: PUSH
79397: EMPTY
79398: LIST
79399: LIST
79400: LIST
79401: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
79402: LD_ADDR_VAR 0 61
79406: PUSH
79407: LD_INT 2
79409: PUSH
79410: LD_INT 1
79412: PUSH
79413: EMPTY
79414: LIST
79415: LIST
79416: PUSH
79417: LD_INT 2
79419: PUSH
79420: LD_INT 2
79422: PUSH
79423: EMPTY
79424: LIST
79425: LIST
79426: PUSH
79427: LD_INT 1
79429: PUSH
79430: LD_INT 2
79432: PUSH
79433: EMPTY
79434: LIST
79435: LIST
79436: PUSH
79437: EMPTY
79438: LIST
79439: LIST
79440: LIST
79441: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
79442: LD_ADDR_VAR 0 62
79446: PUSH
79447: LD_INT 1
79449: PUSH
79450: LD_INT 2
79452: PUSH
79453: EMPTY
79454: LIST
79455: LIST
79456: PUSH
79457: LD_INT 0
79459: PUSH
79460: LD_INT 2
79462: PUSH
79463: EMPTY
79464: LIST
79465: LIST
79466: PUSH
79467: LD_INT 1
79469: NEG
79470: PUSH
79471: LD_INT 1
79473: PUSH
79474: EMPTY
79475: LIST
79476: LIST
79477: PUSH
79478: EMPTY
79479: LIST
79480: LIST
79481: LIST
79482: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
79483: LD_ADDR_VAR 0 63
79487: PUSH
79488: LD_INT 1
79490: NEG
79491: PUSH
79492: LD_INT 1
79494: PUSH
79495: EMPTY
79496: LIST
79497: LIST
79498: PUSH
79499: LD_INT 2
79501: NEG
79502: PUSH
79503: LD_INT 0
79505: PUSH
79506: EMPTY
79507: LIST
79508: LIST
79509: PUSH
79510: LD_INT 2
79512: NEG
79513: PUSH
79514: LD_INT 1
79516: NEG
79517: PUSH
79518: EMPTY
79519: LIST
79520: LIST
79521: PUSH
79522: EMPTY
79523: LIST
79524: LIST
79525: LIST
79526: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79527: LD_ADDR_VAR 0 64
79531: PUSH
79532: LD_INT 1
79534: NEG
79535: PUSH
79536: LD_INT 2
79538: NEG
79539: PUSH
79540: EMPTY
79541: LIST
79542: LIST
79543: PUSH
79544: LD_INT 2
79546: NEG
79547: PUSH
79548: LD_INT 1
79550: NEG
79551: PUSH
79552: EMPTY
79553: LIST
79554: LIST
79555: PUSH
79556: LD_INT 2
79558: NEG
79559: PUSH
79560: LD_INT 2
79562: NEG
79563: PUSH
79564: EMPTY
79565: LIST
79566: LIST
79567: PUSH
79568: EMPTY
79569: LIST
79570: LIST
79571: LIST
79572: ST_TO_ADDR
// end ; 2 :
79573: GO 82839
79575: LD_INT 2
79577: DOUBLE
79578: EQUAL
79579: IFTRUE 79583
79581: GO 82838
79583: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
79584: LD_ADDR_VAR 0 29
79588: PUSH
79589: LD_INT 4
79591: PUSH
79592: LD_INT 0
79594: PUSH
79595: EMPTY
79596: LIST
79597: LIST
79598: PUSH
79599: LD_INT 4
79601: PUSH
79602: LD_INT 1
79604: NEG
79605: PUSH
79606: EMPTY
79607: LIST
79608: LIST
79609: PUSH
79610: LD_INT 5
79612: PUSH
79613: LD_INT 0
79615: PUSH
79616: EMPTY
79617: LIST
79618: LIST
79619: PUSH
79620: LD_INT 5
79622: PUSH
79623: LD_INT 1
79625: PUSH
79626: EMPTY
79627: LIST
79628: LIST
79629: PUSH
79630: LD_INT 4
79632: PUSH
79633: LD_INT 1
79635: PUSH
79636: EMPTY
79637: LIST
79638: LIST
79639: PUSH
79640: LD_INT 3
79642: PUSH
79643: LD_INT 0
79645: PUSH
79646: EMPTY
79647: LIST
79648: LIST
79649: PUSH
79650: LD_INT 3
79652: PUSH
79653: LD_INT 1
79655: NEG
79656: PUSH
79657: EMPTY
79658: LIST
79659: LIST
79660: PUSH
79661: LD_INT 3
79663: PUSH
79664: LD_INT 2
79666: NEG
79667: PUSH
79668: EMPTY
79669: LIST
79670: LIST
79671: PUSH
79672: LD_INT 5
79674: PUSH
79675: LD_INT 2
79677: PUSH
79678: EMPTY
79679: LIST
79680: LIST
79681: PUSH
79682: LD_INT 3
79684: PUSH
79685: LD_INT 3
79687: PUSH
79688: EMPTY
79689: LIST
79690: LIST
79691: PUSH
79692: LD_INT 3
79694: PUSH
79695: LD_INT 2
79697: PUSH
79698: EMPTY
79699: LIST
79700: LIST
79701: PUSH
79702: LD_INT 4
79704: PUSH
79705: LD_INT 3
79707: PUSH
79708: EMPTY
79709: LIST
79710: LIST
79711: PUSH
79712: LD_INT 4
79714: PUSH
79715: LD_INT 4
79717: PUSH
79718: EMPTY
79719: LIST
79720: LIST
79721: PUSH
79722: LD_INT 3
79724: PUSH
79725: LD_INT 4
79727: PUSH
79728: EMPTY
79729: LIST
79730: LIST
79731: PUSH
79732: LD_INT 2
79734: PUSH
79735: LD_INT 3
79737: PUSH
79738: EMPTY
79739: LIST
79740: LIST
79741: PUSH
79742: LD_INT 2
79744: PUSH
79745: LD_INT 2
79747: PUSH
79748: EMPTY
79749: LIST
79750: LIST
79751: PUSH
79752: LD_INT 4
79754: PUSH
79755: LD_INT 2
79757: PUSH
79758: EMPTY
79759: LIST
79760: LIST
79761: PUSH
79762: LD_INT 2
79764: PUSH
79765: LD_INT 4
79767: PUSH
79768: EMPTY
79769: LIST
79770: LIST
79771: PUSH
79772: LD_INT 0
79774: PUSH
79775: LD_INT 4
79777: PUSH
79778: EMPTY
79779: LIST
79780: LIST
79781: PUSH
79782: LD_INT 0
79784: PUSH
79785: LD_INT 3
79787: PUSH
79788: EMPTY
79789: LIST
79790: LIST
79791: PUSH
79792: LD_INT 1
79794: PUSH
79795: LD_INT 4
79797: PUSH
79798: EMPTY
79799: LIST
79800: LIST
79801: PUSH
79802: LD_INT 1
79804: PUSH
79805: LD_INT 5
79807: PUSH
79808: EMPTY
79809: LIST
79810: LIST
79811: PUSH
79812: LD_INT 0
79814: PUSH
79815: LD_INT 5
79817: PUSH
79818: EMPTY
79819: LIST
79820: LIST
79821: PUSH
79822: LD_INT 1
79824: NEG
79825: PUSH
79826: LD_INT 4
79828: PUSH
79829: EMPTY
79830: LIST
79831: LIST
79832: PUSH
79833: LD_INT 1
79835: NEG
79836: PUSH
79837: LD_INT 3
79839: PUSH
79840: EMPTY
79841: LIST
79842: LIST
79843: PUSH
79844: LD_INT 2
79846: PUSH
79847: LD_INT 5
79849: PUSH
79850: EMPTY
79851: LIST
79852: LIST
79853: PUSH
79854: LD_INT 2
79856: NEG
79857: PUSH
79858: LD_INT 3
79860: PUSH
79861: EMPTY
79862: LIST
79863: LIST
79864: PUSH
79865: LD_INT 3
79867: NEG
79868: PUSH
79869: LD_INT 0
79871: PUSH
79872: EMPTY
79873: LIST
79874: LIST
79875: PUSH
79876: LD_INT 3
79878: NEG
79879: PUSH
79880: LD_INT 1
79882: NEG
79883: PUSH
79884: EMPTY
79885: LIST
79886: LIST
79887: PUSH
79888: LD_INT 2
79890: NEG
79891: PUSH
79892: LD_INT 0
79894: PUSH
79895: EMPTY
79896: LIST
79897: LIST
79898: PUSH
79899: LD_INT 2
79901: NEG
79902: PUSH
79903: LD_INT 1
79905: PUSH
79906: EMPTY
79907: LIST
79908: LIST
79909: PUSH
79910: LD_INT 3
79912: NEG
79913: PUSH
79914: LD_INT 1
79916: PUSH
79917: EMPTY
79918: LIST
79919: LIST
79920: PUSH
79921: LD_INT 4
79923: NEG
79924: PUSH
79925: LD_INT 0
79927: PUSH
79928: EMPTY
79929: LIST
79930: LIST
79931: PUSH
79932: LD_INT 4
79934: NEG
79935: PUSH
79936: LD_INT 1
79938: NEG
79939: PUSH
79940: EMPTY
79941: LIST
79942: LIST
79943: PUSH
79944: LD_INT 4
79946: NEG
79947: PUSH
79948: LD_INT 2
79950: NEG
79951: PUSH
79952: EMPTY
79953: LIST
79954: LIST
79955: PUSH
79956: LD_INT 2
79958: NEG
79959: PUSH
79960: LD_INT 2
79962: PUSH
79963: EMPTY
79964: LIST
79965: LIST
79966: PUSH
79967: LD_INT 4
79969: NEG
79970: PUSH
79971: LD_INT 4
79973: NEG
79974: PUSH
79975: EMPTY
79976: LIST
79977: LIST
79978: PUSH
79979: LD_INT 4
79981: NEG
79982: PUSH
79983: LD_INT 5
79985: NEG
79986: PUSH
79987: EMPTY
79988: LIST
79989: LIST
79990: PUSH
79991: LD_INT 3
79993: NEG
79994: PUSH
79995: LD_INT 4
79997: NEG
79998: PUSH
79999: EMPTY
80000: LIST
80001: LIST
80002: PUSH
80003: LD_INT 3
80005: NEG
80006: PUSH
80007: LD_INT 3
80009: NEG
80010: PUSH
80011: EMPTY
80012: LIST
80013: LIST
80014: PUSH
80015: LD_INT 4
80017: NEG
80018: PUSH
80019: LD_INT 3
80021: NEG
80022: PUSH
80023: EMPTY
80024: LIST
80025: LIST
80026: PUSH
80027: LD_INT 5
80029: NEG
80030: PUSH
80031: LD_INT 4
80033: NEG
80034: PUSH
80035: EMPTY
80036: LIST
80037: LIST
80038: PUSH
80039: LD_INT 5
80041: NEG
80042: PUSH
80043: LD_INT 5
80045: NEG
80046: PUSH
80047: EMPTY
80048: LIST
80049: LIST
80050: PUSH
80051: LD_INT 3
80053: NEG
80054: PUSH
80055: LD_INT 5
80057: NEG
80058: PUSH
80059: EMPTY
80060: LIST
80061: LIST
80062: PUSH
80063: LD_INT 5
80065: NEG
80066: PUSH
80067: LD_INT 3
80069: NEG
80070: PUSH
80071: EMPTY
80072: LIST
80073: LIST
80074: PUSH
80075: EMPTY
80076: LIST
80077: LIST
80078: LIST
80079: LIST
80080: LIST
80081: LIST
80082: LIST
80083: LIST
80084: LIST
80085: LIST
80086: LIST
80087: LIST
80088: LIST
80089: LIST
80090: LIST
80091: LIST
80092: LIST
80093: LIST
80094: LIST
80095: LIST
80096: LIST
80097: LIST
80098: LIST
80099: LIST
80100: LIST
80101: LIST
80102: LIST
80103: LIST
80104: LIST
80105: LIST
80106: LIST
80107: LIST
80108: LIST
80109: LIST
80110: LIST
80111: LIST
80112: LIST
80113: LIST
80114: LIST
80115: LIST
80116: LIST
80117: LIST
80118: LIST
80119: LIST
80120: LIST
80121: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
80122: LD_ADDR_VAR 0 30
80126: PUSH
80127: LD_INT 4
80129: PUSH
80130: LD_INT 4
80132: PUSH
80133: EMPTY
80134: LIST
80135: LIST
80136: PUSH
80137: LD_INT 4
80139: PUSH
80140: LD_INT 3
80142: PUSH
80143: EMPTY
80144: LIST
80145: LIST
80146: PUSH
80147: LD_INT 5
80149: PUSH
80150: LD_INT 4
80152: PUSH
80153: EMPTY
80154: LIST
80155: LIST
80156: PUSH
80157: LD_INT 5
80159: PUSH
80160: LD_INT 5
80162: PUSH
80163: EMPTY
80164: LIST
80165: LIST
80166: PUSH
80167: LD_INT 4
80169: PUSH
80170: LD_INT 5
80172: PUSH
80173: EMPTY
80174: LIST
80175: LIST
80176: PUSH
80177: LD_INT 3
80179: PUSH
80180: LD_INT 4
80182: PUSH
80183: EMPTY
80184: LIST
80185: LIST
80186: PUSH
80187: LD_INT 3
80189: PUSH
80190: LD_INT 3
80192: PUSH
80193: EMPTY
80194: LIST
80195: LIST
80196: PUSH
80197: LD_INT 5
80199: PUSH
80200: LD_INT 3
80202: PUSH
80203: EMPTY
80204: LIST
80205: LIST
80206: PUSH
80207: LD_INT 3
80209: PUSH
80210: LD_INT 5
80212: PUSH
80213: EMPTY
80214: LIST
80215: LIST
80216: PUSH
80217: LD_INT 0
80219: PUSH
80220: LD_INT 3
80222: PUSH
80223: EMPTY
80224: LIST
80225: LIST
80226: PUSH
80227: LD_INT 0
80229: PUSH
80230: LD_INT 2
80232: PUSH
80233: EMPTY
80234: LIST
80235: LIST
80236: PUSH
80237: LD_INT 1
80239: PUSH
80240: LD_INT 3
80242: PUSH
80243: EMPTY
80244: LIST
80245: LIST
80246: PUSH
80247: LD_INT 1
80249: PUSH
80250: LD_INT 4
80252: PUSH
80253: EMPTY
80254: LIST
80255: LIST
80256: PUSH
80257: LD_INT 0
80259: PUSH
80260: LD_INT 4
80262: PUSH
80263: EMPTY
80264: LIST
80265: LIST
80266: PUSH
80267: LD_INT 1
80269: NEG
80270: PUSH
80271: LD_INT 3
80273: PUSH
80274: EMPTY
80275: LIST
80276: LIST
80277: PUSH
80278: LD_INT 1
80280: NEG
80281: PUSH
80282: LD_INT 2
80284: PUSH
80285: EMPTY
80286: LIST
80287: LIST
80288: PUSH
80289: LD_INT 2
80291: PUSH
80292: LD_INT 4
80294: PUSH
80295: EMPTY
80296: LIST
80297: LIST
80298: PUSH
80299: LD_INT 2
80301: NEG
80302: PUSH
80303: LD_INT 2
80305: PUSH
80306: EMPTY
80307: LIST
80308: LIST
80309: PUSH
80310: LD_INT 4
80312: NEG
80313: PUSH
80314: LD_INT 0
80316: PUSH
80317: EMPTY
80318: LIST
80319: LIST
80320: PUSH
80321: LD_INT 4
80323: NEG
80324: PUSH
80325: LD_INT 1
80327: NEG
80328: PUSH
80329: EMPTY
80330: LIST
80331: LIST
80332: PUSH
80333: LD_INT 3
80335: NEG
80336: PUSH
80337: LD_INT 0
80339: PUSH
80340: EMPTY
80341: LIST
80342: LIST
80343: PUSH
80344: LD_INT 3
80346: NEG
80347: PUSH
80348: LD_INT 1
80350: PUSH
80351: EMPTY
80352: LIST
80353: LIST
80354: PUSH
80355: LD_INT 4
80357: NEG
80358: PUSH
80359: LD_INT 1
80361: PUSH
80362: EMPTY
80363: LIST
80364: LIST
80365: PUSH
80366: LD_INT 5
80368: NEG
80369: PUSH
80370: LD_INT 0
80372: PUSH
80373: EMPTY
80374: LIST
80375: LIST
80376: PUSH
80377: LD_INT 5
80379: NEG
80380: PUSH
80381: LD_INT 1
80383: NEG
80384: PUSH
80385: EMPTY
80386: LIST
80387: LIST
80388: PUSH
80389: LD_INT 5
80391: NEG
80392: PUSH
80393: LD_INT 2
80395: NEG
80396: PUSH
80397: EMPTY
80398: LIST
80399: LIST
80400: PUSH
80401: LD_INT 3
80403: NEG
80404: PUSH
80405: LD_INT 2
80407: PUSH
80408: EMPTY
80409: LIST
80410: LIST
80411: PUSH
80412: LD_INT 3
80414: NEG
80415: PUSH
80416: LD_INT 3
80418: NEG
80419: PUSH
80420: EMPTY
80421: LIST
80422: LIST
80423: PUSH
80424: LD_INT 3
80426: NEG
80427: PUSH
80428: LD_INT 4
80430: NEG
80431: PUSH
80432: EMPTY
80433: LIST
80434: LIST
80435: PUSH
80436: LD_INT 2
80438: NEG
80439: PUSH
80440: LD_INT 3
80442: NEG
80443: PUSH
80444: EMPTY
80445: LIST
80446: LIST
80447: PUSH
80448: LD_INT 2
80450: NEG
80451: PUSH
80452: LD_INT 2
80454: NEG
80455: PUSH
80456: EMPTY
80457: LIST
80458: LIST
80459: PUSH
80460: LD_INT 3
80462: NEG
80463: PUSH
80464: LD_INT 2
80466: NEG
80467: PUSH
80468: EMPTY
80469: LIST
80470: LIST
80471: PUSH
80472: LD_INT 4
80474: NEG
80475: PUSH
80476: LD_INT 3
80478: NEG
80479: PUSH
80480: EMPTY
80481: LIST
80482: LIST
80483: PUSH
80484: LD_INT 4
80486: NEG
80487: PUSH
80488: LD_INT 4
80490: NEG
80491: PUSH
80492: EMPTY
80493: LIST
80494: LIST
80495: PUSH
80496: LD_INT 2
80498: NEG
80499: PUSH
80500: LD_INT 4
80502: NEG
80503: PUSH
80504: EMPTY
80505: LIST
80506: LIST
80507: PUSH
80508: LD_INT 4
80510: NEG
80511: PUSH
80512: LD_INT 2
80514: NEG
80515: PUSH
80516: EMPTY
80517: LIST
80518: LIST
80519: PUSH
80520: LD_INT 0
80522: PUSH
80523: LD_INT 4
80525: NEG
80526: PUSH
80527: EMPTY
80528: LIST
80529: LIST
80530: PUSH
80531: LD_INT 0
80533: PUSH
80534: LD_INT 5
80536: NEG
80537: PUSH
80538: EMPTY
80539: LIST
80540: LIST
80541: PUSH
80542: LD_INT 1
80544: PUSH
80545: LD_INT 4
80547: NEG
80548: PUSH
80549: EMPTY
80550: LIST
80551: LIST
80552: PUSH
80553: LD_INT 1
80555: PUSH
80556: LD_INT 3
80558: NEG
80559: PUSH
80560: EMPTY
80561: LIST
80562: LIST
80563: PUSH
80564: LD_INT 0
80566: PUSH
80567: LD_INT 3
80569: NEG
80570: PUSH
80571: EMPTY
80572: LIST
80573: LIST
80574: PUSH
80575: LD_INT 1
80577: NEG
80578: PUSH
80579: LD_INT 4
80581: NEG
80582: PUSH
80583: EMPTY
80584: LIST
80585: LIST
80586: PUSH
80587: LD_INT 1
80589: NEG
80590: PUSH
80591: LD_INT 5
80593: NEG
80594: PUSH
80595: EMPTY
80596: LIST
80597: LIST
80598: PUSH
80599: LD_INT 2
80601: PUSH
80602: LD_INT 3
80604: NEG
80605: PUSH
80606: EMPTY
80607: LIST
80608: LIST
80609: PUSH
80610: LD_INT 2
80612: NEG
80613: PUSH
80614: LD_INT 5
80616: NEG
80617: PUSH
80618: EMPTY
80619: LIST
80620: LIST
80621: PUSH
80622: EMPTY
80623: LIST
80624: LIST
80625: LIST
80626: LIST
80627: LIST
80628: LIST
80629: LIST
80630: LIST
80631: LIST
80632: LIST
80633: LIST
80634: LIST
80635: LIST
80636: LIST
80637: LIST
80638: LIST
80639: LIST
80640: LIST
80641: LIST
80642: LIST
80643: LIST
80644: LIST
80645: LIST
80646: LIST
80647: LIST
80648: LIST
80649: LIST
80650: LIST
80651: LIST
80652: LIST
80653: LIST
80654: LIST
80655: LIST
80656: LIST
80657: LIST
80658: LIST
80659: LIST
80660: LIST
80661: LIST
80662: LIST
80663: LIST
80664: LIST
80665: LIST
80666: LIST
80667: LIST
80668: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
80669: LD_ADDR_VAR 0 31
80673: PUSH
80674: LD_INT 0
80676: PUSH
80677: LD_INT 4
80679: PUSH
80680: EMPTY
80681: LIST
80682: LIST
80683: PUSH
80684: LD_INT 0
80686: PUSH
80687: LD_INT 3
80689: PUSH
80690: EMPTY
80691: LIST
80692: LIST
80693: PUSH
80694: LD_INT 1
80696: PUSH
80697: LD_INT 4
80699: PUSH
80700: EMPTY
80701: LIST
80702: LIST
80703: PUSH
80704: LD_INT 1
80706: PUSH
80707: LD_INT 5
80709: PUSH
80710: EMPTY
80711: LIST
80712: LIST
80713: PUSH
80714: LD_INT 0
80716: PUSH
80717: LD_INT 5
80719: PUSH
80720: EMPTY
80721: LIST
80722: LIST
80723: PUSH
80724: LD_INT 1
80726: NEG
80727: PUSH
80728: LD_INT 4
80730: PUSH
80731: EMPTY
80732: LIST
80733: LIST
80734: PUSH
80735: LD_INT 1
80737: NEG
80738: PUSH
80739: LD_INT 3
80741: PUSH
80742: EMPTY
80743: LIST
80744: LIST
80745: PUSH
80746: LD_INT 2
80748: PUSH
80749: LD_INT 5
80751: PUSH
80752: EMPTY
80753: LIST
80754: LIST
80755: PUSH
80756: LD_INT 2
80758: NEG
80759: PUSH
80760: LD_INT 3
80762: PUSH
80763: EMPTY
80764: LIST
80765: LIST
80766: PUSH
80767: LD_INT 3
80769: NEG
80770: PUSH
80771: LD_INT 0
80773: PUSH
80774: EMPTY
80775: LIST
80776: LIST
80777: PUSH
80778: LD_INT 3
80780: NEG
80781: PUSH
80782: LD_INT 1
80784: NEG
80785: PUSH
80786: EMPTY
80787: LIST
80788: LIST
80789: PUSH
80790: LD_INT 2
80792: NEG
80793: PUSH
80794: LD_INT 0
80796: PUSH
80797: EMPTY
80798: LIST
80799: LIST
80800: PUSH
80801: LD_INT 2
80803: NEG
80804: PUSH
80805: LD_INT 1
80807: PUSH
80808: EMPTY
80809: LIST
80810: LIST
80811: PUSH
80812: LD_INT 3
80814: NEG
80815: PUSH
80816: LD_INT 1
80818: PUSH
80819: EMPTY
80820: LIST
80821: LIST
80822: PUSH
80823: LD_INT 4
80825: NEG
80826: PUSH
80827: LD_INT 0
80829: PUSH
80830: EMPTY
80831: LIST
80832: LIST
80833: PUSH
80834: LD_INT 4
80836: NEG
80837: PUSH
80838: LD_INT 1
80840: NEG
80841: PUSH
80842: EMPTY
80843: LIST
80844: LIST
80845: PUSH
80846: LD_INT 4
80848: NEG
80849: PUSH
80850: LD_INT 2
80852: NEG
80853: PUSH
80854: EMPTY
80855: LIST
80856: LIST
80857: PUSH
80858: LD_INT 2
80860: NEG
80861: PUSH
80862: LD_INT 2
80864: PUSH
80865: EMPTY
80866: LIST
80867: LIST
80868: PUSH
80869: LD_INT 4
80871: NEG
80872: PUSH
80873: LD_INT 4
80875: NEG
80876: PUSH
80877: EMPTY
80878: LIST
80879: LIST
80880: PUSH
80881: LD_INT 4
80883: NEG
80884: PUSH
80885: LD_INT 5
80887: NEG
80888: PUSH
80889: EMPTY
80890: LIST
80891: LIST
80892: PUSH
80893: LD_INT 3
80895: NEG
80896: PUSH
80897: LD_INT 4
80899: NEG
80900: PUSH
80901: EMPTY
80902: LIST
80903: LIST
80904: PUSH
80905: LD_INT 3
80907: NEG
80908: PUSH
80909: LD_INT 3
80911: NEG
80912: PUSH
80913: EMPTY
80914: LIST
80915: LIST
80916: PUSH
80917: LD_INT 4
80919: NEG
80920: PUSH
80921: LD_INT 3
80923: NEG
80924: PUSH
80925: EMPTY
80926: LIST
80927: LIST
80928: PUSH
80929: LD_INT 5
80931: NEG
80932: PUSH
80933: LD_INT 4
80935: NEG
80936: PUSH
80937: EMPTY
80938: LIST
80939: LIST
80940: PUSH
80941: LD_INT 5
80943: NEG
80944: PUSH
80945: LD_INT 5
80947: NEG
80948: PUSH
80949: EMPTY
80950: LIST
80951: LIST
80952: PUSH
80953: LD_INT 3
80955: NEG
80956: PUSH
80957: LD_INT 5
80959: NEG
80960: PUSH
80961: EMPTY
80962: LIST
80963: LIST
80964: PUSH
80965: LD_INT 5
80967: NEG
80968: PUSH
80969: LD_INT 3
80971: NEG
80972: PUSH
80973: EMPTY
80974: LIST
80975: LIST
80976: PUSH
80977: LD_INT 0
80979: PUSH
80980: LD_INT 3
80982: NEG
80983: PUSH
80984: EMPTY
80985: LIST
80986: LIST
80987: PUSH
80988: LD_INT 0
80990: PUSH
80991: LD_INT 4
80993: NEG
80994: PUSH
80995: EMPTY
80996: LIST
80997: LIST
80998: PUSH
80999: LD_INT 1
81001: PUSH
81002: LD_INT 3
81004: NEG
81005: PUSH
81006: EMPTY
81007: LIST
81008: LIST
81009: PUSH
81010: LD_INT 1
81012: PUSH
81013: LD_INT 2
81015: NEG
81016: PUSH
81017: EMPTY
81018: LIST
81019: LIST
81020: PUSH
81021: LD_INT 0
81023: PUSH
81024: LD_INT 2
81026: NEG
81027: PUSH
81028: EMPTY
81029: LIST
81030: LIST
81031: PUSH
81032: LD_INT 1
81034: NEG
81035: PUSH
81036: LD_INT 3
81038: NEG
81039: PUSH
81040: EMPTY
81041: LIST
81042: LIST
81043: PUSH
81044: LD_INT 1
81046: NEG
81047: PUSH
81048: LD_INT 4
81050: NEG
81051: PUSH
81052: EMPTY
81053: LIST
81054: LIST
81055: PUSH
81056: LD_INT 2
81058: PUSH
81059: LD_INT 2
81061: NEG
81062: PUSH
81063: EMPTY
81064: LIST
81065: LIST
81066: PUSH
81067: LD_INT 2
81069: NEG
81070: PUSH
81071: LD_INT 4
81073: NEG
81074: PUSH
81075: EMPTY
81076: LIST
81077: LIST
81078: PUSH
81079: LD_INT 4
81081: PUSH
81082: LD_INT 0
81084: PUSH
81085: EMPTY
81086: LIST
81087: LIST
81088: PUSH
81089: LD_INT 4
81091: PUSH
81092: LD_INT 1
81094: NEG
81095: PUSH
81096: EMPTY
81097: LIST
81098: LIST
81099: PUSH
81100: LD_INT 5
81102: PUSH
81103: LD_INT 0
81105: PUSH
81106: EMPTY
81107: LIST
81108: LIST
81109: PUSH
81110: LD_INT 5
81112: PUSH
81113: LD_INT 1
81115: PUSH
81116: EMPTY
81117: LIST
81118: LIST
81119: PUSH
81120: LD_INT 4
81122: PUSH
81123: LD_INT 1
81125: PUSH
81126: EMPTY
81127: LIST
81128: LIST
81129: PUSH
81130: LD_INT 3
81132: PUSH
81133: LD_INT 0
81135: PUSH
81136: EMPTY
81137: LIST
81138: LIST
81139: PUSH
81140: LD_INT 3
81142: PUSH
81143: LD_INT 1
81145: NEG
81146: PUSH
81147: EMPTY
81148: LIST
81149: LIST
81150: PUSH
81151: LD_INT 3
81153: PUSH
81154: LD_INT 2
81156: NEG
81157: PUSH
81158: EMPTY
81159: LIST
81160: LIST
81161: PUSH
81162: LD_INT 5
81164: PUSH
81165: LD_INT 2
81167: PUSH
81168: EMPTY
81169: LIST
81170: LIST
81171: PUSH
81172: EMPTY
81173: LIST
81174: LIST
81175: LIST
81176: LIST
81177: LIST
81178: LIST
81179: LIST
81180: LIST
81181: LIST
81182: LIST
81183: LIST
81184: LIST
81185: LIST
81186: LIST
81187: LIST
81188: LIST
81189: LIST
81190: LIST
81191: LIST
81192: LIST
81193: LIST
81194: LIST
81195: LIST
81196: LIST
81197: LIST
81198: LIST
81199: LIST
81200: LIST
81201: LIST
81202: LIST
81203: LIST
81204: LIST
81205: LIST
81206: LIST
81207: LIST
81208: LIST
81209: LIST
81210: LIST
81211: LIST
81212: LIST
81213: LIST
81214: LIST
81215: LIST
81216: LIST
81217: LIST
81218: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
81219: LD_ADDR_VAR 0 32
81223: PUSH
81224: LD_INT 4
81226: NEG
81227: PUSH
81228: LD_INT 0
81230: PUSH
81231: EMPTY
81232: LIST
81233: LIST
81234: PUSH
81235: LD_INT 4
81237: NEG
81238: PUSH
81239: LD_INT 1
81241: NEG
81242: PUSH
81243: EMPTY
81244: LIST
81245: LIST
81246: PUSH
81247: LD_INT 3
81249: NEG
81250: PUSH
81251: LD_INT 0
81253: PUSH
81254: EMPTY
81255: LIST
81256: LIST
81257: PUSH
81258: LD_INT 3
81260: NEG
81261: PUSH
81262: LD_INT 1
81264: PUSH
81265: EMPTY
81266: LIST
81267: LIST
81268: PUSH
81269: LD_INT 4
81271: NEG
81272: PUSH
81273: LD_INT 1
81275: PUSH
81276: EMPTY
81277: LIST
81278: LIST
81279: PUSH
81280: LD_INT 5
81282: NEG
81283: PUSH
81284: LD_INT 0
81286: PUSH
81287: EMPTY
81288: LIST
81289: LIST
81290: PUSH
81291: LD_INT 5
81293: NEG
81294: PUSH
81295: LD_INT 1
81297: NEG
81298: PUSH
81299: EMPTY
81300: LIST
81301: LIST
81302: PUSH
81303: LD_INT 5
81305: NEG
81306: PUSH
81307: LD_INT 2
81309: NEG
81310: PUSH
81311: EMPTY
81312: LIST
81313: LIST
81314: PUSH
81315: LD_INT 3
81317: NEG
81318: PUSH
81319: LD_INT 2
81321: PUSH
81322: EMPTY
81323: LIST
81324: LIST
81325: PUSH
81326: LD_INT 3
81328: NEG
81329: PUSH
81330: LD_INT 3
81332: NEG
81333: PUSH
81334: EMPTY
81335: LIST
81336: LIST
81337: PUSH
81338: LD_INT 3
81340: NEG
81341: PUSH
81342: LD_INT 4
81344: NEG
81345: PUSH
81346: EMPTY
81347: LIST
81348: LIST
81349: PUSH
81350: LD_INT 2
81352: NEG
81353: PUSH
81354: LD_INT 3
81356: NEG
81357: PUSH
81358: EMPTY
81359: LIST
81360: LIST
81361: PUSH
81362: LD_INT 2
81364: NEG
81365: PUSH
81366: LD_INT 2
81368: NEG
81369: PUSH
81370: EMPTY
81371: LIST
81372: LIST
81373: PUSH
81374: LD_INT 3
81376: NEG
81377: PUSH
81378: LD_INT 2
81380: NEG
81381: PUSH
81382: EMPTY
81383: LIST
81384: LIST
81385: PUSH
81386: LD_INT 4
81388: NEG
81389: PUSH
81390: LD_INT 3
81392: NEG
81393: PUSH
81394: EMPTY
81395: LIST
81396: LIST
81397: PUSH
81398: LD_INT 4
81400: NEG
81401: PUSH
81402: LD_INT 4
81404: NEG
81405: PUSH
81406: EMPTY
81407: LIST
81408: LIST
81409: PUSH
81410: LD_INT 2
81412: NEG
81413: PUSH
81414: LD_INT 4
81416: NEG
81417: PUSH
81418: EMPTY
81419: LIST
81420: LIST
81421: PUSH
81422: LD_INT 4
81424: NEG
81425: PUSH
81426: LD_INT 2
81428: NEG
81429: PUSH
81430: EMPTY
81431: LIST
81432: LIST
81433: PUSH
81434: LD_INT 0
81436: PUSH
81437: LD_INT 4
81439: NEG
81440: PUSH
81441: EMPTY
81442: LIST
81443: LIST
81444: PUSH
81445: LD_INT 0
81447: PUSH
81448: LD_INT 5
81450: NEG
81451: PUSH
81452: EMPTY
81453: LIST
81454: LIST
81455: PUSH
81456: LD_INT 1
81458: PUSH
81459: LD_INT 4
81461: NEG
81462: PUSH
81463: EMPTY
81464: LIST
81465: LIST
81466: PUSH
81467: LD_INT 1
81469: PUSH
81470: LD_INT 3
81472: NEG
81473: PUSH
81474: EMPTY
81475: LIST
81476: LIST
81477: PUSH
81478: LD_INT 0
81480: PUSH
81481: LD_INT 3
81483: NEG
81484: PUSH
81485: EMPTY
81486: LIST
81487: LIST
81488: PUSH
81489: LD_INT 1
81491: NEG
81492: PUSH
81493: LD_INT 4
81495: NEG
81496: PUSH
81497: EMPTY
81498: LIST
81499: LIST
81500: PUSH
81501: LD_INT 1
81503: NEG
81504: PUSH
81505: LD_INT 5
81507: NEG
81508: PUSH
81509: EMPTY
81510: LIST
81511: LIST
81512: PUSH
81513: LD_INT 2
81515: PUSH
81516: LD_INT 3
81518: NEG
81519: PUSH
81520: EMPTY
81521: LIST
81522: LIST
81523: PUSH
81524: LD_INT 2
81526: NEG
81527: PUSH
81528: LD_INT 5
81530: NEG
81531: PUSH
81532: EMPTY
81533: LIST
81534: LIST
81535: PUSH
81536: LD_INT 3
81538: PUSH
81539: LD_INT 0
81541: PUSH
81542: EMPTY
81543: LIST
81544: LIST
81545: PUSH
81546: LD_INT 3
81548: PUSH
81549: LD_INT 1
81551: NEG
81552: PUSH
81553: EMPTY
81554: LIST
81555: LIST
81556: PUSH
81557: LD_INT 4
81559: PUSH
81560: LD_INT 0
81562: PUSH
81563: EMPTY
81564: LIST
81565: LIST
81566: PUSH
81567: LD_INT 4
81569: PUSH
81570: LD_INT 1
81572: PUSH
81573: EMPTY
81574: LIST
81575: LIST
81576: PUSH
81577: LD_INT 3
81579: PUSH
81580: LD_INT 1
81582: PUSH
81583: EMPTY
81584: LIST
81585: LIST
81586: PUSH
81587: LD_INT 2
81589: PUSH
81590: LD_INT 0
81592: PUSH
81593: EMPTY
81594: LIST
81595: LIST
81596: PUSH
81597: LD_INT 2
81599: PUSH
81600: LD_INT 1
81602: NEG
81603: PUSH
81604: EMPTY
81605: LIST
81606: LIST
81607: PUSH
81608: LD_INT 2
81610: PUSH
81611: LD_INT 2
81613: NEG
81614: PUSH
81615: EMPTY
81616: LIST
81617: LIST
81618: PUSH
81619: LD_INT 4
81621: PUSH
81622: LD_INT 2
81624: PUSH
81625: EMPTY
81626: LIST
81627: LIST
81628: PUSH
81629: LD_INT 4
81631: PUSH
81632: LD_INT 4
81634: PUSH
81635: EMPTY
81636: LIST
81637: LIST
81638: PUSH
81639: LD_INT 4
81641: PUSH
81642: LD_INT 3
81644: PUSH
81645: EMPTY
81646: LIST
81647: LIST
81648: PUSH
81649: LD_INT 5
81651: PUSH
81652: LD_INT 4
81654: PUSH
81655: EMPTY
81656: LIST
81657: LIST
81658: PUSH
81659: LD_INT 5
81661: PUSH
81662: LD_INT 5
81664: PUSH
81665: EMPTY
81666: LIST
81667: LIST
81668: PUSH
81669: LD_INT 4
81671: PUSH
81672: LD_INT 5
81674: PUSH
81675: EMPTY
81676: LIST
81677: LIST
81678: PUSH
81679: LD_INT 3
81681: PUSH
81682: LD_INT 4
81684: PUSH
81685: EMPTY
81686: LIST
81687: LIST
81688: PUSH
81689: LD_INT 3
81691: PUSH
81692: LD_INT 3
81694: PUSH
81695: EMPTY
81696: LIST
81697: LIST
81698: PUSH
81699: LD_INT 5
81701: PUSH
81702: LD_INT 3
81704: PUSH
81705: EMPTY
81706: LIST
81707: LIST
81708: PUSH
81709: LD_INT 3
81711: PUSH
81712: LD_INT 5
81714: PUSH
81715: EMPTY
81716: LIST
81717: LIST
81718: PUSH
81719: EMPTY
81720: LIST
81721: LIST
81722: LIST
81723: LIST
81724: LIST
81725: LIST
81726: LIST
81727: LIST
81728: LIST
81729: LIST
81730: LIST
81731: LIST
81732: LIST
81733: LIST
81734: LIST
81735: LIST
81736: LIST
81737: LIST
81738: LIST
81739: LIST
81740: LIST
81741: LIST
81742: LIST
81743: LIST
81744: LIST
81745: LIST
81746: LIST
81747: LIST
81748: LIST
81749: LIST
81750: LIST
81751: LIST
81752: LIST
81753: LIST
81754: LIST
81755: LIST
81756: LIST
81757: LIST
81758: LIST
81759: LIST
81760: LIST
81761: LIST
81762: LIST
81763: LIST
81764: LIST
81765: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
81766: LD_ADDR_VAR 0 33
81770: PUSH
81771: LD_INT 4
81773: NEG
81774: PUSH
81775: LD_INT 4
81777: NEG
81778: PUSH
81779: EMPTY
81780: LIST
81781: LIST
81782: PUSH
81783: LD_INT 4
81785: NEG
81786: PUSH
81787: LD_INT 5
81789: NEG
81790: PUSH
81791: EMPTY
81792: LIST
81793: LIST
81794: PUSH
81795: LD_INT 3
81797: NEG
81798: PUSH
81799: LD_INT 4
81801: NEG
81802: PUSH
81803: EMPTY
81804: LIST
81805: LIST
81806: PUSH
81807: LD_INT 3
81809: NEG
81810: PUSH
81811: LD_INT 3
81813: NEG
81814: PUSH
81815: EMPTY
81816: LIST
81817: LIST
81818: PUSH
81819: LD_INT 4
81821: NEG
81822: PUSH
81823: LD_INT 3
81825: NEG
81826: PUSH
81827: EMPTY
81828: LIST
81829: LIST
81830: PUSH
81831: LD_INT 5
81833: NEG
81834: PUSH
81835: LD_INT 4
81837: NEG
81838: PUSH
81839: EMPTY
81840: LIST
81841: LIST
81842: PUSH
81843: LD_INT 5
81845: NEG
81846: PUSH
81847: LD_INT 5
81849: NEG
81850: PUSH
81851: EMPTY
81852: LIST
81853: LIST
81854: PUSH
81855: LD_INT 3
81857: NEG
81858: PUSH
81859: LD_INT 5
81861: NEG
81862: PUSH
81863: EMPTY
81864: LIST
81865: LIST
81866: PUSH
81867: LD_INT 5
81869: NEG
81870: PUSH
81871: LD_INT 3
81873: NEG
81874: PUSH
81875: EMPTY
81876: LIST
81877: LIST
81878: PUSH
81879: LD_INT 0
81881: PUSH
81882: LD_INT 3
81884: NEG
81885: PUSH
81886: EMPTY
81887: LIST
81888: LIST
81889: PUSH
81890: LD_INT 0
81892: PUSH
81893: LD_INT 4
81895: NEG
81896: PUSH
81897: EMPTY
81898: LIST
81899: LIST
81900: PUSH
81901: LD_INT 1
81903: PUSH
81904: LD_INT 3
81906: NEG
81907: PUSH
81908: EMPTY
81909: LIST
81910: LIST
81911: PUSH
81912: LD_INT 1
81914: PUSH
81915: LD_INT 2
81917: NEG
81918: PUSH
81919: EMPTY
81920: LIST
81921: LIST
81922: PUSH
81923: LD_INT 0
81925: PUSH
81926: LD_INT 2
81928: NEG
81929: PUSH
81930: EMPTY
81931: LIST
81932: LIST
81933: PUSH
81934: LD_INT 1
81936: NEG
81937: PUSH
81938: LD_INT 3
81940: NEG
81941: PUSH
81942: EMPTY
81943: LIST
81944: LIST
81945: PUSH
81946: LD_INT 1
81948: NEG
81949: PUSH
81950: LD_INT 4
81952: NEG
81953: PUSH
81954: EMPTY
81955: LIST
81956: LIST
81957: PUSH
81958: LD_INT 2
81960: PUSH
81961: LD_INT 2
81963: NEG
81964: PUSH
81965: EMPTY
81966: LIST
81967: LIST
81968: PUSH
81969: LD_INT 2
81971: NEG
81972: PUSH
81973: LD_INT 4
81975: NEG
81976: PUSH
81977: EMPTY
81978: LIST
81979: LIST
81980: PUSH
81981: LD_INT 4
81983: PUSH
81984: LD_INT 0
81986: PUSH
81987: EMPTY
81988: LIST
81989: LIST
81990: PUSH
81991: LD_INT 4
81993: PUSH
81994: LD_INT 1
81996: NEG
81997: PUSH
81998: EMPTY
81999: LIST
82000: LIST
82001: PUSH
82002: LD_INT 5
82004: PUSH
82005: LD_INT 0
82007: PUSH
82008: EMPTY
82009: LIST
82010: LIST
82011: PUSH
82012: LD_INT 5
82014: PUSH
82015: LD_INT 1
82017: PUSH
82018: EMPTY
82019: LIST
82020: LIST
82021: PUSH
82022: LD_INT 4
82024: PUSH
82025: LD_INT 1
82027: PUSH
82028: EMPTY
82029: LIST
82030: LIST
82031: PUSH
82032: LD_INT 3
82034: PUSH
82035: LD_INT 0
82037: PUSH
82038: EMPTY
82039: LIST
82040: LIST
82041: PUSH
82042: LD_INT 3
82044: PUSH
82045: LD_INT 1
82047: NEG
82048: PUSH
82049: EMPTY
82050: LIST
82051: LIST
82052: PUSH
82053: LD_INT 3
82055: PUSH
82056: LD_INT 2
82058: NEG
82059: PUSH
82060: EMPTY
82061: LIST
82062: LIST
82063: PUSH
82064: LD_INT 5
82066: PUSH
82067: LD_INT 2
82069: PUSH
82070: EMPTY
82071: LIST
82072: LIST
82073: PUSH
82074: LD_INT 3
82076: PUSH
82077: LD_INT 3
82079: PUSH
82080: EMPTY
82081: LIST
82082: LIST
82083: PUSH
82084: LD_INT 3
82086: PUSH
82087: LD_INT 2
82089: PUSH
82090: EMPTY
82091: LIST
82092: LIST
82093: PUSH
82094: LD_INT 4
82096: PUSH
82097: LD_INT 3
82099: PUSH
82100: EMPTY
82101: LIST
82102: LIST
82103: PUSH
82104: LD_INT 4
82106: PUSH
82107: LD_INT 4
82109: PUSH
82110: EMPTY
82111: LIST
82112: LIST
82113: PUSH
82114: LD_INT 3
82116: PUSH
82117: LD_INT 4
82119: PUSH
82120: EMPTY
82121: LIST
82122: LIST
82123: PUSH
82124: LD_INT 2
82126: PUSH
82127: LD_INT 3
82129: PUSH
82130: EMPTY
82131: LIST
82132: LIST
82133: PUSH
82134: LD_INT 2
82136: PUSH
82137: LD_INT 2
82139: PUSH
82140: EMPTY
82141: LIST
82142: LIST
82143: PUSH
82144: LD_INT 4
82146: PUSH
82147: LD_INT 2
82149: PUSH
82150: EMPTY
82151: LIST
82152: LIST
82153: PUSH
82154: LD_INT 2
82156: PUSH
82157: LD_INT 4
82159: PUSH
82160: EMPTY
82161: LIST
82162: LIST
82163: PUSH
82164: LD_INT 0
82166: PUSH
82167: LD_INT 4
82169: PUSH
82170: EMPTY
82171: LIST
82172: LIST
82173: PUSH
82174: LD_INT 0
82176: PUSH
82177: LD_INT 3
82179: PUSH
82180: EMPTY
82181: LIST
82182: LIST
82183: PUSH
82184: LD_INT 1
82186: PUSH
82187: LD_INT 4
82189: PUSH
82190: EMPTY
82191: LIST
82192: LIST
82193: PUSH
82194: LD_INT 1
82196: PUSH
82197: LD_INT 5
82199: PUSH
82200: EMPTY
82201: LIST
82202: LIST
82203: PUSH
82204: LD_INT 0
82206: PUSH
82207: LD_INT 5
82209: PUSH
82210: EMPTY
82211: LIST
82212: LIST
82213: PUSH
82214: LD_INT 1
82216: NEG
82217: PUSH
82218: LD_INT 4
82220: PUSH
82221: EMPTY
82222: LIST
82223: LIST
82224: PUSH
82225: LD_INT 1
82227: NEG
82228: PUSH
82229: LD_INT 3
82231: PUSH
82232: EMPTY
82233: LIST
82234: LIST
82235: PUSH
82236: LD_INT 2
82238: PUSH
82239: LD_INT 5
82241: PUSH
82242: EMPTY
82243: LIST
82244: LIST
82245: PUSH
82246: LD_INT 2
82248: NEG
82249: PUSH
82250: LD_INT 3
82252: PUSH
82253: EMPTY
82254: LIST
82255: LIST
82256: PUSH
82257: EMPTY
82258: LIST
82259: LIST
82260: LIST
82261: LIST
82262: LIST
82263: LIST
82264: LIST
82265: LIST
82266: LIST
82267: LIST
82268: LIST
82269: LIST
82270: LIST
82271: LIST
82272: LIST
82273: LIST
82274: LIST
82275: LIST
82276: LIST
82277: LIST
82278: LIST
82279: LIST
82280: LIST
82281: LIST
82282: LIST
82283: LIST
82284: LIST
82285: LIST
82286: LIST
82287: LIST
82288: LIST
82289: LIST
82290: LIST
82291: LIST
82292: LIST
82293: LIST
82294: LIST
82295: LIST
82296: LIST
82297: LIST
82298: LIST
82299: LIST
82300: LIST
82301: LIST
82302: LIST
82303: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
82304: LD_ADDR_VAR 0 34
82308: PUSH
82309: LD_INT 0
82311: PUSH
82312: LD_INT 4
82314: NEG
82315: PUSH
82316: EMPTY
82317: LIST
82318: LIST
82319: PUSH
82320: LD_INT 0
82322: PUSH
82323: LD_INT 5
82325: NEG
82326: PUSH
82327: EMPTY
82328: LIST
82329: LIST
82330: PUSH
82331: LD_INT 1
82333: PUSH
82334: LD_INT 4
82336: NEG
82337: PUSH
82338: EMPTY
82339: LIST
82340: LIST
82341: PUSH
82342: LD_INT 1
82344: PUSH
82345: LD_INT 3
82347: NEG
82348: PUSH
82349: EMPTY
82350: LIST
82351: LIST
82352: PUSH
82353: LD_INT 0
82355: PUSH
82356: LD_INT 3
82358: NEG
82359: PUSH
82360: EMPTY
82361: LIST
82362: LIST
82363: PUSH
82364: LD_INT 1
82366: NEG
82367: PUSH
82368: LD_INT 4
82370: NEG
82371: PUSH
82372: EMPTY
82373: LIST
82374: LIST
82375: PUSH
82376: LD_INT 1
82378: NEG
82379: PUSH
82380: LD_INT 5
82382: NEG
82383: PUSH
82384: EMPTY
82385: LIST
82386: LIST
82387: PUSH
82388: LD_INT 2
82390: PUSH
82391: LD_INT 3
82393: NEG
82394: PUSH
82395: EMPTY
82396: LIST
82397: LIST
82398: PUSH
82399: LD_INT 2
82401: NEG
82402: PUSH
82403: LD_INT 5
82405: NEG
82406: PUSH
82407: EMPTY
82408: LIST
82409: LIST
82410: PUSH
82411: LD_INT 3
82413: PUSH
82414: LD_INT 0
82416: PUSH
82417: EMPTY
82418: LIST
82419: LIST
82420: PUSH
82421: LD_INT 3
82423: PUSH
82424: LD_INT 1
82426: NEG
82427: PUSH
82428: EMPTY
82429: LIST
82430: LIST
82431: PUSH
82432: LD_INT 4
82434: PUSH
82435: LD_INT 0
82437: PUSH
82438: EMPTY
82439: LIST
82440: LIST
82441: PUSH
82442: LD_INT 4
82444: PUSH
82445: LD_INT 1
82447: PUSH
82448: EMPTY
82449: LIST
82450: LIST
82451: PUSH
82452: LD_INT 3
82454: PUSH
82455: LD_INT 1
82457: PUSH
82458: EMPTY
82459: LIST
82460: LIST
82461: PUSH
82462: LD_INT 2
82464: PUSH
82465: LD_INT 0
82467: PUSH
82468: EMPTY
82469: LIST
82470: LIST
82471: PUSH
82472: LD_INT 2
82474: PUSH
82475: LD_INT 1
82477: NEG
82478: PUSH
82479: EMPTY
82480: LIST
82481: LIST
82482: PUSH
82483: LD_INT 2
82485: PUSH
82486: LD_INT 2
82488: NEG
82489: PUSH
82490: EMPTY
82491: LIST
82492: LIST
82493: PUSH
82494: LD_INT 4
82496: PUSH
82497: LD_INT 2
82499: PUSH
82500: EMPTY
82501: LIST
82502: LIST
82503: PUSH
82504: LD_INT 4
82506: PUSH
82507: LD_INT 4
82509: PUSH
82510: EMPTY
82511: LIST
82512: LIST
82513: PUSH
82514: LD_INT 4
82516: PUSH
82517: LD_INT 3
82519: PUSH
82520: EMPTY
82521: LIST
82522: LIST
82523: PUSH
82524: LD_INT 5
82526: PUSH
82527: LD_INT 4
82529: PUSH
82530: EMPTY
82531: LIST
82532: LIST
82533: PUSH
82534: LD_INT 5
82536: PUSH
82537: LD_INT 5
82539: PUSH
82540: EMPTY
82541: LIST
82542: LIST
82543: PUSH
82544: LD_INT 4
82546: PUSH
82547: LD_INT 5
82549: PUSH
82550: EMPTY
82551: LIST
82552: LIST
82553: PUSH
82554: LD_INT 3
82556: PUSH
82557: LD_INT 4
82559: PUSH
82560: EMPTY
82561: LIST
82562: LIST
82563: PUSH
82564: LD_INT 3
82566: PUSH
82567: LD_INT 3
82569: PUSH
82570: EMPTY
82571: LIST
82572: LIST
82573: PUSH
82574: LD_INT 5
82576: PUSH
82577: LD_INT 3
82579: PUSH
82580: EMPTY
82581: LIST
82582: LIST
82583: PUSH
82584: LD_INT 3
82586: PUSH
82587: LD_INT 5
82589: PUSH
82590: EMPTY
82591: LIST
82592: LIST
82593: PUSH
82594: LD_INT 0
82596: PUSH
82597: LD_INT 3
82599: PUSH
82600: EMPTY
82601: LIST
82602: LIST
82603: PUSH
82604: LD_INT 0
82606: PUSH
82607: LD_INT 2
82609: PUSH
82610: EMPTY
82611: LIST
82612: LIST
82613: PUSH
82614: LD_INT 1
82616: PUSH
82617: LD_INT 3
82619: PUSH
82620: EMPTY
82621: LIST
82622: LIST
82623: PUSH
82624: LD_INT 1
82626: PUSH
82627: LD_INT 4
82629: PUSH
82630: EMPTY
82631: LIST
82632: LIST
82633: PUSH
82634: LD_INT 0
82636: PUSH
82637: LD_INT 4
82639: PUSH
82640: EMPTY
82641: LIST
82642: LIST
82643: PUSH
82644: LD_INT 1
82646: NEG
82647: PUSH
82648: LD_INT 3
82650: PUSH
82651: EMPTY
82652: LIST
82653: LIST
82654: PUSH
82655: LD_INT 1
82657: NEG
82658: PUSH
82659: LD_INT 2
82661: PUSH
82662: EMPTY
82663: LIST
82664: LIST
82665: PUSH
82666: LD_INT 2
82668: PUSH
82669: LD_INT 4
82671: PUSH
82672: EMPTY
82673: LIST
82674: LIST
82675: PUSH
82676: LD_INT 2
82678: NEG
82679: PUSH
82680: LD_INT 2
82682: PUSH
82683: EMPTY
82684: LIST
82685: LIST
82686: PUSH
82687: LD_INT 4
82689: NEG
82690: PUSH
82691: LD_INT 0
82693: PUSH
82694: EMPTY
82695: LIST
82696: LIST
82697: PUSH
82698: LD_INT 4
82700: NEG
82701: PUSH
82702: LD_INT 1
82704: NEG
82705: PUSH
82706: EMPTY
82707: LIST
82708: LIST
82709: PUSH
82710: LD_INT 3
82712: NEG
82713: PUSH
82714: LD_INT 0
82716: PUSH
82717: EMPTY
82718: LIST
82719: LIST
82720: PUSH
82721: LD_INT 3
82723: NEG
82724: PUSH
82725: LD_INT 1
82727: PUSH
82728: EMPTY
82729: LIST
82730: LIST
82731: PUSH
82732: LD_INT 4
82734: NEG
82735: PUSH
82736: LD_INT 1
82738: PUSH
82739: EMPTY
82740: LIST
82741: LIST
82742: PUSH
82743: LD_INT 5
82745: NEG
82746: PUSH
82747: LD_INT 0
82749: PUSH
82750: EMPTY
82751: LIST
82752: LIST
82753: PUSH
82754: LD_INT 5
82756: NEG
82757: PUSH
82758: LD_INT 1
82760: NEG
82761: PUSH
82762: EMPTY
82763: LIST
82764: LIST
82765: PUSH
82766: LD_INT 5
82768: NEG
82769: PUSH
82770: LD_INT 2
82772: NEG
82773: PUSH
82774: EMPTY
82775: LIST
82776: LIST
82777: PUSH
82778: LD_INT 3
82780: NEG
82781: PUSH
82782: LD_INT 2
82784: PUSH
82785: EMPTY
82786: LIST
82787: LIST
82788: PUSH
82789: EMPTY
82790: LIST
82791: LIST
82792: LIST
82793: LIST
82794: LIST
82795: LIST
82796: LIST
82797: LIST
82798: LIST
82799: LIST
82800: LIST
82801: LIST
82802: LIST
82803: LIST
82804: LIST
82805: LIST
82806: LIST
82807: LIST
82808: LIST
82809: LIST
82810: LIST
82811: LIST
82812: LIST
82813: LIST
82814: LIST
82815: LIST
82816: LIST
82817: LIST
82818: LIST
82819: LIST
82820: LIST
82821: LIST
82822: LIST
82823: LIST
82824: LIST
82825: LIST
82826: LIST
82827: LIST
82828: LIST
82829: LIST
82830: LIST
82831: LIST
82832: LIST
82833: LIST
82834: LIST
82835: ST_TO_ADDR
// end ; end ;
82836: GO 82839
82838: POP
// case btype of b_depot , b_warehouse :
82839: LD_VAR 0 1
82843: PUSH
82844: LD_INT 0
82846: DOUBLE
82847: EQUAL
82848: IFTRUE 82858
82850: LD_INT 1
82852: DOUBLE
82853: EQUAL
82854: IFTRUE 82858
82856: GO 83059
82858: POP
// case nation of nation_american :
82859: LD_VAR 0 5
82863: PUSH
82864: LD_INT 1
82866: DOUBLE
82867: EQUAL
82868: IFTRUE 82872
82870: GO 82928
82872: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
82873: LD_ADDR_VAR 0 9
82877: PUSH
82878: LD_VAR 0 11
82882: PUSH
82883: LD_VAR 0 12
82887: PUSH
82888: LD_VAR 0 13
82892: PUSH
82893: LD_VAR 0 14
82897: PUSH
82898: LD_VAR 0 15
82902: PUSH
82903: LD_VAR 0 16
82907: PUSH
82908: EMPTY
82909: LIST
82910: LIST
82911: LIST
82912: LIST
82913: LIST
82914: LIST
82915: PUSH
82916: LD_VAR 0 4
82920: PUSH
82921: LD_INT 1
82923: PLUS
82924: ARRAY
82925: ST_TO_ADDR
82926: GO 83057
82928: LD_INT 2
82930: DOUBLE
82931: EQUAL
82932: IFTRUE 82936
82934: GO 82992
82936: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
82937: LD_ADDR_VAR 0 9
82941: PUSH
82942: LD_VAR 0 17
82946: PUSH
82947: LD_VAR 0 18
82951: PUSH
82952: LD_VAR 0 19
82956: PUSH
82957: LD_VAR 0 20
82961: PUSH
82962: LD_VAR 0 21
82966: PUSH
82967: LD_VAR 0 22
82971: PUSH
82972: EMPTY
82973: LIST
82974: LIST
82975: LIST
82976: LIST
82977: LIST
82978: LIST
82979: PUSH
82980: LD_VAR 0 4
82984: PUSH
82985: LD_INT 1
82987: PLUS
82988: ARRAY
82989: ST_TO_ADDR
82990: GO 83057
82992: LD_INT 3
82994: DOUBLE
82995: EQUAL
82996: IFTRUE 83000
82998: GO 83056
83000: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
83001: LD_ADDR_VAR 0 9
83005: PUSH
83006: LD_VAR 0 23
83010: PUSH
83011: LD_VAR 0 24
83015: PUSH
83016: LD_VAR 0 25
83020: PUSH
83021: LD_VAR 0 26
83025: PUSH
83026: LD_VAR 0 27
83030: PUSH
83031: LD_VAR 0 28
83035: PUSH
83036: EMPTY
83037: LIST
83038: LIST
83039: LIST
83040: LIST
83041: LIST
83042: LIST
83043: PUSH
83044: LD_VAR 0 4
83048: PUSH
83049: LD_INT 1
83051: PLUS
83052: ARRAY
83053: ST_TO_ADDR
83054: GO 83057
83056: POP
83057: GO 83612
83059: LD_INT 2
83061: DOUBLE
83062: EQUAL
83063: IFTRUE 83073
83065: LD_INT 3
83067: DOUBLE
83068: EQUAL
83069: IFTRUE 83073
83071: GO 83129
83073: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
83074: LD_ADDR_VAR 0 9
83078: PUSH
83079: LD_VAR 0 29
83083: PUSH
83084: LD_VAR 0 30
83088: PUSH
83089: LD_VAR 0 31
83093: PUSH
83094: LD_VAR 0 32
83098: PUSH
83099: LD_VAR 0 33
83103: PUSH
83104: LD_VAR 0 34
83108: PUSH
83109: EMPTY
83110: LIST
83111: LIST
83112: LIST
83113: LIST
83114: LIST
83115: LIST
83116: PUSH
83117: LD_VAR 0 4
83121: PUSH
83122: LD_INT 1
83124: PLUS
83125: ARRAY
83126: ST_TO_ADDR
83127: GO 83612
83129: LD_INT 16
83131: DOUBLE
83132: EQUAL
83133: IFTRUE 83191
83135: LD_INT 17
83137: DOUBLE
83138: EQUAL
83139: IFTRUE 83191
83141: LD_INT 18
83143: DOUBLE
83144: EQUAL
83145: IFTRUE 83191
83147: LD_INT 19
83149: DOUBLE
83150: EQUAL
83151: IFTRUE 83191
83153: LD_INT 22
83155: DOUBLE
83156: EQUAL
83157: IFTRUE 83191
83159: LD_INT 20
83161: DOUBLE
83162: EQUAL
83163: IFTRUE 83191
83165: LD_INT 21
83167: DOUBLE
83168: EQUAL
83169: IFTRUE 83191
83171: LD_INT 23
83173: DOUBLE
83174: EQUAL
83175: IFTRUE 83191
83177: LD_INT 24
83179: DOUBLE
83180: EQUAL
83181: IFTRUE 83191
83183: LD_INT 25
83185: DOUBLE
83186: EQUAL
83187: IFTRUE 83191
83189: GO 83247
83191: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
83192: LD_ADDR_VAR 0 9
83196: PUSH
83197: LD_VAR 0 35
83201: PUSH
83202: LD_VAR 0 36
83206: PUSH
83207: LD_VAR 0 37
83211: PUSH
83212: LD_VAR 0 38
83216: PUSH
83217: LD_VAR 0 39
83221: PUSH
83222: LD_VAR 0 40
83226: PUSH
83227: EMPTY
83228: LIST
83229: LIST
83230: LIST
83231: LIST
83232: LIST
83233: LIST
83234: PUSH
83235: LD_VAR 0 4
83239: PUSH
83240: LD_INT 1
83242: PLUS
83243: ARRAY
83244: ST_TO_ADDR
83245: GO 83612
83247: LD_INT 6
83249: DOUBLE
83250: EQUAL
83251: IFTRUE 83303
83253: LD_INT 7
83255: DOUBLE
83256: EQUAL
83257: IFTRUE 83303
83259: LD_INT 8
83261: DOUBLE
83262: EQUAL
83263: IFTRUE 83303
83265: LD_INT 13
83267: DOUBLE
83268: EQUAL
83269: IFTRUE 83303
83271: LD_INT 12
83273: DOUBLE
83274: EQUAL
83275: IFTRUE 83303
83277: LD_INT 15
83279: DOUBLE
83280: EQUAL
83281: IFTRUE 83303
83283: LD_INT 11
83285: DOUBLE
83286: EQUAL
83287: IFTRUE 83303
83289: LD_INT 14
83291: DOUBLE
83292: EQUAL
83293: IFTRUE 83303
83295: LD_INT 10
83297: DOUBLE
83298: EQUAL
83299: IFTRUE 83303
83301: GO 83359
83303: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
83304: LD_ADDR_VAR 0 9
83308: PUSH
83309: LD_VAR 0 41
83313: PUSH
83314: LD_VAR 0 42
83318: PUSH
83319: LD_VAR 0 43
83323: PUSH
83324: LD_VAR 0 44
83328: PUSH
83329: LD_VAR 0 45
83333: PUSH
83334: LD_VAR 0 46
83338: PUSH
83339: EMPTY
83340: LIST
83341: LIST
83342: LIST
83343: LIST
83344: LIST
83345: LIST
83346: PUSH
83347: LD_VAR 0 4
83351: PUSH
83352: LD_INT 1
83354: PLUS
83355: ARRAY
83356: ST_TO_ADDR
83357: GO 83612
83359: LD_INT 36
83361: DOUBLE
83362: EQUAL
83363: IFTRUE 83367
83365: GO 83423
83367: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
83368: LD_ADDR_VAR 0 9
83372: PUSH
83373: LD_VAR 0 47
83377: PUSH
83378: LD_VAR 0 48
83382: PUSH
83383: LD_VAR 0 49
83387: PUSH
83388: LD_VAR 0 50
83392: PUSH
83393: LD_VAR 0 51
83397: PUSH
83398: LD_VAR 0 52
83402: PUSH
83403: EMPTY
83404: LIST
83405: LIST
83406: LIST
83407: LIST
83408: LIST
83409: LIST
83410: PUSH
83411: LD_VAR 0 4
83415: PUSH
83416: LD_INT 1
83418: PLUS
83419: ARRAY
83420: ST_TO_ADDR
83421: GO 83612
83423: LD_INT 4
83425: DOUBLE
83426: EQUAL
83427: IFTRUE 83449
83429: LD_INT 5
83431: DOUBLE
83432: EQUAL
83433: IFTRUE 83449
83435: LD_INT 34
83437: DOUBLE
83438: EQUAL
83439: IFTRUE 83449
83441: LD_INT 37
83443: DOUBLE
83444: EQUAL
83445: IFTRUE 83449
83447: GO 83505
83449: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
83450: LD_ADDR_VAR 0 9
83454: PUSH
83455: LD_VAR 0 53
83459: PUSH
83460: LD_VAR 0 54
83464: PUSH
83465: LD_VAR 0 55
83469: PUSH
83470: LD_VAR 0 56
83474: PUSH
83475: LD_VAR 0 57
83479: PUSH
83480: LD_VAR 0 58
83484: PUSH
83485: EMPTY
83486: LIST
83487: LIST
83488: LIST
83489: LIST
83490: LIST
83491: LIST
83492: PUSH
83493: LD_VAR 0 4
83497: PUSH
83498: LD_INT 1
83500: PLUS
83501: ARRAY
83502: ST_TO_ADDR
83503: GO 83612
83505: LD_INT 31
83507: DOUBLE
83508: EQUAL
83509: IFTRUE 83555
83511: LD_INT 32
83513: DOUBLE
83514: EQUAL
83515: IFTRUE 83555
83517: LD_INT 33
83519: DOUBLE
83520: EQUAL
83521: IFTRUE 83555
83523: LD_INT 27
83525: DOUBLE
83526: EQUAL
83527: IFTRUE 83555
83529: LD_INT 26
83531: DOUBLE
83532: EQUAL
83533: IFTRUE 83555
83535: LD_INT 28
83537: DOUBLE
83538: EQUAL
83539: IFTRUE 83555
83541: LD_INT 29
83543: DOUBLE
83544: EQUAL
83545: IFTRUE 83555
83547: LD_INT 30
83549: DOUBLE
83550: EQUAL
83551: IFTRUE 83555
83553: GO 83611
83555: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
83556: LD_ADDR_VAR 0 9
83560: PUSH
83561: LD_VAR 0 59
83565: PUSH
83566: LD_VAR 0 60
83570: PUSH
83571: LD_VAR 0 61
83575: PUSH
83576: LD_VAR 0 62
83580: PUSH
83581: LD_VAR 0 63
83585: PUSH
83586: LD_VAR 0 64
83590: PUSH
83591: EMPTY
83592: LIST
83593: LIST
83594: LIST
83595: LIST
83596: LIST
83597: LIST
83598: PUSH
83599: LD_VAR 0 4
83603: PUSH
83604: LD_INT 1
83606: PLUS
83607: ARRAY
83608: ST_TO_ADDR
83609: GO 83612
83611: POP
// temp_list2 = [ ] ;
83612: LD_ADDR_VAR 0 10
83616: PUSH
83617: EMPTY
83618: ST_TO_ADDR
// for i in temp_list do
83619: LD_ADDR_VAR 0 8
83623: PUSH
83624: LD_VAR 0 9
83628: PUSH
83629: FOR_IN
83630: IFFALSE 83682
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
83632: LD_ADDR_VAR 0 10
83636: PUSH
83637: LD_VAR 0 10
83641: PUSH
83642: LD_VAR 0 8
83646: PUSH
83647: LD_INT 1
83649: ARRAY
83650: PUSH
83651: LD_VAR 0 2
83655: PLUS
83656: PUSH
83657: LD_VAR 0 8
83661: PUSH
83662: LD_INT 2
83664: ARRAY
83665: PUSH
83666: LD_VAR 0 3
83670: PLUS
83671: PUSH
83672: EMPTY
83673: LIST
83674: LIST
83675: PUSH
83676: EMPTY
83677: LIST
83678: ADD
83679: ST_TO_ADDR
83680: GO 83629
83682: POP
83683: POP
// result = temp_list2 ;
83684: LD_ADDR_VAR 0 7
83688: PUSH
83689: LD_VAR 0 10
83693: ST_TO_ADDR
// end ;
83694: LD_VAR 0 7
83698: RET
// export function EnemyInRange ( unit , dist ) ; begin
83699: LD_INT 0
83701: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
83702: LD_ADDR_VAR 0 3
83706: PUSH
83707: LD_VAR 0 1
83711: PPUSH
83712: CALL_OW 255
83716: PPUSH
83717: LD_VAR 0 1
83721: PPUSH
83722: CALL_OW 250
83726: PPUSH
83727: LD_VAR 0 1
83731: PPUSH
83732: CALL_OW 251
83736: PPUSH
83737: LD_VAR 0 2
83741: PPUSH
83742: CALL 57094 0 4
83746: PUSH
83747: LD_INT 4
83749: ARRAY
83750: ST_TO_ADDR
// end ;
83751: LD_VAR 0 3
83755: RET
// export function PlayerSeeMe ( unit ) ; begin
83756: LD_INT 0
83758: PPUSH
// result := See ( your_side , unit ) ;
83759: LD_ADDR_VAR 0 2
83763: PUSH
83764: LD_OWVAR 2
83768: PPUSH
83769: LD_VAR 0 1
83773: PPUSH
83774: CALL_OW 292
83778: ST_TO_ADDR
// end ;
83779: LD_VAR 0 2
83783: RET
// export function ReverseDir ( unit ) ; begin
83784: LD_INT 0
83786: PPUSH
// if not unit then
83787: LD_VAR 0 1
83791: NOT
83792: IFFALSE 83796
// exit ;
83794: GO 83819
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
83796: LD_ADDR_VAR 0 2
83800: PUSH
83801: LD_VAR 0 1
83805: PPUSH
83806: CALL_OW 254
83810: PUSH
83811: LD_INT 3
83813: PLUS
83814: PUSH
83815: LD_INT 6
83817: MOD
83818: ST_TO_ADDR
// end ;
83819: LD_VAR 0 2
83823: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
83824: LD_INT 0
83826: PPUSH
83827: PPUSH
83828: PPUSH
83829: PPUSH
83830: PPUSH
// if not hexes then
83831: LD_VAR 0 2
83835: NOT
83836: IFFALSE 83840
// exit ;
83838: GO 83988
// dist := 9999 ;
83840: LD_ADDR_VAR 0 5
83844: PUSH
83845: LD_INT 9999
83847: ST_TO_ADDR
// for i = 1 to hexes do
83848: LD_ADDR_VAR 0 4
83852: PUSH
83853: DOUBLE
83854: LD_INT 1
83856: DEC
83857: ST_TO_ADDR
83858: LD_VAR 0 2
83862: PUSH
83863: FOR_TO
83864: IFFALSE 83976
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
83866: LD_VAR 0 1
83870: PPUSH
83871: LD_VAR 0 2
83875: PUSH
83876: LD_VAR 0 4
83880: ARRAY
83881: PUSH
83882: LD_INT 1
83884: ARRAY
83885: PPUSH
83886: LD_VAR 0 2
83890: PUSH
83891: LD_VAR 0 4
83895: ARRAY
83896: PUSH
83897: LD_INT 2
83899: ARRAY
83900: PPUSH
83901: CALL_OW 297
83905: PUSH
83906: LD_VAR 0 5
83910: LESS
83911: IFFALSE 83974
// begin hex := hexes [ i ] ;
83913: LD_ADDR_VAR 0 7
83917: PUSH
83918: LD_VAR 0 2
83922: PUSH
83923: LD_VAR 0 4
83927: ARRAY
83928: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
83929: LD_ADDR_VAR 0 5
83933: PUSH
83934: LD_VAR 0 1
83938: PPUSH
83939: LD_VAR 0 2
83943: PUSH
83944: LD_VAR 0 4
83948: ARRAY
83949: PUSH
83950: LD_INT 1
83952: ARRAY
83953: PPUSH
83954: LD_VAR 0 2
83958: PUSH
83959: LD_VAR 0 4
83963: ARRAY
83964: PUSH
83965: LD_INT 2
83967: ARRAY
83968: PPUSH
83969: CALL_OW 297
83973: ST_TO_ADDR
// end ; end ;
83974: GO 83863
83976: POP
83977: POP
// result := hex ;
83978: LD_ADDR_VAR 0 3
83982: PUSH
83983: LD_VAR 0 7
83987: ST_TO_ADDR
// end ;
83988: LD_VAR 0 3
83992: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
83993: LD_INT 0
83995: PPUSH
83996: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
83997: LD_VAR 0 1
84001: NOT
84002: PUSH
84003: LD_VAR 0 1
84007: PUSH
84008: LD_INT 21
84010: PUSH
84011: LD_INT 2
84013: PUSH
84014: EMPTY
84015: LIST
84016: LIST
84017: PUSH
84018: LD_INT 23
84020: PUSH
84021: LD_INT 2
84023: PUSH
84024: EMPTY
84025: LIST
84026: LIST
84027: PUSH
84028: EMPTY
84029: LIST
84030: LIST
84031: PPUSH
84032: CALL_OW 69
84036: IN
84037: NOT
84038: OR
84039: IFFALSE 84043
// exit ;
84041: GO 84090
// for i = 1 to 3 do
84043: LD_ADDR_VAR 0 3
84047: PUSH
84048: DOUBLE
84049: LD_INT 1
84051: DEC
84052: ST_TO_ADDR
84053: LD_INT 3
84055: PUSH
84056: FOR_TO
84057: IFFALSE 84088
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
84059: LD_VAR 0 1
84063: PPUSH
84064: CALL_OW 250
84068: PPUSH
84069: LD_VAR 0 1
84073: PPUSH
84074: CALL_OW 251
84078: PPUSH
84079: LD_INT 1
84081: PPUSH
84082: CALL_OW 453
84086: GO 84056
84088: POP
84089: POP
// end ;
84090: LD_VAR 0 2
84094: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
84095: LD_INT 0
84097: PPUSH
84098: PPUSH
84099: PPUSH
84100: PPUSH
84101: PPUSH
84102: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
84103: LD_VAR 0 1
84107: NOT
84108: PUSH
84109: LD_VAR 0 2
84113: NOT
84114: OR
84115: PUSH
84116: LD_VAR 0 1
84120: PPUSH
84121: CALL_OW 314
84125: OR
84126: IFFALSE 84130
// exit ;
84128: GO 84571
// x := GetX ( enemy_unit ) ;
84130: LD_ADDR_VAR 0 7
84134: PUSH
84135: LD_VAR 0 2
84139: PPUSH
84140: CALL_OW 250
84144: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
84145: LD_ADDR_VAR 0 8
84149: PUSH
84150: LD_VAR 0 2
84154: PPUSH
84155: CALL_OW 251
84159: ST_TO_ADDR
// if not x or not y then
84160: LD_VAR 0 7
84164: NOT
84165: PUSH
84166: LD_VAR 0 8
84170: NOT
84171: OR
84172: IFFALSE 84176
// exit ;
84174: GO 84571
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
84176: LD_ADDR_VAR 0 6
84180: PUSH
84181: LD_VAR 0 7
84185: PPUSH
84186: LD_INT 0
84188: PPUSH
84189: LD_INT 4
84191: PPUSH
84192: CALL_OW 272
84196: PUSH
84197: LD_VAR 0 8
84201: PPUSH
84202: LD_INT 0
84204: PPUSH
84205: LD_INT 4
84207: PPUSH
84208: CALL_OW 273
84212: PUSH
84213: EMPTY
84214: LIST
84215: LIST
84216: PUSH
84217: LD_VAR 0 7
84221: PPUSH
84222: LD_INT 1
84224: PPUSH
84225: LD_INT 4
84227: PPUSH
84228: CALL_OW 272
84232: PUSH
84233: LD_VAR 0 8
84237: PPUSH
84238: LD_INT 1
84240: PPUSH
84241: LD_INT 4
84243: PPUSH
84244: CALL_OW 273
84248: PUSH
84249: EMPTY
84250: LIST
84251: LIST
84252: PUSH
84253: LD_VAR 0 7
84257: PPUSH
84258: LD_INT 2
84260: PPUSH
84261: LD_INT 4
84263: PPUSH
84264: CALL_OW 272
84268: PUSH
84269: LD_VAR 0 8
84273: PPUSH
84274: LD_INT 2
84276: PPUSH
84277: LD_INT 4
84279: PPUSH
84280: CALL_OW 273
84284: PUSH
84285: EMPTY
84286: LIST
84287: LIST
84288: PUSH
84289: LD_VAR 0 7
84293: PPUSH
84294: LD_INT 3
84296: PPUSH
84297: LD_INT 4
84299: PPUSH
84300: CALL_OW 272
84304: PUSH
84305: LD_VAR 0 8
84309: PPUSH
84310: LD_INT 3
84312: PPUSH
84313: LD_INT 4
84315: PPUSH
84316: CALL_OW 273
84320: PUSH
84321: EMPTY
84322: LIST
84323: LIST
84324: PUSH
84325: LD_VAR 0 7
84329: PPUSH
84330: LD_INT 4
84332: PPUSH
84333: LD_INT 4
84335: PPUSH
84336: CALL_OW 272
84340: PUSH
84341: LD_VAR 0 8
84345: PPUSH
84346: LD_INT 4
84348: PPUSH
84349: LD_INT 4
84351: PPUSH
84352: CALL_OW 273
84356: PUSH
84357: EMPTY
84358: LIST
84359: LIST
84360: PUSH
84361: LD_VAR 0 7
84365: PPUSH
84366: LD_INT 5
84368: PPUSH
84369: LD_INT 4
84371: PPUSH
84372: CALL_OW 272
84376: PUSH
84377: LD_VAR 0 8
84381: PPUSH
84382: LD_INT 5
84384: PPUSH
84385: LD_INT 4
84387: PPUSH
84388: CALL_OW 273
84392: PUSH
84393: EMPTY
84394: LIST
84395: LIST
84396: PUSH
84397: EMPTY
84398: LIST
84399: LIST
84400: LIST
84401: LIST
84402: LIST
84403: LIST
84404: ST_TO_ADDR
// for i = tmp downto 1 do
84405: LD_ADDR_VAR 0 4
84409: PUSH
84410: DOUBLE
84411: LD_VAR 0 6
84415: INC
84416: ST_TO_ADDR
84417: LD_INT 1
84419: PUSH
84420: FOR_DOWNTO
84421: IFFALSE 84522
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
84423: LD_VAR 0 6
84427: PUSH
84428: LD_VAR 0 4
84432: ARRAY
84433: PUSH
84434: LD_INT 1
84436: ARRAY
84437: PPUSH
84438: LD_VAR 0 6
84442: PUSH
84443: LD_VAR 0 4
84447: ARRAY
84448: PUSH
84449: LD_INT 2
84451: ARRAY
84452: PPUSH
84453: CALL_OW 488
84457: NOT
84458: PUSH
84459: LD_VAR 0 6
84463: PUSH
84464: LD_VAR 0 4
84468: ARRAY
84469: PUSH
84470: LD_INT 1
84472: ARRAY
84473: PPUSH
84474: LD_VAR 0 6
84478: PUSH
84479: LD_VAR 0 4
84483: ARRAY
84484: PUSH
84485: LD_INT 2
84487: ARRAY
84488: PPUSH
84489: CALL_OW 428
84493: PUSH
84494: LD_INT 0
84496: NONEQUAL
84497: OR
84498: IFFALSE 84520
// tmp := Delete ( tmp , i ) ;
84500: LD_ADDR_VAR 0 6
84504: PUSH
84505: LD_VAR 0 6
84509: PPUSH
84510: LD_VAR 0 4
84514: PPUSH
84515: CALL_OW 3
84519: ST_TO_ADDR
84520: GO 84420
84522: POP
84523: POP
// j := GetClosestHex ( unit , tmp ) ;
84524: LD_ADDR_VAR 0 5
84528: PUSH
84529: LD_VAR 0 1
84533: PPUSH
84534: LD_VAR 0 6
84538: PPUSH
84539: CALL 83824 0 2
84543: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
84544: LD_VAR 0 1
84548: PPUSH
84549: LD_VAR 0 5
84553: PUSH
84554: LD_INT 1
84556: ARRAY
84557: PPUSH
84558: LD_VAR 0 5
84562: PUSH
84563: LD_INT 2
84565: ARRAY
84566: PPUSH
84567: CALL_OW 111
// end ;
84571: LD_VAR 0 3
84575: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
84576: LD_INT 0
84578: PPUSH
84579: PPUSH
84580: PPUSH
// uc_side = 0 ;
84581: LD_ADDR_OWVAR 20
84585: PUSH
84586: LD_INT 0
84588: ST_TO_ADDR
// uc_nation = 0 ;
84589: LD_ADDR_OWVAR 21
84593: PUSH
84594: LD_INT 0
84596: ST_TO_ADDR
// InitHc_All ( ) ;
84597: CALL_OW 584
// InitVc ;
84601: CALL_OW 20
// if mastodonts then
84605: LD_VAR 0 6
84609: IFFALSE 84676
// for i = 1 to mastodonts do
84611: LD_ADDR_VAR 0 11
84615: PUSH
84616: DOUBLE
84617: LD_INT 1
84619: DEC
84620: ST_TO_ADDR
84621: LD_VAR 0 6
84625: PUSH
84626: FOR_TO
84627: IFFALSE 84674
// begin vc_chassis := 31 ;
84629: LD_ADDR_OWVAR 37
84633: PUSH
84634: LD_INT 31
84636: ST_TO_ADDR
// vc_control := control_rider ;
84637: LD_ADDR_OWVAR 38
84641: PUSH
84642: LD_INT 4
84644: ST_TO_ADDR
// animal := CreateVehicle ;
84645: LD_ADDR_VAR 0 12
84649: PUSH
84650: CALL_OW 45
84654: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84655: LD_VAR 0 12
84659: PPUSH
84660: LD_VAR 0 8
84664: PPUSH
84665: LD_INT 0
84667: PPUSH
84668: CALL 86864 0 3
// end ;
84672: GO 84626
84674: POP
84675: POP
// if horses then
84676: LD_VAR 0 5
84680: IFFALSE 84747
// for i = 1 to horses do
84682: LD_ADDR_VAR 0 11
84686: PUSH
84687: DOUBLE
84688: LD_INT 1
84690: DEC
84691: ST_TO_ADDR
84692: LD_VAR 0 5
84696: PUSH
84697: FOR_TO
84698: IFFALSE 84745
// begin hc_class := 21 ;
84700: LD_ADDR_OWVAR 28
84704: PUSH
84705: LD_INT 21
84707: ST_TO_ADDR
// hc_gallery :=  ;
84708: LD_ADDR_OWVAR 33
84712: PUSH
84713: LD_STRING 
84715: ST_TO_ADDR
// animal := CreateHuman ;
84716: LD_ADDR_VAR 0 12
84720: PUSH
84721: CALL_OW 44
84725: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84726: LD_VAR 0 12
84730: PPUSH
84731: LD_VAR 0 8
84735: PPUSH
84736: LD_INT 0
84738: PPUSH
84739: CALL 86864 0 3
// end ;
84743: GO 84697
84745: POP
84746: POP
// if birds then
84747: LD_VAR 0 1
84751: IFFALSE 84818
// for i = 1 to birds do
84753: LD_ADDR_VAR 0 11
84757: PUSH
84758: DOUBLE
84759: LD_INT 1
84761: DEC
84762: ST_TO_ADDR
84763: LD_VAR 0 1
84767: PUSH
84768: FOR_TO
84769: IFFALSE 84816
// begin hc_class = 18 ;
84771: LD_ADDR_OWVAR 28
84775: PUSH
84776: LD_INT 18
84778: ST_TO_ADDR
// hc_gallery =  ;
84779: LD_ADDR_OWVAR 33
84783: PUSH
84784: LD_STRING 
84786: ST_TO_ADDR
// animal := CreateHuman ;
84787: LD_ADDR_VAR 0 12
84791: PUSH
84792: CALL_OW 44
84796: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84797: LD_VAR 0 12
84801: PPUSH
84802: LD_VAR 0 8
84806: PPUSH
84807: LD_INT 0
84809: PPUSH
84810: CALL 86864 0 3
// end ;
84814: GO 84768
84816: POP
84817: POP
// if tigers then
84818: LD_VAR 0 2
84822: IFFALSE 84906
// for i = 1 to tigers do
84824: LD_ADDR_VAR 0 11
84828: PUSH
84829: DOUBLE
84830: LD_INT 1
84832: DEC
84833: ST_TO_ADDR
84834: LD_VAR 0 2
84838: PUSH
84839: FOR_TO
84840: IFFALSE 84904
// begin hc_class = class_tiger ;
84842: LD_ADDR_OWVAR 28
84846: PUSH
84847: LD_INT 14
84849: ST_TO_ADDR
// hc_gallery =  ;
84850: LD_ADDR_OWVAR 33
84854: PUSH
84855: LD_STRING 
84857: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
84858: LD_ADDR_OWVAR 35
84862: PUSH
84863: LD_INT 7
84865: NEG
84866: PPUSH
84867: LD_INT 7
84869: PPUSH
84870: CALL_OW 12
84874: ST_TO_ADDR
// animal := CreateHuman ;
84875: LD_ADDR_VAR 0 12
84879: PUSH
84880: CALL_OW 44
84884: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84885: LD_VAR 0 12
84889: PPUSH
84890: LD_VAR 0 8
84894: PPUSH
84895: LD_INT 0
84897: PPUSH
84898: CALL 86864 0 3
// end ;
84902: GO 84839
84904: POP
84905: POP
// if apemans then
84906: LD_VAR 0 3
84910: IFFALSE 85033
// for i = 1 to apemans do
84912: LD_ADDR_VAR 0 11
84916: PUSH
84917: DOUBLE
84918: LD_INT 1
84920: DEC
84921: ST_TO_ADDR
84922: LD_VAR 0 3
84926: PUSH
84927: FOR_TO
84928: IFFALSE 85031
// begin hc_class = class_apeman ;
84930: LD_ADDR_OWVAR 28
84934: PUSH
84935: LD_INT 12
84937: ST_TO_ADDR
// hc_gallery =  ;
84938: LD_ADDR_OWVAR 33
84942: PUSH
84943: LD_STRING 
84945: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
84946: LD_ADDR_OWVAR 35
84950: PUSH
84951: LD_INT 2
84953: NEG
84954: PPUSH
84955: LD_INT 2
84957: PPUSH
84958: CALL_OW 12
84962: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
84963: LD_ADDR_OWVAR 31
84967: PUSH
84968: LD_INT 1
84970: PPUSH
84971: LD_INT 3
84973: PPUSH
84974: CALL_OW 12
84978: PUSH
84979: LD_INT 1
84981: PPUSH
84982: LD_INT 3
84984: PPUSH
84985: CALL_OW 12
84989: PUSH
84990: LD_INT 0
84992: PUSH
84993: LD_INT 0
84995: PUSH
84996: EMPTY
84997: LIST
84998: LIST
84999: LIST
85000: LIST
85001: ST_TO_ADDR
// animal := CreateHuman ;
85002: LD_ADDR_VAR 0 12
85006: PUSH
85007: CALL_OW 44
85011: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85012: LD_VAR 0 12
85016: PPUSH
85017: LD_VAR 0 8
85021: PPUSH
85022: LD_INT 0
85024: PPUSH
85025: CALL 86864 0 3
// end ;
85029: GO 84927
85031: POP
85032: POP
// if enchidnas then
85033: LD_VAR 0 4
85037: IFFALSE 85104
// for i = 1 to enchidnas do
85039: LD_ADDR_VAR 0 11
85043: PUSH
85044: DOUBLE
85045: LD_INT 1
85047: DEC
85048: ST_TO_ADDR
85049: LD_VAR 0 4
85053: PUSH
85054: FOR_TO
85055: IFFALSE 85102
// begin hc_class = 13 ;
85057: LD_ADDR_OWVAR 28
85061: PUSH
85062: LD_INT 13
85064: ST_TO_ADDR
// hc_gallery =  ;
85065: LD_ADDR_OWVAR 33
85069: PUSH
85070: LD_STRING 
85072: ST_TO_ADDR
// animal := CreateHuman ;
85073: LD_ADDR_VAR 0 12
85077: PUSH
85078: CALL_OW 44
85082: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85083: LD_VAR 0 12
85087: PPUSH
85088: LD_VAR 0 8
85092: PPUSH
85093: LD_INT 0
85095: PPUSH
85096: CALL 86864 0 3
// end ;
85100: GO 85054
85102: POP
85103: POP
// if fishes then
85104: LD_VAR 0 7
85108: IFFALSE 85175
// for i = 1 to fishes do
85110: LD_ADDR_VAR 0 11
85114: PUSH
85115: DOUBLE
85116: LD_INT 1
85118: DEC
85119: ST_TO_ADDR
85120: LD_VAR 0 7
85124: PUSH
85125: FOR_TO
85126: IFFALSE 85173
// begin hc_class = 20 ;
85128: LD_ADDR_OWVAR 28
85132: PUSH
85133: LD_INT 20
85135: ST_TO_ADDR
// hc_gallery =  ;
85136: LD_ADDR_OWVAR 33
85140: PUSH
85141: LD_STRING 
85143: ST_TO_ADDR
// animal := CreateHuman ;
85144: LD_ADDR_VAR 0 12
85148: PUSH
85149: CALL_OW 44
85153: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
85154: LD_VAR 0 12
85158: PPUSH
85159: LD_VAR 0 9
85163: PPUSH
85164: LD_INT 0
85166: PPUSH
85167: CALL 86864 0 3
// end ;
85171: GO 85125
85173: POP
85174: POP
// end ;
85175: LD_VAR 0 10
85179: RET
// export function WantHeal ( sci , unit ) ; begin
85180: LD_INT 0
85182: PPUSH
// if GetTaskList ( sci ) > 0 then
85183: LD_VAR 0 1
85187: PPUSH
85188: CALL_OW 437
85192: PUSH
85193: LD_INT 0
85195: GREATER
85196: IFFALSE 85266
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
85198: LD_VAR 0 1
85202: PPUSH
85203: CALL_OW 437
85207: PUSH
85208: LD_INT 1
85210: ARRAY
85211: PUSH
85212: LD_INT 1
85214: ARRAY
85215: PUSH
85216: LD_STRING l
85218: EQUAL
85219: PUSH
85220: LD_VAR 0 1
85224: PPUSH
85225: CALL_OW 437
85229: PUSH
85230: LD_INT 1
85232: ARRAY
85233: PUSH
85234: LD_INT 4
85236: ARRAY
85237: PUSH
85238: LD_VAR 0 2
85242: EQUAL
85243: AND
85244: IFFALSE 85256
// result := true else
85246: LD_ADDR_VAR 0 3
85250: PUSH
85251: LD_INT 1
85253: ST_TO_ADDR
85254: GO 85264
// result := false ;
85256: LD_ADDR_VAR 0 3
85260: PUSH
85261: LD_INT 0
85263: ST_TO_ADDR
// end else
85264: GO 85274
// result := false ;
85266: LD_ADDR_VAR 0 3
85270: PUSH
85271: LD_INT 0
85273: ST_TO_ADDR
// end ;
85274: LD_VAR 0 3
85278: RET
// export function HealTarget ( sci ) ; begin
85279: LD_INT 0
85281: PPUSH
// if not sci then
85282: LD_VAR 0 1
85286: NOT
85287: IFFALSE 85291
// exit ;
85289: GO 85356
// result := 0 ;
85291: LD_ADDR_VAR 0 2
85295: PUSH
85296: LD_INT 0
85298: ST_TO_ADDR
// if GetTaskList ( sci ) then
85299: LD_VAR 0 1
85303: PPUSH
85304: CALL_OW 437
85308: IFFALSE 85356
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
85310: LD_VAR 0 1
85314: PPUSH
85315: CALL_OW 437
85319: PUSH
85320: LD_INT 1
85322: ARRAY
85323: PUSH
85324: LD_INT 1
85326: ARRAY
85327: PUSH
85328: LD_STRING l
85330: EQUAL
85331: IFFALSE 85356
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
85333: LD_ADDR_VAR 0 2
85337: PUSH
85338: LD_VAR 0 1
85342: PPUSH
85343: CALL_OW 437
85347: PUSH
85348: LD_INT 1
85350: ARRAY
85351: PUSH
85352: LD_INT 4
85354: ARRAY
85355: ST_TO_ADDR
// end ;
85356: LD_VAR 0 2
85360: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
85361: LD_INT 0
85363: PPUSH
85364: PPUSH
85365: PPUSH
85366: PPUSH
// if not base_units then
85367: LD_VAR 0 1
85371: NOT
85372: IFFALSE 85376
// exit ;
85374: GO 85463
// result := false ;
85376: LD_ADDR_VAR 0 2
85380: PUSH
85381: LD_INT 0
85383: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
85384: LD_ADDR_VAR 0 5
85388: PUSH
85389: LD_VAR 0 1
85393: PPUSH
85394: LD_INT 21
85396: PUSH
85397: LD_INT 3
85399: PUSH
85400: EMPTY
85401: LIST
85402: LIST
85403: PPUSH
85404: CALL_OW 72
85408: ST_TO_ADDR
// if not tmp then
85409: LD_VAR 0 5
85413: NOT
85414: IFFALSE 85418
// exit ;
85416: GO 85463
// for i in tmp do
85418: LD_ADDR_VAR 0 3
85422: PUSH
85423: LD_VAR 0 5
85427: PUSH
85428: FOR_IN
85429: IFFALSE 85461
// begin result := EnemyInRange ( i , 22 ) ;
85431: LD_ADDR_VAR 0 2
85435: PUSH
85436: LD_VAR 0 3
85440: PPUSH
85441: LD_INT 22
85443: PPUSH
85444: CALL 83699 0 2
85448: ST_TO_ADDR
// if result then
85449: LD_VAR 0 2
85453: IFFALSE 85459
// exit ;
85455: POP
85456: POP
85457: GO 85463
// end ;
85459: GO 85428
85461: POP
85462: POP
// end ;
85463: LD_VAR 0 2
85467: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
85468: LD_INT 0
85470: PPUSH
85471: PPUSH
// if not units then
85472: LD_VAR 0 1
85476: NOT
85477: IFFALSE 85481
// exit ;
85479: GO 85551
// result := [ ] ;
85481: LD_ADDR_VAR 0 3
85485: PUSH
85486: EMPTY
85487: ST_TO_ADDR
// for i in units do
85488: LD_ADDR_VAR 0 4
85492: PUSH
85493: LD_VAR 0 1
85497: PUSH
85498: FOR_IN
85499: IFFALSE 85549
// if GetTag ( i ) = tag then
85501: LD_VAR 0 4
85505: PPUSH
85506: CALL_OW 110
85510: PUSH
85511: LD_VAR 0 2
85515: EQUAL
85516: IFFALSE 85547
// result := Insert ( result , result + 1 , i ) ;
85518: LD_ADDR_VAR 0 3
85522: PUSH
85523: LD_VAR 0 3
85527: PPUSH
85528: LD_VAR 0 3
85532: PUSH
85533: LD_INT 1
85535: PLUS
85536: PPUSH
85537: LD_VAR 0 4
85541: PPUSH
85542: CALL_OW 2
85546: ST_TO_ADDR
85547: GO 85498
85549: POP
85550: POP
// end ;
85551: LD_VAR 0 3
85555: RET
// export function IsDriver ( un ) ; begin
85556: LD_INT 0
85558: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
85559: LD_ADDR_VAR 0 2
85563: PUSH
85564: LD_VAR 0 1
85568: PUSH
85569: LD_INT 55
85571: PUSH
85572: EMPTY
85573: LIST
85574: PPUSH
85575: CALL_OW 69
85579: IN
85580: ST_TO_ADDR
// end ;
85581: LD_VAR 0 2
85585: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
85586: LD_INT 0
85588: PPUSH
85589: PPUSH
// list := [ ] ;
85590: LD_ADDR_VAR 0 5
85594: PUSH
85595: EMPTY
85596: ST_TO_ADDR
// case d of 0 :
85597: LD_VAR 0 3
85601: PUSH
85602: LD_INT 0
85604: DOUBLE
85605: EQUAL
85606: IFTRUE 85610
85608: GO 85743
85610: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
85611: LD_ADDR_VAR 0 5
85615: PUSH
85616: LD_VAR 0 1
85620: PUSH
85621: LD_INT 4
85623: MINUS
85624: PUSH
85625: LD_VAR 0 2
85629: PUSH
85630: LD_INT 4
85632: MINUS
85633: PUSH
85634: LD_INT 2
85636: PUSH
85637: EMPTY
85638: LIST
85639: LIST
85640: LIST
85641: PUSH
85642: LD_VAR 0 1
85646: PUSH
85647: LD_INT 3
85649: MINUS
85650: PUSH
85651: LD_VAR 0 2
85655: PUSH
85656: LD_INT 1
85658: PUSH
85659: EMPTY
85660: LIST
85661: LIST
85662: LIST
85663: PUSH
85664: LD_VAR 0 1
85668: PUSH
85669: LD_INT 4
85671: PLUS
85672: PUSH
85673: LD_VAR 0 2
85677: PUSH
85678: LD_INT 4
85680: PUSH
85681: EMPTY
85682: LIST
85683: LIST
85684: LIST
85685: PUSH
85686: LD_VAR 0 1
85690: PUSH
85691: LD_INT 3
85693: PLUS
85694: PUSH
85695: LD_VAR 0 2
85699: PUSH
85700: LD_INT 3
85702: PLUS
85703: PUSH
85704: LD_INT 5
85706: PUSH
85707: EMPTY
85708: LIST
85709: LIST
85710: LIST
85711: PUSH
85712: LD_VAR 0 1
85716: PUSH
85717: LD_VAR 0 2
85721: PUSH
85722: LD_INT 4
85724: PLUS
85725: PUSH
85726: LD_INT 0
85728: PUSH
85729: EMPTY
85730: LIST
85731: LIST
85732: LIST
85733: PUSH
85734: EMPTY
85735: LIST
85736: LIST
85737: LIST
85738: LIST
85739: LIST
85740: ST_TO_ADDR
// end ; 1 :
85741: GO 86441
85743: LD_INT 1
85745: DOUBLE
85746: EQUAL
85747: IFTRUE 85751
85749: GO 85884
85751: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
85752: LD_ADDR_VAR 0 5
85756: PUSH
85757: LD_VAR 0 1
85761: PUSH
85762: LD_VAR 0 2
85766: PUSH
85767: LD_INT 4
85769: MINUS
85770: PUSH
85771: LD_INT 3
85773: PUSH
85774: EMPTY
85775: LIST
85776: LIST
85777: LIST
85778: PUSH
85779: LD_VAR 0 1
85783: PUSH
85784: LD_INT 3
85786: MINUS
85787: PUSH
85788: LD_VAR 0 2
85792: PUSH
85793: LD_INT 3
85795: MINUS
85796: PUSH
85797: LD_INT 2
85799: PUSH
85800: EMPTY
85801: LIST
85802: LIST
85803: LIST
85804: PUSH
85805: LD_VAR 0 1
85809: PUSH
85810: LD_INT 4
85812: MINUS
85813: PUSH
85814: LD_VAR 0 2
85818: PUSH
85819: LD_INT 1
85821: PUSH
85822: EMPTY
85823: LIST
85824: LIST
85825: LIST
85826: PUSH
85827: LD_VAR 0 1
85831: PUSH
85832: LD_VAR 0 2
85836: PUSH
85837: LD_INT 3
85839: PLUS
85840: PUSH
85841: LD_INT 0
85843: PUSH
85844: EMPTY
85845: LIST
85846: LIST
85847: LIST
85848: PUSH
85849: LD_VAR 0 1
85853: PUSH
85854: LD_INT 4
85856: PLUS
85857: PUSH
85858: LD_VAR 0 2
85862: PUSH
85863: LD_INT 4
85865: PLUS
85866: PUSH
85867: LD_INT 5
85869: PUSH
85870: EMPTY
85871: LIST
85872: LIST
85873: LIST
85874: PUSH
85875: EMPTY
85876: LIST
85877: LIST
85878: LIST
85879: LIST
85880: LIST
85881: ST_TO_ADDR
// end ; 2 :
85882: GO 86441
85884: LD_INT 2
85886: DOUBLE
85887: EQUAL
85888: IFTRUE 85892
85890: GO 86021
85892: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
85893: LD_ADDR_VAR 0 5
85897: PUSH
85898: LD_VAR 0 1
85902: PUSH
85903: LD_VAR 0 2
85907: PUSH
85908: LD_INT 3
85910: MINUS
85911: PUSH
85912: LD_INT 3
85914: PUSH
85915: EMPTY
85916: LIST
85917: LIST
85918: LIST
85919: PUSH
85920: LD_VAR 0 1
85924: PUSH
85925: LD_INT 4
85927: PLUS
85928: PUSH
85929: LD_VAR 0 2
85933: PUSH
85934: LD_INT 4
85936: PUSH
85937: EMPTY
85938: LIST
85939: LIST
85940: LIST
85941: PUSH
85942: LD_VAR 0 1
85946: PUSH
85947: LD_VAR 0 2
85951: PUSH
85952: LD_INT 4
85954: PLUS
85955: PUSH
85956: LD_INT 0
85958: PUSH
85959: EMPTY
85960: LIST
85961: LIST
85962: LIST
85963: PUSH
85964: LD_VAR 0 1
85968: PUSH
85969: LD_INT 3
85971: MINUS
85972: PUSH
85973: LD_VAR 0 2
85977: PUSH
85978: LD_INT 1
85980: PUSH
85981: EMPTY
85982: LIST
85983: LIST
85984: LIST
85985: PUSH
85986: LD_VAR 0 1
85990: PUSH
85991: LD_INT 4
85993: MINUS
85994: PUSH
85995: LD_VAR 0 2
85999: PUSH
86000: LD_INT 4
86002: MINUS
86003: PUSH
86004: LD_INT 2
86006: PUSH
86007: EMPTY
86008: LIST
86009: LIST
86010: LIST
86011: PUSH
86012: EMPTY
86013: LIST
86014: LIST
86015: LIST
86016: LIST
86017: LIST
86018: ST_TO_ADDR
// end ; 3 :
86019: GO 86441
86021: LD_INT 3
86023: DOUBLE
86024: EQUAL
86025: IFTRUE 86029
86027: GO 86162
86029: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
86030: LD_ADDR_VAR 0 5
86034: PUSH
86035: LD_VAR 0 1
86039: PUSH
86040: LD_INT 3
86042: PLUS
86043: PUSH
86044: LD_VAR 0 2
86048: PUSH
86049: LD_INT 4
86051: PUSH
86052: EMPTY
86053: LIST
86054: LIST
86055: LIST
86056: PUSH
86057: LD_VAR 0 1
86061: PUSH
86062: LD_INT 4
86064: PLUS
86065: PUSH
86066: LD_VAR 0 2
86070: PUSH
86071: LD_INT 4
86073: PLUS
86074: PUSH
86075: LD_INT 5
86077: PUSH
86078: EMPTY
86079: LIST
86080: LIST
86081: LIST
86082: PUSH
86083: LD_VAR 0 1
86087: PUSH
86088: LD_INT 4
86090: MINUS
86091: PUSH
86092: LD_VAR 0 2
86096: PUSH
86097: LD_INT 1
86099: PUSH
86100: EMPTY
86101: LIST
86102: LIST
86103: LIST
86104: PUSH
86105: LD_VAR 0 1
86109: PUSH
86110: LD_VAR 0 2
86114: PUSH
86115: LD_INT 4
86117: MINUS
86118: PUSH
86119: LD_INT 3
86121: PUSH
86122: EMPTY
86123: LIST
86124: LIST
86125: LIST
86126: PUSH
86127: LD_VAR 0 1
86131: PUSH
86132: LD_INT 3
86134: MINUS
86135: PUSH
86136: LD_VAR 0 2
86140: PUSH
86141: LD_INT 3
86143: MINUS
86144: PUSH
86145: LD_INT 2
86147: PUSH
86148: EMPTY
86149: LIST
86150: LIST
86151: LIST
86152: PUSH
86153: EMPTY
86154: LIST
86155: LIST
86156: LIST
86157: LIST
86158: LIST
86159: ST_TO_ADDR
// end ; 4 :
86160: GO 86441
86162: LD_INT 4
86164: DOUBLE
86165: EQUAL
86166: IFTRUE 86170
86168: GO 86303
86170: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
86171: LD_ADDR_VAR 0 5
86175: PUSH
86176: LD_VAR 0 1
86180: PUSH
86181: LD_VAR 0 2
86185: PUSH
86186: LD_INT 4
86188: PLUS
86189: PUSH
86190: LD_INT 0
86192: PUSH
86193: EMPTY
86194: LIST
86195: LIST
86196: LIST
86197: PUSH
86198: LD_VAR 0 1
86202: PUSH
86203: LD_INT 3
86205: PLUS
86206: PUSH
86207: LD_VAR 0 2
86211: PUSH
86212: LD_INT 3
86214: PLUS
86215: PUSH
86216: LD_INT 5
86218: PUSH
86219: EMPTY
86220: LIST
86221: LIST
86222: LIST
86223: PUSH
86224: LD_VAR 0 1
86228: PUSH
86229: LD_INT 4
86231: PLUS
86232: PUSH
86233: LD_VAR 0 2
86237: PUSH
86238: LD_INT 4
86240: PUSH
86241: EMPTY
86242: LIST
86243: LIST
86244: LIST
86245: PUSH
86246: LD_VAR 0 1
86250: PUSH
86251: LD_VAR 0 2
86255: PUSH
86256: LD_INT 3
86258: MINUS
86259: PUSH
86260: LD_INT 3
86262: PUSH
86263: EMPTY
86264: LIST
86265: LIST
86266: LIST
86267: PUSH
86268: LD_VAR 0 1
86272: PUSH
86273: LD_INT 4
86275: MINUS
86276: PUSH
86277: LD_VAR 0 2
86281: PUSH
86282: LD_INT 4
86284: MINUS
86285: PUSH
86286: LD_INT 2
86288: PUSH
86289: EMPTY
86290: LIST
86291: LIST
86292: LIST
86293: PUSH
86294: EMPTY
86295: LIST
86296: LIST
86297: LIST
86298: LIST
86299: LIST
86300: ST_TO_ADDR
// end ; 5 :
86301: GO 86441
86303: LD_INT 5
86305: DOUBLE
86306: EQUAL
86307: IFTRUE 86311
86309: GO 86440
86311: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
86312: LD_ADDR_VAR 0 5
86316: PUSH
86317: LD_VAR 0 1
86321: PUSH
86322: LD_INT 4
86324: MINUS
86325: PUSH
86326: LD_VAR 0 2
86330: PUSH
86331: LD_INT 1
86333: PUSH
86334: EMPTY
86335: LIST
86336: LIST
86337: LIST
86338: PUSH
86339: LD_VAR 0 1
86343: PUSH
86344: LD_VAR 0 2
86348: PUSH
86349: LD_INT 4
86351: MINUS
86352: PUSH
86353: LD_INT 3
86355: PUSH
86356: EMPTY
86357: LIST
86358: LIST
86359: LIST
86360: PUSH
86361: LD_VAR 0 1
86365: PUSH
86366: LD_INT 4
86368: PLUS
86369: PUSH
86370: LD_VAR 0 2
86374: PUSH
86375: LD_INT 4
86377: PLUS
86378: PUSH
86379: LD_INT 5
86381: PUSH
86382: EMPTY
86383: LIST
86384: LIST
86385: LIST
86386: PUSH
86387: LD_VAR 0 1
86391: PUSH
86392: LD_INT 3
86394: PLUS
86395: PUSH
86396: LD_VAR 0 2
86400: PUSH
86401: LD_INT 4
86403: PUSH
86404: EMPTY
86405: LIST
86406: LIST
86407: LIST
86408: PUSH
86409: LD_VAR 0 1
86413: PUSH
86414: LD_VAR 0 2
86418: PUSH
86419: LD_INT 3
86421: PLUS
86422: PUSH
86423: LD_INT 0
86425: PUSH
86426: EMPTY
86427: LIST
86428: LIST
86429: LIST
86430: PUSH
86431: EMPTY
86432: LIST
86433: LIST
86434: LIST
86435: LIST
86436: LIST
86437: ST_TO_ADDR
// end ; end ;
86438: GO 86441
86440: POP
// result := list ;
86441: LD_ADDR_VAR 0 4
86445: PUSH
86446: LD_VAR 0 5
86450: ST_TO_ADDR
// end ;
86451: LD_VAR 0 4
86455: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
86456: LD_INT 0
86458: PPUSH
86459: PPUSH
86460: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
86461: LD_VAR 0 1
86465: NOT
86466: PUSH
86467: LD_VAR 0 2
86471: PUSH
86472: LD_INT 1
86474: PUSH
86475: LD_INT 2
86477: PUSH
86478: LD_INT 3
86480: PUSH
86481: LD_INT 4
86483: PUSH
86484: EMPTY
86485: LIST
86486: LIST
86487: LIST
86488: LIST
86489: IN
86490: NOT
86491: OR
86492: IFFALSE 86496
// exit ;
86494: GO 86588
// tmp := [ ] ;
86496: LD_ADDR_VAR 0 5
86500: PUSH
86501: EMPTY
86502: ST_TO_ADDR
// for i in units do
86503: LD_ADDR_VAR 0 4
86507: PUSH
86508: LD_VAR 0 1
86512: PUSH
86513: FOR_IN
86514: IFFALSE 86557
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
86516: LD_ADDR_VAR 0 5
86520: PUSH
86521: LD_VAR 0 5
86525: PPUSH
86526: LD_VAR 0 5
86530: PUSH
86531: LD_INT 1
86533: PLUS
86534: PPUSH
86535: LD_VAR 0 4
86539: PPUSH
86540: LD_VAR 0 2
86544: PPUSH
86545: CALL_OW 259
86549: PPUSH
86550: CALL_OW 2
86554: ST_TO_ADDR
86555: GO 86513
86557: POP
86558: POP
// if not tmp then
86559: LD_VAR 0 5
86563: NOT
86564: IFFALSE 86568
// exit ;
86566: GO 86588
// result := SortListByListDesc ( units , tmp ) ;
86568: LD_ADDR_VAR 0 3
86572: PUSH
86573: LD_VAR 0 1
86577: PPUSH
86578: LD_VAR 0 5
86582: PPUSH
86583: CALL_OW 77
86587: ST_TO_ADDR
// end ;
86588: LD_VAR 0 3
86592: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
86593: LD_INT 0
86595: PPUSH
86596: PPUSH
86597: PPUSH
// result := false ;
86598: LD_ADDR_VAR 0 3
86602: PUSH
86603: LD_INT 0
86605: ST_TO_ADDR
// x := GetX ( building ) ;
86606: LD_ADDR_VAR 0 4
86610: PUSH
86611: LD_VAR 0 2
86615: PPUSH
86616: CALL_OW 250
86620: ST_TO_ADDR
// y := GetY ( building ) ;
86621: LD_ADDR_VAR 0 5
86625: PUSH
86626: LD_VAR 0 2
86630: PPUSH
86631: CALL_OW 251
86635: ST_TO_ADDR
// if not building or not x or not y then
86636: LD_VAR 0 2
86640: NOT
86641: PUSH
86642: LD_VAR 0 4
86646: NOT
86647: OR
86648: PUSH
86649: LD_VAR 0 5
86653: NOT
86654: OR
86655: IFFALSE 86659
// exit ;
86657: GO 86751
// if GetTaskList ( unit ) then
86659: LD_VAR 0 1
86663: PPUSH
86664: CALL_OW 437
86668: IFFALSE 86751
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
86670: LD_STRING e
86672: PUSH
86673: LD_VAR 0 1
86677: PPUSH
86678: CALL_OW 437
86682: PUSH
86683: LD_INT 1
86685: ARRAY
86686: PUSH
86687: LD_INT 1
86689: ARRAY
86690: EQUAL
86691: PUSH
86692: LD_VAR 0 4
86696: PUSH
86697: LD_VAR 0 1
86701: PPUSH
86702: CALL_OW 437
86706: PUSH
86707: LD_INT 1
86709: ARRAY
86710: PUSH
86711: LD_INT 2
86713: ARRAY
86714: EQUAL
86715: AND
86716: PUSH
86717: LD_VAR 0 5
86721: PUSH
86722: LD_VAR 0 1
86726: PPUSH
86727: CALL_OW 437
86731: PUSH
86732: LD_INT 1
86734: ARRAY
86735: PUSH
86736: LD_INT 3
86738: ARRAY
86739: EQUAL
86740: AND
86741: IFFALSE 86751
// result := true end ;
86743: LD_ADDR_VAR 0 3
86747: PUSH
86748: LD_INT 1
86750: ST_TO_ADDR
// end ;
86751: LD_VAR 0 3
86755: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
86756: LD_INT 0
86758: PPUSH
// result := false ;
86759: LD_ADDR_VAR 0 4
86763: PUSH
86764: LD_INT 0
86766: ST_TO_ADDR
// if GetTaskList ( unit ) then
86767: LD_VAR 0 1
86771: PPUSH
86772: CALL_OW 437
86776: IFFALSE 86859
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
86778: LD_STRING M
86780: PUSH
86781: LD_VAR 0 1
86785: PPUSH
86786: CALL_OW 437
86790: PUSH
86791: LD_INT 1
86793: ARRAY
86794: PUSH
86795: LD_INT 1
86797: ARRAY
86798: EQUAL
86799: PUSH
86800: LD_VAR 0 2
86804: PUSH
86805: LD_VAR 0 1
86809: PPUSH
86810: CALL_OW 437
86814: PUSH
86815: LD_INT 1
86817: ARRAY
86818: PUSH
86819: LD_INT 2
86821: ARRAY
86822: EQUAL
86823: AND
86824: PUSH
86825: LD_VAR 0 3
86829: PUSH
86830: LD_VAR 0 1
86834: PPUSH
86835: CALL_OW 437
86839: PUSH
86840: LD_INT 1
86842: ARRAY
86843: PUSH
86844: LD_INT 3
86846: ARRAY
86847: EQUAL
86848: AND
86849: IFFALSE 86859
// result := true ;
86851: LD_ADDR_VAR 0 4
86855: PUSH
86856: LD_INT 1
86858: ST_TO_ADDR
// end ; end ;
86859: LD_VAR 0 4
86863: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
86864: LD_INT 0
86866: PPUSH
86867: PPUSH
86868: PPUSH
86869: PPUSH
// if not unit or not area then
86870: LD_VAR 0 1
86874: NOT
86875: PUSH
86876: LD_VAR 0 2
86880: NOT
86881: OR
86882: IFFALSE 86886
// exit ;
86884: GO 87050
// tmp := AreaToList ( area , i ) ;
86886: LD_ADDR_VAR 0 6
86890: PUSH
86891: LD_VAR 0 2
86895: PPUSH
86896: LD_VAR 0 5
86900: PPUSH
86901: CALL_OW 517
86905: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
86906: LD_ADDR_VAR 0 5
86910: PUSH
86911: DOUBLE
86912: LD_INT 1
86914: DEC
86915: ST_TO_ADDR
86916: LD_VAR 0 6
86920: PUSH
86921: LD_INT 1
86923: ARRAY
86924: PUSH
86925: FOR_TO
86926: IFFALSE 87048
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
86928: LD_ADDR_VAR 0 7
86932: PUSH
86933: LD_VAR 0 6
86937: PUSH
86938: LD_INT 1
86940: ARRAY
86941: PUSH
86942: LD_VAR 0 5
86946: ARRAY
86947: PUSH
86948: LD_VAR 0 6
86952: PUSH
86953: LD_INT 2
86955: ARRAY
86956: PUSH
86957: LD_VAR 0 5
86961: ARRAY
86962: PUSH
86963: EMPTY
86964: LIST
86965: LIST
86966: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
86967: LD_VAR 0 7
86971: PUSH
86972: LD_INT 1
86974: ARRAY
86975: PPUSH
86976: LD_VAR 0 7
86980: PUSH
86981: LD_INT 2
86983: ARRAY
86984: PPUSH
86985: CALL_OW 428
86989: PUSH
86990: LD_INT 0
86992: EQUAL
86993: IFFALSE 87046
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
86995: LD_VAR 0 1
86999: PPUSH
87000: LD_VAR 0 7
87004: PUSH
87005: LD_INT 1
87007: ARRAY
87008: PPUSH
87009: LD_VAR 0 7
87013: PUSH
87014: LD_INT 2
87016: ARRAY
87017: PPUSH
87018: LD_VAR 0 3
87022: PPUSH
87023: CALL_OW 48
// result := IsPlaced ( unit ) ;
87027: LD_ADDR_VAR 0 4
87031: PUSH
87032: LD_VAR 0 1
87036: PPUSH
87037: CALL_OW 305
87041: ST_TO_ADDR
// exit ;
87042: POP
87043: POP
87044: GO 87050
// end ; end ;
87046: GO 86925
87048: POP
87049: POP
// end ;
87050: LD_VAR 0 4
87054: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
87055: LD_INT 0
87057: PPUSH
87058: PPUSH
87059: PPUSH
// if not side or side > 8 then
87060: LD_VAR 0 1
87064: NOT
87065: PUSH
87066: LD_VAR 0 1
87070: PUSH
87071: LD_INT 8
87073: GREATER
87074: OR
87075: IFFALSE 87079
// exit ;
87077: GO 87266
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
87079: LD_ADDR_VAR 0 4
87083: PUSH
87084: LD_INT 22
87086: PUSH
87087: LD_VAR 0 1
87091: PUSH
87092: EMPTY
87093: LIST
87094: LIST
87095: PUSH
87096: LD_INT 21
87098: PUSH
87099: LD_INT 3
87101: PUSH
87102: EMPTY
87103: LIST
87104: LIST
87105: PUSH
87106: EMPTY
87107: LIST
87108: LIST
87109: PPUSH
87110: CALL_OW 69
87114: ST_TO_ADDR
// if not tmp then
87115: LD_VAR 0 4
87119: NOT
87120: IFFALSE 87124
// exit ;
87122: GO 87266
// enable_addtolog := true ;
87124: LD_ADDR_OWVAR 81
87128: PUSH
87129: LD_INT 1
87131: ST_TO_ADDR
// AddToLog ( [ ) ;
87132: LD_STRING [
87134: PPUSH
87135: CALL_OW 561
// for i in tmp do
87139: LD_ADDR_VAR 0 3
87143: PUSH
87144: LD_VAR 0 4
87148: PUSH
87149: FOR_IN
87150: IFFALSE 87257
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
87152: LD_STRING [
87154: PUSH
87155: LD_VAR 0 3
87159: PPUSH
87160: CALL_OW 266
87164: STR
87165: PUSH
87166: LD_STRING , 
87168: STR
87169: PUSH
87170: LD_VAR 0 3
87174: PPUSH
87175: CALL_OW 250
87179: STR
87180: PUSH
87181: LD_STRING , 
87183: STR
87184: PUSH
87185: LD_VAR 0 3
87189: PPUSH
87190: CALL_OW 251
87194: STR
87195: PUSH
87196: LD_STRING , 
87198: STR
87199: PUSH
87200: LD_VAR 0 3
87204: PPUSH
87205: CALL_OW 254
87209: STR
87210: PUSH
87211: LD_STRING , 
87213: STR
87214: PUSH
87215: LD_VAR 0 3
87219: PPUSH
87220: LD_INT 1
87222: PPUSH
87223: CALL_OW 268
87227: STR
87228: PUSH
87229: LD_STRING , 
87231: STR
87232: PUSH
87233: LD_VAR 0 3
87237: PPUSH
87238: LD_INT 2
87240: PPUSH
87241: CALL_OW 268
87245: STR
87246: PUSH
87247: LD_STRING ],
87249: STR
87250: PPUSH
87251: CALL_OW 561
// end ;
87255: GO 87149
87257: POP
87258: POP
// AddToLog ( ]; ) ;
87259: LD_STRING ];
87261: PPUSH
87262: CALL_OW 561
// end ;
87266: LD_VAR 0 2
87270: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
87271: LD_INT 0
87273: PPUSH
87274: PPUSH
87275: PPUSH
87276: PPUSH
87277: PPUSH
// if not area or not rate or not max then
87278: LD_VAR 0 1
87282: NOT
87283: PUSH
87284: LD_VAR 0 2
87288: NOT
87289: OR
87290: PUSH
87291: LD_VAR 0 4
87295: NOT
87296: OR
87297: IFFALSE 87301
// exit ;
87299: GO 87493
// while 1 do
87301: LD_INT 1
87303: IFFALSE 87493
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
87305: LD_ADDR_VAR 0 9
87309: PUSH
87310: LD_VAR 0 1
87314: PPUSH
87315: LD_INT 1
87317: PPUSH
87318: CALL_OW 287
87322: PUSH
87323: LD_INT 10
87325: MUL
87326: ST_TO_ADDR
// r := rate / 10 ;
87327: LD_ADDR_VAR 0 7
87331: PUSH
87332: LD_VAR 0 2
87336: PUSH
87337: LD_INT 10
87339: DIVREAL
87340: ST_TO_ADDR
// time := 1 1$00 ;
87341: LD_ADDR_VAR 0 8
87345: PUSH
87346: LD_INT 2100
87348: ST_TO_ADDR
// if amount < min then
87349: LD_VAR 0 9
87353: PUSH
87354: LD_VAR 0 3
87358: LESS
87359: IFFALSE 87377
// r := r * 2 else
87361: LD_ADDR_VAR 0 7
87365: PUSH
87366: LD_VAR 0 7
87370: PUSH
87371: LD_INT 2
87373: MUL
87374: ST_TO_ADDR
87375: GO 87403
// if amount > max then
87377: LD_VAR 0 9
87381: PUSH
87382: LD_VAR 0 4
87386: GREATER
87387: IFFALSE 87403
// r := r / 2 ;
87389: LD_ADDR_VAR 0 7
87393: PUSH
87394: LD_VAR 0 7
87398: PUSH
87399: LD_INT 2
87401: DIVREAL
87402: ST_TO_ADDR
// time := time / r ;
87403: LD_ADDR_VAR 0 8
87407: PUSH
87408: LD_VAR 0 8
87412: PUSH
87413: LD_VAR 0 7
87417: DIVREAL
87418: ST_TO_ADDR
// if time < 0 then
87419: LD_VAR 0 8
87423: PUSH
87424: LD_INT 0
87426: LESS
87427: IFFALSE 87444
// time := time * - 1 ;
87429: LD_ADDR_VAR 0 8
87433: PUSH
87434: LD_VAR 0 8
87438: PUSH
87439: LD_INT 1
87441: NEG
87442: MUL
87443: ST_TO_ADDR
// wait ( time ) ;
87444: LD_VAR 0 8
87448: PPUSH
87449: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
87453: LD_INT 35
87455: PPUSH
87456: LD_INT 875
87458: PPUSH
87459: CALL_OW 12
87463: PPUSH
87464: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
87468: LD_INT 1
87470: PPUSH
87471: LD_INT 5
87473: PPUSH
87474: CALL_OW 12
87478: PPUSH
87479: LD_VAR 0 1
87483: PPUSH
87484: LD_INT 1
87486: PPUSH
87487: CALL_OW 55
// end ;
87491: GO 87301
// end ;
87493: LD_VAR 0 5
87497: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
87498: LD_INT 0
87500: PPUSH
87501: PPUSH
87502: PPUSH
87503: PPUSH
87504: PPUSH
87505: PPUSH
87506: PPUSH
87507: PPUSH
// if not turrets or not factories then
87508: LD_VAR 0 1
87512: NOT
87513: PUSH
87514: LD_VAR 0 2
87518: NOT
87519: OR
87520: IFFALSE 87524
// exit ;
87522: GO 87831
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
87524: LD_ADDR_VAR 0 10
87528: PUSH
87529: LD_INT 5
87531: PUSH
87532: LD_INT 6
87534: PUSH
87535: EMPTY
87536: LIST
87537: LIST
87538: PUSH
87539: LD_INT 2
87541: PUSH
87542: LD_INT 4
87544: PUSH
87545: EMPTY
87546: LIST
87547: LIST
87548: PUSH
87549: LD_INT 3
87551: PUSH
87552: LD_INT 5
87554: PUSH
87555: EMPTY
87556: LIST
87557: LIST
87558: PUSH
87559: EMPTY
87560: LIST
87561: LIST
87562: LIST
87563: PUSH
87564: LD_INT 24
87566: PUSH
87567: LD_INT 25
87569: PUSH
87570: EMPTY
87571: LIST
87572: LIST
87573: PUSH
87574: LD_INT 23
87576: PUSH
87577: LD_INT 27
87579: PUSH
87580: EMPTY
87581: LIST
87582: LIST
87583: PUSH
87584: EMPTY
87585: LIST
87586: LIST
87587: PUSH
87588: LD_INT 42
87590: PUSH
87591: LD_INT 43
87593: PUSH
87594: EMPTY
87595: LIST
87596: LIST
87597: PUSH
87598: LD_INT 44
87600: PUSH
87601: LD_INT 46
87603: PUSH
87604: EMPTY
87605: LIST
87606: LIST
87607: PUSH
87608: LD_INT 45
87610: PUSH
87611: LD_INT 47
87613: PUSH
87614: EMPTY
87615: LIST
87616: LIST
87617: PUSH
87618: EMPTY
87619: LIST
87620: LIST
87621: LIST
87622: PUSH
87623: EMPTY
87624: LIST
87625: LIST
87626: LIST
87627: ST_TO_ADDR
// result := [ ] ;
87628: LD_ADDR_VAR 0 3
87632: PUSH
87633: EMPTY
87634: ST_TO_ADDR
// for i in turrets do
87635: LD_ADDR_VAR 0 4
87639: PUSH
87640: LD_VAR 0 1
87644: PUSH
87645: FOR_IN
87646: IFFALSE 87829
// begin nat := GetNation ( i ) ;
87648: LD_ADDR_VAR 0 7
87652: PUSH
87653: LD_VAR 0 4
87657: PPUSH
87658: CALL_OW 248
87662: ST_TO_ADDR
// weapon := 0 ;
87663: LD_ADDR_VAR 0 8
87667: PUSH
87668: LD_INT 0
87670: ST_TO_ADDR
// if not nat then
87671: LD_VAR 0 7
87675: NOT
87676: IFFALSE 87680
// continue ;
87678: GO 87645
// for j in list [ nat ] do
87680: LD_ADDR_VAR 0 5
87684: PUSH
87685: LD_VAR 0 10
87689: PUSH
87690: LD_VAR 0 7
87694: ARRAY
87695: PUSH
87696: FOR_IN
87697: IFFALSE 87738
// if GetBWeapon ( i ) = j [ 1 ] then
87699: LD_VAR 0 4
87703: PPUSH
87704: CALL_OW 269
87708: PUSH
87709: LD_VAR 0 5
87713: PUSH
87714: LD_INT 1
87716: ARRAY
87717: EQUAL
87718: IFFALSE 87736
// begin weapon := j [ 2 ] ;
87720: LD_ADDR_VAR 0 8
87724: PUSH
87725: LD_VAR 0 5
87729: PUSH
87730: LD_INT 2
87732: ARRAY
87733: ST_TO_ADDR
// break ;
87734: GO 87738
// end ;
87736: GO 87696
87738: POP
87739: POP
// if not weapon then
87740: LD_VAR 0 8
87744: NOT
87745: IFFALSE 87749
// continue ;
87747: GO 87645
// for k in factories do
87749: LD_ADDR_VAR 0 6
87753: PUSH
87754: LD_VAR 0 2
87758: PUSH
87759: FOR_IN
87760: IFFALSE 87825
// begin weapons := AvailableWeaponList ( k ) ;
87762: LD_ADDR_VAR 0 9
87766: PUSH
87767: LD_VAR 0 6
87771: PPUSH
87772: CALL_OW 478
87776: ST_TO_ADDR
// if not weapons then
87777: LD_VAR 0 9
87781: NOT
87782: IFFALSE 87786
// continue ;
87784: GO 87759
// if weapon in weapons then
87786: LD_VAR 0 8
87790: PUSH
87791: LD_VAR 0 9
87795: IN
87796: IFFALSE 87823
// begin result := [ i , weapon ] ;
87798: LD_ADDR_VAR 0 3
87802: PUSH
87803: LD_VAR 0 4
87807: PUSH
87808: LD_VAR 0 8
87812: PUSH
87813: EMPTY
87814: LIST
87815: LIST
87816: ST_TO_ADDR
// exit ;
87817: POP
87818: POP
87819: POP
87820: POP
87821: GO 87831
// end ; end ;
87823: GO 87759
87825: POP
87826: POP
// end ;
87827: GO 87645
87829: POP
87830: POP
// end ;
87831: LD_VAR 0 3
87835: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
87836: LD_INT 0
87838: PPUSH
// if not side or side > 8 then
87839: LD_VAR 0 3
87843: NOT
87844: PUSH
87845: LD_VAR 0 3
87849: PUSH
87850: LD_INT 8
87852: GREATER
87853: OR
87854: IFFALSE 87858
// exit ;
87856: GO 87917
// if not range then
87858: LD_VAR 0 4
87862: NOT
87863: IFFALSE 87874
// range := - 12 ;
87865: LD_ADDR_VAR 0 4
87869: PUSH
87870: LD_INT 12
87872: NEG
87873: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
87874: LD_VAR 0 1
87878: PPUSH
87879: LD_VAR 0 2
87883: PPUSH
87884: LD_VAR 0 3
87888: PPUSH
87889: LD_VAR 0 4
87893: PPUSH
87894: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
87898: LD_VAR 0 1
87902: PPUSH
87903: LD_VAR 0 2
87907: PPUSH
87908: LD_VAR 0 3
87912: PPUSH
87913: CALL_OW 331
// end ;
87917: LD_VAR 0 5
87921: RET
// export function Video ( mode ) ; begin
87922: LD_INT 0
87924: PPUSH
// ingame_video = mode ;
87925: LD_ADDR_OWVAR 52
87929: PUSH
87930: LD_VAR 0 1
87934: ST_TO_ADDR
// interface_hidden = mode ;
87935: LD_ADDR_OWVAR 54
87939: PUSH
87940: LD_VAR 0 1
87944: ST_TO_ADDR
// end ;
87945: LD_VAR 0 2
87949: RET
// export function Join ( array , element ) ; begin
87950: LD_INT 0
87952: PPUSH
// result := Replace ( array , array + 1 , element ) ;
87953: LD_ADDR_VAR 0 3
87957: PUSH
87958: LD_VAR 0 1
87962: PPUSH
87963: LD_VAR 0 1
87967: PUSH
87968: LD_INT 1
87970: PLUS
87971: PPUSH
87972: LD_VAR 0 2
87976: PPUSH
87977: CALL_OW 1
87981: ST_TO_ADDR
// end ;
87982: LD_VAR 0 3
87986: RET
// export function JoinUnion ( array , element ) ; begin
87987: LD_INT 0
87989: PPUSH
// result := array union element ;
87990: LD_ADDR_VAR 0 3
87994: PUSH
87995: LD_VAR 0 1
87999: PUSH
88000: LD_VAR 0 2
88004: UNION
88005: ST_TO_ADDR
// end ;
88006: LD_VAR 0 3
88010: RET
// export function GetBehemoths ( side ) ; begin
88011: LD_INT 0
88013: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
88014: LD_ADDR_VAR 0 2
88018: PUSH
88019: LD_INT 22
88021: PUSH
88022: LD_VAR 0 1
88026: PUSH
88027: EMPTY
88028: LIST
88029: LIST
88030: PUSH
88031: LD_INT 31
88033: PUSH
88034: LD_INT 25
88036: PUSH
88037: EMPTY
88038: LIST
88039: LIST
88040: PUSH
88041: EMPTY
88042: LIST
88043: LIST
88044: PPUSH
88045: CALL_OW 69
88049: ST_TO_ADDR
// end ;
88050: LD_VAR 0 2
88054: RET
// export function Shuffle ( array ) ; var i , index ; begin
88055: LD_INT 0
88057: PPUSH
88058: PPUSH
88059: PPUSH
// result := [ ] ;
88060: LD_ADDR_VAR 0 2
88064: PUSH
88065: EMPTY
88066: ST_TO_ADDR
// if not array then
88067: LD_VAR 0 1
88071: NOT
88072: IFFALSE 88076
// exit ;
88074: GO 88175
// Randomize ;
88076: CALL_OW 10
// for i = array downto 1 do
88080: LD_ADDR_VAR 0 3
88084: PUSH
88085: DOUBLE
88086: LD_VAR 0 1
88090: INC
88091: ST_TO_ADDR
88092: LD_INT 1
88094: PUSH
88095: FOR_DOWNTO
88096: IFFALSE 88173
// begin index := rand ( 1 , array ) ;
88098: LD_ADDR_VAR 0 4
88102: PUSH
88103: LD_INT 1
88105: PPUSH
88106: LD_VAR 0 1
88110: PPUSH
88111: CALL_OW 12
88115: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
88116: LD_ADDR_VAR 0 2
88120: PUSH
88121: LD_VAR 0 2
88125: PPUSH
88126: LD_VAR 0 2
88130: PUSH
88131: LD_INT 1
88133: PLUS
88134: PPUSH
88135: LD_VAR 0 1
88139: PUSH
88140: LD_VAR 0 4
88144: ARRAY
88145: PPUSH
88146: CALL_OW 2
88150: ST_TO_ADDR
// array := Delete ( array , index ) ;
88151: LD_ADDR_VAR 0 1
88155: PUSH
88156: LD_VAR 0 1
88160: PPUSH
88161: LD_VAR 0 4
88165: PPUSH
88166: CALL_OW 3
88170: ST_TO_ADDR
// end ;
88171: GO 88095
88173: POP
88174: POP
// end ;
88175: LD_VAR 0 2
88179: RET
// export function GetBaseMaterials ( base ) ; begin
88180: LD_INT 0
88182: PPUSH
// result := [ 0 , 0 , 0 ] ;
88183: LD_ADDR_VAR 0 2
88187: PUSH
88188: LD_INT 0
88190: PUSH
88191: LD_INT 0
88193: PUSH
88194: LD_INT 0
88196: PUSH
88197: EMPTY
88198: LIST
88199: LIST
88200: LIST
88201: ST_TO_ADDR
// if not base then
88202: LD_VAR 0 1
88206: NOT
88207: IFFALSE 88211
// exit ;
88209: GO 88260
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
88211: LD_ADDR_VAR 0 2
88215: PUSH
88216: LD_VAR 0 1
88220: PPUSH
88221: LD_INT 1
88223: PPUSH
88224: CALL_OW 275
88228: PUSH
88229: LD_VAR 0 1
88233: PPUSH
88234: LD_INT 2
88236: PPUSH
88237: CALL_OW 275
88241: PUSH
88242: LD_VAR 0 1
88246: PPUSH
88247: LD_INT 3
88249: PPUSH
88250: CALL_OW 275
88254: PUSH
88255: EMPTY
88256: LIST
88257: LIST
88258: LIST
88259: ST_TO_ADDR
// end ;
88260: LD_VAR 0 2
88264: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
88265: LD_INT 0
88267: PPUSH
88268: PPUSH
// result := array ;
88269: LD_ADDR_VAR 0 3
88273: PUSH
88274: LD_VAR 0 1
88278: ST_TO_ADDR
// if size > 0 then
88279: LD_VAR 0 2
88283: PUSH
88284: LD_INT 0
88286: GREATER
88287: IFFALSE 88333
// for i := array downto size do
88289: LD_ADDR_VAR 0 4
88293: PUSH
88294: DOUBLE
88295: LD_VAR 0 1
88299: INC
88300: ST_TO_ADDR
88301: LD_VAR 0 2
88305: PUSH
88306: FOR_DOWNTO
88307: IFFALSE 88331
// result := Delete ( result , result ) ;
88309: LD_ADDR_VAR 0 3
88313: PUSH
88314: LD_VAR 0 3
88318: PPUSH
88319: LD_VAR 0 3
88323: PPUSH
88324: CALL_OW 3
88328: ST_TO_ADDR
88329: GO 88306
88331: POP
88332: POP
// end ;
88333: LD_VAR 0 3
88337: RET
// export function ComExit ( unit ) ; var tmp ; begin
88338: LD_INT 0
88340: PPUSH
88341: PPUSH
// if not IsInUnit ( unit ) then
88342: LD_VAR 0 1
88346: PPUSH
88347: CALL_OW 310
88351: NOT
88352: IFFALSE 88356
// exit ;
88354: GO 88416
// tmp := IsInUnit ( unit ) ;
88356: LD_ADDR_VAR 0 3
88360: PUSH
88361: LD_VAR 0 1
88365: PPUSH
88366: CALL_OW 310
88370: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
88371: LD_VAR 0 3
88375: PPUSH
88376: CALL_OW 247
88380: PUSH
88381: LD_INT 2
88383: EQUAL
88384: IFFALSE 88397
// ComExitVehicle ( unit ) else
88386: LD_VAR 0 1
88390: PPUSH
88391: CALL_OW 121
88395: GO 88406
// ComExitBuilding ( unit ) ;
88397: LD_VAR 0 1
88401: PPUSH
88402: CALL_OW 122
// result := tmp ;
88406: LD_ADDR_VAR 0 2
88410: PUSH
88411: LD_VAR 0 3
88415: ST_TO_ADDR
// end ;
88416: LD_VAR 0 2
88420: RET
// export function ComExitAll ( units ) ; var i ; begin
88421: LD_INT 0
88423: PPUSH
88424: PPUSH
// if not units then
88425: LD_VAR 0 1
88429: NOT
88430: IFFALSE 88434
// exit ;
88432: GO 88460
// for i in units do
88434: LD_ADDR_VAR 0 3
88438: PUSH
88439: LD_VAR 0 1
88443: PUSH
88444: FOR_IN
88445: IFFALSE 88458
// ComExit ( i ) ;
88447: LD_VAR 0 3
88451: PPUSH
88452: CALL 88338 0 1
88456: GO 88444
88458: POP
88459: POP
// end ;
88460: LD_VAR 0 2
88464: RET
// export function ResetHc ; begin
88465: LD_INT 0
88467: PPUSH
// InitHc ;
88468: CALL_OW 19
// hc_importance := 0 ;
88472: LD_ADDR_OWVAR 32
88476: PUSH
88477: LD_INT 0
88479: ST_TO_ADDR
// end ;
88480: LD_VAR 0 1
88484: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
88485: LD_INT 0
88487: PPUSH
88488: PPUSH
88489: PPUSH
// _x := ( x1 + x2 ) div 2 ;
88490: LD_ADDR_VAR 0 6
88494: PUSH
88495: LD_VAR 0 1
88499: PUSH
88500: LD_VAR 0 3
88504: PLUS
88505: PUSH
88506: LD_INT 2
88508: DIV
88509: ST_TO_ADDR
// if _x < 0 then
88510: LD_VAR 0 6
88514: PUSH
88515: LD_INT 0
88517: LESS
88518: IFFALSE 88535
// _x := _x * - 1 ;
88520: LD_ADDR_VAR 0 6
88524: PUSH
88525: LD_VAR 0 6
88529: PUSH
88530: LD_INT 1
88532: NEG
88533: MUL
88534: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
88535: LD_ADDR_VAR 0 7
88539: PUSH
88540: LD_VAR 0 2
88544: PUSH
88545: LD_VAR 0 4
88549: PLUS
88550: PUSH
88551: LD_INT 2
88553: DIV
88554: ST_TO_ADDR
// if _y < 0 then
88555: LD_VAR 0 7
88559: PUSH
88560: LD_INT 0
88562: LESS
88563: IFFALSE 88580
// _y := _y * - 1 ;
88565: LD_ADDR_VAR 0 7
88569: PUSH
88570: LD_VAR 0 7
88574: PUSH
88575: LD_INT 1
88577: NEG
88578: MUL
88579: ST_TO_ADDR
// result := [ _x , _y ] ;
88580: LD_ADDR_VAR 0 5
88584: PUSH
88585: LD_VAR 0 6
88589: PUSH
88590: LD_VAR 0 7
88594: PUSH
88595: EMPTY
88596: LIST
88597: LIST
88598: ST_TO_ADDR
// end ;
88599: LD_VAR 0 5
88603: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
88604: LD_INT 0
88606: PPUSH
88607: PPUSH
88608: PPUSH
88609: PPUSH
// task := GetTaskList ( unit ) ;
88610: LD_ADDR_VAR 0 7
88614: PUSH
88615: LD_VAR 0 1
88619: PPUSH
88620: CALL_OW 437
88624: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
88625: LD_VAR 0 7
88629: NOT
88630: PUSH
88631: LD_VAR 0 1
88635: PPUSH
88636: LD_VAR 0 2
88640: PPUSH
88641: CALL_OW 308
88645: NOT
88646: AND
88647: IFFALSE 88651
// exit ;
88649: GO 88769
// if IsInArea ( unit , area ) then
88651: LD_VAR 0 1
88655: PPUSH
88656: LD_VAR 0 2
88660: PPUSH
88661: CALL_OW 308
88665: IFFALSE 88683
// begin ComMoveToArea ( unit , goAway ) ;
88667: LD_VAR 0 1
88671: PPUSH
88672: LD_VAR 0 3
88676: PPUSH
88677: CALL_OW 113
// exit ;
88681: GO 88769
// end ; if task [ 1 ] [ 1 ] <> M then
88683: LD_VAR 0 7
88687: PUSH
88688: LD_INT 1
88690: ARRAY
88691: PUSH
88692: LD_INT 1
88694: ARRAY
88695: PUSH
88696: LD_STRING M
88698: NONEQUAL
88699: IFFALSE 88703
// exit ;
88701: GO 88769
// x := task [ 1 ] [ 2 ] ;
88703: LD_ADDR_VAR 0 5
88707: PUSH
88708: LD_VAR 0 7
88712: PUSH
88713: LD_INT 1
88715: ARRAY
88716: PUSH
88717: LD_INT 2
88719: ARRAY
88720: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
88721: LD_ADDR_VAR 0 6
88725: PUSH
88726: LD_VAR 0 7
88730: PUSH
88731: LD_INT 1
88733: ARRAY
88734: PUSH
88735: LD_INT 3
88737: ARRAY
88738: ST_TO_ADDR
// if InArea ( x , y , area ) then
88739: LD_VAR 0 5
88743: PPUSH
88744: LD_VAR 0 6
88748: PPUSH
88749: LD_VAR 0 2
88753: PPUSH
88754: CALL_OW 309
88758: IFFALSE 88769
// ComStop ( unit ) ;
88760: LD_VAR 0 1
88764: PPUSH
88765: CALL_OW 141
// end ;
88769: LD_VAR 0 4
88773: RET
// export function Abs ( value ) ; begin
88774: LD_INT 0
88776: PPUSH
// result := value ;
88777: LD_ADDR_VAR 0 2
88781: PUSH
88782: LD_VAR 0 1
88786: ST_TO_ADDR
// if value < 0 then
88787: LD_VAR 0 1
88791: PUSH
88792: LD_INT 0
88794: LESS
88795: IFFALSE 88812
// result := value * - 1 ;
88797: LD_ADDR_VAR 0 2
88801: PUSH
88802: LD_VAR 0 1
88806: PUSH
88807: LD_INT 1
88809: NEG
88810: MUL
88811: ST_TO_ADDR
// end ;
88812: LD_VAR 0 2
88816: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
88817: LD_INT 0
88819: PPUSH
88820: PPUSH
88821: PPUSH
88822: PPUSH
88823: PPUSH
88824: PPUSH
88825: PPUSH
88826: PPUSH
// if not unit or not building then
88827: LD_VAR 0 1
88831: NOT
88832: PUSH
88833: LD_VAR 0 2
88837: NOT
88838: OR
88839: IFFALSE 88843
// exit ;
88841: GO 89069
// x := GetX ( building ) ;
88843: LD_ADDR_VAR 0 4
88847: PUSH
88848: LD_VAR 0 2
88852: PPUSH
88853: CALL_OW 250
88857: ST_TO_ADDR
// y := GetY ( building ) ;
88858: LD_ADDR_VAR 0 6
88862: PUSH
88863: LD_VAR 0 2
88867: PPUSH
88868: CALL_OW 251
88872: ST_TO_ADDR
// d := GetDir ( building ) ;
88873: LD_ADDR_VAR 0 8
88877: PUSH
88878: LD_VAR 0 2
88882: PPUSH
88883: CALL_OW 254
88887: ST_TO_ADDR
// r := 4 ;
88888: LD_ADDR_VAR 0 9
88892: PUSH
88893: LD_INT 4
88895: ST_TO_ADDR
// for i := 1 to 5 do
88896: LD_ADDR_VAR 0 10
88900: PUSH
88901: DOUBLE
88902: LD_INT 1
88904: DEC
88905: ST_TO_ADDR
88906: LD_INT 5
88908: PUSH
88909: FOR_TO
88910: IFFALSE 89067
// begin _x := ShiftX ( x , d , r + i ) ;
88912: LD_ADDR_VAR 0 5
88916: PUSH
88917: LD_VAR 0 4
88921: PPUSH
88922: LD_VAR 0 8
88926: PPUSH
88927: LD_VAR 0 9
88931: PUSH
88932: LD_VAR 0 10
88936: PLUS
88937: PPUSH
88938: CALL_OW 272
88942: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
88943: LD_ADDR_VAR 0 7
88947: PUSH
88948: LD_VAR 0 6
88952: PPUSH
88953: LD_VAR 0 8
88957: PPUSH
88958: LD_VAR 0 9
88962: PUSH
88963: LD_VAR 0 10
88967: PLUS
88968: PPUSH
88969: CALL_OW 273
88973: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
88974: LD_VAR 0 5
88978: PPUSH
88979: LD_VAR 0 7
88983: PPUSH
88984: CALL_OW 488
88988: PUSH
88989: LD_VAR 0 5
88993: PPUSH
88994: LD_VAR 0 7
88998: PPUSH
88999: CALL_OW 428
89003: PPUSH
89004: CALL_OW 247
89008: PUSH
89009: LD_INT 3
89011: PUSH
89012: LD_INT 2
89014: PUSH
89015: EMPTY
89016: LIST
89017: LIST
89018: IN
89019: NOT
89020: AND
89021: IFFALSE 89065
// begin ComMoveXY ( unit , _x , _y ) ;
89023: LD_VAR 0 1
89027: PPUSH
89028: LD_VAR 0 5
89032: PPUSH
89033: LD_VAR 0 7
89037: PPUSH
89038: CALL_OW 111
// result := [ _x , _y ] ;
89042: LD_ADDR_VAR 0 3
89046: PUSH
89047: LD_VAR 0 5
89051: PUSH
89052: LD_VAR 0 7
89056: PUSH
89057: EMPTY
89058: LIST
89059: LIST
89060: ST_TO_ADDR
// exit ;
89061: POP
89062: POP
89063: GO 89069
// end ; end ;
89065: GO 88909
89067: POP
89068: POP
// end ;
89069: LD_VAR 0 3
89073: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
89074: LD_INT 0
89076: PPUSH
89077: PPUSH
89078: PPUSH
// result := 0 ;
89079: LD_ADDR_VAR 0 3
89083: PUSH
89084: LD_INT 0
89086: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
89087: LD_VAR 0 1
89091: PUSH
89092: LD_INT 0
89094: LESS
89095: PUSH
89096: LD_VAR 0 1
89100: PUSH
89101: LD_INT 8
89103: GREATER
89104: OR
89105: PUSH
89106: LD_VAR 0 2
89110: PUSH
89111: LD_INT 0
89113: LESS
89114: OR
89115: PUSH
89116: LD_VAR 0 2
89120: PUSH
89121: LD_INT 8
89123: GREATER
89124: OR
89125: IFFALSE 89129
// exit ;
89127: GO 89204
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
89129: LD_ADDR_VAR 0 4
89133: PUSH
89134: LD_INT 22
89136: PUSH
89137: LD_VAR 0 2
89141: PUSH
89142: EMPTY
89143: LIST
89144: LIST
89145: PPUSH
89146: CALL_OW 69
89150: PUSH
89151: FOR_IN
89152: IFFALSE 89202
// begin un := UnitShoot ( i ) ;
89154: LD_ADDR_VAR 0 5
89158: PUSH
89159: LD_VAR 0 4
89163: PPUSH
89164: CALL_OW 504
89168: ST_TO_ADDR
// if GetSide ( un ) = side1 then
89169: LD_VAR 0 5
89173: PPUSH
89174: CALL_OW 255
89178: PUSH
89179: LD_VAR 0 1
89183: EQUAL
89184: IFFALSE 89200
// begin result := un ;
89186: LD_ADDR_VAR 0 3
89190: PUSH
89191: LD_VAR 0 5
89195: ST_TO_ADDR
// exit ;
89196: POP
89197: POP
89198: GO 89204
// end ; end ;
89200: GO 89151
89202: POP
89203: POP
// end ;
89204: LD_VAR 0 3
89208: RET
// export function GetCargoBay ( units ) ; begin
89209: LD_INT 0
89211: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
89212: LD_ADDR_VAR 0 2
89216: PUSH
89217: LD_VAR 0 1
89221: PPUSH
89222: LD_INT 2
89224: PUSH
89225: LD_INT 34
89227: PUSH
89228: LD_INT 12
89230: PUSH
89231: EMPTY
89232: LIST
89233: LIST
89234: PUSH
89235: LD_INT 34
89237: PUSH
89238: LD_INT 51
89240: PUSH
89241: EMPTY
89242: LIST
89243: LIST
89244: PUSH
89245: LD_INT 34
89247: PUSH
89248: LD_INT 32
89250: PUSH
89251: EMPTY
89252: LIST
89253: LIST
89254: PUSH
89255: LD_INT 34
89257: PUSH
89258: LD_EXP 73
89262: PUSH
89263: EMPTY
89264: LIST
89265: LIST
89266: PUSH
89267: EMPTY
89268: LIST
89269: LIST
89270: LIST
89271: LIST
89272: LIST
89273: PPUSH
89274: CALL_OW 72
89278: ST_TO_ADDR
// end ;
89279: LD_VAR 0 2
89283: RET
// export function Negate ( value ) ; begin
89284: LD_INT 0
89286: PPUSH
// result := not value ;
89287: LD_ADDR_VAR 0 2
89291: PUSH
89292: LD_VAR 0 1
89296: NOT
89297: ST_TO_ADDR
// end ;
89298: LD_VAR 0 2
89302: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; begin
89303: LD_INT 0
89305: PPUSH
// if x1 = x2 then
89306: LD_VAR 0 1
89310: PUSH
89311: LD_VAR 0 3
89315: EQUAL
89316: IFFALSE 89350
// begin if y1 > y2 then
89318: LD_VAR 0 2
89322: PUSH
89323: LD_VAR 0 4
89327: GREATER
89328: IFFALSE 89340
// result := 0 else
89330: LD_ADDR_VAR 0 5
89334: PUSH
89335: LD_INT 0
89337: ST_TO_ADDR
89338: GO 89348
// result := 3 ;
89340: LD_ADDR_VAR 0 5
89344: PUSH
89345: LD_INT 3
89347: ST_TO_ADDR
// exit ;
89348: GO 89436
// end ; if y1 = y2 then
89350: LD_VAR 0 2
89354: PUSH
89355: LD_VAR 0 4
89359: EQUAL
89360: IFFALSE 89394
// begin if x1 > x2 then
89362: LD_VAR 0 1
89366: PUSH
89367: LD_VAR 0 3
89371: GREATER
89372: IFFALSE 89384
// result := 1 else
89374: LD_ADDR_VAR 0 5
89378: PUSH
89379: LD_INT 1
89381: ST_TO_ADDR
89382: GO 89392
// result := 4 ;
89384: LD_ADDR_VAR 0 5
89388: PUSH
89389: LD_INT 4
89391: ST_TO_ADDR
// exit ;
89392: GO 89436
// end ; if x1 > x2 and y1 > y2 then
89394: LD_VAR 0 1
89398: PUSH
89399: LD_VAR 0 3
89403: GREATER
89404: PUSH
89405: LD_VAR 0 2
89409: PUSH
89410: LD_VAR 0 4
89414: GREATER
89415: AND
89416: IFFALSE 89428
// result := 2 else
89418: LD_ADDR_VAR 0 5
89422: PUSH
89423: LD_INT 2
89425: ST_TO_ADDR
89426: GO 89436
// result := 5 ;
89428: LD_ADDR_VAR 0 5
89432: PUSH
89433: LD_INT 5
89435: ST_TO_ADDR
// end ;
89436: LD_VAR 0 5
89440: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
89441: LD_INT 0
89443: PPUSH
89444: PPUSH
// if not driver or not IsInUnit ( driver ) then
89445: LD_VAR 0 1
89449: NOT
89450: PUSH
89451: LD_VAR 0 1
89455: PPUSH
89456: CALL_OW 310
89460: NOT
89461: OR
89462: IFFALSE 89466
// exit ;
89464: GO 89556
// vehicle := IsInUnit ( driver ) ;
89466: LD_ADDR_VAR 0 3
89470: PUSH
89471: LD_VAR 0 1
89475: PPUSH
89476: CALL_OW 310
89480: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
89481: LD_VAR 0 1
89485: PPUSH
89486: LD_STRING \
89488: PUSH
89489: LD_INT 0
89491: PUSH
89492: LD_INT 0
89494: PUSH
89495: LD_INT 0
89497: PUSH
89498: LD_INT 0
89500: PUSH
89501: LD_INT 0
89503: PUSH
89504: LD_INT 0
89506: PUSH
89507: EMPTY
89508: LIST
89509: LIST
89510: LIST
89511: LIST
89512: LIST
89513: LIST
89514: LIST
89515: PUSH
89516: LD_STRING E
89518: PUSH
89519: LD_INT 0
89521: PUSH
89522: LD_INT 0
89524: PUSH
89525: LD_VAR 0 3
89529: PUSH
89530: LD_INT 0
89532: PUSH
89533: LD_INT 0
89535: PUSH
89536: LD_INT 0
89538: PUSH
89539: EMPTY
89540: LIST
89541: LIST
89542: LIST
89543: LIST
89544: LIST
89545: LIST
89546: LIST
89547: PUSH
89548: EMPTY
89549: LIST
89550: LIST
89551: PPUSH
89552: CALL_OW 446
// end ;
89556: LD_VAR 0 2
89560: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
89561: LD_INT 0
89563: PPUSH
89564: PPUSH
89565: PPUSH
// tmp := [ ] ;
89566: LD_ADDR_VAR 0 5
89570: PUSH
89571: EMPTY
89572: ST_TO_ADDR
// for i in units do
89573: LD_ADDR_VAR 0 4
89577: PUSH
89578: LD_VAR 0 1
89582: PUSH
89583: FOR_IN
89584: IFFALSE 89622
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
89586: LD_ADDR_VAR 0 5
89590: PUSH
89591: LD_VAR 0 5
89595: PPUSH
89596: LD_VAR 0 5
89600: PUSH
89601: LD_INT 1
89603: PLUS
89604: PPUSH
89605: LD_VAR 0 4
89609: PPUSH
89610: CALL_OW 256
89614: PPUSH
89615: CALL_OW 2
89619: ST_TO_ADDR
89620: GO 89583
89622: POP
89623: POP
// if not tmp then
89624: LD_VAR 0 5
89628: NOT
89629: IFFALSE 89633
// exit ;
89631: GO 89681
// if asc then
89633: LD_VAR 0 2
89637: IFFALSE 89661
// result := SortListByListAsc ( units , tmp ) else
89639: LD_ADDR_VAR 0 3
89643: PUSH
89644: LD_VAR 0 1
89648: PPUSH
89649: LD_VAR 0 5
89653: PPUSH
89654: CALL_OW 76
89658: ST_TO_ADDR
89659: GO 89681
// result := SortListByListDesc ( units , tmp ) ;
89661: LD_ADDR_VAR 0 3
89665: PUSH
89666: LD_VAR 0 1
89670: PPUSH
89671: LD_VAR 0 5
89675: PPUSH
89676: CALL_OW 77
89680: ST_TO_ADDR
// end ;
89681: LD_VAR 0 3
89685: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
89686: LD_INT 0
89688: PPUSH
89689: PPUSH
// task := GetTaskList ( mech ) ;
89690: LD_ADDR_VAR 0 4
89694: PUSH
89695: LD_VAR 0 1
89699: PPUSH
89700: CALL_OW 437
89704: ST_TO_ADDR
// if not task then
89705: LD_VAR 0 4
89709: NOT
89710: IFFALSE 89714
// exit ;
89712: GO 89756
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
89714: LD_ADDR_VAR 0 3
89718: PUSH
89719: LD_VAR 0 4
89723: PUSH
89724: LD_INT 1
89726: ARRAY
89727: PUSH
89728: LD_INT 1
89730: ARRAY
89731: PUSH
89732: LD_STRING r
89734: EQUAL
89735: PUSH
89736: LD_VAR 0 4
89740: PUSH
89741: LD_INT 1
89743: ARRAY
89744: PUSH
89745: LD_INT 4
89747: ARRAY
89748: PUSH
89749: LD_VAR 0 2
89753: EQUAL
89754: AND
89755: ST_TO_ADDR
// end ;
89756: LD_VAR 0 3
89760: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
89761: LD_INT 0
89763: PPUSH
// SetDir ( unit , d ) ;
89764: LD_VAR 0 1
89768: PPUSH
89769: LD_VAR 0 4
89773: PPUSH
89774: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
89778: LD_VAR 0 1
89782: PPUSH
89783: LD_VAR 0 2
89787: PPUSH
89788: LD_VAR 0 3
89792: PPUSH
89793: LD_VAR 0 5
89797: PPUSH
89798: CALL_OW 48
// end ; end_of_file end_of_file
89802: LD_VAR 0 6
89806: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
89807: LD_INT 0
89809: PPUSH
// if p2 = 100 then
89810: LD_VAR 0 2
89814: PUSH
89815: LD_INT 100
89817: EQUAL
89818: IFFALSE 90767
// begin if not StreamModeActive then
89820: LD_EXP 137
89824: NOT
89825: IFFALSE 89835
// StreamModeActive := true ;
89827: LD_ADDR_EXP 137
89831: PUSH
89832: LD_INT 1
89834: ST_TO_ADDR
// if p3 = 0 then
89835: LD_VAR 0 3
89839: PUSH
89840: LD_INT 0
89842: EQUAL
89843: IFFALSE 89849
// InitStreamMode ;
89845: CALL 90927 0 0
// if p3 = 1 then
89849: LD_VAR 0 3
89853: PUSH
89854: LD_INT 1
89856: EQUAL
89857: IFFALSE 89867
// sRocket := true ;
89859: LD_ADDR_EXP 142
89863: PUSH
89864: LD_INT 1
89866: ST_TO_ADDR
// if p3 = 2 then
89867: LD_VAR 0 3
89871: PUSH
89872: LD_INT 2
89874: EQUAL
89875: IFFALSE 89885
// sSpeed := true ;
89877: LD_ADDR_EXP 141
89881: PUSH
89882: LD_INT 1
89884: ST_TO_ADDR
// if p3 = 3 then
89885: LD_VAR 0 3
89889: PUSH
89890: LD_INT 3
89892: EQUAL
89893: IFFALSE 89903
// sEngine := true ;
89895: LD_ADDR_EXP 143
89899: PUSH
89900: LD_INT 1
89902: ST_TO_ADDR
// if p3 = 4 then
89903: LD_VAR 0 3
89907: PUSH
89908: LD_INT 4
89910: EQUAL
89911: IFFALSE 89921
// sSpec := true ;
89913: LD_ADDR_EXP 140
89917: PUSH
89918: LD_INT 1
89920: ST_TO_ADDR
// if p3 = 5 then
89921: LD_VAR 0 3
89925: PUSH
89926: LD_INT 5
89928: EQUAL
89929: IFFALSE 89939
// sLevel := true ;
89931: LD_ADDR_EXP 144
89935: PUSH
89936: LD_INT 1
89938: ST_TO_ADDR
// if p3 = 6 then
89939: LD_VAR 0 3
89943: PUSH
89944: LD_INT 6
89946: EQUAL
89947: IFFALSE 89957
// sArmoury := true ;
89949: LD_ADDR_EXP 145
89953: PUSH
89954: LD_INT 1
89956: ST_TO_ADDR
// if p3 = 7 then
89957: LD_VAR 0 3
89961: PUSH
89962: LD_INT 7
89964: EQUAL
89965: IFFALSE 89975
// sRadar := true ;
89967: LD_ADDR_EXP 146
89971: PUSH
89972: LD_INT 1
89974: ST_TO_ADDR
// if p3 = 8 then
89975: LD_VAR 0 3
89979: PUSH
89980: LD_INT 8
89982: EQUAL
89983: IFFALSE 89993
// sBunker := true ;
89985: LD_ADDR_EXP 147
89989: PUSH
89990: LD_INT 1
89992: ST_TO_ADDR
// if p3 = 9 then
89993: LD_VAR 0 3
89997: PUSH
89998: LD_INT 9
90000: EQUAL
90001: IFFALSE 90011
// sHack := true ;
90003: LD_ADDR_EXP 148
90007: PUSH
90008: LD_INT 1
90010: ST_TO_ADDR
// if p3 = 10 then
90011: LD_VAR 0 3
90015: PUSH
90016: LD_INT 10
90018: EQUAL
90019: IFFALSE 90029
// sFire := true ;
90021: LD_ADDR_EXP 149
90025: PUSH
90026: LD_INT 1
90028: ST_TO_ADDR
// if p3 = 11 then
90029: LD_VAR 0 3
90033: PUSH
90034: LD_INT 11
90036: EQUAL
90037: IFFALSE 90047
// sRefresh := true ;
90039: LD_ADDR_EXP 150
90043: PUSH
90044: LD_INT 1
90046: ST_TO_ADDR
// if p3 = 12 then
90047: LD_VAR 0 3
90051: PUSH
90052: LD_INT 12
90054: EQUAL
90055: IFFALSE 90065
// sExp := true ;
90057: LD_ADDR_EXP 151
90061: PUSH
90062: LD_INT 1
90064: ST_TO_ADDR
// if p3 = 13 then
90065: LD_VAR 0 3
90069: PUSH
90070: LD_INT 13
90072: EQUAL
90073: IFFALSE 90083
// sDepot := true ;
90075: LD_ADDR_EXP 152
90079: PUSH
90080: LD_INT 1
90082: ST_TO_ADDR
// if p3 = 14 then
90083: LD_VAR 0 3
90087: PUSH
90088: LD_INT 14
90090: EQUAL
90091: IFFALSE 90101
// sFlag := true ;
90093: LD_ADDR_EXP 153
90097: PUSH
90098: LD_INT 1
90100: ST_TO_ADDR
// if p3 = 15 then
90101: LD_VAR 0 3
90105: PUSH
90106: LD_INT 15
90108: EQUAL
90109: IFFALSE 90119
// sKamikadze := true ;
90111: LD_ADDR_EXP 161
90115: PUSH
90116: LD_INT 1
90118: ST_TO_ADDR
// if p3 = 16 then
90119: LD_VAR 0 3
90123: PUSH
90124: LD_INT 16
90126: EQUAL
90127: IFFALSE 90137
// sTroll := true ;
90129: LD_ADDR_EXP 162
90133: PUSH
90134: LD_INT 1
90136: ST_TO_ADDR
// if p3 = 17 then
90137: LD_VAR 0 3
90141: PUSH
90142: LD_INT 17
90144: EQUAL
90145: IFFALSE 90155
// sSlow := true ;
90147: LD_ADDR_EXP 163
90151: PUSH
90152: LD_INT 1
90154: ST_TO_ADDR
// if p3 = 18 then
90155: LD_VAR 0 3
90159: PUSH
90160: LD_INT 18
90162: EQUAL
90163: IFFALSE 90173
// sLack := true ;
90165: LD_ADDR_EXP 164
90169: PUSH
90170: LD_INT 1
90172: ST_TO_ADDR
// if p3 = 19 then
90173: LD_VAR 0 3
90177: PUSH
90178: LD_INT 19
90180: EQUAL
90181: IFFALSE 90191
// sTank := true ;
90183: LD_ADDR_EXP 166
90187: PUSH
90188: LD_INT 1
90190: ST_TO_ADDR
// if p3 = 20 then
90191: LD_VAR 0 3
90195: PUSH
90196: LD_INT 20
90198: EQUAL
90199: IFFALSE 90209
// sRemote := true ;
90201: LD_ADDR_EXP 167
90205: PUSH
90206: LD_INT 1
90208: ST_TO_ADDR
// if p3 = 21 then
90209: LD_VAR 0 3
90213: PUSH
90214: LD_INT 21
90216: EQUAL
90217: IFFALSE 90227
// sPowell := true ;
90219: LD_ADDR_EXP 168
90223: PUSH
90224: LD_INT 1
90226: ST_TO_ADDR
// if p3 = 22 then
90227: LD_VAR 0 3
90231: PUSH
90232: LD_INT 22
90234: EQUAL
90235: IFFALSE 90245
// sTeleport := true ;
90237: LD_ADDR_EXP 171
90241: PUSH
90242: LD_INT 1
90244: ST_TO_ADDR
// if p3 = 23 then
90245: LD_VAR 0 3
90249: PUSH
90250: LD_INT 23
90252: EQUAL
90253: IFFALSE 90263
// sOilTower := true ;
90255: LD_ADDR_EXP 173
90259: PUSH
90260: LD_INT 1
90262: ST_TO_ADDR
// if p3 = 24 then
90263: LD_VAR 0 3
90267: PUSH
90268: LD_INT 24
90270: EQUAL
90271: IFFALSE 90281
// sShovel := true ;
90273: LD_ADDR_EXP 174
90277: PUSH
90278: LD_INT 1
90280: ST_TO_ADDR
// if p3 = 25 then
90281: LD_VAR 0 3
90285: PUSH
90286: LD_INT 25
90288: EQUAL
90289: IFFALSE 90299
// sSheik := true ;
90291: LD_ADDR_EXP 175
90295: PUSH
90296: LD_INT 1
90298: ST_TO_ADDR
// if p3 = 26 then
90299: LD_VAR 0 3
90303: PUSH
90304: LD_INT 26
90306: EQUAL
90307: IFFALSE 90317
// sEarthquake := true ;
90309: LD_ADDR_EXP 177
90313: PUSH
90314: LD_INT 1
90316: ST_TO_ADDR
// if p3 = 27 then
90317: LD_VAR 0 3
90321: PUSH
90322: LD_INT 27
90324: EQUAL
90325: IFFALSE 90335
// sAI := true ;
90327: LD_ADDR_EXP 178
90331: PUSH
90332: LD_INT 1
90334: ST_TO_ADDR
// if p3 = 28 then
90335: LD_VAR 0 3
90339: PUSH
90340: LD_INT 28
90342: EQUAL
90343: IFFALSE 90353
// sCargo := true ;
90345: LD_ADDR_EXP 181
90349: PUSH
90350: LD_INT 1
90352: ST_TO_ADDR
// if p3 = 29 then
90353: LD_VAR 0 3
90357: PUSH
90358: LD_INT 29
90360: EQUAL
90361: IFFALSE 90371
// sDLaser := true ;
90363: LD_ADDR_EXP 182
90367: PUSH
90368: LD_INT 1
90370: ST_TO_ADDR
// if p3 = 30 then
90371: LD_VAR 0 3
90375: PUSH
90376: LD_INT 30
90378: EQUAL
90379: IFFALSE 90389
// sExchange := true ;
90381: LD_ADDR_EXP 183
90385: PUSH
90386: LD_INT 1
90388: ST_TO_ADDR
// if p3 = 31 then
90389: LD_VAR 0 3
90393: PUSH
90394: LD_INT 31
90396: EQUAL
90397: IFFALSE 90407
// sFac := true ;
90399: LD_ADDR_EXP 184
90403: PUSH
90404: LD_INT 1
90406: ST_TO_ADDR
// if p3 = 32 then
90407: LD_VAR 0 3
90411: PUSH
90412: LD_INT 32
90414: EQUAL
90415: IFFALSE 90425
// sPower := true ;
90417: LD_ADDR_EXP 185
90421: PUSH
90422: LD_INT 1
90424: ST_TO_ADDR
// if p3 = 33 then
90425: LD_VAR 0 3
90429: PUSH
90430: LD_INT 33
90432: EQUAL
90433: IFFALSE 90443
// sRandom := true ;
90435: LD_ADDR_EXP 186
90439: PUSH
90440: LD_INT 1
90442: ST_TO_ADDR
// if p3 = 34 then
90443: LD_VAR 0 3
90447: PUSH
90448: LD_INT 34
90450: EQUAL
90451: IFFALSE 90461
// sShield := true ;
90453: LD_ADDR_EXP 187
90457: PUSH
90458: LD_INT 1
90460: ST_TO_ADDR
// if p3 = 35 then
90461: LD_VAR 0 3
90465: PUSH
90466: LD_INT 35
90468: EQUAL
90469: IFFALSE 90479
// sTime := true ;
90471: LD_ADDR_EXP 188
90475: PUSH
90476: LD_INT 1
90478: ST_TO_ADDR
// if p3 = 36 then
90479: LD_VAR 0 3
90483: PUSH
90484: LD_INT 36
90486: EQUAL
90487: IFFALSE 90497
// sTools := true ;
90489: LD_ADDR_EXP 189
90493: PUSH
90494: LD_INT 1
90496: ST_TO_ADDR
// if p3 = 101 then
90497: LD_VAR 0 3
90501: PUSH
90502: LD_INT 101
90504: EQUAL
90505: IFFALSE 90515
// sSold := true ;
90507: LD_ADDR_EXP 154
90511: PUSH
90512: LD_INT 1
90514: ST_TO_ADDR
// if p3 = 102 then
90515: LD_VAR 0 3
90519: PUSH
90520: LD_INT 102
90522: EQUAL
90523: IFFALSE 90533
// sDiff := true ;
90525: LD_ADDR_EXP 155
90529: PUSH
90530: LD_INT 1
90532: ST_TO_ADDR
// if p3 = 103 then
90533: LD_VAR 0 3
90537: PUSH
90538: LD_INT 103
90540: EQUAL
90541: IFFALSE 90551
// sFog := true ;
90543: LD_ADDR_EXP 158
90547: PUSH
90548: LD_INT 1
90550: ST_TO_ADDR
// if p3 = 104 then
90551: LD_VAR 0 3
90555: PUSH
90556: LD_INT 104
90558: EQUAL
90559: IFFALSE 90569
// sReset := true ;
90561: LD_ADDR_EXP 159
90565: PUSH
90566: LD_INT 1
90568: ST_TO_ADDR
// if p3 = 105 then
90569: LD_VAR 0 3
90573: PUSH
90574: LD_INT 105
90576: EQUAL
90577: IFFALSE 90587
// sSun := true ;
90579: LD_ADDR_EXP 160
90583: PUSH
90584: LD_INT 1
90586: ST_TO_ADDR
// if p3 = 106 then
90587: LD_VAR 0 3
90591: PUSH
90592: LD_INT 106
90594: EQUAL
90595: IFFALSE 90605
// sTiger := true ;
90597: LD_ADDR_EXP 156
90601: PUSH
90602: LD_INT 1
90604: ST_TO_ADDR
// if p3 = 107 then
90605: LD_VAR 0 3
90609: PUSH
90610: LD_INT 107
90612: EQUAL
90613: IFFALSE 90623
// sBomb := true ;
90615: LD_ADDR_EXP 157
90619: PUSH
90620: LD_INT 1
90622: ST_TO_ADDR
// if p3 = 108 then
90623: LD_VAR 0 3
90627: PUSH
90628: LD_INT 108
90630: EQUAL
90631: IFFALSE 90641
// sWound := true ;
90633: LD_ADDR_EXP 165
90637: PUSH
90638: LD_INT 1
90640: ST_TO_ADDR
// if p3 = 109 then
90641: LD_VAR 0 3
90645: PUSH
90646: LD_INT 109
90648: EQUAL
90649: IFFALSE 90659
// sBetray := true ;
90651: LD_ADDR_EXP 169
90655: PUSH
90656: LD_INT 1
90658: ST_TO_ADDR
// if p3 = 110 then
90659: LD_VAR 0 3
90663: PUSH
90664: LD_INT 110
90666: EQUAL
90667: IFFALSE 90677
// sContamin := true ;
90669: LD_ADDR_EXP 170
90673: PUSH
90674: LD_INT 1
90676: ST_TO_ADDR
// if p3 = 111 then
90677: LD_VAR 0 3
90681: PUSH
90682: LD_INT 111
90684: EQUAL
90685: IFFALSE 90695
// sOil := true ;
90687: LD_ADDR_EXP 172
90691: PUSH
90692: LD_INT 1
90694: ST_TO_ADDR
// if p3 = 112 then
90695: LD_VAR 0 3
90699: PUSH
90700: LD_INT 112
90702: EQUAL
90703: IFFALSE 90713
// sStu := true ;
90705: LD_ADDR_EXP 176
90709: PUSH
90710: LD_INT 1
90712: ST_TO_ADDR
// if p3 = 113 then
90713: LD_VAR 0 3
90717: PUSH
90718: LD_INT 113
90720: EQUAL
90721: IFFALSE 90731
// sBazooka := true ;
90723: LD_ADDR_EXP 179
90727: PUSH
90728: LD_INT 1
90730: ST_TO_ADDR
// if p3 = 114 then
90731: LD_VAR 0 3
90735: PUSH
90736: LD_INT 114
90738: EQUAL
90739: IFFALSE 90749
// sMortar := true ;
90741: LD_ADDR_EXP 180
90745: PUSH
90746: LD_INT 1
90748: ST_TO_ADDR
// if p3 = 115 then
90749: LD_VAR 0 3
90753: PUSH
90754: LD_INT 115
90756: EQUAL
90757: IFFALSE 90767
// sRanger := true ;
90759: LD_ADDR_EXP 190
90763: PUSH
90764: LD_INT 1
90766: ST_TO_ADDR
// end ; if p2 = 101 then
90767: LD_VAR 0 2
90771: PUSH
90772: LD_INT 101
90774: EQUAL
90775: IFFALSE 90903
// begin case p3 of 1 :
90777: LD_VAR 0 3
90781: PUSH
90782: LD_INT 1
90784: DOUBLE
90785: EQUAL
90786: IFTRUE 90790
90788: GO 90797
90790: POP
// hHackUnlimitedResources ; 2 :
90791: CALL 101940 0 0
90795: GO 90903
90797: LD_INT 2
90799: DOUBLE
90800: EQUAL
90801: IFTRUE 90805
90803: GO 90812
90805: POP
// hHackSetLevel10 ; 3 :
90806: CALL 102073 0 0
90810: GO 90903
90812: LD_INT 3
90814: DOUBLE
90815: EQUAL
90816: IFTRUE 90820
90818: GO 90827
90820: POP
// hHackSetLevel10YourUnits ; 4 :
90821: CALL 102158 0 0
90825: GO 90903
90827: LD_INT 4
90829: DOUBLE
90830: EQUAL
90831: IFTRUE 90835
90833: GO 90842
90835: POP
// hHackInvincible ; 5 :
90836: CALL 102606 0 0
90840: GO 90903
90842: LD_INT 5
90844: DOUBLE
90845: EQUAL
90846: IFTRUE 90850
90848: GO 90857
90850: POP
// hHackInvisible ; 6 :
90851: CALL 102717 0 0
90855: GO 90903
90857: LD_INT 6
90859: DOUBLE
90860: EQUAL
90861: IFTRUE 90865
90863: GO 90872
90865: POP
// hHackChangeYourSide ; 7 :
90866: CALL 102774 0 0
90870: GO 90903
90872: LD_INT 7
90874: DOUBLE
90875: EQUAL
90876: IFTRUE 90880
90878: GO 90887
90880: POP
// hHackChangeUnitSide ; 8 :
90881: CALL 102816 0 0
90885: GO 90903
90887: LD_INT 8
90889: DOUBLE
90890: EQUAL
90891: IFTRUE 90895
90893: GO 90902
90895: POP
// hHackFog ; end ;
90896: CALL 102917 0 0
90900: GO 90903
90902: POP
// end ; end ;
90903: LD_VAR 0 7
90907: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
90908: GO 90910
90910: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
90911: LD_STRING initStreamRollete();
90913: PPUSH
90914: CALL_OW 559
// InitStreamMode ;
90918: CALL 90927 0 0
// DefineStreamItems ( ) ;
90922: CALL 91367 0 0
// end ;
90926: END
// function InitStreamMode ; begin
90927: LD_INT 0
90929: PPUSH
// streamModeActive := false ;
90930: LD_ADDR_EXP 137
90934: PUSH
90935: LD_INT 0
90937: ST_TO_ADDR
// normalCounter := 36 ;
90938: LD_ADDR_EXP 138
90942: PUSH
90943: LD_INT 36
90945: ST_TO_ADDR
// hardcoreCounter := 16 ;
90946: LD_ADDR_EXP 139
90950: PUSH
90951: LD_INT 16
90953: ST_TO_ADDR
// sRocket := false ;
90954: LD_ADDR_EXP 142
90958: PUSH
90959: LD_INT 0
90961: ST_TO_ADDR
// sSpeed := false ;
90962: LD_ADDR_EXP 141
90966: PUSH
90967: LD_INT 0
90969: ST_TO_ADDR
// sEngine := false ;
90970: LD_ADDR_EXP 143
90974: PUSH
90975: LD_INT 0
90977: ST_TO_ADDR
// sSpec := false ;
90978: LD_ADDR_EXP 140
90982: PUSH
90983: LD_INT 0
90985: ST_TO_ADDR
// sLevel := false ;
90986: LD_ADDR_EXP 144
90990: PUSH
90991: LD_INT 0
90993: ST_TO_ADDR
// sArmoury := false ;
90994: LD_ADDR_EXP 145
90998: PUSH
90999: LD_INT 0
91001: ST_TO_ADDR
// sRadar := false ;
91002: LD_ADDR_EXP 146
91006: PUSH
91007: LD_INT 0
91009: ST_TO_ADDR
// sBunker := false ;
91010: LD_ADDR_EXP 147
91014: PUSH
91015: LD_INT 0
91017: ST_TO_ADDR
// sHack := false ;
91018: LD_ADDR_EXP 148
91022: PUSH
91023: LD_INT 0
91025: ST_TO_ADDR
// sFire := false ;
91026: LD_ADDR_EXP 149
91030: PUSH
91031: LD_INT 0
91033: ST_TO_ADDR
// sRefresh := false ;
91034: LD_ADDR_EXP 150
91038: PUSH
91039: LD_INT 0
91041: ST_TO_ADDR
// sExp := false ;
91042: LD_ADDR_EXP 151
91046: PUSH
91047: LD_INT 0
91049: ST_TO_ADDR
// sDepot := false ;
91050: LD_ADDR_EXP 152
91054: PUSH
91055: LD_INT 0
91057: ST_TO_ADDR
// sFlag := false ;
91058: LD_ADDR_EXP 153
91062: PUSH
91063: LD_INT 0
91065: ST_TO_ADDR
// sKamikadze := false ;
91066: LD_ADDR_EXP 161
91070: PUSH
91071: LD_INT 0
91073: ST_TO_ADDR
// sTroll := false ;
91074: LD_ADDR_EXP 162
91078: PUSH
91079: LD_INT 0
91081: ST_TO_ADDR
// sSlow := false ;
91082: LD_ADDR_EXP 163
91086: PUSH
91087: LD_INT 0
91089: ST_TO_ADDR
// sLack := false ;
91090: LD_ADDR_EXP 164
91094: PUSH
91095: LD_INT 0
91097: ST_TO_ADDR
// sTank := false ;
91098: LD_ADDR_EXP 166
91102: PUSH
91103: LD_INT 0
91105: ST_TO_ADDR
// sRemote := false ;
91106: LD_ADDR_EXP 167
91110: PUSH
91111: LD_INT 0
91113: ST_TO_ADDR
// sPowell := false ;
91114: LD_ADDR_EXP 168
91118: PUSH
91119: LD_INT 0
91121: ST_TO_ADDR
// sTeleport := false ;
91122: LD_ADDR_EXP 171
91126: PUSH
91127: LD_INT 0
91129: ST_TO_ADDR
// sOilTower := false ;
91130: LD_ADDR_EXP 173
91134: PUSH
91135: LD_INT 0
91137: ST_TO_ADDR
// sShovel := false ;
91138: LD_ADDR_EXP 174
91142: PUSH
91143: LD_INT 0
91145: ST_TO_ADDR
// sSheik := false ;
91146: LD_ADDR_EXP 175
91150: PUSH
91151: LD_INT 0
91153: ST_TO_ADDR
// sEarthquake := false ;
91154: LD_ADDR_EXP 177
91158: PUSH
91159: LD_INT 0
91161: ST_TO_ADDR
// sAI := false ;
91162: LD_ADDR_EXP 178
91166: PUSH
91167: LD_INT 0
91169: ST_TO_ADDR
// sCargo := false ;
91170: LD_ADDR_EXP 181
91174: PUSH
91175: LD_INT 0
91177: ST_TO_ADDR
// sDLaser := false ;
91178: LD_ADDR_EXP 182
91182: PUSH
91183: LD_INT 0
91185: ST_TO_ADDR
// sExchange := false ;
91186: LD_ADDR_EXP 183
91190: PUSH
91191: LD_INT 0
91193: ST_TO_ADDR
// sFac := false ;
91194: LD_ADDR_EXP 184
91198: PUSH
91199: LD_INT 0
91201: ST_TO_ADDR
// sPower := false ;
91202: LD_ADDR_EXP 185
91206: PUSH
91207: LD_INT 0
91209: ST_TO_ADDR
// sRandom := false ;
91210: LD_ADDR_EXP 186
91214: PUSH
91215: LD_INT 0
91217: ST_TO_ADDR
// sShield := false ;
91218: LD_ADDR_EXP 187
91222: PUSH
91223: LD_INT 0
91225: ST_TO_ADDR
// sTime := false ;
91226: LD_ADDR_EXP 188
91230: PUSH
91231: LD_INT 0
91233: ST_TO_ADDR
// sTools := false ;
91234: LD_ADDR_EXP 189
91238: PUSH
91239: LD_INT 0
91241: ST_TO_ADDR
// sSold := false ;
91242: LD_ADDR_EXP 154
91246: PUSH
91247: LD_INT 0
91249: ST_TO_ADDR
// sDiff := false ;
91250: LD_ADDR_EXP 155
91254: PUSH
91255: LD_INT 0
91257: ST_TO_ADDR
// sFog := false ;
91258: LD_ADDR_EXP 158
91262: PUSH
91263: LD_INT 0
91265: ST_TO_ADDR
// sReset := false ;
91266: LD_ADDR_EXP 159
91270: PUSH
91271: LD_INT 0
91273: ST_TO_ADDR
// sSun := false ;
91274: LD_ADDR_EXP 160
91278: PUSH
91279: LD_INT 0
91281: ST_TO_ADDR
// sTiger := false ;
91282: LD_ADDR_EXP 156
91286: PUSH
91287: LD_INT 0
91289: ST_TO_ADDR
// sBomb := false ;
91290: LD_ADDR_EXP 157
91294: PUSH
91295: LD_INT 0
91297: ST_TO_ADDR
// sWound := false ;
91298: LD_ADDR_EXP 165
91302: PUSH
91303: LD_INT 0
91305: ST_TO_ADDR
// sBetray := false ;
91306: LD_ADDR_EXP 169
91310: PUSH
91311: LD_INT 0
91313: ST_TO_ADDR
// sContamin := false ;
91314: LD_ADDR_EXP 170
91318: PUSH
91319: LD_INT 0
91321: ST_TO_ADDR
// sOil := false ;
91322: LD_ADDR_EXP 172
91326: PUSH
91327: LD_INT 0
91329: ST_TO_ADDR
// sStu := false ;
91330: LD_ADDR_EXP 176
91334: PUSH
91335: LD_INT 0
91337: ST_TO_ADDR
// sBazooka := false ;
91338: LD_ADDR_EXP 179
91342: PUSH
91343: LD_INT 0
91345: ST_TO_ADDR
// sMortar := false ;
91346: LD_ADDR_EXP 180
91350: PUSH
91351: LD_INT 0
91353: ST_TO_ADDR
// sRanger := false ;
91354: LD_ADDR_EXP 190
91358: PUSH
91359: LD_INT 0
91361: ST_TO_ADDR
// end ;
91362: LD_VAR 0 1
91366: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
91367: LD_INT 0
91369: PPUSH
91370: PPUSH
91371: PPUSH
91372: PPUSH
91373: PPUSH
// result := [ ] ;
91374: LD_ADDR_VAR 0 1
91378: PUSH
91379: EMPTY
91380: ST_TO_ADDR
// if campaign_id = 1 then
91381: LD_OWVAR 69
91385: PUSH
91386: LD_INT 1
91388: EQUAL
91389: IFFALSE 94327
// begin case mission_number of 1 :
91391: LD_OWVAR 70
91395: PUSH
91396: LD_INT 1
91398: DOUBLE
91399: EQUAL
91400: IFTRUE 91404
91402: GO 91468
91404: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
91405: LD_ADDR_VAR 0 1
91409: PUSH
91410: LD_INT 2
91412: PUSH
91413: LD_INT 4
91415: PUSH
91416: LD_INT 11
91418: PUSH
91419: LD_INT 12
91421: PUSH
91422: LD_INT 15
91424: PUSH
91425: LD_INT 16
91427: PUSH
91428: LD_INT 22
91430: PUSH
91431: LD_INT 23
91433: PUSH
91434: LD_INT 26
91436: PUSH
91437: EMPTY
91438: LIST
91439: LIST
91440: LIST
91441: LIST
91442: LIST
91443: LIST
91444: LIST
91445: LIST
91446: LIST
91447: PUSH
91448: LD_INT 101
91450: PUSH
91451: LD_INT 102
91453: PUSH
91454: LD_INT 106
91456: PUSH
91457: EMPTY
91458: LIST
91459: LIST
91460: LIST
91461: PUSH
91462: EMPTY
91463: LIST
91464: LIST
91465: ST_TO_ADDR
91466: GO 94325
91468: LD_INT 2
91470: DOUBLE
91471: EQUAL
91472: IFTRUE 91476
91474: GO 91548
91476: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
91477: LD_ADDR_VAR 0 1
91481: PUSH
91482: LD_INT 2
91484: PUSH
91485: LD_INT 4
91487: PUSH
91488: LD_INT 11
91490: PUSH
91491: LD_INT 12
91493: PUSH
91494: LD_INT 15
91496: PUSH
91497: LD_INT 16
91499: PUSH
91500: LD_INT 22
91502: PUSH
91503: LD_INT 23
91505: PUSH
91506: LD_INT 26
91508: PUSH
91509: EMPTY
91510: LIST
91511: LIST
91512: LIST
91513: LIST
91514: LIST
91515: LIST
91516: LIST
91517: LIST
91518: LIST
91519: PUSH
91520: LD_INT 101
91522: PUSH
91523: LD_INT 102
91525: PUSH
91526: LD_INT 105
91528: PUSH
91529: LD_INT 106
91531: PUSH
91532: LD_INT 108
91534: PUSH
91535: EMPTY
91536: LIST
91537: LIST
91538: LIST
91539: LIST
91540: LIST
91541: PUSH
91542: EMPTY
91543: LIST
91544: LIST
91545: ST_TO_ADDR
91546: GO 94325
91548: LD_INT 3
91550: DOUBLE
91551: EQUAL
91552: IFTRUE 91556
91554: GO 91632
91556: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
91557: LD_ADDR_VAR 0 1
91561: PUSH
91562: LD_INT 2
91564: PUSH
91565: LD_INT 4
91567: PUSH
91568: LD_INT 5
91570: PUSH
91571: LD_INT 11
91573: PUSH
91574: LD_INT 12
91576: PUSH
91577: LD_INT 15
91579: PUSH
91580: LD_INT 16
91582: PUSH
91583: LD_INT 22
91585: PUSH
91586: LD_INT 26
91588: PUSH
91589: LD_INT 36
91591: PUSH
91592: EMPTY
91593: LIST
91594: LIST
91595: LIST
91596: LIST
91597: LIST
91598: LIST
91599: LIST
91600: LIST
91601: LIST
91602: LIST
91603: PUSH
91604: LD_INT 101
91606: PUSH
91607: LD_INT 102
91609: PUSH
91610: LD_INT 105
91612: PUSH
91613: LD_INT 106
91615: PUSH
91616: LD_INT 108
91618: PUSH
91619: EMPTY
91620: LIST
91621: LIST
91622: LIST
91623: LIST
91624: LIST
91625: PUSH
91626: EMPTY
91627: LIST
91628: LIST
91629: ST_TO_ADDR
91630: GO 94325
91632: LD_INT 4
91634: DOUBLE
91635: EQUAL
91636: IFTRUE 91640
91638: GO 91724
91640: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
91641: LD_ADDR_VAR 0 1
91645: PUSH
91646: LD_INT 2
91648: PUSH
91649: LD_INT 4
91651: PUSH
91652: LD_INT 5
91654: PUSH
91655: LD_INT 8
91657: PUSH
91658: LD_INT 11
91660: PUSH
91661: LD_INT 12
91663: PUSH
91664: LD_INT 15
91666: PUSH
91667: LD_INT 16
91669: PUSH
91670: LD_INT 22
91672: PUSH
91673: LD_INT 23
91675: PUSH
91676: LD_INT 26
91678: PUSH
91679: LD_INT 36
91681: PUSH
91682: EMPTY
91683: LIST
91684: LIST
91685: LIST
91686: LIST
91687: LIST
91688: LIST
91689: LIST
91690: LIST
91691: LIST
91692: LIST
91693: LIST
91694: LIST
91695: PUSH
91696: LD_INT 101
91698: PUSH
91699: LD_INT 102
91701: PUSH
91702: LD_INT 105
91704: PUSH
91705: LD_INT 106
91707: PUSH
91708: LD_INT 108
91710: PUSH
91711: EMPTY
91712: LIST
91713: LIST
91714: LIST
91715: LIST
91716: LIST
91717: PUSH
91718: EMPTY
91719: LIST
91720: LIST
91721: ST_TO_ADDR
91722: GO 94325
91724: LD_INT 5
91726: DOUBLE
91727: EQUAL
91728: IFTRUE 91732
91730: GO 91832
91732: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
91733: LD_ADDR_VAR 0 1
91737: PUSH
91738: LD_INT 2
91740: PUSH
91741: LD_INT 4
91743: PUSH
91744: LD_INT 5
91746: PUSH
91747: LD_INT 6
91749: PUSH
91750: LD_INT 8
91752: PUSH
91753: LD_INT 11
91755: PUSH
91756: LD_INT 12
91758: PUSH
91759: LD_INT 15
91761: PUSH
91762: LD_INT 16
91764: PUSH
91765: LD_INT 22
91767: PUSH
91768: LD_INT 23
91770: PUSH
91771: LD_INT 25
91773: PUSH
91774: LD_INT 26
91776: PUSH
91777: LD_INT 36
91779: PUSH
91780: EMPTY
91781: LIST
91782: LIST
91783: LIST
91784: LIST
91785: LIST
91786: LIST
91787: LIST
91788: LIST
91789: LIST
91790: LIST
91791: LIST
91792: LIST
91793: LIST
91794: LIST
91795: PUSH
91796: LD_INT 101
91798: PUSH
91799: LD_INT 102
91801: PUSH
91802: LD_INT 105
91804: PUSH
91805: LD_INT 106
91807: PUSH
91808: LD_INT 108
91810: PUSH
91811: LD_INT 109
91813: PUSH
91814: LD_INT 112
91816: PUSH
91817: EMPTY
91818: LIST
91819: LIST
91820: LIST
91821: LIST
91822: LIST
91823: LIST
91824: LIST
91825: PUSH
91826: EMPTY
91827: LIST
91828: LIST
91829: ST_TO_ADDR
91830: GO 94325
91832: LD_INT 6
91834: DOUBLE
91835: EQUAL
91836: IFTRUE 91840
91838: GO 91960
91840: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
91841: LD_ADDR_VAR 0 1
91845: PUSH
91846: LD_INT 2
91848: PUSH
91849: LD_INT 4
91851: PUSH
91852: LD_INT 5
91854: PUSH
91855: LD_INT 6
91857: PUSH
91858: LD_INT 8
91860: PUSH
91861: LD_INT 11
91863: PUSH
91864: LD_INT 12
91866: PUSH
91867: LD_INT 15
91869: PUSH
91870: LD_INT 16
91872: PUSH
91873: LD_INT 20
91875: PUSH
91876: LD_INT 21
91878: PUSH
91879: LD_INT 22
91881: PUSH
91882: LD_INT 23
91884: PUSH
91885: LD_INT 25
91887: PUSH
91888: LD_INT 26
91890: PUSH
91891: LD_INT 30
91893: PUSH
91894: LD_INT 31
91896: PUSH
91897: LD_INT 32
91899: PUSH
91900: LD_INT 36
91902: PUSH
91903: EMPTY
91904: LIST
91905: LIST
91906: LIST
91907: LIST
91908: LIST
91909: LIST
91910: LIST
91911: LIST
91912: LIST
91913: LIST
91914: LIST
91915: LIST
91916: LIST
91917: LIST
91918: LIST
91919: LIST
91920: LIST
91921: LIST
91922: LIST
91923: PUSH
91924: LD_INT 101
91926: PUSH
91927: LD_INT 102
91929: PUSH
91930: LD_INT 105
91932: PUSH
91933: LD_INT 106
91935: PUSH
91936: LD_INT 108
91938: PUSH
91939: LD_INT 109
91941: PUSH
91942: LD_INT 112
91944: PUSH
91945: EMPTY
91946: LIST
91947: LIST
91948: LIST
91949: LIST
91950: LIST
91951: LIST
91952: LIST
91953: PUSH
91954: EMPTY
91955: LIST
91956: LIST
91957: ST_TO_ADDR
91958: GO 94325
91960: LD_INT 7
91962: DOUBLE
91963: EQUAL
91964: IFTRUE 91968
91966: GO 92068
91968: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
91969: LD_ADDR_VAR 0 1
91973: PUSH
91974: LD_INT 2
91976: PUSH
91977: LD_INT 4
91979: PUSH
91980: LD_INT 5
91982: PUSH
91983: LD_INT 7
91985: PUSH
91986: LD_INT 11
91988: PUSH
91989: LD_INT 12
91991: PUSH
91992: LD_INT 15
91994: PUSH
91995: LD_INT 16
91997: PUSH
91998: LD_INT 20
92000: PUSH
92001: LD_INT 21
92003: PUSH
92004: LD_INT 22
92006: PUSH
92007: LD_INT 23
92009: PUSH
92010: LD_INT 25
92012: PUSH
92013: LD_INT 26
92015: PUSH
92016: EMPTY
92017: LIST
92018: LIST
92019: LIST
92020: LIST
92021: LIST
92022: LIST
92023: LIST
92024: LIST
92025: LIST
92026: LIST
92027: LIST
92028: LIST
92029: LIST
92030: LIST
92031: PUSH
92032: LD_INT 101
92034: PUSH
92035: LD_INT 102
92037: PUSH
92038: LD_INT 103
92040: PUSH
92041: LD_INT 105
92043: PUSH
92044: LD_INT 106
92046: PUSH
92047: LD_INT 108
92049: PUSH
92050: LD_INT 112
92052: PUSH
92053: EMPTY
92054: LIST
92055: LIST
92056: LIST
92057: LIST
92058: LIST
92059: LIST
92060: LIST
92061: PUSH
92062: EMPTY
92063: LIST
92064: LIST
92065: ST_TO_ADDR
92066: GO 94325
92068: LD_INT 8
92070: DOUBLE
92071: EQUAL
92072: IFTRUE 92076
92074: GO 92204
92076: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
92077: LD_ADDR_VAR 0 1
92081: PUSH
92082: LD_INT 2
92084: PUSH
92085: LD_INT 4
92087: PUSH
92088: LD_INT 5
92090: PUSH
92091: LD_INT 6
92093: PUSH
92094: LD_INT 7
92096: PUSH
92097: LD_INT 8
92099: PUSH
92100: LD_INT 11
92102: PUSH
92103: LD_INT 12
92105: PUSH
92106: LD_INT 15
92108: PUSH
92109: LD_INT 16
92111: PUSH
92112: LD_INT 20
92114: PUSH
92115: LD_INT 21
92117: PUSH
92118: LD_INT 22
92120: PUSH
92121: LD_INT 23
92123: PUSH
92124: LD_INT 25
92126: PUSH
92127: LD_INT 26
92129: PUSH
92130: LD_INT 30
92132: PUSH
92133: LD_INT 31
92135: PUSH
92136: LD_INT 32
92138: PUSH
92139: LD_INT 36
92141: PUSH
92142: EMPTY
92143: LIST
92144: LIST
92145: LIST
92146: LIST
92147: LIST
92148: LIST
92149: LIST
92150: LIST
92151: LIST
92152: LIST
92153: LIST
92154: LIST
92155: LIST
92156: LIST
92157: LIST
92158: LIST
92159: LIST
92160: LIST
92161: LIST
92162: LIST
92163: PUSH
92164: LD_INT 101
92166: PUSH
92167: LD_INT 102
92169: PUSH
92170: LD_INT 103
92172: PUSH
92173: LD_INT 105
92175: PUSH
92176: LD_INT 106
92178: PUSH
92179: LD_INT 108
92181: PUSH
92182: LD_INT 109
92184: PUSH
92185: LD_INT 112
92187: PUSH
92188: EMPTY
92189: LIST
92190: LIST
92191: LIST
92192: LIST
92193: LIST
92194: LIST
92195: LIST
92196: LIST
92197: PUSH
92198: EMPTY
92199: LIST
92200: LIST
92201: ST_TO_ADDR
92202: GO 94325
92204: LD_INT 9
92206: DOUBLE
92207: EQUAL
92208: IFTRUE 92212
92210: GO 92348
92212: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
92213: LD_ADDR_VAR 0 1
92217: PUSH
92218: LD_INT 2
92220: PUSH
92221: LD_INT 4
92223: PUSH
92224: LD_INT 5
92226: PUSH
92227: LD_INT 6
92229: PUSH
92230: LD_INT 7
92232: PUSH
92233: LD_INT 8
92235: PUSH
92236: LD_INT 11
92238: PUSH
92239: LD_INT 12
92241: PUSH
92242: LD_INT 15
92244: PUSH
92245: LD_INT 16
92247: PUSH
92248: LD_INT 20
92250: PUSH
92251: LD_INT 21
92253: PUSH
92254: LD_INT 22
92256: PUSH
92257: LD_INT 23
92259: PUSH
92260: LD_INT 25
92262: PUSH
92263: LD_INT 26
92265: PUSH
92266: LD_INT 28
92268: PUSH
92269: LD_INT 30
92271: PUSH
92272: LD_INT 31
92274: PUSH
92275: LD_INT 32
92277: PUSH
92278: LD_INT 36
92280: PUSH
92281: EMPTY
92282: LIST
92283: LIST
92284: LIST
92285: LIST
92286: LIST
92287: LIST
92288: LIST
92289: LIST
92290: LIST
92291: LIST
92292: LIST
92293: LIST
92294: LIST
92295: LIST
92296: LIST
92297: LIST
92298: LIST
92299: LIST
92300: LIST
92301: LIST
92302: LIST
92303: PUSH
92304: LD_INT 101
92306: PUSH
92307: LD_INT 102
92309: PUSH
92310: LD_INT 103
92312: PUSH
92313: LD_INT 105
92315: PUSH
92316: LD_INT 106
92318: PUSH
92319: LD_INT 108
92321: PUSH
92322: LD_INT 109
92324: PUSH
92325: LD_INT 112
92327: PUSH
92328: LD_INT 114
92330: PUSH
92331: EMPTY
92332: LIST
92333: LIST
92334: LIST
92335: LIST
92336: LIST
92337: LIST
92338: LIST
92339: LIST
92340: LIST
92341: PUSH
92342: EMPTY
92343: LIST
92344: LIST
92345: ST_TO_ADDR
92346: GO 94325
92348: LD_INT 10
92350: DOUBLE
92351: EQUAL
92352: IFTRUE 92356
92354: GO 92540
92356: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
92357: LD_ADDR_VAR 0 1
92361: PUSH
92362: LD_INT 2
92364: PUSH
92365: LD_INT 4
92367: PUSH
92368: LD_INT 5
92370: PUSH
92371: LD_INT 6
92373: PUSH
92374: LD_INT 7
92376: PUSH
92377: LD_INT 8
92379: PUSH
92380: LD_INT 9
92382: PUSH
92383: LD_INT 10
92385: PUSH
92386: LD_INT 11
92388: PUSH
92389: LD_INT 12
92391: PUSH
92392: LD_INT 13
92394: PUSH
92395: LD_INT 14
92397: PUSH
92398: LD_INT 15
92400: PUSH
92401: LD_INT 16
92403: PUSH
92404: LD_INT 17
92406: PUSH
92407: LD_INT 18
92409: PUSH
92410: LD_INT 19
92412: PUSH
92413: LD_INT 20
92415: PUSH
92416: LD_INT 21
92418: PUSH
92419: LD_INT 22
92421: PUSH
92422: LD_INT 23
92424: PUSH
92425: LD_INT 24
92427: PUSH
92428: LD_INT 25
92430: PUSH
92431: LD_INT 26
92433: PUSH
92434: LD_INT 28
92436: PUSH
92437: LD_INT 30
92439: PUSH
92440: LD_INT 31
92442: PUSH
92443: LD_INT 32
92445: PUSH
92446: LD_INT 36
92448: PUSH
92449: EMPTY
92450: LIST
92451: LIST
92452: LIST
92453: LIST
92454: LIST
92455: LIST
92456: LIST
92457: LIST
92458: LIST
92459: LIST
92460: LIST
92461: LIST
92462: LIST
92463: LIST
92464: LIST
92465: LIST
92466: LIST
92467: LIST
92468: LIST
92469: LIST
92470: LIST
92471: LIST
92472: LIST
92473: LIST
92474: LIST
92475: LIST
92476: LIST
92477: LIST
92478: LIST
92479: PUSH
92480: LD_INT 101
92482: PUSH
92483: LD_INT 102
92485: PUSH
92486: LD_INT 103
92488: PUSH
92489: LD_INT 104
92491: PUSH
92492: LD_INT 105
92494: PUSH
92495: LD_INT 106
92497: PUSH
92498: LD_INT 107
92500: PUSH
92501: LD_INT 108
92503: PUSH
92504: LD_INT 109
92506: PUSH
92507: LD_INT 110
92509: PUSH
92510: LD_INT 111
92512: PUSH
92513: LD_INT 112
92515: PUSH
92516: LD_INT 114
92518: PUSH
92519: EMPTY
92520: LIST
92521: LIST
92522: LIST
92523: LIST
92524: LIST
92525: LIST
92526: LIST
92527: LIST
92528: LIST
92529: LIST
92530: LIST
92531: LIST
92532: LIST
92533: PUSH
92534: EMPTY
92535: LIST
92536: LIST
92537: ST_TO_ADDR
92538: GO 94325
92540: LD_INT 11
92542: DOUBLE
92543: EQUAL
92544: IFTRUE 92548
92546: GO 92740
92548: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
92549: LD_ADDR_VAR 0 1
92553: PUSH
92554: LD_INT 2
92556: PUSH
92557: LD_INT 3
92559: PUSH
92560: LD_INT 4
92562: PUSH
92563: LD_INT 5
92565: PUSH
92566: LD_INT 6
92568: PUSH
92569: LD_INT 7
92571: PUSH
92572: LD_INT 8
92574: PUSH
92575: LD_INT 9
92577: PUSH
92578: LD_INT 10
92580: PUSH
92581: LD_INT 11
92583: PUSH
92584: LD_INT 12
92586: PUSH
92587: LD_INT 13
92589: PUSH
92590: LD_INT 14
92592: PUSH
92593: LD_INT 15
92595: PUSH
92596: LD_INT 16
92598: PUSH
92599: LD_INT 17
92601: PUSH
92602: LD_INT 18
92604: PUSH
92605: LD_INT 19
92607: PUSH
92608: LD_INT 20
92610: PUSH
92611: LD_INT 21
92613: PUSH
92614: LD_INT 22
92616: PUSH
92617: LD_INT 23
92619: PUSH
92620: LD_INT 24
92622: PUSH
92623: LD_INT 25
92625: PUSH
92626: LD_INT 26
92628: PUSH
92629: LD_INT 28
92631: PUSH
92632: LD_INT 30
92634: PUSH
92635: LD_INT 31
92637: PUSH
92638: LD_INT 32
92640: PUSH
92641: LD_INT 34
92643: PUSH
92644: LD_INT 36
92646: PUSH
92647: EMPTY
92648: LIST
92649: LIST
92650: LIST
92651: LIST
92652: LIST
92653: LIST
92654: LIST
92655: LIST
92656: LIST
92657: LIST
92658: LIST
92659: LIST
92660: LIST
92661: LIST
92662: LIST
92663: LIST
92664: LIST
92665: LIST
92666: LIST
92667: LIST
92668: LIST
92669: LIST
92670: LIST
92671: LIST
92672: LIST
92673: LIST
92674: LIST
92675: LIST
92676: LIST
92677: LIST
92678: LIST
92679: PUSH
92680: LD_INT 101
92682: PUSH
92683: LD_INT 102
92685: PUSH
92686: LD_INT 103
92688: PUSH
92689: LD_INT 104
92691: PUSH
92692: LD_INT 105
92694: PUSH
92695: LD_INT 106
92697: PUSH
92698: LD_INT 107
92700: PUSH
92701: LD_INT 108
92703: PUSH
92704: LD_INT 109
92706: PUSH
92707: LD_INT 110
92709: PUSH
92710: LD_INT 111
92712: PUSH
92713: LD_INT 112
92715: PUSH
92716: LD_INT 114
92718: PUSH
92719: EMPTY
92720: LIST
92721: LIST
92722: LIST
92723: LIST
92724: LIST
92725: LIST
92726: LIST
92727: LIST
92728: LIST
92729: LIST
92730: LIST
92731: LIST
92732: LIST
92733: PUSH
92734: EMPTY
92735: LIST
92736: LIST
92737: ST_TO_ADDR
92738: GO 94325
92740: LD_INT 12
92742: DOUBLE
92743: EQUAL
92744: IFTRUE 92748
92746: GO 92956
92748: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
92749: LD_ADDR_VAR 0 1
92753: PUSH
92754: LD_INT 1
92756: PUSH
92757: LD_INT 2
92759: PUSH
92760: LD_INT 3
92762: PUSH
92763: LD_INT 4
92765: PUSH
92766: LD_INT 5
92768: PUSH
92769: LD_INT 6
92771: PUSH
92772: LD_INT 7
92774: PUSH
92775: LD_INT 8
92777: PUSH
92778: LD_INT 9
92780: PUSH
92781: LD_INT 10
92783: PUSH
92784: LD_INT 11
92786: PUSH
92787: LD_INT 12
92789: PUSH
92790: LD_INT 13
92792: PUSH
92793: LD_INT 14
92795: PUSH
92796: LD_INT 15
92798: PUSH
92799: LD_INT 16
92801: PUSH
92802: LD_INT 17
92804: PUSH
92805: LD_INT 18
92807: PUSH
92808: LD_INT 19
92810: PUSH
92811: LD_INT 20
92813: PUSH
92814: LD_INT 21
92816: PUSH
92817: LD_INT 22
92819: PUSH
92820: LD_INT 23
92822: PUSH
92823: LD_INT 24
92825: PUSH
92826: LD_INT 25
92828: PUSH
92829: LD_INT 26
92831: PUSH
92832: LD_INT 27
92834: PUSH
92835: LD_INT 28
92837: PUSH
92838: LD_INT 30
92840: PUSH
92841: LD_INT 31
92843: PUSH
92844: LD_INT 32
92846: PUSH
92847: LD_INT 33
92849: PUSH
92850: LD_INT 34
92852: PUSH
92853: LD_INT 36
92855: PUSH
92856: EMPTY
92857: LIST
92858: LIST
92859: LIST
92860: LIST
92861: LIST
92862: LIST
92863: LIST
92864: LIST
92865: LIST
92866: LIST
92867: LIST
92868: LIST
92869: LIST
92870: LIST
92871: LIST
92872: LIST
92873: LIST
92874: LIST
92875: LIST
92876: LIST
92877: LIST
92878: LIST
92879: LIST
92880: LIST
92881: LIST
92882: LIST
92883: LIST
92884: LIST
92885: LIST
92886: LIST
92887: LIST
92888: LIST
92889: LIST
92890: LIST
92891: PUSH
92892: LD_INT 101
92894: PUSH
92895: LD_INT 102
92897: PUSH
92898: LD_INT 103
92900: PUSH
92901: LD_INT 104
92903: PUSH
92904: LD_INT 105
92906: PUSH
92907: LD_INT 106
92909: PUSH
92910: LD_INT 107
92912: PUSH
92913: LD_INT 108
92915: PUSH
92916: LD_INT 109
92918: PUSH
92919: LD_INT 110
92921: PUSH
92922: LD_INT 111
92924: PUSH
92925: LD_INT 112
92927: PUSH
92928: LD_INT 113
92930: PUSH
92931: LD_INT 114
92933: PUSH
92934: EMPTY
92935: LIST
92936: LIST
92937: LIST
92938: LIST
92939: LIST
92940: LIST
92941: LIST
92942: LIST
92943: LIST
92944: LIST
92945: LIST
92946: LIST
92947: LIST
92948: LIST
92949: PUSH
92950: EMPTY
92951: LIST
92952: LIST
92953: ST_TO_ADDR
92954: GO 94325
92956: LD_INT 13
92958: DOUBLE
92959: EQUAL
92960: IFTRUE 92964
92962: GO 93160
92964: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
92965: LD_ADDR_VAR 0 1
92969: PUSH
92970: LD_INT 1
92972: PUSH
92973: LD_INT 2
92975: PUSH
92976: LD_INT 3
92978: PUSH
92979: LD_INT 4
92981: PUSH
92982: LD_INT 5
92984: PUSH
92985: LD_INT 8
92987: PUSH
92988: LD_INT 9
92990: PUSH
92991: LD_INT 10
92993: PUSH
92994: LD_INT 11
92996: PUSH
92997: LD_INT 12
92999: PUSH
93000: LD_INT 14
93002: PUSH
93003: LD_INT 15
93005: PUSH
93006: LD_INT 16
93008: PUSH
93009: LD_INT 17
93011: PUSH
93012: LD_INT 18
93014: PUSH
93015: LD_INT 19
93017: PUSH
93018: LD_INT 20
93020: PUSH
93021: LD_INT 21
93023: PUSH
93024: LD_INT 22
93026: PUSH
93027: LD_INT 23
93029: PUSH
93030: LD_INT 24
93032: PUSH
93033: LD_INT 25
93035: PUSH
93036: LD_INT 26
93038: PUSH
93039: LD_INT 27
93041: PUSH
93042: LD_INT 28
93044: PUSH
93045: LD_INT 30
93047: PUSH
93048: LD_INT 31
93050: PUSH
93051: LD_INT 32
93053: PUSH
93054: LD_INT 33
93056: PUSH
93057: LD_INT 34
93059: PUSH
93060: LD_INT 36
93062: PUSH
93063: EMPTY
93064: LIST
93065: LIST
93066: LIST
93067: LIST
93068: LIST
93069: LIST
93070: LIST
93071: LIST
93072: LIST
93073: LIST
93074: LIST
93075: LIST
93076: LIST
93077: LIST
93078: LIST
93079: LIST
93080: LIST
93081: LIST
93082: LIST
93083: LIST
93084: LIST
93085: LIST
93086: LIST
93087: LIST
93088: LIST
93089: LIST
93090: LIST
93091: LIST
93092: LIST
93093: LIST
93094: LIST
93095: PUSH
93096: LD_INT 101
93098: PUSH
93099: LD_INT 102
93101: PUSH
93102: LD_INT 103
93104: PUSH
93105: LD_INT 104
93107: PUSH
93108: LD_INT 105
93110: PUSH
93111: LD_INT 106
93113: PUSH
93114: LD_INT 107
93116: PUSH
93117: LD_INT 108
93119: PUSH
93120: LD_INT 109
93122: PUSH
93123: LD_INT 110
93125: PUSH
93126: LD_INT 111
93128: PUSH
93129: LD_INT 112
93131: PUSH
93132: LD_INT 113
93134: PUSH
93135: LD_INT 114
93137: PUSH
93138: EMPTY
93139: LIST
93140: LIST
93141: LIST
93142: LIST
93143: LIST
93144: LIST
93145: LIST
93146: LIST
93147: LIST
93148: LIST
93149: LIST
93150: LIST
93151: LIST
93152: LIST
93153: PUSH
93154: EMPTY
93155: LIST
93156: LIST
93157: ST_TO_ADDR
93158: GO 94325
93160: LD_INT 14
93162: DOUBLE
93163: EQUAL
93164: IFTRUE 93168
93166: GO 93380
93168: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
93169: LD_ADDR_VAR 0 1
93173: PUSH
93174: LD_INT 1
93176: PUSH
93177: LD_INT 2
93179: PUSH
93180: LD_INT 3
93182: PUSH
93183: LD_INT 4
93185: PUSH
93186: LD_INT 5
93188: PUSH
93189: LD_INT 6
93191: PUSH
93192: LD_INT 7
93194: PUSH
93195: LD_INT 8
93197: PUSH
93198: LD_INT 9
93200: PUSH
93201: LD_INT 10
93203: PUSH
93204: LD_INT 11
93206: PUSH
93207: LD_INT 12
93209: PUSH
93210: LD_INT 13
93212: PUSH
93213: LD_INT 14
93215: PUSH
93216: LD_INT 15
93218: PUSH
93219: LD_INT 16
93221: PUSH
93222: LD_INT 17
93224: PUSH
93225: LD_INT 18
93227: PUSH
93228: LD_INT 19
93230: PUSH
93231: LD_INT 20
93233: PUSH
93234: LD_INT 21
93236: PUSH
93237: LD_INT 22
93239: PUSH
93240: LD_INT 23
93242: PUSH
93243: LD_INT 24
93245: PUSH
93246: LD_INT 25
93248: PUSH
93249: LD_INT 26
93251: PUSH
93252: LD_INT 27
93254: PUSH
93255: LD_INT 28
93257: PUSH
93258: LD_INT 29
93260: PUSH
93261: LD_INT 30
93263: PUSH
93264: LD_INT 31
93266: PUSH
93267: LD_INT 32
93269: PUSH
93270: LD_INT 33
93272: PUSH
93273: LD_INT 34
93275: PUSH
93276: LD_INT 36
93278: PUSH
93279: EMPTY
93280: LIST
93281: LIST
93282: LIST
93283: LIST
93284: LIST
93285: LIST
93286: LIST
93287: LIST
93288: LIST
93289: LIST
93290: LIST
93291: LIST
93292: LIST
93293: LIST
93294: LIST
93295: LIST
93296: LIST
93297: LIST
93298: LIST
93299: LIST
93300: LIST
93301: LIST
93302: LIST
93303: LIST
93304: LIST
93305: LIST
93306: LIST
93307: LIST
93308: LIST
93309: LIST
93310: LIST
93311: LIST
93312: LIST
93313: LIST
93314: LIST
93315: PUSH
93316: LD_INT 101
93318: PUSH
93319: LD_INT 102
93321: PUSH
93322: LD_INT 103
93324: PUSH
93325: LD_INT 104
93327: PUSH
93328: LD_INT 105
93330: PUSH
93331: LD_INT 106
93333: PUSH
93334: LD_INT 107
93336: PUSH
93337: LD_INT 108
93339: PUSH
93340: LD_INT 109
93342: PUSH
93343: LD_INT 110
93345: PUSH
93346: LD_INT 111
93348: PUSH
93349: LD_INT 112
93351: PUSH
93352: LD_INT 113
93354: PUSH
93355: LD_INT 114
93357: PUSH
93358: EMPTY
93359: LIST
93360: LIST
93361: LIST
93362: LIST
93363: LIST
93364: LIST
93365: LIST
93366: LIST
93367: LIST
93368: LIST
93369: LIST
93370: LIST
93371: LIST
93372: LIST
93373: PUSH
93374: EMPTY
93375: LIST
93376: LIST
93377: ST_TO_ADDR
93378: GO 94325
93380: LD_INT 15
93382: DOUBLE
93383: EQUAL
93384: IFTRUE 93388
93386: GO 93600
93388: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
93389: LD_ADDR_VAR 0 1
93393: PUSH
93394: LD_INT 1
93396: PUSH
93397: LD_INT 2
93399: PUSH
93400: LD_INT 3
93402: PUSH
93403: LD_INT 4
93405: PUSH
93406: LD_INT 5
93408: PUSH
93409: LD_INT 6
93411: PUSH
93412: LD_INT 7
93414: PUSH
93415: LD_INT 8
93417: PUSH
93418: LD_INT 9
93420: PUSH
93421: LD_INT 10
93423: PUSH
93424: LD_INT 11
93426: PUSH
93427: LD_INT 12
93429: PUSH
93430: LD_INT 13
93432: PUSH
93433: LD_INT 14
93435: PUSH
93436: LD_INT 15
93438: PUSH
93439: LD_INT 16
93441: PUSH
93442: LD_INT 17
93444: PUSH
93445: LD_INT 18
93447: PUSH
93448: LD_INT 19
93450: PUSH
93451: LD_INT 20
93453: PUSH
93454: LD_INT 21
93456: PUSH
93457: LD_INT 22
93459: PUSH
93460: LD_INT 23
93462: PUSH
93463: LD_INT 24
93465: PUSH
93466: LD_INT 25
93468: PUSH
93469: LD_INT 26
93471: PUSH
93472: LD_INT 27
93474: PUSH
93475: LD_INT 28
93477: PUSH
93478: LD_INT 29
93480: PUSH
93481: LD_INT 30
93483: PUSH
93484: LD_INT 31
93486: PUSH
93487: LD_INT 32
93489: PUSH
93490: LD_INT 33
93492: PUSH
93493: LD_INT 34
93495: PUSH
93496: LD_INT 36
93498: PUSH
93499: EMPTY
93500: LIST
93501: LIST
93502: LIST
93503: LIST
93504: LIST
93505: LIST
93506: LIST
93507: LIST
93508: LIST
93509: LIST
93510: LIST
93511: LIST
93512: LIST
93513: LIST
93514: LIST
93515: LIST
93516: LIST
93517: LIST
93518: LIST
93519: LIST
93520: LIST
93521: LIST
93522: LIST
93523: LIST
93524: LIST
93525: LIST
93526: LIST
93527: LIST
93528: LIST
93529: LIST
93530: LIST
93531: LIST
93532: LIST
93533: LIST
93534: LIST
93535: PUSH
93536: LD_INT 101
93538: PUSH
93539: LD_INT 102
93541: PUSH
93542: LD_INT 103
93544: PUSH
93545: LD_INT 104
93547: PUSH
93548: LD_INT 105
93550: PUSH
93551: LD_INT 106
93553: PUSH
93554: LD_INT 107
93556: PUSH
93557: LD_INT 108
93559: PUSH
93560: LD_INT 109
93562: PUSH
93563: LD_INT 110
93565: PUSH
93566: LD_INT 111
93568: PUSH
93569: LD_INT 112
93571: PUSH
93572: LD_INT 113
93574: PUSH
93575: LD_INT 114
93577: PUSH
93578: EMPTY
93579: LIST
93580: LIST
93581: LIST
93582: LIST
93583: LIST
93584: LIST
93585: LIST
93586: LIST
93587: LIST
93588: LIST
93589: LIST
93590: LIST
93591: LIST
93592: LIST
93593: PUSH
93594: EMPTY
93595: LIST
93596: LIST
93597: ST_TO_ADDR
93598: GO 94325
93600: LD_INT 16
93602: DOUBLE
93603: EQUAL
93604: IFTRUE 93608
93606: GO 93732
93608: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
93609: LD_ADDR_VAR 0 1
93613: PUSH
93614: LD_INT 2
93616: PUSH
93617: LD_INT 4
93619: PUSH
93620: LD_INT 5
93622: PUSH
93623: LD_INT 7
93625: PUSH
93626: LD_INT 11
93628: PUSH
93629: LD_INT 12
93631: PUSH
93632: LD_INT 15
93634: PUSH
93635: LD_INT 16
93637: PUSH
93638: LD_INT 20
93640: PUSH
93641: LD_INT 21
93643: PUSH
93644: LD_INT 22
93646: PUSH
93647: LD_INT 23
93649: PUSH
93650: LD_INT 25
93652: PUSH
93653: LD_INT 26
93655: PUSH
93656: LD_INT 30
93658: PUSH
93659: LD_INT 31
93661: PUSH
93662: LD_INT 32
93664: PUSH
93665: LD_INT 33
93667: PUSH
93668: LD_INT 34
93670: PUSH
93671: EMPTY
93672: LIST
93673: LIST
93674: LIST
93675: LIST
93676: LIST
93677: LIST
93678: LIST
93679: LIST
93680: LIST
93681: LIST
93682: LIST
93683: LIST
93684: LIST
93685: LIST
93686: LIST
93687: LIST
93688: LIST
93689: LIST
93690: LIST
93691: PUSH
93692: LD_INT 101
93694: PUSH
93695: LD_INT 102
93697: PUSH
93698: LD_INT 103
93700: PUSH
93701: LD_INT 106
93703: PUSH
93704: LD_INT 108
93706: PUSH
93707: LD_INT 112
93709: PUSH
93710: LD_INT 113
93712: PUSH
93713: LD_INT 114
93715: PUSH
93716: EMPTY
93717: LIST
93718: LIST
93719: LIST
93720: LIST
93721: LIST
93722: LIST
93723: LIST
93724: LIST
93725: PUSH
93726: EMPTY
93727: LIST
93728: LIST
93729: ST_TO_ADDR
93730: GO 94325
93732: LD_INT 17
93734: DOUBLE
93735: EQUAL
93736: IFTRUE 93740
93738: GO 93952
93740: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
93741: LD_ADDR_VAR 0 1
93745: PUSH
93746: LD_INT 1
93748: PUSH
93749: LD_INT 2
93751: PUSH
93752: LD_INT 3
93754: PUSH
93755: LD_INT 4
93757: PUSH
93758: LD_INT 5
93760: PUSH
93761: LD_INT 6
93763: PUSH
93764: LD_INT 7
93766: PUSH
93767: LD_INT 8
93769: PUSH
93770: LD_INT 9
93772: PUSH
93773: LD_INT 10
93775: PUSH
93776: LD_INT 11
93778: PUSH
93779: LD_INT 12
93781: PUSH
93782: LD_INT 13
93784: PUSH
93785: LD_INT 14
93787: PUSH
93788: LD_INT 15
93790: PUSH
93791: LD_INT 16
93793: PUSH
93794: LD_INT 17
93796: PUSH
93797: LD_INT 18
93799: PUSH
93800: LD_INT 19
93802: PUSH
93803: LD_INT 20
93805: PUSH
93806: LD_INT 21
93808: PUSH
93809: LD_INT 22
93811: PUSH
93812: LD_INT 23
93814: PUSH
93815: LD_INT 24
93817: PUSH
93818: LD_INT 25
93820: PUSH
93821: LD_INT 26
93823: PUSH
93824: LD_INT 27
93826: PUSH
93827: LD_INT 28
93829: PUSH
93830: LD_INT 29
93832: PUSH
93833: LD_INT 30
93835: PUSH
93836: LD_INT 31
93838: PUSH
93839: LD_INT 32
93841: PUSH
93842: LD_INT 33
93844: PUSH
93845: LD_INT 34
93847: PUSH
93848: LD_INT 36
93850: PUSH
93851: EMPTY
93852: LIST
93853: LIST
93854: LIST
93855: LIST
93856: LIST
93857: LIST
93858: LIST
93859: LIST
93860: LIST
93861: LIST
93862: LIST
93863: LIST
93864: LIST
93865: LIST
93866: LIST
93867: LIST
93868: LIST
93869: LIST
93870: LIST
93871: LIST
93872: LIST
93873: LIST
93874: LIST
93875: LIST
93876: LIST
93877: LIST
93878: LIST
93879: LIST
93880: LIST
93881: LIST
93882: LIST
93883: LIST
93884: LIST
93885: LIST
93886: LIST
93887: PUSH
93888: LD_INT 101
93890: PUSH
93891: LD_INT 102
93893: PUSH
93894: LD_INT 103
93896: PUSH
93897: LD_INT 104
93899: PUSH
93900: LD_INT 105
93902: PUSH
93903: LD_INT 106
93905: PUSH
93906: LD_INT 107
93908: PUSH
93909: LD_INT 108
93911: PUSH
93912: LD_INT 109
93914: PUSH
93915: LD_INT 110
93917: PUSH
93918: LD_INT 111
93920: PUSH
93921: LD_INT 112
93923: PUSH
93924: LD_INT 113
93926: PUSH
93927: LD_INT 114
93929: PUSH
93930: EMPTY
93931: LIST
93932: LIST
93933: LIST
93934: LIST
93935: LIST
93936: LIST
93937: LIST
93938: LIST
93939: LIST
93940: LIST
93941: LIST
93942: LIST
93943: LIST
93944: LIST
93945: PUSH
93946: EMPTY
93947: LIST
93948: LIST
93949: ST_TO_ADDR
93950: GO 94325
93952: LD_INT 18
93954: DOUBLE
93955: EQUAL
93956: IFTRUE 93960
93958: GO 94096
93960: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
93961: LD_ADDR_VAR 0 1
93965: PUSH
93966: LD_INT 2
93968: PUSH
93969: LD_INT 4
93971: PUSH
93972: LD_INT 5
93974: PUSH
93975: LD_INT 7
93977: PUSH
93978: LD_INT 11
93980: PUSH
93981: LD_INT 12
93983: PUSH
93984: LD_INT 15
93986: PUSH
93987: LD_INT 16
93989: PUSH
93990: LD_INT 20
93992: PUSH
93993: LD_INT 21
93995: PUSH
93996: LD_INT 22
93998: PUSH
93999: LD_INT 23
94001: PUSH
94002: LD_INT 25
94004: PUSH
94005: LD_INT 26
94007: PUSH
94008: LD_INT 30
94010: PUSH
94011: LD_INT 31
94013: PUSH
94014: LD_INT 32
94016: PUSH
94017: LD_INT 33
94019: PUSH
94020: LD_INT 34
94022: PUSH
94023: LD_INT 35
94025: PUSH
94026: LD_INT 36
94028: PUSH
94029: EMPTY
94030: LIST
94031: LIST
94032: LIST
94033: LIST
94034: LIST
94035: LIST
94036: LIST
94037: LIST
94038: LIST
94039: LIST
94040: LIST
94041: LIST
94042: LIST
94043: LIST
94044: LIST
94045: LIST
94046: LIST
94047: LIST
94048: LIST
94049: LIST
94050: LIST
94051: PUSH
94052: LD_INT 101
94054: PUSH
94055: LD_INT 102
94057: PUSH
94058: LD_INT 103
94060: PUSH
94061: LD_INT 106
94063: PUSH
94064: LD_INT 108
94066: PUSH
94067: LD_INT 112
94069: PUSH
94070: LD_INT 113
94072: PUSH
94073: LD_INT 114
94075: PUSH
94076: LD_INT 115
94078: PUSH
94079: EMPTY
94080: LIST
94081: LIST
94082: LIST
94083: LIST
94084: LIST
94085: LIST
94086: LIST
94087: LIST
94088: LIST
94089: PUSH
94090: EMPTY
94091: LIST
94092: LIST
94093: ST_TO_ADDR
94094: GO 94325
94096: LD_INT 19
94098: DOUBLE
94099: EQUAL
94100: IFTRUE 94104
94102: GO 94324
94104: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
94105: LD_ADDR_VAR 0 1
94109: PUSH
94110: LD_INT 1
94112: PUSH
94113: LD_INT 2
94115: PUSH
94116: LD_INT 3
94118: PUSH
94119: LD_INT 4
94121: PUSH
94122: LD_INT 5
94124: PUSH
94125: LD_INT 6
94127: PUSH
94128: LD_INT 7
94130: PUSH
94131: LD_INT 8
94133: PUSH
94134: LD_INT 9
94136: PUSH
94137: LD_INT 10
94139: PUSH
94140: LD_INT 11
94142: PUSH
94143: LD_INT 12
94145: PUSH
94146: LD_INT 13
94148: PUSH
94149: LD_INT 14
94151: PUSH
94152: LD_INT 15
94154: PUSH
94155: LD_INT 16
94157: PUSH
94158: LD_INT 17
94160: PUSH
94161: LD_INT 18
94163: PUSH
94164: LD_INT 19
94166: PUSH
94167: LD_INT 20
94169: PUSH
94170: LD_INT 21
94172: PUSH
94173: LD_INT 22
94175: PUSH
94176: LD_INT 23
94178: PUSH
94179: LD_INT 24
94181: PUSH
94182: LD_INT 25
94184: PUSH
94185: LD_INT 26
94187: PUSH
94188: LD_INT 27
94190: PUSH
94191: LD_INT 28
94193: PUSH
94194: LD_INT 29
94196: PUSH
94197: LD_INT 30
94199: PUSH
94200: LD_INT 31
94202: PUSH
94203: LD_INT 32
94205: PUSH
94206: LD_INT 33
94208: PUSH
94209: LD_INT 34
94211: PUSH
94212: LD_INT 35
94214: PUSH
94215: LD_INT 36
94217: PUSH
94218: EMPTY
94219: LIST
94220: LIST
94221: LIST
94222: LIST
94223: LIST
94224: LIST
94225: LIST
94226: LIST
94227: LIST
94228: LIST
94229: LIST
94230: LIST
94231: LIST
94232: LIST
94233: LIST
94234: LIST
94235: LIST
94236: LIST
94237: LIST
94238: LIST
94239: LIST
94240: LIST
94241: LIST
94242: LIST
94243: LIST
94244: LIST
94245: LIST
94246: LIST
94247: LIST
94248: LIST
94249: LIST
94250: LIST
94251: LIST
94252: LIST
94253: LIST
94254: LIST
94255: PUSH
94256: LD_INT 101
94258: PUSH
94259: LD_INT 102
94261: PUSH
94262: LD_INT 103
94264: PUSH
94265: LD_INT 104
94267: PUSH
94268: LD_INT 105
94270: PUSH
94271: LD_INT 106
94273: PUSH
94274: LD_INT 107
94276: PUSH
94277: LD_INT 108
94279: PUSH
94280: LD_INT 109
94282: PUSH
94283: LD_INT 110
94285: PUSH
94286: LD_INT 111
94288: PUSH
94289: LD_INT 112
94291: PUSH
94292: LD_INT 113
94294: PUSH
94295: LD_INT 114
94297: PUSH
94298: LD_INT 115
94300: PUSH
94301: EMPTY
94302: LIST
94303: LIST
94304: LIST
94305: LIST
94306: LIST
94307: LIST
94308: LIST
94309: LIST
94310: LIST
94311: LIST
94312: LIST
94313: LIST
94314: LIST
94315: LIST
94316: LIST
94317: PUSH
94318: EMPTY
94319: LIST
94320: LIST
94321: ST_TO_ADDR
94322: GO 94325
94324: POP
// end else
94325: GO 94544
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
94327: LD_ADDR_VAR 0 1
94331: PUSH
94332: LD_INT 1
94334: PUSH
94335: LD_INT 2
94337: PUSH
94338: LD_INT 3
94340: PUSH
94341: LD_INT 4
94343: PUSH
94344: LD_INT 5
94346: PUSH
94347: LD_INT 6
94349: PUSH
94350: LD_INT 7
94352: PUSH
94353: LD_INT 8
94355: PUSH
94356: LD_INT 9
94358: PUSH
94359: LD_INT 10
94361: PUSH
94362: LD_INT 11
94364: PUSH
94365: LD_INT 12
94367: PUSH
94368: LD_INT 13
94370: PUSH
94371: LD_INT 14
94373: PUSH
94374: LD_INT 15
94376: PUSH
94377: LD_INT 16
94379: PUSH
94380: LD_INT 17
94382: PUSH
94383: LD_INT 18
94385: PUSH
94386: LD_INT 19
94388: PUSH
94389: LD_INT 20
94391: PUSH
94392: LD_INT 21
94394: PUSH
94395: LD_INT 22
94397: PUSH
94398: LD_INT 23
94400: PUSH
94401: LD_INT 24
94403: PUSH
94404: LD_INT 25
94406: PUSH
94407: LD_INT 26
94409: PUSH
94410: LD_INT 27
94412: PUSH
94413: LD_INT 28
94415: PUSH
94416: LD_INT 29
94418: PUSH
94419: LD_INT 30
94421: PUSH
94422: LD_INT 31
94424: PUSH
94425: LD_INT 32
94427: PUSH
94428: LD_INT 33
94430: PUSH
94431: LD_INT 34
94433: PUSH
94434: LD_INT 35
94436: PUSH
94437: LD_INT 36
94439: PUSH
94440: EMPTY
94441: LIST
94442: LIST
94443: LIST
94444: LIST
94445: LIST
94446: LIST
94447: LIST
94448: LIST
94449: LIST
94450: LIST
94451: LIST
94452: LIST
94453: LIST
94454: LIST
94455: LIST
94456: LIST
94457: LIST
94458: LIST
94459: LIST
94460: LIST
94461: LIST
94462: LIST
94463: LIST
94464: LIST
94465: LIST
94466: LIST
94467: LIST
94468: LIST
94469: LIST
94470: LIST
94471: LIST
94472: LIST
94473: LIST
94474: LIST
94475: LIST
94476: LIST
94477: PUSH
94478: LD_INT 101
94480: PUSH
94481: LD_INT 102
94483: PUSH
94484: LD_INT 103
94486: PUSH
94487: LD_INT 104
94489: PUSH
94490: LD_INT 105
94492: PUSH
94493: LD_INT 106
94495: PUSH
94496: LD_INT 107
94498: PUSH
94499: LD_INT 108
94501: PUSH
94502: LD_INT 109
94504: PUSH
94505: LD_INT 110
94507: PUSH
94508: LD_INT 111
94510: PUSH
94511: LD_INT 112
94513: PUSH
94514: LD_INT 113
94516: PUSH
94517: LD_INT 114
94519: PUSH
94520: LD_INT 115
94522: PUSH
94523: EMPTY
94524: LIST
94525: LIST
94526: LIST
94527: LIST
94528: LIST
94529: LIST
94530: LIST
94531: LIST
94532: LIST
94533: LIST
94534: LIST
94535: LIST
94536: LIST
94537: LIST
94538: LIST
94539: PUSH
94540: EMPTY
94541: LIST
94542: LIST
94543: ST_TO_ADDR
// if result then
94544: LD_VAR 0 1
94548: IFFALSE 94837
// begin normal :=  ;
94550: LD_ADDR_VAR 0 3
94554: PUSH
94555: LD_STRING 
94557: ST_TO_ADDR
// hardcore :=  ;
94558: LD_ADDR_VAR 0 4
94562: PUSH
94563: LD_STRING 
94565: ST_TO_ADDR
// for i = 1 to normalCounter do
94566: LD_ADDR_VAR 0 5
94570: PUSH
94571: DOUBLE
94572: LD_INT 1
94574: DEC
94575: ST_TO_ADDR
94576: LD_EXP 138
94580: PUSH
94581: FOR_TO
94582: IFFALSE 94683
// begin tmp := 0 ;
94584: LD_ADDR_VAR 0 2
94588: PUSH
94589: LD_STRING 0
94591: ST_TO_ADDR
// if result [ 1 ] then
94592: LD_VAR 0 1
94596: PUSH
94597: LD_INT 1
94599: ARRAY
94600: IFFALSE 94665
// if result [ 1 ] [ 1 ] = i then
94602: LD_VAR 0 1
94606: PUSH
94607: LD_INT 1
94609: ARRAY
94610: PUSH
94611: LD_INT 1
94613: ARRAY
94614: PUSH
94615: LD_VAR 0 5
94619: EQUAL
94620: IFFALSE 94665
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
94622: LD_ADDR_VAR 0 1
94626: PUSH
94627: LD_VAR 0 1
94631: PPUSH
94632: LD_INT 1
94634: PPUSH
94635: LD_VAR 0 1
94639: PUSH
94640: LD_INT 1
94642: ARRAY
94643: PPUSH
94644: LD_INT 1
94646: PPUSH
94647: CALL_OW 3
94651: PPUSH
94652: CALL_OW 1
94656: ST_TO_ADDR
// tmp := 1 ;
94657: LD_ADDR_VAR 0 2
94661: PUSH
94662: LD_STRING 1
94664: ST_TO_ADDR
// end ; normal := normal & tmp ;
94665: LD_ADDR_VAR 0 3
94669: PUSH
94670: LD_VAR 0 3
94674: PUSH
94675: LD_VAR 0 2
94679: STR
94680: ST_TO_ADDR
// end ;
94681: GO 94581
94683: POP
94684: POP
// for i = 1 to hardcoreCounter do
94685: LD_ADDR_VAR 0 5
94689: PUSH
94690: DOUBLE
94691: LD_INT 1
94693: DEC
94694: ST_TO_ADDR
94695: LD_EXP 139
94699: PUSH
94700: FOR_TO
94701: IFFALSE 94806
// begin tmp := 0 ;
94703: LD_ADDR_VAR 0 2
94707: PUSH
94708: LD_STRING 0
94710: ST_TO_ADDR
// if result [ 2 ] then
94711: LD_VAR 0 1
94715: PUSH
94716: LD_INT 2
94718: ARRAY
94719: IFFALSE 94788
// if result [ 2 ] [ 1 ] = 100 + i then
94721: LD_VAR 0 1
94725: PUSH
94726: LD_INT 2
94728: ARRAY
94729: PUSH
94730: LD_INT 1
94732: ARRAY
94733: PUSH
94734: LD_INT 100
94736: PUSH
94737: LD_VAR 0 5
94741: PLUS
94742: EQUAL
94743: IFFALSE 94788
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
94745: LD_ADDR_VAR 0 1
94749: PUSH
94750: LD_VAR 0 1
94754: PPUSH
94755: LD_INT 2
94757: PPUSH
94758: LD_VAR 0 1
94762: PUSH
94763: LD_INT 2
94765: ARRAY
94766: PPUSH
94767: LD_INT 1
94769: PPUSH
94770: CALL_OW 3
94774: PPUSH
94775: CALL_OW 1
94779: ST_TO_ADDR
// tmp := 1 ;
94780: LD_ADDR_VAR 0 2
94784: PUSH
94785: LD_STRING 1
94787: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
94788: LD_ADDR_VAR 0 4
94792: PUSH
94793: LD_VAR 0 4
94797: PUSH
94798: LD_VAR 0 2
94802: STR
94803: ST_TO_ADDR
// end ;
94804: GO 94700
94806: POP
94807: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
94808: LD_STRING getStreamItemsFromMission("
94810: PUSH
94811: LD_VAR 0 3
94815: STR
94816: PUSH
94817: LD_STRING ","
94819: STR
94820: PUSH
94821: LD_VAR 0 4
94825: STR
94826: PUSH
94827: LD_STRING ")
94829: STR
94830: PPUSH
94831: CALL_OW 559
// end else
94835: GO 94844
// ToLua ( getStreamItemsFromMission("","") ) ;
94837: LD_STRING getStreamItemsFromMission("","")
94839: PPUSH
94840: CALL_OW 559
// end ;
94844: LD_VAR 0 1
94848: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
94849: LD_EXP 137
94853: PUSH
94854: LD_EXP 142
94858: AND
94859: IFFALSE 94983
94861: GO 94863
94863: DISABLE
94864: LD_INT 0
94866: PPUSH
94867: PPUSH
// begin enable ;
94868: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
94869: LD_ADDR_VAR 0 2
94873: PUSH
94874: LD_INT 22
94876: PUSH
94877: LD_OWVAR 2
94881: PUSH
94882: EMPTY
94883: LIST
94884: LIST
94885: PUSH
94886: LD_INT 2
94888: PUSH
94889: LD_INT 34
94891: PUSH
94892: LD_INT 7
94894: PUSH
94895: EMPTY
94896: LIST
94897: LIST
94898: PUSH
94899: LD_INT 34
94901: PUSH
94902: LD_INT 45
94904: PUSH
94905: EMPTY
94906: LIST
94907: LIST
94908: PUSH
94909: LD_INT 34
94911: PUSH
94912: LD_INT 28
94914: PUSH
94915: EMPTY
94916: LIST
94917: LIST
94918: PUSH
94919: LD_INT 34
94921: PUSH
94922: LD_INT 47
94924: PUSH
94925: EMPTY
94926: LIST
94927: LIST
94928: PUSH
94929: EMPTY
94930: LIST
94931: LIST
94932: LIST
94933: LIST
94934: LIST
94935: PUSH
94936: EMPTY
94937: LIST
94938: LIST
94939: PPUSH
94940: CALL_OW 69
94944: ST_TO_ADDR
// if not tmp then
94945: LD_VAR 0 2
94949: NOT
94950: IFFALSE 94954
// exit ;
94952: GO 94983
// for i in tmp do
94954: LD_ADDR_VAR 0 1
94958: PUSH
94959: LD_VAR 0 2
94963: PUSH
94964: FOR_IN
94965: IFFALSE 94981
// begin SetLives ( i , 0 ) ;
94967: LD_VAR 0 1
94971: PPUSH
94972: LD_INT 0
94974: PPUSH
94975: CALL_OW 234
// end ;
94979: GO 94964
94981: POP
94982: POP
// end ;
94983: PPOPN 2
94985: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
94986: LD_EXP 137
94990: PUSH
94991: LD_EXP 143
94995: AND
94996: IFFALSE 95080
94998: GO 95000
95000: DISABLE
95001: LD_INT 0
95003: PPUSH
95004: PPUSH
// begin enable ;
95005: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
95006: LD_ADDR_VAR 0 2
95010: PUSH
95011: LD_INT 22
95013: PUSH
95014: LD_OWVAR 2
95018: PUSH
95019: EMPTY
95020: LIST
95021: LIST
95022: PUSH
95023: LD_INT 32
95025: PUSH
95026: LD_INT 3
95028: PUSH
95029: EMPTY
95030: LIST
95031: LIST
95032: PUSH
95033: EMPTY
95034: LIST
95035: LIST
95036: PPUSH
95037: CALL_OW 69
95041: ST_TO_ADDR
// if not tmp then
95042: LD_VAR 0 2
95046: NOT
95047: IFFALSE 95051
// exit ;
95049: GO 95080
// for i in tmp do
95051: LD_ADDR_VAR 0 1
95055: PUSH
95056: LD_VAR 0 2
95060: PUSH
95061: FOR_IN
95062: IFFALSE 95078
// begin SetLives ( i , 0 ) ;
95064: LD_VAR 0 1
95068: PPUSH
95069: LD_INT 0
95071: PPUSH
95072: CALL_OW 234
// end ;
95076: GO 95061
95078: POP
95079: POP
// end ;
95080: PPOPN 2
95082: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
95083: LD_EXP 137
95087: PUSH
95088: LD_EXP 140
95092: AND
95093: IFFALSE 95186
95095: GO 95097
95097: DISABLE
95098: LD_INT 0
95100: PPUSH
// begin enable ;
95101: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
95102: LD_ADDR_VAR 0 1
95106: PUSH
95107: LD_INT 22
95109: PUSH
95110: LD_OWVAR 2
95114: PUSH
95115: EMPTY
95116: LIST
95117: LIST
95118: PUSH
95119: LD_INT 2
95121: PUSH
95122: LD_INT 25
95124: PUSH
95125: LD_INT 5
95127: PUSH
95128: EMPTY
95129: LIST
95130: LIST
95131: PUSH
95132: LD_INT 25
95134: PUSH
95135: LD_INT 9
95137: PUSH
95138: EMPTY
95139: LIST
95140: LIST
95141: PUSH
95142: LD_INT 25
95144: PUSH
95145: LD_INT 8
95147: PUSH
95148: EMPTY
95149: LIST
95150: LIST
95151: PUSH
95152: EMPTY
95153: LIST
95154: LIST
95155: LIST
95156: LIST
95157: PUSH
95158: EMPTY
95159: LIST
95160: LIST
95161: PPUSH
95162: CALL_OW 69
95166: PUSH
95167: FOR_IN
95168: IFFALSE 95184
// begin SetClass ( i , 1 ) ;
95170: LD_VAR 0 1
95174: PPUSH
95175: LD_INT 1
95177: PPUSH
95178: CALL_OW 336
// end ;
95182: GO 95167
95184: POP
95185: POP
// end ;
95186: PPOPN 1
95188: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
95189: LD_EXP 137
95193: PUSH
95194: LD_EXP 141
95198: AND
95199: PUSH
95200: LD_OWVAR 65
95204: PUSH
95205: LD_INT 7
95207: LESS
95208: AND
95209: IFFALSE 95223
95211: GO 95213
95213: DISABLE
// begin enable ;
95214: ENABLE
// game_speed := 7 ;
95215: LD_ADDR_OWVAR 65
95219: PUSH
95220: LD_INT 7
95222: ST_TO_ADDR
// end ;
95223: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
95224: LD_EXP 137
95228: PUSH
95229: LD_EXP 144
95233: AND
95234: IFFALSE 95436
95236: GO 95238
95238: DISABLE
95239: LD_INT 0
95241: PPUSH
95242: PPUSH
95243: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
95244: LD_ADDR_VAR 0 3
95248: PUSH
95249: LD_INT 81
95251: PUSH
95252: LD_OWVAR 2
95256: PUSH
95257: EMPTY
95258: LIST
95259: LIST
95260: PUSH
95261: LD_INT 21
95263: PUSH
95264: LD_INT 1
95266: PUSH
95267: EMPTY
95268: LIST
95269: LIST
95270: PUSH
95271: EMPTY
95272: LIST
95273: LIST
95274: PPUSH
95275: CALL_OW 69
95279: ST_TO_ADDR
// if not tmp then
95280: LD_VAR 0 3
95284: NOT
95285: IFFALSE 95289
// exit ;
95287: GO 95436
// if tmp > 5 then
95289: LD_VAR 0 3
95293: PUSH
95294: LD_INT 5
95296: GREATER
95297: IFFALSE 95309
// k := 5 else
95299: LD_ADDR_VAR 0 2
95303: PUSH
95304: LD_INT 5
95306: ST_TO_ADDR
95307: GO 95319
// k := tmp ;
95309: LD_ADDR_VAR 0 2
95313: PUSH
95314: LD_VAR 0 3
95318: ST_TO_ADDR
// for i := 1 to k do
95319: LD_ADDR_VAR 0 1
95323: PUSH
95324: DOUBLE
95325: LD_INT 1
95327: DEC
95328: ST_TO_ADDR
95329: LD_VAR 0 2
95333: PUSH
95334: FOR_TO
95335: IFFALSE 95434
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
95337: LD_VAR 0 3
95341: PUSH
95342: LD_VAR 0 1
95346: ARRAY
95347: PPUSH
95348: LD_VAR 0 1
95352: PUSH
95353: LD_INT 4
95355: MOD
95356: PUSH
95357: LD_INT 1
95359: PLUS
95360: PPUSH
95361: CALL_OW 259
95365: PUSH
95366: LD_INT 10
95368: LESS
95369: IFFALSE 95432
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
95371: LD_VAR 0 3
95375: PUSH
95376: LD_VAR 0 1
95380: ARRAY
95381: PPUSH
95382: LD_VAR 0 1
95386: PUSH
95387: LD_INT 4
95389: MOD
95390: PUSH
95391: LD_INT 1
95393: PLUS
95394: PPUSH
95395: LD_VAR 0 3
95399: PUSH
95400: LD_VAR 0 1
95404: ARRAY
95405: PPUSH
95406: LD_VAR 0 1
95410: PUSH
95411: LD_INT 4
95413: MOD
95414: PUSH
95415: LD_INT 1
95417: PLUS
95418: PPUSH
95419: CALL_OW 259
95423: PUSH
95424: LD_INT 1
95426: PLUS
95427: PPUSH
95428: CALL_OW 237
95432: GO 95334
95434: POP
95435: POP
// end ;
95436: PPOPN 3
95438: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
95439: LD_EXP 137
95443: PUSH
95444: LD_EXP 145
95448: AND
95449: IFFALSE 95469
95451: GO 95453
95453: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
95454: LD_INT 4
95456: PPUSH
95457: LD_OWVAR 2
95461: PPUSH
95462: LD_INT 0
95464: PPUSH
95465: CALL_OW 324
95469: END
// every 0 0$1 trigger StreamModeActive and sShovel do
95470: LD_EXP 137
95474: PUSH
95475: LD_EXP 174
95479: AND
95480: IFFALSE 95500
95482: GO 95484
95484: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
95485: LD_INT 19
95487: PPUSH
95488: LD_OWVAR 2
95492: PPUSH
95493: LD_INT 0
95495: PPUSH
95496: CALL_OW 324
95500: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
95501: LD_EXP 137
95505: PUSH
95506: LD_EXP 146
95510: AND
95511: IFFALSE 95613
95513: GO 95515
95515: DISABLE
95516: LD_INT 0
95518: PPUSH
95519: PPUSH
// begin enable ;
95520: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
95521: LD_ADDR_VAR 0 2
95525: PUSH
95526: LD_INT 22
95528: PUSH
95529: LD_OWVAR 2
95533: PUSH
95534: EMPTY
95535: LIST
95536: LIST
95537: PUSH
95538: LD_INT 2
95540: PUSH
95541: LD_INT 34
95543: PUSH
95544: LD_INT 11
95546: PUSH
95547: EMPTY
95548: LIST
95549: LIST
95550: PUSH
95551: LD_INT 34
95553: PUSH
95554: LD_INT 30
95556: PUSH
95557: EMPTY
95558: LIST
95559: LIST
95560: PUSH
95561: EMPTY
95562: LIST
95563: LIST
95564: LIST
95565: PUSH
95566: EMPTY
95567: LIST
95568: LIST
95569: PPUSH
95570: CALL_OW 69
95574: ST_TO_ADDR
// if not tmp then
95575: LD_VAR 0 2
95579: NOT
95580: IFFALSE 95584
// exit ;
95582: GO 95613
// for i in tmp do
95584: LD_ADDR_VAR 0 1
95588: PUSH
95589: LD_VAR 0 2
95593: PUSH
95594: FOR_IN
95595: IFFALSE 95611
// begin SetLives ( i , 0 ) ;
95597: LD_VAR 0 1
95601: PPUSH
95602: LD_INT 0
95604: PPUSH
95605: CALL_OW 234
// end ;
95609: GO 95594
95611: POP
95612: POP
// end ;
95613: PPOPN 2
95615: END
// every 0 0$1 trigger StreamModeActive and sBunker do
95616: LD_EXP 137
95620: PUSH
95621: LD_EXP 147
95625: AND
95626: IFFALSE 95646
95628: GO 95630
95630: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
95631: LD_INT 32
95633: PPUSH
95634: LD_OWVAR 2
95638: PPUSH
95639: LD_INT 0
95641: PPUSH
95642: CALL_OW 324
95646: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
95647: LD_EXP 137
95651: PUSH
95652: LD_EXP 148
95656: AND
95657: IFFALSE 95838
95659: GO 95661
95661: DISABLE
95662: LD_INT 0
95664: PPUSH
95665: PPUSH
95666: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
95667: LD_ADDR_VAR 0 2
95671: PUSH
95672: LD_INT 22
95674: PUSH
95675: LD_OWVAR 2
95679: PUSH
95680: EMPTY
95681: LIST
95682: LIST
95683: PUSH
95684: LD_INT 33
95686: PUSH
95687: LD_INT 3
95689: PUSH
95690: EMPTY
95691: LIST
95692: LIST
95693: PUSH
95694: EMPTY
95695: LIST
95696: LIST
95697: PPUSH
95698: CALL_OW 69
95702: ST_TO_ADDR
// if not tmp then
95703: LD_VAR 0 2
95707: NOT
95708: IFFALSE 95712
// exit ;
95710: GO 95838
// side := 0 ;
95712: LD_ADDR_VAR 0 3
95716: PUSH
95717: LD_INT 0
95719: ST_TO_ADDR
// for i := 1 to 8 do
95720: LD_ADDR_VAR 0 1
95724: PUSH
95725: DOUBLE
95726: LD_INT 1
95728: DEC
95729: ST_TO_ADDR
95730: LD_INT 8
95732: PUSH
95733: FOR_TO
95734: IFFALSE 95782
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
95736: LD_OWVAR 2
95740: PUSH
95741: LD_VAR 0 1
95745: NONEQUAL
95746: PUSH
95747: LD_OWVAR 2
95751: PPUSH
95752: LD_VAR 0 1
95756: PPUSH
95757: CALL_OW 81
95761: PUSH
95762: LD_INT 2
95764: EQUAL
95765: AND
95766: IFFALSE 95780
// begin side := i ;
95768: LD_ADDR_VAR 0 3
95772: PUSH
95773: LD_VAR 0 1
95777: ST_TO_ADDR
// break ;
95778: GO 95782
// end ;
95780: GO 95733
95782: POP
95783: POP
// if not side then
95784: LD_VAR 0 3
95788: NOT
95789: IFFALSE 95793
// exit ;
95791: GO 95838
// for i := 1 to tmp do
95793: LD_ADDR_VAR 0 1
95797: PUSH
95798: DOUBLE
95799: LD_INT 1
95801: DEC
95802: ST_TO_ADDR
95803: LD_VAR 0 2
95807: PUSH
95808: FOR_TO
95809: IFFALSE 95836
// if Prob ( 60 ) then
95811: LD_INT 60
95813: PPUSH
95814: CALL_OW 13
95818: IFFALSE 95834
// SetSide ( i , side ) ;
95820: LD_VAR 0 1
95824: PPUSH
95825: LD_VAR 0 3
95829: PPUSH
95830: CALL_OW 235
95834: GO 95808
95836: POP
95837: POP
// end ;
95838: PPOPN 3
95840: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
95841: LD_EXP 137
95845: PUSH
95846: LD_EXP 150
95850: AND
95851: IFFALSE 95970
95853: GO 95855
95855: DISABLE
95856: LD_INT 0
95858: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
95859: LD_ADDR_VAR 0 1
95863: PUSH
95864: LD_INT 22
95866: PUSH
95867: LD_OWVAR 2
95871: PUSH
95872: EMPTY
95873: LIST
95874: LIST
95875: PUSH
95876: LD_INT 21
95878: PUSH
95879: LD_INT 1
95881: PUSH
95882: EMPTY
95883: LIST
95884: LIST
95885: PUSH
95886: LD_INT 3
95888: PUSH
95889: LD_INT 23
95891: PUSH
95892: LD_INT 0
95894: PUSH
95895: EMPTY
95896: LIST
95897: LIST
95898: PUSH
95899: EMPTY
95900: LIST
95901: LIST
95902: PUSH
95903: EMPTY
95904: LIST
95905: LIST
95906: LIST
95907: PPUSH
95908: CALL_OW 69
95912: PUSH
95913: FOR_IN
95914: IFFALSE 95968
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
95916: LD_VAR 0 1
95920: PPUSH
95921: CALL_OW 257
95925: PUSH
95926: LD_INT 1
95928: PUSH
95929: LD_INT 2
95931: PUSH
95932: LD_INT 3
95934: PUSH
95935: LD_INT 4
95937: PUSH
95938: EMPTY
95939: LIST
95940: LIST
95941: LIST
95942: LIST
95943: IN
95944: IFFALSE 95966
// SetClass ( un , rand ( 1 , 4 ) ) ;
95946: LD_VAR 0 1
95950: PPUSH
95951: LD_INT 1
95953: PPUSH
95954: LD_INT 4
95956: PPUSH
95957: CALL_OW 12
95961: PPUSH
95962: CALL_OW 336
95966: GO 95913
95968: POP
95969: POP
// end ;
95970: PPOPN 1
95972: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
95973: LD_EXP 137
95977: PUSH
95978: LD_EXP 149
95982: AND
95983: IFFALSE 96062
95985: GO 95987
95987: DISABLE
95988: LD_INT 0
95990: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
95991: LD_ADDR_VAR 0 1
95995: PUSH
95996: LD_INT 22
95998: PUSH
95999: LD_OWVAR 2
96003: PUSH
96004: EMPTY
96005: LIST
96006: LIST
96007: PUSH
96008: LD_INT 21
96010: PUSH
96011: LD_INT 3
96013: PUSH
96014: EMPTY
96015: LIST
96016: LIST
96017: PUSH
96018: EMPTY
96019: LIST
96020: LIST
96021: PPUSH
96022: CALL_OW 69
96026: ST_TO_ADDR
// if not tmp then
96027: LD_VAR 0 1
96031: NOT
96032: IFFALSE 96036
// exit ;
96034: GO 96062
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
96036: LD_VAR 0 1
96040: PUSH
96041: LD_INT 1
96043: PPUSH
96044: LD_VAR 0 1
96048: PPUSH
96049: CALL_OW 12
96053: ARRAY
96054: PPUSH
96055: LD_INT 100
96057: PPUSH
96058: CALL_OW 234
// end ;
96062: PPOPN 1
96064: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
96065: LD_EXP 137
96069: PUSH
96070: LD_EXP 151
96074: AND
96075: IFFALSE 96173
96077: GO 96079
96079: DISABLE
96080: LD_INT 0
96082: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
96083: LD_ADDR_VAR 0 1
96087: PUSH
96088: LD_INT 22
96090: PUSH
96091: LD_OWVAR 2
96095: PUSH
96096: EMPTY
96097: LIST
96098: LIST
96099: PUSH
96100: LD_INT 21
96102: PUSH
96103: LD_INT 1
96105: PUSH
96106: EMPTY
96107: LIST
96108: LIST
96109: PUSH
96110: EMPTY
96111: LIST
96112: LIST
96113: PPUSH
96114: CALL_OW 69
96118: ST_TO_ADDR
// if not tmp then
96119: LD_VAR 0 1
96123: NOT
96124: IFFALSE 96128
// exit ;
96126: GO 96173
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
96128: LD_VAR 0 1
96132: PUSH
96133: LD_INT 1
96135: PPUSH
96136: LD_VAR 0 1
96140: PPUSH
96141: CALL_OW 12
96145: ARRAY
96146: PPUSH
96147: LD_INT 1
96149: PPUSH
96150: LD_INT 4
96152: PPUSH
96153: CALL_OW 12
96157: PPUSH
96158: LD_INT 3000
96160: PPUSH
96161: LD_INT 9000
96163: PPUSH
96164: CALL_OW 12
96168: PPUSH
96169: CALL_OW 492
// end ;
96173: PPOPN 1
96175: END
// every 0 0$1 trigger StreamModeActive and sDepot do
96176: LD_EXP 137
96180: PUSH
96181: LD_EXP 152
96185: AND
96186: IFFALSE 96206
96188: GO 96190
96190: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
96191: LD_INT 1
96193: PPUSH
96194: LD_OWVAR 2
96198: PPUSH
96199: LD_INT 0
96201: PPUSH
96202: CALL_OW 324
96206: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
96207: LD_EXP 137
96211: PUSH
96212: LD_EXP 153
96216: AND
96217: IFFALSE 96300
96219: GO 96221
96221: DISABLE
96222: LD_INT 0
96224: PPUSH
96225: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
96226: LD_ADDR_VAR 0 2
96230: PUSH
96231: LD_INT 22
96233: PUSH
96234: LD_OWVAR 2
96238: PUSH
96239: EMPTY
96240: LIST
96241: LIST
96242: PUSH
96243: LD_INT 21
96245: PUSH
96246: LD_INT 3
96248: PUSH
96249: EMPTY
96250: LIST
96251: LIST
96252: PUSH
96253: EMPTY
96254: LIST
96255: LIST
96256: PPUSH
96257: CALL_OW 69
96261: ST_TO_ADDR
// if not tmp then
96262: LD_VAR 0 2
96266: NOT
96267: IFFALSE 96271
// exit ;
96269: GO 96300
// for i in tmp do
96271: LD_ADDR_VAR 0 1
96275: PUSH
96276: LD_VAR 0 2
96280: PUSH
96281: FOR_IN
96282: IFFALSE 96298
// SetBLevel ( i , 10 ) ;
96284: LD_VAR 0 1
96288: PPUSH
96289: LD_INT 10
96291: PPUSH
96292: CALL_OW 241
96296: GO 96281
96298: POP
96299: POP
// end ;
96300: PPOPN 2
96302: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
96303: LD_EXP 137
96307: PUSH
96308: LD_EXP 154
96312: AND
96313: IFFALSE 96424
96315: GO 96317
96317: DISABLE
96318: LD_INT 0
96320: PPUSH
96321: PPUSH
96322: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96323: LD_ADDR_VAR 0 3
96327: PUSH
96328: LD_INT 22
96330: PUSH
96331: LD_OWVAR 2
96335: PUSH
96336: EMPTY
96337: LIST
96338: LIST
96339: PUSH
96340: LD_INT 25
96342: PUSH
96343: LD_INT 1
96345: PUSH
96346: EMPTY
96347: LIST
96348: LIST
96349: PUSH
96350: EMPTY
96351: LIST
96352: LIST
96353: PPUSH
96354: CALL_OW 69
96358: ST_TO_ADDR
// if not tmp then
96359: LD_VAR 0 3
96363: NOT
96364: IFFALSE 96368
// exit ;
96366: GO 96424
// un := tmp [ rand ( 1 , tmp ) ] ;
96368: LD_ADDR_VAR 0 2
96372: PUSH
96373: LD_VAR 0 3
96377: PUSH
96378: LD_INT 1
96380: PPUSH
96381: LD_VAR 0 3
96385: PPUSH
96386: CALL_OW 12
96390: ARRAY
96391: ST_TO_ADDR
// if Crawls ( un ) then
96392: LD_VAR 0 2
96396: PPUSH
96397: CALL_OW 318
96401: IFFALSE 96412
// ComWalk ( un ) ;
96403: LD_VAR 0 2
96407: PPUSH
96408: CALL_OW 138
// SetClass ( un , class_sniper ) ;
96412: LD_VAR 0 2
96416: PPUSH
96417: LD_INT 5
96419: PPUSH
96420: CALL_OW 336
// end ;
96424: PPOPN 3
96426: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
96427: LD_EXP 137
96431: PUSH
96432: LD_EXP 155
96436: AND
96437: PUSH
96438: LD_OWVAR 67
96442: PUSH
96443: LD_INT 3
96445: LESS
96446: AND
96447: IFFALSE 96466
96449: GO 96451
96451: DISABLE
// Difficulty := Difficulty + 1 ;
96452: LD_ADDR_OWVAR 67
96456: PUSH
96457: LD_OWVAR 67
96461: PUSH
96462: LD_INT 1
96464: PLUS
96465: ST_TO_ADDR
96466: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
96467: LD_EXP 137
96471: PUSH
96472: LD_EXP 156
96476: AND
96477: IFFALSE 96580
96479: GO 96481
96481: DISABLE
96482: LD_INT 0
96484: PPUSH
// begin for i := 1 to 5 do
96485: LD_ADDR_VAR 0 1
96489: PUSH
96490: DOUBLE
96491: LD_INT 1
96493: DEC
96494: ST_TO_ADDR
96495: LD_INT 5
96497: PUSH
96498: FOR_TO
96499: IFFALSE 96578
// begin uc_nation := nation_nature ;
96501: LD_ADDR_OWVAR 21
96505: PUSH
96506: LD_INT 0
96508: ST_TO_ADDR
// uc_side := 0 ;
96509: LD_ADDR_OWVAR 20
96513: PUSH
96514: LD_INT 0
96516: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
96517: LD_ADDR_OWVAR 29
96521: PUSH
96522: LD_INT 12
96524: PUSH
96525: LD_INT 12
96527: PUSH
96528: EMPTY
96529: LIST
96530: LIST
96531: ST_TO_ADDR
// hc_agressivity := 20 ;
96532: LD_ADDR_OWVAR 35
96536: PUSH
96537: LD_INT 20
96539: ST_TO_ADDR
// hc_class := class_tiger ;
96540: LD_ADDR_OWVAR 28
96544: PUSH
96545: LD_INT 14
96547: ST_TO_ADDR
// hc_gallery :=  ;
96548: LD_ADDR_OWVAR 33
96552: PUSH
96553: LD_STRING 
96555: ST_TO_ADDR
// hc_name :=  ;
96556: LD_ADDR_OWVAR 26
96560: PUSH
96561: LD_STRING 
96563: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
96564: CALL_OW 44
96568: PPUSH
96569: LD_INT 0
96571: PPUSH
96572: CALL_OW 51
// end ;
96576: GO 96498
96578: POP
96579: POP
// end ;
96580: PPOPN 1
96582: END
// every 0 0$1 trigger StreamModeActive and sBomb do
96583: LD_EXP 137
96587: PUSH
96588: LD_EXP 157
96592: AND
96593: IFFALSE 96602
96595: GO 96597
96597: DISABLE
// StreamSibBomb ;
96598: CALL 96603 0 0
96602: END
// export function StreamSibBomb ; var i , x , y ; begin
96603: LD_INT 0
96605: PPUSH
96606: PPUSH
96607: PPUSH
96608: PPUSH
// result := false ;
96609: LD_ADDR_VAR 0 1
96613: PUSH
96614: LD_INT 0
96616: ST_TO_ADDR
// for i := 1 to 16 do
96617: LD_ADDR_VAR 0 2
96621: PUSH
96622: DOUBLE
96623: LD_INT 1
96625: DEC
96626: ST_TO_ADDR
96627: LD_INT 16
96629: PUSH
96630: FOR_TO
96631: IFFALSE 96830
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
96633: LD_ADDR_VAR 0 3
96637: PUSH
96638: LD_INT 10
96640: PUSH
96641: LD_INT 20
96643: PUSH
96644: LD_INT 30
96646: PUSH
96647: LD_INT 40
96649: PUSH
96650: LD_INT 50
96652: PUSH
96653: LD_INT 60
96655: PUSH
96656: LD_INT 70
96658: PUSH
96659: LD_INT 80
96661: PUSH
96662: LD_INT 90
96664: PUSH
96665: LD_INT 100
96667: PUSH
96668: LD_INT 110
96670: PUSH
96671: LD_INT 120
96673: PUSH
96674: LD_INT 130
96676: PUSH
96677: LD_INT 140
96679: PUSH
96680: LD_INT 150
96682: PUSH
96683: EMPTY
96684: LIST
96685: LIST
96686: LIST
96687: LIST
96688: LIST
96689: LIST
96690: LIST
96691: LIST
96692: LIST
96693: LIST
96694: LIST
96695: LIST
96696: LIST
96697: LIST
96698: LIST
96699: PUSH
96700: LD_INT 1
96702: PPUSH
96703: LD_INT 15
96705: PPUSH
96706: CALL_OW 12
96710: ARRAY
96711: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
96712: LD_ADDR_VAR 0 4
96716: PUSH
96717: LD_INT 10
96719: PUSH
96720: LD_INT 20
96722: PUSH
96723: LD_INT 30
96725: PUSH
96726: LD_INT 40
96728: PUSH
96729: LD_INT 50
96731: PUSH
96732: LD_INT 60
96734: PUSH
96735: LD_INT 70
96737: PUSH
96738: LD_INT 80
96740: PUSH
96741: LD_INT 90
96743: PUSH
96744: LD_INT 100
96746: PUSH
96747: LD_INT 110
96749: PUSH
96750: LD_INT 120
96752: PUSH
96753: LD_INT 130
96755: PUSH
96756: LD_INT 140
96758: PUSH
96759: LD_INT 150
96761: PUSH
96762: EMPTY
96763: LIST
96764: LIST
96765: LIST
96766: LIST
96767: LIST
96768: LIST
96769: LIST
96770: LIST
96771: LIST
96772: LIST
96773: LIST
96774: LIST
96775: LIST
96776: LIST
96777: LIST
96778: PUSH
96779: LD_INT 1
96781: PPUSH
96782: LD_INT 15
96784: PPUSH
96785: CALL_OW 12
96789: ARRAY
96790: ST_TO_ADDR
// if ValidHex ( x , y ) then
96791: LD_VAR 0 3
96795: PPUSH
96796: LD_VAR 0 4
96800: PPUSH
96801: CALL_OW 488
96805: IFFALSE 96828
// begin result := [ x , y ] ;
96807: LD_ADDR_VAR 0 1
96811: PUSH
96812: LD_VAR 0 3
96816: PUSH
96817: LD_VAR 0 4
96821: PUSH
96822: EMPTY
96823: LIST
96824: LIST
96825: ST_TO_ADDR
// break ;
96826: GO 96830
// end ; end ;
96828: GO 96630
96830: POP
96831: POP
// if result then
96832: LD_VAR 0 1
96836: IFFALSE 96896
// begin ToLua ( playSibBomb() ) ;
96838: LD_STRING playSibBomb()
96840: PPUSH
96841: CALL_OW 559
// wait ( 0 0$14 ) ;
96845: LD_INT 490
96847: PPUSH
96848: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
96852: LD_VAR 0 1
96856: PUSH
96857: LD_INT 1
96859: ARRAY
96860: PPUSH
96861: LD_VAR 0 1
96865: PUSH
96866: LD_INT 2
96868: ARRAY
96869: PPUSH
96870: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
96874: LD_VAR 0 1
96878: PUSH
96879: LD_INT 1
96881: ARRAY
96882: PPUSH
96883: LD_VAR 0 1
96887: PUSH
96888: LD_INT 2
96890: ARRAY
96891: PPUSH
96892: CALL_OW 429
// end ; end ;
96896: LD_VAR 0 1
96900: RET
// every 0 0$1 trigger StreamModeActive and sReset do
96901: LD_EXP 137
96905: PUSH
96906: LD_EXP 159
96910: AND
96911: IFFALSE 96923
96913: GO 96915
96915: DISABLE
// YouLost (  ) ;
96916: LD_STRING 
96918: PPUSH
96919: CALL_OW 104
96923: END
// every 0 0$1 trigger StreamModeActive and sFog do
96924: LD_EXP 137
96928: PUSH
96929: LD_EXP 158
96933: AND
96934: IFFALSE 96948
96936: GO 96938
96938: DISABLE
// FogOff ( your_side ) ;
96939: LD_OWVAR 2
96943: PPUSH
96944: CALL_OW 344
96948: END
// every 0 0$1 trigger StreamModeActive and sSun do
96949: LD_EXP 137
96953: PUSH
96954: LD_EXP 160
96958: AND
96959: IFFALSE 96987
96961: GO 96963
96963: DISABLE
// begin solar_recharge_percent := 0 ;
96964: LD_ADDR_OWVAR 79
96968: PUSH
96969: LD_INT 0
96971: ST_TO_ADDR
// wait ( 5 5$00 ) ;
96972: LD_INT 10500
96974: PPUSH
96975: CALL_OW 67
// solar_recharge_percent := 100 ;
96979: LD_ADDR_OWVAR 79
96983: PUSH
96984: LD_INT 100
96986: ST_TO_ADDR
// end ;
96987: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
96988: LD_EXP 137
96992: PUSH
96993: LD_EXP 161
96997: AND
96998: IFFALSE 97237
97000: GO 97002
97002: DISABLE
97003: LD_INT 0
97005: PPUSH
97006: PPUSH
97007: PPUSH
// begin tmp := [ ] ;
97008: LD_ADDR_VAR 0 3
97012: PUSH
97013: EMPTY
97014: ST_TO_ADDR
// for i := 1 to 6 do
97015: LD_ADDR_VAR 0 1
97019: PUSH
97020: DOUBLE
97021: LD_INT 1
97023: DEC
97024: ST_TO_ADDR
97025: LD_INT 6
97027: PUSH
97028: FOR_TO
97029: IFFALSE 97134
// begin uc_nation := nation_nature ;
97031: LD_ADDR_OWVAR 21
97035: PUSH
97036: LD_INT 0
97038: ST_TO_ADDR
// uc_side := 0 ;
97039: LD_ADDR_OWVAR 20
97043: PUSH
97044: LD_INT 0
97046: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
97047: LD_ADDR_OWVAR 29
97051: PUSH
97052: LD_INT 12
97054: PUSH
97055: LD_INT 12
97057: PUSH
97058: EMPTY
97059: LIST
97060: LIST
97061: ST_TO_ADDR
// hc_agressivity := 20 ;
97062: LD_ADDR_OWVAR 35
97066: PUSH
97067: LD_INT 20
97069: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
97070: LD_ADDR_OWVAR 28
97074: PUSH
97075: LD_INT 17
97077: ST_TO_ADDR
// hc_gallery :=  ;
97078: LD_ADDR_OWVAR 33
97082: PUSH
97083: LD_STRING 
97085: ST_TO_ADDR
// hc_name :=  ;
97086: LD_ADDR_OWVAR 26
97090: PUSH
97091: LD_STRING 
97093: ST_TO_ADDR
// un := CreateHuman ;
97094: LD_ADDR_VAR 0 2
97098: PUSH
97099: CALL_OW 44
97103: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
97104: LD_VAR 0 2
97108: PPUSH
97109: LD_INT 1
97111: PPUSH
97112: CALL_OW 51
// tmp := tmp ^ un ;
97116: LD_ADDR_VAR 0 3
97120: PUSH
97121: LD_VAR 0 3
97125: PUSH
97126: LD_VAR 0 2
97130: ADD
97131: ST_TO_ADDR
// end ;
97132: GO 97028
97134: POP
97135: POP
// repeat wait ( 0 0$1 ) ;
97136: LD_INT 35
97138: PPUSH
97139: CALL_OW 67
// for un in tmp do
97143: LD_ADDR_VAR 0 2
97147: PUSH
97148: LD_VAR 0 3
97152: PUSH
97153: FOR_IN
97154: IFFALSE 97228
// begin if IsDead ( un ) then
97156: LD_VAR 0 2
97160: PPUSH
97161: CALL_OW 301
97165: IFFALSE 97185
// begin tmp := tmp diff un ;
97167: LD_ADDR_VAR 0 3
97171: PUSH
97172: LD_VAR 0 3
97176: PUSH
97177: LD_VAR 0 2
97181: DIFF
97182: ST_TO_ADDR
// continue ;
97183: GO 97153
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
97185: LD_VAR 0 2
97189: PPUSH
97190: LD_INT 3
97192: PUSH
97193: LD_INT 22
97195: PUSH
97196: LD_INT 0
97198: PUSH
97199: EMPTY
97200: LIST
97201: LIST
97202: PUSH
97203: EMPTY
97204: LIST
97205: LIST
97206: PPUSH
97207: CALL_OW 69
97211: PPUSH
97212: LD_VAR 0 2
97216: PPUSH
97217: CALL_OW 74
97221: PPUSH
97222: CALL_OW 115
// end ;
97226: GO 97153
97228: POP
97229: POP
// until not tmp ;
97230: LD_VAR 0 3
97234: NOT
97235: IFFALSE 97136
// end ;
97237: PPOPN 3
97239: END
// every 0 0$1 trigger StreamModeActive and sTroll do
97240: LD_EXP 137
97244: PUSH
97245: LD_EXP 162
97249: AND
97250: IFFALSE 97304
97252: GO 97254
97254: DISABLE
// begin ToLua ( displayTroll(); ) ;
97255: LD_STRING displayTroll();
97257: PPUSH
97258: CALL_OW 559
// wait ( 3 3$00 ) ;
97262: LD_INT 6300
97264: PPUSH
97265: CALL_OW 67
// ToLua ( hideTroll(); ) ;
97269: LD_STRING hideTroll();
97271: PPUSH
97272: CALL_OW 559
// wait ( 1 1$00 ) ;
97276: LD_INT 2100
97278: PPUSH
97279: CALL_OW 67
// ToLua ( displayTroll(); ) ;
97283: LD_STRING displayTroll();
97285: PPUSH
97286: CALL_OW 559
// wait ( 1 1$00 ) ;
97290: LD_INT 2100
97292: PPUSH
97293: CALL_OW 67
// ToLua ( hideTroll(); ) ;
97297: LD_STRING hideTroll();
97299: PPUSH
97300: CALL_OW 559
// end ;
97304: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
97305: LD_EXP 137
97309: PUSH
97310: LD_EXP 163
97314: AND
97315: IFFALSE 97378
97317: GO 97319
97319: DISABLE
97320: LD_INT 0
97322: PPUSH
// begin p := 0 ;
97323: LD_ADDR_VAR 0 1
97327: PUSH
97328: LD_INT 0
97330: ST_TO_ADDR
// repeat game_speed := 1 ;
97331: LD_ADDR_OWVAR 65
97335: PUSH
97336: LD_INT 1
97338: ST_TO_ADDR
// wait ( 0 0$1 ) ;
97339: LD_INT 35
97341: PPUSH
97342: CALL_OW 67
// p := p + 1 ;
97346: LD_ADDR_VAR 0 1
97350: PUSH
97351: LD_VAR 0 1
97355: PUSH
97356: LD_INT 1
97358: PLUS
97359: ST_TO_ADDR
// until p >= 60 ;
97360: LD_VAR 0 1
97364: PUSH
97365: LD_INT 60
97367: GREATEREQUAL
97368: IFFALSE 97331
// game_speed := 4 ;
97370: LD_ADDR_OWVAR 65
97374: PUSH
97375: LD_INT 4
97377: ST_TO_ADDR
// end ;
97378: PPOPN 1
97380: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
97381: LD_EXP 137
97385: PUSH
97386: LD_EXP 164
97390: AND
97391: IFFALSE 97537
97393: GO 97395
97395: DISABLE
97396: LD_INT 0
97398: PPUSH
97399: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
97400: LD_ADDR_VAR 0 1
97404: PUSH
97405: LD_INT 22
97407: PUSH
97408: LD_OWVAR 2
97412: PUSH
97413: EMPTY
97414: LIST
97415: LIST
97416: PUSH
97417: LD_INT 2
97419: PUSH
97420: LD_INT 30
97422: PUSH
97423: LD_INT 0
97425: PUSH
97426: EMPTY
97427: LIST
97428: LIST
97429: PUSH
97430: LD_INT 30
97432: PUSH
97433: LD_INT 1
97435: PUSH
97436: EMPTY
97437: LIST
97438: LIST
97439: PUSH
97440: EMPTY
97441: LIST
97442: LIST
97443: LIST
97444: PUSH
97445: EMPTY
97446: LIST
97447: LIST
97448: PPUSH
97449: CALL_OW 69
97453: ST_TO_ADDR
// if not depot then
97454: LD_VAR 0 1
97458: NOT
97459: IFFALSE 97463
// exit ;
97461: GO 97537
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
97463: LD_ADDR_VAR 0 2
97467: PUSH
97468: LD_VAR 0 1
97472: PUSH
97473: LD_INT 1
97475: PPUSH
97476: LD_VAR 0 1
97480: PPUSH
97481: CALL_OW 12
97485: ARRAY
97486: PPUSH
97487: CALL_OW 274
97491: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
97492: LD_VAR 0 2
97496: PPUSH
97497: LD_INT 1
97499: PPUSH
97500: LD_INT 0
97502: PPUSH
97503: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
97507: LD_VAR 0 2
97511: PPUSH
97512: LD_INT 2
97514: PPUSH
97515: LD_INT 0
97517: PPUSH
97518: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
97522: LD_VAR 0 2
97526: PPUSH
97527: LD_INT 3
97529: PPUSH
97530: LD_INT 0
97532: PPUSH
97533: CALL_OW 277
// end ;
97537: PPOPN 2
97539: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
97540: LD_EXP 137
97544: PUSH
97545: LD_EXP 165
97549: AND
97550: IFFALSE 97647
97552: GO 97554
97554: DISABLE
97555: LD_INT 0
97557: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
97558: LD_ADDR_VAR 0 1
97562: PUSH
97563: LD_INT 22
97565: PUSH
97566: LD_OWVAR 2
97570: PUSH
97571: EMPTY
97572: LIST
97573: LIST
97574: PUSH
97575: LD_INT 21
97577: PUSH
97578: LD_INT 1
97580: PUSH
97581: EMPTY
97582: LIST
97583: LIST
97584: PUSH
97585: LD_INT 3
97587: PUSH
97588: LD_INT 23
97590: PUSH
97591: LD_INT 0
97593: PUSH
97594: EMPTY
97595: LIST
97596: LIST
97597: PUSH
97598: EMPTY
97599: LIST
97600: LIST
97601: PUSH
97602: EMPTY
97603: LIST
97604: LIST
97605: LIST
97606: PPUSH
97607: CALL_OW 69
97611: ST_TO_ADDR
// if not tmp then
97612: LD_VAR 0 1
97616: NOT
97617: IFFALSE 97621
// exit ;
97619: GO 97647
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
97621: LD_VAR 0 1
97625: PUSH
97626: LD_INT 1
97628: PPUSH
97629: LD_VAR 0 1
97633: PPUSH
97634: CALL_OW 12
97638: ARRAY
97639: PPUSH
97640: LD_INT 200
97642: PPUSH
97643: CALL_OW 234
// end ;
97647: PPOPN 1
97649: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
97650: LD_EXP 137
97654: PUSH
97655: LD_EXP 166
97659: AND
97660: IFFALSE 97739
97662: GO 97664
97664: DISABLE
97665: LD_INT 0
97667: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
97668: LD_ADDR_VAR 0 1
97672: PUSH
97673: LD_INT 22
97675: PUSH
97676: LD_OWVAR 2
97680: PUSH
97681: EMPTY
97682: LIST
97683: LIST
97684: PUSH
97685: LD_INT 21
97687: PUSH
97688: LD_INT 2
97690: PUSH
97691: EMPTY
97692: LIST
97693: LIST
97694: PUSH
97695: EMPTY
97696: LIST
97697: LIST
97698: PPUSH
97699: CALL_OW 69
97703: ST_TO_ADDR
// if not tmp then
97704: LD_VAR 0 1
97708: NOT
97709: IFFALSE 97713
// exit ;
97711: GO 97739
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
97713: LD_VAR 0 1
97717: PUSH
97718: LD_INT 1
97720: PPUSH
97721: LD_VAR 0 1
97725: PPUSH
97726: CALL_OW 12
97730: ARRAY
97731: PPUSH
97732: LD_INT 60
97734: PPUSH
97735: CALL_OW 234
// end ;
97739: PPOPN 1
97741: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
97742: LD_EXP 137
97746: PUSH
97747: LD_EXP 167
97751: AND
97752: IFFALSE 97851
97754: GO 97756
97756: DISABLE
97757: LD_INT 0
97759: PPUSH
97760: PPUSH
// begin enable ;
97761: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
97762: LD_ADDR_VAR 0 1
97766: PUSH
97767: LD_INT 22
97769: PUSH
97770: LD_OWVAR 2
97774: PUSH
97775: EMPTY
97776: LIST
97777: LIST
97778: PUSH
97779: LD_INT 61
97781: PUSH
97782: EMPTY
97783: LIST
97784: PUSH
97785: LD_INT 33
97787: PUSH
97788: LD_INT 2
97790: PUSH
97791: EMPTY
97792: LIST
97793: LIST
97794: PUSH
97795: EMPTY
97796: LIST
97797: LIST
97798: LIST
97799: PPUSH
97800: CALL_OW 69
97804: ST_TO_ADDR
// if not tmp then
97805: LD_VAR 0 1
97809: NOT
97810: IFFALSE 97814
// exit ;
97812: GO 97851
// for i in tmp do
97814: LD_ADDR_VAR 0 2
97818: PUSH
97819: LD_VAR 0 1
97823: PUSH
97824: FOR_IN
97825: IFFALSE 97849
// if IsControledBy ( i ) then
97827: LD_VAR 0 2
97831: PPUSH
97832: CALL_OW 312
97836: IFFALSE 97847
// ComUnlink ( i ) ;
97838: LD_VAR 0 2
97842: PPUSH
97843: CALL_OW 136
97847: GO 97824
97849: POP
97850: POP
// end ;
97851: PPOPN 2
97853: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
97854: LD_EXP 137
97858: PUSH
97859: LD_EXP 168
97863: AND
97864: IFFALSE 98004
97866: GO 97868
97868: DISABLE
97869: LD_INT 0
97871: PPUSH
97872: PPUSH
// begin ToLua ( displayPowell(); ) ;
97873: LD_STRING displayPowell();
97875: PPUSH
97876: CALL_OW 559
// uc_side := 0 ;
97880: LD_ADDR_OWVAR 20
97884: PUSH
97885: LD_INT 0
97887: ST_TO_ADDR
// uc_nation := 2 ;
97888: LD_ADDR_OWVAR 21
97892: PUSH
97893: LD_INT 2
97895: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
97896: LD_ADDR_OWVAR 37
97900: PUSH
97901: LD_INT 14
97903: ST_TO_ADDR
// vc_engine := engine_siberite ;
97904: LD_ADDR_OWVAR 39
97908: PUSH
97909: LD_INT 3
97911: ST_TO_ADDR
// vc_control := control_apeman ;
97912: LD_ADDR_OWVAR 38
97916: PUSH
97917: LD_INT 5
97919: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
97920: LD_ADDR_OWVAR 40
97924: PUSH
97925: LD_INT 29
97927: ST_TO_ADDR
// un := CreateVehicle ;
97928: LD_ADDR_VAR 0 2
97932: PUSH
97933: CALL_OW 45
97937: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
97938: LD_VAR 0 2
97942: PPUSH
97943: LD_INT 1
97945: PPUSH
97946: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
97950: LD_INT 35
97952: PPUSH
97953: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
97957: LD_VAR 0 2
97961: PPUSH
97962: LD_INT 22
97964: PUSH
97965: LD_OWVAR 2
97969: PUSH
97970: EMPTY
97971: LIST
97972: LIST
97973: PPUSH
97974: CALL_OW 69
97978: PPUSH
97979: LD_VAR 0 2
97983: PPUSH
97984: CALL_OW 74
97988: PPUSH
97989: CALL_OW 115
// until IsDead ( un ) ;
97993: LD_VAR 0 2
97997: PPUSH
97998: CALL_OW 301
98002: IFFALSE 97950
// end ;
98004: PPOPN 2
98006: END
// every 0 0$1 trigger StreamModeActive and sStu do
98007: LD_EXP 137
98011: PUSH
98012: LD_EXP 176
98016: AND
98017: IFFALSE 98033
98019: GO 98021
98021: DISABLE
// begin ToLua ( displayStucuk(); ) ;
98022: LD_STRING displayStucuk();
98024: PPUSH
98025: CALL_OW 559
// ResetFog ;
98029: CALL_OW 335
// end ;
98033: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
98034: LD_EXP 137
98038: PUSH
98039: LD_EXP 169
98043: AND
98044: IFFALSE 98185
98046: GO 98048
98048: DISABLE
98049: LD_INT 0
98051: PPUSH
98052: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
98053: LD_ADDR_VAR 0 2
98057: PUSH
98058: LD_INT 22
98060: PUSH
98061: LD_OWVAR 2
98065: PUSH
98066: EMPTY
98067: LIST
98068: LIST
98069: PUSH
98070: LD_INT 21
98072: PUSH
98073: LD_INT 1
98075: PUSH
98076: EMPTY
98077: LIST
98078: LIST
98079: PUSH
98080: EMPTY
98081: LIST
98082: LIST
98083: PPUSH
98084: CALL_OW 69
98088: ST_TO_ADDR
// if not tmp then
98089: LD_VAR 0 2
98093: NOT
98094: IFFALSE 98098
// exit ;
98096: GO 98185
// un := tmp [ rand ( 1 , tmp ) ] ;
98098: LD_ADDR_VAR 0 1
98102: PUSH
98103: LD_VAR 0 2
98107: PUSH
98108: LD_INT 1
98110: PPUSH
98111: LD_VAR 0 2
98115: PPUSH
98116: CALL_OW 12
98120: ARRAY
98121: ST_TO_ADDR
// SetSide ( un , 0 ) ;
98122: LD_VAR 0 1
98126: PPUSH
98127: LD_INT 0
98129: PPUSH
98130: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
98134: LD_VAR 0 1
98138: PPUSH
98139: LD_OWVAR 3
98143: PUSH
98144: LD_VAR 0 1
98148: DIFF
98149: PPUSH
98150: LD_VAR 0 1
98154: PPUSH
98155: CALL_OW 74
98159: PPUSH
98160: CALL_OW 115
// wait ( 0 0$20 ) ;
98164: LD_INT 700
98166: PPUSH
98167: CALL_OW 67
// SetSide ( un , your_side ) ;
98171: LD_VAR 0 1
98175: PPUSH
98176: LD_OWVAR 2
98180: PPUSH
98181: CALL_OW 235
// end ;
98185: PPOPN 2
98187: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
98188: LD_EXP 137
98192: PUSH
98193: LD_EXP 170
98197: AND
98198: IFFALSE 98304
98200: GO 98202
98202: DISABLE
98203: LD_INT 0
98205: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
98206: LD_ADDR_VAR 0 1
98210: PUSH
98211: LD_INT 22
98213: PUSH
98214: LD_OWVAR 2
98218: PUSH
98219: EMPTY
98220: LIST
98221: LIST
98222: PUSH
98223: LD_INT 2
98225: PUSH
98226: LD_INT 30
98228: PUSH
98229: LD_INT 0
98231: PUSH
98232: EMPTY
98233: LIST
98234: LIST
98235: PUSH
98236: LD_INT 30
98238: PUSH
98239: LD_INT 1
98241: PUSH
98242: EMPTY
98243: LIST
98244: LIST
98245: PUSH
98246: EMPTY
98247: LIST
98248: LIST
98249: LIST
98250: PUSH
98251: EMPTY
98252: LIST
98253: LIST
98254: PPUSH
98255: CALL_OW 69
98259: ST_TO_ADDR
// if not depot then
98260: LD_VAR 0 1
98264: NOT
98265: IFFALSE 98269
// exit ;
98267: GO 98304
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
98269: LD_VAR 0 1
98273: PUSH
98274: LD_INT 1
98276: ARRAY
98277: PPUSH
98278: CALL_OW 250
98282: PPUSH
98283: LD_VAR 0 1
98287: PUSH
98288: LD_INT 1
98290: ARRAY
98291: PPUSH
98292: CALL_OW 251
98296: PPUSH
98297: LD_INT 70
98299: PPUSH
98300: CALL_OW 495
// end ;
98304: PPOPN 1
98306: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
98307: LD_EXP 137
98311: PUSH
98312: LD_EXP 171
98316: AND
98317: IFFALSE 98528
98319: GO 98321
98321: DISABLE
98322: LD_INT 0
98324: PPUSH
98325: PPUSH
98326: PPUSH
98327: PPUSH
98328: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
98329: LD_ADDR_VAR 0 5
98333: PUSH
98334: LD_INT 22
98336: PUSH
98337: LD_OWVAR 2
98341: PUSH
98342: EMPTY
98343: LIST
98344: LIST
98345: PUSH
98346: LD_INT 21
98348: PUSH
98349: LD_INT 1
98351: PUSH
98352: EMPTY
98353: LIST
98354: LIST
98355: PUSH
98356: EMPTY
98357: LIST
98358: LIST
98359: PPUSH
98360: CALL_OW 69
98364: ST_TO_ADDR
// if not tmp then
98365: LD_VAR 0 5
98369: NOT
98370: IFFALSE 98374
// exit ;
98372: GO 98528
// for i in tmp do
98374: LD_ADDR_VAR 0 1
98378: PUSH
98379: LD_VAR 0 5
98383: PUSH
98384: FOR_IN
98385: IFFALSE 98526
// begin d := rand ( 0 , 5 ) ;
98387: LD_ADDR_VAR 0 4
98391: PUSH
98392: LD_INT 0
98394: PPUSH
98395: LD_INT 5
98397: PPUSH
98398: CALL_OW 12
98402: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
98403: LD_ADDR_VAR 0 2
98407: PUSH
98408: LD_VAR 0 1
98412: PPUSH
98413: CALL_OW 250
98417: PPUSH
98418: LD_VAR 0 4
98422: PPUSH
98423: LD_INT 3
98425: PPUSH
98426: LD_INT 12
98428: PPUSH
98429: CALL_OW 12
98433: PPUSH
98434: CALL_OW 272
98438: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
98439: LD_ADDR_VAR 0 3
98443: PUSH
98444: LD_VAR 0 1
98448: PPUSH
98449: CALL_OW 251
98453: PPUSH
98454: LD_VAR 0 4
98458: PPUSH
98459: LD_INT 3
98461: PPUSH
98462: LD_INT 12
98464: PPUSH
98465: CALL_OW 12
98469: PPUSH
98470: CALL_OW 273
98474: ST_TO_ADDR
// if ValidHex ( x , y ) then
98475: LD_VAR 0 2
98479: PPUSH
98480: LD_VAR 0 3
98484: PPUSH
98485: CALL_OW 488
98489: IFFALSE 98524
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
98491: LD_VAR 0 1
98495: PPUSH
98496: LD_VAR 0 2
98500: PPUSH
98501: LD_VAR 0 3
98505: PPUSH
98506: LD_INT 3
98508: PPUSH
98509: LD_INT 6
98511: PPUSH
98512: CALL_OW 12
98516: PPUSH
98517: LD_INT 1
98519: PPUSH
98520: CALL_OW 483
// end ;
98524: GO 98384
98526: POP
98527: POP
// end ;
98528: PPOPN 5
98530: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
98531: LD_EXP 137
98535: PUSH
98536: LD_EXP 172
98540: AND
98541: IFFALSE 98635
98543: GO 98545
98545: DISABLE
98546: LD_INT 0
98548: PPUSH
98549: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
98550: LD_ADDR_VAR 0 2
98554: PUSH
98555: LD_INT 22
98557: PUSH
98558: LD_OWVAR 2
98562: PUSH
98563: EMPTY
98564: LIST
98565: LIST
98566: PUSH
98567: LD_INT 32
98569: PUSH
98570: LD_INT 1
98572: PUSH
98573: EMPTY
98574: LIST
98575: LIST
98576: PUSH
98577: LD_INT 21
98579: PUSH
98580: LD_INT 2
98582: PUSH
98583: EMPTY
98584: LIST
98585: LIST
98586: PUSH
98587: EMPTY
98588: LIST
98589: LIST
98590: LIST
98591: PPUSH
98592: CALL_OW 69
98596: ST_TO_ADDR
// if not tmp then
98597: LD_VAR 0 2
98601: NOT
98602: IFFALSE 98606
// exit ;
98604: GO 98635
// for i in tmp do
98606: LD_ADDR_VAR 0 1
98610: PUSH
98611: LD_VAR 0 2
98615: PUSH
98616: FOR_IN
98617: IFFALSE 98633
// SetFuel ( i , 0 ) ;
98619: LD_VAR 0 1
98623: PPUSH
98624: LD_INT 0
98626: PPUSH
98627: CALL_OW 240
98631: GO 98616
98633: POP
98634: POP
// end ;
98635: PPOPN 2
98637: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
98638: LD_EXP 137
98642: PUSH
98643: LD_EXP 173
98647: AND
98648: IFFALSE 98714
98650: GO 98652
98652: DISABLE
98653: LD_INT 0
98655: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
98656: LD_ADDR_VAR 0 1
98660: PUSH
98661: LD_INT 22
98663: PUSH
98664: LD_OWVAR 2
98668: PUSH
98669: EMPTY
98670: LIST
98671: LIST
98672: PUSH
98673: LD_INT 30
98675: PUSH
98676: LD_INT 29
98678: PUSH
98679: EMPTY
98680: LIST
98681: LIST
98682: PUSH
98683: EMPTY
98684: LIST
98685: LIST
98686: PPUSH
98687: CALL_OW 69
98691: ST_TO_ADDR
// if not tmp then
98692: LD_VAR 0 1
98696: NOT
98697: IFFALSE 98701
// exit ;
98699: GO 98714
// DestroyUnit ( tmp [ 1 ] ) ;
98701: LD_VAR 0 1
98705: PUSH
98706: LD_INT 1
98708: ARRAY
98709: PPUSH
98710: CALL_OW 65
// end ;
98714: PPOPN 1
98716: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
98717: LD_EXP 137
98721: PUSH
98722: LD_EXP 175
98726: AND
98727: IFFALSE 98856
98729: GO 98731
98731: DISABLE
98732: LD_INT 0
98734: PPUSH
// begin uc_side := 0 ;
98735: LD_ADDR_OWVAR 20
98739: PUSH
98740: LD_INT 0
98742: ST_TO_ADDR
// uc_nation := nation_arabian ;
98743: LD_ADDR_OWVAR 21
98747: PUSH
98748: LD_INT 2
98750: ST_TO_ADDR
// hc_gallery :=  ;
98751: LD_ADDR_OWVAR 33
98755: PUSH
98756: LD_STRING 
98758: ST_TO_ADDR
// hc_name :=  ;
98759: LD_ADDR_OWVAR 26
98763: PUSH
98764: LD_STRING 
98766: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
98767: LD_INT 1
98769: PPUSH
98770: LD_INT 11
98772: PPUSH
98773: LD_INT 10
98775: PPUSH
98776: CALL_OW 380
// un := CreateHuman ;
98780: LD_ADDR_VAR 0 1
98784: PUSH
98785: CALL_OW 44
98789: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
98790: LD_VAR 0 1
98794: PPUSH
98795: LD_INT 1
98797: PPUSH
98798: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
98802: LD_INT 35
98804: PPUSH
98805: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
98809: LD_VAR 0 1
98813: PPUSH
98814: LD_INT 22
98816: PUSH
98817: LD_OWVAR 2
98821: PUSH
98822: EMPTY
98823: LIST
98824: LIST
98825: PPUSH
98826: CALL_OW 69
98830: PPUSH
98831: LD_VAR 0 1
98835: PPUSH
98836: CALL_OW 74
98840: PPUSH
98841: CALL_OW 115
// until IsDead ( un ) ;
98845: LD_VAR 0 1
98849: PPUSH
98850: CALL_OW 301
98854: IFFALSE 98802
// end ;
98856: PPOPN 1
98858: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
98859: LD_EXP 137
98863: PUSH
98864: LD_EXP 177
98868: AND
98869: IFFALSE 98881
98871: GO 98873
98873: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
98874: LD_STRING earthquake(getX(game), 0, 32)
98876: PPUSH
98877: CALL_OW 559
98881: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
98882: LD_EXP 137
98886: PUSH
98887: LD_EXP 178
98891: AND
98892: IFFALSE 98983
98894: GO 98896
98896: DISABLE
98897: LD_INT 0
98899: PPUSH
// begin enable ;
98900: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
98901: LD_ADDR_VAR 0 1
98905: PUSH
98906: LD_INT 22
98908: PUSH
98909: LD_OWVAR 2
98913: PUSH
98914: EMPTY
98915: LIST
98916: LIST
98917: PUSH
98918: LD_INT 21
98920: PUSH
98921: LD_INT 2
98923: PUSH
98924: EMPTY
98925: LIST
98926: LIST
98927: PUSH
98928: LD_INT 33
98930: PUSH
98931: LD_INT 3
98933: PUSH
98934: EMPTY
98935: LIST
98936: LIST
98937: PUSH
98938: EMPTY
98939: LIST
98940: LIST
98941: LIST
98942: PPUSH
98943: CALL_OW 69
98947: ST_TO_ADDR
// if not tmp then
98948: LD_VAR 0 1
98952: NOT
98953: IFFALSE 98957
// exit ;
98955: GO 98983
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
98957: LD_VAR 0 1
98961: PUSH
98962: LD_INT 1
98964: PPUSH
98965: LD_VAR 0 1
98969: PPUSH
98970: CALL_OW 12
98974: ARRAY
98975: PPUSH
98976: LD_INT 1
98978: PPUSH
98979: CALL_OW 234
// end ;
98983: PPOPN 1
98985: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
98986: LD_EXP 137
98990: PUSH
98991: LD_EXP 179
98995: AND
98996: IFFALSE 99137
98998: GO 99000
99000: DISABLE
99001: LD_INT 0
99003: PPUSH
99004: PPUSH
99005: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99006: LD_ADDR_VAR 0 3
99010: PUSH
99011: LD_INT 22
99013: PUSH
99014: LD_OWVAR 2
99018: PUSH
99019: EMPTY
99020: LIST
99021: LIST
99022: PUSH
99023: LD_INT 25
99025: PUSH
99026: LD_INT 1
99028: PUSH
99029: EMPTY
99030: LIST
99031: LIST
99032: PUSH
99033: EMPTY
99034: LIST
99035: LIST
99036: PPUSH
99037: CALL_OW 69
99041: ST_TO_ADDR
// if not tmp then
99042: LD_VAR 0 3
99046: NOT
99047: IFFALSE 99051
// exit ;
99049: GO 99137
// un := tmp [ rand ( 1 , tmp ) ] ;
99051: LD_ADDR_VAR 0 2
99055: PUSH
99056: LD_VAR 0 3
99060: PUSH
99061: LD_INT 1
99063: PPUSH
99064: LD_VAR 0 3
99068: PPUSH
99069: CALL_OW 12
99073: ARRAY
99074: ST_TO_ADDR
// if Crawls ( un ) then
99075: LD_VAR 0 2
99079: PPUSH
99080: CALL_OW 318
99084: IFFALSE 99095
// ComWalk ( un ) ;
99086: LD_VAR 0 2
99090: PPUSH
99091: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
99095: LD_VAR 0 2
99099: PPUSH
99100: LD_INT 9
99102: PPUSH
99103: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
99107: LD_INT 28
99109: PPUSH
99110: LD_OWVAR 2
99114: PPUSH
99115: LD_INT 2
99117: PPUSH
99118: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
99122: LD_INT 29
99124: PPUSH
99125: LD_OWVAR 2
99129: PPUSH
99130: LD_INT 2
99132: PPUSH
99133: CALL_OW 322
// end ;
99137: PPOPN 3
99139: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
99140: LD_EXP 137
99144: PUSH
99145: LD_EXP 180
99149: AND
99150: IFFALSE 99261
99152: GO 99154
99154: DISABLE
99155: LD_INT 0
99157: PPUSH
99158: PPUSH
99159: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99160: LD_ADDR_VAR 0 3
99164: PUSH
99165: LD_INT 22
99167: PUSH
99168: LD_OWVAR 2
99172: PUSH
99173: EMPTY
99174: LIST
99175: LIST
99176: PUSH
99177: LD_INT 25
99179: PUSH
99180: LD_INT 1
99182: PUSH
99183: EMPTY
99184: LIST
99185: LIST
99186: PUSH
99187: EMPTY
99188: LIST
99189: LIST
99190: PPUSH
99191: CALL_OW 69
99195: ST_TO_ADDR
// if not tmp then
99196: LD_VAR 0 3
99200: NOT
99201: IFFALSE 99205
// exit ;
99203: GO 99261
// un := tmp [ rand ( 1 , tmp ) ] ;
99205: LD_ADDR_VAR 0 2
99209: PUSH
99210: LD_VAR 0 3
99214: PUSH
99215: LD_INT 1
99217: PPUSH
99218: LD_VAR 0 3
99222: PPUSH
99223: CALL_OW 12
99227: ARRAY
99228: ST_TO_ADDR
// if Crawls ( un ) then
99229: LD_VAR 0 2
99233: PPUSH
99234: CALL_OW 318
99238: IFFALSE 99249
// ComWalk ( un ) ;
99240: LD_VAR 0 2
99244: PPUSH
99245: CALL_OW 138
// SetClass ( un , class_mortar ) ;
99249: LD_VAR 0 2
99253: PPUSH
99254: LD_INT 8
99256: PPUSH
99257: CALL_OW 336
// end ;
99261: PPOPN 3
99263: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
99264: LD_EXP 137
99268: PUSH
99269: LD_EXP 181
99273: AND
99274: IFFALSE 99418
99276: GO 99278
99278: DISABLE
99279: LD_INT 0
99281: PPUSH
99282: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
99283: LD_ADDR_VAR 0 2
99287: PUSH
99288: LD_INT 22
99290: PUSH
99291: LD_OWVAR 2
99295: PUSH
99296: EMPTY
99297: LIST
99298: LIST
99299: PUSH
99300: LD_INT 21
99302: PUSH
99303: LD_INT 2
99305: PUSH
99306: EMPTY
99307: LIST
99308: LIST
99309: PUSH
99310: LD_INT 2
99312: PUSH
99313: LD_INT 34
99315: PUSH
99316: LD_INT 12
99318: PUSH
99319: EMPTY
99320: LIST
99321: LIST
99322: PUSH
99323: LD_INT 34
99325: PUSH
99326: LD_INT 51
99328: PUSH
99329: EMPTY
99330: LIST
99331: LIST
99332: PUSH
99333: LD_INT 34
99335: PUSH
99336: LD_INT 32
99338: PUSH
99339: EMPTY
99340: LIST
99341: LIST
99342: PUSH
99343: EMPTY
99344: LIST
99345: LIST
99346: LIST
99347: LIST
99348: PUSH
99349: EMPTY
99350: LIST
99351: LIST
99352: LIST
99353: PPUSH
99354: CALL_OW 69
99358: ST_TO_ADDR
// if not tmp then
99359: LD_VAR 0 2
99363: NOT
99364: IFFALSE 99368
// exit ;
99366: GO 99418
// for i in tmp do
99368: LD_ADDR_VAR 0 1
99372: PUSH
99373: LD_VAR 0 2
99377: PUSH
99378: FOR_IN
99379: IFFALSE 99416
// if GetCargo ( i , mat_artifact ) = 0 then
99381: LD_VAR 0 1
99385: PPUSH
99386: LD_INT 4
99388: PPUSH
99389: CALL_OW 289
99393: PUSH
99394: LD_INT 0
99396: EQUAL
99397: IFFALSE 99414
// SetCargo ( i , mat_siberit , 100 ) ;
99399: LD_VAR 0 1
99403: PPUSH
99404: LD_INT 3
99406: PPUSH
99407: LD_INT 100
99409: PPUSH
99410: CALL_OW 290
99414: GO 99378
99416: POP
99417: POP
// end ;
99418: PPOPN 2
99420: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
99421: LD_EXP 137
99425: PUSH
99426: LD_EXP 182
99430: AND
99431: IFFALSE 99614
99433: GO 99435
99435: DISABLE
99436: LD_INT 0
99438: PPUSH
99439: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
99440: LD_ADDR_VAR 0 2
99444: PUSH
99445: LD_INT 22
99447: PUSH
99448: LD_OWVAR 2
99452: PUSH
99453: EMPTY
99454: LIST
99455: LIST
99456: PPUSH
99457: CALL_OW 69
99461: ST_TO_ADDR
// if not tmp then
99462: LD_VAR 0 2
99466: NOT
99467: IFFALSE 99471
// exit ;
99469: GO 99614
// for i := 1 to 2 do
99471: LD_ADDR_VAR 0 1
99475: PUSH
99476: DOUBLE
99477: LD_INT 1
99479: DEC
99480: ST_TO_ADDR
99481: LD_INT 2
99483: PUSH
99484: FOR_TO
99485: IFFALSE 99612
// begin uc_side := your_side ;
99487: LD_ADDR_OWVAR 20
99491: PUSH
99492: LD_OWVAR 2
99496: ST_TO_ADDR
// uc_nation := nation_american ;
99497: LD_ADDR_OWVAR 21
99501: PUSH
99502: LD_INT 1
99504: ST_TO_ADDR
// vc_chassis := us_morphling ;
99505: LD_ADDR_OWVAR 37
99509: PUSH
99510: LD_INT 5
99512: ST_TO_ADDR
// vc_engine := engine_siberite ;
99513: LD_ADDR_OWVAR 39
99517: PUSH
99518: LD_INT 3
99520: ST_TO_ADDR
// vc_control := control_computer ;
99521: LD_ADDR_OWVAR 38
99525: PUSH
99526: LD_INT 3
99528: ST_TO_ADDR
// vc_weapon := us_double_laser ;
99529: LD_ADDR_OWVAR 40
99533: PUSH
99534: LD_INT 10
99536: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
99537: LD_VAR 0 2
99541: PUSH
99542: LD_INT 1
99544: ARRAY
99545: PPUSH
99546: CALL_OW 310
99550: NOT
99551: IFFALSE 99598
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
99553: CALL_OW 45
99557: PPUSH
99558: LD_VAR 0 2
99562: PUSH
99563: LD_INT 1
99565: ARRAY
99566: PPUSH
99567: CALL_OW 250
99571: PPUSH
99572: LD_VAR 0 2
99576: PUSH
99577: LD_INT 1
99579: ARRAY
99580: PPUSH
99581: CALL_OW 251
99585: PPUSH
99586: LD_INT 12
99588: PPUSH
99589: LD_INT 1
99591: PPUSH
99592: CALL_OW 50
99596: GO 99610
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
99598: CALL_OW 45
99602: PPUSH
99603: LD_INT 1
99605: PPUSH
99606: CALL_OW 51
// end ;
99610: GO 99484
99612: POP
99613: POP
// end ;
99614: PPOPN 2
99616: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
99617: LD_EXP 137
99621: PUSH
99622: LD_EXP 183
99626: AND
99627: IFFALSE 99849
99629: GO 99631
99631: DISABLE
99632: LD_INT 0
99634: PPUSH
99635: PPUSH
99636: PPUSH
99637: PPUSH
99638: PPUSH
99639: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
99640: LD_ADDR_VAR 0 6
99644: PUSH
99645: LD_INT 22
99647: PUSH
99648: LD_OWVAR 2
99652: PUSH
99653: EMPTY
99654: LIST
99655: LIST
99656: PUSH
99657: LD_INT 21
99659: PUSH
99660: LD_INT 1
99662: PUSH
99663: EMPTY
99664: LIST
99665: LIST
99666: PUSH
99667: LD_INT 3
99669: PUSH
99670: LD_INT 23
99672: PUSH
99673: LD_INT 0
99675: PUSH
99676: EMPTY
99677: LIST
99678: LIST
99679: PUSH
99680: EMPTY
99681: LIST
99682: LIST
99683: PUSH
99684: EMPTY
99685: LIST
99686: LIST
99687: LIST
99688: PPUSH
99689: CALL_OW 69
99693: ST_TO_ADDR
// if not tmp then
99694: LD_VAR 0 6
99698: NOT
99699: IFFALSE 99703
// exit ;
99701: GO 99849
// s1 := rand ( 1 , 4 ) ;
99703: LD_ADDR_VAR 0 2
99707: PUSH
99708: LD_INT 1
99710: PPUSH
99711: LD_INT 4
99713: PPUSH
99714: CALL_OW 12
99718: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
99719: LD_ADDR_VAR 0 4
99723: PUSH
99724: LD_VAR 0 6
99728: PUSH
99729: LD_INT 1
99731: ARRAY
99732: PPUSH
99733: LD_VAR 0 2
99737: PPUSH
99738: CALL_OW 259
99742: ST_TO_ADDR
// if s1 = 1 then
99743: LD_VAR 0 2
99747: PUSH
99748: LD_INT 1
99750: EQUAL
99751: IFFALSE 99771
// s2 := rand ( 2 , 4 ) else
99753: LD_ADDR_VAR 0 3
99757: PUSH
99758: LD_INT 2
99760: PPUSH
99761: LD_INT 4
99763: PPUSH
99764: CALL_OW 12
99768: ST_TO_ADDR
99769: GO 99779
// s2 := 1 ;
99771: LD_ADDR_VAR 0 3
99775: PUSH
99776: LD_INT 1
99778: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
99779: LD_ADDR_VAR 0 5
99783: PUSH
99784: LD_VAR 0 6
99788: PUSH
99789: LD_INT 1
99791: ARRAY
99792: PPUSH
99793: LD_VAR 0 3
99797: PPUSH
99798: CALL_OW 259
99802: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
99803: LD_VAR 0 6
99807: PUSH
99808: LD_INT 1
99810: ARRAY
99811: PPUSH
99812: LD_VAR 0 2
99816: PPUSH
99817: LD_VAR 0 5
99821: PPUSH
99822: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
99826: LD_VAR 0 6
99830: PUSH
99831: LD_INT 1
99833: ARRAY
99834: PPUSH
99835: LD_VAR 0 3
99839: PPUSH
99840: LD_VAR 0 4
99844: PPUSH
99845: CALL_OW 237
// end ;
99849: PPOPN 6
99851: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
99852: LD_EXP 137
99856: PUSH
99857: LD_EXP 184
99861: AND
99862: IFFALSE 99941
99864: GO 99866
99866: DISABLE
99867: LD_INT 0
99869: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
99870: LD_ADDR_VAR 0 1
99874: PUSH
99875: LD_INT 22
99877: PUSH
99878: LD_OWVAR 2
99882: PUSH
99883: EMPTY
99884: LIST
99885: LIST
99886: PUSH
99887: LD_INT 30
99889: PUSH
99890: LD_INT 3
99892: PUSH
99893: EMPTY
99894: LIST
99895: LIST
99896: PUSH
99897: EMPTY
99898: LIST
99899: LIST
99900: PPUSH
99901: CALL_OW 69
99905: ST_TO_ADDR
// if not tmp then
99906: LD_VAR 0 1
99910: NOT
99911: IFFALSE 99915
// exit ;
99913: GO 99941
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
99915: LD_VAR 0 1
99919: PUSH
99920: LD_INT 1
99922: PPUSH
99923: LD_VAR 0 1
99927: PPUSH
99928: CALL_OW 12
99932: ARRAY
99933: PPUSH
99934: LD_INT 1
99936: PPUSH
99937: CALL_OW 234
// end ;
99941: PPOPN 1
99943: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
99944: LD_EXP 137
99948: PUSH
99949: LD_EXP 185
99953: AND
99954: IFFALSE 100066
99956: GO 99958
99958: DISABLE
99959: LD_INT 0
99961: PPUSH
99962: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
99963: LD_ADDR_VAR 0 2
99967: PUSH
99968: LD_INT 22
99970: PUSH
99971: LD_OWVAR 2
99975: PUSH
99976: EMPTY
99977: LIST
99978: LIST
99979: PUSH
99980: LD_INT 2
99982: PUSH
99983: LD_INT 30
99985: PUSH
99986: LD_INT 27
99988: PUSH
99989: EMPTY
99990: LIST
99991: LIST
99992: PUSH
99993: LD_INT 30
99995: PUSH
99996: LD_INT 26
99998: PUSH
99999: EMPTY
100000: LIST
100001: LIST
100002: PUSH
100003: LD_INT 30
100005: PUSH
100006: LD_INT 28
100008: PUSH
100009: EMPTY
100010: LIST
100011: LIST
100012: PUSH
100013: EMPTY
100014: LIST
100015: LIST
100016: LIST
100017: LIST
100018: PUSH
100019: EMPTY
100020: LIST
100021: LIST
100022: PPUSH
100023: CALL_OW 69
100027: ST_TO_ADDR
// if not tmp then
100028: LD_VAR 0 2
100032: NOT
100033: IFFALSE 100037
// exit ;
100035: GO 100066
// for i in tmp do
100037: LD_ADDR_VAR 0 1
100041: PUSH
100042: LD_VAR 0 2
100046: PUSH
100047: FOR_IN
100048: IFFALSE 100064
// SetLives ( i , 1 ) ;
100050: LD_VAR 0 1
100054: PPUSH
100055: LD_INT 1
100057: PPUSH
100058: CALL_OW 234
100062: GO 100047
100064: POP
100065: POP
// end ;
100066: PPOPN 2
100068: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
100069: LD_EXP 137
100073: PUSH
100074: LD_EXP 186
100078: AND
100079: IFFALSE 100353
100081: GO 100083
100083: DISABLE
100084: LD_INT 0
100086: PPUSH
100087: PPUSH
100088: PPUSH
// begin i := rand ( 1 , 7 ) ;
100089: LD_ADDR_VAR 0 1
100093: PUSH
100094: LD_INT 1
100096: PPUSH
100097: LD_INT 7
100099: PPUSH
100100: CALL_OW 12
100104: ST_TO_ADDR
// case i of 1 :
100105: LD_VAR 0 1
100109: PUSH
100110: LD_INT 1
100112: DOUBLE
100113: EQUAL
100114: IFTRUE 100118
100116: GO 100128
100118: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
100119: LD_STRING earthquake(getX(game), 0, 32)
100121: PPUSH
100122: CALL_OW 559
100126: GO 100353
100128: LD_INT 2
100130: DOUBLE
100131: EQUAL
100132: IFTRUE 100136
100134: GO 100150
100136: POP
// begin ToLua ( displayStucuk(); ) ;
100137: LD_STRING displayStucuk();
100139: PPUSH
100140: CALL_OW 559
// ResetFog ;
100144: CALL_OW 335
// end ; 3 :
100148: GO 100353
100150: LD_INT 3
100152: DOUBLE
100153: EQUAL
100154: IFTRUE 100158
100156: GO 100262
100158: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100159: LD_ADDR_VAR 0 2
100163: PUSH
100164: LD_INT 22
100166: PUSH
100167: LD_OWVAR 2
100171: PUSH
100172: EMPTY
100173: LIST
100174: LIST
100175: PUSH
100176: LD_INT 25
100178: PUSH
100179: LD_INT 1
100181: PUSH
100182: EMPTY
100183: LIST
100184: LIST
100185: PUSH
100186: EMPTY
100187: LIST
100188: LIST
100189: PPUSH
100190: CALL_OW 69
100194: ST_TO_ADDR
// if not tmp then
100195: LD_VAR 0 2
100199: NOT
100200: IFFALSE 100204
// exit ;
100202: GO 100353
// un := tmp [ rand ( 1 , tmp ) ] ;
100204: LD_ADDR_VAR 0 3
100208: PUSH
100209: LD_VAR 0 2
100213: PUSH
100214: LD_INT 1
100216: PPUSH
100217: LD_VAR 0 2
100221: PPUSH
100222: CALL_OW 12
100226: ARRAY
100227: ST_TO_ADDR
// if Crawls ( un ) then
100228: LD_VAR 0 3
100232: PPUSH
100233: CALL_OW 318
100237: IFFALSE 100248
// ComWalk ( un ) ;
100239: LD_VAR 0 3
100243: PPUSH
100244: CALL_OW 138
// SetClass ( un , class_mortar ) ;
100248: LD_VAR 0 3
100252: PPUSH
100253: LD_INT 8
100255: PPUSH
100256: CALL_OW 336
// end ; 4 :
100260: GO 100353
100262: LD_INT 4
100264: DOUBLE
100265: EQUAL
100266: IFTRUE 100270
100268: GO 100331
100270: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
100271: LD_ADDR_VAR 0 2
100275: PUSH
100276: LD_INT 22
100278: PUSH
100279: LD_OWVAR 2
100283: PUSH
100284: EMPTY
100285: LIST
100286: LIST
100287: PUSH
100288: LD_INT 30
100290: PUSH
100291: LD_INT 29
100293: PUSH
100294: EMPTY
100295: LIST
100296: LIST
100297: PUSH
100298: EMPTY
100299: LIST
100300: LIST
100301: PPUSH
100302: CALL_OW 69
100306: ST_TO_ADDR
// if not tmp then
100307: LD_VAR 0 2
100311: NOT
100312: IFFALSE 100316
// exit ;
100314: GO 100353
// DestroyUnit ( tmp [ 1 ] ) ;
100316: LD_VAR 0 2
100320: PUSH
100321: LD_INT 1
100323: ARRAY
100324: PPUSH
100325: CALL_OW 65
// end ; 5 .. 7 :
100329: GO 100353
100331: LD_INT 5
100333: DOUBLE
100334: GREATEREQUAL
100335: IFFALSE 100343
100337: LD_INT 7
100339: DOUBLE
100340: LESSEQUAL
100341: IFTRUE 100345
100343: GO 100352
100345: POP
// StreamSibBomb ; end ;
100346: CALL 96603 0 0
100350: GO 100353
100352: POP
// end ;
100353: PPOPN 3
100355: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
100356: LD_EXP 137
100360: PUSH
100361: LD_EXP 187
100365: AND
100366: IFFALSE 100522
100368: GO 100370
100370: DISABLE
100371: LD_INT 0
100373: PPUSH
100374: PPUSH
100375: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
100376: LD_ADDR_VAR 0 2
100380: PUSH
100381: LD_INT 81
100383: PUSH
100384: LD_OWVAR 2
100388: PUSH
100389: EMPTY
100390: LIST
100391: LIST
100392: PUSH
100393: LD_INT 2
100395: PUSH
100396: LD_INT 21
100398: PUSH
100399: LD_INT 1
100401: PUSH
100402: EMPTY
100403: LIST
100404: LIST
100405: PUSH
100406: LD_INT 21
100408: PUSH
100409: LD_INT 2
100411: PUSH
100412: EMPTY
100413: LIST
100414: LIST
100415: PUSH
100416: EMPTY
100417: LIST
100418: LIST
100419: LIST
100420: PUSH
100421: EMPTY
100422: LIST
100423: LIST
100424: PPUSH
100425: CALL_OW 69
100429: ST_TO_ADDR
// if not tmp then
100430: LD_VAR 0 2
100434: NOT
100435: IFFALSE 100439
// exit ;
100437: GO 100522
// p := 0 ;
100439: LD_ADDR_VAR 0 3
100443: PUSH
100444: LD_INT 0
100446: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
100447: LD_INT 35
100449: PPUSH
100450: CALL_OW 67
// p := p + 1 ;
100454: LD_ADDR_VAR 0 3
100458: PUSH
100459: LD_VAR 0 3
100463: PUSH
100464: LD_INT 1
100466: PLUS
100467: ST_TO_ADDR
// for i in tmp do
100468: LD_ADDR_VAR 0 1
100472: PUSH
100473: LD_VAR 0 2
100477: PUSH
100478: FOR_IN
100479: IFFALSE 100510
// if GetLives ( i ) < 1000 then
100481: LD_VAR 0 1
100485: PPUSH
100486: CALL_OW 256
100490: PUSH
100491: LD_INT 1000
100493: LESS
100494: IFFALSE 100508
// SetLives ( i , 1000 ) ;
100496: LD_VAR 0 1
100500: PPUSH
100501: LD_INT 1000
100503: PPUSH
100504: CALL_OW 234
100508: GO 100478
100510: POP
100511: POP
// until p > 20 ;
100512: LD_VAR 0 3
100516: PUSH
100517: LD_INT 20
100519: GREATER
100520: IFFALSE 100447
// end ;
100522: PPOPN 3
100524: END
// every 0 0$1 trigger StreamModeActive and sTime do
100525: LD_EXP 137
100529: PUSH
100530: LD_EXP 188
100534: AND
100535: IFFALSE 100570
100537: GO 100539
100539: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
100540: LD_INT 28
100542: PPUSH
100543: LD_OWVAR 2
100547: PPUSH
100548: LD_INT 2
100550: PPUSH
100551: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
100555: LD_INT 30
100557: PPUSH
100558: LD_OWVAR 2
100562: PPUSH
100563: LD_INT 2
100565: PPUSH
100566: CALL_OW 322
// end ;
100570: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
100571: LD_EXP 137
100575: PUSH
100576: LD_EXP 189
100580: AND
100581: IFFALSE 100702
100583: GO 100585
100585: DISABLE
100586: LD_INT 0
100588: PPUSH
100589: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100590: LD_ADDR_VAR 0 2
100594: PUSH
100595: LD_INT 22
100597: PUSH
100598: LD_OWVAR 2
100602: PUSH
100603: EMPTY
100604: LIST
100605: LIST
100606: PUSH
100607: LD_INT 21
100609: PUSH
100610: LD_INT 1
100612: PUSH
100613: EMPTY
100614: LIST
100615: LIST
100616: PUSH
100617: LD_INT 3
100619: PUSH
100620: LD_INT 23
100622: PUSH
100623: LD_INT 0
100625: PUSH
100626: EMPTY
100627: LIST
100628: LIST
100629: PUSH
100630: EMPTY
100631: LIST
100632: LIST
100633: PUSH
100634: EMPTY
100635: LIST
100636: LIST
100637: LIST
100638: PPUSH
100639: CALL_OW 69
100643: ST_TO_ADDR
// if not tmp then
100644: LD_VAR 0 2
100648: NOT
100649: IFFALSE 100653
// exit ;
100651: GO 100702
// for i in tmp do
100653: LD_ADDR_VAR 0 1
100657: PUSH
100658: LD_VAR 0 2
100662: PUSH
100663: FOR_IN
100664: IFFALSE 100700
// begin if Crawls ( i ) then
100666: LD_VAR 0 1
100670: PPUSH
100671: CALL_OW 318
100675: IFFALSE 100686
// ComWalk ( i ) ;
100677: LD_VAR 0 1
100681: PPUSH
100682: CALL_OW 138
// SetClass ( i , 2 ) ;
100686: LD_VAR 0 1
100690: PPUSH
100691: LD_INT 2
100693: PPUSH
100694: CALL_OW 336
// end ;
100698: GO 100663
100700: POP
100701: POP
// end ;
100702: PPOPN 2
100704: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
100705: LD_EXP 137
100709: PUSH
100710: LD_EXP 190
100714: AND
100715: IFFALSE 100996
100717: GO 100719
100719: DISABLE
100720: LD_INT 0
100722: PPUSH
100723: PPUSH
100724: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
100725: LD_OWVAR 2
100729: PPUSH
100730: LD_INT 9
100732: PPUSH
100733: LD_INT 1
100735: PPUSH
100736: LD_INT 1
100738: PPUSH
100739: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
100743: LD_INT 9
100745: PPUSH
100746: LD_OWVAR 2
100750: PPUSH
100751: CALL_OW 343
// uc_side := 9 ;
100755: LD_ADDR_OWVAR 20
100759: PUSH
100760: LD_INT 9
100762: ST_TO_ADDR
// uc_nation := 2 ;
100763: LD_ADDR_OWVAR 21
100767: PUSH
100768: LD_INT 2
100770: ST_TO_ADDR
// hc_name := Dark Warrior ;
100771: LD_ADDR_OWVAR 26
100775: PUSH
100776: LD_STRING Dark Warrior
100778: ST_TO_ADDR
// hc_gallery :=  ;
100779: LD_ADDR_OWVAR 33
100783: PUSH
100784: LD_STRING 
100786: ST_TO_ADDR
// hc_noskilllimit := true ;
100787: LD_ADDR_OWVAR 76
100791: PUSH
100792: LD_INT 1
100794: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
100795: LD_ADDR_OWVAR 31
100799: PUSH
100800: LD_INT 30
100802: PUSH
100803: LD_INT 30
100805: PUSH
100806: LD_INT 30
100808: PUSH
100809: LD_INT 30
100811: PUSH
100812: EMPTY
100813: LIST
100814: LIST
100815: LIST
100816: LIST
100817: ST_TO_ADDR
// un := CreateHuman ;
100818: LD_ADDR_VAR 0 3
100822: PUSH
100823: CALL_OW 44
100827: ST_TO_ADDR
// hc_noskilllimit := false ;
100828: LD_ADDR_OWVAR 76
100832: PUSH
100833: LD_INT 0
100835: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
100836: LD_VAR 0 3
100840: PPUSH
100841: LD_INT 1
100843: PPUSH
100844: CALL_OW 51
// p := 0 ;
100848: LD_ADDR_VAR 0 2
100852: PUSH
100853: LD_INT 0
100855: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
100856: LD_INT 35
100858: PPUSH
100859: CALL_OW 67
// p := p + 1 ;
100863: LD_ADDR_VAR 0 2
100867: PUSH
100868: LD_VAR 0 2
100872: PUSH
100873: LD_INT 1
100875: PLUS
100876: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
100877: LD_VAR 0 3
100881: PPUSH
100882: CALL_OW 256
100886: PUSH
100887: LD_INT 1000
100889: LESS
100890: IFFALSE 100904
// SetLives ( un , 1000 ) ;
100892: LD_VAR 0 3
100896: PPUSH
100897: LD_INT 1000
100899: PPUSH
100900: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
100904: LD_VAR 0 3
100908: PPUSH
100909: LD_INT 81
100911: PUSH
100912: LD_OWVAR 2
100916: PUSH
100917: EMPTY
100918: LIST
100919: LIST
100920: PUSH
100921: LD_INT 91
100923: PUSH
100924: LD_VAR 0 3
100928: PUSH
100929: LD_INT 30
100931: PUSH
100932: EMPTY
100933: LIST
100934: LIST
100935: LIST
100936: PUSH
100937: EMPTY
100938: LIST
100939: LIST
100940: PPUSH
100941: CALL_OW 69
100945: PPUSH
100946: LD_VAR 0 3
100950: PPUSH
100951: CALL_OW 74
100955: PPUSH
100956: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
100960: LD_VAR 0 2
100964: PUSH
100965: LD_INT 60
100967: GREATER
100968: PUSH
100969: LD_VAR 0 3
100973: PPUSH
100974: CALL_OW 301
100978: OR
100979: IFFALSE 100856
// if un then
100981: LD_VAR 0 3
100985: IFFALSE 100996
// RemoveUnit ( un ) ;
100987: LD_VAR 0 3
100991: PPUSH
100992: CALL_OW 64
// end ;
100996: PPOPN 3
100998: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
100999: LD_INT 0
101001: PPUSH
// case cmd of 301 :
101002: LD_VAR 0 1
101006: PUSH
101007: LD_INT 301
101009: DOUBLE
101010: EQUAL
101011: IFTRUE 101015
101013: GO 101047
101015: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
101016: LD_VAR 0 6
101020: PPUSH
101021: LD_VAR 0 7
101025: PPUSH
101026: LD_VAR 0 8
101030: PPUSH
101031: LD_VAR 0 4
101035: PPUSH
101036: LD_VAR 0 5
101040: PPUSH
101041: CALL 102248 0 5
101045: GO 101168
101047: LD_INT 302
101049: DOUBLE
101050: EQUAL
101051: IFTRUE 101055
101053: GO 101092
101055: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
101056: LD_VAR 0 6
101060: PPUSH
101061: LD_VAR 0 7
101065: PPUSH
101066: LD_VAR 0 8
101070: PPUSH
101071: LD_VAR 0 9
101075: PPUSH
101076: LD_VAR 0 4
101080: PPUSH
101081: LD_VAR 0 5
101085: PPUSH
101086: CALL 102339 0 6
101090: GO 101168
101092: LD_INT 303
101094: DOUBLE
101095: EQUAL
101096: IFTRUE 101100
101098: GO 101137
101100: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
101101: LD_VAR 0 6
101105: PPUSH
101106: LD_VAR 0 7
101110: PPUSH
101111: LD_VAR 0 8
101115: PPUSH
101116: LD_VAR 0 9
101120: PPUSH
101121: LD_VAR 0 4
101125: PPUSH
101126: LD_VAR 0 5
101130: PPUSH
101131: CALL 101173 0 6
101135: GO 101168
101137: LD_INT 304
101139: DOUBLE
101140: EQUAL
101141: IFTRUE 101145
101143: GO 101167
101145: POP
// hHackTeleport ( unit , x , y ) ; end ;
101146: LD_VAR 0 2
101150: PPUSH
101151: LD_VAR 0 4
101155: PPUSH
101156: LD_VAR 0 5
101160: PPUSH
101161: CALL 102932 0 3
101165: GO 101168
101167: POP
// end ;
101168: LD_VAR 0 12
101172: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
101173: LD_INT 0
101175: PPUSH
101176: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
101177: LD_VAR 0 1
101181: PUSH
101182: LD_INT 1
101184: LESS
101185: PUSH
101186: LD_VAR 0 1
101190: PUSH
101191: LD_INT 3
101193: GREATER
101194: OR
101195: PUSH
101196: LD_VAR 0 5
101200: PPUSH
101201: LD_VAR 0 6
101205: PPUSH
101206: CALL_OW 428
101210: OR
101211: IFFALSE 101215
// exit ;
101213: GO 101935
// uc_side := your_side ;
101215: LD_ADDR_OWVAR 20
101219: PUSH
101220: LD_OWVAR 2
101224: ST_TO_ADDR
// uc_nation := nation ;
101225: LD_ADDR_OWVAR 21
101229: PUSH
101230: LD_VAR 0 1
101234: ST_TO_ADDR
// bc_level = 1 ;
101235: LD_ADDR_OWVAR 43
101239: PUSH
101240: LD_INT 1
101242: ST_TO_ADDR
// case btype of 1 :
101243: LD_VAR 0 2
101247: PUSH
101248: LD_INT 1
101250: DOUBLE
101251: EQUAL
101252: IFTRUE 101256
101254: GO 101267
101256: POP
// bc_type := b_depot ; 2 :
101257: LD_ADDR_OWVAR 42
101261: PUSH
101262: LD_INT 0
101264: ST_TO_ADDR
101265: GO 101879
101267: LD_INT 2
101269: DOUBLE
101270: EQUAL
101271: IFTRUE 101275
101273: GO 101286
101275: POP
// bc_type := b_warehouse ; 3 :
101276: LD_ADDR_OWVAR 42
101280: PUSH
101281: LD_INT 1
101283: ST_TO_ADDR
101284: GO 101879
101286: LD_INT 3
101288: DOUBLE
101289: EQUAL
101290: IFTRUE 101294
101292: GO 101305
101294: POP
// bc_type := b_lab ; 4 .. 9 :
101295: LD_ADDR_OWVAR 42
101299: PUSH
101300: LD_INT 6
101302: ST_TO_ADDR
101303: GO 101879
101305: LD_INT 4
101307: DOUBLE
101308: GREATEREQUAL
101309: IFFALSE 101317
101311: LD_INT 9
101313: DOUBLE
101314: LESSEQUAL
101315: IFTRUE 101319
101317: GO 101371
101319: POP
// begin bc_type := b_lab_half ;
101320: LD_ADDR_OWVAR 42
101324: PUSH
101325: LD_INT 7
101327: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
101328: LD_ADDR_OWVAR 44
101332: PUSH
101333: LD_INT 10
101335: PUSH
101336: LD_INT 11
101338: PUSH
101339: LD_INT 12
101341: PUSH
101342: LD_INT 15
101344: PUSH
101345: LD_INT 14
101347: PUSH
101348: LD_INT 13
101350: PUSH
101351: EMPTY
101352: LIST
101353: LIST
101354: LIST
101355: LIST
101356: LIST
101357: LIST
101358: PUSH
101359: LD_VAR 0 2
101363: PUSH
101364: LD_INT 3
101366: MINUS
101367: ARRAY
101368: ST_TO_ADDR
// end ; 10 .. 13 :
101369: GO 101879
101371: LD_INT 10
101373: DOUBLE
101374: GREATEREQUAL
101375: IFFALSE 101383
101377: LD_INT 13
101379: DOUBLE
101380: LESSEQUAL
101381: IFTRUE 101385
101383: GO 101462
101385: POP
// begin bc_type := b_lab_full ;
101386: LD_ADDR_OWVAR 42
101390: PUSH
101391: LD_INT 8
101393: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
101394: LD_ADDR_OWVAR 44
101398: PUSH
101399: LD_INT 10
101401: PUSH
101402: LD_INT 12
101404: PUSH
101405: LD_INT 14
101407: PUSH
101408: LD_INT 13
101410: PUSH
101411: EMPTY
101412: LIST
101413: LIST
101414: LIST
101415: LIST
101416: PUSH
101417: LD_VAR 0 2
101421: PUSH
101422: LD_INT 9
101424: MINUS
101425: ARRAY
101426: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
101427: LD_ADDR_OWVAR 45
101431: PUSH
101432: LD_INT 11
101434: PUSH
101435: LD_INT 15
101437: PUSH
101438: LD_INT 12
101440: PUSH
101441: LD_INT 15
101443: PUSH
101444: EMPTY
101445: LIST
101446: LIST
101447: LIST
101448: LIST
101449: PUSH
101450: LD_VAR 0 2
101454: PUSH
101455: LD_INT 9
101457: MINUS
101458: ARRAY
101459: ST_TO_ADDR
// end ; 14 :
101460: GO 101879
101462: LD_INT 14
101464: DOUBLE
101465: EQUAL
101466: IFTRUE 101470
101468: GO 101481
101470: POP
// bc_type := b_workshop ; 15 :
101471: LD_ADDR_OWVAR 42
101475: PUSH
101476: LD_INT 2
101478: ST_TO_ADDR
101479: GO 101879
101481: LD_INT 15
101483: DOUBLE
101484: EQUAL
101485: IFTRUE 101489
101487: GO 101500
101489: POP
// bc_type := b_factory ; 16 :
101490: LD_ADDR_OWVAR 42
101494: PUSH
101495: LD_INT 3
101497: ST_TO_ADDR
101498: GO 101879
101500: LD_INT 16
101502: DOUBLE
101503: EQUAL
101504: IFTRUE 101508
101506: GO 101519
101508: POP
// bc_type := b_ext_gun ; 17 :
101509: LD_ADDR_OWVAR 42
101513: PUSH
101514: LD_INT 17
101516: ST_TO_ADDR
101517: GO 101879
101519: LD_INT 17
101521: DOUBLE
101522: EQUAL
101523: IFTRUE 101527
101525: GO 101555
101527: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
101528: LD_ADDR_OWVAR 42
101532: PUSH
101533: LD_INT 19
101535: PUSH
101536: LD_INT 23
101538: PUSH
101539: LD_INT 19
101541: PUSH
101542: EMPTY
101543: LIST
101544: LIST
101545: LIST
101546: PUSH
101547: LD_VAR 0 1
101551: ARRAY
101552: ST_TO_ADDR
101553: GO 101879
101555: LD_INT 18
101557: DOUBLE
101558: EQUAL
101559: IFTRUE 101563
101561: GO 101574
101563: POP
// bc_type := b_ext_radar ; 19 :
101564: LD_ADDR_OWVAR 42
101568: PUSH
101569: LD_INT 20
101571: ST_TO_ADDR
101572: GO 101879
101574: LD_INT 19
101576: DOUBLE
101577: EQUAL
101578: IFTRUE 101582
101580: GO 101593
101582: POP
// bc_type := b_ext_radio ; 20 :
101583: LD_ADDR_OWVAR 42
101587: PUSH
101588: LD_INT 22
101590: ST_TO_ADDR
101591: GO 101879
101593: LD_INT 20
101595: DOUBLE
101596: EQUAL
101597: IFTRUE 101601
101599: GO 101612
101601: POP
// bc_type := b_ext_siberium ; 21 :
101602: LD_ADDR_OWVAR 42
101606: PUSH
101607: LD_INT 21
101609: ST_TO_ADDR
101610: GO 101879
101612: LD_INT 21
101614: DOUBLE
101615: EQUAL
101616: IFTRUE 101620
101618: GO 101631
101620: POP
// bc_type := b_ext_computer ; 22 :
101621: LD_ADDR_OWVAR 42
101625: PUSH
101626: LD_INT 24
101628: ST_TO_ADDR
101629: GO 101879
101631: LD_INT 22
101633: DOUBLE
101634: EQUAL
101635: IFTRUE 101639
101637: GO 101650
101639: POP
// bc_type := b_ext_track ; 23 :
101640: LD_ADDR_OWVAR 42
101644: PUSH
101645: LD_INT 16
101647: ST_TO_ADDR
101648: GO 101879
101650: LD_INT 23
101652: DOUBLE
101653: EQUAL
101654: IFTRUE 101658
101656: GO 101669
101658: POP
// bc_type := b_ext_laser ; 24 :
101659: LD_ADDR_OWVAR 42
101663: PUSH
101664: LD_INT 25
101666: ST_TO_ADDR
101667: GO 101879
101669: LD_INT 24
101671: DOUBLE
101672: EQUAL
101673: IFTRUE 101677
101675: GO 101688
101677: POP
// bc_type := b_control_tower ; 25 :
101678: LD_ADDR_OWVAR 42
101682: PUSH
101683: LD_INT 36
101685: ST_TO_ADDR
101686: GO 101879
101688: LD_INT 25
101690: DOUBLE
101691: EQUAL
101692: IFTRUE 101696
101694: GO 101707
101696: POP
// bc_type := b_breastwork ; 26 :
101697: LD_ADDR_OWVAR 42
101701: PUSH
101702: LD_INT 31
101704: ST_TO_ADDR
101705: GO 101879
101707: LD_INT 26
101709: DOUBLE
101710: EQUAL
101711: IFTRUE 101715
101713: GO 101726
101715: POP
// bc_type := b_bunker ; 27 :
101716: LD_ADDR_OWVAR 42
101720: PUSH
101721: LD_INT 32
101723: ST_TO_ADDR
101724: GO 101879
101726: LD_INT 27
101728: DOUBLE
101729: EQUAL
101730: IFTRUE 101734
101732: GO 101745
101734: POP
// bc_type := b_turret ; 28 :
101735: LD_ADDR_OWVAR 42
101739: PUSH
101740: LD_INT 33
101742: ST_TO_ADDR
101743: GO 101879
101745: LD_INT 28
101747: DOUBLE
101748: EQUAL
101749: IFTRUE 101753
101751: GO 101764
101753: POP
// bc_type := b_armoury ; 29 :
101754: LD_ADDR_OWVAR 42
101758: PUSH
101759: LD_INT 4
101761: ST_TO_ADDR
101762: GO 101879
101764: LD_INT 29
101766: DOUBLE
101767: EQUAL
101768: IFTRUE 101772
101770: GO 101783
101772: POP
// bc_type := b_barracks ; 30 :
101773: LD_ADDR_OWVAR 42
101777: PUSH
101778: LD_INT 5
101780: ST_TO_ADDR
101781: GO 101879
101783: LD_INT 30
101785: DOUBLE
101786: EQUAL
101787: IFTRUE 101791
101789: GO 101802
101791: POP
// bc_type := b_solar_power ; 31 :
101792: LD_ADDR_OWVAR 42
101796: PUSH
101797: LD_INT 27
101799: ST_TO_ADDR
101800: GO 101879
101802: LD_INT 31
101804: DOUBLE
101805: EQUAL
101806: IFTRUE 101810
101808: GO 101821
101810: POP
// bc_type := b_oil_power ; 32 :
101811: LD_ADDR_OWVAR 42
101815: PUSH
101816: LD_INT 26
101818: ST_TO_ADDR
101819: GO 101879
101821: LD_INT 32
101823: DOUBLE
101824: EQUAL
101825: IFTRUE 101829
101827: GO 101840
101829: POP
// bc_type := b_siberite_power ; 33 :
101830: LD_ADDR_OWVAR 42
101834: PUSH
101835: LD_INT 28
101837: ST_TO_ADDR
101838: GO 101879
101840: LD_INT 33
101842: DOUBLE
101843: EQUAL
101844: IFTRUE 101848
101846: GO 101859
101848: POP
// bc_type := b_oil_mine ; 34 :
101849: LD_ADDR_OWVAR 42
101853: PUSH
101854: LD_INT 29
101856: ST_TO_ADDR
101857: GO 101879
101859: LD_INT 34
101861: DOUBLE
101862: EQUAL
101863: IFTRUE 101867
101865: GO 101878
101867: POP
// bc_type := b_siberite_mine ; end ;
101868: LD_ADDR_OWVAR 42
101872: PUSH
101873: LD_INT 30
101875: ST_TO_ADDR
101876: GO 101879
101878: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
101879: LD_ADDR_VAR 0 8
101883: PUSH
101884: LD_VAR 0 5
101888: PPUSH
101889: LD_VAR 0 6
101893: PPUSH
101894: LD_VAR 0 3
101898: PPUSH
101899: CALL_OW 47
101903: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
101904: LD_OWVAR 42
101908: PUSH
101909: LD_INT 32
101911: PUSH
101912: LD_INT 33
101914: PUSH
101915: EMPTY
101916: LIST
101917: LIST
101918: IN
101919: IFFALSE 101935
// PlaceWeaponTurret ( b , weapon ) ;
101921: LD_VAR 0 8
101925: PPUSH
101926: LD_VAR 0 4
101930: PPUSH
101931: CALL_OW 431
// end ;
101935: LD_VAR 0 7
101939: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
101940: LD_INT 0
101942: PPUSH
101943: PPUSH
101944: PPUSH
101945: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
101946: LD_ADDR_VAR 0 4
101950: PUSH
101951: LD_INT 22
101953: PUSH
101954: LD_OWVAR 2
101958: PUSH
101959: EMPTY
101960: LIST
101961: LIST
101962: PUSH
101963: LD_INT 2
101965: PUSH
101966: LD_INT 30
101968: PUSH
101969: LD_INT 0
101971: PUSH
101972: EMPTY
101973: LIST
101974: LIST
101975: PUSH
101976: LD_INT 30
101978: PUSH
101979: LD_INT 1
101981: PUSH
101982: EMPTY
101983: LIST
101984: LIST
101985: PUSH
101986: EMPTY
101987: LIST
101988: LIST
101989: LIST
101990: PUSH
101991: EMPTY
101992: LIST
101993: LIST
101994: PPUSH
101995: CALL_OW 69
101999: ST_TO_ADDR
// if not tmp then
102000: LD_VAR 0 4
102004: NOT
102005: IFFALSE 102009
// exit ;
102007: GO 102068
// for i in tmp do
102009: LD_ADDR_VAR 0 2
102013: PUSH
102014: LD_VAR 0 4
102018: PUSH
102019: FOR_IN
102020: IFFALSE 102066
// for j = 1 to 3 do
102022: LD_ADDR_VAR 0 3
102026: PUSH
102027: DOUBLE
102028: LD_INT 1
102030: DEC
102031: ST_TO_ADDR
102032: LD_INT 3
102034: PUSH
102035: FOR_TO
102036: IFFALSE 102062
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
102038: LD_VAR 0 2
102042: PPUSH
102043: CALL_OW 274
102047: PPUSH
102048: LD_VAR 0 3
102052: PPUSH
102053: LD_INT 99999
102055: PPUSH
102056: CALL_OW 277
102060: GO 102035
102062: POP
102063: POP
102064: GO 102019
102066: POP
102067: POP
// end ;
102068: LD_VAR 0 1
102072: RET
// export function hHackSetLevel10 ; var i , j ; begin
102073: LD_INT 0
102075: PPUSH
102076: PPUSH
102077: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
102078: LD_ADDR_VAR 0 2
102082: PUSH
102083: LD_INT 21
102085: PUSH
102086: LD_INT 1
102088: PUSH
102089: EMPTY
102090: LIST
102091: LIST
102092: PPUSH
102093: CALL_OW 69
102097: PUSH
102098: FOR_IN
102099: IFFALSE 102151
// if IsSelected ( i ) then
102101: LD_VAR 0 2
102105: PPUSH
102106: CALL_OW 306
102110: IFFALSE 102149
// begin for j := 1 to 4 do
102112: LD_ADDR_VAR 0 3
102116: PUSH
102117: DOUBLE
102118: LD_INT 1
102120: DEC
102121: ST_TO_ADDR
102122: LD_INT 4
102124: PUSH
102125: FOR_TO
102126: IFFALSE 102147
// SetSkill ( i , j , 10 ) ;
102128: LD_VAR 0 2
102132: PPUSH
102133: LD_VAR 0 3
102137: PPUSH
102138: LD_INT 10
102140: PPUSH
102141: CALL_OW 237
102145: GO 102125
102147: POP
102148: POP
// end ;
102149: GO 102098
102151: POP
102152: POP
// end ;
102153: LD_VAR 0 1
102157: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
102158: LD_INT 0
102160: PPUSH
102161: PPUSH
102162: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
102163: LD_ADDR_VAR 0 2
102167: PUSH
102168: LD_INT 22
102170: PUSH
102171: LD_OWVAR 2
102175: PUSH
102176: EMPTY
102177: LIST
102178: LIST
102179: PUSH
102180: LD_INT 21
102182: PUSH
102183: LD_INT 1
102185: PUSH
102186: EMPTY
102187: LIST
102188: LIST
102189: PUSH
102190: EMPTY
102191: LIST
102192: LIST
102193: PPUSH
102194: CALL_OW 69
102198: PUSH
102199: FOR_IN
102200: IFFALSE 102241
// begin for j := 1 to 4 do
102202: LD_ADDR_VAR 0 3
102206: PUSH
102207: DOUBLE
102208: LD_INT 1
102210: DEC
102211: ST_TO_ADDR
102212: LD_INT 4
102214: PUSH
102215: FOR_TO
102216: IFFALSE 102237
// SetSkill ( i , j , 10 ) ;
102218: LD_VAR 0 2
102222: PPUSH
102223: LD_VAR 0 3
102227: PPUSH
102228: LD_INT 10
102230: PPUSH
102231: CALL_OW 237
102235: GO 102215
102237: POP
102238: POP
// end ;
102239: GO 102199
102241: POP
102242: POP
// end ;
102243: LD_VAR 0 1
102247: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
102248: LD_INT 0
102250: PPUSH
// uc_side := your_side ;
102251: LD_ADDR_OWVAR 20
102255: PUSH
102256: LD_OWVAR 2
102260: ST_TO_ADDR
// uc_nation := nation ;
102261: LD_ADDR_OWVAR 21
102265: PUSH
102266: LD_VAR 0 1
102270: ST_TO_ADDR
// InitHc ;
102271: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
102275: LD_INT 0
102277: PPUSH
102278: LD_VAR 0 2
102282: PPUSH
102283: LD_VAR 0 3
102287: PPUSH
102288: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
102292: LD_VAR 0 4
102296: PPUSH
102297: LD_VAR 0 5
102301: PPUSH
102302: CALL_OW 428
102306: PUSH
102307: LD_INT 0
102309: EQUAL
102310: IFFALSE 102334
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
102312: CALL_OW 44
102316: PPUSH
102317: LD_VAR 0 4
102321: PPUSH
102322: LD_VAR 0 5
102326: PPUSH
102327: LD_INT 1
102329: PPUSH
102330: CALL_OW 48
// end ;
102334: LD_VAR 0 6
102338: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
102339: LD_INT 0
102341: PPUSH
102342: PPUSH
// uc_side := your_side ;
102343: LD_ADDR_OWVAR 20
102347: PUSH
102348: LD_OWVAR 2
102352: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
102353: LD_VAR 0 1
102357: PUSH
102358: LD_INT 1
102360: PUSH
102361: LD_INT 2
102363: PUSH
102364: LD_INT 3
102366: PUSH
102367: LD_INT 4
102369: PUSH
102370: LD_INT 5
102372: PUSH
102373: EMPTY
102374: LIST
102375: LIST
102376: LIST
102377: LIST
102378: LIST
102379: IN
102380: IFFALSE 102392
// uc_nation := nation_american else
102382: LD_ADDR_OWVAR 21
102386: PUSH
102387: LD_INT 1
102389: ST_TO_ADDR
102390: GO 102435
// if chassis in [ 11 , 12 , 13 , 14 ] then
102392: LD_VAR 0 1
102396: PUSH
102397: LD_INT 11
102399: PUSH
102400: LD_INT 12
102402: PUSH
102403: LD_INT 13
102405: PUSH
102406: LD_INT 14
102408: PUSH
102409: EMPTY
102410: LIST
102411: LIST
102412: LIST
102413: LIST
102414: IN
102415: IFFALSE 102427
// uc_nation := nation_arabian else
102417: LD_ADDR_OWVAR 21
102421: PUSH
102422: LD_INT 2
102424: ST_TO_ADDR
102425: GO 102435
// uc_nation := nation_russian ;
102427: LD_ADDR_OWVAR 21
102431: PUSH
102432: LD_INT 3
102434: ST_TO_ADDR
// vc_chassis := chassis ;
102435: LD_ADDR_OWVAR 37
102439: PUSH
102440: LD_VAR 0 1
102444: ST_TO_ADDR
// vc_engine := engine ;
102445: LD_ADDR_OWVAR 39
102449: PUSH
102450: LD_VAR 0 2
102454: ST_TO_ADDR
// vc_control := control ;
102455: LD_ADDR_OWVAR 38
102459: PUSH
102460: LD_VAR 0 3
102464: ST_TO_ADDR
// vc_weapon := weapon ;
102465: LD_ADDR_OWVAR 40
102469: PUSH
102470: LD_VAR 0 4
102474: ST_TO_ADDR
// un := CreateVehicle ;
102475: LD_ADDR_VAR 0 8
102479: PUSH
102480: CALL_OW 45
102484: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
102485: LD_VAR 0 8
102489: PPUSH
102490: LD_INT 0
102492: PPUSH
102493: LD_INT 5
102495: PPUSH
102496: CALL_OW 12
102500: PPUSH
102501: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
102505: LD_VAR 0 8
102509: PPUSH
102510: LD_VAR 0 5
102514: PPUSH
102515: LD_VAR 0 6
102519: PPUSH
102520: LD_INT 1
102522: PPUSH
102523: CALL_OW 48
// end ;
102527: LD_VAR 0 7
102531: RET
// export hInvincible ; every 1 do
102532: GO 102534
102534: DISABLE
// hInvincible := [ ] ;
102535: LD_ADDR_EXP 191
102539: PUSH
102540: EMPTY
102541: ST_TO_ADDR
102542: END
// every 10 do var i ;
102543: GO 102545
102545: DISABLE
102546: LD_INT 0
102548: PPUSH
// begin enable ;
102549: ENABLE
// if not hInvincible then
102550: LD_EXP 191
102554: NOT
102555: IFFALSE 102559
// exit ;
102557: GO 102603
// for i in hInvincible do
102559: LD_ADDR_VAR 0 1
102563: PUSH
102564: LD_EXP 191
102568: PUSH
102569: FOR_IN
102570: IFFALSE 102601
// if GetLives ( i ) < 1000 then
102572: LD_VAR 0 1
102576: PPUSH
102577: CALL_OW 256
102581: PUSH
102582: LD_INT 1000
102584: LESS
102585: IFFALSE 102599
// SetLives ( i , 1000 ) ;
102587: LD_VAR 0 1
102591: PPUSH
102592: LD_INT 1000
102594: PPUSH
102595: CALL_OW 234
102599: GO 102569
102601: POP
102602: POP
// end ;
102603: PPOPN 1
102605: END
// export function hHackInvincible ; var i ; begin
102606: LD_INT 0
102608: PPUSH
102609: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
102610: LD_ADDR_VAR 0 2
102614: PUSH
102615: LD_INT 2
102617: PUSH
102618: LD_INT 21
102620: PUSH
102621: LD_INT 1
102623: PUSH
102624: EMPTY
102625: LIST
102626: LIST
102627: PUSH
102628: LD_INT 21
102630: PUSH
102631: LD_INT 2
102633: PUSH
102634: EMPTY
102635: LIST
102636: LIST
102637: PUSH
102638: EMPTY
102639: LIST
102640: LIST
102641: LIST
102642: PPUSH
102643: CALL_OW 69
102647: PUSH
102648: FOR_IN
102649: IFFALSE 102710
// if IsSelected ( i ) then
102651: LD_VAR 0 2
102655: PPUSH
102656: CALL_OW 306
102660: IFFALSE 102708
// begin if i in hInvincible then
102662: LD_VAR 0 2
102666: PUSH
102667: LD_EXP 191
102671: IN
102672: IFFALSE 102692
// hInvincible := hInvincible diff i else
102674: LD_ADDR_EXP 191
102678: PUSH
102679: LD_EXP 191
102683: PUSH
102684: LD_VAR 0 2
102688: DIFF
102689: ST_TO_ADDR
102690: GO 102708
// hInvincible := hInvincible union i ;
102692: LD_ADDR_EXP 191
102696: PUSH
102697: LD_EXP 191
102701: PUSH
102702: LD_VAR 0 2
102706: UNION
102707: ST_TO_ADDR
// end ;
102708: GO 102648
102710: POP
102711: POP
// end ;
102712: LD_VAR 0 1
102716: RET
// export function hHackInvisible ; var i , j ; begin
102717: LD_INT 0
102719: PPUSH
102720: PPUSH
102721: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
102722: LD_ADDR_VAR 0 2
102726: PUSH
102727: LD_INT 21
102729: PUSH
102730: LD_INT 1
102732: PUSH
102733: EMPTY
102734: LIST
102735: LIST
102736: PPUSH
102737: CALL_OW 69
102741: PUSH
102742: FOR_IN
102743: IFFALSE 102767
// if IsSelected ( i ) then
102745: LD_VAR 0 2
102749: PPUSH
102750: CALL_OW 306
102754: IFFALSE 102765
// ComForceInvisible ( i ) ;
102756: LD_VAR 0 2
102760: PPUSH
102761: CALL_OW 496
102765: GO 102742
102767: POP
102768: POP
// end ;
102769: LD_VAR 0 1
102773: RET
// export function hHackChangeYourSide ; begin
102774: LD_INT 0
102776: PPUSH
// if your_side = 8 then
102777: LD_OWVAR 2
102781: PUSH
102782: LD_INT 8
102784: EQUAL
102785: IFFALSE 102797
// your_side := 0 else
102787: LD_ADDR_OWVAR 2
102791: PUSH
102792: LD_INT 0
102794: ST_TO_ADDR
102795: GO 102811
// your_side := your_side + 1 ;
102797: LD_ADDR_OWVAR 2
102801: PUSH
102802: LD_OWVAR 2
102806: PUSH
102807: LD_INT 1
102809: PLUS
102810: ST_TO_ADDR
// end ;
102811: LD_VAR 0 1
102815: RET
// export function hHackChangeUnitSide ; var i , j ; begin
102816: LD_INT 0
102818: PPUSH
102819: PPUSH
102820: PPUSH
// for i in all_units do
102821: LD_ADDR_VAR 0 2
102825: PUSH
102826: LD_OWVAR 3
102830: PUSH
102831: FOR_IN
102832: IFFALSE 102910
// if IsSelected ( i ) then
102834: LD_VAR 0 2
102838: PPUSH
102839: CALL_OW 306
102843: IFFALSE 102908
// begin j := GetSide ( i ) ;
102845: LD_ADDR_VAR 0 3
102849: PUSH
102850: LD_VAR 0 2
102854: PPUSH
102855: CALL_OW 255
102859: ST_TO_ADDR
// if j = 8 then
102860: LD_VAR 0 3
102864: PUSH
102865: LD_INT 8
102867: EQUAL
102868: IFFALSE 102880
// j := 0 else
102870: LD_ADDR_VAR 0 3
102874: PUSH
102875: LD_INT 0
102877: ST_TO_ADDR
102878: GO 102894
// j := j + 1 ;
102880: LD_ADDR_VAR 0 3
102884: PUSH
102885: LD_VAR 0 3
102889: PUSH
102890: LD_INT 1
102892: PLUS
102893: ST_TO_ADDR
// SetSide ( i , j ) ;
102894: LD_VAR 0 2
102898: PPUSH
102899: LD_VAR 0 3
102903: PPUSH
102904: CALL_OW 235
// end ;
102908: GO 102831
102910: POP
102911: POP
// end ;
102912: LD_VAR 0 1
102916: RET
// export function hHackFog ; begin
102917: LD_INT 0
102919: PPUSH
// FogOff ( true ) ;
102920: LD_INT 1
102922: PPUSH
102923: CALL_OW 344
// end ;
102927: LD_VAR 0 1
102931: RET
// export function hHackTeleport ( unit , x , y ) ; begin
102932: LD_INT 0
102934: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
102935: LD_VAR 0 1
102939: PPUSH
102940: LD_VAR 0 2
102944: PPUSH
102945: LD_VAR 0 3
102949: PPUSH
102950: LD_INT 1
102952: PPUSH
102953: LD_INT 1
102955: PPUSH
102956: CALL_OW 483
// CenterOnXY ( x , y ) ;
102960: LD_VAR 0 2
102964: PPUSH
102965: LD_VAR 0 3
102969: PPUSH
102970: CALL_OW 84
// end ; end_of_file
102974: LD_VAR 0 4
102978: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
102979: LD_INT 0
102981: PPUSH
102982: PPUSH
102983: PPUSH
102984: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
102985: LD_VAR 0 1
102989: PPUSH
102990: CALL_OW 264
102994: PUSH
102995: LD_EXP 76
102999: EQUAL
103000: IFFALSE 103072
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
103002: LD_INT 68
103004: PPUSH
103005: LD_VAR 0 1
103009: PPUSH
103010: CALL_OW 255
103014: PPUSH
103015: CALL_OW 321
103019: PUSH
103020: LD_INT 2
103022: EQUAL
103023: IFFALSE 103035
// eff := 70 else
103025: LD_ADDR_VAR 0 4
103029: PUSH
103030: LD_INT 70
103032: ST_TO_ADDR
103033: GO 103043
// eff := 30 ;
103035: LD_ADDR_VAR 0 4
103039: PUSH
103040: LD_INT 30
103042: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
103043: LD_VAR 0 1
103047: PPUSH
103048: CALL_OW 250
103052: PPUSH
103053: LD_VAR 0 1
103057: PPUSH
103058: CALL_OW 251
103062: PPUSH
103063: LD_VAR 0 4
103067: PPUSH
103068: CALL_OW 495
// end ; end ;
103072: LD_VAR 0 2
103076: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
103077: LD_INT 0
103079: PPUSH
// end ;
103080: LD_VAR 0 4
103084: RET
// export function SOS_Command ( cmd ) ; begin
103085: LD_INT 0
103087: PPUSH
// end ;
103088: LD_VAR 0 2
103092: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
103093: LD_INT 0
103095: PPUSH
// if cmd = 121 then
103096: LD_VAR 0 1
103100: PUSH
103101: LD_INT 121
103103: EQUAL
103104: IFFALSE 103106
// end ;
103106: LD_VAR 0 6
103110: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
103111: LD_INT 0
103113: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
103114: LD_VAR 0 1
103118: PUSH
103119: LD_INT 250
103121: EQUAL
103122: PUSH
103123: LD_VAR 0 2
103127: PPUSH
103128: CALL_OW 264
103132: PUSH
103133: LD_EXP 79
103137: EQUAL
103138: AND
103139: IFFALSE 103160
// MinerPlaceMine ( unit , x , y ) ;
103141: LD_VAR 0 2
103145: PPUSH
103146: LD_VAR 0 4
103150: PPUSH
103151: LD_VAR 0 5
103155: PPUSH
103156: CALL 105509 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
103160: LD_VAR 0 1
103164: PUSH
103165: LD_INT 251
103167: EQUAL
103168: PUSH
103169: LD_VAR 0 2
103173: PPUSH
103174: CALL_OW 264
103178: PUSH
103179: LD_EXP 79
103183: EQUAL
103184: AND
103185: IFFALSE 103206
// MinerDetonateMine ( unit , x , y ) ;
103187: LD_VAR 0 2
103191: PPUSH
103192: LD_VAR 0 4
103196: PPUSH
103197: LD_VAR 0 5
103201: PPUSH
103202: CALL 105786 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
103206: LD_VAR 0 1
103210: PUSH
103211: LD_INT 252
103213: EQUAL
103214: PUSH
103215: LD_VAR 0 2
103219: PPUSH
103220: CALL_OW 264
103224: PUSH
103225: LD_EXP 79
103229: EQUAL
103230: AND
103231: IFFALSE 103252
// MinerCreateMinefield ( unit , x , y ) ;
103233: LD_VAR 0 2
103237: PPUSH
103238: LD_VAR 0 4
103242: PPUSH
103243: LD_VAR 0 5
103247: PPUSH
103248: CALL 106203 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
103252: LD_VAR 0 1
103256: PUSH
103257: LD_INT 253
103259: EQUAL
103260: PUSH
103261: LD_VAR 0 2
103265: PPUSH
103266: CALL_OW 257
103270: PUSH
103271: LD_INT 5
103273: EQUAL
103274: AND
103275: IFFALSE 103296
// ComBinocular ( unit , x , y ) ;
103277: LD_VAR 0 2
103281: PPUSH
103282: LD_VAR 0 4
103286: PPUSH
103287: LD_VAR 0 5
103291: PPUSH
103292: CALL 106574 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
103296: LD_VAR 0 1
103300: PUSH
103301: LD_INT 254
103303: EQUAL
103304: PUSH
103305: LD_VAR 0 2
103309: PPUSH
103310: CALL_OW 264
103314: PUSH
103315: LD_EXP 74
103319: EQUAL
103320: AND
103321: PUSH
103322: LD_VAR 0 3
103326: PPUSH
103327: CALL_OW 263
103331: PUSH
103332: LD_INT 3
103334: EQUAL
103335: AND
103336: IFFALSE 103352
// HackDestroyVehicle ( unit , selectedUnit ) ;
103338: LD_VAR 0 2
103342: PPUSH
103343: LD_VAR 0 3
103347: PPUSH
103348: CALL 104869 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
103352: LD_VAR 0 1
103356: PUSH
103357: LD_INT 255
103359: EQUAL
103360: PUSH
103361: LD_VAR 0 2
103365: PPUSH
103366: CALL_OW 264
103370: PUSH
103371: LD_INT 14
103373: PUSH
103374: LD_INT 53
103376: PUSH
103377: EMPTY
103378: LIST
103379: LIST
103380: IN
103381: AND
103382: PUSH
103383: LD_VAR 0 4
103387: PPUSH
103388: LD_VAR 0 5
103392: PPUSH
103393: CALL_OW 488
103397: AND
103398: IFFALSE 103422
// CutTreeXYR ( unit , x , y , 12 ) ;
103400: LD_VAR 0 2
103404: PPUSH
103405: LD_VAR 0 4
103409: PPUSH
103410: LD_VAR 0 5
103414: PPUSH
103415: LD_INT 12
103417: PPUSH
103418: CALL 103435 0 4
// end ;
103422: LD_VAR 0 6
103426: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
103427: LD_INT 0
103429: PPUSH
// end ;
103430: LD_VAR 0 4
103434: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
103435: LD_INT 0
103437: PPUSH
103438: PPUSH
103439: PPUSH
103440: PPUSH
103441: PPUSH
103442: PPUSH
103443: PPUSH
103444: PPUSH
103445: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
103446: LD_VAR 0 1
103450: NOT
103451: PUSH
103452: LD_VAR 0 2
103456: PPUSH
103457: LD_VAR 0 3
103461: PPUSH
103462: CALL_OW 488
103466: NOT
103467: OR
103468: PUSH
103469: LD_VAR 0 4
103473: NOT
103474: OR
103475: IFFALSE 103479
// exit ;
103477: GO 103819
// list := [ ] ;
103479: LD_ADDR_VAR 0 13
103483: PUSH
103484: EMPTY
103485: ST_TO_ADDR
// if x - r < 0 then
103486: LD_VAR 0 2
103490: PUSH
103491: LD_VAR 0 4
103495: MINUS
103496: PUSH
103497: LD_INT 0
103499: LESS
103500: IFFALSE 103512
// min_x := 0 else
103502: LD_ADDR_VAR 0 7
103506: PUSH
103507: LD_INT 0
103509: ST_TO_ADDR
103510: GO 103528
// min_x := x - r ;
103512: LD_ADDR_VAR 0 7
103516: PUSH
103517: LD_VAR 0 2
103521: PUSH
103522: LD_VAR 0 4
103526: MINUS
103527: ST_TO_ADDR
// if y - r < 0 then
103528: LD_VAR 0 3
103532: PUSH
103533: LD_VAR 0 4
103537: MINUS
103538: PUSH
103539: LD_INT 0
103541: LESS
103542: IFFALSE 103554
// min_y := 0 else
103544: LD_ADDR_VAR 0 8
103548: PUSH
103549: LD_INT 0
103551: ST_TO_ADDR
103552: GO 103570
// min_y := y - r ;
103554: LD_ADDR_VAR 0 8
103558: PUSH
103559: LD_VAR 0 3
103563: PUSH
103564: LD_VAR 0 4
103568: MINUS
103569: ST_TO_ADDR
// max_x := x + r ;
103570: LD_ADDR_VAR 0 9
103574: PUSH
103575: LD_VAR 0 2
103579: PUSH
103580: LD_VAR 0 4
103584: PLUS
103585: ST_TO_ADDR
// max_y := y + r ;
103586: LD_ADDR_VAR 0 10
103590: PUSH
103591: LD_VAR 0 3
103595: PUSH
103596: LD_VAR 0 4
103600: PLUS
103601: ST_TO_ADDR
// for _x = min_x to max_x do
103602: LD_ADDR_VAR 0 11
103606: PUSH
103607: DOUBLE
103608: LD_VAR 0 7
103612: DEC
103613: ST_TO_ADDR
103614: LD_VAR 0 9
103618: PUSH
103619: FOR_TO
103620: IFFALSE 103737
// for _y = min_y to max_y do
103622: LD_ADDR_VAR 0 12
103626: PUSH
103627: DOUBLE
103628: LD_VAR 0 8
103632: DEC
103633: ST_TO_ADDR
103634: LD_VAR 0 10
103638: PUSH
103639: FOR_TO
103640: IFFALSE 103733
// begin if not ValidHex ( _x , _y ) then
103642: LD_VAR 0 11
103646: PPUSH
103647: LD_VAR 0 12
103651: PPUSH
103652: CALL_OW 488
103656: NOT
103657: IFFALSE 103661
// continue ;
103659: GO 103639
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
103661: LD_VAR 0 11
103665: PPUSH
103666: LD_VAR 0 12
103670: PPUSH
103671: CALL_OW 351
103675: PUSH
103676: LD_VAR 0 11
103680: PPUSH
103681: LD_VAR 0 12
103685: PPUSH
103686: CALL_OW 554
103690: AND
103691: IFFALSE 103731
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
103693: LD_ADDR_VAR 0 13
103697: PUSH
103698: LD_VAR 0 13
103702: PPUSH
103703: LD_VAR 0 13
103707: PUSH
103708: LD_INT 1
103710: PLUS
103711: PPUSH
103712: LD_VAR 0 11
103716: PUSH
103717: LD_VAR 0 12
103721: PUSH
103722: EMPTY
103723: LIST
103724: LIST
103725: PPUSH
103726: CALL_OW 2
103730: ST_TO_ADDR
// end ;
103731: GO 103639
103733: POP
103734: POP
103735: GO 103619
103737: POP
103738: POP
// if not list then
103739: LD_VAR 0 13
103743: NOT
103744: IFFALSE 103748
// exit ;
103746: GO 103819
// for i in list do
103748: LD_ADDR_VAR 0 6
103752: PUSH
103753: LD_VAR 0 13
103757: PUSH
103758: FOR_IN
103759: IFFALSE 103817
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
103761: LD_VAR 0 1
103765: PPUSH
103766: LD_STRING M
103768: PUSH
103769: LD_VAR 0 6
103773: PUSH
103774: LD_INT 1
103776: ARRAY
103777: PUSH
103778: LD_VAR 0 6
103782: PUSH
103783: LD_INT 2
103785: ARRAY
103786: PUSH
103787: LD_INT 0
103789: PUSH
103790: LD_INT 0
103792: PUSH
103793: LD_INT 0
103795: PUSH
103796: LD_INT 0
103798: PUSH
103799: EMPTY
103800: LIST
103801: LIST
103802: LIST
103803: LIST
103804: LIST
103805: LIST
103806: LIST
103807: PUSH
103808: EMPTY
103809: LIST
103810: PPUSH
103811: CALL_OW 447
103815: GO 103758
103817: POP
103818: POP
// end ;
103819: LD_VAR 0 5
103823: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
103824: LD_EXP 194
103828: NOT
103829: IFFALSE 103879
103831: GO 103833
103833: DISABLE
// begin initHack := true ;
103834: LD_ADDR_EXP 194
103838: PUSH
103839: LD_INT 1
103841: ST_TO_ADDR
// hackTanks := [ ] ;
103842: LD_ADDR_EXP 195
103846: PUSH
103847: EMPTY
103848: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
103849: LD_ADDR_EXP 196
103853: PUSH
103854: EMPTY
103855: ST_TO_ADDR
// hackLimit := 3 ;
103856: LD_ADDR_EXP 197
103860: PUSH
103861: LD_INT 3
103863: ST_TO_ADDR
// hackDist := 12 ;
103864: LD_ADDR_EXP 198
103868: PUSH
103869: LD_INT 12
103871: ST_TO_ADDR
// hackCounter := [ ] ;
103872: LD_ADDR_EXP 199
103876: PUSH
103877: EMPTY
103878: ST_TO_ADDR
// end ;
103879: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
103880: LD_EXP 194
103884: PUSH
103885: LD_INT 34
103887: PUSH
103888: LD_EXP 74
103892: PUSH
103893: EMPTY
103894: LIST
103895: LIST
103896: PPUSH
103897: CALL_OW 69
103901: AND
103902: IFFALSE 104157
103904: GO 103906
103906: DISABLE
103907: LD_INT 0
103909: PPUSH
103910: PPUSH
// begin enable ;
103911: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
103912: LD_ADDR_VAR 0 1
103916: PUSH
103917: LD_INT 34
103919: PUSH
103920: LD_EXP 74
103924: PUSH
103925: EMPTY
103926: LIST
103927: LIST
103928: PPUSH
103929: CALL_OW 69
103933: PUSH
103934: FOR_IN
103935: IFFALSE 104155
// begin if not i in hackTanks then
103937: LD_VAR 0 1
103941: PUSH
103942: LD_EXP 195
103946: IN
103947: NOT
103948: IFFALSE 104031
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
103950: LD_ADDR_EXP 195
103954: PUSH
103955: LD_EXP 195
103959: PPUSH
103960: LD_EXP 195
103964: PUSH
103965: LD_INT 1
103967: PLUS
103968: PPUSH
103969: LD_VAR 0 1
103973: PPUSH
103974: CALL_OW 1
103978: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
103979: LD_ADDR_EXP 196
103983: PUSH
103984: LD_EXP 196
103988: PPUSH
103989: LD_EXP 196
103993: PUSH
103994: LD_INT 1
103996: PLUS
103997: PPUSH
103998: EMPTY
103999: PPUSH
104000: CALL_OW 1
104004: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
104005: LD_ADDR_EXP 199
104009: PUSH
104010: LD_EXP 199
104014: PPUSH
104015: LD_EXP 199
104019: PUSH
104020: LD_INT 1
104022: PLUS
104023: PPUSH
104024: EMPTY
104025: PPUSH
104026: CALL_OW 1
104030: ST_TO_ADDR
// end ; if not IsOk ( i ) then
104031: LD_VAR 0 1
104035: PPUSH
104036: CALL_OW 302
104040: NOT
104041: IFFALSE 104054
// begin HackUnlinkAll ( i ) ;
104043: LD_VAR 0 1
104047: PPUSH
104048: CALL 104160 0 1
// continue ;
104052: GO 103934
// end ; HackCheckCapturedStatus ( i ) ;
104054: LD_VAR 0 1
104058: PPUSH
104059: CALL 104603 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
104063: LD_ADDR_VAR 0 2
104067: PUSH
104068: LD_INT 81
104070: PUSH
104071: LD_VAR 0 1
104075: PPUSH
104076: CALL_OW 255
104080: PUSH
104081: EMPTY
104082: LIST
104083: LIST
104084: PUSH
104085: LD_INT 33
104087: PUSH
104088: LD_INT 3
104090: PUSH
104091: EMPTY
104092: LIST
104093: LIST
104094: PUSH
104095: LD_INT 91
104097: PUSH
104098: LD_VAR 0 1
104102: PUSH
104103: LD_EXP 198
104107: PUSH
104108: EMPTY
104109: LIST
104110: LIST
104111: LIST
104112: PUSH
104113: LD_INT 50
104115: PUSH
104116: EMPTY
104117: LIST
104118: PUSH
104119: EMPTY
104120: LIST
104121: LIST
104122: LIST
104123: LIST
104124: PPUSH
104125: CALL_OW 69
104129: ST_TO_ADDR
// if not tmp then
104130: LD_VAR 0 2
104134: NOT
104135: IFFALSE 104139
// continue ;
104137: GO 103934
// HackLink ( i , tmp ) ;
104139: LD_VAR 0 1
104143: PPUSH
104144: LD_VAR 0 2
104148: PPUSH
104149: CALL 104296 0 2
// end ;
104153: GO 103934
104155: POP
104156: POP
// end ;
104157: PPOPN 2
104159: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
104160: LD_INT 0
104162: PPUSH
104163: PPUSH
104164: PPUSH
// if not hack in hackTanks then
104165: LD_VAR 0 1
104169: PUSH
104170: LD_EXP 195
104174: IN
104175: NOT
104176: IFFALSE 104180
// exit ;
104178: GO 104291
// index := GetElementIndex ( hackTanks , hack ) ;
104180: LD_ADDR_VAR 0 4
104184: PUSH
104185: LD_EXP 195
104189: PPUSH
104190: LD_VAR 0 1
104194: PPUSH
104195: CALL 55983 0 2
104199: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
104200: LD_EXP 196
104204: PUSH
104205: LD_VAR 0 4
104209: ARRAY
104210: IFFALSE 104291
// begin for i in hackTanksCaptured [ index ] do
104212: LD_ADDR_VAR 0 3
104216: PUSH
104217: LD_EXP 196
104221: PUSH
104222: LD_VAR 0 4
104226: ARRAY
104227: PUSH
104228: FOR_IN
104229: IFFALSE 104255
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
104231: LD_VAR 0 3
104235: PUSH
104236: LD_INT 1
104238: ARRAY
104239: PPUSH
104240: LD_VAR 0 3
104244: PUSH
104245: LD_INT 2
104247: ARRAY
104248: PPUSH
104249: CALL_OW 235
104253: GO 104228
104255: POP
104256: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
104257: LD_ADDR_EXP 196
104261: PUSH
104262: LD_EXP 196
104266: PPUSH
104267: LD_VAR 0 4
104271: PPUSH
104272: EMPTY
104273: PPUSH
104274: CALL_OW 1
104278: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
104279: LD_VAR 0 1
104283: PPUSH
104284: LD_INT 0
104286: PPUSH
104287: CALL_OW 505
// end ; end ;
104291: LD_VAR 0 2
104295: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
104296: LD_INT 0
104298: PPUSH
104299: PPUSH
104300: PPUSH
// if not hack in hackTanks or not vehicles then
104301: LD_VAR 0 1
104305: PUSH
104306: LD_EXP 195
104310: IN
104311: NOT
104312: PUSH
104313: LD_VAR 0 2
104317: NOT
104318: OR
104319: IFFALSE 104323
// exit ;
104321: GO 104598
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
104323: LD_ADDR_VAR 0 2
104327: PUSH
104328: LD_VAR 0 1
104332: PPUSH
104333: LD_VAR 0 2
104337: PPUSH
104338: LD_INT 1
104340: PPUSH
104341: LD_INT 1
104343: PPUSH
104344: CALL 56633 0 4
104348: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
104349: LD_ADDR_VAR 0 5
104353: PUSH
104354: LD_EXP 195
104358: PPUSH
104359: LD_VAR 0 1
104363: PPUSH
104364: CALL 55983 0 2
104368: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
104369: LD_EXP 196
104373: PUSH
104374: LD_VAR 0 5
104378: ARRAY
104379: PUSH
104380: LD_EXP 197
104384: LESS
104385: IFFALSE 104574
// begin for i := 1 to vehicles do
104387: LD_ADDR_VAR 0 4
104391: PUSH
104392: DOUBLE
104393: LD_INT 1
104395: DEC
104396: ST_TO_ADDR
104397: LD_VAR 0 2
104401: PUSH
104402: FOR_TO
104403: IFFALSE 104572
// begin if hackTanksCaptured [ index ] = hackLimit then
104405: LD_EXP 196
104409: PUSH
104410: LD_VAR 0 5
104414: ARRAY
104415: PUSH
104416: LD_EXP 197
104420: EQUAL
104421: IFFALSE 104425
// break ;
104423: GO 104572
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
104425: LD_ADDR_EXP 199
104429: PUSH
104430: LD_EXP 199
104434: PPUSH
104435: LD_VAR 0 5
104439: PPUSH
104440: LD_EXP 199
104444: PUSH
104445: LD_VAR 0 5
104449: ARRAY
104450: PUSH
104451: LD_INT 1
104453: PLUS
104454: PPUSH
104455: CALL_OW 1
104459: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
104460: LD_ADDR_EXP 196
104464: PUSH
104465: LD_EXP 196
104469: PPUSH
104470: LD_VAR 0 5
104474: PUSH
104475: LD_EXP 196
104479: PUSH
104480: LD_VAR 0 5
104484: ARRAY
104485: PUSH
104486: LD_INT 1
104488: PLUS
104489: PUSH
104490: EMPTY
104491: LIST
104492: LIST
104493: PPUSH
104494: LD_VAR 0 2
104498: PUSH
104499: LD_VAR 0 4
104503: ARRAY
104504: PUSH
104505: LD_VAR 0 2
104509: PUSH
104510: LD_VAR 0 4
104514: ARRAY
104515: PPUSH
104516: CALL_OW 255
104520: PUSH
104521: EMPTY
104522: LIST
104523: LIST
104524: PPUSH
104525: CALL 56198 0 3
104529: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
104530: LD_VAR 0 2
104534: PUSH
104535: LD_VAR 0 4
104539: ARRAY
104540: PPUSH
104541: LD_VAR 0 1
104545: PPUSH
104546: CALL_OW 255
104550: PPUSH
104551: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
104555: LD_VAR 0 2
104559: PUSH
104560: LD_VAR 0 4
104564: ARRAY
104565: PPUSH
104566: CALL_OW 141
// end ;
104570: GO 104402
104572: POP
104573: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
104574: LD_VAR 0 1
104578: PPUSH
104579: LD_EXP 196
104583: PUSH
104584: LD_VAR 0 5
104588: ARRAY
104589: PUSH
104590: LD_INT 0
104592: PLUS
104593: PPUSH
104594: CALL_OW 505
// end ;
104598: LD_VAR 0 3
104602: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
104603: LD_INT 0
104605: PPUSH
104606: PPUSH
104607: PPUSH
104608: PPUSH
// if not hack in hackTanks then
104609: LD_VAR 0 1
104613: PUSH
104614: LD_EXP 195
104618: IN
104619: NOT
104620: IFFALSE 104624
// exit ;
104622: GO 104864
// index := GetElementIndex ( hackTanks , hack ) ;
104624: LD_ADDR_VAR 0 4
104628: PUSH
104629: LD_EXP 195
104633: PPUSH
104634: LD_VAR 0 1
104638: PPUSH
104639: CALL 55983 0 2
104643: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
104644: LD_ADDR_VAR 0 3
104648: PUSH
104649: DOUBLE
104650: LD_EXP 196
104654: PUSH
104655: LD_VAR 0 4
104659: ARRAY
104660: INC
104661: ST_TO_ADDR
104662: LD_INT 1
104664: PUSH
104665: FOR_DOWNTO
104666: IFFALSE 104838
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
104668: LD_ADDR_VAR 0 5
104672: PUSH
104673: LD_EXP 196
104677: PUSH
104678: LD_VAR 0 4
104682: ARRAY
104683: PUSH
104684: LD_VAR 0 3
104688: ARRAY
104689: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
104690: LD_VAR 0 5
104694: PUSH
104695: LD_INT 1
104697: ARRAY
104698: PPUSH
104699: CALL_OW 302
104703: NOT
104704: PUSH
104705: LD_VAR 0 5
104709: PUSH
104710: LD_INT 1
104712: ARRAY
104713: PPUSH
104714: CALL_OW 255
104718: PUSH
104719: LD_VAR 0 1
104723: PPUSH
104724: CALL_OW 255
104728: NONEQUAL
104729: OR
104730: IFFALSE 104836
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
104732: LD_VAR 0 5
104736: PUSH
104737: LD_INT 1
104739: ARRAY
104740: PPUSH
104741: CALL_OW 305
104745: PUSH
104746: LD_VAR 0 5
104750: PUSH
104751: LD_INT 1
104753: ARRAY
104754: PPUSH
104755: CALL_OW 255
104759: PUSH
104760: LD_VAR 0 1
104764: PPUSH
104765: CALL_OW 255
104769: EQUAL
104770: AND
104771: IFFALSE 104795
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
104773: LD_VAR 0 5
104777: PUSH
104778: LD_INT 1
104780: ARRAY
104781: PPUSH
104782: LD_VAR 0 5
104786: PUSH
104787: LD_INT 2
104789: ARRAY
104790: PPUSH
104791: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
104795: LD_ADDR_EXP 196
104799: PUSH
104800: LD_EXP 196
104804: PPUSH
104805: LD_VAR 0 4
104809: PPUSH
104810: LD_EXP 196
104814: PUSH
104815: LD_VAR 0 4
104819: ARRAY
104820: PPUSH
104821: LD_VAR 0 3
104825: PPUSH
104826: CALL_OW 3
104830: PPUSH
104831: CALL_OW 1
104835: ST_TO_ADDR
// end ; end ;
104836: GO 104665
104838: POP
104839: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
104840: LD_VAR 0 1
104844: PPUSH
104845: LD_EXP 196
104849: PUSH
104850: LD_VAR 0 4
104854: ARRAY
104855: PUSH
104856: LD_INT 0
104858: PLUS
104859: PPUSH
104860: CALL_OW 505
// end ;
104864: LD_VAR 0 2
104868: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
104869: LD_INT 0
104871: PPUSH
104872: PPUSH
104873: PPUSH
104874: PPUSH
// if not hack in hackTanks then
104875: LD_VAR 0 1
104879: PUSH
104880: LD_EXP 195
104884: IN
104885: NOT
104886: IFFALSE 104890
// exit ;
104888: GO 104975
// index := GetElementIndex ( hackTanks , hack ) ;
104890: LD_ADDR_VAR 0 5
104894: PUSH
104895: LD_EXP 195
104899: PPUSH
104900: LD_VAR 0 1
104904: PPUSH
104905: CALL 55983 0 2
104909: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
104910: LD_ADDR_VAR 0 4
104914: PUSH
104915: DOUBLE
104916: LD_INT 1
104918: DEC
104919: ST_TO_ADDR
104920: LD_EXP 196
104924: PUSH
104925: LD_VAR 0 5
104929: ARRAY
104930: PUSH
104931: FOR_TO
104932: IFFALSE 104973
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
104934: LD_EXP 196
104938: PUSH
104939: LD_VAR 0 5
104943: ARRAY
104944: PUSH
104945: LD_VAR 0 4
104949: ARRAY
104950: PUSH
104951: LD_INT 1
104953: ARRAY
104954: PUSH
104955: LD_VAR 0 2
104959: EQUAL
104960: IFFALSE 104971
// KillUnit ( vehicle ) ;
104962: LD_VAR 0 2
104966: PPUSH
104967: CALL_OW 66
104971: GO 104931
104973: POP
104974: POP
// end ;
104975: LD_VAR 0 3
104979: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
104980: LD_EXP 200
104984: NOT
104985: IFFALSE 105020
104987: GO 104989
104989: DISABLE
// begin initMiner := true ;
104990: LD_ADDR_EXP 200
104994: PUSH
104995: LD_INT 1
104997: ST_TO_ADDR
// minersList := [ ] ;
104998: LD_ADDR_EXP 201
105002: PUSH
105003: EMPTY
105004: ST_TO_ADDR
// minerMinesList := [ ] ;
105005: LD_ADDR_EXP 202
105009: PUSH
105010: EMPTY
105011: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
105012: LD_ADDR_EXP 203
105016: PUSH
105017: LD_INT 5
105019: ST_TO_ADDR
// end ;
105020: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
105021: LD_EXP 200
105025: PUSH
105026: LD_INT 34
105028: PUSH
105029: LD_EXP 79
105033: PUSH
105034: EMPTY
105035: LIST
105036: LIST
105037: PPUSH
105038: CALL_OW 69
105042: AND
105043: IFFALSE 105506
105045: GO 105047
105047: DISABLE
105048: LD_INT 0
105050: PPUSH
105051: PPUSH
105052: PPUSH
105053: PPUSH
// begin enable ;
105054: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
105055: LD_ADDR_VAR 0 1
105059: PUSH
105060: LD_INT 34
105062: PUSH
105063: LD_EXP 79
105067: PUSH
105068: EMPTY
105069: LIST
105070: LIST
105071: PPUSH
105072: CALL_OW 69
105076: PUSH
105077: FOR_IN
105078: IFFALSE 105150
// begin if not i in minersList then
105080: LD_VAR 0 1
105084: PUSH
105085: LD_EXP 201
105089: IN
105090: NOT
105091: IFFALSE 105148
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
105093: LD_ADDR_EXP 201
105097: PUSH
105098: LD_EXP 201
105102: PPUSH
105103: LD_EXP 201
105107: PUSH
105108: LD_INT 1
105110: PLUS
105111: PPUSH
105112: LD_VAR 0 1
105116: PPUSH
105117: CALL_OW 1
105121: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
105122: LD_ADDR_EXP 202
105126: PUSH
105127: LD_EXP 202
105131: PPUSH
105132: LD_EXP 202
105136: PUSH
105137: LD_INT 1
105139: PLUS
105140: PPUSH
105141: EMPTY
105142: PPUSH
105143: CALL_OW 1
105147: ST_TO_ADDR
// end end ;
105148: GO 105077
105150: POP
105151: POP
// for i := minerMinesList downto 1 do
105152: LD_ADDR_VAR 0 1
105156: PUSH
105157: DOUBLE
105158: LD_EXP 202
105162: INC
105163: ST_TO_ADDR
105164: LD_INT 1
105166: PUSH
105167: FOR_DOWNTO
105168: IFFALSE 105504
// begin if IsLive ( minersList [ i ] ) then
105170: LD_EXP 201
105174: PUSH
105175: LD_VAR 0 1
105179: ARRAY
105180: PPUSH
105181: CALL_OW 300
105185: IFFALSE 105213
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
105187: LD_EXP 201
105191: PUSH
105192: LD_VAR 0 1
105196: ARRAY
105197: PPUSH
105198: LD_EXP 202
105202: PUSH
105203: LD_VAR 0 1
105207: ARRAY
105208: PPUSH
105209: CALL_OW 505
// if not minerMinesList [ i ] then
105213: LD_EXP 202
105217: PUSH
105218: LD_VAR 0 1
105222: ARRAY
105223: NOT
105224: IFFALSE 105228
// continue ;
105226: GO 105167
// for j := minerMinesList [ i ] downto 1 do
105228: LD_ADDR_VAR 0 2
105232: PUSH
105233: DOUBLE
105234: LD_EXP 202
105238: PUSH
105239: LD_VAR 0 1
105243: ARRAY
105244: INC
105245: ST_TO_ADDR
105246: LD_INT 1
105248: PUSH
105249: FOR_DOWNTO
105250: IFFALSE 105500
// begin side := GetSide ( minersList [ i ] ) ;
105252: LD_ADDR_VAR 0 3
105256: PUSH
105257: LD_EXP 201
105261: PUSH
105262: LD_VAR 0 1
105266: ARRAY
105267: PPUSH
105268: CALL_OW 255
105272: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
105273: LD_ADDR_VAR 0 4
105277: PUSH
105278: LD_EXP 202
105282: PUSH
105283: LD_VAR 0 1
105287: ARRAY
105288: PUSH
105289: LD_VAR 0 2
105293: ARRAY
105294: PUSH
105295: LD_INT 1
105297: ARRAY
105298: PPUSH
105299: LD_EXP 202
105303: PUSH
105304: LD_VAR 0 1
105308: ARRAY
105309: PUSH
105310: LD_VAR 0 2
105314: ARRAY
105315: PUSH
105316: LD_INT 2
105318: ARRAY
105319: PPUSH
105320: CALL_OW 428
105324: ST_TO_ADDR
// if not tmp then
105325: LD_VAR 0 4
105329: NOT
105330: IFFALSE 105334
// continue ;
105332: GO 105249
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
105334: LD_VAR 0 4
105338: PUSH
105339: LD_INT 81
105341: PUSH
105342: LD_VAR 0 3
105346: PUSH
105347: EMPTY
105348: LIST
105349: LIST
105350: PPUSH
105351: CALL_OW 69
105355: IN
105356: PUSH
105357: LD_EXP 202
105361: PUSH
105362: LD_VAR 0 1
105366: ARRAY
105367: PUSH
105368: LD_VAR 0 2
105372: ARRAY
105373: PUSH
105374: LD_INT 1
105376: ARRAY
105377: PPUSH
105378: LD_EXP 202
105382: PUSH
105383: LD_VAR 0 1
105387: ARRAY
105388: PUSH
105389: LD_VAR 0 2
105393: ARRAY
105394: PUSH
105395: LD_INT 2
105397: ARRAY
105398: PPUSH
105399: CALL_OW 458
105403: AND
105404: IFFALSE 105498
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
105406: LD_EXP 202
105410: PUSH
105411: LD_VAR 0 1
105415: ARRAY
105416: PUSH
105417: LD_VAR 0 2
105421: ARRAY
105422: PUSH
105423: LD_INT 1
105425: ARRAY
105426: PPUSH
105427: LD_EXP 202
105431: PUSH
105432: LD_VAR 0 1
105436: ARRAY
105437: PUSH
105438: LD_VAR 0 2
105442: ARRAY
105443: PUSH
105444: LD_INT 2
105446: ARRAY
105447: PPUSH
105448: LD_VAR 0 3
105452: PPUSH
105453: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
105457: LD_ADDR_EXP 202
105461: PUSH
105462: LD_EXP 202
105466: PPUSH
105467: LD_VAR 0 1
105471: PPUSH
105472: LD_EXP 202
105476: PUSH
105477: LD_VAR 0 1
105481: ARRAY
105482: PPUSH
105483: LD_VAR 0 2
105487: PPUSH
105488: CALL_OW 3
105492: PPUSH
105493: CALL_OW 1
105497: ST_TO_ADDR
// end ; end ;
105498: GO 105249
105500: POP
105501: POP
// end ;
105502: GO 105167
105504: POP
105505: POP
// end ;
105506: PPOPN 4
105508: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
105509: LD_INT 0
105511: PPUSH
105512: PPUSH
// result := false ;
105513: LD_ADDR_VAR 0 4
105517: PUSH
105518: LD_INT 0
105520: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
105521: LD_VAR 0 1
105525: PPUSH
105526: CALL_OW 264
105530: PUSH
105531: LD_EXP 79
105535: EQUAL
105536: NOT
105537: IFFALSE 105541
// exit ;
105539: GO 105781
// index := GetElementIndex ( minersList , unit ) ;
105541: LD_ADDR_VAR 0 5
105545: PUSH
105546: LD_EXP 201
105550: PPUSH
105551: LD_VAR 0 1
105555: PPUSH
105556: CALL 55983 0 2
105560: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
105561: LD_EXP 202
105565: PUSH
105566: LD_VAR 0 5
105570: ARRAY
105571: PUSH
105572: LD_EXP 203
105576: GREATEREQUAL
105577: IFFALSE 105581
// exit ;
105579: GO 105781
// ComMoveXY ( unit , x , y ) ;
105581: LD_VAR 0 1
105585: PPUSH
105586: LD_VAR 0 2
105590: PPUSH
105591: LD_VAR 0 3
105595: PPUSH
105596: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
105600: LD_INT 35
105602: PPUSH
105603: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
105607: LD_VAR 0 1
105611: PPUSH
105612: LD_VAR 0 2
105616: PPUSH
105617: LD_VAR 0 3
105621: PPUSH
105622: CALL 86756 0 3
105626: NOT
105627: PUSH
105628: LD_VAR 0 1
105632: PPUSH
105633: CALL_OW 314
105637: AND
105638: IFFALSE 105642
// exit ;
105640: GO 105781
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
105642: LD_VAR 0 2
105646: PPUSH
105647: LD_VAR 0 3
105651: PPUSH
105652: CALL_OW 428
105656: PUSH
105657: LD_VAR 0 1
105661: EQUAL
105662: PUSH
105663: LD_VAR 0 1
105667: PPUSH
105668: CALL_OW 314
105672: NOT
105673: AND
105674: IFFALSE 105600
// PlaySoundXY ( x , y , PlantMine ) ;
105676: LD_VAR 0 2
105680: PPUSH
105681: LD_VAR 0 3
105685: PPUSH
105686: LD_STRING PlantMine
105688: PPUSH
105689: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
105693: LD_VAR 0 2
105697: PPUSH
105698: LD_VAR 0 3
105702: PPUSH
105703: LD_VAR 0 1
105707: PPUSH
105708: CALL_OW 255
105712: PPUSH
105713: LD_INT 0
105715: PPUSH
105716: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
105720: LD_ADDR_EXP 202
105724: PUSH
105725: LD_EXP 202
105729: PPUSH
105730: LD_VAR 0 5
105734: PUSH
105735: LD_EXP 202
105739: PUSH
105740: LD_VAR 0 5
105744: ARRAY
105745: PUSH
105746: LD_INT 1
105748: PLUS
105749: PUSH
105750: EMPTY
105751: LIST
105752: LIST
105753: PPUSH
105754: LD_VAR 0 2
105758: PUSH
105759: LD_VAR 0 3
105763: PUSH
105764: EMPTY
105765: LIST
105766: LIST
105767: PPUSH
105768: CALL 56198 0 3
105772: ST_TO_ADDR
// result := true ;
105773: LD_ADDR_VAR 0 4
105777: PUSH
105778: LD_INT 1
105780: ST_TO_ADDR
// end ;
105781: LD_VAR 0 4
105785: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
105786: LD_INT 0
105788: PPUSH
105789: PPUSH
105790: PPUSH
// if not unit in minersList then
105791: LD_VAR 0 1
105795: PUSH
105796: LD_EXP 201
105800: IN
105801: NOT
105802: IFFALSE 105806
// exit ;
105804: GO 106198
// index := GetElementIndex ( minersList , unit ) ;
105806: LD_ADDR_VAR 0 6
105810: PUSH
105811: LD_EXP 201
105815: PPUSH
105816: LD_VAR 0 1
105820: PPUSH
105821: CALL 55983 0 2
105825: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
105826: LD_ADDR_VAR 0 5
105830: PUSH
105831: DOUBLE
105832: LD_EXP 202
105836: PUSH
105837: LD_VAR 0 6
105841: ARRAY
105842: INC
105843: ST_TO_ADDR
105844: LD_INT 1
105846: PUSH
105847: FOR_DOWNTO
105848: IFFALSE 106009
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
105850: LD_EXP 202
105854: PUSH
105855: LD_VAR 0 6
105859: ARRAY
105860: PUSH
105861: LD_VAR 0 5
105865: ARRAY
105866: PUSH
105867: LD_INT 1
105869: ARRAY
105870: PUSH
105871: LD_VAR 0 2
105875: EQUAL
105876: PUSH
105877: LD_EXP 202
105881: PUSH
105882: LD_VAR 0 6
105886: ARRAY
105887: PUSH
105888: LD_VAR 0 5
105892: ARRAY
105893: PUSH
105894: LD_INT 2
105896: ARRAY
105897: PUSH
105898: LD_VAR 0 3
105902: EQUAL
105903: AND
105904: IFFALSE 106007
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
105906: LD_EXP 202
105910: PUSH
105911: LD_VAR 0 6
105915: ARRAY
105916: PUSH
105917: LD_VAR 0 5
105921: ARRAY
105922: PUSH
105923: LD_INT 1
105925: ARRAY
105926: PPUSH
105927: LD_EXP 202
105931: PUSH
105932: LD_VAR 0 6
105936: ARRAY
105937: PUSH
105938: LD_VAR 0 5
105942: ARRAY
105943: PUSH
105944: LD_INT 2
105946: ARRAY
105947: PPUSH
105948: LD_VAR 0 1
105952: PPUSH
105953: CALL_OW 255
105957: PPUSH
105958: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
105962: LD_ADDR_EXP 202
105966: PUSH
105967: LD_EXP 202
105971: PPUSH
105972: LD_VAR 0 6
105976: PPUSH
105977: LD_EXP 202
105981: PUSH
105982: LD_VAR 0 6
105986: ARRAY
105987: PPUSH
105988: LD_VAR 0 5
105992: PPUSH
105993: CALL_OW 3
105997: PPUSH
105998: CALL_OW 1
106002: ST_TO_ADDR
// exit ;
106003: POP
106004: POP
106005: GO 106198
// end ; end ;
106007: GO 105847
106009: POP
106010: POP
// for i := minerMinesList [ index ] downto 1 do
106011: LD_ADDR_VAR 0 5
106015: PUSH
106016: DOUBLE
106017: LD_EXP 202
106021: PUSH
106022: LD_VAR 0 6
106026: ARRAY
106027: INC
106028: ST_TO_ADDR
106029: LD_INT 1
106031: PUSH
106032: FOR_DOWNTO
106033: IFFALSE 106196
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
106035: LD_EXP 202
106039: PUSH
106040: LD_VAR 0 6
106044: ARRAY
106045: PUSH
106046: LD_VAR 0 5
106050: ARRAY
106051: PUSH
106052: LD_INT 1
106054: ARRAY
106055: PPUSH
106056: LD_EXP 202
106060: PUSH
106061: LD_VAR 0 6
106065: ARRAY
106066: PUSH
106067: LD_VAR 0 5
106071: ARRAY
106072: PUSH
106073: LD_INT 2
106075: ARRAY
106076: PPUSH
106077: LD_VAR 0 2
106081: PPUSH
106082: LD_VAR 0 3
106086: PPUSH
106087: CALL_OW 298
106091: PUSH
106092: LD_INT 6
106094: LESS
106095: IFFALSE 106194
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
106097: LD_EXP 202
106101: PUSH
106102: LD_VAR 0 6
106106: ARRAY
106107: PUSH
106108: LD_VAR 0 5
106112: ARRAY
106113: PUSH
106114: LD_INT 1
106116: ARRAY
106117: PPUSH
106118: LD_EXP 202
106122: PUSH
106123: LD_VAR 0 6
106127: ARRAY
106128: PUSH
106129: LD_VAR 0 5
106133: ARRAY
106134: PUSH
106135: LD_INT 2
106137: ARRAY
106138: PPUSH
106139: LD_VAR 0 1
106143: PPUSH
106144: CALL_OW 255
106148: PPUSH
106149: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
106153: LD_ADDR_EXP 202
106157: PUSH
106158: LD_EXP 202
106162: PPUSH
106163: LD_VAR 0 6
106167: PPUSH
106168: LD_EXP 202
106172: PUSH
106173: LD_VAR 0 6
106177: ARRAY
106178: PPUSH
106179: LD_VAR 0 5
106183: PPUSH
106184: CALL_OW 3
106188: PPUSH
106189: CALL_OW 1
106193: ST_TO_ADDR
// end ; end ;
106194: GO 106032
106196: POP
106197: POP
// end ;
106198: LD_VAR 0 4
106202: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
106203: LD_INT 0
106205: PPUSH
106206: PPUSH
106207: PPUSH
106208: PPUSH
106209: PPUSH
106210: PPUSH
106211: PPUSH
106212: PPUSH
106213: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
106214: LD_VAR 0 1
106218: PPUSH
106219: CALL_OW 264
106223: PUSH
106224: LD_EXP 79
106228: EQUAL
106229: NOT
106230: PUSH
106231: LD_VAR 0 1
106235: PUSH
106236: LD_EXP 201
106240: IN
106241: NOT
106242: OR
106243: IFFALSE 106247
// exit ;
106245: GO 106569
// index := GetElementIndex ( minersList , unit ) ;
106247: LD_ADDR_VAR 0 6
106251: PUSH
106252: LD_EXP 201
106256: PPUSH
106257: LD_VAR 0 1
106261: PPUSH
106262: CALL 55983 0 2
106266: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
106267: LD_ADDR_VAR 0 8
106271: PUSH
106272: LD_EXP 203
106276: PUSH
106277: LD_EXP 202
106281: PUSH
106282: LD_VAR 0 6
106286: ARRAY
106287: MINUS
106288: ST_TO_ADDR
// if not minesFreeAmount then
106289: LD_VAR 0 8
106293: NOT
106294: IFFALSE 106298
// exit ;
106296: GO 106569
// tmp := [ ] ;
106298: LD_ADDR_VAR 0 7
106302: PUSH
106303: EMPTY
106304: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
106305: LD_ADDR_VAR 0 5
106309: PUSH
106310: DOUBLE
106311: LD_INT 1
106313: DEC
106314: ST_TO_ADDR
106315: LD_VAR 0 8
106319: PUSH
106320: FOR_TO
106321: IFFALSE 106516
// begin _d := rand ( 0 , 5 ) ;
106323: LD_ADDR_VAR 0 11
106327: PUSH
106328: LD_INT 0
106330: PPUSH
106331: LD_INT 5
106333: PPUSH
106334: CALL_OW 12
106338: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
106339: LD_ADDR_VAR 0 12
106343: PUSH
106344: LD_INT 2
106346: PPUSH
106347: LD_INT 6
106349: PPUSH
106350: CALL_OW 12
106354: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
106355: LD_ADDR_VAR 0 9
106359: PUSH
106360: LD_VAR 0 2
106364: PPUSH
106365: LD_VAR 0 11
106369: PPUSH
106370: LD_VAR 0 12
106374: PPUSH
106375: CALL_OW 272
106379: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
106380: LD_ADDR_VAR 0 10
106384: PUSH
106385: LD_VAR 0 3
106389: PPUSH
106390: LD_VAR 0 11
106394: PPUSH
106395: LD_VAR 0 12
106399: PPUSH
106400: CALL_OW 273
106404: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
106405: LD_VAR 0 9
106409: PPUSH
106410: LD_VAR 0 10
106414: PPUSH
106415: CALL_OW 488
106419: PUSH
106420: LD_VAR 0 9
106424: PUSH
106425: LD_VAR 0 10
106429: PUSH
106430: EMPTY
106431: LIST
106432: LIST
106433: PUSH
106434: LD_VAR 0 7
106438: IN
106439: NOT
106440: AND
106441: PUSH
106442: LD_VAR 0 9
106446: PPUSH
106447: LD_VAR 0 10
106451: PPUSH
106452: CALL_OW 458
106456: NOT
106457: AND
106458: IFFALSE 106500
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
106460: LD_ADDR_VAR 0 7
106464: PUSH
106465: LD_VAR 0 7
106469: PPUSH
106470: LD_VAR 0 7
106474: PUSH
106475: LD_INT 1
106477: PLUS
106478: PPUSH
106479: LD_VAR 0 9
106483: PUSH
106484: LD_VAR 0 10
106488: PUSH
106489: EMPTY
106490: LIST
106491: LIST
106492: PPUSH
106493: CALL_OW 1
106497: ST_TO_ADDR
106498: GO 106514
// i := i - 1 ;
106500: LD_ADDR_VAR 0 5
106504: PUSH
106505: LD_VAR 0 5
106509: PUSH
106510: LD_INT 1
106512: MINUS
106513: ST_TO_ADDR
// end ;
106514: GO 106320
106516: POP
106517: POP
// for i in tmp do
106518: LD_ADDR_VAR 0 5
106522: PUSH
106523: LD_VAR 0 7
106527: PUSH
106528: FOR_IN
106529: IFFALSE 106567
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
106531: LD_VAR 0 1
106535: PPUSH
106536: LD_VAR 0 5
106540: PUSH
106541: LD_INT 1
106543: ARRAY
106544: PPUSH
106545: LD_VAR 0 5
106549: PUSH
106550: LD_INT 2
106552: ARRAY
106553: PPUSH
106554: CALL 105509 0 3
106558: NOT
106559: IFFALSE 106565
// exit ;
106561: POP
106562: POP
106563: GO 106569
106565: GO 106528
106567: POP
106568: POP
// end ;
106569: LD_VAR 0 4
106573: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
106574: LD_INT 0
106576: PPUSH
106577: PPUSH
106578: PPUSH
106579: PPUSH
106580: PPUSH
106581: PPUSH
106582: PPUSH
// if not GetClass ( unit ) = class_sniper then
106583: LD_VAR 0 1
106587: PPUSH
106588: CALL_OW 257
106592: PUSH
106593: LD_INT 5
106595: EQUAL
106596: NOT
106597: IFFALSE 106601
// exit ;
106599: GO 106989
// dist := 8 ;
106601: LD_ADDR_VAR 0 5
106605: PUSH
106606: LD_INT 8
106608: ST_TO_ADDR
// viewRange := 12 ;
106609: LD_ADDR_VAR 0 7
106613: PUSH
106614: LD_INT 12
106616: ST_TO_ADDR
// side := GetSide ( unit ) ;
106617: LD_ADDR_VAR 0 6
106621: PUSH
106622: LD_VAR 0 1
106626: PPUSH
106627: CALL_OW 255
106631: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
106632: LD_INT 61
106634: PPUSH
106635: LD_VAR 0 6
106639: PPUSH
106640: CALL_OW 321
106644: PUSH
106645: LD_INT 2
106647: EQUAL
106648: IFFALSE 106658
// viewRange := 16 ;
106650: LD_ADDR_VAR 0 7
106654: PUSH
106655: LD_INT 16
106657: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
106658: LD_VAR 0 1
106662: PPUSH
106663: LD_VAR 0 2
106667: PPUSH
106668: LD_VAR 0 3
106672: PPUSH
106673: CALL_OW 297
106677: PUSH
106678: LD_VAR 0 5
106682: GREATER
106683: IFFALSE 106762
// begin ComMoveXY ( unit , x , y ) ;
106685: LD_VAR 0 1
106689: PPUSH
106690: LD_VAR 0 2
106694: PPUSH
106695: LD_VAR 0 3
106699: PPUSH
106700: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
106704: LD_INT 35
106706: PPUSH
106707: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
106711: LD_VAR 0 1
106715: PPUSH
106716: LD_VAR 0 2
106720: PPUSH
106721: LD_VAR 0 3
106725: PPUSH
106726: CALL 86756 0 3
106730: NOT
106731: IFFALSE 106735
// exit ;
106733: GO 106989
// until GetDistUnitXY ( unit , x , y ) < dist ;
106735: LD_VAR 0 1
106739: PPUSH
106740: LD_VAR 0 2
106744: PPUSH
106745: LD_VAR 0 3
106749: PPUSH
106750: CALL_OW 297
106754: PUSH
106755: LD_VAR 0 5
106759: LESS
106760: IFFALSE 106704
// end ; ComTurnXY ( unit , x , y ) ;
106762: LD_VAR 0 1
106766: PPUSH
106767: LD_VAR 0 2
106771: PPUSH
106772: LD_VAR 0 3
106776: PPUSH
106777: CALL_OW 118
// wait ( 5 ) ;
106781: LD_INT 5
106783: PPUSH
106784: CALL_OW 67
// _d := GetDir ( unit ) ;
106788: LD_ADDR_VAR 0 10
106792: PUSH
106793: LD_VAR 0 1
106797: PPUSH
106798: CALL_OW 254
106802: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
106803: LD_ADDR_VAR 0 8
106807: PUSH
106808: LD_VAR 0 1
106812: PPUSH
106813: CALL_OW 250
106817: PPUSH
106818: LD_VAR 0 10
106822: PPUSH
106823: LD_VAR 0 5
106827: PPUSH
106828: CALL_OW 272
106832: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
106833: LD_ADDR_VAR 0 9
106837: PUSH
106838: LD_VAR 0 1
106842: PPUSH
106843: CALL_OW 251
106847: PPUSH
106848: LD_VAR 0 10
106852: PPUSH
106853: LD_VAR 0 5
106857: PPUSH
106858: CALL_OW 273
106862: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
106863: LD_VAR 0 8
106867: PPUSH
106868: LD_VAR 0 9
106872: PPUSH
106873: CALL_OW 488
106877: NOT
106878: IFFALSE 106882
// exit ;
106880: GO 106989
// ComAnimCustom ( unit , 1 ) ;
106882: LD_VAR 0 1
106886: PPUSH
106887: LD_INT 1
106889: PPUSH
106890: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
106894: LD_VAR 0 8
106898: PPUSH
106899: LD_VAR 0 9
106903: PPUSH
106904: LD_VAR 0 6
106908: PPUSH
106909: LD_VAR 0 7
106913: PPUSH
106914: CALL_OW 330
// repeat wait ( 1 ) ;
106918: LD_INT 1
106920: PPUSH
106921: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
106925: LD_VAR 0 1
106929: PPUSH
106930: CALL_OW 316
106934: PUSH
106935: LD_VAR 0 1
106939: PPUSH
106940: CALL_OW 314
106944: OR
106945: PUSH
106946: LD_VAR 0 1
106950: PPUSH
106951: CALL_OW 302
106955: NOT
106956: OR
106957: PUSH
106958: LD_VAR 0 1
106962: PPUSH
106963: CALL_OW 301
106967: OR
106968: IFFALSE 106918
// RemoveSeeing ( _x , _y , side ) ;
106970: LD_VAR 0 8
106974: PPUSH
106975: LD_VAR 0 9
106979: PPUSH
106980: LD_VAR 0 6
106984: PPUSH
106985: CALL_OW 331
// end ; end_of_file
106989: LD_VAR 0 4
106993: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
106994: LD_INT 0
106996: PPUSH
106997: PPUSH
106998: PPUSH
106999: PPUSH
107000: PPUSH
107001: PPUSH
107002: PPUSH
107003: PPUSH
107004: PPUSH
107005: PPUSH
107006: PPUSH
107007: PPUSH
107008: PPUSH
107009: PPUSH
107010: PPUSH
107011: PPUSH
107012: PPUSH
107013: PPUSH
107014: PPUSH
107015: PPUSH
107016: PPUSH
107017: PPUSH
107018: PPUSH
107019: PPUSH
107020: PPUSH
107021: PPUSH
107022: PPUSH
107023: PPUSH
107024: PPUSH
107025: PPUSH
107026: PPUSH
107027: PPUSH
107028: PPUSH
107029: PPUSH
// if not list then
107030: LD_VAR 0 1
107034: NOT
107035: IFFALSE 107039
// exit ;
107037: GO 111698
// base := list [ 1 ] ;
107039: LD_ADDR_VAR 0 3
107043: PUSH
107044: LD_VAR 0 1
107048: PUSH
107049: LD_INT 1
107051: ARRAY
107052: ST_TO_ADDR
// group := list [ 2 ] ;
107053: LD_ADDR_VAR 0 4
107057: PUSH
107058: LD_VAR 0 1
107062: PUSH
107063: LD_INT 2
107065: ARRAY
107066: ST_TO_ADDR
// path := list [ 3 ] ;
107067: LD_ADDR_VAR 0 5
107071: PUSH
107072: LD_VAR 0 1
107076: PUSH
107077: LD_INT 3
107079: ARRAY
107080: ST_TO_ADDR
// flags := list [ 4 ] ;
107081: LD_ADDR_VAR 0 6
107085: PUSH
107086: LD_VAR 0 1
107090: PUSH
107091: LD_INT 4
107093: ARRAY
107094: ST_TO_ADDR
// mined := [ ] ;
107095: LD_ADDR_VAR 0 27
107099: PUSH
107100: EMPTY
107101: ST_TO_ADDR
// bombed := [ ] ;
107102: LD_ADDR_VAR 0 28
107106: PUSH
107107: EMPTY
107108: ST_TO_ADDR
// healers := [ ] ;
107109: LD_ADDR_VAR 0 31
107113: PUSH
107114: EMPTY
107115: ST_TO_ADDR
// to_heal := [ ] ;
107116: LD_ADDR_VAR 0 30
107120: PUSH
107121: EMPTY
107122: ST_TO_ADDR
// repairs := [ ] ;
107123: LD_ADDR_VAR 0 33
107127: PUSH
107128: EMPTY
107129: ST_TO_ADDR
// to_repair := [ ] ;
107130: LD_ADDR_VAR 0 32
107134: PUSH
107135: EMPTY
107136: ST_TO_ADDR
// if not group or not path then
107137: LD_VAR 0 4
107141: NOT
107142: PUSH
107143: LD_VAR 0 5
107147: NOT
107148: OR
107149: IFFALSE 107153
// exit ;
107151: GO 111698
// side := GetSide ( group [ 1 ] ) ;
107153: LD_ADDR_VAR 0 35
107157: PUSH
107158: LD_VAR 0 4
107162: PUSH
107163: LD_INT 1
107165: ARRAY
107166: PPUSH
107167: CALL_OW 255
107171: ST_TO_ADDR
// if flags then
107172: LD_VAR 0 6
107176: IFFALSE 107320
// begin f_ignore_area := flags [ 1 ] ;
107178: LD_ADDR_VAR 0 17
107182: PUSH
107183: LD_VAR 0 6
107187: PUSH
107188: LD_INT 1
107190: ARRAY
107191: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
107192: LD_ADDR_VAR 0 18
107196: PUSH
107197: LD_VAR 0 6
107201: PUSH
107202: LD_INT 2
107204: ARRAY
107205: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
107206: LD_ADDR_VAR 0 19
107210: PUSH
107211: LD_VAR 0 6
107215: PUSH
107216: LD_INT 3
107218: ARRAY
107219: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
107220: LD_ADDR_VAR 0 20
107224: PUSH
107225: LD_VAR 0 6
107229: PUSH
107230: LD_INT 4
107232: ARRAY
107233: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
107234: LD_ADDR_VAR 0 21
107238: PUSH
107239: LD_VAR 0 6
107243: PUSH
107244: LD_INT 5
107246: ARRAY
107247: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
107248: LD_ADDR_VAR 0 22
107252: PUSH
107253: LD_VAR 0 6
107257: PUSH
107258: LD_INT 6
107260: ARRAY
107261: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
107262: LD_ADDR_VAR 0 23
107266: PUSH
107267: LD_VAR 0 6
107271: PUSH
107272: LD_INT 7
107274: ARRAY
107275: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
107276: LD_ADDR_VAR 0 24
107280: PUSH
107281: LD_VAR 0 6
107285: PUSH
107286: LD_INT 8
107288: ARRAY
107289: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
107290: LD_ADDR_VAR 0 25
107294: PUSH
107295: LD_VAR 0 6
107299: PUSH
107300: LD_INT 9
107302: ARRAY
107303: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
107304: LD_ADDR_VAR 0 26
107308: PUSH
107309: LD_VAR 0 6
107313: PUSH
107314: LD_INT 10
107316: ARRAY
107317: ST_TO_ADDR
// end else
107318: GO 107400
// begin f_ignore_area := false ;
107320: LD_ADDR_VAR 0 17
107324: PUSH
107325: LD_INT 0
107327: ST_TO_ADDR
// f_capture := false ;
107328: LD_ADDR_VAR 0 18
107332: PUSH
107333: LD_INT 0
107335: ST_TO_ADDR
// f_ignore_civ := false ;
107336: LD_ADDR_VAR 0 19
107340: PUSH
107341: LD_INT 0
107343: ST_TO_ADDR
// f_murder := false ;
107344: LD_ADDR_VAR 0 20
107348: PUSH
107349: LD_INT 0
107351: ST_TO_ADDR
// f_mines := false ;
107352: LD_ADDR_VAR 0 21
107356: PUSH
107357: LD_INT 0
107359: ST_TO_ADDR
// f_repair := false ;
107360: LD_ADDR_VAR 0 22
107364: PUSH
107365: LD_INT 0
107367: ST_TO_ADDR
// f_heal := false ;
107368: LD_ADDR_VAR 0 23
107372: PUSH
107373: LD_INT 0
107375: ST_TO_ADDR
// f_spacetime := false ;
107376: LD_ADDR_VAR 0 24
107380: PUSH
107381: LD_INT 0
107383: ST_TO_ADDR
// f_attack_depot := false ;
107384: LD_ADDR_VAR 0 25
107388: PUSH
107389: LD_INT 0
107391: ST_TO_ADDR
// f_crawl := false ;
107392: LD_ADDR_VAR 0 26
107396: PUSH
107397: LD_INT 0
107399: ST_TO_ADDR
// end ; if f_heal then
107400: LD_VAR 0 23
107404: IFFALSE 107431
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
107406: LD_ADDR_VAR 0 31
107410: PUSH
107411: LD_VAR 0 4
107415: PPUSH
107416: LD_INT 25
107418: PUSH
107419: LD_INT 4
107421: PUSH
107422: EMPTY
107423: LIST
107424: LIST
107425: PPUSH
107426: CALL_OW 72
107430: ST_TO_ADDR
// if f_repair then
107431: LD_VAR 0 22
107435: IFFALSE 107462
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
107437: LD_ADDR_VAR 0 33
107441: PUSH
107442: LD_VAR 0 4
107446: PPUSH
107447: LD_INT 25
107449: PUSH
107450: LD_INT 3
107452: PUSH
107453: EMPTY
107454: LIST
107455: LIST
107456: PPUSH
107457: CALL_OW 72
107461: ST_TO_ADDR
// units_path := [ ] ;
107462: LD_ADDR_VAR 0 16
107466: PUSH
107467: EMPTY
107468: ST_TO_ADDR
// for i = 1 to group do
107469: LD_ADDR_VAR 0 7
107473: PUSH
107474: DOUBLE
107475: LD_INT 1
107477: DEC
107478: ST_TO_ADDR
107479: LD_VAR 0 4
107483: PUSH
107484: FOR_TO
107485: IFFALSE 107514
// units_path := Replace ( units_path , i , path ) ;
107487: LD_ADDR_VAR 0 16
107491: PUSH
107492: LD_VAR 0 16
107496: PPUSH
107497: LD_VAR 0 7
107501: PPUSH
107502: LD_VAR 0 5
107506: PPUSH
107507: CALL_OW 1
107511: ST_TO_ADDR
107512: GO 107484
107514: POP
107515: POP
// repeat for i = group downto 1 do
107516: LD_ADDR_VAR 0 7
107520: PUSH
107521: DOUBLE
107522: LD_VAR 0 4
107526: INC
107527: ST_TO_ADDR
107528: LD_INT 1
107530: PUSH
107531: FOR_DOWNTO
107532: IFFALSE 111654
// begin wait ( 5 ) ;
107534: LD_INT 5
107536: PPUSH
107537: CALL_OW 67
// tmp := [ ] ;
107541: LD_ADDR_VAR 0 14
107545: PUSH
107546: EMPTY
107547: ST_TO_ADDR
// attacking := false ;
107548: LD_ADDR_VAR 0 29
107552: PUSH
107553: LD_INT 0
107555: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
107556: LD_VAR 0 4
107560: PUSH
107561: LD_VAR 0 7
107565: ARRAY
107566: PPUSH
107567: CALL_OW 301
107571: PUSH
107572: LD_VAR 0 4
107576: PUSH
107577: LD_VAR 0 7
107581: ARRAY
107582: NOT
107583: OR
107584: IFFALSE 107693
// begin if GetType ( group [ i ] ) = unit_human then
107586: LD_VAR 0 4
107590: PUSH
107591: LD_VAR 0 7
107595: ARRAY
107596: PPUSH
107597: CALL_OW 247
107601: PUSH
107602: LD_INT 1
107604: EQUAL
107605: IFFALSE 107651
// begin to_heal := to_heal diff group [ i ] ;
107607: LD_ADDR_VAR 0 30
107611: PUSH
107612: LD_VAR 0 30
107616: PUSH
107617: LD_VAR 0 4
107621: PUSH
107622: LD_VAR 0 7
107626: ARRAY
107627: DIFF
107628: ST_TO_ADDR
// healers := healers diff group [ i ] ;
107629: LD_ADDR_VAR 0 31
107633: PUSH
107634: LD_VAR 0 31
107638: PUSH
107639: LD_VAR 0 4
107643: PUSH
107644: LD_VAR 0 7
107648: ARRAY
107649: DIFF
107650: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
107651: LD_ADDR_VAR 0 4
107655: PUSH
107656: LD_VAR 0 4
107660: PPUSH
107661: LD_VAR 0 7
107665: PPUSH
107666: CALL_OW 3
107670: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
107671: LD_ADDR_VAR 0 16
107675: PUSH
107676: LD_VAR 0 16
107680: PPUSH
107681: LD_VAR 0 7
107685: PPUSH
107686: CALL_OW 3
107690: ST_TO_ADDR
// continue ;
107691: GO 107531
// end ; if f_repair then
107693: LD_VAR 0 22
107697: IFFALSE 108186
// begin if GetType ( group [ i ] ) = unit_vehicle then
107699: LD_VAR 0 4
107703: PUSH
107704: LD_VAR 0 7
107708: ARRAY
107709: PPUSH
107710: CALL_OW 247
107714: PUSH
107715: LD_INT 2
107717: EQUAL
107718: IFFALSE 107908
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
107720: LD_VAR 0 4
107724: PUSH
107725: LD_VAR 0 7
107729: ARRAY
107730: PPUSH
107731: CALL_OW 256
107735: PUSH
107736: LD_INT 700
107738: LESS
107739: PUSH
107740: LD_VAR 0 4
107744: PUSH
107745: LD_VAR 0 7
107749: ARRAY
107750: PUSH
107751: LD_VAR 0 32
107755: IN
107756: NOT
107757: AND
107758: IFFALSE 107782
// to_repair := to_repair union group [ i ] ;
107760: LD_ADDR_VAR 0 32
107764: PUSH
107765: LD_VAR 0 32
107769: PUSH
107770: LD_VAR 0 4
107774: PUSH
107775: LD_VAR 0 7
107779: ARRAY
107780: UNION
107781: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
107782: LD_VAR 0 4
107786: PUSH
107787: LD_VAR 0 7
107791: ARRAY
107792: PPUSH
107793: CALL_OW 256
107797: PUSH
107798: LD_INT 1000
107800: EQUAL
107801: PUSH
107802: LD_VAR 0 4
107806: PUSH
107807: LD_VAR 0 7
107811: ARRAY
107812: PUSH
107813: LD_VAR 0 32
107817: IN
107818: AND
107819: IFFALSE 107843
// to_repair := to_repair diff group [ i ] ;
107821: LD_ADDR_VAR 0 32
107825: PUSH
107826: LD_VAR 0 32
107830: PUSH
107831: LD_VAR 0 4
107835: PUSH
107836: LD_VAR 0 7
107840: ARRAY
107841: DIFF
107842: ST_TO_ADDR
// if group [ i ] in to_repair then
107843: LD_VAR 0 4
107847: PUSH
107848: LD_VAR 0 7
107852: ARRAY
107853: PUSH
107854: LD_VAR 0 32
107858: IN
107859: IFFALSE 107906
// begin if not IsInArea ( group [ i ] , f_repair ) then
107861: LD_VAR 0 4
107865: PUSH
107866: LD_VAR 0 7
107870: ARRAY
107871: PPUSH
107872: LD_VAR 0 22
107876: PPUSH
107877: CALL_OW 308
107881: NOT
107882: IFFALSE 107904
// ComMoveToArea ( group [ i ] , f_repair ) ;
107884: LD_VAR 0 4
107888: PUSH
107889: LD_VAR 0 7
107893: ARRAY
107894: PPUSH
107895: LD_VAR 0 22
107899: PPUSH
107900: CALL_OW 113
// continue ;
107904: GO 107531
// end ; end else
107906: GO 108186
// if group [ i ] in repairs then
107908: LD_VAR 0 4
107912: PUSH
107913: LD_VAR 0 7
107917: ARRAY
107918: PUSH
107919: LD_VAR 0 33
107923: IN
107924: IFFALSE 108186
// begin if IsInUnit ( group [ i ] ) then
107926: LD_VAR 0 4
107930: PUSH
107931: LD_VAR 0 7
107935: ARRAY
107936: PPUSH
107937: CALL_OW 310
107941: IFFALSE 108009
// begin z := IsInUnit ( group [ i ] ) ;
107943: LD_ADDR_VAR 0 13
107947: PUSH
107948: LD_VAR 0 4
107952: PUSH
107953: LD_VAR 0 7
107957: ARRAY
107958: PPUSH
107959: CALL_OW 310
107963: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
107964: LD_VAR 0 13
107968: PUSH
107969: LD_VAR 0 32
107973: IN
107974: PUSH
107975: LD_VAR 0 13
107979: PPUSH
107980: LD_VAR 0 22
107984: PPUSH
107985: CALL_OW 308
107989: AND
107990: IFFALSE 108007
// ComExitVehicle ( group [ i ] ) ;
107992: LD_VAR 0 4
107996: PUSH
107997: LD_VAR 0 7
108001: ARRAY
108002: PPUSH
108003: CALL_OW 121
// end else
108007: GO 108186
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
108009: LD_ADDR_VAR 0 13
108013: PUSH
108014: LD_VAR 0 4
108018: PPUSH
108019: LD_INT 95
108021: PUSH
108022: LD_VAR 0 22
108026: PUSH
108027: EMPTY
108028: LIST
108029: LIST
108030: PUSH
108031: LD_INT 58
108033: PUSH
108034: EMPTY
108035: LIST
108036: PUSH
108037: EMPTY
108038: LIST
108039: LIST
108040: PPUSH
108041: CALL_OW 72
108045: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
108046: LD_VAR 0 4
108050: PUSH
108051: LD_VAR 0 7
108055: ARRAY
108056: PPUSH
108057: CALL_OW 314
108061: NOT
108062: IFFALSE 108184
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
108064: LD_ADDR_VAR 0 10
108068: PUSH
108069: LD_VAR 0 13
108073: PPUSH
108074: LD_VAR 0 4
108078: PUSH
108079: LD_VAR 0 7
108083: ARRAY
108084: PPUSH
108085: CALL_OW 74
108089: ST_TO_ADDR
// if not x then
108090: LD_VAR 0 10
108094: NOT
108095: IFFALSE 108099
// continue ;
108097: GO 107531
// if GetLives ( x ) < 1000 then
108099: LD_VAR 0 10
108103: PPUSH
108104: CALL_OW 256
108108: PUSH
108109: LD_INT 1000
108111: LESS
108112: IFFALSE 108136
// ComRepairVehicle ( group [ i ] , x ) else
108114: LD_VAR 0 4
108118: PUSH
108119: LD_VAR 0 7
108123: ARRAY
108124: PPUSH
108125: LD_VAR 0 10
108129: PPUSH
108130: CALL_OW 129
108134: GO 108184
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
108136: LD_VAR 0 23
108140: PUSH
108141: LD_VAR 0 4
108145: PUSH
108146: LD_VAR 0 7
108150: ARRAY
108151: PPUSH
108152: CALL_OW 256
108156: PUSH
108157: LD_INT 1000
108159: LESS
108160: AND
108161: NOT
108162: IFFALSE 108184
// ComEnterUnit ( group [ i ] , x ) ;
108164: LD_VAR 0 4
108168: PUSH
108169: LD_VAR 0 7
108173: ARRAY
108174: PPUSH
108175: LD_VAR 0 10
108179: PPUSH
108180: CALL_OW 120
// end ; continue ;
108184: GO 107531
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
108186: LD_VAR 0 23
108190: PUSH
108191: LD_VAR 0 4
108195: PUSH
108196: LD_VAR 0 7
108200: ARRAY
108201: PPUSH
108202: CALL_OW 247
108206: PUSH
108207: LD_INT 1
108209: EQUAL
108210: AND
108211: IFFALSE 108689
// begin if group [ i ] in healers then
108213: LD_VAR 0 4
108217: PUSH
108218: LD_VAR 0 7
108222: ARRAY
108223: PUSH
108224: LD_VAR 0 31
108228: IN
108229: IFFALSE 108502
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
108231: LD_VAR 0 4
108235: PUSH
108236: LD_VAR 0 7
108240: ARRAY
108241: PPUSH
108242: LD_VAR 0 23
108246: PPUSH
108247: CALL_OW 308
108251: NOT
108252: PUSH
108253: LD_VAR 0 4
108257: PUSH
108258: LD_VAR 0 7
108262: ARRAY
108263: PPUSH
108264: CALL_OW 314
108268: NOT
108269: AND
108270: IFFALSE 108294
// ComMoveToArea ( group [ i ] , f_heal ) else
108272: LD_VAR 0 4
108276: PUSH
108277: LD_VAR 0 7
108281: ARRAY
108282: PPUSH
108283: LD_VAR 0 23
108287: PPUSH
108288: CALL_OW 113
108292: GO 108500
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
108294: LD_VAR 0 4
108298: PUSH
108299: LD_VAR 0 7
108303: ARRAY
108304: PPUSH
108305: CALL 85279 0 1
108309: PPUSH
108310: CALL_OW 256
108314: PUSH
108315: LD_INT 1000
108317: EQUAL
108318: IFFALSE 108337
// ComStop ( group [ i ] ) else
108320: LD_VAR 0 4
108324: PUSH
108325: LD_VAR 0 7
108329: ARRAY
108330: PPUSH
108331: CALL_OW 141
108335: GO 108500
// if not HasTask ( group [ i ] ) and to_heal then
108337: LD_VAR 0 4
108341: PUSH
108342: LD_VAR 0 7
108346: ARRAY
108347: PPUSH
108348: CALL_OW 314
108352: NOT
108353: PUSH
108354: LD_VAR 0 30
108358: AND
108359: IFFALSE 108500
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
108361: LD_ADDR_VAR 0 13
108365: PUSH
108366: LD_VAR 0 30
108370: PPUSH
108371: LD_INT 3
108373: PUSH
108374: LD_INT 54
108376: PUSH
108377: EMPTY
108378: LIST
108379: PUSH
108380: EMPTY
108381: LIST
108382: LIST
108383: PPUSH
108384: CALL_OW 72
108388: PPUSH
108389: LD_VAR 0 4
108393: PUSH
108394: LD_VAR 0 7
108398: ARRAY
108399: PPUSH
108400: CALL_OW 74
108404: ST_TO_ADDR
// if z then
108405: LD_VAR 0 13
108409: IFFALSE 108500
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
108411: LD_INT 91
108413: PUSH
108414: LD_VAR 0 13
108418: PUSH
108419: LD_INT 10
108421: PUSH
108422: EMPTY
108423: LIST
108424: LIST
108425: LIST
108426: PUSH
108427: LD_INT 81
108429: PUSH
108430: LD_VAR 0 13
108434: PPUSH
108435: CALL_OW 255
108439: PUSH
108440: EMPTY
108441: LIST
108442: LIST
108443: PUSH
108444: EMPTY
108445: LIST
108446: LIST
108447: PPUSH
108448: CALL_OW 69
108452: PUSH
108453: LD_INT 0
108455: EQUAL
108456: IFFALSE 108480
// ComHeal ( group [ i ] , z ) else
108458: LD_VAR 0 4
108462: PUSH
108463: LD_VAR 0 7
108467: ARRAY
108468: PPUSH
108469: LD_VAR 0 13
108473: PPUSH
108474: CALL_OW 128
108478: GO 108500
// ComMoveToArea ( group [ i ] , f_heal ) ;
108480: LD_VAR 0 4
108484: PUSH
108485: LD_VAR 0 7
108489: ARRAY
108490: PPUSH
108491: LD_VAR 0 23
108495: PPUSH
108496: CALL_OW 113
// end ; continue ;
108500: GO 107531
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
108502: LD_VAR 0 4
108506: PUSH
108507: LD_VAR 0 7
108511: ARRAY
108512: PPUSH
108513: CALL_OW 256
108517: PUSH
108518: LD_INT 700
108520: LESS
108521: PUSH
108522: LD_VAR 0 4
108526: PUSH
108527: LD_VAR 0 7
108531: ARRAY
108532: PUSH
108533: LD_VAR 0 30
108537: IN
108538: NOT
108539: AND
108540: IFFALSE 108564
// to_heal := to_heal union group [ i ] ;
108542: LD_ADDR_VAR 0 30
108546: PUSH
108547: LD_VAR 0 30
108551: PUSH
108552: LD_VAR 0 4
108556: PUSH
108557: LD_VAR 0 7
108561: ARRAY
108562: UNION
108563: ST_TO_ADDR
// if group [ i ] in to_heal then
108564: LD_VAR 0 4
108568: PUSH
108569: LD_VAR 0 7
108573: ARRAY
108574: PUSH
108575: LD_VAR 0 30
108579: IN
108580: IFFALSE 108689
// begin if GetLives ( group [ i ] ) = 1000 then
108582: LD_VAR 0 4
108586: PUSH
108587: LD_VAR 0 7
108591: ARRAY
108592: PPUSH
108593: CALL_OW 256
108597: PUSH
108598: LD_INT 1000
108600: EQUAL
108601: IFFALSE 108627
// to_heal := to_heal diff group [ i ] else
108603: LD_ADDR_VAR 0 30
108607: PUSH
108608: LD_VAR 0 30
108612: PUSH
108613: LD_VAR 0 4
108617: PUSH
108618: LD_VAR 0 7
108622: ARRAY
108623: DIFF
108624: ST_TO_ADDR
108625: GO 108689
// begin if not IsInArea ( group [ i ] , to_heal ) then
108627: LD_VAR 0 4
108631: PUSH
108632: LD_VAR 0 7
108636: ARRAY
108637: PPUSH
108638: LD_VAR 0 30
108642: PPUSH
108643: CALL_OW 308
108647: NOT
108648: IFFALSE 108672
// ComMoveToArea ( group [ i ] , f_heal ) else
108650: LD_VAR 0 4
108654: PUSH
108655: LD_VAR 0 7
108659: ARRAY
108660: PPUSH
108661: LD_VAR 0 23
108665: PPUSH
108666: CALL_OW 113
108670: GO 108687
// ComHold ( group [ i ] ) ;
108672: LD_VAR 0 4
108676: PUSH
108677: LD_VAR 0 7
108681: ARRAY
108682: PPUSH
108683: CALL_OW 140
// continue ;
108687: GO 107531
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
108689: LD_VAR 0 4
108693: PUSH
108694: LD_VAR 0 7
108698: ARRAY
108699: PPUSH
108700: LD_INT 10
108702: PPUSH
108703: CALL 83699 0 2
108707: NOT
108708: PUSH
108709: LD_VAR 0 16
108713: PUSH
108714: LD_VAR 0 7
108718: ARRAY
108719: PUSH
108720: EMPTY
108721: EQUAL
108722: NOT
108723: AND
108724: IFFALSE 108990
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
108726: LD_VAR 0 4
108730: PUSH
108731: LD_VAR 0 7
108735: ARRAY
108736: PPUSH
108737: CALL_OW 262
108741: PUSH
108742: LD_INT 1
108744: PUSH
108745: LD_INT 2
108747: PUSH
108748: EMPTY
108749: LIST
108750: LIST
108751: IN
108752: IFFALSE 108793
// if GetFuel ( group [ i ] ) < 10 then
108754: LD_VAR 0 4
108758: PUSH
108759: LD_VAR 0 7
108763: ARRAY
108764: PPUSH
108765: CALL_OW 261
108769: PUSH
108770: LD_INT 10
108772: LESS
108773: IFFALSE 108793
// SetFuel ( group [ i ] , 12 ) ;
108775: LD_VAR 0 4
108779: PUSH
108780: LD_VAR 0 7
108784: ARRAY
108785: PPUSH
108786: LD_INT 12
108788: PPUSH
108789: CALL_OW 240
// if units_path [ i ] then
108793: LD_VAR 0 16
108797: PUSH
108798: LD_VAR 0 7
108802: ARRAY
108803: IFFALSE 108988
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
108805: LD_VAR 0 4
108809: PUSH
108810: LD_VAR 0 7
108814: ARRAY
108815: PPUSH
108816: LD_VAR 0 16
108820: PUSH
108821: LD_VAR 0 7
108825: ARRAY
108826: PUSH
108827: LD_INT 1
108829: ARRAY
108830: PUSH
108831: LD_INT 1
108833: ARRAY
108834: PPUSH
108835: LD_VAR 0 16
108839: PUSH
108840: LD_VAR 0 7
108844: ARRAY
108845: PUSH
108846: LD_INT 1
108848: ARRAY
108849: PUSH
108850: LD_INT 2
108852: ARRAY
108853: PPUSH
108854: CALL_OW 297
108858: PUSH
108859: LD_INT 6
108861: GREATER
108862: IFFALSE 108937
// begin if not HasTask ( group [ i ] ) then
108864: LD_VAR 0 4
108868: PUSH
108869: LD_VAR 0 7
108873: ARRAY
108874: PPUSH
108875: CALL_OW 314
108879: NOT
108880: IFFALSE 108935
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
108882: LD_VAR 0 4
108886: PUSH
108887: LD_VAR 0 7
108891: ARRAY
108892: PPUSH
108893: LD_VAR 0 16
108897: PUSH
108898: LD_VAR 0 7
108902: ARRAY
108903: PUSH
108904: LD_INT 1
108906: ARRAY
108907: PUSH
108908: LD_INT 1
108910: ARRAY
108911: PPUSH
108912: LD_VAR 0 16
108916: PUSH
108917: LD_VAR 0 7
108921: ARRAY
108922: PUSH
108923: LD_INT 1
108925: ARRAY
108926: PUSH
108927: LD_INT 2
108929: ARRAY
108930: PPUSH
108931: CALL_OW 114
// end else
108935: GO 108988
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
108937: LD_ADDR_VAR 0 15
108941: PUSH
108942: LD_VAR 0 16
108946: PUSH
108947: LD_VAR 0 7
108951: ARRAY
108952: PPUSH
108953: LD_INT 1
108955: PPUSH
108956: CALL_OW 3
108960: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
108961: LD_ADDR_VAR 0 16
108965: PUSH
108966: LD_VAR 0 16
108970: PPUSH
108971: LD_VAR 0 7
108975: PPUSH
108976: LD_VAR 0 15
108980: PPUSH
108981: CALL_OW 1
108985: ST_TO_ADDR
// continue ;
108986: GO 107531
// end ; end ; end else
108988: GO 111652
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
108990: LD_ADDR_VAR 0 14
108994: PUSH
108995: LD_INT 81
108997: PUSH
108998: LD_VAR 0 4
109002: PUSH
109003: LD_VAR 0 7
109007: ARRAY
109008: PPUSH
109009: CALL_OW 255
109013: PUSH
109014: EMPTY
109015: LIST
109016: LIST
109017: PPUSH
109018: CALL_OW 69
109022: ST_TO_ADDR
// if not tmp then
109023: LD_VAR 0 14
109027: NOT
109028: IFFALSE 109032
// continue ;
109030: GO 107531
// if f_ignore_area then
109032: LD_VAR 0 17
109036: IFFALSE 109124
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
109038: LD_ADDR_VAR 0 15
109042: PUSH
109043: LD_VAR 0 14
109047: PPUSH
109048: LD_INT 3
109050: PUSH
109051: LD_INT 92
109053: PUSH
109054: LD_VAR 0 17
109058: PUSH
109059: LD_INT 1
109061: ARRAY
109062: PUSH
109063: LD_VAR 0 17
109067: PUSH
109068: LD_INT 2
109070: ARRAY
109071: PUSH
109072: LD_VAR 0 17
109076: PUSH
109077: LD_INT 3
109079: ARRAY
109080: PUSH
109081: EMPTY
109082: LIST
109083: LIST
109084: LIST
109085: LIST
109086: PUSH
109087: EMPTY
109088: LIST
109089: LIST
109090: PPUSH
109091: CALL_OW 72
109095: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
109096: LD_VAR 0 14
109100: PUSH
109101: LD_VAR 0 15
109105: DIFF
109106: IFFALSE 109124
// tmp := tmp diff tmp2 ;
109108: LD_ADDR_VAR 0 14
109112: PUSH
109113: LD_VAR 0 14
109117: PUSH
109118: LD_VAR 0 15
109122: DIFF
109123: ST_TO_ADDR
// end ; if not f_murder then
109124: LD_VAR 0 20
109128: NOT
109129: IFFALSE 109187
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
109131: LD_ADDR_VAR 0 15
109135: PUSH
109136: LD_VAR 0 14
109140: PPUSH
109141: LD_INT 3
109143: PUSH
109144: LD_INT 50
109146: PUSH
109147: EMPTY
109148: LIST
109149: PUSH
109150: EMPTY
109151: LIST
109152: LIST
109153: PPUSH
109154: CALL_OW 72
109158: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
109159: LD_VAR 0 14
109163: PUSH
109164: LD_VAR 0 15
109168: DIFF
109169: IFFALSE 109187
// tmp := tmp diff tmp2 ;
109171: LD_ADDR_VAR 0 14
109175: PUSH
109176: LD_VAR 0 14
109180: PUSH
109181: LD_VAR 0 15
109185: DIFF
109186: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
109187: LD_ADDR_VAR 0 14
109191: PUSH
109192: LD_VAR 0 4
109196: PUSH
109197: LD_VAR 0 7
109201: ARRAY
109202: PPUSH
109203: LD_VAR 0 14
109207: PPUSH
109208: LD_INT 1
109210: PPUSH
109211: LD_INT 1
109213: PPUSH
109214: CALL 56633 0 4
109218: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
109219: LD_VAR 0 4
109223: PUSH
109224: LD_VAR 0 7
109228: ARRAY
109229: PPUSH
109230: CALL_OW 257
109234: PUSH
109235: LD_INT 1
109237: EQUAL
109238: IFFALSE 109686
// begin if WantPlant ( group [ i ] ) then
109240: LD_VAR 0 4
109244: PUSH
109245: LD_VAR 0 7
109249: ARRAY
109250: PPUSH
109251: CALL 56134 0 1
109255: IFFALSE 109259
// continue ;
109257: GO 107531
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
109259: LD_VAR 0 18
109263: PUSH
109264: LD_VAR 0 4
109268: PUSH
109269: LD_VAR 0 7
109273: ARRAY
109274: PPUSH
109275: CALL_OW 310
109279: NOT
109280: AND
109281: PUSH
109282: LD_VAR 0 14
109286: PUSH
109287: LD_INT 1
109289: ARRAY
109290: PUSH
109291: LD_VAR 0 14
109295: PPUSH
109296: LD_INT 21
109298: PUSH
109299: LD_INT 2
109301: PUSH
109302: EMPTY
109303: LIST
109304: LIST
109305: PUSH
109306: LD_INT 58
109308: PUSH
109309: EMPTY
109310: LIST
109311: PUSH
109312: EMPTY
109313: LIST
109314: LIST
109315: PPUSH
109316: CALL_OW 72
109320: IN
109321: AND
109322: IFFALSE 109358
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
109324: LD_VAR 0 4
109328: PUSH
109329: LD_VAR 0 7
109333: ARRAY
109334: PPUSH
109335: LD_VAR 0 14
109339: PUSH
109340: LD_INT 1
109342: ARRAY
109343: PPUSH
109344: CALL_OW 120
// attacking := true ;
109348: LD_ADDR_VAR 0 29
109352: PUSH
109353: LD_INT 1
109355: ST_TO_ADDR
// continue ;
109356: GO 107531
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
109358: LD_VAR 0 26
109362: PUSH
109363: LD_VAR 0 4
109367: PUSH
109368: LD_VAR 0 7
109372: ARRAY
109373: PPUSH
109374: CALL_OW 257
109378: PUSH
109379: LD_INT 1
109381: EQUAL
109382: AND
109383: PUSH
109384: LD_VAR 0 4
109388: PUSH
109389: LD_VAR 0 7
109393: ARRAY
109394: PPUSH
109395: CALL_OW 256
109399: PUSH
109400: LD_INT 800
109402: LESS
109403: AND
109404: PUSH
109405: LD_VAR 0 4
109409: PUSH
109410: LD_VAR 0 7
109414: ARRAY
109415: PPUSH
109416: CALL_OW 318
109420: NOT
109421: AND
109422: IFFALSE 109439
// ComCrawl ( group [ i ] ) ;
109424: LD_VAR 0 4
109428: PUSH
109429: LD_VAR 0 7
109433: ARRAY
109434: PPUSH
109435: CALL_OW 137
// if f_mines then
109439: LD_VAR 0 21
109443: IFFALSE 109686
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
109445: LD_VAR 0 14
109449: PUSH
109450: LD_INT 1
109452: ARRAY
109453: PPUSH
109454: CALL_OW 247
109458: PUSH
109459: LD_INT 3
109461: EQUAL
109462: PUSH
109463: LD_VAR 0 14
109467: PUSH
109468: LD_INT 1
109470: ARRAY
109471: PUSH
109472: LD_VAR 0 27
109476: IN
109477: NOT
109478: AND
109479: IFFALSE 109686
// begin x := GetX ( tmp [ 1 ] ) ;
109481: LD_ADDR_VAR 0 10
109485: PUSH
109486: LD_VAR 0 14
109490: PUSH
109491: LD_INT 1
109493: ARRAY
109494: PPUSH
109495: CALL_OW 250
109499: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
109500: LD_ADDR_VAR 0 11
109504: PUSH
109505: LD_VAR 0 14
109509: PUSH
109510: LD_INT 1
109512: ARRAY
109513: PPUSH
109514: CALL_OW 251
109518: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
109519: LD_ADDR_VAR 0 12
109523: PUSH
109524: LD_VAR 0 4
109528: PUSH
109529: LD_VAR 0 7
109533: ARRAY
109534: PPUSH
109535: CALL 83784 0 1
109539: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
109540: LD_VAR 0 4
109544: PUSH
109545: LD_VAR 0 7
109549: ARRAY
109550: PPUSH
109551: LD_VAR 0 10
109555: PPUSH
109556: LD_VAR 0 11
109560: PPUSH
109561: LD_VAR 0 14
109565: PUSH
109566: LD_INT 1
109568: ARRAY
109569: PPUSH
109570: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
109574: LD_VAR 0 4
109578: PUSH
109579: LD_VAR 0 7
109583: ARRAY
109584: PPUSH
109585: LD_VAR 0 10
109589: PPUSH
109590: LD_VAR 0 12
109594: PPUSH
109595: LD_INT 7
109597: PPUSH
109598: CALL_OW 272
109602: PPUSH
109603: LD_VAR 0 11
109607: PPUSH
109608: LD_VAR 0 12
109612: PPUSH
109613: LD_INT 7
109615: PPUSH
109616: CALL_OW 273
109620: PPUSH
109621: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
109625: LD_VAR 0 4
109629: PUSH
109630: LD_VAR 0 7
109634: ARRAY
109635: PPUSH
109636: LD_INT 71
109638: PPUSH
109639: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
109643: LD_ADDR_VAR 0 27
109647: PUSH
109648: LD_VAR 0 27
109652: PPUSH
109653: LD_VAR 0 27
109657: PUSH
109658: LD_INT 1
109660: PLUS
109661: PPUSH
109662: LD_VAR 0 14
109666: PUSH
109667: LD_INT 1
109669: ARRAY
109670: PPUSH
109671: CALL_OW 1
109675: ST_TO_ADDR
// attacking := true ;
109676: LD_ADDR_VAR 0 29
109680: PUSH
109681: LD_INT 1
109683: ST_TO_ADDR
// continue ;
109684: GO 107531
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
109686: LD_VAR 0 4
109690: PUSH
109691: LD_VAR 0 7
109695: ARRAY
109696: PPUSH
109697: CALL_OW 257
109701: PUSH
109702: LD_INT 17
109704: EQUAL
109705: PUSH
109706: LD_VAR 0 4
109710: PUSH
109711: LD_VAR 0 7
109715: ARRAY
109716: PPUSH
109717: CALL_OW 110
109721: PUSH
109722: LD_INT 71
109724: EQUAL
109725: NOT
109726: AND
109727: IFFALSE 109873
// begin attacking := false ;
109729: LD_ADDR_VAR 0 29
109733: PUSH
109734: LD_INT 0
109736: ST_TO_ADDR
// k := 5 ;
109737: LD_ADDR_VAR 0 9
109741: PUSH
109742: LD_INT 5
109744: ST_TO_ADDR
// if tmp < k then
109745: LD_VAR 0 14
109749: PUSH
109750: LD_VAR 0 9
109754: LESS
109755: IFFALSE 109767
// k := tmp ;
109757: LD_ADDR_VAR 0 9
109761: PUSH
109762: LD_VAR 0 14
109766: ST_TO_ADDR
// for j = 1 to k do
109767: LD_ADDR_VAR 0 8
109771: PUSH
109772: DOUBLE
109773: LD_INT 1
109775: DEC
109776: ST_TO_ADDR
109777: LD_VAR 0 9
109781: PUSH
109782: FOR_TO
109783: IFFALSE 109871
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
109785: LD_VAR 0 14
109789: PUSH
109790: LD_VAR 0 8
109794: ARRAY
109795: PUSH
109796: LD_VAR 0 14
109800: PPUSH
109801: LD_INT 58
109803: PUSH
109804: EMPTY
109805: LIST
109806: PPUSH
109807: CALL_OW 72
109811: IN
109812: NOT
109813: IFFALSE 109869
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
109815: LD_VAR 0 4
109819: PUSH
109820: LD_VAR 0 7
109824: ARRAY
109825: PPUSH
109826: LD_VAR 0 14
109830: PUSH
109831: LD_VAR 0 8
109835: ARRAY
109836: PPUSH
109837: CALL_OW 115
// attacking := true ;
109841: LD_ADDR_VAR 0 29
109845: PUSH
109846: LD_INT 1
109848: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
109849: LD_VAR 0 4
109853: PUSH
109854: LD_VAR 0 7
109858: ARRAY
109859: PPUSH
109860: LD_INT 71
109862: PPUSH
109863: CALL_OW 109
// continue ;
109867: GO 109782
// end ; end ;
109869: GO 109782
109871: POP
109872: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
109873: LD_VAR 0 4
109877: PUSH
109878: LD_VAR 0 7
109882: ARRAY
109883: PPUSH
109884: CALL_OW 257
109888: PUSH
109889: LD_INT 8
109891: EQUAL
109892: PUSH
109893: LD_VAR 0 4
109897: PUSH
109898: LD_VAR 0 7
109902: ARRAY
109903: PPUSH
109904: CALL_OW 264
109908: PUSH
109909: LD_INT 28
109911: PUSH
109912: LD_INT 45
109914: PUSH
109915: LD_INT 7
109917: PUSH
109918: LD_INT 47
109920: PUSH
109921: EMPTY
109922: LIST
109923: LIST
109924: LIST
109925: LIST
109926: IN
109927: OR
109928: IFFALSE 110184
// begin attacking := false ;
109930: LD_ADDR_VAR 0 29
109934: PUSH
109935: LD_INT 0
109937: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
109938: LD_VAR 0 14
109942: PUSH
109943: LD_INT 1
109945: ARRAY
109946: PPUSH
109947: CALL_OW 266
109951: PUSH
109952: LD_INT 32
109954: PUSH
109955: LD_INT 31
109957: PUSH
109958: LD_INT 33
109960: PUSH
109961: LD_INT 4
109963: PUSH
109964: LD_INT 5
109966: PUSH
109967: EMPTY
109968: LIST
109969: LIST
109970: LIST
109971: LIST
109972: LIST
109973: IN
109974: IFFALSE 110160
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
109976: LD_ADDR_VAR 0 9
109980: PUSH
109981: LD_VAR 0 14
109985: PUSH
109986: LD_INT 1
109988: ARRAY
109989: PPUSH
109990: CALL_OW 266
109994: PPUSH
109995: LD_VAR 0 14
109999: PUSH
110000: LD_INT 1
110002: ARRAY
110003: PPUSH
110004: CALL_OW 250
110008: PPUSH
110009: LD_VAR 0 14
110013: PUSH
110014: LD_INT 1
110016: ARRAY
110017: PPUSH
110018: CALL_OW 251
110022: PPUSH
110023: LD_VAR 0 14
110027: PUSH
110028: LD_INT 1
110030: ARRAY
110031: PPUSH
110032: CALL_OW 254
110036: PPUSH
110037: LD_VAR 0 14
110041: PUSH
110042: LD_INT 1
110044: ARRAY
110045: PPUSH
110046: CALL_OW 248
110050: PPUSH
110051: LD_INT 0
110053: PPUSH
110054: CALL 65154 0 6
110058: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
110059: LD_ADDR_VAR 0 8
110063: PUSH
110064: LD_VAR 0 4
110068: PUSH
110069: LD_VAR 0 7
110073: ARRAY
110074: PPUSH
110075: LD_VAR 0 9
110079: PPUSH
110080: CALL 83824 0 2
110084: ST_TO_ADDR
// if j then
110085: LD_VAR 0 8
110089: IFFALSE 110158
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
110091: LD_VAR 0 8
110095: PUSH
110096: LD_INT 1
110098: ARRAY
110099: PPUSH
110100: LD_VAR 0 8
110104: PUSH
110105: LD_INT 2
110107: ARRAY
110108: PPUSH
110109: CALL_OW 488
110113: IFFALSE 110158
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
110115: LD_VAR 0 4
110119: PUSH
110120: LD_VAR 0 7
110124: ARRAY
110125: PPUSH
110126: LD_VAR 0 8
110130: PUSH
110131: LD_INT 1
110133: ARRAY
110134: PPUSH
110135: LD_VAR 0 8
110139: PUSH
110140: LD_INT 2
110142: ARRAY
110143: PPUSH
110144: CALL_OW 116
// attacking := true ;
110148: LD_ADDR_VAR 0 29
110152: PUSH
110153: LD_INT 1
110155: ST_TO_ADDR
// continue ;
110156: GO 107531
// end ; end else
110158: GO 110184
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
110160: LD_VAR 0 4
110164: PUSH
110165: LD_VAR 0 7
110169: ARRAY
110170: PPUSH
110171: LD_VAR 0 14
110175: PUSH
110176: LD_INT 1
110178: ARRAY
110179: PPUSH
110180: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
110184: LD_VAR 0 4
110188: PUSH
110189: LD_VAR 0 7
110193: ARRAY
110194: PPUSH
110195: CALL_OW 265
110199: PUSH
110200: LD_INT 11
110202: EQUAL
110203: IFFALSE 110481
// begin k := 10 ;
110205: LD_ADDR_VAR 0 9
110209: PUSH
110210: LD_INT 10
110212: ST_TO_ADDR
// x := 0 ;
110213: LD_ADDR_VAR 0 10
110217: PUSH
110218: LD_INT 0
110220: ST_TO_ADDR
// if tmp < k then
110221: LD_VAR 0 14
110225: PUSH
110226: LD_VAR 0 9
110230: LESS
110231: IFFALSE 110243
// k := tmp ;
110233: LD_ADDR_VAR 0 9
110237: PUSH
110238: LD_VAR 0 14
110242: ST_TO_ADDR
// for j = k downto 1 do
110243: LD_ADDR_VAR 0 8
110247: PUSH
110248: DOUBLE
110249: LD_VAR 0 9
110253: INC
110254: ST_TO_ADDR
110255: LD_INT 1
110257: PUSH
110258: FOR_DOWNTO
110259: IFFALSE 110334
// begin if GetType ( tmp [ j ] ) = unit_human then
110261: LD_VAR 0 14
110265: PUSH
110266: LD_VAR 0 8
110270: ARRAY
110271: PPUSH
110272: CALL_OW 247
110276: PUSH
110277: LD_INT 1
110279: EQUAL
110280: IFFALSE 110332
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
110282: LD_VAR 0 4
110286: PUSH
110287: LD_VAR 0 7
110291: ARRAY
110292: PPUSH
110293: LD_VAR 0 14
110297: PUSH
110298: LD_VAR 0 8
110302: ARRAY
110303: PPUSH
110304: CALL 84095 0 2
// x := tmp [ j ] ;
110308: LD_ADDR_VAR 0 10
110312: PUSH
110313: LD_VAR 0 14
110317: PUSH
110318: LD_VAR 0 8
110322: ARRAY
110323: ST_TO_ADDR
// attacking := true ;
110324: LD_ADDR_VAR 0 29
110328: PUSH
110329: LD_INT 1
110331: ST_TO_ADDR
// end ; end ;
110332: GO 110258
110334: POP
110335: POP
// if not x then
110336: LD_VAR 0 10
110340: NOT
110341: IFFALSE 110481
// begin attacking := true ;
110343: LD_ADDR_VAR 0 29
110347: PUSH
110348: LD_INT 1
110350: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
110351: LD_VAR 0 4
110355: PUSH
110356: LD_VAR 0 7
110360: ARRAY
110361: PPUSH
110362: CALL_OW 250
110366: PPUSH
110367: LD_VAR 0 4
110371: PUSH
110372: LD_VAR 0 7
110376: ARRAY
110377: PPUSH
110378: CALL_OW 251
110382: PPUSH
110383: CALL_OW 546
110387: PUSH
110388: LD_INT 2
110390: ARRAY
110391: PUSH
110392: LD_VAR 0 14
110396: PUSH
110397: LD_INT 1
110399: ARRAY
110400: PPUSH
110401: CALL_OW 250
110405: PPUSH
110406: LD_VAR 0 14
110410: PUSH
110411: LD_INT 1
110413: ARRAY
110414: PPUSH
110415: CALL_OW 251
110419: PPUSH
110420: CALL_OW 546
110424: PUSH
110425: LD_INT 2
110427: ARRAY
110428: EQUAL
110429: IFFALSE 110457
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
110431: LD_VAR 0 4
110435: PUSH
110436: LD_VAR 0 7
110440: ARRAY
110441: PPUSH
110442: LD_VAR 0 14
110446: PUSH
110447: LD_INT 1
110449: ARRAY
110450: PPUSH
110451: CALL 84095 0 2
110455: GO 110481
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
110457: LD_VAR 0 4
110461: PUSH
110462: LD_VAR 0 7
110466: ARRAY
110467: PPUSH
110468: LD_VAR 0 14
110472: PUSH
110473: LD_INT 1
110475: ARRAY
110476: PPUSH
110477: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
110481: LD_VAR 0 4
110485: PUSH
110486: LD_VAR 0 7
110490: ARRAY
110491: PPUSH
110492: CALL_OW 264
110496: PUSH
110497: LD_INT 29
110499: EQUAL
110500: IFFALSE 110866
// begin if WantsToAttack ( group [ i ] ) in bombed then
110502: LD_VAR 0 4
110506: PUSH
110507: LD_VAR 0 7
110511: ARRAY
110512: PPUSH
110513: CALL_OW 319
110517: PUSH
110518: LD_VAR 0 28
110522: IN
110523: IFFALSE 110527
// continue ;
110525: GO 107531
// k := 8 ;
110527: LD_ADDR_VAR 0 9
110531: PUSH
110532: LD_INT 8
110534: ST_TO_ADDR
// x := 0 ;
110535: LD_ADDR_VAR 0 10
110539: PUSH
110540: LD_INT 0
110542: ST_TO_ADDR
// if tmp < k then
110543: LD_VAR 0 14
110547: PUSH
110548: LD_VAR 0 9
110552: LESS
110553: IFFALSE 110565
// k := tmp ;
110555: LD_ADDR_VAR 0 9
110559: PUSH
110560: LD_VAR 0 14
110564: ST_TO_ADDR
// for j = 1 to k do
110565: LD_ADDR_VAR 0 8
110569: PUSH
110570: DOUBLE
110571: LD_INT 1
110573: DEC
110574: ST_TO_ADDR
110575: LD_VAR 0 9
110579: PUSH
110580: FOR_TO
110581: IFFALSE 110713
// begin if GetType ( tmp [ j ] ) = unit_building then
110583: LD_VAR 0 14
110587: PUSH
110588: LD_VAR 0 8
110592: ARRAY
110593: PPUSH
110594: CALL_OW 247
110598: PUSH
110599: LD_INT 3
110601: EQUAL
110602: IFFALSE 110711
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
110604: LD_VAR 0 14
110608: PUSH
110609: LD_VAR 0 8
110613: ARRAY
110614: PUSH
110615: LD_VAR 0 28
110619: IN
110620: NOT
110621: PUSH
110622: LD_VAR 0 14
110626: PUSH
110627: LD_VAR 0 8
110631: ARRAY
110632: PPUSH
110633: CALL_OW 313
110637: AND
110638: IFFALSE 110711
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
110640: LD_VAR 0 4
110644: PUSH
110645: LD_VAR 0 7
110649: ARRAY
110650: PPUSH
110651: LD_VAR 0 14
110655: PUSH
110656: LD_VAR 0 8
110660: ARRAY
110661: PPUSH
110662: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
110666: LD_ADDR_VAR 0 28
110670: PUSH
110671: LD_VAR 0 28
110675: PPUSH
110676: LD_VAR 0 28
110680: PUSH
110681: LD_INT 1
110683: PLUS
110684: PPUSH
110685: LD_VAR 0 14
110689: PUSH
110690: LD_VAR 0 8
110694: ARRAY
110695: PPUSH
110696: CALL_OW 1
110700: ST_TO_ADDR
// attacking := true ;
110701: LD_ADDR_VAR 0 29
110705: PUSH
110706: LD_INT 1
110708: ST_TO_ADDR
// break ;
110709: GO 110713
// end ; end ;
110711: GO 110580
110713: POP
110714: POP
// if not attacking and f_attack_depot then
110715: LD_VAR 0 29
110719: NOT
110720: PUSH
110721: LD_VAR 0 25
110725: AND
110726: IFFALSE 110821
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
110728: LD_ADDR_VAR 0 13
110732: PUSH
110733: LD_VAR 0 14
110737: PPUSH
110738: LD_INT 2
110740: PUSH
110741: LD_INT 30
110743: PUSH
110744: LD_INT 0
110746: PUSH
110747: EMPTY
110748: LIST
110749: LIST
110750: PUSH
110751: LD_INT 30
110753: PUSH
110754: LD_INT 1
110756: PUSH
110757: EMPTY
110758: LIST
110759: LIST
110760: PUSH
110761: EMPTY
110762: LIST
110763: LIST
110764: LIST
110765: PPUSH
110766: CALL_OW 72
110770: ST_TO_ADDR
// if z then
110771: LD_VAR 0 13
110775: IFFALSE 110821
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
110777: LD_VAR 0 4
110781: PUSH
110782: LD_VAR 0 7
110786: ARRAY
110787: PPUSH
110788: LD_VAR 0 13
110792: PPUSH
110793: LD_VAR 0 4
110797: PUSH
110798: LD_VAR 0 7
110802: ARRAY
110803: PPUSH
110804: CALL_OW 74
110808: PPUSH
110809: CALL_OW 115
// attacking := true ;
110813: LD_ADDR_VAR 0 29
110817: PUSH
110818: LD_INT 1
110820: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
110821: LD_VAR 0 4
110825: PUSH
110826: LD_VAR 0 7
110830: ARRAY
110831: PPUSH
110832: CALL_OW 256
110836: PUSH
110837: LD_INT 500
110839: LESS
110840: IFFALSE 110866
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
110842: LD_VAR 0 4
110846: PUSH
110847: LD_VAR 0 7
110851: ARRAY
110852: PPUSH
110853: LD_VAR 0 14
110857: PUSH
110858: LD_INT 1
110860: ARRAY
110861: PPUSH
110862: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
110866: LD_VAR 0 4
110870: PUSH
110871: LD_VAR 0 7
110875: ARRAY
110876: PPUSH
110877: CALL_OW 264
110881: PUSH
110882: LD_INT 49
110884: EQUAL
110885: IFFALSE 111006
// begin if not HasTask ( group [ i ] ) then
110887: LD_VAR 0 4
110891: PUSH
110892: LD_VAR 0 7
110896: ARRAY
110897: PPUSH
110898: CALL_OW 314
110902: NOT
110903: IFFALSE 111006
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
110905: LD_ADDR_VAR 0 9
110909: PUSH
110910: LD_INT 81
110912: PUSH
110913: LD_VAR 0 4
110917: PUSH
110918: LD_VAR 0 7
110922: ARRAY
110923: PPUSH
110924: CALL_OW 255
110928: PUSH
110929: EMPTY
110930: LIST
110931: LIST
110932: PPUSH
110933: CALL_OW 69
110937: PPUSH
110938: LD_VAR 0 4
110942: PUSH
110943: LD_VAR 0 7
110947: ARRAY
110948: PPUSH
110949: CALL_OW 74
110953: ST_TO_ADDR
// if k then
110954: LD_VAR 0 9
110958: IFFALSE 111006
// if GetDistUnits ( group [ i ] , k ) > 10 then
110960: LD_VAR 0 4
110964: PUSH
110965: LD_VAR 0 7
110969: ARRAY
110970: PPUSH
110971: LD_VAR 0 9
110975: PPUSH
110976: CALL_OW 296
110980: PUSH
110981: LD_INT 10
110983: GREATER
110984: IFFALSE 111006
// ComMoveUnit ( group [ i ] , k ) ;
110986: LD_VAR 0 4
110990: PUSH
110991: LD_VAR 0 7
110995: ARRAY
110996: PPUSH
110997: LD_VAR 0 9
111001: PPUSH
111002: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
111006: LD_VAR 0 4
111010: PUSH
111011: LD_VAR 0 7
111015: ARRAY
111016: PPUSH
111017: CALL_OW 256
111021: PUSH
111022: LD_INT 250
111024: LESS
111025: PUSH
111026: LD_VAR 0 4
111030: PUSH
111031: LD_VAR 0 7
111035: ARRAY
111036: PUSH
111037: LD_INT 21
111039: PUSH
111040: LD_INT 2
111042: PUSH
111043: EMPTY
111044: LIST
111045: LIST
111046: PUSH
111047: LD_INT 23
111049: PUSH
111050: LD_INT 2
111052: PUSH
111053: EMPTY
111054: LIST
111055: LIST
111056: PUSH
111057: EMPTY
111058: LIST
111059: LIST
111060: PPUSH
111061: CALL_OW 69
111065: IN
111066: AND
111067: IFFALSE 111192
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
111069: LD_ADDR_VAR 0 9
111073: PUSH
111074: LD_OWVAR 3
111078: PUSH
111079: LD_VAR 0 4
111083: PUSH
111084: LD_VAR 0 7
111088: ARRAY
111089: DIFF
111090: PPUSH
111091: LD_VAR 0 4
111095: PUSH
111096: LD_VAR 0 7
111100: ARRAY
111101: PPUSH
111102: CALL_OW 74
111106: ST_TO_ADDR
// if not k then
111107: LD_VAR 0 9
111111: NOT
111112: IFFALSE 111116
// continue ;
111114: GO 107531
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
111116: LD_VAR 0 9
111120: PUSH
111121: LD_INT 81
111123: PUSH
111124: LD_VAR 0 4
111128: PUSH
111129: LD_VAR 0 7
111133: ARRAY
111134: PPUSH
111135: CALL_OW 255
111139: PUSH
111140: EMPTY
111141: LIST
111142: LIST
111143: PPUSH
111144: CALL_OW 69
111148: IN
111149: PUSH
111150: LD_VAR 0 9
111154: PPUSH
111155: LD_VAR 0 4
111159: PUSH
111160: LD_VAR 0 7
111164: ARRAY
111165: PPUSH
111166: CALL_OW 296
111170: PUSH
111171: LD_INT 5
111173: LESS
111174: AND
111175: IFFALSE 111192
// ComAutodestruct ( group [ i ] ) ;
111177: LD_VAR 0 4
111181: PUSH
111182: LD_VAR 0 7
111186: ARRAY
111187: PPUSH
111188: CALL 83993 0 1
// end ; if f_attack_depot then
111192: LD_VAR 0 25
111196: IFFALSE 111308
// begin k := 6 ;
111198: LD_ADDR_VAR 0 9
111202: PUSH
111203: LD_INT 6
111205: ST_TO_ADDR
// if tmp < k then
111206: LD_VAR 0 14
111210: PUSH
111211: LD_VAR 0 9
111215: LESS
111216: IFFALSE 111228
// k := tmp ;
111218: LD_ADDR_VAR 0 9
111222: PUSH
111223: LD_VAR 0 14
111227: ST_TO_ADDR
// for j = 1 to k do
111228: LD_ADDR_VAR 0 8
111232: PUSH
111233: DOUBLE
111234: LD_INT 1
111236: DEC
111237: ST_TO_ADDR
111238: LD_VAR 0 9
111242: PUSH
111243: FOR_TO
111244: IFFALSE 111306
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
111246: LD_VAR 0 8
111250: PPUSH
111251: CALL_OW 266
111255: PUSH
111256: LD_INT 0
111258: PUSH
111259: LD_INT 1
111261: PUSH
111262: EMPTY
111263: LIST
111264: LIST
111265: IN
111266: IFFALSE 111304
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
111268: LD_VAR 0 4
111272: PUSH
111273: LD_VAR 0 7
111277: ARRAY
111278: PPUSH
111279: LD_VAR 0 14
111283: PUSH
111284: LD_VAR 0 8
111288: ARRAY
111289: PPUSH
111290: CALL_OW 115
// attacking := true ;
111294: LD_ADDR_VAR 0 29
111298: PUSH
111299: LD_INT 1
111301: ST_TO_ADDR
// break ;
111302: GO 111306
// end ;
111304: GO 111243
111306: POP
111307: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
111308: LD_VAR 0 4
111312: PUSH
111313: LD_VAR 0 7
111317: ARRAY
111318: PPUSH
111319: CALL_OW 302
111323: PUSH
111324: LD_VAR 0 29
111328: NOT
111329: AND
111330: IFFALSE 111652
// begin if GetTag ( group [ i ] ) = 71 then
111332: LD_VAR 0 4
111336: PUSH
111337: LD_VAR 0 7
111341: ARRAY
111342: PPUSH
111343: CALL_OW 110
111347: PUSH
111348: LD_INT 71
111350: EQUAL
111351: IFFALSE 111392
// begin if HasTask ( group [ i ] ) then
111353: LD_VAR 0 4
111357: PUSH
111358: LD_VAR 0 7
111362: ARRAY
111363: PPUSH
111364: CALL_OW 314
111368: IFFALSE 111374
// continue else
111370: GO 107531
111372: GO 111392
// SetTag ( group [ i ] , 0 ) ;
111374: LD_VAR 0 4
111378: PUSH
111379: LD_VAR 0 7
111383: ARRAY
111384: PPUSH
111385: LD_INT 0
111387: PPUSH
111388: CALL_OW 109
// end ; k := 8 ;
111392: LD_ADDR_VAR 0 9
111396: PUSH
111397: LD_INT 8
111399: ST_TO_ADDR
// x := 0 ;
111400: LD_ADDR_VAR 0 10
111404: PUSH
111405: LD_INT 0
111407: ST_TO_ADDR
// if tmp < k then
111408: LD_VAR 0 14
111412: PUSH
111413: LD_VAR 0 9
111417: LESS
111418: IFFALSE 111430
// k := tmp ;
111420: LD_ADDR_VAR 0 9
111424: PUSH
111425: LD_VAR 0 14
111429: ST_TO_ADDR
// for j = 1 to k do
111430: LD_ADDR_VAR 0 8
111434: PUSH
111435: DOUBLE
111436: LD_INT 1
111438: DEC
111439: ST_TO_ADDR
111440: LD_VAR 0 9
111444: PUSH
111445: FOR_TO
111446: IFFALSE 111544
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
111448: LD_VAR 0 14
111452: PUSH
111453: LD_VAR 0 8
111457: ARRAY
111458: PPUSH
111459: CALL_OW 247
111463: PUSH
111464: LD_INT 1
111466: EQUAL
111467: PUSH
111468: LD_VAR 0 14
111472: PUSH
111473: LD_VAR 0 8
111477: ARRAY
111478: PPUSH
111479: CALL_OW 256
111483: PUSH
111484: LD_INT 250
111486: LESS
111487: PUSH
111488: LD_VAR 0 20
111492: AND
111493: PUSH
111494: LD_VAR 0 20
111498: NOT
111499: PUSH
111500: LD_VAR 0 14
111504: PUSH
111505: LD_VAR 0 8
111509: ARRAY
111510: PPUSH
111511: CALL_OW 256
111515: PUSH
111516: LD_INT 250
111518: GREATEREQUAL
111519: AND
111520: OR
111521: AND
111522: IFFALSE 111542
// begin x := tmp [ j ] ;
111524: LD_ADDR_VAR 0 10
111528: PUSH
111529: LD_VAR 0 14
111533: PUSH
111534: LD_VAR 0 8
111538: ARRAY
111539: ST_TO_ADDR
// break ;
111540: GO 111544
// end ;
111542: GO 111445
111544: POP
111545: POP
// if x then
111546: LD_VAR 0 10
111550: IFFALSE 111574
// ComAttackUnit ( group [ i ] , x ) else
111552: LD_VAR 0 4
111556: PUSH
111557: LD_VAR 0 7
111561: ARRAY
111562: PPUSH
111563: LD_VAR 0 10
111567: PPUSH
111568: CALL_OW 115
111572: GO 111598
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
111574: LD_VAR 0 4
111578: PUSH
111579: LD_VAR 0 7
111583: ARRAY
111584: PPUSH
111585: LD_VAR 0 14
111589: PUSH
111590: LD_INT 1
111592: ARRAY
111593: PPUSH
111594: CALL_OW 115
// if not HasTask ( group [ i ] ) then
111598: LD_VAR 0 4
111602: PUSH
111603: LD_VAR 0 7
111607: ARRAY
111608: PPUSH
111609: CALL_OW 314
111613: NOT
111614: IFFALSE 111652
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
111616: LD_VAR 0 4
111620: PUSH
111621: LD_VAR 0 7
111625: ARRAY
111626: PPUSH
111627: LD_VAR 0 14
111631: PPUSH
111632: LD_VAR 0 4
111636: PUSH
111637: LD_VAR 0 7
111641: ARRAY
111642: PPUSH
111643: CALL_OW 74
111647: PPUSH
111648: CALL_OW 115
// end ; end ; end ;
111652: GO 107531
111654: POP
111655: POP
// wait ( 0 0$2 ) ;
111656: LD_INT 70
111658: PPUSH
111659: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
111663: LD_VAR 0 4
111667: NOT
111668: PUSH
111669: LD_VAR 0 4
111673: PUSH
111674: EMPTY
111675: EQUAL
111676: OR
111677: PUSH
111678: LD_INT 81
111680: PUSH
111681: LD_VAR 0 35
111685: PUSH
111686: EMPTY
111687: LIST
111688: LIST
111689: PPUSH
111690: CALL_OW 69
111694: NOT
111695: OR
111696: IFFALSE 107516
// end ;
111698: LD_VAR 0 2
111702: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
111703: LD_INT 0
111705: PPUSH
111706: PPUSH
111707: PPUSH
111708: PPUSH
111709: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
111710: LD_VAR 0 1
111714: NOT
111715: PUSH
111716: LD_EXP 93
111720: PUSH
111721: LD_VAR 0 1
111725: ARRAY
111726: NOT
111727: OR
111728: PUSH
111729: LD_VAR 0 2
111733: NOT
111734: OR
111735: PUSH
111736: LD_VAR 0 3
111740: NOT
111741: OR
111742: IFFALSE 111746
// exit ;
111744: GO 112259
// side := mc_sides [ base ] ;
111746: LD_ADDR_VAR 0 6
111750: PUSH
111751: LD_EXP 119
111755: PUSH
111756: LD_VAR 0 1
111760: ARRAY
111761: ST_TO_ADDR
// if not side then
111762: LD_VAR 0 6
111766: NOT
111767: IFFALSE 111771
// exit ;
111769: GO 112259
// for i in solds do
111771: LD_ADDR_VAR 0 7
111775: PUSH
111776: LD_VAR 0 2
111780: PUSH
111781: FOR_IN
111782: IFFALSE 111843
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
111784: LD_VAR 0 7
111788: PPUSH
111789: CALL_OW 310
111793: PPUSH
111794: CALL_OW 266
111798: PUSH
111799: LD_INT 32
111801: PUSH
111802: LD_INT 31
111804: PUSH
111805: EMPTY
111806: LIST
111807: LIST
111808: IN
111809: IFFALSE 111829
// solds := solds diff i else
111811: LD_ADDR_VAR 0 2
111815: PUSH
111816: LD_VAR 0 2
111820: PUSH
111821: LD_VAR 0 7
111825: DIFF
111826: ST_TO_ADDR
111827: GO 111841
// SetTag ( i , 18 ) ;
111829: LD_VAR 0 7
111833: PPUSH
111834: LD_INT 18
111836: PPUSH
111837: CALL_OW 109
111841: GO 111781
111843: POP
111844: POP
// if not solds then
111845: LD_VAR 0 2
111849: NOT
111850: IFFALSE 111854
// exit ;
111852: GO 112259
// repeat wait ( 0 0$2 ) ;
111854: LD_INT 70
111856: PPUSH
111857: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
111861: LD_ADDR_VAR 0 5
111865: PUSH
111866: LD_VAR 0 6
111870: PPUSH
111871: LD_VAR 0 3
111875: PPUSH
111876: CALL 52963 0 2
111880: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
111881: LD_EXP 93
111885: PUSH
111886: LD_VAR 0 1
111890: ARRAY
111891: NOT
111892: PUSH
111893: LD_EXP 93
111897: PUSH
111898: LD_VAR 0 1
111902: ARRAY
111903: PUSH
111904: EMPTY
111905: EQUAL
111906: OR
111907: IFFALSE 111944
// begin for i in solds do
111909: LD_ADDR_VAR 0 7
111913: PUSH
111914: LD_VAR 0 2
111918: PUSH
111919: FOR_IN
111920: IFFALSE 111933
// ComStop ( i ) ;
111922: LD_VAR 0 7
111926: PPUSH
111927: CALL_OW 141
111931: GO 111919
111933: POP
111934: POP
// solds := [ ] ;
111935: LD_ADDR_VAR 0 2
111939: PUSH
111940: EMPTY
111941: ST_TO_ADDR
// exit ;
111942: GO 112259
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
111944: LD_VAR 0 5
111948: NOT
111949: PUSH
111950: LD_VAR 0 5
111954: PUSH
111955: LD_INT 3
111957: GREATER
111958: OR
111959: PUSH
111960: LD_EXP 115
111964: PUSH
111965: LD_VAR 0 1
111969: ARRAY
111970: OR
111971: IFFALSE 112012
// begin for i in solds do
111973: LD_ADDR_VAR 0 7
111977: PUSH
111978: LD_VAR 0 2
111982: PUSH
111983: FOR_IN
111984: IFFALSE 112008
// if HasTask ( i ) then
111986: LD_VAR 0 7
111990: PPUSH
111991: CALL_OW 314
111995: IFFALSE 112006
// ComStop ( i ) ;
111997: LD_VAR 0 7
112001: PPUSH
112002: CALL_OW 141
112006: GO 111983
112008: POP
112009: POP
// break ;
112010: GO 112247
// end ; for i in solds do
112012: LD_ADDR_VAR 0 7
112016: PUSH
112017: LD_VAR 0 2
112021: PUSH
112022: FOR_IN
112023: IFFALSE 112239
// begin if IsInUnit ( i ) then
112025: LD_VAR 0 7
112029: PPUSH
112030: CALL_OW 310
112034: IFFALSE 112045
// ComExitBuilding ( i ) ;
112036: LD_VAR 0 7
112040: PPUSH
112041: CALL_OW 122
// if GetLives ( i ) > 333 then
112045: LD_VAR 0 7
112049: PPUSH
112050: CALL_OW 256
112054: PUSH
112055: LD_INT 333
112057: GREATER
112058: IFFALSE 112086
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
112060: LD_VAR 0 7
112064: PPUSH
112065: LD_VAR 0 5
112069: PPUSH
112070: LD_VAR 0 7
112074: PPUSH
112075: CALL_OW 74
112079: PPUSH
112080: CALL_OW 115
112084: GO 112237
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
112086: LD_ADDR_VAR 0 8
112090: PUSH
112091: LD_EXP 93
112095: PUSH
112096: LD_VAR 0 1
112100: ARRAY
112101: PPUSH
112102: LD_INT 2
112104: PUSH
112105: LD_INT 30
112107: PUSH
112108: LD_INT 0
112110: PUSH
112111: EMPTY
112112: LIST
112113: LIST
112114: PUSH
112115: LD_INT 30
112117: PUSH
112118: LD_INT 1
112120: PUSH
112121: EMPTY
112122: LIST
112123: LIST
112124: PUSH
112125: LD_INT 30
112127: PUSH
112128: LD_INT 6
112130: PUSH
112131: EMPTY
112132: LIST
112133: LIST
112134: PUSH
112135: EMPTY
112136: LIST
112137: LIST
112138: LIST
112139: LIST
112140: PPUSH
112141: CALL_OW 72
112145: PPUSH
112146: LD_VAR 0 7
112150: PPUSH
112151: CALL_OW 74
112155: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
112156: LD_VAR 0 7
112160: PPUSH
112161: LD_VAR 0 8
112165: PPUSH
112166: CALL_OW 250
112170: PPUSH
112171: LD_INT 3
112173: PPUSH
112174: LD_INT 5
112176: PPUSH
112177: CALL_OW 272
112181: PPUSH
112182: LD_VAR 0 8
112186: PPUSH
112187: CALL_OW 251
112191: PPUSH
112192: LD_INT 3
112194: PPUSH
112195: LD_INT 5
112197: PPUSH
112198: CALL_OW 273
112202: PPUSH
112203: CALL_OW 111
// SetTag ( i , 0 ) ;
112207: LD_VAR 0 7
112211: PPUSH
112212: LD_INT 0
112214: PPUSH
112215: CALL_OW 109
// solds := solds diff i ;
112219: LD_ADDR_VAR 0 2
112223: PUSH
112224: LD_VAR 0 2
112228: PUSH
112229: LD_VAR 0 7
112233: DIFF
112234: ST_TO_ADDR
// continue ;
112235: GO 112022
// end ; end ;
112237: GO 112022
112239: POP
112240: POP
// until solds ;
112241: LD_VAR 0 2
112245: IFFALSE 111854
// MC_Reset ( base , 18 ) ;
112247: LD_VAR 0 1
112251: PPUSH
112252: LD_INT 18
112254: PPUSH
112255: CALL 24956 0 2
// end ;
112259: LD_VAR 0 4
112263: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class ; begin
112264: LD_INT 0
112266: PPUSH
112267: PPUSH
112268: PPUSH
112269: PPUSH
112270: PPUSH
112271: PPUSH
112272: PPUSH
112273: PPUSH
112274: PPUSH
112275: PPUSH
112276: PPUSH
112277: PPUSH
112278: PPUSH
112279: PPUSH
112280: PPUSH
112281: PPUSH
112282: PPUSH
112283: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
112284: LD_ADDR_VAR 0 13
112288: PUSH
112289: LD_EXP 93
112293: PUSH
112294: LD_VAR 0 1
112298: ARRAY
112299: PPUSH
112300: LD_INT 25
112302: PUSH
112303: LD_INT 3
112305: PUSH
112306: EMPTY
112307: LIST
112308: LIST
112309: PPUSH
112310: CALL_OW 72
112314: ST_TO_ADDR
// if mc_remote_driver [ base ] then
112315: LD_EXP 133
112319: PUSH
112320: LD_VAR 0 1
112324: ARRAY
112325: IFFALSE 112349
// mechs := mechs diff mc_remote_driver [ base ] ;
112327: LD_ADDR_VAR 0 13
112331: PUSH
112332: LD_VAR 0 13
112336: PUSH
112337: LD_EXP 133
112341: PUSH
112342: LD_VAR 0 1
112346: ARRAY
112347: DIFF
112348: ST_TO_ADDR
// for i in mechs do
112349: LD_ADDR_VAR 0 5
112353: PUSH
112354: LD_VAR 0 13
112358: PUSH
112359: FOR_IN
112360: IFFALSE 112395
// if GetTag ( i ) > 0 then
112362: LD_VAR 0 5
112366: PPUSH
112367: CALL_OW 110
112371: PUSH
112372: LD_INT 0
112374: GREATER
112375: IFFALSE 112393
// mechs := mechs diff i ;
112377: LD_ADDR_VAR 0 13
112381: PUSH
112382: LD_VAR 0 13
112386: PUSH
112387: LD_VAR 0 5
112391: DIFF
112392: ST_TO_ADDR
112393: GO 112359
112395: POP
112396: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
112397: LD_ADDR_VAR 0 9
112401: PUSH
112402: LD_EXP 93
112406: PUSH
112407: LD_VAR 0 1
112411: ARRAY
112412: PPUSH
112413: LD_INT 2
112415: PUSH
112416: LD_INT 25
112418: PUSH
112419: LD_INT 1
112421: PUSH
112422: EMPTY
112423: LIST
112424: LIST
112425: PUSH
112426: LD_INT 25
112428: PUSH
112429: LD_INT 5
112431: PUSH
112432: EMPTY
112433: LIST
112434: LIST
112435: PUSH
112436: LD_INT 25
112438: PUSH
112439: LD_INT 8
112441: PUSH
112442: EMPTY
112443: LIST
112444: LIST
112445: PUSH
112446: LD_INT 25
112448: PUSH
112449: LD_INT 9
112451: PUSH
112452: EMPTY
112453: LIST
112454: LIST
112455: PUSH
112456: EMPTY
112457: LIST
112458: LIST
112459: LIST
112460: LIST
112461: LIST
112462: PPUSH
112463: CALL_OW 72
112467: ST_TO_ADDR
// if not defenders and not solds then
112468: LD_VAR 0 2
112472: NOT
112473: PUSH
112474: LD_VAR 0 9
112478: NOT
112479: AND
112480: IFFALSE 112484
// exit ;
112482: GO 114254
// depot_under_attack := false ;
112484: LD_ADDR_VAR 0 17
112488: PUSH
112489: LD_INT 0
112491: ST_TO_ADDR
// sold_defenders := [ ] ;
112492: LD_ADDR_VAR 0 18
112496: PUSH
112497: EMPTY
112498: ST_TO_ADDR
// if mechs then
112499: LD_VAR 0 13
112503: IFFALSE 112656
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
112505: LD_ADDR_VAR 0 5
112509: PUSH
112510: LD_VAR 0 2
112514: PPUSH
112515: LD_INT 21
112517: PUSH
112518: LD_INT 2
112520: PUSH
112521: EMPTY
112522: LIST
112523: LIST
112524: PPUSH
112525: CALL_OW 72
112529: PUSH
112530: FOR_IN
112531: IFFALSE 112654
// begin if GetTag ( i ) <> 20 then
112533: LD_VAR 0 5
112537: PPUSH
112538: CALL_OW 110
112542: PUSH
112543: LD_INT 20
112545: NONEQUAL
112546: IFFALSE 112560
// SetTag ( i , 20 ) ;
112548: LD_VAR 0 5
112552: PPUSH
112553: LD_INT 20
112555: PPUSH
112556: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
112560: LD_VAR 0 5
112564: PPUSH
112565: CALL_OW 263
112569: PUSH
112570: LD_INT 1
112572: EQUAL
112573: PUSH
112574: LD_VAR 0 5
112578: PPUSH
112579: CALL_OW 311
112583: NOT
112584: AND
112585: IFFALSE 112652
// begin un := mechs [ 1 ] ;
112587: LD_ADDR_VAR 0 11
112591: PUSH
112592: LD_VAR 0 13
112596: PUSH
112597: LD_INT 1
112599: ARRAY
112600: ST_TO_ADDR
// ComExit ( un ) ;
112601: LD_VAR 0 11
112605: PPUSH
112606: CALL 88338 0 1
// AddComEnterUnit ( un , i ) ;
112610: LD_VAR 0 11
112614: PPUSH
112615: LD_VAR 0 5
112619: PPUSH
112620: CALL_OW 180
// SetTag ( un , 19 ) ;
112624: LD_VAR 0 11
112628: PPUSH
112629: LD_INT 19
112631: PPUSH
112632: CALL_OW 109
// mechs := mechs diff un ;
112636: LD_ADDR_VAR 0 13
112640: PUSH
112641: LD_VAR 0 13
112645: PUSH
112646: LD_VAR 0 11
112650: DIFF
112651: ST_TO_ADDR
// end ; end ;
112652: GO 112530
112654: POP
112655: POP
// if solds then
112656: LD_VAR 0 9
112660: IFFALSE 112719
// for i in solds do
112662: LD_ADDR_VAR 0 5
112666: PUSH
112667: LD_VAR 0 9
112671: PUSH
112672: FOR_IN
112673: IFFALSE 112717
// if not GetTag ( i ) then
112675: LD_VAR 0 5
112679: PPUSH
112680: CALL_OW 110
112684: NOT
112685: IFFALSE 112715
// begin defenders := defenders union i ;
112687: LD_ADDR_VAR 0 2
112691: PUSH
112692: LD_VAR 0 2
112696: PUSH
112697: LD_VAR 0 5
112701: UNION
112702: ST_TO_ADDR
// SetTag ( i , 18 ) ;
112703: LD_VAR 0 5
112707: PPUSH
112708: LD_INT 18
112710: PPUSH
112711: CALL_OW 109
// end ;
112715: GO 112672
112717: POP
112718: POP
// repeat wait ( 0 0$2 ) ;
112719: LD_INT 70
112721: PPUSH
112722: CALL_OW 67
// enemy := mc_scan [ base ] ;
112726: LD_ADDR_VAR 0 3
112730: PUSH
112731: LD_EXP 116
112735: PUSH
112736: LD_VAR 0 1
112740: ARRAY
112741: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
112742: LD_EXP 93
112746: PUSH
112747: LD_VAR 0 1
112751: ARRAY
112752: NOT
112753: PUSH
112754: LD_EXP 93
112758: PUSH
112759: LD_VAR 0 1
112763: ARRAY
112764: PUSH
112765: EMPTY
112766: EQUAL
112767: OR
112768: IFFALSE 112805
// begin for i in defenders do
112770: LD_ADDR_VAR 0 5
112774: PUSH
112775: LD_VAR 0 2
112779: PUSH
112780: FOR_IN
112781: IFFALSE 112794
// ComStop ( i ) ;
112783: LD_VAR 0 5
112787: PPUSH
112788: CALL_OW 141
112792: GO 112780
112794: POP
112795: POP
// defenders := [ ] ;
112796: LD_ADDR_VAR 0 2
112800: PUSH
112801: EMPTY
112802: ST_TO_ADDR
// exit ;
112803: GO 114254
// end ; for i in defenders do
112805: LD_ADDR_VAR 0 5
112809: PUSH
112810: LD_VAR 0 2
112814: PUSH
112815: FOR_IN
112816: IFFALSE 113714
// begin e := NearestUnitToUnit ( enemy , i ) ;
112818: LD_ADDR_VAR 0 14
112822: PUSH
112823: LD_VAR 0 3
112827: PPUSH
112828: LD_VAR 0 5
112832: PPUSH
112833: CALL_OW 74
112837: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
112838: LD_ADDR_VAR 0 8
112842: PUSH
112843: LD_EXP 93
112847: PUSH
112848: LD_VAR 0 1
112852: ARRAY
112853: PPUSH
112854: LD_INT 2
112856: PUSH
112857: LD_INT 30
112859: PUSH
112860: LD_INT 0
112862: PUSH
112863: EMPTY
112864: LIST
112865: LIST
112866: PUSH
112867: LD_INT 30
112869: PUSH
112870: LD_INT 1
112872: PUSH
112873: EMPTY
112874: LIST
112875: LIST
112876: PUSH
112877: EMPTY
112878: LIST
112879: LIST
112880: LIST
112881: PPUSH
112882: CALL_OW 72
112886: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
112887: LD_ADDR_VAR 0 17
112891: PUSH
112892: LD_VAR 0 8
112896: NOT
112897: PUSH
112898: LD_VAR 0 8
112902: PPUSH
112903: LD_INT 3
112905: PUSH
112906: LD_INT 24
112908: PUSH
112909: LD_INT 600
112911: PUSH
112912: EMPTY
112913: LIST
112914: LIST
112915: PUSH
112916: EMPTY
112917: LIST
112918: LIST
112919: PPUSH
112920: CALL_OW 72
112924: OR
112925: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
112926: LD_VAR 0 5
112930: PPUSH
112931: CALL_OW 247
112935: PUSH
112936: LD_INT 2
112938: DOUBLE
112939: EQUAL
112940: IFTRUE 112944
112942: GO 113340
112944: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
112945: LD_VAR 0 5
112949: PPUSH
112950: CALL_OW 256
112954: PUSH
112955: LD_INT 1000
112957: EQUAL
112958: PUSH
112959: LD_VAR 0 5
112963: PPUSH
112964: LD_VAR 0 14
112968: PPUSH
112969: CALL_OW 296
112973: PUSH
112974: LD_INT 40
112976: LESS
112977: PUSH
112978: LD_VAR 0 14
112982: PPUSH
112983: LD_EXP 118
112987: PUSH
112988: LD_VAR 0 1
112992: ARRAY
112993: PPUSH
112994: CALL_OW 308
112998: OR
112999: AND
113000: IFFALSE 113122
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
113002: LD_VAR 0 5
113006: PPUSH
113007: CALL_OW 262
113011: PUSH
113012: LD_INT 1
113014: EQUAL
113015: PUSH
113016: LD_VAR 0 5
113020: PPUSH
113021: CALL_OW 261
113025: PUSH
113026: LD_INT 30
113028: LESS
113029: AND
113030: PUSH
113031: LD_VAR 0 8
113035: AND
113036: IFFALSE 113106
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
113038: LD_VAR 0 5
113042: PPUSH
113043: LD_VAR 0 8
113047: PPUSH
113048: LD_VAR 0 5
113052: PPUSH
113053: CALL_OW 74
113057: PPUSH
113058: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
113062: LD_VAR 0 5
113066: PPUSH
113067: LD_VAR 0 8
113071: PPUSH
113072: LD_VAR 0 5
113076: PPUSH
113077: CALL_OW 74
113081: PPUSH
113082: CALL_OW 296
113086: PUSH
113087: LD_INT 6
113089: LESS
113090: IFFALSE 113104
// SetFuel ( i , 100 ) ;
113092: LD_VAR 0 5
113096: PPUSH
113097: LD_INT 100
113099: PPUSH
113100: CALL_OW 240
// end else
113104: GO 113120
// ComAttackUnit ( i , e ) ;
113106: LD_VAR 0 5
113110: PPUSH
113111: LD_VAR 0 14
113115: PPUSH
113116: CALL_OW 115
// end else
113120: GO 113223
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
113122: LD_VAR 0 14
113126: PPUSH
113127: LD_EXP 118
113131: PUSH
113132: LD_VAR 0 1
113136: ARRAY
113137: PPUSH
113138: CALL_OW 308
113142: NOT
113143: PUSH
113144: LD_VAR 0 5
113148: PPUSH
113149: LD_VAR 0 14
113153: PPUSH
113154: CALL_OW 296
113158: PUSH
113159: LD_INT 40
113161: GREATEREQUAL
113162: AND
113163: PUSH
113164: LD_VAR 0 5
113168: PPUSH
113169: CALL_OW 256
113173: PUSH
113174: LD_INT 650
113176: LESSEQUAL
113177: OR
113178: PUSH
113179: LD_VAR 0 5
113183: PPUSH
113184: LD_EXP 117
113188: PUSH
113189: LD_VAR 0 1
113193: ARRAY
113194: PPUSH
113195: CALL_OW 308
113199: NOT
113200: AND
113201: IFFALSE 113223
// ComMoveToArea ( i , mc_parking [ base ] ) ;
113203: LD_VAR 0 5
113207: PPUSH
113208: LD_EXP 117
113212: PUSH
113213: LD_VAR 0 1
113217: ARRAY
113218: PPUSH
113219: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
113223: LD_VAR 0 5
113227: PPUSH
113228: CALL_OW 256
113232: PUSH
113233: LD_INT 1000
113235: LESS
113236: PUSH
113237: LD_VAR 0 5
113241: PPUSH
113242: CALL_OW 263
113246: PUSH
113247: LD_INT 1
113249: EQUAL
113250: AND
113251: PUSH
113252: LD_VAR 0 5
113256: PPUSH
113257: CALL_OW 311
113261: AND
113262: PUSH
113263: LD_VAR 0 5
113267: PPUSH
113268: LD_EXP 117
113272: PUSH
113273: LD_VAR 0 1
113277: ARRAY
113278: PPUSH
113279: CALL_OW 308
113283: AND
113284: IFFALSE 113338
// begin mech := IsDrivenBy ( i ) ;
113286: LD_ADDR_VAR 0 10
113290: PUSH
113291: LD_VAR 0 5
113295: PPUSH
113296: CALL_OW 311
113300: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
113301: LD_VAR 0 10
113305: PPUSH
113306: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
113310: LD_VAR 0 10
113314: PPUSH
113315: LD_VAR 0 5
113319: PPUSH
113320: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
113324: LD_VAR 0 10
113328: PPUSH
113329: LD_VAR 0 5
113333: PPUSH
113334: CALL_OW 180
// end ; end ; unit_human :
113338: GO 113685
113340: LD_INT 1
113342: DOUBLE
113343: EQUAL
113344: IFTRUE 113348
113346: GO 113684
113348: POP
// begin b := IsInUnit ( i ) ;
113349: LD_ADDR_VAR 0 19
113353: PUSH
113354: LD_VAR 0 5
113358: PPUSH
113359: CALL_OW 310
113363: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
113364: LD_ADDR_VAR 0 20
113368: PUSH
113369: LD_VAR 0 19
113373: NOT
113374: PUSH
113375: LD_VAR 0 19
113379: PPUSH
113380: CALL_OW 266
113384: PUSH
113385: LD_INT 32
113387: PUSH
113388: LD_INT 31
113390: PUSH
113391: EMPTY
113392: LIST
113393: LIST
113394: IN
113395: OR
113396: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
113397: LD_VAR 0 19
113401: PPUSH
113402: CALL_OW 266
113406: PUSH
113407: LD_INT 5
113409: EQUAL
113410: PUSH
113411: LD_VAR 0 5
113415: PPUSH
113416: CALL_OW 257
113420: PUSH
113421: LD_INT 1
113423: PUSH
113424: LD_INT 2
113426: PUSH
113427: LD_INT 3
113429: PUSH
113430: LD_INT 4
113432: PUSH
113433: EMPTY
113434: LIST
113435: LIST
113436: LIST
113437: LIST
113438: IN
113439: AND
113440: IFFALSE 113477
// begin class := AllowSpecClass ( i ) ;
113442: LD_ADDR_VAR 0 21
113446: PUSH
113447: LD_VAR 0 5
113451: PPUSH
113452: CALL 52998 0 1
113456: ST_TO_ADDR
// if class then
113457: LD_VAR 0 21
113461: IFFALSE 113477
// ComChangeProfession ( i , class ) ;
113463: LD_VAR 0 5
113467: PPUSH
113468: LD_VAR 0 21
113472: PPUSH
113473: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
113477: LD_VAR 0 17
113481: PUSH
113482: LD_VAR 0 2
113486: PPUSH
113487: LD_INT 21
113489: PUSH
113490: LD_INT 2
113492: PUSH
113493: EMPTY
113494: LIST
113495: LIST
113496: PPUSH
113497: CALL_OW 72
113501: PUSH
113502: LD_INT 1
113504: LESSEQUAL
113505: OR
113506: PUSH
113507: LD_VAR 0 20
113511: AND
113512: PUSH
113513: LD_VAR 0 5
113517: PUSH
113518: LD_VAR 0 18
113522: IN
113523: NOT
113524: AND
113525: IFFALSE 113618
// begin if b then
113527: LD_VAR 0 19
113531: IFFALSE 113580
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
113533: LD_VAR 0 19
113537: PPUSH
113538: LD_VAR 0 3
113542: PPUSH
113543: LD_VAR 0 19
113547: PPUSH
113548: CALL_OW 74
113552: PPUSH
113553: CALL_OW 296
113557: PUSH
113558: LD_INT 10
113560: LESS
113561: PUSH
113562: LD_VAR 0 19
113566: PPUSH
113567: CALL_OW 461
113571: PUSH
113572: LD_INT 7
113574: NONEQUAL
113575: AND
113576: IFFALSE 113580
// continue ;
113578: GO 112815
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
113580: LD_ADDR_VAR 0 18
113584: PUSH
113585: LD_VAR 0 18
113589: PPUSH
113590: LD_VAR 0 18
113594: PUSH
113595: LD_INT 1
113597: PLUS
113598: PPUSH
113599: LD_VAR 0 5
113603: PPUSH
113604: CALL_OW 1
113608: ST_TO_ADDR
// ComExitBuilding ( i ) ;
113609: LD_VAR 0 5
113613: PPUSH
113614: CALL_OW 122
// end ; if sold_defenders then
113618: LD_VAR 0 18
113622: IFFALSE 113682
// if i in sold_defenders then
113624: LD_VAR 0 5
113628: PUSH
113629: LD_VAR 0 18
113633: IN
113634: IFFALSE 113682
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
113636: LD_VAR 0 5
113640: PPUSH
113641: CALL_OW 314
113645: NOT
113646: PUSH
113647: LD_VAR 0 5
113651: PPUSH
113652: LD_VAR 0 14
113656: PPUSH
113657: CALL_OW 296
113661: PUSH
113662: LD_INT 30
113664: LESS
113665: AND
113666: IFFALSE 113682
// ComAttackUnit ( i , e ) ;
113668: LD_VAR 0 5
113672: PPUSH
113673: LD_VAR 0 14
113677: PPUSH
113678: CALL_OW 115
// end ; end ; end ;
113682: GO 113685
113684: POP
// if IsDead ( i ) then
113685: LD_VAR 0 5
113689: PPUSH
113690: CALL_OW 301
113694: IFFALSE 113712
// defenders := defenders diff i ;
113696: LD_ADDR_VAR 0 2
113700: PUSH
113701: LD_VAR 0 2
113705: PUSH
113706: LD_VAR 0 5
113710: DIFF
113711: ST_TO_ADDR
// end ;
113712: GO 112815
113714: POP
113715: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
113716: LD_VAR 0 3
113720: NOT
113721: PUSH
113722: LD_VAR 0 2
113726: NOT
113727: OR
113728: PUSH
113729: LD_EXP 93
113733: PUSH
113734: LD_VAR 0 1
113738: ARRAY
113739: NOT
113740: OR
113741: IFFALSE 112719
// MC_Reset ( base , 18 ) ;
113743: LD_VAR 0 1
113747: PPUSH
113748: LD_INT 18
113750: PPUSH
113751: CALL 24956 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
113755: LD_ADDR_VAR 0 2
113759: PUSH
113760: LD_VAR 0 2
113764: PUSH
113765: LD_VAR 0 2
113769: PPUSH
113770: LD_INT 2
113772: PUSH
113773: LD_INT 25
113775: PUSH
113776: LD_INT 1
113778: PUSH
113779: EMPTY
113780: LIST
113781: LIST
113782: PUSH
113783: LD_INT 25
113785: PUSH
113786: LD_INT 5
113788: PUSH
113789: EMPTY
113790: LIST
113791: LIST
113792: PUSH
113793: LD_INT 25
113795: PUSH
113796: LD_INT 8
113798: PUSH
113799: EMPTY
113800: LIST
113801: LIST
113802: PUSH
113803: LD_INT 25
113805: PUSH
113806: LD_INT 9
113808: PUSH
113809: EMPTY
113810: LIST
113811: LIST
113812: PUSH
113813: EMPTY
113814: LIST
113815: LIST
113816: LIST
113817: LIST
113818: LIST
113819: PPUSH
113820: CALL_OW 72
113824: DIFF
113825: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
113826: LD_VAR 0 3
113830: NOT
113831: PUSH
113832: LD_VAR 0 2
113836: PPUSH
113837: LD_INT 21
113839: PUSH
113840: LD_INT 2
113842: PUSH
113843: EMPTY
113844: LIST
113845: LIST
113846: PPUSH
113847: CALL_OW 72
113851: AND
113852: IFFALSE 114190
// begin tmp := FilterByTag ( defenders , 19 ) ;
113854: LD_ADDR_VAR 0 12
113858: PUSH
113859: LD_VAR 0 2
113863: PPUSH
113864: LD_INT 19
113866: PPUSH
113867: CALL 85468 0 2
113871: ST_TO_ADDR
// if tmp then
113872: LD_VAR 0 12
113876: IFFALSE 113946
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
113878: LD_ADDR_VAR 0 12
113882: PUSH
113883: LD_VAR 0 12
113887: PPUSH
113888: LD_INT 25
113890: PUSH
113891: LD_INT 3
113893: PUSH
113894: EMPTY
113895: LIST
113896: LIST
113897: PPUSH
113898: CALL_OW 72
113902: ST_TO_ADDR
// if tmp then
113903: LD_VAR 0 12
113907: IFFALSE 113946
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
113909: LD_ADDR_EXP 105
113913: PUSH
113914: LD_EXP 105
113918: PPUSH
113919: LD_VAR 0 1
113923: PPUSH
113924: LD_EXP 105
113928: PUSH
113929: LD_VAR 0 1
113933: ARRAY
113934: PUSH
113935: LD_VAR 0 12
113939: UNION
113940: PPUSH
113941: CALL_OW 1
113945: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
113946: LD_VAR 0 1
113950: PPUSH
113951: LD_INT 19
113953: PPUSH
113954: CALL 24956 0 2
// repeat wait ( 0 0$1 ) ;
113958: LD_INT 35
113960: PPUSH
113961: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
113965: LD_EXP 93
113969: PUSH
113970: LD_VAR 0 1
113974: ARRAY
113975: NOT
113976: PUSH
113977: LD_EXP 93
113981: PUSH
113982: LD_VAR 0 1
113986: ARRAY
113987: PUSH
113988: EMPTY
113989: EQUAL
113990: OR
113991: IFFALSE 114028
// begin for i in defenders do
113993: LD_ADDR_VAR 0 5
113997: PUSH
113998: LD_VAR 0 2
114002: PUSH
114003: FOR_IN
114004: IFFALSE 114017
// ComStop ( i ) ;
114006: LD_VAR 0 5
114010: PPUSH
114011: CALL_OW 141
114015: GO 114003
114017: POP
114018: POP
// defenders := [ ] ;
114019: LD_ADDR_VAR 0 2
114023: PUSH
114024: EMPTY
114025: ST_TO_ADDR
// exit ;
114026: GO 114254
// end ; for i in defenders do
114028: LD_ADDR_VAR 0 5
114032: PUSH
114033: LD_VAR 0 2
114037: PUSH
114038: FOR_IN
114039: IFFALSE 114128
// begin if not IsInArea ( i , mc_parking [ base ] ) then
114041: LD_VAR 0 5
114045: PPUSH
114046: LD_EXP 117
114050: PUSH
114051: LD_VAR 0 1
114055: ARRAY
114056: PPUSH
114057: CALL_OW 308
114061: NOT
114062: IFFALSE 114086
// ComMoveToArea ( i , mc_parking [ base ] ) else
114064: LD_VAR 0 5
114068: PPUSH
114069: LD_EXP 117
114073: PUSH
114074: LD_VAR 0 1
114078: ARRAY
114079: PPUSH
114080: CALL_OW 113
114084: GO 114126
// if GetControl ( i ) = control_manual then
114086: LD_VAR 0 5
114090: PPUSH
114091: CALL_OW 263
114095: PUSH
114096: LD_INT 1
114098: EQUAL
114099: IFFALSE 114126
// if IsDrivenBy ( i ) then
114101: LD_VAR 0 5
114105: PPUSH
114106: CALL_OW 311
114110: IFFALSE 114126
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
114112: LD_VAR 0 5
114116: PPUSH
114117: CALL_OW 311
114121: PPUSH
114122: CALL_OW 121
// end ;
114126: GO 114038
114128: POP
114129: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
114130: LD_VAR 0 2
114134: PPUSH
114135: LD_INT 95
114137: PUSH
114138: LD_EXP 117
114142: PUSH
114143: LD_VAR 0 1
114147: ARRAY
114148: PUSH
114149: EMPTY
114150: LIST
114151: LIST
114152: PPUSH
114153: CALL_OW 72
114157: PUSH
114158: LD_VAR 0 2
114162: EQUAL
114163: PUSH
114164: LD_EXP 116
114168: PUSH
114169: LD_VAR 0 1
114173: ARRAY
114174: OR
114175: PUSH
114176: LD_EXP 93
114180: PUSH
114181: LD_VAR 0 1
114185: ARRAY
114186: NOT
114187: OR
114188: IFFALSE 113958
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
114190: LD_ADDR_EXP 115
114194: PUSH
114195: LD_EXP 115
114199: PPUSH
114200: LD_VAR 0 1
114204: PPUSH
114205: LD_VAR 0 2
114209: PPUSH
114210: LD_INT 21
114212: PUSH
114213: LD_INT 2
114215: PUSH
114216: EMPTY
114217: LIST
114218: LIST
114219: PPUSH
114220: CALL_OW 72
114224: PPUSH
114225: CALL_OW 1
114229: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
114230: LD_VAR 0 1
114234: PPUSH
114235: LD_INT 19
114237: PPUSH
114238: CALL 24956 0 2
// MC_Reset ( base , 20 ) ;
114242: LD_VAR 0 1
114246: PPUSH
114247: LD_INT 20
114249: PPUSH
114250: CALL 24956 0 2
// end ; end_of_file
114254: LD_VAR 0 4
114258: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
114259: LD_VAR 0 1
114263: PUSH
114264: LD_INT 200
114266: DOUBLE
114267: GREATEREQUAL
114268: IFFALSE 114276
114270: LD_INT 299
114272: DOUBLE
114273: LESSEQUAL
114274: IFTRUE 114278
114276: GO 114310
114278: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
114279: LD_VAR 0 1
114283: PPUSH
114284: LD_VAR 0 2
114288: PPUSH
114289: LD_VAR 0 3
114293: PPUSH
114294: LD_VAR 0 4
114298: PPUSH
114299: LD_VAR 0 5
114303: PPUSH
114304: CALL 103111 0 5
114308: GO 114387
114310: LD_INT 300
114312: DOUBLE
114313: GREATEREQUAL
114314: IFFALSE 114322
114316: LD_INT 399
114318: DOUBLE
114319: LESSEQUAL
114320: IFTRUE 114324
114322: GO 114386
114324: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
114325: LD_VAR 0 1
114329: PPUSH
114330: LD_VAR 0 2
114334: PPUSH
114335: LD_VAR 0 3
114339: PPUSH
114340: LD_VAR 0 4
114344: PPUSH
114345: LD_VAR 0 5
114349: PPUSH
114350: LD_VAR 0 6
114354: PPUSH
114355: LD_VAR 0 7
114359: PPUSH
114360: LD_VAR 0 8
114364: PPUSH
114365: LD_VAR 0 9
114369: PPUSH
114370: LD_VAR 0 10
114374: PPUSH
114375: LD_VAR 0 11
114379: PPUSH
114380: CALL 100999 0 11
114384: GO 114387
114386: POP
// end ;
114387: PPOPN 11
114389: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
114390: LD_VAR 0 1
114394: PPUSH
114395: LD_VAR 0 2
114399: PPUSH
114400: LD_VAR 0 3
114404: PPUSH
114405: LD_VAR 0 4
114409: PPUSH
114410: LD_VAR 0 5
114414: PPUSH
114415: CALL 103093 0 5
// end ; end_of_file
114419: PPOPN 5
114421: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
114422: LD_VAR 0 1
114426: PPUSH
114427: LD_VAR 0 2
114431: PPUSH
114432: LD_VAR 0 3
114436: PPUSH
114437: LD_VAR 0 4
114441: PPUSH
114442: LD_VAR 0 5
114446: PPUSH
114447: LD_VAR 0 6
114451: PPUSH
114452: CALL 89807 0 6
// end ;
114456: PPOPN 6
114458: END
