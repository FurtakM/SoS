// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitMacro ;
  15: CALL 20107 0 0
// InitNature ;
  19: CALL 16779 0 0
// InitArtifact ;
  23: CALL 17392 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAmerican ;
  40: CALL 4496 0 0
// PrepareAlliance ;
  44: CALL 1314 0 0
// PrepareArabian ;
  48: CALL 6205 0 0
// PrepareRussian ;
  52: CALL 8156 0 0
// PrepareLegion ;
  56: CALL 6599 0 0
// Action ;
  60: CALL 10659 0 0
// MC_Start ( ) ;
  64: CALL 22219 0 0
// end ;
  68: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  80: LD_ADDR_EXP 6
  84: PUSH
  85: LD_STRING 11_artifact_captured
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// russianDestroyed := false ;
  96: LD_ADDR_EXP 2
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// legionDestroyed := false ;
 104: LD_ADDR_EXP 3
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// americanDestroyed := false ;
 112: LD_ADDR_EXP 4
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// arabianDestroyed := false ;
 120: LD_ADDR_EXP 5
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// artifactIResearched := false ;
 128: LD_ADDR_EXP 9
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// artifactIIResearched := false ;
 136: LD_ADDR_EXP 10
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// artifactIIIResearched := false ;
 144: LD_ADDR_EXP 11
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// alienSpotted := false ;
 152: LD_ADDR_EXP 7
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// spawnOmar := false ;
 160: LD_ADDR_EXP 8
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// end ;
 168: LD_VAR 0 1
 172: RET
// export function CustomInitMacro ( ) ; begin
 173: LD_INT 0
 175: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 176: LD_ADDR_EXP 98
 180: PUSH
 181: LD_INT 26
 183: PUSH
 184: LD_INT 1
 186: PUSH
 187: LD_INT 4
 189: PUSH
 190: LD_INT 8
 192: PUSH
 193: EMPTY
 194: LIST
 195: LIST
 196: LIST
 197: LIST
 198: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 199: LD_ADDR_EXP 99
 203: PUSH
 204: LD_INT 27
 206: PUSH
 207: LD_INT 2
 209: PUSH
 210: LD_INT 3
 212: PUSH
 213: LD_INT 7
 215: PUSH
 216: EMPTY
 217: LIST
 218: LIST
 219: LIST
 220: LIST
 221: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 ] [ Difficulty ] , arabianMinefield ) ;
 222: LD_INT 1
 224: PPUSH
 225: LD_INT 6
 227: PUSH
 228: LD_INT 7
 230: PUSH
 231: LD_INT 9
 233: PUSH
 234: EMPTY
 235: LIST
 236: LIST
 237: LIST
 238: PUSH
 239: LD_OWVAR 67
 243: ARRAY
 244: PPUSH
 245: LD_INT 28
 247: PPUSH
 248: CALL 43540 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 252: LD_INT 1
 254: PPUSH
 255: LD_INT 10
 257: PUSH
 258: LD_INT 11
 260: PUSH
 261: LD_INT 13
 263: PUSH
 264: LD_INT 15
 266: PUSH
 267: EMPTY
 268: LIST
 269: LIST
 270: LIST
 271: LIST
 272: PPUSH
 273: CALL 44600 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 277: LD_INT 1
 279: PPUSH
 280: LD_INT 29
 282: PUSH
 283: EMPTY
 284: LIST
 285: PPUSH
 286: CALL 44693 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 290: LD_ADDR_EXP 103
 294: PUSH
 295: LD_EXP 103
 299: PPUSH
 300: LD_INT 1
 302: PPUSH
 303: LD_INT 22
 305: PUSH
 306: LD_INT 2
 308: PUSH
 309: EMPTY
 310: LIST
 311: LIST
 312: PUSH
 313: LD_INT 25
 315: PUSH
 316: LD_INT 15
 318: PUSH
 319: EMPTY
 320: LIST
 321: LIST
 322: PUSH
 323: EMPTY
 324: LIST
 325: LIST
 326: PPUSH
 327: CALL_OW 69
 331: PPUSH
 332: CALL_OW 1
 336: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 337: LD_INT 1
 339: PPUSH
 340: LD_INT 13
 342: PUSH
 343: LD_INT 2
 345: PUSH
 346: LD_INT 1
 348: PUSH
 349: LD_INT 31
 351: PUSH
 352: EMPTY
 353: LIST
 354: LIST
 355: LIST
 356: LIST
 357: PUSH
 358: LD_INT 13
 360: PUSH
 361: LD_INT 2
 363: PUSH
 364: LD_INT 1
 366: PUSH
 367: LD_INT 31
 369: PUSH
 370: EMPTY
 371: LIST
 372: LIST
 373: LIST
 374: LIST
 375: PUSH
 376: LD_INT 13
 378: PUSH
 379: LD_INT 1
 381: PUSH
 382: LD_INT 1
 384: PUSH
 385: LD_INT 28
 387: PUSH
 388: EMPTY
 389: LIST
 390: LIST
 391: LIST
 392: LIST
 393: PUSH
 394: LD_INT 13
 396: PUSH
 397: LD_INT 1
 399: PUSH
 400: LD_INT 1
 402: PUSH
 403: LD_INT 28
 405: PUSH
 406: EMPTY
 407: LIST
 408: LIST
 409: LIST
 410: LIST
 411: PUSH
 412: LD_INT 13
 414: PUSH
 415: LD_INT 1
 417: PUSH
 418: LD_INT 1
 420: PUSH
 421: LD_INT 28
 423: PUSH
 424: EMPTY
 425: LIST
 426: LIST
 427: LIST
 428: LIST
 429: PUSH
 430: LD_INT 13
 432: PUSH
 433: LD_INT 1
 435: PUSH
 436: LD_INT 1
 438: PUSH
 439: LD_INT 28
 441: PUSH
 442: EMPTY
 443: LIST
 444: LIST
 445: LIST
 446: LIST
 447: PUSH
 448: EMPTY
 449: LIST
 450: LIST
 451: LIST
 452: LIST
 453: LIST
 454: LIST
 455: PPUSH
 456: CALL 43858 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 460: LD_INT 1
 462: PPUSH
 463: LD_INT 4
 465: PPUSH
 466: CALL 44043 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 470: LD_INT 2
 472: PPUSH
 473: LD_INT 10
 475: PUSH
 476: LD_INT 11
 478: PUSH
 479: LD_INT 12
 481: PUSH
 482: LD_INT 14
 484: PUSH
 485: EMPTY
 486: LIST
 487: LIST
 488: LIST
 489: LIST
 490: PPUSH
 491: CALL 44600 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 495: LD_INT 2
 497: PPUSH
 498: LD_INT 14
 500: PUSH
 501: EMPTY
 502: LIST
 503: PPUSH
 504: CALL 44693 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 508: LD_INT 2
 510: PPUSH
 511: LD_INT 21
 513: PUSH
 514: LD_INT 3
 516: PUSH
 517: LD_INT 3
 519: PUSH
 520: LD_INT 51
 522: PUSH
 523: EMPTY
 524: LIST
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: LD_INT 22
 531: PUSH
 532: LD_INT 3
 534: PUSH
 535: LD_INT 3
 537: PUSH
 538: LD_INT 52
 540: PUSH
 541: EMPTY
 542: LIST
 543: LIST
 544: LIST
 545: LIST
 546: PUSH
 547: LD_INT 22
 549: PUSH
 550: LD_INT 3
 552: PUSH
 553: LD_INT 3
 555: PUSH
 556: LD_INT 52
 558: PUSH
 559: EMPTY
 560: LIST
 561: LIST
 562: LIST
 563: LIST
 564: PUSH
 565: LD_INT 24
 567: PUSH
 568: LD_INT 3
 570: PUSH
 571: LD_INT 3
 573: PUSH
 574: LD_INT 47
 576: PUSH
 577: EMPTY
 578: LIST
 579: LIST
 580: LIST
 581: LIST
 582: PUSH
 583: LD_INT 24
 585: PUSH
 586: LD_INT 3
 588: PUSH
 589: LD_INT 3
 591: PUSH
 592: LD_INT 47
 594: PUSH
 595: EMPTY
 596: LIST
 597: LIST
 598: LIST
 599: LIST
 600: PUSH
 601: LD_INT 24
 603: PUSH
 604: LD_INT 3
 606: PUSH
 607: LD_INT 3
 609: PUSH
 610: LD_INT 47
 612: PUSH
 613: EMPTY
 614: LIST
 615: LIST
 616: LIST
 617: LIST
 618: PUSH
 619: LD_INT 24
 621: PUSH
 622: LD_INT 3
 624: PUSH
 625: LD_INT 3
 627: PUSH
 628: LD_INT 47
 630: PUSH
 631: EMPTY
 632: LIST
 633: LIST
 634: LIST
 635: LIST
 636: PUSH
 637: LD_INT 24
 639: PUSH
 640: LD_INT 3
 642: PUSH
 643: LD_INT 3
 645: PUSH
 646: LD_INT 47
 648: PUSH
 649: EMPTY
 650: LIST
 651: LIST
 652: LIST
 653: LIST
 654: PUSH
 655: EMPTY
 656: LIST
 657: LIST
 658: LIST
 659: LIST
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: PPUSH
 665: CALL 43858 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 669: LD_INT 2
 671: PPUSH
 672: LD_INT 5
 674: PPUSH
 675: CALL 44043 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 679: LD_INT 2
 681: PPUSH
 682: LD_INT 0
 684: PPUSH
 685: CALL 44473 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 689: LD_INT 3
 691: PPUSH
 692: LD_INT 10
 694: PUSH
 695: LD_INT 12
 697: PUSH
 698: LD_INT 15
 700: PUSH
 701: EMPTY
 702: LIST
 703: LIST
 704: LIST
 705: PUSH
 706: LD_OWVAR 67
 710: ARRAY
 711: PPUSH
 712: LD_INT 24
 714: PPUSH
 715: CALL 43540 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 719: LD_INT 3
 721: PPUSH
 722: LD_INT 10
 724: PUSH
 725: LD_INT 11
 727: PUSH
 728: LD_INT 13
 730: PUSH
 731: LD_INT 15
 733: PUSH
 734: EMPTY
 735: LIST
 736: LIST
 737: LIST
 738: LIST
 739: PPUSH
 740: CALL 44600 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 744: LD_INT 3
 746: PPUSH
 747: LD_INT 13
 749: PUSH
 750: EMPTY
 751: LIST
 752: PPUSH
 753: CALL 44693 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 757: LD_ADDR_EXP 103
 761: PUSH
 762: LD_EXP 103
 766: PPUSH
 767: LD_INT 3
 769: PPUSH
 770: LD_INT 22
 772: PUSH
 773: LD_INT 8
 775: PUSH
 776: EMPTY
 777: LIST
 778: LIST
 779: PUSH
 780: LD_INT 25
 782: PUSH
 783: LD_INT 15
 785: PUSH
 786: EMPTY
 787: LIST
 788: LIST
 789: PUSH
 790: EMPTY
 791: LIST
 792: LIST
 793: PPUSH
 794: CALL_OW 69
 798: PPUSH
 799: CALL_OW 1
 803: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 804: LD_INT 3
 806: PPUSH
 807: LD_INT 13
 809: PUSH
 810: LD_INT 2
 812: PUSH
 813: LD_INT 1
 815: PUSH
 816: LD_INT 31
 818: PUSH
 819: EMPTY
 820: LIST
 821: LIST
 822: LIST
 823: LIST
 824: PUSH
 825: LD_INT 13
 827: PUSH
 828: LD_INT 2
 830: PUSH
 831: LD_INT 1
 833: PUSH
 834: LD_INT 31
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 13
 845: PUSH
 846: LD_INT 3
 848: PUSH
 849: LD_INT 2
 851: PUSH
 852: LD_INT 32
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: PUSH
 861: LD_INT 14
 863: PUSH
 864: LD_INT 1
 866: PUSH
 867: LD_INT 1
 869: PUSH
 870: LD_INT 28
 872: PUSH
 873: EMPTY
 874: LIST
 875: LIST
 876: LIST
 877: LIST
 878: PUSH
 879: LD_INT 14
 881: PUSH
 882: LD_INT 1
 884: PUSH
 885: LD_INT 1
 887: PUSH
 888: LD_INT 28
 890: PUSH
 891: EMPTY
 892: LIST
 893: LIST
 894: LIST
 895: LIST
 896: PUSH
 897: LD_INT 14
 899: PUSH
 900: LD_INT 1
 902: PUSH
 903: LD_INT 1
 905: PUSH
 906: LD_INT 28
 908: PUSH
 909: EMPTY
 910: LIST
 911: LIST
 912: LIST
 913: LIST
 914: PUSH
 915: LD_INT 14
 917: PUSH
 918: LD_INT 1
 920: PUSH
 921: LD_INT 1
 923: PUSH
 924: LD_INT 28
 926: PUSH
 927: EMPTY
 928: LIST
 929: LIST
 930: LIST
 931: LIST
 932: PUSH
 933: EMPTY
 934: LIST
 935: LIST
 936: LIST
 937: LIST
 938: LIST
 939: LIST
 940: LIST
 941: PPUSH
 942: CALL 43858 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
 946: LD_INT 3
 948: PPUSH
 949: LD_INT 4
 951: PPUSH
 952: CALL 44043 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
 956: LD_INT 4
 958: PPUSH
 959: LD_INT 10
 961: PUSH
 962: LD_INT 12
 964: PUSH
 965: LD_INT 11
 967: PUSH
 968: LD_INT 15
 970: PUSH
 971: EMPTY
 972: LIST
 973: LIST
 974: LIST
 975: LIST
 976: PPUSH
 977: CALL 44600 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
 981: LD_INT 4
 983: PPUSH
 984: LD_INT 33
 986: PUSH
 987: EMPTY
 988: LIST
 989: PPUSH
 990: CALL 44693 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
 994: LD_INT 4
 996: PPUSH
 997: LD_INT 5
 999: PUSH
1000: LD_INT 6
1002: PUSH
1003: LD_INT 7
1005: PUSH
1006: LD_INT 9
1008: PUSH
1009: LD_INT 10
1011: PUSH
1012: EMPTY
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: LIST
1018: PPUSH
1019: CALL 45011 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1023: LD_INT 4
1025: PPUSH
1026: LD_INT 54
1028: PPUSH
1029: LD_INT 85
1031: PPUSH
1032: LD_INT 2
1034: PPUSH
1035: LD_INT 25
1037: PUSH
1038: LD_INT 16
1040: PUSH
1041: LD_INT 17
1043: PUSH
1044: LD_INT 18
1046: PUSH
1047: LD_INT 22
1049: PUSH
1050: EMPTY
1051: LIST
1052: LIST
1053: LIST
1054: LIST
1055: LIST
1056: PPUSH
1057: CALL 44805 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1061: LD_INT 4
1063: PPUSH
1064: LD_INT 5
1066: PUSH
1067: LD_INT 1
1069: PUSH
1070: LD_INT 1
1072: PUSH
1073: LD_INT 7
1075: PUSH
1076: EMPTY
1077: LIST
1078: LIST
1079: LIST
1080: LIST
1081: PUSH
1082: LD_INT 5
1084: PUSH
1085: LD_INT 1
1087: PUSH
1088: LD_INT 1
1090: PUSH
1091: LD_INT 6
1093: PUSH
1094: EMPTY
1095: LIST
1096: LIST
1097: LIST
1098: LIST
1099: PUSH
1100: LD_INT 5
1102: PUSH
1103: LD_INT 1
1105: PUSH
1106: LD_INT 1
1108: PUSH
1109: LD_INT 7
1111: PUSH
1112: EMPTY
1113: LIST
1114: LIST
1115: LIST
1116: LIST
1117: PUSH
1118: LD_INT 5
1120: PUSH
1121: LD_INT 1
1123: PUSH
1124: LD_INT 1
1126: PUSH
1127: LD_INT 6
1129: PUSH
1130: EMPTY
1131: LIST
1132: LIST
1133: LIST
1134: LIST
1135: PUSH
1136: LD_INT 5
1138: PUSH
1139: LD_INT 1
1141: PUSH
1142: LD_INT 3
1144: PUSH
1145: LD_INT 12
1147: PUSH
1148: EMPTY
1149: LIST
1150: LIST
1151: LIST
1152: LIST
1153: PUSH
1154: LD_INT 3
1156: PUSH
1157: LD_INT 1
1159: PUSH
1160: LD_INT 3
1162: PUSH
1163: LD_INT 13
1165: PUSH
1166: EMPTY
1167: LIST
1168: LIST
1169: LIST
1170: LIST
1171: PUSH
1172: EMPTY
1173: LIST
1174: LIST
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: PPUSH
1180: CALL 43858 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1184: LD_INT 4
1186: PPUSH
1187: LD_INT 4
1189: PPUSH
1190: CALL 44043 0 2
// MC_SetTame ( 4 , powellApe ) ;
1194: LD_INT 4
1196: PPUSH
1197: LD_INT 11
1199: PPUSH
1200: CALL 44424 0 2
// end ;
1204: LD_VAR 0 1
1208: RET
// every 0 0$1 trigger debug do var i ;
1209: LD_EXP 1
1213: IFFALSE 1311
1215: GO 1217
1217: DISABLE
1218: LD_INT 0
1220: PPUSH
// begin enable ;
1221: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1222: LD_ADDR_VAR 0 1
1226: PUSH
1227: LD_INT 22
1229: PUSH
1230: LD_INT 7
1232: PUSH
1233: EMPTY
1234: LIST
1235: LIST
1236: PUSH
1237: LD_INT 2
1239: PUSH
1240: LD_INT 21
1242: PUSH
1243: LD_INT 1
1245: PUSH
1246: EMPTY
1247: LIST
1248: LIST
1249: PUSH
1250: LD_INT 21
1252: PUSH
1253: LD_INT 2
1255: PUSH
1256: EMPTY
1257: LIST
1258: LIST
1259: PUSH
1260: EMPTY
1261: LIST
1262: LIST
1263: LIST
1264: PUSH
1265: LD_INT 3
1267: PUSH
1268: LD_INT 24
1270: PUSH
1271: LD_INT 1000
1273: PUSH
1274: EMPTY
1275: LIST
1276: LIST
1277: PUSH
1278: EMPTY
1279: LIST
1280: LIST
1281: PUSH
1282: EMPTY
1283: LIST
1284: LIST
1285: LIST
1286: PPUSH
1287: CALL_OW 69
1291: PUSH
1292: FOR_IN
1293: IFFALSE 1309
// SetLives ( i , 1000 ) ;
1295: LD_VAR 0 1
1299: PPUSH
1300: LD_INT 1000
1302: PPUSH
1303: CALL_OW 234
1307: GO 1292
1309: POP
1310: POP
// end ; end_of_file
1311: PPOPN 1
1313: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1314: LD_INT 0
1316: PPUSH
1317: PPUSH
1318: PPUSH
1319: PPUSH
1320: PPUSH
// uc_side := 7 ;
1321: LD_ADDR_OWVAR 20
1325: PUSH
1326: LD_INT 7
1328: ST_TO_ADDR
// tmp := [ ] ;
1329: LD_ADDR_VAR 0 5
1333: PUSH
1334: EMPTY
1335: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1336: LD_ADDR_EXP 12
1340: PUSH
1341: LD_STRING JMM
1343: PPUSH
1344: LD_EXP 1
1348: NOT
1349: PPUSH
1350: LD_STRING 14a_
1352: PPUSH
1353: CALL 50250 0 3
1357: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1358: LD_ADDR_EXP 44
1362: PUSH
1363: LD_STRING Burlak
1365: PPUSH
1366: LD_EXP 1
1370: NOT
1371: PPUSH
1372: LD_STRING 14a_
1374: PPUSH
1375: CALL 50250 0 3
1379: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1380: LD_ADDR_EXP 27
1384: PUSH
1385: LD_STRING Joan
1387: PPUSH
1388: LD_EXP 1
1392: NOT
1393: PPUSH
1394: LD_STRING 13a_
1396: PPUSH
1397: CALL 50250 0 3
1401: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1402: LD_ADDR_EXP 13
1406: PUSH
1407: LD_STRING Roth
1409: PPUSH
1410: LD_EXP 1
1414: NOT
1415: PPUSH
1416: LD_STRING 13a_
1418: PPUSH
1419: CALL 50250 0 3
1423: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1424: LD_ADDR_EXP 30
1428: PUSH
1429: LD_STRING Gossudarov
1431: PPUSH
1432: LD_EXP 1
1436: NOT
1437: PPUSH
1438: LD_STRING 13a_
1440: PPUSH
1441: CALL 50250 0 3
1445: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1446: LD_ADDR_EXP 28
1450: PUSH
1451: LD_STRING DeltaDoctor
1453: PPUSH
1454: LD_EXP 1
1458: NOT
1459: PPUSH
1460: LD_STRING 13a_
1462: PPUSH
1463: CALL 50250 0 3
1467: ST_TO_ADDR
// if DeltaDoctor then
1468: LD_EXP 28
1472: IFFALSE 1490
// tmp := tmp ^ DeltaDoctor ;
1474: LD_ADDR_VAR 0 5
1478: PUSH
1479: LD_VAR 0 5
1483: PUSH
1484: LD_EXP 28
1488: ADD
1489: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1490: LD_ADDR_EXP 26
1494: PUSH
1495: LD_STRING Simms
1497: PPUSH
1498: LD_EXP 1
1502: NOT
1503: PPUSH
1504: LD_STRING 13a_
1506: PPUSH
1507: CALL 50250 0 3
1511: ST_TO_ADDR
// if Simms then
1512: LD_EXP 26
1516: IFFALSE 1534
// tmp := tmp ^ Simms ;
1518: LD_ADDR_VAR 0 5
1522: PUSH
1523: LD_VAR 0 5
1527: PUSH
1528: LD_EXP 26
1532: ADD
1533: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1534: LD_ADDR_EXP 24
1538: PUSH
1539: LD_STRING Frank
1541: PPUSH
1542: LD_EXP 1
1546: NOT
1547: PPUSH
1548: LD_STRING 13a_
1550: PPUSH
1551: CALL 50250 0 3
1555: ST_TO_ADDR
// if Frank then
1556: LD_EXP 24
1560: IFFALSE 1578
// tmp := tmp ^ Frank ;
1562: LD_ADDR_VAR 0 5
1566: PUSH
1567: LD_VAR 0 5
1571: PUSH
1572: LD_EXP 24
1576: ADD
1577: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1578: LD_ADDR_EXP 31
1582: PUSH
1583: LD_STRING Kirilenkova
1585: PPUSH
1586: LD_EXP 1
1590: NOT
1591: PPUSH
1592: LD_STRING 13a_
1594: PPUSH
1595: CALL 50250 0 3
1599: ST_TO_ADDR
// if Kirilenkova then
1600: LD_EXP 31
1604: IFFALSE 1622
// tmp := tmp ^ Kirilenkova ;
1606: LD_ADDR_VAR 0 5
1610: PUSH
1611: LD_VAR 0 5
1615: PUSH
1616: LD_EXP 31
1620: ADD
1621: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1622: LD_ADDR_EXP 32
1626: PUSH
1627: LD_STRING Titov
1629: PPUSH
1630: LD_EXP 1
1634: NOT
1635: PPUSH
1636: LD_STRING 13a_
1638: PPUSH
1639: CALL 50250 0 3
1643: ST_TO_ADDR
// if Titov then
1644: LD_EXP 32
1648: IFFALSE 1666
// tmp := tmp ^ Titov ;
1650: LD_ADDR_VAR 0 5
1654: PUSH
1655: LD_VAR 0 5
1659: PUSH
1660: LD_EXP 32
1664: ADD
1665: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1666: LD_ADDR_EXP 33
1670: PUSH
1671: LD_STRING Fadeev
1673: PPUSH
1674: LD_EXP 1
1678: NOT
1679: PPUSH
1680: LD_STRING 13a_
1682: PPUSH
1683: CALL 50250 0 3
1687: ST_TO_ADDR
// if Fadeev then
1688: LD_EXP 33
1692: IFFALSE 1710
// tmp := tmp ^ Fadeev ;
1694: LD_ADDR_VAR 0 5
1698: PUSH
1699: LD_VAR 0 5
1703: PUSH
1704: LD_EXP 33
1708: ADD
1709: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1710: LD_ADDR_EXP 34
1714: PUSH
1715: LD_STRING Dolgov
1717: PPUSH
1718: LD_EXP 1
1722: NOT
1723: PPUSH
1724: LD_STRING 13a_
1726: PPUSH
1727: CALL 50250 0 3
1731: ST_TO_ADDR
// if Dolgov then
1732: LD_EXP 34
1736: IFFALSE 1754
// tmp := tmp ^ Dolgov ;
1738: LD_ADDR_VAR 0 5
1742: PUSH
1743: LD_VAR 0 5
1747: PUSH
1748: LD_EXP 34
1752: ADD
1753: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1754: LD_ADDR_EXP 35
1758: PUSH
1759: LD_STRING Petrosyan
1761: PPUSH
1762: LD_EXP 1
1766: NOT
1767: PPUSH
1768: LD_STRING 13a_
1770: PPUSH
1771: CALL 50250 0 3
1775: ST_TO_ADDR
// if Petrosyan then
1776: LD_EXP 35
1780: IFFALSE 1798
// tmp := tmp ^ Petrosyan ;
1782: LD_ADDR_VAR 0 5
1786: PUSH
1787: LD_VAR 0 5
1791: PUSH
1792: LD_EXP 35
1796: ADD
1797: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1798: LD_ADDR_EXP 36
1802: PUSH
1803: LD_STRING Scholtze
1805: PPUSH
1806: LD_EXP 1
1810: NOT
1811: PPUSH
1812: LD_STRING 13a_
1814: PPUSH
1815: CALL 50250 0 3
1819: ST_TO_ADDR
// if Scholtze then
1820: LD_EXP 36
1824: IFFALSE 1842
// tmp := tmp ^ Scholtze ;
1826: LD_ADDR_VAR 0 5
1830: PUSH
1831: LD_VAR 0 5
1835: PUSH
1836: LD_EXP 36
1840: ADD
1841: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
1842: LD_ADDR_EXP 37
1846: PUSH
1847: LD_STRING Oblukov
1849: PPUSH
1850: LD_EXP 1
1854: NOT
1855: PPUSH
1856: LD_STRING 13a_
1858: PPUSH
1859: CALL 50250 0 3
1863: ST_TO_ADDR
// if Oblukov then
1864: LD_EXP 37
1868: IFFALSE 1886
// tmp := tmp ^ Oblukov ;
1870: LD_ADDR_VAR 0 5
1874: PUSH
1875: LD_VAR 0 5
1879: PUSH
1880: LD_EXP 37
1884: ADD
1885: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
1886: LD_ADDR_EXP 38
1890: PUSH
1891: LD_STRING Kapitsova
1893: PPUSH
1894: LD_EXP 1
1898: NOT
1899: PPUSH
1900: LD_STRING 13a_
1902: PPUSH
1903: CALL 50250 0 3
1907: ST_TO_ADDR
// if Kapitsova then
1908: LD_EXP 38
1912: IFFALSE 1930
// tmp := tmp ^ Kapitsova ;
1914: LD_ADDR_VAR 0 5
1918: PUSH
1919: LD_VAR 0 5
1923: PUSH
1924: LD_EXP 38
1928: ADD
1929: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
1930: LD_ADDR_EXP 39
1934: PUSH
1935: LD_STRING Lipshchin
1937: PPUSH
1938: LD_EXP 1
1942: NOT
1943: PPUSH
1944: LD_STRING 13a_
1946: PPUSH
1947: CALL 50250 0 3
1951: ST_TO_ADDR
// if Lipshchin then
1952: LD_EXP 39
1956: IFFALSE 1974
// tmp := tmp ^ Lipshchin ;
1958: LD_ADDR_VAR 0 5
1962: PUSH
1963: LD_VAR 0 5
1967: PUSH
1968: LD_EXP 39
1972: ADD
1973: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
1974: LD_ADDR_EXP 40
1978: PUSH
1979: LD_STRING Petrovova
1981: PPUSH
1982: LD_EXP 1
1986: NOT
1987: PPUSH
1988: LD_STRING 13a_
1990: PPUSH
1991: CALL 50250 0 3
1995: ST_TO_ADDR
// if Petrovova then
1996: LD_EXP 40
2000: IFFALSE 2018
// tmp := tmp ^ Petrovova ;
2002: LD_ADDR_VAR 0 5
2006: PUSH
2007: LD_VAR 0 5
2011: PUSH
2012: LD_EXP 40
2016: ADD
2017: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2018: LD_ADDR_EXP 41
2022: PUSH
2023: LD_STRING Kovalyuk
2025: PPUSH
2026: LD_EXP 1
2030: NOT
2031: PPUSH
2032: LD_STRING 13a_
2034: PPUSH
2035: CALL 50250 0 3
2039: ST_TO_ADDR
// if Kovalyuk then
2040: LD_EXP 41
2044: IFFALSE 2062
// tmp := tmp ^ Kovalyuk ;
2046: LD_ADDR_VAR 0 5
2050: PUSH
2051: LD_VAR 0 5
2055: PUSH
2056: LD_EXP 41
2060: ADD
2061: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2062: LD_ADDR_EXP 42
2066: PUSH
2067: LD_STRING Kuzmov
2069: PPUSH
2070: LD_EXP 1
2074: NOT
2075: PPUSH
2076: LD_STRING 13a_
2078: PPUSH
2079: CALL 50250 0 3
2083: ST_TO_ADDR
// if Kuzmov then
2084: LD_EXP 42
2088: IFFALSE 2106
// tmp := tmp ^ Kuzmov ;
2090: LD_ADDR_VAR 0 5
2094: PUSH
2095: LD_VAR 0 5
2099: PUSH
2100: LD_EXP 42
2104: ADD
2105: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2106: LD_ADDR_EXP 43
2110: PUSH
2111: LD_STRING Karamazov
2113: PPUSH
2114: LD_EXP 1
2118: NOT
2119: PPUSH
2120: LD_STRING 13a_
2122: PPUSH
2123: CALL 50250 0 3
2127: ST_TO_ADDR
// if Karamazov then
2128: LD_EXP 43
2132: IFFALSE 2150
// tmp := tmp ^ Karamazov ;
2134: LD_ADDR_VAR 0 5
2138: PUSH
2139: LD_VAR 0 5
2143: PUSH
2144: LD_EXP 43
2148: ADD
2149: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2150: LD_ADDR_EXP 45
2154: PUSH
2155: LD_STRING Belkov
2157: PPUSH
2158: LD_EXP 1
2162: NOT
2163: PPUSH
2164: LD_STRING 13a_
2166: PPUSH
2167: CALL 50250 0 3
2171: ST_TO_ADDR
// if Belkov then
2172: LD_EXP 45
2176: IFFALSE 2194
// tmp := tmp ^ Belkov ;
2178: LD_ADDR_VAR 0 5
2182: PUSH
2183: LD_VAR 0 5
2187: PUSH
2188: LD_EXP 45
2192: ADD
2193: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2194: LD_ADDR_EXP 46
2198: PUSH
2199: LD_STRING Gnyevko
2201: PPUSH
2202: LD_EXP 1
2206: NOT
2207: PPUSH
2208: LD_STRING 13a_
2210: PPUSH
2211: CALL 50250 0 3
2215: ST_TO_ADDR
// if Gnyevko then
2216: LD_EXP 46
2220: IFFALSE 2238
// tmp := tmp ^ Gnyevko ;
2222: LD_ADDR_VAR 0 5
2226: PUSH
2227: LD_VAR 0 5
2231: PUSH
2232: LD_EXP 46
2236: ADD
2237: ST_TO_ADDR
// Connie = NewCharacter ( Coonie ) ;
2238: LD_ADDR_EXP 29
2242: PUSH
2243: LD_STRING Coonie
2245: PPUSH
2246: CALL_OW 25
2250: ST_TO_ADDR
// if not Lisa then
2251: LD_EXP 14
2255: NOT
2256: IFFALSE 2302
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2258: LD_ADDR_EXP 14
2262: PUSH
2263: LD_STRING Lisa
2265: PPUSH
2266: LD_EXP 1
2270: NOT
2271: PPUSH
2272: LD_STRING 13a_
2274: PPUSH
2275: CALL 50250 0 3
2279: ST_TO_ADDR
// if Lisa then
2280: LD_EXP 14
2284: IFFALSE 2302
// tmp := tmp ^ Lisa ;
2286: LD_ADDR_VAR 0 5
2290: PUSH
2291: LD_VAR 0 5
2295: PUSH
2296: LD_EXP 14
2300: ADD
2301: ST_TO_ADDR
// end ; if not Donaldson then
2302: LD_EXP 15
2306: NOT
2307: IFFALSE 2353
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2309: LD_ADDR_EXP 15
2313: PUSH
2314: LD_STRING Donaldson
2316: PPUSH
2317: LD_EXP 1
2321: NOT
2322: PPUSH
2323: LD_STRING 13a_
2325: PPUSH
2326: CALL 50250 0 3
2330: ST_TO_ADDR
// if Donaldson then
2331: LD_EXP 15
2335: IFFALSE 2353
// tmp := tmp ^ Donaldson ;
2337: LD_ADDR_VAR 0 5
2341: PUSH
2342: LD_VAR 0 5
2346: PUSH
2347: LD_EXP 15
2351: ADD
2352: ST_TO_ADDR
// end ; if not Bobby then
2353: LD_EXP 16
2357: NOT
2358: IFFALSE 2404
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2360: LD_ADDR_EXP 16
2364: PUSH
2365: LD_STRING Bobby
2367: PPUSH
2368: LD_EXP 1
2372: NOT
2373: PPUSH
2374: LD_STRING 13a_
2376: PPUSH
2377: CALL 50250 0 3
2381: ST_TO_ADDR
// if Bobby then
2382: LD_EXP 16
2386: IFFALSE 2404
// tmp := tmp ^ Bobby ;
2388: LD_ADDR_VAR 0 5
2392: PUSH
2393: LD_VAR 0 5
2397: PUSH
2398: LD_EXP 16
2402: ADD
2403: ST_TO_ADDR
// end ; if not Cyrus then
2404: LD_EXP 17
2408: NOT
2409: IFFALSE 2455
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2411: LD_ADDR_EXP 17
2415: PUSH
2416: LD_STRING Cyrus
2418: PPUSH
2419: LD_EXP 1
2423: NOT
2424: PPUSH
2425: LD_STRING 13a_
2427: PPUSH
2428: CALL 50250 0 3
2432: ST_TO_ADDR
// if Cyrus then
2433: LD_EXP 17
2437: IFFALSE 2455
// tmp := tmp ^ Cyrus ;
2439: LD_ADDR_VAR 0 5
2443: PUSH
2444: LD_VAR 0 5
2448: PUSH
2449: LD_EXP 17
2453: ADD
2454: ST_TO_ADDR
// end ; if not Brown then
2455: LD_EXP 19
2459: NOT
2460: IFFALSE 2506
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2462: LD_ADDR_EXP 19
2466: PUSH
2467: LD_STRING Brown
2469: PPUSH
2470: LD_EXP 1
2474: NOT
2475: PPUSH
2476: LD_STRING 13a_
2478: PPUSH
2479: CALL 50250 0 3
2483: ST_TO_ADDR
// if Brown then
2484: LD_EXP 19
2488: IFFALSE 2506
// tmp := tmp ^ Brown ;
2490: LD_ADDR_VAR 0 5
2494: PUSH
2495: LD_VAR 0 5
2499: PUSH
2500: LD_EXP 19
2504: ADD
2505: ST_TO_ADDR
// end ; if not Gladstone then
2506: LD_EXP 20
2510: NOT
2511: IFFALSE 2557
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2513: LD_ADDR_EXP 20
2517: PUSH
2518: LD_STRING Gladstone
2520: PPUSH
2521: LD_EXP 1
2525: NOT
2526: PPUSH
2527: LD_STRING 13a_
2529: PPUSH
2530: CALL 50250 0 3
2534: ST_TO_ADDR
// if Gladstone then
2535: LD_EXP 20
2539: IFFALSE 2557
// tmp := tmp ^ Gladstone ;
2541: LD_ADDR_VAR 0 5
2545: PUSH
2546: LD_VAR 0 5
2550: PUSH
2551: LD_EXP 20
2555: ADD
2556: ST_TO_ADDR
// end ; if not Cornel then
2557: LD_EXP 22
2561: NOT
2562: IFFALSE 2608
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2564: LD_ADDR_EXP 22
2568: PUSH
2569: LD_STRING Cornel
2571: PPUSH
2572: LD_EXP 1
2576: NOT
2577: PPUSH
2578: LD_STRING 13a_
2580: PPUSH
2581: CALL 50250 0 3
2585: ST_TO_ADDR
// if Cornel then
2586: LD_EXP 22
2590: IFFALSE 2608
// tmp := tmp ^ Cornel ;
2592: LD_ADDR_VAR 0 5
2596: PUSH
2597: LD_VAR 0 5
2601: PUSH
2602: LD_EXP 22
2606: ADD
2607: ST_TO_ADDR
// end ; if not Houten then
2608: LD_EXP 21
2612: NOT
2613: IFFALSE 2659
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2615: LD_ADDR_EXP 21
2619: PUSH
2620: LD_STRING Houten
2622: PPUSH
2623: LD_EXP 1
2627: NOT
2628: PPUSH
2629: LD_STRING 13a_
2631: PPUSH
2632: CALL 50250 0 3
2636: ST_TO_ADDR
// if Houten then
2637: LD_EXP 21
2641: IFFALSE 2659
// tmp := tmp ^ Houten ;
2643: LD_ADDR_VAR 0 5
2647: PUSH
2648: LD_VAR 0 5
2652: PUSH
2653: LD_EXP 21
2657: ADD
2658: ST_TO_ADDR
// end ; if not Gary then
2659: LD_EXP 23
2663: NOT
2664: IFFALSE 2710
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2666: LD_ADDR_EXP 23
2670: PUSH
2671: LD_STRING Gary
2673: PPUSH
2674: LD_EXP 1
2678: NOT
2679: PPUSH
2680: LD_STRING 13a_
2682: PPUSH
2683: CALL 50250 0 3
2687: ST_TO_ADDR
// if Gary then
2688: LD_EXP 23
2692: IFFALSE 2710
// tmp := tmp ^ Gary ;
2694: LD_ADDR_VAR 0 5
2698: PUSH
2699: LD_VAR 0 5
2703: PUSH
2704: LD_EXP 23
2708: ADD
2709: ST_TO_ADDR
// end ; if not Kikuchi then
2710: LD_EXP 25
2714: NOT
2715: IFFALSE 2761
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2717: LD_ADDR_EXP 25
2721: PUSH
2722: LD_STRING Kikuchi
2724: PPUSH
2725: LD_EXP 1
2729: NOT
2730: PPUSH
2731: LD_STRING 13a_
2733: PPUSH
2734: CALL 50250 0 3
2738: ST_TO_ADDR
// if Kikuchi then
2739: LD_EXP 25
2743: IFFALSE 2761
// tmp := tmp ^ Kikuchi ;
2745: LD_ADDR_VAR 0 5
2749: PUSH
2750: LD_VAR 0 5
2754: PUSH
2755: LD_EXP 25
2759: ADD
2760: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2761: LD_ADDR_VAR 0 5
2765: PUSH
2766: LD_VAR 0 5
2770: PUSH
2771: LD_STRING 13a_others
2773: PPUSH
2774: CALL_OW 31
2778: UNION
2779: ST_TO_ADDR
// tmp := tmp diff 0 ;
2780: LD_ADDR_VAR 0 5
2784: PUSH
2785: LD_VAR 0 5
2789: PUSH
2790: LD_INT 0
2792: DIFF
2793: ST_TO_ADDR
// if tmp < 15 then
2794: LD_VAR 0 5
2798: PUSH
2799: LD_INT 15
2801: LESS
2802: IFFALSE 2890
// for i = 15 downto tmp do
2804: LD_ADDR_VAR 0 2
2808: PUSH
2809: DOUBLE
2810: LD_INT 15
2812: INC
2813: ST_TO_ADDR
2814: LD_VAR 0 5
2818: PUSH
2819: FOR_DOWNTO
2820: IFFALSE 2888
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2822: LD_ADDR_OWVAR 21
2826: PUSH
2827: LD_INT 1
2829: PUSH
2830: LD_INT 3
2832: PUSH
2833: EMPTY
2834: LIST
2835: LIST
2836: PUSH
2837: LD_INT 1
2839: PPUSH
2840: LD_INT 2
2842: PPUSH
2843: CALL_OW 12
2847: ARRAY
2848: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
2849: LD_INT 0
2851: PPUSH
2852: LD_INT 1
2854: PPUSH
2855: LD_INT 4
2857: PPUSH
2858: CALL_OW 12
2862: PPUSH
2863: LD_INT 8
2865: PPUSH
2866: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2870: LD_ADDR_VAR 0 5
2874: PUSH
2875: LD_VAR 0 5
2879: PUSH
2880: CALL_OW 44
2884: ADD
2885: ST_TO_ADDR
// end ;
2886: GO 2819
2888: POP
2889: POP
// if not debug then
2890: LD_EXP 1
2894: NOT
2895: IFFALSE 3067
// selected = CharacterSelection (  , [ 15 , 14 , 13 ] [ Difficulty ] , [ 15 , 14 , 13 ] [ Difficulty ] , [ sel_dont_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
2897: LD_ADDR_VAR 0 4
2901: PUSH
2902: LD_STRING 
2904: PPUSH
2905: LD_INT 15
2907: PUSH
2908: LD_INT 14
2910: PUSH
2911: LD_INT 13
2913: PUSH
2914: EMPTY
2915: LIST
2916: LIST
2917: LIST
2918: PUSH
2919: LD_OWVAR 67
2923: ARRAY
2924: PPUSH
2925: LD_INT 15
2927: PUSH
2928: LD_INT 14
2930: PUSH
2931: LD_INT 13
2933: PUSH
2934: EMPTY
2935: LIST
2936: LIST
2937: LIST
2938: PUSH
2939: LD_OWVAR 67
2943: ARRAY
2944: PPUSH
2945: LD_INT -6
2947: PUSH
2948: LD_EXP 12
2952: PUSH
2953: LD_EXP 44
2957: PUSH
2958: LD_EXP 13
2962: PUSH
2963: LD_EXP 27
2967: PUSH
2968: LD_EXP 18
2972: PUSH
2973: LD_EXP 30
2977: PUSH
2978: LD_INT -2
2980: PUSH
2981: LD_INT -3
2983: PUSH
2984: LD_INT -5
2986: PUSH
2987: EMPTY
2988: LIST
2989: LIST
2990: LIST
2991: LIST
2992: LIST
2993: LIST
2994: LIST
2995: LIST
2996: LIST
2997: LIST
2998: PUSH
2999: LD_VAR 0 5
3003: ADD
3004: PPUSH
3005: LD_INT 1
3007: PUSH
3008: LD_INT 4
3010: PUSH
3011: LD_INT 2
3013: PUSH
3014: LD_INT 1
3016: PUSH
3017: EMPTY
3018: LIST
3019: LIST
3020: PUSH
3021: LD_INT 3
3023: PUSH
3024: LD_INT 5
3026: PUSH
3027: LD_INT 0
3029: PUSH
3030: LD_INT 3
3032: PUSH
3033: EMPTY
3034: LIST
3035: LIST
3036: LIST
3037: PUSH
3038: LD_INT 9
3040: PUSH
3041: LD_INT 0
3043: PUSH
3044: LD_INT 3
3046: PUSH
3047: EMPTY
3048: LIST
3049: LIST
3050: LIST
3051: PUSH
3052: EMPTY
3053: LIST
3054: LIST
3055: LIST
3056: LIST
3057: LIST
3058: LIST
3059: PPUSH
3060: CALL_OW 42
3064: ST_TO_ADDR
3065: GO 3146
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ] ;
3067: LD_ADDR_VAR 0 4
3071: PUSH
3072: LD_EXP 32
3076: PUSH
3077: LD_EXP 33
3081: PUSH
3082: LD_EXP 34
3086: PUSH
3087: LD_EXP 35
3091: PUSH
3092: LD_EXP 36
3096: PUSH
3097: LD_EXP 37
3101: PUSH
3102: LD_EXP 38
3106: PUSH
3107: LD_EXP 39
3111: PUSH
3112: LD_EXP 40
3116: PUSH
3117: LD_EXP 41
3121: PUSH
3122: LD_EXP 42
3126: PUSH
3127: LD_EXP 43
3131: PUSH
3132: EMPTY
3133: LIST
3134: LIST
3135: LIST
3136: LIST
3137: LIST
3138: LIST
3139: LIST
3140: LIST
3141: LIST
3142: LIST
3143: LIST
3144: LIST
3145: ST_TO_ADDR
// uc_nation := 1 ;
3146: LD_ADDR_OWVAR 21
3150: PUSH
3151: LD_INT 1
3153: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3154: LD_INT 5
3156: PPUSH
3157: LD_INT 3
3159: PPUSH
3160: LD_INT 1
3162: PPUSH
3163: LD_INT 6
3165: PPUSH
3166: LD_INT 100
3168: PPUSH
3169: CALL 57365 0 5
// veh := CreateVehicle ;
3173: LD_ADDR_VAR 0 3
3177: PUSH
3178: CALL_OW 45
3182: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3183: LD_VAR 0 3
3187: PPUSH
3188: LD_INT 7
3190: NEG
3191: PPUSH
3192: CALL_OW 242
// SetDir ( veh , 3 ) ;
3196: LD_VAR 0 3
3200: PPUSH
3201: LD_INT 3
3203: PPUSH
3204: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3208: LD_VAR 0 3
3212: PPUSH
3213: LD_INT 31
3215: PPUSH
3216: LD_INT 0
3218: PPUSH
3219: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3223: LD_EXP 12
3227: PPUSH
3228: LD_VAR 0 3
3232: PPUSH
3233: CALL_OW 52
// if Joan then
3237: LD_EXP 27
3241: IFFALSE 3313
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3243: LD_INT 3
3245: PPUSH
3246: LD_INT 3
3248: PPUSH
3249: LD_INT 1
3251: PPUSH
3252: LD_INT 11
3254: PPUSH
3255: LD_INT 100
3257: PPUSH
3258: CALL 57365 0 5
// veh := CreateVehicle ;
3262: LD_ADDR_VAR 0 3
3266: PUSH
3267: CALL_OW 45
3271: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3272: LD_VAR 0 3
3276: PPUSH
3277: LD_INT 3
3279: PPUSH
3280: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3284: LD_VAR 0 3
3288: PPUSH
3289: LD_INT 30
3291: PPUSH
3292: LD_INT 0
3294: PPUSH
3295: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3299: LD_EXP 27
3303: PPUSH
3304: LD_VAR 0 3
3308: PPUSH
3309: CALL_OW 52
// end ; if Roth then
3313: LD_EXP 13
3317: IFFALSE 3389
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3319: LD_INT 3
3321: PPUSH
3322: LD_INT 3
3324: PPUSH
3325: LD_INT 1
3327: PPUSH
3328: LD_INT 11
3330: PPUSH
3331: LD_INT 100
3333: PPUSH
3334: CALL 57365 0 5
// veh := CreateVehicle ;
3338: LD_ADDR_VAR 0 3
3342: PUSH
3343: CALL_OW 45
3347: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3348: LD_VAR 0 3
3352: PPUSH
3353: LD_INT 3
3355: PPUSH
3356: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3360: LD_VAR 0 3
3364: PPUSH
3365: LD_INT 30
3367: PPUSH
3368: LD_INT 0
3370: PPUSH
3371: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3375: LD_EXP 13
3379: PPUSH
3380: LD_VAR 0 3
3384: PPUSH
3385: CALL_OW 52
// end ; if Denis then
3389: LD_EXP 18
3393: IFFALSE 3465
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3395: LD_INT 5
3397: PPUSH
3398: LD_INT 3
3400: PPUSH
3401: LD_INT 1
3403: PPUSH
3404: LD_INT 9
3406: PPUSH
3407: LD_INT 100
3409: PPUSH
3410: CALL 57365 0 5
// veh := CreateVehicle ;
3414: LD_ADDR_VAR 0 3
3418: PUSH
3419: CALL_OW 45
3423: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3424: LD_VAR 0 3
3428: PPUSH
3429: LD_INT 3
3431: PPUSH
3432: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3436: LD_VAR 0 3
3440: PPUSH
3441: LD_INT 30
3443: PPUSH
3444: LD_INT 0
3446: PPUSH
3447: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3451: LD_EXP 18
3455: PPUSH
3456: LD_VAR 0 3
3460: PPUSH
3461: CALL_OW 52
// end ; uc_nation := 3 ;
3465: LD_ADDR_OWVAR 21
3469: PUSH
3470: LD_INT 3
3472: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3473: LD_INT 22
3475: PPUSH
3476: LD_INT 3
3478: PPUSH
3479: LD_INT 1
3481: PPUSH
3482: LD_INT 45
3484: PPUSH
3485: LD_INT 100
3487: PPUSH
3488: CALL 57365 0 5
// veh := CreateVehicle ;
3492: LD_ADDR_VAR 0 3
3496: PUSH
3497: CALL_OW 45
3501: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3502: LD_VAR 0 3
3506: PPUSH
3507: LD_INT 7
3509: NEG
3510: PPUSH
3511: CALL_OW 242
// SetDir ( veh , 3 ) ;
3515: LD_VAR 0 3
3519: PPUSH
3520: LD_INT 3
3522: PPUSH
3523: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3527: LD_VAR 0 3
3531: PPUSH
3532: LD_INT 31
3534: PPUSH
3535: LD_INT 0
3537: PPUSH
3538: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3542: LD_EXP 44
3546: PPUSH
3547: LD_VAR 0 3
3551: PPUSH
3552: CALL_OW 52
// if Gossudarov then
3556: LD_EXP 30
3560: IFFALSE 3647
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3562: LD_INT 22
3564: PPUSH
3565: LD_INT 3
3567: PPUSH
3568: LD_INT 1
3570: PPUSH
3571: LD_INT 51
3573: PPUSH
3574: LD_INT 100
3576: PPUSH
3577: CALL 57365 0 5
// veh := CreateVehicle ;
3581: LD_ADDR_VAR 0 3
3585: PUSH
3586: CALL_OW 45
3590: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3591: LD_VAR 0 3
3595: PPUSH
3596: LD_INT 3
3598: PPUSH
3599: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3603: LD_VAR 0 3
3607: PPUSH
3608: LD_INT 30
3610: PPUSH
3611: LD_INT 0
3613: PPUSH
3614: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3618: LD_EXP 30
3622: PPUSH
3623: LD_VAR 0 3
3627: PPUSH
3628: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3632: LD_VAR 0 3
3636: PPUSH
3637: LD_INT 1
3639: PPUSH
3640: LD_INT 100
3642: PPUSH
3643: CALL_OW 290
// end ; for i in selected do
3647: LD_ADDR_VAR 0 2
3651: PUSH
3652: LD_VAR 0 4
3656: PUSH
3657: FOR_IN
3658: IFFALSE 4216
// begin uc_nation := GetNation ( i ) ;
3660: LD_ADDR_OWVAR 21
3664: PUSH
3665: LD_VAR 0 2
3669: PPUSH
3670: CALL_OW 248
3674: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3675: LD_VAR 0 2
3679: PUSH
3680: LD_EXP 14
3684: PUSH
3685: LD_EXP 15
3689: PUSH
3690: LD_EXP 17
3694: PUSH
3695: LD_EXP 16
3699: PUSH
3700: EMPTY
3701: LIST
3702: LIST
3703: LIST
3704: LIST
3705: IN
3706: IFFALSE 3729
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3708: LD_INT 5
3710: PPUSH
3711: LD_INT 3
3713: PPUSH
3714: LD_INT 1
3716: PPUSH
3717: LD_INT 6
3719: PPUSH
3720: LD_INT 100
3722: PPUSH
3723: CALL 57365 0 5
3727: GO 4163
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3729: LD_VAR 0 2
3733: PUSH
3734: LD_EXP 37
3738: PUSH
3739: LD_EXP 42
3743: PUSH
3744: LD_EXP 40
3748: PUSH
3749: LD_EXP 32
3753: PUSH
3754: EMPTY
3755: LIST
3756: LIST
3757: LIST
3758: LIST
3759: IN
3760: IFFALSE 3791
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3762: LD_INT 24
3764: PPUSH
3765: LD_INT 1
3767: PPUSH
3768: LD_INT 1
3770: PPUSH
3771: LD_INT 46
3773: PPUSH
3774: LD_INT 65
3776: PPUSH
3777: LD_INT 75
3779: PPUSH
3780: CALL_OW 12
3784: PPUSH
3785: CALL 57365 0 5
3789: GO 4163
// if i = Karamazov then
3791: LD_VAR 0 2
3795: PUSH
3796: LD_EXP 43
3800: EQUAL
3801: IFFALSE 3824
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3803: LD_INT 22
3805: PPUSH
3806: LD_INT 3
3808: PPUSH
3809: LD_INT 1
3811: PPUSH
3812: LD_INT 52
3814: PPUSH
3815: LD_INT 100
3817: PPUSH
3818: CALL 57365 0 5
3822: GO 4163
// if i = Brown then
3824: LD_VAR 0 2
3828: PUSH
3829: LD_EXP 19
3833: EQUAL
3834: IFFALSE 3857
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
3836: LD_INT 3
3838: PPUSH
3839: LD_INT 3
3841: PPUSH
3842: LD_INT 1
3844: PPUSH
3845: LD_INT 13
3847: PPUSH
3848: LD_INT 100
3850: PPUSH
3851: CALL 57365 0 5
3855: GO 4163
// if uc_nation = nation_american then
3857: LD_OWVAR 21
3861: PUSH
3862: LD_INT 1
3864: EQUAL
3865: IFFALSE 4016
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
3867: LD_INT 3
3869: PUSH
3870: LD_INT 5
3872: PUSH
3873: LD_INT 5
3875: PUSH
3876: EMPTY
3877: LIST
3878: LIST
3879: LIST
3880: PUSH
3881: LD_OWVAR 21
3885: PUSH
3886: LD_INT 3
3888: MOD
3889: PUSH
3890: LD_INT 1
3892: PLUS
3893: ARRAY
3894: PPUSH
3895: LD_INT 1
3897: PUSH
3898: LD_INT 3
3900: PUSH
3901: LD_INT 1
3903: PUSH
3904: EMPTY
3905: LIST
3906: LIST
3907: LIST
3908: PUSH
3909: LD_OWVAR 21
3913: PUSH
3914: LD_INT 3
3916: MOD
3917: PUSH
3918: LD_INT 1
3920: PLUS
3921: ARRAY
3922: PPUSH
3923: LD_INT 1
3925: PPUSH
3926: LD_INT 11
3928: PUSH
3929: LD_INT 4
3931: PUSH
3932: LD_INT 5
3934: PUSH
3935: EMPTY
3936: LIST
3937: LIST
3938: LIST
3939: PUSH
3940: LD_INT 6
3942: PUSH
3943: LD_INT 7
3945: PUSH
3946: LD_INT 9
3948: PUSH
3949: EMPTY
3950: LIST
3951: LIST
3952: LIST
3953: PUSH
3954: LD_INT 6
3956: PUSH
3957: LD_INT 9
3959: PUSH
3960: LD_INT 12
3962: PUSH
3963: EMPTY
3964: LIST
3965: LIST
3966: LIST
3967: PUSH
3968: EMPTY
3969: LIST
3970: LIST
3971: LIST
3972: PUSH
3973: LD_OWVAR 21
3977: PUSH
3978: LD_INT 3
3980: MOD
3981: PUSH
3982: LD_INT 1
3984: PLUS
3985: ARRAY
3986: PUSH
3987: LD_INT 1
3989: PPUSH
3990: LD_INT 3
3992: PPUSH
3993: CALL_OW 12
3997: ARRAY
3998: PPUSH
3999: LD_INT 65
4001: PPUSH
4002: LD_INT 75
4004: PPUSH
4005: CALL_OW 12
4009: PPUSH
4010: CALL 57365 0 5
// end else
4014: GO 4163
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4016: LD_INT 22
4018: PUSH
4019: LD_INT 23
4021: PUSH
4022: LD_INT 23
4024: PUSH
4025: EMPTY
4026: LIST
4027: LIST
4028: LIST
4029: PUSH
4030: LD_OWVAR 21
4034: PUSH
4035: LD_INT 3
4037: MOD
4038: PUSH
4039: LD_INT 1
4041: PLUS
4042: ARRAY
4043: PPUSH
4044: LD_INT 1
4046: PUSH
4047: LD_INT 3
4049: PUSH
4050: LD_INT 1
4052: PUSH
4053: EMPTY
4054: LIST
4055: LIST
4056: LIST
4057: PUSH
4058: LD_OWVAR 21
4062: PUSH
4063: LD_INT 3
4065: MOD
4066: PUSH
4067: LD_INT 1
4069: PLUS
4070: ARRAY
4071: PPUSH
4072: LD_INT 1
4074: PPUSH
4075: LD_INT 45
4077: PUSH
4078: LD_INT 43
4080: PUSH
4081: LD_INT 44
4083: PUSH
4084: EMPTY
4085: LIST
4086: LIST
4087: LIST
4088: PUSH
4089: LD_INT 46
4091: PUSH
4092: LD_INT 45
4094: PUSH
4095: LD_INT 44
4097: PUSH
4098: EMPTY
4099: LIST
4100: LIST
4101: LIST
4102: PUSH
4103: LD_INT 46
4105: PUSH
4106: LD_INT 43
4108: PUSH
4109: LD_INT 45
4111: PUSH
4112: EMPTY
4113: LIST
4114: LIST
4115: LIST
4116: PUSH
4117: EMPTY
4118: LIST
4119: LIST
4120: LIST
4121: PUSH
4122: LD_OWVAR 21
4126: PUSH
4127: LD_INT 3
4129: MOD
4130: PUSH
4131: LD_INT 1
4133: PLUS
4134: ARRAY
4135: PUSH
4136: LD_INT 1
4138: PPUSH
4139: LD_INT 3
4141: PPUSH
4142: CALL_OW 12
4146: ARRAY
4147: PPUSH
4148: LD_INT 65
4150: PPUSH
4151: LD_INT 75
4153: PPUSH
4154: CALL_OW 12
4158: PPUSH
4159: CALL 57365 0 5
// end ; veh := CreateVehicle ;
4163: LD_ADDR_VAR 0 3
4167: PUSH
4168: CALL_OW 45
4172: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4173: LD_VAR 0 3
4177: PPUSH
4178: LD_INT 3
4180: PPUSH
4181: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4185: LD_VAR 0 3
4189: PPUSH
4190: LD_INT 30
4192: PPUSH
4193: LD_INT 0
4195: PPUSH
4196: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4200: LD_VAR 0 2
4204: PPUSH
4205: LD_VAR 0 3
4209: PPUSH
4210: CALL_OW 52
// end ;
4214: GO 3657
4216: POP
4217: POP
// if artifactArCaptured then
4218: LD_EXP 6
4222: IFFALSE 4308
// begin uc_nation := nation_american ;
4224: LD_ADDR_OWVAR 21
4228: PUSH
4229: LD_INT 1
4231: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4232: LD_INT 3
4234: PPUSH
4235: LD_INT 3
4237: PPUSH
4238: LD_INT 3
4240: PPUSH
4241: LD_INT 12
4243: PPUSH
4244: LD_INT 100
4246: PPUSH
4247: CALL 57365 0 5
// veh := CreateVehicle ;
4251: LD_ADDR_VAR 0 3
4255: PUSH
4256: CALL_OW 45
4260: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4261: LD_VAR 0 3
4265: PPUSH
4266: LD_INT 3
4268: PPUSH
4269: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4273: LD_VAR 0 3
4277: PPUSH
4278: LD_INT 198
4280: PPUSH
4281: LD_INT 22
4283: PPUSH
4284: LD_INT 0
4286: PPUSH
4287: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4291: LD_VAR 0 3
4295: PPUSH
4296: LD_INT 4
4298: PPUSH
4299: LD_INT 50
4301: PPUSH
4302: CALL_OW 290
// end else
4306: GO 4327
// begin CreateResourcesXY ( mat_artifact , 267 , 226 , 5 , false ) ;
4308: LD_INT 4
4310: PPUSH
4311: LD_INT 267
4313: PPUSH
4314: LD_INT 226
4316: PPUSH
4317: LD_INT 5
4319: PPUSH
4320: LD_INT 0
4322: PPUSH
4323: CALL_OW 58
// end ; uc_nation := nation_american ;
4327: LD_ADDR_OWVAR 21
4331: PUSH
4332: LD_INT 1
4334: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4335: LD_INT 3
4337: PPUSH
4338: LD_INT 3
4340: PPUSH
4341: LD_INT 3
4343: PPUSH
4344: LD_INT 12
4346: PPUSH
4347: LD_INT 100
4349: PPUSH
4350: CALL 57365 0 5
// veh := CreateVehicle ;
4354: LD_ADDR_VAR 0 3
4358: PUSH
4359: CALL_OW 45
4363: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4364: LD_VAR 0 3
4368: PPUSH
4369: LD_INT 3
4371: PPUSH
4372: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4376: LD_VAR 0 3
4380: PPUSH
4381: LD_INT 218
4383: PPUSH
4384: LD_INT 23
4386: PPUSH
4387: LD_INT 0
4389: PPUSH
4390: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4394: LD_VAR 0 3
4398: PPUSH
4399: LD_INT 4
4401: PPUSH
4402: LD_INT 30
4404: PPUSH
4405: CALL_OW 290
// uc_nation := nation_russian ;
4409: LD_ADDR_OWVAR 21
4413: PUSH
4414: LD_INT 3
4416: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4417: LD_INT 22
4419: PPUSH
4420: LD_INT 3
4422: PPUSH
4423: LD_INT 3
4425: PPUSH
4426: LD_INT 51
4428: PPUSH
4429: LD_INT 100
4431: PPUSH
4432: CALL 57365 0 5
// veh := CreateVehicle ;
4436: LD_ADDR_VAR 0 3
4440: PUSH
4441: CALL_OW 45
4445: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4446: LD_VAR 0 3
4450: PPUSH
4451: LD_INT 3
4453: PPUSH
4454: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4458: LD_VAR 0 3
4462: PPUSH
4463: LD_INT 214
4465: PPUSH
4466: LD_INT 20
4468: PPUSH
4469: LD_INT 0
4471: PPUSH
4472: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4476: LD_VAR 0 3
4480: PPUSH
4481: LD_INT 4
4483: PPUSH
4484: LD_INT 40
4486: PPUSH
4487: CALL_OW 290
// end ; end_of_file
4491: LD_VAR 0 1
4495: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
4496: LD_INT 0
4498: PPUSH
4499: PPUSH
4500: PPUSH
4501: PPUSH
4502: PPUSH
4503: PPUSH
4504: PPUSH
4505: PPUSH
4506: PPUSH
4507: PPUSH
// InitHc ;
4508: CALL_OW 19
// uc_side := 1 ;
4512: LD_ADDR_OWVAR 20
4516: PUSH
4517: LD_INT 1
4519: ST_TO_ADDR
// uc_nation := 1 ;
4520: LD_ADDR_OWVAR 21
4524: PUSH
4525: LD_INT 1
4527: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 25500 ) ;
4528: LD_INT 387
4530: PPUSH
4531: CALL_OW 274
4535: PPUSH
4536: LD_INT 1
4538: PPUSH
4539: LD_INT 25500
4541: PPUSH
4542: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
4546: LD_INT 387
4548: PPUSH
4549: CALL_OW 274
4553: PPUSH
4554: LD_INT 2
4556: PPUSH
4557: LD_INT 4000
4559: PPUSH
4560: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
4564: LD_INT 387
4566: PPUSH
4567: CALL_OW 274
4571: PPUSH
4572: LD_INT 3
4574: PPUSH
4575: LD_INT 50
4577: PPUSH
4578: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 7500 ) ;
4582: LD_INT 476
4584: PPUSH
4585: CALL_OW 274
4589: PPUSH
4590: LD_INT 1
4592: PPUSH
4593: LD_INT 7500
4595: PPUSH
4596: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
4600: LD_INT 476
4602: PPUSH
4603: CALL_OW 274
4607: PPUSH
4608: LD_INT 2
4610: PPUSH
4611: LD_INT 4000
4613: PPUSH
4614: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
4618: LD_INT 476
4620: PPUSH
4621: CALL_OW 274
4625: PPUSH
4626: LD_INT 3
4628: PPUSH
4629: LD_INT 10
4631: PPUSH
4632: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
4636: LD_ADDR_EXP 47
4640: PUSH
4641: LD_STRING Powell
4643: PPUSH
4644: CALL_OW 25
4648: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
4649: LD_EXP 47
4653: PPUSH
4654: LD_INT 387
4656: PPUSH
4657: CALL_OW 52
// tmp := [ ] ;
4661: LD_ADDR_VAR 0 6
4665: PUSH
4666: EMPTY
4667: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
4668: LD_ADDR_EXP 14
4672: PUSH
4673: LD_STRING Lisa
4675: PPUSH
4676: LD_EXP 1
4680: NOT
4681: PPUSH
4682: LD_STRING 12p_
4684: PPUSH
4685: CALL 50250 0 3
4689: ST_TO_ADDR
// if Lisa then
4690: LD_EXP 14
4694: IFFALSE 4712
// tmp := tmp ^ Lisa ;
4696: LD_ADDR_VAR 0 6
4700: PUSH
4701: LD_VAR 0 6
4705: PUSH
4706: LD_EXP 14
4710: ADD
4711: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
4712: LD_ADDR_EXP 15
4716: PUSH
4717: LD_STRING Donaldson
4719: PPUSH
4720: LD_EXP 1
4724: NOT
4725: PPUSH
4726: LD_STRING 12p_
4728: PPUSH
4729: CALL 50250 0 3
4733: ST_TO_ADDR
// if Donaldson then
4734: LD_EXP 15
4738: IFFALSE 4756
// tmp := tmp ^ Donaldson ;
4740: LD_ADDR_VAR 0 6
4744: PUSH
4745: LD_VAR 0 6
4749: PUSH
4750: LD_EXP 15
4754: ADD
4755: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
4756: LD_ADDR_EXP 16
4760: PUSH
4761: LD_STRING Bobby
4763: PPUSH
4764: LD_EXP 1
4768: NOT
4769: PPUSH
4770: LD_STRING 12p_
4772: PPUSH
4773: CALL 50250 0 3
4777: ST_TO_ADDR
// if Bobby then
4778: LD_EXP 16
4782: IFFALSE 4800
// tmp := tmp ^ Bobby ;
4784: LD_ADDR_VAR 0 6
4788: PUSH
4789: LD_VAR 0 6
4793: PUSH
4794: LD_EXP 16
4798: ADD
4799: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
4800: LD_ADDR_EXP 17
4804: PUSH
4805: LD_STRING Cyrus
4807: PPUSH
4808: LD_EXP 1
4812: NOT
4813: PPUSH
4814: LD_STRING 12p_
4816: PPUSH
4817: CALL 50250 0 3
4821: ST_TO_ADDR
// if Cyrus then
4822: LD_EXP 17
4826: IFFALSE 4844
// tmp := tmp ^ Cyrus ;
4828: LD_ADDR_VAR 0 6
4832: PUSH
4833: LD_VAR 0 6
4837: PUSH
4838: LD_EXP 17
4842: ADD
4843: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
4844: LD_ADDR_EXP 19
4848: PUSH
4849: LD_STRING Brown
4851: PPUSH
4852: LD_EXP 1
4856: NOT
4857: PPUSH
4858: LD_STRING 12p_
4860: PPUSH
4861: CALL 50250 0 3
4865: ST_TO_ADDR
// if Brown then
4866: LD_EXP 19
4870: IFFALSE 4888
// tmp := tmp ^ Brown ;
4872: LD_ADDR_VAR 0 6
4876: PUSH
4877: LD_VAR 0 6
4881: PUSH
4882: LD_EXP 19
4886: ADD
4887: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
4888: LD_ADDR_EXP 20
4892: PUSH
4893: LD_STRING Gladstone
4895: PPUSH
4896: LD_EXP 1
4900: NOT
4901: PPUSH
4902: LD_STRING 12p_
4904: PPUSH
4905: CALL 50250 0 3
4909: ST_TO_ADDR
// if Gladstone then
4910: LD_EXP 20
4914: IFFALSE 4932
// tmp := tmp ^ Gladstone ;
4916: LD_ADDR_VAR 0 6
4920: PUSH
4921: LD_VAR 0 6
4925: PUSH
4926: LD_EXP 20
4930: ADD
4931: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
4932: LD_ADDR_EXP 21
4936: PUSH
4937: LD_STRING Houten
4939: PPUSH
4940: LD_EXP 1
4944: NOT
4945: PPUSH
4946: LD_STRING 12p_
4948: PPUSH
4949: CALL 50250 0 3
4953: ST_TO_ADDR
// if Houten then
4954: LD_EXP 21
4958: IFFALSE 4976
// tmp := tmp ^ Houten ;
4960: LD_ADDR_VAR 0 6
4964: PUSH
4965: LD_VAR 0 6
4969: PUSH
4970: LD_EXP 21
4974: ADD
4975: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
4976: LD_ADDR_EXP 22
4980: PUSH
4981: LD_STRING Cornel
4983: PPUSH
4984: LD_EXP 1
4988: NOT
4989: PPUSH
4990: LD_STRING 12p_
4992: PPUSH
4993: CALL 50250 0 3
4997: ST_TO_ADDR
// if Cornel then
4998: LD_EXP 22
5002: IFFALSE 5020
// tmp := tmp ^ Cornel ;
5004: LD_ADDR_VAR 0 6
5008: PUSH
5009: LD_VAR 0 6
5013: PUSH
5014: LD_EXP 22
5018: ADD
5019: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5020: LD_ADDR_EXP 23
5024: PUSH
5025: LD_STRING Gary
5027: PPUSH
5028: LD_EXP 1
5032: NOT
5033: PPUSH
5034: LD_STRING 12p_
5036: PPUSH
5037: CALL 50250 0 3
5041: ST_TO_ADDR
// if Gary then
5042: LD_EXP 23
5046: IFFALSE 5064
// tmp := tmp ^ Gary ;
5048: LD_ADDR_VAR 0 6
5052: PUSH
5053: LD_VAR 0 6
5057: PUSH
5058: LD_EXP 23
5062: ADD
5063: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5064: LD_ADDR_EXP 25
5068: PUSH
5069: LD_STRING Kikuchi
5071: PPUSH
5072: LD_EXP 1
5076: NOT
5077: PPUSH
5078: LD_STRING 12p_
5080: PPUSH
5081: CALL 50250 0 3
5085: ST_TO_ADDR
// if Kikuchi then
5086: LD_EXP 25
5090: IFFALSE 5108
// tmp := tmp ^ Kikuchi ;
5092: LD_ADDR_VAR 0 6
5096: PUSH
5097: LD_VAR 0 6
5101: PUSH
5102: LD_EXP 25
5106: ADD
5107: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5108: LD_ADDR_VAR 0 6
5112: PUSH
5113: LD_VAR 0 6
5117: PUSH
5118: LD_STRING 12p_others
5120: PPUSH
5121: CALL_OW 31
5125: UNION
5126: ST_TO_ADDR
// if tmp < 36 then
5127: LD_VAR 0 6
5131: PUSH
5132: LD_INT 36
5134: LESS
5135: IFFALSE 5202
// for i = 1 to 36 - tmp do
5137: LD_ADDR_VAR 0 2
5141: PUSH
5142: DOUBLE
5143: LD_INT 1
5145: DEC
5146: ST_TO_ADDR
5147: LD_INT 36
5149: PUSH
5150: LD_VAR 0 6
5154: MINUS
5155: PUSH
5156: FOR_TO
5157: IFFALSE 5200
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5159: LD_INT 1
5161: PPUSH
5162: LD_VAR 0 2
5166: PUSH
5167: LD_INT 4
5169: MOD
5170: PUSH
5171: LD_INT 1
5173: PLUS
5174: PPUSH
5175: LD_INT 10
5177: PPUSH
5178: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5182: LD_ADDR_VAR 0 6
5186: PUSH
5187: LD_VAR 0 6
5191: PUSH
5192: CALL_OW 44
5196: ADD
5197: ST_TO_ADDR
// end ;
5198: GO 5156
5200: POP
5201: POP
// for i in tmp do
5202: LD_ADDR_VAR 0 2
5206: PUSH
5207: LD_VAR 0 6
5211: PUSH
5212: FOR_IN
5213: IFFALSE 5238
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5215: LD_VAR 0 2
5219: PPUSH
5220: LD_INT 62
5222: PPUSH
5223: LD_INT 93
5225: PPUSH
5226: LD_INT 9
5228: PPUSH
5229: LD_INT 0
5231: PPUSH
5232: CALL_OW 50
5236: GO 5212
5238: POP
5239: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) ) ;
5240: LD_ADDR_EXP 74
5244: PUSH
5245: LD_EXP 74
5249: PPUSH
5250: LD_INT 4
5252: PPUSH
5253: LD_INT 22
5255: PUSH
5256: LD_INT 1
5258: PUSH
5259: EMPTY
5260: LIST
5261: LIST
5262: PPUSH
5263: CALL_OW 69
5267: PPUSH
5268: CALL_OW 1
5272: ST_TO_ADDR
// uc_side := 0 ;
5273: LD_ADDR_OWVAR 20
5277: PUSH
5278: LD_INT 0
5280: ST_TO_ADDR
// uc_nation := 0 ;
5281: LD_ADDR_OWVAR 21
5285: PUSH
5286: LD_INT 0
5288: ST_TO_ADDR
// for i = 1 to 4 do
5289: LD_ADDR_VAR 0 2
5293: PUSH
5294: DOUBLE
5295: LD_INT 1
5297: DEC
5298: ST_TO_ADDR
5299: LD_INT 4
5301: PUSH
5302: FOR_TO
5303: IFFALSE 5334
// begin InitHc ;
5305: CALL_OW 19
// hc_class := class_apeman ;
5309: LD_ADDR_OWVAR 28
5313: PUSH
5314: LD_INT 12
5316: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
5317: CALL_OW 44
5321: PPUSH
5322: LD_INT 11
5324: PPUSH
5325: LD_INT 0
5327: PPUSH
5328: CALL_OW 49
// end ;
5332: GO 5302
5334: POP
5335: POP
// end ;
5336: LD_VAR 0 1
5340: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
5341: LD_EXP 4
5345: NOT
5346: PUSH
5347: LD_INT 4
5349: PPUSH
5350: LD_INT 1
5352: PPUSH
5353: CALL 45324 0 2
5357: NOT
5358: AND
5359: IFFALSE 6131
5361: GO 5363
5363: DISABLE
5364: LD_INT 0
5366: PPUSH
5367: PPUSH
5368: PPUSH
// begin enable ;
5369: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
5370: LD_INT 22
5372: PUSH
5373: LD_INT 1
5375: PUSH
5376: EMPTY
5377: LIST
5378: LIST
5379: PUSH
5380: LD_INT 23
5382: PUSH
5383: LD_INT 1
5385: PUSH
5386: EMPTY
5387: LIST
5388: LIST
5389: PUSH
5390: LD_INT 30
5392: PUSH
5393: LD_INT 3
5395: PUSH
5396: EMPTY
5397: LIST
5398: LIST
5399: PUSH
5400: EMPTY
5401: LIST
5402: LIST
5403: LIST
5404: PPUSH
5405: CALL_OW 69
5409: NOT
5410: IFFALSE 5414
// exit ;
5412: GO 6131
// if Prob ( 40 ) then
5414: LD_INT 40
5416: PPUSH
5417: CALL_OW 13
5421: IFFALSE 5548
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5423: LD_INT 4
5425: PPUSH
5426: LD_INT 5
5428: PUSH
5429: LD_INT 1
5431: PUSH
5432: LD_INT 2
5434: PUSH
5435: LD_INT 7
5437: PUSH
5438: EMPTY
5439: LIST
5440: LIST
5441: LIST
5442: LIST
5443: PUSH
5444: LD_INT 5
5446: PUSH
5447: LD_INT 1
5449: PUSH
5450: LD_INT 2
5452: PUSH
5453: LD_INT 7
5455: PUSH
5456: EMPTY
5457: LIST
5458: LIST
5459: LIST
5460: LIST
5461: PUSH
5462: LD_INT 5
5464: PUSH
5465: LD_INT 1
5467: PUSH
5468: LD_INT 2
5470: PUSH
5471: LD_INT 7
5473: PUSH
5474: EMPTY
5475: LIST
5476: LIST
5477: LIST
5478: LIST
5479: PUSH
5480: LD_INT 5
5482: PUSH
5483: LD_INT 1
5485: PUSH
5486: LD_INT 2
5488: PUSH
5489: LD_INT 6
5491: PUSH
5492: EMPTY
5493: LIST
5494: LIST
5495: LIST
5496: LIST
5497: PUSH
5498: LD_INT 5
5500: PUSH
5501: LD_INT 1
5503: PUSH
5504: LD_INT 2
5506: PUSH
5507: LD_INT 6
5509: PUSH
5510: EMPTY
5511: LIST
5512: LIST
5513: LIST
5514: LIST
5515: PUSH
5516: LD_INT 5
5518: PUSH
5519: LD_INT 1
5521: PUSH
5522: LD_INT 2
5524: PUSH
5525: LD_INT 6
5527: PUSH
5528: EMPTY
5529: LIST
5530: LIST
5531: LIST
5532: LIST
5533: PUSH
5534: EMPTY
5535: LIST
5536: LIST
5537: LIST
5538: LIST
5539: LIST
5540: LIST
5541: PPUSH
5542: CALL 43906 0 2
// end else
5546: GO 5671
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5548: LD_INT 4
5550: PPUSH
5551: LD_INT 5
5553: PUSH
5554: LD_INT 1
5556: PUSH
5557: LD_INT 2
5559: PUSH
5560: LD_INT 7
5562: PUSH
5563: EMPTY
5564: LIST
5565: LIST
5566: LIST
5567: LIST
5568: PUSH
5569: LD_INT 5
5571: PUSH
5572: LD_INT 1
5574: PUSH
5575: LD_INT 2
5577: PUSH
5578: LD_INT 9
5580: PUSH
5581: EMPTY
5582: LIST
5583: LIST
5584: LIST
5585: LIST
5586: PUSH
5587: LD_INT 5
5589: PUSH
5590: LD_INT 1
5592: PUSH
5593: LD_INT 2
5595: PUSH
5596: LD_INT 9
5598: PUSH
5599: EMPTY
5600: LIST
5601: LIST
5602: LIST
5603: LIST
5604: PUSH
5605: LD_INT 5
5607: PUSH
5608: LD_INT 1
5610: PUSH
5611: LD_INT 2
5613: PUSH
5614: LD_INT 6
5616: PUSH
5617: EMPTY
5618: LIST
5619: LIST
5620: LIST
5621: LIST
5622: PUSH
5623: LD_INT 5
5625: PUSH
5626: LD_INT 1
5628: PUSH
5629: LD_INT 2
5631: PUSH
5632: LD_INT 6
5634: PUSH
5635: EMPTY
5636: LIST
5637: LIST
5638: LIST
5639: LIST
5640: PUSH
5641: LD_INT 5
5643: PUSH
5644: LD_INT 1
5646: PUSH
5647: LD_INT 2
5649: PUSH
5650: LD_INT 6
5652: PUSH
5653: EMPTY
5654: LIST
5655: LIST
5656: LIST
5657: LIST
5658: PUSH
5659: EMPTY
5660: LIST
5661: LIST
5662: LIST
5663: LIST
5664: LIST
5665: LIST
5666: PPUSH
5667: CALL 43906 0 2
// end ; repeat wait ( 0 0$1 ) ;
5671: LD_INT 35
5673: PPUSH
5674: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
5678: LD_INT 4
5680: PPUSH
5681: LD_INT 1
5683: PPUSH
5684: CALL 45324 0 2
5688: PUSH
5689: LD_INT 6
5691: GREATEREQUAL
5692: IFFALSE 5671
// wait ( 0 0$30 ) ;
5694: LD_INT 1050
5696: PPUSH
5697: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
5701: LD_ADDR_VAR 0 2
5705: PUSH
5706: LD_INT 4
5708: PPUSH
5709: LD_INT 1
5711: PPUSH
5712: CALL 45324 0 2
5716: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
5717: LD_ADDR_EXP 93
5721: PUSH
5722: LD_EXP 93
5726: PPUSH
5727: LD_INT 4
5729: PPUSH
5730: LD_EXP 93
5734: PUSH
5735: LD_INT 4
5737: ARRAY
5738: PUSH
5739: LD_VAR 0 2
5743: DIFF
5744: PPUSH
5745: CALL_OW 1
5749: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5750: LD_ADDR_VAR 0 3
5754: PUSH
5755: LD_INT 0
5757: PPUSH
5758: LD_INT 2
5760: PPUSH
5761: CALL_OW 12
5765: ST_TO_ADDR
// if target then
5766: LD_VAR 0 3
5770: IFFALSE 5898
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5772: LD_ADDR_VAR 0 2
5776: PUSH
5777: LD_VAR 0 2
5781: PPUSH
5782: LD_INT 24
5784: PUSH
5785: LD_INT 250
5787: PUSH
5788: EMPTY
5789: LIST
5790: LIST
5791: PPUSH
5792: CALL_OW 72
5796: ST_TO_ADDR
// for i in tmp do
5797: LD_ADDR_VAR 0 1
5801: PUSH
5802: LD_VAR 0 2
5806: PUSH
5807: FOR_IN
5808: IFFALSE 5848
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
5810: LD_VAR 0 1
5814: PPUSH
5815: LD_INT 114
5817: PPUSH
5818: LD_INT 108
5820: PPUSH
5821: CALL_OW 297
5825: PUSH
5826: LD_INT 9
5828: GREATER
5829: IFFALSE 5846
// ComMoveXY ( i , 114 , 108 ) ;
5831: LD_VAR 0 1
5835: PPUSH
5836: LD_INT 114
5838: PPUSH
5839: LD_INT 108
5841: PPUSH
5842: CALL_OW 111
5846: GO 5807
5848: POP
5849: POP
// wait ( 0 0$1 ) ;
5850: LD_INT 35
5852: PPUSH
5853: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
5857: LD_VAR 0 2
5861: PPUSH
5862: LD_INT 92
5864: PUSH
5865: LD_INT 114
5867: PUSH
5868: LD_INT 108
5870: PUSH
5871: LD_INT 9
5873: PUSH
5874: EMPTY
5875: LIST
5876: LIST
5877: LIST
5878: LIST
5879: PPUSH
5880: CALL_OW 72
5884: PUSH
5885: LD_VAR 0 2
5889: PUSH
5890: LD_INT 1
5892: MINUS
5893: GREATEREQUAL
5894: IFFALSE 5772
// end else
5896: GO 6022
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5898: LD_ADDR_VAR 0 2
5902: PUSH
5903: LD_VAR 0 2
5907: PPUSH
5908: LD_INT 24
5910: PUSH
5911: LD_INT 250
5913: PUSH
5914: EMPTY
5915: LIST
5916: LIST
5917: PPUSH
5918: CALL_OW 72
5922: ST_TO_ADDR
// for i in tmp do
5923: LD_ADDR_VAR 0 1
5927: PUSH
5928: LD_VAR 0 2
5932: PUSH
5933: FOR_IN
5934: IFFALSE 5974
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
5936: LD_VAR 0 1
5940: PPUSH
5941: LD_INT 129
5943: PPUSH
5944: LD_INT 139
5946: PPUSH
5947: CALL_OW 297
5951: PUSH
5952: LD_INT 9
5954: GREATER
5955: IFFALSE 5972
// ComMoveXY ( i , 129 , 139 ) ;
5957: LD_VAR 0 1
5961: PPUSH
5962: LD_INT 129
5964: PPUSH
5965: LD_INT 139
5967: PPUSH
5968: CALL_OW 111
5972: GO 5933
5974: POP
5975: POP
// wait ( 0 0$1 ) ;
5976: LD_INT 35
5978: PPUSH
5979: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
5983: LD_VAR 0 2
5987: PPUSH
5988: LD_INT 92
5990: PUSH
5991: LD_INT 129
5993: PUSH
5994: LD_INT 139
5996: PUSH
5997: LD_INT 9
5999: PUSH
6000: EMPTY
6001: LIST
6002: LIST
6003: LIST
6004: LIST
6005: PPUSH
6006: CALL_OW 72
6010: PUSH
6011: LD_VAR 0 2
6015: PUSH
6016: LD_INT 1
6018: MINUS
6019: GREATEREQUAL
6020: IFFALSE 5898
// end ; repeat wait ( 0 0$1 ) ;
6022: LD_INT 35
6024: PPUSH
6025: CALL_OW 67
// for i in tmp do
6029: LD_ADDR_VAR 0 1
6033: PUSH
6034: LD_VAR 0 2
6038: PUSH
6039: FOR_IN
6040: IFFALSE 6122
// begin if GetLives ( i ) > 251 then
6042: LD_VAR 0 1
6046: PPUSH
6047: CALL_OW 256
6051: PUSH
6052: LD_INT 251
6054: GREATER
6055: IFFALSE 6093
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6057: LD_VAR 0 1
6061: PPUSH
6062: LD_INT 81
6064: PUSH
6065: LD_INT 1
6067: PUSH
6068: EMPTY
6069: LIST
6070: LIST
6071: PPUSH
6072: CALL_OW 69
6076: PPUSH
6077: LD_VAR 0 1
6081: PPUSH
6082: CALL_OW 74
6086: PPUSH
6087: CALL_OW 115
6091: GO 6120
// if IsDead ( i ) then
6093: LD_VAR 0 1
6097: PPUSH
6098: CALL_OW 301
6102: IFFALSE 6120
// tmp := tmp diff i ;
6104: LD_ADDR_VAR 0 2
6108: PUSH
6109: LD_VAR 0 2
6113: PUSH
6114: LD_VAR 0 1
6118: DIFF
6119: ST_TO_ADDR
// end ;
6120: GO 6039
6122: POP
6123: POP
// until not tmp ;
6124: LD_VAR 0 2
6128: NOT
6129: IFFALSE 6022
// end ;
6131: PPOPN 3
6133: END
// every 30 30$00 trigger not americanDestroyed do
6134: LD_EXP 4
6138: NOT
6139: IFFALSE 6204
6141: GO 6143
6143: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 10 10$00 ] [ Difficulty ] ) ;
6144: LD_INT 63000
6146: PUSH
6147: LD_INT 42000
6149: PUSH
6150: LD_INT 21000
6152: PUSH
6153: EMPTY
6154: LIST
6155: LIST
6156: LIST
6157: PUSH
6158: LD_OWVAR 67
6162: ARRAY
6163: PPUSH
6164: CALL_OW 67
// if americanDestroyed then
6168: LD_EXP 4
6172: IFFALSE 6176
// exit ;
6174: GO 6204
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6176: LD_INT 4
6178: PPUSH
6179: LD_INT 5
6181: PUSH
6182: LD_INT 3
6184: PUSH
6185: LD_INT 1
6187: PUSH
6188: LD_INT 8
6190: PUSH
6191: EMPTY
6192: LIST
6193: LIST
6194: LIST
6195: LIST
6196: PUSH
6197: EMPTY
6198: LIST
6199: PPUSH
6200: CALL 43906 0 2
// end ; end_of_file
6204: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6205: LD_INT 0
6207: PPUSH
6208: PPUSH
6209: PPUSH
6210: PPUSH
6211: PPUSH
// side := 2 ;
6212: LD_ADDR_VAR 0 5
6216: PUSH
6217: LD_INT 2
6219: ST_TO_ADDR
// InitHc ;
6220: CALL_OW 19
// uc_side := side ;
6224: LD_ADDR_OWVAR 20
6228: PUSH
6229: LD_VAR 0 5
6233: ST_TO_ADDR
// uc_nation := 2 ;
6234: LD_ADDR_OWVAR 21
6238: PUSH
6239: LD_INT 2
6241: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6242: LD_ADDR_VAR 0 4
6246: PUSH
6247: LD_INT 22
6249: PUSH
6250: LD_VAR 0 5
6254: PUSH
6255: EMPTY
6256: LIST
6257: LIST
6258: PUSH
6259: LD_INT 30
6261: PUSH
6262: LD_INT 32
6264: PUSH
6265: EMPTY
6266: LIST
6267: LIST
6268: PUSH
6269: LD_INT 58
6271: PUSH
6272: EMPTY
6273: LIST
6274: PUSH
6275: EMPTY
6276: LIST
6277: LIST
6278: LIST
6279: PPUSH
6280: CALL_OW 69
6284: ST_TO_ADDR
// for i = 1 to 10 do
6285: LD_ADDR_VAR 0 2
6289: PUSH
6290: DOUBLE
6291: LD_INT 1
6293: DEC
6294: ST_TO_ADDR
6295: LD_INT 10
6297: PUSH
6298: FOR_TO
6299: IFFALSE 6371
// begin uc_nation := nation_nature ;
6301: LD_ADDR_OWVAR 21
6305: PUSH
6306: LD_INT 0
6308: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6309: LD_ADDR_OWVAR 28
6313: PUSH
6314: LD_INT 15
6316: ST_TO_ADDR
// hc_gallery :=  ;
6317: LD_ADDR_OWVAR 33
6321: PUSH
6322: LD_STRING 
6324: ST_TO_ADDR
// hc_name :=  ;
6325: LD_ADDR_OWVAR 26
6329: PUSH
6330: LD_STRING 
6332: ST_TO_ADDR
// un := CreateHuman ;
6333: LD_ADDR_VAR 0 3
6337: PUSH
6338: CALL_OW 44
6342: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
6343: LD_VAR 0 3
6347: PPUSH
6348: LD_VAR 0 4
6352: PUSH
6353: LD_VAR 0 4
6357: PUSH
6358: LD_VAR 0 2
6362: MINUS
6363: ARRAY
6364: PPUSH
6365: CALL_OW 52
// end ;
6369: GO 6298
6371: POP
6372: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
6373: LD_INT 503
6375: PPUSH
6376: LD_INT 27
6378: PPUSH
6379: LD_STRING 
6381: PPUSH
6382: LD_INT 8
6384: PUSH
6385: LD_INT 9
6387: PUSH
6388: LD_INT 10
6390: PUSH
6391: EMPTY
6392: LIST
6393: LIST
6394: LIST
6395: PUSH
6396: LD_OWVAR 67
6400: ARRAY
6401: PPUSH
6402: LD_INT 3000
6404: PUSH
6405: LD_INT 500
6407: PUSH
6408: LD_INT 150
6410: PUSH
6411: EMPTY
6412: LIST
6413: LIST
6414: LIST
6415: PPUSH
6416: LD_INT 16
6418: PUSH
6419: LD_INT 6
6421: PUSH
6422: LD_INT 6
6424: PUSH
6425: LD_INT 6
6427: PUSH
6428: EMPTY
6429: LIST
6430: LIST
6431: LIST
6432: LIST
6433: PPUSH
6434: CALL 60774 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
6438: LD_ADDR_EXP 74
6442: PUSH
6443: LD_EXP 74
6447: PPUSH
6448: LD_INT 1
6450: PPUSH
6451: LD_INT 22
6453: PUSH
6454: LD_VAR 0 5
6458: PUSH
6459: EMPTY
6460: LIST
6461: LIST
6462: PUSH
6463: LD_INT 23
6465: PUSH
6466: LD_INT 2
6468: PUSH
6469: EMPTY
6470: LIST
6471: LIST
6472: PUSH
6473: LD_INT 3
6475: PUSH
6476: LD_INT 21
6478: PUSH
6479: LD_INT 2
6481: PUSH
6482: EMPTY
6483: LIST
6484: LIST
6485: PUSH
6486: EMPTY
6487: LIST
6488: LIST
6489: PUSH
6490: EMPTY
6491: LIST
6492: LIST
6493: LIST
6494: PPUSH
6495: CALL_OW 69
6499: PPUSH
6500: CALL_OW 1
6504: ST_TO_ADDR
// end ;
6505: LD_VAR 0 1
6509: RET
// export Omar ; export function PrepareOmarAli ; begin
6510: LD_INT 0
6512: PPUSH
// uc_side := 5 ;
6513: LD_ADDR_OWVAR 20
6517: PUSH
6518: LD_INT 5
6520: ST_TO_ADDR
// uc_nation := 2 ;
6521: LD_ADDR_OWVAR 21
6525: PUSH
6526: LD_INT 2
6528: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
6529: LD_ADDR_EXP 48
6533: PUSH
6534: LD_STRING Omar
6536: PPUSH
6537: CALL_OW 25
6541: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
6542: LD_EXP 48
6546: PPUSH
6547: LD_INT 330
6549: PPUSH
6550: LD_INT 244
6552: PPUSH
6553: LD_INT 0
6555: PPUSH
6556: CALL_OW 48
// ComMoveUnit ( Omar , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Omar ) ) ;
6560: LD_EXP 48
6564: PPUSH
6565: LD_INT 22
6567: PUSH
6568: LD_INT 7
6570: PUSH
6571: EMPTY
6572: LIST
6573: LIST
6574: PPUSH
6575: CALL_OW 69
6579: PPUSH
6580: LD_EXP 48
6584: PPUSH
6585: CALL_OW 74
6589: PPUSH
6590: CALL_OW 112
// end ; end_of_file
6594: LD_VAR 0 1
6598: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
6599: LD_INT 0
6601: PPUSH
6602: PPUSH
6603: PPUSH
6604: PPUSH
6605: PPUSH
// side := 8 ;
6606: LD_ADDR_VAR 0 3
6610: PUSH
6611: LD_INT 8
6613: ST_TO_ADDR
// InitHc ;
6614: CALL_OW 19
// uc_side := side ;
6618: LD_ADDR_OWVAR 20
6622: PUSH
6623: LD_VAR 0 3
6627: ST_TO_ADDR
// uc_nation := 2 ;
6628: LD_ADDR_OWVAR 21
6632: PUSH
6633: LD_INT 2
6635: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6636: LD_ADDR_VAR 0 2
6640: PUSH
6641: LD_INT 22
6643: PUSH
6644: LD_VAR 0 3
6648: PUSH
6649: EMPTY
6650: LIST
6651: LIST
6652: PUSH
6653: LD_INT 21
6655: PUSH
6656: LD_INT 3
6658: PUSH
6659: EMPTY
6660: LIST
6661: LIST
6662: PUSH
6663: EMPTY
6664: LIST
6665: LIST
6666: PPUSH
6667: CALL_OW 69
6671: PUSH
6672: FOR_IN
6673: IFFALSE 6689
// SetBLevel ( i , 10 ) ;
6675: LD_VAR 0 2
6679: PPUSH
6680: LD_INT 10
6682: PPUSH
6683: CALL_OW 241
6687: GO 6672
6689: POP
6690: POP
// Schulz := NewCharacter ( Schulz ) ;
6691: LD_ADDR_EXP 49
6695: PUSH
6696: LD_STRING Schulz
6698: PPUSH
6699: CALL_OW 25
6703: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
6704: LD_ADDR_EXP 50
6708: PUSH
6709: LD_STRING Kozlov
6711: PPUSH
6712: LD_INT 0
6714: PPUSH
6715: LD_STRING 
6717: PPUSH
6718: CALL 50250 0 3
6722: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
6723: LD_EXP 50
6727: PPUSH
6728: LD_INT 22
6730: PUSH
6731: LD_INT 8
6733: PUSH
6734: EMPTY
6735: LIST
6736: LIST
6737: PUSH
6738: LD_INT 23
6740: PUSH
6741: LD_INT 3
6743: PUSH
6744: EMPTY
6745: LIST
6746: LIST
6747: PUSH
6748: LD_INT 30
6750: PUSH
6751: LD_INT 8
6753: PUSH
6754: EMPTY
6755: LIST
6756: LIST
6757: PUSH
6758: EMPTY
6759: LIST
6760: LIST
6761: LIST
6762: PPUSH
6763: CALL_OW 69
6767: PUSH
6768: LD_INT 1
6770: ARRAY
6771: PPUSH
6772: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
6776: LD_EXP 50
6780: PPUSH
6781: LD_INT 3
6783: PPUSH
6784: LD_INT 10
6786: PPUSH
6787: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6791: LD_ADDR_VAR 0 5
6795: PUSH
6796: LD_INT 22
6798: PUSH
6799: LD_VAR 0 3
6803: PUSH
6804: EMPTY
6805: LIST
6806: LIST
6807: PUSH
6808: LD_INT 30
6810: PUSH
6811: LD_INT 32
6813: PUSH
6814: EMPTY
6815: LIST
6816: LIST
6817: PUSH
6818: LD_INT 58
6820: PUSH
6821: EMPTY
6822: LIST
6823: PUSH
6824: EMPTY
6825: LIST
6826: LIST
6827: LIST
6828: PPUSH
6829: CALL_OW 69
6833: ST_TO_ADDR
// for i = 1 to 10 do
6834: LD_ADDR_VAR 0 2
6838: PUSH
6839: DOUBLE
6840: LD_INT 1
6842: DEC
6843: ST_TO_ADDR
6844: LD_INT 10
6846: PUSH
6847: FOR_TO
6848: IFFALSE 6920
// begin uc_nation := nation_nature ;
6850: LD_ADDR_OWVAR 21
6854: PUSH
6855: LD_INT 0
6857: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6858: LD_ADDR_OWVAR 28
6862: PUSH
6863: LD_INT 15
6865: ST_TO_ADDR
// hc_gallery :=  ;
6866: LD_ADDR_OWVAR 33
6870: PUSH
6871: LD_STRING 
6873: ST_TO_ADDR
// hc_name :=  ;
6874: LD_ADDR_OWVAR 26
6878: PUSH
6879: LD_STRING 
6881: ST_TO_ADDR
// un := CreateHuman ;
6882: LD_ADDR_VAR 0 4
6886: PUSH
6887: CALL_OW 44
6891: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
6892: LD_VAR 0 4
6896: PPUSH
6897: LD_VAR 0 5
6901: PUSH
6902: LD_VAR 0 5
6906: PUSH
6907: LD_VAR 0 2
6911: MINUS
6912: ARRAY
6913: PPUSH
6914: CALL_OW 52
// end ;
6918: GO 6847
6920: POP
6921: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
6922: LD_INT 324
6924: PPUSH
6925: LD_INT 3
6927: PPUSH
6928: LD_STRING 
6930: PPUSH
6931: LD_INT 8
6933: PUSH
6934: LD_INT 9
6936: PUSH
6937: LD_INT 10
6939: PUSH
6940: EMPTY
6941: LIST
6942: LIST
6943: LIST
6944: PUSH
6945: LD_OWVAR 67
6949: ARRAY
6950: PPUSH
6951: LD_INT 3000
6953: PUSH
6954: LD_INT 500
6956: PUSH
6957: LD_INT 150
6959: PUSH
6960: EMPTY
6961: LIST
6962: LIST
6963: LIST
6964: PPUSH
6965: LD_INT 16
6967: PUSH
6968: LD_INT 6
6970: PUSH
6971: LD_INT 6
6973: PUSH
6974: LD_INT 8
6976: PUSH
6977: EMPTY
6978: LIST
6979: LIST
6980: LIST
6981: LIST
6982: PPUSH
6983: CALL 60774 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
6987: LD_ADDR_EXP 74
6991: PUSH
6992: LD_EXP 74
6996: PPUSH
6997: LD_INT 3
6999: PPUSH
7000: LD_INT 22
7002: PUSH
7003: LD_VAR 0 3
7007: PUSH
7008: EMPTY
7009: LIST
7010: LIST
7011: PUSH
7012: LD_INT 23
7014: PUSH
7015: LD_INT 2
7017: PUSH
7018: EMPTY
7019: LIST
7020: LIST
7021: PUSH
7022: LD_INT 3
7024: PUSH
7025: LD_INT 21
7027: PUSH
7028: LD_INT 2
7030: PUSH
7031: EMPTY
7032: LIST
7033: LIST
7034: PUSH
7035: EMPTY
7036: LIST
7037: LIST
7038: PUSH
7039: EMPTY
7040: LIST
7041: LIST
7042: LIST
7043: PPUSH
7044: CALL_OW 69
7048: PUSH
7049: LD_EXP 49
7053: DIFF
7054: PPUSH
7055: CALL_OW 1
7059: ST_TO_ADDR
// end ;
7060: LD_VAR 0 1
7064: RET
// export function BuildKozlovBomb ; begin
7065: LD_INT 0
7067: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7068: LD_INT 332
7070: PPUSH
7071: CALL_OW 302
7075: NOT
7076: PUSH
7077: LD_INT 336
7079: PPUSH
7080: CALL_OW 302
7084: NOT
7085: OR
7086: IFFALSE 7090
// exit ;
7088: GO 7187
// ComChangeProfession ( Kozlov , 4 ) ;
7090: LD_EXP 50
7094: PPUSH
7095: LD_INT 4
7097: PPUSH
7098: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7102: LD_INT 336
7104: PPUSH
7105: LD_INT 25
7107: PPUSH
7108: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7112: LD_INT 35
7114: PPUSH
7115: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7119: LD_INT 25
7121: PPUSH
7122: LD_INT 8
7124: PPUSH
7125: CALL_OW 321
7129: PUSH
7130: LD_INT 2
7132: EQUAL
7133: IFFALSE 7112
// ComExitBuilding ( Kozlov ) ;
7135: LD_EXP 50
7139: PPUSH
7140: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
7144: LD_EXP 50
7148: PPUSH
7149: LD_INT 332
7151: PPUSH
7152: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
7156: LD_EXP 50
7160: PPUSH
7161: LD_INT 3
7163: PPUSH
7164: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
7168: LD_INT 332
7170: PPUSH
7171: LD_INT 23
7173: PPUSH
7174: LD_INT 3
7176: PPUSH
7177: LD_INT 1
7179: PPUSH
7180: LD_INT 48
7182: PPUSH
7183: CALL_OW 125
// end ;
7187: LD_VAR 0 1
7191: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
7192: LD_EXP 3
7196: NOT
7197: PUSH
7198: LD_INT 3
7200: PPUSH
7201: LD_INT 1
7203: PPUSH
7204: CALL 45324 0 2
7208: NOT
7209: AND
7210: IFFALSE 8050
7212: GO 7214
7214: DISABLE
7215: LD_INT 0
7217: PPUSH
7218: PPUSH
7219: PPUSH
// begin enable ;
7220: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
7221: LD_INT 22
7223: PUSH
7224: LD_INT 8
7226: PUSH
7227: EMPTY
7228: LIST
7229: LIST
7230: PUSH
7231: LD_INT 23
7233: PUSH
7234: LD_INT 2
7236: PUSH
7237: EMPTY
7238: LIST
7239: LIST
7240: PUSH
7241: LD_INT 30
7243: PUSH
7244: LD_INT 3
7246: PUSH
7247: EMPTY
7248: LIST
7249: LIST
7250: PUSH
7251: EMPTY
7252: LIST
7253: LIST
7254: LIST
7255: PPUSH
7256: CALL_OW 69
7260: NOT
7261: IFFALSE 7265
// exit ;
7263: GO 8050
// if Prob ( 40 ) then
7265: LD_INT 40
7267: PPUSH
7268: CALL_OW 13
7272: IFFALSE 7399
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7274: LD_INT 3
7276: PPUSH
7277: LD_INT 14
7279: PUSH
7280: LD_INT 1
7282: PUSH
7283: LD_INT 2
7285: PUSH
7286: LD_INT 28
7288: PUSH
7289: EMPTY
7290: LIST
7291: LIST
7292: LIST
7293: LIST
7294: PUSH
7295: LD_INT 14
7297: PUSH
7298: LD_INT 1
7300: PUSH
7301: LD_INT 2
7303: PUSH
7304: LD_INT 28
7306: PUSH
7307: EMPTY
7308: LIST
7309: LIST
7310: LIST
7311: LIST
7312: PUSH
7313: LD_INT 14
7315: PUSH
7316: LD_INT 1
7318: PUSH
7319: LD_INT 2
7321: PUSH
7322: LD_INT 28
7324: PUSH
7325: EMPTY
7326: LIST
7327: LIST
7328: LIST
7329: LIST
7330: PUSH
7331: LD_INT 14
7333: PUSH
7334: LD_INT 1
7336: PUSH
7337: LD_INT 2
7339: PUSH
7340: LD_INT 28
7342: PUSH
7343: EMPTY
7344: LIST
7345: LIST
7346: LIST
7347: LIST
7348: PUSH
7349: LD_INT 14
7351: PUSH
7352: LD_INT 1
7354: PUSH
7355: LD_INT 2
7357: PUSH
7358: LD_INT 28
7360: PUSH
7361: EMPTY
7362: LIST
7363: LIST
7364: LIST
7365: LIST
7366: PUSH
7367: LD_INT 14
7369: PUSH
7370: LD_INT 1
7372: PUSH
7373: LD_INT 2
7375: PUSH
7376: LD_INT 26
7378: PUSH
7379: EMPTY
7380: LIST
7381: LIST
7382: LIST
7383: LIST
7384: PUSH
7385: EMPTY
7386: LIST
7387: LIST
7388: LIST
7389: LIST
7390: LIST
7391: LIST
7392: PPUSH
7393: CALL 43906 0 2
// end else
7397: GO 7590
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7399: LD_INT 3
7401: PPUSH
7402: LD_INT 14
7404: PUSH
7405: LD_INT 1
7407: PUSH
7408: LD_INT 2
7410: PUSH
7411: LD_INT 27
7413: PUSH
7414: LD_INT 26
7416: PUSH
7417: LD_INT 26
7419: PUSH
7420: EMPTY
7421: LIST
7422: LIST
7423: LIST
7424: PUSH
7425: LD_OWVAR 67
7429: ARRAY
7430: PUSH
7431: EMPTY
7432: LIST
7433: LIST
7434: LIST
7435: LIST
7436: PUSH
7437: LD_INT 14
7439: PUSH
7440: LD_INT 1
7442: PUSH
7443: LD_INT 2
7445: PUSH
7446: LD_INT 27
7448: PUSH
7449: LD_INT 26
7451: PUSH
7452: LD_INT 26
7454: PUSH
7455: EMPTY
7456: LIST
7457: LIST
7458: LIST
7459: PUSH
7460: LD_OWVAR 67
7464: ARRAY
7465: PUSH
7466: EMPTY
7467: LIST
7468: LIST
7469: LIST
7470: LIST
7471: PUSH
7472: LD_INT 14
7474: PUSH
7475: LD_INT 1
7477: PUSH
7478: LD_INT 2
7480: PUSH
7481: LD_INT 26
7483: PUSH
7484: LD_INT 26
7486: PUSH
7487: LD_INT 29
7489: PUSH
7490: EMPTY
7491: LIST
7492: LIST
7493: LIST
7494: PUSH
7495: LD_OWVAR 67
7499: ARRAY
7500: PUSH
7501: EMPTY
7502: LIST
7503: LIST
7504: LIST
7505: LIST
7506: PUSH
7507: LD_INT 13
7509: PUSH
7510: LD_INT 1
7512: PUSH
7513: LD_INT 2
7515: PUSH
7516: LD_INT 26
7518: PUSH
7519: LD_INT 29
7521: PUSH
7522: LD_INT 29
7524: PUSH
7525: EMPTY
7526: LIST
7527: LIST
7528: LIST
7529: PUSH
7530: LD_OWVAR 67
7534: ARRAY
7535: PUSH
7536: EMPTY
7537: LIST
7538: LIST
7539: LIST
7540: LIST
7541: PUSH
7542: LD_INT 13
7544: PUSH
7545: LD_INT 1
7547: PUSH
7548: LD_INT 2
7550: PUSH
7551: LD_INT 29
7553: PUSH
7554: EMPTY
7555: LIST
7556: LIST
7557: LIST
7558: LIST
7559: PUSH
7560: LD_INT 14
7562: PUSH
7563: LD_INT 1
7565: PUSH
7566: LD_INT 2
7568: PUSH
7569: LD_INT 26
7571: PUSH
7572: EMPTY
7573: LIST
7574: LIST
7575: LIST
7576: LIST
7577: PUSH
7578: EMPTY
7579: LIST
7580: LIST
7581: LIST
7582: LIST
7583: LIST
7584: LIST
7585: PPUSH
7586: CALL 43906 0 2
// end ; repeat wait ( 0 0$1 ) ;
7590: LD_INT 35
7592: PPUSH
7593: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
7597: LD_INT 3
7599: PPUSH
7600: LD_INT 1
7602: PPUSH
7603: CALL 45324 0 2
7607: PUSH
7608: LD_INT 6
7610: GREATEREQUAL
7611: IFFALSE 7590
// wait ( 0 0$30 ) ;
7613: LD_INT 1050
7615: PPUSH
7616: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
7620: LD_ADDR_VAR 0 2
7624: PUSH
7625: LD_INT 3
7627: PPUSH
7628: LD_INT 1
7630: PPUSH
7631: CALL 45324 0 2
7635: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
7636: LD_ADDR_EXP 93
7640: PUSH
7641: LD_EXP 93
7645: PPUSH
7646: LD_INT 3
7648: PPUSH
7649: LD_EXP 93
7653: PUSH
7654: LD_INT 3
7656: ARRAY
7657: PUSH
7658: LD_VAR 0 2
7662: DIFF
7663: PPUSH
7664: CALL_OW 1
7668: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
7669: LD_ADDR_VAR 0 3
7673: PUSH
7674: LD_INT 0
7676: PPUSH
7677: LD_INT 2
7679: PPUSH
7680: CALL_OW 12
7684: ST_TO_ADDR
// if target then
7685: LD_VAR 0 3
7689: IFFALSE 7817
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7691: LD_ADDR_VAR 0 2
7695: PUSH
7696: LD_VAR 0 2
7700: PPUSH
7701: LD_INT 24
7703: PUSH
7704: LD_INT 250
7706: PUSH
7707: EMPTY
7708: LIST
7709: LIST
7710: PPUSH
7711: CALL_OW 72
7715: ST_TO_ADDR
// for i in tmp do
7716: LD_ADDR_VAR 0 1
7720: PUSH
7721: LD_VAR 0 2
7725: PUSH
7726: FOR_IN
7727: IFFALSE 7767
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
7729: LD_VAR 0 1
7733: PPUSH
7734: LD_INT 89
7736: PPUSH
7737: LD_INT 71
7739: PPUSH
7740: CALL_OW 297
7744: PUSH
7745: LD_INT 9
7747: GREATER
7748: IFFALSE 7765
// ComMoveXY ( i , 89 , 71 ) ;
7750: LD_VAR 0 1
7754: PPUSH
7755: LD_INT 89
7757: PPUSH
7758: LD_INT 71
7760: PPUSH
7761: CALL_OW 111
7765: GO 7726
7767: POP
7768: POP
// wait ( 0 0$1 ) ;
7769: LD_INT 35
7771: PPUSH
7772: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
7776: LD_VAR 0 2
7780: PPUSH
7781: LD_INT 92
7783: PUSH
7784: LD_INT 89
7786: PUSH
7787: LD_INT 71
7789: PUSH
7790: LD_INT 9
7792: PUSH
7793: EMPTY
7794: LIST
7795: LIST
7796: LIST
7797: LIST
7798: PPUSH
7799: CALL_OW 72
7803: PUSH
7804: LD_VAR 0 2
7808: PUSH
7809: LD_INT 1
7811: MINUS
7812: GREATEREQUAL
7813: IFFALSE 7691
// end else
7815: GO 7941
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7817: LD_ADDR_VAR 0 2
7821: PUSH
7822: LD_VAR 0 2
7826: PPUSH
7827: LD_INT 24
7829: PUSH
7830: LD_INT 250
7832: PUSH
7833: EMPTY
7834: LIST
7835: LIST
7836: PPUSH
7837: CALL_OW 72
7841: ST_TO_ADDR
// for i in tmp do
7842: LD_ADDR_VAR 0 1
7846: PUSH
7847: LD_VAR 0 2
7851: PUSH
7852: FOR_IN
7853: IFFALSE 7893
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
7855: LD_VAR 0 1
7859: PPUSH
7860: LD_INT 147
7862: PPUSH
7863: LD_INT 4
7865: PPUSH
7866: CALL_OW 297
7870: PUSH
7871: LD_INT 9
7873: GREATER
7874: IFFALSE 7891
// ComMoveXY ( i , 147 , 4 ) ;
7876: LD_VAR 0 1
7880: PPUSH
7881: LD_INT 147
7883: PPUSH
7884: LD_INT 4
7886: PPUSH
7887: CALL_OW 111
7891: GO 7852
7893: POP
7894: POP
// wait ( 0 0$1 ) ;
7895: LD_INT 35
7897: PPUSH
7898: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
7902: LD_VAR 0 2
7906: PPUSH
7907: LD_INT 92
7909: PUSH
7910: LD_INT 147
7912: PUSH
7913: LD_INT 4
7915: PUSH
7916: LD_INT 9
7918: PUSH
7919: EMPTY
7920: LIST
7921: LIST
7922: LIST
7923: LIST
7924: PPUSH
7925: CALL_OW 72
7929: PUSH
7930: LD_VAR 0 2
7934: PUSH
7935: LD_INT 1
7937: MINUS
7938: GREATEREQUAL
7939: IFFALSE 7817
// end ; repeat wait ( 0 0$1 ) ;
7941: LD_INT 35
7943: PPUSH
7944: CALL_OW 67
// for i in tmp do
7948: LD_ADDR_VAR 0 1
7952: PUSH
7953: LD_VAR 0 2
7957: PUSH
7958: FOR_IN
7959: IFFALSE 8041
// begin if GetLives ( i ) > 251 then
7961: LD_VAR 0 1
7965: PPUSH
7966: CALL_OW 256
7970: PUSH
7971: LD_INT 251
7973: GREATER
7974: IFFALSE 8012
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
7976: LD_VAR 0 1
7980: PPUSH
7981: LD_INT 81
7983: PUSH
7984: LD_INT 8
7986: PUSH
7987: EMPTY
7988: LIST
7989: LIST
7990: PPUSH
7991: CALL_OW 69
7995: PPUSH
7996: LD_VAR 0 1
8000: PPUSH
8001: CALL_OW 74
8005: PPUSH
8006: CALL_OW 115
8010: GO 8039
// if IsDead ( i ) then
8012: LD_VAR 0 1
8016: PPUSH
8017: CALL_OW 301
8021: IFFALSE 8039
// tmp := tmp diff i ;
8023: LD_ADDR_VAR 0 2
8027: PUSH
8028: LD_VAR 0 2
8032: PUSH
8033: LD_VAR 0 1
8037: DIFF
8038: ST_TO_ADDR
// end ;
8039: GO 7958
8041: POP
8042: POP
// until not tmp ;
8043: LD_VAR 0 2
8047: NOT
8048: IFFALSE 7941
// end ;
8050: PPOPN 3
8052: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8053: LD_EXP 50
8057: PPUSH
8058: CALL_OW 302
8062: PUSH
8063: LD_EXP 3
8067: NOT
8068: AND
8069: IFFALSE 8078
8071: GO 8073
8073: DISABLE
// BuildKozlovBomb ;
8074: CALL 7065 0 0
8078: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8079: LD_INT 22
8081: PUSH
8082: LD_INT 8
8084: PUSH
8085: EMPTY
8086: LIST
8087: LIST
8088: PUSH
8089: LD_INT 34
8091: PUSH
8092: LD_INT 48
8094: PUSH
8095: EMPTY
8096: LIST
8097: LIST
8098: PUSH
8099: EMPTY
8100: LIST
8101: LIST
8102: PPUSH
8103: CALL_OW 69
8107: IFFALSE 8155
8109: GO 8111
8111: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
8112: LD_INT 22
8114: PUSH
8115: LD_INT 8
8117: PUSH
8118: EMPTY
8119: LIST
8120: LIST
8121: PUSH
8122: LD_INT 34
8124: PUSH
8125: LD_INT 48
8127: PUSH
8128: EMPTY
8129: LIST
8130: LIST
8131: PUSH
8132: EMPTY
8133: LIST
8134: LIST
8135: PPUSH
8136: CALL_OW 69
8140: PUSH
8141: LD_INT 1
8143: ARRAY
8144: PPUSH
8145: LD_INT 173
8147: PPUSH
8148: LD_INT 96
8150: PPUSH
8151: CALL_OW 116
// end ; end_of_file
8155: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
8156: LD_INT 0
8158: PPUSH
8159: PPUSH
8160: PPUSH
8161: PPUSH
8162: PPUSH
8163: PPUSH
8164: PPUSH
8165: PPUSH
8166: PPUSH
// side := 3 ;
8167: LD_ADDR_VAR 0 6
8171: PUSH
8172: LD_INT 3
8174: ST_TO_ADDR
// InitHc ;
8175: CALL_OW 19
// uc_side := side ;
8179: LD_ADDR_OWVAR 20
8183: PUSH
8184: LD_VAR 0 6
8188: ST_TO_ADDR
// uc_nation := 3 ;
8189: LD_ADDR_OWVAR 21
8193: PUSH
8194: LD_INT 3
8196: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
8197: LD_ADDR_VAR 0 2
8201: PUSH
8202: LD_INT 22
8204: PUSH
8205: LD_VAR 0 6
8209: PUSH
8210: EMPTY
8211: LIST
8212: LIST
8213: PUSH
8214: LD_INT 21
8216: PUSH
8217: LD_INT 3
8219: PUSH
8220: EMPTY
8221: LIST
8222: LIST
8223: PUSH
8224: EMPTY
8225: LIST
8226: LIST
8227: PPUSH
8228: CALL_OW 69
8232: PUSH
8233: FOR_IN
8234: IFFALSE 8250
// SetBLevel ( i , 10 ) ;
8236: LD_VAR 0 2
8240: PPUSH
8241: LD_INT 10
8243: PPUSH
8244: CALL_OW 241
8248: GO 8233
8250: POP
8251: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
8252: LD_ADDR_VAR 0 9
8256: PUSH
8257: LD_INT 22
8259: PUSH
8260: LD_VAR 0 6
8264: PUSH
8265: EMPTY
8266: LIST
8267: LIST
8268: PUSH
8269: LD_INT 30
8271: PUSH
8272: LD_INT 34
8274: PUSH
8275: EMPTY
8276: LIST
8277: LIST
8278: PUSH
8279: EMPTY
8280: LIST
8281: LIST
8282: PPUSH
8283: CALL_OW 69
8287: ST_TO_ADDR
// if teleport then
8288: LD_VAR 0 9
8292: IFFALSE 8313
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
8294: LD_VAR 0 9
8298: PUSH
8299: LD_INT 1
8301: ARRAY
8302: PPUSH
8303: LD_INT 123
8305: PPUSH
8306: LD_INT 122
8308: PPUSH
8309: CALL_OW 243
// hc_importance := 0 ;
8313: LD_ADDR_OWVAR 32
8317: PUSH
8318: LD_INT 0
8320: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
8321: LD_ADDR_EXP 51
8325: PUSH
8326: LD_STRING Platonov
8328: PPUSH
8329: CALL_OW 25
8333: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
8334: LD_ADDR_EXP 52
8338: PUSH
8339: LD_STRING Yakotich
8341: PPUSH
8342: CALL_OW 25
8346: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
8347: LD_ADDR_EXP 53
8351: PUSH
8352: LD_STRING Gleb
8354: PPUSH
8355: CALL_OW 25
8359: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
8360: LD_STRING 03_Cornel
8362: PPUSH
8363: CALL_OW 28
8367: IFFALSE 8415
// begin Bierezov := NewCharacter ( Mikhail ) ;
8369: LD_ADDR_EXP 54
8373: PUSH
8374: LD_STRING Mikhail
8376: PPUSH
8377: CALL_OW 25
8381: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
8382: LD_EXP 54
8386: PPUSH
8387: LD_INT 197
8389: PPUSH
8390: LD_INT 111
8392: PPUSH
8393: LD_INT 9
8395: PPUSH
8396: LD_INT 0
8398: PPUSH
8399: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
8403: LD_EXP 54
8407: PPUSH
8408: LD_INT 3
8410: PPUSH
8411: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
8415: LD_EXP 51
8419: PPUSH
8420: LD_INT 126
8422: PPUSH
8423: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
8427: LD_EXP 52
8431: PPUSH
8432: LD_INT 197
8434: PPUSH
8435: LD_INT 111
8437: PPUSH
8438: LD_INT 9
8440: PPUSH
8441: LD_INT 0
8443: PPUSH
8444: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
8448: LD_EXP 53
8452: PPUSH
8453: LD_INT 197
8455: PPUSH
8456: LD_INT 111
8458: PPUSH
8459: LD_INT 9
8461: PPUSH
8462: LD_INT 0
8464: PPUSH
8465: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
8469: LD_ADDR_VAR 0 5
8473: PUSH
8474: LD_INT 126
8476: PPUSH
8477: LD_INT 2
8479: PPUSH
8480: LD_STRING zhukov
8482: PPUSH
8483: LD_INT 9
8485: PUSH
8486: LD_INT 10
8488: PUSH
8489: LD_INT 10
8491: PUSH
8492: EMPTY
8493: LIST
8494: LIST
8495: LIST
8496: PUSH
8497: LD_OWVAR 67
8501: ARRAY
8502: PPUSH
8503: LD_INT 90000
8505: PUSH
8506: LD_INT 1000
8508: PUSH
8509: LD_INT 300
8511: PUSH
8512: EMPTY
8513: LIST
8514: LIST
8515: LIST
8516: PPUSH
8517: LD_INT 21
8519: PUSH
8520: LD_INT 8
8522: PUSH
8523: LD_INT 13
8525: PUSH
8526: LD_INT 8
8528: PUSH
8529: EMPTY
8530: LIST
8531: LIST
8532: LIST
8533: LIST
8534: PPUSH
8535: CALL 60774 0 6
8539: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
8540: LD_ADDR_VAR 0 4
8544: PUSH
8545: LD_INT 267
8547: PPUSH
8548: CALL_OW 274
8552: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
8553: LD_VAR 0 4
8557: PPUSH
8558: LD_INT 1
8560: PPUSH
8561: LD_INT 5000
8563: PPUSH
8564: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8568: LD_VAR 0 4
8572: PPUSH
8573: LD_INT 2
8575: PPUSH
8576: LD_INT 200
8578: PPUSH
8579: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8583: LD_VAR 0 4
8587: PPUSH
8588: LD_INT 3
8590: PPUSH
8591: LD_INT 200
8593: PPUSH
8594: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
8598: LD_ADDR_EXP 74
8602: PUSH
8603: LD_EXP 74
8607: PPUSH
8608: LD_INT 2
8610: PPUSH
8611: LD_VAR 0 5
8615: PUSH
8616: LD_INT 22
8618: PUSH
8619: LD_VAR 0 6
8623: PUSH
8624: EMPTY
8625: LIST
8626: LIST
8627: PUSH
8628: LD_INT 3
8630: PUSH
8631: LD_INT 21
8633: PUSH
8634: LD_INT 2
8636: PUSH
8637: EMPTY
8638: LIST
8639: LIST
8640: PUSH
8641: EMPTY
8642: LIST
8643: LIST
8644: PUSH
8645: EMPTY
8646: LIST
8647: LIST
8648: PPUSH
8649: CALL_OW 69
8653: UNION
8654: PUSH
8655: LD_EXP 51
8659: DIFF
8660: PPUSH
8661: CALL_OW 1
8665: ST_TO_ADDR
// behemoths := [ ] ;
8666: LD_ADDR_EXP 55
8670: PUSH
8671: EMPTY
8672: ST_TO_ADDR
// behemothBuilders := [ ] ;
8673: LD_ADDR_EXP 56
8677: PUSH
8678: EMPTY
8679: ST_TO_ADDR
// j := 3 ;
8680: LD_ADDR_VAR 0 3
8684: PUSH
8685: LD_INT 3
8687: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
8688: LD_ADDR_VAR 0 2
8692: PUSH
8693: LD_INT 22
8695: PUSH
8696: LD_INT 3
8698: PUSH
8699: EMPTY
8700: LIST
8701: LIST
8702: PUSH
8703: LD_INT 25
8705: PUSH
8706: LD_INT 3
8708: PUSH
8709: EMPTY
8710: LIST
8711: LIST
8712: PUSH
8713: EMPTY
8714: LIST
8715: LIST
8716: PPUSH
8717: CALL_OW 69
8721: PUSH
8722: FOR_IN
8723: IFFALSE 8773
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8725: LD_ADDR_EXP 56
8729: PUSH
8730: LD_EXP 56
8734: PPUSH
8735: LD_VAR 0 2
8739: PPUSH
8740: CALL 93110 0 2
8744: ST_TO_ADDR
// j := j - 1 ;
8745: LD_ADDR_VAR 0 3
8749: PUSH
8750: LD_VAR 0 3
8754: PUSH
8755: LD_INT 1
8757: MINUS
8758: ST_TO_ADDR
// if j = 0 then
8759: LD_VAR 0 3
8763: PUSH
8764: LD_INT 0
8766: EQUAL
8767: IFFALSE 8771
// break ;
8769: GO 8773
// end ;
8771: GO 8722
8773: POP
8774: POP
// end ;
8775: LD_VAR 0 1
8779: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
8780: LD_INT 0
8782: PPUSH
8783: PPUSH
8784: PPUSH
8785: PPUSH
8786: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
8787: LD_ADDR_VAR 0 4
8791: PUSH
8792: LD_INT 209
8794: PUSH
8795: LD_INT 149
8797: PUSH
8798: EMPTY
8799: LIST
8800: LIST
8801: PUSH
8802: LD_INT 219
8804: PUSH
8805: LD_INT 154
8807: PUSH
8808: EMPTY
8809: LIST
8810: LIST
8811: PUSH
8812: LD_INT 223
8814: PUSH
8815: LD_INT 149
8817: PUSH
8818: EMPTY
8819: LIST
8820: LIST
8821: PUSH
8822: LD_INT 232
8824: PUSH
8825: LD_INT 155
8827: PUSH
8828: EMPTY
8829: LIST
8830: LIST
8831: PUSH
8832: EMPTY
8833: LIST
8834: LIST
8835: LIST
8836: LIST
8837: ST_TO_ADDR
// if not behemothBuilders then
8838: LD_EXP 56
8842: NOT
8843: IFFALSE 8847
// exit ;
8845: GO 8951
// j := 1 ;
8847: LD_ADDR_VAR 0 3
8851: PUSH
8852: LD_INT 1
8854: ST_TO_ADDR
// for i in behemothBuilders do
8855: LD_ADDR_VAR 0 2
8859: PUSH
8860: LD_EXP 56
8864: PUSH
8865: FOR_IN
8866: IFFALSE 8949
// begin if IsInUnit ( i ) then
8868: LD_VAR 0 2
8872: PPUSH
8873: CALL_OW 310
8877: IFFALSE 8888
// ComExitBuilding ( i ) ;
8879: LD_VAR 0 2
8883: PPUSH
8884: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
8888: LD_VAR 0 2
8892: PPUSH
8893: LD_INT 37
8895: PPUSH
8896: LD_VAR 0 4
8900: PUSH
8901: LD_VAR 0 3
8905: ARRAY
8906: PUSH
8907: LD_INT 1
8909: ARRAY
8910: PPUSH
8911: LD_VAR 0 4
8915: PUSH
8916: LD_VAR 0 3
8920: ARRAY
8921: PUSH
8922: LD_INT 2
8924: ARRAY
8925: PPUSH
8926: LD_INT 0
8928: PPUSH
8929: CALL_OW 230
// j := j + 1 ;
8933: LD_ADDR_VAR 0 3
8937: PUSH
8938: LD_VAR 0 3
8942: PUSH
8943: LD_INT 1
8945: PLUS
8946: ST_TO_ADDR
// end ;
8947: GO 8865
8949: POP
8950: POP
// end ;
8951: LD_VAR 0 1
8955: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
8956: LD_INT 3
8958: PPUSH
8959: CALL 93158 0 1
8963: PUSH
8964: LD_INT 22
8966: PUSH
8967: LD_INT 3
8969: PUSH
8970: EMPTY
8971: LIST
8972: LIST
8973: PUSH
8974: LD_INT 30
8976: PUSH
8977: LD_INT 37
8979: PUSH
8980: EMPTY
8981: LIST
8982: LIST
8983: PUSH
8984: EMPTY
8985: LIST
8986: LIST
8987: PPUSH
8988: CALL_OW 69
8992: NOT
8993: AND
8994: IFFALSE 9180
8996: GO 8998
8998: DISABLE
8999: LD_INT 0
9001: PPUSH
9002: PPUSH
// begin enable ;
9003: ENABLE
// tmp := GetBehemoths ( 3 ) ;
9004: LD_ADDR_VAR 0 2
9008: PUSH
9009: LD_INT 3
9011: PPUSH
9012: CALL 93158 0 1
9016: ST_TO_ADDR
// for i in tmp do
9017: LD_ADDR_VAR 0 1
9021: PUSH
9022: LD_VAR 0 2
9026: PUSH
9027: FOR_IN
9028: IFFALSE 9178
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
9030: LD_VAR 0 1
9034: PPUSH
9035: LD_INT 7
9037: PPUSH
9038: CALL_OW 308
9042: PUSH
9043: LD_VAR 0 1
9047: PPUSH
9048: CALL_OW 110
9052: PUSH
9053: LD_INT 2
9055: EQUAL
9056: NOT
9057: AND
9058: IFFALSE 9072
// SetTag ( i , 2 ) ;
9060: LD_VAR 0 1
9064: PPUSH
9065: LD_INT 2
9067: PPUSH
9068: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
9072: LD_INT 81
9074: PUSH
9075: LD_INT 3
9077: PUSH
9078: EMPTY
9079: LIST
9080: LIST
9081: PUSH
9082: LD_INT 91
9084: PUSH
9085: LD_VAR 0 1
9089: PUSH
9090: LD_INT 12
9092: PUSH
9093: EMPTY
9094: LIST
9095: LIST
9096: LIST
9097: PUSH
9098: EMPTY
9099: LIST
9100: LIST
9101: PPUSH
9102: CALL_OW 69
9106: NOT
9107: PUSH
9108: LD_VAR 0 1
9112: PPUSH
9113: CALL_OW 110
9117: PUSH
9118: LD_INT 2
9120: EQUAL
9121: NOT
9122: AND
9123: IFFALSE 9142
// ComAgressiveMove ( i , 64 , 93 ) else
9125: LD_VAR 0 1
9129: PPUSH
9130: LD_INT 64
9132: PPUSH
9133: LD_INT 93
9135: PPUSH
9136: CALL_OW 114
9140: GO 9176
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9142: LD_VAR 0 1
9146: PPUSH
9147: LD_INT 81
9149: PUSH
9150: LD_INT 3
9152: PUSH
9153: EMPTY
9154: LIST
9155: LIST
9156: PPUSH
9157: CALL_OW 69
9161: PPUSH
9162: LD_VAR 0 1
9166: PPUSH
9167: CALL_OW 74
9171: PPUSH
9172: CALL_OW 115
// end ;
9176: GO 9027
9178: POP
9179: POP
// end ;
9180: PPOPN 2
9182: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9183: LD_EXP 2
9187: NOT
9188: PUSH
9189: LD_INT 2
9191: PPUSH
9192: LD_INT 1
9194: PPUSH
9195: CALL 45324 0 2
9199: NOT
9200: AND
9201: IFFALSE 10121
9203: GO 9205
9205: DISABLE
9206: LD_INT 0
9208: PPUSH
9209: PPUSH
9210: PPUSH
9211: PPUSH
// begin enable ;
9212: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9213: LD_INT 22
9215: PUSH
9216: LD_INT 3
9218: PUSH
9219: EMPTY
9220: LIST
9221: LIST
9222: PUSH
9223: LD_INT 30
9225: PUSH
9226: LD_INT 3
9228: PUSH
9229: EMPTY
9230: LIST
9231: LIST
9232: PUSH
9233: EMPTY
9234: LIST
9235: LIST
9236: PPUSH
9237: CALL_OW 69
9241: NOT
9242: IFFALSE 9246
// exit ;
9244: GO 10121
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9246: LD_ADDR_VAR 0 4
9250: PUSH
9251: LD_INT 22
9253: PUSH
9254: LD_INT 3
9256: PUSH
9257: EMPTY
9258: LIST
9259: LIST
9260: PUSH
9261: LD_INT 30
9263: PUSH
9264: LD_INT 34
9266: PUSH
9267: EMPTY
9268: LIST
9269: LIST
9270: PUSH
9271: EMPTY
9272: LIST
9273: LIST
9274: PPUSH
9275: CALL_OW 69
9279: ST_TO_ADDR
// if Prob ( 40 ) then
9280: LD_INT 40
9282: PPUSH
9283: CALL_OW 13
9287: IFFALSE 9414
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9289: LD_INT 2
9291: PPUSH
9292: LD_INT 22
9294: PUSH
9295: LD_INT 3
9297: PUSH
9298: LD_INT 3
9300: PUSH
9301: LD_INT 49
9303: PUSH
9304: EMPTY
9305: LIST
9306: LIST
9307: LIST
9308: LIST
9309: PUSH
9310: LD_INT 22
9312: PUSH
9313: LD_INT 3
9315: PUSH
9316: LD_INT 3
9318: PUSH
9319: LD_INT 49
9321: PUSH
9322: EMPTY
9323: LIST
9324: LIST
9325: LIST
9326: LIST
9327: PUSH
9328: LD_INT 22
9330: PUSH
9331: LD_INT 3
9333: PUSH
9334: LD_INT 3
9336: PUSH
9337: LD_INT 49
9339: PUSH
9340: EMPTY
9341: LIST
9342: LIST
9343: LIST
9344: LIST
9345: PUSH
9346: LD_INT 24
9348: PUSH
9349: LD_INT 3
9351: PUSH
9352: LD_INT 3
9354: PUSH
9355: LD_INT 46
9357: PUSH
9358: EMPTY
9359: LIST
9360: LIST
9361: LIST
9362: LIST
9363: PUSH
9364: LD_INT 24
9366: PUSH
9367: LD_INT 3
9369: PUSH
9370: LD_INT 3
9372: PUSH
9373: LD_INT 46
9375: PUSH
9376: EMPTY
9377: LIST
9378: LIST
9379: LIST
9380: LIST
9381: PUSH
9382: LD_INT 24
9384: PUSH
9385: LD_INT 3
9387: PUSH
9388: LD_INT 3
9390: PUSH
9391: LD_INT 46
9393: PUSH
9394: EMPTY
9395: LIST
9396: LIST
9397: LIST
9398: LIST
9399: PUSH
9400: EMPTY
9401: LIST
9402: LIST
9403: LIST
9404: LIST
9405: LIST
9406: LIST
9407: PPUSH
9408: CALL 43906 0 2
// end else
9412: GO 9537
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9414: LD_INT 2
9416: PPUSH
9417: LD_INT 24
9419: PUSH
9420: LD_INT 3
9422: PUSH
9423: LD_INT 3
9425: PUSH
9426: LD_INT 47
9428: PUSH
9429: EMPTY
9430: LIST
9431: LIST
9432: LIST
9433: LIST
9434: PUSH
9435: LD_INT 24
9437: PUSH
9438: LD_INT 3
9440: PUSH
9441: LD_INT 3
9443: PUSH
9444: LD_INT 47
9446: PUSH
9447: EMPTY
9448: LIST
9449: LIST
9450: LIST
9451: LIST
9452: PUSH
9453: LD_INT 24
9455: PUSH
9456: LD_INT 3
9458: PUSH
9459: LD_INT 3
9461: PUSH
9462: LD_INT 47
9464: PUSH
9465: EMPTY
9466: LIST
9467: LIST
9468: LIST
9469: LIST
9470: PUSH
9471: LD_INT 24
9473: PUSH
9474: LD_INT 3
9476: PUSH
9477: LD_INT 3
9479: PUSH
9480: LD_INT 46
9482: PUSH
9483: EMPTY
9484: LIST
9485: LIST
9486: LIST
9487: LIST
9488: PUSH
9489: LD_INT 24
9491: PUSH
9492: LD_INT 3
9494: PUSH
9495: LD_INT 3
9497: PUSH
9498: LD_INT 46
9500: PUSH
9501: EMPTY
9502: LIST
9503: LIST
9504: LIST
9505: LIST
9506: PUSH
9507: LD_INT 24
9509: PUSH
9510: LD_INT 3
9512: PUSH
9513: LD_INT 3
9515: PUSH
9516: LD_INT 46
9518: PUSH
9519: EMPTY
9520: LIST
9521: LIST
9522: LIST
9523: LIST
9524: PUSH
9525: EMPTY
9526: LIST
9527: LIST
9528: LIST
9529: LIST
9530: LIST
9531: LIST
9532: PPUSH
9533: CALL 43906 0 2
// end ; if Difficulty > 1 then
9537: LD_OWVAR 67
9541: PUSH
9542: LD_INT 1
9544: GREATER
9545: IFFALSE 9575
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
9547: LD_INT 2
9549: PPUSH
9550: LD_INT 24
9552: PUSH
9553: LD_INT 3
9555: PUSH
9556: LD_INT 3
9558: PUSH
9559: LD_INT 47
9561: PUSH
9562: EMPTY
9563: LIST
9564: LIST
9565: LIST
9566: LIST
9567: PUSH
9568: EMPTY
9569: LIST
9570: PPUSH
9571: CALL 43906 0 2
// repeat wait ( 0 0$1 ) ;
9575: LD_INT 35
9577: PPUSH
9578: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
9582: LD_INT 2
9584: PPUSH
9585: LD_INT 1
9587: PPUSH
9588: CALL 45324 0 2
9592: PUSH
9593: LD_INT 6
9595: PUSH
9596: LD_INT 7
9598: PUSH
9599: LD_INT 7
9601: PUSH
9602: EMPTY
9603: LIST
9604: LIST
9605: LIST
9606: PUSH
9607: LD_OWVAR 67
9611: ARRAY
9612: GREATEREQUAL
9613: IFFALSE 9575
// wait ( 0 0$30 ) ;
9615: LD_INT 1050
9617: PPUSH
9618: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
9622: LD_ADDR_VAR 0 2
9626: PUSH
9627: LD_INT 2
9629: PPUSH
9630: LD_INT 1
9632: PPUSH
9633: CALL 45324 0 2
9637: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
9638: LD_ADDR_EXP 93
9642: PUSH
9643: LD_EXP 93
9647: PPUSH
9648: LD_INT 2
9650: PPUSH
9651: LD_EXP 93
9655: PUSH
9656: LD_INT 2
9658: ARRAY
9659: PUSH
9660: LD_VAR 0 2
9664: DIFF
9665: PPUSH
9666: CALL_OW 1
9670: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
9671: LD_ADDR_VAR 0 3
9675: PUSH
9676: LD_INT 0
9678: PPUSH
9679: LD_INT 1
9681: PPUSH
9682: CALL_OW 12
9686: ST_TO_ADDR
// if target then
9687: LD_VAR 0 3
9691: IFFALSE 9819
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9693: LD_ADDR_VAR 0 2
9697: PUSH
9698: LD_VAR 0 2
9702: PPUSH
9703: LD_INT 24
9705: PUSH
9706: LD_INT 250
9708: PUSH
9709: EMPTY
9710: LIST
9711: LIST
9712: PPUSH
9713: CALL_OW 72
9717: ST_TO_ADDR
// for i in tmp do
9718: LD_ADDR_VAR 0 1
9722: PUSH
9723: LD_VAR 0 2
9727: PUSH
9728: FOR_IN
9729: IFFALSE 9769
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
9731: LD_VAR 0 1
9735: PPUSH
9736: LD_INT 139
9738: PPUSH
9739: LD_INT 89
9741: PPUSH
9742: CALL_OW 297
9746: PUSH
9747: LD_INT 9
9749: GREATER
9750: IFFALSE 9767
// ComMoveXY ( i , 139 , 89 ) ;
9752: LD_VAR 0 1
9756: PPUSH
9757: LD_INT 139
9759: PPUSH
9760: LD_INT 89
9762: PPUSH
9763: CALL_OW 111
9767: GO 9728
9769: POP
9770: POP
// wait ( 0 0$1 ) ;
9771: LD_INT 35
9773: PPUSH
9774: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
9778: LD_VAR 0 2
9782: PPUSH
9783: LD_INT 92
9785: PUSH
9786: LD_INT 139
9788: PUSH
9789: LD_INT 89
9791: PUSH
9792: LD_INT 9
9794: PUSH
9795: EMPTY
9796: LIST
9797: LIST
9798: LIST
9799: LIST
9800: PPUSH
9801: CALL_OW 72
9805: PUSH
9806: LD_VAR 0 2
9810: PUSH
9811: LD_INT 1
9813: MINUS
9814: GREATEREQUAL
9815: IFFALSE 9693
// end else
9817: GO 9961
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
9819: LD_VAR 0 2
9823: PPUSH
9824: LD_VAR 0 4
9828: PUSH
9829: LD_INT 1
9831: ARRAY
9832: PPUSH
9833: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9837: LD_ADDR_VAR 0 2
9841: PUSH
9842: LD_VAR 0 2
9846: PPUSH
9847: LD_INT 24
9849: PUSH
9850: LD_INT 250
9852: PUSH
9853: EMPTY
9854: LIST
9855: LIST
9856: PPUSH
9857: CALL_OW 72
9861: ST_TO_ADDR
// for i in tmp do
9862: LD_ADDR_VAR 0 1
9866: PUSH
9867: LD_VAR 0 2
9871: PUSH
9872: FOR_IN
9873: IFFALSE 9913
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
9875: LD_VAR 0 1
9879: PPUSH
9880: LD_INT 124
9882: PPUSH
9883: LD_INT 139
9885: PPUSH
9886: CALL_OW 297
9890: PUSH
9891: LD_INT 9
9893: GREATER
9894: IFFALSE 9911
// ComMoveXY ( i , 124 , 139 ) ;
9896: LD_VAR 0 1
9900: PPUSH
9901: LD_INT 124
9903: PPUSH
9904: LD_INT 139
9906: PPUSH
9907: CALL_OW 111
9911: GO 9872
9913: POP
9914: POP
// wait ( 0 0$1 ) ;
9915: LD_INT 35
9917: PPUSH
9918: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
9922: LD_VAR 0 2
9926: PPUSH
9927: LD_INT 92
9929: PUSH
9930: LD_INT 124
9932: PUSH
9933: LD_INT 139
9935: PUSH
9936: LD_INT 9
9938: PUSH
9939: EMPTY
9940: LIST
9941: LIST
9942: LIST
9943: LIST
9944: PPUSH
9945: CALL_OW 72
9949: PUSH
9950: LD_VAR 0 2
9954: PUSH
9955: LD_INT 1
9957: MINUS
9958: GREATEREQUAL
9959: IFFALSE 9837
// end ; repeat wait ( 0 0$1 ) ;
9961: LD_INT 35
9963: PPUSH
9964: CALL_OW 67
// for i in tmp do
9968: LD_ADDR_VAR 0 1
9972: PUSH
9973: LD_VAR 0 2
9977: PUSH
9978: FOR_IN
9979: IFFALSE 10112
// begin if GetLives ( i ) > 251 then
9981: LD_VAR 0 1
9985: PPUSH
9986: CALL_OW 256
9990: PUSH
9991: LD_INT 251
9993: GREATER
9994: IFFALSE 10083
// begin if GetWeapon ( i ) = ru_time_lapser then
9996: LD_VAR 0 1
10000: PPUSH
10001: CALL_OW 264
10005: PUSH
10006: LD_INT 49
10008: EQUAL
10009: IFFALSE 10047
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
10011: LD_VAR 0 1
10015: PPUSH
10016: LD_INT 81
10018: PUSH
10019: LD_INT 3
10021: PUSH
10022: EMPTY
10023: LIST
10024: LIST
10025: PPUSH
10026: CALL_OW 69
10030: PPUSH
10031: LD_VAR 0 1
10035: PPUSH
10036: CALL_OW 74
10040: PPUSH
10041: CALL_OW 112
10045: GO 10081
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10047: LD_VAR 0 1
10051: PPUSH
10052: LD_INT 81
10054: PUSH
10055: LD_INT 3
10057: PUSH
10058: EMPTY
10059: LIST
10060: LIST
10061: PPUSH
10062: CALL_OW 69
10066: PPUSH
10067: LD_VAR 0 1
10071: PPUSH
10072: CALL_OW 74
10076: PPUSH
10077: CALL_OW 115
// end else
10081: GO 10110
// if IsDead ( i ) then
10083: LD_VAR 0 1
10087: PPUSH
10088: CALL_OW 301
10092: IFFALSE 10110
// tmp := tmp diff i ;
10094: LD_ADDR_VAR 0 2
10098: PUSH
10099: LD_VAR 0 2
10103: PUSH
10104: LD_VAR 0 1
10108: DIFF
10109: ST_TO_ADDR
// end ;
10110: GO 9978
10112: POP
10113: POP
// until not tmp ;
10114: LD_VAR 0 2
10118: NOT
10119: IFFALSE 9961
// end ;
10121: PPOPN 4
10123: END
// every 30 30$00 trigger not russianDestroyed do
10124: LD_EXP 2
10128: NOT
10129: IFFALSE 10194
10131: GO 10133
10133: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 ] [ Difficulty ] ) ;
10134: LD_INT 105000
10136: PUSH
10137: LD_INT 84000
10139: PUSH
10140: LD_INT 63000
10142: PUSH
10143: EMPTY
10144: LIST
10145: LIST
10146: LIST
10147: PUSH
10148: LD_OWVAR 67
10152: ARRAY
10153: PPUSH
10154: CALL_OW 67
// if russianDestroyed then
10158: LD_EXP 2
10162: IFFALSE 10166
// exit ;
10164: GO 10194
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
10166: LD_INT 2
10168: PPUSH
10169: LD_INT 23
10171: PUSH
10172: LD_INT 3
10174: PUSH
10175: LD_INT 1
10177: PUSH
10178: LD_INT 48
10180: PUSH
10181: EMPTY
10182: LIST
10183: LIST
10184: LIST
10185: LIST
10186: PUSH
10187: EMPTY
10188: LIST
10189: PPUSH
10190: CALL 43906 0 2
// end ; end_of_file
10194: END
// export function CustomEvent ( event ) ; begin
10195: LD_INT 0
10197: PPUSH
// end ;
10198: LD_VAR 0 2
10202: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10203: LD_VAR 0 2
10207: PPUSH
10208: LD_VAR 0 3
10212: PPUSH
10213: LD_INT 15
10215: PPUSH
10216: CALL_OW 309
10220: IFFALSE 10229
// YouLost ( MothContaminate ) ;
10222: LD_STRING MothContaminate
10224: PPUSH
10225: CALL_OW 104
// end ;
10229: PPOPN 3
10231: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10232: LD_VAR 0 2
10236: PPUSH
10237: LD_VAR 0 3
10241: PPUSH
10242: LD_INT 15
10244: PPUSH
10245: CALL_OW 309
10249: IFFALSE 10265
// begin wait ( 0 0$6 ) ;
10251: LD_INT 210
10253: PPUSH
10254: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
10258: LD_STRING MothContaminateBomb
10260: PPUSH
10261: CALL_OW 104
// end ; end ;
10265: PPOPN 3
10267: END
// on UnitDestroyed ( un ) do begin if un = JMM then
10268: LD_VAR 0 1
10272: PUSH
10273: LD_EXP 12
10277: EQUAL
10278: IFFALSE 10289
// begin YouLost ( JMM ) ;
10280: LD_STRING JMM
10282: PPUSH
10283: CALL_OW 104
// exit ;
10287: GO 10338
// end ; if un = Powell then
10289: LD_VAR 0 1
10293: PUSH
10294: LD_EXP 47
10298: EQUAL
10299: IFFALSE 10309
// americanDestroyed := true ;
10301: LD_ADDR_EXP 4
10305: PUSH
10306: LD_INT 1
10308: ST_TO_ADDR
// if un = Platonov then
10309: LD_VAR 0 1
10313: PUSH
10314: LD_EXP 51
10318: EQUAL
10319: IFFALSE 10329
// russianDestroyed := true ;
10321: LD_ADDR_EXP 2
10325: PUSH
10326: LD_INT 1
10328: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
10329: LD_VAR 0 1
10333: PPUSH
10334: CALL 47298 0 1
// end ;
10338: PPOPN 1
10340: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10341: LD_VAR 0 1
10345: PPUSH
10346: LD_VAR 0 2
10350: PPUSH
10351: CALL 49632 0 2
// end ;
10355: PPOPN 2
10357: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10358: LD_VAR 0 1
10362: PPUSH
10363: CALL 48700 0 1
// end ;
10367: PPOPN 1
10369: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
10370: LD_VAR 0 1
10374: PUSH
10375: LD_INT 22
10377: PUSH
10378: LD_INT 8
10380: PUSH
10381: EMPTY
10382: LIST
10383: LIST
10384: PUSH
10385: LD_INT 30
10387: PUSH
10388: LD_INT 2
10390: PUSH
10391: EMPTY
10392: LIST
10393: LIST
10394: PUSH
10395: LD_INT 23
10397: PUSH
10398: LD_INT 3
10400: PUSH
10401: EMPTY
10402: LIST
10403: LIST
10404: PUSH
10405: EMPTY
10406: LIST
10407: LIST
10408: LIST
10409: PPUSH
10410: CALL_OW 69
10414: IN
10415: IFFALSE 10442
// begin ComUpgrade ( building ) ;
10417: LD_VAR 0 1
10421: PPUSH
10422: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
10426: LD_EXP 50
10430: PPUSH
10431: LD_VAR 0 1
10435: PPUSH
10436: CALL 60338 0 2
// exit ;
10440: GO 10451
// end ; MCE_BuildingComplete ( building ) ;
10442: LD_VAR 0 1
10446: PPUSH
10447: CALL 48941 0 1
// end ;
10451: PPOPN 1
10453: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10454: LD_VAR 0 1
10458: PPUSH
10459: LD_VAR 0 2
10463: PPUSH
10464: CALL 46994 0 2
// end ;
10468: PPOPN 2
10470: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10471: LD_VAR 0 1
10475: PPUSH
10476: LD_VAR 0 2
10480: PPUSH
10481: LD_VAR 0 3
10485: PPUSH
10486: LD_VAR 0 4
10490: PPUSH
10491: LD_VAR 0 5
10495: PPUSH
10496: CALL 46614 0 5
// end ;
10500: PPOPN 5
10502: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
10503: LD_VAR 0 1
10507: PPUSH
10508: LD_VAR 0 2
10512: PPUSH
10513: CALL 46210 0 2
// end ;
10517: PPOPN 2
10519: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10520: LD_VAR 0 1
10524: PPUSH
10525: LD_VAR 0 2
10529: PPUSH
10530: LD_VAR 0 3
10534: PPUSH
10535: LD_VAR 0 4
10539: PPUSH
10540: CALL 46048 0 4
// end ;
10544: PPOPN 4
10546: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10547: LD_VAR 0 1
10551: PPUSH
10552: LD_VAR 0 2
10556: PPUSH
10557: LD_VAR 0 3
10561: PPUSH
10562: CALL 45823 0 3
// end ;
10566: PPOPN 3
10568: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10569: LD_VAR 0 1
10573: PPUSH
10574: LD_VAR 0 2
10578: PPUSH
10579: CALL 45708 0 2
// end ;
10583: PPOPN 2
10585: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10586: LD_VAR 0 1
10590: PPUSH
10591: LD_VAR 0 2
10595: PPUSH
10596: CALL 49893 0 2
// end ;
10600: PPOPN 2
10602: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10603: LD_VAR 0 1
10607: PPUSH
10608: LD_VAR 0 2
10612: PPUSH
10613: LD_VAR 0 3
10617: PPUSH
10618: LD_VAR 0 4
10622: PPUSH
10623: CALL 50109 0 4
// end ;
10627: PPOPN 4
10629: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10630: LD_VAR 0 1
10634: PPUSH
10635: LD_VAR 0 2
10639: PPUSH
10640: CALL 45517 0 2
// end ;
10644: PPOPN 2
10646: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
10647: LD_VAR 0 1
10651: PPUSH
10652: CALL 93510 0 1
// end ; end_of_file
10656: PPOPN 1
10658: END
// export function Action ; begin
10659: LD_INT 0
10661: PPUSH
// InGameOn ;
10662: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
10666: LD_INT 206
10668: PPUSH
10669: LD_INT 11
10671: PPUSH
10672: CALL_OW 86
// wait ( 0 0$1 ) ;
10676: LD_INT 35
10678: PPUSH
10679: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
10683: LD_EXP 12
10687: PPUSH
10688: LD_STRING DStart-JMM-JMM-1
10690: PPUSH
10691: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
10695: LD_EXP 44
10699: PPUSH
10700: LD_STRING DStart-JMM-Bur-1
10702: PPUSH
10703: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
10707: LD_EXP 12
10711: PPUSH
10712: LD_STRING DStart-JMM-JMM-2
10714: PPUSH
10715: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
10719: LD_EXP 44
10723: PPUSH
10724: LD_STRING DStart-JMM-Bur-2
10726: PPUSH
10727: CALL_OW 88
// InGameOff ;
10731: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
10735: LD_STRING MStart
10737: PPUSH
10738: CALL_OW 337
// end ;
10742: LD_VAR 0 1
10746: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
10747: LD_INT 7
10749: PPUSH
10750: LD_INT 255
10752: PPUSH
10753: LD_INT 219
10755: PPUSH
10756: CALL_OW 293
10760: IFFALSE 11369
10762: GO 10764
10764: DISABLE
10765: LD_INT 0
10767: PPUSH
// begin wait ( 0 0$3 ) ;
10768: LD_INT 105
10770: PPUSH
10771: CALL_OW 67
// alienSpotted := true ;
10775: LD_ADDR_EXP 7
10779: PUSH
10780: LD_INT 1
10782: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
10783: LD_ADDR_VAR 0 1
10787: PUSH
10788: LD_INT 22
10790: PUSH
10791: LD_INT 7
10793: PUSH
10794: EMPTY
10795: LIST
10796: LIST
10797: PUSH
10798: LD_INT 23
10800: PUSH
10801: LD_INT 3
10803: PUSH
10804: EMPTY
10805: LIST
10806: LIST
10807: PUSH
10808: LD_INT 21
10810: PUSH
10811: LD_INT 1
10813: PUSH
10814: EMPTY
10815: LIST
10816: LIST
10817: PUSH
10818: LD_INT 26
10820: PUSH
10821: LD_INT 1
10823: PUSH
10824: EMPTY
10825: LIST
10826: LIST
10827: PUSH
10828: EMPTY
10829: LIST
10830: LIST
10831: LIST
10832: LIST
10833: PPUSH
10834: CALL_OW 69
10838: PUSH
10839: LD_EXP 44
10843: PUSH
10844: LD_EXP 32
10848: PUSH
10849: LD_EXP 34
10853: PUSH
10854: LD_EXP 35
10858: PUSH
10859: LD_EXP 42
10863: PUSH
10864: LD_EXP 41
10868: PUSH
10869: LD_EXP 36
10873: PUSH
10874: EMPTY
10875: LIST
10876: LIST
10877: LIST
10878: LIST
10879: LIST
10880: LIST
10881: LIST
10882: DIFF
10883: ST_TO_ADDR
// DialogueOn ;
10884: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
10888: LD_INT 255
10890: PPUSH
10891: LD_INT 219
10893: PPUSH
10894: LD_INT 7
10896: PPUSH
10897: LD_INT 20
10899: NEG
10900: PPUSH
10901: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
10905: LD_INT 255
10907: PPUSH
10908: LD_INT 219
10910: PPUSH
10911: CALL_OW 86
// if speaker then
10915: LD_VAR 0 1
10919: IFFALSE 10937
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
10921: LD_VAR 0 1
10925: PUSH
10926: LD_INT 1
10928: ARRAY
10929: PPUSH
10930: LD_STRING DAlienBase-RSol1-1
10932: PPUSH
10933: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
10937: LD_EXP 12
10941: PPUSH
10942: LD_STRING DAlienBase-JMM-1
10944: PPUSH
10945: CALL_OW 88
// if IsOk ( Burlak ) then
10949: LD_EXP 44
10953: PPUSH
10954: CALL_OW 302
10958: IFFALSE 10979
// begin dwait ( 0 0$1 ) ;
10960: LD_INT 35
10962: PPUSH
10963: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
10967: LD_EXP 44
10971: PPUSH
10972: LD_STRING DAlienBase-Bur-1
10974: PPUSH
10975: CALL_OW 88
// end ; if IsOk ( Roth ) then
10979: LD_EXP 13
10983: PPUSH
10984: CALL_OW 302
10988: IFFALSE 11002
// Say ( Roth , DAlienBase-Roth-1 ) ;
10990: LD_EXP 13
10994: PPUSH
10995: LD_STRING DAlienBase-Roth-1
10997: PPUSH
10998: CALL_OW 88
// if IsOk ( Gossudarov ) then
11002: LD_EXP 30
11006: PPUSH
11007: CALL_OW 302
11011: IFFALSE 11027
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
11013: LD_EXP 30
11017: PPUSH
11018: LD_STRING DAlienBase-Gos-1
11020: PPUSH
11021: CALL_OW 88
11025: GO 11144
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11027: LD_ADDR_VAR 0 1
11031: PUSH
11032: LD_INT 22
11034: PUSH
11035: LD_INT 7
11037: PUSH
11038: EMPTY
11039: LIST
11040: LIST
11041: PUSH
11042: LD_INT 25
11044: PUSH
11045: LD_INT 4
11047: PUSH
11048: EMPTY
11049: LIST
11050: LIST
11051: PUSH
11052: LD_INT 21
11054: PUSH
11055: LD_INT 1
11057: PUSH
11058: EMPTY
11059: LIST
11060: LIST
11061: PUSH
11062: LD_INT 26
11064: PUSH
11065: LD_INT 1
11067: PUSH
11068: EMPTY
11069: LIST
11070: LIST
11071: PUSH
11072: EMPTY
11073: LIST
11074: LIST
11075: LIST
11076: LIST
11077: PPUSH
11078: CALL_OW 69
11082: PUSH
11083: LD_EXP 13
11087: PUSH
11088: LD_EXP 12
11092: PUSH
11093: LD_EXP 44
11097: PUSH
11098: LD_EXP 32
11102: PUSH
11103: LD_EXP 42
11107: PUSH
11108: LD_EXP 41
11112: PUSH
11113: EMPTY
11114: LIST
11115: LIST
11116: LIST
11117: LIST
11118: LIST
11119: LIST
11120: DIFF
11121: ST_TO_ADDR
// if speaker then
11122: LD_VAR 0 1
11126: IFFALSE 11144
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
11128: LD_VAR 0 1
11132: PUSH
11133: LD_INT 1
11135: ARRAY
11136: PPUSH
11137: LD_STRING DAlienBase-Sci1-1
11139: PPUSH
11140: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
11144: LD_INT 255
11146: PPUSH
11147: LD_INT 219
11149: PPUSH
11150: LD_INT 7
11152: PPUSH
11153: CALL_OW 331
// DialogueOff ;
11157: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
11161: LD_INT 35
11163: PPUSH
11164: CALL_OW 67
// until IsSelected ( alien ) ;
11168: LD_INT 1
11170: PPUSH
11171: CALL_OW 306
11175: IFFALSE 11161
// if not artifactIResearched or not artifactIIResearched then
11177: LD_EXP 9
11181: NOT
11182: PUSH
11183: LD_EXP 10
11187: NOT
11188: OR
11189: IFFALSE 11369
// begin if IsOk ( Roth ) then
11191: LD_EXP 13
11195: PPUSH
11196: CALL_OW 302
11200: IFFALSE 11216
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
11202: LD_EXP 13
11206: PPUSH
11207: LD_STRING DAlieBaseNotReady-Roth-1
11209: PPUSH
11210: CALL_OW 88
11214: GO 11369
// if IsOk ( Gossudarov ) then
11216: LD_EXP 30
11220: PPUSH
11221: CALL_OW 302
11225: IFFALSE 11241
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
11227: LD_EXP 30
11231: PPUSH
11232: LD_STRING DAlieBaseNotReady-Gos-1
11234: PPUSH
11235: CALL_OW 88
11239: GO 11369
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11241: LD_ADDR_VAR 0 1
11245: PUSH
11246: LD_INT 22
11248: PUSH
11249: LD_INT 7
11251: PUSH
11252: EMPTY
11253: LIST
11254: LIST
11255: PUSH
11256: LD_INT 23
11258: PUSH
11259: LD_INT 3
11261: PUSH
11262: EMPTY
11263: LIST
11264: LIST
11265: PUSH
11266: LD_INT 25
11268: PUSH
11269: LD_INT 4
11271: PUSH
11272: EMPTY
11273: LIST
11274: LIST
11275: PUSH
11276: LD_INT 21
11278: PUSH
11279: LD_INT 1
11281: PUSH
11282: EMPTY
11283: LIST
11284: LIST
11285: PUSH
11286: LD_INT 26
11288: PUSH
11289: LD_INT 1
11291: PUSH
11292: EMPTY
11293: LIST
11294: LIST
11295: PUSH
11296: EMPTY
11297: LIST
11298: LIST
11299: LIST
11300: LIST
11301: LIST
11302: PPUSH
11303: CALL_OW 69
11307: PUSH
11308: LD_EXP 13
11312: PUSH
11313: LD_EXP 12
11317: PUSH
11318: LD_EXP 44
11322: PUSH
11323: LD_EXP 32
11327: PUSH
11328: LD_EXP 42
11332: PUSH
11333: LD_EXP 41
11337: PUSH
11338: EMPTY
11339: LIST
11340: LIST
11341: LIST
11342: LIST
11343: LIST
11344: LIST
11345: DIFF
11346: ST_TO_ADDR
// if speaker then
11347: LD_VAR 0 1
11351: IFFALSE 11369
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
11353: LD_VAR 0 1
11357: PUSH
11358: LD_INT 1
11360: ARRAY
11361: PPUSH
11362: LD_STRING DAlieBaseNotReady-RSci1-1
11364: PPUSH
11365: CALL_OW 88
// end ; end ; end ;
11369: PPOPN 1
11371: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
11372: LD_INT 24
11374: PPUSH
11375: LD_INT 7
11377: PPUSH
11378: CALL_OW 321
11382: PUSH
11383: LD_INT 2
11385: EQUAL
11386: IFFALSE 12077
11388: GO 11390
11390: DISABLE
11391: LD_INT 0
11393: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11394: LD_ADDR_VAR 0 1
11398: PUSH
11399: LD_INT 22
11401: PUSH
11402: LD_INT 7
11404: PUSH
11405: EMPTY
11406: LIST
11407: LIST
11408: PUSH
11409: LD_INT 23
11411: PUSH
11412: LD_INT 3
11414: PUSH
11415: EMPTY
11416: LIST
11417: LIST
11418: PUSH
11419: LD_INT 25
11421: PUSH
11422: LD_INT 4
11424: PUSH
11425: EMPTY
11426: LIST
11427: LIST
11428: PUSH
11429: LD_INT 21
11431: PUSH
11432: LD_INT 1
11434: PUSH
11435: EMPTY
11436: LIST
11437: LIST
11438: PUSH
11439: LD_INT 26
11441: PUSH
11442: LD_INT 1
11444: PUSH
11445: EMPTY
11446: LIST
11447: LIST
11448: PUSH
11449: EMPTY
11450: LIST
11451: LIST
11452: LIST
11453: LIST
11454: LIST
11455: PPUSH
11456: CALL_OW 69
11460: PUSH
11461: LD_EXP 13
11465: PUSH
11466: LD_EXP 12
11470: PUSH
11471: LD_EXP 44
11475: PUSH
11476: LD_EXP 32
11480: PUSH
11481: LD_EXP 42
11485: PUSH
11486: LD_EXP 41
11490: PUSH
11491: EMPTY
11492: LIST
11493: LIST
11494: LIST
11495: LIST
11496: LIST
11497: LIST
11498: DIFF
11499: ST_TO_ADDR
// if not speaker then
11500: LD_VAR 0 1
11504: NOT
11505: IFFALSE 11509
// exit ;
11507: GO 12077
// DialogueOn ;
11509: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
11513: LD_VAR 0 1
11517: PUSH
11518: LD_INT 1
11520: ARRAY
11521: PPUSH
11522: LD_STRING DArtefTechnology-RSci1-1
11524: PPUSH
11525: CALL_OW 88
// if IsOk ( Burlak ) then
11529: LD_EXP 44
11533: PPUSH
11534: CALL_OW 302
11538: IFFALSE 11552
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
11540: LD_EXP 44
11544: PPUSH
11545: LD_STRING DArtefTechnology-Bur-1
11547: PPUSH
11548: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
11552: LD_VAR 0 1
11556: PUSH
11557: LD_INT 1
11559: ARRAY
11560: PPUSH
11561: LD_STRING DArtefTechnology-RSci1-2
11563: PPUSH
11564: CALL_OW 88
// if Denis then
11568: LD_EXP 18
11572: IFFALSE 11589
// speaker := [ Denis ] else
11574: LD_ADDR_VAR 0 1
11578: PUSH
11579: LD_EXP 18
11583: PUSH
11584: EMPTY
11585: LIST
11586: ST_TO_ADDR
11587: GO 11695
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11589: LD_ADDR_VAR 0 1
11593: PUSH
11594: LD_INT 22
11596: PUSH
11597: LD_INT 7
11599: PUSH
11600: EMPTY
11601: LIST
11602: LIST
11603: PUSH
11604: LD_INT 23
11606: PUSH
11607: LD_INT 1
11609: PUSH
11610: EMPTY
11611: LIST
11612: LIST
11613: PUSH
11614: LD_INT 25
11616: PUSH
11617: LD_INT 4
11619: PUSH
11620: EMPTY
11621: LIST
11622: LIST
11623: PUSH
11624: LD_INT 21
11626: PUSH
11627: LD_INT 1
11629: PUSH
11630: EMPTY
11631: LIST
11632: LIST
11633: PUSH
11634: LD_INT 26
11636: PUSH
11637: LD_INT 1
11639: PUSH
11640: EMPTY
11641: LIST
11642: LIST
11643: PUSH
11644: EMPTY
11645: LIST
11646: LIST
11647: LIST
11648: LIST
11649: LIST
11650: PPUSH
11651: CALL_OW 69
11655: PUSH
11656: LD_EXP 13
11660: PUSH
11661: LD_EXP 12
11665: PUSH
11666: LD_EXP 44
11670: PUSH
11671: LD_EXP 32
11675: PUSH
11676: LD_EXP 42
11680: PUSH
11681: LD_EXP 41
11685: PUSH
11686: EMPTY
11687: LIST
11688: LIST
11689: LIST
11690: LIST
11691: LIST
11692: LIST
11693: DIFF
11694: ST_TO_ADDR
// if speaker then
11695: LD_VAR 0 1
11699: IFFALSE 11717
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
11701: LD_VAR 0 1
11705: PUSH
11706: LD_INT 1
11708: ARRAY
11709: PPUSH
11710: LD_STRING DArtefTechnology-Sci1-2
11712: PPUSH
11713: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11717: LD_ADDR_VAR 0 1
11721: PUSH
11722: LD_INT 22
11724: PUSH
11725: LD_INT 7
11727: PUSH
11728: EMPTY
11729: LIST
11730: LIST
11731: PUSH
11732: LD_INT 23
11734: PUSH
11735: LD_INT 3
11737: PUSH
11738: EMPTY
11739: LIST
11740: LIST
11741: PUSH
11742: LD_INT 25
11744: PUSH
11745: LD_INT 4
11747: PUSH
11748: EMPTY
11749: LIST
11750: LIST
11751: PUSH
11752: LD_INT 21
11754: PUSH
11755: LD_INT 1
11757: PUSH
11758: EMPTY
11759: LIST
11760: LIST
11761: PUSH
11762: LD_INT 26
11764: PUSH
11765: LD_INT 1
11767: PUSH
11768: EMPTY
11769: LIST
11770: LIST
11771: PUSH
11772: EMPTY
11773: LIST
11774: LIST
11775: LIST
11776: LIST
11777: LIST
11778: PPUSH
11779: CALL_OW 69
11783: PUSH
11784: LD_EXP 13
11788: PUSH
11789: LD_EXP 12
11793: PUSH
11794: LD_EXP 44
11798: PUSH
11799: LD_EXP 32
11803: PUSH
11804: LD_EXP 42
11808: PUSH
11809: LD_EXP 41
11813: PUSH
11814: EMPTY
11815: LIST
11816: LIST
11817: LIST
11818: LIST
11819: LIST
11820: LIST
11821: DIFF
11822: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
11823: LD_VAR 0 1
11827: PUSH
11828: LD_EXP 6
11832: PUSH
11833: LD_EXP 5
11837: OR
11838: AND
11839: IFFALSE 12073
// begin if arabianDestroyed and IsOk ( Burlak ) then
11841: LD_EXP 5
11845: PUSH
11846: LD_EXP 44
11850: PPUSH
11851: CALL_OW 302
11855: AND
11856: IFFALSE 11872
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
11858: LD_EXP 44
11862: PPUSH
11863: LD_STRING DArtefTechnology-Bur-2
11865: PPUSH
11866: CALL_OW 88
11870: GO 11884
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
11872: LD_EXP 12
11876: PPUSH
11877: LD_STRING DArtefTechnology-JMM-2
11879: PPUSH
11880: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
11884: LD_VAR 0 1
11888: PUSH
11889: LD_INT 1
11891: ARRAY
11892: PPUSH
11893: LD_STRING DArtefTechnology-RSci1-3
11895: PPUSH
11896: CALL_OW 88
// if Denis then
11900: LD_EXP 18
11904: IFFALSE 11921
// speaker := [ Denis ] else
11906: LD_ADDR_VAR 0 1
11910: PUSH
11911: LD_EXP 18
11915: PUSH
11916: EMPTY
11917: LIST
11918: ST_TO_ADDR
11919: GO 12027
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11921: LD_ADDR_VAR 0 1
11925: PUSH
11926: LD_INT 22
11928: PUSH
11929: LD_INT 7
11931: PUSH
11932: EMPTY
11933: LIST
11934: LIST
11935: PUSH
11936: LD_INT 23
11938: PUSH
11939: LD_INT 1
11941: PUSH
11942: EMPTY
11943: LIST
11944: LIST
11945: PUSH
11946: LD_INT 25
11948: PUSH
11949: LD_INT 4
11951: PUSH
11952: EMPTY
11953: LIST
11954: LIST
11955: PUSH
11956: LD_INT 21
11958: PUSH
11959: LD_INT 1
11961: PUSH
11962: EMPTY
11963: LIST
11964: LIST
11965: PUSH
11966: LD_INT 26
11968: PUSH
11969: LD_INT 1
11971: PUSH
11972: EMPTY
11973: LIST
11974: LIST
11975: PUSH
11976: EMPTY
11977: LIST
11978: LIST
11979: LIST
11980: LIST
11981: LIST
11982: PPUSH
11983: CALL_OW 69
11987: PUSH
11988: LD_EXP 13
11992: PUSH
11993: LD_EXP 12
11997: PUSH
11998: LD_EXP 44
12002: PUSH
12003: LD_EXP 32
12007: PUSH
12008: LD_EXP 42
12012: PUSH
12013: LD_EXP 41
12017: PUSH
12018: EMPTY
12019: LIST
12020: LIST
12021: LIST
12022: LIST
12023: LIST
12024: LIST
12025: DIFF
12026: ST_TO_ADDR
// if speaker then
12027: LD_VAR 0 1
12031: IFFALSE 12073
// if alienSpotted then
12033: LD_EXP 7
12037: IFFALSE 12057
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
12039: LD_VAR 0 1
12043: PUSH
12044: LD_INT 1
12046: ARRAY
12047: PPUSH
12048: LD_STRING DArtefTechnology-Sci1-3
12050: PPUSH
12051: CALL_OW 88
12055: GO 12073
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
12057: LD_VAR 0 1
12061: PUSH
12062: LD_INT 1
12064: ARRAY
12065: PPUSH
12066: LD_STRING DArtefTechnology-Sci1-3a
12068: PPUSH
12069: CALL_OW 88
// end ; DialogueOff ;
12073: CALL_OW 7
// end ;
12077: PPOPN 1
12079: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
12080: LD_EXP 9
12084: IFFALSE 12279
12086: GO 12088
12088: DISABLE
12089: LD_INT 0
12091: PPUSH
// begin if Denis then
12092: LD_EXP 18
12096: IFFALSE 12113
// speaker := [ Denis ] else
12098: LD_ADDR_VAR 0 1
12102: PUSH
12103: LD_EXP 18
12107: PUSH
12108: EMPTY
12109: LIST
12110: ST_TO_ADDR
12111: GO 12219
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12113: LD_ADDR_VAR 0 1
12117: PUSH
12118: LD_INT 22
12120: PUSH
12121: LD_INT 7
12123: PUSH
12124: EMPTY
12125: LIST
12126: LIST
12127: PUSH
12128: LD_INT 23
12130: PUSH
12131: LD_INT 1
12133: PUSH
12134: EMPTY
12135: LIST
12136: LIST
12137: PUSH
12138: LD_INT 25
12140: PUSH
12141: LD_INT 4
12143: PUSH
12144: EMPTY
12145: LIST
12146: LIST
12147: PUSH
12148: LD_INT 21
12150: PUSH
12151: LD_INT 1
12153: PUSH
12154: EMPTY
12155: LIST
12156: LIST
12157: PUSH
12158: LD_INT 26
12160: PUSH
12161: LD_INT 1
12163: PUSH
12164: EMPTY
12165: LIST
12166: LIST
12167: PUSH
12168: EMPTY
12169: LIST
12170: LIST
12171: LIST
12172: LIST
12173: LIST
12174: PPUSH
12175: CALL_OW 69
12179: PUSH
12180: LD_EXP 13
12184: PUSH
12185: LD_EXP 12
12189: PUSH
12190: LD_EXP 44
12194: PUSH
12195: LD_EXP 32
12199: PUSH
12200: LD_EXP 42
12204: PUSH
12205: LD_EXP 41
12209: PUSH
12210: EMPTY
12211: LIST
12212: LIST
12213: LIST
12214: LIST
12215: LIST
12216: LIST
12217: DIFF
12218: ST_TO_ADDR
// if not speaker then
12219: LD_VAR 0 1
12223: NOT
12224: IFFALSE 12228
// exit ;
12226: GO 12279
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
12228: LD_VAR 0 1
12232: PUSH
12233: LD_INT 1
12235: ARRAY
12236: PPUSH
12237: LD_STRING DArtefTechnologyAm-Sci1-1
12239: PPUSH
12240: CALL_OW 88
// if IsOk ( Burlak ) then
12244: LD_EXP 44
12248: PPUSH
12249: CALL_OW 302
12253: IFFALSE 12267
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
12255: LD_EXP 44
12259: PPUSH
12260: LD_STRING DArtefTechnologyAm-Bur-1
12262: PPUSH
12263: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
12267: LD_EXP 12
12271: PPUSH
12272: LD_STRING DArtefTechnologyAm-JMM-1
12274: PPUSH
12275: CALL_OW 88
// end ;
12279: PPOPN 1
12281: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
12282: LD_EXP 10
12286: IFFALSE 12497
12288: GO 12290
12290: DISABLE
12291: LD_INT 0
12293: PPUSH
// begin if Denis then
12294: LD_EXP 18
12298: IFFALSE 12315
// speaker := [ Denis ] else
12300: LD_ADDR_VAR 0 1
12304: PUSH
12305: LD_EXP 18
12309: PUSH
12310: EMPTY
12311: LIST
12312: ST_TO_ADDR
12313: GO 12421
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12315: LD_ADDR_VAR 0 1
12319: PUSH
12320: LD_INT 22
12322: PUSH
12323: LD_INT 7
12325: PUSH
12326: EMPTY
12327: LIST
12328: LIST
12329: PUSH
12330: LD_INT 23
12332: PUSH
12333: LD_INT 3
12335: PUSH
12336: EMPTY
12337: LIST
12338: LIST
12339: PUSH
12340: LD_INT 25
12342: PUSH
12343: LD_INT 4
12345: PUSH
12346: EMPTY
12347: LIST
12348: LIST
12349: PUSH
12350: LD_INT 21
12352: PUSH
12353: LD_INT 1
12355: PUSH
12356: EMPTY
12357: LIST
12358: LIST
12359: PUSH
12360: LD_INT 26
12362: PUSH
12363: LD_INT 1
12365: PUSH
12366: EMPTY
12367: LIST
12368: LIST
12369: PUSH
12370: EMPTY
12371: LIST
12372: LIST
12373: LIST
12374: LIST
12375: LIST
12376: PPUSH
12377: CALL_OW 69
12381: PUSH
12382: LD_EXP 13
12386: PUSH
12387: LD_EXP 12
12391: PUSH
12392: LD_EXP 44
12396: PUSH
12397: LD_EXP 32
12401: PUSH
12402: LD_EXP 42
12406: PUSH
12407: LD_EXP 41
12411: PUSH
12412: EMPTY
12413: LIST
12414: LIST
12415: LIST
12416: LIST
12417: LIST
12418: LIST
12419: DIFF
12420: ST_TO_ADDR
// if not speaker then
12421: LD_VAR 0 1
12425: NOT
12426: IFFALSE 12430
// exit ;
12428: GO 12497
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-1 ) ;
12430: LD_VAR 0 1
12434: PUSH
12435: LD_INT 1
12437: ARRAY
12438: PPUSH
12439: LD_STRING DArtefTechnologyRu-RSci1-1
12441: PPUSH
12442: CALL_OW 88
// if IsOk ( Burlak ) then
12446: LD_EXP 44
12450: PPUSH
12451: CALL_OW 302
12455: IFFALSE 12469
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
12457: LD_EXP 44
12461: PPUSH
12462: LD_STRING DArtefTechnologyRu-Bur-1
12464: PPUSH
12465: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-2 ) ;
12469: LD_VAR 0 1
12473: PUSH
12474: LD_INT 1
12476: ARRAY
12477: PPUSH
12478: LD_STRING DArtefTechnologyRu-RSci1-2
12480: PPUSH
12481: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
12485: LD_EXP 12
12489: PPUSH
12490: LD_STRING DArtefTechnologyRu-JMM-1
12492: PPUSH
12493: CALL_OW 88
// end ;
12497: PPOPN 1
12499: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
12500: LD_INT 24
12502: PPUSH
12503: LD_INT 7
12505: PPUSH
12506: CALL_OW 321
12510: PUSH
12511: LD_INT 2
12513: EQUAL
12514: PUSH
12515: LD_INT 1
12517: PPUSH
12518: CALL_OW 255
12522: PUSH
12523: LD_INT 7
12525: EQUAL
12526: AND
12527: IFFALSE 12687
12529: GO 12531
12531: DISABLE
12532: LD_INT 0
12534: PPUSH
// begin if Denis then
12535: LD_EXP 18
12539: IFFALSE 12556
// speaker := [ Denis ] else
12541: LD_ADDR_VAR 0 1
12545: PUSH
12546: LD_EXP 18
12550: PUSH
12551: EMPTY
12552: LIST
12553: ST_TO_ADDR
12554: GO 12662
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12556: LD_ADDR_VAR 0 1
12560: PUSH
12561: LD_INT 22
12563: PUSH
12564: LD_INT 7
12566: PUSH
12567: EMPTY
12568: LIST
12569: LIST
12570: PUSH
12571: LD_INT 23
12573: PUSH
12574: LD_INT 1
12576: PUSH
12577: EMPTY
12578: LIST
12579: LIST
12580: PUSH
12581: LD_INT 25
12583: PUSH
12584: LD_INT 4
12586: PUSH
12587: EMPTY
12588: LIST
12589: LIST
12590: PUSH
12591: LD_INT 21
12593: PUSH
12594: LD_INT 1
12596: PUSH
12597: EMPTY
12598: LIST
12599: LIST
12600: PUSH
12601: LD_INT 26
12603: PUSH
12604: LD_INT 1
12606: PUSH
12607: EMPTY
12608: LIST
12609: LIST
12610: PUSH
12611: EMPTY
12612: LIST
12613: LIST
12614: LIST
12615: LIST
12616: LIST
12617: PPUSH
12618: CALL_OW 69
12622: PUSH
12623: LD_EXP 13
12627: PUSH
12628: LD_EXP 12
12632: PUSH
12633: LD_EXP 44
12637: PUSH
12638: LD_EXP 32
12642: PUSH
12643: LD_EXP 42
12647: PUSH
12648: LD_EXP 41
12652: PUSH
12653: EMPTY
12654: LIST
12655: LIST
12656: LIST
12657: LIST
12658: LIST
12659: LIST
12660: DIFF
12661: ST_TO_ADDR
// if not speaker then
12662: LD_VAR 0 1
12666: NOT
12667: IFFALSE 12671
// exit ;
12669: GO 12687
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
12671: LD_VAR 0 1
12675: PUSH
12676: LD_INT 1
12678: ARRAY
12679: PPUSH
12680: LD_STRING DArtefTechnologyArStart-Sci1-1
12682: PPUSH
12683: CALL_OW 88
// end ;
12687: PPOPN 1
12689: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
12690: LD_EXP 11
12694: IFFALSE 12975
12696: GO 12698
12698: DISABLE
12699: LD_INT 0
12701: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12702: LD_ADDR_VAR 0 1
12706: PUSH
12707: LD_INT 22
12709: PUSH
12710: LD_INT 7
12712: PUSH
12713: EMPTY
12714: LIST
12715: LIST
12716: PUSH
12717: LD_INT 23
12719: PUSH
12720: LD_INT 3
12722: PUSH
12723: EMPTY
12724: LIST
12725: LIST
12726: PUSH
12727: LD_INT 25
12729: PUSH
12730: LD_INT 4
12732: PUSH
12733: EMPTY
12734: LIST
12735: LIST
12736: PUSH
12737: LD_INT 21
12739: PUSH
12740: LD_INT 1
12742: PUSH
12743: EMPTY
12744: LIST
12745: LIST
12746: PUSH
12747: LD_INT 26
12749: PUSH
12750: LD_INT 1
12752: PUSH
12753: EMPTY
12754: LIST
12755: LIST
12756: PUSH
12757: EMPTY
12758: LIST
12759: LIST
12760: LIST
12761: LIST
12762: LIST
12763: PPUSH
12764: CALL_OW 69
12768: PUSH
12769: LD_EXP 13
12773: PUSH
12774: LD_EXP 12
12778: PUSH
12779: LD_EXP 44
12783: PUSH
12784: LD_EXP 32
12788: PUSH
12789: LD_EXP 42
12793: PUSH
12794: LD_EXP 41
12798: PUSH
12799: EMPTY
12800: LIST
12801: LIST
12802: LIST
12803: LIST
12804: LIST
12805: LIST
12806: DIFF
12807: ST_TO_ADDR
// if not speaker then
12808: LD_VAR 0 1
12812: NOT
12813: IFFALSE 12817
// exit ;
12815: GO 12975
// DialogueOn ;
12817: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
12821: LD_VAR 0 1
12825: PUSH
12826: LD_INT 1
12828: ARRAY
12829: PPUSH
12830: LD_STRING DArtefTechnologyAr-RSci1-1
12832: PPUSH
12833: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
12837: LD_EXP 12
12841: PPUSH
12842: LD_STRING DArtefTechnologyAr-JMM-1
12844: PPUSH
12845: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
12849: LD_VAR 0 1
12853: PUSH
12854: LD_INT 1
12856: ARRAY
12857: PPUSH
12858: LD_STRING DArtefTechnologyAr-RSci1-2
12860: PPUSH
12861: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
12865: LD_EXP 12
12869: PPUSH
12870: LD_STRING DArtefTechnologyAr-JMM-2
12872: PPUSH
12873: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
12877: LD_VAR 0 1
12881: PUSH
12882: LD_INT 1
12884: ARRAY
12885: PPUSH
12886: LD_STRING DArtefTechnologyAr-RSci1-3
12888: PPUSH
12889: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
12893: LD_EXP 12
12897: PPUSH
12898: LD_STRING DArtefTechnologyAr-JMM-3
12900: PPUSH
12901: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
12905: LD_VAR 0 1
12909: PUSH
12910: LD_INT 1
12912: ARRAY
12913: PPUSH
12914: LD_STRING DArtefTechnologyAr-RSci1-4
12916: PPUSH
12917: CALL_OW 88
// if IsOk ( Burlak ) then
12921: LD_EXP 44
12925: PPUSH
12926: CALL_OW 302
12930: IFFALSE 12944
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
12932: LD_EXP 44
12936: PPUSH
12937: LD_STRING DArtefTechnologyAr-Bur-4
12939: PPUSH
12940: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
12944: LD_EXP 12
12948: PPUSH
12949: LD_STRING DArtefTechnologyAr-JMM-4
12951: PPUSH
12952: CALL_OW 88
// DialogueOff ;
12956: CALL_OW 7
// wait ( 0 0$45 ) ;
12960: LD_INT 1575
12962: PPUSH
12963: CALL_OW 67
// spawnOmar := true ;
12967: LD_ADDR_EXP 8
12971: PUSH
12972: LD_INT 1
12974: ST_TO_ADDR
// end ;
12975: PPOPN 1
12977: END
// every 0 0$1 trigger spawnOmar do
12978: LD_EXP 8
12982: IFFALSE 13280
12984: GO 12986
12986: DISABLE
// begin PrepareOmarAli ;
12987: CALL 6510 0 0
// if not Omar then
12991: LD_EXP 48
12995: NOT
12996: IFFALSE 13000
// exit ;
12998: GO 13280
// repeat wait ( 0 0$1 ) ;
13000: LD_INT 35
13002: PPUSH
13003: CALL_OW 67
// until See ( 7 , Omar ) ;
13007: LD_INT 7
13009: PPUSH
13010: LD_EXP 48
13014: PPUSH
13015: CALL_OW 292
13019: IFFALSE 13000
// CenterNowOnUnits ( Omar ) ;
13021: LD_EXP 48
13025: PPUSH
13026: CALL_OW 87
// DialogueOn ;
13030: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
13034: LD_EXP 48
13038: PPUSH
13039: LD_STRING DOmar-Omar-1
13041: PPUSH
13042: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
13046: LD_EXP 12
13050: PPUSH
13051: LD_STRING DOmar-JMM-1
13053: PPUSH
13054: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
13058: LD_EXP 48
13062: PPUSH
13063: LD_STRING DOmar-Omar-2
13065: PPUSH
13066: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
13070: LD_EXP 12
13074: PPUSH
13075: LD_STRING DOmar-JMM-2
13077: PPUSH
13078: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
13082: LD_EXP 48
13086: PPUSH
13087: LD_STRING DOmar-Omar-3
13089: PPUSH
13090: CALL_OW 88
// if IsOk ( Burlak ) then
13094: LD_EXP 44
13098: PPUSH
13099: CALL_OW 302
13103: IFFALSE 13119
// Say ( Burlak , DOmar-Bur-3 ) else
13105: LD_EXP 44
13109: PPUSH
13110: LD_STRING DOmar-Bur-3
13112: PPUSH
13113: CALL_OW 88
13117: GO 13131
// Say ( JMM , DOmar-JMM-3 ) ;
13119: LD_EXP 12
13123: PPUSH
13124: LD_STRING DOmar-JMM-3
13126: PPUSH
13127: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
13131: LD_EXP 48
13135: PPUSH
13136: LD_STRING DOmar-Omar-4
13138: PPUSH
13139: CALL_OW 88
// case Query ( QAccept ) of 1 :
13143: LD_STRING QAccept
13145: PPUSH
13146: CALL_OW 97
13150: PUSH
13151: LD_INT 1
13153: DOUBLE
13154: EQUAL
13155: IFTRUE 13159
13157: GO 13195
13159: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
13160: LD_EXP 12
13164: PPUSH
13165: LD_STRING DQrAccept#1-JMM-1
13167: PPUSH
13168: CALL_OW 88
// SetSide ( Omar , 7 ) ;
13172: LD_EXP 48
13176: PPUSH
13177: LD_INT 7
13179: PPUSH
13180: CALL_OW 235
// ComStop ( Omar ) ;
13184: LD_EXP 48
13188: PPUSH
13189: CALL_OW 141
// end ; 2 :
13193: GO 13244
13195: LD_INT 2
13197: DOUBLE
13198: EQUAL
13199: IFTRUE 13203
13201: GO 13243
13203: POP
// begin if IsOk ( Burlak ) then
13204: LD_EXP 44
13208: PPUSH
13209: CALL_OW 302
13213: IFFALSE 13229
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
13215: LD_EXP 44
13219: PPUSH
13220: LD_STRING DQrAccept#2-Bur-1
13222: PPUSH
13223: CALL_OW 88
13227: GO 13241
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
13229: LD_EXP 12
13233: PPUSH
13234: LD_STRING DQrAccept#2-JMM-1
13236: PPUSH
13237: CALL_OW 88
// end ; end ;
13241: GO 13244
13243: POP
// DialogueOff ;
13244: CALL_OW 7
// if GetSide ( Omar ) = 7 then
13248: LD_EXP 48
13252: PPUSH
13253: CALL_OW 255
13257: PUSH
13258: LD_INT 7
13260: EQUAL
13261: IFFALSE 13265
// exit ;
13263: GO 13280
// ComMoveXY ( Omar , 202 , 115 ) ;
13265: LD_EXP 48
13269: PPUSH
13270: LD_INT 202
13272: PPUSH
13273: LD_INT 115
13275: PPUSH
13276: CALL_OW 111
// end ;
13280: END
// every 0 0$1 trigger GetDistUnitXY ( Omar , 200 , 98 ) < 40 and russianDestroyed do
13281: LD_EXP 48
13285: PPUSH
13286: LD_INT 200
13288: PPUSH
13289: LD_INT 98
13291: PPUSH
13292: CALL_OW 297
13296: PUSH
13297: LD_INT 40
13299: LESS
13300: PUSH
13301: LD_EXP 2
13305: AND
13306: IFFALSE 13524
13308: GO 13310
13310: DISABLE
// begin SetSide ( Omar , 5 ) ;
13311: LD_EXP 48
13315: PPUSH
13316: LD_INT 5
13318: PPUSH
13319: CALL_OW 235
// if IsInUnit ( Omar ) then
13323: LD_EXP 48
13327: PPUSH
13328: CALL_OW 310
13332: IFFALSE 13343
// ComExitVehicle ( Omar ) ;
13334: LD_EXP 48
13338: PPUSH
13339: CALL_OW 121
// if IsInUnit ( Omar ) then
13343: LD_EXP 48
13347: PPUSH
13348: CALL_OW 310
13352: IFFALSE 13363
// ComExitBuilding ( Omar ) ;
13354: LD_EXP 48
13358: PPUSH
13359: CALL_OW 122
// wait ( 0 0$1 ) ;
13363: LD_INT 35
13365: PPUSH
13366: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
13370: LD_EXP 48
13374: PPUSH
13375: LD_INT 203
13377: PPUSH
13378: LD_INT 120
13380: PPUSH
13381: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
13385: LD_INT 35
13387: PPUSH
13388: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 6 ;
13392: LD_EXP 48
13396: PPUSH
13397: CALL_OW 306
13401: PUSH
13402: LD_EXP 48
13406: PPUSH
13407: LD_INT 203
13409: PPUSH
13410: LD_INT 120
13412: PPUSH
13413: CALL_OW 297
13417: PUSH
13418: LD_INT 6
13420: LESS
13421: OR
13422: IFFALSE 13385
// CenterNowOnUnits ( Omar ) ;
13424: LD_EXP 48
13428: PPUSH
13429: CALL_OW 87
// DialogueOn ;
13433: CALL_OW 6
// Say ( JMM , DOmarContam-JMM-1 ) ;
13437: LD_EXP 12
13441: PPUSH
13442: LD_STRING DOmarContam-JMM-1
13444: PPUSH
13445: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
13449: LD_EXP 48
13453: PPUSH
13454: LD_STRING DOmarContam-Omar-1
13456: PPUSH
13457: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
13461: LD_EXP 12
13465: PPUSH
13466: LD_STRING DOmarContam-JMM-2
13468: PPUSH
13469: CALL_OW 88
// DialogueOff ;
13473: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
13477: LD_INT 5
13479: PPUSH
13480: LD_INT 7
13482: PPUSH
13483: LD_INT 2
13485: PPUSH
13486: LD_INT 1
13488: PPUSH
13489: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
13493: LD_INT 105
13495: PPUSH
13496: CALL_OW 67
// until IsAt ( Omar , 203 , 120 ) ;
13500: LD_EXP 48
13504: PPUSH
13505: LD_INT 203
13507: PPUSH
13508: LD_INT 120
13510: PPUSH
13511: CALL_OW 307
13515: IFFALSE 13493
// YouLost ( MothContaminate ) ;
13517: LD_STRING MothContaminate
13519: PPUSH
13520: CALL_OW 104
// end ;
13524: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
13525: LD_EXP 4
13529: NOT
13530: PUSH
13531: LD_INT 22
13533: PUSH
13534: LD_INT 1
13536: PUSH
13537: EMPTY
13538: LIST
13539: LIST
13540: PUSH
13541: LD_INT 34
13543: PUSH
13544: LD_INT 8
13546: PUSH
13547: EMPTY
13548: LIST
13549: LIST
13550: PUSH
13551: EMPTY
13552: LIST
13553: LIST
13554: PPUSH
13555: CALL_OW 69
13559: AND
13560: IFFALSE 13641
13562: GO 13564
13564: DISABLE
// begin if not IsOk ( Powell ) then
13565: LD_EXP 47
13569: PPUSH
13570: CALL_OW 302
13574: NOT
13575: IFFALSE 13579
// exit ;
13577: GO 13641
// DialogueOn ;
13579: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
13583: LD_EXP 47
13587: PPUSH
13588: LD_STRING DWinAmericans-Pow-1
13590: PPUSH
13591: CALL_OW 94
// if IsOk ( Burlak ) then
13595: LD_EXP 44
13599: PPUSH
13600: CALL_OW 302
13604: IFFALSE 13618
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
13606: LD_EXP 44
13610: PPUSH
13611: LD_STRING DWinAmericans-Bur-1
13613: PPUSH
13614: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
13618: LD_EXP 12
13622: PPUSH
13623: LD_STRING DWinAmericans-JMM-1
13625: PPUSH
13626: CALL_OW 88
// DialogueOff ;
13630: CALL_OW 7
// YouLost ( AmBomb ) ;
13634: LD_STRING AmBomb
13636: PPUSH
13637: CALL_OW 104
// end ;
13641: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
13642: LD_EXP 2
13646: NOT
13647: PUSH
13648: LD_INT 22
13650: PUSH
13651: LD_INT 3
13653: PUSH
13654: EMPTY
13655: LIST
13656: LIST
13657: PUSH
13658: LD_INT 34
13660: PUSH
13661: LD_INT 48
13663: PUSH
13664: EMPTY
13665: LIST
13666: LIST
13667: PUSH
13668: EMPTY
13669: LIST
13670: LIST
13671: PPUSH
13672: CALL_OW 69
13676: AND
13677: IFFALSE 13758
13679: GO 13681
13681: DISABLE
// begin if not IsOk ( Platonov ) then
13682: LD_EXP 51
13686: PPUSH
13687: CALL_OW 302
13691: NOT
13692: IFFALSE 13696
// exit ;
13694: GO 13758
// DialogueOn ;
13696: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
13700: LD_EXP 51
13704: PPUSH
13705: LD_STRING DWinRussians-Pla-1
13707: PPUSH
13708: CALL_OW 94
// if IsOk ( Burlak ) then
13712: LD_EXP 44
13716: PPUSH
13717: CALL_OW 302
13721: IFFALSE 13735
// Say ( Burlak , DWinRussians-Bur-1 ) ;
13723: LD_EXP 44
13727: PPUSH
13728: LD_STRING DWinRussians-Bur-1
13730: PPUSH
13731: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
13735: LD_EXP 12
13739: PPUSH
13740: LD_STRING DWinRussians-JMM-1
13742: PPUSH
13743: CALL_OW 88
// DialogueOff ;
13747: CALL_OW 7
// YouLost ( RuBomb ) ;
13751: LD_STRING RuBomb
13753: PPUSH
13754: CALL_OW 104
// end ;
13758: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
13759: LD_INT 7
13761: PPUSH
13762: LD_INT 22
13764: PUSH
13765: LD_INT 7
13767: PUSH
13768: EMPTY
13769: LIST
13770: LIST
13771: PPUSH
13772: CALL_OW 70
13776: PUSH
13777: LD_EXP 4
13781: NOT
13782: AND
13783: IFFALSE 13812
13785: GO 13787
13787: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
13788: LD_EXP 47
13792: PPUSH
13793: LD_STRING DSurrenderAmericans-Pow-1
13795: PPUSH
13796: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
13800: LD_EXP 12
13804: PPUSH
13805: LD_STRING DSurrenderAmericans-JMM-1
13807: PPUSH
13808: CALL_OW 88
// end ;
13812: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
13813: LD_INT 2
13815: PPUSH
13816: LD_INT 22
13818: PUSH
13819: LD_INT 7
13821: PUSH
13822: EMPTY
13823: LIST
13824: LIST
13825: PPUSH
13826: CALL_OW 70
13830: PUSH
13831: LD_EXP 2
13835: NOT
13836: AND
13837: PUSH
13838: LD_EXP 44
13842: AND
13843: IFFALSE 13872
13845: GO 13847
13847: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
13848: LD_EXP 51
13852: PPUSH
13853: LD_STRING DSurrenderRussians-Pla-1
13855: PPUSH
13856: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
13860: LD_EXP 44
13864: PPUSH
13865: LD_STRING DSurrenderRussians-Bur-1
13867: PPUSH
13868: CALL_OW 88
// end ;
13872: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
13873: LD_EXP 4
13877: IFFALSE 14252
13879: GO 13881
13881: DISABLE
13882: LD_INT 0
13884: PPUSH
13885: PPUSH
13886: PPUSH
// begin MC_Kill ( 4 ) ;
13887: LD_INT 4
13889: PPUSH
13890: CALL 20342 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
13894: LD_INT 1
13896: PPUSH
13897: LD_INT 7
13899: PPUSH
13900: LD_INT 1
13902: PPUSH
13903: LD_INT 1
13905: PPUSH
13906: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
13910: LD_ADDR_VAR 0 3
13914: PUSH
13915: LD_INT 22
13917: PUSH
13918: LD_INT 1
13920: PUSH
13921: EMPTY
13922: LIST
13923: LIST
13924: PUSH
13925: LD_INT 26
13927: PUSH
13928: LD_INT 1
13930: PUSH
13931: EMPTY
13932: LIST
13933: LIST
13934: PUSH
13935: LD_INT 23
13937: PUSH
13938: LD_INT 1
13940: PUSH
13941: EMPTY
13942: LIST
13943: LIST
13944: PUSH
13945: EMPTY
13946: LIST
13947: LIST
13948: LIST
13949: PPUSH
13950: CALL_OW 69
13954: PUSH
13955: LD_EXP 47
13959: PUSH
13960: LD_EXP 20
13964: PUSH
13965: LD_EXP 17
13969: PUSH
13970: LD_EXP 16
13974: PUSH
13975: LD_EXP 23
13979: PUSH
13980: LD_EXP 21
13984: PUSH
13985: EMPTY
13986: LIST
13987: LIST
13988: LIST
13989: LIST
13990: LIST
13991: LIST
13992: DIFF
13993: ST_TO_ADDR
// if speaker then
13994: LD_VAR 0 3
13998: IFFALSE 14024
// begin DialogueOn ;
14000: CALL_OW 6
// SayRadio ( speaker [ 1 ] , DSurrenderAmericans-Sol1-1a ) ;
14004: LD_VAR 0 3
14008: PUSH
14009: LD_INT 1
14011: ARRAY
14012: PPUSH
14013: LD_STRING DSurrenderAmericans-Sol1-1a
14015: PPUSH
14016: CALL_OW 94
// DialogueOff ;
14020: CALL_OW 7
// end ; tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14024: LD_ADDR_VAR 0 2
14028: PUSH
14029: LD_INT 22
14031: PUSH
14032: LD_INT 1
14034: PUSH
14035: EMPTY
14036: LIST
14037: LIST
14038: PUSH
14039: LD_INT 21
14041: PUSH
14042: LD_INT 1
14044: PUSH
14045: EMPTY
14046: LIST
14047: LIST
14048: PUSH
14049: EMPTY
14050: LIST
14051: LIST
14052: PPUSH
14053: CALL_OW 69
14057: PUSH
14058: LD_INT 22
14060: PUSH
14061: LD_INT 1
14063: PUSH
14064: EMPTY
14065: LIST
14066: LIST
14067: PUSH
14068: LD_INT 21
14070: PUSH
14071: LD_INT 2
14073: PUSH
14074: EMPTY
14075: LIST
14076: LIST
14077: PUSH
14078: LD_INT 1
14080: PUSH
14081: EMPTY
14082: LIST
14083: PUSH
14084: EMPTY
14085: LIST
14086: LIST
14087: LIST
14088: PPUSH
14089: CALL_OW 69
14093: ADD
14094: ST_TO_ADDR
// if tmp then
14095: LD_VAR 0 2
14099: IFFALSE 14252
// repeat wait ( 0 0$1 ) ;
14101: LD_INT 35
14103: PPUSH
14104: CALL_OW 67
// for i in tmp do
14108: LD_ADDR_VAR 0 1
14112: PUSH
14113: LD_VAR 0 2
14117: PUSH
14118: FOR_IN
14119: IFFALSE 14201
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14121: LD_VAR 0 1
14125: PPUSH
14126: CALL_OW 310
14130: PUSH
14131: LD_VAR 0 1
14135: PPUSH
14136: CALL_OW 310
14140: PPUSH
14141: CALL_OW 247
14145: PUSH
14146: LD_INT 3
14148: EQUAL
14149: AND
14150: IFFALSE 14161
// ComExitBuilding ( i ) ;
14152: LD_VAR 0 1
14156: PPUSH
14157: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
14161: LD_VAR 0 1
14165: PPUSH
14166: LD_INT 122
14168: PPUSH
14169: LD_INT 242
14171: PPUSH
14172: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
14176: LD_VAR 0 1
14180: PPUSH
14181: LD_INT 35
14183: PPUSH
14184: CALL_OW 308
14188: IFFALSE 14199
// RemoveUnit ( i ) ;
14190: LD_VAR 0 1
14194: PPUSH
14195: CALL_OW 64
// end ;
14199: GO 14118
14201: POP
14202: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14203: LD_INT 22
14205: PUSH
14206: LD_INT 1
14208: PUSH
14209: EMPTY
14210: LIST
14211: LIST
14212: PUSH
14213: LD_INT 2
14215: PUSH
14216: LD_INT 21
14218: PUSH
14219: LD_INT 1
14221: PUSH
14222: EMPTY
14223: LIST
14224: LIST
14225: PUSH
14226: LD_INT 33
14228: PUSH
14229: LD_INT 1
14231: PUSH
14232: EMPTY
14233: LIST
14234: LIST
14235: PUSH
14236: EMPTY
14237: LIST
14238: LIST
14239: LIST
14240: PUSH
14241: EMPTY
14242: LIST
14243: LIST
14244: PPUSH
14245: CALL_OW 69
14249: NOT
14250: IFFALSE 14101
// end ;
14252: PPOPN 3
14254: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
14255: LD_EXP 2
14259: IFFALSE 14652
14261: GO 14263
14263: DISABLE
14264: LD_INT 0
14266: PPUSH
14267: PPUSH
14268: PPUSH
// begin repeat wait ( 0 0$1 ) ;
14269: LD_INT 35
14271: PPUSH
14272: CALL_OW 67
// until IsDead ( Yakotich ) ;
14276: LD_EXP 52
14280: PPUSH
14281: CALL_OW 301
14285: IFFALSE 14269
// MC_Kill ( 2 ) ;
14287: LD_INT 2
14289: PPUSH
14290: CALL 20342 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
14294: LD_INT 3
14296: PPUSH
14297: LD_INT 7
14299: PPUSH
14300: LD_INT 1
14302: PPUSH
14303: LD_INT 1
14305: PPUSH
14306: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff [ Platonov , Yakotich ] ;
14310: LD_ADDR_VAR 0 3
14314: PUSH
14315: LD_INT 22
14317: PUSH
14318: LD_INT 3
14320: PUSH
14321: EMPTY
14322: LIST
14323: LIST
14324: PUSH
14325: LD_INT 26
14327: PUSH
14328: LD_INT 1
14330: PUSH
14331: EMPTY
14332: LIST
14333: LIST
14334: PUSH
14335: LD_INT 23
14337: PUSH
14338: LD_INT 3
14340: PUSH
14341: EMPTY
14342: LIST
14343: LIST
14344: PUSH
14345: EMPTY
14346: LIST
14347: LIST
14348: LIST
14349: PPUSH
14350: CALL_OW 69
14354: PUSH
14355: LD_EXP 51
14359: PUSH
14360: LD_EXP 52
14364: PUSH
14365: EMPTY
14366: LIST
14367: LIST
14368: DIFF
14369: ST_TO_ADDR
// if speaker then
14370: LD_VAR 0 3
14374: IFFALSE 14424
// begin DialogueOn ;
14376: CALL_OW 6
// if Burlak then
14380: LD_EXP 44
14384: IFFALSE 14404
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1 ) else
14386: LD_VAR 0 3
14390: PUSH
14391: LD_INT 1
14393: ARRAY
14394: PPUSH
14395: LD_STRING DSurrenderRussians-RSol1-1
14397: PPUSH
14398: CALL_OW 94
14402: GO 14420
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1a ) ;
14404: LD_VAR 0 3
14408: PUSH
14409: LD_INT 1
14411: ARRAY
14412: PPUSH
14413: LD_STRING DSurrenderRussians-RSol1-1a
14415: PPUSH
14416: CALL_OW 94
// DialogueOff ;
14420: CALL_OW 7
// end ; tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14424: LD_ADDR_VAR 0 2
14428: PUSH
14429: LD_INT 22
14431: PUSH
14432: LD_INT 3
14434: PUSH
14435: EMPTY
14436: LIST
14437: LIST
14438: PUSH
14439: LD_INT 21
14441: PUSH
14442: LD_INT 1
14444: PUSH
14445: EMPTY
14446: LIST
14447: LIST
14448: PUSH
14449: EMPTY
14450: LIST
14451: LIST
14452: PPUSH
14453: CALL_OW 69
14457: PUSH
14458: LD_INT 22
14460: PUSH
14461: LD_INT 3
14463: PUSH
14464: EMPTY
14465: LIST
14466: LIST
14467: PUSH
14468: LD_INT 21
14470: PUSH
14471: LD_INT 2
14473: PUSH
14474: EMPTY
14475: LIST
14476: LIST
14477: PUSH
14478: LD_INT 1
14480: PUSH
14481: EMPTY
14482: LIST
14483: PUSH
14484: EMPTY
14485: LIST
14486: LIST
14487: LIST
14488: PPUSH
14489: CALL_OW 69
14493: ADD
14494: ST_TO_ADDR
// if tmp then
14495: LD_VAR 0 2
14499: IFFALSE 14652
// repeat wait ( 0 0$1 ) ;
14501: LD_INT 35
14503: PPUSH
14504: CALL_OW 67
// for i in tmp do
14508: LD_ADDR_VAR 0 1
14512: PUSH
14513: LD_VAR 0 2
14517: PUSH
14518: FOR_IN
14519: IFFALSE 14601
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14521: LD_VAR 0 1
14525: PPUSH
14526: CALL_OW 310
14530: PUSH
14531: LD_VAR 0 1
14535: PPUSH
14536: CALL_OW 310
14540: PPUSH
14541: CALL_OW 247
14545: PUSH
14546: LD_INT 3
14548: EQUAL
14549: AND
14550: IFFALSE 14561
// ComExitBuilding ( i ) ;
14552: LD_VAR 0 1
14556: PPUSH
14557: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
14561: LD_VAR 0 1
14565: PPUSH
14566: LD_INT 154
14568: PPUSH
14569: LD_INT 1
14571: PPUSH
14572: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
14576: LD_VAR 0 1
14580: PPUSH
14581: LD_INT 36
14583: PPUSH
14584: CALL_OW 308
14588: IFFALSE 14599
// RemoveUnit ( i ) ;
14590: LD_VAR 0 1
14594: PPUSH
14595: CALL_OW 64
// end ;
14599: GO 14518
14601: POP
14602: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14603: LD_INT 22
14605: PUSH
14606: LD_INT 3
14608: PUSH
14609: EMPTY
14610: LIST
14611: LIST
14612: PUSH
14613: LD_INT 2
14615: PUSH
14616: LD_INT 21
14618: PUSH
14619: LD_INT 1
14621: PUSH
14622: EMPTY
14623: LIST
14624: LIST
14625: PUSH
14626: LD_INT 33
14628: PUSH
14629: LD_INT 1
14631: PUSH
14632: EMPTY
14633: LIST
14634: LIST
14635: PUSH
14636: EMPTY
14637: LIST
14638: LIST
14639: LIST
14640: PUSH
14641: EMPTY
14642: LIST
14643: LIST
14644: PPUSH
14645: CALL_OW 69
14649: NOT
14650: IFFALSE 14501
// end ;
14652: PPOPN 3
14654: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
14655: LD_INT 22
14657: PUSH
14658: LD_INT 8
14660: PUSH
14661: EMPTY
14662: LIST
14663: LIST
14664: PUSH
14665: LD_INT 21
14667: PUSH
14668: LD_INT 1
14670: PUSH
14671: EMPTY
14672: LIST
14673: LIST
14674: PUSH
14675: LD_INT 23
14677: PUSH
14678: LD_INT 2
14680: PUSH
14681: EMPTY
14682: LIST
14683: LIST
14684: PUSH
14685: EMPTY
14686: LIST
14687: LIST
14688: LIST
14689: PPUSH
14690: CALL_OW 69
14694: PUSH
14695: LD_INT 18
14697: LESS
14698: PUSH
14699: LD_EXP 50
14703: PPUSH
14704: CALL_OW 301
14708: OR
14709: PUSH
14710: LD_INT 324
14712: PPUSH
14713: CALL_OW 255
14717: PUSH
14718: LD_INT 7
14720: EQUAL
14721: OR
14722: IFFALSE 14735
14724: GO 14726
14726: DISABLE
// legionDestroyed := true ;
14727: LD_ADDR_EXP 3
14731: PUSH
14732: LD_INT 1
14734: ST_TO_ADDR
14735: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 do
14736: LD_INT 22
14738: PUSH
14739: LD_INT 2
14741: PUSH
14742: EMPTY
14743: LIST
14744: LIST
14745: PUSH
14746: LD_INT 21
14748: PUSH
14749: LD_INT 1
14751: PUSH
14752: EMPTY
14753: LIST
14754: LIST
14755: PUSH
14756: LD_INT 23
14758: PUSH
14759: LD_INT 2
14761: PUSH
14762: EMPTY
14763: LIST
14764: LIST
14765: PUSH
14766: EMPTY
14767: LIST
14768: LIST
14769: LIST
14770: PPUSH
14771: CALL_OW 69
14775: PUSH
14776: LD_INT 9
14778: LESS
14779: IFFALSE 14792
14781: GO 14783
14783: DISABLE
// arabianDestroyed := true ;
14784: LD_ADDR_EXP 5
14788: PUSH
14789: LD_INT 1
14791: ST_TO_ADDR
14792: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
14793: LD_EXP 5
14797: IFFALSE 15057
14799: GO 14801
14801: DISABLE
14802: LD_INT 0
14804: PPUSH
14805: PPUSH
// begin MC_Kill ( 1 ) ;
14806: LD_INT 1
14808: PPUSH
14809: CALL 20342 0 1
// SetAttitude ( 2 , 7 , att_friend , true ) ;
14813: LD_INT 2
14815: PPUSH
14816: LD_INT 7
14818: PPUSH
14819: LD_INT 1
14821: PPUSH
14822: LD_INT 1
14824: PPUSH
14825: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14829: LD_ADDR_VAR 0 2
14833: PUSH
14834: LD_INT 22
14836: PUSH
14837: LD_INT 2
14839: PUSH
14840: EMPTY
14841: LIST
14842: LIST
14843: PUSH
14844: LD_INT 21
14846: PUSH
14847: LD_INT 1
14849: PUSH
14850: EMPTY
14851: LIST
14852: LIST
14853: PUSH
14854: EMPTY
14855: LIST
14856: LIST
14857: PPUSH
14858: CALL_OW 69
14862: PUSH
14863: LD_INT 22
14865: PUSH
14866: LD_INT 8
14868: PUSH
14869: EMPTY
14870: LIST
14871: LIST
14872: PUSH
14873: LD_INT 21
14875: PUSH
14876: LD_INT 2
14878: PUSH
14879: EMPTY
14880: LIST
14881: LIST
14882: PUSH
14883: LD_INT 1
14885: PUSH
14886: EMPTY
14887: LIST
14888: PUSH
14889: EMPTY
14890: LIST
14891: LIST
14892: LIST
14893: PPUSH
14894: CALL_OW 69
14898: ADD
14899: ST_TO_ADDR
// if tmp then
14900: LD_VAR 0 2
14904: IFFALSE 15057
// repeat wait ( 0 0$1 ) ;
14906: LD_INT 35
14908: PPUSH
14909: CALL_OW 67
// for i in tmp do
14913: LD_ADDR_VAR 0 1
14917: PUSH
14918: LD_VAR 0 2
14922: PUSH
14923: FOR_IN
14924: IFFALSE 15006
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14926: LD_VAR 0 1
14930: PPUSH
14931: CALL_OW 310
14935: PUSH
14936: LD_VAR 0 1
14940: PPUSH
14941: CALL_OW 310
14945: PPUSH
14946: CALL_OW 247
14950: PUSH
14951: LD_INT 3
14953: EQUAL
14954: AND
14955: IFFALSE 14966
// ComExitBuilding ( i ) ;
14957: LD_VAR 0 1
14961: PPUSH
14962: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
14966: LD_VAR 0 1
14970: PPUSH
14971: LD_INT 254
14973: PPUSH
14974: LD_INT 268
14976: PPUSH
14977: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
14981: LD_VAR 0 1
14985: PPUSH
14986: LD_INT 34
14988: PPUSH
14989: CALL_OW 308
14993: IFFALSE 15004
// RemoveUnit ( i ) ;
14995: LD_VAR 0 1
14999: PPUSH
15000: CALL_OW 64
// end ;
15004: GO 14923
15006: POP
15007: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15008: LD_INT 22
15010: PUSH
15011: LD_INT 2
15013: PUSH
15014: EMPTY
15015: LIST
15016: LIST
15017: PUSH
15018: LD_INT 2
15020: PUSH
15021: LD_INT 21
15023: PUSH
15024: LD_INT 1
15026: PUSH
15027: EMPTY
15028: LIST
15029: LIST
15030: PUSH
15031: LD_INT 33
15033: PUSH
15034: LD_INT 1
15036: PUSH
15037: EMPTY
15038: LIST
15039: LIST
15040: PUSH
15041: EMPTY
15042: LIST
15043: LIST
15044: LIST
15045: PUSH
15046: EMPTY
15047: LIST
15048: LIST
15049: PPUSH
15050: CALL_OW 69
15054: NOT
15055: IFFALSE 14906
// end ;
15057: PPOPN 2
15059: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
15060: LD_EXP 3
15064: IFFALSE 15408
15066: GO 15068
15068: DISABLE
15069: LD_INT 0
15071: PPUSH
15072: PPUSH
// begin MC_Kill ( 3 ) ;
15073: LD_INT 3
15075: PPUSH
15076: CALL 20342 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
15080: LD_INT 8
15082: PPUSH
15083: LD_INT 7
15085: PPUSH
15086: LD_INT 1
15088: PPUSH
15089: LD_INT 1
15091: PPUSH
15092: CALL_OW 80
// DialogueOn ;
15096: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
15100: LD_EXP 49
15104: PPUSH
15105: LD_STRING D15-Szulc-1
15107: PPUSH
15108: CALL_OW 94
// DialogueOff ;
15112: CALL_OW 7
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
15116: LD_ADDR_VAR 0 1
15120: PUSH
15121: LD_INT 22
15123: PUSH
15124: LD_INT 8
15126: PUSH
15127: EMPTY
15128: LIST
15129: LIST
15130: PUSH
15131: LD_INT 21
15133: PUSH
15134: LD_INT 3
15136: PUSH
15137: EMPTY
15138: LIST
15139: LIST
15140: PUSH
15141: LD_INT 23
15143: PUSH
15144: LD_INT 3
15146: PUSH
15147: EMPTY
15148: LIST
15149: LIST
15150: PUSH
15151: EMPTY
15152: LIST
15153: LIST
15154: LIST
15155: PPUSH
15156: CALL_OW 69
15160: PUSH
15161: FOR_IN
15162: IFFALSE 15178
// SetLives ( i , 3 ) ;
15164: LD_VAR 0 1
15168: PPUSH
15169: LD_INT 3
15171: PPUSH
15172: CALL_OW 234
15176: GO 15161
15178: POP
15179: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15180: LD_ADDR_VAR 0 2
15184: PUSH
15185: LD_INT 22
15187: PUSH
15188: LD_INT 8
15190: PUSH
15191: EMPTY
15192: LIST
15193: LIST
15194: PUSH
15195: LD_INT 21
15197: PUSH
15198: LD_INT 1
15200: PUSH
15201: EMPTY
15202: LIST
15203: LIST
15204: PUSH
15205: EMPTY
15206: LIST
15207: LIST
15208: PPUSH
15209: CALL_OW 69
15213: PUSH
15214: LD_INT 22
15216: PUSH
15217: LD_INT 8
15219: PUSH
15220: EMPTY
15221: LIST
15222: LIST
15223: PUSH
15224: LD_INT 21
15226: PUSH
15227: LD_INT 2
15229: PUSH
15230: EMPTY
15231: LIST
15232: LIST
15233: PUSH
15234: LD_INT 1
15236: PUSH
15237: EMPTY
15238: LIST
15239: PUSH
15240: EMPTY
15241: LIST
15242: LIST
15243: LIST
15244: PPUSH
15245: CALL_OW 69
15249: ADD
15250: ST_TO_ADDR
// if tmp then
15251: LD_VAR 0 2
15255: IFFALSE 15408
// repeat wait ( 0 0$1 ) ;
15257: LD_INT 35
15259: PPUSH
15260: CALL_OW 67
// for i in tmp do
15264: LD_ADDR_VAR 0 1
15268: PUSH
15269: LD_VAR 0 2
15273: PUSH
15274: FOR_IN
15275: IFFALSE 15357
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15277: LD_VAR 0 1
15281: PPUSH
15282: CALL_OW 310
15286: PUSH
15287: LD_VAR 0 1
15291: PPUSH
15292: CALL_OW 310
15296: PPUSH
15297: CALL_OW 247
15301: PUSH
15302: LD_INT 3
15304: EQUAL
15305: AND
15306: IFFALSE 15317
// ComExitBuilding ( i ) ;
15308: LD_VAR 0 1
15312: PPUSH
15313: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
15317: LD_VAR 0 1
15321: PPUSH
15322: LD_INT 10
15324: PPUSH
15325: LD_INT 1
15327: PPUSH
15328: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
15332: LD_VAR 0 1
15336: PPUSH
15337: LD_INT 32
15339: PPUSH
15340: CALL_OW 308
15344: IFFALSE 15355
// RemoveUnit ( i ) ;
15346: LD_VAR 0 1
15350: PPUSH
15351: CALL_OW 64
// end ;
15355: GO 15274
15357: POP
15358: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15359: LD_INT 22
15361: PUSH
15362: LD_INT 8
15364: PUSH
15365: EMPTY
15366: LIST
15367: LIST
15368: PUSH
15369: LD_INT 2
15371: PUSH
15372: LD_INT 21
15374: PUSH
15375: LD_INT 1
15377: PUSH
15378: EMPTY
15379: LIST
15380: LIST
15381: PUSH
15382: LD_INT 33
15384: PUSH
15385: LD_INT 1
15387: PUSH
15388: EMPTY
15389: LIST
15390: LIST
15391: PUSH
15392: EMPTY
15393: LIST
15394: LIST
15395: LIST
15396: PUSH
15397: EMPTY
15398: LIST
15399: LIST
15400: PPUSH
15401: CALL_OW 69
15405: NOT
15406: IFFALSE 15257
// end ;
15408: PPOPN 2
15410: END
// every 0 0$3 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed do var med1 , med2 ;
15411: LD_EXP 4
15415: PUSH
15416: LD_EXP 2
15420: AND
15421: PUSH
15422: LD_EXP 3
15426: AND
15427: PUSH
15428: LD_EXP 5
15432: AND
15433: IFFALSE 16776
15435: GO 15437
15437: DISABLE
15438: LD_INT 0
15440: PPUSH
15441: PPUSH
// begin music_class := 5 ;
15442: LD_ADDR_OWVAR 72
15446: PUSH
15447: LD_INT 5
15449: ST_TO_ADDR
// music_nat := 5 ;
15450: LD_ADDR_OWVAR 71
15454: PUSH
15455: LD_INT 5
15457: ST_TO_ADDR
// CenterNowOnUnits ( JMM ) ;
15458: LD_EXP 12
15462: PPUSH
15463: CALL_OW 87
// InGameOn ;
15467: CALL_OW 8
// DialogueOn ;
15471: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
15475: LD_EXP 12
15479: PPUSH
15480: LD_STRING DEnd-JMM-JMM-1
15482: PPUSH
15483: CALL_OW 88
// if Joan then
15487: LD_EXP 27
15491: IFFALSE 15507
// Say ( Joan , DEnd-JMM-Joan-1 ) else
15493: LD_EXP 27
15497: PPUSH
15498: LD_STRING DEnd-JMM-Joan-1
15500: PPUSH
15501: CALL_OW 88
15505: GO 15551
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
15507: LD_EXP 14
15511: PUSH
15512: LD_EXP 14
15516: PPUSH
15517: CALL_OW 255
15521: PUSH
15522: LD_INT 7
15524: EQUAL
15525: AND
15526: PUSH
15527: LD_EXP 14
15531: PPUSH
15532: CALL_OW 305
15536: AND
15537: IFFALSE 15551
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
15539: LD_EXP 14
15543: PPUSH
15544: LD_STRING DEnd-JMM-Lisa-1
15546: PPUSH
15547: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
15551: LD_EXP 24
15555: PUSH
15556: LD_EXP 24
15560: PPUSH
15561: CALL_OW 305
15565: AND
15566: IFFALSE 15580
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
15568: LD_EXP 24
15572: PPUSH
15573: LD_STRING DEnd-JMM-Frank-1
15575: PPUSH
15576: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
15580: LD_EXP 17
15584: PUSH
15585: LD_EXP 17
15589: PPUSH
15590: CALL_OW 255
15594: PUSH
15595: LD_INT 7
15597: EQUAL
15598: AND
15599: PUSH
15600: LD_EXP 17
15604: PPUSH
15605: CALL_OW 305
15609: AND
15610: IFFALSE 15624
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
15612: LD_EXP 17
15616: PPUSH
15617: LD_STRING DEnd-JMM-Cyrus-1
15619: PPUSH
15620: CALL_OW 88
// if Burlak then
15624: LD_EXP 44
15628: IFFALSE 15642
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
15630: LD_EXP 44
15634: PPUSH
15635: LD_STRING DEnd-JMM-Bur-1
15637: PPUSH
15638: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
15642: LD_EXP 27
15646: PUSH
15647: LD_EXP 14
15651: AND
15652: PUSH
15653: LD_EXP 14
15657: PPUSH
15658: CALL_OW 255
15662: PUSH
15663: LD_INT 7
15665: EQUAL
15666: AND
15667: PUSH
15668: LD_EXP 14
15672: PPUSH
15673: CALL_OW 305
15677: AND
15678: IFFALSE 15692
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
15680: LD_EXP 14
15684: PPUSH
15685: LD_STRING DEnd-Burlak-Lisa-1
15687: PPUSH
15688: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
15692: LD_EXP 45
15696: PUSH
15697: LD_EXP 45
15701: PPUSH
15702: CALL_OW 305
15706: AND
15707: IFFALSE 15721
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
15709: LD_EXP 45
15713: PPUSH
15714: LD_STRING DEnd-JMM-Bel-1
15716: PPUSH
15717: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
15721: LD_EXP 46
15725: PUSH
15726: LD_EXP 46
15730: PPUSH
15731: CALL_OW 305
15735: AND
15736: IFFALSE 15750
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
15738: LD_EXP 46
15742: PPUSH
15743: LD_STRING DEnd-JMM-Gny-1
15745: PPUSH
15746: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
15750: LD_EXP 22
15754: PUSH
15755: LD_EXP 22
15759: PPUSH
15760: CALL_OW 255
15764: PUSH
15765: LD_INT 7
15767: EQUAL
15768: AND
15769: PUSH
15770: LD_EXP 22
15774: PPUSH
15775: CALL_OW 305
15779: AND
15780: IFFALSE 15794
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
15782: LD_EXP 22
15786: PPUSH
15787: LD_STRING DEnd-JMM-Corn-1
15789: PPUSH
15790: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
15794: LD_EXP 15
15798: PUSH
15799: LD_EXP 15
15803: PPUSH
15804: CALL_OW 255
15808: PUSH
15809: LD_INT 7
15811: EQUAL
15812: AND
15813: PUSH
15814: LD_EXP 15
15818: PPUSH
15819: CALL_OW 305
15823: AND
15824: IFFALSE 15838
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
15826: LD_EXP 15
15830: PPUSH
15831: LD_STRING DEnd-JMM-Don-1
15833: PPUSH
15834: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
15838: LD_EXP 16
15842: PUSH
15843: LD_EXP 16
15847: PPUSH
15848: CALL_OW 255
15852: PUSH
15853: LD_INT 7
15855: EQUAL
15856: AND
15857: PUSH
15858: LD_EXP 16
15862: PPUSH
15863: CALL_OW 305
15867: AND
15868: IFFALSE 15882
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
15870: LD_EXP 16
15874: PPUSH
15875: LD_STRING DEnd-JMM-Bobby-1
15877: PPUSH
15878: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
15882: LD_EXP 18
15886: PUSH
15887: LD_EXP 18
15891: PPUSH
15892: CALL_OW 255
15896: PUSH
15897: LD_INT 7
15899: EQUAL
15900: AND
15901: PUSH
15902: LD_EXP 18
15906: PPUSH
15907: CALL_OW 305
15911: AND
15912: IFFALSE 15926
// Say ( Denis , DEnd-JMM-Den-1 ) ;
15914: LD_EXP 18
15918: PPUSH
15919: LD_STRING DEnd-JMM-Den-1
15921: PPUSH
15922: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
15926: LD_EXP 20
15930: PUSH
15931: LD_EXP 20
15935: PPUSH
15936: CALL_OW 255
15940: PUSH
15941: LD_INT 7
15943: EQUAL
15944: AND
15945: PUSH
15946: LD_EXP 20
15950: PPUSH
15951: CALL_OW 305
15955: AND
15956: IFFALSE 15970
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
15958: LD_EXP 20
15962: PPUSH
15963: LD_STRING DEnd-JMM-Glad-1
15965: PPUSH
15966: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
15970: LD_EXP 25
15974: PUSH
15975: LD_EXP 25
15979: PPUSH
15980: CALL_OW 255
15984: PUSH
15985: LD_INT 7
15987: EQUAL
15988: AND
15989: PUSH
15990: LD_EXP 25
15994: PPUSH
15995: CALL_OW 305
15999: AND
16000: IFFALSE 16014
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
16002: LD_EXP 25
16006: PPUSH
16007: LD_STRING DEnd-JMM-Yam-1
16009: PPUSH
16010: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
16014: LD_EXP 19
16018: PUSH
16019: LD_EXP 19
16023: PPUSH
16024: CALL_OW 255
16028: PUSH
16029: LD_INT 7
16031: EQUAL
16032: AND
16033: PUSH
16034: LD_EXP 19
16038: PPUSH
16039: CALL_OW 305
16043: AND
16044: IFFALSE 16058
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
16046: LD_EXP 19
16050: PPUSH
16051: LD_STRING DEnd-JMM-Brown-1
16053: PPUSH
16054: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
16058: LD_EXP 29
16062: PUSH
16063: LD_EXP 29
16067: PPUSH
16068: CALL_OW 255
16072: PUSH
16073: LD_INT 7
16075: EQUAL
16076: AND
16077: PUSH
16078: LD_EXP 29
16082: PPUSH
16083: CALL_OW 305
16087: AND
16088: IFFALSE 16102
// Say ( Connie , DEnd-JMM-Con-1 ) ;
16090: LD_EXP 29
16094: PPUSH
16095: LD_STRING DEnd-JMM-Con-1
16097: PPUSH
16098: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
16102: LD_EXP 23
16106: PUSH
16107: LD_EXP 23
16111: PPUSH
16112: CALL_OW 255
16116: PUSH
16117: LD_INT 7
16119: EQUAL
16120: AND
16121: PUSH
16122: LD_EXP 23
16126: PPUSH
16127: CALL_OW 305
16131: AND
16132: IFFALSE 16146
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
16134: LD_EXP 23
16138: PPUSH
16139: LD_STRING DEnd-JMM-Gary-1
16141: PPUSH
16142: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
16146: LD_EXP 26
16150: PUSH
16151: LD_EXP 13
16155: AND
16156: PUSH
16157: LD_EXP 26
16161: PPUSH
16162: CALL_OW 305
16166: AND
16167: IFFALSE 16181
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
16169: LD_EXP 26
16173: PPUSH
16174: LD_STRING DEnd-JMM-Sim-1
16176: PPUSH
16177: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
16181: LD_EXP 21
16185: PUSH
16186: LD_EXP 21
16190: PPUSH
16191: CALL_OW 255
16195: PUSH
16196: LD_INT 7
16198: EQUAL
16199: AND
16200: PUSH
16201: LD_EXP 21
16205: PPUSH
16206: CALL_OW 305
16210: AND
16211: IFFALSE 16225
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
16213: LD_EXP 21
16217: PPUSH
16218: LD_STRING DEnd-JMM-VanH-1
16220: PPUSH
16221: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
16225: LD_EXP 34
16229: PUSH
16230: LD_EXP 34
16234: PPUSH
16235: CALL_OW 305
16239: AND
16240: IFFALSE 16254
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
16242: LD_EXP 34
16246: PPUSH
16247: LD_STRING DEnd-JMM-Dol-1
16249: PPUSH
16250: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
16254: LD_EXP 38
16258: PUSH
16259: LD_EXP 38
16263: PPUSH
16264: CALL_OW 305
16268: AND
16269: IFFALSE 16283
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
16271: LD_EXP 38
16275: PPUSH
16276: LD_STRING DEnd-JMM-Kap-1
16278: PPUSH
16279: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
16283: LD_EXP 41
16287: PUSH
16288: LD_EXP 41
16292: PPUSH
16293: CALL_OW 305
16297: AND
16298: IFFALSE 16312
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
16300: LD_EXP 41
16304: PPUSH
16305: LD_STRING DEnd-JMM-Kov-1
16307: PPUSH
16308: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
16312: LD_EXP 36
16316: PUSH
16317: LD_EXP 36
16321: PPUSH
16322: CALL_OW 305
16326: AND
16327: IFFALSE 16341
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
16329: LD_EXP 36
16333: PPUSH
16334: LD_STRING DEnd-JMM-Sch-1
16336: PPUSH
16337: CALL_OW 88
// if Titov and IsPlaced ( Titov ) then
16341: LD_EXP 32
16345: PUSH
16346: LD_EXP 32
16350: PPUSH
16351: CALL_OW 305
16355: AND
16356: IFFALSE 16370
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
16358: LD_EXP 32
16362: PPUSH
16363: LD_STRING DEnd-JMM-Tit-1
16365: PPUSH
16366: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
16370: LD_EXP 37
16374: PUSH
16375: LD_EXP 37
16379: PPUSH
16380: CALL_OW 305
16384: AND
16385: IFFALSE 16399
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
16387: LD_EXP 37
16391: PPUSH
16392: LD_STRING DEnd-JMM-Obl-1
16394: PPUSH
16395: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
16399: LD_EXP 39
16403: PUSH
16404: LD_EXP 39
16408: PPUSH
16409: CALL_OW 305
16413: AND
16414: IFFALSE 16428
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
16416: LD_EXP 39
16420: PPUSH
16421: LD_STRING DEnd-JMM-Lip-1
16423: PPUSH
16424: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and Burlak then
16428: LD_EXP 33
16432: PUSH
16433: LD_EXP 33
16437: PPUSH
16438: CALL_OW 305
16442: AND
16443: PUSH
16444: LD_EXP 44
16448: AND
16449: IFFALSE 16463
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
16451: LD_EXP 33
16455: PPUSH
16456: LD_STRING DEnd-Burlak-Fad-1
16458: PPUSH
16459: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
16463: LD_EXP 40
16467: PUSH
16468: LD_EXP 40
16472: PPUSH
16473: CALL_OW 305
16477: AND
16478: IFFALSE 16492
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
16480: LD_EXP 40
16484: PPUSH
16485: LD_STRING DEnd-Burlak-Ptr-1
16487: PPUSH
16488: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
16492: LD_EXP 42
16496: PUSH
16497: LD_EXP 42
16501: PPUSH
16502: CALL_OW 305
16506: AND
16507: IFFALSE 16521
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
16509: LD_EXP 42
16513: PPUSH
16514: LD_STRING DEnd-Burlak-Kuz-1
16516: PPUSH
16517: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and Burlak then
16521: LD_EXP 31
16525: PUSH
16526: LD_EXP 31
16530: PPUSH
16531: CALL_OW 305
16535: AND
16536: PUSH
16537: LD_EXP 44
16541: AND
16542: IFFALSE 16556
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
16544: LD_EXP 31
16548: PPUSH
16549: LD_STRING DEnd-Burlak-Kir-1
16551: PPUSH
16552: CALL_OW 88
// if Burlak then
16556: LD_EXP 44
16560: IFFALSE 16574
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
16562: LD_EXP 12
16566: PPUSH
16567: LD_STRING DEnd-Burlak-JMM-1
16569: PPUSH
16570: CALL_OW 88
// dwait ( 0 0$2 ) ;
16574: LD_INT 70
16576: PPUSH
16577: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
16581: LD_EXP 49
16585: PPUSH
16586: LD_STRING DEnd-Szulc
16588: PPUSH
16589: CALL_OW 94
// dwait ( 0 0$1 ) ;
16593: LD_INT 35
16595: PPUSH
16596: CALL_OW 68
// if IsLive ( Burlak ) then
16600: LD_EXP 44
16604: PPUSH
16605: CALL_OW 300
16609: IFFALSE 16621
// med1 := 1 else
16611: LD_ADDR_VAR 0 1
16615: PUSH
16616: LD_INT 1
16618: ST_TO_ADDR
16619: GO 16630
// med1 := - 1 ;
16621: LD_ADDR_VAR 0 1
16625: PUSH
16626: LD_INT 1
16628: NEG
16629: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
16630: LD_EXP 9
16634: PUSH
16635: LD_EXP 10
16639: AND
16640: PUSH
16641: LD_EXP 11
16645: AND
16646: IFFALSE 16658
// med2 := 1 else
16648: LD_ADDR_VAR 0 2
16652: PUSH
16653: LD_INT 1
16655: ST_TO_ADDR
16656: GO 16667
// med2 := - 1 ;
16658: LD_ADDR_VAR 0 2
16662: PUSH
16663: LD_INT 1
16665: NEG
16666: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
16667: LD_STRING Hero
16669: PPUSH
16670: LD_INT 1
16672: PPUSH
16673: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
16677: LD_STRING Artefact
16679: PPUSH
16680: LD_VAR 0 2
16684: PPUSH
16685: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
16689: LD_STRING ReconcileBurlak
16691: PPUSH
16692: LD_VAR 0 1
16696: PPUSH
16697: CALL_OW 101
// if Difficulty = 3 and med1 = 1 and med2 = 1 then
16701: LD_OWVAR 67
16705: PUSH
16706: LD_INT 3
16708: EQUAL
16709: PUSH
16710: LD_VAR 0 1
16714: PUSH
16715: LD_INT 1
16717: EQUAL
16718: AND
16719: PUSH
16720: LD_VAR 0 2
16724: PUSH
16725: LD_INT 1
16727: EQUAL
16728: AND
16729: IFFALSE 16741
// SetAchievementEX ( ACH_AMER , 19 ) ;
16731: LD_STRING ACH_AMER
16733: PPUSH
16734: LD_INT 19
16736: PPUSH
16737: CALL_OW 564
// GiveMedals ( MAIN ) ;
16741: LD_STRING MAIN
16743: PPUSH
16744: CALL_OW 102
// InGameOff ;
16748: CALL_OW 9
// DialogueOff ;
16752: CALL_OW 7
// music_nat := 1 ;
16756: LD_ADDR_OWVAR 71
16760: PUSH
16761: LD_INT 1
16763: ST_TO_ADDR
// music_class := 4 ;
16764: LD_ADDR_OWVAR 72
16768: PUSH
16769: LD_INT 4
16771: ST_TO_ADDR
// YouWin ;
16772: CALL_OW 103
// end ; end_of_file
16776: PPOPN 2
16778: END
// export function InitNature ; begin
16779: LD_INT 0
16781: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
16782: LD_INT 3
16784: PPUSH
16785: LD_INT 3
16787: PPUSH
16788: LD_INT 2
16790: PPUSH
16791: LD_INT 1
16793: PPUSH
16794: LD_INT 1
16796: PPUSH
16797: LD_INT 0
16799: PPUSH
16800: LD_INT 0
16802: PPUSH
16803: LD_INT 17
16805: PPUSH
16806: LD_INT 0
16808: PPUSH
16809: CALL 85179 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
16813: LD_INT 2
16815: PPUSH
16816: LD_INT 1
16818: PPUSH
16819: LD_INT 1
16821: PPUSH
16822: LD_INT 1
16824: PPUSH
16825: LD_INT 1
16827: PPUSH
16828: LD_INT 0
16830: PPUSH
16831: LD_INT 0
16833: PPUSH
16834: LD_INT 18
16836: PPUSH
16837: LD_INT 0
16839: PPUSH
16840: CALL 85179 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
16844: LD_INT 4
16846: PPUSH
16847: LD_INT 1
16849: PPUSH
16850: LD_INT 2
16852: PPUSH
16853: LD_INT 4
16855: PPUSH
16856: LD_INT 2
16858: PPUSH
16859: LD_INT 1
16861: PPUSH
16862: LD_INT 0
16864: PPUSH
16865: LD_INT 19
16867: PPUSH
16868: LD_INT 0
16870: PPUSH
16871: CALL 85179 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
16875: LD_INT 0
16877: PPUSH
16878: LD_INT 0
16880: PPUSH
16881: LD_INT 0
16883: PPUSH
16884: LD_INT 0
16886: PPUSH
16887: LD_INT 0
16889: PPUSH
16890: LD_INT 0
16892: PPUSH
16893: LD_INT 9
16895: PPUSH
16896: LD_INT 0
16898: PPUSH
16899: LD_INT 20
16901: PPUSH
16902: CALL 85179 0 9
// end ; end_of_file
16906: LD_VAR 0 1
16910: RET
// every 0 0$30 do var time ;
16911: GO 16913
16913: DISABLE
16914: LD_INT 0
16916: PPUSH
// begin time := 0 0$50 ;
16917: LD_ADDR_VAR 0 1
16921: PUSH
16922: LD_INT 1750
16924: ST_TO_ADDR
// repeat wait ( time ) ;
16925: LD_VAR 0 1
16929: PPUSH
16930: CALL_OW 67
// if Prob ( 50 ) then
16934: LD_INT 50
16936: PPUSH
16937: CALL_OW 13
16941: IFFALSE 16970
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
16943: LD_INT 1
16945: PPUSH
16946: LD_INT 5
16948: PPUSH
16949: CALL_OW 12
16953: PPUSH
16954: LD_INT 106
16956: PPUSH
16957: LD_INT 89
16959: PPUSH
16960: LD_INT 45
16962: PPUSH
16963: LD_INT 1
16965: PPUSH
16966: CALL_OW 56
// time := time + 0 0$3 ;
16970: LD_ADDR_VAR 0 1
16974: PUSH
16975: LD_VAR 0 1
16979: PUSH
16980: LD_INT 105
16982: PLUS
16983: ST_TO_ADDR
// if Prob ( 30 ) then
16984: LD_INT 30
16986: PPUSH
16987: CALL_OW 13
16991: IFFALSE 17037
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
16993: LD_INT 525
16995: PPUSH
16996: LD_INT 735
16998: PPUSH
16999: CALL_OW 12
17003: PPUSH
17004: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
17008: LD_INT 1
17010: PPUSH
17011: LD_INT 5
17013: PPUSH
17014: CALL_OW 12
17018: PPUSH
17019: LD_INT 21
17021: PPUSH
17022: LD_INT 26
17024: PPUSH
17025: LD_INT 12
17027: PPUSH
17028: LD_INT 1
17030: PPUSH
17031: CALL_OW 56
// end else
17035: GO 17073
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
17037: LD_INT 700
17039: PPUSH
17040: LD_INT 1225
17042: PPUSH
17043: CALL_OW 12
17047: PPUSH
17048: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
17052: LD_INT 1
17054: PPUSH
17055: LD_INT 5
17057: PPUSH
17058: CALL_OW 12
17062: PPUSH
17063: LD_INT 14
17065: PPUSH
17066: LD_INT 1
17068: PPUSH
17069: CALL_OW 55
// end ; if Prob ( 50 ) then
17073: LD_INT 50
17075: PPUSH
17076: CALL_OW 13
17080: IFFALSE 17126
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
17082: LD_INT 700
17084: PPUSH
17085: LD_INT 1050
17087: PPUSH
17088: CALL_OW 12
17092: PPUSH
17093: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
17097: LD_INT 1
17099: PPUSH
17100: LD_INT 5
17102: PPUSH
17103: CALL_OW 12
17107: PPUSH
17108: LD_INT 181
17110: PPUSH
17111: LD_INT 218
17113: PPUSH
17114: LD_INT 16
17116: PPUSH
17117: LD_INT 1
17119: PPUSH
17120: CALL_OW 56
// end else
17124: GO 17198
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
17126: LD_INT 350
17128: PPUSH
17129: LD_INT 525
17131: PPUSH
17132: CALL_OW 12
17136: PPUSH
17137: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
17141: LD_INT 1
17143: PPUSH
17144: LD_INT 5
17146: PPUSH
17147: CALL_OW 12
17151: PPUSH
17152: LD_INT 13
17154: PPUSH
17155: LD_INT 1
17157: PPUSH
17158: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17162: LD_INT 350
17164: PPUSH
17165: LD_INT 700
17167: PPUSH
17168: CALL_OW 12
17172: PPUSH
17173: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
17177: LD_INT 1
17179: PPUSH
17180: LD_INT 5
17182: PPUSH
17183: CALL_OW 12
17187: PPUSH
17188: LD_INT 33
17190: PPUSH
17191: LD_INT 1
17193: PPUSH
17194: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 ] [ Difficulty ] ) then
17198: LD_INT 65
17200: PUSH
17201: LD_INT 62
17203: PUSH
17204: LD_INT 55
17206: PUSH
17207: EMPTY
17208: LIST
17209: LIST
17210: LIST
17211: PUSH
17212: LD_OWVAR 67
17216: ARRAY
17217: PPUSH
17218: CALL_OW 13
17222: IFFALSE 17268
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
17224: LD_INT 525
17226: PPUSH
17227: LD_INT 875
17229: PPUSH
17230: CALL_OW 12
17234: PPUSH
17235: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17239: LD_INT 1
17241: PPUSH
17242: LD_INT 5
17244: PPUSH
17245: CALL_OW 12
17249: PPUSH
17250: LD_INT 294
17252: PPUSH
17253: LD_INT 211
17255: PPUSH
17256: LD_INT 30
17258: PPUSH
17259: LD_INT 1
17261: PPUSH
17262: CALL_OW 56
// end else
17266: GO 17310
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
17268: LD_INT 420
17270: PPUSH
17271: LD_INT 770
17273: PPUSH
17274: CALL_OW 12
17278: PPUSH
17279: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17283: LD_INT 1
17285: PPUSH
17286: LD_INT 5
17288: PPUSH
17289: CALL_OW 12
17293: PPUSH
17294: LD_INT 294
17296: PPUSH
17297: LD_INT 211
17299: PPUSH
17300: LD_INT 30
17302: PPUSH
17303: LD_INT 1
17305: PPUSH
17306: CALL_OW 56
// end ; if time > 2 2$20 then
17310: LD_VAR 0 1
17314: PUSH
17315: LD_INT 4900
17317: GREATER
17318: IFFALSE 17328
// time := 0 0$50 ;
17320: LD_ADDR_VAR 0 1
17324: PUSH
17325: LD_INT 1750
17327: ST_TO_ADDR
// until false ;
17328: LD_INT 0
17330: IFFALSE 16925
// end ;
17332: PPOPN 1
17334: END
// every 0 0$45 trigger tick < 10 10$00 do
17335: LD_OWVAR 1
17339: PUSH
17340: LD_INT 21000
17342: LESS
17343: IFFALSE 17391
17345: GO 17347
17347: DISABLE
// begin enable ;
17348: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17349: LD_INT 350
17351: PPUSH
17352: LD_INT 700
17354: PPUSH
17355: CALL_OW 12
17359: PPUSH
17360: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
17364: LD_INT 3
17366: PPUSH
17367: LD_INT 5
17369: PPUSH
17370: CALL_OW 12
17374: PPUSH
17375: LD_INT 181
17377: PPUSH
17378: LD_INT 13
17380: PPUSH
17381: LD_INT 20
17383: PPUSH
17384: LD_INT 1
17386: PPUSH
17387: CALL_OW 56
// end ; end_of_file
17391: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
17392: LD_INT 0
17394: PPUSH
// SetArtifactRes ( 7 , true ) ;
17395: LD_INT 7
17397: PPUSH
17398: LD_INT 1
17400: PPUSH
17401: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
17405: LD_ADDR_EXP 57
17409: PUSH
17410: EMPTY
17411: PUSH
17412: EMPTY
17413: PUSH
17414: EMPTY
17415: PUSH
17416: EMPTY
17417: LIST
17418: LIST
17419: LIST
17420: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
17421: LD_ADDR_EXP 58
17425: PUSH
17426: LD_INT 1050
17428: PUSH
17429: LD_OWVAR 67
17433: MUL
17434: PUSH
17435: LD_INT 2800
17437: PUSH
17438: LD_OWVAR 67
17442: MUL
17443: PUSH
17444: LD_INT 1
17446: NEG
17447: PUSH
17448: EMPTY
17449: LIST
17450: LIST
17451: LIST
17452: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
17453: LD_ADDR_EXP 59
17457: PUSH
17458: LD_INT 10
17460: PUSH
17461: LD_INT 35
17463: PUSH
17464: LD_INT 100
17466: PUSH
17467: EMPTY
17468: LIST
17469: LIST
17470: LIST
17471: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
17472: LD_ADDR_EXP 60
17476: PUSH
17477: LD_INT 0
17479: PUSH
17480: LD_INT 0
17482: PUSH
17483: LD_INT 0
17485: PUSH
17486: EMPTY
17487: LIST
17488: LIST
17489: LIST
17490: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
17491: LD_ADDR_EXP 62
17495: PUSH
17496: LD_INT 300
17498: PUSH
17499: LD_INT 500
17501: PUSH
17502: LD_INT 800
17504: PUSH
17505: EMPTY
17506: LIST
17507: LIST
17508: LIST
17509: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
17510: LD_ADDR_EXP 63
17514: PUSH
17515: LD_INT 0
17517: PUSH
17518: LD_INT 0
17520: PUSH
17521: LD_INT 0
17523: PUSH
17524: EMPTY
17525: LIST
17526: LIST
17527: LIST
17528: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
17529: LD_ADDR_EXP 64
17533: PUSH
17534: LD_INT 0
17536: PUSH
17537: LD_INT 0
17539: PUSH
17540: LD_INT 0
17542: PUSH
17543: EMPTY
17544: LIST
17545: LIST
17546: LIST
17547: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
17548: LD_ADDR_EXP 61
17552: PUSH
17553: LD_INT 0
17555: PUSH
17556: LD_INT 0
17558: PUSH
17559: LD_INT 0
17561: PUSH
17562: EMPTY
17563: LIST
17564: LIST
17565: LIST
17566: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
17567: LD_ADDR_EXP 65
17571: PUSH
17572: LD_INT 4
17574: PUSH
17575: LD_INT 3
17577: PUSH
17578: LD_INT 1
17580: PUSH
17581: EMPTY
17582: LIST
17583: LIST
17584: LIST
17585: PUSH
17586: LD_INT 5
17588: PUSH
17589: LD_INT 4
17591: PUSH
17592: LD_INT 2
17594: PUSH
17595: EMPTY
17596: LIST
17597: LIST
17598: LIST
17599: PUSH
17600: LD_INT 6
17602: PUSH
17603: LD_INT 3
17605: PUSH
17606: LD_INT 3
17608: PUSH
17609: EMPTY
17610: LIST
17611: LIST
17612: LIST
17613: PUSH
17614: EMPTY
17615: LIST
17616: LIST
17617: LIST
17618: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
17619: LD_ADDR_EXP 66
17623: PUSH
17624: LD_INT 0
17626: PUSH
17627: LD_INT 0
17629: PUSH
17630: LD_INT 0
17632: PUSH
17633: EMPTY
17634: LIST
17635: LIST
17636: LIST
17637: ST_TO_ADDR
// end ;
17638: LD_VAR 0 1
17642: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
17643: LD_INT 24
17645: PPUSH
17646: LD_INT 7
17648: PPUSH
17649: CALL_OW 321
17653: PUSH
17654: LD_INT 2
17656: EQUAL
17657: IFFALSE 18583
17659: GO 17661
17661: DISABLE
17662: LD_INT 0
17664: PPUSH
17665: PPUSH
17666: PPUSH
17667: PPUSH
17668: PPUSH
// begin enable ;
17669: ENABLE
// for i = 1 to 3 do
17670: LD_ADDR_VAR 0 1
17674: PUSH
17675: DOUBLE
17676: LD_INT 1
17678: DEC
17679: ST_TO_ADDR
17680: LD_INT 3
17682: PUSH
17683: FOR_TO
17684: IFFALSE 18581
// begin pos := FindArtifact ( i + 2 ) ;
17686: LD_ADDR_VAR 0 2
17690: PUSH
17691: LD_VAR 0 1
17695: PUSH
17696: LD_INT 2
17698: PLUS
17699: PPUSH
17700: CALL_OW 469
17704: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
17705: LD_ADDR_EXP 57
17709: PUSH
17710: LD_EXP 57
17714: PPUSH
17715: LD_VAR 0 1
17719: PPUSH
17720: LD_VAR 0 2
17724: PPUSH
17725: CALL_OW 1
17729: ST_TO_ADDR
// if pos then
17730: LD_VAR 0 2
17734: IFFALSE 18442
// begin case i of 1 :
17736: LD_VAR 0 1
17740: PUSH
17741: LD_INT 1
17743: DOUBLE
17744: EQUAL
17745: IFTRUE 17749
17747: GO 17826
17749: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
17750: LD_ADDR_VAR 0 4
17754: PUSH
17755: LD_INT 22
17757: PUSH
17758: LD_INT 7
17760: PUSH
17761: EMPTY
17762: LIST
17763: LIST
17764: PUSH
17765: LD_INT 23
17767: PUSH
17768: LD_INT 1
17770: PUSH
17771: EMPTY
17772: LIST
17773: LIST
17774: PUSH
17775: LD_INT 2
17777: PUSH
17778: LD_INT 30
17780: PUSH
17781: LD_INT 8
17783: PUSH
17784: EMPTY
17785: LIST
17786: LIST
17787: PUSH
17788: LD_INT 30
17790: PUSH
17791: LD_INT 7
17793: PUSH
17794: EMPTY
17795: LIST
17796: LIST
17797: PUSH
17798: LD_INT 30
17800: PUSH
17801: LD_INT 11
17803: PUSH
17804: EMPTY
17805: LIST
17806: LIST
17807: PUSH
17808: EMPTY
17809: LIST
17810: LIST
17811: LIST
17812: LIST
17813: PUSH
17814: EMPTY
17815: LIST
17816: LIST
17817: LIST
17818: PPUSH
17819: CALL_OW 69
17823: ST_TO_ADDR
17824: GO 17934
17826: LD_INT 2
17828: DOUBLE
17829: EQUAL
17830: IFTRUE 17834
17832: GO 17911
17834: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
17835: LD_ADDR_VAR 0 4
17839: PUSH
17840: LD_INT 22
17842: PUSH
17843: LD_INT 7
17845: PUSH
17846: EMPTY
17847: LIST
17848: LIST
17849: PUSH
17850: LD_INT 23
17852: PUSH
17853: LD_INT 3
17855: PUSH
17856: EMPTY
17857: LIST
17858: LIST
17859: PUSH
17860: LD_INT 2
17862: PUSH
17863: LD_INT 30
17865: PUSH
17866: LD_INT 8
17868: PUSH
17869: EMPTY
17870: LIST
17871: LIST
17872: PUSH
17873: LD_INT 30
17875: PUSH
17876: LD_INT 7
17878: PUSH
17879: EMPTY
17880: LIST
17881: LIST
17882: PUSH
17883: LD_INT 30
17885: PUSH
17886: LD_INT 11
17888: PUSH
17889: EMPTY
17890: LIST
17891: LIST
17892: PUSH
17893: EMPTY
17894: LIST
17895: LIST
17896: LIST
17897: LIST
17898: PUSH
17899: EMPTY
17900: LIST
17901: LIST
17902: LIST
17903: PPUSH
17904: CALL_OW 69
17908: ST_TO_ADDR
17909: GO 17934
17911: LD_INT 3
17913: DOUBLE
17914: EQUAL
17915: IFTRUE 17919
17917: GO 17933
17919: POP
// labs := [ alien ] ; end ;
17920: LD_ADDR_VAR 0 4
17924: PUSH
17925: LD_INT 1
17927: PUSH
17928: EMPTY
17929: LIST
17930: ST_TO_ADDR
17931: GO 17934
17933: POP
// if not labs then
17934: LD_VAR 0 4
17938: NOT
17939: IFFALSE 17943
// continue ;
17941: GO 17683
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
17943: LD_ADDR_VAR 0 5
17947: PUSH
17948: LD_VAR 0 4
17952: PPUSH
17953: LD_EXP 57
17957: PUSH
17958: LD_VAR 0 1
17962: ARRAY
17963: PUSH
17964: LD_INT 1
17966: ARRAY
17967: PPUSH
17968: LD_EXP 57
17972: PUSH
17973: LD_VAR 0 1
17977: ARRAY
17978: PUSH
17979: LD_INT 2
17981: ARRAY
17982: PPUSH
17983: CALL_OW 73
17987: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
17988: LD_VAR 0 5
17992: NOT
17993: PUSH
17994: LD_VAR 0 5
17998: PUSH
17999: LD_EXP 64
18003: PUSH
18004: LD_VAR 0 1
18008: ARRAY
18009: NONEQUAL
18010: OR
18011: IFFALSE 18116
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18013: LD_INT 7
18015: PPUSH
18016: LD_EXP 65
18020: PUSH
18021: LD_VAR 0 1
18025: ARRAY
18026: PUSH
18027: LD_INT 3
18029: ARRAY
18030: PPUSH
18031: LD_INT 0
18033: PPUSH
18034: LD_EXP 64
18038: PUSH
18039: LD_VAR 0 1
18043: ARRAY
18044: PPUSH
18045: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18049: LD_INT 7
18051: PPUSH
18052: LD_EXP 65
18056: PUSH
18057: LD_VAR 0 1
18061: ARRAY
18062: PUSH
18063: LD_INT 1
18065: ARRAY
18066: PPUSH
18067: LD_INT 0
18069: PPUSH
18070: LD_EXP 64
18074: PUSH
18075: LD_VAR 0 1
18079: ARRAY
18080: PPUSH
18081: CALL_OW 468
// if nearestLab then
18085: LD_VAR 0 5
18089: IFFALSE 18116
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
18091: LD_ADDR_EXP 64
18095: PUSH
18096: LD_EXP 64
18100: PPUSH
18101: LD_VAR 0 1
18105: PPUSH
18106: LD_VAR 0 5
18110: PPUSH
18111: CALL_OW 1
18115: ST_TO_ADDR
// end ; if not nearestLab then
18116: LD_VAR 0 5
18120: NOT
18121: IFFALSE 18125
// continue ;
18123: GO 17683
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
18125: LD_VAR 0 5
18129: PPUSH
18130: LD_EXP 57
18134: PUSH
18135: LD_VAR 0 1
18139: ARRAY
18140: PUSH
18141: LD_INT 1
18143: ARRAY
18144: PPUSH
18145: LD_EXP 57
18149: PUSH
18150: LD_VAR 0 1
18154: ARRAY
18155: PUSH
18156: LD_INT 2
18158: ARRAY
18159: PPUSH
18160: CALL_OW 297
18164: PUSH
18165: LD_INT 8
18167: LESS
18168: IFFALSE 18365
// begin if not artifactsResearched [ i ] then
18170: LD_EXP 60
18174: PUSH
18175: LD_VAR 0 1
18179: ARRAY
18180: NOT
18181: IFFALSE 18262
// begin if BuildingStatus ( nearestLab ) = bs_idle then
18183: LD_VAR 0 5
18187: PPUSH
18188: CALL_OW 461
18192: PUSH
18193: LD_INT 2
18195: EQUAL
18196: IFFALSE 18230
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
18198: LD_INT 7
18200: PPUSH
18201: LD_EXP 65
18205: PUSH
18206: LD_VAR 0 1
18210: ARRAY
18211: PUSH
18212: LD_INT 3
18214: ARRAY
18215: PPUSH
18216: LD_INT 2
18218: PPUSH
18219: LD_VAR 0 5
18223: PPUSH
18224: CALL_OW 468
18228: GO 18260
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
18230: LD_INT 7
18232: PPUSH
18233: LD_EXP 65
18237: PUSH
18238: LD_VAR 0 1
18242: ARRAY
18243: PUSH
18244: LD_INT 3
18246: ARRAY
18247: PPUSH
18248: LD_INT 1
18250: PPUSH
18251: LD_VAR 0 5
18255: PPUSH
18256: CALL_OW 468
// end else
18260: GO 18363
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
18262: LD_VAR 0 5
18266: PPUSH
18267: CALL_OW 461
18271: PUSH
18272: LD_INT 2
18274: EQUAL
18275: PUSH
18276: LD_EXP 66
18280: PUSH
18281: LD_VAR 0 1
18285: ARRAY
18286: AND
18287: IFFALSE 18333
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
18289: LD_INT 7
18291: PPUSH
18292: LD_EXP 65
18296: PUSH
18297: LD_VAR 0 1
18301: ARRAY
18302: PUSH
18303: LD_INT 1
18305: ARRAY
18306: PPUSH
18307: LD_EXP 65
18311: PUSH
18312: LD_VAR 0 1
18316: ARRAY
18317: PUSH
18318: LD_INT 2
18320: ARRAY
18321: PPUSH
18322: LD_VAR 0 5
18326: PPUSH
18327: CALL_OW 468
18331: GO 18363
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
18333: LD_INT 7
18335: PPUSH
18336: LD_EXP 65
18340: PUSH
18341: LD_VAR 0 1
18345: ARRAY
18346: PUSH
18347: LD_INT 1
18349: ARRAY
18350: PPUSH
18351: LD_INT 1
18353: PPUSH
18354: LD_VAR 0 5
18358: PPUSH
18359: CALL_OW 468
// end else
18363: GO 18440
// begin if not artifactsResearched [ i ] then
18365: LD_EXP 60
18369: PUSH
18370: LD_VAR 0 1
18374: ARRAY
18375: NOT
18376: IFFALSE 18410
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
18378: LD_INT 7
18380: PPUSH
18381: LD_EXP 65
18385: PUSH
18386: LD_VAR 0 1
18390: ARRAY
18391: PUSH
18392: LD_INT 3
18394: ARRAY
18395: PPUSH
18396: LD_INT 0
18398: PPUSH
18399: LD_VAR 0 5
18403: PPUSH
18404: CALL_OW 468
18408: GO 18440
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
18410: LD_INT 7
18412: PPUSH
18413: LD_EXP 65
18417: PUSH
18418: LD_VAR 0 1
18422: ARRAY
18423: PUSH
18424: LD_INT 1
18426: ARRAY
18427: PPUSH
18428: LD_INT 0
18430: PPUSH
18431: LD_VAR 0 5
18435: PPUSH
18436: CALL_OW 468
// end ; end else
18440: GO 18579
// begin if not artifactsLabs [ i ] then
18442: LD_EXP 64
18446: PUSH
18447: LD_VAR 0 1
18451: ARRAY
18452: NOT
18453: IFFALSE 18457
// continue ;
18455: GO 17683
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18457: LD_INT 7
18459: PPUSH
18460: LD_EXP 65
18464: PUSH
18465: LD_VAR 0 1
18469: ARRAY
18470: PUSH
18471: LD_INT 3
18473: ARRAY
18474: PPUSH
18475: LD_INT 0
18477: PPUSH
18478: LD_EXP 64
18482: PUSH
18483: LD_VAR 0 1
18487: ARRAY
18488: PPUSH
18489: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18493: LD_INT 7
18495: PPUSH
18496: LD_EXP 65
18500: PUSH
18501: LD_VAR 0 1
18505: ARRAY
18506: PUSH
18507: LD_INT 1
18509: ARRAY
18510: PPUSH
18511: LD_INT 0
18513: PPUSH
18514: LD_EXP 64
18518: PUSH
18519: LD_VAR 0 1
18523: ARRAY
18524: PPUSH
18525: CALL_OW 468
// if artifactsLabsWorking [ i ] then
18529: LD_EXP 61
18533: PUSH
18534: LD_VAR 0 1
18538: ARRAY
18539: IFFALSE 18579
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
18541: LD_ADDR_EXP 61
18545: PUSH
18546: LD_EXP 61
18550: PPUSH
18551: LD_VAR 0 1
18555: PPUSH
18556: LD_INT 0
18558: PPUSH
18559: CALL_OW 1
18563: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
18564: LD_EXP 64
18568: PUSH
18569: LD_VAR 0 1
18573: ARRAY
18574: PPUSH
18575: CALL_OW 127
// end ; end ; end ;
18579: GO 17683
18581: POP
18582: POP
// end ;
18583: PPOPN 5
18585: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
18586: LD_INT 0
18588: PPUSH
18589: PPUSH
18590: PPUSH
18591: PPUSH
18592: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
18593: LD_VAR 0 2
18597: PUSH
18598: LD_EXP 65
18602: PUSH
18603: LD_INT 1
18605: ARRAY
18606: PUSH
18607: LD_INT 3
18609: ARRAY
18610: EQUAL
18611: IFFALSE 18734
// begin lab := artifactsLabs [ 1 ] ;
18613: LD_ADDR_VAR 0 6
18617: PUSH
18618: LD_EXP 64
18622: PUSH
18623: LD_INT 1
18625: ARRAY
18626: ST_TO_ADDR
// if not lab then
18627: LD_VAR 0 6
18631: NOT
18632: IFFALSE 18636
// exit ;
18634: GO 19668
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
18636: LD_VAR 0 6
18640: PPUSH
18641: LD_EXP 62
18645: PUSH
18646: LD_INT 1
18648: ARRAY
18649: PPUSH
18650: LD_INT 1
18652: PPUSH
18653: CALL_OW 486
// if artifactsResProgress [ 1 ] then
18657: LD_EXP 63
18661: PUSH
18662: LD_INT 1
18664: ARRAY
18665: IFFALSE 18685
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
18667: LD_VAR 0 6
18671: PPUSH
18672: LD_EXP 63
18676: PUSH
18677: LD_INT 1
18679: ARRAY
18680: PPUSH
18681: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
18685: LD_ADDR_EXP 61
18689: PUSH
18690: LD_EXP 61
18694: PPUSH
18695: LD_INT 1
18697: PPUSH
18698: LD_INT 1
18700: PPUSH
18701: CALL_OW 1
18705: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
18706: LD_INT 7
18708: PPUSH
18709: LD_EXP 65
18713: PUSH
18714: LD_INT 1
18716: ARRAY
18717: PUSH
18718: LD_INT 3
18720: ARRAY
18721: PPUSH
18722: LD_INT 0
18724: PPUSH
18725: LD_VAR 0 6
18729: PPUSH
18730: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
18734: LD_VAR 0 2
18738: PUSH
18739: LD_EXP 65
18743: PUSH
18744: LD_INT 2
18746: ARRAY
18747: PUSH
18748: LD_INT 3
18750: ARRAY
18751: EQUAL
18752: IFFALSE 18875
// begin lab := artifactsLabs [ 2 ] ;
18754: LD_ADDR_VAR 0 6
18758: PUSH
18759: LD_EXP 64
18763: PUSH
18764: LD_INT 2
18766: ARRAY
18767: ST_TO_ADDR
// if not lab then
18768: LD_VAR 0 6
18772: NOT
18773: IFFALSE 18777
// exit ;
18775: GO 19668
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
18777: LD_VAR 0 6
18781: PPUSH
18782: LD_EXP 62
18786: PUSH
18787: LD_INT 2
18789: ARRAY
18790: PPUSH
18791: LD_INT 1
18793: PPUSH
18794: CALL_OW 486
// if artifactsResProgress [ 2 ] then
18798: LD_EXP 63
18802: PUSH
18803: LD_INT 2
18805: ARRAY
18806: IFFALSE 18826
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
18808: LD_VAR 0 6
18812: PPUSH
18813: LD_EXP 63
18817: PUSH
18818: LD_INT 2
18820: ARRAY
18821: PPUSH
18822: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
18826: LD_ADDR_EXP 61
18830: PUSH
18831: LD_EXP 61
18835: PPUSH
18836: LD_INT 2
18838: PPUSH
18839: LD_INT 1
18841: PPUSH
18842: CALL_OW 1
18846: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
18847: LD_INT 7
18849: PPUSH
18850: LD_EXP 65
18854: PUSH
18855: LD_INT 2
18857: ARRAY
18858: PUSH
18859: LD_INT 3
18861: ARRAY
18862: PPUSH
18863: LD_INT 0
18865: PPUSH
18866: LD_VAR 0 6
18870: PPUSH
18871: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
18875: LD_VAR 0 2
18879: PUSH
18880: LD_EXP 65
18884: PUSH
18885: LD_INT 3
18887: ARRAY
18888: PUSH
18889: LD_INT 3
18891: ARRAY
18892: EQUAL
18893: IFFALSE 19016
// begin lab := artifactsLabs [ 3 ] ;
18895: LD_ADDR_VAR 0 6
18899: PUSH
18900: LD_EXP 64
18904: PUSH
18905: LD_INT 3
18907: ARRAY
18908: ST_TO_ADDR
// if not lab then
18909: LD_VAR 0 6
18913: NOT
18914: IFFALSE 18918
// exit ;
18916: GO 19668
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
18918: LD_VAR 0 6
18922: PPUSH
18923: LD_EXP 62
18927: PUSH
18928: LD_INT 3
18930: ARRAY
18931: PPUSH
18932: LD_INT 1
18934: PPUSH
18935: CALL_OW 486
// if artifactsResProgress [ 3 ] then
18939: LD_EXP 63
18943: PUSH
18944: LD_INT 3
18946: ARRAY
18947: IFFALSE 18967
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
18949: LD_VAR 0 6
18953: PPUSH
18954: LD_EXP 63
18958: PUSH
18959: LD_INT 3
18961: ARRAY
18962: PPUSH
18963: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
18967: LD_ADDR_EXP 61
18971: PUSH
18972: LD_EXP 61
18976: PPUSH
18977: LD_INT 3
18979: PPUSH
18980: LD_INT 1
18982: PPUSH
18983: CALL_OW 1
18987: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
18988: LD_INT 7
18990: PPUSH
18991: LD_EXP 65
18995: PUSH
18996: LD_INT 3
18998: ARRAY
18999: PUSH
19000: LD_INT 3
19002: ARRAY
19003: PPUSH
19004: LD_INT 0
19006: PPUSH
19007: LD_VAR 0 6
19011: PPUSH
19012: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
19016: LD_VAR 0 2
19020: PUSH
19021: LD_EXP 65
19025: PUSH
19026: LD_INT 1
19028: ARRAY
19029: PUSH
19030: LD_INT 1
19032: ARRAY
19033: EQUAL
19034: IFFALSE 19192
// begin lab := artifactsLabs [ 1 ] ;
19036: LD_ADDR_VAR 0 6
19040: PUSH
19041: LD_EXP 64
19045: PUSH
19046: LD_INT 1
19048: ARRAY
19049: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
19050: LD_VAR 0 6
19054: PPUSH
19055: CALL_OW 274
19059: PPUSH
19060: CALL 93327 0 1
19064: PUSH
19065: LD_INT 3
19067: ARRAY
19068: PUSH
19069: LD_EXP 59
19073: PUSH
19074: LD_INT 1
19076: ARRAY
19077: LESS
19078: IFFALSE 19092
// begin HintSpec ( ArtifactCost , 2 ) ;
19080: LD_STRING ArtifactCost
19082: PPUSH
19083: LD_INT 2
19085: PPUSH
19086: CALL_OW 338
// exit ;
19090: GO 19668
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
19092: LD_ADDR_EXP 66
19096: PUSH
19097: LD_EXP 66
19101: PPUSH
19102: LD_INT 1
19104: PPUSH
19105: LD_INT 0
19107: PPUSH
19108: CALL_OW 1
19112: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
19113: LD_VAR 0 3
19117: PPUSH
19118: LD_VAR 0 4
19122: PPUSH
19123: LD_INT 7
19125: PPUSH
19126: LD_INT 12
19128: NEG
19129: PPUSH
19130: CALL_OW 330
// wait ( 0 0$30 ) ;
19134: LD_INT 1050
19136: PPUSH
19137: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
19141: LD_VAR 0 3
19145: PPUSH
19146: LD_VAR 0 4
19150: PPUSH
19151: LD_INT 7
19153: PPUSH
19154: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
19158: LD_EXP 58
19162: PUSH
19163: LD_INT 1
19165: ARRAY
19166: PPUSH
19167: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
19171: LD_ADDR_EXP 66
19175: PUSH
19176: LD_EXP 66
19180: PPUSH
19181: LD_INT 1
19183: PPUSH
19184: LD_INT 1
19186: PPUSH
19187: CALL_OW 1
19191: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
19192: LD_VAR 0 2
19196: PUSH
19197: LD_EXP 65
19201: PUSH
19202: LD_INT 2
19204: ARRAY
19205: PUSH
19206: LD_INT 1
19208: ARRAY
19209: EQUAL
19210: IFFALSE 19422
// begin lab := artifactsLabs [ 2 ] ;
19212: LD_ADDR_VAR 0 6
19216: PUSH
19217: LD_EXP 64
19221: PUSH
19222: LD_INT 2
19224: ARRAY
19225: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] ] ] ) then
19226: LD_VAR 0 3
19230: PUSH
19231: LD_INT 81
19233: PUSH
19234: LD_INT 7
19236: PUSH
19237: EMPTY
19238: LIST
19239: LIST
19240: PUSH
19241: LD_INT 2
19243: PUSH
19244: LD_INT 32
19246: PUSH
19247: LD_INT 3
19249: PUSH
19250: EMPTY
19251: LIST
19252: LIST
19253: PUSH
19254: LD_INT 30
19256: PUSH
19257: LD_INT 28
19259: PUSH
19260: EMPTY
19261: LIST
19262: LIST
19263: PUSH
19264: LD_INT 30
19266: PUSH
19267: LD_INT 30
19269: PUSH
19270: EMPTY
19271: LIST
19272: LIST
19273: PUSH
19274: LD_INT 35
19276: PUSH
19277: LD_INT 49
19279: PUSH
19280: EMPTY
19281: LIST
19282: LIST
19283: PUSH
19284: LD_INT 34
19286: PUSH
19287: LD_INT 49
19289: PUSH
19290: EMPTY
19291: LIST
19292: LIST
19293: PUSH
19294: EMPTY
19295: LIST
19296: LIST
19297: LIST
19298: LIST
19299: LIST
19300: LIST
19301: PUSH
19302: EMPTY
19303: LIST
19304: LIST
19305: PPUSH
19306: CALL_OW 69
19310: IN
19311: NOT
19312: IFFALSE 19316
// exit ;
19314: GO 19668
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
19316: LD_VAR 0 6
19320: PPUSH
19321: CALL_OW 274
19325: PPUSH
19326: CALL 93327 0 1
19330: PUSH
19331: LD_INT 3
19333: ARRAY
19334: PUSH
19335: LD_EXP 59
19339: PUSH
19340: LD_INT 2
19342: ARRAY
19343: LESS
19344: IFFALSE 19358
// begin HintSpec ( ArtifactCost , 2 ) ;
19346: LD_STRING ArtifactCost
19348: PPUSH
19349: LD_INT 2
19351: PPUSH
19352: CALL_OW 338
// exit ;
19356: GO 19668
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
19358: LD_ADDR_EXP 66
19362: PUSH
19363: LD_EXP 66
19367: PPUSH
19368: LD_INT 2
19370: PPUSH
19371: LD_INT 0
19373: PPUSH
19374: CALL_OW 1
19378: ST_TO_ADDR
// KillUnit ( x ) ;
19379: LD_VAR 0 3
19383: PPUSH
19384: CALL_OW 66
// wait ( artifactsRecharge [ 2 ] ) ;
19388: LD_EXP 58
19392: PUSH
19393: LD_INT 2
19395: ARRAY
19396: PPUSH
19397: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
19401: LD_ADDR_EXP 66
19405: PUSH
19406: LD_EXP 66
19410: PPUSH
19411: LD_INT 2
19413: PPUSH
19414: LD_INT 1
19416: PPUSH
19417: CALL_OW 1
19421: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
19422: LD_VAR 0 2
19426: PUSH
19427: LD_EXP 65
19431: PUSH
19432: LD_INT 3
19434: ARRAY
19435: PUSH
19436: LD_INT 1
19438: ARRAY
19439: EQUAL
19440: IFFALSE 19668
// begin lab := artifactsLabs [ 3 ] ;
19442: LD_ADDR_VAR 0 6
19446: PUSH
19447: LD_EXP 64
19451: PUSH
19452: LD_INT 3
19454: ARRAY
19455: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
19456: LD_VAR 0 6
19460: PPUSH
19461: CALL_OW 274
19465: PPUSH
19466: CALL 93327 0 1
19470: PUSH
19471: LD_INT 3
19473: ARRAY
19474: PUSH
19475: LD_EXP 59
19479: PUSH
19480: LD_INT 3
19482: ARRAY
19483: LESS
19484: IFFALSE 19498
// begin HintSpec ( ArtifactCost , 2 ) ;
19486: LD_STRING ArtifactCost
19488: PPUSH
19489: LD_INT 2
19491: PPUSH
19492: CALL_OW 338
// exit ;
19496: GO 19668
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
19498: LD_INT 37
19500: PPUSH
19501: LD_INT 1
19503: PPUSH
19504: CALL_OW 424
// time := 0 0$30 ;
19508: LD_ADDR_VAR 0 7
19512: PUSH
19513: LD_INT 1050
19515: ST_TO_ADDR
// repeat display_strings := [ Am15a-1 , time ] ;
19516: LD_ADDR_OWVAR 47
19520: PUSH
19521: LD_STRING Am15a-1
19523: PUSH
19524: LD_VAR 0 7
19528: PUSH
19529: EMPTY
19530: LIST
19531: LIST
19532: ST_TO_ADDR
// wait ( 0 0$1 ) ;
19533: LD_INT 35
19535: PPUSH
19536: CALL_OW 67
// time := time - 0 0$1 ;
19540: LD_ADDR_VAR 0 7
19544: PUSH
19545: LD_VAR 0 7
19549: PUSH
19550: LD_INT 35
19552: MINUS
19553: ST_TO_ADDR
// until time = 0 0$00 ;
19554: LD_VAR 0 7
19558: PUSH
19559: LD_INT 0
19561: EQUAL
19562: IFFALSE 19516
// display_strings :=  ;
19564: LD_ADDR_OWVAR 47
19568: PUSH
19569: LD_STRING 
19571: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
19572: LD_INT 37
19574: PPUSH
19575: LD_INT 0
19577: PPUSH
19578: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
19582: LD_ADDR_VAR 0 8
19586: PUSH
19587: LD_INT 37
19589: PPUSH
19590: LD_INT 3
19592: PUSH
19593: LD_INT 21
19595: PUSH
19596: LD_INT 3
19598: PUSH
19599: EMPTY
19600: LIST
19601: LIST
19602: PUSH
19603: EMPTY
19604: LIST
19605: LIST
19606: PPUSH
19607: CALL_OW 70
19611: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
19612: LD_VAR 0 3
19616: PPUSH
19617: LD_VAR 0 4
19621: PPUSH
19622: CALL_OW 84
// for un in list do
19626: LD_ADDR_VAR 0 9
19630: PUSH
19631: LD_VAR 0 8
19635: PUSH
19636: FOR_IN
19637: IFFALSE 19666
// TeleportUnit ( un , x , y , 12 , true ) ;
19639: LD_VAR 0 9
19643: PPUSH
19644: LD_VAR 0 3
19648: PPUSH
19649: LD_VAR 0 4
19653: PPUSH
19654: LD_INT 12
19656: PPUSH
19657: LD_INT 1
19659: PPUSH
19660: CALL_OW 483
19664: GO 19636
19666: POP
19667: POP
// end ; end ;
19668: PPOPN 9
19670: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
19671: LD_INT 0
19673: PPUSH
19674: PPUSH
// begin labNum := 0 ;
19675: LD_ADDR_VAR 0 4
19679: PUSH
19680: LD_INT 0
19682: ST_TO_ADDR
// for i = 1 to artifactsLabs do
19683: LD_ADDR_VAR 0 3
19687: PUSH
19688: DOUBLE
19689: LD_INT 1
19691: DEC
19692: ST_TO_ADDR
19693: LD_EXP 64
19697: PUSH
19698: FOR_TO
19699: IFFALSE 19733
// if artifactsLabs [ i ] = lab then
19701: LD_EXP 64
19705: PUSH
19706: LD_VAR 0 3
19710: ARRAY
19711: PUSH
19712: LD_VAR 0 1
19716: EQUAL
19717: IFFALSE 19731
// begin labNum := i ;
19719: LD_ADDR_VAR 0 4
19723: PUSH
19724: LD_VAR 0 3
19728: ST_TO_ADDR
// break ;
19729: GO 19733
// end ;
19731: GO 19698
19733: POP
19734: POP
// if not labNum then
19735: LD_VAR 0 4
19739: NOT
19740: IFFALSE 19744
// exit ;
19742: GO 19822
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
19744: LD_INT 7
19746: PPUSH
19747: LD_EXP 65
19751: PUSH
19752: LD_VAR 0 4
19756: ARRAY
19757: PUSH
19758: LD_INT 3
19760: ARRAY
19761: PPUSH
19762: LD_INT 2
19764: PPUSH
19765: LD_VAR 0 1
19769: PPUSH
19770: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
19774: LD_ADDR_EXP 63
19778: PUSH
19779: LD_EXP 63
19783: PPUSH
19784: LD_VAR 0 4
19788: PPUSH
19789: LD_VAR 0 2
19793: PPUSH
19794: CALL_OW 1
19798: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
19799: LD_ADDR_EXP 61
19803: PUSH
19804: LD_EXP 61
19808: PPUSH
19809: LD_VAR 0 4
19813: PPUSH
19814: LD_INT 0
19816: PPUSH
19817: CALL_OW 1
19821: ST_TO_ADDR
// end ;
19822: PPOPN 4
19824: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
19825: LD_INT 0
19827: PPUSH
19828: PPUSH
// begin labNum := 0 ;
19829: LD_ADDR_VAR 0 3
19833: PUSH
19834: LD_INT 0
19836: ST_TO_ADDR
// for i = 1 to artifactsLabs do
19837: LD_ADDR_VAR 0 2
19841: PUSH
19842: DOUBLE
19843: LD_INT 1
19845: DEC
19846: ST_TO_ADDR
19847: LD_EXP 64
19851: PUSH
19852: FOR_TO
19853: IFFALSE 19887
// if artifactsLabs [ i ] = lab then
19855: LD_EXP 64
19859: PUSH
19860: LD_VAR 0 2
19864: ARRAY
19865: PUSH
19866: LD_VAR 0 1
19870: EQUAL
19871: IFFALSE 19885
// begin labNum := i ;
19873: LD_ADDR_VAR 0 3
19877: PUSH
19878: LD_VAR 0 2
19882: ST_TO_ADDR
// break ;
19883: GO 19887
// end ;
19885: GO 19852
19887: POP
19888: POP
// if not labNum then
19889: LD_VAR 0 3
19893: NOT
19894: IFFALSE 19898
// exit ;
19896: GO 20060
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
19898: LD_INT 7
19900: PPUSH
19901: LD_EXP 65
19905: PUSH
19906: LD_VAR 0 3
19910: ARRAY
19911: PUSH
19912: LD_INT 3
19914: ARRAY
19915: PPUSH
19916: LD_INT 0
19918: PPUSH
19919: LD_VAR 0 1
19923: PPUSH
19924: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
19928: LD_ADDR_EXP 60
19932: PUSH
19933: LD_EXP 60
19937: PPUSH
19938: LD_VAR 0 3
19942: PPUSH
19943: LD_INT 1
19945: PPUSH
19946: CALL_OW 1
19950: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
19951: LD_ADDR_EXP 66
19955: PUSH
19956: LD_EXP 66
19960: PPUSH
19961: LD_VAR 0 3
19965: PPUSH
19966: LD_INT 1
19968: PPUSH
19969: CALL_OW 1
19973: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
19974: LD_ADDR_EXP 61
19978: PUSH
19979: LD_EXP 61
19983: PPUSH
19984: LD_VAR 0 3
19988: PPUSH
19989: LD_INT 0
19991: PPUSH
19992: CALL_OW 1
19996: ST_TO_ADDR
// case labNum of 1 :
19997: LD_VAR 0 3
20001: PUSH
20002: LD_INT 1
20004: DOUBLE
20005: EQUAL
20006: IFTRUE 20010
20008: GO 20021
20010: POP
// artifactIResearched := true ; 2 :
20011: LD_ADDR_EXP 9
20015: PUSH
20016: LD_INT 1
20018: ST_TO_ADDR
20019: GO 20060
20021: LD_INT 2
20023: DOUBLE
20024: EQUAL
20025: IFTRUE 20029
20027: GO 20040
20029: POP
// artifactIIResearched := true ; 3 :
20030: LD_ADDR_EXP 10
20034: PUSH
20035: LD_INT 1
20037: ST_TO_ADDR
20038: GO 20060
20040: LD_INT 3
20042: DOUBLE
20043: EQUAL
20044: IFTRUE 20048
20046: GO 20059
20048: POP
// artifactIIIResearched := true ; end ;
20049: LD_ADDR_EXP 11
20053: PUSH
20054: LD_INT 1
20056: ST_TO_ADDR
20057: GO 20060
20059: POP
// end ; end_of_file
20060: PPOPN 3
20062: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
20063: GO 20065
20065: DISABLE
// begin ru_radar := 98 ;
20066: LD_ADDR_EXP 67
20070: PUSH
20071: LD_INT 98
20073: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
20074: LD_ADDR_EXP 68
20078: PUSH
20079: LD_INT 89
20081: ST_TO_ADDR
// us_hack := 99 ;
20082: LD_ADDR_EXP 69
20086: PUSH
20087: LD_INT 99
20089: ST_TO_ADDR
// us_artillery := 97 ;
20090: LD_ADDR_EXP 70
20094: PUSH
20095: LD_INT 97
20097: ST_TO_ADDR
// ar_bio_bomb := 91 ;
20098: LD_ADDR_EXP 71
20102: PUSH
20103: LD_INT 91
20105: ST_TO_ADDR
// end ; end_of_file
20106: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
20107: LD_INT 0
20109: PPUSH
20110: PPUSH
// skirmish := false ;
20111: LD_ADDR_EXP 72
20115: PUSH
20116: LD_INT 0
20118: ST_TO_ADDR
// debug_mc := false ;
20119: LD_ADDR_EXP 73
20123: PUSH
20124: LD_INT 0
20126: ST_TO_ADDR
// mc_bases := [ ] ;
20127: LD_ADDR_EXP 74
20131: PUSH
20132: EMPTY
20133: ST_TO_ADDR
// mc_sides := [ ] ;
20134: LD_ADDR_EXP 100
20138: PUSH
20139: EMPTY
20140: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
20141: LD_ADDR_EXP 75
20145: PUSH
20146: EMPTY
20147: ST_TO_ADDR
// mc_building_repairs := [ ] ;
20148: LD_ADDR_EXP 76
20152: PUSH
20153: EMPTY
20154: ST_TO_ADDR
// mc_need_heal := [ ] ;
20155: LD_ADDR_EXP 77
20159: PUSH
20160: EMPTY
20161: ST_TO_ADDR
// mc_healers := [ ] ;
20162: LD_ADDR_EXP 78
20166: PUSH
20167: EMPTY
20168: ST_TO_ADDR
// mc_build_list := [ ] ;
20169: LD_ADDR_EXP 79
20173: PUSH
20174: EMPTY
20175: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
20176: LD_ADDR_EXP 106
20180: PUSH
20181: EMPTY
20182: ST_TO_ADDR
// mc_builders := [ ] ;
20183: LD_ADDR_EXP 80
20187: PUSH
20188: EMPTY
20189: ST_TO_ADDR
// mc_construct_list := [ ] ;
20190: LD_ADDR_EXP 81
20194: PUSH
20195: EMPTY
20196: ST_TO_ADDR
// mc_turret_list := [ ] ;
20197: LD_ADDR_EXP 82
20201: PUSH
20202: EMPTY
20203: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
20204: LD_ADDR_EXP 83
20208: PUSH
20209: EMPTY
20210: ST_TO_ADDR
// mc_miners := [ ] ;
20211: LD_ADDR_EXP 88
20215: PUSH
20216: EMPTY
20217: ST_TO_ADDR
// mc_mines := [ ] ;
20218: LD_ADDR_EXP 87
20222: PUSH
20223: EMPTY
20224: ST_TO_ADDR
// mc_minefields := [ ] ;
20225: LD_ADDR_EXP 89
20229: PUSH
20230: EMPTY
20231: ST_TO_ADDR
// mc_crates := [ ] ;
20232: LD_ADDR_EXP 90
20236: PUSH
20237: EMPTY
20238: ST_TO_ADDR
// mc_crates_collector := [ ] ;
20239: LD_ADDR_EXP 91
20243: PUSH
20244: EMPTY
20245: ST_TO_ADDR
// mc_crates_area := [ ] ;
20246: LD_ADDR_EXP 92
20250: PUSH
20251: EMPTY
20252: ST_TO_ADDR
// mc_vehicles := [ ] ;
20253: LD_ADDR_EXP 93
20257: PUSH
20258: EMPTY
20259: ST_TO_ADDR
// mc_attack := [ ] ;
20260: LD_ADDR_EXP 94
20264: PUSH
20265: EMPTY
20266: ST_TO_ADDR
// mc_produce := [ ] ;
20267: LD_ADDR_EXP 95
20271: PUSH
20272: EMPTY
20273: ST_TO_ADDR
// mc_defender := [ ] ;
20274: LD_ADDR_EXP 96
20278: PUSH
20279: EMPTY
20280: ST_TO_ADDR
// mc_parking := [ ] ;
20281: LD_ADDR_EXP 98
20285: PUSH
20286: EMPTY
20287: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
20288: LD_ADDR_EXP 84
20292: PUSH
20293: EMPTY
20294: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
20295: LD_ADDR_EXP 86
20299: PUSH
20300: EMPTY
20301: ST_TO_ADDR
// mc_scan := [ ] ;
20302: LD_ADDR_EXP 97
20306: PUSH
20307: EMPTY
20308: ST_TO_ADDR
// mc_scan_area := [ ] ;
20309: LD_ADDR_EXP 99
20313: PUSH
20314: EMPTY
20315: ST_TO_ADDR
// mc_tech := [ ] ;
20316: LD_ADDR_EXP 101
20320: PUSH
20321: EMPTY
20322: ST_TO_ADDR
// mc_class := [ ] ;
20323: LD_ADDR_EXP 115
20327: PUSH
20328: EMPTY
20329: ST_TO_ADDR
// mc_class_case_use := [ ] ;
20330: LD_ADDR_EXP 116
20334: PUSH
20335: EMPTY
20336: ST_TO_ADDR
// end ;
20337: LD_VAR 0 1
20341: RET
// export function MC_Kill ( base ) ; begin
20342: LD_INT 0
20344: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
20345: LD_ADDR_EXP 74
20349: PUSH
20350: LD_EXP 74
20354: PPUSH
20355: LD_VAR 0 1
20359: PPUSH
20360: EMPTY
20361: PPUSH
20362: CALL_OW 1
20366: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
20367: LD_ADDR_EXP 75
20371: PUSH
20372: LD_EXP 75
20376: PPUSH
20377: LD_VAR 0 1
20381: PPUSH
20382: EMPTY
20383: PPUSH
20384: CALL_OW 1
20388: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
20389: LD_ADDR_EXP 76
20393: PUSH
20394: LD_EXP 76
20398: PPUSH
20399: LD_VAR 0 1
20403: PPUSH
20404: EMPTY
20405: PPUSH
20406: CALL_OW 1
20410: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
20411: LD_ADDR_EXP 77
20415: PUSH
20416: LD_EXP 77
20420: PPUSH
20421: LD_VAR 0 1
20425: PPUSH
20426: EMPTY
20427: PPUSH
20428: CALL_OW 1
20432: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
20433: LD_ADDR_EXP 78
20437: PUSH
20438: LD_EXP 78
20442: PPUSH
20443: LD_VAR 0 1
20447: PPUSH
20448: EMPTY
20449: PPUSH
20450: CALL_OW 1
20454: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
20455: LD_ADDR_EXP 79
20459: PUSH
20460: LD_EXP 79
20464: PPUSH
20465: LD_VAR 0 1
20469: PPUSH
20470: EMPTY
20471: PPUSH
20472: CALL_OW 1
20476: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
20477: LD_ADDR_EXP 80
20481: PUSH
20482: LD_EXP 80
20486: PPUSH
20487: LD_VAR 0 1
20491: PPUSH
20492: EMPTY
20493: PPUSH
20494: CALL_OW 1
20498: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
20499: LD_ADDR_EXP 81
20503: PUSH
20504: LD_EXP 81
20508: PPUSH
20509: LD_VAR 0 1
20513: PPUSH
20514: EMPTY
20515: PPUSH
20516: CALL_OW 1
20520: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
20521: LD_ADDR_EXP 82
20525: PUSH
20526: LD_EXP 82
20530: PPUSH
20531: LD_VAR 0 1
20535: PPUSH
20536: EMPTY
20537: PPUSH
20538: CALL_OW 1
20542: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
20543: LD_ADDR_EXP 83
20547: PUSH
20548: LD_EXP 83
20552: PPUSH
20553: LD_VAR 0 1
20557: PPUSH
20558: EMPTY
20559: PPUSH
20560: CALL_OW 1
20564: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
20565: LD_ADDR_EXP 84
20569: PUSH
20570: LD_EXP 84
20574: PPUSH
20575: LD_VAR 0 1
20579: PPUSH
20580: EMPTY
20581: PPUSH
20582: CALL_OW 1
20586: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
20587: LD_ADDR_EXP 85
20591: PUSH
20592: LD_EXP 85
20596: PPUSH
20597: LD_VAR 0 1
20601: PPUSH
20602: LD_INT 0
20604: PPUSH
20605: CALL_OW 1
20609: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
20610: LD_ADDR_EXP 86
20614: PUSH
20615: LD_EXP 86
20619: PPUSH
20620: LD_VAR 0 1
20624: PPUSH
20625: EMPTY
20626: PPUSH
20627: CALL_OW 1
20631: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
20632: LD_ADDR_EXP 87
20636: PUSH
20637: LD_EXP 87
20641: PPUSH
20642: LD_VAR 0 1
20646: PPUSH
20647: EMPTY
20648: PPUSH
20649: CALL_OW 1
20653: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
20654: LD_ADDR_EXP 88
20658: PUSH
20659: LD_EXP 88
20663: PPUSH
20664: LD_VAR 0 1
20668: PPUSH
20669: EMPTY
20670: PPUSH
20671: CALL_OW 1
20675: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
20676: LD_ADDR_EXP 89
20680: PUSH
20681: LD_EXP 89
20685: PPUSH
20686: LD_VAR 0 1
20690: PPUSH
20691: EMPTY
20692: PPUSH
20693: CALL_OW 1
20697: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
20698: LD_ADDR_EXP 90
20702: PUSH
20703: LD_EXP 90
20707: PPUSH
20708: LD_VAR 0 1
20712: PPUSH
20713: EMPTY
20714: PPUSH
20715: CALL_OW 1
20719: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
20720: LD_ADDR_EXP 91
20724: PUSH
20725: LD_EXP 91
20729: PPUSH
20730: LD_VAR 0 1
20734: PPUSH
20735: EMPTY
20736: PPUSH
20737: CALL_OW 1
20741: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
20742: LD_ADDR_EXP 92
20746: PUSH
20747: LD_EXP 92
20751: PPUSH
20752: LD_VAR 0 1
20756: PPUSH
20757: EMPTY
20758: PPUSH
20759: CALL_OW 1
20763: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
20764: LD_ADDR_EXP 93
20768: PUSH
20769: LD_EXP 93
20773: PPUSH
20774: LD_VAR 0 1
20778: PPUSH
20779: EMPTY
20780: PPUSH
20781: CALL_OW 1
20785: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
20786: LD_ADDR_EXP 94
20790: PUSH
20791: LD_EXP 94
20795: PPUSH
20796: LD_VAR 0 1
20800: PPUSH
20801: EMPTY
20802: PPUSH
20803: CALL_OW 1
20807: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
20808: LD_ADDR_EXP 95
20812: PUSH
20813: LD_EXP 95
20817: PPUSH
20818: LD_VAR 0 1
20822: PPUSH
20823: EMPTY
20824: PPUSH
20825: CALL_OW 1
20829: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
20830: LD_ADDR_EXP 96
20834: PUSH
20835: LD_EXP 96
20839: PPUSH
20840: LD_VAR 0 1
20844: PPUSH
20845: EMPTY
20846: PPUSH
20847: CALL_OW 1
20851: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
20852: LD_ADDR_EXP 97
20856: PUSH
20857: LD_EXP 97
20861: PPUSH
20862: LD_VAR 0 1
20866: PPUSH
20867: EMPTY
20868: PPUSH
20869: CALL_OW 1
20873: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
20874: LD_ADDR_EXP 98
20878: PUSH
20879: LD_EXP 98
20883: PPUSH
20884: LD_VAR 0 1
20888: PPUSH
20889: EMPTY
20890: PPUSH
20891: CALL_OW 1
20895: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
20896: LD_ADDR_EXP 99
20900: PUSH
20901: LD_EXP 99
20905: PPUSH
20906: LD_VAR 0 1
20910: PPUSH
20911: EMPTY
20912: PPUSH
20913: CALL_OW 1
20917: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
20918: LD_ADDR_EXP 101
20922: PUSH
20923: LD_EXP 101
20927: PPUSH
20928: LD_VAR 0 1
20932: PPUSH
20933: EMPTY
20934: PPUSH
20935: CALL_OW 1
20939: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
20940: LD_ADDR_EXP 103
20944: PUSH
20945: LD_EXP 103
20949: PPUSH
20950: LD_VAR 0 1
20954: PPUSH
20955: EMPTY
20956: PPUSH
20957: CALL_OW 1
20961: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
20962: LD_ADDR_EXP 104
20966: PUSH
20967: LD_EXP 104
20971: PPUSH
20972: LD_VAR 0 1
20976: PPUSH
20977: EMPTY
20978: PPUSH
20979: CALL_OW 1
20983: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
20984: LD_ADDR_EXP 105
20988: PUSH
20989: LD_EXP 105
20993: PPUSH
20994: LD_VAR 0 1
20998: PPUSH
20999: EMPTY
21000: PPUSH
21001: CALL_OW 1
21005: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
21006: LD_ADDR_EXP 106
21010: PUSH
21011: LD_EXP 106
21015: PPUSH
21016: LD_VAR 0 1
21020: PPUSH
21021: EMPTY
21022: PPUSH
21023: CALL_OW 1
21027: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
21028: LD_ADDR_EXP 107
21032: PUSH
21033: LD_EXP 107
21037: PPUSH
21038: LD_VAR 0 1
21042: PPUSH
21043: EMPTY
21044: PPUSH
21045: CALL_OW 1
21049: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
21050: LD_ADDR_EXP 108
21054: PUSH
21055: LD_EXP 108
21059: PPUSH
21060: LD_VAR 0 1
21064: PPUSH
21065: EMPTY
21066: PPUSH
21067: CALL_OW 1
21071: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
21072: LD_ADDR_EXP 109
21076: PUSH
21077: LD_EXP 109
21081: PPUSH
21082: LD_VAR 0 1
21086: PPUSH
21087: EMPTY
21088: PPUSH
21089: CALL_OW 1
21093: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
21094: LD_ADDR_EXP 110
21098: PUSH
21099: LD_EXP 110
21103: PPUSH
21104: LD_VAR 0 1
21108: PPUSH
21109: EMPTY
21110: PPUSH
21111: CALL_OW 1
21115: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
21116: LD_ADDR_EXP 111
21120: PUSH
21121: LD_EXP 111
21125: PPUSH
21126: LD_VAR 0 1
21130: PPUSH
21131: EMPTY
21132: PPUSH
21133: CALL_OW 1
21137: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
21138: LD_ADDR_EXP 112
21142: PUSH
21143: LD_EXP 112
21147: PPUSH
21148: LD_VAR 0 1
21152: PPUSH
21153: EMPTY
21154: PPUSH
21155: CALL_OW 1
21159: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
21160: LD_ADDR_EXP 113
21164: PUSH
21165: LD_EXP 113
21169: PPUSH
21170: LD_VAR 0 1
21174: PPUSH
21175: EMPTY
21176: PPUSH
21177: CALL_OW 1
21181: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
21182: LD_ADDR_EXP 114
21186: PUSH
21187: LD_EXP 114
21191: PPUSH
21192: LD_VAR 0 1
21196: PPUSH
21197: EMPTY
21198: PPUSH
21199: CALL_OW 1
21203: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
21204: LD_ADDR_EXP 115
21208: PUSH
21209: LD_EXP 115
21213: PPUSH
21214: LD_VAR 0 1
21218: PPUSH
21219: EMPTY
21220: PPUSH
21221: CALL_OW 1
21225: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
21226: LD_ADDR_EXP 116
21230: PUSH
21231: LD_EXP 116
21235: PPUSH
21236: LD_VAR 0 1
21240: PPUSH
21241: LD_INT 0
21243: PPUSH
21244: CALL_OW 1
21248: ST_TO_ADDR
// end ;
21249: LD_VAR 0 2
21253: RET
// export function MC_Add ( side , units ) ; var base ; begin
21254: LD_INT 0
21256: PPUSH
21257: PPUSH
// base := mc_bases + 1 ;
21258: LD_ADDR_VAR 0 4
21262: PUSH
21263: LD_EXP 74
21267: PUSH
21268: LD_INT 1
21270: PLUS
21271: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
21272: LD_ADDR_EXP 100
21276: PUSH
21277: LD_EXP 100
21281: PPUSH
21282: LD_VAR 0 4
21286: PPUSH
21287: LD_VAR 0 1
21291: PPUSH
21292: CALL_OW 1
21296: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
21297: LD_ADDR_EXP 74
21301: PUSH
21302: LD_EXP 74
21306: PPUSH
21307: LD_VAR 0 4
21311: PPUSH
21312: LD_VAR 0 2
21316: PPUSH
21317: CALL_OW 1
21321: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
21322: LD_ADDR_EXP 75
21326: PUSH
21327: LD_EXP 75
21331: PPUSH
21332: LD_VAR 0 4
21336: PPUSH
21337: EMPTY
21338: PPUSH
21339: CALL_OW 1
21343: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
21344: LD_ADDR_EXP 76
21348: PUSH
21349: LD_EXP 76
21353: PPUSH
21354: LD_VAR 0 4
21358: PPUSH
21359: EMPTY
21360: PPUSH
21361: CALL_OW 1
21365: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
21366: LD_ADDR_EXP 77
21370: PUSH
21371: LD_EXP 77
21375: PPUSH
21376: LD_VAR 0 4
21380: PPUSH
21381: EMPTY
21382: PPUSH
21383: CALL_OW 1
21387: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
21388: LD_ADDR_EXP 78
21392: PUSH
21393: LD_EXP 78
21397: PPUSH
21398: LD_VAR 0 4
21402: PPUSH
21403: EMPTY
21404: PPUSH
21405: CALL_OW 1
21409: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
21410: LD_ADDR_EXP 79
21414: PUSH
21415: LD_EXP 79
21419: PPUSH
21420: LD_VAR 0 4
21424: PPUSH
21425: EMPTY
21426: PPUSH
21427: CALL_OW 1
21431: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
21432: LD_ADDR_EXP 80
21436: PUSH
21437: LD_EXP 80
21441: PPUSH
21442: LD_VAR 0 4
21446: PPUSH
21447: EMPTY
21448: PPUSH
21449: CALL_OW 1
21453: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
21454: LD_ADDR_EXP 81
21458: PUSH
21459: LD_EXP 81
21463: PPUSH
21464: LD_VAR 0 4
21468: PPUSH
21469: EMPTY
21470: PPUSH
21471: CALL_OW 1
21475: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
21476: LD_ADDR_EXP 82
21480: PUSH
21481: LD_EXP 82
21485: PPUSH
21486: LD_VAR 0 4
21490: PPUSH
21491: EMPTY
21492: PPUSH
21493: CALL_OW 1
21497: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
21498: LD_ADDR_EXP 83
21502: PUSH
21503: LD_EXP 83
21507: PPUSH
21508: LD_VAR 0 4
21512: PPUSH
21513: EMPTY
21514: PPUSH
21515: CALL_OW 1
21519: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
21520: LD_ADDR_EXP 84
21524: PUSH
21525: LD_EXP 84
21529: PPUSH
21530: LD_VAR 0 4
21534: PPUSH
21535: EMPTY
21536: PPUSH
21537: CALL_OW 1
21541: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
21542: LD_ADDR_EXP 85
21546: PUSH
21547: LD_EXP 85
21551: PPUSH
21552: LD_VAR 0 4
21556: PPUSH
21557: LD_INT 0
21559: PPUSH
21560: CALL_OW 1
21564: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21565: LD_ADDR_EXP 86
21569: PUSH
21570: LD_EXP 86
21574: PPUSH
21575: LD_VAR 0 4
21579: PPUSH
21580: EMPTY
21581: PPUSH
21582: CALL_OW 1
21586: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21587: LD_ADDR_EXP 87
21591: PUSH
21592: LD_EXP 87
21596: PPUSH
21597: LD_VAR 0 4
21601: PPUSH
21602: EMPTY
21603: PPUSH
21604: CALL_OW 1
21608: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
21609: LD_ADDR_EXP 88
21613: PUSH
21614: LD_EXP 88
21618: PPUSH
21619: LD_VAR 0 4
21623: PPUSH
21624: EMPTY
21625: PPUSH
21626: CALL_OW 1
21630: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
21631: LD_ADDR_EXP 89
21635: PUSH
21636: LD_EXP 89
21640: PPUSH
21641: LD_VAR 0 4
21645: PPUSH
21646: EMPTY
21647: PPUSH
21648: CALL_OW 1
21652: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
21653: LD_ADDR_EXP 90
21657: PUSH
21658: LD_EXP 90
21662: PPUSH
21663: LD_VAR 0 4
21667: PPUSH
21668: EMPTY
21669: PPUSH
21670: CALL_OW 1
21674: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
21675: LD_ADDR_EXP 91
21679: PUSH
21680: LD_EXP 91
21684: PPUSH
21685: LD_VAR 0 4
21689: PPUSH
21690: EMPTY
21691: PPUSH
21692: CALL_OW 1
21696: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
21697: LD_ADDR_EXP 92
21701: PUSH
21702: LD_EXP 92
21706: PPUSH
21707: LD_VAR 0 4
21711: PPUSH
21712: EMPTY
21713: PPUSH
21714: CALL_OW 1
21718: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
21719: LD_ADDR_EXP 93
21723: PUSH
21724: LD_EXP 93
21728: PPUSH
21729: LD_VAR 0 4
21733: PPUSH
21734: EMPTY
21735: PPUSH
21736: CALL_OW 1
21740: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
21741: LD_ADDR_EXP 94
21745: PUSH
21746: LD_EXP 94
21750: PPUSH
21751: LD_VAR 0 4
21755: PPUSH
21756: EMPTY
21757: PPUSH
21758: CALL_OW 1
21762: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
21763: LD_ADDR_EXP 95
21767: PUSH
21768: LD_EXP 95
21772: PPUSH
21773: LD_VAR 0 4
21777: PPUSH
21778: EMPTY
21779: PPUSH
21780: CALL_OW 1
21784: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
21785: LD_ADDR_EXP 96
21789: PUSH
21790: LD_EXP 96
21794: PPUSH
21795: LD_VAR 0 4
21799: PPUSH
21800: EMPTY
21801: PPUSH
21802: CALL_OW 1
21806: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
21807: LD_ADDR_EXP 97
21811: PUSH
21812: LD_EXP 97
21816: PPUSH
21817: LD_VAR 0 4
21821: PPUSH
21822: EMPTY
21823: PPUSH
21824: CALL_OW 1
21828: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
21829: LD_ADDR_EXP 98
21833: PUSH
21834: LD_EXP 98
21838: PPUSH
21839: LD_VAR 0 4
21843: PPUSH
21844: EMPTY
21845: PPUSH
21846: CALL_OW 1
21850: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
21851: LD_ADDR_EXP 99
21855: PUSH
21856: LD_EXP 99
21860: PPUSH
21861: LD_VAR 0 4
21865: PPUSH
21866: EMPTY
21867: PPUSH
21868: CALL_OW 1
21872: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
21873: LD_ADDR_EXP 101
21877: PUSH
21878: LD_EXP 101
21882: PPUSH
21883: LD_VAR 0 4
21887: PPUSH
21888: EMPTY
21889: PPUSH
21890: CALL_OW 1
21894: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
21895: LD_ADDR_EXP 103
21899: PUSH
21900: LD_EXP 103
21904: PPUSH
21905: LD_VAR 0 4
21909: PPUSH
21910: EMPTY
21911: PPUSH
21912: CALL_OW 1
21916: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
21917: LD_ADDR_EXP 104
21921: PUSH
21922: LD_EXP 104
21926: PPUSH
21927: LD_VAR 0 4
21931: PPUSH
21932: EMPTY
21933: PPUSH
21934: CALL_OW 1
21938: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
21939: LD_ADDR_EXP 105
21943: PUSH
21944: LD_EXP 105
21948: PPUSH
21949: LD_VAR 0 4
21953: PPUSH
21954: EMPTY
21955: PPUSH
21956: CALL_OW 1
21960: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
21961: LD_ADDR_EXP 106
21965: PUSH
21966: LD_EXP 106
21970: PPUSH
21971: LD_VAR 0 4
21975: PPUSH
21976: EMPTY
21977: PPUSH
21978: CALL_OW 1
21982: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
21983: LD_ADDR_EXP 107
21987: PUSH
21988: LD_EXP 107
21992: PPUSH
21993: LD_VAR 0 4
21997: PPUSH
21998: EMPTY
21999: PPUSH
22000: CALL_OW 1
22004: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
22005: LD_ADDR_EXP 108
22009: PUSH
22010: LD_EXP 108
22014: PPUSH
22015: LD_VAR 0 4
22019: PPUSH
22020: EMPTY
22021: PPUSH
22022: CALL_OW 1
22026: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
22027: LD_ADDR_EXP 109
22031: PUSH
22032: LD_EXP 109
22036: PPUSH
22037: LD_VAR 0 4
22041: PPUSH
22042: EMPTY
22043: PPUSH
22044: CALL_OW 1
22048: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
22049: LD_ADDR_EXP 110
22053: PUSH
22054: LD_EXP 110
22058: PPUSH
22059: LD_VAR 0 4
22063: PPUSH
22064: EMPTY
22065: PPUSH
22066: CALL_OW 1
22070: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
22071: LD_ADDR_EXP 111
22075: PUSH
22076: LD_EXP 111
22080: PPUSH
22081: LD_VAR 0 4
22085: PPUSH
22086: EMPTY
22087: PPUSH
22088: CALL_OW 1
22092: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
22093: LD_ADDR_EXP 112
22097: PUSH
22098: LD_EXP 112
22102: PPUSH
22103: LD_VAR 0 4
22107: PPUSH
22108: EMPTY
22109: PPUSH
22110: CALL_OW 1
22114: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
22115: LD_ADDR_EXP 113
22119: PUSH
22120: LD_EXP 113
22124: PPUSH
22125: LD_VAR 0 4
22129: PPUSH
22130: EMPTY
22131: PPUSH
22132: CALL_OW 1
22136: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
22137: LD_ADDR_EXP 114
22141: PUSH
22142: LD_EXP 114
22146: PPUSH
22147: LD_VAR 0 4
22151: PPUSH
22152: EMPTY
22153: PPUSH
22154: CALL_OW 1
22158: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
22159: LD_ADDR_EXP 115
22163: PUSH
22164: LD_EXP 115
22168: PPUSH
22169: LD_VAR 0 4
22173: PPUSH
22174: EMPTY
22175: PPUSH
22176: CALL_OW 1
22180: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
22181: LD_ADDR_EXP 116
22185: PUSH
22186: LD_EXP 116
22190: PPUSH
22191: LD_VAR 0 4
22195: PPUSH
22196: LD_INT 0
22198: PPUSH
22199: CALL_OW 1
22203: ST_TO_ADDR
// result := base ;
22204: LD_ADDR_VAR 0 3
22208: PUSH
22209: LD_VAR 0 4
22213: ST_TO_ADDR
// end ;
22214: LD_VAR 0 3
22218: RET
// export function MC_Start ( ) ; var i ; begin
22219: LD_INT 0
22221: PPUSH
22222: PPUSH
// for i = 1 to mc_bases do
22223: LD_ADDR_VAR 0 2
22227: PUSH
22228: DOUBLE
22229: LD_INT 1
22231: DEC
22232: ST_TO_ADDR
22233: LD_EXP 74
22237: PUSH
22238: FOR_TO
22239: IFFALSE 23316
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
22241: LD_ADDR_EXP 74
22245: PUSH
22246: LD_EXP 74
22250: PPUSH
22251: LD_VAR 0 2
22255: PPUSH
22256: LD_EXP 74
22260: PUSH
22261: LD_VAR 0 2
22265: ARRAY
22266: PUSH
22267: LD_INT 0
22269: DIFF
22270: PPUSH
22271: CALL_OW 1
22275: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
22276: LD_ADDR_EXP 75
22280: PUSH
22281: LD_EXP 75
22285: PPUSH
22286: LD_VAR 0 2
22290: PPUSH
22291: EMPTY
22292: PPUSH
22293: CALL_OW 1
22297: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
22298: LD_ADDR_EXP 76
22302: PUSH
22303: LD_EXP 76
22307: PPUSH
22308: LD_VAR 0 2
22312: PPUSH
22313: EMPTY
22314: PPUSH
22315: CALL_OW 1
22319: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
22320: LD_ADDR_EXP 77
22324: PUSH
22325: LD_EXP 77
22329: PPUSH
22330: LD_VAR 0 2
22334: PPUSH
22335: EMPTY
22336: PPUSH
22337: CALL_OW 1
22341: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
22342: LD_ADDR_EXP 78
22346: PUSH
22347: LD_EXP 78
22351: PPUSH
22352: LD_VAR 0 2
22356: PPUSH
22357: EMPTY
22358: PUSH
22359: EMPTY
22360: PUSH
22361: EMPTY
22362: LIST
22363: LIST
22364: PPUSH
22365: CALL_OW 1
22369: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
22370: LD_ADDR_EXP 79
22374: PUSH
22375: LD_EXP 79
22379: PPUSH
22380: LD_VAR 0 2
22384: PPUSH
22385: EMPTY
22386: PPUSH
22387: CALL_OW 1
22391: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
22392: LD_ADDR_EXP 106
22396: PUSH
22397: LD_EXP 106
22401: PPUSH
22402: LD_VAR 0 2
22406: PPUSH
22407: EMPTY
22408: PPUSH
22409: CALL_OW 1
22413: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
22414: LD_ADDR_EXP 80
22418: PUSH
22419: LD_EXP 80
22423: PPUSH
22424: LD_VAR 0 2
22428: PPUSH
22429: EMPTY
22430: PPUSH
22431: CALL_OW 1
22435: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
22436: LD_ADDR_EXP 81
22440: PUSH
22441: LD_EXP 81
22445: PPUSH
22446: LD_VAR 0 2
22450: PPUSH
22451: EMPTY
22452: PPUSH
22453: CALL_OW 1
22457: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
22458: LD_ADDR_EXP 82
22462: PUSH
22463: LD_EXP 82
22467: PPUSH
22468: LD_VAR 0 2
22472: PPUSH
22473: LD_EXP 74
22477: PUSH
22478: LD_VAR 0 2
22482: ARRAY
22483: PPUSH
22484: LD_INT 2
22486: PUSH
22487: LD_INT 30
22489: PUSH
22490: LD_INT 32
22492: PUSH
22493: EMPTY
22494: LIST
22495: LIST
22496: PUSH
22497: LD_INT 30
22499: PUSH
22500: LD_INT 33
22502: PUSH
22503: EMPTY
22504: LIST
22505: LIST
22506: PUSH
22507: EMPTY
22508: LIST
22509: LIST
22510: LIST
22511: PPUSH
22512: CALL_OW 72
22516: PPUSH
22517: CALL_OW 1
22521: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
22522: LD_ADDR_EXP 83
22526: PUSH
22527: LD_EXP 83
22531: PPUSH
22532: LD_VAR 0 2
22536: PPUSH
22537: LD_EXP 74
22541: PUSH
22542: LD_VAR 0 2
22546: ARRAY
22547: PPUSH
22548: LD_INT 2
22550: PUSH
22551: LD_INT 30
22553: PUSH
22554: LD_INT 32
22556: PUSH
22557: EMPTY
22558: LIST
22559: LIST
22560: PUSH
22561: LD_INT 30
22563: PUSH
22564: LD_INT 31
22566: PUSH
22567: EMPTY
22568: LIST
22569: LIST
22570: PUSH
22571: EMPTY
22572: LIST
22573: LIST
22574: LIST
22575: PUSH
22576: LD_INT 58
22578: PUSH
22579: EMPTY
22580: LIST
22581: PUSH
22582: EMPTY
22583: LIST
22584: LIST
22585: PPUSH
22586: CALL_OW 72
22590: PPUSH
22591: CALL_OW 1
22595: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
22596: LD_ADDR_EXP 84
22600: PUSH
22601: LD_EXP 84
22605: PPUSH
22606: LD_VAR 0 2
22610: PPUSH
22611: EMPTY
22612: PPUSH
22613: CALL_OW 1
22617: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
22618: LD_ADDR_EXP 88
22622: PUSH
22623: LD_EXP 88
22627: PPUSH
22628: LD_VAR 0 2
22632: PPUSH
22633: EMPTY
22634: PPUSH
22635: CALL_OW 1
22639: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
22640: LD_ADDR_EXP 87
22644: PUSH
22645: LD_EXP 87
22649: PPUSH
22650: LD_VAR 0 2
22654: PPUSH
22655: EMPTY
22656: PPUSH
22657: CALL_OW 1
22661: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
22662: LD_ADDR_EXP 89
22666: PUSH
22667: LD_EXP 89
22671: PPUSH
22672: LD_VAR 0 2
22676: PPUSH
22677: EMPTY
22678: PPUSH
22679: CALL_OW 1
22683: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
22684: LD_ADDR_EXP 90
22688: PUSH
22689: LD_EXP 90
22693: PPUSH
22694: LD_VAR 0 2
22698: PPUSH
22699: EMPTY
22700: PPUSH
22701: CALL_OW 1
22705: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
22706: LD_ADDR_EXP 91
22710: PUSH
22711: LD_EXP 91
22715: PPUSH
22716: LD_VAR 0 2
22720: PPUSH
22721: EMPTY
22722: PPUSH
22723: CALL_OW 1
22727: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
22728: LD_ADDR_EXP 92
22732: PUSH
22733: LD_EXP 92
22737: PPUSH
22738: LD_VAR 0 2
22742: PPUSH
22743: EMPTY
22744: PPUSH
22745: CALL_OW 1
22749: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
22750: LD_ADDR_EXP 93
22754: PUSH
22755: LD_EXP 93
22759: PPUSH
22760: LD_VAR 0 2
22764: PPUSH
22765: EMPTY
22766: PPUSH
22767: CALL_OW 1
22771: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
22772: LD_ADDR_EXP 94
22776: PUSH
22777: LD_EXP 94
22781: PPUSH
22782: LD_VAR 0 2
22786: PPUSH
22787: EMPTY
22788: PPUSH
22789: CALL_OW 1
22793: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
22794: LD_ADDR_EXP 95
22798: PUSH
22799: LD_EXP 95
22803: PPUSH
22804: LD_VAR 0 2
22808: PPUSH
22809: EMPTY
22810: PPUSH
22811: CALL_OW 1
22815: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
22816: LD_ADDR_EXP 96
22820: PUSH
22821: LD_EXP 96
22825: PPUSH
22826: LD_VAR 0 2
22830: PPUSH
22831: EMPTY
22832: PPUSH
22833: CALL_OW 1
22837: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
22838: LD_ADDR_EXP 85
22842: PUSH
22843: LD_EXP 85
22847: PPUSH
22848: LD_VAR 0 2
22852: PPUSH
22853: LD_INT 0
22855: PPUSH
22856: CALL_OW 1
22860: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
22861: LD_ADDR_EXP 98
22865: PUSH
22866: LD_EXP 98
22870: PPUSH
22871: LD_VAR 0 2
22875: PPUSH
22876: LD_INT 0
22878: PPUSH
22879: CALL_OW 1
22883: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
22884: LD_ADDR_EXP 86
22888: PUSH
22889: LD_EXP 86
22893: PPUSH
22894: LD_VAR 0 2
22898: PPUSH
22899: EMPTY
22900: PPUSH
22901: CALL_OW 1
22905: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
22906: LD_ADDR_EXP 97
22910: PUSH
22911: LD_EXP 97
22915: PPUSH
22916: LD_VAR 0 2
22920: PPUSH
22921: LD_INT 0
22923: PPUSH
22924: CALL_OW 1
22928: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
22929: LD_ADDR_EXP 99
22933: PUSH
22934: LD_EXP 99
22938: PPUSH
22939: LD_VAR 0 2
22943: PPUSH
22944: EMPTY
22945: PPUSH
22946: CALL_OW 1
22950: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
22951: LD_ADDR_EXP 102
22955: PUSH
22956: LD_EXP 102
22960: PPUSH
22961: LD_VAR 0 2
22965: PPUSH
22966: LD_INT 0
22968: PPUSH
22969: CALL_OW 1
22973: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
22974: LD_ADDR_EXP 103
22978: PUSH
22979: LD_EXP 103
22983: PPUSH
22984: LD_VAR 0 2
22988: PPUSH
22989: EMPTY
22990: PPUSH
22991: CALL_OW 1
22995: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
22996: LD_ADDR_EXP 104
23000: PUSH
23001: LD_EXP 104
23005: PPUSH
23006: LD_VAR 0 2
23010: PPUSH
23011: EMPTY
23012: PPUSH
23013: CALL_OW 1
23017: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
23018: LD_ADDR_EXP 105
23022: PUSH
23023: LD_EXP 105
23027: PPUSH
23028: LD_VAR 0 2
23032: PPUSH
23033: EMPTY
23034: PPUSH
23035: CALL_OW 1
23039: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
23040: LD_ADDR_EXP 107
23044: PUSH
23045: LD_EXP 107
23049: PPUSH
23050: LD_VAR 0 2
23054: PPUSH
23055: LD_EXP 74
23059: PUSH
23060: LD_VAR 0 2
23064: ARRAY
23065: PPUSH
23066: LD_INT 2
23068: PUSH
23069: LD_INT 30
23071: PUSH
23072: LD_INT 6
23074: PUSH
23075: EMPTY
23076: LIST
23077: LIST
23078: PUSH
23079: LD_INT 30
23081: PUSH
23082: LD_INT 7
23084: PUSH
23085: EMPTY
23086: LIST
23087: LIST
23088: PUSH
23089: LD_INT 30
23091: PUSH
23092: LD_INT 8
23094: PUSH
23095: EMPTY
23096: LIST
23097: LIST
23098: PUSH
23099: EMPTY
23100: LIST
23101: LIST
23102: LIST
23103: LIST
23104: PPUSH
23105: CALL_OW 72
23109: PPUSH
23110: CALL_OW 1
23114: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
23115: LD_ADDR_EXP 108
23119: PUSH
23120: LD_EXP 108
23124: PPUSH
23125: LD_VAR 0 2
23129: PPUSH
23130: EMPTY
23131: PPUSH
23132: CALL_OW 1
23136: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
23137: LD_ADDR_EXP 109
23141: PUSH
23142: LD_EXP 109
23146: PPUSH
23147: LD_VAR 0 2
23151: PPUSH
23152: EMPTY
23153: PPUSH
23154: CALL_OW 1
23158: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
23159: LD_ADDR_EXP 110
23163: PUSH
23164: LD_EXP 110
23168: PPUSH
23169: LD_VAR 0 2
23173: PPUSH
23174: EMPTY
23175: PPUSH
23176: CALL_OW 1
23180: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
23181: LD_ADDR_EXP 111
23185: PUSH
23186: LD_EXP 111
23190: PPUSH
23191: LD_VAR 0 2
23195: PPUSH
23196: EMPTY
23197: PPUSH
23198: CALL_OW 1
23202: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
23203: LD_ADDR_EXP 112
23207: PUSH
23208: LD_EXP 112
23212: PPUSH
23213: LD_VAR 0 2
23217: PPUSH
23218: EMPTY
23219: PPUSH
23220: CALL_OW 1
23224: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
23225: LD_ADDR_EXP 113
23229: PUSH
23230: LD_EXP 113
23234: PPUSH
23235: LD_VAR 0 2
23239: PPUSH
23240: EMPTY
23241: PPUSH
23242: CALL_OW 1
23246: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
23247: LD_ADDR_EXP 114
23251: PUSH
23252: LD_EXP 114
23256: PPUSH
23257: LD_VAR 0 2
23261: PPUSH
23262: EMPTY
23263: PPUSH
23264: CALL_OW 1
23268: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
23269: LD_ADDR_EXP 115
23273: PUSH
23274: LD_EXP 115
23278: PPUSH
23279: LD_VAR 0 2
23283: PPUSH
23284: EMPTY
23285: PPUSH
23286: CALL_OW 1
23290: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
23291: LD_ADDR_EXP 116
23295: PUSH
23296: LD_EXP 116
23300: PPUSH
23301: LD_VAR 0 2
23305: PPUSH
23306: LD_INT 0
23308: PPUSH
23309: CALL_OW 1
23313: ST_TO_ADDR
// end ;
23314: GO 22238
23316: POP
23317: POP
// MC_InitSides ( ) ;
23318: CALL 23604 0 0
// MC_InitResearch ( ) ;
23322: CALL 23343 0 0
// CustomInitMacro ( ) ;
23326: CALL 173 0 0
// skirmish := true ;
23330: LD_ADDR_EXP 72
23334: PUSH
23335: LD_INT 1
23337: ST_TO_ADDR
// end ;
23338: LD_VAR 0 1
23342: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
23343: LD_INT 0
23345: PPUSH
23346: PPUSH
23347: PPUSH
23348: PPUSH
23349: PPUSH
23350: PPUSH
// if not mc_bases then
23351: LD_EXP 74
23355: NOT
23356: IFFALSE 23360
// exit ;
23358: GO 23599
// for i = 1 to 8 do
23360: LD_ADDR_VAR 0 2
23364: PUSH
23365: DOUBLE
23366: LD_INT 1
23368: DEC
23369: ST_TO_ADDR
23370: LD_INT 8
23372: PUSH
23373: FOR_TO
23374: IFFALSE 23400
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
23376: LD_ADDR_EXP 101
23380: PUSH
23381: LD_EXP 101
23385: PPUSH
23386: LD_VAR 0 2
23390: PPUSH
23391: EMPTY
23392: PPUSH
23393: CALL_OW 1
23397: ST_TO_ADDR
23398: GO 23373
23400: POP
23401: POP
// tmp := [ ] ;
23402: LD_ADDR_VAR 0 5
23406: PUSH
23407: EMPTY
23408: ST_TO_ADDR
// for i = 1 to mc_sides do
23409: LD_ADDR_VAR 0 2
23413: PUSH
23414: DOUBLE
23415: LD_INT 1
23417: DEC
23418: ST_TO_ADDR
23419: LD_EXP 100
23423: PUSH
23424: FOR_TO
23425: IFFALSE 23483
// if not mc_sides [ i ] in tmp then
23427: LD_EXP 100
23431: PUSH
23432: LD_VAR 0 2
23436: ARRAY
23437: PUSH
23438: LD_VAR 0 5
23442: IN
23443: NOT
23444: IFFALSE 23481
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
23446: LD_ADDR_VAR 0 5
23450: PUSH
23451: LD_VAR 0 5
23455: PPUSH
23456: LD_VAR 0 5
23460: PUSH
23461: LD_INT 1
23463: PLUS
23464: PPUSH
23465: LD_EXP 100
23469: PUSH
23470: LD_VAR 0 2
23474: ARRAY
23475: PPUSH
23476: CALL_OW 2
23480: ST_TO_ADDR
23481: GO 23424
23483: POP
23484: POP
// if not tmp then
23485: LD_VAR 0 5
23489: NOT
23490: IFFALSE 23494
// exit ;
23492: GO 23599
// for j in tmp do
23494: LD_ADDR_VAR 0 3
23498: PUSH
23499: LD_VAR 0 5
23503: PUSH
23504: FOR_IN
23505: IFFALSE 23597
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
23507: LD_ADDR_VAR 0 6
23511: PUSH
23512: LD_INT 22
23514: PUSH
23515: LD_VAR 0 3
23519: PUSH
23520: EMPTY
23521: LIST
23522: LIST
23523: PPUSH
23524: CALL_OW 69
23528: ST_TO_ADDR
// if not un then
23529: LD_VAR 0 6
23533: NOT
23534: IFFALSE 23538
// continue ;
23536: GO 23504
// nation := GetNation ( un [ 1 ] ) ;
23538: LD_ADDR_VAR 0 4
23542: PUSH
23543: LD_VAR 0 6
23547: PUSH
23548: LD_INT 1
23550: ARRAY
23551: PPUSH
23552: CALL_OW 248
23556: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
23557: LD_ADDR_EXP 101
23561: PUSH
23562: LD_EXP 101
23566: PPUSH
23567: LD_VAR 0 3
23571: PPUSH
23572: LD_VAR 0 3
23576: PPUSH
23577: LD_VAR 0 4
23581: PPUSH
23582: LD_INT 1
23584: PPUSH
23585: CALL 50313 0 3
23589: PPUSH
23590: CALL_OW 1
23594: ST_TO_ADDR
// end ;
23595: GO 23504
23597: POP
23598: POP
// end ;
23599: LD_VAR 0 1
23603: RET
// export function MC_InitSides ( ) ; var i ; begin
23604: LD_INT 0
23606: PPUSH
23607: PPUSH
// if not mc_bases then
23608: LD_EXP 74
23612: NOT
23613: IFFALSE 23617
// exit ;
23615: GO 23691
// for i = 1 to mc_bases do
23617: LD_ADDR_VAR 0 2
23621: PUSH
23622: DOUBLE
23623: LD_INT 1
23625: DEC
23626: ST_TO_ADDR
23627: LD_EXP 74
23631: PUSH
23632: FOR_TO
23633: IFFALSE 23689
// if mc_bases [ i ] then
23635: LD_EXP 74
23639: PUSH
23640: LD_VAR 0 2
23644: ARRAY
23645: IFFALSE 23687
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
23647: LD_ADDR_EXP 100
23651: PUSH
23652: LD_EXP 100
23656: PPUSH
23657: LD_VAR 0 2
23661: PPUSH
23662: LD_EXP 74
23666: PUSH
23667: LD_VAR 0 2
23671: ARRAY
23672: PUSH
23673: LD_INT 1
23675: ARRAY
23676: PPUSH
23677: CALL_OW 255
23681: PPUSH
23682: CALL_OW 1
23686: ST_TO_ADDR
23687: GO 23632
23689: POP
23690: POP
// end ;
23691: LD_VAR 0 1
23695: RET
// every 0 0$01 trigger skirmish do
23696: LD_EXP 72
23700: IFFALSE 23854
23702: GO 23704
23704: DISABLE
// begin enable ;
23705: ENABLE
// MC_CheckBuildings ( ) ;
23706: CALL 28352 0 0
// MC_CheckPeopleLife ( ) ;
23710: CALL 28477 0 0
// RaiseSailEvent ( 100 ) ;
23714: LD_INT 100
23716: PPUSH
23717: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
23721: LD_INT 103
23723: PPUSH
23724: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
23728: LD_INT 104
23730: PPUSH
23731: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
23735: LD_INT 105
23737: PPUSH
23738: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
23742: LD_INT 106
23744: PPUSH
23745: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
23749: LD_INT 107
23751: PPUSH
23752: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
23756: LD_INT 108
23758: PPUSH
23759: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
23763: LD_INT 109
23765: PPUSH
23766: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
23770: LD_INT 110
23772: PPUSH
23773: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
23777: LD_INT 111
23779: PPUSH
23780: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
23784: LD_INT 112
23786: PPUSH
23787: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
23791: LD_INT 113
23793: PPUSH
23794: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
23798: LD_INT 120
23800: PPUSH
23801: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
23805: LD_INT 121
23807: PPUSH
23808: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
23812: LD_INT 122
23814: PPUSH
23815: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
23819: LD_INT 123
23821: PPUSH
23822: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
23826: LD_INT 124
23828: PPUSH
23829: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
23833: LD_INT 125
23835: PPUSH
23836: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
23840: LD_INT 126
23842: PPUSH
23843: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
23847: LD_INT 200
23849: PPUSH
23850: CALL_OW 427
// end ;
23854: END
// on SailEvent ( event ) do begin if event < 100 then
23855: LD_VAR 0 1
23859: PUSH
23860: LD_INT 100
23862: LESS
23863: IFFALSE 23874
// CustomEvent ( event ) ;
23865: LD_VAR 0 1
23869: PPUSH
23870: CALL 10195 0 1
// if event = 100 then
23874: LD_VAR 0 1
23878: PUSH
23879: LD_INT 100
23881: EQUAL
23882: IFFALSE 23888
// MC_ClassManager ( ) ;
23884: CALL 24280 0 0
// if event = 101 then
23888: LD_VAR 0 1
23892: PUSH
23893: LD_INT 101
23895: EQUAL
23896: IFFALSE 23902
// MC_RepairBuildings ( ) ;
23898: CALL 29073 0 0
// if event = 102 then
23902: LD_VAR 0 1
23906: PUSH
23907: LD_INT 102
23909: EQUAL
23910: IFFALSE 23916
// MC_Heal ( ) ;
23912: CALL 29805 0 0
// if event = 103 then
23916: LD_VAR 0 1
23920: PUSH
23921: LD_INT 103
23923: EQUAL
23924: IFFALSE 23930
// MC_Build ( ) ;
23926: CALL 30227 0 0
// if event = 104 then
23930: LD_VAR 0 1
23934: PUSH
23935: LD_INT 104
23937: EQUAL
23938: IFFALSE 23944
// MC_TurretWeapon ( ) ;
23940: CALL 31840 0 0
// if event = 105 then
23944: LD_VAR 0 1
23948: PUSH
23949: LD_INT 105
23951: EQUAL
23952: IFFALSE 23958
// MC_BuildUpgrade ( ) ;
23954: CALL 31391 0 0
// if event = 106 then
23958: LD_VAR 0 1
23962: PUSH
23963: LD_INT 106
23965: EQUAL
23966: IFFALSE 23972
// MC_PlantMines ( ) ;
23968: CALL 32270 0 0
// if event = 107 then
23972: LD_VAR 0 1
23976: PUSH
23977: LD_INT 107
23979: EQUAL
23980: IFFALSE 23986
// MC_CollectCrates ( ) ;
23982: CALL 33304 0 0
// if event = 108 then
23986: LD_VAR 0 1
23990: PUSH
23991: LD_INT 108
23993: EQUAL
23994: IFFALSE 24000
// MC_LinkRemoteControl ( ) ;
23996: CALL 35080 0 0
// if event = 109 then
24000: LD_VAR 0 1
24004: PUSH
24005: LD_INT 109
24007: EQUAL
24008: IFFALSE 24014
// MC_ProduceVehicle ( ) ;
24010: CALL 35261 0 0
// if event = 110 then
24014: LD_VAR 0 1
24018: PUSH
24019: LD_INT 110
24021: EQUAL
24022: IFFALSE 24028
// MC_SendAttack ( ) ;
24024: CALL 35727 0 0
// if event = 111 then
24028: LD_VAR 0 1
24032: PUSH
24033: LD_INT 111
24035: EQUAL
24036: IFFALSE 24042
// MC_Defend ( ) ;
24038: CALL 35835 0 0
// if event = 112 then
24042: LD_VAR 0 1
24046: PUSH
24047: LD_INT 112
24049: EQUAL
24050: IFFALSE 24056
// MC_Research ( ) ;
24052: CALL 36440 0 0
// if event = 113 then
24056: LD_VAR 0 1
24060: PUSH
24061: LD_INT 113
24063: EQUAL
24064: IFFALSE 24070
// MC_MinesTrigger ( ) ;
24066: CALL 37554 0 0
// if event = 120 then
24070: LD_VAR 0 1
24074: PUSH
24075: LD_INT 120
24077: EQUAL
24078: IFFALSE 24084
// MC_RepairVehicle ( ) ;
24080: CALL 37653 0 0
// if event = 121 then
24084: LD_VAR 0 1
24088: PUSH
24089: LD_INT 121
24091: EQUAL
24092: IFFALSE 24098
// MC_TameApe ( ) ;
24094: CALL 38383 0 0
// if event = 122 then
24098: LD_VAR 0 1
24102: PUSH
24103: LD_INT 122
24105: EQUAL
24106: IFFALSE 24112
// MC_ChangeApeClass ( ) ;
24108: CALL 39212 0 0
// if event = 123 then
24112: LD_VAR 0 1
24116: PUSH
24117: LD_INT 123
24119: EQUAL
24120: IFFALSE 24126
// MC_Bazooka ( ) ;
24122: CALL 39862 0 0
// if event = 124 then
24126: LD_VAR 0 1
24130: PUSH
24131: LD_INT 124
24133: EQUAL
24134: IFFALSE 24140
// MC_TeleportExit ( ) ;
24136: CALL 40060 0 0
// if event = 125 then
24140: LD_VAR 0 1
24144: PUSH
24145: LD_INT 125
24147: EQUAL
24148: IFFALSE 24154
// MC_Deposits ( ) ;
24150: CALL 40707 0 0
// if event = 126 then
24154: LD_VAR 0 1
24158: PUSH
24159: LD_INT 126
24161: EQUAL
24162: IFFALSE 24168
// MC_RemoteDriver ( ) ;
24164: CALL 41332 0 0
// if event = 200 then
24168: LD_VAR 0 1
24172: PUSH
24173: LD_INT 200
24175: EQUAL
24176: IFFALSE 24182
// MC_Idle ( ) ;
24178: CALL 43281 0 0
// end ;
24182: PPOPN 1
24184: END
// export function MC_Reset ( base , tag ) ; var i ; begin
24185: LD_INT 0
24187: PPUSH
24188: PPUSH
// if not mc_bases [ base ] or not tag then
24189: LD_EXP 74
24193: PUSH
24194: LD_VAR 0 1
24198: ARRAY
24199: NOT
24200: PUSH
24201: LD_VAR 0 2
24205: NOT
24206: OR
24207: IFFALSE 24211
// exit ;
24209: GO 24275
// for i in mc_bases [ base ] union mc_ape [ base ] do
24211: LD_ADDR_VAR 0 4
24215: PUSH
24216: LD_EXP 74
24220: PUSH
24221: LD_VAR 0 1
24225: ARRAY
24226: PUSH
24227: LD_EXP 103
24231: PUSH
24232: LD_VAR 0 1
24236: ARRAY
24237: UNION
24238: PUSH
24239: FOR_IN
24240: IFFALSE 24273
// if GetTag ( i ) = tag then
24242: LD_VAR 0 4
24246: PPUSH
24247: CALL_OW 110
24251: PUSH
24252: LD_VAR 0 2
24256: EQUAL
24257: IFFALSE 24271
// SetTag ( i , 0 ) ;
24259: LD_VAR 0 4
24263: PPUSH
24264: LD_INT 0
24266: PPUSH
24267: CALL_OW 109
24271: GO 24239
24273: POP
24274: POP
// end ;
24275: LD_VAR 0 3
24279: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
24280: LD_INT 0
24282: PPUSH
24283: PPUSH
24284: PPUSH
24285: PPUSH
24286: PPUSH
24287: PPUSH
24288: PPUSH
24289: PPUSH
// if not mc_bases then
24290: LD_EXP 74
24294: NOT
24295: IFFALSE 24299
// exit ;
24297: GO 24757
// for i = 1 to mc_bases do
24299: LD_ADDR_VAR 0 2
24303: PUSH
24304: DOUBLE
24305: LD_INT 1
24307: DEC
24308: ST_TO_ADDR
24309: LD_EXP 74
24313: PUSH
24314: FOR_TO
24315: IFFALSE 24755
// begin tmp := MC_ClassCheckReq ( i ) ;
24317: LD_ADDR_VAR 0 4
24321: PUSH
24322: LD_VAR 0 2
24326: PPUSH
24327: CALL 24762 0 1
24331: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
24332: LD_ADDR_EXP 115
24336: PUSH
24337: LD_EXP 115
24341: PPUSH
24342: LD_VAR 0 2
24346: PPUSH
24347: LD_VAR 0 4
24351: PPUSH
24352: CALL_OW 1
24356: ST_TO_ADDR
// if not tmp then
24357: LD_VAR 0 4
24361: NOT
24362: IFFALSE 24366
// continue ;
24364: GO 24314
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
24366: LD_ADDR_VAR 0 6
24370: PUSH
24371: LD_EXP 74
24375: PUSH
24376: LD_VAR 0 2
24380: ARRAY
24381: PPUSH
24382: LD_INT 2
24384: PUSH
24385: LD_INT 30
24387: PUSH
24388: LD_INT 4
24390: PUSH
24391: EMPTY
24392: LIST
24393: LIST
24394: PUSH
24395: LD_INT 30
24397: PUSH
24398: LD_INT 5
24400: PUSH
24401: EMPTY
24402: LIST
24403: LIST
24404: PUSH
24405: EMPTY
24406: LIST
24407: LIST
24408: LIST
24409: PPUSH
24410: CALL_OW 72
24414: PUSH
24415: LD_EXP 74
24419: PUSH
24420: LD_VAR 0 2
24424: ARRAY
24425: PPUSH
24426: LD_INT 2
24428: PUSH
24429: LD_INT 30
24431: PUSH
24432: LD_INT 0
24434: PUSH
24435: EMPTY
24436: LIST
24437: LIST
24438: PUSH
24439: LD_INT 30
24441: PUSH
24442: LD_INT 1
24444: PUSH
24445: EMPTY
24446: LIST
24447: LIST
24448: PUSH
24449: EMPTY
24450: LIST
24451: LIST
24452: LIST
24453: PPUSH
24454: CALL_OW 72
24458: PUSH
24459: LD_EXP 74
24463: PUSH
24464: LD_VAR 0 2
24468: ARRAY
24469: PPUSH
24470: LD_INT 30
24472: PUSH
24473: LD_INT 3
24475: PUSH
24476: EMPTY
24477: LIST
24478: LIST
24479: PPUSH
24480: CALL_OW 72
24484: PUSH
24485: LD_EXP 74
24489: PUSH
24490: LD_VAR 0 2
24494: ARRAY
24495: PPUSH
24496: LD_INT 2
24498: PUSH
24499: LD_INT 30
24501: PUSH
24502: LD_INT 6
24504: PUSH
24505: EMPTY
24506: LIST
24507: LIST
24508: PUSH
24509: LD_INT 30
24511: PUSH
24512: LD_INT 7
24514: PUSH
24515: EMPTY
24516: LIST
24517: LIST
24518: PUSH
24519: LD_INT 30
24521: PUSH
24522: LD_INT 8
24524: PUSH
24525: EMPTY
24526: LIST
24527: LIST
24528: PUSH
24529: EMPTY
24530: LIST
24531: LIST
24532: LIST
24533: LIST
24534: PPUSH
24535: CALL_OW 72
24539: PUSH
24540: EMPTY
24541: LIST
24542: LIST
24543: LIST
24544: LIST
24545: ST_TO_ADDR
// for j = 1 to 4 do
24546: LD_ADDR_VAR 0 3
24550: PUSH
24551: DOUBLE
24552: LD_INT 1
24554: DEC
24555: ST_TO_ADDR
24556: LD_INT 4
24558: PUSH
24559: FOR_TO
24560: IFFALSE 24751
// begin if not tmp [ j ] then
24562: LD_VAR 0 4
24566: PUSH
24567: LD_VAR 0 3
24571: ARRAY
24572: NOT
24573: IFFALSE 24577
// continue ;
24575: GO 24559
// for p in tmp [ j ] do
24577: LD_ADDR_VAR 0 5
24581: PUSH
24582: LD_VAR 0 4
24586: PUSH
24587: LD_VAR 0 3
24591: ARRAY
24592: PUSH
24593: FOR_IN
24594: IFFALSE 24747
// begin if not b [ j ] then
24596: LD_VAR 0 6
24600: PUSH
24601: LD_VAR 0 3
24605: ARRAY
24606: NOT
24607: IFFALSE 24611
// break ;
24609: GO 24747
// e := 0 ;
24611: LD_ADDR_VAR 0 7
24615: PUSH
24616: LD_INT 0
24618: ST_TO_ADDR
// for k in b [ j ] do
24619: LD_ADDR_VAR 0 8
24623: PUSH
24624: LD_VAR 0 6
24628: PUSH
24629: LD_VAR 0 3
24633: ARRAY
24634: PUSH
24635: FOR_IN
24636: IFFALSE 24663
// if IsNotFull ( k ) then
24638: LD_VAR 0 8
24642: PPUSH
24643: CALL 54753 0 1
24647: IFFALSE 24661
// begin e := k ;
24649: LD_ADDR_VAR 0 7
24653: PUSH
24654: LD_VAR 0 8
24658: ST_TO_ADDR
// break ;
24659: GO 24663
// end ;
24661: GO 24635
24663: POP
24664: POP
// if e and not UnitGoingToBuilding ( p , e ) then
24665: LD_VAR 0 7
24669: PUSH
24670: LD_VAR 0 5
24674: PPUSH
24675: LD_VAR 0 7
24679: PPUSH
24680: CALL 91872 0 2
24684: NOT
24685: AND
24686: IFFALSE 24745
// begin if IsInUnit ( p ) then
24688: LD_VAR 0 5
24692: PPUSH
24693: CALL_OW 310
24697: IFFALSE 24708
// ComExitBuilding ( p ) ;
24699: LD_VAR 0 5
24703: PPUSH
24704: CALL_OW 122
// ComEnterUnit ( p , e ) ;
24708: LD_VAR 0 5
24712: PPUSH
24713: LD_VAR 0 7
24717: PPUSH
24718: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
24722: LD_VAR 0 5
24726: PPUSH
24727: LD_VAR 0 3
24731: PPUSH
24732: CALL_OW 183
// AddComExitBuilding ( p ) ;
24736: LD_VAR 0 5
24740: PPUSH
24741: CALL_OW 182
// end ; end ;
24745: GO 24593
24747: POP
24748: POP
// end ;
24749: GO 24559
24751: POP
24752: POP
// end ;
24753: GO 24314
24755: POP
24756: POP
// end ;
24757: LD_VAR 0 1
24761: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
24762: LD_INT 0
24764: PPUSH
24765: PPUSH
24766: PPUSH
24767: PPUSH
24768: PPUSH
24769: PPUSH
24770: PPUSH
24771: PPUSH
24772: PPUSH
24773: PPUSH
24774: PPUSH
24775: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
24776: LD_VAR 0 1
24780: NOT
24781: PUSH
24782: LD_EXP 74
24786: PUSH
24787: LD_VAR 0 1
24791: ARRAY
24792: NOT
24793: OR
24794: PUSH
24795: LD_EXP 74
24799: PUSH
24800: LD_VAR 0 1
24804: ARRAY
24805: PPUSH
24806: LD_INT 2
24808: PUSH
24809: LD_INT 30
24811: PUSH
24812: LD_INT 0
24814: PUSH
24815: EMPTY
24816: LIST
24817: LIST
24818: PUSH
24819: LD_INT 30
24821: PUSH
24822: LD_INT 1
24824: PUSH
24825: EMPTY
24826: LIST
24827: LIST
24828: PUSH
24829: EMPTY
24830: LIST
24831: LIST
24832: LIST
24833: PPUSH
24834: CALL_OW 72
24838: NOT
24839: OR
24840: IFFALSE 24844
// exit ;
24842: GO 28347
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
24844: LD_ADDR_VAR 0 4
24848: PUSH
24849: LD_EXP 74
24853: PUSH
24854: LD_VAR 0 1
24858: ARRAY
24859: PPUSH
24860: LD_INT 2
24862: PUSH
24863: LD_INT 25
24865: PUSH
24866: LD_INT 1
24868: PUSH
24869: EMPTY
24870: LIST
24871: LIST
24872: PUSH
24873: LD_INT 25
24875: PUSH
24876: LD_INT 2
24878: PUSH
24879: EMPTY
24880: LIST
24881: LIST
24882: PUSH
24883: LD_INT 25
24885: PUSH
24886: LD_INT 3
24888: PUSH
24889: EMPTY
24890: LIST
24891: LIST
24892: PUSH
24893: LD_INT 25
24895: PUSH
24896: LD_INT 4
24898: PUSH
24899: EMPTY
24900: LIST
24901: LIST
24902: PUSH
24903: LD_INT 25
24905: PUSH
24906: LD_INT 5
24908: PUSH
24909: EMPTY
24910: LIST
24911: LIST
24912: PUSH
24913: LD_INT 25
24915: PUSH
24916: LD_INT 8
24918: PUSH
24919: EMPTY
24920: LIST
24921: LIST
24922: PUSH
24923: LD_INT 25
24925: PUSH
24926: LD_INT 9
24928: PUSH
24929: EMPTY
24930: LIST
24931: LIST
24932: PUSH
24933: EMPTY
24934: LIST
24935: LIST
24936: LIST
24937: LIST
24938: LIST
24939: LIST
24940: LIST
24941: LIST
24942: PPUSH
24943: CALL_OW 72
24947: ST_TO_ADDR
// if not tmp then
24948: LD_VAR 0 4
24952: NOT
24953: IFFALSE 24957
// exit ;
24955: GO 28347
// for i in tmp do
24957: LD_ADDR_VAR 0 3
24961: PUSH
24962: LD_VAR 0 4
24966: PUSH
24967: FOR_IN
24968: IFFALSE 24999
// if GetTag ( i ) then
24970: LD_VAR 0 3
24974: PPUSH
24975: CALL_OW 110
24979: IFFALSE 24997
// tmp := tmp diff i ;
24981: LD_ADDR_VAR 0 4
24985: PUSH
24986: LD_VAR 0 4
24990: PUSH
24991: LD_VAR 0 3
24995: DIFF
24996: ST_TO_ADDR
24997: GO 24967
24999: POP
25000: POP
// if not tmp then
25001: LD_VAR 0 4
25005: NOT
25006: IFFALSE 25010
// exit ;
25008: GO 28347
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25010: LD_ADDR_VAR 0 5
25014: PUSH
25015: LD_EXP 74
25019: PUSH
25020: LD_VAR 0 1
25024: ARRAY
25025: PPUSH
25026: LD_INT 2
25028: PUSH
25029: LD_INT 25
25031: PUSH
25032: LD_INT 1
25034: PUSH
25035: EMPTY
25036: LIST
25037: LIST
25038: PUSH
25039: LD_INT 25
25041: PUSH
25042: LD_INT 5
25044: PUSH
25045: EMPTY
25046: LIST
25047: LIST
25048: PUSH
25049: LD_INT 25
25051: PUSH
25052: LD_INT 8
25054: PUSH
25055: EMPTY
25056: LIST
25057: LIST
25058: PUSH
25059: LD_INT 25
25061: PUSH
25062: LD_INT 9
25064: PUSH
25065: EMPTY
25066: LIST
25067: LIST
25068: PUSH
25069: EMPTY
25070: LIST
25071: LIST
25072: LIST
25073: LIST
25074: LIST
25075: PPUSH
25076: CALL_OW 72
25080: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
25081: LD_ADDR_VAR 0 6
25085: PUSH
25086: LD_EXP 74
25090: PUSH
25091: LD_VAR 0 1
25095: ARRAY
25096: PPUSH
25097: LD_INT 25
25099: PUSH
25100: LD_INT 2
25102: PUSH
25103: EMPTY
25104: LIST
25105: LIST
25106: PPUSH
25107: CALL_OW 72
25111: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
25112: LD_ADDR_VAR 0 7
25116: PUSH
25117: LD_EXP 74
25121: PUSH
25122: LD_VAR 0 1
25126: ARRAY
25127: PPUSH
25128: LD_INT 25
25130: PUSH
25131: LD_INT 3
25133: PUSH
25134: EMPTY
25135: LIST
25136: LIST
25137: PPUSH
25138: CALL_OW 72
25142: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
25143: LD_ADDR_VAR 0 8
25147: PUSH
25148: LD_EXP 74
25152: PUSH
25153: LD_VAR 0 1
25157: ARRAY
25158: PPUSH
25159: LD_INT 25
25161: PUSH
25162: LD_INT 4
25164: PUSH
25165: EMPTY
25166: LIST
25167: LIST
25168: PUSH
25169: LD_INT 24
25171: PUSH
25172: LD_INT 251
25174: PUSH
25175: EMPTY
25176: LIST
25177: LIST
25178: PUSH
25179: EMPTY
25180: LIST
25181: LIST
25182: PPUSH
25183: CALL_OW 72
25187: ST_TO_ADDR
// if mc_scan [ base ] then
25188: LD_EXP 97
25192: PUSH
25193: LD_VAR 0 1
25197: ARRAY
25198: IFFALSE 25659
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
25200: LD_ADDR_EXP 116
25204: PUSH
25205: LD_EXP 116
25209: PPUSH
25210: LD_VAR 0 1
25214: PPUSH
25215: LD_INT 4
25217: PPUSH
25218: CALL_OW 1
25222: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
25223: LD_ADDR_VAR 0 12
25227: PUSH
25228: LD_EXP 74
25232: PUSH
25233: LD_VAR 0 1
25237: ARRAY
25238: PPUSH
25239: LD_INT 2
25241: PUSH
25242: LD_INT 30
25244: PUSH
25245: LD_INT 4
25247: PUSH
25248: EMPTY
25249: LIST
25250: LIST
25251: PUSH
25252: LD_INT 30
25254: PUSH
25255: LD_INT 5
25257: PUSH
25258: EMPTY
25259: LIST
25260: LIST
25261: PUSH
25262: EMPTY
25263: LIST
25264: LIST
25265: LIST
25266: PPUSH
25267: CALL_OW 72
25271: ST_TO_ADDR
// if not b then
25272: LD_VAR 0 12
25276: NOT
25277: IFFALSE 25281
// exit ;
25279: GO 28347
// p := [ ] ;
25281: LD_ADDR_VAR 0 11
25285: PUSH
25286: EMPTY
25287: ST_TO_ADDR
// if sci >= 2 then
25288: LD_VAR 0 8
25292: PUSH
25293: LD_INT 2
25295: GREATEREQUAL
25296: IFFALSE 25327
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
25298: LD_ADDR_VAR 0 8
25302: PUSH
25303: LD_VAR 0 8
25307: PUSH
25308: LD_INT 1
25310: ARRAY
25311: PUSH
25312: LD_VAR 0 8
25316: PUSH
25317: LD_INT 2
25319: ARRAY
25320: PUSH
25321: EMPTY
25322: LIST
25323: LIST
25324: ST_TO_ADDR
25325: GO 25388
// if sci = 1 then
25327: LD_VAR 0 8
25331: PUSH
25332: LD_INT 1
25334: EQUAL
25335: IFFALSE 25356
// sci := [ sci [ 1 ] ] else
25337: LD_ADDR_VAR 0 8
25341: PUSH
25342: LD_VAR 0 8
25346: PUSH
25347: LD_INT 1
25349: ARRAY
25350: PUSH
25351: EMPTY
25352: LIST
25353: ST_TO_ADDR
25354: GO 25388
// if sci = 0 then
25356: LD_VAR 0 8
25360: PUSH
25361: LD_INT 0
25363: EQUAL
25364: IFFALSE 25388
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
25366: LD_ADDR_VAR 0 11
25370: PUSH
25371: LD_VAR 0 4
25375: PPUSH
25376: LD_INT 4
25378: PPUSH
25379: CALL 91735 0 2
25383: PUSH
25384: LD_INT 1
25386: ARRAY
25387: ST_TO_ADDR
// if eng > 4 then
25388: LD_VAR 0 6
25392: PUSH
25393: LD_INT 4
25395: GREATER
25396: IFFALSE 25442
// for i = eng downto 4 do
25398: LD_ADDR_VAR 0 3
25402: PUSH
25403: DOUBLE
25404: LD_VAR 0 6
25408: INC
25409: ST_TO_ADDR
25410: LD_INT 4
25412: PUSH
25413: FOR_DOWNTO
25414: IFFALSE 25440
// eng := eng diff eng [ i ] ;
25416: LD_ADDR_VAR 0 6
25420: PUSH
25421: LD_VAR 0 6
25425: PUSH
25426: LD_VAR 0 6
25430: PUSH
25431: LD_VAR 0 3
25435: ARRAY
25436: DIFF
25437: ST_TO_ADDR
25438: GO 25413
25440: POP
25441: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
25442: LD_ADDR_VAR 0 4
25446: PUSH
25447: LD_VAR 0 4
25451: PUSH
25452: LD_VAR 0 5
25456: PUSH
25457: LD_VAR 0 6
25461: UNION
25462: PUSH
25463: LD_VAR 0 7
25467: UNION
25468: PUSH
25469: LD_VAR 0 8
25473: UNION
25474: DIFF
25475: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
25476: LD_ADDR_VAR 0 13
25480: PUSH
25481: LD_EXP 74
25485: PUSH
25486: LD_VAR 0 1
25490: ARRAY
25491: PPUSH
25492: LD_INT 2
25494: PUSH
25495: LD_INT 30
25497: PUSH
25498: LD_INT 32
25500: PUSH
25501: EMPTY
25502: LIST
25503: LIST
25504: PUSH
25505: LD_INT 30
25507: PUSH
25508: LD_INT 31
25510: PUSH
25511: EMPTY
25512: LIST
25513: LIST
25514: PUSH
25515: EMPTY
25516: LIST
25517: LIST
25518: LIST
25519: PPUSH
25520: CALL_OW 72
25524: PUSH
25525: LD_EXP 74
25529: PUSH
25530: LD_VAR 0 1
25534: ARRAY
25535: PPUSH
25536: LD_INT 2
25538: PUSH
25539: LD_INT 30
25541: PUSH
25542: LD_INT 4
25544: PUSH
25545: EMPTY
25546: LIST
25547: LIST
25548: PUSH
25549: LD_INT 30
25551: PUSH
25552: LD_INT 5
25554: PUSH
25555: EMPTY
25556: LIST
25557: LIST
25558: PUSH
25559: EMPTY
25560: LIST
25561: LIST
25562: LIST
25563: PPUSH
25564: CALL_OW 72
25568: PUSH
25569: LD_INT 6
25571: MUL
25572: PLUS
25573: ST_TO_ADDR
// if bcount < tmp then
25574: LD_VAR 0 13
25578: PUSH
25579: LD_VAR 0 4
25583: LESS
25584: IFFALSE 25630
// for i = tmp downto bcount do
25586: LD_ADDR_VAR 0 3
25590: PUSH
25591: DOUBLE
25592: LD_VAR 0 4
25596: INC
25597: ST_TO_ADDR
25598: LD_VAR 0 13
25602: PUSH
25603: FOR_DOWNTO
25604: IFFALSE 25628
// tmp := Delete ( tmp , tmp ) ;
25606: LD_ADDR_VAR 0 4
25610: PUSH
25611: LD_VAR 0 4
25615: PPUSH
25616: LD_VAR 0 4
25620: PPUSH
25621: CALL_OW 3
25625: ST_TO_ADDR
25626: GO 25603
25628: POP
25629: POP
// result := [ tmp , 0 , 0 , p ] ;
25630: LD_ADDR_VAR 0 2
25634: PUSH
25635: LD_VAR 0 4
25639: PUSH
25640: LD_INT 0
25642: PUSH
25643: LD_INT 0
25645: PUSH
25646: LD_VAR 0 11
25650: PUSH
25651: EMPTY
25652: LIST
25653: LIST
25654: LIST
25655: LIST
25656: ST_TO_ADDR
// exit ;
25657: GO 28347
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
25659: LD_EXP 74
25663: PUSH
25664: LD_VAR 0 1
25668: ARRAY
25669: PPUSH
25670: LD_INT 2
25672: PUSH
25673: LD_INT 30
25675: PUSH
25676: LD_INT 6
25678: PUSH
25679: EMPTY
25680: LIST
25681: LIST
25682: PUSH
25683: LD_INT 30
25685: PUSH
25686: LD_INT 7
25688: PUSH
25689: EMPTY
25690: LIST
25691: LIST
25692: PUSH
25693: LD_INT 30
25695: PUSH
25696: LD_INT 8
25698: PUSH
25699: EMPTY
25700: LIST
25701: LIST
25702: PUSH
25703: EMPTY
25704: LIST
25705: LIST
25706: LIST
25707: LIST
25708: PPUSH
25709: CALL_OW 72
25713: NOT
25714: PUSH
25715: LD_EXP 74
25719: PUSH
25720: LD_VAR 0 1
25724: ARRAY
25725: PPUSH
25726: LD_INT 30
25728: PUSH
25729: LD_INT 3
25731: PUSH
25732: EMPTY
25733: LIST
25734: LIST
25735: PPUSH
25736: CALL_OW 72
25740: NOT
25741: AND
25742: IFFALSE 25814
// begin if eng = tmp then
25744: LD_VAR 0 6
25748: PUSH
25749: LD_VAR 0 4
25753: EQUAL
25754: IFFALSE 25758
// exit ;
25756: GO 28347
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
25758: LD_ADDR_EXP 116
25762: PUSH
25763: LD_EXP 116
25767: PPUSH
25768: LD_VAR 0 1
25772: PPUSH
25773: LD_INT 1
25775: PPUSH
25776: CALL_OW 1
25780: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
25781: LD_ADDR_VAR 0 2
25785: PUSH
25786: LD_INT 0
25788: PUSH
25789: LD_VAR 0 4
25793: PUSH
25794: LD_VAR 0 6
25798: DIFF
25799: PUSH
25800: LD_INT 0
25802: PUSH
25803: LD_INT 0
25805: PUSH
25806: EMPTY
25807: LIST
25808: LIST
25809: LIST
25810: LIST
25811: ST_TO_ADDR
// exit ;
25812: GO 28347
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
25814: LD_EXP 101
25818: PUSH
25819: LD_EXP 100
25823: PUSH
25824: LD_VAR 0 1
25828: ARRAY
25829: ARRAY
25830: PUSH
25831: LD_EXP 74
25835: PUSH
25836: LD_VAR 0 1
25840: ARRAY
25841: PPUSH
25842: LD_INT 2
25844: PUSH
25845: LD_INT 30
25847: PUSH
25848: LD_INT 6
25850: PUSH
25851: EMPTY
25852: LIST
25853: LIST
25854: PUSH
25855: LD_INT 30
25857: PUSH
25858: LD_INT 7
25860: PUSH
25861: EMPTY
25862: LIST
25863: LIST
25864: PUSH
25865: LD_INT 30
25867: PUSH
25868: LD_INT 8
25870: PUSH
25871: EMPTY
25872: LIST
25873: LIST
25874: PUSH
25875: EMPTY
25876: LIST
25877: LIST
25878: LIST
25879: LIST
25880: PPUSH
25881: CALL_OW 72
25885: AND
25886: PUSH
25887: LD_EXP 74
25891: PUSH
25892: LD_VAR 0 1
25896: ARRAY
25897: PPUSH
25898: LD_INT 30
25900: PUSH
25901: LD_INT 3
25903: PUSH
25904: EMPTY
25905: LIST
25906: LIST
25907: PPUSH
25908: CALL_OW 72
25912: NOT
25913: AND
25914: IFFALSE 26128
// begin if sci >= 6 then
25916: LD_VAR 0 8
25920: PUSH
25921: LD_INT 6
25923: GREATEREQUAL
25924: IFFALSE 25928
// exit ;
25926: GO 28347
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
25928: LD_ADDR_EXP 116
25932: PUSH
25933: LD_EXP 116
25937: PPUSH
25938: LD_VAR 0 1
25942: PPUSH
25943: LD_INT 2
25945: PPUSH
25946: CALL_OW 1
25950: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
25951: LD_ADDR_VAR 0 9
25955: PUSH
25956: LD_VAR 0 4
25960: PUSH
25961: LD_VAR 0 8
25965: DIFF
25966: PPUSH
25967: LD_INT 4
25969: PPUSH
25970: CALL 91735 0 2
25974: ST_TO_ADDR
// p := [ ] ;
25975: LD_ADDR_VAR 0 11
25979: PUSH
25980: EMPTY
25981: ST_TO_ADDR
// if sci < 6 and sort > 6 then
25982: LD_VAR 0 8
25986: PUSH
25987: LD_INT 6
25989: LESS
25990: PUSH
25991: LD_VAR 0 9
25995: PUSH
25996: LD_INT 6
25998: GREATER
25999: AND
26000: IFFALSE 26081
// begin for i = 1 to 6 - sci do
26002: LD_ADDR_VAR 0 3
26006: PUSH
26007: DOUBLE
26008: LD_INT 1
26010: DEC
26011: ST_TO_ADDR
26012: LD_INT 6
26014: PUSH
26015: LD_VAR 0 8
26019: MINUS
26020: PUSH
26021: FOR_TO
26022: IFFALSE 26077
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
26024: LD_ADDR_VAR 0 11
26028: PUSH
26029: LD_VAR 0 11
26033: PPUSH
26034: LD_VAR 0 11
26038: PUSH
26039: LD_INT 1
26041: PLUS
26042: PPUSH
26043: LD_VAR 0 9
26047: PUSH
26048: LD_INT 1
26050: ARRAY
26051: PPUSH
26052: CALL_OW 2
26056: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
26057: LD_ADDR_VAR 0 9
26061: PUSH
26062: LD_VAR 0 9
26066: PPUSH
26067: LD_INT 1
26069: PPUSH
26070: CALL_OW 3
26074: ST_TO_ADDR
// end ;
26075: GO 26021
26077: POP
26078: POP
// end else
26079: GO 26101
// if sort then
26081: LD_VAR 0 9
26085: IFFALSE 26101
// p := sort [ 1 ] ;
26087: LD_ADDR_VAR 0 11
26091: PUSH
26092: LD_VAR 0 9
26096: PUSH
26097: LD_INT 1
26099: ARRAY
26100: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
26101: LD_ADDR_VAR 0 2
26105: PUSH
26106: LD_INT 0
26108: PUSH
26109: LD_INT 0
26111: PUSH
26112: LD_INT 0
26114: PUSH
26115: LD_VAR 0 11
26119: PUSH
26120: EMPTY
26121: LIST
26122: LIST
26123: LIST
26124: LIST
26125: ST_TO_ADDR
// exit ;
26126: GO 28347
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26128: LD_EXP 101
26132: PUSH
26133: LD_EXP 100
26137: PUSH
26138: LD_VAR 0 1
26142: ARRAY
26143: ARRAY
26144: PUSH
26145: LD_EXP 74
26149: PUSH
26150: LD_VAR 0 1
26154: ARRAY
26155: PPUSH
26156: LD_INT 2
26158: PUSH
26159: LD_INT 30
26161: PUSH
26162: LD_INT 6
26164: PUSH
26165: EMPTY
26166: LIST
26167: LIST
26168: PUSH
26169: LD_INT 30
26171: PUSH
26172: LD_INT 7
26174: PUSH
26175: EMPTY
26176: LIST
26177: LIST
26178: PUSH
26179: LD_INT 30
26181: PUSH
26182: LD_INT 8
26184: PUSH
26185: EMPTY
26186: LIST
26187: LIST
26188: PUSH
26189: EMPTY
26190: LIST
26191: LIST
26192: LIST
26193: LIST
26194: PPUSH
26195: CALL_OW 72
26199: AND
26200: PUSH
26201: LD_EXP 74
26205: PUSH
26206: LD_VAR 0 1
26210: ARRAY
26211: PPUSH
26212: LD_INT 30
26214: PUSH
26215: LD_INT 3
26217: PUSH
26218: EMPTY
26219: LIST
26220: LIST
26221: PPUSH
26222: CALL_OW 72
26226: AND
26227: IFFALSE 26961
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
26229: LD_ADDR_EXP 116
26233: PUSH
26234: LD_EXP 116
26238: PPUSH
26239: LD_VAR 0 1
26243: PPUSH
26244: LD_INT 3
26246: PPUSH
26247: CALL_OW 1
26251: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
26252: LD_ADDR_VAR 0 2
26256: PUSH
26257: LD_INT 0
26259: PUSH
26260: LD_INT 0
26262: PUSH
26263: LD_INT 0
26265: PUSH
26266: LD_INT 0
26268: PUSH
26269: EMPTY
26270: LIST
26271: LIST
26272: LIST
26273: LIST
26274: ST_TO_ADDR
// if not eng then
26275: LD_VAR 0 6
26279: NOT
26280: IFFALSE 26343
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
26282: LD_ADDR_VAR 0 11
26286: PUSH
26287: LD_VAR 0 4
26291: PPUSH
26292: LD_INT 2
26294: PPUSH
26295: CALL 91735 0 2
26299: PUSH
26300: LD_INT 1
26302: ARRAY
26303: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
26304: LD_ADDR_VAR 0 2
26308: PUSH
26309: LD_VAR 0 2
26313: PPUSH
26314: LD_INT 2
26316: PPUSH
26317: LD_VAR 0 11
26321: PPUSH
26322: CALL_OW 1
26326: ST_TO_ADDR
// tmp := tmp diff p ;
26327: LD_ADDR_VAR 0 4
26331: PUSH
26332: LD_VAR 0 4
26336: PUSH
26337: LD_VAR 0 11
26341: DIFF
26342: ST_TO_ADDR
// end ; if tmp and sci < 6 then
26343: LD_VAR 0 4
26347: PUSH
26348: LD_VAR 0 8
26352: PUSH
26353: LD_INT 6
26355: LESS
26356: AND
26357: IFFALSE 26545
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
26359: LD_ADDR_VAR 0 9
26363: PUSH
26364: LD_VAR 0 4
26368: PUSH
26369: LD_VAR 0 8
26373: PUSH
26374: LD_VAR 0 7
26378: UNION
26379: DIFF
26380: PPUSH
26381: LD_INT 4
26383: PPUSH
26384: CALL 91735 0 2
26388: ST_TO_ADDR
// p := [ ] ;
26389: LD_ADDR_VAR 0 11
26393: PUSH
26394: EMPTY
26395: ST_TO_ADDR
// if sort then
26396: LD_VAR 0 9
26400: IFFALSE 26516
// for i = 1 to 6 - sci do
26402: LD_ADDR_VAR 0 3
26406: PUSH
26407: DOUBLE
26408: LD_INT 1
26410: DEC
26411: ST_TO_ADDR
26412: LD_INT 6
26414: PUSH
26415: LD_VAR 0 8
26419: MINUS
26420: PUSH
26421: FOR_TO
26422: IFFALSE 26514
// begin if i = sort then
26424: LD_VAR 0 3
26428: PUSH
26429: LD_VAR 0 9
26433: EQUAL
26434: IFFALSE 26438
// break ;
26436: GO 26514
// if GetClass ( i ) = 4 then
26438: LD_VAR 0 3
26442: PPUSH
26443: CALL_OW 257
26447: PUSH
26448: LD_INT 4
26450: EQUAL
26451: IFFALSE 26455
// continue ;
26453: GO 26421
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26455: LD_ADDR_VAR 0 11
26459: PUSH
26460: LD_VAR 0 11
26464: PPUSH
26465: LD_VAR 0 11
26469: PUSH
26470: LD_INT 1
26472: PLUS
26473: PPUSH
26474: LD_VAR 0 9
26478: PUSH
26479: LD_VAR 0 3
26483: ARRAY
26484: PPUSH
26485: CALL_OW 2
26489: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26490: LD_ADDR_VAR 0 4
26494: PUSH
26495: LD_VAR 0 4
26499: PUSH
26500: LD_VAR 0 9
26504: PUSH
26505: LD_VAR 0 3
26509: ARRAY
26510: DIFF
26511: ST_TO_ADDR
// end ;
26512: GO 26421
26514: POP
26515: POP
// if p then
26516: LD_VAR 0 11
26520: IFFALSE 26545
// result := Replace ( result , 4 , p ) ;
26522: LD_ADDR_VAR 0 2
26526: PUSH
26527: LD_VAR 0 2
26531: PPUSH
26532: LD_INT 4
26534: PPUSH
26535: LD_VAR 0 11
26539: PPUSH
26540: CALL_OW 1
26544: ST_TO_ADDR
// end ; if tmp and mech < 6 then
26545: LD_VAR 0 4
26549: PUSH
26550: LD_VAR 0 7
26554: PUSH
26555: LD_INT 6
26557: LESS
26558: AND
26559: IFFALSE 26747
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
26561: LD_ADDR_VAR 0 9
26565: PUSH
26566: LD_VAR 0 4
26570: PUSH
26571: LD_VAR 0 8
26575: PUSH
26576: LD_VAR 0 7
26580: UNION
26581: DIFF
26582: PPUSH
26583: LD_INT 3
26585: PPUSH
26586: CALL 91735 0 2
26590: ST_TO_ADDR
// p := [ ] ;
26591: LD_ADDR_VAR 0 11
26595: PUSH
26596: EMPTY
26597: ST_TO_ADDR
// if sort then
26598: LD_VAR 0 9
26602: IFFALSE 26718
// for i = 1 to 6 - mech do
26604: LD_ADDR_VAR 0 3
26608: PUSH
26609: DOUBLE
26610: LD_INT 1
26612: DEC
26613: ST_TO_ADDR
26614: LD_INT 6
26616: PUSH
26617: LD_VAR 0 7
26621: MINUS
26622: PUSH
26623: FOR_TO
26624: IFFALSE 26716
// begin if i = sort then
26626: LD_VAR 0 3
26630: PUSH
26631: LD_VAR 0 9
26635: EQUAL
26636: IFFALSE 26640
// break ;
26638: GO 26716
// if GetClass ( i ) = 3 then
26640: LD_VAR 0 3
26644: PPUSH
26645: CALL_OW 257
26649: PUSH
26650: LD_INT 3
26652: EQUAL
26653: IFFALSE 26657
// continue ;
26655: GO 26623
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26657: LD_ADDR_VAR 0 11
26661: PUSH
26662: LD_VAR 0 11
26666: PPUSH
26667: LD_VAR 0 11
26671: PUSH
26672: LD_INT 1
26674: PLUS
26675: PPUSH
26676: LD_VAR 0 9
26680: PUSH
26681: LD_VAR 0 3
26685: ARRAY
26686: PPUSH
26687: CALL_OW 2
26691: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26692: LD_ADDR_VAR 0 4
26696: PUSH
26697: LD_VAR 0 4
26701: PUSH
26702: LD_VAR 0 9
26706: PUSH
26707: LD_VAR 0 3
26711: ARRAY
26712: DIFF
26713: ST_TO_ADDR
// end ;
26714: GO 26623
26716: POP
26717: POP
// if p then
26718: LD_VAR 0 11
26722: IFFALSE 26747
// result := Replace ( result , 3 , p ) ;
26724: LD_ADDR_VAR 0 2
26728: PUSH
26729: LD_VAR 0 2
26733: PPUSH
26734: LD_INT 3
26736: PPUSH
26737: LD_VAR 0 11
26741: PPUSH
26742: CALL_OW 1
26746: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
26747: LD_VAR 0 4
26751: PUSH
26752: LD_INT 6
26754: GREATER
26755: PUSH
26756: LD_VAR 0 6
26760: PUSH
26761: LD_INT 6
26763: LESS
26764: AND
26765: IFFALSE 26959
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
26767: LD_ADDR_VAR 0 9
26771: PUSH
26772: LD_VAR 0 4
26776: PUSH
26777: LD_VAR 0 8
26781: PUSH
26782: LD_VAR 0 7
26786: UNION
26787: PUSH
26788: LD_VAR 0 6
26792: UNION
26793: DIFF
26794: PPUSH
26795: LD_INT 2
26797: PPUSH
26798: CALL 91735 0 2
26802: ST_TO_ADDR
// p := [ ] ;
26803: LD_ADDR_VAR 0 11
26807: PUSH
26808: EMPTY
26809: ST_TO_ADDR
// if sort then
26810: LD_VAR 0 9
26814: IFFALSE 26930
// for i = 1 to 6 - eng do
26816: LD_ADDR_VAR 0 3
26820: PUSH
26821: DOUBLE
26822: LD_INT 1
26824: DEC
26825: ST_TO_ADDR
26826: LD_INT 6
26828: PUSH
26829: LD_VAR 0 6
26833: MINUS
26834: PUSH
26835: FOR_TO
26836: IFFALSE 26928
// begin if i = sort then
26838: LD_VAR 0 3
26842: PUSH
26843: LD_VAR 0 9
26847: EQUAL
26848: IFFALSE 26852
// break ;
26850: GO 26928
// if GetClass ( i ) = 2 then
26852: LD_VAR 0 3
26856: PPUSH
26857: CALL_OW 257
26861: PUSH
26862: LD_INT 2
26864: EQUAL
26865: IFFALSE 26869
// continue ;
26867: GO 26835
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26869: LD_ADDR_VAR 0 11
26873: PUSH
26874: LD_VAR 0 11
26878: PPUSH
26879: LD_VAR 0 11
26883: PUSH
26884: LD_INT 1
26886: PLUS
26887: PPUSH
26888: LD_VAR 0 9
26892: PUSH
26893: LD_VAR 0 3
26897: ARRAY
26898: PPUSH
26899: CALL_OW 2
26903: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26904: LD_ADDR_VAR 0 4
26908: PUSH
26909: LD_VAR 0 4
26913: PUSH
26914: LD_VAR 0 9
26918: PUSH
26919: LD_VAR 0 3
26923: ARRAY
26924: DIFF
26925: ST_TO_ADDR
// end ;
26926: GO 26835
26928: POP
26929: POP
// if p then
26930: LD_VAR 0 11
26934: IFFALSE 26959
// result := Replace ( result , 2 , p ) ;
26936: LD_ADDR_VAR 0 2
26940: PUSH
26941: LD_VAR 0 2
26945: PPUSH
26946: LD_INT 2
26948: PPUSH
26949: LD_VAR 0 11
26953: PPUSH
26954: CALL_OW 1
26958: ST_TO_ADDR
// end ; exit ;
26959: GO 28347
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
26961: LD_EXP 101
26965: PUSH
26966: LD_EXP 100
26970: PUSH
26971: LD_VAR 0 1
26975: ARRAY
26976: ARRAY
26977: NOT
26978: PUSH
26979: LD_EXP 74
26983: PUSH
26984: LD_VAR 0 1
26988: ARRAY
26989: PPUSH
26990: LD_INT 30
26992: PUSH
26993: LD_INT 3
26995: PUSH
26996: EMPTY
26997: LIST
26998: LIST
26999: PPUSH
27000: CALL_OW 72
27004: AND
27005: PUSH
27006: LD_EXP 79
27010: PUSH
27011: LD_VAR 0 1
27015: ARRAY
27016: AND
27017: IFFALSE 27625
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
27019: LD_ADDR_EXP 116
27023: PUSH
27024: LD_EXP 116
27028: PPUSH
27029: LD_VAR 0 1
27033: PPUSH
27034: LD_INT 5
27036: PPUSH
27037: CALL_OW 1
27041: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27042: LD_ADDR_VAR 0 2
27046: PUSH
27047: LD_INT 0
27049: PUSH
27050: LD_INT 0
27052: PUSH
27053: LD_INT 0
27055: PUSH
27056: LD_INT 0
27058: PUSH
27059: EMPTY
27060: LIST
27061: LIST
27062: LIST
27063: LIST
27064: ST_TO_ADDR
// if sci > 1 then
27065: LD_VAR 0 8
27069: PUSH
27070: LD_INT 1
27072: GREATER
27073: IFFALSE 27101
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
27075: LD_ADDR_VAR 0 4
27079: PUSH
27080: LD_VAR 0 4
27084: PUSH
27085: LD_VAR 0 8
27089: PUSH
27090: LD_VAR 0 8
27094: PUSH
27095: LD_INT 1
27097: ARRAY
27098: DIFF
27099: DIFF
27100: ST_TO_ADDR
// if tmp and not sci then
27101: LD_VAR 0 4
27105: PUSH
27106: LD_VAR 0 8
27110: NOT
27111: AND
27112: IFFALSE 27181
// begin sort := SortBySkill ( tmp , 4 ) ;
27114: LD_ADDR_VAR 0 9
27118: PUSH
27119: LD_VAR 0 4
27123: PPUSH
27124: LD_INT 4
27126: PPUSH
27127: CALL 91735 0 2
27131: ST_TO_ADDR
// if sort then
27132: LD_VAR 0 9
27136: IFFALSE 27152
// p := sort [ 1 ] ;
27138: LD_ADDR_VAR 0 11
27142: PUSH
27143: LD_VAR 0 9
27147: PUSH
27148: LD_INT 1
27150: ARRAY
27151: ST_TO_ADDR
// if p then
27152: LD_VAR 0 11
27156: IFFALSE 27181
// result := Replace ( result , 4 , p ) ;
27158: LD_ADDR_VAR 0 2
27162: PUSH
27163: LD_VAR 0 2
27167: PPUSH
27168: LD_INT 4
27170: PPUSH
27171: LD_VAR 0 11
27175: PPUSH
27176: CALL_OW 1
27180: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
27181: LD_ADDR_VAR 0 4
27185: PUSH
27186: LD_VAR 0 4
27190: PUSH
27191: LD_VAR 0 7
27195: DIFF
27196: ST_TO_ADDR
// if tmp and mech < 6 then
27197: LD_VAR 0 4
27201: PUSH
27202: LD_VAR 0 7
27206: PUSH
27207: LD_INT 6
27209: LESS
27210: AND
27211: IFFALSE 27399
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27213: LD_ADDR_VAR 0 9
27217: PUSH
27218: LD_VAR 0 4
27222: PUSH
27223: LD_VAR 0 8
27227: PUSH
27228: LD_VAR 0 7
27232: UNION
27233: DIFF
27234: PPUSH
27235: LD_INT 3
27237: PPUSH
27238: CALL 91735 0 2
27242: ST_TO_ADDR
// p := [ ] ;
27243: LD_ADDR_VAR 0 11
27247: PUSH
27248: EMPTY
27249: ST_TO_ADDR
// if sort then
27250: LD_VAR 0 9
27254: IFFALSE 27370
// for i = 1 to 6 - mech do
27256: LD_ADDR_VAR 0 3
27260: PUSH
27261: DOUBLE
27262: LD_INT 1
27264: DEC
27265: ST_TO_ADDR
27266: LD_INT 6
27268: PUSH
27269: LD_VAR 0 7
27273: MINUS
27274: PUSH
27275: FOR_TO
27276: IFFALSE 27368
// begin if i = sort then
27278: LD_VAR 0 3
27282: PUSH
27283: LD_VAR 0 9
27287: EQUAL
27288: IFFALSE 27292
// break ;
27290: GO 27368
// if GetClass ( i ) = 3 then
27292: LD_VAR 0 3
27296: PPUSH
27297: CALL_OW 257
27301: PUSH
27302: LD_INT 3
27304: EQUAL
27305: IFFALSE 27309
// continue ;
27307: GO 27275
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27309: LD_ADDR_VAR 0 11
27313: PUSH
27314: LD_VAR 0 11
27318: PPUSH
27319: LD_VAR 0 11
27323: PUSH
27324: LD_INT 1
27326: PLUS
27327: PPUSH
27328: LD_VAR 0 9
27332: PUSH
27333: LD_VAR 0 3
27337: ARRAY
27338: PPUSH
27339: CALL_OW 2
27343: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27344: LD_ADDR_VAR 0 4
27348: PUSH
27349: LD_VAR 0 4
27353: PUSH
27354: LD_VAR 0 9
27358: PUSH
27359: LD_VAR 0 3
27363: ARRAY
27364: DIFF
27365: ST_TO_ADDR
// end ;
27366: GO 27275
27368: POP
27369: POP
// if p then
27370: LD_VAR 0 11
27374: IFFALSE 27399
// result := Replace ( result , 3 , p ) ;
27376: LD_ADDR_VAR 0 2
27380: PUSH
27381: LD_VAR 0 2
27385: PPUSH
27386: LD_INT 3
27388: PPUSH
27389: LD_VAR 0 11
27393: PPUSH
27394: CALL_OW 1
27398: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
27399: LD_ADDR_VAR 0 4
27403: PUSH
27404: LD_VAR 0 4
27408: PUSH
27409: LD_VAR 0 6
27413: DIFF
27414: ST_TO_ADDR
// if tmp and eng < 6 then
27415: LD_VAR 0 4
27419: PUSH
27420: LD_VAR 0 6
27424: PUSH
27425: LD_INT 6
27427: LESS
27428: AND
27429: IFFALSE 27623
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
27431: LD_ADDR_VAR 0 9
27435: PUSH
27436: LD_VAR 0 4
27440: PUSH
27441: LD_VAR 0 8
27445: PUSH
27446: LD_VAR 0 7
27450: UNION
27451: PUSH
27452: LD_VAR 0 6
27456: UNION
27457: DIFF
27458: PPUSH
27459: LD_INT 2
27461: PPUSH
27462: CALL 91735 0 2
27466: ST_TO_ADDR
// p := [ ] ;
27467: LD_ADDR_VAR 0 11
27471: PUSH
27472: EMPTY
27473: ST_TO_ADDR
// if sort then
27474: LD_VAR 0 9
27478: IFFALSE 27594
// for i = 1 to 6 - eng do
27480: LD_ADDR_VAR 0 3
27484: PUSH
27485: DOUBLE
27486: LD_INT 1
27488: DEC
27489: ST_TO_ADDR
27490: LD_INT 6
27492: PUSH
27493: LD_VAR 0 6
27497: MINUS
27498: PUSH
27499: FOR_TO
27500: IFFALSE 27592
// begin if i = sort then
27502: LD_VAR 0 3
27506: PUSH
27507: LD_VAR 0 9
27511: EQUAL
27512: IFFALSE 27516
// break ;
27514: GO 27592
// if GetClass ( i ) = 2 then
27516: LD_VAR 0 3
27520: PPUSH
27521: CALL_OW 257
27525: PUSH
27526: LD_INT 2
27528: EQUAL
27529: IFFALSE 27533
// continue ;
27531: GO 27499
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27533: LD_ADDR_VAR 0 11
27537: PUSH
27538: LD_VAR 0 11
27542: PPUSH
27543: LD_VAR 0 11
27547: PUSH
27548: LD_INT 1
27550: PLUS
27551: PPUSH
27552: LD_VAR 0 9
27556: PUSH
27557: LD_VAR 0 3
27561: ARRAY
27562: PPUSH
27563: CALL_OW 2
27567: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27568: LD_ADDR_VAR 0 4
27572: PUSH
27573: LD_VAR 0 4
27577: PUSH
27578: LD_VAR 0 9
27582: PUSH
27583: LD_VAR 0 3
27587: ARRAY
27588: DIFF
27589: ST_TO_ADDR
// end ;
27590: GO 27499
27592: POP
27593: POP
// if p then
27594: LD_VAR 0 11
27598: IFFALSE 27623
// result := Replace ( result , 2 , p ) ;
27600: LD_ADDR_VAR 0 2
27604: PUSH
27605: LD_VAR 0 2
27609: PPUSH
27610: LD_INT 2
27612: PPUSH
27613: LD_VAR 0 11
27617: PPUSH
27618: CALL_OW 1
27622: ST_TO_ADDR
// end ; exit ;
27623: GO 28347
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
27625: LD_EXP 101
27629: PUSH
27630: LD_EXP 100
27634: PUSH
27635: LD_VAR 0 1
27639: ARRAY
27640: ARRAY
27641: NOT
27642: PUSH
27643: LD_EXP 74
27647: PUSH
27648: LD_VAR 0 1
27652: ARRAY
27653: PPUSH
27654: LD_INT 30
27656: PUSH
27657: LD_INT 3
27659: PUSH
27660: EMPTY
27661: LIST
27662: LIST
27663: PPUSH
27664: CALL_OW 72
27668: AND
27669: PUSH
27670: LD_EXP 79
27674: PUSH
27675: LD_VAR 0 1
27679: ARRAY
27680: NOT
27681: AND
27682: IFFALSE 28347
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
27684: LD_ADDR_EXP 116
27688: PUSH
27689: LD_EXP 116
27693: PPUSH
27694: LD_VAR 0 1
27698: PPUSH
27699: LD_INT 6
27701: PPUSH
27702: CALL_OW 1
27706: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27707: LD_ADDR_VAR 0 2
27711: PUSH
27712: LD_INT 0
27714: PUSH
27715: LD_INT 0
27717: PUSH
27718: LD_INT 0
27720: PUSH
27721: LD_INT 0
27723: PUSH
27724: EMPTY
27725: LIST
27726: LIST
27727: LIST
27728: LIST
27729: ST_TO_ADDR
// if sci >= 1 then
27730: LD_VAR 0 8
27734: PUSH
27735: LD_INT 1
27737: GREATEREQUAL
27738: IFFALSE 27760
// tmp := tmp diff sci [ 1 ] ;
27740: LD_ADDR_VAR 0 4
27744: PUSH
27745: LD_VAR 0 4
27749: PUSH
27750: LD_VAR 0 8
27754: PUSH
27755: LD_INT 1
27757: ARRAY
27758: DIFF
27759: ST_TO_ADDR
// if tmp and not sci then
27760: LD_VAR 0 4
27764: PUSH
27765: LD_VAR 0 8
27769: NOT
27770: AND
27771: IFFALSE 27840
// begin sort := SortBySkill ( tmp , 4 ) ;
27773: LD_ADDR_VAR 0 9
27777: PUSH
27778: LD_VAR 0 4
27782: PPUSH
27783: LD_INT 4
27785: PPUSH
27786: CALL 91735 0 2
27790: ST_TO_ADDR
// if sort then
27791: LD_VAR 0 9
27795: IFFALSE 27811
// p := sort [ 1 ] ;
27797: LD_ADDR_VAR 0 11
27801: PUSH
27802: LD_VAR 0 9
27806: PUSH
27807: LD_INT 1
27809: ARRAY
27810: ST_TO_ADDR
// if p then
27811: LD_VAR 0 11
27815: IFFALSE 27840
// result := Replace ( result , 4 , p ) ;
27817: LD_ADDR_VAR 0 2
27821: PUSH
27822: LD_VAR 0 2
27826: PPUSH
27827: LD_INT 4
27829: PPUSH
27830: LD_VAR 0 11
27834: PPUSH
27835: CALL_OW 1
27839: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
27840: LD_ADDR_VAR 0 4
27844: PUSH
27845: LD_VAR 0 4
27849: PUSH
27850: LD_VAR 0 7
27854: DIFF
27855: ST_TO_ADDR
// if tmp and mech < 6 then
27856: LD_VAR 0 4
27860: PUSH
27861: LD_VAR 0 7
27865: PUSH
27866: LD_INT 6
27868: LESS
27869: AND
27870: IFFALSE 28052
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
27872: LD_ADDR_VAR 0 9
27876: PUSH
27877: LD_VAR 0 4
27881: PUSH
27882: LD_VAR 0 7
27886: DIFF
27887: PPUSH
27888: LD_INT 3
27890: PPUSH
27891: CALL 91735 0 2
27895: ST_TO_ADDR
// p := [ ] ;
27896: LD_ADDR_VAR 0 11
27900: PUSH
27901: EMPTY
27902: ST_TO_ADDR
// if sort then
27903: LD_VAR 0 9
27907: IFFALSE 28023
// for i = 1 to 6 - mech do
27909: LD_ADDR_VAR 0 3
27913: PUSH
27914: DOUBLE
27915: LD_INT 1
27917: DEC
27918: ST_TO_ADDR
27919: LD_INT 6
27921: PUSH
27922: LD_VAR 0 7
27926: MINUS
27927: PUSH
27928: FOR_TO
27929: IFFALSE 28021
// begin if i = sort then
27931: LD_VAR 0 3
27935: PUSH
27936: LD_VAR 0 9
27940: EQUAL
27941: IFFALSE 27945
// break ;
27943: GO 28021
// if GetClass ( i ) = 3 then
27945: LD_VAR 0 3
27949: PPUSH
27950: CALL_OW 257
27954: PUSH
27955: LD_INT 3
27957: EQUAL
27958: IFFALSE 27962
// continue ;
27960: GO 27928
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27962: LD_ADDR_VAR 0 11
27966: PUSH
27967: LD_VAR 0 11
27971: PPUSH
27972: LD_VAR 0 11
27976: PUSH
27977: LD_INT 1
27979: PLUS
27980: PPUSH
27981: LD_VAR 0 9
27985: PUSH
27986: LD_VAR 0 3
27990: ARRAY
27991: PPUSH
27992: CALL_OW 2
27996: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27997: LD_ADDR_VAR 0 4
28001: PUSH
28002: LD_VAR 0 4
28006: PUSH
28007: LD_VAR 0 9
28011: PUSH
28012: LD_VAR 0 3
28016: ARRAY
28017: DIFF
28018: ST_TO_ADDR
// end ;
28019: GO 27928
28021: POP
28022: POP
// if p then
28023: LD_VAR 0 11
28027: IFFALSE 28052
// result := Replace ( result , 3 , p ) ;
28029: LD_ADDR_VAR 0 2
28033: PUSH
28034: LD_VAR 0 2
28038: PPUSH
28039: LD_INT 3
28041: PPUSH
28042: LD_VAR 0 11
28046: PPUSH
28047: CALL_OW 1
28051: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28052: LD_ADDR_VAR 0 4
28056: PUSH
28057: LD_VAR 0 4
28061: PUSH
28062: LD_VAR 0 6
28066: DIFF
28067: ST_TO_ADDR
// if tmp and eng < 4 then
28068: LD_VAR 0 4
28072: PUSH
28073: LD_VAR 0 6
28077: PUSH
28078: LD_INT 4
28080: LESS
28081: AND
28082: IFFALSE 28272
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
28084: LD_ADDR_VAR 0 9
28088: PUSH
28089: LD_VAR 0 4
28093: PUSH
28094: LD_VAR 0 7
28098: PUSH
28099: LD_VAR 0 6
28103: UNION
28104: DIFF
28105: PPUSH
28106: LD_INT 2
28108: PPUSH
28109: CALL 91735 0 2
28113: ST_TO_ADDR
// p := [ ] ;
28114: LD_ADDR_VAR 0 11
28118: PUSH
28119: EMPTY
28120: ST_TO_ADDR
// if sort then
28121: LD_VAR 0 9
28125: IFFALSE 28241
// for i = 1 to 4 - eng do
28127: LD_ADDR_VAR 0 3
28131: PUSH
28132: DOUBLE
28133: LD_INT 1
28135: DEC
28136: ST_TO_ADDR
28137: LD_INT 4
28139: PUSH
28140: LD_VAR 0 6
28144: MINUS
28145: PUSH
28146: FOR_TO
28147: IFFALSE 28239
// begin if i = sort then
28149: LD_VAR 0 3
28153: PUSH
28154: LD_VAR 0 9
28158: EQUAL
28159: IFFALSE 28163
// break ;
28161: GO 28239
// if GetClass ( i ) = 2 then
28163: LD_VAR 0 3
28167: PPUSH
28168: CALL_OW 257
28172: PUSH
28173: LD_INT 2
28175: EQUAL
28176: IFFALSE 28180
// continue ;
28178: GO 28146
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28180: LD_ADDR_VAR 0 11
28184: PUSH
28185: LD_VAR 0 11
28189: PPUSH
28190: LD_VAR 0 11
28194: PUSH
28195: LD_INT 1
28197: PLUS
28198: PPUSH
28199: LD_VAR 0 9
28203: PUSH
28204: LD_VAR 0 3
28208: ARRAY
28209: PPUSH
28210: CALL_OW 2
28214: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28215: LD_ADDR_VAR 0 4
28219: PUSH
28220: LD_VAR 0 4
28224: PUSH
28225: LD_VAR 0 9
28229: PUSH
28230: LD_VAR 0 3
28234: ARRAY
28235: DIFF
28236: ST_TO_ADDR
// end ;
28237: GO 28146
28239: POP
28240: POP
// if p then
28241: LD_VAR 0 11
28245: IFFALSE 28270
// result := Replace ( result , 2 , p ) ;
28247: LD_ADDR_VAR 0 2
28251: PUSH
28252: LD_VAR 0 2
28256: PPUSH
28257: LD_INT 2
28259: PPUSH
28260: LD_VAR 0 11
28264: PPUSH
28265: CALL_OW 1
28269: ST_TO_ADDR
// end else
28270: GO 28316
// for i = eng downto 5 do
28272: LD_ADDR_VAR 0 3
28276: PUSH
28277: DOUBLE
28278: LD_VAR 0 6
28282: INC
28283: ST_TO_ADDR
28284: LD_INT 5
28286: PUSH
28287: FOR_DOWNTO
28288: IFFALSE 28314
// tmp := tmp union eng [ i ] ;
28290: LD_ADDR_VAR 0 4
28294: PUSH
28295: LD_VAR 0 4
28299: PUSH
28300: LD_VAR 0 6
28304: PUSH
28305: LD_VAR 0 3
28309: ARRAY
28310: UNION
28311: ST_TO_ADDR
28312: GO 28287
28314: POP
28315: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
28316: LD_ADDR_VAR 0 2
28320: PUSH
28321: LD_VAR 0 2
28325: PPUSH
28326: LD_INT 1
28328: PPUSH
28329: LD_VAR 0 4
28333: PUSH
28334: LD_VAR 0 5
28338: DIFF
28339: PPUSH
28340: CALL_OW 1
28344: ST_TO_ADDR
// exit ;
28345: GO 28347
// end ; end ;
28347: LD_VAR 0 2
28351: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
28352: LD_INT 0
28354: PPUSH
28355: PPUSH
28356: PPUSH
// if not mc_bases then
28357: LD_EXP 74
28361: NOT
28362: IFFALSE 28366
// exit ;
28364: GO 28472
// for i = 1 to mc_bases do
28366: LD_ADDR_VAR 0 2
28370: PUSH
28371: DOUBLE
28372: LD_INT 1
28374: DEC
28375: ST_TO_ADDR
28376: LD_EXP 74
28380: PUSH
28381: FOR_TO
28382: IFFALSE 28463
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
28384: LD_ADDR_VAR 0 3
28388: PUSH
28389: LD_EXP 74
28393: PUSH
28394: LD_VAR 0 2
28398: ARRAY
28399: PPUSH
28400: LD_INT 21
28402: PUSH
28403: LD_INT 3
28405: PUSH
28406: EMPTY
28407: LIST
28408: LIST
28409: PUSH
28410: LD_INT 3
28412: PUSH
28413: LD_INT 24
28415: PUSH
28416: LD_INT 1000
28418: PUSH
28419: EMPTY
28420: LIST
28421: LIST
28422: PUSH
28423: EMPTY
28424: LIST
28425: LIST
28426: PUSH
28427: EMPTY
28428: LIST
28429: LIST
28430: PPUSH
28431: CALL_OW 72
28435: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
28436: LD_ADDR_EXP 75
28440: PUSH
28441: LD_EXP 75
28445: PPUSH
28446: LD_VAR 0 2
28450: PPUSH
28451: LD_VAR 0 3
28455: PPUSH
28456: CALL_OW 1
28460: ST_TO_ADDR
// end ;
28461: GO 28381
28463: POP
28464: POP
// RaiseSailEvent ( 101 ) ;
28465: LD_INT 101
28467: PPUSH
28468: CALL_OW 427
// end ;
28472: LD_VAR 0 1
28476: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
28477: LD_INT 0
28479: PPUSH
28480: PPUSH
28481: PPUSH
28482: PPUSH
28483: PPUSH
28484: PPUSH
28485: PPUSH
// if not mc_bases then
28486: LD_EXP 74
28490: NOT
28491: IFFALSE 28495
// exit ;
28493: GO 29068
// for i = 1 to mc_bases do
28495: LD_ADDR_VAR 0 2
28499: PUSH
28500: DOUBLE
28501: LD_INT 1
28503: DEC
28504: ST_TO_ADDR
28505: LD_EXP 74
28509: PUSH
28510: FOR_TO
28511: IFFALSE 29059
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
28513: LD_ADDR_VAR 0 5
28517: PUSH
28518: LD_EXP 74
28522: PUSH
28523: LD_VAR 0 2
28527: ARRAY
28528: PUSH
28529: LD_EXP 103
28533: PUSH
28534: LD_VAR 0 2
28538: ARRAY
28539: UNION
28540: PPUSH
28541: LD_INT 21
28543: PUSH
28544: LD_INT 1
28546: PUSH
28547: EMPTY
28548: LIST
28549: LIST
28550: PUSH
28551: LD_INT 1
28553: PUSH
28554: LD_INT 3
28556: PUSH
28557: LD_INT 54
28559: PUSH
28560: EMPTY
28561: LIST
28562: PUSH
28563: EMPTY
28564: LIST
28565: LIST
28566: PUSH
28567: LD_INT 3
28569: PUSH
28570: LD_INT 24
28572: PUSH
28573: LD_INT 800
28575: PUSH
28576: EMPTY
28577: LIST
28578: LIST
28579: PUSH
28580: EMPTY
28581: LIST
28582: LIST
28583: PUSH
28584: EMPTY
28585: LIST
28586: LIST
28587: LIST
28588: PUSH
28589: EMPTY
28590: LIST
28591: LIST
28592: PPUSH
28593: CALL_OW 72
28597: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
28598: LD_ADDR_VAR 0 6
28602: PUSH
28603: LD_EXP 74
28607: PUSH
28608: LD_VAR 0 2
28612: ARRAY
28613: PPUSH
28614: LD_INT 21
28616: PUSH
28617: LD_INT 1
28619: PUSH
28620: EMPTY
28621: LIST
28622: LIST
28623: PUSH
28624: LD_INT 1
28626: PUSH
28627: LD_INT 3
28629: PUSH
28630: LD_INT 54
28632: PUSH
28633: EMPTY
28634: LIST
28635: PUSH
28636: EMPTY
28637: LIST
28638: LIST
28639: PUSH
28640: LD_INT 3
28642: PUSH
28643: LD_INT 24
28645: PUSH
28646: LD_INT 250
28648: PUSH
28649: EMPTY
28650: LIST
28651: LIST
28652: PUSH
28653: EMPTY
28654: LIST
28655: LIST
28656: PUSH
28657: EMPTY
28658: LIST
28659: LIST
28660: LIST
28661: PUSH
28662: EMPTY
28663: LIST
28664: LIST
28665: PPUSH
28666: CALL_OW 72
28670: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
28671: LD_ADDR_VAR 0 7
28675: PUSH
28676: LD_VAR 0 5
28680: PUSH
28681: LD_VAR 0 6
28685: DIFF
28686: ST_TO_ADDR
// if not need_heal_1 then
28687: LD_VAR 0 6
28691: NOT
28692: IFFALSE 28725
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
28694: LD_ADDR_EXP 77
28698: PUSH
28699: LD_EXP 77
28703: PPUSH
28704: LD_VAR 0 2
28708: PUSH
28709: LD_INT 1
28711: PUSH
28712: EMPTY
28713: LIST
28714: LIST
28715: PPUSH
28716: EMPTY
28717: PPUSH
28718: CALL 57487 0 3
28722: ST_TO_ADDR
28723: GO 28795
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
28725: LD_ADDR_EXP 77
28729: PUSH
28730: LD_EXP 77
28734: PPUSH
28735: LD_VAR 0 2
28739: PUSH
28740: LD_INT 1
28742: PUSH
28743: EMPTY
28744: LIST
28745: LIST
28746: PPUSH
28747: LD_EXP 77
28751: PUSH
28752: LD_VAR 0 2
28756: ARRAY
28757: PUSH
28758: LD_INT 1
28760: ARRAY
28761: PPUSH
28762: LD_INT 3
28764: PUSH
28765: LD_INT 24
28767: PUSH
28768: LD_INT 1000
28770: PUSH
28771: EMPTY
28772: LIST
28773: LIST
28774: PUSH
28775: EMPTY
28776: LIST
28777: LIST
28778: PPUSH
28779: CALL_OW 72
28783: PUSH
28784: LD_VAR 0 6
28788: UNION
28789: PPUSH
28790: CALL 57487 0 3
28794: ST_TO_ADDR
// if not need_heal_2 then
28795: LD_VAR 0 7
28799: NOT
28800: IFFALSE 28833
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
28802: LD_ADDR_EXP 77
28806: PUSH
28807: LD_EXP 77
28811: PPUSH
28812: LD_VAR 0 2
28816: PUSH
28817: LD_INT 2
28819: PUSH
28820: EMPTY
28821: LIST
28822: LIST
28823: PPUSH
28824: EMPTY
28825: PPUSH
28826: CALL 57487 0 3
28830: ST_TO_ADDR
28831: GO 28865
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
28833: LD_ADDR_EXP 77
28837: PUSH
28838: LD_EXP 77
28842: PPUSH
28843: LD_VAR 0 2
28847: PUSH
28848: LD_INT 2
28850: PUSH
28851: EMPTY
28852: LIST
28853: LIST
28854: PPUSH
28855: LD_VAR 0 7
28859: PPUSH
28860: CALL 57487 0 3
28864: ST_TO_ADDR
// if need_heal_2 then
28865: LD_VAR 0 7
28869: IFFALSE 29041
// for j in need_heal_2 do
28871: LD_ADDR_VAR 0 3
28875: PUSH
28876: LD_VAR 0 7
28880: PUSH
28881: FOR_IN
28882: IFFALSE 29039
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
28884: LD_ADDR_VAR 0 5
28888: PUSH
28889: LD_EXP 74
28893: PUSH
28894: LD_VAR 0 2
28898: ARRAY
28899: PPUSH
28900: LD_INT 2
28902: PUSH
28903: LD_INT 30
28905: PUSH
28906: LD_INT 6
28908: PUSH
28909: EMPTY
28910: LIST
28911: LIST
28912: PUSH
28913: LD_INT 30
28915: PUSH
28916: LD_INT 7
28918: PUSH
28919: EMPTY
28920: LIST
28921: LIST
28922: PUSH
28923: LD_INT 30
28925: PUSH
28926: LD_INT 8
28928: PUSH
28929: EMPTY
28930: LIST
28931: LIST
28932: PUSH
28933: LD_INT 30
28935: PUSH
28936: LD_INT 0
28938: PUSH
28939: EMPTY
28940: LIST
28941: LIST
28942: PUSH
28943: LD_INT 30
28945: PUSH
28946: LD_INT 1
28948: PUSH
28949: EMPTY
28950: LIST
28951: LIST
28952: PUSH
28953: LD_INT 25
28955: PUSH
28956: LD_INT 4
28958: PUSH
28959: EMPTY
28960: LIST
28961: LIST
28962: PUSH
28963: EMPTY
28964: LIST
28965: LIST
28966: LIST
28967: LIST
28968: LIST
28969: LIST
28970: LIST
28971: PPUSH
28972: CALL_OW 72
28976: ST_TO_ADDR
// if tmp then
28977: LD_VAR 0 5
28981: IFFALSE 29037
// begin k := NearestUnitToUnit ( tmp , j ) ;
28983: LD_ADDR_VAR 0 4
28987: PUSH
28988: LD_VAR 0 5
28992: PPUSH
28993: LD_VAR 0 3
28997: PPUSH
28998: CALL_OW 74
29002: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
29003: LD_VAR 0 3
29007: PPUSH
29008: LD_VAR 0 4
29012: PPUSH
29013: CALL_OW 296
29017: PUSH
29018: LD_INT 7
29020: GREATER
29021: IFFALSE 29037
// ComMoveUnit ( j , k ) ;
29023: LD_VAR 0 3
29027: PPUSH
29028: LD_VAR 0 4
29032: PPUSH
29033: CALL_OW 112
// end ; end ;
29037: GO 28881
29039: POP
29040: POP
// if not need_heal_1 and not need_heal_2 then
29041: LD_VAR 0 6
29045: NOT
29046: PUSH
29047: LD_VAR 0 7
29051: NOT
29052: AND
29053: IFFALSE 29057
// continue ;
29055: GO 28510
// end ;
29057: GO 28510
29059: POP
29060: POP
// RaiseSailEvent ( 102 ) ;
29061: LD_INT 102
29063: PPUSH
29064: CALL_OW 427
// end ;
29068: LD_VAR 0 1
29072: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes ; begin
29073: LD_INT 0
29075: PPUSH
29076: PPUSH
29077: PPUSH
29078: PPUSH
29079: PPUSH
29080: PPUSH
// if not mc_bases then
29081: LD_EXP 74
29085: NOT
29086: IFFALSE 29090
// exit ;
29088: GO 29800
// for i = 1 to mc_bases do
29090: LD_ADDR_VAR 0 2
29094: PUSH
29095: DOUBLE
29096: LD_INT 1
29098: DEC
29099: ST_TO_ADDR
29100: LD_EXP 74
29104: PUSH
29105: FOR_TO
29106: IFFALSE 29798
// begin if not mc_building_need_repair [ i ] then
29108: LD_EXP 75
29112: PUSH
29113: LD_VAR 0 2
29117: ARRAY
29118: NOT
29119: IFFALSE 29293
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
29121: LD_ADDR_VAR 0 6
29125: PUSH
29126: LD_EXP 93
29130: PUSH
29131: LD_VAR 0 2
29135: ARRAY
29136: PPUSH
29137: LD_INT 3
29139: PUSH
29140: LD_INT 24
29142: PUSH
29143: LD_INT 1000
29145: PUSH
29146: EMPTY
29147: LIST
29148: LIST
29149: PUSH
29150: EMPTY
29151: LIST
29152: LIST
29153: PUSH
29154: LD_INT 2
29156: PUSH
29157: LD_INT 34
29159: PUSH
29160: LD_INT 13
29162: PUSH
29163: EMPTY
29164: LIST
29165: LIST
29166: PUSH
29167: LD_INT 34
29169: PUSH
29170: LD_INT 52
29172: PUSH
29173: EMPTY
29174: LIST
29175: LIST
29176: PUSH
29177: EMPTY
29178: LIST
29179: LIST
29180: LIST
29181: PUSH
29182: EMPTY
29183: LIST
29184: LIST
29185: PPUSH
29186: CALL_OW 72
29190: ST_TO_ADDR
// if cranes then
29191: LD_VAR 0 6
29195: IFFALSE 29257
// for j in cranes do
29197: LD_ADDR_VAR 0 3
29201: PUSH
29202: LD_VAR 0 6
29206: PUSH
29207: FOR_IN
29208: IFFALSE 29255
// if not IsInArea ( j , mc_parking [ i ] ) then
29210: LD_VAR 0 3
29214: PPUSH
29215: LD_EXP 98
29219: PUSH
29220: LD_VAR 0 2
29224: ARRAY
29225: PPUSH
29226: CALL_OW 308
29230: NOT
29231: IFFALSE 29253
// ComMoveToArea ( j , mc_parking [ i ] ) ;
29233: LD_VAR 0 3
29237: PPUSH
29238: LD_EXP 98
29242: PUSH
29243: LD_VAR 0 2
29247: ARRAY
29248: PPUSH
29249: CALL_OW 113
29253: GO 29207
29255: POP
29256: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
29257: LD_ADDR_EXP 76
29261: PUSH
29262: LD_EXP 76
29266: PPUSH
29267: LD_VAR 0 2
29271: PPUSH
29272: EMPTY
29273: PPUSH
29274: CALL_OW 1
29278: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
29279: LD_VAR 0 2
29283: PPUSH
29284: LD_INT 101
29286: PPUSH
29287: CALL 24185 0 2
// continue ;
29291: GO 29105
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
29293: LD_ADDR_EXP 80
29297: PUSH
29298: LD_EXP 80
29302: PPUSH
29303: LD_VAR 0 2
29307: PPUSH
29308: EMPTY
29309: PPUSH
29310: CALL_OW 1
29314: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
29315: LD_VAR 0 2
29319: PPUSH
29320: LD_INT 103
29322: PPUSH
29323: CALL 24185 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
29327: LD_ADDR_VAR 0 5
29331: PUSH
29332: LD_EXP 74
29336: PUSH
29337: LD_VAR 0 2
29341: ARRAY
29342: PUSH
29343: LD_EXP 103
29347: PUSH
29348: LD_VAR 0 2
29352: ARRAY
29353: UNION
29354: PPUSH
29355: LD_INT 2
29357: PUSH
29358: LD_INT 25
29360: PUSH
29361: LD_INT 2
29363: PUSH
29364: EMPTY
29365: LIST
29366: LIST
29367: PUSH
29368: LD_INT 25
29370: PUSH
29371: LD_INT 16
29373: PUSH
29374: EMPTY
29375: LIST
29376: LIST
29377: PUSH
29378: EMPTY
29379: LIST
29380: LIST
29381: LIST
29382: PUSH
29383: EMPTY
29384: LIST
29385: PPUSH
29386: CALL_OW 72
29390: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
29391: LD_ADDR_VAR 0 6
29395: PUSH
29396: LD_EXP 93
29400: PUSH
29401: LD_VAR 0 2
29405: ARRAY
29406: PPUSH
29407: LD_INT 2
29409: PUSH
29410: LD_INT 34
29412: PUSH
29413: LD_INT 13
29415: PUSH
29416: EMPTY
29417: LIST
29418: LIST
29419: PUSH
29420: LD_INT 34
29422: PUSH
29423: LD_INT 52
29425: PUSH
29426: EMPTY
29427: LIST
29428: LIST
29429: PUSH
29430: EMPTY
29431: LIST
29432: LIST
29433: LIST
29434: PPUSH
29435: CALL_OW 72
29439: ST_TO_ADDR
// if cranes then
29440: LD_VAR 0 6
29444: IFFALSE 29580
// begin for j in cranes do
29446: LD_ADDR_VAR 0 3
29450: PUSH
29451: LD_VAR 0 6
29455: PUSH
29456: FOR_IN
29457: IFFALSE 29578
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
29459: LD_VAR 0 3
29463: PPUSH
29464: CALL_OW 256
29468: PUSH
29469: LD_INT 500
29471: GREATEREQUAL
29472: PUSH
29473: LD_VAR 0 3
29477: PPUSH
29478: CALL_OW 314
29482: NOT
29483: AND
29484: IFFALSE 29518
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
29486: LD_VAR 0 3
29490: PPUSH
29491: LD_EXP 75
29495: PUSH
29496: LD_VAR 0 2
29500: ARRAY
29501: PPUSH
29502: LD_VAR 0 3
29506: PPUSH
29507: CALL_OW 74
29511: PPUSH
29512: CALL_OW 130
29516: GO 29576
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
29518: LD_VAR 0 3
29522: PPUSH
29523: CALL_OW 256
29527: PUSH
29528: LD_INT 500
29530: LESS
29531: PUSH
29532: LD_VAR 0 3
29536: PPUSH
29537: LD_EXP 98
29541: PUSH
29542: LD_VAR 0 2
29546: ARRAY
29547: PPUSH
29548: CALL_OW 308
29552: NOT
29553: AND
29554: IFFALSE 29576
// ComMoveToArea ( j , mc_parking [ i ] ) ;
29556: LD_VAR 0 3
29560: PPUSH
29561: LD_EXP 98
29565: PUSH
29566: LD_VAR 0 2
29570: ARRAY
29571: PPUSH
29572: CALL_OW 113
29576: GO 29456
29578: POP
29579: POP
// end ; if not tmp then
29580: LD_VAR 0 5
29584: NOT
29585: IFFALSE 29589
// continue ;
29587: GO 29105
// for j in tmp do
29589: LD_ADDR_VAR 0 3
29593: PUSH
29594: LD_VAR 0 5
29598: PUSH
29599: FOR_IN
29600: IFFALSE 29794
// begin if mc_need_heal [ i ] then
29602: LD_EXP 77
29606: PUSH
29607: LD_VAR 0 2
29611: ARRAY
29612: IFFALSE 29660
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
29614: LD_VAR 0 3
29618: PUSH
29619: LD_EXP 77
29623: PUSH
29624: LD_VAR 0 2
29628: ARRAY
29629: PUSH
29630: LD_INT 1
29632: ARRAY
29633: IN
29634: PUSH
29635: LD_VAR 0 3
29639: PUSH
29640: LD_EXP 77
29644: PUSH
29645: LD_VAR 0 2
29649: ARRAY
29650: PUSH
29651: LD_INT 2
29653: ARRAY
29654: IN
29655: OR
29656: IFFALSE 29660
// continue ;
29658: GO 29599
// if IsInUnit ( j ) then
29660: LD_VAR 0 3
29664: PPUSH
29665: CALL_OW 310
29669: IFFALSE 29680
// ComExitBuilding ( j ) ;
29671: LD_VAR 0 3
29675: PPUSH
29676: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
29680: LD_VAR 0 3
29684: PUSH
29685: LD_EXP 76
29689: PUSH
29690: LD_VAR 0 2
29694: ARRAY
29695: IN
29696: NOT
29697: IFFALSE 29755
// begin SetTag ( j , 101 ) ;
29699: LD_VAR 0 3
29703: PPUSH
29704: LD_INT 101
29706: PPUSH
29707: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
29711: LD_ADDR_EXP 76
29715: PUSH
29716: LD_EXP 76
29720: PPUSH
29721: LD_VAR 0 2
29725: PUSH
29726: LD_EXP 76
29730: PUSH
29731: LD_VAR 0 2
29735: ARRAY
29736: PUSH
29737: LD_INT 1
29739: PLUS
29740: PUSH
29741: EMPTY
29742: LIST
29743: LIST
29744: PPUSH
29745: LD_VAR 0 3
29749: PPUSH
29750: CALL 57487 0 3
29754: ST_TO_ADDR
// end ; wait ( 1 ) ;
29755: LD_INT 1
29757: PPUSH
29758: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
29762: LD_VAR 0 3
29766: PPUSH
29767: LD_EXP 75
29771: PUSH
29772: LD_VAR 0 2
29776: ARRAY
29777: PPUSH
29778: LD_VAR 0 3
29782: PPUSH
29783: CALL_OW 74
29787: PPUSH
29788: CALL_OW 130
// end ;
29792: GO 29599
29794: POP
29795: POP
// end ;
29796: GO 29105
29798: POP
29799: POP
// end ;
29800: LD_VAR 0 1
29804: RET
// export function MC_Heal ; var i , j , tmp ; begin
29805: LD_INT 0
29807: PPUSH
29808: PPUSH
29809: PPUSH
29810: PPUSH
// if not mc_bases then
29811: LD_EXP 74
29815: NOT
29816: IFFALSE 29820
// exit ;
29818: GO 30222
// for i = 1 to mc_bases do
29820: LD_ADDR_VAR 0 2
29824: PUSH
29825: DOUBLE
29826: LD_INT 1
29828: DEC
29829: ST_TO_ADDR
29830: LD_EXP 74
29834: PUSH
29835: FOR_TO
29836: IFFALSE 30220
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
29838: LD_EXP 77
29842: PUSH
29843: LD_VAR 0 2
29847: ARRAY
29848: PUSH
29849: LD_INT 1
29851: ARRAY
29852: NOT
29853: PUSH
29854: LD_EXP 77
29858: PUSH
29859: LD_VAR 0 2
29863: ARRAY
29864: PUSH
29865: LD_INT 2
29867: ARRAY
29868: NOT
29869: AND
29870: IFFALSE 29908
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
29872: LD_ADDR_EXP 78
29876: PUSH
29877: LD_EXP 78
29881: PPUSH
29882: LD_VAR 0 2
29886: PPUSH
29887: EMPTY
29888: PPUSH
29889: CALL_OW 1
29893: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
29894: LD_VAR 0 2
29898: PPUSH
29899: LD_INT 102
29901: PPUSH
29902: CALL 24185 0 2
// continue ;
29906: GO 29835
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
29908: LD_ADDR_VAR 0 4
29912: PUSH
29913: LD_EXP 74
29917: PUSH
29918: LD_VAR 0 2
29922: ARRAY
29923: PPUSH
29924: LD_INT 25
29926: PUSH
29927: LD_INT 4
29929: PUSH
29930: EMPTY
29931: LIST
29932: LIST
29933: PPUSH
29934: CALL_OW 72
29938: ST_TO_ADDR
// if not tmp then
29939: LD_VAR 0 4
29943: NOT
29944: IFFALSE 29948
// continue ;
29946: GO 29835
// if mc_taming [ i ] then
29948: LD_EXP 105
29952: PUSH
29953: LD_VAR 0 2
29957: ARRAY
29958: IFFALSE 29982
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
29960: LD_ADDR_EXP 105
29964: PUSH
29965: LD_EXP 105
29969: PPUSH
29970: LD_VAR 0 2
29974: PPUSH
29975: EMPTY
29976: PPUSH
29977: CALL_OW 1
29981: ST_TO_ADDR
// for j in tmp do
29982: LD_ADDR_VAR 0 3
29986: PUSH
29987: LD_VAR 0 4
29991: PUSH
29992: FOR_IN
29993: IFFALSE 30216
// begin if IsInUnit ( j ) then
29995: LD_VAR 0 3
29999: PPUSH
30000: CALL_OW 310
30004: IFFALSE 30015
// ComExitBuilding ( j ) ;
30006: LD_VAR 0 3
30010: PPUSH
30011: CALL_OW 122
// if not j in mc_healers [ i ] then
30015: LD_VAR 0 3
30019: PUSH
30020: LD_EXP 78
30024: PUSH
30025: LD_VAR 0 2
30029: ARRAY
30030: IN
30031: NOT
30032: IFFALSE 30078
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
30034: LD_ADDR_EXP 78
30038: PUSH
30039: LD_EXP 78
30043: PPUSH
30044: LD_VAR 0 2
30048: PUSH
30049: LD_EXP 78
30053: PUSH
30054: LD_VAR 0 2
30058: ARRAY
30059: PUSH
30060: LD_INT 1
30062: PLUS
30063: PUSH
30064: EMPTY
30065: LIST
30066: LIST
30067: PPUSH
30068: LD_VAR 0 3
30072: PPUSH
30073: CALL 57487 0 3
30077: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
30078: LD_VAR 0 3
30082: PPUSH
30083: CALL_OW 110
30087: PUSH
30088: LD_INT 102
30090: NONEQUAL
30091: IFFALSE 30105
// SetTag ( j , 102 ) ;
30093: LD_VAR 0 3
30097: PPUSH
30098: LD_INT 102
30100: PPUSH
30101: CALL_OW 109
// Wait ( 3 ) ;
30105: LD_INT 3
30107: PPUSH
30108: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
30112: LD_EXP 77
30116: PUSH
30117: LD_VAR 0 2
30121: ARRAY
30122: PUSH
30123: LD_INT 1
30125: ARRAY
30126: IFFALSE 30158
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
30128: LD_VAR 0 3
30132: PPUSH
30133: LD_EXP 77
30137: PUSH
30138: LD_VAR 0 2
30142: ARRAY
30143: PUSH
30144: LD_INT 1
30146: ARRAY
30147: PUSH
30148: LD_INT 1
30150: ARRAY
30151: PPUSH
30152: CALL_OW 128
30156: GO 30214
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
30158: LD_VAR 0 3
30162: PPUSH
30163: CALL_OW 314
30167: NOT
30168: PUSH
30169: LD_EXP 77
30173: PUSH
30174: LD_VAR 0 2
30178: ARRAY
30179: PUSH
30180: LD_INT 2
30182: ARRAY
30183: AND
30184: IFFALSE 30214
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
30186: LD_VAR 0 3
30190: PPUSH
30191: LD_EXP 77
30195: PUSH
30196: LD_VAR 0 2
30200: ARRAY
30201: PUSH
30202: LD_INT 2
30204: ARRAY
30205: PUSH
30206: LD_INT 1
30208: ARRAY
30209: PPUSH
30210: CALL_OW 128
// end ;
30214: GO 29992
30216: POP
30217: POP
// end ;
30218: GO 29835
30220: POP
30221: POP
// end ;
30222: LD_VAR 0 1
30226: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
30227: LD_INT 0
30229: PPUSH
30230: PPUSH
30231: PPUSH
30232: PPUSH
30233: PPUSH
// if not mc_bases then
30234: LD_EXP 74
30238: NOT
30239: IFFALSE 30243
// exit ;
30241: GO 31386
// for i = 1 to mc_bases do
30243: LD_ADDR_VAR 0 2
30247: PUSH
30248: DOUBLE
30249: LD_INT 1
30251: DEC
30252: ST_TO_ADDR
30253: LD_EXP 74
30257: PUSH
30258: FOR_TO
30259: IFFALSE 31384
// begin if mc_scan [ i ] then
30261: LD_EXP 97
30265: PUSH
30266: LD_VAR 0 2
30270: ARRAY
30271: IFFALSE 30275
// continue ;
30273: GO 30258
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
30275: LD_EXP 79
30279: PUSH
30280: LD_VAR 0 2
30284: ARRAY
30285: NOT
30286: PUSH
30287: LD_EXP 81
30291: PUSH
30292: LD_VAR 0 2
30296: ARRAY
30297: NOT
30298: AND
30299: PUSH
30300: LD_EXP 80
30304: PUSH
30305: LD_VAR 0 2
30309: ARRAY
30310: AND
30311: IFFALSE 30349
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
30313: LD_ADDR_EXP 80
30317: PUSH
30318: LD_EXP 80
30322: PPUSH
30323: LD_VAR 0 2
30327: PPUSH
30328: EMPTY
30329: PPUSH
30330: CALL_OW 1
30334: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
30335: LD_VAR 0 2
30339: PPUSH
30340: LD_INT 103
30342: PPUSH
30343: CALL 24185 0 2
// continue ;
30347: GO 30258
// end ; if mc_construct_list [ i ] then
30349: LD_EXP 81
30353: PUSH
30354: LD_VAR 0 2
30358: ARRAY
30359: IFFALSE 30579
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
30361: LD_ADDR_VAR 0 4
30365: PUSH
30366: LD_EXP 74
30370: PUSH
30371: LD_VAR 0 2
30375: ARRAY
30376: PPUSH
30377: LD_INT 25
30379: PUSH
30380: LD_INT 2
30382: PUSH
30383: EMPTY
30384: LIST
30385: LIST
30386: PPUSH
30387: CALL_OW 72
30391: PUSH
30392: LD_EXP 76
30396: PUSH
30397: LD_VAR 0 2
30401: ARRAY
30402: DIFF
30403: ST_TO_ADDR
// if not tmp then
30404: LD_VAR 0 4
30408: NOT
30409: IFFALSE 30413
// continue ;
30411: GO 30258
// for j in tmp do
30413: LD_ADDR_VAR 0 3
30417: PUSH
30418: LD_VAR 0 4
30422: PUSH
30423: FOR_IN
30424: IFFALSE 30575
// begin if not mc_builders [ i ] then
30426: LD_EXP 80
30430: PUSH
30431: LD_VAR 0 2
30435: ARRAY
30436: NOT
30437: IFFALSE 30495
// begin SetTag ( j , 103 ) ;
30439: LD_VAR 0 3
30443: PPUSH
30444: LD_INT 103
30446: PPUSH
30447: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
30451: LD_ADDR_EXP 80
30455: PUSH
30456: LD_EXP 80
30460: PPUSH
30461: LD_VAR 0 2
30465: PUSH
30466: LD_EXP 80
30470: PUSH
30471: LD_VAR 0 2
30475: ARRAY
30476: PUSH
30477: LD_INT 1
30479: PLUS
30480: PUSH
30481: EMPTY
30482: LIST
30483: LIST
30484: PPUSH
30485: LD_VAR 0 3
30489: PPUSH
30490: CALL 57487 0 3
30494: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
30495: LD_VAR 0 3
30499: PPUSH
30500: CALL_OW 310
30504: IFFALSE 30515
// ComExitBuilding ( j ) ;
30506: LD_VAR 0 3
30510: PPUSH
30511: CALL_OW 122
// wait ( 3 ) ;
30515: LD_INT 3
30517: PPUSH
30518: CALL_OW 67
// if not mc_construct_list [ i ] then
30522: LD_EXP 81
30526: PUSH
30527: LD_VAR 0 2
30531: ARRAY
30532: NOT
30533: IFFALSE 30537
// break ;
30535: GO 30575
// if not HasTask ( j ) then
30537: LD_VAR 0 3
30541: PPUSH
30542: CALL_OW 314
30546: NOT
30547: IFFALSE 30573
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
30549: LD_VAR 0 3
30553: PPUSH
30554: LD_EXP 81
30558: PUSH
30559: LD_VAR 0 2
30563: ARRAY
30564: PUSH
30565: LD_INT 1
30567: ARRAY
30568: PPUSH
30569: CALL 60338 0 2
// end ;
30573: GO 30423
30575: POP
30576: POP
// end else
30577: GO 31382
// if mc_build_list [ i ] then
30579: LD_EXP 79
30583: PUSH
30584: LD_VAR 0 2
30588: ARRAY
30589: IFFALSE 31382
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
30591: LD_ADDR_VAR 0 5
30595: PUSH
30596: LD_EXP 74
30600: PUSH
30601: LD_VAR 0 2
30605: ARRAY
30606: PPUSH
30607: LD_INT 2
30609: PUSH
30610: LD_INT 30
30612: PUSH
30613: LD_INT 0
30615: PUSH
30616: EMPTY
30617: LIST
30618: LIST
30619: PUSH
30620: LD_INT 30
30622: PUSH
30623: LD_INT 1
30625: PUSH
30626: EMPTY
30627: LIST
30628: LIST
30629: PUSH
30630: EMPTY
30631: LIST
30632: LIST
30633: LIST
30634: PPUSH
30635: CALL_OW 72
30639: ST_TO_ADDR
// if depot then
30640: LD_VAR 0 5
30644: IFFALSE 30662
// depot := depot [ 1 ] else
30646: LD_ADDR_VAR 0 5
30650: PUSH
30651: LD_VAR 0 5
30655: PUSH
30656: LD_INT 1
30658: ARRAY
30659: ST_TO_ADDR
30660: GO 30670
// depot := 0 ;
30662: LD_ADDR_VAR 0 5
30666: PUSH
30667: LD_INT 0
30669: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
30670: LD_EXP 79
30674: PUSH
30675: LD_VAR 0 2
30679: ARRAY
30680: PUSH
30681: LD_INT 1
30683: ARRAY
30684: PUSH
30685: LD_INT 1
30687: ARRAY
30688: PPUSH
30689: CALL 60168 0 1
30693: PUSH
30694: LD_EXP 74
30698: PUSH
30699: LD_VAR 0 2
30703: ARRAY
30704: PPUSH
30705: LD_INT 2
30707: PUSH
30708: LD_INT 30
30710: PUSH
30711: LD_INT 2
30713: PUSH
30714: EMPTY
30715: LIST
30716: LIST
30717: PUSH
30718: LD_INT 30
30720: PUSH
30721: LD_INT 3
30723: PUSH
30724: EMPTY
30725: LIST
30726: LIST
30727: PUSH
30728: EMPTY
30729: LIST
30730: LIST
30731: LIST
30732: PPUSH
30733: CALL_OW 72
30737: NOT
30738: AND
30739: IFFALSE 30844
// begin for j = 1 to mc_build_list [ i ] do
30741: LD_ADDR_VAR 0 3
30745: PUSH
30746: DOUBLE
30747: LD_INT 1
30749: DEC
30750: ST_TO_ADDR
30751: LD_EXP 79
30755: PUSH
30756: LD_VAR 0 2
30760: ARRAY
30761: PUSH
30762: FOR_TO
30763: IFFALSE 30842
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
30765: LD_EXP 79
30769: PUSH
30770: LD_VAR 0 2
30774: ARRAY
30775: PUSH
30776: LD_VAR 0 3
30780: ARRAY
30781: PUSH
30782: LD_INT 1
30784: ARRAY
30785: PUSH
30786: LD_INT 2
30788: EQUAL
30789: IFFALSE 30840
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
30791: LD_ADDR_EXP 79
30795: PUSH
30796: LD_EXP 79
30800: PPUSH
30801: LD_VAR 0 2
30805: PPUSH
30806: LD_EXP 79
30810: PUSH
30811: LD_VAR 0 2
30815: ARRAY
30816: PPUSH
30817: LD_VAR 0 3
30821: PPUSH
30822: LD_INT 1
30824: PPUSH
30825: LD_INT 0
30827: PPUSH
30828: CALL 56905 0 4
30832: PPUSH
30833: CALL_OW 1
30837: ST_TO_ADDR
// break ;
30838: GO 30842
// end ;
30840: GO 30762
30842: POP
30843: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
30844: LD_EXP 79
30848: PUSH
30849: LD_VAR 0 2
30853: ARRAY
30854: PUSH
30855: LD_INT 1
30857: ARRAY
30858: PUSH
30859: LD_INT 1
30861: ARRAY
30862: PUSH
30863: LD_INT 0
30865: EQUAL
30866: PUSH
30867: LD_VAR 0 5
30871: PUSH
30872: LD_VAR 0 5
30876: PPUSH
30877: LD_EXP 79
30881: PUSH
30882: LD_VAR 0 2
30886: ARRAY
30887: PUSH
30888: LD_INT 1
30890: ARRAY
30891: PUSH
30892: LD_INT 1
30894: ARRAY
30895: PPUSH
30896: LD_EXP 79
30900: PUSH
30901: LD_VAR 0 2
30905: ARRAY
30906: PUSH
30907: LD_INT 1
30909: ARRAY
30910: PUSH
30911: LD_INT 2
30913: ARRAY
30914: PPUSH
30915: LD_EXP 79
30919: PUSH
30920: LD_VAR 0 2
30924: ARRAY
30925: PUSH
30926: LD_INT 1
30928: ARRAY
30929: PUSH
30930: LD_INT 3
30932: ARRAY
30933: PPUSH
30934: LD_EXP 79
30938: PUSH
30939: LD_VAR 0 2
30943: ARRAY
30944: PUSH
30945: LD_INT 1
30947: ARRAY
30948: PUSH
30949: LD_INT 4
30951: ARRAY
30952: PPUSH
30953: CALL 64902 0 5
30957: AND
30958: OR
30959: IFFALSE 31240
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
30961: LD_ADDR_VAR 0 4
30965: PUSH
30966: LD_EXP 74
30970: PUSH
30971: LD_VAR 0 2
30975: ARRAY
30976: PPUSH
30977: LD_INT 25
30979: PUSH
30980: LD_INT 2
30982: PUSH
30983: EMPTY
30984: LIST
30985: LIST
30986: PPUSH
30987: CALL_OW 72
30991: PUSH
30992: LD_EXP 76
30996: PUSH
30997: LD_VAR 0 2
31001: ARRAY
31002: DIFF
31003: ST_TO_ADDR
// if not tmp then
31004: LD_VAR 0 4
31008: NOT
31009: IFFALSE 31013
// continue ;
31011: GO 30258
// for j in tmp do
31013: LD_ADDR_VAR 0 3
31017: PUSH
31018: LD_VAR 0 4
31022: PUSH
31023: FOR_IN
31024: IFFALSE 31236
// begin if not mc_builders [ i ] then
31026: LD_EXP 80
31030: PUSH
31031: LD_VAR 0 2
31035: ARRAY
31036: NOT
31037: IFFALSE 31095
// begin SetTag ( j , 103 ) ;
31039: LD_VAR 0 3
31043: PPUSH
31044: LD_INT 103
31046: PPUSH
31047: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31051: LD_ADDR_EXP 80
31055: PUSH
31056: LD_EXP 80
31060: PPUSH
31061: LD_VAR 0 2
31065: PUSH
31066: LD_EXP 80
31070: PUSH
31071: LD_VAR 0 2
31075: ARRAY
31076: PUSH
31077: LD_INT 1
31079: PLUS
31080: PUSH
31081: EMPTY
31082: LIST
31083: LIST
31084: PPUSH
31085: LD_VAR 0 3
31089: PPUSH
31090: CALL 57487 0 3
31094: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31095: LD_VAR 0 3
31099: PPUSH
31100: CALL_OW 310
31104: IFFALSE 31115
// ComExitBuilding ( j ) ;
31106: LD_VAR 0 3
31110: PPUSH
31111: CALL_OW 122
// wait ( 3 ) ;
31115: LD_INT 3
31117: PPUSH
31118: CALL_OW 67
// if not mc_build_list [ i ] then
31122: LD_EXP 79
31126: PUSH
31127: LD_VAR 0 2
31131: ARRAY
31132: NOT
31133: IFFALSE 31137
// break ;
31135: GO 31236
// if not HasTask ( j ) then
31137: LD_VAR 0 3
31141: PPUSH
31142: CALL_OW 314
31146: NOT
31147: IFFALSE 31234
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
31149: LD_VAR 0 3
31153: PPUSH
31154: LD_EXP 79
31158: PUSH
31159: LD_VAR 0 2
31163: ARRAY
31164: PUSH
31165: LD_INT 1
31167: ARRAY
31168: PUSH
31169: LD_INT 1
31171: ARRAY
31172: PPUSH
31173: LD_EXP 79
31177: PUSH
31178: LD_VAR 0 2
31182: ARRAY
31183: PUSH
31184: LD_INT 1
31186: ARRAY
31187: PUSH
31188: LD_INT 2
31190: ARRAY
31191: PPUSH
31192: LD_EXP 79
31196: PUSH
31197: LD_VAR 0 2
31201: ARRAY
31202: PUSH
31203: LD_INT 1
31205: ARRAY
31206: PUSH
31207: LD_INT 3
31209: ARRAY
31210: PPUSH
31211: LD_EXP 79
31215: PUSH
31216: LD_VAR 0 2
31220: ARRAY
31221: PUSH
31222: LD_INT 1
31224: ARRAY
31225: PUSH
31226: LD_INT 4
31228: ARRAY
31229: PPUSH
31230: CALL_OW 145
// end ;
31234: GO 31023
31236: POP
31237: POP
// end else
31238: GO 31382
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
31240: LD_EXP 74
31244: PUSH
31245: LD_VAR 0 2
31249: ARRAY
31250: PPUSH
31251: LD_EXP 79
31255: PUSH
31256: LD_VAR 0 2
31260: ARRAY
31261: PUSH
31262: LD_INT 1
31264: ARRAY
31265: PUSH
31266: LD_INT 1
31268: ARRAY
31269: PPUSH
31270: LD_EXP 79
31274: PUSH
31275: LD_VAR 0 2
31279: ARRAY
31280: PUSH
31281: LD_INT 1
31283: ARRAY
31284: PUSH
31285: LD_INT 2
31287: ARRAY
31288: PPUSH
31289: LD_EXP 79
31293: PUSH
31294: LD_VAR 0 2
31298: ARRAY
31299: PUSH
31300: LD_INT 1
31302: ARRAY
31303: PUSH
31304: LD_INT 3
31306: ARRAY
31307: PPUSH
31308: LD_EXP 79
31312: PUSH
31313: LD_VAR 0 2
31317: ARRAY
31318: PUSH
31319: LD_INT 1
31321: ARRAY
31322: PUSH
31323: LD_INT 4
31325: ARRAY
31326: PPUSH
31327: CALL 64238 0 5
31331: NOT
31332: IFFALSE 31382
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
31334: LD_ADDR_EXP 79
31338: PUSH
31339: LD_EXP 79
31343: PPUSH
31344: LD_VAR 0 2
31348: PPUSH
31349: LD_EXP 79
31353: PUSH
31354: LD_VAR 0 2
31358: ARRAY
31359: PPUSH
31360: LD_INT 1
31362: PPUSH
31363: LD_INT 1
31365: NEG
31366: PPUSH
31367: LD_INT 0
31369: PPUSH
31370: CALL 56905 0 4
31374: PPUSH
31375: CALL_OW 1
31379: ST_TO_ADDR
// continue ;
31380: GO 30258
// end ; end ; end ;
31382: GO 30258
31384: POP
31385: POP
// end ;
31386: LD_VAR 0 1
31390: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
31391: LD_INT 0
31393: PPUSH
31394: PPUSH
31395: PPUSH
31396: PPUSH
31397: PPUSH
31398: PPUSH
// if not mc_bases then
31399: LD_EXP 74
31403: NOT
31404: IFFALSE 31408
// exit ;
31406: GO 31835
// for i = 1 to mc_bases do
31408: LD_ADDR_VAR 0 2
31412: PUSH
31413: DOUBLE
31414: LD_INT 1
31416: DEC
31417: ST_TO_ADDR
31418: LD_EXP 74
31422: PUSH
31423: FOR_TO
31424: IFFALSE 31833
// begin tmp := mc_build_upgrade [ i ] ;
31426: LD_ADDR_VAR 0 4
31430: PUSH
31431: LD_EXP 106
31435: PUSH
31436: LD_VAR 0 2
31440: ARRAY
31441: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
31442: LD_ADDR_VAR 0 6
31446: PUSH
31447: LD_EXP 107
31451: PUSH
31452: LD_VAR 0 2
31456: ARRAY
31457: PPUSH
31458: LD_INT 2
31460: PUSH
31461: LD_INT 30
31463: PUSH
31464: LD_INT 6
31466: PUSH
31467: EMPTY
31468: LIST
31469: LIST
31470: PUSH
31471: LD_INT 30
31473: PUSH
31474: LD_INT 7
31476: PUSH
31477: EMPTY
31478: LIST
31479: LIST
31480: PUSH
31481: EMPTY
31482: LIST
31483: LIST
31484: LIST
31485: PPUSH
31486: CALL_OW 72
31490: ST_TO_ADDR
// if not tmp and not lab then
31491: LD_VAR 0 4
31495: NOT
31496: PUSH
31497: LD_VAR 0 6
31501: NOT
31502: AND
31503: IFFALSE 31507
// continue ;
31505: GO 31423
// if tmp then
31507: LD_VAR 0 4
31511: IFFALSE 31631
// for j in tmp do
31513: LD_ADDR_VAR 0 3
31517: PUSH
31518: LD_VAR 0 4
31522: PUSH
31523: FOR_IN
31524: IFFALSE 31629
// begin if UpgradeCost ( j ) then
31526: LD_VAR 0 3
31530: PPUSH
31531: CALL 63898 0 1
31535: IFFALSE 31627
// begin ComUpgrade ( j ) ;
31537: LD_VAR 0 3
31541: PPUSH
31542: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
31546: LD_ADDR_EXP 106
31550: PUSH
31551: LD_EXP 106
31555: PPUSH
31556: LD_VAR 0 2
31560: PPUSH
31561: LD_EXP 106
31565: PUSH
31566: LD_VAR 0 2
31570: ARRAY
31571: PUSH
31572: LD_VAR 0 3
31576: DIFF
31577: PPUSH
31578: CALL_OW 1
31582: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
31583: LD_ADDR_EXP 81
31587: PUSH
31588: LD_EXP 81
31592: PPUSH
31593: LD_VAR 0 2
31597: PUSH
31598: LD_EXP 81
31602: PUSH
31603: LD_VAR 0 2
31607: ARRAY
31608: PUSH
31609: LD_INT 1
31611: PLUS
31612: PUSH
31613: EMPTY
31614: LIST
31615: LIST
31616: PPUSH
31617: LD_VAR 0 3
31621: PPUSH
31622: CALL 57487 0 3
31626: ST_TO_ADDR
// end ; end ;
31627: GO 31523
31629: POP
31630: POP
// if not lab or not mc_lab_upgrade [ i ] then
31631: LD_VAR 0 6
31635: NOT
31636: PUSH
31637: LD_EXP 108
31641: PUSH
31642: LD_VAR 0 2
31646: ARRAY
31647: NOT
31648: OR
31649: IFFALSE 31653
// continue ;
31651: GO 31423
// for j in lab do
31653: LD_ADDR_VAR 0 3
31657: PUSH
31658: LD_VAR 0 6
31662: PUSH
31663: FOR_IN
31664: IFFALSE 31829
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
31666: LD_VAR 0 3
31670: PPUSH
31671: CALL_OW 266
31675: PUSH
31676: LD_INT 6
31678: PUSH
31679: LD_INT 7
31681: PUSH
31682: EMPTY
31683: LIST
31684: LIST
31685: IN
31686: PUSH
31687: LD_VAR 0 3
31691: PPUSH
31692: CALL_OW 461
31696: PUSH
31697: LD_INT 1
31699: NONEQUAL
31700: AND
31701: IFFALSE 31827
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
31703: LD_VAR 0 3
31707: PPUSH
31708: LD_EXP 108
31712: PUSH
31713: LD_VAR 0 2
31717: ARRAY
31718: PUSH
31719: LD_INT 1
31721: ARRAY
31722: PPUSH
31723: CALL 64103 0 2
31727: IFFALSE 31827
// begin ComCancel ( j ) ;
31729: LD_VAR 0 3
31733: PPUSH
31734: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
31738: LD_VAR 0 3
31742: PPUSH
31743: LD_EXP 108
31747: PUSH
31748: LD_VAR 0 2
31752: ARRAY
31753: PUSH
31754: LD_INT 1
31756: ARRAY
31757: PPUSH
31758: CALL_OW 207
// if not j in mc_construct_list [ i ] then
31762: LD_VAR 0 3
31766: PUSH
31767: LD_EXP 81
31771: PUSH
31772: LD_VAR 0 2
31776: ARRAY
31777: IN
31778: NOT
31779: IFFALSE 31825
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
31781: LD_ADDR_EXP 81
31785: PUSH
31786: LD_EXP 81
31790: PPUSH
31791: LD_VAR 0 2
31795: PUSH
31796: LD_EXP 81
31800: PUSH
31801: LD_VAR 0 2
31805: ARRAY
31806: PUSH
31807: LD_INT 1
31809: PLUS
31810: PUSH
31811: EMPTY
31812: LIST
31813: LIST
31814: PPUSH
31815: LD_VAR 0 3
31819: PPUSH
31820: CALL 57487 0 3
31824: ST_TO_ADDR
// break ;
31825: GO 31829
// end ; end ; end ;
31827: GO 31663
31829: POP
31830: POP
// end ;
31831: GO 31423
31833: POP
31834: POP
// end ;
31835: LD_VAR 0 1
31839: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
31840: LD_INT 0
31842: PPUSH
31843: PPUSH
31844: PPUSH
31845: PPUSH
31846: PPUSH
31847: PPUSH
31848: PPUSH
31849: PPUSH
31850: PPUSH
// if not mc_bases then
31851: LD_EXP 74
31855: NOT
31856: IFFALSE 31860
// exit ;
31858: GO 32265
// for i = 1 to mc_bases do
31860: LD_ADDR_VAR 0 2
31864: PUSH
31865: DOUBLE
31866: LD_INT 1
31868: DEC
31869: ST_TO_ADDR
31870: LD_EXP 74
31874: PUSH
31875: FOR_TO
31876: IFFALSE 32263
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
31878: LD_EXP 82
31882: PUSH
31883: LD_VAR 0 2
31887: ARRAY
31888: NOT
31889: PUSH
31890: LD_EXP 74
31894: PUSH
31895: LD_VAR 0 2
31899: ARRAY
31900: PPUSH
31901: LD_INT 30
31903: PUSH
31904: LD_INT 3
31906: PUSH
31907: EMPTY
31908: LIST
31909: LIST
31910: PPUSH
31911: CALL_OW 72
31915: NOT
31916: OR
31917: IFFALSE 31921
// continue ;
31919: GO 31875
// busy := false ;
31921: LD_ADDR_VAR 0 8
31925: PUSH
31926: LD_INT 0
31928: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
31929: LD_ADDR_VAR 0 4
31933: PUSH
31934: LD_EXP 74
31938: PUSH
31939: LD_VAR 0 2
31943: ARRAY
31944: PPUSH
31945: LD_INT 30
31947: PUSH
31948: LD_INT 3
31950: PUSH
31951: EMPTY
31952: LIST
31953: LIST
31954: PPUSH
31955: CALL_OW 72
31959: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
31960: LD_ADDR_VAR 0 6
31964: PUSH
31965: LD_EXP 82
31969: PUSH
31970: LD_VAR 0 2
31974: ARRAY
31975: PPUSH
31976: LD_INT 2
31978: PUSH
31979: LD_INT 30
31981: PUSH
31982: LD_INT 32
31984: PUSH
31985: EMPTY
31986: LIST
31987: LIST
31988: PUSH
31989: LD_INT 30
31991: PUSH
31992: LD_INT 33
31994: PUSH
31995: EMPTY
31996: LIST
31997: LIST
31998: PUSH
31999: EMPTY
32000: LIST
32001: LIST
32002: LIST
32003: PPUSH
32004: CALL_OW 72
32008: ST_TO_ADDR
// if not t then
32009: LD_VAR 0 6
32013: NOT
32014: IFFALSE 32018
// continue ;
32016: GO 31875
// for j in tmp do
32018: LD_ADDR_VAR 0 3
32022: PUSH
32023: LD_VAR 0 4
32027: PUSH
32028: FOR_IN
32029: IFFALSE 32059
// if not BuildingStatus ( j ) = bs_idle then
32031: LD_VAR 0 3
32035: PPUSH
32036: CALL_OW 461
32040: PUSH
32041: LD_INT 2
32043: EQUAL
32044: NOT
32045: IFFALSE 32057
// begin busy := true ;
32047: LD_ADDR_VAR 0 8
32051: PUSH
32052: LD_INT 1
32054: ST_TO_ADDR
// break ;
32055: GO 32059
// end ;
32057: GO 32028
32059: POP
32060: POP
// if busy then
32061: LD_VAR 0 8
32065: IFFALSE 32069
// continue ;
32067: GO 31875
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
32069: LD_ADDR_VAR 0 7
32073: PUSH
32074: LD_VAR 0 6
32078: PPUSH
32079: LD_INT 35
32081: PUSH
32082: LD_INT 0
32084: PUSH
32085: EMPTY
32086: LIST
32087: LIST
32088: PPUSH
32089: CALL_OW 72
32093: ST_TO_ADDR
// if tw then
32094: LD_VAR 0 7
32098: IFFALSE 32175
// begin tw := tw [ 1 ] ;
32100: LD_ADDR_VAR 0 7
32104: PUSH
32105: LD_VAR 0 7
32109: PUSH
32110: LD_INT 1
32112: ARRAY
32113: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
32114: LD_ADDR_VAR 0 9
32118: PUSH
32119: LD_VAR 0 7
32123: PPUSH
32124: LD_EXP 99
32128: PUSH
32129: LD_VAR 0 2
32133: ARRAY
32134: PPUSH
32135: CALL 62457 0 2
32139: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
32140: LD_EXP 113
32144: PUSH
32145: LD_VAR 0 2
32149: ARRAY
32150: IFFALSE 32173
// if not weapon in mc_allowed_tower_weapons [ i ] then
32152: LD_VAR 0 9
32156: PUSH
32157: LD_EXP 113
32161: PUSH
32162: LD_VAR 0 2
32166: ARRAY
32167: IN
32168: NOT
32169: IFFALSE 32173
// continue ;
32171: GO 31875
// end else
32173: GO 32238
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
32175: LD_ADDR_VAR 0 5
32179: PUSH
32180: LD_EXP 82
32184: PUSH
32185: LD_VAR 0 2
32189: ARRAY
32190: PPUSH
32191: LD_VAR 0 4
32195: PPUSH
32196: CALL 92658 0 2
32200: ST_TO_ADDR
// if not tmp2 then
32201: LD_VAR 0 5
32205: NOT
32206: IFFALSE 32210
// continue ;
32208: GO 31875
// tw := tmp2 [ 1 ] ;
32210: LD_ADDR_VAR 0 7
32214: PUSH
32215: LD_VAR 0 5
32219: PUSH
32220: LD_INT 1
32222: ARRAY
32223: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
32224: LD_ADDR_VAR 0 9
32228: PUSH
32229: LD_VAR 0 5
32233: PUSH
32234: LD_INT 2
32236: ARRAY
32237: ST_TO_ADDR
// end ; if not weapon then
32238: LD_VAR 0 9
32242: NOT
32243: IFFALSE 32247
// continue ;
32245: GO 31875
// ComPlaceWeapon ( tw , weapon ) ;
32247: LD_VAR 0 7
32251: PPUSH
32252: LD_VAR 0 9
32256: PPUSH
32257: CALL_OW 148
// end ;
32261: GO 31875
32263: POP
32264: POP
// end ;
32265: LD_VAR 0 1
32269: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
32270: LD_INT 0
32272: PPUSH
32273: PPUSH
32274: PPUSH
32275: PPUSH
32276: PPUSH
32277: PPUSH
// if not mc_bases then
32278: LD_EXP 74
32282: NOT
32283: IFFALSE 32287
// exit ;
32285: GO 33299
// for i = 1 to mc_bases do
32287: LD_ADDR_VAR 0 2
32291: PUSH
32292: DOUBLE
32293: LD_INT 1
32295: DEC
32296: ST_TO_ADDR
32297: LD_EXP 74
32301: PUSH
32302: FOR_TO
32303: IFFALSE 33297
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
32305: LD_EXP 87
32309: PUSH
32310: LD_VAR 0 2
32314: ARRAY
32315: NOT
32316: PUSH
32317: LD_EXP 87
32321: PUSH
32322: LD_VAR 0 2
32326: ARRAY
32327: PUSH
32328: LD_EXP 88
32332: PUSH
32333: LD_VAR 0 2
32337: ARRAY
32338: EQUAL
32339: OR
32340: IFFALSE 32344
// continue ;
32342: GO 32302
// if mc_miners [ i ] then
32344: LD_EXP 88
32348: PUSH
32349: LD_VAR 0 2
32353: ARRAY
32354: IFFALSE 32984
// begin k := 1 ;
32356: LD_ADDR_VAR 0 4
32360: PUSH
32361: LD_INT 1
32363: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
32364: LD_ADDR_VAR 0 3
32368: PUSH
32369: DOUBLE
32370: LD_EXP 88
32374: PUSH
32375: LD_VAR 0 2
32379: ARRAY
32380: INC
32381: ST_TO_ADDR
32382: LD_INT 1
32384: PUSH
32385: FOR_DOWNTO
32386: IFFALSE 32982
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
32388: LD_EXP 88
32392: PUSH
32393: LD_VAR 0 2
32397: ARRAY
32398: PUSH
32399: LD_VAR 0 3
32403: ARRAY
32404: PPUSH
32405: CALL_OW 301
32409: PUSH
32410: LD_EXP 88
32414: PUSH
32415: LD_VAR 0 2
32419: ARRAY
32420: PUSH
32421: LD_VAR 0 3
32425: ARRAY
32426: PPUSH
32427: CALL_OW 257
32431: PUSH
32432: LD_INT 1
32434: NONEQUAL
32435: OR
32436: IFFALSE 32499
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
32438: LD_ADDR_VAR 0 5
32442: PUSH
32443: LD_EXP 88
32447: PUSH
32448: LD_VAR 0 2
32452: ARRAY
32453: PUSH
32454: LD_EXP 88
32458: PUSH
32459: LD_VAR 0 2
32463: ARRAY
32464: PUSH
32465: LD_VAR 0 3
32469: ARRAY
32470: DIFF
32471: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
32472: LD_ADDR_EXP 88
32476: PUSH
32477: LD_EXP 88
32481: PPUSH
32482: LD_VAR 0 2
32486: PPUSH
32487: LD_VAR 0 5
32491: PPUSH
32492: CALL_OW 1
32496: ST_TO_ADDR
// continue ;
32497: GO 32385
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
32499: LD_EXP 88
32503: PUSH
32504: LD_VAR 0 2
32508: ARRAY
32509: PUSH
32510: LD_VAR 0 3
32514: ARRAY
32515: PPUSH
32516: CALL 57423 0 1
32520: PUSH
32521: LD_EXP 88
32525: PUSH
32526: LD_VAR 0 2
32530: ARRAY
32531: PUSH
32532: LD_VAR 0 3
32536: ARRAY
32537: PPUSH
32538: CALL_OW 255
32542: PPUSH
32543: LD_EXP 87
32547: PUSH
32548: LD_VAR 0 2
32552: ARRAY
32553: PUSH
32554: LD_VAR 0 4
32558: ARRAY
32559: PUSH
32560: LD_INT 1
32562: ARRAY
32563: PPUSH
32564: LD_EXP 87
32568: PUSH
32569: LD_VAR 0 2
32573: ARRAY
32574: PUSH
32575: LD_VAR 0 4
32579: ARRAY
32580: PUSH
32581: LD_INT 2
32583: ARRAY
32584: PPUSH
32585: LD_INT 15
32587: PPUSH
32588: CALL 58383 0 4
32592: PUSH
32593: LD_INT 4
32595: ARRAY
32596: PUSH
32597: LD_EXP 88
32601: PUSH
32602: LD_VAR 0 2
32606: ARRAY
32607: PUSH
32608: LD_VAR 0 3
32612: ARRAY
32613: PPUSH
32614: LD_INT 10
32616: PPUSH
32617: CALL 60080 0 2
32621: PUSH
32622: LD_INT 4
32624: ARRAY
32625: OR
32626: AND
32627: IFFALSE 32650
// ComStop ( mc_miners [ i ] [ j ] ) ;
32629: LD_EXP 88
32633: PUSH
32634: LD_VAR 0 2
32638: ARRAY
32639: PUSH
32640: LD_VAR 0 3
32644: ARRAY
32645: PPUSH
32646: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
32650: LD_EXP 88
32654: PUSH
32655: LD_VAR 0 2
32659: ARRAY
32660: PUSH
32661: LD_VAR 0 3
32665: ARRAY
32666: PPUSH
32667: CALL_OW 257
32671: PUSH
32672: LD_INT 1
32674: EQUAL
32675: PUSH
32676: LD_EXP 88
32680: PUSH
32681: LD_VAR 0 2
32685: ARRAY
32686: PUSH
32687: LD_VAR 0 3
32691: ARRAY
32692: PPUSH
32693: CALL_OW 459
32697: NOT
32698: AND
32699: PUSH
32700: LD_EXP 88
32704: PUSH
32705: LD_VAR 0 2
32709: ARRAY
32710: PUSH
32711: LD_VAR 0 3
32715: ARRAY
32716: PPUSH
32717: CALL_OW 255
32721: PPUSH
32722: LD_EXP 87
32726: PUSH
32727: LD_VAR 0 2
32731: ARRAY
32732: PUSH
32733: LD_VAR 0 4
32737: ARRAY
32738: PUSH
32739: LD_INT 1
32741: ARRAY
32742: PPUSH
32743: LD_EXP 87
32747: PUSH
32748: LD_VAR 0 2
32752: ARRAY
32753: PUSH
32754: LD_VAR 0 4
32758: ARRAY
32759: PUSH
32760: LD_INT 2
32762: ARRAY
32763: PPUSH
32764: LD_INT 15
32766: PPUSH
32767: CALL 58383 0 4
32771: PUSH
32772: LD_INT 4
32774: ARRAY
32775: PUSH
32776: LD_INT 0
32778: EQUAL
32779: AND
32780: PUSH
32781: LD_EXP 88
32785: PUSH
32786: LD_VAR 0 2
32790: ARRAY
32791: PUSH
32792: LD_VAR 0 3
32796: ARRAY
32797: PPUSH
32798: CALL_OW 314
32802: NOT
32803: AND
32804: IFFALSE 32980
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
32806: LD_EXP 88
32810: PUSH
32811: LD_VAR 0 2
32815: ARRAY
32816: PUSH
32817: LD_VAR 0 3
32821: ARRAY
32822: PPUSH
32823: CALL_OW 310
32827: IFFALSE 32850
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
32829: LD_EXP 88
32833: PUSH
32834: LD_VAR 0 2
32838: ARRAY
32839: PUSH
32840: LD_VAR 0 3
32844: ARRAY
32845: PPUSH
32846: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
32850: LD_EXP 88
32854: PUSH
32855: LD_VAR 0 2
32859: ARRAY
32860: PUSH
32861: LD_VAR 0 3
32865: ARRAY
32866: PPUSH
32867: CALL_OW 314
32871: NOT
32872: IFFALSE 32940
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
32874: LD_EXP 88
32878: PUSH
32879: LD_VAR 0 2
32883: ARRAY
32884: PUSH
32885: LD_VAR 0 3
32889: ARRAY
32890: PPUSH
32891: LD_EXP 87
32895: PUSH
32896: LD_VAR 0 2
32900: ARRAY
32901: PUSH
32902: LD_VAR 0 4
32906: ARRAY
32907: PUSH
32908: LD_INT 1
32910: ARRAY
32911: PPUSH
32912: LD_EXP 87
32916: PUSH
32917: LD_VAR 0 2
32921: ARRAY
32922: PUSH
32923: LD_VAR 0 4
32927: ARRAY
32928: PUSH
32929: LD_INT 2
32931: ARRAY
32932: PPUSH
32933: LD_INT 0
32935: PPUSH
32936: CALL_OW 193
// k := k + 1 ;
32940: LD_ADDR_VAR 0 4
32944: PUSH
32945: LD_VAR 0 4
32949: PUSH
32950: LD_INT 1
32952: PLUS
32953: ST_TO_ADDR
// if k > mc_mines [ i ] then
32954: LD_VAR 0 4
32958: PUSH
32959: LD_EXP 87
32963: PUSH
32964: LD_VAR 0 2
32968: ARRAY
32969: GREATER
32970: IFFALSE 32980
// k := 1 ;
32972: LD_ADDR_VAR 0 4
32976: PUSH
32977: LD_INT 1
32979: ST_TO_ADDR
// end ; end ;
32980: GO 32385
32982: POP
32983: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
32984: LD_ADDR_VAR 0 5
32988: PUSH
32989: LD_EXP 74
32993: PUSH
32994: LD_VAR 0 2
32998: ARRAY
32999: PPUSH
33000: LD_INT 2
33002: PUSH
33003: LD_INT 30
33005: PUSH
33006: LD_INT 4
33008: PUSH
33009: EMPTY
33010: LIST
33011: LIST
33012: PUSH
33013: LD_INT 30
33015: PUSH
33016: LD_INT 5
33018: PUSH
33019: EMPTY
33020: LIST
33021: LIST
33022: PUSH
33023: LD_INT 30
33025: PUSH
33026: LD_INT 32
33028: PUSH
33029: EMPTY
33030: LIST
33031: LIST
33032: PUSH
33033: EMPTY
33034: LIST
33035: LIST
33036: LIST
33037: LIST
33038: PPUSH
33039: CALL_OW 72
33043: ST_TO_ADDR
// if not tmp then
33044: LD_VAR 0 5
33048: NOT
33049: IFFALSE 33053
// continue ;
33051: GO 32302
// list := [ ] ;
33053: LD_ADDR_VAR 0 6
33057: PUSH
33058: EMPTY
33059: ST_TO_ADDR
// for j in tmp do
33060: LD_ADDR_VAR 0 3
33064: PUSH
33065: LD_VAR 0 5
33069: PUSH
33070: FOR_IN
33071: IFFALSE 33140
// begin for k in UnitsInside ( j ) do
33073: LD_ADDR_VAR 0 4
33077: PUSH
33078: LD_VAR 0 3
33082: PPUSH
33083: CALL_OW 313
33087: PUSH
33088: FOR_IN
33089: IFFALSE 33136
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
33091: LD_VAR 0 4
33095: PPUSH
33096: CALL_OW 257
33100: PUSH
33101: LD_INT 1
33103: EQUAL
33104: PUSH
33105: LD_VAR 0 4
33109: PPUSH
33110: CALL_OW 459
33114: NOT
33115: AND
33116: IFFALSE 33134
// list := list ^ k ;
33118: LD_ADDR_VAR 0 6
33122: PUSH
33123: LD_VAR 0 6
33127: PUSH
33128: LD_VAR 0 4
33132: ADD
33133: ST_TO_ADDR
33134: GO 33088
33136: POP
33137: POP
// end ;
33138: GO 33070
33140: POP
33141: POP
// list := list diff mc_miners [ i ] ;
33142: LD_ADDR_VAR 0 6
33146: PUSH
33147: LD_VAR 0 6
33151: PUSH
33152: LD_EXP 88
33156: PUSH
33157: LD_VAR 0 2
33161: ARRAY
33162: DIFF
33163: ST_TO_ADDR
// if not list then
33164: LD_VAR 0 6
33168: NOT
33169: IFFALSE 33173
// continue ;
33171: GO 32302
// k := mc_mines [ i ] - mc_miners [ i ] ;
33173: LD_ADDR_VAR 0 4
33177: PUSH
33178: LD_EXP 87
33182: PUSH
33183: LD_VAR 0 2
33187: ARRAY
33188: PUSH
33189: LD_EXP 88
33193: PUSH
33194: LD_VAR 0 2
33198: ARRAY
33199: MINUS
33200: ST_TO_ADDR
// if k > list then
33201: LD_VAR 0 4
33205: PUSH
33206: LD_VAR 0 6
33210: GREATER
33211: IFFALSE 33223
// k := list ;
33213: LD_ADDR_VAR 0 4
33217: PUSH
33218: LD_VAR 0 6
33222: ST_TO_ADDR
// for j = 1 to k do
33223: LD_ADDR_VAR 0 3
33227: PUSH
33228: DOUBLE
33229: LD_INT 1
33231: DEC
33232: ST_TO_ADDR
33233: LD_VAR 0 4
33237: PUSH
33238: FOR_TO
33239: IFFALSE 33293
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
33241: LD_ADDR_EXP 88
33245: PUSH
33246: LD_EXP 88
33250: PPUSH
33251: LD_VAR 0 2
33255: PUSH
33256: LD_EXP 88
33260: PUSH
33261: LD_VAR 0 2
33265: ARRAY
33266: PUSH
33267: LD_INT 1
33269: PLUS
33270: PUSH
33271: EMPTY
33272: LIST
33273: LIST
33274: PPUSH
33275: LD_VAR 0 6
33279: PUSH
33280: LD_VAR 0 3
33284: ARRAY
33285: PPUSH
33286: CALL 57487 0 3
33290: ST_TO_ADDR
33291: GO 33238
33293: POP
33294: POP
// end ;
33295: GO 32302
33297: POP
33298: POP
// end ;
33299: LD_VAR 0 1
33303: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
33304: LD_INT 0
33306: PPUSH
33307: PPUSH
33308: PPUSH
33309: PPUSH
33310: PPUSH
33311: PPUSH
33312: PPUSH
33313: PPUSH
33314: PPUSH
33315: PPUSH
// if not mc_bases then
33316: LD_EXP 74
33320: NOT
33321: IFFALSE 33325
// exit ;
33323: GO 35075
// for i = 1 to mc_bases do
33325: LD_ADDR_VAR 0 2
33329: PUSH
33330: DOUBLE
33331: LD_INT 1
33333: DEC
33334: ST_TO_ADDR
33335: LD_EXP 74
33339: PUSH
33340: FOR_TO
33341: IFFALSE 35073
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
33343: LD_EXP 74
33347: PUSH
33348: LD_VAR 0 2
33352: ARRAY
33353: NOT
33354: PUSH
33355: LD_EXP 81
33359: PUSH
33360: LD_VAR 0 2
33364: ARRAY
33365: OR
33366: IFFALSE 33370
// continue ;
33368: GO 33340
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
33370: LD_EXP 90
33374: PUSH
33375: LD_VAR 0 2
33379: ARRAY
33380: NOT
33381: PUSH
33382: LD_EXP 91
33386: PUSH
33387: LD_VAR 0 2
33391: ARRAY
33392: AND
33393: IFFALSE 33431
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
33395: LD_ADDR_EXP 91
33399: PUSH
33400: LD_EXP 91
33404: PPUSH
33405: LD_VAR 0 2
33409: PPUSH
33410: EMPTY
33411: PPUSH
33412: CALL_OW 1
33416: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
33417: LD_VAR 0 2
33421: PPUSH
33422: LD_INT 107
33424: PPUSH
33425: CALL 24185 0 2
// continue ;
33429: GO 33340
// end ; target := [ ] ;
33431: LD_ADDR_VAR 0 6
33435: PUSH
33436: EMPTY
33437: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
33438: LD_ADDR_VAR 0 3
33442: PUSH
33443: DOUBLE
33444: LD_EXP 90
33448: PUSH
33449: LD_VAR 0 2
33453: ARRAY
33454: INC
33455: ST_TO_ADDR
33456: LD_INT 1
33458: PUSH
33459: FOR_DOWNTO
33460: IFFALSE 33720
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
33462: LD_EXP 90
33466: PUSH
33467: LD_VAR 0 2
33471: ARRAY
33472: PUSH
33473: LD_VAR 0 3
33477: ARRAY
33478: PUSH
33479: LD_INT 2
33481: ARRAY
33482: PPUSH
33483: LD_EXP 90
33487: PUSH
33488: LD_VAR 0 2
33492: ARRAY
33493: PUSH
33494: LD_VAR 0 3
33498: ARRAY
33499: PUSH
33500: LD_INT 3
33502: ARRAY
33503: PPUSH
33504: CALL_OW 488
33508: PUSH
33509: LD_EXP 90
33513: PUSH
33514: LD_VAR 0 2
33518: ARRAY
33519: PUSH
33520: LD_VAR 0 3
33524: ARRAY
33525: PUSH
33526: LD_INT 2
33528: ARRAY
33529: PPUSH
33530: LD_EXP 90
33534: PUSH
33535: LD_VAR 0 2
33539: ARRAY
33540: PUSH
33541: LD_VAR 0 3
33545: ARRAY
33546: PUSH
33547: LD_INT 3
33549: ARRAY
33550: PPUSH
33551: CALL_OW 284
33555: PUSH
33556: LD_INT 0
33558: EQUAL
33559: AND
33560: IFFALSE 33615
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
33562: LD_ADDR_VAR 0 5
33566: PUSH
33567: LD_EXP 90
33571: PUSH
33572: LD_VAR 0 2
33576: ARRAY
33577: PPUSH
33578: LD_VAR 0 3
33582: PPUSH
33583: CALL_OW 3
33587: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
33588: LD_ADDR_EXP 90
33592: PUSH
33593: LD_EXP 90
33597: PPUSH
33598: LD_VAR 0 2
33602: PPUSH
33603: LD_VAR 0 5
33607: PPUSH
33608: CALL_OW 1
33612: ST_TO_ADDR
// continue ;
33613: GO 33459
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
33615: LD_EXP 74
33619: PUSH
33620: LD_VAR 0 2
33624: ARRAY
33625: PUSH
33626: LD_INT 1
33628: ARRAY
33629: PPUSH
33630: CALL_OW 255
33634: PPUSH
33635: LD_EXP 90
33639: PUSH
33640: LD_VAR 0 2
33644: ARRAY
33645: PUSH
33646: LD_VAR 0 3
33650: ARRAY
33651: PUSH
33652: LD_INT 2
33654: ARRAY
33655: PPUSH
33656: LD_EXP 90
33660: PUSH
33661: LD_VAR 0 2
33665: ARRAY
33666: PUSH
33667: LD_VAR 0 3
33671: ARRAY
33672: PUSH
33673: LD_INT 3
33675: ARRAY
33676: PPUSH
33677: LD_INT 30
33679: PPUSH
33680: CALL 58383 0 4
33684: PUSH
33685: LD_INT 4
33687: ARRAY
33688: PUSH
33689: LD_INT 0
33691: EQUAL
33692: IFFALSE 33718
// begin target := mc_crates [ i ] [ j ] ;
33694: LD_ADDR_VAR 0 6
33698: PUSH
33699: LD_EXP 90
33703: PUSH
33704: LD_VAR 0 2
33708: ARRAY
33709: PUSH
33710: LD_VAR 0 3
33714: ARRAY
33715: ST_TO_ADDR
// break ;
33716: GO 33720
// end ; end ;
33718: GO 33459
33720: POP
33721: POP
// if not target then
33722: LD_VAR 0 6
33726: NOT
33727: IFFALSE 33731
// continue ;
33729: GO 33340
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
33731: LD_ADDR_VAR 0 7
33735: PUSH
33736: LD_EXP 93
33740: PUSH
33741: LD_VAR 0 2
33745: ARRAY
33746: PPUSH
33747: LD_INT 2
33749: PUSH
33750: LD_INT 3
33752: PUSH
33753: LD_INT 58
33755: PUSH
33756: EMPTY
33757: LIST
33758: PUSH
33759: EMPTY
33760: LIST
33761: LIST
33762: PUSH
33763: LD_INT 61
33765: PUSH
33766: EMPTY
33767: LIST
33768: PUSH
33769: LD_INT 33
33771: PUSH
33772: LD_INT 5
33774: PUSH
33775: EMPTY
33776: LIST
33777: LIST
33778: PUSH
33779: LD_INT 33
33781: PUSH
33782: LD_INT 3
33784: PUSH
33785: EMPTY
33786: LIST
33787: LIST
33788: PUSH
33789: EMPTY
33790: LIST
33791: LIST
33792: LIST
33793: LIST
33794: LIST
33795: PUSH
33796: LD_INT 2
33798: PUSH
33799: LD_INT 34
33801: PUSH
33802: LD_INT 32
33804: PUSH
33805: EMPTY
33806: LIST
33807: LIST
33808: PUSH
33809: LD_INT 34
33811: PUSH
33812: LD_INT 51
33814: PUSH
33815: EMPTY
33816: LIST
33817: LIST
33818: PUSH
33819: LD_INT 34
33821: PUSH
33822: LD_INT 12
33824: PUSH
33825: EMPTY
33826: LIST
33827: LIST
33828: PUSH
33829: EMPTY
33830: LIST
33831: LIST
33832: LIST
33833: LIST
33834: PUSH
33835: EMPTY
33836: LIST
33837: LIST
33838: PPUSH
33839: CALL_OW 72
33843: ST_TO_ADDR
// if not cargo then
33844: LD_VAR 0 7
33848: NOT
33849: IFFALSE 34492
// begin if mc_crates_collector [ i ] < 5 then
33851: LD_EXP 91
33855: PUSH
33856: LD_VAR 0 2
33860: ARRAY
33861: PUSH
33862: LD_INT 5
33864: LESS
33865: IFFALSE 34231
// begin if mc_ape [ i ] then
33867: LD_EXP 103
33871: PUSH
33872: LD_VAR 0 2
33876: ARRAY
33877: IFFALSE 33924
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
33879: LD_ADDR_VAR 0 5
33883: PUSH
33884: LD_EXP 103
33888: PUSH
33889: LD_VAR 0 2
33893: ARRAY
33894: PPUSH
33895: LD_INT 25
33897: PUSH
33898: LD_INT 16
33900: PUSH
33901: EMPTY
33902: LIST
33903: LIST
33904: PUSH
33905: LD_INT 24
33907: PUSH
33908: LD_INT 750
33910: PUSH
33911: EMPTY
33912: LIST
33913: LIST
33914: PUSH
33915: EMPTY
33916: LIST
33917: LIST
33918: PPUSH
33919: CALL_OW 72
33923: ST_TO_ADDR
// if not tmp then
33924: LD_VAR 0 5
33928: NOT
33929: IFFALSE 33976
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
33931: LD_ADDR_VAR 0 5
33935: PUSH
33936: LD_EXP 74
33940: PUSH
33941: LD_VAR 0 2
33945: ARRAY
33946: PPUSH
33947: LD_INT 25
33949: PUSH
33950: LD_INT 2
33952: PUSH
33953: EMPTY
33954: LIST
33955: LIST
33956: PUSH
33957: LD_INT 24
33959: PUSH
33960: LD_INT 750
33962: PUSH
33963: EMPTY
33964: LIST
33965: LIST
33966: PUSH
33967: EMPTY
33968: LIST
33969: LIST
33970: PPUSH
33971: CALL_OW 72
33975: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
33976: LD_EXP 103
33980: PUSH
33981: LD_VAR 0 2
33985: ARRAY
33986: PUSH
33987: LD_EXP 74
33991: PUSH
33992: LD_VAR 0 2
33996: ARRAY
33997: PPUSH
33998: LD_INT 25
34000: PUSH
34001: LD_INT 2
34003: PUSH
34004: EMPTY
34005: LIST
34006: LIST
34007: PUSH
34008: LD_INT 24
34010: PUSH
34011: LD_INT 750
34013: PUSH
34014: EMPTY
34015: LIST
34016: LIST
34017: PUSH
34018: EMPTY
34019: LIST
34020: LIST
34021: PPUSH
34022: CALL_OW 72
34026: AND
34027: PUSH
34028: LD_VAR 0 5
34032: PUSH
34033: LD_INT 5
34035: LESS
34036: AND
34037: IFFALSE 34119
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
34039: LD_ADDR_VAR 0 3
34043: PUSH
34044: LD_EXP 74
34048: PUSH
34049: LD_VAR 0 2
34053: ARRAY
34054: PPUSH
34055: LD_INT 25
34057: PUSH
34058: LD_INT 2
34060: PUSH
34061: EMPTY
34062: LIST
34063: LIST
34064: PUSH
34065: LD_INT 24
34067: PUSH
34068: LD_INT 750
34070: PUSH
34071: EMPTY
34072: LIST
34073: LIST
34074: PUSH
34075: EMPTY
34076: LIST
34077: LIST
34078: PPUSH
34079: CALL_OW 72
34083: PUSH
34084: FOR_IN
34085: IFFALSE 34117
// begin tmp := tmp union j ;
34087: LD_ADDR_VAR 0 5
34091: PUSH
34092: LD_VAR 0 5
34096: PUSH
34097: LD_VAR 0 3
34101: UNION
34102: ST_TO_ADDR
// if tmp >= 5 then
34103: LD_VAR 0 5
34107: PUSH
34108: LD_INT 5
34110: GREATEREQUAL
34111: IFFALSE 34115
// break ;
34113: GO 34117
// end ;
34115: GO 34084
34117: POP
34118: POP
// end ; if not tmp then
34119: LD_VAR 0 5
34123: NOT
34124: IFFALSE 34128
// continue ;
34126: GO 33340
// for j in tmp do
34128: LD_ADDR_VAR 0 3
34132: PUSH
34133: LD_VAR 0 5
34137: PUSH
34138: FOR_IN
34139: IFFALSE 34229
// if not GetTag ( j ) then
34141: LD_VAR 0 3
34145: PPUSH
34146: CALL_OW 110
34150: NOT
34151: IFFALSE 34227
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
34153: LD_ADDR_EXP 91
34157: PUSH
34158: LD_EXP 91
34162: PPUSH
34163: LD_VAR 0 2
34167: PUSH
34168: LD_EXP 91
34172: PUSH
34173: LD_VAR 0 2
34177: ARRAY
34178: PUSH
34179: LD_INT 1
34181: PLUS
34182: PUSH
34183: EMPTY
34184: LIST
34185: LIST
34186: PPUSH
34187: LD_VAR 0 3
34191: PPUSH
34192: CALL 57487 0 3
34196: ST_TO_ADDR
// SetTag ( j , 107 ) ;
34197: LD_VAR 0 3
34201: PPUSH
34202: LD_INT 107
34204: PPUSH
34205: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
34209: LD_EXP 91
34213: PUSH
34214: LD_VAR 0 2
34218: ARRAY
34219: PUSH
34220: LD_INT 5
34222: GREATEREQUAL
34223: IFFALSE 34227
// break ;
34225: GO 34229
// end ;
34227: GO 34138
34229: POP
34230: POP
// end ; if mc_crates_collector [ i ] and target then
34231: LD_EXP 91
34235: PUSH
34236: LD_VAR 0 2
34240: ARRAY
34241: PUSH
34242: LD_VAR 0 6
34246: AND
34247: IFFALSE 34490
// begin if mc_crates_collector [ i ] < target [ 1 ] then
34249: LD_EXP 91
34253: PUSH
34254: LD_VAR 0 2
34258: ARRAY
34259: PUSH
34260: LD_VAR 0 6
34264: PUSH
34265: LD_INT 1
34267: ARRAY
34268: LESS
34269: IFFALSE 34289
// tmp := mc_crates_collector [ i ] else
34271: LD_ADDR_VAR 0 5
34275: PUSH
34276: LD_EXP 91
34280: PUSH
34281: LD_VAR 0 2
34285: ARRAY
34286: ST_TO_ADDR
34287: GO 34303
// tmp := target [ 1 ] ;
34289: LD_ADDR_VAR 0 5
34293: PUSH
34294: LD_VAR 0 6
34298: PUSH
34299: LD_INT 1
34301: ARRAY
34302: ST_TO_ADDR
// k := 0 ;
34303: LD_ADDR_VAR 0 4
34307: PUSH
34308: LD_INT 0
34310: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
34311: LD_ADDR_VAR 0 3
34315: PUSH
34316: LD_EXP 91
34320: PUSH
34321: LD_VAR 0 2
34325: ARRAY
34326: PUSH
34327: FOR_IN
34328: IFFALSE 34488
// begin k := k + 1 ;
34330: LD_ADDR_VAR 0 4
34334: PUSH
34335: LD_VAR 0 4
34339: PUSH
34340: LD_INT 1
34342: PLUS
34343: ST_TO_ADDR
// if k > tmp then
34344: LD_VAR 0 4
34348: PUSH
34349: LD_VAR 0 5
34353: GREATER
34354: IFFALSE 34358
// break ;
34356: GO 34488
// if not GetClass ( j ) in [ 2 , 16 ] then
34358: LD_VAR 0 3
34362: PPUSH
34363: CALL_OW 257
34367: PUSH
34368: LD_INT 2
34370: PUSH
34371: LD_INT 16
34373: PUSH
34374: EMPTY
34375: LIST
34376: LIST
34377: IN
34378: NOT
34379: IFFALSE 34432
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
34381: LD_ADDR_EXP 91
34385: PUSH
34386: LD_EXP 91
34390: PPUSH
34391: LD_VAR 0 2
34395: PPUSH
34396: LD_EXP 91
34400: PUSH
34401: LD_VAR 0 2
34405: ARRAY
34406: PUSH
34407: LD_VAR 0 3
34411: DIFF
34412: PPUSH
34413: CALL_OW 1
34417: ST_TO_ADDR
// SetTag ( j , 0 ) ;
34418: LD_VAR 0 3
34422: PPUSH
34423: LD_INT 0
34425: PPUSH
34426: CALL_OW 109
// continue ;
34430: GO 34327
// end ; if IsInUnit ( j ) then
34432: LD_VAR 0 3
34436: PPUSH
34437: CALL_OW 310
34441: IFFALSE 34452
// ComExitBuilding ( j ) ;
34443: LD_VAR 0 3
34447: PPUSH
34448: CALL_OW 122
// wait ( 3 ) ;
34452: LD_INT 3
34454: PPUSH
34455: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
34459: LD_VAR 0 3
34463: PPUSH
34464: LD_VAR 0 6
34468: PUSH
34469: LD_INT 2
34471: ARRAY
34472: PPUSH
34473: LD_VAR 0 6
34477: PUSH
34478: LD_INT 3
34480: ARRAY
34481: PPUSH
34482: CALL_OW 117
// end ;
34486: GO 34327
34488: POP
34489: POP
// end ; end else
34490: GO 35071
// begin for j in cargo do
34492: LD_ADDR_VAR 0 3
34496: PUSH
34497: LD_VAR 0 7
34501: PUSH
34502: FOR_IN
34503: IFFALSE 35069
// begin if GetTag ( j ) <> 0 then
34505: LD_VAR 0 3
34509: PPUSH
34510: CALL_OW 110
34514: PUSH
34515: LD_INT 0
34517: NONEQUAL
34518: IFFALSE 34522
// continue ;
34520: GO 34502
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
34522: LD_VAR 0 3
34526: PPUSH
34527: CALL_OW 256
34531: PUSH
34532: LD_INT 1000
34534: LESS
34535: PUSH
34536: LD_VAR 0 3
34540: PPUSH
34541: LD_EXP 98
34545: PUSH
34546: LD_VAR 0 2
34550: ARRAY
34551: PPUSH
34552: CALL_OW 308
34556: NOT
34557: AND
34558: IFFALSE 34580
// ComMoveToArea ( j , mc_parking [ i ] ) ;
34560: LD_VAR 0 3
34564: PPUSH
34565: LD_EXP 98
34569: PUSH
34570: LD_VAR 0 2
34574: ARRAY
34575: PPUSH
34576: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
34580: LD_VAR 0 3
34584: PPUSH
34585: CALL_OW 256
34589: PUSH
34590: LD_INT 1000
34592: LESS
34593: PUSH
34594: LD_VAR 0 3
34598: PPUSH
34599: LD_EXP 98
34603: PUSH
34604: LD_VAR 0 2
34608: ARRAY
34609: PPUSH
34610: CALL_OW 308
34614: AND
34615: IFFALSE 34619
// continue ;
34617: GO 34502
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
34619: LD_VAR 0 3
34623: PPUSH
34624: CALL_OW 262
34628: PUSH
34629: LD_INT 2
34631: EQUAL
34632: PUSH
34633: LD_VAR 0 3
34637: PPUSH
34638: CALL_OW 261
34642: PUSH
34643: LD_INT 15
34645: LESS
34646: AND
34647: IFFALSE 34651
// continue ;
34649: GO 34502
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
34651: LD_VAR 0 3
34655: PPUSH
34656: CALL_OW 262
34660: PUSH
34661: LD_INT 1
34663: EQUAL
34664: PUSH
34665: LD_VAR 0 3
34669: PPUSH
34670: CALL_OW 261
34674: PUSH
34675: LD_INT 10
34677: LESS
34678: AND
34679: IFFALSE 35008
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34681: LD_ADDR_VAR 0 8
34685: PUSH
34686: LD_EXP 74
34690: PUSH
34691: LD_VAR 0 2
34695: ARRAY
34696: PPUSH
34697: LD_INT 2
34699: PUSH
34700: LD_INT 30
34702: PUSH
34703: LD_INT 0
34705: PUSH
34706: EMPTY
34707: LIST
34708: LIST
34709: PUSH
34710: LD_INT 30
34712: PUSH
34713: LD_INT 1
34715: PUSH
34716: EMPTY
34717: LIST
34718: LIST
34719: PUSH
34720: EMPTY
34721: LIST
34722: LIST
34723: LIST
34724: PPUSH
34725: CALL_OW 72
34729: ST_TO_ADDR
// if not depot then
34730: LD_VAR 0 8
34734: NOT
34735: IFFALSE 34739
// continue ;
34737: GO 34502
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
34739: LD_VAR 0 3
34743: PPUSH
34744: LD_VAR 0 8
34748: PPUSH
34749: LD_VAR 0 3
34753: PPUSH
34754: CALL_OW 74
34758: PPUSH
34759: CALL_OW 296
34763: PUSH
34764: LD_INT 6
34766: LESS
34767: IFFALSE 34783
// SetFuel ( j , 100 ) else
34769: LD_VAR 0 3
34773: PPUSH
34774: LD_INT 100
34776: PPUSH
34777: CALL_OW 240
34781: GO 35008
// if GetFuel ( j ) = 0 then
34783: LD_VAR 0 3
34787: PPUSH
34788: CALL_OW 261
34792: PUSH
34793: LD_INT 0
34795: EQUAL
34796: IFFALSE 35008
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
34798: LD_ADDR_EXP 93
34802: PUSH
34803: LD_EXP 93
34807: PPUSH
34808: LD_VAR 0 2
34812: PPUSH
34813: LD_EXP 93
34817: PUSH
34818: LD_VAR 0 2
34822: ARRAY
34823: PUSH
34824: LD_VAR 0 3
34828: DIFF
34829: PPUSH
34830: CALL_OW 1
34834: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
34835: LD_VAR 0 3
34839: PPUSH
34840: CALL_OW 263
34844: PUSH
34845: LD_INT 1
34847: EQUAL
34848: IFFALSE 34864
// ComExitVehicle ( IsInUnit ( j ) ) ;
34850: LD_VAR 0 3
34854: PPUSH
34855: CALL_OW 310
34859: PPUSH
34860: CALL_OW 121
// if GetControl ( j ) = control_remote then
34864: LD_VAR 0 3
34868: PPUSH
34869: CALL_OW 263
34873: PUSH
34874: LD_INT 2
34876: EQUAL
34877: IFFALSE 34888
// ComUnlink ( j ) ;
34879: LD_VAR 0 3
34883: PPUSH
34884: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
34888: LD_ADDR_VAR 0 9
34892: PUSH
34893: LD_VAR 0 2
34897: PPUSH
34898: LD_INT 3
34900: PPUSH
34901: CALL 44361 0 2
34905: ST_TO_ADDR
// if fac then
34906: LD_VAR 0 9
34910: IFFALSE 35006
// begin for k in fac do
34912: LD_ADDR_VAR 0 4
34916: PUSH
34917: LD_VAR 0 9
34921: PUSH
34922: FOR_IN
34923: IFFALSE 35004
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
34925: LD_ADDR_VAR 0 10
34929: PUSH
34930: LD_VAR 0 9
34934: PPUSH
34935: LD_VAR 0 3
34939: PPUSH
34940: CALL_OW 265
34944: PPUSH
34945: LD_VAR 0 3
34949: PPUSH
34950: CALL_OW 262
34954: PPUSH
34955: LD_VAR 0 3
34959: PPUSH
34960: CALL_OW 263
34964: PPUSH
34965: LD_VAR 0 3
34969: PPUSH
34970: CALL_OW 264
34974: PPUSH
34975: CALL 55019 0 5
34979: ST_TO_ADDR
// if components then
34980: LD_VAR 0 10
34984: IFFALSE 35002
// begin MC_InsertProduceList ( i , components ) ;
34986: LD_VAR 0 2
34990: PPUSH
34991: LD_VAR 0 10
34995: PPUSH
34996: CALL 43906 0 2
// break ;
35000: GO 35004
// end ; end ;
35002: GO 34922
35004: POP
35005: POP
// end ; continue ;
35006: GO 34502
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
35008: LD_VAR 0 3
35012: PPUSH
35013: LD_INT 1
35015: PPUSH
35016: CALL_OW 289
35020: PUSH
35021: LD_INT 100
35023: LESS
35024: PUSH
35025: LD_VAR 0 3
35029: PPUSH
35030: CALL_OW 314
35034: NOT
35035: AND
35036: IFFALSE 35065
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35038: LD_VAR 0 3
35042: PPUSH
35043: LD_VAR 0 6
35047: PUSH
35048: LD_INT 2
35050: ARRAY
35051: PPUSH
35052: LD_VAR 0 6
35056: PUSH
35057: LD_INT 3
35059: ARRAY
35060: PPUSH
35061: CALL_OW 117
// break ;
35065: GO 35069
// end ;
35067: GO 34502
35069: POP
35070: POP
// end ; end ;
35071: GO 33340
35073: POP
35074: POP
// end ;
35075: LD_VAR 0 1
35079: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
35080: LD_INT 0
35082: PPUSH
35083: PPUSH
35084: PPUSH
35085: PPUSH
// if not mc_bases then
35086: LD_EXP 74
35090: NOT
35091: IFFALSE 35095
// exit ;
35093: GO 35256
// for i = 1 to mc_bases do
35095: LD_ADDR_VAR 0 2
35099: PUSH
35100: DOUBLE
35101: LD_INT 1
35103: DEC
35104: ST_TO_ADDR
35105: LD_EXP 74
35109: PUSH
35110: FOR_TO
35111: IFFALSE 35254
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
35113: LD_ADDR_VAR 0 4
35117: PUSH
35118: LD_EXP 93
35122: PUSH
35123: LD_VAR 0 2
35127: ARRAY
35128: PUSH
35129: LD_EXP 96
35133: PUSH
35134: LD_VAR 0 2
35138: ARRAY
35139: UNION
35140: PPUSH
35141: LD_INT 33
35143: PUSH
35144: LD_INT 2
35146: PUSH
35147: EMPTY
35148: LIST
35149: LIST
35150: PPUSH
35151: CALL_OW 72
35155: ST_TO_ADDR
// if tmp then
35156: LD_VAR 0 4
35160: IFFALSE 35252
// for j in tmp do
35162: LD_ADDR_VAR 0 3
35166: PUSH
35167: LD_VAR 0 4
35171: PUSH
35172: FOR_IN
35173: IFFALSE 35250
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
35175: LD_VAR 0 3
35179: PPUSH
35180: CALL_OW 312
35184: NOT
35185: PUSH
35186: LD_VAR 0 3
35190: PPUSH
35191: CALL_OW 256
35195: PUSH
35196: LD_INT 250
35198: GREATEREQUAL
35199: AND
35200: IFFALSE 35213
// Connect ( j ) else
35202: LD_VAR 0 3
35206: PPUSH
35207: CALL 60420 0 1
35211: GO 35248
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
35213: LD_VAR 0 3
35217: PPUSH
35218: CALL_OW 256
35222: PUSH
35223: LD_INT 250
35225: LESS
35226: PUSH
35227: LD_VAR 0 3
35231: PPUSH
35232: CALL_OW 312
35236: AND
35237: IFFALSE 35248
// ComUnlink ( j ) ;
35239: LD_VAR 0 3
35243: PPUSH
35244: CALL_OW 136
35248: GO 35172
35250: POP
35251: POP
// end ;
35252: GO 35110
35254: POP
35255: POP
// end ;
35256: LD_VAR 0 1
35260: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
35261: LD_INT 0
35263: PPUSH
35264: PPUSH
35265: PPUSH
35266: PPUSH
35267: PPUSH
// if not mc_bases then
35268: LD_EXP 74
35272: NOT
35273: IFFALSE 35277
// exit ;
35275: GO 35722
// for i = 1 to mc_bases do
35277: LD_ADDR_VAR 0 2
35281: PUSH
35282: DOUBLE
35283: LD_INT 1
35285: DEC
35286: ST_TO_ADDR
35287: LD_EXP 74
35291: PUSH
35292: FOR_TO
35293: IFFALSE 35720
// begin if not mc_produce [ i ] then
35295: LD_EXP 95
35299: PUSH
35300: LD_VAR 0 2
35304: ARRAY
35305: NOT
35306: IFFALSE 35310
// continue ;
35308: GO 35292
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35310: LD_ADDR_VAR 0 5
35314: PUSH
35315: LD_EXP 74
35319: PUSH
35320: LD_VAR 0 2
35324: ARRAY
35325: PPUSH
35326: LD_INT 30
35328: PUSH
35329: LD_INT 3
35331: PUSH
35332: EMPTY
35333: LIST
35334: LIST
35335: PPUSH
35336: CALL_OW 72
35340: ST_TO_ADDR
// if not fac then
35341: LD_VAR 0 5
35345: NOT
35346: IFFALSE 35350
// continue ;
35348: GO 35292
// for j in fac do
35350: LD_ADDR_VAR 0 3
35354: PUSH
35355: LD_VAR 0 5
35359: PUSH
35360: FOR_IN
35361: IFFALSE 35716
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
35363: LD_VAR 0 3
35367: PPUSH
35368: CALL_OW 461
35372: PUSH
35373: LD_INT 2
35375: NONEQUAL
35376: PUSH
35377: LD_VAR 0 3
35381: PPUSH
35382: LD_INT 15
35384: PPUSH
35385: CALL 60080 0 2
35389: PUSH
35390: LD_INT 4
35392: ARRAY
35393: OR
35394: IFFALSE 35398
// continue ;
35396: GO 35360
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
35398: LD_VAR 0 3
35402: PPUSH
35403: LD_EXP 95
35407: PUSH
35408: LD_VAR 0 2
35412: ARRAY
35413: PUSH
35414: LD_INT 1
35416: ARRAY
35417: PUSH
35418: LD_INT 1
35420: ARRAY
35421: PPUSH
35422: LD_EXP 95
35426: PUSH
35427: LD_VAR 0 2
35431: ARRAY
35432: PUSH
35433: LD_INT 1
35435: ARRAY
35436: PUSH
35437: LD_INT 2
35439: ARRAY
35440: PPUSH
35441: LD_EXP 95
35445: PUSH
35446: LD_VAR 0 2
35450: ARRAY
35451: PUSH
35452: LD_INT 1
35454: ARRAY
35455: PUSH
35456: LD_INT 3
35458: ARRAY
35459: PPUSH
35460: LD_EXP 95
35464: PUSH
35465: LD_VAR 0 2
35469: ARRAY
35470: PUSH
35471: LD_INT 1
35473: ARRAY
35474: PUSH
35475: LD_INT 4
35477: ARRAY
35478: PPUSH
35479: CALL_OW 448
35483: PUSH
35484: LD_VAR 0 3
35488: PPUSH
35489: LD_EXP 95
35493: PUSH
35494: LD_VAR 0 2
35498: ARRAY
35499: PUSH
35500: LD_INT 1
35502: ARRAY
35503: PUSH
35504: LD_INT 1
35506: ARRAY
35507: PUSH
35508: LD_EXP 95
35512: PUSH
35513: LD_VAR 0 2
35517: ARRAY
35518: PUSH
35519: LD_INT 1
35521: ARRAY
35522: PUSH
35523: LD_INT 2
35525: ARRAY
35526: PUSH
35527: LD_EXP 95
35531: PUSH
35532: LD_VAR 0 2
35536: ARRAY
35537: PUSH
35538: LD_INT 1
35540: ARRAY
35541: PUSH
35542: LD_INT 3
35544: ARRAY
35545: PUSH
35546: LD_EXP 95
35550: PUSH
35551: LD_VAR 0 2
35555: ARRAY
35556: PUSH
35557: LD_INT 1
35559: ARRAY
35560: PUSH
35561: LD_INT 4
35563: ARRAY
35564: PUSH
35565: EMPTY
35566: LIST
35567: LIST
35568: LIST
35569: LIST
35570: PPUSH
35571: CALL 63751 0 2
35575: AND
35576: IFFALSE 35714
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
35578: LD_VAR 0 3
35582: PPUSH
35583: LD_EXP 95
35587: PUSH
35588: LD_VAR 0 2
35592: ARRAY
35593: PUSH
35594: LD_INT 1
35596: ARRAY
35597: PUSH
35598: LD_INT 1
35600: ARRAY
35601: PPUSH
35602: LD_EXP 95
35606: PUSH
35607: LD_VAR 0 2
35611: ARRAY
35612: PUSH
35613: LD_INT 1
35615: ARRAY
35616: PUSH
35617: LD_INT 2
35619: ARRAY
35620: PPUSH
35621: LD_EXP 95
35625: PUSH
35626: LD_VAR 0 2
35630: ARRAY
35631: PUSH
35632: LD_INT 1
35634: ARRAY
35635: PUSH
35636: LD_INT 3
35638: ARRAY
35639: PPUSH
35640: LD_EXP 95
35644: PUSH
35645: LD_VAR 0 2
35649: ARRAY
35650: PUSH
35651: LD_INT 1
35653: ARRAY
35654: PUSH
35655: LD_INT 4
35657: ARRAY
35658: PPUSH
35659: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
35663: LD_ADDR_VAR 0 4
35667: PUSH
35668: LD_EXP 95
35672: PUSH
35673: LD_VAR 0 2
35677: ARRAY
35678: PPUSH
35679: LD_INT 1
35681: PPUSH
35682: CALL_OW 3
35686: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
35687: LD_ADDR_EXP 95
35691: PUSH
35692: LD_EXP 95
35696: PPUSH
35697: LD_VAR 0 2
35701: PPUSH
35702: LD_VAR 0 4
35706: PPUSH
35707: CALL_OW 1
35711: ST_TO_ADDR
// break ;
35712: GO 35716
// end ; end ;
35714: GO 35360
35716: POP
35717: POP
// end ;
35718: GO 35292
35720: POP
35721: POP
// end ;
35722: LD_VAR 0 1
35726: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
35727: LD_INT 0
35729: PPUSH
35730: PPUSH
35731: PPUSH
// if not mc_bases then
35732: LD_EXP 74
35736: NOT
35737: IFFALSE 35741
// exit ;
35739: GO 35830
// for i = 1 to mc_bases do
35741: LD_ADDR_VAR 0 2
35745: PUSH
35746: DOUBLE
35747: LD_INT 1
35749: DEC
35750: ST_TO_ADDR
35751: LD_EXP 74
35755: PUSH
35756: FOR_TO
35757: IFFALSE 35828
// begin if mc_attack [ i ] then
35759: LD_EXP 94
35763: PUSH
35764: LD_VAR 0 2
35768: ARRAY
35769: IFFALSE 35826
// begin tmp := mc_attack [ i ] [ 1 ] ;
35771: LD_ADDR_VAR 0 3
35775: PUSH
35776: LD_EXP 94
35780: PUSH
35781: LD_VAR 0 2
35785: ARRAY
35786: PUSH
35787: LD_INT 1
35789: ARRAY
35790: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
35791: LD_ADDR_EXP 94
35795: PUSH
35796: LD_EXP 94
35800: PPUSH
35801: LD_VAR 0 2
35805: PPUSH
35806: EMPTY
35807: PPUSH
35808: CALL_OW 1
35812: ST_TO_ADDR
// Attack ( tmp ) ;
35813: LD_VAR 0 3
35817: PPUSH
35818: CALL 85964 0 1
// exit ;
35822: POP
35823: POP
35824: GO 35830
// end ; end ;
35826: GO 35756
35828: POP
35829: POP
// end ;
35830: LD_VAR 0 1
35834: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
35835: LD_INT 0
35837: PPUSH
35838: PPUSH
35839: PPUSH
35840: PPUSH
35841: PPUSH
35842: PPUSH
35843: PPUSH
// if not mc_bases then
35844: LD_EXP 74
35848: NOT
35849: IFFALSE 35853
// exit ;
35851: GO 36435
// for i = 1 to mc_bases do
35853: LD_ADDR_VAR 0 2
35857: PUSH
35858: DOUBLE
35859: LD_INT 1
35861: DEC
35862: ST_TO_ADDR
35863: LD_EXP 74
35867: PUSH
35868: FOR_TO
35869: IFFALSE 36433
// begin if not mc_bases [ i ] then
35871: LD_EXP 74
35875: PUSH
35876: LD_VAR 0 2
35880: ARRAY
35881: NOT
35882: IFFALSE 35886
// continue ;
35884: GO 35868
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
35886: LD_ADDR_VAR 0 7
35890: PUSH
35891: LD_EXP 74
35895: PUSH
35896: LD_VAR 0 2
35900: ARRAY
35901: PUSH
35902: LD_INT 1
35904: ARRAY
35905: PPUSH
35906: CALL 54323 0 1
35910: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
35911: LD_ADDR_EXP 97
35915: PUSH
35916: LD_EXP 97
35920: PPUSH
35921: LD_VAR 0 2
35925: PPUSH
35926: LD_EXP 74
35930: PUSH
35931: LD_VAR 0 2
35935: ARRAY
35936: PUSH
35937: LD_INT 1
35939: ARRAY
35940: PPUSH
35941: CALL_OW 255
35945: PPUSH
35946: LD_EXP 99
35950: PUSH
35951: LD_VAR 0 2
35955: ARRAY
35956: PPUSH
35957: CALL 51877 0 2
35961: PPUSH
35962: CALL_OW 1
35966: ST_TO_ADDR
// if not mc_scan [ i ] then
35967: LD_EXP 97
35971: PUSH
35972: LD_VAR 0 2
35976: ARRAY
35977: NOT
35978: IFFALSE 36133
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
35980: LD_ADDR_VAR 0 4
35984: PUSH
35985: LD_EXP 74
35989: PUSH
35990: LD_VAR 0 2
35994: ARRAY
35995: PPUSH
35996: LD_INT 2
35998: PUSH
35999: LD_INT 25
36001: PUSH
36002: LD_INT 5
36004: PUSH
36005: EMPTY
36006: LIST
36007: LIST
36008: PUSH
36009: LD_INT 25
36011: PUSH
36012: LD_INT 8
36014: PUSH
36015: EMPTY
36016: LIST
36017: LIST
36018: PUSH
36019: LD_INT 25
36021: PUSH
36022: LD_INT 9
36024: PUSH
36025: EMPTY
36026: LIST
36027: LIST
36028: PUSH
36029: EMPTY
36030: LIST
36031: LIST
36032: LIST
36033: LIST
36034: PPUSH
36035: CALL_OW 72
36039: ST_TO_ADDR
// if not tmp then
36040: LD_VAR 0 4
36044: NOT
36045: IFFALSE 36049
// continue ;
36047: GO 35868
// for j in tmp do
36049: LD_ADDR_VAR 0 3
36053: PUSH
36054: LD_VAR 0 4
36058: PUSH
36059: FOR_IN
36060: IFFALSE 36131
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
36062: LD_VAR 0 3
36066: PPUSH
36067: CALL_OW 310
36071: PPUSH
36072: CALL_OW 266
36076: PUSH
36077: LD_INT 5
36079: EQUAL
36080: PUSH
36081: LD_VAR 0 3
36085: PPUSH
36086: CALL_OW 257
36090: PUSH
36091: LD_INT 1
36093: EQUAL
36094: AND
36095: PUSH
36096: LD_VAR 0 3
36100: PPUSH
36101: CALL_OW 459
36105: NOT
36106: AND
36107: PUSH
36108: LD_VAR 0 7
36112: AND
36113: IFFALSE 36129
// ComChangeProfession ( j , class ) ;
36115: LD_VAR 0 3
36119: PPUSH
36120: LD_VAR 0 7
36124: PPUSH
36125: CALL_OW 123
36129: GO 36059
36131: POP
36132: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
36133: LD_EXP 97
36137: PUSH
36138: LD_VAR 0 2
36142: ARRAY
36143: PUSH
36144: LD_EXP 96
36148: PUSH
36149: LD_VAR 0 2
36153: ARRAY
36154: NOT
36155: AND
36156: PUSH
36157: LD_EXP 74
36161: PUSH
36162: LD_VAR 0 2
36166: ARRAY
36167: PPUSH
36168: LD_INT 30
36170: PUSH
36171: LD_INT 32
36173: PUSH
36174: EMPTY
36175: LIST
36176: LIST
36177: PPUSH
36178: CALL_OW 72
36182: NOT
36183: AND
36184: PUSH
36185: LD_EXP 74
36189: PUSH
36190: LD_VAR 0 2
36194: ARRAY
36195: PPUSH
36196: LD_INT 2
36198: PUSH
36199: LD_INT 30
36201: PUSH
36202: LD_INT 4
36204: PUSH
36205: EMPTY
36206: LIST
36207: LIST
36208: PUSH
36209: LD_INT 30
36211: PUSH
36212: LD_INT 5
36214: PUSH
36215: EMPTY
36216: LIST
36217: LIST
36218: PUSH
36219: EMPTY
36220: LIST
36221: LIST
36222: LIST
36223: PPUSH
36224: CALL_OW 72
36228: NOT
36229: AND
36230: IFFALSE 36362
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36232: LD_ADDR_VAR 0 4
36236: PUSH
36237: LD_EXP 74
36241: PUSH
36242: LD_VAR 0 2
36246: ARRAY
36247: PPUSH
36248: LD_INT 2
36250: PUSH
36251: LD_INT 25
36253: PUSH
36254: LD_INT 1
36256: PUSH
36257: EMPTY
36258: LIST
36259: LIST
36260: PUSH
36261: LD_INT 25
36263: PUSH
36264: LD_INT 5
36266: PUSH
36267: EMPTY
36268: LIST
36269: LIST
36270: PUSH
36271: LD_INT 25
36273: PUSH
36274: LD_INT 8
36276: PUSH
36277: EMPTY
36278: LIST
36279: LIST
36280: PUSH
36281: LD_INT 25
36283: PUSH
36284: LD_INT 9
36286: PUSH
36287: EMPTY
36288: LIST
36289: LIST
36290: PUSH
36291: EMPTY
36292: LIST
36293: LIST
36294: LIST
36295: LIST
36296: LIST
36297: PPUSH
36298: CALL_OW 72
36302: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
36303: LD_ADDR_VAR 0 4
36307: PUSH
36308: LD_VAR 0 4
36312: PUSH
36313: LD_VAR 0 4
36317: PPUSH
36318: LD_INT 18
36320: PPUSH
36321: CALL 90747 0 2
36325: DIFF
36326: ST_TO_ADDR
// if tmp then
36327: LD_VAR 0 4
36331: IFFALSE 36362
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
36333: LD_VAR 0 2
36337: PPUSH
36338: LD_VAR 0 4
36342: PPUSH
36343: LD_EXP 99
36347: PUSH
36348: LD_VAR 0 2
36352: ARRAY
36353: PPUSH
36354: CALL 51912 0 3
// exit ;
36358: POP
36359: POP
36360: GO 36435
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
36362: LD_EXP 97
36366: PUSH
36367: LD_VAR 0 2
36371: ARRAY
36372: PUSH
36373: LD_EXP 96
36377: PUSH
36378: LD_VAR 0 2
36382: ARRAY
36383: AND
36384: IFFALSE 36431
// begin tmp := mc_defender [ i ] ;
36386: LD_ADDR_VAR 0 4
36390: PUSH
36391: LD_EXP 96
36395: PUSH
36396: LD_VAR 0 2
36400: ARRAY
36401: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
36402: LD_VAR 0 2
36406: PPUSH
36407: LD_VAR 0 4
36411: PPUSH
36412: LD_EXP 97
36416: PUSH
36417: LD_VAR 0 2
36421: ARRAY
36422: PPUSH
36423: CALL 52473 0 3
// exit ;
36427: POP
36428: POP
36429: GO 36435
// end ; end ;
36431: GO 35868
36433: POP
36434: POP
// end ;
36435: LD_VAR 0 1
36439: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
36440: LD_INT 0
36442: PPUSH
36443: PPUSH
36444: PPUSH
36445: PPUSH
36446: PPUSH
36447: PPUSH
36448: PPUSH
36449: PPUSH
36450: PPUSH
36451: PPUSH
36452: PPUSH
// if not mc_bases then
36453: LD_EXP 74
36457: NOT
36458: IFFALSE 36462
// exit ;
36460: GO 37549
// for i = 1 to mc_bases do
36462: LD_ADDR_VAR 0 2
36466: PUSH
36467: DOUBLE
36468: LD_INT 1
36470: DEC
36471: ST_TO_ADDR
36472: LD_EXP 74
36476: PUSH
36477: FOR_TO
36478: IFFALSE 37547
// begin tmp := mc_lab [ i ] ;
36480: LD_ADDR_VAR 0 6
36484: PUSH
36485: LD_EXP 107
36489: PUSH
36490: LD_VAR 0 2
36494: ARRAY
36495: ST_TO_ADDR
// if not tmp then
36496: LD_VAR 0 6
36500: NOT
36501: IFFALSE 36505
// continue ;
36503: GO 36477
// idle_lab := 0 ;
36505: LD_ADDR_VAR 0 11
36509: PUSH
36510: LD_INT 0
36512: ST_TO_ADDR
// for j in tmp do
36513: LD_ADDR_VAR 0 3
36517: PUSH
36518: LD_VAR 0 6
36522: PUSH
36523: FOR_IN
36524: IFFALSE 37543
// begin researching := false ;
36526: LD_ADDR_VAR 0 10
36530: PUSH
36531: LD_INT 0
36533: ST_TO_ADDR
// side := GetSide ( j ) ;
36534: LD_ADDR_VAR 0 4
36538: PUSH
36539: LD_VAR 0 3
36543: PPUSH
36544: CALL_OW 255
36548: ST_TO_ADDR
// if not mc_tech [ side ] then
36549: LD_EXP 101
36553: PUSH
36554: LD_VAR 0 4
36558: ARRAY
36559: NOT
36560: IFFALSE 36564
// continue ;
36562: GO 36523
// if BuildingStatus ( j ) = bs_idle then
36564: LD_VAR 0 3
36568: PPUSH
36569: CALL_OW 461
36573: PUSH
36574: LD_INT 2
36576: EQUAL
36577: IFFALSE 36765
// begin if idle_lab and UnitsInside ( j ) < 6 then
36579: LD_VAR 0 11
36583: PUSH
36584: LD_VAR 0 3
36588: PPUSH
36589: CALL_OW 313
36593: PUSH
36594: LD_INT 6
36596: LESS
36597: AND
36598: IFFALSE 36669
// begin tmp2 := UnitsInside ( idle_lab ) ;
36600: LD_ADDR_VAR 0 9
36604: PUSH
36605: LD_VAR 0 11
36609: PPUSH
36610: CALL_OW 313
36614: ST_TO_ADDR
// if tmp2 then
36615: LD_VAR 0 9
36619: IFFALSE 36661
// for x in tmp2 do
36621: LD_ADDR_VAR 0 7
36625: PUSH
36626: LD_VAR 0 9
36630: PUSH
36631: FOR_IN
36632: IFFALSE 36659
// begin ComExitBuilding ( x ) ;
36634: LD_VAR 0 7
36638: PPUSH
36639: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
36643: LD_VAR 0 7
36647: PPUSH
36648: LD_VAR 0 3
36652: PPUSH
36653: CALL_OW 180
// end ;
36657: GO 36631
36659: POP
36660: POP
// idle_lab := 0 ;
36661: LD_ADDR_VAR 0 11
36665: PUSH
36666: LD_INT 0
36668: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
36669: LD_ADDR_VAR 0 5
36673: PUSH
36674: LD_EXP 101
36678: PUSH
36679: LD_VAR 0 4
36683: ARRAY
36684: PUSH
36685: FOR_IN
36686: IFFALSE 36746
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
36688: LD_VAR 0 3
36692: PPUSH
36693: LD_VAR 0 5
36697: PPUSH
36698: CALL_OW 430
36702: PUSH
36703: LD_VAR 0 4
36707: PPUSH
36708: LD_VAR 0 5
36712: PPUSH
36713: CALL 50982 0 2
36717: AND
36718: IFFALSE 36744
// begin researching := true ;
36720: LD_ADDR_VAR 0 10
36724: PUSH
36725: LD_INT 1
36727: ST_TO_ADDR
// ComResearch ( j , t ) ;
36728: LD_VAR 0 3
36732: PPUSH
36733: LD_VAR 0 5
36737: PPUSH
36738: CALL_OW 124
// break ;
36742: GO 36746
// end ;
36744: GO 36685
36746: POP
36747: POP
// if not researching then
36748: LD_VAR 0 10
36752: NOT
36753: IFFALSE 36765
// idle_lab := j ;
36755: LD_ADDR_VAR 0 11
36759: PUSH
36760: LD_VAR 0 3
36764: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
36765: LD_VAR 0 3
36769: PPUSH
36770: CALL_OW 461
36774: PUSH
36775: LD_INT 10
36777: EQUAL
36778: IFFALSE 37366
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
36780: LD_EXP 103
36784: PUSH
36785: LD_VAR 0 2
36789: ARRAY
36790: NOT
36791: PUSH
36792: LD_EXP 104
36796: PUSH
36797: LD_VAR 0 2
36801: ARRAY
36802: NOT
36803: AND
36804: PUSH
36805: LD_EXP 101
36809: PUSH
36810: LD_VAR 0 4
36814: ARRAY
36815: PUSH
36816: LD_INT 1
36818: GREATER
36819: AND
36820: IFFALSE 36951
// begin ComCancel ( j ) ;
36822: LD_VAR 0 3
36826: PPUSH
36827: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
36831: LD_ADDR_EXP 101
36835: PUSH
36836: LD_EXP 101
36840: PPUSH
36841: LD_VAR 0 4
36845: PPUSH
36846: LD_EXP 101
36850: PUSH
36851: LD_VAR 0 4
36855: ARRAY
36856: PPUSH
36857: LD_EXP 101
36861: PUSH
36862: LD_VAR 0 4
36866: ARRAY
36867: PUSH
36868: LD_INT 1
36870: MINUS
36871: PPUSH
36872: LD_EXP 101
36876: PUSH
36877: LD_VAR 0 4
36881: ARRAY
36882: PPUSH
36883: LD_INT 0
36885: PPUSH
36886: CALL 56905 0 4
36890: PPUSH
36891: CALL_OW 1
36895: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
36896: LD_ADDR_EXP 101
36900: PUSH
36901: LD_EXP 101
36905: PPUSH
36906: LD_VAR 0 4
36910: PPUSH
36911: LD_EXP 101
36915: PUSH
36916: LD_VAR 0 4
36920: ARRAY
36921: PPUSH
36922: LD_EXP 101
36926: PUSH
36927: LD_VAR 0 4
36931: ARRAY
36932: PPUSH
36933: LD_INT 1
36935: PPUSH
36936: LD_INT 0
36938: PPUSH
36939: CALL 56905 0 4
36943: PPUSH
36944: CALL_OW 1
36948: ST_TO_ADDR
// continue ;
36949: GO 36523
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
36951: LD_EXP 103
36955: PUSH
36956: LD_VAR 0 2
36960: ARRAY
36961: PUSH
36962: LD_EXP 104
36966: PUSH
36967: LD_VAR 0 2
36971: ARRAY
36972: NOT
36973: AND
36974: IFFALSE 37101
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
36976: LD_ADDR_EXP 104
36980: PUSH
36981: LD_EXP 104
36985: PPUSH
36986: LD_VAR 0 2
36990: PUSH
36991: LD_EXP 104
36995: PUSH
36996: LD_VAR 0 2
37000: ARRAY
37001: PUSH
37002: LD_INT 1
37004: PLUS
37005: PUSH
37006: EMPTY
37007: LIST
37008: LIST
37009: PPUSH
37010: LD_EXP 103
37014: PUSH
37015: LD_VAR 0 2
37019: ARRAY
37020: PUSH
37021: LD_INT 1
37023: ARRAY
37024: PPUSH
37025: CALL 57487 0 3
37029: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
37030: LD_EXP 103
37034: PUSH
37035: LD_VAR 0 2
37039: ARRAY
37040: PUSH
37041: LD_INT 1
37043: ARRAY
37044: PPUSH
37045: LD_INT 112
37047: PPUSH
37048: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
37052: LD_ADDR_VAR 0 9
37056: PUSH
37057: LD_EXP 103
37061: PUSH
37062: LD_VAR 0 2
37066: ARRAY
37067: PPUSH
37068: LD_INT 1
37070: PPUSH
37071: CALL_OW 3
37075: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
37076: LD_ADDR_EXP 103
37080: PUSH
37081: LD_EXP 103
37085: PPUSH
37086: LD_VAR 0 2
37090: PPUSH
37091: LD_VAR 0 9
37095: PPUSH
37096: CALL_OW 1
37100: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
37101: LD_EXP 103
37105: PUSH
37106: LD_VAR 0 2
37110: ARRAY
37111: PUSH
37112: LD_EXP 104
37116: PUSH
37117: LD_VAR 0 2
37121: ARRAY
37122: AND
37123: PUSH
37124: LD_EXP 104
37128: PUSH
37129: LD_VAR 0 2
37133: ARRAY
37134: PUSH
37135: LD_INT 1
37137: ARRAY
37138: PPUSH
37139: CALL_OW 310
37143: NOT
37144: AND
37145: PUSH
37146: LD_VAR 0 3
37150: PPUSH
37151: CALL_OW 313
37155: PUSH
37156: LD_INT 6
37158: EQUAL
37159: AND
37160: IFFALSE 37216
// begin tmp2 := UnitsInside ( j ) ;
37162: LD_ADDR_VAR 0 9
37166: PUSH
37167: LD_VAR 0 3
37171: PPUSH
37172: CALL_OW 313
37176: ST_TO_ADDR
// if tmp2 = 6 then
37177: LD_VAR 0 9
37181: PUSH
37182: LD_INT 6
37184: EQUAL
37185: IFFALSE 37216
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
37187: LD_VAR 0 9
37191: PUSH
37192: LD_INT 1
37194: ARRAY
37195: PPUSH
37196: LD_INT 112
37198: PPUSH
37199: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
37203: LD_VAR 0 9
37207: PUSH
37208: LD_INT 1
37210: ARRAY
37211: PPUSH
37212: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
37216: LD_EXP 104
37220: PUSH
37221: LD_VAR 0 2
37225: ARRAY
37226: PUSH
37227: LD_EXP 104
37231: PUSH
37232: LD_VAR 0 2
37236: ARRAY
37237: PUSH
37238: LD_INT 1
37240: ARRAY
37241: PPUSH
37242: CALL_OW 314
37246: NOT
37247: AND
37248: PUSH
37249: LD_EXP 104
37253: PUSH
37254: LD_VAR 0 2
37258: ARRAY
37259: PUSH
37260: LD_INT 1
37262: ARRAY
37263: PPUSH
37264: CALL_OW 310
37268: NOT
37269: AND
37270: IFFALSE 37296
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
37272: LD_EXP 104
37276: PUSH
37277: LD_VAR 0 2
37281: ARRAY
37282: PUSH
37283: LD_INT 1
37285: ARRAY
37286: PPUSH
37287: LD_VAR 0 3
37291: PPUSH
37292: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
37296: LD_EXP 104
37300: PUSH
37301: LD_VAR 0 2
37305: ARRAY
37306: PUSH
37307: LD_INT 1
37309: ARRAY
37310: PPUSH
37311: CALL_OW 310
37315: PUSH
37316: LD_EXP 104
37320: PUSH
37321: LD_VAR 0 2
37325: ARRAY
37326: PUSH
37327: LD_INT 1
37329: ARRAY
37330: PPUSH
37331: CALL_OW 310
37335: PPUSH
37336: CALL_OW 461
37340: PUSH
37341: LD_INT 3
37343: NONEQUAL
37344: AND
37345: IFFALSE 37366
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
37347: LD_EXP 104
37351: PUSH
37352: LD_VAR 0 2
37356: ARRAY
37357: PUSH
37358: LD_INT 1
37360: ARRAY
37361: PPUSH
37362: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
37366: LD_VAR 0 3
37370: PPUSH
37371: CALL_OW 461
37375: PUSH
37376: LD_INT 6
37378: EQUAL
37379: PUSH
37380: LD_VAR 0 6
37384: PUSH
37385: LD_INT 1
37387: GREATER
37388: AND
37389: IFFALSE 37541
// begin sci := [ ] ;
37391: LD_ADDR_VAR 0 8
37395: PUSH
37396: EMPTY
37397: ST_TO_ADDR
// for x in ( tmp diff j ) do
37398: LD_ADDR_VAR 0 7
37402: PUSH
37403: LD_VAR 0 6
37407: PUSH
37408: LD_VAR 0 3
37412: DIFF
37413: PUSH
37414: FOR_IN
37415: IFFALSE 37467
// begin if sci = 6 then
37417: LD_VAR 0 8
37421: PUSH
37422: LD_INT 6
37424: EQUAL
37425: IFFALSE 37429
// break ;
37427: GO 37467
// if BuildingStatus ( x ) = bs_idle then
37429: LD_VAR 0 7
37433: PPUSH
37434: CALL_OW 461
37438: PUSH
37439: LD_INT 2
37441: EQUAL
37442: IFFALSE 37465
// sci := sci ^ UnitsInside ( x ) ;
37444: LD_ADDR_VAR 0 8
37448: PUSH
37449: LD_VAR 0 8
37453: PUSH
37454: LD_VAR 0 7
37458: PPUSH
37459: CALL_OW 313
37463: ADD
37464: ST_TO_ADDR
// end ;
37465: GO 37414
37467: POP
37468: POP
// if not sci then
37469: LD_VAR 0 8
37473: NOT
37474: IFFALSE 37478
// continue ;
37476: GO 36523
// for x in sci do
37478: LD_ADDR_VAR 0 7
37482: PUSH
37483: LD_VAR 0 8
37487: PUSH
37488: FOR_IN
37489: IFFALSE 37539
// if IsInUnit ( x ) and not HasTask ( x ) then
37491: LD_VAR 0 7
37495: PPUSH
37496: CALL_OW 310
37500: PUSH
37501: LD_VAR 0 7
37505: PPUSH
37506: CALL_OW 314
37510: NOT
37511: AND
37512: IFFALSE 37537
// begin ComExitBuilding ( x ) ;
37514: LD_VAR 0 7
37518: PPUSH
37519: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
37523: LD_VAR 0 7
37527: PPUSH
37528: LD_VAR 0 3
37532: PPUSH
37533: CALL_OW 180
// end ;
37537: GO 37488
37539: POP
37540: POP
// end ; end ;
37541: GO 36523
37543: POP
37544: POP
// end ;
37545: GO 36477
37547: POP
37548: POP
// end ;
37549: LD_VAR 0 1
37553: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
37554: LD_INT 0
37556: PPUSH
37557: PPUSH
// if not mc_bases then
37558: LD_EXP 74
37562: NOT
37563: IFFALSE 37567
// exit ;
37565: GO 37648
// for i = 1 to mc_bases do
37567: LD_ADDR_VAR 0 2
37571: PUSH
37572: DOUBLE
37573: LD_INT 1
37575: DEC
37576: ST_TO_ADDR
37577: LD_EXP 74
37581: PUSH
37582: FOR_TO
37583: IFFALSE 37646
// if mc_mines [ i ] and mc_miners [ i ] then
37585: LD_EXP 87
37589: PUSH
37590: LD_VAR 0 2
37594: ARRAY
37595: PUSH
37596: LD_EXP 88
37600: PUSH
37601: LD_VAR 0 2
37605: ARRAY
37606: AND
37607: IFFALSE 37644
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
37609: LD_EXP 88
37613: PUSH
37614: LD_VAR 0 2
37618: ARRAY
37619: PUSH
37620: LD_INT 1
37622: ARRAY
37623: PPUSH
37624: CALL_OW 255
37628: PPUSH
37629: LD_EXP 87
37633: PUSH
37634: LD_VAR 0 2
37638: ARRAY
37639: PPUSH
37640: CALL 54476 0 2
37644: GO 37582
37646: POP
37647: POP
// end ;
37648: LD_VAR 0 1
37652: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
37653: LD_INT 0
37655: PPUSH
37656: PPUSH
37657: PPUSH
37658: PPUSH
37659: PPUSH
37660: PPUSH
37661: PPUSH
37662: PPUSH
// if not mc_bases or not mc_parking then
37663: LD_EXP 74
37667: NOT
37668: PUSH
37669: LD_EXP 98
37673: NOT
37674: OR
37675: IFFALSE 37679
// exit ;
37677: GO 38378
// for i = 1 to mc_bases do
37679: LD_ADDR_VAR 0 2
37683: PUSH
37684: DOUBLE
37685: LD_INT 1
37687: DEC
37688: ST_TO_ADDR
37689: LD_EXP 74
37693: PUSH
37694: FOR_TO
37695: IFFALSE 38376
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
37697: LD_EXP 74
37701: PUSH
37702: LD_VAR 0 2
37706: ARRAY
37707: NOT
37708: PUSH
37709: LD_EXP 98
37713: PUSH
37714: LD_VAR 0 2
37718: ARRAY
37719: NOT
37720: OR
37721: IFFALSE 37725
// continue ;
37723: GO 37694
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
37725: LD_ADDR_VAR 0 5
37729: PUSH
37730: LD_EXP 74
37734: PUSH
37735: LD_VAR 0 2
37739: ARRAY
37740: PUSH
37741: LD_INT 1
37743: ARRAY
37744: PPUSH
37745: CALL_OW 255
37749: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
37750: LD_ADDR_VAR 0 6
37754: PUSH
37755: LD_EXP 74
37759: PUSH
37760: LD_VAR 0 2
37764: ARRAY
37765: PPUSH
37766: LD_INT 30
37768: PUSH
37769: LD_INT 3
37771: PUSH
37772: EMPTY
37773: LIST
37774: LIST
37775: PPUSH
37776: CALL_OW 72
37780: ST_TO_ADDR
// if not fac then
37781: LD_VAR 0 6
37785: NOT
37786: IFFALSE 37837
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37788: LD_ADDR_VAR 0 6
37792: PUSH
37793: LD_EXP 74
37797: PUSH
37798: LD_VAR 0 2
37802: ARRAY
37803: PPUSH
37804: LD_INT 2
37806: PUSH
37807: LD_INT 30
37809: PUSH
37810: LD_INT 0
37812: PUSH
37813: EMPTY
37814: LIST
37815: LIST
37816: PUSH
37817: LD_INT 30
37819: PUSH
37820: LD_INT 1
37822: PUSH
37823: EMPTY
37824: LIST
37825: LIST
37826: PUSH
37827: EMPTY
37828: LIST
37829: LIST
37830: LIST
37831: PPUSH
37832: CALL_OW 72
37836: ST_TO_ADDR
// if not fac then
37837: LD_VAR 0 6
37841: NOT
37842: IFFALSE 37846
// continue ;
37844: GO 37694
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
37846: LD_ADDR_VAR 0 7
37850: PUSH
37851: LD_EXP 98
37855: PUSH
37856: LD_VAR 0 2
37860: ARRAY
37861: PPUSH
37862: LD_INT 22
37864: PUSH
37865: LD_VAR 0 5
37869: PUSH
37870: EMPTY
37871: LIST
37872: LIST
37873: PUSH
37874: LD_INT 21
37876: PUSH
37877: LD_INT 2
37879: PUSH
37880: EMPTY
37881: LIST
37882: LIST
37883: PUSH
37884: LD_INT 3
37886: PUSH
37887: LD_INT 24
37889: PUSH
37890: LD_INT 1000
37892: PUSH
37893: EMPTY
37894: LIST
37895: LIST
37896: PUSH
37897: EMPTY
37898: LIST
37899: LIST
37900: PUSH
37901: EMPTY
37902: LIST
37903: LIST
37904: LIST
37905: PPUSH
37906: CALL_OW 70
37910: ST_TO_ADDR
// for j in fac do
37911: LD_ADDR_VAR 0 3
37915: PUSH
37916: LD_VAR 0 6
37920: PUSH
37921: FOR_IN
37922: IFFALSE 38003
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
37924: LD_ADDR_VAR 0 7
37928: PUSH
37929: LD_VAR 0 7
37933: PUSH
37934: LD_INT 22
37936: PUSH
37937: LD_VAR 0 5
37941: PUSH
37942: EMPTY
37943: LIST
37944: LIST
37945: PUSH
37946: LD_INT 91
37948: PUSH
37949: LD_VAR 0 3
37953: PUSH
37954: LD_INT 15
37956: PUSH
37957: EMPTY
37958: LIST
37959: LIST
37960: LIST
37961: PUSH
37962: LD_INT 21
37964: PUSH
37965: LD_INT 2
37967: PUSH
37968: EMPTY
37969: LIST
37970: LIST
37971: PUSH
37972: LD_INT 3
37974: PUSH
37975: LD_INT 24
37977: PUSH
37978: LD_INT 1000
37980: PUSH
37981: EMPTY
37982: LIST
37983: LIST
37984: PUSH
37985: EMPTY
37986: LIST
37987: LIST
37988: PUSH
37989: EMPTY
37990: LIST
37991: LIST
37992: LIST
37993: LIST
37994: PPUSH
37995: CALL_OW 69
37999: UNION
38000: ST_TO_ADDR
38001: GO 37921
38003: POP
38004: POP
// if not vehs then
38005: LD_VAR 0 7
38009: NOT
38010: IFFALSE 38036
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
38012: LD_ADDR_EXP 86
38016: PUSH
38017: LD_EXP 86
38021: PPUSH
38022: LD_VAR 0 2
38026: PPUSH
38027: EMPTY
38028: PPUSH
38029: CALL_OW 1
38033: ST_TO_ADDR
// continue ;
38034: GO 37694
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38036: LD_ADDR_VAR 0 8
38040: PUSH
38041: LD_EXP 74
38045: PUSH
38046: LD_VAR 0 2
38050: ARRAY
38051: PPUSH
38052: LD_INT 30
38054: PUSH
38055: LD_INT 3
38057: PUSH
38058: EMPTY
38059: LIST
38060: LIST
38061: PPUSH
38062: CALL_OW 72
38066: ST_TO_ADDR
// if tmp then
38067: LD_VAR 0 8
38071: IFFALSE 38174
// begin for j in tmp do
38073: LD_ADDR_VAR 0 3
38077: PUSH
38078: LD_VAR 0 8
38082: PUSH
38083: FOR_IN
38084: IFFALSE 38172
// for k in UnitsInside ( j ) do
38086: LD_ADDR_VAR 0 4
38090: PUSH
38091: LD_VAR 0 3
38095: PPUSH
38096: CALL_OW 313
38100: PUSH
38101: FOR_IN
38102: IFFALSE 38168
// if k then
38104: LD_VAR 0 4
38108: IFFALSE 38166
// if not k in mc_repair_vehicle [ i ] then
38110: LD_VAR 0 4
38114: PUSH
38115: LD_EXP 86
38119: PUSH
38120: LD_VAR 0 2
38124: ARRAY
38125: IN
38126: NOT
38127: IFFALSE 38166
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
38129: LD_ADDR_EXP 86
38133: PUSH
38134: LD_EXP 86
38138: PPUSH
38139: LD_VAR 0 2
38143: PPUSH
38144: LD_EXP 86
38148: PUSH
38149: LD_VAR 0 2
38153: ARRAY
38154: PUSH
38155: LD_VAR 0 4
38159: UNION
38160: PPUSH
38161: CALL_OW 1
38165: ST_TO_ADDR
38166: GO 38101
38168: POP
38169: POP
38170: GO 38083
38172: POP
38173: POP
// end ; if not mc_repair_vehicle [ i ] then
38174: LD_EXP 86
38178: PUSH
38179: LD_VAR 0 2
38183: ARRAY
38184: NOT
38185: IFFALSE 38189
// continue ;
38187: GO 37694
// for j in mc_repair_vehicle [ i ] do
38189: LD_ADDR_VAR 0 3
38193: PUSH
38194: LD_EXP 86
38198: PUSH
38199: LD_VAR 0 2
38203: ARRAY
38204: PUSH
38205: FOR_IN
38206: IFFALSE 38372
// begin if GetClass ( j ) <> 3 then
38208: LD_VAR 0 3
38212: PPUSH
38213: CALL_OW 257
38217: PUSH
38218: LD_INT 3
38220: NONEQUAL
38221: IFFALSE 38262
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
38223: LD_ADDR_EXP 86
38227: PUSH
38228: LD_EXP 86
38232: PPUSH
38233: LD_VAR 0 2
38237: PPUSH
38238: LD_EXP 86
38242: PUSH
38243: LD_VAR 0 2
38247: ARRAY
38248: PUSH
38249: LD_VAR 0 3
38253: DIFF
38254: PPUSH
38255: CALL_OW 1
38259: ST_TO_ADDR
// continue ;
38260: GO 38205
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38262: LD_VAR 0 3
38266: PPUSH
38267: CALL_OW 311
38271: NOT
38272: PUSH
38273: LD_VAR 0 3
38277: PUSH
38278: LD_EXP 77
38282: PUSH
38283: LD_VAR 0 2
38287: ARRAY
38288: PUSH
38289: LD_INT 1
38291: ARRAY
38292: IN
38293: NOT
38294: AND
38295: PUSH
38296: LD_VAR 0 3
38300: PUSH
38301: LD_EXP 77
38305: PUSH
38306: LD_VAR 0 2
38310: ARRAY
38311: PUSH
38312: LD_INT 2
38314: ARRAY
38315: IN
38316: NOT
38317: AND
38318: IFFALSE 38370
// begin if IsInUnit ( j ) then
38320: LD_VAR 0 3
38324: PPUSH
38325: CALL_OW 310
38329: IFFALSE 38340
// ComExitBuilding ( j ) ;
38331: LD_VAR 0 3
38335: PPUSH
38336: CALL_OW 122
// if not HasTask ( j ) then
38340: LD_VAR 0 3
38344: PPUSH
38345: CALL_OW 314
38349: NOT
38350: IFFALSE 38370
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
38352: LD_VAR 0 3
38356: PPUSH
38357: LD_VAR 0 7
38361: PUSH
38362: LD_INT 1
38364: ARRAY
38365: PPUSH
38366: CALL_OW 189
// end ; end ;
38370: GO 38205
38372: POP
38373: POP
// end ;
38374: GO 37694
38376: POP
38377: POP
// end ;
38378: LD_VAR 0 1
38382: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
38383: LD_INT 0
38385: PPUSH
38386: PPUSH
38387: PPUSH
38388: PPUSH
38389: PPUSH
38390: PPUSH
38391: PPUSH
38392: PPUSH
38393: PPUSH
38394: PPUSH
38395: PPUSH
// if not mc_bases then
38396: LD_EXP 74
38400: NOT
38401: IFFALSE 38405
// exit ;
38403: GO 39207
// for i = 1 to mc_bases do
38405: LD_ADDR_VAR 0 2
38409: PUSH
38410: DOUBLE
38411: LD_INT 1
38413: DEC
38414: ST_TO_ADDR
38415: LD_EXP 74
38419: PUSH
38420: FOR_TO
38421: IFFALSE 39205
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
38423: LD_EXP 102
38427: PUSH
38428: LD_VAR 0 2
38432: ARRAY
38433: NOT
38434: PUSH
38435: LD_EXP 77
38439: PUSH
38440: LD_VAR 0 2
38444: ARRAY
38445: PUSH
38446: LD_INT 1
38448: ARRAY
38449: OR
38450: PUSH
38451: LD_EXP 77
38455: PUSH
38456: LD_VAR 0 2
38460: ARRAY
38461: PUSH
38462: LD_INT 2
38464: ARRAY
38465: OR
38466: PUSH
38467: LD_EXP 100
38471: PUSH
38472: LD_VAR 0 2
38476: ARRAY
38477: PPUSH
38478: LD_INT 1
38480: PPUSH
38481: CALL_OW 325
38485: NOT
38486: OR
38487: PUSH
38488: LD_EXP 97
38492: PUSH
38493: LD_VAR 0 2
38497: ARRAY
38498: OR
38499: IFFALSE 38503
// continue ;
38501: GO 38420
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
38503: LD_ADDR_VAR 0 8
38507: PUSH
38508: LD_EXP 74
38512: PUSH
38513: LD_VAR 0 2
38517: ARRAY
38518: PPUSH
38519: LD_INT 25
38521: PUSH
38522: LD_INT 4
38524: PUSH
38525: EMPTY
38526: LIST
38527: LIST
38528: PUSH
38529: LD_INT 50
38531: PUSH
38532: EMPTY
38533: LIST
38534: PUSH
38535: LD_INT 3
38537: PUSH
38538: LD_INT 60
38540: PUSH
38541: EMPTY
38542: LIST
38543: PUSH
38544: EMPTY
38545: LIST
38546: LIST
38547: PUSH
38548: EMPTY
38549: LIST
38550: LIST
38551: LIST
38552: PPUSH
38553: CALL_OW 72
38557: PUSH
38558: LD_EXP 78
38562: PUSH
38563: LD_VAR 0 2
38567: ARRAY
38568: DIFF
38569: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38570: LD_ADDR_VAR 0 9
38574: PUSH
38575: LD_EXP 74
38579: PUSH
38580: LD_VAR 0 2
38584: ARRAY
38585: PPUSH
38586: LD_INT 2
38588: PUSH
38589: LD_INT 30
38591: PUSH
38592: LD_INT 0
38594: PUSH
38595: EMPTY
38596: LIST
38597: LIST
38598: PUSH
38599: LD_INT 30
38601: PUSH
38602: LD_INT 1
38604: PUSH
38605: EMPTY
38606: LIST
38607: LIST
38608: PUSH
38609: EMPTY
38610: LIST
38611: LIST
38612: LIST
38613: PPUSH
38614: CALL_OW 72
38618: ST_TO_ADDR
// if not tmp or not dep then
38619: LD_VAR 0 8
38623: NOT
38624: PUSH
38625: LD_VAR 0 9
38629: NOT
38630: OR
38631: IFFALSE 38635
// continue ;
38633: GO 38420
// side := GetSide ( tmp [ 1 ] ) ;
38635: LD_ADDR_VAR 0 11
38639: PUSH
38640: LD_VAR 0 8
38644: PUSH
38645: LD_INT 1
38647: ARRAY
38648: PPUSH
38649: CALL_OW 255
38653: ST_TO_ADDR
// dep := dep [ 1 ] ;
38654: LD_ADDR_VAR 0 9
38658: PUSH
38659: LD_VAR 0 9
38663: PUSH
38664: LD_INT 1
38666: ARRAY
38667: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
38668: LD_ADDR_VAR 0 7
38672: PUSH
38673: LD_EXP 102
38677: PUSH
38678: LD_VAR 0 2
38682: ARRAY
38683: PPUSH
38684: LD_INT 22
38686: PUSH
38687: LD_INT 0
38689: PUSH
38690: EMPTY
38691: LIST
38692: LIST
38693: PUSH
38694: LD_INT 25
38696: PUSH
38697: LD_INT 12
38699: PUSH
38700: EMPTY
38701: LIST
38702: LIST
38703: PUSH
38704: EMPTY
38705: LIST
38706: LIST
38707: PPUSH
38708: CALL_OW 70
38712: PUSH
38713: LD_INT 22
38715: PUSH
38716: LD_INT 0
38718: PUSH
38719: EMPTY
38720: LIST
38721: LIST
38722: PUSH
38723: LD_INT 25
38725: PUSH
38726: LD_INT 12
38728: PUSH
38729: EMPTY
38730: LIST
38731: LIST
38732: PUSH
38733: LD_INT 91
38735: PUSH
38736: LD_VAR 0 9
38740: PUSH
38741: LD_INT 20
38743: PUSH
38744: EMPTY
38745: LIST
38746: LIST
38747: LIST
38748: PUSH
38749: EMPTY
38750: LIST
38751: LIST
38752: LIST
38753: PPUSH
38754: CALL_OW 69
38758: UNION
38759: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
38760: LD_ADDR_VAR 0 10
38764: PUSH
38765: LD_EXP 102
38769: PUSH
38770: LD_VAR 0 2
38774: ARRAY
38775: PPUSH
38776: LD_INT 81
38778: PUSH
38779: LD_VAR 0 11
38783: PUSH
38784: EMPTY
38785: LIST
38786: LIST
38787: PPUSH
38788: CALL_OW 70
38792: ST_TO_ADDR
// if not apes or danger_at_area then
38793: LD_VAR 0 7
38797: NOT
38798: PUSH
38799: LD_VAR 0 10
38803: OR
38804: IFFALSE 38854
// begin if mc_taming [ i ] then
38806: LD_EXP 105
38810: PUSH
38811: LD_VAR 0 2
38815: ARRAY
38816: IFFALSE 38852
// begin MC_Reset ( i , 121 ) ;
38818: LD_VAR 0 2
38822: PPUSH
38823: LD_INT 121
38825: PPUSH
38826: CALL 24185 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
38830: LD_ADDR_EXP 105
38834: PUSH
38835: LD_EXP 105
38839: PPUSH
38840: LD_VAR 0 2
38844: PPUSH
38845: EMPTY
38846: PPUSH
38847: CALL_OW 1
38851: ST_TO_ADDR
// end ; continue ;
38852: GO 38420
// end ; for j in tmp do
38854: LD_ADDR_VAR 0 3
38858: PUSH
38859: LD_VAR 0 8
38863: PUSH
38864: FOR_IN
38865: IFFALSE 39201
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
38867: LD_VAR 0 3
38871: PUSH
38872: LD_EXP 105
38876: PUSH
38877: LD_VAR 0 2
38881: ARRAY
38882: IN
38883: NOT
38884: PUSH
38885: LD_EXP 105
38889: PUSH
38890: LD_VAR 0 2
38894: ARRAY
38895: PUSH
38896: LD_INT 3
38898: LESS
38899: AND
38900: IFFALSE 38958
// begin SetTag ( j , 121 ) ;
38902: LD_VAR 0 3
38906: PPUSH
38907: LD_INT 121
38909: PPUSH
38910: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
38914: LD_ADDR_EXP 105
38918: PUSH
38919: LD_EXP 105
38923: PPUSH
38924: LD_VAR 0 2
38928: PUSH
38929: LD_EXP 105
38933: PUSH
38934: LD_VAR 0 2
38938: ARRAY
38939: PUSH
38940: LD_INT 1
38942: PLUS
38943: PUSH
38944: EMPTY
38945: LIST
38946: LIST
38947: PPUSH
38948: LD_VAR 0 3
38952: PPUSH
38953: CALL 57487 0 3
38957: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
38958: LD_VAR 0 3
38962: PUSH
38963: LD_EXP 105
38967: PUSH
38968: LD_VAR 0 2
38972: ARRAY
38973: IN
38974: IFFALSE 39199
// begin if GetClass ( j ) <> 4 then
38976: LD_VAR 0 3
38980: PPUSH
38981: CALL_OW 257
38985: PUSH
38986: LD_INT 4
38988: NONEQUAL
38989: IFFALSE 39042
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
38991: LD_ADDR_EXP 105
38995: PUSH
38996: LD_EXP 105
39000: PPUSH
39001: LD_VAR 0 2
39005: PPUSH
39006: LD_EXP 105
39010: PUSH
39011: LD_VAR 0 2
39015: ARRAY
39016: PUSH
39017: LD_VAR 0 3
39021: DIFF
39022: PPUSH
39023: CALL_OW 1
39027: ST_TO_ADDR
// SetTag ( j , 0 ) ;
39028: LD_VAR 0 3
39032: PPUSH
39033: LD_INT 0
39035: PPUSH
39036: CALL_OW 109
// continue ;
39040: GO 38864
// end ; if IsInUnit ( j ) then
39042: LD_VAR 0 3
39046: PPUSH
39047: CALL_OW 310
39051: IFFALSE 39062
// ComExitBuilding ( j ) ;
39053: LD_VAR 0 3
39057: PPUSH
39058: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
39062: LD_ADDR_VAR 0 6
39066: PUSH
39067: LD_VAR 0 7
39071: PPUSH
39072: LD_VAR 0 3
39076: PPUSH
39077: CALL_OW 74
39081: ST_TO_ADDR
// if not ape then
39082: LD_VAR 0 6
39086: NOT
39087: IFFALSE 39091
// break ;
39089: GO 39201
// x := GetX ( ape ) ;
39091: LD_ADDR_VAR 0 4
39095: PUSH
39096: LD_VAR 0 6
39100: PPUSH
39101: CALL_OW 250
39105: ST_TO_ADDR
// y := GetY ( ape ) ;
39106: LD_ADDR_VAR 0 5
39110: PUSH
39111: LD_VAR 0 6
39115: PPUSH
39116: CALL_OW 251
39120: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
39121: LD_VAR 0 4
39125: PPUSH
39126: LD_VAR 0 5
39130: PPUSH
39131: CALL_OW 488
39135: NOT
39136: PUSH
39137: LD_VAR 0 11
39141: PPUSH
39142: LD_VAR 0 4
39146: PPUSH
39147: LD_VAR 0 5
39151: PPUSH
39152: LD_INT 20
39154: PPUSH
39155: CALL 58383 0 4
39159: PUSH
39160: LD_INT 4
39162: ARRAY
39163: OR
39164: IFFALSE 39168
// break ;
39166: GO 39201
// if not HasTask ( j ) then
39168: LD_VAR 0 3
39172: PPUSH
39173: CALL_OW 314
39177: NOT
39178: IFFALSE 39199
// ComTameXY ( j , x , y ) ;
39180: LD_VAR 0 3
39184: PPUSH
39185: LD_VAR 0 4
39189: PPUSH
39190: LD_VAR 0 5
39194: PPUSH
39195: CALL_OW 131
// end ; end ;
39199: GO 38864
39201: POP
39202: POP
// end ;
39203: GO 38420
39205: POP
39206: POP
// end ;
39207: LD_VAR 0 1
39211: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
39212: LD_INT 0
39214: PPUSH
39215: PPUSH
39216: PPUSH
39217: PPUSH
39218: PPUSH
39219: PPUSH
39220: PPUSH
39221: PPUSH
// if not mc_bases then
39222: LD_EXP 74
39226: NOT
39227: IFFALSE 39231
// exit ;
39229: GO 39857
// for i = 1 to mc_bases do
39231: LD_ADDR_VAR 0 2
39235: PUSH
39236: DOUBLE
39237: LD_INT 1
39239: DEC
39240: ST_TO_ADDR
39241: LD_EXP 74
39245: PUSH
39246: FOR_TO
39247: IFFALSE 39855
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
39249: LD_EXP 103
39253: PUSH
39254: LD_VAR 0 2
39258: ARRAY
39259: NOT
39260: PUSH
39261: LD_EXP 103
39265: PUSH
39266: LD_VAR 0 2
39270: ARRAY
39271: PPUSH
39272: LD_INT 25
39274: PUSH
39275: LD_INT 12
39277: PUSH
39278: EMPTY
39279: LIST
39280: LIST
39281: PPUSH
39282: CALL_OW 72
39286: NOT
39287: OR
39288: IFFALSE 39292
// continue ;
39290: GO 39246
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
39292: LD_ADDR_VAR 0 5
39296: PUSH
39297: LD_EXP 103
39301: PUSH
39302: LD_VAR 0 2
39306: ARRAY
39307: PUSH
39308: LD_INT 1
39310: ARRAY
39311: PPUSH
39312: CALL_OW 255
39316: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
39317: LD_VAR 0 5
39321: PPUSH
39322: LD_INT 2
39324: PPUSH
39325: CALL_OW 325
39329: IFFALSE 39582
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
39331: LD_ADDR_VAR 0 4
39335: PUSH
39336: LD_EXP 103
39340: PUSH
39341: LD_VAR 0 2
39345: ARRAY
39346: PPUSH
39347: LD_INT 25
39349: PUSH
39350: LD_INT 16
39352: PUSH
39353: EMPTY
39354: LIST
39355: LIST
39356: PPUSH
39357: CALL_OW 72
39361: ST_TO_ADDR
// if tmp < 6 then
39362: LD_VAR 0 4
39366: PUSH
39367: LD_INT 6
39369: LESS
39370: IFFALSE 39582
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39372: LD_ADDR_VAR 0 6
39376: PUSH
39377: LD_EXP 74
39381: PUSH
39382: LD_VAR 0 2
39386: ARRAY
39387: PPUSH
39388: LD_INT 2
39390: PUSH
39391: LD_INT 30
39393: PUSH
39394: LD_INT 0
39396: PUSH
39397: EMPTY
39398: LIST
39399: LIST
39400: PUSH
39401: LD_INT 30
39403: PUSH
39404: LD_INT 1
39406: PUSH
39407: EMPTY
39408: LIST
39409: LIST
39410: PUSH
39411: EMPTY
39412: LIST
39413: LIST
39414: LIST
39415: PPUSH
39416: CALL_OW 72
39420: ST_TO_ADDR
// if depot then
39421: LD_VAR 0 6
39425: IFFALSE 39582
// begin selected := 0 ;
39427: LD_ADDR_VAR 0 7
39431: PUSH
39432: LD_INT 0
39434: ST_TO_ADDR
// for j in depot do
39435: LD_ADDR_VAR 0 3
39439: PUSH
39440: LD_VAR 0 6
39444: PUSH
39445: FOR_IN
39446: IFFALSE 39477
// begin if UnitsInside ( j ) < 6 then
39448: LD_VAR 0 3
39452: PPUSH
39453: CALL_OW 313
39457: PUSH
39458: LD_INT 6
39460: LESS
39461: IFFALSE 39475
// begin selected := j ;
39463: LD_ADDR_VAR 0 7
39467: PUSH
39468: LD_VAR 0 3
39472: ST_TO_ADDR
// break ;
39473: GO 39477
// end ; end ;
39475: GO 39445
39477: POP
39478: POP
// if selected then
39479: LD_VAR 0 7
39483: IFFALSE 39582
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
39485: LD_ADDR_VAR 0 3
39489: PUSH
39490: LD_EXP 103
39494: PUSH
39495: LD_VAR 0 2
39499: ARRAY
39500: PPUSH
39501: LD_INT 25
39503: PUSH
39504: LD_INT 12
39506: PUSH
39507: EMPTY
39508: LIST
39509: LIST
39510: PPUSH
39511: CALL_OW 72
39515: PUSH
39516: FOR_IN
39517: IFFALSE 39580
// if not HasTask ( j ) then
39519: LD_VAR 0 3
39523: PPUSH
39524: CALL_OW 314
39528: NOT
39529: IFFALSE 39578
// begin if not IsInUnit ( j ) then
39531: LD_VAR 0 3
39535: PPUSH
39536: CALL_OW 310
39540: NOT
39541: IFFALSE 39557
// ComEnterUnit ( j , selected ) ;
39543: LD_VAR 0 3
39547: PPUSH
39548: LD_VAR 0 7
39552: PPUSH
39553: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
39557: LD_VAR 0 3
39561: PPUSH
39562: LD_INT 16
39564: PPUSH
39565: CALL_OW 183
// AddComExitBuilding ( j ) ;
39569: LD_VAR 0 3
39573: PPUSH
39574: CALL_OW 182
// end ;
39578: GO 39516
39580: POP
39581: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
39582: LD_VAR 0 5
39586: PPUSH
39587: LD_INT 11
39589: PPUSH
39590: CALL_OW 325
39594: IFFALSE 39853
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
39596: LD_ADDR_VAR 0 4
39600: PUSH
39601: LD_EXP 103
39605: PUSH
39606: LD_VAR 0 2
39610: ARRAY
39611: PPUSH
39612: LD_INT 25
39614: PUSH
39615: LD_INT 16
39617: PUSH
39618: EMPTY
39619: LIST
39620: LIST
39621: PPUSH
39622: CALL_OW 72
39626: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
39627: LD_VAR 0 4
39631: PUSH
39632: LD_INT 6
39634: GREATEREQUAL
39635: PUSH
39636: LD_VAR 0 5
39640: PPUSH
39641: LD_INT 2
39643: PPUSH
39644: CALL_OW 325
39648: NOT
39649: OR
39650: IFFALSE 39853
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
39652: LD_ADDR_VAR 0 8
39656: PUSH
39657: LD_EXP 74
39661: PUSH
39662: LD_VAR 0 2
39666: ARRAY
39667: PPUSH
39668: LD_INT 2
39670: PUSH
39671: LD_INT 30
39673: PUSH
39674: LD_INT 4
39676: PUSH
39677: EMPTY
39678: LIST
39679: LIST
39680: PUSH
39681: LD_INT 30
39683: PUSH
39684: LD_INT 5
39686: PUSH
39687: EMPTY
39688: LIST
39689: LIST
39690: PUSH
39691: EMPTY
39692: LIST
39693: LIST
39694: LIST
39695: PPUSH
39696: CALL_OW 72
39700: ST_TO_ADDR
// if barracks then
39701: LD_VAR 0 8
39705: IFFALSE 39853
// begin selected := 0 ;
39707: LD_ADDR_VAR 0 7
39711: PUSH
39712: LD_INT 0
39714: ST_TO_ADDR
// for j in barracks do
39715: LD_ADDR_VAR 0 3
39719: PUSH
39720: LD_VAR 0 8
39724: PUSH
39725: FOR_IN
39726: IFFALSE 39757
// begin if UnitsInside ( j ) < 6 then
39728: LD_VAR 0 3
39732: PPUSH
39733: CALL_OW 313
39737: PUSH
39738: LD_INT 6
39740: LESS
39741: IFFALSE 39755
// begin selected := j ;
39743: LD_ADDR_VAR 0 7
39747: PUSH
39748: LD_VAR 0 3
39752: ST_TO_ADDR
// break ;
39753: GO 39757
// end ; end ;
39755: GO 39725
39757: POP
39758: POP
// if selected then
39759: LD_VAR 0 7
39763: IFFALSE 39853
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
39765: LD_ADDR_VAR 0 3
39769: PUSH
39770: LD_EXP 103
39774: PUSH
39775: LD_VAR 0 2
39779: ARRAY
39780: PPUSH
39781: LD_INT 25
39783: PUSH
39784: LD_INT 12
39786: PUSH
39787: EMPTY
39788: LIST
39789: LIST
39790: PPUSH
39791: CALL_OW 72
39795: PUSH
39796: FOR_IN
39797: IFFALSE 39851
// if not IsInUnit ( j ) and not HasTask ( j ) then
39799: LD_VAR 0 3
39803: PPUSH
39804: CALL_OW 310
39808: NOT
39809: PUSH
39810: LD_VAR 0 3
39814: PPUSH
39815: CALL_OW 314
39819: NOT
39820: AND
39821: IFFALSE 39849
// begin ComEnterUnit ( j , selected ) ;
39823: LD_VAR 0 3
39827: PPUSH
39828: LD_VAR 0 7
39832: PPUSH
39833: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
39837: LD_VAR 0 3
39841: PPUSH
39842: LD_INT 15
39844: PPUSH
39845: CALL_OW 183
// end ;
39849: GO 39796
39851: POP
39852: POP
// end ; end ; end ; end ; end ;
39853: GO 39246
39855: POP
39856: POP
// end ;
39857: LD_VAR 0 1
39861: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
39862: LD_INT 0
39864: PPUSH
39865: PPUSH
39866: PPUSH
39867: PPUSH
// if not mc_bases then
39868: LD_EXP 74
39872: NOT
39873: IFFALSE 39877
// exit ;
39875: GO 40055
// for i = 1 to mc_bases do
39877: LD_ADDR_VAR 0 2
39881: PUSH
39882: DOUBLE
39883: LD_INT 1
39885: DEC
39886: ST_TO_ADDR
39887: LD_EXP 74
39891: PUSH
39892: FOR_TO
39893: IFFALSE 40053
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
39895: LD_ADDR_VAR 0 4
39899: PUSH
39900: LD_EXP 74
39904: PUSH
39905: LD_VAR 0 2
39909: ARRAY
39910: PPUSH
39911: LD_INT 25
39913: PUSH
39914: LD_INT 9
39916: PUSH
39917: EMPTY
39918: LIST
39919: LIST
39920: PPUSH
39921: CALL_OW 72
39925: ST_TO_ADDR
// if not tmp then
39926: LD_VAR 0 4
39930: NOT
39931: IFFALSE 39935
// continue ;
39933: GO 39892
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
39935: LD_EXP 100
39939: PUSH
39940: LD_VAR 0 2
39944: ARRAY
39945: PPUSH
39946: LD_INT 29
39948: PPUSH
39949: CALL_OW 325
39953: NOT
39954: PUSH
39955: LD_EXP 100
39959: PUSH
39960: LD_VAR 0 2
39964: ARRAY
39965: PPUSH
39966: LD_INT 28
39968: PPUSH
39969: CALL_OW 325
39973: NOT
39974: AND
39975: IFFALSE 39979
// continue ;
39977: GO 39892
// for j in tmp do
39979: LD_ADDR_VAR 0 3
39983: PUSH
39984: LD_VAR 0 4
39988: PUSH
39989: FOR_IN
39990: IFFALSE 40049
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
39992: LD_VAR 0 3
39996: PUSH
39997: LD_EXP 77
40001: PUSH
40002: LD_VAR 0 2
40006: ARRAY
40007: PUSH
40008: LD_INT 1
40010: ARRAY
40011: IN
40012: NOT
40013: PUSH
40014: LD_VAR 0 3
40018: PUSH
40019: LD_EXP 77
40023: PUSH
40024: LD_VAR 0 2
40028: ARRAY
40029: PUSH
40030: LD_INT 2
40032: ARRAY
40033: IN
40034: NOT
40035: AND
40036: IFFALSE 40047
// ComSpaceTimeShoot ( j ) ;
40038: LD_VAR 0 3
40042: PPUSH
40043: CALL 51073 0 1
40047: GO 39989
40049: POP
40050: POP
// end ;
40051: GO 39892
40053: POP
40054: POP
// end ;
40055: LD_VAR 0 1
40059: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
40060: LD_INT 0
40062: PPUSH
40063: PPUSH
40064: PPUSH
40065: PPUSH
40066: PPUSH
40067: PPUSH
40068: PPUSH
40069: PPUSH
40070: PPUSH
// if not mc_bases then
40071: LD_EXP 74
40075: NOT
40076: IFFALSE 40080
// exit ;
40078: GO 40702
// for i = 1 to mc_bases do
40080: LD_ADDR_VAR 0 2
40084: PUSH
40085: DOUBLE
40086: LD_INT 1
40088: DEC
40089: ST_TO_ADDR
40090: LD_EXP 74
40094: PUSH
40095: FOR_TO
40096: IFFALSE 40700
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
40098: LD_EXP 109
40102: PUSH
40103: LD_VAR 0 2
40107: ARRAY
40108: NOT
40109: PUSH
40110: LD_INT 38
40112: PPUSH
40113: LD_EXP 100
40117: PUSH
40118: LD_VAR 0 2
40122: ARRAY
40123: PPUSH
40124: CALL_OW 321
40128: PUSH
40129: LD_INT 2
40131: NONEQUAL
40132: OR
40133: IFFALSE 40137
// continue ;
40135: GO 40095
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
40137: LD_ADDR_VAR 0 8
40141: PUSH
40142: LD_EXP 74
40146: PUSH
40147: LD_VAR 0 2
40151: ARRAY
40152: PPUSH
40153: LD_INT 30
40155: PUSH
40156: LD_INT 34
40158: PUSH
40159: EMPTY
40160: LIST
40161: LIST
40162: PPUSH
40163: CALL_OW 72
40167: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
40168: LD_ADDR_VAR 0 9
40172: PUSH
40173: LD_EXP 74
40177: PUSH
40178: LD_VAR 0 2
40182: ARRAY
40183: PPUSH
40184: LD_INT 25
40186: PUSH
40187: LD_INT 4
40189: PUSH
40190: EMPTY
40191: LIST
40192: LIST
40193: PPUSH
40194: CALL_OW 72
40198: PPUSH
40199: LD_INT 0
40201: PPUSH
40202: CALL 90747 0 2
40206: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
40207: LD_VAR 0 9
40211: NOT
40212: PUSH
40213: LD_VAR 0 8
40217: NOT
40218: OR
40219: PUSH
40220: LD_EXP 74
40224: PUSH
40225: LD_VAR 0 2
40229: ARRAY
40230: PPUSH
40231: LD_INT 124
40233: PPUSH
40234: CALL 90747 0 2
40238: OR
40239: IFFALSE 40243
// continue ;
40241: GO 40095
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
40243: LD_EXP 110
40247: PUSH
40248: LD_VAR 0 2
40252: ARRAY
40253: PUSH
40254: LD_EXP 109
40258: PUSH
40259: LD_VAR 0 2
40263: ARRAY
40264: LESS
40265: PUSH
40266: LD_EXP 110
40270: PUSH
40271: LD_VAR 0 2
40275: ARRAY
40276: PUSH
40277: LD_VAR 0 8
40281: LESS
40282: AND
40283: IFFALSE 40698
// begin tmp := sci [ 1 ] ;
40285: LD_ADDR_VAR 0 7
40289: PUSH
40290: LD_VAR 0 9
40294: PUSH
40295: LD_INT 1
40297: ARRAY
40298: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
40299: LD_VAR 0 7
40303: PPUSH
40304: LD_INT 124
40306: PPUSH
40307: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
40311: LD_ADDR_VAR 0 3
40315: PUSH
40316: DOUBLE
40317: LD_EXP 109
40321: PUSH
40322: LD_VAR 0 2
40326: ARRAY
40327: INC
40328: ST_TO_ADDR
40329: LD_EXP 109
40333: PUSH
40334: LD_VAR 0 2
40338: ARRAY
40339: PUSH
40340: FOR_DOWNTO
40341: IFFALSE 40684
// begin if IsInUnit ( tmp ) then
40343: LD_VAR 0 7
40347: PPUSH
40348: CALL_OW 310
40352: IFFALSE 40363
// ComExitBuilding ( tmp ) ;
40354: LD_VAR 0 7
40358: PPUSH
40359: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
40363: LD_INT 35
40365: PPUSH
40366: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
40370: LD_VAR 0 7
40374: PPUSH
40375: CALL_OW 310
40379: NOT
40380: PUSH
40381: LD_VAR 0 7
40385: PPUSH
40386: CALL_OW 314
40390: NOT
40391: AND
40392: IFFALSE 40363
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
40394: LD_ADDR_VAR 0 6
40398: PUSH
40399: LD_VAR 0 7
40403: PPUSH
40404: CALL_OW 250
40408: PUSH
40409: LD_VAR 0 7
40413: PPUSH
40414: CALL_OW 251
40418: PUSH
40419: EMPTY
40420: LIST
40421: LIST
40422: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
40423: LD_INT 35
40425: PPUSH
40426: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
40430: LD_ADDR_VAR 0 4
40434: PUSH
40435: LD_EXP 109
40439: PUSH
40440: LD_VAR 0 2
40444: ARRAY
40445: PUSH
40446: LD_VAR 0 3
40450: ARRAY
40451: PUSH
40452: LD_INT 1
40454: ARRAY
40455: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
40456: LD_ADDR_VAR 0 5
40460: PUSH
40461: LD_EXP 109
40465: PUSH
40466: LD_VAR 0 2
40470: ARRAY
40471: PUSH
40472: LD_VAR 0 3
40476: ARRAY
40477: PUSH
40478: LD_INT 2
40480: ARRAY
40481: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
40482: LD_VAR 0 7
40486: PPUSH
40487: LD_INT 10
40489: PPUSH
40490: CALL 60080 0 2
40494: PUSH
40495: LD_INT 4
40497: ARRAY
40498: IFFALSE 40536
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
40500: LD_VAR 0 7
40504: PPUSH
40505: LD_VAR 0 6
40509: PUSH
40510: LD_INT 1
40512: ARRAY
40513: PPUSH
40514: LD_VAR 0 6
40518: PUSH
40519: LD_INT 2
40521: ARRAY
40522: PPUSH
40523: CALL_OW 111
// wait ( 0 0$10 ) ;
40527: LD_INT 350
40529: PPUSH
40530: CALL_OW 67
// end else
40534: GO 40562
// begin ComMoveXY ( tmp , x , y ) ;
40536: LD_VAR 0 7
40540: PPUSH
40541: LD_VAR 0 4
40545: PPUSH
40546: LD_VAR 0 5
40550: PPUSH
40551: CALL_OW 111
// wait ( 0 0$3 ) ;
40555: LD_INT 105
40557: PPUSH
40558: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
40562: LD_VAR 0 7
40566: PPUSH
40567: LD_VAR 0 4
40571: PPUSH
40572: LD_VAR 0 5
40576: PPUSH
40577: CALL_OW 307
40581: IFFALSE 40423
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
40583: LD_VAR 0 7
40587: PPUSH
40588: LD_VAR 0 4
40592: PPUSH
40593: LD_VAR 0 5
40597: PPUSH
40598: LD_VAR 0 8
40602: PUSH
40603: LD_VAR 0 3
40607: ARRAY
40608: PPUSH
40609: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
40613: LD_INT 35
40615: PPUSH
40616: CALL_OW 67
// until not HasTask ( tmp ) ;
40620: LD_VAR 0 7
40624: PPUSH
40625: CALL_OW 314
40629: NOT
40630: IFFALSE 40613
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
40632: LD_ADDR_EXP 110
40636: PUSH
40637: LD_EXP 110
40641: PPUSH
40642: LD_VAR 0 2
40646: PUSH
40647: LD_EXP 110
40651: PUSH
40652: LD_VAR 0 2
40656: ARRAY
40657: PUSH
40658: LD_INT 1
40660: PLUS
40661: PUSH
40662: EMPTY
40663: LIST
40664: LIST
40665: PPUSH
40666: LD_VAR 0 8
40670: PUSH
40671: LD_VAR 0 3
40675: ARRAY
40676: PPUSH
40677: CALL 57487 0 3
40681: ST_TO_ADDR
// end ;
40682: GO 40340
40684: POP
40685: POP
// MC_Reset ( i , 124 ) ;
40686: LD_VAR 0 2
40690: PPUSH
40691: LD_INT 124
40693: PPUSH
40694: CALL 24185 0 2
// end ; end ;
40698: GO 40095
40700: POP
40701: POP
// end ;
40702: LD_VAR 0 1
40706: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
40707: LD_INT 0
40709: PPUSH
40710: PPUSH
40711: PPUSH
// if not mc_bases then
40712: LD_EXP 74
40716: NOT
40717: IFFALSE 40721
// exit ;
40719: GO 41327
// for i = 1 to mc_bases do
40721: LD_ADDR_VAR 0 2
40725: PUSH
40726: DOUBLE
40727: LD_INT 1
40729: DEC
40730: ST_TO_ADDR
40731: LD_EXP 74
40735: PUSH
40736: FOR_TO
40737: IFFALSE 41325
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
40739: LD_ADDR_VAR 0 3
40743: PUSH
40744: LD_EXP 74
40748: PUSH
40749: LD_VAR 0 2
40753: ARRAY
40754: PPUSH
40755: LD_INT 25
40757: PUSH
40758: LD_INT 4
40760: PUSH
40761: EMPTY
40762: LIST
40763: LIST
40764: PPUSH
40765: CALL_OW 72
40769: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
40770: LD_VAR 0 3
40774: NOT
40775: PUSH
40776: LD_EXP 111
40780: PUSH
40781: LD_VAR 0 2
40785: ARRAY
40786: NOT
40787: OR
40788: PUSH
40789: LD_EXP 74
40793: PUSH
40794: LD_VAR 0 2
40798: ARRAY
40799: PPUSH
40800: LD_INT 2
40802: PUSH
40803: LD_INT 30
40805: PUSH
40806: LD_INT 0
40808: PUSH
40809: EMPTY
40810: LIST
40811: LIST
40812: PUSH
40813: LD_INT 30
40815: PUSH
40816: LD_INT 1
40818: PUSH
40819: EMPTY
40820: LIST
40821: LIST
40822: PUSH
40823: EMPTY
40824: LIST
40825: LIST
40826: LIST
40827: PPUSH
40828: CALL_OW 72
40832: NOT
40833: OR
40834: IFFALSE 40884
// begin if mc_deposits_finder [ i ] then
40836: LD_EXP 112
40840: PUSH
40841: LD_VAR 0 2
40845: ARRAY
40846: IFFALSE 40882
// begin MC_Reset ( i , 125 ) ;
40848: LD_VAR 0 2
40852: PPUSH
40853: LD_INT 125
40855: PPUSH
40856: CALL 24185 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
40860: LD_ADDR_EXP 112
40864: PUSH
40865: LD_EXP 112
40869: PPUSH
40870: LD_VAR 0 2
40874: PPUSH
40875: EMPTY
40876: PPUSH
40877: CALL_OW 1
40881: ST_TO_ADDR
// end ; continue ;
40882: GO 40736
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
40884: LD_EXP 111
40888: PUSH
40889: LD_VAR 0 2
40893: ARRAY
40894: PUSH
40895: LD_INT 1
40897: ARRAY
40898: PUSH
40899: LD_INT 3
40901: ARRAY
40902: PUSH
40903: LD_INT 1
40905: EQUAL
40906: PUSH
40907: LD_INT 20
40909: PPUSH
40910: LD_EXP 100
40914: PUSH
40915: LD_VAR 0 2
40919: ARRAY
40920: PPUSH
40921: CALL_OW 321
40925: PUSH
40926: LD_INT 2
40928: NONEQUAL
40929: AND
40930: IFFALSE 40980
// begin if mc_deposits_finder [ i ] then
40932: LD_EXP 112
40936: PUSH
40937: LD_VAR 0 2
40941: ARRAY
40942: IFFALSE 40978
// begin MC_Reset ( i , 125 ) ;
40944: LD_VAR 0 2
40948: PPUSH
40949: LD_INT 125
40951: PPUSH
40952: CALL 24185 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
40956: LD_ADDR_EXP 112
40960: PUSH
40961: LD_EXP 112
40965: PPUSH
40966: LD_VAR 0 2
40970: PPUSH
40971: EMPTY
40972: PPUSH
40973: CALL_OW 1
40977: ST_TO_ADDR
// end ; continue ;
40978: GO 40736
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
40980: LD_EXP 111
40984: PUSH
40985: LD_VAR 0 2
40989: ARRAY
40990: PUSH
40991: LD_INT 1
40993: ARRAY
40994: PUSH
40995: LD_INT 1
40997: ARRAY
40998: PPUSH
40999: LD_EXP 111
41003: PUSH
41004: LD_VAR 0 2
41008: ARRAY
41009: PUSH
41010: LD_INT 1
41012: ARRAY
41013: PUSH
41014: LD_INT 2
41016: ARRAY
41017: PPUSH
41018: LD_EXP 100
41022: PUSH
41023: LD_VAR 0 2
41027: ARRAY
41028: PPUSH
41029: CALL_OW 440
41033: IFFALSE 41076
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
41035: LD_ADDR_EXP 111
41039: PUSH
41040: LD_EXP 111
41044: PPUSH
41045: LD_VAR 0 2
41049: PPUSH
41050: LD_EXP 111
41054: PUSH
41055: LD_VAR 0 2
41059: ARRAY
41060: PPUSH
41061: LD_INT 1
41063: PPUSH
41064: CALL_OW 3
41068: PPUSH
41069: CALL_OW 1
41073: ST_TO_ADDR
41074: GO 41323
// begin if not mc_deposits_finder [ i ] then
41076: LD_EXP 112
41080: PUSH
41081: LD_VAR 0 2
41085: ARRAY
41086: NOT
41087: IFFALSE 41139
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
41089: LD_ADDR_EXP 112
41093: PUSH
41094: LD_EXP 112
41098: PPUSH
41099: LD_VAR 0 2
41103: PPUSH
41104: LD_VAR 0 3
41108: PUSH
41109: LD_INT 1
41111: ARRAY
41112: PUSH
41113: EMPTY
41114: LIST
41115: PPUSH
41116: CALL_OW 1
41120: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
41121: LD_VAR 0 3
41125: PUSH
41126: LD_INT 1
41128: ARRAY
41129: PPUSH
41130: LD_INT 125
41132: PPUSH
41133: CALL_OW 109
// end else
41137: GO 41323
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
41139: LD_EXP 112
41143: PUSH
41144: LD_VAR 0 2
41148: ARRAY
41149: PUSH
41150: LD_INT 1
41152: ARRAY
41153: PPUSH
41154: CALL_OW 310
41158: IFFALSE 41181
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
41160: LD_EXP 112
41164: PUSH
41165: LD_VAR 0 2
41169: ARRAY
41170: PUSH
41171: LD_INT 1
41173: ARRAY
41174: PPUSH
41175: CALL_OW 122
41179: GO 41323
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
41181: LD_EXP 112
41185: PUSH
41186: LD_VAR 0 2
41190: ARRAY
41191: PUSH
41192: LD_INT 1
41194: ARRAY
41195: PPUSH
41196: CALL_OW 314
41200: NOT
41201: PUSH
41202: LD_EXP 112
41206: PUSH
41207: LD_VAR 0 2
41211: ARRAY
41212: PUSH
41213: LD_INT 1
41215: ARRAY
41216: PPUSH
41217: LD_EXP 111
41221: PUSH
41222: LD_VAR 0 2
41226: ARRAY
41227: PUSH
41228: LD_INT 1
41230: ARRAY
41231: PUSH
41232: LD_INT 1
41234: ARRAY
41235: PPUSH
41236: LD_EXP 111
41240: PUSH
41241: LD_VAR 0 2
41245: ARRAY
41246: PUSH
41247: LD_INT 1
41249: ARRAY
41250: PUSH
41251: LD_INT 2
41253: ARRAY
41254: PPUSH
41255: CALL_OW 297
41259: PUSH
41260: LD_INT 6
41262: GREATER
41263: AND
41264: IFFALSE 41323
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
41266: LD_EXP 112
41270: PUSH
41271: LD_VAR 0 2
41275: ARRAY
41276: PUSH
41277: LD_INT 1
41279: ARRAY
41280: PPUSH
41281: LD_EXP 111
41285: PUSH
41286: LD_VAR 0 2
41290: ARRAY
41291: PUSH
41292: LD_INT 1
41294: ARRAY
41295: PUSH
41296: LD_INT 1
41298: ARRAY
41299: PPUSH
41300: LD_EXP 111
41304: PUSH
41305: LD_VAR 0 2
41309: ARRAY
41310: PUSH
41311: LD_INT 1
41313: ARRAY
41314: PUSH
41315: LD_INT 2
41317: ARRAY
41318: PPUSH
41319: CALL_OW 111
// end ; end ; end ;
41323: GO 40736
41325: POP
41326: POP
// end ;
41327: LD_VAR 0 1
41331: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
41332: LD_INT 0
41334: PPUSH
41335: PPUSH
41336: PPUSH
41337: PPUSH
41338: PPUSH
41339: PPUSH
41340: PPUSH
41341: PPUSH
41342: PPUSH
41343: PPUSH
41344: PPUSH
// if not mc_bases then
41345: LD_EXP 74
41349: NOT
41350: IFFALSE 41354
// exit ;
41352: GO 42294
// for i = 1 to mc_bases do
41354: LD_ADDR_VAR 0 2
41358: PUSH
41359: DOUBLE
41360: LD_INT 1
41362: DEC
41363: ST_TO_ADDR
41364: LD_EXP 74
41368: PUSH
41369: FOR_TO
41370: IFFALSE 42292
// begin if not mc_bases [ i ] or mc_scan [ i ] then
41372: LD_EXP 74
41376: PUSH
41377: LD_VAR 0 2
41381: ARRAY
41382: NOT
41383: PUSH
41384: LD_EXP 97
41388: PUSH
41389: LD_VAR 0 2
41393: ARRAY
41394: OR
41395: IFFALSE 41399
// continue ;
41397: GO 41369
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
41399: LD_ADDR_VAR 0 7
41403: PUSH
41404: LD_EXP 74
41408: PUSH
41409: LD_VAR 0 2
41413: ARRAY
41414: PUSH
41415: LD_INT 1
41417: ARRAY
41418: PPUSH
41419: CALL_OW 248
41423: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
41424: LD_VAR 0 7
41428: PUSH
41429: LD_INT 3
41431: EQUAL
41432: PUSH
41433: LD_EXP 93
41437: PUSH
41438: LD_VAR 0 2
41442: ARRAY
41443: PUSH
41444: LD_EXP 96
41448: PUSH
41449: LD_VAR 0 2
41453: ARRAY
41454: UNION
41455: PPUSH
41456: LD_INT 33
41458: PUSH
41459: LD_INT 2
41461: PUSH
41462: EMPTY
41463: LIST
41464: LIST
41465: PPUSH
41466: CALL_OW 72
41470: NOT
41471: OR
41472: IFFALSE 41476
// continue ;
41474: GO 41369
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
41476: LD_ADDR_VAR 0 9
41480: PUSH
41481: LD_EXP 74
41485: PUSH
41486: LD_VAR 0 2
41490: ARRAY
41491: PPUSH
41492: LD_INT 30
41494: PUSH
41495: LD_INT 36
41497: PUSH
41498: EMPTY
41499: LIST
41500: LIST
41501: PPUSH
41502: CALL_OW 72
41506: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
41507: LD_ADDR_VAR 0 10
41511: PUSH
41512: LD_EXP 93
41516: PUSH
41517: LD_VAR 0 2
41521: ARRAY
41522: PPUSH
41523: LD_INT 34
41525: PUSH
41526: LD_INT 31
41528: PUSH
41529: EMPTY
41530: LIST
41531: LIST
41532: PPUSH
41533: CALL_OW 72
41537: ST_TO_ADDR
// if not cts and not mcts then
41538: LD_VAR 0 9
41542: NOT
41543: PUSH
41544: LD_VAR 0 10
41548: NOT
41549: AND
41550: IFFALSE 41554
// continue ;
41552: GO 41369
// x := cts ;
41554: LD_ADDR_VAR 0 11
41558: PUSH
41559: LD_VAR 0 9
41563: ST_TO_ADDR
// if not x then
41564: LD_VAR 0 11
41568: NOT
41569: IFFALSE 41581
// x := mcts ;
41571: LD_ADDR_VAR 0 11
41575: PUSH
41576: LD_VAR 0 10
41580: ST_TO_ADDR
// if not x then
41581: LD_VAR 0 11
41585: NOT
41586: IFFALSE 41590
// continue ;
41588: GO 41369
// if mc_remote_driver [ i ] then
41590: LD_EXP 114
41594: PUSH
41595: LD_VAR 0 2
41599: ARRAY
41600: IFFALSE 41987
// for j in mc_remote_driver [ i ] do
41602: LD_ADDR_VAR 0 3
41606: PUSH
41607: LD_EXP 114
41611: PUSH
41612: LD_VAR 0 2
41616: ARRAY
41617: PUSH
41618: FOR_IN
41619: IFFALSE 41985
// begin if GetClass ( j ) <> 3 then
41621: LD_VAR 0 3
41625: PPUSH
41626: CALL_OW 257
41630: PUSH
41631: LD_INT 3
41633: NONEQUAL
41634: IFFALSE 41687
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
41636: LD_ADDR_EXP 114
41640: PUSH
41641: LD_EXP 114
41645: PPUSH
41646: LD_VAR 0 2
41650: PPUSH
41651: LD_EXP 114
41655: PUSH
41656: LD_VAR 0 2
41660: ARRAY
41661: PUSH
41662: LD_VAR 0 3
41666: DIFF
41667: PPUSH
41668: CALL_OW 1
41672: ST_TO_ADDR
// SetTag ( j , 0 ) ;
41673: LD_VAR 0 3
41677: PPUSH
41678: LD_INT 0
41680: PPUSH
41681: CALL_OW 109
// continue ;
41685: GO 41618
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
41687: LD_EXP 93
41691: PUSH
41692: LD_VAR 0 2
41696: ARRAY
41697: PPUSH
41698: LD_INT 34
41700: PUSH
41701: LD_INT 31
41703: PUSH
41704: EMPTY
41705: LIST
41706: LIST
41707: PUSH
41708: LD_INT 58
41710: PUSH
41711: EMPTY
41712: LIST
41713: PUSH
41714: EMPTY
41715: LIST
41716: LIST
41717: PPUSH
41718: CALL_OW 72
41722: PUSH
41723: LD_VAR 0 3
41727: PPUSH
41728: CALL 90835 0 1
41732: NOT
41733: AND
41734: IFFALSE 41805
// begin if IsInUnit ( j ) then
41736: LD_VAR 0 3
41740: PPUSH
41741: CALL_OW 310
41745: IFFALSE 41756
// ComExitBuilding ( j ) ;
41747: LD_VAR 0 3
41751: PPUSH
41752: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
41756: LD_VAR 0 3
41760: PPUSH
41761: LD_EXP 93
41765: PUSH
41766: LD_VAR 0 2
41770: ARRAY
41771: PPUSH
41772: LD_INT 34
41774: PUSH
41775: LD_INT 31
41777: PUSH
41778: EMPTY
41779: LIST
41780: LIST
41781: PUSH
41782: LD_INT 58
41784: PUSH
41785: EMPTY
41786: LIST
41787: PUSH
41788: EMPTY
41789: LIST
41790: LIST
41791: PPUSH
41792: CALL_OW 72
41796: PUSH
41797: LD_INT 1
41799: ARRAY
41800: PPUSH
41801: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
41805: LD_VAR 0 3
41809: PPUSH
41810: CALL_OW 310
41814: NOT
41815: PUSH
41816: LD_VAR 0 3
41820: PPUSH
41821: CALL_OW 310
41825: PPUSH
41826: CALL_OW 266
41830: PUSH
41831: LD_INT 36
41833: NONEQUAL
41834: PUSH
41835: LD_VAR 0 3
41839: PPUSH
41840: CALL 90835 0 1
41844: NOT
41845: AND
41846: OR
41847: IFFALSE 41983
// begin if IsInUnit ( j ) then
41849: LD_VAR 0 3
41853: PPUSH
41854: CALL_OW 310
41858: IFFALSE 41869
// ComExitBuilding ( j ) ;
41860: LD_VAR 0 3
41864: PPUSH
41865: CALL_OW 122
// ct := 0 ;
41869: LD_ADDR_VAR 0 8
41873: PUSH
41874: LD_INT 0
41876: ST_TO_ADDR
// for k in x do
41877: LD_ADDR_VAR 0 4
41881: PUSH
41882: LD_VAR 0 11
41886: PUSH
41887: FOR_IN
41888: IFFALSE 41961
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
41890: LD_VAR 0 4
41894: PPUSH
41895: CALL_OW 264
41899: PUSH
41900: LD_INT 31
41902: EQUAL
41903: PUSH
41904: LD_VAR 0 4
41908: PPUSH
41909: CALL_OW 311
41913: NOT
41914: AND
41915: PUSH
41916: LD_VAR 0 4
41920: PPUSH
41921: CALL_OW 266
41925: PUSH
41926: LD_INT 36
41928: EQUAL
41929: PUSH
41930: LD_VAR 0 4
41934: PPUSH
41935: CALL_OW 313
41939: PUSH
41940: LD_INT 3
41942: LESS
41943: AND
41944: OR
41945: IFFALSE 41959
// begin ct := k ;
41947: LD_ADDR_VAR 0 8
41951: PUSH
41952: LD_VAR 0 4
41956: ST_TO_ADDR
// break ;
41957: GO 41961
// end ;
41959: GO 41887
41961: POP
41962: POP
// if ct then
41963: LD_VAR 0 8
41967: IFFALSE 41983
// ComEnterUnit ( j , ct ) ;
41969: LD_VAR 0 3
41973: PPUSH
41974: LD_VAR 0 8
41978: PPUSH
41979: CALL_OW 120
// end ; end ;
41983: GO 41618
41985: POP
41986: POP
// places := 0 ;
41987: LD_ADDR_VAR 0 5
41991: PUSH
41992: LD_INT 0
41994: ST_TO_ADDR
// for j = 1 to x do
41995: LD_ADDR_VAR 0 3
41999: PUSH
42000: DOUBLE
42001: LD_INT 1
42003: DEC
42004: ST_TO_ADDR
42005: LD_VAR 0 11
42009: PUSH
42010: FOR_TO
42011: IFFALSE 42087
// if GetWeapon ( x [ j ] ) = ar_control_tower then
42013: LD_VAR 0 11
42017: PUSH
42018: LD_VAR 0 3
42022: ARRAY
42023: PPUSH
42024: CALL_OW 264
42028: PUSH
42029: LD_INT 31
42031: EQUAL
42032: IFFALSE 42050
// places := places + 1 else
42034: LD_ADDR_VAR 0 5
42038: PUSH
42039: LD_VAR 0 5
42043: PUSH
42044: LD_INT 1
42046: PLUS
42047: ST_TO_ADDR
42048: GO 42085
// if GetBType ( x [ j ] ) = b_control_tower then
42050: LD_VAR 0 11
42054: PUSH
42055: LD_VAR 0 3
42059: ARRAY
42060: PPUSH
42061: CALL_OW 266
42065: PUSH
42066: LD_INT 36
42068: EQUAL
42069: IFFALSE 42085
// places := places + 3 ;
42071: LD_ADDR_VAR 0 5
42075: PUSH
42076: LD_VAR 0 5
42080: PUSH
42081: LD_INT 3
42083: PLUS
42084: ST_TO_ADDR
42085: GO 42010
42087: POP
42088: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
42089: LD_VAR 0 5
42093: PUSH
42094: LD_INT 0
42096: EQUAL
42097: PUSH
42098: LD_VAR 0 5
42102: PUSH
42103: LD_EXP 114
42107: PUSH
42108: LD_VAR 0 2
42112: ARRAY
42113: LESSEQUAL
42114: OR
42115: IFFALSE 42119
// continue ;
42117: GO 41369
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
42119: LD_ADDR_VAR 0 6
42123: PUSH
42124: LD_EXP 74
42128: PUSH
42129: LD_VAR 0 2
42133: ARRAY
42134: PPUSH
42135: LD_INT 25
42137: PUSH
42138: LD_INT 3
42140: PUSH
42141: EMPTY
42142: LIST
42143: LIST
42144: PPUSH
42145: CALL_OW 72
42149: PUSH
42150: LD_EXP 114
42154: PUSH
42155: LD_VAR 0 2
42159: ARRAY
42160: DIFF
42161: PPUSH
42162: LD_INT 3
42164: PPUSH
42165: CALL 91735 0 2
42169: ST_TO_ADDR
// for j in tmp do
42170: LD_ADDR_VAR 0 3
42174: PUSH
42175: LD_VAR 0 6
42179: PUSH
42180: FOR_IN
42181: IFFALSE 42216
// if GetTag ( j ) > 0 then
42183: LD_VAR 0 3
42187: PPUSH
42188: CALL_OW 110
42192: PUSH
42193: LD_INT 0
42195: GREATER
42196: IFFALSE 42214
// tmp := tmp diff j ;
42198: LD_ADDR_VAR 0 6
42202: PUSH
42203: LD_VAR 0 6
42207: PUSH
42208: LD_VAR 0 3
42212: DIFF
42213: ST_TO_ADDR
42214: GO 42180
42216: POP
42217: POP
// if not tmp then
42218: LD_VAR 0 6
42222: NOT
42223: IFFALSE 42227
// continue ;
42225: GO 41369
// if places then
42227: LD_VAR 0 5
42231: IFFALSE 42290
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
42233: LD_ADDR_EXP 114
42237: PUSH
42238: LD_EXP 114
42242: PPUSH
42243: LD_VAR 0 2
42247: PPUSH
42248: LD_EXP 114
42252: PUSH
42253: LD_VAR 0 2
42257: ARRAY
42258: PUSH
42259: LD_VAR 0 6
42263: PUSH
42264: LD_INT 1
42266: ARRAY
42267: UNION
42268: PPUSH
42269: CALL_OW 1
42273: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
42274: LD_VAR 0 6
42278: PUSH
42279: LD_INT 1
42281: ARRAY
42282: PPUSH
42283: LD_INT 126
42285: PPUSH
42286: CALL_OW 109
// end ; end ;
42290: GO 41369
42292: POP
42293: POP
// end ;
42294: LD_VAR 0 1
42298: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
42299: LD_INT 0
42301: PPUSH
42302: PPUSH
42303: PPUSH
42304: PPUSH
42305: PPUSH
42306: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
42307: LD_VAR 0 1
42311: NOT
42312: PUSH
42313: LD_VAR 0 2
42317: NOT
42318: OR
42319: PUSH
42320: LD_VAR 0 3
42324: NOT
42325: OR
42326: PUSH
42327: LD_VAR 0 4
42331: PUSH
42332: LD_INT 1
42334: PUSH
42335: LD_INT 2
42337: PUSH
42338: LD_INT 3
42340: PUSH
42341: LD_INT 4
42343: PUSH
42344: LD_INT 5
42346: PUSH
42347: LD_INT 8
42349: PUSH
42350: LD_INT 9
42352: PUSH
42353: LD_INT 15
42355: PUSH
42356: LD_INT 16
42358: PUSH
42359: EMPTY
42360: LIST
42361: LIST
42362: LIST
42363: LIST
42364: LIST
42365: LIST
42366: LIST
42367: LIST
42368: LIST
42369: IN
42370: NOT
42371: OR
42372: IFFALSE 42376
// exit ;
42374: GO 43276
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
42376: LD_ADDR_VAR 0 2
42380: PUSH
42381: LD_VAR 0 2
42385: PPUSH
42386: LD_INT 21
42388: PUSH
42389: LD_INT 3
42391: PUSH
42392: EMPTY
42393: LIST
42394: LIST
42395: PUSH
42396: LD_INT 24
42398: PUSH
42399: LD_INT 250
42401: PUSH
42402: EMPTY
42403: LIST
42404: LIST
42405: PUSH
42406: EMPTY
42407: LIST
42408: LIST
42409: PPUSH
42410: CALL_OW 72
42414: ST_TO_ADDR
// case class of 1 , 15 :
42415: LD_VAR 0 4
42419: PUSH
42420: LD_INT 1
42422: DOUBLE
42423: EQUAL
42424: IFTRUE 42434
42426: LD_INT 15
42428: DOUBLE
42429: EQUAL
42430: IFTRUE 42434
42432: GO 42519
42434: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
42435: LD_ADDR_VAR 0 8
42439: PUSH
42440: LD_VAR 0 2
42444: PPUSH
42445: LD_INT 2
42447: PUSH
42448: LD_INT 30
42450: PUSH
42451: LD_INT 32
42453: PUSH
42454: EMPTY
42455: LIST
42456: LIST
42457: PUSH
42458: LD_INT 30
42460: PUSH
42461: LD_INT 31
42463: PUSH
42464: EMPTY
42465: LIST
42466: LIST
42467: PUSH
42468: EMPTY
42469: LIST
42470: LIST
42471: LIST
42472: PPUSH
42473: CALL_OW 72
42477: PUSH
42478: LD_VAR 0 2
42482: PPUSH
42483: LD_INT 2
42485: PUSH
42486: LD_INT 30
42488: PUSH
42489: LD_INT 4
42491: PUSH
42492: EMPTY
42493: LIST
42494: LIST
42495: PUSH
42496: LD_INT 30
42498: PUSH
42499: LD_INT 5
42501: PUSH
42502: EMPTY
42503: LIST
42504: LIST
42505: PUSH
42506: EMPTY
42507: LIST
42508: LIST
42509: LIST
42510: PPUSH
42511: CALL_OW 72
42515: ADD
42516: ST_TO_ADDR
42517: GO 42765
42519: LD_INT 2
42521: DOUBLE
42522: EQUAL
42523: IFTRUE 42533
42525: LD_INT 16
42527: DOUBLE
42528: EQUAL
42529: IFTRUE 42533
42531: GO 42579
42533: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
42534: LD_ADDR_VAR 0 8
42538: PUSH
42539: LD_VAR 0 2
42543: PPUSH
42544: LD_INT 2
42546: PUSH
42547: LD_INT 30
42549: PUSH
42550: LD_INT 0
42552: PUSH
42553: EMPTY
42554: LIST
42555: LIST
42556: PUSH
42557: LD_INT 30
42559: PUSH
42560: LD_INT 1
42562: PUSH
42563: EMPTY
42564: LIST
42565: LIST
42566: PUSH
42567: EMPTY
42568: LIST
42569: LIST
42570: LIST
42571: PPUSH
42572: CALL_OW 72
42576: ST_TO_ADDR
42577: GO 42765
42579: LD_INT 3
42581: DOUBLE
42582: EQUAL
42583: IFTRUE 42587
42585: GO 42633
42587: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
42588: LD_ADDR_VAR 0 8
42592: PUSH
42593: LD_VAR 0 2
42597: PPUSH
42598: LD_INT 2
42600: PUSH
42601: LD_INT 30
42603: PUSH
42604: LD_INT 2
42606: PUSH
42607: EMPTY
42608: LIST
42609: LIST
42610: PUSH
42611: LD_INT 30
42613: PUSH
42614: LD_INT 3
42616: PUSH
42617: EMPTY
42618: LIST
42619: LIST
42620: PUSH
42621: EMPTY
42622: LIST
42623: LIST
42624: LIST
42625: PPUSH
42626: CALL_OW 72
42630: ST_TO_ADDR
42631: GO 42765
42633: LD_INT 4
42635: DOUBLE
42636: EQUAL
42637: IFTRUE 42641
42639: GO 42698
42641: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
42642: LD_ADDR_VAR 0 8
42646: PUSH
42647: LD_VAR 0 2
42651: PPUSH
42652: LD_INT 2
42654: PUSH
42655: LD_INT 30
42657: PUSH
42658: LD_INT 6
42660: PUSH
42661: EMPTY
42662: LIST
42663: LIST
42664: PUSH
42665: LD_INT 30
42667: PUSH
42668: LD_INT 7
42670: PUSH
42671: EMPTY
42672: LIST
42673: LIST
42674: PUSH
42675: LD_INT 30
42677: PUSH
42678: LD_INT 8
42680: PUSH
42681: EMPTY
42682: LIST
42683: LIST
42684: PUSH
42685: EMPTY
42686: LIST
42687: LIST
42688: LIST
42689: LIST
42690: PPUSH
42691: CALL_OW 72
42695: ST_TO_ADDR
42696: GO 42765
42698: LD_INT 5
42700: DOUBLE
42701: EQUAL
42702: IFTRUE 42718
42704: LD_INT 8
42706: DOUBLE
42707: EQUAL
42708: IFTRUE 42718
42710: LD_INT 9
42712: DOUBLE
42713: EQUAL
42714: IFTRUE 42718
42716: GO 42764
42718: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
42719: LD_ADDR_VAR 0 8
42723: PUSH
42724: LD_VAR 0 2
42728: PPUSH
42729: LD_INT 2
42731: PUSH
42732: LD_INT 30
42734: PUSH
42735: LD_INT 4
42737: PUSH
42738: EMPTY
42739: LIST
42740: LIST
42741: PUSH
42742: LD_INT 30
42744: PUSH
42745: LD_INT 5
42747: PUSH
42748: EMPTY
42749: LIST
42750: LIST
42751: PUSH
42752: EMPTY
42753: LIST
42754: LIST
42755: LIST
42756: PPUSH
42757: CALL_OW 72
42761: ST_TO_ADDR
42762: GO 42765
42764: POP
// if not tmp then
42765: LD_VAR 0 8
42769: NOT
42770: IFFALSE 42774
// exit ;
42772: GO 43276
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
42774: LD_VAR 0 4
42778: PUSH
42779: LD_INT 1
42781: PUSH
42782: LD_INT 15
42784: PUSH
42785: EMPTY
42786: LIST
42787: LIST
42788: IN
42789: PUSH
42790: LD_EXP 83
42794: PUSH
42795: LD_VAR 0 1
42799: ARRAY
42800: AND
42801: IFFALSE 42957
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
42803: LD_ADDR_VAR 0 9
42807: PUSH
42808: LD_EXP 83
42812: PUSH
42813: LD_VAR 0 1
42817: ARRAY
42818: PUSH
42819: LD_INT 1
42821: ARRAY
42822: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
42823: LD_VAR 0 9
42827: PUSH
42828: LD_EXP 84
42832: PUSH
42833: LD_VAR 0 1
42837: ARRAY
42838: IN
42839: NOT
42840: IFFALSE 42955
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
42842: LD_ADDR_EXP 84
42846: PUSH
42847: LD_EXP 84
42851: PPUSH
42852: LD_VAR 0 1
42856: PUSH
42857: LD_EXP 84
42861: PUSH
42862: LD_VAR 0 1
42866: ARRAY
42867: PUSH
42868: LD_INT 1
42870: PLUS
42871: PUSH
42872: EMPTY
42873: LIST
42874: LIST
42875: PPUSH
42876: LD_VAR 0 9
42880: PPUSH
42881: CALL 57487 0 3
42885: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
42886: LD_ADDR_EXP 83
42890: PUSH
42891: LD_EXP 83
42895: PPUSH
42896: LD_VAR 0 1
42900: PPUSH
42901: LD_EXP 83
42905: PUSH
42906: LD_VAR 0 1
42910: ARRAY
42911: PUSH
42912: LD_VAR 0 9
42916: DIFF
42917: PPUSH
42918: CALL_OW 1
42922: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
42923: LD_VAR 0 3
42927: PPUSH
42928: LD_EXP 84
42932: PUSH
42933: LD_VAR 0 1
42937: ARRAY
42938: PUSH
42939: LD_EXP 84
42943: PUSH
42944: LD_VAR 0 1
42948: ARRAY
42949: ARRAY
42950: PPUSH
42951: CALL_OW 120
// end ; exit ;
42955: GO 43276
// end ; if tmp > 1 then
42957: LD_VAR 0 8
42961: PUSH
42962: LD_INT 1
42964: GREATER
42965: IFFALSE 43069
// for i = 2 to tmp do
42967: LD_ADDR_VAR 0 6
42971: PUSH
42972: DOUBLE
42973: LD_INT 2
42975: DEC
42976: ST_TO_ADDR
42977: LD_VAR 0 8
42981: PUSH
42982: FOR_TO
42983: IFFALSE 43067
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
42985: LD_VAR 0 8
42989: PUSH
42990: LD_VAR 0 6
42994: ARRAY
42995: PPUSH
42996: CALL_OW 461
43000: PUSH
43001: LD_INT 6
43003: EQUAL
43004: IFFALSE 43065
// begin x := tmp [ i ] ;
43006: LD_ADDR_VAR 0 9
43010: PUSH
43011: LD_VAR 0 8
43015: PUSH
43016: LD_VAR 0 6
43020: ARRAY
43021: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
43022: LD_ADDR_VAR 0 8
43026: PUSH
43027: LD_VAR 0 8
43031: PPUSH
43032: LD_VAR 0 6
43036: PPUSH
43037: CALL_OW 3
43041: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
43042: LD_ADDR_VAR 0 8
43046: PUSH
43047: LD_VAR 0 8
43051: PPUSH
43052: LD_INT 1
43054: PPUSH
43055: LD_VAR 0 9
43059: PPUSH
43060: CALL_OW 2
43064: ST_TO_ADDR
// end ;
43065: GO 42982
43067: POP
43068: POP
// for i in tmp do
43069: LD_ADDR_VAR 0 6
43073: PUSH
43074: LD_VAR 0 8
43078: PUSH
43079: FOR_IN
43080: IFFALSE 43149
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
43082: LD_VAR 0 6
43086: PPUSH
43087: CALL_OW 313
43091: PUSH
43092: LD_INT 6
43094: LESS
43095: PUSH
43096: LD_VAR 0 6
43100: PPUSH
43101: CALL_OW 266
43105: PUSH
43106: LD_INT 31
43108: PUSH
43109: LD_INT 32
43111: PUSH
43112: EMPTY
43113: LIST
43114: LIST
43115: IN
43116: NOT
43117: AND
43118: PUSH
43119: LD_VAR 0 6
43123: PPUSH
43124: CALL_OW 313
43128: PUSH
43129: LD_INT 0
43131: EQUAL
43132: OR
43133: IFFALSE 43147
// begin j := i ;
43135: LD_ADDR_VAR 0 7
43139: PUSH
43140: LD_VAR 0 6
43144: ST_TO_ADDR
// break ;
43145: GO 43149
// end ; end ;
43147: GO 43079
43149: POP
43150: POP
// if j then
43151: LD_VAR 0 7
43155: IFFALSE 43173
// ComEnterUnit ( unit , j ) else
43157: LD_VAR 0 3
43161: PPUSH
43162: LD_VAR 0 7
43166: PPUSH
43167: CALL_OW 120
43171: GO 43276
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43173: LD_ADDR_VAR 0 10
43177: PUSH
43178: LD_VAR 0 2
43182: PPUSH
43183: LD_INT 2
43185: PUSH
43186: LD_INT 30
43188: PUSH
43189: LD_INT 0
43191: PUSH
43192: EMPTY
43193: LIST
43194: LIST
43195: PUSH
43196: LD_INT 30
43198: PUSH
43199: LD_INT 1
43201: PUSH
43202: EMPTY
43203: LIST
43204: LIST
43205: PUSH
43206: EMPTY
43207: LIST
43208: LIST
43209: LIST
43210: PPUSH
43211: CALL_OW 72
43215: ST_TO_ADDR
// if depot then
43216: LD_VAR 0 10
43220: IFFALSE 43276
// begin depot := NearestUnitToUnit ( depot , unit ) ;
43222: LD_ADDR_VAR 0 10
43226: PUSH
43227: LD_VAR 0 10
43231: PPUSH
43232: LD_VAR 0 3
43236: PPUSH
43237: CALL_OW 74
43241: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
43242: LD_VAR 0 3
43246: PPUSH
43247: LD_VAR 0 10
43251: PPUSH
43252: CALL_OW 296
43256: PUSH
43257: LD_INT 10
43259: GREATER
43260: IFFALSE 43276
// ComStandNearbyBuilding ( unit , depot ) ;
43262: LD_VAR 0 3
43266: PPUSH
43267: LD_VAR 0 10
43271: PPUSH
43272: CALL 51690 0 2
// end ; end ; end ;
43276: LD_VAR 0 5
43280: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
43281: LD_INT 0
43283: PPUSH
43284: PPUSH
43285: PPUSH
43286: PPUSH
// if not mc_bases then
43287: LD_EXP 74
43291: NOT
43292: IFFALSE 43296
// exit ;
43294: GO 43535
// for i = 1 to mc_bases do
43296: LD_ADDR_VAR 0 2
43300: PUSH
43301: DOUBLE
43302: LD_INT 1
43304: DEC
43305: ST_TO_ADDR
43306: LD_EXP 74
43310: PUSH
43311: FOR_TO
43312: IFFALSE 43533
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
43314: LD_ADDR_VAR 0 4
43318: PUSH
43319: LD_EXP 74
43323: PUSH
43324: LD_VAR 0 2
43328: ARRAY
43329: PPUSH
43330: LD_INT 21
43332: PUSH
43333: LD_INT 1
43335: PUSH
43336: EMPTY
43337: LIST
43338: LIST
43339: PPUSH
43340: CALL_OW 72
43344: PUSH
43345: LD_EXP 103
43349: PUSH
43350: LD_VAR 0 2
43354: ARRAY
43355: UNION
43356: ST_TO_ADDR
// if not tmp then
43357: LD_VAR 0 4
43361: NOT
43362: IFFALSE 43366
// continue ;
43364: GO 43311
// for j in tmp do
43366: LD_ADDR_VAR 0 3
43370: PUSH
43371: LD_VAR 0 4
43375: PUSH
43376: FOR_IN
43377: IFFALSE 43529
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
43379: LD_VAR 0 3
43383: PPUSH
43384: CALL_OW 110
43388: NOT
43389: PUSH
43390: LD_VAR 0 3
43394: PPUSH
43395: CALL_OW 314
43399: NOT
43400: AND
43401: PUSH
43402: LD_VAR 0 3
43406: PPUSH
43407: CALL_OW 311
43411: NOT
43412: AND
43413: PUSH
43414: LD_VAR 0 3
43418: PPUSH
43419: CALL_OW 310
43423: NOT
43424: AND
43425: PUSH
43426: LD_VAR 0 3
43430: PUSH
43431: LD_EXP 77
43435: PUSH
43436: LD_VAR 0 2
43440: ARRAY
43441: PUSH
43442: LD_INT 1
43444: ARRAY
43445: IN
43446: NOT
43447: AND
43448: PUSH
43449: LD_VAR 0 3
43453: PUSH
43454: LD_EXP 77
43458: PUSH
43459: LD_VAR 0 2
43463: ARRAY
43464: PUSH
43465: LD_INT 2
43467: ARRAY
43468: IN
43469: NOT
43470: AND
43471: PUSH
43472: LD_VAR 0 3
43476: PUSH
43477: LD_EXP 86
43481: PUSH
43482: LD_VAR 0 2
43486: ARRAY
43487: IN
43488: NOT
43489: AND
43490: IFFALSE 43527
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
43492: LD_VAR 0 2
43496: PPUSH
43497: LD_EXP 74
43501: PUSH
43502: LD_VAR 0 2
43506: ARRAY
43507: PPUSH
43508: LD_VAR 0 3
43512: PPUSH
43513: LD_VAR 0 3
43517: PPUSH
43518: CALL_OW 257
43522: PPUSH
43523: CALL 42299 0 4
// end ;
43527: GO 43376
43529: POP
43530: POP
// end ;
43531: GO 43311
43533: POP
43534: POP
// end ;
43535: LD_VAR 0 1
43539: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
43540: LD_INT 0
43542: PPUSH
43543: PPUSH
43544: PPUSH
43545: PPUSH
43546: PPUSH
43547: PPUSH
// if not mc_bases [ base ] then
43548: LD_EXP 74
43552: PUSH
43553: LD_VAR 0 1
43557: ARRAY
43558: NOT
43559: IFFALSE 43563
// exit ;
43561: GO 43745
// tmp := [ ] ;
43563: LD_ADDR_VAR 0 6
43567: PUSH
43568: EMPTY
43569: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
43570: LD_ADDR_VAR 0 7
43574: PUSH
43575: LD_VAR 0 3
43579: PPUSH
43580: LD_INT 0
43582: PPUSH
43583: CALL_OW 517
43587: ST_TO_ADDR
// if not list then
43588: LD_VAR 0 7
43592: NOT
43593: IFFALSE 43597
// exit ;
43595: GO 43745
// for i = 1 to amount do
43597: LD_ADDR_VAR 0 5
43601: PUSH
43602: DOUBLE
43603: LD_INT 1
43605: DEC
43606: ST_TO_ADDR
43607: LD_VAR 0 2
43611: PUSH
43612: FOR_TO
43613: IFFALSE 43693
// begin x := rand ( 1 , list [ 1 ] ) ;
43615: LD_ADDR_VAR 0 8
43619: PUSH
43620: LD_INT 1
43622: PPUSH
43623: LD_VAR 0 7
43627: PUSH
43628: LD_INT 1
43630: ARRAY
43631: PPUSH
43632: CALL_OW 12
43636: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
43637: LD_ADDR_VAR 0 6
43641: PUSH
43642: LD_VAR 0 6
43646: PPUSH
43647: LD_VAR 0 5
43651: PPUSH
43652: LD_VAR 0 7
43656: PUSH
43657: LD_INT 1
43659: ARRAY
43660: PUSH
43661: LD_VAR 0 8
43665: ARRAY
43666: PUSH
43667: LD_VAR 0 7
43671: PUSH
43672: LD_INT 2
43674: ARRAY
43675: PUSH
43676: LD_VAR 0 8
43680: ARRAY
43681: PUSH
43682: EMPTY
43683: LIST
43684: LIST
43685: PPUSH
43686: CALL_OW 1
43690: ST_TO_ADDR
// end ;
43691: GO 43612
43693: POP
43694: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
43695: LD_ADDR_EXP 87
43699: PUSH
43700: LD_EXP 87
43704: PPUSH
43705: LD_VAR 0 1
43709: PPUSH
43710: LD_VAR 0 6
43714: PPUSH
43715: CALL_OW 1
43719: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
43720: LD_ADDR_EXP 89
43724: PUSH
43725: LD_EXP 89
43729: PPUSH
43730: LD_VAR 0 1
43734: PPUSH
43735: LD_VAR 0 3
43739: PPUSH
43740: CALL_OW 1
43744: ST_TO_ADDR
// end ;
43745: LD_VAR 0 4
43749: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
43750: LD_INT 0
43752: PPUSH
// if not mc_bases [ base ] then
43753: LD_EXP 74
43757: PUSH
43758: LD_VAR 0 1
43762: ARRAY
43763: NOT
43764: IFFALSE 43768
// exit ;
43766: GO 43793
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
43768: LD_ADDR_EXP 79
43772: PUSH
43773: LD_EXP 79
43777: PPUSH
43778: LD_VAR 0 1
43782: PPUSH
43783: LD_VAR 0 2
43787: PPUSH
43788: CALL_OW 1
43792: ST_TO_ADDR
// end ;
43793: LD_VAR 0 3
43797: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
43798: LD_INT 0
43800: PPUSH
// if not mc_bases [ base ] then
43801: LD_EXP 74
43805: PUSH
43806: LD_VAR 0 1
43810: ARRAY
43811: NOT
43812: IFFALSE 43816
// exit ;
43814: GO 43853
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
43816: LD_ADDR_EXP 79
43820: PUSH
43821: LD_EXP 79
43825: PPUSH
43826: LD_VAR 0 1
43830: PPUSH
43831: LD_EXP 79
43835: PUSH
43836: LD_VAR 0 1
43840: ARRAY
43841: PUSH
43842: LD_VAR 0 2
43846: UNION
43847: PPUSH
43848: CALL_OW 1
43852: ST_TO_ADDR
// end ;
43853: LD_VAR 0 3
43857: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
43858: LD_INT 0
43860: PPUSH
// if not mc_bases [ base ] then
43861: LD_EXP 74
43865: PUSH
43866: LD_VAR 0 1
43870: ARRAY
43871: NOT
43872: IFFALSE 43876
// exit ;
43874: GO 43901
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
43876: LD_ADDR_EXP 95
43880: PUSH
43881: LD_EXP 95
43885: PPUSH
43886: LD_VAR 0 1
43890: PPUSH
43891: LD_VAR 0 2
43895: PPUSH
43896: CALL_OW 1
43900: ST_TO_ADDR
// end ;
43901: LD_VAR 0 3
43905: RET
// export function MC_InsertProduceList ( base , components ) ; begin
43906: LD_INT 0
43908: PPUSH
// if not mc_bases [ base ] then
43909: LD_EXP 74
43913: PUSH
43914: LD_VAR 0 1
43918: ARRAY
43919: NOT
43920: IFFALSE 43924
// exit ;
43922: GO 43961
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
43924: LD_ADDR_EXP 95
43928: PUSH
43929: LD_EXP 95
43933: PPUSH
43934: LD_VAR 0 1
43938: PPUSH
43939: LD_EXP 95
43943: PUSH
43944: LD_VAR 0 1
43948: ARRAY
43949: PUSH
43950: LD_VAR 0 2
43954: ADD
43955: PPUSH
43956: CALL_OW 1
43960: ST_TO_ADDR
// end ;
43961: LD_VAR 0 3
43965: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
43966: LD_INT 0
43968: PPUSH
// if not mc_bases [ base ] then
43969: LD_EXP 74
43973: PUSH
43974: LD_VAR 0 1
43978: ARRAY
43979: NOT
43980: IFFALSE 43984
// exit ;
43982: GO 44038
// mc_defender := Replace ( mc_defender , base , deflist ) ;
43984: LD_ADDR_EXP 96
43988: PUSH
43989: LD_EXP 96
43993: PPUSH
43994: LD_VAR 0 1
43998: PPUSH
43999: LD_VAR 0 2
44003: PPUSH
44004: CALL_OW 1
44008: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
44009: LD_ADDR_EXP 85
44013: PUSH
44014: LD_EXP 85
44018: PPUSH
44019: LD_VAR 0 1
44023: PPUSH
44024: LD_VAR 0 2
44028: PUSH
44029: LD_INT 0
44031: PLUS
44032: PPUSH
44033: CALL_OW 1
44037: ST_TO_ADDR
// end ;
44038: LD_VAR 0 3
44042: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
44043: LD_INT 0
44045: PPUSH
// if not mc_bases [ base ] then
44046: LD_EXP 74
44050: PUSH
44051: LD_VAR 0 1
44055: ARRAY
44056: NOT
44057: IFFALSE 44061
// exit ;
44059: GO 44086
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
44061: LD_ADDR_EXP 85
44065: PUSH
44066: LD_EXP 85
44070: PPUSH
44071: LD_VAR 0 1
44075: PPUSH
44076: LD_VAR 0 2
44080: PPUSH
44081: CALL_OW 1
44085: ST_TO_ADDR
// end ;
44086: LD_VAR 0 3
44090: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
44091: LD_INT 0
44093: PPUSH
44094: PPUSH
44095: PPUSH
44096: PPUSH
// if not mc_bases [ base ] then
44097: LD_EXP 74
44101: PUSH
44102: LD_VAR 0 1
44106: ARRAY
44107: NOT
44108: IFFALSE 44112
// exit ;
44110: GO 44177
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
44112: LD_ADDR_EXP 94
44116: PUSH
44117: LD_EXP 94
44121: PPUSH
44122: LD_VAR 0 1
44126: PUSH
44127: LD_EXP 94
44131: PUSH
44132: LD_VAR 0 1
44136: ARRAY
44137: PUSH
44138: LD_INT 1
44140: PLUS
44141: PUSH
44142: EMPTY
44143: LIST
44144: LIST
44145: PPUSH
44146: LD_VAR 0 1
44150: PUSH
44151: LD_VAR 0 2
44155: PUSH
44156: LD_VAR 0 3
44160: PUSH
44161: LD_VAR 0 4
44165: PUSH
44166: EMPTY
44167: LIST
44168: LIST
44169: LIST
44170: LIST
44171: PPUSH
44172: CALL 57487 0 3
44176: ST_TO_ADDR
// end ;
44177: LD_VAR 0 5
44181: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
44182: LD_INT 0
44184: PPUSH
// if not mc_bases [ base ] then
44185: LD_EXP 74
44189: PUSH
44190: LD_VAR 0 1
44194: ARRAY
44195: NOT
44196: IFFALSE 44200
// exit ;
44198: GO 44225
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
44200: LD_ADDR_EXP 111
44204: PUSH
44205: LD_EXP 111
44209: PPUSH
44210: LD_VAR 0 1
44214: PPUSH
44215: LD_VAR 0 2
44219: PPUSH
44220: CALL_OW 1
44224: ST_TO_ADDR
// end ;
44225: LD_VAR 0 3
44229: RET
// export function MC_GetMinesField ( base ) ; begin
44230: LD_INT 0
44232: PPUSH
// result := mc_mines [ base ] ;
44233: LD_ADDR_VAR 0 2
44237: PUSH
44238: LD_EXP 87
44242: PUSH
44243: LD_VAR 0 1
44247: ARRAY
44248: ST_TO_ADDR
// end ;
44249: LD_VAR 0 2
44253: RET
// export function MC_GetProduceList ( base ) ; begin
44254: LD_INT 0
44256: PPUSH
// result := mc_produce [ base ] ;
44257: LD_ADDR_VAR 0 2
44261: PUSH
44262: LD_EXP 95
44266: PUSH
44267: LD_VAR 0 1
44271: ARRAY
44272: ST_TO_ADDR
// end ;
44273: LD_VAR 0 2
44277: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
44278: LD_INT 0
44280: PPUSH
44281: PPUSH
// if not mc_bases then
44282: LD_EXP 74
44286: NOT
44287: IFFALSE 44291
// exit ;
44289: GO 44356
// if mc_bases [ base ] then
44291: LD_EXP 74
44295: PUSH
44296: LD_VAR 0 1
44300: ARRAY
44301: IFFALSE 44356
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44303: LD_ADDR_VAR 0 3
44307: PUSH
44308: LD_EXP 74
44312: PUSH
44313: LD_VAR 0 1
44317: ARRAY
44318: PPUSH
44319: LD_INT 30
44321: PUSH
44322: LD_VAR 0 2
44326: PUSH
44327: EMPTY
44328: LIST
44329: LIST
44330: PPUSH
44331: CALL_OW 72
44335: ST_TO_ADDR
// if result then
44336: LD_VAR 0 3
44340: IFFALSE 44356
// result := result [ 1 ] ;
44342: LD_ADDR_VAR 0 3
44346: PUSH
44347: LD_VAR 0 3
44351: PUSH
44352: LD_INT 1
44354: ARRAY
44355: ST_TO_ADDR
// end ; end ;
44356: LD_VAR 0 3
44360: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
44361: LD_INT 0
44363: PPUSH
44364: PPUSH
// if not mc_bases then
44365: LD_EXP 74
44369: NOT
44370: IFFALSE 44374
// exit ;
44372: GO 44419
// if mc_bases [ base ] then
44374: LD_EXP 74
44378: PUSH
44379: LD_VAR 0 1
44383: ARRAY
44384: IFFALSE 44419
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44386: LD_ADDR_VAR 0 3
44390: PUSH
44391: LD_EXP 74
44395: PUSH
44396: LD_VAR 0 1
44400: ARRAY
44401: PPUSH
44402: LD_INT 30
44404: PUSH
44405: LD_VAR 0 2
44409: PUSH
44410: EMPTY
44411: LIST
44412: LIST
44413: PPUSH
44414: CALL_OW 72
44418: ST_TO_ADDR
// end ;
44419: LD_VAR 0 3
44423: RET
// export function MC_SetTame ( base , area ) ; begin
44424: LD_INT 0
44426: PPUSH
// if not mc_bases or not base then
44427: LD_EXP 74
44431: NOT
44432: PUSH
44433: LD_VAR 0 1
44437: NOT
44438: OR
44439: IFFALSE 44443
// exit ;
44441: GO 44468
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
44443: LD_ADDR_EXP 102
44447: PUSH
44448: LD_EXP 102
44452: PPUSH
44453: LD_VAR 0 1
44457: PPUSH
44458: LD_VAR 0 2
44462: PPUSH
44463: CALL_OW 1
44467: ST_TO_ADDR
// end ;
44468: LD_VAR 0 3
44472: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
44473: LD_INT 0
44475: PPUSH
44476: PPUSH
// if not mc_bases or not base then
44477: LD_EXP 74
44481: NOT
44482: PUSH
44483: LD_VAR 0 1
44487: NOT
44488: OR
44489: IFFALSE 44493
// exit ;
44491: GO 44595
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44493: LD_ADDR_VAR 0 4
44497: PUSH
44498: LD_EXP 74
44502: PUSH
44503: LD_VAR 0 1
44507: ARRAY
44508: PPUSH
44509: LD_INT 30
44511: PUSH
44512: LD_VAR 0 2
44516: PUSH
44517: EMPTY
44518: LIST
44519: LIST
44520: PPUSH
44521: CALL_OW 72
44525: ST_TO_ADDR
// if not tmp then
44526: LD_VAR 0 4
44530: NOT
44531: IFFALSE 44535
// exit ;
44533: GO 44595
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
44535: LD_ADDR_EXP 106
44539: PUSH
44540: LD_EXP 106
44544: PPUSH
44545: LD_VAR 0 1
44549: PPUSH
44550: LD_EXP 106
44554: PUSH
44555: LD_VAR 0 1
44559: ARRAY
44560: PPUSH
44561: LD_EXP 106
44565: PUSH
44566: LD_VAR 0 1
44570: ARRAY
44571: PUSH
44572: LD_INT 1
44574: PLUS
44575: PPUSH
44576: LD_VAR 0 4
44580: PUSH
44581: LD_INT 1
44583: ARRAY
44584: PPUSH
44585: CALL_OW 2
44589: PPUSH
44590: CALL_OW 1
44594: ST_TO_ADDR
// end ;
44595: LD_VAR 0 3
44599: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
44600: LD_INT 0
44602: PPUSH
44603: PPUSH
// if not mc_bases or not base or not kinds then
44604: LD_EXP 74
44608: NOT
44609: PUSH
44610: LD_VAR 0 1
44614: NOT
44615: OR
44616: PUSH
44617: LD_VAR 0 2
44621: NOT
44622: OR
44623: IFFALSE 44627
// exit ;
44625: GO 44688
// for i in kinds do
44627: LD_ADDR_VAR 0 4
44631: PUSH
44632: LD_VAR 0 2
44636: PUSH
44637: FOR_IN
44638: IFFALSE 44686
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
44640: LD_ADDR_EXP 108
44644: PUSH
44645: LD_EXP 108
44649: PPUSH
44650: LD_VAR 0 1
44654: PUSH
44655: LD_EXP 108
44659: PUSH
44660: LD_VAR 0 1
44664: ARRAY
44665: PUSH
44666: LD_INT 1
44668: PLUS
44669: PUSH
44670: EMPTY
44671: LIST
44672: LIST
44673: PPUSH
44674: LD_VAR 0 4
44678: PPUSH
44679: CALL 57487 0 3
44683: ST_TO_ADDR
44684: GO 44637
44686: POP
44687: POP
// end ;
44688: LD_VAR 0 3
44692: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
44693: LD_INT 0
44695: PPUSH
// if not mc_bases or not base or not areas then
44696: LD_EXP 74
44700: NOT
44701: PUSH
44702: LD_VAR 0 1
44706: NOT
44707: OR
44708: PUSH
44709: LD_VAR 0 2
44713: NOT
44714: OR
44715: IFFALSE 44719
// exit ;
44717: GO 44744
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
44719: LD_ADDR_EXP 92
44723: PUSH
44724: LD_EXP 92
44728: PPUSH
44729: LD_VAR 0 1
44733: PPUSH
44734: LD_VAR 0 2
44738: PPUSH
44739: CALL_OW 1
44743: ST_TO_ADDR
// end ;
44744: LD_VAR 0 3
44748: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
44749: LD_INT 0
44751: PPUSH
// if not mc_bases or not base or not teleports_exit then
44752: LD_EXP 74
44756: NOT
44757: PUSH
44758: LD_VAR 0 1
44762: NOT
44763: OR
44764: PUSH
44765: LD_VAR 0 2
44769: NOT
44770: OR
44771: IFFALSE 44775
// exit ;
44773: GO 44800
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
44775: LD_ADDR_EXP 109
44779: PUSH
44780: LD_EXP 109
44784: PPUSH
44785: LD_VAR 0 1
44789: PPUSH
44790: LD_VAR 0 2
44794: PPUSH
44795: CALL_OW 1
44799: ST_TO_ADDR
// end ;
44800: LD_VAR 0 3
44804: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
44805: LD_INT 0
44807: PPUSH
44808: PPUSH
44809: PPUSH
// if not mc_bases or not base or not ext_list then
44810: LD_EXP 74
44814: NOT
44815: PUSH
44816: LD_VAR 0 1
44820: NOT
44821: OR
44822: PUSH
44823: LD_VAR 0 5
44827: NOT
44828: OR
44829: IFFALSE 44833
// exit ;
44831: GO 45006
// tmp := GetFacExtXYD ( x , y , d ) ;
44833: LD_ADDR_VAR 0 8
44837: PUSH
44838: LD_VAR 0 2
44842: PPUSH
44843: LD_VAR 0 3
44847: PPUSH
44848: LD_VAR 0 4
44852: PPUSH
44853: CALL 90865 0 3
44857: ST_TO_ADDR
// if not tmp then
44858: LD_VAR 0 8
44862: NOT
44863: IFFALSE 44867
// exit ;
44865: GO 45006
// for i in tmp do
44867: LD_ADDR_VAR 0 7
44871: PUSH
44872: LD_VAR 0 8
44876: PUSH
44877: FOR_IN
44878: IFFALSE 45004
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
44880: LD_ADDR_EXP 79
44884: PUSH
44885: LD_EXP 79
44889: PPUSH
44890: LD_VAR 0 1
44894: PPUSH
44895: LD_EXP 79
44899: PUSH
44900: LD_VAR 0 1
44904: ARRAY
44905: PPUSH
44906: LD_EXP 79
44910: PUSH
44911: LD_VAR 0 1
44915: ARRAY
44916: PUSH
44917: LD_INT 1
44919: PLUS
44920: PPUSH
44921: LD_VAR 0 5
44925: PUSH
44926: LD_INT 1
44928: ARRAY
44929: PUSH
44930: LD_VAR 0 7
44934: PUSH
44935: LD_INT 1
44937: ARRAY
44938: PUSH
44939: LD_VAR 0 7
44943: PUSH
44944: LD_INT 2
44946: ARRAY
44947: PUSH
44948: LD_VAR 0 7
44952: PUSH
44953: LD_INT 3
44955: ARRAY
44956: PUSH
44957: EMPTY
44958: LIST
44959: LIST
44960: LIST
44961: LIST
44962: PPUSH
44963: CALL_OW 2
44967: PPUSH
44968: CALL_OW 1
44972: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
44973: LD_ADDR_VAR 0 5
44977: PUSH
44978: LD_VAR 0 5
44982: PPUSH
44983: LD_INT 1
44985: PPUSH
44986: CALL_OW 3
44990: ST_TO_ADDR
// if not ext_list then
44991: LD_VAR 0 5
44995: NOT
44996: IFFALSE 45002
// exit ;
44998: POP
44999: POP
45000: GO 45006
// end ;
45002: GO 44877
45004: POP
45005: POP
// end ;
45006: LD_VAR 0 6
45010: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
45011: LD_INT 0
45013: PPUSH
// if not mc_bases or not base or not weapon_list then
45014: LD_EXP 74
45018: NOT
45019: PUSH
45020: LD_VAR 0 1
45024: NOT
45025: OR
45026: PUSH
45027: LD_VAR 0 2
45031: NOT
45032: OR
45033: IFFALSE 45037
// exit ;
45035: GO 45062
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
45037: LD_ADDR_EXP 113
45041: PUSH
45042: LD_EXP 113
45046: PPUSH
45047: LD_VAR 0 1
45051: PPUSH
45052: LD_VAR 0 2
45056: PPUSH
45057: CALL_OW 1
45061: ST_TO_ADDR
// end ;
45062: LD_VAR 0 3
45066: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
45067: LD_INT 0
45069: PPUSH
// if not mc_bases or not base or not tech_list then
45070: LD_EXP 74
45074: NOT
45075: PUSH
45076: LD_VAR 0 1
45080: NOT
45081: OR
45082: PUSH
45083: LD_VAR 0 2
45087: NOT
45088: OR
45089: IFFALSE 45093
// exit ;
45091: GO 45118
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
45093: LD_ADDR_EXP 101
45097: PUSH
45098: LD_EXP 101
45102: PPUSH
45103: LD_VAR 0 1
45107: PPUSH
45108: LD_VAR 0 2
45112: PPUSH
45113: CALL_OW 1
45117: ST_TO_ADDR
// end ;
45118: LD_VAR 0 3
45122: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
45123: LD_INT 0
45125: PPUSH
// if not mc_bases or not parking_area or not base then
45126: LD_EXP 74
45130: NOT
45131: PUSH
45132: LD_VAR 0 2
45136: NOT
45137: OR
45138: PUSH
45139: LD_VAR 0 1
45143: NOT
45144: OR
45145: IFFALSE 45149
// exit ;
45147: GO 45174
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
45149: LD_ADDR_EXP 98
45153: PUSH
45154: LD_EXP 98
45158: PPUSH
45159: LD_VAR 0 1
45163: PPUSH
45164: LD_VAR 0 2
45168: PPUSH
45169: CALL_OW 1
45173: ST_TO_ADDR
// end ;
45174: LD_VAR 0 3
45178: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
45179: LD_INT 0
45181: PPUSH
// if not mc_bases or not base or not scan_area then
45182: LD_EXP 74
45186: NOT
45187: PUSH
45188: LD_VAR 0 1
45192: NOT
45193: OR
45194: PUSH
45195: LD_VAR 0 2
45199: NOT
45200: OR
45201: IFFALSE 45205
// exit ;
45203: GO 45230
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
45205: LD_ADDR_EXP 99
45209: PUSH
45210: LD_EXP 99
45214: PPUSH
45215: LD_VAR 0 1
45219: PPUSH
45220: LD_VAR 0 2
45224: PPUSH
45225: CALL_OW 1
45229: ST_TO_ADDR
// end ;
45230: LD_VAR 0 3
45234: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
45235: LD_INT 0
45237: PPUSH
45238: PPUSH
// if not mc_bases or not base then
45239: LD_EXP 74
45243: NOT
45244: PUSH
45245: LD_VAR 0 1
45249: NOT
45250: OR
45251: IFFALSE 45255
// exit ;
45253: GO 45319
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
45255: LD_ADDR_VAR 0 3
45259: PUSH
45260: LD_INT 1
45262: PUSH
45263: LD_INT 2
45265: PUSH
45266: LD_INT 3
45268: PUSH
45269: LD_INT 4
45271: PUSH
45272: LD_INT 11
45274: PUSH
45275: EMPTY
45276: LIST
45277: LIST
45278: LIST
45279: LIST
45280: LIST
45281: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
45282: LD_ADDR_EXP 101
45286: PUSH
45287: LD_EXP 101
45291: PPUSH
45292: LD_VAR 0 1
45296: PPUSH
45297: LD_EXP 101
45301: PUSH
45302: LD_VAR 0 1
45306: ARRAY
45307: PUSH
45308: LD_VAR 0 3
45312: DIFF
45313: PPUSH
45314: CALL_OW 1
45318: ST_TO_ADDR
// end ;
45319: LD_VAR 0 2
45323: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
45324: LD_INT 0
45326: PPUSH
// result := mc_vehicles [ base ] ;
45327: LD_ADDR_VAR 0 3
45331: PUSH
45332: LD_EXP 93
45336: PUSH
45337: LD_VAR 0 1
45341: ARRAY
45342: ST_TO_ADDR
// if onlyCombat then
45343: LD_VAR 0 2
45347: IFFALSE 45512
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
45349: LD_ADDR_VAR 0 3
45353: PUSH
45354: LD_VAR 0 3
45358: PUSH
45359: LD_VAR 0 3
45363: PPUSH
45364: LD_INT 2
45366: PUSH
45367: LD_INT 34
45369: PUSH
45370: LD_INT 12
45372: PUSH
45373: EMPTY
45374: LIST
45375: LIST
45376: PUSH
45377: LD_INT 34
45379: PUSH
45380: LD_INT 51
45382: PUSH
45383: EMPTY
45384: LIST
45385: LIST
45386: PUSH
45387: LD_INT 34
45389: PUSH
45390: LD_EXP 68
45394: PUSH
45395: EMPTY
45396: LIST
45397: LIST
45398: PUSH
45399: LD_INT 34
45401: PUSH
45402: LD_INT 32
45404: PUSH
45405: EMPTY
45406: LIST
45407: LIST
45408: PUSH
45409: LD_INT 34
45411: PUSH
45412: LD_INT 13
45414: PUSH
45415: EMPTY
45416: LIST
45417: LIST
45418: PUSH
45419: LD_INT 34
45421: PUSH
45422: LD_INT 52
45424: PUSH
45425: EMPTY
45426: LIST
45427: LIST
45428: PUSH
45429: LD_INT 34
45431: PUSH
45432: LD_INT 14
45434: PUSH
45435: EMPTY
45436: LIST
45437: LIST
45438: PUSH
45439: LD_INT 34
45441: PUSH
45442: LD_INT 53
45444: PUSH
45445: EMPTY
45446: LIST
45447: LIST
45448: PUSH
45449: LD_INT 34
45451: PUSH
45452: LD_EXP 67
45456: PUSH
45457: EMPTY
45458: LIST
45459: LIST
45460: PUSH
45461: LD_INT 34
45463: PUSH
45464: LD_INT 31
45466: PUSH
45467: EMPTY
45468: LIST
45469: LIST
45470: PUSH
45471: LD_INT 34
45473: PUSH
45474: LD_INT 48
45476: PUSH
45477: EMPTY
45478: LIST
45479: LIST
45480: PUSH
45481: LD_INT 34
45483: PUSH
45484: LD_INT 8
45486: PUSH
45487: EMPTY
45488: LIST
45489: LIST
45490: PUSH
45491: EMPTY
45492: LIST
45493: LIST
45494: LIST
45495: LIST
45496: LIST
45497: LIST
45498: LIST
45499: LIST
45500: LIST
45501: LIST
45502: LIST
45503: LIST
45504: LIST
45505: PPUSH
45506: CALL_OW 72
45510: DIFF
45511: ST_TO_ADDR
// end ; end_of_file
45512: LD_VAR 0 3
45516: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
45517: LD_INT 0
45519: PPUSH
45520: PPUSH
45521: PPUSH
// if not mc_bases or not skirmish then
45522: LD_EXP 74
45526: NOT
45527: PUSH
45528: LD_EXP 72
45532: NOT
45533: OR
45534: IFFALSE 45538
// exit ;
45536: GO 45703
// for i = 1 to mc_bases do
45538: LD_ADDR_VAR 0 4
45542: PUSH
45543: DOUBLE
45544: LD_INT 1
45546: DEC
45547: ST_TO_ADDR
45548: LD_EXP 74
45552: PUSH
45553: FOR_TO
45554: IFFALSE 45701
// begin if sci in mc_bases [ i ] then
45556: LD_VAR 0 2
45560: PUSH
45561: LD_EXP 74
45565: PUSH
45566: LD_VAR 0 4
45570: ARRAY
45571: IN
45572: IFFALSE 45699
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
45574: LD_ADDR_EXP 103
45578: PUSH
45579: LD_EXP 103
45583: PPUSH
45584: LD_VAR 0 4
45588: PUSH
45589: LD_EXP 103
45593: PUSH
45594: LD_VAR 0 4
45598: ARRAY
45599: PUSH
45600: LD_INT 1
45602: PLUS
45603: PUSH
45604: EMPTY
45605: LIST
45606: LIST
45607: PPUSH
45608: LD_VAR 0 1
45612: PPUSH
45613: CALL 57487 0 3
45617: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
45618: LD_ADDR_VAR 0 5
45622: PUSH
45623: LD_EXP 74
45627: PUSH
45628: LD_VAR 0 4
45632: ARRAY
45633: PPUSH
45634: LD_INT 2
45636: PUSH
45637: LD_INT 30
45639: PUSH
45640: LD_INT 0
45642: PUSH
45643: EMPTY
45644: LIST
45645: LIST
45646: PUSH
45647: LD_INT 30
45649: PUSH
45650: LD_INT 1
45652: PUSH
45653: EMPTY
45654: LIST
45655: LIST
45656: PUSH
45657: EMPTY
45658: LIST
45659: LIST
45660: LIST
45661: PPUSH
45662: CALL_OW 72
45666: PPUSH
45667: LD_VAR 0 1
45671: PPUSH
45672: CALL_OW 74
45676: ST_TO_ADDR
// if tmp then
45677: LD_VAR 0 5
45681: IFFALSE 45697
// ComStandNearbyBuilding ( ape , tmp ) ;
45683: LD_VAR 0 1
45687: PPUSH
45688: LD_VAR 0 5
45692: PPUSH
45693: CALL 51690 0 2
// break ;
45697: GO 45701
// end ; end ;
45699: GO 45553
45701: POP
45702: POP
// end ;
45703: LD_VAR 0 3
45707: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
45708: LD_INT 0
45710: PPUSH
45711: PPUSH
45712: PPUSH
// if not mc_bases or not skirmish then
45713: LD_EXP 74
45717: NOT
45718: PUSH
45719: LD_EXP 72
45723: NOT
45724: OR
45725: IFFALSE 45729
// exit ;
45727: GO 45818
// for i = 1 to mc_bases do
45729: LD_ADDR_VAR 0 4
45733: PUSH
45734: DOUBLE
45735: LD_INT 1
45737: DEC
45738: ST_TO_ADDR
45739: LD_EXP 74
45743: PUSH
45744: FOR_TO
45745: IFFALSE 45816
// begin if building in mc_busy_turret_list [ i ] then
45747: LD_VAR 0 1
45751: PUSH
45752: LD_EXP 84
45756: PUSH
45757: LD_VAR 0 4
45761: ARRAY
45762: IN
45763: IFFALSE 45814
// begin tmp := mc_busy_turret_list [ i ] diff building ;
45765: LD_ADDR_VAR 0 5
45769: PUSH
45770: LD_EXP 84
45774: PUSH
45775: LD_VAR 0 4
45779: ARRAY
45780: PUSH
45781: LD_VAR 0 1
45785: DIFF
45786: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
45787: LD_ADDR_EXP 84
45791: PUSH
45792: LD_EXP 84
45796: PPUSH
45797: LD_VAR 0 4
45801: PPUSH
45802: LD_VAR 0 5
45806: PPUSH
45807: CALL_OW 1
45811: ST_TO_ADDR
// break ;
45812: GO 45816
// end ; end ;
45814: GO 45744
45816: POP
45817: POP
// end ;
45818: LD_VAR 0 3
45822: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
45823: LD_INT 0
45825: PPUSH
45826: PPUSH
45827: PPUSH
// if not mc_bases or not skirmish then
45828: LD_EXP 74
45832: NOT
45833: PUSH
45834: LD_EXP 72
45838: NOT
45839: OR
45840: IFFALSE 45844
// exit ;
45842: GO 46043
// for i = 1 to mc_bases do
45844: LD_ADDR_VAR 0 5
45848: PUSH
45849: DOUBLE
45850: LD_INT 1
45852: DEC
45853: ST_TO_ADDR
45854: LD_EXP 74
45858: PUSH
45859: FOR_TO
45860: IFFALSE 46041
// if building in mc_bases [ i ] then
45862: LD_VAR 0 1
45866: PUSH
45867: LD_EXP 74
45871: PUSH
45872: LD_VAR 0 5
45876: ARRAY
45877: IN
45878: IFFALSE 46039
// begin tmp := mc_bases [ i ] diff building ;
45880: LD_ADDR_VAR 0 6
45884: PUSH
45885: LD_EXP 74
45889: PUSH
45890: LD_VAR 0 5
45894: ARRAY
45895: PUSH
45896: LD_VAR 0 1
45900: DIFF
45901: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
45902: LD_ADDR_EXP 74
45906: PUSH
45907: LD_EXP 74
45911: PPUSH
45912: LD_VAR 0 5
45916: PPUSH
45917: LD_VAR 0 6
45921: PPUSH
45922: CALL_OW 1
45926: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
45927: LD_VAR 0 1
45931: PUSH
45932: LD_EXP 82
45936: PUSH
45937: LD_VAR 0 5
45941: ARRAY
45942: IN
45943: IFFALSE 45982
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
45945: LD_ADDR_EXP 82
45949: PUSH
45950: LD_EXP 82
45954: PPUSH
45955: LD_VAR 0 5
45959: PPUSH
45960: LD_EXP 82
45964: PUSH
45965: LD_VAR 0 5
45969: ARRAY
45970: PUSH
45971: LD_VAR 0 1
45975: DIFF
45976: PPUSH
45977: CALL_OW 1
45981: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
45982: LD_VAR 0 1
45986: PUSH
45987: LD_EXP 83
45991: PUSH
45992: LD_VAR 0 5
45996: ARRAY
45997: IN
45998: IFFALSE 46037
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
46000: LD_ADDR_EXP 83
46004: PUSH
46005: LD_EXP 83
46009: PPUSH
46010: LD_VAR 0 5
46014: PPUSH
46015: LD_EXP 83
46019: PUSH
46020: LD_VAR 0 5
46024: ARRAY
46025: PUSH
46026: LD_VAR 0 1
46030: DIFF
46031: PPUSH
46032: CALL_OW 1
46036: ST_TO_ADDR
// break ;
46037: GO 46041
// end ;
46039: GO 45859
46041: POP
46042: POP
// end ;
46043: LD_VAR 0 4
46047: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
46048: LD_INT 0
46050: PPUSH
46051: PPUSH
46052: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
46053: LD_EXP 74
46057: NOT
46058: PUSH
46059: LD_EXP 72
46063: NOT
46064: OR
46065: PUSH
46066: LD_VAR 0 3
46070: PUSH
46071: LD_EXP 100
46075: IN
46076: NOT
46077: OR
46078: IFFALSE 46082
// exit ;
46080: GO 46205
// for i = 1 to mc_vehicles do
46082: LD_ADDR_VAR 0 6
46086: PUSH
46087: DOUBLE
46088: LD_INT 1
46090: DEC
46091: ST_TO_ADDR
46092: LD_EXP 93
46096: PUSH
46097: FOR_TO
46098: IFFALSE 46203
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
46100: LD_VAR 0 2
46104: PUSH
46105: LD_EXP 93
46109: PUSH
46110: LD_VAR 0 6
46114: ARRAY
46115: IN
46116: PUSH
46117: LD_VAR 0 1
46121: PUSH
46122: LD_EXP 93
46126: PUSH
46127: LD_VAR 0 6
46131: ARRAY
46132: IN
46133: OR
46134: IFFALSE 46201
// begin tmp := mc_vehicles [ i ] diff old ;
46136: LD_ADDR_VAR 0 7
46140: PUSH
46141: LD_EXP 93
46145: PUSH
46146: LD_VAR 0 6
46150: ARRAY
46151: PUSH
46152: LD_VAR 0 2
46156: DIFF
46157: ST_TO_ADDR
// tmp := tmp diff new ;
46158: LD_ADDR_VAR 0 7
46162: PUSH
46163: LD_VAR 0 7
46167: PUSH
46168: LD_VAR 0 1
46172: DIFF
46173: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
46174: LD_ADDR_EXP 93
46178: PUSH
46179: LD_EXP 93
46183: PPUSH
46184: LD_VAR 0 6
46188: PPUSH
46189: LD_VAR 0 7
46193: PPUSH
46194: CALL_OW 1
46198: ST_TO_ADDR
// break ;
46199: GO 46203
// end ;
46201: GO 46097
46203: POP
46204: POP
// end ;
46205: LD_VAR 0 5
46209: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
46210: LD_INT 0
46212: PPUSH
46213: PPUSH
46214: PPUSH
46215: PPUSH
// if not mc_bases or not skirmish then
46216: LD_EXP 74
46220: NOT
46221: PUSH
46222: LD_EXP 72
46226: NOT
46227: OR
46228: IFFALSE 46232
// exit ;
46230: GO 46609
// side := GetSide ( vehicle ) ;
46232: LD_ADDR_VAR 0 5
46236: PUSH
46237: LD_VAR 0 1
46241: PPUSH
46242: CALL_OW 255
46246: ST_TO_ADDR
// for i = 1 to mc_bases do
46247: LD_ADDR_VAR 0 4
46251: PUSH
46252: DOUBLE
46253: LD_INT 1
46255: DEC
46256: ST_TO_ADDR
46257: LD_EXP 74
46261: PUSH
46262: FOR_TO
46263: IFFALSE 46607
// begin if factory in mc_bases [ i ] then
46265: LD_VAR 0 2
46269: PUSH
46270: LD_EXP 74
46274: PUSH
46275: LD_VAR 0 4
46279: ARRAY
46280: IN
46281: IFFALSE 46605
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
46283: LD_EXP 96
46287: PUSH
46288: LD_VAR 0 4
46292: ARRAY
46293: PUSH
46294: LD_EXP 85
46298: PUSH
46299: LD_VAR 0 4
46303: ARRAY
46304: LESS
46305: PUSH
46306: LD_VAR 0 1
46310: PPUSH
46311: CALL_OW 264
46315: PUSH
46316: LD_INT 31
46318: PUSH
46319: LD_INT 32
46321: PUSH
46322: LD_INT 51
46324: PUSH
46325: LD_EXP 68
46329: PUSH
46330: LD_INT 12
46332: PUSH
46333: LD_INT 30
46335: PUSH
46336: LD_EXP 67
46340: PUSH
46341: LD_INT 11
46343: PUSH
46344: LD_INT 53
46346: PUSH
46347: LD_INT 14
46349: PUSH
46350: LD_EXP 71
46354: PUSH
46355: LD_INT 29
46357: PUSH
46358: LD_EXP 69
46362: PUSH
46363: LD_INT 13
46365: PUSH
46366: LD_INT 52
46368: PUSH
46369: LD_INT 48
46371: PUSH
46372: LD_INT 8
46374: PUSH
46375: EMPTY
46376: LIST
46377: LIST
46378: LIST
46379: LIST
46380: LIST
46381: LIST
46382: LIST
46383: LIST
46384: LIST
46385: LIST
46386: LIST
46387: LIST
46388: LIST
46389: LIST
46390: LIST
46391: LIST
46392: LIST
46393: IN
46394: NOT
46395: AND
46396: IFFALSE 46444
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
46398: LD_ADDR_EXP 96
46402: PUSH
46403: LD_EXP 96
46407: PPUSH
46408: LD_VAR 0 4
46412: PUSH
46413: LD_EXP 96
46417: PUSH
46418: LD_VAR 0 4
46422: ARRAY
46423: PUSH
46424: LD_INT 1
46426: PLUS
46427: PUSH
46428: EMPTY
46429: LIST
46430: LIST
46431: PPUSH
46432: LD_VAR 0 1
46436: PPUSH
46437: CALL 57487 0 3
46441: ST_TO_ADDR
46442: GO 46488
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
46444: LD_ADDR_EXP 93
46448: PUSH
46449: LD_EXP 93
46453: PPUSH
46454: LD_VAR 0 4
46458: PUSH
46459: LD_EXP 93
46463: PUSH
46464: LD_VAR 0 4
46468: ARRAY
46469: PUSH
46470: LD_INT 1
46472: PLUS
46473: PUSH
46474: EMPTY
46475: LIST
46476: LIST
46477: PPUSH
46478: LD_VAR 0 1
46482: PPUSH
46483: CALL 57487 0 3
46487: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
46488: LD_VAR 0 1
46492: PPUSH
46493: CALL_OW 263
46497: PUSH
46498: LD_INT 2
46500: EQUAL
46501: IFFALSE 46521
// begin repeat wait ( 0 0$1 ) ;
46503: LD_INT 35
46505: PPUSH
46506: CALL_OW 67
// until IsControledBy ( vehicle ) ;
46510: LD_VAR 0 1
46514: PPUSH
46515: CALL_OW 312
46519: IFFALSE 46503
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
46521: LD_VAR 0 1
46525: PPUSH
46526: LD_EXP 98
46530: PUSH
46531: LD_VAR 0 4
46535: ARRAY
46536: PPUSH
46537: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
46541: LD_VAR 0 1
46545: PPUSH
46546: CALL_OW 263
46550: PUSH
46551: LD_INT 1
46553: NONEQUAL
46554: IFFALSE 46558
// break ;
46556: GO 46607
// repeat wait ( 0 0$1 ) ;
46558: LD_INT 35
46560: PPUSH
46561: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
46565: LD_VAR 0 1
46569: PPUSH
46570: LD_EXP 98
46574: PUSH
46575: LD_VAR 0 4
46579: ARRAY
46580: PPUSH
46581: CALL_OW 308
46585: IFFALSE 46558
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
46587: LD_VAR 0 1
46591: PPUSH
46592: CALL_OW 311
46596: PPUSH
46597: CALL_OW 121
// exit ;
46601: POP
46602: POP
46603: GO 46609
// end ; end ;
46605: GO 46262
46607: POP
46608: POP
// end ;
46609: LD_VAR 0 3
46613: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
46614: LD_INT 0
46616: PPUSH
46617: PPUSH
46618: PPUSH
46619: PPUSH
// if not mc_bases or not skirmish then
46620: LD_EXP 74
46624: NOT
46625: PUSH
46626: LD_EXP 72
46630: NOT
46631: OR
46632: IFFALSE 46636
// exit ;
46634: GO 46989
// repeat wait ( 0 0$1 ) ;
46636: LD_INT 35
46638: PPUSH
46639: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
46643: LD_VAR 0 2
46647: PPUSH
46648: LD_VAR 0 3
46652: PPUSH
46653: CALL_OW 284
46657: IFFALSE 46636
// if GetResourceTypeXY ( x , y ) = mat_artefact then
46659: LD_VAR 0 2
46663: PPUSH
46664: LD_VAR 0 3
46668: PPUSH
46669: CALL_OW 283
46673: PUSH
46674: LD_INT 4
46676: EQUAL
46677: IFFALSE 46681
// exit ;
46679: GO 46989
// for i = 1 to mc_bases do
46681: LD_ADDR_VAR 0 7
46685: PUSH
46686: DOUBLE
46687: LD_INT 1
46689: DEC
46690: ST_TO_ADDR
46691: LD_EXP 74
46695: PUSH
46696: FOR_TO
46697: IFFALSE 46987
// begin if mc_crates_area [ i ] then
46699: LD_EXP 92
46703: PUSH
46704: LD_VAR 0 7
46708: ARRAY
46709: IFFALSE 46820
// for j in mc_crates_area [ i ] do
46711: LD_ADDR_VAR 0 8
46715: PUSH
46716: LD_EXP 92
46720: PUSH
46721: LD_VAR 0 7
46725: ARRAY
46726: PUSH
46727: FOR_IN
46728: IFFALSE 46818
// if InArea ( x , y , j ) then
46730: LD_VAR 0 2
46734: PPUSH
46735: LD_VAR 0 3
46739: PPUSH
46740: LD_VAR 0 8
46744: PPUSH
46745: CALL_OW 309
46749: IFFALSE 46816
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
46751: LD_ADDR_EXP 90
46755: PUSH
46756: LD_EXP 90
46760: PPUSH
46761: LD_VAR 0 7
46765: PUSH
46766: LD_EXP 90
46770: PUSH
46771: LD_VAR 0 7
46775: ARRAY
46776: PUSH
46777: LD_INT 1
46779: PLUS
46780: PUSH
46781: EMPTY
46782: LIST
46783: LIST
46784: PPUSH
46785: LD_VAR 0 4
46789: PUSH
46790: LD_VAR 0 2
46794: PUSH
46795: LD_VAR 0 3
46799: PUSH
46800: EMPTY
46801: LIST
46802: LIST
46803: LIST
46804: PPUSH
46805: CALL 57487 0 3
46809: ST_TO_ADDR
// exit ;
46810: POP
46811: POP
46812: POP
46813: POP
46814: GO 46989
// end ;
46816: GO 46727
46818: POP
46819: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
46820: LD_ADDR_VAR 0 9
46824: PUSH
46825: LD_EXP 74
46829: PUSH
46830: LD_VAR 0 7
46834: ARRAY
46835: PPUSH
46836: LD_INT 2
46838: PUSH
46839: LD_INT 30
46841: PUSH
46842: LD_INT 0
46844: PUSH
46845: EMPTY
46846: LIST
46847: LIST
46848: PUSH
46849: LD_INT 30
46851: PUSH
46852: LD_INT 1
46854: PUSH
46855: EMPTY
46856: LIST
46857: LIST
46858: PUSH
46859: EMPTY
46860: LIST
46861: LIST
46862: LIST
46863: PPUSH
46864: CALL_OW 72
46868: ST_TO_ADDR
// if not depot then
46869: LD_VAR 0 9
46873: NOT
46874: IFFALSE 46878
// continue ;
46876: GO 46696
// for j in depot do
46878: LD_ADDR_VAR 0 8
46882: PUSH
46883: LD_VAR 0 9
46887: PUSH
46888: FOR_IN
46889: IFFALSE 46983
// if GetDistUnitXY ( j , x , y ) < 30 then
46891: LD_VAR 0 8
46895: PPUSH
46896: LD_VAR 0 2
46900: PPUSH
46901: LD_VAR 0 3
46905: PPUSH
46906: CALL_OW 297
46910: PUSH
46911: LD_INT 30
46913: LESS
46914: IFFALSE 46981
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
46916: LD_ADDR_EXP 90
46920: PUSH
46921: LD_EXP 90
46925: PPUSH
46926: LD_VAR 0 7
46930: PUSH
46931: LD_EXP 90
46935: PUSH
46936: LD_VAR 0 7
46940: ARRAY
46941: PUSH
46942: LD_INT 1
46944: PLUS
46945: PUSH
46946: EMPTY
46947: LIST
46948: LIST
46949: PPUSH
46950: LD_VAR 0 4
46954: PUSH
46955: LD_VAR 0 2
46959: PUSH
46960: LD_VAR 0 3
46964: PUSH
46965: EMPTY
46966: LIST
46967: LIST
46968: LIST
46969: PPUSH
46970: CALL 57487 0 3
46974: ST_TO_ADDR
// exit ;
46975: POP
46976: POP
46977: POP
46978: POP
46979: GO 46989
// end ;
46981: GO 46888
46983: POP
46984: POP
// end ;
46985: GO 46696
46987: POP
46988: POP
// end ;
46989: LD_VAR 0 6
46993: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
46994: LD_INT 0
46996: PPUSH
46997: PPUSH
46998: PPUSH
46999: PPUSH
// if not mc_bases or not skirmish then
47000: LD_EXP 74
47004: NOT
47005: PUSH
47006: LD_EXP 72
47010: NOT
47011: OR
47012: IFFALSE 47016
// exit ;
47014: GO 47293
// side := GetSide ( lab ) ;
47016: LD_ADDR_VAR 0 4
47020: PUSH
47021: LD_VAR 0 2
47025: PPUSH
47026: CALL_OW 255
47030: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
47031: LD_VAR 0 4
47035: PUSH
47036: LD_EXP 100
47040: IN
47041: NOT
47042: PUSH
47043: LD_EXP 101
47047: NOT
47048: OR
47049: PUSH
47050: LD_EXP 74
47054: NOT
47055: OR
47056: IFFALSE 47060
// exit ;
47058: GO 47293
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
47060: LD_ADDR_EXP 101
47064: PUSH
47065: LD_EXP 101
47069: PPUSH
47070: LD_VAR 0 4
47074: PPUSH
47075: LD_EXP 101
47079: PUSH
47080: LD_VAR 0 4
47084: ARRAY
47085: PUSH
47086: LD_VAR 0 1
47090: DIFF
47091: PPUSH
47092: CALL_OW 1
47096: ST_TO_ADDR
// for i = 1 to mc_bases do
47097: LD_ADDR_VAR 0 5
47101: PUSH
47102: DOUBLE
47103: LD_INT 1
47105: DEC
47106: ST_TO_ADDR
47107: LD_EXP 74
47111: PUSH
47112: FOR_TO
47113: IFFALSE 47291
// begin if lab in mc_bases [ i ] then
47115: LD_VAR 0 2
47119: PUSH
47120: LD_EXP 74
47124: PUSH
47125: LD_VAR 0 5
47129: ARRAY
47130: IN
47131: IFFALSE 47289
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
47133: LD_VAR 0 1
47137: PUSH
47138: LD_INT 11
47140: PUSH
47141: LD_INT 4
47143: PUSH
47144: LD_INT 3
47146: PUSH
47147: LD_INT 2
47149: PUSH
47150: EMPTY
47151: LIST
47152: LIST
47153: LIST
47154: LIST
47155: IN
47156: PUSH
47157: LD_EXP 104
47161: PUSH
47162: LD_VAR 0 5
47166: ARRAY
47167: AND
47168: IFFALSE 47289
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
47170: LD_ADDR_VAR 0 6
47174: PUSH
47175: LD_EXP 104
47179: PUSH
47180: LD_VAR 0 5
47184: ARRAY
47185: PUSH
47186: LD_INT 1
47188: ARRAY
47189: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
47190: LD_ADDR_EXP 104
47194: PUSH
47195: LD_EXP 104
47199: PPUSH
47200: LD_VAR 0 5
47204: PPUSH
47205: EMPTY
47206: PPUSH
47207: CALL_OW 1
47211: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
47212: LD_VAR 0 6
47216: PPUSH
47217: LD_INT 0
47219: PPUSH
47220: CALL_OW 109
// ComExitBuilding ( tmp ) ;
47224: LD_VAR 0 6
47228: PPUSH
47229: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
47233: LD_ADDR_EXP 103
47237: PUSH
47238: LD_EXP 103
47242: PPUSH
47243: LD_VAR 0 5
47247: PPUSH
47248: LD_EXP 103
47252: PUSH
47253: LD_VAR 0 5
47257: ARRAY
47258: PPUSH
47259: LD_INT 1
47261: PPUSH
47262: LD_VAR 0 6
47266: PPUSH
47267: CALL_OW 2
47271: PPUSH
47272: CALL_OW 1
47276: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
47277: LD_VAR 0 5
47281: PPUSH
47282: LD_INT 112
47284: PPUSH
47285: CALL 24185 0 2
// end ; end ; end ;
47289: GO 47112
47291: POP
47292: POP
// end ;
47293: LD_VAR 0 3
47297: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
47298: LD_INT 0
47300: PPUSH
47301: PPUSH
47302: PPUSH
47303: PPUSH
47304: PPUSH
47305: PPUSH
47306: PPUSH
47307: PPUSH
// if not mc_bases or not skirmish then
47308: LD_EXP 74
47312: NOT
47313: PUSH
47314: LD_EXP 72
47318: NOT
47319: OR
47320: IFFALSE 47324
// exit ;
47322: GO 48695
// for i = 1 to mc_bases do
47324: LD_ADDR_VAR 0 3
47328: PUSH
47329: DOUBLE
47330: LD_INT 1
47332: DEC
47333: ST_TO_ADDR
47334: LD_EXP 74
47338: PUSH
47339: FOR_TO
47340: IFFALSE 48693
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
47342: LD_VAR 0 1
47346: PUSH
47347: LD_EXP 74
47351: PUSH
47352: LD_VAR 0 3
47356: ARRAY
47357: IN
47358: PUSH
47359: LD_VAR 0 1
47363: PUSH
47364: LD_EXP 81
47368: PUSH
47369: LD_VAR 0 3
47373: ARRAY
47374: IN
47375: OR
47376: PUSH
47377: LD_VAR 0 1
47381: PUSH
47382: LD_EXP 96
47386: PUSH
47387: LD_VAR 0 3
47391: ARRAY
47392: IN
47393: OR
47394: PUSH
47395: LD_VAR 0 1
47399: PUSH
47400: LD_EXP 93
47404: PUSH
47405: LD_VAR 0 3
47409: ARRAY
47410: IN
47411: OR
47412: PUSH
47413: LD_VAR 0 1
47417: PUSH
47418: LD_EXP 103
47422: PUSH
47423: LD_VAR 0 3
47427: ARRAY
47428: IN
47429: OR
47430: PUSH
47431: LD_VAR 0 1
47435: PUSH
47436: LD_EXP 104
47440: PUSH
47441: LD_VAR 0 3
47445: ARRAY
47446: IN
47447: OR
47448: IFFALSE 48691
// begin if un in mc_ape [ i ] then
47450: LD_VAR 0 1
47454: PUSH
47455: LD_EXP 103
47459: PUSH
47460: LD_VAR 0 3
47464: ARRAY
47465: IN
47466: IFFALSE 47505
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
47468: LD_ADDR_EXP 103
47472: PUSH
47473: LD_EXP 103
47477: PPUSH
47478: LD_VAR 0 3
47482: PPUSH
47483: LD_EXP 103
47487: PUSH
47488: LD_VAR 0 3
47492: ARRAY
47493: PUSH
47494: LD_VAR 0 1
47498: DIFF
47499: PPUSH
47500: CALL_OW 1
47504: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
47505: LD_VAR 0 1
47509: PUSH
47510: LD_EXP 104
47514: PUSH
47515: LD_VAR 0 3
47519: ARRAY
47520: IN
47521: IFFALSE 47545
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
47523: LD_ADDR_EXP 104
47527: PUSH
47528: LD_EXP 104
47532: PPUSH
47533: LD_VAR 0 3
47537: PPUSH
47538: EMPTY
47539: PPUSH
47540: CALL_OW 1
47544: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
47545: LD_VAR 0 1
47549: PPUSH
47550: CALL_OW 247
47554: PUSH
47555: LD_INT 2
47557: EQUAL
47558: PUSH
47559: LD_VAR 0 1
47563: PPUSH
47564: CALL_OW 110
47568: PUSH
47569: LD_INT 20
47571: EQUAL
47572: PUSH
47573: LD_VAR 0 1
47577: PUSH
47578: LD_EXP 96
47582: PUSH
47583: LD_VAR 0 3
47587: ARRAY
47588: IN
47589: OR
47590: PUSH
47591: LD_VAR 0 1
47595: PPUSH
47596: CALL_OW 264
47600: PUSH
47601: LD_INT 12
47603: PUSH
47604: LD_INT 51
47606: PUSH
47607: LD_EXP 68
47611: PUSH
47612: LD_INT 32
47614: PUSH
47615: LD_INT 13
47617: PUSH
47618: LD_INT 52
47620: PUSH
47621: LD_INT 31
47623: PUSH
47624: EMPTY
47625: LIST
47626: LIST
47627: LIST
47628: LIST
47629: LIST
47630: LIST
47631: LIST
47632: IN
47633: OR
47634: AND
47635: IFFALSE 47943
// begin if un in mc_defender [ i ] then
47637: LD_VAR 0 1
47641: PUSH
47642: LD_EXP 96
47646: PUSH
47647: LD_VAR 0 3
47651: ARRAY
47652: IN
47653: IFFALSE 47692
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
47655: LD_ADDR_EXP 96
47659: PUSH
47660: LD_EXP 96
47664: PPUSH
47665: LD_VAR 0 3
47669: PPUSH
47670: LD_EXP 96
47674: PUSH
47675: LD_VAR 0 3
47679: ARRAY
47680: PUSH
47681: LD_VAR 0 1
47685: DIFF
47686: PPUSH
47687: CALL_OW 1
47691: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
47692: LD_ADDR_VAR 0 8
47696: PUSH
47697: LD_VAR 0 3
47701: PPUSH
47702: LD_INT 3
47704: PPUSH
47705: CALL 44361 0 2
47709: ST_TO_ADDR
// if fac then
47710: LD_VAR 0 8
47714: IFFALSE 47943
// begin for j in fac do
47716: LD_ADDR_VAR 0 4
47720: PUSH
47721: LD_VAR 0 8
47725: PUSH
47726: FOR_IN
47727: IFFALSE 47941
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
47729: LD_ADDR_VAR 0 9
47733: PUSH
47734: LD_VAR 0 8
47738: PPUSH
47739: LD_VAR 0 1
47743: PPUSH
47744: CALL_OW 265
47748: PPUSH
47749: LD_VAR 0 1
47753: PPUSH
47754: CALL_OW 262
47758: PPUSH
47759: LD_VAR 0 1
47763: PPUSH
47764: CALL_OW 263
47768: PPUSH
47769: LD_VAR 0 1
47773: PPUSH
47774: CALL_OW 264
47778: PPUSH
47779: CALL 55019 0 5
47783: ST_TO_ADDR
// if components then
47784: LD_VAR 0 9
47788: IFFALSE 47939
// begin if GetWeapon ( un ) = ar_control_tower then
47790: LD_VAR 0 1
47794: PPUSH
47795: CALL_OW 264
47799: PUSH
47800: LD_INT 31
47802: EQUAL
47803: IFFALSE 47920
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
47805: LD_VAR 0 1
47809: PPUSH
47810: CALL_OW 311
47814: PPUSH
47815: LD_INT 0
47817: PPUSH
47818: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
47822: LD_ADDR_EXP 114
47826: PUSH
47827: LD_EXP 114
47831: PPUSH
47832: LD_VAR 0 3
47836: PPUSH
47837: LD_EXP 114
47841: PUSH
47842: LD_VAR 0 3
47846: ARRAY
47847: PUSH
47848: LD_VAR 0 1
47852: PPUSH
47853: CALL_OW 311
47857: DIFF
47858: PPUSH
47859: CALL_OW 1
47863: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
47864: LD_ADDR_VAR 0 7
47868: PUSH
47869: LD_EXP 95
47873: PUSH
47874: LD_VAR 0 3
47878: ARRAY
47879: PPUSH
47880: LD_INT 1
47882: PPUSH
47883: LD_VAR 0 9
47887: PPUSH
47888: CALL_OW 2
47892: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
47893: LD_ADDR_EXP 95
47897: PUSH
47898: LD_EXP 95
47902: PPUSH
47903: LD_VAR 0 3
47907: PPUSH
47908: LD_VAR 0 7
47912: PPUSH
47913: CALL_OW 1
47917: ST_TO_ADDR
// end else
47918: GO 47937
// MC_InsertProduceList ( i , [ components ] ) ;
47920: LD_VAR 0 3
47924: PPUSH
47925: LD_VAR 0 9
47929: PUSH
47930: EMPTY
47931: LIST
47932: PPUSH
47933: CALL 43906 0 2
// break ;
47937: GO 47941
// end ; end ;
47939: GO 47726
47941: POP
47942: POP
// end ; end ; if GetType ( un ) = unit_building then
47943: LD_VAR 0 1
47947: PPUSH
47948: CALL_OW 247
47952: PUSH
47953: LD_INT 3
47955: EQUAL
47956: IFFALSE 48359
// begin btype := GetBType ( un ) ;
47958: LD_ADDR_VAR 0 5
47962: PUSH
47963: LD_VAR 0 1
47967: PPUSH
47968: CALL_OW 266
47972: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
47973: LD_VAR 0 5
47977: PUSH
47978: LD_INT 29
47980: PUSH
47981: LD_INT 30
47983: PUSH
47984: EMPTY
47985: LIST
47986: LIST
47987: IN
47988: IFFALSE 48061
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
47990: LD_VAR 0 1
47994: PPUSH
47995: CALL_OW 250
47999: PPUSH
48000: LD_VAR 0 1
48004: PPUSH
48005: CALL_OW 251
48009: PPUSH
48010: LD_VAR 0 1
48014: PPUSH
48015: CALL_OW 255
48019: PPUSH
48020: CALL_OW 440
48024: NOT
48025: IFFALSE 48061
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
48027: LD_VAR 0 1
48031: PPUSH
48032: CALL_OW 250
48036: PPUSH
48037: LD_VAR 0 1
48041: PPUSH
48042: CALL_OW 251
48046: PPUSH
48047: LD_VAR 0 1
48051: PPUSH
48052: CALL_OW 255
48056: PPUSH
48057: CALL_OW 441
// end ; if btype = b_warehouse then
48061: LD_VAR 0 5
48065: PUSH
48066: LD_INT 1
48068: EQUAL
48069: IFFALSE 48087
// begin btype := b_depot ;
48071: LD_ADDR_VAR 0 5
48075: PUSH
48076: LD_INT 0
48078: ST_TO_ADDR
// pos := 1 ;
48079: LD_ADDR_VAR 0 6
48083: PUSH
48084: LD_INT 1
48086: ST_TO_ADDR
// end ; if btype = b_factory then
48087: LD_VAR 0 5
48091: PUSH
48092: LD_INT 3
48094: EQUAL
48095: IFFALSE 48113
// begin btype := b_workshop ;
48097: LD_ADDR_VAR 0 5
48101: PUSH
48102: LD_INT 2
48104: ST_TO_ADDR
// pos := 1 ;
48105: LD_ADDR_VAR 0 6
48109: PUSH
48110: LD_INT 1
48112: ST_TO_ADDR
// end ; if btype = b_barracks then
48113: LD_VAR 0 5
48117: PUSH
48118: LD_INT 5
48120: EQUAL
48121: IFFALSE 48131
// btype := b_armoury ;
48123: LD_ADDR_VAR 0 5
48127: PUSH
48128: LD_INT 4
48130: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
48131: LD_VAR 0 5
48135: PUSH
48136: LD_INT 7
48138: PUSH
48139: LD_INT 8
48141: PUSH
48142: EMPTY
48143: LIST
48144: LIST
48145: IN
48146: IFFALSE 48156
// btype := b_lab ;
48148: LD_ADDR_VAR 0 5
48152: PUSH
48153: LD_INT 6
48155: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
48156: LD_ADDR_EXP 79
48160: PUSH
48161: LD_EXP 79
48165: PPUSH
48166: LD_VAR 0 3
48170: PUSH
48171: LD_EXP 79
48175: PUSH
48176: LD_VAR 0 3
48180: ARRAY
48181: PUSH
48182: LD_INT 1
48184: PLUS
48185: PUSH
48186: EMPTY
48187: LIST
48188: LIST
48189: PPUSH
48190: LD_VAR 0 5
48194: PUSH
48195: LD_VAR 0 1
48199: PPUSH
48200: CALL_OW 250
48204: PUSH
48205: LD_VAR 0 1
48209: PPUSH
48210: CALL_OW 251
48214: PUSH
48215: LD_VAR 0 1
48219: PPUSH
48220: CALL_OW 254
48224: PUSH
48225: EMPTY
48226: LIST
48227: LIST
48228: LIST
48229: LIST
48230: PPUSH
48231: CALL 57487 0 3
48235: ST_TO_ADDR
// if pos = 1 then
48236: LD_VAR 0 6
48240: PUSH
48241: LD_INT 1
48243: EQUAL
48244: IFFALSE 48359
// begin tmp := mc_build_list [ i ] ;
48246: LD_ADDR_VAR 0 7
48250: PUSH
48251: LD_EXP 79
48255: PUSH
48256: LD_VAR 0 3
48260: ARRAY
48261: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
48262: LD_VAR 0 7
48266: PPUSH
48267: LD_INT 2
48269: PUSH
48270: LD_INT 30
48272: PUSH
48273: LD_INT 0
48275: PUSH
48276: EMPTY
48277: LIST
48278: LIST
48279: PUSH
48280: LD_INT 30
48282: PUSH
48283: LD_INT 1
48285: PUSH
48286: EMPTY
48287: LIST
48288: LIST
48289: PUSH
48290: EMPTY
48291: LIST
48292: LIST
48293: LIST
48294: PPUSH
48295: CALL_OW 72
48299: IFFALSE 48309
// pos := 2 ;
48301: LD_ADDR_VAR 0 6
48305: PUSH
48306: LD_INT 2
48308: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
48309: LD_ADDR_VAR 0 7
48313: PUSH
48314: LD_VAR 0 7
48318: PPUSH
48319: LD_VAR 0 6
48323: PPUSH
48324: LD_VAR 0 7
48328: PPUSH
48329: CALL 57813 0 3
48333: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
48334: LD_ADDR_EXP 79
48338: PUSH
48339: LD_EXP 79
48343: PPUSH
48344: LD_VAR 0 3
48348: PPUSH
48349: LD_VAR 0 7
48353: PPUSH
48354: CALL_OW 1
48358: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
48359: LD_VAR 0 1
48363: PUSH
48364: LD_EXP 74
48368: PUSH
48369: LD_VAR 0 3
48373: ARRAY
48374: IN
48375: IFFALSE 48414
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
48377: LD_ADDR_EXP 74
48381: PUSH
48382: LD_EXP 74
48386: PPUSH
48387: LD_VAR 0 3
48391: PPUSH
48392: LD_EXP 74
48396: PUSH
48397: LD_VAR 0 3
48401: ARRAY
48402: PUSH
48403: LD_VAR 0 1
48407: DIFF
48408: PPUSH
48409: CALL_OW 1
48413: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
48414: LD_VAR 0 1
48418: PUSH
48419: LD_EXP 81
48423: PUSH
48424: LD_VAR 0 3
48428: ARRAY
48429: IN
48430: IFFALSE 48469
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
48432: LD_ADDR_EXP 81
48436: PUSH
48437: LD_EXP 81
48441: PPUSH
48442: LD_VAR 0 3
48446: PPUSH
48447: LD_EXP 81
48451: PUSH
48452: LD_VAR 0 3
48456: ARRAY
48457: PUSH
48458: LD_VAR 0 1
48462: DIFF
48463: PPUSH
48464: CALL_OW 1
48468: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
48469: LD_VAR 0 1
48473: PUSH
48474: LD_EXP 93
48478: PUSH
48479: LD_VAR 0 3
48483: ARRAY
48484: IN
48485: IFFALSE 48524
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
48487: LD_ADDR_EXP 93
48491: PUSH
48492: LD_EXP 93
48496: PPUSH
48497: LD_VAR 0 3
48501: PPUSH
48502: LD_EXP 93
48506: PUSH
48507: LD_VAR 0 3
48511: ARRAY
48512: PUSH
48513: LD_VAR 0 1
48517: DIFF
48518: PPUSH
48519: CALL_OW 1
48523: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
48524: LD_VAR 0 1
48528: PUSH
48529: LD_EXP 96
48533: PUSH
48534: LD_VAR 0 3
48538: ARRAY
48539: IN
48540: IFFALSE 48579
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
48542: LD_ADDR_EXP 96
48546: PUSH
48547: LD_EXP 96
48551: PPUSH
48552: LD_VAR 0 3
48556: PPUSH
48557: LD_EXP 96
48561: PUSH
48562: LD_VAR 0 3
48566: ARRAY
48567: PUSH
48568: LD_VAR 0 1
48572: DIFF
48573: PPUSH
48574: CALL_OW 1
48578: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
48579: LD_VAR 0 1
48583: PUSH
48584: LD_EXP 83
48588: PUSH
48589: LD_VAR 0 3
48593: ARRAY
48594: IN
48595: IFFALSE 48634
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
48597: LD_ADDR_EXP 83
48601: PUSH
48602: LD_EXP 83
48606: PPUSH
48607: LD_VAR 0 3
48611: PPUSH
48612: LD_EXP 83
48616: PUSH
48617: LD_VAR 0 3
48621: ARRAY
48622: PUSH
48623: LD_VAR 0 1
48627: DIFF
48628: PPUSH
48629: CALL_OW 1
48633: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
48634: LD_VAR 0 1
48638: PUSH
48639: LD_EXP 82
48643: PUSH
48644: LD_VAR 0 3
48648: ARRAY
48649: IN
48650: IFFALSE 48689
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
48652: LD_ADDR_EXP 82
48656: PUSH
48657: LD_EXP 82
48661: PPUSH
48662: LD_VAR 0 3
48666: PPUSH
48667: LD_EXP 82
48671: PUSH
48672: LD_VAR 0 3
48676: ARRAY
48677: PUSH
48678: LD_VAR 0 1
48682: DIFF
48683: PPUSH
48684: CALL_OW 1
48688: ST_TO_ADDR
// end ; break ;
48689: GO 48693
// end ;
48691: GO 47339
48693: POP
48694: POP
// end ;
48695: LD_VAR 0 2
48699: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
48700: LD_INT 0
48702: PPUSH
48703: PPUSH
48704: PPUSH
// if not mc_bases or not skirmish then
48705: LD_EXP 74
48709: NOT
48710: PUSH
48711: LD_EXP 72
48715: NOT
48716: OR
48717: IFFALSE 48721
// exit ;
48719: GO 48936
// for i = 1 to mc_bases do
48721: LD_ADDR_VAR 0 3
48725: PUSH
48726: DOUBLE
48727: LD_INT 1
48729: DEC
48730: ST_TO_ADDR
48731: LD_EXP 74
48735: PUSH
48736: FOR_TO
48737: IFFALSE 48934
// begin if building in mc_construct_list [ i ] then
48739: LD_VAR 0 1
48743: PUSH
48744: LD_EXP 81
48748: PUSH
48749: LD_VAR 0 3
48753: ARRAY
48754: IN
48755: IFFALSE 48932
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
48757: LD_ADDR_EXP 81
48761: PUSH
48762: LD_EXP 81
48766: PPUSH
48767: LD_VAR 0 3
48771: PPUSH
48772: LD_EXP 81
48776: PUSH
48777: LD_VAR 0 3
48781: ARRAY
48782: PUSH
48783: LD_VAR 0 1
48787: DIFF
48788: PPUSH
48789: CALL_OW 1
48793: ST_TO_ADDR
// if building in mc_lab [ i ] then
48794: LD_VAR 0 1
48798: PUSH
48799: LD_EXP 107
48803: PUSH
48804: LD_VAR 0 3
48808: ARRAY
48809: IN
48810: IFFALSE 48865
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
48812: LD_ADDR_EXP 108
48816: PUSH
48817: LD_EXP 108
48821: PPUSH
48822: LD_VAR 0 3
48826: PPUSH
48827: LD_EXP 108
48831: PUSH
48832: LD_VAR 0 3
48836: ARRAY
48837: PPUSH
48838: LD_INT 1
48840: PPUSH
48841: LD_EXP 108
48845: PUSH
48846: LD_VAR 0 3
48850: ARRAY
48851: PPUSH
48852: LD_INT 0
48854: PPUSH
48855: CALL 56905 0 4
48859: PPUSH
48860: CALL_OW 1
48864: ST_TO_ADDR
// if not building in mc_bases [ i ] then
48865: LD_VAR 0 1
48869: PUSH
48870: LD_EXP 74
48874: PUSH
48875: LD_VAR 0 3
48879: ARRAY
48880: IN
48881: NOT
48882: IFFALSE 48928
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
48884: LD_ADDR_EXP 74
48888: PUSH
48889: LD_EXP 74
48893: PPUSH
48894: LD_VAR 0 3
48898: PUSH
48899: LD_EXP 74
48903: PUSH
48904: LD_VAR 0 3
48908: ARRAY
48909: PUSH
48910: LD_INT 1
48912: PLUS
48913: PUSH
48914: EMPTY
48915: LIST
48916: LIST
48917: PPUSH
48918: LD_VAR 0 1
48922: PPUSH
48923: CALL 57487 0 3
48927: ST_TO_ADDR
// exit ;
48928: POP
48929: POP
48930: GO 48936
// end ; end ;
48932: GO 48736
48934: POP
48935: POP
// end ;
48936: LD_VAR 0 2
48940: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
48941: LD_INT 0
48943: PPUSH
48944: PPUSH
48945: PPUSH
48946: PPUSH
48947: PPUSH
48948: PPUSH
48949: PPUSH
// if not mc_bases or not skirmish then
48950: LD_EXP 74
48954: NOT
48955: PUSH
48956: LD_EXP 72
48960: NOT
48961: OR
48962: IFFALSE 48966
// exit ;
48964: GO 49627
// for i = 1 to mc_bases do
48966: LD_ADDR_VAR 0 3
48970: PUSH
48971: DOUBLE
48972: LD_INT 1
48974: DEC
48975: ST_TO_ADDR
48976: LD_EXP 74
48980: PUSH
48981: FOR_TO
48982: IFFALSE 49625
// begin if building in mc_construct_list [ i ] then
48984: LD_VAR 0 1
48988: PUSH
48989: LD_EXP 81
48993: PUSH
48994: LD_VAR 0 3
48998: ARRAY
48999: IN
49000: IFFALSE 49623
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
49002: LD_ADDR_EXP 81
49006: PUSH
49007: LD_EXP 81
49011: PPUSH
49012: LD_VAR 0 3
49016: PPUSH
49017: LD_EXP 81
49021: PUSH
49022: LD_VAR 0 3
49026: ARRAY
49027: PUSH
49028: LD_VAR 0 1
49032: DIFF
49033: PPUSH
49034: CALL_OW 1
49038: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
49039: LD_ADDR_EXP 74
49043: PUSH
49044: LD_EXP 74
49048: PPUSH
49049: LD_VAR 0 3
49053: PUSH
49054: LD_EXP 74
49058: PUSH
49059: LD_VAR 0 3
49063: ARRAY
49064: PUSH
49065: LD_INT 1
49067: PLUS
49068: PUSH
49069: EMPTY
49070: LIST
49071: LIST
49072: PPUSH
49073: LD_VAR 0 1
49077: PPUSH
49078: CALL 57487 0 3
49082: ST_TO_ADDR
// btype := GetBType ( building ) ;
49083: LD_ADDR_VAR 0 5
49087: PUSH
49088: LD_VAR 0 1
49092: PPUSH
49093: CALL_OW 266
49097: ST_TO_ADDR
// side := GetSide ( building ) ;
49098: LD_ADDR_VAR 0 8
49102: PUSH
49103: LD_VAR 0 1
49107: PPUSH
49108: CALL_OW 255
49112: ST_TO_ADDR
// if btype = b_lab then
49113: LD_VAR 0 5
49117: PUSH
49118: LD_INT 6
49120: EQUAL
49121: IFFALSE 49171
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
49123: LD_ADDR_EXP 107
49127: PUSH
49128: LD_EXP 107
49132: PPUSH
49133: LD_VAR 0 3
49137: PUSH
49138: LD_EXP 107
49142: PUSH
49143: LD_VAR 0 3
49147: ARRAY
49148: PUSH
49149: LD_INT 1
49151: PLUS
49152: PUSH
49153: EMPTY
49154: LIST
49155: LIST
49156: PPUSH
49157: LD_VAR 0 1
49161: PPUSH
49162: CALL 57487 0 3
49166: ST_TO_ADDR
// exit ;
49167: POP
49168: POP
49169: GO 49627
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
49171: LD_VAR 0 5
49175: PUSH
49176: LD_INT 0
49178: PUSH
49179: LD_INT 2
49181: PUSH
49182: LD_INT 4
49184: PUSH
49185: EMPTY
49186: LIST
49187: LIST
49188: LIST
49189: IN
49190: IFFALSE 49314
// begin if btype = b_armoury then
49192: LD_VAR 0 5
49196: PUSH
49197: LD_INT 4
49199: EQUAL
49200: IFFALSE 49210
// btype := b_barracks ;
49202: LD_ADDR_VAR 0 5
49206: PUSH
49207: LD_INT 5
49209: ST_TO_ADDR
// if btype = b_depot then
49210: LD_VAR 0 5
49214: PUSH
49215: LD_INT 0
49217: EQUAL
49218: IFFALSE 49228
// btype := b_warehouse ;
49220: LD_ADDR_VAR 0 5
49224: PUSH
49225: LD_INT 1
49227: ST_TO_ADDR
// if btype = b_workshop then
49228: LD_VAR 0 5
49232: PUSH
49233: LD_INT 2
49235: EQUAL
49236: IFFALSE 49246
// btype := b_factory ;
49238: LD_ADDR_VAR 0 5
49242: PUSH
49243: LD_INT 3
49245: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
49246: LD_VAR 0 5
49250: PPUSH
49251: LD_VAR 0 8
49255: PPUSH
49256: CALL_OW 323
49260: PUSH
49261: LD_INT 1
49263: EQUAL
49264: IFFALSE 49310
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
49266: LD_ADDR_EXP 106
49270: PUSH
49271: LD_EXP 106
49275: PPUSH
49276: LD_VAR 0 3
49280: PUSH
49281: LD_EXP 106
49285: PUSH
49286: LD_VAR 0 3
49290: ARRAY
49291: PUSH
49292: LD_INT 1
49294: PLUS
49295: PUSH
49296: EMPTY
49297: LIST
49298: LIST
49299: PPUSH
49300: LD_VAR 0 1
49304: PPUSH
49305: CALL 57487 0 3
49309: ST_TO_ADDR
// exit ;
49310: POP
49311: POP
49312: GO 49627
// end ; if btype in [ b_bunker , b_turret ] then
49314: LD_VAR 0 5
49318: PUSH
49319: LD_INT 32
49321: PUSH
49322: LD_INT 33
49324: PUSH
49325: EMPTY
49326: LIST
49327: LIST
49328: IN
49329: IFFALSE 49619
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
49331: LD_ADDR_EXP 82
49335: PUSH
49336: LD_EXP 82
49340: PPUSH
49341: LD_VAR 0 3
49345: PUSH
49346: LD_EXP 82
49350: PUSH
49351: LD_VAR 0 3
49355: ARRAY
49356: PUSH
49357: LD_INT 1
49359: PLUS
49360: PUSH
49361: EMPTY
49362: LIST
49363: LIST
49364: PPUSH
49365: LD_VAR 0 1
49369: PPUSH
49370: CALL 57487 0 3
49374: ST_TO_ADDR
// if btype = b_bunker then
49375: LD_VAR 0 5
49379: PUSH
49380: LD_INT 32
49382: EQUAL
49383: IFFALSE 49619
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
49385: LD_ADDR_EXP 83
49389: PUSH
49390: LD_EXP 83
49394: PPUSH
49395: LD_VAR 0 3
49399: PUSH
49400: LD_EXP 83
49404: PUSH
49405: LD_VAR 0 3
49409: ARRAY
49410: PUSH
49411: LD_INT 1
49413: PLUS
49414: PUSH
49415: EMPTY
49416: LIST
49417: LIST
49418: PPUSH
49419: LD_VAR 0 1
49423: PPUSH
49424: CALL 57487 0 3
49428: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
49429: LD_ADDR_VAR 0 6
49433: PUSH
49434: LD_EXP 74
49438: PUSH
49439: LD_VAR 0 3
49443: ARRAY
49444: PPUSH
49445: LD_INT 25
49447: PUSH
49448: LD_INT 1
49450: PUSH
49451: EMPTY
49452: LIST
49453: LIST
49454: PUSH
49455: LD_INT 3
49457: PUSH
49458: LD_INT 54
49460: PUSH
49461: EMPTY
49462: LIST
49463: PUSH
49464: EMPTY
49465: LIST
49466: LIST
49467: PUSH
49468: EMPTY
49469: LIST
49470: LIST
49471: PPUSH
49472: CALL_OW 72
49476: ST_TO_ADDR
// if tmp then
49477: LD_VAR 0 6
49481: IFFALSE 49487
// exit ;
49483: POP
49484: POP
49485: GO 49627
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
49487: LD_ADDR_VAR 0 6
49491: PUSH
49492: LD_EXP 74
49496: PUSH
49497: LD_VAR 0 3
49501: ARRAY
49502: PPUSH
49503: LD_INT 2
49505: PUSH
49506: LD_INT 30
49508: PUSH
49509: LD_INT 4
49511: PUSH
49512: EMPTY
49513: LIST
49514: LIST
49515: PUSH
49516: LD_INT 30
49518: PUSH
49519: LD_INT 5
49521: PUSH
49522: EMPTY
49523: LIST
49524: LIST
49525: PUSH
49526: EMPTY
49527: LIST
49528: LIST
49529: LIST
49530: PPUSH
49531: CALL_OW 72
49535: ST_TO_ADDR
// if not tmp then
49536: LD_VAR 0 6
49540: NOT
49541: IFFALSE 49547
// exit ;
49543: POP
49544: POP
49545: GO 49627
// for j in tmp do
49547: LD_ADDR_VAR 0 4
49551: PUSH
49552: LD_VAR 0 6
49556: PUSH
49557: FOR_IN
49558: IFFALSE 49617
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
49560: LD_ADDR_VAR 0 7
49564: PUSH
49565: LD_VAR 0 4
49569: PPUSH
49570: CALL_OW 313
49574: PPUSH
49575: LD_INT 25
49577: PUSH
49578: LD_INT 1
49580: PUSH
49581: EMPTY
49582: LIST
49583: LIST
49584: PPUSH
49585: CALL_OW 72
49589: ST_TO_ADDR
// if units then
49590: LD_VAR 0 7
49594: IFFALSE 49615
// begin ComExitBuilding ( units [ 1 ] ) ;
49596: LD_VAR 0 7
49600: PUSH
49601: LD_INT 1
49603: ARRAY
49604: PPUSH
49605: CALL_OW 122
// exit ;
49609: POP
49610: POP
49611: POP
49612: POP
49613: GO 49627
// end ; end ;
49615: GO 49557
49617: POP
49618: POP
// end ; end ; exit ;
49619: POP
49620: POP
49621: GO 49627
// end ; end ;
49623: GO 48981
49625: POP
49626: POP
// end ;
49627: LD_VAR 0 2
49631: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
49632: LD_INT 0
49634: PPUSH
49635: PPUSH
49636: PPUSH
49637: PPUSH
49638: PPUSH
49639: PPUSH
49640: PPUSH
// if not mc_bases or not skirmish then
49641: LD_EXP 74
49645: NOT
49646: PUSH
49647: LD_EXP 72
49651: NOT
49652: OR
49653: IFFALSE 49657
// exit ;
49655: GO 49888
// btype := GetBType ( building ) ;
49657: LD_ADDR_VAR 0 6
49661: PUSH
49662: LD_VAR 0 1
49666: PPUSH
49667: CALL_OW 266
49671: ST_TO_ADDR
// x := GetX ( building ) ;
49672: LD_ADDR_VAR 0 7
49676: PUSH
49677: LD_VAR 0 1
49681: PPUSH
49682: CALL_OW 250
49686: ST_TO_ADDR
// y := GetY ( building ) ;
49687: LD_ADDR_VAR 0 8
49691: PUSH
49692: LD_VAR 0 1
49696: PPUSH
49697: CALL_OW 251
49701: ST_TO_ADDR
// d := GetDir ( building ) ;
49702: LD_ADDR_VAR 0 9
49706: PUSH
49707: LD_VAR 0 1
49711: PPUSH
49712: CALL_OW 254
49716: ST_TO_ADDR
// for i = 1 to mc_bases do
49717: LD_ADDR_VAR 0 4
49721: PUSH
49722: DOUBLE
49723: LD_INT 1
49725: DEC
49726: ST_TO_ADDR
49727: LD_EXP 74
49731: PUSH
49732: FOR_TO
49733: IFFALSE 49886
// begin if not mc_build_list [ i ] then
49735: LD_EXP 79
49739: PUSH
49740: LD_VAR 0 4
49744: ARRAY
49745: NOT
49746: IFFALSE 49750
// continue ;
49748: GO 49732
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
49750: LD_VAR 0 6
49754: PUSH
49755: LD_VAR 0 7
49759: PUSH
49760: LD_VAR 0 8
49764: PUSH
49765: LD_VAR 0 9
49769: PUSH
49770: EMPTY
49771: LIST
49772: LIST
49773: LIST
49774: LIST
49775: PPUSH
49776: LD_EXP 79
49780: PUSH
49781: LD_VAR 0 4
49785: ARRAY
49786: PUSH
49787: LD_INT 1
49789: ARRAY
49790: PPUSH
49791: CALL 63656 0 2
49795: IFFALSE 49884
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
49797: LD_ADDR_EXP 79
49801: PUSH
49802: LD_EXP 79
49806: PPUSH
49807: LD_VAR 0 4
49811: PPUSH
49812: LD_EXP 79
49816: PUSH
49817: LD_VAR 0 4
49821: ARRAY
49822: PPUSH
49823: LD_INT 1
49825: PPUSH
49826: CALL_OW 3
49830: PPUSH
49831: CALL_OW 1
49835: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
49836: LD_ADDR_EXP 81
49840: PUSH
49841: LD_EXP 81
49845: PPUSH
49846: LD_VAR 0 4
49850: PUSH
49851: LD_EXP 81
49855: PUSH
49856: LD_VAR 0 4
49860: ARRAY
49861: PUSH
49862: LD_INT 1
49864: PLUS
49865: PUSH
49866: EMPTY
49867: LIST
49868: LIST
49869: PPUSH
49870: LD_VAR 0 1
49874: PPUSH
49875: CALL 57487 0 3
49879: ST_TO_ADDR
// exit ;
49880: POP
49881: POP
49882: GO 49888
// end ; end ;
49884: GO 49732
49886: POP
49887: POP
// end ;
49888: LD_VAR 0 3
49892: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
49893: LD_INT 0
49895: PPUSH
49896: PPUSH
49897: PPUSH
// if not mc_bases or not skirmish then
49898: LD_EXP 74
49902: NOT
49903: PUSH
49904: LD_EXP 72
49908: NOT
49909: OR
49910: IFFALSE 49914
// exit ;
49912: GO 50104
// for i = 1 to mc_bases do
49914: LD_ADDR_VAR 0 4
49918: PUSH
49919: DOUBLE
49920: LD_INT 1
49922: DEC
49923: ST_TO_ADDR
49924: LD_EXP 74
49928: PUSH
49929: FOR_TO
49930: IFFALSE 50017
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
49932: LD_VAR 0 1
49936: PUSH
49937: LD_EXP 82
49941: PUSH
49942: LD_VAR 0 4
49946: ARRAY
49947: IN
49948: PUSH
49949: LD_VAR 0 1
49953: PUSH
49954: LD_EXP 83
49958: PUSH
49959: LD_VAR 0 4
49963: ARRAY
49964: IN
49965: NOT
49966: AND
49967: IFFALSE 50015
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
49969: LD_ADDR_EXP 83
49973: PUSH
49974: LD_EXP 83
49978: PPUSH
49979: LD_VAR 0 4
49983: PUSH
49984: LD_EXP 83
49988: PUSH
49989: LD_VAR 0 4
49993: ARRAY
49994: PUSH
49995: LD_INT 1
49997: PLUS
49998: PUSH
49999: EMPTY
50000: LIST
50001: LIST
50002: PPUSH
50003: LD_VAR 0 1
50007: PPUSH
50008: CALL 57487 0 3
50012: ST_TO_ADDR
// break ;
50013: GO 50017
// end ; end ;
50015: GO 49929
50017: POP
50018: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
50019: LD_VAR 0 1
50023: PPUSH
50024: CALL_OW 257
50028: PUSH
50029: LD_EXP 100
50033: IN
50034: PUSH
50035: LD_VAR 0 1
50039: PPUSH
50040: CALL_OW 266
50044: PUSH
50045: LD_INT 5
50047: EQUAL
50048: AND
50049: PUSH
50050: LD_VAR 0 2
50054: PPUSH
50055: CALL_OW 110
50059: PUSH
50060: LD_INT 18
50062: NONEQUAL
50063: AND
50064: IFFALSE 50104
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
50066: LD_VAR 0 2
50070: PPUSH
50071: CALL_OW 257
50075: PUSH
50076: LD_INT 5
50078: PUSH
50079: LD_INT 8
50081: PUSH
50082: LD_INT 9
50084: PUSH
50085: EMPTY
50086: LIST
50087: LIST
50088: LIST
50089: IN
50090: IFFALSE 50104
// SetClass ( unit , 1 ) ;
50092: LD_VAR 0 2
50096: PPUSH
50097: LD_INT 1
50099: PPUSH
50100: CALL_OW 336
// end ;
50104: LD_VAR 0 3
50108: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
50109: LD_INT 0
50111: PPUSH
50112: PPUSH
// if not mc_bases or not skirmish then
50113: LD_EXP 74
50117: NOT
50118: PUSH
50119: LD_EXP 72
50123: NOT
50124: OR
50125: IFFALSE 50129
// exit ;
50127: GO 50245
// if GetLives ( abandoned_vehicle ) > 250 then
50129: LD_VAR 0 2
50133: PPUSH
50134: CALL_OW 256
50138: PUSH
50139: LD_INT 250
50141: GREATER
50142: IFFALSE 50146
// exit ;
50144: GO 50245
// for i = 1 to mc_bases do
50146: LD_ADDR_VAR 0 6
50150: PUSH
50151: DOUBLE
50152: LD_INT 1
50154: DEC
50155: ST_TO_ADDR
50156: LD_EXP 74
50160: PUSH
50161: FOR_TO
50162: IFFALSE 50243
// begin if driver in mc_bases [ i ] then
50164: LD_VAR 0 1
50168: PUSH
50169: LD_EXP 74
50173: PUSH
50174: LD_VAR 0 6
50178: ARRAY
50179: IN
50180: IFFALSE 50241
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
50182: LD_VAR 0 1
50186: PPUSH
50187: LD_EXP 74
50191: PUSH
50192: LD_VAR 0 6
50196: ARRAY
50197: PPUSH
50198: LD_INT 2
50200: PUSH
50201: LD_INT 30
50203: PUSH
50204: LD_INT 0
50206: PUSH
50207: EMPTY
50208: LIST
50209: LIST
50210: PUSH
50211: LD_INT 30
50213: PUSH
50214: LD_INT 1
50216: PUSH
50217: EMPTY
50218: LIST
50219: LIST
50220: PUSH
50221: EMPTY
50222: LIST
50223: LIST
50224: LIST
50225: PPUSH
50226: CALL_OW 72
50230: PUSH
50231: LD_INT 1
50233: ARRAY
50234: PPUSH
50235: CALL_OW 112
// break ;
50239: GO 50243
// end ; end ;
50241: GO 50161
50243: POP
50244: POP
// end ; end_of_file
50245: LD_VAR 0 5
50249: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
50250: LD_INT 0
50252: PPUSH
50253: PPUSH
// if exist_mode then
50254: LD_VAR 0 2
50258: IFFALSE 50283
// unit := CreateCharacter ( prefix & ident ) else
50260: LD_ADDR_VAR 0 5
50264: PUSH
50265: LD_VAR 0 3
50269: PUSH
50270: LD_VAR 0 1
50274: STR
50275: PPUSH
50276: CALL_OW 34
50280: ST_TO_ADDR
50281: GO 50298
// unit := NewCharacter ( ident ) ;
50283: LD_ADDR_VAR 0 5
50287: PUSH
50288: LD_VAR 0 1
50292: PPUSH
50293: CALL_OW 25
50297: ST_TO_ADDR
// result := unit ;
50298: LD_ADDR_VAR 0 4
50302: PUSH
50303: LD_VAR 0 5
50307: ST_TO_ADDR
// end ;
50308: LD_VAR 0 4
50312: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
50313: LD_INT 0
50315: PPUSH
50316: PPUSH
// if not side or not nation then
50317: LD_VAR 0 1
50321: NOT
50322: PUSH
50323: LD_VAR 0 2
50327: NOT
50328: OR
50329: IFFALSE 50333
// exit ;
50331: GO 50977
// case nation of nation_american :
50333: LD_VAR 0 2
50337: PUSH
50338: LD_INT 1
50340: DOUBLE
50341: EQUAL
50342: IFTRUE 50346
50344: GO 50520
50346: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
50347: LD_ADDR_VAR 0 4
50351: PUSH
50352: LD_INT 35
50354: PUSH
50355: LD_INT 45
50357: PUSH
50358: LD_INT 46
50360: PUSH
50361: LD_INT 47
50363: PUSH
50364: LD_INT 1
50366: PUSH
50367: LD_INT 2
50369: PUSH
50370: LD_INT 6
50372: PUSH
50373: LD_INT 15
50375: PUSH
50376: LD_INT 16
50378: PUSH
50379: LD_INT 7
50381: PUSH
50382: LD_INT 12
50384: PUSH
50385: LD_INT 13
50387: PUSH
50388: LD_INT 10
50390: PUSH
50391: LD_INT 14
50393: PUSH
50394: LD_INT 20
50396: PUSH
50397: LD_INT 21
50399: PUSH
50400: LD_INT 22
50402: PUSH
50403: LD_INT 25
50405: PUSH
50406: LD_INT 32
50408: PUSH
50409: LD_INT 27
50411: PUSH
50412: LD_INT 36
50414: PUSH
50415: LD_INT 69
50417: PUSH
50418: LD_INT 39
50420: PUSH
50421: LD_INT 34
50423: PUSH
50424: LD_INT 40
50426: PUSH
50427: LD_INT 48
50429: PUSH
50430: LD_INT 49
50432: PUSH
50433: LD_INT 50
50435: PUSH
50436: LD_INT 51
50438: PUSH
50439: LD_INT 52
50441: PUSH
50442: LD_INT 53
50444: PUSH
50445: LD_INT 54
50447: PUSH
50448: LD_INT 55
50450: PUSH
50451: LD_INT 56
50453: PUSH
50454: LD_INT 57
50456: PUSH
50457: LD_INT 58
50459: PUSH
50460: LD_INT 59
50462: PUSH
50463: LD_INT 60
50465: PUSH
50466: LD_INT 61
50468: PUSH
50469: LD_INT 62
50471: PUSH
50472: LD_INT 80
50474: PUSH
50475: EMPTY
50476: LIST
50477: LIST
50478: LIST
50479: LIST
50480: LIST
50481: LIST
50482: LIST
50483: LIST
50484: LIST
50485: LIST
50486: LIST
50487: LIST
50488: LIST
50489: LIST
50490: LIST
50491: LIST
50492: LIST
50493: LIST
50494: LIST
50495: LIST
50496: LIST
50497: LIST
50498: LIST
50499: LIST
50500: LIST
50501: LIST
50502: LIST
50503: LIST
50504: LIST
50505: LIST
50506: LIST
50507: LIST
50508: LIST
50509: LIST
50510: LIST
50511: LIST
50512: LIST
50513: LIST
50514: LIST
50515: LIST
50516: LIST
50517: ST_TO_ADDR
50518: GO 50901
50520: LD_INT 2
50522: DOUBLE
50523: EQUAL
50524: IFTRUE 50528
50526: GO 50710
50528: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
50529: LD_ADDR_VAR 0 4
50533: PUSH
50534: LD_INT 35
50536: PUSH
50537: LD_INT 45
50539: PUSH
50540: LD_INT 46
50542: PUSH
50543: LD_INT 47
50545: PUSH
50546: LD_INT 70
50548: PUSH
50549: LD_INT 1
50551: PUSH
50552: LD_INT 11
50554: PUSH
50555: LD_INT 3
50557: PUSH
50558: LD_INT 4
50560: PUSH
50561: LD_INT 5
50563: PUSH
50564: LD_INT 6
50566: PUSH
50567: LD_INT 15
50569: PUSH
50570: LD_INT 18
50572: PUSH
50573: LD_INT 7
50575: PUSH
50576: LD_INT 17
50578: PUSH
50579: LD_INT 8
50581: PUSH
50582: LD_INT 20
50584: PUSH
50585: LD_INT 21
50587: PUSH
50588: LD_INT 22
50590: PUSH
50591: LD_INT 72
50593: PUSH
50594: LD_INT 26
50596: PUSH
50597: LD_INT 69
50599: PUSH
50600: LD_INT 39
50602: PUSH
50603: LD_INT 40
50605: PUSH
50606: LD_INT 41
50608: PUSH
50609: LD_INT 42
50611: PUSH
50612: LD_INT 43
50614: PUSH
50615: LD_INT 48
50617: PUSH
50618: LD_INT 49
50620: PUSH
50621: LD_INT 50
50623: PUSH
50624: LD_INT 51
50626: PUSH
50627: LD_INT 52
50629: PUSH
50630: LD_INT 53
50632: PUSH
50633: LD_INT 54
50635: PUSH
50636: LD_INT 55
50638: PUSH
50639: LD_INT 56
50641: PUSH
50642: LD_INT 60
50644: PUSH
50645: LD_INT 61
50647: PUSH
50648: LD_INT 62
50650: PUSH
50651: LD_INT 66
50653: PUSH
50654: LD_INT 67
50656: PUSH
50657: LD_INT 68
50659: PUSH
50660: LD_INT 81
50662: PUSH
50663: EMPTY
50664: LIST
50665: LIST
50666: LIST
50667: LIST
50668: LIST
50669: LIST
50670: LIST
50671: LIST
50672: LIST
50673: LIST
50674: LIST
50675: LIST
50676: LIST
50677: LIST
50678: LIST
50679: LIST
50680: LIST
50681: LIST
50682: LIST
50683: LIST
50684: LIST
50685: LIST
50686: LIST
50687: LIST
50688: LIST
50689: LIST
50690: LIST
50691: LIST
50692: LIST
50693: LIST
50694: LIST
50695: LIST
50696: LIST
50697: LIST
50698: LIST
50699: LIST
50700: LIST
50701: LIST
50702: LIST
50703: LIST
50704: LIST
50705: LIST
50706: LIST
50707: ST_TO_ADDR
50708: GO 50901
50710: LD_INT 3
50712: DOUBLE
50713: EQUAL
50714: IFTRUE 50718
50716: GO 50900
50718: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
50719: LD_ADDR_VAR 0 4
50723: PUSH
50724: LD_INT 46
50726: PUSH
50727: LD_INT 47
50729: PUSH
50730: LD_INT 1
50732: PUSH
50733: LD_INT 2
50735: PUSH
50736: LD_INT 11
50738: PUSH
50739: LD_INT 9
50741: PUSH
50742: LD_INT 20
50744: PUSH
50745: LD_INT 19
50747: PUSH
50748: LD_INT 21
50750: PUSH
50751: LD_INT 24
50753: PUSH
50754: LD_INT 22
50756: PUSH
50757: LD_INT 25
50759: PUSH
50760: LD_INT 28
50762: PUSH
50763: LD_INT 29
50765: PUSH
50766: LD_INT 30
50768: PUSH
50769: LD_INT 31
50771: PUSH
50772: LD_INT 37
50774: PUSH
50775: LD_INT 38
50777: PUSH
50778: LD_INT 32
50780: PUSH
50781: LD_INT 27
50783: PUSH
50784: LD_INT 33
50786: PUSH
50787: LD_INT 69
50789: PUSH
50790: LD_INT 39
50792: PUSH
50793: LD_INT 34
50795: PUSH
50796: LD_INT 40
50798: PUSH
50799: LD_INT 71
50801: PUSH
50802: LD_INT 23
50804: PUSH
50805: LD_INT 44
50807: PUSH
50808: LD_INT 48
50810: PUSH
50811: LD_INT 49
50813: PUSH
50814: LD_INT 50
50816: PUSH
50817: LD_INT 51
50819: PUSH
50820: LD_INT 52
50822: PUSH
50823: LD_INT 53
50825: PUSH
50826: LD_INT 54
50828: PUSH
50829: LD_INT 55
50831: PUSH
50832: LD_INT 56
50834: PUSH
50835: LD_INT 57
50837: PUSH
50838: LD_INT 58
50840: PUSH
50841: LD_INT 59
50843: PUSH
50844: LD_INT 63
50846: PUSH
50847: LD_INT 64
50849: PUSH
50850: LD_INT 65
50852: PUSH
50853: EMPTY
50854: LIST
50855: LIST
50856: LIST
50857: LIST
50858: LIST
50859: LIST
50860: LIST
50861: LIST
50862: LIST
50863: LIST
50864: LIST
50865: LIST
50866: LIST
50867: LIST
50868: LIST
50869: LIST
50870: LIST
50871: LIST
50872: LIST
50873: LIST
50874: LIST
50875: LIST
50876: LIST
50877: LIST
50878: LIST
50879: LIST
50880: LIST
50881: LIST
50882: LIST
50883: LIST
50884: LIST
50885: LIST
50886: LIST
50887: LIST
50888: LIST
50889: LIST
50890: LIST
50891: LIST
50892: LIST
50893: LIST
50894: LIST
50895: LIST
50896: LIST
50897: ST_TO_ADDR
50898: GO 50901
50900: POP
// if state > - 1 and state < 3 then
50901: LD_VAR 0 3
50905: PUSH
50906: LD_INT 1
50908: NEG
50909: GREATER
50910: PUSH
50911: LD_VAR 0 3
50915: PUSH
50916: LD_INT 3
50918: LESS
50919: AND
50920: IFFALSE 50977
// for i in result do
50922: LD_ADDR_VAR 0 5
50926: PUSH
50927: LD_VAR 0 4
50931: PUSH
50932: FOR_IN
50933: IFFALSE 50975
// if GetTech ( i , side ) <> state then
50935: LD_VAR 0 5
50939: PPUSH
50940: LD_VAR 0 1
50944: PPUSH
50945: CALL_OW 321
50949: PUSH
50950: LD_VAR 0 3
50954: NONEQUAL
50955: IFFALSE 50973
// result := result diff i ;
50957: LD_ADDR_VAR 0 4
50961: PUSH
50962: LD_VAR 0 4
50966: PUSH
50967: LD_VAR 0 5
50971: DIFF
50972: ST_TO_ADDR
50973: GO 50932
50975: POP
50976: POP
// end ;
50977: LD_VAR 0 4
50981: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
50982: LD_INT 0
50984: PPUSH
50985: PPUSH
50986: PPUSH
// result := true ;
50987: LD_ADDR_VAR 0 3
50991: PUSH
50992: LD_INT 1
50994: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
50995: LD_ADDR_VAR 0 5
50999: PUSH
51000: LD_VAR 0 2
51004: PPUSH
51005: CALL_OW 480
51009: ST_TO_ADDR
// if not tmp then
51010: LD_VAR 0 5
51014: NOT
51015: IFFALSE 51019
// exit ;
51017: GO 51068
// for i in tmp do
51019: LD_ADDR_VAR 0 4
51023: PUSH
51024: LD_VAR 0 5
51028: PUSH
51029: FOR_IN
51030: IFFALSE 51066
// if GetTech ( i , side ) <> state_researched then
51032: LD_VAR 0 4
51036: PPUSH
51037: LD_VAR 0 1
51041: PPUSH
51042: CALL_OW 321
51046: PUSH
51047: LD_INT 2
51049: NONEQUAL
51050: IFFALSE 51064
// begin result := false ;
51052: LD_ADDR_VAR 0 3
51056: PUSH
51057: LD_INT 0
51059: ST_TO_ADDR
// exit ;
51060: POP
51061: POP
51062: GO 51068
// end ;
51064: GO 51029
51066: POP
51067: POP
// end ;
51068: LD_VAR 0 3
51072: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
51073: LD_INT 0
51075: PPUSH
51076: PPUSH
51077: PPUSH
51078: PPUSH
51079: PPUSH
51080: PPUSH
51081: PPUSH
51082: PPUSH
51083: PPUSH
51084: PPUSH
51085: PPUSH
51086: PPUSH
51087: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
51088: LD_VAR 0 1
51092: NOT
51093: PUSH
51094: LD_VAR 0 1
51098: PPUSH
51099: CALL_OW 257
51103: PUSH
51104: LD_INT 9
51106: NONEQUAL
51107: OR
51108: IFFALSE 51112
// exit ;
51110: GO 51685
// side := GetSide ( unit ) ;
51112: LD_ADDR_VAR 0 9
51116: PUSH
51117: LD_VAR 0 1
51121: PPUSH
51122: CALL_OW 255
51126: ST_TO_ADDR
// tech_space := tech_spacanom ;
51127: LD_ADDR_VAR 0 12
51131: PUSH
51132: LD_INT 29
51134: ST_TO_ADDR
// tech_time := tech_taurad ;
51135: LD_ADDR_VAR 0 13
51139: PUSH
51140: LD_INT 28
51142: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
51143: LD_ADDR_VAR 0 11
51147: PUSH
51148: LD_VAR 0 1
51152: PPUSH
51153: CALL_OW 310
51157: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
51158: LD_VAR 0 11
51162: PPUSH
51163: CALL_OW 247
51167: PUSH
51168: LD_INT 2
51170: EQUAL
51171: IFFALSE 51175
// exit ;
51173: GO 51685
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
51175: LD_ADDR_VAR 0 8
51179: PUSH
51180: LD_INT 81
51182: PUSH
51183: LD_VAR 0 9
51187: PUSH
51188: EMPTY
51189: LIST
51190: LIST
51191: PUSH
51192: LD_INT 3
51194: PUSH
51195: LD_INT 21
51197: PUSH
51198: LD_INT 3
51200: PUSH
51201: EMPTY
51202: LIST
51203: LIST
51204: PUSH
51205: EMPTY
51206: LIST
51207: LIST
51208: PUSH
51209: EMPTY
51210: LIST
51211: LIST
51212: PPUSH
51213: CALL_OW 69
51217: ST_TO_ADDR
// if not tmp then
51218: LD_VAR 0 8
51222: NOT
51223: IFFALSE 51227
// exit ;
51225: GO 51685
// if in_unit then
51227: LD_VAR 0 11
51231: IFFALSE 51255
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
51233: LD_ADDR_VAR 0 10
51237: PUSH
51238: LD_VAR 0 8
51242: PPUSH
51243: LD_VAR 0 11
51247: PPUSH
51248: CALL_OW 74
51252: ST_TO_ADDR
51253: GO 51275
// enemy := NearestUnitToUnit ( tmp , unit ) ;
51255: LD_ADDR_VAR 0 10
51259: PUSH
51260: LD_VAR 0 8
51264: PPUSH
51265: LD_VAR 0 1
51269: PPUSH
51270: CALL_OW 74
51274: ST_TO_ADDR
// if not enemy then
51275: LD_VAR 0 10
51279: NOT
51280: IFFALSE 51284
// exit ;
51282: GO 51685
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
51284: LD_VAR 0 11
51288: PUSH
51289: LD_VAR 0 11
51293: PPUSH
51294: LD_VAR 0 10
51298: PPUSH
51299: CALL_OW 296
51303: PUSH
51304: LD_INT 13
51306: GREATER
51307: AND
51308: PUSH
51309: LD_VAR 0 1
51313: PPUSH
51314: LD_VAR 0 10
51318: PPUSH
51319: CALL_OW 296
51323: PUSH
51324: LD_INT 12
51326: GREATER
51327: OR
51328: IFFALSE 51332
// exit ;
51330: GO 51685
// missile := [ 1 ] ;
51332: LD_ADDR_VAR 0 14
51336: PUSH
51337: LD_INT 1
51339: PUSH
51340: EMPTY
51341: LIST
51342: ST_TO_ADDR
// if Researched ( side , tech_space ) then
51343: LD_VAR 0 9
51347: PPUSH
51348: LD_VAR 0 12
51352: PPUSH
51353: CALL_OW 325
51357: IFFALSE 51386
// missile := Insert ( missile , missile + 1 , 2 ) ;
51359: LD_ADDR_VAR 0 14
51363: PUSH
51364: LD_VAR 0 14
51368: PPUSH
51369: LD_VAR 0 14
51373: PUSH
51374: LD_INT 1
51376: PLUS
51377: PPUSH
51378: LD_INT 2
51380: PPUSH
51381: CALL_OW 2
51385: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
51386: LD_VAR 0 9
51390: PPUSH
51391: LD_VAR 0 13
51395: PPUSH
51396: CALL_OW 325
51400: PUSH
51401: LD_VAR 0 10
51405: PPUSH
51406: CALL_OW 255
51410: PPUSH
51411: LD_VAR 0 13
51415: PPUSH
51416: CALL_OW 325
51420: NOT
51421: AND
51422: IFFALSE 51451
// missile := Insert ( missile , missile + 1 , 3 ) ;
51424: LD_ADDR_VAR 0 14
51428: PUSH
51429: LD_VAR 0 14
51433: PPUSH
51434: LD_VAR 0 14
51438: PUSH
51439: LD_INT 1
51441: PLUS
51442: PPUSH
51443: LD_INT 3
51445: PPUSH
51446: CALL_OW 2
51450: ST_TO_ADDR
// if missile < 2 then
51451: LD_VAR 0 14
51455: PUSH
51456: LD_INT 2
51458: LESS
51459: IFFALSE 51463
// exit ;
51461: GO 51685
// x := GetX ( enemy ) ;
51463: LD_ADDR_VAR 0 4
51467: PUSH
51468: LD_VAR 0 10
51472: PPUSH
51473: CALL_OW 250
51477: ST_TO_ADDR
// y := GetY ( enemy ) ;
51478: LD_ADDR_VAR 0 5
51482: PUSH
51483: LD_VAR 0 10
51487: PPUSH
51488: CALL_OW 251
51492: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
51493: LD_ADDR_VAR 0 6
51497: PUSH
51498: LD_VAR 0 4
51502: PUSH
51503: LD_INT 1
51505: NEG
51506: PPUSH
51507: LD_INT 1
51509: PPUSH
51510: CALL_OW 12
51514: PLUS
51515: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
51516: LD_ADDR_VAR 0 7
51520: PUSH
51521: LD_VAR 0 5
51525: PUSH
51526: LD_INT 1
51528: NEG
51529: PPUSH
51530: LD_INT 1
51532: PPUSH
51533: CALL_OW 12
51537: PLUS
51538: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
51539: LD_VAR 0 6
51543: PPUSH
51544: LD_VAR 0 7
51548: PPUSH
51549: CALL_OW 488
51553: NOT
51554: IFFALSE 51576
// begin _x := x ;
51556: LD_ADDR_VAR 0 6
51560: PUSH
51561: LD_VAR 0 4
51565: ST_TO_ADDR
// _y := y ;
51566: LD_ADDR_VAR 0 7
51570: PUSH
51571: LD_VAR 0 5
51575: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
51576: LD_ADDR_VAR 0 3
51580: PUSH
51581: LD_INT 1
51583: PPUSH
51584: LD_VAR 0 14
51588: PPUSH
51589: CALL_OW 12
51593: ST_TO_ADDR
// case i of 1 :
51594: LD_VAR 0 3
51598: PUSH
51599: LD_INT 1
51601: DOUBLE
51602: EQUAL
51603: IFTRUE 51607
51605: GO 51624
51607: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
51608: LD_VAR 0 1
51612: PPUSH
51613: LD_VAR 0 10
51617: PPUSH
51618: CALL_OW 115
51622: GO 51685
51624: LD_INT 2
51626: DOUBLE
51627: EQUAL
51628: IFTRUE 51632
51630: GO 51654
51632: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
51633: LD_VAR 0 1
51637: PPUSH
51638: LD_VAR 0 6
51642: PPUSH
51643: LD_VAR 0 7
51647: PPUSH
51648: CALL_OW 153
51652: GO 51685
51654: LD_INT 3
51656: DOUBLE
51657: EQUAL
51658: IFTRUE 51662
51660: GO 51684
51662: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
51663: LD_VAR 0 1
51667: PPUSH
51668: LD_VAR 0 6
51672: PPUSH
51673: LD_VAR 0 7
51677: PPUSH
51678: CALL_OW 154
51682: GO 51685
51684: POP
// end ;
51685: LD_VAR 0 2
51689: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
51690: LD_INT 0
51692: PPUSH
51693: PPUSH
51694: PPUSH
51695: PPUSH
51696: PPUSH
51697: PPUSH
// if not unit or not building then
51698: LD_VAR 0 1
51702: NOT
51703: PUSH
51704: LD_VAR 0 2
51708: NOT
51709: OR
51710: IFFALSE 51714
// exit ;
51712: GO 51872
// x := GetX ( building ) ;
51714: LD_ADDR_VAR 0 5
51718: PUSH
51719: LD_VAR 0 2
51723: PPUSH
51724: CALL_OW 250
51728: ST_TO_ADDR
// y := GetY ( building ) ;
51729: LD_ADDR_VAR 0 6
51733: PUSH
51734: LD_VAR 0 2
51738: PPUSH
51739: CALL_OW 251
51743: ST_TO_ADDR
// for i = 0 to 5 do
51744: LD_ADDR_VAR 0 4
51748: PUSH
51749: DOUBLE
51750: LD_INT 0
51752: DEC
51753: ST_TO_ADDR
51754: LD_INT 5
51756: PUSH
51757: FOR_TO
51758: IFFALSE 51870
// begin _x := ShiftX ( x , i , 3 ) ;
51760: LD_ADDR_VAR 0 7
51764: PUSH
51765: LD_VAR 0 5
51769: PPUSH
51770: LD_VAR 0 4
51774: PPUSH
51775: LD_INT 3
51777: PPUSH
51778: CALL_OW 272
51782: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
51783: LD_ADDR_VAR 0 8
51787: PUSH
51788: LD_VAR 0 6
51792: PPUSH
51793: LD_VAR 0 4
51797: PPUSH
51798: LD_INT 3
51800: PPUSH
51801: CALL_OW 273
51805: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
51806: LD_VAR 0 7
51810: PPUSH
51811: LD_VAR 0 8
51815: PPUSH
51816: CALL_OW 488
51820: NOT
51821: IFFALSE 51825
// continue ;
51823: GO 51757
// if HexInfo ( _x , _y ) = 0 then
51825: LD_VAR 0 7
51829: PPUSH
51830: LD_VAR 0 8
51834: PPUSH
51835: CALL_OW 428
51839: PUSH
51840: LD_INT 0
51842: EQUAL
51843: IFFALSE 51868
// begin ComMoveXY ( unit , _x , _y ) ;
51845: LD_VAR 0 1
51849: PPUSH
51850: LD_VAR 0 7
51854: PPUSH
51855: LD_VAR 0 8
51859: PPUSH
51860: CALL_OW 111
// exit ;
51864: POP
51865: POP
51866: GO 51872
// end ; end ;
51868: GO 51757
51870: POP
51871: POP
// end ;
51872: LD_VAR 0 3
51876: RET
// export function ScanBase ( side , base_area ) ; begin
51877: LD_INT 0
51879: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
51880: LD_ADDR_VAR 0 3
51884: PUSH
51885: LD_VAR 0 2
51889: PPUSH
51890: LD_INT 81
51892: PUSH
51893: LD_VAR 0 1
51897: PUSH
51898: EMPTY
51899: LIST
51900: LIST
51901: PPUSH
51902: CALL_OW 70
51906: ST_TO_ADDR
// end ;
51907: LD_VAR 0 3
51911: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
51912: LD_INT 0
51914: PPUSH
51915: PPUSH
51916: PPUSH
51917: PPUSH
51918: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
51919: LD_VAR 0 1
51923: NOT
51924: PUSH
51925: LD_EXP 74
51929: PUSH
51930: LD_VAR 0 1
51934: ARRAY
51935: NOT
51936: OR
51937: PUSH
51938: LD_VAR 0 2
51942: NOT
51943: OR
51944: PUSH
51945: LD_VAR 0 3
51949: NOT
51950: OR
51951: IFFALSE 51955
// exit ;
51953: GO 52468
// side := mc_sides [ base ] ;
51955: LD_ADDR_VAR 0 6
51959: PUSH
51960: LD_EXP 100
51964: PUSH
51965: LD_VAR 0 1
51969: ARRAY
51970: ST_TO_ADDR
// if not side then
51971: LD_VAR 0 6
51975: NOT
51976: IFFALSE 51980
// exit ;
51978: GO 52468
// for i in solds do
51980: LD_ADDR_VAR 0 7
51984: PUSH
51985: LD_VAR 0 2
51989: PUSH
51990: FOR_IN
51991: IFFALSE 52052
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
51993: LD_VAR 0 7
51997: PPUSH
51998: CALL_OW 310
52002: PPUSH
52003: CALL_OW 266
52007: PUSH
52008: LD_INT 32
52010: PUSH
52011: LD_INT 31
52013: PUSH
52014: EMPTY
52015: LIST
52016: LIST
52017: IN
52018: IFFALSE 52038
// solds := solds diff i else
52020: LD_ADDR_VAR 0 2
52024: PUSH
52025: LD_VAR 0 2
52029: PUSH
52030: LD_VAR 0 7
52034: DIFF
52035: ST_TO_ADDR
52036: GO 52050
// SetTag ( i , 18 ) ;
52038: LD_VAR 0 7
52042: PPUSH
52043: LD_INT 18
52045: PPUSH
52046: CALL_OW 109
52050: GO 51990
52052: POP
52053: POP
// if not solds then
52054: LD_VAR 0 2
52058: NOT
52059: IFFALSE 52063
// exit ;
52061: GO 52468
// repeat wait ( 0 0$1 ) ;
52063: LD_INT 35
52065: PPUSH
52066: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
52070: LD_ADDR_VAR 0 5
52074: PUSH
52075: LD_VAR 0 6
52079: PPUSH
52080: LD_VAR 0 3
52084: PPUSH
52085: CALL 51877 0 2
52089: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
52090: LD_EXP 74
52094: PUSH
52095: LD_VAR 0 1
52099: ARRAY
52100: NOT
52101: PUSH
52102: LD_EXP 74
52106: PUSH
52107: LD_VAR 0 1
52111: ARRAY
52112: PUSH
52113: EMPTY
52114: EQUAL
52115: OR
52116: IFFALSE 52153
// begin for i in solds do
52118: LD_ADDR_VAR 0 7
52122: PUSH
52123: LD_VAR 0 2
52127: PUSH
52128: FOR_IN
52129: IFFALSE 52142
// ComStop ( i ) ;
52131: LD_VAR 0 7
52135: PPUSH
52136: CALL_OW 141
52140: GO 52128
52142: POP
52143: POP
// solds := [ ] ;
52144: LD_ADDR_VAR 0 2
52148: PUSH
52149: EMPTY
52150: ST_TO_ADDR
// exit ;
52151: GO 52468
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
52153: LD_VAR 0 5
52157: NOT
52158: PUSH
52159: LD_VAR 0 5
52163: PUSH
52164: LD_INT 3
52166: GREATER
52167: OR
52168: PUSH
52169: LD_EXP 96
52173: PUSH
52174: LD_VAR 0 1
52178: ARRAY
52179: OR
52180: IFFALSE 52221
// begin for i in solds do
52182: LD_ADDR_VAR 0 7
52186: PUSH
52187: LD_VAR 0 2
52191: PUSH
52192: FOR_IN
52193: IFFALSE 52217
// if HasTask ( i ) then
52195: LD_VAR 0 7
52199: PPUSH
52200: CALL_OW 314
52204: IFFALSE 52215
// ComStop ( i ) ;
52206: LD_VAR 0 7
52210: PPUSH
52211: CALL_OW 141
52215: GO 52192
52217: POP
52218: POP
// break ;
52219: GO 52456
// end ; for i in solds do
52221: LD_ADDR_VAR 0 7
52225: PUSH
52226: LD_VAR 0 2
52230: PUSH
52231: FOR_IN
52232: IFFALSE 52448
// begin if IsInUnit ( i ) then
52234: LD_VAR 0 7
52238: PPUSH
52239: CALL_OW 310
52243: IFFALSE 52254
// ComExitBuilding ( i ) ;
52245: LD_VAR 0 7
52249: PPUSH
52250: CALL_OW 122
// if GetLives ( i ) > 333 then
52254: LD_VAR 0 7
52258: PPUSH
52259: CALL_OW 256
52263: PUSH
52264: LD_INT 333
52266: GREATER
52267: IFFALSE 52295
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
52269: LD_VAR 0 7
52273: PPUSH
52274: LD_VAR 0 5
52278: PPUSH
52279: LD_VAR 0 7
52283: PPUSH
52284: CALL_OW 74
52288: PPUSH
52289: CALL_OW 115
52293: GO 52446
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
52295: LD_ADDR_VAR 0 8
52299: PUSH
52300: LD_EXP 74
52304: PUSH
52305: LD_VAR 0 1
52309: ARRAY
52310: PPUSH
52311: LD_INT 2
52313: PUSH
52314: LD_INT 30
52316: PUSH
52317: LD_INT 0
52319: PUSH
52320: EMPTY
52321: LIST
52322: LIST
52323: PUSH
52324: LD_INT 30
52326: PUSH
52327: LD_INT 1
52329: PUSH
52330: EMPTY
52331: LIST
52332: LIST
52333: PUSH
52334: LD_INT 30
52336: PUSH
52337: LD_INT 6
52339: PUSH
52340: EMPTY
52341: LIST
52342: LIST
52343: PUSH
52344: EMPTY
52345: LIST
52346: LIST
52347: LIST
52348: LIST
52349: PPUSH
52350: CALL_OW 72
52354: PPUSH
52355: LD_VAR 0 7
52359: PPUSH
52360: CALL_OW 74
52364: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
52365: LD_VAR 0 7
52369: PPUSH
52370: LD_VAR 0 8
52374: PPUSH
52375: CALL_OW 250
52379: PPUSH
52380: LD_INT 3
52382: PPUSH
52383: LD_INT 5
52385: PPUSH
52386: CALL_OW 272
52390: PPUSH
52391: LD_VAR 0 8
52395: PPUSH
52396: CALL_OW 251
52400: PPUSH
52401: LD_INT 3
52403: PPUSH
52404: LD_INT 5
52406: PPUSH
52407: CALL_OW 273
52411: PPUSH
52412: CALL_OW 111
// SetTag ( i , 0 ) ;
52416: LD_VAR 0 7
52420: PPUSH
52421: LD_INT 0
52423: PPUSH
52424: CALL_OW 109
// solds := solds diff i ;
52428: LD_ADDR_VAR 0 2
52432: PUSH
52433: LD_VAR 0 2
52437: PUSH
52438: LD_VAR 0 7
52442: DIFF
52443: ST_TO_ADDR
// continue ;
52444: GO 52231
// end ; end ;
52446: GO 52231
52448: POP
52449: POP
// until solds ;
52450: LD_VAR 0 2
52454: IFFALSE 52063
// MC_Reset ( base , 18 ) ;
52456: LD_VAR 0 1
52460: PPUSH
52461: LD_INT 18
52463: PPUSH
52464: CALL 24185 0 2
// end ;
52468: LD_VAR 0 4
52472: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
52473: LD_INT 0
52475: PPUSH
52476: PPUSH
52477: PPUSH
52478: PPUSH
52479: PPUSH
52480: PPUSH
52481: PPUSH
52482: PPUSH
52483: PPUSH
52484: PPUSH
52485: PPUSH
52486: PPUSH
52487: PPUSH
52488: PPUSH
52489: PPUSH
52490: PPUSH
52491: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
52492: LD_ADDR_VAR 0 13
52496: PUSH
52497: LD_EXP 74
52501: PUSH
52502: LD_VAR 0 1
52506: ARRAY
52507: PPUSH
52508: LD_INT 25
52510: PUSH
52511: LD_INT 3
52513: PUSH
52514: EMPTY
52515: LIST
52516: LIST
52517: PPUSH
52518: CALL_OW 72
52522: ST_TO_ADDR
// if mc_remote_driver [ base ] then
52523: LD_EXP 114
52527: PUSH
52528: LD_VAR 0 1
52532: ARRAY
52533: IFFALSE 52557
// mechs := mechs diff mc_remote_driver [ base ] ;
52535: LD_ADDR_VAR 0 13
52539: PUSH
52540: LD_VAR 0 13
52544: PUSH
52545: LD_EXP 114
52549: PUSH
52550: LD_VAR 0 1
52554: ARRAY
52555: DIFF
52556: ST_TO_ADDR
// for i in mechs do
52557: LD_ADDR_VAR 0 5
52561: PUSH
52562: LD_VAR 0 13
52566: PUSH
52567: FOR_IN
52568: IFFALSE 52603
// if GetTag ( i ) > 0 then
52570: LD_VAR 0 5
52574: PPUSH
52575: CALL_OW 110
52579: PUSH
52580: LD_INT 0
52582: GREATER
52583: IFFALSE 52601
// mechs := mechs diff i ;
52585: LD_ADDR_VAR 0 13
52589: PUSH
52590: LD_VAR 0 13
52594: PUSH
52595: LD_VAR 0 5
52599: DIFF
52600: ST_TO_ADDR
52601: GO 52567
52603: POP
52604: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
52605: LD_ADDR_VAR 0 9
52609: PUSH
52610: LD_EXP 74
52614: PUSH
52615: LD_VAR 0 1
52619: ARRAY
52620: PPUSH
52621: LD_INT 2
52623: PUSH
52624: LD_INT 25
52626: PUSH
52627: LD_INT 1
52629: PUSH
52630: EMPTY
52631: LIST
52632: LIST
52633: PUSH
52634: LD_INT 25
52636: PUSH
52637: LD_INT 5
52639: PUSH
52640: EMPTY
52641: LIST
52642: LIST
52643: PUSH
52644: LD_INT 25
52646: PUSH
52647: LD_INT 8
52649: PUSH
52650: EMPTY
52651: LIST
52652: LIST
52653: PUSH
52654: LD_INT 25
52656: PUSH
52657: LD_INT 9
52659: PUSH
52660: EMPTY
52661: LIST
52662: LIST
52663: PUSH
52664: EMPTY
52665: LIST
52666: LIST
52667: LIST
52668: LIST
52669: LIST
52670: PPUSH
52671: CALL_OW 72
52675: ST_TO_ADDR
// if not defenders and not solds then
52676: LD_VAR 0 2
52680: NOT
52681: PUSH
52682: LD_VAR 0 9
52686: NOT
52687: AND
52688: IFFALSE 52692
// exit ;
52690: GO 54318
// depot_under_attack := false ;
52692: LD_ADDR_VAR 0 17
52696: PUSH
52697: LD_INT 0
52699: ST_TO_ADDR
// sold_defenders := [ ] ;
52700: LD_ADDR_VAR 0 18
52704: PUSH
52705: EMPTY
52706: ST_TO_ADDR
// if mechs then
52707: LD_VAR 0 13
52711: IFFALSE 52840
// for i in defenders do
52713: LD_ADDR_VAR 0 5
52717: PUSH
52718: LD_VAR 0 2
52722: PUSH
52723: FOR_IN
52724: IFFALSE 52838
// begin SetTag ( i , 20 ) ;
52726: LD_VAR 0 5
52730: PPUSH
52731: LD_INT 20
52733: PPUSH
52734: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
52738: LD_VAR 0 5
52742: PPUSH
52743: CALL_OW 263
52747: PUSH
52748: LD_INT 1
52750: EQUAL
52751: PUSH
52752: LD_VAR 0 5
52756: PPUSH
52757: CALL_OW 311
52761: NOT
52762: AND
52763: PUSH
52764: LD_VAR 0 13
52768: AND
52769: IFFALSE 52836
// begin un := mechs [ 1 ] ;
52771: LD_ADDR_VAR 0 11
52775: PUSH
52776: LD_VAR 0 13
52780: PUSH
52781: LD_INT 1
52783: ARRAY
52784: ST_TO_ADDR
// ComExitBuilding ( un ) ;
52785: LD_VAR 0 11
52789: PPUSH
52790: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
52794: LD_VAR 0 11
52798: PPUSH
52799: LD_VAR 0 5
52803: PPUSH
52804: CALL_OW 180
// SetTag ( un , 19 ) ;
52808: LD_VAR 0 11
52812: PPUSH
52813: LD_INT 19
52815: PPUSH
52816: CALL_OW 109
// mechs := mechs diff un ;
52820: LD_ADDR_VAR 0 13
52824: PUSH
52825: LD_VAR 0 13
52829: PUSH
52830: LD_VAR 0 11
52834: DIFF
52835: ST_TO_ADDR
// end ; end ;
52836: GO 52723
52838: POP
52839: POP
// if solds then
52840: LD_VAR 0 9
52844: IFFALSE 52903
// for i in solds do
52846: LD_ADDR_VAR 0 5
52850: PUSH
52851: LD_VAR 0 9
52855: PUSH
52856: FOR_IN
52857: IFFALSE 52901
// if not GetTag ( i ) then
52859: LD_VAR 0 5
52863: PPUSH
52864: CALL_OW 110
52868: NOT
52869: IFFALSE 52899
// begin defenders := defenders union i ;
52871: LD_ADDR_VAR 0 2
52875: PUSH
52876: LD_VAR 0 2
52880: PUSH
52881: LD_VAR 0 5
52885: UNION
52886: ST_TO_ADDR
// SetTag ( i , 18 ) ;
52887: LD_VAR 0 5
52891: PPUSH
52892: LD_INT 18
52894: PPUSH
52895: CALL_OW 109
// end ;
52899: GO 52856
52901: POP
52902: POP
// repeat wait ( 0 0$1 ) ;
52903: LD_INT 35
52905: PPUSH
52906: CALL_OW 67
// enemy := mc_scan [ base ] ;
52910: LD_ADDR_VAR 0 3
52914: PUSH
52915: LD_EXP 97
52919: PUSH
52920: LD_VAR 0 1
52924: ARRAY
52925: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
52926: LD_EXP 74
52930: PUSH
52931: LD_VAR 0 1
52935: ARRAY
52936: NOT
52937: PUSH
52938: LD_EXP 74
52942: PUSH
52943: LD_VAR 0 1
52947: ARRAY
52948: PUSH
52949: EMPTY
52950: EQUAL
52951: OR
52952: IFFALSE 52989
// begin for i in defenders do
52954: LD_ADDR_VAR 0 5
52958: PUSH
52959: LD_VAR 0 2
52963: PUSH
52964: FOR_IN
52965: IFFALSE 52978
// ComStop ( i ) ;
52967: LD_VAR 0 5
52971: PPUSH
52972: CALL_OW 141
52976: GO 52964
52978: POP
52979: POP
// defenders := [ ] ;
52980: LD_ADDR_VAR 0 2
52984: PUSH
52985: EMPTY
52986: ST_TO_ADDR
// exit ;
52987: GO 54318
// end ; for i in defenders do
52989: LD_ADDR_VAR 0 5
52993: PUSH
52994: LD_VAR 0 2
52998: PUSH
52999: FOR_IN
53000: IFFALSE 53818
// begin e := NearestUnitToUnit ( enemy , i ) ;
53002: LD_ADDR_VAR 0 14
53006: PUSH
53007: LD_VAR 0 3
53011: PPUSH
53012: LD_VAR 0 5
53016: PPUSH
53017: CALL_OW 74
53021: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53022: LD_ADDR_VAR 0 8
53026: PUSH
53027: LD_EXP 74
53031: PUSH
53032: LD_VAR 0 1
53036: ARRAY
53037: PPUSH
53038: LD_INT 2
53040: PUSH
53041: LD_INT 30
53043: PUSH
53044: LD_INT 0
53046: PUSH
53047: EMPTY
53048: LIST
53049: LIST
53050: PUSH
53051: LD_INT 30
53053: PUSH
53054: LD_INT 1
53056: PUSH
53057: EMPTY
53058: LIST
53059: LIST
53060: PUSH
53061: EMPTY
53062: LIST
53063: LIST
53064: LIST
53065: PPUSH
53066: CALL_OW 72
53070: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
53071: LD_ADDR_VAR 0 17
53075: PUSH
53076: LD_VAR 0 8
53080: NOT
53081: PUSH
53082: LD_VAR 0 8
53086: PPUSH
53087: LD_INT 3
53089: PUSH
53090: LD_INT 24
53092: PUSH
53093: LD_INT 600
53095: PUSH
53096: EMPTY
53097: LIST
53098: LIST
53099: PUSH
53100: EMPTY
53101: LIST
53102: LIST
53103: PPUSH
53104: CALL_OW 72
53108: OR
53109: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
53110: LD_VAR 0 5
53114: PPUSH
53115: CALL_OW 247
53119: PUSH
53120: LD_INT 2
53122: DOUBLE
53123: EQUAL
53124: IFTRUE 53128
53126: GO 53524
53128: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
53129: LD_VAR 0 5
53133: PPUSH
53134: CALL_OW 256
53138: PUSH
53139: LD_INT 650
53141: GREATER
53142: PUSH
53143: LD_VAR 0 5
53147: PPUSH
53148: LD_VAR 0 14
53152: PPUSH
53153: CALL_OW 296
53157: PUSH
53158: LD_INT 40
53160: LESS
53161: PUSH
53162: LD_VAR 0 14
53166: PPUSH
53167: LD_EXP 99
53171: PUSH
53172: LD_VAR 0 1
53176: ARRAY
53177: PPUSH
53178: CALL_OW 308
53182: OR
53183: AND
53184: IFFALSE 53306
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
53186: LD_VAR 0 5
53190: PPUSH
53191: CALL_OW 262
53195: PUSH
53196: LD_INT 1
53198: EQUAL
53199: PUSH
53200: LD_VAR 0 5
53204: PPUSH
53205: CALL_OW 261
53209: PUSH
53210: LD_INT 30
53212: LESS
53213: AND
53214: PUSH
53215: LD_VAR 0 8
53219: AND
53220: IFFALSE 53290
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
53222: LD_VAR 0 5
53226: PPUSH
53227: LD_VAR 0 8
53231: PPUSH
53232: LD_VAR 0 5
53236: PPUSH
53237: CALL_OW 74
53241: PPUSH
53242: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
53246: LD_VAR 0 5
53250: PPUSH
53251: LD_VAR 0 8
53255: PPUSH
53256: LD_VAR 0 5
53260: PPUSH
53261: CALL_OW 74
53265: PPUSH
53266: CALL_OW 296
53270: PUSH
53271: LD_INT 6
53273: LESS
53274: IFFALSE 53288
// SetFuel ( i , 100 ) ;
53276: LD_VAR 0 5
53280: PPUSH
53281: LD_INT 100
53283: PPUSH
53284: CALL_OW 240
// end else
53288: GO 53304
// ComAttackUnit ( i , e ) ;
53290: LD_VAR 0 5
53294: PPUSH
53295: LD_VAR 0 14
53299: PPUSH
53300: CALL_OW 115
// end else
53304: GO 53407
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
53306: LD_VAR 0 14
53310: PPUSH
53311: LD_EXP 99
53315: PUSH
53316: LD_VAR 0 1
53320: ARRAY
53321: PPUSH
53322: CALL_OW 308
53326: NOT
53327: PUSH
53328: LD_VAR 0 5
53332: PPUSH
53333: LD_VAR 0 14
53337: PPUSH
53338: CALL_OW 296
53342: PUSH
53343: LD_INT 40
53345: GREATEREQUAL
53346: AND
53347: PUSH
53348: LD_VAR 0 5
53352: PPUSH
53353: CALL_OW 256
53357: PUSH
53358: LD_INT 650
53360: LESSEQUAL
53361: OR
53362: PUSH
53363: LD_VAR 0 5
53367: PPUSH
53368: LD_EXP 98
53372: PUSH
53373: LD_VAR 0 1
53377: ARRAY
53378: PPUSH
53379: CALL_OW 308
53383: NOT
53384: AND
53385: IFFALSE 53407
// ComMoveToArea ( i , mc_parking [ base ] ) ;
53387: LD_VAR 0 5
53391: PPUSH
53392: LD_EXP 98
53396: PUSH
53397: LD_VAR 0 1
53401: ARRAY
53402: PPUSH
53403: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
53407: LD_VAR 0 5
53411: PPUSH
53412: CALL_OW 256
53416: PUSH
53417: LD_INT 998
53419: LESS
53420: PUSH
53421: LD_VAR 0 5
53425: PPUSH
53426: CALL_OW 263
53430: PUSH
53431: LD_INT 1
53433: EQUAL
53434: AND
53435: PUSH
53436: LD_VAR 0 5
53440: PPUSH
53441: CALL_OW 311
53445: AND
53446: PUSH
53447: LD_VAR 0 5
53451: PPUSH
53452: LD_EXP 98
53456: PUSH
53457: LD_VAR 0 1
53461: ARRAY
53462: PPUSH
53463: CALL_OW 308
53467: AND
53468: IFFALSE 53522
// begin mech := IsDrivenBy ( i ) ;
53470: LD_ADDR_VAR 0 10
53474: PUSH
53475: LD_VAR 0 5
53479: PPUSH
53480: CALL_OW 311
53484: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
53485: LD_VAR 0 10
53489: PPUSH
53490: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
53494: LD_VAR 0 10
53498: PPUSH
53499: LD_VAR 0 5
53503: PPUSH
53504: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
53508: LD_VAR 0 10
53512: PPUSH
53513: LD_VAR 0 5
53517: PPUSH
53518: CALL_OW 180
// end ; end ; unit_human :
53522: GO 53789
53524: LD_INT 1
53526: DOUBLE
53527: EQUAL
53528: IFTRUE 53532
53530: GO 53788
53532: POP
// begin b := IsInUnit ( i ) ;
53533: LD_ADDR_VAR 0 19
53537: PUSH
53538: LD_VAR 0 5
53542: PPUSH
53543: CALL_OW 310
53547: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
53548: LD_ADDR_VAR 0 20
53552: PUSH
53553: LD_VAR 0 19
53557: NOT
53558: PUSH
53559: LD_VAR 0 19
53563: PPUSH
53564: CALL_OW 266
53568: PUSH
53569: LD_INT 32
53571: PUSH
53572: LD_INT 31
53574: PUSH
53575: EMPTY
53576: LIST
53577: LIST
53578: IN
53579: OR
53580: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
53581: LD_VAR 0 17
53585: PUSH
53586: LD_VAR 0 2
53590: PPUSH
53591: LD_INT 21
53593: PUSH
53594: LD_INT 2
53596: PUSH
53597: EMPTY
53598: LIST
53599: LIST
53600: PPUSH
53601: CALL_OW 72
53605: PUSH
53606: LD_INT 1
53608: LESSEQUAL
53609: OR
53610: PUSH
53611: LD_VAR 0 20
53615: AND
53616: PUSH
53617: LD_VAR 0 5
53621: PUSH
53622: LD_VAR 0 18
53626: IN
53627: NOT
53628: AND
53629: IFFALSE 53722
// begin if b then
53631: LD_VAR 0 19
53635: IFFALSE 53684
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
53637: LD_VAR 0 19
53641: PPUSH
53642: LD_VAR 0 3
53646: PPUSH
53647: LD_VAR 0 19
53651: PPUSH
53652: CALL_OW 74
53656: PPUSH
53657: CALL_OW 296
53661: PUSH
53662: LD_INT 10
53664: LESS
53665: PUSH
53666: LD_VAR 0 19
53670: PPUSH
53671: CALL_OW 461
53675: PUSH
53676: LD_INT 7
53678: NONEQUAL
53679: AND
53680: IFFALSE 53684
// continue ;
53682: GO 52999
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
53684: LD_ADDR_VAR 0 18
53688: PUSH
53689: LD_VAR 0 18
53693: PPUSH
53694: LD_VAR 0 18
53698: PUSH
53699: LD_INT 1
53701: PLUS
53702: PPUSH
53703: LD_VAR 0 5
53707: PPUSH
53708: CALL_OW 1
53712: ST_TO_ADDR
// ComExitBuilding ( i ) ;
53713: LD_VAR 0 5
53717: PPUSH
53718: CALL_OW 122
// end ; if sold_defenders then
53722: LD_VAR 0 18
53726: IFFALSE 53786
// if i in sold_defenders then
53728: LD_VAR 0 5
53732: PUSH
53733: LD_VAR 0 18
53737: IN
53738: IFFALSE 53786
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
53740: LD_VAR 0 5
53744: PPUSH
53745: CALL_OW 314
53749: NOT
53750: PUSH
53751: LD_VAR 0 5
53755: PPUSH
53756: LD_VAR 0 14
53760: PPUSH
53761: CALL_OW 296
53765: PUSH
53766: LD_INT 30
53768: LESS
53769: AND
53770: IFFALSE 53786
// ComAttackUnit ( i , e ) ;
53772: LD_VAR 0 5
53776: PPUSH
53777: LD_VAR 0 14
53781: PPUSH
53782: CALL_OW 115
// end ; end ; end ;
53786: GO 53789
53788: POP
// if IsDead ( i ) then
53789: LD_VAR 0 5
53793: PPUSH
53794: CALL_OW 301
53798: IFFALSE 53816
// defenders := defenders diff i ;
53800: LD_ADDR_VAR 0 2
53804: PUSH
53805: LD_VAR 0 2
53809: PUSH
53810: LD_VAR 0 5
53814: DIFF
53815: ST_TO_ADDR
// end ;
53816: GO 52999
53818: POP
53819: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
53820: LD_VAR 0 3
53824: NOT
53825: PUSH
53826: LD_VAR 0 2
53830: NOT
53831: OR
53832: PUSH
53833: LD_EXP 74
53837: PUSH
53838: LD_VAR 0 1
53842: ARRAY
53843: NOT
53844: OR
53845: IFFALSE 52903
// MC_Reset ( base , 18 ) ;
53847: LD_VAR 0 1
53851: PPUSH
53852: LD_INT 18
53854: PPUSH
53855: CALL 24185 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
53859: LD_ADDR_VAR 0 2
53863: PUSH
53864: LD_VAR 0 2
53868: PUSH
53869: LD_VAR 0 2
53873: PPUSH
53874: LD_INT 2
53876: PUSH
53877: LD_INT 25
53879: PUSH
53880: LD_INT 1
53882: PUSH
53883: EMPTY
53884: LIST
53885: LIST
53886: PUSH
53887: LD_INT 25
53889: PUSH
53890: LD_INT 5
53892: PUSH
53893: EMPTY
53894: LIST
53895: LIST
53896: PUSH
53897: LD_INT 25
53899: PUSH
53900: LD_INT 8
53902: PUSH
53903: EMPTY
53904: LIST
53905: LIST
53906: PUSH
53907: LD_INT 25
53909: PUSH
53910: LD_INT 9
53912: PUSH
53913: EMPTY
53914: LIST
53915: LIST
53916: PUSH
53917: EMPTY
53918: LIST
53919: LIST
53920: LIST
53921: LIST
53922: LIST
53923: PPUSH
53924: CALL_OW 72
53928: DIFF
53929: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
53930: LD_VAR 0 3
53934: NOT
53935: PUSH
53936: LD_VAR 0 2
53940: PPUSH
53941: LD_INT 21
53943: PUSH
53944: LD_INT 2
53946: PUSH
53947: EMPTY
53948: LIST
53949: LIST
53950: PPUSH
53951: CALL_OW 72
53955: AND
53956: IFFALSE 54294
// begin tmp := FilterByTag ( defenders , 19 ) ;
53958: LD_ADDR_VAR 0 12
53962: PUSH
53963: LD_VAR 0 2
53967: PPUSH
53968: LD_INT 19
53970: PPUSH
53971: CALL 90747 0 2
53975: ST_TO_ADDR
// if tmp then
53976: LD_VAR 0 12
53980: IFFALSE 54050
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
53982: LD_ADDR_VAR 0 12
53986: PUSH
53987: LD_VAR 0 12
53991: PPUSH
53992: LD_INT 25
53994: PUSH
53995: LD_INT 3
53997: PUSH
53998: EMPTY
53999: LIST
54000: LIST
54001: PPUSH
54002: CALL_OW 72
54006: ST_TO_ADDR
// if tmp then
54007: LD_VAR 0 12
54011: IFFALSE 54050
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
54013: LD_ADDR_EXP 86
54017: PUSH
54018: LD_EXP 86
54022: PPUSH
54023: LD_VAR 0 1
54027: PPUSH
54028: LD_EXP 86
54032: PUSH
54033: LD_VAR 0 1
54037: ARRAY
54038: PUSH
54039: LD_VAR 0 12
54043: UNION
54044: PPUSH
54045: CALL_OW 1
54049: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
54050: LD_VAR 0 1
54054: PPUSH
54055: LD_INT 19
54057: PPUSH
54058: CALL 24185 0 2
// repeat wait ( 0 0$1 ) ;
54062: LD_INT 35
54064: PPUSH
54065: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
54069: LD_EXP 74
54073: PUSH
54074: LD_VAR 0 1
54078: ARRAY
54079: NOT
54080: PUSH
54081: LD_EXP 74
54085: PUSH
54086: LD_VAR 0 1
54090: ARRAY
54091: PUSH
54092: EMPTY
54093: EQUAL
54094: OR
54095: IFFALSE 54132
// begin for i in defenders do
54097: LD_ADDR_VAR 0 5
54101: PUSH
54102: LD_VAR 0 2
54106: PUSH
54107: FOR_IN
54108: IFFALSE 54121
// ComStop ( i ) ;
54110: LD_VAR 0 5
54114: PPUSH
54115: CALL_OW 141
54119: GO 54107
54121: POP
54122: POP
// defenders := [ ] ;
54123: LD_ADDR_VAR 0 2
54127: PUSH
54128: EMPTY
54129: ST_TO_ADDR
// exit ;
54130: GO 54318
// end ; for i in defenders do
54132: LD_ADDR_VAR 0 5
54136: PUSH
54137: LD_VAR 0 2
54141: PUSH
54142: FOR_IN
54143: IFFALSE 54232
// begin if not IsInArea ( i , mc_parking [ base ] ) then
54145: LD_VAR 0 5
54149: PPUSH
54150: LD_EXP 98
54154: PUSH
54155: LD_VAR 0 1
54159: ARRAY
54160: PPUSH
54161: CALL_OW 308
54165: NOT
54166: IFFALSE 54190
// ComMoveToArea ( i , mc_parking [ base ] ) else
54168: LD_VAR 0 5
54172: PPUSH
54173: LD_EXP 98
54177: PUSH
54178: LD_VAR 0 1
54182: ARRAY
54183: PPUSH
54184: CALL_OW 113
54188: GO 54230
// if GetControl ( i ) = control_manual then
54190: LD_VAR 0 5
54194: PPUSH
54195: CALL_OW 263
54199: PUSH
54200: LD_INT 1
54202: EQUAL
54203: IFFALSE 54230
// if IsDrivenBy ( i ) then
54205: LD_VAR 0 5
54209: PPUSH
54210: CALL_OW 311
54214: IFFALSE 54230
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
54216: LD_VAR 0 5
54220: PPUSH
54221: CALL_OW 311
54225: PPUSH
54226: CALL_OW 121
// end ;
54230: GO 54142
54232: POP
54233: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
54234: LD_VAR 0 2
54238: PPUSH
54239: LD_INT 95
54241: PUSH
54242: LD_EXP 98
54246: PUSH
54247: LD_VAR 0 1
54251: ARRAY
54252: PUSH
54253: EMPTY
54254: LIST
54255: LIST
54256: PPUSH
54257: CALL_OW 72
54261: PUSH
54262: LD_VAR 0 2
54266: EQUAL
54267: PUSH
54268: LD_EXP 97
54272: PUSH
54273: LD_VAR 0 1
54277: ARRAY
54278: OR
54279: PUSH
54280: LD_EXP 74
54284: PUSH
54285: LD_VAR 0 1
54289: ARRAY
54290: NOT
54291: OR
54292: IFFALSE 54062
// end ; MC_Reset ( base , 19 ) ;
54294: LD_VAR 0 1
54298: PPUSH
54299: LD_INT 19
54301: PPUSH
54302: CALL 24185 0 2
// MC_Reset ( base , 20 ) ;
54306: LD_VAR 0 1
54310: PPUSH
54311: LD_INT 20
54313: PPUSH
54314: CALL 24185 0 2
// end ;
54318: LD_VAR 0 4
54322: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
54323: LD_INT 0
54325: PPUSH
54326: PPUSH
54327: PPUSH
54328: PPUSH
// result := false ;
54329: LD_ADDR_VAR 0 2
54333: PUSH
54334: LD_INT 0
54336: ST_TO_ADDR
// side := GetSide ( unit ) ;
54337: LD_ADDR_VAR 0 3
54341: PUSH
54342: LD_VAR 0 1
54346: PPUSH
54347: CALL_OW 255
54351: ST_TO_ADDR
// nat := GetNation ( unit ) ;
54352: LD_ADDR_VAR 0 4
54356: PUSH
54357: LD_VAR 0 1
54361: PPUSH
54362: CALL_OW 248
54366: ST_TO_ADDR
// case nat of 1 :
54367: LD_VAR 0 4
54371: PUSH
54372: LD_INT 1
54374: DOUBLE
54375: EQUAL
54376: IFTRUE 54380
54378: GO 54391
54380: POP
// tech := tech_lassight ; 2 :
54381: LD_ADDR_VAR 0 5
54385: PUSH
54386: LD_INT 12
54388: ST_TO_ADDR
54389: GO 54430
54391: LD_INT 2
54393: DOUBLE
54394: EQUAL
54395: IFTRUE 54399
54397: GO 54410
54399: POP
// tech := tech_mortar ; 3 :
54400: LD_ADDR_VAR 0 5
54404: PUSH
54405: LD_INT 41
54407: ST_TO_ADDR
54408: GO 54430
54410: LD_INT 3
54412: DOUBLE
54413: EQUAL
54414: IFTRUE 54418
54416: GO 54429
54418: POP
// tech := tech_bazooka ; end ;
54419: LD_ADDR_VAR 0 5
54423: PUSH
54424: LD_INT 44
54426: ST_TO_ADDR
54427: GO 54430
54429: POP
// if Researched ( side , tech ) then
54430: LD_VAR 0 3
54434: PPUSH
54435: LD_VAR 0 5
54439: PPUSH
54440: CALL_OW 325
54444: IFFALSE 54471
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
54446: LD_ADDR_VAR 0 2
54450: PUSH
54451: LD_INT 5
54453: PUSH
54454: LD_INT 8
54456: PUSH
54457: LD_INT 9
54459: PUSH
54460: EMPTY
54461: LIST
54462: LIST
54463: LIST
54464: PUSH
54465: LD_VAR 0 4
54469: ARRAY
54470: ST_TO_ADDR
// end ;
54471: LD_VAR 0 2
54475: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
54476: LD_INT 0
54478: PPUSH
54479: PPUSH
54480: PPUSH
// if not mines then
54481: LD_VAR 0 2
54485: NOT
54486: IFFALSE 54490
// exit ;
54488: GO 54634
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54490: LD_ADDR_VAR 0 5
54494: PUSH
54495: LD_INT 81
54497: PUSH
54498: LD_VAR 0 1
54502: PUSH
54503: EMPTY
54504: LIST
54505: LIST
54506: PUSH
54507: LD_INT 3
54509: PUSH
54510: LD_INT 21
54512: PUSH
54513: LD_INT 3
54515: PUSH
54516: EMPTY
54517: LIST
54518: LIST
54519: PUSH
54520: EMPTY
54521: LIST
54522: LIST
54523: PUSH
54524: EMPTY
54525: LIST
54526: LIST
54527: PPUSH
54528: CALL_OW 69
54532: ST_TO_ADDR
// for i in mines do
54533: LD_ADDR_VAR 0 4
54537: PUSH
54538: LD_VAR 0 2
54542: PUSH
54543: FOR_IN
54544: IFFALSE 54632
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
54546: LD_VAR 0 4
54550: PUSH
54551: LD_INT 1
54553: ARRAY
54554: PPUSH
54555: LD_VAR 0 4
54559: PUSH
54560: LD_INT 2
54562: ARRAY
54563: PPUSH
54564: CALL_OW 458
54568: NOT
54569: IFFALSE 54573
// continue ;
54571: GO 54543
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
54573: LD_VAR 0 4
54577: PUSH
54578: LD_INT 1
54580: ARRAY
54581: PPUSH
54582: LD_VAR 0 4
54586: PUSH
54587: LD_INT 2
54589: ARRAY
54590: PPUSH
54591: CALL_OW 428
54595: PUSH
54596: LD_VAR 0 5
54600: IN
54601: IFFALSE 54630
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
54603: LD_VAR 0 4
54607: PUSH
54608: LD_INT 1
54610: ARRAY
54611: PPUSH
54612: LD_VAR 0 4
54616: PUSH
54617: LD_INT 2
54619: ARRAY
54620: PPUSH
54621: LD_VAR 0 1
54625: PPUSH
54626: CALL_OW 456
// end ;
54630: GO 54543
54632: POP
54633: POP
// end ;
54634: LD_VAR 0 3
54638: RET
// export function Count ( array ) ; var i ; begin
54639: LD_INT 0
54641: PPUSH
54642: PPUSH
// result := 0 ;
54643: LD_ADDR_VAR 0 2
54647: PUSH
54648: LD_INT 0
54650: ST_TO_ADDR
// for i in array do
54651: LD_ADDR_VAR 0 3
54655: PUSH
54656: LD_VAR 0 1
54660: PUSH
54661: FOR_IN
54662: IFFALSE 54686
// if i then
54664: LD_VAR 0 3
54668: IFFALSE 54684
// result := result + 1 ;
54670: LD_ADDR_VAR 0 2
54674: PUSH
54675: LD_VAR 0 2
54679: PUSH
54680: LD_INT 1
54682: PLUS
54683: ST_TO_ADDR
54684: GO 54661
54686: POP
54687: POP
// end ;
54688: LD_VAR 0 2
54692: RET
// export function IsEmpty ( building ) ; begin
54693: LD_INT 0
54695: PPUSH
// if not building then
54696: LD_VAR 0 1
54700: NOT
54701: IFFALSE 54705
// exit ;
54703: GO 54748
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
54705: LD_ADDR_VAR 0 2
54709: PUSH
54710: LD_VAR 0 1
54714: PUSH
54715: LD_INT 22
54717: PUSH
54718: LD_VAR 0 1
54722: PPUSH
54723: CALL_OW 255
54727: PUSH
54728: EMPTY
54729: LIST
54730: LIST
54731: PUSH
54732: LD_INT 58
54734: PUSH
54735: EMPTY
54736: LIST
54737: PUSH
54738: EMPTY
54739: LIST
54740: LIST
54741: PPUSH
54742: CALL_OW 69
54746: IN
54747: ST_TO_ADDR
// end ;
54748: LD_VAR 0 2
54752: RET
// export function IsNotFull ( building ) ; begin
54753: LD_INT 0
54755: PPUSH
// if not building then
54756: LD_VAR 0 1
54760: NOT
54761: IFFALSE 54765
// exit ;
54763: GO 54784
// result := UnitsInside ( building ) < 6 ;
54765: LD_ADDR_VAR 0 2
54769: PUSH
54770: LD_VAR 0 1
54774: PPUSH
54775: CALL_OW 313
54779: PUSH
54780: LD_INT 6
54782: LESS
54783: ST_TO_ADDR
// end ;
54784: LD_VAR 0 2
54788: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
54789: LD_INT 0
54791: PPUSH
54792: PPUSH
54793: PPUSH
54794: PPUSH
// tmp := [ ] ;
54795: LD_ADDR_VAR 0 3
54799: PUSH
54800: EMPTY
54801: ST_TO_ADDR
// list := [ ] ;
54802: LD_ADDR_VAR 0 5
54806: PUSH
54807: EMPTY
54808: ST_TO_ADDR
// for i = 16 to 25 do
54809: LD_ADDR_VAR 0 4
54813: PUSH
54814: DOUBLE
54815: LD_INT 16
54817: DEC
54818: ST_TO_ADDR
54819: LD_INT 25
54821: PUSH
54822: FOR_TO
54823: IFFALSE 54896
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
54825: LD_ADDR_VAR 0 3
54829: PUSH
54830: LD_VAR 0 3
54834: PUSH
54835: LD_INT 22
54837: PUSH
54838: LD_VAR 0 1
54842: PPUSH
54843: CALL_OW 255
54847: PUSH
54848: EMPTY
54849: LIST
54850: LIST
54851: PUSH
54852: LD_INT 91
54854: PUSH
54855: LD_VAR 0 1
54859: PUSH
54860: LD_INT 6
54862: PUSH
54863: EMPTY
54864: LIST
54865: LIST
54866: LIST
54867: PUSH
54868: LD_INT 30
54870: PUSH
54871: LD_VAR 0 4
54875: PUSH
54876: EMPTY
54877: LIST
54878: LIST
54879: PUSH
54880: EMPTY
54881: LIST
54882: LIST
54883: LIST
54884: PUSH
54885: EMPTY
54886: LIST
54887: PPUSH
54888: CALL_OW 69
54892: ADD
54893: ST_TO_ADDR
54894: GO 54822
54896: POP
54897: POP
// for i = 1 to tmp do
54898: LD_ADDR_VAR 0 4
54902: PUSH
54903: DOUBLE
54904: LD_INT 1
54906: DEC
54907: ST_TO_ADDR
54908: LD_VAR 0 3
54912: PUSH
54913: FOR_TO
54914: IFFALSE 55002
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
54916: LD_ADDR_VAR 0 5
54920: PUSH
54921: LD_VAR 0 5
54925: PUSH
54926: LD_VAR 0 3
54930: PUSH
54931: LD_VAR 0 4
54935: ARRAY
54936: PPUSH
54937: CALL_OW 266
54941: PUSH
54942: LD_VAR 0 3
54946: PUSH
54947: LD_VAR 0 4
54951: ARRAY
54952: PPUSH
54953: CALL_OW 250
54957: PUSH
54958: LD_VAR 0 3
54962: PUSH
54963: LD_VAR 0 4
54967: ARRAY
54968: PPUSH
54969: CALL_OW 251
54973: PUSH
54974: LD_VAR 0 3
54978: PUSH
54979: LD_VAR 0 4
54983: ARRAY
54984: PPUSH
54985: CALL_OW 254
54989: PUSH
54990: EMPTY
54991: LIST
54992: LIST
54993: LIST
54994: LIST
54995: PUSH
54996: EMPTY
54997: LIST
54998: ADD
54999: ST_TO_ADDR
55000: GO 54913
55002: POP
55003: POP
// result := list ;
55004: LD_ADDR_VAR 0 2
55008: PUSH
55009: LD_VAR 0 5
55013: ST_TO_ADDR
// end ;
55014: LD_VAR 0 2
55018: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
55019: LD_INT 0
55021: PPUSH
55022: PPUSH
55023: PPUSH
55024: PPUSH
55025: PPUSH
55026: PPUSH
55027: PPUSH
// if not factory then
55028: LD_VAR 0 1
55032: NOT
55033: IFFALSE 55037
// exit ;
55035: GO 55630
// if control = control_apeman then
55037: LD_VAR 0 4
55041: PUSH
55042: LD_INT 5
55044: EQUAL
55045: IFFALSE 55154
// begin tmp := UnitsInside ( factory ) ;
55047: LD_ADDR_VAR 0 8
55051: PUSH
55052: LD_VAR 0 1
55056: PPUSH
55057: CALL_OW 313
55061: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
55062: LD_VAR 0 8
55066: PPUSH
55067: LD_INT 25
55069: PUSH
55070: LD_INT 12
55072: PUSH
55073: EMPTY
55074: LIST
55075: LIST
55076: PPUSH
55077: CALL_OW 72
55081: NOT
55082: IFFALSE 55092
// control := control_manual ;
55084: LD_ADDR_VAR 0 4
55088: PUSH
55089: LD_INT 1
55091: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
55092: LD_ADDR_VAR 0 8
55096: PUSH
55097: LD_VAR 0 1
55101: PPUSH
55102: CALL 54789 0 1
55106: ST_TO_ADDR
// if tmp then
55107: LD_VAR 0 8
55111: IFFALSE 55154
// begin for i in tmp do
55113: LD_ADDR_VAR 0 7
55117: PUSH
55118: LD_VAR 0 8
55122: PUSH
55123: FOR_IN
55124: IFFALSE 55152
// if i [ 1 ] = b_ext_radio then
55126: LD_VAR 0 7
55130: PUSH
55131: LD_INT 1
55133: ARRAY
55134: PUSH
55135: LD_INT 22
55137: EQUAL
55138: IFFALSE 55150
// begin control := control_remote ;
55140: LD_ADDR_VAR 0 4
55144: PUSH
55145: LD_INT 2
55147: ST_TO_ADDR
// break ;
55148: GO 55152
// end ;
55150: GO 55123
55152: POP
55153: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55154: LD_VAR 0 1
55158: PPUSH
55159: LD_VAR 0 2
55163: PPUSH
55164: LD_VAR 0 3
55168: PPUSH
55169: LD_VAR 0 4
55173: PPUSH
55174: LD_VAR 0 5
55178: PPUSH
55179: CALL_OW 448
55183: IFFALSE 55218
// begin result := [ chassis , engine , control , weapon ] ;
55185: LD_ADDR_VAR 0 6
55189: PUSH
55190: LD_VAR 0 2
55194: PUSH
55195: LD_VAR 0 3
55199: PUSH
55200: LD_VAR 0 4
55204: PUSH
55205: LD_VAR 0 5
55209: PUSH
55210: EMPTY
55211: LIST
55212: LIST
55213: LIST
55214: LIST
55215: ST_TO_ADDR
// exit ;
55216: GO 55630
// end ; _chassis := AvailableChassisList ( factory ) ;
55218: LD_ADDR_VAR 0 9
55222: PUSH
55223: LD_VAR 0 1
55227: PPUSH
55228: CALL_OW 475
55232: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
55233: LD_ADDR_VAR 0 11
55237: PUSH
55238: LD_VAR 0 1
55242: PPUSH
55243: CALL_OW 476
55247: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
55248: LD_ADDR_VAR 0 12
55252: PUSH
55253: LD_VAR 0 1
55257: PPUSH
55258: CALL_OW 477
55262: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
55263: LD_ADDR_VAR 0 10
55267: PUSH
55268: LD_VAR 0 1
55272: PPUSH
55273: CALL_OW 478
55277: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
55278: LD_VAR 0 9
55282: NOT
55283: PUSH
55284: LD_VAR 0 11
55288: NOT
55289: OR
55290: PUSH
55291: LD_VAR 0 12
55295: NOT
55296: OR
55297: PUSH
55298: LD_VAR 0 10
55302: NOT
55303: OR
55304: IFFALSE 55339
// begin result := [ chassis , engine , control , weapon ] ;
55306: LD_ADDR_VAR 0 6
55310: PUSH
55311: LD_VAR 0 2
55315: PUSH
55316: LD_VAR 0 3
55320: PUSH
55321: LD_VAR 0 4
55325: PUSH
55326: LD_VAR 0 5
55330: PUSH
55331: EMPTY
55332: LIST
55333: LIST
55334: LIST
55335: LIST
55336: ST_TO_ADDR
// exit ;
55337: GO 55630
// end ; if not chassis in _chassis then
55339: LD_VAR 0 2
55343: PUSH
55344: LD_VAR 0 9
55348: IN
55349: NOT
55350: IFFALSE 55376
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
55352: LD_ADDR_VAR 0 2
55356: PUSH
55357: LD_VAR 0 9
55361: PUSH
55362: LD_INT 1
55364: PPUSH
55365: LD_VAR 0 9
55369: PPUSH
55370: CALL_OW 12
55374: ARRAY
55375: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
55376: LD_VAR 0 2
55380: PPUSH
55381: LD_VAR 0 3
55385: PPUSH
55386: CALL 55635 0 2
55390: NOT
55391: IFFALSE 55450
// repeat engine := _engine [ 1 ] ;
55393: LD_ADDR_VAR 0 3
55397: PUSH
55398: LD_VAR 0 11
55402: PUSH
55403: LD_INT 1
55405: ARRAY
55406: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
55407: LD_ADDR_VAR 0 11
55411: PUSH
55412: LD_VAR 0 11
55416: PPUSH
55417: LD_INT 1
55419: PPUSH
55420: CALL_OW 3
55424: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
55425: LD_VAR 0 2
55429: PPUSH
55430: LD_VAR 0 3
55434: PPUSH
55435: CALL 55635 0 2
55439: PUSH
55440: LD_VAR 0 11
55444: PUSH
55445: EMPTY
55446: EQUAL
55447: OR
55448: IFFALSE 55393
// if not control in _control then
55450: LD_VAR 0 4
55454: PUSH
55455: LD_VAR 0 12
55459: IN
55460: NOT
55461: IFFALSE 55487
// control := _control [ rand ( 1 , _control ) ] ;
55463: LD_ADDR_VAR 0 4
55467: PUSH
55468: LD_VAR 0 12
55472: PUSH
55473: LD_INT 1
55475: PPUSH
55476: LD_VAR 0 12
55480: PPUSH
55481: CALL_OW 12
55485: ARRAY
55486: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
55487: LD_VAR 0 2
55491: PPUSH
55492: LD_VAR 0 5
55496: PPUSH
55497: CALL 55855 0 2
55501: NOT
55502: IFFALSE 55561
// repeat weapon := _weapon [ 1 ] ;
55504: LD_ADDR_VAR 0 5
55508: PUSH
55509: LD_VAR 0 10
55513: PUSH
55514: LD_INT 1
55516: ARRAY
55517: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
55518: LD_ADDR_VAR 0 10
55522: PUSH
55523: LD_VAR 0 10
55527: PPUSH
55528: LD_INT 1
55530: PPUSH
55531: CALL_OW 3
55535: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
55536: LD_VAR 0 2
55540: PPUSH
55541: LD_VAR 0 5
55545: PPUSH
55546: CALL 55855 0 2
55550: PUSH
55551: LD_VAR 0 10
55555: PUSH
55556: EMPTY
55557: EQUAL
55558: OR
55559: IFFALSE 55504
// result := [ ] ;
55561: LD_ADDR_VAR 0 6
55565: PUSH
55566: EMPTY
55567: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55568: LD_VAR 0 1
55572: PPUSH
55573: LD_VAR 0 2
55577: PPUSH
55578: LD_VAR 0 3
55582: PPUSH
55583: LD_VAR 0 4
55587: PPUSH
55588: LD_VAR 0 5
55592: PPUSH
55593: CALL_OW 448
55597: IFFALSE 55630
// result := [ chassis , engine , control , weapon ] ;
55599: LD_ADDR_VAR 0 6
55603: PUSH
55604: LD_VAR 0 2
55608: PUSH
55609: LD_VAR 0 3
55613: PUSH
55614: LD_VAR 0 4
55618: PUSH
55619: LD_VAR 0 5
55623: PUSH
55624: EMPTY
55625: LIST
55626: LIST
55627: LIST
55628: LIST
55629: ST_TO_ADDR
// end ;
55630: LD_VAR 0 6
55634: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
55635: LD_INT 0
55637: PPUSH
// if not chassis or not engine then
55638: LD_VAR 0 1
55642: NOT
55643: PUSH
55644: LD_VAR 0 2
55648: NOT
55649: OR
55650: IFFALSE 55654
// exit ;
55652: GO 55850
// case engine of engine_solar :
55654: LD_VAR 0 2
55658: PUSH
55659: LD_INT 2
55661: DOUBLE
55662: EQUAL
55663: IFTRUE 55667
55665: GO 55705
55667: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
55668: LD_ADDR_VAR 0 3
55672: PUSH
55673: LD_INT 11
55675: PUSH
55676: LD_INT 12
55678: PUSH
55679: LD_INT 13
55681: PUSH
55682: LD_INT 14
55684: PUSH
55685: LD_INT 1
55687: PUSH
55688: LD_INT 2
55690: PUSH
55691: LD_INT 3
55693: PUSH
55694: EMPTY
55695: LIST
55696: LIST
55697: LIST
55698: LIST
55699: LIST
55700: LIST
55701: LIST
55702: ST_TO_ADDR
55703: GO 55834
55705: LD_INT 1
55707: DOUBLE
55708: EQUAL
55709: IFTRUE 55713
55711: GO 55775
55713: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
55714: LD_ADDR_VAR 0 3
55718: PUSH
55719: LD_INT 11
55721: PUSH
55722: LD_INT 12
55724: PUSH
55725: LD_INT 13
55727: PUSH
55728: LD_INT 14
55730: PUSH
55731: LD_INT 1
55733: PUSH
55734: LD_INT 2
55736: PUSH
55737: LD_INT 3
55739: PUSH
55740: LD_INT 4
55742: PUSH
55743: LD_INT 5
55745: PUSH
55746: LD_INT 21
55748: PUSH
55749: LD_INT 23
55751: PUSH
55752: LD_INT 22
55754: PUSH
55755: LD_INT 24
55757: PUSH
55758: EMPTY
55759: LIST
55760: LIST
55761: LIST
55762: LIST
55763: LIST
55764: LIST
55765: LIST
55766: LIST
55767: LIST
55768: LIST
55769: LIST
55770: LIST
55771: LIST
55772: ST_TO_ADDR
55773: GO 55834
55775: LD_INT 3
55777: DOUBLE
55778: EQUAL
55779: IFTRUE 55783
55781: GO 55833
55783: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
55784: LD_ADDR_VAR 0 3
55788: PUSH
55789: LD_INT 13
55791: PUSH
55792: LD_INT 14
55794: PUSH
55795: LD_INT 2
55797: PUSH
55798: LD_INT 3
55800: PUSH
55801: LD_INT 4
55803: PUSH
55804: LD_INT 5
55806: PUSH
55807: LD_INT 21
55809: PUSH
55810: LD_INT 22
55812: PUSH
55813: LD_INT 23
55815: PUSH
55816: LD_INT 24
55818: PUSH
55819: EMPTY
55820: LIST
55821: LIST
55822: LIST
55823: LIST
55824: LIST
55825: LIST
55826: LIST
55827: LIST
55828: LIST
55829: LIST
55830: ST_TO_ADDR
55831: GO 55834
55833: POP
// result := ( chassis in result ) ;
55834: LD_ADDR_VAR 0 3
55838: PUSH
55839: LD_VAR 0 1
55843: PUSH
55844: LD_VAR 0 3
55848: IN
55849: ST_TO_ADDR
// end ;
55850: LD_VAR 0 3
55854: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
55855: LD_INT 0
55857: PPUSH
// if not chassis or not weapon then
55858: LD_VAR 0 1
55862: NOT
55863: PUSH
55864: LD_VAR 0 2
55868: NOT
55869: OR
55870: IFFALSE 55874
// exit ;
55872: GO 56900
// case weapon of us_machine_gun :
55874: LD_VAR 0 2
55878: PUSH
55879: LD_INT 2
55881: DOUBLE
55882: EQUAL
55883: IFTRUE 55887
55885: GO 55917
55887: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
55888: LD_ADDR_VAR 0 3
55892: PUSH
55893: LD_INT 1
55895: PUSH
55896: LD_INT 2
55898: PUSH
55899: LD_INT 3
55901: PUSH
55902: LD_INT 4
55904: PUSH
55905: LD_INT 5
55907: PUSH
55908: EMPTY
55909: LIST
55910: LIST
55911: LIST
55912: LIST
55913: LIST
55914: ST_TO_ADDR
55915: GO 56884
55917: LD_INT 3
55919: DOUBLE
55920: EQUAL
55921: IFTRUE 55925
55923: GO 55955
55925: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
55926: LD_ADDR_VAR 0 3
55930: PUSH
55931: LD_INT 1
55933: PUSH
55934: LD_INT 2
55936: PUSH
55937: LD_INT 3
55939: PUSH
55940: LD_INT 4
55942: PUSH
55943: LD_INT 5
55945: PUSH
55946: EMPTY
55947: LIST
55948: LIST
55949: LIST
55950: LIST
55951: LIST
55952: ST_TO_ADDR
55953: GO 56884
55955: LD_INT 11
55957: DOUBLE
55958: EQUAL
55959: IFTRUE 55963
55961: GO 55993
55963: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
55964: LD_ADDR_VAR 0 3
55968: PUSH
55969: LD_INT 1
55971: PUSH
55972: LD_INT 2
55974: PUSH
55975: LD_INT 3
55977: PUSH
55978: LD_INT 4
55980: PUSH
55981: LD_INT 5
55983: PUSH
55984: EMPTY
55985: LIST
55986: LIST
55987: LIST
55988: LIST
55989: LIST
55990: ST_TO_ADDR
55991: GO 56884
55993: LD_INT 4
55995: DOUBLE
55996: EQUAL
55997: IFTRUE 56001
55999: GO 56027
56001: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
56002: LD_ADDR_VAR 0 3
56006: PUSH
56007: LD_INT 2
56009: PUSH
56010: LD_INT 3
56012: PUSH
56013: LD_INT 4
56015: PUSH
56016: LD_INT 5
56018: PUSH
56019: EMPTY
56020: LIST
56021: LIST
56022: LIST
56023: LIST
56024: ST_TO_ADDR
56025: GO 56884
56027: LD_INT 5
56029: DOUBLE
56030: EQUAL
56031: IFTRUE 56035
56033: GO 56061
56035: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
56036: LD_ADDR_VAR 0 3
56040: PUSH
56041: LD_INT 2
56043: PUSH
56044: LD_INT 3
56046: PUSH
56047: LD_INT 4
56049: PUSH
56050: LD_INT 5
56052: PUSH
56053: EMPTY
56054: LIST
56055: LIST
56056: LIST
56057: LIST
56058: ST_TO_ADDR
56059: GO 56884
56061: LD_INT 9
56063: DOUBLE
56064: EQUAL
56065: IFTRUE 56069
56067: GO 56095
56069: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
56070: LD_ADDR_VAR 0 3
56074: PUSH
56075: LD_INT 2
56077: PUSH
56078: LD_INT 3
56080: PUSH
56081: LD_INT 4
56083: PUSH
56084: LD_INT 5
56086: PUSH
56087: EMPTY
56088: LIST
56089: LIST
56090: LIST
56091: LIST
56092: ST_TO_ADDR
56093: GO 56884
56095: LD_INT 7
56097: DOUBLE
56098: EQUAL
56099: IFTRUE 56103
56101: GO 56129
56103: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
56104: LD_ADDR_VAR 0 3
56108: PUSH
56109: LD_INT 2
56111: PUSH
56112: LD_INT 3
56114: PUSH
56115: LD_INT 4
56117: PUSH
56118: LD_INT 5
56120: PUSH
56121: EMPTY
56122: LIST
56123: LIST
56124: LIST
56125: LIST
56126: ST_TO_ADDR
56127: GO 56884
56129: LD_INT 12
56131: DOUBLE
56132: EQUAL
56133: IFTRUE 56137
56135: GO 56163
56137: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
56138: LD_ADDR_VAR 0 3
56142: PUSH
56143: LD_INT 2
56145: PUSH
56146: LD_INT 3
56148: PUSH
56149: LD_INT 4
56151: PUSH
56152: LD_INT 5
56154: PUSH
56155: EMPTY
56156: LIST
56157: LIST
56158: LIST
56159: LIST
56160: ST_TO_ADDR
56161: GO 56884
56163: LD_INT 13
56165: DOUBLE
56166: EQUAL
56167: IFTRUE 56171
56169: GO 56197
56171: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
56172: LD_ADDR_VAR 0 3
56176: PUSH
56177: LD_INT 2
56179: PUSH
56180: LD_INT 3
56182: PUSH
56183: LD_INT 4
56185: PUSH
56186: LD_INT 5
56188: PUSH
56189: EMPTY
56190: LIST
56191: LIST
56192: LIST
56193: LIST
56194: ST_TO_ADDR
56195: GO 56884
56197: LD_INT 14
56199: DOUBLE
56200: EQUAL
56201: IFTRUE 56205
56203: GO 56223
56205: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
56206: LD_ADDR_VAR 0 3
56210: PUSH
56211: LD_INT 4
56213: PUSH
56214: LD_INT 5
56216: PUSH
56217: EMPTY
56218: LIST
56219: LIST
56220: ST_TO_ADDR
56221: GO 56884
56223: LD_INT 6
56225: DOUBLE
56226: EQUAL
56227: IFTRUE 56231
56229: GO 56249
56231: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
56232: LD_ADDR_VAR 0 3
56236: PUSH
56237: LD_INT 4
56239: PUSH
56240: LD_INT 5
56242: PUSH
56243: EMPTY
56244: LIST
56245: LIST
56246: ST_TO_ADDR
56247: GO 56884
56249: LD_INT 10
56251: DOUBLE
56252: EQUAL
56253: IFTRUE 56257
56255: GO 56275
56257: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
56258: LD_ADDR_VAR 0 3
56262: PUSH
56263: LD_INT 4
56265: PUSH
56266: LD_INT 5
56268: PUSH
56269: EMPTY
56270: LIST
56271: LIST
56272: ST_TO_ADDR
56273: GO 56884
56275: LD_INT 22
56277: DOUBLE
56278: EQUAL
56279: IFTRUE 56283
56281: GO 56309
56283: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
56284: LD_ADDR_VAR 0 3
56288: PUSH
56289: LD_INT 11
56291: PUSH
56292: LD_INT 12
56294: PUSH
56295: LD_INT 13
56297: PUSH
56298: LD_INT 14
56300: PUSH
56301: EMPTY
56302: LIST
56303: LIST
56304: LIST
56305: LIST
56306: ST_TO_ADDR
56307: GO 56884
56309: LD_INT 23
56311: DOUBLE
56312: EQUAL
56313: IFTRUE 56317
56315: GO 56343
56317: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
56318: LD_ADDR_VAR 0 3
56322: PUSH
56323: LD_INT 11
56325: PUSH
56326: LD_INT 12
56328: PUSH
56329: LD_INT 13
56331: PUSH
56332: LD_INT 14
56334: PUSH
56335: EMPTY
56336: LIST
56337: LIST
56338: LIST
56339: LIST
56340: ST_TO_ADDR
56341: GO 56884
56343: LD_INT 24
56345: DOUBLE
56346: EQUAL
56347: IFTRUE 56351
56349: GO 56377
56351: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
56352: LD_ADDR_VAR 0 3
56356: PUSH
56357: LD_INT 11
56359: PUSH
56360: LD_INT 12
56362: PUSH
56363: LD_INT 13
56365: PUSH
56366: LD_INT 14
56368: PUSH
56369: EMPTY
56370: LIST
56371: LIST
56372: LIST
56373: LIST
56374: ST_TO_ADDR
56375: GO 56884
56377: LD_INT 30
56379: DOUBLE
56380: EQUAL
56381: IFTRUE 56385
56383: GO 56411
56385: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
56386: LD_ADDR_VAR 0 3
56390: PUSH
56391: LD_INT 11
56393: PUSH
56394: LD_INT 12
56396: PUSH
56397: LD_INT 13
56399: PUSH
56400: LD_INT 14
56402: PUSH
56403: EMPTY
56404: LIST
56405: LIST
56406: LIST
56407: LIST
56408: ST_TO_ADDR
56409: GO 56884
56411: LD_INT 25
56413: DOUBLE
56414: EQUAL
56415: IFTRUE 56419
56417: GO 56437
56419: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
56420: LD_ADDR_VAR 0 3
56424: PUSH
56425: LD_INT 13
56427: PUSH
56428: LD_INT 14
56430: PUSH
56431: EMPTY
56432: LIST
56433: LIST
56434: ST_TO_ADDR
56435: GO 56884
56437: LD_INT 27
56439: DOUBLE
56440: EQUAL
56441: IFTRUE 56445
56443: GO 56463
56445: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
56446: LD_ADDR_VAR 0 3
56450: PUSH
56451: LD_INT 13
56453: PUSH
56454: LD_INT 14
56456: PUSH
56457: EMPTY
56458: LIST
56459: LIST
56460: ST_TO_ADDR
56461: GO 56884
56463: LD_INT 28
56465: DOUBLE
56466: EQUAL
56467: IFTRUE 56471
56469: GO 56489
56471: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
56472: LD_ADDR_VAR 0 3
56476: PUSH
56477: LD_INT 13
56479: PUSH
56480: LD_INT 14
56482: PUSH
56483: EMPTY
56484: LIST
56485: LIST
56486: ST_TO_ADDR
56487: GO 56884
56489: LD_INT 29
56491: DOUBLE
56492: EQUAL
56493: IFTRUE 56497
56495: GO 56515
56497: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
56498: LD_ADDR_VAR 0 3
56502: PUSH
56503: LD_INT 13
56505: PUSH
56506: LD_INT 14
56508: PUSH
56509: EMPTY
56510: LIST
56511: LIST
56512: ST_TO_ADDR
56513: GO 56884
56515: LD_INT 31
56517: DOUBLE
56518: EQUAL
56519: IFTRUE 56523
56521: GO 56541
56523: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
56524: LD_ADDR_VAR 0 3
56528: PUSH
56529: LD_INT 13
56531: PUSH
56532: LD_INT 14
56534: PUSH
56535: EMPTY
56536: LIST
56537: LIST
56538: ST_TO_ADDR
56539: GO 56884
56541: LD_INT 26
56543: DOUBLE
56544: EQUAL
56545: IFTRUE 56549
56547: GO 56567
56549: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
56550: LD_ADDR_VAR 0 3
56554: PUSH
56555: LD_INT 13
56557: PUSH
56558: LD_INT 14
56560: PUSH
56561: EMPTY
56562: LIST
56563: LIST
56564: ST_TO_ADDR
56565: GO 56884
56567: LD_INT 42
56569: DOUBLE
56570: EQUAL
56571: IFTRUE 56575
56573: GO 56601
56575: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
56576: LD_ADDR_VAR 0 3
56580: PUSH
56581: LD_INT 21
56583: PUSH
56584: LD_INT 22
56586: PUSH
56587: LD_INT 23
56589: PUSH
56590: LD_INT 24
56592: PUSH
56593: EMPTY
56594: LIST
56595: LIST
56596: LIST
56597: LIST
56598: ST_TO_ADDR
56599: GO 56884
56601: LD_INT 43
56603: DOUBLE
56604: EQUAL
56605: IFTRUE 56609
56607: GO 56635
56609: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
56610: LD_ADDR_VAR 0 3
56614: PUSH
56615: LD_INT 21
56617: PUSH
56618: LD_INT 22
56620: PUSH
56621: LD_INT 23
56623: PUSH
56624: LD_INT 24
56626: PUSH
56627: EMPTY
56628: LIST
56629: LIST
56630: LIST
56631: LIST
56632: ST_TO_ADDR
56633: GO 56884
56635: LD_INT 44
56637: DOUBLE
56638: EQUAL
56639: IFTRUE 56643
56641: GO 56669
56643: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
56644: LD_ADDR_VAR 0 3
56648: PUSH
56649: LD_INT 21
56651: PUSH
56652: LD_INT 22
56654: PUSH
56655: LD_INT 23
56657: PUSH
56658: LD_INT 24
56660: PUSH
56661: EMPTY
56662: LIST
56663: LIST
56664: LIST
56665: LIST
56666: ST_TO_ADDR
56667: GO 56884
56669: LD_INT 45
56671: DOUBLE
56672: EQUAL
56673: IFTRUE 56677
56675: GO 56703
56677: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
56678: LD_ADDR_VAR 0 3
56682: PUSH
56683: LD_INT 21
56685: PUSH
56686: LD_INT 22
56688: PUSH
56689: LD_INT 23
56691: PUSH
56692: LD_INT 24
56694: PUSH
56695: EMPTY
56696: LIST
56697: LIST
56698: LIST
56699: LIST
56700: ST_TO_ADDR
56701: GO 56884
56703: LD_INT 49
56705: DOUBLE
56706: EQUAL
56707: IFTRUE 56711
56709: GO 56737
56711: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
56712: LD_ADDR_VAR 0 3
56716: PUSH
56717: LD_INT 21
56719: PUSH
56720: LD_INT 22
56722: PUSH
56723: LD_INT 23
56725: PUSH
56726: LD_INT 24
56728: PUSH
56729: EMPTY
56730: LIST
56731: LIST
56732: LIST
56733: LIST
56734: ST_TO_ADDR
56735: GO 56884
56737: LD_INT 51
56739: DOUBLE
56740: EQUAL
56741: IFTRUE 56745
56743: GO 56771
56745: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
56746: LD_ADDR_VAR 0 3
56750: PUSH
56751: LD_INT 21
56753: PUSH
56754: LD_INT 22
56756: PUSH
56757: LD_INT 23
56759: PUSH
56760: LD_INT 24
56762: PUSH
56763: EMPTY
56764: LIST
56765: LIST
56766: LIST
56767: LIST
56768: ST_TO_ADDR
56769: GO 56884
56771: LD_INT 52
56773: DOUBLE
56774: EQUAL
56775: IFTRUE 56779
56777: GO 56805
56779: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
56780: LD_ADDR_VAR 0 3
56784: PUSH
56785: LD_INT 21
56787: PUSH
56788: LD_INT 22
56790: PUSH
56791: LD_INT 23
56793: PUSH
56794: LD_INT 24
56796: PUSH
56797: EMPTY
56798: LIST
56799: LIST
56800: LIST
56801: LIST
56802: ST_TO_ADDR
56803: GO 56884
56805: LD_INT 53
56807: DOUBLE
56808: EQUAL
56809: IFTRUE 56813
56811: GO 56831
56813: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
56814: LD_ADDR_VAR 0 3
56818: PUSH
56819: LD_INT 23
56821: PUSH
56822: LD_INT 24
56824: PUSH
56825: EMPTY
56826: LIST
56827: LIST
56828: ST_TO_ADDR
56829: GO 56884
56831: LD_INT 46
56833: DOUBLE
56834: EQUAL
56835: IFTRUE 56839
56837: GO 56857
56839: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
56840: LD_ADDR_VAR 0 3
56844: PUSH
56845: LD_INT 23
56847: PUSH
56848: LD_INT 24
56850: PUSH
56851: EMPTY
56852: LIST
56853: LIST
56854: ST_TO_ADDR
56855: GO 56884
56857: LD_INT 47
56859: DOUBLE
56860: EQUAL
56861: IFTRUE 56865
56863: GO 56883
56865: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
56866: LD_ADDR_VAR 0 3
56870: PUSH
56871: LD_INT 23
56873: PUSH
56874: LD_INT 24
56876: PUSH
56877: EMPTY
56878: LIST
56879: LIST
56880: ST_TO_ADDR
56881: GO 56884
56883: POP
// result := ( chassis in result ) ;
56884: LD_ADDR_VAR 0 3
56888: PUSH
56889: LD_VAR 0 1
56893: PUSH
56894: LD_VAR 0 3
56898: IN
56899: ST_TO_ADDR
// end ;
56900: LD_VAR 0 3
56904: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
56905: LD_INT 0
56907: PPUSH
56908: PPUSH
56909: PPUSH
56910: PPUSH
56911: PPUSH
56912: PPUSH
56913: PPUSH
// result := array ;
56914: LD_ADDR_VAR 0 5
56918: PUSH
56919: LD_VAR 0 1
56923: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
56924: LD_VAR 0 1
56928: NOT
56929: PUSH
56930: LD_VAR 0 2
56934: NOT
56935: OR
56936: PUSH
56937: LD_VAR 0 3
56941: NOT
56942: OR
56943: PUSH
56944: LD_VAR 0 2
56948: PUSH
56949: LD_VAR 0 1
56953: GREATER
56954: OR
56955: PUSH
56956: LD_VAR 0 3
56960: PUSH
56961: LD_VAR 0 1
56965: GREATER
56966: OR
56967: IFFALSE 56971
// exit ;
56969: GO 57267
// if direction then
56971: LD_VAR 0 4
56975: IFFALSE 57039
// begin d := 1 ;
56977: LD_ADDR_VAR 0 9
56981: PUSH
56982: LD_INT 1
56984: ST_TO_ADDR
// if i_from > i_to then
56985: LD_VAR 0 2
56989: PUSH
56990: LD_VAR 0 3
56994: GREATER
56995: IFFALSE 57021
// length := ( array - i_from ) + i_to else
56997: LD_ADDR_VAR 0 11
57001: PUSH
57002: LD_VAR 0 1
57006: PUSH
57007: LD_VAR 0 2
57011: MINUS
57012: PUSH
57013: LD_VAR 0 3
57017: PLUS
57018: ST_TO_ADDR
57019: GO 57037
// length := i_to - i_from ;
57021: LD_ADDR_VAR 0 11
57025: PUSH
57026: LD_VAR 0 3
57030: PUSH
57031: LD_VAR 0 2
57035: MINUS
57036: ST_TO_ADDR
// end else
57037: GO 57100
// begin d := - 1 ;
57039: LD_ADDR_VAR 0 9
57043: PUSH
57044: LD_INT 1
57046: NEG
57047: ST_TO_ADDR
// if i_from > i_to then
57048: LD_VAR 0 2
57052: PUSH
57053: LD_VAR 0 3
57057: GREATER
57058: IFFALSE 57078
// length := i_from - i_to else
57060: LD_ADDR_VAR 0 11
57064: PUSH
57065: LD_VAR 0 2
57069: PUSH
57070: LD_VAR 0 3
57074: MINUS
57075: ST_TO_ADDR
57076: GO 57100
// length := ( array - i_to ) + i_from ;
57078: LD_ADDR_VAR 0 11
57082: PUSH
57083: LD_VAR 0 1
57087: PUSH
57088: LD_VAR 0 3
57092: MINUS
57093: PUSH
57094: LD_VAR 0 2
57098: PLUS
57099: ST_TO_ADDR
// end ; if not length then
57100: LD_VAR 0 11
57104: NOT
57105: IFFALSE 57109
// exit ;
57107: GO 57267
// tmp := array ;
57109: LD_ADDR_VAR 0 10
57113: PUSH
57114: LD_VAR 0 1
57118: ST_TO_ADDR
// for i = 1 to length do
57119: LD_ADDR_VAR 0 6
57123: PUSH
57124: DOUBLE
57125: LD_INT 1
57127: DEC
57128: ST_TO_ADDR
57129: LD_VAR 0 11
57133: PUSH
57134: FOR_TO
57135: IFFALSE 57255
// begin for j = 1 to array do
57137: LD_ADDR_VAR 0 7
57141: PUSH
57142: DOUBLE
57143: LD_INT 1
57145: DEC
57146: ST_TO_ADDR
57147: LD_VAR 0 1
57151: PUSH
57152: FOR_TO
57153: IFFALSE 57241
// begin k := j + d ;
57155: LD_ADDR_VAR 0 8
57159: PUSH
57160: LD_VAR 0 7
57164: PUSH
57165: LD_VAR 0 9
57169: PLUS
57170: ST_TO_ADDR
// if k > array then
57171: LD_VAR 0 8
57175: PUSH
57176: LD_VAR 0 1
57180: GREATER
57181: IFFALSE 57191
// k := 1 ;
57183: LD_ADDR_VAR 0 8
57187: PUSH
57188: LD_INT 1
57190: ST_TO_ADDR
// if not k then
57191: LD_VAR 0 8
57195: NOT
57196: IFFALSE 57208
// k := array ;
57198: LD_ADDR_VAR 0 8
57202: PUSH
57203: LD_VAR 0 1
57207: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
57208: LD_ADDR_VAR 0 10
57212: PUSH
57213: LD_VAR 0 10
57217: PPUSH
57218: LD_VAR 0 8
57222: PPUSH
57223: LD_VAR 0 1
57227: PUSH
57228: LD_VAR 0 7
57232: ARRAY
57233: PPUSH
57234: CALL_OW 1
57238: ST_TO_ADDR
// end ;
57239: GO 57152
57241: POP
57242: POP
// array := tmp ;
57243: LD_ADDR_VAR 0 1
57247: PUSH
57248: LD_VAR 0 10
57252: ST_TO_ADDR
// end ;
57253: GO 57134
57255: POP
57256: POP
// result := array ;
57257: LD_ADDR_VAR 0 5
57261: PUSH
57262: LD_VAR 0 1
57266: ST_TO_ADDR
// end ;
57267: LD_VAR 0 5
57271: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
57272: LD_INT 0
57274: PPUSH
57275: PPUSH
// result := 0 ;
57276: LD_ADDR_VAR 0 3
57280: PUSH
57281: LD_INT 0
57283: ST_TO_ADDR
// if not array or not value in array then
57284: LD_VAR 0 1
57288: NOT
57289: PUSH
57290: LD_VAR 0 2
57294: PUSH
57295: LD_VAR 0 1
57299: IN
57300: NOT
57301: OR
57302: IFFALSE 57306
// exit ;
57304: GO 57360
// for i = 1 to array do
57306: LD_ADDR_VAR 0 4
57310: PUSH
57311: DOUBLE
57312: LD_INT 1
57314: DEC
57315: ST_TO_ADDR
57316: LD_VAR 0 1
57320: PUSH
57321: FOR_TO
57322: IFFALSE 57358
// if value = array [ i ] then
57324: LD_VAR 0 2
57328: PUSH
57329: LD_VAR 0 1
57333: PUSH
57334: LD_VAR 0 4
57338: ARRAY
57339: EQUAL
57340: IFFALSE 57356
// begin result := i ;
57342: LD_ADDR_VAR 0 3
57346: PUSH
57347: LD_VAR 0 4
57351: ST_TO_ADDR
// exit ;
57352: POP
57353: POP
57354: GO 57360
// end ;
57356: GO 57321
57358: POP
57359: POP
// end ;
57360: LD_VAR 0 3
57364: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
57365: LD_INT 0
57367: PPUSH
// vc_chassis := chassis ;
57368: LD_ADDR_OWVAR 37
57372: PUSH
57373: LD_VAR 0 1
57377: ST_TO_ADDR
// vc_engine := engine ;
57378: LD_ADDR_OWVAR 39
57382: PUSH
57383: LD_VAR 0 2
57387: ST_TO_ADDR
// vc_control := control ;
57388: LD_ADDR_OWVAR 38
57392: PUSH
57393: LD_VAR 0 3
57397: ST_TO_ADDR
// vc_weapon := weapon ;
57398: LD_ADDR_OWVAR 40
57402: PUSH
57403: LD_VAR 0 4
57407: ST_TO_ADDR
// vc_fuel_battery := fuel ;
57408: LD_ADDR_OWVAR 41
57412: PUSH
57413: LD_VAR 0 5
57417: ST_TO_ADDR
// end ;
57418: LD_VAR 0 6
57422: RET
// export function WantPlant ( unit ) ; var task ; begin
57423: LD_INT 0
57425: PPUSH
57426: PPUSH
// result := false ;
57427: LD_ADDR_VAR 0 2
57431: PUSH
57432: LD_INT 0
57434: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
57435: LD_ADDR_VAR 0 3
57439: PUSH
57440: LD_VAR 0 1
57444: PPUSH
57445: CALL_OW 437
57449: ST_TO_ADDR
// if task then
57450: LD_VAR 0 3
57454: IFFALSE 57482
// if task [ 1 ] [ 1 ] = p then
57456: LD_VAR 0 3
57460: PUSH
57461: LD_INT 1
57463: ARRAY
57464: PUSH
57465: LD_INT 1
57467: ARRAY
57468: PUSH
57469: LD_STRING p
57471: EQUAL
57472: IFFALSE 57482
// result := true ;
57474: LD_ADDR_VAR 0 2
57478: PUSH
57479: LD_INT 1
57481: ST_TO_ADDR
// end ;
57482: LD_VAR 0 2
57486: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
57487: LD_INT 0
57489: PPUSH
57490: PPUSH
57491: PPUSH
57492: PPUSH
// if pos < 1 then
57493: LD_VAR 0 2
57497: PUSH
57498: LD_INT 1
57500: LESS
57501: IFFALSE 57505
// exit ;
57503: GO 57808
// if pos = 1 then
57505: LD_VAR 0 2
57509: PUSH
57510: LD_INT 1
57512: EQUAL
57513: IFFALSE 57546
// result := Replace ( arr , pos [ 1 ] , value ) else
57515: LD_ADDR_VAR 0 4
57519: PUSH
57520: LD_VAR 0 1
57524: PPUSH
57525: LD_VAR 0 2
57529: PUSH
57530: LD_INT 1
57532: ARRAY
57533: PPUSH
57534: LD_VAR 0 3
57538: PPUSH
57539: CALL_OW 1
57543: ST_TO_ADDR
57544: GO 57808
// begin tmp := arr ;
57546: LD_ADDR_VAR 0 6
57550: PUSH
57551: LD_VAR 0 1
57555: ST_TO_ADDR
// s_arr := [ tmp ] ;
57556: LD_ADDR_VAR 0 7
57560: PUSH
57561: LD_VAR 0 6
57565: PUSH
57566: EMPTY
57567: LIST
57568: ST_TO_ADDR
// for i = 1 to pos - 1 do
57569: LD_ADDR_VAR 0 5
57573: PUSH
57574: DOUBLE
57575: LD_INT 1
57577: DEC
57578: ST_TO_ADDR
57579: LD_VAR 0 2
57583: PUSH
57584: LD_INT 1
57586: MINUS
57587: PUSH
57588: FOR_TO
57589: IFFALSE 57634
// begin tmp := tmp [ pos [ i ] ] ;
57591: LD_ADDR_VAR 0 6
57595: PUSH
57596: LD_VAR 0 6
57600: PUSH
57601: LD_VAR 0 2
57605: PUSH
57606: LD_VAR 0 5
57610: ARRAY
57611: ARRAY
57612: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
57613: LD_ADDR_VAR 0 7
57617: PUSH
57618: LD_VAR 0 7
57622: PUSH
57623: LD_VAR 0 6
57627: PUSH
57628: EMPTY
57629: LIST
57630: ADD
57631: ST_TO_ADDR
// end ;
57632: GO 57588
57634: POP
57635: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
57636: LD_ADDR_VAR 0 6
57640: PUSH
57641: LD_VAR 0 6
57645: PPUSH
57646: LD_VAR 0 2
57650: PUSH
57651: LD_VAR 0 2
57655: ARRAY
57656: PPUSH
57657: LD_VAR 0 3
57661: PPUSH
57662: CALL_OW 1
57666: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
57667: LD_ADDR_VAR 0 7
57671: PUSH
57672: LD_VAR 0 7
57676: PPUSH
57677: LD_VAR 0 7
57681: PPUSH
57682: LD_VAR 0 6
57686: PPUSH
57687: CALL_OW 1
57691: ST_TO_ADDR
// for i = s_arr downto 2 do
57692: LD_ADDR_VAR 0 5
57696: PUSH
57697: DOUBLE
57698: LD_VAR 0 7
57702: INC
57703: ST_TO_ADDR
57704: LD_INT 2
57706: PUSH
57707: FOR_DOWNTO
57708: IFFALSE 57792
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
57710: LD_ADDR_VAR 0 6
57714: PUSH
57715: LD_VAR 0 7
57719: PUSH
57720: LD_VAR 0 5
57724: PUSH
57725: LD_INT 1
57727: MINUS
57728: ARRAY
57729: PPUSH
57730: LD_VAR 0 2
57734: PUSH
57735: LD_VAR 0 5
57739: PUSH
57740: LD_INT 1
57742: MINUS
57743: ARRAY
57744: PPUSH
57745: LD_VAR 0 7
57749: PUSH
57750: LD_VAR 0 5
57754: ARRAY
57755: PPUSH
57756: CALL_OW 1
57760: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
57761: LD_ADDR_VAR 0 7
57765: PUSH
57766: LD_VAR 0 7
57770: PPUSH
57771: LD_VAR 0 5
57775: PUSH
57776: LD_INT 1
57778: MINUS
57779: PPUSH
57780: LD_VAR 0 6
57784: PPUSH
57785: CALL_OW 1
57789: ST_TO_ADDR
// end ;
57790: GO 57707
57792: POP
57793: POP
// result := s_arr [ 1 ] ;
57794: LD_ADDR_VAR 0 4
57798: PUSH
57799: LD_VAR 0 7
57803: PUSH
57804: LD_INT 1
57806: ARRAY
57807: ST_TO_ADDR
// end ; end ;
57808: LD_VAR 0 4
57812: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
57813: LD_INT 0
57815: PPUSH
57816: PPUSH
// if not list then
57817: LD_VAR 0 1
57821: NOT
57822: IFFALSE 57826
// exit ;
57824: GO 57917
// i := list [ pos1 ] ;
57826: LD_ADDR_VAR 0 5
57830: PUSH
57831: LD_VAR 0 1
57835: PUSH
57836: LD_VAR 0 2
57840: ARRAY
57841: ST_TO_ADDR
// if not i then
57842: LD_VAR 0 5
57846: NOT
57847: IFFALSE 57851
// exit ;
57849: GO 57917
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
57851: LD_ADDR_VAR 0 1
57855: PUSH
57856: LD_VAR 0 1
57860: PPUSH
57861: LD_VAR 0 2
57865: PPUSH
57866: LD_VAR 0 1
57870: PUSH
57871: LD_VAR 0 3
57875: ARRAY
57876: PPUSH
57877: CALL_OW 1
57881: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
57882: LD_ADDR_VAR 0 1
57886: PUSH
57887: LD_VAR 0 1
57891: PPUSH
57892: LD_VAR 0 3
57896: PPUSH
57897: LD_VAR 0 5
57901: PPUSH
57902: CALL_OW 1
57906: ST_TO_ADDR
// result := list ;
57907: LD_ADDR_VAR 0 4
57911: PUSH
57912: LD_VAR 0 1
57916: ST_TO_ADDR
// end ;
57917: LD_VAR 0 4
57921: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
57922: LD_INT 0
57924: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
57925: LD_ADDR_VAR 0 5
57929: PUSH
57930: LD_VAR 0 1
57934: PPUSH
57935: CALL_OW 250
57939: PPUSH
57940: LD_VAR 0 1
57944: PPUSH
57945: CALL_OW 251
57949: PPUSH
57950: LD_VAR 0 2
57954: PPUSH
57955: LD_VAR 0 3
57959: PPUSH
57960: LD_VAR 0 4
57964: PPUSH
57965: CALL 57975 0 5
57969: ST_TO_ADDR
// end ;
57970: LD_VAR 0 5
57974: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
57975: LD_INT 0
57977: PPUSH
57978: PPUSH
57979: PPUSH
57980: PPUSH
// if not list then
57981: LD_VAR 0 3
57985: NOT
57986: IFFALSE 57990
// exit ;
57988: GO 58378
// result := [ ] ;
57990: LD_ADDR_VAR 0 6
57994: PUSH
57995: EMPTY
57996: ST_TO_ADDR
// for i in list do
57997: LD_ADDR_VAR 0 7
58001: PUSH
58002: LD_VAR 0 3
58006: PUSH
58007: FOR_IN
58008: IFFALSE 58210
// begin tmp := GetDistUnitXY ( i , x , y ) ;
58010: LD_ADDR_VAR 0 9
58014: PUSH
58015: LD_VAR 0 7
58019: PPUSH
58020: LD_VAR 0 1
58024: PPUSH
58025: LD_VAR 0 2
58029: PPUSH
58030: CALL_OW 297
58034: ST_TO_ADDR
// if not result then
58035: LD_VAR 0 6
58039: NOT
58040: IFFALSE 58066
// result := [ [ i , tmp ] ] else
58042: LD_ADDR_VAR 0 6
58046: PUSH
58047: LD_VAR 0 7
58051: PUSH
58052: LD_VAR 0 9
58056: PUSH
58057: EMPTY
58058: LIST
58059: LIST
58060: PUSH
58061: EMPTY
58062: LIST
58063: ST_TO_ADDR
58064: GO 58208
// begin if result [ result ] [ 2 ] < tmp then
58066: LD_VAR 0 6
58070: PUSH
58071: LD_VAR 0 6
58075: ARRAY
58076: PUSH
58077: LD_INT 2
58079: ARRAY
58080: PUSH
58081: LD_VAR 0 9
58085: LESS
58086: IFFALSE 58128
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
58088: LD_ADDR_VAR 0 6
58092: PUSH
58093: LD_VAR 0 6
58097: PPUSH
58098: LD_VAR 0 6
58102: PUSH
58103: LD_INT 1
58105: PLUS
58106: PPUSH
58107: LD_VAR 0 7
58111: PUSH
58112: LD_VAR 0 9
58116: PUSH
58117: EMPTY
58118: LIST
58119: LIST
58120: PPUSH
58121: CALL_OW 2
58125: ST_TO_ADDR
58126: GO 58208
// for j = 1 to result do
58128: LD_ADDR_VAR 0 8
58132: PUSH
58133: DOUBLE
58134: LD_INT 1
58136: DEC
58137: ST_TO_ADDR
58138: LD_VAR 0 6
58142: PUSH
58143: FOR_TO
58144: IFFALSE 58206
// begin if tmp < result [ j ] [ 2 ] then
58146: LD_VAR 0 9
58150: PUSH
58151: LD_VAR 0 6
58155: PUSH
58156: LD_VAR 0 8
58160: ARRAY
58161: PUSH
58162: LD_INT 2
58164: ARRAY
58165: LESS
58166: IFFALSE 58204
// begin result := Insert ( result , j , [ i , tmp ] ) ;
58168: LD_ADDR_VAR 0 6
58172: PUSH
58173: LD_VAR 0 6
58177: PPUSH
58178: LD_VAR 0 8
58182: PPUSH
58183: LD_VAR 0 7
58187: PUSH
58188: LD_VAR 0 9
58192: PUSH
58193: EMPTY
58194: LIST
58195: LIST
58196: PPUSH
58197: CALL_OW 2
58201: ST_TO_ADDR
// break ;
58202: GO 58206
// end ; end ;
58204: GO 58143
58206: POP
58207: POP
// end ; end ;
58208: GO 58007
58210: POP
58211: POP
// if result and not asc then
58212: LD_VAR 0 6
58216: PUSH
58217: LD_VAR 0 4
58221: NOT
58222: AND
58223: IFFALSE 58298
// begin tmp := result ;
58225: LD_ADDR_VAR 0 9
58229: PUSH
58230: LD_VAR 0 6
58234: ST_TO_ADDR
// for i = tmp downto 1 do
58235: LD_ADDR_VAR 0 7
58239: PUSH
58240: DOUBLE
58241: LD_VAR 0 9
58245: INC
58246: ST_TO_ADDR
58247: LD_INT 1
58249: PUSH
58250: FOR_DOWNTO
58251: IFFALSE 58296
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
58253: LD_ADDR_VAR 0 6
58257: PUSH
58258: LD_VAR 0 6
58262: PPUSH
58263: LD_VAR 0 9
58267: PUSH
58268: LD_VAR 0 7
58272: MINUS
58273: PUSH
58274: LD_INT 1
58276: PLUS
58277: PPUSH
58278: LD_VAR 0 9
58282: PUSH
58283: LD_VAR 0 7
58287: ARRAY
58288: PPUSH
58289: CALL_OW 1
58293: ST_TO_ADDR
58294: GO 58250
58296: POP
58297: POP
// end ; tmp := [ ] ;
58298: LD_ADDR_VAR 0 9
58302: PUSH
58303: EMPTY
58304: ST_TO_ADDR
// if mode then
58305: LD_VAR 0 5
58309: IFFALSE 58378
// begin for i = 1 to result do
58311: LD_ADDR_VAR 0 7
58315: PUSH
58316: DOUBLE
58317: LD_INT 1
58319: DEC
58320: ST_TO_ADDR
58321: LD_VAR 0 6
58325: PUSH
58326: FOR_TO
58327: IFFALSE 58366
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
58329: LD_ADDR_VAR 0 9
58333: PUSH
58334: LD_VAR 0 9
58338: PPUSH
58339: LD_VAR 0 7
58343: PPUSH
58344: LD_VAR 0 6
58348: PUSH
58349: LD_VAR 0 7
58353: ARRAY
58354: PUSH
58355: LD_INT 1
58357: ARRAY
58358: PPUSH
58359: CALL_OW 1
58363: ST_TO_ADDR
58364: GO 58326
58366: POP
58367: POP
// result := tmp ;
58368: LD_ADDR_VAR 0 6
58372: PUSH
58373: LD_VAR 0 9
58377: ST_TO_ADDR
// end ; end ;
58378: LD_VAR 0 6
58382: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
58383: LD_INT 0
58385: PPUSH
58386: PPUSH
58387: PPUSH
58388: PPUSH
58389: PPUSH
58390: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
58391: LD_ADDR_VAR 0 5
58395: PUSH
58396: LD_INT 0
58398: PUSH
58399: LD_INT 0
58401: PUSH
58402: LD_INT 0
58404: PUSH
58405: EMPTY
58406: PUSH
58407: EMPTY
58408: LIST
58409: LIST
58410: LIST
58411: LIST
58412: ST_TO_ADDR
// if not x or not y then
58413: LD_VAR 0 2
58417: NOT
58418: PUSH
58419: LD_VAR 0 3
58423: NOT
58424: OR
58425: IFFALSE 58429
// exit ;
58427: GO 60075
// if not range then
58429: LD_VAR 0 4
58433: NOT
58434: IFFALSE 58444
// range := 10 ;
58436: LD_ADDR_VAR 0 4
58440: PUSH
58441: LD_INT 10
58443: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
58444: LD_ADDR_VAR 0 8
58448: PUSH
58449: LD_INT 81
58451: PUSH
58452: LD_VAR 0 1
58456: PUSH
58457: EMPTY
58458: LIST
58459: LIST
58460: PUSH
58461: LD_INT 92
58463: PUSH
58464: LD_VAR 0 2
58468: PUSH
58469: LD_VAR 0 3
58473: PUSH
58474: LD_VAR 0 4
58478: PUSH
58479: EMPTY
58480: LIST
58481: LIST
58482: LIST
58483: LIST
58484: PUSH
58485: LD_INT 3
58487: PUSH
58488: LD_INT 21
58490: PUSH
58491: LD_INT 3
58493: PUSH
58494: EMPTY
58495: LIST
58496: LIST
58497: PUSH
58498: EMPTY
58499: LIST
58500: LIST
58501: PUSH
58502: EMPTY
58503: LIST
58504: LIST
58505: LIST
58506: PPUSH
58507: CALL_OW 69
58511: ST_TO_ADDR
// if not tmp then
58512: LD_VAR 0 8
58516: NOT
58517: IFFALSE 58521
// exit ;
58519: GO 60075
// for i in tmp do
58521: LD_ADDR_VAR 0 6
58525: PUSH
58526: LD_VAR 0 8
58530: PUSH
58531: FOR_IN
58532: IFFALSE 60050
// begin points := [ 0 , 0 , 0 ] ;
58534: LD_ADDR_VAR 0 9
58538: PUSH
58539: LD_INT 0
58541: PUSH
58542: LD_INT 0
58544: PUSH
58545: LD_INT 0
58547: PUSH
58548: EMPTY
58549: LIST
58550: LIST
58551: LIST
58552: ST_TO_ADDR
// bpoints := 1 ;
58553: LD_ADDR_VAR 0 10
58557: PUSH
58558: LD_INT 1
58560: ST_TO_ADDR
// case GetType ( i ) of unit_human :
58561: LD_VAR 0 6
58565: PPUSH
58566: CALL_OW 247
58570: PUSH
58571: LD_INT 1
58573: DOUBLE
58574: EQUAL
58575: IFTRUE 58579
58577: GO 59157
58579: POP
// begin if GetClass ( i ) = 1 then
58580: LD_VAR 0 6
58584: PPUSH
58585: CALL_OW 257
58589: PUSH
58590: LD_INT 1
58592: EQUAL
58593: IFFALSE 58614
// points := [ 10 , 5 , 3 ] ;
58595: LD_ADDR_VAR 0 9
58599: PUSH
58600: LD_INT 10
58602: PUSH
58603: LD_INT 5
58605: PUSH
58606: LD_INT 3
58608: PUSH
58609: EMPTY
58610: LIST
58611: LIST
58612: LIST
58613: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
58614: LD_VAR 0 6
58618: PPUSH
58619: CALL_OW 257
58623: PUSH
58624: LD_INT 2
58626: PUSH
58627: LD_INT 3
58629: PUSH
58630: LD_INT 4
58632: PUSH
58633: EMPTY
58634: LIST
58635: LIST
58636: LIST
58637: IN
58638: IFFALSE 58659
// points := [ 3 , 2 , 1 ] ;
58640: LD_ADDR_VAR 0 9
58644: PUSH
58645: LD_INT 3
58647: PUSH
58648: LD_INT 2
58650: PUSH
58651: LD_INT 1
58653: PUSH
58654: EMPTY
58655: LIST
58656: LIST
58657: LIST
58658: ST_TO_ADDR
// if GetClass ( i ) = 5 then
58659: LD_VAR 0 6
58663: PPUSH
58664: CALL_OW 257
58668: PUSH
58669: LD_INT 5
58671: EQUAL
58672: IFFALSE 58693
// points := [ 130 , 5 , 2 ] ;
58674: LD_ADDR_VAR 0 9
58678: PUSH
58679: LD_INT 130
58681: PUSH
58682: LD_INT 5
58684: PUSH
58685: LD_INT 2
58687: PUSH
58688: EMPTY
58689: LIST
58690: LIST
58691: LIST
58692: ST_TO_ADDR
// if GetClass ( i ) = 8 then
58693: LD_VAR 0 6
58697: PPUSH
58698: CALL_OW 257
58702: PUSH
58703: LD_INT 8
58705: EQUAL
58706: IFFALSE 58727
// points := [ 35 , 35 , 30 ] ;
58708: LD_ADDR_VAR 0 9
58712: PUSH
58713: LD_INT 35
58715: PUSH
58716: LD_INT 35
58718: PUSH
58719: LD_INT 30
58721: PUSH
58722: EMPTY
58723: LIST
58724: LIST
58725: LIST
58726: ST_TO_ADDR
// if GetClass ( i ) = 9 then
58727: LD_VAR 0 6
58731: PPUSH
58732: CALL_OW 257
58736: PUSH
58737: LD_INT 9
58739: EQUAL
58740: IFFALSE 58761
// points := [ 20 , 55 , 40 ] ;
58742: LD_ADDR_VAR 0 9
58746: PUSH
58747: LD_INT 20
58749: PUSH
58750: LD_INT 55
58752: PUSH
58753: LD_INT 40
58755: PUSH
58756: EMPTY
58757: LIST
58758: LIST
58759: LIST
58760: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
58761: LD_VAR 0 6
58765: PPUSH
58766: CALL_OW 257
58770: PUSH
58771: LD_INT 12
58773: PUSH
58774: LD_INT 16
58776: PUSH
58777: EMPTY
58778: LIST
58779: LIST
58780: IN
58781: IFFALSE 58802
// points := [ 5 , 3 , 2 ] ;
58783: LD_ADDR_VAR 0 9
58787: PUSH
58788: LD_INT 5
58790: PUSH
58791: LD_INT 3
58793: PUSH
58794: LD_INT 2
58796: PUSH
58797: EMPTY
58798: LIST
58799: LIST
58800: LIST
58801: ST_TO_ADDR
// if GetClass ( i ) = 17 then
58802: LD_VAR 0 6
58806: PPUSH
58807: CALL_OW 257
58811: PUSH
58812: LD_INT 17
58814: EQUAL
58815: IFFALSE 58836
// points := [ 100 , 50 , 75 ] ;
58817: LD_ADDR_VAR 0 9
58821: PUSH
58822: LD_INT 100
58824: PUSH
58825: LD_INT 50
58827: PUSH
58828: LD_INT 75
58830: PUSH
58831: EMPTY
58832: LIST
58833: LIST
58834: LIST
58835: ST_TO_ADDR
// if GetClass ( i ) = 15 then
58836: LD_VAR 0 6
58840: PPUSH
58841: CALL_OW 257
58845: PUSH
58846: LD_INT 15
58848: EQUAL
58849: IFFALSE 58870
// points := [ 10 , 5 , 3 ] ;
58851: LD_ADDR_VAR 0 9
58855: PUSH
58856: LD_INT 10
58858: PUSH
58859: LD_INT 5
58861: PUSH
58862: LD_INT 3
58864: PUSH
58865: EMPTY
58866: LIST
58867: LIST
58868: LIST
58869: ST_TO_ADDR
// if GetClass ( i ) = 14 then
58870: LD_VAR 0 6
58874: PPUSH
58875: CALL_OW 257
58879: PUSH
58880: LD_INT 14
58882: EQUAL
58883: IFFALSE 58904
// points := [ 10 , 0 , 0 ] ;
58885: LD_ADDR_VAR 0 9
58889: PUSH
58890: LD_INT 10
58892: PUSH
58893: LD_INT 0
58895: PUSH
58896: LD_INT 0
58898: PUSH
58899: EMPTY
58900: LIST
58901: LIST
58902: LIST
58903: ST_TO_ADDR
// if GetClass ( i ) = 11 then
58904: LD_VAR 0 6
58908: PPUSH
58909: CALL_OW 257
58913: PUSH
58914: LD_INT 11
58916: EQUAL
58917: IFFALSE 58938
// points := [ 30 , 10 , 5 ] ;
58919: LD_ADDR_VAR 0 9
58923: PUSH
58924: LD_INT 30
58926: PUSH
58927: LD_INT 10
58929: PUSH
58930: LD_INT 5
58932: PUSH
58933: EMPTY
58934: LIST
58935: LIST
58936: LIST
58937: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
58938: LD_VAR 0 1
58942: PPUSH
58943: LD_INT 5
58945: PPUSH
58946: CALL_OW 321
58950: PUSH
58951: LD_INT 2
58953: EQUAL
58954: IFFALSE 58971
// bpoints := bpoints * 1.8 ;
58956: LD_ADDR_VAR 0 10
58960: PUSH
58961: LD_VAR 0 10
58965: PUSH
58966: LD_REAL  1.80000000000000E+0000
58969: MUL
58970: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
58971: LD_VAR 0 6
58975: PPUSH
58976: CALL_OW 257
58980: PUSH
58981: LD_INT 1
58983: PUSH
58984: LD_INT 2
58986: PUSH
58987: LD_INT 3
58989: PUSH
58990: LD_INT 4
58992: PUSH
58993: EMPTY
58994: LIST
58995: LIST
58996: LIST
58997: LIST
58998: IN
58999: PUSH
59000: LD_VAR 0 1
59004: PPUSH
59005: LD_INT 51
59007: PPUSH
59008: CALL_OW 321
59012: PUSH
59013: LD_INT 2
59015: EQUAL
59016: AND
59017: IFFALSE 59034
// bpoints := bpoints * 1.2 ;
59019: LD_ADDR_VAR 0 10
59023: PUSH
59024: LD_VAR 0 10
59028: PUSH
59029: LD_REAL  1.20000000000000E+0000
59032: MUL
59033: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
59034: LD_VAR 0 6
59038: PPUSH
59039: CALL_OW 257
59043: PUSH
59044: LD_INT 5
59046: PUSH
59047: LD_INT 7
59049: PUSH
59050: LD_INT 9
59052: PUSH
59053: EMPTY
59054: LIST
59055: LIST
59056: LIST
59057: IN
59058: PUSH
59059: LD_VAR 0 1
59063: PPUSH
59064: LD_INT 52
59066: PPUSH
59067: CALL_OW 321
59071: PUSH
59072: LD_INT 2
59074: EQUAL
59075: AND
59076: IFFALSE 59093
// bpoints := bpoints * 1.5 ;
59078: LD_ADDR_VAR 0 10
59082: PUSH
59083: LD_VAR 0 10
59087: PUSH
59088: LD_REAL  1.50000000000000E+0000
59091: MUL
59092: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
59093: LD_VAR 0 1
59097: PPUSH
59098: LD_INT 66
59100: PPUSH
59101: CALL_OW 321
59105: PUSH
59106: LD_INT 2
59108: EQUAL
59109: IFFALSE 59126
// bpoints := bpoints * 1.1 ;
59111: LD_ADDR_VAR 0 10
59115: PUSH
59116: LD_VAR 0 10
59120: PUSH
59121: LD_REAL  1.10000000000000E+0000
59124: MUL
59125: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
59126: LD_ADDR_VAR 0 10
59130: PUSH
59131: LD_VAR 0 10
59135: PUSH
59136: LD_VAR 0 6
59140: PPUSH
59141: LD_INT 1
59143: PPUSH
59144: CALL_OW 259
59148: PUSH
59149: LD_REAL  1.15000000000000E+0000
59152: MUL
59153: MUL
59154: ST_TO_ADDR
// end ; unit_vehicle :
59155: GO 59979
59157: LD_INT 2
59159: DOUBLE
59160: EQUAL
59161: IFTRUE 59165
59163: GO 59967
59165: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
59166: LD_VAR 0 6
59170: PPUSH
59171: CALL_OW 264
59175: PUSH
59176: LD_INT 2
59178: PUSH
59179: LD_INT 42
59181: PUSH
59182: LD_INT 24
59184: PUSH
59185: EMPTY
59186: LIST
59187: LIST
59188: LIST
59189: IN
59190: IFFALSE 59211
// points := [ 25 , 5 , 3 ] ;
59192: LD_ADDR_VAR 0 9
59196: PUSH
59197: LD_INT 25
59199: PUSH
59200: LD_INT 5
59202: PUSH
59203: LD_INT 3
59205: PUSH
59206: EMPTY
59207: LIST
59208: LIST
59209: LIST
59210: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
59211: LD_VAR 0 6
59215: PPUSH
59216: CALL_OW 264
59220: PUSH
59221: LD_INT 4
59223: PUSH
59224: LD_INT 43
59226: PUSH
59227: LD_INT 25
59229: PUSH
59230: EMPTY
59231: LIST
59232: LIST
59233: LIST
59234: IN
59235: IFFALSE 59256
// points := [ 40 , 15 , 5 ] ;
59237: LD_ADDR_VAR 0 9
59241: PUSH
59242: LD_INT 40
59244: PUSH
59245: LD_INT 15
59247: PUSH
59248: LD_INT 5
59250: PUSH
59251: EMPTY
59252: LIST
59253: LIST
59254: LIST
59255: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
59256: LD_VAR 0 6
59260: PPUSH
59261: CALL_OW 264
59265: PUSH
59266: LD_INT 3
59268: PUSH
59269: LD_INT 23
59271: PUSH
59272: EMPTY
59273: LIST
59274: LIST
59275: IN
59276: IFFALSE 59297
// points := [ 7 , 25 , 8 ] ;
59278: LD_ADDR_VAR 0 9
59282: PUSH
59283: LD_INT 7
59285: PUSH
59286: LD_INT 25
59288: PUSH
59289: LD_INT 8
59291: PUSH
59292: EMPTY
59293: LIST
59294: LIST
59295: LIST
59296: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
59297: LD_VAR 0 6
59301: PPUSH
59302: CALL_OW 264
59306: PUSH
59307: LD_INT 5
59309: PUSH
59310: LD_INT 27
59312: PUSH
59313: LD_INT 44
59315: PUSH
59316: EMPTY
59317: LIST
59318: LIST
59319: LIST
59320: IN
59321: IFFALSE 59342
// points := [ 14 , 50 , 16 ] ;
59323: LD_ADDR_VAR 0 9
59327: PUSH
59328: LD_INT 14
59330: PUSH
59331: LD_INT 50
59333: PUSH
59334: LD_INT 16
59336: PUSH
59337: EMPTY
59338: LIST
59339: LIST
59340: LIST
59341: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
59342: LD_VAR 0 6
59346: PPUSH
59347: CALL_OW 264
59351: PUSH
59352: LD_INT 6
59354: PUSH
59355: LD_INT 46
59357: PUSH
59358: EMPTY
59359: LIST
59360: LIST
59361: IN
59362: IFFALSE 59383
// points := [ 32 , 120 , 70 ] ;
59364: LD_ADDR_VAR 0 9
59368: PUSH
59369: LD_INT 32
59371: PUSH
59372: LD_INT 120
59374: PUSH
59375: LD_INT 70
59377: PUSH
59378: EMPTY
59379: LIST
59380: LIST
59381: LIST
59382: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
59383: LD_VAR 0 6
59387: PPUSH
59388: CALL_OW 264
59392: PUSH
59393: LD_INT 7
59395: PUSH
59396: LD_INT 28
59398: PUSH
59399: LD_INT 45
59401: PUSH
59402: EMPTY
59403: LIST
59404: LIST
59405: LIST
59406: IN
59407: IFFALSE 59428
// points := [ 35 , 20 , 45 ] ;
59409: LD_ADDR_VAR 0 9
59413: PUSH
59414: LD_INT 35
59416: PUSH
59417: LD_INT 20
59419: PUSH
59420: LD_INT 45
59422: PUSH
59423: EMPTY
59424: LIST
59425: LIST
59426: LIST
59427: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
59428: LD_VAR 0 6
59432: PPUSH
59433: CALL_OW 264
59437: PUSH
59438: LD_INT 47
59440: PUSH
59441: EMPTY
59442: LIST
59443: IN
59444: IFFALSE 59465
// points := [ 67 , 45 , 75 ] ;
59446: LD_ADDR_VAR 0 9
59450: PUSH
59451: LD_INT 67
59453: PUSH
59454: LD_INT 45
59456: PUSH
59457: LD_INT 75
59459: PUSH
59460: EMPTY
59461: LIST
59462: LIST
59463: LIST
59464: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
59465: LD_VAR 0 6
59469: PPUSH
59470: CALL_OW 264
59474: PUSH
59475: LD_INT 26
59477: PUSH
59478: EMPTY
59479: LIST
59480: IN
59481: IFFALSE 59502
// points := [ 120 , 30 , 80 ] ;
59483: LD_ADDR_VAR 0 9
59487: PUSH
59488: LD_INT 120
59490: PUSH
59491: LD_INT 30
59493: PUSH
59494: LD_INT 80
59496: PUSH
59497: EMPTY
59498: LIST
59499: LIST
59500: LIST
59501: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
59502: LD_VAR 0 6
59506: PPUSH
59507: CALL_OW 264
59511: PUSH
59512: LD_INT 22
59514: PUSH
59515: EMPTY
59516: LIST
59517: IN
59518: IFFALSE 59539
// points := [ 40 , 1 , 1 ] ;
59520: LD_ADDR_VAR 0 9
59524: PUSH
59525: LD_INT 40
59527: PUSH
59528: LD_INT 1
59530: PUSH
59531: LD_INT 1
59533: PUSH
59534: EMPTY
59535: LIST
59536: LIST
59537: LIST
59538: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
59539: LD_VAR 0 6
59543: PPUSH
59544: CALL_OW 264
59548: PUSH
59549: LD_INT 29
59551: PUSH
59552: EMPTY
59553: LIST
59554: IN
59555: IFFALSE 59576
// points := [ 70 , 200 , 400 ] ;
59557: LD_ADDR_VAR 0 9
59561: PUSH
59562: LD_INT 70
59564: PUSH
59565: LD_INT 200
59567: PUSH
59568: LD_INT 400
59570: PUSH
59571: EMPTY
59572: LIST
59573: LIST
59574: LIST
59575: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
59576: LD_VAR 0 6
59580: PPUSH
59581: CALL_OW 264
59585: PUSH
59586: LD_INT 14
59588: PUSH
59589: LD_INT 53
59591: PUSH
59592: EMPTY
59593: LIST
59594: LIST
59595: IN
59596: IFFALSE 59617
// points := [ 40 , 10 , 20 ] ;
59598: LD_ADDR_VAR 0 9
59602: PUSH
59603: LD_INT 40
59605: PUSH
59606: LD_INT 10
59608: PUSH
59609: LD_INT 20
59611: PUSH
59612: EMPTY
59613: LIST
59614: LIST
59615: LIST
59616: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
59617: LD_VAR 0 6
59621: PPUSH
59622: CALL_OW 264
59626: PUSH
59627: LD_INT 9
59629: PUSH
59630: EMPTY
59631: LIST
59632: IN
59633: IFFALSE 59654
// points := [ 5 , 70 , 20 ] ;
59635: LD_ADDR_VAR 0 9
59639: PUSH
59640: LD_INT 5
59642: PUSH
59643: LD_INT 70
59645: PUSH
59646: LD_INT 20
59648: PUSH
59649: EMPTY
59650: LIST
59651: LIST
59652: LIST
59653: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
59654: LD_VAR 0 6
59658: PPUSH
59659: CALL_OW 264
59663: PUSH
59664: LD_INT 10
59666: PUSH
59667: EMPTY
59668: LIST
59669: IN
59670: IFFALSE 59691
// points := [ 35 , 110 , 70 ] ;
59672: LD_ADDR_VAR 0 9
59676: PUSH
59677: LD_INT 35
59679: PUSH
59680: LD_INT 110
59682: PUSH
59683: LD_INT 70
59685: PUSH
59686: EMPTY
59687: LIST
59688: LIST
59689: LIST
59690: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
59691: LD_VAR 0 6
59695: PPUSH
59696: CALL_OW 265
59700: PUSH
59701: LD_INT 25
59703: EQUAL
59704: IFFALSE 59725
// points := [ 80 , 65 , 100 ] ;
59706: LD_ADDR_VAR 0 9
59710: PUSH
59711: LD_INT 80
59713: PUSH
59714: LD_INT 65
59716: PUSH
59717: LD_INT 100
59719: PUSH
59720: EMPTY
59721: LIST
59722: LIST
59723: LIST
59724: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
59725: LD_VAR 0 6
59729: PPUSH
59730: CALL_OW 263
59734: PUSH
59735: LD_INT 1
59737: EQUAL
59738: IFFALSE 59773
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
59740: LD_ADDR_VAR 0 10
59744: PUSH
59745: LD_VAR 0 10
59749: PUSH
59750: LD_VAR 0 6
59754: PPUSH
59755: CALL_OW 311
59759: PPUSH
59760: LD_INT 3
59762: PPUSH
59763: CALL_OW 259
59767: PUSH
59768: LD_INT 4
59770: MUL
59771: MUL
59772: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
59773: LD_VAR 0 6
59777: PPUSH
59778: CALL_OW 263
59782: PUSH
59783: LD_INT 2
59785: EQUAL
59786: IFFALSE 59837
// begin j := IsControledBy ( i ) ;
59788: LD_ADDR_VAR 0 7
59792: PUSH
59793: LD_VAR 0 6
59797: PPUSH
59798: CALL_OW 312
59802: ST_TO_ADDR
// if j then
59803: LD_VAR 0 7
59807: IFFALSE 59837
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
59809: LD_ADDR_VAR 0 10
59813: PUSH
59814: LD_VAR 0 10
59818: PUSH
59819: LD_VAR 0 7
59823: PPUSH
59824: LD_INT 3
59826: PPUSH
59827: CALL_OW 259
59831: PUSH
59832: LD_INT 3
59834: MUL
59835: MUL
59836: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
59837: LD_VAR 0 6
59841: PPUSH
59842: CALL_OW 264
59846: PUSH
59847: LD_INT 5
59849: PUSH
59850: LD_INT 6
59852: PUSH
59853: LD_INT 46
59855: PUSH
59856: LD_INT 44
59858: PUSH
59859: LD_INT 47
59861: PUSH
59862: LD_INT 45
59864: PUSH
59865: LD_INT 28
59867: PUSH
59868: LD_INT 7
59870: PUSH
59871: LD_INT 27
59873: PUSH
59874: LD_INT 29
59876: PUSH
59877: EMPTY
59878: LIST
59879: LIST
59880: LIST
59881: LIST
59882: LIST
59883: LIST
59884: LIST
59885: LIST
59886: LIST
59887: LIST
59888: IN
59889: PUSH
59890: LD_VAR 0 1
59894: PPUSH
59895: LD_INT 52
59897: PPUSH
59898: CALL_OW 321
59902: PUSH
59903: LD_INT 2
59905: EQUAL
59906: AND
59907: IFFALSE 59924
// bpoints := bpoints * 1.2 ;
59909: LD_ADDR_VAR 0 10
59913: PUSH
59914: LD_VAR 0 10
59918: PUSH
59919: LD_REAL  1.20000000000000E+0000
59922: MUL
59923: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
59924: LD_VAR 0 6
59928: PPUSH
59929: CALL_OW 264
59933: PUSH
59934: LD_INT 6
59936: PUSH
59937: LD_INT 46
59939: PUSH
59940: LD_INT 47
59942: PUSH
59943: EMPTY
59944: LIST
59945: LIST
59946: LIST
59947: IN
59948: IFFALSE 59965
// bpoints := bpoints * 1.2 ;
59950: LD_ADDR_VAR 0 10
59954: PUSH
59955: LD_VAR 0 10
59959: PUSH
59960: LD_REAL  1.20000000000000E+0000
59963: MUL
59964: ST_TO_ADDR
// end ; unit_building :
59965: GO 59979
59967: LD_INT 3
59969: DOUBLE
59970: EQUAL
59971: IFTRUE 59975
59973: GO 59978
59975: POP
// ; end ;
59976: GO 59979
59978: POP
// for j = 1 to 3 do
59979: LD_ADDR_VAR 0 7
59983: PUSH
59984: DOUBLE
59985: LD_INT 1
59987: DEC
59988: ST_TO_ADDR
59989: LD_INT 3
59991: PUSH
59992: FOR_TO
59993: IFFALSE 60046
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
59995: LD_ADDR_VAR 0 5
59999: PUSH
60000: LD_VAR 0 5
60004: PPUSH
60005: LD_VAR 0 7
60009: PPUSH
60010: LD_VAR 0 5
60014: PUSH
60015: LD_VAR 0 7
60019: ARRAY
60020: PUSH
60021: LD_VAR 0 9
60025: PUSH
60026: LD_VAR 0 7
60030: ARRAY
60031: PUSH
60032: LD_VAR 0 10
60036: MUL
60037: PLUS
60038: PPUSH
60039: CALL_OW 1
60043: ST_TO_ADDR
60044: GO 59992
60046: POP
60047: POP
// end ;
60048: GO 58531
60050: POP
60051: POP
// result := Replace ( result , 4 , tmp ) ;
60052: LD_ADDR_VAR 0 5
60056: PUSH
60057: LD_VAR 0 5
60061: PPUSH
60062: LD_INT 4
60064: PPUSH
60065: LD_VAR 0 8
60069: PPUSH
60070: CALL_OW 1
60074: ST_TO_ADDR
// end ;
60075: LD_VAR 0 5
60079: RET
// export function DangerAtRange ( unit , range ) ; begin
60080: LD_INT 0
60082: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
60083: LD_ADDR_VAR 0 3
60087: PUSH
60088: LD_VAR 0 1
60092: PPUSH
60093: CALL_OW 255
60097: PPUSH
60098: LD_VAR 0 1
60102: PPUSH
60103: CALL_OW 250
60107: PPUSH
60108: LD_VAR 0 1
60112: PPUSH
60113: CALL_OW 251
60117: PPUSH
60118: LD_VAR 0 2
60122: PPUSH
60123: CALL 58383 0 4
60127: ST_TO_ADDR
// end ;
60128: LD_VAR 0 3
60132: RET
// export function DangerInArea ( side , area ) ; begin
60133: LD_INT 0
60135: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
60136: LD_ADDR_VAR 0 3
60140: PUSH
60141: LD_VAR 0 2
60145: PPUSH
60146: LD_INT 81
60148: PUSH
60149: LD_VAR 0 1
60153: PUSH
60154: EMPTY
60155: LIST
60156: LIST
60157: PPUSH
60158: CALL_OW 70
60162: ST_TO_ADDR
// end ;
60163: LD_VAR 0 3
60167: RET
// export function IsExtension ( b ) ; begin
60168: LD_INT 0
60170: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
60171: LD_ADDR_VAR 0 2
60175: PUSH
60176: LD_VAR 0 1
60180: PUSH
60181: LD_INT 23
60183: PUSH
60184: LD_INT 20
60186: PUSH
60187: LD_INT 22
60189: PUSH
60190: LD_INT 17
60192: PUSH
60193: LD_INT 24
60195: PUSH
60196: LD_INT 21
60198: PUSH
60199: LD_INT 19
60201: PUSH
60202: LD_INT 16
60204: PUSH
60205: LD_INT 25
60207: PUSH
60208: LD_INT 18
60210: PUSH
60211: EMPTY
60212: LIST
60213: LIST
60214: LIST
60215: LIST
60216: LIST
60217: LIST
60218: LIST
60219: LIST
60220: LIST
60221: LIST
60222: IN
60223: ST_TO_ADDR
// end ;
60224: LD_VAR 0 2
60228: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
60229: LD_INT 0
60231: PPUSH
60232: PPUSH
60233: PPUSH
// result := [ ] ;
60234: LD_ADDR_VAR 0 3
60238: PUSH
60239: EMPTY
60240: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
60241: LD_ADDR_VAR 0 4
60245: PUSH
60246: LD_VAR 0 2
60250: PPUSH
60251: LD_INT 21
60253: PUSH
60254: LD_INT 3
60256: PUSH
60257: EMPTY
60258: LIST
60259: LIST
60260: PPUSH
60261: CALL_OW 70
60265: ST_TO_ADDR
// if not tmp then
60266: LD_VAR 0 4
60270: NOT
60271: IFFALSE 60275
// exit ;
60273: GO 60333
// for i in tmp do
60275: LD_ADDR_VAR 0 5
60279: PUSH
60280: LD_VAR 0 4
60284: PUSH
60285: FOR_IN
60286: IFFALSE 60321
// if GetBase ( i ) <> base then
60288: LD_VAR 0 5
60292: PPUSH
60293: CALL_OW 274
60297: PUSH
60298: LD_VAR 0 1
60302: NONEQUAL
60303: IFFALSE 60319
// ComLinkToBase ( base , i ) ;
60305: LD_VAR 0 1
60309: PPUSH
60310: LD_VAR 0 5
60314: PPUSH
60315: CALL_OW 169
60319: GO 60285
60321: POP
60322: POP
// result := tmp ;
60323: LD_ADDR_VAR 0 3
60327: PUSH
60328: LD_VAR 0 4
60332: ST_TO_ADDR
// end ;
60333: LD_VAR 0 3
60337: RET
// export function ComComplete ( unit , b ) ; var i ; begin
60338: LD_INT 0
60340: PPUSH
60341: PPUSH
// if BuildingStatus ( b ) = bs_build then
60342: LD_VAR 0 2
60346: PPUSH
60347: CALL_OW 461
60351: PUSH
60352: LD_INT 1
60354: EQUAL
60355: IFFALSE 60415
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
60357: LD_VAR 0 1
60361: PPUSH
60362: LD_STRING h
60364: PUSH
60365: LD_VAR 0 2
60369: PPUSH
60370: CALL_OW 250
60374: PUSH
60375: LD_VAR 0 2
60379: PPUSH
60380: CALL_OW 251
60384: PUSH
60385: LD_VAR 0 2
60389: PUSH
60390: LD_INT 0
60392: PUSH
60393: LD_INT 0
60395: PUSH
60396: LD_INT 0
60398: PUSH
60399: EMPTY
60400: LIST
60401: LIST
60402: LIST
60403: LIST
60404: LIST
60405: LIST
60406: LIST
60407: PUSH
60408: EMPTY
60409: LIST
60410: PPUSH
60411: CALL_OW 446
// end ;
60415: LD_VAR 0 3
60419: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
60420: LD_INT 0
60422: PPUSH
60423: PPUSH
60424: PPUSH
60425: PPUSH
60426: PPUSH
60427: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
60428: LD_VAR 0 1
60432: NOT
60433: PUSH
60434: LD_VAR 0 1
60438: PPUSH
60439: CALL_OW 263
60443: PUSH
60444: LD_INT 2
60446: EQUAL
60447: NOT
60448: OR
60449: IFFALSE 60453
// exit ;
60451: GO 60769
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
60453: LD_ADDR_VAR 0 6
60457: PUSH
60458: LD_INT 22
60460: PUSH
60461: LD_VAR 0 1
60465: PPUSH
60466: CALL_OW 255
60470: PUSH
60471: EMPTY
60472: LIST
60473: LIST
60474: PUSH
60475: LD_INT 2
60477: PUSH
60478: LD_INT 30
60480: PUSH
60481: LD_INT 36
60483: PUSH
60484: EMPTY
60485: LIST
60486: LIST
60487: PUSH
60488: LD_INT 34
60490: PUSH
60491: LD_INT 31
60493: PUSH
60494: EMPTY
60495: LIST
60496: LIST
60497: PUSH
60498: EMPTY
60499: LIST
60500: LIST
60501: LIST
60502: PUSH
60503: EMPTY
60504: LIST
60505: LIST
60506: PPUSH
60507: CALL_OW 69
60511: ST_TO_ADDR
// if not tmp then
60512: LD_VAR 0 6
60516: NOT
60517: IFFALSE 60521
// exit ;
60519: GO 60769
// result := [ ] ;
60521: LD_ADDR_VAR 0 2
60525: PUSH
60526: EMPTY
60527: ST_TO_ADDR
// for i in tmp do
60528: LD_ADDR_VAR 0 3
60532: PUSH
60533: LD_VAR 0 6
60537: PUSH
60538: FOR_IN
60539: IFFALSE 60610
// begin t := UnitsInside ( i ) ;
60541: LD_ADDR_VAR 0 4
60545: PUSH
60546: LD_VAR 0 3
60550: PPUSH
60551: CALL_OW 313
60555: ST_TO_ADDR
// if t then
60556: LD_VAR 0 4
60560: IFFALSE 60608
// for j in t do
60562: LD_ADDR_VAR 0 7
60566: PUSH
60567: LD_VAR 0 4
60571: PUSH
60572: FOR_IN
60573: IFFALSE 60606
// result := Insert ( result , result + 1 , j ) ;
60575: LD_ADDR_VAR 0 2
60579: PUSH
60580: LD_VAR 0 2
60584: PPUSH
60585: LD_VAR 0 2
60589: PUSH
60590: LD_INT 1
60592: PLUS
60593: PPUSH
60594: LD_VAR 0 7
60598: PPUSH
60599: CALL_OW 2
60603: ST_TO_ADDR
60604: GO 60572
60606: POP
60607: POP
// end ;
60608: GO 60538
60610: POP
60611: POP
// if not result then
60612: LD_VAR 0 2
60616: NOT
60617: IFFALSE 60621
// exit ;
60619: GO 60769
// mech := result [ 1 ] ;
60621: LD_ADDR_VAR 0 5
60625: PUSH
60626: LD_VAR 0 2
60630: PUSH
60631: LD_INT 1
60633: ARRAY
60634: ST_TO_ADDR
// if result > 1 then
60635: LD_VAR 0 2
60639: PUSH
60640: LD_INT 1
60642: GREATER
60643: IFFALSE 60755
// for i = 2 to result do
60645: LD_ADDR_VAR 0 3
60649: PUSH
60650: DOUBLE
60651: LD_INT 2
60653: DEC
60654: ST_TO_ADDR
60655: LD_VAR 0 2
60659: PUSH
60660: FOR_TO
60661: IFFALSE 60753
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
60663: LD_ADDR_VAR 0 4
60667: PUSH
60668: LD_VAR 0 2
60672: PUSH
60673: LD_VAR 0 3
60677: ARRAY
60678: PPUSH
60679: LD_INT 3
60681: PPUSH
60682: CALL_OW 259
60686: PUSH
60687: LD_VAR 0 2
60691: PUSH
60692: LD_VAR 0 3
60696: ARRAY
60697: PPUSH
60698: CALL_OW 432
60702: MINUS
60703: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
60704: LD_VAR 0 4
60708: PUSH
60709: LD_VAR 0 5
60713: PPUSH
60714: LD_INT 3
60716: PPUSH
60717: CALL_OW 259
60721: PUSH
60722: LD_VAR 0 5
60726: PPUSH
60727: CALL_OW 432
60731: MINUS
60732: GREATEREQUAL
60733: IFFALSE 60751
// mech := result [ i ] ;
60735: LD_ADDR_VAR 0 5
60739: PUSH
60740: LD_VAR 0 2
60744: PUSH
60745: LD_VAR 0 3
60749: ARRAY
60750: ST_TO_ADDR
// end ;
60751: GO 60660
60753: POP
60754: POP
// ComLinkTo ( vehicle , mech ) ;
60755: LD_VAR 0 1
60759: PPUSH
60760: LD_VAR 0 5
60764: PPUSH
60765: CALL_OW 135
// end ;
60769: LD_VAR 0 2
60773: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
60774: LD_INT 0
60776: PPUSH
60777: PPUSH
60778: PPUSH
60779: PPUSH
60780: PPUSH
60781: PPUSH
60782: PPUSH
60783: PPUSH
60784: PPUSH
60785: PPUSH
60786: PPUSH
60787: PPUSH
60788: PPUSH
// result := [ ] ;
60789: LD_ADDR_VAR 0 7
60793: PUSH
60794: EMPTY
60795: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
60796: LD_VAR 0 1
60800: PPUSH
60801: CALL_OW 266
60805: PUSH
60806: LD_INT 0
60808: PUSH
60809: LD_INT 1
60811: PUSH
60812: EMPTY
60813: LIST
60814: LIST
60815: IN
60816: NOT
60817: IFFALSE 60821
// exit ;
60819: GO 62452
// if name then
60821: LD_VAR 0 3
60825: IFFALSE 60841
// SetBName ( base_dep , name ) ;
60827: LD_VAR 0 1
60831: PPUSH
60832: LD_VAR 0 3
60836: PPUSH
60837: CALL_OW 500
// base := GetBase ( base_dep ) ;
60841: LD_ADDR_VAR 0 15
60845: PUSH
60846: LD_VAR 0 1
60850: PPUSH
60851: CALL_OW 274
60855: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
60856: LD_ADDR_VAR 0 16
60860: PUSH
60861: LD_VAR 0 1
60865: PPUSH
60866: CALL_OW 255
60870: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
60871: LD_ADDR_VAR 0 17
60875: PUSH
60876: LD_VAR 0 1
60880: PPUSH
60881: CALL_OW 248
60885: ST_TO_ADDR
// if sources then
60886: LD_VAR 0 5
60890: IFFALSE 60937
// for i = 1 to 3 do
60892: LD_ADDR_VAR 0 8
60896: PUSH
60897: DOUBLE
60898: LD_INT 1
60900: DEC
60901: ST_TO_ADDR
60902: LD_INT 3
60904: PUSH
60905: FOR_TO
60906: IFFALSE 60935
// AddResourceType ( base , i , sources [ i ] ) ;
60908: LD_VAR 0 15
60912: PPUSH
60913: LD_VAR 0 8
60917: PPUSH
60918: LD_VAR 0 5
60922: PUSH
60923: LD_VAR 0 8
60927: ARRAY
60928: PPUSH
60929: CALL_OW 276
60933: GO 60905
60935: POP
60936: POP
// buildings := GetBaseBuildings ( base , area ) ;
60937: LD_ADDR_VAR 0 18
60941: PUSH
60942: LD_VAR 0 15
60946: PPUSH
60947: LD_VAR 0 2
60951: PPUSH
60952: CALL 60229 0 2
60956: ST_TO_ADDR
// InitHc ;
60957: CALL_OW 19
// InitUc ;
60961: CALL_OW 18
// uc_side := side ;
60965: LD_ADDR_OWVAR 20
60969: PUSH
60970: LD_VAR 0 16
60974: ST_TO_ADDR
// uc_nation := nation ;
60975: LD_ADDR_OWVAR 21
60979: PUSH
60980: LD_VAR 0 17
60984: ST_TO_ADDR
// if buildings then
60985: LD_VAR 0 18
60989: IFFALSE 62311
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
60991: LD_ADDR_VAR 0 19
60995: PUSH
60996: LD_VAR 0 18
61000: PPUSH
61001: LD_INT 2
61003: PUSH
61004: LD_INT 30
61006: PUSH
61007: LD_INT 29
61009: PUSH
61010: EMPTY
61011: LIST
61012: LIST
61013: PUSH
61014: LD_INT 30
61016: PUSH
61017: LD_INT 30
61019: PUSH
61020: EMPTY
61021: LIST
61022: LIST
61023: PUSH
61024: EMPTY
61025: LIST
61026: LIST
61027: LIST
61028: PPUSH
61029: CALL_OW 72
61033: ST_TO_ADDR
// if tmp then
61034: LD_VAR 0 19
61038: IFFALSE 61086
// for i in tmp do
61040: LD_ADDR_VAR 0 8
61044: PUSH
61045: LD_VAR 0 19
61049: PUSH
61050: FOR_IN
61051: IFFALSE 61084
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
61053: LD_VAR 0 8
61057: PPUSH
61058: CALL_OW 250
61062: PPUSH
61063: LD_VAR 0 8
61067: PPUSH
61068: CALL_OW 251
61072: PPUSH
61073: LD_VAR 0 16
61077: PPUSH
61078: CALL_OW 441
61082: GO 61050
61084: POP
61085: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
61086: LD_VAR 0 18
61090: PPUSH
61091: LD_INT 2
61093: PUSH
61094: LD_INT 30
61096: PUSH
61097: LD_INT 32
61099: PUSH
61100: EMPTY
61101: LIST
61102: LIST
61103: PUSH
61104: LD_INT 30
61106: PUSH
61107: LD_INT 33
61109: PUSH
61110: EMPTY
61111: LIST
61112: LIST
61113: PUSH
61114: EMPTY
61115: LIST
61116: LIST
61117: LIST
61118: PPUSH
61119: CALL_OW 72
61123: IFFALSE 61211
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
61125: LD_ADDR_VAR 0 8
61129: PUSH
61130: LD_VAR 0 18
61134: PPUSH
61135: LD_INT 2
61137: PUSH
61138: LD_INT 30
61140: PUSH
61141: LD_INT 32
61143: PUSH
61144: EMPTY
61145: LIST
61146: LIST
61147: PUSH
61148: LD_INT 30
61150: PUSH
61151: LD_INT 33
61153: PUSH
61154: EMPTY
61155: LIST
61156: LIST
61157: PUSH
61158: EMPTY
61159: LIST
61160: LIST
61161: LIST
61162: PPUSH
61163: CALL_OW 72
61167: PUSH
61168: FOR_IN
61169: IFFALSE 61209
// begin if not GetBWeapon ( i ) then
61171: LD_VAR 0 8
61175: PPUSH
61176: CALL_OW 269
61180: NOT
61181: IFFALSE 61207
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
61183: LD_VAR 0 8
61187: PPUSH
61188: LD_VAR 0 8
61192: PPUSH
61193: LD_VAR 0 2
61197: PPUSH
61198: CALL 62457 0 2
61202: PPUSH
61203: CALL_OW 431
// end ;
61207: GO 61168
61209: POP
61210: POP
// end ; for i = 1 to personel do
61211: LD_ADDR_VAR 0 8
61215: PUSH
61216: DOUBLE
61217: LD_INT 1
61219: DEC
61220: ST_TO_ADDR
61221: LD_VAR 0 6
61225: PUSH
61226: FOR_TO
61227: IFFALSE 62291
// begin if i > 4 then
61229: LD_VAR 0 8
61233: PUSH
61234: LD_INT 4
61236: GREATER
61237: IFFALSE 61241
// break ;
61239: GO 62291
// case i of 1 :
61241: LD_VAR 0 8
61245: PUSH
61246: LD_INT 1
61248: DOUBLE
61249: EQUAL
61250: IFTRUE 61254
61252: GO 61334
61254: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
61255: LD_ADDR_VAR 0 12
61259: PUSH
61260: LD_VAR 0 18
61264: PPUSH
61265: LD_INT 22
61267: PUSH
61268: LD_VAR 0 16
61272: PUSH
61273: EMPTY
61274: LIST
61275: LIST
61276: PUSH
61277: LD_INT 58
61279: PUSH
61280: EMPTY
61281: LIST
61282: PUSH
61283: LD_INT 2
61285: PUSH
61286: LD_INT 30
61288: PUSH
61289: LD_INT 32
61291: PUSH
61292: EMPTY
61293: LIST
61294: LIST
61295: PUSH
61296: LD_INT 30
61298: PUSH
61299: LD_INT 4
61301: PUSH
61302: EMPTY
61303: LIST
61304: LIST
61305: PUSH
61306: LD_INT 30
61308: PUSH
61309: LD_INT 5
61311: PUSH
61312: EMPTY
61313: LIST
61314: LIST
61315: PUSH
61316: EMPTY
61317: LIST
61318: LIST
61319: LIST
61320: LIST
61321: PUSH
61322: EMPTY
61323: LIST
61324: LIST
61325: LIST
61326: PPUSH
61327: CALL_OW 72
61331: ST_TO_ADDR
61332: GO 61556
61334: LD_INT 2
61336: DOUBLE
61337: EQUAL
61338: IFTRUE 61342
61340: GO 61404
61342: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
61343: LD_ADDR_VAR 0 12
61347: PUSH
61348: LD_VAR 0 18
61352: PPUSH
61353: LD_INT 22
61355: PUSH
61356: LD_VAR 0 16
61360: PUSH
61361: EMPTY
61362: LIST
61363: LIST
61364: PUSH
61365: LD_INT 2
61367: PUSH
61368: LD_INT 30
61370: PUSH
61371: LD_INT 0
61373: PUSH
61374: EMPTY
61375: LIST
61376: LIST
61377: PUSH
61378: LD_INT 30
61380: PUSH
61381: LD_INT 1
61383: PUSH
61384: EMPTY
61385: LIST
61386: LIST
61387: PUSH
61388: EMPTY
61389: LIST
61390: LIST
61391: LIST
61392: PUSH
61393: EMPTY
61394: LIST
61395: LIST
61396: PPUSH
61397: CALL_OW 72
61401: ST_TO_ADDR
61402: GO 61556
61404: LD_INT 3
61406: DOUBLE
61407: EQUAL
61408: IFTRUE 61412
61410: GO 61474
61412: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
61413: LD_ADDR_VAR 0 12
61417: PUSH
61418: LD_VAR 0 18
61422: PPUSH
61423: LD_INT 22
61425: PUSH
61426: LD_VAR 0 16
61430: PUSH
61431: EMPTY
61432: LIST
61433: LIST
61434: PUSH
61435: LD_INT 2
61437: PUSH
61438: LD_INT 30
61440: PUSH
61441: LD_INT 2
61443: PUSH
61444: EMPTY
61445: LIST
61446: LIST
61447: PUSH
61448: LD_INT 30
61450: PUSH
61451: LD_INT 3
61453: PUSH
61454: EMPTY
61455: LIST
61456: LIST
61457: PUSH
61458: EMPTY
61459: LIST
61460: LIST
61461: LIST
61462: PUSH
61463: EMPTY
61464: LIST
61465: LIST
61466: PPUSH
61467: CALL_OW 72
61471: ST_TO_ADDR
61472: GO 61556
61474: LD_INT 4
61476: DOUBLE
61477: EQUAL
61478: IFTRUE 61482
61480: GO 61555
61482: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
61483: LD_ADDR_VAR 0 12
61487: PUSH
61488: LD_VAR 0 18
61492: PPUSH
61493: LD_INT 22
61495: PUSH
61496: LD_VAR 0 16
61500: PUSH
61501: EMPTY
61502: LIST
61503: LIST
61504: PUSH
61505: LD_INT 2
61507: PUSH
61508: LD_INT 30
61510: PUSH
61511: LD_INT 6
61513: PUSH
61514: EMPTY
61515: LIST
61516: LIST
61517: PUSH
61518: LD_INT 30
61520: PUSH
61521: LD_INT 7
61523: PUSH
61524: EMPTY
61525: LIST
61526: LIST
61527: PUSH
61528: LD_INT 30
61530: PUSH
61531: LD_INT 8
61533: PUSH
61534: EMPTY
61535: LIST
61536: LIST
61537: PUSH
61538: EMPTY
61539: LIST
61540: LIST
61541: LIST
61542: LIST
61543: PUSH
61544: EMPTY
61545: LIST
61546: LIST
61547: PPUSH
61548: CALL_OW 72
61552: ST_TO_ADDR
61553: GO 61556
61555: POP
// if i = 1 then
61556: LD_VAR 0 8
61560: PUSH
61561: LD_INT 1
61563: EQUAL
61564: IFFALSE 61675
// begin tmp := [ ] ;
61566: LD_ADDR_VAR 0 19
61570: PUSH
61571: EMPTY
61572: ST_TO_ADDR
// for j in f do
61573: LD_ADDR_VAR 0 9
61577: PUSH
61578: LD_VAR 0 12
61582: PUSH
61583: FOR_IN
61584: IFFALSE 61657
// if GetBType ( j ) = b_bunker then
61586: LD_VAR 0 9
61590: PPUSH
61591: CALL_OW 266
61595: PUSH
61596: LD_INT 32
61598: EQUAL
61599: IFFALSE 61626
// tmp := Insert ( tmp , 1 , j ) else
61601: LD_ADDR_VAR 0 19
61605: PUSH
61606: LD_VAR 0 19
61610: PPUSH
61611: LD_INT 1
61613: PPUSH
61614: LD_VAR 0 9
61618: PPUSH
61619: CALL_OW 2
61623: ST_TO_ADDR
61624: GO 61655
// tmp := Insert ( tmp , tmp + 1 , j ) ;
61626: LD_ADDR_VAR 0 19
61630: PUSH
61631: LD_VAR 0 19
61635: PPUSH
61636: LD_VAR 0 19
61640: PUSH
61641: LD_INT 1
61643: PLUS
61644: PPUSH
61645: LD_VAR 0 9
61649: PPUSH
61650: CALL_OW 2
61654: ST_TO_ADDR
61655: GO 61583
61657: POP
61658: POP
// if tmp then
61659: LD_VAR 0 19
61663: IFFALSE 61675
// f := tmp ;
61665: LD_ADDR_VAR 0 12
61669: PUSH
61670: LD_VAR 0 19
61674: ST_TO_ADDR
// end ; x := personel [ i ] ;
61675: LD_ADDR_VAR 0 13
61679: PUSH
61680: LD_VAR 0 6
61684: PUSH
61685: LD_VAR 0 8
61689: ARRAY
61690: ST_TO_ADDR
// if x = - 1 then
61691: LD_VAR 0 13
61695: PUSH
61696: LD_INT 1
61698: NEG
61699: EQUAL
61700: IFFALSE 61909
// begin for j in f do
61702: LD_ADDR_VAR 0 9
61706: PUSH
61707: LD_VAR 0 12
61711: PUSH
61712: FOR_IN
61713: IFFALSE 61905
// repeat InitHc ;
61715: CALL_OW 19
// if GetBType ( j ) = b_barracks then
61719: LD_VAR 0 9
61723: PPUSH
61724: CALL_OW 266
61728: PUSH
61729: LD_INT 5
61731: EQUAL
61732: IFFALSE 61802
// begin if UnitsInside ( j ) < 3 then
61734: LD_VAR 0 9
61738: PPUSH
61739: CALL_OW 313
61743: PUSH
61744: LD_INT 3
61746: LESS
61747: IFFALSE 61783
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
61749: LD_INT 0
61751: PPUSH
61752: LD_INT 5
61754: PUSH
61755: LD_INT 8
61757: PUSH
61758: LD_INT 9
61760: PUSH
61761: EMPTY
61762: LIST
61763: LIST
61764: LIST
61765: PUSH
61766: LD_VAR 0 17
61770: ARRAY
61771: PPUSH
61772: LD_VAR 0 4
61776: PPUSH
61777: CALL_OW 380
61781: GO 61800
// PrepareHuman ( false , i , skill ) ;
61783: LD_INT 0
61785: PPUSH
61786: LD_VAR 0 8
61790: PPUSH
61791: LD_VAR 0 4
61795: PPUSH
61796: CALL_OW 380
// end else
61800: GO 61819
// PrepareHuman ( false , i , skill ) ;
61802: LD_INT 0
61804: PPUSH
61805: LD_VAR 0 8
61809: PPUSH
61810: LD_VAR 0 4
61814: PPUSH
61815: CALL_OW 380
// un := CreateHuman ;
61819: LD_ADDR_VAR 0 14
61823: PUSH
61824: CALL_OW 44
61828: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61829: LD_ADDR_VAR 0 7
61833: PUSH
61834: LD_VAR 0 7
61838: PPUSH
61839: LD_INT 1
61841: PPUSH
61842: LD_VAR 0 14
61846: PPUSH
61847: CALL_OW 2
61851: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
61852: LD_VAR 0 14
61856: PPUSH
61857: LD_VAR 0 9
61861: PPUSH
61862: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
61866: LD_VAR 0 9
61870: PPUSH
61871: CALL_OW 313
61875: PUSH
61876: LD_INT 6
61878: EQUAL
61879: PUSH
61880: LD_VAR 0 9
61884: PPUSH
61885: CALL_OW 266
61889: PUSH
61890: LD_INT 32
61892: PUSH
61893: LD_INT 31
61895: PUSH
61896: EMPTY
61897: LIST
61898: LIST
61899: IN
61900: OR
61901: IFFALSE 61715
61903: GO 61712
61905: POP
61906: POP
// end else
61907: GO 62289
// for j = 1 to x do
61909: LD_ADDR_VAR 0 9
61913: PUSH
61914: DOUBLE
61915: LD_INT 1
61917: DEC
61918: ST_TO_ADDR
61919: LD_VAR 0 13
61923: PUSH
61924: FOR_TO
61925: IFFALSE 62287
// begin InitHc ;
61927: CALL_OW 19
// if not f then
61931: LD_VAR 0 12
61935: NOT
61936: IFFALSE 62025
// begin PrepareHuman ( false , i , skill ) ;
61938: LD_INT 0
61940: PPUSH
61941: LD_VAR 0 8
61945: PPUSH
61946: LD_VAR 0 4
61950: PPUSH
61951: CALL_OW 380
// un := CreateHuman ;
61955: LD_ADDR_VAR 0 14
61959: PUSH
61960: CALL_OW 44
61964: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61965: LD_ADDR_VAR 0 7
61969: PUSH
61970: LD_VAR 0 7
61974: PPUSH
61975: LD_INT 1
61977: PPUSH
61978: LD_VAR 0 14
61982: PPUSH
61983: CALL_OW 2
61987: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
61988: LD_VAR 0 14
61992: PPUSH
61993: LD_VAR 0 1
61997: PPUSH
61998: CALL_OW 250
62002: PPUSH
62003: LD_VAR 0 1
62007: PPUSH
62008: CALL_OW 251
62012: PPUSH
62013: LD_INT 10
62015: PPUSH
62016: LD_INT 0
62018: PPUSH
62019: CALL_OW 50
// continue ;
62023: GO 61924
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
62025: LD_VAR 0 12
62029: PUSH
62030: LD_INT 1
62032: ARRAY
62033: PPUSH
62034: CALL_OW 313
62038: PUSH
62039: LD_VAR 0 12
62043: PUSH
62044: LD_INT 1
62046: ARRAY
62047: PPUSH
62048: CALL_OW 266
62052: PUSH
62053: LD_INT 32
62055: PUSH
62056: LD_INT 31
62058: PUSH
62059: EMPTY
62060: LIST
62061: LIST
62062: IN
62063: AND
62064: PUSH
62065: LD_VAR 0 12
62069: PUSH
62070: LD_INT 1
62072: ARRAY
62073: PPUSH
62074: CALL_OW 313
62078: PUSH
62079: LD_INT 6
62081: EQUAL
62082: OR
62083: IFFALSE 62103
// f := Delete ( f , 1 ) ;
62085: LD_ADDR_VAR 0 12
62089: PUSH
62090: LD_VAR 0 12
62094: PPUSH
62095: LD_INT 1
62097: PPUSH
62098: CALL_OW 3
62102: ST_TO_ADDR
// if not f then
62103: LD_VAR 0 12
62107: NOT
62108: IFFALSE 62126
// begin x := x + 2 ;
62110: LD_ADDR_VAR 0 13
62114: PUSH
62115: LD_VAR 0 13
62119: PUSH
62120: LD_INT 2
62122: PLUS
62123: ST_TO_ADDR
// continue ;
62124: GO 61924
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
62126: LD_VAR 0 12
62130: PUSH
62131: LD_INT 1
62133: ARRAY
62134: PPUSH
62135: CALL_OW 266
62139: PUSH
62140: LD_INT 5
62142: EQUAL
62143: IFFALSE 62217
// begin if UnitsInside ( f [ 1 ] ) < 3 then
62145: LD_VAR 0 12
62149: PUSH
62150: LD_INT 1
62152: ARRAY
62153: PPUSH
62154: CALL_OW 313
62158: PUSH
62159: LD_INT 3
62161: LESS
62162: IFFALSE 62198
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
62164: LD_INT 0
62166: PPUSH
62167: LD_INT 5
62169: PUSH
62170: LD_INT 8
62172: PUSH
62173: LD_INT 9
62175: PUSH
62176: EMPTY
62177: LIST
62178: LIST
62179: LIST
62180: PUSH
62181: LD_VAR 0 17
62185: ARRAY
62186: PPUSH
62187: LD_VAR 0 4
62191: PPUSH
62192: CALL_OW 380
62196: GO 62215
// PrepareHuman ( false , i , skill ) ;
62198: LD_INT 0
62200: PPUSH
62201: LD_VAR 0 8
62205: PPUSH
62206: LD_VAR 0 4
62210: PPUSH
62211: CALL_OW 380
// end else
62215: GO 62234
// PrepareHuman ( false , i , skill ) ;
62217: LD_INT 0
62219: PPUSH
62220: LD_VAR 0 8
62224: PPUSH
62225: LD_VAR 0 4
62229: PPUSH
62230: CALL_OW 380
// un := CreateHuman ;
62234: LD_ADDR_VAR 0 14
62238: PUSH
62239: CALL_OW 44
62243: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
62244: LD_ADDR_VAR 0 7
62248: PUSH
62249: LD_VAR 0 7
62253: PPUSH
62254: LD_INT 1
62256: PPUSH
62257: LD_VAR 0 14
62261: PPUSH
62262: CALL_OW 2
62266: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
62267: LD_VAR 0 14
62271: PPUSH
62272: LD_VAR 0 12
62276: PUSH
62277: LD_INT 1
62279: ARRAY
62280: PPUSH
62281: CALL_OW 52
// end ;
62285: GO 61924
62287: POP
62288: POP
// end ;
62289: GO 61226
62291: POP
62292: POP
// result := result ^ buildings ;
62293: LD_ADDR_VAR 0 7
62297: PUSH
62298: LD_VAR 0 7
62302: PUSH
62303: LD_VAR 0 18
62307: ADD
62308: ST_TO_ADDR
// end else
62309: GO 62452
// begin for i = 1 to personel do
62311: LD_ADDR_VAR 0 8
62315: PUSH
62316: DOUBLE
62317: LD_INT 1
62319: DEC
62320: ST_TO_ADDR
62321: LD_VAR 0 6
62325: PUSH
62326: FOR_TO
62327: IFFALSE 62450
// begin if i > 4 then
62329: LD_VAR 0 8
62333: PUSH
62334: LD_INT 4
62336: GREATER
62337: IFFALSE 62341
// break ;
62339: GO 62450
// x := personel [ i ] ;
62341: LD_ADDR_VAR 0 13
62345: PUSH
62346: LD_VAR 0 6
62350: PUSH
62351: LD_VAR 0 8
62355: ARRAY
62356: ST_TO_ADDR
// if x = - 1 then
62357: LD_VAR 0 13
62361: PUSH
62362: LD_INT 1
62364: NEG
62365: EQUAL
62366: IFFALSE 62370
// continue ;
62368: GO 62326
// PrepareHuman ( false , i , skill ) ;
62370: LD_INT 0
62372: PPUSH
62373: LD_VAR 0 8
62377: PPUSH
62378: LD_VAR 0 4
62382: PPUSH
62383: CALL_OW 380
// un := CreateHuman ;
62387: LD_ADDR_VAR 0 14
62391: PUSH
62392: CALL_OW 44
62396: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
62397: LD_VAR 0 14
62401: PPUSH
62402: LD_VAR 0 1
62406: PPUSH
62407: CALL_OW 250
62411: PPUSH
62412: LD_VAR 0 1
62416: PPUSH
62417: CALL_OW 251
62421: PPUSH
62422: LD_INT 10
62424: PPUSH
62425: LD_INT 0
62427: PPUSH
62428: CALL_OW 50
// result := result ^ un ;
62432: LD_ADDR_VAR 0 7
62436: PUSH
62437: LD_VAR 0 7
62441: PUSH
62442: LD_VAR 0 14
62446: ADD
62447: ST_TO_ADDR
// end ;
62448: GO 62326
62450: POP
62451: POP
// end ; end ;
62452: LD_VAR 0 7
62456: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
62457: LD_INT 0
62459: PPUSH
62460: PPUSH
62461: PPUSH
62462: PPUSH
62463: PPUSH
62464: PPUSH
62465: PPUSH
62466: PPUSH
62467: PPUSH
62468: PPUSH
62469: PPUSH
62470: PPUSH
62471: PPUSH
62472: PPUSH
62473: PPUSH
62474: PPUSH
// result := false ;
62475: LD_ADDR_VAR 0 3
62479: PUSH
62480: LD_INT 0
62482: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
62483: LD_VAR 0 1
62487: NOT
62488: PUSH
62489: LD_VAR 0 1
62493: PPUSH
62494: CALL_OW 266
62498: PUSH
62499: LD_INT 32
62501: PUSH
62502: LD_INT 33
62504: PUSH
62505: EMPTY
62506: LIST
62507: LIST
62508: IN
62509: NOT
62510: OR
62511: IFFALSE 62515
// exit ;
62513: GO 63651
// nat := GetNation ( tower ) ;
62515: LD_ADDR_VAR 0 12
62519: PUSH
62520: LD_VAR 0 1
62524: PPUSH
62525: CALL_OW 248
62529: ST_TO_ADDR
// side := GetSide ( tower ) ;
62530: LD_ADDR_VAR 0 16
62534: PUSH
62535: LD_VAR 0 1
62539: PPUSH
62540: CALL_OW 255
62544: ST_TO_ADDR
// x := GetX ( tower ) ;
62545: LD_ADDR_VAR 0 10
62549: PUSH
62550: LD_VAR 0 1
62554: PPUSH
62555: CALL_OW 250
62559: ST_TO_ADDR
// y := GetY ( tower ) ;
62560: LD_ADDR_VAR 0 11
62564: PUSH
62565: LD_VAR 0 1
62569: PPUSH
62570: CALL_OW 251
62574: ST_TO_ADDR
// if not x or not y then
62575: LD_VAR 0 10
62579: NOT
62580: PUSH
62581: LD_VAR 0 11
62585: NOT
62586: OR
62587: IFFALSE 62591
// exit ;
62589: GO 63651
// weapon := 0 ;
62591: LD_ADDR_VAR 0 18
62595: PUSH
62596: LD_INT 0
62598: ST_TO_ADDR
// fac_list := [ ] ;
62599: LD_ADDR_VAR 0 17
62603: PUSH
62604: EMPTY
62605: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
62606: LD_ADDR_VAR 0 6
62610: PUSH
62611: LD_VAR 0 1
62615: PPUSH
62616: CALL_OW 274
62620: PPUSH
62621: LD_VAR 0 2
62625: PPUSH
62626: CALL 60229 0 2
62630: PPUSH
62631: LD_INT 30
62633: PUSH
62634: LD_INT 3
62636: PUSH
62637: EMPTY
62638: LIST
62639: LIST
62640: PPUSH
62641: CALL_OW 72
62645: ST_TO_ADDR
// if not factories then
62646: LD_VAR 0 6
62650: NOT
62651: IFFALSE 62655
// exit ;
62653: GO 63651
// for i in factories do
62655: LD_ADDR_VAR 0 8
62659: PUSH
62660: LD_VAR 0 6
62664: PUSH
62665: FOR_IN
62666: IFFALSE 62691
// fac_list := fac_list union AvailableWeaponList ( i ) ;
62668: LD_ADDR_VAR 0 17
62672: PUSH
62673: LD_VAR 0 17
62677: PUSH
62678: LD_VAR 0 8
62682: PPUSH
62683: CALL_OW 478
62687: UNION
62688: ST_TO_ADDR
62689: GO 62665
62691: POP
62692: POP
// if not fac_list then
62693: LD_VAR 0 17
62697: NOT
62698: IFFALSE 62702
// exit ;
62700: GO 63651
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
62702: LD_ADDR_VAR 0 5
62706: PUSH
62707: LD_INT 4
62709: PUSH
62710: LD_INT 5
62712: PUSH
62713: LD_INT 9
62715: PUSH
62716: LD_INT 10
62718: PUSH
62719: LD_INT 6
62721: PUSH
62722: LD_INT 7
62724: PUSH
62725: LD_INT 11
62727: PUSH
62728: EMPTY
62729: LIST
62730: LIST
62731: LIST
62732: LIST
62733: LIST
62734: LIST
62735: LIST
62736: PUSH
62737: LD_INT 27
62739: PUSH
62740: LD_INT 28
62742: PUSH
62743: LD_INT 26
62745: PUSH
62746: LD_INT 30
62748: PUSH
62749: EMPTY
62750: LIST
62751: LIST
62752: LIST
62753: LIST
62754: PUSH
62755: LD_INT 43
62757: PUSH
62758: LD_INT 44
62760: PUSH
62761: LD_INT 46
62763: PUSH
62764: LD_INT 45
62766: PUSH
62767: LD_INT 47
62769: PUSH
62770: LD_INT 49
62772: PUSH
62773: EMPTY
62774: LIST
62775: LIST
62776: LIST
62777: LIST
62778: LIST
62779: LIST
62780: PUSH
62781: EMPTY
62782: LIST
62783: LIST
62784: LIST
62785: PUSH
62786: LD_VAR 0 12
62790: ARRAY
62791: ST_TO_ADDR
// for i in list do
62792: LD_ADDR_VAR 0 8
62796: PUSH
62797: LD_VAR 0 5
62801: PUSH
62802: FOR_IN
62803: IFFALSE 62836
// if not i in fac_list then
62805: LD_VAR 0 8
62809: PUSH
62810: LD_VAR 0 17
62814: IN
62815: NOT
62816: IFFALSE 62834
// list := list diff i ;
62818: LD_ADDR_VAR 0 5
62822: PUSH
62823: LD_VAR 0 5
62827: PUSH
62828: LD_VAR 0 8
62832: DIFF
62833: ST_TO_ADDR
62834: GO 62802
62836: POP
62837: POP
// if not list then
62838: LD_VAR 0 5
62842: NOT
62843: IFFALSE 62847
// exit ;
62845: GO 63651
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
62847: LD_VAR 0 12
62851: PUSH
62852: LD_INT 3
62854: EQUAL
62855: PUSH
62856: LD_INT 49
62858: PUSH
62859: LD_VAR 0 5
62863: IN
62864: AND
62865: PUSH
62866: LD_INT 31
62868: PPUSH
62869: LD_VAR 0 16
62873: PPUSH
62874: CALL_OW 321
62878: PUSH
62879: LD_INT 2
62881: EQUAL
62882: AND
62883: IFFALSE 62943
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
62885: LD_INT 22
62887: PUSH
62888: LD_VAR 0 16
62892: PUSH
62893: EMPTY
62894: LIST
62895: LIST
62896: PUSH
62897: LD_INT 35
62899: PUSH
62900: LD_INT 49
62902: PUSH
62903: EMPTY
62904: LIST
62905: LIST
62906: PUSH
62907: LD_INT 91
62909: PUSH
62910: LD_VAR 0 1
62914: PUSH
62915: LD_INT 10
62917: PUSH
62918: EMPTY
62919: LIST
62920: LIST
62921: LIST
62922: PUSH
62923: EMPTY
62924: LIST
62925: LIST
62926: LIST
62927: PPUSH
62928: CALL_OW 69
62932: NOT
62933: IFFALSE 62943
// weapon := ru_time_lapser ;
62935: LD_ADDR_VAR 0 18
62939: PUSH
62940: LD_INT 49
62942: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
62943: LD_VAR 0 12
62947: PUSH
62948: LD_INT 1
62950: PUSH
62951: LD_INT 2
62953: PUSH
62954: EMPTY
62955: LIST
62956: LIST
62957: IN
62958: PUSH
62959: LD_INT 11
62961: PUSH
62962: LD_VAR 0 5
62966: IN
62967: PUSH
62968: LD_INT 30
62970: PUSH
62971: LD_VAR 0 5
62975: IN
62976: OR
62977: AND
62978: PUSH
62979: LD_INT 6
62981: PPUSH
62982: LD_VAR 0 16
62986: PPUSH
62987: CALL_OW 321
62991: PUSH
62992: LD_INT 2
62994: EQUAL
62995: AND
62996: IFFALSE 63161
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
62998: LD_INT 22
63000: PUSH
63001: LD_VAR 0 16
63005: PUSH
63006: EMPTY
63007: LIST
63008: LIST
63009: PUSH
63010: LD_INT 2
63012: PUSH
63013: LD_INT 35
63015: PUSH
63016: LD_INT 11
63018: PUSH
63019: EMPTY
63020: LIST
63021: LIST
63022: PUSH
63023: LD_INT 35
63025: PUSH
63026: LD_INT 30
63028: PUSH
63029: EMPTY
63030: LIST
63031: LIST
63032: PUSH
63033: EMPTY
63034: LIST
63035: LIST
63036: LIST
63037: PUSH
63038: LD_INT 91
63040: PUSH
63041: LD_VAR 0 1
63045: PUSH
63046: LD_INT 18
63048: PUSH
63049: EMPTY
63050: LIST
63051: LIST
63052: LIST
63053: PUSH
63054: EMPTY
63055: LIST
63056: LIST
63057: LIST
63058: PPUSH
63059: CALL_OW 69
63063: NOT
63064: PUSH
63065: LD_INT 22
63067: PUSH
63068: LD_VAR 0 16
63072: PUSH
63073: EMPTY
63074: LIST
63075: LIST
63076: PUSH
63077: LD_INT 2
63079: PUSH
63080: LD_INT 30
63082: PUSH
63083: LD_INT 32
63085: PUSH
63086: EMPTY
63087: LIST
63088: LIST
63089: PUSH
63090: LD_INT 30
63092: PUSH
63093: LD_INT 33
63095: PUSH
63096: EMPTY
63097: LIST
63098: LIST
63099: PUSH
63100: EMPTY
63101: LIST
63102: LIST
63103: LIST
63104: PUSH
63105: LD_INT 91
63107: PUSH
63108: LD_VAR 0 1
63112: PUSH
63113: LD_INT 12
63115: PUSH
63116: EMPTY
63117: LIST
63118: LIST
63119: LIST
63120: PUSH
63121: EMPTY
63122: LIST
63123: LIST
63124: LIST
63125: PUSH
63126: EMPTY
63127: LIST
63128: PPUSH
63129: CALL_OW 69
63133: PUSH
63134: LD_INT 2
63136: GREATER
63137: AND
63138: IFFALSE 63161
// weapon := [ us_radar , ar_radar ] [ nat ] ;
63140: LD_ADDR_VAR 0 18
63144: PUSH
63145: LD_INT 11
63147: PUSH
63148: LD_INT 30
63150: PUSH
63151: EMPTY
63152: LIST
63153: LIST
63154: PUSH
63155: LD_VAR 0 12
63159: ARRAY
63160: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
63161: LD_VAR 0 18
63165: NOT
63166: PUSH
63167: LD_INT 40
63169: PPUSH
63170: LD_VAR 0 16
63174: PPUSH
63175: CALL_OW 321
63179: PUSH
63180: LD_INT 2
63182: EQUAL
63183: AND
63184: PUSH
63185: LD_INT 7
63187: PUSH
63188: LD_VAR 0 5
63192: IN
63193: PUSH
63194: LD_INT 28
63196: PUSH
63197: LD_VAR 0 5
63201: IN
63202: OR
63203: PUSH
63204: LD_INT 45
63206: PUSH
63207: LD_VAR 0 5
63211: IN
63212: OR
63213: AND
63214: IFFALSE 63468
// begin hex := GetHexInfo ( x , y ) ;
63216: LD_ADDR_VAR 0 4
63220: PUSH
63221: LD_VAR 0 10
63225: PPUSH
63226: LD_VAR 0 11
63230: PPUSH
63231: CALL_OW 546
63235: ST_TO_ADDR
// if hex [ 1 ] then
63236: LD_VAR 0 4
63240: PUSH
63241: LD_INT 1
63243: ARRAY
63244: IFFALSE 63248
// exit ;
63246: GO 63651
// height := hex [ 2 ] ;
63248: LD_ADDR_VAR 0 15
63252: PUSH
63253: LD_VAR 0 4
63257: PUSH
63258: LD_INT 2
63260: ARRAY
63261: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
63262: LD_ADDR_VAR 0 14
63266: PUSH
63267: LD_INT 0
63269: PUSH
63270: LD_INT 2
63272: PUSH
63273: LD_INT 3
63275: PUSH
63276: LD_INT 5
63278: PUSH
63279: EMPTY
63280: LIST
63281: LIST
63282: LIST
63283: LIST
63284: ST_TO_ADDR
// for i in tmp do
63285: LD_ADDR_VAR 0 8
63289: PUSH
63290: LD_VAR 0 14
63294: PUSH
63295: FOR_IN
63296: IFFALSE 63466
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
63298: LD_ADDR_VAR 0 9
63302: PUSH
63303: LD_VAR 0 10
63307: PPUSH
63308: LD_VAR 0 8
63312: PPUSH
63313: LD_INT 5
63315: PPUSH
63316: CALL_OW 272
63320: PUSH
63321: LD_VAR 0 11
63325: PPUSH
63326: LD_VAR 0 8
63330: PPUSH
63331: LD_INT 5
63333: PPUSH
63334: CALL_OW 273
63338: PUSH
63339: EMPTY
63340: LIST
63341: LIST
63342: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
63343: LD_VAR 0 9
63347: PUSH
63348: LD_INT 1
63350: ARRAY
63351: PPUSH
63352: LD_VAR 0 9
63356: PUSH
63357: LD_INT 2
63359: ARRAY
63360: PPUSH
63361: CALL_OW 488
63365: IFFALSE 63464
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
63367: LD_ADDR_VAR 0 4
63371: PUSH
63372: LD_VAR 0 9
63376: PUSH
63377: LD_INT 1
63379: ARRAY
63380: PPUSH
63381: LD_VAR 0 9
63385: PUSH
63386: LD_INT 2
63388: ARRAY
63389: PPUSH
63390: CALL_OW 546
63394: ST_TO_ADDR
// if hex [ 1 ] then
63395: LD_VAR 0 4
63399: PUSH
63400: LD_INT 1
63402: ARRAY
63403: IFFALSE 63407
// continue ;
63405: GO 63295
// h := hex [ 2 ] ;
63407: LD_ADDR_VAR 0 13
63411: PUSH
63412: LD_VAR 0 4
63416: PUSH
63417: LD_INT 2
63419: ARRAY
63420: ST_TO_ADDR
// if h + 7 < height then
63421: LD_VAR 0 13
63425: PUSH
63426: LD_INT 7
63428: PLUS
63429: PUSH
63430: LD_VAR 0 15
63434: LESS
63435: IFFALSE 63464
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
63437: LD_ADDR_VAR 0 18
63441: PUSH
63442: LD_INT 7
63444: PUSH
63445: LD_INT 28
63447: PUSH
63448: LD_INT 45
63450: PUSH
63451: EMPTY
63452: LIST
63453: LIST
63454: LIST
63455: PUSH
63456: LD_VAR 0 12
63460: ARRAY
63461: ST_TO_ADDR
// break ;
63462: GO 63466
// end ; end ; end ;
63464: GO 63295
63466: POP
63467: POP
// end ; if not weapon then
63468: LD_VAR 0 18
63472: NOT
63473: IFFALSE 63533
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
63475: LD_ADDR_VAR 0 5
63479: PUSH
63480: LD_VAR 0 5
63484: PUSH
63485: LD_INT 11
63487: PUSH
63488: LD_INT 30
63490: PUSH
63491: LD_INT 49
63493: PUSH
63494: EMPTY
63495: LIST
63496: LIST
63497: LIST
63498: DIFF
63499: ST_TO_ADDR
// if not list then
63500: LD_VAR 0 5
63504: NOT
63505: IFFALSE 63509
// exit ;
63507: GO 63651
// weapon := list [ rand ( 1 , list ) ] ;
63509: LD_ADDR_VAR 0 18
63513: PUSH
63514: LD_VAR 0 5
63518: PUSH
63519: LD_INT 1
63521: PPUSH
63522: LD_VAR 0 5
63526: PPUSH
63527: CALL_OW 12
63531: ARRAY
63532: ST_TO_ADDR
// end ; if weapon then
63533: LD_VAR 0 18
63537: IFFALSE 63651
// begin tmp := CostOfWeapon ( weapon ) ;
63539: LD_ADDR_VAR 0 14
63543: PUSH
63544: LD_VAR 0 18
63548: PPUSH
63549: CALL_OW 451
63553: ST_TO_ADDR
// j := GetBase ( tower ) ;
63554: LD_ADDR_VAR 0 9
63558: PUSH
63559: LD_VAR 0 1
63563: PPUSH
63564: CALL_OW 274
63568: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
63569: LD_VAR 0 9
63573: PPUSH
63574: LD_INT 1
63576: PPUSH
63577: CALL_OW 275
63581: PUSH
63582: LD_VAR 0 14
63586: PUSH
63587: LD_INT 1
63589: ARRAY
63590: GREATEREQUAL
63591: PUSH
63592: LD_VAR 0 9
63596: PPUSH
63597: LD_INT 2
63599: PPUSH
63600: CALL_OW 275
63604: PUSH
63605: LD_VAR 0 14
63609: PUSH
63610: LD_INT 2
63612: ARRAY
63613: GREATEREQUAL
63614: AND
63615: PUSH
63616: LD_VAR 0 9
63620: PPUSH
63621: LD_INT 3
63623: PPUSH
63624: CALL_OW 275
63628: PUSH
63629: LD_VAR 0 14
63633: PUSH
63634: LD_INT 3
63636: ARRAY
63637: GREATEREQUAL
63638: AND
63639: IFFALSE 63651
// result := weapon ;
63641: LD_ADDR_VAR 0 3
63645: PUSH
63646: LD_VAR 0 18
63650: ST_TO_ADDR
// end ; end ;
63651: LD_VAR 0 3
63655: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
63656: LD_INT 0
63658: PPUSH
63659: PPUSH
// result := true ;
63660: LD_ADDR_VAR 0 3
63664: PUSH
63665: LD_INT 1
63667: ST_TO_ADDR
// if array1 = array2 then
63668: LD_VAR 0 1
63672: PUSH
63673: LD_VAR 0 2
63677: EQUAL
63678: IFFALSE 63738
// begin for i = 1 to array1 do
63680: LD_ADDR_VAR 0 4
63684: PUSH
63685: DOUBLE
63686: LD_INT 1
63688: DEC
63689: ST_TO_ADDR
63690: LD_VAR 0 1
63694: PUSH
63695: FOR_TO
63696: IFFALSE 63734
// if array1 [ i ] <> array2 [ i ] then
63698: LD_VAR 0 1
63702: PUSH
63703: LD_VAR 0 4
63707: ARRAY
63708: PUSH
63709: LD_VAR 0 2
63713: PUSH
63714: LD_VAR 0 4
63718: ARRAY
63719: NONEQUAL
63720: IFFALSE 63732
// begin result := false ;
63722: LD_ADDR_VAR 0 3
63726: PUSH
63727: LD_INT 0
63729: ST_TO_ADDR
// break ;
63730: GO 63734
// end ;
63732: GO 63695
63734: POP
63735: POP
// end else
63736: GO 63746
// result := false ;
63738: LD_ADDR_VAR 0 3
63742: PUSH
63743: LD_INT 0
63745: ST_TO_ADDR
// end ;
63746: LD_VAR 0 3
63750: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
63751: LD_INT 0
63753: PPUSH
63754: PPUSH
63755: PPUSH
// pom := GetBase ( fac ) ;
63756: LD_ADDR_VAR 0 5
63760: PUSH
63761: LD_VAR 0 1
63765: PPUSH
63766: CALL_OW 274
63770: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
63771: LD_ADDR_VAR 0 4
63775: PUSH
63776: LD_VAR 0 2
63780: PUSH
63781: LD_INT 1
63783: ARRAY
63784: PPUSH
63785: LD_VAR 0 2
63789: PUSH
63790: LD_INT 2
63792: ARRAY
63793: PPUSH
63794: LD_VAR 0 2
63798: PUSH
63799: LD_INT 3
63801: ARRAY
63802: PPUSH
63803: LD_VAR 0 2
63807: PUSH
63808: LD_INT 4
63810: ARRAY
63811: PPUSH
63812: CALL_OW 449
63816: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63817: LD_ADDR_VAR 0 3
63821: PUSH
63822: LD_VAR 0 5
63826: PPUSH
63827: LD_INT 1
63829: PPUSH
63830: CALL_OW 275
63834: PUSH
63835: LD_VAR 0 4
63839: PUSH
63840: LD_INT 1
63842: ARRAY
63843: GREATEREQUAL
63844: PUSH
63845: LD_VAR 0 5
63849: PPUSH
63850: LD_INT 2
63852: PPUSH
63853: CALL_OW 275
63857: PUSH
63858: LD_VAR 0 4
63862: PUSH
63863: LD_INT 2
63865: ARRAY
63866: GREATEREQUAL
63867: AND
63868: PUSH
63869: LD_VAR 0 5
63873: PPUSH
63874: LD_INT 3
63876: PPUSH
63877: CALL_OW 275
63881: PUSH
63882: LD_VAR 0 4
63886: PUSH
63887: LD_INT 3
63889: ARRAY
63890: GREATEREQUAL
63891: AND
63892: ST_TO_ADDR
// end ;
63893: LD_VAR 0 3
63897: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
63898: LD_INT 0
63900: PPUSH
63901: PPUSH
63902: PPUSH
63903: PPUSH
// pom := GetBase ( building ) ;
63904: LD_ADDR_VAR 0 3
63908: PUSH
63909: LD_VAR 0 1
63913: PPUSH
63914: CALL_OW 274
63918: ST_TO_ADDR
// if not pom then
63919: LD_VAR 0 3
63923: NOT
63924: IFFALSE 63928
// exit ;
63926: GO 64098
// btype := GetBType ( building ) ;
63928: LD_ADDR_VAR 0 5
63932: PUSH
63933: LD_VAR 0 1
63937: PPUSH
63938: CALL_OW 266
63942: ST_TO_ADDR
// if btype = b_armoury then
63943: LD_VAR 0 5
63947: PUSH
63948: LD_INT 4
63950: EQUAL
63951: IFFALSE 63961
// btype := b_barracks ;
63953: LD_ADDR_VAR 0 5
63957: PUSH
63958: LD_INT 5
63960: ST_TO_ADDR
// if btype = b_depot then
63961: LD_VAR 0 5
63965: PUSH
63966: LD_INT 0
63968: EQUAL
63969: IFFALSE 63979
// btype := b_warehouse ;
63971: LD_ADDR_VAR 0 5
63975: PUSH
63976: LD_INT 1
63978: ST_TO_ADDR
// if btype = b_workshop then
63979: LD_VAR 0 5
63983: PUSH
63984: LD_INT 2
63986: EQUAL
63987: IFFALSE 63997
// btype := b_factory ;
63989: LD_ADDR_VAR 0 5
63993: PUSH
63994: LD_INT 3
63996: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
63997: LD_ADDR_VAR 0 4
64001: PUSH
64002: LD_VAR 0 5
64006: PPUSH
64007: LD_VAR 0 1
64011: PPUSH
64012: CALL_OW 248
64016: PPUSH
64017: CALL_OW 450
64021: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
64022: LD_ADDR_VAR 0 2
64026: PUSH
64027: LD_VAR 0 3
64031: PPUSH
64032: LD_INT 1
64034: PPUSH
64035: CALL_OW 275
64039: PUSH
64040: LD_VAR 0 4
64044: PUSH
64045: LD_INT 1
64047: ARRAY
64048: GREATEREQUAL
64049: PUSH
64050: LD_VAR 0 3
64054: PPUSH
64055: LD_INT 2
64057: PPUSH
64058: CALL_OW 275
64062: PUSH
64063: LD_VAR 0 4
64067: PUSH
64068: LD_INT 2
64070: ARRAY
64071: GREATEREQUAL
64072: AND
64073: PUSH
64074: LD_VAR 0 3
64078: PPUSH
64079: LD_INT 3
64081: PPUSH
64082: CALL_OW 275
64086: PUSH
64087: LD_VAR 0 4
64091: PUSH
64092: LD_INT 3
64094: ARRAY
64095: GREATEREQUAL
64096: AND
64097: ST_TO_ADDR
// end ;
64098: LD_VAR 0 2
64102: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
64103: LD_INT 0
64105: PPUSH
64106: PPUSH
64107: PPUSH
// pom := GetBase ( building ) ;
64108: LD_ADDR_VAR 0 4
64112: PUSH
64113: LD_VAR 0 1
64117: PPUSH
64118: CALL_OW 274
64122: ST_TO_ADDR
// if not pom then
64123: LD_VAR 0 4
64127: NOT
64128: IFFALSE 64132
// exit ;
64130: GO 64233
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
64132: LD_ADDR_VAR 0 5
64136: PUSH
64137: LD_VAR 0 2
64141: PPUSH
64142: LD_VAR 0 1
64146: PPUSH
64147: CALL_OW 248
64151: PPUSH
64152: CALL_OW 450
64156: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
64157: LD_ADDR_VAR 0 3
64161: PUSH
64162: LD_VAR 0 4
64166: PPUSH
64167: LD_INT 1
64169: PPUSH
64170: CALL_OW 275
64174: PUSH
64175: LD_VAR 0 5
64179: PUSH
64180: LD_INT 1
64182: ARRAY
64183: GREATEREQUAL
64184: PUSH
64185: LD_VAR 0 4
64189: PPUSH
64190: LD_INT 2
64192: PPUSH
64193: CALL_OW 275
64197: PUSH
64198: LD_VAR 0 5
64202: PUSH
64203: LD_INT 2
64205: ARRAY
64206: GREATEREQUAL
64207: AND
64208: PUSH
64209: LD_VAR 0 4
64213: PPUSH
64214: LD_INT 3
64216: PPUSH
64217: CALL_OW 275
64221: PUSH
64222: LD_VAR 0 5
64226: PUSH
64227: LD_INT 3
64229: ARRAY
64230: GREATEREQUAL
64231: AND
64232: ST_TO_ADDR
// end ;
64233: LD_VAR 0 3
64237: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
64238: LD_INT 0
64240: PPUSH
64241: PPUSH
64242: PPUSH
64243: PPUSH
64244: PPUSH
64245: PPUSH
64246: PPUSH
64247: PPUSH
64248: PPUSH
64249: PPUSH
// result := false ;
64250: LD_ADDR_VAR 0 6
64254: PUSH
64255: LD_INT 0
64257: ST_TO_ADDR
// if not base or not btype or not x or not y then
64258: LD_VAR 0 1
64262: NOT
64263: PUSH
64264: LD_VAR 0 2
64268: NOT
64269: OR
64270: PUSH
64271: LD_VAR 0 3
64275: NOT
64276: OR
64277: PUSH
64278: LD_VAR 0 4
64282: NOT
64283: OR
64284: IFFALSE 64288
// exit ;
64286: GO 64897
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
64288: LD_ADDR_VAR 0 12
64292: PUSH
64293: LD_VAR 0 2
64297: PPUSH
64298: LD_VAR 0 3
64302: PPUSH
64303: LD_VAR 0 4
64307: PPUSH
64308: LD_VAR 0 5
64312: PPUSH
64313: LD_VAR 0 1
64317: PUSH
64318: LD_INT 1
64320: ARRAY
64321: PPUSH
64322: CALL_OW 248
64326: PPUSH
64327: LD_INT 0
64329: PPUSH
64330: CALL 65734 0 6
64334: ST_TO_ADDR
// if not hexes then
64335: LD_VAR 0 12
64339: NOT
64340: IFFALSE 64344
// exit ;
64342: GO 64897
// for i = 1 to hexes do
64344: LD_ADDR_VAR 0 7
64348: PUSH
64349: DOUBLE
64350: LD_INT 1
64352: DEC
64353: ST_TO_ADDR
64354: LD_VAR 0 12
64358: PUSH
64359: FOR_TO
64360: IFFALSE 64895
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
64362: LD_ADDR_VAR 0 11
64366: PUSH
64367: LD_VAR 0 12
64371: PUSH
64372: LD_VAR 0 7
64376: ARRAY
64377: PUSH
64378: LD_INT 1
64380: ARRAY
64381: PPUSH
64382: LD_VAR 0 12
64386: PUSH
64387: LD_VAR 0 7
64391: ARRAY
64392: PUSH
64393: LD_INT 2
64395: ARRAY
64396: PPUSH
64397: CALL_OW 428
64401: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
64402: LD_VAR 0 12
64406: PUSH
64407: LD_VAR 0 7
64411: ARRAY
64412: PUSH
64413: LD_INT 1
64415: ARRAY
64416: PPUSH
64417: LD_VAR 0 12
64421: PUSH
64422: LD_VAR 0 7
64426: ARRAY
64427: PUSH
64428: LD_INT 2
64430: ARRAY
64431: PPUSH
64432: CALL_OW 351
64436: PUSH
64437: LD_VAR 0 12
64441: PUSH
64442: LD_VAR 0 7
64446: ARRAY
64447: PUSH
64448: LD_INT 1
64450: ARRAY
64451: PPUSH
64452: LD_VAR 0 12
64456: PUSH
64457: LD_VAR 0 7
64461: ARRAY
64462: PUSH
64463: LD_INT 2
64465: ARRAY
64466: PPUSH
64467: CALL_OW 488
64471: NOT
64472: OR
64473: PUSH
64474: LD_VAR 0 11
64478: PPUSH
64479: CALL_OW 247
64483: PUSH
64484: LD_INT 3
64486: EQUAL
64487: OR
64488: IFFALSE 64494
// exit ;
64490: POP
64491: POP
64492: GO 64897
// if not tmp or not tmp in base then
64494: LD_VAR 0 11
64498: NOT
64499: PUSH
64500: LD_VAR 0 11
64504: PUSH
64505: LD_VAR 0 1
64509: IN
64510: NOT
64511: OR
64512: IFFALSE 64516
// continue ;
64514: GO 64359
// result := true ;
64516: LD_ADDR_VAR 0 6
64520: PUSH
64521: LD_INT 1
64523: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
64524: LD_ADDR_VAR 0 15
64528: PUSH
64529: LD_VAR 0 1
64533: PPUSH
64534: LD_INT 22
64536: PUSH
64537: LD_VAR 0 11
64541: PPUSH
64542: CALL_OW 255
64546: PUSH
64547: EMPTY
64548: LIST
64549: LIST
64550: PUSH
64551: LD_INT 2
64553: PUSH
64554: LD_INT 30
64556: PUSH
64557: LD_INT 0
64559: PUSH
64560: EMPTY
64561: LIST
64562: LIST
64563: PUSH
64564: LD_INT 30
64566: PUSH
64567: LD_INT 1
64569: PUSH
64570: EMPTY
64571: LIST
64572: LIST
64573: PUSH
64574: EMPTY
64575: LIST
64576: LIST
64577: LIST
64578: PUSH
64579: EMPTY
64580: LIST
64581: LIST
64582: PPUSH
64583: CALL_OW 72
64587: ST_TO_ADDR
// if dep then
64588: LD_VAR 0 15
64592: IFFALSE 64728
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
64594: LD_ADDR_VAR 0 14
64598: PUSH
64599: LD_VAR 0 15
64603: PUSH
64604: LD_INT 1
64606: ARRAY
64607: PPUSH
64608: CALL_OW 250
64612: PPUSH
64613: LD_VAR 0 15
64617: PUSH
64618: LD_INT 1
64620: ARRAY
64621: PPUSH
64622: CALL_OW 254
64626: PPUSH
64627: LD_INT 5
64629: PPUSH
64630: CALL_OW 272
64634: PUSH
64635: LD_VAR 0 15
64639: PUSH
64640: LD_INT 1
64642: ARRAY
64643: PPUSH
64644: CALL_OW 251
64648: PPUSH
64649: LD_VAR 0 15
64653: PUSH
64654: LD_INT 1
64656: ARRAY
64657: PPUSH
64658: CALL_OW 254
64662: PPUSH
64663: LD_INT 5
64665: PPUSH
64666: CALL_OW 273
64670: PUSH
64671: EMPTY
64672: LIST
64673: LIST
64674: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
64675: LD_VAR 0 14
64679: PUSH
64680: LD_INT 1
64682: ARRAY
64683: PPUSH
64684: LD_VAR 0 14
64688: PUSH
64689: LD_INT 2
64691: ARRAY
64692: PPUSH
64693: CALL_OW 488
64697: IFFALSE 64728
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
64699: LD_VAR 0 11
64703: PPUSH
64704: LD_VAR 0 14
64708: PUSH
64709: LD_INT 1
64711: ARRAY
64712: PPUSH
64713: LD_VAR 0 14
64717: PUSH
64718: LD_INT 2
64720: ARRAY
64721: PPUSH
64722: CALL_OW 111
// continue ;
64726: GO 64359
// end ; end ; r := GetDir ( tmp ) ;
64728: LD_ADDR_VAR 0 13
64732: PUSH
64733: LD_VAR 0 11
64737: PPUSH
64738: CALL_OW 254
64742: ST_TO_ADDR
// if r = 5 then
64743: LD_VAR 0 13
64747: PUSH
64748: LD_INT 5
64750: EQUAL
64751: IFFALSE 64761
// r := 0 ;
64753: LD_ADDR_VAR 0 13
64757: PUSH
64758: LD_INT 0
64760: ST_TO_ADDR
// for j = r to 5 do
64761: LD_ADDR_VAR 0 8
64765: PUSH
64766: DOUBLE
64767: LD_VAR 0 13
64771: DEC
64772: ST_TO_ADDR
64773: LD_INT 5
64775: PUSH
64776: FOR_TO
64777: IFFALSE 64891
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
64779: LD_ADDR_VAR 0 9
64783: PUSH
64784: LD_VAR 0 11
64788: PPUSH
64789: CALL_OW 250
64793: PPUSH
64794: LD_VAR 0 8
64798: PPUSH
64799: LD_INT 2
64801: PPUSH
64802: CALL_OW 272
64806: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
64807: LD_ADDR_VAR 0 10
64811: PUSH
64812: LD_VAR 0 11
64816: PPUSH
64817: CALL_OW 251
64821: PPUSH
64822: LD_VAR 0 8
64826: PPUSH
64827: LD_INT 2
64829: PPUSH
64830: CALL_OW 273
64834: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
64835: LD_VAR 0 9
64839: PPUSH
64840: LD_VAR 0 10
64844: PPUSH
64845: CALL_OW 488
64849: PUSH
64850: LD_VAR 0 9
64854: PPUSH
64855: LD_VAR 0 10
64859: PPUSH
64860: CALL_OW 428
64864: NOT
64865: AND
64866: IFFALSE 64889
// begin ComMoveXY ( tmp , _x , _y ) ;
64868: LD_VAR 0 11
64872: PPUSH
64873: LD_VAR 0 9
64877: PPUSH
64878: LD_VAR 0 10
64882: PPUSH
64883: CALL_OW 111
// break ;
64887: GO 64891
// end ; end ;
64889: GO 64776
64891: POP
64892: POP
// end ;
64893: GO 64359
64895: POP
64896: POP
// end ;
64897: LD_VAR 0 6
64901: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
64902: LD_INT 0
64904: PPUSH
64905: PPUSH
64906: PPUSH
64907: PPUSH
64908: PPUSH
64909: PPUSH
64910: PPUSH
64911: PPUSH
64912: PPUSH
64913: PPUSH
// result := false ;
64914: LD_ADDR_VAR 0 6
64918: PUSH
64919: LD_INT 0
64921: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
64922: LD_VAR 0 1
64926: NOT
64927: PUSH
64928: LD_VAR 0 1
64932: PPUSH
64933: CALL_OW 266
64937: PUSH
64938: LD_INT 0
64940: PUSH
64941: LD_INT 1
64943: PUSH
64944: EMPTY
64945: LIST
64946: LIST
64947: IN
64948: NOT
64949: OR
64950: PUSH
64951: LD_VAR 0 2
64955: NOT
64956: OR
64957: PUSH
64958: LD_VAR 0 5
64962: PUSH
64963: LD_INT 0
64965: PUSH
64966: LD_INT 1
64968: PUSH
64969: LD_INT 2
64971: PUSH
64972: LD_INT 3
64974: PUSH
64975: LD_INT 4
64977: PUSH
64978: LD_INT 5
64980: PUSH
64981: EMPTY
64982: LIST
64983: LIST
64984: LIST
64985: LIST
64986: LIST
64987: LIST
64988: IN
64989: NOT
64990: OR
64991: PUSH
64992: LD_VAR 0 3
64996: PPUSH
64997: LD_VAR 0 4
65001: PPUSH
65002: CALL_OW 488
65006: NOT
65007: OR
65008: IFFALSE 65012
// exit ;
65010: GO 65729
// pom := GetBase ( depot ) ;
65012: LD_ADDR_VAR 0 10
65016: PUSH
65017: LD_VAR 0 1
65021: PPUSH
65022: CALL_OW 274
65026: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
65027: LD_ADDR_VAR 0 11
65031: PUSH
65032: LD_VAR 0 2
65036: PPUSH
65037: LD_VAR 0 1
65041: PPUSH
65042: CALL_OW 248
65046: PPUSH
65047: CALL_OW 450
65051: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
65052: LD_VAR 0 10
65056: PPUSH
65057: LD_INT 1
65059: PPUSH
65060: CALL_OW 275
65064: PUSH
65065: LD_VAR 0 11
65069: PUSH
65070: LD_INT 1
65072: ARRAY
65073: GREATEREQUAL
65074: PUSH
65075: LD_VAR 0 10
65079: PPUSH
65080: LD_INT 2
65082: PPUSH
65083: CALL_OW 275
65087: PUSH
65088: LD_VAR 0 11
65092: PUSH
65093: LD_INT 2
65095: ARRAY
65096: GREATEREQUAL
65097: AND
65098: PUSH
65099: LD_VAR 0 10
65103: PPUSH
65104: LD_INT 3
65106: PPUSH
65107: CALL_OW 275
65111: PUSH
65112: LD_VAR 0 11
65116: PUSH
65117: LD_INT 3
65119: ARRAY
65120: GREATEREQUAL
65121: AND
65122: NOT
65123: IFFALSE 65127
// exit ;
65125: GO 65729
// if GetBType ( depot ) = b_depot then
65127: LD_VAR 0 1
65131: PPUSH
65132: CALL_OW 266
65136: PUSH
65137: LD_INT 0
65139: EQUAL
65140: IFFALSE 65152
// dist := 28 else
65142: LD_ADDR_VAR 0 14
65146: PUSH
65147: LD_INT 28
65149: ST_TO_ADDR
65150: GO 65160
// dist := 36 ;
65152: LD_ADDR_VAR 0 14
65156: PUSH
65157: LD_INT 36
65159: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
65160: LD_VAR 0 1
65164: PPUSH
65165: LD_VAR 0 3
65169: PPUSH
65170: LD_VAR 0 4
65174: PPUSH
65175: CALL_OW 297
65179: PUSH
65180: LD_VAR 0 14
65184: GREATER
65185: IFFALSE 65189
// exit ;
65187: GO 65729
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
65189: LD_ADDR_VAR 0 12
65193: PUSH
65194: LD_VAR 0 2
65198: PPUSH
65199: LD_VAR 0 3
65203: PPUSH
65204: LD_VAR 0 4
65208: PPUSH
65209: LD_VAR 0 5
65213: PPUSH
65214: LD_VAR 0 1
65218: PPUSH
65219: CALL_OW 248
65223: PPUSH
65224: LD_INT 0
65226: PPUSH
65227: CALL 65734 0 6
65231: ST_TO_ADDR
// if not hexes then
65232: LD_VAR 0 12
65236: NOT
65237: IFFALSE 65241
// exit ;
65239: GO 65729
// hex := GetHexInfo ( x , y ) ;
65241: LD_ADDR_VAR 0 15
65245: PUSH
65246: LD_VAR 0 3
65250: PPUSH
65251: LD_VAR 0 4
65255: PPUSH
65256: CALL_OW 546
65260: ST_TO_ADDR
// if hex [ 1 ] then
65261: LD_VAR 0 15
65265: PUSH
65266: LD_INT 1
65268: ARRAY
65269: IFFALSE 65273
// exit ;
65271: GO 65729
// height := hex [ 2 ] ;
65273: LD_ADDR_VAR 0 13
65277: PUSH
65278: LD_VAR 0 15
65282: PUSH
65283: LD_INT 2
65285: ARRAY
65286: ST_TO_ADDR
// for i = 1 to hexes do
65287: LD_ADDR_VAR 0 7
65291: PUSH
65292: DOUBLE
65293: LD_INT 1
65295: DEC
65296: ST_TO_ADDR
65297: LD_VAR 0 12
65301: PUSH
65302: FOR_TO
65303: IFFALSE 65633
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
65305: LD_VAR 0 12
65309: PUSH
65310: LD_VAR 0 7
65314: ARRAY
65315: PUSH
65316: LD_INT 1
65318: ARRAY
65319: PPUSH
65320: LD_VAR 0 12
65324: PUSH
65325: LD_VAR 0 7
65329: ARRAY
65330: PUSH
65331: LD_INT 2
65333: ARRAY
65334: PPUSH
65335: CALL_OW 488
65339: NOT
65340: PUSH
65341: LD_VAR 0 12
65345: PUSH
65346: LD_VAR 0 7
65350: ARRAY
65351: PUSH
65352: LD_INT 1
65354: ARRAY
65355: PPUSH
65356: LD_VAR 0 12
65360: PUSH
65361: LD_VAR 0 7
65365: ARRAY
65366: PUSH
65367: LD_INT 2
65369: ARRAY
65370: PPUSH
65371: CALL_OW 428
65375: PUSH
65376: LD_INT 0
65378: GREATER
65379: OR
65380: PUSH
65381: LD_VAR 0 12
65385: PUSH
65386: LD_VAR 0 7
65390: ARRAY
65391: PUSH
65392: LD_INT 1
65394: ARRAY
65395: PPUSH
65396: LD_VAR 0 12
65400: PUSH
65401: LD_VAR 0 7
65405: ARRAY
65406: PUSH
65407: LD_INT 2
65409: ARRAY
65410: PPUSH
65411: CALL_OW 351
65415: OR
65416: IFFALSE 65422
// exit ;
65418: POP
65419: POP
65420: GO 65729
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
65422: LD_ADDR_VAR 0 8
65426: PUSH
65427: LD_VAR 0 12
65431: PUSH
65432: LD_VAR 0 7
65436: ARRAY
65437: PUSH
65438: LD_INT 1
65440: ARRAY
65441: PPUSH
65442: LD_VAR 0 12
65446: PUSH
65447: LD_VAR 0 7
65451: ARRAY
65452: PUSH
65453: LD_INT 2
65455: ARRAY
65456: PPUSH
65457: CALL_OW 546
65461: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
65462: LD_VAR 0 8
65466: PUSH
65467: LD_INT 1
65469: ARRAY
65470: PUSH
65471: LD_VAR 0 8
65475: PUSH
65476: LD_INT 2
65478: ARRAY
65479: PUSH
65480: LD_VAR 0 13
65484: PUSH
65485: LD_INT 2
65487: PLUS
65488: GREATER
65489: OR
65490: PUSH
65491: LD_VAR 0 8
65495: PUSH
65496: LD_INT 2
65498: ARRAY
65499: PUSH
65500: LD_VAR 0 13
65504: PUSH
65505: LD_INT 2
65507: MINUS
65508: LESS
65509: OR
65510: PUSH
65511: LD_VAR 0 8
65515: PUSH
65516: LD_INT 3
65518: ARRAY
65519: PUSH
65520: LD_INT 0
65522: PUSH
65523: LD_INT 8
65525: PUSH
65526: LD_INT 9
65528: PUSH
65529: LD_INT 10
65531: PUSH
65532: LD_INT 11
65534: PUSH
65535: LD_INT 12
65537: PUSH
65538: LD_INT 13
65540: PUSH
65541: LD_INT 16
65543: PUSH
65544: LD_INT 17
65546: PUSH
65547: LD_INT 18
65549: PUSH
65550: LD_INT 19
65552: PUSH
65553: LD_INT 20
65555: PUSH
65556: LD_INT 21
65558: PUSH
65559: EMPTY
65560: LIST
65561: LIST
65562: LIST
65563: LIST
65564: LIST
65565: LIST
65566: LIST
65567: LIST
65568: LIST
65569: LIST
65570: LIST
65571: LIST
65572: LIST
65573: IN
65574: NOT
65575: OR
65576: PUSH
65577: LD_VAR 0 8
65581: PUSH
65582: LD_INT 5
65584: ARRAY
65585: NOT
65586: OR
65587: PUSH
65588: LD_VAR 0 8
65592: PUSH
65593: LD_INT 6
65595: ARRAY
65596: PUSH
65597: LD_INT 1
65599: PUSH
65600: LD_INT 2
65602: PUSH
65603: LD_INT 7
65605: PUSH
65606: LD_INT 9
65608: PUSH
65609: LD_INT 10
65611: PUSH
65612: LD_INT 11
65614: PUSH
65615: EMPTY
65616: LIST
65617: LIST
65618: LIST
65619: LIST
65620: LIST
65621: LIST
65622: IN
65623: NOT
65624: OR
65625: IFFALSE 65631
// exit ;
65627: POP
65628: POP
65629: GO 65729
// end ;
65631: GO 65302
65633: POP
65634: POP
// side := GetSide ( depot ) ;
65635: LD_ADDR_VAR 0 9
65639: PUSH
65640: LD_VAR 0 1
65644: PPUSH
65645: CALL_OW 255
65649: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
65650: LD_VAR 0 9
65654: PPUSH
65655: LD_VAR 0 3
65659: PPUSH
65660: LD_VAR 0 4
65664: PPUSH
65665: LD_INT 20
65667: PPUSH
65668: CALL 58383 0 4
65672: PUSH
65673: LD_INT 4
65675: ARRAY
65676: IFFALSE 65680
// exit ;
65678: GO 65729
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
65680: LD_VAR 0 2
65684: PUSH
65685: LD_INT 29
65687: PUSH
65688: LD_INT 30
65690: PUSH
65691: EMPTY
65692: LIST
65693: LIST
65694: IN
65695: PUSH
65696: LD_VAR 0 3
65700: PPUSH
65701: LD_VAR 0 4
65705: PPUSH
65706: LD_VAR 0 9
65710: PPUSH
65711: CALL_OW 440
65715: NOT
65716: AND
65717: IFFALSE 65721
// exit ;
65719: GO 65729
// result := true ;
65721: LD_ADDR_VAR 0 6
65725: PUSH
65726: LD_INT 1
65728: ST_TO_ADDR
// end ;
65729: LD_VAR 0 6
65733: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
65734: LD_INT 0
65736: PPUSH
65737: PPUSH
65738: PPUSH
65739: PPUSH
65740: PPUSH
65741: PPUSH
65742: PPUSH
65743: PPUSH
65744: PPUSH
65745: PPUSH
65746: PPUSH
65747: PPUSH
65748: PPUSH
65749: PPUSH
65750: PPUSH
65751: PPUSH
65752: PPUSH
65753: PPUSH
65754: PPUSH
65755: PPUSH
65756: PPUSH
65757: PPUSH
65758: PPUSH
65759: PPUSH
65760: PPUSH
65761: PPUSH
65762: PPUSH
65763: PPUSH
65764: PPUSH
65765: PPUSH
65766: PPUSH
65767: PPUSH
65768: PPUSH
65769: PPUSH
65770: PPUSH
65771: PPUSH
65772: PPUSH
65773: PPUSH
65774: PPUSH
65775: PPUSH
65776: PPUSH
65777: PPUSH
65778: PPUSH
65779: PPUSH
65780: PPUSH
65781: PPUSH
65782: PPUSH
65783: PPUSH
65784: PPUSH
65785: PPUSH
65786: PPUSH
65787: PPUSH
65788: PPUSH
65789: PPUSH
65790: PPUSH
65791: PPUSH
65792: PPUSH
65793: PPUSH
// result = [ ] ;
65794: LD_ADDR_VAR 0 7
65798: PUSH
65799: EMPTY
65800: ST_TO_ADDR
// temp_list = [ ] ;
65801: LD_ADDR_VAR 0 9
65805: PUSH
65806: EMPTY
65807: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
65808: LD_VAR 0 4
65812: PUSH
65813: LD_INT 0
65815: PUSH
65816: LD_INT 1
65818: PUSH
65819: LD_INT 2
65821: PUSH
65822: LD_INT 3
65824: PUSH
65825: LD_INT 4
65827: PUSH
65828: LD_INT 5
65830: PUSH
65831: EMPTY
65832: LIST
65833: LIST
65834: LIST
65835: LIST
65836: LIST
65837: LIST
65838: IN
65839: NOT
65840: PUSH
65841: LD_VAR 0 1
65845: PUSH
65846: LD_INT 0
65848: PUSH
65849: LD_INT 1
65851: PUSH
65852: EMPTY
65853: LIST
65854: LIST
65855: IN
65856: PUSH
65857: LD_VAR 0 5
65861: PUSH
65862: LD_INT 1
65864: PUSH
65865: LD_INT 2
65867: PUSH
65868: LD_INT 3
65870: PUSH
65871: EMPTY
65872: LIST
65873: LIST
65874: LIST
65875: IN
65876: NOT
65877: AND
65878: OR
65879: IFFALSE 65883
// exit ;
65881: GO 84274
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
65883: LD_VAR 0 1
65887: PUSH
65888: LD_INT 6
65890: PUSH
65891: LD_INT 7
65893: PUSH
65894: LD_INT 8
65896: PUSH
65897: LD_INT 13
65899: PUSH
65900: LD_INT 12
65902: PUSH
65903: LD_INT 15
65905: PUSH
65906: LD_INT 11
65908: PUSH
65909: LD_INT 14
65911: PUSH
65912: LD_INT 10
65914: PUSH
65915: EMPTY
65916: LIST
65917: LIST
65918: LIST
65919: LIST
65920: LIST
65921: LIST
65922: LIST
65923: LIST
65924: LIST
65925: IN
65926: IFFALSE 65936
// btype = b_lab ;
65928: LD_ADDR_VAR 0 1
65932: PUSH
65933: LD_INT 6
65935: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
65936: LD_VAR 0 6
65940: PUSH
65941: LD_INT 0
65943: PUSH
65944: LD_INT 1
65946: PUSH
65947: LD_INT 2
65949: PUSH
65950: EMPTY
65951: LIST
65952: LIST
65953: LIST
65954: IN
65955: NOT
65956: PUSH
65957: LD_VAR 0 1
65961: PUSH
65962: LD_INT 0
65964: PUSH
65965: LD_INT 1
65967: PUSH
65968: LD_INT 2
65970: PUSH
65971: LD_INT 3
65973: PUSH
65974: LD_INT 6
65976: PUSH
65977: LD_INT 36
65979: PUSH
65980: LD_INT 4
65982: PUSH
65983: LD_INT 5
65985: PUSH
65986: LD_INT 31
65988: PUSH
65989: LD_INT 32
65991: PUSH
65992: LD_INT 33
65994: PUSH
65995: EMPTY
65996: LIST
65997: LIST
65998: LIST
65999: LIST
66000: LIST
66001: LIST
66002: LIST
66003: LIST
66004: LIST
66005: LIST
66006: LIST
66007: IN
66008: NOT
66009: PUSH
66010: LD_VAR 0 6
66014: PUSH
66015: LD_INT 1
66017: EQUAL
66018: AND
66019: OR
66020: PUSH
66021: LD_VAR 0 1
66025: PUSH
66026: LD_INT 2
66028: PUSH
66029: LD_INT 3
66031: PUSH
66032: EMPTY
66033: LIST
66034: LIST
66035: IN
66036: NOT
66037: PUSH
66038: LD_VAR 0 6
66042: PUSH
66043: LD_INT 2
66045: EQUAL
66046: AND
66047: OR
66048: IFFALSE 66058
// mode = 0 ;
66050: LD_ADDR_VAR 0 6
66054: PUSH
66055: LD_INT 0
66057: ST_TO_ADDR
// case mode of 0 :
66058: LD_VAR 0 6
66062: PUSH
66063: LD_INT 0
66065: DOUBLE
66066: EQUAL
66067: IFTRUE 66071
66069: GO 77524
66071: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
66072: LD_ADDR_VAR 0 11
66076: PUSH
66077: LD_INT 0
66079: PUSH
66080: LD_INT 0
66082: PUSH
66083: EMPTY
66084: LIST
66085: LIST
66086: PUSH
66087: LD_INT 0
66089: PUSH
66090: LD_INT 1
66092: NEG
66093: PUSH
66094: EMPTY
66095: LIST
66096: LIST
66097: PUSH
66098: LD_INT 1
66100: PUSH
66101: LD_INT 0
66103: PUSH
66104: EMPTY
66105: LIST
66106: LIST
66107: PUSH
66108: LD_INT 1
66110: PUSH
66111: LD_INT 1
66113: PUSH
66114: EMPTY
66115: LIST
66116: LIST
66117: PUSH
66118: LD_INT 0
66120: PUSH
66121: LD_INT 1
66123: PUSH
66124: EMPTY
66125: LIST
66126: LIST
66127: PUSH
66128: LD_INT 1
66130: NEG
66131: PUSH
66132: LD_INT 0
66134: PUSH
66135: EMPTY
66136: LIST
66137: LIST
66138: PUSH
66139: LD_INT 1
66141: NEG
66142: PUSH
66143: LD_INT 1
66145: NEG
66146: PUSH
66147: EMPTY
66148: LIST
66149: LIST
66150: PUSH
66151: LD_INT 1
66153: NEG
66154: PUSH
66155: LD_INT 2
66157: NEG
66158: PUSH
66159: EMPTY
66160: LIST
66161: LIST
66162: PUSH
66163: LD_INT 0
66165: PUSH
66166: LD_INT 2
66168: NEG
66169: PUSH
66170: EMPTY
66171: LIST
66172: LIST
66173: PUSH
66174: LD_INT 1
66176: PUSH
66177: LD_INT 1
66179: NEG
66180: PUSH
66181: EMPTY
66182: LIST
66183: LIST
66184: PUSH
66185: LD_INT 1
66187: PUSH
66188: LD_INT 2
66190: PUSH
66191: EMPTY
66192: LIST
66193: LIST
66194: PUSH
66195: LD_INT 0
66197: PUSH
66198: LD_INT 2
66200: PUSH
66201: EMPTY
66202: LIST
66203: LIST
66204: PUSH
66205: LD_INT 1
66207: NEG
66208: PUSH
66209: LD_INT 1
66211: PUSH
66212: EMPTY
66213: LIST
66214: LIST
66215: PUSH
66216: LD_INT 1
66218: PUSH
66219: LD_INT 3
66221: PUSH
66222: EMPTY
66223: LIST
66224: LIST
66225: PUSH
66226: LD_INT 0
66228: PUSH
66229: LD_INT 3
66231: PUSH
66232: EMPTY
66233: LIST
66234: LIST
66235: PUSH
66236: LD_INT 1
66238: NEG
66239: PUSH
66240: LD_INT 2
66242: PUSH
66243: EMPTY
66244: LIST
66245: LIST
66246: PUSH
66247: EMPTY
66248: LIST
66249: LIST
66250: LIST
66251: LIST
66252: LIST
66253: LIST
66254: LIST
66255: LIST
66256: LIST
66257: LIST
66258: LIST
66259: LIST
66260: LIST
66261: LIST
66262: LIST
66263: LIST
66264: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
66265: LD_ADDR_VAR 0 12
66269: PUSH
66270: LD_INT 0
66272: PUSH
66273: LD_INT 0
66275: PUSH
66276: EMPTY
66277: LIST
66278: LIST
66279: PUSH
66280: LD_INT 0
66282: PUSH
66283: LD_INT 1
66285: NEG
66286: PUSH
66287: EMPTY
66288: LIST
66289: LIST
66290: PUSH
66291: LD_INT 1
66293: PUSH
66294: LD_INT 0
66296: PUSH
66297: EMPTY
66298: LIST
66299: LIST
66300: PUSH
66301: LD_INT 1
66303: PUSH
66304: LD_INT 1
66306: PUSH
66307: EMPTY
66308: LIST
66309: LIST
66310: PUSH
66311: LD_INT 0
66313: PUSH
66314: LD_INT 1
66316: PUSH
66317: EMPTY
66318: LIST
66319: LIST
66320: PUSH
66321: LD_INT 1
66323: NEG
66324: PUSH
66325: LD_INT 0
66327: PUSH
66328: EMPTY
66329: LIST
66330: LIST
66331: PUSH
66332: LD_INT 1
66334: NEG
66335: PUSH
66336: LD_INT 1
66338: NEG
66339: PUSH
66340: EMPTY
66341: LIST
66342: LIST
66343: PUSH
66344: LD_INT 1
66346: PUSH
66347: LD_INT 1
66349: NEG
66350: PUSH
66351: EMPTY
66352: LIST
66353: LIST
66354: PUSH
66355: LD_INT 2
66357: PUSH
66358: LD_INT 0
66360: PUSH
66361: EMPTY
66362: LIST
66363: LIST
66364: PUSH
66365: LD_INT 2
66367: PUSH
66368: LD_INT 1
66370: PUSH
66371: EMPTY
66372: LIST
66373: LIST
66374: PUSH
66375: LD_INT 1
66377: NEG
66378: PUSH
66379: LD_INT 1
66381: PUSH
66382: EMPTY
66383: LIST
66384: LIST
66385: PUSH
66386: LD_INT 2
66388: NEG
66389: PUSH
66390: LD_INT 0
66392: PUSH
66393: EMPTY
66394: LIST
66395: LIST
66396: PUSH
66397: LD_INT 2
66399: NEG
66400: PUSH
66401: LD_INT 1
66403: NEG
66404: PUSH
66405: EMPTY
66406: LIST
66407: LIST
66408: PUSH
66409: LD_INT 2
66411: NEG
66412: PUSH
66413: LD_INT 1
66415: PUSH
66416: EMPTY
66417: LIST
66418: LIST
66419: PUSH
66420: LD_INT 3
66422: NEG
66423: PUSH
66424: LD_INT 0
66426: PUSH
66427: EMPTY
66428: LIST
66429: LIST
66430: PUSH
66431: LD_INT 3
66433: NEG
66434: PUSH
66435: LD_INT 1
66437: NEG
66438: PUSH
66439: EMPTY
66440: LIST
66441: LIST
66442: PUSH
66443: EMPTY
66444: LIST
66445: LIST
66446: LIST
66447: LIST
66448: LIST
66449: LIST
66450: LIST
66451: LIST
66452: LIST
66453: LIST
66454: LIST
66455: LIST
66456: LIST
66457: LIST
66458: LIST
66459: LIST
66460: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
66461: LD_ADDR_VAR 0 13
66465: PUSH
66466: LD_INT 0
66468: PUSH
66469: LD_INT 0
66471: PUSH
66472: EMPTY
66473: LIST
66474: LIST
66475: PUSH
66476: LD_INT 0
66478: PUSH
66479: LD_INT 1
66481: NEG
66482: PUSH
66483: EMPTY
66484: LIST
66485: LIST
66486: PUSH
66487: LD_INT 1
66489: PUSH
66490: LD_INT 0
66492: PUSH
66493: EMPTY
66494: LIST
66495: LIST
66496: PUSH
66497: LD_INT 1
66499: PUSH
66500: LD_INT 1
66502: PUSH
66503: EMPTY
66504: LIST
66505: LIST
66506: PUSH
66507: LD_INT 0
66509: PUSH
66510: LD_INT 1
66512: PUSH
66513: EMPTY
66514: LIST
66515: LIST
66516: PUSH
66517: LD_INT 1
66519: NEG
66520: PUSH
66521: LD_INT 0
66523: PUSH
66524: EMPTY
66525: LIST
66526: LIST
66527: PUSH
66528: LD_INT 1
66530: NEG
66531: PUSH
66532: LD_INT 1
66534: NEG
66535: PUSH
66536: EMPTY
66537: LIST
66538: LIST
66539: PUSH
66540: LD_INT 1
66542: NEG
66543: PUSH
66544: LD_INT 2
66546: NEG
66547: PUSH
66548: EMPTY
66549: LIST
66550: LIST
66551: PUSH
66552: LD_INT 2
66554: PUSH
66555: LD_INT 1
66557: PUSH
66558: EMPTY
66559: LIST
66560: LIST
66561: PUSH
66562: LD_INT 2
66564: PUSH
66565: LD_INT 2
66567: PUSH
66568: EMPTY
66569: LIST
66570: LIST
66571: PUSH
66572: LD_INT 1
66574: PUSH
66575: LD_INT 2
66577: PUSH
66578: EMPTY
66579: LIST
66580: LIST
66581: PUSH
66582: LD_INT 2
66584: NEG
66585: PUSH
66586: LD_INT 1
66588: NEG
66589: PUSH
66590: EMPTY
66591: LIST
66592: LIST
66593: PUSH
66594: LD_INT 2
66596: NEG
66597: PUSH
66598: LD_INT 2
66600: NEG
66601: PUSH
66602: EMPTY
66603: LIST
66604: LIST
66605: PUSH
66606: LD_INT 2
66608: NEG
66609: PUSH
66610: LD_INT 3
66612: NEG
66613: PUSH
66614: EMPTY
66615: LIST
66616: LIST
66617: PUSH
66618: LD_INT 3
66620: NEG
66621: PUSH
66622: LD_INT 2
66624: NEG
66625: PUSH
66626: EMPTY
66627: LIST
66628: LIST
66629: PUSH
66630: LD_INT 3
66632: NEG
66633: PUSH
66634: LD_INT 3
66636: NEG
66637: PUSH
66638: EMPTY
66639: LIST
66640: LIST
66641: PUSH
66642: EMPTY
66643: LIST
66644: LIST
66645: LIST
66646: LIST
66647: LIST
66648: LIST
66649: LIST
66650: LIST
66651: LIST
66652: LIST
66653: LIST
66654: LIST
66655: LIST
66656: LIST
66657: LIST
66658: LIST
66659: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
66660: LD_ADDR_VAR 0 14
66664: PUSH
66665: LD_INT 0
66667: PUSH
66668: LD_INT 0
66670: PUSH
66671: EMPTY
66672: LIST
66673: LIST
66674: PUSH
66675: LD_INT 0
66677: PUSH
66678: LD_INT 1
66680: NEG
66681: PUSH
66682: EMPTY
66683: LIST
66684: LIST
66685: PUSH
66686: LD_INT 1
66688: PUSH
66689: LD_INT 0
66691: PUSH
66692: EMPTY
66693: LIST
66694: LIST
66695: PUSH
66696: LD_INT 1
66698: PUSH
66699: LD_INT 1
66701: PUSH
66702: EMPTY
66703: LIST
66704: LIST
66705: PUSH
66706: LD_INT 0
66708: PUSH
66709: LD_INT 1
66711: PUSH
66712: EMPTY
66713: LIST
66714: LIST
66715: PUSH
66716: LD_INT 1
66718: NEG
66719: PUSH
66720: LD_INT 0
66722: PUSH
66723: EMPTY
66724: LIST
66725: LIST
66726: PUSH
66727: LD_INT 1
66729: NEG
66730: PUSH
66731: LD_INT 1
66733: NEG
66734: PUSH
66735: EMPTY
66736: LIST
66737: LIST
66738: PUSH
66739: LD_INT 1
66741: NEG
66742: PUSH
66743: LD_INT 2
66745: NEG
66746: PUSH
66747: EMPTY
66748: LIST
66749: LIST
66750: PUSH
66751: LD_INT 0
66753: PUSH
66754: LD_INT 2
66756: NEG
66757: PUSH
66758: EMPTY
66759: LIST
66760: LIST
66761: PUSH
66762: LD_INT 1
66764: PUSH
66765: LD_INT 1
66767: NEG
66768: PUSH
66769: EMPTY
66770: LIST
66771: LIST
66772: PUSH
66773: LD_INT 1
66775: PUSH
66776: LD_INT 2
66778: PUSH
66779: EMPTY
66780: LIST
66781: LIST
66782: PUSH
66783: LD_INT 0
66785: PUSH
66786: LD_INT 2
66788: PUSH
66789: EMPTY
66790: LIST
66791: LIST
66792: PUSH
66793: LD_INT 1
66795: NEG
66796: PUSH
66797: LD_INT 1
66799: PUSH
66800: EMPTY
66801: LIST
66802: LIST
66803: PUSH
66804: LD_INT 1
66806: NEG
66807: PUSH
66808: LD_INT 3
66810: NEG
66811: PUSH
66812: EMPTY
66813: LIST
66814: LIST
66815: PUSH
66816: LD_INT 0
66818: PUSH
66819: LD_INT 3
66821: NEG
66822: PUSH
66823: EMPTY
66824: LIST
66825: LIST
66826: PUSH
66827: LD_INT 1
66829: PUSH
66830: LD_INT 2
66832: NEG
66833: PUSH
66834: EMPTY
66835: LIST
66836: LIST
66837: PUSH
66838: EMPTY
66839: LIST
66840: LIST
66841: LIST
66842: LIST
66843: LIST
66844: LIST
66845: LIST
66846: LIST
66847: LIST
66848: LIST
66849: LIST
66850: LIST
66851: LIST
66852: LIST
66853: LIST
66854: LIST
66855: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
66856: LD_ADDR_VAR 0 15
66860: PUSH
66861: LD_INT 0
66863: PUSH
66864: LD_INT 0
66866: PUSH
66867: EMPTY
66868: LIST
66869: LIST
66870: PUSH
66871: LD_INT 0
66873: PUSH
66874: LD_INT 1
66876: NEG
66877: PUSH
66878: EMPTY
66879: LIST
66880: LIST
66881: PUSH
66882: LD_INT 1
66884: PUSH
66885: LD_INT 0
66887: PUSH
66888: EMPTY
66889: LIST
66890: LIST
66891: PUSH
66892: LD_INT 1
66894: PUSH
66895: LD_INT 1
66897: PUSH
66898: EMPTY
66899: LIST
66900: LIST
66901: PUSH
66902: LD_INT 0
66904: PUSH
66905: LD_INT 1
66907: PUSH
66908: EMPTY
66909: LIST
66910: LIST
66911: PUSH
66912: LD_INT 1
66914: NEG
66915: PUSH
66916: LD_INT 0
66918: PUSH
66919: EMPTY
66920: LIST
66921: LIST
66922: PUSH
66923: LD_INT 1
66925: NEG
66926: PUSH
66927: LD_INT 1
66929: NEG
66930: PUSH
66931: EMPTY
66932: LIST
66933: LIST
66934: PUSH
66935: LD_INT 1
66937: PUSH
66938: LD_INT 1
66940: NEG
66941: PUSH
66942: EMPTY
66943: LIST
66944: LIST
66945: PUSH
66946: LD_INT 2
66948: PUSH
66949: LD_INT 0
66951: PUSH
66952: EMPTY
66953: LIST
66954: LIST
66955: PUSH
66956: LD_INT 2
66958: PUSH
66959: LD_INT 1
66961: PUSH
66962: EMPTY
66963: LIST
66964: LIST
66965: PUSH
66966: LD_INT 1
66968: NEG
66969: PUSH
66970: LD_INT 1
66972: PUSH
66973: EMPTY
66974: LIST
66975: LIST
66976: PUSH
66977: LD_INT 2
66979: NEG
66980: PUSH
66981: LD_INT 0
66983: PUSH
66984: EMPTY
66985: LIST
66986: LIST
66987: PUSH
66988: LD_INT 2
66990: NEG
66991: PUSH
66992: LD_INT 1
66994: NEG
66995: PUSH
66996: EMPTY
66997: LIST
66998: LIST
66999: PUSH
67000: LD_INT 2
67002: PUSH
67003: LD_INT 1
67005: NEG
67006: PUSH
67007: EMPTY
67008: LIST
67009: LIST
67010: PUSH
67011: LD_INT 3
67013: PUSH
67014: LD_INT 0
67016: PUSH
67017: EMPTY
67018: LIST
67019: LIST
67020: PUSH
67021: LD_INT 3
67023: PUSH
67024: LD_INT 1
67026: PUSH
67027: EMPTY
67028: LIST
67029: LIST
67030: PUSH
67031: EMPTY
67032: LIST
67033: LIST
67034: LIST
67035: LIST
67036: LIST
67037: LIST
67038: LIST
67039: LIST
67040: LIST
67041: LIST
67042: LIST
67043: LIST
67044: LIST
67045: LIST
67046: LIST
67047: LIST
67048: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
67049: LD_ADDR_VAR 0 16
67053: PUSH
67054: LD_INT 0
67056: PUSH
67057: LD_INT 0
67059: PUSH
67060: EMPTY
67061: LIST
67062: LIST
67063: PUSH
67064: LD_INT 0
67066: PUSH
67067: LD_INT 1
67069: NEG
67070: PUSH
67071: EMPTY
67072: LIST
67073: LIST
67074: PUSH
67075: LD_INT 1
67077: PUSH
67078: LD_INT 0
67080: PUSH
67081: EMPTY
67082: LIST
67083: LIST
67084: PUSH
67085: LD_INT 1
67087: PUSH
67088: LD_INT 1
67090: PUSH
67091: EMPTY
67092: LIST
67093: LIST
67094: PUSH
67095: LD_INT 0
67097: PUSH
67098: LD_INT 1
67100: PUSH
67101: EMPTY
67102: LIST
67103: LIST
67104: PUSH
67105: LD_INT 1
67107: NEG
67108: PUSH
67109: LD_INT 0
67111: PUSH
67112: EMPTY
67113: LIST
67114: LIST
67115: PUSH
67116: LD_INT 1
67118: NEG
67119: PUSH
67120: LD_INT 1
67122: NEG
67123: PUSH
67124: EMPTY
67125: LIST
67126: LIST
67127: PUSH
67128: LD_INT 1
67130: NEG
67131: PUSH
67132: LD_INT 2
67134: NEG
67135: PUSH
67136: EMPTY
67137: LIST
67138: LIST
67139: PUSH
67140: LD_INT 2
67142: PUSH
67143: LD_INT 1
67145: PUSH
67146: EMPTY
67147: LIST
67148: LIST
67149: PUSH
67150: LD_INT 2
67152: PUSH
67153: LD_INT 2
67155: PUSH
67156: EMPTY
67157: LIST
67158: LIST
67159: PUSH
67160: LD_INT 1
67162: PUSH
67163: LD_INT 2
67165: PUSH
67166: EMPTY
67167: LIST
67168: LIST
67169: PUSH
67170: LD_INT 2
67172: NEG
67173: PUSH
67174: LD_INT 1
67176: NEG
67177: PUSH
67178: EMPTY
67179: LIST
67180: LIST
67181: PUSH
67182: LD_INT 2
67184: NEG
67185: PUSH
67186: LD_INT 2
67188: NEG
67189: PUSH
67190: EMPTY
67191: LIST
67192: LIST
67193: PUSH
67194: LD_INT 3
67196: PUSH
67197: LD_INT 2
67199: PUSH
67200: EMPTY
67201: LIST
67202: LIST
67203: PUSH
67204: LD_INT 3
67206: PUSH
67207: LD_INT 3
67209: PUSH
67210: EMPTY
67211: LIST
67212: LIST
67213: PUSH
67214: LD_INT 2
67216: PUSH
67217: LD_INT 3
67219: PUSH
67220: EMPTY
67221: LIST
67222: LIST
67223: PUSH
67224: EMPTY
67225: LIST
67226: LIST
67227: LIST
67228: LIST
67229: LIST
67230: LIST
67231: LIST
67232: LIST
67233: LIST
67234: LIST
67235: LIST
67236: LIST
67237: LIST
67238: LIST
67239: LIST
67240: LIST
67241: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67242: LD_ADDR_VAR 0 17
67246: PUSH
67247: LD_INT 0
67249: PUSH
67250: LD_INT 0
67252: PUSH
67253: EMPTY
67254: LIST
67255: LIST
67256: PUSH
67257: LD_INT 0
67259: PUSH
67260: LD_INT 1
67262: NEG
67263: PUSH
67264: EMPTY
67265: LIST
67266: LIST
67267: PUSH
67268: LD_INT 1
67270: PUSH
67271: LD_INT 0
67273: PUSH
67274: EMPTY
67275: LIST
67276: LIST
67277: PUSH
67278: LD_INT 1
67280: PUSH
67281: LD_INT 1
67283: PUSH
67284: EMPTY
67285: LIST
67286: LIST
67287: PUSH
67288: LD_INT 0
67290: PUSH
67291: LD_INT 1
67293: PUSH
67294: EMPTY
67295: LIST
67296: LIST
67297: PUSH
67298: LD_INT 1
67300: NEG
67301: PUSH
67302: LD_INT 0
67304: PUSH
67305: EMPTY
67306: LIST
67307: LIST
67308: PUSH
67309: LD_INT 1
67311: NEG
67312: PUSH
67313: LD_INT 1
67315: NEG
67316: PUSH
67317: EMPTY
67318: LIST
67319: LIST
67320: PUSH
67321: LD_INT 1
67323: NEG
67324: PUSH
67325: LD_INT 2
67327: NEG
67328: PUSH
67329: EMPTY
67330: LIST
67331: LIST
67332: PUSH
67333: LD_INT 0
67335: PUSH
67336: LD_INT 2
67338: NEG
67339: PUSH
67340: EMPTY
67341: LIST
67342: LIST
67343: PUSH
67344: LD_INT 1
67346: PUSH
67347: LD_INT 1
67349: NEG
67350: PUSH
67351: EMPTY
67352: LIST
67353: LIST
67354: PUSH
67355: LD_INT 2
67357: PUSH
67358: LD_INT 0
67360: PUSH
67361: EMPTY
67362: LIST
67363: LIST
67364: PUSH
67365: LD_INT 2
67367: PUSH
67368: LD_INT 1
67370: PUSH
67371: EMPTY
67372: LIST
67373: LIST
67374: PUSH
67375: LD_INT 2
67377: PUSH
67378: LD_INT 2
67380: PUSH
67381: EMPTY
67382: LIST
67383: LIST
67384: PUSH
67385: LD_INT 1
67387: PUSH
67388: LD_INT 2
67390: PUSH
67391: EMPTY
67392: LIST
67393: LIST
67394: PUSH
67395: LD_INT 0
67397: PUSH
67398: LD_INT 2
67400: PUSH
67401: EMPTY
67402: LIST
67403: LIST
67404: PUSH
67405: LD_INT 1
67407: NEG
67408: PUSH
67409: LD_INT 1
67411: PUSH
67412: EMPTY
67413: LIST
67414: LIST
67415: PUSH
67416: LD_INT 2
67418: NEG
67419: PUSH
67420: LD_INT 0
67422: PUSH
67423: EMPTY
67424: LIST
67425: LIST
67426: PUSH
67427: LD_INT 2
67429: NEG
67430: PUSH
67431: LD_INT 1
67433: NEG
67434: PUSH
67435: EMPTY
67436: LIST
67437: LIST
67438: PUSH
67439: LD_INT 2
67441: NEG
67442: PUSH
67443: LD_INT 2
67445: NEG
67446: PUSH
67447: EMPTY
67448: LIST
67449: LIST
67450: PUSH
67451: EMPTY
67452: LIST
67453: LIST
67454: LIST
67455: LIST
67456: LIST
67457: LIST
67458: LIST
67459: LIST
67460: LIST
67461: LIST
67462: LIST
67463: LIST
67464: LIST
67465: LIST
67466: LIST
67467: LIST
67468: LIST
67469: LIST
67470: LIST
67471: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67472: LD_ADDR_VAR 0 18
67476: PUSH
67477: LD_INT 0
67479: PUSH
67480: LD_INT 0
67482: PUSH
67483: EMPTY
67484: LIST
67485: LIST
67486: PUSH
67487: LD_INT 0
67489: PUSH
67490: LD_INT 1
67492: NEG
67493: PUSH
67494: EMPTY
67495: LIST
67496: LIST
67497: PUSH
67498: LD_INT 1
67500: PUSH
67501: LD_INT 0
67503: PUSH
67504: EMPTY
67505: LIST
67506: LIST
67507: PUSH
67508: LD_INT 1
67510: PUSH
67511: LD_INT 1
67513: PUSH
67514: EMPTY
67515: LIST
67516: LIST
67517: PUSH
67518: LD_INT 0
67520: PUSH
67521: LD_INT 1
67523: PUSH
67524: EMPTY
67525: LIST
67526: LIST
67527: PUSH
67528: LD_INT 1
67530: NEG
67531: PUSH
67532: LD_INT 0
67534: PUSH
67535: EMPTY
67536: LIST
67537: LIST
67538: PUSH
67539: LD_INT 1
67541: NEG
67542: PUSH
67543: LD_INT 1
67545: NEG
67546: PUSH
67547: EMPTY
67548: LIST
67549: LIST
67550: PUSH
67551: LD_INT 1
67553: NEG
67554: PUSH
67555: LD_INT 2
67557: NEG
67558: PUSH
67559: EMPTY
67560: LIST
67561: LIST
67562: PUSH
67563: LD_INT 0
67565: PUSH
67566: LD_INT 2
67568: NEG
67569: PUSH
67570: EMPTY
67571: LIST
67572: LIST
67573: PUSH
67574: LD_INT 1
67576: PUSH
67577: LD_INT 1
67579: NEG
67580: PUSH
67581: EMPTY
67582: LIST
67583: LIST
67584: PUSH
67585: LD_INT 2
67587: PUSH
67588: LD_INT 0
67590: PUSH
67591: EMPTY
67592: LIST
67593: LIST
67594: PUSH
67595: LD_INT 2
67597: PUSH
67598: LD_INT 1
67600: PUSH
67601: EMPTY
67602: LIST
67603: LIST
67604: PUSH
67605: LD_INT 2
67607: PUSH
67608: LD_INT 2
67610: PUSH
67611: EMPTY
67612: LIST
67613: LIST
67614: PUSH
67615: LD_INT 1
67617: PUSH
67618: LD_INT 2
67620: PUSH
67621: EMPTY
67622: LIST
67623: LIST
67624: PUSH
67625: LD_INT 0
67627: PUSH
67628: LD_INT 2
67630: PUSH
67631: EMPTY
67632: LIST
67633: LIST
67634: PUSH
67635: LD_INT 1
67637: NEG
67638: PUSH
67639: LD_INT 1
67641: PUSH
67642: EMPTY
67643: LIST
67644: LIST
67645: PUSH
67646: LD_INT 2
67648: NEG
67649: PUSH
67650: LD_INT 0
67652: PUSH
67653: EMPTY
67654: LIST
67655: LIST
67656: PUSH
67657: LD_INT 2
67659: NEG
67660: PUSH
67661: LD_INT 1
67663: NEG
67664: PUSH
67665: EMPTY
67666: LIST
67667: LIST
67668: PUSH
67669: LD_INT 2
67671: NEG
67672: PUSH
67673: LD_INT 2
67675: NEG
67676: PUSH
67677: EMPTY
67678: LIST
67679: LIST
67680: PUSH
67681: EMPTY
67682: LIST
67683: LIST
67684: LIST
67685: LIST
67686: LIST
67687: LIST
67688: LIST
67689: LIST
67690: LIST
67691: LIST
67692: LIST
67693: LIST
67694: LIST
67695: LIST
67696: LIST
67697: LIST
67698: LIST
67699: LIST
67700: LIST
67701: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67702: LD_ADDR_VAR 0 19
67706: PUSH
67707: LD_INT 0
67709: PUSH
67710: LD_INT 0
67712: PUSH
67713: EMPTY
67714: LIST
67715: LIST
67716: PUSH
67717: LD_INT 0
67719: PUSH
67720: LD_INT 1
67722: NEG
67723: PUSH
67724: EMPTY
67725: LIST
67726: LIST
67727: PUSH
67728: LD_INT 1
67730: PUSH
67731: LD_INT 0
67733: PUSH
67734: EMPTY
67735: LIST
67736: LIST
67737: PUSH
67738: LD_INT 1
67740: PUSH
67741: LD_INT 1
67743: PUSH
67744: EMPTY
67745: LIST
67746: LIST
67747: PUSH
67748: LD_INT 0
67750: PUSH
67751: LD_INT 1
67753: PUSH
67754: EMPTY
67755: LIST
67756: LIST
67757: PUSH
67758: LD_INT 1
67760: NEG
67761: PUSH
67762: LD_INT 0
67764: PUSH
67765: EMPTY
67766: LIST
67767: LIST
67768: PUSH
67769: LD_INT 1
67771: NEG
67772: PUSH
67773: LD_INT 1
67775: NEG
67776: PUSH
67777: EMPTY
67778: LIST
67779: LIST
67780: PUSH
67781: LD_INT 1
67783: NEG
67784: PUSH
67785: LD_INT 2
67787: NEG
67788: PUSH
67789: EMPTY
67790: LIST
67791: LIST
67792: PUSH
67793: LD_INT 0
67795: PUSH
67796: LD_INT 2
67798: NEG
67799: PUSH
67800: EMPTY
67801: LIST
67802: LIST
67803: PUSH
67804: LD_INT 1
67806: PUSH
67807: LD_INT 1
67809: NEG
67810: PUSH
67811: EMPTY
67812: LIST
67813: LIST
67814: PUSH
67815: LD_INT 2
67817: PUSH
67818: LD_INT 0
67820: PUSH
67821: EMPTY
67822: LIST
67823: LIST
67824: PUSH
67825: LD_INT 2
67827: PUSH
67828: LD_INT 1
67830: PUSH
67831: EMPTY
67832: LIST
67833: LIST
67834: PUSH
67835: LD_INT 2
67837: PUSH
67838: LD_INT 2
67840: PUSH
67841: EMPTY
67842: LIST
67843: LIST
67844: PUSH
67845: LD_INT 1
67847: PUSH
67848: LD_INT 2
67850: PUSH
67851: EMPTY
67852: LIST
67853: LIST
67854: PUSH
67855: LD_INT 0
67857: PUSH
67858: LD_INT 2
67860: PUSH
67861: EMPTY
67862: LIST
67863: LIST
67864: PUSH
67865: LD_INT 1
67867: NEG
67868: PUSH
67869: LD_INT 1
67871: PUSH
67872: EMPTY
67873: LIST
67874: LIST
67875: PUSH
67876: LD_INT 2
67878: NEG
67879: PUSH
67880: LD_INT 0
67882: PUSH
67883: EMPTY
67884: LIST
67885: LIST
67886: PUSH
67887: LD_INT 2
67889: NEG
67890: PUSH
67891: LD_INT 1
67893: NEG
67894: PUSH
67895: EMPTY
67896: LIST
67897: LIST
67898: PUSH
67899: LD_INT 2
67901: NEG
67902: PUSH
67903: LD_INT 2
67905: NEG
67906: PUSH
67907: EMPTY
67908: LIST
67909: LIST
67910: PUSH
67911: EMPTY
67912: LIST
67913: LIST
67914: LIST
67915: LIST
67916: LIST
67917: LIST
67918: LIST
67919: LIST
67920: LIST
67921: LIST
67922: LIST
67923: LIST
67924: LIST
67925: LIST
67926: LIST
67927: LIST
67928: LIST
67929: LIST
67930: LIST
67931: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67932: LD_ADDR_VAR 0 20
67936: PUSH
67937: LD_INT 0
67939: PUSH
67940: LD_INT 0
67942: PUSH
67943: EMPTY
67944: LIST
67945: LIST
67946: PUSH
67947: LD_INT 0
67949: PUSH
67950: LD_INT 1
67952: NEG
67953: PUSH
67954: EMPTY
67955: LIST
67956: LIST
67957: PUSH
67958: LD_INT 1
67960: PUSH
67961: LD_INT 0
67963: PUSH
67964: EMPTY
67965: LIST
67966: LIST
67967: PUSH
67968: LD_INT 1
67970: PUSH
67971: LD_INT 1
67973: PUSH
67974: EMPTY
67975: LIST
67976: LIST
67977: PUSH
67978: LD_INT 0
67980: PUSH
67981: LD_INT 1
67983: PUSH
67984: EMPTY
67985: LIST
67986: LIST
67987: PUSH
67988: LD_INT 1
67990: NEG
67991: PUSH
67992: LD_INT 0
67994: PUSH
67995: EMPTY
67996: LIST
67997: LIST
67998: PUSH
67999: LD_INT 1
68001: NEG
68002: PUSH
68003: LD_INT 1
68005: NEG
68006: PUSH
68007: EMPTY
68008: LIST
68009: LIST
68010: PUSH
68011: LD_INT 1
68013: NEG
68014: PUSH
68015: LD_INT 2
68017: NEG
68018: PUSH
68019: EMPTY
68020: LIST
68021: LIST
68022: PUSH
68023: LD_INT 0
68025: PUSH
68026: LD_INT 2
68028: NEG
68029: PUSH
68030: EMPTY
68031: LIST
68032: LIST
68033: PUSH
68034: LD_INT 1
68036: PUSH
68037: LD_INT 1
68039: NEG
68040: PUSH
68041: EMPTY
68042: LIST
68043: LIST
68044: PUSH
68045: LD_INT 2
68047: PUSH
68048: LD_INT 0
68050: PUSH
68051: EMPTY
68052: LIST
68053: LIST
68054: PUSH
68055: LD_INT 2
68057: PUSH
68058: LD_INT 1
68060: PUSH
68061: EMPTY
68062: LIST
68063: LIST
68064: PUSH
68065: LD_INT 2
68067: PUSH
68068: LD_INT 2
68070: PUSH
68071: EMPTY
68072: LIST
68073: LIST
68074: PUSH
68075: LD_INT 1
68077: PUSH
68078: LD_INT 2
68080: PUSH
68081: EMPTY
68082: LIST
68083: LIST
68084: PUSH
68085: LD_INT 0
68087: PUSH
68088: LD_INT 2
68090: PUSH
68091: EMPTY
68092: LIST
68093: LIST
68094: PUSH
68095: LD_INT 1
68097: NEG
68098: PUSH
68099: LD_INT 1
68101: PUSH
68102: EMPTY
68103: LIST
68104: LIST
68105: PUSH
68106: LD_INT 2
68108: NEG
68109: PUSH
68110: LD_INT 0
68112: PUSH
68113: EMPTY
68114: LIST
68115: LIST
68116: PUSH
68117: LD_INT 2
68119: NEG
68120: PUSH
68121: LD_INT 1
68123: NEG
68124: PUSH
68125: EMPTY
68126: LIST
68127: LIST
68128: PUSH
68129: LD_INT 2
68131: NEG
68132: PUSH
68133: LD_INT 2
68135: NEG
68136: PUSH
68137: EMPTY
68138: LIST
68139: LIST
68140: PUSH
68141: EMPTY
68142: LIST
68143: LIST
68144: LIST
68145: LIST
68146: LIST
68147: LIST
68148: LIST
68149: LIST
68150: LIST
68151: LIST
68152: LIST
68153: LIST
68154: LIST
68155: LIST
68156: LIST
68157: LIST
68158: LIST
68159: LIST
68160: LIST
68161: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68162: LD_ADDR_VAR 0 21
68166: PUSH
68167: LD_INT 0
68169: PUSH
68170: LD_INT 0
68172: PUSH
68173: EMPTY
68174: LIST
68175: LIST
68176: PUSH
68177: LD_INT 0
68179: PUSH
68180: LD_INT 1
68182: NEG
68183: PUSH
68184: EMPTY
68185: LIST
68186: LIST
68187: PUSH
68188: LD_INT 1
68190: PUSH
68191: LD_INT 0
68193: PUSH
68194: EMPTY
68195: LIST
68196: LIST
68197: PUSH
68198: LD_INT 1
68200: PUSH
68201: LD_INT 1
68203: PUSH
68204: EMPTY
68205: LIST
68206: LIST
68207: PUSH
68208: LD_INT 0
68210: PUSH
68211: LD_INT 1
68213: PUSH
68214: EMPTY
68215: LIST
68216: LIST
68217: PUSH
68218: LD_INT 1
68220: NEG
68221: PUSH
68222: LD_INT 0
68224: PUSH
68225: EMPTY
68226: LIST
68227: LIST
68228: PUSH
68229: LD_INT 1
68231: NEG
68232: PUSH
68233: LD_INT 1
68235: NEG
68236: PUSH
68237: EMPTY
68238: LIST
68239: LIST
68240: PUSH
68241: LD_INT 1
68243: NEG
68244: PUSH
68245: LD_INT 2
68247: NEG
68248: PUSH
68249: EMPTY
68250: LIST
68251: LIST
68252: PUSH
68253: LD_INT 0
68255: PUSH
68256: LD_INT 2
68258: NEG
68259: PUSH
68260: EMPTY
68261: LIST
68262: LIST
68263: PUSH
68264: LD_INT 1
68266: PUSH
68267: LD_INT 1
68269: NEG
68270: PUSH
68271: EMPTY
68272: LIST
68273: LIST
68274: PUSH
68275: LD_INT 2
68277: PUSH
68278: LD_INT 0
68280: PUSH
68281: EMPTY
68282: LIST
68283: LIST
68284: PUSH
68285: LD_INT 2
68287: PUSH
68288: LD_INT 1
68290: PUSH
68291: EMPTY
68292: LIST
68293: LIST
68294: PUSH
68295: LD_INT 2
68297: PUSH
68298: LD_INT 2
68300: PUSH
68301: EMPTY
68302: LIST
68303: LIST
68304: PUSH
68305: LD_INT 1
68307: PUSH
68308: LD_INT 2
68310: PUSH
68311: EMPTY
68312: LIST
68313: LIST
68314: PUSH
68315: LD_INT 0
68317: PUSH
68318: LD_INT 2
68320: PUSH
68321: EMPTY
68322: LIST
68323: LIST
68324: PUSH
68325: LD_INT 1
68327: NEG
68328: PUSH
68329: LD_INT 1
68331: PUSH
68332: EMPTY
68333: LIST
68334: LIST
68335: PUSH
68336: LD_INT 2
68338: NEG
68339: PUSH
68340: LD_INT 0
68342: PUSH
68343: EMPTY
68344: LIST
68345: LIST
68346: PUSH
68347: LD_INT 2
68349: NEG
68350: PUSH
68351: LD_INT 1
68353: NEG
68354: PUSH
68355: EMPTY
68356: LIST
68357: LIST
68358: PUSH
68359: LD_INT 2
68361: NEG
68362: PUSH
68363: LD_INT 2
68365: NEG
68366: PUSH
68367: EMPTY
68368: LIST
68369: LIST
68370: PUSH
68371: EMPTY
68372: LIST
68373: LIST
68374: LIST
68375: LIST
68376: LIST
68377: LIST
68378: LIST
68379: LIST
68380: LIST
68381: LIST
68382: LIST
68383: LIST
68384: LIST
68385: LIST
68386: LIST
68387: LIST
68388: LIST
68389: LIST
68390: LIST
68391: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68392: LD_ADDR_VAR 0 22
68396: PUSH
68397: LD_INT 0
68399: PUSH
68400: LD_INT 0
68402: PUSH
68403: EMPTY
68404: LIST
68405: LIST
68406: PUSH
68407: LD_INT 0
68409: PUSH
68410: LD_INT 1
68412: NEG
68413: PUSH
68414: EMPTY
68415: LIST
68416: LIST
68417: PUSH
68418: LD_INT 1
68420: PUSH
68421: LD_INT 0
68423: PUSH
68424: EMPTY
68425: LIST
68426: LIST
68427: PUSH
68428: LD_INT 1
68430: PUSH
68431: LD_INT 1
68433: PUSH
68434: EMPTY
68435: LIST
68436: LIST
68437: PUSH
68438: LD_INT 0
68440: PUSH
68441: LD_INT 1
68443: PUSH
68444: EMPTY
68445: LIST
68446: LIST
68447: PUSH
68448: LD_INT 1
68450: NEG
68451: PUSH
68452: LD_INT 0
68454: PUSH
68455: EMPTY
68456: LIST
68457: LIST
68458: PUSH
68459: LD_INT 1
68461: NEG
68462: PUSH
68463: LD_INT 1
68465: NEG
68466: PUSH
68467: EMPTY
68468: LIST
68469: LIST
68470: PUSH
68471: LD_INT 1
68473: NEG
68474: PUSH
68475: LD_INT 2
68477: NEG
68478: PUSH
68479: EMPTY
68480: LIST
68481: LIST
68482: PUSH
68483: LD_INT 0
68485: PUSH
68486: LD_INT 2
68488: NEG
68489: PUSH
68490: EMPTY
68491: LIST
68492: LIST
68493: PUSH
68494: LD_INT 1
68496: PUSH
68497: LD_INT 1
68499: NEG
68500: PUSH
68501: EMPTY
68502: LIST
68503: LIST
68504: PUSH
68505: LD_INT 2
68507: PUSH
68508: LD_INT 0
68510: PUSH
68511: EMPTY
68512: LIST
68513: LIST
68514: PUSH
68515: LD_INT 2
68517: PUSH
68518: LD_INT 1
68520: PUSH
68521: EMPTY
68522: LIST
68523: LIST
68524: PUSH
68525: LD_INT 2
68527: PUSH
68528: LD_INT 2
68530: PUSH
68531: EMPTY
68532: LIST
68533: LIST
68534: PUSH
68535: LD_INT 1
68537: PUSH
68538: LD_INT 2
68540: PUSH
68541: EMPTY
68542: LIST
68543: LIST
68544: PUSH
68545: LD_INT 0
68547: PUSH
68548: LD_INT 2
68550: PUSH
68551: EMPTY
68552: LIST
68553: LIST
68554: PUSH
68555: LD_INT 1
68557: NEG
68558: PUSH
68559: LD_INT 1
68561: PUSH
68562: EMPTY
68563: LIST
68564: LIST
68565: PUSH
68566: LD_INT 2
68568: NEG
68569: PUSH
68570: LD_INT 0
68572: PUSH
68573: EMPTY
68574: LIST
68575: LIST
68576: PUSH
68577: LD_INT 2
68579: NEG
68580: PUSH
68581: LD_INT 1
68583: NEG
68584: PUSH
68585: EMPTY
68586: LIST
68587: LIST
68588: PUSH
68589: LD_INT 2
68591: NEG
68592: PUSH
68593: LD_INT 2
68595: NEG
68596: PUSH
68597: EMPTY
68598: LIST
68599: LIST
68600: PUSH
68601: EMPTY
68602: LIST
68603: LIST
68604: LIST
68605: LIST
68606: LIST
68607: LIST
68608: LIST
68609: LIST
68610: LIST
68611: LIST
68612: LIST
68613: LIST
68614: LIST
68615: LIST
68616: LIST
68617: LIST
68618: LIST
68619: LIST
68620: LIST
68621: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
68622: LD_ADDR_VAR 0 23
68626: PUSH
68627: LD_INT 0
68629: PUSH
68630: LD_INT 0
68632: PUSH
68633: EMPTY
68634: LIST
68635: LIST
68636: PUSH
68637: LD_INT 0
68639: PUSH
68640: LD_INT 1
68642: NEG
68643: PUSH
68644: EMPTY
68645: LIST
68646: LIST
68647: PUSH
68648: LD_INT 1
68650: PUSH
68651: LD_INT 0
68653: PUSH
68654: EMPTY
68655: LIST
68656: LIST
68657: PUSH
68658: LD_INT 1
68660: PUSH
68661: LD_INT 1
68663: PUSH
68664: EMPTY
68665: LIST
68666: LIST
68667: PUSH
68668: LD_INT 0
68670: PUSH
68671: LD_INT 1
68673: PUSH
68674: EMPTY
68675: LIST
68676: LIST
68677: PUSH
68678: LD_INT 1
68680: NEG
68681: PUSH
68682: LD_INT 0
68684: PUSH
68685: EMPTY
68686: LIST
68687: LIST
68688: PUSH
68689: LD_INT 1
68691: NEG
68692: PUSH
68693: LD_INT 1
68695: NEG
68696: PUSH
68697: EMPTY
68698: LIST
68699: LIST
68700: PUSH
68701: LD_INT 1
68703: NEG
68704: PUSH
68705: LD_INT 2
68707: NEG
68708: PUSH
68709: EMPTY
68710: LIST
68711: LIST
68712: PUSH
68713: LD_INT 0
68715: PUSH
68716: LD_INT 2
68718: NEG
68719: PUSH
68720: EMPTY
68721: LIST
68722: LIST
68723: PUSH
68724: LD_INT 1
68726: PUSH
68727: LD_INT 1
68729: NEG
68730: PUSH
68731: EMPTY
68732: LIST
68733: LIST
68734: PUSH
68735: LD_INT 2
68737: PUSH
68738: LD_INT 0
68740: PUSH
68741: EMPTY
68742: LIST
68743: LIST
68744: PUSH
68745: LD_INT 2
68747: PUSH
68748: LD_INT 1
68750: PUSH
68751: EMPTY
68752: LIST
68753: LIST
68754: PUSH
68755: LD_INT 2
68757: PUSH
68758: LD_INT 2
68760: PUSH
68761: EMPTY
68762: LIST
68763: LIST
68764: PUSH
68765: LD_INT 1
68767: PUSH
68768: LD_INT 2
68770: PUSH
68771: EMPTY
68772: LIST
68773: LIST
68774: PUSH
68775: LD_INT 0
68777: PUSH
68778: LD_INT 2
68780: PUSH
68781: EMPTY
68782: LIST
68783: LIST
68784: PUSH
68785: LD_INT 1
68787: NEG
68788: PUSH
68789: LD_INT 1
68791: PUSH
68792: EMPTY
68793: LIST
68794: LIST
68795: PUSH
68796: LD_INT 2
68798: NEG
68799: PUSH
68800: LD_INT 0
68802: PUSH
68803: EMPTY
68804: LIST
68805: LIST
68806: PUSH
68807: LD_INT 2
68809: NEG
68810: PUSH
68811: LD_INT 1
68813: NEG
68814: PUSH
68815: EMPTY
68816: LIST
68817: LIST
68818: PUSH
68819: LD_INT 2
68821: NEG
68822: PUSH
68823: LD_INT 2
68825: NEG
68826: PUSH
68827: EMPTY
68828: LIST
68829: LIST
68830: PUSH
68831: LD_INT 2
68833: NEG
68834: PUSH
68835: LD_INT 3
68837: NEG
68838: PUSH
68839: EMPTY
68840: LIST
68841: LIST
68842: PUSH
68843: LD_INT 1
68845: NEG
68846: PUSH
68847: LD_INT 3
68849: NEG
68850: PUSH
68851: EMPTY
68852: LIST
68853: LIST
68854: PUSH
68855: LD_INT 1
68857: PUSH
68858: LD_INT 2
68860: NEG
68861: PUSH
68862: EMPTY
68863: LIST
68864: LIST
68865: PUSH
68866: LD_INT 2
68868: PUSH
68869: LD_INT 1
68871: NEG
68872: PUSH
68873: EMPTY
68874: LIST
68875: LIST
68876: PUSH
68877: EMPTY
68878: LIST
68879: LIST
68880: LIST
68881: LIST
68882: LIST
68883: LIST
68884: LIST
68885: LIST
68886: LIST
68887: LIST
68888: LIST
68889: LIST
68890: LIST
68891: LIST
68892: LIST
68893: LIST
68894: LIST
68895: LIST
68896: LIST
68897: LIST
68898: LIST
68899: LIST
68900: LIST
68901: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
68902: LD_ADDR_VAR 0 24
68906: PUSH
68907: LD_INT 0
68909: PUSH
68910: LD_INT 0
68912: PUSH
68913: EMPTY
68914: LIST
68915: LIST
68916: PUSH
68917: LD_INT 0
68919: PUSH
68920: LD_INT 1
68922: NEG
68923: PUSH
68924: EMPTY
68925: LIST
68926: LIST
68927: PUSH
68928: LD_INT 1
68930: PUSH
68931: LD_INT 0
68933: PUSH
68934: EMPTY
68935: LIST
68936: LIST
68937: PUSH
68938: LD_INT 1
68940: PUSH
68941: LD_INT 1
68943: PUSH
68944: EMPTY
68945: LIST
68946: LIST
68947: PUSH
68948: LD_INT 0
68950: PUSH
68951: LD_INT 1
68953: PUSH
68954: EMPTY
68955: LIST
68956: LIST
68957: PUSH
68958: LD_INT 1
68960: NEG
68961: PUSH
68962: LD_INT 0
68964: PUSH
68965: EMPTY
68966: LIST
68967: LIST
68968: PUSH
68969: LD_INT 1
68971: NEG
68972: PUSH
68973: LD_INT 1
68975: NEG
68976: PUSH
68977: EMPTY
68978: LIST
68979: LIST
68980: PUSH
68981: LD_INT 1
68983: NEG
68984: PUSH
68985: LD_INT 2
68987: NEG
68988: PUSH
68989: EMPTY
68990: LIST
68991: LIST
68992: PUSH
68993: LD_INT 0
68995: PUSH
68996: LD_INT 2
68998: NEG
68999: PUSH
69000: EMPTY
69001: LIST
69002: LIST
69003: PUSH
69004: LD_INT 1
69006: PUSH
69007: LD_INT 1
69009: NEG
69010: PUSH
69011: EMPTY
69012: LIST
69013: LIST
69014: PUSH
69015: LD_INT 2
69017: PUSH
69018: LD_INT 0
69020: PUSH
69021: EMPTY
69022: LIST
69023: LIST
69024: PUSH
69025: LD_INT 2
69027: PUSH
69028: LD_INT 1
69030: PUSH
69031: EMPTY
69032: LIST
69033: LIST
69034: PUSH
69035: LD_INT 2
69037: PUSH
69038: LD_INT 2
69040: PUSH
69041: EMPTY
69042: LIST
69043: LIST
69044: PUSH
69045: LD_INT 1
69047: PUSH
69048: LD_INT 2
69050: PUSH
69051: EMPTY
69052: LIST
69053: LIST
69054: PUSH
69055: LD_INT 0
69057: PUSH
69058: LD_INT 2
69060: PUSH
69061: EMPTY
69062: LIST
69063: LIST
69064: PUSH
69065: LD_INT 1
69067: NEG
69068: PUSH
69069: LD_INT 1
69071: PUSH
69072: EMPTY
69073: LIST
69074: LIST
69075: PUSH
69076: LD_INT 2
69078: NEG
69079: PUSH
69080: LD_INT 0
69082: PUSH
69083: EMPTY
69084: LIST
69085: LIST
69086: PUSH
69087: LD_INT 2
69089: NEG
69090: PUSH
69091: LD_INT 1
69093: NEG
69094: PUSH
69095: EMPTY
69096: LIST
69097: LIST
69098: PUSH
69099: LD_INT 2
69101: NEG
69102: PUSH
69103: LD_INT 2
69105: NEG
69106: PUSH
69107: EMPTY
69108: LIST
69109: LIST
69110: PUSH
69111: LD_INT 1
69113: PUSH
69114: LD_INT 2
69116: NEG
69117: PUSH
69118: EMPTY
69119: LIST
69120: LIST
69121: PUSH
69122: LD_INT 2
69124: PUSH
69125: LD_INT 1
69127: NEG
69128: PUSH
69129: EMPTY
69130: LIST
69131: LIST
69132: PUSH
69133: LD_INT 3
69135: PUSH
69136: LD_INT 1
69138: PUSH
69139: EMPTY
69140: LIST
69141: LIST
69142: PUSH
69143: LD_INT 3
69145: PUSH
69146: LD_INT 2
69148: PUSH
69149: EMPTY
69150: LIST
69151: LIST
69152: PUSH
69153: EMPTY
69154: LIST
69155: LIST
69156: LIST
69157: LIST
69158: LIST
69159: LIST
69160: LIST
69161: LIST
69162: LIST
69163: LIST
69164: LIST
69165: LIST
69166: LIST
69167: LIST
69168: LIST
69169: LIST
69170: LIST
69171: LIST
69172: LIST
69173: LIST
69174: LIST
69175: LIST
69176: LIST
69177: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
69178: LD_ADDR_VAR 0 25
69182: PUSH
69183: LD_INT 0
69185: PUSH
69186: LD_INT 0
69188: PUSH
69189: EMPTY
69190: LIST
69191: LIST
69192: PUSH
69193: LD_INT 0
69195: PUSH
69196: LD_INT 1
69198: NEG
69199: PUSH
69200: EMPTY
69201: LIST
69202: LIST
69203: PUSH
69204: LD_INT 1
69206: PUSH
69207: LD_INT 0
69209: PUSH
69210: EMPTY
69211: LIST
69212: LIST
69213: PUSH
69214: LD_INT 1
69216: PUSH
69217: LD_INT 1
69219: PUSH
69220: EMPTY
69221: LIST
69222: LIST
69223: PUSH
69224: LD_INT 0
69226: PUSH
69227: LD_INT 1
69229: PUSH
69230: EMPTY
69231: LIST
69232: LIST
69233: PUSH
69234: LD_INT 1
69236: NEG
69237: PUSH
69238: LD_INT 0
69240: PUSH
69241: EMPTY
69242: LIST
69243: LIST
69244: PUSH
69245: LD_INT 1
69247: NEG
69248: PUSH
69249: LD_INT 1
69251: NEG
69252: PUSH
69253: EMPTY
69254: LIST
69255: LIST
69256: PUSH
69257: LD_INT 1
69259: NEG
69260: PUSH
69261: LD_INT 2
69263: NEG
69264: PUSH
69265: EMPTY
69266: LIST
69267: LIST
69268: PUSH
69269: LD_INT 0
69271: PUSH
69272: LD_INT 2
69274: NEG
69275: PUSH
69276: EMPTY
69277: LIST
69278: LIST
69279: PUSH
69280: LD_INT 1
69282: PUSH
69283: LD_INT 1
69285: NEG
69286: PUSH
69287: EMPTY
69288: LIST
69289: LIST
69290: PUSH
69291: LD_INT 2
69293: PUSH
69294: LD_INT 0
69296: PUSH
69297: EMPTY
69298: LIST
69299: LIST
69300: PUSH
69301: LD_INT 2
69303: PUSH
69304: LD_INT 1
69306: PUSH
69307: EMPTY
69308: LIST
69309: LIST
69310: PUSH
69311: LD_INT 2
69313: PUSH
69314: LD_INT 2
69316: PUSH
69317: EMPTY
69318: LIST
69319: LIST
69320: PUSH
69321: LD_INT 1
69323: PUSH
69324: LD_INT 2
69326: PUSH
69327: EMPTY
69328: LIST
69329: LIST
69330: PUSH
69331: LD_INT 0
69333: PUSH
69334: LD_INT 2
69336: PUSH
69337: EMPTY
69338: LIST
69339: LIST
69340: PUSH
69341: LD_INT 1
69343: NEG
69344: PUSH
69345: LD_INT 1
69347: PUSH
69348: EMPTY
69349: LIST
69350: LIST
69351: PUSH
69352: LD_INT 2
69354: NEG
69355: PUSH
69356: LD_INT 0
69358: PUSH
69359: EMPTY
69360: LIST
69361: LIST
69362: PUSH
69363: LD_INT 2
69365: NEG
69366: PUSH
69367: LD_INT 1
69369: NEG
69370: PUSH
69371: EMPTY
69372: LIST
69373: LIST
69374: PUSH
69375: LD_INT 2
69377: NEG
69378: PUSH
69379: LD_INT 2
69381: NEG
69382: PUSH
69383: EMPTY
69384: LIST
69385: LIST
69386: PUSH
69387: LD_INT 3
69389: PUSH
69390: LD_INT 1
69392: PUSH
69393: EMPTY
69394: LIST
69395: LIST
69396: PUSH
69397: LD_INT 3
69399: PUSH
69400: LD_INT 2
69402: PUSH
69403: EMPTY
69404: LIST
69405: LIST
69406: PUSH
69407: LD_INT 2
69409: PUSH
69410: LD_INT 3
69412: PUSH
69413: EMPTY
69414: LIST
69415: LIST
69416: PUSH
69417: LD_INT 1
69419: PUSH
69420: LD_INT 3
69422: PUSH
69423: EMPTY
69424: LIST
69425: LIST
69426: PUSH
69427: EMPTY
69428: LIST
69429: LIST
69430: LIST
69431: LIST
69432: LIST
69433: LIST
69434: LIST
69435: LIST
69436: LIST
69437: LIST
69438: LIST
69439: LIST
69440: LIST
69441: LIST
69442: LIST
69443: LIST
69444: LIST
69445: LIST
69446: LIST
69447: LIST
69448: LIST
69449: LIST
69450: LIST
69451: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
69452: LD_ADDR_VAR 0 26
69456: PUSH
69457: LD_INT 0
69459: PUSH
69460: LD_INT 0
69462: PUSH
69463: EMPTY
69464: LIST
69465: LIST
69466: PUSH
69467: LD_INT 0
69469: PUSH
69470: LD_INT 1
69472: NEG
69473: PUSH
69474: EMPTY
69475: LIST
69476: LIST
69477: PUSH
69478: LD_INT 1
69480: PUSH
69481: LD_INT 0
69483: PUSH
69484: EMPTY
69485: LIST
69486: LIST
69487: PUSH
69488: LD_INT 1
69490: PUSH
69491: LD_INT 1
69493: PUSH
69494: EMPTY
69495: LIST
69496: LIST
69497: PUSH
69498: LD_INT 0
69500: PUSH
69501: LD_INT 1
69503: PUSH
69504: EMPTY
69505: LIST
69506: LIST
69507: PUSH
69508: LD_INT 1
69510: NEG
69511: PUSH
69512: LD_INT 0
69514: PUSH
69515: EMPTY
69516: LIST
69517: LIST
69518: PUSH
69519: LD_INT 1
69521: NEG
69522: PUSH
69523: LD_INT 1
69525: NEG
69526: PUSH
69527: EMPTY
69528: LIST
69529: LIST
69530: PUSH
69531: LD_INT 1
69533: NEG
69534: PUSH
69535: LD_INT 2
69537: NEG
69538: PUSH
69539: EMPTY
69540: LIST
69541: LIST
69542: PUSH
69543: LD_INT 0
69545: PUSH
69546: LD_INT 2
69548: NEG
69549: PUSH
69550: EMPTY
69551: LIST
69552: LIST
69553: PUSH
69554: LD_INT 1
69556: PUSH
69557: LD_INT 1
69559: NEG
69560: PUSH
69561: EMPTY
69562: LIST
69563: LIST
69564: PUSH
69565: LD_INT 2
69567: PUSH
69568: LD_INT 0
69570: PUSH
69571: EMPTY
69572: LIST
69573: LIST
69574: PUSH
69575: LD_INT 2
69577: PUSH
69578: LD_INT 1
69580: PUSH
69581: EMPTY
69582: LIST
69583: LIST
69584: PUSH
69585: LD_INT 2
69587: PUSH
69588: LD_INT 2
69590: PUSH
69591: EMPTY
69592: LIST
69593: LIST
69594: PUSH
69595: LD_INT 1
69597: PUSH
69598: LD_INT 2
69600: PUSH
69601: EMPTY
69602: LIST
69603: LIST
69604: PUSH
69605: LD_INT 0
69607: PUSH
69608: LD_INT 2
69610: PUSH
69611: EMPTY
69612: LIST
69613: LIST
69614: PUSH
69615: LD_INT 1
69617: NEG
69618: PUSH
69619: LD_INT 1
69621: PUSH
69622: EMPTY
69623: LIST
69624: LIST
69625: PUSH
69626: LD_INT 2
69628: NEG
69629: PUSH
69630: LD_INT 0
69632: PUSH
69633: EMPTY
69634: LIST
69635: LIST
69636: PUSH
69637: LD_INT 2
69639: NEG
69640: PUSH
69641: LD_INT 1
69643: NEG
69644: PUSH
69645: EMPTY
69646: LIST
69647: LIST
69648: PUSH
69649: LD_INT 2
69651: NEG
69652: PUSH
69653: LD_INT 2
69655: NEG
69656: PUSH
69657: EMPTY
69658: LIST
69659: LIST
69660: PUSH
69661: LD_INT 2
69663: PUSH
69664: LD_INT 3
69666: PUSH
69667: EMPTY
69668: LIST
69669: LIST
69670: PUSH
69671: LD_INT 1
69673: PUSH
69674: LD_INT 3
69676: PUSH
69677: EMPTY
69678: LIST
69679: LIST
69680: PUSH
69681: LD_INT 1
69683: NEG
69684: PUSH
69685: LD_INT 2
69687: PUSH
69688: EMPTY
69689: LIST
69690: LIST
69691: PUSH
69692: LD_INT 2
69694: NEG
69695: PUSH
69696: LD_INT 1
69698: PUSH
69699: EMPTY
69700: LIST
69701: LIST
69702: PUSH
69703: EMPTY
69704: LIST
69705: LIST
69706: LIST
69707: LIST
69708: LIST
69709: LIST
69710: LIST
69711: LIST
69712: LIST
69713: LIST
69714: LIST
69715: LIST
69716: LIST
69717: LIST
69718: LIST
69719: LIST
69720: LIST
69721: LIST
69722: LIST
69723: LIST
69724: LIST
69725: LIST
69726: LIST
69727: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
69728: LD_ADDR_VAR 0 27
69732: PUSH
69733: LD_INT 0
69735: PUSH
69736: LD_INT 0
69738: PUSH
69739: EMPTY
69740: LIST
69741: LIST
69742: PUSH
69743: LD_INT 0
69745: PUSH
69746: LD_INT 1
69748: NEG
69749: PUSH
69750: EMPTY
69751: LIST
69752: LIST
69753: PUSH
69754: LD_INT 1
69756: PUSH
69757: LD_INT 0
69759: PUSH
69760: EMPTY
69761: LIST
69762: LIST
69763: PUSH
69764: LD_INT 1
69766: PUSH
69767: LD_INT 1
69769: PUSH
69770: EMPTY
69771: LIST
69772: LIST
69773: PUSH
69774: LD_INT 0
69776: PUSH
69777: LD_INT 1
69779: PUSH
69780: EMPTY
69781: LIST
69782: LIST
69783: PUSH
69784: LD_INT 1
69786: NEG
69787: PUSH
69788: LD_INT 0
69790: PUSH
69791: EMPTY
69792: LIST
69793: LIST
69794: PUSH
69795: LD_INT 1
69797: NEG
69798: PUSH
69799: LD_INT 1
69801: NEG
69802: PUSH
69803: EMPTY
69804: LIST
69805: LIST
69806: PUSH
69807: LD_INT 1
69809: NEG
69810: PUSH
69811: LD_INT 2
69813: NEG
69814: PUSH
69815: EMPTY
69816: LIST
69817: LIST
69818: PUSH
69819: LD_INT 0
69821: PUSH
69822: LD_INT 2
69824: NEG
69825: PUSH
69826: EMPTY
69827: LIST
69828: LIST
69829: PUSH
69830: LD_INT 1
69832: PUSH
69833: LD_INT 1
69835: NEG
69836: PUSH
69837: EMPTY
69838: LIST
69839: LIST
69840: PUSH
69841: LD_INT 2
69843: PUSH
69844: LD_INT 0
69846: PUSH
69847: EMPTY
69848: LIST
69849: LIST
69850: PUSH
69851: LD_INT 2
69853: PUSH
69854: LD_INT 1
69856: PUSH
69857: EMPTY
69858: LIST
69859: LIST
69860: PUSH
69861: LD_INT 2
69863: PUSH
69864: LD_INT 2
69866: PUSH
69867: EMPTY
69868: LIST
69869: LIST
69870: PUSH
69871: LD_INT 1
69873: PUSH
69874: LD_INT 2
69876: PUSH
69877: EMPTY
69878: LIST
69879: LIST
69880: PUSH
69881: LD_INT 0
69883: PUSH
69884: LD_INT 2
69886: PUSH
69887: EMPTY
69888: LIST
69889: LIST
69890: PUSH
69891: LD_INT 1
69893: NEG
69894: PUSH
69895: LD_INT 1
69897: PUSH
69898: EMPTY
69899: LIST
69900: LIST
69901: PUSH
69902: LD_INT 2
69904: NEG
69905: PUSH
69906: LD_INT 0
69908: PUSH
69909: EMPTY
69910: LIST
69911: LIST
69912: PUSH
69913: LD_INT 2
69915: NEG
69916: PUSH
69917: LD_INT 1
69919: NEG
69920: PUSH
69921: EMPTY
69922: LIST
69923: LIST
69924: PUSH
69925: LD_INT 2
69927: NEG
69928: PUSH
69929: LD_INT 2
69931: NEG
69932: PUSH
69933: EMPTY
69934: LIST
69935: LIST
69936: PUSH
69937: LD_INT 1
69939: NEG
69940: PUSH
69941: LD_INT 2
69943: PUSH
69944: EMPTY
69945: LIST
69946: LIST
69947: PUSH
69948: LD_INT 2
69950: NEG
69951: PUSH
69952: LD_INT 1
69954: PUSH
69955: EMPTY
69956: LIST
69957: LIST
69958: PUSH
69959: LD_INT 3
69961: NEG
69962: PUSH
69963: LD_INT 1
69965: NEG
69966: PUSH
69967: EMPTY
69968: LIST
69969: LIST
69970: PUSH
69971: LD_INT 3
69973: NEG
69974: PUSH
69975: LD_INT 2
69977: NEG
69978: PUSH
69979: EMPTY
69980: LIST
69981: LIST
69982: PUSH
69983: EMPTY
69984: LIST
69985: LIST
69986: LIST
69987: LIST
69988: LIST
69989: LIST
69990: LIST
69991: LIST
69992: LIST
69993: LIST
69994: LIST
69995: LIST
69996: LIST
69997: LIST
69998: LIST
69999: LIST
70000: LIST
70001: LIST
70002: LIST
70003: LIST
70004: LIST
70005: LIST
70006: LIST
70007: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
70008: LD_ADDR_VAR 0 28
70012: PUSH
70013: LD_INT 0
70015: PUSH
70016: LD_INT 0
70018: PUSH
70019: EMPTY
70020: LIST
70021: LIST
70022: PUSH
70023: LD_INT 0
70025: PUSH
70026: LD_INT 1
70028: NEG
70029: PUSH
70030: EMPTY
70031: LIST
70032: LIST
70033: PUSH
70034: LD_INT 1
70036: PUSH
70037: LD_INT 0
70039: PUSH
70040: EMPTY
70041: LIST
70042: LIST
70043: PUSH
70044: LD_INT 1
70046: PUSH
70047: LD_INT 1
70049: PUSH
70050: EMPTY
70051: LIST
70052: LIST
70053: PUSH
70054: LD_INT 0
70056: PUSH
70057: LD_INT 1
70059: PUSH
70060: EMPTY
70061: LIST
70062: LIST
70063: PUSH
70064: LD_INT 1
70066: NEG
70067: PUSH
70068: LD_INT 0
70070: PUSH
70071: EMPTY
70072: LIST
70073: LIST
70074: PUSH
70075: LD_INT 1
70077: NEG
70078: PUSH
70079: LD_INT 1
70081: NEG
70082: PUSH
70083: EMPTY
70084: LIST
70085: LIST
70086: PUSH
70087: LD_INT 1
70089: NEG
70090: PUSH
70091: LD_INT 2
70093: NEG
70094: PUSH
70095: EMPTY
70096: LIST
70097: LIST
70098: PUSH
70099: LD_INT 0
70101: PUSH
70102: LD_INT 2
70104: NEG
70105: PUSH
70106: EMPTY
70107: LIST
70108: LIST
70109: PUSH
70110: LD_INT 1
70112: PUSH
70113: LD_INT 1
70115: NEG
70116: PUSH
70117: EMPTY
70118: LIST
70119: LIST
70120: PUSH
70121: LD_INT 2
70123: PUSH
70124: LD_INT 0
70126: PUSH
70127: EMPTY
70128: LIST
70129: LIST
70130: PUSH
70131: LD_INT 2
70133: PUSH
70134: LD_INT 1
70136: PUSH
70137: EMPTY
70138: LIST
70139: LIST
70140: PUSH
70141: LD_INT 2
70143: PUSH
70144: LD_INT 2
70146: PUSH
70147: EMPTY
70148: LIST
70149: LIST
70150: PUSH
70151: LD_INT 1
70153: PUSH
70154: LD_INT 2
70156: PUSH
70157: EMPTY
70158: LIST
70159: LIST
70160: PUSH
70161: LD_INT 0
70163: PUSH
70164: LD_INT 2
70166: PUSH
70167: EMPTY
70168: LIST
70169: LIST
70170: PUSH
70171: LD_INT 1
70173: NEG
70174: PUSH
70175: LD_INT 1
70177: PUSH
70178: EMPTY
70179: LIST
70180: LIST
70181: PUSH
70182: LD_INT 2
70184: NEG
70185: PUSH
70186: LD_INT 0
70188: PUSH
70189: EMPTY
70190: LIST
70191: LIST
70192: PUSH
70193: LD_INT 2
70195: NEG
70196: PUSH
70197: LD_INT 1
70199: NEG
70200: PUSH
70201: EMPTY
70202: LIST
70203: LIST
70204: PUSH
70205: LD_INT 2
70207: NEG
70208: PUSH
70209: LD_INT 2
70211: NEG
70212: PUSH
70213: EMPTY
70214: LIST
70215: LIST
70216: PUSH
70217: LD_INT 2
70219: NEG
70220: PUSH
70221: LD_INT 3
70223: NEG
70224: PUSH
70225: EMPTY
70226: LIST
70227: LIST
70228: PUSH
70229: LD_INT 1
70231: NEG
70232: PUSH
70233: LD_INT 3
70235: NEG
70236: PUSH
70237: EMPTY
70238: LIST
70239: LIST
70240: PUSH
70241: LD_INT 3
70243: NEG
70244: PUSH
70245: LD_INT 1
70247: NEG
70248: PUSH
70249: EMPTY
70250: LIST
70251: LIST
70252: PUSH
70253: LD_INT 3
70255: NEG
70256: PUSH
70257: LD_INT 2
70259: NEG
70260: PUSH
70261: EMPTY
70262: LIST
70263: LIST
70264: PUSH
70265: EMPTY
70266: LIST
70267: LIST
70268: LIST
70269: LIST
70270: LIST
70271: LIST
70272: LIST
70273: LIST
70274: LIST
70275: LIST
70276: LIST
70277: LIST
70278: LIST
70279: LIST
70280: LIST
70281: LIST
70282: LIST
70283: LIST
70284: LIST
70285: LIST
70286: LIST
70287: LIST
70288: LIST
70289: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70290: LD_ADDR_VAR 0 29
70294: PUSH
70295: LD_INT 0
70297: PUSH
70298: LD_INT 0
70300: PUSH
70301: EMPTY
70302: LIST
70303: LIST
70304: PUSH
70305: LD_INT 0
70307: PUSH
70308: LD_INT 1
70310: NEG
70311: PUSH
70312: EMPTY
70313: LIST
70314: LIST
70315: PUSH
70316: LD_INT 1
70318: PUSH
70319: LD_INT 0
70321: PUSH
70322: EMPTY
70323: LIST
70324: LIST
70325: PUSH
70326: LD_INT 1
70328: PUSH
70329: LD_INT 1
70331: PUSH
70332: EMPTY
70333: LIST
70334: LIST
70335: PUSH
70336: LD_INT 0
70338: PUSH
70339: LD_INT 1
70341: PUSH
70342: EMPTY
70343: LIST
70344: LIST
70345: PUSH
70346: LD_INT 1
70348: NEG
70349: PUSH
70350: LD_INT 0
70352: PUSH
70353: EMPTY
70354: LIST
70355: LIST
70356: PUSH
70357: LD_INT 1
70359: NEG
70360: PUSH
70361: LD_INT 1
70363: NEG
70364: PUSH
70365: EMPTY
70366: LIST
70367: LIST
70368: PUSH
70369: LD_INT 1
70371: NEG
70372: PUSH
70373: LD_INT 2
70375: NEG
70376: PUSH
70377: EMPTY
70378: LIST
70379: LIST
70380: PUSH
70381: LD_INT 0
70383: PUSH
70384: LD_INT 2
70386: NEG
70387: PUSH
70388: EMPTY
70389: LIST
70390: LIST
70391: PUSH
70392: LD_INT 1
70394: PUSH
70395: LD_INT 1
70397: NEG
70398: PUSH
70399: EMPTY
70400: LIST
70401: LIST
70402: PUSH
70403: LD_INT 2
70405: PUSH
70406: LD_INT 0
70408: PUSH
70409: EMPTY
70410: LIST
70411: LIST
70412: PUSH
70413: LD_INT 2
70415: PUSH
70416: LD_INT 1
70418: PUSH
70419: EMPTY
70420: LIST
70421: LIST
70422: PUSH
70423: LD_INT 1
70425: PUSH
70426: LD_INT 2
70428: PUSH
70429: EMPTY
70430: LIST
70431: LIST
70432: PUSH
70433: LD_INT 0
70435: PUSH
70436: LD_INT 2
70438: PUSH
70439: EMPTY
70440: LIST
70441: LIST
70442: PUSH
70443: LD_INT 1
70445: NEG
70446: PUSH
70447: LD_INT 1
70449: PUSH
70450: EMPTY
70451: LIST
70452: LIST
70453: PUSH
70454: LD_INT 2
70456: NEG
70457: PUSH
70458: LD_INT 1
70460: NEG
70461: PUSH
70462: EMPTY
70463: LIST
70464: LIST
70465: PUSH
70466: LD_INT 2
70468: NEG
70469: PUSH
70470: LD_INT 2
70472: NEG
70473: PUSH
70474: EMPTY
70475: LIST
70476: LIST
70477: PUSH
70478: LD_INT 2
70480: NEG
70481: PUSH
70482: LD_INT 3
70484: NEG
70485: PUSH
70486: EMPTY
70487: LIST
70488: LIST
70489: PUSH
70490: LD_INT 2
70492: PUSH
70493: LD_INT 1
70495: NEG
70496: PUSH
70497: EMPTY
70498: LIST
70499: LIST
70500: PUSH
70501: LD_INT 3
70503: PUSH
70504: LD_INT 1
70506: PUSH
70507: EMPTY
70508: LIST
70509: LIST
70510: PUSH
70511: LD_INT 1
70513: PUSH
70514: LD_INT 3
70516: PUSH
70517: EMPTY
70518: LIST
70519: LIST
70520: PUSH
70521: LD_INT 1
70523: NEG
70524: PUSH
70525: LD_INT 2
70527: PUSH
70528: EMPTY
70529: LIST
70530: LIST
70531: PUSH
70532: LD_INT 3
70534: NEG
70535: PUSH
70536: LD_INT 2
70538: NEG
70539: PUSH
70540: EMPTY
70541: LIST
70542: LIST
70543: PUSH
70544: EMPTY
70545: LIST
70546: LIST
70547: LIST
70548: LIST
70549: LIST
70550: LIST
70551: LIST
70552: LIST
70553: LIST
70554: LIST
70555: LIST
70556: LIST
70557: LIST
70558: LIST
70559: LIST
70560: LIST
70561: LIST
70562: LIST
70563: LIST
70564: LIST
70565: LIST
70566: LIST
70567: LIST
70568: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70569: LD_ADDR_VAR 0 30
70573: PUSH
70574: LD_INT 0
70576: PUSH
70577: LD_INT 0
70579: PUSH
70580: EMPTY
70581: LIST
70582: LIST
70583: PUSH
70584: LD_INT 0
70586: PUSH
70587: LD_INT 1
70589: NEG
70590: PUSH
70591: EMPTY
70592: LIST
70593: LIST
70594: PUSH
70595: LD_INT 1
70597: PUSH
70598: LD_INT 0
70600: PUSH
70601: EMPTY
70602: LIST
70603: LIST
70604: PUSH
70605: LD_INT 1
70607: PUSH
70608: LD_INT 1
70610: PUSH
70611: EMPTY
70612: LIST
70613: LIST
70614: PUSH
70615: LD_INT 0
70617: PUSH
70618: LD_INT 1
70620: PUSH
70621: EMPTY
70622: LIST
70623: LIST
70624: PUSH
70625: LD_INT 1
70627: NEG
70628: PUSH
70629: LD_INT 0
70631: PUSH
70632: EMPTY
70633: LIST
70634: LIST
70635: PUSH
70636: LD_INT 1
70638: NEG
70639: PUSH
70640: LD_INT 1
70642: NEG
70643: PUSH
70644: EMPTY
70645: LIST
70646: LIST
70647: PUSH
70648: LD_INT 1
70650: NEG
70651: PUSH
70652: LD_INT 2
70654: NEG
70655: PUSH
70656: EMPTY
70657: LIST
70658: LIST
70659: PUSH
70660: LD_INT 0
70662: PUSH
70663: LD_INT 2
70665: NEG
70666: PUSH
70667: EMPTY
70668: LIST
70669: LIST
70670: PUSH
70671: LD_INT 1
70673: PUSH
70674: LD_INT 1
70676: NEG
70677: PUSH
70678: EMPTY
70679: LIST
70680: LIST
70681: PUSH
70682: LD_INT 2
70684: PUSH
70685: LD_INT 0
70687: PUSH
70688: EMPTY
70689: LIST
70690: LIST
70691: PUSH
70692: LD_INT 2
70694: PUSH
70695: LD_INT 1
70697: PUSH
70698: EMPTY
70699: LIST
70700: LIST
70701: PUSH
70702: LD_INT 2
70704: PUSH
70705: LD_INT 2
70707: PUSH
70708: EMPTY
70709: LIST
70710: LIST
70711: PUSH
70712: LD_INT 1
70714: PUSH
70715: LD_INT 2
70717: PUSH
70718: EMPTY
70719: LIST
70720: LIST
70721: PUSH
70722: LD_INT 1
70724: NEG
70725: PUSH
70726: LD_INT 1
70728: PUSH
70729: EMPTY
70730: LIST
70731: LIST
70732: PUSH
70733: LD_INT 2
70735: NEG
70736: PUSH
70737: LD_INT 0
70739: PUSH
70740: EMPTY
70741: LIST
70742: LIST
70743: PUSH
70744: LD_INT 2
70746: NEG
70747: PUSH
70748: LD_INT 1
70750: NEG
70751: PUSH
70752: EMPTY
70753: LIST
70754: LIST
70755: PUSH
70756: LD_INT 1
70758: NEG
70759: PUSH
70760: LD_INT 3
70762: NEG
70763: PUSH
70764: EMPTY
70765: LIST
70766: LIST
70767: PUSH
70768: LD_INT 1
70770: PUSH
70771: LD_INT 2
70773: NEG
70774: PUSH
70775: EMPTY
70776: LIST
70777: LIST
70778: PUSH
70779: LD_INT 3
70781: PUSH
70782: LD_INT 2
70784: PUSH
70785: EMPTY
70786: LIST
70787: LIST
70788: PUSH
70789: LD_INT 2
70791: PUSH
70792: LD_INT 3
70794: PUSH
70795: EMPTY
70796: LIST
70797: LIST
70798: PUSH
70799: LD_INT 2
70801: NEG
70802: PUSH
70803: LD_INT 1
70805: PUSH
70806: EMPTY
70807: LIST
70808: LIST
70809: PUSH
70810: LD_INT 3
70812: NEG
70813: PUSH
70814: LD_INT 1
70816: NEG
70817: PUSH
70818: EMPTY
70819: LIST
70820: LIST
70821: PUSH
70822: EMPTY
70823: LIST
70824: LIST
70825: LIST
70826: LIST
70827: LIST
70828: LIST
70829: LIST
70830: LIST
70831: LIST
70832: LIST
70833: LIST
70834: LIST
70835: LIST
70836: LIST
70837: LIST
70838: LIST
70839: LIST
70840: LIST
70841: LIST
70842: LIST
70843: LIST
70844: LIST
70845: LIST
70846: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70847: LD_ADDR_VAR 0 31
70851: PUSH
70852: LD_INT 0
70854: PUSH
70855: LD_INT 0
70857: PUSH
70858: EMPTY
70859: LIST
70860: LIST
70861: PUSH
70862: LD_INT 0
70864: PUSH
70865: LD_INT 1
70867: NEG
70868: PUSH
70869: EMPTY
70870: LIST
70871: LIST
70872: PUSH
70873: LD_INT 1
70875: PUSH
70876: LD_INT 0
70878: PUSH
70879: EMPTY
70880: LIST
70881: LIST
70882: PUSH
70883: LD_INT 1
70885: PUSH
70886: LD_INT 1
70888: PUSH
70889: EMPTY
70890: LIST
70891: LIST
70892: PUSH
70893: LD_INT 0
70895: PUSH
70896: LD_INT 1
70898: PUSH
70899: EMPTY
70900: LIST
70901: LIST
70902: PUSH
70903: LD_INT 1
70905: NEG
70906: PUSH
70907: LD_INT 0
70909: PUSH
70910: EMPTY
70911: LIST
70912: LIST
70913: PUSH
70914: LD_INT 1
70916: NEG
70917: PUSH
70918: LD_INT 1
70920: NEG
70921: PUSH
70922: EMPTY
70923: LIST
70924: LIST
70925: PUSH
70926: LD_INT 1
70928: NEG
70929: PUSH
70930: LD_INT 2
70932: NEG
70933: PUSH
70934: EMPTY
70935: LIST
70936: LIST
70937: PUSH
70938: LD_INT 1
70940: PUSH
70941: LD_INT 1
70943: NEG
70944: PUSH
70945: EMPTY
70946: LIST
70947: LIST
70948: PUSH
70949: LD_INT 2
70951: PUSH
70952: LD_INT 0
70954: PUSH
70955: EMPTY
70956: LIST
70957: LIST
70958: PUSH
70959: LD_INT 2
70961: PUSH
70962: LD_INT 1
70964: PUSH
70965: EMPTY
70966: LIST
70967: LIST
70968: PUSH
70969: LD_INT 2
70971: PUSH
70972: LD_INT 2
70974: PUSH
70975: EMPTY
70976: LIST
70977: LIST
70978: PUSH
70979: LD_INT 1
70981: PUSH
70982: LD_INT 2
70984: PUSH
70985: EMPTY
70986: LIST
70987: LIST
70988: PUSH
70989: LD_INT 0
70991: PUSH
70992: LD_INT 2
70994: PUSH
70995: EMPTY
70996: LIST
70997: LIST
70998: PUSH
70999: LD_INT 1
71001: NEG
71002: PUSH
71003: LD_INT 1
71005: PUSH
71006: EMPTY
71007: LIST
71008: LIST
71009: PUSH
71010: LD_INT 2
71012: NEG
71013: PUSH
71014: LD_INT 1
71016: NEG
71017: PUSH
71018: EMPTY
71019: LIST
71020: LIST
71021: PUSH
71022: LD_INT 2
71024: NEG
71025: PUSH
71026: LD_INT 2
71028: NEG
71029: PUSH
71030: EMPTY
71031: LIST
71032: LIST
71033: PUSH
71034: LD_INT 2
71036: NEG
71037: PUSH
71038: LD_INT 3
71040: NEG
71041: PUSH
71042: EMPTY
71043: LIST
71044: LIST
71045: PUSH
71046: LD_INT 2
71048: PUSH
71049: LD_INT 1
71051: NEG
71052: PUSH
71053: EMPTY
71054: LIST
71055: LIST
71056: PUSH
71057: LD_INT 3
71059: PUSH
71060: LD_INT 1
71062: PUSH
71063: EMPTY
71064: LIST
71065: LIST
71066: PUSH
71067: LD_INT 1
71069: PUSH
71070: LD_INT 3
71072: PUSH
71073: EMPTY
71074: LIST
71075: LIST
71076: PUSH
71077: LD_INT 1
71079: NEG
71080: PUSH
71081: LD_INT 2
71083: PUSH
71084: EMPTY
71085: LIST
71086: LIST
71087: PUSH
71088: LD_INT 3
71090: NEG
71091: PUSH
71092: LD_INT 2
71094: NEG
71095: PUSH
71096: EMPTY
71097: LIST
71098: LIST
71099: PUSH
71100: EMPTY
71101: LIST
71102: LIST
71103: LIST
71104: LIST
71105: LIST
71106: LIST
71107: LIST
71108: LIST
71109: LIST
71110: LIST
71111: LIST
71112: LIST
71113: LIST
71114: LIST
71115: LIST
71116: LIST
71117: LIST
71118: LIST
71119: LIST
71120: LIST
71121: LIST
71122: LIST
71123: LIST
71124: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71125: LD_ADDR_VAR 0 32
71129: PUSH
71130: LD_INT 0
71132: PUSH
71133: LD_INT 0
71135: PUSH
71136: EMPTY
71137: LIST
71138: LIST
71139: PUSH
71140: LD_INT 0
71142: PUSH
71143: LD_INT 1
71145: NEG
71146: PUSH
71147: EMPTY
71148: LIST
71149: LIST
71150: PUSH
71151: LD_INT 1
71153: PUSH
71154: LD_INT 0
71156: PUSH
71157: EMPTY
71158: LIST
71159: LIST
71160: PUSH
71161: LD_INT 1
71163: PUSH
71164: LD_INT 1
71166: PUSH
71167: EMPTY
71168: LIST
71169: LIST
71170: PUSH
71171: LD_INT 0
71173: PUSH
71174: LD_INT 1
71176: PUSH
71177: EMPTY
71178: LIST
71179: LIST
71180: PUSH
71181: LD_INT 1
71183: NEG
71184: PUSH
71185: LD_INT 0
71187: PUSH
71188: EMPTY
71189: LIST
71190: LIST
71191: PUSH
71192: LD_INT 1
71194: NEG
71195: PUSH
71196: LD_INT 1
71198: NEG
71199: PUSH
71200: EMPTY
71201: LIST
71202: LIST
71203: PUSH
71204: LD_INT 1
71206: NEG
71207: PUSH
71208: LD_INT 2
71210: NEG
71211: PUSH
71212: EMPTY
71213: LIST
71214: LIST
71215: PUSH
71216: LD_INT 0
71218: PUSH
71219: LD_INT 2
71221: NEG
71222: PUSH
71223: EMPTY
71224: LIST
71225: LIST
71226: PUSH
71227: LD_INT 1
71229: PUSH
71230: LD_INT 1
71232: NEG
71233: PUSH
71234: EMPTY
71235: LIST
71236: LIST
71237: PUSH
71238: LD_INT 2
71240: PUSH
71241: LD_INT 1
71243: PUSH
71244: EMPTY
71245: LIST
71246: LIST
71247: PUSH
71248: LD_INT 2
71250: PUSH
71251: LD_INT 2
71253: PUSH
71254: EMPTY
71255: LIST
71256: LIST
71257: PUSH
71258: LD_INT 1
71260: PUSH
71261: LD_INT 2
71263: PUSH
71264: EMPTY
71265: LIST
71266: LIST
71267: PUSH
71268: LD_INT 0
71270: PUSH
71271: LD_INT 2
71273: PUSH
71274: EMPTY
71275: LIST
71276: LIST
71277: PUSH
71278: LD_INT 1
71280: NEG
71281: PUSH
71282: LD_INT 1
71284: PUSH
71285: EMPTY
71286: LIST
71287: LIST
71288: PUSH
71289: LD_INT 2
71291: NEG
71292: PUSH
71293: LD_INT 0
71295: PUSH
71296: EMPTY
71297: LIST
71298: LIST
71299: PUSH
71300: LD_INT 2
71302: NEG
71303: PUSH
71304: LD_INT 1
71306: NEG
71307: PUSH
71308: EMPTY
71309: LIST
71310: LIST
71311: PUSH
71312: LD_INT 1
71314: NEG
71315: PUSH
71316: LD_INT 3
71318: NEG
71319: PUSH
71320: EMPTY
71321: LIST
71322: LIST
71323: PUSH
71324: LD_INT 1
71326: PUSH
71327: LD_INT 2
71329: NEG
71330: PUSH
71331: EMPTY
71332: LIST
71333: LIST
71334: PUSH
71335: LD_INT 3
71337: PUSH
71338: LD_INT 2
71340: PUSH
71341: EMPTY
71342: LIST
71343: LIST
71344: PUSH
71345: LD_INT 2
71347: PUSH
71348: LD_INT 3
71350: PUSH
71351: EMPTY
71352: LIST
71353: LIST
71354: PUSH
71355: LD_INT 2
71357: NEG
71358: PUSH
71359: LD_INT 1
71361: PUSH
71362: EMPTY
71363: LIST
71364: LIST
71365: PUSH
71366: LD_INT 3
71368: NEG
71369: PUSH
71370: LD_INT 1
71372: NEG
71373: PUSH
71374: EMPTY
71375: LIST
71376: LIST
71377: PUSH
71378: EMPTY
71379: LIST
71380: LIST
71381: LIST
71382: LIST
71383: LIST
71384: LIST
71385: LIST
71386: LIST
71387: LIST
71388: LIST
71389: LIST
71390: LIST
71391: LIST
71392: LIST
71393: LIST
71394: LIST
71395: LIST
71396: LIST
71397: LIST
71398: LIST
71399: LIST
71400: LIST
71401: LIST
71402: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71403: LD_ADDR_VAR 0 33
71407: PUSH
71408: LD_INT 0
71410: PUSH
71411: LD_INT 0
71413: PUSH
71414: EMPTY
71415: LIST
71416: LIST
71417: PUSH
71418: LD_INT 0
71420: PUSH
71421: LD_INT 1
71423: NEG
71424: PUSH
71425: EMPTY
71426: LIST
71427: LIST
71428: PUSH
71429: LD_INT 1
71431: PUSH
71432: LD_INT 0
71434: PUSH
71435: EMPTY
71436: LIST
71437: LIST
71438: PUSH
71439: LD_INT 1
71441: PUSH
71442: LD_INT 1
71444: PUSH
71445: EMPTY
71446: LIST
71447: LIST
71448: PUSH
71449: LD_INT 0
71451: PUSH
71452: LD_INT 1
71454: PUSH
71455: EMPTY
71456: LIST
71457: LIST
71458: PUSH
71459: LD_INT 1
71461: NEG
71462: PUSH
71463: LD_INT 0
71465: PUSH
71466: EMPTY
71467: LIST
71468: LIST
71469: PUSH
71470: LD_INT 1
71472: NEG
71473: PUSH
71474: LD_INT 1
71476: NEG
71477: PUSH
71478: EMPTY
71479: LIST
71480: LIST
71481: PUSH
71482: LD_INT 1
71484: NEG
71485: PUSH
71486: LD_INT 2
71488: NEG
71489: PUSH
71490: EMPTY
71491: LIST
71492: LIST
71493: PUSH
71494: LD_INT 1
71496: PUSH
71497: LD_INT 1
71499: NEG
71500: PUSH
71501: EMPTY
71502: LIST
71503: LIST
71504: PUSH
71505: LD_INT 2
71507: PUSH
71508: LD_INT 0
71510: PUSH
71511: EMPTY
71512: LIST
71513: LIST
71514: PUSH
71515: LD_INT 2
71517: PUSH
71518: LD_INT 1
71520: PUSH
71521: EMPTY
71522: LIST
71523: LIST
71524: PUSH
71525: LD_INT 1
71527: PUSH
71528: LD_INT 2
71530: PUSH
71531: EMPTY
71532: LIST
71533: LIST
71534: PUSH
71535: LD_INT 0
71537: PUSH
71538: LD_INT 2
71540: PUSH
71541: EMPTY
71542: LIST
71543: LIST
71544: PUSH
71545: LD_INT 1
71547: NEG
71548: PUSH
71549: LD_INT 1
71551: PUSH
71552: EMPTY
71553: LIST
71554: LIST
71555: PUSH
71556: LD_INT 2
71558: NEG
71559: PUSH
71560: LD_INT 0
71562: PUSH
71563: EMPTY
71564: LIST
71565: LIST
71566: PUSH
71567: LD_INT 2
71569: NEG
71570: PUSH
71571: LD_INT 1
71573: NEG
71574: PUSH
71575: EMPTY
71576: LIST
71577: LIST
71578: PUSH
71579: LD_INT 2
71581: NEG
71582: PUSH
71583: LD_INT 2
71585: NEG
71586: PUSH
71587: EMPTY
71588: LIST
71589: LIST
71590: PUSH
71591: LD_INT 2
71593: NEG
71594: PUSH
71595: LD_INT 3
71597: NEG
71598: PUSH
71599: EMPTY
71600: LIST
71601: LIST
71602: PUSH
71603: LD_INT 2
71605: PUSH
71606: LD_INT 1
71608: NEG
71609: PUSH
71610: EMPTY
71611: LIST
71612: LIST
71613: PUSH
71614: LD_INT 3
71616: PUSH
71617: LD_INT 1
71619: PUSH
71620: EMPTY
71621: LIST
71622: LIST
71623: PUSH
71624: LD_INT 1
71626: PUSH
71627: LD_INT 3
71629: PUSH
71630: EMPTY
71631: LIST
71632: LIST
71633: PUSH
71634: LD_INT 1
71636: NEG
71637: PUSH
71638: LD_INT 2
71640: PUSH
71641: EMPTY
71642: LIST
71643: LIST
71644: PUSH
71645: LD_INT 3
71647: NEG
71648: PUSH
71649: LD_INT 2
71651: NEG
71652: PUSH
71653: EMPTY
71654: LIST
71655: LIST
71656: PUSH
71657: EMPTY
71658: LIST
71659: LIST
71660: LIST
71661: LIST
71662: LIST
71663: LIST
71664: LIST
71665: LIST
71666: LIST
71667: LIST
71668: LIST
71669: LIST
71670: LIST
71671: LIST
71672: LIST
71673: LIST
71674: LIST
71675: LIST
71676: LIST
71677: LIST
71678: LIST
71679: LIST
71680: LIST
71681: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71682: LD_ADDR_VAR 0 34
71686: PUSH
71687: LD_INT 0
71689: PUSH
71690: LD_INT 0
71692: PUSH
71693: EMPTY
71694: LIST
71695: LIST
71696: PUSH
71697: LD_INT 0
71699: PUSH
71700: LD_INT 1
71702: NEG
71703: PUSH
71704: EMPTY
71705: LIST
71706: LIST
71707: PUSH
71708: LD_INT 1
71710: PUSH
71711: LD_INT 0
71713: PUSH
71714: EMPTY
71715: LIST
71716: LIST
71717: PUSH
71718: LD_INT 1
71720: PUSH
71721: LD_INT 1
71723: PUSH
71724: EMPTY
71725: LIST
71726: LIST
71727: PUSH
71728: LD_INT 0
71730: PUSH
71731: LD_INT 1
71733: PUSH
71734: EMPTY
71735: LIST
71736: LIST
71737: PUSH
71738: LD_INT 1
71740: NEG
71741: PUSH
71742: LD_INT 0
71744: PUSH
71745: EMPTY
71746: LIST
71747: LIST
71748: PUSH
71749: LD_INT 1
71751: NEG
71752: PUSH
71753: LD_INT 1
71755: NEG
71756: PUSH
71757: EMPTY
71758: LIST
71759: LIST
71760: PUSH
71761: LD_INT 1
71763: NEG
71764: PUSH
71765: LD_INT 2
71767: NEG
71768: PUSH
71769: EMPTY
71770: LIST
71771: LIST
71772: PUSH
71773: LD_INT 0
71775: PUSH
71776: LD_INT 2
71778: NEG
71779: PUSH
71780: EMPTY
71781: LIST
71782: LIST
71783: PUSH
71784: LD_INT 1
71786: PUSH
71787: LD_INT 1
71789: NEG
71790: PUSH
71791: EMPTY
71792: LIST
71793: LIST
71794: PUSH
71795: LD_INT 2
71797: PUSH
71798: LD_INT 1
71800: PUSH
71801: EMPTY
71802: LIST
71803: LIST
71804: PUSH
71805: LD_INT 2
71807: PUSH
71808: LD_INT 2
71810: PUSH
71811: EMPTY
71812: LIST
71813: LIST
71814: PUSH
71815: LD_INT 1
71817: PUSH
71818: LD_INT 2
71820: PUSH
71821: EMPTY
71822: LIST
71823: LIST
71824: PUSH
71825: LD_INT 1
71827: NEG
71828: PUSH
71829: LD_INT 1
71831: PUSH
71832: EMPTY
71833: LIST
71834: LIST
71835: PUSH
71836: LD_INT 2
71838: NEG
71839: PUSH
71840: LD_INT 0
71842: PUSH
71843: EMPTY
71844: LIST
71845: LIST
71846: PUSH
71847: LD_INT 2
71849: NEG
71850: PUSH
71851: LD_INT 1
71853: NEG
71854: PUSH
71855: EMPTY
71856: LIST
71857: LIST
71858: PUSH
71859: LD_INT 2
71861: NEG
71862: PUSH
71863: LD_INT 2
71865: NEG
71866: PUSH
71867: EMPTY
71868: LIST
71869: LIST
71870: PUSH
71871: LD_INT 1
71873: NEG
71874: PUSH
71875: LD_INT 3
71877: NEG
71878: PUSH
71879: EMPTY
71880: LIST
71881: LIST
71882: PUSH
71883: LD_INT 1
71885: PUSH
71886: LD_INT 2
71888: NEG
71889: PUSH
71890: EMPTY
71891: LIST
71892: LIST
71893: PUSH
71894: LD_INT 3
71896: PUSH
71897: LD_INT 2
71899: PUSH
71900: EMPTY
71901: LIST
71902: LIST
71903: PUSH
71904: LD_INT 2
71906: PUSH
71907: LD_INT 3
71909: PUSH
71910: EMPTY
71911: LIST
71912: LIST
71913: PUSH
71914: LD_INT 2
71916: NEG
71917: PUSH
71918: LD_INT 1
71920: PUSH
71921: EMPTY
71922: LIST
71923: LIST
71924: PUSH
71925: LD_INT 3
71927: NEG
71928: PUSH
71929: LD_INT 1
71931: NEG
71932: PUSH
71933: EMPTY
71934: LIST
71935: LIST
71936: PUSH
71937: EMPTY
71938: LIST
71939: LIST
71940: LIST
71941: LIST
71942: LIST
71943: LIST
71944: LIST
71945: LIST
71946: LIST
71947: LIST
71948: LIST
71949: LIST
71950: LIST
71951: LIST
71952: LIST
71953: LIST
71954: LIST
71955: LIST
71956: LIST
71957: LIST
71958: LIST
71959: LIST
71960: LIST
71961: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
71962: LD_ADDR_VAR 0 35
71966: PUSH
71967: LD_INT 0
71969: PUSH
71970: LD_INT 0
71972: PUSH
71973: EMPTY
71974: LIST
71975: LIST
71976: PUSH
71977: LD_INT 0
71979: PUSH
71980: LD_INT 1
71982: NEG
71983: PUSH
71984: EMPTY
71985: LIST
71986: LIST
71987: PUSH
71988: LD_INT 1
71990: PUSH
71991: LD_INT 0
71993: PUSH
71994: EMPTY
71995: LIST
71996: LIST
71997: PUSH
71998: LD_INT 1
72000: PUSH
72001: LD_INT 1
72003: PUSH
72004: EMPTY
72005: LIST
72006: LIST
72007: PUSH
72008: LD_INT 0
72010: PUSH
72011: LD_INT 1
72013: PUSH
72014: EMPTY
72015: LIST
72016: LIST
72017: PUSH
72018: LD_INT 1
72020: NEG
72021: PUSH
72022: LD_INT 0
72024: PUSH
72025: EMPTY
72026: LIST
72027: LIST
72028: PUSH
72029: LD_INT 1
72031: NEG
72032: PUSH
72033: LD_INT 1
72035: NEG
72036: PUSH
72037: EMPTY
72038: LIST
72039: LIST
72040: PUSH
72041: LD_INT 2
72043: PUSH
72044: LD_INT 1
72046: PUSH
72047: EMPTY
72048: LIST
72049: LIST
72050: PUSH
72051: LD_INT 2
72053: NEG
72054: PUSH
72055: LD_INT 1
72057: NEG
72058: PUSH
72059: EMPTY
72060: LIST
72061: LIST
72062: PUSH
72063: EMPTY
72064: LIST
72065: LIST
72066: LIST
72067: LIST
72068: LIST
72069: LIST
72070: LIST
72071: LIST
72072: LIST
72073: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72074: LD_ADDR_VAR 0 36
72078: PUSH
72079: LD_INT 0
72081: PUSH
72082: LD_INT 0
72084: PUSH
72085: EMPTY
72086: LIST
72087: LIST
72088: PUSH
72089: LD_INT 0
72091: PUSH
72092: LD_INT 1
72094: NEG
72095: PUSH
72096: EMPTY
72097: LIST
72098: LIST
72099: PUSH
72100: LD_INT 1
72102: PUSH
72103: LD_INT 0
72105: PUSH
72106: EMPTY
72107: LIST
72108: LIST
72109: PUSH
72110: LD_INT 1
72112: PUSH
72113: LD_INT 1
72115: PUSH
72116: EMPTY
72117: LIST
72118: LIST
72119: PUSH
72120: LD_INT 0
72122: PUSH
72123: LD_INT 1
72125: PUSH
72126: EMPTY
72127: LIST
72128: LIST
72129: PUSH
72130: LD_INT 1
72132: NEG
72133: PUSH
72134: LD_INT 0
72136: PUSH
72137: EMPTY
72138: LIST
72139: LIST
72140: PUSH
72141: LD_INT 1
72143: NEG
72144: PUSH
72145: LD_INT 1
72147: NEG
72148: PUSH
72149: EMPTY
72150: LIST
72151: LIST
72152: PUSH
72153: LD_INT 1
72155: NEG
72156: PUSH
72157: LD_INT 2
72159: NEG
72160: PUSH
72161: EMPTY
72162: LIST
72163: LIST
72164: PUSH
72165: LD_INT 1
72167: PUSH
72168: LD_INT 2
72170: PUSH
72171: EMPTY
72172: LIST
72173: LIST
72174: PUSH
72175: EMPTY
72176: LIST
72177: LIST
72178: LIST
72179: LIST
72180: LIST
72181: LIST
72182: LIST
72183: LIST
72184: LIST
72185: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72186: LD_ADDR_VAR 0 37
72190: PUSH
72191: LD_INT 0
72193: PUSH
72194: LD_INT 0
72196: PUSH
72197: EMPTY
72198: LIST
72199: LIST
72200: PUSH
72201: LD_INT 0
72203: PUSH
72204: LD_INT 1
72206: NEG
72207: PUSH
72208: EMPTY
72209: LIST
72210: LIST
72211: PUSH
72212: LD_INT 1
72214: PUSH
72215: LD_INT 0
72217: PUSH
72218: EMPTY
72219: LIST
72220: LIST
72221: PUSH
72222: LD_INT 1
72224: PUSH
72225: LD_INT 1
72227: PUSH
72228: EMPTY
72229: LIST
72230: LIST
72231: PUSH
72232: LD_INT 0
72234: PUSH
72235: LD_INT 1
72237: PUSH
72238: EMPTY
72239: LIST
72240: LIST
72241: PUSH
72242: LD_INT 1
72244: NEG
72245: PUSH
72246: LD_INT 0
72248: PUSH
72249: EMPTY
72250: LIST
72251: LIST
72252: PUSH
72253: LD_INT 1
72255: NEG
72256: PUSH
72257: LD_INT 1
72259: NEG
72260: PUSH
72261: EMPTY
72262: LIST
72263: LIST
72264: PUSH
72265: LD_INT 1
72267: PUSH
72268: LD_INT 1
72270: NEG
72271: PUSH
72272: EMPTY
72273: LIST
72274: LIST
72275: PUSH
72276: LD_INT 1
72278: NEG
72279: PUSH
72280: LD_INT 1
72282: PUSH
72283: EMPTY
72284: LIST
72285: LIST
72286: PUSH
72287: EMPTY
72288: LIST
72289: LIST
72290: LIST
72291: LIST
72292: LIST
72293: LIST
72294: LIST
72295: LIST
72296: LIST
72297: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
72298: LD_ADDR_VAR 0 38
72302: PUSH
72303: LD_INT 0
72305: PUSH
72306: LD_INT 0
72308: PUSH
72309: EMPTY
72310: LIST
72311: LIST
72312: PUSH
72313: LD_INT 0
72315: PUSH
72316: LD_INT 1
72318: NEG
72319: PUSH
72320: EMPTY
72321: LIST
72322: LIST
72323: PUSH
72324: LD_INT 1
72326: PUSH
72327: LD_INT 0
72329: PUSH
72330: EMPTY
72331: LIST
72332: LIST
72333: PUSH
72334: LD_INT 1
72336: PUSH
72337: LD_INT 1
72339: PUSH
72340: EMPTY
72341: LIST
72342: LIST
72343: PUSH
72344: LD_INT 0
72346: PUSH
72347: LD_INT 1
72349: PUSH
72350: EMPTY
72351: LIST
72352: LIST
72353: PUSH
72354: LD_INT 1
72356: NEG
72357: PUSH
72358: LD_INT 0
72360: PUSH
72361: EMPTY
72362: LIST
72363: LIST
72364: PUSH
72365: LD_INT 1
72367: NEG
72368: PUSH
72369: LD_INT 1
72371: NEG
72372: PUSH
72373: EMPTY
72374: LIST
72375: LIST
72376: PUSH
72377: LD_INT 2
72379: PUSH
72380: LD_INT 1
72382: PUSH
72383: EMPTY
72384: LIST
72385: LIST
72386: PUSH
72387: LD_INT 2
72389: NEG
72390: PUSH
72391: LD_INT 1
72393: NEG
72394: PUSH
72395: EMPTY
72396: LIST
72397: LIST
72398: PUSH
72399: EMPTY
72400: LIST
72401: LIST
72402: LIST
72403: LIST
72404: LIST
72405: LIST
72406: LIST
72407: LIST
72408: LIST
72409: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72410: LD_ADDR_VAR 0 39
72414: PUSH
72415: LD_INT 0
72417: PUSH
72418: LD_INT 0
72420: PUSH
72421: EMPTY
72422: LIST
72423: LIST
72424: PUSH
72425: LD_INT 0
72427: PUSH
72428: LD_INT 1
72430: NEG
72431: PUSH
72432: EMPTY
72433: LIST
72434: LIST
72435: PUSH
72436: LD_INT 1
72438: PUSH
72439: LD_INT 0
72441: PUSH
72442: EMPTY
72443: LIST
72444: LIST
72445: PUSH
72446: LD_INT 1
72448: PUSH
72449: LD_INT 1
72451: PUSH
72452: EMPTY
72453: LIST
72454: LIST
72455: PUSH
72456: LD_INT 0
72458: PUSH
72459: LD_INT 1
72461: PUSH
72462: EMPTY
72463: LIST
72464: LIST
72465: PUSH
72466: LD_INT 1
72468: NEG
72469: PUSH
72470: LD_INT 0
72472: PUSH
72473: EMPTY
72474: LIST
72475: LIST
72476: PUSH
72477: LD_INT 1
72479: NEG
72480: PUSH
72481: LD_INT 1
72483: NEG
72484: PUSH
72485: EMPTY
72486: LIST
72487: LIST
72488: PUSH
72489: LD_INT 1
72491: NEG
72492: PUSH
72493: LD_INT 2
72495: NEG
72496: PUSH
72497: EMPTY
72498: LIST
72499: LIST
72500: PUSH
72501: LD_INT 1
72503: PUSH
72504: LD_INT 2
72506: PUSH
72507: EMPTY
72508: LIST
72509: LIST
72510: PUSH
72511: EMPTY
72512: LIST
72513: LIST
72514: LIST
72515: LIST
72516: LIST
72517: LIST
72518: LIST
72519: LIST
72520: LIST
72521: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72522: LD_ADDR_VAR 0 40
72526: PUSH
72527: LD_INT 0
72529: PUSH
72530: LD_INT 0
72532: PUSH
72533: EMPTY
72534: LIST
72535: LIST
72536: PUSH
72537: LD_INT 0
72539: PUSH
72540: LD_INT 1
72542: NEG
72543: PUSH
72544: EMPTY
72545: LIST
72546: LIST
72547: PUSH
72548: LD_INT 1
72550: PUSH
72551: LD_INT 0
72553: PUSH
72554: EMPTY
72555: LIST
72556: LIST
72557: PUSH
72558: LD_INT 1
72560: PUSH
72561: LD_INT 1
72563: PUSH
72564: EMPTY
72565: LIST
72566: LIST
72567: PUSH
72568: LD_INT 0
72570: PUSH
72571: LD_INT 1
72573: PUSH
72574: EMPTY
72575: LIST
72576: LIST
72577: PUSH
72578: LD_INT 1
72580: NEG
72581: PUSH
72582: LD_INT 0
72584: PUSH
72585: EMPTY
72586: LIST
72587: LIST
72588: PUSH
72589: LD_INT 1
72591: NEG
72592: PUSH
72593: LD_INT 1
72595: NEG
72596: PUSH
72597: EMPTY
72598: LIST
72599: LIST
72600: PUSH
72601: LD_INT 1
72603: PUSH
72604: LD_INT 1
72606: NEG
72607: PUSH
72608: EMPTY
72609: LIST
72610: LIST
72611: PUSH
72612: LD_INT 1
72614: NEG
72615: PUSH
72616: LD_INT 1
72618: PUSH
72619: EMPTY
72620: LIST
72621: LIST
72622: PUSH
72623: EMPTY
72624: LIST
72625: LIST
72626: LIST
72627: LIST
72628: LIST
72629: LIST
72630: LIST
72631: LIST
72632: LIST
72633: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72634: LD_ADDR_VAR 0 41
72638: PUSH
72639: LD_INT 0
72641: PUSH
72642: LD_INT 0
72644: PUSH
72645: EMPTY
72646: LIST
72647: LIST
72648: PUSH
72649: LD_INT 0
72651: PUSH
72652: LD_INT 1
72654: NEG
72655: PUSH
72656: EMPTY
72657: LIST
72658: LIST
72659: PUSH
72660: LD_INT 1
72662: PUSH
72663: LD_INT 0
72665: PUSH
72666: EMPTY
72667: LIST
72668: LIST
72669: PUSH
72670: LD_INT 1
72672: PUSH
72673: LD_INT 1
72675: PUSH
72676: EMPTY
72677: LIST
72678: LIST
72679: PUSH
72680: LD_INT 0
72682: PUSH
72683: LD_INT 1
72685: PUSH
72686: EMPTY
72687: LIST
72688: LIST
72689: PUSH
72690: LD_INT 1
72692: NEG
72693: PUSH
72694: LD_INT 0
72696: PUSH
72697: EMPTY
72698: LIST
72699: LIST
72700: PUSH
72701: LD_INT 1
72703: NEG
72704: PUSH
72705: LD_INT 1
72707: NEG
72708: PUSH
72709: EMPTY
72710: LIST
72711: LIST
72712: PUSH
72713: LD_INT 1
72715: NEG
72716: PUSH
72717: LD_INT 2
72719: NEG
72720: PUSH
72721: EMPTY
72722: LIST
72723: LIST
72724: PUSH
72725: LD_INT 1
72727: PUSH
72728: LD_INT 1
72730: NEG
72731: PUSH
72732: EMPTY
72733: LIST
72734: LIST
72735: PUSH
72736: LD_INT 2
72738: PUSH
72739: LD_INT 0
72741: PUSH
72742: EMPTY
72743: LIST
72744: LIST
72745: PUSH
72746: LD_INT 2
72748: PUSH
72749: LD_INT 1
72751: PUSH
72752: EMPTY
72753: LIST
72754: LIST
72755: PUSH
72756: LD_INT 2
72758: PUSH
72759: LD_INT 2
72761: PUSH
72762: EMPTY
72763: LIST
72764: LIST
72765: PUSH
72766: LD_INT 1
72768: PUSH
72769: LD_INT 2
72771: PUSH
72772: EMPTY
72773: LIST
72774: LIST
72775: PUSH
72776: LD_INT 1
72778: NEG
72779: PUSH
72780: LD_INT 1
72782: PUSH
72783: EMPTY
72784: LIST
72785: LIST
72786: PUSH
72787: LD_INT 2
72789: NEG
72790: PUSH
72791: LD_INT 0
72793: PUSH
72794: EMPTY
72795: LIST
72796: LIST
72797: PUSH
72798: LD_INT 2
72800: NEG
72801: PUSH
72802: LD_INT 1
72804: NEG
72805: PUSH
72806: EMPTY
72807: LIST
72808: LIST
72809: PUSH
72810: LD_INT 2
72812: NEG
72813: PUSH
72814: LD_INT 2
72816: NEG
72817: PUSH
72818: EMPTY
72819: LIST
72820: LIST
72821: PUSH
72822: LD_INT 2
72824: NEG
72825: PUSH
72826: LD_INT 3
72828: NEG
72829: PUSH
72830: EMPTY
72831: LIST
72832: LIST
72833: PUSH
72834: LD_INT 2
72836: PUSH
72837: LD_INT 1
72839: NEG
72840: PUSH
72841: EMPTY
72842: LIST
72843: LIST
72844: PUSH
72845: LD_INT 3
72847: PUSH
72848: LD_INT 0
72850: PUSH
72851: EMPTY
72852: LIST
72853: LIST
72854: PUSH
72855: LD_INT 3
72857: PUSH
72858: LD_INT 1
72860: PUSH
72861: EMPTY
72862: LIST
72863: LIST
72864: PUSH
72865: LD_INT 3
72867: PUSH
72868: LD_INT 2
72870: PUSH
72871: EMPTY
72872: LIST
72873: LIST
72874: PUSH
72875: LD_INT 3
72877: PUSH
72878: LD_INT 3
72880: PUSH
72881: EMPTY
72882: LIST
72883: LIST
72884: PUSH
72885: LD_INT 2
72887: PUSH
72888: LD_INT 3
72890: PUSH
72891: EMPTY
72892: LIST
72893: LIST
72894: PUSH
72895: LD_INT 2
72897: NEG
72898: PUSH
72899: LD_INT 1
72901: PUSH
72902: EMPTY
72903: LIST
72904: LIST
72905: PUSH
72906: LD_INT 3
72908: NEG
72909: PUSH
72910: LD_INT 0
72912: PUSH
72913: EMPTY
72914: LIST
72915: LIST
72916: PUSH
72917: LD_INT 3
72919: NEG
72920: PUSH
72921: LD_INT 1
72923: NEG
72924: PUSH
72925: EMPTY
72926: LIST
72927: LIST
72928: PUSH
72929: LD_INT 3
72931: NEG
72932: PUSH
72933: LD_INT 2
72935: NEG
72936: PUSH
72937: EMPTY
72938: LIST
72939: LIST
72940: PUSH
72941: LD_INT 3
72943: NEG
72944: PUSH
72945: LD_INT 3
72947: NEG
72948: PUSH
72949: EMPTY
72950: LIST
72951: LIST
72952: PUSH
72953: EMPTY
72954: LIST
72955: LIST
72956: LIST
72957: LIST
72958: LIST
72959: LIST
72960: LIST
72961: LIST
72962: LIST
72963: LIST
72964: LIST
72965: LIST
72966: LIST
72967: LIST
72968: LIST
72969: LIST
72970: LIST
72971: LIST
72972: LIST
72973: LIST
72974: LIST
72975: LIST
72976: LIST
72977: LIST
72978: LIST
72979: LIST
72980: LIST
72981: LIST
72982: LIST
72983: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72984: LD_ADDR_VAR 0 42
72988: PUSH
72989: LD_INT 0
72991: PUSH
72992: LD_INT 0
72994: PUSH
72995: EMPTY
72996: LIST
72997: LIST
72998: PUSH
72999: LD_INT 0
73001: PUSH
73002: LD_INT 1
73004: NEG
73005: PUSH
73006: EMPTY
73007: LIST
73008: LIST
73009: PUSH
73010: LD_INT 1
73012: PUSH
73013: LD_INT 0
73015: PUSH
73016: EMPTY
73017: LIST
73018: LIST
73019: PUSH
73020: LD_INT 1
73022: PUSH
73023: LD_INT 1
73025: PUSH
73026: EMPTY
73027: LIST
73028: LIST
73029: PUSH
73030: LD_INT 0
73032: PUSH
73033: LD_INT 1
73035: PUSH
73036: EMPTY
73037: LIST
73038: LIST
73039: PUSH
73040: LD_INT 1
73042: NEG
73043: PUSH
73044: LD_INT 0
73046: PUSH
73047: EMPTY
73048: LIST
73049: LIST
73050: PUSH
73051: LD_INT 1
73053: NEG
73054: PUSH
73055: LD_INT 1
73057: NEG
73058: PUSH
73059: EMPTY
73060: LIST
73061: LIST
73062: PUSH
73063: LD_INT 1
73065: NEG
73066: PUSH
73067: LD_INT 2
73069: NEG
73070: PUSH
73071: EMPTY
73072: LIST
73073: LIST
73074: PUSH
73075: LD_INT 0
73077: PUSH
73078: LD_INT 2
73080: NEG
73081: PUSH
73082: EMPTY
73083: LIST
73084: LIST
73085: PUSH
73086: LD_INT 1
73088: PUSH
73089: LD_INT 1
73091: NEG
73092: PUSH
73093: EMPTY
73094: LIST
73095: LIST
73096: PUSH
73097: LD_INT 2
73099: PUSH
73100: LD_INT 1
73102: PUSH
73103: EMPTY
73104: LIST
73105: LIST
73106: PUSH
73107: LD_INT 2
73109: PUSH
73110: LD_INT 2
73112: PUSH
73113: EMPTY
73114: LIST
73115: LIST
73116: PUSH
73117: LD_INT 1
73119: PUSH
73120: LD_INT 2
73122: PUSH
73123: EMPTY
73124: LIST
73125: LIST
73126: PUSH
73127: LD_INT 0
73129: PUSH
73130: LD_INT 2
73132: PUSH
73133: EMPTY
73134: LIST
73135: LIST
73136: PUSH
73137: LD_INT 1
73139: NEG
73140: PUSH
73141: LD_INT 1
73143: PUSH
73144: EMPTY
73145: LIST
73146: LIST
73147: PUSH
73148: LD_INT 2
73150: NEG
73151: PUSH
73152: LD_INT 1
73154: NEG
73155: PUSH
73156: EMPTY
73157: LIST
73158: LIST
73159: PUSH
73160: LD_INT 2
73162: NEG
73163: PUSH
73164: LD_INT 2
73166: NEG
73167: PUSH
73168: EMPTY
73169: LIST
73170: LIST
73171: PUSH
73172: LD_INT 2
73174: NEG
73175: PUSH
73176: LD_INT 3
73178: NEG
73179: PUSH
73180: EMPTY
73181: LIST
73182: LIST
73183: PUSH
73184: LD_INT 1
73186: NEG
73187: PUSH
73188: LD_INT 3
73190: NEG
73191: PUSH
73192: EMPTY
73193: LIST
73194: LIST
73195: PUSH
73196: LD_INT 0
73198: PUSH
73199: LD_INT 3
73201: NEG
73202: PUSH
73203: EMPTY
73204: LIST
73205: LIST
73206: PUSH
73207: LD_INT 1
73209: PUSH
73210: LD_INT 2
73212: NEG
73213: PUSH
73214: EMPTY
73215: LIST
73216: LIST
73217: PUSH
73218: LD_INT 3
73220: PUSH
73221: LD_INT 2
73223: PUSH
73224: EMPTY
73225: LIST
73226: LIST
73227: PUSH
73228: LD_INT 3
73230: PUSH
73231: LD_INT 3
73233: PUSH
73234: EMPTY
73235: LIST
73236: LIST
73237: PUSH
73238: LD_INT 2
73240: PUSH
73241: LD_INT 3
73243: PUSH
73244: EMPTY
73245: LIST
73246: LIST
73247: PUSH
73248: LD_INT 1
73250: PUSH
73251: LD_INT 3
73253: PUSH
73254: EMPTY
73255: LIST
73256: LIST
73257: PUSH
73258: LD_INT 0
73260: PUSH
73261: LD_INT 3
73263: PUSH
73264: EMPTY
73265: LIST
73266: LIST
73267: PUSH
73268: LD_INT 1
73270: NEG
73271: PUSH
73272: LD_INT 2
73274: PUSH
73275: EMPTY
73276: LIST
73277: LIST
73278: PUSH
73279: LD_INT 3
73281: NEG
73282: PUSH
73283: LD_INT 2
73285: NEG
73286: PUSH
73287: EMPTY
73288: LIST
73289: LIST
73290: PUSH
73291: LD_INT 3
73293: NEG
73294: PUSH
73295: LD_INT 3
73297: NEG
73298: PUSH
73299: EMPTY
73300: LIST
73301: LIST
73302: PUSH
73303: EMPTY
73304: LIST
73305: LIST
73306: LIST
73307: LIST
73308: LIST
73309: LIST
73310: LIST
73311: LIST
73312: LIST
73313: LIST
73314: LIST
73315: LIST
73316: LIST
73317: LIST
73318: LIST
73319: LIST
73320: LIST
73321: LIST
73322: LIST
73323: LIST
73324: LIST
73325: LIST
73326: LIST
73327: LIST
73328: LIST
73329: LIST
73330: LIST
73331: LIST
73332: LIST
73333: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73334: LD_ADDR_VAR 0 43
73338: PUSH
73339: LD_INT 0
73341: PUSH
73342: LD_INT 0
73344: PUSH
73345: EMPTY
73346: LIST
73347: LIST
73348: PUSH
73349: LD_INT 0
73351: PUSH
73352: LD_INT 1
73354: NEG
73355: PUSH
73356: EMPTY
73357: LIST
73358: LIST
73359: PUSH
73360: LD_INT 1
73362: PUSH
73363: LD_INT 0
73365: PUSH
73366: EMPTY
73367: LIST
73368: LIST
73369: PUSH
73370: LD_INT 1
73372: PUSH
73373: LD_INT 1
73375: PUSH
73376: EMPTY
73377: LIST
73378: LIST
73379: PUSH
73380: LD_INT 0
73382: PUSH
73383: LD_INT 1
73385: PUSH
73386: EMPTY
73387: LIST
73388: LIST
73389: PUSH
73390: LD_INT 1
73392: NEG
73393: PUSH
73394: LD_INT 0
73396: PUSH
73397: EMPTY
73398: LIST
73399: LIST
73400: PUSH
73401: LD_INT 1
73403: NEG
73404: PUSH
73405: LD_INT 1
73407: NEG
73408: PUSH
73409: EMPTY
73410: LIST
73411: LIST
73412: PUSH
73413: LD_INT 1
73415: NEG
73416: PUSH
73417: LD_INT 2
73419: NEG
73420: PUSH
73421: EMPTY
73422: LIST
73423: LIST
73424: PUSH
73425: LD_INT 0
73427: PUSH
73428: LD_INT 2
73430: NEG
73431: PUSH
73432: EMPTY
73433: LIST
73434: LIST
73435: PUSH
73436: LD_INT 1
73438: PUSH
73439: LD_INT 1
73441: NEG
73442: PUSH
73443: EMPTY
73444: LIST
73445: LIST
73446: PUSH
73447: LD_INT 2
73449: PUSH
73450: LD_INT 0
73452: PUSH
73453: EMPTY
73454: LIST
73455: LIST
73456: PUSH
73457: LD_INT 2
73459: PUSH
73460: LD_INT 1
73462: PUSH
73463: EMPTY
73464: LIST
73465: LIST
73466: PUSH
73467: LD_INT 1
73469: PUSH
73470: LD_INT 2
73472: PUSH
73473: EMPTY
73474: LIST
73475: LIST
73476: PUSH
73477: LD_INT 0
73479: PUSH
73480: LD_INT 2
73482: PUSH
73483: EMPTY
73484: LIST
73485: LIST
73486: PUSH
73487: LD_INT 1
73489: NEG
73490: PUSH
73491: LD_INT 1
73493: PUSH
73494: EMPTY
73495: LIST
73496: LIST
73497: PUSH
73498: LD_INT 2
73500: NEG
73501: PUSH
73502: LD_INT 0
73504: PUSH
73505: EMPTY
73506: LIST
73507: LIST
73508: PUSH
73509: LD_INT 2
73511: NEG
73512: PUSH
73513: LD_INT 1
73515: NEG
73516: PUSH
73517: EMPTY
73518: LIST
73519: LIST
73520: PUSH
73521: LD_INT 1
73523: NEG
73524: PUSH
73525: LD_INT 3
73527: NEG
73528: PUSH
73529: EMPTY
73530: LIST
73531: LIST
73532: PUSH
73533: LD_INT 0
73535: PUSH
73536: LD_INT 3
73538: NEG
73539: PUSH
73540: EMPTY
73541: LIST
73542: LIST
73543: PUSH
73544: LD_INT 1
73546: PUSH
73547: LD_INT 2
73549: NEG
73550: PUSH
73551: EMPTY
73552: LIST
73553: LIST
73554: PUSH
73555: LD_INT 2
73557: PUSH
73558: LD_INT 1
73560: NEG
73561: PUSH
73562: EMPTY
73563: LIST
73564: LIST
73565: PUSH
73566: LD_INT 3
73568: PUSH
73569: LD_INT 0
73571: PUSH
73572: EMPTY
73573: LIST
73574: LIST
73575: PUSH
73576: LD_INT 3
73578: PUSH
73579: LD_INT 1
73581: PUSH
73582: EMPTY
73583: LIST
73584: LIST
73585: PUSH
73586: LD_INT 1
73588: PUSH
73589: LD_INT 3
73591: PUSH
73592: EMPTY
73593: LIST
73594: LIST
73595: PUSH
73596: LD_INT 0
73598: PUSH
73599: LD_INT 3
73601: PUSH
73602: EMPTY
73603: LIST
73604: LIST
73605: PUSH
73606: LD_INT 1
73608: NEG
73609: PUSH
73610: LD_INT 2
73612: PUSH
73613: EMPTY
73614: LIST
73615: LIST
73616: PUSH
73617: LD_INT 2
73619: NEG
73620: PUSH
73621: LD_INT 1
73623: PUSH
73624: EMPTY
73625: LIST
73626: LIST
73627: PUSH
73628: LD_INT 3
73630: NEG
73631: PUSH
73632: LD_INT 0
73634: PUSH
73635: EMPTY
73636: LIST
73637: LIST
73638: PUSH
73639: LD_INT 3
73641: NEG
73642: PUSH
73643: LD_INT 1
73645: NEG
73646: PUSH
73647: EMPTY
73648: LIST
73649: LIST
73650: PUSH
73651: EMPTY
73652: LIST
73653: LIST
73654: LIST
73655: LIST
73656: LIST
73657: LIST
73658: LIST
73659: LIST
73660: LIST
73661: LIST
73662: LIST
73663: LIST
73664: LIST
73665: LIST
73666: LIST
73667: LIST
73668: LIST
73669: LIST
73670: LIST
73671: LIST
73672: LIST
73673: LIST
73674: LIST
73675: LIST
73676: LIST
73677: LIST
73678: LIST
73679: LIST
73680: LIST
73681: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73682: LD_ADDR_VAR 0 44
73686: PUSH
73687: LD_INT 0
73689: PUSH
73690: LD_INT 0
73692: PUSH
73693: EMPTY
73694: LIST
73695: LIST
73696: PUSH
73697: LD_INT 0
73699: PUSH
73700: LD_INT 1
73702: NEG
73703: PUSH
73704: EMPTY
73705: LIST
73706: LIST
73707: PUSH
73708: LD_INT 1
73710: PUSH
73711: LD_INT 0
73713: PUSH
73714: EMPTY
73715: LIST
73716: LIST
73717: PUSH
73718: LD_INT 1
73720: PUSH
73721: LD_INT 1
73723: PUSH
73724: EMPTY
73725: LIST
73726: LIST
73727: PUSH
73728: LD_INT 0
73730: PUSH
73731: LD_INT 1
73733: PUSH
73734: EMPTY
73735: LIST
73736: LIST
73737: PUSH
73738: LD_INT 1
73740: NEG
73741: PUSH
73742: LD_INT 0
73744: PUSH
73745: EMPTY
73746: LIST
73747: LIST
73748: PUSH
73749: LD_INT 1
73751: NEG
73752: PUSH
73753: LD_INT 1
73755: NEG
73756: PUSH
73757: EMPTY
73758: LIST
73759: LIST
73760: PUSH
73761: LD_INT 1
73763: NEG
73764: PUSH
73765: LD_INT 2
73767: NEG
73768: PUSH
73769: EMPTY
73770: LIST
73771: LIST
73772: PUSH
73773: LD_INT 1
73775: PUSH
73776: LD_INT 1
73778: NEG
73779: PUSH
73780: EMPTY
73781: LIST
73782: LIST
73783: PUSH
73784: LD_INT 2
73786: PUSH
73787: LD_INT 0
73789: PUSH
73790: EMPTY
73791: LIST
73792: LIST
73793: PUSH
73794: LD_INT 2
73796: PUSH
73797: LD_INT 1
73799: PUSH
73800: EMPTY
73801: LIST
73802: LIST
73803: PUSH
73804: LD_INT 2
73806: PUSH
73807: LD_INT 2
73809: PUSH
73810: EMPTY
73811: LIST
73812: LIST
73813: PUSH
73814: LD_INT 1
73816: PUSH
73817: LD_INT 2
73819: PUSH
73820: EMPTY
73821: LIST
73822: LIST
73823: PUSH
73824: LD_INT 1
73826: NEG
73827: PUSH
73828: LD_INT 1
73830: PUSH
73831: EMPTY
73832: LIST
73833: LIST
73834: PUSH
73835: LD_INT 2
73837: NEG
73838: PUSH
73839: LD_INT 0
73841: PUSH
73842: EMPTY
73843: LIST
73844: LIST
73845: PUSH
73846: LD_INT 2
73848: NEG
73849: PUSH
73850: LD_INT 1
73852: NEG
73853: PUSH
73854: EMPTY
73855: LIST
73856: LIST
73857: PUSH
73858: LD_INT 2
73860: NEG
73861: PUSH
73862: LD_INT 2
73864: NEG
73865: PUSH
73866: EMPTY
73867: LIST
73868: LIST
73869: PUSH
73870: LD_INT 2
73872: NEG
73873: PUSH
73874: LD_INT 3
73876: NEG
73877: PUSH
73878: EMPTY
73879: LIST
73880: LIST
73881: PUSH
73882: LD_INT 2
73884: PUSH
73885: LD_INT 1
73887: NEG
73888: PUSH
73889: EMPTY
73890: LIST
73891: LIST
73892: PUSH
73893: LD_INT 3
73895: PUSH
73896: LD_INT 0
73898: PUSH
73899: EMPTY
73900: LIST
73901: LIST
73902: PUSH
73903: LD_INT 3
73905: PUSH
73906: LD_INT 1
73908: PUSH
73909: EMPTY
73910: LIST
73911: LIST
73912: PUSH
73913: LD_INT 3
73915: PUSH
73916: LD_INT 2
73918: PUSH
73919: EMPTY
73920: LIST
73921: LIST
73922: PUSH
73923: LD_INT 3
73925: PUSH
73926: LD_INT 3
73928: PUSH
73929: EMPTY
73930: LIST
73931: LIST
73932: PUSH
73933: LD_INT 2
73935: PUSH
73936: LD_INT 3
73938: PUSH
73939: EMPTY
73940: LIST
73941: LIST
73942: PUSH
73943: LD_INT 2
73945: NEG
73946: PUSH
73947: LD_INT 1
73949: PUSH
73950: EMPTY
73951: LIST
73952: LIST
73953: PUSH
73954: LD_INT 3
73956: NEG
73957: PUSH
73958: LD_INT 0
73960: PUSH
73961: EMPTY
73962: LIST
73963: LIST
73964: PUSH
73965: LD_INT 3
73967: NEG
73968: PUSH
73969: LD_INT 1
73971: NEG
73972: PUSH
73973: EMPTY
73974: LIST
73975: LIST
73976: PUSH
73977: LD_INT 3
73979: NEG
73980: PUSH
73981: LD_INT 2
73983: NEG
73984: PUSH
73985: EMPTY
73986: LIST
73987: LIST
73988: PUSH
73989: LD_INT 3
73991: NEG
73992: PUSH
73993: LD_INT 3
73995: NEG
73996: PUSH
73997: EMPTY
73998: LIST
73999: LIST
74000: PUSH
74001: EMPTY
74002: LIST
74003: LIST
74004: LIST
74005: LIST
74006: LIST
74007: LIST
74008: LIST
74009: LIST
74010: LIST
74011: LIST
74012: LIST
74013: LIST
74014: LIST
74015: LIST
74016: LIST
74017: LIST
74018: LIST
74019: LIST
74020: LIST
74021: LIST
74022: LIST
74023: LIST
74024: LIST
74025: LIST
74026: LIST
74027: LIST
74028: LIST
74029: LIST
74030: LIST
74031: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74032: LD_ADDR_VAR 0 45
74036: PUSH
74037: LD_INT 0
74039: PUSH
74040: LD_INT 0
74042: PUSH
74043: EMPTY
74044: LIST
74045: LIST
74046: PUSH
74047: LD_INT 0
74049: PUSH
74050: LD_INT 1
74052: NEG
74053: PUSH
74054: EMPTY
74055: LIST
74056: LIST
74057: PUSH
74058: LD_INT 1
74060: PUSH
74061: LD_INT 0
74063: PUSH
74064: EMPTY
74065: LIST
74066: LIST
74067: PUSH
74068: LD_INT 1
74070: PUSH
74071: LD_INT 1
74073: PUSH
74074: EMPTY
74075: LIST
74076: LIST
74077: PUSH
74078: LD_INT 0
74080: PUSH
74081: LD_INT 1
74083: PUSH
74084: EMPTY
74085: LIST
74086: LIST
74087: PUSH
74088: LD_INT 1
74090: NEG
74091: PUSH
74092: LD_INT 0
74094: PUSH
74095: EMPTY
74096: LIST
74097: LIST
74098: PUSH
74099: LD_INT 1
74101: NEG
74102: PUSH
74103: LD_INT 1
74105: NEG
74106: PUSH
74107: EMPTY
74108: LIST
74109: LIST
74110: PUSH
74111: LD_INT 1
74113: NEG
74114: PUSH
74115: LD_INT 2
74117: NEG
74118: PUSH
74119: EMPTY
74120: LIST
74121: LIST
74122: PUSH
74123: LD_INT 0
74125: PUSH
74126: LD_INT 2
74128: NEG
74129: PUSH
74130: EMPTY
74131: LIST
74132: LIST
74133: PUSH
74134: LD_INT 1
74136: PUSH
74137: LD_INT 1
74139: NEG
74140: PUSH
74141: EMPTY
74142: LIST
74143: LIST
74144: PUSH
74145: LD_INT 2
74147: PUSH
74148: LD_INT 1
74150: PUSH
74151: EMPTY
74152: LIST
74153: LIST
74154: PUSH
74155: LD_INT 2
74157: PUSH
74158: LD_INT 2
74160: PUSH
74161: EMPTY
74162: LIST
74163: LIST
74164: PUSH
74165: LD_INT 1
74167: PUSH
74168: LD_INT 2
74170: PUSH
74171: EMPTY
74172: LIST
74173: LIST
74174: PUSH
74175: LD_INT 0
74177: PUSH
74178: LD_INT 2
74180: PUSH
74181: EMPTY
74182: LIST
74183: LIST
74184: PUSH
74185: LD_INT 1
74187: NEG
74188: PUSH
74189: LD_INT 1
74191: PUSH
74192: EMPTY
74193: LIST
74194: LIST
74195: PUSH
74196: LD_INT 2
74198: NEG
74199: PUSH
74200: LD_INT 1
74202: NEG
74203: PUSH
74204: EMPTY
74205: LIST
74206: LIST
74207: PUSH
74208: LD_INT 2
74210: NEG
74211: PUSH
74212: LD_INT 2
74214: NEG
74215: PUSH
74216: EMPTY
74217: LIST
74218: LIST
74219: PUSH
74220: LD_INT 2
74222: NEG
74223: PUSH
74224: LD_INT 3
74226: NEG
74227: PUSH
74228: EMPTY
74229: LIST
74230: LIST
74231: PUSH
74232: LD_INT 1
74234: NEG
74235: PUSH
74236: LD_INT 3
74238: NEG
74239: PUSH
74240: EMPTY
74241: LIST
74242: LIST
74243: PUSH
74244: LD_INT 0
74246: PUSH
74247: LD_INT 3
74249: NEG
74250: PUSH
74251: EMPTY
74252: LIST
74253: LIST
74254: PUSH
74255: LD_INT 1
74257: PUSH
74258: LD_INT 2
74260: NEG
74261: PUSH
74262: EMPTY
74263: LIST
74264: LIST
74265: PUSH
74266: LD_INT 3
74268: PUSH
74269: LD_INT 2
74271: PUSH
74272: EMPTY
74273: LIST
74274: LIST
74275: PUSH
74276: LD_INT 3
74278: PUSH
74279: LD_INT 3
74281: PUSH
74282: EMPTY
74283: LIST
74284: LIST
74285: PUSH
74286: LD_INT 2
74288: PUSH
74289: LD_INT 3
74291: PUSH
74292: EMPTY
74293: LIST
74294: LIST
74295: PUSH
74296: LD_INT 1
74298: PUSH
74299: LD_INT 3
74301: PUSH
74302: EMPTY
74303: LIST
74304: LIST
74305: PUSH
74306: LD_INT 0
74308: PUSH
74309: LD_INT 3
74311: PUSH
74312: EMPTY
74313: LIST
74314: LIST
74315: PUSH
74316: LD_INT 1
74318: NEG
74319: PUSH
74320: LD_INT 2
74322: PUSH
74323: EMPTY
74324: LIST
74325: LIST
74326: PUSH
74327: LD_INT 3
74329: NEG
74330: PUSH
74331: LD_INT 2
74333: NEG
74334: PUSH
74335: EMPTY
74336: LIST
74337: LIST
74338: PUSH
74339: LD_INT 3
74341: NEG
74342: PUSH
74343: LD_INT 3
74345: NEG
74346: PUSH
74347: EMPTY
74348: LIST
74349: LIST
74350: PUSH
74351: EMPTY
74352: LIST
74353: LIST
74354: LIST
74355: LIST
74356: LIST
74357: LIST
74358: LIST
74359: LIST
74360: LIST
74361: LIST
74362: LIST
74363: LIST
74364: LIST
74365: LIST
74366: LIST
74367: LIST
74368: LIST
74369: LIST
74370: LIST
74371: LIST
74372: LIST
74373: LIST
74374: LIST
74375: LIST
74376: LIST
74377: LIST
74378: LIST
74379: LIST
74380: LIST
74381: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74382: LD_ADDR_VAR 0 46
74386: PUSH
74387: LD_INT 0
74389: PUSH
74390: LD_INT 0
74392: PUSH
74393: EMPTY
74394: LIST
74395: LIST
74396: PUSH
74397: LD_INT 0
74399: PUSH
74400: LD_INT 1
74402: NEG
74403: PUSH
74404: EMPTY
74405: LIST
74406: LIST
74407: PUSH
74408: LD_INT 1
74410: PUSH
74411: LD_INT 0
74413: PUSH
74414: EMPTY
74415: LIST
74416: LIST
74417: PUSH
74418: LD_INT 1
74420: PUSH
74421: LD_INT 1
74423: PUSH
74424: EMPTY
74425: LIST
74426: LIST
74427: PUSH
74428: LD_INT 0
74430: PUSH
74431: LD_INT 1
74433: PUSH
74434: EMPTY
74435: LIST
74436: LIST
74437: PUSH
74438: LD_INT 1
74440: NEG
74441: PUSH
74442: LD_INT 0
74444: PUSH
74445: EMPTY
74446: LIST
74447: LIST
74448: PUSH
74449: LD_INT 1
74451: NEG
74452: PUSH
74453: LD_INT 1
74455: NEG
74456: PUSH
74457: EMPTY
74458: LIST
74459: LIST
74460: PUSH
74461: LD_INT 1
74463: NEG
74464: PUSH
74465: LD_INT 2
74467: NEG
74468: PUSH
74469: EMPTY
74470: LIST
74471: LIST
74472: PUSH
74473: LD_INT 0
74475: PUSH
74476: LD_INT 2
74478: NEG
74479: PUSH
74480: EMPTY
74481: LIST
74482: LIST
74483: PUSH
74484: LD_INT 1
74486: PUSH
74487: LD_INT 1
74489: NEG
74490: PUSH
74491: EMPTY
74492: LIST
74493: LIST
74494: PUSH
74495: LD_INT 2
74497: PUSH
74498: LD_INT 0
74500: PUSH
74501: EMPTY
74502: LIST
74503: LIST
74504: PUSH
74505: LD_INT 2
74507: PUSH
74508: LD_INT 1
74510: PUSH
74511: EMPTY
74512: LIST
74513: LIST
74514: PUSH
74515: LD_INT 1
74517: PUSH
74518: LD_INT 2
74520: PUSH
74521: EMPTY
74522: LIST
74523: LIST
74524: PUSH
74525: LD_INT 0
74527: PUSH
74528: LD_INT 2
74530: PUSH
74531: EMPTY
74532: LIST
74533: LIST
74534: PUSH
74535: LD_INT 1
74537: NEG
74538: PUSH
74539: LD_INT 1
74541: PUSH
74542: EMPTY
74543: LIST
74544: LIST
74545: PUSH
74546: LD_INT 2
74548: NEG
74549: PUSH
74550: LD_INT 0
74552: PUSH
74553: EMPTY
74554: LIST
74555: LIST
74556: PUSH
74557: LD_INT 2
74559: NEG
74560: PUSH
74561: LD_INT 1
74563: NEG
74564: PUSH
74565: EMPTY
74566: LIST
74567: LIST
74568: PUSH
74569: LD_INT 1
74571: NEG
74572: PUSH
74573: LD_INT 3
74575: NEG
74576: PUSH
74577: EMPTY
74578: LIST
74579: LIST
74580: PUSH
74581: LD_INT 0
74583: PUSH
74584: LD_INT 3
74586: NEG
74587: PUSH
74588: EMPTY
74589: LIST
74590: LIST
74591: PUSH
74592: LD_INT 1
74594: PUSH
74595: LD_INT 2
74597: NEG
74598: PUSH
74599: EMPTY
74600: LIST
74601: LIST
74602: PUSH
74603: LD_INT 2
74605: PUSH
74606: LD_INT 1
74608: NEG
74609: PUSH
74610: EMPTY
74611: LIST
74612: LIST
74613: PUSH
74614: LD_INT 3
74616: PUSH
74617: LD_INT 0
74619: PUSH
74620: EMPTY
74621: LIST
74622: LIST
74623: PUSH
74624: LD_INT 3
74626: PUSH
74627: LD_INT 1
74629: PUSH
74630: EMPTY
74631: LIST
74632: LIST
74633: PUSH
74634: LD_INT 1
74636: PUSH
74637: LD_INT 3
74639: PUSH
74640: EMPTY
74641: LIST
74642: LIST
74643: PUSH
74644: LD_INT 0
74646: PUSH
74647: LD_INT 3
74649: PUSH
74650: EMPTY
74651: LIST
74652: LIST
74653: PUSH
74654: LD_INT 1
74656: NEG
74657: PUSH
74658: LD_INT 2
74660: PUSH
74661: EMPTY
74662: LIST
74663: LIST
74664: PUSH
74665: LD_INT 2
74667: NEG
74668: PUSH
74669: LD_INT 1
74671: PUSH
74672: EMPTY
74673: LIST
74674: LIST
74675: PUSH
74676: LD_INT 3
74678: NEG
74679: PUSH
74680: LD_INT 0
74682: PUSH
74683: EMPTY
74684: LIST
74685: LIST
74686: PUSH
74687: LD_INT 3
74689: NEG
74690: PUSH
74691: LD_INT 1
74693: NEG
74694: PUSH
74695: EMPTY
74696: LIST
74697: LIST
74698: PUSH
74699: EMPTY
74700: LIST
74701: LIST
74702: LIST
74703: LIST
74704: LIST
74705: LIST
74706: LIST
74707: LIST
74708: LIST
74709: LIST
74710: LIST
74711: LIST
74712: LIST
74713: LIST
74714: LIST
74715: LIST
74716: LIST
74717: LIST
74718: LIST
74719: LIST
74720: LIST
74721: LIST
74722: LIST
74723: LIST
74724: LIST
74725: LIST
74726: LIST
74727: LIST
74728: LIST
74729: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74730: LD_ADDR_VAR 0 47
74734: PUSH
74735: LD_INT 0
74737: PUSH
74738: LD_INT 0
74740: PUSH
74741: EMPTY
74742: LIST
74743: LIST
74744: PUSH
74745: LD_INT 0
74747: PUSH
74748: LD_INT 1
74750: NEG
74751: PUSH
74752: EMPTY
74753: LIST
74754: LIST
74755: PUSH
74756: LD_INT 1
74758: PUSH
74759: LD_INT 0
74761: PUSH
74762: EMPTY
74763: LIST
74764: LIST
74765: PUSH
74766: LD_INT 1
74768: PUSH
74769: LD_INT 1
74771: PUSH
74772: EMPTY
74773: LIST
74774: LIST
74775: PUSH
74776: LD_INT 0
74778: PUSH
74779: LD_INT 1
74781: PUSH
74782: EMPTY
74783: LIST
74784: LIST
74785: PUSH
74786: LD_INT 1
74788: NEG
74789: PUSH
74790: LD_INT 0
74792: PUSH
74793: EMPTY
74794: LIST
74795: LIST
74796: PUSH
74797: LD_INT 1
74799: NEG
74800: PUSH
74801: LD_INT 1
74803: NEG
74804: PUSH
74805: EMPTY
74806: LIST
74807: LIST
74808: PUSH
74809: LD_INT 1
74811: NEG
74812: PUSH
74813: LD_INT 2
74815: NEG
74816: PUSH
74817: EMPTY
74818: LIST
74819: LIST
74820: PUSH
74821: LD_INT 0
74823: PUSH
74824: LD_INT 2
74826: NEG
74827: PUSH
74828: EMPTY
74829: LIST
74830: LIST
74831: PUSH
74832: LD_INT 1
74834: PUSH
74835: LD_INT 1
74837: NEG
74838: PUSH
74839: EMPTY
74840: LIST
74841: LIST
74842: PUSH
74843: LD_INT 2
74845: NEG
74846: PUSH
74847: LD_INT 1
74849: NEG
74850: PUSH
74851: EMPTY
74852: LIST
74853: LIST
74854: PUSH
74855: LD_INT 2
74857: NEG
74858: PUSH
74859: LD_INT 2
74861: NEG
74862: PUSH
74863: EMPTY
74864: LIST
74865: LIST
74866: PUSH
74867: EMPTY
74868: LIST
74869: LIST
74870: LIST
74871: LIST
74872: LIST
74873: LIST
74874: LIST
74875: LIST
74876: LIST
74877: LIST
74878: LIST
74879: LIST
74880: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
74881: LD_ADDR_VAR 0 48
74885: PUSH
74886: LD_INT 0
74888: PUSH
74889: LD_INT 0
74891: PUSH
74892: EMPTY
74893: LIST
74894: LIST
74895: PUSH
74896: LD_INT 0
74898: PUSH
74899: LD_INT 1
74901: NEG
74902: PUSH
74903: EMPTY
74904: LIST
74905: LIST
74906: PUSH
74907: LD_INT 1
74909: PUSH
74910: LD_INT 0
74912: PUSH
74913: EMPTY
74914: LIST
74915: LIST
74916: PUSH
74917: LD_INT 1
74919: PUSH
74920: LD_INT 1
74922: PUSH
74923: EMPTY
74924: LIST
74925: LIST
74926: PUSH
74927: LD_INT 0
74929: PUSH
74930: LD_INT 1
74932: PUSH
74933: EMPTY
74934: LIST
74935: LIST
74936: PUSH
74937: LD_INT 1
74939: NEG
74940: PUSH
74941: LD_INT 0
74943: PUSH
74944: EMPTY
74945: LIST
74946: LIST
74947: PUSH
74948: LD_INT 1
74950: NEG
74951: PUSH
74952: LD_INT 1
74954: NEG
74955: PUSH
74956: EMPTY
74957: LIST
74958: LIST
74959: PUSH
74960: LD_INT 1
74962: NEG
74963: PUSH
74964: LD_INT 2
74966: NEG
74967: PUSH
74968: EMPTY
74969: LIST
74970: LIST
74971: PUSH
74972: LD_INT 0
74974: PUSH
74975: LD_INT 2
74977: NEG
74978: PUSH
74979: EMPTY
74980: LIST
74981: LIST
74982: PUSH
74983: LD_INT 1
74985: PUSH
74986: LD_INT 1
74988: NEG
74989: PUSH
74990: EMPTY
74991: LIST
74992: LIST
74993: PUSH
74994: LD_INT 2
74996: PUSH
74997: LD_INT 0
74999: PUSH
75000: EMPTY
75001: LIST
75002: LIST
75003: PUSH
75004: LD_INT 2
75006: PUSH
75007: LD_INT 1
75009: PUSH
75010: EMPTY
75011: LIST
75012: LIST
75013: PUSH
75014: EMPTY
75015: LIST
75016: LIST
75017: LIST
75018: LIST
75019: LIST
75020: LIST
75021: LIST
75022: LIST
75023: LIST
75024: LIST
75025: LIST
75026: LIST
75027: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
75028: LD_ADDR_VAR 0 49
75032: PUSH
75033: LD_INT 0
75035: PUSH
75036: LD_INT 0
75038: PUSH
75039: EMPTY
75040: LIST
75041: LIST
75042: PUSH
75043: LD_INT 0
75045: PUSH
75046: LD_INT 1
75048: NEG
75049: PUSH
75050: EMPTY
75051: LIST
75052: LIST
75053: PUSH
75054: LD_INT 1
75056: PUSH
75057: LD_INT 0
75059: PUSH
75060: EMPTY
75061: LIST
75062: LIST
75063: PUSH
75064: LD_INT 1
75066: PUSH
75067: LD_INT 1
75069: PUSH
75070: EMPTY
75071: LIST
75072: LIST
75073: PUSH
75074: LD_INT 0
75076: PUSH
75077: LD_INT 1
75079: PUSH
75080: EMPTY
75081: LIST
75082: LIST
75083: PUSH
75084: LD_INT 1
75086: NEG
75087: PUSH
75088: LD_INT 0
75090: PUSH
75091: EMPTY
75092: LIST
75093: LIST
75094: PUSH
75095: LD_INT 1
75097: NEG
75098: PUSH
75099: LD_INT 1
75101: NEG
75102: PUSH
75103: EMPTY
75104: LIST
75105: LIST
75106: PUSH
75107: LD_INT 1
75109: PUSH
75110: LD_INT 1
75112: NEG
75113: PUSH
75114: EMPTY
75115: LIST
75116: LIST
75117: PUSH
75118: LD_INT 2
75120: PUSH
75121: LD_INT 0
75123: PUSH
75124: EMPTY
75125: LIST
75126: LIST
75127: PUSH
75128: LD_INT 2
75130: PUSH
75131: LD_INT 1
75133: PUSH
75134: EMPTY
75135: LIST
75136: LIST
75137: PUSH
75138: LD_INT 2
75140: PUSH
75141: LD_INT 2
75143: PUSH
75144: EMPTY
75145: LIST
75146: LIST
75147: PUSH
75148: LD_INT 1
75150: PUSH
75151: LD_INT 2
75153: PUSH
75154: EMPTY
75155: LIST
75156: LIST
75157: PUSH
75158: EMPTY
75159: LIST
75160: LIST
75161: LIST
75162: LIST
75163: LIST
75164: LIST
75165: LIST
75166: LIST
75167: LIST
75168: LIST
75169: LIST
75170: LIST
75171: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
75172: LD_ADDR_VAR 0 50
75176: PUSH
75177: LD_INT 0
75179: PUSH
75180: LD_INT 0
75182: PUSH
75183: EMPTY
75184: LIST
75185: LIST
75186: PUSH
75187: LD_INT 0
75189: PUSH
75190: LD_INT 1
75192: NEG
75193: PUSH
75194: EMPTY
75195: LIST
75196: LIST
75197: PUSH
75198: LD_INT 1
75200: PUSH
75201: LD_INT 0
75203: PUSH
75204: EMPTY
75205: LIST
75206: LIST
75207: PUSH
75208: LD_INT 1
75210: PUSH
75211: LD_INT 1
75213: PUSH
75214: EMPTY
75215: LIST
75216: LIST
75217: PUSH
75218: LD_INT 0
75220: PUSH
75221: LD_INT 1
75223: PUSH
75224: EMPTY
75225: LIST
75226: LIST
75227: PUSH
75228: LD_INT 1
75230: NEG
75231: PUSH
75232: LD_INT 0
75234: PUSH
75235: EMPTY
75236: LIST
75237: LIST
75238: PUSH
75239: LD_INT 1
75241: NEG
75242: PUSH
75243: LD_INT 1
75245: NEG
75246: PUSH
75247: EMPTY
75248: LIST
75249: LIST
75250: PUSH
75251: LD_INT 2
75253: PUSH
75254: LD_INT 1
75256: PUSH
75257: EMPTY
75258: LIST
75259: LIST
75260: PUSH
75261: LD_INT 2
75263: PUSH
75264: LD_INT 2
75266: PUSH
75267: EMPTY
75268: LIST
75269: LIST
75270: PUSH
75271: LD_INT 1
75273: PUSH
75274: LD_INT 2
75276: PUSH
75277: EMPTY
75278: LIST
75279: LIST
75280: PUSH
75281: LD_INT 0
75283: PUSH
75284: LD_INT 2
75286: PUSH
75287: EMPTY
75288: LIST
75289: LIST
75290: PUSH
75291: LD_INT 1
75293: NEG
75294: PUSH
75295: LD_INT 1
75297: PUSH
75298: EMPTY
75299: LIST
75300: LIST
75301: PUSH
75302: EMPTY
75303: LIST
75304: LIST
75305: LIST
75306: LIST
75307: LIST
75308: LIST
75309: LIST
75310: LIST
75311: LIST
75312: LIST
75313: LIST
75314: LIST
75315: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
75316: LD_ADDR_VAR 0 51
75320: PUSH
75321: LD_INT 0
75323: PUSH
75324: LD_INT 0
75326: PUSH
75327: EMPTY
75328: LIST
75329: LIST
75330: PUSH
75331: LD_INT 0
75333: PUSH
75334: LD_INT 1
75336: NEG
75337: PUSH
75338: EMPTY
75339: LIST
75340: LIST
75341: PUSH
75342: LD_INT 1
75344: PUSH
75345: LD_INT 0
75347: PUSH
75348: EMPTY
75349: LIST
75350: LIST
75351: PUSH
75352: LD_INT 1
75354: PUSH
75355: LD_INT 1
75357: PUSH
75358: EMPTY
75359: LIST
75360: LIST
75361: PUSH
75362: LD_INT 0
75364: PUSH
75365: LD_INT 1
75367: PUSH
75368: EMPTY
75369: LIST
75370: LIST
75371: PUSH
75372: LD_INT 1
75374: NEG
75375: PUSH
75376: LD_INT 0
75378: PUSH
75379: EMPTY
75380: LIST
75381: LIST
75382: PUSH
75383: LD_INT 1
75385: NEG
75386: PUSH
75387: LD_INT 1
75389: NEG
75390: PUSH
75391: EMPTY
75392: LIST
75393: LIST
75394: PUSH
75395: LD_INT 1
75397: PUSH
75398: LD_INT 2
75400: PUSH
75401: EMPTY
75402: LIST
75403: LIST
75404: PUSH
75405: LD_INT 0
75407: PUSH
75408: LD_INT 2
75410: PUSH
75411: EMPTY
75412: LIST
75413: LIST
75414: PUSH
75415: LD_INT 1
75417: NEG
75418: PUSH
75419: LD_INT 1
75421: PUSH
75422: EMPTY
75423: LIST
75424: LIST
75425: PUSH
75426: LD_INT 2
75428: NEG
75429: PUSH
75430: LD_INT 0
75432: PUSH
75433: EMPTY
75434: LIST
75435: LIST
75436: PUSH
75437: LD_INT 2
75439: NEG
75440: PUSH
75441: LD_INT 1
75443: NEG
75444: PUSH
75445: EMPTY
75446: LIST
75447: LIST
75448: PUSH
75449: EMPTY
75450: LIST
75451: LIST
75452: LIST
75453: LIST
75454: LIST
75455: LIST
75456: LIST
75457: LIST
75458: LIST
75459: LIST
75460: LIST
75461: LIST
75462: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75463: LD_ADDR_VAR 0 52
75467: PUSH
75468: LD_INT 0
75470: PUSH
75471: LD_INT 0
75473: PUSH
75474: EMPTY
75475: LIST
75476: LIST
75477: PUSH
75478: LD_INT 0
75480: PUSH
75481: LD_INT 1
75483: NEG
75484: PUSH
75485: EMPTY
75486: LIST
75487: LIST
75488: PUSH
75489: LD_INT 1
75491: PUSH
75492: LD_INT 0
75494: PUSH
75495: EMPTY
75496: LIST
75497: LIST
75498: PUSH
75499: LD_INT 1
75501: PUSH
75502: LD_INT 1
75504: PUSH
75505: EMPTY
75506: LIST
75507: LIST
75508: PUSH
75509: LD_INT 0
75511: PUSH
75512: LD_INT 1
75514: PUSH
75515: EMPTY
75516: LIST
75517: LIST
75518: PUSH
75519: LD_INT 1
75521: NEG
75522: PUSH
75523: LD_INT 0
75525: PUSH
75526: EMPTY
75527: LIST
75528: LIST
75529: PUSH
75530: LD_INT 1
75532: NEG
75533: PUSH
75534: LD_INT 1
75536: NEG
75537: PUSH
75538: EMPTY
75539: LIST
75540: LIST
75541: PUSH
75542: LD_INT 1
75544: NEG
75545: PUSH
75546: LD_INT 2
75548: NEG
75549: PUSH
75550: EMPTY
75551: LIST
75552: LIST
75553: PUSH
75554: LD_INT 1
75556: NEG
75557: PUSH
75558: LD_INT 1
75560: PUSH
75561: EMPTY
75562: LIST
75563: LIST
75564: PUSH
75565: LD_INT 2
75567: NEG
75568: PUSH
75569: LD_INT 0
75571: PUSH
75572: EMPTY
75573: LIST
75574: LIST
75575: PUSH
75576: LD_INT 2
75578: NEG
75579: PUSH
75580: LD_INT 1
75582: NEG
75583: PUSH
75584: EMPTY
75585: LIST
75586: LIST
75587: PUSH
75588: LD_INT 2
75590: NEG
75591: PUSH
75592: LD_INT 2
75594: NEG
75595: PUSH
75596: EMPTY
75597: LIST
75598: LIST
75599: PUSH
75600: EMPTY
75601: LIST
75602: LIST
75603: LIST
75604: LIST
75605: LIST
75606: LIST
75607: LIST
75608: LIST
75609: LIST
75610: LIST
75611: LIST
75612: LIST
75613: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75614: LD_ADDR_VAR 0 53
75618: PUSH
75619: LD_INT 0
75621: PUSH
75622: LD_INT 0
75624: PUSH
75625: EMPTY
75626: LIST
75627: LIST
75628: PUSH
75629: LD_INT 0
75631: PUSH
75632: LD_INT 1
75634: NEG
75635: PUSH
75636: EMPTY
75637: LIST
75638: LIST
75639: PUSH
75640: LD_INT 1
75642: PUSH
75643: LD_INT 0
75645: PUSH
75646: EMPTY
75647: LIST
75648: LIST
75649: PUSH
75650: LD_INT 1
75652: PUSH
75653: LD_INT 1
75655: PUSH
75656: EMPTY
75657: LIST
75658: LIST
75659: PUSH
75660: LD_INT 0
75662: PUSH
75663: LD_INT 1
75665: PUSH
75666: EMPTY
75667: LIST
75668: LIST
75669: PUSH
75670: LD_INT 1
75672: NEG
75673: PUSH
75674: LD_INT 0
75676: PUSH
75677: EMPTY
75678: LIST
75679: LIST
75680: PUSH
75681: LD_INT 1
75683: NEG
75684: PUSH
75685: LD_INT 1
75687: NEG
75688: PUSH
75689: EMPTY
75690: LIST
75691: LIST
75692: PUSH
75693: LD_INT 1
75695: NEG
75696: PUSH
75697: LD_INT 2
75699: NEG
75700: PUSH
75701: EMPTY
75702: LIST
75703: LIST
75704: PUSH
75705: LD_INT 0
75707: PUSH
75708: LD_INT 2
75710: NEG
75711: PUSH
75712: EMPTY
75713: LIST
75714: LIST
75715: PUSH
75716: LD_INT 1
75718: PUSH
75719: LD_INT 1
75721: NEG
75722: PUSH
75723: EMPTY
75724: LIST
75725: LIST
75726: PUSH
75727: LD_INT 2
75729: PUSH
75730: LD_INT 0
75732: PUSH
75733: EMPTY
75734: LIST
75735: LIST
75736: PUSH
75737: LD_INT 2
75739: PUSH
75740: LD_INT 1
75742: PUSH
75743: EMPTY
75744: LIST
75745: LIST
75746: PUSH
75747: LD_INT 2
75749: PUSH
75750: LD_INT 2
75752: PUSH
75753: EMPTY
75754: LIST
75755: LIST
75756: PUSH
75757: LD_INT 1
75759: PUSH
75760: LD_INT 2
75762: PUSH
75763: EMPTY
75764: LIST
75765: LIST
75766: PUSH
75767: LD_INT 0
75769: PUSH
75770: LD_INT 2
75772: PUSH
75773: EMPTY
75774: LIST
75775: LIST
75776: PUSH
75777: LD_INT 1
75779: NEG
75780: PUSH
75781: LD_INT 1
75783: PUSH
75784: EMPTY
75785: LIST
75786: LIST
75787: PUSH
75788: LD_INT 2
75790: NEG
75791: PUSH
75792: LD_INT 0
75794: PUSH
75795: EMPTY
75796: LIST
75797: LIST
75798: PUSH
75799: LD_INT 2
75801: NEG
75802: PUSH
75803: LD_INT 1
75805: NEG
75806: PUSH
75807: EMPTY
75808: LIST
75809: LIST
75810: PUSH
75811: LD_INT 2
75813: NEG
75814: PUSH
75815: LD_INT 2
75817: NEG
75818: PUSH
75819: EMPTY
75820: LIST
75821: LIST
75822: PUSH
75823: EMPTY
75824: LIST
75825: LIST
75826: LIST
75827: LIST
75828: LIST
75829: LIST
75830: LIST
75831: LIST
75832: LIST
75833: LIST
75834: LIST
75835: LIST
75836: LIST
75837: LIST
75838: LIST
75839: LIST
75840: LIST
75841: LIST
75842: LIST
75843: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75844: LD_ADDR_VAR 0 54
75848: PUSH
75849: LD_INT 0
75851: PUSH
75852: LD_INT 0
75854: PUSH
75855: EMPTY
75856: LIST
75857: LIST
75858: PUSH
75859: LD_INT 0
75861: PUSH
75862: LD_INT 1
75864: NEG
75865: PUSH
75866: EMPTY
75867: LIST
75868: LIST
75869: PUSH
75870: LD_INT 1
75872: PUSH
75873: LD_INT 0
75875: PUSH
75876: EMPTY
75877: LIST
75878: LIST
75879: PUSH
75880: LD_INT 1
75882: PUSH
75883: LD_INT 1
75885: PUSH
75886: EMPTY
75887: LIST
75888: LIST
75889: PUSH
75890: LD_INT 0
75892: PUSH
75893: LD_INT 1
75895: PUSH
75896: EMPTY
75897: LIST
75898: LIST
75899: PUSH
75900: LD_INT 1
75902: NEG
75903: PUSH
75904: LD_INT 0
75906: PUSH
75907: EMPTY
75908: LIST
75909: LIST
75910: PUSH
75911: LD_INT 1
75913: NEG
75914: PUSH
75915: LD_INT 1
75917: NEG
75918: PUSH
75919: EMPTY
75920: LIST
75921: LIST
75922: PUSH
75923: LD_INT 1
75925: NEG
75926: PUSH
75927: LD_INT 2
75929: NEG
75930: PUSH
75931: EMPTY
75932: LIST
75933: LIST
75934: PUSH
75935: LD_INT 0
75937: PUSH
75938: LD_INT 2
75940: NEG
75941: PUSH
75942: EMPTY
75943: LIST
75944: LIST
75945: PUSH
75946: LD_INT 1
75948: PUSH
75949: LD_INT 1
75951: NEG
75952: PUSH
75953: EMPTY
75954: LIST
75955: LIST
75956: PUSH
75957: LD_INT 2
75959: PUSH
75960: LD_INT 0
75962: PUSH
75963: EMPTY
75964: LIST
75965: LIST
75966: PUSH
75967: LD_INT 2
75969: PUSH
75970: LD_INT 1
75972: PUSH
75973: EMPTY
75974: LIST
75975: LIST
75976: PUSH
75977: LD_INT 2
75979: PUSH
75980: LD_INT 2
75982: PUSH
75983: EMPTY
75984: LIST
75985: LIST
75986: PUSH
75987: LD_INT 1
75989: PUSH
75990: LD_INT 2
75992: PUSH
75993: EMPTY
75994: LIST
75995: LIST
75996: PUSH
75997: LD_INT 0
75999: PUSH
76000: LD_INT 2
76002: PUSH
76003: EMPTY
76004: LIST
76005: LIST
76006: PUSH
76007: LD_INT 1
76009: NEG
76010: PUSH
76011: LD_INT 1
76013: PUSH
76014: EMPTY
76015: LIST
76016: LIST
76017: PUSH
76018: LD_INT 2
76020: NEG
76021: PUSH
76022: LD_INT 0
76024: PUSH
76025: EMPTY
76026: LIST
76027: LIST
76028: PUSH
76029: LD_INT 2
76031: NEG
76032: PUSH
76033: LD_INT 1
76035: NEG
76036: PUSH
76037: EMPTY
76038: LIST
76039: LIST
76040: PUSH
76041: LD_INT 2
76043: NEG
76044: PUSH
76045: LD_INT 2
76047: NEG
76048: PUSH
76049: EMPTY
76050: LIST
76051: LIST
76052: PUSH
76053: EMPTY
76054: LIST
76055: LIST
76056: LIST
76057: LIST
76058: LIST
76059: LIST
76060: LIST
76061: LIST
76062: LIST
76063: LIST
76064: LIST
76065: LIST
76066: LIST
76067: LIST
76068: LIST
76069: LIST
76070: LIST
76071: LIST
76072: LIST
76073: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76074: LD_ADDR_VAR 0 55
76078: PUSH
76079: LD_INT 0
76081: PUSH
76082: LD_INT 0
76084: PUSH
76085: EMPTY
76086: LIST
76087: LIST
76088: PUSH
76089: LD_INT 0
76091: PUSH
76092: LD_INT 1
76094: NEG
76095: PUSH
76096: EMPTY
76097: LIST
76098: LIST
76099: PUSH
76100: LD_INT 1
76102: PUSH
76103: LD_INT 0
76105: PUSH
76106: EMPTY
76107: LIST
76108: LIST
76109: PUSH
76110: LD_INT 1
76112: PUSH
76113: LD_INT 1
76115: PUSH
76116: EMPTY
76117: LIST
76118: LIST
76119: PUSH
76120: LD_INT 0
76122: PUSH
76123: LD_INT 1
76125: PUSH
76126: EMPTY
76127: LIST
76128: LIST
76129: PUSH
76130: LD_INT 1
76132: NEG
76133: PUSH
76134: LD_INT 0
76136: PUSH
76137: EMPTY
76138: LIST
76139: LIST
76140: PUSH
76141: LD_INT 1
76143: NEG
76144: PUSH
76145: LD_INT 1
76147: NEG
76148: PUSH
76149: EMPTY
76150: LIST
76151: LIST
76152: PUSH
76153: LD_INT 1
76155: NEG
76156: PUSH
76157: LD_INT 2
76159: NEG
76160: PUSH
76161: EMPTY
76162: LIST
76163: LIST
76164: PUSH
76165: LD_INT 0
76167: PUSH
76168: LD_INT 2
76170: NEG
76171: PUSH
76172: EMPTY
76173: LIST
76174: LIST
76175: PUSH
76176: LD_INT 1
76178: PUSH
76179: LD_INT 1
76181: NEG
76182: PUSH
76183: EMPTY
76184: LIST
76185: LIST
76186: PUSH
76187: LD_INT 2
76189: PUSH
76190: LD_INT 0
76192: PUSH
76193: EMPTY
76194: LIST
76195: LIST
76196: PUSH
76197: LD_INT 2
76199: PUSH
76200: LD_INT 1
76202: PUSH
76203: EMPTY
76204: LIST
76205: LIST
76206: PUSH
76207: LD_INT 2
76209: PUSH
76210: LD_INT 2
76212: PUSH
76213: EMPTY
76214: LIST
76215: LIST
76216: PUSH
76217: LD_INT 1
76219: PUSH
76220: LD_INT 2
76222: PUSH
76223: EMPTY
76224: LIST
76225: LIST
76226: PUSH
76227: LD_INT 0
76229: PUSH
76230: LD_INT 2
76232: PUSH
76233: EMPTY
76234: LIST
76235: LIST
76236: PUSH
76237: LD_INT 1
76239: NEG
76240: PUSH
76241: LD_INT 1
76243: PUSH
76244: EMPTY
76245: LIST
76246: LIST
76247: PUSH
76248: LD_INT 2
76250: NEG
76251: PUSH
76252: LD_INT 0
76254: PUSH
76255: EMPTY
76256: LIST
76257: LIST
76258: PUSH
76259: LD_INT 2
76261: NEG
76262: PUSH
76263: LD_INT 1
76265: NEG
76266: PUSH
76267: EMPTY
76268: LIST
76269: LIST
76270: PUSH
76271: LD_INT 2
76273: NEG
76274: PUSH
76275: LD_INT 2
76277: NEG
76278: PUSH
76279: EMPTY
76280: LIST
76281: LIST
76282: PUSH
76283: EMPTY
76284: LIST
76285: LIST
76286: LIST
76287: LIST
76288: LIST
76289: LIST
76290: LIST
76291: LIST
76292: LIST
76293: LIST
76294: LIST
76295: LIST
76296: LIST
76297: LIST
76298: LIST
76299: LIST
76300: LIST
76301: LIST
76302: LIST
76303: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76304: LD_ADDR_VAR 0 56
76308: PUSH
76309: LD_INT 0
76311: PUSH
76312: LD_INT 0
76314: PUSH
76315: EMPTY
76316: LIST
76317: LIST
76318: PUSH
76319: LD_INT 0
76321: PUSH
76322: LD_INT 1
76324: NEG
76325: PUSH
76326: EMPTY
76327: LIST
76328: LIST
76329: PUSH
76330: LD_INT 1
76332: PUSH
76333: LD_INT 0
76335: PUSH
76336: EMPTY
76337: LIST
76338: LIST
76339: PUSH
76340: LD_INT 1
76342: PUSH
76343: LD_INT 1
76345: PUSH
76346: EMPTY
76347: LIST
76348: LIST
76349: PUSH
76350: LD_INT 0
76352: PUSH
76353: LD_INT 1
76355: PUSH
76356: EMPTY
76357: LIST
76358: LIST
76359: PUSH
76360: LD_INT 1
76362: NEG
76363: PUSH
76364: LD_INT 0
76366: PUSH
76367: EMPTY
76368: LIST
76369: LIST
76370: PUSH
76371: LD_INT 1
76373: NEG
76374: PUSH
76375: LD_INT 1
76377: NEG
76378: PUSH
76379: EMPTY
76380: LIST
76381: LIST
76382: PUSH
76383: LD_INT 1
76385: NEG
76386: PUSH
76387: LD_INT 2
76389: NEG
76390: PUSH
76391: EMPTY
76392: LIST
76393: LIST
76394: PUSH
76395: LD_INT 0
76397: PUSH
76398: LD_INT 2
76400: NEG
76401: PUSH
76402: EMPTY
76403: LIST
76404: LIST
76405: PUSH
76406: LD_INT 1
76408: PUSH
76409: LD_INT 1
76411: NEG
76412: PUSH
76413: EMPTY
76414: LIST
76415: LIST
76416: PUSH
76417: LD_INT 2
76419: PUSH
76420: LD_INT 0
76422: PUSH
76423: EMPTY
76424: LIST
76425: LIST
76426: PUSH
76427: LD_INT 2
76429: PUSH
76430: LD_INT 1
76432: PUSH
76433: EMPTY
76434: LIST
76435: LIST
76436: PUSH
76437: LD_INT 2
76439: PUSH
76440: LD_INT 2
76442: PUSH
76443: EMPTY
76444: LIST
76445: LIST
76446: PUSH
76447: LD_INT 1
76449: PUSH
76450: LD_INT 2
76452: PUSH
76453: EMPTY
76454: LIST
76455: LIST
76456: PUSH
76457: LD_INT 0
76459: PUSH
76460: LD_INT 2
76462: PUSH
76463: EMPTY
76464: LIST
76465: LIST
76466: PUSH
76467: LD_INT 1
76469: NEG
76470: PUSH
76471: LD_INT 1
76473: PUSH
76474: EMPTY
76475: LIST
76476: LIST
76477: PUSH
76478: LD_INT 2
76480: NEG
76481: PUSH
76482: LD_INT 0
76484: PUSH
76485: EMPTY
76486: LIST
76487: LIST
76488: PUSH
76489: LD_INT 2
76491: NEG
76492: PUSH
76493: LD_INT 1
76495: NEG
76496: PUSH
76497: EMPTY
76498: LIST
76499: LIST
76500: PUSH
76501: LD_INT 2
76503: NEG
76504: PUSH
76505: LD_INT 2
76507: NEG
76508: PUSH
76509: EMPTY
76510: LIST
76511: LIST
76512: PUSH
76513: EMPTY
76514: LIST
76515: LIST
76516: LIST
76517: LIST
76518: LIST
76519: LIST
76520: LIST
76521: LIST
76522: LIST
76523: LIST
76524: LIST
76525: LIST
76526: LIST
76527: LIST
76528: LIST
76529: LIST
76530: LIST
76531: LIST
76532: LIST
76533: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76534: LD_ADDR_VAR 0 57
76538: PUSH
76539: LD_INT 0
76541: PUSH
76542: LD_INT 0
76544: PUSH
76545: EMPTY
76546: LIST
76547: LIST
76548: PUSH
76549: LD_INT 0
76551: PUSH
76552: LD_INT 1
76554: NEG
76555: PUSH
76556: EMPTY
76557: LIST
76558: LIST
76559: PUSH
76560: LD_INT 1
76562: PUSH
76563: LD_INT 0
76565: PUSH
76566: EMPTY
76567: LIST
76568: LIST
76569: PUSH
76570: LD_INT 1
76572: PUSH
76573: LD_INT 1
76575: PUSH
76576: EMPTY
76577: LIST
76578: LIST
76579: PUSH
76580: LD_INT 0
76582: PUSH
76583: LD_INT 1
76585: PUSH
76586: EMPTY
76587: LIST
76588: LIST
76589: PUSH
76590: LD_INT 1
76592: NEG
76593: PUSH
76594: LD_INT 0
76596: PUSH
76597: EMPTY
76598: LIST
76599: LIST
76600: PUSH
76601: LD_INT 1
76603: NEG
76604: PUSH
76605: LD_INT 1
76607: NEG
76608: PUSH
76609: EMPTY
76610: LIST
76611: LIST
76612: PUSH
76613: LD_INT 1
76615: NEG
76616: PUSH
76617: LD_INT 2
76619: NEG
76620: PUSH
76621: EMPTY
76622: LIST
76623: LIST
76624: PUSH
76625: LD_INT 0
76627: PUSH
76628: LD_INT 2
76630: NEG
76631: PUSH
76632: EMPTY
76633: LIST
76634: LIST
76635: PUSH
76636: LD_INT 1
76638: PUSH
76639: LD_INT 1
76641: NEG
76642: PUSH
76643: EMPTY
76644: LIST
76645: LIST
76646: PUSH
76647: LD_INT 2
76649: PUSH
76650: LD_INT 0
76652: PUSH
76653: EMPTY
76654: LIST
76655: LIST
76656: PUSH
76657: LD_INT 2
76659: PUSH
76660: LD_INT 1
76662: PUSH
76663: EMPTY
76664: LIST
76665: LIST
76666: PUSH
76667: LD_INT 2
76669: PUSH
76670: LD_INT 2
76672: PUSH
76673: EMPTY
76674: LIST
76675: LIST
76676: PUSH
76677: LD_INT 1
76679: PUSH
76680: LD_INT 2
76682: PUSH
76683: EMPTY
76684: LIST
76685: LIST
76686: PUSH
76687: LD_INT 0
76689: PUSH
76690: LD_INT 2
76692: PUSH
76693: EMPTY
76694: LIST
76695: LIST
76696: PUSH
76697: LD_INT 1
76699: NEG
76700: PUSH
76701: LD_INT 1
76703: PUSH
76704: EMPTY
76705: LIST
76706: LIST
76707: PUSH
76708: LD_INT 2
76710: NEG
76711: PUSH
76712: LD_INT 0
76714: PUSH
76715: EMPTY
76716: LIST
76717: LIST
76718: PUSH
76719: LD_INT 2
76721: NEG
76722: PUSH
76723: LD_INT 1
76725: NEG
76726: PUSH
76727: EMPTY
76728: LIST
76729: LIST
76730: PUSH
76731: LD_INT 2
76733: NEG
76734: PUSH
76735: LD_INT 2
76737: NEG
76738: PUSH
76739: EMPTY
76740: LIST
76741: LIST
76742: PUSH
76743: EMPTY
76744: LIST
76745: LIST
76746: LIST
76747: LIST
76748: LIST
76749: LIST
76750: LIST
76751: LIST
76752: LIST
76753: LIST
76754: LIST
76755: LIST
76756: LIST
76757: LIST
76758: LIST
76759: LIST
76760: LIST
76761: LIST
76762: LIST
76763: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76764: LD_ADDR_VAR 0 58
76768: PUSH
76769: LD_INT 0
76771: PUSH
76772: LD_INT 0
76774: PUSH
76775: EMPTY
76776: LIST
76777: LIST
76778: PUSH
76779: LD_INT 0
76781: PUSH
76782: LD_INT 1
76784: NEG
76785: PUSH
76786: EMPTY
76787: LIST
76788: LIST
76789: PUSH
76790: LD_INT 1
76792: PUSH
76793: LD_INT 0
76795: PUSH
76796: EMPTY
76797: LIST
76798: LIST
76799: PUSH
76800: LD_INT 1
76802: PUSH
76803: LD_INT 1
76805: PUSH
76806: EMPTY
76807: LIST
76808: LIST
76809: PUSH
76810: LD_INT 0
76812: PUSH
76813: LD_INT 1
76815: PUSH
76816: EMPTY
76817: LIST
76818: LIST
76819: PUSH
76820: LD_INT 1
76822: NEG
76823: PUSH
76824: LD_INT 0
76826: PUSH
76827: EMPTY
76828: LIST
76829: LIST
76830: PUSH
76831: LD_INT 1
76833: NEG
76834: PUSH
76835: LD_INT 1
76837: NEG
76838: PUSH
76839: EMPTY
76840: LIST
76841: LIST
76842: PUSH
76843: LD_INT 1
76845: NEG
76846: PUSH
76847: LD_INT 2
76849: NEG
76850: PUSH
76851: EMPTY
76852: LIST
76853: LIST
76854: PUSH
76855: LD_INT 0
76857: PUSH
76858: LD_INT 2
76860: NEG
76861: PUSH
76862: EMPTY
76863: LIST
76864: LIST
76865: PUSH
76866: LD_INT 1
76868: PUSH
76869: LD_INT 1
76871: NEG
76872: PUSH
76873: EMPTY
76874: LIST
76875: LIST
76876: PUSH
76877: LD_INT 2
76879: PUSH
76880: LD_INT 0
76882: PUSH
76883: EMPTY
76884: LIST
76885: LIST
76886: PUSH
76887: LD_INT 2
76889: PUSH
76890: LD_INT 1
76892: PUSH
76893: EMPTY
76894: LIST
76895: LIST
76896: PUSH
76897: LD_INT 2
76899: PUSH
76900: LD_INT 2
76902: PUSH
76903: EMPTY
76904: LIST
76905: LIST
76906: PUSH
76907: LD_INT 1
76909: PUSH
76910: LD_INT 2
76912: PUSH
76913: EMPTY
76914: LIST
76915: LIST
76916: PUSH
76917: LD_INT 0
76919: PUSH
76920: LD_INT 2
76922: PUSH
76923: EMPTY
76924: LIST
76925: LIST
76926: PUSH
76927: LD_INT 1
76929: NEG
76930: PUSH
76931: LD_INT 1
76933: PUSH
76934: EMPTY
76935: LIST
76936: LIST
76937: PUSH
76938: LD_INT 2
76940: NEG
76941: PUSH
76942: LD_INT 0
76944: PUSH
76945: EMPTY
76946: LIST
76947: LIST
76948: PUSH
76949: LD_INT 2
76951: NEG
76952: PUSH
76953: LD_INT 1
76955: NEG
76956: PUSH
76957: EMPTY
76958: LIST
76959: LIST
76960: PUSH
76961: LD_INT 2
76963: NEG
76964: PUSH
76965: LD_INT 2
76967: NEG
76968: PUSH
76969: EMPTY
76970: LIST
76971: LIST
76972: PUSH
76973: EMPTY
76974: LIST
76975: LIST
76976: LIST
76977: LIST
76978: LIST
76979: LIST
76980: LIST
76981: LIST
76982: LIST
76983: LIST
76984: LIST
76985: LIST
76986: LIST
76987: LIST
76988: LIST
76989: LIST
76990: LIST
76991: LIST
76992: LIST
76993: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76994: LD_ADDR_VAR 0 59
76998: PUSH
76999: LD_INT 0
77001: PUSH
77002: LD_INT 0
77004: PUSH
77005: EMPTY
77006: LIST
77007: LIST
77008: PUSH
77009: LD_INT 0
77011: PUSH
77012: LD_INT 1
77014: NEG
77015: PUSH
77016: EMPTY
77017: LIST
77018: LIST
77019: PUSH
77020: LD_INT 1
77022: PUSH
77023: LD_INT 0
77025: PUSH
77026: EMPTY
77027: LIST
77028: LIST
77029: PUSH
77030: LD_INT 1
77032: PUSH
77033: LD_INT 1
77035: PUSH
77036: EMPTY
77037: LIST
77038: LIST
77039: PUSH
77040: LD_INT 0
77042: PUSH
77043: LD_INT 1
77045: PUSH
77046: EMPTY
77047: LIST
77048: LIST
77049: PUSH
77050: LD_INT 1
77052: NEG
77053: PUSH
77054: LD_INT 0
77056: PUSH
77057: EMPTY
77058: LIST
77059: LIST
77060: PUSH
77061: LD_INT 1
77063: NEG
77064: PUSH
77065: LD_INT 1
77067: NEG
77068: PUSH
77069: EMPTY
77070: LIST
77071: LIST
77072: PUSH
77073: EMPTY
77074: LIST
77075: LIST
77076: LIST
77077: LIST
77078: LIST
77079: LIST
77080: LIST
77081: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77082: LD_ADDR_VAR 0 60
77086: PUSH
77087: LD_INT 0
77089: PUSH
77090: LD_INT 0
77092: PUSH
77093: EMPTY
77094: LIST
77095: LIST
77096: PUSH
77097: LD_INT 0
77099: PUSH
77100: LD_INT 1
77102: NEG
77103: PUSH
77104: EMPTY
77105: LIST
77106: LIST
77107: PUSH
77108: LD_INT 1
77110: PUSH
77111: LD_INT 0
77113: PUSH
77114: EMPTY
77115: LIST
77116: LIST
77117: PUSH
77118: LD_INT 1
77120: PUSH
77121: LD_INT 1
77123: PUSH
77124: EMPTY
77125: LIST
77126: LIST
77127: PUSH
77128: LD_INT 0
77130: PUSH
77131: LD_INT 1
77133: PUSH
77134: EMPTY
77135: LIST
77136: LIST
77137: PUSH
77138: LD_INT 1
77140: NEG
77141: PUSH
77142: LD_INT 0
77144: PUSH
77145: EMPTY
77146: LIST
77147: LIST
77148: PUSH
77149: LD_INT 1
77151: NEG
77152: PUSH
77153: LD_INT 1
77155: NEG
77156: PUSH
77157: EMPTY
77158: LIST
77159: LIST
77160: PUSH
77161: EMPTY
77162: LIST
77163: LIST
77164: LIST
77165: LIST
77166: LIST
77167: LIST
77168: LIST
77169: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77170: LD_ADDR_VAR 0 61
77174: PUSH
77175: LD_INT 0
77177: PUSH
77178: LD_INT 0
77180: PUSH
77181: EMPTY
77182: LIST
77183: LIST
77184: PUSH
77185: LD_INT 0
77187: PUSH
77188: LD_INT 1
77190: NEG
77191: PUSH
77192: EMPTY
77193: LIST
77194: LIST
77195: PUSH
77196: LD_INT 1
77198: PUSH
77199: LD_INT 0
77201: PUSH
77202: EMPTY
77203: LIST
77204: LIST
77205: PUSH
77206: LD_INT 1
77208: PUSH
77209: LD_INT 1
77211: PUSH
77212: EMPTY
77213: LIST
77214: LIST
77215: PUSH
77216: LD_INT 0
77218: PUSH
77219: LD_INT 1
77221: PUSH
77222: EMPTY
77223: LIST
77224: LIST
77225: PUSH
77226: LD_INT 1
77228: NEG
77229: PUSH
77230: LD_INT 0
77232: PUSH
77233: EMPTY
77234: LIST
77235: LIST
77236: PUSH
77237: LD_INT 1
77239: NEG
77240: PUSH
77241: LD_INT 1
77243: NEG
77244: PUSH
77245: EMPTY
77246: LIST
77247: LIST
77248: PUSH
77249: EMPTY
77250: LIST
77251: LIST
77252: LIST
77253: LIST
77254: LIST
77255: LIST
77256: LIST
77257: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77258: LD_ADDR_VAR 0 62
77262: PUSH
77263: LD_INT 0
77265: PUSH
77266: LD_INT 0
77268: PUSH
77269: EMPTY
77270: LIST
77271: LIST
77272: PUSH
77273: LD_INT 0
77275: PUSH
77276: LD_INT 1
77278: NEG
77279: PUSH
77280: EMPTY
77281: LIST
77282: LIST
77283: PUSH
77284: LD_INT 1
77286: PUSH
77287: LD_INT 0
77289: PUSH
77290: EMPTY
77291: LIST
77292: LIST
77293: PUSH
77294: LD_INT 1
77296: PUSH
77297: LD_INT 1
77299: PUSH
77300: EMPTY
77301: LIST
77302: LIST
77303: PUSH
77304: LD_INT 0
77306: PUSH
77307: LD_INT 1
77309: PUSH
77310: EMPTY
77311: LIST
77312: LIST
77313: PUSH
77314: LD_INT 1
77316: NEG
77317: PUSH
77318: LD_INT 0
77320: PUSH
77321: EMPTY
77322: LIST
77323: LIST
77324: PUSH
77325: LD_INT 1
77327: NEG
77328: PUSH
77329: LD_INT 1
77331: NEG
77332: PUSH
77333: EMPTY
77334: LIST
77335: LIST
77336: PUSH
77337: EMPTY
77338: LIST
77339: LIST
77340: LIST
77341: LIST
77342: LIST
77343: LIST
77344: LIST
77345: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77346: LD_ADDR_VAR 0 63
77350: PUSH
77351: LD_INT 0
77353: PUSH
77354: LD_INT 0
77356: PUSH
77357: EMPTY
77358: LIST
77359: LIST
77360: PUSH
77361: LD_INT 0
77363: PUSH
77364: LD_INT 1
77366: NEG
77367: PUSH
77368: EMPTY
77369: LIST
77370: LIST
77371: PUSH
77372: LD_INT 1
77374: PUSH
77375: LD_INT 0
77377: PUSH
77378: EMPTY
77379: LIST
77380: LIST
77381: PUSH
77382: LD_INT 1
77384: PUSH
77385: LD_INT 1
77387: PUSH
77388: EMPTY
77389: LIST
77390: LIST
77391: PUSH
77392: LD_INT 0
77394: PUSH
77395: LD_INT 1
77397: PUSH
77398: EMPTY
77399: LIST
77400: LIST
77401: PUSH
77402: LD_INT 1
77404: NEG
77405: PUSH
77406: LD_INT 0
77408: PUSH
77409: EMPTY
77410: LIST
77411: LIST
77412: PUSH
77413: LD_INT 1
77415: NEG
77416: PUSH
77417: LD_INT 1
77419: NEG
77420: PUSH
77421: EMPTY
77422: LIST
77423: LIST
77424: PUSH
77425: EMPTY
77426: LIST
77427: LIST
77428: LIST
77429: LIST
77430: LIST
77431: LIST
77432: LIST
77433: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77434: LD_ADDR_VAR 0 64
77438: PUSH
77439: LD_INT 0
77441: PUSH
77442: LD_INT 0
77444: PUSH
77445: EMPTY
77446: LIST
77447: LIST
77448: PUSH
77449: LD_INT 0
77451: PUSH
77452: LD_INT 1
77454: NEG
77455: PUSH
77456: EMPTY
77457: LIST
77458: LIST
77459: PUSH
77460: LD_INT 1
77462: PUSH
77463: LD_INT 0
77465: PUSH
77466: EMPTY
77467: LIST
77468: LIST
77469: PUSH
77470: LD_INT 1
77472: PUSH
77473: LD_INT 1
77475: PUSH
77476: EMPTY
77477: LIST
77478: LIST
77479: PUSH
77480: LD_INT 0
77482: PUSH
77483: LD_INT 1
77485: PUSH
77486: EMPTY
77487: LIST
77488: LIST
77489: PUSH
77490: LD_INT 1
77492: NEG
77493: PUSH
77494: LD_INT 0
77496: PUSH
77497: EMPTY
77498: LIST
77499: LIST
77500: PUSH
77501: LD_INT 1
77503: NEG
77504: PUSH
77505: LD_INT 1
77507: NEG
77508: PUSH
77509: EMPTY
77510: LIST
77511: LIST
77512: PUSH
77513: EMPTY
77514: LIST
77515: LIST
77516: LIST
77517: LIST
77518: LIST
77519: LIST
77520: LIST
77521: ST_TO_ADDR
// end ; 1 :
77522: GO 83419
77524: LD_INT 1
77526: DOUBLE
77527: EQUAL
77528: IFTRUE 77532
77530: GO 80155
77532: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77533: LD_ADDR_VAR 0 11
77537: PUSH
77538: LD_INT 1
77540: NEG
77541: PUSH
77542: LD_INT 3
77544: NEG
77545: PUSH
77546: EMPTY
77547: LIST
77548: LIST
77549: PUSH
77550: LD_INT 0
77552: PUSH
77553: LD_INT 3
77555: NEG
77556: PUSH
77557: EMPTY
77558: LIST
77559: LIST
77560: PUSH
77561: LD_INT 1
77563: PUSH
77564: LD_INT 2
77566: NEG
77567: PUSH
77568: EMPTY
77569: LIST
77570: LIST
77571: PUSH
77572: EMPTY
77573: LIST
77574: LIST
77575: LIST
77576: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77577: LD_ADDR_VAR 0 12
77581: PUSH
77582: LD_INT 2
77584: PUSH
77585: LD_INT 1
77587: NEG
77588: PUSH
77589: EMPTY
77590: LIST
77591: LIST
77592: PUSH
77593: LD_INT 3
77595: PUSH
77596: LD_INT 0
77598: PUSH
77599: EMPTY
77600: LIST
77601: LIST
77602: PUSH
77603: LD_INT 3
77605: PUSH
77606: LD_INT 1
77608: PUSH
77609: EMPTY
77610: LIST
77611: LIST
77612: PUSH
77613: EMPTY
77614: LIST
77615: LIST
77616: LIST
77617: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77618: LD_ADDR_VAR 0 13
77622: PUSH
77623: LD_INT 3
77625: PUSH
77626: LD_INT 2
77628: PUSH
77629: EMPTY
77630: LIST
77631: LIST
77632: PUSH
77633: LD_INT 3
77635: PUSH
77636: LD_INT 3
77638: PUSH
77639: EMPTY
77640: LIST
77641: LIST
77642: PUSH
77643: LD_INT 2
77645: PUSH
77646: LD_INT 3
77648: PUSH
77649: EMPTY
77650: LIST
77651: LIST
77652: PUSH
77653: EMPTY
77654: LIST
77655: LIST
77656: LIST
77657: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77658: LD_ADDR_VAR 0 14
77662: PUSH
77663: LD_INT 1
77665: PUSH
77666: LD_INT 3
77668: PUSH
77669: EMPTY
77670: LIST
77671: LIST
77672: PUSH
77673: LD_INT 0
77675: PUSH
77676: LD_INT 3
77678: PUSH
77679: EMPTY
77680: LIST
77681: LIST
77682: PUSH
77683: LD_INT 1
77685: NEG
77686: PUSH
77687: LD_INT 2
77689: PUSH
77690: EMPTY
77691: LIST
77692: LIST
77693: PUSH
77694: EMPTY
77695: LIST
77696: LIST
77697: LIST
77698: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77699: LD_ADDR_VAR 0 15
77703: PUSH
77704: LD_INT 2
77706: NEG
77707: PUSH
77708: LD_INT 1
77710: PUSH
77711: EMPTY
77712: LIST
77713: LIST
77714: PUSH
77715: LD_INT 3
77717: NEG
77718: PUSH
77719: LD_INT 0
77721: PUSH
77722: EMPTY
77723: LIST
77724: LIST
77725: PUSH
77726: LD_INT 3
77728: NEG
77729: PUSH
77730: LD_INT 1
77732: NEG
77733: PUSH
77734: EMPTY
77735: LIST
77736: LIST
77737: PUSH
77738: EMPTY
77739: LIST
77740: LIST
77741: LIST
77742: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77743: LD_ADDR_VAR 0 16
77747: PUSH
77748: LD_INT 2
77750: NEG
77751: PUSH
77752: LD_INT 3
77754: NEG
77755: PUSH
77756: EMPTY
77757: LIST
77758: LIST
77759: PUSH
77760: LD_INT 3
77762: NEG
77763: PUSH
77764: LD_INT 2
77766: NEG
77767: PUSH
77768: EMPTY
77769: LIST
77770: LIST
77771: PUSH
77772: LD_INT 3
77774: NEG
77775: PUSH
77776: LD_INT 3
77778: NEG
77779: PUSH
77780: EMPTY
77781: LIST
77782: LIST
77783: PUSH
77784: EMPTY
77785: LIST
77786: LIST
77787: LIST
77788: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77789: LD_ADDR_VAR 0 17
77793: PUSH
77794: LD_INT 1
77796: NEG
77797: PUSH
77798: LD_INT 3
77800: NEG
77801: PUSH
77802: EMPTY
77803: LIST
77804: LIST
77805: PUSH
77806: LD_INT 0
77808: PUSH
77809: LD_INT 3
77811: NEG
77812: PUSH
77813: EMPTY
77814: LIST
77815: LIST
77816: PUSH
77817: LD_INT 1
77819: PUSH
77820: LD_INT 2
77822: NEG
77823: PUSH
77824: EMPTY
77825: LIST
77826: LIST
77827: PUSH
77828: EMPTY
77829: LIST
77830: LIST
77831: LIST
77832: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77833: LD_ADDR_VAR 0 18
77837: PUSH
77838: LD_INT 2
77840: PUSH
77841: LD_INT 1
77843: NEG
77844: PUSH
77845: EMPTY
77846: LIST
77847: LIST
77848: PUSH
77849: LD_INT 3
77851: PUSH
77852: LD_INT 0
77854: PUSH
77855: EMPTY
77856: LIST
77857: LIST
77858: PUSH
77859: LD_INT 3
77861: PUSH
77862: LD_INT 1
77864: PUSH
77865: EMPTY
77866: LIST
77867: LIST
77868: PUSH
77869: EMPTY
77870: LIST
77871: LIST
77872: LIST
77873: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77874: LD_ADDR_VAR 0 19
77878: PUSH
77879: LD_INT 3
77881: PUSH
77882: LD_INT 2
77884: PUSH
77885: EMPTY
77886: LIST
77887: LIST
77888: PUSH
77889: LD_INT 3
77891: PUSH
77892: LD_INT 3
77894: PUSH
77895: EMPTY
77896: LIST
77897: LIST
77898: PUSH
77899: LD_INT 2
77901: PUSH
77902: LD_INT 3
77904: PUSH
77905: EMPTY
77906: LIST
77907: LIST
77908: PUSH
77909: EMPTY
77910: LIST
77911: LIST
77912: LIST
77913: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77914: LD_ADDR_VAR 0 20
77918: PUSH
77919: LD_INT 1
77921: PUSH
77922: LD_INT 3
77924: PUSH
77925: EMPTY
77926: LIST
77927: LIST
77928: PUSH
77929: LD_INT 0
77931: PUSH
77932: LD_INT 3
77934: PUSH
77935: EMPTY
77936: LIST
77937: LIST
77938: PUSH
77939: LD_INT 1
77941: NEG
77942: PUSH
77943: LD_INT 2
77945: PUSH
77946: EMPTY
77947: LIST
77948: LIST
77949: PUSH
77950: EMPTY
77951: LIST
77952: LIST
77953: LIST
77954: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77955: LD_ADDR_VAR 0 21
77959: PUSH
77960: LD_INT 2
77962: NEG
77963: PUSH
77964: LD_INT 1
77966: PUSH
77967: EMPTY
77968: LIST
77969: LIST
77970: PUSH
77971: LD_INT 3
77973: NEG
77974: PUSH
77975: LD_INT 0
77977: PUSH
77978: EMPTY
77979: LIST
77980: LIST
77981: PUSH
77982: LD_INT 3
77984: NEG
77985: PUSH
77986: LD_INT 1
77988: NEG
77989: PUSH
77990: EMPTY
77991: LIST
77992: LIST
77993: PUSH
77994: EMPTY
77995: LIST
77996: LIST
77997: LIST
77998: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77999: LD_ADDR_VAR 0 22
78003: PUSH
78004: LD_INT 2
78006: NEG
78007: PUSH
78008: LD_INT 3
78010: NEG
78011: PUSH
78012: EMPTY
78013: LIST
78014: LIST
78015: PUSH
78016: LD_INT 3
78018: NEG
78019: PUSH
78020: LD_INT 2
78022: NEG
78023: PUSH
78024: EMPTY
78025: LIST
78026: LIST
78027: PUSH
78028: LD_INT 3
78030: NEG
78031: PUSH
78032: LD_INT 3
78034: NEG
78035: PUSH
78036: EMPTY
78037: LIST
78038: LIST
78039: PUSH
78040: EMPTY
78041: LIST
78042: LIST
78043: LIST
78044: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
78045: LD_ADDR_VAR 0 23
78049: PUSH
78050: LD_INT 0
78052: PUSH
78053: LD_INT 3
78055: NEG
78056: PUSH
78057: EMPTY
78058: LIST
78059: LIST
78060: PUSH
78061: LD_INT 1
78063: NEG
78064: PUSH
78065: LD_INT 4
78067: NEG
78068: PUSH
78069: EMPTY
78070: LIST
78071: LIST
78072: PUSH
78073: LD_INT 1
78075: PUSH
78076: LD_INT 3
78078: NEG
78079: PUSH
78080: EMPTY
78081: LIST
78082: LIST
78083: PUSH
78084: EMPTY
78085: LIST
78086: LIST
78087: LIST
78088: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
78089: LD_ADDR_VAR 0 24
78093: PUSH
78094: LD_INT 3
78096: PUSH
78097: LD_INT 0
78099: PUSH
78100: EMPTY
78101: LIST
78102: LIST
78103: PUSH
78104: LD_INT 3
78106: PUSH
78107: LD_INT 1
78109: NEG
78110: PUSH
78111: EMPTY
78112: LIST
78113: LIST
78114: PUSH
78115: LD_INT 4
78117: PUSH
78118: LD_INT 1
78120: PUSH
78121: EMPTY
78122: LIST
78123: LIST
78124: PUSH
78125: EMPTY
78126: LIST
78127: LIST
78128: LIST
78129: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
78130: LD_ADDR_VAR 0 25
78134: PUSH
78135: LD_INT 3
78137: PUSH
78138: LD_INT 3
78140: PUSH
78141: EMPTY
78142: LIST
78143: LIST
78144: PUSH
78145: LD_INT 4
78147: PUSH
78148: LD_INT 3
78150: PUSH
78151: EMPTY
78152: LIST
78153: LIST
78154: PUSH
78155: LD_INT 3
78157: PUSH
78158: LD_INT 4
78160: PUSH
78161: EMPTY
78162: LIST
78163: LIST
78164: PUSH
78165: EMPTY
78166: LIST
78167: LIST
78168: LIST
78169: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
78170: LD_ADDR_VAR 0 26
78174: PUSH
78175: LD_INT 0
78177: PUSH
78178: LD_INT 3
78180: PUSH
78181: EMPTY
78182: LIST
78183: LIST
78184: PUSH
78185: LD_INT 1
78187: PUSH
78188: LD_INT 4
78190: PUSH
78191: EMPTY
78192: LIST
78193: LIST
78194: PUSH
78195: LD_INT 1
78197: NEG
78198: PUSH
78199: LD_INT 3
78201: PUSH
78202: EMPTY
78203: LIST
78204: LIST
78205: PUSH
78206: EMPTY
78207: LIST
78208: LIST
78209: LIST
78210: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
78211: LD_ADDR_VAR 0 27
78215: PUSH
78216: LD_INT 3
78218: NEG
78219: PUSH
78220: LD_INT 0
78222: PUSH
78223: EMPTY
78224: LIST
78225: LIST
78226: PUSH
78227: LD_INT 3
78229: NEG
78230: PUSH
78231: LD_INT 1
78233: PUSH
78234: EMPTY
78235: LIST
78236: LIST
78237: PUSH
78238: LD_INT 4
78240: NEG
78241: PUSH
78242: LD_INT 1
78244: NEG
78245: PUSH
78246: EMPTY
78247: LIST
78248: LIST
78249: PUSH
78250: EMPTY
78251: LIST
78252: LIST
78253: LIST
78254: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
78255: LD_ADDR_VAR 0 28
78259: PUSH
78260: LD_INT 3
78262: NEG
78263: PUSH
78264: LD_INT 3
78266: NEG
78267: PUSH
78268: EMPTY
78269: LIST
78270: LIST
78271: PUSH
78272: LD_INT 3
78274: NEG
78275: PUSH
78276: LD_INT 4
78278: NEG
78279: PUSH
78280: EMPTY
78281: LIST
78282: LIST
78283: PUSH
78284: LD_INT 4
78286: NEG
78287: PUSH
78288: LD_INT 3
78290: NEG
78291: PUSH
78292: EMPTY
78293: LIST
78294: LIST
78295: PUSH
78296: EMPTY
78297: LIST
78298: LIST
78299: LIST
78300: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
78301: LD_ADDR_VAR 0 29
78305: PUSH
78306: LD_INT 1
78308: NEG
78309: PUSH
78310: LD_INT 3
78312: NEG
78313: PUSH
78314: EMPTY
78315: LIST
78316: LIST
78317: PUSH
78318: LD_INT 0
78320: PUSH
78321: LD_INT 3
78323: NEG
78324: PUSH
78325: EMPTY
78326: LIST
78327: LIST
78328: PUSH
78329: LD_INT 1
78331: PUSH
78332: LD_INT 2
78334: NEG
78335: PUSH
78336: EMPTY
78337: LIST
78338: LIST
78339: PUSH
78340: LD_INT 1
78342: NEG
78343: PUSH
78344: LD_INT 4
78346: NEG
78347: PUSH
78348: EMPTY
78349: LIST
78350: LIST
78351: PUSH
78352: LD_INT 0
78354: PUSH
78355: LD_INT 4
78357: NEG
78358: PUSH
78359: EMPTY
78360: LIST
78361: LIST
78362: PUSH
78363: LD_INT 1
78365: PUSH
78366: LD_INT 3
78368: NEG
78369: PUSH
78370: EMPTY
78371: LIST
78372: LIST
78373: PUSH
78374: LD_INT 1
78376: NEG
78377: PUSH
78378: LD_INT 5
78380: NEG
78381: PUSH
78382: EMPTY
78383: LIST
78384: LIST
78385: PUSH
78386: LD_INT 0
78388: PUSH
78389: LD_INT 5
78391: NEG
78392: PUSH
78393: EMPTY
78394: LIST
78395: LIST
78396: PUSH
78397: LD_INT 1
78399: PUSH
78400: LD_INT 4
78402: NEG
78403: PUSH
78404: EMPTY
78405: LIST
78406: LIST
78407: PUSH
78408: LD_INT 1
78410: NEG
78411: PUSH
78412: LD_INT 6
78414: NEG
78415: PUSH
78416: EMPTY
78417: LIST
78418: LIST
78419: PUSH
78420: LD_INT 0
78422: PUSH
78423: LD_INT 6
78425: NEG
78426: PUSH
78427: EMPTY
78428: LIST
78429: LIST
78430: PUSH
78431: LD_INT 1
78433: PUSH
78434: LD_INT 5
78436: NEG
78437: PUSH
78438: EMPTY
78439: LIST
78440: LIST
78441: PUSH
78442: EMPTY
78443: LIST
78444: LIST
78445: LIST
78446: LIST
78447: LIST
78448: LIST
78449: LIST
78450: LIST
78451: LIST
78452: LIST
78453: LIST
78454: LIST
78455: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
78456: LD_ADDR_VAR 0 30
78460: PUSH
78461: LD_INT 2
78463: PUSH
78464: LD_INT 1
78466: NEG
78467: PUSH
78468: EMPTY
78469: LIST
78470: LIST
78471: PUSH
78472: LD_INT 3
78474: PUSH
78475: LD_INT 0
78477: PUSH
78478: EMPTY
78479: LIST
78480: LIST
78481: PUSH
78482: LD_INT 3
78484: PUSH
78485: LD_INT 1
78487: PUSH
78488: EMPTY
78489: LIST
78490: LIST
78491: PUSH
78492: LD_INT 3
78494: PUSH
78495: LD_INT 1
78497: NEG
78498: PUSH
78499: EMPTY
78500: LIST
78501: LIST
78502: PUSH
78503: LD_INT 4
78505: PUSH
78506: LD_INT 0
78508: PUSH
78509: EMPTY
78510: LIST
78511: LIST
78512: PUSH
78513: LD_INT 4
78515: PUSH
78516: LD_INT 1
78518: PUSH
78519: EMPTY
78520: LIST
78521: LIST
78522: PUSH
78523: LD_INT 4
78525: PUSH
78526: LD_INT 1
78528: NEG
78529: PUSH
78530: EMPTY
78531: LIST
78532: LIST
78533: PUSH
78534: LD_INT 5
78536: PUSH
78537: LD_INT 0
78539: PUSH
78540: EMPTY
78541: LIST
78542: LIST
78543: PUSH
78544: LD_INT 5
78546: PUSH
78547: LD_INT 1
78549: PUSH
78550: EMPTY
78551: LIST
78552: LIST
78553: PUSH
78554: LD_INT 5
78556: PUSH
78557: LD_INT 1
78559: NEG
78560: PUSH
78561: EMPTY
78562: LIST
78563: LIST
78564: PUSH
78565: LD_INT 6
78567: PUSH
78568: LD_INT 0
78570: PUSH
78571: EMPTY
78572: LIST
78573: LIST
78574: PUSH
78575: LD_INT 6
78577: PUSH
78578: LD_INT 1
78580: PUSH
78581: EMPTY
78582: LIST
78583: LIST
78584: PUSH
78585: EMPTY
78586: LIST
78587: LIST
78588: LIST
78589: LIST
78590: LIST
78591: LIST
78592: LIST
78593: LIST
78594: LIST
78595: LIST
78596: LIST
78597: LIST
78598: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
78599: LD_ADDR_VAR 0 31
78603: PUSH
78604: LD_INT 3
78606: PUSH
78607: LD_INT 2
78609: PUSH
78610: EMPTY
78611: LIST
78612: LIST
78613: PUSH
78614: LD_INT 3
78616: PUSH
78617: LD_INT 3
78619: PUSH
78620: EMPTY
78621: LIST
78622: LIST
78623: PUSH
78624: LD_INT 2
78626: PUSH
78627: LD_INT 3
78629: PUSH
78630: EMPTY
78631: LIST
78632: LIST
78633: PUSH
78634: LD_INT 4
78636: PUSH
78637: LD_INT 3
78639: PUSH
78640: EMPTY
78641: LIST
78642: LIST
78643: PUSH
78644: LD_INT 4
78646: PUSH
78647: LD_INT 4
78649: PUSH
78650: EMPTY
78651: LIST
78652: LIST
78653: PUSH
78654: LD_INT 3
78656: PUSH
78657: LD_INT 4
78659: PUSH
78660: EMPTY
78661: LIST
78662: LIST
78663: PUSH
78664: LD_INT 5
78666: PUSH
78667: LD_INT 4
78669: PUSH
78670: EMPTY
78671: LIST
78672: LIST
78673: PUSH
78674: LD_INT 5
78676: PUSH
78677: LD_INT 5
78679: PUSH
78680: EMPTY
78681: LIST
78682: LIST
78683: PUSH
78684: LD_INT 4
78686: PUSH
78687: LD_INT 5
78689: PUSH
78690: EMPTY
78691: LIST
78692: LIST
78693: PUSH
78694: LD_INT 6
78696: PUSH
78697: LD_INT 5
78699: PUSH
78700: EMPTY
78701: LIST
78702: LIST
78703: PUSH
78704: LD_INT 6
78706: PUSH
78707: LD_INT 6
78709: PUSH
78710: EMPTY
78711: LIST
78712: LIST
78713: PUSH
78714: LD_INT 5
78716: PUSH
78717: LD_INT 6
78719: PUSH
78720: EMPTY
78721: LIST
78722: LIST
78723: PUSH
78724: EMPTY
78725: LIST
78726: LIST
78727: LIST
78728: LIST
78729: LIST
78730: LIST
78731: LIST
78732: LIST
78733: LIST
78734: LIST
78735: LIST
78736: LIST
78737: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
78738: LD_ADDR_VAR 0 32
78742: PUSH
78743: LD_INT 1
78745: PUSH
78746: LD_INT 3
78748: PUSH
78749: EMPTY
78750: LIST
78751: LIST
78752: PUSH
78753: LD_INT 0
78755: PUSH
78756: LD_INT 3
78758: PUSH
78759: EMPTY
78760: LIST
78761: LIST
78762: PUSH
78763: LD_INT 1
78765: NEG
78766: PUSH
78767: LD_INT 2
78769: PUSH
78770: EMPTY
78771: LIST
78772: LIST
78773: PUSH
78774: LD_INT 1
78776: PUSH
78777: LD_INT 4
78779: PUSH
78780: EMPTY
78781: LIST
78782: LIST
78783: PUSH
78784: LD_INT 0
78786: PUSH
78787: LD_INT 4
78789: PUSH
78790: EMPTY
78791: LIST
78792: LIST
78793: PUSH
78794: LD_INT 1
78796: NEG
78797: PUSH
78798: LD_INT 3
78800: PUSH
78801: EMPTY
78802: LIST
78803: LIST
78804: PUSH
78805: LD_INT 1
78807: PUSH
78808: LD_INT 5
78810: PUSH
78811: EMPTY
78812: LIST
78813: LIST
78814: PUSH
78815: LD_INT 0
78817: PUSH
78818: LD_INT 5
78820: PUSH
78821: EMPTY
78822: LIST
78823: LIST
78824: PUSH
78825: LD_INT 1
78827: NEG
78828: PUSH
78829: LD_INT 4
78831: PUSH
78832: EMPTY
78833: LIST
78834: LIST
78835: PUSH
78836: LD_INT 1
78838: PUSH
78839: LD_INT 6
78841: PUSH
78842: EMPTY
78843: LIST
78844: LIST
78845: PUSH
78846: LD_INT 0
78848: PUSH
78849: LD_INT 6
78851: PUSH
78852: EMPTY
78853: LIST
78854: LIST
78855: PUSH
78856: LD_INT 1
78858: NEG
78859: PUSH
78860: LD_INT 5
78862: PUSH
78863: EMPTY
78864: LIST
78865: LIST
78866: PUSH
78867: EMPTY
78868: LIST
78869: LIST
78870: LIST
78871: LIST
78872: LIST
78873: LIST
78874: LIST
78875: LIST
78876: LIST
78877: LIST
78878: LIST
78879: LIST
78880: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
78881: LD_ADDR_VAR 0 33
78885: PUSH
78886: LD_INT 2
78888: NEG
78889: PUSH
78890: LD_INT 1
78892: PUSH
78893: EMPTY
78894: LIST
78895: LIST
78896: PUSH
78897: LD_INT 3
78899: NEG
78900: PUSH
78901: LD_INT 0
78903: PUSH
78904: EMPTY
78905: LIST
78906: LIST
78907: PUSH
78908: LD_INT 3
78910: NEG
78911: PUSH
78912: LD_INT 1
78914: NEG
78915: PUSH
78916: EMPTY
78917: LIST
78918: LIST
78919: PUSH
78920: LD_INT 3
78922: NEG
78923: PUSH
78924: LD_INT 1
78926: PUSH
78927: EMPTY
78928: LIST
78929: LIST
78930: PUSH
78931: LD_INT 4
78933: NEG
78934: PUSH
78935: LD_INT 0
78937: PUSH
78938: EMPTY
78939: LIST
78940: LIST
78941: PUSH
78942: LD_INT 4
78944: NEG
78945: PUSH
78946: LD_INT 1
78948: NEG
78949: PUSH
78950: EMPTY
78951: LIST
78952: LIST
78953: PUSH
78954: LD_INT 4
78956: NEG
78957: PUSH
78958: LD_INT 1
78960: PUSH
78961: EMPTY
78962: LIST
78963: LIST
78964: PUSH
78965: LD_INT 5
78967: NEG
78968: PUSH
78969: LD_INT 0
78971: PUSH
78972: EMPTY
78973: LIST
78974: LIST
78975: PUSH
78976: LD_INT 5
78978: NEG
78979: PUSH
78980: LD_INT 1
78982: NEG
78983: PUSH
78984: EMPTY
78985: LIST
78986: LIST
78987: PUSH
78988: LD_INT 5
78990: NEG
78991: PUSH
78992: LD_INT 1
78994: PUSH
78995: EMPTY
78996: LIST
78997: LIST
78998: PUSH
78999: LD_INT 6
79001: NEG
79002: PUSH
79003: LD_INT 0
79005: PUSH
79006: EMPTY
79007: LIST
79008: LIST
79009: PUSH
79010: LD_INT 6
79012: NEG
79013: PUSH
79014: LD_INT 1
79016: NEG
79017: PUSH
79018: EMPTY
79019: LIST
79020: LIST
79021: PUSH
79022: EMPTY
79023: LIST
79024: LIST
79025: LIST
79026: LIST
79027: LIST
79028: LIST
79029: LIST
79030: LIST
79031: LIST
79032: LIST
79033: LIST
79034: LIST
79035: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
79036: LD_ADDR_VAR 0 34
79040: PUSH
79041: LD_INT 2
79043: NEG
79044: PUSH
79045: LD_INT 3
79047: NEG
79048: PUSH
79049: EMPTY
79050: LIST
79051: LIST
79052: PUSH
79053: LD_INT 3
79055: NEG
79056: PUSH
79057: LD_INT 2
79059: NEG
79060: PUSH
79061: EMPTY
79062: LIST
79063: LIST
79064: PUSH
79065: LD_INT 3
79067: NEG
79068: PUSH
79069: LD_INT 3
79071: NEG
79072: PUSH
79073: EMPTY
79074: LIST
79075: LIST
79076: PUSH
79077: LD_INT 3
79079: NEG
79080: PUSH
79081: LD_INT 4
79083: NEG
79084: PUSH
79085: EMPTY
79086: LIST
79087: LIST
79088: PUSH
79089: LD_INT 4
79091: NEG
79092: PUSH
79093: LD_INT 3
79095: NEG
79096: PUSH
79097: EMPTY
79098: LIST
79099: LIST
79100: PUSH
79101: LD_INT 4
79103: NEG
79104: PUSH
79105: LD_INT 4
79107: NEG
79108: PUSH
79109: EMPTY
79110: LIST
79111: LIST
79112: PUSH
79113: LD_INT 4
79115: NEG
79116: PUSH
79117: LD_INT 5
79119: NEG
79120: PUSH
79121: EMPTY
79122: LIST
79123: LIST
79124: PUSH
79125: LD_INT 5
79127: NEG
79128: PUSH
79129: LD_INT 4
79131: NEG
79132: PUSH
79133: EMPTY
79134: LIST
79135: LIST
79136: PUSH
79137: LD_INT 5
79139: NEG
79140: PUSH
79141: LD_INT 5
79143: NEG
79144: PUSH
79145: EMPTY
79146: LIST
79147: LIST
79148: PUSH
79149: LD_INT 5
79151: NEG
79152: PUSH
79153: LD_INT 6
79155: NEG
79156: PUSH
79157: EMPTY
79158: LIST
79159: LIST
79160: PUSH
79161: LD_INT 6
79163: NEG
79164: PUSH
79165: LD_INT 5
79167: NEG
79168: PUSH
79169: EMPTY
79170: LIST
79171: LIST
79172: PUSH
79173: LD_INT 6
79175: NEG
79176: PUSH
79177: LD_INT 6
79179: NEG
79180: PUSH
79181: EMPTY
79182: LIST
79183: LIST
79184: PUSH
79185: EMPTY
79186: LIST
79187: LIST
79188: LIST
79189: LIST
79190: LIST
79191: LIST
79192: LIST
79193: LIST
79194: LIST
79195: LIST
79196: LIST
79197: LIST
79198: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
79199: LD_ADDR_VAR 0 41
79203: PUSH
79204: LD_INT 0
79206: PUSH
79207: LD_INT 2
79209: NEG
79210: PUSH
79211: EMPTY
79212: LIST
79213: LIST
79214: PUSH
79215: LD_INT 1
79217: NEG
79218: PUSH
79219: LD_INT 3
79221: NEG
79222: PUSH
79223: EMPTY
79224: LIST
79225: LIST
79226: PUSH
79227: LD_INT 1
79229: PUSH
79230: LD_INT 2
79232: NEG
79233: PUSH
79234: EMPTY
79235: LIST
79236: LIST
79237: PUSH
79238: EMPTY
79239: LIST
79240: LIST
79241: LIST
79242: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
79243: LD_ADDR_VAR 0 42
79247: PUSH
79248: LD_INT 2
79250: PUSH
79251: LD_INT 0
79253: PUSH
79254: EMPTY
79255: LIST
79256: LIST
79257: PUSH
79258: LD_INT 2
79260: PUSH
79261: LD_INT 1
79263: NEG
79264: PUSH
79265: EMPTY
79266: LIST
79267: LIST
79268: PUSH
79269: LD_INT 3
79271: PUSH
79272: LD_INT 1
79274: PUSH
79275: EMPTY
79276: LIST
79277: LIST
79278: PUSH
79279: EMPTY
79280: LIST
79281: LIST
79282: LIST
79283: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
79284: LD_ADDR_VAR 0 43
79288: PUSH
79289: LD_INT 2
79291: PUSH
79292: LD_INT 2
79294: PUSH
79295: EMPTY
79296: LIST
79297: LIST
79298: PUSH
79299: LD_INT 3
79301: PUSH
79302: LD_INT 2
79304: PUSH
79305: EMPTY
79306: LIST
79307: LIST
79308: PUSH
79309: LD_INT 2
79311: PUSH
79312: LD_INT 3
79314: PUSH
79315: EMPTY
79316: LIST
79317: LIST
79318: PUSH
79319: EMPTY
79320: LIST
79321: LIST
79322: LIST
79323: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
79324: LD_ADDR_VAR 0 44
79328: PUSH
79329: LD_INT 0
79331: PUSH
79332: LD_INT 2
79334: PUSH
79335: EMPTY
79336: LIST
79337: LIST
79338: PUSH
79339: LD_INT 1
79341: PUSH
79342: LD_INT 3
79344: PUSH
79345: EMPTY
79346: LIST
79347: LIST
79348: PUSH
79349: LD_INT 1
79351: NEG
79352: PUSH
79353: LD_INT 2
79355: PUSH
79356: EMPTY
79357: LIST
79358: LIST
79359: PUSH
79360: EMPTY
79361: LIST
79362: LIST
79363: LIST
79364: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
79365: LD_ADDR_VAR 0 45
79369: PUSH
79370: LD_INT 2
79372: NEG
79373: PUSH
79374: LD_INT 0
79376: PUSH
79377: EMPTY
79378: LIST
79379: LIST
79380: PUSH
79381: LD_INT 2
79383: NEG
79384: PUSH
79385: LD_INT 1
79387: PUSH
79388: EMPTY
79389: LIST
79390: LIST
79391: PUSH
79392: LD_INT 3
79394: NEG
79395: PUSH
79396: LD_INT 1
79398: NEG
79399: PUSH
79400: EMPTY
79401: LIST
79402: LIST
79403: PUSH
79404: EMPTY
79405: LIST
79406: LIST
79407: LIST
79408: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
79409: LD_ADDR_VAR 0 46
79413: PUSH
79414: LD_INT 2
79416: NEG
79417: PUSH
79418: LD_INT 2
79420: NEG
79421: PUSH
79422: EMPTY
79423: LIST
79424: LIST
79425: PUSH
79426: LD_INT 2
79428: NEG
79429: PUSH
79430: LD_INT 3
79432: NEG
79433: PUSH
79434: EMPTY
79435: LIST
79436: LIST
79437: PUSH
79438: LD_INT 3
79440: NEG
79441: PUSH
79442: LD_INT 2
79444: NEG
79445: PUSH
79446: EMPTY
79447: LIST
79448: LIST
79449: PUSH
79450: EMPTY
79451: LIST
79452: LIST
79453: LIST
79454: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
79455: LD_ADDR_VAR 0 47
79459: PUSH
79460: LD_INT 2
79462: NEG
79463: PUSH
79464: LD_INT 3
79466: NEG
79467: PUSH
79468: EMPTY
79469: LIST
79470: LIST
79471: PUSH
79472: LD_INT 1
79474: NEG
79475: PUSH
79476: LD_INT 3
79478: NEG
79479: PUSH
79480: EMPTY
79481: LIST
79482: LIST
79483: PUSH
79484: EMPTY
79485: LIST
79486: LIST
79487: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
79488: LD_ADDR_VAR 0 48
79492: PUSH
79493: LD_INT 1
79495: PUSH
79496: LD_INT 2
79498: NEG
79499: PUSH
79500: EMPTY
79501: LIST
79502: LIST
79503: PUSH
79504: LD_INT 2
79506: PUSH
79507: LD_INT 1
79509: NEG
79510: PUSH
79511: EMPTY
79512: LIST
79513: LIST
79514: PUSH
79515: EMPTY
79516: LIST
79517: LIST
79518: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
79519: LD_ADDR_VAR 0 49
79523: PUSH
79524: LD_INT 3
79526: PUSH
79527: LD_INT 1
79529: PUSH
79530: EMPTY
79531: LIST
79532: LIST
79533: PUSH
79534: LD_INT 3
79536: PUSH
79537: LD_INT 2
79539: PUSH
79540: EMPTY
79541: LIST
79542: LIST
79543: PUSH
79544: EMPTY
79545: LIST
79546: LIST
79547: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
79548: LD_ADDR_VAR 0 50
79552: PUSH
79553: LD_INT 2
79555: PUSH
79556: LD_INT 3
79558: PUSH
79559: EMPTY
79560: LIST
79561: LIST
79562: PUSH
79563: LD_INT 1
79565: PUSH
79566: LD_INT 3
79568: PUSH
79569: EMPTY
79570: LIST
79571: LIST
79572: PUSH
79573: EMPTY
79574: LIST
79575: LIST
79576: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
79577: LD_ADDR_VAR 0 51
79581: PUSH
79582: LD_INT 1
79584: NEG
79585: PUSH
79586: LD_INT 2
79588: PUSH
79589: EMPTY
79590: LIST
79591: LIST
79592: PUSH
79593: LD_INT 2
79595: NEG
79596: PUSH
79597: LD_INT 1
79599: PUSH
79600: EMPTY
79601: LIST
79602: LIST
79603: PUSH
79604: EMPTY
79605: LIST
79606: LIST
79607: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
79608: LD_ADDR_VAR 0 52
79612: PUSH
79613: LD_INT 3
79615: NEG
79616: PUSH
79617: LD_INT 1
79619: NEG
79620: PUSH
79621: EMPTY
79622: LIST
79623: LIST
79624: PUSH
79625: LD_INT 3
79627: NEG
79628: PUSH
79629: LD_INT 2
79631: NEG
79632: PUSH
79633: EMPTY
79634: LIST
79635: LIST
79636: PUSH
79637: EMPTY
79638: LIST
79639: LIST
79640: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79641: LD_ADDR_VAR 0 53
79645: PUSH
79646: LD_INT 1
79648: NEG
79649: PUSH
79650: LD_INT 3
79652: NEG
79653: PUSH
79654: EMPTY
79655: LIST
79656: LIST
79657: PUSH
79658: LD_INT 0
79660: PUSH
79661: LD_INT 3
79663: NEG
79664: PUSH
79665: EMPTY
79666: LIST
79667: LIST
79668: PUSH
79669: LD_INT 1
79671: PUSH
79672: LD_INT 2
79674: NEG
79675: PUSH
79676: EMPTY
79677: LIST
79678: LIST
79679: PUSH
79680: EMPTY
79681: LIST
79682: LIST
79683: LIST
79684: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79685: LD_ADDR_VAR 0 54
79689: PUSH
79690: LD_INT 2
79692: PUSH
79693: LD_INT 1
79695: NEG
79696: PUSH
79697: EMPTY
79698: LIST
79699: LIST
79700: PUSH
79701: LD_INT 3
79703: PUSH
79704: LD_INT 0
79706: PUSH
79707: EMPTY
79708: LIST
79709: LIST
79710: PUSH
79711: LD_INT 3
79713: PUSH
79714: LD_INT 1
79716: PUSH
79717: EMPTY
79718: LIST
79719: LIST
79720: PUSH
79721: EMPTY
79722: LIST
79723: LIST
79724: LIST
79725: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79726: LD_ADDR_VAR 0 55
79730: PUSH
79731: LD_INT 3
79733: PUSH
79734: LD_INT 2
79736: PUSH
79737: EMPTY
79738: LIST
79739: LIST
79740: PUSH
79741: LD_INT 3
79743: PUSH
79744: LD_INT 3
79746: PUSH
79747: EMPTY
79748: LIST
79749: LIST
79750: PUSH
79751: LD_INT 2
79753: PUSH
79754: LD_INT 3
79756: PUSH
79757: EMPTY
79758: LIST
79759: LIST
79760: PUSH
79761: EMPTY
79762: LIST
79763: LIST
79764: LIST
79765: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
79766: LD_ADDR_VAR 0 56
79770: PUSH
79771: LD_INT 1
79773: PUSH
79774: LD_INT 3
79776: PUSH
79777: EMPTY
79778: LIST
79779: LIST
79780: PUSH
79781: LD_INT 0
79783: PUSH
79784: LD_INT 3
79786: PUSH
79787: EMPTY
79788: LIST
79789: LIST
79790: PUSH
79791: LD_INT 1
79793: NEG
79794: PUSH
79795: LD_INT 2
79797: PUSH
79798: EMPTY
79799: LIST
79800: LIST
79801: PUSH
79802: EMPTY
79803: LIST
79804: LIST
79805: LIST
79806: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
79807: LD_ADDR_VAR 0 57
79811: PUSH
79812: LD_INT 2
79814: NEG
79815: PUSH
79816: LD_INT 1
79818: PUSH
79819: EMPTY
79820: LIST
79821: LIST
79822: PUSH
79823: LD_INT 3
79825: NEG
79826: PUSH
79827: LD_INT 0
79829: PUSH
79830: EMPTY
79831: LIST
79832: LIST
79833: PUSH
79834: LD_INT 3
79836: NEG
79837: PUSH
79838: LD_INT 1
79840: NEG
79841: PUSH
79842: EMPTY
79843: LIST
79844: LIST
79845: PUSH
79846: EMPTY
79847: LIST
79848: LIST
79849: LIST
79850: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
79851: LD_ADDR_VAR 0 58
79855: PUSH
79856: LD_INT 2
79858: NEG
79859: PUSH
79860: LD_INT 3
79862: NEG
79863: PUSH
79864: EMPTY
79865: LIST
79866: LIST
79867: PUSH
79868: LD_INT 3
79870: NEG
79871: PUSH
79872: LD_INT 2
79874: NEG
79875: PUSH
79876: EMPTY
79877: LIST
79878: LIST
79879: PUSH
79880: LD_INT 3
79882: NEG
79883: PUSH
79884: LD_INT 3
79886: NEG
79887: PUSH
79888: EMPTY
79889: LIST
79890: LIST
79891: PUSH
79892: EMPTY
79893: LIST
79894: LIST
79895: LIST
79896: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
79897: LD_ADDR_VAR 0 59
79901: PUSH
79902: LD_INT 1
79904: NEG
79905: PUSH
79906: LD_INT 2
79908: NEG
79909: PUSH
79910: EMPTY
79911: LIST
79912: LIST
79913: PUSH
79914: LD_INT 0
79916: PUSH
79917: LD_INT 2
79919: NEG
79920: PUSH
79921: EMPTY
79922: LIST
79923: LIST
79924: PUSH
79925: LD_INT 1
79927: PUSH
79928: LD_INT 1
79930: NEG
79931: PUSH
79932: EMPTY
79933: LIST
79934: LIST
79935: PUSH
79936: EMPTY
79937: LIST
79938: LIST
79939: LIST
79940: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
79941: LD_ADDR_VAR 0 60
79945: PUSH
79946: LD_INT 1
79948: PUSH
79949: LD_INT 1
79951: NEG
79952: PUSH
79953: EMPTY
79954: LIST
79955: LIST
79956: PUSH
79957: LD_INT 2
79959: PUSH
79960: LD_INT 0
79962: PUSH
79963: EMPTY
79964: LIST
79965: LIST
79966: PUSH
79967: LD_INT 2
79969: PUSH
79970: LD_INT 1
79972: PUSH
79973: EMPTY
79974: LIST
79975: LIST
79976: PUSH
79977: EMPTY
79978: LIST
79979: LIST
79980: LIST
79981: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
79982: LD_ADDR_VAR 0 61
79986: PUSH
79987: LD_INT 2
79989: PUSH
79990: LD_INT 1
79992: PUSH
79993: EMPTY
79994: LIST
79995: LIST
79996: PUSH
79997: LD_INT 2
79999: PUSH
80000: LD_INT 2
80002: PUSH
80003: EMPTY
80004: LIST
80005: LIST
80006: PUSH
80007: LD_INT 1
80009: PUSH
80010: LD_INT 2
80012: PUSH
80013: EMPTY
80014: LIST
80015: LIST
80016: PUSH
80017: EMPTY
80018: LIST
80019: LIST
80020: LIST
80021: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
80022: LD_ADDR_VAR 0 62
80026: PUSH
80027: LD_INT 1
80029: PUSH
80030: LD_INT 2
80032: PUSH
80033: EMPTY
80034: LIST
80035: LIST
80036: PUSH
80037: LD_INT 0
80039: PUSH
80040: LD_INT 2
80042: PUSH
80043: EMPTY
80044: LIST
80045: LIST
80046: PUSH
80047: LD_INT 1
80049: NEG
80050: PUSH
80051: LD_INT 1
80053: PUSH
80054: EMPTY
80055: LIST
80056: LIST
80057: PUSH
80058: EMPTY
80059: LIST
80060: LIST
80061: LIST
80062: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
80063: LD_ADDR_VAR 0 63
80067: PUSH
80068: LD_INT 1
80070: NEG
80071: PUSH
80072: LD_INT 1
80074: PUSH
80075: EMPTY
80076: LIST
80077: LIST
80078: PUSH
80079: LD_INT 2
80081: NEG
80082: PUSH
80083: LD_INT 0
80085: PUSH
80086: EMPTY
80087: LIST
80088: LIST
80089: PUSH
80090: LD_INT 2
80092: NEG
80093: PUSH
80094: LD_INT 1
80096: NEG
80097: PUSH
80098: EMPTY
80099: LIST
80100: LIST
80101: PUSH
80102: EMPTY
80103: LIST
80104: LIST
80105: LIST
80106: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80107: LD_ADDR_VAR 0 64
80111: PUSH
80112: LD_INT 1
80114: NEG
80115: PUSH
80116: LD_INT 2
80118: NEG
80119: PUSH
80120: EMPTY
80121: LIST
80122: LIST
80123: PUSH
80124: LD_INT 2
80126: NEG
80127: PUSH
80128: LD_INT 1
80130: NEG
80131: PUSH
80132: EMPTY
80133: LIST
80134: LIST
80135: PUSH
80136: LD_INT 2
80138: NEG
80139: PUSH
80140: LD_INT 2
80142: NEG
80143: PUSH
80144: EMPTY
80145: LIST
80146: LIST
80147: PUSH
80148: EMPTY
80149: LIST
80150: LIST
80151: LIST
80152: ST_TO_ADDR
// end ; 2 :
80153: GO 83419
80155: LD_INT 2
80157: DOUBLE
80158: EQUAL
80159: IFTRUE 80163
80161: GO 83418
80163: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
80164: LD_ADDR_VAR 0 29
80168: PUSH
80169: LD_INT 4
80171: PUSH
80172: LD_INT 0
80174: PUSH
80175: EMPTY
80176: LIST
80177: LIST
80178: PUSH
80179: LD_INT 4
80181: PUSH
80182: LD_INT 1
80184: NEG
80185: PUSH
80186: EMPTY
80187: LIST
80188: LIST
80189: PUSH
80190: LD_INT 5
80192: PUSH
80193: LD_INT 0
80195: PUSH
80196: EMPTY
80197: LIST
80198: LIST
80199: PUSH
80200: LD_INT 5
80202: PUSH
80203: LD_INT 1
80205: PUSH
80206: EMPTY
80207: LIST
80208: LIST
80209: PUSH
80210: LD_INT 4
80212: PUSH
80213: LD_INT 1
80215: PUSH
80216: EMPTY
80217: LIST
80218: LIST
80219: PUSH
80220: LD_INT 3
80222: PUSH
80223: LD_INT 0
80225: PUSH
80226: EMPTY
80227: LIST
80228: LIST
80229: PUSH
80230: LD_INT 3
80232: PUSH
80233: LD_INT 1
80235: NEG
80236: PUSH
80237: EMPTY
80238: LIST
80239: LIST
80240: PUSH
80241: LD_INT 3
80243: PUSH
80244: LD_INT 2
80246: NEG
80247: PUSH
80248: EMPTY
80249: LIST
80250: LIST
80251: PUSH
80252: LD_INT 5
80254: PUSH
80255: LD_INT 2
80257: PUSH
80258: EMPTY
80259: LIST
80260: LIST
80261: PUSH
80262: LD_INT 3
80264: PUSH
80265: LD_INT 3
80267: PUSH
80268: EMPTY
80269: LIST
80270: LIST
80271: PUSH
80272: LD_INT 3
80274: PUSH
80275: LD_INT 2
80277: PUSH
80278: EMPTY
80279: LIST
80280: LIST
80281: PUSH
80282: LD_INT 4
80284: PUSH
80285: LD_INT 3
80287: PUSH
80288: EMPTY
80289: LIST
80290: LIST
80291: PUSH
80292: LD_INT 4
80294: PUSH
80295: LD_INT 4
80297: PUSH
80298: EMPTY
80299: LIST
80300: LIST
80301: PUSH
80302: LD_INT 3
80304: PUSH
80305: LD_INT 4
80307: PUSH
80308: EMPTY
80309: LIST
80310: LIST
80311: PUSH
80312: LD_INT 2
80314: PUSH
80315: LD_INT 3
80317: PUSH
80318: EMPTY
80319: LIST
80320: LIST
80321: PUSH
80322: LD_INT 2
80324: PUSH
80325: LD_INT 2
80327: PUSH
80328: EMPTY
80329: LIST
80330: LIST
80331: PUSH
80332: LD_INT 4
80334: PUSH
80335: LD_INT 2
80337: PUSH
80338: EMPTY
80339: LIST
80340: LIST
80341: PUSH
80342: LD_INT 2
80344: PUSH
80345: LD_INT 4
80347: PUSH
80348: EMPTY
80349: LIST
80350: LIST
80351: PUSH
80352: LD_INT 0
80354: PUSH
80355: LD_INT 4
80357: PUSH
80358: EMPTY
80359: LIST
80360: LIST
80361: PUSH
80362: LD_INT 0
80364: PUSH
80365: LD_INT 3
80367: PUSH
80368: EMPTY
80369: LIST
80370: LIST
80371: PUSH
80372: LD_INT 1
80374: PUSH
80375: LD_INT 4
80377: PUSH
80378: EMPTY
80379: LIST
80380: LIST
80381: PUSH
80382: LD_INT 1
80384: PUSH
80385: LD_INT 5
80387: PUSH
80388: EMPTY
80389: LIST
80390: LIST
80391: PUSH
80392: LD_INT 0
80394: PUSH
80395: LD_INT 5
80397: PUSH
80398: EMPTY
80399: LIST
80400: LIST
80401: PUSH
80402: LD_INT 1
80404: NEG
80405: PUSH
80406: LD_INT 4
80408: PUSH
80409: EMPTY
80410: LIST
80411: LIST
80412: PUSH
80413: LD_INT 1
80415: NEG
80416: PUSH
80417: LD_INT 3
80419: PUSH
80420: EMPTY
80421: LIST
80422: LIST
80423: PUSH
80424: LD_INT 2
80426: PUSH
80427: LD_INT 5
80429: PUSH
80430: EMPTY
80431: LIST
80432: LIST
80433: PUSH
80434: LD_INT 2
80436: NEG
80437: PUSH
80438: LD_INT 3
80440: PUSH
80441: EMPTY
80442: LIST
80443: LIST
80444: PUSH
80445: LD_INT 3
80447: NEG
80448: PUSH
80449: LD_INT 0
80451: PUSH
80452: EMPTY
80453: LIST
80454: LIST
80455: PUSH
80456: LD_INT 3
80458: NEG
80459: PUSH
80460: LD_INT 1
80462: NEG
80463: PUSH
80464: EMPTY
80465: LIST
80466: LIST
80467: PUSH
80468: LD_INT 2
80470: NEG
80471: PUSH
80472: LD_INT 0
80474: PUSH
80475: EMPTY
80476: LIST
80477: LIST
80478: PUSH
80479: LD_INT 2
80481: NEG
80482: PUSH
80483: LD_INT 1
80485: PUSH
80486: EMPTY
80487: LIST
80488: LIST
80489: PUSH
80490: LD_INT 3
80492: NEG
80493: PUSH
80494: LD_INT 1
80496: PUSH
80497: EMPTY
80498: LIST
80499: LIST
80500: PUSH
80501: LD_INT 4
80503: NEG
80504: PUSH
80505: LD_INT 0
80507: PUSH
80508: EMPTY
80509: LIST
80510: LIST
80511: PUSH
80512: LD_INT 4
80514: NEG
80515: PUSH
80516: LD_INT 1
80518: NEG
80519: PUSH
80520: EMPTY
80521: LIST
80522: LIST
80523: PUSH
80524: LD_INT 4
80526: NEG
80527: PUSH
80528: LD_INT 2
80530: NEG
80531: PUSH
80532: EMPTY
80533: LIST
80534: LIST
80535: PUSH
80536: LD_INT 2
80538: NEG
80539: PUSH
80540: LD_INT 2
80542: PUSH
80543: EMPTY
80544: LIST
80545: LIST
80546: PUSH
80547: LD_INT 4
80549: NEG
80550: PUSH
80551: LD_INT 4
80553: NEG
80554: PUSH
80555: EMPTY
80556: LIST
80557: LIST
80558: PUSH
80559: LD_INT 4
80561: NEG
80562: PUSH
80563: LD_INT 5
80565: NEG
80566: PUSH
80567: EMPTY
80568: LIST
80569: LIST
80570: PUSH
80571: LD_INT 3
80573: NEG
80574: PUSH
80575: LD_INT 4
80577: NEG
80578: PUSH
80579: EMPTY
80580: LIST
80581: LIST
80582: PUSH
80583: LD_INT 3
80585: NEG
80586: PUSH
80587: LD_INT 3
80589: NEG
80590: PUSH
80591: EMPTY
80592: LIST
80593: LIST
80594: PUSH
80595: LD_INT 4
80597: NEG
80598: PUSH
80599: LD_INT 3
80601: NEG
80602: PUSH
80603: EMPTY
80604: LIST
80605: LIST
80606: PUSH
80607: LD_INT 5
80609: NEG
80610: PUSH
80611: LD_INT 4
80613: NEG
80614: PUSH
80615: EMPTY
80616: LIST
80617: LIST
80618: PUSH
80619: LD_INT 5
80621: NEG
80622: PUSH
80623: LD_INT 5
80625: NEG
80626: PUSH
80627: EMPTY
80628: LIST
80629: LIST
80630: PUSH
80631: LD_INT 3
80633: NEG
80634: PUSH
80635: LD_INT 5
80637: NEG
80638: PUSH
80639: EMPTY
80640: LIST
80641: LIST
80642: PUSH
80643: LD_INT 5
80645: NEG
80646: PUSH
80647: LD_INT 3
80649: NEG
80650: PUSH
80651: EMPTY
80652: LIST
80653: LIST
80654: PUSH
80655: EMPTY
80656: LIST
80657: LIST
80658: LIST
80659: LIST
80660: LIST
80661: LIST
80662: LIST
80663: LIST
80664: LIST
80665: LIST
80666: LIST
80667: LIST
80668: LIST
80669: LIST
80670: LIST
80671: LIST
80672: LIST
80673: LIST
80674: LIST
80675: LIST
80676: LIST
80677: LIST
80678: LIST
80679: LIST
80680: LIST
80681: LIST
80682: LIST
80683: LIST
80684: LIST
80685: LIST
80686: LIST
80687: LIST
80688: LIST
80689: LIST
80690: LIST
80691: LIST
80692: LIST
80693: LIST
80694: LIST
80695: LIST
80696: LIST
80697: LIST
80698: LIST
80699: LIST
80700: LIST
80701: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
80702: LD_ADDR_VAR 0 30
80706: PUSH
80707: LD_INT 4
80709: PUSH
80710: LD_INT 4
80712: PUSH
80713: EMPTY
80714: LIST
80715: LIST
80716: PUSH
80717: LD_INT 4
80719: PUSH
80720: LD_INT 3
80722: PUSH
80723: EMPTY
80724: LIST
80725: LIST
80726: PUSH
80727: LD_INT 5
80729: PUSH
80730: LD_INT 4
80732: PUSH
80733: EMPTY
80734: LIST
80735: LIST
80736: PUSH
80737: LD_INT 5
80739: PUSH
80740: LD_INT 5
80742: PUSH
80743: EMPTY
80744: LIST
80745: LIST
80746: PUSH
80747: LD_INT 4
80749: PUSH
80750: LD_INT 5
80752: PUSH
80753: EMPTY
80754: LIST
80755: LIST
80756: PUSH
80757: LD_INT 3
80759: PUSH
80760: LD_INT 4
80762: PUSH
80763: EMPTY
80764: LIST
80765: LIST
80766: PUSH
80767: LD_INT 3
80769: PUSH
80770: LD_INT 3
80772: PUSH
80773: EMPTY
80774: LIST
80775: LIST
80776: PUSH
80777: LD_INT 5
80779: PUSH
80780: LD_INT 3
80782: PUSH
80783: EMPTY
80784: LIST
80785: LIST
80786: PUSH
80787: LD_INT 3
80789: PUSH
80790: LD_INT 5
80792: PUSH
80793: EMPTY
80794: LIST
80795: LIST
80796: PUSH
80797: LD_INT 0
80799: PUSH
80800: LD_INT 3
80802: PUSH
80803: EMPTY
80804: LIST
80805: LIST
80806: PUSH
80807: LD_INT 0
80809: PUSH
80810: LD_INT 2
80812: PUSH
80813: EMPTY
80814: LIST
80815: LIST
80816: PUSH
80817: LD_INT 1
80819: PUSH
80820: LD_INT 3
80822: PUSH
80823: EMPTY
80824: LIST
80825: LIST
80826: PUSH
80827: LD_INT 1
80829: PUSH
80830: LD_INT 4
80832: PUSH
80833: EMPTY
80834: LIST
80835: LIST
80836: PUSH
80837: LD_INT 0
80839: PUSH
80840: LD_INT 4
80842: PUSH
80843: EMPTY
80844: LIST
80845: LIST
80846: PUSH
80847: LD_INT 1
80849: NEG
80850: PUSH
80851: LD_INT 3
80853: PUSH
80854: EMPTY
80855: LIST
80856: LIST
80857: PUSH
80858: LD_INT 1
80860: NEG
80861: PUSH
80862: LD_INT 2
80864: PUSH
80865: EMPTY
80866: LIST
80867: LIST
80868: PUSH
80869: LD_INT 2
80871: PUSH
80872: LD_INT 4
80874: PUSH
80875: EMPTY
80876: LIST
80877: LIST
80878: PUSH
80879: LD_INT 2
80881: NEG
80882: PUSH
80883: LD_INT 2
80885: PUSH
80886: EMPTY
80887: LIST
80888: LIST
80889: PUSH
80890: LD_INT 4
80892: NEG
80893: PUSH
80894: LD_INT 0
80896: PUSH
80897: EMPTY
80898: LIST
80899: LIST
80900: PUSH
80901: LD_INT 4
80903: NEG
80904: PUSH
80905: LD_INT 1
80907: NEG
80908: PUSH
80909: EMPTY
80910: LIST
80911: LIST
80912: PUSH
80913: LD_INT 3
80915: NEG
80916: PUSH
80917: LD_INT 0
80919: PUSH
80920: EMPTY
80921: LIST
80922: LIST
80923: PUSH
80924: LD_INT 3
80926: NEG
80927: PUSH
80928: LD_INT 1
80930: PUSH
80931: EMPTY
80932: LIST
80933: LIST
80934: PUSH
80935: LD_INT 4
80937: NEG
80938: PUSH
80939: LD_INT 1
80941: PUSH
80942: EMPTY
80943: LIST
80944: LIST
80945: PUSH
80946: LD_INT 5
80948: NEG
80949: PUSH
80950: LD_INT 0
80952: PUSH
80953: EMPTY
80954: LIST
80955: LIST
80956: PUSH
80957: LD_INT 5
80959: NEG
80960: PUSH
80961: LD_INT 1
80963: NEG
80964: PUSH
80965: EMPTY
80966: LIST
80967: LIST
80968: PUSH
80969: LD_INT 5
80971: NEG
80972: PUSH
80973: LD_INT 2
80975: NEG
80976: PUSH
80977: EMPTY
80978: LIST
80979: LIST
80980: PUSH
80981: LD_INT 3
80983: NEG
80984: PUSH
80985: LD_INT 2
80987: PUSH
80988: EMPTY
80989: LIST
80990: LIST
80991: PUSH
80992: LD_INT 3
80994: NEG
80995: PUSH
80996: LD_INT 3
80998: NEG
80999: PUSH
81000: EMPTY
81001: LIST
81002: LIST
81003: PUSH
81004: LD_INT 3
81006: NEG
81007: PUSH
81008: LD_INT 4
81010: NEG
81011: PUSH
81012: EMPTY
81013: LIST
81014: LIST
81015: PUSH
81016: LD_INT 2
81018: NEG
81019: PUSH
81020: LD_INT 3
81022: NEG
81023: PUSH
81024: EMPTY
81025: LIST
81026: LIST
81027: PUSH
81028: LD_INT 2
81030: NEG
81031: PUSH
81032: LD_INT 2
81034: NEG
81035: PUSH
81036: EMPTY
81037: LIST
81038: LIST
81039: PUSH
81040: LD_INT 3
81042: NEG
81043: PUSH
81044: LD_INT 2
81046: NEG
81047: PUSH
81048: EMPTY
81049: LIST
81050: LIST
81051: PUSH
81052: LD_INT 4
81054: NEG
81055: PUSH
81056: LD_INT 3
81058: NEG
81059: PUSH
81060: EMPTY
81061: LIST
81062: LIST
81063: PUSH
81064: LD_INT 4
81066: NEG
81067: PUSH
81068: LD_INT 4
81070: NEG
81071: PUSH
81072: EMPTY
81073: LIST
81074: LIST
81075: PUSH
81076: LD_INT 2
81078: NEG
81079: PUSH
81080: LD_INT 4
81082: NEG
81083: PUSH
81084: EMPTY
81085: LIST
81086: LIST
81087: PUSH
81088: LD_INT 4
81090: NEG
81091: PUSH
81092: LD_INT 2
81094: NEG
81095: PUSH
81096: EMPTY
81097: LIST
81098: LIST
81099: PUSH
81100: LD_INT 0
81102: PUSH
81103: LD_INT 4
81105: NEG
81106: PUSH
81107: EMPTY
81108: LIST
81109: LIST
81110: PUSH
81111: LD_INT 0
81113: PUSH
81114: LD_INT 5
81116: NEG
81117: PUSH
81118: EMPTY
81119: LIST
81120: LIST
81121: PUSH
81122: LD_INT 1
81124: PUSH
81125: LD_INT 4
81127: NEG
81128: PUSH
81129: EMPTY
81130: LIST
81131: LIST
81132: PUSH
81133: LD_INT 1
81135: PUSH
81136: LD_INT 3
81138: NEG
81139: PUSH
81140: EMPTY
81141: LIST
81142: LIST
81143: PUSH
81144: LD_INT 0
81146: PUSH
81147: LD_INT 3
81149: NEG
81150: PUSH
81151: EMPTY
81152: LIST
81153: LIST
81154: PUSH
81155: LD_INT 1
81157: NEG
81158: PUSH
81159: LD_INT 4
81161: NEG
81162: PUSH
81163: EMPTY
81164: LIST
81165: LIST
81166: PUSH
81167: LD_INT 1
81169: NEG
81170: PUSH
81171: LD_INT 5
81173: NEG
81174: PUSH
81175: EMPTY
81176: LIST
81177: LIST
81178: PUSH
81179: LD_INT 2
81181: PUSH
81182: LD_INT 3
81184: NEG
81185: PUSH
81186: EMPTY
81187: LIST
81188: LIST
81189: PUSH
81190: LD_INT 2
81192: NEG
81193: PUSH
81194: LD_INT 5
81196: NEG
81197: PUSH
81198: EMPTY
81199: LIST
81200: LIST
81201: PUSH
81202: EMPTY
81203: LIST
81204: LIST
81205: LIST
81206: LIST
81207: LIST
81208: LIST
81209: LIST
81210: LIST
81211: LIST
81212: LIST
81213: LIST
81214: LIST
81215: LIST
81216: LIST
81217: LIST
81218: LIST
81219: LIST
81220: LIST
81221: LIST
81222: LIST
81223: LIST
81224: LIST
81225: LIST
81226: LIST
81227: LIST
81228: LIST
81229: LIST
81230: LIST
81231: LIST
81232: LIST
81233: LIST
81234: LIST
81235: LIST
81236: LIST
81237: LIST
81238: LIST
81239: LIST
81240: LIST
81241: LIST
81242: LIST
81243: LIST
81244: LIST
81245: LIST
81246: LIST
81247: LIST
81248: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
81249: LD_ADDR_VAR 0 31
81253: PUSH
81254: LD_INT 0
81256: PUSH
81257: LD_INT 4
81259: PUSH
81260: EMPTY
81261: LIST
81262: LIST
81263: PUSH
81264: LD_INT 0
81266: PUSH
81267: LD_INT 3
81269: PUSH
81270: EMPTY
81271: LIST
81272: LIST
81273: PUSH
81274: LD_INT 1
81276: PUSH
81277: LD_INT 4
81279: PUSH
81280: EMPTY
81281: LIST
81282: LIST
81283: PUSH
81284: LD_INT 1
81286: PUSH
81287: LD_INT 5
81289: PUSH
81290: EMPTY
81291: LIST
81292: LIST
81293: PUSH
81294: LD_INT 0
81296: PUSH
81297: LD_INT 5
81299: PUSH
81300: EMPTY
81301: LIST
81302: LIST
81303: PUSH
81304: LD_INT 1
81306: NEG
81307: PUSH
81308: LD_INT 4
81310: PUSH
81311: EMPTY
81312: LIST
81313: LIST
81314: PUSH
81315: LD_INT 1
81317: NEG
81318: PUSH
81319: LD_INT 3
81321: PUSH
81322: EMPTY
81323: LIST
81324: LIST
81325: PUSH
81326: LD_INT 2
81328: PUSH
81329: LD_INT 5
81331: PUSH
81332: EMPTY
81333: LIST
81334: LIST
81335: PUSH
81336: LD_INT 2
81338: NEG
81339: PUSH
81340: LD_INT 3
81342: PUSH
81343: EMPTY
81344: LIST
81345: LIST
81346: PUSH
81347: LD_INT 3
81349: NEG
81350: PUSH
81351: LD_INT 0
81353: PUSH
81354: EMPTY
81355: LIST
81356: LIST
81357: PUSH
81358: LD_INT 3
81360: NEG
81361: PUSH
81362: LD_INT 1
81364: NEG
81365: PUSH
81366: EMPTY
81367: LIST
81368: LIST
81369: PUSH
81370: LD_INT 2
81372: NEG
81373: PUSH
81374: LD_INT 0
81376: PUSH
81377: EMPTY
81378: LIST
81379: LIST
81380: PUSH
81381: LD_INT 2
81383: NEG
81384: PUSH
81385: LD_INT 1
81387: PUSH
81388: EMPTY
81389: LIST
81390: LIST
81391: PUSH
81392: LD_INT 3
81394: NEG
81395: PUSH
81396: LD_INT 1
81398: PUSH
81399: EMPTY
81400: LIST
81401: LIST
81402: PUSH
81403: LD_INT 4
81405: NEG
81406: PUSH
81407: LD_INT 0
81409: PUSH
81410: EMPTY
81411: LIST
81412: LIST
81413: PUSH
81414: LD_INT 4
81416: NEG
81417: PUSH
81418: LD_INT 1
81420: NEG
81421: PUSH
81422: EMPTY
81423: LIST
81424: LIST
81425: PUSH
81426: LD_INT 4
81428: NEG
81429: PUSH
81430: LD_INT 2
81432: NEG
81433: PUSH
81434: EMPTY
81435: LIST
81436: LIST
81437: PUSH
81438: LD_INT 2
81440: NEG
81441: PUSH
81442: LD_INT 2
81444: PUSH
81445: EMPTY
81446: LIST
81447: LIST
81448: PUSH
81449: LD_INT 4
81451: NEG
81452: PUSH
81453: LD_INT 4
81455: NEG
81456: PUSH
81457: EMPTY
81458: LIST
81459: LIST
81460: PUSH
81461: LD_INT 4
81463: NEG
81464: PUSH
81465: LD_INT 5
81467: NEG
81468: PUSH
81469: EMPTY
81470: LIST
81471: LIST
81472: PUSH
81473: LD_INT 3
81475: NEG
81476: PUSH
81477: LD_INT 4
81479: NEG
81480: PUSH
81481: EMPTY
81482: LIST
81483: LIST
81484: PUSH
81485: LD_INT 3
81487: NEG
81488: PUSH
81489: LD_INT 3
81491: NEG
81492: PUSH
81493: EMPTY
81494: LIST
81495: LIST
81496: PUSH
81497: LD_INT 4
81499: NEG
81500: PUSH
81501: LD_INT 3
81503: NEG
81504: PUSH
81505: EMPTY
81506: LIST
81507: LIST
81508: PUSH
81509: LD_INT 5
81511: NEG
81512: PUSH
81513: LD_INT 4
81515: NEG
81516: PUSH
81517: EMPTY
81518: LIST
81519: LIST
81520: PUSH
81521: LD_INT 5
81523: NEG
81524: PUSH
81525: LD_INT 5
81527: NEG
81528: PUSH
81529: EMPTY
81530: LIST
81531: LIST
81532: PUSH
81533: LD_INT 3
81535: NEG
81536: PUSH
81537: LD_INT 5
81539: NEG
81540: PUSH
81541: EMPTY
81542: LIST
81543: LIST
81544: PUSH
81545: LD_INT 5
81547: NEG
81548: PUSH
81549: LD_INT 3
81551: NEG
81552: PUSH
81553: EMPTY
81554: LIST
81555: LIST
81556: PUSH
81557: LD_INT 0
81559: PUSH
81560: LD_INT 3
81562: NEG
81563: PUSH
81564: EMPTY
81565: LIST
81566: LIST
81567: PUSH
81568: LD_INT 0
81570: PUSH
81571: LD_INT 4
81573: NEG
81574: PUSH
81575: EMPTY
81576: LIST
81577: LIST
81578: PUSH
81579: LD_INT 1
81581: PUSH
81582: LD_INT 3
81584: NEG
81585: PUSH
81586: EMPTY
81587: LIST
81588: LIST
81589: PUSH
81590: LD_INT 1
81592: PUSH
81593: LD_INT 2
81595: NEG
81596: PUSH
81597: EMPTY
81598: LIST
81599: LIST
81600: PUSH
81601: LD_INT 0
81603: PUSH
81604: LD_INT 2
81606: NEG
81607: PUSH
81608: EMPTY
81609: LIST
81610: LIST
81611: PUSH
81612: LD_INT 1
81614: NEG
81615: PUSH
81616: LD_INT 3
81618: NEG
81619: PUSH
81620: EMPTY
81621: LIST
81622: LIST
81623: PUSH
81624: LD_INT 1
81626: NEG
81627: PUSH
81628: LD_INT 4
81630: NEG
81631: PUSH
81632: EMPTY
81633: LIST
81634: LIST
81635: PUSH
81636: LD_INT 2
81638: PUSH
81639: LD_INT 2
81641: NEG
81642: PUSH
81643: EMPTY
81644: LIST
81645: LIST
81646: PUSH
81647: LD_INT 2
81649: NEG
81650: PUSH
81651: LD_INT 4
81653: NEG
81654: PUSH
81655: EMPTY
81656: LIST
81657: LIST
81658: PUSH
81659: LD_INT 4
81661: PUSH
81662: LD_INT 0
81664: PUSH
81665: EMPTY
81666: LIST
81667: LIST
81668: PUSH
81669: LD_INT 4
81671: PUSH
81672: LD_INT 1
81674: NEG
81675: PUSH
81676: EMPTY
81677: LIST
81678: LIST
81679: PUSH
81680: LD_INT 5
81682: PUSH
81683: LD_INT 0
81685: PUSH
81686: EMPTY
81687: LIST
81688: LIST
81689: PUSH
81690: LD_INT 5
81692: PUSH
81693: LD_INT 1
81695: PUSH
81696: EMPTY
81697: LIST
81698: LIST
81699: PUSH
81700: LD_INT 4
81702: PUSH
81703: LD_INT 1
81705: PUSH
81706: EMPTY
81707: LIST
81708: LIST
81709: PUSH
81710: LD_INT 3
81712: PUSH
81713: LD_INT 0
81715: PUSH
81716: EMPTY
81717: LIST
81718: LIST
81719: PUSH
81720: LD_INT 3
81722: PUSH
81723: LD_INT 1
81725: NEG
81726: PUSH
81727: EMPTY
81728: LIST
81729: LIST
81730: PUSH
81731: LD_INT 3
81733: PUSH
81734: LD_INT 2
81736: NEG
81737: PUSH
81738: EMPTY
81739: LIST
81740: LIST
81741: PUSH
81742: LD_INT 5
81744: PUSH
81745: LD_INT 2
81747: PUSH
81748: EMPTY
81749: LIST
81750: LIST
81751: PUSH
81752: EMPTY
81753: LIST
81754: LIST
81755: LIST
81756: LIST
81757: LIST
81758: LIST
81759: LIST
81760: LIST
81761: LIST
81762: LIST
81763: LIST
81764: LIST
81765: LIST
81766: LIST
81767: LIST
81768: LIST
81769: LIST
81770: LIST
81771: LIST
81772: LIST
81773: LIST
81774: LIST
81775: LIST
81776: LIST
81777: LIST
81778: LIST
81779: LIST
81780: LIST
81781: LIST
81782: LIST
81783: LIST
81784: LIST
81785: LIST
81786: LIST
81787: LIST
81788: LIST
81789: LIST
81790: LIST
81791: LIST
81792: LIST
81793: LIST
81794: LIST
81795: LIST
81796: LIST
81797: LIST
81798: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
81799: LD_ADDR_VAR 0 32
81803: PUSH
81804: LD_INT 4
81806: NEG
81807: PUSH
81808: LD_INT 0
81810: PUSH
81811: EMPTY
81812: LIST
81813: LIST
81814: PUSH
81815: LD_INT 4
81817: NEG
81818: PUSH
81819: LD_INT 1
81821: NEG
81822: PUSH
81823: EMPTY
81824: LIST
81825: LIST
81826: PUSH
81827: LD_INT 3
81829: NEG
81830: PUSH
81831: LD_INT 0
81833: PUSH
81834: EMPTY
81835: LIST
81836: LIST
81837: PUSH
81838: LD_INT 3
81840: NEG
81841: PUSH
81842: LD_INT 1
81844: PUSH
81845: EMPTY
81846: LIST
81847: LIST
81848: PUSH
81849: LD_INT 4
81851: NEG
81852: PUSH
81853: LD_INT 1
81855: PUSH
81856: EMPTY
81857: LIST
81858: LIST
81859: PUSH
81860: LD_INT 5
81862: NEG
81863: PUSH
81864: LD_INT 0
81866: PUSH
81867: EMPTY
81868: LIST
81869: LIST
81870: PUSH
81871: LD_INT 5
81873: NEG
81874: PUSH
81875: LD_INT 1
81877: NEG
81878: PUSH
81879: EMPTY
81880: LIST
81881: LIST
81882: PUSH
81883: LD_INT 5
81885: NEG
81886: PUSH
81887: LD_INT 2
81889: NEG
81890: PUSH
81891: EMPTY
81892: LIST
81893: LIST
81894: PUSH
81895: LD_INT 3
81897: NEG
81898: PUSH
81899: LD_INT 2
81901: PUSH
81902: EMPTY
81903: LIST
81904: LIST
81905: PUSH
81906: LD_INT 3
81908: NEG
81909: PUSH
81910: LD_INT 3
81912: NEG
81913: PUSH
81914: EMPTY
81915: LIST
81916: LIST
81917: PUSH
81918: LD_INT 3
81920: NEG
81921: PUSH
81922: LD_INT 4
81924: NEG
81925: PUSH
81926: EMPTY
81927: LIST
81928: LIST
81929: PUSH
81930: LD_INT 2
81932: NEG
81933: PUSH
81934: LD_INT 3
81936: NEG
81937: PUSH
81938: EMPTY
81939: LIST
81940: LIST
81941: PUSH
81942: LD_INT 2
81944: NEG
81945: PUSH
81946: LD_INT 2
81948: NEG
81949: PUSH
81950: EMPTY
81951: LIST
81952: LIST
81953: PUSH
81954: LD_INT 3
81956: NEG
81957: PUSH
81958: LD_INT 2
81960: NEG
81961: PUSH
81962: EMPTY
81963: LIST
81964: LIST
81965: PUSH
81966: LD_INT 4
81968: NEG
81969: PUSH
81970: LD_INT 3
81972: NEG
81973: PUSH
81974: EMPTY
81975: LIST
81976: LIST
81977: PUSH
81978: LD_INT 4
81980: NEG
81981: PUSH
81982: LD_INT 4
81984: NEG
81985: PUSH
81986: EMPTY
81987: LIST
81988: LIST
81989: PUSH
81990: LD_INT 2
81992: NEG
81993: PUSH
81994: LD_INT 4
81996: NEG
81997: PUSH
81998: EMPTY
81999: LIST
82000: LIST
82001: PUSH
82002: LD_INT 4
82004: NEG
82005: PUSH
82006: LD_INT 2
82008: NEG
82009: PUSH
82010: EMPTY
82011: LIST
82012: LIST
82013: PUSH
82014: LD_INT 0
82016: PUSH
82017: LD_INT 4
82019: NEG
82020: PUSH
82021: EMPTY
82022: LIST
82023: LIST
82024: PUSH
82025: LD_INT 0
82027: PUSH
82028: LD_INT 5
82030: NEG
82031: PUSH
82032: EMPTY
82033: LIST
82034: LIST
82035: PUSH
82036: LD_INT 1
82038: PUSH
82039: LD_INT 4
82041: NEG
82042: PUSH
82043: EMPTY
82044: LIST
82045: LIST
82046: PUSH
82047: LD_INT 1
82049: PUSH
82050: LD_INT 3
82052: NEG
82053: PUSH
82054: EMPTY
82055: LIST
82056: LIST
82057: PUSH
82058: LD_INT 0
82060: PUSH
82061: LD_INT 3
82063: NEG
82064: PUSH
82065: EMPTY
82066: LIST
82067: LIST
82068: PUSH
82069: LD_INT 1
82071: NEG
82072: PUSH
82073: LD_INT 4
82075: NEG
82076: PUSH
82077: EMPTY
82078: LIST
82079: LIST
82080: PUSH
82081: LD_INT 1
82083: NEG
82084: PUSH
82085: LD_INT 5
82087: NEG
82088: PUSH
82089: EMPTY
82090: LIST
82091: LIST
82092: PUSH
82093: LD_INT 2
82095: PUSH
82096: LD_INT 3
82098: NEG
82099: PUSH
82100: EMPTY
82101: LIST
82102: LIST
82103: PUSH
82104: LD_INT 2
82106: NEG
82107: PUSH
82108: LD_INT 5
82110: NEG
82111: PUSH
82112: EMPTY
82113: LIST
82114: LIST
82115: PUSH
82116: LD_INT 3
82118: PUSH
82119: LD_INT 0
82121: PUSH
82122: EMPTY
82123: LIST
82124: LIST
82125: PUSH
82126: LD_INT 3
82128: PUSH
82129: LD_INT 1
82131: NEG
82132: PUSH
82133: EMPTY
82134: LIST
82135: LIST
82136: PUSH
82137: LD_INT 4
82139: PUSH
82140: LD_INT 0
82142: PUSH
82143: EMPTY
82144: LIST
82145: LIST
82146: PUSH
82147: LD_INT 4
82149: PUSH
82150: LD_INT 1
82152: PUSH
82153: EMPTY
82154: LIST
82155: LIST
82156: PUSH
82157: LD_INT 3
82159: PUSH
82160: LD_INT 1
82162: PUSH
82163: EMPTY
82164: LIST
82165: LIST
82166: PUSH
82167: LD_INT 2
82169: PUSH
82170: LD_INT 0
82172: PUSH
82173: EMPTY
82174: LIST
82175: LIST
82176: PUSH
82177: LD_INT 2
82179: PUSH
82180: LD_INT 1
82182: NEG
82183: PUSH
82184: EMPTY
82185: LIST
82186: LIST
82187: PUSH
82188: LD_INT 2
82190: PUSH
82191: LD_INT 2
82193: NEG
82194: PUSH
82195: EMPTY
82196: LIST
82197: LIST
82198: PUSH
82199: LD_INT 4
82201: PUSH
82202: LD_INT 2
82204: PUSH
82205: EMPTY
82206: LIST
82207: LIST
82208: PUSH
82209: LD_INT 4
82211: PUSH
82212: LD_INT 4
82214: PUSH
82215: EMPTY
82216: LIST
82217: LIST
82218: PUSH
82219: LD_INT 4
82221: PUSH
82222: LD_INT 3
82224: PUSH
82225: EMPTY
82226: LIST
82227: LIST
82228: PUSH
82229: LD_INT 5
82231: PUSH
82232: LD_INT 4
82234: PUSH
82235: EMPTY
82236: LIST
82237: LIST
82238: PUSH
82239: LD_INT 5
82241: PUSH
82242: LD_INT 5
82244: PUSH
82245: EMPTY
82246: LIST
82247: LIST
82248: PUSH
82249: LD_INT 4
82251: PUSH
82252: LD_INT 5
82254: PUSH
82255: EMPTY
82256: LIST
82257: LIST
82258: PUSH
82259: LD_INT 3
82261: PUSH
82262: LD_INT 4
82264: PUSH
82265: EMPTY
82266: LIST
82267: LIST
82268: PUSH
82269: LD_INT 3
82271: PUSH
82272: LD_INT 3
82274: PUSH
82275: EMPTY
82276: LIST
82277: LIST
82278: PUSH
82279: LD_INT 5
82281: PUSH
82282: LD_INT 3
82284: PUSH
82285: EMPTY
82286: LIST
82287: LIST
82288: PUSH
82289: LD_INT 3
82291: PUSH
82292: LD_INT 5
82294: PUSH
82295: EMPTY
82296: LIST
82297: LIST
82298: PUSH
82299: EMPTY
82300: LIST
82301: LIST
82302: LIST
82303: LIST
82304: LIST
82305: LIST
82306: LIST
82307: LIST
82308: LIST
82309: LIST
82310: LIST
82311: LIST
82312: LIST
82313: LIST
82314: LIST
82315: LIST
82316: LIST
82317: LIST
82318: LIST
82319: LIST
82320: LIST
82321: LIST
82322: LIST
82323: LIST
82324: LIST
82325: LIST
82326: LIST
82327: LIST
82328: LIST
82329: LIST
82330: LIST
82331: LIST
82332: LIST
82333: LIST
82334: LIST
82335: LIST
82336: LIST
82337: LIST
82338: LIST
82339: LIST
82340: LIST
82341: LIST
82342: LIST
82343: LIST
82344: LIST
82345: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
82346: LD_ADDR_VAR 0 33
82350: PUSH
82351: LD_INT 4
82353: NEG
82354: PUSH
82355: LD_INT 4
82357: NEG
82358: PUSH
82359: EMPTY
82360: LIST
82361: LIST
82362: PUSH
82363: LD_INT 4
82365: NEG
82366: PUSH
82367: LD_INT 5
82369: NEG
82370: PUSH
82371: EMPTY
82372: LIST
82373: LIST
82374: PUSH
82375: LD_INT 3
82377: NEG
82378: PUSH
82379: LD_INT 4
82381: NEG
82382: PUSH
82383: EMPTY
82384: LIST
82385: LIST
82386: PUSH
82387: LD_INT 3
82389: NEG
82390: PUSH
82391: LD_INT 3
82393: NEG
82394: PUSH
82395: EMPTY
82396: LIST
82397: LIST
82398: PUSH
82399: LD_INT 4
82401: NEG
82402: PUSH
82403: LD_INT 3
82405: NEG
82406: PUSH
82407: EMPTY
82408: LIST
82409: LIST
82410: PUSH
82411: LD_INT 5
82413: NEG
82414: PUSH
82415: LD_INT 4
82417: NEG
82418: PUSH
82419: EMPTY
82420: LIST
82421: LIST
82422: PUSH
82423: LD_INT 5
82425: NEG
82426: PUSH
82427: LD_INT 5
82429: NEG
82430: PUSH
82431: EMPTY
82432: LIST
82433: LIST
82434: PUSH
82435: LD_INT 3
82437: NEG
82438: PUSH
82439: LD_INT 5
82441: NEG
82442: PUSH
82443: EMPTY
82444: LIST
82445: LIST
82446: PUSH
82447: LD_INT 5
82449: NEG
82450: PUSH
82451: LD_INT 3
82453: NEG
82454: PUSH
82455: EMPTY
82456: LIST
82457: LIST
82458: PUSH
82459: LD_INT 0
82461: PUSH
82462: LD_INT 3
82464: NEG
82465: PUSH
82466: EMPTY
82467: LIST
82468: LIST
82469: PUSH
82470: LD_INT 0
82472: PUSH
82473: LD_INT 4
82475: NEG
82476: PUSH
82477: EMPTY
82478: LIST
82479: LIST
82480: PUSH
82481: LD_INT 1
82483: PUSH
82484: LD_INT 3
82486: NEG
82487: PUSH
82488: EMPTY
82489: LIST
82490: LIST
82491: PUSH
82492: LD_INT 1
82494: PUSH
82495: LD_INT 2
82497: NEG
82498: PUSH
82499: EMPTY
82500: LIST
82501: LIST
82502: PUSH
82503: LD_INT 0
82505: PUSH
82506: LD_INT 2
82508: NEG
82509: PUSH
82510: EMPTY
82511: LIST
82512: LIST
82513: PUSH
82514: LD_INT 1
82516: NEG
82517: PUSH
82518: LD_INT 3
82520: NEG
82521: PUSH
82522: EMPTY
82523: LIST
82524: LIST
82525: PUSH
82526: LD_INT 1
82528: NEG
82529: PUSH
82530: LD_INT 4
82532: NEG
82533: PUSH
82534: EMPTY
82535: LIST
82536: LIST
82537: PUSH
82538: LD_INT 2
82540: PUSH
82541: LD_INT 2
82543: NEG
82544: PUSH
82545: EMPTY
82546: LIST
82547: LIST
82548: PUSH
82549: LD_INT 2
82551: NEG
82552: PUSH
82553: LD_INT 4
82555: NEG
82556: PUSH
82557: EMPTY
82558: LIST
82559: LIST
82560: PUSH
82561: LD_INT 4
82563: PUSH
82564: LD_INT 0
82566: PUSH
82567: EMPTY
82568: LIST
82569: LIST
82570: PUSH
82571: LD_INT 4
82573: PUSH
82574: LD_INT 1
82576: NEG
82577: PUSH
82578: EMPTY
82579: LIST
82580: LIST
82581: PUSH
82582: LD_INT 5
82584: PUSH
82585: LD_INT 0
82587: PUSH
82588: EMPTY
82589: LIST
82590: LIST
82591: PUSH
82592: LD_INT 5
82594: PUSH
82595: LD_INT 1
82597: PUSH
82598: EMPTY
82599: LIST
82600: LIST
82601: PUSH
82602: LD_INT 4
82604: PUSH
82605: LD_INT 1
82607: PUSH
82608: EMPTY
82609: LIST
82610: LIST
82611: PUSH
82612: LD_INT 3
82614: PUSH
82615: LD_INT 0
82617: PUSH
82618: EMPTY
82619: LIST
82620: LIST
82621: PUSH
82622: LD_INT 3
82624: PUSH
82625: LD_INT 1
82627: NEG
82628: PUSH
82629: EMPTY
82630: LIST
82631: LIST
82632: PUSH
82633: LD_INT 3
82635: PUSH
82636: LD_INT 2
82638: NEG
82639: PUSH
82640: EMPTY
82641: LIST
82642: LIST
82643: PUSH
82644: LD_INT 5
82646: PUSH
82647: LD_INT 2
82649: PUSH
82650: EMPTY
82651: LIST
82652: LIST
82653: PUSH
82654: LD_INT 3
82656: PUSH
82657: LD_INT 3
82659: PUSH
82660: EMPTY
82661: LIST
82662: LIST
82663: PUSH
82664: LD_INT 3
82666: PUSH
82667: LD_INT 2
82669: PUSH
82670: EMPTY
82671: LIST
82672: LIST
82673: PUSH
82674: LD_INT 4
82676: PUSH
82677: LD_INT 3
82679: PUSH
82680: EMPTY
82681: LIST
82682: LIST
82683: PUSH
82684: LD_INT 4
82686: PUSH
82687: LD_INT 4
82689: PUSH
82690: EMPTY
82691: LIST
82692: LIST
82693: PUSH
82694: LD_INT 3
82696: PUSH
82697: LD_INT 4
82699: PUSH
82700: EMPTY
82701: LIST
82702: LIST
82703: PUSH
82704: LD_INT 2
82706: PUSH
82707: LD_INT 3
82709: PUSH
82710: EMPTY
82711: LIST
82712: LIST
82713: PUSH
82714: LD_INT 2
82716: PUSH
82717: LD_INT 2
82719: PUSH
82720: EMPTY
82721: LIST
82722: LIST
82723: PUSH
82724: LD_INT 4
82726: PUSH
82727: LD_INT 2
82729: PUSH
82730: EMPTY
82731: LIST
82732: LIST
82733: PUSH
82734: LD_INT 2
82736: PUSH
82737: LD_INT 4
82739: PUSH
82740: EMPTY
82741: LIST
82742: LIST
82743: PUSH
82744: LD_INT 0
82746: PUSH
82747: LD_INT 4
82749: PUSH
82750: EMPTY
82751: LIST
82752: LIST
82753: PUSH
82754: LD_INT 0
82756: PUSH
82757: LD_INT 3
82759: PUSH
82760: EMPTY
82761: LIST
82762: LIST
82763: PUSH
82764: LD_INT 1
82766: PUSH
82767: LD_INT 4
82769: PUSH
82770: EMPTY
82771: LIST
82772: LIST
82773: PUSH
82774: LD_INT 1
82776: PUSH
82777: LD_INT 5
82779: PUSH
82780: EMPTY
82781: LIST
82782: LIST
82783: PUSH
82784: LD_INT 0
82786: PUSH
82787: LD_INT 5
82789: PUSH
82790: EMPTY
82791: LIST
82792: LIST
82793: PUSH
82794: LD_INT 1
82796: NEG
82797: PUSH
82798: LD_INT 4
82800: PUSH
82801: EMPTY
82802: LIST
82803: LIST
82804: PUSH
82805: LD_INT 1
82807: NEG
82808: PUSH
82809: LD_INT 3
82811: PUSH
82812: EMPTY
82813: LIST
82814: LIST
82815: PUSH
82816: LD_INT 2
82818: PUSH
82819: LD_INT 5
82821: PUSH
82822: EMPTY
82823: LIST
82824: LIST
82825: PUSH
82826: LD_INT 2
82828: NEG
82829: PUSH
82830: LD_INT 3
82832: PUSH
82833: EMPTY
82834: LIST
82835: LIST
82836: PUSH
82837: EMPTY
82838: LIST
82839: LIST
82840: LIST
82841: LIST
82842: LIST
82843: LIST
82844: LIST
82845: LIST
82846: LIST
82847: LIST
82848: LIST
82849: LIST
82850: LIST
82851: LIST
82852: LIST
82853: LIST
82854: LIST
82855: LIST
82856: LIST
82857: LIST
82858: LIST
82859: LIST
82860: LIST
82861: LIST
82862: LIST
82863: LIST
82864: LIST
82865: LIST
82866: LIST
82867: LIST
82868: LIST
82869: LIST
82870: LIST
82871: LIST
82872: LIST
82873: LIST
82874: LIST
82875: LIST
82876: LIST
82877: LIST
82878: LIST
82879: LIST
82880: LIST
82881: LIST
82882: LIST
82883: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
82884: LD_ADDR_VAR 0 34
82888: PUSH
82889: LD_INT 0
82891: PUSH
82892: LD_INT 4
82894: NEG
82895: PUSH
82896: EMPTY
82897: LIST
82898: LIST
82899: PUSH
82900: LD_INT 0
82902: PUSH
82903: LD_INT 5
82905: NEG
82906: PUSH
82907: EMPTY
82908: LIST
82909: LIST
82910: PUSH
82911: LD_INT 1
82913: PUSH
82914: LD_INT 4
82916: NEG
82917: PUSH
82918: EMPTY
82919: LIST
82920: LIST
82921: PUSH
82922: LD_INT 1
82924: PUSH
82925: LD_INT 3
82927: NEG
82928: PUSH
82929: EMPTY
82930: LIST
82931: LIST
82932: PUSH
82933: LD_INT 0
82935: PUSH
82936: LD_INT 3
82938: NEG
82939: PUSH
82940: EMPTY
82941: LIST
82942: LIST
82943: PUSH
82944: LD_INT 1
82946: NEG
82947: PUSH
82948: LD_INT 4
82950: NEG
82951: PUSH
82952: EMPTY
82953: LIST
82954: LIST
82955: PUSH
82956: LD_INT 1
82958: NEG
82959: PUSH
82960: LD_INT 5
82962: NEG
82963: PUSH
82964: EMPTY
82965: LIST
82966: LIST
82967: PUSH
82968: LD_INT 2
82970: PUSH
82971: LD_INT 3
82973: NEG
82974: PUSH
82975: EMPTY
82976: LIST
82977: LIST
82978: PUSH
82979: LD_INT 2
82981: NEG
82982: PUSH
82983: LD_INT 5
82985: NEG
82986: PUSH
82987: EMPTY
82988: LIST
82989: LIST
82990: PUSH
82991: LD_INT 3
82993: PUSH
82994: LD_INT 0
82996: PUSH
82997: EMPTY
82998: LIST
82999: LIST
83000: PUSH
83001: LD_INT 3
83003: PUSH
83004: LD_INT 1
83006: NEG
83007: PUSH
83008: EMPTY
83009: LIST
83010: LIST
83011: PUSH
83012: LD_INT 4
83014: PUSH
83015: LD_INT 0
83017: PUSH
83018: EMPTY
83019: LIST
83020: LIST
83021: PUSH
83022: LD_INT 4
83024: PUSH
83025: LD_INT 1
83027: PUSH
83028: EMPTY
83029: LIST
83030: LIST
83031: PUSH
83032: LD_INT 3
83034: PUSH
83035: LD_INT 1
83037: PUSH
83038: EMPTY
83039: LIST
83040: LIST
83041: PUSH
83042: LD_INT 2
83044: PUSH
83045: LD_INT 0
83047: PUSH
83048: EMPTY
83049: LIST
83050: LIST
83051: PUSH
83052: LD_INT 2
83054: PUSH
83055: LD_INT 1
83057: NEG
83058: PUSH
83059: EMPTY
83060: LIST
83061: LIST
83062: PUSH
83063: LD_INT 2
83065: PUSH
83066: LD_INT 2
83068: NEG
83069: PUSH
83070: EMPTY
83071: LIST
83072: LIST
83073: PUSH
83074: LD_INT 4
83076: PUSH
83077: LD_INT 2
83079: PUSH
83080: EMPTY
83081: LIST
83082: LIST
83083: PUSH
83084: LD_INT 4
83086: PUSH
83087: LD_INT 4
83089: PUSH
83090: EMPTY
83091: LIST
83092: LIST
83093: PUSH
83094: LD_INT 4
83096: PUSH
83097: LD_INT 3
83099: PUSH
83100: EMPTY
83101: LIST
83102: LIST
83103: PUSH
83104: LD_INT 5
83106: PUSH
83107: LD_INT 4
83109: PUSH
83110: EMPTY
83111: LIST
83112: LIST
83113: PUSH
83114: LD_INT 5
83116: PUSH
83117: LD_INT 5
83119: PUSH
83120: EMPTY
83121: LIST
83122: LIST
83123: PUSH
83124: LD_INT 4
83126: PUSH
83127: LD_INT 5
83129: PUSH
83130: EMPTY
83131: LIST
83132: LIST
83133: PUSH
83134: LD_INT 3
83136: PUSH
83137: LD_INT 4
83139: PUSH
83140: EMPTY
83141: LIST
83142: LIST
83143: PUSH
83144: LD_INT 3
83146: PUSH
83147: LD_INT 3
83149: PUSH
83150: EMPTY
83151: LIST
83152: LIST
83153: PUSH
83154: LD_INT 5
83156: PUSH
83157: LD_INT 3
83159: PUSH
83160: EMPTY
83161: LIST
83162: LIST
83163: PUSH
83164: LD_INT 3
83166: PUSH
83167: LD_INT 5
83169: PUSH
83170: EMPTY
83171: LIST
83172: LIST
83173: PUSH
83174: LD_INT 0
83176: PUSH
83177: LD_INT 3
83179: PUSH
83180: EMPTY
83181: LIST
83182: LIST
83183: PUSH
83184: LD_INT 0
83186: PUSH
83187: LD_INT 2
83189: PUSH
83190: EMPTY
83191: LIST
83192: LIST
83193: PUSH
83194: LD_INT 1
83196: PUSH
83197: LD_INT 3
83199: PUSH
83200: EMPTY
83201: LIST
83202: LIST
83203: PUSH
83204: LD_INT 1
83206: PUSH
83207: LD_INT 4
83209: PUSH
83210: EMPTY
83211: LIST
83212: LIST
83213: PUSH
83214: LD_INT 0
83216: PUSH
83217: LD_INT 4
83219: PUSH
83220: EMPTY
83221: LIST
83222: LIST
83223: PUSH
83224: LD_INT 1
83226: NEG
83227: PUSH
83228: LD_INT 3
83230: PUSH
83231: EMPTY
83232: LIST
83233: LIST
83234: PUSH
83235: LD_INT 1
83237: NEG
83238: PUSH
83239: LD_INT 2
83241: PUSH
83242: EMPTY
83243: LIST
83244: LIST
83245: PUSH
83246: LD_INT 2
83248: PUSH
83249: LD_INT 4
83251: PUSH
83252: EMPTY
83253: LIST
83254: LIST
83255: PUSH
83256: LD_INT 2
83258: NEG
83259: PUSH
83260: LD_INT 2
83262: PUSH
83263: EMPTY
83264: LIST
83265: LIST
83266: PUSH
83267: LD_INT 4
83269: NEG
83270: PUSH
83271: LD_INT 0
83273: PUSH
83274: EMPTY
83275: LIST
83276: LIST
83277: PUSH
83278: LD_INT 4
83280: NEG
83281: PUSH
83282: LD_INT 1
83284: NEG
83285: PUSH
83286: EMPTY
83287: LIST
83288: LIST
83289: PUSH
83290: LD_INT 3
83292: NEG
83293: PUSH
83294: LD_INT 0
83296: PUSH
83297: EMPTY
83298: LIST
83299: LIST
83300: PUSH
83301: LD_INT 3
83303: NEG
83304: PUSH
83305: LD_INT 1
83307: PUSH
83308: EMPTY
83309: LIST
83310: LIST
83311: PUSH
83312: LD_INT 4
83314: NEG
83315: PUSH
83316: LD_INT 1
83318: PUSH
83319: EMPTY
83320: LIST
83321: LIST
83322: PUSH
83323: LD_INT 5
83325: NEG
83326: PUSH
83327: LD_INT 0
83329: PUSH
83330: EMPTY
83331: LIST
83332: LIST
83333: PUSH
83334: LD_INT 5
83336: NEG
83337: PUSH
83338: LD_INT 1
83340: NEG
83341: PUSH
83342: EMPTY
83343: LIST
83344: LIST
83345: PUSH
83346: LD_INT 5
83348: NEG
83349: PUSH
83350: LD_INT 2
83352: NEG
83353: PUSH
83354: EMPTY
83355: LIST
83356: LIST
83357: PUSH
83358: LD_INT 3
83360: NEG
83361: PUSH
83362: LD_INT 2
83364: PUSH
83365: EMPTY
83366: LIST
83367: LIST
83368: PUSH
83369: EMPTY
83370: LIST
83371: LIST
83372: LIST
83373: LIST
83374: LIST
83375: LIST
83376: LIST
83377: LIST
83378: LIST
83379: LIST
83380: LIST
83381: LIST
83382: LIST
83383: LIST
83384: LIST
83385: LIST
83386: LIST
83387: LIST
83388: LIST
83389: LIST
83390: LIST
83391: LIST
83392: LIST
83393: LIST
83394: LIST
83395: LIST
83396: LIST
83397: LIST
83398: LIST
83399: LIST
83400: LIST
83401: LIST
83402: LIST
83403: LIST
83404: LIST
83405: LIST
83406: LIST
83407: LIST
83408: LIST
83409: LIST
83410: LIST
83411: LIST
83412: LIST
83413: LIST
83414: LIST
83415: ST_TO_ADDR
// end ; end ;
83416: GO 83419
83418: POP
// case btype of b_depot , b_warehouse :
83419: LD_VAR 0 1
83423: PUSH
83424: LD_INT 0
83426: DOUBLE
83427: EQUAL
83428: IFTRUE 83438
83430: LD_INT 1
83432: DOUBLE
83433: EQUAL
83434: IFTRUE 83438
83436: GO 83639
83438: POP
// case nation of nation_american :
83439: LD_VAR 0 5
83443: PUSH
83444: LD_INT 1
83446: DOUBLE
83447: EQUAL
83448: IFTRUE 83452
83450: GO 83508
83452: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
83453: LD_ADDR_VAR 0 9
83457: PUSH
83458: LD_VAR 0 11
83462: PUSH
83463: LD_VAR 0 12
83467: PUSH
83468: LD_VAR 0 13
83472: PUSH
83473: LD_VAR 0 14
83477: PUSH
83478: LD_VAR 0 15
83482: PUSH
83483: LD_VAR 0 16
83487: PUSH
83488: EMPTY
83489: LIST
83490: LIST
83491: LIST
83492: LIST
83493: LIST
83494: LIST
83495: PUSH
83496: LD_VAR 0 4
83500: PUSH
83501: LD_INT 1
83503: PLUS
83504: ARRAY
83505: ST_TO_ADDR
83506: GO 83637
83508: LD_INT 2
83510: DOUBLE
83511: EQUAL
83512: IFTRUE 83516
83514: GO 83572
83516: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
83517: LD_ADDR_VAR 0 9
83521: PUSH
83522: LD_VAR 0 17
83526: PUSH
83527: LD_VAR 0 18
83531: PUSH
83532: LD_VAR 0 19
83536: PUSH
83537: LD_VAR 0 20
83541: PUSH
83542: LD_VAR 0 21
83546: PUSH
83547: LD_VAR 0 22
83551: PUSH
83552: EMPTY
83553: LIST
83554: LIST
83555: LIST
83556: LIST
83557: LIST
83558: LIST
83559: PUSH
83560: LD_VAR 0 4
83564: PUSH
83565: LD_INT 1
83567: PLUS
83568: ARRAY
83569: ST_TO_ADDR
83570: GO 83637
83572: LD_INT 3
83574: DOUBLE
83575: EQUAL
83576: IFTRUE 83580
83578: GO 83636
83580: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
83581: LD_ADDR_VAR 0 9
83585: PUSH
83586: LD_VAR 0 23
83590: PUSH
83591: LD_VAR 0 24
83595: PUSH
83596: LD_VAR 0 25
83600: PUSH
83601: LD_VAR 0 26
83605: PUSH
83606: LD_VAR 0 27
83610: PUSH
83611: LD_VAR 0 28
83615: PUSH
83616: EMPTY
83617: LIST
83618: LIST
83619: LIST
83620: LIST
83621: LIST
83622: LIST
83623: PUSH
83624: LD_VAR 0 4
83628: PUSH
83629: LD_INT 1
83631: PLUS
83632: ARRAY
83633: ST_TO_ADDR
83634: GO 83637
83636: POP
83637: GO 84192
83639: LD_INT 2
83641: DOUBLE
83642: EQUAL
83643: IFTRUE 83653
83645: LD_INT 3
83647: DOUBLE
83648: EQUAL
83649: IFTRUE 83653
83651: GO 83709
83653: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
83654: LD_ADDR_VAR 0 9
83658: PUSH
83659: LD_VAR 0 29
83663: PUSH
83664: LD_VAR 0 30
83668: PUSH
83669: LD_VAR 0 31
83673: PUSH
83674: LD_VAR 0 32
83678: PUSH
83679: LD_VAR 0 33
83683: PUSH
83684: LD_VAR 0 34
83688: PUSH
83689: EMPTY
83690: LIST
83691: LIST
83692: LIST
83693: LIST
83694: LIST
83695: LIST
83696: PUSH
83697: LD_VAR 0 4
83701: PUSH
83702: LD_INT 1
83704: PLUS
83705: ARRAY
83706: ST_TO_ADDR
83707: GO 84192
83709: LD_INT 16
83711: DOUBLE
83712: EQUAL
83713: IFTRUE 83771
83715: LD_INT 17
83717: DOUBLE
83718: EQUAL
83719: IFTRUE 83771
83721: LD_INT 18
83723: DOUBLE
83724: EQUAL
83725: IFTRUE 83771
83727: LD_INT 19
83729: DOUBLE
83730: EQUAL
83731: IFTRUE 83771
83733: LD_INT 22
83735: DOUBLE
83736: EQUAL
83737: IFTRUE 83771
83739: LD_INT 20
83741: DOUBLE
83742: EQUAL
83743: IFTRUE 83771
83745: LD_INT 21
83747: DOUBLE
83748: EQUAL
83749: IFTRUE 83771
83751: LD_INT 23
83753: DOUBLE
83754: EQUAL
83755: IFTRUE 83771
83757: LD_INT 24
83759: DOUBLE
83760: EQUAL
83761: IFTRUE 83771
83763: LD_INT 25
83765: DOUBLE
83766: EQUAL
83767: IFTRUE 83771
83769: GO 83827
83771: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
83772: LD_ADDR_VAR 0 9
83776: PUSH
83777: LD_VAR 0 35
83781: PUSH
83782: LD_VAR 0 36
83786: PUSH
83787: LD_VAR 0 37
83791: PUSH
83792: LD_VAR 0 38
83796: PUSH
83797: LD_VAR 0 39
83801: PUSH
83802: LD_VAR 0 40
83806: PUSH
83807: EMPTY
83808: LIST
83809: LIST
83810: LIST
83811: LIST
83812: LIST
83813: LIST
83814: PUSH
83815: LD_VAR 0 4
83819: PUSH
83820: LD_INT 1
83822: PLUS
83823: ARRAY
83824: ST_TO_ADDR
83825: GO 84192
83827: LD_INT 6
83829: DOUBLE
83830: EQUAL
83831: IFTRUE 83883
83833: LD_INT 7
83835: DOUBLE
83836: EQUAL
83837: IFTRUE 83883
83839: LD_INT 8
83841: DOUBLE
83842: EQUAL
83843: IFTRUE 83883
83845: LD_INT 13
83847: DOUBLE
83848: EQUAL
83849: IFTRUE 83883
83851: LD_INT 12
83853: DOUBLE
83854: EQUAL
83855: IFTRUE 83883
83857: LD_INT 15
83859: DOUBLE
83860: EQUAL
83861: IFTRUE 83883
83863: LD_INT 11
83865: DOUBLE
83866: EQUAL
83867: IFTRUE 83883
83869: LD_INT 14
83871: DOUBLE
83872: EQUAL
83873: IFTRUE 83883
83875: LD_INT 10
83877: DOUBLE
83878: EQUAL
83879: IFTRUE 83883
83881: GO 83939
83883: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
83884: LD_ADDR_VAR 0 9
83888: PUSH
83889: LD_VAR 0 41
83893: PUSH
83894: LD_VAR 0 42
83898: PUSH
83899: LD_VAR 0 43
83903: PUSH
83904: LD_VAR 0 44
83908: PUSH
83909: LD_VAR 0 45
83913: PUSH
83914: LD_VAR 0 46
83918: PUSH
83919: EMPTY
83920: LIST
83921: LIST
83922: LIST
83923: LIST
83924: LIST
83925: LIST
83926: PUSH
83927: LD_VAR 0 4
83931: PUSH
83932: LD_INT 1
83934: PLUS
83935: ARRAY
83936: ST_TO_ADDR
83937: GO 84192
83939: LD_INT 36
83941: DOUBLE
83942: EQUAL
83943: IFTRUE 83947
83945: GO 84003
83947: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
83948: LD_ADDR_VAR 0 9
83952: PUSH
83953: LD_VAR 0 47
83957: PUSH
83958: LD_VAR 0 48
83962: PUSH
83963: LD_VAR 0 49
83967: PUSH
83968: LD_VAR 0 50
83972: PUSH
83973: LD_VAR 0 51
83977: PUSH
83978: LD_VAR 0 52
83982: PUSH
83983: EMPTY
83984: LIST
83985: LIST
83986: LIST
83987: LIST
83988: LIST
83989: LIST
83990: PUSH
83991: LD_VAR 0 4
83995: PUSH
83996: LD_INT 1
83998: PLUS
83999: ARRAY
84000: ST_TO_ADDR
84001: GO 84192
84003: LD_INT 4
84005: DOUBLE
84006: EQUAL
84007: IFTRUE 84029
84009: LD_INT 5
84011: DOUBLE
84012: EQUAL
84013: IFTRUE 84029
84015: LD_INT 34
84017: DOUBLE
84018: EQUAL
84019: IFTRUE 84029
84021: LD_INT 37
84023: DOUBLE
84024: EQUAL
84025: IFTRUE 84029
84027: GO 84085
84029: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
84030: LD_ADDR_VAR 0 9
84034: PUSH
84035: LD_VAR 0 53
84039: PUSH
84040: LD_VAR 0 54
84044: PUSH
84045: LD_VAR 0 55
84049: PUSH
84050: LD_VAR 0 56
84054: PUSH
84055: LD_VAR 0 57
84059: PUSH
84060: LD_VAR 0 58
84064: PUSH
84065: EMPTY
84066: LIST
84067: LIST
84068: LIST
84069: LIST
84070: LIST
84071: LIST
84072: PUSH
84073: LD_VAR 0 4
84077: PUSH
84078: LD_INT 1
84080: PLUS
84081: ARRAY
84082: ST_TO_ADDR
84083: GO 84192
84085: LD_INT 31
84087: DOUBLE
84088: EQUAL
84089: IFTRUE 84135
84091: LD_INT 32
84093: DOUBLE
84094: EQUAL
84095: IFTRUE 84135
84097: LD_INT 33
84099: DOUBLE
84100: EQUAL
84101: IFTRUE 84135
84103: LD_INT 27
84105: DOUBLE
84106: EQUAL
84107: IFTRUE 84135
84109: LD_INT 26
84111: DOUBLE
84112: EQUAL
84113: IFTRUE 84135
84115: LD_INT 28
84117: DOUBLE
84118: EQUAL
84119: IFTRUE 84135
84121: LD_INT 29
84123: DOUBLE
84124: EQUAL
84125: IFTRUE 84135
84127: LD_INT 30
84129: DOUBLE
84130: EQUAL
84131: IFTRUE 84135
84133: GO 84191
84135: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
84136: LD_ADDR_VAR 0 9
84140: PUSH
84141: LD_VAR 0 59
84145: PUSH
84146: LD_VAR 0 60
84150: PUSH
84151: LD_VAR 0 61
84155: PUSH
84156: LD_VAR 0 62
84160: PUSH
84161: LD_VAR 0 63
84165: PUSH
84166: LD_VAR 0 64
84170: PUSH
84171: EMPTY
84172: LIST
84173: LIST
84174: LIST
84175: LIST
84176: LIST
84177: LIST
84178: PUSH
84179: LD_VAR 0 4
84183: PUSH
84184: LD_INT 1
84186: PLUS
84187: ARRAY
84188: ST_TO_ADDR
84189: GO 84192
84191: POP
// temp_list2 = [ ] ;
84192: LD_ADDR_VAR 0 10
84196: PUSH
84197: EMPTY
84198: ST_TO_ADDR
// for i in temp_list do
84199: LD_ADDR_VAR 0 8
84203: PUSH
84204: LD_VAR 0 9
84208: PUSH
84209: FOR_IN
84210: IFFALSE 84262
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
84212: LD_ADDR_VAR 0 10
84216: PUSH
84217: LD_VAR 0 10
84221: PUSH
84222: LD_VAR 0 8
84226: PUSH
84227: LD_INT 1
84229: ARRAY
84230: PUSH
84231: LD_VAR 0 2
84235: PLUS
84236: PUSH
84237: LD_VAR 0 8
84241: PUSH
84242: LD_INT 2
84244: ARRAY
84245: PUSH
84246: LD_VAR 0 3
84250: PLUS
84251: PUSH
84252: EMPTY
84253: LIST
84254: LIST
84255: PUSH
84256: EMPTY
84257: LIST
84258: ADD
84259: ST_TO_ADDR
84260: GO 84209
84262: POP
84263: POP
// result = temp_list2 ;
84264: LD_ADDR_VAR 0 7
84268: PUSH
84269: LD_VAR 0 10
84273: ST_TO_ADDR
// end ;
84274: LD_VAR 0 7
84278: RET
// export function EnemyInRange ( unit , dist ) ; begin
84279: LD_INT 0
84281: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
84282: LD_ADDR_VAR 0 3
84286: PUSH
84287: LD_VAR 0 1
84291: PPUSH
84292: CALL_OW 255
84296: PPUSH
84297: LD_VAR 0 1
84301: PPUSH
84302: CALL_OW 250
84306: PPUSH
84307: LD_VAR 0 1
84311: PPUSH
84312: CALL_OW 251
84316: PPUSH
84317: LD_VAR 0 2
84321: PPUSH
84322: CALL 58383 0 4
84326: PUSH
84327: LD_INT 4
84329: ARRAY
84330: ST_TO_ADDR
// end ;
84331: LD_VAR 0 3
84335: RET
// export function PlayerSeeMe ( unit ) ; begin
84336: LD_INT 0
84338: PPUSH
// result := See ( your_side , unit ) ;
84339: LD_ADDR_VAR 0 2
84343: PUSH
84344: LD_OWVAR 2
84348: PPUSH
84349: LD_VAR 0 1
84353: PPUSH
84354: CALL_OW 292
84358: ST_TO_ADDR
// end ;
84359: LD_VAR 0 2
84363: RET
// export function ReverseDir ( unit ) ; begin
84364: LD_INT 0
84366: PPUSH
// if not unit then
84367: LD_VAR 0 1
84371: NOT
84372: IFFALSE 84376
// exit ;
84374: GO 84422
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
84376: LD_ADDR_VAR 0 2
84380: PUSH
84381: LD_INT 3
84383: PUSH
84384: LD_INT 4
84386: PUSH
84387: LD_INT 5
84389: PUSH
84390: LD_INT 0
84392: PUSH
84393: LD_INT 1
84395: PUSH
84396: LD_INT 2
84398: PUSH
84399: EMPTY
84400: LIST
84401: LIST
84402: LIST
84403: LIST
84404: LIST
84405: LIST
84406: PUSH
84407: LD_VAR 0 1
84411: PPUSH
84412: CALL_OW 254
84416: PUSH
84417: LD_INT 1
84419: PLUS
84420: ARRAY
84421: ST_TO_ADDR
// end ;
84422: LD_VAR 0 2
84426: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
84427: LD_INT 0
84429: PPUSH
84430: PPUSH
84431: PPUSH
84432: PPUSH
84433: PPUSH
// if not hexes then
84434: LD_VAR 0 2
84438: NOT
84439: IFFALSE 84443
// exit ;
84441: GO 84591
// dist := 9999 ;
84443: LD_ADDR_VAR 0 5
84447: PUSH
84448: LD_INT 9999
84450: ST_TO_ADDR
// for i = 1 to hexes do
84451: LD_ADDR_VAR 0 4
84455: PUSH
84456: DOUBLE
84457: LD_INT 1
84459: DEC
84460: ST_TO_ADDR
84461: LD_VAR 0 2
84465: PUSH
84466: FOR_TO
84467: IFFALSE 84579
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
84469: LD_VAR 0 1
84473: PPUSH
84474: LD_VAR 0 2
84478: PUSH
84479: LD_VAR 0 4
84483: ARRAY
84484: PUSH
84485: LD_INT 1
84487: ARRAY
84488: PPUSH
84489: LD_VAR 0 2
84493: PUSH
84494: LD_VAR 0 4
84498: ARRAY
84499: PUSH
84500: LD_INT 2
84502: ARRAY
84503: PPUSH
84504: CALL_OW 297
84508: PUSH
84509: LD_VAR 0 5
84513: LESS
84514: IFFALSE 84577
// begin hex := hexes [ i ] ;
84516: LD_ADDR_VAR 0 7
84520: PUSH
84521: LD_VAR 0 2
84525: PUSH
84526: LD_VAR 0 4
84530: ARRAY
84531: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
84532: LD_ADDR_VAR 0 5
84536: PUSH
84537: LD_VAR 0 1
84541: PPUSH
84542: LD_VAR 0 2
84546: PUSH
84547: LD_VAR 0 4
84551: ARRAY
84552: PUSH
84553: LD_INT 1
84555: ARRAY
84556: PPUSH
84557: LD_VAR 0 2
84561: PUSH
84562: LD_VAR 0 4
84566: ARRAY
84567: PUSH
84568: LD_INT 2
84570: ARRAY
84571: PPUSH
84572: CALL_OW 297
84576: ST_TO_ADDR
// end ; end ;
84577: GO 84466
84579: POP
84580: POP
// result := hex ;
84581: LD_ADDR_VAR 0 3
84585: PUSH
84586: LD_VAR 0 7
84590: ST_TO_ADDR
// end ;
84591: LD_VAR 0 3
84595: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
84596: LD_INT 0
84598: PPUSH
84599: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
84600: LD_VAR 0 1
84604: NOT
84605: PUSH
84606: LD_VAR 0 1
84610: PUSH
84611: LD_INT 21
84613: PUSH
84614: LD_INT 2
84616: PUSH
84617: EMPTY
84618: LIST
84619: LIST
84620: PUSH
84621: LD_INT 23
84623: PUSH
84624: LD_INT 2
84626: PUSH
84627: EMPTY
84628: LIST
84629: LIST
84630: PUSH
84631: EMPTY
84632: LIST
84633: LIST
84634: PPUSH
84635: CALL_OW 69
84639: IN
84640: NOT
84641: OR
84642: IFFALSE 84646
// exit ;
84644: GO 84693
// for i = 1 to 3 do
84646: LD_ADDR_VAR 0 3
84650: PUSH
84651: DOUBLE
84652: LD_INT 1
84654: DEC
84655: ST_TO_ADDR
84656: LD_INT 3
84658: PUSH
84659: FOR_TO
84660: IFFALSE 84691
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
84662: LD_VAR 0 1
84666: PPUSH
84667: CALL_OW 250
84671: PPUSH
84672: LD_VAR 0 1
84676: PPUSH
84677: CALL_OW 251
84681: PPUSH
84682: LD_INT 1
84684: PPUSH
84685: CALL_OW 453
84689: GO 84659
84691: POP
84692: POP
// end ;
84693: LD_VAR 0 2
84697: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
84698: LD_INT 0
84700: PPUSH
84701: PPUSH
84702: PPUSH
84703: PPUSH
84704: PPUSH
84705: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
84706: LD_VAR 0 1
84710: NOT
84711: PUSH
84712: LD_VAR 0 2
84716: NOT
84717: OR
84718: PUSH
84719: LD_VAR 0 1
84723: PPUSH
84724: CALL_OW 314
84728: OR
84729: IFFALSE 84733
// exit ;
84731: GO 85174
// x := GetX ( enemy_unit ) ;
84733: LD_ADDR_VAR 0 7
84737: PUSH
84738: LD_VAR 0 2
84742: PPUSH
84743: CALL_OW 250
84747: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
84748: LD_ADDR_VAR 0 8
84752: PUSH
84753: LD_VAR 0 2
84757: PPUSH
84758: CALL_OW 251
84762: ST_TO_ADDR
// if not x or not y then
84763: LD_VAR 0 7
84767: NOT
84768: PUSH
84769: LD_VAR 0 8
84773: NOT
84774: OR
84775: IFFALSE 84779
// exit ;
84777: GO 85174
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
84779: LD_ADDR_VAR 0 6
84783: PUSH
84784: LD_VAR 0 7
84788: PPUSH
84789: LD_INT 0
84791: PPUSH
84792: LD_INT 4
84794: PPUSH
84795: CALL_OW 272
84799: PUSH
84800: LD_VAR 0 8
84804: PPUSH
84805: LD_INT 0
84807: PPUSH
84808: LD_INT 4
84810: PPUSH
84811: CALL_OW 273
84815: PUSH
84816: EMPTY
84817: LIST
84818: LIST
84819: PUSH
84820: LD_VAR 0 7
84824: PPUSH
84825: LD_INT 1
84827: PPUSH
84828: LD_INT 4
84830: PPUSH
84831: CALL_OW 272
84835: PUSH
84836: LD_VAR 0 8
84840: PPUSH
84841: LD_INT 1
84843: PPUSH
84844: LD_INT 4
84846: PPUSH
84847: CALL_OW 273
84851: PUSH
84852: EMPTY
84853: LIST
84854: LIST
84855: PUSH
84856: LD_VAR 0 7
84860: PPUSH
84861: LD_INT 2
84863: PPUSH
84864: LD_INT 4
84866: PPUSH
84867: CALL_OW 272
84871: PUSH
84872: LD_VAR 0 8
84876: PPUSH
84877: LD_INT 2
84879: PPUSH
84880: LD_INT 4
84882: PPUSH
84883: CALL_OW 273
84887: PUSH
84888: EMPTY
84889: LIST
84890: LIST
84891: PUSH
84892: LD_VAR 0 7
84896: PPUSH
84897: LD_INT 3
84899: PPUSH
84900: LD_INT 4
84902: PPUSH
84903: CALL_OW 272
84907: PUSH
84908: LD_VAR 0 8
84912: PPUSH
84913: LD_INT 3
84915: PPUSH
84916: LD_INT 4
84918: PPUSH
84919: CALL_OW 273
84923: PUSH
84924: EMPTY
84925: LIST
84926: LIST
84927: PUSH
84928: LD_VAR 0 7
84932: PPUSH
84933: LD_INT 4
84935: PPUSH
84936: LD_INT 4
84938: PPUSH
84939: CALL_OW 272
84943: PUSH
84944: LD_VAR 0 8
84948: PPUSH
84949: LD_INT 4
84951: PPUSH
84952: LD_INT 4
84954: PPUSH
84955: CALL_OW 273
84959: PUSH
84960: EMPTY
84961: LIST
84962: LIST
84963: PUSH
84964: LD_VAR 0 7
84968: PPUSH
84969: LD_INT 5
84971: PPUSH
84972: LD_INT 4
84974: PPUSH
84975: CALL_OW 272
84979: PUSH
84980: LD_VAR 0 8
84984: PPUSH
84985: LD_INT 5
84987: PPUSH
84988: LD_INT 4
84990: PPUSH
84991: CALL_OW 273
84995: PUSH
84996: EMPTY
84997: LIST
84998: LIST
84999: PUSH
85000: EMPTY
85001: LIST
85002: LIST
85003: LIST
85004: LIST
85005: LIST
85006: LIST
85007: ST_TO_ADDR
// for i = tmp downto 1 do
85008: LD_ADDR_VAR 0 4
85012: PUSH
85013: DOUBLE
85014: LD_VAR 0 6
85018: INC
85019: ST_TO_ADDR
85020: LD_INT 1
85022: PUSH
85023: FOR_DOWNTO
85024: IFFALSE 85125
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
85026: LD_VAR 0 6
85030: PUSH
85031: LD_VAR 0 4
85035: ARRAY
85036: PUSH
85037: LD_INT 1
85039: ARRAY
85040: PPUSH
85041: LD_VAR 0 6
85045: PUSH
85046: LD_VAR 0 4
85050: ARRAY
85051: PUSH
85052: LD_INT 2
85054: ARRAY
85055: PPUSH
85056: CALL_OW 488
85060: NOT
85061: PUSH
85062: LD_VAR 0 6
85066: PUSH
85067: LD_VAR 0 4
85071: ARRAY
85072: PUSH
85073: LD_INT 1
85075: ARRAY
85076: PPUSH
85077: LD_VAR 0 6
85081: PUSH
85082: LD_VAR 0 4
85086: ARRAY
85087: PUSH
85088: LD_INT 2
85090: ARRAY
85091: PPUSH
85092: CALL_OW 428
85096: PUSH
85097: LD_INT 0
85099: NONEQUAL
85100: OR
85101: IFFALSE 85123
// tmp := Delete ( tmp , i ) ;
85103: LD_ADDR_VAR 0 6
85107: PUSH
85108: LD_VAR 0 6
85112: PPUSH
85113: LD_VAR 0 4
85117: PPUSH
85118: CALL_OW 3
85122: ST_TO_ADDR
85123: GO 85023
85125: POP
85126: POP
// j := GetClosestHex ( unit , tmp ) ;
85127: LD_ADDR_VAR 0 5
85131: PUSH
85132: LD_VAR 0 1
85136: PPUSH
85137: LD_VAR 0 6
85141: PPUSH
85142: CALL 84427 0 2
85146: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
85147: LD_VAR 0 1
85151: PPUSH
85152: LD_VAR 0 5
85156: PUSH
85157: LD_INT 1
85159: ARRAY
85160: PPUSH
85161: LD_VAR 0 5
85165: PUSH
85166: LD_INT 2
85168: ARRAY
85169: PPUSH
85170: CALL_OW 111
// end ;
85174: LD_VAR 0 3
85178: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
85179: LD_INT 0
85181: PPUSH
85182: PPUSH
85183: PPUSH
// uc_side = 0 ;
85184: LD_ADDR_OWVAR 20
85188: PUSH
85189: LD_INT 0
85191: ST_TO_ADDR
// uc_nation = 0 ;
85192: LD_ADDR_OWVAR 21
85196: PUSH
85197: LD_INT 0
85199: ST_TO_ADDR
// InitHc ;
85200: CALL_OW 19
// InitVc ;
85204: CALL_OW 20
// if mastodonts then
85208: LD_VAR 0 6
85212: IFFALSE 85279
// for i = 1 to mastodonts do
85214: LD_ADDR_VAR 0 11
85218: PUSH
85219: DOUBLE
85220: LD_INT 1
85222: DEC
85223: ST_TO_ADDR
85224: LD_VAR 0 6
85228: PUSH
85229: FOR_TO
85230: IFFALSE 85277
// begin vc_chassis := 31 ;
85232: LD_ADDR_OWVAR 37
85236: PUSH
85237: LD_INT 31
85239: ST_TO_ADDR
// vc_control := control_rider ;
85240: LD_ADDR_OWVAR 38
85244: PUSH
85245: LD_INT 4
85247: ST_TO_ADDR
// animal := CreateVehicle ;
85248: LD_ADDR_VAR 0 12
85252: PUSH
85253: CALL_OW 45
85257: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85258: LD_VAR 0 12
85262: PPUSH
85263: LD_VAR 0 8
85267: PPUSH
85268: LD_INT 0
85270: PPUSH
85271: CALL 92024 0 3
// end ;
85275: GO 85229
85277: POP
85278: POP
// if horses then
85279: LD_VAR 0 5
85283: IFFALSE 85350
// for i = 1 to horses do
85285: LD_ADDR_VAR 0 11
85289: PUSH
85290: DOUBLE
85291: LD_INT 1
85293: DEC
85294: ST_TO_ADDR
85295: LD_VAR 0 5
85299: PUSH
85300: FOR_TO
85301: IFFALSE 85348
// begin hc_class := 21 ;
85303: LD_ADDR_OWVAR 28
85307: PUSH
85308: LD_INT 21
85310: ST_TO_ADDR
// hc_gallery :=  ;
85311: LD_ADDR_OWVAR 33
85315: PUSH
85316: LD_STRING 
85318: ST_TO_ADDR
// animal := CreateHuman ;
85319: LD_ADDR_VAR 0 12
85323: PUSH
85324: CALL_OW 44
85328: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85329: LD_VAR 0 12
85333: PPUSH
85334: LD_VAR 0 8
85338: PPUSH
85339: LD_INT 0
85341: PPUSH
85342: CALL 92024 0 3
// end ;
85346: GO 85300
85348: POP
85349: POP
// if birds then
85350: LD_VAR 0 1
85354: IFFALSE 85421
// for i = 1 to birds do
85356: LD_ADDR_VAR 0 11
85360: PUSH
85361: DOUBLE
85362: LD_INT 1
85364: DEC
85365: ST_TO_ADDR
85366: LD_VAR 0 1
85370: PUSH
85371: FOR_TO
85372: IFFALSE 85419
// begin hc_class = 18 ;
85374: LD_ADDR_OWVAR 28
85378: PUSH
85379: LD_INT 18
85381: ST_TO_ADDR
// hc_gallery =  ;
85382: LD_ADDR_OWVAR 33
85386: PUSH
85387: LD_STRING 
85389: ST_TO_ADDR
// animal := CreateHuman ;
85390: LD_ADDR_VAR 0 12
85394: PUSH
85395: CALL_OW 44
85399: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85400: LD_VAR 0 12
85404: PPUSH
85405: LD_VAR 0 8
85409: PPUSH
85410: LD_INT 0
85412: PPUSH
85413: CALL 92024 0 3
// end ;
85417: GO 85371
85419: POP
85420: POP
// if tigers then
85421: LD_VAR 0 2
85425: IFFALSE 85509
// for i = 1 to tigers do
85427: LD_ADDR_VAR 0 11
85431: PUSH
85432: DOUBLE
85433: LD_INT 1
85435: DEC
85436: ST_TO_ADDR
85437: LD_VAR 0 2
85441: PUSH
85442: FOR_TO
85443: IFFALSE 85507
// begin hc_class = class_tiger ;
85445: LD_ADDR_OWVAR 28
85449: PUSH
85450: LD_INT 14
85452: ST_TO_ADDR
// hc_gallery =  ;
85453: LD_ADDR_OWVAR 33
85457: PUSH
85458: LD_STRING 
85460: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
85461: LD_ADDR_OWVAR 35
85465: PUSH
85466: LD_INT 7
85468: NEG
85469: PPUSH
85470: LD_INT 7
85472: PPUSH
85473: CALL_OW 12
85477: ST_TO_ADDR
// animal := CreateHuman ;
85478: LD_ADDR_VAR 0 12
85482: PUSH
85483: CALL_OW 44
85487: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85488: LD_VAR 0 12
85492: PPUSH
85493: LD_VAR 0 8
85497: PPUSH
85498: LD_INT 0
85500: PPUSH
85501: CALL 92024 0 3
// end ;
85505: GO 85442
85507: POP
85508: POP
// if apemans then
85509: LD_VAR 0 3
85513: IFFALSE 85636
// for i = 1 to apemans do
85515: LD_ADDR_VAR 0 11
85519: PUSH
85520: DOUBLE
85521: LD_INT 1
85523: DEC
85524: ST_TO_ADDR
85525: LD_VAR 0 3
85529: PUSH
85530: FOR_TO
85531: IFFALSE 85634
// begin hc_class = class_apeman ;
85533: LD_ADDR_OWVAR 28
85537: PUSH
85538: LD_INT 12
85540: ST_TO_ADDR
// hc_gallery =  ;
85541: LD_ADDR_OWVAR 33
85545: PUSH
85546: LD_STRING 
85548: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
85549: LD_ADDR_OWVAR 35
85553: PUSH
85554: LD_INT 5
85556: NEG
85557: PPUSH
85558: LD_INT 5
85560: PPUSH
85561: CALL_OW 12
85565: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
85566: LD_ADDR_OWVAR 31
85570: PUSH
85571: LD_INT 1
85573: PPUSH
85574: LD_INT 3
85576: PPUSH
85577: CALL_OW 12
85581: PUSH
85582: LD_INT 1
85584: PPUSH
85585: LD_INT 3
85587: PPUSH
85588: CALL_OW 12
85592: PUSH
85593: LD_INT 0
85595: PUSH
85596: LD_INT 0
85598: PUSH
85599: EMPTY
85600: LIST
85601: LIST
85602: LIST
85603: LIST
85604: ST_TO_ADDR
// animal := CreateHuman ;
85605: LD_ADDR_VAR 0 12
85609: PUSH
85610: CALL_OW 44
85614: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85615: LD_VAR 0 12
85619: PPUSH
85620: LD_VAR 0 8
85624: PPUSH
85625: LD_INT 0
85627: PPUSH
85628: CALL 92024 0 3
// end ;
85632: GO 85530
85634: POP
85635: POP
// if enchidnas then
85636: LD_VAR 0 4
85640: IFFALSE 85707
// for i = 1 to enchidnas do
85642: LD_ADDR_VAR 0 11
85646: PUSH
85647: DOUBLE
85648: LD_INT 1
85650: DEC
85651: ST_TO_ADDR
85652: LD_VAR 0 4
85656: PUSH
85657: FOR_TO
85658: IFFALSE 85705
// begin hc_class = 13 ;
85660: LD_ADDR_OWVAR 28
85664: PUSH
85665: LD_INT 13
85667: ST_TO_ADDR
// hc_gallery =  ;
85668: LD_ADDR_OWVAR 33
85672: PUSH
85673: LD_STRING 
85675: ST_TO_ADDR
// animal := CreateHuman ;
85676: LD_ADDR_VAR 0 12
85680: PUSH
85681: CALL_OW 44
85685: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85686: LD_VAR 0 12
85690: PPUSH
85691: LD_VAR 0 8
85695: PPUSH
85696: LD_INT 0
85698: PPUSH
85699: CALL 92024 0 3
// end ;
85703: GO 85657
85705: POP
85706: POP
// if fishes then
85707: LD_VAR 0 7
85711: IFFALSE 85778
// for i = 1 to fishes do
85713: LD_ADDR_VAR 0 11
85717: PUSH
85718: DOUBLE
85719: LD_INT 1
85721: DEC
85722: ST_TO_ADDR
85723: LD_VAR 0 7
85727: PUSH
85728: FOR_TO
85729: IFFALSE 85776
// begin hc_class = 20 ;
85731: LD_ADDR_OWVAR 28
85735: PUSH
85736: LD_INT 20
85738: ST_TO_ADDR
// hc_gallery =  ;
85739: LD_ADDR_OWVAR 33
85743: PUSH
85744: LD_STRING 
85746: ST_TO_ADDR
// animal := CreateHuman ;
85747: LD_ADDR_VAR 0 12
85751: PUSH
85752: CALL_OW 44
85756: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
85757: LD_VAR 0 12
85761: PPUSH
85762: LD_VAR 0 9
85766: PPUSH
85767: LD_INT 0
85769: PPUSH
85770: CALL 92024 0 3
// end ;
85774: GO 85728
85776: POP
85777: POP
// end ;
85778: LD_VAR 0 10
85782: RET
// export function WantHeal ( sci , unit ) ; begin
85783: LD_INT 0
85785: PPUSH
// if GetTaskList ( sci ) > 0 then
85786: LD_VAR 0 1
85790: PPUSH
85791: CALL_OW 437
85795: PUSH
85796: LD_INT 0
85798: GREATER
85799: IFFALSE 85869
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
85801: LD_VAR 0 1
85805: PPUSH
85806: CALL_OW 437
85810: PUSH
85811: LD_INT 1
85813: ARRAY
85814: PUSH
85815: LD_INT 1
85817: ARRAY
85818: PUSH
85819: LD_STRING l
85821: EQUAL
85822: PUSH
85823: LD_VAR 0 1
85827: PPUSH
85828: CALL_OW 437
85832: PUSH
85833: LD_INT 1
85835: ARRAY
85836: PUSH
85837: LD_INT 4
85839: ARRAY
85840: PUSH
85841: LD_VAR 0 2
85845: EQUAL
85846: AND
85847: IFFALSE 85859
// result := true else
85849: LD_ADDR_VAR 0 3
85853: PUSH
85854: LD_INT 1
85856: ST_TO_ADDR
85857: GO 85867
// result := false ;
85859: LD_ADDR_VAR 0 3
85863: PUSH
85864: LD_INT 0
85866: ST_TO_ADDR
// end else
85867: GO 85877
// result := false ;
85869: LD_ADDR_VAR 0 3
85873: PUSH
85874: LD_INT 0
85876: ST_TO_ADDR
// end ;
85877: LD_VAR 0 3
85881: RET
// export function HealTarget ( sci ) ; begin
85882: LD_INT 0
85884: PPUSH
// if not sci then
85885: LD_VAR 0 1
85889: NOT
85890: IFFALSE 85894
// exit ;
85892: GO 85959
// result := 0 ;
85894: LD_ADDR_VAR 0 2
85898: PUSH
85899: LD_INT 0
85901: ST_TO_ADDR
// if GetTaskList ( sci ) then
85902: LD_VAR 0 1
85906: PPUSH
85907: CALL_OW 437
85911: IFFALSE 85959
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
85913: LD_VAR 0 1
85917: PPUSH
85918: CALL_OW 437
85922: PUSH
85923: LD_INT 1
85925: ARRAY
85926: PUSH
85927: LD_INT 1
85929: ARRAY
85930: PUSH
85931: LD_STRING l
85933: EQUAL
85934: IFFALSE 85959
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
85936: LD_ADDR_VAR 0 2
85940: PUSH
85941: LD_VAR 0 1
85945: PPUSH
85946: CALL_OW 437
85950: PUSH
85951: LD_INT 1
85953: ARRAY
85954: PUSH
85955: LD_INT 4
85957: ARRAY
85958: ST_TO_ADDR
// end ;
85959: LD_VAR 0 2
85963: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
85964: LD_INT 0
85966: PPUSH
85967: PPUSH
85968: PPUSH
85969: PPUSH
85970: PPUSH
85971: PPUSH
85972: PPUSH
85973: PPUSH
85974: PPUSH
85975: PPUSH
85976: PPUSH
85977: PPUSH
85978: PPUSH
85979: PPUSH
85980: PPUSH
85981: PPUSH
85982: PPUSH
85983: PPUSH
85984: PPUSH
85985: PPUSH
85986: PPUSH
85987: PPUSH
85988: PPUSH
85989: PPUSH
85990: PPUSH
85991: PPUSH
85992: PPUSH
85993: PPUSH
85994: PPUSH
85995: PPUSH
85996: PPUSH
85997: PPUSH
85998: PPUSH
85999: PPUSH
// if not list then
86000: LD_VAR 0 1
86004: NOT
86005: IFFALSE 86009
// exit ;
86007: GO 90635
// base := list [ 1 ] ;
86009: LD_ADDR_VAR 0 3
86013: PUSH
86014: LD_VAR 0 1
86018: PUSH
86019: LD_INT 1
86021: ARRAY
86022: ST_TO_ADDR
// group := list [ 2 ] ;
86023: LD_ADDR_VAR 0 4
86027: PUSH
86028: LD_VAR 0 1
86032: PUSH
86033: LD_INT 2
86035: ARRAY
86036: ST_TO_ADDR
// path := list [ 3 ] ;
86037: LD_ADDR_VAR 0 5
86041: PUSH
86042: LD_VAR 0 1
86046: PUSH
86047: LD_INT 3
86049: ARRAY
86050: ST_TO_ADDR
// flags := list [ 4 ] ;
86051: LD_ADDR_VAR 0 6
86055: PUSH
86056: LD_VAR 0 1
86060: PUSH
86061: LD_INT 4
86063: ARRAY
86064: ST_TO_ADDR
// mined := [ ] ;
86065: LD_ADDR_VAR 0 27
86069: PUSH
86070: EMPTY
86071: ST_TO_ADDR
// bombed := [ ] ;
86072: LD_ADDR_VAR 0 28
86076: PUSH
86077: EMPTY
86078: ST_TO_ADDR
// healers := [ ] ;
86079: LD_ADDR_VAR 0 31
86083: PUSH
86084: EMPTY
86085: ST_TO_ADDR
// to_heal := [ ] ;
86086: LD_ADDR_VAR 0 30
86090: PUSH
86091: EMPTY
86092: ST_TO_ADDR
// repairs := [ ] ;
86093: LD_ADDR_VAR 0 33
86097: PUSH
86098: EMPTY
86099: ST_TO_ADDR
// to_repair := [ ] ;
86100: LD_ADDR_VAR 0 32
86104: PUSH
86105: EMPTY
86106: ST_TO_ADDR
// if not group or not path then
86107: LD_VAR 0 4
86111: NOT
86112: PUSH
86113: LD_VAR 0 5
86117: NOT
86118: OR
86119: IFFALSE 86123
// exit ;
86121: GO 90635
// side := GetSide ( group [ 1 ] ) ;
86123: LD_ADDR_VAR 0 35
86127: PUSH
86128: LD_VAR 0 4
86132: PUSH
86133: LD_INT 1
86135: ARRAY
86136: PPUSH
86137: CALL_OW 255
86141: ST_TO_ADDR
// if flags then
86142: LD_VAR 0 6
86146: IFFALSE 86290
// begin f_ignore_area := flags [ 1 ] ;
86148: LD_ADDR_VAR 0 17
86152: PUSH
86153: LD_VAR 0 6
86157: PUSH
86158: LD_INT 1
86160: ARRAY
86161: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
86162: LD_ADDR_VAR 0 18
86166: PUSH
86167: LD_VAR 0 6
86171: PUSH
86172: LD_INT 2
86174: ARRAY
86175: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
86176: LD_ADDR_VAR 0 19
86180: PUSH
86181: LD_VAR 0 6
86185: PUSH
86186: LD_INT 3
86188: ARRAY
86189: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
86190: LD_ADDR_VAR 0 20
86194: PUSH
86195: LD_VAR 0 6
86199: PUSH
86200: LD_INT 4
86202: ARRAY
86203: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
86204: LD_ADDR_VAR 0 21
86208: PUSH
86209: LD_VAR 0 6
86213: PUSH
86214: LD_INT 5
86216: ARRAY
86217: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
86218: LD_ADDR_VAR 0 22
86222: PUSH
86223: LD_VAR 0 6
86227: PUSH
86228: LD_INT 6
86230: ARRAY
86231: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
86232: LD_ADDR_VAR 0 23
86236: PUSH
86237: LD_VAR 0 6
86241: PUSH
86242: LD_INT 7
86244: ARRAY
86245: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
86246: LD_ADDR_VAR 0 24
86250: PUSH
86251: LD_VAR 0 6
86255: PUSH
86256: LD_INT 8
86258: ARRAY
86259: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
86260: LD_ADDR_VAR 0 25
86264: PUSH
86265: LD_VAR 0 6
86269: PUSH
86270: LD_INT 9
86272: ARRAY
86273: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
86274: LD_ADDR_VAR 0 26
86278: PUSH
86279: LD_VAR 0 6
86283: PUSH
86284: LD_INT 10
86286: ARRAY
86287: ST_TO_ADDR
// end else
86288: GO 86370
// begin f_ignore_area := false ;
86290: LD_ADDR_VAR 0 17
86294: PUSH
86295: LD_INT 0
86297: ST_TO_ADDR
// f_capture := false ;
86298: LD_ADDR_VAR 0 18
86302: PUSH
86303: LD_INT 0
86305: ST_TO_ADDR
// f_ignore_civ := false ;
86306: LD_ADDR_VAR 0 19
86310: PUSH
86311: LD_INT 0
86313: ST_TO_ADDR
// f_murder := false ;
86314: LD_ADDR_VAR 0 20
86318: PUSH
86319: LD_INT 0
86321: ST_TO_ADDR
// f_mines := false ;
86322: LD_ADDR_VAR 0 21
86326: PUSH
86327: LD_INT 0
86329: ST_TO_ADDR
// f_repair := false ;
86330: LD_ADDR_VAR 0 22
86334: PUSH
86335: LD_INT 0
86337: ST_TO_ADDR
// f_heal := false ;
86338: LD_ADDR_VAR 0 23
86342: PUSH
86343: LD_INT 0
86345: ST_TO_ADDR
// f_spacetime := false ;
86346: LD_ADDR_VAR 0 24
86350: PUSH
86351: LD_INT 0
86353: ST_TO_ADDR
// f_attack_depot := false ;
86354: LD_ADDR_VAR 0 25
86358: PUSH
86359: LD_INT 0
86361: ST_TO_ADDR
// f_crawl := false ;
86362: LD_ADDR_VAR 0 26
86366: PUSH
86367: LD_INT 0
86369: ST_TO_ADDR
// end ; if f_heal then
86370: LD_VAR 0 23
86374: IFFALSE 86401
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
86376: LD_ADDR_VAR 0 31
86380: PUSH
86381: LD_VAR 0 4
86385: PPUSH
86386: LD_INT 25
86388: PUSH
86389: LD_INT 4
86391: PUSH
86392: EMPTY
86393: LIST
86394: LIST
86395: PPUSH
86396: CALL_OW 72
86400: ST_TO_ADDR
// if f_repair then
86401: LD_VAR 0 22
86405: IFFALSE 86432
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
86407: LD_ADDR_VAR 0 33
86411: PUSH
86412: LD_VAR 0 4
86416: PPUSH
86417: LD_INT 25
86419: PUSH
86420: LD_INT 3
86422: PUSH
86423: EMPTY
86424: LIST
86425: LIST
86426: PPUSH
86427: CALL_OW 72
86431: ST_TO_ADDR
// units_path := [ ] ;
86432: LD_ADDR_VAR 0 16
86436: PUSH
86437: EMPTY
86438: ST_TO_ADDR
// for i = 1 to group do
86439: LD_ADDR_VAR 0 7
86443: PUSH
86444: DOUBLE
86445: LD_INT 1
86447: DEC
86448: ST_TO_ADDR
86449: LD_VAR 0 4
86453: PUSH
86454: FOR_TO
86455: IFFALSE 86484
// units_path := Replace ( units_path , i , path ) ;
86457: LD_ADDR_VAR 0 16
86461: PUSH
86462: LD_VAR 0 16
86466: PPUSH
86467: LD_VAR 0 7
86471: PPUSH
86472: LD_VAR 0 5
86476: PPUSH
86477: CALL_OW 1
86481: ST_TO_ADDR
86482: GO 86454
86484: POP
86485: POP
// repeat for i = group downto 1 do
86486: LD_ADDR_VAR 0 7
86490: PUSH
86491: DOUBLE
86492: LD_VAR 0 4
86496: INC
86497: ST_TO_ADDR
86498: LD_INT 1
86500: PUSH
86501: FOR_DOWNTO
86502: IFFALSE 90598
// begin wait ( 5 ) ;
86504: LD_INT 5
86506: PPUSH
86507: CALL_OW 67
// tmp := [ ] ;
86511: LD_ADDR_VAR 0 14
86515: PUSH
86516: EMPTY
86517: ST_TO_ADDR
// attacking := false ;
86518: LD_ADDR_VAR 0 29
86522: PUSH
86523: LD_INT 0
86525: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
86526: LD_VAR 0 4
86530: PUSH
86531: LD_VAR 0 7
86535: ARRAY
86536: PPUSH
86537: CALL_OW 301
86541: PUSH
86542: LD_VAR 0 4
86546: PUSH
86547: LD_VAR 0 7
86551: ARRAY
86552: NOT
86553: OR
86554: IFFALSE 86663
// begin if GetType ( group [ i ] ) = unit_human then
86556: LD_VAR 0 4
86560: PUSH
86561: LD_VAR 0 7
86565: ARRAY
86566: PPUSH
86567: CALL_OW 247
86571: PUSH
86572: LD_INT 1
86574: EQUAL
86575: IFFALSE 86621
// begin to_heal := to_heal diff group [ i ] ;
86577: LD_ADDR_VAR 0 30
86581: PUSH
86582: LD_VAR 0 30
86586: PUSH
86587: LD_VAR 0 4
86591: PUSH
86592: LD_VAR 0 7
86596: ARRAY
86597: DIFF
86598: ST_TO_ADDR
// healers := healers diff group [ i ] ;
86599: LD_ADDR_VAR 0 31
86603: PUSH
86604: LD_VAR 0 31
86608: PUSH
86609: LD_VAR 0 4
86613: PUSH
86614: LD_VAR 0 7
86618: ARRAY
86619: DIFF
86620: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
86621: LD_ADDR_VAR 0 4
86625: PUSH
86626: LD_VAR 0 4
86630: PPUSH
86631: LD_VAR 0 7
86635: PPUSH
86636: CALL_OW 3
86640: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
86641: LD_ADDR_VAR 0 16
86645: PUSH
86646: LD_VAR 0 16
86650: PPUSH
86651: LD_VAR 0 7
86655: PPUSH
86656: CALL_OW 3
86660: ST_TO_ADDR
// continue ;
86661: GO 86501
// end ; if f_repair then
86663: LD_VAR 0 22
86667: IFFALSE 87156
// begin if GetType ( group [ i ] ) = unit_vehicle then
86669: LD_VAR 0 4
86673: PUSH
86674: LD_VAR 0 7
86678: ARRAY
86679: PPUSH
86680: CALL_OW 247
86684: PUSH
86685: LD_INT 2
86687: EQUAL
86688: IFFALSE 86878
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
86690: LD_VAR 0 4
86694: PUSH
86695: LD_VAR 0 7
86699: ARRAY
86700: PPUSH
86701: CALL_OW 256
86705: PUSH
86706: LD_INT 700
86708: LESS
86709: PUSH
86710: LD_VAR 0 4
86714: PUSH
86715: LD_VAR 0 7
86719: ARRAY
86720: PUSH
86721: LD_VAR 0 32
86725: IN
86726: NOT
86727: AND
86728: IFFALSE 86752
// to_repair := to_repair union group [ i ] ;
86730: LD_ADDR_VAR 0 32
86734: PUSH
86735: LD_VAR 0 32
86739: PUSH
86740: LD_VAR 0 4
86744: PUSH
86745: LD_VAR 0 7
86749: ARRAY
86750: UNION
86751: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
86752: LD_VAR 0 4
86756: PUSH
86757: LD_VAR 0 7
86761: ARRAY
86762: PPUSH
86763: CALL_OW 256
86767: PUSH
86768: LD_INT 1000
86770: EQUAL
86771: PUSH
86772: LD_VAR 0 4
86776: PUSH
86777: LD_VAR 0 7
86781: ARRAY
86782: PUSH
86783: LD_VAR 0 32
86787: IN
86788: AND
86789: IFFALSE 86813
// to_repair := to_repair diff group [ i ] ;
86791: LD_ADDR_VAR 0 32
86795: PUSH
86796: LD_VAR 0 32
86800: PUSH
86801: LD_VAR 0 4
86805: PUSH
86806: LD_VAR 0 7
86810: ARRAY
86811: DIFF
86812: ST_TO_ADDR
// if group [ i ] in to_repair then
86813: LD_VAR 0 4
86817: PUSH
86818: LD_VAR 0 7
86822: ARRAY
86823: PUSH
86824: LD_VAR 0 32
86828: IN
86829: IFFALSE 86876
// begin if not IsInArea ( group [ i ] , f_repair ) then
86831: LD_VAR 0 4
86835: PUSH
86836: LD_VAR 0 7
86840: ARRAY
86841: PPUSH
86842: LD_VAR 0 22
86846: PPUSH
86847: CALL_OW 308
86851: NOT
86852: IFFALSE 86874
// ComMoveToArea ( group [ i ] , f_repair ) ;
86854: LD_VAR 0 4
86858: PUSH
86859: LD_VAR 0 7
86863: ARRAY
86864: PPUSH
86865: LD_VAR 0 22
86869: PPUSH
86870: CALL_OW 113
// continue ;
86874: GO 86501
// end ; end else
86876: GO 87156
// if group [ i ] in repairs then
86878: LD_VAR 0 4
86882: PUSH
86883: LD_VAR 0 7
86887: ARRAY
86888: PUSH
86889: LD_VAR 0 33
86893: IN
86894: IFFALSE 87156
// begin if IsInUnit ( group [ i ] ) then
86896: LD_VAR 0 4
86900: PUSH
86901: LD_VAR 0 7
86905: ARRAY
86906: PPUSH
86907: CALL_OW 310
86911: IFFALSE 86979
// begin z := IsInUnit ( group [ i ] ) ;
86913: LD_ADDR_VAR 0 13
86917: PUSH
86918: LD_VAR 0 4
86922: PUSH
86923: LD_VAR 0 7
86927: ARRAY
86928: PPUSH
86929: CALL_OW 310
86933: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
86934: LD_VAR 0 13
86938: PUSH
86939: LD_VAR 0 32
86943: IN
86944: PUSH
86945: LD_VAR 0 13
86949: PPUSH
86950: LD_VAR 0 22
86954: PPUSH
86955: CALL_OW 308
86959: AND
86960: IFFALSE 86977
// ComExitVehicle ( group [ i ] ) ;
86962: LD_VAR 0 4
86966: PUSH
86967: LD_VAR 0 7
86971: ARRAY
86972: PPUSH
86973: CALL_OW 121
// end else
86977: GO 87156
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
86979: LD_ADDR_VAR 0 13
86983: PUSH
86984: LD_VAR 0 4
86988: PPUSH
86989: LD_INT 95
86991: PUSH
86992: LD_VAR 0 22
86996: PUSH
86997: EMPTY
86998: LIST
86999: LIST
87000: PUSH
87001: LD_INT 58
87003: PUSH
87004: EMPTY
87005: LIST
87006: PUSH
87007: EMPTY
87008: LIST
87009: LIST
87010: PPUSH
87011: CALL_OW 72
87015: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
87016: LD_VAR 0 4
87020: PUSH
87021: LD_VAR 0 7
87025: ARRAY
87026: PPUSH
87027: CALL_OW 314
87031: NOT
87032: IFFALSE 87154
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
87034: LD_ADDR_VAR 0 10
87038: PUSH
87039: LD_VAR 0 13
87043: PPUSH
87044: LD_VAR 0 4
87048: PUSH
87049: LD_VAR 0 7
87053: ARRAY
87054: PPUSH
87055: CALL_OW 74
87059: ST_TO_ADDR
// if not x then
87060: LD_VAR 0 10
87064: NOT
87065: IFFALSE 87069
// continue ;
87067: GO 86501
// if GetLives ( x ) < 1000 then
87069: LD_VAR 0 10
87073: PPUSH
87074: CALL_OW 256
87078: PUSH
87079: LD_INT 1000
87081: LESS
87082: IFFALSE 87106
// ComRepairVehicle ( group [ i ] , x ) else
87084: LD_VAR 0 4
87088: PUSH
87089: LD_VAR 0 7
87093: ARRAY
87094: PPUSH
87095: LD_VAR 0 10
87099: PPUSH
87100: CALL_OW 129
87104: GO 87154
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
87106: LD_VAR 0 23
87110: PUSH
87111: LD_VAR 0 4
87115: PUSH
87116: LD_VAR 0 7
87120: ARRAY
87121: PPUSH
87122: CALL_OW 256
87126: PUSH
87127: LD_INT 1000
87129: LESS
87130: AND
87131: NOT
87132: IFFALSE 87154
// ComEnterUnit ( group [ i ] , x ) ;
87134: LD_VAR 0 4
87138: PUSH
87139: LD_VAR 0 7
87143: ARRAY
87144: PPUSH
87145: LD_VAR 0 10
87149: PPUSH
87150: CALL_OW 120
// end ; continue ;
87154: GO 86501
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
87156: LD_VAR 0 23
87160: PUSH
87161: LD_VAR 0 4
87165: PUSH
87166: LD_VAR 0 7
87170: ARRAY
87171: PPUSH
87172: CALL_OW 247
87176: PUSH
87177: LD_INT 1
87179: EQUAL
87180: AND
87181: IFFALSE 87659
// begin if group [ i ] in healers then
87183: LD_VAR 0 4
87187: PUSH
87188: LD_VAR 0 7
87192: ARRAY
87193: PUSH
87194: LD_VAR 0 31
87198: IN
87199: IFFALSE 87472
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
87201: LD_VAR 0 4
87205: PUSH
87206: LD_VAR 0 7
87210: ARRAY
87211: PPUSH
87212: LD_VAR 0 23
87216: PPUSH
87217: CALL_OW 308
87221: NOT
87222: PUSH
87223: LD_VAR 0 4
87227: PUSH
87228: LD_VAR 0 7
87232: ARRAY
87233: PPUSH
87234: CALL_OW 314
87238: NOT
87239: AND
87240: IFFALSE 87264
// ComMoveToArea ( group [ i ] , f_heal ) else
87242: LD_VAR 0 4
87246: PUSH
87247: LD_VAR 0 7
87251: ARRAY
87252: PPUSH
87253: LD_VAR 0 23
87257: PPUSH
87258: CALL_OW 113
87262: GO 87470
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
87264: LD_VAR 0 4
87268: PUSH
87269: LD_VAR 0 7
87273: ARRAY
87274: PPUSH
87275: CALL 85882 0 1
87279: PPUSH
87280: CALL_OW 256
87284: PUSH
87285: LD_INT 1000
87287: EQUAL
87288: IFFALSE 87307
// ComStop ( group [ i ] ) else
87290: LD_VAR 0 4
87294: PUSH
87295: LD_VAR 0 7
87299: ARRAY
87300: PPUSH
87301: CALL_OW 141
87305: GO 87470
// if not HasTask ( group [ i ] ) and to_heal then
87307: LD_VAR 0 4
87311: PUSH
87312: LD_VAR 0 7
87316: ARRAY
87317: PPUSH
87318: CALL_OW 314
87322: NOT
87323: PUSH
87324: LD_VAR 0 30
87328: AND
87329: IFFALSE 87470
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
87331: LD_ADDR_VAR 0 13
87335: PUSH
87336: LD_VAR 0 30
87340: PPUSH
87341: LD_INT 3
87343: PUSH
87344: LD_INT 54
87346: PUSH
87347: EMPTY
87348: LIST
87349: PUSH
87350: EMPTY
87351: LIST
87352: LIST
87353: PPUSH
87354: CALL_OW 72
87358: PPUSH
87359: LD_VAR 0 4
87363: PUSH
87364: LD_VAR 0 7
87368: ARRAY
87369: PPUSH
87370: CALL_OW 74
87374: ST_TO_ADDR
// if z then
87375: LD_VAR 0 13
87379: IFFALSE 87470
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
87381: LD_INT 91
87383: PUSH
87384: LD_VAR 0 13
87388: PUSH
87389: LD_INT 10
87391: PUSH
87392: EMPTY
87393: LIST
87394: LIST
87395: LIST
87396: PUSH
87397: LD_INT 81
87399: PUSH
87400: LD_VAR 0 13
87404: PPUSH
87405: CALL_OW 255
87409: PUSH
87410: EMPTY
87411: LIST
87412: LIST
87413: PUSH
87414: EMPTY
87415: LIST
87416: LIST
87417: PPUSH
87418: CALL_OW 69
87422: PUSH
87423: LD_INT 0
87425: EQUAL
87426: IFFALSE 87450
// ComHeal ( group [ i ] , z ) else
87428: LD_VAR 0 4
87432: PUSH
87433: LD_VAR 0 7
87437: ARRAY
87438: PPUSH
87439: LD_VAR 0 13
87443: PPUSH
87444: CALL_OW 128
87448: GO 87470
// ComMoveToArea ( group [ i ] , f_heal ) ;
87450: LD_VAR 0 4
87454: PUSH
87455: LD_VAR 0 7
87459: ARRAY
87460: PPUSH
87461: LD_VAR 0 23
87465: PPUSH
87466: CALL_OW 113
// end ; continue ;
87470: GO 86501
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
87472: LD_VAR 0 4
87476: PUSH
87477: LD_VAR 0 7
87481: ARRAY
87482: PPUSH
87483: CALL_OW 256
87487: PUSH
87488: LD_INT 700
87490: LESS
87491: PUSH
87492: LD_VAR 0 4
87496: PUSH
87497: LD_VAR 0 7
87501: ARRAY
87502: PUSH
87503: LD_VAR 0 30
87507: IN
87508: NOT
87509: AND
87510: IFFALSE 87534
// to_heal := to_heal union group [ i ] ;
87512: LD_ADDR_VAR 0 30
87516: PUSH
87517: LD_VAR 0 30
87521: PUSH
87522: LD_VAR 0 4
87526: PUSH
87527: LD_VAR 0 7
87531: ARRAY
87532: UNION
87533: ST_TO_ADDR
// if group [ i ] in to_heal then
87534: LD_VAR 0 4
87538: PUSH
87539: LD_VAR 0 7
87543: ARRAY
87544: PUSH
87545: LD_VAR 0 30
87549: IN
87550: IFFALSE 87659
// begin if GetLives ( group [ i ] ) = 1000 then
87552: LD_VAR 0 4
87556: PUSH
87557: LD_VAR 0 7
87561: ARRAY
87562: PPUSH
87563: CALL_OW 256
87567: PUSH
87568: LD_INT 1000
87570: EQUAL
87571: IFFALSE 87597
// to_heal := to_heal diff group [ i ] else
87573: LD_ADDR_VAR 0 30
87577: PUSH
87578: LD_VAR 0 30
87582: PUSH
87583: LD_VAR 0 4
87587: PUSH
87588: LD_VAR 0 7
87592: ARRAY
87593: DIFF
87594: ST_TO_ADDR
87595: GO 87659
// begin if not IsInArea ( group [ i ] , to_heal ) then
87597: LD_VAR 0 4
87601: PUSH
87602: LD_VAR 0 7
87606: ARRAY
87607: PPUSH
87608: LD_VAR 0 30
87612: PPUSH
87613: CALL_OW 308
87617: NOT
87618: IFFALSE 87642
// ComMoveToArea ( group [ i ] , f_heal ) else
87620: LD_VAR 0 4
87624: PUSH
87625: LD_VAR 0 7
87629: ARRAY
87630: PPUSH
87631: LD_VAR 0 23
87635: PPUSH
87636: CALL_OW 113
87640: GO 87657
// ComHold ( group [ i ] ) ;
87642: LD_VAR 0 4
87646: PUSH
87647: LD_VAR 0 7
87651: ARRAY
87652: PPUSH
87653: CALL_OW 140
// continue ;
87657: GO 86501
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
87659: LD_VAR 0 4
87663: PUSH
87664: LD_VAR 0 7
87668: ARRAY
87669: PPUSH
87670: LD_INT 10
87672: PPUSH
87673: CALL 84279 0 2
87677: NOT
87678: PUSH
87679: LD_VAR 0 16
87683: PUSH
87684: LD_VAR 0 7
87688: ARRAY
87689: PUSH
87690: EMPTY
87691: EQUAL
87692: NOT
87693: AND
87694: IFFALSE 87960
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
87696: LD_VAR 0 4
87700: PUSH
87701: LD_VAR 0 7
87705: ARRAY
87706: PPUSH
87707: CALL_OW 262
87711: PUSH
87712: LD_INT 1
87714: PUSH
87715: LD_INT 2
87717: PUSH
87718: EMPTY
87719: LIST
87720: LIST
87721: IN
87722: IFFALSE 87763
// if GetFuel ( group [ i ] ) < 10 then
87724: LD_VAR 0 4
87728: PUSH
87729: LD_VAR 0 7
87733: ARRAY
87734: PPUSH
87735: CALL_OW 261
87739: PUSH
87740: LD_INT 10
87742: LESS
87743: IFFALSE 87763
// SetFuel ( group [ i ] , 12 ) ;
87745: LD_VAR 0 4
87749: PUSH
87750: LD_VAR 0 7
87754: ARRAY
87755: PPUSH
87756: LD_INT 12
87758: PPUSH
87759: CALL_OW 240
// if units_path [ i ] then
87763: LD_VAR 0 16
87767: PUSH
87768: LD_VAR 0 7
87772: ARRAY
87773: IFFALSE 87958
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
87775: LD_VAR 0 4
87779: PUSH
87780: LD_VAR 0 7
87784: ARRAY
87785: PPUSH
87786: LD_VAR 0 16
87790: PUSH
87791: LD_VAR 0 7
87795: ARRAY
87796: PUSH
87797: LD_INT 1
87799: ARRAY
87800: PUSH
87801: LD_INT 1
87803: ARRAY
87804: PPUSH
87805: LD_VAR 0 16
87809: PUSH
87810: LD_VAR 0 7
87814: ARRAY
87815: PUSH
87816: LD_INT 1
87818: ARRAY
87819: PUSH
87820: LD_INT 2
87822: ARRAY
87823: PPUSH
87824: CALL_OW 297
87828: PUSH
87829: LD_INT 6
87831: GREATER
87832: IFFALSE 87907
// begin if not HasTask ( group [ i ] ) then
87834: LD_VAR 0 4
87838: PUSH
87839: LD_VAR 0 7
87843: ARRAY
87844: PPUSH
87845: CALL_OW 314
87849: NOT
87850: IFFALSE 87905
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
87852: LD_VAR 0 4
87856: PUSH
87857: LD_VAR 0 7
87861: ARRAY
87862: PPUSH
87863: LD_VAR 0 16
87867: PUSH
87868: LD_VAR 0 7
87872: ARRAY
87873: PUSH
87874: LD_INT 1
87876: ARRAY
87877: PUSH
87878: LD_INT 1
87880: ARRAY
87881: PPUSH
87882: LD_VAR 0 16
87886: PUSH
87887: LD_VAR 0 7
87891: ARRAY
87892: PUSH
87893: LD_INT 1
87895: ARRAY
87896: PUSH
87897: LD_INT 2
87899: ARRAY
87900: PPUSH
87901: CALL_OW 114
// end else
87905: GO 87958
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
87907: LD_ADDR_VAR 0 15
87911: PUSH
87912: LD_VAR 0 16
87916: PUSH
87917: LD_VAR 0 7
87921: ARRAY
87922: PPUSH
87923: LD_INT 1
87925: PPUSH
87926: CALL_OW 3
87930: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
87931: LD_ADDR_VAR 0 16
87935: PUSH
87936: LD_VAR 0 16
87940: PPUSH
87941: LD_VAR 0 7
87945: PPUSH
87946: LD_VAR 0 15
87950: PPUSH
87951: CALL_OW 1
87955: ST_TO_ADDR
// continue ;
87956: GO 86501
// end ; end ; end else
87958: GO 90596
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
87960: LD_ADDR_VAR 0 14
87964: PUSH
87965: LD_INT 81
87967: PUSH
87968: LD_VAR 0 4
87972: PUSH
87973: LD_VAR 0 7
87977: ARRAY
87978: PPUSH
87979: CALL_OW 255
87983: PUSH
87984: EMPTY
87985: LIST
87986: LIST
87987: PPUSH
87988: CALL_OW 69
87992: ST_TO_ADDR
// if not tmp then
87993: LD_VAR 0 14
87997: NOT
87998: IFFALSE 88002
// continue ;
88000: GO 86501
// if f_ignore_area then
88002: LD_VAR 0 17
88006: IFFALSE 88094
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
88008: LD_ADDR_VAR 0 15
88012: PUSH
88013: LD_VAR 0 14
88017: PPUSH
88018: LD_INT 3
88020: PUSH
88021: LD_INT 92
88023: PUSH
88024: LD_VAR 0 17
88028: PUSH
88029: LD_INT 1
88031: ARRAY
88032: PUSH
88033: LD_VAR 0 17
88037: PUSH
88038: LD_INT 2
88040: ARRAY
88041: PUSH
88042: LD_VAR 0 17
88046: PUSH
88047: LD_INT 3
88049: ARRAY
88050: PUSH
88051: EMPTY
88052: LIST
88053: LIST
88054: LIST
88055: LIST
88056: PUSH
88057: EMPTY
88058: LIST
88059: LIST
88060: PPUSH
88061: CALL_OW 72
88065: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
88066: LD_VAR 0 14
88070: PUSH
88071: LD_VAR 0 15
88075: DIFF
88076: IFFALSE 88094
// tmp := tmp diff tmp2 ;
88078: LD_ADDR_VAR 0 14
88082: PUSH
88083: LD_VAR 0 14
88087: PUSH
88088: LD_VAR 0 15
88092: DIFF
88093: ST_TO_ADDR
// end ; if not f_murder then
88094: LD_VAR 0 20
88098: NOT
88099: IFFALSE 88157
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
88101: LD_ADDR_VAR 0 15
88105: PUSH
88106: LD_VAR 0 14
88110: PPUSH
88111: LD_INT 3
88113: PUSH
88114: LD_INT 50
88116: PUSH
88117: EMPTY
88118: LIST
88119: PUSH
88120: EMPTY
88121: LIST
88122: LIST
88123: PPUSH
88124: CALL_OW 72
88128: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
88129: LD_VAR 0 14
88133: PUSH
88134: LD_VAR 0 15
88138: DIFF
88139: IFFALSE 88157
// tmp := tmp diff tmp2 ;
88141: LD_ADDR_VAR 0 14
88145: PUSH
88146: LD_VAR 0 14
88150: PUSH
88151: LD_VAR 0 15
88155: DIFF
88156: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
88157: LD_ADDR_VAR 0 14
88161: PUSH
88162: LD_VAR 0 4
88166: PUSH
88167: LD_VAR 0 7
88171: ARRAY
88172: PPUSH
88173: LD_VAR 0 14
88177: PPUSH
88178: LD_INT 1
88180: PPUSH
88181: LD_INT 1
88183: PPUSH
88184: CALL 57922 0 4
88188: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
88189: LD_VAR 0 4
88193: PUSH
88194: LD_VAR 0 7
88198: ARRAY
88199: PPUSH
88200: CALL_OW 257
88204: PUSH
88205: LD_INT 1
88207: EQUAL
88208: IFFALSE 88656
// begin if WantPlant ( group [ i ] ) then
88210: LD_VAR 0 4
88214: PUSH
88215: LD_VAR 0 7
88219: ARRAY
88220: PPUSH
88221: CALL 57423 0 1
88225: IFFALSE 88229
// continue ;
88227: GO 86501
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
88229: LD_VAR 0 18
88233: PUSH
88234: LD_VAR 0 4
88238: PUSH
88239: LD_VAR 0 7
88243: ARRAY
88244: PPUSH
88245: CALL_OW 310
88249: NOT
88250: AND
88251: PUSH
88252: LD_VAR 0 14
88256: PUSH
88257: LD_INT 1
88259: ARRAY
88260: PUSH
88261: LD_VAR 0 14
88265: PPUSH
88266: LD_INT 21
88268: PUSH
88269: LD_INT 2
88271: PUSH
88272: EMPTY
88273: LIST
88274: LIST
88275: PUSH
88276: LD_INT 58
88278: PUSH
88279: EMPTY
88280: LIST
88281: PUSH
88282: EMPTY
88283: LIST
88284: LIST
88285: PPUSH
88286: CALL_OW 72
88290: IN
88291: AND
88292: IFFALSE 88328
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
88294: LD_VAR 0 4
88298: PUSH
88299: LD_VAR 0 7
88303: ARRAY
88304: PPUSH
88305: LD_VAR 0 14
88309: PUSH
88310: LD_INT 1
88312: ARRAY
88313: PPUSH
88314: CALL_OW 120
// attacking := true ;
88318: LD_ADDR_VAR 0 29
88322: PUSH
88323: LD_INT 1
88325: ST_TO_ADDR
// continue ;
88326: GO 86501
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
88328: LD_VAR 0 26
88332: PUSH
88333: LD_VAR 0 4
88337: PUSH
88338: LD_VAR 0 7
88342: ARRAY
88343: PPUSH
88344: CALL_OW 257
88348: PUSH
88349: LD_INT 1
88351: EQUAL
88352: AND
88353: PUSH
88354: LD_VAR 0 4
88358: PUSH
88359: LD_VAR 0 7
88363: ARRAY
88364: PPUSH
88365: CALL_OW 256
88369: PUSH
88370: LD_INT 800
88372: LESS
88373: AND
88374: PUSH
88375: LD_VAR 0 4
88379: PUSH
88380: LD_VAR 0 7
88384: ARRAY
88385: PPUSH
88386: CALL_OW 318
88390: NOT
88391: AND
88392: IFFALSE 88409
// ComCrawl ( group [ i ] ) ;
88394: LD_VAR 0 4
88398: PUSH
88399: LD_VAR 0 7
88403: ARRAY
88404: PPUSH
88405: CALL_OW 137
// if f_mines then
88409: LD_VAR 0 21
88413: IFFALSE 88656
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
88415: LD_VAR 0 14
88419: PUSH
88420: LD_INT 1
88422: ARRAY
88423: PPUSH
88424: CALL_OW 247
88428: PUSH
88429: LD_INT 3
88431: EQUAL
88432: PUSH
88433: LD_VAR 0 14
88437: PUSH
88438: LD_INT 1
88440: ARRAY
88441: PUSH
88442: LD_VAR 0 27
88446: IN
88447: NOT
88448: AND
88449: IFFALSE 88656
// begin x := GetX ( tmp [ 1 ] ) ;
88451: LD_ADDR_VAR 0 10
88455: PUSH
88456: LD_VAR 0 14
88460: PUSH
88461: LD_INT 1
88463: ARRAY
88464: PPUSH
88465: CALL_OW 250
88469: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
88470: LD_ADDR_VAR 0 11
88474: PUSH
88475: LD_VAR 0 14
88479: PUSH
88480: LD_INT 1
88482: ARRAY
88483: PPUSH
88484: CALL_OW 251
88488: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
88489: LD_ADDR_VAR 0 12
88493: PUSH
88494: LD_VAR 0 4
88498: PUSH
88499: LD_VAR 0 7
88503: ARRAY
88504: PPUSH
88505: CALL 84364 0 1
88509: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
88510: LD_VAR 0 4
88514: PUSH
88515: LD_VAR 0 7
88519: ARRAY
88520: PPUSH
88521: LD_VAR 0 10
88525: PPUSH
88526: LD_VAR 0 11
88530: PPUSH
88531: LD_VAR 0 14
88535: PUSH
88536: LD_INT 1
88538: ARRAY
88539: PPUSH
88540: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
88544: LD_VAR 0 4
88548: PUSH
88549: LD_VAR 0 7
88553: ARRAY
88554: PPUSH
88555: LD_VAR 0 10
88559: PPUSH
88560: LD_VAR 0 12
88564: PPUSH
88565: LD_INT 7
88567: PPUSH
88568: CALL_OW 272
88572: PPUSH
88573: LD_VAR 0 11
88577: PPUSH
88578: LD_VAR 0 12
88582: PPUSH
88583: LD_INT 7
88585: PPUSH
88586: CALL_OW 273
88590: PPUSH
88591: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
88595: LD_VAR 0 4
88599: PUSH
88600: LD_VAR 0 7
88604: ARRAY
88605: PPUSH
88606: LD_INT 71
88608: PPUSH
88609: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
88613: LD_ADDR_VAR 0 27
88617: PUSH
88618: LD_VAR 0 27
88622: PPUSH
88623: LD_VAR 0 27
88627: PUSH
88628: LD_INT 1
88630: PLUS
88631: PPUSH
88632: LD_VAR 0 14
88636: PUSH
88637: LD_INT 1
88639: ARRAY
88640: PPUSH
88641: CALL_OW 1
88645: ST_TO_ADDR
// attacking := true ;
88646: LD_ADDR_VAR 0 29
88650: PUSH
88651: LD_INT 1
88653: ST_TO_ADDR
// continue ;
88654: GO 86501
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
88656: LD_VAR 0 4
88660: PUSH
88661: LD_VAR 0 7
88665: ARRAY
88666: PPUSH
88667: CALL_OW 257
88671: PUSH
88672: LD_INT 17
88674: EQUAL
88675: PUSH
88676: LD_VAR 0 4
88680: PUSH
88681: LD_VAR 0 7
88685: ARRAY
88686: PPUSH
88687: CALL_OW 110
88691: PUSH
88692: LD_INT 71
88694: EQUAL
88695: NOT
88696: AND
88697: IFFALSE 88843
// begin attacking := false ;
88699: LD_ADDR_VAR 0 29
88703: PUSH
88704: LD_INT 0
88706: ST_TO_ADDR
// k := 5 ;
88707: LD_ADDR_VAR 0 9
88711: PUSH
88712: LD_INT 5
88714: ST_TO_ADDR
// if tmp < k then
88715: LD_VAR 0 14
88719: PUSH
88720: LD_VAR 0 9
88724: LESS
88725: IFFALSE 88737
// k := tmp ;
88727: LD_ADDR_VAR 0 9
88731: PUSH
88732: LD_VAR 0 14
88736: ST_TO_ADDR
// for j = 1 to k do
88737: LD_ADDR_VAR 0 8
88741: PUSH
88742: DOUBLE
88743: LD_INT 1
88745: DEC
88746: ST_TO_ADDR
88747: LD_VAR 0 9
88751: PUSH
88752: FOR_TO
88753: IFFALSE 88841
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
88755: LD_VAR 0 14
88759: PUSH
88760: LD_VAR 0 8
88764: ARRAY
88765: PUSH
88766: LD_VAR 0 14
88770: PPUSH
88771: LD_INT 58
88773: PUSH
88774: EMPTY
88775: LIST
88776: PPUSH
88777: CALL_OW 72
88781: IN
88782: NOT
88783: IFFALSE 88839
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
88785: LD_VAR 0 4
88789: PUSH
88790: LD_VAR 0 7
88794: ARRAY
88795: PPUSH
88796: LD_VAR 0 14
88800: PUSH
88801: LD_VAR 0 8
88805: ARRAY
88806: PPUSH
88807: CALL_OW 115
// attacking := true ;
88811: LD_ADDR_VAR 0 29
88815: PUSH
88816: LD_INT 1
88818: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
88819: LD_VAR 0 4
88823: PUSH
88824: LD_VAR 0 7
88828: ARRAY
88829: PPUSH
88830: LD_INT 71
88832: PPUSH
88833: CALL_OW 109
// continue ;
88837: GO 88752
// end ; end ;
88839: GO 88752
88841: POP
88842: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
88843: LD_VAR 0 4
88847: PUSH
88848: LD_VAR 0 7
88852: ARRAY
88853: PPUSH
88854: CALL_OW 257
88858: PUSH
88859: LD_INT 8
88861: EQUAL
88862: PUSH
88863: LD_VAR 0 4
88867: PUSH
88868: LD_VAR 0 7
88872: ARRAY
88873: PPUSH
88874: CALL_OW 264
88878: PUSH
88879: LD_INT 28
88881: PUSH
88882: LD_INT 45
88884: PUSH
88885: LD_INT 7
88887: PUSH
88888: LD_INT 47
88890: PUSH
88891: EMPTY
88892: LIST
88893: LIST
88894: LIST
88895: LIST
88896: IN
88897: OR
88898: IFFALSE 89128
// begin attacking := false ;
88900: LD_ADDR_VAR 0 29
88904: PUSH
88905: LD_INT 0
88907: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
88908: LD_VAR 0 14
88912: PUSH
88913: LD_INT 1
88915: ARRAY
88916: PPUSH
88917: CALL_OW 266
88921: PUSH
88922: LD_INT 32
88924: PUSH
88925: LD_INT 31
88927: PUSH
88928: LD_INT 33
88930: PUSH
88931: LD_INT 4
88933: PUSH
88934: LD_INT 5
88936: PUSH
88937: EMPTY
88938: LIST
88939: LIST
88940: LIST
88941: LIST
88942: LIST
88943: IN
88944: IFFALSE 89128
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
88946: LD_ADDR_VAR 0 9
88950: PUSH
88951: LD_VAR 0 14
88955: PUSH
88956: LD_INT 1
88958: ARRAY
88959: PPUSH
88960: CALL_OW 266
88964: PPUSH
88965: LD_VAR 0 14
88969: PUSH
88970: LD_INT 1
88972: ARRAY
88973: PPUSH
88974: CALL_OW 250
88978: PPUSH
88979: LD_VAR 0 14
88983: PUSH
88984: LD_INT 1
88986: ARRAY
88987: PPUSH
88988: CALL_OW 251
88992: PPUSH
88993: LD_VAR 0 14
88997: PUSH
88998: LD_INT 1
89000: ARRAY
89001: PPUSH
89002: CALL_OW 254
89006: PPUSH
89007: LD_VAR 0 14
89011: PUSH
89012: LD_INT 1
89014: ARRAY
89015: PPUSH
89016: CALL_OW 248
89020: PPUSH
89021: LD_INT 0
89023: PPUSH
89024: CALL 65734 0 6
89028: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
89029: LD_ADDR_VAR 0 8
89033: PUSH
89034: LD_VAR 0 4
89038: PUSH
89039: LD_VAR 0 7
89043: ARRAY
89044: PPUSH
89045: LD_VAR 0 9
89049: PPUSH
89050: CALL 84427 0 2
89054: ST_TO_ADDR
// if j then
89055: LD_VAR 0 8
89059: IFFALSE 89128
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
89061: LD_VAR 0 8
89065: PUSH
89066: LD_INT 1
89068: ARRAY
89069: PPUSH
89070: LD_VAR 0 8
89074: PUSH
89075: LD_INT 2
89077: ARRAY
89078: PPUSH
89079: CALL_OW 488
89083: IFFALSE 89128
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
89085: LD_VAR 0 4
89089: PUSH
89090: LD_VAR 0 7
89094: ARRAY
89095: PPUSH
89096: LD_VAR 0 8
89100: PUSH
89101: LD_INT 1
89103: ARRAY
89104: PPUSH
89105: LD_VAR 0 8
89109: PUSH
89110: LD_INT 2
89112: ARRAY
89113: PPUSH
89114: CALL_OW 116
// attacking := true ;
89118: LD_ADDR_VAR 0 29
89122: PUSH
89123: LD_INT 1
89125: ST_TO_ADDR
// continue ;
89126: GO 86501
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
89128: LD_VAR 0 4
89132: PUSH
89133: LD_VAR 0 7
89137: ARRAY
89138: PPUSH
89139: CALL_OW 265
89143: PUSH
89144: LD_INT 11
89146: EQUAL
89147: IFFALSE 89425
// begin k := 10 ;
89149: LD_ADDR_VAR 0 9
89153: PUSH
89154: LD_INT 10
89156: ST_TO_ADDR
// x := 0 ;
89157: LD_ADDR_VAR 0 10
89161: PUSH
89162: LD_INT 0
89164: ST_TO_ADDR
// if tmp < k then
89165: LD_VAR 0 14
89169: PUSH
89170: LD_VAR 0 9
89174: LESS
89175: IFFALSE 89187
// k := tmp ;
89177: LD_ADDR_VAR 0 9
89181: PUSH
89182: LD_VAR 0 14
89186: ST_TO_ADDR
// for j = k downto 1 do
89187: LD_ADDR_VAR 0 8
89191: PUSH
89192: DOUBLE
89193: LD_VAR 0 9
89197: INC
89198: ST_TO_ADDR
89199: LD_INT 1
89201: PUSH
89202: FOR_DOWNTO
89203: IFFALSE 89278
// begin if GetType ( tmp [ j ] ) = unit_human then
89205: LD_VAR 0 14
89209: PUSH
89210: LD_VAR 0 8
89214: ARRAY
89215: PPUSH
89216: CALL_OW 247
89220: PUSH
89221: LD_INT 1
89223: EQUAL
89224: IFFALSE 89276
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
89226: LD_VAR 0 4
89230: PUSH
89231: LD_VAR 0 7
89235: ARRAY
89236: PPUSH
89237: LD_VAR 0 14
89241: PUSH
89242: LD_VAR 0 8
89246: ARRAY
89247: PPUSH
89248: CALL 84698 0 2
// x := tmp [ j ] ;
89252: LD_ADDR_VAR 0 10
89256: PUSH
89257: LD_VAR 0 14
89261: PUSH
89262: LD_VAR 0 8
89266: ARRAY
89267: ST_TO_ADDR
// attacking := true ;
89268: LD_ADDR_VAR 0 29
89272: PUSH
89273: LD_INT 1
89275: ST_TO_ADDR
// end ; end ;
89276: GO 89202
89278: POP
89279: POP
// if not x then
89280: LD_VAR 0 10
89284: NOT
89285: IFFALSE 89425
// begin attacking := true ;
89287: LD_ADDR_VAR 0 29
89291: PUSH
89292: LD_INT 1
89294: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
89295: LD_VAR 0 4
89299: PUSH
89300: LD_VAR 0 7
89304: ARRAY
89305: PPUSH
89306: CALL_OW 250
89310: PPUSH
89311: LD_VAR 0 4
89315: PUSH
89316: LD_VAR 0 7
89320: ARRAY
89321: PPUSH
89322: CALL_OW 251
89326: PPUSH
89327: CALL_OW 546
89331: PUSH
89332: LD_INT 2
89334: ARRAY
89335: PUSH
89336: LD_VAR 0 14
89340: PUSH
89341: LD_INT 1
89343: ARRAY
89344: PPUSH
89345: CALL_OW 250
89349: PPUSH
89350: LD_VAR 0 14
89354: PUSH
89355: LD_INT 1
89357: ARRAY
89358: PPUSH
89359: CALL_OW 251
89363: PPUSH
89364: CALL_OW 546
89368: PUSH
89369: LD_INT 2
89371: ARRAY
89372: EQUAL
89373: IFFALSE 89401
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
89375: LD_VAR 0 4
89379: PUSH
89380: LD_VAR 0 7
89384: ARRAY
89385: PPUSH
89386: LD_VAR 0 14
89390: PUSH
89391: LD_INT 1
89393: ARRAY
89394: PPUSH
89395: CALL 84698 0 2
89399: GO 89425
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
89401: LD_VAR 0 4
89405: PUSH
89406: LD_VAR 0 7
89410: ARRAY
89411: PPUSH
89412: LD_VAR 0 14
89416: PUSH
89417: LD_INT 1
89419: ARRAY
89420: PPUSH
89421: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
89425: LD_VAR 0 4
89429: PUSH
89430: LD_VAR 0 7
89434: ARRAY
89435: PPUSH
89436: CALL_OW 264
89440: PUSH
89441: LD_INT 29
89443: EQUAL
89444: IFFALSE 89810
// begin if WantsToAttack ( group [ i ] ) in bombed then
89446: LD_VAR 0 4
89450: PUSH
89451: LD_VAR 0 7
89455: ARRAY
89456: PPUSH
89457: CALL_OW 319
89461: PUSH
89462: LD_VAR 0 28
89466: IN
89467: IFFALSE 89471
// continue ;
89469: GO 86501
// k := 8 ;
89471: LD_ADDR_VAR 0 9
89475: PUSH
89476: LD_INT 8
89478: ST_TO_ADDR
// x := 0 ;
89479: LD_ADDR_VAR 0 10
89483: PUSH
89484: LD_INT 0
89486: ST_TO_ADDR
// if tmp < k then
89487: LD_VAR 0 14
89491: PUSH
89492: LD_VAR 0 9
89496: LESS
89497: IFFALSE 89509
// k := tmp ;
89499: LD_ADDR_VAR 0 9
89503: PUSH
89504: LD_VAR 0 14
89508: ST_TO_ADDR
// for j = 1 to k do
89509: LD_ADDR_VAR 0 8
89513: PUSH
89514: DOUBLE
89515: LD_INT 1
89517: DEC
89518: ST_TO_ADDR
89519: LD_VAR 0 9
89523: PUSH
89524: FOR_TO
89525: IFFALSE 89657
// begin if GetType ( tmp [ j ] ) = unit_building then
89527: LD_VAR 0 14
89531: PUSH
89532: LD_VAR 0 8
89536: ARRAY
89537: PPUSH
89538: CALL_OW 247
89542: PUSH
89543: LD_INT 3
89545: EQUAL
89546: IFFALSE 89655
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
89548: LD_VAR 0 14
89552: PUSH
89553: LD_VAR 0 8
89557: ARRAY
89558: PUSH
89559: LD_VAR 0 28
89563: IN
89564: NOT
89565: PUSH
89566: LD_VAR 0 14
89570: PUSH
89571: LD_VAR 0 8
89575: ARRAY
89576: PPUSH
89577: CALL_OW 313
89581: AND
89582: IFFALSE 89655
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
89584: LD_VAR 0 4
89588: PUSH
89589: LD_VAR 0 7
89593: ARRAY
89594: PPUSH
89595: LD_VAR 0 14
89599: PUSH
89600: LD_VAR 0 8
89604: ARRAY
89605: PPUSH
89606: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
89610: LD_ADDR_VAR 0 28
89614: PUSH
89615: LD_VAR 0 28
89619: PPUSH
89620: LD_VAR 0 28
89624: PUSH
89625: LD_INT 1
89627: PLUS
89628: PPUSH
89629: LD_VAR 0 14
89633: PUSH
89634: LD_VAR 0 8
89638: ARRAY
89639: PPUSH
89640: CALL_OW 1
89644: ST_TO_ADDR
// attacking := true ;
89645: LD_ADDR_VAR 0 29
89649: PUSH
89650: LD_INT 1
89652: ST_TO_ADDR
// break ;
89653: GO 89657
// end ; end ;
89655: GO 89524
89657: POP
89658: POP
// if not attacking and f_attack_depot then
89659: LD_VAR 0 29
89663: NOT
89664: PUSH
89665: LD_VAR 0 25
89669: AND
89670: IFFALSE 89765
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
89672: LD_ADDR_VAR 0 13
89676: PUSH
89677: LD_VAR 0 14
89681: PPUSH
89682: LD_INT 2
89684: PUSH
89685: LD_INT 30
89687: PUSH
89688: LD_INT 0
89690: PUSH
89691: EMPTY
89692: LIST
89693: LIST
89694: PUSH
89695: LD_INT 30
89697: PUSH
89698: LD_INT 1
89700: PUSH
89701: EMPTY
89702: LIST
89703: LIST
89704: PUSH
89705: EMPTY
89706: LIST
89707: LIST
89708: LIST
89709: PPUSH
89710: CALL_OW 72
89714: ST_TO_ADDR
// if z then
89715: LD_VAR 0 13
89719: IFFALSE 89765
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
89721: LD_VAR 0 4
89725: PUSH
89726: LD_VAR 0 7
89730: ARRAY
89731: PPUSH
89732: LD_VAR 0 13
89736: PPUSH
89737: LD_VAR 0 4
89741: PUSH
89742: LD_VAR 0 7
89746: ARRAY
89747: PPUSH
89748: CALL_OW 74
89752: PPUSH
89753: CALL_OW 115
// attacking := true ;
89757: LD_ADDR_VAR 0 29
89761: PUSH
89762: LD_INT 1
89764: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
89765: LD_VAR 0 4
89769: PUSH
89770: LD_VAR 0 7
89774: ARRAY
89775: PPUSH
89776: CALL_OW 256
89780: PUSH
89781: LD_INT 500
89783: LESS
89784: IFFALSE 89810
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
89786: LD_VAR 0 4
89790: PUSH
89791: LD_VAR 0 7
89795: ARRAY
89796: PPUSH
89797: LD_VAR 0 14
89801: PUSH
89802: LD_INT 1
89804: ARRAY
89805: PPUSH
89806: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
89810: LD_VAR 0 4
89814: PUSH
89815: LD_VAR 0 7
89819: ARRAY
89820: PPUSH
89821: CALL_OW 264
89825: PUSH
89826: LD_INT 49
89828: EQUAL
89829: IFFALSE 89950
// begin if not HasTask ( group [ i ] ) then
89831: LD_VAR 0 4
89835: PUSH
89836: LD_VAR 0 7
89840: ARRAY
89841: PPUSH
89842: CALL_OW 314
89846: NOT
89847: IFFALSE 89950
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
89849: LD_ADDR_VAR 0 9
89853: PUSH
89854: LD_INT 81
89856: PUSH
89857: LD_VAR 0 4
89861: PUSH
89862: LD_VAR 0 7
89866: ARRAY
89867: PPUSH
89868: CALL_OW 255
89872: PUSH
89873: EMPTY
89874: LIST
89875: LIST
89876: PPUSH
89877: CALL_OW 69
89881: PPUSH
89882: LD_VAR 0 4
89886: PUSH
89887: LD_VAR 0 7
89891: ARRAY
89892: PPUSH
89893: CALL_OW 74
89897: ST_TO_ADDR
// if k then
89898: LD_VAR 0 9
89902: IFFALSE 89950
// if GetDistUnits ( group [ i ] , k ) > 10 then
89904: LD_VAR 0 4
89908: PUSH
89909: LD_VAR 0 7
89913: ARRAY
89914: PPUSH
89915: LD_VAR 0 9
89919: PPUSH
89920: CALL_OW 296
89924: PUSH
89925: LD_INT 10
89927: GREATER
89928: IFFALSE 89950
// ComMoveUnit ( group [ i ] , k ) ;
89930: LD_VAR 0 4
89934: PUSH
89935: LD_VAR 0 7
89939: ARRAY
89940: PPUSH
89941: LD_VAR 0 9
89945: PPUSH
89946: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
89950: LD_VAR 0 4
89954: PUSH
89955: LD_VAR 0 7
89959: ARRAY
89960: PPUSH
89961: CALL_OW 256
89965: PUSH
89966: LD_INT 250
89968: LESS
89969: PUSH
89970: LD_VAR 0 4
89974: PUSH
89975: LD_VAR 0 7
89979: ARRAY
89980: PUSH
89981: LD_INT 21
89983: PUSH
89984: LD_INT 2
89986: PUSH
89987: EMPTY
89988: LIST
89989: LIST
89990: PUSH
89991: LD_INT 23
89993: PUSH
89994: LD_INT 2
89996: PUSH
89997: EMPTY
89998: LIST
89999: LIST
90000: PUSH
90001: EMPTY
90002: LIST
90003: LIST
90004: PPUSH
90005: CALL_OW 69
90009: IN
90010: AND
90011: IFFALSE 90136
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
90013: LD_ADDR_VAR 0 9
90017: PUSH
90018: LD_OWVAR 3
90022: PUSH
90023: LD_VAR 0 4
90027: PUSH
90028: LD_VAR 0 7
90032: ARRAY
90033: DIFF
90034: PPUSH
90035: LD_VAR 0 4
90039: PUSH
90040: LD_VAR 0 7
90044: ARRAY
90045: PPUSH
90046: CALL_OW 74
90050: ST_TO_ADDR
// if not k then
90051: LD_VAR 0 9
90055: NOT
90056: IFFALSE 90060
// continue ;
90058: GO 86501
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
90060: LD_VAR 0 9
90064: PUSH
90065: LD_INT 81
90067: PUSH
90068: LD_VAR 0 4
90072: PUSH
90073: LD_VAR 0 7
90077: ARRAY
90078: PPUSH
90079: CALL_OW 255
90083: PUSH
90084: EMPTY
90085: LIST
90086: LIST
90087: PPUSH
90088: CALL_OW 69
90092: IN
90093: PUSH
90094: LD_VAR 0 9
90098: PPUSH
90099: LD_VAR 0 4
90103: PUSH
90104: LD_VAR 0 7
90108: ARRAY
90109: PPUSH
90110: CALL_OW 296
90114: PUSH
90115: LD_INT 5
90117: LESS
90118: AND
90119: IFFALSE 90136
// ComAutodestruct ( group [ i ] ) ;
90121: LD_VAR 0 4
90125: PUSH
90126: LD_VAR 0 7
90130: ARRAY
90131: PPUSH
90132: CALL 84596 0 1
// end ; if f_attack_depot then
90136: LD_VAR 0 25
90140: IFFALSE 90252
// begin k := 6 ;
90142: LD_ADDR_VAR 0 9
90146: PUSH
90147: LD_INT 6
90149: ST_TO_ADDR
// if tmp < k then
90150: LD_VAR 0 14
90154: PUSH
90155: LD_VAR 0 9
90159: LESS
90160: IFFALSE 90172
// k := tmp ;
90162: LD_ADDR_VAR 0 9
90166: PUSH
90167: LD_VAR 0 14
90171: ST_TO_ADDR
// for j = 1 to k do
90172: LD_ADDR_VAR 0 8
90176: PUSH
90177: DOUBLE
90178: LD_INT 1
90180: DEC
90181: ST_TO_ADDR
90182: LD_VAR 0 9
90186: PUSH
90187: FOR_TO
90188: IFFALSE 90250
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
90190: LD_VAR 0 8
90194: PPUSH
90195: CALL_OW 266
90199: PUSH
90200: LD_INT 0
90202: PUSH
90203: LD_INT 1
90205: PUSH
90206: EMPTY
90207: LIST
90208: LIST
90209: IN
90210: IFFALSE 90248
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
90212: LD_VAR 0 4
90216: PUSH
90217: LD_VAR 0 7
90221: ARRAY
90222: PPUSH
90223: LD_VAR 0 14
90227: PUSH
90228: LD_VAR 0 8
90232: ARRAY
90233: PPUSH
90234: CALL_OW 115
// attacking := true ;
90238: LD_ADDR_VAR 0 29
90242: PUSH
90243: LD_INT 1
90245: ST_TO_ADDR
// break ;
90246: GO 90250
// end ;
90248: GO 90187
90250: POP
90251: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
90252: LD_VAR 0 4
90256: PUSH
90257: LD_VAR 0 7
90261: ARRAY
90262: PPUSH
90263: CALL_OW 302
90267: PUSH
90268: LD_VAR 0 29
90272: NOT
90273: AND
90274: IFFALSE 90596
// begin if GetTag ( group [ i ] ) = 71 then
90276: LD_VAR 0 4
90280: PUSH
90281: LD_VAR 0 7
90285: ARRAY
90286: PPUSH
90287: CALL_OW 110
90291: PUSH
90292: LD_INT 71
90294: EQUAL
90295: IFFALSE 90336
// begin if HasTask ( group [ i ] ) then
90297: LD_VAR 0 4
90301: PUSH
90302: LD_VAR 0 7
90306: ARRAY
90307: PPUSH
90308: CALL_OW 314
90312: IFFALSE 90318
// continue else
90314: GO 86501
90316: GO 90336
// SetTag ( group [ i ] , 0 ) ;
90318: LD_VAR 0 4
90322: PUSH
90323: LD_VAR 0 7
90327: ARRAY
90328: PPUSH
90329: LD_INT 0
90331: PPUSH
90332: CALL_OW 109
// end ; k := 8 ;
90336: LD_ADDR_VAR 0 9
90340: PUSH
90341: LD_INT 8
90343: ST_TO_ADDR
// x := 0 ;
90344: LD_ADDR_VAR 0 10
90348: PUSH
90349: LD_INT 0
90351: ST_TO_ADDR
// if tmp < k then
90352: LD_VAR 0 14
90356: PUSH
90357: LD_VAR 0 9
90361: LESS
90362: IFFALSE 90374
// k := tmp ;
90364: LD_ADDR_VAR 0 9
90368: PUSH
90369: LD_VAR 0 14
90373: ST_TO_ADDR
// for j = 1 to k do
90374: LD_ADDR_VAR 0 8
90378: PUSH
90379: DOUBLE
90380: LD_INT 1
90382: DEC
90383: ST_TO_ADDR
90384: LD_VAR 0 9
90388: PUSH
90389: FOR_TO
90390: IFFALSE 90488
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
90392: LD_VAR 0 14
90396: PUSH
90397: LD_VAR 0 8
90401: ARRAY
90402: PPUSH
90403: CALL_OW 247
90407: PUSH
90408: LD_INT 1
90410: EQUAL
90411: PUSH
90412: LD_VAR 0 14
90416: PUSH
90417: LD_VAR 0 8
90421: ARRAY
90422: PPUSH
90423: CALL_OW 256
90427: PUSH
90428: LD_INT 250
90430: LESS
90431: PUSH
90432: LD_VAR 0 20
90436: AND
90437: PUSH
90438: LD_VAR 0 20
90442: NOT
90443: PUSH
90444: LD_VAR 0 14
90448: PUSH
90449: LD_VAR 0 8
90453: ARRAY
90454: PPUSH
90455: CALL_OW 256
90459: PUSH
90460: LD_INT 250
90462: GREATEREQUAL
90463: AND
90464: OR
90465: AND
90466: IFFALSE 90486
// begin x := tmp [ j ] ;
90468: LD_ADDR_VAR 0 10
90472: PUSH
90473: LD_VAR 0 14
90477: PUSH
90478: LD_VAR 0 8
90482: ARRAY
90483: ST_TO_ADDR
// break ;
90484: GO 90488
// end ;
90486: GO 90389
90488: POP
90489: POP
// if x then
90490: LD_VAR 0 10
90494: IFFALSE 90518
// ComAttackUnit ( group [ i ] , x ) else
90496: LD_VAR 0 4
90500: PUSH
90501: LD_VAR 0 7
90505: ARRAY
90506: PPUSH
90507: LD_VAR 0 10
90511: PPUSH
90512: CALL_OW 115
90516: GO 90542
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
90518: LD_VAR 0 4
90522: PUSH
90523: LD_VAR 0 7
90527: ARRAY
90528: PPUSH
90529: LD_VAR 0 14
90533: PUSH
90534: LD_INT 1
90536: ARRAY
90537: PPUSH
90538: CALL_OW 115
// if not HasTask ( group [ i ] ) then
90542: LD_VAR 0 4
90546: PUSH
90547: LD_VAR 0 7
90551: ARRAY
90552: PPUSH
90553: CALL_OW 314
90557: NOT
90558: IFFALSE 90596
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
90560: LD_VAR 0 4
90564: PUSH
90565: LD_VAR 0 7
90569: ARRAY
90570: PPUSH
90571: LD_VAR 0 14
90575: PPUSH
90576: LD_VAR 0 4
90580: PUSH
90581: LD_VAR 0 7
90585: ARRAY
90586: PPUSH
90587: CALL_OW 74
90591: PPUSH
90592: CALL_OW 115
// end ; end ; end ;
90596: GO 86501
90598: POP
90599: POP
// wait ( 0 0$1 ) ;
90600: LD_INT 35
90602: PPUSH
90603: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
90607: LD_VAR 0 4
90611: PUSH
90612: EMPTY
90613: EQUAL
90614: PUSH
90615: LD_INT 81
90617: PUSH
90618: LD_VAR 0 35
90622: PUSH
90623: EMPTY
90624: LIST
90625: LIST
90626: PPUSH
90627: CALL_OW 69
90631: NOT
90632: OR
90633: IFFALSE 86486
// end ;
90635: LD_VAR 0 2
90639: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
90640: LD_INT 0
90642: PPUSH
90643: PPUSH
90644: PPUSH
90645: PPUSH
// if not base_units then
90646: LD_VAR 0 1
90650: NOT
90651: IFFALSE 90655
// exit ;
90653: GO 90742
// result := false ;
90655: LD_ADDR_VAR 0 2
90659: PUSH
90660: LD_INT 0
90662: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
90663: LD_ADDR_VAR 0 5
90667: PUSH
90668: LD_VAR 0 1
90672: PPUSH
90673: LD_INT 21
90675: PUSH
90676: LD_INT 3
90678: PUSH
90679: EMPTY
90680: LIST
90681: LIST
90682: PPUSH
90683: CALL_OW 72
90687: ST_TO_ADDR
// if not tmp then
90688: LD_VAR 0 5
90692: NOT
90693: IFFALSE 90697
// exit ;
90695: GO 90742
// for i in tmp do
90697: LD_ADDR_VAR 0 3
90701: PUSH
90702: LD_VAR 0 5
90706: PUSH
90707: FOR_IN
90708: IFFALSE 90740
// begin result := EnemyInRange ( i , 22 ) ;
90710: LD_ADDR_VAR 0 2
90714: PUSH
90715: LD_VAR 0 3
90719: PPUSH
90720: LD_INT 22
90722: PPUSH
90723: CALL 84279 0 2
90727: ST_TO_ADDR
// if result then
90728: LD_VAR 0 2
90732: IFFALSE 90738
// exit ;
90734: POP
90735: POP
90736: GO 90742
// end ;
90738: GO 90707
90740: POP
90741: POP
// end ;
90742: LD_VAR 0 2
90746: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
90747: LD_INT 0
90749: PPUSH
90750: PPUSH
// if not units then
90751: LD_VAR 0 1
90755: NOT
90756: IFFALSE 90760
// exit ;
90758: GO 90830
// result := [ ] ;
90760: LD_ADDR_VAR 0 3
90764: PUSH
90765: EMPTY
90766: ST_TO_ADDR
// for i in units do
90767: LD_ADDR_VAR 0 4
90771: PUSH
90772: LD_VAR 0 1
90776: PUSH
90777: FOR_IN
90778: IFFALSE 90828
// if GetTag ( i ) = tag then
90780: LD_VAR 0 4
90784: PPUSH
90785: CALL_OW 110
90789: PUSH
90790: LD_VAR 0 2
90794: EQUAL
90795: IFFALSE 90826
// result := Insert ( result , result + 1 , i ) ;
90797: LD_ADDR_VAR 0 3
90801: PUSH
90802: LD_VAR 0 3
90806: PPUSH
90807: LD_VAR 0 3
90811: PUSH
90812: LD_INT 1
90814: PLUS
90815: PPUSH
90816: LD_VAR 0 4
90820: PPUSH
90821: CALL_OW 2
90825: ST_TO_ADDR
90826: GO 90777
90828: POP
90829: POP
// end ;
90830: LD_VAR 0 3
90834: RET
// export function IsDriver ( un ) ; begin
90835: LD_INT 0
90837: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
90838: LD_ADDR_VAR 0 2
90842: PUSH
90843: LD_VAR 0 1
90847: PUSH
90848: LD_INT 55
90850: PUSH
90851: EMPTY
90852: LIST
90853: PPUSH
90854: CALL_OW 69
90858: IN
90859: ST_TO_ADDR
// end ;
90860: LD_VAR 0 2
90864: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
90865: LD_INT 0
90867: PPUSH
90868: PPUSH
// list := [ ] ;
90869: LD_ADDR_VAR 0 5
90873: PUSH
90874: EMPTY
90875: ST_TO_ADDR
// case d of 0 :
90876: LD_VAR 0 3
90880: PUSH
90881: LD_INT 0
90883: DOUBLE
90884: EQUAL
90885: IFTRUE 90889
90887: GO 91022
90889: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
90890: LD_ADDR_VAR 0 5
90894: PUSH
90895: LD_VAR 0 1
90899: PUSH
90900: LD_INT 4
90902: MINUS
90903: PUSH
90904: LD_VAR 0 2
90908: PUSH
90909: LD_INT 4
90911: MINUS
90912: PUSH
90913: LD_INT 2
90915: PUSH
90916: EMPTY
90917: LIST
90918: LIST
90919: LIST
90920: PUSH
90921: LD_VAR 0 1
90925: PUSH
90926: LD_INT 3
90928: MINUS
90929: PUSH
90930: LD_VAR 0 2
90934: PUSH
90935: LD_INT 1
90937: PUSH
90938: EMPTY
90939: LIST
90940: LIST
90941: LIST
90942: PUSH
90943: LD_VAR 0 1
90947: PUSH
90948: LD_INT 4
90950: PLUS
90951: PUSH
90952: LD_VAR 0 2
90956: PUSH
90957: LD_INT 4
90959: PUSH
90960: EMPTY
90961: LIST
90962: LIST
90963: LIST
90964: PUSH
90965: LD_VAR 0 1
90969: PUSH
90970: LD_INT 3
90972: PLUS
90973: PUSH
90974: LD_VAR 0 2
90978: PUSH
90979: LD_INT 3
90981: PLUS
90982: PUSH
90983: LD_INT 5
90985: PUSH
90986: EMPTY
90987: LIST
90988: LIST
90989: LIST
90990: PUSH
90991: LD_VAR 0 1
90995: PUSH
90996: LD_VAR 0 2
91000: PUSH
91001: LD_INT 4
91003: PLUS
91004: PUSH
91005: LD_INT 0
91007: PUSH
91008: EMPTY
91009: LIST
91010: LIST
91011: LIST
91012: PUSH
91013: EMPTY
91014: LIST
91015: LIST
91016: LIST
91017: LIST
91018: LIST
91019: ST_TO_ADDR
// end ; 1 :
91020: GO 91720
91022: LD_INT 1
91024: DOUBLE
91025: EQUAL
91026: IFTRUE 91030
91028: GO 91163
91030: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
91031: LD_ADDR_VAR 0 5
91035: PUSH
91036: LD_VAR 0 1
91040: PUSH
91041: LD_VAR 0 2
91045: PUSH
91046: LD_INT 4
91048: MINUS
91049: PUSH
91050: LD_INT 3
91052: PUSH
91053: EMPTY
91054: LIST
91055: LIST
91056: LIST
91057: PUSH
91058: LD_VAR 0 1
91062: PUSH
91063: LD_INT 3
91065: MINUS
91066: PUSH
91067: LD_VAR 0 2
91071: PUSH
91072: LD_INT 3
91074: MINUS
91075: PUSH
91076: LD_INT 2
91078: PUSH
91079: EMPTY
91080: LIST
91081: LIST
91082: LIST
91083: PUSH
91084: LD_VAR 0 1
91088: PUSH
91089: LD_INT 4
91091: MINUS
91092: PUSH
91093: LD_VAR 0 2
91097: PUSH
91098: LD_INT 1
91100: PUSH
91101: EMPTY
91102: LIST
91103: LIST
91104: LIST
91105: PUSH
91106: LD_VAR 0 1
91110: PUSH
91111: LD_VAR 0 2
91115: PUSH
91116: LD_INT 3
91118: PLUS
91119: PUSH
91120: LD_INT 0
91122: PUSH
91123: EMPTY
91124: LIST
91125: LIST
91126: LIST
91127: PUSH
91128: LD_VAR 0 1
91132: PUSH
91133: LD_INT 4
91135: PLUS
91136: PUSH
91137: LD_VAR 0 2
91141: PUSH
91142: LD_INT 4
91144: PLUS
91145: PUSH
91146: LD_INT 5
91148: PUSH
91149: EMPTY
91150: LIST
91151: LIST
91152: LIST
91153: PUSH
91154: EMPTY
91155: LIST
91156: LIST
91157: LIST
91158: LIST
91159: LIST
91160: ST_TO_ADDR
// end ; 2 :
91161: GO 91720
91163: LD_INT 2
91165: DOUBLE
91166: EQUAL
91167: IFTRUE 91171
91169: GO 91300
91171: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
91172: LD_ADDR_VAR 0 5
91176: PUSH
91177: LD_VAR 0 1
91181: PUSH
91182: LD_VAR 0 2
91186: PUSH
91187: LD_INT 3
91189: MINUS
91190: PUSH
91191: LD_INT 3
91193: PUSH
91194: EMPTY
91195: LIST
91196: LIST
91197: LIST
91198: PUSH
91199: LD_VAR 0 1
91203: PUSH
91204: LD_INT 4
91206: PLUS
91207: PUSH
91208: LD_VAR 0 2
91212: PUSH
91213: LD_INT 4
91215: PUSH
91216: EMPTY
91217: LIST
91218: LIST
91219: LIST
91220: PUSH
91221: LD_VAR 0 1
91225: PUSH
91226: LD_VAR 0 2
91230: PUSH
91231: LD_INT 4
91233: PLUS
91234: PUSH
91235: LD_INT 0
91237: PUSH
91238: EMPTY
91239: LIST
91240: LIST
91241: LIST
91242: PUSH
91243: LD_VAR 0 1
91247: PUSH
91248: LD_INT 3
91250: MINUS
91251: PUSH
91252: LD_VAR 0 2
91256: PUSH
91257: LD_INT 1
91259: PUSH
91260: EMPTY
91261: LIST
91262: LIST
91263: LIST
91264: PUSH
91265: LD_VAR 0 1
91269: PUSH
91270: LD_INT 4
91272: MINUS
91273: PUSH
91274: LD_VAR 0 2
91278: PUSH
91279: LD_INT 4
91281: MINUS
91282: PUSH
91283: LD_INT 2
91285: PUSH
91286: EMPTY
91287: LIST
91288: LIST
91289: LIST
91290: PUSH
91291: EMPTY
91292: LIST
91293: LIST
91294: LIST
91295: LIST
91296: LIST
91297: ST_TO_ADDR
// end ; 3 :
91298: GO 91720
91300: LD_INT 3
91302: DOUBLE
91303: EQUAL
91304: IFTRUE 91308
91306: GO 91441
91308: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
91309: LD_ADDR_VAR 0 5
91313: PUSH
91314: LD_VAR 0 1
91318: PUSH
91319: LD_INT 3
91321: PLUS
91322: PUSH
91323: LD_VAR 0 2
91327: PUSH
91328: LD_INT 4
91330: PUSH
91331: EMPTY
91332: LIST
91333: LIST
91334: LIST
91335: PUSH
91336: LD_VAR 0 1
91340: PUSH
91341: LD_INT 4
91343: PLUS
91344: PUSH
91345: LD_VAR 0 2
91349: PUSH
91350: LD_INT 4
91352: PLUS
91353: PUSH
91354: LD_INT 5
91356: PUSH
91357: EMPTY
91358: LIST
91359: LIST
91360: LIST
91361: PUSH
91362: LD_VAR 0 1
91366: PUSH
91367: LD_INT 4
91369: MINUS
91370: PUSH
91371: LD_VAR 0 2
91375: PUSH
91376: LD_INT 1
91378: PUSH
91379: EMPTY
91380: LIST
91381: LIST
91382: LIST
91383: PUSH
91384: LD_VAR 0 1
91388: PUSH
91389: LD_VAR 0 2
91393: PUSH
91394: LD_INT 4
91396: MINUS
91397: PUSH
91398: LD_INT 3
91400: PUSH
91401: EMPTY
91402: LIST
91403: LIST
91404: LIST
91405: PUSH
91406: LD_VAR 0 1
91410: PUSH
91411: LD_INT 3
91413: MINUS
91414: PUSH
91415: LD_VAR 0 2
91419: PUSH
91420: LD_INT 3
91422: MINUS
91423: PUSH
91424: LD_INT 2
91426: PUSH
91427: EMPTY
91428: LIST
91429: LIST
91430: LIST
91431: PUSH
91432: EMPTY
91433: LIST
91434: LIST
91435: LIST
91436: LIST
91437: LIST
91438: ST_TO_ADDR
// end ; 4 :
91439: GO 91720
91441: LD_INT 4
91443: DOUBLE
91444: EQUAL
91445: IFTRUE 91449
91447: GO 91582
91449: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
91450: LD_ADDR_VAR 0 5
91454: PUSH
91455: LD_VAR 0 1
91459: PUSH
91460: LD_VAR 0 2
91464: PUSH
91465: LD_INT 4
91467: PLUS
91468: PUSH
91469: LD_INT 0
91471: PUSH
91472: EMPTY
91473: LIST
91474: LIST
91475: LIST
91476: PUSH
91477: LD_VAR 0 1
91481: PUSH
91482: LD_INT 3
91484: PLUS
91485: PUSH
91486: LD_VAR 0 2
91490: PUSH
91491: LD_INT 3
91493: PLUS
91494: PUSH
91495: LD_INT 5
91497: PUSH
91498: EMPTY
91499: LIST
91500: LIST
91501: LIST
91502: PUSH
91503: LD_VAR 0 1
91507: PUSH
91508: LD_INT 4
91510: PLUS
91511: PUSH
91512: LD_VAR 0 2
91516: PUSH
91517: LD_INT 4
91519: PUSH
91520: EMPTY
91521: LIST
91522: LIST
91523: LIST
91524: PUSH
91525: LD_VAR 0 1
91529: PUSH
91530: LD_VAR 0 2
91534: PUSH
91535: LD_INT 3
91537: MINUS
91538: PUSH
91539: LD_INT 3
91541: PUSH
91542: EMPTY
91543: LIST
91544: LIST
91545: LIST
91546: PUSH
91547: LD_VAR 0 1
91551: PUSH
91552: LD_INT 4
91554: MINUS
91555: PUSH
91556: LD_VAR 0 2
91560: PUSH
91561: LD_INT 4
91563: MINUS
91564: PUSH
91565: LD_INT 2
91567: PUSH
91568: EMPTY
91569: LIST
91570: LIST
91571: LIST
91572: PUSH
91573: EMPTY
91574: LIST
91575: LIST
91576: LIST
91577: LIST
91578: LIST
91579: ST_TO_ADDR
// end ; 5 :
91580: GO 91720
91582: LD_INT 5
91584: DOUBLE
91585: EQUAL
91586: IFTRUE 91590
91588: GO 91719
91590: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
91591: LD_ADDR_VAR 0 5
91595: PUSH
91596: LD_VAR 0 1
91600: PUSH
91601: LD_INT 4
91603: MINUS
91604: PUSH
91605: LD_VAR 0 2
91609: PUSH
91610: LD_INT 1
91612: PUSH
91613: EMPTY
91614: LIST
91615: LIST
91616: LIST
91617: PUSH
91618: LD_VAR 0 1
91622: PUSH
91623: LD_VAR 0 2
91627: PUSH
91628: LD_INT 4
91630: MINUS
91631: PUSH
91632: LD_INT 3
91634: PUSH
91635: EMPTY
91636: LIST
91637: LIST
91638: LIST
91639: PUSH
91640: LD_VAR 0 1
91644: PUSH
91645: LD_INT 4
91647: PLUS
91648: PUSH
91649: LD_VAR 0 2
91653: PUSH
91654: LD_INT 4
91656: PLUS
91657: PUSH
91658: LD_INT 5
91660: PUSH
91661: EMPTY
91662: LIST
91663: LIST
91664: LIST
91665: PUSH
91666: LD_VAR 0 1
91670: PUSH
91671: LD_INT 3
91673: PLUS
91674: PUSH
91675: LD_VAR 0 2
91679: PUSH
91680: LD_INT 4
91682: PUSH
91683: EMPTY
91684: LIST
91685: LIST
91686: LIST
91687: PUSH
91688: LD_VAR 0 1
91692: PUSH
91693: LD_VAR 0 2
91697: PUSH
91698: LD_INT 3
91700: PLUS
91701: PUSH
91702: LD_INT 0
91704: PUSH
91705: EMPTY
91706: LIST
91707: LIST
91708: LIST
91709: PUSH
91710: EMPTY
91711: LIST
91712: LIST
91713: LIST
91714: LIST
91715: LIST
91716: ST_TO_ADDR
// end ; end ;
91717: GO 91720
91719: POP
// result := list ;
91720: LD_ADDR_VAR 0 4
91724: PUSH
91725: LD_VAR 0 5
91729: ST_TO_ADDR
// end ;
91730: LD_VAR 0 4
91734: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
91735: LD_INT 0
91737: PPUSH
91738: PPUSH
91739: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
91740: LD_VAR 0 1
91744: NOT
91745: PUSH
91746: LD_VAR 0 2
91750: PUSH
91751: LD_INT 1
91753: PUSH
91754: LD_INT 2
91756: PUSH
91757: LD_INT 3
91759: PUSH
91760: LD_INT 4
91762: PUSH
91763: EMPTY
91764: LIST
91765: LIST
91766: LIST
91767: LIST
91768: IN
91769: NOT
91770: OR
91771: IFFALSE 91775
// exit ;
91773: GO 91867
// tmp := [ ] ;
91775: LD_ADDR_VAR 0 5
91779: PUSH
91780: EMPTY
91781: ST_TO_ADDR
// for i in units do
91782: LD_ADDR_VAR 0 4
91786: PUSH
91787: LD_VAR 0 1
91791: PUSH
91792: FOR_IN
91793: IFFALSE 91836
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
91795: LD_ADDR_VAR 0 5
91799: PUSH
91800: LD_VAR 0 5
91804: PPUSH
91805: LD_VAR 0 5
91809: PUSH
91810: LD_INT 1
91812: PLUS
91813: PPUSH
91814: LD_VAR 0 4
91818: PPUSH
91819: LD_VAR 0 2
91823: PPUSH
91824: CALL_OW 259
91828: PPUSH
91829: CALL_OW 2
91833: ST_TO_ADDR
91834: GO 91792
91836: POP
91837: POP
// if not tmp then
91838: LD_VAR 0 5
91842: NOT
91843: IFFALSE 91847
// exit ;
91845: GO 91867
// result := SortListByListDesc ( units , tmp ) ;
91847: LD_ADDR_VAR 0 3
91851: PUSH
91852: LD_VAR 0 1
91856: PPUSH
91857: LD_VAR 0 5
91861: PPUSH
91862: CALL_OW 77
91866: ST_TO_ADDR
// end ;
91867: LD_VAR 0 3
91871: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
91872: LD_INT 0
91874: PPUSH
91875: PPUSH
91876: PPUSH
// x := GetX ( building ) ;
91877: LD_ADDR_VAR 0 4
91881: PUSH
91882: LD_VAR 0 2
91886: PPUSH
91887: CALL_OW 250
91891: ST_TO_ADDR
// y := GetY ( building ) ;
91892: LD_ADDR_VAR 0 5
91896: PUSH
91897: LD_VAR 0 2
91901: PPUSH
91902: CALL_OW 251
91906: ST_TO_ADDR
// if GetTaskList ( unit ) then
91907: LD_VAR 0 1
91911: PPUSH
91912: CALL_OW 437
91916: IFFALSE 92011
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
91918: LD_STRING e
91920: PUSH
91921: LD_VAR 0 1
91925: PPUSH
91926: CALL_OW 437
91930: PUSH
91931: LD_INT 1
91933: ARRAY
91934: PUSH
91935: LD_INT 1
91937: ARRAY
91938: EQUAL
91939: PUSH
91940: LD_VAR 0 4
91944: PUSH
91945: LD_VAR 0 1
91949: PPUSH
91950: CALL_OW 437
91954: PUSH
91955: LD_INT 1
91957: ARRAY
91958: PUSH
91959: LD_INT 2
91961: ARRAY
91962: EQUAL
91963: AND
91964: PUSH
91965: LD_VAR 0 5
91969: PUSH
91970: LD_VAR 0 1
91974: PPUSH
91975: CALL_OW 437
91979: PUSH
91980: LD_INT 1
91982: ARRAY
91983: PUSH
91984: LD_INT 3
91986: ARRAY
91987: EQUAL
91988: AND
91989: IFFALSE 92001
// result := true else
91991: LD_ADDR_VAR 0 3
91995: PUSH
91996: LD_INT 1
91998: ST_TO_ADDR
91999: GO 92009
// result := false ;
92001: LD_ADDR_VAR 0 3
92005: PUSH
92006: LD_INT 0
92008: ST_TO_ADDR
// end else
92009: GO 92019
// result := false ;
92011: LD_ADDR_VAR 0 3
92015: PUSH
92016: LD_INT 0
92018: ST_TO_ADDR
// end ;
92019: LD_VAR 0 3
92023: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
92024: LD_INT 0
92026: PPUSH
92027: PPUSH
92028: PPUSH
92029: PPUSH
// if not unit or not area then
92030: LD_VAR 0 1
92034: NOT
92035: PUSH
92036: LD_VAR 0 2
92040: NOT
92041: OR
92042: IFFALSE 92046
// exit ;
92044: GO 92210
// tmp := AreaToList ( area , i ) ;
92046: LD_ADDR_VAR 0 6
92050: PUSH
92051: LD_VAR 0 2
92055: PPUSH
92056: LD_VAR 0 5
92060: PPUSH
92061: CALL_OW 517
92065: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
92066: LD_ADDR_VAR 0 5
92070: PUSH
92071: DOUBLE
92072: LD_INT 1
92074: DEC
92075: ST_TO_ADDR
92076: LD_VAR 0 6
92080: PUSH
92081: LD_INT 1
92083: ARRAY
92084: PUSH
92085: FOR_TO
92086: IFFALSE 92208
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
92088: LD_ADDR_VAR 0 7
92092: PUSH
92093: LD_VAR 0 6
92097: PUSH
92098: LD_INT 1
92100: ARRAY
92101: PUSH
92102: LD_VAR 0 5
92106: ARRAY
92107: PUSH
92108: LD_VAR 0 6
92112: PUSH
92113: LD_INT 2
92115: ARRAY
92116: PUSH
92117: LD_VAR 0 5
92121: ARRAY
92122: PUSH
92123: EMPTY
92124: LIST
92125: LIST
92126: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
92127: LD_VAR 0 7
92131: PUSH
92132: LD_INT 1
92134: ARRAY
92135: PPUSH
92136: LD_VAR 0 7
92140: PUSH
92141: LD_INT 2
92143: ARRAY
92144: PPUSH
92145: CALL_OW 428
92149: PUSH
92150: LD_INT 0
92152: EQUAL
92153: IFFALSE 92206
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
92155: LD_VAR 0 1
92159: PPUSH
92160: LD_VAR 0 7
92164: PUSH
92165: LD_INT 1
92167: ARRAY
92168: PPUSH
92169: LD_VAR 0 7
92173: PUSH
92174: LD_INT 2
92176: ARRAY
92177: PPUSH
92178: LD_VAR 0 3
92182: PPUSH
92183: CALL_OW 48
// result := IsPlaced ( unit ) ;
92187: LD_ADDR_VAR 0 4
92191: PUSH
92192: LD_VAR 0 1
92196: PPUSH
92197: CALL_OW 305
92201: ST_TO_ADDR
// exit ;
92202: POP
92203: POP
92204: GO 92210
// end ; end ;
92206: GO 92085
92208: POP
92209: POP
// end ;
92210: LD_VAR 0 4
92214: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
92215: LD_INT 0
92217: PPUSH
92218: PPUSH
92219: PPUSH
// if not side or side > 8 then
92220: LD_VAR 0 1
92224: NOT
92225: PUSH
92226: LD_VAR 0 1
92230: PUSH
92231: LD_INT 8
92233: GREATER
92234: OR
92235: IFFALSE 92239
// exit ;
92237: GO 92426
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
92239: LD_ADDR_VAR 0 4
92243: PUSH
92244: LD_INT 22
92246: PUSH
92247: LD_VAR 0 1
92251: PUSH
92252: EMPTY
92253: LIST
92254: LIST
92255: PUSH
92256: LD_INT 21
92258: PUSH
92259: LD_INT 3
92261: PUSH
92262: EMPTY
92263: LIST
92264: LIST
92265: PUSH
92266: EMPTY
92267: LIST
92268: LIST
92269: PPUSH
92270: CALL_OW 69
92274: ST_TO_ADDR
// if not tmp then
92275: LD_VAR 0 4
92279: NOT
92280: IFFALSE 92284
// exit ;
92282: GO 92426
// enable_addtolog := true ;
92284: LD_ADDR_OWVAR 81
92288: PUSH
92289: LD_INT 1
92291: ST_TO_ADDR
// AddToLog ( [ ) ;
92292: LD_STRING [
92294: PPUSH
92295: CALL_OW 561
// for i in tmp do
92299: LD_ADDR_VAR 0 3
92303: PUSH
92304: LD_VAR 0 4
92308: PUSH
92309: FOR_IN
92310: IFFALSE 92417
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
92312: LD_STRING [
92314: PUSH
92315: LD_VAR 0 3
92319: PPUSH
92320: CALL_OW 266
92324: STR
92325: PUSH
92326: LD_STRING , 
92328: STR
92329: PUSH
92330: LD_VAR 0 3
92334: PPUSH
92335: CALL_OW 250
92339: STR
92340: PUSH
92341: LD_STRING , 
92343: STR
92344: PUSH
92345: LD_VAR 0 3
92349: PPUSH
92350: CALL_OW 251
92354: STR
92355: PUSH
92356: LD_STRING , 
92358: STR
92359: PUSH
92360: LD_VAR 0 3
92364: PPUSH
92365: CALL_OW 254
92369: STR
92370: PUSH
92371: LD_STRING , 
92373: STR
92374: PUSH
92375: LD_VAR 0 3
92379: PPUSH
92380: LD_INT 1
92382: PPUSH
92383: CALL_OW 268
92387: STR
92388: PUSH
92389: LD_STRING , 
92391: STR
92392: PUSH
92393: LD_VAR 0 3
92397: PPUSH
92398: LD_INT 2
92400: PPUSH
92401: CALL_OW 268
92405: STR
92406: PUSH
92407: LD_STRING ],
92409: STR
92410: PPUSH
92411: CALL_OW 561
// end ;
92415: GO 92309
92417: POP
92418: POP
// AddToLog ( ]; ) ;
92419: LD_STRING ];
92421: PPUSH
92422: CALL_OW 561
// end ;
92426: LD_VAR 0 2
92430: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
92431: LD_INT 0
92433: PPUSH
92434: PPUSH
92435: PPUSH
92436: PPUSH
92437: PPUSH
// if not area or not rate or not max then
92438: LD_VAR 0 1
92442: NOT
92443: PUSH
92444: LD_VAR 0 2
92448: NOT
92449: OR
92450: PUSH
92451: LD_VAR 0 4
92455: NOT
92456: OR
92457: IFFALSE 92461
// exit ;
92459: GO 92653
// while 1 do
92461: LD_INT 1
92463: IFFALSE 92653
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
92465: LD_ADDR_VAR 0 9
92469: PUSH
92470: LD_VAR 0 1
92474: PPUSH
92475: LD_INT 1
92477: PPUSH
92478: CALL_OW 287
92482: PUSH
92483: LD_INT 10
92485: MUL
92486: ST_TO_ADDR
// r := rate / 10 ;
92487: LD_ADDR_VAR 0 7
92491: PUSH
92492: LD_VAR 0 2
92496: PUSH
92497: LD_INT 10
92499: DIVREAL
92500: ST_TO_ADDR
// time := 1 1$00 ;
92501: LD_ADDR_VAR 0 8
92505: PUSH
92506: LD_INT 2100
92508: ST_TO_ADDR
// if amount < min then
92509: LD_VAR 0 9
92513: PUSH
92514: LD_VAR 0 3
92518: LESS
92519: IFFALSE 92537
// r := r * 2 else
92521: LD_ADDR_VAR 0 7
92525: PUSH
92526: LD_VAR 0 7
92530: PUSH
92531: LD_INT 2
92533: MUL
92534: ST_TO_ADDR
92535: GO 92563
// if amount > max then
92537: LD_VAR 0 9
92541: PUSH
92542: LD_VAR 0 4
92546: GREATER
92547: IFFALSE 92563
// r := r / 2 ;
92549: LD_ADDR_VAR 0 7
92553: PUSH
92554: LD_VAR 0 7
92558: PUSH
92559: LD_INT 2
92561: DIVREAL
92562: ST_TO_ADDR
// time := time / r ;
92563: LD_ADDR_VAR 0 8
92567: PUSH
92568: LD_VAR 0 8
92572: PUSH
92573: LD_VAR 0 7
92577: DIVREAL
92578: ST_TO_ADDR
// if time < 0 then
92579: LD_VAR 0 8
92583: PUSH
92584: LD_INT 0
92586: LESS
92587: IFFALSE 92604
// time := time * - 1 ;
92589: LD_ADDR_VAR 0 8
92593: PUSH
92594: LD_VAR 0 8
92598: PUSH
92599: LD_INT 1
92601: NEG
92602: MUL
92603: ST_TO_ADDR
// wait ( time ) ;
92604: LD_VAR 0 8
92608: PPUSH
92609: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
92613: LD_INT 35
92615: PPUSH
92616: LD_INT 875
92618: PPUSH
92619: CALL_OW 12
92623: PPUSH
92624: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
92628: LD_INT 1
92630: PPUSH
92631: LD_INT 5
92633: PPUSH
92634: CALL_OW 12
92638: PPUSH
92639: LD_VAR 0 1
92643: PPUSH
92644: LD_INT 1
92646: PPUSH
92647: CALL_OW 55
// end ;
92651: GO 92461
// end ;
92653: LD_VAR 0 5
92657: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
92658: LD_INT 0
92660: PPUSH
92661: PPUSH
92662: PPUSH
92663: PPUSH
92664: PPUSH
92665: PPUSH
92666: PPUSH
92667: PPUSH
// if not turrets or not factories then
92668: LD_VAR 0 1
92672: NOT
92673: PUSH
92674: LD_VAR 0 2
92678: NOT
92679: OR
92680: IFFALSE 92684
// exit ;
92682: GO 92991
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
92684: LD_ADDR_VAR 0 10
92688: PUSH
92689: LD_INT 5
92691: PUSH
92692: LD_INT 6
92694: PUSH
92695: EMPTY
92696: LIST
92697: LIST
92698: PUSH
92699: LD_INT 2
92701: PUSH
92702: LD_INT 4
92704: PUSH
92705: EMPTY
92706: LIST
92707: LIST
92708: PUSH
92709: LD_INT 3
92711: PUSH
92712: LD_INT 5
92714: PUSH
92715: EMPTY
92716: LIST
92717: LIST
92718: PUSH
92719: EMPTY
92720: LIST
92721: LIST
92722: LIST
92723: PUSH
92724: LD_INT 24
92726: PUSH
92727: LD_INT 25
92729: PUSH
92730: EMPTY
92731: LIST
92732: LIST
92733: PUSH
92734: LD_INT 23
92736: PUSH
92737: LD_INT 27
92739: PUSH
92740: EMPTY
92741: LIST
92742: LIST
92743: PUSH
92744: EMPTY
92745: LIST
92746: LIST
92747: PUSH
92748: LD_INT 42
92750: PUSH
92751: LD_INT 43
92753: PUSH
92754: EMPTY
92755: LIST
92756: LIST
92757: PUSH
92758: LD_INT 44
92760: PUSH
92761: LD_INT 46
92763: PUSH
92764: EMPTY
92765: LIST
92766: LIST
92767: PUSH
92768: LD_INT 45
92770: PUSH
92771: LD_INT 47
92773: PUSH
92774: EMPTY
92775: LIST
92776: LIST
92777: PUSH
92778: EMPTY
92779: LIST
92780: LIST
92781: LIST
92782: PUSH
92783: EMPTY
92784: LIST
92785: LIST
92786: LIST
92787: ST_TO_ADDR
// result := [ ] ;
92788: LD_ADDR_VAR 0 3
92792: PUSH
92793: EMPTY
92794: ST_TO_ADDR
// for i in turrets do
92795: LD_ADDR_VAR 0 4
92799: PUSH
92800: LD_VAR 0 1
92804: PUSH
92805: FOR_IN
92806: IFFALSE 92989
// begin nat := GetNation ( i ) ;
92808: LD_ADDR_VAR 0 7
92812: PUSH
92813: LD_VAR 0 4
92817: PPUSH
92818: CALL_OW 248
92822: ST_TO_ADDR
// weapon := 0 ;
92823: LD_ADDR_VAR 0 8
92827: PUSH
92828: LD_INT 0
92830: ST_TO_ADDR
// if not nat then
92831: LD_VAR 0 7
92835: NOT
92836: IFFALSE 92840
// continue ;
92838: GO 92805
// for j in list [ nat ] do
92840: LD_ADDR_VAR 0 5
92844: PUSH
92845: LD_VAR 0 10
92849: PUSH
92850: LD_VAR 0 7
92854: ARRAY
92855: PUSH
92856: FOR_IN
92857: IFFALSE 92898
// if GetBWeapon ( i ) = j [ 1 ] then
92859: LD_VAR 0 4
92863: PPUSH
92864: CALL_OW 269
92868: PUSH
92869: LD_VAR 0 5
92873: PUSH
92874: LD_INT 1
92876: ARRAY
92877: EQUAL
92878: IFFALSE 92896
// begin weapon := j [ 2 ] ;
92880: LD_ADDR_VAR 0 8
92884: PUSH
92885: LD_VAR 0 5
92889: PUSH
92890: LD_INT 2
92892: ARRAY
92893: ST_TO_ADDR
// break ;
92894: GO 92898
// end ;
92896: GO 92856
92898: POP
92899: POP
// if not weapon then
92900: LD_VAR 0 8
92904: NOT
92905: IFFALSE 92909
// continue ;
92907: GO 92805
// for k in factories do
92909: LD_ADDR_VAR 0 6
92913: PUSH
92914: LD_VAR 0 2
92918: PUSH
92919: FOR_IN
92920: IFFALSE 92985
// begin weapons := AvailableWeaponList ( k ) ;
92922: LD_ADDR_VAR 0 9
92926: PUSH
92927: LD_VAR 0 6
92931: PPUSH
92932: CALL_OW 478
92936: ST_TO_ADDR
// if not weapons then
92937: LD_VAR 0 9
92941: NOT
92942: IFFALSE 92946
// continue ;
92944: GO 92919
// if weapon in weapons then
92946: LD_VAR 0 8
92950: PUSH
92951: LD_VAR 0 9
92955: IN
92956: IFFALSE 92983
// begin result := [ i , weapon ] ;
92958: LD_ADDR_VAR 0 3
92962: PUSH
92963: LD_VAR 0 4
92967: PUSH
92968: LD_VAR 0 8
92972: PUSH
92973: EMPTY
92974: LIST
92975: LIST
92976: ST_TO_ADDR
// exit ;
92977: POP
92978: POP
92979: POP
92980: POP
92981: GO 92991
// end ; end ;
92983: GO 92919
92985: POP
92986: POP
// end ;
92987: GO 92805
92989: POP
92990: POP
// end ;
92991: LD_VAR 0 3
92995: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
92996: LD_INT 0
92998: PPUSH
// if not side or side > 8 then
92999: LD_VAR 0 3
93003: NOT
93004: PUSH
93005: LD_VAR 0 3
93009: PUSH
93010: LD_INT 8
93012: GREATER
93013: OR
93014: IFFALSE 93018
// exit ;
93016: GO 93077
// if not range then
93018: LD_VAR 0 4
93022: NOT
93023: IFFALSE 93034
// range := - 12 ;
93025: LD_ADDR_VAR 0 4
93029: PUSH
93030: LD_INT 12
93032: NEG
93033: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
93034: LD_VAR 0 1
93038: PPUSH
93039: LD_VAR 0 2
93043: PPUSH
93044: LD_VAR 0 3
93048: PPUSH
93049: LD_VAR 0 4
93053: PPUSH
93054: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
93058: LD_VAR 0 1
93062: PPUSH
93063: LD_VAR 0 2
93067: PPUSH
93068: LD_VAR 0 3
93072: PPUSH
93073: CALL_OW 331
// end ;
93077: LD_VAR 0 5
93081: RET
// export function Video ( mode ) ; begin
93082: LD_INT 0
93084: PPUSH
// ingame_video = mode ;
93085: LD_ADDR_OWVAR 52
93089: PUSH
93090: LD_VAR 0 1
93094: ST_TO_ADDR
// interface_hidden = mode ;
93095: LD_ADDR_OWVAR 54
93099: PUSH
93100: LD_VAR 0 1
93104: ST_TO_ADDR
// end ;
93105: LD_VAR 0 2
93109: RET
// export function Join ( array , element ) ; begin
93110: LD_INT 0
93112: PPUSH
// result := array ^ element ;
93113: LD_ADDR_VAR 0 3
93117: PUSH
93118: LD_VAR 0 1
93122: PUSH
93123: LD_VAR 0 2
93127: ADD
93128: ST_TO_ADDR
// end ;
93129: LD_VAR 0 3
93133: RET
// export function JoinUnion ( array , element ) ; begin
93134: LD_INT 0
93136: PPUSH
// result := array union element ;
93137: LD_ADDR_VAR 0 3
93141: PUSH
93142: LD_VAR 0 1
93146: PUSH
93147: LD_VAR 0 2
93151: UNION
93152: ST_TO_ADDR
// end ;
93153: LD_VAR 0 3
93157: RET
// export function GetBehemoths ( side ) ; begin
93158: LD_INT 0
93160: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
93161: LD_ADDR_VAR 0 2
93165: PUSH
93166: LD_INT 22
93168: PUSH
93169: LD_VAR 0 1
93173: PUSH
93174: EMPTY
93175: LIST
93176: LIST
93177: PUSH
93178: LD_INT 31
93180: PUSH
93181: LD_INT 25
93183: PUSH
93184: EMPTY
93185: LIST
93186: LIST
93187: PUSH
93188: EMPTY
93189: LIST
93190: LIST
93191: PPUSH
93192: CALL_OW 69
93196: ST_TO_ADDR
// end ;
93197: LD_VAR 0 2
93201: RET
// export function Shuffle ( array ) ; var i , index ; begin
93202: LD_INT 0
93204: PPUSH
93205: PPUSH
93206: PPUSH
// result := [ ] ;
93207: LD_ADDR_VAR 0 2
93211: PUSH
93212: EMPTY
93213: ST_TO_ADDR
// if not array then
93214: LD_VAR 0 1
93218: NOT
93219: IFFALSE 93223
// exit ;
93221: GO 93322
// Randomize ;
93223: CALL_OW 10
// for i = array downto 1 do
93227: LD_ADDR_VAR 0 3
93231: PUSH
93232: DOUBLE
93233: LD_VAR 0 1
93237: INC
93238: ST_TO_ADDR
93239: LD_INT 1
93241: PUSH
93242: FOR_DOWNTO
93243: IFFALSE 93320
// begin index := rand ( 1 , array ) ;
93245: LD_ADDR_VAR 0 4
93249: PUSH
93250: LD_INT 1
93252: PPUSH
93253: LD_VAR 0 1
93257: PPUSH
93258: CALL_OW 12
93262: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
93263: LD_ADDR_VAR 0 2
93267: PUSH
93268: LD_VAR 0 2
93272: PPUSH
93273: LD_VAR 0 2
93277: PUSH
93278: LD_INT 1
93280: PLUS
93281: PPUSH
93282: LD_VAR 0 1
93286: PUSH
93287: LD_VAR 0 4
93291: ARRAY
93292: PPUSH
93293: CALL_OW 2
93297: ST_TO_ADDR
// array := Delete ( array , index ) ;
93298: LD_ADDR_VAR 0 1
93302: PUSH
93303: LD_VAR 0 1
93307: PPUSH
93308: LD_VAR 0 4
93312: PPUSH
93313: CALL_OW 3
93317: ST_TO_ADDR
// end ;
93318: GO 93242
93320: POP
93321: POP
// end ;
93322: LD_VAR 0 2
93326: RET
// export function GetBaseMaterials ( base ) ; begin
93327: LD_INT 0
93329: PPUSH
// result := [ 0 , 0 , 0 ] ;
93330: LD_ADDR_VAR 0 2
93334: PUSH
93335: LD_INT 0
93337: PUSH
93338: LD_INT 0
93340: PUSH
93341: LD_INT 0
93343: PUSH
93344: EMPTY
93345: LIST
93346: LIST
93347: LIST
93348: ST_TO_ADDR
// if not base then
93349: LD_VAR 0 1
93353: NOT
93354: IFFALSE 93358
// exit ;
93356: GO 93407
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
93358: LD_ADDR_VAR 0 2
93362: PUSH
93363: LD_VAR 0 1
93367: PPUSH
93368: LD_INT 1
93370: PPUSH
93371: CALL_OW 275
93375: PUSH
93376: LD_VAR 0 1
93380: PPUSH
93381: LD_INT 2
93383: PPUSH
93384: CALL_OW 275
93388: PUSH
93389: LD_VAR 0 1
93393: PPUSH
93394: LD_INT 3
93396: PPUSH
93397: CALL_OW 275
93401: PUSH
93402: EMPTY
93403: LIST
93404: LIST
93405: LIST
93406: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
93407: LD_VAR 0 2
93411: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
93412: LD_INT 0
93414: PPUSH
93415: PPUSH
93416: PPUSH
93417: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
93418: LD_VAR 0 1
93422: PPUSH
93423: CALL_OW 264
93427: PUSH
93428: LD_EXP 71
93432: EQUAL
93433: IFFALSE 93505
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
93435: LD_INT 68
93437: PPUSH
93438: LD_VAR 0 1
93442: PPUSH
93443: CALL_OW 255
93447: PPUSH
93448: CALL_OW 321
93452: PUSH
93453: LD_INT 2
93455: EQUAL
93456: IFFALSE 93468
// eff := 70 else
93458: LD_ADDR_VAR 0 6
93462: PUSH
93463: LD_INT 70
93465: ST_TO_ADDR
93466: GO 93476
// eff := 30 ;
93468: LD_ADDR_VAR 0 6
93472: PUSH
93473: LD_INT 30
93475: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
93476: LD_VAR 0 1
93480: PPUSH
93481: CALL_OW 250
93485: PPUSH
93486: LD_VAR 0 1
93490: PPUSH
93491: CALL_OW 251
93495: PPUSH
93496: LD_VAR 0 6
93500: PPUSH
93501: CALL_OW 495
// end ; end ;
93505: LD_VAR 0 4
93509: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
93510: LD_INT 0
93512: PPUSH
93513: PPUSH
93514: PPUSH
93515: PPUSH
93516: PPUSH
93517: PPUSH
// if cmd = 124 then
93518: LD_VAR 0 1
93522: PUSH
93523: LD_INT 124
93525: EQUAL
93526: IFFALSE 93732
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
93528: LD_ADDR_VAR 0 5
93532: PUSH
93533: LD_INT 2
93535: PUSH
93536: LD_INT 34
93538: PUSH
93539: LD_INT 53
93541: PUSH
93542: EMPTY
93543: LIST
93544: LIST
93545: PUSH
93546: LD_INT 34
93548: PUSH
93549: LD_INT 14
93551: PUSH
93552: EMPTY
93553: LIST
93554: LIST
93555: PUSH
93556: EMPTY
93557: LIST
93558: LIST
93559: LIST
93560: PPUSH
93561: CALL_OW 69
93565: ST_TO_ADDR
// if not tmp then
93566: LD_VAR 0 5
93570: NOT
93571: IFFALSE 93575
// exit ;
93573: GO 93732
// for i in tmp do
93575: LD_ADDR_VAR 0 3
93579: PUSH
93580: LD_VAR 0 5
93584: PUSH
93585: FOR_IN
93586: IFFALSE 93730
// begin taskList := GetTaskList ( i ) ;
93588: LD_ADDR_VAR 0 6
93592: PUSH
93593: LD_VAR 0 3
93597: PPUSH
93598: CALL_OW 437
93602: ST_TO_ADDR
// if not taskList then
93603: LD_VAR 0 6
93607: NOT
93608: IFFALSE 93612
// continue ;
93610: GO 93585
// for j = 1 to taskList do
93612: LD_ADDR_VAR 0 4
93616: PUSH
93617: DOUBLE
93618: LD_INT 1
93620: DEC
93621: ST_TO_ADDR
93622: LD_VAR 0 6
93626: PUSH
93627: FOR_TO
93628: IFFALSE 93726
// if taskList [ j ] [ 1 ] = | then
93630: LD_VAR 0 6
93634: PUSH
93635: LD_VAR 0 4
93639: ARRAY
93640: PUSH
93641: LD_INT 1
93643: ARRAY
93644: PUSH
93645: LD_STRING |
93647: EQUAL
93648: IFFALSE 93724
// begin _taskList := Delete ( taskList , 1 ) ;
93650: LD_ADDR_VAR 0 7
93654: PUSH
93655: LD_VAR 0 6
93659: PPUSH
93660: LD_INT 1
93662: PPUSH
93663: CALL_OW 3
93667: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
93668: LD_VAR 0 3
93672: PPUSH
93673: LD_VAR 0 7
93677: PPUSH
93678: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
93682: LD_VAR 0 3
93686: PPUSH
93687: LD_VAR 0 6
93691: PUSH
93692: LD_VAR 0 4
93696: ARRAY
93697: PUSH
93698: LD_INT 2
93700: ARRAY
93701: PPUSH
93702: LD_VAR 0 6
93706: PUSH
93707: LD_VAR 0 4
93711: ARRAY
93712: PUSH
93713: LD_INT 3
93715: ARRAY
93716: PPUSH
93717: LD_INT 8
93719: PPUSH
93720: CALL 93737 0 4
// end ;
93724: GO 93627
93726: POP
93727: POP
// end ;
93728: GO 93585
93730: POP
93731: POP
// end ; end ;
93732: LD_VAR 0 2
93736: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
93737: LD_INT 0
93739: PPUSH
93740: PPUSH
93741: PPUSH
93742: PPUSH
93743: PPUSH
93744: PPUSH
93745: PPUSH
93746: PPUSH
93747: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
93748: LD_VAR 0 1
93752: NOT
93753: PUSH
93754: LD_VAR 0 2
93758: PPUSH
93759: LD_VAR 0 3
93763: PPUSH
93764: CALL_OW 488
93768: NOT
93769: OR
93770: PUSH
93771: LD_VAR 0 4
93775: NOT
93776: OR
93777: IFFALSE 93781
// exit ;
93779: GO 94121
// list := [ ] ;
93781: LD_ADDR_VAR 0 13
93785: PUSH
93786: EMPTY
93787: ST_TO_ADDR
// if x - r < 0 then
93788: LD_VAR 0 2
93792: PUSH
93793: LD_VAR 0 4
93797: MINUS
93798: PUSH
93799: LD_INT 0
93801: LESS
93802: IFFALSE 93814
// min_x := 0 else
93804: LD_ADDR_VAR 0 7
93808: PUSH
93809: LD_INT 0
93811: ST_TO_ADDR
93812: GO 93830
// min_x := x - r ;
93814: LD_ADDR_VAR 0 7
93818: PUSH
93819: LD_VAR 0 2
93823: PUSH
93824: LD_VAR 0 4
93828: MINUS
93829: ST_TO_ADDR
// if y - r < 0 then
93830: LD_VAR 0 3
93834: PUSH
93835: LD_VAR 0 4
93839: MINUS
93840: PUSH
93841: LD_INT 0
93843: LESS
93844: IFFALSE 93856
// min_y := 0 else
93846: LD_ADDR_VAR 0 8
93850: PUSH
93851: LD_INT 0
93853: ST_TO_ADDR
93854: GO 93872
// min_y := y - r ;
93856: LD_ADDR_VAR 0 8
93860: PUSH
93861: LD_VAR 0 3
93865: PUSH
93866: LD_VAR 0 4
93870: MINUS
93871: ST_TO_ADDR
// max_x := x + r ;
93872: LD_ADDR_VAR 0 9
93876: PUSH
93877: LD_VAR 0 2
93881: PUSH
93882: LD_VAR 0 4
93886: PLUS
93887: ST_TO_ADDR
// max_y := y + r ;
93888: LD_ADDR_VAR 0 10
93892: PUSH
93893: LD_VAR 0 3
93897: PUSH
93898: LD_VAR 0 4
93902: PLUS
93903: ST_TO_ADDR
// for _x = min_x to max_x do
93904: LD_ADDR_VAR 0 11
93908: PUSH
93909: DOUBLE
93910: LD_VAR 0 7
93914: DEC
93915: ST_TO_ADDR
93916: LD_VAR 0 9
93920: PUSH
93921: FOR_TO
93922: IFFALSE 94039
// for _y = min_y to max_y do
93924: LD_ADDR_VAR 0 12
93928: PUSH
93929: DOUBLE
93930: LD_VAR 0 8
93934: DEC
93935: ST_TO_ADDR
93936: LD_VAR 0 10
93940: PUSH
93941: FOR_TO
93942: IFFALSE 94035
// begin if not ValidHex ( _x , _y ) then
93944: LD_VAR 0 11
93948: PPUSH
93949: LD_VAR 0 12
93953: PPUSH
93954: CALL_OW 488
93958: NOT
93959: IFFALSE 93963
// continue ;
93961: GO 93941
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
93963: LD_VAR 0 11
93967: PPUSH
93968: LD_VAR 0 12
93972: PPUSH
93973: CALL_OW 351
93977: PUSH
93978: LD_VAR 0 11
93982: PPUSH
93983: LD_VAR 0 12
93987: PPUSH
93988: CALL_OW 554
93992: AND
93993: IFFALSE 94033
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
93995: LD_ADDR_VAR 0 13
93999: PUSH
94000: LD_VAR 0 13
94004: PPUSH
94005: LD_VAR 0 13
94009: PUSH
94010: LD_INT 1
94012: PLUS
94013: PPUSH
94014: LD_VAR 0 11
94018: PUSH
94019: LD_VAR 0 12
94023: PUSH
94024: EMPTY
94025: LIST
94026: LIST
94027: PPUSH
94028: CALL_OW 2
94032: ST_TO_ADDR
// end ;
94033: GO 93941
94035: POP
94036: POP
94037: GO 93921
94039: POP
94040: POP
// if not list then
94041: LD_VAR 0 13
94045: NOT
94046: IFFALSE 94050
// exit ;
94048: GO 94121
// for i in list do
94050: LD_ADDR_VAR 0 6
94054: PUSH
94055: LD_VAR 0 13
94059: PUSH
94060: FOR_IN
94061: IFFALSE 94119
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
94063: LD_VAR 0 1
94067: PPUSH
94068: LD_STRING M
94070: PUSH
94071: LD_VAR 0 6
94075: PUSH
94076: LD_INT 1
94078: ARRAY
94079: PUSH
94080: LD_VAR 0 6
94084: PUSH
94085: LD_INT 2
94087: ARRAY
94088: PUSH
94089: LD_INT 0
94091: PUSH
94092: LD_INT 0
94094: PUSH
94095: LD_INT 0
94097: PUSH
94098: LD_INT 0
94100: PUSH
94101: EMPTY
94102: LIST
94103: LIST
94104: LIST
94105: LIST
94106: LIST
94107: LIST
94108: LIST
94109: PUSH
94110: EMPTY
94111: LIST
94112: PPUSH
94113: CALL_OW 447
94117: GO 94060
94119: POP
94120: POP
// end ;
94121: LD_VAR 0 5
94125: RET
