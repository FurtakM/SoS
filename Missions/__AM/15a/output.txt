// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitMacro ;
  15: CALL 20571 0 0
// InitNature ;
  19: CALL 17133 0 0
// InitArtifact ;
  23: CALL 17746 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAmerican ;
  40: CALL 4579 0 0
// PrepareAlliance ;
  44: CALL 1375 0 0
// PrepareArabian ;
  48: CALL 6347 0 0
// PrepareRussian ;
  52: CALL 8332 0 0
// PrepareLegion ;
  56: CALL 6775 0 0
// Action ;
  60: CALL 10885 0 0
// MC_Start ( ) ;
  64: CALL 22683 0 0
// end ;
  68: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  80: LD_ADDR_EXP 9
  84: PUSH
  85: LD_STRING 11_artifact_captured
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// russianDestroyed := false ;
  96: LD_ADDR_EXP 2
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// legionDestroyed := false ;
 104: LD_ADDR_EXP 3
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// americanDestroyed := false ;
 112: LD_ADDR_EXP 4
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// arabianDestroyed := false ;
 120: LD_ADDR_EXP 5
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// americanCapitulated := false ;
 128: LD_ADDR_EXP 6
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// russianCapitulated := false ;
 136: LD_ADDR_EXP 7
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// legionCapitulated := false ;
 144: LD_ADDR_EXP 8
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// artifactIResearched := false ;
 152: LD_ADDR_EXP 12
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// artifactIIResearched := false ;
 160: LD_ADDR_EXP 13
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// artifactIIIResearched := false ;
 168: LD_ADDR_EXP 14
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// alienSpotted := false ;
 176: LD_ADDR_EXP 10
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// spawnOmar := false ;
 184: LD_ADDR_EXP 11
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 192: LD_ADDR_EXP 15
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 200: LD_ADDR_EXP 16
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// end ;
 208: LD_VAR 0 1
 212: RET
// export function CustomInitMacro ( ) ; begin
 213: LD_INT 0
 215: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 216: LD_ADDR_EXP 111
 220: PUSH
 221: LD_INT 26
 223: PUSH
 224: LD_INT 1
 226: PUSH
 227: LD_INT 4
 229: PUSH
 230: LD_INT 8
 232: PUSH
 233: EMPTY
 234: LIST
 235: LIST
 236: LIST
 237: LIST
 238: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 239: LD_ADDR_EXP 112
 243: PUSH
 244: LD_INT 27
 246: PUSH
 247: LD_INT 2
 249: PUSH
 250: LD_INT 3
 252: PUSH
 253: LD_INT 7
 255: PUSH
 256: EMPTY
 257: LIST
 258: LIST
 259: LIST
 260: LIST
 261: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 ] [ Difficulty ] , arabianMinefield ) ;
 262: LD_INT 1
 264: PPUSH
 265: LD_INT 6
 267: PUSH
 268: LD_INT 7
 270: PUSH
 271: LD_INT 9
 273: PUSH
 274: EMPTY
 275: LIST
 276: LIST
 277: LIST
 278: PUSH
 279: LD_OWVAR 67
 283: ARRAY
 284: PPUSH
 285: LD_INT 28
 287: PPUSH
 288: CALL 43900 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 292: LD_INT 1
 294: PPUSH
 295: LD_INT 10
 297: PUSH
 298: LD_INT 11
 300: PUSH
 301: LD_INT 13
 303: PUSH
 304: LD_INT 15
 306: PUSH
 307: EMPTY
 308: LIST
 309: LIST
 310: LIST
 311: LIST
 312: PPUSH
 313: CALL 44960 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 317: LD_INT 1
 319: PPUSH
 320: LD_INT 29
 322: PUSH
 323: EMPTY
 324: LIST
 325: PPUSH
 326: CALL 45053 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 330: LD_ADDR_EXP 116
 334: PUSH
 335: LD_EXP 116
 339: PPUSH
 340: LD_INT 1
 342: PPUSH
 343: LD_INT 22
 345: PUSH
 346: LD_INT 2
 348: PUSH
 349: EMPTY
 350: LIST
 351: LIST
 352: PUSH
 353: LD_INT 25
 355: PUSH
 356: LD_INT 15
 358: PUSH
 359: EMPTY
 360: LIST
 361: LIST
 362: PUSH
 363: EMPTY
 364: LIST
 365: LIST
 366: PPUSH
 367: CALL_OW 69
 371: PPUSH
 372: CALL_OW 1
 376: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 377: LD_INT 1
 379: PPUSH
 380: LD_INT 13
 382: PUSH
 383: LD_INT 2
 385: PUSH
 386: LD_INT 1
 388: PUSH
 389: LD_INT 31
 391: PUSH
 392: EMPTY
 393: LIST
 394: LIST
 395: LIST
 396: LIST
 397: PUSH
 398: LD_INT 13
 400: PUSH
 401: LD_INT 2
 403: PUSH
 404: LD_INT 1
 406: PUSH
 407: LD_INT 31
 409: PUSH
 410: EMPTY
 411: LIST
 412: LIST
 413: LIST
 414: LIST
 415: PUSH
 416: LD_INT 13
 418: PUSH
 419: LD_INT 1
 421: PUSH
 422: LD_INT 1
 424: PUSH
 425: LD_INT 28
 427: PUSH
 428: EMPTY
 429: LIST
 430: LIST
 431: LIST
 432: LIST
 433: PUSH
 434: LD_INT 13
 436: PUSH
 437: LD_INT 1
 439: PUSH
 440: LD_INT 1
 442: PUSH
 443: LD_INT 28
 445: PUSH
 446: EMPTY
 447: LIST
 448: LIST
 449: LIST
 450: LIST
 451: PUSH
 452: LD_INT 13
 454: PUSH
 455: LD_INT 1
 457: PUSH
 458: LD_INT 1
 460: PUSH
 461: LD_INT 28
 463: PUSH
 464: EMPTY
 465: LIST
 466: LIST
 467: LIST
 468: LIST
 469: PUSH
 470: LD_INT 13
 472: PUSH
 473: LD_INT 1
 475: PUSH
 476: LD_INT 1
 478: PUSH
 479: LD_INT 28
 481: PUSH
 482: EMPTY
 483: LIST
 484: LIST
 485: LIST
 486: LIST
 487: PUSH
 488: EMPTY
 489: LIST
 490: LIST
 491: LIST
 492: LIST
 493: LIST
 494: LIST
 495: PPUSH
 496: CALL 44218 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 500: LD_INT 1
 502: PPUSH
 503: LD_INT 4
 505: PPUSH
 506: CALL 44403 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 510: LD_INT 2
 512: PPUSH
 513: LD_INT 10
 515: PUSH
 516: LD_INT 11
 518: PUSH
 519: LD_INT 12
 521: PUSH
 522: LD_INT 14
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: LIST
 529: LIST
 530: PPUSH
 531: CALL 44960 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 535: LD_INT 2
 537: PPUSH
 538: LD_INT 14
 540: PUSH
 541: EMPTY
 542: LIST
 543: PPUSH
 544: CALL 45053 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 548: LD_INT 2
 550: PPUSH
 551: LD_INT 21
 553: PUSH
 554: LD_INT 3
 556: PUSH
 557: LD_INT 3
 559: PUSH
 560: LD_INT 51
 562: PUSH
 563: EMPTY
 564: LIST
 565: LIST
 566: LIST
 567: LIST
 568: PUSH
 569: LD_INT 22
 571: PUSH
 572: LD_INT 3
 574: PUSH
 575: LD_INT 3
 577: PUSH
 578: LD_INT 52
 580: PUSH
 581: EMPTY
 582: LIST
 583: LIST
 584: LIST
 585: LIST
 586: PUSH
 587: LD_INT 22
 589: PUSH
 590: LD_INT 3
 592: PUSH
 593: LD_INT 3
 595: PUSH
 596: LD_INT 52
 598: PUSH
 599: EMPTY
 600: LIST
 601: LIST
 602: LIST
 603: LIST
 604: PUSH
 605: LD_INT 24
 607: PUSH
 608: LD_INT 3
 610: PUSH
 611: LD_INT 3
 613: PUSH
 614: LD_INT 47
 616: PUSH
 617: EMPTY
 618: LIST
 619: LIST
 620: LIST
 621: LIST
 622: PUSH
 623: LD_INT 24
 625: PUSH
 626: LD_INT 3
 628: PUSH
 629: LD_INT 3
 631: PUSH
 632: LD_INT 47
 634: PUSH
 635: EMPTY
 636: LIST
 637: LIST
 638: LIST
 639: LIST
 640: PUSH
 641: LD_INT 24
 643: PUSH
 644: LD_INT 3
 646: PUSH
 647: LD_INT 3
 649: PUSH
 650: LD_INT 47
 652: PUSH
 653: EMPTY
 654: LIST
 655: LIST
 656: LIST
 657: LIST
 658: PUSH
 659: LD_INT 24
 661: PUSH
 662: LD_INT 3
 664: PUSH
 665: LD_INT 3
 667: PUSH
 668: LD_INT 47
 670: PUSH
 671: EMPTY
 672: LIST
 673: LIST
 674: LIST
 675: LIST
 676: PUSH
 677: LD_INT 24
 679: PUSH
 680: LD_INT 3
 682: PUSH
 683: LD_INT 3
 685: PUSH
 686: LD_INT 47
 688: PUSH
 689: EMPTY
 690: LIST
 691: LIST
 692: LIST
 693: LIST
 694: PUSH
 695: EMPTY
 696: LIST
 697: LIST
 698: LIST
 699: LIST
 700: LIST
 701: LIST
 702: LIST
 703: LIST
 704: PPUSH
 705: CALL 44218 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 709: LD_INT 2
 711: PPUSH
 712: LD_INT 5
 714: PPUSH
 715: CALL 44403 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 719: LD_INT 2
 721: PPUSH
 722: LD_INT 0
 724: PPUSH
 725: CALL 44833 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 729: LD_INT 3
 731: PPUSH
 732: LD_INT 10
 734: PUSH
 735: LD_INT 12
 737: PUSH
 738: LD_INT 15
 740: PUSH
 741: EMPTY
 742: LIST
 743: LIST
 744: LIST
 745: PUSH
 746: LD_OWVAR 67
 750: ARRAY
 751: PPUSH
 752: LD_INT 24
 754: PPUSH
 755: CALL 43900 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 759: LD_INT 3
 761: PPUSH
 762: LD_INT 10
 764: PUSH
 765: LD_INT 11
 767: PUSH
 768: LD_INT 13
 770: PUSH
 771: LD_INT 15
 773: PUSH
 774: EMPTY
 775: LIST
 776: LIST
 777: LIST
 778: LIST
 779: PPUSH
 780: CALL 44960 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 784: LD_INT 3
 786: PPUSH
 787: LD_INT 13
 789: PUSH
 790: EMPTY
 791: LIST
 792: PPUSH
 793: CALL 45053 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 797: LD_ADDR_EXP 116
 801: PUSH
 802: LD_EXP 116
 806: PPUSH
 807: LD_INT 3
 809: PPUSH
 810: LD_INT 22
 812: PUSH
 813: LD_INT 8
 815: PUSH
 816: EMPTY
 817: LIST
 818: LIST
 819: PUSH
 820: LD_INT 25
 822: PUSH
 823: LD_INT 15
 825: PUSH
 826: EMPTY
 827: LIST
 828: LIST
 829: PUSH
 830: EMPTY
 831: LIST
 832: LIST
 833: PPUSH
 834: CALL_OW 69
 838: PPUSH
 839: CALL_OW 1
 843: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 844: LD_INT 3
 846: PPUSH
 847: LD_INT 13
 849: PUSH
 850: LD_INT 2
 852: PUSH
 853: LD_INT 1
 855: PUSH
 856: LD_INT 31
 858: PUSH
 859: EMPTY
 860: LIST
 861: LIST
 862: LIST
 863: LIST
 864: PUSH
 865: LD_INT 13
 867: PUSH
 868: LD_INT 2
 870: PUSH
 871: LD_INT 1
 873: PUSH
 874: LD_INT 31
 876: PUSH
 877: EMPTY
 878: LIST
 879: LIST
 880: LIST
 881: LIST
 882: PUSH
 883: LD_INT 13
 885: PUSH
 886: LD_INT 3
 888: PUSH
 889: LD_INT 2
 891: PUSH
 892: LD_INT 32
 894: PUSH
 895: EMPTY
 896: LIST
 897: LIST
 898: LIST
 899: LIST
 900: PUSH
 901: LD_INT 14
 903: PUSH
 904: LD_INT 1
 906: PUSH
 907: LD_INT 1
 909: PUSH
 910: LD_INT 28
 912: PUSH
 913: EMPTY
 914: LIST
 915: LIST
 916: LIST
 917: LIST
 918: PUSH
 919: LD_INT 14
 921: PUSH
 922: LD_INT 1
 924: PUSH
 925: LD_INT 1
 927: PUSH
 928: LD_INT 28
 930: PUSH
 931: EMPTY
 932: LIST
 933: LIST
 934: LIST
 935: LIST
 936: PUSH
 937: LD_INT 14
 939: PUSH
 940: LD_INT 1
 942: PUSH
 943: LD_INT 1
 945: PUSH
 946: LD_INT 28
 948: PUSH
 949: EMPTY
 950: LIST
 951: LIST
 952: LIST
 953: LIST
 954: PUSH
 955: LD_INT 14
 957: PUSH
 958: LD_INT 1
 960: PUSH
 961: LD_INT 1
 963: PUSH
 964: LD_INT 28
 966: PUSH
 967: EMPTY
 968: LIST
 969: LIST
 970: LIST
 971: LIST
 972: PUSH
 973: EMPTY
 974: LIST
 975: LIST
 976: LIST
 977: LIST
 978: LIST
 979: LIST
 980: LIST
 981: PPUSH
 982: CALL 44218 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
 986: LD_INT 3
 988: PPUSH
 989: LD_INT 4
 991: PPUSH
 992: CALL 44403 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
 996: LD_INT 4
 998: PPUSH
 999: LD_INT 10
1001: PUSH
1002: LD_INT 12
1004: PUSH
1005: LD_INT 11
1007: PUSH
1008: LD_INT 15
1010: PUSH
1011: EMPTY
1012: LIST
1013: LIST
1014: LIST
1015: LIST
1016: PPUSH
1017: CALL 44960 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1021: LD_INT 4
1023: PPUSH
1024: LD_INT 33
1026: PUSH
1027: EMPTY
1028: LIST
1029: PPUSH
1030: CALL 45053 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1034: LD_INT 4
1036: PPUSH
1037: LD_INT 5
1039: PUSH
1040: LD_INT 6
1042: PUSH
1043: LD_INT 7
1045: PUSH
1046: LD_INT 9
1048: PUSH
1049: LD_INT 10
1051: PUSH
1052: EMPTY
1053: LIST
1054: LIST
1055: LIST
1056: LIST
1057: LIST
1058: PPUSH
1059: CALL 45371 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1063: LD_INT 4
1065: PPUSH
1066: LD_INT 54
1068: PPUSH
1069: LD_INT 85
1071: PPUSH
1072: LD_INT 2
1074: PPUSH
1075: LD_INT 25
1077: PUSH
1078: LD_INT 16
1080: PUSH
1081: LD_INT 17
1083: PUSH
1084: LD_INT 18
1086: PUSH
1087: LD_INT 22
1089: PUSH
1090: EMPTY
1091: LIST
1092: LIST
1093: LIST
1094: LIST
1095: LIST
1096: PPUSH
1097: CALL 45165 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1101: LD_INT 4
1103: PPUSH
1104: LD_INT 5
1106: PUSH
1107: LD_INT 1
1109: PUSH
1110: LD_INT 1
1112: PUSH
1113: LD_INT 7
1115: PUSH
1116: EMPTY
1117: LIST
1118: LIST
1119: LIST
1120: LIST
1121: PUSH
1122: LD_INT 5
1124: PUSH
1125: LD_INT 1
1127: PUSH
1128: LD_INT 1
1130: PUSH
1131: LD_INT 6
1133: PUSH
1134: EMPTY
1135: LIST
1136: LIST
1137: LIST
1138: LIST
1139: PUSH
1140: LD_INT 5
1142: PUSH
1143: LD_INT 1
1145: PUSH
1146: LD_INT 1
1148: PUSH
1149: LD_INT 7
1151: PUSH
1152: EMPTY
1153: LIST
1154: LIST
1155: LIST
1156: LIST
1157: PUSH
1158: LD_INT 5
1160: PUSH
1161: LD_INT 1
1163: PUSH
1164: LD_INT 1
1166: PUSH
1167: LD_INT 6
1169: PUSH
1170: EMPTY
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: PUSH
1176: LD_INT 5
1178: PUSH
1179: LD_INT 1
1181: PUSH
1182: LD_INT 3
1184: PUSH
1185: LD_INT 12
1187: PUSH
1188: EMPTY
1189: LIST
1190: LIST
1191: LIST
1192: LIST
1193: PUSH
1194: LD_INT 3
1196: PUSH
1197: LD_INT 1
1199: PUSH
1200: LD_INT 3
1202: PUSH
1203: LD_INT 13
1205: PUSH
1206: EMPTY
1207: LIST
1208: LIST
1209: LIST
1210: LIST
1211: PUSH
1212: EMPTY
1213: LIST
1214: LIST
1215: LIST
1216: LIST
1217: LIST
1218: LIST
1219: PPUSH
1220: CALL 44218 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1224: LD_INT 4
1226: PPUSH
1227: LD_INT 4
1229: PPUSH
1230: CALL 44403 0 2
// MC_SetTame ( 4 , powellApe ) ;
1234: LD_INT 4
1236: PPUSH
1237: LD_INT 11
1239: PPUSH
1240: CALL 44784 0 2
// end ;
1244: LD_VAR 0 1
1248: RET
// every 0 0$1 trigger debug do var i ;
1249: LD_EXP 1
1253: IFFALSE 1351
1255: GO 1257
1257: DISABLE
1258: LD_INT 0
1260: PPUSH
// begin enable ;
1261: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1262: LD_ADDR_VAR 0 1
1266: PUSH
1267: LD_INT 22
1269: PUSH
1270: LD_INT 7
1272: PUSH
1273: EMPTY
1274: LIST
1275: LIST
1276: PUSH
1277: LD_INT 2
1279: PUSH
1280: LD_INT 21
1282: PUSH
1283: LD_INT 1
1285: PUSH
1286: EMPTY
1287: LIST
1288: LIST
1289: PUSH
1290: LD_INT 21
1292: PUSH
1293: LD_INT 2
1295: PUSH
1296: EMPTY
1297: LIST
1298: LIST
1299: PUSH
1300: EMPTY
1301: LIST
1302: LIST
1303: LIST
1304: PUSH
1305: LD_INT 3
1307: PUSH
1308: LD_INT 24
1310: PUSH
1311: LD_INT 1000
1313: PUSH
1314: EMPTY
1315: LIST
1316: LIST
1317: PUSH
1318: EMPTY
1319: LIST
1320: LIST
1321: PUSH
1322: EMPTY
1323: LIST
1324: LIST
1325: LIST
1326: PPUSH
1327: CALL_OW 69
1331: PUSH
1332: FOR_IN
1333: IFFALSE 1349
// SetLives ( i , 1000 ) ;
1335: LD_VAR 0 1
1339: PPUSH
1340: LD_INT 1000
1342: PPUSH
1343: CALL_OW 234
1347: GO 1332
1349: POP
1350: POP
// end ;
1351: PPOPN 1
1353: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1354: LD_EXP 16
1358: PUSH
1359: LD_INT 5
1361: GREATEREQUAL
1362: IFFALSE 1374
1364: GO 1366
1366: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1367: LD_STRING ACH_ARTIFACT
1369: PPUSH
1370: CALL_OW 543
1374: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1375: LD_INT 0
1377: PPUSH
1378: PPUSH
1379: PPUSH
1380: PPUSH
1381: PPUSH
// uc_side := 7 ;
1382: LD_ADDR_OWVAR 20
1386: PUSH
1387: LD_INT 7
1389: ST_TO_ADDR
// tmp := [ ] ;
1390: LD_ADDR_VAR 0 5
1394: PUSH
1395: EMPTY
1396: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1397: LD_ADDR_EXP 17
1401: PUSH
1402: LD_STRING JMM
1404: PPUSH
1405: LD_EXP 1
1409: NOT
1410: PPUSH
1411: LD_STRING 14a_
1413: PPUSH
1414: CALL 50610 0 3
1418: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1419: LD_ADDR_EXP 49
1423: PUSH
1424: LD_STRING Burlak
1426: PPUSH
1427: LD_EXP 1
1431: NOT
1432: PPUSH
1433: LD_STRING 14a_
1435: PPUSH
1436: CALL 50610 0 3
1440: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1441: LD_ADDR_EXP 32
1445: PUSH
1446: LD_STRING Joan
1448: PPUSH
1449: LD_EXP 1
1453: NOT
1454: PPUSH
1455: LD_STRING 13a_
1457: PPUSH
1458: CALL 50610 0 3
1462: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1463: LD_ADDR_EXP 18
1467: PUSH
1468: LD_STRING Roth
1470: PPUSH
1471: LD_EXP 1
1475: NOT
1476: PPUSH
1477: LD_STRING 13a_
1479: PPUSH
1480: CALL 50610 0 3
1484: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1485: LD_ADDR_EXP 35
1489: PUSH
1490: LD_STRING Gossudarov
1492: PPUSH
1493: LD_EXP 1
1497: NOT
1498: PPUSH
1499: LD_STRING 13a_
1501: PPUSH
1502: CALL 50610 0 3
1506: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1507: LD_ADDR_EXP 23
1511: PUSH
1512: LD_STRING Denis
1514: PPUSH
1515: LD_EXP 1
1519: NOT
1520: PPUSH
1521: LD_STRING 13a_
1523: PPUSH
1524: CALL 50610 0 3
1528: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1529: LD_ADDR_EXP 33
1533: PUSH
1534: LD_STRING DeltaDoctor
1536: PPUSH
1537: LD_EXP 1
1541: NOT
1542: PPUSH
1543: LD_STRING 13a_
1545: PPUSH
1546: CALL 50610 0 3
1550: ST_TO_ADDR
// if DeltaDoctor then
1551: LD_EXP 33
1555: IFFALSE 1573
// tmp := tmp ^ DeltaDoctor ;
1557: LD_ADDR_VAR 0 5
1561: PUSH
1562: LD_VAR 0 5
1566: PUSH
1567: LD_EXP 33
1571: ADD
1572: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1573: LD_ADDR_EXP 31
1577: PUSH
1578: LD_STRING Simms
1580: PPUSH
1581: LD_EXP 1
1585: NOT
1586: PPUSH
1587: LD_STRING 13a_
1589: PPUSH
1590: CALL 50610 0 3
1594: ST_TO_ADDR
// if Simms then
1595: LD_EXP 31
1599: IFFALSE 1617
// tmp := tmp ^ Simms ;
1601: LD_ADDR_VAR 0 5
1605: PUSH
1606: LD_VAR 0 5
1610: PUSH
1611: LD_EXP 31
1615: ADD
1616: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1617: LD_ADDR_EXP 29
1621: PUSH
1622: LD_STRING Frank
1624: PPUSH
1625: LD_EXP 1
1629: NOT
1630: PPUSH
1631: LD_STRING 13a_
1633: PPUSH
1634: CALL 50610 0 3
1638: ST_TO_ADDR
// if Frank then
1639: LD_EXP 29
1643: IFFALSE 1661
// tmp := tmp ^ Frank ;
1645: LD_ADDR_VAR 0 5
1649: PUSH
1650: LD_VAR 0 5
1654: PUSH
1655: LD_EXP 29
1659: ADD
1660: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1661: LD_ADDR_EXP 36
1665: PUSH
1666: LD_STRING Kirilenkova
1668: PPUSH
1669: LD_EXP 1
1673: NOT
1674: PPUSH
1675: LD_STRING 13a_
1677: PPUSH
1678: CALL 50610 0 3
1682: ST_TO_ADDR
// if Kirilenkova then
1683: LD_EXP 36
1687: IFFALSE 1705
// tmp := tmp ^ Kirilenkova ;
1689: LD_ADDR_VAR 0 5
1693: PUSH
1694: LD_VAR 0 5
1698: PUSH
1699: LD_EXP 36
1703: ADD
1704: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1705: LD_ADDR_EXP 37
1709: PUSH
1710: LD_STRING Titov
1712: PPUSH
1713: LD_EXP 1
1717: NOT
1718: PPUSH
1719: LD_STRING 13a_
1721: PPUSH
1722: CALL 50610 0 3
1726: ST_TO_ADDR
// if Titov then
1727: LD_EXP 37
1731: IFFALSE 1749
// tmp := tmp ^ Titov ;
1733: LD_ADDR_VAR 0 5
1737: PUSH
1738: LD_VAR 0 5
1742: PUSH
1743: LD_EXP 37
1747: ADD
1748: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1749: LD_ADDR_EXP 38
1753: PUSH
1754: LD_STRING Fadeev
1756: PPUSH
1757: LD_EXP 1
1761: NOT
1762: PPUSH
1763: LD_STRING 13a_
1765: PPUSH
1766: CALL 50610 0 3
1770: ST_TO_ADDR
// if Fadeev then
1771: LD_EXP 38
1775: IFFALSE 1793
// tmp := tmp ^ Fadeev ;
1777: LD_ADDR_VAR 0 5
1781: PUSH
1782: LD_VAR 0 5
1786: PUSH
1787: LD_EXP 38
1791: ADD
1792: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1793: LD_ADDR_EXP 39
1797: PUSH
1798: LD_STRING Dolgov
1800: PPUSH
1801: LD_EXP 1
1805: NOT
1806: PPUSH
1807: LD_STRING 13a_
1809: PPUSH
1810: CALL 50610 0 3
1814: ST_TO_ADDR
// if Dolgov then
1815: LD_EXP 39
1819: IFFALSE 1837
// tmp := tmp ^ Dolgov ;
1821: LD_ADDR_VAR 0 5
1825: PUSH
1826: LD_VAR 0 5
1830: PUSH
1831: LD_EXP 39
1835: ADD
1836: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1837: LD_ADDR_EXP 40
1841: PUSH
1842: LD_STRING Petrosyan
1844: PPUSH
1845: LD_EXP 1
1849: NOT
1850: PPUSH
1851: LD_STRING 13a_
1853: PPUSH
1854: CALL 50610 0 3
1858: ST_TO_ADDR
// if Petrosyan then
1859: LD_EXP 40
1863: IFFALSE 1881
// tmp := tmp ^ Petrosyan ;
1865: LD_ADDR_VAR 0 5
1869: PUSH
1870: LD_VAR 0 5
1874: PUSH
1875: LD_EXP 40
1879: ADD
1880: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1881: LD_ADDR_EXP 41
1885: PUSH
1886: LD_STRING Scholtze
1888: PPUSH
1889: LD_EXP 1
1893: NOT
1894: PPUSH
1895: LD_STRING 13a_
1897: PPUSH
1898: CALL 50610 0 3
1902: ST_TO_ADDR
// if Scholtze then
1903: LD_EXP 41
1907: IFFALSE 1925
// tmp := tmp ^ Scholtze ;
1909: LD_ADDR_VAR 0 5
1913: PUSH
1914: LD_VAR 0 5
1918: PUSH
1919: LD_EXP 41
1923: ADD
1924: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
1925: LD_ADDR_EXP 42
1929: PUSH
1930: LD_STRING Oblukov
1932: PPUSH
1933: LD_EXP 1
1937: NOT
1938: PPUSH
1939: LD_STRING 13a_
1941: PPUSH
1942: CALL 50610 0 3
1946: ST_TO_ADDR
// if Oblukov then
1947: LD_EXP 42
1951: IFFALSE 1969
// tmp := tmp ^ Oblukov ;
1953: LD_ADDR_VAR 0 5
1957: PUSH
1958: LD_VAR 0 5
1962: PUSH
1963: LD_EXP 42
1967: ADD
1968: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
1969: LD_ADDR_EXP 43
1973: PUSH
1974: LD_STRING Kapitsova
1976: PPUSH
1977: LD_EXP 1
1981: NOT
1982: PPUSH
1983: LD_STRING 13a_
1985: PPUSH
1986: CALL 50610 0 3
1990: ST_TO_ADDR
// if Kapitsova then
1991: LD_EXP 43
1995: IFFALSE 2013
// tmp := tmp ^ Kapitsova ;
1997: LD_ADDR_VAR 0 5
2001: PUSH
2002: LD_VAR 0 5
2006: PUSH
2007: LD_EXP 43
2011: ADD
2012: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2013: LD_ADDR_EXP 44
2017: PUSH
2018: LD_STRING Lipshchin
2020: PPUSH
2021: LD_EXP 1
2025: NOT
2026: PPUSH
2027: LD_STRING 13a_
2029: PPUSH
2030: CALL 50610 0 3
2034: ST_TO_ADDR
// if Lipshchin then
2035: LD_EXP 44
2039: IFFALSE 2057
// tmp := tmp ^ Lipshchin ;
2041: LD_ADDR_VAR 0 5
2045: PUSH
2046: LD_VAR 0 5
2050: PUSH
2051: LD_EXP 44
2055: ADD
2056: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2057: LD_ADDR_EXP 45
2061: PUSH
2062: LD_STRING Petrovova
2064: PPUSH
2065: LD_EXP 1
2069: NOT
2070: PPUSH
2071: LD_STRING 13a_
2073: PPUSH
2074: CALL 50610 0 3
2078: ST_TO_ADDR
// if Petrovova then
2079: LD_EXP 45
2083: IFFALSE 2101
// tmp := tmp ^ Petrovova ;
2085: LD_ADDR_VAR 0 5
2089: PUSH
2090: LD_VAR 0 5
2094: PUSH
2095: LD_EXP 45
2099: ADD
2100: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2101: LD_ADDR_EXP 46
2105: PUSH
2106: LD_STRING Kovalyuk
2108: PPUSH
2109: LD_EXP 1
2113: NOT
2114: PPUSH
2115: LD_STRING 13a_
2117: PPUSH
2118: CALL 50610 0 3
2122: ST_TO_ADDR
// if Kovalyuk then
2123: LD_EXP 46
2127: IFFALSE 2145
// tmp := tmp ^ Kovalyuk ;
2129: LD_ADDR_VAR 0 5
2133: PUSH
2134: LD_VAR 0 5
2138: PUSH
2139: LD_EXP 46
2143: ADD
2144: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2145: LD_ADDR_EXP 47
2149: PUSH
2150: LD_STRING Kuzmov
2152: PPUSH
2153: LD_EXP 1
2157: NOT
2158: PPUSH
2159: LD_STRING 13a_
2161: PPUSH
2162: CALL 50610 0 3
2166: ST_TO_ADDR
// if Kuzmov then
2167: LD_EXP 47
2171: IFFALSE 2189
// tmp := tmp ^ Kuzmov ;
2173: LD_ADDR_VAR 0 5
2177: PUSH
2178: LD_VAR 0 5
2182: PUSH
2183: LD_EXP 47
2187: ADD
2188: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2189: LD_ADDR_EXP 48
2193: PUSH
2194: LD_STRING Karamazov
2196: PPUSH
2197: LD_EXP 1
2201: NOT
2202: PPUSH
2203: LD_STRING 13a_
2205: PPUSH
2206: CALL 50610 0 3
2210: ST_TO_ADDR
// if Karamazov then
2211: LD_EXP 48
2215: IFFALSE 2233
// tmp := tmp ^ Karamazov ;
2217: LD_ADDR_VAR 0 5
2221: PUSH
2222: LD_VAR 0 5
2226: PUSH
2227: LD_EXP 48
2231: ADD
2232: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2233: LD_ADDR_EXP 50
2237: PUSH
2238: LD_STRING Belkov
2240: PPUSH
2241: LD_EXP 1
2245: NOT
2246: PPUSH
2247: LD_STRING 13a_
2249: PPUSH
2250: CALL 50610 0 3
2254: ST_TO_ADDR
// if Belkov then
2255: LD_EXP 50
2259: IFFALSE 2277
// tmp := tmp ^ Belkov ;
2261: LD_ADDR_VAR 0 5
2265: PUSH
2266: LD_VAR 0 5
2270: PUSH
2271: LD_EXP 50
2275: ADD
2276: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2277: LD_ADDR_EXP 51
2281: PUSH
2282: LD_STRING Gnyevko
2284: PPUSH
2285: LD_EXP 1
2289: NOT
2290: PPUSH
2291: LD_STRING 13a_
2293: PPUSH
2294: CALL 50610 0 3
2298: ST_TO_ADDR
// if Gnyevko then
2299: LD_EXP 51
2303: IFFALSE 2321
// tmp := tmp ^ Gnyevko ;
2305: LD_ADDR_VAR 0 5
2309: PUSH
2310: LD_VAR 0 5
2314: PUSH
2315: LD_EXP 51
2319: ADD
2320: ST_TO_ADDR
// Connie = NewCharacter ( Coonie ) ;
2321: LD_ADDR_EXP 34
2325: PUSH
2326: LD_STRING Coonie
2328: PPUSH
2329: CALL_OW 25
2333: ST_TO_ADDR
// if not Lisa then
2334: LD_EXP 19
2338: NOT
2339: IFFALSE 2385
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2341: LD_ADDR_EXP 19
2345: PUSH
2346: LD_STRING Lisa
2348: PPUSH
2349: LD_EXP 1
2353: NOT
2354: PPUSH
2355: LD_STRING 13a_
2357: PPUSH
2358: CALL 50610 0 3
2362: ST_TO_ADDR
// if Lisa then
2363: LD_EXP 19
2367: IFFALSE 2385
// tmp := tmp ^ Lisa ;
2369: LD_ADDR_VAR 0 5
2373: PUSH
2374: LD_VAR 0 5
2378: PUSH
2379: LD_EXP 19
2383: ADD
2384: ST_TO_ADDR
// end ; if not Donaldson then
2385: LD_EXP 20
2389: NOT
2390: IFFALSE 2436
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2392: LD_ADDR_EXP 20
2396: PUSH
2397: LD_STRING Donaldson
2399: PPUSH
2400: LD_EXP 1
2404: NOT
2405: PPUSH
2406: LD_STRING 13a_
2408: PPUSH
2409: CALL 50610 0 3
2413: ST_TO_ADDR
// if Donaldson then
2414: LD_EXP 20
2418: IFFALSE 2436
// tmp := tmp ^ Donaldson ;
2420: LD_ADDR_VAR 0 5
2424: PUSH
2425: LD_VAR 0 5
2429: PUSH
2430: LD_EXP 20
2434: ADD
2435: ST_TO_ADDR
// end ; if not Bobby then
2436: LD_EXP 21
2440: NOT
2441: IFFALSE 2487
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2443: LD_ADDR_EXP 21
2447: PUSH
2448: LD_STRING Bobby
2450: PPUSH
2451: LD_EXP 1
2455: NOT
2456: PPUSH
2457: LD_STRING 13a_
2459: PPUSH
2460: CALL 50610 0 3
2464: ST_TO_ADDR
// if Bobby then
2465: LD_EXP 21
2469: IFFALSE 2487
// tmp := tmp ^ Bobby ;
2471: LD_ADDR_VAR 0 5
2475: PUSH
2476: LD_VAR 0 5
2480: PUSH
2481: LD_EXP 21
2485: ADD
2486: ST_TO_ADDR
// end ; if not Cyrus then
2487: LD_EXP 22
2491: NOT
2492: IFFALSE 2538
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2494: LD_ADDR_EXP 22
2498: PUSH
2499: LD_STRING Cyrus
2501: PPUSH
2502: LD_EXP 1
2506: NOT
2507: PPUSH
2508: LD_STRING 13a_
2510: PPUSH
2511: CALL 50610 0 3
2515: ST_TO_ADDR
// if Cyrus then
2516: LD_EXP 22
2520: IFFALSE 2538
// tmp := tmp ^ Cyrus ;
2522: LD_ADDR_VAR 0 5
2526: PUSH
2527: LD_VAR 0 5
2531: PUSH
2532: LD_EXP 22
2536: ADD
2537: ST_TO_ADDR
// end ; if not Brown then
2538: LD_EXP 24
2542: NOT
2543: IFFALSE 2589
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2545: LD_ADDR_EXP 24
2549: PUSH
2550: LD_STRING Brown
2552: PPUSH
2553: LD_EXP 1
2557: NOT
2558: PPUSH
2559: LD_STRING 13a_
2561: PPUSH
2562: CALL 50610 0 3
2566: ST_TO_ADDR
// if Brown then
2567: LD_EXP 24
2571: IFFALSE 2589
// tmp := tmp ^ Brown ;
2573: LD_ADDR_VAR 0 5
2577: PUSH
2578: LD_VAR 0 5
2582: PUSH
2583: LD_EXP 24
2587: ADD
2588: ST_TO_ADDR
// end ; if not Gladstone then
2589: LD_EXP 25
2593: NOT
2594: IFFALSE 2640
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2596: LD_ADDR_EXP 25
2600: PUSH
2601: LD_STRING Gladstone
2603: PPUSH
2604: LD_EXP 1
2608: NOT
2609: PPUSH
2610: LD_STRING 13a_
2612: PPUSH
2613: CALL 50610 0 3
2617: ST_TO_ADDR
// if Gladstone then
2618: LD_EXP 25
2622: IFFALSE 2640
// tmp := tmp ^ Gladstone ;
2624: LD_ADDR_VAR 0 5
2628: PUSH
2629: LD_VAR 0 5
2633: PUSH
2634: LD_EXP 25
2638: ADD
2639: ST_TO_ADDR
// end ; if not Cornel then
2640: LD_EXP 27
2644: NOT
2645: IFFALSE 2691
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2647: LD_ADDR_EXP 27
2651: PUSH
2652: LD_STRING Cornel
2654: PPUSH
2655: LD_EXP 1
2659: NOT
2660: PPUSH
2661: LD_STRING 13a_
2663: PPUSH
2664: CALL 50610 0 3
2668: ST_TO_ADDR
// if Cornel then
2669: LD_EXP 27
2673: IFFALSE 2691
// tmp := tmp ^ Cornel ;
2675: LD_ADDR_VAR 0 5
2679: PUSH
2680: LD_VAR 0 5
2684: PUSH
2685: LD_EXP 27
2689: ADD
2690: ST_TO_ADDR
// end ; if not Houten then
2691: LD_EXP 26
2695: NOT
2696: IFFALSE 2742
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2698: LD_ADDR_EXP 26
2702: PUSH
2703: LD_STRING Houten
2705: PPUSH
2706: LD_EXP 1
2710: NOT
2711: PPUSH
2712: LD_STRING 13a_
2714: PPUSH
2715: CALL 50610 0 3
2719: ST_TO_ADDR
// if Houten then
2720: LD_EXP 26
2724: IFFALSE 2742
// tmp := tmp ^ Houten ;
2726: LD_ADDR_VAR 0 5
2730: PUSH
2731: LD_VAR 0 5
2735: PUSH
2736: LD_EXP 26
2740: ADD
2741: ST_TO_ADDR
// end ; if not Gary then
2742: LD_EXP 28
2746: NOT
2747: IFFALSE 2793
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2749: LD_ADDR_EXP 28
2753: PUSH
2754: LD_STRING Gary
2756: PPUSH
2757: LD_EXP 1
2761: NOT
2762: PPUSH
2763: LD_STRING 13a_
2765: PPUSH
2766: CALL 50610 0 3
2770: ST_TO_ADDR
// if Gary then
2771: LD_EXP 28
2775: IFFALSE 2793
// tmp := tmp ^ Gary ;
2777: LD_ADDR_VAR 0 5
2781: PUSH
2782: LD_VAR 0 5
2786: PUSH
2787: LD_EXP 28
2791: ADD
2792: ST_TO_ADDR
// end ; if not Kikuchi then
2793: LD_EXP 30
2797: NOT
2798: IFFALSE 2844
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2800: LD_ADDR_EXP 30
2804: PUSH
2805: LD_STRING Kikuchi
2807: PPUSH
2808: LD_EXP 1
2812: NOT
2813: PPUSH
2814: LD_STRING 13a_
2816: PPUSH
2817: CALL 50610 0 3
2821: ST_TO_ADDR
// if Kikuchi then
2822: LD_EXP 30
2826: IFFALSE 2844
// tmp := tmp ^ Kikuchi ;
2828: LD_ADDR_VAR 0 5
2832: PUSH
2833: LD_VAR 0 5
2837: PUSH
2838: LD_EXP 30
2842: ADD
2843: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2844: LD_ADDR_VAR 0 5
2848: PUSH
2849: LD_VAR 0 5
2853: PUSH
2854: LD_STRING 13a_others
2856: PPUSH
2857: CALL_OW 31
2861: UNION
2862: ST_TO_ADDR
// tmp := tmp diff 0 ;
2863: LD_ADDR_VAR 0 5
2867: PUSH
2868: LD_VAR 0 5
2872: PUSH
2873: LD_INT 0
2875: DIFF
2876: ST_TO_ADDR
// if tmp < 15 then
2877: LD_VAR 0 5
2881: PUSH
2882: LD_INT 15
2884: LESS
2885: IFFALSE 2973
// for i = 15 downto tmp do
2887: LD_ADDR_VAR 0 2
2891: PUSH
2892: DOUBLE
2893: LD_INT 15
2895: INC
2896: ST_TO_ADDR
2897: LD_VAR 0 5
2901: PUSH
2902: FOR_DOWNTO
2903: IFFALSE 2971
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2905: LD_ADDR_OWVAR 21
2909: PUSH
2910: LD_INT 1
2912: PUSH
2913: LD_INT 3
2915: PUSH
2916: EMPTY
2917: LIST
2918: LIST
2919: PUSH
2920: LD_INT 1
2922: PPUSH
2923: LD_INT 2
2925: PPUSH
2926: CALL_OW 12
2930: ARRAY
2931: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
2932: LD_INT 0
2934: PPUSH
2935: LD_INT 1
2937: PPUSH
2938: LD_INT 4
2940: PPUSH
2941: CALL_OW 12
2945: PPUSH
2946: LD_INT 8
2948: PPUSH
2949: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2953: LD_ADDR_VAR 0 5
2957: PUSH
2958: LD_VAR 0 5
2962: PUSH
2963: CALL_OW 44
2967: ADD
2968: ST_TO_ADDR
// end ;
2969: GO 2902
2971: POP
2972: POP
// if not debug then
2973: LD_EXP 1
2977: NOT
2978: IFFALSE 3150
// selected = CharacterSelection (  , [ 15 , 14 , 13 ] [ Difficulty ] , [ 15 , 14 , 13 ] [ Difficulty ] , [ sel_dont_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
2980: LD_ADDR_VAR 0 4
2984: PUSH
2985: LD_STRING 
2987: PPUSH
2988: LD_INT 15
2990: PUSH
2991: LD_INT 14
2993: PUSH
2994: LD_INT 13
2996: PUSH
2997: EMPTY
2998: LIST
2999: LIST
3000: LIST
3001: PUSH
3002: LD_OWVAR 67
3006: ARRAY
3007: PPUSH
3008: LD_INT 15
3010: PUSH
3011: LD_INT 14
3013: PUSH
3014: LD_INT 13
3016: PUSH
3017: EMPTY
3018: LIST
3019: LIST
3020: LIST
3021: PUSH
3022: LD_OWVAR 67
3026: ARRAY
3027: PPUSH
3028: LD_INT -6
3030: PUSH
3031: LD_EXP 17
3035: PUSH
3036: LD_EXP 49
3040: PUSH
3041: LD_EXP 18
3045: PUSH
3046: LD_EXP 32
3050: PUSH
3051: LD_EXP 23
3055: PUSH
3056: LD_EXP 35
3060: PUSH
3061: LD_INT -2
3063: PUSH
3064: LD_INT -3
3066: PUSH
3067: LD_INT -5
3069: PUSH
3070: EMPTY
3071: LIST
3072: LIST
3073: LIST
3074: LIST
3075: LIST
3076: LIST
3077: LIST
3078: LIST
3079: LIST
3080: LIST
3081: PUSH
3082: LD_VAR 0 5
3086: ADD
3087: PPUSH
3088: LD_INT 1
3090: PUSH
3091: LD_INT 4
3093: PUSH
3094: LD_INT 2
3096: PUSH
3097: LD_INT 1
3099: PUSH
3100: EMPTY
3101: LIST
3102: LIST
3103: PUSH
3104: LD_INT 3
3106: PUSH
3107: LD_INT 5
3109: PUSH
3110: LD_INT 0
3112: PUSH
3113: LD_INT 3
3115: PUSH
3116: EMPTY
3117: LIST
3118: LIST
3119: LIST
3120: PUSH
3121: LD_INT 9
3123: PUSH
3124: LD_INT 0
3126: PUSH
3127: LD_INT 3
3129: PUSH
3130: EMPTY
3131: LIST
3132: LIST
3133: LIST
3134: PUSH
3135: EMPTY
3136: LIST
3137: LIST
3138: LIST
3139: LIST
3140: LIST
3141: LIST
3142: PPUSH
3143: CALL_OW 42
3147: ST_TO_ADDR
3148: GO 3229
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ] ;
3150: LD_ADDR_VAR 0 4
3154: PUSH
3155: LD_EXP 37
3159: PUSH
3160: LD_EXP 38
3164: PUSH
3165: LD_EXP 39
3169: PUSH
3170: LD_EXP 40
3174: PUSH
3175: LD_EXP 41
3179: PUSH
3180: LD_EXP 42
3184: PUSH
3185: LD_EXP 43
3189: PUSH
3190: LD_EXP 44
3194: PUSH
3195: LD_EXP 45
3199: PUSH
3200: LD_EXP 46
3204: PUSH
3205: LD_EXP 47
3209: PUSH
3210: LD_EXP 48
3214: PUSH
3215: EMPTY
3216: LIST
3217: LIST
3218: LIST
3219: LIST
3220: LIST
3221: LIST
3222: LIST
3223: LIST
3224: LIST
3225: LIST
3226: LIST
3227: LIST
3228: ST_TO_ADDR
// uc_nation := 1 ;
3229: LD_ADDR_OWVAR 21
3233: PUSH
3234: LD_INT 1
3236: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3237: LD_INT 5
3239: PPUSH
3240: LD_INT 3
3242: PPUSH
3243: LD_INT 1
3245: PPUSH
3246: LD_INT 6
3248: PPUSH
3249: LD_INT 100
3251: PPUSH
3252: CALL 57845 0 5
// veh := CreateVehicle ;
3256: LD_ADDR_VAR 0 3
3260: PUSH
3261: CALL_OW 45
3265: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3266: LD_VAR 0 3
3270: PPUSH
3271: LD_INT 7
3273: NEG
3274: PPUSH
3275: CALL_OW 242
// SetDir ( veh , 3 ) ;
3279: LD_VAR 0 3
3283: PPUSH
3284: LD_INT 3
3286: PPUSH
3287: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3291: LD_VAR 0 3
3295: PPUSH
3296: LD_INT 31
3298: PPUSH
3299: LD_INT 0
3301: PPUSH
3302: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3306: LD_EXP 17
3310: PPUSH
3311: LD_VAR 0 3
3315: PPUSH
3316: CALL_OW 52
// if Joan then
3320: LD_EXP 32
3324: IFFALSE 3396
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3326: LD_INT 3
3328: PPUSH
3329: LD_INT 3
3331: PPUSH
3332: LD_INT 1
3334: PPUSH
3335: LD_INT 11
3337: PPUSH
3338: LD_INT 100
3340: PPUSH
3341: CALL 57845 0 5
// veh := CreateVehicle ;
3345: LD_ADDR_VAR 0 3
3349: PUSH
3350: CALL_OW 45
3354: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3355: LD_VAR 0 3
3359: PPUSH
3360: LD_INT 3
3362: PPUSH
3363: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3367: LD_VAR 0 3
3371: PPUSH
3372: LD_INT 30
3374: PPUSH
3375: LD_INT 0
3377: PPUSH
3378: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3382: LD_EXP 32
3386: PPUSH
3387: LD_VAR 0 3
3391: PPUSH
3392: CALL_OW 52
// end ; if Roth then
3396: LD_EXP 18
3400: IFFALSE 3472
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3402: LD_INT 3
3404: PPUSH
3405: LD_INT 3
3407: PPUSH
3408: LD_INT 1
3410: PPUSH
3411: LD_INT 11
3413: PPUSH
3414: LD_INT 100
3416: PPUSH
3417: CALL 57845 0 5
// veh := CreateVehicle ;
3421: LD_ADDR_VAR 0 3
3425: PUSH
3426: CALL_OW 45
3430: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3431: LD_VAR 0 3
3435: PPUSH
3436: LD_INT 3
3438: PPUSH
3439: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3443: LD_VAR 0 3
3447: PPUSH
3448: LD_INT 30
3450: PPUSH
3451: LD_INT 0
3453: PPUSH
3454: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3458: LD_EXP 18
3462: PPUSH
3463: LD_VAR 0 3
3467: PPUSH
3468: CALL_OW 52
// end ; if Denis then
3472: LD_EXP 23
3476: IFFALSE 3548
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3478: LD_INT 5
3480: PPUSH
3481: LD_INT 3
3483: PPUSH
3484: LD_INT 1
3486: PPUSH
3487: LD_INT 9
3489: PPUSH
3490: LD_INT 100
3492: PPUSH
3493: CALL 57845 0 5
// veh := CreateVehicle ;
3497: LD_ADDR_VAR 0 3
3501: PUSH
3502: CALL_OW 45
3506: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3507: LD_VAR 0 3
3511: PPUSH
3512: LD_INT 3
3514: PPUSH
3515: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3519: LD_VAR 0 3
3523: PPUSH
3524: LD_INT 30
3526: PPUSH
3527: LD_INT 0
3529: PPUSH
3530: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3534: LD_EXP 23
3538: PPUSH
3539: LD_VAR 0 3
3543: PPUSH
3544: CALL_OW 52
// end ; uc_nation := 3 ;
3548: LD_ADDR_OWVAR 21
3552: PUSH
3553: LD_INT 3
3555: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3556: LD_INT 22
3558: PPUSH
3559: LD_INT 3
3561: PPUSH
3562: LD_INT 1
3564: PPUSH
3565: LD_INT 45
3567: PPUSH
3568: LD_INT 100
3570: PPUSH
3571: CALL 57845 0 5
// veh := CreateVehicle ;
3575: LD_ADDR_VAR 0 3
3579: PUSH
3580: CALL_OW 45
3584: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3585: LD_VAR 0 3
3589: PPUSH
3590: LD_INT 7
3592: NEG
3593: PPUSH
3594: CALL_OW 242
// SetDir ( veh , 3 ) ;
3598: LD_VAR 0 3
3602: PPUSH
3603: LD_INT 3
3605: PPUSH
3606: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3610: LD_VAR 0 3
3614: PPUSH
3615: LD_INT 31
3617: PPUSH
3618: LD_INT 0
3620: PPUSH
3621: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3625: LD_EXP 49
3629: PPUSH
3630: LD_VAR 0 3
3634: PPUSH
3635: CALL_OW 52
// if Gossudarov then
3639: LD_EXP 35
3643: IFFALSE 3730
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3645: LD_INT 22
3647: PPUSH
3648: LD_INT 3
3650: PPUSH
3651: LD_INT 1
3653: PPUSH
3654: LD_INT 51
3656: PPUSH
3657: LD_INT 100
3659: PPUSH
3660: CALL 57845 0 5
// veh := CreateVehicle ;
3664: LD_ADDR_VAR 0 3
3668: PUSH
3669: CALL_OW 45
3673: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3674: LD_VAR 0 3
3678: PPUSH
3679: LD_INT 3
3681: PPUSH
3682: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3686: LD_VAR 0 3
3690: PPUSH
3691: LD_INT 30
3693: PPUSH
3694: LD_INT 0
3696: PPUSH
3697: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3701: LD_EXP 35
3705: PPUSH
3706: LD_VAR 0 3
3710: PPUSH
3711: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3715: LD_VAR 0 3
3719: PPUSH
3720: LD_INT 1
3722: PPUSH
3723: LD_INT 100
3725: PPUSH
3726: CALL_OW 290
// end ; for i in selected do
3730: LD_ADDR_VAR 0 2
3734: PUSH
3735: LD_VAR 0 4
3739: PUSH
3740: FOR_IN
3741: IFFALSE 4299
// begin uc_nation := GetNation ( i ) ;
3743: LD_ADDR_OWVAR 21
3747: PUSH
3748: LD_VAR 0 2
3752: PPUSH
3753: CALL_OW 248
3757: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3758: LD_VAR 0 2
3762: PUSH
3763: LD_EXP 19
3767: PUSH
3768: LD_EXP 20
3772: PUSH
3773: LD_EXP 22
3777: PUSH
3778: LD_EXP 21
3782: PUSH
3783: EMPTY
3784: LIST
3785: LIST
3786: LIST
3787: LIST
3788: IN
3789: IFFALSE 3812
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3791: LD_INT 5
3793: PPUSH
3794: LD_INT 3
3796: PPUSH
3797: LD_INT 1
3799: PPUSH
3800: LD_INT 6
3802: PPUSH
3803: LD_INT 100
3805: PPUSH
3806: CALL 57845 0 5
3810: GO 4246
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3812: LD_VAR 0 2
3816: PUSH
3817: LD_EXP 42
3821: PUSH
3822: LD_EXP 47
3826: PUSH
3827: LD_EXP 45
3831: PUSH
3832: LD_EXP 37
3836: PUSH
3837: EMPTY
3838: LIST
3839: LIST
3840: LIST
3841: LIST
3842: IN
3843: IFFALSE 3874
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3845: LD_INT 24
3847: PPUSH
3848: LD_INT 1
3850: PPUSH
3851: LD_INT 1
3853: PPUSH
3854: LD_INT 46
3856: PPUSH
3857: LD_INT 65
3859: PPUSH
3860: LD_INT 75
3862: PPUSH
3863: CALL_OW 12
3867: PPUSH
3868: CALL 57845 0 5
3872: GO 4246
// if i = Karamazov then
3874: LD_VAR 0 2
3878: PUSH
3879: LD_EXP 48
3883: EQUAL
3884: IFFALSE 3907
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3886: LD_INT 22
3888: PPUSH
3889: LD_INT 3
3891: PPUSH
3892: LD_INT 1
3894: PPUSH
3895: LD_INT 52
3897: PPUSH
3898: LD_INT 100
3900: PPUSH
3901: CALL 57845 0 5
3905: GO 4246
// if i = Brown then
3907: LD_VAR 0 2
3911: PUSH
3912: LD_EXP 24
3916: EQUAL
3917: IFFALSE 3940
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
3919: LD_INT 3
3921: PPUSH
3922: LD_INT 3
3924: PPUSH
3925: LD_INT 1
3927: PPUSH
3928: LD_INT 13
3930: PPUSH
3931: LD_INT 100
3933: PPUSH
3934: CALL 57845 0 5
3938: GO 4246
// if uc_nation = nation_american then
3940: LD_OWVAR 21
3944: PUSH
3945: LD_INT 1
3947: EQUAL
3948: IFFALSE 4099
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
3950: LD_INT 3
3952: PUSH
3953: LD_INT 5
3955: PUSH
3956: LD_INT 5
3958: PUSH
3959: EMPTY
3960: LIST
3961: LIST
3962: LIST
3963: PUSH
3964: LD_OWVAR 21
3968: PUSH
3969: LD_INT 3
3971: MOD
3972: PUSH
3973: LD_INT 1
3975: PLUS
3976: ARRAY
3977: PPUSH
3978: LD_INT 1
3980: PUSH
3981: LD_INT 3
3983: PUSH
3984: LD_INT 1
3986: PUSH
3987: EMPTY
3988: LIST
3989: LIST
3990: LIST
3991: PUSH
3992: LD_OWVAR 21
3996: PUSH
3997: LD_INT 3
3999: MOD
4000: PUSH
4001: LD_INT 1
4003: PLUS
4004: ARRAY
4005: PPUSH
4006: LD_INT 1
4008: PPUSH
4009: LD_INT 11
4011: PUSH
4012: LD_INT 4
4014: PUSH
4015: LD_INT 5
4017: PUSH
4018: EMPTY
4019: LIST
4020: LIST
4021: LIST
4022: PUSH
4023: LD_INT 6
4025: PUSH
4026: LD_INT 7
4028: PUSH
4029: LD_INT 9
4031: PUSH
4032: EMPTY
4033: LIST
4034: LIST
4035: LIST
4036: PUSH
4037: LD_INT 6
4039: PUSH
4040: LD_INT 9
4042: PUSH
4043: LD_INT 12
4045: PUSH
4046: EMPTY
4047: LIST
4048: LIST
4049: LIST
4050: PUSH
4051: EMPTY
4052: LIST
4053: LIST
4054: LIST
4055: PUSH
4056: LD_OWVAR 21
4060: PUSH
4061: LD_INT 3
4063: MOD
4064: PUSH
4065: LD_INT 1
4067: PLUS
4068: ARRAY
4069: PUSH
4070: LD_INT 1
4072: PPUSH
4073: LD_INT 3
4075: PPUSH
4076: CALL_OW 12
4080: ARRAY
4081: PPUSH
4082: LD_INT 65
4084: PPUSH
4085: LD_INT 75
4087: PPUSH
4088: CALL_OW 12
4092: PPUSH
4093: CALL 57845 0 5
// end else
4097: GO 4246
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4099: LD_INT 22
4101: PUSH
4102: LD_INT 23
4104: PUSH
4105: LD_INT 23
4107: PUSH
4108: EMPTY
4109: LIST
4110: LIST
4111: LIST
4112: PUSH
4113: LD_OWVAR 21
4117: PUSH
4118: LD_INT 3
4120: MOD
4121: PUSH
4122: LD_INT 1
4124: PLUS
4125: ARRAY
4126: PPUSH
4127: LD_INT 1
4129: PUSH
4130: LD_INT 3
4132: PUSH
4133: LD_INT 1
4135: PUSH
4136: EMPTY
4137: LIST
4138: LIST
4139: LIST
4140: PUSH
4141: LD_OWVAR 21
4145: PUSH
4146: LD_INT 3
4148: MOD
4149: PUSH
4150: LD_INT 1
4152: PLUS
4153: ARRAY
4154: PPUSH
4155: LD_INT 1
4157: PPUSH
4158: LD_INT 45
4160: PUSH
4161: LD_INT 43
4163: PUSH
4164: LD_INT 44
4166: PUSH
4167: EMPTY
4168: LIST
4169: LIST
4170: LIST
4171: PUSH
4172: LD_INT 46
4174: PUSH
4175: LD_INT 45
4177: PUSH
4178: LD_INT 44
4180: PUSH
4181: EMPTY
4182: LIST
4183: LIST
4184: LIST
4185: PUSH
4186: LD_INT 46
4188: PUSH
4189: LD_INT 43
4191: PUSH
4192: LD_INT 45
4194: PUSH
4195: EMPTY
4196: LIST
4197: LIST
4198: LIST
4199: PUSH
4200: EMPTY
4201: LIST
4202: LIST
4203: LIST
4204: PUSH
4205: LD_OWVAR 21
4209: PUSH
4210: LD_INT 3
4212: MOD
4213: PUSH
4214: LD_INT 1
4216: PLUS
4217: ARRAY
4218: PUSH
4219: LD_INT 1
4221: PPUSH
4222: LD_INT 3
4224: PPUSH
4225: CALL_OW 12
4229: ARRAY
4230: PPUSH
4231: LD_INT 65
4233: PPUSH
4234: LD_INT 75
4236: PPUSH
4237: CALL_OW 12
4241: PPUSH
4242: CALL 57845 0 5
// end ; veh := CreateVehicle ;
4246: LD_ADDR_VAR 0 3
4250: PUSH
4251: CALL_OW 45
4255: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4256: LD_VAR 0 3
4260: PPUSH
4261: LD_INT 3
4263: PPUSH
4264: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4268: LD_VAR 0 3
4272: PPUSH
4273: LD_INT 30
4275: PPUSH
4276: LD_INT 0
4278: PPUSH
4279: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4283: LD_VAR 0 2
4287: PPUSH
4288: LD_VAR 0 3
4292: PPUSH
4293: CALL_OW 52
// end ;
4297: GO 3740
4299: POP
4300: POP
// if artifactArCaptured then
4301: LD_EXP 9
4305: IFFALSE 4391
// begin uc_nation := nation_american ;
4307: LD_ADDR_OWVAR 21
4311: PUSH
4312: LD_INT 1
4314: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4315: LD_INT 3
4317: PPUSH
4318: LD_INT 3
4320: PPUSH
4321: LD_INT 3
4323: PPUSH
4324: LD_INT 12
4326: PPUSH
4327: LD_INT 100
4329: PPUSH
4330: CALL 57845 0 5
// veh := CreateVehicle ;
4334: LD_ADDR_VAR 0 3
4338: PUSH
4339: CALL_OW 45
4343: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4344: LD_VAR 0 3
4348: PPUSH
4349: LD_INT 3
4351: PPUSH
4352: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4356: LD_VAR 0 3
4360: PPUSH
4361: LD_INT 198
4363: PPUSH
4364: LD_INT 22
4366: PPUSH
4367: LD_INT 0
4369: PPUSH
4370: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4374: LD_VAR 0 3
4378: PPUSH
4379: LD_INT 4
4381: PPUSH
4382: LD_INT 50
4384: PPUSH
4385: CALL_OW 290
// end else
4389: GO 4410
// begin CreateResourcesXY ( mat_artifact , 267 , 226 , 5 , false ) ;
4391: LD_INT 4
4393: PPUSH
4394: LD_INT 267
4396: PPUSH
4397: LD_INT 226
4399: PPUSH
4400: LD_INT 5
4402: PPUSH
4403: LD_INT 0
4405: PPUSH
4406: CALL_OW 58
// end ; uc_nation := nation_american ;
4410: LD_ADDR_OWVAR 21
4414: PUSH
4415: LD_INT 1
4417: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4418: LD_INT 3
4420: PPUSH
4421: LD_INT 3
4423: PPUSH
4424: LD_INT 3
4426: PPUSH
4427: LD_INT 12
4429: PPUSH
4430: LD_INT 100
4432: PPUSH
4433: CALL 57845 0 5
// veh := CreateVehicle ;
4437: LD_ADDR_VAR 0 3
4441: PUSH
4442: CALL_OW 45
4446: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4447: LD_VAR 0 3
4451: PPUSH
4452: LD_INT 3
4454: PPUSH
4455: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4459: LD_VAR 0 3
4463: PPUSH
4464: LD_INT 218
4466: PPUSH
4467: LD_INT 23
4469: PPUSH
4470: LD_INT 0
4472: PPUSH
4473: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4477: LD_VAR 0 3
4481: PPUSH
4482: LD_INT 4
4484: PPUSH
4485: LD_INT 30
4487: PPUSH
4488: CALL_OW 290
// uc_nation := nation_russian ;
4492: LD_ADDR_OWVAR 21
4496: PUSH
4497: LD_INT 3
4499: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4500: LD_INT 22
4502: PPUSH
4503: LD_INT 3
4505: PPUSH
4506: LD_INT 3
4508: PPUSH
4509: LD_INT 51
4511: PPUSH
4512: LD_INT 100
4514: PPUSH
4515: CALL 57845 0 5
// veh := CreateVehicle ;
4519: LD_ADDR_VAR 0 3
4523: PUSH
4524: CALL_OW 45
4528: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4529: LD_VAR 0 3
4533: PPUSH
4534: LD_INT 3
4536: PPUSH
4537: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4541: LD_VAR 0 3
4545: PPUSH
4546: LD_INT 214
4548: PPUSH
4549: LD_INT 20
4551: PPUSH
4552: LD_INT 0
4554: PPUSH
4555: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4559: LD_VAR 0 3
4563: PPUSH
4564: LD_INT 4
4566: PPUSH
4567: LD_INT 40
4569: PPUSH
4570: CALL_OW 290
// end ; end_of_file
4574: LD_VAR 0 1
4578: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
4579: LD_INT 0
4581: PPUSH
4582: PPUSH
4583: PPUSH
4584: PPUSH
4585: PPUSH
4586: PPUSH
4587: PPUSH
4588: PPUSH
4589: PPUSH
4590: PPUSH
// InitHc ;
4591: CALL_OW 19
// uc_side := 1 ;
4595: LD_ADDR_OWVAR 20
4599: PUSH
4600: LD_INT 1
4602: ST_TO_ADDR
// uc_nation := 1 ;
4603: LD_ADDR_OWVAR 21
4607: PUSH
4608: LD_INT 1
4610: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
4611: LD_ADDR_VAR 0 2
4615: PUSH
4616: LD_INT 22
4618: PUSH
4619: LD_INT 1
4621: PUSH
4622: EMPTY
4623: LIST
4624: LIST
4625: PUSH
4626: LD_INT 21
4628: PUSH
4629: LD_INT 3
4631: PUSH
4632: EMPTY
4633: LIST
4634: LIST
4635: PUSH
4636: EMPTY
4637: LIST
4638: LIST
4639: PPUSH
4640: CALL_OW 69
4644: PUSH
4645: FOR_IN
4646: IFFALSE 4662
// SetBLevel ( i , 10 ) ;
4648: LD_VAR 0 2
4652: PPUSH
4653: LD_INT 10
4655: PPUSH
4656: CALL_OW 241
4660: GO 4645
4662: POP
4663: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 7500 ) ;
4664: LD_INT 387
4666: PPUSH
4667: CALL_OW 274
4671: PPUSH
4672: LD_INT 1
4674: PPUSH
4675: LD_INT 7500
4677: PPUSH
4678: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
4682: LD_INT 387
4684: PPUSH
4685: CALL_OW 274
4689: PPUSH
4690: LD_INT 2
4692: PPUSH
4693: LD_INT 4000
4695: PPUSH
4696: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
4700: LD_INT 387
4702: PPUSH
4703: CALL_OW 274
4707: PPUSH
4708: LD_INT 3
4710: PPUSH
4711: LD_INT 50
4713: PPUSH
4714: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 5500 ) ;
4718: LD_INT 476
4720: PPUSH
4721: CALL_OW 274
4725: PPUSH
4726: LD_INT 1
4728: PPUSH
4729: LD_INT 5500
4731: PPUSH
4732: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
4736: LD_INT 476
4738: PPUSH
4739: CALL_OW 274
4743: PPUSH
4744: LD_INT 2
4746: PPUSH
4747: LD_INT 4000
4749: PPUSH
4750: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
4754: LD_INT 476
4756: PPUSH
4757: CALL_OW 274
4761: PPUSH
4762: LD_INT 3
4764: PPUSH
4765: LD_INT 10
4767: PPUSH
4768: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
4772: LD_ADDR_EXP 52
4776: PUSH
4777: LD_STRING Powell
4779: PPUSH
4780: CALL_OW 25
4784: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
4785: LD_EXP 52
4789: PPUSH
4790: LD_INT 387
4792: PPUSH
4793: CALL_OW 52
// tmp := [ ] ;
4797: LD_ADDR_VAR 0 6
4801: PUSH
4802: EMPTY
4803: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
4804: LD_ADDR_EXP 19
4808: PUSH
4809: LD_STRING Lisa
4811: PPUSH
4812: LD_EXP 1
4816: NOT
4817: PPUSH
4818: LD_STRING 12p_
4820: PPUSH
4821: CALL 50610 0 3
4825: ST_TO_ADDR
// if Lisa then
4826: LD_EXP 19
4830: IFFALSE 4848
// tmp := tmp ^ Lisa ;
4832: LD_ADDR_VAR 0 6
4836: PUSH
4837: LD_VAR 0 6
4841: PUSH
4842: LD_EXP 19
4846: ADD
4847: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
4848: LD_ADDR_EXP 20
4852: PUSH
4853: LD_STRING Donaldson
4855: PPUSH
4856: LD_EXP 1
4860: NOT
4861: PPUSH
4862: LD_STRING 12p_
4864: PPUSH
4865: CALL 50610 0 3
4869: ST_TO_ADDR
// if Donaldson then
4870: LD_EXP 20
4874: IFFALSE 4892
// tmp := tmp ^ Donaldson ;
4876: LD_ADDR_VAR 0 6
4880: PUSH
4881: LD_VAR 0 6
4885: PUSH
4886: LD_EXP 20
4890: ADD
4891: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
4892: LD_ADDR_EXP 21
4896: PUSH
4897: LD_STRING Bobby
4899: PPUSH
4900: LD_EXP 1
4904: NOT
4905: PPUSH
4906: LD_STRING 12p_
4908: PPUSH
4909: CALL 50610 0 3
4913: ST_TO_ADDR
// if Bobby then
4914: LD_EXP 21
4918: IFFALSE 4936
// tmp := tmp ^ Bobby ;
4920: LD_ADDR_VAR 0 6
4924: PUSH
4925: LD_VAR 0 6
4929: PUSH
4930: LD_EXP 21
4934: ADD
4935: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
4936: LD_ADDR_EXP 22
4940: PUSH
4941: LD_STRING Cyrus
4943: PPUSH
4944: LD_EXP 1
4948: NOT
4949: PPUSH
4950: LD_STRING 12p_
4952: PPUSH
4953: CALL 50610 0 3
4957: ST_TO_ADDR
// if Cyrus then
4958: LD_EXP 22
4962: IFFALSE 4980
// tmp := tmp ^ Cyrus ;
4964: LD_ADDR_VAR 0 6
4968: PUSH
4969: LD_VAR 0 6
4973: PUSH
4974: LD_EXP 22
4978: ADD
4979: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
4980: LD_ADDR_EXP 24
4984: PUSH
4985: LD_STRING Brown
4987: PPUSH
4988: LD_EXP 1
4992: NOT
4993: PPUSH
4994: LD_STRING 12p_
4996: PPUSH
4997: CALL 50610 0 3
5001: ST_TO_ADDR
// if Brown then
5002: LD_EXP 24
5006: IFFALSE 5024
// tmp := tmp ^ Brown ;
5008: LD_ADDR_VAR 0 6
5012: PUSH
5013: LD_VAR 0 6
5017: PUSH
5018: LD_EXP 24
5022: ADD
5023: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5024: LD_ADDR_EXP 25
5028: PUSH
5029: LD_STRING Gladstone
5031: PPUSH
5032: LD_EXP 1
5036: NOT
5037: PPUSH
5038: LD_STRING 12p_
5040: PPUSH
5041: CALL 50610 0 3
5045: ST_TO_ADDR
// if Gladstone then
5046: LD_EXP 25
5050: IFFALSE 5068
// tmp := tmp ^ Gladstone ;
5052: LD_ADDR_VAR 0 6
5056: PUSH
5057: LD_VAR 0 6
5061: PUSH
5062: LD_EXP 25
5066: ADD
5067: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5068: LD_ADDR_EXP 26
5072: PUSH
5073: LD_STRING Houten
5075: PPUSH
5076: LD_EXP 1
5080: NOT
5081: PPUSH
5082: LD_STRING 12p_
5084: PPUSH
5085: CALL 50610 0 3
5089: ST_TO_ADDR
// if Houten then
5090: LD_EXP 26
5094: IFFALSE 5112
// tmp := tmp ^ Houten ;
5096: LD_ADDR_VAR 0 6
5100: PUSH
5101: LD_VAR 0 6
5105: PUSH
5106: LD_EXP 26
5110: ADD
5111: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5112: LD_ADDR_EXP 27
5116: PUSH
5117: LD_STRING Cornel
5119: PPUSH
5120: LD_EXP 1
5124: NOT
5125: PPUSH
5126: LD_STRING 12p_
5128: PPUSH
5129: CALL 50610 0 3
5133: ST_TO_ADDR
// if Cornel then
5134: LD_EXP 27
5138: IFFALSE 5156
// tmp := tmp ^ Cornel ;
5140: LD_ADDR_VAR 0 6
5144: PUSH
5145: LD_VAR 0 6
5149: PUSH
5150: LD_EXP 27
5154: ADD
5155: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5156: LD_ADDR_EXP 28
5160: PUSH
5161: LD_STRING Gary
5163: PPUSH
5164: LD_EXP 1
5168: NOT
5169: PPUSH
5170: LD_STRING 12p_
5172: PPUSH
5173: CALL 50610 0 3
5177: ST_TO_ADDR
// if Gary then
5178: LD_EXP 28
5182: IFFALSE 5200
// tmp := tmp ^ Gary ;
5184: LD_ADDR_VAR 0 6
5188: PUSH
5189: LD_VAR 0 6
5193: PUSH
5194: LD_EXP 28
5198: ADD
5199: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5200: LD_ADDR_EXP 30
5204: PUSH
5205: LD_STRING Kikuchi
5207: PPUSH
5208: LD_EXP 1
5212: NOT
5213: PPUSH
5214: LD_STRING 12p_
5216: PPUSH
5217: CALL 50610 0 3
5221: ST_TO_ADDR
// if Kikuchi then
5222: LD_EXP 30
5226: IFFALSE 5244
// tmp := tmp ^ Kikuchi ;
5228: LD_ADDR_VAR 0 6
5232: PUSH
5233: LD_VAR 0 6
5237: PUSH
5238: LD_EXP 30
5242: ADD
5243: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5244: LD_ADDR_VAR 0 6
5248: PUSH
5249: LD_VAR 0 6
5253: PUSH
5254: LD_STRING 12p_others
5256: PPUSH
5257: CALL_OW 31
5261: UNION
5262: ST_TO_ADDR
// if tmp < 36 then
5263: LD_VAR 0 6
5267: PUSH
5268: LD_INT 36
5270: LESS
5271: IFFALSE 5338
// for i = 1 to 36 - tmp do
5273: LD_ADDR_VAR 0 2
5277: PUSH
5278: DOUBLE
5279: LD_INT 1
5281: DEC
5282: ST_TO_ADDR
5283: LD_INT 36
5285: PUSH
5286: LD_VAR 0 6
5290: MINUS
5291: PUSH
5292: FOR_TO
5293: IFFALSE 5336
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5295: LD_INT 1
5297: PPUSH
5298: LD_VAR 0 2
5302: PUSH
5303: LD_INT 4
5305: MOD
5306: PUSH
5307: LD_INT 1
5309: PLUS
5310: PPUSH
5311: LD_INT 10
5313: PPUSH
5314: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5318: LD_ADDR_VAR 0 6
5322: PUSH
5323: LD_VAR 0 6
5327: PUSH
5328: CALL_OW 44
5332: ADD
5333: ST_TO_ADDR
// end ;
5334: GO 5292
5336: POP
5337: POP
// for i in tmp do
5338: LD_ADDR_VAR 0 2
5342: PUSH
5343: LD_VAR 0 6
5347: PUSH
5348: FOR_IN
5349: IFFALSE 5374
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5351: LD_VAR 0 2
5355: PPUSH
5356: LD_INT 62
5358: PPUSH
5359: LD_INT 93
5361: PPUSH
5362: LD_INT 9
5364: PPUSH
5365: LD_INT 0
5367: PPUSH
5368: CALL_OW 50
5372: GO 5348
5374: POP
5375: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
5376: LD_ADDR_EXP 87
5380: PUSH
5381: LD_EXP 87
5385: PPUSH
5386: LD_INT 4
5388: PPUSH
5389: LD_INT 22
5391: PUSH
5392: LD_INT 1
5394: PUSH
5395: EMPTY
5396: LIST
5397: LIST
5398: PPUSH
5399: CALL_OW 69
5403: PUSH
5404: LD_EXP 52
5408: DIFF
5409: PPUSH
5410: CALL_OW 1
5414: ST_TO_ADDR
// uc_side := 0 ;
5415: LD_ADDR_OWVAR 20
5419: PUSH
5420: LD_INT 0
5422: ST_TO_ADDR
// uc_nation := 0 ;
5423: LD_ADDR_OWVAR 21
5427: PUSH
5428: LD_INT 0
5430: ST_TO_ADDR
// for i = 1 to 4 do
5431: LD_ADDR_VAR 0 2
5435: PUSH
5436: DOUBLE
5437: LD_INT 1
5439: DEC
5440: ST_TO_ADDR
5441: LD_INT 4
5443: PUSH
5444: FOR_TO
5445: IFFALSE 5476
// begin InitHc ;
5447: CALL_OW 19
// hc_class := class_apeman ;
5451: LD_ADDR_OWVAR 28
5455: PUSH
5456: LD_INT 12
5458: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
5459: CALL_OW 44
5463: PPUSH
5464: LD_INT 11
5466: PPUSH
5467: LD_INT 0
5469: PPUSH
5470: CALL_OW 49
// end ;
5474: GO 5444
5476: POP
5477: POP
// end ;
5478: LD_VAR 0 1
5482: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
5483: LD_EXP 4
5487: NOT
5488: PUSH
5489: LD_INT 4
5491: PPUSH
5492: LD_INT 1
5494: PPUSH
5495: CALL 45684 0 2
5499: NOT
5500: AND
5501: IFFALSE 6273
5503: GO 5505
5505: DISABLE
5506: LD_INT 0
5508: PPUSH
5509: PPUSH
5510: PPUSH
// begin enable ;
5511: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
5512: LD_INT 22
5514: PUSH
5515: LD_INT 1
5517: PUSH
5518: EMPTY
5519: LIST
5520: LIST
5521: PUSH
5522: LD_INT 23
5524: PUSH
5525: LD_INT 1
5527: PUSH
5528: EMPTY
5529: LIST
5530: LIST
5531: PUSH
5532: LD_INT 30
5534: PUSH
5535: LD_INT 3
5537: PUSH
5538: EMPTY
5539: LIST
5540: LIST
5541: PUSH
5542: EMPTY
5543: LIST
5544: LIST
5545: LIST
5546: PPUSH
5547: CALL_OW 69
5551: NOT
5552: IFFALSE 5556
// exit ;
5554: GO 6273
// if Prob ( 40 ) then
5556: LD_INT 40
5558: PPUSH
5559: CALL_OW 13
5563: IFFALSE 5690
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5565: LD_INT 4
5567: PPUSH
5568: LD_INT 5
5570: PUSH
5571: LD_INT 1
5573: PUSH
5574: LD_INT 2
5576: PUSH
5577: LD_INT 7
5579: PUSH
5580: EMPTY
5581: LIST
5582: LIST
5583: LIST
5584: LIST
5585: PUSH
5586: LD_INT 5
5588: PUSH
5589: LD_INT 1
5591: PUSH
5592: LD_INT 2
5594: PUSH
5595: LD_INT 7
5597: PUSH
5598: EMPTY
5599: LIST
5600: LIST
5601: LIST
5602: LIST
5603: PUSH
5604: LD_INT 5
5606: PUSH
5607: LD_INT 1
5609: PUSH
5610: LD_INT 2
5612: PUSH
5613: LD_INT 7
5615: PUSH
5616: EMPTY
5617: LIST
5618: LIST
5619: LIST
5620: LIST
5621: PUSH
5622: LD_INT 5
5624: PUSH
5625: LD_INT 1
5627: PUSH
5628: LD_INT 2
5630: PUSH
5631: LD_INT 6
5633: PUSH
5634: EMPTY
5635: LIST
5636: LIST
5637: LIST
5638: LIST
5639: PUSH
5640: LD_INT 5
5642: PUSH
5643: LD_INT 1
5645: PUSH
5646: LD_INT 2
5648: PUSH
5649: LD_INT 6
5651: PUSH
5652: EMPTY
5653: LIST
5654: LIST
5655: LIST
5656: LIST
5657: PUSH
5658: LD_INT 5
5660: PUSH
5661: LD_INT 1
5663: PUSH
5664: LD_INT 2
5666: PUSH
5667: LD_INT 6
5669: PUSH
5670: EMPTY
5671: LIST
5672: LIST
5673: LIST
5674: LIST
5675: PUSH
5676: EMPTY
5677: LIST
5678: LIST
5679: LIST
5680: LIST
5681: LIST
5682: LIST
5683: PPUSH
5684: CALL 44266 0 2
// end else
5688: GO 5813
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5690: LD_INT 4
5692: PPUSH
5693: LD_INT 5
5695: PUSH
5696: LD_INT 1
5698: PUSH
5699: LD_INT 2
5701: PUSH
5702: LD_INT 7
5704: PUSH
5705: EMPTY
5706: LIST
5707: LIST
5708: LIST
5709: LIST
5710: PUSH
5711: LD_INT 5
5713: PUSH
5714: LD_INT 1
5716: PUSH
5717: LD_INT 2
5719: PUSH
5720: LD_INT 9
5722: PUSH
5723: EMPTY
5724: LIST
5725: LIST
5726: LIST
5727: LIST
5728: PUSH
5729: LD_INT 5
5731: PUSH
5732: LD_INT 1
5734: PUSH
5735: LD_INT 2
5737: PUSH
5738: LD_INT 9
5740: PUSH
5741: EMPTY
5742: LIST
5743: LIST
5744: LIST
5745: LIST
5746: PUSH
5747: LD_INT 5
5749: PUSH
5750: LD_INT 1
5752: PUSH
5753: LD_INT 2
5755: PUSH
5756: LD_INT 6
5758: PUSH
5759: EMPTY
5760: LIST
5761: LIST
5762: LIST
5763: LIST
5764: PUSH
5765: LD_INT 5
5767: PUSH
5768: LD_INT 1
5770: PUSH
5771: LD_INT 2
5773: PUSH
5774: LD_INT 6
5776: PUSH
5777: EMPTY
5778: LIST
5779: LIST
5780: LIST
5781: LIST
5782: PUSH
5783: LD_INT 5
5785: PUSH
5786: LD_INT 1
5788: PUSH
5789: LD_INT 2
5791: PUSH
5792: LD_INT 6
5794: PUSH
5795: EMPTY
5796: LIST
5797: LIST
5798: LIST
5799: LIST
5800: PUSH
5801: EMPTY
5802: LIST
5803: LIST
5804: LIST
5805: LIST
5806: LIST
5807: LIST
5808: PPUSH
5809: CALL 44266 0 2
// end ; repeat wait ( 0 0$1 ) ;
5813: LD_INT 35
5815: PPUSH
5816: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
5820: LD_INT 4
5822: PPUSH
5823: LD_INT 1
5825: PPUSH
5826: CALL 45684 0 2
5830: PUSH
5831: LD_INT 6
5833: GREATEREQUAL
5834: IFFALSE 5813
// wait ( 0 0$30 ) ;
5836: LD_INT 1050
5838: PPUSH
5839: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
5843: LD_ADDR_VAR 0 2
5847: PUSH
5848: LD_INT 4
5850: PPUSH
5851: LD_INT 1
5853: PPUSH
5854: CALL 45684 0 2
5858: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
5859: LD_ADDR_EXP 106
5863: PUSH
5864: LD_EXP 106
5868: PPUSH
5869: LD_INT 4
5871: PPUSH
5872: LD_EXP 106
5876: PUSH
5877: LD_INT 4
5879: ARRAY
5880: PUSH
5881: LD_VAR 0 2
5885: DIFF
5886: PPUSH
5887: CALL_OW 1
5891: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5892: LD_ADDR_VAR 0 3
5896: PUSH
5897: LD_INT 0
5899: PPUSH
5900: LD_INT 2
5902: PPUSH
5903: CALL_OW 12
5907: ST_TO_ADDR
// if target then
5908: LD_VAR 0 3
5912: IFFALSE 6040
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5914: LD_ADDR_VAR 0 2
5918: PUSH
5919: LD_VAR 0 2
5923: PPUSH
5924: LD_INT 24
5926: PUSH
5927: LD_INT 250
5929: PUSH
5930: EMPTY
5931: LIST
5932: LIST
5933: PPUSH
5934: CALL_OW 72
5938: ST_TO_ADDR
// for i in tmp do
5939: LD_ADDR_VAR 0 1
5943: PUSH
5944: LD_VAR 0 2
5948: PUSH
5949: FOR_IN
5950: IFFALSE 5990
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
5952: LD_VAR 0 1
5956: PPUSH
5957: LD_INT 114
5959: PPUSH
5960: LD_INT 108
5962: PPUSH
5963: CALL_OW 297
5967: PUSH
5968: LD_INT 9
5970: GREATER
5971: IFFALSE 5988
// ComMoveXY ( i , 114 , 108 ) ;
5973: LD_VAR 0 1
5977: PPUSH
5978: LD_INT 114
5980: PPUSH
5981: LD_INT 108
5983: PPUSH
5984: CALL_OW 111
5988: GO 5949
5990: POP
5991: POP
// wait ( 0 0$1 ) ;
5992: LD_INT 35
5994: PPUSH
5995: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
5999: LD_VAR 0 2
6003: PPUSH
6004: LD_INT 92
6006: PUSH
6007: LD_INT 114
6009: PUSH
6010: LD_INT 108
6012: PUSH
6013: LD_INT 9
6015: PUSH
6016: EMPTY
6017: LIST
6018: LIST
6019: LIST
6020: LIST
6021: PPUSH
6022: CALL_OW 72
6026: PUSH
6027: LD_VAR 0 2
6031: PUSH
6032: LD_INT 1
6034: MINUS
6035: GREATEREQUAL
6036: IFFALSE 5914
// end else
6038: GO 6164
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6040: LD_ADDR_VAR 0 2
6044: PUSH
6045: LD_VAR 0 2
6049: PPUSH
6050: LD_INT 24
6052: PUSH
6053: LD_INT 250
6055: PUSH
6056: EMPTY
6057: LIST
6058: LIST
6059: PPUSH
6060: CALL_OW 72
6064: ST_TO_ADDR
// for i in tmp do
6065: LD_ADDR_VAR 0 1
6069: PUSH
6070: LD_VAR 0 2
6074: PUSH
6075: FOR_IN
6076: IFFALSE 6116
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6078: LD_VAR 0 1
6082: PPUSH
6083: LD_INT 129
6085: PPUSH
6086: LD_INT 139
6088: PPUSH
6089: CALL_OW 297
6093: PUSH
6094: LD_INT 9
6096: GREATER
6097: IFFALSE 6114
// ComMoveXY ( i , 129 , 139 ) ;
6099: LD_VAR 0 1
6103: PPUSH
6104: LD_INT 129
6106: PPUSH
6107: LD_INT 139
6109: PPUSH
6110: CALL_OW 111
6114: GO 6075
6116: POP
6117: POP
// wait ( 0 0$1 ) ;
6118: LD_INT 35
6120: PPUSH
6121: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
6125: LD_VAR 0 2
6129: PPUSH
6130: LD_INT 92
6132: PUSH
6133: LD_INT 129
6135: PUSH
6136: LD_INT 139
6138: PUSH
6139: LD_INT 9
6141: PUSH
6142: EMPTY
6143: LIST
6144: LIST
6145: LIST
6146: LIST
6147: PPUSH
6148: CALL_OW 72
6152: PUSH
6153: LD_VAR 0 2
6157: PUSH
6158: LD_INT 1
6160: MINUS
6161: GREATEREQUAL
6162: IFFALSE 6040
// end ; repeat wait ( 0 0$1 ) ;
6164: LD_INT 35
6166: PPUSH
6167: CALL_OW 67
// for i in tmp do
6171: LD_ADDR_VAR 0 1
6175: PUSH
6176: LD_VAR 0 2
6180: PUSH
6181: FOR_IN
6182: IFFALSE 6264
// begin if GetLives ( i ) > 251 then
6184: LD_VAR 0 1
6188: PPUSH
6189: CALL_OW 256
6193: PUSH
6194: LD_INT 251
6196: GREATER
6197: IFFALSE 6235
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6199: LD_VAR 0 1
6203: PPUSH
6204: LD_INT 81
6206: PUSH
6207: LD_INT 1
6209: PUSH
6210: EMPTY
6211: LIST
6212: LIST
6213: PPUSH
6214: CALL_OW 69
6218: PPUSH
6219: LD_VAR 0 1
6223: PPUSH
6224: CALL_OW 74
6228: PPUSH
6229: CALL_OW 115
6233: GO 6262
// if IsDead ( i ) then
6235: LD_VAR 0 1
6239: PPUSH
6240: CALL_OW 301
6244: IFFALSE 6262
// tmp := tmp diff i ;
6246: LD_ADDR_VAR 0 2
6250: PUSH
6251: LD_VAR 0 2
6255: PUSH
6256: LD_VAR 0 1
6260: DIFF
6261: ST_TO_ADDR
// end ;
6262: GO 6181
6264: POP
6265: POP
// until not tmp ;
6266: LD_VAR 0 2
6270: NOT
6271: IFFALSE 6164
// end ;
6273: PPOPN 3
6275: END
// every 30 30$00 trigger not americanDestroyed do
6276: LD_EXP 4
6280: NOT
6281: IFFALSE 6346
6283: GO 6285
6285: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 10 10$00 ] [ Difficulty ] ) ;
6286: LD_INT 63000
6288: PUSH
6289: LD_INT 42000
6291: PUSH
6292: LD_INT 21000
6294: PUSH
6295: EMPTY
6296: LIST
6297: LIST
6298: LIST
6299: PUSH
6300: LD_OWVAR 67
6304: ARRAY
6305: PPUSH
6306: CALL_OW 67
// if americanDestroyed then
6310: LD_EXP 4
6314: IFFALSE 6318
// exit ;
6316: GO 6346
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6318: LD_INT 4
6320: PPUSH
6321: LD_INT 5
6323: PUSH
6324: LD_INT 3
6326: PUSH
6327: LD_INT 1
6329: PUSH
6330: LD_INT 8
6332: PUSH
6333: EMPTY
6334: LIST
6335: LIST
6336: LIST
6337: LIST
6338: PUSH
6339: EMPTY
6340: LIST
6341: PPUSH
6342: CALL 44266 0 2
// end ; end_of_file
6346: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6347: LD_INT 0
6349: PPUSH
6350: PPUSH
6351: PPUSH
6352: PPUSH
6353: PPUSH
// side := 2 ;
6354: LD_ADDR_VAR 0 5
6358: PUSH
6359: LD_INT 2
6361: ST_TO_ADDR
// InitHc ;
6362: CALL_OW 19
// uc_side := side ;
6366: LD_ADDR_OWVAR 20
6370: PUSH
6371: LD_VAR 0 5
6375: ST_TO_ADDR
// uc_nation := 2 ;
6376: LD_ADDR_OWVAR 21
6380: PUSH
6381: LD_INT 2
6383: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
6384: LD_ADDR_VAR 0 2
6388: PUSH
6389: LD_INT 22
6391: PUSH
6392: LD_INT 2
6394: PUSH
6395: EMPTY
6396: LIST
6397: LIST
6398: PUSH
6399: LD_INT 21
6401: PUSH
6402: LD_INT 3
6404: PUSH
6405: EMPTY
6406: LIST
6407: LIST
6408: PUSH
6409: EMPTY
6410: LIST
6411: LIST
6412: PPUSH
6413: CALL_OW 69
6417: PUSH
6418: FOR_IN
6419: IFFALSE 6435
// SetBLevel ( i , 10 ) ;
6421: LD_VAR 0 2
6425: PPUSH
6426: LD_INT 10
6428: PPUSH
6429: CALL_OW 241
6433: GO 6418
6435: POP
6436: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6437: LD_ADDR_VAR 0 4
6441: PUSH
6442: LD_INT 22
6444: PUSH
6445: LD_VAR 0 5
6449: PUSH
6450: EMPTY
6451: LIST
6452: LIST
6453: PUSH
6454: LD_INT 30
6456: PUSH
6457: LD_INT 32
6459: PUSH
6460: EMPTY
6461: LIST
6462: LIST
6463: PUSH
6464: LD_INT 58
6466: PUSH
6467: EMPTY
6468: LIST
6469: PUSH
6470: EMPTY
6471: LIST
6472: LIST
6473: LIST
6474: PPUSH
6475: CALL_OW 69
6479: ST_TO_ADDR
// for i = 1 to 10 do
6480: LD_ADDR_VAR 0 2
6484: PUSH
6485: DOUBLE
6486: LD_INT 1
6488: DEC
6489: ST_TO_ADDR
6490: LD_INT 10
6492: PUSH
6493: FOR_TO
6494: IFFALSE 6566
// begin uc_nation := nation_nature ;
6496: LD_ADDR_OWVAR 21
6500: PUSH
6501: LD_INT 0
6503: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6504: LD_ADDR_OWVAR 28
6508: PUSH
6509: LD_INT 15
6511: ST_TO_ADDR
// hc_gallery :=  ;
6512: LD_ADDR_OWVAR 33
6516: PUSH
6517: LD_STRING 
6519: ST_TO_ADDR
// hc_name :=  ;
6520: LD_ADDR_OWVAR 26
6524: PUSH
6525: LD_STRING 
6527: ST_TO_ADDR
// un := CreateHuman ;
6528: LD_ADDR_VAR 0 3
6532: PUSH
6533: CALL_OW 44
6537: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
6538: LD_VAR 0 3
6542: PPUSH
6543: LD_VAR 0 4
6547: PUSH
6548: LD_VAR 0 4
6552: PUSH
6553: LD_VAR 0 2
6557: MINUS
6558: ARRAY
6559: PPUSH
6560: CALL_OW 52
// end ;
6564: GO 6493
6566: POP
6567: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
6568: LD_INT 503
6570: PPUSH
6571: LD_INT 27
6573: PPUSH
6574: LD_STRING 
6576: PPUSH
6577: LD_INT 8
6579: PUSH
6580: LD_INT 9
6582: PUSH
6583: LD_INT 10
6585: PUSH
6586: EMPTY
6587: LIST
6588: LIST
6589: LIST
6590: PUSH
6591: LD_OWVAR 67
6595: ARRAY
6596: PPUSH
6597: LD_INT 3000
6599: PUSH
6600: LD_INT 500
6602: PUSH
6603: LD_INT 150
6605: PUSH
6606: EMPTY
6607: LIST
6608: LIST
6609: LIST
6610: PPUSH
6611: LD_INT 16
6613: PUSH
6614: LD_INT 6
6616: PUSH
6617: LD_INT 6
6619: PUSH
6620: LD_INT 6
6622: PUSH
6623: EMPTY
6624: LIST
6625: LIST
6626: LIST
6627: LIST
6628: PPUSH
6629: CALL 61254 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
6633: LD_ADDR_EXP 87
6637: PUSH
6638: LD_EXP 87
6642: PPUSH
6643: LD_INT 1
6645: PPUSH
6646: LD_INT 22
6648: PUSH
6649: LD_VAR 0 5
6653: PUSH
6654: EMPTY
6655: LIST
6656: LIST
6657: PUSH
6658: LD_INT 23
6660: PUSH
6661: LD_INT 2
6663: PUSH
6664: EMPTY
6665: LIST
6666: LIST
6667: PUSH
6668: LD_INT 3
6670: PUSH
6671: LD_INT 21
6673: PUSH
6674: LD_INT 2
6676: PUSH
6677: EMPTY
6678: LIST
6679: LIST
6680: PUSH
6681: EMPTY
6682: LIST
6683: LIST
6684: PUSH
6685: EMPTY
6686: LIST
6687: LIST
6688: LIST
6689: PPUSH
6690: CALL_OW 69
6694: PPUSH
6695: CALL_OW 1
6699: ST_TO_ADDR
// end ;
6700: LD_VAR 0 1
6704: RET
// export Omar ; export function PrepareOmarAli ; begin
6705: LD_INT 0
6707: PPUSH
// uc_side := 5 ;
6708: LD_ADDR_OWVAR 20
6712: PUSH
6713: LD_INT 5
6715: ST_TO_ADDR
// uc_nation := 2 ;
6716: LD_ADDR_OWVAR 21
6720: PUSH
6721: LD_INT 2
6723: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
6724: LD_ADDR_EXP 53
6728: PUSH
6729: LD_STRING Omar
6731: PPUSH
6732: CALL_OW 25
6736: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
6737: LD_EXP 53
6741: PPUSH
6742: LD_INT 330
6744: PPUSH
6745: LD_INT 244
6747: PPUSH
6748: LD_INT 0
6750: PPUSH
6751: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
6755: LD_EXP 53
6759: PPUSH
6760: LD_INT 252
6762: PPUSH
6763: LD_INT 220
6765: PPUSH
6766: CALL_OW 111
// end ; end_of_file
6770: LD_VAR 0 1
6774: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
6775: LD_INT 0
6777: PPUSH
6778: PPUSH
6779: PPUSH
6780: PPUSH
6781: PPUSH
// side := 8 ;
6782: LD_ADDR_VAR 0 3
6786: PUSH
6787: LD_INT 8
6789: ST_TO_ADDR
// InitHc ;
6790: CALL_OW 19
// uc_side := side ;
6794: LD_ADDR_OWVAR 20
6798: PUSH
6799: LD_VAR 0 3
6803: ST_TO_ADDR
// uc_nation := 2 ;
6804: LD_ADDR_OWVAR 21
6808: PUSH
6809: LD_INT 2
6811: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6812: LD_ADDR_VAR 0 2
6816: PUSH
6817: LD_INT 22
6819: PUSH
6820: LD_VAR 0 3
6824: PUSH
6825: EMPTY
6826: LIST
6827: LIST
6828: PUSH
6829: LD_INT 21
6831: PUSH
6832: LD_INT 3
6834: PUSH
6835: EMPTY
6836: LIST
6837: LIST
6838: PUSH
6839: EMPTY
6840: LIST
6841: LIST
6842: PPUSH
6843: CALL_OW 69
6847: PUSH
6848: FOR_IN
6849: IFFALSE 6865
// SetBLevel ( i , 10 ) ;
6851: LD_VAR 0 2
6855: PPUSH
6856: LD_INT 10
6858: PPUSH
6859: CALL_OW 241
6863: GO 6848
6865: POP
6866: POP
// Schulz := NewCharacter ( Schulz ) ;
6867: LD_ADDR_EXP 54
6871: PUSH
6872: LD_STRING Schulz
6874: PPUSH
6875: CALL_OW 25
6879: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
6880: LD_ADDR_EXP 55
6884: PUSH
6885: LD_STRING Kozlov
6887: PPUSH
6888: LD_INT 0
6890: PPUSH
6891: LD_STRING 
6893: PPUSH
6894: CALL 50610 0 3
6898: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
6899: LD_EXP 55
6903: PPUSH
6904: LD_INT 22
6906: PUSH
6907: LD_INT 8
6909: PUSH
6910: EMPTY
6911: LIST
6912: LIST
6913: PUSH
6914: LD_INT 23
6916: PUSH
6917: LD_INT 3
6919: PUSH
6920: EMPTY
6921: LIST
6922: LIST
6923: PUSH
6924: LD_INT 30
6926: PUSH
6927: LD_INT 8
6929: PUSH
6930: EMPTY
6931: LIST
6932: LIST
6933: PUSH
6934: EMPTY
6935: LIST
6936: LIST
6937: LIST
6938: PPUSH
6939: CALL_OW 69
6943: PUSH
6944: LD_INT 1
6946: ARRAY
6947: PPUSH
6948: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
6952: LD_EXP 55
6956: PPUSH
6957: LD_INT 3
6959: PPUSH
6960: LD_INT 10
6962: PPUSH
6963: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6967: LD_ADDR_VAR 0 5
6971: PUSH
6972: LD_INT 22
6974: PUSH
6975: LD_VAR 0 3
6979: PUSH
6980: EMPTY
6981: LIST
6982: LIST
6983: PUSH
6984: LD_INT 30
6986: PUSH
6987: LD_INT 32
6989: PUSH
6990: EMPTY
6991: LIST
6992: LIST
6993: PUSH
6994: LD_INT 58
6996: PUSH
6997: EMPTY
6998: LIST
6999: PUSH
7000: EMPTY
7001: LIST
7002: LIST
7003: LIST
7004: PPUSH
7005: CALL_OW 69
7009: ST_TO_ADDR
// for i = 1 to 10 do
7010: LD_ADDR_VAR 0 2
7014: PUSH
7015: DOUBLE
7016: LD_INT 1
7018: DEC
7019: ST_TO_ADDR
7020: LD_INT 10
7022: PUSH
7023: FOR_TO
7024: IFFALSE 7096
// begin uc_nation := nation_nature ;
7026: LD_ADDR_OWVAR 21
7030: PUSH
7031: LD_INT 0
7033: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7034: LD_ADDR_OWVAR 28
7038: PUSH
7039: LD_INT 15
7041: ST_TO_ADDR
// hc_gallery :=  ;
7042: LD_ADDR_OWVAR 33
7046: PUSH
7047: LD_STRING 
7049: ST_TO_ADDR
// hc_name :=  ;
7050: LD_ADDR_OWVAR 26
7054: PUSH
7055: LD_STRING 
7057: ST_TO_ADDR
// un := CreateHuman ;
7058: LD_ADDR_VAR 0 4
7062: PUSH
7063: CALL_OW 44
7067: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7068: LD_VAR 0 4
7072: PPUSH
7073: LD_VAR 0 5
7077: PUSH
7078: LD_VAR 0 5
7082: PUSH
7083: LD_VAR 0 2
7087: MINUS
7088: ARRAY
7089: PPUSH
7090: CALL_OW 52
// end ;
7094: GO 7023
7096: POP
7097: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
7098: LD_INT 324
7100: PPUSH
7101: LD_INT 3
7103: PPUSH
7104: LD_STRING 
7106: PPUSH
7107: LD_INT 8
7109: PUSH
7110: LD_INT 9
7112: PUSH
7113: LD_INT 10
7115: PUSH
7116: EMPTY
7117: LIST
7118: LIST
7119: LIST
7120: PUSH
7121: LD_OWVAR 67
7125: ARRAY
7126: PPUSH
7127: LD_INT 3000
7129: PUSH
7130: LD_INT 500
7132: PUSH
7133: LD_INT 150
7135: PUSH
7136: EMPTY
7137: LIST
7138: LIST
7139: LIST
7140: PPUSH
7141: LD_INT 16
7143: PUSH
7144: LD_INT 6
7146: PUSH
7147: LD_INT 6
7149: PUSH
7150: LD_INT 8
7152: PUSH
7153: EMPTY
7154: LIST
7155: LIST
7156: LIST
7157: LIST
7158: PPUSH
7159: CALL 61254 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
7163: LD_ADDR_EXP 87
7167: PUSH
7168: LD_EXP 87
7172: PPUSH
7173: LD_INT 3
7175: PPUSH
7176: LD_INT 22
7178: PUSH
7179: LD_VAR 0 3
7183: PUSH
7184: EMPTY
7185: LIST
7186: LIST
7187: PUSH
7188: LD_INT 23
7190: PUSH
7191: LD_INT 2
7193: PUSH
7194: EMPTY
7195: LIST
7196: LIST
7197: PUSH
7198: LD_INT 3
7200: PUSH
7201: LD_INT 21
7203: PUSH
7204: LD_INT 2
7206: PUSH
7207: EMPTY
7208: LIST
7209: LIST
7210: PUSH
7211: EMPTY
7212: LIST
7213: LIST
7214: PUSH
7215: EMPTY
7216: LIST
7217: LIST
7218: LIST
7219: PPUSH
7220: CALL_OW 69
7224: PUSH
7225: LD_EXP 54
7229: DIFF
7230: PPUSH
7231: CALL_OW 1
7235: ST_TO_ADDR
// end ;
7236: LD_VAR 0 1
7240: RET
// export function BuildKozlovBomb ; begin
7241: LD_INT 0
7243: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7244: LD_INT 332
7246: PPUSH
7247: CALL_OW 302
7251: NOT
7252: PUSH
7253: LD_INT 336
7255: PPUSH
7256: CALL_OW 302
7260: NOT
7261: OR
7262: IFFALSE 7266
// exit ;
7264: GO 7363
// ComChangeProfession ( Kozlov , 4 ) ;
7266: LD_EXP 55
7270: PPUSH
7271: LD_INT 4
7273: PPUSH
7274: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7278: LD_INT 336
7280: PPUSH
7281: LD_INT 25
7283: PPUSH
7284: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7288: LD_INT 35
7290: PPUSH
7291: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7295: LD_INT 25
7297: PPUSH
7298: LD_INT 8
7300: PPUSH
7301: CALL_OW 321
7305: PUSH
7306: LD_INT 2
7308: EQUAL
7309: IFFALSE 7288
// ComExitBuilding ( Kozlov ) ;
7311: LD_EXP 55
7315: PPUSH
7316: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
7320: LD_EXP 55
7324: PPUSH
7325: LD_INT 332
7327: PPUSH
7328: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
7332: LD_EXP 55
7336: PPUSH
7337: LD_INT 3
7339: PPUSH
7340: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
7344: LD_INT 332
7346: PPUSH
7347: LD_INT 23
7349: PPUSH
7350: LD_INT 3
7352: PPUSH
7353: LD_INT 1
7355: PPUSH
7356: LD_INT 48
7358: PPUSH
7359: CALL_OW 125
// end ;
7363: LD_VAR 0 1
7367: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
7368: LD_EXP 3
7372: NOT
7373: PUSH
7374: LD_INT 3
7376: PPUSH
7377: LD_INT 1
7379: PPUSH
7380: CALL 45684 0 2
7384: NOT
7385: AND
7386: IFFALSE 8226
7388: GO 7390
7390: DISABLE
7391: LD_INT 0
7393: PPUSH
7394: PPUSH
7395: PPUSH
// begin enable ;
7396: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
7397: LD_INT 22
7399: PUSH
7400: LD_INT 8
7402: PUSH
7403: EMPTY
7404: LIST
7405: LIST
7406: PUSH
7407: LD_INT 23
7409: PUSH
7410: LD_INT 2
7412: PUSH
7413: EMPTY
7414: LIST
7415: LIST
7416: PUSH
7417: LD_INT 30
7419: PUSH
7420: LD_INT 3
7422: PUSH
7423: EMPTY
7424: LIST
7425: LIST
7426: PUSH
7427: EMPTY
7428: LIST
7429: LIST
7430: LIST
7431: PPUSH
7432: CALL_OW 69
7436: NOT
7437: IFFALSE 7441
// exit ;
7439: GO 8226
// if Prob ( 40 ) then
7441: LD_INT 40
7443: PPUSH
7444: CALL_OW 13
7448: IFFALSE 7575
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7450: LD_INT 3
7452: PPUSH
7453: LD_INT 14
7455: PUSH
7456: LD_INT 1
7458: PUSH
7459: LD_INT 2
7461: PUSH
7462: LD_INT 28
7464: PUSH
7465: EMPTY
7466: LIST
7467: LIST
7468: LIST
7469: LIST
7470: PUSH
7471: LD_INT 14
7473: PUSH
7474: LD_INT 1
7476: PUSH
7477: LD_INT 2
7479: PUSH
7480: LD_INT 28
7482: PUSH
7483: EMPTY
7484: LIST
7485: LIST
7486: LIST
7487: LIST
7488: PUSH
7489: LD_INT 14
7491: PUSH
7492: LD_INT 1
7494: PUSH
7495: LD_INT 2
7497: PUSH
7498: LD_INT 28
7500: PUSH
7501: EMPTY
7502: LIST
7503: LIST
7504: LIST
7505: LIST
7506: PUSH
7507: LD_INT 14
7509: PUSH
7510: LD_INT 1
7512: PUSH
7513: LD_INT 2
7515: PUSH
7516: LD_INT 28
7518: PUSH
7519: EMPTY
7520: LIST
7521: LIST
7522: LIST
7523: LIST
7524: PUSH
7525: LD_INT 14
7527: PUSH
7528: LD_INT 1
7530: PUSH
7531: LD_INT 2
7533: PUSH
7534: LD_INT 28
7536: PUSH
7537: EMPTY
7538: LIST
7539: LIST
7540: LIST
7541: LIST
7542: PUSH
7543: LD_INT 14
7545: PUSH
7546: LD_INT 1
7548: PUSH
7549: LD_INT 2
7551: PUSH
7552: LD_INT 26
7554: PUSH
7555: EMPTY
7556: LIST
7557: LIST
7558: LIST
7559: LIST
7560: PUSH
7561: EMPTY
7562: LIST
7563: LIST
7564: LIST
7565: LIST
7566: LIST
7567: LIST
7568: PPUSH
7569: CALL 44266 0 2
// end else
7573: GO 7766
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7575: LD_INT 3
7577: PPUSH
7578: LD_INT 14
7580: PUSH
7581: LD_INT 1
7583: PUSH
7584: LD_INT 2
7586: PUSH
7587: LD_INT 27
7589: PUSH
7590: LD_INT 26
7592: PUSH
7593: LD_INT 26
7595: PUSH
7596: EMPTY
7597: LIST
7598: LIST
7599: LIST
7600: PUSH
7601: LD_OWVAR 67
7605: ARRAY
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: LIST
7611: LIST
7612: PUSH
7613: LD_INT 14
7615: PUSH
7616: LD_INT 1
7618: PUSH
7619: LD_INT 2
7621: PUSH
7622: LD_INT 27
7624: PUSH
7625: LD_INT 26
7627: PUSH
7628: LD_INT 26
7630: PUSH
7631: EMPTY
7632: LIST
7633: LIST
7634: LIST
7635: PUSH
7636: LD_OWVAR 67
7640: ARRAY
7641: PUSH
7642: EMPTY
7643: LIST
7644: LIST
7645: LIST
7646: LIST
7647: PUSH
7648: LD_INT 14
7650: PUSH
7651: LD_INT 1
7653: PUSH
7654: LD_INT 2
7656: PUSH
7657: LD_INT 26
7659: PUSH
7660: LD_INT 26
7662: PUSH
7663: LD_INT 29
7665: PUSH
7666: EMPTY
7667: LIST
7668: LIST
7669: LIST
7670: PUSH
7671: LD_OWVAR 67
7675: ARRAY
7676: PUSH
7677: EMPTY
7678: LIST
7679: LIST
7680: LIST
7681: LIST
7682: PUSH
7683: LD_INT 13
7685: PUSH
7686: LD_INT 1
7688: PUSH
7689: LD_INT 2
7691: PUSH
7692: LD_INT 26
7694: PUSH
7695: LD_INT 29
7697: PUSH
7698: LD_INT 29
7700: PUSH
7701: EMPTY
7702: LIST
7703: LIST
7704: LIST
7705: PUSH
7706: LD_OWVAR 67
7710: ARRAY
7711: PUSH
7712: EMPTY
7713: LIST
7714: LIST
7715: LIST
7716: LIST
7717: PUSH
7718: LD_INT 13
7720: PUSH
7721: LD_INT 1
7723: PUSH
7724: LD_INT 2
7726: PUSH
7727: LD_INT 29
7729: PUSH
7730: EMPTY
7731: LIST
7732: LIST
7733: LIST
7734: LIST
7735: PUSH
7736: LD_INT 14
7738: PUSH
7739: LD_INT 1
7741: PUSH
7742: LD_INT 2
7744: PUSH
7745: LD_INT 26
7747: PUSH
7748: EMPTY
7749: LIST
7750: LIST
7751: LIST
7752: LIST
7753: PUSH
7754: EMPTY
7755: LIST
7756: LIST
7757: LIST
7758: LIST
7759: LIST
7760: LIST
7761: PPUSH
7762: CALL 44266 0 2
// end ; repeat wait ( 0 0$1 ) ;
7766: LD_INT 35
7768: PPUSH
7769: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
7773: LD_INT 3
7775: PPUSH
7776: LD_INT 1
7778: PPUSH
7779: CALL 45684 0 2
7783: PUSH
7784: LD_INT 6
7786: GREATEREQUAL
7787: IFFALSE 7766
// wait ( 0 0$30 ) ;
7789: LD_INT 1050
7791: PPUSH
7792: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
7796: LD_ADDR_VAR 0 2
7800: PUSH
7801: LD_INT 3
7803: PPUSH
7804: LD_INT 1
7806: PPUSH
7807: CALL 45684 0 2
7811: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
7812: LD_ADDR_EXP 106
7816: PUSH
7817: LD_EXP 106
7821: PPUSH
7822: LD_INT 3
7824: PPUSH
7825: LD_EXP 106
7829: PUSH
7830: LD_INT 3
7832: ARRAY
7833: PUSH
7834: LD_VAR 0 2
7838: DIFF
7839: PPUSH
7840: CALL_OW 1
7844: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
7845: LD_ADDR_VAR 0 3
7849: PUSH
7850: LD_INT 0
7852: PPUSH
7853: LD_INT 2
7855: PPUSH
7856: CALL_OW 12
7860: ST_TO_ADDR
// if target then
7861: LD_VAR 0 3
7865: IFFALSE 7993
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7867: LD_ADDR_VAR 0 2
7871: PUSH
7872: LD_VAR 0 2
7876: PPUSH
7877: LD_INT 24
7879: PUSH
7880: LD_INT 250
7882: PUSH
7883: EMPTY
7884: LIST
7885: LIST
7886: PPUSH
7887: CALL_OW 72
7891: ST_TO_ADDR
// for i in tmp do
7892: LD_ADDR_VAR 0 1
7896: PUSH
7897: LD_VAR 0 2
7901: PUSH
7902: FOR_IN
7903: IFFALSE 7943
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
7905: LD_VAR 0 1
7909: PPUSH
7910: LD_INT 89
7912: PPUSH
7913: LD_INT 71
7915: PPUSH
7916: CALL_OW 297
7920: PUSH
7921: LD_INT 9
7923: GREATER
7924: IFFALSE 7941
// ComMoveXY ( i , 89 , 71 ) ;
7926: LD_VAR 0 1
7930: PPUSH
7931: LD_INT 89
7933: PPUSH
7934: LD_INT 71
7936: PPUSH
7937: CALL_OW 111
7941: GO 7902
7943: POP
7944: POP
// wait ( 0 0$1 ) ;
7945: LD_INT 35
7947: PPUSH
7948: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
7952: LD_VAR 0 2
7956: PPUSH
7957: LD_INT 92
7959: PUSH
7960: LD_INT 89
7962: PUSH
7963: LD_INT 71
7965: PUSH
7966: LD_INT 9
7968: PUSH
7969: EMPTY
7970: LIST
7971: LIST
7972: LIST
7973: LIST
7974: PPUSH
7975: CALL_OW 72
7979: PUSH
7980: LD_VAR 0 2
7984: PUSH
7985: LD_INT 1
7987: MINUS
7988: GREATEREQUAL
7989: IFFALSE 7867
// end else
7991: GO 8117
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7993: LD_ADDR_VAR 0 2
7997: PUSH
7998: LD_VAR 0 2
8002: PPUSH
8003: LD_INT 24
8005: PUSH
8006: LD_INT 250
8008: PUSH
8009: EMPTY
8010: LIST
8011: LIST
8012: PPUSH
8013: CALL_OW 72
8017: ST_TO_ADDR
// for i in tmp do
8018: LD_ADDR_VAR 0 1
8022: PUSH
8023: LD_VAR 0 2
8027: PUSH
8028: FOR_IN
8029: IFFALSE 8069
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
8031: LD_VAR 0 1
8035: PPUSH
8036: LD_INT 147
8038: PPUSH
8039: LD_INT 4
8041: PPUSH
8042: CALL_OW 297
8046: PUSH
8047: LD_INT 9
8049: GREATER
8050: IFFALSE 8067
// ComMoveXY ( i , 147 , 4 ) ;
8052: LD_VAR 0 1
8056: PPUSH
8057: LD_INT 147
8059: PPUSH
8060: LD_INT 4
8062: PPUSH
8063: CALL_OW 111
8067: GO 8028
8069: POP
8070: POP
// wait ( 0 0$1 ) ;
8071: LD_INT 35
8073: PPUSH
8074: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
8078: LD_VAR 0 2
8082: PPUSH
8083: LD_INT 92
8085: PUSH
8086: LD_INT 147
8088: PUSH
8089: LD_INT 4
8091: PUSH
8092: LD_INT 9
8094: PUSH
8095: EMPTY
8096: LIST
8097: LIST
8098: LIST
8099: LIST
8100: PPUSH
8101: CALL_OW 72
8105: PUSH
8106: LD_VAR 0 2
8110: PUSH
8111: LD_INT 1
8113: MINUS
8114: GREATEREQUAL
8115: IFFALSE 7993
// end ; repeat wait ( 0 0$1 ) ;
8117: LD_INT 35
8119: PPUSH
8120: CALL_OW 67
// for i in tmp do
8124: LD_ADDR_VAR 0 1
8128: PUSH
8129: LD_VAR 0 2
8133: PUSH
8134: FOR_IN
8135: IFFALSE 8217
// begin if GetLives ( i ) > 251 then
8137: LD_VAR 0 1
8141: PPUSH
8142: CALL_OW 256
8146: PUSH
8147: LD_INT 251
8149: GREATER
8150: IFFALSE 8188
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
8152: LD_VAR 0 1
8156: PPUSH
8157: LD_INT 81
8159: PUSH
8160: LD_INT 8
8162: PUSH
8163: EMPTY
8164: LIST
8165: LIST
8166: PPUSH
8167: CALL_OW 69
8171: PPUSH
8172: LD_VAR 0 1
8176: PPUSH
8177: CALL_OW 74
8181: PPUSH
8182: CALL_OW 115
8186: GO 8215
// if IsDead ( i ) then
8188: LD_VAR 0 1
8192: PPUSH
8193: CALL_OW 301
8197: IFFALSE 8215
// tmp := tmp diff i ;
8199: LD_ADDR_VAR 0 2
8203: PUSH
8204: LD_VAR 0 2
8208: PUSH
8209: LD_VAR 0 1
8213: DIFF
8214: ST_TO_ADDR
// end ;
8215: GO 8134
8217: POP
8218: POP
// until not tmp ;
8219: LD_VAR 0 2
8223: NOT
8224: IFFALSE 8117
// end ;
8226: PPOPN 3
8228: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8229: LD_EXP 55
8233: PPUSH
8234: CALL_OW 302
8238: PUSH
8239: LD_EXP 3
8243: NOT
8244: AND
8245: IFFALSE 8254
8247: GO 8249
8249: DISABLE
// BuildKozlovBomb ;
8250: CALL 7241 0 0
8254: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8255: LD_INT 22
8257: PUSH
8258: LD_INT 8
8260: PUSH
8261: EMPTY
8262: LIST
8263: LIST
8264: PUSH
8265: LD_INT 34
8267: PUSH
8268: LD_INT 48
8270: PUSH
8271: EMPTY
8272: LIST
8273: LIST
8274: PUSH
8275: EMPTY
8276: LIST
8277: LIST
8278: PPUSH
8279: CALL_OW 69
8283: IFFALSE 8331
8285: GO 8287
8287: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
8288: LD_INT 22
8290: PUSH
8291: LD_INT 8
8293: PUSH
8294: EMPTY
8295: LIST
8296: LIST
8297: PUSH
8298: LD_INT 34
8300: PUSH
8301: LD_INT 48
8303: PUSH
8304: EMPTY
8305: LIST
8306: LIST
8307: PUSH
8308: EMPTY
8309: LIST
8310: LIST
8311: PPUSH
8312: CALL_OW 69
8316: PUSH
8317: LD_INT 1
8319: ARRAY
8320: PPUSH
8321: LD_INT 173
8323: PPUSH
8324: LD_INT 96
8326: PPUSH
8327: CALL_OW 116
// end ; end_of_file
8331: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
8332: LD_INT 0
8334: PPUSH
8335: PPUSH
8336: PPUSH
8337: PPUSH
8338: PPUSH
8339: PPUSH
8340: PPUSH
8341: PPUSH
8342: PPUSH
// side := 3 ;
8343: LD_ADDR_VAR 0 6
8347: PUSH
8348: LD_INT 3
8350: ST_TO_ADDR
// InitHc ;
8351: CALL_OW 19
// uc_side := side ;
8355: LD_ADDR_OWVAR 20
8359: PUSH
8360: LD_VAR 0 6
8364: ST_TO_ADDR
// uc_nation := 3 ;
8365: LD_ADDR_OWVAR 21
8369: PUSH
8370: LD_INT 3
8372: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
8373: LD_ADDR_VAR 0 2
8377: PUSH
8378: LD_INT 22
8380: PUSH
8381: LD_VAR 0 6
8385: PUSH
8386: EMPTY
8387: LIST
8388: LIST
8389: PUSH
8390: LD_INT 21
8392: PUSH
8393: LD_INT 3
8395: PUSH
8396: EMPTY
8397: LIST
8398: LIST
8399: PUSH
8400: EMPTY
8401: LIST
8402: LIST
8403: PPUSH
8404: CALL_OW 69
8408: PUSH
8409: FOR_IN
8410: IFFALSE 8426
// SetBLevel ( i , 10 ) ;
8412: LD_VAR 0 2
8416: PPUSH
8417: LD_INT 10
8419: PPUSH
8420: CALL_OW 241
8424: GO 8409
8426: POP
8427: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
8428: LD_ADDR_VAR 0 9
8432: PUSH
8433: LD_INT 22
8435: PUSH
8436: LD_VAR 0 6
8440: PUSH
8441: EMPTY
8442: LIST
8443: LIST
8444: PUSH
8445: LD_INT 30
8447: PUSH
8448: LD_INT 34
8450: PUSH
8451: EMPTY
8452: LIST
8453: LIST
8454: PUSH
8455: EMPTY
8456: LIST
8457: LIST
8458: PPUSH
8459: CALL_OW 69
8463: ST_TO_ADDR
// if teleport then
8464: LD_VAR 0 9
8468: IFFALSE 8489
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
8470: LD_VAR 0 9
8474: PUSH
8475: LD_INT 1
8477: ARRAY
8478: PPUSH
8479: LD_INT 123
8481: PPUSH
8482: LD_INT 122
8484: PPUSH
8485: CALL_OW 243
// hc_importance := 0 ;
8489: LD_ADDR_OWVAR 32
8493: PUSH
8494: LD_INT 0
8496: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
8497: LD_ADDR_EXP 56
8501: PUSH
8502: LD_STRING Platonov
8504: PPUSH
8505: CALL_OW 25
8509: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
8510: LD_ADDR_EXP 57
8514: PUSH
8515: LD_STRING Yakotich
8517: PPUSH
8518: CALL_OW 25
8522: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
8523: LD_ADDR_EXP 58
8527: PUSH
8528: LD_STRING Gleb
8530: PPUSH
8531: CALL_OW 25
8535: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
8536: LD_STRING 03_Cornel
8538: PPUSH
8539: CALL_OW 28
8543: IFFALSE 8591
// begin Bierezov := NewCharacter ( Mikhail ) ;
8545: LD_ADDR_EXP 59
8549: PUSH
8550: LD_STRING Mikhail
8552: PPUSH
8553: CALL_OW 25
8557: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
8558: LD_EXP 59
8562: PPUSH
8563: LD_INT 197
8565: PPUSH
8566: LD_INT 111
8568: PPUSH
8569: LD_INT 9
8571: PPUSH
8572: LD_INT 0
8574: PPUSH
8575: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
8579: LD_EXP 59
8583: PPUSH
8584: LD_INT 3
8586: PPUSH
8587: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
8591: LD_EXP 56
8595: PPUSH
8596: LD_INT 126
8598: PPUSH
8599: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
8603: LD_EXP 57
8607: PPUSH
8608: LD_INT 197
8610: PPUSH
8611: LD_INT 111
8613: PPUSH
8614: LD_INT 9
8616: PPUSH
8617: LD_INT 0
8619: PPUSH
8620: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
8624: LD_EXP 58
8628: PPUSH
8629: LD_INT 197
8631: PPUSH
8632: LD_INT 111
8634: PPUSH
8635: LD_INT 9
8637: PPUSH
8638: LD_INT 0
8640: PPUSH
8641: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 9000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
8645: LD_ADDR_VAR 0 5
8649: PUSH
8650: LD_INT 126
8652: PPUSH
8653: LD_INT 2
8655: PPUSH
8656: LD_STRING zhukov
8658: PPUSH
8659: LD_INT 9
8661: PUSH
8662: LD_INT 10
8664: PUSH
8665: LD_INT 10
8667: PUSH
8668: EMPTY
8669: LIST
8670: LIST
8671: LIST
8672: PUSH
8673: LD_OWVAR 67
8677: ARRAY
8678: PPUSH
8679: LD_INT 9000
8681: PUSH
8682: LD_INT 1000
8684: PUSH
8685: LD_INT 300
8687: PUSH
8688: EMPTY
8689: LIST
8690: LIST
8691: LIST
8692: PPUSH
8693: LD_INT 21
8695: PUSH
8696: LD_INT 8
8698: PUSH
8699: LD_INT 13
8701: PUSH
8702: LD_INT 8
8704: PUSH
8705: EMPTY
8706: LIST
8707: LIST
8708: LIST
8709: LIST
8710: PPUSH
8711: CALL 61254 0 6
8715: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
8716: LD_ADDR_VAR 0 4
8720: PUSH
8721: LD_INT 267
8723: PPUSH
8724: CALL_OW 274
8728: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
8729: LD_VAR 0 4
8733: PPUSH
8734: LD_INT 1
8736: PPUSH
8737: LD_INT 5000
8739: PPUSH
8740: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8744: LD_VAR 0 4
8748: PPUSH
8749: LD_INT 2
8751: PPUSH
8752: LD_INT 200
8754: PPUSH
8755: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8759: LD_VAR 0 4
8763: PPUSH
8764: LD_INT 3
8766: PPUSH
8767: LD_INT 200
8769: PPUSH
8770: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
8774: LD_ADDR_EXP 87
8778: PUSH
8779: LD_EXP 87
8783: PPUSH
8784: LD_INT 2
8786: PPUSH
8787: LD_VAR 0 5
8791: PUSH
8792: LD_INT 22
8794: PUSH
8795: LD_VAR 0 6
8799: PUSH
8800: EMPTY
8801: LIST
8802: LIST
8803: PUSH
8804: LD_INT 3
8806: PUSH
8807: LD_INT 21
8809: PUSH
8810: LD_INT 2
8812: PUSH
8813: EMPTY
8814: LIST
8815: LIST
8816: PUSH
8817: EMPTY
8818: LIST
8819: LIST
8820: PUSH
8821: EMPTY
8822: LIST
8823: LIST
8824: PPUSH
8825: CALL_OW 69
8829: UNION
8830: PUSH
8831: LD_EXP 56
8835: DIFF
8836: PPUSH
8837: CALL_OW 1
8841: ST_TO_ADDR
// behemoths := [ ] ;
8842: LD_ADDR_EXP 60
8846: PUSH
8847: EMPTY
8848: ST_TO_ADDR
// behemothBuilders := [ ] ;
8849: LD_ADDR_EXP 61
8853: PUSH
8854: EMPTY
8855: ST_TO_ADDR
// j := 3 ;
8856: LD_ADDR_VAR 0 3
8860: PUSH
8861: LD_INT 3
8863: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
8864: LD_ADDR_VAR 0 2
8868: PUSH
8869: LD_INT 22
8871: PUSH
8872: LD_INT 3
8874: PUSH
8875: EMPTY
8876: LIST
8877: LIST
8878: PUSH
8879: LD_INT 25
8881: PUSH
8882: LD_INT 3
8884: PUSH
8885: EMPTY
8886: LIST
8887: LIST
8888: PUSH
8889: EMPTY
8890: LIST
8891: LIST
8892: PPUSH
8893: CALL_OW 69
8897: PUSH
8898: FOR_IN
8899: IFFALSE 8949
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8901: LD_ADDR_EXP 61
8905: PUSH
8906: LD_EXP 61
8910: PPUSH
8911: LD_VAR 0 2
8915: PPUSH
8916: CALL 93600 0 2
8920: ST_TO_ADDR
// j := j - 1 ;
8921: LD_ADDR_VAR 0 3
8925: PUSH
8926: LD_VAR 0 3
8930: PUSH
8931: LD_INT 1
8933: MINUS
8934: ST_TO_ADDR
// if j = 0 then
8935: LD_VAR 0 3
8939: PUSH
8940: LD_INT 0
8942: EQUAL
8943: IFFALSE 8947
// break ;
8945: GO 8949
// end ;
8947: GO 8898
8949: POP
8950: POP
// end ;
8951: LD_VAR 0 1
8955: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
8956: LD_INT 0
8958: PPUSH
8959: PPUSH
8960: PPUSH
8961: PPUSH
8962: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
8963: LD_ADDR_VAR 0 4
8967: PUSH
8968: LD_INT 209
8970: PUSH
8971: LD_INT 149
8973: PUSH
8974: EMPTY
8975: LIST
8976: LIST
8977: PUSH
8978: LD_INT 219
8980: PUSH
8981: LD_INT 154
8983: PUSH
8984: EMPTY
8985: LIST
8986: LIST
8987: PUSH
8988: LD_INT 223
8990: PUSH
8991: LD_INT 149
8993: PUSH
8994: EMPTY
8995: LIST
8996: LIST
8997: PUSH
8998: LD_INT 232
9000: PUSH
9001: LD_INT 155
9003: PUSH
9004: EMPTY
9005: LIST
9006: LIST
9007: PUSH
9008: EMPTY
9009: LIST
9010: LIST
9011: LIST
9012: LIST
9013: ST_TO_ADDR
// if not behemothBuilders then
9014: LD_EXP 61
9018: NOT
9019: IFFALSE 9023
// exit ;
9021: GO 9127
// j := 1 ;
9023: LD_ADDR_VAR 0 3
9027: PUSH
9028: LD_INT 1
9030: ST_TO_ADDR
// for i in behemothBuilders do
9031: LD_ADDR_VAR 0 2
9035: PUSH
9036: LD_EXP 61
9040: PUSH
9041: FOR_IN
9042: IFFALSE 9125
// begin if IsInUnit ( i ) then
9044: LD_VAR 0 2
9048: PPUSH
9049: CALL_OW 310
9053: IFFALSE 9064
// ComExitBuilding ( i ) ;
9055: LD_VAR 0 2
9059: PPUSH
9060: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
9064: LD_VAR 0 2
9068: PPUSH
9069: LD_INT 37
9071: PPUSH
9072: LD_VAR 0 4
9076: PUSH
9077: LD_VAR 0 3
9081: ARRAY
9082: PUSH
9083: LD_INT 1
9085: ARRAY
9086: PPUSH
9087: LD_VAR 0 4
9091: PUSH
9092: LD_VAR 0 3
9096: ARRAY
9097: PUSH
9098: LD_INT 2
9100: ARRAY
9101: PPUSH
9102: LD_INT 0
9104: PPUSH
9105: CALL_OW 230
// j := j + 1 ;
9109: LD_ADDR_VAR 0 3
9113: PUSH
9114: LD_VAR 0 3
9118: PUSH
9119: LD_INT 1
9121: PLUS
9122: ST_TO_ADDR
// end ;
9123: GO 9041
9125: POP
9126: POP
// end ;
9127: LD_VAR 0 1
9131: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
9132: LD_INT 3
9134: PPUSH
9135: CALL 93648 0 1
9139: PUSH
9140: LD_INT 22
9142: PUSH
9143: LD_INT 3
9145: PUSH
9146: EMPTY
9147: LIST
9148: LIST
9149: PUSH
9150: LD_INT 30
9152: PUSH
9153: LD_INT 37
9155: PUSH
9156: EMPTY
9157: LIST
9158: LIST
9159: PUSH
9160: EMPTY
9161: LIST
9162: LIST
9163: PPUSH
9164: CALL_OW 69
9168: NOT
9169: AND
9170: IFFALSE 9356
9172: GO 9174
9174: DISABLE
9175: LD_INT 0
9177: PPUSH
9178: PPUSH
// begin enable ;
9179: ENABLE
// tmp := GetBehemoths ( 3 ) ;
9180: LD_ADDR_VAR 0 2
9184: PUSH
9185: LD_INT 3
9187: PPUSH
9188: CALL 93648 0 1
9192: ST_TO_ADDR
// for i in tmp do
9193: LD_ADDR_VAR 0 1
9197: PUSH
9198: LD_VAR 0 2
9202: PUSH
9203: FOR_IN
9204: IFFALSE 9354
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
9206: LD_VAR 0 1
9210: PPUSH
9211: LD_INT 7
9213: PPUSH
9214: CALL_OW 308
9218: PUSH
9219: LD_VAR 0 1
9223: PPUSH
9224: CALL_OW 110
9228: PUSH
9229: LD_INT 2
9231: EQUAL
9232: NOT
9233: AND
9234: IFFALSE 9248
// SetTag ( i , 2 ) ;
9236: LD_VAR 0 1
9240: PPUSH
9241: LD_INT 2
9243: PPUSH
9244: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
9248: LD_INT 81
9250: PUSH
9251: LD_INT 3
9253: PUSH
9254: EMPTY
9255: LIST
9256: LIST
9257: PUSH
9258: LD_INT 91
9260: PUSH
9261: LD_VAR 0 1
9265: PUSH
9266: LD_INT 12
9268: PUSH
9269: EMPTY
9270: LIST
9271: LIST
9272: LIST
9273: PUSH
9274: EMPTY
9275: LIST
9276: LIST
9277: PPUSH
9278: CALL_OW 69
9282: NOT
9283: PUSH
9284: LD_VAR 0 1
9288: PPUSH
9289: CALL_OW 110
9293: PUSH
9294: LD_INT 2
9296: EQUAL
9297: NOT
9298: AND
9299: IFFALSE 9318
// ComAgressiveMove ( i , 64 , 93 ) else
9301: LD_VAR 0 1
9305: PPUSH
9306: LD_INT 64
9308: PPUSH
9309: LD_INT 93
9311: PPUSH
9312: CALL_OW 114
9316: GO 9352
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9318: LD_VAR 0 1
9322: PPUSH
9323: LD_INT 81
9325: PUSH
9326: LD_INT 3
9328: PUSH
9329: EMPTY
9330: LIST
9331: LIST
9332: PPUSH
9333: CALL_OW 69
9337: PPUSH
9338: LD_VAR 0 1
9342: PPUSH
9343: CALL_OW 74
9347: PPUSH
9348: CALL_OW 115
// end ;
9352: GO 9203
9354: POP
9355: POP
// end ;
9356: PPOPN 2
9358: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9359: LD_EXP 2
9363: NOT
9364: PUSH
9365: LD_INT 2
9367: PPUSH
9368: LD_INT 1
9370: PPUSH
9371: CALL 45684 0 2
9375: NOT
9376: AND
9377: IFFALSE 10297
9379: GO 9381
9381: DISABLE
9382: LD_INT 0
9384: PPUSH
9385: PPUSH
9386: PPUSH
9387: PPUSH
// begin enable ;
9388: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9389: LD_INT 22
9391: PUSH
9392: LD_INT 3
9394: PUSH
9395: EMPTY
9396: LIST
9397: LIST
9398: PUSH
9399: LD_INT 30
9401: PUSH
9402: LD_INT 3
9404: PUSH
9405: EMPTY
9406: LIST
9407: LIST
9408: PUSH
9409: EMPTY
9410: LIST
9411: LIST
9412: PPUSH
9413: CALL_OW 69
9417: NOT
9418: IFFALSE 9422
// exit ;
9420: GO 10297
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9422: LD_ADDR_VAR 0 4
9426: PUSH
9427: LD_INT 22
9429: PUSH
9430: LD_INT 3
9432: PUSH
9433: EMPTY
9434: LIST
9435: LIST
9436: PUSH
9437: LD_INT 30
9439: PUSH
9440: LD_INT 34
9442: PUSH
9443: EMPTY
9444: LIST
9445: LIST
9446: PUSH
9447: EMPTY
9448: LIST
9449: LIST
9450: PPUSH
9451: CALL_OW 69
9455: ST_TO_ADDR
// if Prob ( 40 ) then
9456: LD_INT 40
9458: PPUSH
9459: CALL_OW 13
9463: IFFALSE 9590
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9465: LD_INT 2
9467: PPUSH
9468: LD_INT 22
9470: PUSH
9471: LD_INT 3
9473: PUSH
9474: LD_INT 3
9476: PUSH
9477: LD_INT 49
9479: PUSH
9480: EMPTY
9481: LIST
9482: LIST
9483: LIST
9484: LIST
9485: PUSH
9486: LD_INT 22
9488: PUSH
9489: LD_INT 3
9491: PUSH
9492: LD_INT 3
9494: PUSH
9495: LD_INT 49
9497: PUSH
9498: EMPTY
9499: LIST
9500: LIST
9501: LIST
9502: LIST
9503: PUSH
9504: LD_INT 22
9506: PUSH
9507: LD_INT 3
9509: PUSH
9510: LD_INT 3
9512: PUSH
9513: LD_INT 49
9515: PUSH
9516: EMPTY
9517: LIST
9518: LIST
9519: LIST
9520: LIST
9521: PUSH
9522: LD_INT 24
9524: PUSH
9525: LD_INT 3
9527: PUSH
9528: LD_INT 3
9530: PUSH
9531: LD_INT 46
9533: PUSH
9534: EMPTY
9535: LIST
9536: LIST
9537: LIST
9538: LIST
9539: PUSH
9540: LD_INT 24
9542: PUSH
9543: LD_INT 3
9545: PUSH
9546: LD_INT 3
9548: PUSH
9549: LD_INT 46
9551: PUSH
9552: EMPTY
9553: LIST
9554: LIST
9555: LIST
9556: LIST
9557: PUSH
9558: LD_INT 24
9560: PUSH
9561: LD_INT 3
9563: PUSH
9564: LD_INT 3
9566: PUSH
9567: LD_INT 46
9569: PUSH
9570: EMPTY
9571: LIST
9572: LIST
9573: LIST
9574: LIST
9575: PUSH
9576: EMPTY
9577: LIST
9578: LIST
9579: LIST
9580: LIST
9581: LIST
9582: LIST
9583: PPUSH
9584: CALL 44266 0 2
// end else
9588: GO 9713
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9590: LD_INT 2
9592: PPUSH
9593: LD_INT 24
9595: PUSH
9596: LD_INT 3
9598: PUSH
9599: LD_INT 3
9601: PUSH
9602: LD_INT 47
9604: PUSH
9605: EMPTY
9606: LIST
9607: LIST
9608: LIST
9609: LIST
9610: PUSH
9611: LD_INT 24
9613: PUSH
9614: LD_INT 3
9616: PUSH
9617: LD_INT 3
9619: PUSH
9620: LD_INT 47
9622: PUSH
9623: EMPTY
9624: LIST
9625: LIST
9626: LIST
9627: LIST
9628: PUSH
9629: LD_INT 24
9631: PUSH
9632: LD_INT 3
9634: PUSH
9635: LD_INT 3
9637: PUSH
9638: LD_INT 47
9640: PUSH
9641: EMPTY
9642: LIST
9643: LIST
9644: LIST
9645: LIST
9646: PUSH
9647: LD_INT 24
9649: PUSH
9650: LD_INT 3
9652: PUSH
9653: LD_INT 3
9655: PUSH
9656: LD_INT 46
9658: PUSH
9659: EMPTY
9660: LIST
9661: LIST
9662: LIST
9663: LIST
9664: PUSH
9665: LD_INT 24
9667: PUSH
9668: LD_INT 3
9670: PUSH
9671: LD_INT 3
9673: PUSH
9674: LD_INT 46
9676: PUSH
9677: EMPTY
9678: LIST
9679: LIST
9680: LIST
9681: LIST
9682: PUSH
9683: LD_INT 24
9685: PUSH
9686: LD_INT 3
9688: PUSH
9689: LD_INT 3
9691: PUSH
9692: LD_INT 46
9694: PUSH
9695: EMPTY
9696: LIST
9697: LIST
9698: LIST
9699: LIST
9700: PUSH
9701: EMPTY
9702: LIST
9703: LIST
9704: LIST
9705: LIST
9706: LIST
9707: LIST
9708: PPUSH
9709: CALL 44266 0 2
// end ; if Difficulty > 1 then
9713: LD_OWVAR 67
9717: PUSH
9718: LD_INT 1
9720: GREATER
9721: IFFALSE 9751
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
9723: LD_INT 2
9725: PPUSH
9726: LD_INT 24
9728: PUSH
9729: LD_INT 3
9731: PUSH
9732: LD_INT 3
9734: PUSH
9735: LD_INT 47
9737: PUSH
9738: EMPTY
9739: LIST
9740: LIST
9741: LIST
9742: LIST
9743: PUSH
9744: EMPTY
9745: LIST
9746: PPUSH
9747: CALL 44266 0 2
// repeat wait ( 0 0$1 ) ;
9751: LD_INT 35
9753: PPUSH
9754: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
9758: LD_INT 2
9760: PPUSH
9761: LD_INT 1
9763: PPUSH
9764: CALL 45684 0 2
9768: PUSH
9769: LD_INT 6
9771: PUSH
9772: LD_INT 7
9774: PUSH
9775: LD_INT 7
9777: PUSH
9778: EMPTY
9779: LIST
9780: LIST
9781: LIST
9782: PUSH
9783: LD_OWVAR 67
9787: ARRAY
9788: GREATEREQUAL
9789: IFFALSE 9751
// wait ( 0 0$30 ) ;
9791: LD_INT 1050
9793: PPUSH
9794: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
9798: LD_ADDR_VAR 0 2
9802: PUSH
9803: LD_INT 2
9805: PPUSH
9806: LD_INT 1
9808: PPUSH
9809: CALL 45684 0 2
9813: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
9814: LD_ADDR_EXP 106
9818: PUSH
9819: LD_EXP 106
9823: PPUSH
9824: LD_INT 2
9826: PPUSH
9827: LD_EXP 106
9831: PUSH
9832: LD_INT 2
9834: ARRAY
9835: PUSH
9836: LD_VAR 0 2
9840: DIFF
9841: PPUSH
9842: CALL_OW 1
9846: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
9847: LD_ADDR_VAR 0 3
9851: PUSH
9852: LD_INT 0
9854: PPUSH
9855: LD_INT 1
9857: PPUSH
9858: CALL_OW 12
9862: ST_TO_ADDR
// if target then
9863: LD_VAR 0 3
9867: IFFALSE 9995
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9869: LD_ADDR_VAR 0 2
9873: PUSH
9874: LD_VAR 0 2
9878: PPUSH
9879: LD_INT 24
9881: PUSH
9882: LD_INT 250
9884: PUSH
9885: EMPTY
9886: LIST
9887: LIST
9888: PPUSH
9889: CALL_OW 72
9893: ST_TO_ADDR
// for i in tmp do
9894: LD_ADDR_VAR 0 1
9898: PUSH
9899: LD_VAR 0 2
9903: PUSH
9904: FOR_IN
9905: IFFALSE 9945
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
9907: LD_VAR 0 1
9911: PPUSH
9912: LD_INT 139
9914: PPUSH
9915: LD_INT 89
9917: PPUSH
9918: CALL_OW 297
9922: PUSH
9923: LD_INT 9
9925: GREATER
9926: IFFALSE 9943
// ComMoveXY ( i , 139 , 89 ) ;
9928: LD_VAR 0 1
9932: PPUSH
9933: LD_INT 139
9935: PPUSH
9936: LD_INT 89
9938: PPUSH
9939: CALL_OW 111
9943: GO 9904
9945: POP
9946: POP
// wait ( 0 0$1 ) ;
9947: LD_INT 35
9949: PPUSH
9950: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
9954: LD_VAR 0 2
9958: PPUSH
9959: LD_INT 92
9961: PUSH
9962: LD_INT 139
9964: PUSH
9965: LD_INT 89
9967: PUSH
9968: LD_INT 9
9970: PUSH
9971: EMPTY
9972: LIST
9973: LIST
9974: LIST
9975: LIST
9976: PPUSH
9977: CALL_OW 72
9981: PUSH
9982: LD_VAR 0 2
9986: PUSH
9987: LD_INT 1
9989: MINUS
9990: GREATEREQUAL
9991: IFFALSE 9869
// end else
9993: GO 10137
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
9995: LD_VAR 0 2
9999: PPUSH
10000: LD_VAR 0 4
10004: PUSH
10005: LD_INT 1
10007: ARRAY
10008: PPUSH
10009: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10013: LD_ADDR_VAR 0 2
10017: PUSH
10018: LD_VAR 0 2
10022: PPUSH
10023: LD_INT 24
10025: PUSH
10026: LD_INT 250
10028: PUSH
10029: EMPTY
10030: LIST
10031: LIST
10032: PPUSH
10033: CALL_OW 72
10037: ST_TO_ADDR
// for i in tmp do
10038: LD_ADDR_VAR 0 1
10042: PUSH
10043: LD_VAR 0 2
10047: PUSH
10048: FOR_IN
10049: IFFALSE 10089
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10051: LD_VAR 0 1
10055: PPUSH
10056: LD_INT 124
10058: PPUSH
10059: LD_INT 139
10061: PPUSH
10062: CALL_OW 297
10066: PUSH
10067: LD_INT 9
10069: GREATER
10070: IFFALSE 10087
// ComMoveXY ( i , 124 , 139 ) ;
10072: LD_VAR 0 1
10076: PPUSH
10077: LD_INT 124
10079: PPUSH
10080: LD_INT 139
10082: PPUSH
10083: CALL_OW 111
10087: GO 10048
10089: POP
10090: POP
// wait ( 0 0$1 ) ;
10091: LD_INT 35
10093: PPUSH
10094: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10098: LD_VAR 0 2
10102: PPUSH
10103: LD_INT 92
10105: PUSH
10106: LD_INT 124
10108: PUSH
10109: LD_INT 139
10111: PUSH
10112: LD_INT 9
10114: PUSH
10115: EMPTY
10116: LIST
10117: LIST
10118: LIST
10119: LIST
10120: PPUSH
10121: CALL_OW 72
10125: PUSH
10126: LD_VAR 0 2
10130: PUSH
10131: LD_INT 1
10133: MINUS
10134: GREATEREQUAL
10135: IFFALSE 10013
// end ; repeat wait ( 0 0$1 ) ;
10137: LD_INT 35
10139: PPUSH
10140: CALL_OW 67
// for i in tmp do
10144: LD_ADDR_VAR 0 1
10148: PUSH
10149: LD_VAR 0 2
10153: PUSH
10154: FOR_IN
10155: IFFALSE 10288
// begin if GetLives ( i ) > 251 then
10157: LD_VAR 0 1
10161: PPUSH
10162: CALL_OW 256
10166: PUSH
10167: LD_INT 251
10169: GREATER
10170: IFFALSE 10259
// begin if GetWeapon ( i ) = ru_time_lapser then
10172: LD_VAR 0 1
10176: PPUSH
10177: CALL_OW 264
10181: PUSH
10182: LD_INT 49
10184: EQUAL
10185: IFFALSE 10223
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
10187: LD_VAR 0 1
10191: PPUSH
10192: LD_INT 81
10194: PUSH
10195: LD_INT 3
10197: PUSH
10198: EMPTY
10199: LIST
10200: LIST
10201: PPUSH
10202: CALL_OW 69
10206: PPUSH
10207: LD_VAR 0 1
10211: PPUSH
10212: CALL_OW 74
10216: PPUSH
10217: CALL_OW 112
10221: GO 10257
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10223: LD_VAR 0 1
10227: PPUSH
10228: LD_INT 81
10230: PUSH
10231: LD_INT 3
10233: PUSH
10234: EMPTY
10235: LIST
10236: LIST
10237: PPUSH
10238: CALL_OW 69
10242: PPUSH
10243: LD_VAR 0 1
10247: PPUSH
10248: CALL_OW 74
10252: PPUSH
10253: CALL_OW 115
// end else
10257: GO 10286
// if IsDead ( i ) then
10259: LD_VAR 0 1
10263: PPUSH
10264: CALL_OW 301
10268: IFFALSE 10286
// tmp := tmp diff i ;
10270: LD_ADDR_VAR 0 2
10274: PUSH
10275: LD_VAR 0 2
10279: PUSH
10280: LD_VAR 0 1
10284: DIFF
10285: ST_TO_ADDR
// end ;
10286: GO 10154
10288: POP
10289: POP
// until not tmp ;
10290: LD_VAR 0 2
10294: NOT
10295: IFFALSE 10137
// end ;
10297: PPOPN 4
10299: END
// every 30 30$00 trigger not russianDestroyed do
10300: LD_EXP 2
10304: NOT
10305: IFFALSE 10370
10307: GO 10309
10309: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 ] [ Difficulty ] ) ;
10310: LD_INT 105000
10312: PUSH
10313: LD_INT 84000
10315: PUSH
10316: LD_INT 63000
10318: PUSH
10319: EMPTY
10320: LIST
10321: LIST
10322: LIST
10323: PUSH
10324: LD_OWVAR 67
10328: ARRAY
10329: PPUSH
10330: CALL_OW 67
// if russianDestroyed then
10334: LD_EXP 2
10338: IFFALSE 10342
// exit ;
10340: GO 10370
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
10342: LD_INT 2
10344: PPUSH
10345: LD_INT 23
10347: PUSH
10348: LD_INT 3
10350: PUSH
10351: LD_INT 1
10353: PUSH
10354: LD_INT 48
10356: PUSH
10357: EMPTY
10358: LIST
10359: LIST
10360: LIST
10361: LIST
10362: PUSH
10363: EMPTY
10364: LIST
10365: PPUSH
10366: CALL 44266 0 2
// end ; end_of_file
10370: END
// export function CustomEvent ( event ) ; begin
10371: LD_INT 0
10373: PPUSH
// end ;
10374: LD_VAR 0 2
10378: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10379: LD_VAR 0 2
10383: PPUSH
10384: LD_VAR 0 3
10388: PPUSH
10389: LD_INT 15
10391: PPUSH
10392: CALL_OW 309
10396: IFFALSE 10405
// YouLost ( MothContaminate ) ;
10398: LD_STRING MothContaminate
10400: PPUSH
10401: CALL_OW 104
// end ;
10405: PPOPN 3
10407: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10408: LD_VAR 0 2
10412: PPUSH
10413: LD_VAR 0 3
10417: PPUSH
10418: LD_INT 15
10420: PPUSH
10421: CALL_OW 309
10425: IFFALSE 10441
// begin wait ( 0 0$6 ) ;
10427: LD_INT 210
10429: PPUSH
10430: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
10434: LD_STRING MothContaminateBomb
10436: PPUSH
10437: CALL_OW 104
// end ; end ;
10441: PPOPN 3
10443: END
// on UnitDestroyed ( un ) do begin if un = JMM then
10444: LD_VAR 0 1
10448: PUSH
10449: LD_EXP 17
10453: EQUAL
10454: IFFALSE 10465
// begin YouLost ( JMM ) ;
10456: LD_STRING JMM
10458: PPUSH
10459: CALL_OW 104
// exit ;
10463: GO 10564
// end ; if un = Powell then
10465: LD_VAR 0 1
10469: PUSH
10470: LD_EXP 52
10474: EQUAL
10475: IFFALSE 10485
// americanDestroyed := true ;
10477: LD_ADDR_EXP 4
10481: PUSH
10482: LD_INT 1
10484: ST_TO_ADDR
// if un = Platonov then
10485: LD_VAR 0 1
10489: PUSH
10490: LD_EXP 56
10494: EQUAL
10495: IFFALSE 10505
// russianDestroyed := true ;
10497: LD_ADDR_EXP 2
10501: PUSH
10502: LD_INT 1
10504: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
10505: LD_VAR 0 1
10509: PUSH
10510: LD_INT 22
10512: PUSH
10513: LD_INT 7
10515: PUSH
10516: EMPTY
10517: LIST
10518: LIST
10519: PUSH
10520: LD_INT 21
10522: PUSH
10523: LD_INT 2
10525: PUSH
10526: EMPTY
10527: LIST
10528: LIST
10529: PUSH
10530: EMPTY
10531: LIST
10532: LIST
10533: PPUSH
10534: CALL_OW 69
10538: IN
10539: IFFALSE 10555
// vehicleLostCounter := vehicleLostCounter + 1 ;
10541: LD_ADDR_EXP 15
10545: PUSH
10546: LD_EXP 15
10550: PUSH
10551: LD_INT 1
10553: PLUS
10554: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
10555: LD_VAR 0 1
10559: PPUSH
10560: CALL 47658 0 1
// end ;
10564: PPOPN 1
10566: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10567: LD_VAR 0 1
10571: PPUSH
10572: LD_VAR 0 2
10576: PPUSH
10577: CALL 49992 0 2
// end ;
10581: PPOPN 2
10583: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10584: LD_VAR 0 1
10588: PPUSH
10589: CALL 49060 0 1
// end ;
10593: PPOPN 1
10595: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
10596: LD_VAR 0 1
10600: PUSH
10601: LD_INT 22
10603: PUSH
10604: LD_INT 8
10606: PUSH
10607: EMPTY
10608: LIST
10609: LIST
10610: PUSH
10611: LD_INT 30
10613: PUSH
10614: LD_INT 2
10616: PUSH
10617: EMPTY
10618: LIST
10619: LIST
10620: PUSH
10621: LD_INT 23
10623: PUSH
10624: LD_INT 3
10626: PUSH
10627: EMPTY
10628: LIST
10629: LIST
10630: PUSH
10631: EMPTY
10632: LIST
10633: LIST
10634: LIST
10635: PPUSH
10636: CALL_OW 69
10640: IN
10641: IFFALSE 10668
// begin ComUpgrade ( building ) ;
10643: LD_VAR 0 1
10647: PPUSH
10648: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
10652: LD_EXP 55
10656: PPUSH
10657: LD_VAR 0 1
10661: PPUSH
10662: CALL 60818 0 2
// exit ;
10666: GO 10677
// end ; MCE_BuildingComplete ( building ) ;
10668: LD_VAR 0 1
10672: PPUSH
10673: CALL 49301 0 1
// end ;
10677: PPOPN 1
10679: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10680: LD_VAR 0 1
10684: PPUSH
10685: LD_VAR 0 2
10689: PPUSH
10690: CALL 47354 0 2
// end ;
10694: PPOPN 2
10696: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10697: LD_VAR 0 1
10701: PPUSH
10702: LD_VAR 0 2
10706: PPUSH
10707: LD_VAR 0 3
10711: PPUSH
10712: LD_VAR 0 4
10716: PPUSH
10717: LD_VAR 0 5
10721: PPUSH
10722: CALL 46974 0 5
// end ;
10726: PPOPN 5
10728: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
10729: LD_VAR 0 1
10733: PPUSH
10734: LD_VAR 0 2
10738: PPUSH
10739: CALL 46570 0 2
// end ;
10743: PPOPN 2
10745: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10746: LD_VAR 0 1
10750: PPUSH
10751: LD_VAR 0 2
10755: PPUSH
10756: LD_VAR 0 3
10760: PPUSH
10761: LD_VAR 0 4
10765: PPUSH
10766: CALL 46408 0 4
// end ;
10770: PPOPN 4
10772: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10773: LD_VAR 0 1
10777: PPUSH
10778: LD_VAR 0 2
10782: PPUSH
10783: LD_VAR 0 3
10787: PPUSH
10788: CALL 46183 0 3
// end ;
10792: PPOPN 3
10794: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10795: LD_VAR 0 1
10799: PPUSH
10800: LD_VAR 0 2
10804: PPUSH
10805: CALL 46068 0 2
// end ;
10809: PPOPN 2
10811: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10812: LD_VAR 0 1
10816: PPUSH
10817: LD_VAR 0 2
10821: PPUSH
10822: CALL 50253 0 2
// end ;
10826: PPOPN 2
10828: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10829: LD_VAR 0 1
10833: PPUSH
10834: LD_VAR 0 2
10838: PPUSH
10839: LD_VAR 0 3
10843: PPUSH
10844: LD_VAR 0 4
10848: PPUSH
10849: CALL 50469 0 4
// end ;
10853: PPOPN 4
10855: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10856: LD_VAR 0 1
10860: PPUSH
10861: LD_VAR 0 2
10865: PPUSH
10866: CALL 45877 0 2
// end ;
10870: PPOPN 2
10872: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
10873: LD_VAR 0 1
10877: PPUSH
10878: CALL 104847 0 1
// end ; end_of_file
10882: PPOPN 1
10884: END
// export function Action ; begin
10885: LD_INT 0
10887: PPUSH
// InGameOn ;
10888: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
10892: LD_INT 206
10894: PPUSH
10895: LD_INT 11
10897: PPUSH
10898: CALL_OW 86
// wait ( 0 0$1 ) ;
10902: LD_INT 35
10904: PPUSH
10905: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
10909: LD_EXP 17
10913: PPUSH
10914: LD_STRING DStart-JMM-JMM-1
10916: PPUSH
10917: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
10921: LD_EXP 49
10925: PPUSH
10926: LD_STRING DStart-JMM-Bur-1
10928: PPUSH
10929: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
10933: LD_EXP 17
10937: PPUSH
10938: LD_STRING DStart-JMM-JMM-2
10940: PPUSH
10941: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
10945: LD_EXP 49
10949: PPUSH
10950: LD_STRING DStart-JMM-Bur-2
10952: PPUSH
10953: CALL_OW 88
// InGameOff ;
10957: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
10961: LD_STRING MStart
10963: PPUSH
10964: CALL_OW 337
// end ;
10968: LD_VAR 0 1
10972: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
10973: LD_INT 7
10975: PPUSH
10976: LD_INT 255
10978: PPUSH
10979: LD_INT 219
10981: PPUSH
10982: CALL_OW 293
10986: IFFALSE 11595
10988: GO 10990
10990: DISABLE
10991: LD_INT 0
10993: PPUSH
// begin wait ( 0 0$3 ) ;
10994: LD_INT 105
10996: PPUSH
10997: CALL_OW 67
// alienSpotted := true ;
11001: LD_ADDR_EXP 10
11005: PUSH
11006: LD_INT 1
11008: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
11009: LD_ADDR_VAR 0 1
11013: PUSH
11014: LD_INT 22
11016: PUSH
11017: LD_INT 7
11019: PUSH
11020: EMPTY
11021: LIST
11022: LIST
11023: PUSH
11024: LD_INT 23
11026: PUSH
11027: LD_INT 3
11029: PUSH
11030: EMPTY
11031: LIST
11032: LIST
11033: PUSH
11034: LD_INT 21
11036: PUSH
11037: LD_INT 1
11039: PUSH
11040: EMPTY
11041: LIST
11042: LIST
11043: PUSH
11044: LD_INT 26
11046: PUSH
11047: LD_INT 1
11049: PUSH
11050: EMPTY
11051: LIST
11052: LIST
11053: PUSH
11054: EMPTY
11055: LIST
11056: LIST
11057: LIST
11058: LIST
11059: PPUSH
11060: CALL_OW 69
11064: PUSH
11065: LD_EXP 49
11069: PUSH
11070: LD_EXP 37
11074: PUSH
11075: LD_EXP 39
11079: PUSH
11080: LD_EXP 40
11084: PUSH
11085: LD_EXP 47
11089: PUSH
11090: LD_EXP 46
11094: PUSH
11095: LD_EXP 41
11099: PUSH
11100: EMPTY
11101: LIST
11102: LIST
11103: LIST
11104: LIST
11105: LIST
11106: LIST
11107: LIST
11108: DIFF
11109: ST_TO_ADDR
// DialogueOn ;
11110: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
11114: LD_INT 255
11116: PPUSH
11117: LD_INT 219
11119: PPUSH
11120: LD_INT 7
11122: PPUSH
11123: LD_INT 20
11125: NEG
11126: PPUSH
11127: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
11131: LD_INT 255
11133: PPUSH
11134: LD_INT 219
11136: PPUSH
11137: CALL_OW 86
// if speaker then
11141: LD_VAR 0 1
11145: IFFALSE 11163
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
11147: LD_VAR 0 1
11151: PUSH
11152: LD_INT 1
11154: ARRAY
11155: PPUSH
11156: LD_STRING DAlienBase-RSol1-1
11158: PPUSH
11159: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
11163: LD_EXP 17
11167: PPUSH
11168: LD_STRING DAlienBase-JMM-1
11170: PPUSH
11171: CALL_OW 88
// if IsOk ( Burlak ) then
11175: LD_EXP 49
11179: PPUSH
11180: CALL_OW 302
11184: IFFALSE 11205
// begin dwait ( 0 0$1 ) ;
11186: LD_INT 35
11188: PPUSH
11189: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
11193: LD_EXP 49
11197: PPUSH
11198: LD_STRING DAlienBase-Bur-1
11200: PPUSH
11201: CALL_OW 88
// end ; if IsOk ( Roth ) then
11205: LD_EXP 18
11209: PPUSH
11210: CALL_OW 302
11214: IFFALSE 11228
// Say ( Roth , DAlienBase-Roth-1 ) ;
11216: LD_EXP 18
11220: PPUSH
11221: LD_STRING DAlienBase-Roth-1
11223: PPUSH
11224: CALL_OW 88
// if IsOk ( Gossudarov ) then
11228: LD_EXP 35
11232: PPUSH
11233: CALL_OW 302
11237: IFFALSE 11253
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
11239: LD_EXP 35
11243: PPUSH
11244: LD_STRING DAlienBase-Gos-1
11246: PPUSH
11247: CALL_OW 88
11251: GO 11370
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11253: LD_ADDR_VAR 0 1
11257: PUSH
11258: LD_INT 22
11260: PUSH
11261: LD_INT 7
11263: PUSH
11264: EMPTY
11265: LIST
11266: LIST
11267: PUSH
11268: LD_INT 25
11270: PUSH
11271: LD_INT 4
11273: PUSH
11274: EMPTY
11275: LIST
11276: LIST
11277: PUSH
11278: LD_INT 21
11280: PUSH
11281: LD_INT 1
11283: PUSH
11284: EMPTY
11285: LIST
11286: LIST
11287: PUSH
11288: LD_INT 26
11290: PUSH
11291: LD_INT 1
11293: PUSH
11294: EMPTY
11295: LIST
11296: LIST
11297: PUSH
11298: EMPTY
11299: LIST
11300: LIST
11301: LIST
11302: LIST
11303: PPUSH
11304: CALL_OW 69
11308: PUSH
11309: LD_EXP 18
11313: PUSH
11314: LD_EXP 17
11318: PUSH
11319: LD_EXP 49
11323: PUSH
11324: LD_EXP 37
11328: PUSH
11329: LD_EXP 47
11333: PUSH
11334: LD_EXP 46
11338: PUSH
11339: EMPTY
11340: LIST
11341: LIST
11342: LIST
11343: LIST
11344: LIST
11345: LIST
11346: DIFF
11347: ST_TO_ADDR
// if speaker then
11348: LD_VAR 0 1
11352: IFFALSE 11370
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
11354: LD_VAR 0 1
11358: PUSH
11359: LD_INT 1
11361: ARRAY
11362: PPUSH
11363: LD_STRING DAlienBase-Sci1-1
11365: PPUSH
11366: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
11370: LD_INT 255
11372: PPUSH
11373: LD_INT 219
11375: PPUSH
11376: LD_INT 7
11378: PPUSH
11379: CALL_OW 331
// DialogueOff ;
11383: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
11387: LD_INT 35
11389: PPUSH
11390: CALL_OW 67
// until IsSelected ( alien ) ;
11394: LD_INT 1
11396: PPUSH
11397: CALL_OW 306
11401: IFFALSE 11387
// if not artifactIResearched or not artifactIIResearched then
11403: LD_EXP 12
11407: NOT
11408: PUSH
11409: LD_EXP 13
11413: NOT
11414: OR
11415: IFFALSE 11595
// begin if IsOk ( Roth ) then
11417: LD_EXP 18
11421: PPUSH
11422: CALL_OW 302
11426: IFFALSE 11442
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
11428: LD_EXP 18
11432: PPUSH
11433: LD_STRING DAlieBaseNotReady-Roth-1
11435: PPUSH
11436: CALL_OW 88
11440: GO 11595
// if IsOk ( Gossudarov ) then
11442: LD_EXP 35
11446: PPUSH
11447: CALL_OW 302
11451: IFFALSE 11467
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
11453: LD_EXP 35
11457: PPUSH
11458: LD_STRING DAlieBaseNotReady-Gos-1
11460: PPUSH
11461: CALL_OW 88
11465: GO 11595
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11467: LD_ADDR_VAR 0 1
11471: PUSH
11472: LD_INT 22
11474: PUSH
11475: LD_INT 7
11477: PUSH
11478: EMPTY
11479: LIST
11480: LIST
11481: PUSH
11482: LD_INT 23
11484: PUSH
11485: LD_INT 3
11487: PUSH
11488: EMPTY
11489: LIST
11490: LIST
11491: PUSH
11492: LD_INT 25
11494: PUSH
11495: LD_INT 4
11497: PUSH
11498: EMPTY
11499: LIST
11500: LIST
11501: PUSH
11502: LD_INT 21
11504: PUSH
11505: LD_INT 1
11507: PUSH
11508: EMPTY
11509: LIST
11510: LIST
11511: PUSH
11512: LD_INT 26
11514: PUSH
11515: LD_INT 1
11517: PUSH
11518: EMPTY
11519: LIST
11520: LIST
11521: PUSH
11522: EMPTY
11523: LIST
11524: LIST
11525: LIST
11526: LIST
11527: LIST
11528: PPUSH
11529: CALL_OW 69
11533: PUSH
11534: LD_EXP 18
11538: PUSH
11539: LD_EXP 17
11543: PUSH
11544: LD_EXP 49
11548: PUSH
11549: LD_EXP 37
11553: PUSH
11554: LD_EXP 47
11558: PUSH
11559: LD_EXP 46
11563: PUSH
11564: EMPTY
11565: LIST
11566: LIST
11567: LIST
11568: LIST
11569: LIST
11570: LIST
11571: DIFF
11572: ST_TO_ADDR
// if speaker then
11573: LD_VAR 0 1
11577: IFFALSE 11595
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
11579: LD_VAR 0 1
11583: PUSH
11584: LD_INT 1
11586: ARRAY
11587: PPUSH
11588: LD_STRING DAlieBaseNotReady-RSci1-1
11590: PPUSH
11591: CALL_OW 88
// end ; end ; end ;
11595: PPOPN 1
11597: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
11598: LD_INT 24
11600: PPUSH
11601: LD_INT 7
11603: PPUSH
11604: CALL_OW 321
11608: PUSH
11609: LD_INT 2
11611: EQUAL
11612: IFFALSE 12303
11614: GO 11616
11616: DISABLE
11617: LD_INT 0
11619: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11620: LD_ADDR_VAR 0 1
11624: PUSH
11625: LD_INT 22
11627: PUSH
11628: LD_INT 7
11630: PUSH
11631: EMPTY
11632: LIST
11633: LIST
11634: PUSH
11635: LD_INT 23
11637: PUSH
11638: LD_INT 3
11640: PUSH
11641: EMPTY
11642: LIST
11643: LIST
11644: PUSH
11645: LD_INT 25
11647: PUSH
11648: LD_INT 4
11650: PUSH
11651: EMPTY
11652: LIST
11653: LIST
11654: PUSH
11655: LD_INT 21
11657: PUSH
11658: LD_INT 1
11660: PUSH
11661: EMPTY
11662: LIST
11663: LIST
11664: PUSH
11665: LD_INT 26
11667: PUSH
11668: LD_INT 1
11670: PUSH
11671: EMPTY
11672: LIST
11673: LIST
11674: PUSH
11675: EMPTY
11676: LIST
11677: LIST
11678: LIST
11679: LIST
11680: LIST
11681: PPUSH
11682: CALL_OW 69
11686: PUSH
11687: LD_EXP 18
11691: PUSH
11692: LD_EXP 17
11696: PUSH
11697: LD_EXP 49
11701: PUSH
11702: LD_EXP 37
11706: PUSH
11707: LD_EXP 47
11711: PUSH
11712: LD_EXP 46
11716: PUSH
11717: EMPTY
11718: LIST
11719: LIST
11720: LIST
11721: LIST
11722: LIST
11723: LIST
11724: DIFF
11725: ST_TO_ADDR
// if not speaker then
11726: LD_VAR 0 1
11730: NOT
11731: IFFALSE 11735
// exit ;
11733: GO 12303
// DialogueOn ;
11735: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
11739: LD_VAR 0 1
11743: PUSH
11744: LD_INT 1
11746: ARRAY
11747: PPUSH
11748: LD_STRING DArtefTechnology-RSci1-1
11750: PPUSH
11751: CALL_OW 88
// if IsOk ( Burlak ) then
11755: LD_EXP 49
11759: PPUSH
11760: CALL_OW 302
11764: IFFALSE 11778
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
11766: LD_EXP 49
11770: PPUSH
11771: LD_STRING DArtefTechnology-Bur-1
11773: PPUSH
11774: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
11778: LD_VAR 0 1
11782: PUSH
11783: LD_INT 1
11785: ARRAY
11786: PPUSH
11787: LD_STRING DArtefTechnology-RSci1-2
11789: PPUSH
11790: CALL_OW 88
// if Denis then
11794: LD_EXP 23
11798: IFFALSE 11815
// speaker := [ Denis ] else
11800: LD_ADDR_VAR 0 1
11804: PUSH
11805: LD_EXP 23
11809: PUSH
11810: EMPTY
11811: LIST
11812: ST_TO_ADDR
11813: GO 11921
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11815: LD_ADDR_VAR 0 1
11819: PUSH
11820: LD_INT 22
11822: PUSH
11823: LD_INT 7
11825: PUSH
11826: EMPTY
11827: LIST
11828: LIST
11829: PUSH
11830: LD_INT 23
11832: PUSH
11833: LD_INT 1
11835: PUSH
11836: EMPTY
11837: LIST
11838: LIST
11839: PUSH
11840: LD_INT 25
11842: PUSH
11843: LD_INT 4
11845: PUSH
11846: EMPTY
11847: LIST
11848: LIST
11849: PUSH
11850: LD_INT 21
11852: PUSH
11853: LD_INT 1
11855: PUSH
11856: EMPTY
11857: LIST
11858: LIST
11859: PUSH
11860: LD_INT 26
11862: PUSH
11863: LD_INT 1
11865: PUSH
11866: EMPTY
11867: LIST
11868: LIST
11869: PUSH
11870: EMPTY
11871: LIST
11872: LIST
11873: LIST
11874: LIST
11875: LIST
11876: PPUSH
11877: CALL_OW 69
11881: PUSH
11882: LD_EXP 18
11886: PUSH
11887: LD_EXP 17
11891: PUSH
11892: LD_EXP 49
11896: PUSH
11897: LD_EXP 37
11901: PUSH
11902: LD_EXP 47
11906: PUSH
11907: LD_EXP 46
11911: PUSH
11912: EMPTY
11913: LIST
11914: LIST
11915: LIST
11916: LIST
11917: LIST
11918: LIST
11919: DIFF
11920: ST_TO_ADDR
// if speaker then
11921: LD_VAR 0 1
11925: IFFALSE 11943
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
11927: LD_VAR 0 1
11931: PUSH
11932: LD_INT 1
11934: ARRAY
11935: PPUSH
11936: LD_STRING DArtefTechnology-Sci1-2
11938: PPUSH
11939: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11943: LD_ADDR_VAR 0 1
11947: PUSH
11948: LD_INT 22
11950: PUSH
11951: LD_INT 7
11953: PUSH
11954: EMPTY
11955: LIST
11956: LIST
11957: PUSH
11958: LD_INT 23
11960: PUSH
11961: LD_INT 3
11963: PUSH
11964: EMPTY
11965: LIST
11966: LIST
11967: PUSH
11968: LD_INT 25
11970: PUSH
11971: LD_INT 4
11973: PUSH
11974: EMPTY
11975: LIST
11976: LIST
11977: PUSH
11978: LD_INT 21
11980: PUSH
11981: LD_INT 1
11983: PUSH
11984: EMPTY
11985: LIST
11986: LIST
11987: PUSH
11988: LD_INT 26
11990: PUSH
11991: LD_INT 1
11993: PUSH
11994: EMPTY
11995: LIST
11996: LIST
11997: PUSH
11998: EMPTY
11999: LIST
12000: LIST
12001: LIST
12002: LIST
12003: LIST
12004: PPUSH
12005: CALL_OW 69
12009: PUSH
12010: LD_EXP 18
12014: PUSH
12015: LD_EXP 17
12019: PUSH
12020: LD_EXP 49
12024: PUSH
12025: LD_EXP 37
12029: PUSH
12030: LD_EXP 47
12034: PUSH
12035: LD_EXP 46
12039: PUSH
12040: EMPTY
12041: LIST
12042: LIST
12043: LIST
12044: LIST
12045: LIST
12046: LIST
12047: DIFF
12048: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
12049: LD_VAR 0 1
12053: PUSH
12054: LD_EXP 9
12058: PUSH
12059: LD_EXP 5
12063: OR
12064: AND
12065: IFFALSE 12299
// begin if arabianDestroyed and IsOk ( Burlak ) then
12067: LD_EXP 5
12071: PUSH
12072: LD_EXP 49
12076: PPUSH
12077: CALL_OW 302
12081: AND
12082: IFFALSE 12098
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
12084: LD_EXP 49
12088: PPUSH
12089: LD_STRING DArtefTechnology-Bur-2
12091: PPUSH
12092: CALL_OW 88
12096: GO 12110
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
12098: LD_EXP 17
12102: PPUSH
12103: LD_STRING DArtefTechnology-JMM-2
12105: PPUSH
12106: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
12110: LD_VAR 0 1
12114: PUSH
12115: LD_INT 1
12117: ARRAY
12118: PPUSH
12119: LD_STRING DArtefTechnology-RSci1-3
12121: PPUSH
12122: CALL_OW 88
// if Denis then
12126: LD_EXP 23
12130: IFFALSE 12147
// speaker := [ Denis ] else
12132: LD_ADDR_VAR 0 1
12136: PUSH
12137: LD_EXP 23
12141: PUSH
12142: EMPTY
12143: LIST
12144: ST_TO_ADDR
12145: GO 12253
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12147: LD_ADDR_VAR 0 1
12151: PUSH
12152: LD_INT 22
12154: PUSH
12155: LD_INT 7
12157: PUSH
12158: EMPTY
12159: LIST
12160: LIST
12161: PUSH
12162: LD_INT 23
12164: PUSH
12165: LD_INT 1
12167: PUSH
12168: EMPTY
12169: LIST
12170: LIST
12171: PUSH
12172: LD_INT 25
12174: PUSH
12175: LD_INT 4
12177: PUSH
12178: EMPTY
12179: LIST
12180: LIST
12181: PUSH
12182: LD_INT 21
12184: PUSH
12185: LD_INT 1
12187: PUSH
12188: EMPTY
12189: LIST
12190: LIST
12191: PUSH
12192: LD_INT 26
12194: PUSH
12195: LD_INT 1
12197: PUSH
12198: EMPTY
12199: LIST
12200: LIST
12201: PUSH
12202: EMPTY
12203: LIST
12204: LIST
12205: LIST
12206: LIST
12207: LIST
12208: PPUSH
12209: CALL_OW 69
12213: PUSH
12214: LD_EXP 18
12218: PUSH
12219: LD_EXP 17
12223: PUSH
12224: LD_EXP 49
12228: PUSH
12229: LD_EXP 37
12233: PUSH
12234: LD_EXP 47
12238: PUSH
12239: LD_EXP 46
12243: PUSH
12244: EMPTY
12245: LIST
12246: LIST
12247: LIST
12248: LIST
12249: LIST
12250: LIST
12251: DIFF
12252: ST_TO_ADDR
// if speaker then
12253: LD_VAR 0 1
12257: IFFALSE 12299
// if alienSpotted then
12259: LD_EXP 10
12263: IFFALSE 12283
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
12265: LD_VAR 0 1
12269: PUSH
12270: LD_INT 1
12272: ARRAY
12273: PPUSH
12274: LD_STRING DArtefTechnology-Sci1-3
12276: PPUSH
12277: CALL_OW 88
12281: GO 12299
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
12283: LD_VAR 0 1
12287: PUSH
12288: LD_INT 1
12290: ARRAY
12291: PPUSH
12292: LD_STRING DArtefTechnology-Sci1-3a
12294: PPUSH
12295: CALL_OW 88
// end ; DialogueOff ;
12299: CALL_OW 7
// end ;
12303: PPOPN 1
12305: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
12306: LD_EXP 12
12310: IFFALSE 12505
12312: GO 12314
12314: DISABLE
12315: LD_INT 0
12317: PPUSH
// begin if Denis then
12318: LD_EXP 23
12322: IFFALSE 12339
// speaker := [ Denis ] else
12324: LD_ADDR_VAR 0 1
12328: PUSH
12329: LD_EXP 23
12333: PUSH
12334: EMPTY
12335: LIST
12336: ST_TO_ADDR
12337: GO 12445
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12339: LD_ADDR_VAR 0 1
12343: PUSH
12344: LD_INT 22
12346: PUSH
12347: LD_INT 7
12349: PUSH
12350: EMPTY
12351: LIST
12352: LIST
12353: PUSH
12354: LD_INT 23
12356: PUSH
12357: LD_INT 1
12359: PUSH
12360: EMPTY
12361: LIST
12362: LIST
12363: PUSH
12364: LD_INT 25
12366: PUSH
12367: LD_INT 4
12369: PUSH
12370: EMPTY
12371: LIST
12372: LIST
12373: PUSH
12374: LD_INT 21
12376: PUSH
12377: LD_INT 1
12379: PUSH
12380: EMPTY
12381: LIST
12382: LIST
12383: PUSH
12384: LD_INT 26
12386: PUSH
12387: LD_INT 1
12389: PUSH
12390: EMPTY
12391: LIST
12392: LIST
12393: PUSH
12394: EMPTY
12395: LIST
12396: LIST
12397: LIST
12398: LIST
12399: LIST
12400: PPUSH
12401: CALL_OW 69
12405: PUSH
12406: LD_EXP 18
12410: PUSH
12411: LD_EXP 17
12415: PUSH
12416: LD_EXP 49
12420: PUSH
12421: LD_EXP 37
12425: PUSH
12426: LD_EXP 47
12430: PUSH
12431: LD_EXP 46
12435: PUSH
12436: EMPTY
12437: LIST
12438: LIST
12439: LIST
12440: LIST
12441: LIST
12442: LIST
12443: DIFF
12444: ST_TO_ADDR
// if not speaker then
12445: LD_VAR 0 1
12449: NOT
12450: IFFALSE 12454
// exit ;
12452: GO 12505
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
12454: LD_VAR 0 1
12458: PUSH
12459: LD_INT 1
12461: ARRAY
12462: PPUSH
12463: LD_STRING DArtefTechnologyAm-Sci1-1
12465: PPUSH
12466: CALL_OW 88
// if IsOk ( Burlak ) then
12470: LD_EXP 49
12474: PPUSH
12475: CALL_OW 302
12479: IFFALSE 12493
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
12481: LD_EXP 49
12485: PPUSH
12486: LD_STRING DArtefTechnologyAm-Bur-1
12488: PPUSH
12489: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
12493: LD_EXP 17
12497: PPUSH
12498: LD_STRING DArtefTechnologyAm-JMM-1
12500: PPUSH
12501: CALL_OW 88
// end ;
12505: PPOPN 1
12507: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
12508: LD_EXP 13
12512: IFFALSE 12702
12514: GO 12516
12516: DISABLE
12517: LD_INT 0
12519: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12520: LD_ADDR_VAR 0 1
12524: PUSH
12525: LD_INT 22
12527: PUSH
12528: LD_INT 7
12530: PUSH
12531: EMPTY
12532: LIST
12533: LIST
12534: PUSH
12535: LD_INT 23
12537: PUSH
12538: LD_INT 3
12540: PUSH
12541: EMPTY
12542: LIST
12543: LIST
12544: PUSH
12545: LD_INT 25
12547: PUSH
12548: LD_INT 4
12550: PUSH
12551: EMPTY
12552: LIST
12553: LIST
12554: PUSH
12555: LD_INT 21
12557: PUSH
12558: LD_INT 1
12560: PUSH
12561: EMPTY
12562: LIST
12563: LIST
12564: PUSH
12565: LD_INT 26
12567: PUSH
12568: LD_INT 1
12570: PUSH
12571: EMPTY
12572: LIST
12573: LIST
12574: PUSH
12575: EMPTY
12576: LIST
12577: LIST
12578: LIST
12579: LIST
12580: LIST
12581: PPUSH
12582: CALL_OW 69
12586: PUSH
12587: LD_EXP 18
12591: PUSH
12592: LD_EXP 17
12596: PUSH
12597: LD_EXP 49
12601: PUSH
12602: LD_EXP 37
12606: PUSH
12607: LD_EXP 47
12611: PUSH
12612: LD_EXP 46
12616: PUSH
12617: EMPTY
12618: LIST
12619: LIST
12620: LIST
12621: LIST
12622: LIST
12623: LIST
12624: DIFF
12625: ST_TO_ADDR
// if not speaker then
12626: LD_VAR 0 1
12630: NOT
12631: IFFALSE 12635
// exit ;
12633: GO 12702
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-1 ) ;
12635: LD_VAR 0 1
12639: PUSH
12640: LD_INT 1
12642: ARRAY
12643: PPUSH
12644: LD_STRING DArtefTechnologyRu-RSci1-1
12646: PPUSH
12647: CALL_OW 88
// if IsOk ( Burlak ) then
12651: LD_EXP 49
12655: PPUSH
12656: CALL_OW 302
12660: IFFALSE 12674
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
12662: LD_EXP 49
12666: PPUSH
12667: LD_STRING DArtefTechnologyRu-Bur-1
12669: PPUSH
12670: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-2 ) ;
12674: LD_VAR 0 1
12678: PUSH
12679: LD_INT 1
12681: ARRAY
12682: PPUSH
12683: LD_STRING DArtefTechnologyRu-RSci1-2
12685: PPUSH
12686: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
12690: LD_EXP 17
12694: PPUSH
12695: LD_STRING DArtefTechnologyRu-JMM-1
12697: PPUSH
12698: CALL_OW 88
// end ;
12702: PPOPN 1
12704: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
12705: LD_INT 24
12707: PPUSH
12708: LD_INT 7
12710: PPUSH
12711: CALL_OW 321
12715: PUSH
12716: LD_INT 2
12718: EQUAL
12719: PUSH
12720: LD_INT 1
12722: PPUSH
12723: CALL_OW 255
12727: PUSH
12728: LD_INT 7
12730: EQUAL
12731: AND
12732: IFFALSE 12892
12734: GO 12736
12736: DISABLE
12737: LD_INT 0
12739: PPUSH
// begin if Denis then
12740: LD_EXP 23
12744: IFFALSE 12761
// speaker := [ Denis ] else
12746: LD_ADDR_VAR 0 1
12750: PUSH
12751: LD_EXP 23
12755: PUSH
12756: EMPTY
12757: LIST
12758: ST_TO_ADDR
12759: GO 12867
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12761: LD_ADDR_VAR 0 1
12765: PUSH
12766: LD_INT 22
12768: PUSH
12769: LD_INT 7
12771: PUSH
12772: EMPTY
12773: LIST
12774: LIST
12775: PUSH
12776: LD_INT 23
12778: PUSH
12779: LD_INT 1
12781: PUSH
12782: EMPTY
12783: LIST
12784: LIST
12785: PUSH
12786: LD_INT 25
12788: PUSH
12789: LD_INT 4
12791: PUSH
12792: EMPTY
12793: LIST
12794: LIST
12795: PUSH
12796: LD_INT 21
12798: PUSH
12799: LD_INT 1
12801: PUSH
12802: EMPTY
12803: LIST
12804: LIST
12805: PUSH
12806: LD_INT 26
12808: PUSH
12809: LD_INT 1
12811: PUSH
12812: EMPTY
12813: LIST
12814: LIST
12815: PUSH
12816: EMPTY
12817: LIST
12818: LIST
12819: LIST
12820: LIST
12821: LIST
12822: PPUSH
12823: CALL_OW 69
12827: PUSH
12828: LD_EXP 18
12832: PUSH
12833: LD_EXP 17
12837: PUSH
12838: LD_EXP 49
12842: PUSH
12843: LD_EXP 37
12847: PUSH
12848: LD_EXP 47
12852: PUSH
12853: LD_EXP 46
12857: PUSH
12858: EMPTY
12859: LIST
12860: LIST
12861: LIST
12862: LIST
12863: LIST
12864: LIST
12865: DIFF
12866: ST_TO_ADDR
// if not speaker then
12867: LD_VAR 0 1
12871: NOT
12872: IFFALSE 12876
// exit ;
12874: GO 12892
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
12876: LD_VAR 0 1
12880: PUSH
12881: LD_INT 1
12883: ARRAY
12884: PPUSH
12885: LD_STRING DArtefTechnologyArStart-Sci1-1
12887: PPUSH
12888: CALL_OW 88
// end ;
12892: PPOPN 1
12894: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
12895: LD_EXP 14
12899: IFFALSE 13180
12901: GO 12903
12903: DISABLE
12904: LD_INT 0
12906: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12907: LD_ADDR_VAR 0 1
12911: PUSH
12912: LD_INT 22
12914: PUSH
12915: LD_INT 7
12917: PUSH
12918: EMPTY
12919: LIST
12920: LIST
12921: PUSH
12922: LD_INT 23
12924: PUSH
12925: LD_INT 3
12927: PUSH
12928: EMPTY
12929: LIST
12930: LIST
12931: PUSH
12932: LD_INT 25
12934: PUSH
12935: LD_INT 4
12937: PUSH
12938: EMPTY
12939: LIST
12940: LIST
12941: PUSH
12942: LD_INT 21
12944: PUSH
12945: LD_INT 1
12947: PUSH
12948: EMPTY
12949: LIST
12950: LIST
12951: PUSH
12952: LD_INT 26
12954: PUSH
12955: LD_INT 1
12957: PUSH
12958: EMPTY
12959: LIST
12960: LIST
12961: PUSH
12962: EMPTY
12963: LIST
12964: LIST
12965: LIST
12966: LIST
12967: LIST
12968: PPUSH
12969: CALL_OW 69
12973: PUSH
12974: LD_EXP 18
12978: PUSH
12979: LD_EXP 17
12983: PUSH
12984: LD_EXP 49
12988: PUSH
12989: LD_EXP 37
12993: PUSH
12994: LD_EXP 47
12998: PUSH
12999: LD_EXP 46
13003: PUSH
13004: EMPTY
13005: LIST
13006: LIST
13007: LIST
13008: LIST
13009: LIST
13010: LIST
13011: DIFF
13012: ST_TO_ADDR
// if not speaker then
13013: LD_VAR 0 1
13017: NOT
13018: IFFALSE 13022
// exit ;
13020: GO 13180
// DialogueOn ;
13022: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
13026: LD_VAR 0 1
13030: PUSH
13031: LD_INT 1
13033: ARRAY
13034: PPUSH
13035: LD_STRING DArtefTechnologyAr-RSci1-1
13037: PPUSH
13038: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
13042: LD_EXP 17
13046: PPUSH
13047: LD_STRING DArtefTechnologyAr-JMM-1
13049: PPUSH
13050: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
13054: LD_VAR 0 1
13058: PUSH
13059: LD_INT 1
13061: ARRAY
13062: PPUSH
13063: LD_STRING DArtefTechnologyAr-RSci1-2
13065: PPUSH
13066: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
13070: LD_EXP 17
13074: PPUSH
13075: LD_STRING DArtefTechnologyAr-JMM-2
13077: PPUSH
13078: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
13082: LD_VAR 0 1
13086: PUSH
13087: LD_INT 1
13089: ARRAY
13090: PPUSH
13091: LD_STRING DArtefTechnologyAr-RSci1-3
13093: PPUSH
13094: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
13098: LD_EXP 17
13102: PPUSH
13103: LD_STRING DArtefTechnologyAr-JMM-3
13105: PPUSH
13106: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
13110: LD_VAR 0 1
13114: PUSH
13115: LD_INT 1
13117: ARRAY
13118: PPUSH
13119: LD_STRING DArtefTechnologyAr-RSci1-4
13121: PPUSH
13122: CALL_OW 88
// if IsOk ( Burlak ) then
13126: LD_EXP 49
13130: PPUSH
13131: CALL_OW 302
13135: IFFALSE 13149
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
13137: LD_EXP 49
13141: PPUSH
13142: LD_STRING DArtefTechnologyAr-Bur-4
13144: PPUSH
13145: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
13149: LD_EXP 17
13153: PPUSH
13154: LD_STRING DArtefTechnologyAr-JMM-4
13156: PPUSH
13157: CALL_OW 88
// DialogueOff ;
13161: CALL_OW 7
// wait ( 0 0$45 ) ;
13165: LD_INT 1575
13167: PPUSH
13168: CALL_OW 67
// spawnOmar := true ;
13172: LD_ADDR_EXP 11
13176: PUSH
13177: LD_INT 1
13179: ST_TO_ADDR
// end ;
13180: PPOPN 1
13182: END
// every 0 0$1 trigger spawnOmar do
13183: LD_EXP 11
13187: IFFALSE 13567
13189: GO 13191
13191: DISABLE
// begin PrepareOmarAli ;
13192: CALL 6705 0 0
// if not HasTask ( Omar ) then
13196: LD_EXP 53
13200: PPUSH
13201: CALL_OW 314
13205: NOT
13206: IFFALSE 13223
// ComMoveXY ( Omar , 252 , 220 ) ;
13208: LD_EXP 53
13212: PPUSH
13213: LD_INT 252
13215: PPUSH
13216: LD_INT 220
13218: PPUSH
13219: CALL_OW 111
// if not Omar then
13223: LD_EXP 53
13227: NOT
13228: IFFALSE 13232
// exit ;
13230: GO 13567
// repeat wait ( 0 0$1 ) ;
13232: LD_INT 35
13234: PPUSH
13235: CALL_OW 67
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
13239: LD_EXP 53
13243: PPUSH
13244: CALL_OW 314
13248: NOT
13249: PUSH
13250: LD_EXP 53
13254: PPUSH
13255: LD_INT 252
13257: PPUSH
13258: LD_INT 220
13260: PPUSH
13261: CALL_OW 297
13265: PUSH
13266: LD_INT 6
13268: GREATER
13269: AND
13270: IFFALSE 13287
// ComMoveXY ( Omar , 252 , 220 ) ;
13272: LD_EXP 53
13276: PPUSH
13277: LD_INT 252
13279: PPUSH
13280: LD_INT 220
13282: PPUSH
13283: CALL_OW 111
// until See ( 7 , Omar ) ;
13287: LD_INT 7
13289: PPUSH
13290: LD_EXP 53
13294: PPUSH
13295: CALL_OW 292
13299: IFFALSE 13232
// CenterNowOnUnits ( Omar ) ;
13301: LD_EXP 53
13305: PPUSH
13306: CALL_OW 87
// DialogueOn ;
13310: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
13314: LD_EXP 53
13318: PPUSH
13319: LD_STRING DOmar-Omar-1
13321: PPUSH
13322: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
13326: LD_EXP 17
13330: PPUSH
13331: LD_STRING DOmar-JMM-1
13333: PPUSH
13334: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
13338: LD_EXP 53
13342: PPUSH
13343: LD_STRING DOmar-Omar-2
13345: PPUSH
13346: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
13350: LD_EXP 17
13354: PPUSH
13355: LD_STRING DOmar-JMM-2
13357: PPUSH
13358: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
13362: LD_EXP 53
13366: PPUSH
13367: LD_STRING DOmar-Omar-3
13369: PPUSH
13370: CALL_OW 88
// if IsOk ( Burlak ) then
13374: LD_EXP 49
13378: PPUSH
13379: CALL_OW 302
13383: IFFALSE 13399
// Say ( Burlak , DOmar-Bur-3 ) else
13385: LD_EXP 49
13389: PPUSH
13390: LD_STRING DOmar-Bur-3
13392: PPUSH
13393: CALL_OW 88
13397: GO 13411
// Say ( JMM , DOmar-JMM-3 ) ;
13399: LD_EXP 17
13403: PPUSH
13404: LD_STRING DOmar-JMM-3
13406: PPUSH
13407: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
13411: LD_EXP 53
13415: PPUSH
13416: LD_STRING DOmar-Omar-4
13418: PPUSH
13419: CALL_OW 88
// case Query ( QAccept ) of 1 :
13423: LD_STRING QAccept
13425: PPUSH
13426: CALL_OW 97
13430: PUSH
13431: LD_INT 1
13433: DOUBLE
13434: EQUAL
13435: IFTRUE 13439
13437: GO 13475
13439: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
13440: LD_EXP 17
13444: PPUSH
13445: LD_STRING DQrAccept#1-JMM-1
13447: PPUSH
13448: CALL_OW 88
// SetSide ( Omar , 7 ) ;
13452: LD_EXP 53
13456: PPUSH
13457: LD_INT 7
13459: PPUSH
13460: CALL_OW 235
// ComStop ( Omar ) ;
13464: LD_EXP 53
13468: PPUSH
13469: CALL_OW 141
// end ; 2 :
13473: GO 13524
13475: LD_INT 2
13477: DOUBLE
13478: EQUAL
13479: IFTRUE 13483
13481: GO 13523
13483: POP
// begin if IsOk ( Burlak ) then
13484: LD_EXP 49
13488: PPUSH
13489: CALL_OW 302
13493: IFFALSE 13509
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
13495: LD_EXP 49
13499: PPUSH
13500: LD_STRING DQrAccept#2-Bur-1
13502: PPUSH
13503: CALL_OW 88
13507: GO 13521
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
13509: LD_EXP 17
13513: PPUSH
13514: LD_STRING DQrAccept#2-JMM-1
13516: PPUSH
13517: CALL_OW 88
// end ; end ;
13521: GO 13524
13523: POP
// DialogueOff ;
13524: CALL_OW 7
// if GetSide ( Omar ) = 7 then
13528: LD_EXP 53
13532: PPUSH
13533: CALL_OW 255
13537: PUSH
13538: LD_INT 7
13540: EQUAL
13541: IFFALSE 13552
// begin SetAchievement ( ACH_OMAR ) ;
13543: LD_STRING ACH_OMAR
13545: PPUSH
13546: CALL_OW 543
// exit ;
13550: GO 13567
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
13552: LD_EXP 53
13556: PPUSH
13557: LD_INT 202
13559: PPUSH
13560: LD_INT 115
13562: PPUSH
13563: CALL_OW 111
// end ;
13567: END
// every 0 0$1 trigger GetDistUnitXY ( Omar , 200 , 98 ) < 40 and russianDestroyed do
13568: LD_EXP 53
13572: PPUSH
13573: LD_INT 200
13575: PPUSH
13576: LD_INT 98
13578: PPUSH
13579: CALL_OW 297
13583: PUSH
13584: LD_INT 40
13586: LESS
13587: PUSH
13588: LD_EXP 2
13592: AND
13593: IFFALSE 13811
13595: GO 13597
13597: DISABLE
// begin SetSide ( Omar , 5 ) ;
13598: LD_EXP 53
13602: PPUSH
13603: LD_INT 5
13605: PPUSH
13606: CALL_OW 235
// if IsInUnit ( Omar ) then
13610: LD_EXP 53
13614: PPUSH
13615: CALL_OW 310
13619: IFFALSE 13630
// ComExitVehicle ( Omar ) ;
13621: LD_EXP 53
13625: PPUSH
13626: CALL_OW 121
// if IsInUnit ( Omar ) then
13630: LD_EXP 53
13634: PPUSH
13635: CALL_OW 310
13639: IFFALSE 13650
// ComExitBuilding ( Omar ) ;
13641: LD_EXP 53
13645: PPUSH
13646: CALL_OW 122
// wait ( 0 0$1 ) ;
13650: LD_INT 35
13652: PPUSH
13653: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
13657: LD_EXP 53
13661: PPUSH
13662: LD_INT 203
13664: PPUSH
13665: LD_INT 120
13667: PPUSH
13668: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
13672: LD_INT 35
13674: PPUSH
13675: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 6 ;
13679: LD_EXP 53
13683: PPUSH
13684: CALL_OW 306
13688: PUSH
13689: LD_EXP 53
13693: PPUSH
13694: LD_INT 203
13696: PPUSH
13697: LD_INT 120
13699: PPUSH
13700: CALL_OW 297
13704: PUSH
13705: LD_INT 6
13707: LESS
13708: OR
13709: IFFALSE 13672
// CenterNowOnUnits ( Omar ) ;
13711: LD_EXP 53
13715: PPUSH
13716: CALL_OW 87
// DialogueOn ;
13720: CALL_OW 6
// Say ( JMM , DOmarContam-JMM-1 ) ;
13724: LD_EXP 17
13728: PPUSH
13729: LD_STRING DOmarContam-JMM-1
13731: PPUSH
13732: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
13736: LD_EXP 53
13740: PPUSH
13741: LD_STRING DOmarContam-Omar-1
13743: PPUSH
13744: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
13748: LD_EXP 17
13752: PPUSH
13753: LD_STRING DOmarContam-JMM-2
13755: PPUSH
13756: CALL_OW 88
// DialogueOff ;
13760: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
13764: LD_INT 5
13766: PPUSH
13767: LD_INT 7
13769: PPUSH
13770: LD_INT 2
13772: PPUSH
13773: LD_INT 1
13775: PPUSH
13776: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
13780: LD_INT 105
13782: PPUSH
13783: CALL_OW 67
// until IsAt ( Omar , 203 , 120 ) ;
13787: LD_EXP 53
13791: PPUSH
13792: LD_INT 203
13794: PPUSH
13795: LD_INT 120
13797: PPUSH
13798: CALL_OW 307
13802: IFFALSE 13780
// YouLost ( MothContaminate ) ;
13804: LD_STRING MothContaminate
13806: PPUSH
13807: CALL_OW 104
// end ;
13811: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
13812: LD_EXP 4
13816: NOT
13817: PUSH
13818: LD_INT 22
13820: PUSH
13821: LD_INT 1
13823: PUSH
13824: EMPTY
13825: LIST
13826: LIST
13827: PUSH
13828: LD_INT 34
13830: PUSH
13831: LD_INT 8
13833: PUSH
13834: EMPTY
13835: LIST
13836: LIST
13837: PUSH
13838: EMPTY
13839: LIST
13840: LIST
13841: PPUSH
13842: CALL_OW 69
13846: AND
13847: IFFALSE 13928
13849: GO 13851
13851: DISABLE
// begin if not IsOk ( Powell ) then
13852: LD_EXP 52
13856: PPUSH
13857: CALL_OW 302
13861: NOT
13862: IFFALSE 13866
// exit ;
13864: GO 13928
// DialogueOn ;
13866: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
13870: LD_EXP 52
13874: PPUSH
13875: LD_STRING DWinAmericans-Pow-1
13877: PPUSH
13878: CALL_OW 94
// if IsOk ( Burlak ) then
13882: LD_EXP 49
13886: PPUSH
13887: CALL_OW 302
13891: IFFALSE 13905
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
13893: LD_EXP 49
13897: PPUSH
13898: LD_STRING DWinAmericans-Bur-1
13900: PPUSH
13901: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
13905: LD_EXP 17
13909: PPUSH
13910: LD_STRING DWinAmericans-JMM-1
13912: PPUSH
13913: CALL_OW 88
// DialogueOff ;
13917: CALL_OW 7
// YouLost ( AmBomb ) ;
13921: LD_STRING AmBomb
13923: PPUSH
13924: CALL_OW 104
// end ;
13928: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
13929: LD_EXP 2
13933: NOT
13934: PUSH
13935: LD_INT 22
13937: PUSH
13938: LD_INT 3
13940: PUSH
13941: EMPTY
13942: LIST
13943: LIST
13944: PUSH
13945: LD_INT 34
13947: PUSH
13948: LD_INT 48
13950: PUSH
13951: EMPTY
13952: LIST
13953: LIST
13954: PUSH
13955: EMPTY
13956: LIST
13957: LIST
13958: PPUSH
13959: CALL_OW 69
13963: AND
13964: IFFALSE 14045
13966: GO 13968
13968: DISABLE
// begin if not IsOk ( Platonov ) then
13969: LD_EXP 56
13973: PPUSH
13974: CALL_OW 302
13978: NOT
13979: IFFALSE 13983
// exit ;
13981: GO 14045
// DialogueOn ;
13983: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
13987: LD_EXP 56
13991: PPUSH
13992: LD_STRING DWinRussians-Pla-1
13994: PPUSH
13995: CALL_OW 94
// if IsOk ( Burlak ) then
13999: LD_EXP 49
14003: PPUSH
14004: CALL_OW 302
14008: IFFALSE 14022
// Say ( Burlak , DWinRussians-Bur-1 ) ;
14010: LD_EXP 49
14014: PPUSH
14015: LD_STRING DWinRussians-Bur-1
14017: PPUSH
14018: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
14022: LD_EXP 17
14026: PPUSH
14027: LD_STRING DWinRussians-JMM-1
14029: PPUSH
14030: CALL_OW 88
// DialogueOff ;
14034: CALL_OW 7
// YouLost ( RuBomb ) ;
14038: LD_STRING RuBomb
14040: PPUSH
14041: CALL_OW 104
// end ;
14045: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
14046: LD_INT 7
14048: PPUSH
14049: LD_INT 22
14051: PUSH
14052: LD_INT 7
14054: PUSH
14055: EMPTY
14056: LIST
14057: LIST
14058: PPUSH
14059: CALL_OW 70
14063: PUSH
14064: LD_EXP 4
14068: NOT
14069: AND
14070: IFFALSE 14099
14072: GO 14074
14074: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
14075: LD_EXP 52
14079: PPUSH
14080: LD_STRING DSurrenderAmericans-Pow-1
14082: PPUSH
14083: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
14087: LD_EXP 17
14091: PPUSH
14092: LD_STRING DSurrenderAmericans-JMM-1
14094: PPUSH
14095: CALL_OW 88
// end ;
14099: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
14100: LD_INT 2
14102: PPUSH
14103: LD_INT 22
14105: PUSH
14106: LD_INT 7
14108: PUSH
14109: EMPTY
14110: LIST
14111: LIST
14112: PPUSH
14113: CALL_OW 70
14117: PUSH
14118: LD_EXP 2
14122: NOT
14123: AND
14124: PUSH
14125: LD_EXP 49
14129: AND
14130: IFFALSE 14159
14132: GO 14134
14134: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
14135: LD_EXP 56
14139: PPUSH
14140: LD_STRING DSurrenderRussians-Pla-1
14142: PPUSH
14143: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
14147: LD_EXP 49
14151: PPUSH
14152: LD_STRING DSurrenderRussians-Bur-1
14154: PPUSH
14155: CALL_OW 88
// end ;
14159: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
14160: LD_EXP 4
14164: IFFALSE 14547
14166: GO 14168
14168: DISABLE
14169: LD_INT 0
14171: PPUSH
14172: PPUSH
14173: PPUSH
// begin MC_Kill ( 4 ) ;
14174: LD_INT 4
14176: PPUSH
14177: CALL 20806 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
14181: LD_INT 1
14183: PPUSH
14184: LD_INT 7
14186: PPUSH
14187: LD_INT 1
14189: PPUSH
14190: LD_INT 1
14192: PPUSH
14193: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
14197: LD_ADDR_VAR 0 3
14201: PUSH
14202: LD_INT 22
14204: PUSH
14205: LD_INT 1
14207: PUSH
14208: EMPTY
14209: LIST
14210: LIST
14211: PUSH
14212: LD_INT 26
14214: PUSH
14215: LD_INT 1
14217: PUSH
14218: EMPTY
14219: LIST
14220: LIST
14221: PUSH
14222: LD_INT 23
14224: PUSH
14225: LD_INT 1
14227: PUSH
14228: EMPTY
14229: LIST
14230: LIST
14231: PUSH
14232: EMPTY
14233: LIST
14234: LIST
14235: LIST
14236: PPUSH
14237: CALL_OW 69
14241: PUSH
14242: LD_EXP 52
14246: PUSH
14247: LD_EXP 25
14251: PUSH
14252: LD_EXP 22
14256: PUSH
14257: LD_EXP 21
14261: PUSH
14262: LD_EXP 28
14266: PUSH
14267: LD_EXP 26
14271: PUSH
14272: EMPTY
14273: LIST
14274: LIST
14275: LIST
14276: LIST
14277: LIST
14278: LIST
14279: DIFF
14280: ST_TO_ADDR
// if speaker then
14281: LD_VAR 0 3
14285: IFFALSE 14311
// begin DialogueOn ;
14287: CALL_OW 6
// SayRadio ( speaker [ 1 ] , DSurrenderAmericans-Sol1-1a ) ;
14291: LD_VAR 0 3
14295: PUSH
14296: LD_INT 1
14298: ARRAY
14299: PPUSH
14300: LD_STRING DSurrenderAmericans-Sol1-1a
14302: PPUSH
14303: CALL_OW 94
// DialogueOff ;
14307: CALL_OW 7
// end ; americanCapitulated := true ;
14311: LD_ADDR_EXP 6
14315: PUSH
14316: LD_INT 1
14318: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14319: LD_ADDR_VAR 0 2
14323: PUSH
14324: LD_INT 22
14326: PUSH
14327: LD_INT 1
14329: PUSH
14330: EMPTY
14331: LIST
14332: LIST
14333: PUSH
14334: LD_INT 21
14336: PUSH
14337: LD_INT 1
14339: PUSH
14340: EMPTY
14341: LIST
14342: LIST
14343: PUSH
14344: EMPTY
14345: LIST
14346: LIST
14347: PPUSH
14348: CALL_OW 69
14352: PUSH
14353: LD_INT 22
14355: PUSH
14356: LD_INT 1
14358: PUSH
14359: EMPTY
14360: LIST
14361: LIST
14362: PUSH
14363: LD_INT 21
14365: PUSH
14366: LD_INT 2
14368: PUSH
14369: EMPTY
14370: LIST
14371: LIST
14372: PUSH
14373: LD_INT 1
14375: PUSH
14376: EMPTY
14377: LIST
14378: PUSH
14379: EMPTY
14380: LIST
14381: LIST
14382: LIST
14383: PPUSH
14384: CALL_OW 69
14388: ADD
14389: ST_TO_ADDR
// if tmp then
14390: LD_VAR 0 2
14394: IFFALSE 14547
// repeat wait ( 0 0$1 ) ;
14396: LD_INT 35
14398: PPUSH
14399: CALL_OW 67
// for i in tmp do
14403: LD_ADDR_VAR 0 1
14407: PUSH
14408: LD_VAR 0 2
14412: PUSH
14413: FOR_IN
14414: IFFALSE 14496
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14416: LD_VAR 0 1
14420: PPUSH
14421: CALL_OW 310
14425: PUSH
14426: LD_VAR 0 1
14430: PPUSH
14431: CALL_OW 310
14435: PPUSH
14436: CALL_OW 247
14440: PUSH
14441: LD_INT 3
14443: EQUAL
14444: AND
14445: IFFALSE 14456
// ComExitBuilding ( i ) ;
14447: LD_VAR 0 1
14451: PPUSH
14452: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
14456: LD_VAR 0 1
14460: PPUSH
14461: LD_INT 122
14463: PPUSH
14464: LD_INT 242
14466: PPUSH
14467: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
14471: LD_VAR 0 1
14475: PPUSH
14476: LD_INT 35
14478: PPUSH
14479: CALL_OW 308
14483: IFFALSE 14494
// RemoveUnit ( i ) ;
14485: LD_VAR 0 1
14489: PPUSH
14490: CALL_OW 64
// end ;
14494: GO 14413
14496: POP
14497: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14498: LD_INT 22
14500: PUSH
14501: LD_INT 1
14503: PUSH
14504: EMPTY
14505: LIST
14506: LIST
14507: PUSH
14508: LD_INT 2
14510: PUSH
14511: LD_INT 21
14513: PUSH
14514: LD_INT 1
14516: PUSH
14517: EMPTY
14518: LIST
14519: LIST
14520: PUSH
14521: LD_INT 33
14523: PUSH
14524: LD_INT 1
14526: PUSH
14527: EMPTY
14528: LIST
14529: LIST
14530: PUSH
14531: EMPTY
14532: LIST
14533: LIST
14534: LIST
14535: PUSH
14536: EMPTY
14537: LIST
14538: LIST
14539: PPUSH
14540: CALL_OW 69
14544: NOT
14545: IFFALSE 14396
// end ;
14547: PPOPN 3
14549: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
14550: LD_EXP 2
14554: IFFALSE 14955
14556: GO 14558
14558: DISABLE
14559: LD_INT 0
14561: PPUSH
14562: PPUSH
14563: PPUSH
// begin repeat wait ( 0 0$1 ) ;
14564: LD_INT 35
14566: PPUSH
14567: CALL_OW 67
// until IsDead ( Yakotich ) ;
14571: LD_EXP 57
14575: PPUSH
14576: CALL_OW 301
14580: IFFALSE 14564
// MC_Kill ( 2 ) ;
14582: LD_INT 2
14584: PPUSH
14585: CALL 20806 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
14589: LD_INT 3
14591: PPUSH
14592: LD_INT 7
14594: PPUSH
14595: LD_INT 1
14597: PPUSH
14598: LD_INT 1
14600: PPUSH
14601: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff [ Platonov , Yakotich ] ;
14605: LD_ADDR_VAR 0 3
14609: PUSH
14610: LD_INT 22
14612: PUSH
14613: LD_INT 3
14615: PUSH
14616: EMPTY
14617: LIST
14618: LIST
14619: PUSH
14620: LD_INT 26
14622: PUSH
14623: LD_INT 1
14625: PUSH
14626: EMPTY
14627: LIST
14628: LIST
14629: PUSH
14630: LD_INT 23
14632: PUSH
14633: LD_INT 3
14635: PUSH
14636: EMPTY
14637: LIST
14638: LIST
14639: PUSH
14640: EMPTY
14641: LIST
14642: LIST
14643: LIST
14644: PPUSH
14645: CALL_OW 69
14649: PUSH
14650: LD_EXP 56
14654: PUSH
14655: LD_EXP 57
14659: PUSH
14660: EMPTY
14661: LIST
14662: LIST
14663: DIFF
14664: ST_TO_ADDR
// if speaker then
14665: LD_VAR 0 3
14669: IFFALSE 14719
// begin DialogueOn ;
14671: CALL_OW 6
// if Burlak then
14675: LD_EXP 49
14679: IFFALSE 14699
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1 ) else
14681: LD_VAR 0 3
14685: PUSH
14686: LD_INT 1
14688: ARRAY
14689: PPUSH
14690: LD_STRING DSurrenderRussians-RSol1-1
14692: PPUSH
14693: CALL_OW 94
14697: GO 14715
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1a ) ;
14699: LD_VAR 0 3
14703: PUSH
14704: LD_INT 1
14706: ARRAY
14707: PPUSH
14708: LD_STRING DSurrenderRussians-RSol1-1a
14710: PPUSH
14711: CALL_OW 94
// DialogueOff ;
14715: CALL_OW 7
// end ; russianCapitulated := true ;
14719: LD_ADDR_EXP 7
14723: PUSH
14724: LD_INT 1
14726: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14727: LD_ADDR_VAR 0 2
14731: PUSH
14732: LD_INT 22
14734: PUSH
14735: LD_INT 3
14737: PUSH
14738: EMPTY
14739: LIST
14740: LIST
14741: PUSH
14742: LD_INT 21
14744: PUSH
14745: LD_INT 1
14747: PUSH
14748: EMPTY
14749: LIST
14750: LIST
14751: PUSH
14752: EMPTY
14753: LIST
14754: LIST
14755: PPUSH
14756: CALL_OW 69
14760: PUSH
14761: LD_INT 22
14763: PUSH
14764: LD_INT 3
14766: PUSH
14767: EMPTY
14768: LIST
14769: LIST
14770: PUSH
14771: LD_INT 21
14773: PUSH
14774: LD_INT 2
14776: PUSH
14777: EMPTY
14778: LIST
14779: LIST
14780: PUSH
14781: LD_INT 1
14783: PUSH
14784: EMPTY
14785: LIST
14786: PUSH
14787: EMPTY
14788: LIST
14789: LIST
14790: LIST
14791: PPUSH
14792: CALL_OW 69
14796: ADD
14797: ST_TO_ADDR
// if tmp then
14798: LD_VAR 0 2
14802: IFFALSE 14955
// repeat wait ( 0 0$1 ) ;
14804: LD_INT 35
14806: PPUSH
14807: CALL_OW 67
// for i in tmp do
14811: LD_ADDR_VAR 0 1
14815: PUSH
14816: LD_VAR 0 2
14820: PUSH
14821: FOR_IN
14822: IFFALSE 14904
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14824: LD_VAR 0 1
14828: PPUSH
14829: CALL_OW 310
14833: PUSH
14834: LD_VAR 0 1
14838: PPUSH
14839: CALL_OW 310
14843: PPUSH
14844: CALL_OW 247
14848: PUSH
14849: LD_INT 3
14851: EQUAL
14852: AND
14853: IFFALSE 14864
// ComExitBuilding ( i ) ;
14855: LD_VAR 0 1
14859: PPUSH
14860: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
14864: LD_VAR 0 1
14868: PPUSH
14869: LD_INT 154
14871: PPUSH
14872: LD_INT 1
14874: PPUSH
14875: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
14879: LD_VAR 0 1
14883: PPUSH
14884: LD_INT 36
14886: PPUSH
14887: CALL_OW 308
14891: IFFALSE 14902
// RemoveUnit ( i ) ;
14893: LD_VAR 0 1
14897: PPUSH
14898: CALL_OW 64
// end ;
14902: GO 14821
14904: POP
14905: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14906: LD_INT 22
14908: PUSH
14909: LD_INT 3
14911: PUSH
14912: EMPTY
14913: LIST
14914: LIST
14915: PUSH
14916: LD_INT 2
14918: PUSH
14919: LD_INT 21
14921: PUSH
14922: LD_INT 1
14924: PUSH
14925: EMPTY
14926: LIST
14927: LIST
14928: PUSH
14929: LD_INT 33
14931: PUSH
14932: LD_INT 1
14934: PUSH
14935: EMPTY
14936: LIST
14937: LIST
14938: PUSH
14939: EMPTY
14940: LIST
14941: LIST
14942: LIST
14943: PUSH
14944: EMPTY
14945: LIST
14946: LIST
14947: PPUSH
14948: CALL_OW 69
14952: NOT
14953: IFFALSE 14804
// end ;
14955: PPOPN 3
14957: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
14958: LD_INT 22
14960: PUSH
14961: LD_INT 8
14963: PUSH
14964: EMPTY
14965: LIST
14966: LIST
14967: PUSH
14968: LD_INT 21
14970: PUSH
14971: LD_INT 1
14973: PUSH
14974: EMPTY
14975: LIST
14976: LIST
14977: PUSH
14978: LD_INT 23
14980: PUSH
14981: LD_INT 2
14983: PUSH
14984: EMPTY
14985: LIST
14986: LIST
14987: PUSH
14988: EMPTY
14989: LIST
14990: LIST
14991: LIST
14992: PPUSH
14993: CALL_OW 69
14997: PUSH
14998: LD_INT 18
15000: LESS
15001: PUSH
15002: LD_EXP 55
15006: PPUSH
15007: CALL_OW 301
15011: OR
15012: PUSH
15013: LD_INT 324
15015: PPUSH
15016: CALL_OW 255
15020: PUSH
15021: LD_INT 7
15023: EQUAL
15024: OR
15025: IFFALSE 15038
15027: GO 15029
15029: DISABLE
// legionDestroyed := true ;
15030: LD_ADDR_EXP 3
15034: PUSH
15035: LD_INT 1
15037: ST_TO_ADDR
15038: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 do
15039: LD_INT 22
15041: PUSH
15042: LD_INT 2
15044: PUSH
15045: EMPTY
15046: LIST
15047: LIST
15048: PUSH
15049: LD_INT 21
15051: PUSH
15052: LD_INT 1
15054: PUSH
15055: EMPTY
15056: LIST
15057: LIST
15058: PUSH
15059: LD_INT 23
15061: PUSH
15062: LD_INT 2
15064: PUSH
15065: EMPTY
15066: LIST
15067: LIST
15068: PUSH
15069: EMPTY
15070: LIST
15071: LIST
15072: LIST
15073: PPUSH
15074: CALL_OW 69
15078: PUSH
15079: LD_INT 9
15081: LESS
15082: IFFALSE 15095
15084: GO 15086
15086: DISABLE
// arabianDestroyed := true ;
15087: LD_ADDR_EXP 5
15091: PUSH
15092: LD_INT 1
15094: ST_TO_ADDR
15095: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
15096: LD_EXP 5
15100: IFFALSE 15344
15102: GO 15104
15104: DISABLE
15105: LD_INT 0
15107: PPUSH
15108: PPUSH
// begin MC_Kill ( 1 ) ;
15109: LD_INT 1
15111: PPUSH
15112: CALL 20806 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15116: LD_ADDR_VAR 0 2
15120: PUSH
15121: LD_INT 22
15123: PUSH
15124: LD_INT 2
15126: PUSH
15127: EMPTY
15128: LIST
15129: LIST
15130: PUSH
15131: LD_INT 21
15133: PUSH
15134: LD_INT 1
15136: PUSH
15137: EMPTY
15138: LIST
15139: LIST
15140: PUSH
15141: EMPTY
15142: LIST
15143: LIST
15144: PPUSH
15145: CALL_OW 69
15149: PUSH
15150: LD_INT 22
15152: PUSH
15153: LD_INT 8
15155: PUSH
15156: EMPTY
15157: LIST
15158: LIST
15159: PUSH
15160: LD_INT 21
15162: PUSH
15163: LD_INT 2
15165: PUSH
15166: EMPTY
15167: LIST
15168: LIST
15169: PUSH
15170: LD_INT 1
15172: PUSH
15173: EMPTY
15174: LIST
15175: PUSH
15176: EMPTY
15177: LIST
15178: LIST
15179: LIST
15180: PPUSH
15181: CALL_OW 69
15185: ADD
15186: ST_TO_ADDR
// if tmp then
15187: LD_VAR 0 2
15191: IFFALSE 15344
// repeat wait ( 0 0$1 ) ;
15193: LD_INT 35
15195: PPUSH
15196: CALL_OW 67
// for i in tmp do
15200: LD_ADDR_VAR 0 1
15204: PUSH
15205: LD_VAR 0 2
15209: PUSH
15210: FOR_IN
15211: IFFALSE 15293
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15213: LD_VAR 0 1
15217: PPUSH
15218: CALL_OW 310
15222: PUSH
15223: LD_VAR 0 1
15227: PPUSH
15228: CALL_OW 310
15232: PPUSH
15233: CALL_OW 247
15237: PUSH
15238: LD_INT 3
15240: EQUAL
15241: AND
15242: IFFALSE 15253
// ComExitBuilding ( i ) ;
15244: LD_VAR 0 1
15248: PPUSH
15249: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
15253: LD_VAR 0 1
15257: PPUSH
15258: LD_INT 254
15260: PPUSH
15261: LD_INT 268
15263: PPUSH
15264: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
15268: LD_VAR 0 1
15272: PPUSH
15273: LD_INT 34
15275: PPUSH
15276: CALL_OW 308
15280: IFFALSE 15291
// RemoveUnit ( i ) ;
15282: LD_VAR 0 1
15286: PPUSH
15287: CALL_OW 64
// end ;
15291: GO 15210
15293: POP
15294: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15295: LD_INT 22
15297: PUSH
15298: LD_INT 2
15300: PUSH
15301: EMPTY
15302: LIST
15303: LIST
15304: PUSH
15305: LD_INT 2
15307: PUSH
15308: LD_INT 21
15310: PUSH
15311: LD_INT 1
15313: PUSH
15314: EMPTY
15315: LIST
15316: LIST
15317: PUSH
15318: LD_INT 33
15320: PUSH
15321: LD_INT 1
15323: PUSH
15324: EMPTY
15325: LIST
15326: LIST
15327: PUSH
15328: EMPTY
15329: LIST
15330: LIST
15331: LIST
15332: PUSH
15333: EMPTY
15334: LIST
15335: LIST
15336: PPUSH
15337: CALL_OW 69
15341: NOT
15342: IFFALSE 15193
// end ;
15344: PPOPN 2
15346: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
15347: LD_EXP 3
15351: IFFALSE 15703
15353: GO 15355
15355: DISABLE
15356: LD_INT 0
15358: PPUSH
15359: PPUSH
// begin MC_Kill ( 3 ) ;
15360: LD_INT 3
15362: PPUSH
15363: CALL 20806 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
15367: LD_INT 8
15369: PPUSH
15370: LD_INT 7
15372: PPUSH
15373: LD_INT 1
15375: PPUSH
15376: LD_INT 1
15378: PPUSH
15379: CALL_OW 80
// DialogueOn ;
15383: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
15387: LD_EXP 54
15391: PPUSH
15392: LD_STRING D15-Szulc-1
15394: PPUSH
15395: CALL_OW 94
// DialogueOff ;
15399: CALL_OW 7
// legionCapitulated := true ;
15403: LD_ADDR_EXP 8
15407: PUSH
15408: LD_INT 1
15410: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
15411: LD_ADDR_VAR 0 1
15415: PUSH
15416: LD_INT 22
15418: PUSH
15419: LD_INT 8
15421: PUSH
15422: EMPTY
15423: LIST
15424: LIST
15425: PUSH
15426: LD_INT 21
15428: PUSH
15429: LD_INT 3
15431: PUSH
15432: EMPTY
15433: LIST
15434: LIST
15435: PUSH
15436: LD_INT 23
15438: PUSH
15439: LD_INT 3
15441: PUSH
15442: EMPTY
15443: LIST
15444: LIST
15445: PUSH
15446: EMPTY
15447: LIST
15448: LIST
15449: LIST
15450: PPUSH
15451: CALL_OW 69
15455: PUSH
15456: FOR_IN
15457: IFFALSE 15473
// SetLives ( i , 3 ) ;
15459: LD_VAR 0 1
15463: PPUSH
15464: LD_INT 3
15466: PPUSH
15467: CALL_OW 234
15471: GO 15456
15473: POP
15474: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15475: LD_ADDR_VAR 0 2
15479: PUSH
15480: LD_INT 22
15482: PUSH
15483: LD_INT 8
15485: PUSH
15486: EMPTY
15487: LIST
15488: LIST
15489: PUSH
15490: LD_INT 21
15492: PUSH
15493: LD_INT 1
15495: PUSH
15496: EMPTY
15497: LIST
15498: LIST
15499: PUSH
15500: EMPTY
15501: LIST
15502: LIST
15503: PPUSH
15504: CALL_OW 69
15508: PUSH
15509: LD_INT 22
15511: PUSH
15512: LD_INT 8
15514: PUSH
15515: EMPTY
15516: LIST
15517: LIST
15518: PUSH
15519: LD_INT 21
15521: PUSH
15522: LD_INT 2
15524: PUSH
15525: EMPTY
15526: LIST
15527: LIST
15528: PUSH
15529: LD_INT 1
15531: PUSH
15532: EMPTY
15533: LIST
15534: PUSH
15535: EMPTY
15536: LIST
15537: LIST
15538: LIST
15539: PPUSH
15540: CALL_OW 69
15544: ADD
15545: ST_TO_ADDR
// if tmp then
15546: LD_VAR 0 2
15550: IFFALSE 15703
// repeat wait ( 0 0$1 ) ;
15552: LD_INT 35
15554: PPUSH
15555: CALL_OW 67
// for i in tmp do
15559: LD_ADDR_VAR 0 1
15563: PUSH
15564: LD_VAR 0 2
15568: PUSH
15569: FOR_IN
15570: IFFALSE 15652
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15572: LD_VAR 0 1
15576: PPUSH
15577: CALL_OW 310
15581: PUSH
15582: LD_VAR 0 1
15586: PPUSH
15587: CALL_OW 310
15591: PPUSH
15592: CALL_OW 247
15596: PUSH
15597: LD_INT 3
15599: EQUAL
15600: AND
15601: IFFALSE 15612
// ComExitBuilding ( i ) ;
15603: LD_VAR 0 1
15607: PPUSH
15608: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
15612: LD_VAR 0 1
15616: PPUSH
15617: LD_INT 10
15619: PPUSH
15620: LD_INT 1
15622: PPUSH
15623: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
15627: LD_VAR 0 1
15631: PPUSH
15632: LD_INT 32
15634: PPUSH
15635: CALL_OW 308
15639: IFFALSE 15650
// RemoveUnit ( i ) ;
15641: LD_VAR 0 1
15645: PPUSH
15646: CALL_OW 64
// end ;
15650: GO 15569
15652: POP
15653: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15654: LD_INT 22
15656: PUSH
15657: LD_INT 8
15659: PUSH
15660: EMPTY
15661: LIST
15662: LIST
15663: PUSH
15664: LD_INT 2
15666: PUSH
15667: LD_INT 21
15669: PUSH
15670: LD_INT 1
15672: PUSH
15673: EMPTY
15674: LIST
15675: LIST
15676: PUSH
15677: LD_INT 33
15679: PUSH
15680: LD_INT 1
15682: PUSH
15683: EMPTY
15684: LIST
15685: LIST
15686: PUSH
15687: EMPTY
15688: LIST
15689: LIST
15690: LIST
15691: PUSH
15692: EMPTY
15693: LIST
15694: LIST
15695: PPUSH
15696: CALL_OW 69
15700: NOT
15701: IFFALSE 15552
// end ;
15703: PPOPN 2
15705: END
// every 0 0$10 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated do var med1 , med2 ;
15706: LD_EXP 4
15710: PUSH
15711: LD_EXP 2
15715: AND
15716: PUSH
15717: LD_EXP 3
15721: AND
15722: PUSH
15723: LD_EXP 5
15727: AND
15728: PUSH
15729: LD_EXP 6
15733: AND
15734: PUSH
15735: LD_EXP 7
15739: AND
15740: PUSH
15741: LD_EXP 8
15745: AND
15746: IFFALSE 17130
15748: GO 15750
15750: DISABLE
15751: LD_INT 0
15753: PPUSH
15754: PPUSH
// begin music_class := 5 ;
15755: LD_ADDR_OWVAR 72
15759: PUSH
15760: LD_INT 5
15762: ST_TO_ADDR
// music_nat := 5 ;
15763: LD_ADDR_OWVAR 71
15767: PUSH
15768: LD_INT 5
15770: ST_TO_ADDR
// if vehicleLostCounter < 3 then
15771: LD_EXP 15
15775: PUSH
15776: LD_INT 3
15778: LESS
15779: IFFALSE 15788
// SetAchievement ( ACH_ECONOMY ) ;
15781: LD_STRING ACH_ECONOMY
15783: PPUSH
15784: CALL_OW 543
// if tick < 60 60$00 then
15788: LD_OWVAR 1
15792: PUSH
15793: LD_INT 126000
15795: LESS
15796: IFFALSE 15812
// begin wait ( 3 ) ;
15798: LD_INT 3
15800: PPUSH
15801: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
15805: LD_STRING ACH_ASPEED_19
15807: PPUSH
15808: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
15812: LD_EXP 17
15816: PPUSH
15817: CALL_OW 87
// InGameOn ;
15821: CALL_OW 8
// DialogueOn ;
15825: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
15829: LD_EXP 17
15833: PPUSH
15834: LD_STRING DEnd-JMM-JMM-1
15836: PPUSH
15837: CALL_OW 88
// if Joan then
15841: LD_EXP 32
15845: IFFALSE 15861
// Say ( Joan , DEnd-JMM-Joan-1 ) else
15847: LD_EXP 32
15851: PPUSH
15852: LD_STRING DEnd-JMM-Joan-1
15854: PPUSH
15855: CALL_OW 88
15859: GO 15905
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
15861: LD_EXP 19
15865: PUSH
15866: LD_EXP 19
15870: PPUSH
15871: CALL_OW 255
15875: PUSH
15876: LD_INT 7
15878: EQUAL
15879: AND
15880: PUSH
15881: LD_EXP 19
15885: PPUSH
15886: CALL_OW 305
15890: AND
15891: IFFALSE 15905
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
15893: LD_EXP 19
15897: PPUSH
15898: LD_STRING DEnd-JMM-Lisa-1
15900: PPUSH
15901: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
15905: LD_EXP 29
15909: PUSH
15910: LD_EXP 29
15914: PPUSH
15915: CALL_OW 305
15919: AND
15920: IFFALSE 15934
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
15922: LD_EXP 29
15926: PPUSH
15927: LD_STRING DEnd-JMM-Frank-1
15929: PPUSH
15930: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
15934: LD_EXP 22
15938: PUSH
15939: LD_EXP 22
15943: PPUSH
15944: CALL_OW 255
15948: PUSH
15949: LD_INT 7
15951: EQUAL
15952: AND
15953: PUSH
15954: LD_EXP 22
15958: PPUSH
15959: CALL_OW 305
15963: AND
15964: IFFALSE 15978
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
15966: LD_EXP 22
15970: PPUSH
15971: LD_STRING DEnd-JMM-Cyrus-1
15973: PPUSH
15974: CALL_OW 88
// if Burlak then
15978: LD_EXP 49
15982: IFFALSE 15996
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
15984: LD_EXP 49
15988: PPUSH
15989: LD_STRING DEnd-JMM-Bur-1
15991: PPUSH
15992: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
15996: LD_EXP 32
16000: PUSH
16001: LD_EXP 19
16005: AND
16006: PUSH
16007: LD_EXP 19
16011: PPUSH
16012: CALL_OW 255
16016: PUSH
16017: LD_INT 7
16019: EQUAL
16020: AND
16021: PUSH
16022: LD_EXP 19
16026: PPUSH
16027: CALL_OW 305
16031: AND
16032: IFFALSE 16046
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
16034: LD_EXP 19
16038: PPUSH
16039: LD_STRING DEnd-Burlak-Lisa-1
16041: PPUSH
16042: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
16046: LD_EXP 50
16050: PUSH
16051: LD_EXP 50
16055: PPUSH
16056: CALL_OW 305
16060: AND
16061: IFFALSE 16075
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
16063: LD_EXP 50
16067: PPUSH
16068: LD_STRING DEnd-JMM-Bel-1
16070: PPUSH
16071: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
16075: LD_EXP 51
16079: PUSH
16080: LD_EXP 51
16084: PPUSH
16085: CALL_OW 305
16089: AND
16090: IFFALSE 16104
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
16092: LD_EXP 51
16096: PPUSH
16097: LD_STRING DEnd-JMM-Gny-1
16099: PPUSH
16100: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
16104: LD_EXP 27
16108: PUSH
16109: LD_EXP 27
16113: PPUSH
16114: CALL_OW 255
16118: PUSH
16119: LD_INT 7
16121: EQUAL
16122: AND
16123: PUSH
16124: LD_EXP 27
16128: PPUSH
16129: CALL_OW 305
16133: AND
16134: IFFALSE 16148
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
16136: LD_EXP 27
16140: PPUSH
16141: LD_STRING DEnd-JMM-Corn-1
16143: PPUSH
16144: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
16148: LD_EXP 20
16152: PUSH
16153: LD_EXP 20
16157: PPUSH
16158: CALL_OW 255
16162: PUSH
16163: LD_INT 7
16165: EQUAL
16166: AND
16167: PUSH
16168: LD_EXP 20
16172: PPUSH
16173: CALL_OW 305
16177: AND
16178: IFFALSE 16192
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
16180: LD_EXP 20
16184: PPUSH
16185: LD_STRING DEnd-JMM-Don-1
16187: PPUSH
16188: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
16192: LD_EXP 21
16196: PUSH
16197: LD_EXP 21
16201: PPUSH
16202: CALL_OW 255
16206: PUSH
16207: LD_INT 7
16209: EQUAL
16210: AND
16211: PUSH
16212: LD_EXP 21
16216: PPUSH
16217: CALL_OW 305
16221: AND
16222: IFFALSE 16236
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
16224: LD_EXP 21
16228: PPUSH
16229: LD_STRING DEnd-JMM-Bobby-1
16231: PPUSH
16232: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
16236: LD_EXP 23
16240: PUSH
16241: LD_EXP 23
16245: PPUSH
16246: CALL_OW 255
16250: PUSH
16251: LD_INT 7
16253: EQUAL
16254: AND
16255: PUSH
16256: LD_EXP 23
16260: PPUSH
16261: CALL_OW 305
16265: AND
16266: IFFALSE 16280
// Say ( Denis , DEnd-JMM-Den-1 ) ;
16268: LD_EXP 23
16272: PPUSH
16273: LD_STRING DEnd-JMM-Den-1
16275: PPUSH
16276: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
16280: LD_EXP 25
16284: PUSH
16285: LD_EXP 25
16289: PPUSH
16290: CALL_OW 255
16294: PUSH
16295: LD_INT 7
16297: EQUAL
16298: AND
16299: PUSH
16300: LD_EXP 25
16304: PPUSH
16305: CALL_OW 305
16309: AND
16310: IFFALSE 16324
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
16312: LD_EXP 25
16316: PPUSH
16317: LD_STRING DEnd-JMM-Glad-1
16319: PPUSH
16320: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
16324: LD_EXP 30
16328: PUSH
16329: LD_EXP 30
16333: PPUSH
16334: CALL_OW 255
16338: PUSH
16339: LD_INT 7
16341: EQUAL
16342: AND
16343: PUSH
16344: LD_EXP 30
16348: PPUSH
16349: CALL_OW 305
16353: AND
16354: IFFALSE 16368
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
16356: LD_EXP 30
16360: PPUSH
16361: LD_STRING DEnd-JMM-Yam-1
16363: PPUSH
16364: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
16368: LD_EXP 24
16372: PUSH
16373: LD_EXP 24
16377: PPUSH
16378: CALL_OW 255
16382: PUSH
16383: LD_INT 7
16385: EQUAL
16386: AND
16387: PUSH
16388: LD_EXP 24
16392: PPUSH
16393: CALL_OW 305
16397: AND
16398: IFFALSE 16412
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
16400: LD_EXP 24
16404: PPUSH
16405: LD_STRING DEnd-JMM-Brown-1
16407: PPUSH
16408: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
16412: LD_EXP 34
16416: PUSH
16417: LD_EXP 34
16421: PPUSH
16422: CALL_OW 255
16426: PUSH
16427: LD_INT 7
16429: EQUAL
16430: AND
16431: PUSH
16432: LD_EXP 34
16436: PPUSH
16437: CALL_OW 305
16441: AND
16442: IFFALSE 16456
// Say ( Connie , DEnd-JMM-Con-1 ) ;
16444: LD_EXP 34
16448: PPUSH
16449: LD_STRING DEnd-JMM-Con-1
16451: PPUSH
16452: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
16456: LD_EXP 28
16460: PUSH
16461: LD_EXP 28
16465: PPUSH
16466: CALL_OW 255
16470: PUSH
16471: LD_INT 7
16473: EQUAL
16474: AND
16475: PUSH
16476: LD_EXP 28
16480: PPUSH
16481: CALL_OW 305
16485: AND
16486: IFFALSE 16500
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
16488: LD_EXP 28
16492: PPUSH
16493: LD_STRING DEnd-JMM-Gary-1
16495: PPUSH
16496: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
16500: LD_EXP 31
16504: PUSH
16505: LD_EXP 18
16509: AND
16510: PUSH
16511: LD_EXP 31
16515: PPUSH
16516: CALL_OW 305
16520: AND
16521: IFFALSE 16535
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
16523: LD_EXP 31
16527: PPUSH
16528: LD_STRING DEnd-JMM-Sim-1
16530: PPUSH
16531: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
16535: LD_EXP 26
16539: PUSH
16540: LD_EXP 26
16544: PPUSH
16545: CALL_OW 255
16549: PUSH
16550: LD_INT 7
16552: EQUAL
16553: AND
16554: PUSH
16555: LD_EXP 26
16559: PPUSH
16560: CALL_OW 305
16564: AND
16565: IFFALSE 16579
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
16567: LD_EXP 26
16571: PPUSH
16572: LD_STRING DEnd-JMM-VanH-1
16574: PPUSH
16575: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
16579: LD_EXP 39
16583: PUSH
16584: LD_EXP 39
16588: PPUSH
16589: CALL_OW 305
16593: AND
16594: IFFALSE 16608
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
16596: LD_EXP 39
16600: PPUSH
16601: LD_STRING DEnd-JMM-Dol-1
16603: PPUSH
16604: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
16608: LD_EXP 43
16612: PUSH
16613: LD_EXP 43
16617: PPUSH
16618: CALL_OW 305
16622: AND
16623: IFFALSE 16637
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
16625: LD_EXP 43
16629: PPUSH
16630: LD_STRING DEnd-JMM-Kap-1
16632: PPUSH
16633: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
16637: LD_EXP 46
16641: PUSH
16642: LD_EXP 46
16646: PPUSH
16647: CALL_OW 305
16651: AND
16652: IFFALSE 16666
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
16654: LD_EXP 46
16658: PPUSH
16659: LD_STRING DEnd-JMM-Kov-1
16661: PPUSH
16662: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
16666: LD_EXP 41
16670: PUSH
16671: LD_EXP 41
16675: PPUSH
16676: CALL_OW 305
16680: AND
16681: IFFALSE 16695
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
16683: LD_EXP 41
16687: PPUSH
16688: LD_STRING DEnd-JMM-Sch-1
16690: PPUSH
16691: CALL_OW 88
// if Titov and IsPlaced ( Titov ) then
16695: LD_EXP 37
16699: PUSH
16700: LD_EXP 37
16704: PPUSH
16705: CALL_OW 305
16709: AND
16710: IFFALSE 16724
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
16712: LD_EXP 37
16716: PPUSH
16717: LD_STRING DEnd-JMM-Tit-1
16719: PPUSH
16720: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
16724: LD_EXP 42
16728: PUSH
16729: LD_EXP 42
16733: PPUSH
16734: CALL_OW 305
16738: AND
16739: IFFALSE 16753
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
16741: LD_EXP 42
16745: PPUSH
16746: LD_STRING DEnd-JMM-Obl-1
16748: PPUSH
16749: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
16753: LD_EXP 44
16757: PUSH
16758: LD_EXP 44
16762: PPUSH
16763: CALL_OW 305
16767: AND
16768: IFFALSE 16782
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
16770: LD_EXP 44
16774: PPUSH
16775: LD_STRING DEnd-JMM-Lip-1
16777: PPUSH
16778: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and Burlak then
16782: LD_EXP 38
16786: PUSH
16787: LD_EXP 38
16791: PPUSH
16792: CALL_OW 305
16796: AND
16797: PUSH
16798: LD_EXP 49
16802: AND
16803: IFFALSE 16817
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
16805: LD_EXP 38
16809: PPUSH
16810: LD_STRING DEnd-Burlak-Fad-1
16812: PPUSH
16813: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
16817: LD_EXP 45
16821: PUSH
16822: LD_EXP 45
16826: PPUSH
16827: CALL_OW 305
16831: AND
16832: IFFALSE 16846
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
16834: LD_EXP 45
16838: PPUSH
16839: LD_STRING DEnd-Burlak-Ptr-1
16841: PPUSH
16842: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
16846: LD_EXP 47
16850: PUSH
16851: LD_EXP 47
16855: PPUSH
16856: CALL_OW 305
16860: AND
16861: IFFALSE 16875
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
16863: LD_EXP 47
16867: PPUSH
16868: LD_STRING DEnd-Burlak-Kuz-1
16870: PPUSH
16871: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and Burlak then
16875: LD_EXP 36
16879: PUSH
16880: LD_EXP 36
16884: PPUSH
16885: CALL_OW 305
16889: AND
16890: PUSH
16891: LD_EXP 49
16895: AND
16896: IFFALSE 16910
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
16898: LD_EXP 36
16902: PPUSH
16903: LD_STRING DEnd-Burlak-Kir-1
16905: PPUSH
16906: CALL_OW 88
// if Burlak then
16910: LD_EXP 49
16914: IFFALSE 16928
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
16916: LD_EXP 17
16920: PPUSH
16921: LD_STRING DEnd-Burlak-JMM-1
16923: PPUSH
16924: CALL_OW 88
// dwait ( 0 0$2 ) ;
16928: LD_INT 70
16930: PPUSH
16931: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
16935: LD_EXP 54
16939: PPUSH
16940: LD_STRING DEnd-Szulc
16942: PPUSH
16943: CALL_OW 94
// dwait ( 0 0$1 ) ;
16947: LD_INT 35
16949: PPUSH
16950: CALL_OW 68
// if IsLive ( Burlak ) then
16954: LD_EXP 49
16958: PPUSH
16959: CALL_OW 300
16963: IFFALSE 16975
// med1 := 1 else
16965: LD_ADDR_VAR 0 1
16969: PUSH
16970: LD_INT 1
16972: ST_TO_ADDR
16973: GO 16984
// med1 := - 1 ;
16975: LD_ADDR_VAR 0 1
16979: PUSH
16980: LD_INT 1
16982: NEG
16983: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
16984: LD_EXP 12
16988: PUSH
16989: LD_EXP 13
16993: AND
16994: PUSH
16995: LD_EXP 14
16999: AND
17000: IFFALSE 17012
// med2 := 1 else
17002: LD_ADDR_VAR 0 2
17006: PUSH
17007: LD_INT 1
17009: ST_TO_ADDR
17010: GO 17021
// med2 := - 1 ;
17012: LD_ADDR_VAR 0 2
17016: PUSH
17017: LD_INT 1
17019: NEG
17020: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
17021: LD_STRING Hero
17023: PPUSH
17024: LD_INT 1
17026: PPUSH
17027: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
17031: LD_STRING Artefact
17033: PPUSH
17034: LD_VAR 0 2
17038: PPUSH
17039: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
17043: LD_STRING ReconcileBurlak
17045: PPUSH
17046: LD_VAR 0 1
17050: PPUSH
17051: CALL_OW 101
// if Difficulty = 3 and med1 = 1 and med2 = 1 then
17055: LD_OWVAR 67
17059: PUSH
17060: LD_INT 3
17062: EQUAL
17063: PUSH
17064: LD_VAR 0 1
17068: PUSH
17069: LD_INT 1
17071: EQUAL
17072: AND
17073: PUSH
17074: LD_VAR 0 2
17078: PUSH
17079: LD_INT 1
17081: EQUAL
17082: AND
17083: IFFALSE 17095
// SetAchievementEX ( ACH_AMER , 19 ) ;
17085: LD_STRING ACH_AMER
17087: PPUSH
17088: LD_INT 19
17090: PPUSH
17091: CALL_OW 564
// GiveMedals ( MAIN ) ;
17095: LD_STRING MAIN
17097: PPUSH
17098: CALL_OW 102
// InGameOff ;
17102: CALL_OW 9
// DialogueOff ;
17106: CALL_OW 7
// music_nat := 1 ;
17110: LD_ADDR_OWVAR 71
17114: PUSH
17115: LD_INT 1
17117: ST_TO_ADDR
// music_class := 4 ;
17118: LD_ADDR_OWVAR 72
17122: PUSH
17123: LD_INT 4
17125: ST_TO_ADDR
// YouWin ;
17126: CALL_OW 103
// end ; end_of_file
17130: PPOPN 2
17132: END
// export function InitNature ; begin
17133: LD_INT 0
17135: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
17136: LD_INT 3
17138: PPUSH
17139: LD_INT 3
17141: PPUSH
17142: LD_INT 2
17144: PPUSH
17145: LD_INT 1
17147: PPUSH
17148: LD_INT 1
17150: PPUSH
17151: LD_INT 0
17153: PPUSH
17154: LD_INT 0
17156: PPUSH
17157: LD_INT 17
17159: PPUSH
17160: LD_INT 0
17162: PPUSH
17163: CALL 85636 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
17167: LD_INT 2
17169: PPUSH
17170: LD_INT 1
17172: PPUSH
17173: LD_INT 1
17175: PPUSH
17176: LD_INT 1
17178: PPUSH
17179: LD_INT 1
17181: PPUSH
17182: LD_INT 0
17184: PPUSH
17185: LD_INT 0
17187: PPUSH
17188: LD_INT 18
17190: PPUSH
17191: LD_INT 0
17193: PPUSH
17194: CALL 85636 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
17198: LD_INT 4
17200: PPUSH
17201: LD_INT 1
17203: PPUSH
17204: LD_INT 2
17206: PPUSH
17207: LD_INT 4
17209: PPUSH
17210: LD_INT 2
17212: PPUSH
17213: LD_INT 1
17215: PPUSH
17216: LD_INT 0
17218: PPUSH
17219: LD_INT 19
17221: PPUSH
17222: LD_INT 0
17224: PPUSH
17225: CALL 85636 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
17229: LD_INT 0
17231: PPUSH
17232: LD_INT 0
17234: PPUSH
17235: LD_INT 0
17237: PPUSH
17238: LD_INT 0
17240: PPUSH
17241: LD_INT 0
17243: PPUSH
17244: LD_INT 0
17246: PPUSH
17247: LD_INT 9
17249: PPUSH
17250: LD_INT 0
17252: PPUSH
17253: LD_INT 20
17255: PPUSH
17256: CALL 85636 0 9
// end ; end_of_file
17260: LD_VAR 0 1
17264: RET
// every 0 0$30 do var time ;
17265: GO 17267
17267: DISABLE
17268: LD_INT 0
17270: PPUSH
// begin time := 0 0$50 ;
17271: LD_ADDR_VAR 0 1
17275: PUSH
17276: LD_INT 1750
17278: ST_TO_ADDR
// repeat wait ( time ) ;
17279: LD_VAR 0 1
17283: PPUSH
17284: CALL_OW 67
// if Prob ( 50 ) then
17288: LD_INT 50
17290: PPUSH
17291: CALL_OW 13
17295: IFFALSE 17324
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
17297: LD_INT 1
17299: PPUSH
17300: LD_INT 5
17302: PPUSH
17303: CALL_OW 12
17307: PPUSH
17308: LD_INT 106
17310: PPUSH
17311: LD_INT 89
17313: PPUSH
17314: LD_INT 45
17316: PPUSH
17317: LD_INT 1
17319: PPUSH
17320: CALL_OW 56
// time := time + 0 0$3 ;
17324: LD_ADDR_VAR 0 1
17328: PUSH
17329: LD_VAR 0 1
17333: PUSH
17334: LD_INT 105
17336: PLUS
17337: ST_TO_ADDR
// if Prob ( 30 ) then
17338: LD_INT 30
17340: PPUSH
17341: CALL_OW 13
17345: IFFALSE 17391
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
17347: LD_INT 525
17349: PPUSH
17350: LD_INT 735
17352: PPUSH
17353: CALL_OW 12
17357: PPUSH
17358: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
17362: LD_INT 1
17364: PPUSH
17365: LD_INT 5
17367: PPUSH
17368: CALL_OW 12
17372: PPUSH
17373: LD_INT 21
17375: PPUSH
17376: LD_INT 26
17378: PPUSH
17379: LD_INT 12
17381: PPUSH
17382: LD_INT 1
17384: PPUSH
17385: CALL_OW 56
// end else
17389: GO 17427
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
17391: LD_INT 700
17393: PPUSH
17394: LD_INT 1225
17396: PPUSH
17397: CALL_OW 12
17401: PPUSH
17402: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
17406: LD_INT 1
17408: PPUSH
17409: LD_INT 5
17411: PPUSH
17412: CALL_OW 12
17416: PPUSH
17417: LD_INT 14
17419: PPUSH
17420: LD_INT 1
17422: PPUSH
17423: CALL_OW 55
// end ; if Prob ( 50 ) then
17427: LD_INT 50
17429: PPUSH
17430: CALL_OW 13
17434: IFFALSE 17480
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
17436: LD_INT 700
17438: PPUSH
17439: LD_INT 1050
17441: PPUSH
17442: CALL_OW 12
17446: PPUSH
17447: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
17451: LD_INT 1
17453: PPUSH
17454: LD_INT 5
17456: PPUSH
17457: CALL_OW 12
17461: PPUSH
17462: LD_INT 181
17464: PPUSH
17465: LD_INT 218
17467: PPUSH
17468: LD_INT 16
17470: PPUSH
17471: LD_INT 1
17473: PPUSH
17474: CALL_OW 56
// end else
17478: GO 17552
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
17480: LD_INT 350
17482: PPUSH
17483: LD_INT 525
17485: PPUSH
17486: CALL_OW 12
17490: PPUSH
17491: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
17495: LD_INT 1
17497: PPUSH
17498: LD_INT 5
17500: PPUSH
17501: CALL_OW 12
17505: PPUSH
17506: LD_INT 13
17508: PPUSH
17509: LD_INT 1
17511: PPUSH
17512: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17516: LD_INT 350
17518: PPUSH
17519: LD_INT 700
17521: PPUSH
17522: CALL_OW 12
17526: PPUSH
17527: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
17531: LD_INT 1
17533: PPUSH
17534: LD_INT 5
17536: PPUSH
17537: CALL_OW 12
17541: PPUSH
17542: LD_INT 33
17544: PPUSH
17545: LD_INT 1
17547: PPUSH
17548: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 ] [ Difficulty ] ) then
17552: LD_INT 65
17554: PUSH
17555: LD_INT 62
17557: PUSH
17558: LD_INT 55
17560: PUSH
17561: EMPTY
17562: LIST
17563: LIST
17564: LIST
17565: PUSH
17566: LD_OWVAR 67
17570: ARRAY
17571: PPUSH
17572: CALL_OW 13
17576: IFFALSE 17622
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
17578: LD_INT 525
17580: PPUSH
17581: LD_INT 875
17583: PPUSH
17584: CALL_OW 12
17588: PPUSH
17589: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17593: LD_INT 1
17595: PPUSH
17596: LD_INT 5
17598: PPUSH
17599: CALL_OW 12
17603: PPUSH
17604: LD_INT 294
17606: PPUSH
17607: LD_INT 211
17609: PPUSH
17610: LD_INT 30
17612: PPUSH
17613: LD_INT 1
17615: PPUSH
17616: CALL_OW 56
// end else
17620: GO 17664
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
17622: LD_INT 420
17624: PPUSH
17625: LD_INT 770
17627: PPUSH
17628: CALL_OW 12
17632: PPUSH
17633: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17637: LD_INT 1
17639: PPUSH
17640: LD_INT 5
17642: PPUSH
17643: CALL_OW 12
17647: PPUSH
17648: LD_INT 294
17650: PPUSH
17651: LD_INT 211
17653: PPUSH
17654: LD_INT 30
17656: PPUSH
17657: LD_INT 1
17659: PPUSH
17660: CALL_OW 56
// end ; if time > 2 2$20 then
17664: LD_VAR 0 1
17668: PUSH
17669: LD_INT 4900
17671: GREATER
17672: IFFALSE 17682
// time := 0 0$50 ;
17674: LD_ADDR_VAR 0 1
17678: PUSH
17679: LD_INT 1750
17681: ST_TO_ADDR
// until false ;
17682: LD_INT 0
17684: IFFALSE 17279
// end ;
17686: PPOPN 1
17688: END
// every 0 0$45 trigger tick < 10 10$00 do
17689: LD_OWVAR 1
17693: PUSH
17694: LD_INT 21000
17696: LESS
17697: IFFALSE 17745
17699: GO 17701
17701: DISABLE
// begin enable ;
17702: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17703: LD_INT 350
17705: PPUSH
17706: LD_INT 700
17708: PPUSH
17709: CALL_OW 12
17713: PPUSH
17714: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
17718: LD_INT 3
17720: PPUSH
17721: LD_INT 5
17723: PPUSH
17724: CALL_OW 12
17728: PPUSH
17729: LD_INT 181
17731: PPUSH
17732: LD_INT 13
17734: PPUSH
17735: LD_INT 20
17737: PPUSH
17738: LD_INT 1
17740: PPUSH
17741: CALL_OW 56
// end ; end_of_file
17745: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
17746: LD_INT 0
17748: PPUSH
// SetArtifactRes ( 7 , true ) ;
17749: LD_INT 7
17751: PPUSH
17752: LD_INT 1
17754: PPUSH
17755: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
17759: LD_ADDR_EXP 62
17763: PUSH
17764: EMPTY
17765: PUSH
17766: EMPTY
17767: PUSH
17768: EMPTY
17769: PUSH
17770: EMPTY
17771: LIST
17772: LIST
17773: LIST
17774: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
17775: LD_ADDR_EXP 63
17779: PUSH
17780: LD_INT 1050
17782: PUSH
17783: LD_OWVAR 67
17787: MUL
17788: PUSH
17789: LD_INT 2800
17791: PUSH
17792: LD_OWVAR 67
17796: MUL
17797: PUSH
17798: LD_INT 1
17800: NEG
17801: PUSH
17802: EMPTY
17803: LIST
17804: LIST
17805: LIST
17806: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
17807: LD_ADDR_EXP 64
17811: PUSH
17812: LD_INT 10
17814: PUSH
17815: LD_INT 35
17817: PUSH
17818: LD_INT 100
17820: PUSH
17821: EMPTY
17822: LIST
17823: LIST
17824: LIST
17825: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
17826: LD_ADDR_EXP 65
17830: PUSH
17831: LD_INT 0
17833: PUSH
17834: LD_INT 0
17836: PUSH
17837: LD_INT 0
17839: PUSH
17840: EMPTY
17841: LIST
17842: LIST
17843: LIST
17844: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
17845: LD_ADDR_EXP 67
17849: PUSH
17850: LD_INT 300
17852: PUSH
17853: LD_INT 500
17855: PUSH
17856: LD_INT 800
17858: PUSH
17859: EMPTY
17860: LIST
17861: LIST
17862: LIST
17863: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
17864: LD_ADDR_EXP 68
17868: PUSH
17869: LD_INT 0
17871: PUSH
17872: LD_INT 0
17874: PUSH
17875: LD_INT 0
17877: PUSH
17878: EMPTY
17879: LIST
17880: LIST
17881: LIST
17882: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
17883: LD_ADDR_EXP 69
17887: PUSH
17888: LD_INT 0
17890: PUSH
17891: LD_INT 0
17893: PUSH
17894: LD_INT 0
17896: PUSH
17897: EMPTY
17898: LIST
17899: LIST
17900: LIST
17901: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
17902: LD_ADDR_EXP 66
17906: PUSH
17907: LD_INT 0
17909: PUSH
17910: LD_INT 0
17912: PUSH
17913: LD_INT 0
17915: PUSH
17916: EMPTY
17917: LIST
17918: LIST
17919: LIST
17920: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
17921: LD_ADDR_EXP 70
17925: PUSH
17926: LD_INT 4
17928: PUSH
17929: LD_INT 3
17931: PUSH
17932: LD_INT 1
17934: PUSH
17935: EMPTY
17936: LIST
17937: LIST
17938: LIST
17939: PUSH
17940: LD_INT 5
17942: PUSH
17943: LD_INT 4
17945: PUSH
17946: LD_INT 2
17948: PUSH
17949: EMPTY
17950: LIST
17951: LIST
17952: LIST
17953: PUSH
17954: LD_INT 6
17956: PUSH
17957: LD_INT 3
17959: PUSH
17960: LD_INT 3
17962: PUSH
17963: EMPTY
17964: LIST
17965: LIST
17966: LIST
17967: PUSH
17968: EMPTY
17969: LIST
17970: LIST
17971: LIST
17972: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
17973: LD_ADDR_EXP 71
17977: PUSH
17978: LD_INT 0
17980: PUSH
17981: LD_INT 0
17983: PUSH
17984: LD_INT 0
17986: PUSH
17987: EMPTY
17988: LIST
17989: LIST
17990: LIST
17991: ST_TO_ADDR
// end ;
17992: LD_VAR 0 1
17996: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
17997: LD_INT 24
17999: PPUSH
18000: LD_INT 7
18002: PPUSH
18003: CALL_OW 321
18007: PUSH
18008: LD_INT 2
18010: EQUAL
18011: IFFALSE 18937
18013: GO 18015
18015: DISABLE
18016: LD_INT 0
18018: PPUSH
18019: PPUSH
18020: PPUSH
18021: PPUSH
18022: PPUSH
// begin enable ;
18023: ENABLE
// for i = 1 to 3 do
18024: LD_ADDR_VAR 0 1
18028: PUSH
18029: DOUBLE
18030: LD_INT 1
18032: DEC
18033: ST_TO_ADDR
18034: LD_INT 3
18036: PUSH
18037: FOR_TO
18038: IFFALSE 18935
// begin pos := FindArtifact ( i + 2 ) ;
18040: LD_ADDR_VAR 0 2
18044: PUSH
18045: LD_VAR 0 1
18049: PUSH
18050: LD_INT 2
18052: PLUS
18053: PPUSH
18054: CALL_OW 469
18058: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
18059: LD_ADDR_EXP 62
18063: PUSH
18064: LD_EXP 62
18068: PPUSH
18069: LD_VAR 0 1
18073: PPUSH
18074: LD_VAR 0 2
18078: PPUSH
18079: CALL_OW 1
18083: ST_TO_ADDR
// if pos then
18084: LD_VAR 0 2
18088: IFFALSE 18796
// begin case i of 1 :
18090: LD_VAR 0 1
18094: PUSH
18095: LD_INT 1
18097: DOUBLE
18098: EQUAL
18099: IFTRUE 18103
18101: GO 18180
18103: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
18104: LD_ADDR_VAR 0 4
18108: PUSH
18109: LD_INT 22
18111: PUSH
18112: LD_INT 7
18114: PUSH
18115: EMPTY
18116: LIST
18117: LIST
18118: PUSH
18119: LD_INT 23
18121: PUSH
18122: LD_INT 1
18124: PUSH
18125: EMPTY
18126: LIST
18127: LIST
18128: PUSH
18129: LD_INT 2
18131: PUSH
18132: LD_INT 30
18134: PUSH
18135: LD_INT 8
18137: PUSH
18138: EMPTY
18139: LIST
18140: LIST
18141: PUSH
18142: LD_INT 30
18144: PUSH
18145: LD_INT 7
18147: PUSH
18148: EMPTY
18149: LIST
18150: LIST
18151: PUSH
18152: LD_INT 30
18154: PUSH
18155: LD_INT 11
18157: PUSH
18158: EMPTY
18159: LIST
18160: LIST
18161: PUSH
18162: EMPTY
18163: LIST
18164: LIST
18165: LIST
18166: LIST
18167: PUSH
18168: EMPTY
18169: LIST
18170: LIST
18171: LIST
18172: PPUSH
18173: CALL_OW 69
18177: ST_TO_ADDR
18178: GO 18288
18180: LD_INT 2
18182: DOUBLE
18183: EQUAL
18184: IFTRUE 18188
18186: GO 18265
18188: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
18189: LD_ADDR_VAR 0 4
18193: PUSH
18194: LD_INT 22
18196: PUSH
18197: LD_INT 7
18199: PUSH
18200: EMPTY
18201: LIST
18202: LIST
18203: PUSH
18204: LD_INT 23
18206: PUSH
18207: LD_INT 3
18209: PUSH
18210: EMPTY
18211: LIST
18212: LIST
18213: PUSH
18214: LD_INT 2
18216: PUSH
18217: LD_INT 30
18219: PUSH
18220: LD_INT 8
18222: PUSH
18223: EMPTY
18224: LIST
18225: LIST
18226: PUSH
18227: LD_INT 30
18229: PUSH
18230: LD_INT 7
18232: PUSH
18233: EMPTY
18234: LIST
18235: LIST
18236: PUSH
18237: LD_INT 30
18239: PUSH
18240: LD_INT 11
18242: PUSH
18243: EMPTY
18244: LIST
18245: LIST
18246: PUSH
18247: EMPTY
18248: LIST
18249: LIST
18250: LIST
18251: LIST
18252: PUSH
18253: EMPTY
18254: LIST
18255: LIST
18256: LIST
18257: PPUSH
18258: CALL_OW 69
18262: ST_TO_ADDR
18263: GO 18288
18265: LD_INT 3
18267: DOUBLE
18268: EQUAL
18269: IFTRUE 18273
18271: GO 18287
18273: POP
// labs := [ alien ] ; end ;
18274: LD_ADDR_VAR 0 4
18278: PUSH
18279: LD_INT 1
18281: PUSH
18282: EMPTY
18283: LIST
18284: ST_TO_ADDR
18285: GO 18288
18287: POP
// if not labs then
18288: LD_VAR 0 4
18292: NOT
18293: IFFALSE 18297
// continue ;
18295: GO 18037
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
18297: LD_ADDR_VAR 0 5
18301: PUSH
18302: LD_VAR 0 4
18306: PPUSH
18307: LD_EXP 62
18311: PUSH
18312: LD_VAR 0 1
18316: ARRAY
18317: PUSH
18318: LD_INT 1
18320: ARRAY
18321: PPUSH
18322: LD_EXP 62
18326: PUSH
18327: LD_VAR 0 1
18331: ARRAY
18332: PUSH
18333: LD_INT 2
18335: ARRAY
18336: PPUSH
18337: CALL_OW 73
18341: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
18342: LD_VAR 0 5
18346: NOT
18347: PUSH
18348: LD_VAR 0 5
18352: PUSH
18353: LD_EXP 69
18357: PUSH
18358: LD_VAR 0 1
18362: ARRAY
18363: NONEQUAL
18364: OR
18365: IFFALSE 18470
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18367: LD_INT 7
18369: PPUSH
18370: LD_EXP 70
18374: PUSH
18375: LD_VAR 0 1
18379: ARRAY
18380: PUSH
18381: LD_INT 3
18383: ARRAY
18384: PPUSH
18385: LD_INT 0
18387: PPUSH
18388: LD_EXP 69
18392: PUSH
18393: LD_VAR 0 1
18397: ARRAY
18398: PPUSH
18399: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18403: LD_INT 7
18405: PPUSH
18406: LD_EXP 70
18410: PUSH
18411: LD_VAR 0 1
18415: ARRAY
18416: PUSH
18417: LD_INT 1
18419: ARRAY
18420: PPUSH
18421: LD_INT 0
18423: PPUSH
18424: LD_EXP 69
18428: PUSH
18429: LD_VAR 0 1
18433: ARRAY
18434: PPUSH
18435: CALL_OW 468
// if nearestLab then
18439: LD_VAR 0 5
18443: IFFALSE 18470
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
18445: LD_ADDR_EXP 69
18449: PUSH
18450: LD_EXP 69
18454: PPUSH
18455: LD_VAR 0 1
18459: PPUSH
18460: LD_VAR 0 5
18464: PPUSH
18465: CALL_OW 1
18469: ST_TO_ADDR
// end ; if not nearestLab then
18470: LD_VAR 0 5
18474: NOT
18475: IFFALSE 18479
// continue ;
18477: GO 18037
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
18479: LD_VAR 0 5
18483: PPUSH
18484: LD_EXP 62
18488: PUSH
18489: LD_VAR 0 1
18493: ARRAY
18494: PUSH
18495: LD_INT 1
18497: ARRAY
18498: PPUSH
18499: LD_EXP 62
18503: PUSH
18504: LD_VAR 0 1
18508: ARRAY
18509: PUSH
18510: LD_INT 2
18512: ARRAY
18513: PPUSH
18514: CALL_OW 297
18518: PUSH
18519: LD_INT 8
18521: LESS
18522: IFFALSE 18719
// begin if not artifactsResearched [ i ] then
18524: LD_EXP 65
18528: PUSH
18529: LD_VAR 0 1
18533: ARRAY
18534: NOT
18535: IFFALSE 18616
// begin if BuildingStatus ( nearestLab ) = bs_idle then
18537: LD_VAR 0 5
18541: PPUSH
18542: CALL_OW 461
18546: PUSH
18547: LD_INT 2
18549: EQUAL
18550: IFFALSE 18584
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
18552: LD_INT 7
18554: PPUSH
18555: LD_EXP 70
18559: PUSH
18560: LD_VAR 0 1
18564: ARRAY
18565: PUSH
18566: LD_INT 3
18568: ARRAY
18569: PPUSH
18570: LD_INT 2
18572: PPUSH
18573: LD_VAR 0 5
18577: PPUSH
18578: CALL_OW 468
18582: GO 18614
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
18584: LD_INT 7
18586: PPUSH
18587: LD_EXP 70
18591: PUSH
18592: LD_VAR 0 1
18596: ARRAY
18597: PUSH
18598: LD_INT 3
18600: ARRAY
18601: PPUSH
18602: LD_INT 1
18604: PPUSH
18605: LD_VAR 0 5
18609: PPUSH
18610: CALL_OW 468
// end else
18614: GO 18717
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
18616: LD_VAR 0 5
18620: PPUSH
18621: CALL_OW 461
18625: PUSH
18626: LD_INT 2
18628: EQUAL
18629: PUSH
18630: LD_EXP 71
18634: PUSH
18635: LD_VAR 0 1
18639: ARRAY
18640: AND
18641: IFFALSE 18687
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
18643: LD_INT 7
18645: PPUSH
18646: LD_EXP 70
18650: PUSH
18651: LD_VAR 0 1
18655: ARRAY
18656: PUSH
18657: LD_INT 1
18659: ARRAY
18660: PPUSH
18661: LD_EXP 70
18665: PUSH
18666: LD_VAR 0 1
18670: ARRAY
18671: PUSH
18672: LD_INT 2
18674: ARRAY
18675: PPUSH
18676: LD_VAR 0 5
18680: PPUSH
18681: CALL_OW 468
18685: GO 18717
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
18687: LD_INT 7
18689: PPUSH
18690: LD_EXP 70
18694: PUSH
18695: LD_VAR 0 1
18699: ARRAY
18700: PUSH
18701: LD_INT 1
18703: ARRAY
18704: PPUSH
18705: LD_INT 1
18707: PPUSH
18708: LD_VAR 0 5
18712: PPUSH
18713: CALL_OW 468
// end else
18717: GO 18794
// begin if not artifactsResearched [ i ] then
18719: LD_EXP 65
18723: PUSH
18724: LD_VAR 0 1
18728: ARRAY
18729: NOT
18730: IFFALSE 18764
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
18732: LD_INT 7
18734: PPUSH
18735: LD_EXP 70
18739: PUSH
18740: LD_VAR 0 1
18744: ARRAY
18745: PUSH
18746: LD_INT 3
18748: ARRAY
18749: PPUSH
18750: LD_INT 0
18752: PPUSH
18753: LD_VAR 0 5
18757: PPUSH
18758: CALL_OW 468
18762: GO 18794
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
18764: LD_INT 7
18766: PPUSH
18767: LD_EXP 70
18771: PUSH
18772: LD_VAR 0 1
18776: ARRAY
18777: PUSH
18778: LD_INT 1
18780: ARRAY
18781: PPUSH
18782: LD_INT 0
18784: PPUSH
18785: LD_VAR 0 5
18789: PPUSH
18790: CALL_OW 468
// end ; end else
18794: GO 18933
// begin if not artifactsLabs [ i ] then
18796: LD_EXP 69
18800: PUSH
18801: LD_VAR 0 1
18805: ARRAY
18806: NOT
18807: IFFALSE 18811
// continue ;
18809: GO 18037
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18811: LD_INT 7
18813: PPUSH
18814: LD_EXP 70
18818: PUSH
18819: LD_VAR 0 1
18823: ARRAY
18824: PUSH
18825: LD_INT 3
18827: ARRAY
18828: PPUSH
18829: LD_INT 0
18831: PPUSH
18832: LD_EXP 69
18836: PUSH
18837: LD_VAR 0 1
18841: ARRAY
18842: PPUSH
18843: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18847: LD_INT 7
18849: PPUSH
18850: LD_EXP 70
18854: PUSH
18855: LD_VAR 0 1
18859: ARRAY
18860: PUSH
18861: LD_INT 1
18863: ARRAY
18864: PPUSH
18865: LD_INT 0
18867: PPUSH
18868: LD_EXP 69
18872: PUSH
18873: LD_VAR 0 1
18877: ARRAY
18878: PPUSH
18879: CALL_OW 468
// if artifactsLabsWorking [ i ] then
18883: LD_EXP 66
18887: PUSH
18888: LD_VAR 0 1
18892: ARRAY
18893: IFFALSE 18933
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
18895: LD_ADDR_EXP 66
18899: PUSH
18900: LD_EXP 66
18904: PPUSH
18905: LD_VAR 0 1
18909: PPUSH
18910: LD_INT 0
18912: PPUSH
18913: CALL_OW 1
18917: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
18918: LD_EXP 69
18922: PUSH
18923: LD_VAR 0 1
18927: ARRAY
18928: PPUSH
18929: CALL_OW 127
// end ; end ; end ;
18933: GO 18037
18935: POP
18936: POP
// end ;
18937: PPOPN 5
18939: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
18940: LD_INT 0
18942: PPUSH
18943: PPUSH
18944: PPUSH
18945: PPUSH
18946: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
18947: LD_VAR 0 2
18951: PUSH
18952: LD_EXP 70
18956: PUSH
18957: LD_INT 1
18959: ARRAY
18960: PUSH
18961: LD_INT 3
18963: ARRAY
18964: EQUAL
18965: IFFALSE 19088
// begin lab := artifactsLabs [ 1 ] ;
18967: LD_ADDR_VAR 0 6
18971: PUSH
18972: LD_EXP 69
18976: PUSH
18977: LD_INT 1
18979: ARRAY
18980: ST_TO_ADDR
// if not lab then
18981: LD_VAR 0 6
18985: NOT
18986: IFFALSE 18990
// exit ;
18988: GO 20068
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
18990: LD_VAR 0 6
18994: PPUSH
18995: LD_EXP 67
18999: PUSH
19000: LD_INT 1
19002: ARRAY
19003: PPUSH
19004: LD_INT 1
19006: PPUSH
19007: CALL_OW 486
// if artifactsResProgress [ 1 ] then
19011: LD_EXP 68
19015: PUSH
19016: LD_INT 1
19018: ARRAY
19019: IFFALSE 19039
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
19021: LD_VAR 0 6
19025: PPUSH
19026: LD_EXP 68
19030: PUSH
19031: LD_INT 1
19033: ARRAY
19034: PPUSH
19035: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
19039: LD_ADDR_EXP 66
19043: PUSH
19044: LD_EXP 66
19048: PPUSH
19049: LD_INT 1
19051: PPUSH
19052: LD_INT 1
19054: PPUSH
19055: CALL_OW 1
19059: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
19060: LD_INT 7
19062: PPUSH
19063: LD_EXP 70
19067: PUSH
19068: LD_INT 1
19070: ARRAY
19071: PUSH
19072: LD_INT 3
19074: ARRAY
19075: PPUSH
19076: LD_INT 0
19078: PPUSH
19079: LD_VAR 0 6
19083: PPUSH
19084: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
19088: LD_VAR 0 2
19092: PUSH
19093: LD_EXP 70
19097: PUSH
19098: LD_INT 2
19100: ARRAY
19101: PUSH
19102: LD_INT 3
19104: ARRAY
19105: EQUAL
19106: IFFALSE 19229
// begin lab := artifactsLabs [ 2 ] ;
19108: LD_ADDR_VAR 0 6
19112: PUSH
19113: LD_EXP 69
19117: PUSH
19118: LD_INT 2
19120: ARRAY
19121: ST_TO_ADDR
// if not lab then
19122: LD_VAR 0 6
19126: NOT
19127: IFFALSE 19131
// exit ;
19129: GO 20068
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
19131: LD_VAR 0 6
19135: PPUSH
19136: LD_EXP 67
19140: PUSH
19141: LD_INT 2
19143: ARRAY
19144: PPUSH
19145: LD_INT 1
19147: PPUSH
19148: CALL_OW 486
// if artifactsResProgress [ 2 ] then
19152: LD_EXP 68
19156: PUSH
19157: LD_INT 2
19159: ARRAY
19160: IFFALSE 19180
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
19162: LD_VAR 0 6
19166: PPUSH
19167: LD_EXP 68
19171: PUSH
19172: LD_INT 2
19174: ARRAY
19175: PPUSH
19176: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
19180: LD_ADDR_EXP 66
19184: PUSH
19185: LD_EXP 66
19189: PPUSH
19190: LD_INT 2
19192: PPUSH
19193: LD_INT 1
19195: PPUSH
19196: CALL_OW 1
19200: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
19201: LD_INT 7
19203: PPUSH
19204: LD_EXP 70
19208: PUSH
19209: LD_INT 2
19211: ARRAY
19212: PUSH
19213: LD_INT 3
19215: ARRAY
19216: PPUSH
19217: LD_INT 0
19219: PPUSH
19220: LD_VAR 0 6
19224: PPUSH
19225: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
19229: LD_VAR 0 2
19233: PUSH
19234: LD_EXP 70
19238: PUSH
19239: LD_INT 3
19241: ARRAY
19242: PUSH
19243: LD_INT 3
19245: ARRAY
19246: EQUAL
19247: IFFALSE 19370
// begin lab := artifactsLabs [ 3 ] ;
19249: LD_ADDR_VAR 0 6
19253: PUSH
19254: LD_EXP 69
19258: PUSH
19259: LD_INT 3
19261: ARRAY
19262: ST_TO_ADDR
// if not lab then
19263: LD_VAR 0 6
19267: NOT
19268: IFFALSE 19272
// exit ;
19270: GO 20068
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
19272: LD_VAR 0 6
19276: PPUSH
19277: LD_EXP 67
19281: PUSH
19282: LD_INT 3
19284: ARRAY
19285: PPUSH
19286: LD_INT 1
19288: PPUSH
19289: CALL_OW 486
// if artifactsResProgress [ 3 ] then
19293: LD_EXP 68
19297: PUSH
19298: LD_INT 3
19300: ARRAY
19301: IFFALSE 19321
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
19303: LD_VAR 0 6
19307: PPUSH
19308: LD_EXP 68
19312: PUSH
19313: LD_INT 3
19315: ARRAY
19316: PPUSH
19317: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
19321: LD_ADDR_EXP 66
19325: PUSH
19326: LD_EXP 66
19330: PPUSH
19331: LD_INT 3
19333: PPUSH
19334: LD_INT 1
19336: PPUSH
19337: CALL_OW 1
19341: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
19342: LD_INT 7
19344: PPUSH
19345: LD_EXP 70
19349: PUSH
19350: LD_INT 3
19352: ARRAY
19353: PUSH
19354: LD_INT 3
19356: ARRAY
19357: PPUSH
19358: LD_INT 0
19360: PPUSH
19361: LD_VAR 0 6
19365: PPUSH
19366: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
19370: LD_VAR 0 2
19374: PUSH
19375: LD_EXP 70
19379: PUSH
19380: LD_INT 1
19382: ARRAY
19383: PUSH
19384: LD_INT 1
19386: ARRAY
19387: EQUAL
19388: IFFALSE 19546
// begin lab := artifactsLabs [ 1 ] ;
19390: LD_ADDR_VAR 0 6
19394: PUSH
19395: LD_EXP 69
19399: PUSH
19400: LD_INT 1
19402: ARRAY
19403: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
19404: LD_VAR 0 6
19408: PPUSH
19409: CALL_OW 274
19413: PPUSH
19414: CALL 93817 0 1
19418: PUSH
19419: LD_INT 3
19421: ARRAY
19422: PUSH
19423: LD_EXP 64
19427: PUSH
19428: LD_INT 1
19430: ARRAY
19431: LESS
19432: IFFALSE 19446
// begin HintSpec ( ArtifactCost , 2 ) ;
19434: LD_STRING ArtifactCost
19436: PPUSH
19437: LD_INT 2
19439: PPUSH
19440: CALL_OW 338
// exit ;
19444: GO 20068
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
19446: LD_ADDR_EXP 71
19450: PUSH
19451: LD_EXP 71
19455: PPUSH
19456: LD_INT 1
19458: PPUSH
19459: LD_INT 0
19461: PPUSH
19462: CALL_OW 1
19466: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
19467: LD_VAR 0 3
19471: PPUSH
19472: LD_VAR 0 4
19476: PPUSH
19477: LD_INT 7
19479: PPUSH
19480: LD_INT 12
19482: NEG
19483: PPUSH
19484: CALL_OW 330
// wait ( 0 0$30 ) ;
19488: LD_INT 1050
19490: PPUSH
19491: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
19495: LD_VAR 0 3
19499: PPUSH
19500: LD_VAR 0 4
19504: PPUSH
19505: LD_INT 7
19507: PPUSH
19508: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
19512: LD_EXP 63
19516: PUSH
19517: LD_INT 1
19519: ARRAY
19520: PPUSH
19521: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
19525: LD_ADDR_EXP 71
19529: PUSH
19530: LD_EXP 71
19534: PPUSH
19535: LD_INT 1
19537: PPUSH
19538: LD_INT 1
19540: PPUSH
19541: CALL_OW 1
19545: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
19546: LD_VAR 0 2
19550: PUSH
19551: LD_EXP 70
19555: PUSH
19556: LD_INT 2
19558: ARRAY
19559: PUSH
19560: LD_INT 1
19562: ARRAY
19563: EQUAL
19564: IFFALSE 19801
// begin lab := artifactsLabs [ 2 ] ;
19566: LD_ADDR_VAR 0 6
19570: PUSH
19571: LD_EXP 69
19575: PUSH
19576: LD_INT 2
19578: ARRAY
19579: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] , [ f_btype , b_ext_siberium ] ] ] ) then
19580: LD_VAR 0 3
19584: PUSH
19585: LD_INT 81
19587: PUSH
19588: LD_INT 7
19590: PUSH
19591: EMPTY
19592: LIST
19593: LIST
19594: PUSH
19595: LD_INT 2
19597: PUSH
19598: LD_INT 32
19600: PUSH
19601: LD_INT 3
19603: PUSH
19604: EMPTY
19605: LIST
19606: LIST
19607: PUSH
19608: LD_INT 30
19610: PUSH
19611: LD_INT 28
19613: PUSH
19614: EMPTY
19615: LIST
19616: LIST
19617: PUSH
19618: LD_INT 30
19620: PUSH
19621: LD_INT 30
19623: PUSH
19624: EMPTY
19625: LIST
19626: LIST
19627: PUSH
19628: LD_INT 35
19630: PUSH
19631: LD_INT 49
19633: PUSH
19634: EMPTY
19635: LIST
19636: LIST
19637: PUSH
19638: LD_INT 34
19640: PUSH
19641: LD_INT 49
19643: PUSH
19644: EMPTY
19645: LIST
19646: LIST
19647: PUSH
19648: LD_INT 30
19650: PUSH
19651: LD_INT 21
19653: PUSH
19654: EMPTY
19655: LIST
19656: LIST
19657: PUSH
19658: EMPTY
19659: LIST
19660: LIST
19661: LIST
19662: LIST
19663: LIST
19664: LIST
19665: LIST
19666: PUSH
19667: EMPTY
19668: LIST
19669: LIST
19670: PPUSH
19671: CALL_OW 69
19675: IN
19676: NOT
19677: IFFALSE 19681
// exit ;
19679: GO 20068
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
19681: LD_VAR 0 6
19685: PPUSH
19686: CALL_OW 274
19690: PPUSH
19691: CALL 93817 0 1
19695: PUSH
19696: LD_INT 3
19698: ARRAY
19699: PUSH
19700: LD_EXP 64
19704: PUSH
19705: LD_INT 2
19707: ARRAY
19708: LESS
19709: IFFALSE 19723
// begin HintSpec ( ArtifactCost , 2 ) ;
19711: LD_STRING ArtifactCost
19713: PPUSH
19714: LD_INT 2
19716: PPUSH
19717: CALL_OW 338
// exit ;
19721: GO 20068
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
19723: LD_ADDR_EXP 71
19727: PUSH
19728: LD_EXP 71
19732: PPUSH
19733: LD_INT 2
19735: PPUSH
19736: LD_INT 0
19738: PPUSH
19739: CALL_OW 1
19743: ST_TO_ADDR
// KillUnit ( x ) ;
19744: LD_VAR 0 3
19748: PPUSH
19749: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
19753: LD_ADDR_EXP 16
19757: PUSH
19758: LD_EXP 16
19762: PUSH
19763: LD_INT 1
19765: PLUS
19766: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
19767: LD_EXP 63
19771: PUSH
19772: LD_INT 2
19774: ARRAY
19775: PPUSH
19776: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
19780: LD_ADDR_EXP 71
19784: PUSH
19785: LD_EXP 71
19789: PPUSH
19790: LD_INT 2
19792: PPUSH
19793: LD_INT 1
19795: PPUSH
19796: CALL_OW 1
19800: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
19801: LD_VAR 0 2
19805: PUSH
19806: LD_EXP 70
19810: PUSH
19811: LD_INT 3
19813: ARRAY
19814: PUSH
19815: LD_INT 1
19817: ARRAY
19818: EQUAL
19819: IFFALSE 20068
// begin lab := artifactsLabs [ 3 ] ;
19821: LD_ADDR_VAR 0 6
19825: PUSH
19826: LD_EXP 69
19830: PUSH
19831: LD_INT 3
19833: ARRAY
19834: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
19835: LD_VAR 0 6
19839: PPUSH
19840: CALL_OW 274
19844: PPUSH
19845: CALL 93817 0 1
19849: PUSH
19850: LD_INT 3
19852: ARRAY
19853: PUSH
19854: LD_EXP 64
19858: PUSH
19859: LD_INT 3
19861: ARRAY
19862: LESS
19863: IFFALSE 19877
// begin HintSpec ( ArtifactCost , 2 ) ;
19865: LD_STRING ArtifactCost
19867: PPUSH
19868: LD_INT 2
19870: PPUSH
19871: CALL_OW 338
// exit ;
19875: GO 20068
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
19877: LD_INT 37
19879: PPUSH
19880: LD_INT 1
19882: PPUSH
19883: CALL_OW 424
// time := 0 0$30 ;
19887: LD_ADDR_VAR 0 7
19891: PUSH
19892: LD_INT 1050
19894: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
19895: LD_ADDR_EXP 71
19899: PUSH
19900: LD_EXP 71
19904: PPUSH
19905: LD_INT 3
19907: PPUSH
19908: LD_INT 0
19910: PPUSH
19911: CALL_OW 1
19915: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
19916: LD_ADDR_OWVAR 47
19920: PUSH
19921: LD_STRING #Am15a-1
19923: PUSH
19924: LD_VAR 0 7
19928: PUSH
19929: EMPTY
19930: LIST
19931: LIST
19932: ST_TO_ADDR
// wait ( 0 0$1 ) ;
19933: LD_INT 35
19935: PPUSH
19936: CALL_OW 67
// time := time - 0 0$1 ;
19940: LD_ADDR_VAR 0 7
19944: PUSH
19945: LD_VAR 0 7
19949: PUSH
19950: LD_INT 35
19952: MINUS
19953: ST_TO_ADDR
// until time = 0 0$00 ;
19954: LD_VAR 0 7
19958: PUSH
19959: LD_INT 0
19961: EQUAL
19962: IFFALSE 19916
// display_strings :=  ;
19964: LD_ADDR_OWVAR 47
19968: PUSH
19969: LD_STRING 
19971: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
19972: LD_INT 37
19974: PPUSH
19975: LD_INT 0
19977: PPUSH
19978: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
19982: LD_ADDR_VAR 0 8
19986: PUSH
19987: LD_INT 37
19989: PPUSH
19990: LD_INT 3
19992: PUSH
19993: LD_INT 21
19995: PUSH
19996: LD_INT 3
19998: PUSH
19999: EMPTY
20000: LIST
20001: LIST
20002: PUSH
20003: EMPTY
20004: LIST
20005: LIST
20006: PPUSH
20007: CALL_OW 70
20011: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
20012: LD_VAR 0 3
20016: PPUSH
20017: LD_VAR 0 4
20021: PPUSH
20022: CALL_OW 84
// for un in list do
20026: LD_ADDR_VAR 0 9
20030: PUSH
20031: LD_VAR 0 8
20035: PUSH
20036: FOR_IN
20037: IFFALSE 20066
// TeleportUnit ( un , x , y , 12 , true ) ;
20039: LD_VAR 0 9
20043: PPUSH
20044: LD_VAR 0 3
20048: PPUSH
20049: LD_VAR 0 4
20053: PPUSH
20054: LD_INT 12
20056: PPUSH
20057: LD_INT 1
20059: PPUSH
20060: CALL_OW 483
20064: GO 20036
20066: POP
20067: POP
// end ; end ;
20068: PPOPN 9
20070: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
20071: LD_INT 0
20073: PPUSH
20074: PPUSH
// begin labNum := 0 ;
20075: LD_ADDR_VAR 0 4
20079: PUSH
20080: LD_INT 0
20082: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20083: LD_ADDR_VAR 0 3
20087: PUSH
20088: DOUBLE
20089: LD_INT 1
20091: DEC
20092: ST_TO_ADDR
20093: LD_EXP 69
20097: PUSH
20098: FOR_TO
20099: IFFALSE 20133
// if artifactsLabs [ i ] = lab then
20101: LD_EXP 69
20105: PUSH
20106: LD_VAR 0 3
20110: ARRAY
20111: PUSH
20112: LD_VAR 0 1
20116: EQUAL
20117: IFFALSE 20131
// begin labNum := i ;
20119: LD_ADDR_VAR 0 4
20123: PUSH
20124: LD_VAR 0 3
20128: ST_TO_ADDR
// break ;
20129: GO 20133
// end ;
20131: GO 20098
20133: POP
20134: POP
// if not labNum then
20135: LD_VAR 0 4
20139: NOT
20140: IFFALSE 20144
// exit ;
20142: GO 20222
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
20144: LD_INT 7
20146: PPUSH
20147: LD_EXP 70
20151: PUSH
20152: LD_VAR 0 4
20156: ARRAY
20157: PUSH
20158: LD_INT 3
20160: ARRAY
20161: PPUSH
20162: LD_INT 2
20164: PPUSH
20165: LD_VAR 0 1
20169: PPUSH
20170: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
20174: LD_ADDR_EXP 68
20178: PUSH
20179: LD_EXP 68
20183: PPUSH
20184: LD_VAR 0 4
20188: PPUSH
20189: LD_VAR 0 2
20193: PPUSH
20194: CALL_OW 1
20198: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
20199: LD_ADDR_EXP 66
20203: PUSH
20204: LD_EXP 66
20208: PPUSH
20209: LD_VAR 0 4
20213: PPUSH
20214: LD_INT 0
20216: PPUSH
20217: CALL_OW 1
20221: ST_TO_ADDR
// end ;
20222: PPOPN 4
20224: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
20225: LD_INT 0
20227: PPUSH
20228: PPUSH
// begin labNum := 0 ;
20229: LD_ADDR_VAR 0 3
20233: PUSH
20234: LD_INT 0
20236: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20237: LD_ADDR_VAR 0 2
20241: PUSH
20242: DOUBLE
20243: LD_INT 1
20245: DEC
20246: ST_TO_ADDR
20247: LD_EXP 69
20251: PUSH
20252: FOR_TO
20253: IFFALSE 20287
// if artifactsLabs [ i ] = lab then
20255: LD_EXP 69
20259: PUSH
20260: LD_VAR 0 2
20264: ARRAY
20265: PUSH
20266: LD_VAR 0 1
20270: EQUAL
20271: IFFALSE 20285
// begin labNum := i ;
20273: LD_ADDR_VAR 0 3
20277: PUSH
20278: LD_VAR 0 2
20282: ST_TO_ADDR
// break ;
20283: GO 20287
// end ;
20285: GO 20252
20287: POP
20288: POP
// if not labNum then
20289: LD_VAR 0 3
20293: NOT
20294: IFFALSE 20298
// exit ;
20296: GO 20460
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
20298: LD_INT 7
20300: PPUSH
20301: LD_EXP 70
20305: PUSH
20306: LD_VAR 0 3
20310: ARRAY
20311: PUSH
20312: LD_INT 3
20314: ARRAY
20315: PPUSH
20316: LD_INT 0
20318: PPUSH
20319: LD_VAR 0 1
20323: PPUSH
20324: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
20328: LD_ADDR_EXP 65
20332: PUSH
20333: LD_EXP 65
20337: PPUSH
20338: LD_VAR 0 3
20342: PPUSH
20343: LD_INT 1
20345: PPUSH
20346: CALL_OW 1
20350: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
20351: LD_ADDR_EXP 71
20355: PUSH
20356: LD_EXP 71
20360: PPUSH
20361: LD_VAR 0 3
20365: PPUSH
20366: LD_INT 1
20368: PPUSH
20369: CALL_OW 1
20373: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
20374: LD_ADDR_EXP 66
20378: PUSH
20379: LD_EXP 66
20383: PPUSH
20384: LD_VAR 0 3
20388: PPUSH
20389: LD_INT 0
20391: PPUSH
20392: CALL_OW 1
20396: ST_TO_ADDR
// case labNum of 1 :
20397: LD_VAR 0 3
20401: PUSH
20402: LD_INT 1
20404: DOUBLE
20405: EQUAL
20406: IFTRUE 20410
20408: GO 20421
20410: POP
// artifactIResearched := true ; 2 :
20411: LD_ADDR_EXP 12
20415: PUSH
20416: LD_INT 1
20418: ST_TO_ADDR
20419: GO 20460
20421: LD_INT 2
20423: DOUBLE
20424: EQUAL
20425: IFTRUE 20429
20427: GO 20440
20429: POP
// artifactIIResearched := true ; 3 :
20430: LD_ADDR_EXP 13
20434: PUSH
20435: LD_INT 1
20437: ST_TO_ADDR
20438: GO 20460
20440: LD_INT 3
20442: DOUBLE
20443: EQUAL
20444: IFTRUE 20448
20446: GO 20459
20448: POP
// artifactIIIResearched := true ; end ;
20449: LD_ADDR_EXP 14
20453: PUSH
20454: LD_INT 1
20456: ST_TO_ADDR
20457: GO 20460
20459: POP
// end ; end_of_file
20460: PPOPN 3
20462: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
20463: GO 20465
20465: DISABLE
// begin ru_radar := 98 ;
20466: LD_ADDR_EXP 72
20470: PUSH
20471: LD_INT 98
20473: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
20474: LD_ADDR_EXP 73
20478: PUSH
20479: LD_INT 89
20481: ST_TO_ADDR
// us_hack := 99 ;
20482: LD_ADDR_EXP 74
20486: PUSH
20487: LD_INT 99
20489: ST_TO_ADDR
// us_artillery := 97 ;
20490: LD_ADDR_EXP 75
20494: PUSH
20495: LD_INT 97
20497: ST_TO_ADDR
// ar_bio_bomb := 91 ;
20498: LD_ADDR_EXP 76
20502: PUSH
20503: LD_INT 91
20505: ST_TO_ADDR
// tech_Artillery := 80 ;
20506: LD_ADDR_EXP 77
20510: PUSH
20511: LD_INT 80
20513: ST_TO_ADDR
// tech_RadMat := 81 ;
20514: LD_ADDR_EXP 78
20518: PUSH
20519: LD_INT 81
20521: ST_TO_ADDR
// tech_BasicTools := 82 ;
20522: LD_ADDR_EXP 79
20526: PUSH
20527: LD_INT 82
20529: ST_TO_ADDR
// tech_Cargo := 83 ;
20530: LD_ADDR_EXP 80
20534: PUSH
20535: LD_INT 83
20537: ST_TO_ADDR
// tech_Track := 84 ;
20538: LD_ADDR_EXP 81
20542: PUSH
20543: LD_INT 84
20545: ST_TO_ADDR
// tech_Crane := 85 ;
20546: LD_ADDR_EXP 82
20550: PUSH
20551: LD_INT 85
20553: ST_TO_ADDR
// tech_Bulldozer := 86 ;
20554: LD_ADDR_EXP 83
20558: PUSH
20559: LD_INT 86
20561: ST_TO_ADDR
// tech_Hovercraft := 87 ;
20562: LD_ADDR_EXP 84
20566: PUSH
20567: LD_INT 87
20569: ST_TO_ADDR
// end ; end_of_file
20570: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
20571: LD_INT 0
20573: PPUSH
20574: PPUSH
// skirmish := false ;
20575: LD_ADDR_EXP 85
20579: PUSH
20580: LD_INT 0
20582: ST_TO_ADDR
// debug_mc := false ;
20583: LD_ADDR_EXP 86
20587: PUSH
20588: LD_INT 0
20590: ST_TO_ADDR
// mc_bases := [ ] ;
20591: LD_ADDR_EXP 87
20595: PUSH
20596: EMPTY
20597: ST_TO_ADDR
// mc_sides := [ ] ;
20598: LD_ADDR_EXP 113
20602: PUSH
20603: EMPTY
20604: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
20605: LD_ADDR_EXP 88
20609: PUSH
20610: EMPTY
20611: ST_TO_ADDR
// mc_building_repairs := [ ] ;
20612: LD_ADDR_EXP 89
20616: PUSH
20617: EMPTY
20618: ST_TO_ADDR
// mc_need_heal := [ ] ;
20619: LD_ADDR_EXP 90
20623: PUSH
20624: EMPTY
20625: ST_TO_ADDR
// mc_healers := [ ] ;
20626: LD_ADDR_EXP 91
20630: PUSH
20631: EMPTY
20632: ST_TO_ADDR
// mc_build_list := [ ] ;
20633: LD_ADDR_EXP 92
20637: PUSH
20638: EMPTY
20639: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
20640: LD_ADDR_EXP 119
20644: PUSH
20645: EMPTY
20646: ST_TO_ADDR
// mc_builders := [ ] ;
20647: LD_ADDR_EXP 93
20651: PUSH
20652: EMPTY
20653: ST_TO_ADDR
// mc_construct_list := [ ] ;
20654: LD_ADDR_EXP 94
20658: PUSH
20659: EMPTY
20660: ST_TO_ADDR
// mc_turret_list := [ ] ;
20661: LD_ADDR_EXP 95
20665: PUSH
20666: EMPTY
20667: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
20668: LD_ADDR_EXP 96
20672: PUSH
20673: EMPTY
20674: ST_TO_ADDR
// mc_miners := [ ] ;
20675: LD_ADDR_EXP 101
20679: PUSH
20680: EMPTY
20681: ST_TO_ADDR
// mc_mines := [ ] ;
20682: LD_ADDR_EXP 100
20686: PUSH
20687: EMPTY
20688: ST_TO_ADDR
// mc_minefields := [ ] ;
20689: LD_ADDR_EXP 102
20693: PUSH
20694: EMPTY
20695: ST_TO_ADDR
// mc_crates := [ ] ;
20696: LD_ADDR_EXP 103
20700: PUSH
20701: EMPTY
20702: ST_TO_ADDR
// mc_crates_collector := [ ] ;
20703: LD_ADDR_EXP 104
20707: PUSH
20708: EMPTY
20709: ST_TO_ADDR
// mc_crates_area := [ ] ;
20710: LD_ADDR_EXP 105
20714: PUSH
20715: EMPTY
20716: ST_TO_ADDR
// mc_vehicles := [ ] ;
20717: LD_ADDR_EXP 106
20721: PUSH
20722: EMPTY
20723: ST_TO_ADDR
// mc_attack := [ ] ;
20724: LD_ADDR_EXP 107
20728: PUSH
20729: EMPTY
20730: ST_TO_ADDR
// mc_produce := [ ] ;
20731: LD_ADDR_EXP 108
20735: PUSH
20736: EMPTY
20737: ST_TO_ADDR
// mc_defender := [ ] ;
20738: LD_ADDR_EXP 109
20742: PUSH
20743: EMPTY
20744: ST_TO_ADDR
// mc_parking := [ ] ;
20745: LD_ADDR_EXP 111
20749: PUSH
20750: EMPTY
20751: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
20752: LD_ADDR_EXP 97
20756: PUSH
20757: EMPTY
20758: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
20759: LD_ADDR_EXP 99
20763: PUSH
20764: EMPTY
20765: ST_TO_ADDR
// mc_scan := [ ] ;
20766: LD_ADDR_EXP 110
20770: PUSH
20771: EMPTY
20772: ST_TO_ADDR
// mc_scan_area := [ ] ;
20773: LD_ADDR_EXP 112
20777: PUSH
20778: EMPTY
20779: ST_TO_ADDR
// mc_tech := [ ] ;
20780: LD_ADDR_EXP 114
20784: PUSH
20785: EMPTY
20786: ST_TO_ADDR
// mc_class := [ ] ;
20787: LD_ADDR_EXP 128
20791: PUSH
20792: EMPTY
20793: ST_TO_ADDR
// mc_class_case_use := [ ] ;
20794: LD_ADDR_EXP 129
20798: PUSH
20799: EMPTY
20800: ST_TO_ADDR
// end ;
20801: LD_VAR 0 1
20805: RET
// export function MC_Kill ( base ) ; begin
20806: LD_INT 0
20808: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
20809: LD_ADDR_EXP 87
20813: PUSH
20814: LD_EXP 87
20818: PPUSH
20819: LD_VAR 0 1
20823: PPUSH
20824: EMPTY
20825: PPUSH
20826: CALL_OW 1
20830: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
20831: LD_ADDR_EXP 88
20835: PUSH
20836: LD_EXP 88
20840: PPUSH
20841: LD_VAR 0 1
20845: PPUSH
20846: EMPTY
20847: PPUSH
20848: CALL_OW 1
20852: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
20853: LD_ADDR_EXP 89
20857: PUSH
20858: LD_EXP 89
20862: PPUSH
20863: LD_VAR 0 1
20867: PPUSH
20868: EMPTY
20869: PPUSH
20870: CALL_OW 1
20874: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
20875: LD_ADDR_EXP 90
20879: PUSH
20880: LD_EXP 90
20884: PPUSH
20885: LD_VAR 0 1
20889: PPUSH
20890: EMPTY
20891: PPUSH
20892: CALL_OW 1
20896: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
20897: LD_ADDR_EXP 91
20901: PUSH
20902: LD_EXP 91
20906: PPUSH
20907: LD_VAR 0 1
20911: PPUSH
20912: EMPTY
20913: PPUSH
20914: CALL_OW 1
20918: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
20919: LD_ADDR_EXP 92
20923: PUSH
20924: LD_EXP 92
20928: PPUSH
20929: LD_VAR 0 1
20933: PPUSH
20934: EMPTY
20935: PPUSH
20936: CALL_OW 1
20940: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
20941: LD_ADDR_EXP 93
20945: PUSH
20946: LD_EXP 93
20950: PPUSH
20951: LD_VAR 0 1
20955: PPUSH
20956: EMPTY
20957: PPUSH
20958: CALL_OW 1
20962: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
20963: LD_ADDR_EXP 94
20967: PUSH
20968: LD_EXP 94
20972: PPUSH
20973: LD_VAR 0 1
20977: PPUSH
20978: EMPTY
20979: PPUSH
20980: CALL_OW 1
20984: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
20985: LD_ADDR_EXP 95
20989: PUSH
20990: LD_EXP 95
20994: PPUSH
20995: LD_VAR 0 1
20999: PPUSH
21000: EMPTY
21001: PPUSH
21002: CALL_OW 1
21006: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
21007: LD_ADDR_EXP 96
21011: PUSH
21012: LD_EXP 96
21016: PPUSH
21017: LD_VAR 0 1
21021: PPUSH
21022: EMPTY
21023: PPUSH
21024: CALL_OW 1
21028: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
21029: LD_ADDR_EXP 97
21033: PUSH
21034: LD_EXP 97
21038: PPUSH
21039: LD_VAR 0 1
21043: PPUSH
21044: EMPTY
21045: PPUSH
21046: CALL_OW 1
21050: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
21051: LD_ADDR_EXP 98
21055: PUSH
21056: LD_EXP 98
21060: PPUSH
21061: LD_VAR 0 1
21065: PPUSH
21066: LD_INT 0
21068: PPUSH
21069: CALL_OW 1
21073: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21074: LD_ADDR_EXP 99
21078: PUSH
21079: LD_EXP 99
21083: PPUSH
21084: LD_VAR 0 1
21088: PPUSH
21089: EMPTY
21090: PPUSH
21091: CALL_OW 1
21095: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21096: LD_ADDR_EXP 100
21100: PUSH
21101: LD_EXP 100
21105: PPUSH
21106: LD_VAR 0 1
21110: PPUSH
21111: EMPTY
21112: PPUSH
21113: CALL_OW 1
21117: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
21118: LD_ADDR_EXP 101
21122: PUSH
21123: LD_EXP 101
21127: PPUSH
21128: LD_VAR 0 1
21132: PPUSH
21133: EMPTY
21134: PPUSH
21135: CALL_OW 1
21139: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
21140: LD_ADDR_EXP 102
21144: PUSH
21145: LD_EXP 102
21149: PPUSH
21150: LD_VAR 0 1
21154: PPUSH
21155: EMPTY
21156: PPUSH
21157: CALL_OW 1
21161: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
21162: LD_ADDR_EXP 103
21166: PUSH
21167: LD_EXP 103
21171: PPUSH
21172: LD_VAR 0 1
21176: PPUSH
21177: EMPTY
21178: PPUSH
21179: CALL_OW 1
21183: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
21184: LD_ADDR_EXP 104
21188: PUSH
21189: LD_EXP 104
21193: PPUSH
21194: LD_VAR 0 1
21198: PPUSH
21199: EMPTY
21200: PPUSH
21201: CALL_OW 1
21205: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
21206: LD_ADDR_EXP 105
21210: PUSH
21211: LD_EXP 105
21215: PPUSH
21216: LD_VAR 0 1
21220: PPUSH
21221: EMPTY
21222: PPUSH
21223: CALL_OW 1
21227: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
21228: LD_ADDR_EXP 106
21232: PUSH
21233: LD_EXP 106
21237: PPUSH
21238: LD_VAR 0 1
21242: PPUSH
21243: EMPTY
21244: PPUSH
21245: CALL_OW 1
21249: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
21250: LD_ADDR_EXP 107
21254: PUSH
21255: LD_EXP 107
21259: PPUSH
21260: LD_VAR 0 1
21264: PPUSH
21265: EMPTY
21266: PPUSH
21267: CALL_OW 1
21271: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
21272: LD_ADDR_EXP 108
21276: PUSH
21277: LD_EXP 108
21281: PPUSH
21282: LD_VAR 0 1
21286: PPUSH
21287: EMPTY
21288: PPUSH
21289: CALL_OW 1
21293: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
21294: LD_ADDR_EXP 109
21298: PUSH
21299: LD_EXP 109
21303: PPUSH
21304: LD_VAR 0 1
21308: PPUSH
21309: EMPTY
21310: PPUSH
21311: CALL_OW 1
21315: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
21316: LD_ADDR_EXP 110
21320: PUSH
21321: LD_EXP 110
21325: PPUSH
21326: LD_VAR 0 1
21330: PPUSH
21331: EMPTY
21332: PPUSH
21333: CALL_OW 1
21337: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
21338: LD_ADDR_EXP 111
21342: PUSH
21343: LD_EXP 111
21347: PPUSH
21348: LD_VAR 0 1
21352: PPUSH
21353: EMPTY
21354: PPUSH
21355: CALL_OW 1
21359: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
21360: LD_ADDR_EXP 112
21364: PUSH
21365: LD_EXP 112
21369: PPUSH
21370: LD_VAR 0 1
21374: PPUSH
21375: EMPTY
21376: PPUSH
21377: CALL_OW 1
21381: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
21382: LD_ADDR_EXP 114
21386: PUSH
21387: LD_EXP 114
21391: PPUSH
21392: LD_VAR 0 1
21396: PPUSH
21397: EMPTY
21398: PPUSH
21399: CALL_OW 1
21403: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
21404: LD_ADDR_EXP 116
21408: PUSH
21409: LD_EXP 116
21413: PPUSH
21414: LD_VAR 0 1
21418: PPUSH
21419: EMPTY
21420: PPUSH
21421: CALL_OW 1
21425: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
21426: LD_ADDR_EXP 117
21430: PUSH
21431: LD_EXP 117
21435: PPUSH
21436: LD_VAR 0 1
21440: PPUSH
21441: EMPTY
21442: PPUSH
21443: CALL_OW 1
21447: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
21448: LD_ADDR_EXP 118
21452: PUSH
21453: LD_EXP 118
21457: PPUSH
21458: LD_VAR 0 1
21462: PPUSH
21463: EMPTY
21464: PPUSH
21465: CALL_OW 1
21469: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
21470: LD_ADDR_EXP 119
21474: PUSH
21475: LD_EXP 119
21479: PPUSH
21480: LD_VAR 0 1
21484: PPUSH
21485: EMPTY
21486: PPUSH
21487: CALL_OW 1
21491: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
21492: LD_ADDR_EXP 120
21496: PUSH
21497: LD_EXP 120
21501: PPUSH
21502: LD_VAR 0 1
21506: PPUSH
21507: EMPTY
21508: PPUSH
21509: CALL_OW 1
21513: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
21514: LD_ADDR_EXP 121
21518: PUSH
21519: LD_EXP 121
21523: PPUSH
21524: LD_VAR 0 1
21528: PPUSH
21529: EMPTY
21530: PPUSH
21531: CALL_OW 1
21535: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
21536: LD_ADDR_EXP 122
21540: PUSH
21541: LD_EXP 122
21545: PPUSH
21546: LD_VAR 0 1
21550: PPUSH
21551: EMPTY
21552: PPUSH
21553: CALL_OW 1
21557: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
21558: LD_ADDR_EXP 123
21562: PUSH
21563: LD_EXP 123
21567: PPUSH
21568: LD_VAR 0 1
21572: PPUSH
21573: EMPTY
21574: PPUSH
21575: CALL_OW 1
21579: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
21580: LD_ADDR_EXP 124
21584: PUSH
21585: LD_EXP 124
21589: PPUSH
21590: LD_VAR 0 1
21594: PPUSH
21595: EMPTY
21596: PPUSH
21597: CALL_OW 1
21601: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
21602: LD_ADDR_EXP 125
21606: PUSH
21607: LD_EXP 125
21611: PPUSH
21612: LD_VAR 0 1
21616: PPUSH
21617: EMPTY
21618: PPUSH
21619: CALL_OW 1
21623: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
21624: LD_ADDR_EXP 126
21628: PUSH
21629: LD_EXP 126
21633: PPUSH
21634: LD_VAR 0 1
21638: PPUSH
21639: EMPTY
21640: PPUSH
21641: CALL_OW 1
21645: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
21646: LD_ADDR_EXP 127
21650: PUSH
21651: LD_EXP 127
21655: PPUSH
21656: LD_VAR 0 1
21660: PPUSH
21661: EMPTY
21662: PPUSH
21663: CALL_OW 1
21667: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
21668: LD_ADDR_EXP 128
21672: PUSH
21673: LD_EXP 128
21677: PPUSH
21678: LD_VAR 0 1
21682: PPUSH
21683: EMPTY
21684: PPUSH
21685: CALL_OW 1
21689: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
21690: LD_ADDR_EXP 129
21694: PUSH
21695: LD_EXP 129
21699: PPUSH
21700: LD_VAR 0 1
21704: PPUSH
21705: LD_INT 0
21707: PPUSH
21708: CALL_OW 1
21712: ST_TO_ADDR
// end ;
21713: LD_VAR 0 2
21717: RET
// export function MC_Add ( side , units ) ; var base ; begin
21718: LD_INT 0
21720: PPUSH
21721: PPUSH
// base := mc_bases + 1 ;
21722: LD_ADDR_VAR 0 4
21726: PUSH
21727: LD_EXP 87
21731: PUSH
21732: LD_INT 1
21734: PLUS
21735: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
21736: LD_ADDR_EXP 113
21740: PUSH
21741: LD_EXP 113
21745: PPUSH
21746: LD_VAR 0 4
21750: PPUSH
21751: LD_VAR 0 1
21755: PPUSH
21756: CALL_OW 1
21760: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
21761: LD_ADDR_EXP 87
21765: PUSH
21766: LD_EXP 87
21770: PPUSH
21771: LD_VAR 0 4
21775: PPUSH
21776: LD_VAR 0 2
21780: PPUSH
21781: CALL_OW 1
21785: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
21786: LD_ADDR_EXP 88
21790: PUSH
21791: LD_EXP 88
21795: PPUSH
21796: LD_VAR 0 4
21800: PPUSH
21801: EMPTY
21802: PPUSH
21803: CALL_OW 1
21807: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
21808: LD_ADDR_EXP 89
21812: PUSH
21813: LD_EXP 89
21817: PPUSH
21818: LD_VAR 0 4
21822: PPUSH
21823: EMPTY
21824: PPUSH
21825: CALL_OW 1
21829: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
21830: LD_ADDR_EXP 90
21834: PUSH
21835: LD_EXP 90
21839: PPUSH
21840: LD_VAR 0 4
21844: PPUSH
21845: EMPTY
21846: PPUSH
21847: CALL_OW 1
21851: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
21852: LD_ADDR_EXP 91
21856: PUSH
21857: LD_EXP 91
21861: PPUSH
21862: LD_VAR 0 4
21866: PPUSH
21867: EMPTY
21868: PPUSH
21869: CALL_OW 1
21873: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
21874: LD_ADDR_EXP 92
21878: PUSH
21879: LD_EXP 92
21883: PPUSH
21884: LD_VAR 0 4
21888: PPUSH
21889: EMPTY
21890: PPUSH
21891: CALL_OW 1
21895: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
21896: LD_ADDR_EXP 93
21900: PUSH
21901: LD_EXP 93
21905: PPUSH
21906: LD_VAR 0 4
21910: PPUSH
21911: EMPTY
21912: PPUSH
21913: CALL_OW 1
21917: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
21918: LD_ADDR_EXP 94
21922: PUSH
21923: LD_EXP 94
21927: PPUSH
21928: LD_VAR 0 4
21932: PPUSH
21933: EMPTY
21934: PPUSH
21935: CALL_OW 1
21939: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
21940: LD_ADDR_EXP 95
21944: PUSH
21945: LD_EXP 95
21949: PPUSH
21950: LD_VAR 0 4
21954: PPUSH
21955: EMPTY
21956: PPUSH
21957: CALL_OW 1
21961: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
21962: LD_ADDR_EXP 96
21966: PUSH
21967: LD_EXP 96
21971: PPUSH
21972: LD_VAR 0 4
21976: PPUSH
21977: EMPTY
21978: PPUSH
21979: CALL_OW 1
21983: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
21984: LD_ADDR_EXP 97
21988: PUSH
21989: LD_EXP 97
21993: PPUSH
21994: LD_VAR 0 4
21998: PPUSH
21999: EMPTY
22000: PPUSH
22001: CALL_OW 1
22005: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
22006: LD_ADDR_EXP 98
22010: PUSH
22011: LD_EXP 98
22015: PPUSH
22016: LD_VAR 0 4
22020: PPUSH
22021: LD_INT 0
22023: PPUSH
22024: CALL_OW 1
22028: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
22029: LD_ADDR_EXP 99
22033: PUSH
22034: LD_EXP 99
22038: PPUSH
22039: LD_VAR 0 4
22043: PPUSH
22044: EMPTY
22045: PPUSH
22046: CALL_OW 1
22050: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
22051: LD_ADDR_EXP 100
22055: PUSH
22056: LD_EXP 100
22060: PPUSH
22061: LD_VAR 0 4
22065: PPUSH
22066: EMPTY
22067: PPUSH
22068: CALL_OW 1
22072: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
22073: LD_ADDR_EXP 101
22077: PUSH
22078: LD_EXP 101
22082: PPUSH
22083: LD_VAR 0 4
22087: PPUSH
22088: EMPTY
22089: PPUSH
22090: CALL_OW 1
22094: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
22095: LD_ADDR_EXP 102
22099: PUSH
22100: LD_EXP 102
22104: PPUSH
22105: LD_VAR 0 4
22109: PPUSH
22110: EMPTY
22111: PPUSH
22112: CALL_OW 1
22116: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
22117: LD_ADDR_EXP 103
22121: PUSH
22122: LD_EXP 103
22126: PPUSH
22127: LD_VAR 0 4
22131: PPUSH
22132: EMPTY
22133: PPUSH
22134: CALL_OW 1
22138: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
22139: LD_ADDR_EXP 104
22143: PUSH
22144: LD_EXP 104
22148: PPUSH
22149: LD_VAR 0 4
22153: PPUSH
22154: EMPTY
22155: PPUSH
22156: CALL_OW 1
22160: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
22161: LD_ADDR_EXP 105
22165: PUSH
22166: LD_EXP 105
22170: PPUSH
22171: LD_VAR 0 4
22175: PPUSH
22176: EMPTY
22177: PPUSH
22178: CALL_OW 1
22182: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
22183: LD_ADDR_EXP 106
22187: PUSH
22188: LD_EXP 106
22192: PPUSH
22193: LD_VAR 0 4
22197: PPUSH
22198: EMPTY
22199: PPUSH
22200: CALL_OW 1
22204: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
22205: LD_ADDR_EXP 107
22209: PUSH
22210: LD_EXP 107
22214: PPUSH
22215: LD_VAR 0 4
22219: PPUSH
22220: EMPTY
22221: PPUSH
22222: CALL_OW 1
22226: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
22227: LD_ADDR_EXP 108
22231: PUSH
22232: LD_EXP 108
22236: PPUSH
22237: LD_VAR 0 4
22241: PPUSH
22242: EMPTY
22243: PPUSH
22244: CALL_OW 1
22248: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
22249: LD_ADDR_EXP 109
22253: PUSH
22254: LD_EXP 109
22258: PPUSH
22259: LD_VAR 0 4
22263: PPUSH
22264: EMPTY
22265: PPUSH
22266: CALL_OW 1
22270: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
22271: LD_ADDR_EXP 110
22275: PUSH
22276: LD_EXP 110
22280: PPUSH
22281: LD_VAR 0 4
22285: PPUSH
22286: EMPTY
22287: PPUSH
22288: CALL_OW 1
22292: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
22293: LD_ADDR_EXP 111
22297: PUSH
22298: LD_EXP 111
22302: PPUSH
22303: LD_VAR 0 4
22307: PPUSH
22308: EMPTY
22309: PPUSH
22310: CALL_OW 1
22314: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
22315: LD_ADDR_EXP 112
22319: PUSH
22320: LD_EXP 112
22324: PPUSH
22325: LD_VAR 0 4
22329: PPUSH
22330: EMPTY
22331: PPUSH
22332: CALL_OW 1
22336: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
22337: LD_ADDR_EXP 114
22341: PUSH
22342: LD_EXP 114
22346: PPUSH
22347: LD_VAR 0 4
22351: PPUSH
22352: EMPTY
22353: PPUSH
22354: CALL_OW 1
22358: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
22359: LD_ADDR_EXP 116
22363: PUSH
22364: LD_EXP 116
22368: PPUSH
22369: LD_VAR 0 4
22373: PPUSH
22374: EMPTY
22375: PPUSH
22376: CALL_OW 1
22380: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
22381: LD_ADDR_EXP 117
22385: PUSH
22386: LD_EXP 117
22390: PPUSH
22391: LD_VAR 0 4
22395: PPUSH
22396: EMPTY
22397: PPUSH
22398: CALL_OW 1
22402: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
22403: LD_ADDR_EXP 118
22407: PUSH
22408: LD_EXP 118
22412: PPUSH
22413: LD_VAR 0 4
22417: PPUSH
22418: EMPTY
22419: PPUSH
22420: CALL_OW 1
22424: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
22425: LD_ADDR_EXP 119
22429: PUSH
22430: LD_EXP 119
22434: PPUSH
22435: LD_VAR 0 4
22439: PPUSH
22440: EMPTY
22441: PPUSH
22442: CALL_OW 1
22446: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
22447: LD_ADDR_EXP 120
22451: PUSH
22452: LD_EXP 120
22456: PPUSH
22457: LD_VAR 0 4
22461: PPUSH
22462: EMPTY
22463: PPUSH
22464: CALL_OW 1
22468: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
22469: LD_ADDR_EXP 121
22473: PUSH
22474: LD_EXP 121
22478: PPUSH
22479: LD_VAR 0 4
22483: PPUSH
22484: EMPTY
22485: PPUSH
22486: CALL_OW 1
22490: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
22491: LD_ADDR_EXP 122
22495: PUSH
22496: LD_EXP 122
22500: PPUSH
22501: LD_VAR 0 4
22505: PPUSH
22506: EMPTY
22507: PPUSH
22508: CALL_OW 1
22512: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
22513: LD_ADDR_EXP 123
22517: PUSH
22518: LD_EXP 123
22522: PPUSH
22523: LD_VAR 0 4
22527: PPUSH
22528: EMPTY
22529: PPUSH
22530: CALL_OW 1
22534: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
22535: LD_ADDR_EXP 124
22539: PUSH
22540: LD_EXP 124
22544: PPUSH
22545: LD_VAR 0 4
22549: PPUSH
22550: EMPTY
22551: PPUSH
22552: CALL_OW 1
22556: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
22557: LD_ADDR_EXP 125
22561: PUSH
22562: LD_EXP 125
22566: PPUSH
22567: LD_VAR 0 4
22571: PPUSH
22572: EMPTY
22573: PPUSH
22574: CALL_OW 1
22578: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
22579: LD_ADDR_EXP 126
22583: PUSH
22584: LD_EXP 126
22588: PPUSH
22589: LD_VAR 0 4
22593: PPUSH
22594: EMPTY
22595: PPUSH
22596: CALL_OW 1
22600: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
22601: LD_ADDR_EXP 127
22605: PUSH
22606: LD_EXP 127
22610: PPUSH
22611: LD_VAR 0 4
22615: PPUSH
22616: EMPTY
22617: PPUSH
22618: CALL_OW 1
22622: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
22623: LD_ADDR_EXP 128
22627: PUSH
22628: LD_EXP 128
22632: PPUSH
22633: LD_VAR 0 4
22637: PPUSH
22638: EMPTY
22639: PPUSH
22640: CALL_OW 1
22644: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
22645: LD_ADDR_EXP 129
22649: PUSH
22650: LD_EXP 129
22654: PPUSH
22655: LD_VAR 0 4
22659: PPUSH
22660: LD_INT 0
22662: PPUSH
22663: CALL_OW 1
22667: ST_TO_ADDR
// result := base ;
22668: LD_ADDR_VAR 0 3
22672: PUSH
22673: LD_VAR 0 4
22677: ST_TO_ADDR
// end ;
22678: LD_VAR 0 3
22682: RET
// export function MC_Start ( ) ; var i ; begin
22683: LD_INT 0
22685: PPUSH
22686: PPUSH
// for i = 1 to mc_bases do
22687: LD_ADDR_VAR 0 2
22691: PUSH
22692: DOUBLE
22693: LD_INT 1
22695: DEC
22696: ST_TO_ADDR
22697: LD_EXP 87
22701: PUSH
22702: FOR_TO
22703: IFFALSE 23780
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
22705: LD_ADDR_EXP 87
22709: PUSH
22710: LD_EXP 87
22714: PPUSH
22715: LD_VAR 0 2
22719: PPUSH
22720: LD_EXP 87
22724: PUSH
22725: LD_VAR 0 2
22729: ARRAY
22730: PUSH
22731: LD_INT 0
22733: DIFF
22734: PPUSH
22735: CALL_OW 1
22739: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
22740: LD_ADDR_EXP 88
22744: PUSH
22745: LD_EXP 88
22749: PPUSH
22750: LD_VAR 0 2
22754: PPUSH
22755: EMPTY
22756: PPUSH
22757: CALL_OW 1
22761: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
22762: LD_ADDR_EXP 89
22766: PUSH
22767: LD_EXP 89
22771: PPUSH
22772: LD_VAR 0 2
22776: PPUSH
22777: EMPTY
22778: PPUSH
22779: CALL_OW 1
22783: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
22784: LD_ADDR_EXP 90
22788: PUSH
22789: LD_EXP 90
22793: PPUSH
22794: LD_VAR 0 2
22798: PPUSH
22799: EMPTY
22800: PPUSH
22801: CALL_OW 1
22805: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
22806: LD_ADDR_EXP 91
22810: PUSH
22811: LD_EXP 91
22815: PPUSH
22816: LD_VAR 0 2
22820: PPUSH
22821: EMPTY
22822: PUSH
22823: EMPTY
22824: PUSH
22825: EMPTY
22826: LIST
22827: LIST
22828: PPUSH
22829: CALL_OW 1
22833: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
22834: LD_ADDR_EXP 92
22838: PUSH
22839: LD_EXP 92
22843: PPUSH
22844: LD_VAR 0 2
22848: PPUSH
22849: EMPTY
22850: PPUSH
22851: CALL_OW 1
22855: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
22856: LD_ADDR_EXP 119
22860: PUSH
22861: LD_EXP 119
22865: PPUSH
22866: LD_VAR 0 2
22870: PPUSH
22871: EMPTY
22872: PPUSH
22873: CALL_OW 1
22877: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
22878: LD_ADDR_EXP 93
22882: PUSH
22883: LD_EXP 93
22887: PPUSH
22888: LD_VAR 0 2
22892: PPUSH
22893: EMPTY
22894: PPUSH
22895: CALL_OW 1
22899: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
22900: LD_ADDR_EXP 94
22904: PUSH
22905: LD_EXP 94
22909: PPUSH
22910: LD_VAR 0 2
22914: PPUSH
22915: EMPTY
22916: PPUSH
22917: CALL_OW 1
22921: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
22922: LD_ADDR_EXP 95
22926: PUSH
22927: LD_EXP 95
22931: PPUSH
22932: LD_VAR 0 2
22936: PPUSH
22937: LD_EXP 87
22941: PUSH
22942: LD_VAR 0 2
22946: ARRAY
22947: PPUSH
22948: LD_INT 2
22950: PUSH
22951: LD_INT 30
22953: PUSH
22954: LD_INT 32
22956: PUSH
22957: EMPTY
22958: LIST
22959: LIST
22960: PUSH
22961: LD_INT 30
22963: PUSH
22964: LD_INT 33
22966: PUSH
22967: EMPTY
22968: LIST
22969: LIST
22970: PUSH
22971: EMPTY
22972: LIST
22973: LIST
22974: LIST
22975: PPUSH
22976: CALL_OW 72
22980: PPUSH
22981: CALL_OW 1
22985: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
22986: LD_ADDR_EXP 96
22990: PUSH
22991: LD_EXP 96
22995: PPUSH
22996: LD_VAR 0 2
23000: PPUSH
23001: LD_EXP 87
23005: PUSH
23006: LD_VAR 0 2
23010: ARRAY
23011: PPUSH
23012: LD_INT 2
23014: PUSH
23015: LD_INT 30
23017: PUSH
23018: LD_INT 32
23020: PUSH
23021: EMPTY
23022: LIST
23023: LIST
23024: PUSH
23025: LD_INT 30
23027: PUSH
23028: LD_INT 31
23030: PUSH
23031: EMPTY
23032: LIST
23033: LIST
23034: PUSH
23035: EMPTY
23036: LIST
23037: LIST
23038: LIST
23039: PUSH
23040: LD_INT 58
23042: PUSH
23043: EMPTY
23044: LIST
23045: PUSH
23046: EMPTY
23047: LIST
23048: LIST
23049: PPUSH
23050: CALL_OW 72
23054: PPUSH
23055: CALL_OW 1
23059: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
23060: LD_ADDR_EXP 97
23064: PUSH
23065: LD_EXP 97
23069: PPUSH
23070: LD_VAR 0 2
23074: PPUSH
23075: EMPTY
23076: PPUSH
23077: CALL_OW 1
23081: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
23082: LD_ADDR_EXP 101
23086: PUSH
23087: LD_EXP 101
23091: PPUSH
23092: LD_VAR 0 2
23096: PPUSH
23097: EMPTY
23098: PPUSH
23099: CALL_OW 1
23103: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
23104: LD_ADDR_EXP 100
23108: PUSH
23109: LD_EXP 100
23113: PPUSH
23114: LD_VAR 0 2
23118: PPUSH
23119: EMPTY
23120: PPUSH
23121: CALL_OW 1
23125: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
23126: LD_ADDR_EXP 102
23130: PUSH
23131: LD_EXP 102
23135: PPUSH
23136: LD_VAR 0 2
23140: PPUSH
23141: EMPTY
23142: PPUSH
23143: CALL_OW 1
23147: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
23148: LD_ADDR_EXP 103
23152: PUSH
23153: LD_EXP 103
23157: PPUSH
23158: LD_VAR 0 2
23162: PPUSH
23163: EMPTY
23164: PPUSH
23165: CALL_OW 1
23169: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
23170: LD_ADDR_EXP 104
23174: PUSH
23175: LD_EXP 104
23179: PPUSH
23180: LD_VAR 0 2
23184: PPUSH
23185: EMPTY
23186: PPUSH
23187: CALL_OW 1
23191: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
23192: LD_ADDR_EXP 105
23196: PUSH
23197: LD_EXP 105
23201: PPUSH
23202: LD_VAR 0 2
23206: PPUSH
23207: EMPTY
23208: PPUSH
23209: CALL_OW 1
23213: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
23214: LD_ADDR_EXP 106
23218: PUSH
23219: LD_EXP 106
23223: PPUSH
23224: LD_VAR 0 2
23228: PPUSH
23229: EMPTY
23230: PPUSH
23231: CALL_OW 1
23235: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
23236: LD_ADDR_EXP 107
23240: PUSH
23241: LD_EXP 107
23245: PPUSH
23246: LD_VAR 0 2
23250: PPUSH
23251: EMPTY
23252: PPUSH
23253: CALL_OW 1
23257: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
23258: LD_ADDR_EXP 108
23262: PUSH
23263: LD_EXP 108
23267: PPUSH
23268: LD_VAR 0 2
23272: PPUSH
23273: EMPTY
23274: PPUSH
23275: CALL_OW 1
23279: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
23280: LD_ADDR_EXP 109
23284: PUSH
23285: LD_EXP 109
23289: PPUSH
23290: LD_VAR 0 2
23294: PPUSH
23295: EMPTY
23296: PPUSH
23297: CALL_OW 1
23301: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
23302: LD_ADDR_EXP 98
23306: PUSH
23307: LD_EXP 98
23311: PPUSH
23312: LD_VAR 0 2
23316: PPUSH
23317: LD_INT 0
23319: PPUSH
23320: CALL_OW 1
23324: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
23325: LD_ADDR_EXP 111
23329: PUSH
23330: LD_EXP 111
23334: PPUSH
23335: LD_VAR 0 2
23339: PPUSH
23340: LD_INT 0
23342: PPUSH
23343: CALL_OW 1
23347: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
23348: LD_ADDR_EXP 99
23352: PUSH
23353: LD_EXP 99
23357: PPUSH
23358: LD_VAR 0 2
23362: PPUSH
23363: EMPTY
23364: PPUSH
23365: CALL_OW 1
23369: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
23370: LD_ADDR_EXP 110
23374: PUSH
23375: LD_EXP 110
23379: PPUSH
23380: LD_VAR 0 2
23384: PPUSH
23385: LD_INT 0
23387: PPUSH
23388: CALL_OW 1
23392: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
23393: LD_ADDR_EXP 112
23397: PUSH
23398: LD_EXP 112
23402: PPUSH
23403: LD_VAR 0 2
23407: PPUSH
23408: EMPTY
23409: PPUSH
23410: CALL_OW 1
23414: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
23415: LD_ADDR_EXP 115
23419: PUSH
23420: LD_EXP 115
23424: PPUSH
23425: LD_VAR 0 2
23429: PPUSH
23430: LD_INT 0
23432: PPUSH
23433: CALL_OW 1
23437: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
23438: LD_ADDR_EXP 116
23442: PUSH
23443: LD_EXP 116
23447: PPUSH
23448: LD_VAR 0 2
23452: PPUSH
23453: EMPTY
23454: PPUSH
23455: CALL_OW 1
23459: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
23460: LD_ADDR_EXP 117
23464: PUSH
23465: LD_EXP 117
23469: PPUSH
23470: LD_VAR 0 2
23474: PPUSH
23475: EMPTY
23476: PPUSH
23477: CALL_OW 1
23481: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
23482: LD_ADDR_EXP 118
23486: PUSH
23487: LD_EXP 118
23491: PPUSH
23492: LD_VAR 0 2
23496: PPUSH
23497: EMPTY
23498: PPUSH
23499: CALL_OW 1
23503: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
23504: LD_ADDR_EXP 120
23508: PUSH
23509: LD_EXP 120
23513: PPUSH
23514: LD_VAR 0 2
23518: PPUSH
23519: LD_EXP 87
23523: PUSH
23524: LD_VAR 0 2
23528: ARRAY
23529: PPUSH
23530: LD_INT 2
23532: PUSH
23533: LD_INT 30
23535: PUSH
23536: LD_INT 6
23538: PUSH
23539: EMPTY
23540: LIST
23541: LIST
23542: PUSH
23543: LD_INT 30
23545: PUSH
23546: LD_INT 7
23548: PUSH
23549: EMPTY
23550: LIST
23551: LIST
23552: PUSH
23553: LD_INT 30
23555: PUSH
23556: LD_INT 8
23558: PUSH
23559: EMPTY
23560: LIST
23561: LIST
23562: PUSH
23563: EMPTY
23564: LIST
23565: LIST
23566: LIST
23567: LIST
23568: PPUSH
23569: CALL_OW 72
23573: PPUSH
23574: CALL_OW 1
23578: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
23579: LD_ADDR_EXP 121
23583: PUSH
23584: LD_EXP 121
23588: PPUSH
23589: LD_VAR 0 2
23593: PPUSH
23594: EMPTY
23595: PPUSH
23596: CALL_OW 1
23600: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
23601: LD_ADDR_EXP 122
23605: PUSH
23606: LD_EXP 122
23610: PPUSH
23611: LD_VAR 0 2
23615: PPUSH
23616: EMPTY
23617: PPUSH
23618: CALL_OW 1
23622: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
23623: LD_ADDR_EXP 123
23627: PUSH
23628: LD_EXP 123
23632: PPUSH
23633: LD_VAR 0 2
23637: PPUSH
23638: EMPTY
23639: PPUSH
23640: CALL_OW 1
23644: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
23645: LD_ADDR_EXP 124
23649: PUSH
23650: LD_EXP 124
23654: PPUSH
23655: LD_VAR 0 2
23659: PPUSH
23660: EMPTY
23661: PPUSH
23662: CALL_OW 1
23666: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
23667: LD_ADDR_EXP 125
23671: PUSH
23672: LD_EXP 125
23676: PPUSH
23677: LD_VAR 0 2
23681: PPUSH
23682: EMPTY
23683: PPUSH
23684: CALL_OW 1
23688: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
23689: LD_ADDR_EXP 126
23693: PUSH
23694: LD_EXP 126
23698: PPUSH
23699: LD_VAR 0 2
23703: PPUSH
23704: EMPTY
23705: PPUSH
23706: CALL_OW 1
23710: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
23711: LD_ADDR_EXP 127
23715: PUSH
23716: LD_EXP 127
23720: PPUSH
23721: LD_VAR 0 2
23725: PPUSH
23726: EMPTY
23727: PPUSH
23728: CALL_OW 1
23732: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
23733: LD_ADDR_EXP 128
23737: PUSH
23738: LD_EXP 128
23742: PPUSH
23743: LD_VAR 0 2
23747: PPUSH
23748: EMPTY
23749: PPUSH
23750: CALL_OW 1
23754: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
23755: LD_ADDR_EXP 129
23759: PUSH
23760: LD_EXP 129
23764: PPUSH
23765: LD_VAR 0 2
23769: PPUSH
23770: LD_INT 0
23772: PPUSH
23773: CALL_OW 1
23777: ST_TO_ADDR
// end ;
23778: GO 22702
23780: POP
23781: POP
// MC_InitSides ( ) ;
23782: CALL 24068 0 0
// MC_InitResearch ( ) ;
23786: CALL 23807 0 0
// CustomInitMacro ( ) ;
23790: CALL 213 0 0
// skirmish := true ;
23794: LD_ADDR_EXP 85
23798: PUSH
23799: LD_INT 1
23801: ST_TO_ADDR
// end ;
23802: LD_VAR 0 1
23806: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
23807: LD_INT 0
23809: PPUSH
23810: PPUSH
23811: PPUSH
23812: PPUSH
23813: PPUSH
23814: PPUSH
// if not mc_bases then
23815: LD_EXP 87
23819: NOT
23820: IFFALSE 23824
// exit ;
23822: GO 24063
// for i = 1 to 8 do
23824: LD_ADDR_VAR 0 2
23828: PUSH
23829: DOUBLE
23830: LD_INT 1
23832: DEC
23833: ST_TO_ADDR
23834: LD_INT 8
23836: PUSH
23837: FOR_TO
23838: IFFALSE 23864
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
23840: LD_ADDR_EXP 114
23844: PUSH
23845: LD_EXP 114
23849: PPUSH
23850: LD_VAR 0 2
23854: PPUSH
23855: EMPTY
23856: PPUSH
23857: CALL_OW 1
23861: ST_TO_ADDR
23862: GO 23837
23864: POP
23865: POP
// tmp := [ ] ;
23866: LD_ADDR_VAR 0 5
23870: PUSH
23871: EMPTY
23872: ST_TO_ADDR
// for i = 1 to mc_sides do
23873: LD_ADDR_VAR 0 2
23877: PUSH
23878: DOUBLE
23879: LD_INT 1
23881: DEC
23882: ST_TO_ADDR
23883: LD_EXP 113
23887: PUSH
23888: FOR_TO
23889: IFFALSE 23947
// if not mc_sides [ i ] in tmp then
23891: LD_EXP 113
23895: PUSH
23896: LD_VAR 0 2
23900: ARRAY
23901: PUSH
23902: LD_VAR 0 5
23906: IN
23907: NOT
23908: IFFALSE 23945
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
23910: LD_ADDR_VAR 0 5
23914: PUSH
23915: LD_VAR 0 5
23919: PPUSH
23920: LD_VAR 0 5
23924: PUSH
23925: LD_INT 1
23927: PLUS
23928: PPUSH
23929: LD_EXP 113
23933: PUSH
23934: LD_VAR 0 2
23938: ARRAY
23939: PPUSH
23940: CALL_OW 2
23944: ST_TO_ADDR
23945: GO 23888
23947: POP
23948: POP
// if not tmp then
23949: LD_VAR 0 5
23953: NOT
23954: IFFALSE 23958
// exit ;
23956: GO 24063
// for j in tmp do
23958: LD_ADDR_VAR 0 3
23962: PUSH
23963: LD_VAR 0 5
23967: PUSH
23968: FOR_IN
23969: IFFALSE 24061
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
23971: LD_ADDR_VAR 0 6
23975: PUSH
23976: LD_INT 22
23978: PUSH
23979: LD_VAR 0 3
23983: PUSH
23984: EMPTY
23985: LIST
23986: LIST
23987: PPUSH
23988: CALL_OW 69
23992: ST_TO_ADDR
// if not un then
23993: LD_VAR 0 6
23997: NOT
23998: IFFALSE 24002
// continue ;
24000: GO 23968
// nation := GetNation ( un [ 1 ] ) ;
24002: LD_ADDR_VAR 0 4
24006: PUSH
24007: LD_VAR 0 6
24011: PUSH
24012: LD_INT 1
24014: ARRAY
24015: PPUSH
24016: CALL_OW 248
24020: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
24021: LD_ADDR_EXP 114
24025: PUSH
24026: LD_EXP 114
24030: PPUSH
24031: LD_VAR 0 3
24035: PPUSH
24036: LD_VAR 0 3
24040: PPUSH
24041: LD_VAR 0 4
24045: PPUSH
24046: LD_INT 1
24048: PPUSH
24049: CALL 50673 0 3
24053: PPUSH
24054: CALL_OW 1
24058: ST_TO_ADDR
// end ;
24059: GO 23968
24061: POP
24062: POP
// end ;
24063: LD_VAR 0 1
24067: RET
// export function MC_InitSides ( ) ; var i ; begin
24068: LD_INT 0
24070: PPUSH
24071: PPUSH
// if not mc_bases then
24072: LD_EXP 87
24076: NOT
24077: IFFALSE 24081
// exit ;
24079: GO 24155
// for i = 1 to mc_bases do
24081: LD_ADDR_VAR 0 2
24085: PUSH
24086: DOUBLE
24087: LD_INT 1
24089: DEC
24090: ST_TO_ADDR
24091: LD_EXP 87
24095: PUSH
24096: FOR_TO
24097: IFFALSE 24153
// if mc_bases [ i ] then
24099: LD_EXP 87
24103: PUSH
24104: LD_VAR 0 2
24108: ARRAY
24109: IFFALSE 24151
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
24111: LD_ADDR_EXP 113
24115: PUSH
24116: LD_EXP 113
24120: PPUSH
24121: LD_VAR 0 2
24125: PPUSH
24126: LD_EXP 87
24130: PUSH
24131: LD_VAR 0 2
24135: ARRAY
24136: PUSH
24137: LD_INT 1
24139: ARRAY
24140: PPUSH
24141: CALL_OW 255
24145: PPUSH
24146: CALL_OW 1
24150: ST_TO_ADDR
24151: GO 24096
24153: POP
24154: POP
// end ;
24155: LD_VAR 0 1
24159: RET
// every 0 0$01 trigger skirmish do
24160: LD_EXP 85
24164: IFFALSE 24318
24166: GO 24168
24168: DISABLE
// begin enable ;
24169: ENABLE
// MC_CheckBuildings ( ) ;
24170: CALL 28816 0 0
// MC_CheckPeopleLife ( ) ;
24174: CALL 28941 0 0
// RaiseSailEvent ( 100 ) ;
24178: LD_INT 100
24180: PPUSH
24181: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
24185: LD_INT 103
24187: PPUSH
24188: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
24192: LD_INT 104
24194: PPUSH
24195: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
24199: LD_INT 105
24201: PPUSH
24202: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
24206: LD_INT 106
24208: PPUSH
24209: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
24213: LD_INT 107
24215: PPUSH
24216: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
24220: LD_INT 108
24222: PPUSH
24223: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
24227: LD_INT 109
24229: PPUSH
24230: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
24234: LD_INT 110
24236: PPUSH
24237: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
24241: LD_INT 111
24243: PPUSH
24244: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
24248: LD_INT 112
24250: PPUSH
24251: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
24255: LD_INT 113
24257: PPUSH
24258: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
24262: LD_INT 120
24264: PPUSH
24265: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
24269: LD_INT 121
24271: PPUSH
24272: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
24276: LD_INT 122
24278: PPUSH
24279: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
24283: LD_INT 123
24285: PPUSH
24286: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
24290: LD_INT 124
24292: PPUSH
24293: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
24297: LD_INT 125
24299: PPUSH
24300: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
24304: LD_INT 126
24306: PPUSH
24307: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
24311: LD_INT 200
24313: PPUSH
24314: CALL_OW 427
// end ;
24318: END
// on SailEvent ( event ) do begin if event < 100 then
24319: LD_VAR 0 1
24323: PUSH
24324: LD_INT 100
24326: LESS
24327: IFFALSE 24338
// CustomEvent ( event ) ;
24329: LD_VAR 0 1
24333: PPUSH
24334: CALL 10371 0 1
// if event = 100 then
24338: LD_VAR 0 1
24342: PUSH
24343: LD_INT 100
24345: EQUAL
24346: IFFALSE 24352
// MC_ClassManager ( ) ;
24348: CALL 24744 0 0
// if event = 101 then
24352: LD_VAR 0 1
24356: PUSH
24357: LD_INT 101
24359: EQUAL
24360: IFFALSE 24366
// MC_RepairBuildings ( ) ;
24362: CALL 29537 0 0
// if event = 102 then
24366: LD_VAR 0 1
24370: PUSH
24371: LD_INT 102
24373: EQUAL
24374: IFFALSE 24380
// MC_Heal ( ) ;
24376: CALL 30401 0 0
// if event = 103 then
24380: LD_VAR 0 1
24384: PUSH
24385: LD_INT 103
24387: EQUAL
24388: IFFALSE 24394
// MC_Build ( ) ;
24390: CALL 30823 0 0
// if event = 104 then
24394: LD_VAR 0 1
24398: PUSH
24399: LD_INT 104
24401: EQUAL
24402: IFFALSE 24408
// MC_TurretWeapon ( ) ;
24404: CALL 32436 0 0
// if event = 105 then
24408: LD_VAR 0 1
24412: PUSH
24413: LD_INT 105
24415: EQUAL
24416: IFFALSE 24422
// MC_BuildUpgrade ( ) ;
24418: CALL 31987 0 0
// if event = 106 then
24422: LD_VAR 0 1
24426: PUSH
24427: LD_INT 106
24429: EQUAL
24430: IFFALSE 24436
// MC_PlantMines ( ) ;
24432: CALL 32866 0 0
// if event = 107 then
24436: LD_VAR 0 1
24440: PUSH
24441: LD_INT 107
24443: EQUAL
24444: IFFALSE 24450
// MC_CollectCrates ( ) ;
24446: CALL 33664 0 0
// if event = 108 then
24450: LD_VAR 0 1
24454: PUSH
24455: LD_INT 108
24457: EQUAL
24458: IFFALSE 24464
// MC_LinkRemoteControl ( ) ;
24460: CALL 35440 0 0
// if event = 109 then
24464: LD_VAR 0 1
24468: PUSH
24469: LD_INT 109
24471: EQUAL
24472: IFFALSE 24478
// MC_ProduceVehicle ( ) ;
24474: CALL 35621 0 0
// if event = 110 then
24478: LD_VAR 0 1
24482: PUSH
24483: LD_INT 110
24485: EQUAL
24486: IFFALSE 24492
// MC_SendAttack ( ) ;
24488: CALL 36087 0 0
// if event = 111 then
24492: LD_VAR 0 1
24496: PUSH
24497: LD_INT 111
24499: EQUAL
24500: IFFALSE 24506
// MC_Defend ( ) ;
24502: CALL 36195 0 0
// if event = 112 then
24506: LD_VAR 0 1
24510: PUSH
24511: LD_INT 112
24513: EQUAL
24514: IFFALSE 24520
// MC_Research ( ) ;
24516: CALL 36800 0 0
// if event = 113 then
24520: LD_VAR 0 1
24524: PUSH
24525: LD_INT 113
24527: EQUAL
24528: IFFALSE 24534
// MC_MinesTrigger ( ) ;
24530: CALL 37914 0 0
// if event = 120 then
24534: LD_VAR 0 1
24538: PUSH
24539: LD_INT 120
24541: EQUAL
24542: IFFALSE 24548
// MC_RepairVehicle ( ) ;
24544: CALL 38013 0 0
// if event = 121 then
24548: LD_VAR 0 1
24552: PUSH
24553: LD_INT 121
24555: EQUAL
24556: IFFALSE 24562
// MC_TameApe ( ) ;
24558: CALL 38743 0 0
// if event = 122 then
24562: LD_VAR 0 1
24566: PUSH
24567: LD_INT 122
24569: EQUAL
24570: IFFALSE 24576
// MC_ChangeApeClass ( ) ;
24572: CALL 39572 0 0
// if event = 123 then
24576: LD_VAR 0 1
24580: PUSH
24581: LD_INT 123
24583: EQUAL
24584: IFFALSE 24590
// MC_Bazooka ( ) ;
24586: CALL 40222 0 0
// if event = 124 then
24590: LD_VAR 0 1
24594: PUSH
24595: LD_INT 124
24597: EQUAL
24598: IFFALSE 24604
// MC_TeleportExit ( ) ;
24600: CALL 40420 0 0
// if event = 125 then
24604: LD_VAR 0 1
24608: PUSH
24609: LD_INT 125
24611: EQUAL
24612: IFFALSE 24618
// MC_Deposits ( ) ;
24614: CALL 41067 0 0
// if event = 126 then
24618: LD_VAR 0 1
24622: PUSH
24623: LD_INT 126
24625: EQUAL
24626: IFFALSE 24632
// MC_RemoteDriver ( ) ;
24628: CALL 41692 0 0
// if event = 200 then
24632: LD_VAR 0 1
24636: PUSH
24637: LD_INT 200
24639: EQUAL
24640: IFFALSE 24646
// MC_Idle ( ) ;
24642: CALL 43641 0 0
// end ;
24646: PPOPN 1
24648: END
// export function MC_Reset ( base , tag ) ; var i ; begin
24649: LD_INT 0
24651: PPUSH
24652: PPUSH
// if not mc_bases [ base ] or not tag then
24653: LD_EXP 87
24657: PUSH
24658: LD_VAR 0 1
24662: ARRAY
24663: NOT
24664: PUSH
24665: LD_VAR 0 2
24669: NOT
24670: OR
24671: IFFALSE 24675
// exit ;
24673: GO 24739
// for i in mc_bases [ base ] union mc_ape [ base ] do
24675: LD_ADDR_VAR 0 4
24679: PUSH
24680: LD_EXP 87
24684: PUSH
24685: LD_VAR 0 1
24689: ARRAY
24690: PUSH
24691: LD_EXP 116
24695: PUSH
24696: LD_VAR 0 1
24700: ARRAY
24701: UNION
24702: PUSH
24703: FOR_IN
24704: IFFALSE 24737
// if GetTag ( i ) = tag then
24706: LD_VAR 0 4
24710: PPUSH
24711: CALL_OW 110
24715: PUSH
24716: LD_VAR 0 2
24720: EQUAL
24721: IFFALSE 24735
// SetTag ( i , 0 ) ;
24723: LD_VAR 0 4
24727: PPUSH
24728: LD_INT 0
24730: PPUSH
24731: CALL_OW 109
24735: GO 24703
24737: POP
24738: POP
// end ;
24739: LD_VAR 0 3
24743: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
24744: LD_INT 0
24746: PPUSH
24747: PPUSH
24748: PPUSH
24749: PPUSH
24750: PPUSH
24751: PPUSH
24752: PPUSH
24753: PPUSH
// if not mc_bases then
24754: LD_EXP 87
24758: NOT
24759: IFFALSE 24763
// exit ;
24761: GO 25221
// for i = 1 to mc_bases do
24763: LD_ADDR_VAR 0 2
24767: PUSH
24768: DOUBLE
24769: LD_INT 1
24771: DEC
24772: ST_TO_ADDR
24773: LD_EXP 87
24777: PUSH
24778: FOR_TO
24779: IFFALSE 25219
// begin tmp := MC_ClassCheckReq ( i ) ;
24781: LD_ADDR_VAR 0 4
24785: PUSH
24786: LD_VAR 0 2
24790: PPUSH
24791: CALL 25226 0 1
24795: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
24796: LD_ADDR_EXP 128
24800: PUSH
24801: LD_EXP 128
24805: PPUSH
24806: LD_VAR 0 2
24810: PPUSH
24811: LD_VAR 0 4
24815: PPUSH
24816: CALL_OW 1
24820: ST_TO_ADDR
// if not tmp then
24821: LD_VAR 0 4
24825: NOT
24826: IFFALSE 24830
// continue ;
24828: GO 24778
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
24830: LD_ADDR_VAR 0 6
24834: PUSH
24835: LD_EXP 87
24839: PUSH
24840: LD_VAR 0 2
24844: ARRAY
24845: PPUSH
24846: LD_INT 2
24848: PUSH
24849: LD_INT 30
24851: PUSH
24852: LD_INT 4
24854: PUSH
24855: EMPTY
24856: LIST
24857: LIST
24858: PUSH
24859: LD_INT 30
24861: PUSH
24862: LD_INT 5
24864: PUSH
24865: EMPTY
24866: LIST
24867: LIST
24868: PUSH
24869: EMPTY
24870: LIST
24871: LIST
24872: LIST
24873: PPUSH
24874: CALL_OW 72
24878: PUSH
24879: LD_EXP 87
24883: PUSH
24884: LD_VAR 0 2
24888: ARRAY
24889: PPUSH
24890: LD_INT 2
24892: PUSH
24893: LD_INT 30
24895: PUSH
24896: LD_INT 0
24898: PUSH
24899: EMPTY
24900: LIST
24901: LIST
24902: PUSH
24903: LD_INT 30
24905: PUSH
24906: LD_INT 1
24908: PUSH
24909: EMPTY
24910: LIST
24911: LIST
24912: PUSH
24913: EMPTY
24914: LIST
24915: LIST
24916: LIST
24917: PPUSH
24918: CALL_OW 72
24922: PUSH
24923: LD_EXP 87
24927: PUSH
24928: LD_VAR 0 2
24932: ARRAY
24933: PPUSH
24934: LD_INT 30
24936: PUSH
24937: LD_INT 3
24939: PUSH
24940: EMPTY
24941: LIST
24942: LIST
24943: PPUSH
24944: CALL_OW 72
24948: PUSH
24949: LD_EXP 87
24953: PUSH
24954: LD_VAR 0 2
24958: ARRAY
24959: PPUSH
24960: LD_INT 2
24962: PUSH
24963: LD_INT 30
24965: PUSH
24966: LD_INT 6
24968: PUSH
24969: EMPTY
24970: LIST
24971: LIST
24972: PUSH
24973: LD_INT 30
24975: PUSH
24976: LD_INT 7
24978: PUSH
24979: EMPTY
24980: LIST
24981: LIST
24982: PUSH
24983: LD_INT 30
24985: PUSH
24986: LD_INT 8
24988: PUSH
24989: EMPTY
24990: LIST
24991: LIST
24992: PUSH
24993: EMPTY
24994: LIST
24995: LIST
24996: LIST
24997: LIST
24998: PPUSH
24999: CALL_OW 72
25003: PUSH
25004: EMPTY
25005: LIST
25006: LIST
25007: LIST
25008: LIST
25009: ST_TO_ADDR
// for j = 1 to 4 do
25010: LD_ADDR_VAR 0 3
25014: PUSH
25015: DOUBLE
25016: LD_INT 1
25018: DEC
25019: ST_TO_ADDR
25020: LD_INT 4
25022: PUSH
25023: FOR_TO
25024: IFFALSE 25215
// begin if not tmp [ j ] then
25026: LD_VAR 0 4
25030: PUSH
25031: LD_VAR 0 3
25035: ARRAY
25036: NOT
25037: IFFALSE 25041
// continue ;
25039: GO 25023
// for p in tmp [ j ] do
25041: LD_ADDR_VAR 0 5
25045: PUSH
25046: LD_VAR 0 4
25050: PUSH
25051: LD_VAR 0 3
25055: ARRAY
25056: PUSH
25057: FOR_IN
25058: IFFALSE 25211
// begin if not b [ j ] then
25060: LD_VAR 0 6
25064: PUSH
25065: LD_VAR 0 3
25069: ARRAY
25070: NOT
25071: IFFALSE 25075
// break ;
25073: GO 25211
// e := 0 ;
25075: LD_ADDR_VAR 0 7
25079: PUSH
25080: LD_INT 0
25082: ST_TO_ADDR
// for k in b [ j ] do
25083: LD_ADDR_VAR 0 8
25087: PUSH
25088: LD_VAR 0 6
25092: PUSH
25093: LD_VAR 0 3
25097: ARRAY
25098: PUSH
25099: FOR_IN
25100: IFFALSE 25127
// if IsNotFull ( k ) then
25102: LD_VAR 0 8
25106: PPUSH
25107: CALL 55233 0 1
25111: IFFALSE 25125
// begin e := k ;
25113: LD_ADDR_VAR 0 7
25117: PUSH
25118: LD_VAR 0 8
25122: ST_TO_ADDR
// break ;
25123: GO 25127
// end ;
25125: GO 25099
25127: POP
25128: POP
// if e and not UnitGoingToBuilding ( p , e ) then
25129: LD_VAR 0 7
25133: PUSH
25134: LD_VAR 0 5
25138: PPUSH
25139: LD_VAR 0 7
25143: PPUSH
25144: CALL 92362 0 2
25148: NOT
25149: AND
25150: IFFALSE 25209
// begin if IsInUnit ( p ) then
25152: LD_VAR 0 5
25156: PPUSH
25157: CALL_OW 310
25161: IFFALSE 25172
// ComExitBuilding ( p ) ;
25163: LD_VAR 0 5
25167: PPUSH
25168: CALL_OW 122
// ComEnterUnit ( p , e ) ;
25172: LD_VAR 0 5
25176: PPUSH
25177: LD_VAR 0 7
25181: PPUSH
25182: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
25186: LD_VAR 0 5
25190: PPUSH
25191: LD_VAR 0 3
25195: PPUSH
25196: CALL_OW 183
// AddComExitBuilding ( p ) ;
25200: LD_VAR 0 5
25204: PPUSH
25205: CALL_OW 182
// end ; end ;
25209: GO 25057
25211: POP
25212: POP
// end ;
25213: GO 25023
25215: POP
25216: POP
// end ;
25217: GO 24778
25219: POP
25220: POP
// end ;
25221: LD_VAR 0 1
25225: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
25226: LD_INT 0
25228: PPUSH
25229: PPUSH
25230: PPUSH
25231: PPUSH
25232: PPUSH
25233: PPUSH
25234: PPUSH
25235: PPUSH
25236: PPUSH
25237: PPUSH
25238: PPUSH
25239: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
25240: LD_VAR 0 1
25244: NOT
25245: PUSH
25246: LD_EXP 87
25250: PUSH
25251: LD_VAR 0 1
25255: ARRAY
25256: NOT
25257: OR
25258: PUSH
25259: LD_EXP 87
25263: PUSH
25264: LD_VAR 0 1
25268: ARRAY
25269: PPUSH
25270: LD_INT 2
25272: PUSH
25273: LD_INT 30
25275: PUSH
25276: LD_INT 0
25278: PUSH
25279: EMPTY
25280: LIST
25281: LIST
25282: PUSH
25283: LD_INT 30
25285: PUSH
25286: LD_INT 1
25288: PUSH
25289: EMPTY
25290: LIST
25291: LIST
25292: PUSH
25293: EMPTY
25294: LIST
25295: LIST
25296: LIST
25297: PPUSH
25298: CALL_OW 72
25302: NOT
25303: OR
25304: IFFALSE 25308
// exit ;
25306: GO 28811
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25308: LD_ADDR_VAR 0 4
25312: PUSH
25313: LD_EXP 87
25317: PUSH
25318: LD_VAR 0 1
25322: ARRAY
25323: PPUSH
25324: LD_INT 2
25326: PUSH
25327: LD_INT 25
25329: PUSH
25330: LD_INT 1
25332: PUSH
25333: EMPTY
25334: LIST
25335: LIST
25336: PUSH
25337: LD_INT 25
25339: PUSH
25340: LD_INT 2
25342: PUSH
25343: EMPTY
25344: LIST
25345: LIST
25346: PUSH
25347: LD_INT 25
25349: PUSH
25350: LD_INT 3
25352: PUSH
25353: EMPTY
25354: LIST
25355: LIST
25356: PUSH
25357: LD_INT 25
25359: PUSH
25360: LD_INT 4
25362: PUSH
25363: EMPTY
25364: LIST
25365: LIST
25366: PUSH
25367: LD_INT 25
25369: PUSH
25370: LD_INT 5
25372: PUSH
25373: EMPTY
25374: LIST
25375: LIST
25376: PUSH
25377: LD_INT 25
25379: PUSH
25380: LD_INT 8
25382: PUSH
25383: EMPTY
25384: LIST
25385: LIST
25386: PUSH
25387: LD_INT 25
25389: PUSH
25390: LD_INT 9
25392: PUSH
25393: EMPTY
25394: LIST
25395: LIST
25396: PUSH
25397: EMPTY
25398: LIST
25399: LIST
25400: LIST
25401: LIST
25402: LIST
25403: LIST
25404: LIST
25405: LIST
25406: PPUSH
25407: CALL_OW 72
25411: ST_TO_ADDR
// if not tmp then
25412: LD_VAR 0 4
25416: NOT
25417: IFFALSE 25421
// exit ;
25419: GO 28811
// for i in tmp do
25421: LD_ADDR_VAR 0 3
25425: PUSH
25426: LD_VAR 0 4
25430: PUSH
25431: FOR_IN
25432: IFFALSE 25463
// if GetTag ( i ) then
25434: LD_VAR 0 3
25438: PPUSH
25439: CALL_OW 110
25443: IFFALSE 25461
// tmp := tmp diff i ;
25445: LD_ADDR_VAR 0 4
25449: PUSH
25450: LD_VAR 0 4
25454: PUSH
25455: LD_VAR 0 3
25459: DIFF
25460: ST_TO_ADDR
25461: GO 25431
25463: POP
25464: POP
// if not tmp then
25465: LD_VAR 0 4
25469: NOT
25470: IFFALSE 25474
// exit ;
25472: GO 28811
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25474: LD_ADDR_VAR 0 5
25478: PUSH
25479: LD_EXP 87
25483: PUSH
25484: LD_VAR 0 1
25488: ARRAY
25489: PPUSH
25490: LD_INT 2
25492: PUSH
25493: LD_INT 25
25495: PUSH
25496: LD_INT 1
25498: PUSH
25499: EMPTY
25500: LIST
25501: LIST
25502: PUSH
25503: LD_INT 25
25505: PUSH
25506: LD_INT 5
25508: PUSH
25509: EMPTY
25510: LIST
25511: LIST
25512: PUSH
25513: LD_INT 25
25515: PUSH
25516: LD_INT 8
25518: PUSH
25519: EMPTY
25520: LIST
25521: LIST
25522: PUSH
25523: LD_INT 25
25525: PUSH
25526: LD_INT 9
25528: PUSH
25529: EMPTY
25530: LIST
25531: LIST
25532: PUSH
25533: EMPTY
25534: LIST
25535: LIST
25536: LIST
25537: LIST
25538: LIST
25539: PPUSH
25540: CALL_OW 72
25544: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
25545: LD_ADDR_VAR 0 6
25549: PUSH
25550: LD_EXP 87
25554: PUSH
25555: LD_VAR 0 1
25559: ARRAY
25560: PPUSH
25561: LD_INT 25
25563: PUSH
25564: LD_INT 2
25566: PUSH
25567: EMPTY
25568: LIST
25569: LIST
25570: PPUSH
25571: CALL_OW 72
25575: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
25576: LD_ADDR_VAR 0 7
25580: PUSH
25581: LD_EXP 87
25585: PUSH
25586: LD_VAR 0 1
25590: ARRAY
25591: PPUSH
25592: LD_INT 25
25594: PUSH
25595: LD_INT 3
25597: PUSH
25598: EMPTY
25599: LIST
25600: LIST
25601: PPUSH
25602: CALL_OW 72
25606: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
25607: LD_ADDR_VAR 0 8
25611: PUSH
25612: LD_EXP 87
25616: PUSH
25617: LD_VAR 0 1
25621: ARRAY
25622: PPUSH
25623: LD_INT 25
25625: PUSH
25626: LD_INT 4
25628: PUSH
25629: EMPTY
25630: LIST
25631: LIST
25632: PUSH
25633: LD_INT 24
25635: PUSH
25636: LD_INT 251
25638: PUSH
25639: EMPTY
25640: LIST
25641: LIST
25642: PUSH
25643: EMPTY
25644: LIST
25645: LIST
25646: PPUSH
25647: CALL_OW 72
25651: ST_TO_ADDR
// if mc_scan [ base ] then
25652: LD_EXP 110
25656: PUSH
25657: LD_VAR 0 1
25661: ARRAY
25662: IFFALSE 26123
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
25664: LD_ADDR_EXP 129
25668: PUSH
25669: LD_EXP 129
25673: PPUSH
25674: LD_VAR 0 1
25678: PPUSH
25679: LD_INT 4
25681: PPUSH
25682: CALL_OW 1
25686: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
25687: LD_ADDR_VAR 0 12
25691: PUSH
25692: LD_EXP 87
25696: PUSH
25697: LD_VAR 0 1
25701: ARRAY
25702: PPUSH
25703: LD_INT 2
25705: PUSH
25706: LD_INT 30
25708: PUSH
25709: LD_INT 4
25711: PUSH
25712: EMPTY
25713: LIST
25714: LIST
25715: PUSH
25716: LD_INT 30
25718: PUSH
25719: LD_INT 5
25721: PUSH
25722: EMPTY
25723: LIST
25724: LIST
25725: PUSH
25726: EMPTY
25727: LIST
25728: LIST
25729: LIST
25730: PPUSH
25731: CALL_OW 72
25735: ST_TO_ADDR
// if not b then
25736: LD_VAR 0 12
25740: NOT
25741: IFFALSE 25745
// exit ;
25743: GO 28811
// p := [ ] ;
25745: LD_ADDR_VAR 0 11
25749: PUSH
25750: EMPTY
25751: ST_TO_ADDR
// if sci >= 2 then
25752: LD_VAR 0 8
25756: PUSH
25757: LD_INT 2
25759: GREATEREQUAL
25760: IFFALSE 25791
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
25762: LD_ADDR_VAR 0 8
25766: PUSH
25767: LD_VAR 0 8
25771: PUSH
25772: LD_INT 1
25774: ARRAY
25775: PUSH
25776: LD_VAR 0 8
25780: PUSH
25781: LD_INT 2
25783: ARRAY
25784: PUSH
25785: EMPTY
25786: LIST
25787: LIST
25788: ST_TO_ADDR
25789: GO 25852
// if sci = 1 then
25791: LD_VAR 0 8
25795: PUSH
25796: LD_INT 1
25798: EQUAL
25799: IFFALSE 25820
// sci := [ sci [ 1 ] ] else
25801: LD_ADDR_VAR 0 8
25805: PUSH
25806: LD_VAR 0 8
25810: PUSH
25811: LD_INT 1
25813: ARRAY
25814: PUSH
25815: EMPTY
25816: LIST
25817: ST_TO_ADDR
25818: GO 25852
// if sci = 0 then
25820: LD_VAR 0 8
25824: PUSH
25825: LD_INT 0
25827: EQUAL
25828: IFFALSE 25852
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
25830: LD_ADDR_VAR 0 11
25834: PUSH
25835: LD_VAR 0 4
25839: PPUSH
25840: LD_INT 4
25842: PPUSH
25843: CALL 92225 0 2
25847: PUSH
25848: LD_INT 1
25850: ARRAY
25851: ST_TO_ADDR
// if eng > 4 then
25852: LD_VAR 0 6
25856: PUSH
25857: LD_INT 4
25859: GREATER
25860: IFFALSE 25906
// for i = eng downto 4 do
25862: LD_ADDR_VAR 0 3
25866: PUSH
25867: DOUBLE
25868: LD_VAR 0 6
25872: INC
25873: ST_TO_ADDR
25874: LD_INT 4
25876: PUSH
25877: FOR_DOWNTO
25878: IFFALSE 25904
// eng := eng diff eng [ i ] ;
25880: LD_ADDR_VAR 0 6
25884: PUSH
25885: LD_VAR 0 6
25889: PUSH
25890: LD_VAR 0 6
25894: PUSH
25895: LD_VAR 0 3
25899: ARRAY
25900: DIFF
25901: ST_TO_ADDR
25902: GO 25877
25904: POP
25905: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
25906: LD_ADDR_VAR 0 4
25910: PUSH
25911: LD_VAR 0 4
25915: PUSH
25916: LD_VAR 0 5
25920: PUSH
25921: LD_VAR 0 6
25925: UNION
25926: PUSH
25927: LD_VAR 0 7
25931: UNION
25932: PUSH
25933: LD_VAR 0 8
25937: UNION
25938: DIFF
25939: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
25940: LD_ADDR_VAR 0 13
25944: PUSH
25945: LD_EXP 87
25949: PUSH
25950: LD_VAR 0 1
25954: ARRAY
25955: PPUSH
25956: LD_INT 2
25958: PUSH
25959: LD_INT 30
25961: PUSH
25962: LD_INT 32
25964: PUSH
25965: EMPTY
25966: LIST
25967: LIST
25968: PUSH
25969: LD_INT 30
25971: PUSH
25972: LD_INT 31
25974: PUSH
25975: EMPTY
25976: LIST
25977: LIST
25978: PUSH
25979: EMPTY
25980: LIST
25981: LIST
25982: LIST
25983: PPUSH
25984: CALL_OW 72
25988: PUSH
25989: LD_EXP 87
25993: PUSH
25994: LD_VAR 0 1
25998: ARRAY
25999: PPUSH
26000: LD_INT 2
26002: PUSH
26003: LD_INT 30
26005: PUSH
26006: LD_INT 4
26008: PUSH
26009: EMPTY
26010: LIST
26011: LIST
26012: PUSH
26013: LD_INT 30
26015: PUSH
26016: LD_INT 5
26018: PUSH
26019: EMPTY
26020: LIST
26021: LIST
26022: PUSH
26023: EMPTY
26024: LIST
26025: LIST
26026: LIST
26027: PPUSH
26028: CALL_OW 72
26032: PUSH
26033: LD_INT 6
26035: MUL
26036: PLUS
26037: ST_TO_ADDR
// if bcount < tmp then
26038: LD_VAR 0 13
26042: PUSH
26043: LD_VAR 0 4
26047: LESS
26048: IFFALSE 26094
// for i = tmp downto bcount do
26050: LD_ADDR_VAR 0 3
26054: PUSH
26055: DOUBLE
26056: LD_VAR 0 4
26060: INC
26061: ST_TO_ADDR
26062: LD_VAR 0 13
26066: PUSH
26067: FOR_DOWNTO
26068: IFFALSE 26092
// tmp := Delete ( tmp , tmp ) ;
26070: LD_ADDR_VAR 0 4
26074: PUSH
26075: LD_VAR 0 4
26079: PPUSH
26080: LD_VAR 0 4
26084: PPUSH
26085: CALL_OW 3
26089: ST_TO_ADDR
26090: GO 26067
26092: POP
26093: POP
// result := [ tmp , 0 , 0 , p ] ;
26094: LD_ADDR_VAR 0 2
26098: PUSH
26099: LD_VAR 0 4
26103: PUSH
26104: LD_INT 0
26106: PUSH
26107: LD_INT 0
26109: PUSH
26110: LD_VAR 0 11
26114: PUSH
26115: EMPTY
26116: LIST
26117: LIST
26118: LIST
26119: LIST
26120: ST_TO_ADDR
// exit ;
26121: GO 28811
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26123: LD_EXP 87
26127: PUSH
26128: LD_VAR 0 1
26132: ARRAY
26133: PPUSH
26134: LD_INT 2
26136: PUSH
26137: LD_INT 30
26139: PUSH
26140: LD_INT 6
26142: PUSH
26143: EMPTY
26144: LIST
26145: LIST
26146: PUSH
26147: LD_INT 30
26149: PUSH
26150: LD_INT 7
26152: PUSH
26153: EMPTY
26154: LIST
26155: LIST
26156: PUSH
26157: LD_INT 30
26159: PUSH
26160: LD_INT 8
26162: PUSH
26163: EMPTY
26164: LIST
26165: LIST
26166: PUSH
26167: EMPTY
26168: LIST
26169: LIST
26170: LIST
26171: LIST
26172: PPUSH
26173: CALL_OW 72
26177: NOT
26178: PUSH
26179: LD_EXP 87
26183: PUSH
26184: LD_VAR 0 1
26188: ARRAY
26189: PPUSH
26190: LD_INT 30
26192: PUSH
26193: LD_INT 3
26195: PUSH
26196: EMPTY
26197: LIST
26198: LIST
26199: PPUSH
26200: CALL_OW 72
26204: NOT
26205: AND
26206: IFFALSE 26278
// begin if eng = tmp then
26208: LD_VAR 0 6
26212: PUSH
26213: LD_VAR 0 4
26217: EQUAL
26218: IFFALSE 26222
// exit ;
26220: GO 28811
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
26222: LD_ADDR_EXP 129
26226: PUSH
26227: LD_EXP 129
26231: PPUSH
26232: LD_VAR 0 1
26236: PPUSH
26237: LD_INT 1
26239: PPUSH
26240: CALL_OW 1
26244: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
26245: LD_ADDR_VAR 0 2
26249: PUSH
26250: LD_INT 0
26252: PUSH
26253: LD_VAR 0 4
26257: PUSH
26258: LD_VAR 0 6
26262: DIFF
26263: PUSH
26264: LD_INT 0
26266: PUSH
26267: LD_INT 0
26269: PUSH
26270: EMPTY
26271: LIST
26272: LIST
26273: LIST
26274: LIST
26275: ST_TO_ADDR
// exit ;
26276: GO 28811
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26278: LD_EXP 114
26282: PUSH
26283: LD_EXP 113
26287: PUSH
26288: LD_VAR 0 1
26292: ARRAY
26293: ARRAY
26294: PUSH
26295: LD_EXP 87
26299: PUSH
26300: LD_VAR 0 1
26304: ARRAY
26305: PPUSH
26306: LD_INT 2
26308: PUSH
26309: LD_INT 30
26311: PUSH
26312: LD_INT 6
26314: PUSH
26315: EMPTY
26316: LIST
26317: LIST
26318: PUSH
26319: LD_INT 30
26321: PUSH
26322: LD_INT 7
26324: PUSH
26325: EMPTY
26326: LIST
26327: LIST
26328: PUSH
26329: LD_INT 30
26331: PUSH
26332: LD_INT 8
26334: PUSH
26335: EMPTY
26336: LIST
26337: LIST
26338: PUSH
26339: EMPTY
26340: LIST
26341: LIST
26342: LIST
26343: LIST
26344: PPUSH
26345: CALL_OW 72
26349: AND
26350: PUSH
26351: LD_EXP 87
26355: PUSH
26356: LD_VAR 0 1
26360: ARRAY
26361: PPUSH
26362: LD_INT 30
26364: PUSH
26365: LD_INT 3
26367: PUSH
26368: EMPTY
26369: LIST
26370: LIST
26371: PPUSH
26372: CALL_OW 72
26376: NOT
26377: AND
26378: IFFALSE 26592
// begin if sci >= 6 then
26380: LD_VAR 0 8
26384: PUSH
26385: LD_INT 6
26387: GREATEREQUAL
26388: IFFALSE 26392
// exit ;
26390: GO 28811
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
26392: LD_ADDR_EXP 129
26396: PUSH
26397: LD_EXP 129
26401: PPUSH
26402: LD_VAR 0 1
26406: PPUSH
26407: LD_INT 2
26409: PPUSH
26410: CALL_OW 1
26414: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
26415: LD_ADDR_VAR 0 9
26419: PUSH
26420: LD_VAR 0 4
26424: PUSH
26425: LD_VAR 0 8
26429: DIFF
26430: PPUSH
26431: LD_INT 4
26433: PPUSH
26434: CALL 92225 0 2
26438: ST_TO_ADDR
// p := [ ] ;
26439: LD_ADDR_VAR 0 11
26443: PUSH
26444: EMPTY
26445: ST_TO_ADDR
// if sci < 6 and sort > 6 then
26446: LD_VAR 0 8
26450: PUSH
26451: LD_INT 6
26453: LESS
26454: PUSH
26455: LD_VAR 0 9
26459: PUSH
26460: LD_INT 6
26462: GREATER
26463: AND
26464: IFFALSE 26545
// begin for i = 1 to 6 - sci do
26466: LD_ADDR_VAR 0 3
26470: PUSH
26471: DOUBLE
26472: LD_INT 1
26474: DEC
26475: ST_TO_ADDR
26476: LD_INT 6
26478: PUSH
26479: LD_VAR 0 8
26483: MINUS
26484: PUSH
26485: FOR_TO
26486: IFFALSE 26541
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
26488: LD_ADDR_VAR 0 11
26492: PUSH
26493: LD_VAR 0 11
26497: PPUSH
26498: LD_VAR 0 11
26502: PUSH
26503: LD_INT 1
26505: PLUS
26506: PPUSH
26507: LD_VAR 0 9
26511: PUSH
26512: LD_INT 1
26514: ARRAY
26515: PPUSH
26516: CALL_OW 2
26520: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
26521: LD_ADDR_VAR 0 9
26525: PUSH
26526: LD_VAR 0 9
26530: PPUSH
26531: LD_INT 1
26533: PPUSH
26534: CALL_OW 3
26538: ST_TO_ADDR
// end ;
26539: GO 26485
26541: POP
26542: POP
// end else
26543: GO 26565
// if sort then
26545: LD_VAR 0 9
26549: IFFALSE 26565
// p := sort [ 1 ] ;
26551: LD_ADDR_VAR 0 11
26555: PUSH
26556: LD_VAR 0 9
26560: PUSH
26561: LD_INT 1
26563: ARRAY
26564: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
26565: LD_ADDR_VAR 0 2
26569: PUSH
26570: LD_INT 0
26572: PUSH
26573: LD_INT 0
26575: PUSH
26576: LD_INT 0
26578: PUSH
26579: LD_VAR 0 11
26583: PUSH
26584: EMPTY
26585: LIST
26586: LIST
26587: LIST
26588: LIST
26589: ST_TO_ADDR
// exit ;
26590: GO 28811
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26592: LD_EXP 114
26596: PUSH
26597: LD_EXP 113
26601: PUSH
26602: LD_VAR 0 1
26606: ARRAY
26607: ARRAY
26608: PUSH
26609: LD_EXP 87
26613: PUSH
26614: LD_VAR 0 1
26618: ARRAY
26619: PPUSH
26620: LD_INT 2
26622: PUSH
26623: LD_INT 30
26625: PUSH
26626: LD_INT 6
26628: PUSH
26629: EMPTY
26630: LIST
26631: LIST
26632: PUSH
26633: LD_INT 30
26635: PUSH
26636: LD_INT 7
26638: PUSH
26639: EMPTY
26640: LIST
26641: LIST
26642: PUSH
26643: LD_INT 30
26645: PUSH
26646: LD_INT 8
26648: PUSH
26649: EMPTY
26650: LIST
26651: LIST
26652: PUSH
26653: EMPTY
26654: LIST
26655: LIST
26656: LIST
26657: LIST
26658: PPUSH
26659: CALL_OW 72
26663: AND
26664: PUSH
26665: LD_EXP 87
26669: PUSH
26670: LD_VAR 0 1
26674: ARRAY
26675: PPUSH
26676: LD_INT 30
26678: PUSH
26679: LD_INT 3
26681: PUSH
26682: EMPTY
26683: LIST
26684: LIST
26685: PPUSH
26686: CALL_OW 72
26690: AND
26691: IFFALSE 27425
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
26693: LD_ADDR_EXP 129
26697: PUSH
26698: LD_EXP 129
26702: PPUSH
26703: LD_VAR 0 1
26707: PPUSH
26708: LD_INT 3
26710: PPUSH
26711: CALL_OW 1
26715: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
26716: LD_ADDR_VAR 0 2
26720: PUSH
26721: LD_INT 0
26723: PUSH
26724: LD_INT 0
26726: PUSH
26727: LD_INT 0
26729: PUSH
26730: LD_INT 0
26732: PUSH
26733: EMPTY
26734: LIST
26735: LIST
26736: LIST
26737: LIST
26738: ST_TO_ADDR
// if not eng then
26739: LD_VAR 0 6
26743: NOT
26744: IFFALSE 26807
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
26746: LD_ADDR_VAR 0 11
26750: PUSH
26751: LD_VAR 0 4
26755: PPUSH
26756: LD_INT 2
26758: PPUSH
26759: CALL 92225 0 2
26763: PUSH
26764: LD_INT 1
26766: ARRAY
26767: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
26768: LD_ADDR_VAR 0 2
26772: PUSH
26773: LD_VAR 0 2
26777: PPUSH
26778: LD_INT 2
26780: PPUSH
26781: LD_VAR 0 11
26785: PPUSH
26786: CALL_OW 1
26790: ST_TO_ADDR
// tmp := tmp diff p ;
26791: LD_ADDR_VAR 0 4
26795: PUSH
26796: LD_VAR 0 4
26800: PUSH
26801: LD_VAR 0 11
26805: DIFF
26806: ST_TO_ADDR
// end ; if tmp and sci < 6 then
26807: LD_VAR 0 4
26811: PUSH
26812: LD_VAR 0 8
26816: PUSH
26817: LD_INT 6
26819: LESS
26820: AND
26821: IFFALSE 27009
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
26823: LD_ADDR_VAR 0 9
26827: PUSH
26828: LD_VAR 0 4
26832: PUSH
26833: LD_VAR 0 8
26837: PUSH
26838: LD_VAR 0 7
26842: UNION
26843: DIFF
26844: PPUSH
26845: LD_INT 4
26847: PPUSH
26848: CALL 92225 0 2
26852: ST_TO_ADDR
// p := [ ] ;
26853: LD_ADDR_VAR 0 11
26857: PUSH
26858: EMPTY
26859: ST_TO_ADDR
// if sort then
26860: LD_VAR 0 9
26864: IFFALSE 26980
// for i = 1 to 6 - sci do
26866: LD_ADDR_VAR 0 3
26870: PUSH
26871: DOUBLE
26872: LD_INT 1
26874: DEC
26875: ST_TO_ADDR
26876: LD_INT 6
26878: PUSH
26879: LD_VAR 0 8
26883: MINUS
26884: PUSH
26885: FOR_TO
26886: IFFALSE 26978
// begin if i = sort then
26888: LD_VAR 0 3
26892: PUSH
26893: LD_VAR 0 9
26897: EQUAL
26898: IFFALSE 26902
// break ;
26900: GO 26978
// if GetClass ( i ) = 4 then
26902: LD_VAR 0 3
26906: PPUSH
26907: CALL_OW 257
26911: PUSH
26912: LD_INT 4
26914: EQUAL
26915: IFFALSE 26919
// continue ;
26917: GO 26885
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26919: LD_ADDR_VAR 0 11
26923: PUSH
26924: LD_VAR 0 11
26928: PPUSH
26929: LD_VAR 0 11
26933: PUSH
26934: LD_INT 1
26936: PLUS
26937: PPUSH
26938: LD_VAR 0 9
26942: PUSH
26943: LD_VAR 0 3
26947: ARRAY
26948: PPUSH
26949: CALL_OW 2
26953: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26954: LD_ADDR_VAR 0 4
26958: PUSH
26959: LD_VAR 0 4
26963: PUSH
26964: LD_VAR 0 9
26968: PUSH
26969: LD_VAR 0 3
26973: ARRAY
26974: DIFF
26975: ST_TO_ADDR
// end ;
26976: GO 26885
26978: POP
26979: POP
// if p then
26980: LD_VAR 0 11
26984: IFFALSE 27009
// result := Replace ( result , 4 , p ) ;
26986: LD_ADDR_VAR 0 2
26990: PUSH
26991: LD_VAR 0 2
26995: PPUSH
26996: LD_INT 4
26998: PPUSH
26999: LD_VAR 0 11
27003: PPUSH
27004: CALL_OW 1
27008: ST_TO_ADDR
// end ; if tmp and mech < 6 then
27009: LD_VAR 0 4
27013: PUSH
27014: LD_VAR 0 7
27018: PUSH
27019: LD_INT 6
27021: LESS
27022: AND
27023: IFFALSE 27211
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27025: LD_ADDR_VAR 0 9
27029: PUSH
27030: LD_VAR 0 4
27034: PUSH
27035: LD_VAR 0 8
27039: PUSH
27040: LD_VAR 0 7
27044: UNION
27045: DIFF
27046: PPUSH
27047: LD_INT 3
27049: PPUSH
27050: CALL 92225 0 2
27054: ST_TO_ADDR
// p := [ ] ;
27055: LD_ADDR_VAR 0 11
27059: PUSH
27060: EMPTY
27061: ST_TO_ADDR
// if sort then
27062: LD_VAR 0 9
27066: IFFALSE 27182
// for i = 1 to 6 - mech do
27068: LD_ADDR_VAR 0 3
27072: PUSH
27073: DOUBLE
27074: LD_INT 1
27076: DEC
27077: ST_TO_ADDR
27078: LD_INT 6
27080: PUSH
27081: LD_VAR 0 7
27085: MINUS
27086: PUSH
27087: FOR_TO
27088: IFFALSE 27180
// begin if i = sort then
27090: LD_VAR 0 3
27094: PUSH
27095: LD_VAR 0 9
27099: EQUAL
27100: IFFALSE 27104
// break ;
27102: GO 27180
// if GetClass ( i ) = 3 then
27104: LD_VAR 0 3
27108: PPUSH
27109: CALL_OW 257
27113: PUSH
27114: LD_INT 3
27116: EQUAL
27117: IFFALSE 27121
// continue ;
27119: GO 27087
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27121: LD_ADDR_VAR 0 11
27125: PUSH
27126: LD_VAR 0 11
27130: PPUSH
27131: LD_VAR 0 11
27135: PUSH
27136: LD_INT 1
27138: PLUS
27139: PPUSH
27140: LD_VAR 0 9
27144: PUSH
27145: LD_VAR 0 3
27149: ARRAY
27150: PPUSH
27151: CALL_OW 2
27155: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27156: LD_ADDR_VAR 0 4
27160: PUSH
27161: LD_VAR 0 4
27165: PUSH
27166: LD_VAR 0 9
27170: PUSH
27171: LD_VAR 0 3
27175: ARRAY
27176: DIFF
27177: ST_TO_ADDR
// end ;
27178: GO 27087
27180: POP
27181: POP
// if p then
27182: LD_VAR 0 11
27186: IFFALSE 27211
// result := Replace ( result , 3 , p ) ;
27188: LD_ADDR_VAR 0 2
27192: PUSH
27193: LD_VAR 0 2
27197: PPUSH
27198: LD_INT 3
27200: PPUSH
27201: LD_VAR 0 11
27205: PPUSH
27206: CALL_OW 1
27210: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
27211: LD_VAR 0 4
27215: PUSH
27216: LD_INT 6
27218: GREATER
27219: PUSH
27220: LD_VAR 0 6
27224: PUSH
27225: LD_INT 6
27227: LESS
27228: AND
27229: IFFALSE 27423
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
27231: LD_ADDR_VAR 0 9
27235: PUSH
27236: LD_VAR 0 4
27240: PUSH
27241: LD_VAR 0 8
27245: PUSH
27246: LD_VAR 0 7
27250: UNION
27251: PUSH
27252: LD_VAR 0 6
27256: UNION
27257: DIFF
27258: PPUSH
27259: LD_INT 2
27261: PPUSH
27262: CALL 92225 0 2
27266: ST_TO_ADDR
// p := [ ] ;
27267: LD_ADDR_VAR 0 11
27271: PUSH
27272: EMPTY
27273: ST_TO_ADDR
// if sort then
27274: LD_VAR 0 9
27278: IFFALSE 27394
// for i = 1 to 6 - eng do
27280: LD_ADDR_VAR 0 3
27284: PUSH
27285: DOUBLE
27286: LD_INT 1
27288: DEC
27289: ST_TO_ADDR
27290: LD_INT 6
27292: PUSH
27293: LD_VAR 0 6
27297: MINUS
27298: PUSH
27299: FOR_TO
27300: IFFALSE 27392
// begin if i = sort then
27302: LD_VAR 0 3
27306: PUSH
27307: LD_VAR 0 9
27311: EQUAL
27312: IFFALSE 27316
// break ;
27314: GO 27392
// if GetClass ( i ) = 2 then
27316: LD_VAR 0 3
27320: PPUSH
27321: CALL_OW 257
27325: PUSH
27326: LD_INT 2
27328: EQUAL
27329: IFFALSE 27333
// continue ;
27331: GO 27299
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27333: LD_ADDR_VAR 0 11
27337: PUSH
27338: LD_VAR 0 11
27342: PPUSH
27343: LD_VAR 0 11
27347: PUSH
27348: LD_INT 1
27350: PLUS
27351: PPUSH
27352: LD_VAR 0 9
27356: PUSH
27357: LD_VAR 0 3
27361: ARRAY
27362: PPUSH
27363: CALL_OW 2
27367: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27368: LD_ADDR_VAR 0 4
27372: PUSH
27373: LD_VAR 0 4
27377: PUSH
27378: LD_VAR 0 9
27382: PUSH
27383: LD_VAR 0 3
27387: ARRAY
27388: DIFF
27389: ST_TO_ADDR
// end ;
27390: GO 27299
27392: POP
27393: POP
// if p then
27394: LD_VAR 0 11
27398: IFFALSE 27423
// result := Replace ( result , 2 , p ) ;
27400: LD_ADDR_VAR 0 2
27404: PUSH
27405: LD_VAR 0 2
27409: PPUSH
27410: LD_INT 2
27412: PPUSH
27413: LD_VAR 0 11
27417: PPUSH
27418: CALL_OW 1
27422: ST_TO_ADDR
// end ; exit ;
27423: GO 28811
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
27425: LD_EXP 114
27429: PUSH
27430: LD_EXP 113
27434: PUSH
27435: LD_VAR 0 1
27439: ARRAY
27440: ARRAY
27441: NOT
27442: PUSH
27443: LD_EXP 87
27447: PUSH
27448: LD_VAR 0 1
27452: ARRAY
27453: PPUSH
27454: LD_INT 30
27456: PUSH
27457: LD_INT 3
27459: PUSH
27460: EMPTY
27461: LIST
27462: LIST
27463: PPUSH
27464: CALL_OW 72
27468: AND
27469: PUSH
27470: LD_EXP 92
27474: PUSH
27475: LD_VAR 0 1
27479: ARRAY
27480: AND
27481: IFFALSE 28089
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
27483: LD_ADDR_EXP 129
27487: PUSH
27488: LD_EXP 129
27492: PPUSH
27493: LD_VAR 0 1
27497: PPUSH
27498: LD_INT 5
27500: PPUSH
27501: CALL_OW 1
27505: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27506: LD_ADDR_VAR 0 2
27510: PUSH
27511: LD_INT 0
27513: PUSH
27514: LD_INT 0
27516: PUSH
27517: LD_INT 0
27519: PUSH
27520: LD_INT 0
27522: PUSH
27523: EMPTY
27524: LIST
27525: LIST
27526: LIST
27527: LIST
27528: ST_TO_ADDR
// if sci > 1 then
27529: LD_VAR 0 8
27533: PUSH
27534: LD_INT 1
27536: GREATER
27537: IFFALSE 27565
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
27539: LD_ADDR_VAR 0 4
27543: PUSH
27544: LD_VAR 0 4
27548: PUSH
27549: LD_VAR 0 8
27553: PUSH
27554: LD_VAR 0 8
27558: PUSH
27559: LD_INT 1
27561: ARRAY
27562: DIFF
27563: DIFF
27564: ST_TO_ADDR
// if tmp and not sci then
27565: LD_VAR 0 4
27569: PUSH
27570: LD_VAR 0 8
27574: NOT
27575: AND
27576: IFFALSE 27645
// begin sort := SortBySkill ( tmp , 4 ) ;
27578: LD_ADDR_VAR 0 9
27582: PUSH
27583: LD_VAR 0 4
27587: PPUSH
27588: LD_INT 4
27590: PPUSH
27591: CALL 92225 0 2
27595: ST_TO_ADDR
// if sort then
27596: LD_VAR 0 9
27600: IFFALSE 27616
// p := sort [ 1 ] ;
27602: LD_ADDR_VAR 0 11
27606: PUSH
27607: LD_VAR 0 9
27611: PUSH
27612: LD_INT 1
27614: ARRAY
27615: ST_TO_ADDR
// if p then
27616: LD_VAR 0 11
27620: IFFALSE 27645
// result := Replace ( result , 4 , p ) ;
27622: LD_ADDR_VAR 0 2
27626: PUSH
27627: LD_VAR 0 2
27631: PPUSH
27632: LD_INT 4
27634: PPUSH
27635: LD_VAR 0 11
27639: PPUSH
27640: CALL_OW 1
27644: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
27645: LD_ADDR_VAR 0 4
27649: PUSH
27650: LD_VAR 0 4
27654: PUSH
27655: LD_VAR 0 7
27659: DIFF
27660: ST_TO_ADDR
// if tmp and mech < 6 then
27661: LD_VAR 0 4
27665: PUSH
27666: LD_VAR 0 7
27670: PUSH
27671: LD_INT 6
27673: LESS
27674: AND
27675: IFFALSE 27863
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27677: LD_ADDR_VAR 0 9
27681: PUSH
27682: LD_VAR 0 4
27686: PUSH
27687: LD_VAR 0 8
27691: PUSH
27692: LD_VAR 0 7
27696: UNION
27697: DIFF
27698: PPUSH
27699: LD_INT 3
27701: PPUSH
27702: CALL 92225 0 2
27706: ST_TO_ADDR
// p := [ ] ;
27707: LD_ADDR_VAR 0 11
27711: PUSH
27712: EMPTY
27713: ST_TO_ADDR
// if sort then
27714: LD_VAR 0 9
27718: IFFALSE 27834
// for i = 1 to 6 - mech do
27720: LD_ADDR_VAR 0 3
27724: PUSH
27725: DOUBLE
27726: LD_INT 1
27728: DEC
27729: ST_TO_ADDR
27730: LD_INT 6
27732: PUSH
27733: LD_VAR 0 7
27737: MINUS
27738: PUSH
27739: FOR_TO
27740: IFFALSE 27832
// begin if i = sort then
27742: LD_VAR 0 3
27746: PUSH
27747: LD_VAR 0 9
27751: EQUAL
27752: IFFALSE 27756
// break ;
27754: GO 27832
// if GetClass ( i ) = 3 then
27756: LD_VAR 0 3
27760: PPUSH
27761: CALL_OW 257
27765: PUSH
27766: LD_INT 3
27768: EQUAL
27769: IFFALSE 27773
// continue ;
27771: GO 27739
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27773: LD_ADDR_VAR 0 11
27777: PUSH
27778: LD_VAR 0 11
27782: PPUSH
27783: LD_VAR 0 11
27787: PUSH
27788: LD_INT 1
27790: PLUS
27791: PPUSH
27792: LD_VAR 0 9
27796: PUSH
27797: LD_VAR 0 3
27801: ARRAY
27802: PPUSH
27803: CALL_OW 2
27807: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27808: LD_ADDR_VAR 0 4
27812: PUSH
27813: LD_VAR 0 4
27817: PUSH
27818: LD_VAR 0 9
27822: PUSH
27823: LD_VAR 0 3
27827: ARRAY
27828: DIFF
27829: ST_TO_ADDR
// end ;
27830: GO 27739
27832: POP
27833: POP
// if p then
27834: LD_VAR 0 11
27838: IFFALSE 27863
// result := Replace ( result , 3 , p ) ;
27840: LD_ADDR_VAR 0 2
27844: PUSH
27845: LD_VAR 0 2
27849: PPUSH
27850: LD_INT 3
27852: PPUSH
27853: LD_VAR 0 11
27857: PPUSH
27858: CALL_OW 1
27862: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
27863: LD_ADDR_VAR 0 4
27867: PUSH
27868: LD_VAR 0 4
27872: PUSH
27873: LD_VAR 0 6
27877: DIFF
27878: ST_TO_ADDR
// if tmp and eng < 6 then
27879: LD_VAR 0 4
27883: PUSH
27884: LD_VAR 0 6
27888: PUSH
27889: LD_INT 6
27891: LESS
27892: AND
27893: IFFALSE 28087
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
27895: LD_ADDR_VAR 0 9
27899: PUSH
27900: LD_VAR 0 4
27904: PUSH
27905: LD_VAR 0 8
27909: PUSH
27910: LD_VAR 0 7
27914: UNION
27915: PUSH
27916: LD_VAR 0 6
27920: UNION
27921: DIFF
27922: PPUSH
27923: LD_INT 2
27925: PPUSH
27926: CALL 92225 0 2
27930: ST_TO_ADDR
// p := [ ] ;
27931: LD_ADDR_VAR 0 11
27935: PUSH
27936: EMPTY
27937: ST_TO_ADDR
// if sort then
27938: LD_VAR 0 9
27942: IFFALSE 28058
// for i = 1 to 6 - eng do
27944: LD_ADDR_VAR 0 3
27948: PUSH
27949: DOUBLE
27950: LD_INT 1
27952: DEC
27953: ST_TO_ADDR
27954: LD_INT 6
27956: PUSH
27957: LD_VAR 0 6
27961: MINUS
27962: PUSH
27963: FOR_TO
27964: IFFALSE 28056
// begin if i = sort then
27966: LD_VAR 0 3
27970: PUSH
27971: LD_VAR 0 9
27975: EQUAL
27976: IFFALSE 27980
// break ;
27978: GO 28056
// if GetClass ( i ) = 2 then
27980: LD_VAR 0 3
27984: PPUSH
27985: CALL_OW 257
27989: PUSH
27990: LD_INT 2
27992: EQUAL
27993: IFFALSE 27997
// continue ;
27995: GO 27963
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27997: LD_ADDR_VAR 0 11
28001: PUSH
28002: LD_VAR 0 11
28006: PPUSH
28007: LD_VAR 0 11
28011: PUSH
28012: LD_INT 1
28014: PLUS
28015: PPUSH
28016: LD_VAR 0 9
28020: PUSH
28021: LD_VAR 0 3
28025: ARRAY
28026: PPUSH
28027: CALL_OW 2
28031: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28032: LD_ADDR_VAR 0 4
28036: PUSH
28037: LD_VAR 0 4
28041: PUSH
28042: LD_VAR 0 9
28046: PUSH
28047: LD_VAR 0 3
28051: ARRAY
28052: DIFF
28053: ST_TO_ADDR
// end ;
28054: GO 27963
28056: POP
28057: POP
// if p then
28058: LD_VAR 0 11
28062: IFFALSE 28087
// result := Replace ( result , 2 , p ) ;
28064: LD_ADDR_VAR 0 2
28068: PUSH
28069: LD_VAR 0 2
28073: PPUSH
28074: LD_INT 2
28076: PPUSH
28077: LD_VAR 0 11
28081: PPUSH
28082: CALL_OW 1
28086: ST_TO_ADDR
// end ; exit ;
28087: GO 28811
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
28089: LD_EXP 114
28093: PUSH
28094: LD_EXP 113
28098: PUSH
28099: LD_VAR 0 1
28103: ARRAY
28104: ARRAY
28105: NOT
28106: PUSH
28107: LD_EXP 87
28111: PUSH
28112: LD_VAR 0 1
28116: ARRAY
28117: PPUSH
28118: LD_INT 30
28120: PUSH
28121: LD_INT 3
28123: PUSH
28124: EMPTY
28125: LIST
28126: LIST
28127: PPUSH
28128: CALL_OW 72
28132: AND
28133: PUSH
28134: LD_EXP 92
28138: PUSH
28139: LD_VAR 0 1
28143: ARRAY
28144: NOT
28145: AND
28146: IFFALSE 28811
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
28148: LD_ADDR_EXP 129
28152: PUSH
28153: LD_EXP 129
28157: PPUSH
28158: LD_VAR 0 1
28162: PPUSH
28163: LD_INT 6
28165: PPUSH
28166: CALL_OW 1
28170: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
28171: LD_ADDR_VAR 0 2
28175: PUSH
28176: LD_INT 0
28178: PUSH
28179: LD_INT 0
28181: PUSH
28182: LD_INT 0
28184: PUSH
28185: LD_INT 0
28187: PUSH
28188: EMPTY
28189: LIST
28190: LIST
28191: LIST
28192: LIST
28193: ST_TO_ADDR
// if sci >= 1 then
28194: LD_VAR 0 8
28198: PUSH
28199: LD_INT 1
28201: GREATEREQUAL
28202: IFFALSE 28224
// tmp := tmp diff sci [ 1 ] ;
28204: LD_ADDR_VAR 0 4
28208: PUSH
28209: LD_VAR 0 4
28213: PUSH
28214: LD_VAR 0 8
28218: PUSH
28219: LD_INT 1
28221: ARRAY
28222: DIFF
28223: ST_TO_ADDR
// if tmp and not sci then
28224: LD_VAR 0 4
28228: PUSH
28229: LD_VAR 0 8
28233: NOT
28234: AND
28235: IFFALSE 28304
// begin sort := SortBySkill ( tmp , 4 ) ;
28237: LD_ADDR_VAR 0 9
28241: PUSH
28242: LD_VAR 0 4
28246: PPUSH
28247: LD_INT 4
28249: PPUSH
28250: CALL 92225 0 2
28254: ST_TO_ADDR
// if sort then
28255: LD_VAR 0 9
28259: IFFALSE 28275
// p := sort [ 1 ] ;
28261: LD_ADDR_VAR 0 11
28265: PUSH
28266: LD_VAR 0 9
28270: PUSH
28271: LD_INT 1
28273: ARRAY
28274: ST_TO_ADDR
// if p then
28275: LD_VAR 0 11
28279: IFFALSE 28304
// result := Replace ( result , 4 , p ) ;
28281: LD_ADDR_VAR 0 2
28285: PUSH
28286: LD_VAR 0 2
28290: PPUSH
28291: LD_INT 4
28293: PPUSH
28294: LD_VAR 0 11
28298: PPUSH
28299: CALL_OW 1
28303: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
28304: LD_ADDR_VAR 0 4
28308: PUSH
28309: LD_VAR 0 4
28313: PUSH
28314: LD_VAR 0 7
28318: DIFF
28319: ST_TO_ADDR
// if tmp and mech < 6 then
28320: LD_VAR 0 4
28324: PUSH
28325: LD_VAR 0 7
28329: PUSH
28330: LD_INT 6
28332: LESS
28333: AND
28334: IFFALSE 28516
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
28336: LD_ADDR_VAR 0 9
28340: PUSH
28341: LD_VAR 0 4
28345: PUSH
28346: LD_VAR 0 7
28350: DIFF
28351: PPUSH
28352: LD_INT 3
28354: PPUSH
28355: CALL 92225 0 2
28359: ST_TO_ADDR
// p := [ ] ;
28360: LD_ADDR_VAR 0 11
28364: PUSH
28365: EMPTY
28366: ST_TO_ADDR
// if sort then
28367: LD_VAR 0 9
28371: IFFALSE 28487
// for i = 1 to 6 - mech do
28373: LD_ADDR_VAR 0 3
28377: PUSH
28378: DOUBLE
28379: LD_INT 1
28381: DEC
28382: ST_TO_ADDR
28383: LD_INT 6
28385: PUSH
28386: LD_VAR 0 7
28390: MINUS
28391: PUSH
28392: FOR_TO
28393: IFFALSE 28485
// begin if i = sort then
28395: LD_VAR 0 3
28399: PUSH
28400: LD_VAR 0 9
28404: EQUAL
28405: IFFALSE 28409
// break ;
28407: GO 28485
// if GetClass ( i ) = 3 then
28409: LD_VAR 0 3
28413: PPUSH
28414: CALL_OW 257
28418: PUSH
28419: LD_INT 3
28421: EQUAL
28422: IFFALSE 28426
// continue ;
28424: GO 28392
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28426: LD_ADDR_VAR 0 11
28430: PUSH
28431: LD_VAR 0 11
28435: PPUSH
28436: LD_VAR 0 11
28440: PUSH
28441: LD_INT 1
28443: PLUS
28444: PPUSH
28445: LD_VAR 0 9
28449: PUSH
28450: LD_VAR 0 3
28454: ARRAY
28455: PPUSH
28456: CALL_OW 2
28460: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28461: LD_ADDR_VAR 0 4
28465: PUSH
28466: LD_VAR 0 4
28470: PUSH
28471: LD_VAR 0 9
28475: PUSH
28476: LD_VAR 0 3
28480: ARRAY
28481: DIFF
28482: ST_TO_ADDR
// end ;
28483: GO 28392
28485: POP
28486: POP
// if p then
28487: LD_VAR 0 11
28491: IFFALSE 28516
// result := Replace ( result , 3 , p ) ;
28493: LD_ADDR_VAR 0 2
28497: PUSH
28498: LD_VAR 0 2
28502: PPUSH
28503: LD_INT 3
28505: PPUSH
28506: LD_VAR 0 11
28510: PPUSH
28511: CALL_OW 1
28515: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28516: LD_ADDR_VAR 0 4
28520: PUSH
28521: LD_VAR 0 4
28525: PUSH
28526: LD_VAR 0 6
28530: DIFF
28531: ST_TO_ADDR
// if tmp and eng < 4 then
28532: LD_VAR 0 4
28536: PUSH
28537: LD_VAR 0 6
28541: PUSH
28542: LD_INT 4
28544: LESS
28545: AND
28546: IFFALSE 28736
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
28548: LD_ADDR_VAR 0 9
28552: PUSH
28553: LD_VAR 0 4
28557: PUSH
28558: LD_VAR 0 7
28562: PUSH
28563: LD_VAR 0 6
28567: UNION
28568: DIFF
28569: PPUSH
28570: LD_INT 2
28572: PPUSH
28573: CALL 92225 0 2
28577: ST_TO_ADDR
// p := [ ] ;
28578: LD_ADDR_VAR 0 11
28582: PUSH
28583: EMPTY
28584: ST_TO_ADDR
// if sort then
28585: LD_VAR 0 9
28589: IFFALSE 28705
// for i = 1 to 4 - eng do
28591: LD_ADDR_VAR 0 3
28595: PUSH
28596: DOUBLE
28597: LD_INT 1
28599: DEC
28600: ST_TO_ADDR
28601: LD_INT 4
28603: PUSH
28604: LD_VAR 0 6
28608: MINUS
28609: PUSH
28610: FOR_TO
28611: IFFALSE 28703
// begin if i = sort then
28613: LD_VAR 0 3
28617: PUSH
28618: LD_VAR 0 9
28622: EQUAL
28623: IFFALSE 28627
// break ;
28625: GO 28703
// if GetClass ( i ) = 2 then
28627: LD_VAR 0 3
28631: PPUSH
28632: CALL_OW 257
28636: PUSH
28637: LD_INT 2
28639: EQUAL
28640: IFFALSE 28644
// continue ;
28642: GO 28610
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28644: LD_ADDR_VAR 0 11
28648: PUSH
28649: LD_VAR 0 11
28653: PPUSH
28654: LD_VAR 0 11
28658: PUSH
28659: LD_INT 1
28661: PLUS
28662: PPUSH
28663: LD_VAR 0 9
28667: PUSH
28668: LD_VAR 0 3
28672: ARRAY
28673: PPUSH
28674: CALL_OW 2
28678: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28679: LD_ADDR_VAR 0 4
28683: PUSH
28684: LD_VAR 0 4
28688: PUSH
28689: LD_VAR 0 9
28693: PUSH
28694: LD_VAR 0 3
28698: ARRAY
28699: DIFF
28700: ST_TO_ADDR
// end ;
28701: GO 28610
28703: POP
28704: POP
// if p then
28705: LD_VAR 0 11
28709: IFFALSE 28734
// result := Replace ( result , 2 , p ) ;
28711: LD_ADDR_VAR 0 2
28715: PUSH
28716: LD_VAR 0 2
28720: PPUSH
28721: LD_INT 2
28723: PPUSH
28724: LD_VAR 0 11
28728: PPUSH
28729: CALL_OW 1
28733: ST_TO_ADDR
// end else
28734: GO 28780
// for i = eng downto 5 do
28736: LD_ADDR_VAR 0 3
28740: PUSH
28741: DOUBLE
28742: LD_VAR 0 6
28746: INC
28747: ST_TO_ADDR
28748: LD_INT 5
28750: PUSH
28751: FOR_DOWNTO
28752: IFFALSE 28778
// tmp := tmp union eng [ i ] ;
28754: LD_ADDR_VAR 0 4
28758: PUSH
28759: LD_VAR 0 4
28763: PUSH
28764: LD_VAR 0 6
28768: PUSH
28769: LD_VAR 0 3
28773: ARRAY
28774: UNION
28775: ST_TO_ADDR
28776: GO 28751
28778: POP
28779: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
28780: LD_ADDR_VAR 0 2
28784: PUSH
28785: LD_VAR 0 2
28789: PPUSH
28790: LD_INT 1
28792: PPUSH
28793: LD_VAR 0 4
28797: PUSH
28798: LD_VAR 0 5
28802: DIFF
28803: PPUSH
28804: CALL_OW 1
28808: ST_TO_ADDR
// exit ;
28809: GO 28811
// end ; end ;
28811: LD_VAR 0 2
28815: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
28816: LD_INT 0
28818: PPUSH
28819: PPUSH
28820: PPUSH
// if not mc_bases then
28821: LD_EXP 87
28825: NOT
28826: IFFALSE 28830
// exit ;
28828: GO 28936
// for i = 1 to mc_bases do
28830: LD_ADDR_VAR 0 2
28834: PUSH
28835: DOUBLE
28836: LD_INT 1
28838: DEC
28839: ST_TO_ADDR
28840: LD_EXP 87
28844: PUSH
28845: FOR_TO
28846: IFFALSE 28927
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
28848: LD_ADDR_VAR 0 3
28852: PUSH
28853: LD_EXP 87
28857: PUSH
28858: LD_VAR 0 2
28862: ARRAY
28863: PPUSH
28864: LD_INT 21
28866: PUSH
28867: LD_INT 3
28869: PUSH
28870: EMPTY
28871: LIST
28872: LIST
28873: PUSH
28874: LD_INT 3
28876: PUSH
28877: LD_INT 24
28879: PUSH
28880: LD_INT 1000
28882: PUSH
28883: EMPTY
28884: LIST
28885: LIST
28886: PUSH
28887: EMPTY
28888: LIST
28889: LIST
28890: PUSH
28891: EMPTY
28892: LIST
28893: LIST
28894: PPUSH
28895: CALL_OW 72
28899: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
28900: LD_ADDR_EXP 88
28904: PUSH
28905: LD_EXP 88
28909: PPUSH
28910: LD_VAR 0 2
28914: PPUSH
28915: LD_VAR 0 3
28919: PPUSH
28920: CALL_OW 1
28924: ST_TO_ADDR
// end ;
28925: GO 28845
28927: POP
28928: POP
// RaiseSailEvent ( 101 ) ;
28929: LD_INT 101
28931: PPUSH
28932: CALL_OW 427
// end ;
28936: LD_VAR 0 1
28940: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
28941: LD_INT 0
28943: PPUSH
28944: PPUSH
28945: PPUSH
28946: PPUSH
28947: PPUSH
28948: PPUSH
28949: PPUSH
// if not mc_bases then
28950: LD_EXP 87
28954: NOT
28955: IFFALSE 28959
// exit ;
28957: GO 29532
// for i = 1 to mc_bases do
28959: LD_ADDR_VAR 0 2
28963: PUSH
28964: DOUBLE
28965: LD_INT 1
28967: DEC
28968: ST_TO_ADDR
28969: LD_EXP 87
28973: PUSH
28974: FOR_TO
28975: IFFALSE 29523
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
28977: LD_ADDR_VAR 0 5
28981: PUSH
28982: LD_EXP 87
28986: PUSH
28987: LD_VAR 0 2
28991: ARRAY
28992: PUSH
28993: LD_EXP 116
28997: PUSH
28998: LD_VAR 0 2
29002: ARRAY
29003: UNION
29004: PPUSH
29005: LD_INT 21
29007: PUSH
29008: LD_INT 1
29010: PUSH
29011: EMPTY
29012: LIST
29013: LIST
29014: PUSH
29015: LD_INT 1
29017: PUSH
29018: LD_INT 3
29020: PUSH
29021: LD_INT 54
29023: PUSH
29024: EMPTY
29025: LIST
29026: PUSH
29027: EMPTY
29028: LIST
29029: LIST
29030: PUSH
29031: LD_INT 3
29033: PUSH
29034: LD_INT 24
29036: PUSH
29037: LD_INT 800
29039: PUSH
29040: EMPTY
29041: LIST
29042: LIST
29043: PUSH
29044: EMPTY
29045: LIST
29046: LIST
29047: PUSH
29048: EMPTY
29049: LIST
29050: LIST
29051: LIST
29052: PUSH
29053: EMPTY
29054: LIST
29055: LIST
29056: PPUSH
29057: CALL_OW 72
29061: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
29062: LD_ADDR_VAR 0 6
29066: PUSH
29067: LD_EXP 87
29071: PUSH
29072: LD_VAR 0 2
29076: ARRAY
29077: PPUSH
29078: LD_INT 21
29080: PUSH
29081: LD_INT 1
29083: PUSH
29084: EMPTY
29085: LIST
29086: LIST
29087: PUSH
29088: LD_INT 1
29090: PUSH
29091: LD_INT 3
29093: PUSH
29094: LD_INT 54
29096: PUSH
29097: EMPTY
29098: LIST
29099: PUSH
29100: EMPTY
29101: LIST
29102: LIST
29103: PUSH
29104: LD_INT 3
29106: PUSH
29107: LD_INT 24
29109: PUSH
29110: LD_INT 250
29112: PUSH
29113: EMPTY
29114: LIST
29115: LIST
29116: PUSH
29117: EMPTY
29118: LIST
29119: LIST
29120: PUSH
29121: EMPTY
29122: LIST
29123: LIST
29124: LIST
29125: PUSH
29126: EMPTY
29127: LIST
29128: LIST
29129: PPUSH
29130: CALL_OW 72
29134: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
29135: LD_ADDR_VAR 0 7
29139: PUSH
29140: LD_VAR 0 5
29144: PUSH
29145: LD_VAR 0 6
29149: DIFF
29150: ST_TO_ADDR
// if not need_heal_1 then
29151: LD_VAR 0 6
29155: NOT
29156: IFFALSE 29189
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
29158: LD_ADDR_EXP 90
29162: PUSH
29163: LD_EXP 90
29167: PPUSH
29168: LD_VAR 0 2
29172: PUSH
29173: LD_INT 1
29175: PUSH
29176: EMPTY
29177: LIST
29178: LIST
29179: PPUSH
29180: EMPTY
29181: PPUSH
29182: CALL 57967 0 3
29186: ST_TO_ADDR
29187: GO 29259
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
29189: LD_ADDR_EXP 90
29193: PUSH
29194: LD_EXP 90
29198: PPUSH
29199: LD_VAR 0 2
29203: PUSH
29204: LD_INT 1
29206: PUSH
29207: EMPTY
29208: LIST
29209: LIST
29210: PPUSH
29211: LD_EXP 90
29215: PUSH
29216: LD_VAR 0 2
29220: ARRAY
29221: PUSH
29222: LD_INT 1
29224: ARRAY
29225: PPUSH
29226: LD_INT 3
29228: PUSH
29229: LD_INT 24
29231: PUSH
29232: LD_INT 1000
29234: PUSH
29235: EMPTY
29236: LIST
29237: LIST
29238: PUSH
29239: EMPTY
29240: LIST
29241: LIST
29242: PPUSH
29243: CALL_OW 72
29247: PUSH
29248: LD_VAR 0 6
29252: UNION
29253: PPUSH
29254: CALL 57967 0 3
29258: ST_TO_ADDR
// if not need_heal_2 then
29259: LD_VAR 0 7
29263: NOT
29264: IFFALSE 29297
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
29266: LD_ADDR_EXP 90
29270: PUSH
29271: LD_EXP 90
29275: PPUSH
29276: LD_VAR 0 2
29280: PUSH
29281: LD_INT 2
29283: PUSH
29284: EMPTY
29285: LIST
29286: LIST
29287: PPUSH
29288: EMPTY
29289: PPUSH
29290: CALL 57967 0 3
29294: ST_TO_ADDR
29295: GO 29329
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
29297: LD_ADDR_EXP 90
29301: PUSH
29302: LD_EXP 90
29306: PPUSH
29307: LD_VAR 0 2
29311: PUSH
29312: LD_INT 2
29314: PUSH
29315: EMPTY
29316: LIST
29317: LIST
29318: PPUSH
29319: LD_VAR 0 7
29323: PPUSH
29324: CALL 57967 0 3
29328: ST_TO_ADDR
// if need_heal_2 then
29329: LD_VAR 0 7
29333: IFFALSE 29505
// for j in need_heal_2 do
29335: LD_ADDR_VAR 0 3
29339: PUSH
29340: LD_VAR 0 7
29344: PUSH
29345: FOR_IN
29346: IFFALSE 29503
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
29348: LD_ADDR_VAR 0 5
29352: PUSH
29353: LD_EXP 87
29357: PUSH
29358: LD_VAR 0 2
29362: ARRAY
29363: PPUSH
29364: LD_INT 2
29366: PUSH
29367: LD_INT 30
29369: PUSH
29370: LD_INT 6
29372: PUSH
29373: EMPTY
29374: LIST
29375: LIST
29376: PUSH
29377: LD_INT 30
29379: PUSH
29380: LD_INT 7
29382: PUSH
29383: EMPTY
29384: LIST
29385: LIST
29386: PUSH
29387: LD_INT 30
29389: PUSH
29390: LD_INT 8
29392: PUSH
29393: EMPTY
29394: LIST
29395: LIST
29396: PUSH
29397: LD_INT 30
29399: PUSH
29400: LD_INT 0
29402: PUSH
29403: EMPTY
29404: LIST
29405: LIST
29406: PUSH
29407: LD_INT 30
29409: PUSH
29410: LD_INT 1
29412: PUSH
29413: EMPTY
29414: LIST
29415: LIST
29416: PUSH
29417: LD_INT 25
29419: PUSH
29420: LD_INT 4
29422: PUSH
29423: EMPTY
29424: LIST
29425: LIST
29426: PUSH
29427: EMPTY
29428: LIST
29429: LIST
29430: LIST
29431: LIST
29432: LIST
29433: LIST
29434: LIST
29435: PPUSH
29436: CALL_OW 72
29440: ST_TO_ADDR
// if tmp then
29441: LD_VAR 0 5
29445: IFFALSE 29501
// begin k := NearestUnitToUnit ( tmp , j ) ;
29447: LD_ADDR_VAR 0 4
29451: PUSH
29452: LD_VAR 0 5
29456: PPUSH
29457: LD_VAR 0 3
29461: PPUSH
29462: CALL_OW 74
29466: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
29467: LD_VAR 0 3
29471: PPUSH
29472: LD_VAR 0 4
29476: PPUSH
29477: CALL_OW 296
29481: PUSH
29482: LD_INT 7
29484: GREATER
29485: IFFALSE 29501
// ComMoveUnit ( j , k ) ;
29487: LD_VAR 0 3
29491: PPUSH
29492: LD_VAR 0 4
29496: PPUSH
29497: CALL_OW 112
// end ; end ;
29501: GO 29345
29503: POP
29504: POP
// if not need_heal_1 and not need_heal_2 then
29505: LD_VAR 0 6
29509: NOT
29510: PUSH
29511: LD_VAR 0 7
29515: NOT
29516: AND
29517: IFFALSE 29521
// continue ;
29519: GO 28974
// end ;
29521: GO 28974
29523: POP
29524: POP
// RaiseSailEvent ( 102 ) ;
29525: LD_INT 102
29527: PPUSH
29528: CALL_OW 427
// end ;
29532: LD_VAR 0 1
29536: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
29537: LD_INT 0
29539: PPUSH
29540: PPUSH
29541: PPUSH
29542: PPUSH
29543: PPUSH
29544: PPUSH
29545: PPUSH
29546: PPUSH
// if not mc_bases then
29547: LD_EXP 87
29551: NOT
29552: IFFALSE 29556
// exit ;
29554: GO 30396
// for i = 1 to mc_bases do
29556: LD_ADDR_VAR 0 2
29560: PUSH
29561: DOUBLE
29562: LD_INT 1
29564: DEC
29565: ST_TO_ADDR
29566: LD_EXP 87
29570: PUSH
29571: FOR_TO
29572: IFFALSE 30394
// begin if not mc_building_need_repair [ i ] then
29574: LD_EXP 88
29578: PUSH
29579: LD_VAR 0 2
29583: ARRAY
29584: NOT
29585: IFFALSE 29759
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
29587: LD_ADDR_VAR 0 6
29591: PUSH
29592: LD_EXP 106
29596: PUSH
29597: LD_VAR 0 2
29601: ARRAY
29602: PPUSH
29603: LD_INT 3
29605: PUSH
29606: LD_INT 24
29608: PUSH
29609: LD_INT 1000
29611: PUSH
29612: EMPTY
29613: LIST
29614: LIST
29615: PUSH
29616: EMPTY
29617: LIST
29618: LIST
29619: PUSH
29620: LD_INT 2
29622: PUSH
29623: LD_INT 34
29625: PUSH
29626: LD_INT 13
29628: PUSH
29629: EMPTY
29630: LIST
29631: LIST
29632: PUSH
29633: LD_INT 34
29635: PUSH
29636: LD_INT 52
29638: PUSH
29639: EMPTY
29640: LIST
29641: LIST
29642: PUSH
29643: EMPTY
29644: LIST
29645: LIST
29646: LIST
29647: PUSH
29648: EMPTY
29649: LIST
29650: LIST
29651: PPUSH
29652: CALL_OW 72
29656: ST_TO_ADDR
// if cranes then
29657: LD_VAR 0 6
29661: IFFALSE 29723
// for j in cranes do
29663: LD_ADDR_VAR 0 3
29667: PUSH
29668: LD_VAR 0 6
29672: PUSH
29673: FOR_IN
29674: IFFALSE 29721
// if not IsInArea ( j , mc_parking [ i ] ) then
29676: LD_VAR 0 3
29680: PPUSH
29681: LD_EXP 111
29685: PUSH
29686: LD_VAR 0 2
29690: ARRAY
29691: PPUSH
29692: CALL_OW 308
29696: NOT
29697: IFFALSE 29719
// ComMoveToArea ( j , mc_parking [ i ] ) ;
29699: LD_VAR 0 3
29703: PPUSH
29704: LD_EXP 111
29708: PUSH
29709: LD_VAR 0 2
29713: ARRAY
29714: PPUSH
29715: CALL_OW 113
29719: GO 29673
29721: POP
29722: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
29723: LD_ADDR_EXP 89
29727: PUSH
29728: LD_EXP 89
29732: PPUSH
29733: LD_VAR 0 2
29737: PPUSH
29738: EMPTY
29739: PPUSH
29740: CALL_OW 1
29744: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
29745: LD_VAR 0 2
29749: PPUSH
29750: LD_INT 101
29752: PPUSH
29753: CALL 24649 0 2
// continue ;
29757: GO 29571
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
29759: LD_ADDR_EXP 93
29763: PUSH
29764: LD_EXP 93
29768: PPUSH
29769: LD_VAR 0 2
29773: PPUSH
29774: EMPTY
29775: PPUSH
29776: CALL_OW 1
29780: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
29781: LD_VAR 0 2
29785: PPUSH
29786: LD_INT 103
29788: PPUSH
29789: CALL 24649 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
29793: LD_ADDR_VAR 0 5
29797: PUSH
29798: LD_EXP 87
29802: PUSH
29803: LD_VAR 0 2
29807: ARRAY
29808: PUSH
29809: LD_EXP 116
29813: PUSH
29814: LD_VAR 0 2
29818: ARRAY
29819: UNION
29820: PPUSH
29821: LD_INT 2
29823: PUSH
29824: LD_INT 25
29826: PUSH
29827: LD_INT 2
29829: PUSH
29830: EMPTY
29831: LIST
29832: LIST
29833: PUSH
29834: LD_INT 25
29836: PUSH
29837: LD_INT 16
29839: PUSH
29840: EMPTY
29841: LIST
29842: LIST
29843: PUSH
29844: EMPTY
29845: LIST
29846: LIST
29847: LIST
29848: PUSH
29849: EMPTY
29850: LIST
29851: PPUSH
29852: CALL_OW 72
29856: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
29857: LD_ADDR_VAR 0 6
29861: PUSH
29862: LD_EXP 106
29866: PUSH
29867: LD_VAR 0 2
29871: ARRAY
29872: PPUSH
29873: LD_INT 2
29875: PUSH
29876: LD_INT 34
29878: PUSH
29879: LD_INT 13
29881: PUSH
29882: EMPTY
29883: LIST
29884: LIST
29885: PUSH
29886: LD_INT 34
29888: PUSH
29889: LD_INT 52
29891: PUSH
29892: EMPTY
29893: LIST
29894: LIST
29895: PUSH
29896: EMPTY
29897: LIST
29898: LIST
29899: LIST
29900: PPUSH
29901: CALL_OW 72
29905: ST_TO_ADDR
// if cranes then
29906: LD_VAR 0 6
29910: IFFALSE 30046
// begin for j in cranes do
29912: LD_ADDR_VAR 0 3
29916: PUSH
29917: LD_VAR 0 6
29921: PUSH
29922: FOR_IN
29923: IFFALSE 30044
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
29925: LD_VAR 0 3
29929: PPUSH
29930: CALL_OW 256
29934: PUSH
29935: LD_INT 500
29937: GREATEREQUAL
29938: PUSH
29939: LD_VAR 0 3
29943: PPUSH
29944: CALL_OW 314
29948: NOT
29949: AND
29950: IFFALSE 29984
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
29952: LD_VAR 0 3
29956: PPUSH
29957: LD_EXP 88
29961: PUSH
29962: LD_VAR 0 2
29966: ARRAY
29967: PPUSH
29968: LD_VAR 0 3
29972: PPUSH
29973: CALL_OW 74
29977: PPUSH
29978: CALL_OW 130
29982: GO 30042
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
29984: LD_VAR 0 3
29988: PPUSH
29989: CALL_OW 256
29993: PUSH
29994: LD_INT 500
29996: LESS
29997: PUSH
29998: LD_VAR 0 3
30002: PPUSH
30003: LD_EXP 111
30007: PUSH
30008: LD_VAR 0 2
30012: ARRAY
30013: PPUSH
30014: CALL_OW 308
30018: NOT
30019: AND
30020: IFFALSE 30042
// ComMoveToArea ( j , mc_parking [ i ] ) ;
30022: LD_VAR 0 3
30026: PPUSH
30027: LD_EXP 111
30031: PUSH
30032: LD_VAR 0 2
30036: ARRAY
30037: PPUSH
30038: CALL_OW 113
30042: GO 29922
30044: POP
30045: POP
// end ; if not tmp then
30046: LD_VAR 0 5
30050: NOT
30051: IFFALSE 30055
// continue ;
30053: GO 29571
// for j in tmp do
30055: LD_ADDR_VAR 0 3
30059: PUSH
30060: LD_VAR 0 5
30064: PUSH
30065: FOR_IN
30066: IFFALSE 30390
// begin if mc_need_heal [ i ] then
30068: LD_EXP 90
30072: PUSH
30073: LD_VAR 0 2
30077: ARRAY
30078: IFFALSE 30126
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
30080: LD_VAR 0 3
30084: PUSH
30085: LD_EXP 90
30089: PUSH
30090: LD_VAR 0 2
30094: ARRAY
30095: PUSH
30096: LD_INT 1
30098: ARRAY
30099: IN
30100: PUSH
30101: LD_VAR 0 3
30105: PUSH
30106: LD_EXP 90
30110: PUSH
30111: LD_VAR 0 2
30115: ARRAY
30116: PUSH
30117: LD_INT 2
30119: ARRAY
30120: IN
30121: OR
30122: IFFALSE 30126
// continue ;
30124: GO 30065
// if IsInUnit ( j ) then
30126: LD_VAR 0 3
30130: PPUSH
30131: CALL_OW 310
30135: IFFALSE 30146
// ComExitBuilding ( j ) ;
30137: LD_VAR 0 3
30141: PPUSH
30142: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
30146: LD_VAR 0 3
30150: PUSH
30151: LD_EXP 89
30155: PUSH
30156: LD_VAR 0 2
30160: ARRAY
30161: IN
30162: NOT
30163: IFFALSE 30221
// begin SetTag ( j , 101 ) ;
30165: LD_VAR 0 3
30169: PPUSH
30170: LD_INT 101
30172: PPUSH
30173: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
30177: LD_ADDR_EXP 89
30181: PUSH
30182: LD_EXP 89
30186: PPUSH
30187: LD_VAR 0 2
30191: PUSH
30192: LD_EXP 89
30196: PUSH
30197: LD_VAR 0 2
30201: ARRAY
30202: PUSH
30203: LD_INT 1
30205: PLUS
30206: PUSH
30207: EMPTY
30208: LIST
30209: LIST
30210: PPUSH
30211: LD_VAR 0 3
30215: PPUSH
30216: CALL 57967 0 3
30220: ST_TO_ADDR
// end ; wait ( 1 ) ;
30221: LD_INT 1
30223: PPUSH
30224: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
30228: LD_ADDR_VAR 0 7
30232: PUSH
30233: LD_EXP 88
30237: PUSH
30238: LD_VAR 0 2
30242: ARRAY
30243: ST_TO_ADDR
// if mc_scan [ i ] then
30244: LD_EXP 110
30248: PUSH
30249: LD_VAR 0 2
30253: ARRAY
30254: IFFALSE 30323
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ] ) ;
30256: LD_ADDR_VAR 0 7
30260: PUSH
30261: LD_EXP 88
30265: PUSH
30266: LD_VAR 0 2
30270: ARRAY
30271: PPUSH
30272: LD_INT 3
30274: PUSH
30275: LD_INT 2
30277: PUSH
30278: LD_INT 30
30280: PUSH
30281: LD_INT 32
30283: PUSH
30284: EMPTY
30285: LIST
30286: LIST
30287: PUSH
30288: LD_INT 30
30290: PUSH
30291: LD_INT 33
30293: PUSH
30294: EMPTY
30295: LIST
30296: LIST
30297: PUSH
30298: LD_INT 30
30300: PUSH
30301: LD_INT 31
30303: PUSH
30304: EMPTY
30305: LIST
30306: LIST
30307: PUSH
30308: EMPTY
30309: LIST
30310: LIST
30311: LIST
30312: LIST
30313: PUSH
30314: EMPTY
30315: LIST
30316: LIST
30317: PPUSH
30318: CALL_OW 72
30322: ST_TO_ADDR
// if not to_repair_tmp then
30323: LD_VAR 0 7
30327: NOT
30328: IFFALSE 30332
// continue ;
30330: GO 30065
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
30332: LD_ADDR_VAR 0 8
30336: PUSH
30337: LD_VAR 0 7
30341: PPUSH
30342: LD_VAR 0 3
30346: PPUSH
30347: CALL_OW 74
30351: ST_TO_ADDR
// if DangerAtRange ( to_repair , 14 ) [ 4 ] < 5 then
30352: LD_VAR 0 8
30356: PPUSH
30357: LD_INT 14
30359: PPUSH
30360: CALL 60560 0 2
30364: PUSH
30365: LD_INT 4
30367: ARRAY
30368: PUSH
30369: LD_INT 5
30371: LESS
30372: IFFALSE 30388
// ComRepairBuilding ( j , to_repair ) ;
30374: LD_VAR 0 3
30378: PPUSH
30379: LD_VAR 0 8
30383: PPUSH
30384: CALL_OW 130
// end ;
30388: GO 30065
30390: POP
30391: POP
// end ;
30392: GO 29571
30394: POP
30395: POP
// end ;
30396: LD_VAR 0 1
30400: RET
// export function MC_Heal ; var i , j , tmp ; begin
30401: LD_INT 0
30403: PPUSH
30404: PPUSH
30405: PPUSH
30406: PPUSH
// if not mc_bases then
30407: LD_EXP 87
30411: NOT
30412: IFFALSE 30416
// exit ;
30414: GO 30818
// for i = 1 to mc_bases do
30416: LD_ADDR_VAR 0 2
30420: PUSH
30421: DOUBLE
30422: LD_INT 1
30424: DEC
30425: ST_TO_ADDR
30426: LD_EXP 87
30430: PUSH
30431: FOR_TO
30432: IFFALSE 30816
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
30434: LD_EXP 90
30438: PUSH
30439: LD_VAR 0 2
30443: ARRAY
30444: PUSH
30445: LD_INT 1
30447: ARRAY
30448: NOT
30449: PUSH
30450: LD_EXP 90
30454: PUSH
30455: LD_VAR 0 2
30459: ARRAY
30460: PUSH
30461: LD_INT 2
30463: ARRAY
30464: NOT
30465: AND
30466: IFFALSE 30504
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
30468: LD_ADDR_EXP 91
30472: PUSH
30473: LD_EXP 91
30477: PPUSH
30478: LD_VAR 0 2
30482: PPUSH
30483: EMPTY
30484: PPUSH
30485: CALL_OW 1
30489: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
30490: LD_VAR 0 2
30494: PPUSH
30495: LD_INT 102
30497: PPUSH
30498: CALL 24649 0 2
// continue ;
30502: GO 30431
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
30504: LD_ADDR_VAR 0 4
30508: PUSH
30509: LD_EXP 87
30513: PUSH
30514: LD_VAR 0 2
30518: ARRAY
30519: PPUSH
30520: LD_INT 25
30522: PUSH
30523: LD_INT 4
30525: PUSH
30526: EMPTY
30527: LIST
30528: LIST
30529: PPUSH
30530: CALL_OW 72
30534: ST_TO_ADDR
// if not tmp then
30535: LD_VAR 0 4
30539: NOT
30540: IFFALSE 30544
// continue ;
30542: GO 30431
// if mc_taming [ i ] then
30544: LD_EXP 118
30548: PUSH
30549: LD_VAR 0 2
30553: ARRAY
30554: IFFALSE 30578
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
30556: LD_ADDR_EXP 118
30560: PUSH
30561: LD_EXP 118
30565: PPUSH
30566: LD_VAR 0 2
30570: PPUSH
30571: EMPTY
30572: PPUSH
30573: CALL_OW 1
30577: ST_TO_ADDR
// for j in tmp do
30578: LD_ADDR_VAR 0 3
30582: PUSH
30583: LD_VAR 0 4
30587: PUSH
30588: FOR_IN
30589: IFFALSE 30812
// begin if IsInUnit ( j ) then
30591: LD_VAR 0 3
30595: PPUSH
30596: CALL_OW 310
30600: IFFALSE 30611
// ComExitBuilding ( j ) ;
30602: LD_VAR 0 3
30606: PPUSH
30607: CALL_OW 122
// if not j in mc_healers [ i ] then
30611: LD_VAR 0 3
30615: PUSH
30616: LD_EXP 91
30620: PUSH
30621: LD_VAR 0 2
30625: ARRAY
30626: IN
30627: NOT
30628: IFFALSE 30674
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
30630: LD_ADDR_EXP 91
30634: PUSH
30635: LD_EXP 91
30639: PPUSH
30640: LD_VAR 0 2
30644: PUSH
30645: LD_EXP 91
30649: PUSH
30650: LD_VAR 0 2
30654: ARRAY
30655: PUSH
30656: LD_INT 1
30658: PLUS
30659: PUSH
30660: EMPTY
30661: LIST
30662: LIST
30663: PPUSH
30664: LD_VAR 0 3
30668: PPUSH
30669: CALL 57967 0 3
30673: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
30674: LD_VAR 0 3
30678: PPUSH
30679: CALL_OW 110
30683: PUSH
30684: LD_INT 102
30686: NONEQUAL
30687: IFFALSE 30701
// SetTag ( j , 102 ) ;
30689: LD_VAR 0 3
30693: PPUSH
30694: LD_INT 102
30696: PPUSH
30697: CALL_OW 109
// Wait ( 3 ) ;
30701: LD_INT 3
30703: PPUSH
30704: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
30708: LD_EXP 90
30712: PUSH
30713: LD_VAR 0 2
30717: ARRAY
30718: PUSH
30719: LD_INT 1
30721: ARRAY
30722: IFFALSE 30754
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
30724: LD_VAR 0 3
30728: PPUSH
30729: LD_EXP 90
30733: PUSH
30734: LD_VAR 0 2
30738: ARRAY
30739: PUSH
30740: LD_INT 1
30742: ARRAY
30743: PUSH
30744: LD_INT 1
30746: ARRAY
30747: PPUSH
30748: CALL_OW 128
30752: GO 30810
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
30754: LD_VAR 0 3
30758: PPUSH
30759: CALL_OW 314
30763: NOT
30764: PUSH
30765: LD_EXP 90
30769: PUSH
30770: LD_VAR 0 2
30774: ARRAY
30775: PUSH
30776: LD_INT 2
30778: ARRAY
30779: AND
30780: IFFALSE 30810
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
30782: LD_VAR 0 3
30786: PPUSH
30787: LD_EXP 90
30791: PUSH
30792: LD_VAR 0 2
30796: ARRAY
30797: PUSH
30798: LD_INT 2
30800: ARRAY
30801: PUSH
30802: LD_INT 1
30804: ARRAY
30805: PPUSH
30806: CALL_OW 128
// end ;
30810: GO 30588
30812: POP
30813: POP
// end ;
30814: GO 30431
30816: POP
30817: POP
// end ;
30818: LD_VAR 0 1
30822: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
30823: LD_INT 0
30825: PPUSH
30826: PPUSH
30827: PPUSH
30828: PPUSH
30829: PPUSH
// if not mc_bases then
30830: LD_EXP 87
30834: NOT
30835: IFFALSE 30839
// exit ;
30837: GO 31982
// for i = 1 to mc_bases do
30839: LD_ADDR_VAR 0 2
30843: PUSH
30844: DOUBLE
30845: LD_INT 1
30847: DEC
30848: ST_TO_ADDR
30849: LD_EXP 87
30853: PUSH
30854: FOR_TO
30855: IFFALSE 31980
// begin if mc_scan [ i ] then
30857: LD_EXP 110
30861: PUSH
30862: LD_VAR 0 2
30866: ARRAY
30867: IFFALSE 30871
// continue ;
30869: GO 30854
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
30871: LD_EXP 92
30875: PUSH
30876: LD_VAR 0 2
30880: ARRAY
30881: NOT
30882: PUSH
30883: LD_EXP 94
30887: PUSH
30888: LD_VAR 0 2
30892: ARRAY
30893: NOT
30894: AND
30895: PUSH
30896: LD_EXP 93
30900: PUSH
30901: LD_VAR 0 2
30905: ARRAY
30906: AND
30907: IFFALSE 30945
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
30909: LD_ADDR_EXP 93
30913: PUSH
30914: LD_EXP 93
30918: PPUSH
30919: LD_VAR 0 2
30923: PPUSH
30924: EMPTY
30925: PPUSH
30926: CALL_OW 1
30930: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
30931: LD_VAR 0 2
30935: PPUSH
30936: LD_INT 103
30938: PPUSH
30939: CALL 24649 0 2
// continue ;
30943: GO 30854
// end ; if mc_construct_list [ i ] then
30945: LD_EXP 94
30949: PUSH
30950: LD_VAR 0 2
30954: ARRAY
30955: IFFALSE 31175
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
30957: LD_ADDR_VAR 0 4
30961: PUSH
30962: LD_EXP 87
30966: PUSH
30967: LD_VAR 0 2
30971: ARRAY
30972: PPUSH
30973: LD_INT 25
30975: PUSH
30976: LD_INT 2
30978: PUSH
30979: EMPTY
30980: LIST
30981: LIST
30982: PPUSH
30983: CALL_OW 72
30987: PUSH
30988: LD_EXP 89
30992: PUSH
30993: LD_VAR 0 2
30997: ARRAY
30998: DIFF
30999: ST_TO_ADDR
// if not tmp then
31000: LD_VAR 0 4
31004: NOT
31005: IFFALSE 31009
// continue ;
31007: GO 30854
// for j in tmp do
31009: LD_ADDR_VAR 0 3
31013: PUSH
31014: LD_VAR 0 4
31018: PUSH
31019: FOR_IN
31020: IFFALSE 31171
// begin if not mc_builders [ i ] then
31022: LD_EXP 93
31026: PUSH
31027: LD_VAR 0 2
31031: ARRAY
31032: NOT
31033: IFFALSE 31091
// begin SetTag ( j , 103 ) ;
31035: LD_VAR 0 3
31039: PPUSH
31040: LD_INT 103
31042: PPUSH
31043: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31047: LD_ADDR_EXP 93
31051: PUSH
31052: LD_EXP 93
31056: PPUSH
31057: LD_VAR 0 2
31061: PUSH
31062: LD_EXP 93
31066: PUSH
31067: LD_VAR 0 2
31071: ARRAY
31072: PUSH
31073: LD_INT 1
31075: PLUS
31076: PUSH
31077: EMPTY
31078: LIST
31079: LIST
31080: PPUSH
31081: LD_VAR 0 3
31085: PPUSH
31086: CALL 57967 0 3
31090: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31091: LD_VAR 0 3
31095: PPUSH
31096: CALL_OW 310
31100: IFFALSE 31111
// ComExitBuilding ( j ) ;
31102: LD_VAR 0 3
31106: PPUSH
31107: CALL_OW 122
// wait ( 3 ) ;
31111: LD_INT 3
31113: PPUSH
31114: CALL_OW 67
// if not mc_construct_list [ i ] then
31118: LD_EXP 94
31122: PUSH
31123: LD_VAR 0 2
31127: ARRAY
31128: NOT
31129: IFFALSE 31133
// break ;
31131: GO 31171
// if not HasTask ( j ) then
31133: LD_VAR 0 3
31137: PPUSH
31138: CALL_OW 314
31142: NOT
31143: IFFALSE 31169
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
31145: LD_VAR 0 3
31149: PPUSH
31150: LD_EXP 94
31154: PUSH
31155: LD_VAR 0 2
31159: ARRAY
31160: PUSH
31161: LD_INT 1
31163: ARRAY
31164: PPUSH
31165: CALL 60818 0 2
// end ;
31169: GO 31019
31171: POP
31172: POP
// end else
31173: GO 31978
// if mc_build_list [ i ] then
31175: LD_EXP 92
31179: PUSH
31180: LD_VAR 0 2
31184: ARRAY
31185: IFFALSE 31978
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31187: LD_ADDR_VAR 0 5
31191: PUSH
31192: LD_EXP 87
31196: PUSH
31197: LD_VAR 0 2
31201: ARRAY
31202: PPUSH
31203: LD_INT 2
31205: PUSH
31206: LD_INT 30
31208: PUSH
31209: LD_INT 0
31211: PUSH
31212: EMPTY
31213: LIST
31214: LIST
31215: PUSH
31216: LD_INT 30
31218: PUSH
31219: LD_INT 1
31221: PUSH
31222: EMPTY
31223: LIST
31224: LIST
31225: PUSH
31226: EMPTY
31227: LIST
31228: LIST
31229: LIST
31230: PPUSH
31231: CALL_OW 72
31235: ST_TO_ADDR
// if depot then
31236: LD_VAR 0 5
31240: IFFALSE 31258
// depot := depot [ 1 ] else
31242: LD_ADDR_VAR 0 5
31246: PUSH
31247: LD_VAR 0 5
31251: PUSH
31252: LD_INT 1
31254: ARRAY
31255: ST_TO_ADDR
31256: GO 31266
// depot := 0 ;
31258: LD_ADDR_VAR 0 5
31262: PUSH
31263: LD_INT 0
31265: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
31266: LD_EXP 92
31270: PUSH
31271: LD_VAR 0 2
31275: ARRAY
31276: PUSH
31277: LD_INT 1
31279: ARRAY
31280: PUSH
31281: LD_INT 1
31283: ARRAY
31284: PPUSH
31285: CALL 60648 0 1
31289: PUSH
31290: LD_EXP 87
31294: PUSH
31295: LD_VAR 0 2
31299: ARRAY
31300: PPUSH
31301: LD_INT 2
31303: PUSH
31304: LD_INT 30
31306: PUSH
31307: LD_INT 2
31309: PUSH
31310: EMPTY
31311: LIST
31312: LIST
31313: PUSH
31314: LD_INT 30
31316: PUSH
31317: LD_INT 3
31319: PUSH
31320: EMPTY
31321: LIST
31322: LIST
31323: PUSH
31324: EMPTY
31325: LIST
31326: LIST
31327: LIST
31328: PPUSH
31329: CALL_OW 72
31333: NOT
31334: AND
31335: IFFALSE 31440
// begin for j = 1 to mc_build_list [ i ] do
31337: LD_ADDR_VAR 0 3
31341: PUSH
31342: DOUBLE
31343: LD_INT 1
31345: DEC
31346: ST_TO_ADDR
31347: LD_EXP 92
31351: PUSH
31352: LD_VAR 0 2
31356: ARRAY
31357: PUSH
31358: FOR_TO
31359: IFFALSE 31438
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
31361: LD_EXP 92
31365: PUSH
31366: LD_VAR 0 2
31370: ARRAY
31371: PUSH
31372: LD_VAR 0 3
31376: ARRAY
31377: PUSH
31378: LD_INT 1
31380: ARRAY
31381: PUSH
31382: LD_INT 2
31384: EQUAL
31385: IFFALSE 31436
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
31387: LD_ADDR_EXP 92
31391: PUSH
31392: LD_EXP 92
31396: PPUSH
31397: LD_VAR 0 2
31401: PPUSH
31402: LD_EXP 92
31406: PUSH
31407: LD_VAR 0 2
31411: ARRAY
31412: PPUSH
31413: LD_VAR 0 3
31417: PPUSH
31418: LD_INT 1
31420: PPUSH
31421: LD_INT 0
31423: PPUSH
31424: CALL 57385 0 4
31428: PPUSH
31429: CALL_OW 1
31433: ST_TO_ADDR
// break ;
31434: GO 31438
// end ;
31436: GO 31358
31438: POP
31439: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
31440: LD_EXP 92
31444: PUSH
31445: LD_VAR 0 2
31449: ARRAY
31450: PUSH
31451: LD_INT 1
31453: ARRAY
31454: PUSH
31455: LD_INT 1
31457: ARRAY
31458: PUSH
31459: LD_INT 0
31461: EQUAL
31462: PUSH
31463: LD_VAR 0 5
31467: PUSH
31468: LD_VAR 0 5
31472: PPUSH
31473: LD_EXP 92
31477: PUSH
31478: LD_VAR 0 2
31482: ARRAY
31483: PUSH
31484: LD_INT 1
31486: ARRAY
31487: PUSH
31488: LD_INT 1
31490: ARRAY
31491: PPUSH
31492: LD_EXP 92
31496: PUSH
31497: LD_VAR 0 2
31501: ARRAY
31502: PUSH
31503: LD_INT 1
31505: ARRAY
31506: PUSH
31507: LD_INT 2
31509: ARRAY
31510: PPUSH
31511: LD_EXP 92
31515: PUSH
31516: LD_VAR 0 2
31520: ARRAY
31521: PUSH
31522: LD_INT 1
31524: ARRAY
31525: PUSH
31526: LD_INT 3
31528: ARRAY
31529: PPUSH
31530: LD_EXP 92
31534: PUSH
31535: LD_VAR 0 2
31539: ARRAY
31540: PUSH
31541: LD_INT 1
31543: ARRAY
31544: PUSH
31545: LD_INT 4
31547: ARRAY
31548: PPUSH
31549: CALL 65382 0 5
31553: AND
31554: OR
31555: IFFALSE 31836
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31557: LD_ADDR_VAR 0 4
31561: PUSH
31562: LD_EXP 87
31566: PUSH
31567: LD_VAR 0 2
31571: ARRAY
31572: PPUSH
31573: LD_INT 25
31575: PUSH
31576: LD_INT 2
31578: PUSH
31579: EMPTY
31580: LIST
31581: LIST
31582: PPUSH
31583: CALL_OW 72
31587: PUSH
31588: LD_EXP 89
31592: PUSH
31593: LD_VAR 0 2
31597: ARRAY
31598: DIFF
31599: ST_TO_ADDR
// if not tmp then
31600: LD_VAR 0 4
31604: NOT
31605: IFFALSE 31609
// continue ;
31607: GO 30854
// for j in tmp do
31609: LD_ADDR_VAR 0 3
31613: PUSH
31614: LD_VAR 0 4
31618: PUSH
31619: FOR_IN
31620: IFFALSE 31832
// begin if not mc_builders [ i ] then
31622: LD_EXP 93
31626: PUSH
31627: LD_VAR 0 2
31631: ARRAY
31632: NOT
31633: IFFALSE 31691
// begin SetTag ( j , 103 ) ;
31635: LD_VAR 0 3
31639: PPUSH
31640: LD_INT 103
31642: PPUSH
31643: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31647: LD_ADDR_EXP 93
31651: PUSH
31652: LD_EXP 93
31656: PPUSH
31657: LD_VAR 0 2
31661: PUSH
31662: LD_EXP 93
31666: PUSH
31667: LD_VAR 0 2
31671: ARRAY
31672: PUSH
31673: LD_INT 1
31675: PLUS
31676: PUSH
31677: EMPTY
31678: LIST
31679: LIST
31680: PPUSH
31681: LD_VAR 0 3
31685: PPUSH
31686: CALL 57967 0 3
31690: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31691: LD_VAR 0 3
31695: PPUSH
31696: CALL_OW 310
31700: IFFALSE 31711
// ComExitBuilding ( j ) ;
31702: LD_VAR 0 3
31706: PPUSH
31707: CALL_OW 122
// wait ( 3 ) ;
31711: LD_INT 3
31713: PPUSH
31714: CALL_OW 67
// if not mc_build_list [ i ] then
31718: LD_EXP 92
31722: PUSH
31723: LD_VAR 0 2
31727: ARRAY
31728: NOT
31729: IFFALSE 31733
// break ;
31731: GO 31832
// if not HasTask ( j ) then
31733: LD_VAR 0 3
31737: PPUSH
31738: CALL_OW 314
31742: NOT
31743: IFFALSE 31830
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
31745: LD_VAR 0 3
31749: PPUSH
31750: LD_EXP 92
31754: PUSH
31755: LD_VAR 0 2
31759: ARRAY
31760: PUSH
31761: LD_INT 1
31763: ARRAY
31764: PUSH
31765: LD_INT 1
31767: ARRAY
31768: PPUSH
31769: LD_EXP 92
31773: PUSH
31774: LD_VAR 0 2
31778: ARRAY
31779: PUSH
31780: LD_INT 1
31782: ARRAY
31783: PUSH
31784: LD_INT 2
31786: ARRAY
31787: PPUSH
31788: LD_EXP 92
31792: PUSH
31793: LD_VAR 0 2
31797: ARRAY
31798: PUSH
31799: LD_INT 1
31801: ARRAY
31802: PUSH
31803: LD_INT 3
31805: ARRAY
31806: PPUSH
31807: LD_EXP 92
31811: PUSH
31812: LD_VAR 0 2
31816: ARRAY
31817: PUSH
31818: LD_INT 1
31820: ARRAY
31821: PUSH
31822: LD_INT 4
31824: ARRAY
31825: PPUSH
31826: CALL_OW 145
// end ;
31830: GO 31619
31832: POP
31833: POP
// end else
31834: GO 31978
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
31836: LD_EXP 87
31840: PUSH
31841: LD_VAR 0 2
31845: ARRAY
31846: PPUSH
31847: LD_EXP 92
31851: PUSH
31852: LD_VAR 0 2
31856: ARRAY
31857: PUSH
31858: LD_INT 1
31860: ARRAY
31861: PUSH
31862: LD_INT 1
31864: ARRAY
31865: PPUSH
31866: LD_EXP 92
31870: PUSH
31871: LD_VAR 0 2
31875: ARRAY
31876: PUSH
31877: LD_INT 1
31879: ARRAY
31880: PUSH
31881: LD_INT 2
31883: ARRAY
31884: PPUSH
31885: LD_EXP 92
31889: PUSH
31890: LD_VAR 0 2
31894: ARRAY
31895: PUSH
31896: LD_INT 1
31898: ARRAY
31899: PUSH
31900: LD_INT 3
31902: ARRAY
31903: PPUSH
31904: LD_EXP 92
31908: PUSH
31909: LD_VAR 0 2
31913: ARRAY
31914: PUSH
31915: LD_INT 1
31917: ARRAY
31918: PUSH
31919: LD_INT 4
31921: ARRAY
31922: PPUSH
31923: CALL 64718 0 5
31927: NOT
31928: IFFALSE 31978
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
31930: LD_ADDR_EXP 92
31934: PUSH
31935: LD_EXP 92
31939: PPUSH
31940: LD_VAR 0 2
31944: PPUSH
31945: LD_EXP 92
31949: PUSH
31950: LD_VAR 0 2
31954: ARRAY
31955: PPUSH
31956: LD_INT 1
31958: PPUSH
31959: LD_INT 1
31961: NEG
31962: PPUSH
31963: LD_INT 0
31965: PPUSH
31966: CALL 57385 0 4
31970: PPUSH
31971: CALL_OW 1
31975: ST_TO_ADDR
// continue ;
31976: GO 30854
// end ; end ; end ;
31978: GO 30854
31980: POP
31981: POP
// end ;
31982: LD_VAR 0 1
31986: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
31987: LD_INT 0
31989: PPUSH
31990: PPUSH
31991: PPUSH
31992: PPUSH
31993: PPUSH
31994: PPUSH
// if not mc_bases then
31995: LD_EXP 87
31999: NOT
32000: IFFALSE 32004
// exit ;
32002: GO 32431
// for i = 1 to mc_bases do
32004: LD_ADDR_VAR 0 2
32008: PUSH
32009: DOUBLE
32010: LD_INT 1
32012: DEC
32013: ST_TO_ADDR
32014: LD_EXP 87
32018: PUSH
32019: FOR_TO
32020: IFFALSE 32429
// begin tmp := mc_build_upgrade [ i ] ;
32022: LD_ADDR_VAR 0 4
32026: PUSH
32027: LD_EXP 119
32031: PUSH
32032: LD_VAR 0 2
32036: ARRAY
32037: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
32038: LD_ADDR_VAR 0 6
32042: PUSH
32043: LD_EXP 120
32047: PUSH
32048: LD_VAR 0 2
32052: ARRAY
32053: PPUSH
32054: LD_INT 2
32056: PUSH
32057: LD_INT 30
32059: PUSH
32060: LD_INT 6
32062: PUSH
32063: EMPTY
32064: LIST
32065: LIST
32066: PUSH
32067: LD_INT 30
32069: PUSH
32070: LD_INT 7
32072: PUSH
32073: EMPTY
32074: LIST
32075: LIST
32076: PUSH
32077: EMPTY
32078: LIST
32079: LIST
32080: LIST
32081: PPUSH
32082: CALL_OW 72
32086: ST_TO_ADDR
// if not tmp and not lab then
32087: LD_VAR 0 4
32091: NOT
32092: PUSH
32093: LD_VAR 0 6
32097: NOT
32098: AND
32099: IFFALSE 32103
// continue ;
32101: GO 32019
// if tmp then
32103: LD_VAR 0 4
32107: IFFALSE 32227
// for j in tmp do
32109: LD_ADDR_VAR 0 3
32113: PUSH
32114: LD_VAR 0 4
32118: PUSH
32119: FOR_IN
32120: IFFALSE 32225
// begin if UpgradeCost ( j ) then
32122: LD_VAR 0 3
32126: PPUSH
32127: CALL 64378 0 1
32131: IFFALSE 32223
// begin ComUpgrade ( j ) ;
32133: LD_VAR 0 3
32137: PPUSH
32138: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
32142: LD_ADDR_EXP 119
32146: PUSH
32147: LD_EXP 119
32151: PPUSH
32152: LD_VAR 0 2
32156: PPUSH
32157: LD_EXP 119
32161: PUSH
32162: LD_VAR 0 2
32166: ARRAY
32167: PUSH
32168: LD_VAR 0 3
32172: DIFF
32173: PPUSH
32174: CALL_OW 1
32178: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
32179: LD_ADDR_EXP 94
32183: PUSH
32184: LD_EXP 94
32188: PPUSH
32189: LD_VAR 0 2
32193: PUSH
32194: LD_EXP 94
32198: PUSH
32199: LD_VAR 0 2
32203: ARRAY
32204: PUSH
32205: LD_INT 1
32207: PLUS
32208: PUSH
32209: EMPTY
32210: LIST
32211: LIST
32212: PPUSH
32213: LD_VAR 0 3
32217: PPUSH
32218: CALL 57967 0 3
32222: ST_TO_ADDR
// end ; end ;
32223: GO 32119
32225: POP
32226: POP
// if not lab or not mc_lab_upgrade [ i ] then
32227: LD_VAR 0 6
32231: NOT
32232: PUSH
32233: LD_EXP 121
32237: PUSH
32238: LD_VAR 0 2
32242: ARRAY
32243: NOT
32244: OR
32245: IFFALSE 32249
// continue ;
32247: GO 32019
// for j in lab do
32249: LD_ADDR_VAR 0 3
32253: PUSH
32254: LD_VAR 0 6
32258: PUSH
32259: FOR_IN
32260: IFFALSE 32425
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
32262: LD_VAR 0 3
32266: PPUSH
32267: CALL_OW 266
32271: PUSH
32272: LD_INT 6
32274: PUSH
32275: LD_INT 7
32277: PUSH
32278: EMPTY
32279: LIST
32280: LIST
32281: IN
32282: PUSH
32283: LD_VAR 0 3
32287: PPUSH
32288: CALL_OW 461
32292: PUSH
32293: LD_INT 1
32295: NONEQUAL
32296: AND
32297: IFFALSE 32423
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
32299: LD_VAR 0 3
32303: PPUSH
32304: LD_EXP 121
32308: PUSH
32309: LD_VAR 0 2
32313: ARRAY
32314: PUSH
32315: LD_INT 1
32317: ARRAY
32318: PPUSH
32319: CALL 64583 0 2
32323: IFFALSE 32423
// begin ComCancel ( j ) ;
32325: LD_VAR 0 3
32329: PPUSH
32330: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
32334: LD_VAR 0 3
32338: PPUSH
32339: LD_EXP 121
32343: PUSH
32344: LD_VAR 0 2
32348: ARRAY
32349: PUSH
32350: LD_INT 1
32352: ARRAY
32353: PPUSH
32354: CALL_OW 207
// if not j in mc_construct_list [ i ] then
32358: LD_VAR 0 3
32362: PUSH
32363: LD_EXP 94
32367: PUSH
32368: LD_VAR 0 2
32372: ARRAY
32373: IN
32374: NOT
32375: IFFALSE 32421
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
32377: LD_ADDR_EXP 94
32381: PUSH
32382: LD_EXP 94
32386: PPUSH
32387: LD_VAR 0 2
32391: PUSH
32392: LD_EXP 94
32396: PUSH
32397: LD_VAR 0 2
32401: ARRAY
32402: PUSH
32403: LD_INT 1
32405: PLUS
32406: PUSH
32407: EMPTY
32408: LIST
32409: LIST
32410: PPUSH
32411: LD_VAR 0 3
32415: PPUSH
32416: CALL 57967 0 3
32420: ST_TO_ADDR
// break ;
32421: GO 32425
// end ; end ; end ;
32423: GO 32259
32425: POP
32426: POP
// end ;
32427: GO 32019
32429: POP
32430: POP
// end ;
32431: LD_VAR 0 1
32435: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
32436: LD_INT 0
32438: PPUSH
32439: PPUSH
32440: PPUSH
32441: PPUSH
32442: PPUSH
32443: PPUSH
32444: PPUSH
32445: PPUSH
32446: PPUSH
// if not mc_bases then
32447: LD_EXP 87
32451: NOT
32452: IFFALSE 32456
// exit ;
32454: GO 32861
// for i = 1 to mc_bases do
32456: LD_ADDR_VAR 0 2
32460: PUSH
32461: DOUBLE
32462: LD_INT 1
32464: DEC
32465: ST_TO_ADDR
32466: LD_EXP 87
32470: PUSH
32471: FOR_TO
32472: IFFALSE 32859
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
32474: LD_EXP 95
32478: PUSH
32479: LD_VAR 0 2
32483: ARRAY
32484: NOT
32485: PUSH
32486: LD_EXP 87
32490: PUSH
32491: LD_VAR 0 2
32495: ARRAY
32496: PPUSH
32497: LD_INT 30
32499: PUSH
32500: LD_INT 3
32502: PUSH
32503: EMPTY
32504: LIST
32505: LIST
32506: PPUSH
32507: CALL_OW 72
32511: NOT
32512: OR
32513: IFFALSE 32517
// continue ;
32515: GO 32471
// busy := false ;
32517: LD_ADDR_VAR 0 8
32521: PUSH
32522: LD_INT 0
32524: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32525: LD_ADDR_VAR 0 4
32529: PUSH
32530: LD_EXP 87
32534: PUSH
32535: LD_VAR 0 2
32539: ARRAY
32540: PPUSH
32541: LD_INT 30
32543: PUSH
32544: LD_INT 3
32546: PUSH
32547: EMPTY
32548: LIST
32549: LIST
32550: PPUSH
32551: CALL_OW 72
32555: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
32556: LD_ADDR_VAR 0 6
32560: PUSH
32561: LD_EXP 95
32565: PUSH
32566: LD_VAR 0 2
32570: ARRAY
32571: PPUSH
32572: LD_INT 2
32574: PUSH
32575: LD_INT 30
32577: PUSH
32578: LD_INT 32
32580: PUSH
32581: EMPTY
32582: LIST
32583: LIST
32584: PUSH
32585: LD_INT 30
32587: PUSH
32588: LD_INT 33
32590: PUSH
32591: EMPTY
32592: LIST
32593: LIST
32594: PUSH
32595: EMPTY
32596: LIST
32597: LIST
32598: LIST
32599: PPUSH
32600: CALL_OW 72
32604: ST_TO_ADDR
// if not t then
32605: LD_VAR 0 6
32609: NOT
32610: IFFALSE 32614
// continue ;
32612: GO 32471
// for j in tmp do
32614: LD_ADDR_VAR 0 3
32618: PUSH
32619: LD_VAR 0 4
32623: PUSH
32624: FOR_IN
32625: IFFALSE 32655
// if not BuildingStatus ( j ) = bs_idle then
32627: LD_VAR 0 3
32631: PPUSH
32632: CALL_OW 461
32636: PUSH
32637: LD_INT 2
32639: EQUAL
32640: NOT
32641: IFFALSE 32653
// begin busy := true ;
32643: LD_ADDR_VAR 0 8
32647: PUSH
32648: LD_INT 1
32650: ST_TO_ADDR
// break ;
32651: GO 32655
// end ;
32653: GO 32624
32655: POP
32656: POP
// if busy then
32657: LD_VAR 0 8
32661: IFFALSE 32665
// continue ;
32663: GO 32471
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
32665: LD_ADDR_VAR 0 7
32669: PUSH
32670: LD_VAR 0 6
32674: PPUSH
32675: LD_INT 35
32677: PUSH
32678: LD_INT 0
32680: PUSH
32681: EMPTY
32682: LIST
32683: LIST
32684: PPUSH
32685: CALL_OW 72
32689: ST_TO_ADDR
// if tw then
32690: LD_VAR 0 7
32694: IFFALSE 32771
// begin tw := tw [ 1 ] ;
32696: LD_ADDR_VAR 0 7
32700: PUSH
32701: LD_VAR 0 7
32705: PUSH
32706: LD_INT 1
32708: ARRAY
32709: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
32710: LD_ADDR_VAR 0 9
32714: PUSH
32715: LD_VAR 0 7
32719: PPUSH
32720: LD_EXP 112
32724: PUSH
32725: LD_VAR 0 2
32729: ARRAY
32730: PPUSH
32731: CALL 62937 0 2
32735: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
32736: LD_EXP 126
32740: PUSH
32741: LD_VAR 0 2
32745: ARRAY
32746: IFFALSE 32769
// if not weapon in mc_allowed_tower_weapons [ i ] then
32748: LD_VAR 0 9
32752: PUSH
32753: LD_EXP 126
32757: PUSH
32758: LD_VAR 0 2
32762: ARRAY
32763: IN
32764: NOT
32765: IFFALSE 32769
// continue ;
32767: GO 32471
// end else
32769: GO 32834
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
32771: LD_ADDR_VAR 0 5
32775: PUSH
32776: LD_EXP 95
32780: PUSH
32781: LD_VAR 0 2
32785: ARRAY
32786: PPUSH
32787: LD_VAR 0 4
32791: PPUSH
32792: CALL 93148 0 2
32796: ST_TO_ADDR
// if not tmp2 then
32797: LD_VAR 0 5
32801: NOT
32802: IFFALSE 32806
// continue ;
32804: GO 32471
// tw := tmp2 [ 1 ] ;
32806: LD_ADDR_VAR 0 7
32810: PUSH
32811: LD_VAR 0 5
32815: PUSH
32816: LD_INT 1
32818: ARRAY
32819: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
32820: LD_ADDR_VAR 0 9
32824: PUSH
32825: LD_VAR 0 5
32829: PUSH
32830: LD_INT 2
32832: ARRAY
32833: ST_TO_ADDR
// end ; if not weapon then
32834: LD_VAR 0 9
32838: NOT
32839: IFFALSE 32843
// continue ;
32841: GO 32471
// ComPlaceWeapon ( tw , weapon ) ;
32843: LD_VAR 0 7
32847: PPUSH
32848: LD_VAR 0 9
32852: PPUSH
32853: CALL_OW 148
// end ;
32857: GO 32471
32859: POP
32860: POP
// end ;
32861: LD_VAR 0 1
32865: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
32866: LD_INT 0
32868: PPUSH
32869: PPUSH
32870: PPUSH
32871: PPUSH
32872: PPUSH
32873: PPUSH
// if not mc_bases then
32874: LD_EXP 87
32878: NOT
32879: IFFALSE 32883
// exit ;
32881: GO 33659
// for i = 1 to mc_bases do
32883: LD_ADDR_VAR 0 2
32887: PUSH
32888: DOUBLE
32889: LD_INT 1
32891: DEC
32892: ST_TO_ADDR
32893: LD_EXP 87
32897: PUSH
32898: FOR_TO
32899: IFFALSE 33657
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
32901: LD_EXP 100
32905: PUSH
32906: LD_VAR 0 2
32910: ARRAY
32911: NOT
32912: PUSH
32913: LD_EXP 100
32917: PUSH
32918: LD_VAR 0 2
32922: ARRAY
32923: PUSH
32924: LD_EXP 101
32928: PUSH
32929: LD_VAR 0 2
32933: ARRAY
32934: EQUAL
32935: OR
32936: PUSH
32937: LD_EXP 110
32941: PUSH
32942: LD_VAR 0 2
32946: ARRAY
32947: OR
32948: IFFALSE 32952
// continue ;
32950: GO 32898
// if mc_miners [ i ] then
32952: LD_EXP 101
32956: PUSH
32957: LD_VAR 0 2
32961: ARRAY
32962: IFFALSE 33344
// begin for j = mc_miners [ i ] downto 1 do
32964: LD_ADDR_VAR 0 3
32968: PUSH
32969: DOUBLE
32970: LD_EXP 101
32974: PUSH
32975: LD_VAR 0 2
32979: ARRAY
32980: INC
32981: ST_TO_ADDR
32982: LD_INT 1
32984: PUSH
32985: FOR_DOWNTO
32986: IFFALSE 33342
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
32988: LD_EXP 101
32992: PUSH
32993: LD_VAR 0 2
32997: ARRAY
32998: PUSH
32999: LD_VAR 0 3
33003: ARRAY
33004: PPUSH
33005: CALL_OW 301
33009: PUSH
33010: LD_EXP 101
33014: PUSH
33015: LD_VAR 0 2
33019: ARRAY
33020: PUSH
33021: LD_VAR 0 3
33025: ARRAY
33026: PPUSH
33027: CALL_OW 257
33031: PUSH
33032: LD_INT 1
33034: NONEQUAL
33035: OR
33036: IFFALSE 33099
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
33038: LD_ADDR_VAR 0 5
33042: PUSH
33043: LD_EXP 101
33047: PUSH
33048: LD_VAR 0 2
33052: ARRAY
33053: PUSH
33054: LD_EXP 101
33058: PUSH
33059: LD_VAR 0 2
33063: ARRAY
33064: PUSH
33065: LD_VAR 0 3
33069: ARRAY
33070: DIFF
33071: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
33072: LD_ADDR_EXP 101
33076: PUSH
33077: LD_EXP 101
33081: PPUSH
33082: LD_VAR 0 2
33086: PPUSH
33087: LD_VAR 0 5
33091: PPUSH
33092: CALL_OW 1
33096: ST_TO_ADDR
// continue ;
33097: GO 32985
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
33099: LD_EXP 101
33103: PUSH
33104: LD_VAR 0 2
33108: ARRAY
33109: PUSH
33110: LD_VAR 0 3
33114: ARRAY
33115: PPUSH
33116: CALL_OW 257
33120: PUSH
33121: LD_INT 1
33123: EQUAL
33124: PUSH
33125: LD_EXP 101
33129: PUSH
33130: LD_VAR 0 2
33134: ARRAY
33135: PUSH
33136: LD_VAR 0 3
33140: ARRAY
33141: PPUSH
33142: CALL_OW 459
33146: NOT
33147: AND
33148: PUSH
33149: LD_EXP 101
33153: PUSH
33154: LD_VAR 0 2
33158: ARRAY
33159: PUSH
33160: LD_VAR 0 3
33164: ARRAY
33165: PPUSH
33166: CALL_OW 314
33170: NOT
33171: AND
33172: IFFALSE 33340
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
33174: LD_EXP 101
33178: PUSH
33179: LD_VAR 0 2
33183: ARRAY
33184: PUSH
33185: LD_VAR 0 3
33189: ARRAY
33190: PPUSH
33191: CALL_OW 310
33195: IFFALSE 33218
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
33197: LD_EXP 101
33201: PUSH
33202: LD_VAR 0 2
33206: ARRAY
33207: PUSH
33208: LD_VAR 0 3
33212: ARRAY
33213: PPUSH
33214: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
33218: LD_EXP 101
33222: PUSH
33223: LD_VAR 0 2
33227: ARRAY
33228: PUSH
33229: LD_VAR 0 3
33233: ARRAY
33234: PPUSH
33235: CALL_OW 314
33239: NOT
33240: IFFALSE 33340
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
33242: LD_EXP 101
33246: PUSH
33247: LD_VAR 0 2
33251: ARRAY
33252: PUSH
33253: LD_VAR 0 3
33257: ARRAY
33258: PPUSH
33259: LD_EXP 100
33263: PUSH
33264: LD_VAR 0 2
33268: ARRAY
33269: PUSH
33270: LD_VAR 0 3
33274: PUSH
33275: LD_EXP 100
33279: PUSH
33280: LD_VAR 0 2
33284: ARRAY
33285: MOD
33286: PUSH
33287: LD_INT 1
33289: PLUS
33290: ARRAY
33291: PUSH
33292: LD_INT 1
33294: ARRAY
33295: PPUSH
33296: LD_EXP 100
33300: PUSH
33301: LD_VAR 0 2
33305: ARRAY
33306: PUSH
33307: LD_VAR 0 3
33311: PUSH
33312: LD_EXP 100
33316: PUSH
33317: LD_VAR 0 2
33321: ARRAY
33322: MOD
33323: PUSH
33324: LD_INT 1
33326: PLUS
33327: ARRAY
33328: PUSH
33329: LD_INT 2
33331: ARRAY
33332: PPUSH
33333: LD_INT 0
33335: PPUSH
33336: CALL_OW 193
// end ; end ;
33340: GO 32985
33342: POP
33343: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
33344: LD_ADDR_VAR 0 5
33348: PUSH
33349: LD_EXP 87
33353: PUSH
33354: LD_VAR 0 2
33358: ARRAY
33359: PPUSH
33360: LD_INT 2
33362: PUSH
33363: LD_INT 30
33365: PUSH
33366: LD_INT 4
33368: PUSH
33369: EMPTY
33370: LIST
33371: LIST
33372: PUSH
33373: LD_INT 30
33375: PUSH
33376: LD_INT 5
33378: PUSH
33379: EMPTY
33380: LIST
33381: LIST
33382: PUSH
33383: LD_INT 30
33385: PUSH
33386: LD_INT 32
33388: PUSH
33389: EMPTY
33390: LIST
33391: LIST
33392: PUSH
33393: EMPTY
33394: LIST
33395: LIST
33396: LIST
33397: LIST
33398: PPUSH
33399: CALL_OW 72
33403: ST_TO_ADDR
// if not tmp then
33404: LD_VAR 0 5
33408: NOT
33409: IFFALSE 33413
// continue ;
33411: GO 32898
// list := [ ] ;
33413: LD_ADDR_VAR 0 6
33417: PUSH
33418: EMPTY
33419: ST_TO_ADDR
// for j in tmp do
33420: LD_ADDR_VAR 0 3
33424: PUSH
33425: LD_VAR 0 5
33429: PUSH
33430: FOR_IN
33431: IFFALSE 33500
// begin for k in UnitsInside ( j ) do
33433: LD_ADDR_VAR 0 4
33437: PUSH
33438: LD_VAR 0 3
33442: PPUSH
33443: CALL_OW 313
33447: PUSH
33448: FOR_IN
33449: IFFALSE 33496
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
33451: LD_VAR 0 4
33455: PPUSH
33456: CALL_OW 257
33460: PUSH
33461: LD_INT 1
33463: EQUAL
33464: PUSH
33465: LD_VAR 0 4
33469: PPUSH
33470: CALL_OW 459
33474: NOT
33475: AND
33476: IFFALSE 33494
// list := list ^ k ;
33478: LD_ADDR_VAR 0 6
33482: PUSH
33483: LD_VAR 0 6
33487: PUSH
33488: LD_VAR 0 4
33492: ADD
33493: ST_TO_ADDR
33494: GO 33448
33496: POP
33497: POP
// end ;
33498: GO 33430
33500: POP
33501: POP
// list := list diff mc_miners [ i ] ;
33502: LD_ADDR_VAR 0 6
33506: PUSH
33507: LD_VAR 0 6
33511: PUSH
33512: LD_EXP 101
33516: PUSH
33517: LD_VAR 0 2
33521: ARRAY
33522: DIFF
33523: ST_TO_ADDR
// if not list then
33524: LD_VAR 0 6
33528: NOT
33529: IFFALSE 33533
// continue ;
33531: GO 32898
// k := mc_mines [ i ] - mc_miners [ i ] ;
33533: LD_ADDR_VAR 0 4
33537: PUSH
33538: LD_EXP 100
33542: PUSH
33543: LD_VAR 0 2
33547: ARRAY
33548: PUSH
33549: LD_EXP 101
33553: PUSH
33554: LD_VAR 0 2
33558: ARRAY
33559: MINUS
33560: ST_TO_ADDR
// if k > list then
33561: LD_VAR 0 4
33565: PUSH
33566: LD_VAR 0 6
33570: GREATER
33571: IFFALSE 33583
// k := list ;
33573: LD_ADDR_VAR 0 4
33577: PUSH
33578: LD_VAR 0 6
33582: ST_TO_ADDR
// for j = 1 to k do
33583: LD_ADDR_VAR 0 3
33587: PUSH
33588: DOUBLE
33589: LD_INT 1
33591: DEC
33592: ST_TO_ADDR
33593: LD_VAR 0 4
33597: PUSH
33598: FOR_TO
33599: IFFALSE 33653
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
33601: LD_ADDR_EXP 101
33605: PUSH
33606: LD_EXP 101
33610: PPUSH
33611: LD_VAR 0 2
33615: PUSH
33616: LD_EXP 101
33620: PUSH
33621: LD_VAR 0 2
33625: ARRAY
33626: PUSH
33627: LD_INT 1
33629: PLUS
33630: PUSH
33631: EMPTY
33632: LIST
33633: LIST
33634: PPUSH
33635: LD_VAR 0 6
33639: PUSH
33640: LD_VAR 0 3
33644: ARRAY
33645: PPUSH
33646: CALL 57967 0 3
33650: ST_TO_ADDR
33651: GO 33598
33653: POP
33654: POP
// end ;
33655: GO 32898
33657: POP
33658: POP
// end ;
33659: LD_VAR 0 1
33663: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
33664: LD_INT 0
33666: PPUSH
33667: PPUSH
33668: PPUSH
33669: PPUSH
33670: PPUSH
33671: PPUSH
33672: PPUSH
33673: PPUSH
33674: PPUSH
33675: PPUSH
// if not mc_bases then
33676: LD_EXP 87
33680: NOT
33681: IFFALSE 33685
// exit ;
33683: GO 35435
// for i = 1 to mc_bases do
33685: LD_ADDR_VAR 0 2
33689: PUSH
33690: DOUBLE
33691: LD_INT 1
33693: DEC
33694: ST_TO_ADDR
33695: LD_EXP 87
33699: PUSH
33700: FOR_TO
33701: IFFALSE 35433
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
33703: LD_EXP 87
33707: PUSH
33708: LD_VAR 0 2
33712: ARRAY
33713: NOT
33714: PUSH
33715: LD_EXP 94
33719: PUSH
33720: LD_VAR 0 2
33724: ARRAY
33725: OR
33726: IFFALSE 33730
// continue ;
33728: GO 33700
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
33730: LD_EXP 103
33734: PUSH
33735: LD_VAR 0 2
33739: ARRAY
33740: NOT
33741: PUSH
33742: LD_EXP 104
33746: PUSH
33747: LD_VAR 0 2
33751: ARRAY
33752: AND
33753: IFFALSE 33791
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
33755: LD_ADDR_EXP 104
33759: PUSH
33760: LD_EXP 104
33764: PPUSH
33765: LD_VAR 0 2
33769: PPUSH
33770: EMPTY
33771: PPUSH
33772: CALL_OW 1
33776: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
33777: LD_VAR 0 2
33781: PPUSH
33782: LD_INT 107
33784: PPUSH
33785: CALL 24649 0 2
// continue ;
33789: GO 33700
// end ; target := [ ] ;
33791: LD_ADDR_VAR 0 6
33795: PUSH
33796: EMPTY
33797: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
33798: LD_ADDR_VAR 0 3
33802: PUSH
33803: DOUBLE
33804: LD_EXP 103
33808: PUSH
33809: LD_VAR 0 2
33813: ARRAY
33814: INC
33815: ST_TO_ADDR
33816: LD_INT 1
33818: PUSH
33819: FOR_DOWNTO
33820: IFFALSE 34080
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
33822: LD_EXP 103
33826: PUSH
33827: LD_VAR 0 2
33831: ARRAY
33832: PUSH
33833: LD_VAR 0 3
33837: ARRAY
33838: PUSH
33839: LD_INT 2
33841: ARRAY
33842: PPUSH
33843: LD_EXP 103
33847: PUSH
33848: LD_VAR 0 2
33852: ARRAY
33853: PUSH
33854: LD_VAR 0 3
33858: ARRAY
33859: PUSH
33860: LD_INT 3
33862: ARRAY
33863: PPUSH
33864: CALL_OW 488
33868: PUSH
33869: LD_EXP 103
33873: PUSH
33874: LD_VAR 0 2
33878: ARRAY
33879: PUSH
33880: LD_VAR 0 3
33884: ARRAY
33885: PUSH
33886: LD_INT 2
33888: ARRAY
33889: PPUSH
33890: LD_EXP 103
33894: PUSH
33895: LD_VAR 0 2
33899: ARRAY
33900: PUSH
33901: LD_VAR 0 3
33905: ARRAY
33906: PUSH
33907: LD_INT 3
33909: ARRAY
33910: PPUSH
33911: CALL_OW 284
33915: PUSH
33916: LD_INT 0
33918: EQUAL
33919: AND
33920: IFFALSE 33975
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
33922: LD_ADDR_VAR 0 5
33926: PUSH
33927: LD_EXP 103
33931: PUSH
33932: LD_VAR 0 2
33936: ARRAY
33937: PPUSH
33938: LD_VAR 0 3
33942: PPUSH
33943: CALL_OW 3
33947: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
33948: LD_ADDR_EXP 103
33952: PUSH
33953: LD_EXP 103
33957: PPUSH
33958: LD_VAR 0 2
33962: PPUSH
33963: LD_VAR 0 5
33967: PPUSH
33968: CALL_OW 1
33972: ST_TO_ADDR
// continue ;
33973: GO 33819
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
33975: LD_EXP 87
33979: PUSH
33980: LD_VAR 0 2
33984: ARRAY
33985: PUSH
33986: LD_INT 1
33988: ARRAY
33989: PPUSH
33990: CALL_OW 255
33994: PPUSH
33995: LD_EXP 103
33999: PUSH
34000: LD_VAR 0 2
34004: ARRAY
34005: PUSH
34006: LD_VAR 0 3
34010: ARRAY
34011: PUSH
34012: LD_INT 2
34014: ARRAY
34015: PPUSH
34016: LD_EXP 103
34020: PUSH
34021: LD_VAR 0 2
34025: ARRAY
34026: PUSH
34027: LD_VAR 0 3
34031: ARRAY
34032: PUSH
34033: LD_INT 3
34035: ARRAY
34036: PPUSH
34037: LD_INT 30
34039: PPUSH
34040: CALL 58863 0 4
34044: PUSH
34045: LD_INT 4
34047: ARRAY
34048: PUSH
34049: LD_INT 0
34051: EQUAL
34052: IFFALSE 34078
// begin target := mc_crates [ i ] [ j ] ;
34054: LD_ADDR_VAR 0 6
34058: PUSH
34059: LD_EXP 103
34063: PUSH
34064: LD_VAR 0 2
34068: ARRAY
34069: PUSH
34070: LD_VAR 0 3
34074: ARRAY
34075: ST_TO_ADDR
// break ;
34076: GO 34080
// end ; end ;
34078: GO 33819
34080: POP
34081: POP
// if not target then
34082: LD_VAR 0 6
34086: NOT
34087: IFFALSE 34091
// continue ;
34089: GO 33700
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
34091: LD_ADDR_VAR 0 7
34095: PUSH
34096: LD_EXP 106
34100: PUSH
34101: LD_VAR 0 2
34105: ARRAY
34106: PPUSH
34107: LD_INT 2
34109: PUSH
34110: LD_INT 3
34112: PUSH
34113: LD_INT 58
34115: PUSH
34116: EMPTY
34117: LIST
34118: PUSH
34119: EMPTY
34120: LIST
34121: LIST
34122: PUSH
34123: LD_INT 61
34125: PUSH
34126: EMPTY
34127: LIST
34128: PUSH
34129: LD_INT 33
34131: PUSH
34132: LD_INT 5
34134: PUSH
34135: EMPTY
34136: LIST
34137: LIST
34138: PUSH
34139: LD_INT 33
34141: PUSH
34142: LD_INT 3
34144: PUSH
34145: EMPTY
34146: LIST
34147: LIST
34148: PUSH
34149: EMPTY
34150: LIST
34151: LIST
34152: LIST
34153: LIST
34154: LIST
34155: PUSH
34156: LD_INT 2
34158: PUSH
34159: LD_INT 34
34161: PUSH
34162: LD_INT 32
34164: PUSH
34165: EMPTY
34166: LIST
34167: LIST
34168: PUSH
34169: LD_INT 34
34171: PUSH
34172: LD_INT 51
34174: PUSH
34175: EMPTY
34176: LIST
34177: LIST
34178: PUSH
34179: LD_INT 34
34181: PUSH
34182: LD_INT 12
34184: PUSH
34185: EMPTY
34186: LIST
34187: LIST
34188: PUSH
34189: EMPTY
34190: LIST
34191: LIST
34192: LIST
34193: LIST
34194: PUSH
34195: EMPTY
34196: LIST
34197: LIST
34198: PPUSH
34199: CALL_OW 72
34203: ST_TO_ADDR
// if not cargo then
34204: LD_VAR 0 7
34208: NOT
34209: IFFALSE 34852
// begin if mc_crates_collector [ i ] < 5 then
34211: LD_EXP 104
34215: PUSH
34216: LD_VAR 0 2
34220: ARRAY
34221: PUSH
34222: LD_INT 5
34224: LESS
34225: IFFALSE 34591
// begin if mc_ape [ i ] then
34227: LD_EXP 116
34231: PUSH
34232: LD_VAR 0 2
34236: ARRAY
34237: IFFALSE 34284
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
34239: LD_ADDR_VAR 0 5
34243: PUSH
34244: LD_EXP 116
34248: PUSH
34249: LD_VAR 0 2
34253: ARRAY
34254: PPUSH
34255: LD_INT 25
34257: PUSH
34258: LD_INT 16
34260: PUSH
34261: EMPTY
34262: LIST
34263: LIST
34264: PUSH
34265: LD_INT 24
34267: PUSH
34268: LD_INT 750
34270: PUSH
34271: EMPTY
34272: LIST
34273: LIST
34274: PUSH
34275: EMPTY
34276: LIST
34277: LIST
34278: PPUSH
34279: CALL_OW 72
34283: ST_TO_ADDR
// if not tmp then
34284: LD_VAR 0 5
34288: NOT
34289: IFFALSE 34336
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
34291: LD_ADDR_VAR 0 5
34295: PUSH
34296: LD_EXP 87
34300: PUSH
34301: LD_VAR 0 2
34305: ARRAY
34306: PPUSH
34307: LD_INT 25
34309: PUSH
34310: LD_INT 2
34312: PUSH
34313: EMPTY
34314: LIST
34315: LIST
34316: PUSH
34317: LD_INT 24
34319: PUSH
34320: LD_INT 750
34322: PUSH
34323: EMPTY
34324: LIST
34325: LIST
34326: PUSH
34327: EMPTY
34328: LIST
34329: LIST
34330: PPUSH
34331: CALL_OW 72
34335: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
34336: LD_EXP 116
34340: PUSH
34341: LD_VAR 0 2
34345: ARRAY
34346: PUSH
34347: LD_EXP 87
34351: PUSH
34352: LD_VAR 0 2
34356: ARRAY
34357: PPUSH
34358: LD_INT 25
34360: PUSH
34361: LD_INT 2
34363: PUSH
34364: EMPTY
34365: LIST
34366: LIST
34367: PUSH
34368: LD_INT 24
34370: PUSH
34371: LD_INT 750
34373: PUSH
34374: EMPTY
34375: LIST
34376: LIST
34377: PUSH
34378: EMPTY
34379: LIST
34380: LIST
34381: PPUSH
34382: CALL_OW 72
34386: AND
34387: PUSH
34388: LD_VAR 0 5
34392: PUSH
34393: LD_INT 5
34395: LESS
34396: AND
34397: IFFALSE 34479
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
34399: LD_ADDR_VAR 0 3
34403: PUSH
34404: LD_EXP 87
34408: PUSH
34409: LD_VAR 0 2
34413: ARRAY
34414: PPUSH
34415: LD_INT 25
34417: PUSH
34418: LD_INT 2
34420: PUSH
34421: EMPTY
34422: LIST
34423: LIST
34424: PUSH
34425: LD_INT 24
34427: PUSH
34428: LD_INT 750
34430: PUSH
34431: EMPTY
34432: LIST
34433: LIST
34434: PUSH
34435: EMPTY
34436: LIST
34437: LIST
34438: PPUSH
34439: CALL_OW 72
34443: PUSH
34444: FOR_IN
34445: IFFALSE 34477
// begin tmp := tmp union j ;
34447: LD_ADDR_VAR 0 5
34451: PUSH
34452: LD_VAR 0 5
34456: PUSH
34457: LD_VAR 0 3
34461: UNION
34462: ST_TO_ADDR
// if tmp >= 5 then
34463: LD_VAR 0 5
34467: PUSH
34468: LD_INT 5
34470: GREATEREQUAL
34471: IFFALSE 34475
// break ;
34473: GO 34477
// end ;
34475: GO 34444
34477: POP
34478: POP
// end ; if not tmp then
34479: LD_VAR 0 5
34483: NOT
34484: IFFALSE 34488
// continue ;
34486: GO 33700
// for j in tmp do
34488: LD_ADDR_VAR 0 3
34492: PUSH
34493: LD_VAR 0 5
34497: PUSH
34498: FOR_IN
34499: IFFALSE 34589
// if not GetTag ( j ) then
34501: LD_VAR 0 3
34505: PPUSH
34506: CALL_OW 110
34510: NOT
34511: IFFALSE 34587
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
34513: LD_ADDR_EXP 104
34517: PUSH
34518: LD_EXP 104
34522: PPUSH
34523: LD_VAR 0 2
34527: PUSH
34528: LD_EXP 104
34532: PUSH
34533: LD_VAR 0 2
34537: ARRAY
34538: PUSH
34539: LD_INT 1
34541: PLUS
34542: PUSH
34543: EMPTY
34544: LIST
34545: LIST
34546: PPUSH
34547: LD_VAR 0 3
34551: PPUSH
34552: CALL 57967 0 3
34556: ST_TO_ADDR
// SetTag ( j , 107 ) ;
34557: LD_VAR 0 3
34561: PPUSH
34562: LD_INT 107
34564: PPUSH
34565: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
34569: LD_EXP 104
34573: PUSH
34574: LD_VAR 0 2
34578: ARRAY
34579: PUSH
34580: LD_INT 5
34582: GREATEREQUAL
34583: IFFALSE 34587
// break ;
34585: GO 34589
// end ;
34587: GO 34498
34589: POP
34590: POP
// end ; if mc_crates_collector [ i ] and target then
34591: LD_EXP 104
34595: PUSH
34596: LD_VAR 0 2
34600: ARRAY
34601: PUSH
34602: LD_VAR 0 6
34606: AND
34607: IFFALSE 34850
// begin if mc_crates_collector [ i ] < target [ 1 ] then
34609: LD_EXP 104
34613: PUSH
34614: LD_VAR 0 2
34618: ARRAY
34619: PUSH
34620: LD_VAR 0 6
34624: PUSH
34625: LD_INT 1
34627: ARRAY
34628: LESS
34629: IFFALSE 34649
// tmp := mc_crates_collector [ i ] else
34631: LD_ADDR_VAR 0 5
34635: PUSH
34636: LD_EXP 104
34640: PUSH
34641: LD_VAR 0 2
34645: ARRAY
34646: ST_TO_ADDR
34647: GO 34663
// tmp := target [ 1 ] ;
34649: LD_ADDR_VAR 0 5
34653: PUSH
34654: LD_VAR 0 6
34658: PUSH
34659: LD_INT 1
34661: ARRAY
34662: ST_TO_ADDR
// k := 0 ;
34663: LD_ADDR_VAR 0 4
34667: PUSH
34668: LD_INT 0
34670: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
34671: LD_ADDR_VAR 0 3
34675: PUSH
34676: LD_EXP 104
34680: PUSH
34681: LD_VAR 0 2
34685: ARRAY
34686: PUSH
34687: FOR_IN
34688: IFFALSE 34848
// begin k := k + 1 ;
34690: LD_ADDR_VAR 0 4
34694: PUSH
34695: LD_VAR 0 4
34699: PUSH
34700: LD_INT 1
34702: PLUS
34703: ST_TO_ADDR
// if k > tmp then
34704: LD_VAR 0 4
34708: PUSH
34709: LD_VAR 0 5
34713: GREATER
34714: IFFALSE 34718
// break ;
34716: GO 34848
// if not GetClass ( j ) in [ 2 , 16 ] then
34718: LD_VAR 0 3
34722: PPUSH
34723: CALL_OW 257
34727: PUSH
34728: LD_INT 2
34730: PUSH
34731: LD_INT 16
34733: PUSH
34734: EMPTY
34735: LIST
34736: LIST
34737: IN
34738: NOT
34739: IFFALSE 34792
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
34741: LD_ADDR_EXP 104
34745: PUSH
34746: LD_EXP 104
34750: PPUSH
34751: LD_VAR 0 2
34755: PPUSH
34756: LD_EXP 104
34760: PUSH
34761: LD_VAR 0 2
34765: ARRAY
34766: PUSH
34767: LD_VAR 0 3
34771: DIFF
34772: PPUSH
34773: CALL_OW 1
34777: ST_TO_ADDR
// SetTag ( j , 0 ) ;
34778: LD_VAR 0 3
34782: PPUSH
34783: LD_INT 0
34785: PPUSH
34786: CALL_OW 109
// continue ;
34790: GO 34687
// end ; if IsInUnit ( j ) then
34792: LD_VAR 0 3
34796: PPUSH
34797: CALL_OW 310
34801: IFFALSE 34812
// ComExitBuilding ( j ) ;
34803: LD_VAR 0 3
34807: PPUSH
34808: CALL_OW 122
// wait ( 3 ) ;
34812: LD_INT 3
34814: PPUSH
34815: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
34819: LD_VAR 0 3
34823: PPUSH
34824: LD_VAR 0 6
34828: PUSH
34829: LD_INT 2
34831: ARRAY
34832: PPUSH
34833: LD_VAR 0 6
34837: PUSH
34838: LD_INT 3
34840: ARRAY
34841: PPUSH
34842: CALL_OW 117
// end ;
34846: GO 34687
34848: POP
34849: POP
// end ; end else
34850: GO 35431
// begin for j in cargo do
34852: LD_ADDR_VAR 0 3
34856: PUSH
34857: LD_VAR 0 7
34861: PUSH
34862: FOR_IN
34863: IFFALSE 35429
// begin if GetTag ( j ) <> 0 then
34865: LD_VAR 0 3
34869: PPUSH
34870: CALL_OW 110
34874: PUSH
34875: LD_INT 0
34877: NONEQUAL
34878: IFFALSE 34882
// continue ;
34880: GO 34862
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
34882: LD_VAR 0 3
34886: PPUSH
34887: CALL_OW 256
34891: PUSH
34892: LD_INT 1000
34894: LESS
34895: PUSH
34896: LD_VAR 0 3
34900: PPUSH
34901: LD_EXP 111
34905: PUSH
34906: LD_VAR 0 2
34910: ARRAY
34911: PPUSH
34912: CALL_OW 308
34916: NOT
34917: AND
34918: IFFALSE 34940
// ComMoveToArea ( j , mc_parking [ i ] ) ;
34920: LD_VAR 0 3
34924: PPUSH
34925: LD_EXP 111
34929: PUSH
34930: LD_VAR 0 2
34934: ARRAY
34935: PPUSH
34936: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
34940: LD_VAR 0 3
34944: PPUSH
34945: CALL_OW 256
34949: PUSH
34950: LD_INT 1000
34952: LESS
34953: PUSH
34954: LD_VAR 0 3
34958: PPUSH
34959: LD_EXP 111
34963: PUSH
34964: LD_VAR 0 2
34968: ARRAY
34969: PPUSH
34970: CALL_OW 308
34974: AND
34975: IFFALSE 34979
// continue ;
34977: GO 34862
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
34979: LD_VAR 0 3
34983: PPUSH
34984: CALL_OW 262
34988: PUSH
34989: LD_INT 2
34991: EQUAL
34992: PUSH
34993: LD_VAR 0 3
34997: PPUSH
34998: CALL_OW 261
35002: PUSH
35003: LD_INT 15
35005: LESS
35006: AND
35007: IFFALSE 35011
// continue ;
35009: GO 34862
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
35011: LD_VAR 0 3
35015: PPUSH
35016: CALL_OW 262
35020: PUSH
35021: LD_INT 1
35023: EQUAL
35024: PUSH
35025: LD_VAR 0 3
35029: PPUSH
35030: CALL_OW 261
35034: PUSH
35035: LD_INT 10
35037: LESS
35038: AND
35039: IFFALSE 35368
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
35041: LD_ADDR_VAR 0 8
35045: PUSH
35046: LD_EXP 87
35050: PUSH
35051: LD_VAR 0 2
35055: ARRAY
35056: PPUSH
35057: LD_INT 2
35059: PUSH
35060: LD_INT 30
35062: PUSH
35063: LD_INT 0
35065: PUSH
35066: EMPTY
35067: LIST
35068: LIST
35069: PUSH
35070: LD_INT 30
35072: PUSH
35073: LD_INT 1
35075: PUSH
35076: EMPTY
35077: LIST
35078: LIST
35079: PUSH
35080: EMPTY
35081: LIST
35082: LIST
35083: LIST
35084: PPUSH
35085: CALL_OW 72
35089: ST_TO_ADDR
// if not depot then
35090: LD_VAR 0 8
35094: NOT
35095: IFFALSE 35099
// continue ;
35097: GO 34862
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
35099: LD_VAR 0 3
35103: PPUSH
35104: LD_VAR 0 8
35108: PPUSH
35109: LD_VAR 0 3
35113: PPUSH
35114: CALL_OW 74
35118: PPUSH
35119: CALL_OW 296
35123: PUSH
35124: LD_INT 6
35126: LESS
35127: IFFALSE 35143
// SetFuel ( j , 100 ) else
35129: LD_VAR 0 3
35133: PPUSH
35134: LD_INT 100
35136: PPUSH
35137: CALL_OW 240
35141: GO 35368
// if GetFuel ( j ) = 0 then
35143: LD_VAR 0 3
35147: PPUSH
35148: CALL_OW 261
35152: PUSH
35153: LD_INT 0
35155: EQUAL
35156: IFFALSE 35368
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
35158: LD_ADDR_EXP 106
35162: PUSH
35163: LD_EXP 106
35167: PPUSH
35168: LD_VAR 0 2
35172: PPUSH
35173: LD_EXP 106
35177: PUSH
35178: LD_VAR 0 2
35182: ARRAY
35183: PUSH
35184: LD_VAR 0 3
35188: DIFF
35189: PPUSH
35190: CALL_OW 1
35194: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
35195: LD_VAR 0 3
35199: PPUSH
35200: CALL_OW 263
35204: PUSH
35205: LD_INT 1
35207: EQUAL
35208: IFFALSE 35224
// ComExitVehicle ( IsInUnit ( j ) ) ;
35210: LD_VAR 0 3
35214: PPUSH
35215: CALL_OW 310
35219: PPUSH
35220: CALL_OW 121
// if GetControl ( j ) = control_remote then
35224: LD_VAR 0 3
35228: PPUSH
35229: CALL_OW 263
35233: PUSH
35234: LD_INT 2
35236: EQUAL
35237: IFFALSE 35248
// ComUnlink ( j ) ;
35239: LD_VAR 0 3
35243: PPUSH
35244: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
35248: LD_ADDR_VAR 0 9
35252: PUSH
35253: LD_VAR 0 2
35257: PPUSH
35258: LD_INT 3
35260: PPUSH
35261: CALL 44721 0 2
35265: ST_TO_ADDR
// if fac then
35266: LD_VAR 0 9
35270: IFFALSE 35366
// begin for k in fac do
35272: LD_ADDR_VAR 0 4
35276: PUSH
35277: LD_VAR 0 9
35281: PUSH
35282: FOR_IN
35283: IFFALSE 35364
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
35285: LD_ADDR_VAR 0 10
35289: PUSH
35290: LD_VAR 0 9
35294: PPUSH
35295: LD_VAR 0 3
35299: PPUSH
35300: CALL_OW 265
35304: PPUSH
35305: LD_VAR 0 3
35309: PPUSH
35310: CALL_OW 262
35314: PPUSH
35315: LD_VAR 0 3
35319: PPUSH
35320: CALL_OW 263
35324: PPUSH
35325: LD_VAR 0 3
35329: PPUSH
35330: CALL_OW 264
35334: PPUSH
35335: CALL 55499 0 5
35339: ST_TO_ADDR
// if components then
35340: LD_VAR 0 10
35344: IFFALSE 35362
// begin MC_InsertProduceList ( i , components ) ;
35346: LD_VAR 0 2
35350: PPUSH
35351: LD_VAR 0 10
35355: PPUSH
35356: CALL 44266 0 2
// break ;
35360: GO 35364
// end ; end ;
35362: GO 35282
35364: POP
35365: POP
// end ; continue ;
35366: GO 34862
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
35368: LD_VAR 0 3
35372: PPUSH
35373: LD_INT 1
35375: PPUSH
35376: CALL_OW 289
35380: PUSH
35381: LD_INT 100
35383: LESS
35384: PUSH
35385: LD_VAR 0 3
35389: PPUSH
35390: CALL_OW 314
35394: NOT
35395: AND
35396: IFFALSE 35425
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35398: LD_VAR 0 3
35402: PPUSH
35403: LD_VAR 0 6
35407: PUSH
35408: LD_INT 2
35410: ARRAY
35411: PPUSH
35412: LD_VAR 0 6
35416: PUSH
35417: LD_INT 3
35419: ARRAY
35420: PPUSH
35421: CALL_OW 117
// break ;
35425: GO 35429
// end ;
35427: GO 34862
35429: POP
35430: POP
// end ; end ;
35431: GO 33700
35433: POP
35434: POP
// end ;
35435: LD_VAR 0 1
35439: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
35440: LD_INT 0
35442: PPUSH
35443: PPUSH
35444: PPUSH
35445: PPUSH
// if not mc_bases then
35446: LD_EXP 87
35450: NOT
35451: IFFALSE 35455
// exit ;
35453: GO 35616
// for i = 1 to mc_bases do
35455: LD_ADDR_VAR 0 2
35459: PUSH
35460: DOUBLE
35461: LD_INT 1
35463: DEC
35464: ST_TO_ADDR
35465: LD_EXP 87
35469: PUSH
35470: FOR_TO
35471: IFFALSE 35614
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
35473: LD_ADDR_VAR 0 4
35477: PUSH
35478: LD_EXP 106
35482: PUSH
35483: LD_VAR 0 2
35487: ARRAY
35488: PUSH
35489: LD_EXP 109
35493: PUSH
35494: LD_VAR 0 2
35498: ARRAY
35499: UNION
35500: PPUSH
35501: LD_INT 33
35503: PUSH
35504: LD_INT 2
35506: PUSH
35507: EMPTY
35508: LIST
35509: LIST
35510: PPUSH
35511: CALL_OW 72
35515: ST_TO_ADDR
// if tmp then
35516: LD_VAR 0 4
35520: IFFALSE 35612
// for j in tmp do
35522: LD_ADDR_VAR 0 3
35526: PUSH
35527: LD_VAR 0 4
35531: PUSH
35532: FOR_IN
35533: IFFALSE 35610
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
35535: LD_VAR 0 3
35539: PPUSH
35540: CALL_OW 312
35544: NOT
35545: PUSH
35546: LD_VAR 0 3
35550: PPUSH
35551: CALL_OW 256
35555: PUSH
35556: LD_INT 250
35558: GREATEREQUAL
35559: AND
35560: IFFALSE 35573
// Connect ( j ) else
35562: LD_VAR 0 3
35566: PPUSH
35567: CALL 60900 0 1
35571: GO 35608
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
35573: LD_VAR 0 3
35577: PPUSH
35578: CALL_OW 256
35582: PUSH
35583: LD_INT 250
35585: LESS
35586: PUSH
35587: LD_VAR 0 3
35591: PPUSH
35592: CALL_OW 312
35596: AND
35597: IFFALSE 35608
// ComUnlink ( j ) ;
35599: LD_VAR 0 3
35603: PPUSH
35604: CALL_OW 136
35608: GO 35532
35610: POP
35611: POP
// end ;
35612: GO 35470
35614: POP
35615: POP
// end ;
35616: LD_VAR 0 1
35620: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
35621: LD_INT 0
35623: PPUSH
35624: PPUSH
35625: PPUSH
35626: PPUSH
35627: PPUSH
// if not mc_bases then
35628: LD_EXP 87
35632: NOT
35633: IFFALSE 35637
// exit ;
35635: GO 36082
// for i = 1 to mc_bases do
35637: LD_ADDR_VAR 0 2
35641: PUSH
35642: DOUBLE
35643: LD_INT 1
35645: DEC
35646: ST_TO_ADDR
35647: LD_EXP 87
35651: PUSH
35652: FOR_TO
35653: IFFALSE 36080
// begin if not mc_produce [ i ] then
35655: LD_EXP 108
35659: PUSH
35660: LD_VAR 0 2
35664: ARRAY
35665: NOT
35666: IFFALSE 35670
// continue ;
35668: GO 35652
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35670: LD_ADDR_VAR 0 5
35674: PUSH
35675: LD_EXP 87
35679: PUSH
35680: LD_VAR 0 2
35684: ARRAY
35685: PPUSH
35686: LD_INT 30
35688: PUSH
35689: LD_INT 3
35691: PUSH
35692: EMPTY
35693: LIST
35694: LIST
35695: PPUSH
35696: CALL_OW 72
35700: ST_TO_ADDR
// if not fac then
35701: LD_VAR 0 5
35705: NOT
35706: IFFALSE 35710
// continue ;
35708: GO 35652
// for j in fac do
35710: LD_ADDR_VAR 0 3
35714: PUSH
35715: LD_VAR 0 5
35719: PUSH
35720: FOR_IN
35721: IFFALSE 36076
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
35723: LD_VAR 0 3
35727: PPUSH
35728: CALL_OW 461
35732: PUSH
35733: LD_INT 2
35735: NONEQUAL
35736: PUSH
35737: LD_VAR 0 3
35741: PPUSH
35742: LD_INT 15
35744: PPUSH
35745: CALL 60560 0 2
35749: PUSH
35750: LD_INT 4
35752: ARRAY
35753: OR
35754: IFFALSE 35758
// continue ;
35756: GO 35720
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
35758: LD_VAR 0 3
35762: PPUSH
35763: LD_EXP 108
35767: PUSH
35768: LD_VAR 0 2
35772: ARRAY
35773: PUSH
35774: LD_INT 1
35776: ARRAY
35777: PUSH
35778: LD_INT 1
35780: ARRAY
35781: PPUSH
35782: LD_EXP 108
35786: PUSH
35787: LD_VAR 0 2
35791: ARRAY
35792: PUSH
35793: LD_INT 1
35795: ARRAY
35796: PUSH
35797: LD_INT 2
35799: ARRAY
35800: PPUSH
35801: LD_EXP 108
35805: PUSH
35806: LD_VAR 0 2
35810: ARRAY
35811: PUSH
35812: LD_INT 1
35814: ARRAY
35815: PUSH
35816: LD_INT 3
35818: ARRAY
35819: PPUSH
35820: LD_EXP 108
35824: PUSH
35825: LD_VAR 0 2
35829: ARRAY
35830: PUSH
35831: LD_INT 1
35833: ARRAY
35834: PUSH
35835: LD_INT 4
35837: ARRAY
35838: PPUSH
35839: CALL_OW 448
35843: PUSH
35844: LD_VAR 0 3
35848: PPUSH
35849: LD_EXP 108
35853: PUSH
35854: LD_VAR 0 2
35858: ARRAY
35859: PUSH
35860: LD_INT 1
35862: ARRAY
35863: PUSH
35864: LD_INT 1
35866: ARRAY
35867: PUSH
35868: LD_EXP 108
35872: PUSH
35873: LD_VAR 0 2
35877: ARRAY
35878: PUSH
35879: LD_INT 1
35881: ARRAY
35882: PUSH
35883: LD_INT 2
35885: ARRAY
35886: PUSH
35887: LD_EXP 108
35891: PUSH
35892: LD_VAR 0 2
35896: ARRAY
35897: PUSH
35898: LD_INT 1
35900: ARRAY
35901: PUSH
35902: LD_INT 3
35904: ARRAY
35905: PUSH
35906: LD_EXP 108
35910: PUSH
35911: LD_VAR 0 2
35915: ARRAY
35916: PUSH
35917: LD_INT 1
35919: ARRAY
35920: PUSH
35921: LD_INT 4
35923: ARRAY
35924: PUSH
35925: EMPTY
35926: LIST
35927: LIST
35928: LIST
35929: LIST
35930: PPUSH
35931: CALL 64231 0 2
35935: AND
35936: IFFALSE 36074
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
35938: LD_VAR 0 3
35942: PPUSH
35943: LD_EXP 108
35947: PUSH
35948: LD_VAR 0 2
35952: ARRAY
35953: PUSH
35954: LD_INT 1
35956: ARRAY
35957: PUSH
35958: LD_INT 1
35960: ARRAY
35961: PPUSH
35962: LD_EXP 108
35966: PUSH
35967: LD_VAR 0 2
35971: ARRAY
35972: PUSH
35973: LD_INT 1
35975: ARRAY
35976: PUSH
35977: LD_INT 2
35979: ARRAY
35980: PPUSH
35981: LD_EXP 108
35985: PUSH
35986: LD_VAR 0 2
35990: ARRAY
35991: PUSH
35992: LD_INT 1
35994: ARRAY
35995: PUSH
35996: LD_INT 3
35998: ARRAY
35999: PPUSH
36000: LD_EXP 108
36004: PUSH
36005: LD_VAR 0 2
36009: ARRAY
36010: PUSH
36011: LD_INT 1
36013: ARRAY
36014: PUSH
36015: LD_INT 4
36017: ARRAY
36018: PPUSH
36019: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
36023: LD_ADDR_VAR 0 4
36027: PUSH
36028: LD_EXP 108
36032: PUSH
36033: LD_VAR 0 2
36037: ARRAY
36038: PPUSH
36039: LD_INT 1
36041: PPUSH
36042: CALL_OW 3
36046: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
36047: LD_ADDR_EXP 108
36051: PUSH
36052: LD_EXP 108
36056: PPUSH
36057: LD_VAR 0 2
36061: PPUSH
36062: LD_VAR 0 4
36066: PPUSH
36067: CALL_OW 1
36071: ST_TO_ADDR
// break ;
36072: GO 36076
// end ; end ;
36074: GO 35720
36076: POP
36077: POP
// end ;
36078: GO 35652
36080: POP
36081: POP
// end ;
36082: LD_VAR 0 1
36086: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
36087: LD_INT 0
36089: PPUSH
36090: PPUSH
36091: PPUSH
// if not mc_bases then
36092: LD_EXP 87
36096: NOT
36097: IFFALSE 36101
// exit ;
36099: GO 36190
// for i = 1 to mc_bases do
36101: LD_ADDR_VAR 0 2
36105: PUSH
36106: DOUBLE
36107: LD_INT 1
36109: DEC
36110: ST_TO_ADDR
36111: LD_EXP 87
36115: PUSH
36116: FOR_TO
36117: IFFALSE 36188
// begin if mc_attack [ i ] then
36119: LD_EXP 107
36123: PUSH
36124: LD_VAR 0 2
36128: ARRAY
36129: IFFALSE 36186
// begin tmp := mc_attack [ i ] [ 1 ] ;
36131: LD_ADDR_VAR 0 3
36135: PUSH
36136: LD_EXP 107
36140: PUSH
36141: LD_VAR 0 2
36145: ARRAY
36146: PUSH
36147: LD_INT 1
36149: ARRAY
36150: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
36151: LD_ADDR_EXP 107
36155: PUSH
36156: LD_EXP 107
36160: PPUSH
36161: LD_VAR 0 2
36165: PPUSH
36166: EMPTY
36167: PPUSH
36168: CALL_OW 1
36172: ST_TO_ADDR
// Attack ( tmp ) ;
36173: LD_VAR 0 3
36177: PPUSH
36178: CALL 86421 0 1
// exit ;
36182: POP
36183: POP
36184: GO 36190
// end ; end ;
36186: GO 36116
36188: POP
36189: POP
// end ;
36190: LD_VAR 0 1
36194: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
36195: LD_INT 0
36197: PPUSH
36198: PPUSH
36199: PPUSH
36200: PPUSH
36201: PPUSH
36202: PPUSH
36203: PPUSH
// if not mc_bases then
36204: LD_EXP 87
36208: NOT
36209: IFFALSE 36213
// exit ;
36211: GO 36795
// for i = 1 to mc_bases do
36213: LD_ADDR_VAR 0 2
36217: PUSH
36218: DOUBLE
36219: LD_INT 1
36221: DEC
36222: ST_TO_ADDR
36223: LD_EXP 87
36227: PUSH
36228: FOR_TO
36229: IFFALSE 36793
// begin if not mc_bases [ i ] then
36231: LD_EXP 87
36235: PUSH
36236: LD_VAR 0 2
36240: ARRAY
36241: NOT
36242: IFFALSE 36246
// continue ;
36244: GO 36228
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
36246: LD_ADDR_VAR 0 7
36250: PUSH
36251: LD_EXP 87
36255: PUSH
36256: LD_VAR 0 2
36260: ARRAY
36261: PUSH
36262: LD_INT 1
36264: ARRAY
36265: PPUSH
36266: CALL 54803 0 1
36270: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
36271: LD_ADDR_EXP 110
36275: PUSH
36276: LD_EXP 110
36280: PPUSH
36281: LD_VAR 0 2
36285: PPUSH
36286: LD_EXP 87
36290: PUSH
36291: LD_VAR 0 2
36295: ARRAY
36296: PUSH
36297: LD_INT 1
36299: ARRAY
36300: PPUSH
36301: CALL_OW 255
36305: PPUSH
36306: LD_EXP 112
36310: PUSH
36311: LD_VAR 0 2
36315: ARRAY
36316: PPUSH
36317: CALL 52357 0 2
36321: PPUSH
36322: CALL_OW 1
36326: ST_TO_ADDR
// if not mc_scan [ i ] then
36327: LD_EXP 110
36331: PUSH
36332: LD_VAR 0 2
36336: ARRAY
36337: NOT
36338: IFFALSE 36493
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36340: LD_ADDR_VAR 0 4
36344: PUSH
36345: LD_EXP 87
36349: PUSH
36350: LD_VAR 0 2
36354: ARRAY
36355: PPUSH
36356: LD_INT 2
36358: PUSH
36359: LD_INT 25
36361: PUSH
36362: LD_INT 5
36364: PUSH
36365: EMPTY
36366: LIST
36367: LIST
36368: PUSH
36369: LD_INT 25
36371: PUSH
36372: LD_INT 8
36374: PUSH
36375: EMPTY
36376: LIST
36377: LIST
36378: PUSH
36379: LD_INT 25
36381: PUSH
36382: LD_INT 9
36384: PUSH
36385: EMPTY
36386: LIST
36387: LIST
36388: PUSH
36389: EMPTY
36390: LIST
36391: LIST
36392: LIST
36393: LIST
36394: PPUSH
36395: CALL_OW 72
36399: ST_TO_ADDR
// if not tmp then
36400: LD_VAR 0 4
36404: NOT
36405: IFFALSE 36409
// continue ;
36407: GO 36228
// for j in tmp do
36409: LD_ADDR_VAR 0 3
36413: PUSH
36414: LD_VAR 0 4
36418: PUSH
36419: FOR_IN
36420: IFFALSE 36491
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
36422: LD_VAR 0 3
36426: PPUSH
36427: CALL_OW 310
36431: PPUSH
36432: CALL_OW 266
36436: PUSH
36437: LD_INT 5
36439: EQUAL
36440: PUSH
36441: LD_VAR 0 3
36445: PPUSH
36446: CALL_OW 257
36450: PUSH
36451: LD_INT 1
36453: EQUAL
36454: AND
36455: PUSH
36456: LD_VAR 0 3
36460: PPUSH
36461: CALL_OW 459
36465: NOT
36466: AND
36467: PUSH
36468: LD_VAR 0 7
36472: AND
36473: IFFALSE 36489
// ComChangeProfession ( j , class ) ;
36475: LD_VAR 0 3
36479: PPUSH
36480: LD_VAR 0 7
36484: PPUSH
36485: CALL_OW 123
36489: GO 36419
36491: POP
36492: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
36493: LD_EXP 110
36497: PUSH
36498: LD_VAR 0 2
36502: ARRAY
36503: PUSH
36504: LD_EXP 109
36508: PUSH
36509: LD_VAR 0 2
36513: ARRAY
36514: NOT
36515: AND
36516: PUSH
36517: LD_EXP 87
36521: PUSH
36522: LD_VAR 0 2
36526: ARRAY
36527: PPUSH
36528: LD_INT 30
36530: PUSH
36531: LD_INT 32
36533: PUSH
36534: EMPTY
36535: LIST
36536: LIST
36537: PPUSH
36538: CALL_OW 72
36542: NOT
36543: AND
36544: PUSH
36545: LD_EXP 87
36549: PUSH
36550: LD_VAR 0 2
36554: ARRAY
36555: PPUSH
36556: LD_INT 2
36558: PUSH
36559: LD_INT 30
36561: PUSH
36562: LD_INT 4
36564: PUSH
36565: EMPTY
36566: LIST
36567: LIST
36568: PUSH
36569: LD_INT 30
36571: PUSH
36572: LD_INT 5
36574: PUSH
36575: EMPTY
36576: LIST
36577: LIST
36578: PUSH
36579: EMPTY
36580: LIST
36581: LIST
36582: LIST
36583: PPUSH
36584: CALL_OW 72
36588: NOT
36589: AND
36590: IFFALSE 36722
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36592: LD_ADDR_VAR 0 4
36596: PUSH
36597: LD_EXP 87
36601: PUSH
36602: LD_VAR 0 2
36606: ARRAY
36607: PPUSH
36608: LD_INT 2
36610: PUSH
36611: LD_INT 25
36613: PUSH
36614: LD_INT 1
36616: PUSH
36617: EMPTY
36618: LIST
36619: LIST
36620: PUSH
36621: LD_INT 25
36623: PUSH
36624: LD_INT 5
36626: PUSH
36627: EMPTY
36628: LIST
36629: LIST
36630: PUSH
36631: LD_INT 25
36633: PUSH
36634: LD_INT 8
36636: PUSH
36637: EMPTY
36638: LIST
36639: LIST
36640: PUSH
36641: LD_INT 25
36643: PUSH
36644: LD_INT 9
36646: PUSH
36647: EMPTY
36648: LIST
36649: LIST
36650: PUSH
36651: EMPTY
36652: LIST
36653: LIST
36654: LIST
36655: LIST
36656: LIST
36657: PPUSH
36658: CALL_OW 72
36662: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
36663: LD_ADDR_VAR 0 4
36667: PUSH
36668: LD_VAR 0 4
36672: PUSH
36673: LD_VAR 0 4
36677: PPUSH
36678: LD_INT 18
36680: PPUSH
36681: CALL 91237 0 2
36685: DIFF
36686: ST_TO_ADDR
// if tmp then
36687: LD_VAR 0 4
36691: IFFALSE 36722
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
36693: LD_VAR 0 2
36697: PPUSH
36698: LD_VAR 0 4
36702: PPUSH
36703: LD_EXP 112
36707: PUSH
36708: LD_VAR 0 2
36712: ARRAY
36713: PPUSH
36714: CALL 52392 0 3
// exit ;
36718: POP
36719: POP
36720: GO 36795
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
36722: LD_EXP 110
36726: PUSH
36727: LD_VAR 0 2
36731: ARRAY
36732: PUSH
36733: LD_EXP 109
36737: PUSH
36738: LD_VAR 0 2
36742: ARRAY
36743: AND
36744: IFFALSE 36791
// begin tmp := mc_defender [ i ] ;
36746: LD_ADDR_VAR 0 4
36750: PUSH
36751: LD_EXP 109
36755: PUSH
36756: LD_VAR 0 2
36760: ARRAY
36761: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
36762: LD_VAR 0 2
36766: PPUSH
36767: LD_VAR 0 4
36771: PPUSH
36772: LD_EXP 110
36776: PUSH
36777: LD_VAR 0 2
36781: ARRAY
36782: PPUSH
36783: CALL 52953 0 3
// exit ;
36787: POP
36788: POP
36789: GO 36795
// end ; end ;
36791: GO 36228
36793: POP
36794: POP
// end ;
36795: LD_VAR 0 1
36799: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
36800: LD_INT 0
36802: PPUSH
36803: PPUSH
36804: PPUSH
36805: PPUSH
36806: PPUSH
36807: PPUSH
36808: PPUSH
36809: PPUSH
36810: PPUSH
36811: PPUSH
36812: PPUSH
// if not mc_bases then
36813: LD_EXP 87
36817: NOT
36818: IFFALSE 36822
// exit ;
36820: GO 37909
// for i = 1 to mc_bases do
36822: LD_ADDR_VAR 0 2
36826: PUSH
36827: DOUBLE
36828: LD_INT 1
36830: DEC
36831: ST_TO_ADDR
36832: LD_EXP 87
36836: PUSH
36837: FOR_TO
36838: IFFALSE 37907
// begin tmp := mc_lab [ i ] ;
36840: LD_ADDR_VAR 0 6
36844: PUSH
36845: LD_EXP 120
36849: PUSH
36850: LD_VAR 0 2
36854: ARRAY
36855: ST_TO_ADDR
// if not tmp then
36856: LD_VAR 0 6
36860: NOT
36861: IFFALSE 36865
// continue ;
36863: GO 36837
// idle_lab := 0 ;
36865: LD_ADDR_VAR 0 11
36869: PUSH
36870: LD_INT 0
36872: ST_TO_ADDR
// for j in tmp do
36873: LD_ADDR_VAR 0 3
36877: PUSH
36878: LD_VAR 0 6
36882: PUSH
36883: FOR_IN
36884: IFFALSE 37903
// begin researching := false ;
36886: LD_ADDR_VAR 0 10
36890: PUSH
36891: LD_INT 0
36893: ST_TO_ADDR
// side := GetSide ( j ) ;
36894: LD_ADDR_VAR 0 4
36898: PUSH
36899: LD_VAR 0 3
36903: PPUSH
36904: CALL_OW 255
36908: ST_TO_ADDR
// if not mc_tech [ side ] then
36909: LD_EXP 114
36913: PUSH
36914: LD_VAR 0 4
36918: ARRAY
36919: NOT
36920: IFFALSE 36924
// continue ;
36922: GO 36883
// if BuildingStatus ( j ) = bs_idle then
36924: LD_VAR 0 3
36928: PPUSH
36929: CALL_OW 461
36933: PUSH
36934: LD_INT 2
36936: EQUAL
36937: IFFALSE 37125
// begin if idle_lab and UnitsInside ( j ) < 6 then
36939: LD_VAR 0 11
36943: PUSH
36944: LD_VAR 0 3
36948: PPUSH
36949: CALL_OW 313
36953: PUSH
36954: LD_INT 6
36956: LESS
36957: AND
36958: IFFALSE 37029
// begin tmp2 := UnitsInside ( idle_lab ) ;
36960: LD_ADDR_VAR 0 9
36964: PUSH
36965: LD_VAR 0 11
36969: PPUSH
36970: CALL_OW 313
36974: ST_TO_ADDR
// if tmp2 then
36975: LD_VAR 0 9
36979: IFFALSE 37021
// for x in tmp2 do
36981: LD_ADDR_VAR 0 7
36985: PUSH
36986: LD_VAR 0 9
36990: PUSH
36991: FOR_IN
36992: IFFALSE 37019
// begin ComExitBuilding ( x ) ;
36994: LD_VAR 0 7
36998: PPUSH
36999: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
37003: LD_VAR 0 7
37007: PPUSH
37008: LD_VAR 0 3
37012: PPUSH
37013: CALL_OW 180
// end ;
37017: GO 36991
37019: POP
37020: POP
// idle_lab := 0 ;
37021: LD_ADDR_VAR 0 11
37025: PUSH
37026: LD_INT 0
37028: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
37029: LD_ADDR_VAR 0 5
37033: PUSH
37034: LD_EXP 114
37038: PUSH
37039: LD_VAR 0 4
37043: ARRAY
37044: PUSH
37045: FOR_IN
37046: IFFALSE 37106
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
37048: LD_VAR 0 3
37052: PPUSH
37053: LD_VAR 0 5
37057: PPUSH
37058: CALL_OW 430
37062: PUSH
37063: LD_VAR 0 4
37067: PPUSH
37068: LD_VAR 0 5
37072: PPUSH
37073: CALL 51462 0 2
37077: AND
37078: IFFALSE 37104
// begin researching := true ;
37080: LD_ADDR_VAR 0 10
37084: PUSH
37085: LD_INT 1
37087: ST_TO_ADDR
// ComResearch ( j , t ) ;
37088: LD_VAR 0 3
37092: PPUSH
37093: LD_VAR 0 5
37097: PPUSH
37098: CALL_OW 124
// break ;
37102: GO 37106
// end ;
37104: GO 37045
37106: POP
37107: POP
// if not researching then
37108: LD_VAR 0 10
37112: NOT
37113: IFFALSE 37125
// idle_lab := j ;
37115: LD_ADDR_VAR 0 11
37119: PUSH
37120: LD_VAR 0 3
37124: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
37125: LD_VAR 0 3
37129: PPUSH
37130: CALL_OW 461
37134: PUSH
37135: LD_INT 10
37137: EQUAL
37138: IFFALSE 37726
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
37140: LD_EXP 116
37144: PUSH
37145: LD_VAR 0 2
37149: ARRAY
37150: NOT
37151: PUSH
37152: LD_EXP 117
37156: PUSH
37157: LD_VAR 0 2
37161: ARRAY
37162: NOT
37163: AND
37164: PUSH
37165: LD_EXP 114
37169: PUSH
37170: LD_VAR 0 4
37174: ARRAY
37175: PUSH
37176: LD_INT 1
37178: GREATER
37179: AND
37180: IFFALSE 37311
// begin ComCancel ( j ) ;
37182: LD_VAR 0 3
37186: PPUSH
37187: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
37191: LD_ADDR_EXP 114
37195: PUSH
37196: LD_EXP 114
37200: PPUSH
37201: LD_VAR 0 4
37205: PPUSH
37206: LD_EXP 114
37210: PUSH
37211: LD_VAR 0 4
37215: ARRAY
37216: PPUSH
37217: LD_EXP 114
37221: PUSH
37222: LD_VAR 0 4
37226: ARRAY
37227: PUSH
37228: LD_INT 1
37230: MINUS
37231: PPUSH
37232: LD_EXP 114
37236: PUSH
37237: LD_VAR 0 4
37241: ARRAY
37242: PPUSH
37243: LD_INT 0
37245: PPUSH
37246: CALL 57385 0 4
37250: PPUSH
37251: CALL_OW 1
37255: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
37256: LD_ADDR_EXP 114
37260: PUSH
37261: LD_EXP 114
37265: PPUSH
37266: LD_VAR 0 4
37270: PPUSH
37271: LD_EXP 114
37275: PUSH
37276: LD_VAR 0 4
37280: ARRAY
37281: PPUSH
37282: LD_EXP 114
37286: PUSH
37287: LD_VAR 0 4
37291: ARRAY
37292: PPUSH
37293: LD_INT 1
37295: PPUSH
37296: LD_INT 0
37298: PPUSH
37299: CALL 57385 0 4
37303: PPUSH
37304: CALL_OW 1
37308: ST_TO_ADDR
// continue ;
37309: GO 36883
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
37311: LD_EXP 116
37315: PUSH
37316: LD_VAR 0 2
37320: ARRAY
37321: PUSH
37322: LD_EXP 117
37326: PUSH
37327: LD_VAR 0 2
37331: ARRAY
37332: NOT
37333: AND
37334: IFFALSE 37461
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
37336: LD_ADDR_EXP 117
37340: PUSH
37341: LD_EXP 117
37345: PPUSH
37346: LD_VAR 0 2
37350: PUSH
37351: LD_EXP 117
37355: PUSH
37356: LD_VAR 0 2
37360: ARRAY
37361: PUSH
37362: LD_INT 1
37364: PLUS
37365: PUSH
37366: EMPTY
37367: LIST
37368: LIST
37369: PPUSH
37370: LD_EXP 116
37374: PUSH
37375: LD_VAR 0 2
37379: ARRAY
37380: PUSH
37381: LD_INT 1
37383: ARRAY
37384: PPUSH
37385: CALL 57967 0 3
37389: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
37390: LD_EXP 116
37394: PUSH
37395: LD_VAR 0 2
37399: ARRAY
37400: PUSH
37401: LD_INT 1
37403: ARRAY
37404: PPUSH
37405: LD_INT 112
37407: PPUSH
37408: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
37412: LD_ADDR_VAR 0 9
37416: PUSH
37417: LD_EXP 116
37421: PUSH
37422: LD_VAR 0 2
37426: ARRAY
37427: PPUSH
37428: LD_INT 1
37430: PPUSH
37431: CALL_OW 3
37435: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
37436: LD_ADDR_EXP 116
37440: PUSH
37441: LD_EXP 116
37445: PPUSH
37446: LD_VAR 0 2
37450: PPUSH
37451: LD_VAR 0 9
37455: PPUSH
37456: CALL_OW 1
37460: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
37461: LD_EXP 116
37465: PUSH
37466: LD_VAR 0 2
37470: ARRAY
37471: PUSH
37472: LD_EXP 117
37476: PUSH
37477: LD_VAR 0 2
37481: ARRAY
37482: AND
37483: PUSH
37484: LD_EXP 117
37488: PUSH
37489: LD_VAR 0 2
37493: ARRAY
37494: PUSH
37495: LD_INT 1
37497: ARRAY
37498: PPUSH
37499: CALL_OW 310
37503: NOT
37504: AND
37505: PUSH
37506: LD_VAR 0 3
37510: PPUSH
37511: CALL_OW 313
37515: PUSH
37516: LD_INT 6
37518: EQUAL
37519: AND
37520: IFFALSE 37576
// begin tmp2 := UnitsInside ( j ) ;
37522: LD_ADDR_VAR 0 9
37526: PUSH
37527: LD_VAR 0 3
37531: PPUSH
37532: CALL_OW 313
37536: ST_TO_ADDR
// if tmp2 = 6 then
37537: LD_VAR 0 9
37541: PUSH
37542: LD_INT 6
37544: EQUAL
37545: IFFALSE 37576
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
37547: LD_VAR 0 9
37551: PUSH
37552: LD_INT 1
37554: ARRAY
37555: PPUSH
37556: LD_INT 112
37558: PPUSH
37559: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
37563: LD_VAR 0 9
37567: PUSH
37568: LD_INT 1
37570: ARRAY
37571: PPUSH
37572: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
37576: LD_EXP 117
37580: PUSH
37581: LD_VAR 0 2
37585: ARRAY
37586: PUSH
37587: LD_EXP 117
37591: PUSH
37592: LD_VAR 0 2
37596: ARRAY
37597: PUSH
37598: LD_INT 1
37600: ARRAY
37601: PPUSH
37602: CALL_OW 314
37606: NOT
37607: AND
37608: PUSH
37609: LD_EXP 117
37613: PUSH
37614: LD_VAR 0 2
37618: ARRAY
37619: PUSH
37620: LD_INT 1
37622: ARRAY
37623: PPUSH
37624: CALL_OW 310
37628: NOT
37629: AND
37630: IFFALSE 37656
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
37632: LD_EXP 117
37636: PUSH
37637: LD_VAR 0 2
37641: ARRAY
37642: PUSH
37643: LD_INT 1
37645: ARRAY
37646: PPUSH
37647: LD_VAR 0 3
37651: PPUSH
37652: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
37656: LD_EXP 117
37660: PUSH
37661: LD_VAR 0 2
37665: ARRAY
37666: PUSH
37667: LD_INT 1
37669: ARRAY
37670: PPUSH
37671: CALL_OW 310
37675: PUSH
37676: LD_EXP 117
37680: PUSH
37681: LD_VAR 0 2
37685: ARRAY
37686: PUSH
37687: LD_INT 1
37689: ARRAY
37690: PPUSH
37691: CALL_OW 310
37695: PPUSH
37696: CALL_OW 461
37700: PUSH
37701: LD_INT 3
37703: NONEQUAL
37704: AND
37705: IFFALSE 37726
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
37707: LD_EXP 117
37711: PUSH
37712: LD_VAR 0 2
37716: ARRAY
37717: PUSH
37718: LD_INT 1
37720: ARRAY
37721: PPUSH
37722: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
37726: LD_VAR 0 3
37730: PPUSH
37731: CALL_OW 461
37735: PUSH
37736: LD_INT 6
37738: EQUAL
37739: PUSH
37740: LD_VAR 0 6
37744: PUSH
37745: LD_INT 1
37747: GREATER
37748: AND
37749: IFFALSE 37901
// begin sci := [ ] ;
37751: LD_ADDR_VAR 0 8
37755: PUSH
37756: EMPTY
37757: ST_TO_ADDR
// for x in ( tmp diff j ) do
37758: LD_ADDR_VAR 0 7
37762: PUSH
37763: LD_VAR 0 6
37767: PUSH
37768: LD_VAR 0 3
37772: DIFF
37773: PUSH
37774: FOR_IN
37775: IFFALSE 37827
// begin if sci = 6 then
37777: LD_VAR 0 8
37781: PUSH
37782: LD_INT 6
37784: EQUAL
37785: IFFALSE 37789
// break ;
37787: GO 37827
// if BuildingStatus ( x ) = bs_idle then
37789: LD_VAR 0 7
37793: PPUSH
37794: CALL_OW 461
37798: PUSH
37799: LD_INT 2
37801: EQUAL
37802: IFFALSE 37825
// sci := sci ^ UnitsInside ( x ) ;
37804: LD_ADDR_VAR 0 8
37808: PUSH
37809: LD_VAR 0 8
37813: PUSH
37814: LD_VAR 0 7
37818: PPUSH
37819: CALL_OW 313
37823: ADD
37824: ST_TO_ADDR
// end ;
37825: GO 37774
37827: POP
37828: POP
// if not sci then
37829: LD_VAR 0 8
37833: NOT
37834: IFFALSE 37838
// continue ;
37836: GO 36883
// for x in sci do
37838: LD_ADDR_VAR 0 7
37842: PUSH
37843: LD_VAR 0 8
37847: PUSH
37848: FOR_IN
37849: IFFALSE 37899
// if IsInUnit ( x ) and not HasTask ( x ) then
37851: LD_VAR 0 7
37855: PPUSH
37856: CALL_OW 310
37860: PUSH
37861: LD_VAR 0 7
37865: PPUSH
37866: CALL_OW 314
37870: NOT
37871: AND
37872: IFFALSE 37897
// begin ComExitBuilding ( x ) ;
37874: LD_VAR 0 7
37878: PPUSH
37879: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
37883: LD_VAR 0 7
37887: PPUSH
37888: LD_VAR 0 3
37892: PPUSH
37893: CALL_OW 180
// end ;
37897: GO 37848
37899: POP
37900: POP
// end ; end ;
37901: GO 36883
37903: POP
37904: POP
// end ;
37905: GO 36837
37907: POP
37908: POP
// end ;
37909: LD_VAR 0 1
37913: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
37914: LD_INT 0
37916: PPUSH
37917: PPUSH
// if not mc_bases then
37918: LD_EXP 87
37922: NOT
37923: IFFALSE 37927
// exit ;
37925: GO 38008
// for i = 1 to mc_bases do
37927: LD_ADDR_VAR 0 2
37931: PUSH
37932: DOUBLE
37933: LD_INT 1
37935: DEC
37936: ST_TO_ADDR
37937: LD_EXP 87
37941: PUSH
37942: FOR_TO
37943: IFFALSE 38006
// if mc_mines [ i ] and mc_miners [ i ] then
37945: LD_EXP 100
37949: PUSH
37950: LD_VAR 0 2
37954: ARRAY
37955: PUSH
37956: LD_EXP 101
37960: PUSH
37961: LD_VAR 0 2
37965: ARRAY
37966: AND
37967: IFFALSE 38004
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
37969: LD_EXP 101
37973: PUSH
37974: LD_VAR 0 2
37978: ARRAY
37979: PUSH
37980: LD_INT 1
37982: ARRAY
37983: PPUSH
37984: CALL_OW 255
37988: PPUSH
37989: LD_EXP 100
37993: PUSH
37994: LD_VAR 0 2
37998: ARRAY
37999: PPUSH
38000: CALL 54956 0 2
38004: GO 37942
38006: POP
38007: POP
// end ;
38008: LD_VAR 0 1
38012: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
38013: LD_INT 0
38015: PPUSH
38016: PPUSH
38017: PPUSH
38018: PPUSH
38019: PPUSH
38020: PPUSH
38021: PPUSH
38022: PPUSH
// if not mc_bases or not mc_parking then
38023: LD_EXP 87
38027: NOT
38028: PUSH
38029: LD_EXP 111
38033: NOT
38034: OR
38035: IFFALSE 38039
// exit ;
38037: GO 38738
// for i = 1 to mc_bases do
38039: LD_ADDR_VAR 0 2
38043: PUSH
38044: DOUBLE
38045: LD_INT 1
38047: DEC
38048: ST_TO_ADDR
38049: LD_EXP 87
38053: PUSH
38054: FOR_TO
38055: IFFALSE 38736
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
38057: LD_EXP 87
38061: PUSH
38062: LD_VAR 0 2
38066: ARRAY
38067: NOT
38068: PUSH
38069: LD_EXP 111
38073: PUSH
38074: LD_VAR 0 2
38078: ARRAY
38079: NOT
38080: OR
38081: IFFALSE 38085
// continue ;
38083: GO 38054
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
38085: LD_ADDR_VAR 0 5
38089: PUSH
38090: LD_EXP 87
38094: PUSH
38095: LD_VAR 0 2
38099: ARRAY
38100: PUSH
38101: LD_INT 1
38103: ARRAY
38104: PPUSH
38105: CALL_OW 255
38109: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38110: LD_ADDR_VAR 0 6
38114: PUSH
38115: LD_EXP 87
38119: PUSH
38120: LD_VAR 0 2
38124: ARRAY
38125: PPUSH
38126: LD_INT 30
38128: PUSH
38129: LD_INT 3
38131: PUSH
38132: EMPTY
38133: LIST
38134: LIST
38135: PPUSH
38136: CALL_OW 72
38140: ST_TO_ADDR
// if not fac then
38141: LD_VAR 0 6
38145: NOT
38146: IFFALSE 38197
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38148: LD_ADDR_VAR 0 6
38152: PUSH
38153: LD_EXP 87
38157: PUSH
38158: LD_VAR 0 2
38162: ARRAY
38163: PPUSH
38164: LD_INT 2
38166: PUSH
38167: LD_INT 30
38169: PUSH
38170: LD_INT 0
38172: PUSH
38173: EMPTY
38174: LIST
38175: LIST
38176: PUSH
38177: LD_INT 30
38179: PUSH
38180: LD_INT 1
38182: PUSH
38183: EMPTY
38184: LIST
38185: LIST
38186: PUSH
38187: EMPTY
38188: LIST
38189: LIST
38190: LIST
38191: PPUSH
38192: CALL_OW 72
38196: ST_TO_ADDR
// if not fac then
38197: LD_VAR 0 6
38201: NOT
38202: IFFALSE 38206
// continue ;
38204: GO 38054
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
38206: LD_ADDR_VAR 0 7
38210: PUSH
38211: LD_EXP 111
38215: PUSH
38216: LD_VAR 0 2
38220: ARRAY
38221: PPUSH
38222: LD_INT 22
38224: PUSH
38225: LD_VAR 0 5
38229: PUSH
38230: EMPTY
38231: LIST
38232: LIST
38233: PUSH
38234: LD_INT 21
38236: PUSH
38237: LD_INT 2
38239: PUSH
38240: EMPTY
38241: LIST
38242: LIST
38243: PUSH
38244: LD_INT 3
38246: PUSH
38247: LD_INT 24
38249: PUSH
38250: LD_INT 1000
38252: PUSH
38253: EMPTY
38254: LIST
38255: LIST
38256: PUSH
38257: EMPTY
38258: LIST
38259: LIST
38260: PUSH
38261: EMPTY
38262: LIST
38263: LIST
38264: LIST
38265: PPUSH
38266: CALL_OW 70
38270: ST_TO_ADDR
// for j in fac do
38271: LD_ADDR_VAR 0 3
38275: PUSH
38276: LD_VAR 0 6
38280: PUSH
38281: FOR_IN
38282: IFFALSE 38363
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
38284: LD_ADDR_VAR 0 7
38288: PUSH
38289: LD_VAR 0 7
38293: PUSH
38294: LD_INT 22
38296: PUSH
38297: LD_VAR 0 5
38301: PUSH
38302: EMPTY
38303: LIST
38304: LIST
38305: PUSH
38306: LD_INT 91
38308: PUSH
38309: LD_VAR 0 3
38313: PUSH
38314: LD_INT 15
38316: PUSH
38317: EMPTY
38318: LIST
38319: LIST
38320: LIST
38321: PUSH
38322: LD_INT 21
38324: PUSH
38325: LD_INT 2
38327: PUSH
38328: EMPTY
38329: LIST
38330: LIST
38331: PUSH
38332: LD_INT 3
38334: PUSH
38335: LD_INT 24
38337: PUSH
38338: LD_INT 1000
38340: PUSH
38341: EMPTY
38342: LIST
38343: LIST
38344: PUSH
38345: EMPTY
38346: LIST
38347: LIST
38348: PUSH
38349: EMPTY
38350: LIST
38351: LIST
38352: LIST
38353: LIST
38354: PPUSH
38355: CALL_OW 69
38359: UNION
38360: ST_TO_ADDR
38361: GO 38281
38363: POP
38364: POP
// if not vehs then
38365: LD_VAR 0 7
38369: NOT
38370: IFFALSE 38396
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
38372: LD_ADDR_EXP 99
38376: PUSH
38377: LD_EXP 99
38381: PPUSH
38382: LD_VAR 0 2
38386: PPUSH
38387: EMPTY
38388: PPUSH
38389: CALL_OW 1
38393: ST_TO_ADDR
// continue ;
38394: GO 38054
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38396: LD_ADDR_VAR 0 8
38400: PUSH
38401: LD_EXP 87
38405: PUSH
38406: LD_VAR 0 2
38410: ARRAY
38411: PPUSH
38412: LD_INT 30
38414: PUSH
38415: LD_INT 3
38417: PUSH
38418: EMPTY
38419: LIST
38420: LIST
38421: PPUSH
38422: CALL_OW 72
38426: ST_TO_ADDR
// if tmp then
38427: LD_VAR 0 8
38431: IFFALSE 38534
// begin for j in tmp do
38433: LD_ADDR_VAR 0 3
38437: PUSH
38438: LD_VAR 0 8
38442: PUSH
38443: FOR_IN
38444: IFFALSE 38532
// for k in UnitsInside ( j ) do
38446: LD_ADDR_VAR 0 4
38450: PUSH
38451: LD_VAR 0 3
38455: PPUSH
38456: CALL_OW 313
38460: PUSH
38461: FOR_IN
38462: IFFALSE 38528
// if k then
38464: LD_VAR 0 4
38468: IFFALSE 38526
// if not k in mc_repair_vehicle [ i ] then
38470: LD_VAR 0 4
38474: PUSH
38475: LD_EXP 99
38479: PUSH
38480: LD_VAR 0 2
38484: ARRAY
38485: IN
38486: NOT
38487: IFFALSE 38526
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
38489: LD_ADDR_EXP 99
38493: PUSH
38494: LD_EXP 99
38498: PPUSH
38499: LD_VAR 0 2
38503: PPUSH
38504: LD_EXP 99
38508: PUSH
38509: LD_VAR 0 2
38513: ARRAY
38514: PUSH
38515: LD_VAR 0 4
38519: UNION
38520: PPUSH
38521: CALL_OW 1
38525: ST_TO_ADDR
38526: GO 38461
38528: POP
38529: POP
38530: GO 38443
38532: POP
38533: POP
// end ; if not mc_repair_vehicle [ i ] then
38534: LD_EXP 99
38538: PUSH
38539: LD_VAR 0 2
38543: ARRAY
38544: NOT
38545: IFFALSE 38549
// continue ;
38547: GO 38054
// for j in mc_repair_vehicle [ i ] do
38549: LD_ADDR_VAR 0 3
38553: PUSH
38554: LD_EXP 99
38558: PUSH
38559: LD_VAR 0 2
38563: ARRAY
38564: PUSH
38565: FOR_IN
38566: IFFALSE 38732
// begin if GetClass ( j ) <> 3 then
38568: LD_VAR 0 3
38572: PPUSH
38573: CALL_OW 257
38577: PUSH
38578: LD_INT 3
38580: NONEQUAL
38581: IFFALSE 38622
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
38583: LD_ADDR_EXP 99
38587: PUSH
38588: LD_EXP 99
38592: PPUSH
38593: LD_VAR 0 2
38597: PPUSH
38598: LD_EXP 99
38602: PUSH
38603: LD_VAR 0 2
38607: ARRAY
38608: PUSH
38609: LD_VAR 0 3
38613: DIFF
38614: PPUSH
38615: CALL_OW 1
38619: ST_TO_ADDR
// continue ;
38620: GO 38565
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38622: LD_VAR 0 3
38626: PPUSH
38627: CALL_OW 311
38631: NOT
38632: PUSH
38633: LD_VAR 0 3
38637: PUSH
38638: LD_EXP 90
38642: PUSH
38643: LD_VAR 0 2
38647: ARRAY
38648: PUSH
38649: LD_INT 1
38651: ARRAY
38652: IN
38653: NOT
38654: AND
38655: PUSH
38656: LD_VAR 0 3
38660: PUSH
38661: LD_EXP 90
38665: PUSH
38666: LD_VAR 0 2
38670: ARRAY
38671: PUSH
38672: LD_INT 2
38674: ARRAY
38675: IN
38676: NOT
38677: AND
38678: IFFALSE 38730
// begin if IsInUnit ( j ) then
38680: LD_VAR 0 3
38684: PPUSH
38685: CALL_OW 310
38689: IFFALSE 38700
// ComExitBuilding ( j ) ;
38691: LD_VAR 0 3
38695: PPUSH
38696: CALL_OW 122
// if not HasTask ( j ) then
38700: LD_VAR 0 3
38704: PPUSH
38705: CALL_OW 314
38709: NOT
38710: IFFALSE 38730
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
38712: LD_VAR 0 3
38716: PPUSH
38717: LD_VAR 0 7
38721: PUSH
38722: LD_INT 1
38724: ARRAY
38725: PPUSH
38726: CALL_OW 189
// end ; end ;
38730: GO 38565
38732: POP
38733: POP
// end ;
38734: GO 38054
38736: POP
38737: POP
// end ;
38738: LD_VAR 0 1
38742: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
38743: LD_INT 0
38745: PPUSH
38746: PPUSH
38747: PPUSH
38748: PPUSH
38749: PPUSH
38750: PPUSH
38751: PPUSH
38752: PPUSH
38753: PPUSH
38754: PPUSH
38755: PPUSH
// if not mc_bases then
38756: LD_EXP 87
38760: NOT
38761: IFFALSE 38765
// exit ;
38763: GO 39567
// for i = 1 to mc_bases do
38765: LD_ADDR_VAR 0 2
38769: PUSH
38770: DOUBLE
38771: LD_INT 1
38773: DEC
38774: ST_TO_ADDR
38775: LD_EXP 87
38779: PUSH
38780: FOR_TO
38781: IFFALSE 39565
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
38783: LD_EXP 115
38787: PUSH
38788: LD_VAR 0 2
38792: ARRAY
38793: NOT
38794: PUSH
38795: LD_EXP 90
38799: PUSH
38800: LD_VAR 0 2
38804: ARRAY
38805: PUSH
38806: LD_INT 1
38808: ARRAY
38809: OR
38810: PUSH
38811: LD_EXP 90
38815: PUSH
38816: LD_VAR 0 2
38820: ARRAY
38821: PUSH
38822: LD_INT 2
38824: ARRAY
38825: OR
38826: PUSH
38827: LD_EXP 113
38831: PUSH
38832: LD_VAR 0 2
38836: ARRAY
38837: PPUSH
38838: LD_INT 1
38840: PPUSH
38841: CALL_OW 325
38845: NOT
38846: OR
38847: PUSH
38848: LD_EXP 110
38852: PUSH
38853: LD_VAR 0 2
38857: ARRAY
38858: OR
38859: IFFALSE 38863
// continue ;
38861: GO 38780
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
38863: LD_ADDR_VAR 0 8
38867: PUSH
38868: LD_EXP 87
38872: PUSH
38873: LD_VAR 0 2
38877: ARRAY
38878: PPUSH
38879: LD_INT 25
38881: PUSH
38882: LD_INT 4
38884: PUSH
38885: EMPTY
38886: LIST
38887: LIST
38888: PUSH
38889: LD_INT 50
38891: PUSH
38892: EMPTY
38893: LIST
38894: PUSH
38895: LD_INT 3
38897: PUSH
38898: LD_INT 60
38900: PUSH
38901: EMPTY
38902: LIST
38903: PUSH
38904: EMPTY
38905: LIST
38906: LIST
38907: PUSH
38908: EMPTY
38909: LIST
38910: LIST
38911: LIST
38912: PPUSH
38913: CALL_OW 72
38917: PUSH
38918: LD_EXP 91
38922: PUSH
38923: LD_VAR 0 2
38927: ARRAY
38928: DIFF
38929: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38930: LD_ADDR_VAR 0 9
38934: PUSH
38935: LD_EXP 87
38939: PUSH
38940: LD_VAR 0 2
38944: ARRAY
38945: PPUSH
38946: LD_INT 2
38948: PUSH
38949: LD_INT 30
38951: PUSH
38952: LD_INT 0
38954: PUSH
38955: EMPTY
38956: LIST
38957: LIST
38958: PUSH
38959: LD_INT 30
38961: PUSH
38962: LD_INT 1
38964: PUSH
38965: EMPTY
38966: LIST
38967: LIST
38968: PUSH
38969: EMPTY
38970: LIST
38971: LIST
38972: LIST
38973: PPUSH
38974: CALL_OW 72
38978: ST_TO_ADDR
// if not tmp or not dep then
38979: LD_VAR 0 8
38983: NOT
38984: PUSH
38985: LD_VAR 0 9
38989: NOT
38990: OR
38991: IFFALSE 38995
// continue ;
38993: GO 38780
// side := GetSide ( tmp [ 1 ] ) ;
38995: LD_ADDR_VAR 0 11
38999: PUSH
39000: LD_VAR 0 8
39004: PUSH
39005: LD_INT 1
39007: ARRAY
39008: PPUSH
39009: CALL_OW 255
39013: ST_TO_ADDR
// dep := dep [ 1 ] ;
39014: LD_ADDR_VAR 0 9
39018: PUSH
39019: LD_VAR 0 9
39023: PUSH
39024: LD_INT 1
39026: ARRAY
39027: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
39028: LD_ADDR_VAR 0 7
39032: PUSH
39033: LD_EXP 115
39037: PUSH
39038: LD_VAR 0 2
39042: ARRAY
39043: PPUSH
39044: LD_INT 22
39046: PUSH
39047: LD_INT 0
39049: PUSH
39050: EMPTY
39051: LIST
39052: LIST
39053: PUSH
39054: LD_INT 25
39056: PUSH
39057: LD_INT 12
39059: PUSH
39060: EMPTY
39061: LIST
39062: LIST
39063: PUSH
39064: EMPTY
39065: LIST
39066: LIST
39067: PPUSH
39068: CALL_OW 70
39072: PUSH
39073: LD_INT 22
39075: PUSH
39076: LD_INT 0
39078: PUSH
39079: EMPTY
39080: LIST
39081: LIST
39082: PUSH
39083: LD_INT 25
39085: PUSH
39086: LD_INT 12
39088: PUSH
39089: EMPTY
39090: LIST
39091: LIST
39092: PUSH
39093: LD_INT 91
39095: PUSH
39096: LD_VAR 0 9
39100: PUSH
39101: LD_INT 20
39103: PUSH
39104: EMPTY
39105: LIST
39106: LIST
39107: LIST
39108: PUSH
39109: EMPTY
39110: LIST
39111: LIST
39112: LIST
39113: PPUSH
39114: CALL_OW 69
39118: UNION
39119: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
39120: LD_ADDR_VAR 0 10
39124: PUSH
39125: LD_EXP 115
39129: PUSH
39130: LD_VAR 0 2
39134: ARRAY
39135: PPUSH
39136: LD_INT 81
39138: PUSH
39139: LD_VAR 0 11
39143: PUSH
39144: EMPTY
39145: LIST
39146: LIST
39147: PPUSH
39148: CALL_OW 70
39152: ST_TO_ADDR
// if not apes or danger_at_area then
39153: LD_VAR 0 7
39157: NOT
39158: PUSH
39159: LD_VAR 0 10
39163: OR
39164: IFFALSE 39214
// begin if mc_taming [ i ] then
39166: LD_EXP 118
39170: PUSH
39171: LD_VAR 0 2
39175: ARRAY
39176: IFFALSE 39212
// begin MC_Reset ( i , 121 ) ;
39178: LD_VAR 0 2
39182: PPUSH
39183: LD_INT 121
39185: PPUSH
39186: CALL 24649 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
39190: LD_ADDR_EXP 118
39194: PUSH
39195: LD_EXP 118
39199: PPUSH
39200: LD_VAR 0 2
39204: PPUSH
39205: EMPTY
39206: PPUSH
39207: CALL_OW 1
39211: ST_TO_ADDR
// end ; continue ;
39212: GO 38780
// end ; for j in tmp do
39214: LD_ADDR_VAR 0 3
39218: PUSH
39219: LD_VAR 0 8
39223: PUSH
39224: FOR_IN
39225: IFFALSE 39561
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
39227: LD_VAR 0 3
39231: PUSH
39232: LD_EXP 118
39236: PUSH
39237: LD_VAR 0 2
39241: ARRAY
39242: IN
39243: NOT
39244: PUSH
39245: LD_EXP 118
39249: PUSH
39250: LD_VAR 0 2
39254: ARRAY
39255: PUSH
39256: LD_INT 3
39258: LESS
39259: AND
39260: IFFALSE 39318
// begin SetTag ( j , 121 ) ;
39262: LD_VAR 0 3
39266: PPUSH
39267: LD_INT 121
39269: PPUSH
39270: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
39274: LD_ADDR_EXP 118
39278: PUSH
39279: LD_EXP 118
39283: PPUSH
39284: LD_VAR 0 2
39288: PUSH
39289: LD_EXP 118
39293: PUSH
39294: LD_VAR 0 2
39298: ARRAY
39299: PUSH
39300: LD_INT 1
39302: PLUS
39303: PUSH
39304: EMPTY
39305: LIST
39306: LIST
39307: PPUSH
39308: LD_VAR 0 3
39312: PPUSH
39313: CALL 57967 0 3
39317: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
39318: LD_VAR 0 3
39322: PUSH
39323: LD_EXP 118
39327: PUSH
39328: LD_VAR 0 2
39332: ARRAY
39333: IN
39334: IFFALSE 39559
// begin if GetClass ( j ) <> 4 then
39336: LD_VAR 0 3
39340: PPUSH
39341: CALL_OW 257
39345: PUSH
39346: LD_INT 4
39348: NONEQUAL
39349: IFFALSE 39402
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
39351: LD_ADDR_EXP 118
39355: PUSH
39356: LD_EXP 118
39360: PPUSH
39361: LD_VAR 0 2
39365: PPUSH
39366: LD_EXP 118
39370: PUSH
39371: LD_VAR 0 2
39375: ARRAY
39376: PUSH
39377: LD_VAR 0 3
39381: DIFF
39382: PPUSH
39383: CALL_OW 1
39387: ST_TO_ADDR
// SetTag ( j , 0 ) ;
39388: LD_VAR 0 3
39392: PPUSH
39393: LD_INT 0
39395: PPUSH
39396: CALL_OW 109
// continue ;
39400: GO 39224
// end ; if IsInUnit ( j ) then
39402: LD_VAR 0 3
39406: PPUSH
39407: CALL_OW 310
39411: IFFALSE 39422
// ComExitBuilding ( j ) ;
39413: LD_VAR 0 3
39417: PPUSH
39418: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
39422: LD_ADDR_VAR 0 6
39426: PUSH
39427: LD_VAR 0 7
39431: PPUSH
39432: LD_VAR 0 3
39436: PPUSH
39437: CALL_OW 74
39441: ST_TO_ADDR
// if not ape then
39442: LD_VAR 0 6
39446: NOT
39447: IFFALSE 39451
// break ;
39449: GO 39561
// x := GetX ( ape ) ;
39451: LD_ADDR_VAR 0 4
39455: PUSH
39456: LD_VAR 0 6
39460: PPUSH
39461: CALL_OW 250
39465: ST_TO_ADDR
// y := GetY ( ape ) ;
39466: LD_ADDR_VAR 0 5
39470: PUSH
39471: LD_VAR 0 6
39475: PPUSH
39476: CALL_OW 251
39480: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
39481: LD_VAR 0 4
39485: PPUSH
39486: LD_VAR 0 5
39490: PPUSH
39491: CALL_OW 488
39495: NOT
39496: PUSH
39497: LD_VAR 0 11
39501: PPUSH
39502: LD_VAR 0 4
39506: PPUSH
39507: LD_VAR 0 5
39511: PPUSH
39512: LD_INT 20
39514: PPUSH
39515: CALL 58863 0 4
39519: PUSH
39520: LD_INT 4
39522: ARRAY
39523: OR
39524: IFFALSE 39528
// break ;
39526: GO 39561
// if not HasTask ( j ) then
39528: LD_VAR 0 3
39532: PPUSH
39533: CALL_OW 314
39537: NOT
39538: IFFALSE 39559
// ComTameXY ( j , x , y ) ;
39540: LD_VAR 0 3
39544: PPUSH
39545: LD_VAR 0 4
39549: PPUSH
39550: LD_VAR 0 5
39554: PPUSH
39555: CALL_OW 131
// end ; end ;
39559: GO 39224
39561: POP
39562: POP
// end ;
39563: GO 38780
39565: POP
39566: POP
// end ;
39567: LD_VAR 0 1
39571: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
39572: LD_INT 0
39574: PPUSH
39575: PPUSH
39576: PPUSH
39577: PPUSH
39578: PPUSH
39579: PPUSH
39580: PPUSH
39581: PPUSH
// if not mc_bases then
39582: LD_EXP 87
39586: NOT
39587: IFFALSE 39591
// exit ;
39589: GO 40217
// for i = 1 to mc_bases do
39591: LD_ADDR_VAR 0 2
39595: PUSH
39596: DOUBLE
39597: LD_INT 1
39599: DEC
39600: ST_TO_ADDR
39601: LD_EXP 87
39605: PUSH
39606: FOR_TO
39607: IFFALSE 40215
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
39609: LD_EXP 116
39613: PUSH
39614: LD_VAR 0 2
39618: ARRAY
39619: NOT
39620: PUSH
39621: LD_EXP 116
39625: PUSH
39626: LD_VAR 0 2
39630: ARRAY
39631: PPUSH
39632: LD_INT 25
39634: PUSH
39635: LD_INT 12
39637: PUSH
39638: EMPTY
39639: LIST
39640: LIST
39641: PPUSH
39642: CALL_OW 72
39646: NOT
39647: OR
39648: IFFALSE 39652
// continue ;
39650: GO 39606
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
39652: LD_ADDR_VAR 0 5
39656: PUSH
39657: LD_EXP 116
39661: PUSH
39662: LD_VAR 0 2
39666: ARRAY
39667: PUSH
39668: LD_INT 1
39670: ARRAY
39671: PPUSH
39672: CALL_OW 255
39676: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
39677: LD_VAR 0 5
39681: PPUSH
39682: LD_INT 2
39684: PPUSH
39685: CALL_OW 325
39689: IFFALSE 39942
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
39691: LD_ADDR_VAR 0 4
39695: PUSH
39696: LD_EXP 116
39700: PUSH
39701: LD_VAR 0 2
39705: ARRAY
39706: PPUSH
39707: LD_INT 25
39709: PUSH
39710: LD_INT 16
39712: PUSH
39713: EMPTY
39714: LIST
39715: LIST
39716: PPUSH
39717: CALL_OW 72
39721: ST_TO_ADDR
// if tmp < 6 then
39722: LD_VAR 0 4
39726: PUSH
39727: LD_INT 6
39729: LESS
39730: IFFALSE 39942
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39732: LD_ADDR_VAR 0 6
39736: PUSH
39737: LD_EXP 87
39741: PUSH
39742: LD_VAR 0 2
39746: ARRAY
39747: PPUSH
39748: LD_INT 2
39750: PUSH
39751: LD_INT 30
39753: PUSH
39754: LD_INT 0
39756: PUSH
39757: EMPTY
39758: LIST
39759: LIST
39760: PUSH
39761: LD_INT 30
39763: PUSH
39764: LD_INT 1
39766: PUSH
39767: EMPTY
39768: LIST
39769: LIST
39770: PUSH
39771: EMPTY
39772: LIST
39773: LIST
39774: LIST
39775: PPUSH
39776: CALL_OW 72
39780: ST_TO_ADDR
// if depot then
39781: LD_VAR 0 6
39785: IFFALSE 39942
// begin selected := 0 ;
39787: LD_ADDR_VAR 0 7
39791: PUSH
39792: LD_INT 0
39794: ST_TO_ADDR
// for j in depot do
39795: LD_ADDR_VAR 0 3
39799: PUSH
39800: LD_VAR 0 6
39804: PUSH
39805: FOR_IN
39806: IFFALSE 39837
// begin if UnitsInside ( j ) < 6 then
39808: LD_VAR 0 3
39812: PPUSH
39813: CALL_OW 313
39817: PUSH
39818: LD_INT 6
39820: LESS
39821: IFFALSE 39835
// begin selected := j ;
39823: LD_ADDR_VAR 0 7
39827: PUSH
39828: LD_VAR 0 3
39832: ST_TO_ADDR
// break ;
39833: GO 39837
// end ; end ;
39835: GO 39805
39837: POP
39838: POP
// if selected then
39839: LD_VAR 0 7
39843: IFFALSE 39942
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
39845: LD_ADDR_VAR 0 3
39849: PUSH
39850: LD_EXP 116
39854: PUSH
39855: LD_VAR 0 2
39859: ARRAY
39860: PPUSH
39861: LD_INT 25
39863: PUSH
39864: LD_INT 12
39866: PUSH
39867: EMPTY
39868: LIST
39869: LIST
39870: PPUSH
39871: CALL_OW 72
39875: PUSH
39876: FOR_IN
39877: IFFALSE 39940
// if not HasTask ( j ) then
39879: LD_VAR 0 3
39883: PPUSH
39884: CALL_OW 314
39888: NOT
39889: IFFALSE 39938
// begin if not IsInUnit ( j ) then
39891: LD_VAR 0 3
39895: PPUSH
39896: CALL_OW 310
39900: NOT
39901: IFFALSE 39917
// ComEnterUnit ( j , selected ) ;
39903: LD_VAR 0 3
39907: PPUSH
39908: LD_VAR 0 7
39912: PPUSH
39913: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
39917: LD_VAR 0 3
39921: PPUSH
39922: LD_INT 16
39924: PPUSH
39925: CALL_OW 183
// AddComExitBuilding ( j ) ;
39929: LD_VAR 0 3
39933: PPUSH
39934: CALL_OW 182
// end ;
39938: GO 39876
39940: POP
39941: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
39942: LD_VAR 0 5
39946: PPUSH
39947: LD_INT 11
39949: PPUSH
39950: CALL_OW 325
39954: IFFALSE 40213
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
39956: LD_ADDR_VAR 0 4
39960: PUSH
39961: LD_EXP 116
39965: PUSH
39966: LD_VAR 0 2
39970: ARRAY
39971: PPUSH
39972: LD_INT 25
39974: PUSH
39975: LD_INT 16
39977: PUSH
39978: EMPTY
39979: LIST
39980: LIST
39981: PPUSH
39982: CALL_OW 72
39986: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
39987: LD_VAR 0 4
39991: PUSH
39992: LD_INT 6
39994: GREATEREQUAL
39995: PUSH
39996: LD_VAR 0 5
40000: PPUSH
40001: LD_INT 2
40003: PPUSH
40004: CALL_OW 325
40008: NOT
40009: OR
40010: IFFALSE 40213
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
40012: LD_ADDR_VAR 0 8
40016: PUSH
40017: LD_EXP 87
40021: PUSH
40022: LD_VAR 0 2
40026: ARRAY
40027: PPUSH
40028: LD_INT 2
40030: PUSH
40031: LD_INT 30
40033: PUSH
40034: LD_INT 4
40036: PUSH
40037: EMPTY
40038: LIST
40039: LIST
40040: PUSH
40041: LD_INT 30
40043: PUSH
40044: LD_INT 5
40046: PUSH
40047: EMPTY
40048: LIST
40049: LIST
40050: PUSH
40051: EMPTY
40052: LIST
40053: LIST
40054: LIST
40055: PPUSH
40056: CALL_OW 72
40060: ST_TO_ADDR
// if barracks then
40061: LD_VAR 0 8
40065: IFFALSE 40213
// begin selected := 0 ;
40067: LD_ADDR_VAR 0 7
40071: PUSH
40072: LD_INT 0
40074: ST_TO_ADDR
// for j in barracks do
40075: LD_ADDR_VAR 0 3
40079: PUSH
40080: LD_VAR 0 8
40084: PUSH
40085: FOR_IN
40086: IFFALSE 40117
// begin if UnitsInside ( j ) < 6 then
40088: LD_VAR 0 3
40092: PPUSH
40093: CALL_OW 313
40097: PUSH
40098: LD_INT 6
40100: LESS
40101: IFFALSE 40115
// begin selected := j ;
40103: LD_ADDR_VAR 0 7
40107: PUSH
40108: LD_VAR 0 3
40112: ST_TO_ADDR
// break ;
40113: GO 40117
// end ; end ;
40115: GO 40085
40117: POP
40118: POP
// if selected then
40119: LD_VAR 0 7
40123: IFFALSE 40213
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
40125: LD_ADDR_VAR 0 3
40129: PUSH
40130: LD_EXP 116
40134: PUSH
40135: LD_VAR 0 2
40139: ARRAY
40140: PPUSH
40141: LD_INT 25
40143: PUSH
40144: LD_INT 12
40146: PUSH
40147: EMPTY
40148: LIST
40149: LIST
40150: PPUSH
40151: CALL_OW 72
40155: PUSH
40156: FOR_IN
40157: IFFALSE 40211
// if not IsInUnit ( j ) and not HasTask ( j ) then
40159: LD_VAR 0 3
40163: PPUSH
40164: CALL_OW 310
40168: NOT
40169: PUSH
40170: LD_VAR 0 3
40174: PPUSH
40175: CALL_OW 314
40179: NOT
40180: AND
40181: IFFALSE 40209
// begin ComEnterUnit ( j , selected ) ;
40183: LD_VAR 0 3
40187: PPUSH
40188: LD_VAR 0 7
40192: PPUSH
40193: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
40197: LD_VAR 0 3
40201: PPUSH
40202: LD_INT 15
40204: PPUSH
40205: CALL_OW 183
// end ;
40209: GO 40156
40211: POP
40212: POP
// end ; end ; end ; end ; end ;
40213: GO 39606
40215: POP
40216: POP
// end ;
40217: LD_VAR 0 1
40221: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
40222: LD_INT 0
40224: PPUSH
40225: PPUSH
40226: PPUSH
40227: PPUSH
// if not mc_bases then
40228: LD_EXP 87
40232: NOT
40233: IFFALSE 40237
// exit ;
40235: GO 40415
// for i = 1 to mc_bases do
40237: LD_ADDR_VAR 0 2
40241: PUSH
40242: DOUBLE
40243: LD_INT 1
40245: DEC
40246: ST_TO_ADDR
40247: LD_EXP 87
40251: PUSH
40252: FOR_TO
40253: IFFALSE 40413
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
40255: LD_ADDR_VAR 0 4
40259: PUSH
40260: LD_EXP 87
40264: PUSH
40265: LD_VAR 0 2
40269: ARRAY
40270: PPUSH
40271: LD_INT 25
40273: PUSH
40274: LD_INT 9
40276: PUSH
40277: EMPTY
40278: LIST
40279: LIST
40280: PPUSH
40281: CALL_OW 72
40285: ST_TO_ADDR
// if not tmp then
40286: LD_VAR 0 4
40290: NOT
40291: IFFALSE 40295
// continue ;
40293: GO 40252
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
40295: LD_EXP 113
40299: PUSH
40300: LD_VAR 0 2
40304: ARRAY
40305: PPUSH
40306: LD_INT 29
40308: PPUSH
40309: CALL_OW 325
40313: NOT
40314: PUSH
40315: LD_EXP 113
40319: PUSH
40320: LD_VAR 0 2
40324: ARRAY
40325: PPUSH
40326: LD_INT 28
40328: PPUSH
40329: CALL_OW 325
40333: NOT
40334: AND
40335: IFFALSE 40339
// continue ;
40337: GO 40252
// for j in tmp do
40339: LD_ADDR_VAR 0 3
40343: PUSH
40344: LD_VAR 0 4
40348: PUSH
40349: FOR_IN
40350: IFFALSE 40409
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
40352: LD_VAR 0 3
40356: PUSH
40357: LD_EXP 90
40361: PUSH
40362: LD_VAR 0 2
40366: ARRAY
40367: PUSH
40368: LD_INT 1
40370: ARRAY
40371: IN
40372: NOT
40373: PUSH
40374: LD_VAR 0 3
40378: PUSH
40379: LD_EXP 90
40383: PUSH
40384: LD_VAR 0 2
40388: ARRAY
40389: PUSH
40390: LD_INT 2
40392: ARRAY
40393: IN
40394: NOT
40395: AND
40396: IFFALSE 40407
// ComSpaceTimeShoot ( j ) ;
40398: LD_VAR 0 3
40402: PPUSH
40403: CALL 51553 0 1
40407: GO 40349
40409: POP
40410: POP
// end ;
40411: GO 40252
40413: POP
40414: POP
// end ;
40415: LD_VAR 0 1
40419: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
40420: LD_INT 0
40422: PPUSH
40423: PPUSH
40424: PPUSH
40425: PPUSH
40426: PPUSH
40427: PPUSH
40428: PPUSH
40429: PPUSH
40430: PPUSH
// if not mc_bases then
40431: LD_EXP 87
40435: NOT
40436: IFFALSE 40440
// exit ;
40438: GO 41062
// for i = 1 to mc_bases do
40440: LD_ADDR_VAR 0 2
40444: PUSH
40445: DOUBLE
40446: LD_INT 1
40448: DEC
40449: ST_TO_ADDR
40450: LD_EXP 87
40454: PUSH
40455: FOR_TO
40456: IFFALSE 41060
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
40458: LD_EXP 122
40462: PUSH
40463: LD_VAR 0 2
40467: ARRAY
40468: NOT
40469: PUSH
40470: LD_INT 38
40472: PPUSH
40473: LD_EXP 113
40477: PUSH
40478: LD_VAR 0 2
40482: ARRAY
40483: PPUSH
40484: CALL_OW 321
40488: PUSH
40489: LD_INT 2
40491: NONEQUAL
40492: OR
40493: IFFALSE 40497
// continue ;
40495: GO 40455
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
40497: LD_ADDR_VAR 0 8
40501: PUSH
40502: LD_EXP 87
40506: PUSH
40507: LD_VAR 0 2
40511: ARRAY
40512: PPUSH
40513: LD_INT 30
40515: PUSH
40516: LD_INT 34
40518: PUSH
40519: EMPTY
40520: LIST
40521: LIST
40522: PPUSH
40523: CALL_OW 72
40527: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
40528: LD_ADDR_VAR 0 9
40532: PUSH
40533: LD_EXP 87
40537: PUSH
40538: LD_VAR 0 2
40542: ARRAY
40543: PPUSH
40544: LD_INT 25
40546: PUSH
40547: LD_INT 4
40549: PUSH
40550: EMPTY
40551: LIST
40552: LIST
40553: PPUSH
40554: CALL_OW 72
40558: PPUSH
40559: LD_INT 0
40561: PPUSH
40562: CALL 91237 0 2
40566: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
40567: LD_VAR 0 9
40571: NOT
40572: PUSH
40573: LD_VAR 0 8
40577: NOT
40578: OR
40579: PUSH
40580: LD_EXP 87
40584: PUSH
40585: LD_VAR 0 2
40589: ARRAY
40590: PPUSH
40591: LD_INT 124
40593: PPUSH
40594: CALL 91237 0 2
40598: OR
40599: IFFALSE 40603
// continue ;
40601: GO 40455
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
40603: LD_EXP 123
40607: PUSH
40608: LD_VAR 0 2
40612: ARRAY
40613: PUSH
40614: LD_EXP 122
40618: PUSH
40619: LD_VAR 0 2
40623: ARRAY
40624: LESS
40625: PUSH
40626: LD_EXP 123
40630: PUSH
40631: LD_VAR 0 2
40635: ARRAY
40636: PUSH
40637: LD_VAR 0 8
40641: LESS
40642: AND
40643: IFFALSE 41058
// begin tmp := sci [ 1 ] ;
40645: LD_ADDR_VAR 0 7
40649: PUSH
40650: LD_VAR 0 9
40654: PUSH
40655: LD_INT 1
40657: ARRAY
40658: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
40659: LD_VAR 0 7
40663: PPUSH
40664: LD_INT 124
40666: PPUSH
40667: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
40671: LD_ADDR_VAR 0 3
40675: PUSH
40676: DOUBLE
40677: LD_EXP 122
40681: PUSH
40682: LD_VAR 0 2
40686: ARRAY
40687: INC
40688: ST_TO_ADDR
40689: LD_EXP 122
40693: PUSH
40694: LD_VAR 0 2
40698: ARRAY
40699: PUSH
40700: FOR_DOWNTO
40701: IFFALSE 41044
// begin if IsInUnit ( tmp ) then
40703: LD_VAR 0 7
40707: PPUSH
40708: CALL_OW 310
40712: IFFALSE 40723
// ComExitBuilding ( tmp ) ;
40714: LD_VAR 0 7
40718: PPUSH
40719: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
40723: LD_INT 35
40725: PPUSH
40726: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
40730: LD_VAR 0 7
40734: PPUSH
40735: CALL_OW 310
40739: NOT
40740: PUSH
40741: LD_VAR 0 7
40745: PPUSH
40746: CALL_OW 314
40750: NOT
40751: AND
40752: IFFALSE 40723
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
40754: LD_ADDR_VAR 0 6
40758: PUSH
40759: LD_VAR 0 7
40763: PPUSH
40764: CALL_OW 250
40768: PUSH
40769: LD_VAR 0 7
40773: PPUSH
40774: CALL_OW 251
40778: PUSH
40779: EMPTY
40780: LIST
40781: LIST
40782: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
40783: LD_INT 35
40785: PPUSH
40786: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
40790: LD_ADDR_VAR 0 4
40794: PUSH
40795: LD_EXP 122
40799: PUSH
40800: LD_VAR 0 2
40804: ARRAY
40805: PUSH
40806: LD_VAR 0 3
40810: ARRAY
40811: PUSH
40812: LD_INT 1
40814: ARRAY
40815: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
40816: LD_ADDR_VAR 0 5
40820: PUSH
40821: LD_EXP 122
40825: PUSH
40826: LD_VAR 0 2
40830: ARRAY
40831: PUSH
40832: LD_VAR 0 3
40836: ARRAY
40837: PUSH
40838: LD_INT 2
40840: ARRAY
40841: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
40842: LD_VAR 0 7
40846: PPUSH
40847: LD_INT 10
40849: PPUSH
40850: CALL 60560 0 2
40854: PUSH
40855: LD_INT 4
40857: ARRAY
40858: IFFALSE 40896
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
40860: LD_VAR 0 7
40864: PPUSH
40865: LD_VAR 0 6
40869: PUSH
40870: LD_INT 1
40872: ARRAY
40873: PPUSH
40874: LD_VAR 0 6
40878: PUSH
40879: LD_INT 2
40881: ARRAY
40882: PPUSH
40883: CALL_OW 111
// wait ( 0 0$10 ) ;
40887: LD_INT 350
40889: PPUSH
40890: CALL_OW 67
// end else
40894: GO 40922
// begin ComMoveXY ( tmp , x , y ) ;
40896: LD_VAR 0 7
40900: PPUSH
40901: LD_VAR 0 4
40905: PPUSH
40906: LD_VAR 0 5
40910: PPUSH
40911: CALL_OW 111
// wait ( 0 0$3 ) ;
40915: LD_INT 105
40917: PPUSH
40918: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
40922: LD_VAR 0 7
40926: PPUSH
40927: LD_VAR 0 4
40931: PPUSH
40932: LD_VAR 0 5
40936: PPUSH
40937: CALL_OW 307
40941: IFFALSE 40783
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
40943: LD_VAR 0 7
40947: PPUSH
40948: LD_VAR 0 4
40952: PPUSH
40953: LD_VAR 0 5
40957: PPUSH
40958: LD_VAR 0 8
40962: PUSH
40963: LD_VAR 0 3
40967: ARRAY
40968: PPUSH
40969: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
40973: LD_INT 35
40975: PPUSH
40976: CALL_OW 67
// until not HasTask ( tmp ) ;
40980: LD_VAR 0 7
40984: PPUSH
40985: CALL_OW 314
40989: NOT
40990: IFFALSE 40973
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
40992: LD_ADDR_EXP 123
40996: PUSH
40997: LD_EXP 123
41001: PPUSH
41002: LD_VAR 0 2
41006: PUSH
41007: LD_EXP 123
41011: PUSH
41012: LD_VAR 0 2
41016: ARRAY
41017: PUSH
41018: LD_INT 1
41020: PLUS
41021: PUSH
41022: EMPTY
41023: LIST
41024: LIST
41025: PPUSH
41026: LD_VAR 0 8
41030: PUSH
41031: LD_VAR 0 3
41035: ARRAY
41036: PPUSH
41037: CALL 57967 0 3
41041: ST_TO_ADDR
// end ;
41042: GO 40700
41044: POP
41045: POP
// MC_Reset ( i , 124 ) ;
41046: LD_VAR 0 2
41050: PPUSH
41051: LD_INT 124
41053: PPUSH
41054: CALL 24649 0 2
// end ; end ;
41058: GO 40455
41060: POP
41061: POP
// end ;
41062: LD_VAR 0 1
41066: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
41067: LD_INT 0
41069: PPUSH
41070: PPUSH
41071: PPUSH
// if not mc_bases then
41072: LD_EXP 87
41076: NOT
41077: IFFALSE 41081
// exit ;
41079: GO 41687
// for i = 1 to mc_bases do
41081: LD_ADDR_VAR 0 2
41085: PUSH
41086: DOUBLE
41087: LD_INT 1
41089: DEC
41090: ST_TO_ADDR
41091: LD_EXP 87
41095: PUSH
41096: FOR_TO
41097: IFFALSE 41685
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
41099: LD_ADDR_VAR 0 3
41103: PUSH
41104: LD_EXP 87
41108: PUSH
41109: LD_VAR 0 2
41113: ARRAY
41114: PPUSH
41115: LD_INT 25
41117: PUSH
41118: LD_INT 4
41120: PUSH
41121: EMPTY
41122: LIST
41123: LIST
41124: PPUSH
41125: CALL_OW 72
41129: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
41130: LD_VAR 0 3
41134: NOT
41135: PUSH
41136: LD_EXP 124
41140: PUSH
41141: LD_VAR 0 2
41145: ARRAY
41146: NOT
41147: OR
41148: PUSH
41149: LD_EXP 87
41153: PUSH
41154: LD_VAR 0 2
41158: ARRAY
41159: PPUSH
41160: LD_INT 2
41162: PUSH
41163: LD_INT 30
41165: PUSH
41166: LD_INT 0
41168: PUSH
41169: EMPTY
41170: LIST
41171: LIST
41172: PUSH
41173: LD_INT 30
41175: PUSH
41176: LD_INT 1
41178: PUSH
41179: EMPTY
41180: LIST
41181: LIST
41182: PUSH
41183: EMPTY
41184: LIST
41185: LIST
41186: LIST
41187: PPUSH
41188: CALL_OW 72
41192: NOT
41193: OR
41194: IFFALSE 41244
// begin if mc_deposits_finder [ i ] then
41196: LD_EXP 125
41200: PUSH
41201: LD_VAR 0 2
41205: ARRAY
41206: IFFALSE 41242
// begin MC_Reset ( i , 125 ) ;
41208: LD_VAR 0 2
41212: PPUSH
41213: LD_INT 125
41215: PPUSH
41216: CALL 24649 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41220: LD_ADDR_EXP 125
41224: PUSH
41225: LD_EXP 125
41229: PPUSH
41230: LD_VAR 0 2
41234: PPUSH
41235: EMPTY
41236: PPUSH
41237: CALL_OW 1
41241: ST_TO_ADDR
// end ; continue ;
41242: GO 41096
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
41244: LD_EXP 124
41248: PUSH
41249: LD_VAR 0 2
41253: ARRAY
41254: PUSH
41255: LD_INT 1
41257: ARRAY
41258: PUSH
41259: LD_INT 3
41261: ARRAY
41262: PUSH
41263: LD_INT 1
41265: EQUAL
41266: PUSH
41267: LD_INT 20
41269: PPUSH
41270: LD_EXP 113
41274: PUSH
41275: LD_VAR 0 2
41279: ARRAY
41280: PPUSH
41281: CALL_OW 321
41285: PUSH
41286: LD_INT 2
41288: NONEQUAL
41289: AND
41290: IFFALSE 41340
// begin if mc_deposits_finder [ i ] then
41292: LD_EXP 125
41296: PUSH
41297: LD_VAR 0 2
41301: ARRAY
41302: IFFALSE 41338
// begin MC_Reset ( i , 125 ) ;
41304: LD_VAR 0 2
41308: PPUSH
41309: LD_INT 125
41311: PPUSH
41312: CALL 24649 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41316: LD_ADDR_EXP 125
41320: PUSH
41321: LD_EXP 125
41325: PPUSH
41326: LD_VAR 0 2
41330: PPUSH
41331: EMPTY
41332: PPUSH
41333: CALL_OW 1
41337: ST_TO_ADDR
// end ; continue ;
41338: GO 41096
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
41340: LD_EXP 124
41344: PUSH
41345: LD_VAR 0 2
41349: ARRAY
41350: PUSH
41351: LD_INT 1
41353: ARRAY
41354: PUSH
41355: LD_INT 1
41357: ARRAY
41358: PPUSH
41359: LD_EXP 124
41363: PUSH
41364: LD_VAR 0 2
41368: ARRAY
41369: PUSH
41370: LD_INT 1
41372: ARRAY
41373: PUSH
41374: LD_INT 2
41376: ARRAY
41377: PPUSH
41378: LD_EXP 113
41382: PUSH
41383: LD_VAR 0 2
41387: ARRAY
41388: PPUSH
41389: CALL_OW 440
41393: IFFALSE 41436
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
41395: LD_ADDR_EXP 124
41399: PUSH
41400: LD_EXP 124
41404: PPUSH
41405: LD_VAR 0 2
41409: PPUSH
41410: LD_EXP 124
41414: PUSH
41415: LD_VAR 0 2
41419: ARRAY
41420: PPUSH
41421: LD_INT 1
41423: PPUSH
41424: CALL_OW 3
41428: PPUSH
41429: CALL_OW 1
41433: ST_TO_ADDR
41434: GO 41683
// begin if not mc_deposits_finder [ i ] then
41436: LD_EXP 125
41440: PUSH
41441: LD_VAR 0 2
41445: ARRAY
41446: NOT
41447: IFFALSE 41499
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
41449: LD_ADDR_EXP 125
41453: PUSH
41454: LD_EXP 125
41458: PPUSH
41459: LD_VAR 0 2
41463: PPUSH
41464: LD_VAR 0 3
41468: PUSH
41469: LD_INT 1
41471: ARRAY
41472: PUSH
41473: EMPTY
41474: LIST
41475: PPUSH
41476: CALL_OW 1
41480: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
41481: LD_VAR 0 3
41485: PUSH
41486: LD_INT 1
41488: ARRAY
41489: PPUSH
41490: LD_INT 125
41492: PPUSH
41493: CALL_OW 109
// end else
41497: GO 41683
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
41499: LD_EXP 125
41503: PUSH
41504: LD_VAR 0 2
41508: ARRAY
41509: PUSH
41510: LD_INT 1
41512: ARRAY
41513: PPUSH
41514: CALL_OW 310
41518: IFFALSE 41541
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
41520: LD_EXP 125
41524: PUSH
41525: LD_VAR 0 2
41529: ARRAY
41530: PUSH
41531: LD_INT 1
41533: ARRAY
41534: PPUSH
41535: CALL_OW 122
41539: GO 41683
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
41541: LD_EXP 125
41545: PUSH
41546: LD_VAR 0 2
41550: ARRAY
41551: PUSH
41552: LD_INT 1
41554: ARRAY
41555: PPUSH
41556: CALL_OW 314
41560: NOT
41561: PUSH
41562: LD_EXP 125
41566: PUSH
41567: LD_VAR 0 2
41571: ARRAY
41572: PUSH
41573: LD_INT 1
41575: ARRAY
41576: PPUSH
41577: LD_EXP 124
41581: PUSH
41582: LD_VAR 0 2
41586: ARRAY
41587: PUSH
41588: LD_INT 1
41590: ARRAY
41591: PUSH
41592: LD_INT 1
41594: ARRAY
41595: PPUSH
41596: LD_EXP 124
41600: PUSH
41601: LD_VAR 0 2
41605: ARRAY
41606: PUSH
41607: LD_INT 1
41609: ARRAY
41610: PUSH
41611: LD_INT 2
41613: ARRAY
41614: PPUSH
41615: CALL_OW 297
41619: PUSH
41620: LD_INT 6
41622: GREATER
41623: AND
41624: IFFALSE 41683
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
41626: LD_EXP 125
41630: PUSH
41631: LD_VAR 0 2
41635: ARRAY
41636: PUSH
41637: LD_INT 1
41639: ARRAY
41640: PPUSH
41641: LD_EXP 124
41645: PUSH
41646: LD_VAR 0 2
41650: ARRAY
41651: PUSH
41652: LD_INT 1
41654: ARRAY
41655: PUSH
41656: LD_INT 1
41658: ARRAY
41659: PPUSH
41660: LD_EXP 124
41664: PUSH
41665: LD_VAR 0 2
41669: ARRAY
41670: PUSH
41671: LD_INT 1
41673: ARRAY
41674: PUSH
41675: LD_INT 2
41677: ARRAY
41678: PPUSH
41679: CALL_OW 111
// end ; end ; end ;
41683: GO 41096
41685: POP
41686: POP
// end ;
41687: LD_VAR 0 1
41691: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
41692: LD_INT 0
41694: PPUSH
41695: PPUSH
41696: PPUSH
41697: PPUSH
41698: PPUSH
41699: PPUSH
41700: PPUSH
41701: PPUSH
41702: PPUSH
41703: PPUSH
41704: PPUSH
// if not mc_bases then
41705: LD_EXP 87
41709: NOT
41710: IFFALSE 41714
// exit ;
41712: GO 42654
// for i = 1 to mc_bases do
41714: LD_ADDR_VAR 0 2
41718: PUSH
41719: DOUBLE
41720: LD_INT 1
41722: DEC
41723: ST_TO_ADDR
41724: LD_EXP 87
41728: PUSH
41729: FOR_TO
41730: IFFALSE 42652
// begin if not mc_bases [ i ] or mc_scan [ i ] then
41732: LD_EXP 87
41736: PUSH
41737: LD_VAR 0 2
41741: ARRAY
41742: NOT
41743: PUSH
41744: LD_EXP 110
41748: PUSH
41749: LD_VAR 0 2
41753: ARRAY
41754: OR
41755: IFFALSE 41759
// continue ;
41757: GO 41729
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
41759: LD_ADDR_VAR 0 7
41763: PUSH
41764: LD_EXP 87
41768: PUSH
41769: LD_VAR 0 2
41773: ARRAY
41774: PUSH
41775: LD_INT 1
41777: ARRAY
41778: PPUSH
41779: CALL_OW 248
41783: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
41784: LD_VAR 0 7
41788: PUSH
41789: LD_INT 3
41791: EQUAL
41792: PUSH
41793: LD_EXP 106
41797: PUSH
41798: LD_VAR 0 2
41802: ARRAY
41803: PUSH
41804: LD_EXP 109
41808: PUSH
41809: LD_VAR 0 2
41813: ARRAY
41814: UNION
41815: PPUSH
41816: LD_INT 33
41818: PUSH
41819: LD_INT 2
41821: PUSH
41822: EMPTY
41823: LIST
41824: LIST
41825: PPUSH
41826: CALL_OW 72
41830: NOT
41831: OR
41832: IFFALSE 41836
// continue ;
41834: GO 41729
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
41836: LD_ADDR_VAR 0 9
41840: PUSH
41841: LD_EXP 87
41845: PUSH
41846: LD_VAR 0 2
41850: ARRAY
41851: PPUSH
41852: LD_INT 30
41854: PUSH
41855: LD_INT 36
41857: PUSH
41858: EMPTY
41859: LIST
41860: LIST
41861: PPUSH
41862: CALL_OW 72
41866: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
41867: LD_ADDR_VAR 0 10
41871: PUSH
41872: LD_EXP 106
41876: PUSH
41877: LD_VAR 0 2
41881: ARRAY
41882: PPUSH
41883: LD_INT 34
41885: PUSH
41886: LD_INT 31
41888: PUSH
41889: EMPTY
41890: LIST
41891: LIST
41892: PPUSH
41893: CALL_OW 72
41897: ST_TO_ADDR
// if not cts and not mcts then
41898: LD_VAR 0 9
41902: NOT
41903: PUSH
41904: LD_VAR 0 10
41908: NOT
41909: AND
41910: IFFALSE 41914
// continue ;
41912: GO 41729
// x := cts ;
41914: LD_ADDR_VAR 0 11
41918: PUSH
41919: LD_VAR 0 9
41923: ST_TO_ADDR
// if not x then
41924: LD_VAR 0 11
41928: NOT
41929: IFFALSE 41941
// x := mcts ;
41931: LD_ADDR_VAR 0 11
41935: PUSH
41936: LD_VAR 0 10
41940: ST_TO_ADDR
// if not x then
41941: LD_VAR 0 11
41945: NOT
41946: IFFALSE 41950
// continue ;
41948: GO 41729
// if mc_remote_driver [ i ] then
41950: LD_EXP 127
41954: PUSH
41955: LD_VAR 0 2
41959: ARRAY
41960: IFFALSE 42347
// for j in mc_remote_driver [ i ] do
41962: LD_ADDR_VAR 0 3
41966: PUSH
41967: LD_EXP 127
41971: PUSH
41972: LD_VAR 0 2
41976: ARRAY
41977: PUSH
41978: FOR_IN
41979: IFFALSE 42345
// begin if GetClass ( j ) <> 3 then
41981: LD_VAR 0 3
41985: PPUSH
41986: CALL_OW 257
41990: PUSH
41991: LD_INT 3
41993: NONEQUAL
41994: IFFALSE 42047
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
41996: LD_ADDR_EXP 127
42000: PUSH
42001: LD_EXP 127
42005: PPUSH
42006: LD_VAR 0 2
42010: PPUSH
42011: LD_EXP 127
42015: PUSH
42016: LD_VAR 0 2
42020: ARRAY
42021: PUSH
42022: LD_VAR 0 3
42026: DIFF
42027: PPUSH
42028: CALL_OW 1
42032: ST_TO_ADDR
// SetTag ( j , 0 ) ;
42033: LD_VAR 0 3
42037: PPUSH
42038: LD_INT 0
42040: PPUSH
42041: CALL_OW 109
// continue ;
42045: GO 41978
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
42047: LD_EXP 106
42051: PUSH
42052: LD_VAR 0 2
42056: ARRAY
42057: PPUSH
42058: LD_INT 34
42060: PUSH
42061: LD_INT 31
42063: PUSH
42064: EMPTY
42065: LIST
42066: LIST
42067: PUSH
42068: LD_INT 58
42070: PUSH
42071: EMPTY
42072: LIST
42073: PUSH
42074: EMPTY
42075: LIST
42076: LIST
42077: PPUSH
42078: CALL_OW 72
42082: PUSH
42083: LD_VAR 0 3
42087: PPUSH
42088: CALL 91325 0 1
42092: NOT
42093: AND
42094: IFFALSE 42165
// begin if IsInUnit ( j ) then
42096: LD_VAR 0 3
42100: PPUSH
42101: CALL_OW 310
42105: IFFALSE 42116
// ComExitBuilding ( j ) ;
42107: LD_VAR 0 3
42111: PPUSH
42112: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
42116: LD_VAR 0 3
42120: PPUSH
42121: LD_EXP 106
42125: PUSH
42126: LD_VAR 0 2
42130: ARRAY
42131: PPUSH
42132: LD_INT 34
42134: PUSH
42135: LD_INT 31
42137: PUSH
42138: EMPTY
42139: LIST
42140: LIST
42141: PUSH
42142: LD_INT 58
42144: PUSH
42145: EMPTY
42146: LIST
42147: PUSH
42148: EMPTY
42149: LIST
42150: LIST
42151: PPUSH
42152: CALL_OW 72
42156: PUSH
42157: LD_INT 1
42159: ARRAY
42160: PPUSH
42161: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
42165: LD_VAR 0 3
42169: PPUSH
42170: CALL_OW 310
42174: NOT
42175: PUSH
42176: LD_VAR 0 3
42180: PPUSH
42181: CALL_OW 310
42185: PPUSH
42186: CALL_OW 266
42190: PUSH
42191: LD_INT 36
42193: NONEQUAL
42194: PUSH
42195: LD_VAR 0 3
42199: PPUSH
42200: CALL 91325 0 1
42204: NOT
42205: AND
42206: OR
42207: IFFALSE 42343
// begin if IsInUnit ( j ) then
42209: LD_VAR 0 3
42213: PPUSH
42214: CALL_OW 310
42218: IFFALSE 42229
// ComExitBuilding ( j ) ;
42220: LD_VAR 0 3
42224: PPUSH
42225: CALL_OW 122
// ct := 0 ;
42229: LD_ADDR_VAR 0 8
42233: PUSH
42234: LD_INT 0
42236: ST_TO_ADDR
// for k in x do
42237: LD_ADDR_VAR 0 4
42241: PUSH
42242: LD_VAR 0 11
42246: PUSH
42247: FOR_IN
42248: IFFALSE 42321
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
42250: LD_VAR 0 4
42254: PPUSH
42255: CALL_OW 264
42259: PUSH
42260: LD_INT 31
42262: EQUAL
42263: PUSH
42264: LD_VAR 0 4
42268: PPUSH
42269: CALL_OW 311
42273: NOT
42274: AND
42275: PUSH
42276: LD_VAR 0 4
42280: PPUSH
42281: CALL_OW 266
42285: PUSH
42286: LD_INT 36
42288: EQUAL
42289: PUSH
42290: LD_VAR 0 4
42294: PPUSH
42295: CALL_OW 313
42299: PUSH
42300: LD_INT 3
42302: LESS
42303: AND
42304: OR
42305: IFFALSE 42319
// begin ct := k ;
42307: LD_ADDR_VAR 0 8
42311: PUSH
42312: LD_VAR 0 4
42316: ST_TO_ADDR
// break ;
42317: GO 42321
// end ;
42319: GO 42247
42321: POP
42322: POP
// if ct then
42323: LD_VAR 0 8
42327: IFFALSE 42343
// ComEnterUnit ( j , ct ) ;
42329: LD_VAR 0 3
42333: PPUSH
42334: LD_VAR 0 8
42338: PPUSH
42339: CALL_OW 120
// end ; end ;
42343: GO 41978
42345: POP
42346: POP
// places := 0 ;
42347: LD_ADDR_VAR 0 5
42351: PUSH
42352: LD_INT 0
42354: ST_TO_ADDR
// for j = 1 to x do
42355: LD_ADDR_VAR 0 3
42359: PUSH
42360: DOUBLE
42361: LD_INT 1
42363: DEC
42364: ST_TO_ADDR
42365: LD_VAR 0 11
42369: PUSH
42370: FOR_TO
42371: IFFALSE 42447
// if GetWeapon ( x [ j ] ) = ar_control_tower then
42373: LD_VAR 0 11
42377: PUSH
42378: LD_VAR 0 3
42382: ARRAY
42383: PPUSH
42384: CALL_OW 264
42388: PUSH
42389: LD_INT 31
42391: EQUAL
42392: IFFALSE 42410
// places := places + 1 else
42394: LD_ADDR_VAR 0 5
42398: PUSH
42399: LD_VAR 0 5
42403: PUSH
42404: LD_INT 1
42406: PLUS
42407: ST_TO_ADDR
42408: GO 42445
// if GetBType ( x [ j ] ) = b_control_tower then
42410: LD_VAR 0 11
42414: PUSH
42415: LD_VAR 0 3
42419: ARRAY
42420: PPUSH
42421: CALL_OW 266
42425: PUSH
42426: LD_INT 36
42428: EQUAL
42429: IFFALSE 42445
// places := places + 3 ;
42431: LD_ADDR_VAR 0 5
42435: PUSH
42436: LD_VAR 0 5
42440: PUSH
42441: LD_INT 3
42443: PLUS
42444: ST_TO_ADDR
42445: GO 42370
42447: POP
42448: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
42449: LD_VAR 0 5
42453: PUSH
42454: LD_INT 0
42456: EQUAL
42457: PUSH
42458: LD_VAR 0 5
42462: PUSH
42463: LD_EXP 127
42467: PUSH
42468: LD_VAR 0 2
42472: ARRAY
42473: LESSEQUAL
42474: OR
42475: IFFALSE 42479
// continue ;
42477: GO 41729
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
42479: LD_ADDR_VAR 0 6
42483: PUSH
42484: LD_EXP 87
42488: PUSH
42489: LD_VAR 0 2
42493: ARRAY
42494: PPUSH
42495: LD_INT 25
42497: PUSH
42498: LD_INT 3
42500: PUSH
42501: EMPTY
42502: LIST
42503: LIST
42504: PPUSH
42505: CALL_OW 72
42509: PUSH
42510: LD_EXP 127
42514: PUSH
42515: LD_VAR 0 2
42519: ARRAY
42520: DIFF
42521: PPUSH
42522: LD_INT 3
42524: PPUSH
42525: CALL 92225 0 2
42529: ST_TO_ADDR
// for j in tmp do
42530: LD_ADDR_VAR 0 3
42534: PUSH
42535: LD_VAR 0 6
42539: PUSH
42540: FOR_IN
42541: IFFALSE 42576
// if GetTag ( j ) > 0 then
42543: LD_VAR 0 3
42547: PPUSH
42548: CALL_OW 110
42552: PUSH
42553: LD_INT 0
42555: GREATER
42556: IFFALSE 42574
// tmp := tmp diff j ;
42558: LD_ADDR_VAR 0 6
42562: PUSH
42563: LD_VAR 0 6
42567: PUSH
42568: LD_VAR 0 3
42572: DIFF
42573: ST_TO_ADDR
42574: GO 42540
42576: POP
42577: POP
// if not tmp then
42578: LD_VAR 0 6
42582: NOT
42583: IFFALSE 42587
// continue ;
42585: GO 41729
// if places then
42587: LD_VAR 0 5
42591: IFFALSE 42650
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
42593: LD_ADDR_EXP 127
42597: PUSH
42598: LD_EXP 127
42602: PPUSH
42603: LD_VAR 0 2
42607: PPUSH
42608: LD_EXP 127
42612: PUSH
42613: LD_VAR 0 2
42617: ARRAY
42618: PUSH
42619: LD_VAR 0 6
42623: PUSH
42624: LD_INT 1
42626: ARRAY
42627: UNION
42628: PPUSH
42629: CALL_OW 1
42633: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
42634: LD_VAR 0 6
42638: PUSH
42639: LD_INT 1
42641: ARRAY
42642: PPUSH
42643: LD_INT 126
42645: PPUSH
42646: CALL_OW 109
// end ; end ;
42650: GO 41729
42652: POP
42653: POP
// end ;
42654: LD_VAR 0 1
42658: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
42659: LD_INT 0
42661: PPUSH
42662: PPUSH
42663: PPUSH
42664: PPUSH
42665: PPUSH
42666: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
42667: LD_VAR 0 1
42671: NOT
42672: PUSH
42673: LD_VAR 0 2
42677: NOT
42678: OR
42679: PUSH
42680: LD_VAR 0 3
42684: NOT
42685: OR
42686: PUSH
42687: LD_VAR 0 4
42691: PUSH
42692: LD_INT 1
42694: PUSH
42695: LD_INT 2
42697: PUSH
42698: LD_INT 3
42700: PUSH
42701: LD_INT 4
42703: PUSH
42704: LD_INT 5
42706: PUSH
42707: LD_INT 8
42709: PUSH
42710: LD_INT 9
42712: PUSH
42713: LD_INT 15
42715: PUSH
42716: LD_INT 16
42718: PUSH
42719: EMPTY
42720: LIST
42721: LIST
42722: LIST
42723: LIST
42724: LIST
42725: LIST
42726: LIST
42727: LIST
42728: LIST
42729: IN
42730: NOT
42731: OR
42732: IFFALSE 42736
// exit ;
42734: GO 43636
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
42736: LD_ADDR_VAR 0 2
42740: PUSH
42741: LD_VAR 0 2
42745: PPUSH
42746: LD_INT 21
42748: PUSH
42749: LD_INT 3
42751: PUSH
42752: EMPTY
42753: LIST
42754: LIST
42755: PUSH
42756: LD_INT 24
42758: PUSH
42759: LD_INT 250
42761: PUSH
42762: EMPTY
42763: LIST
42764: LIST
42765: PUSH
42766: EMPTY
42767: LIST
42768: LIST
42769: PPUSH
42770: CALL_OW 72
42774: ST_TO_ADDR
// case class of 1 , 15 :
42775: LD_VAR 0 4
42779: PUSH
42780: LD_INT 1
42782: DOUBLE
42783: EQUAL
42784: IFTRUE 42794
42786: LD_INT 15
42788: DOUBLE
42789: EQUAL
42790: IFTRUE 42794
42792: GO 42879
42794: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
42795: LD_ADDR_VAR 0 8
42799: PUSH
42800: LD_VAR 0 2
42804: PPUSH
42805: LD_INT 2
42807: PUSH
42808: LD_INT 30
42810: PUSH
42811: LD_INT 32
42813: PUSH
42814: EMPTY
42815: LIST
42816: LIST
42817: PUSH
42818: LD_INT 30
42820: PUSH
42821: LD_INT 31
42823: PUSH
42824: EMPTY
42825: LIST
42826: LIST
42827: PUSH
42828: EMPTY
42829: LIST
42830: LIST
42831: LIST
42832: PPUSH
42833: CALL_OW 72
42837: PUSH
42838: LD_VAR 0 2
42842: PPUSH
42843: LD_INT 2
42845: PUSH
42846: LD_INT 30
42848: PUSH
42849: LD_INT 4
42851: PUSH
42852: EMPTY
42853: LIST
42854: LIST
42855: PUSH
42856: LD_INT 30
42858: PUSH
42859: LD_INT 5
42861: PUSH
42862: EMPTY
42863: LIST
42864: LIST
42865: PUSH
42866: EMPTY
42867: LIST
42868: LIST
42869: LIST
42870: PPUSH
42871: CALL_OW 72
42875: ADD
42876: ST_TO_ADDR
42877: GO 43125
42879: LD_INT 2
42881: DOUBLE
42882: EQUAL
42883: IFTRUE 42893
42885: LD_INT 16
42887: DOUBLE
42888: EQUAL
42889: IFTRUE 42893
42891: GO 42939
42893: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
42894: LD_ADDR_VAR 0 8
42898: PUSH
42899: LD_VAR 0 2
42903: PPUSH
42904: LD_INT 2
42906: PUSH
42907: LD_INT 30
42909: PUSH
42910: LD_INT 0
42912: PUSH
42913: EMPTY
42914: LIST
42915: LIST
42916: PUSH
42917: LD_INT 30
42919: PUSH
42920: LD_INT 1
42922: PUSH
42923: EMPTY
42924: LIST
42925: LIST
42926: PUSH
42927: EMPTY
42928: LIST
42929: LIST
42930: LIST
42931: PPUSH
42932: CALL_OW 72
42936: ST_TO_ADDR
42937: GO 43125
42939: LD_INT 3
42941: DOUBLE
42942: EQUAL
42943: IFTRUE 42947
42945: GO 42993
42947: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
42948: LD_ADDR_VAR 0 8
42952: PUSH
42953: LD_VAR 0 2
42957: PPUSH
42958: LD_INT 2
42960: PUSH
42961: LD_INT 30
42963: PUSH
42964: LD_INT 2
42966: PUSH
42967: EMPTY
42968: LIST
42969: LIST
42970: PUSH
42971: LD_INT 30
42973: PUSH
42974: LD_INT 3
42976: PUSH
42977: EMPTY
42978: LIST
42979: LIST
42980: PUSH
42981: EMPTY
42982: LIST
42983: LIST
42984: LIST
42985: PPUSH
42986: CALL_OW 72
42990: ST_TO_ADDR
42991: GO 43125
42993: LD_INT 4
42995: DOUBLE
42996: EQUAL
42997: IFTRUE 43001
42999: GO 43058
43001: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
43002: LD_ADDR_VAR 0 8
43006: PUSH
43007: LD_VAR 0 2
43011: PPUSH
43012: LD_INT 2
43014: PUSH
43015: LD_INT 30
43017: PUSH
43018: LD_INT 6
43020: PUSH
43021: EMPTY
43022: LIST
43023: LIST
43024: PUSH
43025: LD_INT 30
43027: PUSH
43028: LD_INT 7
43030: PUSH
43031: EMPTY
43032: LIST
43033: LIST
43034: PUSH
43035: LD_INT 30
43037: PUSH
43038: LD_INT 8
43040: PUSH
43041: EMPTY
43042: LIST
43043: LIST
43044: PUSH
43045: EMPTY
43046: LIST
43047: LIST
43048: LIST
43049: LIST
43050: PPUSH
43051: CALL_OW 72
43055: ST_TO_ADDR
43056: GO 43125
43058: LD_INT 5
43060: DOUBLE
43061: EQUAL
43062: IFTRUE 43078
43064: LD_INT 8
43066: DOUBLE
43067: EQUAL
43068: IFTRUE 43078
43070: LD_INT 9
43072: DOUBLE
43073: EQUAL
43074: IFTRUE 43078
43076: GO 43124
43078: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
43079: LD_ADDR_VAR 0 8
43083: PUSH
43084: LD_VAR 0 2
43088: PPUSH
43089: LD_INT 2
43091: PUSH
43092: LD_INT 30
43094: PUSH
43095: LD_INT 4
43097: PUSH
43098: EMPTY
43099: LIST
43100: LIST
43101: PUSH
43102: LD_INT 30
43104: PUSH
43105: LD_INT 5
43107: PUSH
43108: EMPTY
43109: LIST
43110: LIST
43111: PUSH
43112: EMPTY
43113: LIST
43114: LIST
43115: LIST
43116: PPUSH
43117: CALL_OW 72
43121: ST_TO_ADDR
43122: GO 43125
43124: POP
// if not tmp then
43125: LD_VAR 0 8
43129: NOT
43130: IFFALSE 43134
// exit ;
43132: GO 43636
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
43134: LD_VAR 0 4
43138: PUSH
43139: LD_INT 1
43141: PUSH
43142: LD_INT 15
43144: PUSH
43145: EMPTY
43146: LIST
43147: LIST
43148: IN
43149: PUSH
43150: LD_EXP 96
43154: PUSH
43155: LD_VAR 0 1
43159: ARRAY
43160: AND
43161: IFFALSE 43317
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
43163: LD_ADDR_VAR 0 9
43167: PUSH
43168: LD_EXP 96
43172: PUSH
43173: LD_VAR 0 1
43177: ARRAY
43178: PUSH
43179: LD_INT 1
43181: ARRAY
43182: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
43183: LD_VAR 0 9
43187: PUSH
43188: LD_EXP 97
43192: PUSH
43193: LD_VAR 0 1
43197: ARRAY
43198: IN
43199: NOT
43200: IFFALSE 43315
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
43202: LD_ADDR_EXP 97
43206: PUSH
43207: LD_EXP 97
43211: PPUSH
43212: LD_VAR 0 1
43216: PUSH
43217: LD_EXP 97
43221: PUSH
43222: LD_VAR 0 1
43226: ARRAY
43227: PUSH
43228: LD_INT 1
43230: PLUS
43231: PUSH
43232: EMPTY
43233: LIST
43234: LIST
43235: PPUSH
43236: LD_VAR 0 9
43240: PPUSH
43241: CALL 57967 0 3
43245: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
43246: LD_ADDR_EXP 96
43250: PUSH
43251: LD_EXP 96
43255: PPUSH
43256: LD_VAR 0 1
43260: PPUSH
43261: LD_EXP 96
43265: PUSH
43266: LD_VAR 0 1
43270: ARRAY
43271: PUSH
43272: LD_VAR 0 9
43276: DIFF
43277: PPUSH
43278: CALL_OW 1
43282: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
43283: LD_VAR 0 3
43287: PPUSH
43288: LD_EXP 97
43292: PUSH
43293: LD_VAR 0 1
43297: ARRAY
43298: PUSH
43299: LD_EXP 97
43303: PUSH
43304: LD_VAR 0 1
43308: ARRAY
43309: ARRAY
43310: PPUSH
43311: CALL_OW 120
// end ; exit ;
43315: GO 43636
// end ; if tmp > 1 then
43317: LD_VAR 0 8
43321: PUSH
43322: LD_INT 1
43324: GREATER
43325: IFFALSE 43429
// for i = 2 to tmp do
43327: LD_ADDR_VAR 0 6
43331: PUSH
43332: DOUBLE
43333: LD_INT 2
43335: DEC
43336: ST_TO_ADDR
43337: LD_VAR 0 8
43341: PUSH
43342: FOR_TO
43343: IFFALSE 43427
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
43345: LD_VAR 0 8
43349: PUSH
43350: LD_VAR 0 6
43354: ARRAY
43355: PPUSH
43356: CALL_OW 461
43360: PUSH
43361: LD_INT 6
43363: EQUAL
43364: IFFALSE 43425
// begin x := tmp [ i ] ;
43366: LD_ADDR_VAR 0 9
43370: PUSH
43371: LD_VAR 0 8
43375: PUSH
43376: LD_VAR 0 6
43380: ARRAY
43381: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
43382: LD_ADDR_VAR 0 8
43386: PUSH
43387: LD_VAR 0 8
43391: PPUSH
43392: LD_VAR 0 6
43396: PPUSH
43397: CALL_OW 3
43401: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
43402: LD_ADDR_VAR 0 8
43406: PUSH
43407: LD_VAR 0 8
43411: PPUSH
43412: LD_INT 1
43414: PPUSH
43415: LD_VAR 0 9
43419: PPUSH
43420: CALL_OW 2
43424: ST_TO_ADDR
// end ;
43425: GO 43342
43427: POP
43428: POP
// for i in tmp do
43429: LD_ADDR_VAR 0 6
43433: PUSH
43434: LD_VAR 0 8
43438: PUSH
43439: FOR_IN
43440: IFFALSE 43509
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
43442: LD_VAR 0 6
43446: PPUSH
43447: CALL_OW 313
43451: PUSH
43452: LD_INT 6
43454: LESS
43455: PUSH
43456: LD_VAR 0 6
43460: PPUSH
43461: CALL_OW 266
43465: PUSH
43466: LD_INT 31
43468: PUSH
43469: LD_INT 32
43471: PUSH
43472: EMPTY
43473: LIST
43474: LIST
43475: IN
43476: NOT
43477: AND
43478: PUSH
43479: LD_VAR 0 6
43483: PPUSH
43484: CALL_OW 313
43488: PUSH
43489: LD_INT 0
43491: EQUAL
43492: OR
43493: IFFALSE 43507
// begin j := i ;
43495: LD_ADDR_VAR 0 7
43499: PUSH
43500: LD_VAR 0 6
43504: ST_TO_ADDR
// break ;
43505: GO 43509
// end ; end ;
43507: GO 43439
43509: POP
43510: POP
// if j then
43511: LD_VAR 0 7
43515: IFFALSE 43533
// ComEnterUnit ( unit , j ) else
43517: LD_VAR 0 3
43521: PPUSH
43522: LD_VAR 0 7
43526: PPUSH
43527: CALL_OW 120
43531: GO 43636
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43533: LD_ADDR_VAR 0 10
43537: PUSH
43538: LD_VAR 0 2
43542: PPUSH
43543: LD_INT 2
43545: PUSH
43546: LD_INT 30
43548: PUSH
43549: LD_INT 0
43551: PUSH
43552: EMPTY
43553: LIST
43554: LIST
43555: PUSH
43556: LD_INT 30
43558: PUSH
43559: LD_INT 1
43561: PUSH
43562: EMPTY
43563: LIST
43564: LIST
43565: PUSH
43566: EMPTY
43567: LIST
43568: LIST
43569: LIST
43570: PPUSH
43571: CALL_OW 72
43575: ST_TO_ADDR
// if depot then
43576: LD_VAR 0 10
43580: IFFALSE 43636
// begin depot := NearestUnitToUnit ( depot , unit ) ;
43582: LD_ADDR_VAR 0 10
43586: PUSH
43587: LD_VAR 0 10
43591: PPUSH
43592: LD_VAR 0 3
43596: PPUSH
43597: CALL_OW 74
43601: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
43602: LD_VAR 0 3
43606: PPUSH
43607: LD_VAR 0 10
43611: PPUSH
43612: CALL_OW 296
43616: PUSH
43617: LD_INT 10
43619: GREATER
43620: IFFALSE 43636
// ComStandNearbyBuilding ( unit , depot ) ;
43622: LD_VAR 0 3
43626: PPUSH
43627: LD_VAR 0 10
43631: PPUSH
43632: CALL 52170 0 2
// end ; end ; end ;
43636: LD_VAR 0 5
43640: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
43641: LD_INT 0
43643: PPUSH
43644: PPUSH
43645: PPUSH
43646: PPUSH
// if not mc_bases then
43647: LD_EXP 87
43651: NOT
43652: IFFALSE 43656
// exit ;
43654: GO 43895
// for i = 1 to mc_bases do
43656: LD_ADDR_VAR 0 2
43660: PUSH
43661: DOUBLE
43662: LD_INT 1
43664: DEC
43665: ST_TO_ADDR
43666: LD_EXP 87
43670: PUSH
43671: FOR_TO
43672: IFFALSE 43893
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
43674: LD_ADDR_VAR 0 4
43678: PUSH
43679: LD_EXP 87
43683: PUSH
43684: LD_VAR 0 2
43688: ARRAY
43689: PPUSH
43690: LD_INT 21
43692: PUSH
43693: LD_INT 1
43695: PUSH
43696: EMPTY
43697: LIST
43698: LIST
43699: PPUSH
43700: CALL_OW 72
43704: PUSH
43705: LD_EXP 116
43709: PUSH
43710: LD_VAR 0 2
43714: ARRAY
43715: UNION
43716: ST_TO_ADDR
// if not tmp then
43717: LD_VAR 0 4
43721: NOT
43722: IFFALSE 43726
// continue ;
43724: GO 43671
// for j in tmp do
43726: LD_ADDR_VAR 0 3
43730: PUSH
43731: LD_VAR 0 4
43735: PUSH
43736: FOR_IN
43737: IFFALSE 43889
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
43739: LD_VAR 0 3
43743: PPUSH
43744: CALL_OW 110
43748: NOT
43749: PUSH
43750: LD_VAR 0 3
43754: PPUSH
43755: CALL_OW 314
43759: NOT
43760: AND
43761: PUSH
43762: LD_VAR 0 3
43766: PPUSH
43767: CALL_OW 311
43771: NOT
43772: AND
43773: PUSH
43774: LD_VAR 0 3
43778: PPUSH
43779: CALL_OW 310
43783: NOT
43784: AND
43785: PUSH
43786: LD_VAR 0 3
43790: PUSH
43791: LD_EXP 90
43795: PUSH
43796: LD_VAR 0 2
43800: ARRAY
43801: PUSH
43802: LD_INT 1
43804: ARRAY
43805: IN
43806: NOT
43807: AND
43808: PUSH
43809: LD_VAR 0 3
43813: PUSH
43814: LD_EXP 90
43818: PUSH
43819: LD_VAR 0 2
43823: ARRAY
43824: PUSH
43825: LD_INT 2
43827: ARRAY
43828: IN
43829: NOT
43830: AND
43831: PUSH
43832: LD_VAR 0 3
43836: PUSH
43837: LD_EXP 99
43841: PUSH
43842: LD_VAR 0 2
43846: ARRAY
43847: IN
43848: NOT
43849: AND
43850: IFFALSE 43887
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
43852: LD_VAR 0 2
43856: PPUSH
43857: LD_EXP 87
43861: PUSH
43862: LD_VAR 0 2
43866: ARRAY
43867: PPUSH
43868: LD_VAR 0 3
43872: PPUSH
43873: LD_VAR 0 3
43877: PPUSH
43878: CALL_OW 257
43882: PPUSH
43883: CALL 42659 0 4
// end ;
43887: GO 43736
43889: POP
43890: POP
// end ;
43891: GO 43671
43893: POP
43894: POP
// end ;
43895: LD_VAR 0 1
43899: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
43900: LD_INT 0
43902: PPUSH
43903: PPUSH
43904: PPUSH
43905: PPUSH
43906: PPUSH
43907: PPUSH
// if not mc_bases [ base ] then
43908: LD_EXP 87
43912: PUSH
43913: LD_VAR 0 1
43917: ARRAY
43918: NOT
43919: IFFALSE 43923
// exit ;
43921: GO 44105
// tmp := [ ] ;
43923: LD_ADDR_VAR 0 6
43927: PUSH
43928: EMPTY
43929: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
43930: LD_ADDR_VAR 0 7
43934: PUSH
43935: LD_VAR 0 3
43939: PPUSH
43940: LD_INT 0
43942: PPUSH
43943: CALL_OW 517
43947: ST_TO_ADDR
// if not list then
43948: LD_VAR 0 7
43952: NOT
43953: IFFALSE 43957
// exit ;
43955: GO 44105
// for i = 1 to amount do
43957: LD_ADDR_VAR 0 5
43961: PUSH
43962: DOUBLE
43963: LD_INT 1
43965: DEC
43966: ST_TO_ADDR
43967: LD_VAR 0 2
43971: PUSH
43972: FOR_TO
43973: IFFALSE 44053
// begin x := rand ( 1 , list [ 1 ] ) ;
43975: LD_ADDR_VAR 0 8
43979: PUSH
43980: LD_INT 1
43982: PPUSH
43983: LD_VAR 0 7
43987: PUSH
43988: LD_INT 1
43990: ARRAY
43991: PPUSH
43992: CALL_OW 12
43996: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
43997: LD_ADDR_VAR 0 6
44001: PUSH
44002: LD_VAR 0 6
44006: PPUSH
44007: LD_VAR 0 5
44011: PPUSH
44012: LD_VAR 0 7
44016: PUSH
44017: LD_INT 1
44019: ARRAY
44020: PUSH
44021: LD_VAR 0 8
44025: ARRAY
44026: PUSH
44027: LD_VAR 0 7
44031: PUSH
44032: LD_INT 2
44034: ARRAY
44035: PUSH
44036: LD_VAR 0 8
44040: ARRAY
44041: PUSH
44042: EMPTY
44043: LIST
44044: LIST
44045: PPUSH
44046: CALL_OW 1
44050: ST_TO_ADDR
// end ;
44051: GO 43972
44053: POP
44054: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
44055: LD_ADDR_EXP 100
44059: PUSH
44060: LD_EXP 100
44064: PPUSH
44065: LD_VAR 0 1
44069: PPUSH
44070: LD_VAR 0 6
44074: PPUSH
44075: CALL_OW 1
44079: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
44080: LD_ADDR_EXP 102
44084: PUSH
44085: LD_EXP 102
44089: PPUSH
44090: LD_VAR 0 1
44094: PPUSH
44095: LD_VAR 0 3
44099: PPUSH
44100: CALL_OW 1
44104: ST_TO_ADDR
// end ;
44105: LD_VAR 0 4
44109: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
44110: LD_INT 0
44112: PPUSH
// if not mc_bases [ base ] then
44113: LD_EXP 87
44117: PUSH
44118: LD_VAR 0 1
44122: ARRAY
44123: NOT
44124: IFFALSE 44128
// exit ;
44126: GO 44153
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
44128: LD_ADDR_EXP 92
44132: PUSH
44133: LD_EXP 92
44137: PPUSH
44138: LD_VAR 0 1
44142: PPUSH
44143: LD_VAR 0 2
44147: PPUSH
44148: CALL_OW 1
44152: ST_TO_ADDR
// end ;
44153: LD_VAR 0 3
44157: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
44158: LD_INT 0
44160: PPUSH
// if not mc_bases [ base ] then
44161: LD_EXP 87
44165: PUSH
44166: LD_VAR 0 1
44170: ARRAY
44171: NOT
44172: IFFALSE 44176
// exit ;
44174: GO 44213
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
44176: LD_ADDR_EXP 92
44180: PUSH
44181: LD_EXP 92
44185: PPUSH
44186: LD_VAR 0 1
44190: PPUSH
44191: LD_EXP 92
44195: PUSH
44196: LD_VAR 0 1
44200: ARRAY
44201: PUSH
44202: LD_VAR 0 2
44206: UNION
44207: PPUSH
44208: CALL_OW 1
44212: ST_TO_ADDR
// end ;
44213: LD_VAR 0 3
44217: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
44218: LD_INT 0
44220: PPUSH
// if not mc_bases [ base ] then
44221: LD_EXP 87
44225: PUSH
44226: LD_VAR 0 1
44230: ARRAY
44231: NOT
44232: IFFALSE 44236
// exit ;
44234: GO 44261
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
44236: LD_ADDR_EXP 108
44240: PUSH
44241: LD_EXP 108
44245: PPUSH
44246: LD_VAR 0 1
44250: PPUSH
44251: LD_VAR 0 2
44255: PPUSH
44256: CALL_OW 1
44260: ST_TO_ADDR
// end ;
44261: LD_VAR 0 3
44265: RET
// export function MC_InsertProduceList ( base , components ) ; begin
44266: LD_INT 0
44268: PPUSH
// if not mc_bases [ base ] then
44269: LD_EXP 87
44273: PUSH
44274: LD_VAR 0 1
44278: ARRAY
44279: NOT
44280: IFFALSE 44284
// exit ;
44282: GO 44321
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
44284: LD_ADDR_EXP 108
44288: PUSH
44289: LD_EXP 108
44293: PPUSH
44294: LD_VAR 0 1
44298: PPUSH
44299: LD_EXP 108
44303: PUSH
44304: LD_VAR 0 1
44308: ARRAY
44309: PUSH
44310: LD_VAR 0 2
44314: ADD
44315: PPUSH
44316: CALL_OW 1
44320: ST_TO_ADDR
// end ;
44321: LD_VAR 0 3
44325: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
44326: LD_INT 0
44328: PPUSH
// if not mc_bases [ base ] then
44329: LD_EXP 87
44333: PUSH
44334: LD_VAR 0 1
44338: ARRAY
44339: NOT
44340: IFFALSE 44344
// exit ;
44342: GO 44398
// mc_defender := Replace ( mc_defender , base , deflist ) ;
44344: LD_ADDR_EXP 109
44348: PUSH
44349: LD_EXP 109
44353: PPUSH
44354: LD_VAR 0 1
44358: PPUSH
44359: LD_VAR 0 2
44363: PPUSH
44364: CALL_OW 1
44368: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
44369: LD_ADDR_EXP 98
44373: PUSH
44374: LD_EXP 98
44378: PPUSH
44379: LD_VAR 0 1
44383: PPUSH
44384: LD_VAR 0 2
44388: PUSH
44389: LD_INT 0
44391: PLUS
44392: PPUSH
44393: CALL_OW 1
44397: ST_TO_ADDR
// end ;
44398: LD_VAR 0 3
44402: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
44403: LD_INT 0
44405: PPUSH
// if not mc_bases [ base ] then
44406: LD_EXP 87
44410: PUSH
44411: LD_VAR 0 1
44415: ARRAY
44416: NOT
44417: IFFALSE 44421
// exit ;
44419: GO 44446
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
44421: LD_ADDR_EXP 98
44425: PUSH
44426: LD_EXP 98
44430: PPUSH
44431: LD_VAR 0 1
44435: PPUSH
44436: LD_VAR 0 2
44440: PPUSH
44441: CALL_OW 1
44445: ST_TO_ADDR
// end ;
44446: LD_VAR 0 3
44450: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
44451: LD_INT 0
44453: PPUSH
44454: PPUSH
44455: PPUSH
44456: PPUSH
// if not mc_bases [ base ] then
44457: LD_EXP 87
44461: PUSH
44462: LD_VAR 0 1
44466: ARRAY
44467: NOT
44468: IFFALSE 44472
// exit ;
44470: GO 44537
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
44472: LD_ADDR_EXP 107
44476: PUSH
44477: LD_EXP 107
44481: PPUSH
44482: LD_VAR 0 1
44486: PUSH
44487: LD_EXP 107
44491: PUSH
44492: LD_VAR 0 1
44496: ARRAY
44497: PUSH
44498: LD_INT 1
44500: PLUS
44501: PUSH
44502: EMPTY
44503: LIST
44504: LIST
44505: PPUSH
44506: LD_VAR 0 1
44510: PUSH
44511: LD_VAR 0 2
44515: PUSH
44516: LD_VAR 0 3
44520: PUSH
44521: LD_VAR 0 4
44525: PUSH
44526: EMPTY
44527: LIST
44528: LIST
44529: LIST
44530: LIST
44531: PPUSH
44532: CALL 57967 0 3
44536: ST_TO_ADDR
// end ;
44537: LD_VAR 0 5
44541: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
44542: LD_INT 0
44544: PPUSH
// if not mc_bases [ base ] then
44545: LD_EXP 87
44549: PUSH
44550: LD_VAR 0 1
44554: ARRAY
44555: NOT
44556: IFFALSE 44560
// exit ;
44558: GO 44585
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
44560: LD_ADDR_EXP 124
44564: PUSH
44565: LD_EXP 124
44569: PPUSH
44570: LD_VAR 0 1
44574: PPUSH
44575: LD_VAR 0 2
44579: PPUSH
44580: CALL_OW 1
44584: ST_TO_ADDR
// end ;
44585: LD_VAR 0 3
44589: RET
// export function MC_GetMinesField ( base ) ; begin
44590: LD_INT 0
44592: PPUSH
// result := mc_mines [ base ] ;
44593: LD_ADDR_VAR 0 2
44597: PUSH
44598: LD_EXP 100
44602: PUSH
44603: LD_VAR 0 1
44607: ARRAY
44608: ST_TO_ADDR
// end ;
44609: LD_VAR 0 2
44613: RET
// export function MC_GetProduceList ( base ) ; begin
44614: LD_INT 0
44616: PPUSH
// result := mc_produce [ base ] ;
44617: LD_ADDR_VAR 0 2
44621: PUSH
44622: LD_EXP 108
44626: PUSH
44627: LD_VAR 0 1
44631: ARRAY
44632: ST_TO_ADDR
// end ;
44633: LD_VAR 0 2
44637: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
44638: LD_INT 0
44640: PPUSH
44641: PPUSH
// if not mc_bases then
44642: LD_EXP 87
44646: NOT
44647: IFFALSE 44651
// exit ;
44649: GO 44716
// if mc_bases [ base ] then
44651: LD_EXP 87
44655: PUSH
44656: LD_VAR 0 1
44660: ARRAY
44661: IFFALSE 44716
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44663: LD_ADDR_VAR 0 3
44667: PUSH
44668: LD_EXP 87
44672: PUSH
44673: LD_VAR 0 1
44677: ARRAY
44678: PPUSH
44679: LD_INT 30
44681: PUSH
44682: LD_VAR 0 2
44686: PUSH
44687: EMPTY
44688: LIST
44689: LIST
44690: PPUSH
44691: CALL_OW 72
44695: ST_TO_ADDR
// if result then
44696: LD_VAR 0 3
44700: IFFALSE 44716
// result := result [ 1 ] ;
44702: LD_ADDR_VAR 0 3
44706: PUSH
44707: LD_VAR 0 3
44711: PUSH
44712: LD_INT 1
44714: ARRAY
44715: ST_TO_ADDR
// end ; end ;
44716: LD_VAR 0 3
44720: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
44721: LD_INT 0
44723: PPUSH
44724: PPUSH
// if not mc_bases then
44725: LD_EXP 87
44729: NOT
44730: IFFALSE 44734
// exit ;
44732: GO 44779
// if mc_bases [ base ] then
44734: LD_EXP 87
44738: PUSH
44739: LD_VAR 0 1
44743: ARRAY
44744: IFFALSE 44779
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44746: LD_ADDR_VAR 0 3
44750: PUSH
44751: LD_EXP 87
44755: PUSH
44756: LD_VAR 0 1
44760: ARRAY
44761: PPUSH
44762: LD_INT 30
44764: PUSH
44765: LD_VAR 0 2
44769: PUSH
44770: EMPTY
44771: LIST
44772: LIST
44773: PPUSH
44774: CALL_OW 72
44778: ST_TO_ADDR
// end ;
44779: LD_VAR 0 3
44783: RET
// export function MC_SetTame ( base , area ) ; begin
44784: LD_INT 0
44786: PPUSH
// if not mc_bases or not base then
44787: LD_EXP 87
44791: NOT
44792: PUSH
44793: LD_VAR 0 1
44797: NOT
44798: OR
44799: IFFALSE 44803
// exit ;
44801: GO 44828
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
44803: LD_ADDR_EXP 115
44807: PUSH
44808: LD_EXP 115
44812: PPUSH
44813: LD_VAR 0 1
44817: PPUSH
44818: LD_VAR 0 2
44822: PPUSH
44823: CALL_OW 1
44827: ST_TO_ADDR
// end ;
44828: LD_VAR 0 3
44832: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
44833: LD_INT 0
44835: PPUSH
44836: PPUSH
// if not mc_bases or not base then
44837: LD_EXP 87
44841: NOT
44842: PUSH
44843: LD_VAR 0 1
44847: NOT
44848: OR
44849: IFFALSE 44853
// exit ;
44851: GO 44955
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44853: LD_ADDR_VAR 0 4
44857: PUSH
44858: LD_EXP 87
44862: PUSH
44863: LD_VAR 0 1
44867: ARRAY
44868: PPUSH
44869: LD_INT 30
44871: PUSH
44872: LD_VAR 0 2
44876: PUSH
44877: EMPTY
44878: LIST
44879: LIST
44880: PPUSH
44881: CALL_OW 72
44885: ST_TO_ADDR
// if not tmp then
44886: LD_VAR 0 4
44890: NOT
44891: IFFALSE 44895
// exit ;
44893: GO 44955
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
44895: LD_ADDR_EXP 119
44899: PUSH
44900: LD_EXP 119
44904: PPUSH
44905: LD_VAR 0 1
44909: PPUSH
44910: LD_EXP 119
44914: PUSH
44915: LD_VAR 0 1
44919: ARRAY
44920: PPUSH
44921: LD_EXP 119
44925: PUSH
44926: LD_VAR 0 1
44930: ARRAY
44931: PUSH
44932: LD_INT 1
44934: PLUS
44935: PPUSH
44936: LD_VAR 0 4
44940: PUSH
44941: LD_INT 1
44943: ARRAY
44944: PPUSH
44945: CALL_OW 2
44949: PPUSH
44950: CALL_OW 1
44954: ST_TO_ADDR
// end ;
44955: LD_VAR 0 3
44959: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
44960: LD_INT 0
44962: PPUSH
44963: PPUSH
// if not mc_bases or not base or not kinds then
44964: LD_EXP 87
44968: NOT
44969: PUSH
44970: LD_VAR 0 1
44974: NOT
44975: OR
44976: PUSH
44977: LD_VAR 0 2
44981: NOT
44982: OR
44983: IFFALSE 44987
// exit ;
44985: GO 45048
// for i in kinds do
44987: LD_ADDR_VAR 0 4
44991: PUSH
44992: LD_VAR 0 2
44996: PUSH
44997: FOR_IN
44998: IFFALSE 45046
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
45000: LD_ADDR_EXP 121
45004: PUSH
45005: LD_EXP 121
45009: PPUSH
45010: LD_VAR 0 1
45014: PUSH
45015: LD_EXP 121
45019: PUSH
45020: LD_VAR 0 1
45024: ARRAY
45025: PUSH
45026: LD_INT 1
45028: PLUS
45029: PUSH
45030: EMPTY
45031: LIST
45032: LIST
45033: PPUSH
45034: LD_VAR 0 4
45038: PPUSH
45039: CALL 57967 0 3
45043: ST_TO_ADDR
45044: GO 44997
45046: POP
45047: POP
// end ;
45048: LD_VAR 0 3
45052: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
45053: LD_INT 0
45055: PPUSH
// if not mc_bases or not base or not areas then
45056: LD_EXP 87
45060: NOT
45061: PUSH
45062: LD_VAR 0 1
45066: NOT
45067: OR
45068: PUSH
45069: LD_VAR 0 2
45073: NOT
45074: OR
45075: IFFALSE 45079
// exit ;
45077: GO 45104
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
45079: LD_ADDR_EXP 105
45083: PUSH
45084: LD_EXP 105
45088: PPUSH
45089: LD_VAR 0 1
45093: PPUSH
45094: LD_VAR 0 2
45098: PPUSH
45099: CALL_OW 1
45103: ST_TO_ADDR
// end ;
45104: LD_VAR 0 3
45108: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
45109: LD_INT 0
45111: PPUSH
// if not mc_bases or not base or not teleports_exit then
45112: LD_EXP 87
45116: NOT
45117: PUSH
45118: LD_VAR 0 1
45122: NOT
45123: OR
45124: PUSH
45125: LD_VAR 0 2
45129: NOT
45130: OR
45131: IFFALSE 45135
// exit ;
45133: GO 45160
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
45135: LD_ADDR_EXP 122
45139: PUSH
45140: LD_EXP 122
45144: PPUSH
45145: LD_VAR 0 1
45149: PPUSH
45150: LD_VAR 0 2
45154: PPUSH
45155: CALL_OW 1
45159: ST_TO_ADDR
// end ;
45160: LD_VAR 0 3
45164: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
45165: LD_INT 0
45167: PPUSH
45168: PPUSH
45169: PPUSH
// if not mc_bases or not base or not ext_list then
45170: LD_EXP 87
45174: NOT
45175: PUSH
45176: LD_VAR 0 1
45180: NOT
45181: OR
45182: PUSH
45183: LD_VAR 0 5
45187: NOT
45188: OR
45189: IFFALSE 45193
// exit ;
45191: GO 45366
// tmp := GetFacExtXYD ( x , y , d ) ;
45193: LD_ADDR_VAR 0 8
45197: PUSH
45198: LD_VAR 0 2
45202: PPUSH
45203: LD_VAR 0 3
45207: PPUSH
45208: LD_VAR 0 4
45212: PPUSH
45213: CALL 91355 0 3
45217: ST_TO_ADDR
// if not tmp then
45218: LD_VAR 0 8
45222: NOT
45223: IFFALSE 45227
// exit ;
45225: GO 45366
// for i in tmp do
45227: LD_ADDR_VAR 0 7
45231: PUSH
45232: LD_VAR 0 8
45236: PUSH
45237: FOR_IN
45238: IFFALSE 45364
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
45240: LD_ADDR_EXP 92
45244: PUSH
45245: LD_EXP 92
45249: PPUSH
45250: LD_VAR 0 1
45254: PPUSH
45255: LD_EXP 92
45259: PUSH
45260: LD_VAR 0 1
45264: ARRAY
45265: PPUSH
45266: LD_EXP 92
45270: PUSH
45271: LD_VAR 0 1
45275: ARRAY
45276: PUSH
45277: LD_INT 1
45279: PLUS
45280: PPUSH
45281: LD_VAR 0 5
45285: PUSH
45286: LD_INT 1
45288: ARRAY
45289: PUSH
45290: LD_VAR 0 7
45294: PUSH
45295: LD_INT 1
45297: ARRAY
45298: PUSH
45299: LD_VAR 0 7
45303: PUSH
45304: LD_INT 2
45306: ARRAY
45307: PUSH
45308: LD_VAR 0 7
45312: PUSH
45313: LD_INT 3
45315: ARRAY
45316: PUSH
45317: EMPTY
45318: LIST
45319: LIST
45320: LIST
45321: LIST
45322: PPUSH
45323: CALL_OW 2
45327: PPUSH
45328: CALL_OW 1
45332: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
45333: LD_ADDR_VAR 0 5
45337: PUSH
45338: LD_VAR 0 5
45342: PPUSH
45343: LD_INT 1
45345: PPUSH
45346: CALL_OW 3
45350: ST_TO_ADDR
// if not ext_list then
45351: LD_VAR 0 5
45355: NOT
45356: IFFALSE 45362
// exit ;
45358: POP
45359: POP
45360: GO 45366
// end ;
45362: GO 45237
45364: POP
45365: POP
// end ;
45366: LD_VAR 0 6
45370: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
45371: LD_INT 0
45373: PPUSH
// if not mc_bases or not base or not weapon_list then
45374: LD_EXP 87
45378: NOT
45379: PUSH
45380: LD_VAR 0 1
45384: NOT
45385: OR
45386: PUSH
45387: LD_VAR 0 2
45391: NOT
45392: OR
45393: IFFALSE 45397
// exit ;
45395: GO 45422
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
45397: LD_ADDR_EXP 126
45401: PUSH
45402: LD_EXP 126
45406: PPUSH
45407: LD_VAR 0 1
45411: PPUSH
45412: LD_VAR 0 2
45416: PPUSH
45417: CALL_OW 1
45421: ST_TO_ADDR
// end ;
45422: LD_VAR 0 3
45426: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
45427: LD_INT 0
45429: PPUSH
// if not mc_bases or not base or not tech_list then
45430: LD_EXP 87
45434: NOT
45435: PUSH
45436: LD_VAR 0 1
45440: NOT
45441: OR
45442: PUSH
45443: LD_VAR 0 2
45447: NOT
45448: OR
45449: IFFALSE 45453
// exit ;
45451: GO 45478
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
45453: LD_ADDR_EXP 114
45457: PUSH
45458: LD_EXP 114
45462: PPUSH
45463: LD_VAR 0 1
45467: PPUSH
45468: LD_VAR 0 2
45472: PPUSH
45473: CALL_OW 1
45477: ST_TO_ADDR
// end ;
45478: LD_VAR 0 3
45482: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
45483: LD_INT 0
45485: PPUSH
// if not mc_bases or not parking_area or not base then
45486: LD_EXP 87
45490: NOT
45491: PUSH
45492: LD_VAR 0 2
45496: NOT
45497: OR
45498: PUSH
45499: LD_VAR 0 1
45503: NOT
45504: OR
45505: IFFALSE 45509
// exit ;
45507: GO 45534
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
45509: LD_ADDR_EXP 111
45513: PUSH
45514: LD_EXP 111
45518: PPUSH
45519: LD_VAR 0 1
45523: PPUSH
45524: LD_VAR 0 2
45528: PPUSH
45529: CALL_OW 1
45533: ST_TO_ADDR
// end ;
45534: LD_VAR 0 3
45538: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
45539: LD_INT 0
45541: PPUSH
// if not mc_bases or not base or not scan_area then
45542: LD_EXP 87
45546: NOT
45547: PUSH
45548: LD_VAR 0 1
45552: NOT
45553: OR
45554: PUSH
45555: LD_VAR 0 2
45559: NOT
45560: OR
45561: IFFALSE 45565
// exit ;
45563: GO 45590
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
45565: LD_ADDR_EXP 112
45569: PUSH
45570: LD_EXP 112
45574: PPUSH
45575: LD_VAR 0 1
45579: PPUSH
45580: LD_VAR 0 2
45584: PPUSH
45585: CALL_OW 1
45589: ST_TO_ADDR
// end ;
45590: LD_VAR 0 3
45594: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
45595: LD_INT 0
45597: PPUSH
45598: PPUSH
// if not mc_bases or not base then
45599: LD_EXP 87
45603: NOT
45604: PUSH
45605: LD_VAR 0 1
45609: NOT
45610: OR
45611: IFFALSE 45615
// exit ;
45613: GO 45679
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
45615: LD_ADDR_VAR 0 3
45619: PUSH
45620: LD_INT 1
45622: PUSH
45623: LD_INT 2
45625: PUSH
45626: LD_INT 3
45628: PUSH
45629: LD_INT 4
45631: PUSH
45632: LD_INT 11
45634: PUSH
45635: EMPTY
45636: LIST
45637: LIST
45638: LIST
45639: LIST
45640: LIST
45641: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
45642: LD_ADDR_EXP 114
45646: PUSH
45647: LD_EXP 114
45651: PPUSH
45652: LD_VAR 0 1
45656: PPUSH
45657: LD_EXP 114
45661: PUSH
45662: LD_VAR 0 1
45666: ARRAY
45667: PUSH
45668: LD_VAR 0 3
45672: DIFF
45673: PPUSH
45674: CALL_OW 1
45678: ST_TO_ADDR
// end ;
45679: LD_VAR 0 2
45683: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
45684: LD_INT 0
45686: PPUSH
// result := mc_vehicles [ base ] ;
45687: LD_ADDR_VAR 0 3
45691: PUSH
45692: LD_EXP 106
45696: PUSH
45697: LD_VAR 0 1
45701: ARRAY
45702: ST_TO_ADDR
// if onlyCombat then
45703: LD_VAR 0 2
45707: IFFALSE 45872
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
45709: LD_ADDR_VAR 0 3
45713: PUSH
45714: LD_VAR 0 3
45718: PUSH
45719: LD_VAR 0 3
45723: PPUSH
45724: LD_INT 2
45726: PUSH
45727: LD_INT 34
45729: PUSH
45730: LD_INT 12
45732: PUSH
45733: EMPTY
45734: LIST
45735: LIST
45736: PUSH
45737: LD_INT 34
45739: PUSH
45740: LD_INT 51
45742: PUSH
45743: EMPTY
45744: LIST
45745: LIST
45746: PUSH
45747: LD_INT 34
45749: PUSH
45750: LD_EXP 73
45754: PUSH
45755: EMPTY
45756: LIST
45757: LIST
45758: PUSH
45759: LD_INT 34
45761: PUSH
45762: LD_INT 32
45764: PUSH
45765: EMPTY
45766: LIST
45767: LIST
45768: PUSH
45769: LD_INT 34
45771: PUSH
45772: LD_INT 13
45774: PUSH
45775: EMPTY
45776: LIST
45777: LIST
45778: PUSH
45779: LD_INT 34
45781: PUSH
45782: LD_INT 52
45784: PUSH
45785: EMPTY
45786: LIST
45787: LIST
45788: PUSH
45789: LD_INT 34
45791: PUSH
45792: LD_INT 14
45794: PUSH
45795: EMPTY
45796: LIST
45797: LIST
45798: PUSH
45799: LD_INT 34
45801: PUSH
45802: LD_INT 53
45804: PUSH
45805: EMPTY
45806: LIST
45807: LIST
45808: PUSH
45809: LD_INT 34
45811: PUSH
45812: LD_EXP 72
45816: PUSH
45817: EMPTY
45818: LIST
45819: LIST
45820: PUSH
45821: LD_INT 34
45823: PUSH
45824: LD_INT 31
45826: PUSH
45827: EMPTY
45828: LIST
45829: LIST
45830: PUSH
45831: LD_INT 34
45833: PUSH
45834: LD_INT 48
45836: PUSH
45837: EMPTY
45838: LIST
45839: LIST
45840: PUSH
45841: LD_INT 34
45843: PUSH
45844: LD_INT 8
45846: PUSH
45847: EMPTY
45848: LIST
45849: LIST
45850: PUSH
45851: EMPTY
45852: LIST
45853: LIST
45854: LIST
45855: LIST
45856: LIST
45857: LIST
45858: LIST
45859: LIST
45860: LIST
45861: LIST
45862: LIST
45863: LIST
45864: LIST
45865: PPUSH
45866: CALL_OW 72
45870: DIFF
45871: ST_TO_ADDR
// end ; end_of_file
45872: LD_VAR 0 3
45876: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
45877: LD_INT 0
45879: PPUSH
45880: PPUSH
45881: PPUSH
// if not mc_bases or not skirmish then
45882: LD_EXP 87
45886: NOT
45887: PUSH
45888: LD_EXP 85
45892: NOT
45893: OR
45894: IFFALSE 45898
// exit ;
45896: GO 46063
// for i = 1 to mc_bases do
45898: LD_ADDR_VAR 0 4
45902: PUSH
45903: DOUBLE
45904: LD_INT 1
45906: DEC
45907: ST_TO_ADDR
45908: LD_EXP 87
45912: PUSH
45913: FOR_TO
45914: IFFALSE 46061
// begin if sci in mc_bases [ i ] then
45916: LD_VAR 0 2
45920: PUSH
45921: LD_EXP 87
45925: PUSH
45926: LD_VAR 0 4
45930: ARRAY
45931: IN
45932: IFFALSE 46059
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
45934: LD_ADDR_EXP 116
45938: PUSH
45939: LD_EXP 116
45943: PPUSH
45944: LD_VAR 0 4
45948: PUSH
45949: LD_EXP 116
45953: PUSH
45954: LD_VAR 0 4
45958: ARRAY
45959: PUSH
45960: LD_INT 1
45962: PLUS
45963: PUSH
45964: EMPTY
45965: LIST
45966: LIST
45967: PPUSH
45968: LD_VAR 0 1
45972: PPUSH
45973: CALL 57967 0 3
45977: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
45978: LD_ADDR_VAR 0 5
45982: PUSH
45983: LD_EXP 87
45987: PUSH
45988: LD_VAR 0 4
45992: ARRAY
45993: PPUSH
45994: LD_INT 2
45996: PUSH
45997: LD_INT 30
45999: PUSH
46000: LD_INT 0
46002: PUSH
46003: EMPTY
46004: LIST
46005: LIST
46006: PUSH
46007: LD_INT 30
46009: PUSH
46010: LD_INT 1
46012: PUSH
46013: EMPTY
46014: LIST
46015: LIST
46016: PUSH
46017: EMPTY
46018: LIST
46019: LIST
46020: LIST
46021: PPUSH
46022: CALL_OW 72
46026: PPUSH
46027: LD_VAR 0 1
46031: PPUSH
46032: CALL_OW 74
46036: ST_TO_ADDR
// if tmp then
46037: LD_VAR 0 5
46041: IFFALSE 46057
// ComStandNearbyBuilding ( ape , tmp ) ;
46043: LD_VAR 0 1
46047: PPUSH
46048: LD_VAR 0 5
46052: PPUSH
46053: CALL 52170 0 2
// break ;
46057: GO 46061
// end ; end ;
46059: GO 45913
46061: POP
46062: POP
// end ;
46063: LD_VAR 0 3
46067: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
46068: LD_INT 0
46070: PPUSH
46071: PPUSH
46072: PPUSH
// if not mc_bases or not skirmish then
46073: LD_EXP 87
46077: NOT
46078: PUSH
46079: LD_EXP 85
46083: NOT
46084: OR
46085: IFFALSE 46089
// exit ;
46087: GO 46178
// for i = 1 to mc_bases do
46089: LD_ADDR_VAR 0 4
46093: PUSH
46094: DOUBLE
46095: LD_INT 1
46097: DEC
46098: ST_TO_ADDR
46099: LD_EXP 87
46103: PUSH
46104: FOR_TO
46105: IFFALSE 46176
// begin if building in mc_busy_turret_list [ i ] then
46107: LD_VAR 0 1
46111: PUSH
46112: LD_EXP 97
46116: PUSH
46117: LD_VAR 0 4
46121: ARRAY
46122: IN
46123: IFFALSE 46174
// begin tmp := mc_busy_turret_list [ i ] diff building ;
46125: LD_ADDR_VAR 0 5
46129: PUSH
46130: LD_EXP 97
46134: PUSH
46135: LD_VAR 0 4
46139: ARRAY
46140: PUSH
46141: LD_VAR 0 1
46145: DIFF
46146: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
46147: LD_ADDR_EXP 97
46151: PUSH
46152: LD_EXP 97
46156: PPUSH
46157: LD_VAR 0 4
46161: PPUSH
46162: LD_VAR 0 5
46166: PPUSH
46167: CALL_OW 1
46171: ST_TO_ADDR
// break ;
46172: GO 46176
// end ; end ;
46174: GO 46104
46176: POP
46177: POP
// end ;
46178: LD_VAR 0 3
46182: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
46183: LD_INT 0
46185: PPUSH
46186: PPUSH
46187: PPUSH
// if not mc_bases or not skirmish then
46188: LD_EXP 87
46192: NOT
46193: PUSH
46194: LD_EXP 85
46198: NOT
46199: OR
46200: IFFALSE 46204
// exit ;
46202: GO 46403
// for i = 1 to mc_bases do
46204: LD_ADDR_VAR 0 5
46208: PUSH
46209: DOUBLE
46210: LD_INT 1
46212: DEC
46213: ST_TO_ADDR
46214: LD_EXP 87
46218: PUSH
46219: FOR_TO
46220: IFFALSE 46401
// if building in mc_bases [ i ] then
46222: LD_VAR 0 1
46226: PUSH
46227: LD_EXP 87
46231: PUSH
46232: LD_VAR 0 5
46236: ARRAY
46237: IN
46238: IFFALSE 46399
// begin tmp := mc_bases [ i ] diff building ;
46240: LD_ADDR_VAR 0 6
46244: PUSH
46245: LD_EXP 87
46249: PUSH
46250: LD_VAR 0 5
46254: ARRAY
46255: PUSH
46256: LD_VAR 0 1
46260: DIFF
46261: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
46262: LD_ADDR_EXP 87
46266: PUSH
46267: LD_EXP 87
46271: PPUSH
46272: LD_VAR 0 5
46276: PPUSH
46277: LD_VAR 0 6
46281: PPUSH
46282: CALL_OW 1
46286: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
46287: LD_VAR 0 1
46291: PUSH
46292: LD_EXP 95
46296: PUSH
46297: LD_VAR 0 5
46301: ARRAY
46302: IN
46303: IFFALSE 46342
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
46305: LD_ADDR_EXP 95
46309: PUSH
46310: LD_EXP 95
46314: PPUSH
46315: LD_VAR 0 5
46319: PPUSH
46320: LD_EXP 95
46324: PUSH
46325: LD_VAR 0 5
46329: ARRAY
46330: PUSH
46331: LD_VAR 0 1
46335: DIFF
46336: PPUSH
46337: CALL_OW 1
46341: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
46342: LD_VAR 0 1
46346: PUSH
46347: LD_EXP 96
46351: PUSH
46352: LD_VAR 0 5
46356: ARRAY
46357: IN
46358: IFFALSE 46397
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
46360: LD_ADDR_EXP 96
46364: PUSH
46365: LD_EXP 96
46369: PPUSH
46370: LD_VAR 0 5
46374: PPUSH
46375: LD_EXP 96
46379: PUSH
46380: LD_VAR 0 5
46384: ARRAY
46385: PUSH
46386: LD_VAR 0 1
46390: DIFF
46391: PPUSH
46392: CALL_OW 1
46396: ST_TO_ADDR
// break ;
46397: GO 46401
// end ;
46399: GO 46219
46401: POP
46402: POP
// end ;
46403: LD_VAR 0 4
46407: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
46408: LD_INT 0
46410: PPUSH
46411: PPUSH
46412: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
46413: LD_EXP 87
46417: NOT
46418: PUSH
46419: LD_EXP 85
46423: NOT
46424: OR
46425: PUSH
46426: LD_VAR 0 3
46430: PUSH
46431: LD_EXP 113
46435: IN
46436: NOT
46437: OR
46438: IFFALSE 46442
// exit ;
46440: GO 46565
// for i = 1 to mc_vehicles do
46442: LD_ADDR_VAR 0 6
46446: PUSH
46447: DOUBLE
46448: LD_INT 1
46450: DEC
46451: ST_TO_ADDR
46452: LD_EXP 106
46456: PUSH
46457: FOR_TO
46458: IFFALSE 46563
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
46460: LD_VAR 0 2
46464: PUSH
46465: LD_EXP 106
46469: PUSH
46470: LD_VAR 0 6
46474: ARRAY
46475: IN
46476: PUSH
46477: LD_VAR 0 1
46481: PUSH
46482: LD_EXP 106
46486: PUSH
46487: LD_VAR 0 6
46491: ARRAY
46492: IN
46493: OR
46494: IFFALSE 46561
// begin tmp := mc_vehicles [ i ] diff old ;
46496: LD_ADDR_VAR 0 7
46500: PUSH
46501: LD_EXP 106
46505: PUSH
46506: LD_VAR 0 6
46510: ARRAY
46511: PUSH
46512: LD_VAR 0 2
46516: DIFF
46517: ST_TO_ADDR
// tmp := tmp diff new ;
46518: LD_ADDR_VAR 0 7
46522: PUSH
46523: LD_VAR 0 7
46527: PUSH
46528: LD_VAR 0 1
46532: DIFF
46533: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
46534: LD_ADDR_EXP 106
46538: PUSH
46539: LD_EXP 106
46543: PPUSH
46544: LD_VAR 0 6
46548: PPUSH
46549: LD_VAR 0 7
46553: PPUSH
46554: CALL_OW 1
46558: ST_TO_ADDR
// break ;
46559: GO 46563
// end ;
46561: GO 46457
46563: POP
46564: POP
// end ;
46565: LD_VAR 0 5
46569: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
46570: LD_INT 0
46572: PPUSH
46573: PPUSH
46574: PPUSH
46575: PPUSH
// if not mc_bases or not skirmish then
46576: LD_EXP 87
46580: NOT
46581: PUSH
46582: LD_EXP 85
46586: NOT
46587: OR
46588: IFFALSE 46592
// exit ;
46590: GO 46969
// side := GetSide ( vehicle ) ;
46592: LD_ADDR_VAR 0 5
46596: PUSH
46597: LD_VAR 0 1
46601: PPUSH
46602: CALL_OW 255
46606: ST_TO_ADDR
// for i = 1 to mc_bases do
46607: LD_ADDR_VAR 0 4
46611: PUSH
46612: DOUBLE
46613: LD_INT 1
46615: DEC
46616: ST_TO_ADDR
46617: LD_EXP 87
46621: PUSH
46622: FOR_TO
46623: IFFALSE 46967
// begin if factory in mc_bases [ i ] then
46625: LD_VAR 0 2
46629: PUSH
46630: LD_EXP 87
46634: PUSH
46635: LD_VAR 0 4
46639: ARRAY
46640: IN
46641: IFFALSE 46965
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
46643: LD_EXP 109
46647: PUSH
46648: LD_VAR 0 4
46652: ARRAY
46653: PUSH
46654: LD_EXP 98
46658: PUSH
46659: LD_VAR 0 4
46663: ARRAY
46664: LESS
46665: PUSH
46666: LD_VAR 0 1
46670: PPUSH
46671: CALL_OW 264
46675: PUSH
46676: LD_INT 31
46678: PUSH
46679: LD_INT 32
46681: PUSH
46682: LD_INT 51
46684: PUSH
46685: LD_EXP 73
46689: PUSH
46690: LD_INT 12
46692: PUSH
46693: LD_INT 30
46695: PUSH
46696: LD_EXP 72
46700: PUSH
46701: LD_INT 11
46703: PUSH
46704: LD_INT 53
46706: PUSH
46707: LD_INT 14
46709: PUSH
46710: LD_EXP 76
46714: PUSH
46715: LD_INT 29
46717: PUSH
46718: LD_EXP 74
46722: PUSH
46723: LD_INT 13
46725: PUSH
46726: LD_INT 52
46728: PUSH
46729: LD_INT 48
46731: PUSH
46732: LD_INT 8
46734: PUSH
46735: EMPTY
46736: LIST
46737: LIST
46738: LIST
46739: LIST
46740: LIST
46741: LIST
46742: LIST
46743: LIST
46744: LIST
46745: LIST
46746: LIST
46747: LIST
46748: LIST
46749: LIST
46750: LIST
46751: LIST
46752: LIST
46753: IN
46754: NOT
46755: AND
46756: IFFALSE 46804
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
46758: LD_ADDR_EXP 109
46762: PUSH
46763: LD_EXP 109
46767: PPUSH
46768: LD_VAR 0 4
46772: PUSH
46773: LD_EXP 109
46777: PUSH
46778: LD_VAR 0 4
46782: ARRAY
46783: PUSH
46784: LD_INT 1
46786: PLUS
46787: PUSH
46788: EMPTY
46789: LIST
46790: LIST
46791: PPUSH
46792: LD_VAR 0 1
46796: PPUSH
46797: CALL 57967 0 3
46801: ST_TO_ADDR
46802: GO 46848
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
46804: LD_ADDR_EXP 106
46808: PUSH
46809: LD_EXP 106
46813: PPUSH
46814: LD_VAR 0 4
46818: PUSH
46819: LD_EXP 106
46823: PUSH
46824: LD_VAR 0 4
46828: ARRAY
46829: PUSH
46830: LD_INT 1
46832: PLUS
46833: PUSH
46834: EMPTY
46835: LIST
46836: LIST
46837: PPUSH
46838: LD_VAR 0 1
46842: PPUSH
46843: CALL 57967 0 3
46847: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
46848: LD_VAR 0 1
46852: PPUSH
46853: CALL_OW 263
46857: PUSH
46858: LD_INT 2
46860: EQUAL
46861: IFFALSE 46881
// begin repeat wait ( 0 0$1 ) ;
46863: LD_INT 35
46865: PPUSH
46866: CALL_OW 67
// until IsControledBy ( vehicle ) ;
46870: LD_VAR 0 1
46874: PPUSH
46875: CALL_OW 312
46879: IFFALSE 46863
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
46881: LD_VAR 0 1
46885: PPUSH
46886: LD_EXP 111
46890: PUSH
46891: LD_VAR 0 4
46895: ARRAY
46896: PPUSH
46897: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
46901: LD_VAR 0 1
46905: PPUSH
46906: CALL_OW 263
46910: PUSH
46911: LD_INT 1
46913: NONEQUAL
46914: IFFALSE 46918
// break ;
46916: GO 46967
// repeat wait ( 0 0$1 ) ;
46918: LD_INT 35
46920: PPUSH
46921: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
46925: LD_VAR 0 1
46929: PPUSH
46930: LD_EXP 111
46934: PUSH
46935: LD_VAR 0 4
46939: ARRAY
46940: PPUSH
46941: CALL_OW 308
46945: IFFALSE 46918
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
46947: LD_VAR 0 1
46951: PPUSH
46952: CALL_OW 311
46956: PPUSH
46957: CALL_OW 121
// exit ;
46961: POP
46962: POP
46963: GO 46969
// end ; end ;
46965: GO 46622
46967: POP
46968: POP
// end ;
46969: LD_VAR 0 3
46973: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
46974: LD_INT 0
46976: PPUSH
46977: PPUSH
46978: PPUSH
46979: PPUSH
// if not mc_bases or not skirmish then
46980: LD_EXP 87
46984: NOT
46985: PUSH
46986: LD_EXP 85
46990: NOT
46991: OR
46992: IFFALSE 46996
// exit ;
46994: GO 47349
// repeat wait ( 0 0$1 ) ;
46996: LD_INT 35
46998: PPUSH
46999: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
47003: LD_VAR 0 2
47007: PPUSH
47008: LD_VAR 0 3
47012: PPUSH
47013: CALL_OW 284
47017: IFFALSE 46996
// if GetResourceTypeXY ( x , y ) = mat_artefact then
47019: LD_VAR 0 2
47023: PPUSH
47024: LD_VAR 0 3
47028: PPUSH
47029: CALL_OW 283
47033: PUSH
47034: LD_INT 4
47036: EQUAL
47037: IFFALSE 47041
// exit ;
47039: GO 47349
// for i = 1 to mc_bases do
47041: LD_ADDR_VAR 0 7
47045: PUSH
47046: DOUBLE
47047: LD_INT 1
47049: DEC
47050: ST_TO_ADDR
47051: LD_EXP 87
47055: PUSH
47056: FOR_TO
47057: IFFALSE 47347
// begin if mc_crates_area [ i ] then
47059: LD_EXP 105
47063: PUSH
47064: LD_VAR 0 7
47068: ARRAY
47069: IFFALSE 47180
// for j in mc_crates_area [ i ] do
47071: LD_ADDR_VAR 0 8
47075: PUSH
47076: LD_EXP 105
47080: PUSH
47081: LD_VAR 0 7
47085: ARRAY
47086: PUSH
47087: FOR_IN
47088: IFFALSE 47178
// if InArea ( x , y , j ) then
47090: LD_VAR 0 2
47094: PPUSH
47095: LD_VAR 0 3
47099: PPUSH
47100: LD_VAR 0 8
47104: PPUSH
47105: CALL_OW 309
47109: IFFALSE 47176
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
47111: LD_ADDR_EXP 103
47115: PUSH
47116: LD_EXP 103
47120: PPUSH
47121: LD_VAR 0 7
47125: PUSH
47126: LD_EXP 103
47130: PUSH
47131: LD_VAR 0 7
47135: ARRAY
47136: PUSH
47137: LD_INT 1
47139: PLUS
47140: PUSH
47141: EMPTY
47142: LIST
47143: LIST
47144: PPUSH
47145: LD_VAR 0 4
47149: PUSH
47150: LD_VAR 0 2
47154: PUSH
47155: LD_VAR 0 3
47159: PUSH
47160: EMPTY
47161: LIST
47162: LIST
47163: LIST
47164: PPUSH
47165: CALL 57967 0 3
47169: ST_TO_ADDR
// exit ;
47170: POP
47171: POP
47172: POP
47173: POP
47174: GO 47349
// end ;
47176: GO 47087
47178: POP
47179: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47180: LD_ADDR_VAR 0 9
47184: PUSH
47185: LD_EXP 87
47189: PUSH
47190: LD_VAR 0 7
47194: ARRAY
47195: PPUSH
47196: LD_INT 2
47198: PUSH
47199: LD_INT 30
47201: PUSH
47202: LD_INT 0
47204: PUSH
47205: EMPTY
47206: LIST
47207: LIST
47208: PUSH
47209: LD_INT 30
47211: PUSH
47212: LD_INT 1
47214: PUSH
47215: EMPTY
47216: LIST
47217: LIST
47218: PUSH
47219: EMPTY
47220: LIST
47221: LIST
47222: LIST
47223: PPUSH
47224: CALL_OW 72
47228: ST_TO_ADDR
// if not depot then
47229: LD_VAR 0 9
47233: NOT
47234: IFFALSE 47238
// continue ;
47236: GO 47056
// for j in depot do
47238: LD_ADDR_VAR 0 8
47242: PUSH
47243: LD_VAR 0 9
47247: PUSH
47248: FOR_IN
47249: IFFALSE 47343
// if GetDistUnitXY ( j , x , y ) < 30 then
47251: LD_VAR 0 8
47255: PPUSH
47256: LD_VAR 0 2
47260: PPUSH
47261: LD_VAR 0 3
47265: PPUSH
47266: CALL_OW 297
47270: PUSH
47271: LD_INT 30
47273: LESS
47274: IFFALSE 47341
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
47276: LD_ADDR_EXP 103
47280: PUSH
47281: LD_EXP 103
47285: PPUSH
47286: LD_VAR 0 7
47290: PUSH
47291: LD_EXP 103
47295: PUSH
47296: LD_VAR 0 7
47300: ARRAY
47301: PUSH
47302: LD_INT 1
47304: PLUS
47305: PUSH
47306: EMPTY
47307: LIST
47308: LIST
47309: PPUSH
47310: LD_VAR 0 4
47314: PUSH
47315: LD_VAR 0 2
47319: PUSH
47320: LD_VAR 0 3
47324: PUSH
47325: EMPTY
47326: LIST
47327: LIST
47328: LIST
47329: PPUSH
47330: CALL 57967 0 3
47334: ST_TO_ADDR
// exit ;
47335: POP
47336: POP
47337: POP
47338: POP
47339: GO 47349
// end ;
47341: GO 47248
47343: POP
47344: POP
// end ;
47345: GO 47056
47347: POP
47348: POP
// end ;
47349: LD_VAR 0 6
47353: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
47354: LD_INT 0
47356: PPUSH
47357: PPUSH
47358: PPUSH
47359: PPUSH
// if not mc_bases or not skirmish then
47360: LD_EXP 87
47364: NOT
47365: PUSH
47366: LD_EXP 85
47370: NOT
47371: OR
47372: IFFALSE 47376
// exit ;
47374: GO 47653
// side := GetSide ( lab ) ;
47376: LD_ADDR_VAR 0 4
47380: PUSH
47381: LD_VAR 0 2
47385: PPUSH
47386: CALL_OW 255
47390: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
47391: LD_VAR 0 4
47395: PUSH
47396: LD_EXP 113
47400: IN
47401: NOT
47402: PUSH
47403: LD_EXP 114
47407: NOT
47408: OR
47409: PUSH
47410: LD_EXP 87
47414: NOT
47415: OR
47416: IFFALSE 47420
// exit ;
47418: GO 47653
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
47420: LD_ADDR_EXP 114
47424: PUSH
47425: LD_EXP 114
47429: PPUSH
47430: LD_VAR 0 4
47434: PPUSH
47435: LD_EXP 114
47439: PUSH
47440: LD_VAR 0 4
47444: ARRAY
47445: PUSH
47446: LD_VAR 0 1
47450: DIFF
47451: PPUSH
47452: CALL_OW 1
47456: ST_TO_ADDR
// for i = 1 to mc_bases do
47457: LD_ADDR_VAR 0 5
47461: PUSH
47462: DOUBLE
47463: LD_INT 1
47465: DEC
47466: ST_TO_ADDR
47467: LD_EXP 87
47471: PUSH
47472: FOR_TO
47473: IFFALSE 47651
// begin if lab in mc_bases [ i ] then
47475: LD_VAR 0 2
47479: PUSH
47480: LD_EXP 87
47484: PUSH
47485: LD_VAR 0 5
47489: ARRAY
47490: IN
47491: IFFALSE 47649
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
47493: LD_VAR 0 1
47497: PUSH
47498: LD_INT 11
47500: PUSH
47501: LD_INT 4
47503: PUSH
47504: LD_INT 3
47506: PUSH
47507: LD_INT 2
47509: PUSH
47510: EMPTY
47511: LIST
47512: LIST
47513: LIST
47514: LIST
47515: IN
47516: PUSH
47517: LD_EXP 117
47521: PUSH
47522: LD_VAR 0 5
47526: ARRAY
47527: AND
47528: IFFALSE 47649
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
47530: LD_ADDR_VAR 0 6
47534: PUSH
47535: LD_EXP 117
47539: PUSH
47540: LD_VAR 0 5
47544: ARRAY
47545: PUSH
47546: LD_INT 1
47548: ARRAY
47549: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
47550: LD_ADDR_EXP 117
47554: PUSH
47555: LD_EXP 117
47559: PPUSH
47560: LD_VAR 0 5
47564: PPUSH
47565: EMPTY
47566: PPUSH
47567: CALL_OW 1
47571: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
47572: LD_VAR 0 6
47576: PPUSH
47577: LD_INT 0
47579: PPUSH
47580: CALL_OW 109
// ComExitBuilding ( tmp ) ;
47584: LD_VAR 0 6
47588: PPUSH
47589: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
47593: LD_ADDR_EXP 116
47597: PUSH
47598: LD_EXP 116
47602: PPUSH
47603: LD_VAR 0 5
47607: PPUSH
47608: LD_EXP 116
47612: PUSH
47613: LD_VAR 0 5
47617: ARRAY
47618: PPUSH
47619: LD_INT 1
47621: PPUSH
47622: LD_VAR 0 6
47626: PPUSH
47627: CALL_OW 2
47631: PPUSH
47632: CALL_OW 1
47636: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
47637: LD_VAR 0 5
47641: PPUSH
47642: LD_INT 112
47644: PPUSH
47645: CALL 24649 0 2
// end ; end ; end ;
47649: GO 47472
47651: POP
47652: POP
// end ;
47653: LD_VAR 0 3
47657: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
47658: LD_INT 0
47660: PPUSH
47661: PPUSH
47662: PPUSH
47663: PPUSH
47664: PPUSH
47665: PPUSH
47666: PPUSH
47667: PPUSH
// if not mc_bases or not skirmish then
47668: LD_EXP 87
47672: NOT
47673: PUSH
47674: LD_EXP 85
47678: NOT
47679: OR
47680: IFFALSE 47684
// exit ;
47682: GO 49055
// for i = 1 to mc_bases do
47684: LD_ADDR_VAR 0 3
47688: PUSH
47689: DOUBLE
47690: LD_INT 1
47692: DEC
47693: ST_TO_ADDR
47694: LD_EXP 87
47698: PUSH
47699: FOR_TO
47700: IFFALSE 49053
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
47702: LD_VAR 0 1
47706: PUSH
47707: LD_EXP 87
47711: PUSH
47712: LD_VAR 0 3
47716: ARRAY
47717: IN
47718: PUSH
47719: LD_VAR 0 1
47723: PUSH
47724: LD_EXP 94
47728: PUSH
47729: LD_VAR 0 3
47733: ARRAY
47734: IN
47735: OR
47736: PUSH
47737: LD_VAR 0 1
47741: PUSH
47742: LD_EXP 109
47746: PUSH
47747: LD_VAR 0 3
47751: ARRAY
47752: IN
47753: OR
47754: PUSH
47755: LD_VAR 0 1
47759: PUSH
47760: LD_EXP 106
47764: PUSH
47765: LD_VAR 0 3
47769: ARRAY
47770: IN
47771: OR
47772: PUSH
47773: LD_VAR 0 1
47777: PUSH
47778: LD_EXP 116
47782: PUSH
47783: LD_VAR 0 3
47787: ARRAY
47788: IN
47789: OR
47790: PUSH
47791: LD_VAR 0 1
47795: PUSH
47796: LD_EXP 117
47800: PUSH
47801: LD_VAR 0 3
47805: ARRAY
47806: IN
47807: OR
47808: IFFALSE 49051
// begin if un in mc_ape [ i ] then
47810: LD_VAR 0 1
47814: PUSH
47815: LD_EXP 116
47819: PUSH
47820: LD_VAR 0 3
47824: ARRAY
47825: IN
47826: IFFALSE 47865
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
47828: LD_ADDR_EXP 116
47832: PUSH
47833: LD_EXP 116
47837: PPUSH
47838: LD_VAR 0 3
47842: PPUSH
47843: LD_EXP 116
47847: PUSH
47848: LD_VAR 0 3
47852: ARRAY
47853: PUSH
47854: LD_VAR 0 1
47858: DIFF
47859: PPUSH
47860: CALL_OW 1
47864: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
47865: LD_VAR 0 1
47869: PUSH
47870: LD_EXP 117
47874: PUSH
47875: LD_VAR 0 3
47879: ARRAY
47880: IN
47881: IFFALSE 47905
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
47883: LD_ADDR_EXP 117
47887: PUSH
47888: LD_EXP 117
47892: PPUSH
47893: LD_VAR 0 3
47897: PPUSH
47898: EMPTY
47899: PPUSH
47900: CALL_OW 1
47904: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
47905: LD_VAR 0 1
47909: PPUSH
47910: CALL_OW 247
47914: PUSH
47915: LD_INT 2
47917: EQUAL
47918: PUSH
47919: LD_VAR 0 1
47923: PPUSH
47924: CALL_OW 110
47928: PUSH
47929: LD_INT 20
47931: EQUAL
47932: PUSH
47933: LD_VAR 0 1
47937: PUSH
47938: LD_EXP 109
47942: PUSH
47943: LD_VAR 0 3
47947: ARRAY
47948: IN
47949: OR
47950: PUSH
47951: LD_VAR 0 1
47955: PPUSH
47956: CALL_OW 264
47960: PUSH
47961: LD_INT 12
47963: PUSH
47964: LD_INT 51
47966: PUSH
47967: LD_EXP 73
47971: PUSH
47972: LD_INT 32
47974: PUSH
47975: LD_INT 13
47977: PUSH
47978: LD_INT 52
47980: PUSH
47981: LD_INT 31
47983: PUSH
47984: EMPTY
47985: LIST
47986: LIST
47987: LIST
47988: LIST
47989: LIST
47990: LIST
47991: LIST
47992: IN
47993: OR
47994: AND
47995: IFFALSE 48303
// begin if un in mc_defender [ i ] then
47997: LD_VAR 0 1
48001: PUSH
48002: LD_EXP 109
48006: PUSH
48007: LD_VAR 0 3
48011: ARRAY
48012: IN
48013: IFFALSE 48052
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
48015: LD_ADDR_EXP 109
48019: PUSH
48020: LD_EXP 109
48024: PPUSH
48025: LD_VAR 0 3
48029: PPUSH
48030: LD_EXP 109
48034: PUSH
48035: LD_VAR 0 3
48039: ARRAY
48040: PUSH
48041: LD_VAR 0 1
48045: DIFF
48046: PPUSH
48047: CALL_OW 1
48051: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
48052: LD_ADDR_VAR 0 8
48056: PUSH
48057: LD_VAR 0 3
48061: PPUSH
48062: LD_INT 3
48064: PPUSH
48065: CALL 44721 0 2
48069: ST_TO_ADDR
// if fac then
48070: LD_VAR 0 8
48074: IFFALSE 48303
// begin for j in fac do
48076: LD_ADDR_VAR 0 4
48080: PUSH
48081: LD_VAR 0 8
48085: PUSH
48086: FOR_IN
48087: IFFALSE 48301
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
48089: LD_ADDR_VAR 0 9
48093: PUSH
48094: LD_VAR 0 8
48098: PPUSH
48099: LD_VAR 0 1
48103: PPUSH
48104: CALL_OW 265
48108: PPUSH
48109: LD_VAR 0 1
48113: PPUSH
48114: CALL_OW 262
48118: PPUSH
48119: LD_VAR 0 1
48123: PPUSH
48124: CALL_OW 263
48128: PPUSH
48129: LD_VAR 0 1
48133: PPUSH
48134: CALL_OW 264
48138: PPUSH
48139: CALL 55499 0 5
48143: ST_TO_ADDR
// if components then
48144: LD_VAR 0 9
48148: IFFALSE 48299
// begin if GetWeapon ( un ) = ar_control_tower then
48150: LD_VAR 0 1
48154: PPUSH
48155: CALL_OW 264
48159: PUSH
48160: LD_INT 31
48162: EQUAL
48163: IFFALSE 48280
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
48165: LD_VAR 0 1
48169: PPUSH
48170: CALL_OW 311
48174: PPUSH
48175: LD_INT 0
48177: PPUSH
48178: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
48182: LD_ADDR_EXP 127
48186: PUSH
48187: LD_EXP 127
48191: PPUSH
48192: LD_VAR 0 3
48196: PPUSH
48197: LD_EXP 127
48201: PUSH
48202: LD_VAR 0 3
48206: ARRAY
48207: PUSH
48208: LD_VAR 0 1
48212: PPUSH
48213: CALL_OW 311
48217: DIFF
48218: PPUSH
48219: CALL_OW 1
48223: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
48224: LD_ADDR_VAR 0 7
48228: PUSH
48229: LD_EXP 108
48233: PUSH
48234: LD_VAR 0 3
48238: ARRAY
48239: PPUSH
48240: LD_INT 1
48242: PPUSH
48243: LD_VAR 0 9
48247: PPUSH
48248: CALL_OW 2
48252: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
48253: LD_ADDR_EXP 108
48257: PUSH
48258: LD_EXP 108
48262: PPUSH
48263: LD_VAR 0 3
48267: PPUSH
48268: LD_VAR 0 7
48272: PPUSH
48273: CALL_OW 1
48277: ST_TO_ADDR
// end else
48278: GO 48297
// MC_InsertProduceList ( i , [ components ] ) ;
48280: LD_VAR 0 3
48284: PPUSH
48285: LD_VAR 0 9
48289: PUSH
48290: EMPTY
48291: LIST
48292: PPUSH
48293: CALL 44266 0 2
// break ;
48297: GO 48301
// end ; end ;
48299: GO 48086
48301: POP
48302: POP
// end ; end ; if GetType ( un ) = unit_building then
48303: LD_VAR 0 1
48307: PPUSH
48308: CALL_OW 247
48312: PUSH
48313: LD_INT 3
48315: EQUAL
48316: IFFALSE 48719
// begin btype := GetBType ( un ) ;
48318: LD_ADDR_VAR 0 5
48322: PUSH
48323: LD_VAR 0 1
48327: PPUSH
48328: CALL_OW 266
48332: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
48333: LD_VAR 0 5
48337: PUSH
48338: LD_INT 29
48340: PUSH
48341: LD_INT 30
48343: PUSH
48344: EMPTY
48345: LIST
48346: LIST
48347: IN
48348: IFFALSE 48421
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
48350: LD_VAR 0 1
48354: PPUSH
48355: CALL_OW 250
48359: PPUSH
48360: LD_VAR 0 1
48364: PPUSH
48365: CALL_OW 251
48369: PPUSH
48370: LD_VAR 0 1
48374: PPUSH
48375: CALL_OW 255
48379: PPUSH
48380: CALL_OW 440
48384: NOT
48385: IFFALSE 48421
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
48387: LD_VAR 0 1
48391: PPUSH
48392: CALL_OW 250
48396: PPUSH
48397: LD_VAR 0 1
48401: PPUSH
48402: CALL_OW 251
48406: PPUSH
48407: LD_VAR 0 1
48411: PPUSH
48412: CALL_OW 255
48416: PPUSH
48417: CALL_OW 441
// end ; if btype = b_warehouse then
48421: LD_VAR 0 5
48425: PUSH
48426: LD_INT 1
48428: EQUAL
48429: IFFALSE 48447
// begin btype := b_depot ;
48431: LD_ADDR_VAR 0 5
48435: PUSH
48436: LD_INT 0
48438: ST_TO_ADDR
// pos := 1 ;
48439: LD_ADDR_VAR 0 6
48443: PUSH
48444: LD_INT 1
48446: ST_TO_ADDR
// end ; if btype = b_factory then
48447: LD_VAR 0 5
48451: PUSH
48452: LD_INT 3
48454: EQUAL
48455: IFFALSE 48473
// begin btype := b_workshop ;
48457: LD_ADDR_VAR 0 5
48461: PUSH
48462: LD_INT 2
48464: ST_TO_ADDR
// pos := 1 ;
48465: LD_ADDR_VAR 0 6
48469: PUSH
48470: LD_INT 1
48472: ST_TO_ADDR
// end ; if btype = b_barracks then
48473: LD_VAR 0 5
48477: PUSH
48478: LD_INT 5
48480: EQUAL
48481: IFFALSE 48491
// btype := b_armoury ;
48483: LD_ADDR_VAR 0 5
48487: PUSH
48488: LD_INT 4
48490: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
48491: LD_VAR 0 5
48495: PUSH
48496: LD_INT 7
48498: PUSH
48499: LD_INT 8
48501: PUSH
48502: EMPTY
48503: LIST
48504: LIST
48505: IN
48506: IFFALSE 48516
// btype := b_lab ;
48508: LD_ADDR_VAR 0 5
48512: PUSH
48513: LD_INT 6
48515: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
48516: LD_ADDR_EXP 92
48520: PUSH
48521: LD_EXP 92
48525: PPUSH
48526: LD_VAR 0 3
48530: PUSH
48531: LD_EXP 92
48535: PUSH
48536: LD_VAR 0 3
48540: ARRAY
48541: PUSH
48542: LD_INT 1
48544: PLUS
48545: PUSH
48546: EMPTY
48547: LIST
48548: LIST
48549: PPUSH
48550: LD_VAR 0 5
48554: PUSH
48555: LD_VAR 0 1
48559: PPUSH
48560: CALL_OW 250
48564: PUSH
48565: LD_VAR 0 1
48569: PPUSH
48570: CALL_OW 251
48574: PUSH
48575: LD_VAR 0 1
48579: PPUSH
48580: CALL_OW 254
48584: PUSH
48585: EMPTY
48586: LIST
48587: LIST
48588: LIST
48589: LIST
48590: PPUSH
48591: CALL 57967 0 3
48595: ST_TO_ADDR
// if pos = 1 then
48596: LD_VAR 0 6
48600: PUSH
48601: LD_INT 1
48603: EQUAL
48604: IFFALSE 48719
// begin tmp := mc_build_list [ i ] ;
48606: LD_ADDR_VAR 0 7
48610: PUSH
48611: LD_EXP 92
48615: PUSH
48616: LD_VAR 0 3
48620: ARRAY
48621: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
48622: LD_VAR 0 7
48626: PPUSH
48627: LD_INT 2
48629: PUSH
48630: LD_INT 30
48632: PUSH
48633: LD_INT 0
48635: PUSH
48636: EMPTY
48637: LIST
48638: LIST
48639: PUSH
48640: LD_INT 30
48642: PUSH
48643: LD_INT 1
48645: PUSH
48646: EMPTY
48647: LIST
48648: LIST
48649: PUSH
48650: EMPTY
48651: LIST
48652: LIST
48653: LIST
48654: PPUSH
48655: CALL_OW 72
48659: IFFALSE 48669
// pos := 2 ;
48661: LD_ADDR_VAR 0 6
48665: PUSH
48666: LD_INT 2
48668: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
48669: LD_ADDR_VAR 0 7
48673: PUSH
48674: LD_VAR 0 7
48678: PPUSH
48679: LD_VAR 0 6
48683: PPUSH
48684: LD_VAR 0 7
48688: PPUSH
48689: CALL 58293 0 3
48693: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
48694: LD_ADDR_EXP 92
48698: PUSH
48699: LD_EXP 92
48703: PPUSH
48704: LD_VAR 0 3
48708: PPUSH
48709: LD_VAR 0 7
48713: PPUSH
48714: CALL_OW 1
48718: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
48719: LD_VAR 0 1
48723: PUSH
48724: LD_EXP 87
48728: PUSH
48729: LD_VAR 0 3
48733: ARRAY
48734: IN
48735: IFFALSE 48774
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
48737: LD_ADDR_EXP 87
48741: PUSH
48742: LD_EXP 87
48746: PPUSH
48747: LD_VAR 0 3
48751: PPUSH
48752: LD_EXP 87
48756: PUSH
48757: LD_VAR 0 3
48761: ARRAY
48762: PUSH
48763: LD_VAR 0 1
48767: DIFF
48768: PPUSH
48769: CALL_OW 1
48773: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
48774: LD_VAR 0 1
48778: PUSH
48779: LD_EXP 94
48783: PUSH
48784: LD_VAR 0 3
48788: ARRAY
48789: IN
48790: IFFALSE 48829
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
48792: LD_ADDR_EXP 94
48796: PUSH
48797: LD_EXP 94
48801: PPUSH
48802: LD_VAR 0 3
48806: PPUSH
48807: LD_EXP 94
48811: PUSH
48812: LD_VAR 0 3
48816: ARRAY
48817: PUSH
48818: LD_VAR 0 1
48822: DIFF
48823: PPUSH
48824: CALL_OW 1
48828: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
48829: LD_VAR 0 1
48833: PUSH
48834: LD_EXP 106
48838: PUSH
48839: LD_VAR 0 3
48843: ARRAY
48844: IN
48845: IFFALSE 48884
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
48847: LD_ADDR_EXP 106
48851: PUSH
48852: LD_EXP 106
48856: PPUSH
48857: LD_VAR 0 3
48861: PPUSH
48862: LD_EXP 106
48866: PUSH
48867: LD_VAR 0 3
48871: ARRAY
48872: PUSH
48873: LD_VAR 0 1
48877: DIFF
48878: PPUSH
48879: CALL_OW 1
48883: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
48884: LD_VAR 0 1
48888: PUSH
48889: LD_EXP 109
48893: PUSH
48894: LD_VAR 0 3
48898: ARRAY
48899: IN
48900: IFFALSE 48939
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
48902: LD_ADDR_EXP 109
48906: PUSH
48907: LD_EXP 109
48911: PPUSH
48912: LD_VAR 0 3
48916: PPUSH
48917: LD_EXP 109
48921: PUSH
48922: LD_VAR 0 3
48926: ARRAY
48927: PUSH
48928: LD_VAR 0 1
48932: DIFF
48933: PPUSH
48934: CALL_OW 1
48938: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
48939: LD_VAR 0 1
48943: PUSH
48944: LD_EXP 96
48948: PUSH
48949: LD_VAR 0 3
48953: ARRAY
48954: IN
48955: IFFALSE 48994
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
48957: LD_ADDR_EXP 96
48961: PUSH
48962: LD_EXP 96
48966: PPUSH
48967: LD_VAR 0 3
48971: PPUSH
48972: LD_EXP 96
48976: PUSH
48977: LD_VAR 0 3
48981: ARRAY
48982: PUSH
48983: LD_VAR 0 1
48987: DIFF
48988: PPUSH
48989: CALL_OW 1
48993: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
48994: LD_VAR 0 1
48998: PUSH
48999: LD_EXP 95
49003: PUSH
49004: LD_VAR 0 3
49008: ARRAY
49009: IN
49010: IFFALSE 49049
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
49012: LD_ADDR_EXP 95
49016: PUSH
49017: LD_EXP 95
49021: PPUSH
49022: LD_VAR 0 3
49026: PPUSH
49027: LD_EXP 95
49031: PUSH
49032: LD_VAR 0 3
49036: ARRAY
49037: PUSH
49038: LD_VAR 0 1
49042: DIFF
49043: PPUSH
49044: CALL_OW 1
49048: ST_TO_ADDR
// end ; break ;
49049: GO 49053
// end ;
49051: GO 47699
49053: POP
49054: POP
// end ;
49055: LD_VAR 0 2
49059: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
49060: LD_INT 0
49062: PPUSH
49063: PPUSH
49064: PPUSH
// if not mc_bases or not skirmish then
49065: LD_EXP 87
49069: NOT
49070: PUSH
49071: LD_EXP 85
49075: NOT
49076: OR
49077: IFFALSE 49081
// exit ;
49079: GO 49296
// for i = 1 to mc_bases do
49081: LD_ADDR_VAR 0 3
49085: PUSH
49086: DOUBLE
49087: LD_INT 1
49089: DEC
49090: ST_TO_ADDR
49091: LD_EXP 87
49095: PUSH
49096: FOR_TO
49097: IFFALSE 49294
// begin if building in mc_construct_list [ i ] then
49099: LD_VAR 0 1
49103: PUSH
49104: LD_EXP 94
49108: PUSH
49109: LD_VAR 0 3
49113: ARRAY
49114: IN
49115: IFFALSE 49292
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
49117: LD_ADDR_EXP 94
49121: PUSH
49122: LD_EXP 94
49126: PPUSH
49127: LD_VAR 0 3
49131: PPUSH
49132: LD_EXP 94
49136: PUSH
49137: LD_VAR 0 3
49141: ARRAY
49142: PUSH
49143: LD_VAR 0 1
49147: DIFF
49148: PPUSH
49149: CALL_OW 1
49153: ST_TO_ADDR
// if building in mc_lab [ i ] then
49154: LD_VAR 0 1
49158: PUSH
49159: LD_EXP 120
49163: PUSH
49164: LD_VAR 0 3
49168: ARRAY
49169: IN
49170: IFFALSE 49225
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
49172: LD_ADDR_EXP 121
49176: PUSH
49177: LD_EXP 121
49181: PPUSH
49182: LD_VAR 0 3
49186: PPUSH
49187: LD_EXP 121
49191: PUSH
49192: LD_VAR 0 3
49196: ARRAY
49197: PPUSH
49198: LD_INT 1
49200: PPUSH
49201: LD_EXP 121
49205: PUSH
49206: LD_VAR 0 3
49210: ARRAY
49211: PPUSH
49212: LD_INT 0
49214: PPUSH
49215: CALL 57385 0 4
49219: PPUSH
49220: CALL_OW 1
49224: ST_TO_ADDR
// if not building in mc_bases [ i ] then
49225: LD_VAR 0 1
49229: PUSH
49230: LD_EXP 87
49234: PUSH
49235: LD_VAR 0 3
49239: ARRAY
49240: IN
49241: NOT
49242: IFFALSE 49288
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
49244: LD_ADDR_EXP 87
49248: PUSH
49249: LD_EXP 87
49253: PPUSH
49254: LD_VAR 0 3
49258: PUSH
49259: LD_EXP 87
49263: PUSH
49264: LD_VAR 0 3
49268: ARRAY
49269: PUSH
49270: LD_INT 1
49272: PLUS
49273: PUSH
49274: EMPTY
49275: LIST
49276: LIST
49277: PPUSH
49278: LD_VAR 0 1
49282: PPUSH
49283: CALL 57967 0 3
49287: ST_TO_ADDR
// exit ;
49288: POP
49289: POP
49290: GO 49296
// end ; end ;
49292: GO 49096
49294: POP
49295: POP
// end ;
49296: LD_VAR 0 2
49300: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
49301: LD_INT 0
49303: PPUSH
49304: PPUSH
49305: PPUSH
49306: PPUSH
49307: PPUSH
49308: PPUSH
49309: PPUSH
// if not mc_bases or not skirmish then
49310: LD_EXP 87
49314: NOT
49315: PUSH
49316: LD_EXP 85
49320: NOT
49321: OR
49322: IFFALSE 49326
// exit ;
49324: GO 49987
// for i = 1 to mc_bases do
49326: LD_ADDR_VAR 0 3
49330: PUSH
49331: DOUBLE
49332: LD_INT 1
49334: DEC
49335: ST_TO_ADDR
49336: LD_EXP 87
49340: PUSH
49341: FOR_TO
49342: IFFALSE 49985
// begin if building in mc_construct_list [ i ] then
49344: LD_VAR 0 1
49348: PUSH
49349: LD_EXP 94
49353: PUSH
49354: LD_VAR 0 3
49358: ARRAY
49359: IN
49360: IFFALSE 49983
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
49362: LD_ADDR_EXP 94
49366: PUSH
49367: LD_EXP 94
49371: PPUSH
49372: LD_VAR 0 3
49376: PPUSH
49377: LD_EXP 94
49381: PUSH
49382: LD_VAR 0 3
49386: ARRAY
49387: PUSH
49388: LD_VAR 0 1
49392: DIFF
49393: PPUSH
49394: CALL_OW 1
49398: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
49399: LD_ADDR_EXP 87
49403: PUSH
49404: LD_EXP 87
49408: PPUSH
49409: LD_VAR 0 3
49413: PUSH
49414: LD_EXP 87
49418: PUSH
49419: LD_VAR 0 3
49423: ARRAY
49424: PUSH
49425: LD_INT 1
49427: PLUS
49428: PUSH
49429: EMPTY
49430: LIST
49431: LIST
49432: PPUSH
49433: LD_VAR 0 1
49437: PPUSH
49438: CALL 57967 0 3
49442: ST_TO_ADDR
// btype := GetBType ( building ) ;
49443: LD_ADDR_VAR 0 5
49447: PUSH
49448: LD_VAR 0 1
49452: PPUSH
49453: CALL_OW 266
49457: ST_TO_ADDR
// side := GetSide ( building ) ;
49458: LD_ADDR_VAR 0 8
49462: PUSH
49463: LD_VAR 0 1
49467: PPUSH
49468: CALL_OW 255
49472: ST_TO_ADDR
// if btype = b_lab then
49473: LD_VAR 0 5
49477: PUSH
49478: LD_INT 6
49480: EQUAL
49481: IFFALSE 49531
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
49483: LD_ADDR_EXP 120
49487: PUSH
49488: LD_EXP 120
49492: PPUSH
49493: LD_VAR 0 3
49497: PUSH
49498: LD_EXP 120
49502: PUSH
49503: LD_VAR 0 3
49507: ARRAY
49508: PUSH
49509: LD_INT 1
49511: PLUS
49512: PUSH
49513: EMPTY
49514: LIST
49515: LIST
49516: PPUSH
49517: LD_VAR 0 1
49521: PPUSH
49522: CALL 57967 0 3
49526: ST_TO_ADDR
// exit ;
49527: POP
49528: POP
49529: GO 49987
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
49531: LD_VAR 0 5
49535: PUSH
49536: LD_INT 0
49538: PUSH
49539: LD_INT 2
49541: PUSH
49542: LD_INT 4
49544: PUSH
49545: EMPTY
49546: LIST
49547: LIST
49548: LIST
49549: IN
49550: IFFALSE 49674
// begin if btype = b_armoury then
49552: LD_VAR 0 5
49556: PUSH
49557: LD_INT 4
49559: EQUAL
49560: IFFALSE 49570
// btype := b_barracks ;
49562: LD_ADDR_VAR 0 5
49566: PUSH
49567: LD_INT 5
49569: ST_TO_ADDR
// if btype = b_depot then
49570: LD_VAR 0 5
49574: PUSH
49575: LD_INT 0
49577: EQUAL
49578: IFFALSE 49588
// btype := b_warehouse ;
49580: LD_ADDR_VAR 0 5
49584: PUSH
49585: LD_INT 1
49587: ST_TO_ADDR
// if btype = b_workshop then
49588: LD_VAR 0 5
49592: PUSH
49593: LD_INT 2
49595: EQUAL
49596: IFFALSE 49606
// btype := b_factory ;
49598: LD_ADDR_VAR 0 5
49602: PUSH
49603: LD_INT 3
49605: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
49606: LD_VAR 0 5
49610: PPUSH
49611: LD_VAR 0 8
49615: PPUSH
49616: CALL_OW 323
49620: PUSH
49621: LD_INT 1
49623: EQUAL
49624: IFFALSE 49670
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
49626: LD_ADDR_EXP 119
49630: PUSH
49631: LD_EXP 119
49635: PPUSH
49636: LD_VAR 0 3
49640: PUSH
49641: LD_EXP 119
49645: PUSH
49646: LD_VAR 0 3
49650: ARRAY
49651: PUSH
49652: LD_INT 1
49654: PLUS
49655: PUSH
49656: EMPTY
49657: LIST
49658: LIST
49659: PPUSH
49660: LD_VAR 0 1
49664: PPUSH
49665: CALL 57967 0 3
49669: ST_TO_ADDR
// exit ;
49670: POP
49671: POP
49672: GO 49987
// end ; if btype in [ b_bunker , b_turret ] then
49674: LD_VAR 0 5
49678: PUSH
49679: LD_INT 32
49681: PUSH
49682: LD_INT 33
49684: PUSH
49685: EMPTY
49686: LIST
49687: LIST
49688: IN
49689: IFFALSE 49979
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
49691: LD_ADDR_EXP 95
49695: PUSH
49696: LD_EXP 95
49700: PPUSH
49701: LD_VAR 0 3
49705: PUSH
49706: LD_EXP 95
49710: PUSH
49711: LD_VAR 0 3
49715: ARRAY
49716: PUSH
49717: LD_INT 1
49719: PLUS
49720: PUSH
49721: EMPTY
49722: LIST
49723: LIST
49724: PPUSH
49725: LD_VAR 0 1
49729: PPUSH
49730: CALL 57967 0 3
49734: ST_TO_ADDR
// if btype = b_bunker then
49735: LD_VAR 0 5
49739: PUSH
49740: LD_INT 32
49742: EQUAL
49743: IFFALSE 49979
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
49745: LD_ADDR_EXP 96
49749: PUSH
49750: LD_EXP 96
49754: PPUSH
49755: LD_VAR 0 3
49759: PUSH
49760: LD_EXP 96
49764: PUSH
49765: LD_VAR 0 3
49769: ARRAY
49770: PUSH
49771: LD_INT 1
49773: PLUS
49774: PUSH
49775: EMPTY
49776: LIST
49777: LIST
49778: PPUSH
49779: LD_VAR 0 1
49783: PPUSH
49784: CALL 57967 0 3
49788: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
49789: LD_ADDR_VAR 0 6
49793: PUSH
49794: LD_EXP 87
49798: PUSH
49799: LD_VAR 0 3
49803: ARRAY
49804: PPUSH
49805: LD_INT 25
49807: PUSH
49808: LD_INT 1
49810: PUSH
49811: EMPTY
49812: LIST
49813: LIST
49814: PUSH
49815: LD_INT 3
49817: PUSH
49818: LD_INT 54
49820: PUSH
49821: EMPTY
49822: LIST
49823: PUSH
49824: EMPTY
49825: LIST
49826: LIST
49827: PUSH
49828: EMPTY
49829: LIST
49830: LIST
49831: PPUSH
49832: CALL_OW 72
49836: ST_TO_ADDR
// if tmp then
49837: LD_VAR 0 6
49841: IFFALSE 49847
// exit ;
49843: POP
49844: POP
49845: GO 49987
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
49847: LD_ADDR_VAR 0 6
49851: PUSH
49852: LD_EXP 87
49856: PUSH
49857: LD_VAR 0 3
49861: ARRAY
49862: PPUSH
49863: LD_INT 2
49865: PUSH
49866: LD_INT 30
49868: PUSH
49869: LD_INT 4
49871: PUSH
49872: EMPTY
49873: LIST
49874: LIST
49875: PUSH
49876: LD_INT 30
49878: PUSH
49879: LD_INT 5
49881: PUSH
49882: EMPTY
49883: LIST
49884: LIST
49885: PUSH
49886: EMPTY
49887: LIST
49888: LIST
49889: LIST
49890: PPUSH
49891: CALL_OW 72
49895: ST_TO_ADDR
// if not tmp then
49896: LD_VAR 0 6
49900: NOT
49901: IFFALSE 49907
// exit ;
49903: POP
49904: POP
49905: GO 49987
// for j in tmp do
49907: LD_ADDR_VAR 0 4
49911: PUSH
49912: LD_VAR 0 6
49916: PUSH
49917: FOR_IN
49918: IFFALSE 49977
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
49920: LD_ADDR_VAR 0 7
49924: PUSH
49925: LD_VAR 0 4
49929: PPUSH
49930: CALL_OW 313
49934: PPUSH
49935: LD_INT 25
49937: PUSH
49938: LD_INT 1
49940: PUSH
49941: EMPTY
49942: LIST
49943: LIST
49944: PPUSH
49945: CALL_OW 72
49949: ST_TO_ADDR
// if units then
49950: LD_VAR 0 7
49954: IFFALSE 49975
// begin ComExitBuilding ( units [ 1 ] ) ;
49956: LD_VAR 0 7
49960: PUSH
49961: LD_INT 1
49963: ARRAY
49964: PPUSH
49965: CALL_OW 122
// exit ;
49969: POP
49970: POP
49971: POP
49972: POP
49973: GO 49987
// end ; end ;
49975: GO 49917
49977: POP
49978: POP
// end ; end ; exit ;
49979: POP
49980: POP
49981: GO 49987
// end ; end ;
49983: GO 49341
49985: POP
49986: POP
// end ;
49987: LD_VAR 0 2
49991: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
49992: LD_INT 0
49994: PPUSH
49995: PPUSH
49996: PPUSH
49997: PPUSH
49998: PPUSH
49999: PPUSH
50000: PPUSH
// if not mc_bases or not skirmish then
50001: LD_EXP 87
50005: NOT
50006: PUSH
50007: LD_EXP 85
50011: NOT
50012: OR
50013: IFFALSE 50017
// exit ;
50015: GO 50248
// btype := GetBType ( building ) ;
50017: LD_ADDR_VAR 0 6
50021: PUSH
50022: LD_VAR 0 1
50026: PPUSH
50027: CALL_OW 266
50031: ST_TO_ADDR
// x := GetX ( building ) ;
50032: LD_ADDR_VAR 0 7
50036: PUSH
50037: LD_VAR 0 1
50041: PPUSH
50042: CALL_OW 250
50046: ST_TO_ADDR
// y := GetY ( building ) ;
50047: LD_ADDR_VAR 0 8
50051: PUSH
50052: LD_VAR 0 1
50056: PPUSH
50057: CALL_OW 251
50061: ST_TO_ADDR
// d := GetDir ( building ) ;
50062: LD_ADDR_VAR 0 9
50066: PUSH
50067: LD_VAR 0 1
50071: PPUSH
50072: CALL_OW 254
50076: ST_TO_ADDR
// for i = 1 to mc_bases do
50077: LD_ADDR_VAR 0 4
50081: PUSH
50082: DOUBLE
50083: LD_INT 1
50085: DEC
50086: ST_TO_ADDR
50087: LD_EXP 87
50091: PUSH
50092: FOR_TO
50093: IFFALSE 50246
// begin if not mc_build_list [ i ] then
50095: LD_EXP 92
50099: PUSH
50100: LD_VAR 0 4
50104: ARRAY
50105: NOT
50106: IFFALSE 50110
// continue ;
50108: GO 50092
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
50110: LD_VAR 0 6
50114: PUSH
50115: LD_VAR 0 7
50119: PUSH
50120: LD_VAR 0 8
50124: PUSH
50125: LD_VAR 0 9
50129: PUSH
50130: EMPTY
50131: LIST
50132: LIST
50133: LIST
50134: LIST
50135: PPUSH
50136: LD_EXP 92
50140: PUSH
50141: LD_VAR 0 4
50145: ARRAY
50146: PUSH
50147: LD_INT 1
50149: ARRAY
50150: PPUSH
50151: CALL 64136 0 2
50155: IFFALSE 50244
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
50157: LD_ADDR_EXP 92
50161: PUSH
50162: LD_EXP 92
50166: PPUSH
50167: LD_VAR 0 4
50171: PPUSH
50172: LD_EXP 92
50176: PUSH
50177: LD_VAR 0 4
50181: ARRAY
50182: PPUSH
50183: LD_INT 1
50185: PPUSH
50186: CALL_OW 3
50190: PPUSH
50191: CALL_OW 1
50195: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
50196: LD_ADDR_EXP 94
50200: PUSH
50201: LD_EXP 94
50205: PPUSH
50206: LD_VAR 0 4
50210: PUSH
50211: LD_EXP 94
50215: PUSH
50216: LD_VAR 0 4
50220: ARRAY
50221: PUSH
50222: LD_INT 1
50224: PLUS
50225: PUSH
50226: EMPTY
50227: LIST
50228: LIST
50229: PPUSH
50230: LD_VAR 0 1
50234: PPUSH
50235: CALL 57967 0 3
50239: ST_TO_ADDR
// exit ;
50240: POP
50241: POP
50242: GO 50248
// end ; end ;
50244: GO 50092
50246: POP
50247: POP
// end ;
50248: LD_VAR 0 3
50252: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
50253: LD_INT 0
50255: PPUSH
50256: PPUSH
50257: PPUSH
// if not mc_bases or not skirmish then
50258: LD_EXP 87
50262: NOT
50263: PUSH
50264: LD_EXP 85
50268: NOT
50269: OR
50270: IFFALSE 50274
// exit ;
50272: GO 50464
// for i = 1 to mc_bases do
50274: LD_ADDR_VAR 0 4
50278: PUSH
50279: DOUBLE
50280: LD_INT 1
50282: DEC
50283: ST_TO_ADDR
50284: LD_EXP 87
50288: PUSH
50289: FOR_TO
50290: IFFALSE 50377
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
50292: LD_VAR 0 1
50296: PUSH
50297: LD_EXP 95
50301: PUSH
50302: LD_VAR 0 4
50306: ARRAY
50307: IN
50308: PUSH
50309: LD_VAR 0 1
50313: PUSH
50314: LD_EXP 96
50318: PUSH
50319: LD_VAR 0 4
50323: ARRAY
50324: IN
50325: NOT
50326: AND
50327: IFFALSE 50375
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
50329: LD_ADDR_EXP 96
50333: PUSH
50334: LD_EXP 96
50338: PPUSH
50339: LD_VAR 0 4
50343: PUSH
50344: LD_EXP 96
50348: PUSH
50349: LD_VAR 0 4
50353: ARRAY
50354: PUSH
50355: LD_INT 1
50357: PLUS
50358: PUSH
50359: EMPTY
50360: LIST
50361: LIST
50362: PPUSH
50363: LD_VAR 0 1
50367: PPUSH
50368: CALL 57967 0 3
50372: ST_TO_ADDR
// break ;
50373: GO 50377
// end ; end ;
50375: GO 50289
50377: POP
50378: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
50379: LD_VAR 0 1
50383: PPUSH
50384: CALL_OW 257
50388: PUSH
50389: LD_EXP 113
50393: IN
50394: PUSH
50395: LD_VAR 0 1
50399: PPUSH
50400: CALL_OW 266
50404: PUSH
50405: LD_INT 5
50407: EQUAL
50408: AND
50409: PUSH
50410: LD_VAR 0 2
50414: PPUSH
50415: CALL_OW 110
50419: PUSH
50420: LD_INT 18
50422: NONEQUAL
50423: AND
50424: IFFALSE 50464
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
50426: LD_VAR 0 2
50430: PPUSH
50431: CALL_OW 257
50435: PUSH
50436: LD_INT 5
50438: PUSH
50439: LD_INT 8
50441: PUSH
50442: LD_INT 9
50444: PUSH
50445: EMPTY
50446: LIST
50447: LIST
50448: LIST
50449: IN
50450: IFFALSE 50464
// SetClass ( unit , 1 ) ;
50452: LD_VAR 0 2
50456: PPUSH
50457: LD_INT 1
50459: PPUSH
50460: CALL_OW 336
// end ;
50464: LD_VAR 0 3
50468: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
50469: LD_INT 0
50471: PPUSH
50472: PPUSH
// if not mc_bases or not skirmish then
50473: LD_EXP 87
50477: NOT
50478: PUSH
50479: LD_EXP 85
50483: NOT
50484: OR
50485: IFFALSE 50489
// exit ;
50487: GO 50605
// if GetLives ( abandoned_vehicle ) > 250 then
50489: LD_VAR 0 2
50493: PPUSH
50494: CALL_OW 256
50498: PUSH
50499: LD_INT 250
50501: GREATER
50502: IFFALSE 50506
// exit ;
50504: GO 50605
// for i = 1 to mc_bases do
50506: LD_ADDR_VAR 0 6
50510: PUSH
50511: DOUBLE
50512: LD_INT 1
50514: DEC
50515: ST_TO_ADDR
50516: LD_EXP 87
50520: PUSH
50521: FOR_TO
50522: IFFALSE 50603
// begin if driver in mc_bases [ i ] then
50524: LD_VAR 0 1
50528: PUSH
50529: LD_EXP 87
50533: PUSH
50534: LD_VAR 0 6
50538: ARRAY
50539: IN
50540: IFFALSE 50601
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
50542: LD_VAR 0 1
50546: PPUSH
50547: LD_EXP 87
50551: PUSH
50552: LD_VAR 0 6
50556: ARRAY
50557: PPUSH
50558: LD_INT 2
50560: PUSH
50561: LD_INT 30
50563: PUSH
50564: LD_INT 0
50566: PUSH
50567: EMPTY
50568: LIST
50569: LIST
50570: PUSH
50571: LD_INT 30
50573: PUSH
50574: LD_INT 1
50576: PUSH
50577: EMPTY
50578: LIST
50579: LIST
50580: PUSH
50581: EMPTY
50582: LIST
50583: LIST
50584: LIST
50585: PPUSH
50586: CALL_OW 72
50590: PUSH
50591: LD_INT 1
50593: ARRAY
50594: PPUSH
50595: CALL_OW 112
// break ;
50599: GO 50603
// end ; end ;
50601: GO 50521
50603: POP
50604: POP
// end ; end_of_file
50605: LD_VAR 0 5
50609: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
50610: LD_INT 0
50612: PPUSH
50613: PPUSH
// if exist_mode then
50614: LD_VAR 0 2
50618: IFFALSE 50643
// unit := CreateCharacter ( prefix & ident ) else
50620: LD_ADDR_VAR 0 5
50624: PUSH
50625: LD_VAR 0 3
50629: PUSH
50630: LD_VAR 0 1
50634: STR
50635: PPUSH
50636: CALL_OW 34
50640: ST_TO_ADDR
50641: GO 50658
// unit := NewCharacter ( ident ) ;
50643: LD_ADDR_VAR 0 5
50647: PUSH
50648: LD_VAR 0 1
50652: PPUSH
50653: CALL_OW 25
50657: ST_TO_ADDR
// result := unit ;
50658: LD_ADDR_VAR 0 4
50662: PUSH
50663: LD_VAR 0 5
50667: ST_TO_ADDR
// end ;
50668: LD_VAR 0 4
50672: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
50673: LD_INT 0
50675: PPUSH
50676: PPUSH
// if not side or not nation then
50677: LD_VAR 0 1
50681: NOT
50682: PUSH
50683: LD_VAR 0 2
50687: NOT
50688: OR
50689: IFFALSE 50693
// exit ;
50691: GO 51457
// case nation of nation_american :
50693: LD_VAR 0 2
50697: PUSH
50698: LD_INT 1
50700: DOUBLE
50701: EQUAL
50702: IFTRUE 50706
50704: GO 50920
50706: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
50707: LD_ADDR_VAR 0 4
50711: PUSH
50712: LD_INT 35
50714: PUSH
50715: LD_INT 45
50717: PUSH
50718: LD_INT 46
50720: PUSH
50721: LD_INT 47
50723: PUSH
50724: LD_INT 82
50726: PUSH
50727: LD_INT 83
50729: PUSH
50730: LD_INT 84
50732: PUSH
50733: LD_INT 85
50735: PUSH
50736: LD_INT 86
50738: PUSH
50739: LD_INT 1
50741: PUSH
50742: LD_INT 2
50744: PUSH
50745: LD_INT 6
50747: PUSH
50748: LD_INT 15
50750: PUSH
50751: LD_INT 16
50753: PUSH
50754: LD_INT 7
50756: PUSH
50757: LD_INT 12
50759: PUSH
50760: LD_INT 13
50762: PUSH
50763: LD_INT 10
50765: PUSH
50766: LD_INT 14
50768: PUSH
50769: LD_INT 20
50771: PUSH
50772: LD_INT 21
50774: PUSH
50775: LD_INT 22
50777: PUSH
50778: LD_INT 25
50780: PUSH
50781: LD_INT 32
50783: PUSH
50784: LD_INT 27
50786: PUSH
50787: LD_INT 36
50789: PUSH
50790: LD_INT 69
50792: PUSH
50793: LD_INT 39
50795: PUSH
50796: LD_INT 34
50798: PUSH
50799: LD_INT 40
50801: PUSH
50802: LD_INT 48
50804: PUSH
50805: LD_INT 49
50807: PUSH
50808: LD_INT 50
50810: PUSH
50811: LD_INT 51
50813: PUSH
50814: LD_INT 52
50816: PUSH
50817: LD_INT 53
50819: PUSH
50820: LD_INT 54
50822: PUSH
50823: LD_INT 55
50825: PUSH
50826: LD_INT 56
50828: PUSH
50829: LD_INT 57
50831: PUSH
50832: LD_INT 58
50834: PUSH
50835: LD_INT 59
50837: PUSH
50838: LD_INT 60
50840: PUSH
50841: LD_INT 61
50843: PUSH
50844: LD_INT 62
50846: PUSH
50847: LD_INT 80
50849: PUSH
50850: LD_INT 82
50852: PUSH
50853: LD_INT 83
50855: PUSH
50856: LD_INT 84
50858: PUSH
50859: LD_INT 85
50861: PUSH
50862: LD_INT 86
50864: PUSH
50865: EMPTY
50866: LIST
50867: LIST
50868: LIST
50869: LIST
50870: LIST
50871: LIST
50872: LIST
50873: LIST
50874: LIST
50875: LIST
50876: LIST
50877: LIST
50878: LIST
50879: LIST
50880: LIST
50881: LIST
50882: LIST
50883: LIST
50884: LIST
50885: LIST
50886: LIST
50887: LIST
50888: LIST
50889: LIST
50890: LIST
50891: LIST
50892: LIST
50893: LIST
50894: LIST
50895: LIST
50896: LIST
50897: LIST
50898: LIST
50899: LIST
50900: LIST
50901: LIST
50902: LIST
50903: LIST
50904: LIST
50905: LIST
50906: LIST
50907: LIST
50908: LIST
50909: LIST
50910: LIST
50911: LIST
50912: LIST
50913: LIST
50914: LIST
50915: LIST
50916: LIST
50917: ST_TO_ADDR
50918: GO 51381
50920: LD_INT 2
50922: DOUBLE
50923: EQUAL
50924: IFTRUE 50928
50926: GO 51150
50928: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
50929: LD_ADDR_VAR 0 4
50933: PUSH
50934: LD_INT 35
50936: PUSH
50937: LD_INT 45
50939: PUSH
50940: LD_INT 46
50942: PUSH
50943: LD_INT 47
50945: PUSH
50946: LD_INT 82
50948: PUSH
50949: LD_INT 83
50951: PUSH
50952: LD_INT 84
50954: PUSH
50955: LD_INT 85
50957: PUSH
50958: LD_INT 87
50960: PUSH
50961: LD_INT 70
50963: PUSH
50964: LD_INT 1
50966: PUSH
50967: LD_INT 11
50969: PUSH
50970: LD_INT 3
50972: PUSH
50973: LD_INT 4
50975: PUSH
50976: LD_INT 5
50978: PUSH
50979: LD_INT 6
50981: PUSH
50982: LD_INT 15
50984: PUSH
50985: LD_INT 18
50987: PUSH
50988: LD_INT 7
50990: PUSH
50991: LD_INT 17
50993: PUSH
50994: LD_INT 8
50996: PUSH
50997: LD_INT 20
50999: PUSH
51000: LD_INT 21
51002: PUSH
51003: LD_INT 22
51005: PUSH
51006: LD_INT 72
51008: PUSH
51009: LD_INT 26
51011: PUSH
51012: LD_INT 69
51014: PUSH
51015: LD_INT 39
51017: PUSH
51018: LD_INT 40
51020: PUSH
51021: LD_INT 41
51023: PUSH
51024: LD_INT 42
51026: PUSH
51027: LD_INT 43
51029: PUSH
51030: LD_INT 48
51032: PUSH
51033: LD_INT 49
51035: PUSH
51036: LD_INT 50
51038: PUSH
51039: LD_INT 51
51041: PUSH
51042: LD_INT 52
51044: PUSH
51045: LD_INT 53
51047: PUSH
51048: LD_INT 54
51050: PUSH
51051: LD_INT 55
51053: PUSH
51054: LD_INT 56
51056: PUSH
51057: LD_INT 60
51059: PUSH
51060: LD_INT 61
51062: PUSH
51063: LD_INT 62
51065: PUSH
51066: LD_INT 66
51068: PUSH
51069: LD_INT 67
51071: PUSH
51072: LD_INT 68
51074: PUSH
51075: LD_INT 81
51077: PUSH
51078: LD_INT 82
51080: PUSH
51081: LD_INT 83
51083: PUSH
51084: LD_INT 84
51086: PUSH
51087: LD_INT 85
51089: PUSH
51090: LD_INT 87
51092: PUSH
51093: EMPTY
51094: LIST
51095: LIST
51096: LIST
51097: LIST
51098: LIST
51099: LIST
51100: LIST
51101: LIST
51102: LIST
51103: LIST
51104: LIST
51105: LIST
51106: LIST
51107: LIST
51108: LIST
51109: LIST
51110: LIST
51111: LIST
51112: LIST
51113: LIST
51114: LIST
51115: LIST
51116: LIST
51117: LIST
51118: LIST
51119: LIST
51120: LIST
51121: LIST
51122: LIST
51123: LIST
51124: LIST
51125: LIST
51126: LIST
51127: LIST
51128: LIST
51129: LIST
51130: LIST
51131: LIST
51132: LIST
51133: LIST
51134: LIST
51135: LIST
51136: LIST
51137: LIST
51138: LIST
51139: LIST
51140: LIST
51141: LIST
51142: LIST
51143: LIST
51144: LIST
51145: LIST
51146: LIST
51147: ST_TO_ADDR
51148: GO 51381
51150: LD_INT 3
51152: DOUBLE
51153: EQUAL
51154: IFTRUE 51158
51156: GO 51380
51158: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
51159: LD_ADDR_VAR 0 4
51163: PUSH
51164: LD_INT 46
51166: PUSH
51167: LD_INT 47
51169: PUSH
51170: LD_INT 1
51172: PUSH
51173: LD_INT 2
51175: PUSH
51176: LD_INT 82
51178: PUSH
51179: LD_INT 83
51181: PUSH
51182: LD_INT 84
51184: PUSH
51185: LD_INT 85
51187: PUSH
51188: LD_INT 86
51190: PUSH
51191: LD_INT 11
51193: PUSH
51194: LD_INT 9
51196: PUSH
51197: LD_INT 20
51199: PUSH
51200: LD_INT 19
51202: PUSH
51203: LD_INT 21
51205: PUSH
51206: LD_INT 24
51208: PUSH
51209: LD_INT 22
51211: PUSH
51212: LD_INT 25
51214: PUSH
51215: LD_INT 28
51217: PUSH
51218: LD_INT 29
51220: PUSH
51221: LD_INT 30
51223: PUSH
51224: LD_INT 31
51226: PUSH
51227: LD_INT 37
51229: PUSH
51230: LD_INT 38
51232: PUSH
51233: LD_INT 32
51235: PUSH
51236: LD_INT 27
51238: PUSH
51239: LD_INT 33
51241: PUSH
51242: LD_INT 69
51244: PUSH
51245: LD_INT 39
51247: PUSH
51248: LD_INT 34
51250: PUSH
51251: LD_INT 40
51253: PUSH
51254: LD_INT 71
51256: PUSH
51257: LD_INT 23
51259: PUSH
51260: LD_INT 44
51262: PUSH
51263: LD_INT 48
51265: PUSH
51266: LD_INT 49
51268: PUSH
51269: LD_INT 50
51271: PUSH
51272: LD_INT 51
51274: PUSH
51275: LD_INT 52
51277: PUSH
51278: LD_INT 53
51280: PUSH
51281: LD_INT 54
51283: PUSH
51284: LD_INT 55
51286: PUSH
51287: LD_INT 56
51289: PUSH
51290: LD_INT 57
51292: PUSH
51293: LD_INT 58
51295: PUSH
51296: LD_INT 59
51298: PUSH
51299: LD_INT 63
51301: PUSH
51302: LD_INT 64
51304: PUSH
51305: LD_INT 65
51307: PUSH
51308: LD_INT 82
51310: PUSH
51311: LD_INT 83
51313: PUSH
51314: LD_INT 84
51316: PUSH
51317: LD_INT 85
51319: PUSH
51320: LD_INT 86
51322: PUSH
51323: EMPTY
51324: LIST
51325: LIST
51326: LIST
51327: LIST
51328: LIST
51329: LIST
51330: LIST
51331: LIST
51332: LIST
51333: LIST
51334: LIST
51335: LIST
51336: LIST
51337: LIST
51338: LIST
51339: LIST
51340: LIST
51341: LIST
51342: LIST
51343: LIST
51344: LIST
51345: LIST
51346: LIST
51347: LIST
51348: LIST
51349: LIST
51350: LIST
51351: LIST
51352: LIST
51353: LIST
51354: LIST
51355: LIST
51356: LIST
51357: LIST
51358: LIST
51359: LIST
51360: LIST
51361: LIST
51362: LIST
51363: LIST
51364: LIST
51365: LIST
51366: LIST
51367: LIST
51368: LIST
51369: LIST
51370: LIST
51371: LIST
51372: LIST
51373: LIST
51374: LIST
51375: LIST
51376: LIST
51377: ST_TO_ADDR
51378: GO 51381
51380: POP
// if state > - 1 and state < 3 then
51381: LD_VAR 0 3
51385: PUSH
51386: LD_INT 1
51388: NEG
51389: GREATER
51390: PUSH
51391: LD_VAR 0 3
51395: PUSH
51396: LD_INT 3
51398: LESS
51399: AND
51400: IFFALSE 51457
// for i in result do
51402: LD_ADDR_VAR 0 5
51406: PUSH
51407: LD_VAR 0 4
51411: PUSH
51412: FOR_IN
51413: IFFALSE 51455
// if GetTech ( i , side ) <> state then
51415: LD_VAR 0 5
51419: PPUSH
51420: LD_VAR 0 1
51424: PPUSH
51425: CALL_OW 321
51429: PUSH
51430: LD_VAR 0 3
51434: NONEQUAL
51435: IFFALSE 51453
// result := result diff i ;
51437: LD_ADDR_VAR 0 4
51441: PUSH
51442: LD_VAR 0 4
51446: PUSH
51447: LD_VAR 0 5
51451: DIFF
51452: ST_TO_ADDR
51453: GO 51412
51455: POP
51456: POP
// end ;
51457: LD_VAR 0 4
51461: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
51462: LD_INT 0
51464: PPUSH
51465: PPUSH
51466: PPUSH
// result := true ;
51467: LD_ADDR_VAR 0 3
51471: PUSH
51472: LD_INT 1
51474: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
51475: LD_ADDR_VAR 0 5
51479: PUSH
51480: LD_VAR 0 2
51484: PPUSH
51485: CALL_OW 480
51489: ST_TO_ADDR
// if not tmp then
51490: LD_VAR 0 5
51494: NOT
51495: IFFALSE 51499
// exit ;
51497: GO 51548
// for i in tmp do
51499: LD_ADDR_VAR 0 4
51503: PUSH
51504: LD_VAR 0 5
51508: PUSH
51509: FOR_IN
51510: IFFALSE 51546
// if GetTech ( i , side ) <> state_researched then
51512: LD_VAR 0 4
51516: PPUSH
51517: LD_VAR 0 1
51521: PPUSH
51522: CALL_OW 321
51526: PUSH
51527: LD_INT 2
51529: NONEQUAL
51530: IFFALSE 51544
// begin result := false ;
51532: LD_ADDR_VAR 0 3
51536: PUSH
51537: LD_INT 0
51539: ST_TO_ADDR
// exit ;
51540: POP
51541: POP
51542: GO 51548
// end ;
51544: GO 51509
51546: POP
51547: POP
// end ;
51548: LD_VAR 0 3
51552: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
51553: LD_INT 0
51555: PPUSH
51556: PPUSH
51557: PPUSH
51558: PPUSH
51559: PPUSH
51560: PPUSH
51561: PPUSH
51562: PPUSH
51563: PPUSH
51564: PPUSH
51565: PPUSH
51566: PPUSH
51567: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
51568: LD_VAR 0 1
51572: NOT
51573: PUSH
51574: LD_VAR 0 1
51578: PPUSH
51579: CALL_OW 257
51583: PUSH
51584: LD_INT 9
51586: NONEQUAL
51587: OR
51588: IFFALSE 51592
// exit ;
51590: GO 52165
// side := GetSide ( unit ) ;
51592: LD_ADDR_VAR 0 9
51596: PUSH
51597: LD_VAR 0 1
51601: PPUSH
51602: CALL_OW 255
51606: ST_TO_ADDR
// tech_space := tech_spacanom ;
51607: LD_ADDR_VAR 0 12
51611: PUSH
51612: LD_INT 29
51614: ST_TO_ADDR
// tech_time := tech_taurad ;
51615: LD_ADDR_VAR 0 13
51619: PUSH
51620: LD_INT 28
51622: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
51623: LD_ADDR_VAR 0 11
51627: PUSH
51628: LD_VAR 0 1
51632: PPUSH
51633: CALL_OW 310
51637: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
51638: LD_VAR 0 11
51642: PPUSH
51643: CALL_OW 247
51647: PUSH
51648: LD_INT 2
51650: EQUAL
51651: IFFALSE 51655
// exit ;
51653: GO 52165
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
51655: LD_ADDR_VAR 0 8
51659: PUSH
51660: LD_INT 81
51662: PUSH
51663: LD_VAR 0 9
51667: PUSH
51668: EMPTY
51669: LIST
51670: LIST
51671: PUSH
51672: LD_INT 3
51674: PUSH
51675: LD_INT 21
51677: PUSH
51678: LD_INT 3
51680: PUSH
51681: EMPTY
51682: LIST
51683: LIST
51684: PUSH
51685: EMPTY
51686: LIST
51687: LIST
51688: PUSH
51689: EMPTY
51690: LIST
51691: LIST
51692: PPUSH
51693: CALL_OW 69
51697: ST_TO_ADDR
// if not tmp then
51698: LD_VAR 0 8
51702: NOT
51703: IFFALSE 51707
// exit ;
51705: GO 52165
// if in_unit then
51707: LD_VAR 0 11
51711: IFFALSE 51735
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
51713: LD_ADDR_VAR 0 10
51717: PUSH
51718: LD_VAR 0 8
51722: PPUSH
51723: LD_VAR 0 11
51727: PPUSH
51728: CALL_OW 74
51732: ST_TO_ADDR
51733: GO 51755
// enemy := NearestUnitToUnit ( tmp , unit ) ;
51735: LD_ADDR_VAR 0 10
51739: PUSH
51740: LD_VAR 0 8
51744: PPUSH
51745: LD_VAR 0 1
51749: PPUSH
51750: CALL_OW 74
51754: ST_TO_ADDR
// if not enemy then
51755: LD_VAR 0 10
51759: NOT
51760: IFFALSE 51764
// exit ;
51762: GO 52165
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
51764: LD_VAR 0 11
51768: PUSH
51769: LD_VAR 0 11
51773: PPUSH
51774: LD_VAR 0 10
51778: PPUSH
51779: CALL_OW 296
51783: PUSH
51784: LD_INT 13
51786: GREATER
51787: AND
51788: PUSH
51789: LD_VAR 0 1
51793: PPUSH
51794: LD_VAR 0 10
51798: PPUSH
51799: CALL_OW 296
51803: PUSH
51804: LD_INT 12
51806: GREATER
51807: OR
51808: IFFALSE 51812
// exit ;
51810: GO 52165
// missile := [ 1 ] ;
51812: LD_ADDR_VAR 0 14
51816: PUSH
51817: LD_INT 1
51819: PUSH
51820: EMPTY
51821: LIST
51822: ST_TO_ADDR
// if Researched ( side , tech_space ) then
51823: LD_VAR 0 9
51827: PPUSH
51828: LD_VAR 0 12
51832: PPUSH
51833: CALL_OW 325
51837: IFFALSE 51866
// missile := Insert ( missile , missile + 1 , 2 ) ;
51839: LD_ADDR_VAR 0 14
51843: PUSH
51844: LD_VAR 0 14
51848: PPUSH
51849: LD_VAR 0 14
51853: PUSH
51854: LD_INT 1
51856: PLUS
51857: PPUSH
51858: LD_INT 2
51860: PPUSH
51861: CALL_OW 2
51865: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
51866: LD_VAR 0 9
51870: PPUSH
51871: LD_VAR 0 13
51875: PPUSH
51876: CALL_OW 325
51880: PUSH
51881: LD_VAR 0 10
51885: PPUSH
51886: CALL_OW 255
51890: PPUSH
51891: LD_VAR 0 13
51895: PPUSH
51896: CALL_OW 325
51900: NOT
51901: AND
51902: IFFALSE 51931
// missile := Insert ( missile , missile + 1 , 3 ) ;
51904: LD_ADDR_VAR 0 14
51908: PUSH
51909: LD_VAR 0 14
51913: PPUSH
51914: LD_VAR 0 14
51918: PUSH
51919: LD_INT 1
51921: PLUS
51922: PPUSH
51923: LD_INT 3
51925: PPUSH
51926: CALL_OW 2
51930: ST_TO_ADDR
// if missile < 2 then
51931: LD_VAR 0 14
51935: PUSH
51936: LD_INT 2
51938: LESS
51939: IFFALSE 51943
// exit ;
51941: GO 52165
// x := GetX ( enemy ) ;
51943: LD_ADDR_VAR 0 4
51947: PUSH
51948: LD_VAR 0 10
51952: PPUSH
51953: CALL_OW 250
51957: ST_TO_ADDR
// y := GetY ( enemy ) ;
51958: LD_ADDR_VAR 0 5
51962: PUSH
51963: LD_VAR 0 10
51967: PPUSH
51968: CALL_OW 251
51972: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
51973: LD_ADDR_VAR 0 6
51977: PUSH
51978: LD_VAR 0 4
51982: PUSH
51983: LD_INT 1
51985: NEG
51986: PPUSH
51987: LD_INT 1
51989: PPUSH
51990: CALL_OW 12
51994: PLUS
51995: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
51996: LD_ADDR_VAR 0 7
52000: PUSH
52001: LD_VAR 0 5
52005: PUSH
52006: LD_INT 1
52008: NEG
52009: PPUSH
52010: LD_INT 1
52012: PPUSH
52013: CALL_OW 12
52017: PLUS
52018: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
52019: LD_VAR 0 6
52023: PPUSH
52024: LD_VAR 0 7
52028: PPUSH
52029: CALL_OW 488
52033: NOT
52034: IFFALSE 52056
// begin _x := x ;
52036: LD_ADDR_VAR 0 6
52040: PUSH
52041: LD_VAR 0 4
52045: ST_TO_ADDR
// _y := y ;
52046: LD_ADDR_VAR 0 7
52050: PUSH
52051: LD_VAR 0 5
52055: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
52056: LD_ADDR_VAR 0 3
52060: PUSH
52061: LD_INT 1
52063: PPUSH
52064: LD_VAR 0 14
52068: PPUSH
52069: CALL_OW 12
52073: ST_TO_ADDR
// case i of 1 :
52074: LD_VAR 0 3
52078: PUSH
52079: LD_INT 1
52081: DOUBLE
52082: EQUAL
52083: IFTRUE 52087
52085: GO 52104
52087: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
52088: LD_VAR 0 1
52092: PPUSH
52093: LD_VAR 0 10
52097: PPUSH
52098: CALL_OW 115
52102: GO 52165
52104: LD_INT 2
52106: DOUBLE
52107: EQUAL
52108: IFTRUE 52112
52110: GO 52134
52112: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
52113: LD_VAR 0 1
52117: PPUSH
52118: LD_VAR 0 6
52122: PPUSH
52123: LD_VAR 0 7
52127: PPUSH
52128: CALL_OW 153
52132: GO 52165
52134: LD_INT 3
52136: DOUBLE
52137: EQUAL
52138: IFTRUE 52142
52140: GO 52164
52142: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
52143: LD_VAR 0 1
52147: PPUSH
52148: LD_VAR 0 6
52152: PPUSH
52153: LD_VAR 0 7
52157: PPUSH
52158: CALL_OW 154
52162: GO 52165
52164: POP
// end ;
52165: LD_VAR 0 2
52169: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
52170: LD_INT 0
52172: PPUSH
52173: PPUSH
52174: PPUSH
52175: PPUSH
52176: PPUSH
52177: PPUSH
// if not unit or not building then
52178: LD_VAR 0 1
52182: NOT
52183: PUSH
52184: LD_VAR 0 2
52188: NOT
52189: OR
52190: IFFALSE 52194
// exit ;
52192: GO 52352
// x := GetX ( building ) ;
52194: LD_ADDR_VAR 0 5
52198: PUSH
52199: LD_VAR 0 2
52203: PPUSH
52204: CALL_OW 250
52208: ST_TO_ADDR
// y := GetY ( building ) ;
52209: LD_ADDR_VAR 0 6
52213: PUSH
52214: LD_VAR 0 2
52218: PPUSH
52219: CALL_OW 251
52223: ST_TO_ADDR
// for i = 0 to 5 do
52224: LD_ADDR_VAR 0 4
52228: PUSH
52229: DOUBLE
52230: LD_INT 0
52232: DEC
52233: ST_TO_ADDR
52234: LD_INT 5
52236: PUSH
52237: FOR_TO
52238: IFFALSE 52350
// begin _x := ShiftX ( x , i , 3 ) ;
52240: LD_ADDR_VAR 0 7
52244: PUSH
52245: LD_VAR 0 5
52249: PPUSH
52250: LD_VAR 0 4
52254: PPUSH
52255: LD_INT 3
52257: PPUSH
52258: CALL_OW 272
52262: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
52263: LD_ADDR_VAR 0 8
52267: PUSH
52268: LD_VAR 0 6
52272: PPUSH
52273: LD_VAR 0 4
52277: PPUSH
52278: LD_INT 3
52280: PPUSH
52281: CALL_OW 273
52285: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
52286: LD_VAR 0 7
52290: PPUSH
52291: LD_VAR 0 8
52295: PPUSH
52296: CALL_OW 488
52300: NOT
52301: IFFALSE 52305
// continue ;
52303: GO 52237
// if HexInfo ( _x , _y ) = 0 then
52305: LD_VAR 0 7
52309: PPUSH
52310: LD_VAR 0 8
52314: PPUSH
52315: CALL_OW 428
52319: PUSH
52320: LD_INT 0
52322: EQUAL
52323: IFFALSE 52348
// begin ComMoveXY ( unit , _x , _y ) ;
52325: LD_VAR 0 1
52329: PPUSH
52330: LD_VAR 0 7
52334: PPUSH
52335: LD_VAR 0 8
52339: PPUSH
52340: CALL_OW 111
// exit ;
52344: POP
52345: POP
52346: GO 52352
// end ; end ;
52348: GO 52237
52350: POP
52351: POP
// end ;
52352: LD_VAR 0 3
52356: RET
// export function ScanBase ( side , base_area ) ; begin
52357: LD_INT 0
52359: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
52360: LD_ADDR_VAR 0 3
52364: PUSH
52365: LD_VAR 0 2
52369: PPUSH
52370: LD_INT 81
52372: PUSH
52373: LD_VAR 0 1
52377: PUSH
52378: EMPTY
52379: LIST
52380: LIST
52381: PPUSH
52382: CALL_OW 70
52386: ST_TO_ADDR
// end ;
52387: LD_VAR 0 3
52391: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
52392: LD_INT 0
52394: PPUSH
52395: PPUSH
52396: PPUSH
52397: PPUSH
52398: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
52399: LD_VAR 0 1
52403: NOT
52404: PUSH
52405: LD_EXP 87
52409: PUSH
52410: LD_VAR 0 1
52414: ARRAY
52415: NOT
52416: OR
52417: PUSH
52418: LD_VAR 0 2
52422: NOT
52423: OR
52424: PUSH
52425: LD_VAR 0 3
52429: NOT
52430: OR
52431: IFFALSE 52435
// exit ;
52433: GO 52948
// side := mc_sides [ base ] ;
52435: LD_ADDR_VAR 0 6
52439: PUSH
52440: LD_EXP 113
52444: PUSH
52445: LD_VAR 0 1
52449: ARRAY
52450: ST_TO_ADDR
// if not side then
52451: LD_VAR 0 6
52455: NOT
52456: IFFALSE 52460
// exit ;
52458: GO 52948
// for i in solds do
52460: LD_ADDR_VAR 0 7
52464: PUSH
52465: LD_VAR 0 2
52469: PUSH
52470: FOR_IN
52471: IFFALSE 52532
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
52473: LD_VAR 0 7
52477: PPUSH
52478: CALL_OW 310
52482: PPUSH
52483: CALL_OW 266
52487: PUSH
52488: LD_INT 32
52490: PUSH
52491: LD_INT 31
52493: PUSH
52494: EMPTY
52495: LIST
52496: LIST
52497: IN
52498: IFFALSE 52518
// solds := solds diff i else
52500: LD_ADDR_VAR 0 2
52504: PUSH
52505: LD_VAR 0 2
52509: PUSH
52510: LD_VAR 0 7
52514: DIFF
52515: ST_TO_ADDR
52516: GO 52530
// SetTag ( i , 18 ) ;
52518: LD_VAR 0 7
52522: PPUSH
52523: LD_INT 18
52525: PPUSH
52526: CALL_OW 109
52530: GO 52470
52532: POP
52533: POP
// if not solds then
52534: LD_VAR 0 2
52538: NOT
52539: IFFALSE 52543
// exit ;
52541: GO 52948
// repeat wait ( 0 0$1 ) ;
52543: LD_INT 35
52545: PPUSH
52546: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
52550: LD_ADDR_VAR 0 5
52554: PUSH
52555: LD_VAR 0 6
52559: PPUSH
52560: LD_VAR 0 3
52564: PPUSH
52565: CALL 52357 0 2
52569: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
52570: LD_EXP 87
52574: PUSH
52575: LD_VAR 0 1
52579: ARRAY
52580: NOT
52581: PUSH
52582: LD_EXP 87
52586: PUSH
52587: LD_VAR 0 1
52591: ARRAY
52592: PUSH
52593: EMPTY
52594: EQUAL
52595: OR
52596: IFFALSE 52633
// begin for i in solds do
52598: LD_ADDR_VAR 0 7
52602: PUSH
52603: LD_VAR 0 2
52607: PUSH
52608: FOR_IN
52609: IFFALSE 52622
// ComStop ( i ) ;
52611: LD_VAR 0 7
52615: PPUSH
52616: CALL_OW 141
52620: GO 52608
52622: POP
52623: POP
// solds := [ ] ;
52624: LD_ADDR_VAR 0 2
52628: PUSH
52629: EMPTY
52630: ST_TO_ADDR
// exit ;
52631: GO 52948
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
52633: LD_VAR 0 5
52637: NOT
52638: PUSH
52639: LD_VAR 0 5
52643: PUSH
52644: LD_INT 3
52646: GREATER
52647: OR
52648: PUSH
52649: LD_EXP 109
52653: PUSH
52654: LD_VAR 0 1
52658: ARRAY
52659: OR
52660: IFFALSE 52701
// begin for i in solds do
52662: LD_ADDR_VAR 0 7
52666: PUSH
52667: LD_VAR 0 2
52671: PUSH
52672: FOR_IN
52673: IFFALSE 52697
// if HasTask ( i ) then
52675: LD_VAR 0 7
52679: PPUSH
52680: CALL_OW 314
52684: IFFALSE 52695
// ComStop ( i ) ;
52686: LD_VAR 0 7
52690: PPUSH
52691: CALL_OW 141
52695: GO 52672
52697: POP
52698: POP
// break ;
52699: GO 52936
// end ; for i in solds do
52701: LD_ADDR_VAR 0 7
52705: PUSH
52706: LD_VAR 0 2
52710: PUSH
52711: FOR_IN
52712: IFFALSE 52928
// begin if IsInUnit ( i ) then
52714: LD_VAR 0 7
52718: PPUSH
52719: CALL_OW 310
52723: IFFALSE 52734
// ComExitBuilding ( i ) ;
52725: LD_VAR 0 7
52729: PPUSH
52730: CALL_OW 122
// if GetLives ( i ) > 333 then
52734: LD_VAR 0 7
52738: PPUSH
52739: CALL_OW 256
52743: PUSH
52744: LD_INT 333
52746: GREATER
52747: IFFALSE 52775
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
52749: LD_VAR 0 7
52753: PPUSH
52754: LD_VAR 0 5
52758: PPUSH
52759: LD_VAR 0 7
52763: PPUSH
52764: CALL_OW 74
52768: PPUSH
52769: CALL_OW 115
52773: GO 52926
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
52775: LD_ADDR_VAR 0 8
52779: PUSH
52780: LD_EXP 87
52784: PUSH
52785: LD_VAR 0 1
52789: ARRAY
52790: PPUSH
52791: LD_INT 2
52793: PUSH
52794: LD_INT 30
52796: PUSH
52797: LD_INT 0
52799: PUSH
52800: EMPTY
52801: LIST
52802: LIST
52803: PUSH
52804: LD_INT 30
52806: PUSH
52807: LD_INT 1
52809: PUSH
52810: EMPTY
52811: LIST
52812: LIST
52813: PUSH
52814: LD_INT 30
52816: PUSH
52817: LD_INT 6
52819: PUSH
52820: EMPTY
52821: LIST
52822: LIST
52823: PUSH
52824: EMPTY
52825: LIST
52826: LIST
52827: LIST
52828: LIST
52829: PPUSH
52830: CALL_OW 72
52834: PPUSH
52835: LD_VAR 0 7
52839: PPUSH
52840: CALL_OW 74
52844: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
52845: LD_VAR 0 7
52849: PPUSH
52850: LD_VAR 0 8
52854: PPUSH
52855: CALL_OW 250
52859: PPUSH
52860: LD_INT 3
52862: PPUSH
52863: LD_INT 5
52865: PPUSH
52866: CALL_OW 272
52870: PPUSH
52871: LD_VAR 0 8
52875: PPUSH
52876: CALL_OW 251
52880: PPUSH
52881: LD_INT 3
52883: PPUSH
52884: LD_INT 5
52886: PPUSH
52887: CALL_OW 273
52891: PPUSH
52892: CALL_OW 111
// SetTag ( i , 0 ) ;
52896: LD_VAR 0 7
52900: PPUSH
52901: LD_INT 0
52903: PPUSH
52904: CALL_OW 109
// solds := solds diff i ;
52908: LD_ADDR_VAR 0 2
52912: PUSH
52913: LD_VAR 0 2
52917: PUSH
52918: LD_VAR 0 7
52922: DIFF
52923: ST_TO_ADDR
// continue ;
52924: GO 52711
// end ; end ;
52926: GO 52711
52928: POP
52929: POP
// until solds ;
52930: LD_VAR 0 2
52934: IFFALSE 52543
// MC_Reset ( base , 18 ) ;
52936: LD_VAR 0 1
52940: PPUSH
52941: LD_INT 18
52943: PPUSH
52944: CALL 24649 0 2
// end ;
52948: LD_VAR 0 4
52952: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
52953: LD_INT 0
52955: PPUSH
52956: PPUSH
52957: PPUSH
52958: PPUSH
52959: PPUSH
52960: PPUSH
52961: PPUSH
52962: PPUSH
52963: PPUSH
52964: PPUSH
52965: PPUSH
52966: PPUSH
52967: PPUSH
52968: PPUSH
52969: PPUSH
52970: PPUSH
52971: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
52972: LD_ADDR_VAR 0 13
52976: PUSH
52977: LD_EXP 87
52981: PUSH
52982: LD_VAR 0 1
52986: ARRAY
52987: PPUSH
52988: LD_INT 25
52990: PUSH
52991: LD_INT 3
52993: PUSH
52994: EMPTY
52995: LIST
52996: LIST
52997: PPUSH
52998: CALL_OW 72
53002: ST_TO_ADDR
// if mc_remote_driver [ base ] then
53003: LD_EXP 127
53007: PUSH
53008: LD_VAR 0 1
53012: ARRAY
53013: IFFALSE 53037
// mechs := mechs diff mc_remote_driver [ base ] ;
53015: LD_ADDR_VAR 0 13
53019: PUSH
53020: LD_VAR 0 13
53024: PUSH
53025: LD_EXP 127
53029: PUSH
53030: LD_VAR 0 1
53034: ARRAY
53035: DIFF
53036: ST_TO_ADDR
// for i in mechs do
53037: LD_ADDR_VAR 0 5
53041: PUSH
53042: LD_VAR 0 13
53046: PUSH
53047: FOR_IN
53048: IFFALSE 53083
// if GetTag ( i ) > 0 then
53050: LD_VAR 0 5
53054: PPUSH
53055: CALL_OW 110
53059: PUSH
53060: LD_INT 0
53062: GREATER
53063: IFFALSE 53081
// mechs := mechs diff i ;
53065: LD_ADDR_VAR 0 13
53069: PUSH
53070: LD_VAR 0 13
53074: PUSH
53075: LD_VAR 0 5
53079: DIFF
53080: ST_TO_ADDR
53081: GO 53047
53083: POP
53084: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
53085: LD_ADDR_VAR 0 9
53089: PUSH
53090: LD_EXP 87
53094: PUSH
53095: LD_VAR 0 1
53099: ARRAY
53100: PPUSH
53101: LD_INT 2
53103: PUSH
53104: LD_INT 25
53106: PUSH
53107: LD_INT 1
53109: PUSH
53110: EMPTY
53111: LIST
53112: LIST
53113: PUSH
53114: LD_INT 25
53116: PUSH
53117: LD_INT 5
53119: PUSH
53120: EMPTY
53121: LIST
53122: LIST
53123: PUSH
53124: LD_INT 25
53126: PUSH
53127: LD_INT 8
53129: PUSH
53130: EMPTY
53131: LIST
53132: LIST
53133: PUSH
53134: LD_INT 25
53136: PUSH
53137: LD_INT 9
53139: PUSH
53140: EMPTY
53141: LIST
53142: LIST
53143: PUSH
53144: EMPTY
53145: LIST
53146: LIST
53147: LIST
53148: LIST
53149: LIST
53150: PPUSH
53151: CALL_OW 72
53155: ST_TO_ADDR
// if not defenders and not solds then
53156: LD_VAR 0 2
53160: NOT
53161: PUSH
53162: LD_VAR 0 9
53166: NOT
53167: AND
53168: IFFALSE 53172
// exit ;
53170: GO 54798
// depot_under_attack := false ;
53172: LD_ADDR_VAR 0 17
53176: PUSH
53177: LD_INT 0
53179: ST_TO_ADDR
// sold_defenders := [ ] ;
53180: LD_ADDR_VAR 0 18
53184: PUSH
53185: EMPTY
53186: ST_TO_ADDR
// if mechs then
53187: LD_VAR 0 13
53191: IFFALSE 53320
// for i in defenders do
53193: LD_ADDR_VAR 0 5
53197: PUSH
53198: LD_VAR 0 2
53202: PUSH
53203: FOR_IN
53204: IFFALSE 53318
// begin SetTag ( i , 20 ) ;
53206: LD_VAR 0 5
53210: PPUSH
53211: LD_INT 20
53213: PPUSH
53214: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
53218: LD_VAR 0 5
53222: PPUSH
53223: CALL_OW 263
53227: PUSH
53228: LD_INT 1
53230: EQUAL
53231: PUSH
53232: LD_VAR 0 5
53236: PPUSH
53237: CALL_OW 311
53241: NOT
53242: AND
53243: PUSH
53244: LD_VAR 0 13
53248: AND
53249: IFFALSE 53316
// begin un := mechs [ 1 ] ;
53251: LD_ADDR_VAR 0 11
53255: PUSH
53256: LD_VAR 0 13
53260: PUSH
53261: LD_INT 1
53263: ARRAY
53264: ST_TO_ADDR
// ComExitBuilding ( un ) ;
53265: LD_VAR 0 11
53269: PPUSH
53270: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
53274: LD_VAR 0 11
53278: PPUSH
53279: LD_VAR 0 5
53283: PPUSH
53284: CALL_OW 180
// SetTag ( un , 19 ) ;
53288: LD_VAR 0 11
53292: PPUSH
53293: LD_INT 19
53295: PPUSH
53296: CALL_OW 109
// mechs := mechs diff un ;
53300: LD_ADDR_VAR 0 13
53304: PUSH
53305: LD_VAR 0 13
53309: PUSH
53310: LD_VAR 0 11
53314: DIFF
53315: ST_TO_ADDR
// end ; end ;
53316: GO 53203
53318: POP
53319: POP
// if solds then
53320: LD_VAR 0 9
53324: IFFALSE 53383
// for i in solds do
53326: LD_ADDR_VAR 0 5
53330: PUSH
53331: LD_VAR 0 9
53335: PUSH
53336: FOR_IN
53337: IFFALSE 53381
// if not GetTag ( i ) then
53339: LD_VAR 0 5
53343: PPUSH
53344: CALL_OW 110
53348: NOT
53349: IFFALSE 53379
// begin defenders := defenders union i ;
53351: LD_ADDR_VAR 0 2
53355: PUSH
53356: LD_VAR 0 2
53360: PUSH
53361: LD_VAR 0 5
53365: UNION
53366: ST_TO_ADDR
// SetTag ( i , 18 ) ;
53367: LD_VAR 0 5
53371: PPUSH
53372: LD_INT 18
53374: PPUSH
53375: CALL_OW 109
// end ;
53379: GO 53336
53381: POP
53382: POP
// repeat wait ( 0 0$1 ) ;
53383: LD_INT 35
53385: PPUSH
53386: CALL_OW 67
// enemy := mc_scan [ base ] ;
53390: LD_ADDR_VAR 0 3
53394: PUSH
53395: LD_EXP 110
53399: PUSH
53400: LD_VAR 0 1
53404: ARRAY
53405: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
53406: LD_EXP 87
53410: PUSH
53411: LD_VAR 0 1
53415: ARRAY
53416: NOT
53417: PUSH
53418: LD_EXP 87
53422: PUSH
53423: LD_VAR 0 1
53427: ARRAY
53428: PUSH
53429: EMPTY
53430: EQUAL
53431: OR
53432: IFFALSE 53469
// begin for i in defenders do
53434: LD_ADDR_VAR 0 5
53438: PUSH
53439: LD_VAR 0 2
53443: PUSH
53444: FOR_IN
53445: IFFALSE 53458
// ComStop ( i ) ;
53447: LD_VAR 0 5
53451: PPUSH
53452: CALL_OW 141
53456: GO 53444
53458: POP
53459: POP
// defenders := [ ] ;
53460: LD_ADDR_VAR 0 2
53464: PUSH
53465: EMPTY
53466: ST_TO_ADDR
// exit ;
53467: GO 54798
// end ; for i in defenders do
53469: LD_ADDR_VAR 0 5
53473: PUSH
53474: LD_VAR 0 2
53478: PUSH
53479: FOR_IN
53480: IFFALSE 54298
// begin e := NearestUnitToUnit ( enemy , i ) ;
53482: LD_ADDR_VAR 0 14
53486: PUSH
53487: LD_VAR 0 3
53491: PPUSH
53492: LD_VAR 0 5
53496: PPUSH
53497: CALL_OW 74
53501: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53502: LD_ADDR_VAR 0 8
53506: PUSH
53507: LD_EXP 87
53511: PUSH
53512: LD_VAR 0 1
53516: ARRAY
53517: PPUSH
53518: LD_INT 2
53520: PUSH
53521: LD_INT 30
53523: PUSH
53524: LD_INT 0
53526: PUSH
53527: EMPTY
53528: LIST
53529: LIST
53530: PUSH
53531: LD_INT 30
53533: PUSH
53534: LD_INT 1
53536: PUSH
53537: EMPTY
53538: LIST
53539: LIST
53540: PUSH
53541: EMPTY
53542: LIST
53543: LIST
53544: LIST
53545: PPUSH
53546: CALL_OW 72
53550: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
53551: LD_ADDR_VAR 0 17
53555: PUSH
53556: LD_VAR 0 8
53560: NOT
53561: PUSH
53562: LD_VAR 0 8
53566: PPUSH
53567: LD_INT 3
53569: PUSH
53570: LD_INT 24
53572: PUSH
53573: LD_INT 600
53575: PUSH
53576: EMPTY
53577: LIST
53578: LIST
53579: PUSH
53580: EMPTY
53581: LIST
53582: LIST
53583: PPUSH
53584: CALL_OW 72
53588: OR
53589: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
53590: LD_VAR 0 5
53594: PPUSH
53595: CALL_OW 247
53599: PUSH
53600: LD_INT 2
53602: DOUBLE
53603: EQUAL
53604: IFTRUE 53608
53606: GO 54004
53608: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
53609: LD_VAR 0 5
53613: PPUSH
53614: CALL_OW 256
53618: PUSH
53619: LD_INT 650
53621: GREATER
53622: PUSH
53623: LD_VAR 0 5
53627: PPUSH
53628: LD_VAR 0 14
53632: PPUSH
53633: CALL_OW 296
53637: PUSH
53638: LD_INT 40
53640: LESS
53641: PUSH
53642: LD_VAR 0 14
53646: PPUSH
53647: LD_EXP 112
53651: PUSH
53652: LD_VAR 0 1
53656: ARRAY
53657: PPUSH
53658: CALL_OW 308
53662: OR
53663: AND
53664: IFFALSE 53786
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
53666: LD_VAR 0 5
53670: PPUSH
53671: CALL_OW 262
53675: PUSH
53676: LD_INT 1
53678: EQUAL
53679: PUSH
53680: LD_VAR 0 5
53684: PPUSH
53685: CALL_OW 261
53689: PUSH
53690: LD_INT 30
53692: LESS
53693: AND
53694: PUSH
53695: LD_VAR 0 8
53699: AND
53700: IFFALSE 53770
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
53702: LD_VAR 0 5
53706: PPUSH
53707: LD_VAR 0 8
53711: PPUSH
53712: LD_VAR 0 5
53716: PPUSH
53717: CALL_OW 74
53721: PPUSH
53722: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
53726: LD_VAR 0 5
53730: PPUSH
53731: LD_VAR 0 8
53735: PPUSH
53736: LD_VAR 0 5
53740: PPUSH
53741: CALL_OW 74
53745: PPUSH
53746: CALL_OW 296
53750: PUSH
53751: LD_INT 6
53753: LESS
53754: IFFALSE 53768
// SetFuel ( i , 100 ) ;
53756: LD_VAR 0 5
53760: PPUSH
53761: LD_INT 100
53763: PPUSH
53764: CALL_OW 240
// end else
53768: GO 53784
// ComAttackUnit ( i , e ) ;
53770: LD_VAR 0 5
53774: PPUSH
53775: LD_VAR 0 14
53779: PPUSH
53780: CALL_OW 115
// end else
53784: GO 53887
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
53786: LD_VAR 0 14
53790: PPUSH
53791: LD_EXP 112
53795: PUSH
53796: LD_VAR 0 1
53800: ARRAY
53801: PPUSH
53802: CALL_OW 308
53806: NOT
53807: PUSH
53808: LD_VAR 0 5
53812: PPUSH
53813: LD_VAR 0 14
53817: PPUSH
53818: CALL_OW 296
53822: PUSH
53823: LD_INT 40
53825: GREATEREQUAL
53826: AND
53827: PUSH
53828: LD_VAR 0 5
53832: PPUSH
53833: CALL_OW 256
53837: PUSH
53838: LD_INT 650
53840: LESSEQUAL
53841: OR
53842: PUSH
53843: LD_VAR 0 5
53847: PPUSH
53848: LD_EXP 111
53852: PUSH
53853: LD_VAR 0 1
53857: ARRAY
53858: PPUSH
53859: CALL_OW 308
53863: NOT
53864: AND
53865: IFFALSE 53887
// ComMoveToArea ( i , mc_parking [ base ] ) ;
53867: LD_VAR 0 5
53871: PPUSH
53872: LD_EXP 111
53876: PUSH
53877: LD_VAR 0 1
53881: ARRAY
53882: PPUSH
53883: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
53887: LD_VAR 0 5
53891: PPUSH
53892: CALL_OW 256
53896: PUSH
53897: LD_INT 998
53899: LESS
53900: PUSH
53901: LD_VAR 0 5
53905: PPUSH
53906: CALL_OW 263
53910: PUSH
53911: LD_INT 1
53913: EQUAL
53914: AND
53915: PUSH
53916: LD_VAR 0 5
53920: PPUSH
53921: CALL_OW 311
53925: AND
53926: PUSH
53927: LD_VAR 0 5
53931: PPUSH
53932: LD_EXP 111
53936: PUSH
53937: LD_VAR 0 1
53941: ARRAY
53942: PPUSH
53943: CALL_OW 308
53947: AND
53948: IFFALSE 54002
// begin mech := IsDrivenBy ( i ) ;
53950: LD_ADDR_VAR 0 10
53954: PUSH
53955: LD_VAR 0 5
53959: PPUSH
53960: CALL_OW 311
53964: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
53965: LD_VAR 0 10
53969: PPUSH
53970: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
53974: LD_VAR 0 10
53978: PPUSH
53979: LD_VAR 0 5
53983: PPUSH
53984: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
53988: LD_VAR 0 10
53992: PPUSH
53993: LD_VAR 0 5
53997: PPUSH
53998: CALL_OW 180
// end ; end ; unit_human :
54002: GO 54269
54004: LD_INT 1
54006: DOUBLE
54007: EQUAL
54008: IFTRUE 54012
54010: GO 54268
54012: POP
// begin b := IsInUnit ( i ) ;
54013: LD_ADDR_VAR 0 19
54017: PUSH
54018: LD_VAR 0 5
54022: PPUSH
54023: CALL_OW 310
54027: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
54028: LD_ADDR_VAR 0 20
54032: PUSH
54033: LD_VAR 0 19
54037: NOT
54038: PUSH
54039: LD_VAR 0 19
54043: PPUSH
54044: CALL_OW 266
54048: PUSH
54049: LD_INT 32
54051: PUSH
54052: LD_INT 31
54054: PUSH
54055: EMPTY
54056: LIST
54057: LIST
54058: IN
54059: OR
54060: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
54061: LD_VAR 0 17
54065: PUSH
54066: LD_VAR 0 2
54070: PPUSH
54071: LD_INT 21
54073: PUSH
54074: LD_INT 2
54076: PUSH
54077: EMPTY
54078: LIST
54079: LIST
54080: PPUSH
54081: CALL_OW 72
54085: PUSH
54086: LD_INT 1
54088: LESSEQUAL
54089: OR
54090: PUSH
54091: LD_VAR 0 20
54095: AND
54096: PUSH
54097: LD_VAR 0 5
54101: PUSH
54102: LD_VAR 0 18
54106: IN
54107: NOT
54108: AND
54109: IFFALSE 54202
// begin if b then
54111: LD_VAR 0 19
54115: IFFALSE 54164
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
54117: LD_VAR 0 19
54121: PPUSH
54122: LD_VAR 0 3
54126: PPUSH
54127: LD_VAR 0 19
54131: PPUSH
54132: CALL_OW 74
54136: PPUSH
54137: CALL_OW 296
54141: PUSH
54142: LD_INT 10
54144: LESS
54145: PUSH
54146: LD_VAR 0 19
54150: PPUSH
54151: CALL_OW 461
54155: PUSH
54156: LD_INT 7
54158: NONEQUAL
54159: AND
54160: IFFALSE 54164
// continue ;
54162: GO 53479
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
54164: LD_ADDR_VAR 0 18
54168: PUSH
54169: LD_VAR 0 18
54173: PPUSH
54174: LD_VAR 0 18
54178: PUSH
54179: LD_INT 1
54181: PLUS
54182: PPUSH
54183: LD_VAR 0 5
54187: PPUSH
54188: CALL_OW 1
54192: ST_TO_ADDR
// ComExitBuilding ( i ) ;
54193: LD_VAR 0 5
54197: PPUSH
54198: CALL_OW 122
// end ; if sold_defenders then
54202: LD_VAR 0 18
54206: IFFALSE 54266
// if i in sold_defenders then
54208: LD_VAR 0 5
54212: PUSH
54213: LD_VAR 0 18
54217: IN
54218: IFFALSE 54266
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
54220: LD_VAR 0 5
54224: PPUSH
54225: CALL_OW 314
54229: NOT
54230: PUSH
54231: LD_VAR 0 5
54235: PPUSH
54236: LD_VAR 0 14
54240: PPUSH
54241: CALL_OW 296
54245: PUSH
54246: LD_INT 30
54248: LESS
54249: AND
54250: IFFALSE 54266
// ComAttackUnit ( i , e ) ;
54252: LD_VAR 0 5
54256: PPUSH
54257: LD_VAR 0 14
54261: PPUSH
54262: CALL_OW 115
// end ; end ; end ;
54266: GO 54269
54268: POP
// if IsDead ( i ) then
54269: LD_VAR 0 5
54273: PPUSH
54274: CALL_OW 301
54278: IFFALSE 54296
// defenders := defenders diff i ;
54280: LD_ADDR_VAR 0 2
54284: PUSH
54285: LD_VAR 0 2
54289: PUSH
54290: LD_VAR 0 5
54294: DIFF
54295: ST_TO_ADDR
// end ;
54296: GO 53479
54298: POP
54299: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
54300: LD_VAR 0 3
54304: NOT
54305: PUSH
54306: LD_VAR 0 2
54310: NOT
54311: OR
54312: PUSH
54313: LD_EXP 87
54317: PUSH
54318: LD_VAR 0 1
54322: ARRAY
54323: NOT
54324: OR
54325: IFFALSE 53383
// MC_Reset ( base , 18 ) ;
54327: LD_VAR 0 1
54331: PPUSH
54332: LD_INT 18
54334: PPUSH
54335: CALL 24649 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
54339: LD_ADDR_VAR 0 2
54343: PUSH
54344: LD_VAR 0 2
54348: PUSH
54349: LD_VAR 0 2
54353: PPUSH
54354: LD_INT 2
54356: PUSH
54357: LD_INT 25
54359: PUSH
54360: LD_INT 1
54362: PUSH
54363: EMPTY
54364: LIST
54365: LIST
54366: PUSH
54367: LD_INT 25
54369: PUSH
54370: LD_INT 5
54372: PUSH
54373: EMPTY
54374: LIST
54375: LIST
54376: PUSH
54377: LD_INT 25
54379: PUSH
54380: LD_INT 8
54382: PUSH
54383: EMPTY
54384: LIST
54385: LIST
54386: PUSH
54387: LD_INT 25
54389: PUSH
54390: LD_INT 9
54392: PUSH
54393: EMPTY
54394: LIST
54395: LIST
54396: PUSH
54397: EMPTY
54398: LIST
54399: LIST
54400: LIST
54401: LIST
54402: LIST
54403: PPUSH
54404: CALL_OW 72
54408: DIFF
54409: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
54410: LD_VAR 0 3
54414: NOT
54415: PUSH
54416: LD_VAR 0 2
54420: PPUSH
54421: LD_INT 21
54423: PUSH
54424: LD_INT 2
54426: PUSH
54427: EMPTY
54428: LIST
54429: LIST
54430: PPUSH
54431: CALL_OW 72
54435: AND
54436: IFFALSE 54774
// begin tmp := FilterByTag ( defenders , 19 ) ;
54438: LD_ADDR_VAR 0 12
54442: PUSH
54443: LD_VAR 0 2
54447: PPUSH
54448: LD_INT 19
54450: PPUSH
54451: CALL 91237 0 2
54455: ST_TO_ADDR
// if tmp then
54456: LD_VAR 0 12
54460: IFFALSE 54530
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
54462: LD_ADDR_VAR 0 12
54466: PUSH
54467: LD_VAR 0 12
54471: PPUSH
54472: LD_INT 25
54474: PUSH
54475: LD_INT 3
54477: PUSH
54478: EMPTY
54479: LIST
54480: LIST
54481: PPUSH
54482: CALL_OW 72
54486: ST_TO_ADDR
// if tmp then
54487: LD_VAR 0 12
54491: IFFALSE 54530
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
54493: LD_ADDR_EXP 99
54497: PUSH
54498: LD_EXP 99
54502: PPUSH
54503: LD_VAR 0 1
54507: PPUSH
54508: LD_EXP 99
54512: PUSH
54513: LD_VAR 0 1
54517: ARRAY
54518: PUSH
54519: LD_VAR 0 12
54523: UNION
54524: PPUSH
54525: CALL_OW 1
54529: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
54530: LD_VAR 0 1
54534: PPUSH
54535: LD_INT 19
54537: PPUSH
54538: CALL 24649 0 2
// repeat wait ( 0 0$1 ) ;
54542: LD_INT 35
54544: PPUSH
54545: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
54549: LD_EXP 87
54553: PUSH
54554: LD_VAR 0 1
54558: ARRAY
54559: NOT
54560: PUSH
54561: LD_EXP 87
54565: PUSH
54566: LD_VAR 0 1
54570: ARRAY
54571: PUSH
54572: EMPTY
54573: EQUAL
54574: OR
54575: IFFALSE 54612
// begin for i in defenders do
54577: LD_ADDR_VAR 0 5
54581: PUSH
54582: LD_VAR 0 2
54586: PUSH
54587: FOR_IN
54588: IFFALSE 54601
// ComStop ( i ) ;
54590: LD_VAR 0 5
54594: PPUSH
54595: CALL_OW 141
54599: GO 54587
54601: POP
54602: POP
// defenders := [ ] ;
54603: LD_ADDR_VAR 0 2
54607: PUSH
54608: EMPTY
54609: ST_TO_ADDR
// exit ;
54610: GO 54798
// end ; for i in defenders do
54612: LD_ADDR_VAR 0 5
54616: PUSH
54617: LD_VAR 0 2
54621: PUSH
54622: FOR_IN
54623: IFFALSE 54712
// begin if not IsInArea ( i , mc_parking [ base ] ) then
54625: LD_VAR 0 5
54629: PPUSH
54630: LD_EXP 111
54634: PUSH
54635: LD_VAR 0 1
54639: ARRAY
54640: PPUSH
54641: CALL_OW 308
54645: NOT
54646: IFFALSE 54670
// ComMoveToArea ( i , mc_parking [ base ] ) else
54648: LD_VAR 0 5
54652: PPUSH
54653: LD_EXP 111
54657: PUSH
54658: LD_VAR 0 1
54662: ARRAY
54663: PPUSH
54664: CALL_OW 113
54668: GO 54710
// if GetControl ( i ) = control_manual then
54670: LD_VAR 0 5
54674: PPUSH
54675: CALL_OW 263
54679: PUSH
54680: LD_INT 1
54682: EQUAL
54683: IFFALSE 54710
// if IsDrivenBy ( i ) then
54685: LD_VAR 0 5
54689: PPUSH
54690: CALL_OW 311
54694: IFFALSE 54710
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
54696: LD_VAR 0 5
54700: PPUSH
54701: CALL_OW 311
54705: PPUSH
54706: CALL_OW 121
// end ;
54710: GO 54622
54712: POP
54713: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
54714: LD_VAR 0 2
54718: PPUSH
54719: LD_INT 95
54721: PUSH
54722: LD_EXP 111
54726: PUSH
54727: LD_VAR 0 1
54731: ARRAY
54732: PUSH
54733: EMPTY
54734: LIST
54735: LIST
54736: PPUSH
54737: CALL_OW 72
54741: PUSH
54742: LD_VAR 0 2
54746: EQUAL
54747: PUSH
54748: LD_EXP 110
54752: PUSH
54753: LD_VAR 0 1
54757: ARRAY
54758: OR
54759: PUSH
54760: LD_EXP 87
54764: PUSH
54765: LD_VAR 0 1
54769: ARRAY
54770: NOT
54771: OR
54772: IFFALSE 54542
// end ; MC_Reset ( base , 19 ) ;
54774: LD_VAR 0 1
54778: PPUSH
54779: LD_INT 19
54781: PPUSH
54782: CALL 24649 0 2
// MC_Reset ( base , 20 ) ;
54786: LD_VAR 0 1
54790: PPUSH
54791: LD_INT 20
54793: PPUSH
54794: CALL 24649 0 2
// end ;
54798: LD_VAR 0 4
54802: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
54803: LD_INT 0
54805: PPUSH
54806: PPUSH
54807: PPUSH
54808: PPUSH
// result := false ;
54809: LD_ADDR_VAR 0 2
54813: PUSH
54814: LD_INT 0
54816: ST_TO_ADDR
// side := GetSide ( unit ) ;
54817: LD_ADDR_VAR 0 3
54821: PUSH
54822: LD_VAR 0 1
54826: PPUSH
54827: CALL_OW 255
54831: ST_TO_ADDR
// nat := GetNation ( unit ) ;
54832: LD_ADDR_VAR 0 4
54836: PUSH
54837: LD_VAR 0 1
54841: PPUSH
54842: CALL_OW 248
54846: ST_TO_ADDR
// case nat of 1 :
54847: LD_VAR 0 4
54851: PUSH
54852: LD_INT 1
54854: DOUBLE
54855: EQUAL
54856: IFTRUE 54860
54858: GO 54871
54860: POP
// tech := tech_lassight ; 2 :
54861: LD_ADDR_VAR 0 5
54865: PUSH
54866: LD_INT 12
54868: ST_TO_ADDR
54869: GO 54910
54871: LD_INT 2
54873: DOUBLE
54874: EQUAL
54875: IFTRUE 54879
54877: GO 54890
54879: POP
// tech := tech_mortar ; 3 :
54880: LD_ADDR_VAR 0 5
54884: PUSH
54885: LD_INT 41
54887: ST_TO_ADDR
54888: GO 54910
54890: LD_INT 3
54892: DOUBLE
54893: EQUAL
54894: IFTRUE 54898
54896: GO 54909
54898: POP
// tech := tech_bazooka ; end ;
54899: LD_ADDR_VAR 0 5
54903: PUSH
54904: LD_INT 44
54906: ST_TO_ADDR
54907: GO 54910
54909: POP
// if Researched ( side , tech ) then
54910: LD_VAR 0 3
54914: PPUSH
54915: LD_VAR 0 5
54919: PPUSH
54920: CALL_OW 325
54924: IFFALSE 54951
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
54926: LD_ADDR_VAR 0 2
54930: PUSH
54931: LD_INT 5
54933: PUSH
54934: LD_INT 8
54936: PUSH
54937: LD_INT 9
54939: PUSH
54940: EMPTY
54941: LIST
54942: LIST
54943: LIST
54944: PUSH
54945: LD_VAR 0 4
54949: ARRAY
54950: ST_TO_ADDR
// end ;
54951: LD_VAR 0 2
54955: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
54956: LD_INT 0
54958: PPUSH
54959: PPUSH
54960: PPUSH
// if not mines then
54961: LD_VAR 0 2
54965: NOT
54966: IFFALSE 54970
// exit ;
54968: GO 55114
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54970: LD_ADDR_VAR 0 5
54974: PUSH
54975: LD_INT 81
54977: PUSH
54978: LD_VAR 0 1
54982: PUSH
54983: EMPTY
54984: LIST
54985: LIST
54986: PUSH
54987: LD_INT 3
54989: PUSH
54990: LD_INT 21
54992: PUSH
54993: LD_INT 3
54995: PUSH
54996: EMPTY
54997: LIST
54998: LIST
54999: PUSH
55000: EMPTY
55001: LIST
55002: LIST
55003: PUSH
55004: EMPTY
55005: LIST
55006: LIST
55007: PPUSH
55008: CALL_OW 69
55012: ST_TO_ADDR
// for i in mines do
55013: LD_ADDR_VAR 0 4
55017: PUSH
55018: LD_VAR 0 2
55022: PUSH
55023: FOR_IN
55024: IFFALSE 55112
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
55026: LD_VAR 0 4
55030: PUSH
55031: LD_INT 1
55033: ARRAY
55034: PPUSH
55035: LD_VAR 0 4
55039: PUSH
55040: LD_INT 2
55042: ARRAY
55043: PPUSH
55044: CALL_OW 458
55048: NOT
55049: IFFALSE 55053
// continue ;
55051: GO 55023
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
55053: LD_VAR 0 4
55057: PUSH
55058: LD_INT 1
55060: ARRAY
55061: PPUSH
55062: LD_VAR 0 4
55066: PUSH
55067: LD_INT 2
55069: ARRAY
55070: PPUSH
55071: CALL_OW 428
55075: PUSH
55076: LD_VAR 0 5
55080: IN
55081: IFFALSE 55110
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
55083: LD_VAR 0 4
55087: PUSH
55088: LD_INT 1
55090: ARRAY
55091: PPUSH
55092: LD_VAR 0 4
55096: PUSH
55097: LD_INT 2
55099: ARRAY
55100: PPUSH
55101: LD_VAR 0 1
55105: PPUSH
55106: CALL_OW 456
// end ;
55110: GO 55023
55112: POP
55113: POP
// end ;
55114: LD_VAR 0 3
55118: RET
// export function Count ( array ) ; var i ; begin
55119: LD_INT 0
55121: PPUSH
55122: PPUSH
// result := 0 ;
55123: LD_ADDR_VAR 0 2
55127: PUSH
55128: LD_INT 0
55130: ST_TO_ADDR
// for i in array do
55131: LD_ADDR_VAR 0 3
55135: PUSH
55136: LD_VAR 0 1
55140: PUSH
55141: FOR_IN
55142: IFFALSE 55166
// if i then
55144: LD_VAR 0 3
55148: IFFALSE 55164
// result := result + 1 ;
55150: LD_ADDR_VAR 0 2
55154: PUSH
55155: LD_VAR 0 2
55159: PUSH
55160: LD_INT 1
55162: PLUS
55163: ST_TO_ADDR
55164: GO 55141
55166: POP
55167: POP
// end ;
55168: LD_VAR 0 2
55172: RET
// export function IsEmpty ( building ) ; begin
55173: LD_INT 0
55175: PPUSH
// if not building then
55176: LD_VAR 0 1
55180: NOT
55181: IFFALSE 55185
// exit ;
55183: GO 55228
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
55185: LD_ADDR_VAR 0 2
55189: PUSH
55190: LD_VAR 0 1
55194: PUSH
55195: LD_INT 22
55197: PUSH
55198: LD_VAR 0 1
55202: PPUSH
55203: CALL_OW 255
55207: PUSH
55208: EMPTY
55209: LIST
55210: LIST
55211: PUSH
55212: LD_INT 58
55214: PUSH
55215: EMPTY
55216: LIST
55217: PUSH
55218: EMPTY
55219: LIST
55220: LIST
55221: PPUSH
55222: CALL_OW 69
55226: IN
55227: ST_TO_ADDR
// end ;
55228: LD_VAR 0 2
55232: RET
// export function IsNotFull ( building ) ; begin
55233: LD_INT 0
55235: PPUSH
// if not building then
55236: LD_VAR 0 1
55240: NOT
55241: IFFALSE 55245
// exit ;
55243: GO 55264
// result := UnitsInside ( building ) < 6 ;
55245: LD_ADDR_VAR 0 2
55249: PUSH
55250: LD_VAR 0 1
55254: PPUSH
55255: CALL_OW 313
55259: PUSH
55260: LD_INT 6
55262: LESS
55263: ST_TO_ADDR
// end ;
55264: LD_VAR 0 2
55268: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
55269: LD_INT 0
55271: PPUSH
55272: PPUSH
55273: PPUSH
55274: PPUSH
// tmp := [ ] ;
55275: LD_ADDR_VAR 0 3
55279: PUSH
55280: EMPTY
55281: ST_TO_ADDR
// list := [ ] ;
55282: LD_ADDR_VAR 0 5
55286: PUSH
55287: EMPTY
55288: ST_TO_ADDR
// for i = 16 to 25 do
55289: LD_ADDR_VAR 0 4
55293: PUSH
55294: DOUBLE
55295: LD_INT 16
55297: DEC
55298: ST_TO_ADDR
55299: LD_INT 25
55301: PUSH
55302: FOR_TO
55303: IFFALSE 55376
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
55305: LD_ADDR_VAR 0 3
55309: PUSH
55310: LD_VAR 0 3
55314: PUSH
55315: LD_INT 22
55317: PUSH
55318: LD_VAR 0 1
55322: PPUSH
55323: CALL_OW 255
55327: PUSH
55328: EMPTY
55329: LIST
55330: LIST
55331: PUSH
55332: LD_INT 91
55334: PUSH
55335: LD_VAR 0 1
55339: PUSH
55340: LD_INT 6
55342: PUSH
55343: EMPTY
55344: LIST
55345: LIST
55346: LIST
55347: PUSH
55348: LD_INT 30
55350: PUSH
55351: LD_VAR 0 4
55355: PUSH
55356: EMPTY
55357: LIST
55358: LIST
55359: PUSH
55360: EMPTY
55361: LIST
55362: LIST
55363: LIST
55364: PUSH
55365: EMPTY
55366: LIST
55367: PPUSH
55368: CALL_OW 69
55372: ADD
55373: ST_TO_ADDR
55374: GO 55302
55376: POP
55377: POP
// for i = 1 to tmp do
55378: LD_ADDR_VAR 0 4
55382: PUSH
55383: DOUBLE
55384: LD_INT 1
55386: DEC
55387: ST_TO_ADDR
55388: LD_VAR 0 3
55392: PUSH
55393: FOR_TO
55394: IFFALSE 55482
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
55396: LD_ADDR_VAR 0 5
55400: PUSH
55401: LD_VAR 0 5
55405: PUSH
55406: LD_VAR 0 3
55410: PUSH
55411: LD_VAR 0 4
55415: ARRAY
55416: PPUSH
55417: CALL_OW 266
55421: PUSH
55422: LD_VAR 0 3
55426: PUSH
55427: LD_VAR 0 4
55431: ARRAY
55432: PPUSH
55433: CALL_OW 250
55437: PUSH
55438: LD_VAR 0 3
55442: PUSH
55443: LD_VAR 0 4
55447: ARRAY
55448: PPUSH
55449: CALL_OW 251
55453: PUSH
55454: LD_VAR 0 3
55458: PUSH
55459: LD_VAR 0 4
55463: ARRAY
55464: PPUSH
55465: CALL_OW 254
55469: PUSH
55470: EMPTY
55471: LIST
55472: LIST
55473: LIST
55474: LIST
55475: PUSH
55476: EMPTY
55477: LIST
55478: ADD
55479: ST_TO_ADDR
55480: GO 55393
55482: POP
55483: POP
// result := list ;
55484: LD_ADDR_VAR 0 2
55488: PUSH
55489: LD_VAR 0 5
55493: ST_TO_ADDR
// end ;
55494: LD_VAR 0 2
55498: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
55499: LD_INT 0
55501: PPUSH
55502: PPUSH
55503: PPUSH
55504: PPUSH
55505: PPUSH
55506: PPUSH
55507: PPUSH
// if not factory then
55508: LD_VAR 0 1
55512: NOT
55513: IFFALSE 55517
// exit ;
55515: GO 56110
// if control = control_apeman then
55517: LD_VAR 0 4
55521: PUSH
55522: LD_INT 5
55524: EQUAL
55525: IFFALSE 55634
// begin tmp := UnitsInside ( factory ) ;
55527: LD_ADDR_VAR 0 8
55531: PUSH
55532: LD_VAR 0 1
55536: PPUSH
55537: CALL_OW 313
55541: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
55542: LD_VAR 0 8
55546: PPUSH
55547: LD_INT 25
55549: PUSH
55550: LD_INT 12
55552: PUSH
55553: EMPTY
55554: LIST
55555: LIST
55556: PPUSH
55557: CALL_OW 72
55561: NOT
55562: IFFALSE 55572
// control := control_manual ;
55564: LD_ADDR_VAR 0 4
55568: PUSH
55569: LD_INT 1
55571: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
55572: LD_ADDR_VAR 0 8
55576: PUSH
55577: LD_VAR 0 1
55581: PPUSH
55582: CALL 55269 0 1
55586: ST_TO_ADDR
// if tmp then
55587: LD_VAR 0 8
55591: IFFALSE 55634
// begin for i in tmp do
55593: LD_ADDR_VAR 0 7
55597: PUSH
55598: LD_VAR 0 8
55602: PUSH
55603: FOR_IN
55604: IFFALSE 55632
// if i [ 1 ] = b_ext_radio then
55606: LD_VAR 0 7
55610: PUSH
55611: LD_INT 1
55613: ARRAY
55614: PUSH
55615: LD_INT 22
55617: EQUAL
55618: IFFALSE 55630
// begin control := control_remote ;
55620: LD_ADDR_VAR 0 4
55624: PUSH
55625: LD_INT 2
55627: ST_TO_ADDR
// break ;
55628: GO 55632
// end ;
55630: GO 55603
55632: POP
55633: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55634: LD_VAR 0 1
55638: PPUSH
55639: LD_VAR 0 2
55643: PPUSH
55644: LD_VAR 0 3
55648: PPUSH
55649: LD_VAR 0 4
55653: PPUSH
55654: LD_VAR 0 5
55658: PPUSH
55659: CALL_OW 448
55663: IFFALSE 55698
// begin result := [ chassis , engine , control , weapon ] ;
55665: LD_ADDR_VAR 0 6
55669: PUSH
55670: LD_VAR 0 2
55674: PUSH
55675: LD_VAR 0 3
55679: PUSH
55680: LD_VAR 0 4
55684: PUSH
55685: LD_VAR 0 5
55689: PUSH
55690: EMPTY
55691: LIST
55692: LIST
55693: LIST
55694: LIST
55695: ST_TO_ADDR
// exit ;
55696: GO 56110
// end ; _chassis := AvailableChassisList ( factory ) ;
55698: LD_ADDR_VAR 0 9
55702: PUSH
55703: LD_VAR 0 1
55707: PPUSH
55708: CALL_OW 475
55712: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
55713: LD_ADDR_VAR 0 11
55717: PUSH
55718: LD_VAR 0 1
55722: PPUSH
55723: CALL_OW 476
55727: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
55728: LD_ADDR_VAR 0 12
55732: PUSH
55733: LD_VAR 0 1
55737: PPUSH
55738: CALL_OW 477
55742: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
55743: LD_ADDR_VAR 0 10
55747: PUSH
55748: LD_VAR 0 1
55752: PPUSH
55753: CALL_OW 478
55757: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
55758: LD_VAR 0 9
55762: NOT
55763: PUSH
55764: LD_VAR 0 11
55768: NOT
55769: OR
55770: PUSH
55771: LD_VAR 0 12
55775: NOT
55776: OR
55777: PUSH
55778: LD_VAR 0 10
55782: NOT
55783: OR
55784: IFFALSE 55819
// begin result := [ chassis , engine , control , weapon ] ;
55786: LD_ADDR_VAR 0 6
55790: PUSH
55791: LD_VAR 0 2
55795: PUSH
55796: LD_VAR 0 3
55800: PUSH
55801: LD_VAR 0 4
55805: PUSH
55806: LD_VAR 0 5
55810: PUSH
55811: EMPTY
55812: LIST
55813: LIST
55814: LIST
55815: LIST
55816: ST_TO_ADDR
// exit ;
55817: GO 56110
// end ; if not chassis in _chassis then
55819: LD_VAR 0 2
55823: PUSH
55824: LD_VAR 0 9
55828: IN
55829: NOT
55830: IFFALSE 55856
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
55832: LD_ADDR_VAR 0 2
55836: PUSH
55837: LD_VAR 0 9
55841: PUSH
55842: LD_INT 1
55844: PPUSH
55845: LD_VAR 0 9
55849: PPUSH
55850: CALL_OW 12
55854: ARRAY
55855: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
55856: LD_VAR 0 2
55860: PPUSH
55861: LD_VAR 0 3
55865: PPUSH
55866: CALL 56115 0 2
55870: NOT
55871: IFFALSE 55930
// repeat engine := _engine [ 1 ] ;
55873: LD_ADDR_VAR 0 3
55877: PUSH
55878: LD_VAR 0 11
55882: PUSH
55883: LD_INT 1
55885: ARRAY
55886: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
55887: LD_ADDR_VAR 0 11
55891: PUSH
55892: LD_VAR 0 11
55896: PPUSH
55897: LD_INT 1
55899: PPUSH
55900: CALL_OW 3
55904: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
55905: LD_VAR 0 2
55909: PPUSH
55910: LD_VAR 0 3
55914: PPUSH
55915: CALL 56115 0 2
55919: PUSH
55920: LD_VAR 0 11
55924: PUSH
55925: EMPTY
55926: EQUAL
55927: OR
55928: IFFALSE 55873
// if not control in _control then
55930: LD_VAR 0 4
55934: PUSH
55935: LD_VAR 0 12
55939: IN
55940: NOT
55941: IFFALSE 55967
// control := _control [ rand ( 1 , _control ) ] ;
55943: LD_ADDR_VAR 0 4
55947: PUSH
55948: LD_VAR 0 12
55952: PUSH
55953: LD_INT 1
55955: PPUSH
55956: LD_VAR 0 12
55960: PPUSH
55961: CALL_OW 12
55965: ARRAY
55966: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
55967: LD_VAR 0 2
55971: PPUSH
55972: LD_VAR 0 5
55976: PPUSH
55977: CALL 56335 0 2
55981: NOT
55982: IFFALSE 56041
// repeat weapon := _weapon [ 1 ] ;
55984: LD_ADDR_VAR 0 5
55988: PUSH
55989: LD_VAR 0 10
55993: PUSH
55994: LD_INT 1
55996: ARRAY
55997: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
55998: LD_ADDR_VAR 0 10
56002: PUSH
56003: LD_VAR 0 10
56007: PPUSH
56008: LD_INT 1
56010: PPUSH
56011: CALL_OW 3
56015: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
56016: LD_VAR 0 2
56020: PPUSH
56021: LD_VAR 0 5
56025: PPUSH
56026: CALL 56335 0 2
56030: PUSH
56031: LD_VAR 0 10
56035: PUSH
56036: EMPTY
56037: EQUAL
56038: OR
56039: IFFALSE 55984
// result := [ ] ;
56041: LD_ADDR_VAR 0 6
56045: PUSH
56046: EMPTY
56047: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
56048: LD_VAR 0 1
56052: PPUSH
56053: LD_VAR 0 2
56057: PPUSH
56058: LD_VAR 0 3
56062: PPUSH
56063: LD_VAR 0 4
56067: PPUSH
56068: LD_VAR 0 5
56072: PPUSH
56073: CALL_OW 448
56077: IFFALSE 56110
// result := [ chassis , engine , control , weapon ] ;
56079: LD_ADDR_VAR 0 6
56083: PUSH
56084: LD_VAR 0 2
56088: PUSH
56089: LD_VAR 0 3
56093: PUSH
56094: LD_VAR 0 4
56098: PUSH
56099: LD_VAR 0 5
56103: PUSH
56104: EMPTY
56105: LIST
56106: LIST
56107: LIST
56108: LIST
56109: ST_TO_ADDR
// end ;
56110: LD_VAR 0 6
56114: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
56115: LD_INT 0
56117: PPUSH
// if not chassis or not engine then
56118: LD_VAR 0 1
56122: NOT
56123: PUSH
56124: LD_VAR 0 2
56128: NOT
56129: OR
56130: IFFALSE 56134
// exit ;
56132: GO 56330
// case engine of engine_solar :
56134: LD_VAR 0 2
56138: PUSH
56139: LD_INT 2
56141: DOUBLE
56142: EQUAL
56143: IFTRUE 56147
56145: GO 56185
56147: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
56148: LD_ADDR_VAR 0 3
56152: PUSH
56153: LD_INT 11
56155: PUSH
56156: LD_INT 12
56158: PUSH
56159: LD_INT 13
56161: PUSH
56162: LD_INT 14
56164: PUSH
56165: LD_INT 1
56167: PUSH
56168: LD_INT 2
56170: PUSH
56171: LD_INT 3
56173: PUSH
56174: EMPTY
56175: LIST
56176: LIST
56177: LIST
56178: LIST
56179: LIST
56180: LIST
56181: LIST
56182: ST_TO_ADDR
56183: GO 56314
56185: LD_INT 1
56187: DOUBLE
56188: EQUAL
56189: IFTRUE 56193
56191: GO 56255
56193: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
56194: LD_ADDR_VAR 0 3
56198: PUSH
56199: LD_INT 11
56201: PUSH
56202: LD_INT 12
56204: PUSH
56205: LD_INT 13
56207: PUSH
56208: LD_INT 14
56210: PUSH
56211: LD_INT 1
56213: PUSH
56214: LD_INT 2
56216: PUSH
56217: LD_INT 3
56219: PUSH
56220: LD_INT 4
56222: PUSH
56223: LD_INT 5
56225: PUSH
56226: LD_INT 21
56228: PUSH
56229: LD_INT 23
56231: PUSH
56232: LD_INT 22
56234: PUSH
56235: LD_INT 24
56237: PUSH
56238: EMPTY
56239: LIST
56240: LIST
56241: LIST
56242: LIST
56243: LIST
56244: LIST
56245: LIST
56246: LIST
56247: LIST
56248: LIST
56249: LIST
56250: LIST
56251: LIST
56252: ST_TO_ADDR
56253: GO 56314
56255: LD_INT 3
56257: DOUBLE
56258: EQUAL
56259: IFTRUE 56263
56261: GO 56313
56263: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
56264: LD_ADDR_VAR 0 3
56268: PUSH
56269: LD_INT 13
56271: PUSH
56272: LD_INT 14
56274: PUSH
56275: LD_INT 2
56277: PUSH
56278: LD_INT 3
56280: PUSH
56281: LD_INT 4
56283: PUSH
56284: LD_INT 5
56286: PUSH
56287: LD_INT 21
56289: PUSH
56290: LD_INT 22
56292: PUSH
56293: LD_INT 23
56295: PUSH
56296: LD_INT 24
56298: PUSH
56299: EMPTY
56300: LIST
56301: LIST
56302: LIST
56303: LIST
56304: LIST
56305: LIST
56306: LIST
56307: LIST
56308: LIST
56309: LIST
56310: ST_TO_ADDR
56311: GO 56314
56313: POP
// result := ( chassis in result ) ;
56314: LD_ADDR_VAR 0 3
56318: PUSH
56319: LD_VAR 0 1
56323: PUSH
56324: LD_VAR 0 3
56328: IN
56329: ST_TO_ADDR
// end ;
56330: LD_VAR 0 3
56334: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
56335: LD_INT 0
56337: PPUSH
// if not chassis or not weapon then
56338: LD_VAR 0 1
56342: NOT
56343: PUSH
56344: LD_VAR 0 2
56348: NOT
56349: OR
56350: IFFALSE 56354
// exit ;
56352: GO 57380
// case weapon of us_machine_gun :
56354: LD_VAR 0 2
56358: PUSH
56359: LD_INT 2
56361: DOUBLE
56362: EQUAL
56363: IFTRUE 56367
56365: GO 56397
56367: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
56368: LD_ADDR_VAR 0 3
56372: PUSH
56373: LD_INT 1
56375: PUSH
56376: LD_INT 2
56378: PUSH
56379: LD_INT 3
56381: PUSH
56382: LD_INT 4
56384: PUSH
56385: LD_INT 5
56387: PUSH
56388: EMPTY
56389: LIST
56390: LIST
56391: LIST
56392: LIST
56393: LIST
56394: ST_TO_ADDR
56395: GO 57364
56397: LD_INT 3
56399: DOUBLE
56400: EQUAL
56401: IFTRUE 56405
56403: GO 56435
56405: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
56406: LD_ADDR_VAR 0 3
56410: PUSH
56411: LD_INT 1
56413: PUSH
56414: LD_INT 2
56416: PUSH
56417: LD_INT 3
56419: PUSH
56420: LD_INT 4
56422: PUSH
56423: LD_INT 5
56425: PUSH
56426: EMPTY
56427: LIST
56428: LIST
56429: LIST
56430: LIST
56431: LIST
56432: ST_TO_ADDR
56433: GO 57364
56435: LD_INT 11
56437: DOUBLE
56438: EQUAL
56439: IFTRUE 56443
56441: GO 56473
56443: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
56444: LD_ADDR_VAR 0 3
56448: PUSH
56449: LD_INT 1
56451: PUSH
56452: LD_INT 2
56454: PUSH
56455: LD_INT 3
56457: PUSH
56458: LD_INT 4
56460: PUSH
56461: LD_INT 5
56463: PUSH
56464: EMPTY
56465: LIST
56466: LIST
56467: LIST
56468: LIST
56469: LIST
56470: ST_TO_ADDR
56471: GO 57364
56473: LD_INT 4
56475: DOUBLE
56476: EQUAL
56477: IFTRUE 56481
56479: GO 56507
56481: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
56482: LD_ADDR_VAR 0 3
56486: PUSH
56487: LD_INT 2
56489: PUSH
56490: LD_INT 3
56492: PUSH
56493: LD_INT 4
56495: PUSH
56496: LD_INT 5
56498: PUSH
56499: EMPTY
56500: LIST
56501: LIST
56502: LIST
56503: LIST
56504: ST_TO_ADDR
56505: GO 57364
56507: LD_INT 5
56509: DOUBLE
56510: EQUAL
56511: IFTRUE 56515
56513: GO 56541
56515: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
56516: LD_ADDR_VAR 0 3
56520: PUSH
56521: LD_INT 2
56523: PUSH
56524: LD_INT 3
56526: PUSH
56527: LD_INT 4
56529: PUSH
56530: LD_INT 5
56532: PUSH
56533: EMPTY
56534: LIST
56535: LIST
56536: LIST
56537: LIST
56538: ST_TO_ADDR
56539: GO 57364
56541: LD_INT 9
56543: DOUBLE
56544: EQUAL
56545: IFTRUE 56549
56547: GO 56575
56549: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
56550: LD_ADDR_VAR 0 3
56554: PUSH
56555: LD_INT 2
56557: PUSH
56558: LD_INT 3
56560: PUSH
56561: LD_INT 4
56563: PUSH
56564: LD_INT 5
56566: PUSH
56567: EMPTY
56568: LIST
56569: LIST
56570: LIST
56571: LIST
56572: ST_TO_ADDR
56573: GO 57364
56575: LD_INT 7
56577: DOUBLE
56578: EQUAL
56579: IFTRUE 56583
56581: GO 56609
56583: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
56584: LD_ADDR_VAR 0 3
56588: PUSH
56589: LD_INT 2
56591: PUSH
56592: LD_INT 3
56594: PUSH
56595: LD_INT 4
56597: PUSH
56598: LD_INT 5
56600: PUSH
56601: EMPTY
56602: LIST
56603: LIST
56604: LIST
56605: LIST
56606: ST_TO_ADDR
56607: GO 57364
56609: LD_INT 12
56611: DOUBLE
56612: EQUAL
56613: IFTRUE 56617
56615: GO 56643
56617: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
56618: LD_ADDR_VAR 0 3
56622: PUSH
56623: LD_INT 2
56625: PUSH
56626: LD_INT 3
56628: PUSH
56629: LD_INT 4
56631: PUSH
56632: LD_INT 5
56634: PUSH
56635: EMPTY
56636: LIST
56637: LIST
56638: LIST
56639: LIST
56640: ST_TO_ADDR
56641: GO 57364
56643: LD_INT 13
56645: DOUBLE
56646: EQUAL
56647: IFTRUE 56651
56649: GO 56677
56651: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
56652: LD_ADDR_VAR 0 3
56656: PUSH
56657: LD_INT 2
56659: PUSH
56660: LD_INT 3
56662: PUSH
56663: LD_INT 4
56665: PUSH
56666: LD_INT 5
56668: PUSH
56669: EMPTY
56670: LIST
56671: LIST
56672: LIST
56673: LIST
56674: ST_TO_ADDR
56675: GO 57364
56677: LD_INT 14
56679: DOUBLE
56680: EQUAL
56681: IFTRUE 56685
56683: GO 56703
56685: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
56686: LD_ADDR_VAR 0 3
56690: PUSH
56691: LD_INT 4
56693: PUSH
56694: LD_INT 5
56696: PUSH
56697: EMPTY
56698: LIST
56699: LIST
56700: ST_TO_ADDR
56701: GO 57364
56703: LD_INT 6
56705: DOUBLE
56706: EQUAL
56707: IFTRUE 56711
56709: GO 56729
56711: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
56712: LD_ADDR_VAR 0 3
56716: PUSH
56717: LD_INT 4
56719: PUSH
56720: LD_INT 5
56722: PUSH
56723: EMPTY
56724: LIST
56725: LIST
56726: ST_TO_ADDR
56727: GO 57364
56729: LD_INT 10
56731: DOUBLE
56732: EQUAL
56733: IFTRUE 56737
56735: GO 56755
56737: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
56738: LD_ADDR_VAR 0 3
56742: PUSH
56743: LD_INT 4
56745: PUSH
56746: LD_INT 5
56748: PUSH
56749: EMPTY
56750: LIST
56751: LIST
56752: ST_TO_ADDR
56753: GO 57364
56755: LD_INT 22
56757: DOUBLE
56758: EQUAL
56759: IFTRUE 56763
56761: GO 56789
56763: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
56764: LD_ADDR_VAR 0 3
56768: PUSH
56769: LD_INT 11
56771: PUSH
56772: LD_INT 12
56774: PUSH
56775: LD_INT 13
56777: PUSH
56778: LD_INT 14
56780: PUSH
56781: EMPTY
56782: LIST
56783: LIST
56784: LIST
56785: LIST
56786: ST_TO_ADDR
56787: GO 57364
56789: LD_INT 23
56791: DOUBLE
56792: EQUAL
56793: IFTRUE 56797
56795: GO 56823
56797: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
56798: LD_ADDR_VAR 0 3
56802: PUSH
56803: LD_INT 11
56805: PUSH
56806: LD_INT 12
56808: PUSH
56809: LD_INT 13
56811: PUSH
56812: LD_INT 14
56814: PUSH
56815: EMPTY
56816: LIST
56817: LIST
56818: LIST
56819: LIST
56820: ST_TO_ADDR
56821: GO 57364
56823: LD_INT 24
56825: DOUBLE
56826: EQUAL
56827: IFTRUE 56831
56829: GO 56857
56831: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
56832: LD_ADDR_VAR 0 3
56836: PUSH
56837: LD_INT 11
56839: PUSH
56840: LD_INT 12
56842: PUSH
56843: LD_INT 13
56845: PUSH
56846: LD_INT 14
56848: PUSH
56849: EMPTY
56850: LIST
56851: LIST
56852: LIST
56853: LIST
56854: ST_TO_ADDR
56855: GO 57364
56857: LD_INT 30
56859: DOUBLE
56860: EQUAL
56861: IFTRUE 56865
56863: GO 56891
56865: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
56866: LD_ADDR_VAR 0 3
56870: PUSH
56871: LD_INT 11
56873: PUSH
56874: LD_INT 12
56876: PUSH
56877: LD_INT 13
56879: PUSH
56880: LD_INT 14
56882: PUSH
56883: EMPTY
56884: LIST
56885: LIST
56886: LIST
56887: LIST
56888: ST_TO_ADDR
56889: GO 57364
56891: LD_INT 25
56893: DOUBLE
56894: EQUAL
56895: IFTRUE 56899
56897: GO 56917
56899: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
56900: LD_ADDR_VAR 0 3
56904: PUSH
56905: LD_INT 13
56907: PUSH
56908: LD_INT 14
56910: PUSH
56911: EMPTY
56912: LIST
56913: LIST
56914: ST_TO_ADDR
56915: GO 57364
56917: LD_INT 27
56919: DOUBLE
56920: EQUAL
56921: IFTRUE 56925
56923: GO 56943
56925: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
56926: LD_ADDR_VAR 0 3
56930: PUSH
56931: LD_INT 13
56933: PUSH
56934: LD_INT 14
56936: PUSH
56937: EMPTY
56938: LIST
56939: LIST
56940: ST_TO_ADDR
56941: GO 57364
56943: LD_INT 28
56945: DOUBLE
56946: EQUAL
56947: IFTRUE 56951
56949: GO 56969
56951: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
56952: LD_ADDR_VAR 0 3
56956: PUSH
56957: LD_INT 13
56959: PUSH
56960: LD_INT 14
56962: PUSH
56963: EMPTY
56964: LIST
56965: LIST
56966: ST_TO_ADDR
56967: GO 57364
56969: LD_INT 29
56971: DOUBLE
56972: EQUAL
56973: IFTRUE 56977
56975: GO 56995
56977: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
56978: LD_ADDR_VAR 0 3
56982: PUSH
56983: LD_INT 13
56985: PUSH
56986: LD_INT 14
56988: PUSH
56989: EMPTY
56990: LIST
56991: LIST
56992: ST_TO_ADDR
56993: GO 57364
56995: LD_INT 31
56997: DOUBLE
56998: EQUAL
56999: IFTRUE 57003
57001: GO 57021
57003: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
57004: LD_ADDR_VAR 0 3
57008: PUSH
57009: LD_INT 13
57011: PUSH
57012: LD_INT 14
57014: PUSH
57015: EMPTY
57016: LIST
57017: LIST
57018: ST_TO_ADDR
57019: GO 57364
57021: LD_INT 26
57023: DOUBLE
57024: EQUAL
57025: IFTRUE 57029
57027: GO 57047
57029: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
57030: LD_ADDR_VAR 0 3
57034: PUSH
57035: LD_INT 13
57037: PUSH
57038: LD_INT 14
57040: PUSH
57041: EMPTY
57042: LIST
57043: LIST
57044: ST_TO_ADDR
57045: GO 57364
57047: LD_INT 42
57049: DOUBLE
57050: EQUAL
57051: IFTRUE 57055
57053: GO 57081
57055: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
57056: LD_ADDR_VAR 0 3
57060: PUSH
57061: LD_INT 21
57063: PUSH
57064: LD_INT 22
57066: PUSH
57067: LD_INT 23
57069: PUSH
57070: LD_INT 24
57072: PUSH
57073: EMPTY
57074: LIST
57075: LIST
57076: LIST
57077: LIST
57078: ST_TO_ADDR
57079: GO 57364
57081: LD_INT 43
57083: DOUBLE
57084: EQUAL
57085: IFTRUE 57089
57087: GO 57115
57089: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
57090: LD_ADDR_VAR 0 3
57094: PUSH
57095: LD_INT 21
57097: PUSH
57098: LD_INT 22
57100: PUSH
57101: LD_INT 23
57103: PUSH
57104: LD_INT 24
57106: PUSH
57107: EMPTY
57108: LIST
57109: LIST
57110: LIST
57111: LIST
57112: ST_TO_ADDR
57113: GO 57364
57115: LD_INT 44
57117: DOUBLE
57118: EQUAL
57119: IFTRUE 57123
57121: GO 57149
57123: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
57124: LD_ADDR_VAR 0 3
57128: PUSH
57129: LD_INT 21
57131: PUSH
57132: LD_INT 22
57134: PUSH
57135: LD_INT 23
57137: PUSH
57138: LD_INT 24
57140: PUSH
57141: EMPTY
57142: LIST
57143: LIST
57144: LIST
57145: LIST
57146: ST_TO_ADDR
57147: GO 57364
57149: LD_INT 45
57151: DOUBLE
57152: EQUAL
57153: IFTRUE 57157
57155: GO 57183
57157: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
57158: LD_ADDR_VAR 0 3
57162: PUSH
57163: LD_INT 21
57165: PUSH
57166: LD_INT 22
57168: PUSH
57169: LD_INT 23
57171: PUSH
57172: LD_INT 24
57174: PUSH
57175: EMPTY
57176: LIST
57177: LIST
57178: LIST
57179: LIST
57180: ST_TO_ADDR
57181: GO 57364
57183: LD_INT 49
57185: DOUBLE
57186: EQUAL
57187: IFTRUE 57191
57189: GO 57217
57191: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
57192: LD_ADDR_VAR 0 3
57196: PUSH
57197: LD_INT 21
57199: PUSH
57200: LD_INT 22
57202: PUSH
57203: LD_INT 23
57205: PUSH
57206: LD_INT 24
57208: PUSH
57209: EMPTY
57210: LIST
57211: LIST
57212: LIST
57213: LIST
57214: ST_TO_ADDR
57215: GO 57364
57217: LD_INT 51
57219: DOUBLE
57220: EQUAL
57221: IFTRUE 57225
57223: GO 57251
57225: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
57226: LD_ADDR_VAR 0 3
57230: PUSH
57231: LD_INT 21
57233: PUSH
57234: LD_INT 22
57236: PUSH
57237: LD_INT 23
57239: PUSH
57240: LD_INT 24
57242: PUSH
57243: EMPTY
57244: LIST
57245: LIST
57246: LIST
57247: LIST
57248: ST_TO_ADDR
57249: GO 57364
57251: LD_INT 52
57253: DOUBLE
57254: EQUAL
57255: IFTRUE 57259
57257: GO 57285
57259: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
57260: LD_ADDR_VAR 0 3
57264: PUSH
57265: LD_INT 21
57267: PUSH
57268: LD_INT 22
57270: PUSH
57271: LD_INT 23
57273: PUSH
57274: LD_INT 24
57276: PUSH
57277: EMPTY
57278: LIST
57279: LIST
57280: LIST
57281: LIST
57282: ST_TO_ADDR
57283: GO 57364
57285: LD_INT 53
57287: DOUBLE
57288: EQUAL
57289: IFTRUE 57293
57291: GO 57311
57293: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
57294: LD_ADDR_VAR 0 3
57298: PUSH
57299: LD_INT 23
57301: PUSH
57302: LD_INT 24
57304: PUSH
57305: EMPTY
57306: LIST
57307: LIST
57308: ST_TO_ADDR
57309: GO 57364
57311: LD_INT 46
57313: DOUBLE
57314: EQUAL
57315: IFTRUE 57319
57317: GO 57337
57319: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
57320: LD_ADDR_VAR 0 3
57324: PUSH
57325: LD_INT 23
57327: PUSH
57328: LD_INT 24
57330: PUSH
57331: EMPTY
57332: LIST
57333: LIST
57334: ST_TO_ADDR
57335: GO 57364
57337: LD_INT 47
57339: DOUBLE
57340: EQUAL
57341: IFTRUE 57345
57343: GO 57363
57345: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
57346: LD_ADDR_VAR 0 3
57350: PUSH
57351: LD_INT 23
57353: PUSH
57354: LD_INT 24
57356: PUSH
57357: EMPTY
57358: LIST
57359: LIST
57360: ST_TO_ADDR
57361: GO 57364
57363: POP
// result := ( chassis in result ) ;
57364: LD_ADDR_VAR 0 3
57368: PUSH
57369: LD_VAR 0 1
57373: PUSH
57374: LD_VAR 0 3
57378: IN
57379: ST_TO_ADDR
// end ;
57380: LD_VAR 0 3
57384: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
57385: LD_INT 0
57387: PPUSH
57388: PPUSH
57389: PPUSH
57390: PPUSH
57391: PPUSH
57392: PPUSH
57393: PPUSH
// result := array ;
57394: LD_ADDR_VAR 0 5
57398: PUSH
57399: LD_VAR 0 1
57403: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
57404: LD_VAR 0 1
57408: NOT
57409: PUSH
57410: LD_VAR 0 2
57414: NOT
57415: OR
57416: PUSH
57417: LD_VAR 0 3
57421: NOT
57422: OR
57423: PUSH
57424: LD_VAR 0 2
57428: PUSH
57429: LD_VAR 0 1
57433: GREATER
57434: OR
57435: PUSH
57436: LD_VAR 0 3
57440: PUSH
57441: LD_VAR 0 1
57445: GREATER
57446: OR
57447: IFFALSE 57451
// exit ;
57449: GO 57747
// if direction then
57451: LD_VAR 0 4
57455: IFFALSE 57519
// begin d := 1 ;
57457: LD_ADDR_VAR 0 9
57461: PUSH
57462: LD_INT 1
57464: ST_TO_ADDR
// if i_from > i_to then
57465: LD_VAR 0 2
57469: PUSH
57470: LD_VAR 0 3
57474: GREATER
57475: IFFALSE 57501
// length := ( array - i_from ) + i_to else
57477: LD_ADDR_VAR 0 11
57481: PUSH
57482: LD_VAR 0 1
57486: PUSH
57487: LD_VAR 0 2
57491: MINUS
57492: PUSH
57493: LD_VAR 0 3
57497: PLUS
57498: ST_TO_ADDR
57499: GO 57517
// length := i_to - i_from ;
57501: LD_ADDR_VAR 0 11
57505: PUSH
57506: LD_VAR 0 3
57510: PUSH
57511: LD_VAR 0 2
57515: MINUS
57516: ST_TO_ADDR
// end else
57517: GO 57580
// begin d := - 1 ;
57519: LD_ADDR_VAR 0 9
57523: PUSH
57524: LD_INT 1
57526: NEG
57527: ST_TO_ADDR
// if i_from > i_to then
57528: LD_VAR 0 2
57532: PUSH
57533: LD_VAR 0 3
57537: GREATER
57538: IFFALSE 57558
// length := i_from - i_to else
57540: LD_ADDR_VAR 0 11
57544: PUSH
57545: LD_VAR 0 2
57549: PUSH
57550: LD_VAR 0 3
57554: MINUS
57555: ST_TO_ADDR
57556: GO 57580
// length := ( array - i_to ) + i_from ;
57558: LD_ADDR_VAR 0 11
57562: PUSH
57563: LD_VAR 0 1
57567: PUSH
57568: LD_VAR 0 3
57572: MINUS
57573: PUSH
57574: LD_VAR 0 2
57578: PLUS
57579: ST_TO_ADDR
// end ; if not length then
57580: LD_VAR 0 11
57584: NOT
57585: IFFALSE 57589
// exit ;
57587: GO 57747
// tmp := array ;
57589: LD_ADDR_VAR 0 10
57593: PUSH
57594: LD_VAR 0 1
57598: ST_TO_ADDR
// for i = 1 to length do
57599: LD_ADDR_VAR 0 6
57603: PUSH
57604: DOUBLE
57605: LD_INT 1
57607: DEC
57608: ST_TO_ADDR
57609: LD_VAR 0 11
57613: PUSH
57614: FOR_TO
57615: IFFALSE 57735
// begin for j = 1 to array do
57617: LD_ADDR_VAR 0 7
57621: PUSH
57622: DOUBLE
57623: LD_INT 1
57625: DEC
57626: ST_TO_ADDR
57627: LD_VAR 0 1
57631: PUSH
57632: FOR_TO
57633: IFFALSE 57721
// begin k := j + d ;
57635: LD_ADDR_VAR 0 8
57639: PUSH
57640: LD_VAR 0 7
57644: PUSH
57645: LD_VAR 0 9
57649: PLUS
57650: ST_TO_ADDR
// if k > array then
57651: LD_VAR 0 8
57655: PUSH
57656: LD_VAR 0 1
57660: GREATER
57661: IFFALSE 57671
// k := 1 ;
57663: LD_ADDR_VAR 0 8
57667: PUSH
57668: LD_INT 1
57670: ST_TO_ADDR
// if not k then
57671: LD_VAR 0 8
57675: NOT
57676: IFFALSE 57688
// k := array ;
57678: LD_ADDR_VAR 0 8
57682: PUSH
57683: LD_VAR 0 1
57687: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
57688: LD_ADDR_VAR 0 10
57692: PUSH
57693: LD_VAR 0 10
57697: PPUSH
57698: LD_VAR 0 8
57702: PPUSH
57703: LD_VAR 0 1
57707: PUSH
57708: LD_VAR 0 7
57712: ARRAY
57713: PPUSH
57714: CALL_OW 1
57718: ST_TO_ADDR
// end ;
57719: GO 57632
57721: POP
57722: POP
// array := tmp ;
57723: LD_ADDR_VAR 0 1
57727: PUSH
57728: LD_VAR 0 10
57732: ST_TO_ADDR
// end ;
57733: GO 57614
57735: POP
57736: POP
// result := array ;
57737: LD_ADDR_VAR 0 5
57741: PUSH
57742: LD_VAR 0 1
57746: ST_TO_ADDR
// end ;
57747: LD_VAR 0 5
57751: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
57752: LD_INT 0
57754: PPUSH
57755: PPUSH
// result := 0 ;
57756: LD_ADDR_VAR 0 3
57760: PUSH
57761: LD_INT 0
57763: ST_TO_ADDR
// if not array or not value in array then
57764: LD_VAR 0 1
57768: NOT
57769: PUSH
57770: LD_VAR 0 2
57774: PUSH
57775: LD_VAR 0 1
57779: IN
57780: NOT
57781: OR
57782: IFFALSE 57786
// exit ;
57784: GO 57840
// for i = 1 to array do
57786: LD_ADDR_VAR 0 4
57790: PUSH
57791: DOUBLE
57792: LD_INT 1
57794: DEC
57795: ST_TO_ADDR
57796: LD_VAR 0 1
57800: PUSH
57801: FOR_TO
57802: IFFALSE 57838
// if value = array [ i ] then
57804: LD_VAR 0 2
57808: PUSH
57809: LD_VAR 0 1
57813: PUSH
57814: LD_VAR 0 4
57818: ARRAY
57819: EQUAL
57820: IFFALSE 57836
// begin result := i ;
57822: LD_ADDR_VAR 0 3
57826: PUSH
57827: LD_VAR 0 4
57831: ST_TO_ADDR
// exit ;
57832: POP
57833: POP
57834: GO 57840
// end ;
57836: GO 57801
57838: POP
57839: POP
// end ;
57840: LD_VAR 0 3
57844: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
57845: LD_INT 0
57847: PPUSH
// vc_chassis := chassis ;
57848: LD_ADDR_OWVAR 37
57852: PUSH
57853: LD_VAR 0 1
57857: ST_TO_ADDR
// vc_engine := engine ;
57858: LD_ADDR_OWVAR 39
57862: PUSH
57863: LD_VAR 0 2
57867: ST_TO_ADDR
// vc_control := control ;
57868: LD_ADDR_OWVAR 38
57872: PUSH
57873: LD_VAR 0 3
57877: ST_TO_ADDR
// vc_weapon := weapon ;
57878: LD_ADDR_OWVAR 40
57882: PUSH
57883: LD_VAR 0 4
57887: ST_TO_ADDR
// vc_fuel_battery := fuel ;
57888: LD_ADDR_OWVAR 41
57892: PUSH
57893: LD_VAR 0 5
57897: ST_TO_ADDR
// end ;
57898: LD_VAR 0 6
57902: RET
// export function WantPlant ( unit ) ; var task ; begin
57903: LD_INT 0
57905: PPUSH
57906: PPUSH
// result := false ;
57907: LD_ADDR_VAR 0 2
57911: PUSH
57912: LD_INT 0
57914: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
57915: LD_ADDR_VAR 0 3
57919: PUSH
57920: LD_VAR 0 1
57924: PPUSH
57925: CALL_OW 437
57929: ST_TO_ADDR
// if task then
57930: LD_VAR 0 3
57934: IFFALSE 57962
// if task [ 1 ] [ 1 ] = p then
57936: LD_VAR 0 3
57940: PUSH
57941: LD_INT 1
57943: ARRAY
57944: PUSH
57945: LD_INT 1
57947: ARRAY
57948: PUSH
57949: LD_STRING p
57951: EQUAL
57952: IFFALSE 57962
// result := true ;
57954: LD_ADDR_VAR 0 2
57958: PUSH
57959: LD_INT 1
57961: ST_TO_ADDR
// end ;
57962: LD_VAR 0 2
57966: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
57967: LD_INT 0
57969: PPUSH
57970: PPUSH
57971: PPUSH
57972: PPUSH
// if pos < 1 then
57973: LD_VAR 0 2
57977: PUSH
57978: LD_INT 1
57980: LESS
57981: IFFALSE 57985
// exit ;
57983: GO 58288
// if pos = 1 then
57985: LD_VAR 0 2
57989: PUSH
57990: LD_INT 1
57992: EQUAL
57993: IFFALSE 58026
// result := Replace ( arr , pos [ 1 ] , value ) else
57995: LD_ADDR_VAR 0 4
57999: PUSH
58000: LD_VAR 0 1
58004: PPUSH
58005: LD_VAR 0 2
58009: PUSH
58010: LD_INT 1
58012: ARRAY
58013: PPUSH
58014: LD_VAR 0 3
58018: PPUSH
58019: CALL_OW 1
58023: ST_TO_ADDR
58024: GO 58288
// begin tmp := arr ;
58026: LD_ADDR_VAR 0 6
58030: PUSH
58031: LD_VAR 0 1
58035: ST_TO_ADDR
// s_arr := [ tmp ] ;
58036: LD_ADDR_VAR 0 7
58040: PUSH
58041: LD_VAR 0 6
58045: PUSH
58046: EMPTY
58047: LIST
58048: ST_TO_ADDR
// for i = 1 to pos - 1 do
58049: LD_ADDR_VAR 0 5
58053: PUSH
58054: DOUBLE
58055: LD_INT 1
58057: DEC
58058: ST_TO_ADDR
58059: LD_VAR 0 2
58063: PUSH
58064: LD_INT 1
58066: MINUS
58067: PUSH
58068: FOR_TO
58069: IFFALSE 58114
// begin tmp := tmp [ pos [ i ] ] ;
58071: LD_ADDR_VAR 0 6
58075: PUSH
58076: LD_VAR 0 6
58080: PUSH
58081: LD_VAR 0 2
58085: PUSH
58086: LD_VAR 0 5
58090: ARRAY
58091: ARRAY
58092: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
58093: LD_ADDR_VAR 0 7
58097: PUSH
58098: LD_VAR 0 7
58102: PUSH
58103: LD_VAR 0 6
58107: PUSH
58108: EMPTY
58109: LIST
58110: ADD
58111: ST_TO_ADDR
// end ;
58112: GO 58068
58114: POP
58115: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
58116: LD_ADDR_VAR 0 6
58120: PUSH
58121: LD_VAR 0 6
58125: PPUSH
58126: LD_VAR 0 2
58130: PUSH
58131: LD_VAR 0 2
58135: ARRAY
58136: PPUSH
58137: LD_VAR 0 3
58141: PPUSH
58142: CALL_OW 1
58146: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
58147: LD_ADDR_VAR 0 7
58151: PUSH
58152: LD_VAR 0 7
58156: PPUSH
58157: LD_VAR 0 7
58161: PPUSH
58162: LD_VAR 0 6
58166: PPUSH
58167: CALL_OW 1
58171: ST_TO_ADDR
// for i = s_arr downto 2 do
58172: LD_ADDR_VAR 0 5
58176: PUSH
58177: DOUBLE
58178: LD_VAR 0 7
58182: INC
58183: ST_TO_ADDR
58184: LD_INT 2
58186: PUSH
58187: FOR_DOWNTO
58188: IFFALSE 58272
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
58190: LD_ADDR_VAR 0 6
58194: PUSH
58195: LD_VAR 0 7
58199: PUSH
58200: LD_VAR 0 5
58204: PUSH
58205: LD_INT 1
58207: MINUS
58208: ARRAY
58209: PPUSH
58210: LD_VAR 0 2
58214: PUSH
58215: LD_VAR 0 5
58219: PUSH
58220: LD_INT 1
58222: MINUS
58223: ARRAY
58224: PPUSH
58225: LD_VAR 0 7
58229: PUSH
58230: LD_VAR 0 5
58234: ARRAY
58235: PPUSH
58236: CALL_OW 1
58240: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
58241: LD_ADDR_VAR 0 7
58245: PUSH
58246: LD_VAR 0 7
58250: PPUSH
58251: LD_VAR 0 5
58255: PUSH
58256: LD_INT 1
58258: MINUS
58259: PPUSH
58260: LD_VAR 0 6
58264: PPUSH
58265: CALL_OW 1
58269: ST_TO_ADDR
// end ;
58270: GO 58187
58272: POP
58273: POP
// result := s_arr [ 1 ] ;
58274: LD_ADDR_VAR 0 4
58278: PUSH
58279: LD_VAR 0 7
58283: PUSH
58284: LD_INT 1
58286: ARRAY
58287: ST_TO_ADDR
// end ; end ;
58288: LD_VAR 0 4
58292: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
58293: LD_INT 0
58295: PPUSH
58296: PPUSH
// if not list then
58297: LD_VAR 0 1
58301: NOT
58302: IFFALSE 58306
// exit ;
58304: GO 58397
// i := list [ pos1 ] ;
58306: LD_ADDR_VAR 0 5
58310: PUSH
58311: LD_VAR 0 1
58315: PUSH
58316: LD_VAR 0 2
58320: ARRAY
58321: ST_TO_ADDR
// if not i then
58322: LD_VAR 0 5
58326: NOT
58327: IFFALSE 58331
// exit ;
58329: GO 58397
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
58331: LD_ADDR_VAR 0 1
58335: PUSH
58336: LD_VAR 0 1
58340: PPUSH
58341: LD_VAR 0 2
58345: PPUSH
58346: LD_VAR 0 1
58350: PUSH
58351: LD_VAR 0 3
58355: ARRAY
58356: PPUSH
58357: CALL_OW 1
58361: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
58362: LD_ADDR_VAR 0 1
58366: PUSH
58367: LD_VAR 0 1
58371: PPUSH
58372: LD_VAR 0 3
58376: PPUSH
58377: LD_VAR 0 5
58381: PPUSH
58382: CALL_OW 1
58386: ST_TO_ADDR
// result := list ;
58387: LD_ADDR_VAR 0 4
58391: PUSH
58392: LD_VAR 0 1
58396: ST_TO_ADDR
// end ;
58397: LD_VAR 0 4
58401: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
58402: LD_INT 0
58404: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
58405: LD_ADDR_VAR 0 5
58409: PUSH
58410: LD_VAR 0 1
58414: PPUSH
58415: CALL_OW 250
58419: PPUSH
58420: LD_VAR 0 1
58424: PPUSH
58425: CALL_OW 251
58429: PPUSH
58430: LD_VAR 0 2
58434: PPUSH
58435: LD_VAR 0 3
58439: PPUSH
58440: LD_VAR 0 4
58444: PPUSH
58445: CALL 58455 0 5
58449: ST_TO_ADDR
// end ;
58450: LD_VAR 0 5
58454: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
58455: LD_INT 0
58457: PPUSH
58458: PPUSH
58459: PPUSH
58460: PPUSH
// if not list then
58461: LD_VAR 0 3
58465: NOT
58466: IFFALSE 58470
// exit ;
58468: GO 58858
// result := [ ] ;
58470: LD_ADDR_VAR 0 6
58474: PUSH
58475: EMPTY
58476: ST_TO_ADDR
// for i in list do
58477: LD_ADDR_VAR 0 7
58481: PUSH
58482: LD_VAR 0 3
58486: PUSH
58487: FOR_IN
58488: IFFALSE 58690
// begin tmp := GetDistUnitXY ( i , x , y ) ;
58490: LD_ADDR_VAR 0 9
58494: PUSH
58495: LD_VAR 0 7
58499: PPUSH
58500: LD_VAR 0 1
58504: PPUSH
58505: LD_VAR 0 2
58509: PPUSH
58510: CALL_OW 297
58514: ST_TO_ADDR
// if not result then
58515: LD_VAR 0 6
58519: NOT
58520: IFFALSE 58546
// result := [ [ i , tmp ] ] else
58522: LD_ADDR_VAR 0 6
58526: PUSH
58527: LD_VAR 0 7
58531: PUSH
58532: LD_VAR 0 9
58536: PUSH
58537: EMPTY
58538: LIST
58539: LIST
58540: PUSH
58541: EMPTY
58542: LIST
58543: ST_TO_ADDR
58544: GO 58688
// begin if result [ result ] [ 2 ] < tmp then
58546: LD_VAR 0 6
58550: PUSH
58551: LD_VAR 0 6
58555: ARRAY
58556: PUSH
58557: LD_INT 2
58559: ARRAY
58560: PUSH
58561: LD_VAR 0 9
58565: LESS
58566: IFFALSE 58608
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
58568: LD_ADDR_VAR 0 6
58572: PUSH
58573: LD_VAR 0 6
58577: PPUSH
58578: LD_VAR 0 6
58582: PUSH
58583: LD_INT 1
58585: PLUS
58586: PPUSH
58587: LD_VAR 0 7
58591: PUSH
58592: LD_VAR 0 9
58596: PUSH
58597: EMPTY
58598: LIST
58599: LIST
58600: PPUSH
58601: CALL_OW 2
58605: ST_TO_ADDR
58606: GO 58688
// for j = 1 to result do
58608: LD_ADDR_VAR 0 8
58612: PUSH
58613: DOUBLE
58614: LD_INT 1
58616: DEC
58617: ST_TO_ADDR
58618: LD_VAR 0 6
58622: PUSH
58623: FOR_TO
58624: IFFALSE 58686
// begin if tmp < result [ j ] [ 2 ] then
58626: LD_VAR 0 9
58630: PUSH
58631: LD_VAR 0 6
58635: PUSH
58636: LD_VAR 0 8
58640: ARRAY
58641: PUSH
58642: LD_INT 2
58644: ARRAY
58645: LESS
58646: IFFALSE 58684
// begin result := Insert ( result , j , [ i , tmp ] ) ;
58648: LD_ADDR_VAR 0 6
58652: PUSH
58653: LD_VAR 0 6
58657: PPUSH
58658: LD_VAR 0 8
58662: PPUSH
58663: LD_VAR 0 7
58667: PUSH
58668: LD_VAR 0 9
58672: PUSH
58673: EMPTY
58674: LIST
58675: LIST
58676: PPUSH
58677: CALL_OW 2
58681: ST_TO_ADDR
// break ;
58682: GO 58686
// end ; end ;
58684: GO 58623
58686: POP
58687: POP
// end ; end ;
58688: GO 58487
58690: POP
58691: POP
// if result and not asc then
58692: LD_VAR 0 6
58696: PUSH
58697: LD_VAR 0 4
58701: NOT
58702: AND
58703: IFFALSE 58778
// begin tmp := result ;
58705: LD_ADDR_VAR 0 9
58709: PUSH
58710: LD_VAR 0 6
58714: ST_TO_ADDR
// for i = tmp downto 1 do
58715: LD_ADDR_VAR 0 7
58719: PUSH
58720: DOUBLE
58721: LD_VAR 0 9
58725: INC
58726: ST_TO_ADDR
58727: LD_INT 1
58729: PUSH
58730: FOR_DOWNTO
58731: IFFALSE 58776
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
58733: LD_ADDR_VAR 0 6
58737: PUSH
58738: LD_VAR 0 6
58742: PPUSH
58743: LD_VAR 0 9
58747: PUSH
58748: LD_VAR 0 7
58752: MINUS
58753: PUSH
58754: LD_INT 1
58756: PLUS
58757: PPUSH
58758: LD_VAR 0 9
58762: PUSH
58763: LD_VAR 0 7
58767: ARRAY
58768: PPUSH
58769: CALL_OW 1
58773: ST_TO_ADDR
58774: GO 58730
58776: POP
58777: POP
// end ; tmp := [ ] ;
58778: LD_ADDR_VAR 0 9
58782: PUSH
58783: EMPTY
58784: ST_TO_ADDR
// if mode then
58785: LD_VAR 0 5
58789: IFFALSE 58858
// begin for i = 1 to result do
58791: LD_ADDR_VAR 0 7
58795: PUSH
58796: DOUBLE
58797: LD_INT 1
58799: DEC
58800: ST_TO_ADDR
58801: LD_VAR 0 6
58805: PUSH
58806: FOR_TO
58807: IFFALSE 58846
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
58809: LD_ADDR_VAR 0 9
58813: PUSH
58814: LD_VAR 0 9
58818: PPUSH
58819: LD_VAR 0 7
58823: PPUSH
58824: LD_VAR 0 6
58828: PUSH
58829: LD_VAR 0 7
58833: ARRAY
58834: PUSH
58835: LD_INT 1
58837: ARRAY
58838: PPUSH
58839: CALL_OW 1
58843: ST_TO_ADDR
58844: GO 58806
58846: POP
58847: POP
// result := tmp ;
58848: LD_ADDR_VAR 0 6
58852: PUSH
58853: LD_VAR 0 9
58857: ST_TO_ADDR
// end ; end ;
58858: LD_VAR 0 6
58862: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
58863: LD_INT 0
58865: PPUSH
58866: PPUSH
58867: PPUSH
58868: PPUSH
58869: PPUSH
58870: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
58871: LD_ADDR_VAR 0 5
58875: PUSH
58876: LD_INT 0
58878: PUSH
58879: LD_INT 0
58881: PUSH
58882: LD_INT 0
58884: PUSH
58885: EMPTY
58886: PUSH
58887: EMPTY
58888: LIST
58889: LIST
58890: LIST
58891: LIST
58892: ST_TO_ADDR
// if not x or not y then
58893: LD_VAR 0 2
58897: NOT
58898: PUSH
58899: LD_VAR 0 3
58903: NOT
58904: OR
58905: IFFALSE 58909
// exit ;
58907: GO 60555
// if not range then
58909: LD_VAR 0 4
58913: NOT
58914: IFFALSE 58924
// range := 10 ;
58916: LD_ADDR_VAR 0 4
58920: PUSH
58921: LD_INT 10
58923: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
58924: LD_ADDR_VAR 0 8
58928: PUSH
58929: LD_INT 81
58931: PUSH
58932: LD_VAR 0 1
58936: PUSH
58937: EMPTY
58938: LIST
58939: LIST
58940: PUSH
58941: LD_INT 92
58943: PUSH
58944: LD_VAR 0 2
58948: PUSH
58949: LD_VAR 0 3
58953: PUSH
58954: LD_VAR 0 4
58958: PUSH
58959: EMPTY
58960: LIST
58961: LIST
58962: LIST
58963: LIST
58964: PUSH
58965: LD_INT 3
58967: PUSH
58968: LD_INT 21
58970: PUSH
58971: LD_INT 3
58973: PUSH
58974: EMPTY
58975: LIST
58976: LIST
58977: PUSH
58978: EMPTY
58979: LIST
58980: LIST
58981: PUSH
58982: EMPTY
58983: LIST
58984: LIST
58985: LIST
58986: PPUSH
58987: CALL_OW 69
58991: ST_TO_ADDR
// if not tmp then
58992: LD_VAR 0 8
58996: NOT
58997: IFFALSE 59001
// exit ;
58999: GO 60555
// for i in tmp do
59001: LD_ADDR_VAR 0 6
59005: PUSH
59006: LD_VAR 0 8
59010: PUSH
59011: FOR_IN
59012: IFFALSE 60530
// begin points := [ 0 , 0 , 0 ] ;
59014: LD_ADDR_VAR 0 9
59018: PUSH
59019: LD_INT 0
59021: PUSH
59022: LD_INT 0
59024: PUSH
59025: LD_INT 0
59027: PUSH
59028: EMPTY
59029: LIST
59030: LIST
59031: LIST
59032: ST_TO_ADDR
// bpoints := 1 ;
59033: LD_ADDR_VAR 0 10
59037: PUSH
59038: LD_INT 1
59040: ST_TO_ADDR
// case GetType ( i ) of unit_human :
59041: LD_VAR 0 6
59045: PPUSH
59046: CALL_OW 247
59050: PUSH
59051: LD_INT 1
59053: DOUBLE
59054: EQUAL
59055: IFTRUE 59059
59057: GO 59637
59059: POP
// begin if GetClass ( i ) = 1 then
59060: LD_VAR 0 6
59064: PPUSH
59065: CALL_OW 257
59069: PUSH
59070: LD_INT 1
59072: EQUAL
59073: IFFALSE 59094
// points := [ 10 , 5 , 3 ] ;
59075: LD_ADDR_VAR 0 9
59079: PUSH
59080: LD_INT 10
59082: PUSH
59083: LD_INT 5
59085: PUSH
59086: LD_INT 3
59088: PUSH
59089: EMPTY
59090: LIST
59091: LIST
59092: LIST
59093: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
59094: LD_VAR 0 6
59098: PPUSH
59099: CALL_OW 257
59103: PUSH
59104: LD_INT 2
59106: PUSH
59107: LD_INT 3
59109: PUSH
59110: LD_INT 4
59112: PUSH
59113: EMPTY
59114: LIST
59115: LIST
59116: LIST
59117: IN
59118: IFFALSE 59139
// points := [ 3 , 2 , 1 ] ;
59120: LD_ADDR_VAR 0 9
59124: PUSH
59125: LD_INT 3
59127: PUSH
59128: LD_INT 2
59130: PUSH
59131: LD_INT 1
59133: PUSH
59134: EMPTY
59135: LIST
59136: LIST
59137: LIST
59138: ST_TO_ADDR
// if GetClass ( i ) = 5 then
59139: LD_VAR 0 6
59143: PPUSH
59144: CALL_OW 257
59148: PUSH
59149: LD_INT 5
59151: EQUAL
59152: IFFALSE 59173
// points := [ 130 , 5 , 2 ] ;
59154: LD_ADDR_VAR 0 9
59158: PUSH
59159: LD_INT 130
59161: PUSH
59162: LD_INT 5
59164: PUSH
59165: LD_INT 2
59167: PUSH
59168: EMPTY
59169: LIST
59170: LIST
59171: LIST
59172: ST_TO_ADDR
// if GetClass ( i ) = 8 then
59173: LD_VAR 0 6
59177: PPUSH
59178: CALL_OW 257
59182: PUSH
59183: LD_INT 8
59185: EQUAL
59186: IFFALSE 59207
// points := [ 35 , 35 , 30 ] ;
59188: LD_ADDR_VAR 0 9
59192: PUSH
59193: LD_INT 35
59195: PUSH
59196: LD_INT 35
59198: PUSH
59199: LD_INT 30
59201: PUSH
59202: EMPTY
59203: LIST
59204: LIST
59205: LIST
59206: ST_TO_ADDR
// if GetClass ( i ) = 9 then
59207: LD_VAR 0 6
59211: PPUSH
59212: CALL_OW 257
59216: PUSH
59217: LD_INT 9
59219: EQUAL
59220: IFFALSE 59241
// points := [ 20 , 55 , 40 ] ;
59222: LD_ADDR_VAR 0 9
59226: PUSH
59227: LD_INT 20
59229: PUSH
59230: LD_INT 55
59232: PUSH
59233: LD_INT 40
59235: PUSH
59236: EMPTY
59237: LIST
59238: LIST
59239: LIST
59240: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
59241: LD_VAR 0 6
59245: PPUSH
59246: CALL_OW 257
59250: PUSH
59251: LD_INT 12
59253: PUSH
59254: LD_INT 16
59256: PUSH
59257: EMPTY
59258: LIST
59259: LIST
59260: IN
59261: IFFALSE 59282
// points := [ 5 , 3 , 2 ] ;
59263: LD_ADDR_VAR 0 9
59267: PUSH
59268: LD_INT 5
59270: PUSH
59271: LD_INT 3
59273: PUSH
59274: LD_INT 2
59276: PUSH
59277: EMPTY
59278: LIST
59279: LIST
59280: LIST
59281: ST_TO_ADDR
// if GetClass ( i ) = 17 then
59282: LD_VAR 0 6
59286: PPUSH
59287: CALL_OW 257
59291: PUSH
59292: LD_INT 17
59294: EQUAL
59295: IFFALSE 59316
// points := [ 100 , 50 , 75 ] ;
59297: LD_ADDR_VAR 0 9
59301: PUSH
59302: LD_INT 100
59304: PUSH
59305: LD_INT 50
59307: PUSH
59308: LD_INT 75
59310: PUSH
59311: EMPTY
59312: LIST
59313: LIST
59314: LIST
59315: ST_TO_ADDR
// if GetClass ( i ) = 15 then
59316: LD_VAR 0 6
59320: PPUSH
59321: CALL_OW 257
59325: PUSH
59326: LD_INT 15
59328: EQUAL
59329: IFFALSE 59350
// points := [ 10 , 5 , 3 ] ;
59331: LD_ADDR_VAR 0 9
59335: PUSH
59336: LD_INT 10
59338: PUSH
59339: LD_INT 5
59341: PUSH
59342: LD_INT 3
59344: PUSH
59345: EMPTY
59346: LIST
59347: LIST
59348: LIST
59349: ST_TO_ADDR
// if GetClass ( i ) = 14 then
59350: LD_VAR 0 6
59354: PPUSH
59355: CALL_OW 257
59359: PUSH
59360: LD_INT 14
59362: EQUAL
59363: IFFALSE 59384
// points := [ 10 , 0 , 0 ] ;
59365: LD_ADDR_VAR 0 9
59369: PUSH
59370: LD_INT 10
59372: PUSH
59373: LD_INT 0
59375: PUSH
59376: LD_INT 0
59378: PUSH
59379: EMPTY
59380: LIST
59381: LIST
59382: LIST
59383: ST_TO_ADDR
// if GetClass ( i ) = 11 then
59384: LD_VAR 0 6
59388: PPUSH
59389: CALL_OW 257
59393: PUSH
59394: LD_INT 11
59396: EQUAL
59397: IFFALSE 59418
// points := [ 30 , 10 , 5 ] ;
59399: LD_ADDR_VAR 0 9
59403: PUSH
59404: LD_INT 30
59406: PUSH
59407: LD_INT 10
59409: PUSH
59410: LD_INT 5
59412: PUSH
59413: EMPTY
59414: LIST
59415: LIST
59416: LIST
59417: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
59418: LD_VAR 0 1
59422: PPUSH
59423: LD_INT 5
59425: PPUSH
59426: CALL_OW 321
59430: PUSH
59431: LD_INT 2
59433: EQUAL
59434: IFFALSE 59451
// bpoints := bpoints * 1.8 ;
59436: LD_ADDR_VAR 0 10
59440: PUSH
59441: LD_VAR 0 10
59445: PUSH
59446: LD_REAL  1.80000000000000E+0000
59449: MUL
59450: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
59451: LD_VAR 0 6
59455: PPUSH
59456: CALL_OW 257
59460: PUSH
59461: LD_INT 1
59463: PUSH
59464: LD_INT 2
59466: PUSH
59467: LD_INT 3
59469: PUSH
59470: LD_INT 4
59472: PUSH
59473: EMPTY
59474: LIST
59475: LIST
59476: LIST
59477: LIST
59478: IN
59479: PUSH
59480: LD_VAR 0 1
59484: PPUSH
59485: LD_INT 51
59487: PPUSH
59488: CALL_OW 321
59492: PUSH
59493: LD_INT 2
59495: EQUAL
59496: AND
59497: IFFALSE 59514
// bpoints := bpoints * 1.2 ;
59499: LD_ADDR_VAR 0 10
59503: PUSH
59504: LD_VAR 0 10
59508: PUSH
59509: LD_REAL  1.20000000000000E+0000
59512: MUL
59513: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
59514: LD_VAR 0 6
59518: PPUSH
59519: CALL_OW 257
59523: PUSH
59524: LD_INT 5
59526: PUSH
59527: LD_INT 7
59529: PUSH
59530: LD_INT 9
59532: PUSH
59533: EMPTY
59534: LIST
59535: LIST
59536: LIST
59537: IN
59538: PUSH
59539: LD_VAR 0 1
59543: PPUSH
59544: LD_INT 52
59546: PPUSH
59547: CALL_OW 321
59551: PUSH
59552: LD_INT 2
59554: EQUAL
59555: AND
59556: IFFALSE 59573
// bpoints := bpoints * 1.5 ;
59558: LD_ADDR_VAR 0 10
59562: PUSH
59563: LD_VAR 0 10
59567: PUSH
59568: LD_REAL  1.50000000000000E+0000
59571: MUL
59572: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
59573: LD_VAR 0 1
59577: PPUSH
59578: LD_INT 66
59580: PPUSH
59581: CALL_OW 321
59585: PUSH
59586: LD_INT 2
59588: EQUAL
59589: IFFALSE 59606
// bpoints := bpoints * 1.1 ;
59591: LD_ADDR_VAR 0 10
59595: PUSH
59596: LD_VAR 0 10
59600: PUSH
59601: LD_REAL  1.10000000000000E+0000
59604: MUL
59605: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
59606: LD_ADDR_VAR 0 10
59610: PUSH
59611: LD_VAR 0 10
59615: PUSH
59616: LD_VAR 0 6
59620: PPUSH
59621: LD_INT 1
59623: PPUSH
59624: CALL_OW 259
59628: PUSH
59629: LD_REAL  1.15000000000000E+0000
59632: MUL
59633: MUL
59634: ST_TO_ADDR
// end ; unit_vehicle :
59635: GO 60459
59637: LD_INT 2
59639: DOUBLE
59640: EQUAL
59641: IFTRUE 59645
59643: GO 60447
59645: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
59646: LD_VAR 0 6
59650: PPUSH
59651: CALL_OW 264
59655: PUSH
59656: LD_INT 2
59658: PUSH
59659: LD_INT 42
59661: PUSH
59662: LD_INT 24
59664: PUSH
59665: EMPTY
59666: LIST
59667: LIST
59668: LIST
59669: IN
59670: IFFALSE 59691
// points := [ 25 , 5 , 3 ] ;
59672: LD_ADDR_VAR 0 9
59676: PUSH
59677: LD_INT 25
59679: PUSH
59680: LD_INT 5
59682: PUSH
59683: LD_INT 3
59685: PUSH
59686: EMPTY
59687: LIST
59688: LIST
59689: LIST
59690: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
59691: LD_VAR 0 6
59695: PPUSH
59696: CALL_OW 264
59700: PUSH
59701: LD_INT 4
59703: PUSH
59704: LD_INT 43
59706: PUSH
59707: LD_INT 25
59709: PUSH
59710: EMPTY
59711: LIST
59712: LIST
59713: LIST
59714: IN
59715: IFFALSE 59736
// points := [ 40 , 15 , 5 ] ;
59717: LD_ADDR_VAR 0 9
59721: PUSH
59722: LD_INT 40
59724: PUSH
59725: LD_INT 15
59727: PUSH
59728: LD_INT 5
59730: PUSH
59731: EMPTY
59732: LIST
59733: LIST
59734: LIST
59735: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
59736: LD_VAR 0 6
59740: PPUSH
59741: CALL_OW 264
59745: PUSH
59746: LD_INT 3
59748: PUSH
59749: LD_INT 23
59751: PUSH
59752: EMPTY
59753: LIST
59754: LIST
59755: IN
59756: IFFALSE 59777
// points := [ 7 , 25 , 8 ] ;
59758: LD_ADDR_VAR 0 9
59762: PUSH
59763: LD_INT 7
59765: PUSH
59766: LD_INT 25
59768: PUSH
59769: LD_INT 8
59771: PUSH
59772: EMPTY
59773: LIST
59774: LIST
59775: LIST
59776: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
59777: LD_VAR 0 6
59781: PPUSH
59782: CALL_OW 264
59786: PUSH
59787: LD_INT 5
59789: PUSH
59790: LD_INT 27
59792: PUSH
59793: LD_INT 44
59795: PUSH
59796: EMPTY
59797: LIST
59798: LIST
59799: LIST
59800: IN
59801: IFFALSE 59822
// points := [ 14 , 50 , 16 ] ;
59803: LD_ADDR_VAR 0 9
59807: PUSH
59808: LD_INT 14
59810: PUSH
59811: LD_INT 50
59813: PUSH
59814: LD_INT 16
59816: PUSH
59817: EMPTY
59818: LIST
59819: LIST
59820: LIST
59821: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
59822: LD_VAR 0 6
59826: PPUSH
59827: CALL_OW 264
59831: PUSH
59832: LD_INT 6
59834: PUSH
59835: LD_INT 46
59837: PUSH
59838: EMPTY
59839: LIST
59840: LIST
59841: IN
59842: IFFALSE 59863
// points := [ 32 , 120 , 70 ] ;
59844: LD_ADDR_VAR 0 9
59848: PUSH
59849: LD_INT 32
59851: PUSH
59852: LD_INT 120
59854: PUSH
59855: LD_INT 70
59857: PUSH
59858: EMPTY
59859: LIST
59860: LIST
59861: LIST
59862: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
59863: LD_VAR 0 6
59867: PPUSH
59868: CALL_OW 264
59872: PUSH
59873: LD_INT 7
59875: PUSH
59876: LD_INT 28
59878: PUSH
59879: LD_INT 45
59881: PUSH
59882: EMPTY
59883: LIST
59884: LIST
59885: LIST
59886: IN
59887: IFFALSE 59908
// points := [ 35 , 20 , 45 ] ;
59889: LD_ADDR_VAR 0 9
59893: PUSH
59894: LD_INT 35
59896: PUSH
59897: LD_INT 20
59899: PUSH
59900: LD_INT 45
59902: PUSH
59903: EMPTY
59904: LIST
59905: LIST
59906: LIST
59907: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
59908: LD_VAR 0 6
59912: PPUSH
59913: CALL_OW 264
59917: PUSH
59918: LD_INT 47
59920: PUSH
59921: EMPTY
59922: LIST
59923: IN
59924: IFFALSE 59945
// points := [ 67 , 45 , 75 ] ;
59926: LD_ADDR_VAR 0 9
59930: PUSH
59931: LD_INT 67
59933: PUSH
59934: LD_INT 45
59936: PUSH
59937: LD_INT 75
59939: PUSH
59940: EMPTY
59941: LIST
59942: LIST
59943: LIST
59944: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
59945: LD_VAR 0 6
59949: PPUSH
59950: CALL_OW 264
59954: PUSH
59955: LD_INT 26
59957: PUSH
59958: EMPTY
59959: LIST
59960: IN
59961: IFFALSE 59982
// points := [ 120 , 30 , 80 ] ;
59963: LD_ADDR_VAR 0 9
59967: PUSH
59968: LD_INT 120
59970: PUSH
59971: LD_INT 30
59973: PUSH
59974: LD_INT 80
59976: PUSH
59977: EMPTY
59978: LIST
59979: LIST
59980: LIST
59981: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
59982: LD_VAR 0 6
59986: PPUSH
59987: CALL_OW 264
59991: PUSH
59992: LD_INT 22
59994: PUSH
59995: EMPTY
59996: LIST
59997: IN
59998: IFFALSE 60019
// points := [ 40 , 1 , 1 ] ;
60000: LD_ADDR_VAR 0 9
60004: PUSH
60005: LD_INT 40
60007: PUSH
60008: LD_INT 1
60010: PUSH
60011: LD_INT 1
60013: PUSH
60014: EMPTY
60015: LIST
60016: LIST
60017: LIST
60018: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
60019: LD_VAR 0 6
60023: PPUSH
60024: CALL_OW 264
60028: PUSH
60029: LD_INT 29
60031: PUSH
60032: EMPTY
60033: LIST
60034: IN
60035: IFFALSE 60056
// points := [ 70 , 200 , 400 ] ;
60037: LD_ADDR_VAR 0 9
60041: PUSH
60042: LD_INT 70
60044: PUSH
60045: LD_INT 200
60047: PUSH
60048: LD_INT 400
60050: PUSH
60051: EMPTY
60052: LIST
60053: LIST
60054: LIST
60055: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
60056: LD_VAR 0 6
60060: PPUSH
60061: CALL_OW 264
60065: PUSH
60066: LD_INT 14
60068: PUSH
60069: LD_INT 53
60071: PUSH
60072: EMPTY
60073: LIST
60074: LIST
60075: IN
60076: IFFALSE 60097
// points := [ 40 , 10 , 20 ] ;
60078: LD_ADDR_VAR 0 9
60082: PUSH
60083: LD_INT 40
60085: PUSH
60086: LD_INT 10
60088: PUSH
60089: LD_INT 20
60091: PUSH
60092: EMPTY
60093: LIST
60094: LIST
60095: LIST
60096: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
60097: LD_VAR 0 6
60101: PPUSH
60102: CALL_OW 264
60106: PUSH
60107: LD_INT 9
60109: PUSH
60110: EMPTY
60111: LIST
60112: IN
60113: IFFALSE 60134
// points := [ 5 , 70 , 20 ] ;
60115: LD_ADDR_VAR 0 9
60119: PUSH
60120: LD_INT 5
60122: PUSH
60123: LD_INT 70
60125: PUSH
60126: LD_INT 20
60128: PUSH
60129: EMPTY
60130: LIST
60131: LIST
60132: LIST
60133: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
60134: LD_VAR 0 6
60138: PPUSH
60139: CALL_OW 264
60143: PUSH
60144: LD_INT 10
60146: PUSH
60147: EMPTY
60148: LIST
60149: IN
60150: IFFALSE 60171
// points := [ 35 , 110 , 70 ] ;
60152: LD_ADDR_VAR 0 9
60156: PUSH
60157: LD_INT 35
60159: PUSH
60160: LD_INT 110
60162: PUSH
60163: LD_INT 70
60165: PUSH
60166: EMPTY
60167: LIST
60168: LIST
60169: LIST
60170: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
60171: LD_VAR 0 6
60175: PPUSH
60176: CALL_OW 265
60180: PUSH
60181: LD_INT 25
60183: EQUAL
60184: IFFALSE 60205
// points := [ 80 , 65 , 100 ] ;
60186: LD_ADDR_VAR 0 9
60190: PUSH
60191: LD_INT 80
60193: PUSH
60194: LD_INT 65
60196: PUSH
60197: LD_INT 100
60199: PUSH
60200: EMPTY
60201: LIST
60202: LIST
60203: LIST
60204: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
60205: LD_VAR 0 6
60209: PPUSH
60210: CALL_OW 263
60214: PUSH
60215: LD_INT 1
60217: EQUAL
60218: IFFALSE 60253
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
60220: LD_ADDR_VAR 0 10
60224: PUSH
60225: LD_VAR 0 10
60229: PUSH
60230: LD_VAR 0 6
60234: PPUSH
60235: CALL_OW 311
60239: PPUSH
60240: LD_INT 3
60242: PPUSH
60243: CALL_OW 259
60247: PUSH
60248: LD_INT 4
60250: MUL
60251: MUL
60252: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
60253: LD_VAR 0 6
60257: PPUSH
60258: CALL_OW 263
60262: PUSH
60263: LD_INT 2
60265: EQUAL
60266: IFFALSE 60317
// begin j := IsControledBy ( i ) ;
60268: LD_ADDR_VAR 0 7
60272: PUSH
60273: LD_VAR 0 6
60277: PPUSH
60278: CALL_OW 312
60282: ST_TO_ADDR
// if j then
60283: LD_VAR 0 7
60287: IFFALSE 60317
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
60289: LD_ADDR_VAR 0 10
60293: PUSH
60294: LD_VAR 0 10
60298: PUSH
60299: LD_VAR 0 7
60303: PPUSH
60304: LD_INT 3
60306: PPUSH
60307: CALL_OW 259
60311: PUSH
60312: LD_INT 3
60314: MUL
60315: MUL
60316: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
60317: LD_VAR 0 6
60321: PPUSH
60322: CALL_OW 264
60326: PUSH
60327: LD_INT 5
60329: PUSH
60330: LD_INT 6
60332: PUSH
60333: LD_INT 46
60335: PUSH
60336: LD_INT 44
60338: PUSH
60339: LD_INT 47
60341: PUSH
60342: LD_INT 45
60344: PUSH
60345: LD_INT 28
60347: PUSH
60348: LD_INT 7
60350: PUSH
60351: LD_INT 27
60353: PUSH
60354: LD_INT 29
60356: PUSH
60357: EMPTY
60358: LIST
60359: LIST
60360: LIST
60361: LIST
60362: LIST
60363: LIST
60364: LIST
60365: LIST
60366: LIST
60367: LIST
60368: IN
60369: PUSH
60370: LD_VAR 0 1
60374: PPUSH
60375: LD_INT 52
60377: PPUSH
60378: CALL_OW 321
60382: PUSH
60383: LD_INT 2
60385: EQUAL
60386: AND
60387: IFFALSE 60404
// bpoints := bpoints * 1.2 ;
60389: LD_ADDR_VAR 0 10
60393: PUSH
60394: LD_VAR 0 10
60398: PUSH
60399: LD_REAL  1.20000000000000E+0000
60402: MUL
60403: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
60404: LD_VAR 0 6
60408: PPUSH
60409: CALL_OW 264
60413: PUSH
60414: LD_INT 6
60416: PUSH
60417: LD_INT 46
60419: PUSH
60420: LD_INT 47
60422: PUSH
60423: EMPTY
60424: LIST
60425: LIST
60426: LIST
60427: IN
60428: IFFALSE 60445
// bpoints := bpoints * 1.2 ;
60430: LD_ADDR_VAR 0 10
60434: PUSH
60435: LD_VAR 0 10
60439: PUSH
60440: LD_REAL  1.20000000000000E+0000
60443: MUL
60444: ST_TO_ADDR
// end ; unit_building :
60445: GO 60459
60447: LD_INT 3
60449: DOUBLE
60450: EQUAL
60451: IFTRUE 60455
60453: GO 60458
60455: POP
// ; end ;
60456: GO 60459
60458: POP
// for j = 1 to 3 do
60459: LD_ADDR_VAR 0 7
60463: PUSH
60464: DOUBLE
60465: LD_INT 1
60467: DEC
60468: ST_TO_ADDR
60469: LD_INT 3
60471: PUSH
60472: FOR_TO
60473: IFFALSE 60526
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
60475: LD_ADDR_VAR 0 5
60479: PUSH
60480: LD_VAR 0 5
60484: PPUSH
60485: LD_VAR 0 7
60489: PPUSH
60490: LD_VAR 0 5
60494: PUSH
60495: LD_VAR 0 7
60499: ARRAY
60500: PUSH
60501: LD_VAR 0 9
60505: PUSH
60506: LD_VAR 0 7
60510: ARRAY
60511: PUSH
60512: LD_VAR 0 10
60516: MUL
60517: PLUS
60518: PPUSH
60519: CALL_OW 1
60523: ST_TO_ADDR
60524: GO 60472
60526: POP
60527: POP
// end ;
60528: GO 59011
60530: POP
60531: POP
// result := Replace ( result , 4 , tmp ) ;
60532: LD_ADDR_VAR 0 5
60536: PUSH
60537: LD_VAR 0 5
60541: PPUSH
60542: LD_INT 4
60544: PPUSH
60545: LD_VAR 0 8
60549: PPUSH
60550: CALL_OW 1
60554: ST_TO_ADDR
// end ;
60555: LD_VAR 0 5
60559: RET
// export function DangerAtRange ( unit , range ) ; begin
60560: LD_INT 0
60562: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
60563: LD_ADDR_VAR 0 3
60567: PUSH
60568: LD_VAR 0 1
60572: PPUSH
60573: CALL_OW 255
60577: PPUSH
60578: LD_VAR 0 1
60582: PPUSH
60583: CALL_OW 250
60587: PPUSH
60588: LD_VAR 0 1
60592: PPUSH
60593: CALL_OW 251
60597: PPUSH
60598: LD_VAR 0 2
60602: PPUSH
60603: CALL 58863 0 4
60607: ST_TO_ADDR
// end ;
60608: LD_VAR 0 3
60612: RET
// export function DangerInArea ( side , area ) ; begin
60613: LD_INT 0
60615: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
60616: LD_ADDR_VAR 0 3
60620: PUSH
60621: LD_VAR 0 2
60625: PPUSH
60626: LD_INT 81
60628: PUSH
60629: LD_VAR 0 1
60633: PUSH
60634: EMPTY
60635: LIST
60636: LIST
60637: PPUSH
60638: CALL_OW 70
60642: ST_TO_ADDR
// end ;
60643: LD_VAR 0 3
60647: RET
// export function IsExtension ( b ) ; begin
60648: LD_INT 0
60650: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
60651: LD_ADDR_VAR 0 2
60655: PUSH
60656: LD_VAR 0 1
60660: PUSH
60661: LD_INT 23
60663: PUSH
60664: LD_INT 20
60666: PUSH
60667: LD_INT 22
60669: PUSH
60670: LD_INT 17
60672: PUSH
60673: LD_INT 24
60675: PUSH
60676: LD_INT 21
60678: PUSH
60679: LD_INT 19
60681: PUSH
60682: LD_INT 16
60684: PUSH
60685: LD_INT 25
60687: PUSH
60688: LD_INT 18
60690: PUSH
60691: EMPTY
60692: LIST
60693: LIST
60694: LIST
60695: LIST
60696: LIST
60697: LIST
60698: LIST
60699: LIST
60700: LIST
60701: LIST
60702: IN
60703: ST_TO_ADDR
// end ;
60704: LD_VAR 0 2
60708: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
60709: LD_INT 0
60711: PPUSH
60712: PPUSH
60713: PPUSH
// result := [ ] ;
60714: LD_ADDR_VAR 0 3
60718: PUSH
60719: EMPTY
60720: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
60721: LD_ADDR_VAR 0 4
60725: PUSH
60726: LD_VAR 0 2
60730: PPUSH
60731: LD_INT 21
60733: PUSH
60734: LD_INT 3
60736: PUSH
60737: EMPTY
60738: LIST
60739: LIST
60740: PPUSH
60741: CALL_OW 70
60745: ST_TO_ADDR
// if not tmp then
60746: LD_VAR 0 4
60750: NOT
60751: IFFALSE 60755
// exit ;
60753: GO 60813
// for i in tmp do
60755: LD_ADDR_VAR 0 5
60759: PUSH
60760: LD_VAR 0 4
60764: PUSH
60765: FOR_IN
60766: IFFALSE 60801
// if GetBase ( i ) <> base then
60768: LD_VAR 0 5
60772: PPUSH
60773: CALL_OW 274
60777: PUSH
60778: LD_VAR 0 1
60782: NONEQUAL
60783: IFFALSE 60799
// ComLinkToBase ( base , i ) ;
60785: LD_VAR 0 1
60789: PPUSH
60790: LD_VAR 0 5
60794: PPUSH
60795: CALL_OW 169
60799: GO 60765
60801: POP
60802: POP
// result := tmp ;
60803: LD_ADDR_VAR 0 3
60807: PUSH
60808: LD_VAR 0 4
60812: ST_TO_ADDR
// end ;
60813: LD_VAR 0 3
60817: RET
// export function ComComplete ( unit , b ) ; var i ; begin
60818: LD_INT 0
60820: PPUSH
60821: PPUSH
// if BuildingStatus ( b ) = bs_build then
60822: LD_VAR 0 2
60826: PPUSH
60827: CALL_OW 461
60831: PUSH
60832: LD_INT 1
60834: EQUAL
60835: IFFALSE 60895
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
60837: LD_VAR 0 1
60841: PPUSH
60842: LD_STRING h
60844: PUSH
60845: LD_VAR 0 2
60849: PPUSH
60850: CALL_OW 250
60854: PUSH
60855: LD_VAR 0 2
60859: PPUSH
60860: CALL_OW 251
60864: PUSH
60865: LD_VAR 0 2
60869: PUSH
60870: LD_INT 0
60872: PUSH
60873: LD_INT 0
60875: PUSH
60876: LD_INT 0
60878: PUSH
60879: EMPTY
60880: LIST
60881: LIST
60882: LIST
60883: LIST
60884: LIST
60885: LIST
60886: LIST
60887: PUSH
60888: EMPTY
60889: LIST
60890: PPUSH
60891: CALL_OW 446
// end ;
60895: LD_VAR 0 3
60899: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
60900: LD_INT 0
60902: PPUSH
60903: PPUSH
60904: PPUSH
60905: PPUSH
60906: PPUSH
60907: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
60908: LD_VAR 0 1
60912: NOT
60913: PUSH
60914: LD_VAR 0 1
60918: PPUSH
60919: CALL_OW 263
60923: PUSH
60924: LD_INT 2
60926: EQUAL
60927: NOT
60928: OR
60929: IFFALSE 60933
// exit ;
60931: GO 61249
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
60933: LD_ADDR_VAR 0 6
60937: PUSH
60938: LD_INT 22
60940: PUSH
60941: LD_VAR 0 1
60945: PPUSH
60946: CALL_OW 255
60950: PUSH
60951: EMPTY
60952: LIST
60953: LIST
60954: PUSH
60955: LD_INT 2
60957: PUSH
60958: LD_INT 30
60960: PUSH
60961: LD_INT 36
60963: PUSH
60964: EMPTY
60965: LIST
60966: LIST
60967: PUSH
60968: LD_INT 34
60970: PUSH
60971: LD_INT 31
60973: PUSH
60974: EMPTY
60975: LIST
60976: LIST
60977: PUSH
60978: EMPTY
60979: LIST
60980: LIST
60981: LIST
60982: PUSH
60983: EMPTY
60984: LIST
60985: LIST
60986: PPUSH
60987: CALL_OW 69
60991: ST_TO_ADDR
// if not tmp then
60992: LD_VAR 0 6
60996: NOT
60997: IFFALSE 61001
// exit ;
60999: GO 61249
// result := [ ] ;
61001: LD_ADDR_VAR 0 2
61005: PUSH
61006: EMPTY
61007: ST_TO_ADDR
// for i in tmp do
61008: LD_ADDR_VAR 0 3
61012: PUSH
61013: LD_VAR 0 6
61017: PUSH
61018: FOR_IN
61019: IFFALSE 61090
// begin t := UnitsInside ( i ) ;
61021: LD_ADDR_VAR 0 4
61025: PUSH
61026: LD_VAR 0 3
61030: PPUSH
61031: CALL_OW 313
61035: ST_TO_ADDR
// if t then
61036: LD_VAR 0 4
61040: IFFALSE 61088
// for j in t do
61042: LD_ADDR_VAR 0 7
61046: PUSH
61047: LD_VAR 0 4
61051: PUSH
61052: FOR_IN
61053: IFFALSE 61086
// result := Insert ( result , result + 1 , j ) ;
61055: LD_ADDR_VAR 0 2
61059: PUSH
61060: LD_VAR 0 2
61064: PPUSH
61065: LD_VAR 0 2
61069: PUSH
61070: LD_INT 1
61072: PLUS
61073: PPUSH
61074: LD_VAR 0 7
61078: PPUSH
61079: CALL_OW 2
61083: ST_TO_ADDR
61084: GO 61052
61086: POP
61087: POP
// end ;
61088: GO 61018
61090: POP
61091: POP
// if not result then
61092: LD_VAR 0 2
61096: NOT
61097: IFFALSE 61101
// exit ;
61099: GO 61249
// mech := result [ 1 ] ;
61101: LD_ADDR_VAR 0 5
61105: PUSH
61106: LD_VAR 0 2
61110: PUSH
61111: LD_INT 1
61113: ARRAY
61114: ST_TO_ADDR
// if result > 1 then
61115: LD_VAR 0 2
61119: PUSH
61120: LD_INT 1
61122: GREATER
61123: IFFALSE 61235
// for i = 2 to result do
61125: LD_ADDR_VAR 0 3
61129: PUSH
61130: DOUBLE
61131: LD_INT 2
61133: DEC
61134: ST_TO_ADDR
61135: LD_VAR 0 2
61139: PUSH
61140: FOR_TO
61141: IFFALSE 61233
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
61143: LD_ADDR_VAR 0 4
61147: PUSH
61148: LD_VAR 0 2
61152: PUSH
61153: LD_VAR 0 3
61157: ARRAY
61158: PPUSH
61159: LD_INT 3
61161: PPUSH
61162: CALL_OW 259
61166: PUSH
61167: LD_VAR 0 2
61171: PUSH
61172: LD_VAR 0 3
61176: ARRAY
61177: PPUSH
61178: CALL_OW 432
61182: MINUS
61183: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
61184: LD_VAR 0 4
61188: PUSH
61189: LD_VAR 0 5
61193: PPUSH
61194: LD_INT 3
61196: PPUSH
61197: CALL_OW 259
61201: PUSH
61202: LD_VAR 0 5
61206: PPUSH
61207: CALL_OW 432
61211: MINUS
61212: GREATEREQUAL
61213: IFFALSE 61231
// mech := result [ i ] ;
61215: LD_ADDR_VAR 0 5
61219: PUSH
61220: LD_VAR 0 2
61224: PUSH
61225: LD_VAR 0 3
61229: ARRAY
61230: ST_TO_ADDR
// end ;
61231: GO 61140
61233: POP
61234: POP
// ComLinkTo ( vehicle , mech ) ;
61235: LD_VAR 0 1
61239: PPUSH
61240: LD_VAR 0 5
61244: PPUSH
61245: CALL_OW 135
// end ;
61249: LD_VAR 0 2
61253: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
61254: LD_INT 0
61256: PPUSH
61257: PPUSH
61258: PPUSH
61259: PPUSH
61260: PPUSH
61261: PPUSH
61262: PPUSH
61263: PPUSH
61264: PPUSH
61265: PPUSH
61266: PPUSH
61267: PPUSH
61268: PPUSH
// result := [ ] ;
61269: LD_ADDR_VAR 0 7
61273: PUSH
61274: EMPTY
61275: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
61276: LD_VAR 0 1
61280: PPUSH
61281: CALL_OW 266
61285: PUSH
61286: LD_INT 0
61288: PUSH
61289: LD_INT 1
61291: PUSH
61292: EMPTY
61293: LIST
61294: LIST
61295: IN
61296: NOT
61297: IFFALSE 61301
// exit ;
61299: GO 62932
// if name then
61301: LD_VAR 0 3
61305: IFFALSE 61321
// SetBName ( base_dep , name ) ;
61307: LD_VAR 0 1
61311: PPUSH
61312: LD_VAR 0 3
61316: PPUSH
61317: CALL_OW 500
// base := GetBase ( base_dep ) ;
61321: LD_ADDR_VAR 0 15
61325: PUSH
61326: LD_VAR 0 1
61330: PPUSH
61331: CALL_OW 274
61335: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
61336: LD_ADDR_VAR 0 16
61340: PUSH
61341: LD_VAR 0 1
61345: PPUSH
61346: CALL_OW 255
61350: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
61351: LD_ADDR_VAR 0 17
61355: PUSH
61356: LD_VAR 0 1
61360: PPUSH
61361: CALL_OW 248
61365: ST_TO_ADDR
// if sources then
61366: LD_VAR 0 5
61370: IFFALSE 61417
// for i = 1 to 3 do
61372: LD_ADDR_VAR 0 8
61376: PUSH
61377: DOUBLE
61378: LD_INT 1
61380: DEC
61381: ST_TO_ADDR
61382: LD_INT 3
61384: PUSH
61385: FOR_TO
61386: IFFALSE 61415
// AddResourceType ( base , i , sources [ i ] ) ;
61388: LD_VAR 0 15
61392: PPUSH
61393: LD_VAR 0 8
61397: PPUSH
61398: LD_VAR 0 5
61402: PUSH
61403: LD_VAR 0 8
61407: ARRAY
61408: PPUSH
61409: CALL_OW 276
61413: GO 61385
61415: POP
61416: POP
// buildings := GetBaseBuildings ( base , area ) ;
61417: LD_ADDR_VAR 0 18
61421: PUSH
61422: LD_VAR 0 15
61426: PPUSH
61427: LD_VAR 0 2
61431: PPUSH
61432: CALL 60709 0 2
61436: ST_TO_ADDR
// InitHc ;
61437: CALL_OW 19
// InitUc ;
61441: CALL_OW 18
// uc_side := side ;
61445: LD_ADDR_OWVAR 20
61449: PUSH
61450: LD_VAR 0 16
61454: ST_TO_ADDR
// uc_nation := nation ;
61455: LD_ADDR_OWVAR 21
61459: PUSH
61460: LD_VAR 0 17
61464: ST_TO_ADDR
// if buildings then
61465: LD_VAR 0 18
61469: IFFALSE 62791
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
61471: LD_ADDR_VAR 0 19
61475: PUSH
61476: LD_VAR 0 18
61480: PPUSH
61481: LD_INT 2
61483: PUSH
61484: LD_INT 30
61486: PUSH
61487: LD_INT 29
61489: PUSH
61490: EMPTY
61491: LIST
61492: LIST
61493: PUSH
61494: LD_INT 30
61496: PUSH
61497: LD_INT 30
61499: PUSH
61500: EMPTY
61501: LIST
61502: LIST
61503: PUSH
61504: EMPTY
61505: LIST
61506: LIST
61507: LIST
61508: PPUSH
61509: CALL_OW 72
61513: ST_TO_ADDR
// if tmp then
61514: LD_VAR 0 19
61518: IFFALSE 61566
// for i in tmp do
61520: LD_ADDR_VAR 0 8
61524: PUSH
61525: LD_VAR 0 19
61529: PUSH
61530: FOR_IN
61531: IFFALSE 61564
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
61533: LD_VAR 0 8
61537: PPUSH
61538: CALL_OW 250
61542: PPUSH
61543: LD_VAR 0 8
61547: PPUSH
61548: CALL_OW 251
61552: PPUSH
61553: LD_VAR 0 16
61557: PPUSH
61558: CALL_OW 441
61562: GO 61530
61564: POP
61565: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
61566: LD_VAR 0 18
61570: PPUSH
61571: LD_INT 2
61573: PUSH
61574: LD_INT 30
61576: PUSH
61577: LD_INT 32
61579: PUSH
61580: EMPTY
61581: LIST
61582: LIST
61583: PUSH
61584: LD_INT 30
61586: PUSH
61587: LD_INT 33
61589: PUSH
61590: EMPTY
61591: LIST
61592: LIST
61593: PUSH
61594: EMPTY
61595: LIST
61596: LIST
61597: LIST
61598: PPUSH
61599: CALL_OW 72
61603: IFFALSE 61691
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
61605: LD_ADDR_VAR 0 8
61609: PUSH
61610: LD_VAR 0 18
61614: PPUSH
61615: LD_INT 2
61617: PUSH
61618: LD_INT 30
61620: PUSH
61621: LD_INT 32
61623: PUSH
61624: EMPTY
61625: LIST
61626: LIST
61627: PUSH
61628: LD_INT 30
61630: PUSH
61631: LD_INT 33
61633: PUSH
61634: EMPTY
61635: LIST
61636: LIST
61637: PUSH
61638: EMPTY
61639: LIST
61640: LIST
61641: LIST
61642: PPUSH
61643: CALL_OW 72
61647: PUSH
61648: FOR_IN
61649: IFFALSE 61689
// begin if not GetBWeapon ( i ) then
61651: LD_VAR 0 8
61655: PPUSH
61656: CALL_OW 269
61660: NOT
61661: IFFALSE 61687
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
61663: LD_VAR 0 8
61667: PPUSH
61668: LD_VAR 0 8
61672: PPUSH
61673: LD_VAR 0 2
61677: PPUSH
61678: CALL 62937 0 2
61682: PPUSH
61683: CALL_OW 431
// end ;
61687: GO 61648
61689: POP
61690: POP
// end ; for i = 1 to personel do
61691: LD_ADDR_VAR 0 8
61695: PUSH
61696: DOUBLE
61697: LD_INT 1
61699: DEC
61700: ST_TO_ADDR
61701: LD_VAR 0 6
61705: PUSH
61706: FOR_TO
61707: IFFALSE 62771
// begin if i > 4 then
61709: LD_VAR 0 8
61713: PUSH
61714: LD_INT 4
61716: GREATER
61717: IFFALSE 61721
// break ;
61719: GO 62771
// case i of 1 :
61721: LD_VAR 0 8
61725: PUSH
61726: LD_INT 1
61728: DOUBLE
61729: EQUAL
61730: IFTRUE 61734
61732: GO 61814
61734: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
61735: LD_ADDR_VAR 0 12
61739: PUSH
61740: LD_VAR 0 18
61744: PPUSH
61745: LD_INT 22
61747: PUSH
61748: LD_VAR 0 16
61752: PUSH
61753: EMPTY
61754: LIST
61755: LIST
61756: PUSH
61757: LD_INT 58
61759: PUSH
61760: EMPTY
61761: LIST
61762: PUSH
61763: LD_INT 2
61765: PUSH
61766: LD_INT 30
61768: PUSH
61769: LD_INT 32
61771: PUSH
61772: EMPTY
61773: LIST
61774: LIST
61775: PUSH
61776: LD_INT 30
61778: PUSH
61779: LD_INT 4
61781: PUSH
61782: EMPTY
61783: LIST
61784: LIST
61785: PUSH
61786: LD_INT 30
61788: PUSH
61789: LD_INT 5
61791: PUSH
61792: EMPTY
61793: LIST
61794: LIST
61795: PUSH
61796: EMPTY
61797: LIST
61798: LIST
61799: LIST
61800: LIST
61801: PUSH
61802: EMPTY
61803: LIST
61804: LIST
61805: LIST
61806: PPUSH
61807: CALL_OW 72
61811: ST_TO_ADDR
61812: GO 62036
61814: LD_INT 2
61816: DOUBLE
61817: EQUAL
61818: IFTRUE 61822
61820: GO 61884
61822: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
61823: LD_ADDR_VAR 0 12
61827: PUSH
61828: LD_VAR 0 18
61832: PPUSH
61833: LD_INT 22
61835: PUSH
61836: LD_VAR 0 16
61840: PUSH
61841: EMPTY
61842: LIST
61843: LIST
61844: PUSH
61845: LD_INT 2
61847: PUSH
61848: LD_INT 30
61850: PUSH
61851: LD_INT 0
61853: PUSH
61854: EMPTY
61855: LIST
61856: LIST
61857: PUSH
61858: LD_INT 30
61860: PUSH
61861: LD_INT 1
61863: PUSH
61864: EMPTY
61865: LIST
61866: LIST
61867: PUSH
61868: EMPTY
61869: LIST
61870: LIST
61871: LIST
61872: PUSH
61873: EMPTY
61874: LIST
61875: LIST
61876: PPUSH
61877: CALL_OW 72
61881: ST_TO_ADDR
61882: GO 62036
61884: LD_INT 3
61886: DOUBLE
61887: EQUAL
61888: IFTRUE 61892
61890: GO 61954
61892: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
61893: LD_ADDR_VAR 0 12
61897: PUSH
61898: LD_VAR 0 18
61902: PPUSH
61903: LD_INT 22
61905: PUSH
61906: LD_VAR 0 16
61910: PUSH
61911: EMPTY
61912: LIST
61913: LIST
61914: PUSH
61915: LD_INT 2
61917: PUSH
61918: LD_INT 30
61920: PUSH
61921: LD_INT 2
61923: PUSH
61924: EMPTY
61925: LIST
61926: LIST
61927: PUSH
61928: LD_INT 30
61930: PUSH
61931: LD_INT 3
61933: PUSH
61934: EMPTY
61935: LIST
61936: LIST
61937: PUSH
61938: EMPTY
61939: LIST
61940: LIST
61941: LIST
61942: PUSH
61943: EMPTY
61944: LIST
61945: LIST
61946: PPUSH
61947: CALL_OW 72
61951: ST_TO_ADDR
61952: GO 62036
61954: LD_INT 4
61956: DOUBLE
61957: EQUAL
61958: IFTRUE 61962
61960: GO 62035
61962: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
61963: LD_ADDR_VAR 0 12
61967: PUSH
61968: LD_VAR 0 18
61972: PPUSH
61973: LD_INT 22
61975: PUSH
61976: LD_VAR 0 16
61980: PUSH
61981: EMPTY
61982: LIST
61983: LIST
61984: PUSH
61985: LD_INT 2
61987: PUSH
61988: LD_INT 30
61990: PUSH
61991: LD_INT 6
61993: PUSH
61994: EMPTY
61995: LIST
61996: LIST
61997: PUSH
61998: LD_INT 30
62000: PUSH
62001: LD_INT 7
62003: PUSH
62004: EMPTY
62005: LIST
62006: LIST
62007: PUSH
62008: LD_INT 30
62010: PUSH
62011: LD_INT 8
62013: PUSH
62014: EMPTY
62015: LIST
62016: LIST
62017: PUSH
62018: EMPTY
62019: LIST
62020: LIST
62021: LIST
62022: LIST
62023: PUSH
62024: EMPTY
62025: LIST
62026: LIST
62027: PPUSH
62028: CALL_OW 72
62032: ST_TO_ADDR
62033: GO 62036
62035: POP
// if i = 1 then
62036: LD_VAR 0 8
62040: PUSH
62041: LD_INT 1
62043: EQUAL
62044: IFFALSE 62155
// begin tmp := [ ] ;
62046: LD_ADDR_VAR 0 19
62050: PUSH
62051: EMPTY
62052: ST_TO_ADDR
// for j in f do
62053: LD_ADDR_VAR 0 9
62057: PUSH
62058: LD_VAR 0 12
62062: PUSH
62063: FOR_IN
62064: IFFALSE 62137
// if GetBType ( j ) = b_bunker then
62066: LD_VAR 0 9
62070: PPUSH
62071: CALL_OW 266
62075: PUSH
62076: LD_INT 32
62078: EQUAL
62079: IFFALSE 62106
// tmp := Insert ( tmp , 1 , j ) else
62081: LD_ADDR_VAR 0 19
62085: PUSH
62086: LD_VAR 0 19
62090: PPUSH
62091: LD_INT 1
62093: PPUSH
62094: LD_VAR 0 9
62098: PPUSH
62099: CALL_OW 2
62103: ST_TO_ADDR
62104: GO 62135
// tmp := Insert ( tmp , tmp + 1 , j ) ;
62106: LD_ADDR_VAR 0 19
62110: PUSH
62111: LD_VAR 0 19
62115: PPUSH
62116: LD_VAR 0 19
62120: PUSH
62121: LD_INT 1
62123: PLUS
62124: PPUSH
62125: LD_VAR 0 9
62129: PPUSH
62130: CALL_OW 2
62134: ST_TO_ADDR
62135: GO 62063
62137: POP
62138: POP
// if tmp then
62139: LD_VAR 0 19
62143: IFFALSE 62155
// f := tmp ;
62145: LD_ADDR_VAR 0 12
62149: PUSH
62150: LD_VAR 0 19
62154: ST_TO_ADDR
// end ; x := personel [ i ] ;
62155: LD_ADDR_VAR 0 13
62159: PUSH
62160: LD_VAR 0 6
62164: PUSH
62165: LD_VAR 0 8
62169: ARRAY
62170: ST_TO_ADDR
// if x = - 1 then
62171: LD_VAR 0 13
62175: PUSH
62176: LD_INT 1
62178: NEG
62179: EQUAL
62180: IFFALSE 62389
// begin for j in f do
62182: LD_ADDR_VAR 0 9
62186: PUSH
62187: LD_VAR 0 12
62191: PUSH
62192: FOR_IN
62193: IFFALSE 62385
// repeat InitHc ;
62195: CALL_OW 19
// if GetBType ( j ) = b_barracks then
62199: LD_VAR 0 9
62203: PPUSH
62204: CALL_OW 266
62208: PUSH
62209: LD_INT 5
62211: EQUAL
62212: IFFALSE 62282
// begin if UnitsInside ( j ) < 3 then
62214: LD_VAR 0 9
62218: PPUSH
62219: CALL_OW 313
62223: PUSH
62224: LD_INT 3
62226: LESS
62227: IFFALSE 62263
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
62229: LD_INT 0
62231: PPUSH
62232: LD_INT 5
62234: PUSH
62235: LD_INT 8
62237: PUSH
62238: LD_INT 9
62240: PUSH
62241: EMPTY
62242: LIST
62243: LIST
62244: LIST
62245: PUSH
62246: LD_VAR 0 17
62250: ARRAY
62251: PPUSH
62252: LD_VAR 0 4
62256: PPUSH
62257: CALL_OW 380
62261: GO 62280
// PrepareHuman ( false , i , skill ) ;
62263: LD_INT 0
62265: PPUSH
62266: LD_VAR 0 8
62270: PPUSH
62271: LD_VAR 0 4
62275: PPUSH
62276: CALL_OW 380
// end else
62280: GO 62299
// PrepareHuman ( false , i , skill ) ;
62282: LD_INT 0
62284: PPUSH
62285: LD_VAR 0 8
62289: PPUSH
62290: LD_VAR 0 4
62294: PPUSH
62295: CALL_OW 380
// un := CreateHuman ;
62299: LD_ADDR_VAR 0 14
62303: PUSH
62304: CALL_OW 44
62308: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
62309: LD_ADDR_VAR 0 7
62313: PUSH
62314: LD_VAR 0 7
62318: PPUSH
62319: LD_INT 1
62321: PPUSH
62322: LD_VAR 0 14
62326: PPUSH
62327: CALL_OW 2
62331: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
62332: LD_VAR 0 14
62336: PPUSH
62337: LD_VAR 0 9
62341: PPUSH
62342: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
62346: LD_VAR 0 9
62350: PPUSH
62351: CALL_OW 313
62355: PUSH
62356: LD_INT 6
62358: EQUAL
62359: PUSH
62360: LD_VAR 0 9
62364: PPUSH
62365: CALL_OW 266
62369: PUSH
62370: LD_INT 32
62372: PUSH
62373: LD_INT 31
62375: PUSH
62376: EMPTY
62377: LIST
62378: LIST
62379: IN
62380: OR
62381: IFFALSE 62195
62383: GO 62192
62385: POP
62386: POP
// end else
62387: GO 62769
// for j = 1 to x do
62389: LD_ADDR_VAR 0 9
62393: PUSH
62394: DOUBLE
62395: LD_INT 1
62397: DEC
62398: ST_TO_ADDR
62399: LD_VAR 0 13
62403: PUSH
62404: FOR_TO
62405: IFFALSE 62767
// begin InitHc ;
62407: CALL_OW 19
// if not f then
62411: LD_VAR 0 12
62415: NOT
62416: IFFALSE 62505
// begin PrepareHuman ( false , i , skill ) ;
62418: LD_INT 0
62420: PPUSH
62421: LD_VAR 0 8
62425: PPUSH
62426: LD_VAR 0 4
62430: PPUSH
62431: CALL_OW 380
// un := CreateHuman ;
62435: LD_ADDR_VAR 0 14
62439: PUSH
62440: CALL_OW 44
62444: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
62445: LD_ADDR_VAR 0 7
62449: PUSH
62450: LD_VAR 0 7
62454: PPUSH
62455: LD_INT 1
62457: PPUSH
62458: LD_VAR 0 14
62462: PPUSH
62463: CALL_OW 2
62467: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
62468: LD_VAR 0 14
62472: PPUSH
62473: LD_VAR 0 1
62477: PPUSH
62478: CALL_OW 250
62482: PPUSH
62483: LD_VAR 0 1
62487: PPUSH
62488: CALL_OW 251
62492: PPUSH
62493: LD_INT 10
62495: PPUSH
62496: LD_INT 0
62498: PPUSH
62499: CALL_OW 50
// continue ;
62503: GO 62404
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
62505: LD_VAR 0 12
62509: PUSH
62510: LD_INT 1
62512: ARRAY
62513: PPUSH
62514: CALL_OW 313
62518: PUSH
62519: LD_VAR 0 12
62523: PUSH
62524: LD_INT 1
62526: ARRAY
62527: PPUSH
62528: CALL_OW 266
62532: PUSH
62533: LD_INT 32
62535: PUSH
62536: LD_INT 31
62538: PUSH
62539: EMPTY
62540: LIST
62541: LIST
62542: IN
62543: AND
62544: PUSH
62545: LD_VAR 0 12
62549: PUSH
62550: LD_INT 1
62552: ARRAY
62553: PPUSH
62554: CALL_OW 313
62558: PUSH
62559: LD_INT 6
62561: EQUAL
62562: OR
62563: IFFALSE 62583
// f := Delete ( f , 1 ) ;
62565: LD_ADDR_VAR 0 12
62569: PUSH
62570: LD_VAR 0 12
62574: PPUSH
62575: LD_INT 1
62577: PPUSH
62578: CALL_OW 3
62582: ST_TO_ADDR
// if not f then
62583: LD_VAR 0 12
62587: NOT
62588: IFFALSE 62606
// begin x := x + 2 ;
62590: LD_ADDR_VAR 0 13
62594: PUSH
62595: LD_VAR 0 13
62599: PUSH
62600: LD_INT 2
62602: PLUS
62603: ST_TO_ADDR
// continue ;
62604: GO 62404
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
62606: LD_VAR 0 12
62610: PUSH
62611: LD_INT 1
62613: ARRAY
62614: PPUSH
62615: CALL_OW 266
62619: PUSH
62620: LD_INT 5
62622: EQUAL
62623: IFFALSE 62697
// begin if UnitsInside ( f [ 1 ] ) < 3 then
62625: LD_VAR 0 12
62629: PUSH
62630: LD_INT 1
62632: ARRAY
62633: PPUSH
62634: CALL_OW 313
62638: PUSH
62639: LD_INT 3
62641: LESS
62642: IFFALSE 62678
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
62644: LD_INT 0
62646: PPUSH
62647: LD_INT 5
62649: PUSH
62650: LD_INT 8
62652: PUSH
62653: LD_INT 9
62655: PUSH
62656: EMPTY
62657: LIST
62658: LIST
62659: LIST
62660: PUSH
62661: LD_VAR 0 17
62665: ARRAY
62666: PPUSH
62667: LD_VAR 0 4
62671: PPUSH
62672: CALL_OW 380
62676: GO 62695
// PrepareHuman ( false , i , skill ) ;
62678: LD_INT 0
62680: PPUSH
62681: LD_VAR 0 8
62685: PPUSH
62686: LD_VAR 0 4
62690: PPUSH
62691: CALL_OW 380
// end else
62695: GO 62714
// PrepareHuman ( false , i , skill ) ;
62697: LD_INT 0
62699: PPUSH
62700: LD_VAR 0 8
62704: PPUSH
62705: LD_VAR 0 4
62709: PPUSH
62710: CALL_OW 380
// un := CreateHuman ;
62714: LD_ADDR_VAR 0 14
62718: PUSH
62719: CALL_OW 44
62723: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
62724: LD_ADDR_VAR 0 7
62728: PUSH
62729: LD_VAR 0 7
62733: PPUSH
62734: LD_INT 1
62736: PPUSH
62737: LD_VAR 0 14
62741: PPUSH
62742: CALL_OW 2
62746: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
62747: LD_VAR 0 14
62751: PPUSH
62752: LD_VAR 0 12
62756: PUSH
62757: LD_INT 1
62759: ARRAY
62760: PPUSH
62761: CALL_OW 52
// end ;
62765: GO 62404
62767: POP
62768: POP
// end ;
62769: GO 61706
62771: POP
62772: POP
// result := result ^ buildings ;
62773: LD_ADDR_VAR 0 7
62777: PUSH
62778: LD_VAR 0 7
62782: PUSH
62783: LD_VAR 0 18
62787: ADD
62788: ST_TO_ADDR
// end else
62789: GO 62932
// begin for i = 1 to personel do
62791: LD_ADDR_VAR 0 8
62795: PUSH
62796: DOUBLE
62797: LD_INT 1
62799: DEC
62800: ST_TO_ADDR
62801: LD_VAR 0 6
62805: PUSH
62806: FOR_TO
62807: IFFALSE 62930
// begin if i > 4 then
62809: LD_VAR 0 8
62813: PUSH
62814: LD_INT 4
62816: GREATER
62817: IFFALSE 62821
// break ;
62819: GO 62930
// x := personel [ i ] ;
62821: LD_ADDR_VAR 0 13
62825: PUSH
62826: LD_VAR 0 6
62830: PUSH
62831: LD_VAR 0 8
62835: ARRAY
62836: ST_TO_ADDR
// if x = - 1 then
62837: LD_VAR 0 13
62841: PUSH
62842: LD_INT 1
62844: NEG
62845: EQUAL
62846: IFFALSE 62850
// continue ;
62848: GO 62806
// PrepareHuman ( false , i , skill ) ;
62850: LD_INT 0
62852: PPUSH
62853: LD_VAR 0 8
62857: PPUSH
62858: LD_VAR 0 4
62862: PPUSH
62863: CALL_OW 380
// un := CreateHuman ;
62867: LD_ADDR_VAR 0 14
62871: PUSH
62872: CALL_OW 44
62876: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
62877: LD_VAR 0 14
62881: PPUSH
62882: LD_VAR 0 1
62886: PPUSH
62887: CALL_OW 250
62891: PPUSH
62892: LD_VAR 0 1
62896: PPUSH
62897: CALL_OW 251
62901: PPUSH
62902: LD_INT 10
62904: PPUSH
62905: LD_INT 0
62907: PPUSH
62908: CALL_OW 50
// result := result ^ un ;
62912: LD_ADDR_VAR 0 7
62916: PUSH
62917: LD_VAR 0 7
62921: PUSH
62922: LD_VAR 0 14
62926: ADD
62927: ST_TO_ADDR
// end ;
62928: GO 62806
62930: POP
62931: POP
// end ; end ;
62932: LD_VAR 0 7
62936: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
62937: LD_INT 0
62939: PPUSH
62940: PPUSH
62941: PPUSH
62942: PPUSH
62943: PPUSH
62944: PPUSH
62945: PPUSH
62946: PPUSH
62947: PPUSH
62948: PPUSH
62949: PPUSH
62950: PPUSH
62951: PPUSH
62952: PPUSH
62953: PPUSH
62954: PPUSH
// result := false ;
62955: LD_ADDR_VAR 0 3
62959: PUSH
62960: LD_INT 0
62962: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
62963: LD_VAR 0 1
62967: NOT
62968: PUSH
62969: LD_VAR 0 1
62973: PPUSH
62974: CALL_OW 266
62978: PUSH
62979: LD_INT 32
62981: PUSH
62982: LD_INT 33
62984: PUSH
62985: EMPTY
62986: LIST
62987: LIST
62988: IN
62989: NOT
62990: OR
62991: IFFALSE 62995
// exit ;
62993: GO 64131
// nat := GetNation ( tower ) ;
62995: LD_ADDR_VAR 0 12
62999: PUSH
63000: LD_VAR 0 1
63004: PPUSH
63005: CALL_OW 248
63009: ST_TO_ADDR
// side := GetSide ( tower ) ;
63010: LD_ADDR_VAR 0 16
63014: PUSH
63015: LD_VAR 0 1
63019: PPUSH
63020: CALL_OW 255
63024: ST_TO_ADDR
// x := GetX ( tower ) ;
63025: LD_ADDR_VAR 0 10
63029: PUSH
63030: LD_VAR 0 1
63034: PPUSH
63035: CALL_OW 250
63039: ST_TO_ADDR
// y := GetY ( tower ) ;
63040: LD_ADDR_VAR 0 11
63044: PUSH
63045: LD_VAR 0 1
63049: PPUSH
63050: CALL_OW 251
63054: ST_TO_ADDR
// if not x or not y then
63055: LD_VAR 0 10
63059: NOT
63060: PUSH
63061: LD_VAR 0 11
63065: NOT
63066: OR
63067: IFFALSE 63071
// exit ;
63069: GO 64131
// weapon := 0 ;
63071: LD_ADDR_VAR 0 18
63075: PUSH
63076: LD_INT 0
63078: ST_TO_ADDR
// fac_list := [ ] ;
63079: LD_ADDR_VAR 0 17
63083: PUSH
63084: EMPTY
63085: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
63086: LD_ADDR_VAR 0 6
63090: PUSH
63091: LD_VAR 0 1
63095: PPUSH
63096: CALL_OW 274
63100: PPUSH
63101: LD_VAR 0 2
63105: PPUSH
63106: CALL 60709 0 2
63110: PPUSH
63111: LD_INT 30
63113: PUSH
63114: LD_INT 3
63116: PUSH
63117: EMPTY
63118: LIST
63119: LIST
63120: PPUSH
63121: CALL_OW 72
63125: ST_TO_ADDR
// if not factories then
63126: LD_VAR 0 6
63130: NOT
63131: IFFALSE 63135
// exit ;
63133: GO 64131
// for i in factories do
63135: LD_ADDR_VAR 0 8
63139: PUSH
63140: LD_VAR 0 6
63144: PUSH
63145: FOR_IN
63146: IFFALSE 63171
// fac_list := fac_list union AvailableWeaponList ( i ) ;
63148: LD_ADDR_VAR 0 17
63152: PUSH
63153: LD_VAR 0 17
63157: PUSH
63158: LD_VAR 0 8
63162: PPUSH
63163: CALL_OW 478
63167: UNION
63168: ST_TO_ADDR
63169: GO 63145
63171: POP
63172: POP
// if not fac_list then
63173: LD_VAR 0 17
63177: NOT
63178: IFFALSE 63182
// exit ;
63180: GO 64131
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
63182: LD_ADDR_VAR 0 5
63186: PUSH
63187: LD_INT 4
63189: PUSH
63190: LD_INT 5
63192: PUSH
63193: LD_INT 9
63195: PUSH
63196: LD_INT 10
63198: PUSH
63199: LD_INT 6
63201: PUSH
63202: LD_INT 7
63204: PUSH
63205: LD_INT 11
63207: PUSH
63208: EMPTY
63209: LIST
63210: LIST
63211: LIST
63212: LIST
63213: LIST
63214: LIST
63215: LIST
63216: PUSH
63217: LD_INT 27
63219: PUSH
63220: LD_INT 28
63222: PUSH
63223: LD_INT 26
63225: PUSH
63226: LD_INT 30
63228: PUSH
63229: EMPTY
63230: LIST
63231: LIST
63232: LIST
63233: LIST
63234: PUSH
63235: LD_INT 43
63237: PUSH
63238: LD_INT 44
63240: PUSH
63241: LD_INT 46
63243: PUSH
63244: LD_INT 45
63246: PUSH
63247: LD_INT 47
63249: PUSH
63250: LD_INT 49
63252: PUSH
63253: EMPTY
63254: LIST
63255: LIST
63256: LIST
63257: LIST
63258: LIST
63259: LIST
63260: PUSH
63261: EMPTY
63262: LIST
63263: LIST
63264: LIST
63265: PUSH
63266: LD_VAR 0 12
63270: ARRAY
63271: ST_TO_ADDR
// for i in list do
63272: LD_ADDR_VAR 0 8
63276: PUSH
63277: LD_VAR 0 5
63281: PUSH
63282: FOR_IN
63283: IFFALSE 63316
// if not i in fac_list then
63285: LD_VAR 0 8
63289: PUSH
63290: LD_VAR 0 17
63294: IN
63295: NOT
63296: IFFALSE 63314
// list := list diff i ;
63298: LD_ADDR_VAR 0 5
63302: PUSH
63303: LD_VAR 0 5
63307: PUSH
63308: LD_VAR 0 8
63312: DIFF
63313: ST_TO_ADDR
63314: GO 63282
63316: POP
63317: POP
// if not list then
63318: LD_VAR 0 5
63322: NOT
63323: IFFALSE 63327
// exit ;
63325: GO 64131
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
63327: LD_VAR 0 12
63331: PUSH
63332: LD_INT 3
63334: EQUAL
63335: PUSH
63336: LD_INT 49
63338: PUSH
63339: LD_VAR 0 5
63343: IN
63344: AND
63345: PUSH
63346: LD_INT 31
63348: PPUSH
63349: LD_VAR 0 16
63353: PPUSH
63354: CALL_OW 321
63358: PUSH
63359: LD_INT 2
63361: EQUAL
63362: AND
63363: IFFALSE 63423
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
63365: LD_INT 22
63367: PUSH
63368: LD_VAR 0 16
63372: PUSH
63373: EMPTY
63374: LIST
63375: LIST
63376: PUSH
63377: LD_INT 35
63379: PUSH
63380: LD_INT 49
63382: PUSH
63383: EMPTY
63384: LIST
63385: LIST
63386: PUSH
63387: LD_INT 91
63389: PUSH
63390: LD_VAR 0 1
63394: PUSH
63395: LD_INT 10
63397: PUSH
63398: EMPTY
63399: LIST
63400: LIST
63401: LIST
63402: PUSH
63403: EMPTY
63404: LIST
63405: LIST
63406: LIST
63407: PPUSH
63408: CALL_OW 69
63412: NOT
63413: IFFALSE 63423
// weapon := ru_time_lapser ;
63415: LD_ADDR_VAR 0 18
63419: PUSH
63420: LD_INT 49
63422: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
63423: LD_VAR 0 12
63427: PUSH
63428: LD_INT 1
63430: PUSH
63431: LD_INT 2
63433: PUSH
63434: EMPTY
63435: LIST
63436: LIST
63437: IN
63438: PUSH
63439: LD_INT 11
63441: PUSH
63442: LD_VAR 0 5
63446: IN
63447: PUSH
63448: LD_INT 30
63450: PUSH
63451: LD_VAR 0 5
63455: IN
63456: OR
63457: AND
63458: PUSH
63459: LD_INT 6
63461: PPUSH
63462: LD_VAR 0 16
63466: PPUSH
63467: CALL_OW 321
63471: PUSH
63472: LD_INT 2
63474: EQUAL
63475: AND
63476: IFFALSE 63641
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
63478: LD_INT 22
63480: PUSH
63481: LD_VAR 0 16
63485: PUSH
63486: EMPTY
63487: LIST
63488: LIST
63489: PUSH
63490: LD_INT 2
63492: PUSH
63493: LD_INT 35
63495: PUSH
63496: LD_INT 11
63498: PUSH
63499: EMPTY
63500: LIST
63501: LIST
63502: PUSH
63503: LD_INT 35
63505: PUSH
63506: LD_INT 30
63508: PUSH
63509: EMPTY
63510: LIST
63511: LIST
63512: PUSH
63513: EMPTY
63514: LIST
63515: LIST
63516: LIST
63517: PUSH
63518: LD_INT 91
63520: PUSH
63521: LD_VAR 0 1
63525: PUSH
63526: LD_INT 18
63528: PUSH
63529: EMPTY
63530: LIST
63531: LIST
63532: LIST
63533: PUSH
63534: EMPTY
63535: LIST
63536: LIST
63537: LIST
63538: PPUSH
63539: CALL_OW 69
63543: NOT
63544: PUSH
63545: LD_INT 22
63547: PUSH
63548: LD_VAR 0 16
63552: PUSH
63553: EMPTY
63554: LIST
63555: LIST
63556: PUSH
63557: LD_INT 2
63559: PUSH
63560: LD_INT 30
63562: PUSH
63563: LD_INT 32
63565: PUSH
63566: EMPTY
63567: LIST
63568: LIST
63569: PUSH
63570: LD_INT 30
63572: PUSH
63573: LD_INT 33
63575: PUSH
63576: EMPTY
63577: LIST
63578: LIST
63579: PUSH
63580: EMPTY
63581: LIST
63582: LIST
63583: LIST
63584: PUSH
63585: LD_INT 91
63587: PUSH
63588: LD_VAR 0 1
63592: PUSH
63593: LD_INT 12
63595: PUSH
63596: EMPTY
63597: LIST
63598: LIST
63599: LIST
63600: PUSH
63601: EMPTY
63602: LIST
63603: LIST
63604: LIST
63605: PUSH
63606: EMPTY
63607: LIST
63608: PPUSH
63609: CALL_OW 69
63613: PUSH
63614: LD_INT 2
63616: GREATER
63617: AND
63618: IFFALSE 63641
// weapon := [ us_radar , ar_radar ] [ nat ] ;
63620: LD_ADDR_VAR 0 18
63624: PUSH
63625: LD_INT 11
63627: PUSH
63628: LD_INT 30
63630: PUSH
63631: EMPTY
63632: LIST
63633: LIST
63634: PUSH
63635: LD_VAR 0 12
63639: ARRAY
63640: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
63641: LD_VAR 0 18
63645: NOT
63646: PUSH
63647: LD_INT 40
63649: PPUSH
63650: LD_VAR 0 16
63654: PPUSH
63655: CALL_OW 321
63659: PUSH
63660: LD_INT 2
63662: EQUAL
63663: AND
63664: PUSH
63665: LD_INT 7
63667: PUSH
63668: LD_VAR 0 5
63672: IN
63673: PUSH
63674: LD_INT 28
63676: PUSH
63677: LD_VAR 0 5
63681: IN
63682: OR
63683: PUSH
63684: LD_INT 45
63686: PUSH
63687: LD_VAR 0 5
63691: IN
63692: OR
63693: AND
63694: IFFALSE 63948
// begin hex := GetHexInfo ( x , y ) ;
63696: LD_ADDR_VAR 0 4
63700: PUSH
63701: LD_VAR 0 10
63705: PPUSH
63706: LD_VAR 0 11
63710: PPUSH
63711: CALL_OW 546
63715: ST_TO_ADDR
// if hex [ 1 ] then
63716: LD_VAR 0 4
63720: PUSH
63721: LD_INT 1
63723: ARRAY
63724: IFFALSE 63728
// exit ;
63726: GO 64131
// height := hex [ 2 ] ;
63728: LD_ADDR_VAR 0 15
63732: PUSH
63733: LD_VAR 0 4
63737: PUSH
63738: LD_INT 2
63740: ARRAY
63741: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
63742: LD_ADDR_VAR 0 14
63746: PUSH
63747: LD_INT 0
63749: PUSH
63750: LD_INT 2
63752: PUSH
63753: LD_INT 3
63755: PUSH
63756: LD_INT 5
63758: PUSH
63759: EMPTY
63760: LIST
63761: LIST
63762: LIST
63763: LIST
63764: ST_TO_ADDR
// for i in tmp do
63765: LD_ADDR_VAR 0 8
63769: PUSH
63770: LD_VAR 0 14
63774: PUSH
63775: FOR_IN
63776: IFFALSE 63946
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
63778: LD_ADDR_VAR 0 9
63782: PUSH
63783: LD_VAR 0 10
63787: PPUSH
63788: LD_VAR 0 8
63792: PPUSH
63793: LD_INT 5
63795: PPUSH
63796: CALL_OW 272
63800: PUSH
63801: LD_VAR 0 11
63805: PPUSH
63806: LD_VAR 0 8
63810: PPUSH
63811: LD_INT 5
63813: PPUSH
63814: CALL_OW 273
63818: PUSH
63819: EMPTY
63820: LIST
63821: LIST
63822: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
63823: LD_VAR 0 9
63827: PUSH
63828: LD_INT 1
63830: ARRAY
63831: PPUSH
63832: LD_VAR 0 9
63836: PUSH
63837: LD_INT 2
63839: ARRAY
63840: PPUSH
63841: CALL_OW 488
63845: IFFALSE 63944
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
63847: LD_ADDR_VAR 0 4
63851: PUSH
63852: LD_VAR 0 9
63856: PUSH
63857: LD_INT 1
63859: ARRAY
63860: PPUSH
63861: LD_VAR 0 9
63865: PUSH
63866: LD_INT 2
63868: ARRAY
63869: PPUSH
63870: CALL_OW 546
63874: ST_TO_ADDR
// if hex [ 1 ] then
63875: LD_VAR 0 4
63879: PUSH
63880: LD_INT 1
63882: ARRAY
63883: IFFALSE 63887
// continue ;
63885: GO 63775
// h := hex [ 2 ] ;
63887: LD_ADDR_VAR 0 13
63891: PUSH
63892: LD_VAR 0 4
63896: PUSH
63897: LD_INT 2
63899: ARRAY
63900: ST_TO_ADDR
// if h + 7 < height then
63901: LD_VAR 0 13
63905: PUSH
63906: LD_INT 7
63908: PLUS
63909: PUSH
63910: LD_VAR 0 15
63914: LESS
63915: IFFALSE 63944
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
63917: LD_ADDR_VAR 0 18
63921: PUSH
63922: LD_INT 7
63924: PUSH
63925: LD_INT 28
63927: PUSH
63928: LD_INT 45
63930: PUSH
63931: EMPTY
63932: LIST
63933: LIST
63934: LIST
63935: PUSH
63936: LD_VAR 0 12
63940: ARRAY
63941: ST_TO_ADDR
// break ;
63942: GO 63946
// end ; end ; end ;
63944: GO 63775
63946: POP
63947: POP
// end ; if not weapon then
63948: LD_VAR 0 18
63952: NOT
63953: IFFALSE 64013
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
63955: LD_ADDR_VAR 0 5
63959: PUSH
63960: LD_VAR 0 5
63964: PUSH
63965: LD_INT 11
63967: PUSH
63968: LD_INT 30
63970: PUSH
63971: LD_INT 49
63973: PUSH
63974: EMPTY
63975: LIST
63976: LIST
63977: LIST
63978: DIFF
63979: ST_TO_ADDR
// if not list then
63980: LD_VAR 0 5
63984: NOT
63985: IFFALSE 63989
// exit ;
63987: GO 64131
// weapon := list [ rand ( 1 , list ) ] ;
63989: LD_ADDR_VAR 0 18
63993: PUSH
63994: LD_VAR 0 5
63998: PUSH
63999: LD_INT 1
64001: PPUSH
64002: LD_VAR 0 5
64006: PPUSH
64007: CALL_OW 12
64011: ARRAY
64012: ST_TO_ADDR
// end ; if weapon then
64013: LD_VAR 0 18
64017: IFFALSE 64131
// begin tmp := CostOfWeapon ( weapon ) ;
64019: LD_ADDR_VAR 0 14
64023: PUSH
64024: LD_VAR 0 18
64028: PPUSH
64029: CALL_OW 451
64033: ST_TO_ADDR
// j := GetBase ( tower ) ;
64034: LD_ADDR_VAR 0 9
64038: PUSH
64039: LD_VAR 0 1
64043: PPUSH
64044: CALL_OW 274
64048: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
64049: LD_VAR 0 9
64053: PPUSH
64054: LD_INT 1
64056: PPUSH
64057: CALL_OW 275
64061: PUSH
64062: LD_VAR 0 14
64066: PUSH
64067: LD_INT 1
64069: ARRAY
64070: GREATEREQUAL
64071: PUSH
64072: LD_VAR 0 9
64076: PPUSH
64077: LD_INT 2
64079: PPUSH
64080: CALL_OW 275
64084: PUSH
64085: LD_VAR 0 14
64089: PUSH
64090: LD_INT 2
64092: ARRAY
64093: GREATEREQUAL
64094: AND
64095: PUSH
64096: LD_VAR 0 9
64100: PPUSH
64101: LD_INT 3
64103: PPUSH
64104: CALL_OW 275
64108: PUSH
64109: LD_VAR 0 14
64113: PUSH
64114: LD_INT 3
64116: ARRAY
64117: GREATEREQUAL
64118: AND
64119: IFFALSE 64131
// result := weapon ;
64121: LD_ADDR_VAR 0 3
64125: PUSH
64126: LD_VAR 0 18
64130: ST_TO_ADDR
// end ; end ;
64131: LD_VAR 0 3
64135: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
64136: LD_INT 0
64138: PPUSH
64139: PPUSH
// result := true ;
64140: LD_ADDR_VAR 0 3
64144: PUSH
64145: LD_INT 1
64147: ST_TO_ADDR
// if array1 = array2 then
64148: LD_VAR 0 1
64152: PUSH
64153: LD_VAR 0 2
64157: EQUAL
64158: IFFALSE 64218
// begin for i = 1 to array1 do
64160: LD_ADDR_VAR 0 4
64164: PUSH
64165: DOUBLE
64166: LD_INT 1
64168: DEC
64169: ST_TO_ADDR
64170: LD_VAR 0 1
64174: PUSH
64175: FOR_TO
64176: IFFALSE 64214
// if array1 [ i ] <> array2 [ i ] then
64178: LD_VAR 0 1
64182: PUSH
64183: LD_VAR 0 4
64187: ARRAY
64188: PUSH
64189: LD_VAR 0 2
64193: PUSH
64194: LD_VAR 0 4
64198: ARRAY
64199: NONEQUAL
64200: IFFALSE 64212
// begin result := false ;
64202: LD_ADDR_VAR 0 3
64206: PUSH
64207: LD_INT 0
64209: ST_TO_ADDR
// break ;
64210: GO 64214
// end ;
64212: GO 64175
64214: POP
64215: POP
// end else
64216: GO 64226
// result := false ;
64218: LD_ADDR_VAR 0 3
64222: PUSH
64223: LD_INT 0
64225: ST_TO_ADDR
// end ;
64226: LD_VAR 0 3
64230: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
64231: LD_INT 0
64233: PPUSH
64234: PPUSH
64235: PPUSH
// pom := GetBase ( fac ) ;
64236: LD_ADDR_VAR 0 5
64240: PUSH
64241: LD_VAR 0 1
64245: PPUSH
64246: CALL_OW 274
64250: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
64251: LD_ADDR_VAR 0 4
64255: PUSH
64256: LD_VAR 0 2
64260: PUSH
64261: LD_INT 1
64263: ARRAY
64264: PPUSH
64265: LD_VAR 0 2
64269: PUSH
64270: LD_INT 2
64272: ARRAY
64273: PPUSH
64274: LD_VAR 0 2
64278: PUSH
64279: LD_INT 3
64281: ARRAY
64282: PPUSH
64283: LD_VAR 0 2
64287: PUSH
64288: LD_INT 4
64290: ARRAY
64291: PPUSH
64292: CALL_OW 449
64296: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
64297: LD_ADDR_VAR 0 3
64301: PUSH
64302: LD_VAR 0 5
64306: PPUSH
64307: LD_INT 1
64309: PPUSH
64310: CALL_OW 275
64314: PUSH
64315: LD_VAR 0 4
64319: PUSH
64320: LD_INT 1
64322: ARRAY
64323: GREATEREQUAL
64324: PUSH
64325: LD_VAR 0 5
64329: PPUSH
64330: LD_INT 2
64332: PPUSH
64333: CALL_OW 275
64337: PUSH
64338: LD_VAR 0 4
64342: PUSH
64343: LD_INT 2
64345: ARRAY
64346: GREATEREQUAL
64347: AND
64348: PUSH
64349: LD_VAR 0 5
64353: PPUSH
64354: LD_INT 3
64356: PPUSH
64357: CALL_OW 275
64361: PUSH
64362: LD_VAR 0 4
64366: PUSH
64367: LD_INT 3
64369: ARRAY
64370: GREATEREQUAL
64371: AND
64372: ST_TO_ADDR
// end ;
64373: LD_VAR 0 3
64377: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
64378: LD_INT 0
64380: PPUSH
64381: PPUSH
64382: PPUSH
64383: PPUSH
// pom := GetBase ( building ) ;
64384: LD_ADDR_VAR 0 3
64388: PUSH
64389: LD_VAR 0 1
64393: PPUSH
64394: CALL_OW 274
64398: ST_TO_ADDR
// if not pom then
64399: LD_VAR 0 3
64403: NOT
64404: IFFALSE 64408
// exit ;
64406: GO 64578
// btype := GetBType ( building ) ;
64408: LD_ADDR_VAR 0 5
64412: PUSH
64413: LD_VAR 0 1
64417: PPUSH
64418: CALL_OW 266
64422: ST_TO_ADDR
// if btype = b_armoury then
64423: LD_VAR 0 5
64427: PUSH
64428: LD_INT 4
64430: EQUAL
64431: IFFALSE 64441
// btype := b_barracks ;
64433: LD_ADDR_VAR 0 5
64437: PUSH
64438: LD_INT 5
64440: ST_TO_ADDR
// if btype = b_depot then
64441: LD_VAR 0 5
64445: PUSH
64446: LD_INT 0
64448: EQUAL
64449: IFFALSE 64459
// btype := b_warehouse ;
64451: LD_ADDR_VAR 0 5
64455: PUSH
64456: LD_INT 1
64458: ST_TO_ADDR
// if btype = b_workshop then
64459: LD_VAR 0 5
64463: PUSH
64464: LD_INT 2
64466: EQUAL
64467: IFFALSE 64477
// btype := b_factory ;
64469: LD_ADDR_VAR 0 5
64473: PUSH
64474: LD_INT 3
64476: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
64477: LD_ADDR_VAR 0 4
64481: PUSH
64482: LD_VAR 0 5
64486: PPUSH
64487: LD_VAR 0 1
64491: PPUSH
64492: CALL_OW 248
64496: PPUSH
64497: CALL_OW 450
64501: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
64502: LD_ADDR_VAR 0 2
64506: PUSH
64507: LD_VAR 0 3
64511: PPUSH
64512: LD_INT 1
64514: PPUSH
64515: CALL_OW 275
64519: PUSH
64520: LD_VAR 0 4
64524: PUSH
64525: LD_INT 1
64527: ARRAY
64528: GREATEREQUAL
64529: PUSH
64530: LD_VAR 0 3
64534: PPUSH
64535: LD_INT 2
64537: PPUSH
64538: CALL_OW 275
64542: PUSH
64543: LD_VAR 0 4
64547: PUSH
64548: LD_INT 2
64550: ARRAY
64551: GREATEREQUAL
64552: AND
64553: PUSH
64554: LD_VAR 0 3
64558: PPUSH
64559: LD_INT 3
64561: PPUSH
64562: CALL_OW 275
64566: PUSH
64567: LD_VAR 0 4
64571: PUSH
64572: LD_INT 3
64574: ARRAY
64575: GREATEREQUAL
64576: AND
64577: ST_TO_ADDR
// end ;
64578: LD_VAR 0 2
64582: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
64583: LD_INT 0
64585: PPUSH
64586: PPUSH
64587: PPUSH
// pom := GetBase ( building ) ;
64588: LD_ADDR_VAR 0 4
64592: PUSH
64593: LD_VAR 0 1
64597: PPUSH
64598: CALL_OW 274
64602: ST_TO_ADDR
// if not pom then
64603: LD_VAR 0 4
64607: NOT
64608: IFFALSE 64612
// exit ;
64610: GO 64713
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
64612: LD_ADDR_VAR 0 5
64616: PUSH
64617: LD_VAR 0 2
64621: PPUSH
64622: LD_VAR 0 1
64626: PPUSH
64627: CALL_OW 248
64631: PPUSH
64632: CALL_OW 450
64636: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
64637: LD_ADDR_VAR 0 3
64641: PUSH
64642: LD_VAR 0 4
64646: PPUSH
64647: LD_INT 1
64649: PPUSH
64650: CALL_OW 275
64654: PUSH
64655: LD_VAR 0 5
64659: PUSH
64660: LD_INT 1
64662: ARRAY
64663: GREATEREQUAL
64664: PUSH
64665: LD_VAR 0 4
64669: PPUSH
64670: LD_INT 2
64672: PPUSH
64673: CALL_OW 275
64677: PUSH
64678: LD_VAR 0 5
64682: PUSH
64683: LD_INT 2
64685: ARRAY
64686: GREATEREQUAL
64687: AND
64688: PUSH
64689: LD_VAR 0 4
64693: PPUSH
64694: LD_INT 3
64696: PPUSH
64697: CALL_OW 275
64701: PUSH
64702: LD_VAR 0 5
64706: PUSH
64707: LD_INT 3
64709: ARRAY
64710: GREATEREQUAL
64711: AND
64712: ST_TO_ADDR
// end ;
64713: LD_VAR 0 3
64717: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
64718: LD_INT 0
64720: PPUSH
64721: PPUSH
64722: PPUSH
64723: PPUSH
64724: PPUSH
64725: PPUSH
64726: PPUSH
64727: PPUSH
64728: PPUSH
64729: PPUSH
// result := false ;
64730: LD_ADDR_VAR 0 6
64734: PUSH
64735: LD_INT 0
64737: ST_TO_ADDR
// if not base or not btype or not x or not y then
64738: LD_VAR 0 1
64742: NOT
64743: PUSH
64744: LD_VAR 0 2
64748: NOT
64749: OR
64750: PUSH
64751: LD_VAR 0 3
64755: NOT
64756: OR
64757: PUSH
64758: LD_VAR 0 4
64762: NOT
64763: OR
64764: IFFALSE 64768
// exit ;
64766: GO 65377
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
64768: LD_ADDR_VAR 0 12
64772: PUSH
64773: LD_VAR 0 2
64777: PPUSH
64778: LD_VAR 0 3
64782: PPUSH
64783: LD_VAR 0 4
64787: PPUSH
64788: LD_VAR 0 5
64792: PPUSH
64793: LD_VAR 0 1
64797: PUSH
64798: LD_INT 1
64800: ARRAY
64801: PPUSH
64802: CALL_OW 248
64806: PPUSH
64807: LD_INT 0
64809: PPUSH
64810: CALL 66214 0 6
64814: ST_TO_ADDR
// if not hexes then
64815: LD_VAR 0 12
64819: NOT
64820: IFFALSE 64824
// exit ;
64822: GO 65377
// for i = 1 to hexes do
64824: LD_ADDR_VAR 0 7
64828: PUSH
64829: DOUBLE
64830: LD_INT 1
64832: DEC
64833: ST_TO_ADDR
64834: LD_VAR 0 12
64838: PUSH
64839: FOR_TO
64840: IFFALSE 65375
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
64842: LD_ADDR_VAR 0 11
64846: PUSH
64847: LD_VAR 0 12
64851: PUSH
64852: LD_VAR 0 7
64856: ARRAY
64857: PUSH
64858: LD_INT 1
64860: ARRAY
64861: PPUSH
64862: LD_VAR 0 12
64866: PUSH
64867: LD_VAR 0 7
64871: ARRAY
64872: PUSH
64873: LD_INT 2
64875: ARRAY
64876: PPUSH
64877: CALL_OW 428
64881: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
64882: LD_VAR 0 12
64886: PUSH
64887: LD_VAR 0 7
64891: ARRAY
64892: PUSH
64893: LD_INT 1
64895: ARRAY
64896: PPUSH
64897: LD_VAR 0 12
64901: PUSH
64902: LD_VAR 0 7
64906: ARRAY
64907: PUSH
64908: LD_INT 2
64910: ARRAY
64911: PPUSH
64912: CALL_OW 351
64916: PUSH
64917: LD_VAR 0 12
64921: PUSH
64922: LD_VAR 0 7
64926: ARRAY
64927: PUSH
64928: LD_INT 1
64930: ARRAY
64931: PPUSH
64932: LD_VAR 0 12
64936: PUSH
64937: LD_VAR 0 7
64941: ARRAY
64942: PUSH
64943: LD_INT 2
64945: ARRAY
64946: PPUSH
64947: CALL_OW 488
64951: NOT
64952: OR
64953: PUSH
64954: LD_VAR 0 11
64958: PPUSH
64959: CALL_OW 247
64963: PUSH
64964: LD_INT 3
64966: EQUAL
64967: OR
64968: IFFALSE 64974
// exit ;
64970: POP
64971: POP
64972: GO 65377
// if not tmp or not tmp in base then
64974: LD_VAR 0 11
64978: NOT
64979: PUSH
64980: LD_VAR 0 11
64984: PUSH
64985: LD_VAR 0 1
64989: IN
64990: NOT
64991: OR
64992: IFFALSE 64996
// continue ;
64994: GO 64839
// result := true ;
64996: LD_ADDR_VAR 0 6
65000: PUSH
65001: LD_INT 1
65003: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
65004: LD_ADDR_VAR 0 15
65008: PUSH
65009: LD_VAR 0 1
65013: PPUSH
65014: LD_INT 22
65016: PUSH
65017: LD_VAR 0 11
65021: PPUSH
65022: CALL_OW 255
65026: PUSH
65027: EMPTY
65028: LIST
65029: LIST
65030: PUSH
65031: LD_INT 2
65033: PUSH
65034: LD_INT 30
65036: PUSH
65037: LD_INT 0
65039: PUSH
65040: EMPTY
65041: LIST
65042: LIST
65043: PUSH
65044: LD_INT 30
65046: PUSH
65047: LD_INT 1
65049: PUSH
65050: EMPTY
65051: LIST
65052: LIST
65053: PUSH
65054: EMPTY
65055: LIST
65056: LIST
65057: LIST
65058: PUSH
65059: EMPTY
65060: LIST
65061: LIST
65062: PPUSH
65063: CALL_OW 72
65067: ST_TO_ADDR
// if dep then
65068: LD_VAR 0 15
65072: IFFALSE 65208
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
65074: LD_ADDR_VAR 0 14
65078: PUSH
65079: LD_VAR 0 15
65083: PUSH
65084: LD_INT 1
65086: ARRAY
65087: PPUSH
65088: CALL_OW 250
65092: PPUSH
65093: LD_VAR 0 15
65097: PUSH
65098: LD_INT 1
65100: ARRAY
65101: PPUSH
65102: CALL_OW 254
65106: PPUSH
65107: LD_INT 5
65109: PPUSH
65110: CALL_OW 272
65114: PUSH
65115: LD_VAR 0 15
65119: PUSH
65120: LD_INT 1
65122: ARRAY
65123: PPUSH
65124: CALL_OW 251
65128: PPUSH
65129: LD_VAR 0 15
65133: PUSH
65134: LD_INT 1
65136: ARRAY
65137: PPUSH
65138: CALL_OW 254
65142: PPUSH
65143: LD_INT 5
65145: PPUSH
65146: CALL_OW 273
65150: PUSH
65151: EMPTY
65152: LIST
65153: LIST
65154: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
65155: LD_VAR 0 14
65159: PUSH
65160: LD_INT 1
65162: ARRAY
65163: PPUSH
65164: LD_VAR 0 14
65168: PUSH
65169: LD_INT 2
65171: ARRAY
65172: PPUSH
65173: CALL_OW 488
65177: IFFALSE 65208
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
65179: LD_VAR 0 11
65183: PPUSH
65184: LD_VAR 0 14
65188: PUSH
65189: LD_INT 1
65191: ARRAY
65192: PPUSH
65193: LD_VAR 0 14
65197: PUSH
65198: LD_INT 2
65200: ARRAY
65201: PPUSH
65202: CALL_OW 111
// continue ;
65206: GO 64839
// end ; end ; r := GetDir ( tmp ) ;
65208: LD_ADDR_VAR 0 13
65212: PUSH
65213: LD_VAR 0 11
65217: PPUSH
65218: CALL_OW 254
65222: ST_TO_ADDR
// if r = 5 then
65223: LD_VAR 0 13
65227: PUSH
65228: LD_INT 5
65230: EQUAL
65231: IFFALSE 65241
// r := 0 ;
65233: LD_ADDR_VAR 0 13
65237: PUSH
65238: LD_INT 0
65240: ST_TO_ADDR
// for j = r to 5 do
65241: LD_ADDR_VAR 0 8
65245: PUSH
65246: DOUBLE
65247: LD_VAR 0 13
65251: DEC
65252: ST_TO_ADDR
65253: LD_INT 5
65255: PUSH
65256: FOR_TO
65257: IFFALSE 65371
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
65259: LD_ADDR_VAR 0 9
65263: PUSH
65264: LD_VAR 0 11
65268: PPUSH
65269: CALL_OW 250
65273: PPUSH
65274: LD_VAR 0 8
65278: PPUSH
65279: LD_INT 2
65281: PPUSH
65282: CALL_OW 272
65286: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
65287: LD_ADDR_VAR 0 10
65291: PUSH
65292: LD_VAR 0 11
65296: PPUSH
65297: CALL_OW 251
65301: PPUSH
65302: LD_VAR 0 8
65306: PPUSH
65307: LD_INT 2
65309: PPUSH
65310: CALL_OW 273
65314: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
65315: LD_VAR 0 9
65319: PPUSH
65320: LD_VAR 0 10
65324: PPUSH
65325: CALL_OW 488
65329: PUSH
65330: LD_VAR 0 9
65334: PPUSH
65335: LD_VAR 0 10
65339: PPUSH
65340: CALL_OW 428
65344: NOT
65345: AND
65346: IFFALSE 65369
// begin ComMoveXY ( tmp , _x , _y ) ;
65348: LD_VAR 0 11
65352: PPUSH
65353: LD_VAR 0 9
65357: PPUSH
65358: LD_VAR 0 10
65362: PPUSH
65363: CALL_OW 111
// break ;
65367: GO 65371
// end ; end ;
65369: GO 65256
65371: POP
65372: POP
// end ;
65373: GO 64839
65375: POP
65376: POP
// end ;
65377: LD_VAR 0 6
65381: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
65382: LD_INT 0
65384: PPUSH
65385: PPUSH
65386: PPUSH
65387: PPUSH
65388: PPUSH
65389: PPUSH
65390: PPUSH
65391: PPUSH
65392: PPUSH
65393: PPUSH
// result := false ;
65394: LD_ADDR_VAR 0 6
65398: PUSH
65399: LD_INT 0
65401: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
65402: LD_VAR 0 1
65406: NOT
65407: PUSH
65408: LD_VAR 0 1
65412: PPUSH
65413: CALL_OW 266
65417: PUSH
65418: LD_INT 0
65420: PUSH
65421: LD_INT 1
65423: PUSH
65424: EMPTY
65425: LIST
65426: LIST
65427: IN
65428: NOT
65429: OR
65430: PUSH
65431: LD_VAR 0 2
65435: NOT
65436: OR
65437: PUSH
65438: LD_VAR 0 5
65442: PUSH
65443: LD_INT 0
65445: PUSH
65446: LD_INT 1
65448: PUSH
65449: LD_INT 2
65451: PUSH
65452: LD_INT 3
65454: PUSH
65455: LD_INT 4
65457: PUSH
65458: LD_INT 5
65460: PUSH
65461: EMPTY
65462: LIST
65463: LIST
65464: LIST
65465: LIST
65466: LIST
65467: LIST
65468: IN
65469: NOT
65470: OR
65471: PUSH
65472: LD_VAR 0 3
65476: PPUSH
65477: LD_VAR 0 4
65481: PPUSH
65482: CALL_OW 488
65486: NOT
65487: OR
65488: IFFALSE 65492
// exit ;
65490: GO 66209
// pom := GetBase ( depot ) ;
65492: LD_ADDR_VAR 0 10
65496: PUSH
65497: LD_VAR 0 1
65501: PPUSH
65502: CALL_OW 274
65506: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
65507: LD_ADDR_VAR 0 11
65511: PUSH
65512: LD_VAR 0 2
65516: PPUSH
65517: LD_VAR 0 1
65521: PPUSH
65522: CALL_OW 248
65526: PPUSH
65527: CALL_OW 450
65531: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
65532: LD_VAR 0 10
65536: PPUSH
65537: LD_INT 1
65539: PPUSH
65540: CALL_OW 275
65544: PUSH
65545: LD_VAR 0 11
65549: PUSH
65550: LD_INT 1
65552: ARRAY
65553: GREATEREQUAL
65554: PUSH
65555: LD_VAR 0 10
65559: PPUSH
65560: LD_INT 2
65562: PPUSH
65563: CALL_OW 275
65567: PUSH
65568: LD_VAR 0 11
65572: PUSH
65573: LD_INT 2
65575: ARRAY
65576: GREATEREQUAL
65577: AND
65578: PUSH
65579: LD_VAR 0 10
65583: PPUSH
65584: LD_INT 3
65586: PPUSH
65587: CALL_OW 275
65591: PUSH
65592: LD_VAR 0 11
65596: PUSH
65597: LD_INT 3
65599: ARRAY
65600: GREATEREQUAL
65601: AND
65602: NOT
65603: IFFALSE 65607
// exit ;
65605: GO 66209
// if GetBType ( depot ) = b_depot then
65607: LD_VAR 0 1
65611: PPUSH
65612: CALL_OW 266
65616: PUSH
65617: LD_INT 0
65619: EQUAL
65620: IFFALSE 65632
// dist := 28 else
65622: LD_ADDR_VAR 0 14
65626: PUSH
65627: LD_INT 28
65629: ST_TO_ADDR
65630: GO 65640
// dist := 36 ;
65632: LD_ADDR_VAR 0 14
65636: PUSH
65637: LD_INT 36
65639: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
65640: LD_VAR 0 1
65644: PPUSH
65645: LD_VAR 0 3
65649: PPUSH
65650: LD_VAR 0 4
65654: PPUSH
65655: CALL_OW 297
65659: PUSH
65660: LD_VAR 0 14
65664: GREATER
65665: IFFALSE 65669
// exit ;
65667: GO 66209
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
65669: LD_ADDR_VAR 0 12
65673: PUSH
65674: LD_VAR 0 2
65678: PPUSH
65679: LD_VAR 0 3
65683: PPUSH
65684: LD_VAR 0 4
65688: PPUSH
65689: LD_VAR 0 5
65693: PPUSH
65694: LD_VAR 0 1
65698: PPUSH
65699: CALL_OW 248
65703: PPUSH
65704: LD_INT 0
65706: PPUSH
65707: CALL 66214 0 6
65711: ST_TO_ADDR
// if not hexes then
65712: LD_VAR 0 12
65716: NOT
65717: IFFALSE 65721
// exit ;
65719: GO 66209
// hex := GetHexInfo ( x , y ) ;
65721: LD_ADDR_VAR 0 15
65725: PUSH
65726: LD_VAR 0 3
65730: PPUSH
65731: LD_VAR 0 4
65735: PPUSH
65736: CALL_OW 546
65740: ST_TO_ADDR
// if hex [ 1 ] then
65741: LD_VAR 0 15
65745: PUSH
65746: LD_INT 1
65748: ARRAY
65749: IFFALSE 65753
// exit ;
65751: GO 66209
// height := hex [ 2 ] ;
65753: LD_ADDR_VAR 0 13
65757: PUSH
65758: LD_VAR 0 15
65762: PUSH
65763: LD_INT 2
65765: ARRAY
65766: ST_TO_ADDR
// for i = 1 to hexes do
65767: LD_ADDR_VAR 0 7
65771: PUSH
65772: DOUBLE
65773: LD_INT 1
65775: DEC
65776: ST_TO_ADDR
65777: LD_VAR 0 12
65781: PUSH
65782: FOR_TO
65783: IFFALSE 66113
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
65785: LD_VAR 0 12
65789: PUSH
65790: LD_VAR 0 7
65794: ARRAY
65795: PUSH
65796: LD_INT 1
65798: ARRAY
65799: PPUSH
65800: LD_VAR 0 12
65804: PUSH
65805: LD_VAR 0 7
65809: ARRAY
65810: PUSH
65811: LD_INT 2
65813: ARRAY
65814: PPUSH
65815: CALL_OW 488
65819: NOT
65820: PUSH
65821: LD_VAR 0 12
65825: PUSH
65826: LD_VAR 0 7
65830: ARRAY
65831: PUSH
65832: LD_INT 1
65834: ARRAY
65835: PPUSH
65836: LD_VAR 0 12
65840: PUSH
65841: LD_VAR 0 7
65845: ARRAY
65846: PUSH
65847: LD_INT 2
65849: ARRAY
65850: PPUSH
65851: CALL_OW 428
65855: PUSH
65856: LD_INT 0
65858: GREATER
65859: OR
65860: PUSH
65861: LD_VAR 0 12
65865: PUSH
65866: LD_VAR 0 7
65870: ARRAY
65871: PUSH
65872: LD_INT 1
65874: ARRAY
65875: PPUSH
65876: LD_VAR 0 12
65880: PUSH
65881: LD_VAR 0 7
65885: ARRAY
65886: PUSH
65887: LD_INT 2
65889: ARRAY
65890: PPUSH
65891: CALL_OW 351
65895: OR
65896: IFFALSE 65902
// exit ;
65898: POP
65899: POP
65900: GO 66209
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
65902: LD_ADDR_VAR 0 8
65906: PUSH
65907: LD_VAR 0 12
65911: PUSH
65912: LD_VAR 0 7
65916: ARRAY
65917: PUSH
65918: LD_INT 1
65920: ARRAY
65921: PPUSH
65922: LD_VAR 0 12
65926: PUSH
65927: LD_VAR 0 7
65931: ARRAY
65932: PUSH
65933: LD_INT 2
65935: ARRAY
65936: PPUSH
65937: CALL_OW 546
65941: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
65942: LD_VAR 0 8
65946: PUSH
65947: LD_INT 1
65949: ARRAY
65950: PUSH
65951: LD_VAR 0 8
65955: PUSH
65956: LD_INT 2
65958: ARRAY
65959: PUSH
65960: LD_VAR 0 13
65964: PUSH
65965: LD_INT 2
65967: PLUS
65968: GREATER
65969: OR
65970: PUSH
65971: LD_VAR 0 8
65975: PUSH
65976: LD_INT 2
65978: ARRAY
65979: PUSH
65980: LD_VAR 0 13
65984: PUSH
65985: LD_INT 2
65987: MINUS
65988: LESS
65989: OR
65990: PUSH
65991: LD_VAR 0 8
65995: PUSH
65996: LD_INT 3
65998: ARRAY
65999: PUSH
66000: LD_INT 0
66002: PUSH
66003: LD_INT 8
66005: PUSH
66006: LD_INT 9
66008: PUSH
66009: LD_INT 10
66011: PUSH
66012: LD_INT 11
66014: PUSH
66015: LD_INT 12
66017: PUSH
66018: LD_INT 13
66020: PUSH
66021: LD_INT 16
66023: PUSH
66024: LD_INT 17
66026: PUSH
66027: LD_INT 18
66029: PUSH
66030: LD_INT 19
66032: PUSH
66033: LD_INT 20
66035: PUSH
66036: LD_INT 21
66038: PUSH
66039: EMPTY
66040: LIST
66041: LIST
66042: LIST
66043: LIST
66044: LIST
66045: LIST
66046: LIST
66047: LIST
66048: LIST
66049: LIST
66050: LIST
66051: LIST
66052: LIST
66053: IN
66054: NOT
66055: OR
66056: PUSH
66057: LD_VAR 0 8
66061: PUSH
66062: LD_INT 5
66064: ARRAY
66065: NOT
66066: OR
66067: PUSH
66068: LD_VAR 0 8
66072: PUSH
66073: LD_INT 6
66075: ARRAY
66076: PUSH
66077: LD_INT 1
66079: PUSH
66080: LD_INT 2
66082: PUSH
66083: LD_INT 7
66085: PUSH
66086: LD_INT 9
66088: PUSH
66089: LD_INT 10
66091: PUSH
66092: LD_INT 11
66094: PUSH
66095: EMPTY
66096: LIST
66097: LIST
66098: LIST
66099: LIST
66100: LIST
66101: LIST
66102: IN
66103: NOT
66104: OR
66105: IFFALSE 66111
// exit ;
66107: POP
66108: POP
66109: GO 66209
// end ;
66111: GO 65782
66113: POP
66114: POP
// side := GetSide ( depot ) ;
66115: LD_ADDR_VAR 0 9
66119: PUSH
66120: LD_VAR 0 1
66124: PPUSH
66125: CALL_OW 255
66129: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
66130: LD_VAR 0 9
66134: PPUSH
66135: LD_VAR 0 3
66139: PPUSH
66140: LD_VAR 0 4
66144: PPUSH
66145: LD_INT 20
66147: PPUSH
66148: CALL 58863 0 4
66152: PUSH
66153: LD_INT 4
66155: ARRAY
66156: IFFALSE 66160
// exit ;
66158: GO 66209
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
66160: LD_VAR 0 2
66164: PUSH
66165: LD_INT 29
66167: PUSH
66168: LD_INT 30
66170: PUSH
66171: EMPTY
66172: LIST
66173: LIST
66174: IN
66175: PUSH
66176: LD_VAR 0 3
66180: PPUSH
66181: LD_VAR 0 4
66185: PPUSH
66186: LD_VAR 0 9
66190: PPUSH
66191: CALL_OW 440
66195: NOT
66196: AND
66197: IFFALSE 66201
// exit ;
66199: GO 66209
// result := true ;
66201: LD_ADDR_VAR 0 6
66205: PUSH
66206: LD_INT 1
66208: ST_TO_ADDR
// end ;
66209: LD_VAR 0 6
66213: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
66214: LD_INT 0
66216: PPUSH
66217: PPUSH
66218: PPUSH
66219: PPUSH
66220: PPUSH
66221: PPUSH
66222: PPUSH
66223: PPUSH
66224: PPUSH
66225: PPUSH
66226: PPUSH
66227: PPUSH
66228: PPUSH
66229: PPUSH
66230: PPUSH
66231: PPUSH
66232: PPUSH
66233: PPUSH
66234: PPUSH
66235: PPUSH
66236: PPUSH
66237: PPUSH
66238: PPUSH
66239: PPUSH
66240: PPUSH
66241: PPUSH
66242: PPUSH
66243: PPUSH
66244: PPUSH
66245: PPUSH
66246: PPUSH
66247: PPUSH
66248: PPUSH
66249: PPUSH
66250: PPUSH
66251: PPUSH
66252: PPUSH
66253: PPUSH
66254: PPUSH
66255: PPUSH
66256: PPUSH
66257: PPUSH
66258: PPUSH
66259: PPUSH
66260: PPUSH
66261: PPUSH
66262: PPUSH
66263: PPUSH
66264: PPUSH
66265: PPUSH
66266: PPUSH
66267: PPUSH
66268: PPUSH
66269: PPUSH
66270: PPUSH
66271: PPUSH
66272: PPUSH
66273: PPUSH
// result = [ ] ;
66274: LD_ADDR_VAR 0 7
66278: PUSH
66279: EMPTY
66280: ST_TO_ADDR
// temp_list = [ ] ;
66281: LD_ADDR_VAR 0 9
66285: PUSH
66286: EMPTY
66287: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
66288: LD_VAR 0 4
66292: PUSH
66293: LD_INT 0
66295: PUSH
66296: LD_INT 1
66298: PUSH
66299: LD_INT 2
66301: PUSH
66302: LD_INT 3
66304: PUSH
66305: LD_INT 4
66307: PUSH
66308: LD_INT 5
66310: PUSH
66311: EMPTY
66312: LIST
66313: LIST
66314: LIST
66315: LIST
66316: LIST
66317: LIST
66318: IN
66319: NOT
66320: PUSH
66321: LD_VAR 0 1
66325: PUSH
66326: LD_INT 0
66328: PUSH
66329: LD_INT 1
66331: PUSH
66332: EMPTY
66333: LIST
66334: LIST
66335: IN
66336: PUSH
66337: LD_VAR 0 5
66341: PUSH
66342: LD_INT 1
66344: PUSH
66345: LD_INT 2
66347: PUSH
66348: LD_INT 3
66350: PUSH
66351: EMPTY
66352: LIST
66353: LIST
66354: LIST
66355: IN
66356: NOT
66357: AND
66358: OR
66359: IFFALSE 66363
// exit ;
66361: GO 84754
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
66363: LD_VAR 0 1
66367: PUSH
66368: LD_INT 6
66370: PUSH
66371: LD_INT 7
66373: PUSH
66374: LD_INT 8
66376: PUSH
66377: LD_INT 13
66379: PUSH
66380: LD_INT 12
66382: PUSH
66383: LD_INT 15
66385: PUSH
66386: LD_INT 11
66388: PUSH
66389: LD_INT 14
66391: PUSH
66392: LD_INT 10
66394: PUSH
66395: EMPTY
66396: LIST
66397: LIST
66398: LIST
66399: LIST
66400: LIST
66401: LIST
66402: LIST
66403: LIST
66404: LIST
66405: IN
66406: IFFALSE 66416
// btype = b_lab ;
66408: LD_ADDR_VAR 0 1
66412: PUSH
66413: LD_INT 6
66415: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
66416: LD_VAR 0 6
66420: PUSH
66421: LD_INT 0
66423: PUSH
66424: LD_INT 1
66426: PUSH
66427: LD_INT 2
66429: PUSH
66430: EMPTY
66431: LIST
66432: LIST
66433: LIST
66434: IN
66435: NOT
66436: PUSH
66437: LD_VAR 0 1
66441: PUSH
66442: LD_INT 0
66444: PUSH
66445: LD_INT 1
66447: PUSH
66448: LD_INT 2
66450: PUSH
66451: LD_INT 3
66453: PUSH
66454: LD_INT 6
66456: PUSH
66457: LD_INT 36
66459: PUSH
66460: LD_INT 4
66462: PUSH
66463: LD_INT 5
66465: PUSH
66466: LD_INT 31
66468: PUSH
66469: LD_INT 32
66471: PUSH
66472: LD_INT 33
66474: PUSH
66475: EMPTY
66476: LIST
66477: LIST
66478: LIST
66479: LIST
66480: LIST
66481: LIST
66482: LIST
66483: LIST
66484: LIST
66485: LIST
66486: LIST
66487: IN
66488: NOT
66489: PUSH
66490: LD_VAR 0 6
66494: PUSH
66495: LD_INT 1
66497: EQUAL
66498: AND
66499: OR
66500: PUSH
66501: LD_VAR 0 1
66505: PUSH
66506: LD_INT 2
66508: PUSH
66509: LD_INT 3
66511: PUSH
66512: EMPTY
66513: LIST
66514: LIST
66515: IN
66516: NOT
66517: PUSH
66518: LD_VAR 0 6
66522: PUSH
66523: LD_INT 2
66525: EQUAL
66526: AND
66527: OR
66528: IFFALSE 66538
// mode = 0 ;
66530: LD_ADDR_VAR 0 6
66534: PUSH
66535: LD_INT 0
66537: ST_TO_ADDR
// case mode of 0 :
66538: LD_VAR 0 6
66542: PUSH
66543: LD_INT 0
66545: DOUBLE
66546: EQUAL
66547: IFTRUE 66551
66549: GO 78004
66551: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
66552: LD_ADDR_VAR 0 11
66556: PUSH
66557: LD_INT 0
66559: PUSH
66560: LD_INT 0
66562: PUSH
66563: EMPTY
66564: LIST
66565: LIST
66566: PUSH
66567: LD_INT 0
66569: PUSH
66570: LD_INT 1
66572: NEG
66573: PUSH
66574: EMPTY
66575: LIST
66576: LIST
66577: PUSH
66578: LD_INT 1
66580: PUSH
66581: LD_INT 0
66583: PUSH
66584: EMPTY
66585: LIST
66586: LIST
66587: PUSH
66588: LD_INT 1
66590: PUSH
66591: LD_INT 1
66593: PUSH
66594: EMPTY
66595: LIST
66596: LIST
66597: PUSH
66598: LD_INT 0
66600: PUSH
66601: LD_INT 1
66603: PUSH
66604: EMPTY
66605: LIST
66606: LIST
66607: PUSH
66608: LD_INT 1
66610: NEG
66611: PUSH
66612: LD_INT 0
66614: PUSH
66615: EMPTY
66616: LIST
66617: LIST
66618: PUSH
66619: LD_INT 1
66621: NEG
66622: PUSH
66623: LD_INT 1
66625: NEG
66626: PUSH
66627: EMPTY
66628: LIST
66629: LIST
66630: PUSH
66631: LD_INT 1
66633: NEG
66634: PUSH
66635: LD_INT 2
66637: NEG
66638: PUSH
66639: EMPTY
66640: LIST
66641: LIST
66642: PUSH
66643: LD_INT 0
66645: PUSH
66646: LD_INT 2
66648: NEG
66649: PUSH
66650: EMPTY
66651: LIST
66652: LIST
66653: PUSH
66654: LD_INT 1
66656: PUSH
66657: LD_INT 1
66659: NEG
66660: PUSH
66661: EMPTY
66662: LIST
66663: LIST
66664: PUSH
66665: LD_INT 1
66667: PUSH
66668: LD_INT 2
66670: PUSH
66671: EMPTY
66672: LIST
66673: LIST
66674: PUSH
66675: LD_INT 0
66677: PUSH
66678: LD_INT 2
66680: PUSH
66681: EMPTY
66682: LIST
66683: LIST
66684: PUSH
66685: LD_INT 1
66687: NEG
66688: PUSH
66689: LD_INT 1
66691: PUSH
66692: EMPTY
66693: LIST
66694: LIST
66695: PUSH
66696: LD_INT 1
66698: PUSH
66699: LD_INT 3
66701: PUSH
66702: EMPTY
66703: LIST
66704: LIST
66705: PUSH
66706: LD_INT 0
66708: PUSH
66709: LD_INT 3
66711: PUSH
66712: EMPTY
66713: LIST
66714: LIST
66715: PUSH
66716: LD_INT 1
66718: NEG
66719: PUSH
66720: LD_INT 2
66722: PUSH
66723: EMPTY
66724: LIST
66725: LIST
66726: PUSH
66727: EMPTY
66728: LIST
66729: LIST
66730: LIST
66731: LIST
66732: LIST
66733: LIST
66734: LIST
66735: LIST
66736: LIST
66737: LIST
66738: LIST
66739: LIST
66740: LIST
66741: LIST
66742: LIST
66743: LIST
66744: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
66745: LD_ADDR_VAR 0 12
66749: PUSH
66750: LD_INT 0
66752: PUSH
66753: LD_INT 0
66755: PUSH
66756: EMPTY
66757: LIST
66758: LIST
66759: PUSH
66760: LD_INT 0
66762: PUSH
66763: LD_INT 1
66765: NEG
66766: PUSH
66767: EMPTY
66768: LIST
66769: LIST
66770: PUSH
66771: LD_INT 1
66773: PUSH
66774: LD_INT 0
66776: PUSH
66777: EMPTY
66778: LIST
66779: LIST
66780: PUSH
66781: LD_INT 1
66783: PUSH
66784: LD_INT 1
66786: PUSH
66787: EMPTY
66788: LIST
66789: LIST
66790: PUSH
66791: LD_INT 0
66793: PUSH
66794: LD_INT 1
66796: PUSH
66797: EMPTY
66798: LIST
66799: LIST
66800: PUSH
66801: LD_INT 1
66803: NEG
66804: PUSH
66805: LD_INT 0
66807: PUSH
66808: EMPTY
66809: LIST
66810: LIST
66811: PUSH
66812: LD_INT 1
66814: NEG
66815: PUSH
66816: LD_INT 1
66818: NEG
66819: PUSH
66820: EMPTY
66821: LIST
66822: LIST
66823: PUSH
66824: LD_INT 1
66826: PUSH
66827: LD_INT 1
66829: NEG
66830: PUSH
66831: EMPTY
66832: LIST
66833: LIST
66834: PUSH
66835: LD_INT 2
66837: PUSH
66838: LD_INT 0
66840: PUSH
66841: EMPTY
66842: LIST
66843: LIST
66844: PUSH
66845: LD_INT 2
66847: PUSH
66848: LD_INT 1
66850: PUSH
66851: EMPTY
66852: LIST
66853: LIST
66854: PUSH
66855: LD_INT 1
66857: NEG
66858: PUSH
66859: LD_INT 1
66861: PUSH
66862: EMPTY
66863: LIST
66864: LIST
66865: PUSH
66866: LD_INT 2
66868: NEG
66869: PUSH
66870: LD_INT 0
66872: PUSH
66873: EMPTY
66874: LIST
66875: LIST
66876: PUSH
66877: LD_INT 2
66879: NEG
66880: PUSH
66881: LD_INT 1
66883: NEG
66884: PUSH
66885: EMPTY
66886: LIST
66887: LIST
66888: PUSH
66889: LD_INT 2
66891: NEG
66892: PUSH
66893: LD_INT 1
66895: PUSH
66896: EMPTY
66897: LIST
66898: LIST
66899: PUSH
66900: LD_INT 3
66902: NEG
66903: PUSH
66904: LD_INT 0
66906: PUSH
66907: EMPTY
66908: LIST
66909: LIST
66910: PUSH
66911: LD_INT 3
66913: NEG
66914: PUSH
66915: LD_INT 1
66917: NEG
66918: PUSH
66919: EMPTY
66920: LIST
66921: LIST
66922: PUSH
66923: EMPTY
66924: LIST
66925: LIST
66926: LIST
66927: LIST
66928: LIST
66929: LIST
66930: LIST
66931: LIST
66932: LIST
66933: LIST
66934: LIST
66935: LIST
66936: LIST
66937: LIST
66938: LIST
66939: LIST
66940: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
66941: LD_ADDR_VAR 0 13
66945: PUSH
66946: LD_INT 0
66948: PUSH
66949: LD_INT 0
66951: PUSH
66952: EMPTY
66953: LIST
66954: LIST
66955: PUSH
66956: LD_INT 0
66958: PUSH
66959: LD_INT 1
66961: NEG
66962: PUSH
66963: EMPTY
66964: LIST
66965: LIST
66966: PUSH
66967: LD_INT 1
66969: PUSH
66970: LD_INT 0
66972: PUSH
66973: EMPTY
66974: LIST
66975: LIST
66976: PUSH
66977: LD_INT 1
66979: PUSH
66980: LD_INT 1
66982: PUSH
66983: EMPTY
66984: LIST
66985: LIST
66986: PUSH
66987: LD_INT 0
66989: PUSH
66990: LD_INT 1
66992: PUSH
66993: EMPTY
66994: LIST
66995: LIST
66996: PUSH
66997: LD_INT 1
66999: NEG
67000: PUSH
67001: LD_INT 0
67003: PUSH
67004: EMPTY
67005: LIST
67006: LIST
67007: PUSH
67008: LD_INT 1
67010: NEG
67011: PUSH
67012: LD_INT 1
67014: NEG
67015: PUSH
67016: EMPTY
67017: LIST
67018: LIST
67019: PUSH
67020: LD_INT 1
67022: NEG
67023: PUSH
67024: LD_INT 2
67026: NEG
67027: PUSH
67028: EMPTY
67029: LIST
67030: LIST
67031: PUSH
67032: LD_INT 2
67034: PUSH
67035: LD_INT 1
67037: PUSH
67038: EMPTY
67039: LIST
67040: LIST
67041: PUSH
67042: LD_INT 2
67044: PUSH
67045: LD_INT 2
67047: PUSH
67048: EMPTY
67049: LIST
67050: LIST
67051: PUSH
67052: LD_INT 1
67054: PUSH
67055: LD_INT 2
67057: PUSH
67058: EMPTY
67059: LIST
67060: LIST
67061: PUSH
67062: LD_INT 2
67064: NEG
67065: PUSH
67066: LD_INT 1
67068: NEG
67069: PUSH
67070: EMPTY
67071: LIST
67072: LIST
67073: PUSH
67074: LD_INT 2
67076: NEG
67077: PUSH
67078: LD_INT 2
67080: NEG
67081: PUSH
67082: EMPTY
67083: LIST
67084: LIST
67085: PUSH
67086: LD_INT 2
67088: NEG
67089: PUSH
67090: LD_INT 3
67092: NEG
67093: PUSH
67094: EMPTY
67095: LIST
67096: LIST
67097: PUSH
67098: LD_INT 3
67100: NEG
67101: PUSH
67102: LD_INT 2
67104: NEG
67105: PUSH
67106: EMPTY
67107: LIST
67108: LIST
67109: PUSH
67110: LD_INT 3
67112: NEG
67113: PUSH
67114: LD_INT 3
67116: NEG
67117: PUSH
67118: EMPTY
67119: LIST
67120: LIST
67121: PUSH
67122: EMPTY
67123: LIST
67124: LIST
67125: LIST
67126: LIST
67127: LIST
67128: LIST
67129: LIST
67130: LIST
67131: LIST
67132: LIST
67133: LIST
67134: LIST
67135: LIST
67136: LIST
67137: LIST
67138: LIST
67139: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
67140: LD_ADDR_VAR 0 14
67144: PUSH
67145: LD_INT 0
67147: PUSH
67148: LD_INT 0
67150: PUSH
67151: EMPTY
67152: LIST
67153: LIST
67154: PUSH
67155: LD_INT 0
67157: PUSH
67158: LD_INT 1
67160: NEG
67161: PUSH
67162: EMPTY
67163: LIST
67164: LIST
67165: PUSH
67166: LD_INT 1
67168: PUSH
67169: LD_INT 0
67171: PUSH
67172: EMPTY
67173: LIST
67174: LIST
67175: PUSH
67176: LD_INT 1
67178: PUSH
67179: LD_INT 1
67181: PUSH
67182: EMPTY
67183: LIST
67184: LIST
67185: PUSH
67186: LD_INT 0
67188: PUSH
67189: LD_INT 1
67191: PUSH
67192: EMPTY
67193: LIST
67194: LIST
67195: PUSH
67196: LD_INT 1
67198: NEG
67199: PUSH
67200: LD_INT 0
67202: PUSH
67203: EMPTY
67204: LIST
67205: LIST
67206: PUSH
67207: LD_INT 1
67209: NEG
67210: PUSH
67211: LD_INT 1
67213: NEG
67214: PUSH
67215: EMPTY
67216: LIST
67217: LIST
67218: PUSH
67219: LD_INT 1
67221: NEG
67222: PUSH
67223: LD_INT 2
67225: NEG
67226: PUSH
67227: EMPTY
67228: LIST
67229: LIST
67230: PUSH
67231: LD_INT 0
67233: PUSH
67234: LD_INT 2
67236: NEG
67237: PUSH
67238: EMPTY
67239: LIST
67240: LIST
67241: PUSH
67242: LD_INT 1
67244: PUSH
67245: LD_INT 1
67247: NEG
67248: PUSH
67249: EMPTY
67250: LIST
67251: LIST
67252: PUSH
67253: LD_INT 1
67255: PUSH
67256: LD_INT 2
67258: PUSH
67259: EMPTY
67260: LIST
67261: LIST
67262: PUSH
67263: LD_INT 0
67265: PUSH
67266: LD_INT 2
67268: PUSH
67269: EMPTY
67270: LIST
67271: LIST
67272: PUSH
67273: LD_INT 1
67275: NEG
67276: PUSH
67277: LD_INT 1
67279: PUSH
67280: EMPTY
67281: LIST
67282: LIST
67283: PUSH
67284: LD_INT 1
67286: NEG
67287: PUSH
67288: LD_INT 3
67290: NEG
67291: PUSH
67292: EMPTY
67293: LIST
67294: LIST
67295: PUSH
67296: LD_INT 0
67298: PUSH
67299: LD_INT 3
67301: NEG
67302: PUSH
67303: EMPTY
67304: LIST
67305: LIST
67306: PUSH
67307: LD_INT 1
67309: PUSH
67310: LD_INT 2
67312: NEG
67313: PUSH
67314: EMPTY
67315: LIST
67316: LIST
67317: PUSH
67318: EMPTY
67319: LIST
67320: LIST
67321: LIST
67322: LIST
67323: LIST
67324: LIST
67325: LIST
67326: LIST
67327: LIST
67328: LIST
67329: LIST
67330: LIST
67331: LIST
67332: LIST
67333: LIST
67334: LIST
67335: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
67336: LD_ADDR_VAR 0 15
67340: PUSH
67341: LD_INT 0
67343: PUSH
67344: LD_INT 0
67346: PUSH
67347: EMPTY
67348: LIST
67349: LIST
67350: PUSH
67351: LD_INT 0
67353: PUSH
67354: LD_INT 1
67356: NEG
67357: PUSH
67358: EMPTY
67359: LIST
67360: LIST
67361: PUSH
67362: LD_INT 1
67364: PUSH
67365: LD_INT 0
67367: PUSH
67368: EMPTY
67369: LIST
67370: LIST
67371: PUSH
67372: LD_INT 1
67374: PUSH
67375: LD_INT 1
67377: PUSH
67378: EMPTY
67379: LIST
67380: LIST
67381: PUSH
67382: LD_INT 0
67384: PUSH
67385: LD_INT 1
67387: PUSH
67388: EMPTY
67389: LIST
67390: LIST
67391: PUSH
67392: LD_INT 1
67394: NEG
67395: PUSH
67396: LD_INT 0
67398: PUSH
67399: EMPTY
67400: LIST
67401: LIST
67402: PUSH
67403: LD_INT 1
67405: NEG
67406: PUSH
67407: LD_INT 1
67409: NEG
67410: PUSH
67411: EMPTY
67412: LIST
67413: LIST
67414: PUSH
67415: LD_INT 1
67417: PUSH
67418: LD_INT 1
67420: NEG
67421: PUSH
67422: EMPTY
67423: LIST
67424: LIST
67425: PUSH
67426: LD_INT 2
67428: PUSH
67429: LD_INT 0
67431: PUSH
67432: EMPTY
67433: LIST
67434: LIST
67435: PUSH
67436: LD_INT 2
67438: PUSH
67439: LD_INT 1
67441: PUSH
67442: EMPTY
67443: LIST
67444: LIST
67445: PUSH
67446: LD_INT 1
67448: NEG
67449: PUSH
67450: LD_INT 1
67452: PUSH
67453: EMPTY
67454: LIST
67455: LIST
67456: PUSH
67457: LD_INT 2
67459: NEG
67460: PUSH
67461: LD_INT 0
67463: PUSH
67464: EMPTY
67465: LIST
67466: LIST
67467: PUSH
67468: LD_INT 2
67470: NEG
67471: PUSH
67472: LD_INT 1
67474: NEG
67475: PUSH
67476: EMPTY
67477: LIST
67478: LIST
67479: PUSH
67480: LD_INT 2
67482: PUSH
67483: LD_INT 1
67485: NEG
67486: PUSH
67487: EMPTY
67488: LIST
67489: LIST
67490: PUSH
67491: LD_INT 3
67493: PUSH
67494: LD_INT 0
67496: PUSH
67497: EMPTY
67498: LIST
67499: LIST
67500: PUSH
67501: LD_INT 3
67503: PUSH
67504: LD_INT 1
67506: PUSH
67507: EMPTY
67508: LIST
67509: LIST
67510: PUSH
67511: EMPTY
67512: LIST
67513: LIST
67514: LIST
67515: LIST
67516: LIST
67517: LIST
67518: LIST
67519: LIST
67520: LIST
67521: LIST
67522: LIST
67523: LIST
67524: LIST
67525: LIST
67526: LIST
67527: LIST
67528: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
67529: LD_ADDR_VAR 0 16
67533: PUSH
67534: LD_INT 0
67536: PUSH
67537: LD_INT 0
67539: PUSH
67540: EMPTY
67541: LIST
67542: LIST
67543: PUSH
67544: LD_INT 0
67546: PUSH
67547: LD_INT 1
67549: NEG
67550: PUSH
67551: EMPTY
67552: LIST
67553: LIST
67554: PUSH
67555: LD_INT 1
67557: PUSH
67558: LD_INT 0
67560: PUSH
67561: EMPTY
67562: LIST
67563: LIST
67564: PUSH
67565: LD_INT 1
67567: PUSH
67568: LD_INT 1
67570: PUSH
67571: EMPTY
67572: LIST
67573: LIST
67574: PUSH
67575: LD_INT 0
67577: PUSH
67578: LD_INT 1
67580: PUSH
67581: EMPTY
67582: LIST
67583: LIST
67584: PUSH
67585: LD_INT 1
67587: NEG
67588: PUSH
67589: LD_INT 0
67591: PUSH
67592: EMPTY
67593: LIST
67594: LIST
67595: PUSH
67596: LD_INT 1
67598: NEG
67599: PUSH
67600: LD_INT 1
67602: NEG
67603: PUSH
67604: EMPTY
67605: LIST
67606: LIST
67607: PUSH
67608: LD_INT 1
67610: NEG
67611: PUSH
67612: LD_INT 2
67614: NEG
67615: PUSH
67616: EMPTY
67617: LIST
67618: LIST
67619: PUSH
67620: LD_INT 2
67622: PUSH
67623: LD_INT 1
67625: PUSH
67626: EMPTY
67627: LIST
67628: LIST
67629: PUSH
67630: LD_INT 2
67632: PUSH
67633: LD_INT 2
67635: PUSH
67636: EMPTY
67637: LIST
67638: LIST
67639: PUSH
67640: LD_INT 1
67642: PUSH
67643: LD_INT 2
67645: PUSH
67646: EMPTY
67647: LIST
67648: LIST
67649: PUSH
67650: LD_INT 2
67652: NEG
67653: PUSH
67654: LD_INT 1
67656: NEG
67657: PUSH
67658: EMPTY
67659: LIST
67660: LIST
67661: PUSH
67662: LD_INT 2
67664: NEG
67665: PUSH
67666: LD_INT 2
67668: NEG
67669: PUSH
67670: EMPTY
67671: LIST
67672: LIST
67673: PUSH
67674: LD_INT 3
67676: PUSH
67677: LD_INT 2
67679: PUSH
67680: EMPTY
67681: LIST
67682: LIST
67683: PUSH
67684: LD_INT 3
67686: PUSH
67687: LD_INT 3
67689: PUSH
67690: EMPTY
67691: LIST
67692: LIST
67693: PUSH
67694: LD_INT 2
67696: PUSH
67697: LD_INT 3
67699: PUSH
67700: EMPTY
67701: LIST
67702: LIST
67703: PUSH
67704: EMPTY
67705: LIST
67706: LIST
67707: LIST
67708: LIST
67709: LIST
67710: LIST
67711: LIST
67712: LIST
67713: LIST
67714: LIST
67715: LIST
67716: LIST
67717: LIST
67718: LIST
67719: LIST
67720: LIST
67721: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67722: LD_ADDR_VAR 0 17
67726: PUSH
67727: LD_INT 0
67729: PUSH
67730: LD_INT 0
67732: PUSH
67733: EMPTY
67734: LIST
67735: LIST
67736: PUSH
67737: LD_INT 0
67739: PUSH
67740: LD_INT 1
67742: NEG
67743: PUSH
67744: EMPTY
67745: LIST
67746: LIST
67747: PUSH
67748: LD_INT 1
67750: PUSH
67751: LD_INT 0
67753: PUSH
67754: EMPTY
67755: LIST
67756: LIST
67757: PUSH
67758: LD_INT 1
67760: PUSH
67761: LD_INT 1
67763: PUSH
67764: EMPTY
67765: LIST
67766: LIST
67767: PUSH
67768: LD_INT 0
67770: PUSH
67771: LD_INT 1
67773: PUSH
67774: EMPTY
67775: LIST
67776: LIST
67777: PUSH
67778: LD_INT 1
67780: NEG
67781: PUSH
67782: LD_INT 0
67784: PUSH
67785: EMPTY
67786: LIST
67787: LIST
67788: PUSH
67789: LD_INT 1
67791: NEG
67792: PUSH
67793: LD_INT 1
67795: NEG
67796: PUSH
67797: EMPTY
67798: LIST
67799: LIST
67800: PUSH
67801: LD_INT 1
67803: NEG
67804: PUSH
67805: LD_INT 2
67807: NEG
67808: PUSH
67809: EMPTY
67810: LIST
67811: LIST
67812: PUSH
67813: LD_INT 0
67815: PUSH
67816: LD_INT 2
67818: NEG
67819: PUSH
67820: EMPTY
67821: LIST
67822: LIST
67823: PUSH
67824: LD_INT 1
67826: PUSH
67827: LD_INT 1
67829: NEG
67830: PUSH
67831: EMPTY
67832: LIST
67833: LIST
67834: PUSH
67835: LD_INT 2
67837: PUSH
67838: LD_INT 0
67840: PUSH
67841: EMPTY
67842: LIST
67843: LIST
67844: PUSH
67845: LD_INT 2
67847: PUSH
67848: LD_INT 1
67850: PUSH
67851: EMPTY
67852: LIST
67853: LIST
67854: PUSH
67855: LD_INT 2
67857: PUSH
67858: LD_INT 2
67860: PUSH
67861: EMPTY
67862: LIST
67863: LIST
67864: PUSH
67865: LD_INT 1
67867: PUSH
67868: LD_INT 2
67870: PUSH
67871: EMPTY
67872: LIST
67873: LIST
67874: PUSH
67875: LD_INT 0
67877: PUSH
67878: LD_INT 2
67880: PUSH
67881: EMPTY
67882: LIST
67883: LIST
67884: PUSH
67885: LD_INT 1
67887: NEG
67888: PUSH
67889: LD_INT 1
67891: PUSH
67892: EMPTY
67893: LIST
67894: LIST
67895: PUSH
67896: LD_INT 2
67898: NEG
67899: PUSH
67900: LD_INT 0
67902: PUSH
67903: EMPTY
67904: LIST
67905: LIST
67906: PUSH
67907: LD_INT 2
67909: NEG
67910: PUSH
67911: LD_INT 1
67913: NEG
67914: PUSH
67915: EMPTY
67916: LIST
67917: LIST
67918: PUSH
67919: LD_INT 2
67921: NEG
67922: PUSH
67923: LD_INT 2
67925: NEG
67926: PUSH
67927: EMPTY
67928: LIST
67929: LIST
67930: PUSH
67931: EMPTY
67932: LIST
67933: LIST
67934: LIST
67935: LIST
67936: LIST
67937: LIST
67938: LIST
67939: LIST
67940: LIST
67941: LIST
67942: LIST
67943: LIST
67944: LIST
67945: LIST
67946: LIST
67947: LIST
67948: LIST
67949: LIST
67950: LIST
67951: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67952: LD_ADDR_VAR 0 18
67956: PUSH
67957: LD_INT 0
67959: PUSH
67960: LD_INT 0
67962: PUSH
67963: EMPTY
67964: LIST
67965: LIST
67966: PUSH
67967: LD_INT 0
67969: PUSH
67970: LD_INT 1
67972: NEG
67973: PUSH
67974: EMPTY
67975: LIST
67976: LIST
67977: PUSH
67978: LD_INT 1
67980: PUSH
67981: LD_INT 0
67983: PUSH
67984: EMPTY
67985: LIST
67986: LIST
67987: PUSH
67988: LD_INT 1
67990: PUSH
67991: LD_INT 1
67993: PUSH
67994: EMPTY
67995: LIST
67996: LIST
67997: PUSH
67998: LD_INT 0
68000: PUSH
68001: LD_INT 1
68003: PUSH
68004: EMPTY
68005: LIST
68006: LIST
68007: PUSH
68008: LD_INT 1
68010: NEG
68011: PUSH
68012: LD_INT 0
68014: PUSH
68015: EMPTY
68016: LIST
68017: LIST
68018: PUSH
68019: LD_INT 1
68021: NEG
68022: PUSH
68023: LD_INT 1
68025: NEG
68026: PUSH
68027: EMPTY
68028: LIST
68029: LIST
68030: PUSH
68031: LD_INT 1
68033: NEG
68034: PUSH
68035: LD_INT 2
68037: NEG
68038: PUSH
68039: EMPTY
68040: LIST
68041: LIST
68042: PUSH
68043: LD_INT 0
68045: PUSH
68046: LD_INT 2
68048: NEG
68049: PUSH
68050: EMPTY
68051: LIST
68052: LIST
68053: PUSH
68054: LD_INT 1
68056: PUSH
68057: LD_INT 1
68059: NEG
68060: PUSH
68061: EMPTY
68062: LIST
68063: LIST
68064: PUSH
68065: LD_INT 2
68067: PUSH
68068: LD_INT 0
68070: PUSH
68071: EMPTY
68072: LIST
68073: LIST
68074: PUSH
68075: LD_INT 2
68077: PUSH
68078: LD_INT 1
68080: PUSH
68081: EMPTY
68082: LIST
68083: LIST
68084: PUSH
68085: LD_INT 2
68087: PUSH
68088: LD_INT 2
68090: PUSH
68091: EMPTY
68092: LIST
68093: LIST
68094: PUSH
68095: LD_INT 1
68097: PUSH
68098: LD_INT 2
68100: PUSH
68101: EMPTY
68102: LIST
68103: LIST
68104: PUSH
68105: LD_INT 0
68107: PUSH
68108: LD_INT 2
68110: PUSH
68111: EMPTY
68112: LIST
68113: LIST
68114: PUSH
68115: LD_INT 1
68117: NEG
68118: PUSH
68119: LD_INT 1
68121: PUSH
68122: EMPTY
68123: LIST
68124: LIST
68125: PUSH
68126: LD_INT 2
68128: NEG
68129: PUSH
68130: LD_INT 0
68132: PUSH
68133: EMPTY
68134: LIST
68135: LIST
68136: PUSH
68137: LD_INT 2
68139: NEG
68140: PUSH
68141: LD_INT 1
68143: NEG
68144: PUSH
68145: EMPTY
68146: LIST
68147: LIST
68148: PUSH
68149: LD_INT 2
68151: NEG
68152: PUSH
68153: LD_INT 2
68155: NEG
68156: PUSH
68157: EMPTY
68158: LIST
68159: LIST
68160: PUSH
68161: EMPTY
68162: LIST
68163: LIST
68164: LIST
68165: LIST
68166: LIST
68167: LIST
68168: LIST
68169: LIST
68170: LIST
68171: LIST
68172: LIST
68173: LIST
68174: LIST
68175: LIST
68176: LIST
68177: LIST
68178: LIST
68179: LIST
68180: LIST
68181: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68182: LD_ADDR_VAR 0 19
68186: PUSH
68187: LD_INT 0
68189: PUSH
68190: LD_INT 0
68192: PUSH
68193: EMPTY
68194: LIST
68195: LIST
68196: PUSH
68197: LD_INT 0
68199: PUSH
68200: LD_INT 1
68202: NEG
68203: PUSH
68204: EMPTY
68205: LIST
68206: LIST
68207: PUSH
68208: LD_INT 1
68210: PUSH
68211: LD_INT 0
68213: PUSH
68214: EMPTY
68215: LIST
68216: LIST
68217: PUSH
68218: LD_INT 1
68220: PUSH
68221: LD_INT 1
68223: PUSH
68224: EMPTY
68225: LIST
68226: LIST
68227: PUSH
68228: LD_INT 0
68230: PUSH
68231: LD_INT 1
68233: PUSH
68234: EMPTY
68235: LIST
68236: LIST
68237: PUSH
68238: LD_INT 1
68240: NEG
68241: PUSH
68242: LD_INT 0
68244: PUSH
68245: EMPTY
68246: LIST
68247: LIST
68248: PUSH
68249: LD_INT 1
68251: NEG
68252: PUSH
68253: LD_INT 1
68255: NEG
68256: PUSH
68257: EMPTY
68258: LIST
68259: LIST
68260: PUSH
68261: LD_INT 1
68263: NEG
68264: PUSH
68265: LD_INT 2
68267: NEG
68268: PUSH
68269: EMPTY
68270: LIST
68271: LIST
68272: PUSH
68273: LD_INT 0
68275: PUSH
68276: LD_INT 2
68278: NEG
68279: PUSH
68280: EMPTY
68281: LIST
68282: LIST
68283: PUSH
68284: LD_INT 1
68286: PUSH
68287: LD_INT 1
68289: NEG
68290: PUSH
68291: EMPTY
68292: LIST
68293: LIST
68294: PUSH
68295: LD_INT 2
68297: PUSH
68298: LD_INT 0
68300: PUSH
68301: EMPTY
68302: LIST
68303: LIST
68304: PUSH
68305: LD_INT 2
68307: PUSH
68308: LD_INT 1
68310: PUSH
68311: EMPTY
68312: LIST
68313: LIST
68314: PUSH
68315: LD_INT 2
68317: PUSH
68318: LD_INT 2
68320: PUSH
68321: EMPTY
68322: LIST
68323: LIST
68324: PUSH
68325: LD_INT 1
68327: PUSH
68328: LD_INT 2
68330: PUSH
68331: EMPTY
68332: LIST
68333: LIST
68334: PUSH
68335: LD_INT 0
68337: PUSH
68338: LD_INT 2
68340: PUSH
68341: EMPTY
68342: LIST
68343: LIST
68344: PUSH
68345: LD_INT 1
68347: NEG
68348: PUSH
68349: LD_INT 1
68351: PUSH
68352: EMPTY
68353: LIST
68354: LIST
68355: PUSH
68356: LD_INT 2
68358: NEG
68359: PUSH
68360: LD_INT 0
68362: PUSH
68363: EMPTY
68364: LIST
68365: LIST
68366: PUSH
68367: LD_INT 2
68369: NEG
68370: PUSH
68371: LD_INT 1
68373: NEG
68374: PUSH
68375: EMPTY
68376: LIST
68377: LIST
68378: PUSH
68379: LD_INT 2
68381: NEG
68382: PUSH
68383: LD_INT 2
68385: NEG
68386: PUSH
68387: EMPTY
68388: LIST
68389: LIST
68390: PUSH
68391: EMPTY
68392: LIST
68393: LIST
68394: LIST
68395: LIST
68396: LIST
68397: LIST
68398: LIST
68399: LIST
68400: LIST
68401: LIST
68402: LIST
68403: LIST
68404: LIST
68405: LIST
68406: LIST
68407: LIST
68408: LIST
68409: LIST
68410: LIST
68411: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68412: LD_ADDR_VAR 0 20
68416: PUSH
68417: LD_INT 0
68419: PUSH
68420: LD_INT 0
68422: PUSH
68423: EMPTY
68424: LIST
68425: LIST
68426: PUSH
68427: LD_INT 0
68429: PUSH
68430: LD_INT 1
68432: NEG
68433: PUSH
68434: EMPTY
68435: LIST
68436: LIST
68437: PUSH
68438: LD_INT 1
68440: PUSH
68441: LD_INT 0
68443: PUSH
68444: EMPTY
68445: LIST
68446: LIST
68447: PUSH
68448: LD_INT 1
68450: PUSH
68451: LD_INT 1
68453: PUSH
68454: EMPTY
68455: LIST
68456: LIST
68457: PUSH
68458: LD_INT 0
68460: PUSH
68461: LD_INT 1
68463: PUSH
68464: EMPTY
68465: LIST
68466: LIST
68467: PUSH
68468: LD_INT 1
68470: NEG
68471: PUSH
68472: LD_INT 0
68474: PUSH
68475: EMPTY
68476: LIST
68477: LIST
68478: PUSH
68479: LD_INT 1
68481: NEG
68482: PUSH
68483: LD_INT 1
68485: NEG
68486: PUSH
68487: EMPTY
68488: LIST
68489: LIST
68490: PUSH
68491: LD_INT 1
68493: NEG
68494: PUSH
68495: LD_INT 2
68497: NEG
68498: PUSH
68499: EMPTY
68500: LIST
68501: LIST
68502: PUSH
68503: LD_INT 0
68505: PUSH
68506: LD_INT 2
68508: NEG
68509: PUSH
68510: EMPTY
68511: LIST
68512: LIST
68513: PUSH
68514: LD_INT 1
68516: PUSH
68517: LD_INT 1
68519: NEG
68520: PUSH
68521: EMPTY
68522: LIST
68523: LIST
68524: PUSH
68525: LD_INT 2
68527: PUSH
68528: LD_INT 0
68530: PUSH
68531: EMPTY
68532: LIST
68533: LIST
68534: PUSH
68535: LD_INT 2
68537: PUSH
68538: LD_INT 1
68540: PUSH
68541: EMPTY
68542: LIST
68543: LIST
68544: PUSH
68545: LD_INT 2
68547: PUSH
68548: LD_INT 2
68550: PUSH
68551: EMPTY
68552: LIST
68553: LIST
68554: PUSH
68555: LD_INT 1
68557: PUSH
68558: LD_INT 2
68560: PUSH
68561: EMPTY
68562: LIST
68563: LIST
68564: PUSH
68565: LD_INT 0
68567: PUSH
68568: LD_INT 2
68570: PUSH
68571: EMPTY
68572: LIST
68573: LIST
68574: PUSH
68575: LD_INT 1
68577: NEG
68578: PUSH
68579: LD_INT 1
68581: PUSH
68582: EMPTY
68583: LIST
68584: LIST
68585: PUSH
68586: LD_INT 2
68588: NEG
68589: PUSH
68590: LD_INT 0
68592: PUSH
68593: EMPTY
68594: LIST
68595: LIST
68596: PUSH
68597: LD_INT 2
68599: NEG
68600: PUSH
68601: LD_INT 1
68603: NEG
68604: PUSH
68605: EMPTY
68606: LIST
68607: LIST
68608: PUSH
68609: LD_INT 2
68611: NEG
68612: PUSH
68613: LD_INT 2
68615: NEG
68616: PUSH
68617: EMPTY
68618: LIST
68619: LIST
68620: PUSH
68621: EMPTY
68622: LIST
68623: LIST
68624: LIST
68625: LIST
68626: LIST
68627: LIST
68628: LIST
68629: LIST
68630: LIST
68631: LIST
68632: LIST
68633: LIST
68634: LIST
68635: LIST
68636: LIST
68637: LIST
68638: LIST
68639: LIST
68640: LIST
68641: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68642: LD_ADDR_VAR 0 21
68646: PUSH
68647: LD_INT 0
68649: PUSH
68650: LD_INT 0
68652: PUSH
68653: EMPTY
68654: LIST
68655: LIST
68656: PUSH
68657: LD_INT 0
68659: PUSH
68660: LD_INT 1
68662: NEG
68663: PUSH
68664: EMPTY
68665: LIST
68666: LIST
68667: PUSH
68668: LD_INT 1
68670: PUSH
68671: LD_INT 0
68673: PUSH
68674: EMPTY
68675: LIST
68676: LIST
68677: PUSH
68678: LD_INT 1
68680: PUSH
68681: LD_INT 1
68683: PUSH
68684: EMPTY
68685: LIST
68686: LIST
68687: PUSH
68688: LD_INT 0
68690: PUSH
68691: LD_INT 1
68693: PUSH
68694: EMPTY
68695: LIST
68696: LIST
68697: PUSH
68698: LD_INT 1
68700: NEG
68701: PUSH
68702: LD_INT 0
68704: PUSH
68705: EMPTY
68706: LIST
68707: LIST
68708: PUSH
68709: LD_INT 1
68711: NEG
68712: PUSH
68713: LD_INT 1
68715: NEG
68716: PUSH
68717: EMPTY
68718: LIST
68719: LIST
68720: PUSH
68721: LD_INT 1
68723: NEG
68724: PUSH
68725: LD_INT 2
68727: NEG
68728: PUSH
68729: EMPTY
68730: LIST
68731: LIST
68732: PUSH
68733: LD_INT 0
68735: PUSH
68736: LD_INT 2
68738: NEG
68739: PUSH
68740: EMPTY
68741: LIST
68742: LIST
68743: PUSH
68744: LD_INT 1
68746: PUSH
68747: LD_INT 1
68749: NEG
68750: PUSH
68751: EMPTY
68752: LIST
68753: LIST
68754: PUSH
68755: LD_INT 2
68757: PUSH
68758: LD_INT 0
68760: PUSH
68761: EMPTY
68762: LIST
68763: LIST
68764: PUSH
68765: LD_INT 2
68767: PUSH
68768: LD_INT 1
68770: PUSH
68771: EMPTY
68772: LIST
68773: LIST
68774: PUSH
68775: LD_INT 2
68777: PUSH
68778: LD_INT 2
68780: PUSH
68781: EMPTY
68782: LIST
68783: LIST
68784: PUSH
68785: LD_INT 1
68787: PUSH
68788: LD_INT 2
68790: PUSH
68791: EMPTY
68792: LIST
68793: LIST
68794: PUSH
68795: LD_INT 0
68797: PUSH
68798: LD_INT 2
68800: PUSH
68801: EMPTY
68802: LIST
68803: LIST
68804: PUSH
68805: LD_INT 1
68807: NEG
68808: PUSH
68809: LD_INT 1
68811: PUSH
68812: EMPTY
68813: LIST
68814: LIST
68815: PUSH
68816: LD_INT 2
68818: NEG
68819: PUSH
68820: LD_INT 0
68822: PUSH
68823: EMPTY
68824: LIST
68825: LIST
68826: PUSH
68827: LD_INT 2
68829: NEG
68830: PUSH
68831: LD_INT 1
68833: NEG
68834: PUSH
68835: EMPTY
68836: LIST
68837: LIST
68838: PUSH
68839: LD_INT 2
68841: NEG
68842: PUSH
68843: LD_INT 2
68845: NEG
68846: PUSH
68847: EMPTY
68848: LIST
68849: LIST
68850: PUSH
68851: EMPTY
68852: LIST
68853: LIST
68854: LIST
68855: LIST
68856: LIST
68857: LIST
68858: LIST
68859: LIST
68860: LIST
68861: LIST
68862: LIST
68863: LIST
68864: LIST
68865: LIST
68866: LIST
68867: LIST
68868: LIST
68869: LIST
68870: LIST
68871: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68872: LD_ADDR_VAR 0 22
68876: PUSH
68877: LD_INT 0
68879: PUSH
68880: LD_INT 0
68882: PUSH
68883: EMPTY
68884: LIST
68885: LIST
68886: PUSH
68887: LD_INT 0
68889: PUSH
68890: LD_INT 1
68892: NEG
68893: PUSH
68894: EMPTY
68895: LIST
68896: LIST
68897: PUSH
68898: LD_INT 1
68900: PUSH
68901: LD_INT 0
68903: PUSH
68904: EMPTY
68905: LIST
68906: LIST
68907: PUSH
68908: LD_INT 1
68910: PUSH
68911: LD_INT 1
68913: PUSH
68914: EMPTY
68915: LIST
68916: LIST
68917: PUSH
68918: LD_INT 0
68920: PUSH
68921: LD_INT 1
68923: PUSH
68924: EMPTY
68925: LIST
68926: LIST
68927: PUSH
68928: LD_INT 1
68930: NEG
68931: PUSH
68932: LD_INT 0
68934: PUSH
68935: EMPTY
68936: LIST
68937: LIST
68938: PUSH
68939: LD_INT 1
68941: NEG
68942: PUSH
68943: LD_INT 1
68945: NEG
68946: PUSH
68947: EMPTY
68948: LIST
68949: LIST
68950: PUSH
68951: LD_INT 1
68953: NEG
68954: PUSH
68955: LD_INT 2
68957: NEG
68958: PUSH
68959: EMPTY
68960: LIST
68961: LIST
68962: PUSH
68963: LD_INT 0
68965: PUSH
68966: LD_INT 2
68968: NEG
68969: PUSH
68970: EMPTY
68971: LIST
68972: LIST
68973: PUSH
68974: LD_INT 1
68976: PUSH
68977: LD_INT 1
68979: NEG
68980: PUSH
68981: EMPTY
68982: LIST
68983: LIST
68984: PUSH
68985: LD_INT 2
68987: PUSH
68988: LD_INT 0
68990: PUSH
68991: EMPTY
68992: LIST
68993: LIST
68994: PUSH
68995: LD_INT 2
68997: PUSH
68998: LD_INT 1
69000: PUSH
69001: EMPTY
69002: LIST
69003: LIST
69004: PUSH
69005: LD_INT 2
69007: PUSH
69008: LD_INT 2
69010: PUSH
69011: EMPTY
69012: LIST
69013: LIST
69014: PUSH
69015: LD_INT 1
69017: PUSH
69018: LD_INT 2
69020: PUSH
69021: EMPTY
69022: LIST
69023: LIST
69024: PUSH
69025: LD_INT 0
69027: PUSH
69028: LD_INT 2
69030: PUSH
69031: EMPTY
69032: LIST
69033: LIST
69034: PUSH
69035: LD_INT 1
69037: NEG
69038: PUSH
69039: LD_INT 1
69041: PUSH
69042: EMPTY
69043: LIST
69044: LIST
69045: PUSH
69046: LD_INT 2
69048: NEG
69049: PUSH
69050: LD_INT 0
69052: PUSH
69053: EMPTY
69054: LIST
69055: LIST
69056: PUSH
69057: LD_INT 2
69059: NEG
69060: PUSH
69061: LD_INT 1
69063: NEG
69064: PUSH
69065: EMPTY
69066: LIST
69067: LIST
69068: PUSH
69069: LD_INT 2
69071: NEG
69072: PUSH
69073: LD_INT 2
69075: NEG
69076: PUSH
69077: EMPTY
69078: LIST
69079: LIST
69080: PUSH
69081: EMPTY
69082: LIST
69083: LIST
69084: LIST
69085: LIST
69086: LIST
69087: LIST
69088: LIST
69089: LIST
69090: LIST
69091: LIST
69092: LIST
69093: LIST
69094: LIST
69095: LIST
69096: LIST
69097: LIST
69098: LIST
69099: LIST
69100: LIST
69101: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
69102: LD_ADDR_VAR 0 23
69106: PUSH
69107: LD_INT 0
69109: PUSH
69110: LD_INT 0
69112: PUSH
69113: EMPTY
69114: LIST
69115: LIST
69116: PUSH
69117: LD_INT 0
69119: PUSH
69120: LD_INT 1
69122: NEG
69123: PUSH
69124: EMPTY
69125: LIST
69126: LIST
69127: PUSH
69128: LD_INT 1
69130: PUSH
69131: LD_INT 0
69133: PUSH
69134: EMPTY
69135: LIST
69136: LIST
69137: PUSH
69138: LD_INT 1
69140: PUSH
69141: LD_INT 1
69143: PUSH
69144: EMPTY
69145: LIST
69146: LIST
69147: PUSH
69148: LD_INT 0
69150: PUSH
69151: LD_INT 1
69153: PUSH
69154: EMPTY
69155: LIST
69156: LIST
69157: PUSH
69158: LD_INT 1
69160: NEG
69161: PUSH
69162: LD_INT 0
69164: PUSH
69165: EMPTY
69166: LIST
69167: LIST
69168: PUSH
69169: LD_INT 1
69171: NEG
69172: PUSH
69173: LD_INT 1
69175: NEG
69176: PUSH
69177: EMPTY
69178: LIST
69179: LIST
69180: PUSH
69181: LD_INT 1
69183: NEG
69184: PUSH
69185: LD_INT 2
69187: NEG
69188: PUSH
69189: EMPTY
69190: LIST
69191: LIST
69192: PUSH
69193: LD_INT 0
69195: PUSH
69196: LD_INT 2
69198: NEG
69199: PUSH
69200: EMPTY
69201: LIST
69202: LIST
69203: PUSH
69204: LD_INT 1
69206: PUSH
69207: LD_INT 1
69209: NEG
69210: PUSH
69211: EMPTY
69212: LIST
69213: LIST
69214: PUSH
69215: LD_INT 2
69217: PUSH
69218: LD_INT 0
69220: PUSH
69221: EMPTY
69222: LIST
69223: LIST
69224: PUSH
69225: LD_INT 2
69227: PUSH
69228: LD_INT 1
69230: PUSH
69231: EMPTY
69232: LIST
69233: LIST
69234: PUSH
69235: LD_INT 2
69237: PUSH
69238: LD_INT 2
69240: PUSH
69241: EMPTY
69242: LIST
69243: LIST
69244: PUSH
69245: LD_INT 1
69247: PUSH
69248: LD_INT 2
69250: PUSH
69251: EMPTY
69252: LIST
69253: LIST
69254: PUSH
69255: LD_INT 0
69257: PUSH
69258: LD_INT 2
69260: PUSH
69261: EMPTY
69262: LIST
69263: LIST
69264: PUSH
69265: LD_INT 1
69267: NEG
69268: PUSH
69269: LD_INT 1
69271: PUSH
69272: EMPTY
69273: LIST
69274: LIST
69275: PUSH
69276: LD_INT 2
69278: NEG
69279: PUSH
69280: LD_INT 0
69282: PUSH
69283: EMPTY
69284: LIST
69285: LIST
69286: PUSH
69287: LD_INT 2
69289: NEG
69290: PUSH
69291: LD_INT 1
69293: NEG
69294: PUSH
69295: EMPTY
69296: LIST
69297: LIST
69298: PUSH
69299: LD_INT 2
69301: NEG
69302: PUSH
69303: LD_INT 2
69305: NEG
69306: PUSH
69307: EMPTY
69308: LIST
69309: LIST
69310: PUSH
69311: LD_INT 2
69313: NEG
69314: PUSH
69315: LD_INT 3
69317: NEG
69318: PUSH
69319: EMPTY
69320: LIST
69321: LIST
69322: PUSH
69323: LD_INT 1
69325: NEG
69326: PUSH
69327: LD_INT 3
69329: NEG
69330: PUSH
69331: EMPTY
69332: LIST
69333: LIST
69334: PUSH
69335: LD_INT 1
69337: PUSH
69338: LD_INT 2
69340: NEG
69341: PUSH
69342: EMPTY
69343: LIST
69344: LIST
69345: PUSH
69346: LD_INT 2
69348: PUSH
69349: LD_INT 1
69351: NEG
69352: PUSH
69353: EMPTY
69354: LIST
69355: LIST
69356: PUSH
69357: EMPTY
69358: LIST
69359: LIST
69360: LIST
69361: LIST
69362: LIST
69363: LIST
69364: LIST
69365: LIST
69366: LIST
69367: LIST
69368: LIST
69369: LIST
69370: LIST
69371: LIST
69372: LIST
69373: LIST
69374: LIST
69375: LIST
69376: LIST
69377: LIST
69378: LIST
69379: LIST
69380: LIST
69381: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
69382: LD_ADDR_VAR 0 24
69386: PUSH
69387: LD_INT 0
69389: PUSH
69390: LD_INT 0
69392: PUSH
69393: EMPTY
69394: LIST
69395: LIST
69396: PUSH
69397: LD_INT 0
69399: PUSH
69400: LD_INT 1
69402: NEG
69403: PUSH
69404: EMPTY
69405: LIST
69406: LIST
69407: PUSH
69408: LD_INT 1
69410: PUSH
69411: LD_INT 0
69413: PUSH
69414: EMPTY
69415: LIST
69416: LIST
69417: PUSH
69418: LD_INT 1
69420: PUSH
69421: LD_INT 1
69423: PUSH
69424: EMPTY
69425: LIST
69426: LIST
69427: PUSH
69428: LD_INT 0
69430: PUSH
69431: LD_INT 1
69433: PUSH
69434: EMPTY
69435: LIST
69436: LIST
69437: PUSH
69438: LD_INT 1
69440: NEG
69441: PUSH
69442: LD_INT 0
69444: PUSH
69445: EMPTY
69446: LIST
69447: LIST
69448: PUSH
69449: LD_INT 1
69451: NEG
69452: PUSH
69453: LD_INT 1
69455: NEG
69456: PUSH
69457: EMPTY
69458: LIST
69459: LIST
69460: PUSH
69461: LD_INT 1
69463: NEG
69464: PUSH
69465: LD_INT 2
69467: NEG
69468: PUSH
69469: EMPTY
69470: LIST
69471: LIST
69472: PUSH
69473: LD_INT 0
69475: PUSH
69476: LD_INT 2
69478: NEG
69479: PUSH
69480: EMPTY
69481: LIST
69482: LIST
69483: PUSH
69484: LD_INT 1
69486: PUSH
69487: LD_INT 1
69489: NEG
69490: PUSH
69491: EMPTY
69492: LIST
69493: LIST
69494: PUSH
69495: LD_INT 2
69497: PUSH
69498: LD_INT 0
69500: PUSH
69501: EMPTY
69502: LIST
69503: LIST
69504: PUSH
69505: LD_INT 2
69507: PUSH
69508: LD_INT 1
69510: PUSH
69511: EMPTY
69512: LIST
69513: LIST
69514: PUSH
69515: LD_INT 2
69517: PUSH
69518: LD_INT 2
69520: PUSH
69521: EMPTY
69522: LIST
69523: LIST
69524: PUSH
69525: LD_INT 1
69527: PUSH
69528: LD_INT 2
69530: PUSH
69531: EMPTY
69532: LIST
69533: LIST
69534: PUSH
69535: LD_INT 0
69537: PUSH
69538: LD_INT 2
69540: PUSH
69541: EMPTY
69542: LIST
69543: LIST
69544: PUSH
69545: LD_INT 1
69547: NEG
69548: PUSH
69549: LD_INT 1
69551: PUSH
69552: EMPTY
69553: LIST
69554: LIST
69555: PUSH
69556: LD_INT 2
69558: NEG
69559: PUSH
69560: LD_INT 0
69562: PUSH
69563: EMPTY
69564: LIST
69565: LIST
69566: PUSH
69567: LD_INT 2
69569: NEG
69570: PUSH
69571: LD_INT 1
69573: NEG
69574: PUSH
69575: EMPTY
69576: LIST
69577: LIST
69578: PUSH
69579: LD_INT 2
69581: NEG
69582: PUSH
69583: LD_INT 2
69585: NEG
69586: PUSH
69587: EMPTY
69588: LIST
69589: LIST
69590: PUSH
69591: LD_INT 1
69593: PUSH
69594: LD_INT 2
69596: NEG
69597: PUSH
69598: EMPTY
69599: LIST
69600: LIST
69601: PUSH
69602: LD_INT 2
69604: PUSH
69605: LD_INT 1
69607: NEG
69608: PUSH
69609: EMPTY
69610: LIST
69611: LIST
69612: PUSH
69613: LD_INT 3
69615: PUSH
69616: LD_INT 1
69618: PUSH
69619: EMPTY
69620: LIST
69621: LIST
69622: PUSH
69623: LD_INT 3
69625: PUSH
69626: LD_INT 2
69628: PUSH
69629: EMPTY
69630: LIST
69631: LIST
69632: PUSH
69633: EMPTY
69634: LIST
69635: LIST
69636: LIST
69637: LIST
69638: LIST
69639: LIST
69640: LIST
69641: LIST
69642: LIST
69643: LIST
69644: LIST
69645: LIST
69646: LIST
69647: LIST
69648: LIST
69649: LIST
69650: LIST
69651: LIST
69652: LIST
69653: LIST
69654: LIST
69655: LIST
69656: LIST
69657: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
69658: LD_ADDR_VAR 0 25
69662: PUSH
69663: LD_INT 0
69665: PUSH
69666: LD_INT 0
69668: PUSH
69669: EMPTY
69670: LIST
69671: LIST
69672: PUSH
69673: LD_INT 0
69675: PUSH
69676: LD_INT 1
69678: NEG
69679: PUSH
69680: EMPTY
69681: LIST
69682: LIST
69683: PUSH
69684: LD_INT 1
69686: PUSH
69687: LD_INT 0
69689: PUSH
69690: EMPTY
69691: LIST
69692: LIST
69693: PUSH
69694: LD_INT 1
69696: PUSH
69697: LD_INT 1
69699: PUSH
69700: EMPTY
69701: LIST
69702: LIST
69703: PUSH
69704: LD_INT 0
69706: PUSH
69707: LD_INT 1
69709: PUSH
69710: EMPTY
69711: LIST
69712: LIST
69713: PUSH
69714: LD_INT 1
69716: NEG
69717: PUSH
69718: LD_INT 0
69720: PUSH
69721: EMPTY
69722: LIST
69723: LIST
69724: PUSH
69725: LD_INT 1
69727: NEG
69728: PUSH
69729: LD_INT 1
69731: NEG
69732: PUSH
69733: EMPTY
69734: LIST
69735: LIST
69736: PUSH
69737: LD_INT 1
69739: NEG
69740: PUSH
69741: LD_INT 2
69743: NEG
69744: PUSH
69745: EMPTY
69746: LIST
69747: LIST
69748: PUSH
69749: LD_INT 0
69751: PUSH
69752: LD_INT 2
69754: NEG
69755: PUSH
69756: EMPTY
69757: LIST
69758: LIST
69759: PUSH
69760: LD_INT 1
69762: PUSH
69763: LD_INT 1
69765: NEG
69766: PUSH
69767: EMPTY
69768: LIST
69769: LIST
69770: PUSH
69771: LD_INT 2
69773: PUSH
69774: LD_INT 0
69776: PUSH
69777: EMPTY
69778: LIST
69779: LIST
69780: PUSH
69781: LD_INT 2
69783: PUSH
69784: LD_INT 1
69786: PUSH
69787: EMPTY
69788: LIST
69789: LIST
69790: PUSH
69791: LD_INT 2
69793: PUSH
69794: LD_INT 2
69796: PUSH
69797: EMPTY
69798: LIST
69799: LIST
69800: PUSH
69801: LD_INT 1
69803: PUSH
69804: LD_INT 2
69806: PUSH
69807: EMPTY
69808: LIST
69809: LIST
69810: PUSH
69811: LD_INT 0
69813: PUSH
69814: LD_INT 2
69816: PUSH
69817: EMPTY
69818: LIST
69819: LIST
69820: PUSH
69821: LD_INT 1
69823: NEG
69824: PUSH
69825: LD_INT 1
69827: PUSH
69828: EMPTY
69829: LIST
69830: LIST
69831: PUSH
69832: LD_INT 2
69834: NEG
69835: PUSH
69836: LD_INT 0
69838: PUSH
69839: EMPTY
69840: LIST
69841: LIST
69842: PUSH
69843: LD_INT 2
69845: NEG
69846: PUSH
69847: LD_INT 1
69849: NEG
69850: PUSH
69851: EMPTY
69852: LIST
69853: LIST
69854: PUSH
69855: LD_INT 2
69857: NEG
69858: PUSH
69859: LD_INT 2
69861: NEG
69862: PUSH
69863: EMPTY
69864: LIST
69865: LIST
69866: PUSH
69867: LD_INT 3
69869: PUSH
69870: LD_INT 1
69872: PUSH
69873: EMPTY
69874: LIST
69875: LIST
69876: PUSH
69877: LD_INT 3
69879: PUSH
69880: LD_INT 2
69882: PUSH
69883: EMPTY
69884: LIST
69885: LIST
69886: PUSH
69887: LD_INT 2
69889: PUSH
69890: LD_INT 3
69892: PUSH
69893: EMPTY
69894: LIST
69895: LIST
69896: PUSH
69897: LD_INT 1
69899: PUSH
69900: LD_INT 3
69902: PUSH
69903: EMPTY
69904: LIST
69905: LIST
69906: PUSH
69907: EMPTY
69908: LIST
69909: LIST
69910: LIST
69911: LIST
69912: LIST
69913: LIST
69914: LIST
69915: LIST
69916: LIST
69917: LIST
69918: LIST
69919: LIST
69920: LIST
69921: LIST
69922: LIST
69923: LIST
69924: LIST
69925: LIST
69926: LIST
69927: LIST
69928: LIST
69929: LIST
69930: LIST
69931: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
69932: LD_ADDR_VAR 0 26
69936: PUSH
69937: LD_INT 0
69939: PUSH
69940: LD_INT 0
69942: PUSH
69943: EMPTY
69944: LIST
69945: LIST
69946: PUSH
69947: LD_INT 0
69949: PUSH
69950: LD_INT 1
69952: NEG
69953: PUSH
69954: EMPTY
69955: LIST
69956: LIST
69957: PUSH
69958: LD_INT 1
69960: PUSH
69961: LD_INT 0
69963: PUSH
69964: EMPTY
69965: LIST
69966: LIST
69967: PUSH
69968: LD_INT 1
69970: PUSH
69971: LD_INT 1
69973: PUSH
69974: EMPTY
69975: LIST
69976: LIST
69977: PUSH
69978: LD_INT 0
69980: PUSH
69981: LD_INT 1
69983: PUSH
69984: EMPTY
69985: LIST
69986: LIST
69987: PUSH
69988: LD_INT 1
69990: NEG
69991: PUSH
69992: LD_INT 0
69994: PUSH
69995: EMPTY
69996: LIST
69997: LIST
69998: PUSH
69999: LD_INT 1
70001: NEG
70002: PUSH
70003: LD_INT 1
70005: NEG
70006: PUSH
70007: EMPTY
70008: LIST
70009: LIST
70010: PUSH
70011: LD_INT 1
70013: NEG
70014: PUSH
70015: LD_INT 2
70017: NEG
70018: PUSH
70019: EMPTY
70020: LIST
70021: LIST
70022: PUSH
70023: LD_INT 0
70025: PUSH
70026: LD_INT 2
70028: NEG
70029: PUSH
70030: EMPTY
70031: LIST
70032: LIST
70033: PUSH
70034: LD_INT 1
70036: PUSH
70037: LD_INT 1
70039: NEG
70040: PUSH
70041: EMPTY
70042: LIST
70043: LIST
70044: PUSH
70045: LD_INT 2
70047: PUSH
70048: LD_INT 0
70050: PUSH
70051: EMPTY
70052: LIST
70053: LIST
70054: PUSH
70055: LD_INT 2
70057: PUSH
70058: LD_INT 1
70060: PUSH
70061: EMPTY
70062: LIST
70063: LIST
70064: PUSH
70065: LD_INT 2
70067: PUSH
70068: LD_INT 2
70070: PUSH
70071: EMPTY
70072: LIST
70073: LIST
70074: PUSH
70075: LD_INT 1
70077: PUSH
70078: LD_INT 2
70080: PUSH
70081: EMPTY
70082: LIST
70083: LIST
70084: PUSH
70085: LD_INT 0
70087: PUSH
70088: LD_INT 2
70090: PUSH
70091: EMPTY
70092: LIST
70093: LIST
70094: PUSH
70095: LD_INT 1
70097: NEG
70098: PUSH
70099: LD_INT 1
70101: PUSH
70102: EMPTY
70103: LIST
70104: LIST
70105: PUSH
70106: LD_INT 2
70108: NEG
70109: PUSH
70110: LD_INT 0
70112: PUSH
70113: EMPTY
70114: LIST
70115: LIST
70116: PUSH
70117: LD_INT 2
70119: NEG
70120: PUSH
70121: LD_INT 1
70123: NEG
70124: PUSH
70125: EMPTY
70126: LIST
70127: LIST
70128: PUSH
70129: LD_INT 2
70131: NEG
70132: PUSH
70133: LD_INT 2
70135: NEG
70136: PUSH
70137: EMPTY
70138: LIST
70139: LIST
70140: PUSH
70141: LD_INT 2
70143: PUSH
70144: LD_INT 3
70146: PUSH
70147: EMPTY
70148: LIST
70149: LIST
70150: PUSH
70151: LD_INT 1
70153: PUSH
70154: LD_INT 3
70156: PUSH
70157: EMPTY
70158: LIST
70159: LIST
70160: PUSH
70161: LD_INT 1
70163: NEG
70164: PUSH
70165: LD_INT 2
70167: PUSH
70168: EMPTY
70169: LIST
70170: LIST
70171: PUSH
70172: LD_INT 2
70174: NEG
70175: PUSH
70176: LD_INT 1
70178: PUSH
70179: EMPTY
70180: LIST
70181: LIST
70182: PUSH
70183: EMPTY
70184: LIST
70185: LIST
70186: LIST
70187: LIST
70188: LIST
70189: LIST
70190: LIST
70191: LIST
70192: LIST
70193: LIST
70194: LIST
70195: LIST
70196: LIST
70197: LIST
70198: LIST
70199: LIST
70200: LIST
70201: LIST
70202: LIST
70203: LIST
70204: LIST
70205: LIST
70206: LIST
70207: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
70208: LD_ADDR_VAR 0 27
70212: PUSH
70213: LD_INT 0
70215: PUSH
70216: LD_INT 0
70218: PUSH
70219: EMPTY
70220: LIST
70221: LIST
70222: PUSH
70223: LD_INT 0
70225: PUSH
70226: LD_INT 1
70228: NEG
70229: PUSH
70230: EMPTY
70231: LIST
70232: LIST
70233: PUSH
70234: LD_INT 1
70236: PUSH
70237: LD_INT 0
70239: PUSH
70240: EMPTY
70241: LIST
70242: LIST
70243: PUSH
70244: LD_INT 1
70246: PUSH
70247: LD_INT 1
70249: PUSH
70250: EMPTY
70251: LIST
70252: LIST
70253: PUSH
70254: LD_INT 0
70256: PUSH
70257: LD_INT 1
70259: PUSH
70260: EMPTY
70261: LIST
70262: LIST
70263: PUSH
70264: LD_INT 1
70266: NEG
70267: PUSH
70268: LD_INT 0
70270: PUSH
70271: EMPTY
70272: LIST
70273: LIST
70274: PUSH
70275: LD_INT 1
70277: NEG
70278: PUSH
70279: LD_INT 1
70281: NEG
70282: PUSH
70283: EMPTY
70284: LIST
70285: LIST
70286: PUSH
70287: LD_INT 1
70289: NEG
70290: PUSH
70291: LD_INT 2
70293: NEG
70294: PUSH
70295: EMPTY
70296: LIST
70297: LIST
70298: PUSH
70299: LD_INT 0
70301: PUSH
70302: LD_INT 2
70304: NEG
70305: PUSH
70306: EMPTY
70307: LIST
70308: LIST
70309: PUSH
70310: LD_INT 1
70312: PUSH
70313: LD_INT 1
70315: NEG
70316: PUSH
70317: EMPTY
70318: LIST
70319: LIST
70320: PUSH
70321: LD_INT 2
70323: PUSH
70324: LD_INT 0
70326: PUSH
70327: EMPTY
70328: LIST
70329: LIST
70330: PUSH
70331: LD_INT 2
70333: PUSH
70334: LD_INT 1
70336: PUSH
70337: EMPTY
70338: LIST
70339: LIST
70340: PUSH
70341: LD_INT 2
70343: PUSH
70344: LD_INT 2
70346: PUSH
70347: EMPTY
70348: LIST
70349: LIST
70350: PUSH
70351: LD_INT 1
70353: PUSH
70354: LD_INT 2
70356: PUSH
70357: EMPTY
70358: LIST
70359: LIST
70360: PUSH
70361: LD_INT 0
70363: PUSH
70364: LD_INT 2
70366: PUSH
70367: EMPTY
70368: LIST
70369: LIST
70370: PUSH
70371: LD_INT 1
70373: NEG
70374: PUSH
70375: LD_INT 1
70377: PUSH
70378: EMPTY
70379: LIST
70380: LIST
70381: PUSH
70382: LD_INT 2
70384: NEG
70385: PUSH
70386: LD_INT 0
70388: PUSH
70389: EMPTY
70390: LIST
70391: LIST
70392: PUSH
70393: LD_INT 2
70395: NEG
70396: PUSH
70397: LD_INT 1
70399: NEG
70400: PUSH
70401: EMPTY
70402: LIST
70403: LIST
70404: PUSH
70405: LD_INT 2
70407: NEG
70408: PUSH
70409: LD_INT 2
70411: NEG
70412: PUSH
70413: EMPTY
70414: LIST
70415: LIST
70416: PUSH
70417: LD_INT 1
70419: NEG
70420: PUSH
70421: LD_INT 2
70423: PUSH
70424: EMPTY
70425: LIST
70426: LIST
70427: PUSH
70428: LD_INT 2
70430: NEG
70431: PUSH
70432: LD_INT 1
70434: PUSH
70435: EMPTY
70436: LIST
70437: LIST
70438: PUSH
70439: LD_INT 3
70441: NEG
70442: PUSH
70443: LD_INT 1
70445: NEG
70446: PUSH
70447: EMPTY
70448: LIST
70449: LIST
70450: PUSH
70451: LD_INT 3
70453: NEG
70454: PUSH
70455: LD_INT 2
70457: NEG
70458: PUSH
70459: EMPTY
70460: LIST
70461: LIST
70462: PUSH
70463: EMPTY
70464: LIST
70465: LIST
70466: LIST
70467: LIST
70468: LIST
70469: LIST
70470: LIST
70471: LIST
70472: LIST
70473: LIST
70474: LIST
70475: LIST
70476: LIST
70477: LIST
70478: LIST
70479: LIST
70480: LIST
70481: LIST
70482: LIST
70483: LIST
70484: LIST
70485: LIST
70486: LIST
70487: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
70488: LD_ADDR_VAR 0 28
70492: PUSH
70493: LD_INT 0
70495: PUSH
70496: LD_INT 0
70498: PUSH
70499: EMPTY
70500: LIST
70501: LIST
70502: PUSH
70503: LD_INT 0
70505: PUSH
70506: LD_INT 1
70508: NEG
70509: PUSH
70510: EMPTY
70511: LIST
70512: LIST
70513: PUSH
70514: LD_INT 1
70516: PUSH
70517: LD_INT 0
70519: PUSH
70520: EMPTY
70521: LIST
70522: LIST
70523: PUSH
70524: LD_INT 1
70526: PUSH
70527: LD_INT 1
70529: PUSH
70530: EMPTY
70531: LIST
70532: LIST
70533: PUSH
70534: LD_INT 0
70536: PUSH
70537: LD_INT 1
70539: PUSH
70540: EMPTY
70541: LIST
70542: LIST
70543: PUSH
70544: LD_INT 1
70546: NEG
70547: PUSH
70548: LD_INT 0
70550: PUSH
70551: EMPTY
70552: LIST
70553: LIST
70554: PUSH
70555: LD_INT 1
70557: NEG
70558: PUSH
70559: LD_INT 1
70561: NEG
70562: PUSH
70563: EMPTY
70564: LIST
70565: LIST
70566: PUSH
70567: LD_INT 1
70569: NEG
70570: PUSH
70571: LD_INT 2
70573: NEG
70574: PUSH
70575: EMPTY
70576: LIST
70577: LIST
70578: PUSH
70579: LD_INT 0
70581: PUSH
70582: LD_INT 2
70584: NEG
70585: PUSH
70586: EMPTY
70587: LIST
70588: LIST
70589: PUSH
70590: LD_INT 1
70592: PUSH
70593: LD_INT 1
70595: NEG
70596: PUSH
70597: EMPTY
70598: LIST
70599: LIST
70600: PUSH
70601: LD_INT 2
70603: PUSH
70604: LD_INT 0
70606: PUSH
70607: EMPTY
70608: LIST
70609: LIST
70610: PUSH
70611: LD_INT 2
70613: PUSH
70614: LD_INT 1
70616: PUSH
70617: EMPTY
70618: LIST
70619: LIST
70620: PUSH
70621: LD_INT 2
70623: PUSH
70624: LD_INT 2
70626: PUSH
70627: EMPTY
70628: LIST
70629: LIST
70630: PUSH
70631: LD_INT 1
70633: PUSH
70634: LD_INT 2
70636: PUSH
70637: EMPTY
70638: LIST
70639: LIST
70640: PUSH
70641: LD_INT 0
70643: PUSH
70644: LD_INT 2
70646: PUSH
70647: EMPTY
70648: LIST
70649: LIST
70650: PUSH
70651: LD_INT 1
70653: NEG
70654: PUSH
70655: LD_INT 1
70657: PUSH
70658: EMPTY
70659: LIST
70660: LIST
70661: PUSH
70662: LD_INT 2
70664: NEG
70665: PUSH
70666: LD_INT 0
70668: PUSH
70669: EMPTY
70670: LIST
70671: LIST
70672: PUSH
70673: LD_INT 2
70675: NEG
70676: PUSH
70677: LD_INT 1
70679: NEG
70680: PUSH
70681: EMPTY
70682: LIST
70683: LIST
70684: PUSH
70685: LD_INT 2
70687: NEG
70688: PUSH
70689: LD_INT 2
70691: NEG
70692: PUSH
70693: EMPTY
70694: LIST
70695: LIST
70696: PUSH
70697: LD_INT 2
70699: NEG
70700: PUSH
70701: LD_INT 3
70703: NEG
70704: PUSH
70705: EMPTY
70706: LIST
70707: LIST
70708: PUSH
70709: LD_INT 1
70711: NEG
70712: PUSH
70713: LD_INT 3
70715: NEG
70716: PUSH
70717: EMPTY
70718: LIST
70719: LIST
70720: PUSH
70721: LD_INT 3
70723: NEG
70724: PUSH
70725: LD_INT 1
70727: NEG
70728: PUSH
70729: EMPTY
70730: LIST
70731: LIST
70732: PUSH
70733: LD_INT 3
70735: NEG
70736: PUSH
70737: LD_INT 2
70739: NEG
70740: PUSH
70741: EMPTY
70742: LIST
70743: LIST
70744: PUSH
70745: EMPTY
70746: LIST
70747: LIST
70748: LIST
70749: LIST
70750: LIST
70751: LIST
70752: LIST
70753: LIST
70754: LIST
70755: LIST
70756: LIST
70757: LIST
70758: LIST
70759: LIST
70760: LIST
70761: LIST
70762: LIST
70763: LIST
70764: LIST
70765: LIST
70766: LIST
70767: LIST
70768: LIST
70769: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70770: LD_ADDR_VAR 0 29
70774: PUSH
70775: LD_INT 0
70777: PUSH
70778: LD_INT 0
70780: PUSH
70781: EMPTY
70782: LIST
70783: LIST
70784: PUSH
70785: LD_INT 0
70787: PUSH
70788: LD_INT 1
70790: NEG
70791: PUSH
70792: EMPTY
70793: LIST
70794: LIST
70795: PUSH
70796: LD_INT 1
70798: PUSH
70799: LD_INT 0
70801: PUSH
70802: EMPTY
70803: LIST
70804: LIST
70805: PUSH
70806: LD_INT 1
70808: PUSH
70809: LD_INT 1
70811: PUSH
70812: EMPTY
70813: LIST
70814: LIST
70815: PUSH
70816: LD_INT 0
70818: PUSH
70819: LD_INT 1
70821: PUSH
70822: EMPTY
70823: LIST
70824: LIST
70825: PUSH
70826: LD_INT 1
70828: NEG
70829: PUSH
70830: LD_INT 0
70832: PUSH
70833: EMPTY
70834: LIST
70835: LIST
70836: PUSH
70837: LD_INT 1
70839: NEG
70840: PUSH
70841: LD_INT 1
70843: NEG
70844: PUSH
70845: EMPTY
70846: LIST
70847: LIST
70848: PUSH
70849: LD_INT 1
70851: NEG
70852: PUSH
70853: LD_INT 2
70855: NEG
70856: PUSH
70857: EMPTY
70858: LIST
70859: LIST
70860: PUSH
70861: LD_INT 0
70863: PUSH
70864: LD_INT 2
70866: NEG
70867: PUSH
70868: EMPTY
70869: LIST
70870: LIST
70871: PUSH
70872: LD_INT 1
70874: PUSH
70875: LD_INT 1
70877: NEG
70878: PUSH
70879: EMPTY
70880: LIST
70881: LIST
70882: PUSH
70883: LD_INT 2
70885: PUSH
70886: LD_INT 0
70888: PUSH
70889: EMPTY
70890: LIST
70891: LIST
70892: PUSH
70893: LD_INT 2
70895: PUSH
70896: LD_INT 1
70898: PUSH
70899: EMPTY
70900: LIST
70901: LIST
70902: PUSH
70903: LD_INT 1
70905: PUSH
70906: LD_INT 2
70908: PUSH
70909: EMPTY
70910: LIST
70911: LIST
70912: PUSH
70913: LD_INT 0
70915: PUSH
70916: LD_INT 2
70918: PUSH
70919: EMPTY
70920: LIST
70921: LIST
70922: PUSH
70923: LD_INT 1
70925: NEG
70926: PUSH
70927: LD_INT 1
70929: PUSH
70930: EMPTY
70931: LIST
70932: LIST
70933: PUSH
70934: LD_INT 2
70936: NEG
70937: PUSH
70938: LD_INT 1
70940: NEG
70941: PUSH
70942: EMPTY
70943: LIST
70944: LIST
70945: PUSH
70946: LD_INT 2
70948: NEG
70949: PUSH
70950: LD_INT 2
70952: NEG
70953: PUSH
70954: EMPTY
70955: LIST
70956: LIST
70957: PUSH
70958: LD_INT 2
70960: NEG
70961: PUSH
70962: LD_INT 3
70964: NEG
70965: PUSH
70966: EMPTY
70967: LIST
70968: LIST
70969: PUSH
70970: LD_INT 2
70972: PUSH
70973: LD_INT 1
70975: NEG
70976: PUSH
70977: EMPTY
70978: LIST
70979: LIST
70980: PUSH
70981: LD_INT 3
70983: PUSH
70984: LD_INT 1
70986: PUSH
70987: EMPTY
70988: LIST
70989: LIST
70990: PUSH
70991: LD_INT 1
70993: PUSH
70994: LD_INT 3
70996: PUSH
70997: EMPTY
70998: LIST
70999: LIST
71000: PUSH
71001: LD_INT 1
71003: NEG
71004: PUSH
71005: LD_INT 2
71007: PUSH
71008: EMPTY
71009: LIST
71010: LIST
71011: PUSH
71012: LD_INT 3
71014: NEG
71015: PUSH
71016: LD_INT 2
71018: NEG
71019: PUSH
71020: EMPTY
71021: LIST
71022: LIST
71023: PUSH
71024: EMPTY
71025: LIST
71026: LIST
71027: LIST
71028: LIST
71029: LIST
71030: LIST
71031: LIST
71032: LIST
71033: LIST
71034: LIST
71035: LIST
71036: LIST
71037: LIST
71038: LIST
71039: LIST
71040: LIST
71041: LIST
71042: LIST
71043: LIST
71044: LIST
71045: LIST
71046: LIST
71047: LIST
71048: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71049: LD_ADDR_VAR 0 30
71053: PUSH
71054: LD_INT 0
71056: PUSH
71057: LD_INT 0
71059: PUSH
71060: EMPTY
71061: LIST
71062: LIST
71063: PUSH
71064: LD_INT 0
71066: PUSH
71067: LD_INT 1
71069: NEG
71070: PUSH
71071: EMPTY
71072: LIST
71073: LIST
71074: PUSH
71075: LD_INT 1
71077: PUSH
71078: LD_INT 0
71080: PUSH
71081: EMPTY
71082: LIST
71083: LIST
71084: PUSH
71085: LD_INT 1
71087: PUSH
71088: LD_INT 1
71090: PUSH
71091: EMPTY
71092: LIST
71093: LIST
71094: PUSH
71095: LD_INT 0
71097: PUSH
71098: LD_INT 1
71100: PUSH
71101: EMPTY
71102: LIST
71103: LIST
71104: PUSH
71105: LD_INT 1
71107: NEG
71108: PUSH
71109: LD_INT 0
71111: PUSH
71112: EMPTY
71113: LIST
71114: LIST
71115: PUSH
71116: LD_INT 1
71118: NEG
71119: PUSH
71120: LD_INT 1
71122: NEG
71123: PUSH
71124: EMPTY
71125: LIST
71126: LIST
71127: PUSH
71128: LD_INT 1
71130: NEG
71131: PUSH
71132: LD_INT 2
71134: NEG
71135: PUSH
71136: EMPTY
71137: LIST
71138: LIST
71139: PUSH
71140: LD_INT 0
71142: PUSH
71143: LD_INT 2
71145: NEG
71146: PUSH
71147: EMPTY
71148: LIST
71149: LIST
71150: PUSH
71151: LD_INT 1
71153: PUSH
71154: LD_INT 1
71156: NEG
71157: PUSH
71158: EMPTY
71159: LIST
71160: LIST
71161: PUSH
71162: LD_INT 2
71164: PUSH
71165: LD_INT 0
71167: PUSH
71168: EMPTY
71169: LIST
71170: LIST
71171: PUSH
71172: LD_INT 2
71174: PUSH
71175: LD_INT 1
71177: PUSH
71178: EMPTY
71179: LIST
71180: LIST
71181: PUSH
71182: LD_INT 2
71184: PUSH
71185: LD_INT 2
71187: PUSH
71188: EMPTY
71189: LIST
71190: LIST
71191: PUSH
71192: LD_INT 1
71194: PUSH
71195: LD_INT 2
71197: PUSH
71198: EMPTY
71199: LIST
71200: LIST
71201: PUSH
71202: LD_INT 1
71204: NEG
71205: PUSH
71206: LD_INT 1
71208: PUSH
71209: EMPTY
71210: LIST
71211: LIST
71212: PUSH
71213: LD_INT 2
71215: NEG
71216: PUSH
71217: LD_INT 0
71219: PUSH
71220: EMPTY
71221: LIST
71222: LIST
71223: PUSH
71224: LD_INT 2
71226: NEG
71227: PUSH
71228: LD_INT 1
71230: NEG
71231: PUSH
71232: EMPTY
71233: LIST
71234: LIST
71235: PUSH
71236: LD_INT 1
71238: NEG
71239: PUSH
71240: LD_INT 3
71242: NEG
71243: PUSH
71244: EMPTY
71245: LIST
71246: LIST
71247: PUSH
71248: LD_INT 1
71250: PUSH
71251: LD_INT 2
71253: NEG
71254: PUSH
71255: EMPTY
71256: LIST
71257: LIST
71258: PUSH
71259: LD_INT 3
71261: PUSH
71262: LD_INT 2
71264: PUSH
71265: EMPTY
71266: LIST
71267: LIST
71268: PUSH
71269: LD_INT 2
71271: PUSH
71272: LD_INT 3
71274: PUSH
71275: EMPTY
71276: LIST
71277: LIST
71278: PUSH
71279: LD_INT 2
71281: NEG
71282: PUSH
71283: LD_INT 1
71285: PUSH
71286: EMPTY
71287: LIST
71288: LIST
71289: PUSH
71290: LD_INT 3
71292: NEG
71293: PUSH
71294: LD_INT 1
71296: NEG
71297: PUSH
71298: EMPTY
71299: LIST
71300: LIST
71301: PUSH
71302: EMPTY
71303: LIST
71304: LIST
71305: LIST
71306: LIST
71307: LIST
71308: LIST
71309: LIST
71310: LIST
71311: LIST
71312: LIST
71313: LIST
71314: LIST
71315: LIST
71316: LIST
71317: LIST
71318: LIST
71319: LIST
71320: LIST
71321: LIST
71322: LIST
71323: LIST
71324: LIST
71325: LIST
71326: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71327: LD_ADDR_VAR 0 31
71331: PUSH
71332: LD_INT 0
71334: PUSH
71335: LD_INT 0
71337: PUSH
71338: EMPTY
71339: LIST
71340: LIST
71341: PUSH
71342: LD_INT 0
71344: PUSH
71345: LD_INT 1
71347: NEG
71348: PUSH
71349: EMPTY
71350: LIST
71351: LIST
71352: PUSH
71353: LD_INT 1
71355: PUSH
71356: LD_INT 0
71358: PUSH
71359: EMPTY
71360: LIST
71361: LIST
71362: PUSH
71363: LD_INT 1
71365: PUSH
71366: LD_INT 1
71368: PUSH
71369: EMPTY
71370: LIST
71371: LIST
71372: PUSH
71373: LD_INT 0
71375: PUSH
71376: LD_INT 1
71378: PUSH
71379: EMPTY
71380: LIST
71381: LIST
71382: PUSH
71383: LD_INT 1
71385: NEG
71386: PUSH
71387: LD_INT 0
71389: PUSH
71390: EMPTY
71391: LIST
71392: LIST
71393: PUSH
71394: LD_INT 1
71396: NEG
71397: PUSH
71398: LD_INT 1
71400: NEG
71401: PUSH
71402: EMPTY
71403: LIST
71404: LIST
71405: PUSH
71406: LD_INT 1
71408: NEG
71409: PUSH
71410: LD_INT 2
71412: NEG
71413: PUSH
71414: EMPTY
71415: LIST
71416: LIST
71417: PUSH
71418: LD_INT 1
71420: PUSH
71421: LD_INT 1
71423: NEG
71424: PUSH
71425: EMPTY
71426: LIST
71427: LIST
71428: PUSH
71429: LD_INT 2
71431: PUSH
71432: LD_INT 0
71434: PUSH
71435: EMPTY
71436: LIST
71437: LIST
71438: PUSH
71439: LD_INT 2
71441: PUSH
71442: LD_INT 1
71444: PUSH
71445: EMPTY
71446: LIST
71447: LIST
71448: PUSH
71449: LD_INT 2
71451: PUSH
71452: LD_INT 2
71454: PUSH
71455: EMPTY
71456: LIST
71457: LIST
71458: PUSH
71459: LD_INT 1
71461: PUSH
71462: LD_INT 2
71464: PUSH
71465: EMPTY
71466: LIST
71467: LIST
71468: PUSH
71469: LD_INT 0
71471: PUSH
71472: LD_INT 2
71474: PUSH
71475: EMPTY
71476: LIST
71477: LIST
71478: PUSH
71479: LD_INT 1
71481: NEG
71482: PUSH
71483: LD_INT 1
71485: PUSH
71486: EMPTY
71487: LIST
71488: LIST
71489: PUSH
71490: LD_INT 2
71492: NEG
71493: PUSH
71494: LD_INT 1
71496: NEG
71497: PUSH
71498: EMPTY
71499: LIST
71500: LIST
71501: PUSH
71502: LD_INT 2
71504: NEG
71505: PUSH
71506: LD_INT 2
71508: NEG
71509: PUSH
71510: EMPTY
71511: LIST
71512: LIST
71513: PUSH
71514: LD_INT 2
71516: NEG
71517: PUSH
71518: LD_INT 3
71520: NEG
71521: PUSH
71522: EMPTY
71523: LIST
71524: LIST
71525: PUSH
71526: LD_INT 2
71528: PUSH
71529: LD_INT 1
71531: NEG
71532: PUSH
71533: EMPTY
71534: LIST
71535: LIST
71536: PUSH
71537: LD_INT 3
71539: PUSH
71540: LD_INT 1
71542: PUSH
71543: EMPTY
71544: LIST
71545: LIST
71546: PUSH
71547: LD_INT 1
71549: PUSH
71550: LD_INT 3
71552: PUSH
71553: EMPTY
71554: LIST
71555: LIST
71556: PUSH
71557: LD_INT 1
71559: NEG
71560: PUSH
71561: LD_INT 2
71563: PUSH
71564: EMPTY
71565: LIST
71566: LIST
71567: PUSH
71568: LD_INT 3
71570: NEG
71571: PUSH
71572: LD_INT 2
71574: NEG
71575: PUSH
71576: EMPTY
71577: LIST
71578: LIST
71579: PUSH
71580: EMPTY
71581: LIST
71582: LIST
71583: LIST
71584: LIST
71585: LIST
71586: LIST
71587: LIST
71588: LIST
71589: LIST
71590: LIST
71591: LIST
71592: LIST
71593: LIST
71594: LIST
71595: LIST
71596: LIST
71597: LIST
71598: LIST
71599: LIST
71600: LIST
71601: LIST
71602: LIST
71603: LIST
71604: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71605: LD_ADDR_VAR 0 32
71609: PUSH
71610: LD_INT 0
71612: PUSH
71613: LD_INT 0
71615: PUSH
71616: EMPTY
71617: LIST
71618: LIST
71619: PUSH
71620: LD_INT 0
71622: PUSH
71623: LD_INT 1
71625: NEG
71626: PUSH
71627: EMPTY
71628: LIST
71629: LIST
71630: PUSH
71631: LD_INT 1
71633: PUSH
71634: LD_INT 0
71636: PUSH
71637: EMPTY
71638: LIST
71639: LIST
71640: PUSH
71641: LD_INT 1
71643: PUSH
71644: LD_INT 1
71646: PUSH
71647: EMPTY
71648: LIST
71649: LIST
71650: PUSH
71651: LD_INT 0
71653: PUSH
71654: LD_INT 1
71656: PUSH
71657: EMPTY
71658: LIST
71659: LIST
71660: PUSH
71661: LD_INT 1
71663: NEG
71664: PUSH
71665: LD_INT 0
71667: PUSH
71668: EMPTY
71669: LIST
71670: LIST
71671: PUSH
71672: LD_INT 1
71674: NEG
71675: PUSH
71676: LD_INT 1
71678: NEG
71679: PUSH
71680: EMPTY
71681: LIST
71682: LIST
71683: PUSH
71684: LD_INT 1
71686: NEG
71687: PUSH
71688: LD_INT 2
71690: NEG
71691: PUSH
71692: EMPTY
71693: LIST
71694: LIST
71695: PUSH
71696: LD_INT 0
71698: PUSH
71699: LD_INT 2
71701: NEG
71702: PUSH
71703: EMPTY
71704: LIST
71705: LIST
71706: PUSH
71707: LD_INT 1
71709: PUSH
71710: LD_INT 1
71712: NEG
71713: PUSH
71714: EMPTY
71715: LIST
71716: LIST
71717: PUSH
71718: LD_INT 2
71720: PUSH
71721: LD_INT 1
71723: PUSH
71724: EMPTY
71725: LIST
71726: LIST
71727: PUSH
71728: LD_INT 2
71730: PUSH
71731: LD_INT 2
71733: PUSH
71734: EMPTY
71735: LIST
71736: LIST
71737: PUSH
71738: LD_INT 1
71740: PUSH
71741: LD_INT 2
71743: PUSH
71744: EMPTY
71745: LIST
71746: LIST
71747: PUSH
71748: LD_INT 0
71750: PUSH
71751: LD_INT 2
71753: PUSH
71754: EMPTY
71755: LIST
71756: LIST
71757: PUSH
71758: LD_INT 1
71760: NEG
71761: PUSH
71762: LD_INT 1
71764: PUSH
71765: EMPTY
71766: LIST
71767: LIST
71768: PUSH
71769: LD_INT 2
71771: NEG
71772: PUSH
71773: LD_INT 0
71775: PUSH
71776: EMPTY
71777: LIST
71778: LIST
71779: PUSH
71780: LD_INT 2
71782: NEG
71783: PUSH
71784: LD_INT 1
71786: NEG
71787: PUSH
71788: EMPTY
71789: LIST
71790: LIST
71791: PUSH
71792: LD_INT 1
71794: NEG
71795: PUSH
71796: LD_INT 3
71798: NEG
71799: PUSH
71800: EMPTY
71801: LIST
71802: LIST
71803: PUSH
71804: LD_INT 1
71806: PUSH
71807: LD_INT 2
71809: NEG
71810: PUSH
71811: EMPTY
71812: LIST
71813: LIST
71814: PUSH
71815: LD_INT 3
71817: PUSH
71818: LD_INT 2
71820: PUSH
71821: EMPTY
71822: LIST
71823: LIST
71824: PUSH
71825: LD_INT 2
71827: PUSH
71828: LD_INT 3
71830: PUSH
71831: EMPTY
71832: LIST
71833: LIST
71834: PUSH
71835: LD_INT 2
71837: NEG
71838: PUSH
71839: LD_INT 1
71841: PUSH
71842: EMPTY
71843: LIST
71844: LIST
71845: PUSH
71846: LD_INT 3
71848: NEG
71849: PUSH
71850: LD_INT 1
71852: NEG
71853: PUSH
71854: EMPTY
71855: LIST
71856: LIST
71857: PUSH
71858: EMPTY
71859: LIST
71860: LIST
71861: LIST
71862: LIST
71863: LIST
71864: LIST
71865: LIST
71866: LIST
71867: LIST
71868: LIST
71869: LIST
71870: LIST
71871: LIST
71872: LIST
71873: LIST
71874: LIST
71875: LIST
71876: LIST
71877: LIST
71878: LIST
71879: LIST
71880: LIST
71881: LIST
71882: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71883: LD_ADDR_VAR 0 33
71887: PUSH
71888: LD_INT 0
71890: PUSH
71891: LD_INT 0
71893: PUSH
71894: EMPTY
71895: LIST
71896: LIST
71897: PUSH
71898: LD_INT 0
71900: PUSH
71901: LD_INT 1
71903: NEG
71904: PUSH
71905: EMPTY
71906: LIST
71907: LIST
71908: PUSH
71909: LD_INT 1
71911: PUSH
71912: LD_INT 0
71914: PUSH
71915: EMPTY
71916: LIST
71917: LIST
71918: PUSH
71919: LD_INT 1
71921: PUSH
71922: LD_INT 1
71924: PUSH
71925: EMPTY
71926: LIST
71927: LIST
71928: PUSH
71929: LD_INT 0
71931: PUSH
71932: LD_INT 1
71934: PUSH
71935: EMPTY
71936: LIST
71937: LIST
71938: PUSH
71939: LD_INT 1
71941: NEG
71942: PUSH
71943: LD_INT 0
71945: PUSH
71946: EMPTY
71947: LIST
71948: LIST
71949: PUSH
71950: LD_INT 1
71952: NEG
71953: PUSH
71954: LD_INT 1
71956: NEG
71957: PUSH
71958: EMPTY
71959: LIST
71960: LIST
71961: PUSH
71962: LD_INT 1
71964: NEG
71965: PUSH
71966: LD_INT 2
71968: NEG
71969: PUSH
71970: EMPTY
71971: LIST
71972: LIST
71973: PUSH
71974: LD_INT 1
71976: PUSH
71977: LD_INT 1
71979: NEG
71980: PUSH
71981: EMPTY
71982: LIST
71983: LIST
71984: PUSH
71985: LD_INT 2
71987: PUSH
71988: LD_INT 0
71990: PUSH
71991: EMPTY
71992: LIST
71993: LIST
71994: PUSH
71995: LD_INT 2
71997: PUSH
71998: LD_INT 1
72000: PUSH
72001: EMPTY
72002: LIST
72003: LIST
72004: PUSH
72005: LD_INT 1
72007: PUSH
72008: LD_INT 2
72010: PUSH
72011: EMPTY
72012: LIST
72013: LIST
72014: PUSH
72015: LD_INT 0
72017: PUSH
72018: LD_INT 2
72020: PUSH
72021: EMPTY
72022: LIST
72023: LIST
72024: PUSH
72025: LD_INT 1
72027: NEG
72028: PUSH
72029: LD_INT 1
72031: PUSH
72032: EMPTY
72033: LIST
72034: LIST
72035: PUSH
72036: LD_INT 2
72038: NEG
72039: PUSH
72040: LD_INT 0
72042: PUSH
72043: EMPTY
72044: LIST
72045: LIST
72046: PUSH
72047: LD_INT 2
72049: NEG
72050: PUSH
72051: LD_INT 1
72053: NEG
72054: PUSH
72055: EMPTY
72056: LIST
72057: LIST
72058: PUSH
72059: LD_INT 2
72061: NEG
72062: PUSH
72063: LD_INT 2
72065: NEG
72066: PUSH
72067: EMPTY
72068: LIST
72069: LIST
72070: PUSH
72071: LD_INT 2
72073: NEG
72074: PUSH
72075: LD_INT 3
72077: NEG
72078: PUSH
72079: EMPTY
72080: LIST
72081: LIST
72082: PUSH
72083: LD_INT 2
72085: PUSH
72086: LD_INT 1
72088: NEG
72089: PUSH
72090: EMPTY
72091: LIST
72092: LIST
72093: PUSH
72094: LD_INT 3
72096: PUSH
72097: LD_INT 1
72099: PUSH
72100: EMPTY
72101: LIST
72102: LIST
72103: PUSH
72104: LD_INT 1
72106: PUSH
72107: LD_INT 3
72109: PUSH
72110: EMPTY
72111: LIST
72112: LIST
72113: PUSH
72114: LD_INT 1
72116: NEG
72117: PUSH
72118: LD_INT 2
72120: PUSH
72121: EMPTY
72122: LIST
72123: LIST
72124: PUSH
72125: LD_INT 3
72127: NEG
72128: PUSH
72129: LD_INT 2
72131: NEG
72132: PUSH
72133: EMPTY
72134: LIST
72135: LIST
72136: PUSH
72137: EMPTY
72138: LIST
72139: LIST
72140: LIST
72141: LIST
72142: LIST
72143: LIST
72144: LIST
72145: LIST
72146: LIST
72147: LIST
72148: LIST
72149: LIST
72150: LIST
72151: LIST
72152: LIST
72153: LIST
72154: LIST
72155: LIST
72156: LIST
72157: LIST
72158: LIST
72159: LIST
72160: LIST
72161: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
72162: LD_ADDR_VAR 0 34
72166: PUSH
72167: LD_INT 0
72169: PUSH
72170: LD_INT 0
72172: PUSH
72173: EMPTY
72174: LIST
72175: LIST
72176: PUSH
72177: LD_INT 0
72179: PUSH
72180: LD_INT 1
72182: NEG
72183: PUSH
72184: EMPTY
72185: LIST
72186: LIST
72187: PUSH
72188: LD_INT 1
72190: PUSH
72191: LD_INT 0
72193: PUSH
72194: EMPTY
72195: LIST
72196: LIST
72197: PUSH
72198: LD_INT 1
72200: PUSH
72201: LD_INT 1
72203: PUSH
72204: EMPTY
72205: LIST
72206: LIST
72207: PUSH
72208: LD_INT 0
72210: PUSH
72211: LD_INT 1
72213: PUSH
72214: EMPTY
72215: LIST
72216: LIST
72217: PUSH
72218: LD_INT 1
72220: NEG
72221: PUSH
72222: LD_INT 0
72224: PUSH
72225: EMPTY
72226: LIST
72227: LIST
72228: PUSH
72229: LD_INT 1
72231: NEG
72232: PUSH
72233: LD_INT 1
72235: NEG
72236: PUSH
72237: EMPTY
72238: LIST
72239: LIST
72240: PUSH
72241: LD_INT 1
72243: NEG
72244: PUSH
72245: LD_INT 2
72247: NEG
72248: PUSH
72249: EMPTY
72250: LIST
72251: LIST
72252: PUSH
72253: LD_INT 0
72255: PUSH
72256: LD_INT 2
72258: NEG
72259: PUSH
72260: EMPTY
72261: LIST
72262: LIST
72263: PUSH
72264: LD_INT 1
72266: PUSH
72267: LD_INT 1
72269: NEG
72270: PUSH
72271: EMPTY
72272: LIST
72273: LIST
72274: PUSH
72275: LD_INT 2
72277: PUSH
72278: LD_INT 1
72280: PUSH
72281: EMPTY
72282: LIST
72283: LIST
72284: PUSH
72285: LD_INT 2
72287: PUSH
72288: LD_INT 2
72290: PUSH
72291: EMPTY
72292: LIST
72293: LIST
72294: PUSH
72295: LD_INT 1
72297: PUSH
72298: LD_INT 2
72300: PUSH
72301: EMPTY
72302: LIST
72303: LIST
72304: PUSH
72305: LD_INT 1
72307: NEG
72308: PUSH
72309: LD_INT 1
72311: PUSH
72312: EMPTY
72313: LIST
72314: LIST
72315: PUSH
72316: LD_INT 2
72318: NEG
72319: PUSH
72320: LD_INT 0
72322: PUSH
72323: EMPTY
72324: LIST
72325: LIST
72326: PUSH
72327: LD_INT 2
72329: NEG
72330: PUSH
72331: LD_INT 1
72333: NEG
72334: PUSH
72335: EMPTY
72336: LIST
72337: LIST
72338: PUSH
72339: LD_INT 2
72341: NEG
72342: PUSH
72343: LD_INT 2
72345: NEG
72346: PUSH
72347: EMPTY
72348: LIST
72349: LIST
72350: PUSH
72351: LD_INT 1
72353: NEG
72354: PUSH
72355: LD_INT 3
72357: NEG
72358: PUSH
72359: EMPTY
72360: LIST
72361: LIST
72362: PUSH
72363: LD_INT 1
72365: PUSH
72366: LD_INT 2
72368: NEG
72369: PUSH
72370: EMPTY
72371: LIST
72372: LIST
72373: PUSH
72374: LD_INT 3
72376: PUSH
72377: LD_INT 2
72379: PUSH
72380: EMPTY
72381: LIST
72382: LIST
72383: PUSH
72384: LD_INT 2
72386: PUSH
72387: LD_INT 3
72389: PUSH
72390: EMPTY
72391: LIST
72392: LIST
72393: PUSH
72394: LD_INT 2
72396: NEG
72397: PUSH
72398: LD_INT 1
72400: PUSH
72401: EMPTY
72402: LIST
72403: LIST
72404: PUSH
72405: LD_INT 3
72407: NEG
72408: PUSH
72409: LD_INT 1
72411: NEG
72412: PUSH
72413: EMPTY
72414: LIST
72415: LIST
72416: PUSH
72417: EMPTY
72418: LIST
72419: LIST
72420: LIST
72421: LIST
72422: LIST
72423: LIST
72424: LIST
72425: LIST
72426: LIST
72427: LIST
72428: LIST
72429: LIST
72430: LIST
72431: LIST
72432: LIST
72433: LIST
72434: LIST
72435: LIST
72436: LIST
72437: LIST
72438: LIST
72439: LIST
72440: LIST
72441: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
72442: LD_ADDR_VAR 0 35
72446: PUSH
72447: LD_INT 0
72449: PUSH
72450: LD_INT 0
72452: PUSH
72453: EMPTY
72454: LIST
72455: LIST
72456: PUSH
72457: LD_INT 0
72459: PUSH
72460: LD_INT 1
72462: NEG
72463: PUSH
72464: EMPTY
72465: LIST
72466: LIST
72467: PUSH
72468: LD_INT 1
72470: PUSH
72471: LD_INT 0
72473: PUSH
72474: EMPTY
72475: LIST
72476: LIST
72477: PUSH
72478: LD_INT 1
72480: PUSH
72481: LD_INT 1
72483: PUSH
72484: EMPTY
72485: LIST
72486: LIST
72487: PUSH
72488: LD_INT 0
72490: PUSH
72491: LD_INT 1
72493: PUSH
72494: EMPTY
72495: LIST
72496: LIST
72497: PUSH
72498: LD_INT 1
72500: NEG
72501: PUSH
72502: LD_INT 0
72504: PUSH
72505: EMPTY
72506: LIST
72507: LIST
72508: PUSH
72509: LD_INT 1
72511: NEG
72512: PUSH
72513: LD_INT 1
72515: NEG
72516: PUSH
72517: EMPTY
72518: LIST
72519: LIST
72520: PUSH
72521: LD_INT 2
72523: PUSH
72524: LD_INT 1
72526: PUSH
72527: EMPTY
72528: LIST
72529: LIST
72530: PUSH
72531: LD_INT 2
72533: NEG
72534: PUSH
72535: LD_INT 1
72537: NEG
72538: PUSH
72539: EMPTY
72540: LIST
72541: LIST
72542: PUSH
72543: EMPTY
72544: LIST
72545: LIST
72546: LIST
72547: LIST
72548: LIST
72549: LIST
72550: LIST
72551: LIST
72552: LIST
72553: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72554: LD_ADDR_VAR 0 36
72558: PUSH
72559: LD_INT 0
72561: PUSH
72562: LD_INT 0
72564: PUSH
72565: EMPTY
72566: LIST
72567: LIST
72568: PUSH
72569: LD_INT 0
72571: PUSH
72572: LD_INT 1
72574: NEG
72575: PUSH
72576: EMPTY
72577: LIST
72578: LIST
72579: PUSH
72580: LD_INT 1
72582: PUSH
72583: LD_INT 0
72585: PUSH
72586: EMPTY
72587: LIST
72588: LIST
72589: PUSH
72590: LD_INT 1
72592: PUSH
72593: LD_INT 1
72595: PUSH
72596: EMPTY
72597: LIST
72598: LIST
72599: PUSH
72600: LD_INT 0
72602: PUSH
72603: LD_INT 1
72605: PUSH
72606: EMPTY
72607: LIST
72608: LIST
72609: PUSH
72610: LD_INT 1
72612: NEG
72613: PUSH
72614: LD_INT 0
72616: PUSH
72617: EMPTY
72618: LIST
72619: LIST
72620: PUSH
72621: LD_INT 1
72623: NEG
72624: PUSH
72625: LD_INT 1
72627: NEG
72628: PUSH
72629: EMPTY
72630: LIST
72631: LIST
72632: PUSH
72633: LD_INT 1
72635: NEG
72636: PUSH
72637: LD_INT 2
72639: NEG
72640: PUSH
72641: EMPTY
72642: LIST
72643: LIST
72644: PUSH
72645: LD_INT 1
72647: PUSH
72648: LD_INT 2
72650: PUSH
72651: EMPTY
72652: LIST
72653: LIST
72654: PUSH
72655: EMPTY
72656: LIST
72657: LIST
72658: LIST
72659: LIST
72660: LIST
72661: LIST
72662: LIST
72663: LIST
72664: LIST
72665: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72666: LD_ADDR_VAR 0 37
72670: PUSH
72671: LD_INT 0
72673: PUSH
72674: LD_INT 0
72676: PUSH
72677: EMPTY
72678: LIST
72679: LIST
72680: PUSH
72681: LD_INT 0
72683: PUSH
72684: LD_INT 1
72686: NEG
72687: PUSH
72688: EMPTY
72689: LIST
72690: LIST
72691: PUSH
72692: LD_INT 1
72694: PUSH
72695: LD_INT 0
72697: PUSH
72698: EMPTY
72699: LIST
72700: LIST
72701: PUSH
72702: LD_INT 1
72704: PUSH
72705: LD_INT 1
72707: PUSH
72708: EMPTY
72709: LIST
72710: LIST
72711: PUSH
72712: LD_INT 0
72714: PUSH
72715: LD_INT 1
72717: PUSH
72718: EMPTY
72719: LIST
72720: LIST
72721: PUSH
72722: LD_INT 1
72724: NEG
72725: PUSH
72726: LD_INT 0
72728: PUSH
72729: EMPTY
72730: LIST
72731: LIST
72732: PUSH
72733: LD_INT 1
72735: NEG
72736: PUSH
72737: LD_INT 1
72739: NEG
72740: PUSH
72741: EMPTY
72742: LIST
72743: LIST
72744: PUSH
72745: LD_INT 1
72747: PUSH
72748: LD_INT 1
72750: NEG
72751: PUSH
72752: EMPTY
72753: LIST
72754: LIST
72755: PUSH
72756: LD_INT 1
72758: NEG
72759: PUSH
72760: LD_INT 1
72762: PUSH
72763: EMPTY
72764: LIST
72765: LIST
72766: PUSH
72767: EMPTY
72768: LIST
72769: LIST
72770: LIST
72771: LIST
72772: LIST
72773: LIST
72774: LIST
72775: LIST
72776: LIST
72777: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
72778: LD_ADDR_VAR 0 38
72782: PUSH
72783: LD_INT 0
72785: PUSH
72786: LD_INT 0
72788: PUSH
72789: EMPTY
72790: LIST
72791: LIST
72792: PUSH
72793: LD_INT 0
72795: PUSH
72796: LD_INT 1
72798: NEG
72799: PUSH
72800: EMPTY
72801: LIST
72802: LIST
72803: PUSH
72804: LD_INT 1
72806: PUSH
72807: LD_INT 0
72809: PUSH
72810: EMPTY
72811: LIST
72812: LIST
72813: PUSH
72814: LD_INT 1
72816: PUSH
72817: LD_INT 1
72819: PUSH
72820: EMPTY
72821: LIST
72822: LIST
72823: PUSH
72824: LD_INT 0
72826: PUSH
72827: LD_INT 1
72829: PUSH
72830: EMPTY
72831: LIST
72832: LIST
72833: PUSH
72834: LD_INT 1
72836: NEG
72837: PUSH
72838: LD_INT 0
72840: PUSH
72841: EMPTY
72842: LIST
72843: LIST
72844: PUSH
72845: LD_INT 1
72847: NEG
72848: PUSH
72849: LD_INT 1
72851: NEG
72852: PUSH
72853: EMPTY
72854: LIST
72855: LIST
72856: PUSH
72857: LD_INT 2
72859: PUSH
72860: LD_INT 1
72862: PUSH
72863: EMPTY
72864: LIST
72865: LIST
72866: PUSH
72867: LD_INT 2
72869: NEG
72870: PUSH
72871: LD_INT 1
72873: NEG
72874: PUSH
72875: EMPTY
72876: LIST
72877: LIST
72878: PUSH
72879: EMPTY
72880: LIST
72881: LIST
72882: LIST
72883: LIST
72884: LIST
72885: LIST
72886: LIST
72887: LIST
72888: LIST
72889: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72890: LD_ADDR_VAR 0 39
72894: PUSH
72895: LD_INT 0
72897: PUSH
72898: LD_INT 0
72900: PUSH
72901: EMPTY
72902: LIST
72903: LIST
72904: PUSH
72905: LD_INT 0
72907: PUSH
72908: LD_INT 1
72910: NEG
72911: PUSH
72912: EMPTY
72913: LIST
72914: LIST
72915: PUSH
72916: LD_INT 1
72918: PUSH
72919: LD_INT 0
72921: PUSH
72922: EMPTY
72923: LIST
72924: LIST
72925: PUSH
72926: LD_INT 1
72928: PUSH
72929: LD_INT 1
72931: PUSH
72932: EMPTY
72933: LIST
72934: LIST
72935: PUSH
72936: LD_INT 0
72938: PUSH
72939: LD_INT 1
72941: PUSH
72942: EMPTY
72943: LIST
72944: LIST
72945: PUSH
72946: LD_INT 1
72948: NEG
72949: PUSH
72950: LD_INT 0
72952: PUSH
72953: EMPTY
72954: LIST
72955: LIST
72956: PUSH
72957: LD_INT 1
72959: NEG
72960: PUSH
72961: LD_INT 1
72963: NEG
72964: PUSH
72965: EMPTY
72966: LIST
72967: LIST
72968: PUSH
72969: LD_INT 1
72971: NEG
72972: PUSH
72973: LD_INT 2
72975: NEG
72976: PUSH
72977: EMPTY
72978: LIST
72979: LIST
72980: PUSH
72981: LD_INT 1
72983: PUSH
72984: LD_INT 2
72986: PUSH
72987: EMPTY
72988: LIST
72989: LIST
72990: PUSH
72991: EMPTY
72992: LIST
72993: LIST
72994: LIST
72995: LIST
72996: LIST
72997: LIST
72998: LIST
72999: LIST
73000: LIST
73001: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
73002: LD_ADDR_VAR 0 40
73006: PUSH
73007: LD_INT 0
73009: PUSH
73010: LD_INT 0
73012: PUSH
73013: EMPTY
73014: LIST
73015: LIST
73016: PUSH
73017: LD_INT 0
73019: PUSH
73020: LD_INT 1
73022: NEG
73023: PUSH
73024: EMPTY
73025: LIST
73026: LIST
73027: PUSH
73028: LD_INT 1
73030: PUSH
73031: LD_INT 0
73033: PUSH
73034: EMPTY
73035: LIST
73036: LIST
73037: PUSH
73038: LD_INT 1
73040: PUSH
73041: LD_INT 1
73043: PUSH
73044: EMPTY
73045: LIST
73046: LIST
73047: PUSH
73048: LD_INT 0
73050: PUSH
73051: LD_INT 1
73053: PUSH
73054: EMPTY
73055: LIST
73056: LIST
73057: PUSH
73058: LD_INT 1
73060: NEG
73061: PUSH
73062: LD_INT 0
73064: PUSH
73065: EMPTY
73066: LIST
73067: LIST
73068: PUSH
73069: LD_INT 1
73071: NEG
73072: PUSH
73073: LD_INT 1
73075: NEG
73076: PUSH
73077: EMPTY
73078: LIST
73079: LIST
73080: PUSH
73081: LD_INT 1
73083: PUSH
73084: LD_INT 1
73086: NEG
73087: PUSH
73088: EMPTY
73089: LIST
73090: LIST
73091: PUSH
73092: LD_INT 1
73094: NEG
73095: PUSH
73096: LD_INT 1
73098: PUSH
73099: EMPTY
73100: LIST
73101: LIST
73102: PUSH
73103: EMPTY
73104: LIST
73105: LIST
73106: LIST
73107: LIST
73108: LIST
73109: LIST
73110: LIST
73111: LIST
73112: LIST
73113: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73114: LD_ADDR_VAR 0 41
73118: PUSH
73119: LD_INT 0
73121: PUSH
73122: LD_INT 0
73124: PUSH
73125: EMPTY
73126: LIST
73127: LIST
73128: PUSH
73129: LD_INT 0
73131: PUSH
73132: LD_INT 1
73134: NEG
73135: PUSH
73136: EMPTY
73137: LIST
73138: LIST
73139: PUSH
73140: LD_INT 1
73142: PUSH
73143: LD_INT 0
73145: PUSH
73146: EMPTY
73147: LIST
73148: LIST
73149: PUSH
73150: LD_INT 1
73152: PUSH
73153: LD_INT 1
73155: PUSH
73156: EMPTY
73157: LIST
73158: LIST
73159: PUSH
73160: LD_INT 0
73162: PUSH
73163: LD_INT 1
73165: PUSH
73166: EMPTY
73167: LIST
73168: LIST
73169: PUSH
73170: LD_INT 1
73172: NEG
73173: PUSH
73174: LD_INT 0
73176: PUSH
73177: EMPTY
73178: LIST
73179: LIST
73180: PUSH
73181: LD_INT 1
73183: NEG
73184: PUSH
73185: LD_INT 1
73187: NEG
73188: PUSH
73189: EMPTY
73190: LIST
73191: LIST
73192: PUSH
73193: LD_INT 1
73195: NEG
73196: PUSH
73197: LD_INT 2
73199: NEG
73200: PUSH
73201: EMPTY
73202: LIST
73203: LIST
73204: PUSH
73205: LD_INT 1
73207: PUSH
73208: LD_INT 1
73210: NEG
73211: PUSH
73212: EMPTY
73213: LIST
73214: LIST
73215: PUSH
73216: LD_INT 2
73218: PUSH
73219: LD_INT 0
73221: PUSH
73222: EMPTY
73223: LIST
73224: LIST
73225: PUSH
73226: LD_INT 2
73228: PUSH
73229: LD_INT 1
73231: PUSH
73232: EMPTY
73233: LIST
73234: LIST
73235: PUSH
73236: LD_INT 2
73238: PUSH
73239: LD_INT 2
73241: PUSH
73242: EMPTY
73243: LIST
73244: LIST
73245: PUSH
73246: LD_INT 1
73248: PUSH
73249: LD_INT 2
73251: PUSH
73252: EMPTY
73253: LIST
73254: LIST
73255: PUSH
73256: LD_INT 1
73258: NEG
73259: PUSH
73260: LD_INT 1
73262: PUSH
73263: EMPTY
73264: LIST
73265: LIST
73266: PUSH
73267: LD_INT 2
73269: NEG
73270: PUSH
73271: LD_INT 0
73273: PUSH
73274: EMPTY
73275: LIST
73276: LIST
73277: PUSH
73278: LD_INT 2
73280: NEG
73281: PUSH
73282: LD_INT 1
73284: NEG
73285: PUSH
73286: EMPTY
73287: LIST
73288: LIST
73289: PUSH
73290: LD_INT 2
73292: NEG
73293: PUSH
73294: LD_INT 2
73296: NEG
73297: PUSH
73298: EMPTY
73299: LIST
73300: LIST
73301: PUSH
73302: LD_INT 2
73304: NEG
73305: PUSH
73306: LD_INT 3
73308: NEG
73309: PUSH
73310: EMPTY
73311: LIST
73312: LIST
73313: PUSH
73314: LD_INT 2
73316: PUSH
73317: LD_INT 1
73319: NEG
73320: PUSH
73321: EMPTY
73322: LIST
73323: LIST
73324: PUSH
73325: LD_INT 3
73327: PUSH
73328: LD_INT 0
73330: PUSH
73331: EMPTY
73332: LIST
73333: LIST
73334: PUSH
73335: LD_INT 3
73337: PUSH
73338: LD_INT 1
73340: PUSH
73341: EMPTY
73342: LIST
73343: LIST
73344: PUSH
73345: LD_INT 3
73347: PUSH
73348: LD_INT 2
73350: PUSH
73351: EMPTY
73352: LIST
73353: LIST
73354: PUSH
73355: LD_INT 3
73357: PUSH
73358: LD_INT 3
73360: PUSH
73361: EMPTY
73362: LIST
73363: LIST
73364: PUSH
73365: LD_INT 2
73367: PUSH
73368: LD_INT 3
73370: PUSH
73371: EMPTY
73372: LIST
73373: LIST
73374: PUSH
73375: LD_INT 2
73377: NEG
73378: PUSH
73379: LD_INT 1
73381: PUSH
73382: EMPTY
73383: LIST
73384: LIST
73385: PUSH
73386: LD_INT 3
73388: NEG
73389: PUSH
73390: LD_INT 0
73392: PUSH
73393: EMPTY
73394: LIST
73395: LIST
73396: PUSH
73397: LD_INT 3
73399: NEG
73400: PUSH
73401: LD_INT 1
73403: NEG
73404: PUSH
73405: EMPTY
73406: LIST
73407: LIST
73408: PUSH
73409: LD_INT 3
73411: NEG
73412: PUSH
73413: LD_INT 2
73415: NEG
73416: PUSH
73417: EMPTY
73418: LIST
73419: LIST
73420: PUSH
73421: LD_INT 3
73423: NEG
73424: PUSH
73425: LD_INT 3
73427: NEG
73428: PUSH
73429: EMPTY
73430: LIST
73431: LIST
73432: PUSH
73433: EMPTY
73434: LIST
73435: LIST
73436: LIST
73437: LIST
73438: LIST
73439: LIST
73440: LIST
73441: LIST
73442: LIST
73443: LIST
73444: LIST
73445: LIST
73446: LIST
73447: LIST
73448: LIST
73449: LIST
73450: LIST
73451: LIST
73452: LIST
73453: LIST
73454: LIST
73455: LIST
73456: LIST
73457: LIST
73458: LIST
73459: LIST
73460: LIST
73461: LIST
73462: LIST
73463: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73464: LD_ADDR_VAR 0 42
73468: PUSH
73469: LD_INT 0
73471: PUSH
73472: LD_INT 0
73474: PUSH
73475: EMPTY
73476: LIST
73477: LIST
73478: PUSH
73479: LD_INT 0
73481: PUSH
73482: LD_INT 1
73484: NEG
73485: PUSH
73486: EMPTY
73487: LIST
73488: LIST
73489: PUSH
73490: LD_INT 1
73492: PUSH
73493: LD_INT 0
73495: PUSH
73496: EMPTY
73497: LIST
73498: LIST
73499: PUSH
73500: LD_INT 1
73502: PUSH
73503: LD_INT 1
73505: PUSH
73506: EMPTY
73507: LIST
73508: LIST
73509: PUSH
73510: LD_INT 0
73512: PUSH
73513: LD_INT 1
73515: PUSH
73516: EMPTY
73517: LIST
73518: LIST
73519: PUSH
73520: LD_INT 1
73522: NEG
73523: PUSH
73524: LD_INT 0
73526: PUSH
73527: EMPTY
73528: LIST
73529: LIST
73530: PUSH
73531: LD_INT 1
73533: NEG
73534: PUSH
73535: LD_INT 1
73537: NEG
73538: PUSH
73539: EMPTY
73540: LIST
73541: LIST
73542: PUSH
73543: LD_INT 1
73545: NEG
73546: PUSH
73547: LD_INT 2
73549: NEG
73550: PUSH
73551: EMPTY
73552: LIST
73553: LIST
73554: PUSH
73555: LD_INT 0
73557: PUSH
73558: LD_INT 2
73560: NEG
73561: PUSH
73562: EMPTY
73563: LIST
73564: LIST
73565: PUSH
73566: LD_INT 1
73568: PUSH
73569: LD_INT 1
73571: NEG
73572: PUSH
73573: EMPTY
73574: LIST
73575: LIST
73576: PUSH
73577: LD_INT 2
73579: PUSH
73580: LD_INT 1
73582: PUSH
73583: EMPTY
73584: LIST
73585: LIST
73586: PUSH
73587: LD_INT 2
73589: PUSH
73590: LD_INT 2
73592: PUSH
73593: EMPTY
73594: LIST
73595: LIST
73596: PUSH
73597: LD_INT 1
73599: PUSH
73600: LD_INT 2
73602: PUSH
73603: EMPTY
73604: LIST
73605: LIST
73606: PUSH
73607: LD_INT 0
73609: PUSH
73610: LD_INT 2
73612: PUSH
73613: EMPTY
73614: LIST
73615: LIST
73616: PUSH
73617: LD_INT 1
73619: NEG
73620: PUSH
73621: LD_INT 1
73623: PUSH
73624: EMPTY
73625: LIST
73626: LIST
73627: PUSH
73628: LD_INT 2
73630: NEG
73631: PUSH
73632: LD_INT 1
73634: NEG
73635: PUSH
73636: EMPTY
73637: LIST
73638: LIST
73639: PUSH
73640: LD_INT 2
73642: NEG
73643: PUSH
73644: LD_INT 2
73646: NEG
73647: PUSH
73648: EMPTY
73649: LIST
73650: LIST
73651: PUSH
73652: LD_INT 2
73654: NEG
73655: PUSH
73656: LD_INT 3
73658: NEG
73659: PUSH
73660: EMPTY
73661: LIST
73662: LIST
73663: PUSH
73664: LD_INT 1
73666: NEG
73667: PUSH
73668: LD_INT 3
73670: NEG
73671: PUSH
73672: EMPTY
73673: LIST
73674: LIST
73675: PUSH
73676: LD_INT 0
73678: PUSH
73679: LD_INT 3
73681: NEG
73682: PUSH
73683: EMPTY
73684: LIST
73685: LIST
73686: PUSH
73687: LD_INT 1
73689: PUSH
73690: LD_INT 2
73692: NEG
73693: PUSH
73694: EMPTY
73695: LIST
73696: LIST
73697: PUSH
73698: LD_INT 3
73700: PUSH
73701: LD_INT 2
73703: PUSH
73704: EMPTY
73705: LIST
73706: LIST
73707: PUSH
73708: LD_INT 3
73710: PUSH
73711: LD_INT 3
73713: PUSH
73714: EMPTY
73715: LIST
73716: LIST
73717: PUSH
73718: LD_INT 2
73720: PUSH
73721: LD_INT 3
73723: PUSH
73724: EMPTY
73725: LIST
73726: LIST
73727: PUSH
73728: LD_INT 1
73730: PUSH
73731: LD_INT 3
73733: PUSH
73734: EMPTY
73735: LIST
73736: LIST
73737: PUSH
73738: LD_INT 0
73740: PUSH
73741: LD_INT 3
73743: PUSH
73744: EMPTY
73745: LIST
73746: LIST
73747: PUSH
73748: LD_INT 1
73750: NEG
73751: PUSH
73752: LD_INT 2
73754: PUSH
73755: EMPTY
73756: LIST
73757: LIST
73758: PUSH
73759: LD_INT 3
73761: NEG
73762: PUSH
73763: LD_INT 2
73765: NEG
73766: PUSH
73767: EMPTY
73768: LIST
73769: LIST
73770: PUSH
73771: LD_INT 3
73773: NEG
73774: PUSH
73775: LD_INT 3
73777: NEG
73778: PUSH
73779: EMPTY
73780: LIST
73781: LIST
73782: PUSH
73783: EMPTY
73784: LIST
73785: LIST
73786: LIST
73787: LIST
73788: LIST
73789: LIST
73790: LIST
73791: LIST
73792: LIST
73793: LIST
73794: LIST
73795: LIST
73796: LIST
73797: LIST
73798: LIST
73799: LIST
73800: LIST
73801: LIST
73802: LIST
73803: LIST
73804: LIST
73805: LIST
73806: LIST
73807: LIST
73808: LIST
73809: LIST
73810: LIST
73811: LIST
73812: LIST
73813: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73814: LD_ADDR_VAR 0 43
73818: PUSH
73819: LD_INT 0
73821: PUSH
73822: LD_INT 0
73824: PUSH
73825: EMPTY
73826: LIST
73827: LIST
73828: PUSH
73829: LD_INT 0
73831: PUSH
73832: LD_INT 1
73834: NEG
73835: PUSH
73836: EMPTY
73837: LIST
73838: LIST
73839: PUSH
73840: LD_INT 1
73842: PUSH
73843: LD_INT 0
73845: PUSH
73846: EMPTY
73847: LIST
73848: LIST
73849: PUSH
73850: LD_INT 1
73852: PUSH
73853: LD_INT 1
73855: PUSH
73856: EMPTY
73857: LIST
73858: LIST
73859: PUSH
73860: LD_INT 0
73862: PUSH
73863: LD_INT 1
73865: PUSH
73866: EMPTY
73867: LIST
73868: LIST
73869: PUSH
73870: LD_INT 1
73872: NEG
73873: PUSH
73874: LD_INT 0
73876: PUSH
73877: EMPTY
73878: LIST
73879: LIST
73880: PUSH
73881: LD_INT 1
73883: NEG
73884: PUSH
73885: LD_INT 1
73887: NEG
73888: PUSH
73889: EMPTY
73890: LIST
73891: LIST
73892: PUSH
73893: LD_INT 1
73895: NEG
73896: PUSH
73897: LD_INT 2
73899: NEG
73900: PUSH
73901: EMPTY
73902: LIST
73903: LIST
73904: PUSH
73905: LD_INT 0
73907: PUSH
73908: LD_INT 2
73910: NEG
73911: PUSH
73912: EMPTY
73913: LIST
73914: LIST
73915: PUSH
73916: LD_INT 1
73918: PUSH
73919: LD_INT 1
73921: NEG
73922: PUSH
73923: EMPTY
73924: LIST
73925: LIST
73926: PUSH
73927: LD_INT 2
73929: PUSH
73930: LD_INT 0
73932: PUSH
73933: EMPTY
73934: LIST
73935: LIST
73936: PUSH
73937: LD_INT 2
73939: PUSH
73940: LD_INT 1
73942: PUSH
73943: EMPTY
73944: LIST
73945: LIST
73946: PUSH
73947: LD_INT 1
73949: PUSH
73950: LD_INT 2
73952: PUSH
73953: EMPTY
73954: LIST
73955: LIST
73956: PUSH
73957: LD_INT 0
73959: PUSH
73960: LD_INT 2
73962: PUSH
73963: EMPTY
73964: LIST
73965: LIST
73966: PUSH
73967: LD_INT 1
73969: NEG
73970: PUSH
73971: LD_INT 1
73973: PUSH
73974: EMPTY
73975: LIST
73976: LIST
73977: PUSH
73978: LD_INT 2
73980: NEG
73981: PUSH
73982: LD_INT 0
73984: PUSH
73985: EMPTY
73986: LIST
73987: LIST
73988: PUSH
73989: LD_INT 2
73991: NEG
73992: PUSH
73993: LD_INT 1
73995: NEG
73996: PUSH
73997: EMPTY
73998: LIST
73999: LIST
74000: PUSH
74001: LD_INT 1
74003: NEG
74004: PUSH
74005: LD_INT 3
74007: NEG
74008: PUSH
74009: EMPTY
74010: LIST
74011: LIST
74012: PUSH
74013: LD_INT 0
74015: PUSH
74016: LD_INT 3
74018: NEG
74019: PUSH
74020: EMPTY
74021: LIST
74022: LIST
74023: PUSH
74024: LD_INT 1
74026: PUSH
74027: LD_INT 2
74029: NEG
74030: PUSH
74031: EMPTY
74032: LIST
74033: LIST
74034: PUSH
74035: LD_INT 2
74037: PUSH
74038: LD_INT 1
74040: NEG
74041: PUSH
74042: EMPTY
74043: LIST
74044: LIST
74045: PUSH
74046: LD_INT 3
74048: PUSH
74049: LD_INT 0
74051: PUSH
74052: EMPTY
74053: LIST
74054: LIST
74055: PUSH
74056: LD_INT 3
74058: PUSH
74059: LD_INT 1
74061: PUSH
74062: EMPTY
74063: LIST
74064: LIST
74065: PUSH
74066: LD_INT 1
74068: PUSH
74069: LD_INT 3
74071: PUSH
74072: EMPTY
74073: LIST
74074: LIST
74075: PUSH
74076: LD_INT 0
74078: PUSH
74079: LD_INT 3
74081: PUSH
74082: EMPTY
74083: LIST
74084: LIST
74085: PUSH
74086: LD_INT 1
74088: NEG
74089: PUSH
74090: LD_INT 2
74092: PUSH
74093: EMPTY
74094: LIST
74095: LIST
74096: PUSH
74097: LD_INT 2
74099: NEG
74100: PUSH
74101: LD_INT 1
74103: PUSH
74104: EMPTY
74105: LIST
74106: LIST
74107: PUSH
74108: LD_INT 3
74110: NEG
74111: PUSH
74112: LD_INT 0
74114: PUSH
74115: EMPTY
74116: LIST
74117: LIST
74118: PUSH
74119: LD_INT 3
74121: NEG
74122: PUSH
74123: LD_INT 1
74125: NEG
74126: PUSH
74127: EMPTY
74128: LIST
74129: LIST
74130: PUSH
74131: EMPTY
74132: LIST
74133: LIST
74134: LIST
74135: LIST
74136: LIST
74137: LIST
74138: LIST
74139: LIST
74140: LIST
74141: LIST
74142: LIST
74143: LIST
74144: LIST
74145: LIST
74146: LIST
74147: LIST
74148: LIST
74149: LIST
74150: LIST
74151: LIST
74152: LIST
74153: LIST
74154: LIST
74155: LIST
74156: LIST
74157: LIST
74158: LIST
74159: LIST
74160: LIST
74161: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74162: LD_ADDR_VAR 0 44
74166: PUSH
74167: LD_INT 0
74169: PUSH
74170: LD_INT 0
74172: PUSH
74173: EMPTY
74174: LIST
74175: LIST
74176: PUSH
74177: LD_INT 0
74179: PUSH
74180: LD_INT 1
74182: NEG
74183: PUSH
74184: EMPTY
74185: LIST
74186: LIST
74187: PUSH
74188: LD_INT 1
74190: PUSH
74191: LD_INT 0
74193: PUSH
74194: EMPTY
74195: LIST
74196: LIST
74197: PUSH
74198: LD_INT 1
74200: PUSH
74201: LD_INT 1
74203: PUSH
74204: EMPTY
74205: LIST
74206: LIST
74207: PUSH
74208: LD_INT 0
74210: PUSH
74211: LD_INT 1
74213: PUSH
74214: EMPTY
74215: LIST
74216: LIST
74217: PUSH
74218: LD_INT 1
74220: NEG
74221: PUSH
74222: LD_INT 0
74224: PUSH
74225: EMPTY
74226: LIST
74227: LIST
74228: PUSH
74229: LD_INT 1
74231: NEG
74232: PUSH
74233: LD_INT 1
74235: NEG
74236: PUSH
74237: EMPTY
74238: LIST
74239: LIST
74240: PUSH
74241: LD_INT 1
74243: NEG
74244: PUSH
74245: LD_INT 2
74247: NEG
74248: PUSH
74249: EMPTY
74250: LIST
74251: LIST
74252: PUSH
74253: LD_INT 1
74255: PUSH
74256: LD_INT 1
74258: NEG
74259: PUSH
74260: EMPTY
74261: LIST
74262: LIST
74263: PUSH
74264: LD_INT 2
74266: PUSH
74267: LD_INT 0
74269: PUSH
74270: EMPTY
74271: LIST
74272: LIST
74273: PUSH
74274: LD_INT 2
74276: PUSH
74277: LD_INT 1
74279: PUSH
74280: EMPTY
74281: LIST
74282: LIST
74283: PUSH
74284: LD_INT 2
74286: PUSH
74287: LD_INT 2
74289: PUSH
74290: EMPTY
74291: LIST
74292: LIST
74293: PUSH
74294: LD_INT 1
74296: PUSH
74297: LD_INT 2
74299: PUSH
74300: EMPTY
74301: LIST
74302: LIST
74303: PUSH
74304: LD_INT 1
74306: NEG
74307: PUSH
74308: LD_INT 1
74310: PUSH
74311: EMPTY
74312: LIST
74313: LIST
74314: PUSH
74315: LD_INT 2
74317: NEG
74318: PUSH
74319: LD_INT 0
74321: PUSH
74322: EMPTY
74323: LIST
74324: LIST
74325: PUSH
74326: LD_INT 2
74328: NEG
74329: PUSH
74330: LD_INT 1
74332: NEG
74333: PUSH
74334: EMPTY
74335: LIST
74336: LIST
74337: PUSH
74338: LD_INT 2
74340: NEG
74341: PUSH
74342: LD_INT 2
74344: NEG
74345: PUSH
74346: EMPTY
74347: LIST
74348: LIST
74349: PUSH
74350: LD_INT 2
74352: NEG
74353: PUSH
74354: LD_INT 3
74356: NEG
74357: PUSH
74358: EMPTY
74359: LIST
74360: LIST
74361: PUSH
74362: LD_INT 2
74364: PUSH
74365: LD_INT 1
74367: NEG
74368: PUSH
74369: EMPTY
74370: LIST
74371: LIST
74372: PUSH
74373: LD_INT 3
74375: PUSH
74376: LD_INT 0
74378: PUSH
74379: EMPTY
74380: LIST
74381: LIST
74382: PUSH
74383: LD_INT 3
74385: PUSH
74386: LD_INT 1
74388: PUSH
74389: EMPTY
74390: LIST
74391: LIST
74392: PUSH
74393: LD_INT 3
74395: PUSH
74396: LD_INT 2
74398: PUSH
74399: EMPTY
74400: LIST
74401: LIST
74402: PUSH
74403: LD_INT 3
74405: PUSH
74406: LD_INT 3
74408: PUSH
74409: EMPTY
74410: LIST
74411: LIST
74412: PUSH
74413: LD_INT 2
74415: PUSH
74416: LD_INT 3
74418: PUSH
74419: EMPTY
74420: LIST
74421: LIST
74422: PUSH
74423: LD_INT 2
74425: NEG
74426: PUSH
74427: LD_INT 1
74429: PUSH
74430: EMPTY
74431: LIST
74432: LIST
74433: PUSH
74434: LD_INT 3
74436: NEG
74437: PUSH
74438: LD_INT 0
74440: PUSH
74441: EMPTY
74442: LIST
74443: LIST
74444: PUSH
74445: LD_INT 3
74447: NEG
74448: PUSH
74449: LD_INT 1
74451: NEG
74452: PUSH
74453: EMPTY
74454: LIST
74455: LIST
74456: PUSH
74457: LD_INT 3
74459: NEG
74460: PUSH
74461: LD_INT 2
74463: NEG
74464: PUSH
74465: EMPTY
74466: LIST
74467: LIST
74468: PUSH
74469: LD_INT 3
74471: NEG
74472: PUSH
74473: LD_INT 3
74475: NEG
74476: PUSH
74477: EMPTY
74478: LIST
74479: LIST
74480: PUSH
74481: EMPTY
74482: LIST
74483: LIST
74484: LIST
74485: LIST
74486: LIST
74487: LIST
74488: LIST
74489: LIST
74490: LIST
74491: LIST
74492: LIST
74493: LIST
74494: LIST
74495: LIST
74496: LIST
74497: LIST
74498: LIST
74499: LIST
74500: LIST
74501: LIST
74502: LIST
74503: LIST
74504: LIST
74505: LIST
74506: LIST
74507: LIST
74508: LIST
74509: LIST
74510: LIST
74511: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74512: LD_ADDR_VAR 0 45
74516: PUSH
74517: LD_INT 0
74519: PUSH
74520: LD_INT 0
74522: PUSH
74523: EMPTY
74524: LIST
74525: LIST
74526: PUSH
74527: LD_INT 0
74529: PUSH
74530: LD_INT 1
74532: NEG
74533: PUSH
74534: EMPTY
74535: LIST
74536: LIST
74537: PUSH
74538: LD_INT 1
74540: PUSH
74541: LD_INT 0
74543: PUSH
74544: EMPTY
74545: LIST
74546: LIST
74547: PUSH
74548: LD_INT 1
74550: PUSH
74551: LD_INT 1
74553: PUSH
74554: EMPTY
74555: LIST
74556: LIST
74557: PUSH
74558: LD_INT 0
74560: PUSH
74561: LD_INT 1
74563: PUSH
74564: EMPTY
74565: LIST
74566: LIST
74567: PUSH
74568: LD_INT 1
74570: NEG
74571: PUSH
74572: LD_INT 0
74574: PUSH
74575: EMPTY
74576: LIST
74577: LIST
74578: PUSH
74579: LD_INT 1
74581: NEG
74582: PUSH
74583: LD_INT 1
74585: NEG
74586: PUSH
74587: EMPTY
74588: LIST
74589: LIST
74590: PUSH
74591: LD_INT 1
74593: NEG
74594: PUSH
74595: LD_INT 2
74597: NEG
74598: PUSH
74599: EMPTY
74600: LIST
74601: LIST
74602: PUSH
74603: LD_INT 0
74605: PUSH
74606: LD_INT 2
74608: NEG
74609: PUSH
74610: EMPTY
74611: LIST
74612: LIST
74613: PUSH
74614: LD_INT 1
74616: PUSH
74617: LD_INT 1
74619: NEG
74620: PUSH
74621: EMPTY
74622: LIST
74623: LIST
74624: PUSH
74625: LD_INT 2
74627: PUSH
74628: LD_INT 1
74630: PUSH
74631: EMPTY
74632: LIST
74633: LIST
74634: PUSH
74635: LD_INT 2
74637: PUSH
74638: LD_INT 2
74640: PUSH
74641: EMPTY
74642: LIST
74643: LIST
74644: PUSH
74645: LD_INT 1
74647: PUSH
74648: LD_INT 2
74650: PUSH
74651: EMPTY
74652: LIST
74653: LIST
74654: PUSH
74655: LD_INT 0
74657: PUSH
74658: LD_INT 2
74660: PUSH
74661: EMPTY
74662: LIST
74663: LIST
74664: PUSH
74665: LD_INT 1
74667: NEG
74668: PUSH
74669: LD_INT 1
74671: PUSH
74672: EMPTY
74673: LIST
74674: LIST
74675: PUSH
74676: LD_INT 2
74678: NEG
74679: PUSH
74680: LD_INT 1
74682: NEG
74683: PUSH
74684: EMPTY
74685: LIST
74686: LIST
74687: PUSH
74688: LD_INT 2
74690: NEG
74691: PUSH
74692: LD_INT 2
74694: NEG
74695: PUSH
74696: EMPTY
74697: LIST
74698: LIST
74699: PUSH
74700: LD_INT 2
74702: NEG
74703: PUSH
74704: LD_INT 3
74706: NEG
74707: PUSH
74708: EMPTY
74709: LIST
74710: LIST
74711: PUSH
74712: LD_INT 1
74714: NEG
74715: PUSH
74716: LD_INT 3
74718: NEG
74719: PUSH
74720: EMPTY
74721: LIST
74722: LIST
74723: PUSH
74724: LD_INT 0
74726: PUSH
74727: LD_INT 3
74729: NEG
74730: PUSH
74731: EMPTY
74732: LIST
74733: LIST
74734: PUSH
74735: LD_INT 1
74737: PUSH
74738: LD_INT 2
74740: NEG
74741: PUSH
74742: EMPTY
74743: LIST
74744: LIST
74745: PUSH
74746: LD_INT 3
74748: PUSH
74749: LD_INT 2
74751: PUSH
74752: EMPTY
74753: LIST
74754: LIST
74755: PUSH
74756: LD_INT 3
74758: PUSH
74759: LD_INT 3
74761: PUSH
74762: EMPTY
74763: LIST
74764: LIST
74765: PUSH
74766: LD_INT 2
74768: PUSH
74769: LD_INT 3
74771: PUSH
74772: EMPTY
74773: LIST
74774: LIST
74775: PUSH
74776: LD_INT 1
74778: PUSH
74779: LD_INT 3
74781: PUSH
74782: EMPTY
74783: LIST
74784: LIST
74785: PUSH
74786: LD_INT 0
74788: PUSH
74789: LD_INT 3
74791: PUSH
74792: EMPTY
74793: LIST
74794: LIST
74795: PUSH
74796: LD_INT 1
74798: NEG
74799: PUSH
74800: LD_INT 2
74802: PUSH
74803: EMPTY
74804: LIST
74805: LIST
74806: PUSH
74807: LD_INT 3
74809: NEG
74810: PUSH
74811: LD_INT 2
74813: NEG
74814: PUSH
74815: EMPTY
74816: LIST
74817: LIST
74818: PUSH
74819: LD_INT 3
74821: NEG
74822: PUSH
74823: LD_INT 3
74825: NEG
74826: PUSH
74827: EMPTY
74828: LIST
74829: LIST
74830: PUSH
74831: EMPTY
74832: LIST
74833: LIST
74834: LIST
74835: LIST
74836: LIST
74837: LIST
74838: LIST
74839: LIST
74840: LIST
74841: LIST
74842: LIST
74843: LIST
74844: LIST
74845: LIST
74846: LIST
74847: LIST
74848: LIST
74849: LIST
74850: LIST
74851: LIST
74852: LIST
74853: LIST
74854: LIST
74855: LIST
74856: LIST
74857: LIST
74858: LIST
74859: LIST
74860: LIST
74861: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74862: LD_ADDR_VAR 0 46
74866: PUSH
74867: LD_INT 0
74869: PUSH
74870: LD_INT 0
74872: PUSH
74873: EMPTY
74874: LIST
74875: LIST
74876: PUSH
74877: LD_INT 0
74879: PUSH
74880: LD_INT 1
74882: NEG
74883: PUSH
74884: EMPTY
74885: LIST
74886: LIST
74887: PUSH
74888: LD_INT 1
74890: PUSH
74891: LD_INT 0
74893: PUSH
74894: EMPTY
74895: LIST
74896: LIST
74897: PUSH
74898: LD_INT 1
74900: PUSH
74901: LD_INT 1
74903: PUSH
74904: EMPTY
74905: LIST
74906: LIST
74907: PUSH
74908: LD_INT 0
74910: PUSH
74911: LD_INT 1
74913: PUSH
74914: EMPTY
74915: LIST
74916: LIST
74917: PUSH
74918: LD_INT 1
74920: NEG
74921: PUSH
74922: LD_INT 0
74924: PUSH
74925: EMPTY
74926: LIST
74927: LIST
74928: PUSH
74929: LD_INT 1
74931: NEG
74932: PUSH
74933: LD_INT 1
74935: NEG
74936: PUSH
74937: EMPTY
74938: LIST
74939: LIST
74940: PUSH
74941: LD_INT 1
74943: NEG
74944: PUSH
74945: LD_INT 2
74947: NEG
74948: PUSH
74949: EMPTY
74950: LIST
74951: LIST
74952: PUSH
74953: LD_INT 0
74955: PUSH
74956: LD_INT 2
74958: NEG
74959: PUSH
74960: EMPTY
74961: LIST
74962: LIST
74963: PUSH
74964: LD_INT 1
74966: PUSH
74967: LD_INT 1
74969: NEG
74970: PUSH
74971: EMPTY
74972: LIST
74973: LIST
74974: PUSH
74975: LD_INT 2
74977: PUSH
74978: LD_INT 0
74980: PUSH
74981: EMPTY
74982: LIST
74983: LIST
74984: PUSH
74985: LD_INT 2
74987: PUSH
74988: LD_INT 1
74990: PUSH
74991: EMPTY
74992: LIST
74993: LIST
74994: PUSH
74995: LD_INT 1
74997: PUSH
74998: LD_INT 2
75000: PUSH
75001: EMPTY
75002: LIST
75003: LIST
75004: PUSH
75005: LD_INT 0
75007: PUSH
75008: LD_INT 2
75010: PUSH
75011: EMPTY
75012: LIST
75013: LIST
75014: PUSH
75015: LD_INT 1
75017: NEG
75018: PUSH
75019: LD_INT 1
75021: PUSH
75022: EMPTY
75023: LIST
75024: LIST
75025: PUSH
75026: LD_INT 2
75028: NEG
75029: PUSH
75030: LD_INT 0
75032: PUSH
75033: EMPTY
75034: LIST
75035: LIST
75036: PUSH
75037: LD_INT 2
75039: NEG
75040: PUSH
75041: LD_INT 1
75043: NEG
75044: PUSH
75045: EMPTY
75046: LIST
75047: LIST
75048: PUSH
75049: LD_INT 1
75051: NEG
75052: PUSH
75053: LD_INT 3
75055: NEG
75056: PUSH
75057: EMPTY
75058: LIST
75059: LIST
75060: PUSH
75061: LD_INT 0
75063: PUSH
75064: LD_INT 3
75066: NEG
75067: PUSH
75068: EMPTY
75069: LIST
75070: LIST
75071: PUSH
75072: LD_INT 1
75074: PUSH
75075: LD_INT 2
75077: NEG
75078: PUSH
75079: EMPTY
75080: LIST
75081: LIST
75082: PUSH
75083: LD_INT 2
75085: PUSH
75086: LD_INT 1
75088: NEG
75089: PUSH
75090: EMPTY
75091: LIST
75092: LIST
75093: PUSH
75094: LD_INT 3
75096: PUSH
75097: LD_INT 0
75099: PUSH
75100: EMPTY
75101: LIST
75102: LIST
75103: PUSH
75104: LD_INT 3
75106: PUSH
75107: LD_INT 1
75109: PUSH
75110: EMPTY
75111: LIST
75112: LIST
75113: PUSH
75114: LD_INT 1
75116: PUSH
75117: LD_INT 3
75119: PUSH
75120: EMPTY
75121: LIST
75122: LIST
75123: PUSH
75124: LD_INT 0
75126: PUSH
75127: LD_INT 3
75129: PUSH
75130: EMPTY
75131: LIST
75132: LIST
75133: PUSH
75134: LD_INT 1
75136: NEG
75137: PUSH
75138: LD_INT 2
75140: PUSH
75141: EMPTY
75142: LIST
75143: LIST
75144: PUSH
75145: LD_INT 2
75147: NEG
75148: PUSH
75149: LD_INT 1
75151: PUSH
75152: EMPTY
75153: LIST
75154: LIST
75155: PUSH
75156: LD_INT 3
75158: NEG
75159: PUSH
75160: LD_INT 0
75162: PUSH
75163: EMPTY
75164: LIST
75165: LIST
75166: PUSH
75167: LD_INT 3
75169: NEG
75170: PUSH
75171: LD_INT 1
75173: NEG
75174: PUSH
75175: EMPTY
75176: LIST
75177: LIST
75178: PUSH
75179: EMPTY
75180: LIST
75181: LIST
75182: LIST
75183: LIST
75184: LIST
75185: LIST
75186: LIST
75187: LIST
75188: LIST
75189: LIST
75190: LIST
75191: LIST
75192: LIST
75193: LIST
75194: LIST
75195: LIST
75196: LIST
75197: LIST
75198: LIST
75199: LIST
75200: LIST
75201: LIST
75202: LIST
75203: LIST
75204: LIST
75205: LIST
75206: LIST
75207: LIST
75208: LIST
75209: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75210: LD_ADDR_VAR 0 47
75214: PUSH
75215: LD_INT 0
75217: PUSH
75218: LD_INT 0
75220: PUSH
75221: EMPTY
75222: LIST
75223: LIST
75224: PUSH
75225: LD_INT 0
75227: PUSH
75228: LD_INT 1
75230: NEG
75231: PUSH
75232: EMPTY
75233: LIST
75234: LIST
75235: PUSH
75236: LD_INT 1
75238: PUSH
75239: LD_INT 0
75241: PUSH
75242: EMPTY
75243: LIST
75244: LIST
75245: PUSH
75246: LD_INT 1
75248: PUSH
75249: LD_INT 1
75251: PUSH
75252: EMPTY
75253: LIST
75254: LIST
75255: PUSH
75256: LD_INT 0
75258: PUSH
75259: LD_INT 1
75261: PUSH
75262: EMPTY
75263: LIST
75264: LIST
75265: PUSH
75266: LD_INT 1
75268: NEG
75269: PUSH
75270: LD_INT 0
75272: PUSH
75273: EMPTY
75274: LIST
75275: LIST
75276: PUSH
75277: LD_INT 1
75279: NEG
75280: PUSH
75281: LD_INT 1
75283: NEG
75284: PUSH
75285: EMPTY
75286: LIST
75287: LIST
75288: PUSH
75289: LD_INT 1
75291: NEG
75292: PUSH
75293: LD_INT 2
75295: NEG
75296: PUSH
75297: EMPTY
75298: LIST
75299: LIST
75300: PUSH
75301: LD_INT 0
75303: PUSH
75304: LD_INT 2
75306: NEG
75307: PUSH
75308: EMPTY
75309: LIST
75310: LIST
75311: PUSH
75312: LD_INT 1
75314: PUSH
75315: LD_INT 1
75317: NEG
75318: PUSH
75319: EMPTY
75320: LIST
75321: LIST
75322: PUSH
75323: LD_INT 2
75325: NEG
75326: PUSH
75327: LD_INT 1
75329: NEG
75330: PUSH
75331: EMPTY
75332: LIST
75333: LIST
75334: PUSH
75335: LD_INT 2
75337: NEG
75338: PUSH
75339: LD_INT 2
75341: NEG
75342: PUSH
75343: EMPTY
75344: LIST
75345: LIST
75346: PUSH
75347: EMPTY
75348: LIST
75349: LIST
75350: LIST
75351: LIST
75352: LIST
75353: LIST
75354: LIST
75355: LIST
75356: LIST
75357: LIST
75358: LIST
75359: LIST
75360: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
75361: LD_ADDR_VAR 0 48
75365: PUSH
75366: LD_INT 0
75368: PUSH
75369: LD_INT 0
75371: PUSH
75372: EMPTY
75373: LIST
75374: LIST
75375: PUSH
75376: LD_INT 0
75378: PUSH
75379: LD_INT 1
75381: NEG
75382: PUSH
75383: EMPTY
75384: LIST
75385: LIST
75386: PUSH
75387: LD_INT 1
75389: PUSH
75390: LD_INT 0
75392: PUSH
75393: EMPTY
75394: LIST
75395: LIST
75396: PUSH
75397: LD_INT 1
75399: PUSH
75400: LD_INT 1
75402: PUSH
75403: EMPTY
75404: LIST
75405: LIST
75406: PUSH
75407: LD_INT 0
75409: PUSH
75410: LD_INT 1
75412: PUSH
75413: EMPTY
75414: LIST
75415: LIST
75416: PUSH
75417: LD_INT 1
75419: NEG
75420: PUSH
75421: LD_INT 0
75423: PUSH
75424: EMPTY
75425: LIST
75426: LIST
75427: PUSH
75428: LD_INT 1
75430: NEG
75431: PUSH
75432: LD_INT 1
75434: NEG
75435: PUSH
75436: EMPTY
75437: LIST
75438: LIST
75439: PUSH
75440: LD_INT 1
75442: NEG
75443: PUSH
75444: LD_INT 2
75446: NEG
75447: PUSH
75448: EMPTY
75449: LIST
75450: LIST
75451: PUSH
75452: LD_INT 0
75454: PUSH
75455: LD_INT 2
75457: NEG
75458: PUSH
75459: EMPTY
75460: LIST
75461: LIST
75462: PUSH
75463: LD_INT 1
75465: PUSH
75466: LD_INT 1
75468: NEG
75469: PUSH
75470: EMPTY
75471: LIST
75472: LIST
75473: PUSH
75474: LD_INT 2
75476: PUSH
75477: LD_INT 0
75479: PUSH
75480: EMPTY
75481: LIST
75482: LIST
75483: PUSH
75484: LD_INT 2
75486: PUSH
75487: LD_INT 1
75489: PUSH
75490: EMPTY
75491: LIST
75492: LIST
75493: PUSH
75494: EMPTY
75495: LIST
75496: LIST
75497: LIST
75498: LIST
75499: LIST
75500: LIST
75501: LIST
75502: LIST
75503: LIST
75504: LIST
75505: LIST
75506: LIST
75507: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
75508: LD_ADDR_VAR 0 49
75512: PUSH
75513: LD_INT 0
75515: PUSH
75516: LD_INT 0
75518: PUSH
75519: EMPTY
75520: LIST
75521: LIST
75522: PUSH
75523: LD_INT 0
75525: PUSH
75526: LD_INT 1
75528: NEG
75529: PUSH
75530: EMPTY
75531: LIST
75532: LIST
75533: PUSH
75534: LD_INT 1
75536: PUSH
75537: LD_INT 0
75539: PUSH
75540: EMPTY
75541: LIST
75542: LIST
75543: PUSH
75544: LD_INT 1
75546: PUSH
75547: LD_INT 1
75549: PUSH
75550: EMPTY
75551: LIST
75552: LIST
75553: PUSH
75554: LD_INT 0
75556: PUSH
75557: LD_INT 1
75559: PUSH
75560: EMPTY
75561: LIST
75562: LIST
75563: PUSH
75564: LD_INT 1
75566: NEG
75567: PUSH
75568: LD_INT 0
75570: PUSH
75571: EMPTY
75572: LIST
75573: LIST
75574: PUSH
75575: LD_INT 1
75577: NEG
75578: PUSH
75579: LD_INT 1
75581: NEG
75582: PUSH
75583: EMPTY
75584: LIST
75585: LIST
75586: PUSH
75587: LD_INT 1
75589: PUSH
75590: LD_INT 1
75592: NEG
75593: PUSH
75594: EMPTY
75595: LIST
75596: LIST
75597: PUSH
75598: LD_INT 2
75600: PUSH
75601: LD_INT 0
75603: PUSH
75604: EMPTY
75605: LIST
75606: LIST
75607: PUSH
75608: LD_INT 2
75610: PUSH
75611: LD_INT 1
75613: PUSH
75614: EMPTY
75615: LIST
75616: LIST
75617: PUSH
75618: LD_INT 2
75620: PUSH
75621: LD_INT 2
75623: PUSH
75624: EMPTY
75625: LIST
75626: LIST
75627: PUSH
75628: LD_INT 1
75630: PUSH
75631: LD_INT 2
75633: PUSH
75634: EMPTY
75635: LIST
75636: LIST
75637: PUSH
75638: EMPTY
75639: LIST
75640: LIST
75641: LIST
75642: LIST
75643: LIST
75644: LIST
75645: LIST
75646: LIST
75647: LIST
75648: LIST
75649: LIST
75650: LIST
75651: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
75652: LD_ADDR_VAR 0 50
75656: PUSH
75657: LD_INT 0
75659: PUSH
75660: LD_INT 0
75662: PUSH
75663: EMPTY
75664: LIST
75665: LIST
75666: PUSH
75667: LD_INT 0
75669: PUSH
75670: LD_INT 1
75672: NEG
75673: PUSH
75674: EMPTY
75675: LIST
75676: LIST
75677: PUSH
75678: LD_INT 1
75680: PUSH
75681: LD_INT 0
75683: PUSH
75684: EMPTY
75685: LIST
75686: LIST
75687: PUSH
75688: LD_INT 1
75690: PUSH
75691: LD_INT 1
75693: PUSH
75694: EMPTY
75695: LIST
75696: LIST
75697: PUSH
75698: LD_INT 0
75700: PUSH
75701: LD_INT 1
75703: PUSH
75704: EMPTY
75705: LIST
75706: LIST
75707: PUSH
75708: LD_INT 1
75710: NEG
75711: PUSH
75712: LD_INT 0
75714: PUSH
75715: EMPTY
75716: LIST
75717: LIST
75718: PUSH
75719: LD_INT 1
75721: NEG
75722: PUSH
75723: LD_INT 1
75725: NEG
75726: PUSH
75727: EMPTY
75728: LIST
75729: LIST
75730: PUSH
75731: LD_INT 2
75733: PUSH
75734: LD_INT 1
75736: PUSH
75737: EMPTY
75738: LIST
75739: LIST
75740: PUSH
75741: LD_INT 2
75743: PUSH
75744: LD_INT 2
75746: PUSH
75747: EMPTY
75748: LIST
75749: LIST
75750: PUSH
75751: LD_INT 1
75753: PUSH
75754: LD_INT 2
75756: PUSH
75757: EMPTY
75758: LIST
75759: LIST
75760: PUSH
75761: LD_INT 0
75763: PUSH
75764: LD_INT 2
75766: PUSH
75767: EMPTY
75768: LIST
75769: LIST
75770: PUSH
75771: LD_INT 1
75773: NEG
75774: PUSH
75775: LD_INT 1
75777: PUSH
75778: EMPTY
75779: LIST
75780: LIST
75781: PUSH
75782: EMPTY
75783: LIST
75784: LIST
75785: LIST
75786: LIST
75787: LIST
75788: LIST
75789: LIST
75790: LIST
75791: LIST
75792: LIST
75793: LIST
75794: LIST
75795: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
75796: LD_ADDR_VAR 0 51
75800: PUSH
75801: LD_INT 0
75803: PUSH
75804: LD_INT 0
75806: PUSH
75807: EMPTY
75808: LIST
75809: LIST
75810: PUSH
75811: LD_INT 0
75813: PUSH
75814: LD_INT 1
75816: NEG
75817: PUSH
75818: EMPTY
75819: LIST
75820: LIST
75821: PUSH
75822: LD_INT 1
75824: PUSH
75825: LD_INT 0
75827: PUSH
75828: EMPTY
75829: LIST
75830: LIST
75831: PUSH
75832: LD_INT 1
75834: PUSH
75835: LD_INT 1
75837: PUSH
75838: EMPTY
75839: LIST
75840: LIST
75841: PUSH
75842: LD_INT 0
75844: PUSH
75845: LD_INT 1
75847: PUSH
75848: EMPTY
75849: LIST
75850: LIST
75851: PUSH
75852: LD_INT 1
75854: NEG
75855: PUSH
75856: LD_INT 0
75858: PUSH
75859: EMPTY
75860: LIST
75861: LIST
75862: PUSH
75863: LD_INT 1
75865: NEG
75866: PUSH
75867: LD_INT 1
75869: NEG
75870: PUSH
75871: EMPTY
75872: LIST
75873: LIST
75874: PUSH
75875: LD_INT 1
75877: PUSH
75878: LD_INT 2
75880: PUSH
75881: EMPTY
75882: LIST
75883: LIST
75884: PUSH
75885: LD_INT 0
75887: PUSH
75888: LD_INT 2
75890: PUSH
75891: EMPTY
75892: LIST
75893: LIST
75894: PUSH
75895: LD_INT 1
75897: NEG
75898: PUSH
75899: LD_INT 1
75901: PUSH
75902: EMPTY
75903: LIST
75904: LIST
75905: PUSH
75906: LD_INT 2
75908: NEG
75909: PUSH
75910: LD_INT 0
75912: PUSH
75913: EMPTY
75914: LIST
75915: LIST
75916: PUSH
75917: LD_INT 2
75919: NEG
75920: PUSH
75921: LD_INT 1
75923: NEG
75924: PUSH
75925: EMPTY
75926: LIST
75927: LIST
75928: PUSH
75929: EMPTY
75930: LIST
75931: LIST
75932: LIST
75933: LIST
75934: LIST
75935: LIST
75936: LIST
75937: LIST
75938: LIST
75939: LIST
75940: LIST
75941: LIST
75942: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75943: LD_ADDR_VAR 0 52
75947: PUSH
75948: LD_INT 0
75950: PUSH
75951: LD_INT 0
75953: PUSH
75954: EMPTY
75955: LIST
75956: LIST
75957: PUSH
75958: LD_INT 0
75960: PUSH
75961: LD_INT 1
75963: NEG
75964: PUSH
75965: EMPTY
75966: LIST
75967: LIST
75968: PUSH
75969: LD_INT 1
75971: PUSH
75972: LD_INT 0
75974: PUSH
75975: EMPTY
75976: LIST
75977: LIST
75978: PUSH
75979: LD_INT 1
75981: PUSH
75982: LD_INT 1
75984: PUSH
75985: EMPTY
75986: LIST
75987: LIST
75988: PUSH
75989: LD_INT 0
75991: PUSH
75992: LD_INT 1
75994: PUSH
75995: EMPTY
75996: LIST
75997: LIST
75998: PUSH
75999: LD_INT 1
76001: NEG
76002: PUSH
76003: LD_INT 0
76005: PUSH
76006: EMPTY
76007: LIST
76008: LIST
76009: PUSH
76010: LD_INT 1
76012: NEG
76013: PUSH
76014: LD_INT 1
76016: NEG
76017: PUSH
76018: EMPTY
76019: LIST
76020: LIST
76021: PUSH
76022: LD_INT 1
76024: NEG
76025: PUSH
76026: LD_INT 2
76028: NEG
76029: PUSH
76030: EMPTY
76031: LIST
76032: LIST
76033: PUSH
76034: LD_INT 1
76036: NEG
76037: PUSH
76038: LD_INT 1
76040: PUSH
76041: EMPTY
76042: LIST
76043: LIST
76044: PUSH
76045: LD_INT 2
76047: NEG
76048: PUSH
76049: LD_INT 0
76051: PUSH
76052: EMPTY
76053: LIST
76054: LIST
76055: PUSH
76056: LD_INT 2
76058: NEG
76059: PUSH
76060: LD_INT 1
76062: NEG
76063: PUSH
76064: EMPTY
76065: LIST
76066: LIST
76067: PUSH
76068: LD_INT 2
76070: NEG
76071: PUSH
76072: LD_INT 2
76074: NEG
76075: PUSH
76076: EMPTY
76077: LIST
76078: LIST
76079: PUSH
76080: EMPTY
76081: LIST
76082: LIST
76083: LIST
76084: LIST
76085: LIST
76086: LIST
76087: LIST
76088: LIST
76089: LIST
76090: LIST
76091: LIST
76092: LIST
76093: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76094: LD_ADDR_VAR 0 53
76098: PUSH
76099: LD_INT 0
76101: PUSH
76102: LD_INT 0
76104: PUSH
76105: EMPTY
76106: LIST
76107: LIST
76108: PUSH
76109: LD_INT 0
76111: PUSH
76112: LD_INT 1
76114: NEG
76115: PUSH
76116: EMPTY
76117: LIST
76118: LIST
76119: PUSH
76120: LD_INT 1
76122: PUSH
76123: LD_INT 0
76125: PUSH
76126: EMPTY
76127: LIST
76128: LIST
76129: PUSH
76130: LD_INT 1
76132: PUSH
76133: LD_INT 1
76135: PUSH
76136: EMPTY
76137: LIST
76138: LIST
76139: PUSH
76140: LD_INT 0
76142: PUSH
76143: LD_INT 1
76145: PUSH
76146: EMPTY
76147: LIST
76148: LIST
76149: PUSH
76150: LD_INT 1
76152: NEG
76153: PUSH
76154: LD_INT 0
76156: PUSH
76157: EMPTY
76158: LIST
76159: LIST
76160: PUSH
76161: LD_INT 1
76163: NEG
76164: PUSH
76165: LD_INT 1
76167: NEG
76168: PUSH
76169: EMPTY
76170: LIST
76171: LIST
76172: PUSH
76173: LD_INT 1
76175: NEG
76176: PUSH
76177: LD_INT 2
76179: NEG
76180: PUSH
76181: EMPTY
76182: LIST
76183: LIST
76184: PUSH
76185: LD_INT 0
76187: PUSH
76188: LD_INT 2
76190: NEG
76191: PUSH
76192: EMPTY
76193: LIST
76194: LIST
76195: PUSH
76196: LD_INT 1
76198: PUSH
76199: LD_INT 1
76201: NEG
76202: PUSH
76203: EMPTY
76204: LIST
76205: LIST
76206: PUSH
76207: LD_INT 2
76209: PUSH
76210: LD_INT 0
76212: PUSH
76213: EMPTY
76214: LIST
76215: LIST
76216: PUSH
76217: LD_INT 2
76219: PUSH
76220: LD_INT 1
76222: PUSH
76223: EMPTY
76224: LIST
76225: LIST
76226: PUSH
76227: LD_INT 2
76229: PUSH
76230: LD_INT 2
76232: PUSH
76233: EMPTY
76234: LIST
76235: LIST
76236: PUSH
76237: LD_INT 1
76239: PUSH
76240: LD_INT 2
76242: PUSH
76243: EMPTY
76244: LIST
76245: LIST
76246: PUSH
76247: LD_INT 0
76249: PUSH
76250: LD_INT 2
76252: PUSH
76253: EMPTY
76254: LIST
76255: LIST
76256: PUSH
76257: LD_INT 1
76259: NEG
76260: PUSH
76261: LD_INT 1
76263: PUSH
76264: EMPTY
76265: LIST
76266: LIST
76267: PUSH
76268: LD_INT 2
76270: NEG
76271: PUSH
76272: LD_INT 0
76274: PUSH
76275: EMPTY
76276: LIST
76277: LIST
76278: PUSH
76279: LD_INT 2
76281: NEG
76282: PUSH
76283: LD_INT 1
76285: NEG
76286: PUSH
76287: EMPTY
76288: LIST
76289: LIST
76290: PUSH
76291: LD_INT 2
76293: NEG
76294: PUSH
76295: LD_INT 2
76297: NEG
76298: PUSH
76299: EMPTY
76300: LIST
76301: LIST
76302: PUSH
76303: EMPTY
76304: LIST
76305: LIST
76306: LIST
76307: LIST
76308: LIST
76309: LIST
76310: LIST
76311: LIST
76312: LIST
76313: LIST
76314: LIST
76315: LIST
76316: LIST
76317: LIST
76318: LIST
76319: LIST
76320: LIST
76321: LIST
76322: LIST
76323: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76324: LD_ADDR_VAR 0 54
76328: PUSH
76329: LD_INT 0
76331: PUSH
76332: LD_INT 0
76334: PUSH
76335: EMPTY
76336: LIST
76337: LIST
76338: PUSH
76339: LD_INT 0
76341: PUSH
76342: LD_INT 1
76344: NEG
76345: PUSH
76346: EMPTY
76347: LIST
76348: LIST
76349: PUSH
76350: LD_INT 1
76352: PUSH
76353: LD_INT 0
76355: PUSH
76356: EMPTY
76357: LIST
76358: LIST
76359: PUSH
76360: LD_INT 1
76362: PUSH
76363: LD_INT 1
76365: PUSH
76366: EMPTY
76367: LIST
76368: LIST
76369: PUSH
76370: LD_INT 0
76372: PUSH
76373: LD_INT 1
76375: PUSH
76376: EMPTY
76377: LIST
76378: LIST
76379: PUSH
76380: LD_INT 1
76382: NEG
76383: PUSH
76384: LD_INT 0
76386: PUSH
76387: EMPTY
76388: LIST
76389: LIST
76390: PUSH
76391: LD_INT 1
76393: NEG
76394: PUSH
76395: LD_INT 1
76397: NEG
76398: PUSH
76399: EMPTY
76400: LIST
76401: LIST
76402: PUSH
76403: LD_INT 1
76405: NEG
76406: PUSH
76407: LD_INT 2
76409: NEG
76410: PUSH
76411: EMPTY
76412: LIST
76413: LIST
76414: PUSH
76415: LD_INT 0
76417: PUSH
76418: LD_INT 2
76420: NEG
76421: PUSH
76422: EMPTY
76423: LIST
76424: LIST
76425: PUSH
76426: LD_INT 1
76428: PUSH
76429: LD_INT 1
76431: NEG
76432: PUSH
76433: EMPTY
76434: LIST
76435: LIST
76436: PUSH
76437: LD_INT 2
76439: PUSH
76440: LD_INT 0
76442: PUSH
76443: EMPTY
76444: LIST
76445: LIST
76446: PUSH
76447: LD_INT 2
76449: PUSH
76450: LD_INT 1
76452: PUSH
76453: EMPTY
76454: LIST
76455: LIST
76456: PUSH
76457: LD_INT 2
76459: PUSH
76460: LD_INT 2
76462: PUSH
76463: EMPTY
76464: LIST
76465: LIST
76466: PUSH
76467: LD_INT 1
76469: PUSH
76470: LD_INT 2
76472: PUSH
76473: EMPTY
76474: LIST
76475: LIST
76476: PUSH
76477: LD_INT 0
76479: PUSH
76480: LD_INT 2
76482: PUSH
76483: EMPTY
76484: LIST
76485: LIST
76486: PUSH
76487: LD_INT 1
76489: NEG
76490: PUSH
76491: LD_INT 1
76493: PUSH
76494: EMPTY
76495: LIST
76496: LIST
76497: PUSH
76498: LD_INT 2
76500: NEG
76501: PUSH
76502: LD_INT 0
76504: PUSH
76505: EMPTY
76506: LIST
76507: LIST
76508: PUSH
76509: LD_INT 2
76511: NEG
76512: PUSH
76513: LD_INT 1
76515: NEG
76516: PUSH
76517: EMPTY
76518: LIST
76519: LIST
76520: PUSH
76521: LD_INT 2
76523: NEG
76524: PUSH
76525: LD_INT 2
76527: NEG
76528: PUSH
76529: EMPTY
76530: LIST
76531: LIST
76532: PUSH
76533: EMPTY
76534: LIST
76535: LIST
76536: LIST
76537: LIST
76538: LIST
76539: LIST
76540: LIST
76541: LIST
76542: LIST
76543: LIST
76544: LIST
76545: LIST
76546: LIST
76547: LIST
76548: LIST
76549: LIST
76550: LIST
76551: LIST
76552: LIST
76553: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76554: LD_ADDR_VAR 0 55
76558: PUSH
76559: LD_INT 0
76561: PUSH
76562: LD_INT 0
76564: PUSH
76565: EMPTY
76566: LIST
76567: LIST
76568: PUSH
76569: LD_INT 0
76571: PUSH
76572: LD_INT 1
76574: NEG
76575: PUSH
76576: EMPTY
76577: LIST
76578: LIST
76579: PUSH
76580: LD_INT 1
76582: PUSH
76583: LD_INT 0
76585: PUSH
76586: EMPTY
76587: LIST
76588: LIST
76589: PUSH
76590: LD_INT 1
76592: PUSH
76593: LD_INT 1
76595: PUSH
76596: EMPTY
76597: LIST
76598: LIST
76599: PUSH
76600: LD_INT 0
76602: PUSH
76603: LD_INT 1
76605: PUSH
76606: EMPTY
76607: LIST
76608: LIST
76609: PUSH
76610: LD_INT 1
76612: NEG
76613: PUSH
76614: LD_INT 0
76616: PUSH
76617: EMPTY
76618: LIST
76619: LIST
76620: PUSH
76621: LD_INT 1
76623: NEG
76624: PUSH
76625: LD_INT 1
76627: NEG
76628: PUSH
76629: EMPTY
76630: LIST
76631: LIST
76632: PUSH
76633: LD_INT 1
76635: NEG
76636: PUSH
76637: LD_INT 2
76639: NEG
76640: PUSH
76641: EMPTY
76642: LIST
76643: LIST
76644: PUSH
76645: LD_INT 0
76647: PUSH
76648: LD_INT 2
76650: NEG
76651: PUSH
76652: EMPTY
76653: LIST
76654: LIST
76655: PUSH
76656: LD_INT 1
76658: PUSH
76659: LD_INT 1
76661: NEG
76662: PUSH
76663: EMPTY
76664: LIST
76665: LIST
76666: PUSH
76667: LD_INT 2
76669: PUSH
76670: LD_INT 0
76672: PUSH
76673: EMPTY
76674: LIST
76675: LIST
76676: PUSH
76677: LD_INT 2
76679: PUSH
76680: LD_INT 1
76682: PUSH
76683: EMPTY
76684: LIST
76685: LIST
76686: PUSH
76687: LD_INT 2
76689: PUSH
76690: LD_INT 2
76692: PUSH
76693: EMPTY
76694: LIST
76695: LIST
76696: PUSH
76697: LD_INT 1
76699: PUSH
76700: LD_INT 2
76702: PUSH
76703: EMPTY
76704: LIST
76705: LIST
76706: PUSH
76707: LD_INT 0
76709: PUSH
76710: LD_INT 2
76712: PUSH
76713: EMPTY
76714: LIST
76715: LIST
76716: PUSH
76717: LD_INT 1
76719: NEG
76720: PUSH
76721: LD_INT 1
76723: PUSH
76724: EMPTY
76725: LIST
76726: LIST
76727: PUSH
76728: LD_INT 2
76730: NEG
76731: PUSH
76732: LD_INT 0
76734: PUSH
76735: EMPTY
76736: LIST
76737: LIST
76738: PUSH
76739: LD_INT 2
76741: NEG
76742: PUSH
76743: LD_INT 1
76745: NEG
76746: PUSH
76747: EMPTY
76748: LIST
76749: LIST
76750: PUSH
76751: LD_INT 2
76753: NEG
76754: PUSH
76755: LD_INT 2
76757: NEG
76758: PUSH
76759: EMPTY
76760: LIST
76761: LIST
76762: PUSH
76763: EMPTY
76764: LIST
76765: LIST
76766: LIST
76767: LIST
76768: LIST
76769: LIST
76770: LIST
76771: LIST
76772: LIST
76773: LIST
76774: LIST
76775: LIST
76776: LIST
76777: LIST
76778: LIST
76779: LIST
76780: LIST
76781: LIST
76782: LIST
76783: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76784: LD_ADDR_VAR 0 56
76788: PUSH
76789: LD_INT 0
76791: PUSH
76792: LD_INT 0
76794: PUSH
76795: EMPTY
76796: LIST
76797: LIST
76798: PUSH
76799: LD_INT 0
76801: PUSH
76802: LD_INT 1
76804: NEG
76805: PUSH
76806: EMPTY
76807: LIST
76808: LIST
76809: PUSH
76810: LD_INT 1
76812: PUSH
76813: LD_INT 0
76815: PUSH
76816: EMPTY
76817: LIST
76818: LIST
76819: PUSH
76820: LD_INT 1
76822: PUSH
76823: LD_INT 1
76825: PUSH
76826: EMPTY
76827: LIST
76828: LIST
76829: PUSH
76830: LD_INT 0
76832: PUSH
76833: LD_INT 1
76835: PUSH
76836: EMPTY
76837: LIST
76838: LIST
76839: PUSH
76840: LD_INT 1
76842: NEG
76843: PUSH
76844: LD_INT 0
76846: PUSH
76847: EMPTY
76848: LIST
76849: LIST
76850: PUSH
76851: LD_INT 1
76853: NEG
76854: PUSH
76855: LD_INT 1
76857: NEG
76858: PUSH
76859: EMPTY
76860: LIST
76861: LIST
76862: PUSH
76863: LD_INT 1
76865: NEG
76866: PUSH
76867: LD_INT 2
76869: NEG
76870: PUSH
76871: EMPTY
76872: LIST
76873: LIST
76874: PUSH
76875: LD_INT 0
76877: PUSH
76878: LD_INT 2
76880: NEG
76881: PUSH
76882: EMPTY
76883: LIST
76884: LIST
76885: PUSH
76886: LD_INT 1
76888: PUSH
76889: LD_INT 1
76891: NEG
76892: PUSH
76893: EMPTY
76894: LIST
76895: LIST
76896: PUSH
76897: LD_INT 2
76899: PUSH
76900: LD_INT 0
76902: PUSH
76903: EMPTY
76904: LIST
76905: LIST
76906: PUSH
76907: LD_INT 2
76909: PUSH
76910: LD_INT 1
76912: PUSH
76913: EMPTY
76914: LIST
76915: LIST
76916: PUSH
76917: LD_INT 2
76919: PUSH
76920: LD_INT 2
76922: PUSH
76923: EMPTY
76924: LIST
76925: LIST
76926: PUSH
76927: LD_INT 1
76929: PUSH
76930: LD_INT 2
76932: PUSH
76933: EMPTY
76934: LIST
76935: LIST
76936: PUSH
76937: LD_INT 0
76939: PUSH
76940: LD_INT 2
76942: PUSH
76943: EMPTY
76944: LIST
76945: LIST
76946: PUSH
76947: LD_INT 1
76949: NEG
76950: PUSH
76951: LD_INT 1
76953: PUSH
76954: EMPTY
76955: LIST
76956: LIST
76957: PUSH
76958: LD_INT 2
76960: NEG
76961: PUSH
76962: LD_INT 0
76964: PUSH
76965: EMPTY
76966: LIST
76967: LIST
76968: PUSH
76969: LD_INT 2
76971: NEG
76972: PUSH
76973: LD_INT 1
76975: NEG
76976: PUSH
76977: EMPTY
76978: LIST
76979: LIST
76980: PUSH
76981: LD_INT 2
76983: NEG
76984: PUSH
76985: LD_INT 2
76987: NEG
76988: PUSH
76989: EMPTY
76990: LIST
76991: LIST
76992: PUSH
76993: EMPTY
76994: LIST
76995: LIST
76996: LIST
76997: LIST
76998: LIST
76999: LIST
77000: LIST
77001: LIST
77002: LIST
77003: LIST
77004: LIST
77005: LIST
77006: LIST
77007: LIST
77008: LIST
77009: LIST
77010: LIST
77011: LIST
77012: LIST
77013: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77014: LD_ADDR_VAR 0 57
77018: PUSH
77019: LD_INT 0
77021: PUSH
77022: LD_INT 0
77024: PUSH
77025: EMPTY
77026: LIST
77027: LIST
77028: PUSH
77029: LD_INT 0
77031: PUSH
77032: LD_INT 1
77034: NEG
77035: PUSH
77036: EMPTY
77037: LIST
77038: LIST
77039: PUSH
77040: LD_INT 1
77042: PUSH
77043: LD_INT 0
77045: PUSH
77046: EMPTY
77047: LIST
77048: LIST
77049: PUSH
77050: LD_INT 1
77052: PUSH
77053: LD_INT 1
77055: PUSH
77056: EMPTY
77057: LIST
77058: LIST
77059: PUSH
77060: LD_INT 0
77062: PUSH
77063: LD_INT 1
77065: PUSH
77066: EMPTY
77067: LIST
77068: LIST
77069: PUSH
77070: LD_INT 1
77072: NEG
77073: PUSH
77074: LD_INT 0
77076: PUSH
77077: EMPTY
77078: LIST
77079: LIST
77080: PUSH
77081: LD_INT 1
77083: NEG
77084: PUSH
77085: LD_INT 1
77087: NEG
77088: PUSH
77089: EMPTY
77090: LIST
77091: LIST
77092: PUSH
77093: LD_INT 1
77095: NEG
77096: PUSH
77097: LD_INT 2
77099: NEG
77100: PUSH
77101: EMPTY
77102: LIST
77103: LIST
77104: PUSH
77105: LD_INT 0
77107: PUSH
77108: LD_INT 2
77110: NEG
77111: PUSH
77112: EMPTY
77113: LIST
77114: LIST
77115: PUSH
77116: LD_INT 1
77118: PUSH
77119: LD_INT 1
77121: NEG
77122: PUSH
77123: EMPTY
77124: LIST
77125: LIST
77126: PUSH
77127: LD_INT 2
77129: PUSH
77130: LD_INT 0
77132: PUSH
77133: EMPTY
77134: LIST
77135: LIST
77136: PUSH
77137: LD_INT 2
77139: PUSH
77140: LD_INT 1
77142: PUSH
77143: EMPTY
77144: LIST
77145: LIST
77146: PUSH
77147: LD_INT 2
77149: PUSH
77150: LD_INT 2
77152: PUSH
77153: EMPTY
77154: LIST
77155: LIST
77156: PUSH
77157: LD_INT 1
77159: PUSH
77160: LD_INT 2
77162: PUSH
77163: EMPTY
77164: LIST
77165: LIST
77166: PUSH
77167: LD_INT 0
77169: PUSH
77170: LD_INT 2
77172: PUSH
77173: EMPTY
77174: LIST
77175: LIST
77176: PUSH
77177: LD_INT 1
77179: NEG
77180: PUSH
77181: LD_INT 1
77183: PUSH
77184: EMPTY
77185: LIST
77186: LIST
77187: PUSH
77188: LD_INT 2
77190: NEG
77191: PUSH
77192: LD_INT 0
77194: PUSH
77195: EMPTY
77196: LIST
77197: LIST
77198: PUSH
77199: LD_INT 2
77201: NEG
77202: PUSH
77203: LD_INT 1
77205: NEG
77206: PUSH
77207: EMPTY
77208: LIST
77209: LIST
77210: PUSH
77211: LD_INT 2
77213: NEG
77214: PUSH
77215: LD_INT 2
77217: NEG
77218: PUSH
77219: EMPTY
77220: LIST
77221: LIST
77222: PUSH
77223: EMPTY
77224: LIST
77225: LIST
77226: LIST
77227: LIST
77228: LIST
77229: LIST
77230: LIST
77231: LIST
77232: LIST
77233: LIST
77234: LIST
77235: LIST
77236: LIST
77237: LIST
77238: LIST
77239: LIST
77240: LIST
77241: LIST
77242: LIST
77243: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77244: LD_ADDR_VAR 0 58
77248: PUSH
77249: LD_INT 0
77251: PUSH
77252: LD_INT 0
77254: PUSH
77255: EMPTY
77256: LIST
77257: LIST
77258: PUSH
77259: LD_INT 0
77261: PUSH
77262: LD_INT 1
77264: NEG
77265: PUSH
77266: EMPTY
77267: LIST
77268: LIST
77269: PUSH
77270: LD_INT 1
77272: PUSH
77273: LD_INT 0
77275: PUSH
77276: EMPTY
77277: LIST
77278: LIST
77279: PUSH
77280: LD_INT 1
77282: PUSH
77283: LD_INT 1
77285: PUSH
77286: EMPTY
77287: LIST
77288: LIST
77289: PUSH
77290: LD_INT 0
77292: PUSH
77293: LD_INT 1
77295: PUSH
77296: EMPTY
77297: LIST
77298: LIST
77299: PUSH
77300: LD_INT 1
77302: NEG
77303: PUSH
77304: LD_INT 0
77306: PUSH
77307: EMPTY
77308: LIST
77309: LIST
77310: PUSH
77311: LD_INT 1
77313: NEG
77314: PUSH
77315: LD_INT 1
77317: NEG
77318: PUSH
77319: EMPTY
77320: LIST
77321: LIST
77322: PUSH
77323: LD_INT 1
77325: NEG
77326: PUSH
77327: LD_INT 2
77329: NEG
77330: PUSH
77331: EMPTY
77332: LIST
77333: LIST
77334: PUSH
77335: LD_INT 0
77337: PUSH
77338: LD_INT 2
77340: NEG
77341: PUSH
77342: EMPTY
77343: LIST
77344: LIST
77345: PUSH
77346: LD_INT 1
77348: PUSH
77349: LD_INT 1
77351: NEG
77352: PUSH
77353: EMPTY
77354: LIST
77355: LIST
77356: PUSH
77357: LD_INT 2
77359: PUSH
77360: LD_INT 0
77362: PUSH
77363: EMPTY
77364: LIST
77365: LIST
77366: PUSH
77367: LD_INT 2
77369: PUSH
77370: LD_INT 1
77372: PUSH
77373: EMPTY
77374: LIST
77375: LIST
77376: PUSH
77377: LD_INT 2
77379: PUSH
77380: LD_INT 2
77382: PUSH
77383: EMPTY
77384: LIST
77385: LIST
77386: PUSH
77387: LD_INT 1
77389: PUSH
77390: LD_INT 2
77392: PUSH
77393: EMPTY
77394: LIST
77395: LIST
77396: PUSH
77397: LD_INT 0
77399: PUSH
77400: LD_INT 2
77402: PUSH
77403: EMPTY
77404: LIST
77405: LIST
77406: PUSH
77407: LD_INT 1
77409: NEG
77410: PUSH
77411: LD_INT 1
77413: PUSH
77414: EMPTY
77415: LIST
77416: LIST
77417: PUSH
77418: LD_INT 2
77420: NEG
77421: PUSH
77422: LD_INT 0
77424: PUSH
77425: EMPTY
77426: LIST
77427: LIST
77428: PUSH
77429: LD_INT 2
77431: NEG
77432: PUSH
77433: LD_INT 1
77435: NEG
77436: PUSH
77437: EMPTY
77438: LIST
77439: LIST
77440: PUSH
77441: LD_INT 2
77443: NEG
77444: PUSH
77445: LD_INT 2
77447: NEG
77448: PUSH
77449: EMPTY
77450: LIST
77451: LIST
77452: PUSH
77453: EMPTY
77454: LIST
77455: LIST
77456: LIST
77457: LIST
77458: LIST
77459: LIST
77460: LIST
77461: LIST
77462: LIST
77463: LIST
77464: LIST
77465: LIST
77466: LIST
77467: LIST
77468: LIST
77469: LIST
77470: LIST
77471: LIST
77472: LIST
77473: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77474: LD_ADDR_VAR 0 59
77478: PUSH
77479: LD_INT 0
77481: PUSH
77482: LD_INT 0
77484: PUSH
77485: EMPTY
77486: LIST
77487: LIST
77488: PUSH
77489: LD_INT 0
77491: PUSH
77492: LD_INT 1
77494: NEG
77495: PUSH
77496: EMPTY
77497: LIST
77498: LIST
77499: PUSH
77500: LD_INT 1
77502: PUSH
77503: LD_INT 0
77505: PUSH
77506: EMPTY
77507: LIST
77508: LIST
77509: PUSH
77510: LD_INT 1
77512: PUSH
77513: LD_INT 1
77515: PUSH
77516: EMPTY
77517: LIST
77518: LIST
77519: PUSH
77520: LD_INT 0
77522: PUSH
77523: LD_INT 1
77525: PUSH
77526: EMPTY
77527: LIST
77528: LIST
77529: PUSH
77530: LD_INT 1
77532: NEG
77533: PUSH
77534: LD_INT 0
77536: PUSH
77537: EMPTY
77538: LIST
77539: LIST
77540: PUSH
77541: LD_INT 1
77543: NEG
77544: PUSH
77545: LD_INT 1
77547: NEG
77548: PUSH
77549: EMPTY
77550: LIST
77551: LIST
77552: PUSH
77553: EMPTY
77554: LIST
77555: LIST
77556: LIST
77557: LIST
77558: LIST
77559: LIST
77560: LIST
77561: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77562: LD_ADDR_VAR 0 60
77566: PUSH
77567: LD_INT 0
77569: PUSH
77570: LD_INT 0
77572: PUSH
77573: EMPTY
77574: LIST
77575: LIST
77576: PUSH
77577: LD_INT 0
77579: PUSH
77580: LD_INT 1
77582: NEG
77583: PUSH
77584: EMPTY
77585: LIST
77586: LIST
77587: PUSH
77588: LD_INT 1
77590: PUSH
77591: LD_INT 0
77593: PUSH
77594: EMPTY
77595: LIST
77596: LIST
77597: PUSH
77598: LD_INT 1
77600: PUSH
77601: LD_INT 1
77603: PUSH
77604: EMPTY
77605: LIST
77606: LIST
77607: PUSH
77608: LD_INT 0
77610: PUSH
77611: LD_INT 1
77613: PUSH
77614: EMPTY
77615: LIST
77616: LIST
77617: PUSH
77618: LD_INT 1
77620: NEG
77621: PUSH
77622: LD_INT 0
77624: PUSH
77625: EMPTY
77626: LIST
77627: LIST
77628: PUSH
77629: LD_INT 1
77631: NEG
77632: PUSH
77633: LD_INT 1
77635: NEG
77636: PUSH
77637: EMPTY
77638: LIST
77639: LIST
77640: PUSH
77641: EMPTY
77642: LIST
77643: LIST
77644: LIST
77645: LIST
77646: LIST
77647: LIST
77648: LIST
77649: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77650: LD_ADDR_VAR 0 61
77654: PUSH
77655: LD_INT 0
77657: PUSH
77658: LD_INT 0
77660: PUSH
77661: EMPTY
77662: LIST
77663: LIST
77664: PUSH
77665: LD_INT 0
77667: PUSH
77668: LD_INT 1
77670: NEG
77671: PUSH
77672: EMPTY
77673: LIST
77674: LIST
77675: PUSH
77676: LD_INT 1
77678: PUSH
77679: LD_INT 0
77681: PUSH
77682: EMPTY
77683: LIST
77684: LIST
77685: PUSH
77686: LD_INT 1
77688: PUSH
77689: LD_INT 1
77691: PUSH
77692: EMPTY
77693: LIST
77694: LIST
77695: PUSH
77696: LD_INT 0
77698: PUSH
77699: LD_INT 1
77701: PUSH
77702: EMPTY
77703: LIST
77704: LIST
77705: PUSH
77706: LD_INT 1
77708: NEG
77709: PUSH
77710: LD_INT 0
77712: PUSH
77713: EMPTY
77714: LIST
77715: LIST
77716: PUSH
77717: LD_INT 1
77719: NEG
77720: PUSH
77721: LD_INT 1
77723: NEG
77724: PUSH
77725: EMPTY
77726: LIST
77727: LIST
77728: PUSH
77729: EMPTY
77730: LIST
77731: LIST
77732: LIST
77733: LIST
77734: LIST
77735: LIST
77736: LIST
77737: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77738: LD_ADDR_VAR 0 62
77742: PUSH
77743: LD_INT 0
77745: PUSH
77746: LD_INT 0
77748: PUSH
77749: EMPTY
77750: LIST
77751: LIST
77752: PUSH
77753: LD_INT 0
77755: PUSH
77756: LD_INT 1
77758: NEG
77759: PUSH
77760: EMPTY
77761: LIST
77762: LIST
77763: PUSH
77764: LD_INT 1
77766: PUSH
77767: LD_INT 0
77769: PUSH
77770: EMPTY
77771: LIST
77772: LIST
77773: PUSH
77774: LD_INT 1
77776: PUSH
77777: LD_INT 1
77779: PUSH
77780: EMPTY
77781: LIST
77782: LIST
77783: PUSH
77784: LD_INT 0
77786: PUSH
77787: LD_INT 1
77789: PUSH
77790: EMPTY
77791: LIST
77792: LIST
77793: PUSH
77794: LD_INT 1
77796: NEG
77797: PUSH
77798: LD_INT 0
77800: PUSH
77801: EMPTY
77802: LIST
77803: LIST
77804: PUSH
77805: LD_INT 1
77807: NEG
77808: PUSH
77809: LD_INT 1
77811: NEG
77812: PUSH
77813: EMPTY
77814: LIST
77815: LIST
77816: PUSH
77817: EMPTY
77818: LIST
77819: LIST
77820: LIST
77821: LIST
77822: LIST
77823: LIST
77824: LIST
77825: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77826: LD_ADDR_VAR 0 63
77830: PUSH
77831: LD_INT 0
77833: PUSH
77834: LD_INT 0
77836: PUSH
77837: EMPTY
77838: LIST
77839: LIST
77840: PUSH
77841: LD_INT 0
77843: PUSH
77844: LD_INT 1
77846: NEG
77847: PUSH
77848: EMPTY
77849: LIST
77850: LIST
77851: PUSH
77852: LD_INT 1
77854: PUSH
77855: LD_INT 0
77857: PUSH
77858: EMPTY
77859: LIST
77860: LIST
77861: PUSH
77862: LD_INT 1
77864: PUSH
77865: LD_INT 1
77867: PUSH
77868: EMPTY
77869: LIST
77870: LIST
77871: PUSH
77872: LD_INT 0
77874: PUSH
77875: LD_INT 1
77877: PUSH
77878: EMPTY
77879: LIST
77880: LIST
77881: PUSH
77882: LD_INT 1
77884: NEG
77885: PUSH
77886: LD_INT 0
77888: PUSH
77889: EMPTY
77890: LIST
77891: LIST
77892: PUSH
77893: LD_INT 1
77895: NEG
77896: PUSH
77897: LD_INT 1
77899: NEG
77900: PUSH
77901: EMPTY
77902: LIST
77903: LIST
77904: PUSH
77905: EMPTY
77906: LIST
77907: LIST
77908: LIST
77909: LIST
77910: LIST
77911: LIST
77912: LIST
77913: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77914: LD_ADDR_VAR 0 64
77918: PUSH
77919: LD_INT 0
77921: PUSH
77922: LD_INT 0
77924: PUSH
77925: EMPTY
77926: LIST
77927: LIST
77928: PUSH
77929: LD_INT 0
77931: PUSH
77932: LD_INT 1
77934: NEG
77935: PUSH
77936: EMPTY
77937: LIST
77938: LIST
77939: PUSH
77940: LD_INT 1
77942: PUSH
77943: LD_INT 0
77945: PUSH
77946: EMPTY
77947: LIST
77948: LIST
77949: PUSH
77950: LD_INT 1
77952: PUSH
77953: LD_INT 1
77955: PUSH
77956: EMPTY
77957: LIST
77958: LIST
77959: PUSH
77960: LD_INT 0
77962: PUSH
77963: LD_INT 1
77965: PUSH
77966: EMPTY
77967: LIST
77968: LIST
77969: PUSH
77970: LD_INT 1
77972: NEG
77973: PUSH
77974: LD_INT 0
77976: PUSH
77977: EMPTY
77978: LIST
77979: LIST
77980: PUSH
77981: LD_INT 1
77983: NEG
77984: PUSH
77985: LD_INT 1
77987: NEG
77988: PUSH
77989: EMPTY
77990: LIST
77991: LIST
77992: PUSH
77993: EMPTY
77994: LIST
77995: LIST
77996: LIST
77997: LIST
77998: LIST
77999: LIST
78000: LIST
78001: ST_TO_ADDR
// end ; 1 :
78002: GO 83899
78004: LD_INT 1
78006: DOUBLE
78007: EQUAL
78008: IFTRUE 78012
78010: GO 80635
78012: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
78013: LD_ADDR_VAR 0 11
78017: PUSH
78018: LD_INT 1
78020: NEG
78021: PUSH
78022: LD_INT 3
78024: NEG
78025: PUSH
78026: EMPTY
78027: LIST
78028: LIST
78029: PUSH
78030: LD_INT 0
78032: PUSH
78033: LD_INT 3
78035: NEG
78036: PUSH
78037: EMPTY
78038: LIST
78039: LIST
78040: PUSH
78041: LD_INT 1
78043: PUSH
78044: LD_INT 2
78046: NEG
78047: PUSH
78048: EMPTY
78049: LIST
78050: LIST
78051: PUSH
78052: EMPTY
78053: LIST
78054: LIST
78055: LIST
78056: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
78057: LD_ADDR_VAR 0 12
78061: PUSH
78062: LD_INT 2
78064: PUSH
78065: LD_INT 1
78067: NEG
78068: PUSH
78069: EMPTY
78070: LIST
78071: LIST
78072: PUSH
78073: LD_INT 3
78075: PUSH
78076: LD_INT 0
78078: PUSH
78079: EMPTY
78080: LIST
78081: LIST
78082: PUSH
78083: LD_INT 3
78085: PUSH
78086: LD_INT 1
78088: PUSH
78089: EMPTY
78090: LIST
78091: LIST
78092: PUSH
78093: EMPTY
78094: LIST
78095: LIST
78096: LIST
78097: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78098: LD_ADDR_VAR 0 13
78102: PUSH
78103: LD_INT 3
78105: PUSH
78106: LD_INT 2
78108: PUSH
78109: EMPTY
78110: LIST
78111: LIST
78112: PUSH
78113: LD_INT 3
78115: PUSH
78116: LD_INT 3
78118: PUSH
78119: EMPTY
78120: LIST
78121: LIST
78122: PUSH
78123: LD_INT 2
78125: PUSH
78126: LD_INT 3
78128: PUSH
78129: EMPTY
78130: LIST
78131: LIST
78132: PUSH
78133: EMPTY
78134: LIST
78135: LIST
78136: LIST
78137: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78138: LD_ADDR_VAR 0 14
78142: PUSH
78143: LD_INT 1
78145: PUSH
78146: LD_INT 3
78148: PUSH
78149: EMPTY
78150: LIST
78151: LIST
78152: PUSH
78153: LD_INT 0
78155: PUSH
78156: LD_INT 3
78158: PUSH
78159: EMPTY
78160: LIST
78161: LIST
78162: PUSH
78163: LD_INT 1
78165: NEG
78166: PUSH
78167: LD_INT 2
78169: PUSH
78170: EMPTY
78171: LIST
78172: LIST
78173: PUSH
78174: EMPTY
78175: LIST
78176: LIST
78177: LIST
78178: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78179: LD_ADDR_VAR 0 15
78183: PUSH
78184: LD_INT 2
78186: NEG
78187: PUSH
78188: LD_INT 1
78190: PUSH
78191: EMPTY
78192: LIST
78193: LIST
78194: PUSH
78195: LD_INT 3
78197: NEG
78198: PUSH
78199: LD_INT 0
78201: PUSH
78202: EMPTY
78203: LIST
78204: LIST
78205: PUSH
78206: LD_INT 3
78208: NEG
78209: PUSH
78210: LD_INT 1
78212: NEG
78213: PUSH
78214: EMPTY
78215: LIST
78216: LIST
78217: PUSH
78218: EMPTY
78219: LIST
78220: LIST
78221: LIST
78222: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78223: LD_ADDR_VAR 0 16
78227: PUSH
78228: LD_INT 2
78230: NEG
78231: PUSH
78232: LD_INT 3
78234: NEG
78235: PUSH
78236: EMPTY
78237: LIST
78238: LIST
78239: PUSH
78240: LD_INT 3
78242: NEG
78243: PUSH
78244: LD_INT 2
78246: NEG
78247: PUSH
78248: EMPTY
78249: LIST
78250: LIST
78251: PUSH
78252: LD_INT 3
78254: NEG
78255: PUSH
78256: LD_INT 3
78258: NEG
78259: PUSH
78260: EMPTY
78261: LIST
78262: LIST
78263: PUSH
78264: EMPTY
78265: LIST
78266: LIST
78267: LIST
78268: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
78269: LD_ADDR_VAR 0 17
78273: PUSH
78274: LD_INT 1
78276: NEG
78277: PUSH
78278: LD_INT 3
78280: NEG
78281: PUSH
78282: EMPTY
78283: LIST
78284: LIST
78285: PUSH
78286: LD_INT 0
78288: PUSH
78289: LD_INT 3
78291: NEG
78292: PUSH
78293: EMPTY
78294: LIST
78295: LIST
78296: PUSH
78297: LD_INT 1
78299: PUSH
78300: LD_INT 2
78302: NEG
78303: PUSH
78304: EMPTY
78305: LIST
78306: LIST
78307: PUSH
78308: EMPTY
78309: LIST
78310: LIST
78311: LIST
78312: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
78313: LD_ADDR_VAR 0 18
78317: PUSH
78318: LD_INT 2
78320: PUSH
78321: LD_INT 1
78323: NEG
78324: PUSH
78325: EMPTY
78326: LIST
78327: LIST
78328: PUSH
78329: LD_INT 3
78331: PUSH
78332: LD_INT 0
78334: PUSH
78335: EMPTY
78336: LIST
78337: LIST
78338: PUSH
78339: LD_INT 3
78341: PUSH
78342: LD_INT 1
78344: PUSH
78345: EMPTY
78346: LIST
78347: LIST
78348: PUSH
78349: EMPTY
78350: LIST
78351: LIST
78352: LIST
78353: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78354: LD_ADDR_VAR 0 19
78358: PUSH
78359: LD_INT 3
78361: PUSH
78362: LD_INT 2
78364: PUSH
78365: EMPTY
78366: LIST
78367: LIST
78368: PUSH
78369: LD_INT 3
78371: PUSH
78372: LD_INT 3
78374: PUSH
78375: EMPTY
78376: LIST
78377: LIST
78378: PUSH
78379: LD_INT 2
78381: PUSH
78382: LD_INT 3
78384: PUSH
78385: EMPTY
78386: LIST
78387: LIST
78388: PUSH
78389: EMPTY
78390: LIST
78391: LIST
78392: LIST
78393: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78394: LD_ADDR_VAR 0 20
78398: PUSH
78399: LD_INT 1
78401: PUSH
78402: LD_INT 3
78404: PUSH
78405: EMPTY
78406: LIST
78407: LIST
78408: PUSH
78409: LD_INT 0
78411: PUSH
78412: LD_INT 3
78414: PUSH
78415: EMPTY
78416: LIST
78417: LIST
78418: PUSH
78419: LD_INT 1
78421: NEG
78422: PUSH
78423: LD_INT 2
78425: PUSH
78426: EMPTY
78427: LIST
78428: LIST
78429: PUSH
78430: EMPTY
78431: LIST
78432: LIST
78433: LIST
78434: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78435: LD_ADDR_VAR 0 21
78439: PUSH
78440: LD_INT 2
78442: NEG
78443: PUSH
78444: LD_INT 1
78446: PUSH
78447: EMPTY
78448: LIST
78449: LIST
78450: PUSH
78451: LD_INT 3
78453: NEG
78454: PUSH
78455: LD_INT 0
78457: PUSH
78458: EMPTY
78459: LIST
78460: LIST
78461: PUSH
78462: LD_INT 3
78464: NEG
78465: PUSH
78466: LD_INT 1
78468: NEG
78469: PUSH
78470: EMPTY
78471: LIST
78472: LIST
78473: PUSH
78474: EMPTY
78475: LIST
78476: LIST
78477: LIST
78478: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78479: LD_ADDR_VAR 0 22
78483: PUSH
78484: LD_INT 2
78486: NEG
78487: PUSH
78488: LD_INT 3
78490: NEG
78491: PUSH
78492: EMPTY
78493: LIST
78494: LIST
78495: PUSH
78496: LD_INT 3
78498: NEG
78499: PUSH
78500: LD_INT 2
78502: NEG
78503: PUSH
78504: EMPTY
78505: LIST
78506: LIST
78507: PUSH
78508: LD_INT 3
78510: NEG
78511: PUSH
78512: LD_INT 3
78514: NEG
78515: PUSH
78516: EMPTY
78517: LIST
78518: LIST
78519: PUSH
78520: EMPTY
78521: LIST
78522: LIST
78523: LIST
78524: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
78525: LD_ADDR_VAR 0 23
78529: PUSH
78530: LD_INT 0
78532: PUSH
78533: LD_INT 3
78535: NEG
78536: PUSH
78537: EMPTY
78538: LIST
78539: LIST
78540: PUSH
78541: LD_INT 1
78543: NEG
78544: PUSH
78545: LD_INT 4
78547: NEG
78548: PUSH
78549: EMPTY
78550: LIST
78551: LIST
78552: PUSH
78553: LD_INT 1
78555: PUSH
78556: LD_INT 3
78558: NEG
78559: PUSH
78560: EMPTY
78561: LIST
78562: LIST
78563: PUSH
78564: EMPTY
78565: LIST
78566: LIST
78567: LIST
78568: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
78569: LD_ADDR_VAR 0 24
78573: PUSH
78574: LD_INT 3
78576: PUSH
78577: LD_INT 0
78579: PUSH
78580: EMPTY
78581: LIST
78582: LIST
78583: PUSH
78584: LD_INT 3
78586: PUSH
78587: LD_INT 1
78589: NEG
78590: PUSH
78591: EMPTY
78592: LIST
78593: LIST
78594: PUSH
78595: LD_INT 4
78597: PUSH
78598: LD_INT 1
78600: PUSH
78601: EMPTY
78602: LIST
78603: LIST
78604: PUSH
78605: EMPTY
78606: LIST
78607: LIST
78608: LIST
78609: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
78610: LD_ADDR_VAR 0 25
78614: PUSH
78615: LD_INT 3
78617: PUSH
78618: LD_INT 3
78620: PUSH
78621: EMPTY
78622: LIST
78623: LIST
78624: PUSH
78625: LD_INT 4
78627: PUSH
78628: LD_INT 3
78630: PUSH
78631: EMPTY
78632: LIST
78633: LIST
78634: PUSH
78635: LD_INT 3
78637: PUSH
78638: LD_INT 4
78640: PUSH
78641: EMPTY
78642: LIST
78643: LIST
78644: PUSH
78645: EMPTY
78646: LIST
78647: LIST
78648: LIST
78649: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
78650: LD_ADDR_VAR 0 26
78654: PUSH
78655: LD_INT 0
78657: PUSH
78658: LD_INT 3
78660: PUSH
78661: EMPTY
78662: LIST
78663: LIST
78664: PUSH
78665: LD_INT 1
78667: PUSH
78668: LD_INT 4
78670: PUSH
78671: EMPTY
78672: LIST
78673: LIST
78674: PUSH
78675: LD_INT 1
78677: NEG
78678: PUSH
78679: LD_INT 3
78681: PUSH
78682: EMPTY
78683: LIST
78684: LIST
78685: PUSH
78686: EMPTY
78687: LIST
78688: LIST
78689: LIST
78690: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
78691: LD_ADDR_VAR 0 27
78695: PUSH
78696: LD_INT 3
78698: NEG
78699: PUSH
78700: LD_INT 0
78702: PUSH
78703: EMPTY
78704: LIST
78705: LIST
78706: PUSH
78707: LD_INT 3
78709: NEG
78710: PUSH
78711: LD_INT 1
78713: PUSH
78714: EMPTY
78715: LIST
78716: LIST
78717: PUSH
78718: LD_INT 4
78720: NEG
78721: PUSH
78722: LD_INT 1
78724: NEG
78725: PUSH
78726: EMPTY
78727: LIST
78728: LIST
78729: PUSH
78730: EMPTY
78731: LIST
78732: LIST
78733: LIST
78734: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
78735: LD_ADDR_VAR 0 28
78739: PUSH
78740: LD_INT 3
78742: NEG
78743: PUSH
78744: LD_INT 3
78746: NEG
78747: PUSH
78748: EMPTY
78749: LIST
78750: LIST
78751: PUSH
78752: LD_INT 3
78754: NEG
78755: PUSH
78756: LD_INT 4
78758: NEG
78759: PUSH
78760: EMPTY
78761: LIST
78762: LIST
78763: PUSH
78764: LD_INT 4
78766: NEG
78767: PUSH
78768: LD_INT 3
78770: NEG
78771: PUSH
78772: EMPTY
78773: LIST
78774: LIST
78775: PUSH
78776: EMPTY
78777: LIST
78778: LIST
78779: LIST
78780: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
78781: LD_ADDR_VAR 0 29
78785: PUSH
78786: LD_INT 1
78788: NEG
78789: PUSH
78790: LD_INT 3
78792: NEG
78793: PUSH
78794: EMPTY
78795: LIST
78796: LIST
78797: PUSH
78798: LD_INT 0
78800: PUSH
78801: LD_INT 3
78803: NEG
78804: PUSH
78805: EMPTY
78806: LIST
78807: LIST
78808: PUSH
78809: LD_INT 1
78811: PUSH
78812: LD_INT 2
78814: NEG
78815: PUSH
78816: EMPTY
78817: LIST
78818: LIST
78819: PUSH
78820: LD_INT 1
78822: NEG
78823: PUSH
78824: LD_INT 4
78826: NEG
78827: PUSH
78828: EMPTY
78829: LIST
78830: LIST
78831: PUSH
78832: LD_INT 0
78834: PUSH
78835: LD_INT 4
78837: NEG
78838: PUSH
78839: EMPTY
78840: LIST
78841: LIST
78842: PUSH
78843: LD_INT 1
78845: PUSH
78846: LD_INT 3
78848: NEG
78849: PUSH
78850: EMPTY
78851: LIST
78852: LIST
78853: PUSH
78854: LD_INT 1
78856: NEG
78857: PUSH
78858: LD_INT 5
78860: NEG
78861: PUSH
78862: EMPTY
78863: LIST
78864: LIST
78865: PUSH
78866: LD_INT 0
78868: PUSH
78869: LD_INT 5
78871: NEG
78872: PUSH
78873: EMPTY
78874: LIST
78875: LIST
78876: PUSH
78877: LD_INT 1
78879: PUSH
78880: LD_INT 4
78882: NEG
78883: PUSH
78884: EMPTY
78885: LIST
78886: LIST
78887: PUSH
78888: LD_INT 1
78890: NEG
78891: PUSH
78892: LD_INT 6
78894: NEG
78895: PUSH
78896: EMPTY
78897: LIST
78898: LIST
78899: PUSH
78900: LD_INT 0
78902: PUSH
78903: LD_INT 6
78905: NEG
78906: PUSH
78907: EMPTY
78908: LIST
78909: LIST
78910: PUSH
78911: LD_INT 1
78913: PUSH
78914: LD_INT 5
78916: NEG
78917: PUSH
78918: EMPTY
78919: LIST
78920: LIST
78921: PUSH
78922: EMPTY
78923: LIST
78924: LIST
78925: LIST
78926: LIST
78927: LIST
78928: LIST
78929: LIST
78930: LIST
78931: LIST
78932: LIST
78933: LIST
78934: LIST
78935: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
78936: LD_ADDR_VAR 0 30
78940: PUSH
78941: LD_INT 2
78943: PUSH
78944: LD_INT 1
78946: NEG
78947: PUSH
78948: EMPTY
78949: LIST
78950: LIST
78951: PUSH
78952: LD_INT 3
78954: PUSH
78955: LD_INT 0
78957: PUSH
78958: EMPTY
78959: LIST
78960: LIST
78961: PUSH
78962: LD_INT 3
78964: PUSH
78965: LD_INT 1
78967: PUSH
78968: EMPTY
78969: LIST
78970: LIST
78971: PUSH
78972: LD_INT 3
78974: PUSH
78975: LD_INT 1
78977: NEG
78978: PUSH
78979: EMPTY
78980: LIST
78981: LIST
78982: PUSH
78983: LD_INT 4
78985: PUSH
78986: LD_INT 0
78988: PUSH
78989: EMPTY
78990: LIST
78991: LIST
78992: PUSH
78993: LD_INT 4
78995: PUSH
78996: LD_INT 1
78998: PUSH
78999: EMPTY
79000: LIST
79001: LIST
79002: PUSH
79003: LD_INT 4
79005: PUSH
79006: LD_INT 1
79008: NEG
79009: PUSH
79010: EMPTY
79011: LIST
79012: LIST
79013: PUSH
79014: LD_INT 5
79016: PUSH
79017: LD_INT 0
79019: PUSH
79020: EMPTY
79021: LIST
79022: LIST
79023: PUSH
79024: LD_INT 5
79026: PUSH
79027: LD_INT 1
79029: PUSH
79030: EMPTY
79031: LIST
79032: LIST
79033: PUSH
79034: LD_INT 5
79036: PUSH
79037: LD_INT 1
79039: NEG
79040: PUSH
79041: EMPTY
79042: LIST
79043: LIST
79044: PUSH
79045: LD_INT 6
79047: PUSH
79048: LD_INT 0
79050: PUSH
79051: EMPTY
79052: LIST
79053: LIST
79054: PUSH
79055: LD_INT 6
79057: PUSH
79058: LD_INT 1
79060: PUSH
79061: EMPTY
79062: LIST
79063: LIST
79064: PUSH
79065: EMPTY
79066: LIST
79067: LIST
79068: LIST
79069: LIST
79070: LIST
79071: LIST
79072: LIST
79073: LIST
79074: LIST
79075: LIST
79076: LIST
79077: LIST
79078: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
79079: LD_ADDR_VAR 0 31
79083: PUSH
79084: LD_INT 3
79086: PUSH
79087: LD_INT 2
79089: PUSH
79090: EMPTY
79091: LIST
79092: LIST
79093: PUSH
79094: LD_INT 3
79096: PUSH
79097: LD_INT 3
79099: PUSH
79100: EMPTY
79101: LIST
79102: LIST
79103: PUSH
79104: LD_INT 2
79106: PUSH
79107: LD_INT 3
79109: PUSH
79110: EMPTY
79111: LIST
79112: LIST
79113: PUSH
79114: LD_INT 4
79116: PUSH
79117: LD_INT 3
79119: PUSH
79120: EMPTY
79121: LIST
79122: LIST
79123: PUSH
79124: LD_INT 4
79126: PUSH
79127: LD_INT 4
79129: PUSH
79130: EMPTY
79131: LIST
79132: LIST
79133: PUSH
79134: LD_INT 3
79136: PUSH
79137: LD_INT 4
79139: PUSH
79140: EMPTY
79141: LIST
79142: LIST
79143: PUSH
79144: LD_INT 5
79146: PUSH
79147: LD_INT 4
79149: PUSH
79150: EMPTY
79151: LIST
79152: LIST
79153: PUSH
79154: LD_INT 5
79156: PUSH
79157: LD_INT 5
79159: PUSH
79160: EMPTY
79161: LIST
79162: LIST
79163: PUSH
79164: LD_INT 4
79166: PUSH
79167: LD_INT 5
79169: PUSH
79170: EMPTY
79171: LIST
79172: LIST
79173: PUSH
79174: LD_INT 6
79176: PUSH
79177: LD_INT 5
79179: PUSH
79180: EMPTY
79181: LIST
79182: LIST
79183: PUSH
79184: LD_INT 6
79186: PUSH
79187: LD_INT 6
79189: PUSH
79190: EMPTY
79191: LIST
79192: LIST
79193: PUSH
79194: LD_INT 5
79196: PUSH
79197: LD_INT 6
79199: PUSH
79200: EMPTY
79201: LIST
79202: LIST
79203: PUSH
79204: EMPTY
79205: LIST
79206: LIST
79207: LIST
79208: LIST
79209: LIST
79210: LIST
79211: LIST
79212: LIST
79213: LIST
79214: LIST
79215: LIST
79216: LIST
79217: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
79218: LD_ADDR_VAR 0 32
79222: PUSH
79223: LD_INT 1
79225: PUSH
79226: LD_INT 3
79228: PUSH
79229: EMPTY
79230: LIST
79231: LIST
79232: PUSH
79233: LD_INT 0
79235: PUSH
79236: LD_INT 3
79238: PUSH
79239: EMPTY
79240: LIST
79241: LIST
79242: PUSH
79243: LD_INT 1
79245: NEG
79246: PUSH
79247: LD_INT 2
79249: PUSH
79250: EMPTY
79251: LIST
79252: LIST
79253: PUSH
79254: LD_INT 1
79256: PUSH
79257: LD_INT 4
79259: PUSH
79260: EMPTY
79261: LIST
79262: LIST
79263: PUSH
79264: LD_INT 0
79266: PUSH
79267: LD_INT 4
79269: PUSH
79270: EMPTY
79271: LIST
79272: LIST
79273: PUSH
79274: LD_INT 1
79276: NEG
79277: PUSH
79278: LD_INT 3
79280: PUSH
79281: EMPTY
79282: LIST
79283: LIST
79284: PUSH
79285: LD_INT 1
79287: PUSH
79288: LD_INT 5
79290: PUSH
79291: EMPTY
79292: LIST
79293: LIST
79294: PUSH
79295: LD_INT 0
79297: PUSH
79298: LD_INT 5
79300: PUSH
79301: EMPTY
79302: LIST
79303: LIST
79304: PUSH
79305: LD_INT 1
79307: NEG
79308: PUSH
79309: LD_INT 4
79311: PUSH
79312: EMPTY
79313: LIST
79314: LIST
79315: PUSH
79316: LD_INT 1
79318: PUSH
79319: LD_INT 6
79321: PUSH
79322: EMPTY
79323: LIST
79324: LIST
79325: PUSH
79326: LD_INT 0
79328: PUSH
79329: LD_INT 6
79331: PUSH
79332: EMPTY
79333: LIST
79334: LIST
79335: PUSH
79336: LD_INT 1
79338: NEG
79339: PUSH
79340: LD_INT 5
79342: PUSH
79343: EMPTY
79344: LIST
79345: LIST
79346: PUSH
79347: EMPTY
79348: LIST
79349: LIST
79350: LIST
79351: LIST
79352: LIST
79353: LIST
79354: LIST
79355: LIST
79356: LIST
79357: LIST
79358: LIST
79359: LIST
79360: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
79361: LD_ADDR_VAR 0 33
79365: PUSH
79366: LD_INT 2
79368: NEG
79369: PUSH
79370: LD_INT 1
79372: PUSH
79373: EMPTY
79374: LIST
79375: LIST
79376: PUSH
79377: LD_INT 3
79379: NEG
79380: PUSH
79381: LD_INT 0
79383: PUSH
79384: EMPTY
79385: LIST
79386: LIST
79387: PUSH
79388: LD_INT 3
79390: NEG
79391: PUSH
79392: LD_INT 1
79394: NEG
79395: PUSH
79396: EMPTY
79397: LIST
79398: LIST
79399: PUSH
79400: LD_INT 3
79402: NEG
79403: PUSH
79404: LD_INT 1
79406: PUSH
79407: EMPTY
79408: LIST
79409: LIST
79410: PUSH
79411: LD_INT 4
79413: NEG
79414: PUSH
79415: LD_INT 0
79417: PUSH
79418: EMPTY
79419: LIST
79420: LIST
79421: PUSH
79422: LD_INT 4
79424: NEG
79425: PUSH
79426: LD_INT 1
79428: NEG
79429: PUSH
79430: EMPTY
79431: LIST
79432: LIST
79433: PUSH
79434: LD_INT 4
79436: NEG
79437: PUSH
79438: LD_INT 1
79440: PUSH
79441: EMPTY
79442: LIST
79443: LIST
79444: PUSH
79445: LD_INT 5
79447: NEG
79448: PUSH
79449: LD_INT 0
79451: PUSH
79452: EMPTY
79453: LIST
79454: LIST
79455: PUSH
79456: LD_INT 5
79458: NEG
79459: PUSH
79460: LD_INT 1
79462: NEG
79463: PUSH
79464: EMPTY
79465: LIST
79466: LIST
79467: PUSH
79468: LD_INT 5
79470: NEG
79471: PUSH
79472: LD_INT 1
79474: PUSH
79475: EMPTY
79476: LIST
79477: LIST
79478: PUSH
79479: LD_INT 6
79481: NEG
79482: PUSH
79483: LD_INT 0
79485: PUSH
79486: EMPTY
79487: LIST
79488: LIST
79489: PUSH
79490: LD_INT 6
79492: NEG
79493: PUSH
79494: LD_INT 1
79496: NEG
79497: PUSH
79498: EMPTY
79499: LIST
79500: LIST
79501: PUSH
79502: EMPTY
79503: LIST
79504: LIST
79505: LIST
79506: LIST
79507: LIST
79508: LIST
79509: LIST
79510: LIST
79511: LIST
79512: LIST
79513: LIST
79514: LIST
79515: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
79516: LD_ADDR_VAR 0 34
79520: PUSH
79521: LD_INT 2
79523: NEG
79524: PUSH
79525: LD_INT 3
79527: NEG
79528: PUSH
79529: EMPTY
79530: LIST
79531: LIST
79532: PUSH
79533: LD_INT 3
79535: NEG
79536: PUSH
79537: LD_INT 2
79539: NEG
79540: PUSH
79541: EMPTY
79542: LIST
79543: LIST
79544: PUSH
79545: LD_INT 3
79547: NEG
79548: PUSH
79549: LD_INT 3
79551: NEG
79552: PUSH
79553: EMPTY
79554: LIST
79555: LIST
79556: PUSH
79557: LD_INT 3
79559: NEG
79560: PUSH
79561: LD_INT 4
79563: NEG
79564: PUSH
79565: EMPTY
79566: LIST
79567: LIST
79568: PUSH
79569: LD_INT 4
79571: NEG
79572: PUSH
79573: LD_INT 3
79575: NEG
79576: PUSH
79577: EMPTY
79578: LIST
79579: LIST
79580: PUSH
79581: LD_INT 4
79583: NEG
79584: PUSH
79585: LD_INT 4
79587: NEG
79588: PUSH
79589: EMPTY
79590: LIST
79591: LIST
79592: PUSH
79593: LD_INT 4
79595: NEG
79596: PUSH
79597: LD_INT 5
79599: NEG
79600: PUSH
79601: EMPTY
79602: LIST
79603: LIST
79604: PUSH
79605: LD_INT 5
79607: NEG
79608: PUSH
79609: LD_INT 4
79611: NEG
79612: PUSH
79613: EMPTY
79614: LIST
79615: LIST
79616: PUSH
79617: LD_INT 5
79619: NEG
79620: PUSH
79621: LD_INT 5
79623: NEG
79624: PUSH
79625: EMPTY
79626: LIST
79627: LIST
79628: PUSH
79629: LD_INT 5
79631: NEG
79632: PUSH
79633: LD_INT 6
79635: NEG
79636: PUSH
79637: EMPTY
79638: LIST
79639: LIST
79640: PUSH
79641: LD_INT 6
79643: NEG
79644: PUSH
79645: LD_INT 5
79647: NEG
79648: PUSH
79649: EMPTY
79650: LIST
79651: LIST
79652: PUSH
79653: LD_INT 6
79655: NEG
79656: PUSH
79657: LD_INT 6
79659: NEG
79660: PUSH
79661: EMPTY
79662: LIST
79663: LIST
79664: PUSH
79665: EMPTY
79666: LIST
79667: LIST
79668: LIST
79669: LIST
79670: LIST
79671: LIST
79672: LIST
79673: LIST
79674: LIST
79675: LIST
79676: LIST
79677: LIST
79678: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
79679: LD_ADDR_VAR 0 41
79683: PUSH
79684: LD_INT 0
79686: PUSH
79687: LD_INT 2
79689: NEG
79690: PUSH
79691: EMPTY
79692: LIST
79693: LIST
79694: PUSH
79695: LD_INT 1
79697: NEG
79698: PUSH
79699: LD_INT 3
79701: NEG
79702: PUSH
79703: EMPTY
79704: LIST
79705: LIST
79706: PUSH
79707: LD_INT 1
79709: PUSH
79710: LD_INT 2
79712: NEG
79713: PUSH
79714: EMPTY
79715: LIST
79716: LIST
79717: PUSH
79718: EMPTY
79719: LIST
79720: LIST
79721: LIST
79722: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
79723: LD_ADDR_VAR 0 42
79727: PUSH
79728: LD_INT 2
79730: PUSH
79731: LD_INT 0
79733: PUSH
79734: EMPTY
79735: LIST
79736: LIST
79737: PUSH
79738: LD_INT 2
79740: PUSH
79741: LD_INT 1
79743: NEG
79744: PUSH
79745: EMPTY
79746: LIST
79747: LIST
79748: PUSH
79749: LD_INT 3
79751: PUSH
79752: LD_INT 1
79754: PUSH
79755: EMPTY
79756: LIST
79757: LIST
79758: PUSH
79759: EMPTY
79760: LIST
79761: LIST
79762: LIST
79763: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
79764: LD_ADDR_VAR 0 43
79768: PUSH
79769: LD_INT 2
79771: PUSH
79772: LD_INT 2
79774: PUSH
79775: EMPTY
79776: LIST
79777: LIST
79778: PUSH
79779: LD_INT 3
79781: PUSH
79782: LD_INT 2
79784: PUSH
79785: EMPTY
79786: LIST
79787: LIST
79788: PUSH
79789: LD_INT 2
79791: PUSH
79792: LD_INT 3
79794: PUSH
79795: EMPTY
79796: LIST
79797: LIST
79798: PUSH
79799: EMPTY
79800: LIST
79801: LIST
79802: LIST
79803: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
79804: LD_ADDR_VAR 0 44
79808: PUSH
79809: LD_INT 0
79811: PUSH
79812: LD_INT 2
79814: PUSH
79815: EMPTY
79816: LIST
79817: LIST
79818: PUSH
79819: LD_INT 1
79821: PUSH
79822: LD_INT 3
79824: PUSH
79825: EMPTY
79826: LIST
79827: LIST
79828: PUSH
79829: LD_INT 1
79831: NEG
79832: PUSH
79833: LD_INT 2
79835: PUSH
79836: EMPTY
79837: LIST
79838: LIST
79839: PUSH
79840: EMPTY
79841: LIST
79842: LIST
79843: LIST
79844: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
79845: LD_ADDR_VAR 0 45
79849: PUSH
79850: LD_INT 2
79852: NEG
79853: PUSH
79854: LD_INT 0
79856: PUSH
79857: EMPTY
79858: LIST
79859: LIST
79860: PUSH
79861: LD_INT 2
79863: NEG
79864: PUSH
79865: LD_INT 1
79867: PUSH
79868: EMPTY
79869: LIST
79870: LIST
79871: PUSH
79872: LD_INT 3
79874: NEG
79875: PUSH
79876: LD_INT 1
79878: NEG
79879: PUSH
79880: EMPTY
79881: LIST
79882: LIST
79883: PUSH
79884: EMPTY
79885: LIST
79886: LIST
79887: LIST
79888: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
79889: LD_ADDR_VAR 0 46
79893: PUSH
79894: LD_INT 2
79896: NEG
79897: PUSH
79898: LD_INT 2
79900: NEG
79901: PUSH
79902: EMPTY
79903: LIST
79904: LIST
79905: PUSH
79906: LD_INT 2
79908: NEG
79909: PUSH
79910: LD_INT 3
79912: NEG
79913: PUSH
79914: EMPTY
79915: LIST
79916: LIST
79917: PUSH
79918: LD_INT 3
79920: NEG
79921: PUSH
79922: LD_INT 2
79924: NEG
79925: PUSH
79926: EMPTY
79927: LIST
79928: LIST
79929: PUSH
79930: EMPTY
79931: LIST
79932: LIST
79933: LIST
79934: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
79935: LD_ADDR_VAR 0 47
79939: PUSH
79940: LD_INT 2
79942: NEG
79943: PUSH
79944: LD_INT 3
79946: NEG
79947: PUSH
79948: EMPTY
79949: LIST
79950: LIST
79951: PUSH
79952: LD_INT 1
79954: NEG
79955: PUSH
79956: LD_INT 3
79958: NEG
79959: PUSH
79960: EMPTY
79961: LIST
79962: LIST
79963: PUSH
79964: EMPTY
79965: LIST
79966: LIST
79967: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
79968: LD_ADDR_VAR 0 48
79972: PUSH
79973: LD_INT 1
79975: PUSH
79976: LD_INT 2
79978: NEG
79979: PUSH
79980: EMPTY
79981: LIST
79982: LIST
79983: PUSH
79984: LD_INT 2
79986: PUSH
79987: LD_INT 1
79989: NEG
79990: PUSH
79991: EMPTY
79992: LIST
79993: LIST
79994: PUSH
79995: EMPTY
79996: LIST
79997: LIST
79998: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
79999: LD_ADDR_VAR 0 49
80003: PUSH
80004: LD_INT 3
80006: PUSH
80007: LD_INT 1
80009: PUSH
80010: EMPTY
80011: LIST
80012: LIST
80013: PUSH
80014: LD_INT 3
80016: PUSH
80017: LD_INT 2
80019: PUSH
80020: EMPTY
80021: LIST
80022: LIST
80023: PUSH
80024: EMPTY
80025: LIST
80026: LIST
80027: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
80028: LD_ADDR_VAR 0 50
80032: PUSH
80033: LD_INT 2
80035: PUSH
80036: LD_INT 3
80038: PUSH
80039: EMPTY
80040: LIST
80041: LIST
80042: PUSH
80043: LD_INT 1
80045: PUSH
80046: LD_INT 3
80048: PUSH
80049: EMPTY
80050: LIST
80051: LIST
80052: PUSH
80053: EMPTY
80054: LIST
80055: LIST
80056: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
80057: LD_ADDR_VAR 0 51
80061: PUSH
80062: LD_INT 1
80064: NEG
80065: PUSH
80066: LD_INT 2
80068: PUSH
80069: EMPTY
80070: LIST
80071: LIST
80072: PUSH
80073: LD_INT 2
80075: NEG
80076: PUSH
80077: LD_INT 1
80079: PUSH
80080: EMPTY
80081: LIST
80082: LIST
80083: PUSH
80084: EMPTY
80085: LIST
80086: LIST
80087: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
80088: LD_ADDR_VAR 0 52
80092: PUSH
80093: LD_INT 3
80095: NEG
80096: PUSH
80097: LD_INT 1
80099: NEG
80100: PUSH
80101: EMPTY
80102: LIST
80103: LIST
80104: PUSH
80105: LD_INT 3
80107: NEG
80108: PUSH
80109: LD_INT 2
80111: NEG
80112: PUSH
80113: EMPTY
80114: LIST
80115: LIST
80116: PUSH
80117: EMPTY
80118: LIST
80119: LIST
80120: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
80121: LD_ADDR_VAR 0 53
80125: PUSH
80126: LD_INT 1
80128: NEG
80129: PUSH
80130: LD_INT 3
80132: NEG
80133: PUSH
80134: EMPTY
80135: LIST
80136: LIST
80137: PUSH
80138: LD_INT 0
80140: PUSH
80141: LD_INT 3
80143: NEG
80144: PUSH
80145: EMPTY
80146: LIST
80147: LIST
80148: PUSH
80149: LD_INT 1
80151: PUSH
80152: LD_INT 2
80154: NEG
80155: PUSH
80156: EMPTY
80157: LIST
80158: LIST
80159: PUSH
80160: EMPTY
80161: LIST
80162: LIST
80163: LIST
80164: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
80165: LD_ADDR_VAR 0 54
80169: PUSH
80170: LD_INT 2
80172: PUSH
80173: LD_INT 1
80175: NEG
80176: PUSH
80177: EMPTY
80178: LIST
80179: LIST
80180: PUSH
80181: LD_INT 3
80183: PUSH
80184: LD_INT 0
80186: PUSH
80187: EMPTY
80188: LIST
80189: LIST
80190: PUSH
80191: LD_INT 3
80193: PUSH
80194: LD_INT 1
80196: PUSH
80197: EMPTY
80198: LIST
80199: LIST
80200: PUSH
80201: EMPTY
80202: LIST
80203: LIST
80204: LIST
80205: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
80206: LD_ADDR_VAR 0 55
80210: PUSH
80211: LD_INT 3
80213: PUSH
80214: LD_INT 2
80216: PUSH
80217: EMPTY
80218: LIST
80219: LIST
80220: PUSH
80221: LD_INT 3
80223: PUSH
80224: LD_INT 3
80226: PUSH
80227: EMPTY
80228: LIST
80229: LIST
80230: PUSH
80231: LD_INT 2
80233: PUSH
80234: LD_INT 3
80236: PUSH
80237: EMPTY
80238: LIST
80239: LIST
80240: PUSH
80241: EMPTY
80242: LIST
80243: LIST
80244: LIST
80245: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
80246: LD_ADDR_VAR 0 56
80250: PUSH
80251: LD_INT 1
80253: PUSH
80254: LD_INT 3
80256: PUSH
80257: EMPTY
80258: LIST
80259: LIST
80260: PUSH
80261: LD_INT 0
80263: PUSH
80264: LD_INT 3
80266: PUSH
80267: EMPTY
80268: LIST
80269: LIST
80270: PUSH
80271: LD_INT 1
80273: NEG
80274: PUSH
80275: LD_INT 2
80277: PUSH
80278: EMPTY
80279: LIST
80280: LIST
80281: PUSH
80282: EMPTY
80283: LIST
80284: LIST
80285: LIST
80286: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80287: LD_ADDR_VAR 0 57
80291: PUSH
80292: LD_INT 2
80294: NEG
80295: PUSH
80296: LD_INT 1
80298: PUSH
80299: EMPTY
80300: LIST
80301: LIST
80302: PUSH
80303: LD_INT 3
80305: NEG
80306: PUSH
80307: LD_INT 0
80309: PUSH
80310: EMPTY
80311: LIST
80312: LIST
80313: PUSH
80314: LD_INT 3
80316: NEG
80317: PUSH
80318: LD_INT 1
80320: NEG
80321: PUSH
80322: EMPTY
80323: LIST
80324: LIST
80325: PUSH
80326: EMPTY
80327: LIST
80328: LIST
80329: LIST
80330: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80331: LD_ADDR_VAR 0 58
80335: PUSH
80336: LD_INT 2
80338: NEG
80339: PUSH
80340: LD_INT 3
80342: NEG
80343: PUSH
80344: EMPTY
80345: LIST
80346: LIST
80347: PUSH
80348: LD_INT 3
80350: NEG
80351: PUSH
80352: LD_INT 2
80354: NEG
80355: PUSH
80356: EMPTY
80357: LIST
80358: LIST
80359: PUSH
80360: LD_INT 3
80362: NEG
80363: PUSH
80364: LD_INT 3
80366: NEG
80367: PUSH
80368: EMPTY
80369: LIST
80370: LIST
80371: PUSH
80372: EMPTY
80373: LIST
80374: LIST
80375: LIST
80376: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
80377: LD_ADDR_VAR 0 59
80381: PUSH
80382: LD_INT 1
80384: NEG
80385: PUSH
80386: LD_INT 2
80388: NEG
80389: PUSH
80390: EMPTY
80391: LIST
80392: LIST
80393: PUSH
80394: LD_INT 0
80396: PUSH
80397: LD_INT 2
80399: NEG
80400: PUSH
80401: EMPTY
80402: LIST
80403: LIST
80404: PUSH
80405: LD_INT 1
80407: PUSH
80408: LD_INT 1
80410: NEG
80411: PUSH
80412: EMPTY
80413: LIST
80414: LIST
80415: PUSH
80416: EMPTY
80417: LIST
80418: LIST
80419: LIST
80420: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
80421: LD_ADDR_VAR 0 60
80425: PUSH
80426: LD_INT 1
80428: PUSH
80429: LD_INT 1
80431: NEG
80432: PUSH
80433: EMPTY
80434: LIST
80435: LIST
80436: PUSH
80437: LD_INT 2
80439: PUSH
80440: LD_INT 0
80442: PUSH
80443: EMPTY
80444: LIST
80445: LIST
80446: PUSH
80447: LD_INT 2
80449: PUSH
80450: LD_INT 1
80452: PUSH
80453: EMPTY
80454: LIST
80455: LIST
80456: PUSH
80457: EMPTY
80458: LIST
80459: LIST
80460: LIST
80461: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
80462: LD_ADDR_VAR 0 61
80466: PUSH
80467: LD_INT 2
80469: PUSH
80470: LD_INT 1
80472: PUSH
80473: EMPTY
80474: LIST
80475: LIST
80476: PUSH
80477: LD_INT 2
80479: PUSH
80480: LD_INT 2
80482: PUSH
80483: EMPTY
80484: LIST
80485: LIST
80486: PUSH
80487: LD_INT 1
80489: PUSH
80490: LD_INT 2
80492: PUSH
80493: EMPTY
80494: LIST
80495: LIST
80496: PUSH
80497: EMPTY
80498: LIST
80499: LIST
80500: LIST
80501: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
80502: LD_ADDR_VAR 0 62
80506: PUSH
80507: LD_INT 1
80509: PUSH
80510: LD_INT 2
80512: PUSH
80513: EMPTY
80514: LIST
80515: LIST
80516: PUSH
80517: LD_INT 0
80519: PUSH
80520: LD_INT 2
80522: PUSH
80523: EMPTY
80524: LIST
80525: LIST
80526: PUSH
80527: LD_INT 1
80529: NEG
80530: PUSH
80531: LD_INT 1
80533: PUSH
80534: EMPTY
80535: LIST
80536: LIST
80537: PUSH
80538: EMPTY
80539: LIST
80540: LIST
80541: LIST
80542: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
80543: LD_ADDR_VAR 0 63
80547: PUSH
80548: LD_INT 1
80550: NEG
80551: PUSH
80552: LD_INT 1
80554: PUSH
80555: EMPTY
80556: LIST
80557: LIST
80558: PUSH
80559: LD_INT 2
80561: NEG
80562: PUSH
80563: LD_INT 0
80565: PUSH
80566: EMPTY
80567: LIST
80568: LIST
80569: PUSH
80570: LD_INT 2
80572: NEG
80573: PUSH
80574: LD_INT 1
80576: NEG
80577: PUSH
80578: EMPTY
80579: LIST
80580: LIST
80581: PUSH
80582: EMPTY
80583: LIST
80584: LIST
80585: LIST
80586: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80587: LD_ADDR_VAR 0 64
80591: PUSH
80592: LD_INT 1
80594: NEG
80595: PUSH
80596: LD_INT 2
80598: NEG
80599: PUSH
80600: EMPTY
80601: LIST
80602: LIST
80603: PUSH
80604: LD_INT 2
80606: NEG
80607: PUSH
80608: LD_INT 1
80610: NEG
80611: PUSH
80612: EMPTY
80613: LIST
80614: LIST
80615: PUSH
80616: LD_INT 2
80618: NEG
80619: PUSH
80620: LD_INT 2
80622: NEG
80623: PUSH
80624: EMPTY
80625: LIST
80626: LIST
80627: PUSH
80628: EMPTY
80629: LIST
80630: LIST
80631: LIST
80632: ST_TO_ADDR
// end ; 2 :
80633: GO 83899
80635: LD_INT 2
80637: DOUBLE
80638: EQUAL
80639: IFTRUE 80643
80641: GO 83898
80643: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
80644: LD_ADDR_VAR 0 29
80648: PUSH
80649: LD_INT 4
80651: PUSH
80652: LD_INT 0
80654: PUSH
80655: EMPTY
80656: LIST
80657: LIST
80658: PUSH
80659: LD_INT 4
80661: PUSH
80662: LD_INT 1
80664: NEG
80665: PUSH
80666: EMPTY
80667: LIST
80668: LIST
80669: PUSH
80670: LD_INT 5
80672: PUSH
80673: LD_INT 0
80675: PUSH
80676: EMPTY
80677: LIST
80678: LIST
80679: PUSH
80680: LD_INT 5
80682: PUSH
80683: LD_INT 1
80685: PUSH
80686: EMPTY
80687: LIST
80688: LIST
80689: PUSH
80690: LD_INT 4
80692: PUSH
80693: LD_INT 1
80695: PUSH
80696: EMPTY
80697: LIST
80698: LIST
80699: PUSH
80700: LD_INT 3
80702: PUSH
80703: LD_INT 0
80705: PUSH
80706: EMPTY
80707: LIST
80708: LIST
80709: PUSH
80710: LD_INT 3
80712: PUSH
80713: LD_INT 1
80715: NEG
80716: PUSH
80717: EMPTY
80718: LIST
80719: LIST
80720: PUSH
80721: LD_INT 3
80723: PUSH
80724: LD_INT 2
80726: NEG
80727: PUSH
80728: EMPTY
80729: LIST
80730: LIST
80731: PUSH
80732: LD_INT 5
80734: PUSH
80735: LD_INT 2
80737: PUSH
80738: EMPTY
80739: LIST
80740: LIST
80741: PUSH
80742: LD_INT 3
80744: PUSH
80745: LD_INT 3
80747: PUSH
80748: EMPTY
80749: LIST
80750: LIST
80751: PUSH
80752: LD_INT 3
80754: PUSH
80755: LD_INT 2
80757: PUSH
80758: EMPTY
80759: LIST
80760: LIST
80761: PUSH
80762: LD_INT 4
80764: PUSH
80765: LD_INT 3
80767: PUSH
80768: EMPTY
80769: LIST
80770: LIST
80771: PUSH
80772: LD_INT 4
80774: PUSH
80775: LD_INT 4
80777: PUSH
80778: EMPTY
80779: LIST
80780: LIST
80781: PUSH
80782: LD_INT 3
80784: PUSH
80785: LD_INT 4
80787: PUSH
80788: EMPTY
80789: LIST
80790: LIST
80791: PUSH
80792: LD_INT 2
80794: PUSH
80795: LD_INT 3
80797: PUSH
80798: EMPTY
80799: LIST
80800: LIST
80801: PUSH
80802: LD_INT 2
80804: PUSH
80805: LD_INT 2
80807: PUSH
80808: EMPTY
80809: LIST
80810: LIST
80811: PUSH
80812: LD_INT 4
80814: PUSH
80815: LD_INT 2
80817: PUSH
80818: EMPTY
80819: LIST
80820: LIST
80821: PUSH
80822: LD_INT 2
80824: PUSH
80825: LD_INT 4
80827: PUSH
80828: EMPTY
80829: LIST
80830: LIST
80831: PUSH
80832: LD_INT 0
80834: PUSH
80835: LD_INT 4
80837: PUSH
80838: EMPTY
80839: LIST
80840: LIST
80841: PUSH
80842: LD_INT 0
80844: PUSH
80845: LD_INT 3
80847: PUSH
80848: EMPTY
80849: LIST
80850: LIST
80851: PUSH
80852: LD_INT 1
80854: PUSH
80855: LD_INT 4
80857: PUSH
80858: EMPTY
80859: LIST
80860: LIST
80861: PUSH
80862: LD_INT 1
80864: PUSH
80865: LD_INT 5
80867: PUSH
80868: EMPTY
80869: LIST
80870: LIST
80871: PUSH
80872: LD_INT 0
80874: PUSH
80875: LD_INT 5
80877: PUSH
80878: EMPTY
80879: LIST
80880: LIST
80881: PUSH
80882: LD_INT 1
80884: NEG
80885: PUSH
80886: LD_INT 4
80888: PUSH
80889: EMPTY
80890: LIST
80891: LIST
80892: PUSH
80893: LD_INT 1
80895: NEG
80896: PUSH
80897: LD_INT 3
80899: PUSH
80900: EMPTY
80901: LIST
80902: LIST
80903: PUSH
80904: LD_INT 2
80906: PUSH
80907: LD_INT 5
80909: PUSH
80910: EMPTY
80911: LIST
80912: LIST
80913: PUSH
80914: LD_INT 2
80916: NEG
80917: PUSH
80918: LD_INT 3
80920: PUSH
80921: EMPTY
80922: LIST
80923: LIST
80924: PUSH
80925: LD_INT 3
80927: NEG
80928: PUSH
80929: LD_INT 0
80931: PUSH
80932: EMPTY
80933: LIST
80934: LIST
80935: PUSH
80936: LD_INT 3
80938: NEG
80939: PUSH
80940: LD_INT 1
80942: NEG
80943: PUSH
80944: EMPTY
80945: LIST
80946: LIST
80947: PUSH
80948: LD_INT 2
80950: NEG
80951: PUSH
80952: LD_INT 0
80954: PUSH
80955: EMPTY
80956: LIST
80957: LIST
80958: PUSH
80959: LD_INT 2
80961: NEG
80962: PUSH
80963: LD_INT 1
80965: PUSH
80966: EMPTY
80967: LIST
80968: LIST
80969: PUSH
80970: LD_INT 3
80972: NEG
80973: PUSH
80974: LD_INT 1
80976: PUSH
80977: EMPTY
80978: LIST
80979: LIST
80980: PUSH
80981: LD_INT 4
80983: NEG
80984: PUSH
80985: LD_INT 0
80987: PUSH
80988: EMPTY
80989: LIST
80990: LIST
80991: PUSH
80992: LD_INT 4
80994: NEG
80995: PUSH
80996: LD_INT 1
80998: NEG
80999: PUSH
81000: EMPTY
81001: LIST
81002: LIST
81003: PUSH
81004: LD_INT 4
81006: NEG
81007: PUSH
81008: LD_INT 2
81010: NEG
81011: PUSH
81012: EMPTY
81013: LIST
81014: LIST
81015: PUSH
81016: LD_INT 2
81018: NEG
81019: PUSH
81020: LD_INT 2
81022: PUSH
81023: EMPTY
81024: LIST
81025: LIST
81026: PUSH
81027: LD_INT 4
81029: NEG
81030: PUSH
81031: LD_INT 4
81033: NEG
81034: PUSH
81035: EMPTY
81036: LIST
81037: LIST
81038: PUSH
81039: LD_INT 4
81041: NEG
81042: PUSH
81043: LD_INT 5
81045: NEG
81046: PUSH
81047: EMPTY
81048: LIST
81049: LIST
81050: PUSH
81051: LD_INT 3
81053: NEG
81054: PUSH
81055: LD_INT 4
81057: NEG
81058: PUSH
81059: EMPTY
81060: LIST
81061: LIST
81062: PUSH
81063: LD_INT 3
81065: NEG
81066: PUSH
81067: LD_INT 3
81069: NEG
81070: PUSH
81071: EMPTY
81072: LIST
81073: LIST
81074: PUSH
81075: LD_INT 4
81077: NEG
81078: PUSH
81079: LD_INT 3
81081: NEG
81082: PUSH
81083: EMPTY
81084: LIST
81085: LIST
81086: PUSH
81087: LD_INT 5
81089: NEG
81090: PUSH
81091: LD_INT 4
81093: NEG
81094: PUSH
81095: EMPTY
81096: LIST
81097: LIST
81098: PUSH
81099: LD_INT 5
81101: NEG
81102: PUSH
81103: LD_INT 5
81105: NEG
81106: PUSH
81107: EMPTY
81108: LIST
81109: LIST
81110: PUSH
81111: LD_INT 3
81113: NEG
81114: PUSH
81115: LD_INT 5
81117: NEG
81118: PUSH
81119: EMPTY
81120: LIST
81121: LIST
81122: PUSH
81123: LD_INT 5
81125: NEG
81126: PUSH
81127: LD_INT 3
81129: NEG
81130: PUSH
81131: EMPTY
81132: LIST
81133: LIST
81134: PUSH
81135: EMPTY
81136: LIST
81137: LIST
81138: LIST
81139: LIST
81140: LIST
81141: LIST
81142: LIST
81143: LIST
81144: LIST
81145: LIST
81146: LIST
81147: LIST
81148: LIST
81149: LIST
81150: LIST
81151: LIST
81152: LIST
81153: LIST
81154: LIST
81155: LIST
81156: LIST
81157: LIST
81158: LIST
81159: LIST
81160: LIST
81161: LIST
81162: LIST
81163: LIST
81164: LIST
81165: LIST
81166: LIST
81167: LIST
81168: LIST
81169: LIST
81170: LIST
81171: LIST
81172: LIST
81173: LIST
81174: LIST
81175: LIST
81176: LIST
81177: LIST
81178: LIST
81179: LIST
81180: LIST
81181: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
81182: LD_ADDR_VAR 0 30
81186: PUSH
81187: LD_INT 4
81189: PUSH
81190: LD_INT 4
81192: PUSH
81193: EMPTY
81194: LIST
81195: LIST
81196: PUSH
81197: LD_INT 4
81199: PUSH
81200: LD_INT 3
81202: PUSH
81203: EMPTY
81204: LIST
81205: LIST
81206: PUSH
81207: LD_INT 5
81209: PUSH
81210: LD_INT 4
81212: PUSH
81213: EMPTY
81214: LIST
81215: LIST
81216: PUSH
81217: LD_INT 5
81219: PUSH
81220: LD_INT 5
81222: PUSH
81223: EMPTY
81224: LIST
81225: LIST
81226: PUSH
81227: LD_INT 4
81229: PUSH
81230: LD_INT 5
81232: PUSH
81233: EMPTY
81234: LIST
81235: LIST
81236: PUSH
81237: LD_INT 3
81239: PUSH
81240: LD_INT 4
81242: PUSH
81243: EMPTY
81244: LIST
81245: LIST
81246: PUSH
81247: LD_INT 3
81249: PUSH
81250: LD_INT 3
81252: PUSH
81253: EMPTY
81254: LIST
81255: LIST
81256: PUSH
81257: LD_INT 5
81259: PUSH
81260: LD_INT 3
81262: PUSH
81263: EMPTY
81264: LIST
81265: LIST
81266: PUSH
81267: LD_INT 3
81269: PUSH
81270: LD_INT 5
81272: PUSH
81273: EMPTY
81274: LIST
81275: LIST
81276: PUSH
81277: LD_INT 0
81279: PUSH
81280: LD_INT 3
81282: PUSH
81283: EMPTY
81284: LIST
81285: LIST
81286: PUSH
81287: LD_INT 0
81289: PUSH
81290: LD_INT 2
81292: PUSH
81293: EMPTY
81294: LIST
81295: LIST
81296: PUSH
81297: LD_INT 1
81299: PUSH
81300: LD_INT 3
81302: PUSH
81303: EMPTY
81304: LIST
81305: LIST
81306: PUSH
81307: LD_INT 1
81309: PUSH
81310: LD_INT 4
81312: PUSH
81313: EMPTY
81314: LIST
81315: LIST
81316: PUSH
81317: LD_INT 0
81319: PUSH
81320: LD_INT 4
81322: PUSH
81323: EMPTY
81324: LIST
81325: LIST
81326: PUSH
81327: LD_INT 1
81329: NEG
81330: PUSH
81331: LD_INT 3
81333: PUSH
81334: EMPTY
81335: LIST
81336: LIST
81337: PUSH
81338: LD_INT 1
81340: NEG
81341: PUSH
81342: LD_INT 2
81344: PUSH
81345: EMPTY
81346: LIST
81347: LIST
81348: PUSH
81349: LD_INT 2
81351: PUSH
81352: LD_INT 4
81354: PUSH
81355: EMPTY
81356: LIST
81357: LIST
81358: PUSH
81359: LD_INT 2
81361: NEG
81362: PUSH
81363: LD_INT 2
81365: PUSH
81366: EMPTY
81367: LIST
81368: LIST
81369: PUSH
81370: LD_INT 4
81372: NEG
81373: PUSH
81374: LD_INT 0
81376: PUSH
81377: EMPTY
81378: LIST
81379: LIST
81380: PUSH
81381: LD_INT 4
81383: NEG
81384: PUSH
81385: LD_INT 1
81387: NEG
81388: PUSH
81389: EMPTY
81390: LIST
81391: LIST
81392: PUSH
81393: LD_INT 3
81395: NEG
81396: PUSH
81397: LD_INT 0
81399: PUSH
81400: EMPTY
81401: LIST
81402: LIST
81403: PUSH
81404: LD_INT 3
81406: NEG
81407: PUSH
81408: LD_INT 1
81410: PUSH
81411: EMPTY
81412: LIST
81413: LIST
81414: PUSH
81415: LD_INT 4
81417: NEG
81418: PUSH
81419: LD_INT 1
81421: PUSH
81422: EMPTY
81423: LIST
81424: LIST
81425: PUSH
81426: LD_INT 5
81428: NEG
81429: PUSH
81430: LD_INT 0
81432: PUSH
81433: EMPTY
81434: LIST
81435: LIST
81436: PUSH
81437: LD_INT 5
81439: NEG
81440: PUSH
81441: LD_INT 1
81443: NEG
81444: PUSH
81445: EMPTY
81446: LIST
81447: LIST
81448: PUSH
81449: LD_INT 5
81451: NEG
81452: PUSH
81453: LD_INT 2
81455: NEG
81456: PUSH
81457: EMPTY
81458: LIST
81459: LIST
81460: PUSH
81461: LD_INT 3
81463: NEG
81464: PUSH
81465: LD_INT 2
81467: PUSH
81468: EMPTY
81469: LIST
81470: LIST
81471: PUSH
81472: LD_INT 3
81474: NEG
81475: PUSH
81476: LD_INT 3
81478: NEG
81479: PUSH
81480: EMPTY
81481: LIST
81482: LIST
81483: PUSH
81484: LD_INT 3
81486: NEG
81487: PUSH
81488: LD_INT 4
81490: NEG
81491: PUSH
81492: EMPTY
81493: LIST
81494: LIST
81495: PUSH
81496: LD_INT 2
81498: NEG
81499: PUSH
81500: LD_INT 3
81502: NEG
81503: PUSH
81504: EMPTY
81505: LIST
81506: LIST
81507: PUSH
81508: LD_INT 2
81510: NEG
81511: PUSH
81512: LD_INT 2
81514: NEG
81515: PUSH
81516: EMPTY
81517: LIST
81518: LIST
81519: PUSH
81520: LD_INT 3
81522: NEG
81523: PUSH
81524: LD_INT 2
81526: NEG
81527: PUSH
81528: EMPTY
81529: LIST
81530: LIST
81531: PUSH
81532: LD_INT 4
81534: NEG
81535: PUSH
81536: LD_INT 3
81538: NEG
81539: PUSH
81540: EMPTY
81541: LIST
81542: LIST
81543: PUSH
81544: LD_INT 4
81546: NEG
81547: PUSH
81548: LD_INT 4
81550: NEG
81551: PUSH
81552: EMPTY
81553: LIST
81554: LIST
81555: PUSH
81556: LD_INT 2
81558: NEG
81559: PUSH
81560: LD_INT 4
81562: NEG
81563: PUSH
81564: EMPTY
81565: LIST
81566: LIST
81567: PUSH
81568: LD_INT 4
81570: NEG
81571: PUSH
81572: LD_INT 2
81574: NEG
81575: PUSH
81576: EMPTY
81577: LIST
81578: LIST
81579: PUSH
81580: LD_INT 0
81582: PUSH
81583: LD_INT 4
81585: NEG
81586: PUSH
81587: EMPTY
81588: LIST
81589: LIST
81590: PUSH
81591: LD_INT 0
81593: PUSH
81594: LD_INT 5
81596: NEG
81597: PUSH
81598: EMPTY
81599: LIST
81600: LIST
81601: PUSH
81602: LD_INT 1
81604: PUSH
81605: LD_INT 4
81607: NEG
81608: PUSH
81609: EMPTY
81610: LIST
81611: LIST
81612: PUSH
81613: LD_INT 1
81615: PUSH
81616: LD_INT 3
81618: NEG
81619: PUSH
81620: EMPTY
81621: LIST
81622: LIST
81623: PUSH
81624: LD_INT 0
81626: PUSH
81627: LD_INT 3
81629: NEG
81630: PUSH
81631: EMPTY
81632: LIST
81633: LIST
81634: PUSH
81635: LD_INT 1
81637: NEG
81638: PUSH
81639: LD_INT 4
81641: NEG
81642: PUSH
81643: EMPTY
81644: LIST
81645: LIST
81646: PUSH
81647: LD_INT 1
81649: NEG
81650: PUSH
81651: LD_INT 5
81653: NEG
81654: PUSH
81655: EMPTY
81656: LIST
81657: LIST
81658: PUSH
81659: LD_INT 2
81661: PUSH
81662: LD_INT 3
81664: NEG
81665: PUSH
81666: EMPTY
81667: LIST
81668: LIST
81669: PUSH
81670: LD_INT 2
81672: NEG
81673: PUSH
81674: LD_INT 5
81676: NEG
81677: PUSH
81678: EMPTY
81679: LIST
81680: LIST
81681: PUSH
81682: EMPTY
81683: LIST
81684: LIST
81685: LIST
81686: LIST
81687: LIST
81688: LIST
81689: LIST
81690: LIST
81691: LIST
81692: LIST
81693: LIST
81694: LIST
81695: LIST
81696: LIST
81697: LIST
81698: LIST
81699: LIST
81700: LIST
81701: LIST
81702: LIST
81703: LIST
81704: LIST
81705: LIST
81706: LIST
81707: LIST
81708: LIST
81709: LIST
81710: LIST
81711: LIST
81712: LIST
81713: LIST
81714: LIST
81715: LIST
81716: LIST
81717: LIST
81718: LIST
81719: LIST
81720: LIST
81721: LIST
81722: LIST
81723: LIST
81724: LIST
81725: LIST
81726: LIST
81727: LIST
81728: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
81729: LD_ADDR_VAR 0 31
81733: PUSH
81734: LD_INT 0
81736: PUSH
81737: LD_INT 4
81739: PUSH
81740: EMPTY
81741: LIST
81742: LIST
81743: PUSH
81744: LD_INT 0
81746: PUSH
81747: LD_INT 3
81749: PUSH
81750: EMPTY
81751: LIST
81752: LIST
81753: PUSH
81754: LD_INT 1
81756: PUSH
81757: LD_INT 4
81759: PUSH
81760: EMPTY
81761: LIST
81762: LIST
81763: PUSH
81764: LD_INT 1
81766: PUSH
81767: LD_INT 5
81769: PUSH
81770: EMPTY
81771: LIST
81772: LIST
81773: PUSH
81774: LD_INT 0
81776: PUSH
81777: LD_INT 5
81779: PUSH
81780: EMPTY
81781: LIST
81782: LIST
81783: PUSH
81784: LD_INT 1
81786: NEG
81787: PUSH
81788: LD_INT 4
81790: PUSH
81791: EMPTY
81792: LIST
81793: LIST
81794: PUSH
81795: LD_INT 1
81797: NEG
81798: PUSH
81799: LD_INT 3
81801: PUSH
81802: EMPTY
81803: LIST
81804: LIST
81805: PUSH
81806: LD_INT 2
81808: PUSH
81809: LD_INT 5
81811: PUSH
81812: EMPTY
81813: LIST
81814: LIST
81815: PUSH
81816: LD_INT 2
81818: NEG
81819: PUSH
81820: LD_INT 3
81822: PUSH
81823: EMPTY
81824: LIST
81825: LIST
81826: PUSH
81827: LD_INT 3
81829: NEG
81830: PUSH
81831: LD_INT 0
81833: PUSH
81834: EMPTY
81835: LIST
81836: LIST
81837: PUSH
81838: LD_INT 3
81840: NEG
81841: PUSH
81842: LD_INT 1
81844: NEG
81845: PUSH
81846: EMPTY
81847: LIST
81848: LIST
81849: PUSH
81850: LD_INT 2
81852: NEG
81853: PUSH
81854: LD_INT 0
81856: PUSH
81857: EMPTY
81858: LIST
81859: LIST
81860: PUSH
81861: LD_INT 2
81863: NEG
81864: PUSH
81865: LD_INT 1
81867: PUSH
81868: EMPTY
81869: LIST
81870: LIST
81871: PUSH
81872: LD_INT 3
81874: NEG
81875: PUSH
81876: LD_INT 1
81878: PUSH
81879: EMPTY
81880: LIST
81881: LIST
81882: PUSH
81883: LD_INT 4
81885: NEG
81886: PUSH
81887: LD_INT 0
81889: PUSH
81890: EMPTY
81891: LIST
81892: LIST
81893: PUSH
81894: LD_INT 4
81896: NEG
81897: PUSH
81898: LD_INT 1
81900: NEG
81901: PUSH
81902: EMPTY
81903: LIST
81904: LIST
81905: PUSH
81906: LD_INT 4
81908: NEG
81909: PUSH
81910: LD_INT 2
81912: NEG
81913: PUSH
81914: EMPTY
81915: LIST
81916: LIST
81917: PUSH
81918: LD_INT 2
81920: NEG
81921: PUSH
81922: LD_INT 2
81924: PUSH
81925: EMPTY
81926: LIST
81927: LIST
81928: PUSH
81929: LD_INT 4
81931: NEG
81932: PUSH
81933: LD_INT 4
81935: NEG
81936: PUSH
81937: EMPTY
81938: LIST
81939: LIST
81940: PUSH
81941: LD_INT 4
81943: NEG
81944: PUSH
81945: LD_INT 5
81947: NEG
81948: PUSH
81949: EMPTY
81950: LIST
81951: LIST
81952: PUSH
81953: LD_INT 3
81955: NEG
81956: PUSH
81957: LD_INT 4
81959: NEG
81960: PUSH
81961: EMPTY
81962: LIST
81963: LIST
81964: PUSH
81965: LD_INT 3
81967: NEG
81968: PUSH
81969: LD_INT 3
81971: NEG
81972: PUSH
81973: EMPTY
81974: LIST
81975: LIST
81976: PUSH
81977: LD_INT 4
81979: NEG
81980: PUSH
81981: LD_INT 3
81983: NEG
81984: PUSH
81985: EMPTY
81986: LIST
81987: LIST
81988: PUSH
81989: LD_INT 5
81991: NEG
81992: PUSH
81993: LD_INT 4
81995: NEG
81996: PUSH
81997: EMPTY
81998: LIST
81999: LIST
82000: PUSH
82001: LD_INT 5
82003: NEG
82004: PUSH
82005: LD_INT 5
82007: NEG
82008: PUSH
82009: EMPTY
82010: LIST
82011: LIST
82012: PUSH
82013: LD_INT 3
82015: NEG
82016: PUSH
82017: LD_INT 5
82019: NEG
82020: PUSH
82021: EMPTY
82022: LIST
82023: LIST
82024: PUSH
82025: LD_INT 5
82027: NEG
82028: PUSH
82029: LD_INT 3
82031: NEG
82032: PUSH
82033: EMPTY
82034: LIST
82035: LIST
82036: PUSH
82037: LD_INT 0
82039: PUSH
82040: LD_INT 3
82042: NEG
82043: PUSH
82044: EMPTY
82045: LIST
82046: LIST
82047: PUSH
82048: LD_INT 0
82050: PUSH
82051: LD_INT 4
82053: NEG
82054: PUSH
82055: EMPTY
82056: LIST
82057: LIST
82058: PUSH
82059: LD_INT 1
82061: PUSH
82062: LD_INT 3
82064: NEG
82065: PUSH
82066: EMPTY
82067: LIST
82068: LIST
82069: PUSH
82070: LD_INT 1
82072: PUSH
82073: LD_INT 2
82075: NEG
82076: PUSH
82077: EMPTY
82078: LIST
82079: LIST
82080: PUSH
82081: LD_INT 0
82083: PUSH
82084: LD_INT 2
82086: NEG
82087: PUSH
82088: EMPTY
82089: LIST
82090: LIST
82091: PUSH
82092: LD_INT 1
82094: NEG
82095: PUSH
82096: LD_INT 3
82098: NEG
82099: PUSH
82100: EMPTY
82101: LIST
82102: LIST
82103: PUSH
82104: LD_INT 1
82106: NEG
82107: PUSH
82108: LD_INT 4
82110: NEG
82111: PUSH
82112: EMPTY
82113: LIST
82114: LIST
82115: PUSH
82116: LD_INT 2
82118: PUSH
82119: LD_INT 2
82121: NEG
82122: PUSH
82123: EMPTY
82124: LIST
82125: LIST
82126: PUSH
82127: LD_INT 2
82129: NEG
82130: PUSH
82131: LD_INT 4
82133: NEG
82134: PUSH
82135: EMPTY
82136: LIST
82137: LIST
82138: PUSH
82139: LD_INT 4
82141: PUSH
82142: LD_INT 0
82144: PUSH
82145: EMPTY
82146: LIST
82147: LIST
82148: PUSH
82149: LD_INT 4
82151: PUSH
82152: LD_INT 1
82154: NEG
82155: PUSH
82156: EMPTY
82157: LIST
82158: LIST
82159: PUSH
82160: LD_INT 5
82162: PUSH
82163: LD_INT 0
82165: PUSH
82166: EMPTY
82167: LIST
82168: LIST
82169: PUSH
82170: LD_INT 5
82172: PUSH
82173: LD_INT 1
82175: PUSH
82176: EMPTY
82177: LIST
82178: LIST
82179: PUSH
82180: LD_INT 4
82182: PUSH
82183: LD_INT 1
82185: PUSH
82186: EMPTY
82187: LIST
82188: LIST
82189: PUSH
82190: LD_INT 3
82192: PUSH
82193: LD_INT 0
82195: PUSH
82196: EMPTY
82197: LIST
82198: LIST
82199: PUSH
82200: LD_INT 3
82202: PUSH
82203: LD_INT 1
82205: NEG
82206: PUSH
82207: EMPTY
82208: LIST
82209: LIST
82210: PUSH
82211: LD_INT 3
82213: PUSH
82214: LD_INT 2
82216: NEG
82217: PUSH
82218: EMPTY
82219: LIST
82220: LIST
82221: PUSH
82222: LD_INT 5
82224: PUSH
82225: LD_INT 2
82227: PUSH
82228: EMPTY
82229: LIST
82230: LIST
82231: PUSH
82232: EMPTY
82233: LIST
82234: LIST
82235: LIST
82236: LIST
82237: LIST
82238: LIST
82239: LIST
82240: LIST
82241: LIST
82242: LIST
82243: LIST
82244: LIST
82245: LIST
82246: LIST
82247: LIST
82248: LIST
82249: LIST
82250: LIST
82251: LIST
82252: LIST
82253: LIST
82254: LIST
82255: LIST
82256: LIST
82257: LIST
82258: LIST
82259: LIST
82260: LIST
82261: LIST
82262: LIST
82263: LIST
82264: LIST
82265: LIST
82266: LIST
82267: LIST
82268: LIST
82269: LIST
82270: LIST
82271: LIST
82272: LIST
82273: LIST
82274: LIST
82275: LIST
82276: LIST
82277: LIST
82278: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
82279: LD_ADDR_VAR 0 32
82283: PUSH
82284: LD_INT 4
82286: NEG
82287: PUSH
82288: LD_INT 0
82290: PUSH
82291: EMPTY
82292: LIST
82293: LIST
82294: PUSH
82295: LD_INT 4
82297: NEG
82298: PUSH
82299: LD_INT 1
82301: NEG
82302: PUSH
82303: EMPTY
82304: LIST
82305: LIST
82306: PUSH
82307: LD_INT 3
82309: NEG
82310: PUSH
82311: LD_INT 0
82313: PUSH
82314: EMPTY
82315: LIST
82316: LIST
82317: PUSH
82318: LD_INT 3
82320: NEG
82321: PUSH
82322: LD_INT 1
82324: PUSH
82325: EMPTY
82326: LIST
82327: LIST
82328: PUSH
82329: LD_INT 4
82331: NEG
82332: PUSH
82333: LD_INT 1
82335: PUSH
82336: EMPTY
82337: LIST
82338: LIST
82339: PUSH
82340: LD_INT 5
82342: NEG
82343: PUSH
82344: LD_INT 0
82346: PUSH
82347: EMPTY
82348: LIST
82349: LIST
82350: PUSH
82351: LD_INT 5
82353: NEG
82354: PUSH
82355: LD_INT 1
82357: NEG
82358: PUSH
82359: EMPTY
82360: LIST
82361: LIST
82362: PUSH
82363: LD_INT 5
82365: NEG
82366: PUSH
82367: LD_INT 2
82369: NEG
82370: PUSH
82371: EMPTY
82372: LIST
82373: LIST
82374: PUSH
82375: LD_INT 3
82377: NEG
82378: PUSH
82379: LD_INT 2
82381: PUSH
82382: EMPTY
82383: LIST
82384: LIST
82385: PUSH
82386: LD_INT 3
82388: NEG
82389: PUSH
82390: LD_INT 3
82392: NEG
82393: PUSH
82394: EMPTY
82395: LIST
82396: LIST
82397: PUSH
82398: LD_INT 3
82400: NEG
82401: PUSH
82402: LD_INT 4
82404: NEG
82405: PUSH
82406: EMPTY
82407: LIST
82408: LIST
82409: PUSH
82410: LD_INT 2
82412: NEG
82413: PUSH
82414: LD_INT 3
82416: NEG
82417: PUSH
82418: EMPTY
82419: LIST
82420: LIST
82421: PUSH
82422: LD_INT 2
82424: NEG
82425: PUSH
82426: LD_INT 2
82428: NEG
82429: PUSH
82430: EMPTY
82431: LIST
82432: LIST
82433: PUSH
82434: LD_INT 3
82436: NEG
82437: PUSH
82438: LD_INT 2
82440: NEG
82441: PUSH
82442: EMPTY
82443: LIST
82444: LIST
82445: PUSH
82446: LD_INT 4
82448: NEG
82449: PUSH
82450: LD_INT 3
82452: NEG
82453: PUSH
82454: EMPTY
82455: LIST
82456: LIST
82457: PUSH
82458: LD_INT 4
82460: NEG
82461: PUSH
82462: LD_INT 4
82464: NEG
82465: PUSH
82466: EMPTY
82467: LIST
82468: LIST
82469: PUSH
82470: LD_INT 2
82472: NEG
82473: PUSH
82474: LD_INT 4
82476: NEG
82477: PUSH
82478: EMPTY
82479: LIST
82480: LIST
82481: PUSH
82482: LD_INT 4
82484: NEG
82485: PUSH
82486: LD_INT 2
82488: NEG
82489: PUSH
82490: EMPTY
82491: LIST
82492: LIST
82493: PUSH
82494: LD_INT 0
82496: PUSH
82497: LD_INT 4
82499: NEG
82500: PUSH
82501: EMPTY
82502: LIST
82503: LIST
82504: PUSH
82505: LD_INT 0
82507: PUSH
82508: LD_INT 5
82510: NEG
82511: PUSH
82512: EMPTY
82513: LIST
82514: LIST
82515: PUSH
82516: LD_INT 1
82518: PUSH
82519: LD_INT 4
82521: NEG
82522: PUSH
82523: EMPTY
82524: LIST
82525: LIST
82526: PUSH
82527: LD_INT 1
82529: PUSH
82530: LD_INT 3
82532: NEG
82533: PUSH
82534: EMPTY
82535: LIST
82536: LIST
82537: PUSH
82538: LD_INT 0
82540: PUSH
82541: LD_INT 3
82543: NEG
82544: PUSH
82545: EMPTY
82546: LIST
82547: LIST
82548: PUSH
82549: LD_INT 1
82551: NEG
82552: PUSH
82553: LD_INT 4
82555: NEG
82556: PUSH
82557: EMPTY
82558: LIST
82559: LIST
82560: PUSH
82561: LD_INT 1
82563: NEG
82564: PUSH
82565: LD_INT 5
82567: NEG
82568: PUSH
82569: EMPTY
82570: LIST
82571: LIST
82572: PUSH
82573: LD_INT 2
82575: PUSH
82576: LD_INT 3
82578: NEG
82579: PUSH
82580: EMPTY
82581: LIST
82582: LIST
82583: PUSH
82584: LD_INT 2
82586: NEG
82587: PUSH
82588: LD_INT 5
82590: NEG
82591: PUSH
82592: EMPTY
82593: LIST
82594: LIST
82595: PUSH
82596: LD_INT 3
82598: PUSH
82599: LD_INT 0
82601: PUSH
82602: EMPTY
82603: LIST
82604: LIST
82605: PUSH
82606: LD_INT 3
82608: PUSH
82609: LD_INT 1
82611: NEG
82612: PUSH
82613: EMPTY
82614: LIST
82615: LIST
82616: PUSH
82617: LD_INT 4
82619: PUSH
82620: LD_INT 0
82622: PUSH
82623: EMPTY
82624: LIST
82625: LIST
82626: PUSH
82627: LD_INT 4
82629: PUSH
82630: LD_INT 1
82632: PUSH
82633: EMPTY
82634: LIST
82635: LIST
82636: PUSH
82637: LD_INT 3
82639: PUSH
82640: LD_INT 1
82642: PUSH
82643: EMPTY
82644: LIST
82645: LIST
82646: PUSH
82647: LD_INT 2
82649: PUSH
82650: LD_INT 0
82652: PUSH
82653: EMPTY
82654: LIST
82655: LIST
82656: PUSH
82657: LD_INT 2
82659: PUSH
82660: LD_INT 1
82662: NEG
82663: PUSH
82664: EMPTY
82665: LIST
82666: LIST
82667: PUSH
82668: LD_INT 2
82670: PUSH
82671: LD_INT 2
82673: NEG
82674: PUSH
82675: EMPTY
82676: LIST
82677: LIST
82678: PUSH
82679: LD_INT 4
82681: PUSH
82682: LD_INT 2
82684: PUSH
82685: EMPTY
82686: LIST
82687: LIST
82688: PUSH
82689: LD_INT 4
82691: PUSH
82692: LD_INT 4
82694: PUSH
82695: EMPTY
82696: LIST
82697: LIST
82698: PUSH
82699: LD_INT 4
82701: PUSH
82702: LD_INT 3
82704: PUSH
82705: EMPTY
82706: LIST
82707: LIST
82708: PUSH
82709: LD_INT 5
82711: PUSH
82712: LD_INT 4
82714: PUSH
82715: EMPTY
82716: LIST
82717: LIST
82718: PUSH
82719: LD_INT 5
82721: PUSH
82722: LD_INT 5
82724: PUSH
82725: EMPTY
82726: LIST
82727: LIST
82728: PUSH
82729: LD_INT 4
82731: PUSH
82732: LD_INT 5
82734: PUSH
82735: EMPTY
82736: LIST
82737: LIST
82738: PUSH
82739: LD_INT 3
82741: PUSH
82742: LD_INT 4
82744: PUSH
82745: EMPTY
82746: LIST
82747: LIST
82748: PUSH
82749: LD_INT 3
82751: PUSH
82752: LD_INT 3
82754: PUSH
82755: EMPTY
82756: LIST
82757: LIST
82758: PUSH
82759: LD_INT 5
82761: PUSH
82762: LD_INT 3
82764: PUSH
82765: EMPTY
82766: LIST
82767: LIST
82768: PUSH
82769: LD_INT 3
82771: PUSH
82772: LD_INT 5
82774: PUSH
82775: EMPTY
82776: LIST
82777: LIST
82778: PUSH
82779: EMPTY
82780: LIST
82781: LIST
82782: LIST
82783: LIST
82784: LIST
82785: LIST
82786: LIST
82787: LIST
82788: LIST
82789: LIST
82790: LIST
82791: LIST
82792: LIST
82793: LIST
82794: LIST
82795: LIST
82796: LIST
82797: LIST
82798: LIST
82799: LIST
82800: LIST
82801: LIST
82802: LIST
82803: LIST
82804: LIST
82805: LIST
82806: LIST
82807: LIST
82808: LIST
82809: LIST
82810: LIST
82811: LIST
82812: LIST
82813: LIST
82814: LIST
82815: LIST
82816: LIST
82817: LIST
82818: LIST
82819: LIST
82820: LIST
82821: LIST
82822: LIST
82823: LIST
82824: LIST
82825: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
82826: LD_ADDR_VAR 0 33
82830: PUSH
82831: LD_INT 4
82833: NEG
82834: PUSH
82835: LD_INT 4
82837: NEG
82838: PUSH
82839: EMPTY
82840: LIST
82841: LIST
82842: PUSH
82843: LD_INT 4
82845: NEG
82846: PUSH
82847: LD_INT 5
82849: NEG
82850: PUSH
82851: EMPTY
82852: LIST
82853: LIST
82854: PUSH
82855: LD_INT 3
82857: NEG
82858: PUSH
82859: LD_INT 4
82861: NEG
82862: PUSH
82863: EMPTY
82864: LIST
82865: LIST
82866: PUSH
82867: LD_INT 3
82869: NEG
82870: PUSH
82871: LD_INT 3
82873: NEG
82874: PUSH
82875: EMPTY
82876: LIST
82877: LIST
82878: PUSH
82879: LD_INT 4
82881: NEG
82882: PUSH
82883: LD_INT 3
82885: NEG
82886: PUSH
82887: EMPTY
82888: LIST
82889: LIST
82890: PUSH
82891: LD_INT 5
82893: NEG
82894: PUSH
82895: LD_INT 4
82897: NEG
82898: PUSH
82899: EMPTY
82900: LIST
82901: LIST
82902: PUSH
82903: LD_INT 5
82905: NEG
82906: PUSH
82907: LD_INT 5
82909: NEG
82910: PUSH
82911: EMPTY
82912: LIST
82913: LIST
82914: PUSH
82915: LD_INT 3
82917: NEG
82918: PUSH
82919: LD_INT 5
82921: NEG
82922: PUSH
82923: EMPTY
82924: LIST
82925: LIST
82926: PUSH
82927: LD_INT 5
82929: NEG
82930: PUSH
82931: LD_INT 3
82933: NEG
82934: PUSH
82935: EMPTY
82936: LIST
82937: LIST
82938: PUSH
82939: LD_INT 0
82941: PUSH
82942: LD_INT 3
82944: NEG
82945: PUSH
82946: EMPTY
82947: LIST
82948: LIST
82949: PUSH
82950: LD_INT 0
82952: PUSH
82953: LD_INT 4
82955: NEG
82956: PUSH
82957: EMPTY
82958: LIST
82959: LIST
82960: PUSH
82961: LD_INT 1
82963: PUSH
82964: LD_INT 3
82966: NEG
82967: PUSH
82968: EMPTY
82969: LIST
82970: LIST
82971: PUSH
82972: LD_INT 1
82974: PUSH
82975: LD_INT 2
82977: NEG
82978: PUSH
82979: EMPTY
82980: LIST
82981: LIST
82982: PUSH
82983: LD_INT 0
82985: PUSH
82986: LD_INT 2
82988: NEG
82989: PUSH
82990: EMPTY
82991: LIST
82992: LIST
82993: PUSH
82994: LD_INT 1
82996: NEG
82997: PUSH
82998: LD_INT 3
83000: NEG
83001: PUSH
83002: EMPTY
83003: LIST
83004: LIST
83005: PUSH
83006: LD_INT 1
83008: NEG
83009: PUSH
83010: LD_INT 4
83012: NEG
83013: PUSH
83014: EMPTY
83015: LIST
83016: LIST
83017: PUSH
83018: LD_INT 2
83020: PUSH
83021: LD_INT 2
83023: NEG
83024: PUSH
83025: EMPTY
83026: LIST
83027: LIST
83028: PUSH
83029: LD_INT 2
83031: NEG
83032: PUSH
83033: LD_INT 4
83035: NEG
83036: PUSH
83037: EMPTY
83038: LIST
83039: LIST
83040: PUSH
83041: LD_INT 4
83043: PUSH
83044: LD_INT 0
83046: PUSH
83047: EMPTY
83048: LIST
83049: LIST
83050: PUSH
83051: LD_INT 4
83053: PUSH
83054: LD_INT 1
83056: NEG
83057: PUSH
83058: EMPTY
83059: LIST
83060: LIST
83061: PUSH
83062: LD_INT 5
83064: PUSH
83065: LD_INT 0
83067: PUSH
83068: EMPTY
83069: LIST
83070: LIST
83071: PUSH
83072: LD_INT 5
83074: PUSH
83075: LD_INT 1
83077: PUSH
83078: EMPTY
83079: LIST
83080: LIST
83081: PUSH
83082: LD_INT 4
83084: PUSH
83085: LD_INT 1
83087: PUSH
83088: EMPTY
83089: LIST
83090: LIST
83091: PUSH
83092: LD_INT 3
83094: PUSH
83095: LD_INT 0
83097: PUSH
83098: EMPTY
83099: LIST
83100: LIST
83101: PUSH
83102: LD_INT 3
83104: PUSH
83105: LD_INT 1
83107: NEG
83108: PUSH
83109: EMPTY
83110: LIST
83111: LIST
83112: PUSH
83113: LD_INT 3
83115: PUSH
83116: LD_INT 2
83118: NEG
83119: PUSH
83120: EMPTY
83121: LIST
83122: LIST
83123: PUSH
83124: LD_INT 5
83126: PUSH
83127: LD_INT 2
83129: PUSH
83130: EMPTY
83131: LIST
83132: LIST
83133: PUSH
83134: LD_INT 3
83136: PUSH
83137: LD_INT 3
83139: PUSH
83140: EMPTY
83141: LIST
83142: LIST
83143: PUSH
83144: LD_INT 3
83146: PUSH
83147: LD_INT 2
83149: PUSH
83150: EMPTY
83151: LIST
83152: LIST
83153: PUSH
83154: LD_INT 4
83156: PUSH
83157: LD_INT 3
83159: PUSH
83160: EMPTY
83161: LIST
83162: LIST
83163: PUSH
83164: LD_INT 4
83166: PUSH
83167: LD_INT 4
83169: PUSH
83170: EMPTY
83171: LIST
83172: LIST
83173: PUSH
83174: LD_INT 3
83176: PUSH
83177: LD_INT 4
83179: PUSH
83180: EMPTY
83181: LIST
83182: LIST
83183: PUSH
83184: LD_INT 2
83186: PUSH
83187: LD_INT 3
83189: PUSH
83190: EMPTY
83191: LIST
83192: LIST
83193: PUSH
83194: LD_INT 2
83196: PUSH
83197: LD_INT 2
83199: PUSH
83200: EMPTY
83201: LIST
83202: LIST
83203: PUSH
83204: LD_INT 4
83206: PUSH
83207: LD_INT 2
83209: PUSH
83210: EMPTY
83211: LIST
83212: LIST
83213: PUSH
83214: LD_INT 2
83216: PUSH
83217: LD_INT 4
83219: PUSH
83220: EMPTY
83221: LIST
83222: LIST
83223: PUSH
83224: LD_INT 0
83226: PUSH
83227: LD_INT 4
83229: PUSH
83230: EMPTY
83231: LIST
83232: LIST
83233: PUSH
83234: LD_INT 0
83236: PUSH
83237: LD_INT 3
83239: PUSH
83240: EMPTY
83241: LIST
83242: LIST
83243: PUSH
83244: LD_INT 1
83246: PUSH
83247: LD_INT 4
83249: PUSH
83250: EMPTY
83251: LIST
83252: LIST
83253: PUSH
83254: LD_INT 1
83256: PUSH
83257: LD_INT 5
83259: PUSH
83260: EMPTY
83261: LIST
83262: LIST
83263: PUSH
83264: LD_INT 0
83266: PUSH
83267: LD_INT 5
83269: PUSH
83270: EMPTY
83271: LIST
83272: LIST
83273: PUSH
83274: LD_INT 1
83276: NEG
83277: PUSH
83278: LD_INT 4
83280: PUSH
83281: EMPTY
83282: LIST
83283: LIST
83284: PUSH
83285: LD_INT 1
83287: NEG
83288: PUSH
83289: LD_INT 3
83291: PUSH
83292: EMPTY
83293: LIST
83294: LIST
83295: PUSH
83296: LD_INT 2
83298: PUSH
83299: LD_INT 5
83301: PUSH
83302: EMPTY
83303: LIST
83304: LIST
83305: PUSH
83306: LD_INT 2
83308: NEG
83309: PUSH
83310: LD_INT 3
83312: PUSH
83313: EMPTY
83314: LIST
83315: LIST
83316: PUSH
83317: EMPTY
83318: LIST
83319: LIST
83320: LIST
83321: LIST
83322: LIST
83323: LIST
83324: LIST
83325: LIST
83326: LIST
83327: LIST
83328: LIST
83329: LIST
83330: LIST
83331: LIST
83332: LIST
83333: LIST
83334: LIST
83335: LIST
83336: LIST
83337: LIST
83338: LIST
83339: LIST
83340: LIST
83341: LIST
83342: LIST
83343: LIST
83344: LIST
83345: LIST
83346: LIST
83347: LIST
83348: LIST
83349: LIST
83350: LIST
83351: LIST
83352: LIST
83353: LIST
83354: LIST
83355: LIST
83356: LIST
83357: LIST
83358: LIST
83359: LIST
83360: LIST
83361: LIST
83362: LIST
83363: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
83364: LD_ADDR_VAR 0 34
83368: PUSH
83369: LD_INT 0
83371: PUSH
83372: LD_INT 4
83374: NEG
83375: PUSH
83376: EMPTY
83377: LIST
83378: LIST
83379: PUSH
83380: LD_INT 0
83382: PUSH
83383: LD_INT 5
83385: NEG
83386: PUSH
83387: EMPTY
83388: LIST
83389: LIST
83390: PUSH
83391: LD_INT 1
83393: PUSH
83394: LD_INT 4
83396: NEG
83397: PUSH
83398: EMPTY
83399: LIST
83400: LIST
83401: PUSH
83402: LD_INT 1
83404: PUSH
83405: LD_INT 3
83407: NEG
83408: PUSH
83409: EMPTY
83410: LIST
83411: LIST
83412: PUSH
83413: LD_INT 0
83415: PUSH
83416: LD_INT 3
83418: NEG
83419: PUSH
83420: EMPTY
83421: LIST
83422: LIST
83423: PUSH
83424: LD_INT 1
83426: NEG
83427: PUSH
83428: LD_INT 4
83430: NEG
83431: PUSH
83432: EMPTY
83433: LIST
83434: LIST
83435: PUSH
83436: LD_INT 1
83438: NEG
83439: PUSH
83440: LD_INT 5
83442: NEG
83443: PUSH
83444: EMPTY
83445: LIST
83446: LIST
83447: PUSH
83448: LD_INT 2
83450: PUSH
83451: LD_INT 3
83453: NEG
83454: PUSH
83455: EMPTY
83456: LIST
83457: LIST
83458: PUSH
83459: LD_INT 2
83461: NEG
83462: PUSH
83463: LD_INT 5
83465: NEG
83466: PUSH
83467: EMPTY
83468: LIST
83469: LIST
83470: PUSH
83471: LD_INT 3
83473: PUSH
83474: LD_INT 0
83476: PUSH
83477: EMPTY
83478: LIST
83479: LIST
83480: PUSH
83481: LD_INT 3
83483: PUSH
83484: LD_INT 1
83486: NEG
83487: PUSH
83488: EMPTY
83489: LIST
83490: LIST
83491: PUSH
83492: LD_INT 4
83494: PUSH
83495: LD_INT 0
83497: PUSH
83498: EMPTY
83499: LIST
83500: LIST
83501: PUSH
83502: LD_INT 4
83504: PUSH
83505: LD_INT 1
83507: PUSH
83508: EMPTY
83509: LIST
83510: LIST
83511: PUSH
83512: LD_INT 3
83514: PUSH
83515: LD_INT 1
83517: PUSH
83518: EMPTY
83519: LIST
83520: LIST
83521: PUSH
83522: LD_INT 2
83524: PUSH
83525: LD_INT 0
83527: PUSH
83528: EMPTY
83529: LIST
83530: LIST
83531: PUSH
83532: LD_INT 2
83534: PUSH
83535: LD_INT 1
83537: NEG
83538: PUSH
83539: EMPTY
83540: LIST
83541: LIST
83542: PUSH
83543: LD_INT 2
83545: PUSH
83546: LD_INT 2
83548: NEG
83549: PUSH
83550: EMPTY
83551: LIST
83552: LIST
83553: PUSH
83554: LD_INT 4
83556: PUSH
83557: LD_INT 2
83559: PUSH
83560: EMPTY
83561: LIST
83562: LIST
83563: PUSH
83564: LD_INT 4
83566: PUSH
83567: LD_INT 4
83569: PUSH
83570: EMPTY
83571: LIST
83572: LIST
83573: PUSH
83574: LD_INT 4
83576: PUSH
83577: LD_INT 3
83579: PUSH
83580: EMPTY
83581: LIST
83582: LIST
83583: PUSH
83584: LD_INT 5
83586: PUSH
83587: LD_INT 4
83589: PUSH
83590: EMPTY
83591: LIST
83592: LIST
83593: PUSH
83594: LD_INT 5
83596: PUSH
83597: LD_INT 5
83599: PUSH
83600: EMPTY
83601: LIST
83602: LIST
83603: PUSH
83604: LD_INT 4
83606: PUSH
83607: LD_INT 5
83609: PUSH
83610: EMPTY
83611: LIST
83612: LIST
83613: PUSH
83614: LD_INT 3
83616: PUSH
83617: LD_INT 4
83619: PUSH
83620: EMPTY
83621: LIST
83622: LIST
83623: PUSH
83624: LD_INT 3
83626: PUSH
83627: LD_INT 3
83629: PUSH
83630: EMPTY
83631: LIST
83632: LIST
83633: PUSH
83634: LD_INT 5
83636: PUSH
83637: LD_INT 3
83639: PUSH
83640: EMPTY
83641: LIST
83642: LIST
83643: PUSH
83644: LD_INT 3
83646: PUSH
83647: LD_INT 5
83649: PUSH
83650: EMPTY
83651: LIST
83652: LIST
83653: PUSH
83654: LD_INT 0
83656: PUSH
83657: LD_INT 3
83659: PUSH
83660: EMPTY
83661: LIST
83662: LIST
83663: PUSH
83664: LD_INT 0
83666: PUSH
83667: LD_INT 2
83669: PUSH
83670: EMPTY
83671: LIST
83672: LIST
83673: PUSH
83674: LD_INT 1
83676: PUSH
83677: LD_INT 3
83679: PUSH
83680: EMPTY
83681: LIST
83682: LIST
83683: PUSH
83684: LD_INT 1
83686: PUSH
83687: LD_INT 4
83689: PUSH
83690: EMPTY
83691: LIST
83692: LIST
83693: PUSH
83694: LD_INT 0
83696: PUSH
83697: LD_INT 4
83699: PUSH
83700: EMPTY
83701: LIST
83702: LIST
83703: PUSH
83704: LD_INT 1
83706: NEG
83707: PUSH
83708: LD_INT 3
83710: PUSH
83711: EMPTY
83712: LIST
83713: LIST
83714: PUSH
83715: LD_INT 1
83717: NEG
83718: PUSH
83719: LD_INT 2
83721: PUSH
83722: EMPTY
83723: LIST
83724: LIST
83725: PUSH
83726: LD_INT 2
83728: PUSH
83729: LD_INT 4
83731: PUSH
83732: EMPTY
83733: LIST
83734: LIST
83735: PUSH
83736: LD_INT 2
83738: NEG
83739: PUSH
83740: LD_INT 2
83742: PUSH
83743: EMPTY
83744: LIST
83745: LIST
83746: PUSH
83747: LD_INT 4
83749: NEG
83750: PUSH
83751: LD_INT 0
83753: PUSH
83754: EMPTY
83755: LIST
83756: LIST
83757: PUSH
83758: LD_INT 4
83760: NEG
83761: PUSH
83762: LD_INT 1
83764: NEG
83765: PUSH
83766: EMPTY
83767: LIST
83768: LIST
83769: PUSH
83770: LD_INT 3
83772: NEG
83773: PUSH
83774: LD_INT 0
83776: PUSH
83777: EMPTY
83778: LIST
83779: LIST
83780: PUSH
83781: LD_INT 3
83783: NEG
83784: PUSH
83785: LD_INT 1
83787: PUSH
83788: EMPTY
83789: LIST
83790: LIST
83791: PUSH
83792: LD_INT 4
83794: NEG
83795: PUSH
83796: LD_INT 1
83798: PUSH
83799: EMPTY
83800: LIST
83801: LIST
83802: PUSH
83803: LD_INT 5
83805: NEG
83806: PUSH
83807: LD_INT 0
83809: PUSH
83810: EMPTY
83811: LIST
83812: LIST
83813: PUSH
83814: LD_INT 5
83816: NEG
83817: PUSH
83818: LD_INT 1
83820: NEG
83821: PUSH
83822: EMPTY
83823: LIST
83824: LIST
83825: PUSH
83826: LD_INT 5
83828: NEG
83829: PUSH
83830: LD_INT 2
83832: NEG
83833: PUSH
83834: EMPTY
83835: LIST
83836: LIST
83837: PUSH
83838: LD_INT 3
83840: NEG
83841: PUSH
83842: LD_INT 2
83844: PUSH
83845: EMPTY
83846: LIST
83847: LIST
83848: PUSH
83849: EMPTY
83850: LIST
83851: LIST
83852: LIST
83853: LIST
83854: LIST
83855: LIST
83856: LIST
83857: LIST
83858: LIST
83859: LIST
83860: LIST
83861: LIST
83862: LIST
83863: LIST
83864: LIST
83865: LIST
83866: LIST
83867: LIST
83868: LIST
83869: LIST
83870: LIST
83871: LIST
83872: LIST
83873: LIST
83874: LIST
83875: LIST
83876: LIST
83877: LIST
83878: LIST
83879: LIST
83880: LIST
83881: LIST
83882: LIST
83883: LIST
83884: LIST
83885: LIST
83886: LIST
83887: LIST
83888: LIST
83889: LIST
83890: LIST
83891: LIST
83892: LIST
83893: LIST
83894: LIST
83895: ST_TO_ADDR
// end ; end ;
83896: GO 83899
83898: POP
// case btype of b_depot , b_warehouse :
83899: LD_VAR 0 1
83903: PUSH
83904: LD_INT 0
83906: DOUBLE
83907: EQUAL
83908: IFTRUE 83918
83910: LD_INT 1
83912: DOUBLE
83913: EQUAL
83914: IFTRUE 83918
83916: GO 84119
83918: POP
// case nation of nation_american :
83919: LD_VAR 0 5
83923: PUSH
83924: LD_INT 1
83926: DOUBLE
83927: EQUAL
83928: IFTRUE 83932
83930: GO 83988
83932: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
83933: LD_ADDR_VAR 0 9
83937: PUSH
83938: LD_VAR 0 11
83942: PUSH
83943: LD_VAR 0 12
83947: PUSH
83948: LD_VAR 0 13
83952: PUSH
83953: LD_VAR 0 14
83957: PUSH
83958: LD_VAR 0 15
83962: PUSH
83963: LD_VAR 0 16
83967: PUSH
83968: EMPTY
83969: LIST
83970: LIST
83971: LIST
83972: LIST
83973: LIST
83974: LIST
83975: PUSH
83976: LD_VAR 0 4
83980: PUSH
83981: LD_INT 1
83983: PLUS
83984: ARRAY
83985: ST_TO_ADDR
83986: GO 84117
83988: LD_INT 2
83990: DOUBLE
83991: EQUAL
83992: IFTRUE 83996
83994: GO 84052
83996: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
83997: LD_ADDR_VAR 0 9
84001: PUSH
84002: LD_VAR 0 17
84006: PUSH
84007: LD_VAR 0 18
84011: PUSH
84012: LD_VAR 0 19
84016: PUSH
84017: LD_VAR 0 20
84021: PUSH
84022: LD_VAR 0 21
84026: PUSH
84027: LD_VAR 0 22
84031: PUSH
84032: EMPTY
84033: LIST
84034: LIST
84035: LIST
84036: LIST
84037: LIST
84038: LIST
84039: PUSH
84040: LD_VAR 0 4
84044: PUSH
84045: LD_INT 1
84047: PLUS
84048: ARRAY
84049: ST_TO_ADDR
84050: GO 84117
84052: LD_INT 3
84054: DOUBLE
84055: EQUAL
84056: IFTRUE 84060
84058: GO 84116
84060: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
84061: LD_ADDR_VAR 0 9
84065: PUSH
84066: LD_VAR 0 23
84070: PUSH
84071: LD_VAR 0 24
84075: PUSH
84076: LD_VAR 0 25
84080: PUSH
84081: LD_VAR 0 26
84085: PUSH
84086: LD_VAR 0 27
84090: PUSH
84091: LD_VAR 0 28
84095: PUSH
84096: EMPTY
84097: LIST
84098: LIST
84099: LIST
84100: LIST
84101: LIST
84102: LIST
84103: PUSH
84104: LD_VAR 0 4
84108: PUSH
84109: LD_INT 1
84111: PLUS
84112: ARRAY
84113: ST_TO_ADDR
84114: GO 84117
84116: POP
84117: GO 84672
84119: LD_INT 2
84121: DOUBLE
84122: EQUAL
84123: IFTRUE 84133
84125: LD_INT 3
84127: DOUBLE
84128: EQUAL
84129: IFTRUE 84133
84131: GO 84189
84133: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
84134: LD_ADDR_VAR 0 9
84138: PUSH
84139: LD_VAR 0 29
84143: PUSH
84144: LD_VAR 0 30
84148: PUSH
84149: LD_VAR 0 31
84153: PUSH
84154: LD_VAR 0 32
84158: PUSH
84159: LD_VAR 0 33
84163: PUSH
84164: LD_VAR 0 34
84168: PUSH
84169: EMPTY
84170: LIST
84171: LIST
84172: LIST
84173: LIST
84174: LIST
84175: LIST
84176: PUSH
84177: LD_VAR 0 4
84181: PUSH
84182: LD_INT 1
84184: PLUS
84185: ARRAY
84186: ST_TO_ADDR
84187: GO 84672
84189: LD_INT 16
84191: DOUBLE
84192: EQUAL
84193: IFTRUE 84251
84195: LD_INT 17
84197: DOUBLE
84198: EQUAL
84199: IFTRUE 84251
84201: LD_INT 18
84203: DOUBLE
84204: EQUAL
84205: IFTRUE 84251
84207: LD_INT 19
84209: DOUBLE
84210: EQUAL
84211: IFTRUE 84251
84213: LD_INT 22
84215: DOUBLE
84216: EQUAL
84217: IFTRUE 84251
84219: LD_INT 20
84221: DOUBLE
84222: EQUAL
84223: IFTRUE 84251
84225: LD_INT 21
84227: DOUBLE
84228: EQUAL
84229: IFTRUE 84251
84231: LD_INT 23
84233: DOUBLE
84234: EQUAL
84235: IFTRUE 84251
84237: LD_INT 24
84239: DOUBLE
84240: EQUAL
84241: IFTRUE 84251
84243: LD_INT 25
84245: DOUBLE
84246: EQUAL
84247: IFTRUE 84251
84249: GO 84307
84251: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
84252: LD_ADDR_VAR 0 9
84256: PUSH
84257: LD_VAR 0 35
84261: PUSH
84262: LD_VAR 0 36
84266: PUSH
84267: LD_VAR 0 37
84271: PUSH
84272: LD_VAR 0 38
84276: PUSH
84277: LD_VAR 0 39
84281: PUSH
84282: LD_VAR 0 40
84286: PUSH
84287: EMPTY
84288: LIST
84289: LIST
84290: LIST
84291: LIST
84292: LIST
84293: LIST
84294: PUSH
84295: LD_VAR 0 4
84299: PUSH
84300: LD_INT 1
84302: PLUS
84303: ARRAY
84304: ST_TO_ADDR
84305: GO 84672
84307: LD_INT 6
84309: DOUBLE
84310: EQUAL
84311: IFTRUE 84363
84313: LD_INT 7
84315: DOUBLE
84316: EQUAL
84317: IFTRUE 84363
84319: LD_INT 8
84321: DOUBLE
84322: EQUAL
84323: IFTRUE 84363
84325: LD_INT 13
84327: DOUBLE
84328: EQUAL
84329: IFTRUE 84363
84331: LD_INT 12
84333: DOUBLE
84334: EQUAL
84335: IFTRUE 84363
84337: LD_INT 15
84339: DOUBLE
84340: EQUAL
84341: IFTRUE 84363
84343: LD_INT 11
84345: DOUBLE
84346: EQUAL
84347: IFTRUE 84363
84349: LD_INT 14
84351: DOUBLE
84352: EQUAL
84353: IFTRUE 84363
84355: LD_INT 10
84357: DOUBLE
84358: EQUAL
84359: IFTRUE 84363
84361: GO 84419
84363: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
84364: LD_ADDR_VAR 0 9
84368: PUSH
84369: LD_VAR 0 41
84373: PUSH
84374: LD_VAR 0 42
84378: PUSH
84379: LD_VAR 0 43
84383: PUSH
84384: LD_VAR 0 44
84388: PUSH
84389: LD_VAR 0 45
84393: PUSH
84394: LD_VAR 0 46
84398: PUSH
84399: EMPTY
84400: LIST
84401: LIST
84402: LIST
84403: LIST
84404: LIST
84405: LIST
84406: PUSH
84407: LD_VAR 0 4
84411: PUSH
84412: LD_INT 1
84414: PLUS
84415: ARRAY
84416: ST_TO_ADDR
84417: GO 84672
84419: LD_INT 36
84421: DOUBLE
84422: EQUAL
84423: IFTRUE 84427
84425: GO 84483
84427: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
84428: LD_ADDR_VAR 0 9
84432: PUSH
84433: LD_VAR 0 47
84437: PUSH
84438: LD_VAR 0 48
84442: PUSH
84443: LD_VAR 0 49
84447: PUSH
84448: LD_VAR 0 50
84452: PUSH
84453: LD_VAR 0 51
84457: PUSH
84458: LD_VAR 0 52
84462: PUSH
84463: EMPTY
84464: LIST
84465: LIST
84466: LIST
84467: LIST
84468: LIST
84469: LIST
84470: PUSH
84471: LD_VAR 0 4
84475: PUSH
84476: LD_INT 1
84478: PLUS
84479: ARRAY
84480: ST_TO_ADDR
84481: GO 84672
84483: LD_INT 4
84485: DOUBLE
84486: EQUAL
84487: IFTRUE 84509
84489: LD_INT 5
84491: DOUBLE
84492: EQUAL
84493: IFTRUE 84509
84495: LD_INT 34
84497: DOUBLE
84498: EQUAL
84499: IFTRUE 84509
84501: LD_INT 37
84503: DOUBLE
84504: EQUAL
84505: IFTRUE 84509
84507: GO 84565
84509: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
84510: LD_ADDR_VAR 0 9
84514: PUSH
84515: LD_VAR 0 53
84519: PUSH
84520: LD_VAR 0 54
84524: PUSH
84525: LD_VAR 0 55
84529: PUSH
84530: LD_VAR 0 56
84534: PUSH
84535: LD_VAR 0 57
84539: PUSH
84540: LD_VAR 0 58
84544: PUSH
84545: EMPTY
84546: LIST
84547: LIST
84548: LIST
84549: LIST
84550: LIST
84551: LIST
84552: PUSH
84553: LD_VAR 0 4
84557: PUSH
84558: LD_INT 1
84560: PLUS
84561: ARRAY
84562: ST_TO_ADDR
84563: GO 84672
84565: LD_INT 31
84567: DOUBLE
84568: EQUAL
84569: IFTRUE 84615
84571: LD_INT 32
84573: DOUBLE
84574: EQUAL
84575: IFTRUE 84615
84577: LD_INT 33
84579: DOUBLE
84580: EQUAL
84581: IFTRUE 84615
84583: LD_INT 27
84585: DOUBLE
84586: EQUAL
84587: IFTRUE 84615
84589: LD_INT 26
84591: DOUBLE
84592: EQUAL
84593: IFTRUE 84615
84595: LD_INT 28
84597: DOUBLE
84598: EQUAL
84599: IFTRUE 84615
84601: LD_INT 29
84603: DOUBLE
84604: EQUAL
84605: IFTRUE 84615
84607: LD_INT 30
84609: DOUBLE
84610: EQUAL
84611: IFTRUE 84615
84613: GO 84671
84615: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
84616: LD_ADDR_VAR 0 9
84620: PUSH
84621: LD_VAR 0 59
84625: PUSH
84626: LD_VAR 0 60
84630: PUSH
84631: LD_VAR 0 61
84635: PUSH
84636: LD_VAR 0 62
84640: PUSH
84641: LD_VAR 0 63
84645: PUSH
84646: LD_VAR 0 64
84650: PUSH
84651: EMPTY
84652: LIST
84653: LIST
84654: LIST
84655: LIST
84656: LIST
84657: LIST
84658: PUSH
84659: LD_VAR 0 4
84663: PUSH
84664: LD_INT 1
84666: PLUS
84667: ARRAY
84668: ST_TO_ADDR
84669: GO 84672
84671: POP
// temp_list2 = [ ] ;
84672: LD_ADDR_VAR 0 10
84676: PUSH
84677: EMPTY
84678: ST_TO_ADDR
// for i in temp_list do
84679: LD_ADDR_VAR 0 8
84683: PUSH
84684: LD_VAR 0 9
84688: PUSH
84689: FOR_IN
84690: IFFALSE 84742
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
84692: LD_ADDR_VAR 0 10
84696: PUSH
84697: LD_VAR 0 10
84701: PUSH
84702: LD_VAR 0 8
84706: PUSH
84707: LD_INT 1
84709: ARRAY
84710: PUSH
84711: LD_VAR 0 2
84715: PLUS
84716: PUSH
84717: LD_VAR 0 8
84721: PUSH
84722: LD_INT 2
84724: ARRAY
84725: PUSH
84726: LD_VAR 0 3
84730: PLUS
84731: PUSH
84732: EMPTY
84733: LIST
84734: LIST
84735: PUSH
84736: EMPTY
84737: LIST
84738: ADD
84739: ST_TO_ADDR
84740: GO 84689
84742: POP
84743: POP
// result = temp_list2 ;
84744: LD_ADDR_VAR 0 7
84748: PUSH
84749: LD_VAR 0 10
84753: ST_TO_ADDR
// end ;
84754: LD_VAR 0 7
84758: RET
// export function EnemyInRange ( unit , dist ) ; begin
84759: LD_INT 0
84761: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
84762: LD_ADDR_VAR 0 3
84766: PUSH
84767: LD_VAR 0 1
84771: PPUSH
84772: CALL_OW 255
84776: PPUSH
84777: LD_VAR 0 1
84781: PPUSH
84782: CALL_OW 250
84786: PPUSH
84787: LD_VAR 0 1
84791: PPUSH
84792: CALL_OW 251
84796: PPUSH
84797: LD_VAR 0 2
84801: PPUSH
84802: CALL 58863 0 4
84806: PUSH
84807: LD_INT 4
84809: ARRAY
84810: ST_TO_ADDR
// end ;
84811: LD_VAR 0 3
84815: RET
// export function PlayerSeeMe ( unit ) ; begin
84816: LD_INT 0
84818: PPUSH
// result := See ( your_side , unit ) ;
84819: LD_ADDR_VAR 0 2
84823: PUSH
84824: LD_OWVAR 2
84828: PPUSH
84829: LD_VAR 0 1
84833: PPUSH
84834: CALL_OW 292
84838: ST_TO_ADDR
// end ;
84839: LD_VAR 0 2
84843: RET
// export function ReverseDir ( unit ) ; begin
84844: LD_INT 0
84846: PPUSH
// if not unit then
84847: LD_VAR 0 1
84851: NOT
84852: IFFALSE 84856
// exit ;
84854: GO 84879
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
84856: LD_ADDR_VAR 0 2
84860: PUSH
84861: LD_VAR 0 1
84865: PPUSH
84866: CALL_OW 254
84870: PUSH
84871: LD_INT 3
84873: PLUS
84874: PUSH
84875: LD_INT 6
84877: MOD
84878: ST_TO_ADDR
// end ;
84879: LD_VAR 0 2
84883: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
84884: LD_INT 0
84886: PPUSH
84887: PPUSH
84888: PPUSH
84889: PPUSH
84890: PPUSH
// if not hexes then
84891: LD_VAR 0 2
84895: NOT
84896: IFFALSE 84900
// exit ;
84898: GO 85048
// dist := 9999 ;
84900: LD_ADDR_VAR 0 5
84904: PUSH
84905: LD_INT 9999
84907: ST_TO_ADDR
// for i = 1 to hexes do
84908: LD_ADDR_VAR 0 4
84912: PUSH
84913: DOUBLE
84914: LD_INT 1
84916: DEC
84917: ST_TO_ADDR
84918: LD_VAR 0 2
84922: PUSH
84923: FOR_TO
84924: IFFALSE 85036
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
84926: LD_VAR 0 1
84930: PPUSH
84931: LD_VAR 0 2
84935: PUSH
84936: LD_VAR 0 4
84940: ARRAY
84941: PUSH
84942: LD_INT 1
84944: ARRAY
84945: PPUSH
84946: LD_VAR 0 2
84950: PUSH
84951: LD_VAR 0 4
84955: ARRAY
84956: PUSH
84957: LD_INT 2
84959: ARRAY
84960: PPUSH
84961: CALL_OW 297
84965: PUSH
84966: LD_VAR 0 5
84970: LESS
84971: IFFALSE 85034
// begin hex := hexes [ i ] ;
84973: LD_ADDR_VAR 0 7
84977: PUSH
84978: LD_VAR 0 2
84982: PUSH
84983: LD_VAR 0 4
84987: ARRAY
84988: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
84989: LD_ADDR_VAR 0 5
84993: PUSH
84994: LD_VAR 0 1
84998: PPUSH
84999: LD_VAR 0 2
85003: PUSH
85004: LD_VAR 0 4
85008: ARRAY
85009: PUSH
85010: LD_INT 1
85012: ARRAY
85013: PPUSH
85014: LD_VAR 0 2
85018: PUSH
85019: LD_VAR 0 4
85023: ARRAY
85024: PUSH
85025: LD_INT 2
85027: ARRAY
85028: PPUSH
85029: CALL_OW 297
85033: ST_TO_ADDR
// end ; end ;
85034: GO 84923
85036: POP
85037: POP
// result := hex ;
85038: LD_ADDR_VAR 0 3
85042: PUSH
85043: LD_VAR 0 7
85047: ST_TO_ADDR
// end ;
85048: LD_VAR 0 3
85052: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
85053: LD_INT 0
85055: PPUSH
85056: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
85057: LD_VAR 0 1
85061: NOT
85062: PUSH
85063: LD_VAR 0 1
85067: PUSH
85068: LD_INT 21
85070: PUSH
85071: LD_INT 2
85073: PUSH
85074: EMPTY
85075: LIST
85076: LIST
85077: PUSH
85078: LD_INT 23
85080: PUSH
85081: LD_INT 2
85083: PUSH
85084: EMPTY
85085: LIST
85086: LIST
85087: PUSH
85088: EMPTY
85089: LIST
85090: LIST
85091: PPUSH
85092: CALL_OW 69
85096: IN
85097: NOT
85098: OR
85099: IFFALSE 85103
// exit ;
85101: GO 85150
// for i = 1 to 3 do
85103: LD_ADDR_VAR 0 3
85107: PUSH
85108: DOUBLE
85109: LD_INT 1
85111: DEC
85112: ST_TO_ADDR
85113: LD_INT 3
85115: PUSH
85116: FOR_TO
85117: IFFALSE 85148
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
85119: LD_VAR 0 1
85123: PPUSH
85124: CALL_OW 250
85128: PPUSH
85129: LD_VAR 0 1
85133: PPUSH
85134: CALL_OW 251
85138: PPUSH
85139: LD_INT 1
85141: PPUSH
85142: CALL_OW 453
85146: GO 85116
85148: POP
85149: POP
// end ;
85150: LD_VAR 0 2
85154: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
85155: LD_INT 0
85157: PPUSH
85158: PPUSH
85159: PPUSH
85160: PPUSH
85161: PPUSH
85162: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
85163: LD_VAR 0 1
85167: NOT
85168: PUSH
85169: LD_VAR 0 2
85173: NOT
85174: OR
85175: PUSH
85176: LD_VAR 0 1
85180: PPUSH
85181: CALL_OW 314
85185: OR
85186: IFFALSE 85190
// exit ;
85188: GO 85631
// x := GetX ( enemy_unit ) ;
85190: LD_ADDR_VAR 0 7
85194: PUSH
85195: LD_VAR 0 2
85199: PPUSH
85200: CALL_OW 250
85204: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
85205: LD_ADDR_VAR 0 8
85209: PUSH
85210: LD_VAR 0 2
85214: PPUSH
85215: CALL_OW 251
85219: ST_TO_ADDR
// if not x or not y then
85220: LD_VAR 0 7
85224: NOT
85225: PUSH
85226: LD_VAR 0 8
85230: NOT
85231: OR
85232: IFFALSE 85236
// exit ;
85234: GO 85631
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
85236: LD_ADDR_VAR 0 6
85240: PUSH
85241: LD_VAR 0 7
85245: PPUSH
85246: LD_INT 0
85248: PPUSH
85249: LD_INT 4
85251: PPUSH
85252: CALL_OW 272
85256: PUSH
85257: LD_VAR 0 8
85261: PPUSH
85262: LD_INT 0
85264: PPUSH
85265: LD_INT 4
85267: PPUSH
85268: CALL_OW 273
85272: PUSH
85273: EMPTY
85274: LIST
85275: LIST
85276: PUSH
85277: LD_VAR 0 7
85281: PPUSH
85282: LD_INT 1
85284: PPUSH
85285: LD_INT 4
85287: PPUSH
85288: CALL_OW 272
85292: PUSH
85293: LD_VAR 0 8
85297: PPUSH
85298: LD_INT 1
85300: PPUSH
85301: LD_INT 4
85303: PPUSH
85304: CALL_OW 273
85308: PUSH
85309: EMPTY
85310: LIST
85311: LIST
85312: PUSH
85313: LD_VAR 0 7
85317: PPUSH
85318: LD_INT 2
85320: PPUSH
85321: LD_INT 4
85323: PPUSH
85324: CALL_OW 272
85328: PUSH
85329: LD_VAR 0 8
85333: PPUSH
85334: LD_INT 2
85336: PPUSH
85337: LD_INT 4
85339: PPUSH
85340: CALL_OW 273
85344: PUSH
85345: EMPTY
85346: LIST
85347: LIST
85348: PUSH
85349: LD_VAR 0 7
85353: PPUSH
85354: LD_INT 3
85356: PPUSH
85357: LD_INT 4
85359: PPUSH
85360: CALL_OW 272
85364: PUSH
85365: LD_VAR 0 8
85369: PPUSH
85370: LD_INT 3
85372: PPUSH
85373: LD_INT 4
85375: PPUSH
85376: CALL_OW 273
85380: PUSH
85381: EMPTY
85382: LIST
85383: LIST
85384: PUSH
85385: LD_VAR 0 7
85389: PPUSH
85390: LD_INT 4
85392: PPUSH
85393: LD_INT 4
85395: PPUSH
85396: CALL_OW 272
85400: PUSH
85401: LD_VAR 0 8
85405: PPUSH
85406: LD_INT 4
85408: PPUSH
85409: LD_INT 4
85411: PPUSH
85412: CALL_OW 273
85416: PUSH
85417: EMPTY
85418: LIST
85419: LIST
85420: PUSH
85421: LD_VAR 0 7
85425: PPUSH
85426: LD_INT 5
85428: PPUSH
85429: LD_INT 4
85431: PPUSH
85432: CALL_OW 272
85436: PUSH
85437: LD_VAR 0 8
85441: PPUSH
85442: LD_INT 5
85444: PPUSH
85445: LD_INT 4
85447: PPUSH
85448: CALL_OW 273
85452: PUSH
85453: EMPTY
85454: LIST
85455: LIST
85456: PUSH
85457: EMPTY
85458: LIST
85459: LIST
85460: LIST
85461: LIST
85462: LIST
85463: LIST
85464: ST_TO_ADDR
// for i = tmp downto 1 do
85465: LD_ADDR_VAR 0 4
85469: PUSH
85470: DOUBLE
85471: LD_VAR 0 6
85475: INC
85476: ST_TO_ADDR
85477: LD_INT 1
85479: PUSH
85480: FOR_DOWNTO
85481: IFFALSE 85582
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
85483: LD_VAR 0 6
85487: PUSH
85488: LD_VAR 0 4
85492: ARRAY
85493: PUSH
85494: LD_INT 1
85496: ARRAY
85497: PPUSH
85498: LD_VAR 0 6
85502: PUSH
85503: LD_VAR 0 4
85507: ARRAY
85508: PUSH
85509: LD_INT 2
85511: ARRAY
85512: PPUSH
85513: CALL_OW 488
85517: NOT
85518: PUSH
85519: LD_VAR 0 6
85523: PUSH
85524: LD_VAR 0 4
85528: ARRAY
85529: PUSH
85530: LD_INT 1
85532: ARRAY
85533: PPUSH
85534: LD_VAR 0 6
85538: PUSH
85539: LD_VAR 0 4
85543: ARRAY
85544: PUSH
85545: LD_INT 2
85547: ARRAY
85548: PPUSH
85549: CALL_OW 428
85553: PUSH
85554: LD_INT 0
85556: NONEQUAL
85557: OR
85558: IFFALSE 85580
// tmp := Delete ( tmp , i ) ;
85560: LD_ADDR_VAR 0 6
85564: PUSH
85565: LD_VAR 0 6
85569: PPUSH
85570: LD_VAR 0 4
85574: PPUSH
85575: CALL_OW 3
85579: ST_TO_ADDR
85580: GO 85480
85582: POP
85583: POP
// j := GetClosestHex ( unit , tmp ) ;
85584: LD_ADDR_VAR 0 5
85588: PUSH
85589: LD_VAR 0 1
85593: PPUSH
85594: LD_VAR 0 6
85598: PPUSH
85599: CALL 84884 0 2
85603: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
85604: LD_VAR 0 1
85608: PPUSH
85609: LD_VAR 0 5
85613: PUSH
85614: LD_INT 1
85616: ARRAY
85617: PPUSH
85618: LD_VAR 0 5
85622: PUSH
85623: LD_INT 2
85625: ARRAY
85626: PPUSH
85627: CALL_OW 111
// end ;
85631: LD_VAR 0 3
85635: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
85636: LD_INT 0
85638: PPUSH
85639: PPUSH
85640: PPUSH
// uc_side = 0 ;
85641: LD_ADDR_OWVAR 20
85645: PUSH
85646: LD_INT 0
85648: ST_TO_ADDR
// uc_nation = 0 ;
85649: LD_ADDR_OWVAR 21
85653: PUSH
85654: LD_INT 0
85656: ST_TO_ADDR
// InitHc ;
85657: CALL_OW 19
// InitVc ;
85661: CALL_OW 20
// if mastodonts then
85665: LD_VAR 0 6
85669: IFFALSE 85736
// for i = 1 to mastodonts do
85671: LD_ADDR_VAR 0 11
85675: PUSH
85676: DOUBLE
85677: LD_INT 1
85679: DEC
85680: ST_TO_ADDR
85681: LD_VAR 0 6
85685: PUSH
85686: FOR_TO
85687: IFFALSE 85734
// begin vc_chassis := 31 ;
85689: LD_ADDR_OWVAR 37
85693: PUSH
85694: LD_INT 31
85696: ST_TO_ADDR
// vc_control := control_rider ;
85697: LD_ADDR_OWVAR 38
85701: PUSH
85702: LD_INT 4
85704: ST_TO_ADDR
// animal := CreateVehicle ;
85705: LD_ADDR_VAR 0 12
85709: PUSH
85710: CALL_OW 45
85714: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85715: LD_VAR 0 12
85719: PPUSH
85720: LD_VAR 0 8
85724: PPUSH
85725: LD_INT 0
85727: PPUSH
85728: CALL 92514 0 3
// end ;
85732: GO 85686
85734: POP
85735: POP
// if horses then
85736: LD_VAR 0 5
85740: IFFALSE 85807
// for i = 1 to horses do
85742: LD_ADDR_VAR 0 11
85746: PUSH
85747: DOUBLE
85748: LD_INT 1
85750: DEC
85751: ST_TO_ADDR
85752: LD_VAR 0 5
85756: PUSH
85757: FOR_TO
85758: IFFALSE 85805
// begin hc_class := 21 ;
85760: LD_ADDR_OWVAR 28
85764: PUSH
85765: LD_INT 21
85767: ST_TO_ADDR
// hc_gallery :=  ;
85768: LD_ADDR_OWVAR 33
85772: PUSH
85773: LD_STRING 
85775: ST_TO_ADDR
// animal := CreateHuman ;
85776: LD_ADDR_VAR 0 12
85780: PUSH
85781: CALL_OW 44
85785: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85786: LD_VAR 0 12
85790: PPUSH
85791: LD_VAR 0 8
85795: PPUSH
85796: LD_INT 0
85798: PPUSH
85799: CALL 92514 0 3
// end ;
85803: GO 85757
85805: POP
85806: POP
// if birds then
85807: LD_VAR 0 1
85811: IFFALSE 85878
// for i = 1 to birds do
85813: LD_ADDR_VAR 0 11
85817: PUSH
85818: DOUBLE
85819: LD_INT 1
85821: DEC
85822: ST_TO_ADDR
85823: LD_VAR 0 1
85827: PUSH
85828: FOR_TO
85829: IFFALSE 85876
// begin hc_class = 18 ;
85831: LD_ADDR_OWVAR 28
85835: PUSH
85836: LD_INT 18
85838: ST_TO_ADDR
// hc_gallery =  ;
85839: LD_ADDR_OWVAR 33
85843: PUSH
85844: LD_STRING 
85846: ST_TO_ADDR
// animal := CreateHuman ;
85847: LD_ADDR_VAR 0 12
85851: PUSH
85852: CALL_OW 44
85856: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85857: LD_VAR 0 12
85861: PPUSH
85862: LD_VAR 0 8
85866: PPUSH
85867: LD_INT 0
85869: PPUSH
85870: CALL 92514 0 3
// end ;
85874: GO 85828
85876: POP
85877: POP
// if tigers then
85878: LD_VAR 0 2
85882: IFFALSE 85966
// for i = 1 to tigers do
85884: LD_ADDR_VAR 0 11
85888: PUSH
85889: DOUBLE
85890: LD_INT 1
85892: DEC
85893: ST_TO_ADDR
85894: LD_VAR 0 2
85898: PUSH
85899: FOR_TO
85900: IFFALSE 85964
// begin hc_class = class_tiger ;
85902: LD_ADDR_OWVAR 28
85906: PUSH
85907: LD_INT 14
85909: ST_TO_ADDR
// hc_gallery =  ;
85910: LD_ADDR_OWVAR 33
85914: PUSH
85915: LD_STRING 
85917: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
85918: LD_ADDR_OWVAR 35
85922: PUSH
85923: LD_INT 7
85925: NEG
85926: PPUSH
85927: LD_INT 7
85929: PPUSH
85930: CALL_OW 12
85934: ST_TO_ADDR
// animal := CreateHuman ;
85935: LD_ADDR_VAR 0 12
85939: PUSH
85940: CALL_OW 44
85944: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85945: LD_VAR 0 12
85949: PPUSH
85950: LD_VAR 0 8
85954: PPUSH
85955: LD_INT 0
85957: PPUSH
85958: CALL 92514 0 3
// end ;
85962: GO 85899
85964: POP
85965: POP
// if apemans then
85966: LD_VAR 0 3
85970: IFFALSE 86093
// for i = 1 to apemans do
85972: LD_ADDR_VAR 0 11
85976: PUSH
85977: DOUBLE
85978: LD_INT 1
85980: DEC
85981: ST_TO_ADDR
85982: LD_VAR 0 3
85986: PUSH
85987: FOR_TO
85988: IFFALSE 86091
// begin hc_class = class_apeman ;
85990: LD_ADDR_OWVAR 28
85994: PUSH
85995: LD_INT 12
85997: ST_TO_ADDR
// hc_gallery =  ;
85998: LD_ADDR_OWVAR 33
86002: PUSH
86003: LD_STRING 
86005: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
86006: LD_ADDR_OWVAR 35
86010: PUSH
86011: LD_INT 5
86013: NEG
86014: PPUSH
86015: LD_INT 5
86017: PPUSH
86018: CALL_OW 12
86022: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
86023: LD_ADDR_OWVAR 31
86027: PUSH
86028: LD_INT 1
86030: PPUSH
86031: LD_INT 3
86033: PPUSH
86034: CALL_OW 12
86038: PUSH
86039: LD_INT 1
86041: PPUSH
86042: LD_INT 3
86044: PPUSH
86045: CALL_OW 12
86049: PUSH
86050: LD_INT 0
86052: PUSH
86053: LD_INT 0
86055: PUSH
86056: EMPTY
86057: LIST
86058: LIST
86059: LIST
86060: LIST
86061: ST_TO_ADDR
// animal := CreateHuman ;
86062: LD_ADDR_VAR 0 12
86066: PUSH
86067: CALL_OW 44
86071: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86072: LD_VAR 0 12
86076: PPUSH
86077: LD_VAR 0 8
86081: PPUSH
86082: LD_INT 0
86084: PPUSH
86085: CALL 92514 0 3
// end ;
86089: GO 85987
86091: POP
86092: POP
// if enchidnas then
86093: LD_VAR 0 4
86097: IFFALSE 86164
// for i = 1 to enchidnas do
86099: LD_ADDR_VAR 0 11
86103: PUSH
86104: DOUBLE
86105: LD_INT 1
86107: DEC
86108: ST_TO_ADDR
86109: LD_VAR 0 4
86113: PUSH
86114: FOR_TO
86115: IFFALSE 86162
// begin hc_class = 13 ;
86117: LD_ADDR_OWVAR 28
86121: PUSH
86122: LD_INT 13
86124: ST_TO_ADDR
// hc_gallery =  ;
86125: LD_ADDR_OWVAR 33
86129: PUSH
86130: LD_STRING 
86132: ST_TO_ADDR
// animal := CreateHuman ;
86133: LD_ADDR_VAR 0 12
86137: PUSH
86138: CALL_OW 44
86142: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86143: LD_VAR 0 12
86147: PPUSH
86148: LD_VAR 0 8
86152: PPUSH
86153: LD_INT 0
86155: PPUSH
86156: CALL 92514 0 3
// end ;
86160: GO 86114
86162: POP
86163: POP
// if fishes then
86164: LD_VAR 0 7
86168: IFFALSE 86235
// for i = 1 to fishes do
86170: LD_ADDR_VAR 0 11
86174: PUSH
86175: DOUBLE
86176: LD_INT 1
86178: DEC
86179: ST_TO_ADDR
86180: LD_VAR 0 7
86184: PUSH
86185: FOR_TO
86186: IFFALSE 86233
// begin hc_class = 20 ;
86188: LD_ADDR_OWVAR 28
86192: PUSH
86193: LD_INT 20
86195: ST_TO_ADDR
// hc_gallery =  ;
86196: LD_ADDR_OWVAR 33
86200: PUSH
86201: LD_STRING 
86203: ST_TO_ADDR
// animal := CreateHuman ;
86204: LD_ADDR_VAR 0 12
86208: PUSH
86209: CALL_OW 44
86213: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
86214: LD_VAR 0 12
86218: PPUSH
86219: LD_VAR 0 9
86223: PPUSH
86224: LD_INT 0
86226: PPUSH
86227: CALL 92514 0 3
// end ;
86231: GO 86185
86233: POP
86234: POP
// end ;
86235: LD_VAR 0 10
86239: RET
// export function WantHeal ( sci , unit ) ; begin
86240: LD_INT 0
86242: PPUSH
// if GetTaskList ( sci ) > 0 then
86243: LD_VAR 0 1
86247: PPUSH
86248: CALL_OW 437
86252: PUSH
86253: LD_INT 0
86255: GREATER
86256: IFFALSE 86326
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
86258: LD_VAR 0 1
86262: PPUSH
86263: CALL_OW 437
86267: PUSH
86268: LD_INT 1
86270: ARRAY
86271: PUSH
86272: LD_INT 1
86274: ARRAY
86275: PUSH
86276: LD_STRING l
86278: EQUAL
86279: PUSH
86280: LD_VAR 0 1
86284: PPUSH
86285: CALL_OW 437
86289: PUSH
86290: LD_INT 1
86292: ARRAY
86293: PUSH
86294: LD_INT 4
86296: ARRAY
86297: PUSH
86298: LD_VAR 0 2
86302: EQUAL
86303: AND
86304: IFFALSE 86316
// result := true else
86306: LD_ADDR_VAR 0 3
86310: PUSH
86311: LD_INT 1
86313: ST_TO_ADDR
86314: GO 86324
// result := false ;
86316: LD_ADDR_VAR 0 3
86320: PUSH
86321: LD_INT 0
86323: ST_TO_ADDR
// end else
86324: GO 86334
// result := false ;
86326: LD_ADDR_VAR 0 3
86330: PUSH
86331: LD_INT 0
86333: ST_TO_ADDR
// end ;
86334: LD_VAR 0 3
86338: RET
// export function HealTarget ( sci ) ; begin
86339: LD_INT 0
86341: PPUSH
// if not sci then
86342: LD_VAR 0 1
86346: NOT
86347: IFFALSE 86351
// exit ;
86349: GO 86416
// result := 0 ;
86351: LD_ADDR_VAR 0 2
86355: PUSH
86356: LD_INT 0
86358: ST_TO_ADDR
// if GetTaskList ( sci ) then
86359: LD_VAR 0 1
86363: PPUSH
86364: CALL_OW 437
86368: IFFALSE 86416
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
86370: LD_VAR 0 1
86374: PPUSH
86375: CALL_OW 437
86379: PUSH
86380: LD_INT 1
86382: ARRAY
86383: PUSH
86384: LD_INT 1
86386: ARRAY
86387: PUSH
86388: LD_STRING l
86390: EQUAL
86391: IFFALSE 86416
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
86393: LD_ADDR_VAR 0 2
86397: PUSH
86398: LD_VAR 0 1
86402: PPUSH
86403: CALL_OW 437
86407: PUSH
86408: LD_INT 1
86410: ARRAY
86411: PUSH
86412: LD_INT 4
86414: ARRAY
86415: ST_TO_ADDR
// end ;
86416: LD_VAR 0 2
86420: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
86421: LD_INT 0
86423: PPUSH
86424: PPUSH
86425: PPUSH
86426: PPUSH
86427: PPUSH
86428: PPUSH
86429: PPUSH
86430: PPUSH
86431: PPUSH
86432: PPUSH
86433: PPUSH
86434: PPUSH
86435: PPUSH
86436: PPUSH
86437: PPUSH
86438: PPUSH
86439: PPUSH
86440: PPUSH
86441: PPUSH
86442: PPUSH
86443: PPUSH
86444: PPUSH
86445: PPUSH
86446: PPUSH
86447: PPUSH
86448: PPUSH
86449: PPUSH
86450: PPUSH
86451: PPUSH
86452: PPUSH
86453: PPUSH
86454: PPUSH
86455: PPUSH
86456: PPUSH
// if not list then
86457: LD_VAR 0 1
86461: NOT
86462: IFFALSE 86466
// exit ;
86464: GO 91125
// base := list [ 1 ] ;
86466: LD_ADDR_VAR 0 3
86470: PUSH
86471: LD_VAR 0 1
86475: PUSH
86476: LD_INT 1
86478: ARRAY
86479: ST_TO_ADDR
// group := list [ 2 ] ;
86480: LD_ADDR_VAR 0 4
86484: PUSH
86485: LD_VAR 0 1
86489: PUSH
86490: LD_INT 2
86492: ARRAY
86493: ST_TO_ADDR
// path := list [ 3 ] ;
86494: LD_ADDR_VAR 0 5
86498: PUSH
86499: LD_VAR 0 1
86503: PUSH
86504: LD_INT 3
86506: ARRAY
86507: ST_TO_ADDR
// flags := list [ 4 ] ;
86508: LD_ADDR_VAR 0 6
86512: PUSH
86513: LD_VAR 0 1
86517: PUSH
86518: LD_INT 4
86520: ARRAY
86521: ST_TO_ADDR
// mined := [ ] ;
86522: LD_ADDR_VAR 0 27
86526: PUSH
86527: EMPTY
86528: ST_TO_ADDR
// bombed := [ ] ;
86529: LD_ADDR_VAR 0 28
86533: PUSH
86534: EMPTY
86535: ST_TO_ADDR
// healers := [ ] ;
86536: LD_ADDR_VAR 0 31
86540: PUSH
86541: EMPTY
86542: ST_TO_ADDR
// to_heal := [ ] ;
86543: LD_ADDR_VAR 0 30
86547: PUSH
86548: EMPTY
86549: ST_TO_ADDR
// repairs := [ ] ;
86550: LD_ADDR_VAR 0 33
86554: PUSH
86555: EMPTY
86556: ST_TO_ADDR
// to_repair := [ ] ;
86557: LD_ADDR_VAR 0 32
86561: PUSH
86562: EMPTY
86563: ST_TO_ADDR
// if not group or not path then
86564: LD_VAR 0 4
86568: NOT
86569: PUSH
86570: LD_VAR 0 5
86574: NOT
86575: OR
86576: IFFALSE 86580
// exit ;
86578: GO 91125
// side := GetSide ( group [ 1 ] ) ;
86580: LD_ADDR_VAR 0 35
86584: PUSH
86585: LD_VAR 0 4
86589: PUSH
86590: LD_INT 1
86592: ARRAY
86593: PPUSH
86594: CALL_OW 255
86598: ST_TO_ADDR
// if flags then
86599: LD_VAR 0 6
86603: IFFALSE 86747
// begin f_ignore_area := flags [ 1 ] ;
86605: LD_ADDR_VAR 0 17
86609: PUSH
86610: LD_VAR 0 6
86614: PUSH
86615: LD_INT 1
86617: ARRAY
86618: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
86619: LD_ADDR_VAR 0 18
86623: PUSH
86624: LD_VAR 0 6
86628: PUSH
86629: LD_INT 2
86631: ARRAY
86632: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
86633: LD_ADDR_VAR 0 19
86637: PUSH
86638: LD_VAR 0 6
86642: PUSH
86643: LD_INT 3
86645: ARRAY
86646: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
86647: LD_ADDR_VAR 0 20
86651: PUSH
86652: LD_VAR 0 6
86656: PUSH
86657: LD_INT 4
86659: ARRAY
86660: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
86661: LD_ADDR_VAR 0 21
86665: PUSH
86666: LD_VAR 0 6
86670: PUSH
86671: LD_INT 5
86673: ARRAY
86674: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
86675: LD_ADDR_VAR 0 22
86679: PUSH
86680: LD_VAR 0 6
86684: PUSH
86685: LD_INT 6
86687: ARRAY
86688: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
86689: LD_ADDR_VAR 0 23
86693: PUSH
86694: LD_VAR 0 6
86698: PUSH
86699: LD_INT 7
86701: ARRAY
86702: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
86703: LD_ADDR_VAR 0 24
86707: PUSH
86708: LD_VAR 0 6
86712: PUSH
86713: LD_INT 8
86715: ARRAY
86716: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
86717: LD_ADDR_VAR 0 25
86721: PUSH
86722: LD_VAR 0 6
86726: PUSH
86727: LD_INT 9
86729: ARRAY
86730: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
86731: LD_ADDR_VAR 0 26
86735: PUSH
86736: LD_VAR 0 6
86740: PUSH
86741: LD_INT 10
86743: ARRAY
86744: ST_TO_ADDR
// end else
86745: GO 86827
// begin f_ignore_area := false ;
86747: LD_ADDR_VAR 0 17
86751: PUSH
86752: LD_INT 0
86754: ST_TO_ADDR
// f_capture := false ;
86755: LD_ADDR_VAR 0 18
86759: PUSH
86760: LD_INT 0
86762: ST_TO_ADDR
// f_ignore_civ := false ;
86763: LD_ADDR_VAR 0 19
86767: PUSH
86768: LD_INT 0
86770: ST_TO_ADDR
// f_murder := false ;
86771: LD_ADDR_VAR 0 20
86775: PUSH
86776: LD_INT 0
86778: ST_TO_ADDR
// f_mines := false ;
86779: LD_ADDR_VAR 0 21
86783: PUSH
86784: LD_INT 0
86786: ST_TO_ADDR
// f_repair := false ;
86787: LD_ADDR_VAR 0 22
86791: PUSH
86792: LD_INT 0
86794: ST_TO_ADDR
// f_heal := false ;
86795: LD_ADDR_VAR 0 23
86799: PUSH
86800: LD_INT 0
86802: ST_TO_ADDR
// f_spacetime := false ;
86803: LD_ADDR_VAR 0 24
86807: PUSH
86808: LD_INT 0
86810: ST_TO_ADDR
// f_attack_depot := false ;
86811: LD_ADDR_VAR 0 25
86815: PUSH
86816: LD_INT 0
86818: ST_TO_ADDR
// f_crawl := false ;
86819: LD_ADDR_VAR 0 26
86823: PUSH
86824: LD_INT 0
86826: ST_TO_ADDR
// end ; if f_heal then
86827: LD_VAR 0 23
86831: IFFALSE 86858
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
86833: LD_ADDR_VAR 0 31
86837: PUSH
86838: LD_VAR 0 4
86842: PPUSH
86843: LD_INT 25
86845: PUSH
86846: LD_INT 4
86848: PUSH
86849: EMPTY
86850: LIST
86851: LIST
86852: PPUSH
86853: CALL_OW 72
86857: ST_TO_ADDR
// if f_repair then
86858: LD_VAR 0 22
86862: IFFALSE 86889
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
86864: LD_ADDR_VAR 0 33
86868: PUSH
86869: LD_VAR 0 4
86873: PPUSH
86874: LD_INT 25
86876: PUSH
86877: LD_INT 3
86879: PUSH
86880: EMPTY
86881: LIST
86882: LIST
86883: PPUSH
86884: CALL_OW 72
86888: ST_TO_ADDR
// units_path := [ ] ;
86889: LD_ADDR_VAR 0 16
86893: PUSH
86894: EMPTY
86895: ST_TO_ADDR
// for i = 1 to group do
86896: LD_ADDR_VAR 0 7
86900: PUSH
86901: DOUBLE
86902: LD_INT 1
86904: DEC
86905: ST_TO_ADDR
86906: LD_VAR 0 4
86910: PUSH
86911: FOR_TO
86912: IFFALSE 86941
// units_path := Replace ( units_path , i , path ) ;
86914: LD_ADDR_VAR 0 16
86918: PUSH
86919: LD_VAR 0 16
86923: PPUSH
86924: LD_VAR 0 7
86928: PPUSH
86929: LD_VAR 0 5
86933: PPUSH
86934: CALL_OW 1
86938: ST_TO_ADDR
86939: GO 86911
86941: POP
86942: POP
// repeat for i = group downto 1 do
86943: LD_ADDR_VAR 0 7
86947: PUSH
86948: DOUBLE
86949: LD_VAR 0 4
86953: INC
86954: ST_TO_ADDR
86955: LD_INT 1
86957: PUSH
86958: FOR_DOWNTO
86959: IFFALSE 91081
// begin wait ( 5 ) ;
86961: LD_INT 5
86963: PPUSH
86964: CALL_OW 67
// tmp := [ ] ;
86968: LD_ADDR_VAR 0 14
86972: PUSH
86973: EMPTY
86974: ST_TO_ADDR
// attacking := false ;
86975: LD_ADDR_VAR 0 29
86979: PUSH
86980: LD_INT 0
86982: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
86983: LD_VAR 0 4
86987: PUSH
86988: LD_VAR 0 7
86992: ARRAY
86993: PPUSH
86994: CALL_OW 301
86998: PUSH
86999: LD_VAR 0 4
87003: PUSH
87004: LD_VAR 0 7
87008: ARRAY
87009: NOT
87010: OR
87011: IFFALSE 87120
// begin if GetType ( group [ i ] ) = unit_human then
87013: LD_VAR 0 4
87017: PUSH
87018: LD_VAR 0 7
87022: ARRAY
87023: PPUSH
87024: CALL_OW 247
87028: PUSH
87029: LD_INT 1
87031: EQUAL
87032: IFFALSE 87078
// begin to_heal := to_heal diff group [ i ] ;
87034: LD_ADDR_VAR 0 30
87038: PUSH
87039: LD_VAR 0 30
87043: PUSH
87044: LD_VAR 0 4
87048: PUSH
87049: LD_VAR 0 7
87053: ARRAY
87054: DIFF
87055: ST_TO_ADDR
// healers := healers diff group [ i ] ;
87056: LD_ADDR_VAR 0 31
87060: PUSH
87061: LD_VAR 0 31
87065: PUSH
87066: LD_VAR 0 4
87070: PUSH
87071: LD_VAR 0 7
87075: ARRAY
87076: DIFF
87077: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
87078: LD_ADDR_VAR 0 4
87082: PUSH
87083: LD_VAR 0 4
87087: PPUSH
87088: LD_VAR 0 7
87092: PPUSH
87093: CALL_OW 3
87097: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
87098: LD_ADDR_VAR 0 16
87102: PUSH
87103: LD_VAR 0 16
87107: PPUSH
87108: LD_VAR 0 7
87112: PPUSH
87113: CALL_OW 3
87117: ST_TO_ADDR
// continue ;
87118: GO 86958
// end ; if f_repair then
87120: LD_VAR 0 22
87124: IFFALSE 87613
// begin if GetType ( group [ i ] ) = unit_vehicle then
87126: LD_VAR 0 4
87130: PUSH
87131: LD_VAR 0 7
87135: ARRAY
87136: PPUSH
87137: CALL_OW 247
87141: PUSH
87142: LD_INT 2
87144: EQUAL
87145: IFFALSE 87335
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
87147: LD_VAR 0 4
87151: PUSH
87152: LD_VAR 0 7
87156: ARRAY
87157: PPUSH
87158: CALL_OW 256
87162: PUSH
87163: LD_INT 700
87165: LESS
87166: PUSH
87167: LD_VAR 0 4
87171: PUSH
87172: LD_VAR 0 7
87176: ARRAY
87177: PUSH
87178: LD_VAR 0 32
87182: IN
87183: NOT
87184: AND
87185: IFFALSE 87209
// to_repair := to_repair union group [ i ] ;
87187: LD_ADDR_VAR 0 32
87191: PUSH
87192: LD_VAR 0 32
87196: PUSH
87197: LD_VAR 0 4
87201: PUSH
87202: LD_VAR 0 7
87206: ARRAY
87207: UNION
87208: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
87209: LD_VAR 0 4
87213: PUSH
87214: LD_VAR 0 7
87218: ARRAY
87219: PPUSH
87220: CALL_OW 256
87224: PUSH
87225: LD_INT 1000
87227: EQUAL
87228: PUSH
87229: LD_VAR 0 4
87233: PUSH
87234: LD_VAR 0 7
87238: ARRAY
87239: PUSH
87240: LD_VAR 0 32
87244: IN
87245: AND
87246: IFFALSE 87270
// to_repair := to_repair diff group [ i ] ;
87248: LD_ADDR_VAR 0 32
87252: PUSH
87253: LD_VAR 0 32
87257: PUSH
87258: LD_VAR 0 4
87262: PUSH
87263: LD_VAR 0 7
87267: ARRAY
87268: DIFF
87269: ST_TO_ADDR
// if group [ i ] in to_repair then
87270: LD_VAR 0 4
87274: PUSH
87275: LD_VAR 0 7
87279: ARRAY
87280: PUSH
87281: LD_VAR 0 32
87285: IN
87286: IFFALSE 87333
// begin if not IsInArea ( group [ i ] , f_repair ) then
87288: LD_VAR 0 4
87292: PUSH
87293: LD_VAR 0 7
87297: ARRAY
87298: PPUSH
87299: LD_VAR 0 22
87303: PPUSH
87304: CALL_OW 308
87308: NOT
87309: IFFALSE 87331
// ComMoveToArea ( group [ i ] , f_repair ) ;
87311: LD_VAR 0 4
87315: PUSH
87316: LD_VAR 0 7
87320: ARRAY
87321: PPUSH
87322: LD_VAR 0 22
87326: PPUSH
87327: CALL_OW 113
// continue ;
87331: GO 86958
// end ; end else
87333: GO 87613
// if group [ i ] in repairs then
87335: LD_VAR 0 4
87339: PUSH
87340: LD_VAR 0 7
87344: ARRAY
87345: PUSH
87346: LD_VAR 0 33
87350: IN
87351: IFFALSE 87613
// begin if IsInUnit ( group [ i ] ) then
87353: LD_VAR 0 4
87357: PUSH
87358: LD_VAR 0 7
87362: ARRAY
87363: PPUSH
87364: CALL_OW 310
87368: IFFALSE 87436
// begin z := IsInUnit ( group [ i ] ) ;
87370: LD_ADDR_VAR 0 13
87374: PUSH
87375: LD_VAR 0 4
87379: PUSH
87380: LD_VAR 0 7
87384: ARRAY
87385: PPUSH
87386: CALL_OW 310
87390: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
87391: LD_VAR 0 13
87395: PUSH
87396: LD_VAR 0 32
87400: IN
87401: PUSH
87402: LD_VAR 0 13
87406: PPUSH
87407: LD_VAR 0 22
87411: PPUSH
87412: CALL_OW 308
87416: AND
87417: IFFALSE 87434
// ComExitVehicle ( group [ i ] ) ;
87419: LD_VAR 0 4
87423: PUSH
87424: LD_VAR 0 7
87428: ARRAY
87429: PPUSH
87430: CALL_OW 121
// end else
87434: GO 87613
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
87436: LD_ADDR_VAR 0 13
87440: PUSH
87441: LD_VAR 0 4
87445: PPUSH
87446: LD_INT 95
87448: PUSH
87449: LD_VAR 0 22
87453: PUSH
87454: EMPTY
87455: LIST
87456: LIST
87457: PUSH
87458: LD_INT 58
87460: PUSH
87461: EMPTY
87462: LIST
87463: PUSH
87464: EMPTY
87465: LIST
87466: LIST
87467: PPUSH
87468: CALL_OW 72
87472: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
87473: LD_VAR 0 4
87477: PUSH
87478: LD_VAR 0 7
87482: ARRAY
87483: PPUSH
87484: CALL_OW 314
87488: NOT
87489: IFFALSE 87611
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
87491: LD_ADDR_VAR 0 10
87495: PUSH
87496: LD_VAR 0 13
87500: PPUSH
87501: LD_VAR 0 4
87505: PUSH
87506: LD_VAR 0 7
87510: ARRAY
87511: PPUSH
87512: CALL_OW 74
87516: ST_TO_ADDR
// if not x then
87517: LD_VAR 0 10
87521: NOT
87522: IFFALSE 87526
// continue ;
87524: GO 86958
// if GetLives ( x ) < 1000 then
87526: LD_VAR 0 10
87530: PPUSH
87531: CALL_OW 256
87535: PUSH
87536: LD_INT 1000
87538: LESS
87539: IFFALSE 87563
// ComRepairVehicle ( group [ i ] , x ) else
87541: LD_VAR 0 4
87545: PUSH
87546: LD_VAR 0 7
87550: ARRAY
87551: PPUSH
87552: LD_VAR 0 10
87556: PPUSH
87557: CALL_OW 129
87561: GO 87611
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
87563: LD_VAR 0 23
87567: PUSH
87568: LD_VAR 0 4
87572: PUSH
87573: LD_VAR 0 7
87577: ARRAY
87578: PPUSH
87579: CALL_OW 256
87583: PUSH
87584: LD_INT 1000
87586: LESS
87587: AND
87588: NOT
87589: IFFALSE 87611
// ComEnterUnit ( group [ i ] , x ) ;
87591: LD_VAR 0 4
87595: PUSH
87596: LD_VAR 0 7
87600: ARRAY
87601: PPUSH
87602: LD_VAR 0 10
87606: PPUSH
87607: CALL_OW 120
// end ; continue ;
87611: GO 86958
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
87613: LD_VAR 0 23
87617: PUSH
87618: LD_VAR 0 4
87622: PUSH
87623: LD_VAR 0 7
87627: ARRAY
87628: PPUSH
87629: CALL_OW 247
87633: PUSH
87634: LD_INT 1
87636: EQUAL
87637: AND
87638: IFFALSE 88116
// begin if group [ i ] in healers then
87640: LD_VAR 0 4
87644: PUSH
87645: LD_VAR 0 7
87649: ARRAY
87650: PUSH
87651: LD_VAR 0 31
87655: IN
87656: IFFALSE 87929
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
87658: LD_VAR 0 4
87662: PUSH
87663: LD_VAR 0 7
87667: ARRAY
87668: PPUSH
87669: LD_VAR 0 23
87673: PPUSH
87674: CALL_OW 308
87678: NOT
87679: PUSH
87680: LD_VAR 0 4
87684: PUSH
87685: LD_VAR 0 7
87689: ARRAY
87690: PPUSH
87691: CALL_OW 314
87695: NOT
87696: AND
87697: IFFALSE 87721
// ComMoveToArea ( group [ i ] , f_heal ) else
87699: LD_VAR 0 4
87703: PUSH
87704: LD_VAR 0 7
87708: ARRAY
87709: PPUSH
87710: LD_VAR 0 23
87714: PPUSH
87715: CALL_OW 113
87719: GO 87927
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
87721: LD_VAR 0 4
87725: PUSH
87726: LD_VAR 0 7
87730: ARRAY
87731: PPUSH
87732: CALL 86339 0 1
87736: PPUSH
87737: CALL_OW 256
87741: PUSH
87742: LD_INT 1000
87744: EQUAL
87745: IFFALSE 87764
// ComStop ( group [ i ] ) else
87747: LD_VAR 0 4
87751: PUSH
87752: LD_VAR 0 7
87756: ARRAY
87757: PPUSH
87758: CALL_OW 141
87762: GO 87927
// if not HasTask ( group [ i ] ) and to_heal then
87764: LD_VAR 0 4
87768: PUSH
87769: LD_VAR 0 7
87773: ARRAY
87774: PPUSH
87775: CALL_OW 314
87779: NOT
87780: PUSH
87781: LD_VAR 0 30
87785: AND
87786: IFFALSE 87927
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
87788: LD_ADDR_VAR 0 13
87792: PUSH
87793: LD_VAR 0 30
87797: PPUSH
87798: LD_INT 3
87800: PUSH
87801: LD_INT 54
87803: PUSH
87804: EMPTY
87805: LIST
87806: PUSH
87807: EMPTY
87808: LIST
87809: LIST
87810: PPUSH
87811: CALL_OW 72
87815: PPUSH
87816: LD_VAR 0 4
87820: PUSH
87821: LD_VAR 0 7
87825: ARRAY
87826: PPUSH
87827: CALL_OW 74
87831: ST_TO_ADDR
// if z then
87832: LD_VAR 0 13
87836: IFFALSE 87927
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
87838: LD_INT 91
87840: PUSH
87841: LD_VAR 0 13
87845: PUSH
87846: LD_INT 10
87848: PUSH
87849: EMPTY
87850: LIST
87851: LIST
87852: LIST
87853: PUSH
87854: LD_INT 81
87856: PUSH
87857: LD_VAR 0 13
87861: PPUSH
87862: CALL_OW 255
87866: PUSH
87867: EMPTY
87868: LIST
87869: LIST
87870: PUSH
87871: EMPTY
87872: LIST
87873: LIST
87874: PPUSH
87875: CALL_OW 69
87879: PUSH
87880: LD_INT 0
87882: EQUAL
87883: IFFALSE 87907
// ComHeal ( group [ i ] , z ) else
87885: LD_VAR 0 4
87889: PUSH
87890: LD_VAR 0 7
87894: ARRAY
87895: PPUSH
87896: LD_VAR 0 13
87900: PPUSH
87901: CALL_OW 128
87905: GO 87927
// ComMoveToArea ( group [ i ] , f_heal ) ;
87907: LD_VAR 0 4
87911: PUSH
87912: LD_VAR 0 7
87916: ARRAY
87917: PPUSH
87918: LD_VAR 0 23
87922: PPUSH
87923: CALL_OW 113
// end ; continue ;
87927: GO 86958
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
87929: LD_VAR 0 4
87933: PUSH
87934: LD_VAR 0 7
87938: ARRAY
87939: PPUSH
87940: CALL_OW 256
87944: PUSH
87945: LD_INT 700
87947: LESS
87948: PUSH
87949: LD_VAR 0 4
87953: PUSH
87954: LD_VAR 0 7
87958: ARRAY
87959: PUSH
87960: LD_VAR 0 30
87964: IN
87965: NOT
87966: AND
87967: IFFALSE 87991
// to_heal := to_heal union group [ i ] ;
87969: LD_ADDR_VAR 0 30
87973: PUSH
87974: LD_VAR 0 30
87978: PUSH
87979: LD_VAR 0 4
87983: PUSH
87984: LD_VAR 0 7
87988: ARRAY
87989: UNION
87990: ST_TO_ADDR
// if group [ i ] in to_heal then
87991: LD_VAR 0 4
87995: PUSH
87996: LD_VAR 0 7
88000: ARRAY
88001: PUSH
88002: LD_VAR 0 30
88006: IN
88007: IFFALSE 88116
// begin if GetLives ( group [ i ] ) = 1000 then
88009: LD_VAR 0 4
88013: PUSH
88014: LD_VAR 0 7
88018: ARRAY
88019: PPUSH
88020: CALL_OW 256
88024: PUSH
88025: LD_INT 1000
88027: EQUAL
88028: IFFALSE 88054
// to_heal := to_heal diff group [ i ] else
88030: LD_ADDR_VAR 0 30
88034: PUSH
88035: LD_VAR 0 30
88039: PUSH
88040: LD_VAR 0 4
88044: PUSH
88045: LD_VAR 0 7
88049: ARRAY
88050: DIFF
88051: ST_TO_ADDR
88052: GO 88116
// begin if not IsInArea ( group [ i ] , to_heal ) then
88054: LD_VAR 0 4
88058: PUSH
88059: LD_VAR 0 7
88063: ARRAY
88064: PPUSH
88065: LD_VAR 0 30
88069: PPUSH
88070: CALL_OW 308
88074: NOT
88075: IFFALSE 88099
// ComMoveToArea ( group [ i ] , f_heal ) else
88077: LD_VAR 0 4
88081: PUSH
88082: LD_VAR 0 7
88086: ARRAY
88087: PPUSH
88088: LD_VAR 0 23
88092: PPUSH
88093: CALL_OW 113
88097: GO 88114
// ComHold ( group [ i ] ) ;
88099: LD_VAR 0 4
88103: PUSH
88104: LD_VAR 0 7
88108: ARRAY
88109: PPUSH
88110: CALL_OW 140
// continue ;
88114: GO 86958
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
88116: LD_VAR 0 4
88120: PUSH
88121: LD_VAR 0 7
88125: ARRAY
88126: PPUSH
88127: LD_INT 10
88129: PPUSH
88130: CALL 84759 0 2
88134: NOT
88135: PUSH
88136: LD_VAR 0 16
88140: PUSH
88141: LD_VAR 0 7
88145: ARRAY
88146: PUSH
88147: EMPTY
88148: EQUAL
88149: NOT
88150: AND
88151: IFFALSE 88417
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
88153: LD_VAR 0 4
88157: PUSH
88158: LD_VAR 0 7
88162: ARRAY
88163: PPUSH
88164: CALL_OW 262
88168: PUSH
88169: LD_INT 1
88171: PUSH
88172: LD_INT 2
88174: PUSH
88175: EMPTY
88176: LIST
88177: LIST
88178: IN
88179: IFFALSE 88220
// if GetFuel ( group [ i ] ) < 10 then
88181: LD_VAR 0 4
88185: PUSH
88186: LD_VAR 0 7
88190: ARRAY
88191: PPUSH
88192: CALL_OW 261
88196: PUSH
88197: LD_INT 10
88199: LESS
88200: IFFALSE 88220
// SetFuel ( group [ i ] , 12 ) ;
88202: LD_VAR 0 4
88206: PUSH
88207: LD_VAR 0 7
88211: ARRAY
88212: PPUSH
88213: LD_INT 12
88215: PPUSH
88216: CALL_OW 240
// if units_path [ i ] then
88220: LD_VAR 0 16
88224: PUSH
88225: LD_VAR 0 7
88229: ARRAY
88230: IFFALSE 88415
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
88232: LD_VAR 0 4
88236: PUSH
88237: LD_VAR 0 7
88241: ARRAY
88242: PPUSH
88243: LD_VAR 0 16
88247: PUSH
88248: LD_VAR 0 7
88252: ARRAY
88253: PUSH
88254: LD_INT 1
88256: ARRAY
88257: PUSH
88258: LD_INT 1
88260: ARRAY
88261: PPUSH
88262: LD_VAR 0 16
88266: PUSH
88267: LD_VAR 0 7
88271: ARRAY
88272: PUSH
88273: LD_INT 1
88275: ARRAY
88276: PUSH
88277: LD_INT 2
88279: ARRAY
88280: PPUSH
88281: CALL_OW 297
88285: PUSH
88286: LD_INT 6
88288: GREATER
88289: IFFALSE 88364
// begin if not HasTask ( group [ i ] ) then
88291: LD_VAR 0 4
88295: PUSH
88296: LD_VAR 0 7
88300: ARRAY
88301: PPUSH
88302: CALL_OW 314
88306: NOT
88307: IFFALSE 88362
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
88309: LD_VAR 0 4
88313: PUSH
88314: LD_VAR 0 7
88318: ARRAY
88319: PPUSH
88320: LD_VAR 0 16
88324: PUSH
88325: LD_VAR 0 7
88329: ARRAY
88330: PUSH
88331: LD_INT 1
88333: ARRAY
88334: PUSH
88335: LD_INT 1
88337: ARRAY
88338: PPUSH
88339: LD_VAR 0 16
88343: PUSH
88344: LD_VAR 0 7
88348: ARRAY
88349: PUSH
88350: LD_INT 1
88352: ARRAY
88353: PUSH
88354: LD_INT 2
88356: ARRAY
88357: PPUSH
88358: CALL_OW 114
// end else
88362: GO 88415
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
88364: LD_ADDR_VAR 0 15
88368: PUSH
88369: LD_VAR 0 16
88373: PUSH
88374: LD_VAR 0 7
88378: ARRAY
88379: PPUSH
88380: LD_INT 1
88382: PPUSH
88383: CALL_OW 3
88387: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
88388: LD_ADDR_VAR 0 16
88392: PUSH
88393: LD_VAR 0 16
88397: PPUSH
88398: LD_VAR 0 7
88402: PPUSH
88403: LD_VAR 0 15
88407: PPUSH
88408: CALL_OW 1
88412: ST_TO_ADDR
// continue ;
88413: GO 86958
// end ; end ; end else
88415: GO 91079
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
88417: LD_ADDR_VAR 0 14
88421: PUSH
88422: LD_INT 81
88424: PUSH
88425: LD_VAR 0 4
88429: PUSH
88430: LD_VAR 0 7
88434: ARRAY
88435: PPUSH
88436: CALL_OW 255
88440: PUSH
88441: EMPTY
88442: LIST
88443: LIST
88444: PPUSH
88445: CALL_OW 69
88449: ST_TO_ADDR
// if not tmp then
88450: LD_VAR 0 14
88454: NOT
88455: IFFALSE 88459
// continue ;
88457: GO 86958
// if f_ignore_area then
88459: LD_VAR 0 17
88463: IFFALSE 88551
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
88465: LD_ADDR_VAR 0 15
88469: PUSH
88470: LD_VAR 0 14
88474: PPUSH
88475: LD_INT 3
88477: PUSH
88478: LD_INT 92
88480: PUSH
88481: LD_VAR 0 17
88485: PUSH
88486: LD_INT 1
88488: ARRAY
88489: PUSH
88490: LD_VAR 0 17
88494: PUSH
88495: LD_INT 2
88497: ARRAY
88498: PUSH
88499: LD_VAR 0 17
88503: PUSH
88504: LD_INT 3
88506: ARRAY
88507: PUSH
88508: EMPTY
88509: LIST
88510: LIST
88511: LIST
88512: LIST
88513: PUSH
88514: EMPTY
88515: LIST
88516: LIST
88517: PPUSH
88518: CALL_OW 72
88522: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
88523: LD_VAR 0 14
88527: PUSH
88528: LD_VAR 0 15
88532: DIFF
88533: IFFALSE 88551
// tmp := tmp diff tmp2 ;
88535: LD_ADDR_VAR 0 14
88539: PUSH
88540: LD_VAR 0 14
88544: PUSH
88545: LD_VAR 0 15
88549: DIFF
88550: ST_TO_ADDR
// end ; if not f_murder then
88551: LD_VAR 0 20
88555: NOT
88556: IFFALSE 88614
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
88558: LD_ADDR_VAR 0 15
88562: PUSH
88563: LD_VAR 0 14
88567: PPUSH
88568: LD_INT 3
88570: PUSH
88571: LD_INT 50
88573: PUSH
88574: EMPTY
88575: LIST
88576: PUSH
88577: EMPTY
88578: LIST
88579: LIST
88580: PPUSH
88581: CALL_OW 72
88585: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
88586: LD_VAR 0 14
88590: PUSH
88591: LD_VAR 0 15
88595: DIFF
88596: IFFALSE 88614
// tmp := tmp diff tmp2 ;
88598: LD_ADDR_VAR 0 14
88602: PUSH
88603: LD_VAR 0 14
88607: PUSH
88608: LD_VAR 0 15
88612: DIFF
88613: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
88614: LD_ADDR_VAR 0 14
88618: PUSH
88619: LD_VAR 0 4
88623: PUSH
88624: LD_VAR 0 7
88628: ARRAY
88629: PPUSH
88630: LD_VAR 0 14
88634: PPUSH
88635: LD_INT 1
88637: PPUSH
88638: LD_INT 1
88640: PPUSH
88641: CALL 58402 0 4
88645: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
88646: LD_VAR 0 4
88650: PUSH
88651: LD_VAR 0 7
88655: ARRAY
88656: PPUSH
88657: CALL_OW 257
88661: PUSH
88662: LD_INT 1
88664: EQUAL
88665: IFFALSE 89113
// begin if WantPlant ( group [ i ] ) then
88667: LD_VAR 0 4
88671: PUSH
88672: LD_VAR 0 7
88676: ARRAY
88677: PPUSH
88678: CALL 57903 0 1
88682: IFFALSE 88686
// continue ;
88684: GO 86958
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
88686: LD_VAR 0 18
88690: PUSH
88691: LD_VAR 0 4
88695: PUSH
88696: LD_VAR 0 7
88700: ARRAY
88701: PPUSH
88702: CALL_OW 310
88706: NOT
88707: AND
88708: PUSH
88709: LD_VAR 0 14
88713: PUSH
88714: LD_INT 1
88716: ARRAY
88717: PUSH
88718: LD_VAR 0 14
88722: PPUSH
88723: LD_INT 21
88725: PUSH
88726: LD_INT 2
88728: PUSH
88729: EMPTY
88730: LIST
88731: LIST
88732: PUSH
88733: LD_INT 58
88735: PUSH
88736: EMPTY
88737: LIST
88738: PUSH
88739: EMPTY
88740: LIST
88741: LIST
88742: PPUSH
88743: CALL_OW 72
88747: IN
88748: AND
88749: IFFALSE 88785
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
88751: LD_VAR 0 4
88755: PUSH
88756: LD_VAR 0 7
88760: ARRAY
88761: PPUSH
88762: LD_VAR 0 14
88766: PUSH
88767: LD_INT 1
88769: ARRAY
88770: PPUSH
88771: CALL_OW 120
// attacking := true ;
88775: LD_ADDR_VAR 0 29
88779: PUSH
88780: LD_INT 1
88782: ST_TO_ADDR
// continue ;
88783: GO 86958
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
88785: LD_VAR 0 26
88789: PUSH
88790: LD_VAR 0 4
88794: PUSH
88795: LD_VAR 0 7
88799: ARRAY
88800: PPUSH
88801: CALL_OW 257
88805: PUSH
88806: LD_INT 1
88808: EQUAL
88809: AND
88810: PUSH
88811: LD_VAR 0 4
88815: PUSH
88816: LD_VAR 0 7
88820: ARRAY
88821: PPUSH
88822: CALL_OW 256
88826: PUSH
88827: LD_INT 800
88829: LESS
88830: AND
88831: PUSH
88832: LD_VAR 0 4
88836: PUSH
88837: LD_VAR 0 7
88841: ARRAY
88842: PPUSH
88843: CALL_OW 318
88847: NOT
88848: AND
88849: IFFALSE 88866
// ComCrawl ( group [ i ] ) ;
88851: LD_VAR 0 4
88855: PUSH
88856: LD_VAR 0 7
88860: ARRAY
88861: PPUSH
88862: CALL_OW 137
// if f_mines then
88866: LD_VAR 0 21
88870: IFFALSE 89113
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
88872: LD_VAR 0 14
88876: PUSH
88877: LD_INT 1
88879: ARRAY
88880: PPUSH
88881: CALL_OW 247
88885: PUSH
88886: LD_INT 3
88888: EQUAL
88889: PUSH
88890: LD_VAR 0 14
88894: PUSH
88895: LD_INT 1
88897: ARRAY
88898: PUSH
88899: LD_VAR 0 27
88903: IN
88904: NOT
88905: AND
88906: IFFALSE 89113
// begin x := GetX ( tmp [ 1 ] ) ;
88908: LD_ADDR_VAR 0 10
88912: PUSH
88913: LD_VAR 0 14
88917: PUSH
88918: LD_INT 1
88920: ARRAY
88921: PPUSH
88922: CALL_OW 250
88926: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
88927: LD_ADDR_VAR 0 11
88931: PUSH
88932: LD_VAR 0 14
88936: PUSH
88937: LD_INT 1
88939: ARRAY
88940: PPUSH
88941: CALL_OW 251
88945: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
88946: LD_ADDR_VAR 0 12
88950: PUSH
88951: LD_VAR 0 4
88955: PUSH
88956: LD_VAR 0 7
88960: ARRAY
88961: PPUSH
88962: CALL 84844 0 1
88966: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
88967: LD_VAR 0 4
88971: PUSH
88972: LD_VAR 0 7
88976: ARRAY
88977: PPUSH
88978: LD_VAR 0 10
88982: PPUSH
88983: LD_VAR 0 11
88987: PPUSH
88988: LD_VAR 0 14
88992: PUSH
88993: LD_INT 1
88995: ARRAY
88996: PPUSH
88997: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
89001: LD_VAR 0 4
89005: PUSH
89006: LD_VAR 0 7
89010: ARRAY
89011: PPUSH
89012: LD_VAR 0 10
89016: PPUSH
89017: LD_VAR 0 12
89021: PPUSH
89022: LD_INT 7
89024: PPUSH
89025: CALL_OW 272
89029: PPUSH
89030: LD_VAR 0 11
89034: PPUSH
89035: LD_VAR 0 12
89039: PPUSH
89040: LD_INT 7
89042: PPUSH
89043: CALL_OW 273
89047: PPUSH
89048: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
89052: LD_VAR 0 4
89056: PUSH
89057: LD_VAR 0 7
89061: ARRAY
89062: PPUSH
89063: LD_INT 71
89065: PPUSH
89066: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
89070: LD_ADDR_VAR 0 27
89074: PUSH
89075: LD_VAR 0 27
89079: PPUSH
89080: LD_VAR 0 27
89084: PUSH
89085: LD_INT 1
89087: PLUS
89088: PPUSH
89089: LD_VAR 0 14
89093: PUSH
89094: LD_INT 1
89096: ARRAY
89097: PPUSH
89098: CALL_OW 1
89102: ST_TO_ADDR
// attacking := true ;
89103: LD_ADDR_VAR 0 29
89107: PUSH
89108: LD_INT 1
89110: ST_TO_ADDR
// continue ;
89111: GO 86958
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
89113: LD_VAR 0 4
89117: PUSH
89118: LD_VAR 0 7
89122: ARRAY
89123: PPUSH
89124: CALL_OW 257
89128: PUSH
89129: LD_INT 17
89131: EQUAL
89132: PUSH
89133: LD_VAR 0 4
89137: PUSH
89138: LD_VAR 0 7
89142: ARRAY
89143: PPUSH
89144: CALL_OW 110
89148: PUSH
89149: LD_INT 71
89151: EQUAL
89152: NOT
89153: AND
89154: IFFALSE 89300
// begin attacking := false ;
89156: LD_ADDR_VAR 0 29
89160: PUSH
89161: LD_INT 0
89163: ST_TO_ADDR
// k := 5 ;
89164: LD_ADDR_VAR 0 9
89168: PUSH
89169: LD_INT 5
89171: ST_TO_ADDR
// if tmp < k then
89172: LD_VAR 0 14
89176: PUSH
89177: LD_VAR 0 9
89181: LESS
89182: IFFALSE 89194
// k := tmp ;
89184: LD_ADDR_VAR 0 9
89188: PUSH
89189: LD_VAR 0 14
89193: ST_TO_ADDR
// for j = 1 to k do
89194: LD_ADDR_VAR 0 8
89198: PUSH
89199: DOUBLE
89200: LD_INT 1
89202: DEC
89203: ST_TO_ADDR
89204: LD_VAR 0 9
89208: PUSH
89209: FOR_TO
89210: IFFALSE 89298
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
89212: LD_VAR 0 14
89216: PUSH
89217: LD_VAR 0 8
89221: ARRAY
89222: PUSH
89223: LD_VAR 0 14
89227: PPUSH
89228: LD_INT 58
89230: PUSH
89231: EMPTY
89232: LIST
89233: PPUSH
89234: CALL_OW 72
89238: IN
89239: NOT
89240: IFFALSE 89296
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
89242: LD_VAR 0 4
89246: PUSH
89247: LD_VAR 0 7
89251: ARRAY
89252: PPUSH
89253: LD_VAR 0 14
89257: PUSH
89258: LD_VAR 0 8
89262: ARRAY
89263: PPUSH
89264: CALL_OW 115
// attacking := true ;
89268: LD_ADDR_VAR 0 29
89272: PUSH
89273: LD_INT 1
89275: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
89276: LD_VAR 0 4
89280: PUSH
89281: LD_VAR 0 7
89285: ARRAY
89286: PPUSH
89287: LD_INT 71
89289: PPUSH
89290: CALL_OW 109
// continue ;
89294: GO 89209
// end ; end ;
89296: GO 89209
89298: POP
89299: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
89300: LD_VAR 0 4
89304: PUSH
89305: LD_VAR 0 7
89309: ARRAY
89310: PPUSH
89311: CALL_OW 257
89315: PUSH
89316: LD_INT 8
89318: EQUAL
89319: PUSH
89320: LD_VAR 0 4
89324: PUSH
89325: LD_VAR 0 7
89329: ARRAY
89330: PPUSH
89331: CALL_OW 264
89335: PUSH
89336: LD_INT 28
89338: PUSH
89339: LD_INT 45
89341: PUSH
89342: LD_INT 7
89344: PUSH
89345: LD_INT 47
89347: PUSH
89348: EMPTY
89349: LIST
89350: LIST
89351: LIST
89352: LIST
89353: IN
89354: OR
89355: IFFALSE 89611
// begin attacking := false ;
89357: LD_ADDR_VAR 0 29
89361: PUSH
89362: LD_INT 0
89364: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
89365: LD_VAR 0 14
89369: PUSH
89370: LD_INT 1
89372: ARRAY
89373: PPUSH
89374: CALL_OW 266
89378: PUSH
89379: LD_INT 32
89381: PUSH
89382: LD_INT 31
89384: PUSH
89385: LD_INT 33
89387: PUSH
89388: LD_INT 4
89390: PUSH
89391: LD_INT 5
89393: PUSH
89394: EMPTY
89395: LIST
89396: LIST
89397: LIST
89398: LIST
89399: LIST
89400: IN
89401: IFFALSE 89587
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
89403: LD_ADDR_VAR 0 9
89407: PUSH
89408: LD_VAR 0 14
89412: PUSH
89413: LD_INT 1
89415: ARRAY
89416: PPUSH
89417: CALL_OW 266
89421: PPUSH
89422: LD_VAR 0 14
89426: PUSH
89427: LD_INT 1
89429: ARRAY
89430: PPUSH
89431: CALL_OW 250
89435: PPUSH
89436: LD_VAR 0 14
89440: PUSH
89441: LD_INT 1
89443: ARRAY
89444: PPUSH
89445: CALL_OW 251
89449: PPUSH
89450: LD_VAR 0 14
89454: PUSH
89455: LD_INT 1
89457: ARRAY
89458: PPUSH
89459: CALL_OW 254
89463: PPUSH
89464: LD_VAR 0 14
89468: PUSH
89469: LD_INT 1
89471: ARRAY
89472: PPUSH
89473: CALL_OW 248
89477: PPUSH
89478: LD_INT 0
89480: PPUSH
89481: CALL 66214 0 6
89485: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
89486: LD_ADDR_VAR 0 8
89490: PUSH
89491: LD_VAR 0 4
89495: PUSH
89496: LD_VAR 0 7
89500: ARRAY
89501: PPUSH
89502: LD_VAR 0 9
89506: PPUSH
89507: CALL 84884 0 2
89511: ST_TO_ADDR
// if j then
89512: LD_VAR 0 8
89516: IFFALSE 89585
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
89518: LD_VAR 0 8
89522: PUSH
89523: LD_INT 1
89525: ARRAY
89526: PPUSH
89527: LD_VAR 0 8
89531: PUSH
89532: LD_INT 2
89534: ARRAY
89535: PPUSH
89536: CALL_OW 488
89540: IFFALSE 89585
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
89542: LD_VAR 0 4
89546: PUSH
89547: LD_VAR 0 7
89551: ARRAY
89552: PPUSH
89553: LD_VAR 0 8
89557: PUSH
89558: LD_INT 1
89560: ARRAY
89561: PPUSH
89562: LD_VAR 0 8
89566: PUSH
89567: LD_INT 2
89569: ARRAY
89570: PPUSH
89571: CALL_OW 116
// attacking := true ;
89575: LD_ADDR_VAR 0 29
89579: PUSH
89580: LD_INT 1
89582: ST_TO_ADDR
// continue ;
89583: GO 86958
// end ; end else
89585: GO 89611
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
89587: LD_VAR 0 4
89591: PUSH
89592: LD_VAR 0 7
89596: ARRAY
89597: PPUSH
89598: LD_VAR 0 14
89602: PUSH
89603: LD_INT 1
89605: ARRAY
89606: PPUSH
89607: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
89611: LD_VAR 0 4
89615: PUSH
89616: LD_VAR 0 7
89620: ARRAY
89621: PPUSH
89622: CALL_OW 265
89626: PUSH
89627: LD_INT 11
89629: EQUAL
89630: IFFALSE 89908
// begin k := 10 ;
89632: LD_ADDR_VAR 0 9
89636: PUSH
89637: LD_INT 10
89639: ST_TO_ADDR
// x := 0 ;
89640: LD_ADDR_VAR 0 10
89644: PUSH
89645: LD_INT 0
89647: ST_TO_ADDR
// if tmp < k then
89648: LD_VAR 0 14
89652: PUSH
89653: LD_VAR 0 9
89657: LESS
89658: IFFALSE 89670
// k := tmp ;
89660: LD_ADDR_VAR 0 9
89664: PUSH
89665: LD_VAR 0 14
89669: ST_TO_ADDR
// for j = k downto 1 do
89670: LD_ADDR_VAR 0 8
89674: PUSH
89675: DOUBLE
89676: LD_VAR 0 9
89680: INC
89681: ST_TO_ADDR
89682: LD_INT 1
89684: PUSH
89685: FOR_DOWNTO
89686: IFFALSE 89761
// begin if GetType ( tmp [ j ] ) = unit_human then
89688: LD_VAR 0 14
89692: PUSH
89693: LD_VAR 0 8
89697: ARRAY
89698: PPUSH
89699: CALL_OW 247
89703: PUSH
89704: LD_INT 1
89706: EQUAL
89707: IFFALSE 89759
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
89709: LD_VAR 0 4
89713: PUSH
89714: LD_VAR 0 7
89718: ARRAY
89719: PPUSH
89720: LD_VAR 0 14
89724: PUSH
89725: LD_VAR 0 8
89729: ARRAY
89730: PPUSH
89731: CALL 85155 0 2
// x := tmp [ j ] ;
89735: LD_ADDR_VAR 0 10
89739: PUSH
89740: LD_VAR 0 14
89744: PUSH
89745: LD_VAR 0 8
89749: ARRAY
89750: ST_TO_ADDR
// attacking := true ;
89751: LD_ADDR_VAR 0 29
89755: PUSH
89756: LD_INT 1
89758: ST_TO_ADDR
// end ; end ;
89759: GO 89685
89761: POP
89762: POP
// if not x then
89763: LD_VAR 0 10
89767: NOT
89768: IFFALSE 89908
// begin attacking := true ;
89770: LD_ADDR_VAR 0 29
89774: PUSH
89775: LD_INT 1
89777: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
89778: LD_VAR 0 4
89782: PUSH
89783: LD_VAR 0 7
89787: ARRAY
89788: PPUSH
89789: CALL_OW 250
89793: PPUSH
89794: LD_VAR 0 4
89798: PUSH
89799: LD_VAR 0 7
89803: ARRAY
89804: PPUSH
89805: CALL_OW 251
89809: PPUSH
89810: CALL_OW 546
89814: PUSH
89815: LD_INT 2
89817: ARRAY
89818: PUSH
89819: LD_VAR 0 14
89823: PUSH
89824: LD_INT 1
89826: ARRAY
89827: PPUSH
89828: CALL_OW 250
89832: PPUSH
89833: LD_VAR 0 14
89837: PUSH
89838: LD_INT 1
89840: ARRAY
89841: PPUSH
89842: CALL_OW 251
89846: PPUSH
89847: CALL_OW 546
89851: PUSH
89852: LD_INT 2
89854: ARRAY
89855: EQUAL
89856: IFFALSE 89884
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
89858: LD_VAR 0 4
89862: PUSH
89863: LD_VAR 0 7
89867: ARRAY
89868: PPUSH
89869: LD_VAR 0 14
89873: PUSH
89874: LD_INT 1
89876: ARRAY
89877: PPUSH
89878: CALL 85155 0 2
89882: GO 89908
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
89884: LD_VAR 0 4
89888: PUSH
89889: LD_VAR 0 7
89893: ARRAY
89894: PPUSH
89895: LD_VAR 0 14
89899: PUSH
89900: LD_INT 1
89902: ARRAY
89903: PPUSH
89904: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
89908: LD_VAR 0 4
89912: PUSH
89913: LD_VAR 0 7
89917: ARRAY
89918: PPUSH
89919: CALL_OW 264
89923: PUSH
89924: LD_INT 29
89926: EQUAL
89927: IFFALSE 90293
// begin if WantsToAttack ( group [ i ] ) in bombed then
89929: LD_VAR 0 4
89933: PUSH
89934: LD_VAR 0 7
89938: ARRAY
89939: PPUSH
89940: CALL_OW 319
89944: PUSH
89945: LD_VAR 0 28
89949: IN
89950: IFFALSE 89954
// continue ;
89952: GO 86958
// k := 8 ;
89954: LD_ADDR_VAR 0 9
89958: PUSH
89959: LD_INT 8
89961: ST_TO_ADDR
// x := 0 ;
89962: LD_ADDR_VAR 0 10
89966: PUSH
89967: LD_INT 0
89969: ST_TO_ADDR
// if tmp < k then
89970: LD_VAR 0 14
89974: PUSH
89975: LD_VAR 0 9
89979: LESS
89980: IFFALSE 89992
// k := tmp ;
89982: LD_ADDR_VAR 0 9
89986: PUSH
89987: LD_VAR 0 14
89991: ST_TO_ADDR
// for j = 1 to k do
89992: LD_ADDR_VAR 0 8
89996: PUSH
89997: DOUBLE
89998: LD_INT 1
90000: DEC
90001: ST_TO_ADDR
90002: LD_VAR 0 9
90006: PUSH
90007: FOR_TO
90008: IFFALSE 90140
// begin if GetType ( tmp [ j ] ) = unit_building then
90010: LD_VAR 0 14
90014: PUSH
90015: LD_VAR 0 8
90019: ARRAY
90020: PPUSH
90021: CALL_OW 247
90025: PUSH
90026: LD_INT 3
90028: EQUAL
90029: IFFALSE 90138
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
90031: LD_VAR 0 14
90035: PUSH
90036: LD_VAR 0 8
90040: ARRAY
90041: PUSH
90042: LD_VAR 0 28
90046: IN
90047: NOT
90048: PUSH
90049: LD_VAR 0 14
90053: PUSH
90054: LD_VAR 0 8
90058: ARRAY
90059: PPUSH
90060: CALL_OW 313
90064: AND
90065: IFFALSE 90138
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
90067: LD_VAR 0 4
90071: PUSH
90072: LD_VAR 0 7
90076: ARRAY
90077: PPUSH
90078: LD_VAR 0 14
90082: PUSH
90083: LD_VAR 0 8
90087: ARRAY
90088: PPUSH
90089: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
90093: LD_ADDR_VAR 0 28
90097: PUSH
90098: LD_VAR 0 28
90102: PPUSH
90103: LD_VAR 0 28
90107: PUSH
90108: LD_INT 1
90110: PLUS
90111: PPUSH
90112: LD_VAR 0 14
90116: PUSH
90117: LD_VAR 0 8
90121: ARRAY
90122: PPUSH
90123: CALL_OW 1
90127: ST_TO_ADDR
// attacking := true ;
90128: LD_ADDR_VAR 0 29
90132: PUSH
90133: LD_INT 1
90135: ST_TO_ADDR
// break ;
90136: GO 90140
// end ; end ;
90138: GO 90007
90140: POP
90141: POP
// if not attacking and f_attack_depot then
90142: LD_VAR 0 29
90146: NOT
90147: PUSH
90148: LD_VAR 0 25
90152: AND
90153: IFFALSE 90248
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
90155: LD_ADDR_VAR 0 13
90159: PUSH
90160: LD_VAR 0 14
90164: PPUSH
90165: LD_INT 2
90167: PUSH
90168: LD_INT 30
90170: PUSH
90171: LD_INT 0
90173: PUSH
90174: EMPTY
90175: LIST
90176: LIST
90177: PUSH
90178: LD_INT 30
90180: PUSH
90181: LD_INT 1
90183: PUSH
90184: EMPTY
90185: LIST
90186: LIST
90187: PUSH
90188: EMPTY
90189: LIST
90190: LIST
90191: LIST
90192: PPUSH
90193: CALL_OW 72
90197: ST_TO_ADDR
// if z then
90198: LD_VAR 0 13
90202: IFFALSE 90248
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
90204: LD_VAR 0 4
90208: PUSH
90209: LD_VAR 0 7
90213: ARRAY
90214: PPUSH
90215: LD_VAR 0 13
90219: PPUSH
90220: LD_VAR 0 4
90224: PUSH
90225: LD_VAR 0 7
90229: ARRAY
90230: PPUSH
90231: CALL_OW 74
90235: PPUSH
90236: CALL_OW 115
// attacking := true ;
90240: LD_ADDR_VAR 0 29
90244: PUSH
90245: LD_INT 1
90247: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
90248: LD_VAR 0 4
90252: PUSH
90253: LD_VAR 0 7
90257: ARRAY
90258: PPUSH
90259: CALL_OW 256
90263: PUSH
90264: LD_INT 500
90266: LESS
90267: IFFALSE 90293
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
90269: LD_VAR 0 4
90273: PUSH
90274: LD_VAR 0 7
90278: ARRAY
90279: PPUSH
90280: LD_VAR 0 14
90284: PUSH
90285: LD_INT 1
90287: ARRAY
90288: PPUSH
90289: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
90293: LD_VAR 0 4
90297: PUSH
90298: LD_VAR 0 7
90302: ARRAY
90303: PPUSH
90304: CALL_OW 264
90308: PUSH
90309: LD_INT 49
90311: EQUAL
90312: IFFALSE 90433
// begin if not HasTask ( group [ i ] ) then
90314: LD_VAR 0 4
90318: PUSH
90319: LD_VAR 0 7
90323: ARRAY
90324: PPUSH
90325: CALL_OW 314
90329: NOT
90330: IFFALSE 90433
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
90332: LD_ADDR_VAR 0 9
90336: PUSH
90337: LD_INT 81
90339: PUSH
90340: LD_VAR 0 4
90344: PUSH
90345: LD_VAR 0 7
90349: ARRAY
90350: PPUSH
90351: CALL_OW 255
90355: PUSH
90356: EMPTY
90357: LIST
90358: LIST
90359: PPUSH
90360: CALL_OW 69
90364: PPUSH
90365: LD_VAR 0 4
90369: PUSH
90370: LD_VAR 0 7
90374: ARRAY
90375: PPUSH
90376: CALL_OW 74
90380: ST_TO_ADDR
// if k then
90381: LD_VAR 0 9
90385: IFFALSE 90433
// if GetDistUnits ( group [ i ] , k ) > 10 then
90387: LD_VAR 0 4
90391: PUSH
90392: LD_VAR 0 7
90396: ARRAY
90397: PPUSH
90398: LD_VAR 0 9
90402: PPUSH
90403: CALL_OW 296
90407: PUSH
90408: LD_INT 10
90410: GREATER
90411: IFFALSE 90433
// ComMoveUnit ( group [ i ] , k ) ;
90413: LD_VAR 0 4
90417: PUSH
90418: LD_VAR 0 7
90422: ARRAY
90423: PPUSH
90424: LD_VAR 0 9
90428: PPUSH
90429: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
90433: LD_VAR 0 4
90437: PUSH
90438: LD_VAR 0 7
90442: ARRAY
90443: PPUSH
90444: CALL_OW 256
90448: PUSH
90449: LD_INT 250
90451: LESS
90452: PUSH
90453: LD_VAR 0 4
90457: PUSH
90458: LD_VAR 0 7
90462: ARRAY
90463: PUSH
90464: LD_INT 21
90466: PUSH
90467: LD_INT 2
90469: PUSH
90470: EMPTY
90471: LIST
90472: LIST
90473: PUSH
90474: LD_INT 23
90476: PUSH
90477: LD_INT 2
90479: PUSH
90480: EMPTY
90481: LIST
90482: LIST
90483: PUSH
90484: EMPTY
90485: LIST
90486: LIST
90487: PPUSH
90488: CALL_OW 69
90492: IN
90493: AND
90494: IFFALSE 90619
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
90496: LD_ADDR_VAR 0 9
90500: PUSH
90501: LD_OWVAR 3
90505: PUSH
90506: LD_VAR 0 4
90510: PUSH
90511: LD_VAR 0 7
90515: ARRAY
90516: DIFF
90517: PPUSH
90518: LD_VAR 0 4
90522: PUSH
90523: LD_VAR 0 7
90527: ARRAY
90528: PPUSH
90529: CALL_OW 74
90533: ST_TO_ADDR
// if not k then
90534: LD_VAR 0 9
90538: NOT
90539: IFFALSE 90543
// continue ;
90541: GO 86958
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
90543: LD_VAR 0 9
90547: PUSH
90548: LD_INT 81
90550: PUSH
90551: LD_VAR 0 4
90555: PUSH
90556: LD_VAR 0 7
90560: ARRAY
90561: PPUSH
90562: CALL_OW 255
90566: PUSH
90567: EMPTY
90568: LIST
90569: LIST
90570: PPUSH
90571: CALL_OW 69
90575: IN
90576: PUSH
90577: LD_VAR 0 9
90581: PPUSH
90582: LD_VAR 0 4
90586: PUSH
90587: LD_VAR 0 7
90591: ARRAY
90592: PPUSH
90593: CALL_OW 296
90597: PUSH
90598: LD_INT 5
90600: LESS
90601: AND
90602: IFFALSE 90619
// ComAutodestruct ( group [ i ] ) ;
90604: LD_VAR 0 4
90608: PUSH
90609: LD_VAR 0 7
90613: ARRAY
90614: PPUSH
90615: CALL 85053 0 1
// end ; if f_attack_depot then
90619: LD_VAR 0 25
90623: IFFALSE 90735
// begin k := 6 ;
90625: LD_ADDR_VAR 0 9
90629: PUSH
90630: LD_INT 6
90632: ST_TO_ADDR
// if tmp < k then
90633: LD_VAR 0 14
90637: PUSH
90638: LD_VAR 0 9
90642: LESS
90643: IFFALSE 90655
// k := tmp ;
90645: LD_ADDR_VAR 0 9
90649: PUSH
90650: LD_VAR 0 14
90654: ST_TO_ADDR
// for j = 1 to k do
90655: LD_ADDR_VAR 0 8
90659: PUSH
90660: DOUBLE
90661: LD_INT 1
90663: DEC
90664: ST_TO_ADDR
90665: LD_VAR 0 9
90669: PUSH
90670: FOR_TO
90671: IFFALSE 90733
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
90673: LD_VAR 0 8
90677: PPUSH
90678: CALL_OW 266
90682: PUSH
90683: LD_INT 0
90685: PUSH
90686: LD_INT 1
90688: PUSH
90689: EMPTY
90690: LIST
90691: LIST
90692: IN
90693: IFFALSE 90731
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
90695: LD_VAR 0 4
90699: PUSH
90700: LD_VAR 0 7
90704: ARRAY
90705: PPUSH
90706: LD_VAR 0 14
90710: PUSH
90711: LD_VAR 0 8
90715: ARRAY
90716: PPUSH
90717: CALL_OW 115
// attacking := true ;
90721: LD_ADDR_VAR 0 29
90725: PUSH
90726: LD_INT 1
90728: ST_TO_ADDR
// break ;
90729: GO 90733
// end ;
90731: GO 90670
90733: POP
90734: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
90735: LD_VAR 0 4
90739: PUSH
90740: LD_VAR 0 7
90744: ARRAY
90745: PPUSH
90746: CALL_OW 302
90750: PUSH
90751: LD_VAR 0 29
90755: NOT
90756: AND
90757: IFFALSE 91079
// begin if GetTag ( group [ i ] ) = 71 then
90759: LD_VAR 0 4
90763: PUSH
90764: LD_VAR 0 7
90768: ARRAY
90769: PPUSH
90770: CALL_OW 110
90774: PUSH
90775: LD_INT 71
90777: EQUAL
90778: IFFALSE 90819
// begin if HasTask ( group [ i ] ) then
90780: LD_VAR 0 4
90784: PUSH
90785: LD_VAR 0 7
90789: ARRAY
90790: PPUSH
90791: CALL_OW 314
90795: IFFALSE 90801
// continue else
90797: GO 86958
90799: GO 90819
// SetTag ( group [ i ] , 0 ) ;
90801: LD_VAR 0 4
90805: PUSH
90806: LD_VAR 0 7
90810: ARRAY
90811: PPUSH
90812: LD_INT 0
90814: PPUSH
90815: CALL_OW 109
// end ; k := 8 ;
90819: LD_ADDR_VAR 0 9
90823: PUSH
90824: LD_INT 8
90826: ST_TO_ADDR
// x := 0 ;
90827: LD_ADDR_VAR 0 10
90831: PUSH
90832: LD_INT 0
90834: ST_TO_ADDR
// if tmp < k then
90835: LD_VAR 0 14
90839: PUSH
90840: LD_VAR 0 9
90844: LESS
90845: IFFALSE 90857
// k := tmp ;
90847: LD_ADDR_VAR 0 9
90851: PUSH
90852: LD_VAR 0 14
90856: ST_TO_ADDR
// for j = 1 to k do
90857: LD_ADDR_VAR 0 8
90861: PUSH
90862: DOUBLE
90863: LD_INT 1
90865: DEC
90866: ST_TO_ADDR
90867: LD_VAR 0 9
90871: PUSH
90872: FOR_TO
90873: IFFALSE 90971
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
90875: LD_VAR 0 14
90879: PUSH
90880: LD_VAR 0 8
90884: ARRAY
90885: PPUSH
90886: CALL_OW 247
90890: PUSH
90891: LD_INT 1
90893: EQUAL
90894: PUSH
90895: LD_VAR 0 14
90899: PUSH
90900: LD_VAR 0 8
90904: ARRAY
90905: PPUSH
90906: CALL_OW 256
90910: PUSH
90911: LD_INT 250
90913: LESS
90914: PUSH
90915: LD_VAR 0 20
90919: AND
90920: PUSH
90921: LD_VAR 0 20
90925: NOT
90926: PUSH
90927: LD_VAR 0 14
90931: PUSH
90932: LD_VAR 0 8
90936: ARRAY
90937: PPUSH
90938: CALL_OW 256
90942: PUSH
90943: LD_INT 250
90945: GREATEREQUAL
90946: AND
90947: OR
90948: AND
90949: IFFALSE 90969
// begin x := tmp [ j ] ;
90951: LD_ADDR_VAR 0 10
90955: PUSH
90956: LD_VAR 0 14
90960: PUSH
90961: LD_VAR 0 8
90965: ARRAY
90966: ST_TO_ADDR
// break ;
90967: GO 90971
// end ;
90969: GO 90872
90971: POP
90972: POP
// if x then
90973: LD_VAR 0 10
90977: IFFALSE 91001
// ComAttackUnit ( group [ i ] , x ) else
90979: LD_VAR 0 4
90983: PUSH
90984: LD_VAR 0 7
90988: ARRAY
90989: PPUSH
90990: LD_VAR 0 10
90994: PPUSH
90995: CALL_OW 115
90999: GO 91025
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
91001: LD_VAR 0 4
91005: PUSH
91006: LD_VAR 0 7
91010: ARRAY
91011: PPUSH
91012: LD_VAR 0 14
91016: PUSH
91017: LD_INT 1
91019: ARRAY
91020: PPUSH
91021: CALL_OW 115
// if not HasTask ( group [ i ] ) then
91025: LD_VAR 0 4
91029: PUSH
91030: LD_VAR 0 7
91034: ARRAY
91035: PPUSH
91036: CALL_OW 314
91040: NOT
91041: IFFALSE 91079
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
91043: LD_VAR 0 4
91047: PUSH
91048: LD_VAR 0 7
91052: ARRAY
91053: PPUSH
91054: LD_VAR 0 14
91058: PPUSH
91059: LD_VAR 0 4
91063: PUSH
91064: LD_VAR 0 7
91068: ARRAY
91069: PPUSH
91070: CALL_OW 74
91074: PPUSH
91075: CALL_OW 115
// end ; end ; end ;
91079: GO 86958
91081: POP
91082: POP
// wait ( 0 0$2 ) ;
91083: LD_INT 70
91085: PPUSH
91086: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
91090: LD_VAR 0 4
91094: NOT
91095: PUSH
91096: LD_VAR 0 4
91100: PUSH
91101: EMPTY
91102: EQUAL
91103: OR
91104: PUSH
91105: LD_INT 81
91107: PUSH
91108: LD_VAR 0 35
91112: PUSH
91113: EMPTY
91114: LIST
91115: LIST
91116: PPUSH
91117: CALL_OW 69
91121: NOT
91122: OR
91123: IFFALSE 86943
// end ;
91125: LD_VAR 0 2
91129: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
91130: LD_INT 0
91132: PPUSH
91133: PPUSH
91134: PPUSH
91135: PPUSH
// if not base_units then
91136: LD_VAR 0 1
91140: NOT
91141: IFFALSE 91145
// exit ;
91143: GO 91232
// result := false ;
91145: LD_ADDR_VAR 0 2
91149: PUSH
91150: LD_INT 0
91152: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
91153: LD_ADDR_VAR 0 5
91157: PUSH
91158: LD_VAR 0 1
91162: PPUSH
91163: LD_INT 21
91165: PUSH
91166: LD_INT 3
91168: PUSH
91169: EMPTY
91170: LIST
91171: LIST
91172: PPUSH
91173: CALL_OW 72
91177: ST_TO_ADDR
// if not tmp then
91178: LD_VAR 0 5
91182: NOT
91183: IFFALSE 91187
// exit ;
91185: GO 91232
// for i in tmp do
91187: LD_ADDR_VAR 0 3
91191: PUSH
91192: LD_VAR 0 5
91196: PUSH
91197: FOR_IN
91198: IFFALSE 91230
// begin result := EnemyInRange ( i , 22 ) ;
91200: LD_ADDR_VAR 0 2
91204: PUSH
91205: LD_VAR 0 3
91209: PPUSH
91210: LD_INT 22
91212: PPUSH
91213: CALL 84759 0 2
91217: ST_TO_ADDR
// if result then
91218: LD_VAR 0 2
91222: IFFALSE 91228
// exit ;
91224: POP
91225: POP
91226: GO 91232
// end ;
91228: GO 91197
91230: POP
91231: POP
// end ;
91232: LD_VAR 0 2
91236: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
91237: LD_INT 0
91239: PPUSH
91240: PPUSH
// if not units then
91241: LD_VAR 0 1
91245: NOT
91246: IFFALSE 91250
// exit ;
91248: GO 91320
// result := [ ] ;
91250: LD_ADDR_VAR 0 3
91254: PUSH
91255: EMPTY
91256: ST_TO_ADDR
// for i in units do
91257: LD_ADDR_VAR 0 4
91261: PUSH
91262: LD_VAR 0 1
91266: PUSH
91267: FOR_IN
91268: IFFALSE 91318
// if GetTag ( i ) = tag then
91270: LD_VAR 0 4
91274: PPUSH
91275: CALL_OW 110
91279: PUSH
91280: LD_VAR 0 2
91284: EQUAL
91285: IFFALSE 91316
// result := Insert ( result , result + 1 , i ) ;
91287: LD_ADDR_VAR 0 3
91291: PUSH
91292: LD_VAR 0 3
91296: PPUSH
91297: LD_VAR 0 3
91301: PUSH
91302: LD_INT 1
91304: PLUS
91305: PPUSH
91306: LD_VAR 0 4
91310: PPUSH
91311: CALL_OW 2
91315: ST_TO_ADDR
91316: GO 91267
91318: POP
91319: POP
// end ;
91320: LD_VAR 0 3
91324: RET
// export function IsDriver ( un ) ; begin
91325: LD_INT 0
91327: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
91328: LD_ADDR_VAR 0 2
91332: PUSH
91333: LD_VAR 0 1
91337: PUSH
91338: LD_INT 55
91340: PUSH
91341: EMPTY
91342: LIST
91343: PPUSH
91344: CALL_OW 69
91348: IN
91349: ST_TO_ADDR
// end ;
91350: LD_VAR 0 2
91354: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
91355: LD_INT 0
91357: PPUSH
91358: PPUSH
// list := [ ] ;
91359: LD_ADDR_VAR 0 5
91363: PUSH
91364: EMPTY
91365: ST_TO_ADDR
// case d of 0 :
91366: LD_VAR 0 3
91370: PUSH
91371: LD_INT 0
91373: DOUBLE
91374: EQUAL
91375: IFTRUE 91379
91377: GO 91512
91379: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
91380: LD_ADDR_VAR 0 5
91384: PUSH
91385: LD_VAR 0 1
91389: PUSH
91390: LD_INT 4
91392: MINUS
91393: PUSH
91394: LD_VAR 0 2
91398: PUSH
91399: LD_INT 4
91401: MINUS
91402: PUSH
91403: LD_INT 2
91405: PUSH
91406: EMPTY
91407: LIST
91408: LIST
91409: LIST
91410: PUSH
91411: LD_VAR 0 1
91415: PUSH
91416: LD_INT 3
91418: MINUS
91419: PUSH
91420: LD_VAR 0 2
91424: PUSH
91425: LD_INT 1
91427: PUSH
91428: EMPTY
91429: LIST
91430: LIST
91431: LIST
91432: PUSH
91433: LD_VAR 0 1
91437: PUSH
91438: LD_INT 4
91440: PLUS
91441: PUSH
91442: LD_VAR 0 2
91446: PUSH
91447: LD_INT 4
91449: PUSH
91450: EMPTY
91451: LIST
91452: LIST
91453: LIST
91454: PUSH
91455: LD_VAR 0 1
91459: PUSH
91460: LD_INT 3
91462: PLUS
91463: PUSH
91464: LD_VAR 0 2
91468: PUSH
91469: LD_INT 3
91471: PLUS
91472: PUSH
91473: LD_INT 5
91475: PUSH
91476: EMPTY
91477: LIST
91478: LIST
91479: LIST
91480: PUSH
91481: LD_VAR 0 1
91485: PUSH
91486: LD_VAR 0 2
91490: PUSH
91491: LD_INT 4
91493: PLUS
91494: PUSH
91495: LD_INT 0
91497: PUSH
91498: EMPTY
91499: LIST
91500: LIST
91501: LIST
91502: PUSH
91503: EMPTY
91504: LIST
91505: LIST
91506: LIST
91507: LIST
91508: LIST
91509: ST_TO_ADDR
// end ; 1 :
91510: GO 92210
91512: LD_INT 1
91514: DOUBLE
91515: EQUAL
91516: IFTRUE 91520
91518: GO 91653
91520: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
91521: LD_ADDR_VAR 0 5
91525: PUSH
91526: LD_VAR 0 1
91530: PUSH
91531: LD_VAR 0 2
91535: PUSH
91536: LD_INT 4
91538: MINUS
91539: PUSH
91540: LD_INT 3
91542: PUSH
91543: EMPTY
91544: LIST
91545: LIST
91546: LIST
91547: PUSH
91548: LD_VAR 0 1
91552: PUSH
91553: LD_INT 3
91555: MINUS
91556: PUSH
91557: LD_VAR 0 2
91561: PUSH
91562: LD_INT 3
91564: MINUS
91565: PUSH
91566: LD_INT 2
91568: PUSH
91569: EMPTY
91570: LIST
91571: LIST
91572: LIST
91573: PUSH
91574: LD_VAR 0 1
91578: PUSH
91579: LD_INT 4
91581: MINUS
91582: PUSH
91583: LD_VAR 0 2
91587: PUSH
91588: LD_INT 1
91590: PUSH
91591: EMPTY
91592: LIST
91593: LIST
91594: LIST
91595: PUSH
91596: LD_VAR 0 1
91600: PUSH
91601: LD_VAR 0 2
91605: PUSH
91606: LD_INT 3
91608: PLUS
91609: PUSH
91610: LD_INT 0
91612: PUSH
91613: EMPTY
91614: LIST
91615: LIST
91616: LIST
91617: PUSH
91618: LD_VAR 0 1
91622: PUSH
91623: LD_INT 4
91625: PLUS
91626: PUSH
91627: LD_VAR 0 2
91631: PUSH
91632: LD_INT 4
91634: PLUS
91635: PUSH
91636: LD_INT 5
91638: PUSH
91639: EMPTY
91640: LIST
91641: LIST
91642: LIST
91643: PUSH
91644: EMPTY
91645: LIST
91646: LIST
91647: LIST
91648: LIST
91649: LIST
91650: ST_TO_ADDR
// end ; 2 :
91651: GO 92210
91653: LD_INT 2
91655: DOUBLE
91656: EQUAL
91657: IFTRUE 91661
91659: GO 91790
91661: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
91662: LD_ADDR_VAR 0 5
91666: PUSH
91667: LD_VAR 0 1
91671: PUSH
91672: LD_VAR 0 2
91676: PUSH
91677: LD_INT 3
91679: MINUS
91680: PUSH
91681: LD_INT 3
91683: PUSH
91684: EMPTY
91685: LIST
91686: LIST
91687: LIST
91688: PUSH
91689: LD_VAR 0 1
91693: PUSH
91694: LD_INT 4
91696: PLUS
91697: PUSH
91698: LD_VAR 0 2
91702: PUSH
91703: LD_INT 4
91705: PUSH
91706: EMPTY
91707: LIST
91708: LIST
91709: LIST
91710: PUSH
91711: LD_VAR 0 1
91715: PUSH
91716: LD_VAR 0 2
91720: PUSH
91721: LD_INT 4
91723: PLUS
91724: PUSH
91725: LD_INT 0
91727: PUSH
91728: EMPTY
91729: LIST
91730: LIST
91731: LIST
91732: PUSH
91733: LD_VAR 0 1
91737: PUSH
91738: LD_INT 3
91740: MINUS
91741: PUSH
91742: LD_VAR 0 2
91746: PUSH
91747: LD_INT 1
91749: PUSH
91750: EMPTY
91751: LIST
91752: LIST
91753: LIST
91754: PUSH
91755: LD_VAR 0 1
91759: PUSH
91760: LD_INT 4
91762: MINUS
91763: PUSH
91764: LD_VAR 0 2
91768: PUSH
91769: LD_INT 4
91771: MINUS
91772: PUSH
91773: LD_INT 2
91775: PUSH
91776: EMPTY
91777: LIST
91778: LIST
91779: LIST
91780: PUSH
91781: EMPTY
91782: LIST
91783: LIST
91784: LIST
91785: LIST
91786: LIST
91787: ST_TO_ADDR
// end ; 3 :
91788: GO 92210
91790: LD_INT 3
91792: DOUBLE
91793: EQUAL
91794: IFTRUE 91798
91796: GO 91931
91798: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
91799: LD_ADDR_VAR 0 5
91803: PUSH
91804: LD_VAR 0 1
91808: PUSH
91809: LD_INT 3
91811: PLUS
91812: PUSH
91813: LD_VAR 0 2
91817: PUSH
91818: LD_INT 4
91820: PUSH
91821: EMPTY
91822: LIST
91823: LIST
91824: LIST
91825: PUSH
91826: LD_VAR 0 1
91830: PUSH
91831: LD_INT 4
91833: PLUS
91834: PUSH
91835: LD_VAR 0 2
91839: PUSH
91840: LD_INT 4
91842: PLUS
91843: PUSH
91844: LD_INT 5
91846: PUSH
91847: EMPTY
91848: LIST
91849: LIST
91850: LIST
91851: PUSH
91852: LD_VAR 0 1
91856: PUSH
91857: LD_INT 4
91859: MINUS
91860: PUSH
91861: LD_VAR 0 2
91865: PUSH
91866: LD_INT 1
91868: PUSH
91869: EMPTY
91870: LIST
91871: LIST
91872: LIST
91873: PUSH
91874: LD_VAR 0 1
91878: PUSH
91879: LD_VAR 0 2
91883: PUSH
91884: LD_INT 4
91886: MINUS
91887: PUSH
91888: LD_INT 3
91890: PUSH
91891: EMPTY
91892: LIST
91893: LIST
91894: LIST
91895: PUSH
91896: LD_VAR 0 1
91900: PUSH
91901: LD_INT 3
91903: MINUS
91904: PUSH
91905: LD_VAR 0 2
91909: PUSH
91910: LD_INT 3
91912: MINUS
91913: PUSH
91914: LD_INT 2
91916: PUSH
91917: EMPTY
91918: LIST
91919: LIST
91920: LIST
91921: PUSH
91922: EMPTY
91923: LIST
91924: LIST
91925: LIST
91926: LIST
91927: LIST
91928: ST_TO_ADDR
// end ; 4 :
91929: GO 92210
91931: LD_INT 4
91933: DOUBLE
91934: EQUAL
91935: IFTRUE 91939
91937: GO 92072
91939: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
91940: LD_ADDR_VAR 0 5
91944: PUSH
91945: LD_VAR 0 1
91949: PUSH
91950: LD_VAR 0 2
91954: PUSH
91955: LD_INT 4
91957: PLUS
91958: PUSH
91959: LD_INT 0
91961: PUSH
91962: EMPTY
91963: LIST
91964: LIST
91965: LIST
91966: PUSH
91967: LD_VAR 0 1
91971: PUSH
91972: LD_INT 3
91974: PLUS
91975: PUSH
91976: LD_VAR 0 2
91980: PUSH
91981: LD_INT 3
91983: PLUS
91984: PUSH
91985: LD_INT 5
91987: PUSH
91988: EMPTY
91989: LIST
91990: LIST
91991: LIST
91992: PUSH
91993: LD_VAR 0 1
91997: PUSH
91998: LD_INT 4
92000: PLUS
92001: PUSH
92002: LD_VAR 0 2
92006: PUSH
92007: LD_INT 4
92009: PUSH
92010: EMPTY
92011: LIST
92012: LIST
92013: LIST
92014: PUSH
92015: LD_VAR 0 1
92019: PUSH
92020: LD_VAR 0 2
92024: PUSH
92025: LD_INT 3
92027: MINUS
92028: PUSH
92029: LD_INT 3
92031: PUSH
92032: EMPTY
92033: LIST
92034: LIST
92035: LIST
92036: PUSH
92037: LD_VAR 0 1
92041: PUSH
92042: LD_INT 4
92044: MINUS
92045: PUSH
92046: LD_VAR 0 2
92050: PUSH
92051: LD_INT 4
92053: MINUS
92054: PUSH
92055: LD_INT 2
92057: PUSH
92058: EMPTY
92059: LIST
92060: LIST
92061: LIST
92062: PUSH
92063: EMPTY
92064: LIST
92065: LIST
92066: LIST
92067: LIST
92068: LIST
92069: ST_TO_ADDR
// end ; 5 :
92070: GO 92210
92072: LD_INT 5
92074: DOUBLE
92075: EQUAL
92076: IFTRUE 92080
92078: GO 92209
92080: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
92081: LD_ADDR_VAR 0 5
92085: PUSH
92086: LD_VAR 0 1
92090: PUSH
92091: LD_INT 4
92093: MINUS
92094: PUSH
92095: LD_VAR 0 2
92099: PUSH
92100: LD_INT 1
92102: PUSH
92103: EMPTY
92104: LIST
92105: LIST
92106: LIST
92107: PUSH
92108: LD_VAR 0 1
92112: PUSH
92113: LD_VAR 0 2
92117: PUSH
92118: LD_INT 4
92120: MINUS
92121: PUSH
92122: LD_INT 3
92124: PUSH
92125: EMPTY
92126: LIST
92127: LIST
92128: LIST
92129: PUSH
92130: LD_VAR 0 1
92134: PUSH
92135: LD_INT 4
92137: PLUS
92138: PUSH
92139: LD_VAR 0 2
92143: PUSH
92144: LD_INT 4
92146: PLUS
92147: PUSH
92148: LD_INT 5
92150: PUSH
92151: EMPTY
92152: LIST
92153: LIST
92154: LIST
92155: PUSH
92156: LD_VAR 0 1
92160: PUSH
92161: LD_INT 3
92163: PLUS
92164: PUSH
92165: LD_VAR 0 2
92169: PUSH
92170: LD_INT 4
92172: PUSH
92173: EMPTY
92174: LIST
92175: LIST
92176: LIST
92177: PUSH
92178: LD_VAR 0 1
92182: PUSH
92183: LD_VAR 0 2
92187: PUSH
92188: LD_INT 3
92190: PLUS
92191: PUSH
92192: LD_INT 0
92194: PUSH
92195: EMPTY
92196: LIST
92197: LIST
92198: LIST
92199: PUSH
92200: EMPTY
92201: LIST
92202: LIST
92203: LIST
92204: LIST
92205: LIST
92206: ST_TO_ADDR
// end ; end ;
92207: GO 92210
92209: POP
// result := list ;
92210: LD_ADDR_VAR 0 4
92214: PUSH
92215: LD_VAR 0 5
92219: ST_TO_ADDR
// end ;
92220: LD_VAR 0 4
92224: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
92225: LD_INT 0
92227: PPUSH
92228: PPUSH
92229: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
92230: LD_VAR 0 1
92234: NOT
92235: PUSH
92236: LD_VAR 0 2
92240: PUSH
92241: LD_INT 1
92243: PUSH
92244: LD_INT 2
92246: PUSH
92247: LD_INT 3
92249: PUSH
92250: LD_INT 4
92252: PUSH
92253: EMPTY
92254: LIST
92255: LIST
92256: LIST
92257: LIST
92258: IN
92259: NOT
92260: OR
92261: IFFALSE 92265
// exit ;
92263: GO 92357
// tmp := [ ] ;
92265: LD_ADDR_VAR 0 5
92269: PUSH
92270: EMPTY
92271: ST_TO_ADDR
// for i in units do
92272: LD_ADDR_VAR 0 4
92276: PUSH
92277: LD_VAR 0 1
92281: PUSH
92282: FOR_IN
92283: IFFALSE 92326
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
92285: LD_ADDR_VAR 0 5
92289: PUSH
92290: LD_VAR 0 5
92294: PPUSH
92295: LD_VAR 0 5
92299: PUSH
92300: LD_INT 1
92302: PLUS
92303: PPUSH
92304: LD_VAR 0 4
92308: PPUSH
92309: LD_VAR 0 2
92313: PPUSH
92314: CALL_OW 259
92318: PPUSH
92319: CALL_OW 2
92323: ST_TO_ADDR
92324: GO 92282
92326: POP
92327: POP
// if not tmp then
92328: LD_VAR 0 5
92332: NOT
92333: IFFALSE 92337
// exit ;
92335: GO 92357
// result := SortListByListDesc ( units , tmp ) ;
92337: LD_ADDR_VAR 0 3
92341: PUSH
92342: LD_VAR 0 1
92346: PPUSH
92347: LD_VAR 0 5
92351: PPUSH
92352: CALL_OW 77
92356: ST_TO_ADDR
// end ;
92357: LD_VAR 0 3
92361: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
92362: LD_INT 0
92364: PPUSH
92365: PPUSH
92366: PPUSH
// x := GetX ( building ) ;
92367: LD_ADDR_VAR 0 4
92371: PUSH
92372: LD_VAR 0 2
92376: PPUSH
92377: CALL_OW 250
92381: ST_TO_ADDR
// y := GetY ( building ) ;
92382: LD_ADDR_VAR 0 5
92386: PUSH
92387: LD_VAR 0 2
92391: PPUSH
92392: CALL_OW 251
92396: ST_TO_ADDR
// if GetTaskList ( unit ) then
92397: LD_VAR 0 1
92401: PPUSH
92402: CALL_OW 437
92406: IFFALSE 92501
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
92408: LD_STRING e
92410: PUSH
92411: LD_VAR 0 1
92415: PPUSH
92416: CALL_OW 437
92420: PUSH
92421: LD_INT 1
92423: ARRAY
92424: PUSH
92425: LD_INT 1
92427: ARRAY
92428: EQUAL
92429: PUSH
92430: LD_VAR 0 4
92434: PUSH
92435: LD_VAR 0 1
92439: PPUSH
92440: CALL_OW 437
92444: PUSH
92445: LD_INT 1
92447: ARRAY
92448: PUSH
92449: LD_INT 2
92451: ARRAY
92452: EQUAL
92453: AND
92454: PUSH
92455: LD_VAR 0 5
92459: PUSH
92460: LD_VAR 0 1
92464: PPUSH
92465: CALL_OW 437
92469: PUSH
92470: LD_INT 1
92472: ARRAY
92473: PUSH
92474: LD_INT 3
92476: ARRAY
92477: EQUAL
92478: AND
92479: IFFALSE 92491
// result := true else
92481: LD_ADDR_VAR 0 3
92485: PUSH
92486: LD_INT 1
92488: ST_TO_ADDR
92489: GO 92499
// result := false ;
92491: LD_ADDR_VAR 0 3
92495: PUSH
92496: LD_INT 0
92498: ST_TO_ADDR
// end else
92499: GO 92509
// result := false ;
92501: LD_ADDR_VAR 0 3
92505: PUSH
92506: LD_INT 0
92508: ST_TO_ADDR
// end ;
92509: LD_VAR 0 3
92513: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
92514: LD_INT 0
92516: PPUSH
92517: PPUSH
92518: PPUSH
92519: PPUSH
// if not unit or not area then
92520: LD_VAR 0 1
92524: NOT
92525: PUSH
92526: LD_VAR 0 2
92530: NOT
92531: OR
92532: IFFALSE 92536
// exit ;
92534: GO 92700
// tmp := AreaToList ( area , i ) ;
92536: LD_ADDR_VAR 0 6
92540: PUSH
92541: LD_VAR 0 2
92545: PPUSH
92546: LD_VAR 0 5
92550: PPUSH
92551: CALL_OW 517
92555: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
92556: LD_ADDR_VAR 0 5
92560: PUSH
92561: DOUBLE
92562: LD_INT 1
92564: DEC
92565: ST_TO_ADDR
92566: LD_VAR 0 6
92570: PUSH
92571: LD_INT 1
92573: ARRAY
92574: PUSH
92575: FOR_TO
92576: IFFALSE 92698
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
92578: LD_ADDR_VAR 0 7
92582: PUSH
92583: LD_VAR 0 6
92587: PUSH
92588: LD_INT 1
92590: ARRAY
92591: PUSH
92592: LD_VAR 0 5
92596: ARRAY
92597: PUSH
92598: LD_VAR 0 6
92602: PUSH
92603: LD_INT 2
92605: ARRAY
92606: PUSH
92607: LD_VAR 0 5
92611: ARRAY
92612: PUSH
92613: EMPTY
92614: LIST
92615: LIST
92616: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
92617: LD_VAR 0 7
92621: PUSH
92622: LD_INT 1
92624: ARRAY
92625: PPUSH
92626: LD_VAR 0 7
92630: PUSH
92631: LD_INT 2
92633: ARRAY
92634: PPUSH
92635: CALL_OW 428
92639: PUSH
92640: LD_INT 0
92642: EQUAL
92643: IFFALSE 92696
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
92645: LD_VAR 0 1
92649: PPUSH
92650: LD_VAR 0 7
92654: PUSH
92655: LD_INT 1
92657: ARRAY
92658: PPUSH
92659: LD_VAR 0 7
92663: PUSH
92664: LD_INT 2
92666: ARRAY
92667: PPUSH
92668: LD_VAR 0 3
92672: PPUSH
92673: CALL_OW 48
// result := IsPlaced ( unit ) ;
92677: LD_ADDR_VAR 0 4
92681: PUSH
92682: LD_VAR 0 1
92686: PPUSH
92687: CALL_OW 305
92691: ST_TO_ADDR
// exit ;
92692: POP
92693: POP
92694: GO 92700
// end ; end ;
92696: GO 92575
92698: POP
92699: POP
// end ;
92700: LD_VAR 0 4
92704: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
92705: LD_INT 0
92707: PPUSH
92708: PPUSH
92709: PPUSH
// if not side or side > 8 then
92710: LD_VAR 0 1
92714: NOT
92715: PUSH
92716: LD_VAR 0 1
92720: PUSH
92721: LD_INT 8
92723: GREATER
92724: OR
92725: IFFALSE 92729
// exit ;
92727: GO 92916
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
92729: LD_ADDR_VAR 0 4
92733: PUSH
92734: LD_INT 22
92736: PUSH
92737: LD_VAR 0 1
92741: PUSH
92742: EMPTY
92743: LIST
92744: LIST
92745: PUSH
92746: LD_INT 21
92748: PUSH
92749: LD_INT 3
92751: PUSH
92752: EMPTY
92753: LIST
92754: LIST
92755: PUSH
92756: EMPTY
92757: LIST
92758: LIST
92759: PPUSH
92760: CALL_OW 69
92764: ST_TO_ADDR
// if not tmp then
92765: LD_VAR 0 4
92769: NOT
92770: IFFALSE 92774
// exit ;
92772: GO 92916
// enable_addtolog := true ;
92774: LD_ADDR_OWVAR 81
92778: PUSH
92779: LD_INT 1
92781: ST_TO_ADDR
// AddToLog ( [ ) ;
92782: LD_STRING [
92784: PPUSH
92785: CALL_OW 561
// for i in tmp do
92789: LD_ADDR_VAR 0 3
92793: PUSH
92794: LD_VAR 0 4
92798: PUSH
92799: FOR_IN
92800: IFFALSE 92907
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
92802: LD_STRING [
92804: PUSH
92805: LD_VAR 0 3
92809: PPUSH
92810: CALL_OW 266
92814: STR
92815: PUSH
92816: LD_STRING , 
92818: STR
92819: PUSH
92820: LD_VAR 0 3
92824: PPUSH
92825: CALL_OW 250
92829: STR
92830: PUSH
92831: LD_STRING , 
92833: STR
92834: PUSH
92835: LD_VAR 0 3
92839: PPUSH
92840: CALL_OW 251
92844: STR
92845: PUSH
92846: LD_STRING , 
92848: STR
92849: PUSH
92850: LD_VAR 0 3
92854: PPUSH
92855: CALL_OW 254
92859: STR
92860: PUSH
92861: LD_STRING , 
92863: STR
92864: PUSH
92865: LD_VAR 0 3
92869: PPUSH
92870: LD_INT 1
92872: PPUSH
92873: CALL_OW 268
92877: STR
92878: PUSH
92879: LD_STRING , 
92881: STR
92882: PUSH
92883: LD_VAR 0 3
92887: PPUSH
92888: LD_INT 2
92890: PPUSH
92891: CALL_OW 268
92895: STR
92896: PUSH
92897: LD_STRING ],
92899: STR
92900: PPUSH
92901: CALL_OW 561
// end ;
92905: GO 92799
92907: POP
92908: POP
// AddToLog ( ]; ) ;
92909: LD_STRING ];
92911: PPUSH
92912: CALL_OW 561
// end ;
92916: LD_VAR 0 2
92920: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
92921: LD_INT 0
92923: PPUSH
92924: PPUSH
92925: PPUSH
92926: PPUSH
92927: PPUSH
// if not area or not rate or not max then
92928: LD_VAR 0 1
92932: NOT
92933: PUSH
92934: LD_VAR 0 2
92938: NOT
92939: OR
92940: PUSH
92941: LD_VAR 0 4
92945: NOT
92946: OR
92947: IFFALSE 92951
// exit ;
92949: GO 93143
// while 1 do
92951: LD_INT 1
92953: IFFALSE 93143
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
92955: LD_ADDR_VAR 0 9
92959: PUSH
92960: LD_VAR 0 1
92964: PPUSH
92965: LD_INT 1
92967: PPUSH
92968: CALL_OW 287
92972: PUSH
92973: LD_INT 10
92975: MUL
92976: ST_TO_ADDR
// r := rate / 10 ;
92977: LD_ADDR_VAR 0 7
92981: PUSH
92982: LD_VAR 0 2
92986: PUSH
92987: LD_INT 10
92989: DIVREAL
92990: ST_TO_ADDR
// time := 1 1$00 ;
92991: LD_ADDR_VAR 0 8
92995: PUSH
92996: LD_INT 2100
92998: ST_TO_ADDR
// if amount < min then
92999: LD_VAR 0 9
93003: PUSH
93004: LD_VAR 0 3
93008: LESS
93009: IFFALSE 93027
// r := r * 2 else
93011: LD_ADDR_VAR 0 7
93015: PUSH
93016: LD_VAR 0 7
93020: PUSH
93021: LD_INT 2
93023: MUL
93024: ST_TO_ADDR
93025: GO 93053
// if amount > max then
93027: LD_VAR 0 9
93031: PUSH
93032: LD_VAR 0 4
93036: GREATER
93037: IFFALSE 93053
// r := r / 2 ;
93039: LD_ADDR_VAR 0 7
93043: PUSH
93044: LD_VAR 0 7
93048: PUSH
93049: LD_INT 2
93051: DIVREAL
93052: ST_TO_ADDR
// time := time / r ;
93053: LD_ADDR_VAR 0 8
93057: PUSH
93058: LD_VAR 0 8
93062: PUSH
93063: LD_VAR 0 7
93067: DIVREAL
93068: ST_TO_ADDR
// if time < 0 then
93069: LD_VAR 0 8
93073: PUSH
93074: LD_INT 0
93076: LESS
93077: IFFALSE 93094
// time := time * - 1 ;
93079: LD_ADDR_VAR 0 8
93083: PUSH
93084: LD_VAR 0 8
93088: PUSH
93089: LD_INT 1
93091: NEG
93092: MUL
93093: ST_TO_ADDR
// wait ( time ) ;
93094: LD_VAR 0 8
93098: PPUSH
93099: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
93103: LD_INT 35
93105: PPUSH
93106: LD_INT 875
93108: PPUSH
93109: CALL_OW 12
93113: PPUSH
93114: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
93118: LD_INT 1
93120: PPUSH
93121: LD_INT 5
93123: PPUSH
93124: CALL_OW 12
93128: PPUSH
93129: LD_VAR 0 1
93133: PPUSH
93134: LD_INT 1
93136: PPUSH
93137: CALL_OW 55
// end ;
93141: GO 92951
// end ;
93143: LD_VAR 0 5
93147: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
93148: LD_INT 0
93150: PPUSH
93151: PPUSH
93152: PPUSH
93153: PPUSH
93154: PPUSH
93155: PPUSH
93156: PPUSH
93157: PPUSH
// if not turrets or not factories then
93158: LD_VAR 0 1
93162: NOT
93163: PUSH
93164: LD_VAR 0 2
93168: NOT
93169: OR
93170: IFFALSE 93174
// exit ;
93172: GO 93481
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
93174: LD_ADDR_VAR 0 10
93178: PUSH
93179: LD_INT 5
93181: PUSH
93182: LD_INT 6
93184: PUSH
93185: EMPTY
93186: LIST
93187: LIST
93188: PUSH
93189: LD_INT 2
93191: PUSH
93192: LD_INT 4
93194: PUSH
93195: EMPTY
93196: LIST
93197: LIST
93198: PUSH
93199: LD_INT 3
93201: PUSH
93202: LD_INT 5
93204: PUSH
93205: EMPTY
93206: LIST
93207: LIST
93208: PUSH
93209: EMPTY
93210: LIST
93211: LIST
93212: LIST
93213: PUSH
93214: LD_INT 24
93216: PUSH
93217: LD_INT 25
93219: PUSH
93220: EMPTY
93221: LIST
93222: LIST
93223: PUSH
93224: LD_INT 23
93226: PUSH
93227: LD_INT 27
93229: PUSH
93230: EMPTY
93231: LIST
93232: LIST
93233: PUSH
93234: EMPTY
93235: LIST
93236: LIST
93237: PUSH
93238: LD_INT 42
93240: PUSH
93241: LD_INT 43
93243: PUSH
93244: EMPTY
93245: LIST
93246: LIST
93247: PUSH
93248: LD_INT 44
93250: PUSH
93251: LD_INT 46
93253: PUSH
93254: EMPTY
93255: LIST
93256: LIST
93257: PUSH
93258: LD_INT 45
93260: PUSH
93261: LD_INT 47
93263: PUSH
93264: EMPTY
93265: LIST
93266: LIST
93267: PUSH
93268: EMPTY
93269: LIST
93270: LIST
93271: LIST
93272: PUSH
93273: EMPTY
93274: LIST
93275: LIST
93276: LIST
93277: ST_TO_ADDR
// result := [ ] ;
93278: LD_ADDR_VAR 0 3
93282: PUSH
93283: EMPTY
93284: ST_TO_ADDR
// for i in turrets do
93285: LD_ADDR_VAR 0 4
93289: PUSH
93290: LD_VAR 0 1
93294: PUSH
93295: FOR_IN
93296: IFFALSE 93479
// begin nat := GetNation ( i ) ;
93298: LD_ADDR_VAR 0 7
93302: PUSH
93303: LD_VAR 0 4
93307: PPUSH
93308: CALL_OW 248
93312: ST_TO_ADDR
// weapon := 0 ;
93313: LD_ADDR_VAR 0 8
93317: PUSH
93318: LD_INT 0
93320: ST_TO_ADDR
// if not nat then
93321: LD_VAR 0 7
93325: NOT
93326: IFFALSE 93330
// continue ;
93328: GO 93295
// for j in list [ nat ] do
93330: LD_ADDR_VAR 0 5
93334: PUSH
93335: LD_VAR 0 10
93339: PUSH
93340: LD_VAR 0 7
93344: ARRAY
93345: PUSH
93346: FOR_IN
93347: IFFALSE 93388
// if GetBWeapon ( i ) = j [ 1 ] then
93349: LD_VAR 0 4
93353: PPUSH
93354: CALL_OW 269
93358: PUSH
93359: LD_VAR 0 5
93363: PUSH
93364: LD_INT 1
93366: ARRAY
93367: EQUAL
93368: IFFALSE 93386
// begin weapon := j [ 2 ] ;
93370: LD_ADDR_VAR 0 8
93374: PUSH
93375: LD_VAR 0 5
93379: PUSH
93380: LD_INT 2
93382: ARRAY
93383: ST_TO_ADDR
// break ;
93384: GO 93388
// end ;
93386: GO 93346
93388: POP
93389: POP
// if not weapon then
93390: LD_VAR 0 8
93394: NOT
93395: IFFALSE 93399
// continue ;
93397: GO 93295
// for k in factories do
93399: LD_ADDR_VAR 0 6
93403: PUSH
93404: LD_VAR 0 2
93408: PUSH
93409: FOR_IN
93410: IFFALSE 93475
// begin weapons := AvailableWeaponList ( k ) ;
93412: LD_ADDR_VAR 0 9
93416: PUSH
93417: LD_VAR 0 6
93421: PPUSH
93422: CALL_OW 478
93426: ST_TO_ADDR
// if not weapons then
93427: LD_VAR 0 9
93431: NOT
93432: IFFALSE 93436
// continue ;
93434: GO 93409
// if weapon in weapons then
93436: LD_VAR 0 8
93440: PUSH
93441: LD_VAR 0 9
93445: IN
93446: IFFALSE 93473
// begin result := [ i , weapon ] ;
93448: LD_ADDR_VAR 0 3
93452: PUSH
93453: LD_VAR 0 4
93457: PUSH
93458: LD_VAR 0 8
93462: PUSH
93463: EMPTY
93464: LIST
93465: LIST
93466: ST_TO_ADDR
// exit ;
93467: POP
93468: POP
93469: POP
93470: POP
93471: GO 93481
// end ; end ;
93473: GO 93409
93475: POP
93476: POP
// end ;
93477: GO 93295
93479: POP
93480: POP
// end ;
93481: LD_VAR 0 3
93485: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
93486: LD_INT 0
93488: PPUSH
// if not side or side > 8 then
93489: LD_VAR 0 3
93493: NOT
93494: PUSH
93495: LD_VAR 0 3
93499: PUSH
93500: LD_INT 8
93502: GREATER
93503: OR
93504: IFFALSE 93508
// exit ;
93506: GO 93567
// if not range then
93508: LD_VAR 0 4
93512: NOT
93513: IFFALSE 93524
// range := - 12 ;
93515: LD_ADDR_VAR 0 4
93519: PUSH
93520: LD_INT 12
93522: NEG
93523: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
93524: LD_VAR 0 1
93528: PPUSH
93529: LD_VAR 0 2
93533: PPUSH
93534: LD_VAR 0 3
93538: PPUSH
93539: LD_VAR 0 4
93543: PPUSH
93544: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
93548: LD_VAR 0 1
93552: PPUSH
93553: LD_VAR 0 2
93557: PPUSH
93558: LD_VAR 0 3
93562: PPUSH
93563: CALL_OW 331
// end ;
93567: LD_VAR 0 5
93571: RET
// export function Video ( mode ) ; begin
93572: LD_INT 0
93574: PPUSH
// ingame_video = mode ;
93575: LD_ADDR_OWVAR 52
93579: PUSH
93580: LD_VAR 0 1
93584: ST_TO_ADDR
// interface_hidden = mode ;
93585: LD_ADDR_OWVAR 54
93589: PUSH
93590: LD_VAR 0 1
93594: ST_TO_ADDR
// end ;
93595: LD_VAR 0 2
93599: RET
// export function Join ( array , element ) ; begin
93600: LD_INT 0
93602: PPUSH
// result := array ^ element ;
93603: LD_ADDR_VAR 0 3
93607: PUSH
93608: LD_VAR 0 1
93612: PUSH
93613: LD_VAR 0 2
93617: ADD
93618: ST_TO_ADDR
// end ;
93619: LD_VAR 0 3
93623: RET
// export function JoinUnion ( array , element ) ; begin
93624: LD_INT 0
93626: PPUSH
// result := array union element ;
93627: LD_ADDR_VAR 0 3
93631: PUSH
93632: LD_VAR 0 1
93636: PUSH
93637: LD_VAR 0 2
93641: UNION
93642: ST_TO_ADDR
// end ;
93643: LD_VAR 0 3
93647: RET
// export function GetBehemoths ( side ) ; begin
93648: LD_INT 0
93650: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
93651: LD_ADDR_VAR 0 2
93655: PUSH
93656: LD_INT 22
93658: PUSH
93659: LD_VAR 0 1
93663: PUSH
93664: EMPTY
93665: LIST
93666: LIST
93667: PUSH
93668: LD_INT 31
93670: PUSH
93671: LD_INT 25
93673: PUSH
93674: EMPTY
93675: LIST
93676: LIST
93677: PUSH
93678: EMPTY
93679: LIST
93680: LIST
93681: PPUSH
93682: CALL_OW 69
93686: ST_TO_ADDR
// end ;
93687: LD_VAR 0 2
93691: RET
// export function Shuffle ( array ) ; var i , index ; begin
93692: LD_INT 0
93694: PPUSH
93695: PPUSH
93696: PPUSH
// result := [ ] ;
93697: LD_ADDR_VAR 0 2
93701: PUSH
93702: EMPTY
93703: ST_TO_ADDR
// if not array then
93704: LD_VAR 0 1
93708: NOT
93709: IFFALSE 93713
// exit ;
93711: GO 93812
// Randomize ;
93713: CALL_OW 10
// for i = array downto 1 do
93717: LD_ADDR_VAR 0 3
93721: PUSH
93722: DOUBLE
93723: LD_VAR 0 1
93727: INC
93728: ST_TO_ADDR
93729: LD_INT 1
93731: PUSH
93732: FOR_DOWNTO
93733: IFFALSE 93810
// begin index := rand ( 1 , array ) ;
93735: LD_ADDR_VAR 0 4
93739: PUSH
93740: LD_INT 1
93742: PPUSH
93743: LD_VAR 0 1
93747: PPUSH
93748: CALL_OW 12
93752: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
93753: LD_ADDR_VAR 0 2
93757: PUSH
93758: LD_VAR 0 2
93762: PPUSH
93763: LD_VAR 0 2
93767: PUSH
93768: LD_INT 1
93770: PLUS
93771: PPUSH
93772: LD_VAR 0 1
93776: PUSH
93777: LD_VAR 0 4
93781: ARRAY
93782: PPUSH
93783: CALL_OW 2
93787: ST_TO_ADDR
// array := Delete ( array , index ) ;
93788: LD_ADDR_VAR 0 1
93792: PUSH
93793: LD_VAR 0 1
93797: PPUSH
93798: LD_VAR 0 4
93802: PPUSH
93803: CALL_OW 3
93807: ST_TO_ADDR
// end ;
93808: GO 93732
93810: POP
93811: POP
// end ;
93812: LD_VAR 0 2
93816: RET
// export function GetBaseMaterials ( base ) ; begin
93817: LD_INT 0
93819: PPUSH
// result := [ 0 , 0 , 0 ] ;
93820: LD_ADDR_VAR 0 2
93824: PUSH
93825: LD_INT 0
93827: PUSH
93828: LD_INT 0
93830: PUSH
93831: LD_INT 0
93833: PUSH
93834: EMPTY
93835: LIST
93836: LIST
93837: LIST
93838: ST_TO_ADDR
// if not base then
93839: LD_VAR 0 1
93843: NOT
93844: IFFALSE 93848
// exit ;
93846: GO 93897
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
93848: LD_ADDR_VAR 0 2
93852: PUSH
93853: LD_VAR 0 1
93857: PPUSH
93858: LD_INT 1
93860: PPUSH
93861: CALL_OW 275
93865: PUSH
93866: LD_VAR 0 1
93870: PPUSH
93871: LD_INT 2
93873: PPUSH
93874: CALL_OW 275
93878: PUSH
93879: LD_VAR 0 1
93883: PPUSH
93884: LD_INT 3
93886: PPUSH
93887: CALL_OW 275
93891: PUSH
93892: EMPTY
93893: LIST
93894: LIST
93895: LIST
93896: ST_TO_ADDR
// end ; end_of_file end_of_file
93897: LD_VAR 0 2
93901: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
93902: GO 93904
93904: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
93905: LD_STRING initStreamRollete();
93907: PPUSH
93908: CALL_OW 559
// InitStreamMode ;
93912: CALL 93921 0 0
// DefineStreamItems ( ) ;
93916: CALL 94361 0 0
// end ;
93920: END
// function InitStreamMode ; begin
93921: LD_INT 0
93923: PPUSH
// streamModeActive := false ;
93924: LD_ADDR_EXP 130
93928: PUSH
93929: LD_INT 0
93931: ST_TO_ADDR
// normalCounter := 36 ;
93932: LD_ADDR_EXP 131
93936: PUSH
93937: LD_INT 36
93939: ST_TO_ADDR
// hardcoreCounter := 16 ;
93940: LD_ADDR_EXP 132
93944: PUSH
93945: LD_INT 16
93947: ST_TO_ADDR
// sRocket := false ;
93948: LD_ADDR_EXP 135
93952: PUSH
93953: LD_INT 0
93955: ST_TO_ADDR
// sSpeed := false ;
93956: LD_ADDR_EXP 134
93960: PUSH
93961: LD_INT 0
93963: ST_TO_ADDR
// sEngine := false ;
93964: LD_ADDR_EXP 136
93968: PUSH
93969: LD_INT 0
93971: ST_TO_ADDR
// sSpec := false ;
93972: LD_ADDR_EXP 133
93976: PUSH
93977: LD_INT 0
93979: ST_TO_ADDR
// sLevel := false ;
93980: LD_ADDR_EXP 137
93984: PUSH
93985: LD_INT 0
93987: ST_TO_ADDR
// sArmoury := false ;
93988: LD_ADDR_EXP 138
93992: PUSH
93993: LD_INT 0
93995: ST_TO_ADDR
// sRadar := false ;
93996: LD_ADDR_EXP 139
94000: PUSH
94001: LD_INT 0
94003: ST_TO_ADDR
// sBunker := false ;
94004: LD_ADDR_EXP 140
94008: PUSH
94009: LD_INT 0
94011: ST_TO_ADDR
// sHack := false ;
94012: LD_ADDR_EXP 141
94016: PUSH
94017: LD_INT 0
94019: ST_TO_ADDR
// sFire := false ;
94020: LD_ADDR_EXP 142
94024: PUSH
94025: LD_INT 0
94027: ST_TO_ADDR
// sRefresh := false ;
94028: LD_ADDR_EXP 143
94032: PUSH
94033: LD_INT 0
94035: ST_TO_ADDR
// sExp := false ;
94036: LD_ADDR_EXP 144
94040: PUSH
94041: LD_INT 0
94043: ST_TO_ADDR
// sDepot := false ;
94044: LD_ADDR_EXP 145
94048: PUSH
94049: LD_INT 0
94051: ST_TO_ADDR
// sFlag := false ;
94052: LD_ADDR_EXP 146
94056: PUSH
94057: LD_INT 0
94059: ST_TO_ADDR
// sKamikadze := false ;
94060: LD_ADDR_EXP 154
94064: PUSH
94065: LD_INT 0
94067: ST_TO_ADDR
// sTroll := false ;
94068: LD_ADDR_EXP 155
94072: PUSH
94073: LD_INT 0
94075: ST_TO_ADDR
// sSlow := false ;
94076: LD_ADDR_EXP 156
94080: PUSH
94081: LD_INT 0
94083: ST_TO_ADDR
// sLack := false ;
94084: LD_ADDR_EXP 157
94088: PUSH
94089: LD_INT 0
94091: ST_TO_ADDR
// sTank := false ;
94092: LD_ADDR_EXP 159
94096: PUSH
94097: LD_INT 0
94099: ST_TO_ADDR
// sRemote := false ;
94100: LD_ADDR_EXP 160
94104: PUSH
94105: LD_INT 0
94107: ST_TO_ADDR
// sPowell := false ;
94108: LD_ADDR_EXP 161
94112: PUSH
94113: LD_INT 0
94115: ST_TO_ADDR
// sTeleport := false ;
94116: LD_ADDR_EXP 164
94120: PUSH
94121: LD_INT 0
94123: ST_TO_ADDR
// sOilTower := false ;
94124: LD_ADDR_EXP 166
94128: PUSH
94129: LD_INT 0
94131: ST_TO_ADDR
// sShovel := false ;
94132: LD_ADDR_EXP 167
94136: PUSH
94137: LD_INT 0
94139: ST_TO_ADDR
// sSheik := false ;
94140: LD_ADDR_EXP 168
94144: PUSH
94145: LD_INT 0
94147: ST_TO_ADDR
// sEarthquake := false ;
94148: LD_ADDR_EXP 170
94152: PUSH
94153: LD_INT 0
94155: ST_TO_ADDR
// sAI := false ;
94156: LD_ADDR_EXP 171
94160: PUSH
94161: LD_INT 0
94163: ST_TO_ADDR
// sCargo := false ;
94164: LD_ADDR_EXP 174
94168: PUSH
94169: LD_INT 0
94171: ST_TO_ADDR
// sDLaser := false ;
94172: LD_ADDR_EXP 175
94176: PUSH
94177: LD_INT 0
94179: ST_TO_ADDR
// sExchange := false ;
94180: LD_ADDR_EXP 176
94184: PUSH
94185: LD_INT 0
94187: ST_TO_ADDR
// sFac := false ;
94188: LD_ADDR_EXP 177
94192: PUSH
94193: LD_INT 0
94195: ST_TO_ADDR
// sPower := false ;
94196: LD_ADDR_EXP 178
94200: PUSH
94201: LD_INT 0
94203: ST_TO_ADDR
// sRandom := false ;
94204: LD_ADDR_EXP 179
94208: PUSH
94209: LD_INT 0
94211: ST_TO_ADDR
// sShield := false ;
94212: LD_ADDR_EXP 180
94216: PUSH
94217: LD_INT 0
94219: ST_TO_ADDR
// sTime := false ;
94220: LD_ADDR_EXP 181
94224: PUSH
94225: LD_INT 0
94227: ST_TO_ADDR
// sTools := false ;
94228: LD_ADDR_EXP 182
94232: PUSH
94233: LD_INT 0
94235: ST_TO_ADDR
// sSold := false ;
94236: LD_ADDR_EXP 147
94240: PUSH
94241: LD_INT 0
94243: ST_TO_ADDR
// sDiff := false ;
94244: LD_ADDR_EXP 148
94248: PUSH
94249: LD_INT 0
94251: ST_TO_ADDR
// sFog := false ;
94252: LD_ADDR_EXP 151
94256: PUSH
94257: LD_INT 0
94259: ST_TO_ADDR
// sReset := false ;
94260: LD_ADDR_EXP 152
94264: PUSH
94265: LD_INT 0
94267: ST_TO_ADDR
// sSun := false ;
94268: LD_ADDR_EXP 153
94272: PUSH
94273: LD_INT 0
94275: ST_TO_ADDR
// sTiger := false ;
94276: LD_ADDR_EXP 149
94280: PUSH
94281: LD_INT 0
94283: ST_TO_ADDR
// sBomb := false ;
94284: LD_ADDR_EXP 150
94288: PUSH
94289: LD_INT 0
94291: ST_TO_ADDR
// sWound := false ;
94292: LD_ADDR_EXP 158
94296: PUSH
94297: LD_INT 0
94299: ST_TO_ADDR
// sBetray := false ;
94300: LD_ADDR_EXP 162
94304: PUSH
94305: LD_INT 0
94307: ST_TO_ADDR
// sContamin := false ;
94308: LD_ADDR_EXP 163
94312: PUSH
94313: LD_INT 0
94315: ST_TO_ADDR
// sOil := false ;
94316: LD_ADDR_EXP 165
94320: PUSH
94321: LD_INT 0
94323: ST_TO_ADDR
// sStu := false ;
94324: LD_ADDR_EXP 169
94328: PUSH
94329: LD_INT 0
94331: ST_TO_ADDR
// sBazooka := false ;
94332: LD_ADDR_EXP 172
94336: PUSH
94337: LD_INT 0
94339: ST_TO_ADDR
// sMortar := false ;
94340: LD_ADDR_EXP 173
94344: PUSH
94345: LD_INT 0
94347: ST_TO_ADDR
// sRanger := false ;
94348: LD_ADDR_EXP 183
94352: PUSH
94353: LD_INT 0
94355: ST_TO_ADDR
// end ;
94356: LD_VAR 0 1
94360: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
94361: LD_INT 0
94363: PPUSH
94364: PPUSH
94365: PPUSH
94366: PPUSH
94367: PPUSH
// result := [ ] ;
94368: LD_ADDR_VAR 0 1
94372: PUSH
94373: EMPTY
94374: ST_TO_ADDR
// if campaign_id = 1 then
94375: LD_OWVAR 69
94379: PUSH
94380: LD_INT 1
94382: EQUAL
94383: IFFALSE 97321
// begin case mission_number of 1 :
94385: LD_OWVAR 70
94389: PUSH
94390: LD_INT 1
94392: DOUBLE
94393: EQUAL
94394: IFTRUE 94398
94396: GO 94462
94398: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
94399: LD_ADDR_VAR 0 1
94403: PUSH
94404: LD_INT 2
94406: PUSH
94407: LD_INT 4
94409: PUSH
94410: LD_INT 11
94412: PUSH
94413: LD_INT 12
94415: PUSH
94416: LD_INT 15
94418: PUSH
94419: LD_INT 16
94421: PUSH
94422: LD_INT 22
94424: PUSH
94425: LD_INT 23
94427: PUSH
94428: LD_INT 26
94430: PUSH
94431: EMPTY
94432: LIST
94433: LIST
94434: LIST
94435: LIST
94436: LIST
94437: LIST
94438: LIST
94439: LIST
94440: LIST
94441: PUSH
94442: LD_INT 101
94444: PUSH
94445: LD_INT 102
94447: PUSH
94448: LD_INT 106
94450: PUSH
94451: EMPTY
94452: LIST
94453: LIST
94454: LIST
94455: PUSH
94456: EMPTY
94457: LIST
94458: LIST
94459: ST_TO_ADDR
94460: GO 97319
94462: LD_INT 2
94464: DOUBLE
94465: EQUAL
94466: IFTRUE 94470
94468: GO 94542
94470: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
94471: LD_ADDR_VAR 0 1
94475: PUSH
94476: LD_INT 2
94478: PUSH
94479: LD_INT 4
94481: PUSH
94482: LD_INT 11
94484: PUSH
94485: LD_INT 12
94487: PUSH
94488: LD_INT 15
94490: PUSH
94491: LD_INT 16
94493: PUSH
94494: LD_INT 22
94496: PUSH
94497: LD_INT 23
94499: PUSH
94500: LD_INT 26
94502: PUSH
94503: EMPTY
94504: LIST
94505: LIST
94506: LIST
94507: LIST
94508: LIST
94509: LIST
94510: LIST
94511: LIST
94512: LIST
94513: PUSH
94514: LD_INT 101
94516: PUSH
94517: LD_INT 102
94519: PUSH
94520: LD_INT 105
94522: PUSH
94523: LD_INT 106
94525: PUSH
94526: LD_INT 108
94528: PUSH
94529: EMPTY
94530: LIST
94531: LIST
94532: LIST
94533: LIST
94534: LIST
94535: PUSH
94536: EMPTY
94537: LIST
94538: LIST
94539: ST_TO_ADDR
94540: GO 97319
94542: LD_INT 3
94544: DOUBLE
94545: EQUAL
94546: IFTRUE 94550
94548: GO 94626
94550: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
94551: LD_ADDR_VAR 0 1
94555: PUSH
94556: LD_INT 2
94558: PUSH
94559: LD_INT 4
94561: PUSH
94562: LD_INT 5
94564: PUSH
94565: LD_INT 11
94567: PUSH
94568: LD_INT 12
94570: PUSH
94571: LD_INT 15
94573: PUSH
94574: LD_INT 16
94576: PUSH
94577: LD_INT 22
94579: PUSH
94580: LD_INT 26
94582: PUSH
94583: LD_INT 36
94585: PUSH
94586: EMPTY
94587: LIST
94588: LIST
94589: LIST
94590: LIST
94591: LIST
94592: LIST
94593: LIST
94594: LIST
94595: LIST
94596: LIST
94597: PUSH
94598: LD_INT 101
94600: PUSH
94601: LD_INT 102
94603: PUSH
94604: LD_INT 105
94606: PUSH
94607: LD_INT 106
94609: PUSH
94610: LD_INT 108
94612: PUSH
94613: EMPTY
94614: LIST
94615: LIST
94616: LIST
94617: LIST
94618: LIST
94619: PUSH
94620: EMPTY
94621: LIST
94622: LIST
94623: ST_TO_ADDR
94624: GO 97319
94626: LD_INT 4
94628: DOUBLE
94629: EQUAL
94630: IFTRUE 94634
94632: GO 94718
94634: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
94635: LD_ADDR_VAR 0 1
94639: PUSH
94640: LD_INT 2
94642: PUSH
94643: LD_INT 4
94645: PUSH
94646: LD_INT 5
94648: PUSH
94649: LD_INT 8
94651: PUSH
94652: LD_INT 11
94654: PUSH
94655: LD_INT 12
94657: PUSH
94658: LD_INT 15
94660: PUSH
94661: LD_INT 16
94663: PUSH
94664: LD_INT 22
94666: PUSH
94667: LD_INT 23
94669: PUSH
94670: LD_INT 26
94672: PUSH
94673: LD_INT 36
94675: PUSH
94676: EMPTY
94677: LIST
94678: LIST
94679: LIST
94680: LIST
94681: LIST
94682: LIST
94683: LIST
94684: LIST
94685: LIST
94686: LIST
94687: LIST
94688: LIST
94689: PUSH
94690: LD_INT 101
94692: PUSH
94693: LD_INT 102
94695: PUSH
94696: LD_INT 105
94698: PUSH
94699: LD_INT 106
94701: PUSH
94702: LD_INT 108
94704: PUSH
94705: EMPTY
94706: LIST
94707: LIST
94708: LIST
94709: LIST
94710: LIST
94711: PUSH
94712: EMPTY
94713: LIST
94714: LIST
94715: ST_TO_ADDR
94716: GO 97319
94718: LD_INT 5
94720: DOUBLE
94721: EQUAL
94722: IFTRUE 94726
94724: GO 94826
94726: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
94727: LD_ADDR_VAR 0 1
94731: PUSH
94732: LD_INT 2
94734: PUSH
94735: LD_INT 4
94737: PUSH
94738: LD_INT 5
94740: PUSH
94741: LD_INT 6
94743: PUSH
94744: LD_INT 8
94746: PUSH
94747: LD_INT 11
94749: PUSH
94750: LD_INT 12
94752: PUSH
94753: LD_INT 15
94755: PUSH
94756: LD_INT 16
94758: PUSH
94759: LD_INT 22
94761: PUSH
94762: LD_INT 23
94764: PUSH
94765: LD_INT 25
94767: PUSH
94768: LD_INT 26
94770: PUSH
94771: LD_INT 36
94773: PUSH
94774: EMPTY
94775: LIST
94776: LIST
94777: LIST
94778: LIST
94779: LIST
94780: LIST
94781: LIST
94782: LIST
94783: LIST
94784: LIST
94785: LIST
94786: LIST
94787: LIST
94788: LIST
94789: PUSH
94790: LD_INT 101
94792: PUSH
94793: LD_INT 102
94795: PUSH
94796: LD_INT 105
94798: PUSH
94799: LD_INT 106
94801: PUSH
94802: LD_INT 108
94804: PUSH
94805: LD_INT 109
94807: PUSH
94808: LD_INT 112
94810: PUSH
94811: EMPTY
94812: LIST
94813: LIST
94814: LIST
94815: LIST
94816: LIST
94817: LIST
94818: LIST
94819: PUSH
94820: EMPTY
94821: LIST
94822: LIST
94823: ST_TO_ADDR
94824: GO 97319
94826: LD_INT 6
94828: DOUBLE
94829: EQUAL
94830: IFTRUE 94834
94832: GO 94954
94834: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
94835: LD_ADDR_VAR 0 1
94839: PUSH
94840: LD_INT 2
94842: PUSH
94843: LD_INT 4
94845: PUSH
94846: LD_INT 5
94848: PUSH
94849: LD_INT 6
94851: PUSH
94852: LD_INT 8
94854: PUSH
94855: LD_INT 11
94857: PUSH
94858: LD_INT 12
94860: PUSH
94861: LD_INT 15
94863: PUSH
94864: LD_INT 16
94866: PUSH
94867: LD_INT 20
94869: PUSH
94870: LD_INT 21
94872: PUSH
94873: LD_INT 22
94875: PUSH
94876: LD_INT 23
94878: PUSH
94879: LD_INT 25
94881: PUSH
94882: LD_INT 26
94884: PUSH
94885: LD_INT 30
94887: PUSH
94888: LD_INT 31
94890: PUSH
94891: LD_INT 32
94893: PUSH
94894: LD_INT 36
94896: PUSH
94897: EMPTY
94898: LIST
94899: LIST
94900: LIST
94901: LIST
94902: LIST
94903: LIST
94904: LIST
94905: LIST
94906: LIST
94907: LIST
94908: LIST
94909: LIST
94910: LIST
94911: LIST
94912: LIST
94913: LIST
94914: LIST
94915: LIST
94916: LIST
94917: PUSH
94918: LD_INT 101
94920: PUSH
94921: LD_INT 102
94923: PUSH
94924: LD_INT 105
94926: PUSH
94927: LD_INT 106
94929: PUSH
94930: LD_INT 108
94932: PUSH
94933: LD_INT 109
94935: PUSH
94936: LD_INT 112
94938: PUSH
94939: EMPTY
94940: LIST
94941: LIST
94942: LIST
94943: LIST
94944: LIST
94945: LIST
94946: LIST
94947: PUSH
94948: EMPTY
94949: LIST
94950: LIST
94951: ST_TO_ADDR
94952: GO 97319
94954: LD_INT 7
94956: DOUBLE
94957: EQUAL
94958: IFTRUE 94962
94960: GO 95062
94962: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
94963: LD_ADDR_VAR 0 1
94967: PUSH
94968: LD_INT 2
94970: PUSH
94971: LD_INT 4
94973: PUSH
94974: LD_INT 5
94976: PUSH
94977: LD_INT 7
94979: PUSH
94980: LD_INT 11
94982: PUSH
94983: LD_INT 12
94985: PUSH
94986: LD_INT 15
94988: PUSH
94989: LD_INT 16
94991: PUSH
94992: LD_INT 20
94994: PUSH
94995: LD_INT 21
94997: PUSH
94998: LD_INT 22
95000: PUSH
95001: LD_INT 23
95003: PUSH
95004: LD_INT 25
95006: PUSH
95007: LD_INT 26
95009: PUSH
95010: EMPTY
95011: LIST
95012: LIST
95013: LIST
95014: LIST
95015: LIST
95016: LIST
95017: LIST
95018: LIST
95019: LIST
95020: LIST
95021: LIST
95022: LIST
95023: LIST
95024: LIST
95025: PUSH
95026: LD_INT 101
95028: PUSH
95029: LD_INT 102
95031: PUSH
95032: LD_INT 103
95034: PUSH
95035: LD_INT 105
95037: PUSH
95038: LD_INT 106
95040: PUSH
95041: LD_INT 108
95043: PUSH
95044: LD_INT 112
95046: PUSH
95047: EMPTY
95048: LIST
95049: LIST
95050: LIST
95051: LIST
95052: LIST
95053: LIST
95054: LIST
95055: PUSH
95056: EMPTY
95057: LIST
95058: LIST
95059: ST_TO_ADDR
95060: GO 97319
95062: LD_INT 8
95064: DOUBLE
95065: EQUAL
95066: IFTRUE 95070
95068: GO 95198
95070: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
95071: LD_ADDR_VAR 0 1
95075: PUSH
95076: LD_INT 2
95078: PUSH
95079: LD_INT 4
95081: PUSH
95082: LD_INT 5
95084: PUSH
95085: LD_INT 6
95087: PUSH
95088: LD_INT 7
95090: PUSH
95091: LD_INT 8
95093: PUSH
95094: LD_INT 11
95096: PUSH
95097: LD_INT 12
95099: PUSH
95100: LD_INT 15
95102: PUSH
95103: LD_INT 16
95105: PUSH
95106: LD_INT 20
95108: PUSH
95109: LD_INT 21
95111: PUSH
95112: LD_INT 22
95114: PUSH
95115: LD_INT 23
95117: PUSH
95118: LD_INT 25
95120: PUSH
95121: LD_INT 26
95123: PUSH
95124: LD_INT 30
95126: PUSH
95127: LD_INT 31
95129: PUSH
95130: LD_INT 32
95132: PUSH
95133: LD_INT 36
95135: PUSH
95136: EMPTY
95137: LIST
95138: LIST
95139: LIST
95140: LIST
95141: LIST
95142: LIST
95143: LIST
95144: LIST
95145: LIST
95146: LIST
95147: LIST
95148: LIST
95149: LIST
95150: LIST
95151: LIST
95152: LIST
95153: LIST
95154: LIST
95155: LIST
95156: LIST
95157: PUSH
95158: LD_INT 101
95160: PUSH
95161: LD_INT 102
95163: PUSH
95164: LD_INT 103
95166: PUSH
95167: LD_INT 105
95169: PUSH
95170: LD_INT 106
95172: PUSH
95173: LD_INT 108
95175: PUSH
95176: LD_INT 109
95178: PUSH
95179: LD_INT 112
95181: PUSH
95182: EMPTY
95183: LIST
95184: LIST
95185: LIST
95186: LIST
95187: LIST
95188: LIST
95189: LIST
95190: LIST
95191: PUSH
95192: EMPTY
95193: LIST
95194: LIST
95195: ST_TO_ADDR
95196: GO 97319
95198: LD_INT 9
95200: DOUBLE
95201: EQUAL
95202: IFTRUE 95206
95204: GO 95342
95206: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
95207: LD_ADDR_VAR 0 1
95211: PUSH
95212: LD_INT 2
95214: PUSH
95215: LD_INT 4
95217: PUSH
95218: LD_INT 5
95220: PUSH
95221: LD_INT 6
95223: PUSH
95224: LD_INT 7
95226: PUSH
95227: LD_INT 8
95229: PUSH
95230: LD_INT 11
95232: PUSH
95233: LD_INT 12
95235: PUSH
95236: LD_INT 15
95238: PUSH
95239: LD_INT 16
95241: PUSH
95242: LD_INT 20
95244: PUSH
95245: LD_INT 21
95247: PUSH
95248: LD_INT 22
95250: PUSH
95251: LD_INT 23
95253: PUSH
95254: LD_INT 25
95256: PUSH
95257: LD_INT 26
95259: PUSH
95260: LD_INT 28
95262: PUSH
95263: LD_INT 30
95265: PUSH
95266: LD_INT 31
95268: PUSH
95269: LD_INT 32
95271: PUSH
95272: LD_INT 36
95274: PUSH
95275: EMPTY
95276: LIST
95277: LIST
95278: LIST
95279: LIST
95280: LIST
95281: LIST
95282: LIST
95283: LIST
95284: LIST
95285: LIST
95286: LIST
95287: LIST
95288: LIST
95289: LIST
95290: LIST
95291: LIST
95292: LIST
95293: LIST
95294: LIST
95295: LIST
95296: LIST
95297: PUSH
95298: LD_INT 101
95300: PUSH
95301: LD_INT 102
95303: PUSH
95304: LD_INT 103
95306: PUSH
95307: LD_INT 105
95309: PUSH
95310: LD_INT 106
95312: PUSH
95313: LD_INT 108
95315: PUSH
95316: LD_INT 109
95318: PUSH
95319: LD_INT 112
95321: PUSH
95322: LD_INT 114
95324: PUSH
95325: EMPTY
95326: LIST
95327: LIST
95328: LIST
95329: LIST
95330: LIST
95331: LIST
95332: LIST
95333: LIST
95334: LIST
95335: PUSH
95336: EMPTY
95337: LIST
95338: LIST
95339: ST_TO_ADDR
95340: GO 97319
95342: LD_INT 10
95344: DOUBLE
95345: EQUAL
95346: IFTRUE 95350
95348: GO 95534
95350: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
95351: LD_ADDR_VAR 0 1
95355: PUSH
95356: LD_INT 2
95358: PUSH
95359: LD_INT 4
95361: PUSH
95362: LD_INT 5
95364: PUSH
95365: LD_INT 6
95367: PUSH
95368: LD_INT 7
95370: PUSH
95371: LD_INT 8
95373: PUSH
95374: LD_INT 9
95376: PUSH
95377: LD_INT 10
95379: PUSH
95380: LD_INT 11
95382: PUSH
95383: LD_INT 12
95385: PUSH
95386: LD_INT 13
95388: PUSH
95389: LD_INT 14
95391: PUSH
95392: LD_INT 15
95394: PUSH
95395: LD_INT 16
95397: PUSH
95398: LD_INT 17
95400: PUSH
95401: LD_INT 18
95403: PUSH
95404: LD_INT 19
95406: PUSH
95407: LD_INT 20
95409: PUSH
95410: LD_INT 21
95412: PUSH
95413: LD_INT 22
95415: PUSH
95416: LD_INT 23
95418: PUSH
95419: LD_INT 24
95421: PUSH
95422: LD_INT 25
95424: PUSH
95425: LD_INT 26
95427: PUSH
95428: LD_INT 28
95430: PUSH
95431: LD_INT 30
95433: PUSH
95434: LD_INT 31
95436: PUSH
95437: LD_INT 32
95439: PUSH
95440: LD_INT 36
95442: PUSH
95443: EMPTY
95444: LIST
95445: LIST
95446: LIST
95447: LIST
95448: LIST
95449: LIST
95450: LIST
95451: LIST
95452: LIST
95453: LIST
95454: LIST
95455: LIST
95456: LIST
95457: LIST
95458: LIST
95459: LIST
95460: LIST
95461: LIST
95462: LIST
95463: LIST
95464: LIST
95465: LIST
95466: LIST
95467: LIST
95468: LIST
95469: LIST
95470: LIST
95471: LIST
95472: LIST
95473: PUSH
95474: LD_INT 101
95476: PUSH
95477: LD_INT 102
95479: PUSH
95480: LD_INT 103
95482: PUSH
95483: LD_INT 104
95485: PUSH
95486: LD_INT 105
95488: PUSH
95489: LD_INT 106
95491: PUSH
95492: LD_INT 107
95494: PUSH
95495: LD_INT 108
95497: PUSH
95498: LD_INT 109
95500: PUSH
95501: LD_INT 110
95503: PUSH
95504: LD_INT 111
95506: PUSH
95507: LD_INT 112
95509: PUSH
95510: LD_INT 114
95512: PUSH
95513: EMPTY
95514: LIST
95515: LIST
95516: LIST
95517: LIST
95518: LIST
95519: LIST
95520: LIST
95521: LIST
95522: LIST
95523: LIST
95524: LIST
95525: LIST
95526: LIST
95527: PUSH
95528: EMPTY
95529: LIST
95530: LIST
95531: ST_TO_ADDR
95532: GO 97319
95534: LD_INT 11
95536: DOUBLE
95537: EQUAL
95538: IFTRUE 95542
95540: GO 95734
95542: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
95543: LD_ADDR_VAR 0 1
95547: PUSH
95548: LD_INT 2
95550: PUSH
95551: LD_INT 3
95553: PUSH
95554: LD_INT 4
95556: PUSH
95557: LD_INT 5
95559: PUSH
95560: LD_INT 6
95562: PUSH
95563: LD_INT 7
95565: PUSH
95566: LD_INT 8
95568: PUSH
95569: LD_INT 9
95571: PUSH
95572: LD_INT 10
95574: PUSH
95575: LD_INT 11
95577: PUSH
95578: LD_INT 12
95580: PUSH
95581: LD_INT 13
95583: PUSH
95584: LD_INT 14
95586: PUSH
95587: LD_INT 15
95589: PUSH
95590: LD_INT 16
95592: PUSH
95593: LD_INT 17
95595: PUSH
95596: LD_INT 18
95598: PUSH
95599: LD_INT 19
95601: PUSH
95602: LD_INT 20
95604: PUSH
95605: LD_INT 21
95607: PUSH
95608: LD_INT 22
95610: PUSH
95611: LD_INT 23
95613: PUSH
95614: LD_INT 24
95616: PUSH
95617: LD_INT 25
95619: PUSH
95620: LD_INT 26
95622: PUSH
95623: LD_INT 28
95625: PUSH
95626: LD_INT 30
95628: PUSH
95629: LD_INT 31
95631: PUSH
95632: LD_INT 32
95634: PUSH
95635: LD_INT 34
95637: PUSH
95638: LD_INT 36
95640: PUSH
95641: EMPTY
95642: LIST
95643: LIST
95644: LIST
95645: LIST
95646: LIST
95647: LIST
95648: LIST
95649: LIST
95650: LIST
95651: LIST
95652: LIST
95653: LIST
95654: LIST
95655: LIST
95656: LIST
95657: LIST
95658: LIST
95659: LIST
95660: LIST
95661: LIST
95662: LIST
95663: LIST
95664: LIST
95665: LIST
95666: LIST
95667: LIST
95668: LIST
95669: LIST
95670: LIST
95671: LIST
95672: LIST
95673: PUSH
95674: LD_INT 101
95676: PUSH
95677: LD_INT 102
95679: PUSH
95680: LD_INT 103
95682: PUSH
95683: LD_INT 104
95685: PUSH
95686: LD_INT 105
95688: PUSH
95689: LD_INT 106
95691: PUSH
95692: LD_INT 107
95694: PUSH
95695: LD_INT 108
95697: PUSH
95698: LD_INT 109
95700: PUSH
95701: LD_INT 110
95703: PUSH
95704: LD_INT 111
95706: PUSH
95707: LD_INT 112
95709: PUSH
95710: LD_INT 114
95712: PUSH
95713: EMPTY
95714: LIST
95715: LIST
95716: LIST
95717: LIST
95718: LIST
95719: LIST
95720: LIST
95721: LIST
95722: LIST
95723: LIST
95724: LIST
95725: LIST
95726: LIST
95727: PUSH
95728: EMPTY
95729: LIST
95730: LIST
95731: ST_TO_ADDR
95732: GO 97319
95734: LD_INT 12
95736: DOUBLE
95737: EQUAL
95738: IFTRUE 95742
95740: GO 95950
95742: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
95743: LD_ADDR_VAR 0 1
95747: PUSH
95748: LD_INT 1
95750: PUSH
95751: LD_INT 2
95753: PUSH
95754: LD_INT 3
95756: PUSH
95757: LD_INT 4
95759: PUSH
95760: LD_INT 5
95762: PUSH
95763: LD_INT 6
95765: PUSH
95766: LD_INT 7
95768: PUSH
95769: LD_INT 8
95771: PUSH
95772: LD_INT 9
95774: PUSH
95775: LD_INT 10
95777: PUSH
95778: LD_INT 11
95780: PUSH
95781: LD_INT 12
95783: PUSH
95784: LD_INT 13
95786: PUSH
95787: LD_INT 14
95789: PUSH
95790: LD_INT 15
95792: PUSH
95793: LD_INT 16
95795: PUSH
95796: LD_INT 17
95798: PUSH
95799: LD_INT 18
95801: PUSH
95802: LD_INT 19
95804: PUSH
95805: LD_INT 20
95807: PUSH
95808: LD_INT 21
95810: PUSH
95811: LD_INT 22
95813: PUSH
95814: LD_INT 23
95816: PUSH
95817: LD_INT 24
95819: PUSH
95820: LD_INT 25
95822: PUSH
95823: LD_INT 26
95825: PUSH
95826: LD_INT 27
95828: PUSH
95829: LD_INT 28
95831: PUSH
95832: LD_INT 30
95834: PUSH
95835: LD_INT 31
95837: PUSH
95838: LD_INT 32
95840: PUSH
95841: LD_INT 33
95843: PUSH
95844: LD_INT 34
95846: PUSH
95847: LD_INT 36
95849: PUSH
95850: EMPTY
95851: LIST
95852: LIST
95853: LIST
95854: LIST
95855: LIST
95856: LIST
95857: LIST
95858: LIST
95859: LIST
95860: LIST
95861: LIST
95862: LIST
95863: LIST
95864: LIST
95865: LIST
95866: LIST
95867: LIST
95868: LIST
95869: LIST
95870: LIST
95871: LIST
95872: LIST
95873: LIST
95874: LIST
95875: LIST
95876: LIST
95877: LIST
95878: LIST
95879: LIST
95880: LIST
95881: LIST
95882: LIST
95883: LIST
95884: LIST
95885: PUSH
95886: LD_INT 101
95888: PUSH
95889: LD_INT 102
95891: PUSH
95892: LD_INT 103
95894: PUSH
95895: LD_INT 104
95897: PUSH
95898: LD_INT 105
95900: PUSH
95901: LD_INT 106
95903: PUSH
95904: LD_INT 107
95906: PUSH
95907: LD_INT 108
95909: PUSH
95910: LD_INT 109
95912: PUSH
95913: LD_INT 110
95915: PUSH
95916: LD_INT 111
95918: PUSH
95919: LD_INT 112
95921: PUSH
95922: LD_INT 113
95924: PUSH
95925: LD_INT 114
95927: PUSH
95928: EMPTY
95929: LIST
95930: LIST
95931: LIST
95932: LIST
95933: LIST
95934: LIST
95935: LIST
95936: LIST
95937: LIST
95938: LIST
95939: LIST
95940: LIST
95941: LIST
95942: LIST
95943: PUSH
95944: EMPTY
95945: LIST
95946: LIST
95947: ST_TO_ADDR
95948: GO 97319
95950: LD_INT 13
95952: DOUBLE
95953: EQUAL
95954: IFTRUE 95958
95956: GO 96154
95958: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
95959: LD_ADDR_VAR 0 1
95963: PUSH
95964: LD_INT 1
95966: PUSH
95967: LD_INT 2
95969: PUSH
95970: LD_INT 3
95972: PUSH
95973: LD_INT 4
95975: PUSH
95976: LD_INT 5
95978: PUSH
95979: LD_INT 8
95981: PUSH
95982: LD_INT 9
95984: PUSH
95985: LD_INT 10
95987: PUSH
95988: LD_INT 11
95990: PUSH
95991: LD_INT 12
95993: PUSH
95994: LD_INT 14
95996: PUSH
95997: LD_INT 15
95999: PUSH
96000: LD_INT 16
96002: PUSH
96003: LD_INT 17
96005: PUSH
96006: LD_INT 18
96008: PUSH
96009: LD_INT 19
96011: PUSH
96012: LD_INT 20
96014: PUSH
96015: LD_INT 21
96017: PUSH
96018: LD_INT 22
96020: PUSH
96021: LD_INT 23
96023: PUSH
96024: LD_INT 24
96026: PUSH
96027: LD_INT 25
96029: PUSH
96030: LD_INT 26
96032: PUSH
96033: LD_INT 27
96035: PUSH
96036: LD_INT 28
96038: PUSH
96039: LD_INT 30
96041: PUSH
96042: LD_INT 31
96044: PUSH
96045: LD_INT 32
96047: PUSH
96048: LD_INT 33
96050: PUSH
96051: LD_INT 34
96053: PUSH
96054: LD_INT 36
96056: PUSH
96057: EMPTY
96058: LIST
96059: LIST
96060: LIST
96061: LIST
96062: LIST
96063: LIST
96064: LIST
96065: LIST
96066: LIST
96067: LIST
96068: LIST
96069: LIST
96070: LIST
96071: LIST
96072: LIST
96073: LIST
96074: LIST
96075: LIST
96076: LIST
96077: LIST
96078: LIST
96079: LIST
96080: LIST
96081: LIST
96082: LIST
96083: LIST
96084: LIST
96085: LIST
96086: LIST
96087: LIST
96088: LIST
96089: PUSH
96090: LD_INT 101
96092: PUSH
96093: LD_INT 102
96095: PUSH
96096: LD_INT 103
96098: PUSH
96099: LD_INT 104
96101: PUSH
96102: LD_INT 105
96104: PUSH
96105: LD_INT 106
96107: PUSH
96108: LD_INT 107
96110: PUSH
96111: LD_INT 108
96113: PUSH
96114: LD_INT 109
96116: PUSH
96117: LD_INT 110
96119: PUSH
96120: LD_INT 111
96122: PUSH
96123: LD_INT 112
96125: PUSH
96126: LD_INT 113
96128: PUSH
96129: LD_INT 114
96131: PUSH
96132: EMPTY
96133: LIST
96134: LIST
96135: LIST
96136: LIST
96137: LIST
96138: LIST
96139: LIST
96140: LIST
96141: LIST
96142: LIST
96143: LIST
96144: LIST
96145: LIST
96146: LIST
96147: PUSH
96148: EMPTY
96149: LIST
96150: LIST
96151: ST_TO_ADDR
96152: GO 97319
96154: LD_INT 14
96156: DOUBLE
96157: EQUAL
96158: IFTRUE 96162
96160: GO 96374
96162: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
96163: LD_ADDR_VAR 0 1
96167: PUSH
96168: LD_INT 1
96170: PUSH
96171: LD_INT 2
96173: PUSH
96174: LD_INT 3
96176: PUSH
96177: LD_INT 4
96179: PUSH
96180: LD_INT 5
96182: PUSH
96183: LD_INT 6
96185: PUSH
96186: LD_INT 7
96188: PUSH
96189: LD_INT 8
96191: PUSH
96192: LD_INT 9
96194: PUSH
96195: LD_INT 10
96197: PUSH
96198: LD_INT 11
96200: PUSH
96201: LD_INT 12
96203: PUSH
96204: LD_INT 13
96206: PUSH
96207: LD_INT 14
96209: PUSH
96210: LD_INT 15
96212: PUSH
96213: LD_INT 16
96215: PUSH
96216: LD_INT 17
96218: PUSH
96219: LD_INT 18
96221: PUSH
96222: LD_INT 19
96224: PUSH
96225: LD_INT 20
96227: PUSH
96228: LD_INT 21
96230: PUSH
96231: LD_INT 22
96233: PUSH
96234: LD_INT 23
96236: PUSH
96237: LD_INT 24
96239: PUSH
96240: LD_INT 25
96242: PUSH
96243: LD_INT 26
96245: PUSH
96246: LD_INT 27
96248: PUSH
96249: LD_INT 28
96251: PUSH
96252: LD_INT 29
96254: PUSH
96255: LD_INT 30
96257: PUSH
96258: LD_INT 31
96260: PUSH
96261: LD_INT 32
96263: PUSH
96264: LD_INT 33
96266: PUSH
96267: LD_INT 34
96269: PUSH
96270: LD_INT 36
96272: PUSH
96273: EMPTY
96274: LIST
96275: LIST
96276: LIST
96277: LIST
96278: LIST
96279: LIST
96280: LIST
96281: LIST
96282: LIST
96283: LIST
96284: LIST
96285: LIST
96286: LIST
96287: LIST
96288: LIST
96289: LIST
96290: LIST
96291: LIST
96292: LIST
96293: LIST
96294: LIST
96295: LIST
96296: LIST
96297: LIST
96298: LIST
96299: LIST
96300: LIST
96301: LIST
96302: LIST
96303: LIST
96304: LIST
96305: LIST
96306: LIST
96307: LIST
96308: LIST
96309: PUSH
96310: LD_INT 101
96312: PUSH
96313: LD_INT 102
96315: PUSH
96316: LD_INT 103
96318: PUSH
96319: LD_INT 104
96321: PUSH
96322: LD_INT 105
96324: PUSH
96325: LD_INT 106
96327: PUSH
96328: LD_INT 107
96330: PUSH
96331: LD_INT 108
96333: PUSH
96334: LD_INT 109
96336: PUSH
96337: LD_INT 110
96339: PUSH
96340: LD_INT 111
96342: PUSH
96343: LD_INT 112
96345: PUSH
96346: LD_INT 113
96348: PUSH
96349: LD_INT 114
96351: PUSH
96352: EMPTY
96353: LIST
96354: LIST
96355: LIST
96356: LIST
96357: LIST
96358: LIST
96359: LIST
96360: LIST
96361: LIST
96362: LIST
96363: LIST
96364: LIST
96365: LIST
96366: LIST
96367: PUSH
96368: EMPTY
96369: LIST
96370: LIST
96371: ST_TO_ADDR
96372: GO 97319
96374: LD_INT 15
96376: DOUBLE
96377: EQUAL
96378: IFTRUE 96382
96380: GO 96594
96382: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
96383: LD_ADDR_VAR 0 1
96387: PUSH
96388: LD_INT 1
96390: PUSH
96391: LD_INT 2
96393: PUSH
96394: LD_INT 3
96396: PUSH
96397: LD_INT 4
96399: PUSH
96400: LD_INT 5
96402: PUSH
96403: LD_INT 6
96405: PUSH
96406: LD_INT 7
96408: PUSH
96409: LD_INT 8
96411: PUSH
96412: LD_INT 9
96414: PUSH
96415: LD_INT 10
96417: PUSH
96418: LD_INT 11
96420: PUSH
96421: LD_INT 12
96423: PUSH
96424: LD_INT 13
96426: PUSH
96427: LD_INT 14
96429: PUSH
96430: LD_INT 15
96432: PUSH
96433: LD_INT 16
96435: PUSH
96436: LD_INT 17
96438: PUSH
96439: LD_INT 18
96441: PUSH
96442: LD_INT 19
96444: PUSH
96445: LD_INT 20
96447: PUSH
96448: LD_INT 21
96450: PUSH
96451: LD_INT 22
96453: PUSH
96454: LD_INT 23
96456: PUSH
96457: LD_INT 24
96459: PUSH
96460: LD_INT 25
96462: PUSH
96463: LD_INT 26
96465: PUSH
96466: LD_INT 27
96468: PUSH
96469: LD_INT 28
96471: PUSH
96472: LD_INT 29
96474: PUSH
96475: LD_INT 30
96477: PUSH
96478: LD_INT 31
96480: PUSH
96481: LD_INT 32
96483: PUSH
96484: LD_INT 33
96486: PUSH
96487: LD_INT 34
96489: PUSH
96490: LD_INT 36
96492: PUSH
96493: EMPTY
96494: LIST
96495: LIST
96496: LIST
96497: LIST
96498: LIST
96499: LIST
96500: LIST
96501: LIST
96502: LIST
96503: LIST
96504: LIST
96505: LIST
96506: LIST
96507: LIST
96508: LIST
96509: LIST
96510: LIST
96511: LIST
96512: LIST
96513: LIST
96514: LIST
96515: LIST
96516: LIST
96517: LIST
96518: LIST
96519: LIST
96520: LIST
96521: LIST
96522: LIST
96523: LIST
96524: LIST
96525: LIST
96526: LIST
96527: LIST
96528: LIST
96529: PUSH
96530: LD_INT 101
96532: PUSH
96533: LD_INT 102
96535: PUSH
96536: LD_INT 103
96538: PUSH
96539: LD_INT 104
96541: PUSH
96542: LD_INT 105
96544: PUSH
96545: LD_INT 106
96547: PUSH
96548: LD_INT 107
96550: PUSH
96551: LD_INT 108
96553: PUSH
96554: LD_INT 109
96556: PUSH
96557: LD_INT 110
96559: PUSH
96560: LD_INT 111
96562: PUSH
96563: LD_INT 112
96565: PUSH
96566: LD_INT 113
96568: PUSH
96569: LD_INT 114
96571: PUSH
96572: EMPTY
96573: LIST
96574: LIST
96575: LIST
96576: LIST
96577: LIST
96578: LIST
96579: LIST
96580: LIST
96581: LIST
96582: LIST
96583: LIST
96584: LIST
96585: LIST
96586: LIST
96587: PUSH
96588: EMPTY
96589: LIST
96590: LIST
96591: ST_TO_ADDR
96592: GO 97319
96594: LD_INT 16
96596: DOUBLE
96597: EQUAL
96598: IFTRUE 96602
96600: GO 96726
96602: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
96603: LD_ADDR_VAR 0 1
96607: PUSH
96608: LD_INT 2
96610: PUSH
96611: LD_INT 4
96613: PUSH
96614: LD_INT 5
96616: PUSH
96617: LD_INT 7
96619: PUSH
96620: LD_INT 11
96622: PUSH
96623: LD_INT 12
96625: PUSH
96626: LD_INT 15
96628: PUSH
96629: LD_INT 16
96631: PUSH
96632: LD_INT 20
96634: PUSH
96635: LD_INT 21
96637: PUSH
96638: LD_INT 22
96640: PUSH
96641: LD_INT 23
96643: PUSH
96644: LD_INT 25
96646: PUSH
96647: LD_INT 26
96649: PUSH
96650: LD_INT 30
96652: PUSH
96653: LD_INT 31
96655: PUSH
96656: LD_INT 32
96658: PUSH
96659: LD_INT 33
96661: PUSH
96662: LD_INT 34
96664: PUSH
96665: EMPTY
96666: LIST
96667: LIST
96668: LIST
96669: LIST
96670: LIST
96671: LIST
96672: LIST
96673: LIST
96674: LIST
96675: LIST
96676: LIST
96677: LIST
96678: LIST
96679: LIST
96680: LIST
96681: LIST
96682: LIST
96683: LIST
96684: LIST
96685: PUSH
96686: LD_INT 101
96688: PUSH
96689: LD_INT 102
96691: PUSH
96692: LD_INT 103
96694: PUSH
96695: LD_INT 106
96697: PUSH
96698: LD_INT 108
96700: PUSH
96701: LD_INT 112
96703: PUSH
96704: LD_INT 113
96706: PUSH
96707: LD_INT 114
96709: PUSH
96710: EMPTY
96711: LIST
96712: LIST
96713: LIST
96714: LIST
96715: LIST
96716: LIST
96717: LIST
96718: LIST
96719: PUSH
96720: EMPTY
96721: LIST
96722: LIST
96723: ST_TO_ADDR
96724: GO 97319
96726: LD_INT 17
96728: DOUBLE
96729: EQUAL
96730: IFTRUE 96734
96732: GO 96946
96734: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
96735: LD_ADDR_VAR 0 1
96739: PUSH
96740: LD_INT 1
96742: PUSH
96743: LD_INT 2
96745: PUSH
96746: LD_INT 3
96748: PUSH
96749: LD_INT 4
96751: PUSH
96752: LD_INT 5
96754: PUSH
96755: LD_INT 6
96757: PUSH
96758: LD_INT 7
96760: PUSH
96761: LD_INT 8
96763: PUSH
96764: LD_INT 9
96766: PUSH
96767: LD_INT 10
96769: PUSH
96770: LD_INT 11
96772: PUSH
96773: LD_INT 12
96775: PUSH
96776: LD_INT 13
96778: PUSH
96779: LD_INT 14
96781: PUSH
96782: LD_INT 15
96784: PUSH
96785: LD_INT 16
96787: PUSH
96788: LD_INT 17
96790: PUSH
96791: LD_INT 18
96793: PUSH
96794: LD_INT 19
96796: PUSH
96797: LD_INT 20
96799: PUSH
96800: LD_INT 21
96802: PUSH
96803: LD_INT 22
96805: PUSH
96806: LD_INT 23
96808: PUSH
96809: LD_INT 24
96811: PUSH
96812: LD_INT 25
96814: PUSH
96815: LD_INT 26
96817: PUSH
96818: LD_INT 27
96820: PUSH
96821: LD_INT 28
96823: PUSH
96824: LD_INT 29
96826: PUSH
96827: LD_INT 30
96829: PUSH
96830: LD_INT 31
96832: PUSH
96833: LD_INT 32
96835: PUSH
96836: LD_INT 33
96838: PUSH
96839: LD_INT 34
96841: PUSH
96842: LD_INT 36
96844: PUSH
96845: EMPTY
96846: LIST
96847: LIST
96848: LIST
96849: LIST
96850: LIST
96851: LIST
96852: LIST
96853: LIST
96854: LIST
96855: LIST
96856: LIST
96857: LIST
96858: LIST
96859: LIST
96860: LIST
96861: LIST
96862: LIST
96863: LIST
96864: LIST
96865: LIST
96866: LIST
96867: LIST
96868: LIST
96869: LIST
96870: LIST
96871: LIST
96872: LIST
96873: LIST
96874: LIST
96875: LIST
96876: LIST
96877: LIST
96878: LIST
96879: LIST
96880: LIST
96881: PUSH
96882: LD_INT 101
96884: PUSH
96885: LD_INT 102
96887: PUSH
96888: LD_INT 103
96890: PUSH
96891: LD_INT 104
96893: PUSH
96894: LD_INT 105
96896: PUSH
96897: LD_INT 106
96899: PUSH
96900: LD_INT 107
96902: PUSH
96903: LD_INT 108
96905: PUSH
96906: LD_INT 109
96908: PUSH
96909: LD_INT 110
96911: PUSH
96912: LD_INT 111
96914: PUSH
96915: LD_INT 112
96917: PUSH
96918: LD_INT 113
96920: PUSH
96921: LD_INT 114
96923: PUSH
96924: EMPTY
96925: LIST
96926: LIST
96927: LIST
96928: LIST
96929: LIST
96930: LIST
96931: LIST
96932: LIST
96933: LIST
96934: LIST
96935: LIST
96936: LIST
96937: LIST
96938: LIST
96939: PUSH
96940: EMPTY
96941: LIST
96942: LIST
96943: ST_TO_ADDR
96944: GO 97319
96946: LD_INT 18
96948: DOUBLE
96949: EQUAL
96950: IFTRUE 96954
96952: GO 97090
96954: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
96955: LD_ADDR_VAR 0 1
96959: PUSH
96960: LD_INT 2
96962: PUSH
96963: LD_INT 4
96965: PUSH
96966: LD_INT 5
96968: PUSH
96969: LD_INT 7
96971: PUSH
96972: LD_INT 11
96974: PUSH
96975: LD_INT 12
96977: PUSH
96978: LD_INT 15
96980: PUSH
96981: LD_INT 16
96983: PUSH
96984: LD_INT 20
96986: PUSH
96987: LD_INT 21
96989: PUSH
96990: LD_INT 22
96992: PUSH
96993: LD_INT 23
96995: PUSH
96996: LD_INT 25
96998: PUSH
96999: LD_INT 26
97001: PUSH
97002: LD_INT 30
97004: PUSH
97005: LD_INT 31
97007: PUSH
97008: LD_INT 32
97010: PUSH
97011: LD_INT 33
97013: PUSH
97014: LD_INT 34
97016: PUSH
97017: LD_INT 35
97019: PUSH
97020: LD_INT 36
97022: PUSH
97023: EMPTY
97024: LIST
97025: LIST
97026: LIST
97027: LIST
97028: LIST
97029: LIST
97030: LIST
97031: LIST
97032: LIST
97033: LIST
97034: LIST
97035: LIST
97036: LIST
97037: LIST
97038: LIST
97039: LIST
97040: LIST
97041: LIST
97042: LIST
97043: LIST
97044: LIST
97045: PUSH
97046: LD_INT 101
97048: PUSH
97049: LD_INT 102
97051: PUSH
97052: LD_INT 103
97054: PUSH
97055: LD_INT 106
97057: PUSH
97058: LD_INT 108
97060: PUSH
97061: LD_INT 112
97063: PUSH
97064: LD_INT 113
97066: PUSH
97067: LD_INT 114
97069: PUSH
97070: LD_INT 115
97072: PUSH
97073: EMPTY
97074: LIST
97075: LIST
97076: LIST
97077: LIST
97078: LIST
97079: LIST
97080: LIST
97081: LIST
97082: LIST
97083: PUSH
97084: EMPTY
97085: LIST
97086: LIST
97087: ST_TO_ADDR
97088: GO 97319
97090: LD_INT 19
97092: DOUBLE
97093: EQUAL
97094: IFTRUE 97098
97096: GO 97318
97098: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
97099: LD_ADDR_VAR 0 1
97103: PUSH
97104: LD_INT 1
97106: PUSH
97107: LD_INT 2
97109: PUSH
97110: LD_INT 3
97112: PUSH
97113: LD_INT 4
97115: PUSH
97116: LD_INT 5
97118: PUSH
97119: LD_INT 6
97121: PUSH
97122: LD_INT 7
97124: PUSH
97125: LD_INT 8
97127: PUSH
97128: LD_INT 9
97130: PUSH
97131: LD_INT 10
97133: PUSH
97134: LD_INT 11
97136: PUSH
97137: LD_INT 12
97139: PUSH
97140: LD_INT 13
97142: PUSH
97143: LD_INT 14
97145: PUSH
97146: LD_INT 15
97148: PUSH
97149: LD_INT 16
97151: PUSH
97152: LD_INT 17
97154: PUSH
97155: LD_INT 18
97157: PUSH
97158: LD_INT 19
97160: PUSH
97161: LD_INT 20
97163: PUSH
97164: LD_INT 21
97166: PUSH
97167: LD_INT 22
97169: PUSH
97170: LD_INT 23
97172: PUSH
97173: LD_INT 24
97175: PUSH
97176: LD_INT 25
97178: PUSH
97179: LD_INT 26
97181: PUSH
97182: LD_INT 27
97184: PUSH
97185: LD_INT 28
97187: PUSH
97188: LD_INT 29
97190: PUSH
97191: LD_INT 30
97193: PUSH
97194: LD_INT 31
97196: PUSH
97197: LD_INT 32
97199: PUSH
97200: LD_INT 33
97202: PUSH
97203: LD_INT 34
97205: PUSH
97206: LD_INT 35
97208: PUSH
97209: LD_INT 36
97211: PUSH
97212: EMPTY
97213: LIST
97214: LIST
97215: LIST
97216: LIST
97217: LIST
97218: LIST
97219: LIST
97220: LIST
97221: LIST
97222: LIST
97223: LIST
97224: LIST
97225: LIST
97226: LIST
97227: LIST
97228: LIST
97229: LIST
97230: LIST
97231: LIST
97232: LIST
97233: LIST
97234: LIST
97235: LIST
97236: LIST
97237: LIST
97238: LIST
97239: LIST
97240: LIST
97241: LIST
97242: LIST
97243: LIST
97244: LIST
97245: LIST
97246: LIST
97247: LIST
97248: LIST
97249: PUSH
97250: LD_INT 101
97252: PUSH
97253: LD_INT 102
97255: PUSH
97256: LD_INT 103
97258: PUSH
97259: LD_INT 104
97261: PUSH
97262: LD_INT 105
97264: PUSH
97265: LD_INT 106
97267: PUSH
97268: LD_INT 107
97270: PUSH
97271: LD_INT 108
97273: PUSH
97274: LD_INT 109
97276: PUSH
97277: LD_INT 110
97279: PUSH
97280: LD_INT 111
97282: PUSH
97283: LD_INT 112
97285: PUSH
97286: LD_INT 113
97288: PUSH
97289: LD_INT 114
97291: PUSH
97292: LD_INT 115
97294: PUSH
97295: EMPTY
97296: LIST
97297: LIST
97298: LIST
97299: LIST
97300: LIST
97301: LIST
97302: LIST
97303: LIST
97304: LIST
97305: LIST
97306: LIST
97307: LIST
97308: LIST
97309: LIST
97310: LIST
97311: PUSH
97312: EMPTY
97313: LIST
97314: LIST
97315: ST_TO_ADDR
97316: GO 97319
97318: POP
// end else
97319: GO 97356
// if campaign_id = 5 then
97321: LD_OWVAR 69
97325: PUSH
97326: LD_INT 5
97328: EQUAL
97329: IFFALSE 97356
// begin result := [ [ 1 , 2 ] , [ 100 ] ] ;
97331: LD_ADDR_VAR 0 1
97335: PUSH
97336: LD_INT 1
97338: PUSH
97339: LD_INT 2
97341: PUSH
97342: EMPTY
97343: LIST
97344: LIST
97345: PUSH
97346: LD_INT 100
97348: PUSH
97349: EMPTY
97350: LIST
97351: PUSH
97352: EMPTY
97353: LIST
97354: LIST
97355: ST_TO_ADDR
// end ; if result then
97356: LD_VAR 0 1
97360: IFFALSE 97649
// begin normal :=  ;
97362: LD_ADDR_VAR 0 3
97366: PUSH
97367: LD_STRING 
97369: ST_TO_ADDR
// hardcore :=  ;
97370: LD_ADDR_VAR 0 4
97374: PUSH
97375: LD_STRING 
97377: ST_TO_ADDR
// for i = 1 to normalCounter do
97378: LD_ADDR_VAR 0 5
97382: PUSH
97383: DOUBLE
97384: LD_INT 1
97386: DEC
97387: ST_TO_ADDR
97388: LD_EXP 131
97392: PUSH
97393: FOR_TO
97394: IFFALSE 97495
// begin tmp := 0 ;
97396: LD_ADDR_VAR 0 2
97400: PUSH
97401: LD_STRING 0
97403: ST_TO_ADDR
// if result [ 1 ] then
97404: LD_VAR 0 1
97408: PUSH
97409: LD_INT 1
97411: ARRAY
97412: IFFALSE 97477
// if result [ 1 ] [ 1 ] = i then
97414: LD_VAR 0 1
97418: PUSH
97419: LD_INT 1
97421: ARRAY
97422: PUSH
97423: LD_INT 1
97425: ARRAY
97426: PUSH
97427: LD_VAR 0 5
97431: EQUAL
97432: IFFALSE 97477
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
97434: LD_ADDR_VAR 0 1
97438: PUSH
97439: LD_VAR 0 1
97443: PPUSH
97444: LD_INT 1
97446: PPUSH
97447: LD_VAR 0 1
97451: PUSH
97452: LD_INT 1
97454: ARRAY
97455: PPUSH
97456: LD_INT 1
97458: PPUSH
97459: CALL_OW 3
97463: PPUSH
97464: CALL_OW 1
97468: ST_TO_ADDR
// tmp := 1 ;
97469: LD_ADDR_VAR 0 2
97473: PUSH
97474: LD_STRING 1
97476: ST_TO_ADDR
// end ; normal := normal & tmp ;
97477: LD_ADDR_VAR 0 3
97481: PUSH
97482: LD_VAR 0 3
97486: PUSH
97487: LD_VAR 0 2
97491: STR
97492: ST_TO_ADDR
// end ;
97493: GO 97393
97495: POP
97496: POP
// for i = 1 to hardcoreCounter do
97497: LD_ADDR_VAR 0 5
97501: PUSH
97502: DOUBLE
97503: LD_INT 1
97505: DEC
97506: ST_TO_ADDR
97507: LD_EXP 132
97511: PUSH
97512: FOR_TO
97513: IFFALSE 97618
// begin tmp := 0 ;
97515: LD_ADDR_VAR 0 2
97519: PUSH
97520: LD_STRING 0
97522: ST_TO_ADDR
// if result [ 2 ] then
97523: LD_VAR 0 1
97527: PUSH
97528: LD_INT 2
97530: ARRAY
97531: IFFALSE 97600
// if result [ 2 ] [ 1 ] = 100 + i then
97533: LD_VAR 0 1
97537: PUSH
97538: LD_INT 2
97540: ARRAY
97541: PUSH
97542: LD_INT 1
97544: ARRAY
97545: PUSH
97546: LD_INT 100
97548: PUSH
97549: LD_VAR 0 5
97553: PLUS
97554: EQUAL
97555: IFFALSE 97600
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
97557: LD_ADDR_VAR 0 1
97561: PUSH
97562: LD_VAR 0 1
97566: PPUSH
97567: LD_INT 2
97569: PPUSH
97570: LD_VAR 0 1
97574: PUSH
97575: LD_INT 2
97577: ARRAY
97578: PPUSH
97579: LD_INT 1
97581: PPUSH
97582: CALL_OW 3
97586: PPUSH
97587: CALL_OW 1
97591: ST_TO_ADDR
// tmp := 1 ;
97592: LD_ADDR_VAR 0 2
97596: PUSH
97597: LD_STRING 1
97599: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
97600: LD_ADDR_VAR 0 4
97604: PUSH
97605: LD_VAR 0 4
97609: PUSH
97610: LD_VAR 0 2
97614: STR
97615: ST_TO_ADDR
// end ;
97616: GO 97512
97618: POP
97619: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
97620: LD_STRING getStreamItemsFromMission("
97622: PUSH
97623: LD_VAR 0 3
97627: STR
97628: PUSH
97629: LD_STRING ","
97631: STR
97632: PUSH
97633: LD_VAR 0 4
97637: STR
97638: PUSH
97639: LD_STRING ")
97641: STR
97642: PPUSH
97643: CALL_OW 559
// end else
97647: GO 97656
// ToLua ( getStreamItemsFromMission("","") ) ;
97649: LD_STRING getStreamItemsFromMission("","")
97651: PPUSH
97652: CALL_OW 559
// end ;
97656: LD_VAR 0 1
97660: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
97661: LD_VAR 0 2
97665: PUSH
97666: LD_INT 100
97668: EQUAL
97669: IFFALSE 98618
// begin if not StreamModeActive then
97671: LD_EXP 130
97675: NOT
97676: IFFALSE 97686
// StreamModeActive := true ;
97678: LD_ADDR_EXP 130
97682: PUSH
97683: LD_INT 1
97685: ST_TO_ADDR
// if p3 = 0 then
97686: LD_VAR 0 3
97690: PUSH
97691: LD_INT 0
97693: EQUAL
97694: IFFALSE 97700
// InitStreamMode ;
97696: CALL 93921 0 0
// if p3 = 1 then
97700: LD_VAR 0 3
97704: PUSH
97705: LD_INT 1
97707: EQUAL
97708: IFFALSE 97718
// sRocket := true ;
97710: LD_ADDR_EXP 135
97714: PUSH
97715: LD_INT 1
97717: ST_TO_ADDR
// if p3 = 2 then
97718: LD_VAR 0 3
97722: PUSH
97723: LD_INT 2
97725: EQUAL
97726: IFFALSE 97736
// sSpeed := true ;
97728: LD_ADDR_EXP 134
97732: PUSH
97733: LD_INT 1
97735: ST_TO_ADDR
// if p3 = 3 then
97736: LD_VAR 0 3
97740: PUSH
97741: LD_INT 3
97743: EQUAL
97744: IFFALSE 97754
// sEngine := true ;
97746: LD_ADDR_EXP 136
97750: PUSH
97751: LD_INT 1
97753: ST_TO_ADDR
// if p3 = 4 then
97754: LD_VAR 0 3
97758: PUSH
97759: LD_INT 4
97761: EQUAL
97762: IFFALSE 97772
// sSpec := true ;
97764: LD_ADDR_EXP 133
97768: PUSH
97769: LD_INT 1
97771: ST_TO_ADDR
// if p3 = 5 then
97772: LD_VAR 0 3
97776: PUSH
97777: LD_INT 5
97779: EQUAL
97780: IFFALSE 97790
// sLevel := true ;
97782: LD_ADDR_EXP 137
97786: PUSH
97787: LD_INT 1
97789: ST_TO_ADDR
// if p3 = 6 then
97790: LD_VAR 0 3
97794: PUSH
97795: LD_INT 6
97797: EQUAL
97798: IFFALSE 97808
// sArmoury := true ;
97800: LD_ADDR_EXP 138
97804: PUSH
97805: LD_INT 1
97807: ST_TO_ADDR
// if p3 = 7 then
97808: LD_VAR 0 3
97812: PUSH
97813: LD_INT 7
97815: EQUAL
97816: IFFALSE 97826
// sRadar := true ;
97818: LD_ADDR_EXP 139
97822: PUSH
97823: LD_INT 1
97825: ST_TO_ADDR
// if p3 = 8 then
97826: LD_VAR 0 3
97830: PUSH
97831: LD_INT 8
97833: EQUAL
97834: IFFALSE 97844
// sBunker := true ;
97836: LD_ADDR_EXP 140
97840: PUSH
97841: LD_INT 1
97843: ST_TO_ADDR
// if p3 = 9 then
97844: LD_VAR 0 3
97848: PUSH
97849: LD_INT 9
97851: EQUAL
97852: IFFALSE 97862
// sHack := true ;
97854: LD_ADDR_EXP 141
97858: PUSH
97859: LD_INT 1
97861: ST_TO_ADDR
// if p3 = 10 then
97862: LD_VAR 0 3
97866: PUSH
97867: LD_INT 10
97869: EQUAL
97870: IFFALSE 97880
// sFire := true ;
97872: LD_ADDR_EXP 142
97876: PUSH
97877: LD_INT 1
97879: ST_TO_ADDR
// if p3 = 11 then
97880: LD_VAR 0 3
97884: PUSH
97885: LD_INT 11
97887: EQUAL
97888: IFFALSE 97898
// sRefresh := true ;
97890: LD_ADDR_EXP 143
97894: PUSH
97895: LD_INT 1
97897: ST_TO_ADDR
// if p3 = 12 then
97898: LD_VAR 0 3
97902: PUSH
97903: LD_INT 12
97905: EQUAL
97906: IFFALSE 97916
// sExp := true ;
97908: LD_ADDR_EXP 144
97912: PUSH
97913: LD_INT 1
97915: ST_TO_ADDR
// if p3 = 13 then
97916: LD_VAR 0 3
97920: PUSH
97921: LD_INT 13
97923: EQUAL
97924: IFFALSE 97934
// sDepot := true ;
97926: LD_ADDR_EXP 145
97930: PUSH
97931: LD_INT 1
97933: ST_TO_ADDR
// if p3 = 14 then
97934: LD_VAR 0 3
97938: PUSH
97939: LD_INT 14
97941: EQUAL
97942: IFFALSE 97952
// sFlag := true ;
97944: LD_ADDR_EXP 146
97948: PUSH
97949: LD_INT 1
97951: ST_TO_ADDR
// if p3 = 15 then
97952: LD_VAR 0 3
97956: PUSH
97957: LD_INT 15
97959: EQUAL
97960: IFFALSE 97970
// sKamikadze := true ;
97962: LD_ADDR_EXP 154
97966: PUSH
97967: LD_INT 1
97969: ST_TO_ADDR
// if p3 = 16 then
97970: LD_VAR 0 3
97974: PUSH
97975: LD_INT 16
97977: EQUAL
97978: IFFALSE 97988
// sTroll := true ;
97980: LD_ADDR_EXP 155
97984: PUSH
97985: LD_INT 1
97987: ST_TO_ADDR
// if p3 = 17 then
97988: LD_VAR 0 3
97992: PUSH
97993: LD_INT 17
97995: EQUAL
97996: IFFALSE 98006
// sSlow := true ;
97998: LD_ADDR_EXP 156
98002: PUSH
98003: LD_INT 1
98005: ST_TO_ADDR
// if p3 = 18 then
98006: LD_VAR 0 3
98010: PUSH
98011: LD_INT 18
98013: EQUAL
98014: IFFALSE 98024
// sLack := true ;
98016: LD_ADDR_EXP 157
98020: PUSH
98021: LD_INT 1
98023: ST_TO_ADDR
// if p3 = 19 then
98024: LD_VAR 0 3
98028: PUSH
98029: LD_INT 19
98031: EQUAL
98032: IFFALSE 98042
// sTank := true ;
98034: LD_ADDR_EXP 159
98038: PUSH
98039: LD_INT 1
98041: ST_TO_ADDR
// if p3 = 20 then
98042: LD_VAR 0 3
98046: PUSH
98047: LD_INT 20
98049: EQUAL
98050: IFFALSE 98060
// sRemote := true ;
98052: LD_ADDR_EXP 160
98056: PUSH
98057: LD_INT 1
98059: ST_TO_ADDR
// if p3 = 21 then
98060: LD_VAR 0 3
98064: PUSH
98065: LD_INT 21
98067: EQUAL
98068: IFFALSE 98078
// sPowell := true ;
98070: LD_ADDR_EXP 161
98074: PUSH
98075: LD_INT 1
98077: ST_TO_ADDR
// if p3 = 22 then
98078: LD_VAR 0 3
98082: PUSH
98083: LD_INT 22
98085: EQUAL
98086: IFFALSE 98096
// sTeleport := true ;
98088: LD_ADDR_EXP 164
98092: PUSH
98093: LD_INT 1
98095: ST_TO_ADDR
// if p3 = 23 then
98096: LD_VAR 0 3
98100: PUSH
98101: LD_INT 23
98103: EQUAL
98104: IFFALSE 98114
// sOilTower := true ;
98106: LD_ADDR_EXP 166
98110: PUSH
98111: LD_INT 1
98113: ST_TO_ADDR
// if p3 = 24 then
98114: LD_VAR 0 3
98118: PUSH
98119: LD_INT 24
98121: EQUAL
98122: IFFALSE 98132
// sShovel := true ;
98124: LD_ADDR_EXP 167
98128: PUSH
98129: LD_INT 1
98131: ST_TO_ADDR
// if p3 = 25 then
98132: LD_VAR 0 3
98136: PUSH
98137: LD_INT 25
98139: EQUAL
98140: IFFALSE 98150
// sSheik := true ;
98142: LD_ADDR_EXP 168
98146: PUSH
98147: LD_INT 1
98149: ST_TO_ADDR
// if p3 = 26 then
98150: LD_VAR 0 3
98154: PUSH
98155: LD_INT 26
98157: EQUAL
98158: IFFALSE 98168
// sEarthquake := true ;
98160: LD_ADDR_EXP 170
98164: PUSH
98165: LD_INT 1
98167: ST_TO_ADDR
// if p3 = 27 then
98168: LD_VAR 0 3
98172: PUSH
98173: LD_INT 27
98175: EQUAL
98176: IFFALSE 98186
// sAI := true ;
98178: LD_ADDR_EXP 171
98182: PUSH
98183: LD_INT 1
98185: ST_TO_ADDR
// if p3 = 28 then
98186: LD_VAR 0 3
98190: PUSH
98191: LD_INT 28
98193: EQUAL
98194: IFFALSE 98204
// sCargo := true ;
98196: LD_ADDR_EXP 174
98200: PUSH
98201: LD_INT 1
98203: ST_TO_ADDR
// if p3 = 29 then
98204: LD_VAR 0 3
98208: PUSH
98209: LD_INT 29
98211: EQUAL
98212: IFFALSE 98222
// sDLaser := true ;
98214: LD_ADDR_EXP 175
98218: PUSH
98219: LD_INT 1
98221: ST_TO_ADDR
// if p3 = 30 then
98222: LD_VAR 0 3
98226: PUSH
98227: LD_INT 30
98229: EQUAL
98230: IFFALSE 98240
// sExchange := true ;
98232: LD_ADDR_EXP 176
98236: PUSH
98237: LD_INT 1
98239: ST_TO_ADDR
// if p3 = 31 then
98240: LD_VAR 0 3
98244: PUSH
98245: LD_INT 31
98247: EQUAL
98248: IFFALSE 98258
// sFac := true ;
98250: LD_ADDR_EXP 177
98254: PUSH
98255: LD_INT 1
98257: ST_TO_ADDR
// if p3 = 32 then
98258: LD_VAR 0 3
98262: PUSH
98263: LD_INT 32
98265: EQUAL
98266: IFFALSE 98276
// sPower := true ;
98268: LD_ADDR_EXP 178
98272: PUSH
98273: LD_INT 1
98275: ST_TO_ADDR
// if p3 = 33 then
98276: LD_VAR 0 3
98280: PUSH
98281: LD_INT 33
98283: EQUAL
98284: IFFALSE 98294
// sRandom := true ;
98286: LD_ADDR_EXP 179
98290: PUSH
98291: LD_INT 1
98293: ST_TO_ADDR
// if p3 = 34 then
98294: LD_VAR 0 3
98298: PUSH
98299: LD_INT 34
98301: EQUAL
98302: IFFALSE 98312
// sShield := true ;
98304: LD_ADDR_EXP 180
98308: PUSH
98309: LD_INT 1
98311: ST_TO_ADDR
// if p3 = 35 then
98312: LD_VAR 0 3
98316: PUSH
98317: LD_INT 35
98319: EQUAL
98320: IFFALSE 98330
// sTime := true ;
98322: LD_ADDR_EXP 181
98326: PUSH
98327: LD_INT 1
98329: ST_TO_ADDR
// if p3 = 36 then
98330: LD_VAR 0 3
98334: PUSH
98335: LD_INT 36
98337: EQUAL
98338: IFFALSE 98348
// sTools := true ;
98340: LD_ADDR_EXP 182
98344: PUSH
98345: LD_INT 1
98347: ST_TO_ADDR
// if p3 = 101 then
98348: LD_VAR 0 3
98352: PUSH
98353: LD_INT 101
98355: EQUAL
98356: IFFALSE 98366
// sSold := true ;
98358: LD_ADDR_EXP 147
98362: PUSH
98363: LD_INT 1
98365: ST_TO_ADDR
// if p3 = 102 then
98366: LD_VAR 0 3
98370: PUSH
98371: LD_INT 102
98373: EQUAL
98374: IFFALSE 98384
// sDiff := true ;
98376: LD_ADDR_EXP 148
98380: PUSH
98381: LD_INT 1
98383: ST_TO_ADDR
// if p3 = 103 then
98384: LD_VAR 0 3
98388: PUSH
98389: LD_INT 103
98391: EQUAL
98392: IFFALSE 98402
// sFog := true ;
98394: LD_ADDR_EXP 151
98398: PUSH
98399: LD_INT 1
98401: ST_TO_ADDR
// if p3 = 104 then
98402: LD_VAR 0 3
98406: PUSH
98407: LD_INT 104
98409: EQUAL
98410: IFFALSE 98420
// sReset := true ;
98412: LD_ADDR_EXP 152
98416: PUSH
98417: LD_INT 1
98419: ST_TO_ADDR
// if p3 = 105 then
98420: LD_VAR 0 3
98424: PUSH
98425: LD_INT 105
98427: EQUAL
98428: IFFALSE 98438
// sSun := true ;
98430: LD_ADDR_EXP 153
98434: PUSH
98435: LD_INT 1
98437: ST_TO_ADDR
// if p3 = 106 then
98438: LD_VAR 0 3
98442: PUSH
98443: LD_INT 106
98445: EQUAL
98446: IFFALSE 98456
// sTiger := true ;
98448: LD_ADDR_EXP 149
98452: PUSH
98453: LD_INT 1
98455: ST_TO_ADDR
// if p3 = 107 then
98456: LD_VAR 0 3
98460: PUSH
98461: LD_INT 107
98463: EQUAL
98464: IFFALSE 98474
// sBomb := true ;
98466: LD_ADDR_EXP 150
98470: PUSH
98471: LD_INT 1
98473: ST_TO_ADDR
// if p3 = 108 then
98474: LD_VAR 0 3
98478: PUSH
98479: LD_INT 108
98481: EQUAL
98482: IFFALSE 98492
// sWound := true ;
98484: LD_ADDR_EXP 158
98488: PUSH
98489: LD_INT 1
98491: ST_TO_ADDR
// if p3 = 109 then
98492: LD_VAR 0 3
98496: PUSH
98497: LD_INT 109
98499: EQUAL
98500: IFFALSE 98510
// sBetray := true ;
98502: LD_ADDR_EXP 162
98506: PUSH
98507: LD_INT 1
98509: ST_TO_ADDR
// if p3 = 110 then
98510: LD_VAR 0 3
98514: PUSH
98515: LD_INT 110
98517: EQUAL
98518: IFFALSE 98528
// sContamin := true ;
98520: LD_ADDR_EXP 163
98524: PUSH
98525: LD_INT 1
98527: ST_TO_ADDR
// if p3 = 111 then
98528: LD_VAR 0 3
98532: PUSH
98533: LD_INT 111
98535: EQUAL
98536: IFFALSE 98546
// sOil := true ;
98538: LD_ADDR_EXP 165
98542: PUSH
98543: LD_INT 1
98545: ST_TO_ADDR
// if p3 = 112 then
98546: LD_VAR 0 3
98550: PUSH
98551: LD_INT 112
98553: EQUAL
98554: IFFALSE 98564
// sStu := true ;
98556: LD_ADDR_EXP 169
98560: PUSH
98561: LD_INT 1
98563: ST_TO_ADDR
// if p3 = 113 then
98564: LD_VAR 0 3
98568: PUSH
98569: LD_INT 113
98571: EQUAL
98572: IFFALSE 98582
// sBazooka := true ;
98574: LD_ADDR_EXP 172
98578: PUSH
98579: LD_INT 1
98581: ST_TO_ADDR
// if p3 = 114 then
98582: LD_VAR 0 3
98586: PUSH
98587: LD_INT 114
98589: EQUAL
98590: IFFALSE 98600
// sMortar := true ;
98592: LD_ADDR_EXP 173
98596: PUSH
98597: LD_INT 1
98599: ST_TO_ADDR
// if p3 = 115 then
98600: LD_VAR 0 3
98604: PUSH
98605: LD_INT 115
98607: EQUAL
98608: IFFALSE 98618
// sRanger := true ;
98610: LD_ADDR_EXP 183
98614: PUSH
98615: LD_INT 1
98617: ST_TO_ADDR
// end ; end ;
98618: PPOPN 6
98620: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
98621: LD_EXP 130
98625: PUSH
98626: LD_EXP 135
98630: AND
98631: IFFALSE 98755
98633: GO 98635
98635: DISABLE
98636: LD_INT 0
98638: PPUSH
98639: PPUSH
// begin enable ;
98640: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
98641: LD_ADDR_VAR 0 2
98645: PUSH
98646: LD_INT 22
98648: PUSH
98649: LD_OWVAR 2
98653: PUSH
98654: EMPTY
98655: LIST
98656: LIST
98657: PUSH
98658: LD_INT 2
98660: PUSH
98661: LD_INT 34
98663: PUSH
98664: LD_INT 7
98666: PUSH
98667: EMPTY
98668: LIST
98669: LIST
98670: PUSH
98671: LD_INT 34
98673: PUSH
98674: LD_INT 45
98676: PUSH
98677: EMPTY
98678: LIST
98679: LIST
98680: PUSH
98681: LD_INT 34
98683: PUSH
98684: LD_INT 28
98686: PUSH
98687: EMPTY
98688: LIST
98689: LIST
98690: PUSH
98691: LD_INT 34
98693: PUSH
98694: LD_INT 47
98696: PUSH
98697: EMPTY
98698: LIST
98699: LIST
98700: PUSH
98701: EMPTY
98702: LIST
98703: LIST
98704: LIST
98705: LIST
98706: LIST
98707: PUSH
98708: EMPTY
98709: LIST
98710: LIST
98711: PPUSH
98712: CALL_OW 69
98716: ST_TO_ADDR
// if not tmp then
98717: LD_VAR 0 2
98721: NOT
98722: IFFALSE 98726
// exit ;
98724: GO 98755
// for i in tmp do
98726: LD_ADDR_VAR 0 1
98730: PUSH
98731: LD_VAR 0 2
98735: PUSH
98736: FOR_IN
98737: IFFALSE 98753
// begin SetLives ( i , 0 ) ;
98739: LD_VAR 0 1
98743: PPUSH
98744: LD_INT 0
98746: PPUSH
98747: CALL_OW 234
// end ;
98751: GO 98736
98753: POP
98754: POP
// end ;
98755: PPOPN 2
98757: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
98758: LD_EXP 130
98762: PUSH
98763: LD_EXP 136
98767: AND
98768: IFFALSE 98852
98770: GO 98772
98772: DISABLE
98773: LD_INT 0
98775: PPUSH
98776: PPUSH
// begin enable ;
98777: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
98778: LD_ADDR_VAR 0 2
98782: PUSH
98783: LD_INT 22
98785: PUSH
98786: LD_OWVAR 2
98790: PUSH
98791: EMPTY
98792: LIST
98793: LIST
98794: PUSH
98795: LD_INT 32
98797: PUSH
98798: LD_INT 3
98800: PUSH
98801: EMPTY
98802: LIST
98803: LIST
98804: PUSH
98805: EMPTY
98806: LIST
98807: LIST
98808: PPUSH
98809: CALL_OW 69
98813: ST_TO_ADDR
// if not tmp then
98814: LD_VAR 0 2
98818: NOT
98819: IFFALSE 98823
// exit ;
98821: GO 98852
// for i in tmp do
98823: LD_ADDR_VAR 0 1
98827: PUSH
98828: LD_VAR 0 2
98832: PUSH
98833: FOR_IN
98834: IFFALSE 98850
// begin SetLives ( i , 0 ) ;
98836: LD_VAR 0 1
98840: PPUSH
98841: LD_INT 0
98843: PPUSH
98844: CALL_OW 234
// end ;
98848: GO 98833
98850: POP
98851: POP
// end ;
98852: PPOPN 2
98854: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
98855: LD_EXP 130
98859: PUSH
98860: LD_EXP 133
98864: AND
98865: IFFALSE 98958
98867: GO 98869
98869: DISABLE
98870: LD_INT 0
98872: PPUSH
// begin enable ;
98873: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
98874: LD_ADDR_VAR 0 1
98878: PUSH
98879: LD_INT 22
98881: PUSH
98882: LD_OWVAR 2
98886: PUSH
98887: EMPTY
98888: LIST
98889: LIST
98890: PUSH
98891: LD_INT 2
98893: PUSH
98894: LD_INT 25
98896: PUSH
98897: LD_INT 5
98899: PUSH
98900: EMPTY
98901: LIST
98902: LIST
98903: PUSH
98904: LD_INT 25
98906: PUSH
98907: LD_INT 9
98909: PUSH
98910: EMPTY
98911: LIST
98912: LIST
98913: PUSH
98914: LD_INT 25
98916: PUSH
98917: LD_INT 8
98919: PUSH
98920: EMPTY
98921: LIST
98922: LIST
98923: PUSH
98924: EMPTY
98925: LIST
98926: LIST
98927: LIST
98928: LIST
98929: PUSH
98930: EMPTY
98931: LIST
98932: LIST
98933: PPUSH
98934: CALL_OW 69
98938: PUSH
98939: FOR_IN
98940: IFFALSE 98956
// begin SetClass ( i , 1 ) ;
98942: LD_VAR 0 1
98946: PPUSH
98947: LD_INT 1
98949: PPUSH
98950: CALL_OW 336
// end ;
98954: GO 98939
98956: POP
98957: POP
// end ;
98958: PPOPN 1
98960: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
98961: LD_EXP 130
98965: PUSH
98966: LD_EXP 134
98970: AND
98971: PUSH
98972: LD_OWVAR 65
98976: PUSH
98977: LD_INT 7
98979: LESS
98980: AND
98981: IFFALSE 98995
98983: GO 98985
98985: DISABLE
// begin enable ;
98986: ENABLE
// game_speed := 7 ;
98987: LD_ADDR_OWVAR 65
98991: PUSH
98992: LD_INT 7
98994: ST_TO_ADDR
// end ;
98995: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
98996: LD_EXP 130
99000: PUSH
99001: LD_EXP 137
99005: AND
99006: IFFALSE 99208
99008: GO 99010
99010: DISABLE
99011: LD_INT 0
99013: PPUSH
99014: PPUSH
99015: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
99016: LD_ADDR_VAR 0 3
99020: PUSH
99021: LD_INT 81
99023: PUSH
99024: LD_OWVAR 2
99028: PUSH
99029: EMPTY
99030: LIST
99031: LIST
99032: PUSH
99033: LD_INT 21
99035: PUSH
99036: LD_INT 1
99038: PUSH
99039: EMPTY
99040: LIST
99041: LIST
99042: PUSH
99043: EMPTY
99044: LIST
99045: LIST
99046: PPUSH
99047: CALL_OW 69
99051: ST_TO_ADDR
// if not tmp then
99052: LD_VAR 0 3
99056: NOT
99057: IFFALSE 99061
// exit ;
99059: GO 99208
// if tmp > 5 then
99061: LD_VAR 0 3
99065: PUSH
99066: LD_INT 5
99068: GREATER
99069: IFFALSE 99081
// k := 5 else
99071: LD_ADDR_VAR 0 2
99075: PUSH
99076: LD_INT 5
99078: ST_TO_ADDR
99079: GO 99091
// k := tmp ;
99081: LD_ADDR_VAR 0 2
99085: PUSH
99086: LD_VAR 0 3
99090: ST_TO_ADDR
// for i := 1 to k do
99091: LD_ADDR_VAR 0 1
99095: PUSH
99096: DOUBLE
99097: LD_INT 1
99099: DEC
99100: ST_TO_ADDR
99101: LD_VAR 0 2
99105: PUSH
99106: FOR_TO
99107: IFFALSE 99206
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
99109: LD_VAR 0 3
99113: PUSH
99114: LD_VAR 0 1
99118: ARRAY
99119: PPUSH
99120: LD_VAR 0 1
99124: PUSH
99125: LD_INT 4
99127: MOD
99128: PUSH
99129: LD_INT 1
99131: PLUS
99132: PPUSH
99133: CALL_OW 259
99137: PUSH
99138: LD_INT 10
99140: LESS
99141: IFFALSE 99204
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
99143: LD_VAR 0 3
99147: PUSH
99148: LD_VAR 0 1
99152: ARRAY
99153: PPUSH
99154: LD_VAR 0 1
99158: PUSH
99159: LD_INT 4
99161: MOD
99162: PUSH
99163: LD_INT 1
99165: PLUS
99166: PPUSH
99167: LD_VAR 0 3
99171: PUSH
99172: LD_VAR 0 1
99176: ARRAY
99177: PPUSH
99178: LD_VAR 0 1
99182: PUSH
99183: LD_INT 4
99185: MOD
99186: PUSH
99187: LD_INT 1
99189: PLUS
99190: PPUSH
99191: CALL_OW 259
99195: PUSH
99196: LD_INT 1
99198: PLUS
99199: PPUSH
99200: CALL_OW 237
99204: GO 99106
99206: POP
99207: POP
// end ;
99208: PPOPN 3
99210: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
99211: LD_EXP 130
99215: PUSH
99216: LD_EXP 138
99220: AND
99221: IFFALSE 99241
99223: GO 99225
99225: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
99226: LD_INT 4
99228: PPUSH
99229: LD_OWVAR 2
99233: PPUSH
99234: LD_INT 0
99236: PPUSH
99237: CALL_OW 324
99241: END
// every 0 0$1 trigger StreamModeActive and sShovel do
99242: LD_EXP 130
99246: PUSH
99247: LD_EXP 167
99251: AND
99252: IFFALSE 99272
99254: GO 99256
99256: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
99257: LD_INT 19
99259: PPUSH
99260: LD_OWVAR 2
99264: PPUSH
99265: LD_INT 0
99267: PPUSH
99268: CALL_OW 324
99272: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
99273: LD_EXP 130
99277: PUSH
99278: LD_EXP 139
99282: AND
99283: IFFALSE 99385
99285: GO 99287
99287: DISABLE
99288: LD_INT 0
99290: PPUSH
99291: PPUSH
// begin enable ;
99292: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
99293: LD_ADDR_VAR 0 2
99297: PUSH
99298: LD_INT 22
99300: PUSH
99301: LD_OWVAR 2
99305: PUSH
99306: EMPTY
99307: LIST
99308: LIST
99309: PUSH
99310: LD_INT 2
99312: PUSH
99313: LD_INT 34
99315: PUSH
99316: LD_INT 11
99318: PUSH
99319: EMPTY
99320: LIST
99321: LIST
99322: PUSH
99323: LD_INT 34
99325: PUSH
99326: LD_INT 30
99328: PUSH
99329: EMPTY
99330: LIST
99331: LIST
99332: PUSH
99333: EMPTY
99334: LIST
99335: LIST
99336: LIST
99337: PUSH
99338: EMPTY
99339: LIST
99340: LIST
99341: PPUSH
99342: CALL_OW 69
99346: ST_TO_ADDR
// if not tmp then
99347: LD_VAR 0 2
99351: NOT
99352: IFFALSE 99356
// exit ;
99354: GO 99385
// for i in tmp do
99356: LD_ADDR_VAR 0 1
99360: PUSH
99361: LD_VAR 0 2
99365: PUSH
99366: FOR_IN
99367: IFFALSE 99383
// begin SetLives ( i , 0 ) ;
99369: LD_VAR 0 1
99373: PPUSH
99374: LD_INT 0
99376: PPUSH
99377: CALL_OW 234
// end ;
99381: GO 99366
99383: POP
99384: POP
// end ;
99385: PPOPN 2
99387: END
// every 0 0$1 trigger StreamModeActive and sBunker do
99388: LD_EXP 130
99392: PUSH
99393: LD_EXP 140
99397: AND
99398: IFFALSE 99418
99400: GO 99402
99402: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
99403: LD_INT 32
99405: PPUSH
99406: LD_OWVAR 2
99410: PPUSH
99411: LD_INT 0
99413: PPUSH
99414: CALL_OW 324
99418: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
99419: LD_EXP 130
99423: PUSH
99424: LD_EXP 141
99428: AND
99429: IFFALSE 99610
99431: GO 99433
99433: DISABLE
99434: LD_INT 0
99436: PPUSH
99437: PPUSH
99438: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
99439: LD_ADDR_VAR 0 2
99443: PUSH
99444: LD_INT 22
99446: PUSH
99447: LD_OWVAR 2
99451: PUSH
99452: EMPTY
99453: LIST
99454: LIST
99455: PUSH
99456: LD_INT 33
99458: PUSH
99459: LD_INT 3
99461: PUSH
99462: EMPTY
99463: LIST
99464: LIST
99465: PUSH
99466: EMPTY
99467: LIST
99468: LIST
99469: PPUSH
99470: CALL_OW 69
99474: ST_TO_ADDR
// if not tmp then
99475: LD_VAR 0 2
99479: NOT
99480: IFFALSE 99484
// exit ;
99482: GO 99610
// side := 0 ;
99484: LD_ADDR_VAR 0 3
99488: PUSH
99489: LD_INT 0
99491: ST_TO_ADDR
// for i := 1 to 8 do
99492: LD_ADDR_VAR 0 1
99496: PUSH
99497: DOUBLE
99498: LD_INT 1
99500: DEC
99501: ST_TO_ADDR
99502: LD_INT 8
99504: PUSH
99505: FOR_TO
99506: IFFALSE 99554
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
99508: LD_OWVAR 2
99512: PUSH
99513: LD_VAR 0 1
99517: NONEQUAL
99518: PUSH
99519: LD_OWVAR 2
99523: PPUSH
99524: LD_VAR 0 1
99528: PPUSH
99529: CALL_OW 81
99533: PUSH
99534: LD_INT 2
99536: EQUAL
99537: AND
99538: IFFALSE 99552
// begin side := i ;
99540: LD_ADDR_VAR 0 3
99544: PUSH
99545: LD_VAR 0 1
99549: ST_TO_ADDR
// break ;
99550: GO 99554
// end ;
99552: GO 99505
99554: POP
99555: POP
// if not side then
99556: LD_VAR 0 3
99560: NOT
99561: IFFALSE 99565
// exit ;
99563: GO 99610
// for i := 1 to tmp do
99565: LD_ADDR_VAR 0 1
99569: PUSH
99570: DOUBLE
99571: LD_INT 1
99573: DEC
99574: ST_TO_ADDR
99575: LD_VAR 0 2
99579: PUSH
99580: FOR_TO
99581: IFFALSE 99608
// if Prob ( 60 ) then
99583: LD_INT 60
99585: PPUSH
99586: CALL_OW 13
99590: IFFALSE 99606
// SetSide ( i , side ) ;
99592: LD_VAR 0 1
99596: PPUSH
99597: LD_VAR 0 3
99601: PPUSH
99602: CALL_OW 235
99606: GO 99580
99608: POP
99609: POP
// end ;
99610: PPOPN 3
99612: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
99613: LD_EXP 130
99617: PUSH
99618: LD_EXP 143
99622: AND
99623: IFFALSE 99742
99625: GO 99627
99627: DISABLE
99628: LD_INT 0
99630: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
99631: LD_ADDR_VAR 0 1
99635: PUSH
99636: LD_INT 22
99638: PUSH
99639: LD_OWVAR 2
99643: PUSH
99644: EMPTY
99645: LIST
99646: LIST
99647: PUSH
99648: LD_INT 21
99650: PUSH
99651: LD_INT 1
99653: PUSH
99654: EMPTY
99655: LIST
99656: LIST
99657: PUSH
99658: LD_INT 3
99660: PUSH
99661: LD_INT 23
99663: PUSH
99664: LD_INT 0
99666: PUSH
99667: EMPTY
99668: LIST
99669: LIST
99670: PUSH
99671: EMPTY
99672: LIST
99673: LIST
99674: PUSH
99675: EMPTY
99676: LIST
99677: LIST
99678: LIST
99679: PPUSH
99680: CALL_OW 69
99684: PUSH
99685: FOR_IN
99686: IFFALSE 99740
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
99688: LD_VAR 0 1
99692: PPUSH
99693: CALL_OW 257
99697: PUSH
99698: LD_INT 1
99700: PUSH
99701: LD_INT 2
99703: PUSH
99704: LD_INT 3
99706: PUSH
99707: LD_INT 4
99709: PUSH
99710: EMPTY
99711: LIST
99712: LIST
99713: LIST
99714: LIST
99715: IN
99716: IFFALSE 99738
// SetClass ( un , rand ( 1 , 4 ) ) ;
99718: LD_VAR 0 1
99722: PPUSH
99723: LD_INT 1
99725: PPUSH
99726: LD_INT 4
99728: PPUSH
99729: CALL_OW 12
99733: PPUSH
99734: CALL_OW 336
99738: GO 99685
99740: POP
99741: POP
// end ;
99742: PPOPN 1
99744: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
99745: LD_EXP 130
99749: PUSH
99750: LD_EXP 142
99754: AND
99755: IFFALSE 99834
99757: GO 99759
99759: DISABLE
99760: LD_INT 0
99762: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
99763: LD_ADDR_VAR 0 1
99767: PUSH
99768: LD_INT 22
99770: PUSH
99771: LD_OWVAR 2
99775: PUSH
99776: EMPTY
99777: LIST
99778: LIST
99779: PUSH
99780: LD_INT 21
99782: PUSH
99783: LD_INT 3
99785: PUSH
99786: EMPTY
99787: LIST
99788: LIST
99789: PUSH
99790: EMPTY
99791: LIST
99792: LIST
99793: PPUSH
99794: CALL_OW 69
99798: ST_TO_ADDR
// if not tmp then
99799: LD_VAR 0 1
99803: NOT
99804: IFFALSE 99808
// exit ;
99806: GO 99834
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
99808: LD_VAR 0 1
99812: PUSH
99813: LD_INT 1
99815: PPUSH
99816: LD_VAR 0 1
99820: PPUSH
99821: CALL_OW 12
99825: ARRAY
99826: PPUSH
99827: LD_INT 100
99829: PPUSH
99830: CALL_OW 234
// end ;
99834: PPOPN 1
99836: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
99837: LD_EXP 130
99841: PUSH
99842: LD_EXP 144
99846: AND
99847: IFFALSE 99945
99849: GO 99851
99851: DISABLE
99852: LD_INT 0
99854: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99855: LD_ADDR_VAR 0 1
99859: PUSH
99860: LD_INT 22
99862: PUSH
99863: LD_OWVAR 2
99867: PUSH
99868: EMPTY
99869: LIST
99870: LIST
99871: PUSH
99872: LD_INT 21
99874: PUSH
99875: LD_INT 1
99877: PUSH
99878: EMPTY
99879: LIST
99880: LIST
99881: PUSH
99882: EMPTY
99883: LIST
99884: LIST
99885: PPUSH
99886: CALL_OW 69
99890: ST_TO_ADDR
// if not tmp then
99891: LD_VAR 0 1
99895: NOT
99896: IFFALSE 99900
// exit ;
99898: GO 99945
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
99900: LD_VAR 0 1
99904: PUSH
99905: LD_INT 1
99907: PPUSH
99908: LD_VAR 0 1
99912: PPUSH
99913: CALL_OW 12
99917: ARRAY
99918: PPUSH
99919: LD_INT 1
99921: PPUSH
99922: LD_INT 4
99924: PPUSH
99925: CALL_OW 12
99929: PPUSH
99930: LD_INT 3000
99932: PPUSH
99933: LD_INT 9000
99935: PPUSH
99936: CALL_OW 12
99940: PPUSH
99941: CALL_OW 492
// end ;
99945: PPOPN 1
99947: END
// every 0 0$1 trigger StreamModeActive and sDepot do
99948: LD_EXP 130
99952: PUSH
99953: LD_EXP 145
99957: AND
99958: IFFALSE 99978
99960: GO 99962
99962: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
99963: LD_INT 1
99965: PPUSH
99966: LD_OWVAR 2
99970: PPUSH
99971: LD_INT 0
99973: PPUSH
99974: CALL_OW 324
99978: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
99979: LD_EXP 130
99983: PUSH
99984: LD_EXP 146
99988: AND
99989: IFFALSE 100072
99991: GO 99993
99993: DISABLE
99994: LD_INT 0
99996: PPUSH
99997: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
99998: LD_ADDR_VAR 0 2
100002: PUSH
100003: LD_INT 22
100005: PUSH
100006: LD_OWVAR 2
100010: PUSH
100011: EMPTY
100012: LIST
100013: LIST
100014: PUSH
100015: LD_INT 21
100017: PUSH
100018: LD_INT 3
100020: PUSH
100021: EMPTY
100022: LIST
100023: LIST
100024: PUSH
100025: EMPTY
100026: LIST
100027: LIST
100028: PPUSH
100029: CALL_OW 69
100033: ST_TO_ADDR
// if not tmp then
100034: LD_VAR 0 2
100038: NOT
100039: IFFALSE 100043
// exit ;
100041: GO 100072
// for i in tmp do
100043: LD_ADDR_VAR 0 1
100047: PUSH
100048: LD_VAR 0 2
100052: PUSH
100053: FOR_IN
100054: IFFALSE 100070
// SetBLevel ( i , 10 ) ;
100056: LD_VAR 0 1
100060: PPUSH
100061: LD_INT 10
100063: PPUSH
100064: CALL_OW 241
100068: GO 100053
100070: POP
100071: POP
// end ;
100072: PPOPN 2
100074: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
100075: LD_EXP 130
100079: PUSH
100080: LD_EXP 147
100084: AND
100085: IFFALSE 100196
100087: GO 100089
100089: DISABLE
100090: LD_INT 0
100092: PPUSH
100093: PPUSH
100094: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100095: LD_ADDR_VAR 0 3
100099: PUSH
100100: LD_INT 22
100102: PUSH
100103: LD_OWVAR 2
100107: PUSH
100108: EMPTY
100109: LIST
100110: LIST
100111: PUSH
100112: LD_INT 25
100114: PUSH
100115: LD_INT 1
100117: PUSH
100118: EMPTY
100119: LIST
100120: LIST
100121: PUSH
100122: EMPTY
100123: LIST
100124: LIST
100125: PPUSH
100126: CALL_OW 69
100130: ST_TO_ADDR
// if not tmp then
100131: LD_VAR 0 3
100135: NOT
100136: IFFALSE 100140
// exit ;
100138: GO 100196
// un := tmp [ rand ( 1 , tmp ) ] ;
100140: LD_ADDR_VAR 0 2
100144: PUSH
100145: LD_VAR 0 3
100149: PUSH
100150: LD_INT 1
100152: PPUSH
100153: LD_VAR 0 3
100157: PPUSH
100158: CALL_OW 12
100162: ARRAY
100163: ST_TO_ADDR
// if Crawls ( un ) then
100164: LD_VAR 0 2
100168: PPUSH
100169: CALL_OW 318
100173: IFFALSE 100184
// ComWalk ( un ) ;
100175: LD_VAR 0 2
100179: PPUSH
100180: CALL_OW 138
// SetClass ( un , class_sniper ) ;
100184: LD_VAR 0 2
100188: PPUSH
100189: LD_INT 5
100191: PPUSH
100192: CALL_OW 336
// end ;
100196: PPOPN 3
100198: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
100199: LD_EXP 130
100203: PUSH
100204: LD_EXP 148
100208: AND
100209: PUSH
100210: LD_OWVAR 67
100214: PUSH
100215: LD_INT 3
100217: LESS
100218: AND
100219: IFFALSE 100238
100221: GO 100223
100223: DISABLE
// Difficulty := Difficulty + 1 ;
100224: LD_ADDR_OWVAR 67
100228: PUSH
100229: LD_OWVAR 67
100233: PUSH
100234: LD_INT 1
100236: PLUS
100237: ST_TO_ADDR
100238: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
100239: LD_EXP 130
100243: PUSH
100244: LD_EXP 149
100248: AND
100249: IFFALSE 100352
100251: GO 100253
100253: DISABLE
100254: LD_INT 0
100256: PPUSH
// begin for i := 1 to 5 do
100257: LD_ADDR_VAR 0 1
100261: PUSH
100262: DOUBLE
100263: LD_INT 1
100265: DEC
100266: ST_TO_ADDR
100267: LD_INT 5
100269: PUSH
100270: FOR_TO
100271: IFFALSE 100350
// begin uc_nation := nation_nature ;
100273: LD_ADDR_OWVAR 21
100277: PUSH
100278: LD_INT 0
100280: ST_TO_ADDR
// uc_side := 0 ;
100281: LD_ADDR_OWVAR 20
100285: PUSH
100286: LD_INT 0
100288: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
100289: LD_ADDR_OWVAR 29
100293: PUSH
100294: LD_INT 12
100296: PUSH
100297: LD_INT 12
100299: PUSH
100300: EMPTY
100301: LIST
100302: LIST
100303: ST_TO_ADDR
// hc_agressivity := 20 ;
100304: LD_ADDR_OWVAR 35
100308: PUSH
100309: LD_INT 20
100311: ST_TO_ADDR
// hc_class := class_tiger ;
100312: LD_ADDR_OWVAR 28
100316: PUSH
100317: LD_INT 14
100319: ST_TO_ADDR
// hc_gallery :=  ;
100320: LD_ADDR_OWVAR 33
100324: PUSH
100325: LD_STRING 
100327: ST_TO_ADDR
// hc_name :=  ;
100328: LD_ADDR_OWVAR 26
100332: PUSH
100333: LD_STRING 
100335: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
100336: CALL_OW 44
100340: PPUSH
100341: LD_INT 0
100343: PPUSH
100344: CALL_OW 51
// end ;
100348: GO 100270
100350: POP
100351: POP
// end ;
100352: PPOPN 1
100354: END
// every 0 0$1 trigger StreamModeActive and sBomb do
100355: LD_EXP 130
100359: PUSH
100360: LD_EXP 150
100364: AND
100365: IFFALSE 100374
100367: GO 100369
100369: DISABLE
// StreamSibBomb ;
100370: CALL 100375 0 0
100374: END
// export function StreamSibBomb ; var i , x , y ; begin
100375: LD_INT 0
100377: PPUSH
100378: PPUSH
100379: PPUSH
100380: PPUSH
// result := false ;
100381: LD_ADDR_VAR 0 1
100385: PUSH
100386: LD_INT 0
100388: ST_TO_ADDR
// for i := 1 to 16 do
100389: LD_ADDR_VAR 0 2
100393: PUSH
100394: DOUBLE
100395: LD_INT 1
100397: DEC
100398: ST_TO_ADDR
100399: LD_INT 16
100401: PUSH
100402: FOR_TO
100403: IFFALSE 100602
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
100405: LD_ADDR_VAR 0 3
100409: PUSH
100410: LD_INT 10
100412: PUSH
100413: LD_INT 20
100415: PUSH
100416: LD_INT 30
100418: PUSH
100419: LD_INT 40
100421: PUSH
100422: LD_INT 50
100424: PUSH
100425: LD_INT 60
100427: PUSH
100428: LD_INT 70
100430: PUSH
100431: LD_INT 80
100433: PUSH
100434: LD_INT 90
100436: PUSH
100437: LD_INT 100
100439: PUSH
100440: LD_INT 110
100442: PUSH
100443: LD_INT 120
100445: PUSH
100446: LD_INT 130
100448: PUSH
100449: LD_INT 140
100451: PUSH
100452: LD_INT 150
100454: PUSH
100455: EMPTY
100456: LIST
100457: LIST
100458: LIST
100459: LIST
100460: LIST
100461: LIST
100462: LIST
100463: LIST
100464: LIST
100465: LIST
100466: LIST
100467: LIST
100468: LIST
100469: LIST
100470: LIST
100471: PUSH
100472: LD_INT 1
100474: PPUSH
100475: LD_INT 15
100477: PPUSH
100478: CALL_OW 12
100482: ARRAY
100483: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
100484: LD_ADDR_VAR 0 4
100488: PUSH
100489: LD_INT 10
100491: PUSH
100492: LD_INT 20
100494: PUSH
100495: LD_INT 30
100497: PUSH
100498: LD_INT 40
100500: PUSH
100501: LD_INT 50
100503: PUSH
100504: LD_INT 60
100506: PUSH
100507: LD_INT 70
100509: PUSH
100510: LD_INT 80
100512: PUSH
100513: LD_INT 90
100515: PUSH
100516: LD_INT 100
100518: PUSH
100519: LD_INT 110
100521: PUSH
100522: LD_INT 120
100524: PUSH
100525: LD_INT 130
100527: PUSH
100528: LD_INT 140
100530: PUSH
100531: LD_INT 150
100533: PUSH
100534: EMPTY
100535: LIST
100536: LIST
100537: LIST
100538: LIST
100539: LIST
100540: LIST
100541: LIST
100542: LIST
100543: LIST
100544: LIST
100545: LIST
100546: LIST
100547: LIST
100548: LIST
100549: LIST
100550: PUSH
100551: LD_INT 1
100553: PPUSH
100554: LD_INT 15
100556: PPUSH
100557: CALL_OW 12
100561: ARRAY
100562: ST_TO_ADDR
// if ValidHex ( x , y ) then
100563: LD_VAR 0 3
100567: PPUSH
100568: LD_VAR 0 4
100572: PPUSH
100573: CALL_OW 488
100577: IFFALSE 100600
// begin result := [ x , y ] ;
100579: LD_ADDR_VAR 0 1
100583: PUSH
100584: LD_VAR 0 3
100588: PUSH
100589: LD_VAR 0 4
100593: PUSH
100594: EMPTY
100595: LIST
100596: LIST
100597: ST_TO_ADDR
// break ;
100598: GO 100602
// end ; end ;
100600: GO 100402
100602: POP
100603: POP
// if result then
100604: LD_VAR 0 1
100608: IFFALSE 100668
// begin ToLua ( playSibBomb() ) ;
100610: LD_STRING playSibBomb()
100612: PPUSH
100613: CALL_OW 559
// wait ( 0 0$14 ) ;
100617: LD_INT 490
100619: PPUSH
100620: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
100624: LD_VAR 0 1
100628: PUSH
100629: LD_INT 1
100631: ARRAY
100632: PPUSH
100633: LD_VAR 0 1
100637: PUSH
100638: LD_INT 2
100640: ARRAY
100641: PPUSH
100642: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
100646: LD_VAR 0 1
100650: PUSH
100651: LD_INT 1
100653: ARRAY
100654: PPUSH
100655: LD_VAR 0 1
100659: PUSH
100660: LD_INT 2
100662: ARRAY
100663: PPUSH
100664: CALL_OW 429
// end ; end ;
100668: LD_VAR 0 1
100672: RET
// every 0 0$1 trigger StreamModeActive and sReset do
100673: LD_EXP 130
100677: PUSH
100678: LD_EXP 152
100682: AND
100683: IFFALSE 100695
100685: GO 100687
100687: DISABLE
// YouLost (  ) ;
100688: LD_STRING 
100690: PPUSH
100691: CALL_OW 104
100695: END
// every 0 0$1 trigger StreamModeActive and sFog do
100696: LD_EXP 130
100700: PUSH
100701: LD_EXP 151
100705: AND
100706: IFFALSE 100720
100708: GO 100710
100710: DISABLE
// FogOff ( your_side ) ;
100711: LD_OWVAR 2
100715: PPUSH
100716: CALL_OW 344
100720: END
// every 0 0$1 trigger StreamModeActive and sSun do
100721: LD_EXP 130
100725: PUSH
100726: LD_EXP 153
100730: AND
100731: IFFALSE 100759
100733: GO 100735
100735: DISABLE
// begin solar_recharge_percent := 0 ;
100736: LD_ADDR_OWVAR 79
100740: PUSH
100741: LD_INT 0
100743: ST_TO_ADDR
// wait ( 5 5$00 ) ;
100744: LD_INT 10500
100746: PPUSH
100747: CALL_OW 67
// solar_recharge_percent := 100 ;
100751: LD_ADDR_OWVAR 79
100755: PUSH
100756: LD_INT 100
100758: ST_TO_ADDR
// end ;
100759: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
100760: LD_EXP 130
100764: PUSH
100765: LD_EXP 154
100769: AND
100770: IFFALSE 101009
100772: GO 100774
100774: DISABLE
100775: LD_INT 0
100777: PPUSH
100778: PPUSH
100779: PPUSH
// begin tmp := [ ] ;
100780: LD_ADDR_VAR 0 3
100784: PUSH
100785: EMPTY
100786: ST_TO_ADDR
// for i := 1 to 6 do
100787: LD_ADDR_VAR 0 1
100791: PUSH
100792: DOUBLE
100793: LD_INT 1
100795: DEC
100796: ST_TO_ADDR
100797: LD_INT 6
100799: PUSH
100800: FOR_TO
100801: IFFALSE 100906
// begin uc_nation := nation_nature ;
100803: LD_ADDR_OWVAR 21
100807: PUSH
100808: LD_INT 0
100810: ST_TO_ADDR
// uc_side := 0 ;
100811: LD_ADDR_OWVAR 20
100815: PUSH
100816: LD_INT 0
100818: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
100819: LD_ADDR_OWVAR 29
100823: PUSH
100824: LD_INT 12
100826: PUSH
100827: LD_INT 12
100829: PUSH
100830: EMPTY
100831: LIST
100832: LIST
100833: ST_TO_ADDR
// hc_agressivity := 20 ;
100834: LD_ADDR_OWVAR 35
100838: PUSH
100839: LD_INT 20
100841: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
100842: LD_ADDR_OWVAR 28
100846: PUSH
100847: LD_INT 17
100849: ST_TO_ADDR
// hc_gallery :=  ;
100850: LD_ADDR_OWVAR 33
100854: PUSH
100855: LD_STRING 
100857: ST_TO_ADDR
// hc_name :=  ;
100858: LD_ADDR_OWVAR 26
100862: PUSH
100863: LD_STRING 
100865: ST_TO_ADDR
// un := CreateHuman ;
100866: LD_ADDR_VAR 0 2
100870: PUSH
100871: CALL_OW 44
100875: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
100876: LD_VAR 0 2
100880: PPUSH
100881: LD_INT 1
100883: PPUSH
100884: CALL_OW 51
// tmp := tmp ^ un ;
100888: LD_ADDR_VAR 0 3
100892: PUSH
100893: LD_VAR 0 3
100897: PUSH
100898: LD_VAR 0 2
100902: ADD
100903: ST_TO_ADDR
// end ;
100904: GO 100800
100906: POP
100907: POP
// repeat wait ( 0 0$1 ) ;
100908: LD_INT 35
100910: PPUSH
100911: CALL_OW 67
// for un in tmp do
100915: LD_ADDR_VAR 0 2
100919: PUSH
100920: LD_VAR 0 3
100924: PUSH
100925: FOR_IN
100926: IFFALSE 101000
// begin if IsDead ( un ) then
100928: LD_VAR 0 2
100932: PPUSH
100933: CALL_OW 301
100937: IFFALSE 100957
// begin tmp := tmp diff un ;
100939: LD_ADDR_VAR 0 3
100943: PUSH
100944: LD_VAR 0 3
100948: PUSH
100949: LD_VAR 0 2
100953: DIFF
100954: ST_TO_ADDR
// continue ;
100955: GO 100925
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
100957: LD_VAR 0 2
100961: PPUSH
100962: LD_INT 3
100964: PUSH
100965: LD_INT 22
100967: PUSH
100968: LD_INT 0
100970: PUSH
100971: EMPTY
100972: LIST
100973: LIST
100974: PUSH
100975: EMPTY
100976: LIST
100977: LIST
100978: PPUSH
100979: CALL_OW 69
100983: PPUSH
100984: LD_VAR 0 2
100988: PPUSH
100989: CALL_OW 74
100993: PPUSH
100994: CALL_OW 115
// end ;
100998: GO 100925
101000: POP
101001: POP
// until not tmp ;
101002: LD_VAR 0 3
101006: NOT
101007: IFFALSE 100908
// end ;
101009: PPOPN 3
101011: END
// every 0 0$1 trigger StreamModeActive and sTroll do
101012: LD_EXP 130
101016: PUSH
101017: LD_EXP 155
101021: AND
101022: IFFALSE 101076
101024: GO 101026
101026: DISABLE
// begin ToLua ( displayTroll(); ) ;
101027: LD_STRING displayTroll();
101029: PPUSH
101030: CALL_OW 559
// wait ( 3 3$00 ) ;
101034: LD_INT 6300
101036: PPUSH
101037: CALL_OW 67
// ToLua ( hideTroll(); ) ;
101041: LD_STRING hideTroll();
101043: PPUSH
101044: CALL_OW 559
// wait ( 1 1$00 ) ;
101048: LD_INT 2100
101050: PPUSH
101051: CALL_OW 67
// ToLua ( displayTroll(); ) ;
101055: LD_STRING displayTroll();
101057: PPUSH
101058: CALL_OW 559
// wait ( 1 1$00 ) ;
101062: LD_INT 2100
101064: PPUSH
101065: CALL_OW 67
// ToLua ( hideTroll(); ) ;
101069: LD_STRING hideTroll();
101071: PPUSH
101072: CALL_OW 559
// end ;
101076: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
101077: LD_EXP 130
101081: PUSH
101082: LD_EXP 156
101086: AND
101087: IFFALSE 101150
101089: GO 101091
101091: DISABLE
101092: LD_INT 0
101094: PPUSH
// begin p := 0 ;
101095: LD_ADDR_VAR 0 1
101099: PUSH
101100: LD_INT 0
101102: ST_TO_ADDR
// repeat game_speed := 1 ;
101103: LD_ADDR_OWVAR 65
101107: PUSH
101108: LD_INT 1
101110: ST_TO_ADDR
// wait ( 0 0$1 ) ;
101111: LD_INT 35
101113: PPUSH
101114: CALL_OW 67
// p := p + 1 ;
101118: LD_ADDR_VAR 0 1
101122: PUSH
101123: LD_VAR 0 1
101127: PUSH
101128: LD_INT 1
101130: PLUS
101131: ST_TO_ADDR
// until p >= 60 ;
101132: LD_VAR 0 1
101136: PUSH
101137: LD_INT 60
101139: GREATEREQUAL
101140: IFFALSE 101103
// game_speed := 4 ;
101142: LD_ADDR_OWVAR 65
101146: PUSH
101147: LD_INT 4
101149: ST_TO_ADDR
// end ;
101150: PPOPN 1
101152: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
101153: LD_EXP 130
101157: PUSH
101158: LD_EXP 157
101162: AND
101163: IFFALSE 101309
101165: GO 101167
101167: DISABLE
101168: LD_INT 0
101170: PPUSH
101171: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
101172: LD_ADDR_VAR 0 1
101176: PUSH
101177: LD_INT 22
101179: PUSH
101180: LD_OWVAR 2
101184: PUSH
101185: EMPTY
101186: LIST
101187: LIST
101188: PUSH
101189: LD_INT 2
101191: PUSH
101192: LD_INT 30
101194: PUSH
101195: LD_INT 0
101197: PUSH
101198: EMPTY
101199: LIST
101200: LIST
101201: PUSH
101202: LD_INT 30
101204: PUSH
101205: LD_INT 1
101207: PUSH
101208: EMPTY
101209: LIST
101210: LIST
101211: PUSH
101212: EMPTY
101213: LIST
101214: LIST
101215: LIST
101216: PUSH
101217: EMPTY
101218: LIST
101219: LIST
101220: PPUSH
101221: CALL_OW 69
101225: ST_TO_ADDR
// if not depot then
101226: LD_VAR 0 1
101230: NOT
101231: IFFALSE 101235
// exit ;
101233: GO 101309
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
101235: LD_ADDR_VAR 0 2
101239: PUSH
101240: LD_VAR 0 1
101244: PUSH
101245: LD_INT 1
101247: PPUSH
101248: LD_VAR 0 1
101252: PPUSH
101253: CALL_OW 12
101257: ARRAY
101258: PPUSH
101259: CALL_OW 274
101263: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
101264: LD_VAR 0 2
101268: PPUSH
101269: LD_INT 1
101271: PPUSH
101272: LD_INT 0
101274: PPUSH
101275: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
101279: LD_VAR 0 2
101283: PPUSH
101284: LD_INT 2
101286: PPUSH
101287: LD_INT 0
101289: PPUSH
101290: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
101294: LD_VAR 0 2
101298: PPUSH
101299: LD_INT 3
101301: PPUSH
101302: LD_INT 0
101304: PPUSH
101305: CALL_OW 277
// end ;
101309: PPOPN 2
101311: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
101312: LD_EXP 130
101316: PUSH
101317: LD_EXP 158
101321: AND
101322: IFFALSE 101419
101324: GO 101326
101326: DISABLE
101327: LD_INT 0
101329: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
101330: LD_ADDR_VAR 0 1
101334: PUSH
101335: LD_INT 22
101337: PUSH
101338: LD_OWVAR 2
101342: PUSH
101343: EMPTY
101344: LIST
101345: LIST
101346: PUSH
101347: LD_INT 21
101349: PUSH
101350: LD_INT 1
101352: PUSH
101353: EMPTY
101354: LIST
101355: LIST
101356: PUSH
101357: LD_INT 3
101359: PUSH
101360: LD_INT 23
101362: PUSH
101363: LD_INT 0
101365: PUSH
101366: EMPTY
101367: LIST
101368: LIST
101369: PUSH
101370: EMPTY
101371: LIST
101372: LIST
101373: PUSH
101374: EMPTY
101375: LIST
101376: LIST
101377: LIST
101378: PPUSH
101379: CALL_OW 69
101383: ST_TO_ADDR
// if not tmp then
101384: LD_VAR 0 1
101388: NOT
101389: IFFALSE 101393
// exit ;
101391: GO 101419
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
101393: LD_VAR 0 1
101397: PUSH
101398: LD_INT 1
101400: PPUSH
101401: LD_VAR 0 1
101405: PPUSH
101406: CALL_OW 12
101410: ARRAY
101411: PPUSH
101412: LD_INT 200
101414: PPUSH
101415: CALL_OW 234
// end ;
101419: PPOPN 1
101421: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
101422: LD_EXP 130
101426: PUSH
101427: LD_EXP 159
101431: AND
101432: IFFALSE 101511
101434: GO 101436
101436: DISABLE
101437: LD_INT 0
101439: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
101440: LD_ADDR_VAR 0 1
101444: PUSH
101445: LD_INT 22
101447: PUSH
101448: LD_OWVAR 2
101452: PUSH
101453: EMPTY
101454: LIST
101455: LIST
101456: PUSH
101457: LD_INT 21
101459: PUSH
101460: LD_INT 2
101462: PUSH
101463: EMPTY
101464: LIST
101465: LIST
101466: PUSH
101467: EMPTY
101468: LIST
101469: LIST
101470: PPUSH
101471: CALL_OW 69
101475: ST_TO_ADDR
// if not tmp then
101476: LD_VAR 0 1
101480: NOT
101481: IFFALSE 101485
// exit ;
101483: GO 101511
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
101485: LD_VAR 0 1
101489: PUSH
101490: LD_INT 1
101492: PPUSH
101493: LD_VAR 0 1
101497: PPUSH
101498: CALL_OW 12
101502: ARRAY
101503: PPUSH
101504: LD_INT 60
101506: PPUSH
101507: CALL_OW 234
// end ;
101511: PPOPN 1
101513: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
101514: LD_EXP 130
101518: PUSH
101519: LD_EXP 160
101523: AND
101524: IFFALSE 101623
101526: GO 101528
101528: DISABLE
101529: LD_INT 0
101531: PPUSH
101532: PPUSH
// begin enable ;
101533: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
101534: LD_ADDR_VAR 0 1
101538: PUSH
101539: LD_INT 22
101541: PUSH
101542: LD_OWVAR 2
101546: PUSH
101547: EMPTY
101548: LIST
101549: LIST
101550: PUSH
101551: LD_INT 61
101553: PUSH
101554: EMPTY
101555: LIST
101556: PUSH
101557: LD_INT 33
101559: PUSH
101560: LD_INT 2
101562: PUSH
101563: EMPTY
101564: LIST
101565: LIST
101566: PUSH
101567: EMPTY
101568: LIST
101569: LIST
101570: LIST
101571: PPUSH
101572: CALL_OW 69
101576: ST_TO_ADDR
// if not tmp then
101577: LD_VAR 0 1
101581: NOT
101582: IFFALSE 101586
// exit ;
101584: GO 101623
// for i in tmp do
101586: LD_ADDR_VAR 0 2
101590: PUSH
101591: LD_VAR 0 1
101595: PUSH
101596: FOR_IN
101597: IFFALSE 101621
// if IsControledBy ( i ) then
101599: LD_VAR 0 2
101603: PPUSH
101604: CALL_OW 312
101608: IFFALSE 101619
// ComUnlink ( i ) ;
101610: LD_VAR 0 2
101614: PPUSH
101615: CALL_OW 136
101619: GO 101596
101621: POP
101622: POP
// end ;
101623: PPOPN 2
101625: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
101626: LD_EXP 130
101630: PUSH
101631: LD_EXP 161
101635: AND
101636: IFFALSE 101776
101638: GO 101640
101640: DISABLE
101641: LD_INT 0
101643: PPUSH
101644: PPUSH
// begin ToLua ( displayPowell(); ) ;
101645: LD_STRING displayPowell();
101647: PPUSH
101648: CALL_OW 559
// uc_side := 0 ;
101652: LD_ADDR_OWVAR 20
101656: PUSH
101657: LD_INT 0
101659: ST_TO_ADDR
// uc_nation := 2 ;
101660: LD_ADDR_OWVAR 21
101664: PUSH
101665: LD_INT 2
101667: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
101668: LD_ADDR_OWVAR 37
101672: PUSH
101673: LD_INT 14
101675: ST_TO_ADDR
// vc_engine := engine_siberite ;
101676: LD_ADDR_OWVAR 39
101680: PUSH
101681: LD_INT 3
101683: ST_TO_ADDR
// vc_control := control_apeman ;
101684: LD_ADDR_OWVAR 38
101688: PUSH
101689: LD_INT 5
101691: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
101692: LD_ADDR_OWVAR 40
101696: PUSH
101697: LD_INT 29
101699: ST_TO_ADDR
// un := CreateVehicle ;
101700: LD_ADDR_VAR 0 2
101704: PUSH
101705: CALL_OW 45
101709: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101710: LD_VAR 0 2
101714: PPUSH
101715: LD_INT 1
101717: PPUSH
101718: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
101722: LD_INT 35
101724: PPUSH
101725: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
101729: LD_VAR 0 2
101733: PPUSH
101734: LD_INT 22
101736: PUSH
101737: LD_OWVAR 2
101741: PUSH
101742: EMPTY
101743: LIST
101744: LIST
101745: PPUSH
101746: CALL_OW 69
101750: PPUSH
101751: LD_VAR 0 2
101755: PPUSH
101756: CALL_OW 74
101760: PPUSH
101761: CALL_OW 115
// until IsDead ( un ) ;
101765: LD_VAR 0 2
101769: PPUSH
101770: CALL_OW 301
101774: IFFALSE 101722
// end ;
101776: PPOPN 2
101778: END
// every 0 0$1 trigger StreamModeActive and sStu do
101779: LD_EXP 130
101783: PUSH
101784: LD_EXP 169
101788: AND
101789: IFFALSE 101805
101791: GO 101793
101793: DISABLE
// begin ToLua ( displayStucuk(); ) ;
101794: LD_STRING displayStucuk();
101796: PPUSH
101797: CALL_OW 559
// ResetFog ;
101801: CALL_OW 335
// end ;
101805: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
101806: LD_EXP 130
101810: PUSH
101811: LD_EXP 162
101815: AND
101816: IFFALSE 101957
101818: GO 101820
101820: DISABLE
101821: LD_INT 0
101823: PPUSH
101824: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101825: LD_ADDR_VAR 0 2
101829: PUSH
101830: LD_INT 22
101832: PUSH
101833: LD_OWVAR 2
101837: PUSH
101838: EMPTY
101839: LIST
101840: LIST
101841: PUSH
101842: LD_INT 21
101844: PUSH
101845: LD_INT 1
101847: PUSH
101848: EMPTY
101849: LIST
101850: LIST
101851: PUSH
101852: EMPTY
101853: LIST
101854: LIST
101855: PPUSH
101856: CALL_OW 69
101860: ST_TO_ADDR
// if not tmp then
101861: LD_VAR 0 2
101865: NOT
101866: IFFALSE 101870
// exit ;
101868: GO 101957
// un := tmp [ rand ( 1 , tmp ) ] ;
101870: LD_ADDR_VAR 0 1
101874: PUSH
101875: LD_VAR 0 2
101879: PUSH
101880: LD_INT 1
101882: PPUSH
101883: LD_VAR 0 2
101887: PPUSH
101888: CALL_OW 12
101892: ARRAY
101893: ST_TO_ADDR
// SetSide ( un , 0 ) ;
101894: LD_VAR 0 1
101898: PPUSH
101899: LD_INT 0
101901: PPUSH
101902: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
101906: LD_VAR 0 1
101910: PPUSH
101911: LD_OWVAR 3
101915: PUSH
101916: LD_VAR 0 1
101920: DIFF
101921: PPUSH
101922: LD_VAR 0 1
101926: PPUSH
101927: CALL_OW 74
101931: PPUSH
101932: CALL_OW 115
// wait ( 0 0$20 ) ;
101936: LD_INT 700
101938: PPUSH
101939: CALL_OW 67
// SetSide ( un , your_side ) ;
101943: LD_VAR 0 1
101947: PPUSH
101948: LD_OWVAR 2
101952: PPUSH
101953: CALL_OW 235
// end ;
101957: PPOPN 2
101959: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
101960: LD_EXP 130
101964: PUSH
101965: LD_EXP 163
101969: AND
101970: IFFALSE 102076
101972: GO 101974
101974: DISABLE
101975: LD_INT 0
101977: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
101978: LD_ADDR_VAR 0 1
101982: PUSH
101983: LD_INT 22
101985: PUSH
101986: LD_OWVAR 2
101990: PUSH
101991: EMPTY
101992: LIST
101993: LIST
101994: PUSH
101995: LD_INT 2
101997: PUSH
101998: LD_INT 30
102000: PUSH
102001: LD_INT 0
102003: PUSH
102004: EMPTY
102005: LIST
102006: LIST
102007: PUSH
102008: LD_INT 30
102010: PUSH
102011: LD_INT 1
102013: PUSH
102014: EMPTY
102015: LIST
102016: LIST
102017: PUSH
102018: EMPTY
102019: LIST
102020: LIST
102021: LIST
102022: PUSH
102023: EMPTY
102024: LIST
102025: LIST
102026: PPUSH
102027: CALL_OW 69
102031: ST_TO_ADDR
// if not depot then
102032: LD_VAR 0 1
102036: NOT
102037: IFFALSE 102041
// exit ;
102039: GO 102076
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
102041: LD_VAR 0 1
102045: PUSH
102046: LD_INT 1
102048: ARRAY
102049: PPUSH
102050: CALL_OW 250
102054: PPUSH
102055: LD_VAR 0 1
102059: PUSH
102060: LD_INT 1
102062: ARRAY
102063: PPUSH
102064: CALL_OW 251
102068: PPUSH
102069: LD_INT 70
102071: PPUSH
102072: CALL_OW 495
// end ;
102076: PPOPN 1
102078: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
102079: LD_EXP 130
102083: PUSH
102084: LD_EXP 164
102088: AND
102089: IFFALSE 102300
102091: GO 102093
102093: DISABLE
102094: LD_INT 0
102096: PPUSH
102097: PPUSH
102098: PPUSH
102099: PPUSH
102100: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
102101: LD_ADDR_VAR 0 5
102105: PUSH
102106: LD_INT 22
102108: PUSH
102109: LD_OWVAR 2
102113: PUSH
102114: EMPTY
102115: LIST
102116: LIST
102117: PUSH
102118: LD_INT 21
102120: PUSH
102121: LD_INT 1
102123: PUSH
102124: EMPTY
102125: LIST
102126: LIST
102127: PUSH
102128: EMPTY
102129: LIST
102130: LIST
102131: PPUSH
102132: CALL_OW 69
102136: ST_TO_ADDR
// if not tmp then
102137: LD_VAR 0 5
102141: NOT
102142: IFFALSE 102146
// exit ;
102144: GO 102300
// for i in tmp do
102146: LD_ADDR_VAR 0 1
102150: PUSH
102151: LD_VAR 0 5
102155: PUSH
102156: FOR_IN
102157: IFFALSE 102298
// begin d := rand ( 0 , 5 ) ;
102159: LD_ADDR_VAR 0 4
102163: PUSH
102164: LD_INT 0
102166: PPUSH
102167: LD_INT 5
102169: PPUSH
102170: CALL_OW 12
102174: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
102175: LD_ADDR_VAR 0 2
102179: PUSH
102180: LD_VAR 0 1
102184: PPUSH
102185: CALL_OW 250
102189: PPUSH
102190: LD_VAR 0 4
102194: PPUSH
102195: LD_INT 3
102197: PPUSH
102198: LD_INT 12
102200: PPUSH
102201: CALL_OW 12
102205: PPUSH
102206: CALL_OW 272
102210: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
102211: LD_ADDR_VAR 0 3
102215: PUSH
102216: LD_VAR 0 1
102220: PPUSH
102221: CALL_OW 251
102225: PPUSH
102226: LD_VAR 0 4
102230: PPUSH
102231: LD_INT 3
102233: PPUSH
102234: LD_INT 12
102236: PPUSH
102237: CALL_OW 12
102241: PPUSH
102242: CALL_OW 273
102246: ST_TO_ADDR
// if ValidHex ( x , y ) then
102247: LD_VAR 0 2
102251: PPUSH
102252: LD_VAR 0 3
102256: PPUSH
102257: CALL_OW 488
102261: IFFALSE 102296
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
102263: LD_VAR 0 1
102267: PPUSH
102268: LD_VAR 0 2
102272: PPUSH
102273: LD_VAR 0 3
102277: PPUSH
102278: LD_INT 3
102280: PPUSH
102281: LD_INT 6
102283: PPUSH
102284: CALL_OW 12
102288: PPUSH
102289: LD_INT 1
102291: PPUSH
102292: CALL_OW 483
// end ;
102296: GO 102156
102298: POP
102299: POP
// end ;
102300: PPOPN 5
102302: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
102303: LD_EXP 130
102307: PUSH
102308: LD_EXP 165
102312: AND
102313: IFFALSE 102407
102315: GO 102317
102317: DISABLE
102318: LD_INT 0
102320: PPUSH
102321: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
102322: LD_ADDR_VAR 0 2
102326: PUSH
102327: LD_INT 22
102329: PUSH
102330: LD_OWVAR 2
102334: PUSH
102335: EMPTY
102336: LIST
102337: LIST
102338: PUSH
102339: LD_INT 32
102341: PUSH
102342: LD_INT 1
102344: PUSH
102345: EMPTY
102346: LIST
102347: LIST
102348: PUSH
102349: LD_INT 21
102351: PUSH
102352: LD_INT 2
102354: PUSH
102355: EMPTY
102356: LIST
102357: LIST
102358: PUSH
102359: EMPTY
102360: LIST
102361: LIST
102362: LIST
102363: PPUSH
102364: CALL_OW 69
102368: ST_TO_ADDR
// if not tmp then
102369: LD_VAR 0 2
102373: NOT
102374: IFFALSE 102378
// exit ;
102376: GO 102407
// for i in tmp do
102378: LD_ADDR_VAR 0 1
102382: PUSH
102383: LD_VAR 0 2
102387: PUSH
102388: FOR_IN
102389: IFFALSE 102405
// SetFuel ( i , 0 ) ;
102391: LD_VAR 0 1
102395: PPUSH
102396: LD_INT 0
102398: PPUSH
102399: CALL_OW 240
102403: GO 102388
102405: POP
102406: POP
// end ;
102407: PPOPN 2
102409: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
102410: LD_EXP 130
102414: PUSH
102415: LD_EXP 166
102419: AND
102420: IFFALSE 102486
102422: GO 102424
102424: DISABLE
102425: LD_INT 0
102427: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
102428: LD_ADDR_VAR 0 1
102432: PUSH
102433: LD_INT 22
102435: PUSH
102436: LD_OWVAR 2
102440: PUSH
102441: EMPTY
102442: LIST
102443: LIST
102444: PUSH
102445: LD_INT 30
102447: PUSH
102448: LD_INT 29
102450: PUSH
102451: EMPTY
102452: LIST
102453: LIST
102454: PUSH
102455: EMPTY
102456: LIST
102457: LIST
102458: PPUSH
102459: CALL_OW 69
102463: ST_TO_ADDR
// if not tmp then
102464: LD_VAR 0 1
102468: NOT
102469: IFFALSE 102473
// exit ;
102471: GO 102486
// DestroyUnit ( tmp [ 1 ] ) ;
102473: LD_VAR 0 1
102477: PUSH
102478: LD_INT 1
102480: ARRAY
102481: PPUSH
102482: CALL_OW 65
// end ;
102486: PPOPN 1
102488: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
102489: LD_EXP 130
102493: PUSH
102494: LD_EXP 168
102498: AND
102499: IFFALSE 102628
102501: GO 102503
102503: DISABLE
102504: LD_INT 0
102506: PPUSH
// begin uc_side := 0 ;
102507: LD_ADDR_OWVAR 20
102511: PUSH
102512: LD_INT 0
102514: ST_TO_ADDR
// uc_nation := nation_arabian ;
102515: LD_ADDR_OWVAR 21
102519: PUSH
102520: LD_INT 2
102522: ST_TO_ADDR
// hc_gallery :=  ;
102523: LD_ADDR_OWVAR 33
102527: PUSH
102528: LD_STRING 
102530: ST_TO_ADDR
// hc_name :=  ;
102531: LD_ADDR_OWVAR 26
102535: PUSH
102536: LD_STRING 
102538: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
102539: LD_INT 1
102541: PPUSH
102542: LD_INT 11
102544: PPUSH
102545: LD_INT 10
102547: PPUSH
102548: CALL_OW 380
// un := CreateHuman ;
102552: LD_ADDR_VAR 0 1
102556: PUSH
102557: CALL_OW 44
102561: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102562: LD_VAR 0 1
102566: PPUSH
102567: LD_INT 1
102569: PPUSH
102570: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
102574: LD_INT 35
102576: PPUSH
102577: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
102581: LD_VAR 0 1
102585: PPUSH
102586: LD_INT 22
102588: PUSH
102589: LD_OWVAR 2
102593: PUSH
102594: EMPTY
102595: LIST
102596: LIST
102597: PPUSH
102598: CALL_OW 69
102602: PPUSH
102603: LD_VAR 0 1
102607: PPUSH
102608: CALL_OW 74
102612: PPUSH
102613: CALL_OW 115
// until IsDead ( un ) ;
102617: LD_VAR 0 1
102621: PPUSH
102622: CALL_OW 301
102626: IFFALSE 102574
// end ;
102628: PPOPN 1
102630: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
102631: LD_EXP 130
102635: PUSH
102636: LD_EXP 170
102640: AND
102641: IFFALSE 102653
102643: GO 102645
102645: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
102646: LD_STRING earthquake(getX(game), 0, 32)
102648: PPUSH
102649: CALL_OW 559
102653: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
102654: LD_EXP 130
102658: PUSH
102659: LD_EXP 171
102663: AND
102664: IFFALSE 102755
102666: GO 102668
102668: DISABLE
102669: LD_INT 0
102671: PPUSH
// begin enable ;
102672: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
102673: LD_ADDR_VAR 0 1
102677: PUSH
102678: LD_INT 22
102680: PUSH
102681: LD_OWVAR 2
102685: PUSH
102686: EMPTY
102687: LIST
102688: LIST
102689: PUSH
102690: LD_INT 21
102692: PUSH
102693: LD_INT 2
102695: PUSH
102696: EMPTY
102697: LIST
102698: LIST
102699: PUSH
102700: LD_INT 33
102702: PUSH
102703: LD_INT 3
102705: PUSH
102706: EMPTY
102707: LIST
102708: LIST
102709: PUSH
102710: EMPTY
102711: LIST
102712: LIST
102713: LIST
102714: PPUSH
102715: CALL_OW 69
102719: ST_TO_ADDR
// if not tmp then
102720: LD_VAR 0 1
102724: NOT
102725: IFFALSE 102729
// exit ;
102727: GO 102755
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
102729: LD_VAR 0 1
102733: PUSH
102734: LD_INT 1
102736: PPUSH
102737: LD_VAR 0 1
102741: PPUSH
102742: CALL_OW 12
102746: ARRAY
102747: PPUSH
102748: LD_INT 1
102750: PPUSH
102751: CALL_OW 234
// end ;
102755: PPOPN 1
102757: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
102758: LD_EXP 130
102762: PUSH
102763: LD_EXP 172
102767: AND
102768: IFFALSE 102909
102770: GO 102772
102772: DISABLE
102773: LD_INT 0
102775: PPUSH
102776: PPUSH
102777: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102778: LD_ADDR_VAR 0 3
102782: PUSH
102783: LD_INT 22
102785: PUSH
102786: LD_OWVAR 2
102790: PUSH
102791: EMPTY
102792: LIST
102793: LIST
102794: PUSH
102795: LD_INT 25
102797: PUSH
102798: LD_INT 1
102800: PUSH
102801: EMPTY
102802: LIST
102803: LIST
102804: PUSH
102805: EMPTY
102806: LIST
102807: LIST
102808: PPUSH
102809: CALL_OW 69
102813: ST_TO_ADDR
// if not tmp then
102814: LD_VAR 0 3
102818: NOT
102819: IFFALSE 102823
// exit ;
102821: GO 102909
// un := tmp [ rand ( 1 , tmp ) ] ;
102823: LD_ADDR_VAR 0 2
102827: PUSH
102828: LD_VAR 0 3
102832: PUSH
102833: LD_INT 1
102835: PPUSH
102836: LD_VAR 0 3
102840: PPUSH
102841: CALL_OW 12
102845: ARRAY
102846: ST_TO_ADDR
// if Crawls ( un ) then
102847: LD_VAR 0 2
102851: PPUSH
102852: CALL_OW 318
102856: IFFALSE 102867
// ComWalk ( un ) ;
102858: LD_VAR 0 2
102862: PPUSH
102863: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
102867: LD_VAR 0 2
102871: PPUSH
102872: LD_INT 9
102874: PPUSH
102875: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
102879: LD_INT 28
102881: PPUSH
102882: LD_OWVAR 2
102886: PPUSH
102887: LD_INT 2
102889: PPUSH
102890: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
102894: LD_INT 29
102896: PPUSH
102897: LD_OWVAR 2
102901: PPUSH
102902: LD_INT 2
102904: PPUSH
102905: CALL_OW 322
// end ;
102909: PPOPN 3
102911: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
102912: LD_EXP 130
102916: PUSH
102917: LD_EXP 173
102921: AND
102922: IFFALSE 103033
102924: GO 102926
102926: DISABLE
102927: LD_INT 0
102929: PPUSH
102930: PPUSH
102931: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102932: LD_ADDR_VAR 0 3
102936: PUSH
102937: LD_INT 22
102939: PUSH
102940: LD_OWVAR 2
102944: PUSH
102945: EMPTY
102946: LIST
102947: LIST
102948: PUSH
102949: LD_INT 25
102951: PUSH
102952: LD_INT 1
102954: PUSH
102955: EMPTY
102956: LIST
102957: LIST
102958: PUSH
102959: EMPTY
102960: LIST
102961: LIST
102962: PPUSH
102963: CALL_OW 69
102967: ST_TO_ADDR
// if not tmp then
102968: LD_VAR 0 3
102972: NOT
102973: IFFALSE 102977
// exit ;
102975: GO 103033
// un := tmp [ rand ( 1 , tmp ) ] ;
102977: LD_ADDR_VAR 0 2
102981: PUSH
102982: LD_VAR 0 3
102986: PUSH
102987: LD_INT 1
102989: PPUSH
102990: LD_VAR 0 3
102994: PPUSH
102995: CALL_OW 12
102999: ARRAY
103000: ST_TO_ADDR
// if Crawls ( un ) then
103001: LD_VAR 0 2
103005: PPUSH
103006: CALL_OW 318
103010: IFFALSE 103021
// ComWalk ( un ) ;
103012: LD_VAR 0 2
103016: PPUSH
103017: CALL_OW 138
// SetClass ( un , class_mortar ) ;
103021: LD_VAR 0 2
103025: PPUSH
103026: LD_INT 8
103028: PPUSH
103029: CALL_OW 336
// end ;
103033: PPOPN 3
103035: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
103036: LD_EXP 130
103040: PUSH
103041: LD_EXP 174
103045: AND
103046: IFFALSE 103190
103048: GO 103050
103050: DISABLE
103051: LD_INT 0
103053: PPUSH
103054: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
103055: LD_ADDR_VAR 0 2
103059: PUSH
103060: LD_INT 22
103062: PUSH
103063: LD_OWVAR 2
103067: PUSH
103068: EMPTY
103069: LIST
103070: LIST
103071: PUSH
103072: LD_INT 21
103074: PUSH
103075: LD_INT 2
103077: PUSH
103078: EMPTY
103079: LIST
103080: LIST
103081: PUSH
103082: LD_INT 2
103084: PUSH
103085: LD_INT 34
103087: PUSH
103088: LD_INT 12
103090: PUSH
103091: EMPTY
103092: LIST
103093: LIST
103094: PUSH
103095: LD_INT 34
103097: PUSH
103098: LD_INT 51
103100: PUSH
103101: EMPTY
103102: LIST
103103: LIST
103104: PUSH
103105: LD_INT 34
103107: PUSH
103108: LD_INT 32
103110: PUSH
103111: EMPTY
103112: LIST
103113: LIST
103114: PUSH
103115: EMPTY
103116: LIST
103117: LIST
103118: LIST
103119: LIST
103120: PUSH
103121: EMPTY
103122: LIST
103123: LIST
103124: LIST
103125: PPUSH
103126: CALL_OW 69
103130: ST_TO_ADDR
// if not tmp then
103131: LD_VAR 0 2
103135: NOT
103136: IFFALSE 103140
// exit ;
103138: GO 103190
// for i in tmp do
103140: LD_ADDR_VAR 0 1
103144: PUSH
103145: LD_VAR 0 2
103149: PUSH
103150: FOR_IN
103151: IFFALSE 103188
// if GetCargo ( i , mat_artifact ) = 0 then
103153: LD_VAR 0 1
103157: PPUSH
103158: LD_INT 4
103160: PPUSH
103161: CALL_OW 289
103165: PUSH
103166: LD_INT 0
103168: EQUAL
103169: IFFALSE 103186
// SetCargo ( i , mat_siberit , 100 ) ;
103171: LD_VAR 0 1
103175: PPUSH
103176: LD_INT 3
103178: PPUSH
103179: LD_INT 100
103181: PPUSH
103182: CALL_OW 290
103186: GO 103150
103188: POP
103189: POP
// end ;
103190: PPOPN 2
103192: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
103193: LD_EXP 130
103197: PUSH
103198: LD_EXP 175
103202: AND
103203: IFFALSE 103356
103205: GO 103207
103207: DISABLE
103208: LD_INT 0
103210: PPUSH
103211: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
103212: LD_ADDR_VAR 0 2
103216: PUSH
103217: LD_INT 22
103219: PUSH
103220: LD_OWVAR 2
103224: PUSH
103225: EMPTY
103226: LIST
103227: LIST
103228: PPUSH
103229: CALL_OW 69
103233: ST_TO_ADDR
// if not tmp then
103234: LD_VAR 0 2
103238: NOT
103239: IFFALSE 103243
// exit ;
103241: GO 103356
// for i := 1 to 2 do
103243: LD_ADDR_VAR 0 1
103247: PUSH
103248: DOUBLE
103249: LD_INT 1
103251: DEC
103252: ST_TO_ADDR
103253: LD_INT 2
103255: PUSH
103256: FOR_TO
103257: IFFALSE 103354
// begin uc_side := your_side ;
103259: LD_ADDR_OWVAR 20
103263: PUSH
103264: LD_OWVAR 2
103268: ST_TO_ADDR
// uc_nation := nation_american ;
103269: LD_ADDR_OWVAR 21
103273: PUSH
103274: LD_INT 1
103276: ST_TO_ADDR
// vc_chassis := us_morphling ;
103277: LD_ADDR_OWVAR 37
103281: PUSH
103282: LD_INT 5
103284: ST_TO_ADDR
// vc_engine := engine_siberite ;
103285: LD_ADDR_OWVAR 39
103289: PUSH
103290: LD_INT 3
103292: ST_TO_ADDR
// vc_control := control_computer ;
103293: LD_ADDR_OWVAR 38
103297: PUSH
103298: LD_INT 3
103300: ST_TO_ADDR
// vc_weapon := us_double_laser ;
103301: LD_ADDR_OWVAR 40
103305: PUSH
103306: LD_INT 10
103308: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
103309: CALL_OW 45
103313: PPUSH
103314: LD_VAR 0 2
103318: PUSH
103319: LD_INT 1
103321: ARRAY
103322: PPUSH
103323: CALL_OW 250
103327: PPUSH
103328: LD_VAR 0 2
103332: PUSH
103333: LD_INT 1
103335: ARRAY
103336: PPUSH
103337: CALL_OW 251
103341: PPUSH
103342: LD_INT 12
103344: PPUSH
103345: LD_INT 1
103347: PPUSH
103348: CALL_OW 50
// end ;
103352: GO 103256
103354: POP
103355: POP
// end ;
103356: PPOPN 2
103358: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
103359: LD_EXP 130
103363: PUSH
103364: LD_EXP 176
103368: AND
103369: IFFALSE 103591
103371: GO 103373
103373: DISABLE
103374: LD_INT 0
103376: PPUSH
103377: PPUSH
103378: PPUSH
103379: PPUSH
103380: PPUSH
103381: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103382: LD_ADDR_VAR 0 6
103386: PUSH
103387: LD_INT 22
103389: PUSH
103390: LD_OWVAR 2
103394: PUSH
103395: EMPTY
103396: LIST
103397: LIST
103398: PUSH
103399: LD_INT 21
103401: PUSH
103402: LD_INT 1
103404: PUSH
103405: EMPTY
103406: LIST
103407: LIST
103408: PUSH
103409: LD_INT 3
103411: PUSH
103412: LD_INT 23
103414: PUSH
103415: LD_INT 0
103417: PUSH
103418: EMPTY
103419: LIST
103420: LIST
103421: PUSH
103422: EMPTY
103423: LIST
103424: LIST
103425: PUSH
103426: EMPTY
103427: LIST
103428: LIST
103429: LIST
103430: PPUSH
103431: CALL_OW 69
103435: ST_TO_ADDR
// if not tmp then
103436: LD_VAR 0 6
103440: NOT
103441: IFFALSE 103445
// exit ;
103443: GO 103591
// s1 := rand ( 1 , 4 ) ;
103445: LD_ADDR_VAR 0 2
103449: PUSH
103450: LD_INT 1
103452: PPUSH
103453: LD_INT 4
103455: PPUSH
103456: CALL_OW 12
103460: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
103461: LD_ADDR_VAR 0 4
103465: PUSH
103466: LD_VAR 0 6
103470: PUSH
103471: LD_INT 1
103473: ARRAY
103474: PPUSH
103475: LD_VAR 0 2
103479: PPUSH
103480: CALL_OW 259
103484: ST_TO_ADDR
// if s1 = 1 then
103485: LD_VAR 0 2
103489: PUSH
103490: LD_INT 1
103492: EQUAL
103493: IFFALSE 103513
// s2 := rand ( 2 , 4 ) else
103495: LD_ADDR_VAR 0 3
103499: PUSH
103500: LD_INT 2
103502: PPUSH
103503: LD_INT 4
103505: PPUSH
103506: CALL_OW 12
103510: ST_TO_ADDR
103511: GO 103521
// s2 := 1 ;
103513: LD_ADDR_VAR 0 3
103517: PUSH
103518: LD_INT 1
103520: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
103521: LD_ADDR_VAR 0 5
103525: PUSH
103526: LD_VAR 0 6
103530: PUSH
103531: LD_INT 1
103533: ARRAY
103534: PPUSH
103535: LD_VAR 0 3
103539: PPUSH
103540: CALL_OW 259
103544: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
103545: LD_VAR 0 6
103549: PUSH
103550: LD_INT 1
103552: ARRAY
103553: PPUSH
103554: LD_VAR 0 2
103558: PPUSH
103559: LD_VAR 0 5
103563: PPUSH
103564: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
103568: LD_VAR 0 6
103572: PUSH
103573: LD_INT 1
103575: ARRAY
103576: PPUSH
103577: LD_VAR 0 3
103581: PPUSH
103582: LD_VAR 0 4
103586: PPUSH
103587: CALL_OW 237
// end ;
103591: PPOPN 6
103593: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
103594: LD_EXP 130
103598: PUSH
103599: LD_EXP 177
103603: AND
103604: IFFALSE 103683
103606: GO 103608
103608: DISABLE
103609: LD_INT 0
103611: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
103612: LD_ADDR_VAR 0 1
103616: PUSH
103617: LD_INT 22
103619: PUSH
103620: LD_OWVAR 2
103624: PUSH
103625: EMPTY
103626: LIST
103627: LIST
103628: PUSH
103629: LD_INT 30
103631: PUSH
103632: LD_INT 3
103634: PUSH
103635: EMPTY
103636: LIST
103637: LIST
103638: PUSH
103639: EMPTY
103640: LIST
103641: LIST
103642: PPUSH
103643: CALL_OW 69
103647: ST_TO_ADDR
// if not tmp then
103648: LD_VAR 0 1
103652: NOT
103653: IFFALSE 103657
// exit ;
103655: GO 103683
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
103657: LD_VAR 0 1
103661: PUSH
103662: LD_INT 1
103664: PPUSH
103665: LD_VAR 0 1
103669: PPUSH
103670: CALL_OW 12
103674: ARRAY
103675: PPUSH
103676: LD_INT 1
103678: PPUSH
103679: CALL_OW 234
// end ;
103683: PPOPN 1
103685: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
103686: LD_EXP 130
103690: PUSH
103691: LD_EXP 178
103695: AND
103696: IFFALSE 103808
103698: GO 103700
103700: DISABLE
103701: LD_INT 0
103703: PPUSH
103704: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
103705: LD_ADDR_VAR 0 2
103709: PUSH
103710: LD_INT 22
103712: PUSH
103713: LD_OWVAR 2
103717: PUSH
103718: EMPTY
103719: LIST
103720: LIST
103721: PUSH
103722: LD_INT 2
103724: PUSH
103725: LD_INT 30
103727: PUSH
103728: LD_INT 27
103730: PUSH
103731: EMPTY
103732: LIST
103733: LIST
103734: PUSH
103735: LD_INT 30
103737: PUSH
103738: LD_INT 26
103740: PUSH
103741: EMPTY
103742: LIST
103743: LIST
103744: PUSH
103745: LD_INT 30
103747: PUSH
103748: LD_INT 28
103750: PUSH
103751: EMPTY
103752: LIST
103753: LIST
103754: PUSH
103755: EMPTY
103756: LIST
103757: LIST
103758: LIST
103759: LIST
103760: PUSH
103761: EMPTY
103762: LIST
103763: LIST
103764: PPUSH
103765: CALL_OW 69
103769: ST_TO_ADDR
// if not tmp then
103770: LD_VAR 0 2
103774: NOT
103775: IFFALSE 103779
// exit ;
103777: GO 103808
// for i in tmp do
103779: LD_ADDR_VAR 0 1
103783: PUSH
103784: LD_VAR 0 2
103788: PUSH
103789: FOR_IN
103790: IFFALSE 103806
// SetLives ( i , 1 ) ;
103792: LD_VAR 0 1
103796: PPUSH
103797: LD_INT 1
103799: PPUSH
103800: CALL_OW 234
103804: GO 103789
103806: POP
103807: POP
// end ;
103808: PPOPN 2
103810: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
103811: LD_EXP 130
103815: PUSH
103816: LD_EXP 179
103820: AND
103821: IFFALSE 104095
103823: GO 103825
103825: DISABLE
103826: LD_INT 0
103828: PPUSH
103829: PPUSH
103830: PPUSH
// begin i := rand ( 1 , 7 ) ;
103831: LD_ADDR_VAR 0 1
103835: PUSH
103836: LD_INT 1
103838: PPUSH
103839: LD_INT 7
103841: PPUSH
103842: CALL_OW 12
103846: ST_TO_ADDR
// case i of 1 :
103847: LD_VAR 0 1
103851: PUSH
103852: LD_INT 1
103854: DOUBLE
103855: EQUAL
103856: IFTRUE 103860
103858: GO 103870
103860: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
103861: LD_STRING earthquake(getX(game), 0, 32)
103863: PPUSH
103864: CALL_OW 559
103868: GO 104095
103870: LD_INT 2
103872: DOUBLE
103873: EQUAL
103874: IFTRUE 103878
103876: GO 103892
103878: POP
// begin ToLua ( displayStucuk(); ) ;
103879: LD_STRING displayStucuk();
103881: PPUSH
103882: CALL_OW 559
// ResetFog ;
103886: CALL_OW 335
// end ; 3 :
103890: GO 104095
103892: LD_INT 3
103894: DOUBLE
103895: EQUAL
103896: IFTRUE 103900
103898: GO 104004
103900: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103901: LD_ADDR_VAR 0 2
103905: PUSH
103906: LD_INT 22
103908: PUSH
103909: LD_OWVAR 2
103913: PUSH
103914: EMPTY
103915: LIST
103916: LIST
103917: PUSH
103918: LD_INT 25
103920: PUSH
103921: LD_INT 1
103923: PUSH
103924: EMPTY
103925: LIST
103926: LIST
103927: PUSH
103928: EMPTY
103929: LIST
103930: LIST
103931: PPUSH
103932: CALL_OW 69
103936: ST_TO_ADDR
// if not tmp then
103937: LD_VAR 0 2
103941: NOT
103942: IFFALSE 103946
// exit ;
103944: GO 104095
// un := tmp [ rand ( 1 , tmp ) ] ;
103946: LD_ADDR_VAR 0 3
103950: PUSH
103951: LD_VAR 0 2
103955: PUSH
103956: LD_INT 1
103958: PPUSH
103959: LD_VAR 0 2
103963: PPUSH
103964: CALL_OW 12
103968: ARRAY
103969: ST_TO_ADDR
// if Crawls ( un ) then
103970: LD_VAR 0 3
103974: PPUSH
103975: CALL_OW 318
103979: IFFALSE 103990
// ComWalk ( un ) ;
103981: LD_VAR 0 3
103985: PPUSH
103986: CALL_OW 138
// SetClass ( un , class_mortar ) ;
103990: LD_VAR 0 3
103994: PPUSH
103995: LD_INT 8
103997: PPUSH
103998: CALL_OW 336
// end ; 4 :
104002: GO 104095
104004: LD_INT 4
104006: DOUBLE
104007: EQUAL
104008: IFTRUE 104012
104010: GO 104073
104012: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
104013: LD_ADDR_VAR 0 2
104017: PUSH
104018: LD_INT 22
104020: PUSH
104021: LD_OWVAR 2
104025: PUSH
104026: EMPTY
104027: LIST
104028: LIST
104029: PUSH
104030: LD_INT 30
104032: PUSH
104033: LD_INT 29
104035: PUSH
104036: EMPTY
104037: LIST
104038: LIST
104039: PUSH
104040: EMPTY
104041: LIST
104042: LIST
104043: PPUSH
104044: CALL_OW 69
104048: ST_TO_ADDR
// if not tmp then
104049: LD_VAR 0 2
104053: NOT
104054: IFFALSE 104058
// exit ;
104056: GO 104095
// DestroyUnit ( tmp [ 1 ] ) ;
104058: LD_VAR 0 2
104062: PUSH
104063: LD_INT 1
104065: ARRAY
104066: PPUSH
104067: CALL_OW 65
// end ; 5 .. 7 :
104071: GO 104095
104073: LD_INT 5
104075: DOUBLE
104076: GREATEREQUAL
104077: IFFALSE 104085
104079: LD_INT 7
104081: DOUBLE
104082: LESSEQUAL
104083: IFTRUE 104087
104085: GO 104094
104087: POP
// StreamSibBomb ; end ;
104088: CALL 100375 0 0
104092: GO 104095
104094: POP
// end ;
104095: PPOPN 3
104097: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
104098: LD_EXP 130
104102: PUSH
104103: LD_EXP 180
104107: AND
104108: IFFALSE 104264
104110: GO 104112
104112: DISABLE
104113: LD_INT 0
104115: PPUSH
104116: PPUSH
104117: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
104118: LD_ADDR_VAR 0 2
104122: PUSH
104123: LD_INT 81
104125: PUSH
104126: LD_OWVAR 2
104130: PUSH
104131: EMPTY
104132: LIST
104133: LIST
104134: PUSH
104135: LD_INT 2
104137: PUSH
104138: LD_INT 21
104140: PUSH
104141: LD_INT 1
104143: PUSH
104144: EMPTY
104145: LIST
104146: LIST
104147: PUSH
104148: LD_INT 21
104150: PUSH
104151: LD_INT 2
104153: PUSH
104154: EMPTY
104155: LIST
104156: LIST
104157: PUSH
104158: EMPTY
104159: LIST
104160: LIST
104161: LIST
104162: PUSH
104163: EMPTY
104164: LIST
104165: LIST
104166: PPUSH
104167: CALL_OW 69
104171: ST_TO_ADDR
// if not tmp then
104172: LD_VAR 0 2
104176: NOT
104177: IFFALSE 104181
// exit ;
104179: GO 104264
// p := 0 ;
104181: LD_ADDR_VAR 0 3
104185: PUSH
104186: LD_INT 0
104188: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
104189: LD_INT 35
104191: PPUSH
104192: CALL_OW 67
// p := p + 1 ;
104196: LD_ADDR_VAR 0 3
104200: PUSH
104201: LD_VAR 0 3
104205: PUSH
104206: LD_INT 1
104208: PLUS
104209: ST_TO_ADDR
// for i in tmp do
104210: LD_ADDR_VAR 0 1
104214: PUSH
104215: LD_VAR 0 2
104219: PUSH
104220: FOR_IN
104221: IFFALSE 104252
// if GetLives ( i ) < 1000 then
104223: LD_VAR 0 1
104227: PPUSH
104228: CALL_OW 256
104232: PUSH
104233: LD_INT 1000
104235: LESS
104236: IFFALSE 104250
// SetLives ( i , 1000 ) ;
104238: LD_VAR 0 1
104242: PPUSH
104243: LD_INT 1000
104245: PPUSH
104246: CALL_OW 234
104250: GO 104220
104252: POP
104253: POP
// until p > 20 ;
104254: LD_VAR 0 3
104258: PUSH
104259: LD_INT 20
104261: GREATER
104262: IFFALSE 104189
// end ;
104264: PPOPN 3
104266: END
// every 0 0$1 trigger StreamModeActive and sTime do
104267: LD_EXP 130
104271: PUSH
104272: LD_EXP 181
104276: AND
104277: IFFALSE 104312
104279: GO 104281
104281: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
104282: LD_INT 28
104284: PPUSH
104285: LD_OWVAR 2
104289: PPUSH
104290: LD_INT 2
104292: PPUSH
104293: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
104297: LD_INT 30
104299: PPUSH
104300: LD_OWVAR 2
104304: PPUSH
104305: LD_INT 2
104307: PPUSH
104308: CALL_OW 322
// end ;
104312: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
104313: LD_EXP 130
104317: PUSH
104318: LD_EXP 182
104322: AND
104323: IFFALSE 104444
104325: GO 104327
104327: DISABLE
104328: LD_INT 0
104330: PPUSH
104331: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
104332: LD_ADDR_VAR 0 2
104336: PUSH
104337: LD_INT 22
104339: PUSH
104340: LD_OWVAR 2
104344: PUSH
104345: EMPTY
104346: LIST
104347: LIST
104348: PUSH
104349: LD_INT 21
104351: PUSH
104352: LD_INT 1
104354: PUSH
104355: EMPTY
104356: LIST
104357: LIST
104358: PUSH
104359: LD_INT 3
104361: PUSH
104362: LD_INT 23
104364: PUSH
104365: LD_INT 0
104367: PUSH
104368: EMPTY
104369: LIST
104370: LIST
104371: PUSH
104372: EMPTY
104373: LIST
104374: LIST
104375: PUSH
104376: EMPTY
104377: LIST
104378: LIST
104379: LIST
104380: PPUSH
104381: CALL_OW 69
104385: ST_TO_ADDR
// if not tmp then
104386: LD_VAR 0 2
104390: NOT
104391: IFFALSE 104395
// exit ;
104393: GO 104444
// for i in tmp do
104395: LD_ADDR_VAR 0 1
104399: PUSH
104400: LD_VAR 0 2
104404: PUSH
104405: FOR_IN
104406: IFFALSE 104442
// begin if Crawls ( i ) then
104408: LD_VAR 0 1
104412: PPUSH
104413: CALL_OW 318
104417: IFFALSE 104428
// ComWalk ( i ) ;
104419: LD_VAR 0 1
104423: PPUSH
104424: CALL_OW 138
// SetClass ( i , 2 ) ;
104428: LD_VAR 0 1
104432: PPUSH
104433: LD_INT 2
104435: PPUSH
104436: CALL_OW 336
// end ;
104440: GO 104405
104442: POP
104443: POP
// end ;
104444: PPOPN 2
104446: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
104447: LD_EXP 130
104451: PUSH
104452: LD_EXP 183
104456: AND
104457: IFFALSE 104738
104459: GO 104461
104461: DISABLE
104462: LD_INT 0
104464: PPUSH
104465: PPUSH
104466: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
104467: LD_OWVAR 2
104471: PPUSH
104472: LD_INT 9
104474: PPUSH
104475: LD_INT 1
104477: PPUSH
104478: LD_INT 1
104480: PPUSH
104481: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
104485: LD_INT 9
104487: PPUSH
104488: LD_OWVAR 2
104492: PPUSH
104493: CALL_OW 343
// uc_side := 9 ;
104497: LD_ADDR_OWVAR 20
104501: PUSH
104502: LD_INT 9
104504: ST_TO_ADDR
// uc_nation := 2 ;
104505: LD_ADDR_OWVAR 21
104509: PUSH
104510: LD_INT 2
104512: ST_TO_ADDR
// hc_name := Dark Warrior ;
104513: LD_ADDR_OWVAR 26
104517: PUSH
104518: LD_STRING Dark Warrior
104520: ST_TO_ADDR
// hc_gallery :=  ;
104521: LD_ADDR_OWVAR 33
104525: PUSH
104526: LD_STRING 
104528: ST_TO_ADDR
// hc_noskilllimit := true ;
104529: LD_ADDR_OWVAR 76
104533: PUSH
104534: LD_INT 1
104536: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
104537: LD_ADDR_OWVAR 31
104541: PUSH
104542: LD_INT 30
104544: PUSH
104545: LD_INT 30
104547: PUSH
104548: LD_INT 30
104550: PUSH
104551: LD_INT 30
104553: PUSH
104554: EMPTY
104555: LIST
104556: LIST
104557: LIST
104558: LIST
104559: ST_TO_ADDR
// un := CreateHuman ;
104560: LD_ADDR_VAR 0 3
104564: PUSH
104565: CALL_OW 44
104569: ST_TO_ADDR
// hc_noskilllimit := false ;
104570: LD_ADDR_OWVAR 76
104574: PUSH
104575: LD_INT 0
104577: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
104578: LD_VAR 0 3
104582: PPUSH
104583: LD_INT 1
104585: PPUSH
104586: CALL_OW 51
// p := 0 ;
104590: LD_ADDR_VAR 0 2
104594: PUSH
104595: LD_INT 0
104597: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
104598: LD_INT 35
104600: PPUSH
104601: CALL_OW 67
// p := p + 1 ;
104605: LD_ADDR_VAR 0 2
104609: PUSH
104610: LD_VAR 0 2
104614: PUSH
104615: LD_INT 1
104617: PLUS
104618: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
104619: LD_VAR 0 3
104623: PPUSH
104624: CALL_OW 256
104628: PUSH
104629: LD_INT 1000
104631: LESS
104632: IFFALSE 104646
// SetLives ( un , 1000 ) ;
104634: LD_VAR 0 3
104638: PPUSH
104639: LD_INT 1000
104641: PPUSH
104642: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
104646: LD_VAR 0 3
104650: PPUSH
104651: LD_INT 81
104653: PUSH
104654: LD_OWVAR 2
104658: PUSH
104659: EMPTY
104660: LIST
104661: LIST
104662: PUSH
104663: LD_INT 91
104665: PUSH
104666: LD_VAR 0 3
104670: PUSH
104671: LD_INT 30
104673: PUSH
104674: EMPTY
104675: LIST
104676: LIST
104677: LIST
104678: PUSH
104679: EMPTY
104680: LIST
104681: LIST
104682: PPUSH
104683: CALL_OW 69
104687: PPUSH
104688: LD_VAR 0 3
104692: PPUSH
104693: CALL_OW 74
104697: PPUSH
104698: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
104702: LD_VAR 0 2
104706: PUSH
104707: LD_INT 60
104709: GREATER
104710: PUSH
104711: LD_VAR 0 3
104715: PPUSH
104716: CALL_OW 301
104720: OR
104721: IFFALSE 104598
// if un then
104723: LD_VAR 0 3
104727: IFFALSE 104738
// RemoveUnit ( un ) ;
104729: LD_VAR 0 3
104733: PPUSH
104734: CALL_OW 64
// end ; end_of_file
104738: PPOPN 3
104740: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
104741: LD_INT 0
104743: PPUSH
104744: PPUSH
104745: PPUSH
104746: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
104747: LD_VAR 0 1
104751: PPUSH
104752: CALL_OW 264
104756: PUSH
104757: LD_EXP 76
104761: EQUAL
104762: IFFALSE 104834
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
104764: LD_INT 68
104766: PPUSH
104767: LD_VAR 0 1
104771: PPUSH
104772: CALL_OW 255
104776: PPUSH
104777: CALL_OW 321
104781: PUSH
104782: LD_INT 2
104784: EQUAL
104785: IFFALSE 104797
// eff := 70 else
104787: LD_ADDR_VAR 0 4
104791: PUSH
104792: LD_INT 70
104794: ST_TO_ADDR
104795: GO 104805
// eff := 30 ;
104797: LD_ADDR_VAR 0 4
104801: PUSH
104802: LD_INT 30
104804: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
104805: LD_VAR 0 1
104809: PPUSH
104810: CALL_OW 250
104814: PPUSH
104815: LD_VAR 0 1
104819: PPUSH
104820: CALL_OW 251
104824: PPUSH
104825: LD_VAR 0 4
104829: PPUSH
104830: CALL_OW 495
// end ; end ;
104834: LD_VAR 0 2
104838: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
104839: LD_INT 0
104841: PPUSH
// end ;
104842: LD_VAR 0 4
104846: RET
// export function SOS_Command ( cmd ) ; begin
104847: LD_INT 0
104849: PPUSH
// end ;
104850: LD_VAR 0 2
104854: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
104855: LD_VAR 0 1
104859: PUSH
104860: LD_INT 255
104862: EQUAL
104863: PUSH
104864: LD_VAR 0 2
104868: PPUSH
104869: CALL_OW 264
104873: PUSH
104874: LD_INT 14
104876: PUSH
104877: LD_INT 53
104879: PUSH
104880: EMPTY
104881: LIST
104882: LIST
104883: IN
104884: AND
104885: PUSH
104886: LD_VAR 0 4
104890: PPUSH
104891: LD_VAR 0 5
104895: PPUSH
104896: CALL_OW 488
104900: AND
104901: IFFALSE 104925
// CutTreeXYR ( unit , x , y , 12 ) ;
104903: LD_VAR 0 2
104907: PPUSH
104908: LD_VAR 0 4
104912: PPUSH
104913: LD_VAR 0 5
104917: PPUSH
104918: LD_INT 12
104920: PPUSH
104921: CALL 104928 0 4
// end ;
104925: PPOPN 5
104927: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
104928: LD_INT 0
104930: PPUSH
104931: PPUSH
104932: PPUSH
104933: PPUSH
104934: PPUSH
104935: PPUSH
104936: PPUSH
104937: PPUSH
104938: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
104939: LD_VAR 0 1
104943: NOT
104944: PUSH
104945: LD_VAR 0 2
104949: PPUSH
104950: LD_VAR 0 3
104954: PPUSH
104955: CALL_OW 488
104959: NOT
104960: OR
104961: PUSH
104962: LD_VAR 0 4
104966: NOT
104967: OR
104968: IFFALSE 104972
// exit ;
104970: GO 105312
// list := [ ] ;
104972: LD_ADDR_VAR 0 13
104976: PUSH
104977: EMPTY
104978: ST_TO_ADDR
// if x - r < 0 then
104979: LD_VAR 0 2
104983: PUSH
104984: LD_VAR 0 4
104988: MINUS
104989: PUSH
104990: LD_INT 0
104992: LESS
104993: IFFALSE 105005
// min_x := 0 else
104995: LD_ADDR_VAR 0 7
104999: PUSH
105000: LD_INT 0
105002: ST_TO_ADDR
105003: GO 105021
// min_x := x - r ;
105005: LD_ADDR_VAR 0 7
105009: PUSH
105010: LD_VAR 0 2
105014: PUSH
105015: LD_VAR 0 4
105019: MINUS
105020: ST_TO_ADDR
// if y - r < 0 then
105021: LD_VAR 0 3
105025: PUSH
105026: LD_VAR 0 4
105030: MINUS
105031: PUSH
105032: LD_INT 0
105034: LESS
105035: IFFALSE 105047
// min_y := 0 else
105037: LD_ADDR_VAR 0 8
105041: PUSH
105042: LD_INT 0
105044: ST_TO_ADDR
105045: GO 105063
// min_y := y - r ;
105047: LD_ADDR_VAR 0 8
105051: PUSH
105052: LD_VAR 0 3
105056: PUSH
105057: LD_VAR 0 4
105061: MINUS
105062: ST_TO_ADDR
// max_x := x + r ;
105063: LD_ADDR_VAR 0 9
105067: PUSH
105068: LD_VAR 0 2
105072: PUSH
105073: LD_VAR 0 4
105077: PLUS
105078: ST_TO_ADDR
// max_y := y + r ;
105079: LD_ADDR_VAR 0 10
105083: PUSH
105084: LD_VAR 0 3
105088: PUSH
105089: LD_VAR 0 4
105093: PLUS
105094: ST_TO_ADDR
// for _x = min_x to max_x do
105095: LD_ADDR_VAR 0 11
105099: PUSH
105100: DOUBLE
105101: LD_VAR 0 7
105105: DEC
105106: ST_TO_ADDR
105107: LD_VAR 0 9
105111: PUSH
105112: FOR_TO
105113: IFFALSE 105230
// for _y = min_y to max_y do
105115: LD_ADDR_VAR 0 12
105119: PUSH
105120: DOUBLE
105121: LD_VAR 0 8
105125: DEC
105126: ST_TO_ADDR
105127: LD_VAR 0 10
105131: PUSH
105132: FOR_TO
105133: IFFALSE 105226
// begin if not ValidHex ( _x , _y ) then
105135: LD_VAR 0 11
105139: PPUSH
105140: LD_VAR 0 12
105144: PPUSH
105145: CALL_OW 488
105149: NOT
105150: IFFALSE 105154
// continue ;
105152: GO 105132
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
105154: LD_VAR 0 11
105158: PPUSH
105159: LD_VAR 0 12
105163: PPUSH
105164: CALL_OW 351
105168: PUSH
105169: LD_VAR 0 11
105173: PPUSH
105174: LD_VAR 0 12
105178: PPUSH
105179: CALL_OW 554
105183: AND
105184: IFFALSE 105224
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
105186: LD_ADDR_VAR 0 13
105190: PUSH
105191: LD_VAR 0 13
105195: PPUSH
105196: LD_VAR 0 13
105200: PUSH
105201: LD_INT 1
105203: PLUS
105204: PPUSH
105205: LD_VAR 0 11
105209: PUSH
105210: LD_VAR 0 12
105214: PUSH
105215: EMPTY
105216: LIST
105217: LIST
105218: PPUSH
105219: CALL_OW 2
105223: ST_TO_ADDR
// end ;
105224: GO 105132
105226: POP
105227: POP
105228: GO 105112
105230: POP
105231: POP
// if not list then
105232: LD_VAR 0 13
105236: NOT
105237: IFFALSE 105241
// exit ;
105239: GO 105312
// for i in list do
105241: LD_ADDR_VAR 0 6
105245: PUSH
105246: LD_VAR 0 13
105250: PUSH
105251: FOR_IN
105252: IFFALSE 105310
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
105254: LD_VAR 0 1
105258: PPUSH
105259: LD_STRING M
105261: PUSH
105262: LD_VAR 0 6
105266: PUSH
105267: LD_INT 1
105269: ARRAY
105270: PUSH
105271: LD_VAR 0 6
105275: PUSH
105276: LD_INT 2
105278: ARRAY
105279: PUSH
105280: LD_INT 0
105282: PUSH
105283: LD_INT 0
105285: PUSH
105286: LD_INT 0
105288: PUSH
105289: LD_INT 0
105291: PUSH
105292: EMPTY
105293: LIST
105294: LIST
105295: LIST
105296: LIST
105297: LIST
105298: LIST
105299: LIST
105300: PUSH
105301: EMPTY
105302: LIST
105303: PPUSH
105304: CALL_OW 447
105308: GO 105251
105310: POP
105311: POP
// end ;
105312: LD_VAR 0 5
105316: RET
